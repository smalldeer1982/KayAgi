# [COCI 2016/2017 #5] Strelice

## 题目描述

Hansel 和 Gretel 正在玩「箭头游戏」。

该游戏在一个 $R$ 行 $S$ 列的棋盘上进行。其中每一个棋格内有一个箭头（$\leftarrow$、$\rightarrow$、$\uparrow$、$\downarrow$ 之一）。

游戏开始后，Hansel 可以选择任意 $K$ 个**不位于最后一列的**棋格进行填涂。接着，Gretel 可以选择**第一列的**任意一个棋格，作为机器人的初始棋格。机器人在放置到初始棋格后将按照箭头的指示自动行走。机器人一旦走到了最后一列，它将立即停止行走。

判定输赢的方式如下：

- 如果机器人在有限的时间内停在了最后一列，那么：当且仅当机器人恰好经过一个有色棋格时，判定 Hansel 获胜，否则 Gretel 获胜。
- 如果机器人无法停止行走（即处于无限循环的状态），那么判定 Hansel 获胜。

规定机器人经过的棋格包括初始棋格、终止棋格以及路径上的其它所有棋格。同时，数据保证箭头不会指向棋盘外部。

你的任务是判断 Hansel 是否有必胜的方案（即对于 Gretel 所选择的任意一个合法的初始棋格，Hansel 的填涂方案都可以使自己获胜）。如果有必胜的方案，输出该方案；否则输出 $-1$。

## 说明/提示

**【样例 1 解释】**

填涂 $(4,2)$ 后，无论初始棋格位于第一列的哪里，机器人都会经过 $(4,2)$。

**【样例 2 解释】**

由于需要填涂 $2$ 个棋格，因此至少有一行没有有色棋格。只要 Gretel 选择没有有色棋格的那一行的第一列放置机器人，Gretel 就会获胜。

**【样例 3 图解】**

![](https://cdn.luogu.com.cn/upload/image_hosting/oy6p59p5.png?x-oss-process=image/resize,m_lfit,h_200)

**【数据规模与约定】**

对于 $100\%$ 的数据，$1 \le R \times S \le 10^6$，$1 \le K \le 50$，$1 \le A \le R$，$1 \le B \lt S$。

**【提示与说明】**

欢迎大家通过私信或发帖对自行编写的 [Special Judge](https://www.luogu.com.cn/paste/k9jt7zoy) 进行 hack。

**题目译自 [COCI 2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #5](https://hsin.hr/coci/archive/2016_2017/contest5_tasks.pdf) _T6 Strelice_。**

**本题分值按 COCI 原题设置，满分 $160$。**

## 样例 #1

### 输入

```
4 3 1
DRD
DUD
DUD
RUL```

### 输出

```
4 2```

## 样例 #2

### 输入

```
3 3 2
RRR
RRR
RRR```

### 输出

```
-1```

## 样例 #3

### 输入

```
4 4 2
RRDL
RRDL
DLRD
RRRL```

### 输出

```
2 3
4 1```

# 题解

## 作者：Feyn (赞：4)

[link](https://www.luogu.com.cn/problem/P8018)

首先给每个点和它指向的点连边之后会形成一片内向基环树森林，毕竟题目中保证了不会指向矩形外的区域（虽然样例二似乎打破了这个限制但无伤大雅）。而题目中 Hansel 获胜的两种方法可以表示为：

- 从第一列某个点到最后一列某个点的路上恰好有一个彩色方块。
- 第一列某个点所在的基环树上压根没有最后一列的结点。

对于第二种情况大可以不管它，因为给这些节点染多少色都是合法的。那么对于第一种情况，基环树上路径是令人难受的。但众所周知，树加边等于基环树，换句话说基环树减边等于树。而根据题目中的设定，机器人到最后一行之后就不会再移动了（所以给最后一行的箭头干嘛呀对吧），那么我们可以把这条边断掉，这样我们就获得了一棵以最后一列结点为根的树。

这样处理完了之后呢，根据题意树上有那么一些特殊的结点（也就是第一列的结点），我们希望给树上的某些结点染色（树根是不能染色哒），然后使得每个特殊节点到树根的路径上刚好有一个染色结点。然后发现考虑每个特殊节点能被哪些点管辖到是复杂的，而考虑每个点能影响哪些特殊点是简单的，于是问题就变成了每个点能管辖一些点，要求选出一些点使得每个特殊点恰好被管辖一次。

考试完瞟了一眼官方题解，说可以用 bitmasks （位掩码）来加速这一过程，但明显我那么弱是不会这种高级东西的。如果做过同为 COCI 的 [Burza](https://www.luogu.com.cn/problem/P6499) 的话会发现二者最后的处理方法惊人的相似（说不定是同一个出题人出的呢）。如果用深搜序来给每个第一列的结点编号，那么每个节点能管辖的特殊点编号必然是连续的，然后就可以使用那道题一样的方法进行 DP 了，具体细节可以看那道题的相关博客，真的几乎一模一样。

输出答案方面直接在 DP 过程中记录一下是哪个状态转移过来的就可以了。还有一点就是有可能他的颜料比较多，为了刷满那么多个点我们可能需要去输出一些无用点（包括以它为根的子树内没有特殊点的点和所在基环树不包含最后一列点的点），具体看代码即可。

最后是由于这道题比较阴险，限制的是矩阵中的结点个数和而不是长宽，不能使用有序数对来代表一个位置，稍微麻烦点但其实还好，反正空间给得足（比起之前 COICI 动不动用 32M 的空间打压我等蒟蒻的题好多了）。

```cpp
#include<bits/stdc++.h>
//#define feyn
#define p(i,j) ((i-1)*n+j)
const int N=1000010;
using namespace std;
inline void read(int &wh){
    wh=0;int f=1;char w=getchar();
    while(w<'0'||w>'9'){if(w=='-')f=-1;w=getchar();}
    while(w<='9'&&w>='0'){wh=wh*10+w-'0';w=getchar();}
    wh*=f;return;
}
inline int get(){
	char w=getchar();
	while(w<'A'||w>'Z')w=getchar();
	if(w=='U')return 0;
	if(w=='R')return 1;
	if(w=='D')return 2;
	if(w=='L')return 3;
}
inline int min(int s1,int s2){
	return s1<s2?s1:s2; 
}
inline int max(int s1,int s2){
	return s1<s2?s2:s1;
}

struct edge{
	int t,next;
}e[N];
int head[N],esum;
inline void add(int fr,int to){
	e[++esum]=(edge){to,head[fr]};head[fr]=esum;
}

int m,n,able;
bool ll[N],rr[N],vis[N];
inline void print(int wh){
	printf("%d %d\n",(wh-1)/n+1,(wh-1)%n+1);
}

struct node{
	int id,r;
};
vector<int>useless;
vector<node>pl[N];
int al[N],ar[N],cnt;//每个点管辖的特殊点的范围，cnt是深搜序 
void dfs(int wh){
	al[wh]=1e9;if(ll[wh])al[wh]=ar[wh]=++cnt;
	for(int i=head[wh],th;i;i=e[i].next){
		if(rr[th=e[i].t])continue;dfs(th);
		if(ar[th])al[wh]=min(al[wh],al[th]),ar[wh]=max(ar[wh],ar[th]);
	}
	if(ar[wh]==0)return;vis[wh]=true;
	pl[al[wh]].push_back((node){wh,ar[wh]});
}

bool f[N][60];//f[i][j]前i个点用了j次染色机会是否能全部染完 
int come[N][60];//记录每个状态是从哪里转移过来的 

signed main(){
	
	#ifdef feyn
	freopen("in.txt","r",stdin);
	#endif
	
	read(m);read(n);read(able);
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			if(j==1)ll[p(i,j)]=true;
			if(j==n)rr[p(i,j)]=true;
			switch(get()){
				case 0:add(p(i-1,j),p(i,j));break;
				case 1:add(p(i,j+1),p(i,j));break;
				case 2:add(p(i+1,j),p(i,j));break;
				case 3:add(p(i,j-1),p(i,j));break;
			}
		}
	}
	for(int i=1;i<=m;i++)dfs(p(i,n));
	int num_=0;
	for(int i=1;i<=m*n;i++){
		if((i-1)%n+1==n)continue;
		if(vis[i]==false)num_++,useless.push_back(i);
	}
	
	f[0][0]=true;
	for(int i=0;i<cnt;i++){
		for(vector<node>::iterator it=pl[i+1].begin();it!=pl[i+1].end();it++){
			int _r=(*it).r,_wh=(*it).id;
			for(int k=0;k<able;k++){
				if(f[i][k]==false)continue;
				if(f[_r][k+1]==false){
					f[_r][k+1]=true;
					come[_r][k+1]=_wh;
				}
			}
		}
	}
	for(int i=0;i<=able;i++){
		if(f[cnt][i]==false)continue;
		if(able-i>num_)continue;
		able-=i;int x=cnt;
		for(int j=i;j;j--){
			print(come[x][j]);
			x=al[come[x][j]]-1;
		}
		for(int j=0;j<able;j++)print(useless[j]);
		return 0;
	}
	printf("-1");
	
	return 0;
}
```

---

## 作者：guosoun (赞：3)

首先注意到，只有能到达最后一列的起始点才有意义。

然后和[P1514 [NOIP2010 提高组] 引水入城](https://www.luogu.com.cn/problem/P1514)类似，可以发现：「最后一列的某个点」如果能由一些起始点到达，那这些起始点必然是**连续的区间**。

考虑建反图之后从「最后一列」的点开始 DFS，求出每个点能到达的「第一列的点」的区间。

剩下的就是使用这些区间完全覆盖第一列的起始点（那些不能到达最后一列的起始点除外），DP解决。

将区间按左端点或右端点从小到大排序，$dp(i,j)$ 表示用恰好 $i$ 个区间，覆盖 $\left [ 1,j\right ] $ 的点，是否可行。

每个区间是 $O(k)$ 的转移，具体不写了，为了方便得到方案，考虑将「是否可行」替换为「最右边区间的编号」。

但是有一些小细节：

如果一个点在 DFS 之后没有得到区间，他有两种情况：

    1. 这个点在原图不能到达最后一列的点（可能陷入了环），没有被 DFS 过。
    1. 这个点在原图中，没有起始点可以到达，被 DFS 过了但没有区间。

这两种位置，都可以没有顾虑的涂色，当我们 DP 后发现凑不够 $k$ 个来覆盖第一列的时候，用他们凑成 $k$ 个。

还有，如果要删去那些没有意义的起始点，可以在 DFS 过程中将第一列的节点按照「搜索到的时间顺序」重新标号，这样可以保证区间连续且不包含没有意义的点。

代码：

```cpp
#include <bits/stdc++.h>
#define ll long long
#define pii pair<int,int>
using namespace std;
const int N=1e6+10;
int n,m,k,tot,dp[N][52],cnt;
vector<int>edge[N];
struct node{int l,r,num;}s[N];
void print(int x){cout<<(x-1)/m+1<<' '<<(x-1)%m+1<<'\n';}
void dfs(int x){
    if(x%m==1){s[x]={++tot,tot,x};}
    for(int to:edge[x]) 
        dfs(to),
        s[x].l=min(s[x].l,s[to].l),
        s[x].r=max(s[x].r,s[to].r);
}
int main(){
    cin>>n>>m>>k;
    for(int i=1;i<=n*m;i++){
        char c;cin>>c;
        s[i]={INT_MAX,-1,i};
        if(i%m==0) continue;
        if(c=='U') edge[i-m].push_back(i);
        if(c=='D') edge[i+m].push_back(i);
        if(c=='R') edge[i+1].push_back(i);
        if(c=='L') edge[i-1].push_back(i);
    }
    for(int i=1;i<=n;i++) for(int to:edge[i*m]) dfs(to);
    dp[0][0]=1;
    sort(s+1,s+n*m+1,[](node x,node y){return x.r<y.r;});
    for(int i=1;i<=n*m&&cnt<k;i++) if(s[i].r==-1&&s[i].num%m) dp[0][++cnt]=i;
    for(int i=1;i<=n*m;i++){
        if(s[i].r==-1) continue;
        for(int j=0;j<k;j++)
            if(dp[s[i].l-1][j]) dp[s[i].r][j+1]=i;
    }
    
    if(!dp[tot][k]) cout<<-1<<'\n';
    else{
        int nw=tot;
        for(int i=k;i>=1;i--){
            print(s[dp[nw][i]].num);
            if(s[dp[nw][i]].r==-1) nw=0;
            else nw=s[dp[nw][i]].l-1;
        }
    }
    return 0;
}
```















---

## 作者：ningago (赞：1)

众所周知每个点有且仅有一条出边的图构成内向基环森林。

定义 $1$ 列的点为“起点”，$m$ 列的点为“终点”。

由于走到终点就不用绕环了，所以我们预先把终点的出边断开。这样就构成了 一些不含终点的内向基环树 + 一些以终点为根的内向树。

对于一个基环树上的节点，或子树内没有起点的节点，不难发现这些点染不染色都一样。我们称之为“废物点”。**注意终点不能成为废物点**（因为不能染色）。

对于所有起点，我们利用其 dfs 序为其编号，记作 $dfn_i$。

不难发现，一个非废物点能够“堵住”的起点的 $dfn$ 是一段连续区间。

于是按照 $dfn$ 进行 DP，$dp_{i,j}$ 表示能否使用 $j$ 次染色，堵住 $dfn_x\leq i$ 的所有节点。即可 $O(nk)$ 解决。

注意答案的 $dp$ 不一定要染色 $k$ 次，因为如果够的话可以使用废物节点。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>

#define N 1000010
int n, m, K;
int h[N], e[N], ne[N], idx;
int nx[N];
void add_edge(int x, int y)
{
	ne[++idx] = h[x];
	h[x] = idx;
	e[idx] = y;
}
#define id(x, y) ((x - 1) * m + y)
char str[N];
bool vis[N];
int feiwu[N], fwidx;
int leaf[N], leafidx;
bool is_begin[N], is_end[N];
int in[N], out[N];
int S, T;

bool dfs1(int k)
{
	vis[k] = 1;
	int res = 0;
	for(int i = h[k]; ~i; i = ne[i])
	{
		int nx = e[i];
		if(vis[nx])
			S = k, T = nx, res = 1;
		else
			res |= dfs1(nx);
	}
	return res;
}

void dfs2(int k)
{
	if(!is_end[k])
		feiwu[++fwidx] = k;
	for(int i = h[k]; ~i; i = ne[i])
	{
		int nx = e[i];
		if(k == S && T == nx)
			continue;
		dfs2(nx);
	}
}

std::vector <std::pair <int, int> > v[N];

void dfs3(int k)
{
	in[k] = 0x3f3f3f3f;
	out[k] = 0;
	if(is_begin[k])
		leaf[++leafidx] = k, in[k] = out[k] = leafidx;
	for(int i = h[k]; ~i; i = ne[i])
	{
		int nx = e[i];
		dfs3(nx);
		in[k] = std::min(in[k], in[nx]);
		out[k] = std::max(out[k], out[nx]);
	}
	if(is_end[k])
		return;
	if(in[k] != 0x3f3f3f3f)
		v[in[k]].push_back(std::make_pair(out[k], k));
	else
		feiwu[++fwidx] = k;
}

bool hh[N];

void solve(int k)
{
	int p = k;
	hh[p] = 1;
	while(nx[p] && !hh[nx[p]])
	{
		hh[nx[p]] = 1;
		p = nx[p];
	}
	S = 0, T = 0;
	k = p;
	if(dfs1(p))
		dfs2(p);
	else
		dfs3(p);
}

void print(int x)
{
	printf("%d %d\n", (x + m - 1) / m, (x - 1) % m + 1);
}

int dp[N][55], last[N][55], pid[N][55];

int main()
{
	memset(h, -1, sizeof(h));
	scanf("%d%d%d", &n, &m, &K);
	for(int i = 1; i <= n; i++)
	{
		scanf("%s", str + 1);
		for(int j = 1; j < m; j++)
		{
			if(str[j] == 'L')
				nx[id(i, j)] = id(i, j - 1);
			if(str[j] == 'R')
				nx[id(i, j)] = id(i, j + 1);
			if(str[j] == 'U')
				nx[id(i, j)] = id(i - 1, j);
			if(str[j] == 'D')
				nx[id(i, j)] = id(i + 1, j);
			add_edge(nx[id(i, j)], id(i, j));
		}
		is_end[id(i, m)] = is_begin[id(i, 1)] = 1;
	}
	for(int i = 1; i <= n * m; i++)
	{
		if(vis[i])
			continue;
		solve(i);
	}
	dp[0][0] = 1;
	for(int l = 1; l <= leafidx; l++)
	{
		int sz = v[l].size();
		for(int _ = 0; _ < sz; _++)
		{
			int r = v[l][_].first, id = v[l][_].second;
			for(int i = 0; i < K; i++)
			{
				if(!dp[l - 1][i]) continue;
				dp[r][i + 1] |= dp[l - 1][i];
				pid[r][i + 1] = id;
				last[r][i + 1] = l - 1;
			}
		}
	}
	for(int i = 0; i <= K; i++)
	{
		if(!dp[leafidx][i])
			continue;
		if(i + fwidx < K)
			continue;
		int p = leafidx, t = i;
		while(p)
		{
			print(pid[p][t]);
			p = last[p][t];
			t--;
		}
		for(int j = i + 1; j <= K; j++)
			print(feiwu[j - i]);
		return 0;
	}
	printf("-1\n");
	return 0;
}
```

---

## 作者：NKL丶 (赞：0)

## Description

给出一个 $N \times M$ 的棋盘，棋盘上每个格子上有一个箭头，保证箭头方向不指向棋盘外。现在第一列任意位置放置一个机器人，机器人会按照箭头行走，直到走到最后一列停止。问能否将棋盘上 $K$ 个前 $M - 1$ 列的格子染色，使得对于任意的行走方案，均满足路径上只有一个染色点或者机器人处于无限循环中。（$1 \le N \times M \le 10^6,1 \le K \le 50$）

## Solution

将箭头视作有向边后建反向图，发现会形成一个基环外向森林，那么题目中的限制就可以转化为：

1. 从第一列节点到最后一列节点的路径上只有一个染色点。
2. 第一列节点所在基环树上不存在最后一列节点。

对于限制一，我们考虑删去最后一列节点的出边，这样子这棵基环树就变成了以最后一列节点为根的外向树。但是直接考虑路径仍然不好做，不妨换个思路，将第一列节点视为关键点，统计每个节点能管辖哪些关键点，具体的，我们记录下每个关键点的 dfs 序，那么对于树上每个节点来说就能用一个区间表示管辖点了，从而可以 dp 解决染色的问题。而对于限制二，这样的基环树是可以任意染色的，在判断答案合法性时输出即可。

## [Code](https://www.luogu.com.cn/paste/ok93yzvl)

---


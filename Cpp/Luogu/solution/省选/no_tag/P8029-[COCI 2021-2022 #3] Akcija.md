# [COCI 2021/2022 #3] Akcija

## 题目描述

给定 $n$ 个商品，每个商品有一个价格 $w_i$ 和一个截止期 $d_i$，其中 $d_i$ 表示第 $i$ 个商品必须在第 $d_i$ 分钟之前完成购买。每次购买一个商品均需花费 $1$ 分钟进行下单，在下单之后才视为购买成功。

现可从这 $n$ 个商品中选择若干个（包括 $0$ 个）进行购买（每个商品最多购买一次），视为一种购买方案。

当一种购买方案内的商品数量大于另一种方案时，规定前者更优；当一种购买方案的商品数量与另一种相同且前者的总价格更低时，规定前者更优。求所有符合题意的购买方案中，第 $1 \sim k$ 优的方案的商品数量和总价格各是多少。

## 说明/提示

**【样例 2 解释】**

前 $k$ 优的方案为 $\{1,3,4\}$、$\{2,3,4\}$ 和 $\{1,3\}$（用商品编号代替对应商品）。

**【数据规模与约定】**

**本题采用子任务捆绑测试。**

- Subtask 1（10 pts）：$k=1$，$w_1=\cdots=w_n$。
- Subtask 2（20 pts）：$k=1$。
- Subtask 3（20 pts）：$k=2$。
- Subtask 4（10 pts）：$1 \le n \le 20$。
- Subtask 5（30 pts）：$1 \le n,k \le 100$。
- Subtask 6（20 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n,k \le 2000$，$1 \le w_i \le 10^9$，$1 \le d_i \le n$。

**【提示与说明】**

官方数据每个子任务有 $13$ 个测试点，所需总时限高达 $6.5$ 分钟。为了减少评测机负担，这里每个子任务只选取前两个测试点进行评测。

**题目译自 [COCI 2021-2022](https://hsin.hr/coci/) [CONTEST #3](https://hsin.hr/coci/contest3_tasks.pdf) _Task 3 Akcija_。**

**本题分值按 COCI 原题设置，满分 $110$。**

## 样例 #1

### 输入

```
3 1
1 1
1 1
1 3```

### 输出

```
2 2```

## 样例 #2

### 输入

```
4 3
1 1
10 1
2 3
10 3```

### 输出

```
3 13
3 22
2 3```

## 样例 #3

### 输入

```
2 4
1 1
2 2```

### 输出

```
2 3
1 1
1 2
0 0```

# 题解

## 作者：registerGen (赞：5)

[在 cnblogs 中查看](https://www.cnblogs.com/registergen/p/p8029_solution.html)

*注*：这篇题解中涉及到的所有概念均会在其第一次出现时用 *斜体* 标出，有些概念给出了定义，而有些概念的含义请自行意会。

定义 *状态* 为选了的物品数 $a$ 与相应总价格 $b$ 的二元组 $(a,b)$。相应地定义状态之间的 *大小关系*、*最优状态* 与状态和状态的 *加法运算* $(a_1,b_1)+(a_2,b_2):=(a_1+a_2,b_1+b_2)$。

我们先来考虑 $k=1$ 时的做法。首先我们将商品按 $d_i$ 排序。设 $f(i,j)$ 表示当考虑前 $i$ 个物品，选了 $j$ 个时，我们 **从剩余物品中能获得的** 最优状态。显然可以 dp 求出。（当然正常的思维路径是设 $f(i,j)$ 表示前 $i$ 个物品选 $j$ 个时的最优状态，这么设的原因见下文。）转移方程为

$$
f(i,j)=\begin{cases}
  f(i+1,j),&d_{i+1}\le j\\
  \max\{f(i+1,j),f(i+1,j+1)+(1,w_{i+1})\},&d_{i+1}\ge j+1
\end{cases}
$$

接下来，我们以状态 $(0,0)$ 为 *搜索树* 的根，进行 [*Fracturing Search*](https://usaco.guide/adv/fracturing-search)。

按 $d_i$ 从小到大的顺序枚举每个物品 $(w_i,d_i)$（$1\le i\le n$）。设考虑第 $i$ 个物品前的前 $k$ 优的状态集合为 $S$，考虑完第 $i$ 个物品后的前 $k$ 优的状态集合为 $T$。枚举 $(a,b)\in S$，其 *后继状态* 为 $(a,b)$（不选第 $i$ 个物品）与 $(a+1,b+w_i)$（选第 $i$ 个物品，前提是 $d_i\ge a+1$），这些后继状态构成了集合 $T$ 的一个超集 $T'$。

对于 $s=(a,b)\in T'$，搜索树上以 $s$ 为根的子树中，最优状态为 $s+f(i,a)$。我们以它为关键字，取 $T'$ 中前 $k$ 大的元素即构成了 $T$。于是，我们令 $S\gets T$，并枚举下一个物品。

我们需要枚举 $n$ 个物品，枚举每个物品时我们以 $\mathcal O(k)$ 的时间复杂度计算后继状态集合 $T$，这样，我们就以 $\mathcal O(nk)$ 的时间复杂度解决了本题。

```cpp
#include <algorithm>
#include <cstdio>
using namespace std;

using ll = long long;

const int N = 2000;

struct Node { int w, d; };
struct State { int cnt; ll sum; };
inline bool operator<(const State &lhs, const State &rhs) {
  return lhs.cnt == rhs.cnt ? lhs.sum > rhs.sum : lhs.cnt < rhs.cnt;
}
inline State operator+(const State &lhs, const State &rhs) {
  return {lhs.cnt + rhs.cnt, lhs.sum + rhs.sum};
}

int n, k;
Node a[N + 10];
State f[N + 10][N + 10];
State ans[N + 10], nxt[N + 10];

int main() {
  scanf("%d%d", &n, &k);
  for (int i = 1; i <= n; i++)
    scanf("%d%d", &a[i].w, &a[i].d);
  sort(a + 1, a + n + 1, [](const Node &lhs, const Node &rhs) {
    return lhs.d < rhs.d;
  });
  for (int i = n - 1; i >= 0; i--)
    for (int j = 0; j <= i; j++) {
      f[i][j] = f[i + 1][j];
      if (a[i + 1].d > j) f[i][j] = max(f[i][j], f[i + 1][j + 1] + State({1, a[i + 1].w}));
    }
  int tota = 1;
  for (int i = 1; i <= n; i++) {
    int totn = 0;
    for (int j = 1; j <= tota; j++) {
      nxt[++totn] = {ans[j].cnt, ans[j].sum};
      if (a[i].d > ans[j].cnt) nxt[++totn] = {ans[j].cnt + 1, ans[j].sum + a[i].w};
    }
    tota = min(k, totn);
    nth_element(nxt + 1, nxt + tota + 1, nxt + totn + 1, [&](const State &lhs, const State &rhs) {
      return rhs + f[i][rhs.cnt] < lhs + f[i][lhs.cnt];
    });
    for (int j = 1; j <= tota; j++) ans[j] = nxt[j];
  }
  sort(ans + 1, ans + k + 1, [](const State &lhs, const State &rhs) { return rhs < lhs; });
  for (int i = 1; i <= k; i++)
    printf("%d %lld\n", ans[i].cnt, ans[i].sum);
  return 0;
}
```

---

## 作者：Thunder_S (赞：3)

## Solution

前 $k$ 优秀，想到 $A^*$。

首先预处理出状态 $(i,j)$ 到终点的最短路。具体来说，$f_{i,j}$ 表示到第 $i$ 个商品，买了 $j$ 个的最小花费。

有转移方程 $f_{i,j}=\min(f_{i+1,j},(f_{i+1,j+1}+w_i)[d_i>j])$。

随后正向枚举每个商品，并不断的加入到堆中，最后取出堆的前 $k$ 个作为下次添加时进行对比的方案。

## Code

```cpp
#include<cstdio>
#include<algorithm>
#define N 2005
#define inf 12345678987654
#define ll long long
using namespace std;
int n,k,tot,num;
ll f[N][N];
struct node
{
    int x,y;
    ll z;
}a[N],b[N],c[N];
bool cmp1(node x,node y) {return x.y<y.y;}
bool cmp2(node x,node y) {return x.z+f[x.x][x.y]<y.z+f[y.x][y.y];}
int main()
{
    freopen("shopping.in","r",stdin);
    freopen("shopping.out","w",stdout);
    scanf("%d%d",&n,&k);
    for (int i=1;i<=n;++i)
        scanf("%d%d",&c[i].x,&c[i].y);
    sort(c+1,c+n+1,cmp1);
    for (int i=0;i<=n;++i)
        f[n][i]=(n-i)*inf;
    for (int i=n-1;i>=0;--i)
        for (int j=0;j<=i;++j)
            if (c[i+1].y>j) f[i][j]=min(f[i+1][j],f[i+1][j+1]+c[i+1].x);
            else f[i][j]=f[i+1][j];
    tot=1;
    for (int i=1;i<=n;++i)
    {
        num=0;
        for (int j=1;j<=tot;++j)
        {
            ++num;
            b[num].x=a[j].x+1;b[num].y=a[j].y;b[num].z=a[j].z;
            if (a[j].y<c[i].y)
            {
                ++num;
                b[num].x=a[j].x+1;b[num].y=a[j].y+1;b[num].z=a[j].z+c[i].x;
            }
        }
        sort(b+1,b+num+1,cmp2);
        tot=min(num,k);
        for (int j=1;j<=tot;++j)
            a[j]=b[j];
    }
    for (int i=1;i<=k;++i)
        printf("%d %lld\n",a[i].y,a[i].z);
    return 0;
}
```

---

## 作者：Mirasycle (赞：1)

很经典的前 $k$ 优方案的问题。目前大概看过两种类型，一个是类似于局部选择可以排序一下，然后维护指针不断加入。另一个是像本题这样子类似全局选可以考虑 $\operatorname{A*}$。维护一个估计函数 $f$ 代表后缀最优代价， 然后从 $1$ 开始顺推。

放到图上形式化地描述就是前者是离源点最近的 $k$ 个点，可以维护指针不断扩展。后者是 $k$ 短路，需要我们用 $\operatorname{A*}$ 来解决。

$d_i$ 为时间约束，我们不妨从小到大排序。

本题的实现方法就是先求出 $f_{i,j}$ 表示后面 $n-i$ 个物品我们选择了 $k-j$ 个的最小代价。也就是一个后缀最优函数。这个很容易通过 dp 来求解。

然后我们从 $1$ 开始顺推，设当前局面状态为 $s$ 前缀代价为 $g_s$。我们只需要维护前 $k$ 大的 $g_s+f_s$ 即可。因为 $f_s$ 仅仅表示后缀最小代价，可能还会有次小等等之类，也就是说 $s$ 后面可能会扩展出多个状态，其中一个最好的情况是 $f_s+g_s$。故当前局面的前 $k$ 优可以推出最后局面的前 $k$ 优。而当前局面的第 $k+1$ 优的最佳情况已经不如前 $k$ 个状态优了，所以必定不可能成为最后的前 $k$ 优方案。

有一个技巧就是我们并不需要维护前 $k$ 状态的相对大小，只需要找到前 $k$ 小，所以直接用 
`nth_element` 函数即可，而不用排序或者优先队列，可以省去一个 $\log$ 的复杂度。

时间复杂度 $O(n^2+nk)$。

---

## 作者：dspt (赞：1)

## 前置知识：A*

A\*：启发式搜索，利用**估价函数**来优化搜索的过程。

为什么想到 A\*？因为题目要求前 $k$ 优的所有方案，我们不可能把所有方案搜索一遍，于是可以用启发式搜索。

比较经典地用 A\* 求前 $k$ 优的例子是 **$k$ 短路**（虽然时间复杂度不正确），可以参考[这篇文章](https://www.mina.moe/archives/2777)的 Solution 2。

&nbsp;
## 本题解法

由于有购买时间 $d_i$ 的限制，我们先将物品按 $d_i$ 从小到大排序。

记 $f_{i,j}$ 表示考虑了第 $i$ 个物品 ~ 第 $n$ 个物品，并且前面已经购买了 $j$ 个物品的估价函数。本题中要求物品最多，代价最少。考虑到我们最多买 $n$ 个物品，我们将不买的物品认为是代价是 $\infin$ 的物品，这样就不用考虑物品最多，只需要考虑代价最少了。那么 $f_{i,j}$ 的含义就是**第 $i$ 个物品 ~ 第 $n$ 个物品，购买 $n-j$ 个物品的最小代价**。

显然这可以 $i:n\rightarrow 1$ 转移，如果 $j<d_i$，$f_{i,j}=\min(f_{i+1,j},f_{i+1,j+1}+w_i)$，否则 $f_{i,j}=f_{i+1,j}$，分别对应买第 $i$ 个物品和不买两种情况。可以在 $O(n^2)$ 的时间里处理出估值函数 $f$。

接下来我们枚举 $i:1\rightarrow n$，枚举每个物品是否购买并求出当前情况下前 $k$ 优。我们记二元组 $(s,w)$ 表示购买了 $s$ 个物品，这些物品价值为 $w$ 的状态。每次我们用二元数组 $b$ 记录最优的 $k$（不足 $k$ 个则全部）个二元组。转移时，我们枚举 $b$ 的每个二元组，分买和不买两种情况转移至二元数组 $c$。

每次转移完后，把 $c$ 按照 $w+f_{i+1,s}$（即当前价值 + 估值函数）从小到大排序，取前 $k$ 个（不足 $k$ 个则全部）放回 $b$ 中，最后 $b$ 中所有二元组就是答案。

时间复杂度 $O(n^2+nk\log k)$。

&nbsp;
## 代码

```c++
#include <stdio.h>
#include <algorithm>
using namespace std;
long long f[2002][2002]; pair<int, int> a[2001]; pair<int, long long> b[2001], c[4001];
#define w second
#define d first
#define s first
int main()
{
    int n, k, t(1); scanf("%d%d", &n, &k);
    for (int i(1); i <= n; ++i) scanf("%d%d", &a[i].w, &a[i].d);
    sort(a + 1, a + n + 1); // 按时间排序
    for (int i(0); i <= n; ++i) f[n + 1][i] = (n - i) * 2e12; // 初始化 (n - i) * \infin
    for (int i(n); i > 1; --i) for (int j(0); j <= i; ++j) // 预处理估值函数 f
    {
        f[i][j] = f[i + 1][j]; // 不买
        if (j < a[i].d && j < i) f[i][j] = min(f[i][j], f[i + 1][j + 1] + a[i].w); // 买
    }
    for (int i(1), m(0); i <= n; ++i, m = 0)
    {
        for (int j(1); j <= t; ++j)
        {
            c[++m] = {b[j].s, b[j].w}; // 不买
            if (b[j].s < a[i].d && b[j].s < i) c[++m] = {b[j].s + 1, b[j].w + a[i].w}; // 买
        }
        sort(c + 1, c + m + 1, [i](const pair<int, long long> x, const pair<int, long long> y)
                               { return x.w + f[i + 1][x.s] < y.w + f[i + 1][y.s]; } ); // 当前价值 + 估值函数 排序
        t = min(m, k); for (int j(1); j <= t; ++j) b[j] = c[j];
    }
    for (int i(1); i <= k; ++i) printf("%d %lld\n", b[i].s, b[i].w); return 0;
}
```

---

## 作者：xiao7_Mr_10_ (赞：0)

这个题我曾经看过，没做，然后考试考到了，就趋势了。

对于前 $k$ 优问题，我们一般需要估计函数做优先队列 bfs 对吧。考虑估价函数的设计，需要考虑后面的物品的最优性，所以不妨设 $f_{i,j}$ 表示选择 $[i+1,n]$ 内的物品，在此之前已经选择了 $j$ 个，问可达的最优代价。

转移也很显然，继承前缀状态或者在可行的状态下加入第 $i+1$ 个物品。这个 dp 显然是 $O(nk)$ 的。

当 $k=1$ 时，答案显然是 $f_{1,0}$。但没必要考虑这个东西，我们考虑从初始状态 $(0,0)$ 跑搜索，枚举一个物品 $i$ 选或者不选，如果选，我们就可以通过 dp 数组计算最优代价。也就是说只需要维护能够扩展的，最优秀的一个解，每次取前 $k$ 优即可。

时间复杂度 $O(nk \log n)$ 足以通过。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=2e3+5;
struct Point{
	int x,y;
	bool operator<(const Point &now)const{
		if(now.y==y)return x<now.x;
		return y<now.y;
	}
}a[N];
struct Point1{
	int cnt,val;
	bool operator<(const Point1 &x)const{
		if(x.cnt==cnt)return val<x.val;
		return cnt>x.cnt;
	}Point1 operator+(const Point1 &x)const{
		return (Point1){cnt+x.cnt,val+x.val};
	}
}f[N][N];
vector <Point1> dp,now; 
int n,K,lq;
bool cmp(const Point1 &x,const Point1 &y){
	return x+f[lq][x.cnt]<y+f[lq][y.cnt];
}
signed main(){
//	ios::sync_with_stdio(0);
//	cin.tie(0),cout.tie(0);
	cin >> n >> K;
	for(int i = 1;i <= n;i++)cin >> a[i].x >> a[i].y;
	sort(a+1,a+1+n);
	for(int i = n-1;i >= 1;i--){
		for(int j = 0;j <= i;j++){
			f[i][j]=f[i+1][j];
			if(a[i+1].y>j)f[i][j]=min(f[i][j],f[i+1][j+1]+(Point1){1,a[i+1].x});
		}
	}
	dp.push_back((Point1){0,0});
	for(int i = 0;i <= n;i++){lq=i;
		sort(dp.begin(),dp.end(),cmp);
		if(dp.size()>K)dp.resize(K);
		if(n==i)break;
		now.clear();
		for(auto it:dp){
			int num=it.cnt;
			now.push_back(it);
			if(a[i+1].y>num)now.push_back((Point1){it.cnt+1,it.val+a[i+1].x});
		}dp=now;
	}
	for(int i = 0;i < K;i++)cout << dp[i].cnt << " " << dp[i].val << "\n";
	return 0;
}

```

---


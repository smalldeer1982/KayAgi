# [COCI 2016/2017 #7] KLAVIR

## 题目描述

年轻的 Alisa 喜欢只用一根手指弹钢琴。但是，由于 Alisa 从来都没学过弹钢琴，因此她的弹琴过程完全是随机的。更准确地说，她会**等概率**选择钢琴的 $N$ 个音调上的任意一个，并且**独立于之前所有选择的音调**。

Alisa 的好朋友 Mirta 想要听一个连续的包含 $M$ 个音调 $A_1,A_2,\dots,A_M$ 的曲子，但由于 Alisa 弹琴过程是完全随机的，Mirta 只想知道，对于所有的 $1\leqslant i\leqslant M$，Alisa 选择音调使 Mirta 第一次听到连续的音调 $A_1,A_2,\dots,A_i$ 的**期望次数**。为了防止精度丢失，**答案对 $\bf 10^9+7$ 取模**。

## 说明/提示

**【数据范围】**

对于 $40\%$ 的数据，保证 $1\leqslant M\leqslant 200$。  
对于所有数据，$1\leqslant N\leqslant 100$，$1\leqslant M\leqslant 10^6$，$1\leqslant A_i\leqslant N$。

**【题目来源】**

本题来源自 **_[COCI 2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST 7](https://hsin.hr/coci/archive/2016_2017/contest7_tasks.pdf) T6 KLAVIR_**，按照原题数据配置，满分 $160$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
2
2
1 2```

### 输出

```
2
4```

## 样例 #2

### 输入

```
2
2
1 1```

### 输出

```
2
6```

## 样例 #3

### 输入

```
3
3
1 2 3```

### 输出

```
3
9
27```

# 题解

## 作者：Petit_Souris (赞：10)

和 CTSC 歌唱王国几乎一致的题目，我来推广一个（比较组合意义的）有趣解法。参考了 [WYXkk 在那题的题解](https://www.luogu.com.cn/blog/WYXkk/solution-p4548) 和 [知乎上的一个回答](https://www.zhihu.com/question/330408241/answer/777567811)。

题意：给定一个字符串 $S$，长度为 $M$。字符集大小为 $N$。有一个字符串 $T$，初始为空。每秒随机在字符集当中选一个字符加到 $T$ 的末尾，对于每个 $S$ 的前缀 $p$ 求出期望几秒之后 $p$ 成为了 $T$ 的子串。$M\le 10^6,N\le 100$。

初看这道题感觉除了把 KMP 自动机建出来消元以外没有好的多项式复杂度做法，但是这个故事的解释很精妙。

我们先对一个单独的 $S$ 求解，不考虑前缀的问题。假设拥有这个会自动吐字符的字符串 $T$ 的人开了一座赌场，设计了这样一个游戏：

> 支付 $k$ 块钱玩一次游戏，猜 $T$ 的下一个出现的字符为 $x$。如果猜对了，返还 $Nk$ 块钱，否则游戏结束。

这个游戏显然是绝对公平的——每次有 $\frac{1}{N}$ 的概率猜对，因此赌场不赚不赔。

我们假设有无限多个赌徒依次进入赌场玩这个游戏。第 $1$ 位赌徒有 $1$ 块钱，在第 $1$ 秒进入，他猜测接下来会出现 $S_1$。如果猜对了，把刚刚获得的全部 $N$ 块钱押第 $2$ 秒出现 $S_2$。如果再猜对，把获得的全部 $N^2$ 块钱押第 $3$ 秒出现 $S_3$......对于其他赌徒也是相同的：第 $i$ 位赌徒在第 $i$ 秒进入赌场，把所有的 $N^j$ 块钱押接下来出现 $S_{j+1}$，依此类推......一旦有一位赌徒连续猜对了 $M$ 次，赌场老板就会因为觉得自己亏了而关闭赌场。

我们现在假设猜对了 $M$ 次的是第 $t$ 位赌徒，那么我们观察一下在赌场关门倒闭了以后，哪些赌徒手上还有钱，以及他们分别有几块钱：

- 第 $t-1$ 位以及之前的赌徒都空手而归。

- 第 $t$ 位赌徒有 $N^M$ 块钱。

- 在第 $t$ 位之后的赌徒还可能有钱，这时候他们猜的串是 $S$ 的一个后缀，它又应该和 $S$ 的前缀相同，因此如果第 $t+k$ 位赌徒没有空手而归，他应该代表了一个 border。且如果 border 长度为 $l$，他会拥有 $N^l$ 块钱。

不难发现按照这样的分析，$S$ 的每个 border 都会对应一位赚到钱的赌徒，并且每个 border 只会出现恰好一次。

如果我们假设 $S$ 的 border 长度集合为 $B$，那么所有赌徒手上的资金总和为 $\sum\limits_{x\in B}N^x$。

最后我们要将赌徒的钱和赌场老板的字符串 $T$ 的长度找出联系。赌场在这个游戏期望下不赚不赔，因此赌徒这个整体也是不赚不赔的。而又由于期望拥有 $\sum\limits_{x\in B}N^x$ 块钱，每个赌徒初始有 $1$ 块钱，所以赌徒的个数也是 $\sum\limits_{x\in B}N^x$。因此游戏的期望时长也是 $\sum\limits_{x\in B}N^x$ 秒，也即为所求的答案。

此时回到原题目，发现我们做一遍 KMP 求出 border，沿着 fail 指针跳 dp 就可以算出答案了，时间复杂度 $\mathcal O(M)$。（最后的实现如果有不理解的建议参考其他题解，这里不多赘述）。


---

## 作者：Feyn (赞：5)

[link](https://www.luogu.com.cn/problem/P8043)

约定：假设 $A$ 是一个序列，$a$ 是一个元素，那么 $A+a$ 是在序列后拼上一个元素形成的新序列。$t(A,B)$ 是指最长序列 $C$ 的长度，满足其即是 $A$ 的后缀又是 $B$ 的前缀。

用 $f_i$ 来代表弹奏完前 $i$ 个音符的期望时间，那么我们可以把这个事件分成两个阶段。首先要弹完前 $i$ 个音符就必须要完美地弹完前 $i-1$ 个（这不废话），于是就必须对于最后一个音符分类讨论。显然有 $\frac{1}{m}$ 的概率使得最后的那个音符刚好是我们想要的，此时只需要再弹一个音符即可；但更多的时候我们会选择到一个没用的音符，此时我们就回到了之前的某个状态。假设我们当前弹了的音符序列是 $A$，当前弹错误音符是 $a$，我们希望的音符序列是 $B$，假如 $len=t(A+a,B)$，那么我们就可以看成是已经弹了 $len$ 个音符，接下来需要的期望时间理应是 $f_i-f_{len}+1$，毕竟最后那个音符也是需要时间的。于是方程就可以列出来了：

$$f_{i}=f_{i-1}+\frac{1}{m}+\frac{1}{m}(f_i-f_{s_1})+\frac{1}{m}(f_i-f_{s_2})+\dots$$

其中 $s_1$ 代表的是序列 $t(A+1,B)$，以此类推。当然等号右边的式子不能包含能一步到位的那一项。移项整理可得：

$$f_i=(f_{i-1}+1)\times m-(f_{s_1}+f_{s_2}+\dots)$$

问题变成了如何求后半部分。如果暴力求很可能被卡成 $O(N^2)$，考虑优化。

我们令上述式子的 $f_{s_1}+f_{s_2}+\dots=g_{i-1}$，于是可以推出 $g$ 的含义，即串的某个前缀后面拼上所有可能字符后对应位置的 $f$ 值之和。既然我们希望的是极长的希望串前缀等于当前串后缀，那么显然 $g_{i}$ 应该和 $g_{fail_i}$ 有密切的关系。显然这段开始的那个式子大部分项应该是相同的，除了两个地方。首先根据定义，$g_i$ 不能包括 $f_{s_{A_{i+1}}}$，也就是不能包括使得下一个位置刚好符合条件的那一项，减掉即可；而由于 $g_{fail_i}$ 也没有包括 $f_{s_{A_{fail_i+1}}}$ 那一项（可能有点绕抱歉），所以要加上这一项。画一下就可以知道两个部分对应的位置，然后正常更新即可。代码异常简略，复杂度 $O(N)$。

```cpp
#include<bits/stdc++.h>
//#define feyn
#define int long long
using namespace std;
const int N=1000010;
const int mod=1e9+7;
inline void read(int &wh){
    wh=0;int f=1;char w=getchar();
    while(w<'0'||w>'9'){if(w=='-')f=-1;w=getchar();}
    while(w<='9'&&w>='0'){wh=wh*10+w-'0';w=getchar();}
    wh*=f;return;
}

int m,n,a[N],fail[N];
int f[N],g[N];

signed main(){
	
	#ifdef feyn
	freopen("in.txt","r",stdin);
	#endif
	
	read(n);read(m);
	for(int i=1,j=0;i<=m;i++){
		read(a[i]);if(i==1)continue;
		while(j&&a[j+1]!=a[i])j=fail[j];
		if(a[j+1]==a[i])j++;fail[i]=j;
	}
	f[1]=n;
	for(int i=2;i<=m;i++){
		//核心代码
		g[i-1]=g[fail[i-1]]+f[fail[i-1]+1]-f[fail[i]];//从fail那里继承，然后加上缺失的部分丢掉不用的部分
		f[i]=n*(f[i-1]+1)-g[i-1];//和上面的式子一样更新即可
		//核心代码
		f[i]%=mod,g[i]%=mod;
	}
	for(int i=1;i<=m;i++)printf("%lld\n",(f[i]%mod+mod)%mod);
	
	return 0;
}
```

---

## 作者：Register_int (赞：4)

大家好，我非常喜欢生成函数，所以我用生成函数切掉了这题。

#### 前置知识：概率生成函数（PGF）

设 $F(x)=\sum_iP(X=i)x^i$，那么 $F'(1)=\sum_iP(X=i)\times i=E[X]$。

- - -

设两个 PGF $F(x)$、$G(x)$，$x^i$ 的系数分别表示到 $i$ 时结束与未结束的概率。考虑新加了个音符，那么这一个必然会导致他结束/不结束，则容易得到：

$$g_{i+1}=f_i+g_i$$

即

$$xG(x)+1=F(x)+G(x)$$

其中 $+1$ 是为了保证在字符数为 $0$ 时不会停止。由于我们要求的是 $F'(1)$ 的值，所以考虑两边求个导，得到：

$$
\begin{aligned}
(xG(x))'&=F'(x)+G'(x)\\
G(x)+xG'(x)&=F'(x)+G'(x)\\
F'(x)&=(x-1)G'(x)+G(x)\\
\end{aligned}
$$

代入 $x=1$ 得到：

$$F'(1)=G(1)$$

那么我们需要求出 $G(1)$ 的值。考虑另一种方向：当前未结束时，强行添加上一串长度为 $m$ 的目标串 $s$ 使得他立刻停止。然而，有可能这个串还没加完就结束了，导致概率多算了后面拼接的剩下部分而减小。容易发现，当出现这种情况时，添加的串正是 $s$ 的一个 $\text{border}$（即公共前后缀）。设字符集大小为 $c$，$s[0:i]$ 为 $s$ 的前 $i+1$ 个字符组成的前缀，容易得到有：

$$\left(\dfrac1cx\right)^mG(x)=\sum_i^{m-1}[s[0:i]\text{ is a border}]\left(\dfrac1cx\right)^{m-i-1}\times F(x)$$

由于 $F(1)=\sum_iP(X=i)=1$，那么 $G(1)$ 容易求得：

$$
\begin{aligned}
\left(\dfrac1cx\right)^mG(x)&=\sum_i^{m-1}[s[0:i]\text{ is a border}]\left(\dfrac1cx\right)^{m-i-1}\times F(x)\\
\left(\dfrac1cx\right)^mG(1)&=\sum_i^{m-1}[s[0:i]\text{ is a border}]\left(\dfrac1c\right)^{m-i-1}\times F(1)\\
G(1)&=\sum_i^{m-1}[s[0:i]\text{ is a border}]\left(\dfrac1c\right)^{-i+1}\\
G(1)&=\sum_i^{m-1}[s[0:i]\text{ is a border}]c^{i+1}\\
\end{aligned}
$$

显然不必计算所有 $m$ 个值，只需要用 $\text{KMP}$ 算法跳 $\text{border}$ 即可。也不必暴力循环计算，可以用前缀和的方式记录，这样单次计算就变成了 $O(1)$，时间复杂度 $O(m)$。

# AC 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 1e6 + 10;
const int mod = 1e9 + 7;

int n, m, a[MAXN], nxt[MAXN];

ll p[MAXN], ans[MAXN];

int main() {
	scanf("%d%d", &n, &m), *nxt = -1, *p = 1;
	for (int i = 0; i < m; i++) scanf("%d", &a[i]), p[i + 1] = p[i] * n % mod;
	for (int i = 0, j = -1; i < m; !~j || a[i] == a[j] ? nxt[++i] = ++j : j = nxt[j]);
	for (int i = 1; i <= m; i++) printf("%lld\n", ans[i] = (ans[nxt[i]] + p[i]) % mod);
}
```

~~四行切黑.jpg~~

---

## 作者：☯☯枫☯☯ (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P8043)

## 题意简述

给定一个字符串，每次等概率随机产生一个新的字符。问产生该字符串的每一前缀的期望次数。

## Declare

- 下文中，记弹 $1\to i$ 的期望弹奏次数为 $dp_i$，且 $dp_1=n$。
- 记音符串为 $a_i$。

## Analysis

首先读懂题意，我们发现，对于当前正在弹奏的一段乐曲，有以下两种情况：

- 当前段的某一后缀与前缀相同。
- 当前段的任何后缀都与前缀不同。（当前串是“独立”的串）

第二种情况比较简单，对于第二种情况，那么有：

$$dp_i=dp_{i-1}+\frac{1}{n}+\frac{1}{n}\times(dp_i-dp_1+1)+\frac{n-2}{n}\times(dp_i+1)$$

$$\Rightarrow dp_i=n\times dp_{i-1}$$

其中，第一个 $\frac{1}{n}$ 表示第 $i$ 个音符直接弹奏正确的期望，$\frac{1}{n}\times(dp_i-dp_1+1)$ 表示这个音符弹奏错误，但与第一个音符相同的期望，$\frac{n-2}{n}\times(dp_i+1)$ 表示这个音符弹奏错误，同时与第一个音符不同的期望。

样例三对应的就是这种情况。

```cpp
3
3
1 2 3 
```

```cpp
3
9
27 
```

接下来讨论第一种情况。

前后缀显然可以用 KMP 预处理处理。

设已经弹奏了 $1\to i$，现在要弹奏第 $i+1$ 个音符。枚举当前弹奏音符 $j$。弹错时，需要找到最长的已经弹对的前缀，记为 $k_j$，于是有：

$$dp_{i+1}=dp_i+\frac{1}{n}+\frac{1}{n}\times\sum\limits_{j=1}^n(dp_{i+1}-dp_{k_j}+1)(j\neq a_{i+1})$$

$$\Rightarrow dp_{i+1}=dp_i+n+\sum\limits_{j=1}^n(dp_{i+1}-dp_{k_j})(j\neq a_{i+1})$$

其中 $\frac{1}{n}\times\sum\limits_{j=1}^n(dp_{i+1}-dp_{k_j}+1)(j\neq a_{i+1})$ 表示弹错了，但已经弹对前缀 $1\to k$，接着从 $k+1$ 弹到 $n+1$ 的期望。两层循环跑一下就完了。时间复杂度 $\mathcal{O}(n\times m^2)$，实测可过（~~大概是机子跑得快的原因~~）。

```cpp
    dp[1] = n;
    F(i, 1, m) {//弹第 i 个音符
        long long s = 0;
        F(j, 1, n){//枚举弹的音符
            if (j != a[i + 1]) {
                k = fail[i];
                while (k && a[k + 1] != j) k = fail[k];
                if (a[k + 1] == j) ++k;
                s += dp[i] - dp[k];
            }
        }
        dp[i + 1] = (s + n + dp[i]) % mod;
    }
```

虽然可过，但理论上还是蛮卡的。接下来我们考虑优化。

我们记当前为第 $i$ 个音符，下一个音符是 $j$ 时，最终跳到的位置为 $f_{i,j}$，那么 $f_{i,j}$ 和 $f_{fail_i,j}$ 只有在 $j=a_{i+1}$ 时是不同的。因此对于 $dp_{i+1}$ 可以直接继承 $dp_{fail_{i+1}}$ 的答案，再额外计算 $j=a_{i+1}$ 的贡献即可。从上面方法中，可以看出 $j=a_{i+1}$ 的贡献就是 $n^{i+1}$。

综上可得：

$$dp_i=dp_{fail_i}+n^i$$

时间复杂度 $\mathcal{O}(m)$，算是十分优秀了。

## code

```cpp
#include <bits/stdc++.h>
#define reg register
#define ll long long
#define _min(x, y) ((x) < (y) ? (x) : (y))
#define _max(x, y) ((x) > (y) ? (x) : (y))
#define Min(x, y) ((x) > (y) and ((x) = (y)))
#define Max(x, y) ((x) < (y) and ((x) = (y)))
#define F(i, a, b) for (reg int i = (a); i <= (b); ++i)
#define PF(i, a, b) for (reg int i = (a); i >= (b); --i)
#define For(i, x) for (reg int i = head[(x)]; i; i = net[(i)])
using namespace std;
bool beginning;
inline int read();
const int N = 1e6 + 5, mod = 1e9 + 7;
int n, m, a[N], fail[N];
inline void init() {
    int j = 0;
    F(i, 2, m) {
        while (j and a[j + 1] != a[i]) j = fail[j];
        j += (a[j + 1] == a[i]);
        fail[i] = j;
    }
}
bool ending;
int main() {
    // printf("%.2lfMB\n",1.0*(&beginning-&ending)/1024/1024);
    n = read(), m = read();
    F(i, 1, m) {
        a[i] = read();
    }
    init();
    int t = n;
    F(i, 1, m) {
        a[i] = a[fail[i]] + t;
        if (a[i] >= mod) a[i] -= mod;
        t = 1ll * t * n % mod;
        printf("%d\n", a[i]);
    }
    return 0;
}
inline int read() {
    reg int x = 0;
    reg bool f = 1;
    reg char c = getchar();
    while (!isdigit(c)) {
        f = c ^ 45;
        c = getchar();
    }
    while (isdigit(c)) x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();
    return f ? x : -x;
}
```

---

## 作者：Kelvin2009 (赞：1)

这是一道 KMP 加期望 DP。

首先，令从音符 $1$ 弹至 $j$ 的期望次数为 $sum_{j}$。假设先前全部弹奏吻合，对于当前字符 $i$，会出现两种情况：

1. 弹奏恰好吻合。此时 $sum_{i-1}$ 对 $sum_{i}$ 有 $\frac{1}{n}$ 的贡献。

2. 弹奏不吻合。设此时的弹奏 $\overline{A_{1}A_{2}\ldots A_{i}C}$ 为 $S_{c}$ ，其前缀匹配为 $nxt_{S_{c}}$。可以发现，其对 $sum_{i}$ 的贡献为 $\frac{1}{n}\cdotp(sum_{i}-sum_{nxt_{S_{c}}}+1)$。

整合一下，可得：
$$sum_i=sum_{i-1}+\frac{1}{n}+\frac{1}{n}\cdot\displaystyle\sum_{i=1}^{n}\lbrack i\neq A_{i}\rbrack\cdot(sum_{i}-sum_{nxt_{S_{c}}}+1)$$ 

移项后：
$$\frac{1}{n}\cdot sum_i=\frac{1}{n}\cdot(n\cdot(sum_{i-1}+1)-\displaystyle\sum_{i=1}^{n}\lbrack i\neq A_{i}\rbrack\cdot sum_{nxt_{S_{c}}})$$ 

化简为：
$$sum_i=n\cdot(sum_{i-1}+1)-\displaystyle\sum_{i=1}^{n}\lbrack i\neq A_{i}\rbrack\cdot sum_{nxt_{S_{c}}}$$ 

只需要维护 $\displaystyle\sum_{i=1}^{n}\lbrack i\neq A_{i}\rbrack\cdot sum_{nxt_{S_{c}}}$，设其为 $def_{i-1}$。考虑从 $def_{nxt_{i-1}}$ 转移过来。

其中，对于 $def_{i}$，$A_{i+1}$ 不贡献，所以除去 $sum_{nxt_{i+1}}$。$def_{nxt_{i}}$ 中 $sum_{(nxt_{i}+1)}$ 并未贡献，需加上。



---

代码：


---


```cpp
#include<bits/stdc++.h>
using namespace std;
const int range=1e6+5;
const long long mod=1e9+7;
int n,m,rec,a[range],nxt[range];
long long sum[range],def[range];
int main()
{
	scanf("%lld%d",&n,&m);
	for(int i=1;i<=m;i++) scanf("%d",&a[i]);
	for(int i=2;i<=m;i++)
	{
		while(rec && a[i]!=a[rec+1]) rec=nxt[rec];
		if(a[i]==a[rec+1]) nxt[i]=++rec;
	}
	for(int i=1;i<=m;i++)
	{
		sum[i]=(((sum[i-1]+1)*n%mod-def[i-1])%mod+mod)%mod;
		printf("%lld\n",sum[i]);
		def[i]=(def[nxt[i]]-sum[nxt[i+1]]+sum[nxt[i]+1])%mod;
	}
	return 0;
}
```

---

## 作者：SmileMask (赞：0)

# 分析
题目可以转化为给定随机的字符串，求 $A$ 第一次出现的位置，下面假设先求整个序列出现的位置。

套路的，记 $f_i$ 为当前匹配到第 $i$ 位，期望需要多少长度能匹配完毕，$f_n=0$，最终答案为 $f_0$，$f$ 转移式有：
$$
f_{i}= 1+\frac{1}{m}f_{i+1}+\frac{1}{m} \sum\limits_{c=1,c\neq s_{i+1}}^m f_{trans_{i,c}}
$$
化简移项得：
$$
f_{i+1}=mf_{i}-m-(\sum\limits_{c=1,c\neq s_{i+1}}^m f_{trans_{i,c}})
$$


$trans_{i,c}$ 为 kmp 自动机上，第 $i$ 个状态接受转移 $c$ 所转移到的状态，$trans$ 的转移式有：
$$
trans_{i,c}=(i+1)[c=s_{i+1}]+trans_{next_i,c}[c\neq s_{i+1}]
$$
$next_i$ 定义为 $\max_{k=1}^{i-1} k[s_{[:k]}=s_{[i-k+1:i]}]$

因为 $f_{i+1}$ 转移的皆为 $i$ 的 $next$ 树上的祖先，所以不妨记 $g_{i}=\sum\limits_{c=1,c\neq s_{i+1}}^m f_{trans_{i,c}}$，考虑如何从 $next_i$ 转移到 $i$。

- 若 $s_{i+1}=s_{next_i+1}$，则 $g_i=g_{next_i}$。
- 若 $s_{i+1}\neq s_{next_i+1}$，则 $g_i=g_{next_i}-f_{h_{i}+1}+f_{next_i+1}$。

实际上都是 $g_i=g_{next_{i}}-f_{h_i+1}+f_{next_i+1}$，其中 $h_i$ 定义为最深的结点 $k$，使得$s_{i+1}=s_{k+1}$，可以开桶 $dfs$ 统计。

$f$ 的转移式变为 $f_{i+1}=mf_i-m-g_i$，可以直接顺序转移，复杂度 $O(n)$。

因为要求解 $f_0$，不妨使用待定系数法，求出 $f_0$ 的系数与常数 $C$，令 $f,g$ 内的元素为二元组 $(a,b)$，表示 $af_0+b$，最后得出 $f_n=xf_0+y=0,\therefore f_0=-\frac{y}{x}$。

因为要求 $A$ 所有前缀出现的答案，其实等价于上面的做法，因为 $next_i$ 并不会大于 $i$，且与 $i$ 后面的字符串无关，所以直接钦定 $f_i=0$ 即可解方程求出答案。

# 代码
因为空间限制，所以要手写dfs+链式前向星。
```cpp
const ll mod=1e9+7;
const int N=1e6+3;

int qmi(int x,int y){
	int res=1;
	x%=mod;
	while(y){
		if(y&1) res=1ll*res*x%mod;
		x=1ll*x*x%mod;y>>=1;
	}
	return res;
}

int n,m,pmt[N];
short a[N];
int head[N],to[N<<1],ne[N<<1],idx=1;
int fr[110],h[N];
pair <int,int> f[N],g[N];

void kmp(){
	pmt[0]=-1;
	for(int i=1;i<=n;i++){
		int j=pmt[i-1];
		while(j>=0&&a[i]!=a[j+1]) j=pmt[j];
		pmt[i]=j+1;
	}
}

bool vis[N];
int sta[N],top;

void add(int a,int b){
	to[++idx]=b,ne[idx]=head[a],head[a]=idx;
}

void dfs(int now){
	memset(vis,0,sizeof vis);
	sta[++top]=now;
	while(top){
	    now=sta[top];
	    if(vis[now]==1){
	        vis[now]=2;
	        if(now<n) fr[a[now+1]]=h[now];
	        top--;
	    }
	    else if(vis[now]==0){
	        vis[now]=1;
	        if(now<n){h[now]=fr[a[now+1]];fr[a[now+1]]=now;}
	        for(int i=head[now];i;i=ne[i]) sta[++top]=to[i];
	    }
	}
}

void Main(){
	m=rd,n=rd;
	int i;
	for(i=0;i<=m;i++) fr[i]=-1;
	for(i=1;i<=n;i++) a[i]=rd;
	kmp();for(i=1;i<=n;i++) add(pmt[i],i);
	dfs(0);for(i=0;i<=n;i++) f[i]={0,0},g[i]={0,0};
	f[0]={1,0},g[0]={m-1,0};
	int tmpm=m%mod,ans;
	for(i=1;i<=n;i++){
		f[i].first=(1ll*f[i-1].first*tmpm%mod-1ll*g[i-1].first+mod)%mod;
		f[i].second=(1ll*f[i-1].second*tmpm%mod-1ll*tmpm-1ll*g[i-1].second+2*mod)%mod;
		g[i].first=(1ll*g[pmt[i]].first+1ll*f[pmt[i]+1].first-1ll*f[h[i]+1].first+mod)%mod;
		g[i].second=(1ll*g[pmt[i]].second+1ll*f[pmt[i]+1].second-1ll*f[h[i]+1].second+mod)%mod;
		ans=1ll*(mod-f[i].second)*qmi(f[i].first,mod-2)%mod;
		printf("%d\n",ans);
	}
}
```

---

## 作者：封禁用户 (赞：0)

首先有一个推论：

> 设 $dp_{i,j}(i<j)$代表目前匹配到了 $i-1$ 这个前缀，这样一直放下去**第一次**匹配到 $j$ 的期望步数（通俗地来讲，就是从 $i$ 走到 $j$ 的步数），那么 $dp_{i,j}=dp_{1,j}-dp_{1,i-1}$。

证明：由于 $i<j$，从 $1$ 到 $j$ 必然经过 $i$，因此 $dp_{i,j}$ 相当于是从 $1$ 开始放，第一次匹配到 $i-1$，再从 $i$ 出发，第一次匹配到 $j$ 的期望步数。即：$dp_{1,j}=dp_{1,i-1}+dp_{i,j}$。

下面进入正题。

### 1、simple 做法

很容易想到一种做法：设 $nxt_{i,j}$ 代表现已匹配到了 $i$ 这个前缀，在结尾放下 $j$ 这个字符后能匹配到的最大前缀。套用 AC 自动机的思想，就有：
$$
nxt_{i,j}=\begin{cases}
  nxt_{fail_i,j}&j \not= s_{i+1}\\
  i+1&j=s_{i+1}
\end{cases}
$$
其中 $fail_i$ 代表失配函数。

于是：
$$
\begin{aligned}
dp_{1,i}&=dp_{1,i-1}+\frac{\sum_{j=1}^n dp_{nxt_{i-1,j}+1,i}}{n}+1\\
&=dp_{1,i-1}+\frac{\sum_{j=1}^n(dp_{1,i}-dp_{1,nxt_{i-1,j}})}{n}+1
\end{aligned}
$$
这是为什么呢？可以感性理解一下，假如我已经知道了 $dp_{1,i-1}$，想要知道 $dp_{1,i}$，就随机出一个字符放下并到达 $nxt_{i-1,j}$，再从 $nxt_{i-1,j}$ 走到 $i$。

化简到这一步，再结合上文提到的 $nxt$ 数组的求法，就能做到在 $O(nm)$ 复杂度解决此题了。

但是此做法有一个很大的问题：$nxt$ 数组开销是 $O(nm)$ 级别的，会 MLE。

### 2、优化做法

尝试优化 $\sum_{j=1}^n dp_{1,nxt_{i-1,j}}$ 这个式子。

设 $f_i=\sum_{j=1}^n dp_{1,nxt_{i-1},j}$。

观察上面关于 $nxt_{i,j}$ 的式子。

发现 $nxt_{i,j}$ 与 $nxt_{fal_i,j}$ 仅有一项差别，可以直接修改。

即：
$$
\begin{aligned}
f_i&=f_{fal_i}-dp_{1,nxt_{fal_i,s_{i+1}}}+dp_{1,nxt_{i,s_{i+1}}}\\
&=f_{fal_i}-dp_{1,nxt_{fal_i,s_{i+1}}}+dp_{1,i+1}
\end{aligned}
$$
再看 $nxt_{fal_i,s_{i+1}}$，我们惊奇地发现：这个式子的含义就是 $fal_{i+1}$！

于是 $f_i=f_{fal_i}-dp_{1,fal{i+1}}+dp_{1,i+1}$。

将 $f_{i-1}$ 带入、移项、化简，就有：
$$
dp_{1,i}=n \times dp_{1,i-1}+dp_{1,fal_i}-f_{fal_{i-1}}
$$
时、空间复杂度均为 $O(m)$。

### 代码：

```cpp
#include <bits/stdc++.h>
#define N 1000005
using namespace std;
int rd(){
    int res=0,c;
    while(c=getchar(),c<48);
    do res=(res<<1)+(res<<3)+(c^48);
    while(c=getchar(),c>=48);
    return res;
}
const int Mod = 1e9 + 7;
int n,m,s[N],fal[N],dp[N],f[N];
int main(){
    n=rd(),m=rd(),fal[0]=-1,f[0]=n;
    for(int i=1;i<=m;i++){
        s[i]=rd();
        int j=fal[i-1];
        while(~j&&s[j+1]!=s[i])j=fal[j];
        fal[i]=j+1;
        dp[i]=1ll*n*(dp[i-1]+1)%Mod;
        if(~fal[i-1]){
            dp[i]=(dp[i]+Mod-f[fal[i-1]])%Mod;
            dp[i]=(dp[i]+dp[j+1])%Mod;
            f[i-1]=((f[fal[i-1]]+dp[i]-dp[j+1])%Mod+Mod)%Mod;
        }
        printf("%d\n",dp[i]);
    }
    return 0;
}
```

---

## 作者：2018ljw (赞：0)

题意很明白，每次随机生成一个字符，求给定字符串的每个前缀第一次出现的期望位置。

假如没有 64M 的空间限制，那么有一个很 trival 的做法：

因为当前串实际关心的只有和目标串匹配到哪个位置，我们对单串建立 AC 自动机，问题就等价于在 trie 图上随机游走，问首次到达每个点的期望步数。

观察下 trie 图，是一个 $0\to n$ 的有向长链，顶上塞了一堆返祖边。你会发现这东西就是 [P6835](https://www.luogu.com.cn/problem/P6835)，于是这题就做完了，时空复杂度 $O(nm)$。

然后考虑如何处理掉这个空间限制。

为了方便后续说明，这里简述 [P6835](https://www.luogu.com.cn/problem/P6835) 的部分做法，基于本题差距有改动。

设 $dp_{x}$ 表示从 $x$ 走到 $x+1$ 的期望步数，答案即为 $\sum\limits_{i=0}^{n-1}{dp_i}$。

则有

$$dp_{x}=1+\frac 1{n}\sum_{y}sum_x-sum_{y-1}$$
$$=1+\frac{n-1}{n}dp_{x}+\frac 1{n}\sum_{y}sum_{x-1}-sum_{y-1}$$
$$dp_{x}=n+(n-1)sum_{x-1}-\sum_{y}sum_{y-1}$$

其中 $y$ 是 $x$ 所有返祖边可到的点。


关注到前两项都能边算边求，所以我们实质上只需要维护最后一项。

AC 自动机干的事是，预处理出 $\sum$ 要枚举哪些位置，然后暴力求解。因此这一部分优化空间的话，要么边算边求位置，要么考虑把 $\sum$ 统一维护起来。这里我们选择后者。

建立 $fail$ 树，每个位置记录 $s_{x+1}$。那么我们对于某个节点接受一个新字符的过程，就等价于找到最深的祖先 $p+1$，满足新字符与该字符相等。换而言之，$p+1$ 就是返祖边的终点。后面那项就是 $\sum sum_p$。

然后考虑 $x$ 和 $fail_x$ 的差别，会发现只有对于 $s_{x+1}$ 一项有改动。但 $sum$ 是在线的，因此预处理遍历 $fail$ 树找到修改时减去贡献的对应位置，然后做到 $x$ 的时候现求即可。

初值，为了方便讨论直接令 $dp_0=n$。实际上根据式子也可直接求出。然后 $0$ 号节点的所有返祖边对该点是没有贡献的（自环），有贡献的只有下行边，即 $\sum =dp_0$。

发现这样处理的话整个过程就和字符集大小没啥关系了，时空复杂度 $O(m)$。

然后这题直接递归是会因为栈空间过大 mle 的，所以需要手搓递归栈，然后循环利用一些暂时没用的数组。

```cpp
#include<cstdio>
const int mod=1e9+7;
int n,m,a[1000001],fail[1000001];
int dp[1000001],dps[1000001];
int stk[1000001],top;
int hed[1000001],net[1000001],ver[1000001],tot;
void add(int x,int y){
	ver[++tot]=y;
	net[tot]=hed[x];
	hed[x]=tot;
}
int lps[101];
void dfs(){
	int i;
	dp[0]=lps[a[1]];
	lps[a[1]]=0;
	while(top){
		int x=stk[top];
		if(!hed[x]){
			lps[a[x+1]]=dp[x];
			top--;
			continue;
		}
		int y=ver[hed[x]];
		hed[x]=net[hed[x]];
		dps[y]=lps[a[y+1]];
		dp[y]=lps[a[y+1]];
		lps[a[y+1]]=y;
		stk[++top]=y;
	}
}
int main(){
	int i,j=0;
	scanf("%d%d",&n,&m);
	for(i=1;i<=m;i++)scanf("%d",&a[i]);
	for(i=2;i<=m;i++){
		while(j&&a[j+1]!=a[i])j=fail[j];
		if(a[j+1]==a[i])j++;
		fail[i]=j;
	}
	for(i=1;i<m;i++)add(fail[i],i); 
	for(i=1;i<=n;i++)lps[i]=-1;top=1;
	dfs();
	dp[0]=a[0]=n;
	for(i=1;i<m;i++){
		dp[i]=n+1ll*(n-1)*dp[i-1]%mod;dp[i]%=mod;
		a[i]=a[fail[i]];
		if(dps[i]!=-1)a[i]+=mod-dp[dps[i]],a[i]%=mod;
		dp[i]+=mod-a[i];dp[i]%=mod;
		dp[i]+=dp[i-1];dp[i]%=mod;
		a[i]+=dp[i];a[i]%=mod;
	}
	for(i=1;i<=m;i++)printf("%d\n",dp[i-1]);
}
```

---


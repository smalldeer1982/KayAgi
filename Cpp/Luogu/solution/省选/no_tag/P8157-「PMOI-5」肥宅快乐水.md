# 「PMOI-5」肥宅快乐水

## 题目背景

lhm 喝肥宅快乐水的时候想到了这个 idea，于是就叫它肥宅快乐水。

~~此题为弱化版，强化版敬请期待 Ynoi。~~

特别感谢：验题人 双管荧光灯 吊打了此题的 std！

## 题目描述

lhm 的手中有 $n$ 个宽度为 $1$ 的矩形水平排列组成的多边形，其中第 $i$ 个矩形的高度为 $a_i$。现在他会进行 $k$ 次操作，每次使一个宽度为 $1$ 的矩形高度减 $1$，求他每次操作后的最大子矩形面积（显然，子矩形必须是连续的一块）。

**注意任何情况高度都大于等于 $0$。**

由于 lhm 太菜了，所以想要请聪明的你来帮他解决。

## 说明/提示

**本题采用捆绑测试。**

|  子任务编号 | 分值 | $n, k$ |
| :-----------: | :---:| :-----------: |
| 1 | 10 | $\leq 500$ |
| 2 | 10 | $\leq 5000$ |
| 3 | 40 | $\leq 10^5$ |
| 4 | 40 | $\leq 5\times10^5$ |

对于 $100\%$ 的数据，$1\le n,k\le 5\times 10^5$，$1\leq a_i\leq 10^9$。保证 $\operatorname{id}'$ 在 `long long` 范围内。

## 样例 #1

### 输入

```
5 2
2 3 1 3 2
2
6```

### 输出

```
5
4```

# 题解

## 作者：jerry3128 (赞：8)

**抢救笛卡尔树**

-----

- 首先考虑笛卡尔树计算静态答案，直接建树后在每个节点的子树大小乘上其高度即可。
- 考虑当高度互不相同的时候，并且 $n$ 和 $q$ 同阶，容易得到均摊 $\mathcal O(1)$ 次旋转可以完成对笛卡尔树形态变化的维护。
- 那么也就是说我们要解决的问题就是当多个节点有同一个高度的时候，我们旋转的 Worst Case 是节点个数的。
- 那么在特意构造的情况下，旋转次数可以被卡到 $\mathcal O(n)$。
- 那么我们需要解决的问题就是：使得每一节点，在向上旋转而跨越某一高度的时候，能够有能被接受的旋转次数。
- 我们考虑将笛卡尔树按 **各个有相同键值** 的连通块划分，对于每个连通块我们单独分析复杂度。那么我们需要支持的操作是：旋转到根、将一个单点插入到父亲联通块中。

### 方法一：随机第二键值
- 考虑到笛卡尔树本质上是用旋转维护的二叉堆。
- 那么我们容易想到另外一个二叉平衡树单旋 Treap，它也用一个随机键值来维护平衡树，使得树高在期望 $\log$ 的高度。
- 那么在一个节点高度减一的时候，我们期望将它旋转 $\mathcal O(\log n)$ 次，并且在同阶的复杂度内维护新树的形态。
- 又因为需要使用一个数据结构维护全局答案最大值，multiset 是一个例子。那么就有复杂度期望 $\mathcal O(n\log^{2}n)$，基于手动随机的第二键值。

### 方法二：强制双旋
- 考虑到单旋的父子该变量为 $\mathcal O(1)$，所以可以被卡。所以使用双旋。
- 考虑双旋的复杂度分析：
1. 对于 $h_{x}<h_{fa_{x}}$
	- 在父亲点、爷爷点二者的高度相同时直接使用双旋。
   - 否则，只会有 $\mathcal O(1)$ 次例外情况，即 $x$ 父亲为根的情况。
   - 此时对于当前连通块双旋复杂度均摊分析成立。
2. 在 $1$ 之后，对于 $h_{x}=h_{fa_{x}}$
	- 将一个节点双旋至根即可。
   - 否则，只会有 $\mathcal O(1)$ 次例外情况，即 $x$ 父亲为根的情况。
- 然后写出来之后你发现这个东西跟 splay 森林没区别。所以有复杂度 $\mathcal O(n\log^{2}n)$。

上述两种方法的两只 $\log$ 均十分小，所以跑过 $5\times 10^{5}$ 应该是没有问题的。

---

## 作者：Lithium_Chestnut (赞：4)

一种简单想到的做法，对于每个可能出现的高度进行离散化。先把一开始出现的值都列出来，用可持久化线段树建出来，然后每次 $\text{-1}$ 就检查这个值有没有，没有就现在再创建。接着对于每个值存一颗线段树，维护哪些点大于等于它。显然答案就是每个值对应的最长连续段长度乘以它的最大值，每次修改只会影响到两棵树。最后可持久化一下，开一个堆维护答案。

但是这种做法常数非常大。所以我们可以优化算法。

首先查一个被改的矩形前面第一个比它小的和后面第一个比它小的，只有前面和后面与它长度的若干相同矩形可延伸的范围会改变。之后这些被改的矩形同时也是区间内的最小值，于是我们只需要修改区间最小值上面所对应的面积就行。

**注意：实现需要优秀。**

最终代码（代码里加了快读，所以看起来很长）：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=500005,E=65536,M=998244353;
namespace io
{
	const int SIZE=(1<<21)+1;
	char ibuf[SIZE],*iS,*iT,obuf[SIZE],*oS=obuf,*oT=oS+SIZE-1,c,qu[55];
    int f,qr;
	#define gc()(iS==iT?(iT=(iS=ibuf)+fread(ibuf,1,SIZE,stdin),(iS==iT?EOF:*iS++)):*iS++)
	inline void flush()
    {
		fwrite(obuf,1,oS-obuf,stdout);
		oS=obuf;
	}
	inline void putc(char x)
    {
		*oS++=x;
		if(oS==oT) flush();
	}
	template<class I>
	inline void gi(I &x)
    {
		for(f=1,c=gc();c<'0' or c>'9'; c=gc())
        {
            if(c=='-') f=-1;
        }
		for(x=0;c<='9' and c>='0';c=gc())
        {
            x=x*10+(c&15);
            x*=f;
        }
	}
	template<class I>
	inline void print(I x)
    {
		if(!x) putc('0');
        if(x<0) putc('-'),x=-x;
		while(x) qu[++qr]=x%10+'0',x/=10;
		while(qr) putc(qu[qr--]);
	}
	struct Flusher_ {~Flusher_(){flush();}}io_flusher_;
}
using io::gi;
using io::putc;
using io::print;
int n,m,mn[N*4],a[N],l[N],r[N],sta[N],top;
long long mnn[N*4],mx[N*4],lazy[N*4],las,x;
void pushup(int i)
{
	mn[i]=min(mn[i<<1],mn[i<<1|1]);
	mx[i]=max(mx[i<<1],mx[i<<1|1]);
	mnn[i]=0;
	if(mn[i]!=mn[i<<1]) mx[i]=max(mx[i],mnn[i<<1]);
	else mnn[i]=max(mnn[i],mnn[i<<1]);
	if(mn[i]!=mn[i<<1|1]) mx[i]=max(mx[i],mnn[i<<1|1]);
	else mnn[i]=max(mnn[i],mnn[i<<1|1]);
    return;
}
void pushdown(int i)
{
	if(lazy[i]!=-1)
    {
		if(mn[i]==mn[i<<1])
        {
			mnn[i<<1]=lazy[i];
			lazy[i<<1]=lazy[i];
		}
		if(mn[i]==mn[i<<1|1])
        {
			mnn[i<<1|1]=lazy[i];
			lazy[i<<1|1]=lazy[i];
		}
		lazy[i]=-1;
	}
    return;
}
void modify(int i,int l,int r,int x,int y,long long z)
{
	if(l==r)
    {
		mn[i]=y;
		mnn[i]=z;
		return;
	}
	pushdown(i);
	int mid=l+r>>1;
	if(mid>=x) modify(i<<1,l,mid,x,y,z);
	else modify(i<<1|1,mid+1,r,x,y,z);
	pushup(i);
    return;
}
void modify2(int i,int l,int r,int ll,int rr,long long x,int y)
{
	if(mn[i]>y) return;
	if(l>=ll and r<=rr)
    {
		lazy[i]=mnn[i]=x;
		return;
	}
	int mid=l+r>>1;
	pushdown(i);
	if(mid>=ll) modify2(i<<1,l,mid,ll,rr,x,y);
	if(mid<rr) modify2(i<<1|1,mid+1,r,ll,rr,x,y);
	pushup(i);
    return;
}
int Findl(int i,int l,int r,int rr,int x)
{
	if(mn[i]>=x) return 0;
	if(l==r) return l;
	int mid=l+r>>1;
	if(mid<rr)
    {
		int as=Findl(i<<1|1,mid+1,r,rr,x);
		return as?as:Findl(i<<1,l,mid,rr,x);
	}
	else return Findl(i<<1,l,mid,rr,x);
}
int Findr(int i,int l,int r,int ll,int x)
{
	if(mn[i]>=x) return n+1;
	if(l==r) return l;
	int mid=l+r>>1;
	if(mid>=ll)
    {
		int as=Findr(i<<1,l,mid,ll,x);
		return as!=n+1?as:Findr(i<<1|1,mid+1,r,ll,x);
	}
	else return Findr(i<<1|1,mid+1,r,ll,x);
}
void Build(int i,int ul,int ur)
{
	if(ul==ur)
    {
		mn[i]=a[ul];
		mnn[i]=1ll*(r[ul]-l[ul]-1)*a[ul];
		return;
	}
	int mid=ul+ur>>1;
	Build(i<<1,ul,mid);
	Build(i<<1|1,mid+1,ur);
	pushup(i);
    return;
}
int main()
{
	gi(n),gi(m);
	for(int i=1;i<=n;++i) gi(a[i]);
	for(int i=1;i<=n;++i)
    {
		while(a[sta[top]]>a[i]) r[sta[top--]]=i;
		sta[++top]=i;
	}
	while(top) r[sta[top--]]=n+1;
	for(int i=n;i>=1;--i)
    {
		while(a[sta[top]]>a[i]) l[sta[top--]]=i;
		sta[++top]=i;
	}
	Build(1,1,n);
	memset(lazy,-1,sizeof(lazy));
	while(m--)
    {
		gi(x);
		x^=las;
		int ul=Findl(1,1,n,x,a[x]),ur=Findr(1,1,n,x,a[x]);
		++ul,--ur;
		modify2(1,1,n,ul,x,1ll*(x-ul)*a[x],a[x]),modify2(1,1,n,x,ur,1ll*a[x]*(ur-x),a[x]);
		--a[x];
		--ul,++ur;
		if(ul>0) ul=Findl(1,1,n,ul,a[x]);
		if(ur<=n) ur=Findr(1,1,n,ur,a[x]);
		modify(1,1,n,x,a[x],1ll*a[x]*(ur-ul-1));
		las=max(mx[1],mnn[1]);
		print(las);
		putc('\n');
	}
    return 0;
}
```


---

## 作者：Imiya (赞：0)

众所周知，[笛卡尔树](https://oi-wiki.org/ds/cartesian-tree/#%E4%BE%8B%E9%A2%98)可以用来求解静态最大子矩形问题，加入了单点减一操作后很容易想到可以通过旋转维护笛卡尔树，再用一些类似删除堆的东西来动态维护答案。由于每次操作只会减一，所以如果需要用旋转调整笛卡尔树的结构，一定有此次操作的节点 $x$ 在操作前的高度 $h$ 与其父节点的高度 $h'$ 相同，于是 $x$ 将一直往上旋转直到撞到一个高度小于 $h$ 的节点，所以直接旋转的话容易被有一坨相同高度的数据卡成单次 $O(n)$。

那么考虑如何优化笛卡尔树的结构。

```
新建一个大小为 n 的空栈。用 top 来标操作前的栈顶。
For i := 1 to n
    While 栈非空 且 栈顶元素 > 当前元素 
        当前元素.左儿子 := 栈顶元素
        top--
    if 栈非空
        栈顶元素.右儿子 := 当前元素
    当前元素入栈
```

这是正常使用单调栈建笛卡尔树的伪代码，下图是用这种方法建出的树。

![](https://cdn.luogu.com.cn/upload/image_hosting/l66jg9bp.png)

相比上图，下图同样是一棵合法的笛卡尔树但是显然在执行单点减一时效率更高。

![](https://cdn.luogu.com.cn/upload/image_hosting/s5b3nuqd.png)

那么我们的任务就是维护笛卡尔树上高度相同的连通块尽量平衡，使得单次操作旋转次数降低。

最简单的方法就是借鉴 Treap，给每一个点附加一个随机权重，如果两个节点高度相同，就用权重来比较大小，这样一来每一个相同高度连通块的期望高度就是 $O(\log n)$。

由于笛卡尔树本身就是一种特殊的 Treap，所以这个优化相当轻松，相比最开始提到的朴素算法，只需要把每个点的值改成第二元随机的二元组，再重载二元组的比较使得优先比较第一元然后比较第二元即可。

最后需要在每个子树的大小发生变动时更新答案，使用删除堆会被卡空间，使用 `multiset` 会被卡时间（当然也可能是我的写法不好 qwq），所以可以用小常数线段树来做。

每次操作需要旋转 $O(\log n)$ 次，每次旋转时更新答案 $O(\log n)$，所以最后复杂度是 $O(k\log^2 n)$。

Code
```cpp
#include<iostream>
#include<cstdlib>
#include<set>
using namespace std;
#define int long long
inline int read(){
    int i=getchar(),r=0;
    while(i<'0'||i>'9')i=getchar();
    while(i>='0'&&i<='9')r=(r<<1)+(r<<3)+(i^48),i=getchar();
    return r;
}
const int N=500100;
namespace bst{//单点修改，全局最大值
    int L[N<<1],R[N<<1],ls[N<<1],rs[N<<1],fa[N<<1],mx[N<<1],loc[N],ver,rt;
    inline int New(int L_,int R_,int ls_,int rs_){
        ver++;
        L[ver]=L_,R[ver]=R_,ls[ver]=ls_,rs[ver]=rs_;
        if(L_==R_)loc[L_]=ver;
        if(ls_)fa[ls_]=ver;
        if(rs_)fa[rs_]=ver;
        return ver;
    }
    int build(int l,int r){
        if(l==r)return New(l,r,0,0);
        int mid=(l+r)>>1;
        return New(l,r,build(l,mid),build(mid+1,r));
    }
    inline void modify(int nd,int k){
        mx[nd]=k;
        while(nd!=rt)nd=fa[nd],mx[nd]=max(mx[ls[nd]],mx[rs[nd]]);
    }
}
struct node{
    int h,wei;
    inline bool operator<(const node&b)const&{return h<b.h||(h==b.h&&wei<b.wei);}
}a[N];
int s[N][2],fa[N],siz[N],val[N],rt;
inline void push_up(int nd){//更新答案与更新siz和更新子节点的父节点放在了一起
    siz[nd]=siz[s[nd][0]]+siz[s[nd][1]]+1;
    val[nd]=siz[nd]*a[nd].h;
    bst::modify(bst::loc[nd],val[nd]);
    if(s[nd][0])fa[s[nd][0]]=nd;
    if(s[nd][1])fa[s[nd][1]]=nd;
}
inline void rotate(int x){
    int y=fa[x],z=fa[fa[x]];
    int d=(x==s[y][1]);
    s[y][d]=s[x][d^1];
    s[x][d^1]=y;
    push_up(y),push_up(x);
    fa[x]=z;
    if(z)s[z][y==s[z][1]]=x,push_up(z);
}
inline void update(int nd){
    while(fa[nd]&&a[nd]<a[fa[nd]])rotate(nd);
    if(!fa[nd])rt=nd;
}
int stk[N],top=0;
void pre(int nd){
    if(!nd)return;
    pre(s[nd][0]);
    pre(s[nd][1]);
    push_up(nd);
}
int build(int n){
    for(int i=1;i<=n;i++){
        while(top&&a[i]<a[stk[top]])s[i][0]=stk[top--];
        if(top)s[stk[top]][1]=i;
        stk[++top]=i;
    }
    pre(stk[1]);
    return stk[1];
}
int n,m;
void init(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)a[i]={read(),rand()};
    bst::rt=bst::build(1,n);
    rt=build(n);
}
signed main(){
    // freopen("read.in","r",stdin);
    init();
    int ans=0;
    while(m--){
        int p=read()^ans;
        a[p].h--;
        push_up(p);
        update(p);
        ans=bst::mx[bst::rt];
        printf("%lld\n",ans);
    }
    return 0;
}   
```

---

## 作者：FutaRimeWoawaSete (赞：0)

orz @[jerry3128](https://www.luogu.com.cn/user/27338)。

考虑到原问题及静态查询全局最大子矩形，显然是建出笛卡尔树后可以直接求的。

考虑一下 $-1$ 的性质。我们可以将原来的笛卡尔树进行类似 Splay 森林的划分，即将高度相同且在笛卡尔树上有边相连的节点划分成一棵 Splay。

那么我们不难发现，对于一个节点 $x$ 的高度减 $1$，相当于是要让 $x$ 从它所属的 Splay 里面出来（删掉），插入之前所属 Splay 向上找的第一个 Splay 里面（或是发现向上找的第一个 Splay 的值不等于 $h_x - 1$ 时自创一个 Splay）。

问题等价于从 Splay 中删除点并插入一个点，直接使用双旋的时间复杂度等价于 Splay 插入删除的旋转次数即 $O(q \log n)$。

同时每次双旋只会影响父亲儿子的子树大小，开个 multiset 什么的你开心就好维护每个点的答案，最后得到全局答案。

静态构建笛卡尔树，时间复杂度 $O(q \log ^ 2 n)$，经~~实验分析~~可知常数极小。

同时讲一下为什么不能进行任意减，记之前的值为 $h_x$ 现在的值为 $hh_x$，一个比较好理解的说法是每次一个点向上旋转至少要跨越 $[hh_x,h_x]$ 高度值域内出现的高度种类数，显然这个就可以卡了。

从 splay 森林本身的角度解释。如果以 LCT 式 splay 森林的角度进行理解，我们不难发现如果一个点向上多次跨越，那么不能简单粗暴地将一个点的父亲旋转到右儿子，因为第一个下标键值就已经是**约束 Splay 树形态的键值**，如果简单粗暴旋转就有可能破坏笛卡尔树关于第二键值的约束（小根堆）。

所以只能像最开始一样，将一次操作看成是对多棵 Splay 节点的插入/删除，时间复杂度自然爆炸。

```cpp
#include "bits/stdc++.h"
using namespace std;
const int Len = 5e5 + 5;
const long long Inf = 1e18;
inline long long read() {
    char ch = getchar();
    long long x = 0, f = 1;
    while (ch < '0' || ch > '9') {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while ('0' <= ch && ch <= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
inline void write(long long x) {
    if (x < 0)
        putchar('-'), x = -x;
    if (x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
}
int n,k,v[Len],rt;
long long a[Len];
struct Segment
{
	long long maxn[Len << 2];
	#define ls(p) p << 1
	#define rs(p) p << 1 | 1
	void push_up(int x){maxn[x] = max(maxn[ls(x)] , maxn[rs(x)]);}
	void build(int p,int l,int r)
	{
		maxn[p] = 0;
		if(l == r){maxn[p] = a[l];return;}
		int mid = (l + r) >> 1;
		build(ls(p) , l , mid);
		build(rs(p) , mid + 1 , r);
		push_up(p);
	}
	void add(int p,int l,int r,int idx)
	{
		if(l == r){maxn[p] = a[l];return;}
		int mid = (l + r) >> 1;
		if(idx <= mid) add(ls(p) , l , mid , idx);
		else add(rs(p) , mid + 1 , r , idx);
		push_up(p);
	}
	void erase(int p,int l,int r,int idx)
	{
		if(l == r){maxn[p] = -Inf;return;}
		int mid = (l + r) >> 1;
		if(idx <= mid) erase(ls(p) , l , mid , idx);
		else erase(rs(p) , mid + 1 , r , idx);
		push_up(p);
	}
	long long Q(){return maxn[1];}
}T1;
struct node
{
	int ch[2],fa,val,siz;
	node(){ch[0] = ch[1] = fa = val = siz = 0;}
	node(int CH0,int CH1,int FA,int VAL,int SIZ){ch[0] = CH0 , ch[1] = CH1 , fa = FA , val = VAL , siz = SIZ;}
}p[Len];
int Init()
{
	p[0].val = 0;
	for(int i = 1 ; i <= n ; i ++)
	{
		int P = i - 1;
		while(p[P].val > p[i].val) P = p[P].fa;
		p[i].ch[0] = p[P].ch[1];
		p[P].ch[1] = i;
		p[i].fa = P;
		p[p[i].ch[0]].fa = i;
	}
	return p[0].ch[1];
}
void dfs(int x)
{
	if(!x) return;
	p[x].siz = 1;
	dfs(p[x].ch[0]);
	dfs(p[x].ch[1]);
	p[x].siz = 1 + p[p[x].ch[0]].siz + p[p[x].ch[1]].siz;
	a[x] = 1ll * p[x].siz * p[x].val;
}
void push_up(int x){p[x].siz = p[p[x].ch[0]].siz + p[p[x].ch[1]].siz + 1;}
void rotate(int x)
{
	int fa = p[x].fa , fafa = p[fa].fa , idf = (p[fa].ch[1] == x) , idff = (p[fafa].ch[1] == fa);
	if(fa) T1.erase(1 , 1 , n , fa);
	if(x) T1.erase(1 , 1 , n , x);
	if(fafa) p[fafa].ch[idff] = x;
	p[fa].ch[idf] = p[x].ch[idf ^ 1];
	p[p[fa].ch[idf]].fa = fa;
	p[x].ch[idf ^ 1] = fa;
	p[fa].fa = x , p[x].fa = fafa;
	push_up(fa) , push_up(x);
	a[fa] = 1ll * p[fa].siz * p[fa].val;
	a[x] = 1ll * p[x].siz * p[x].val;
	if(fa) T1.add(1 , 1 , n , fa);
	if(x) T1.add(1 , 1 , n , x);
}
void del(long long x)
{
	int fa = p[x].fa;
	p[x].val --;
	T1.erase(1 , 1 , n , x);
	while(fa && p[x].val <= p[fa].val)
	{
		int fafa = p[fa].fa;
		if(fafa && fa && p[fafa].val == p[fa].val)
		{
			if((p[fafa].ch[1] == fa) == (p[fa].ch[1] == x)) rotate(fa);
			else rotate(x);
		}
		rotate(x);
		fa = p[x].fa;
	}
	a[x] = 1ll * p[x].val * p[x].siz;
	T1.add(1 , 1 , n , x);
}
int main()
{
	n = read() , k = read();
	for(int i = 1 ; i <= n ; i ++) 
	{
		int x;x = read();
		p[i] = node(0 , 0 , 0 , x , 1);
	}
	rt = Init();
	dfs(rt);
	T1.build(1 , 1 , n);
	long long id,lstans = 0;
	for(int i = 1 ; i <= k ; i ++)
	{
		id = read();
		id ^= lstans;
		del(id);
		write(lstans = T1.Q());
		puts("");
	}
	return 0;
} 
```


---


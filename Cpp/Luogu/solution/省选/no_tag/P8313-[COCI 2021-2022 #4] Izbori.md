# [COCI 2021/2022 #4] Izbori

## 题目描述

Malnar 先生正在竞选县长，这个县一共有 $n$ 栋房屋，每栋房屋里都住着一位居民。Malnar 先生知道，选举的赢家不一定是最好的候选人，而是在选举前举办的宴会最好的候选人。因此，在选举前几天，他将邀请第 $l$ 至 $r(l\le r)$ 栋房屋内居住的居民，为他们准备一顿丰盛的晚餐。

Malnar 先生知道所有居民最喜欢吃的菜。在宴会上，他会准备大多数人喜欢的一道菜。如果一个人吃到了自己最喜欢吃的菜，将会投一票给 Malnar 先生。但是如果没有吃到自己最喜欢吃的菜，他们将会把票投给 Vlado 先生。如果没有来参加晚宴的居民，他们将会忘记选举，不做出任何投票。如果一个候选人获得了投了票的人中一半以上的人的支持，他将会赢得竞选。

Malnar 先生想知道，有多少组的 $(l,r)$ 可以使他赢得竞选。

## 说明/提示

**【样例 2 解释】**

可以使 Malnar 先生赢得竞选的 $(l,r)$ 为：$(1, 1),(2, 2),(3, 3),(1, 3)$。

**【数据规模与约定】**

**本题采用子任务捆绑测试。**

- Subtask 1（10 pts）：$1 ≤ n ≤ 300$。
- Subtask 2（15 pts）：$1 ≤ n ≤ 2\times10^3$。
- Subtask 3（15 pts）：$\forall i\in\{1,2,3,\dots,n\},1 ≤ a_i ≤ 2$。
- Subtask 4（70 pts）：没有额外限制。

对于 $100\%$ 的数据，$1 \le l\le r ≤ n ≤ 2\times10^5,1 ≤ a_i ≤ 10^9$。

**【提示与说明】**

**本题分值按 COCI 原题设置，满分 $110$。**

**题目译自 [COCI2021-2022](https://hsin.hr/coci/) [CONTEST #4](https://hsin.hr/coci/contest4_tasks.pdf) T3 Izbori。**

## 样例 #1

### 输入

```
2
1 1```

### 输出

```
3```

## 样例 #2

### 输入

```
3
2 1 2```

### 输出

```
4```

## 样例 #3

### 输入

```
5
2 2 1 2 3```

### 输出

```
10```

# 题解

## 作者：Demeanor_Roy (赞：17)

[原题链接](https://www.luogu.com.cn/problem/P8313)

提供一种考场上想出来的 $n \log^2 n$ 分治做法，应该比正解好实现许多。


------------

首先由于是序列计数问题，自然要往单调性方面去想。可仔细思考就会发现，众数这东西的性质好像不那么美妙，区间扩展时并不具有很好的性质，不能考虑枚举左端点然后向右扩展。

既然区间扩展不行，就考虑区间拼接。

我们先考虑两个区间拼起来是合法的，需要满足什么条件？我们用 $L_x,R_x$ 分别表示 $L,R$ 区间喜欢 $x$ 菜肴的人数，那么 $L,R$ 拼接起来合法，一定是存在一个 $x$，使得 $2 \times (L_x+R_x) > len_L+len_R$，不难发现不等式拆开就是一个一维偏序，将序列离散化后两组区间的拼接可以 $O(n)$ 解决。

可现在还有一个问题，上面偏序的前提是 $x$ 确定，可我们怎么知道 $x$ 是什么呢？不难发现，对于两个确定的区间拼接，$x$ 必须是其中一方的众数，可这并不能帮助我们把许多区间更快拼接。

可让我们一看题目,你就会发现题目还有一个很强的条件：获得一半以上的人支持！

我们定义一个序列有绝对众数，当且仅当一个序列的众数个数大于区间长度除以二。这时我们可以将上面的结论改一改：对于两个确定的区间拼接，$x$ 必须是其中一方的绝对众数。

考虑序列分治，每次递归处理子区间的问题，现在我们只考虑跨过 $mid$ 的区间。考虑分治带给我们什么好处：不难发现，对于左半部分，这些区间右端点固定，对于右边部分，这些区间左端点固定。

那这又有什么用呢？不难发现，一端端点固定的一组序列，不同的绝对众数的个数是 $\log n$ 级别的。这也很好证明，因为若 $[L,R]$ 这段区间绝对众数为 $a$ ,那么往左右扩展时要求众数改变并且是绝对众数，每次几乎都需要成倍级别增长，结论得证。

那这时思路就明确了，先序列分治，然后对于每层来说，先求出可能的绝对众数作为 $x$，然后枚举绝对众数用桶做一维偏序。

并且这样做不会算重，因为拼接后的一个序列一定只会被一个绝对众数判断为合法。

下附代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define mid ((l+r)>>1)
const int N=2e5+10,delta=2e5;
int n,val[N],cnt[N<<1];
bool vis[N];
vector<int> vec,chosen;
inline LL solve(int l,int r)
{
	if(l==r) return 1;
	LL ans=solve(l,mid)+solve(mid+1,r);
	for(int i=mid;i>=l;i--)
	{
		cnt[val[i]]++;
		if(!vis[val[i]]&&cnt[val[i]]>(mid-i+1)/2)	
		{
			chosen.push_back(val[i]);
			vis[val[i]]=true;
		}
	}
	for(int i=mid;i>=l;i--)	cnt[val[i]]--;
	for(int i=mid+1;i<=r;i++)
	{
		cnt[val[i]]++;
		if(!vis[val[i]]&&cnt[val[i]]>(i-mid)/2)	
		{
			chosen.push_back(val[i]);
			vis[val[i]]=true;
		}
	}
	for(int i=mid+1;i<=r;i++)	cnt[val[i]]--;
	for(auto x:chosen)
	{
		int	now,minn=delta-max(mid-l+1,r-mid),maxn=delta+max(mid-l+1,r-mid);
		now=0;
		for(int i=mid;i>=l;i--)	
		{
			now+=(val[i]==x);
			cnt[(now<<1)-(mid-i+1)+delta]++;
		}
		for(int i=minn;i<=maxn;i++)	cnt[i]+=cnt[i-1];
		now=0;
		for(int i=mid+1;i<=r;i++)
		{
			now+=(val[i]==x);
			ans+=(mid-l+1)-cnt[(i-mid)-(now<<1)+delta];
		}
		for(int i=minn;i<=maxn;i++)	cnt[i]=0;		
	}
	chosen.clear();
	for(int i=l;i<=r;i++)	vis[val[i]]=false;
	return ans;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)	scanf("%d",&val[i]);
	for(int i=1;i<=n;i++)	vec.push_back(val[i]);
	sort(vec.begin(),vec.end());
	vec.erase(unique(vec.begin(),vec.end()),vec.end());
	for(int i=1;i<=n;i++)	val[i]=lower_bound(vec.begin(),vec.end(),val[i])-vec.begin()+1;
	printf("%lld",solve(1,n));
	return 0;
}
```
完结撒花~

---

## 作者：lnwhl (赞：15)

## 前言
- $\text{Upd on 2022.10.17}$ 修改了一处笔误 

[更棒的阅读体验](https://www.cnblogs.com/lnwhl/p/16640878.html)

很棒的一道题，建议评紫。

这里提供一种 $\mathcal O(n\log n)$ 的树状数组的解法，并有详细的部分分题解，可能比较长，如果只想看正解可以直接看 Subtask 4，代码在最后面（包括部分分代码）。
## Subtask 1
暴力穷举区间，枚举众数判断即可。复杂度 $\mathcal O(n^3)$。
## Subtask 2
暴力穷举区间，区间元素个数用一个桶维护起来，区间 $(i,j+1)$ 的各个元素的个数可以由区间 $(i,j)$ 递推得。但由于 $a_i$ 得范围达到了 $10^9$，需要离散化一下。复杂度 $\mathcal O(n^2)$。
## Subtask 3
考虑到只有 $1，2$ 两种数字，所以区间不合法只有一种情况：区间内 $1，2$ 个数相等。考虑将 $1$ 的值设成 $1$，$2$ 的值设成 $-1$，所以不合法的区间的区间和为 $0$，可以记录一个前缀桶来维护。复杂度 $\mathcal O(n)$。
## Subtask 4
受 Subtask 3 的启发，穷举每个种类的数，分别计算贡献。

$a_i\le10^9$ 明显是纸老虎，离散化一下就可以了。考虑当前计算的是 $x$ 的贡献，记 $S_i$ 为前 $i$ 个数中 $x$ 出现的次数，则 $[l+1,r]$ 区间合法则需
$$2(S_r-S_l)> r-l$$
移一下项就变为
$$2S_r-r>2S_l-l$$
这样问题就变成了：对于每一个 $r$，$0\sim r-1$ 中由多少个 $l$ 使 $2S_l-l<2S_r-r$，是一个二维偏序问题，可以通过树状数组维护，复杂度是 $\mathcal O(kn\log n)$ 的，其中 $k$ 为不同数字的个数。但是这样还是只能通过前三个 Subtask，需要优化。

设 $B_i=2S_i-i$，对于每一个 $x$，考虑 $B_i$ 的变化情况。举个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/r6k4m3kr.png)

可以发现如果有 $m$ 个 $x$，那么 $B_i$ 可以被分成 $m+1$ 个区间，每个区间都是一个公差为 $-1$ 的等差数列。考虑到所有的 $m$ 的和为 $n$，我们其实只需要快速处理每一段里的数。

假设这个等差数列为 $s,s-1,\cdots,e+1,e$，用一个数组 $C_i$ 来记录每一个数的个数，那么就是 $[e,s]$ 区间的每个 $C_i$ 都加 $1$。

设 $D_i$ 表示 $C_i$ 的前缀和，即 $D_i=\sum\limits_{j=1}^iC_j$，对于每个 $B_i$，贡献即为 $D_{B_i-1}$，所以对于 $[e,s]$ 这个区间内的所有数，总贡献即为 $\sum\limits_{i=e-1}^{s-1}D_i$，这又变成了一个区间和问题，我们再维护一个数组 $E_i$ 表示 $C_i$ 前缀和的前缀和，即为 $D_i$ 数组的前缀和，即 $E_i=\sum\limits_{j=1}^iD_j$，这样总贡献就变成了
$$\sum\limits_{i=e-1}^{s-1}D_i=E_{s-1}-E_{e-2}$$
至此问题就变成了一个**区间修改，求二阶前缀和**的问题。这就有很多解法了，这里只提供一个树状数组的解法。

考虑到区间修改可以通过**单点修改，求前缀和**来解决，问题就可已转化为**单点修改，求三阶前缀和**。

推的过程比较繁琐，如果不理解可以自己手模两组数据来理解。

------------
现在问题变成了**单点修改，求三阶前缀和**，该如何处理？

如果不会建议先看一看这道题，[ABC 256 F Cumulative Cumulative Cumulative Sum](https://atcoder.jp/contests/abc256/tasks/abc256_f)，这里讲一下树状数组的思路。

先假设 $A_i$ 为原数组，$B_i$ 数组为 $A_i$ 的前缀和，$C_i$ 数组为 $A_i$ 数组的二阶前缀和，$D_i$ 数组为 $A_i$ 的三阶前缀和。

考虑 $A_i$ 对 $B_x$ ($i\le x$) 的贡献为 $1$。

考虑 $A_i$ 对 $C_x$ ($i\le x$) 的贡献为 $x-i+1$。

考虑 $A_i$ 对 $D_x$ ($i\le x$) 的贡献为 $\dfrac{(x-i+1)(x-i+2)}{2}$。
$$D_i=\sum\limits_{i=1}^x\dfrac{(x-i+1)(x-i+2)}{2}A_i$$
$$D_i=\dfrac{(x+1)(x+2)}{2}\sum\limits_{i=1}^xA_i-\dfrac{2x+3}{2}\sum\limits_{i=1}^xiA_i+\dfrac{1}{2}\sum\limits_{i=1}^xi^2A_i$$
用树状数组分别维护 $A_i,iA_i,i^2A_i$，可以解决。

------------
至此，问题就完全解决了。代码在最下面，写了注释。
## 代码
### Subtask 2
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N=2e5+5;
int n,a[N],cop[N],tong[N];
ll ans=0;
signed main()
{
	cin>>n;
	for(int i=1;i<=n;++i)
		cin>>a[i],cop[i]=a[i];//cop为离散化数组
	sort(cop+1,cop+n+1);
	int cntl=unique(cop+1,cop+n+1)-cop-1;
	for(int i=1;i<=n;++i)
		a[i]=lower_bound(cop+1,cop+cntl+1,a[i])-cop;//离散化
	for(int l=1;l<=n;++l)
	{
		int cur=a[l];
		for(int r=l;r<=n;++r)
		{
			tong[a[r]]++;//更新桶数组
			if(tong[a[r]]>tong[cur])cur=a[r];//打擂台得出出现次数最多的元素
			if(tong[cur]*2>r-l+1)ans++;//判断区间众数个数一半
		}
		for(int r=l;r<=n;++r)tong[a[r]]--;//清空tong数组
	}
	cout<<ans;
	return 0;
}
```
### Subtask 3
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N=2e5+5;
int n,a[N],b[N],tong[N<<1];
ll ans=0;
signed main()
{
	cin>>n;
	for(int i=1;i<=n;++i)
	{
		cin>>a[i];
		if(a[i]==1)b[i]=1;
		else b[i]=-1;
	}
	//因为前缀和会出现负数，所以要统一偏移n 
	int sum=0;tong[n]++;
	for(int i=1;i<=n;++i)
	{
		sum+=b[i];//前缀和 
		ans+=tong[sum+n];//更新答案 
		tong[sum+n]++;//更新桶 
	}
	cout<<1ll*n*(n+1)/2-ans;//合法区间-不合法区间 
	return 0;
}
```
### Subtask 4 不加优化做法
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N=2e5+5;
int n,a[N],cop[N],bsum[N<<1],s[N];
ll ans=0;
inline int lowbit(int x){return x&-x;}
inline void add(int i,int x)
{
	while(i<=2*n+2)bsum[i]+=x,i+=lowbit(i);
}
inline int query(int i)
{
	int res=0;
	while(i)res+=bsum[i],i-=lowbit(i);
	return res;
}
signed main()
{
	cin>>n;
	for(int i=1;i<=n;++i)
		cin>>a[i],cop[i]=a[i];//cop为离散化数组
	sort(cop+1,cop+n+1);
	int cntl=unique(cop+1,cop+n+1)-cop-1;
	for(int i=1;i<=n;++i)
		a[i]=lower_bound(cop+1,cop+cntl+1,a[i])-cop;//离散化
	for(int i=1;i<=cntl;++i)
	{
		for(int j=1;j<=n;++j)
			s[j]=s[j-1]+(a[j]==i);//求出前缀和
		add(n+1,1);//n+1的偏移量
		for(int j=1;j<=n;++j)
		{
			ans+=query(2*s[j]-j+n);//树状数组查询
			add(2*s[j]-j+n+1,1);
		}
		add(n+1,-1);
		for(int j=1;j<=n;++j)
			add(2*s[j]-j+n+1,-1);//清空树状数组
	}
	cout<<ans;
	return 0;
}
```
### Subtask 4 AC 代码
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N=2e5+5;
int n,a[N],cop[N];
ll ans=0,bs1[N<<1],bs2[N<<1],bs3[N<<1];
//bs1，bs2，bs3维护树状数组，需要进行n+1的偏移量 
vector<int>t[N];
inline int lowbit(int x){return x&-x;}
inline void add(int i,ll d)
{
	int x=i;
	while(i<=2*n+2)
	{
		bs1[i]+=d;bs2[i]+=d*x;bs3[i]+=d*x*x;
		i+=lowbit(i);
	}
}
inline ll query(int i)
{
	ll res=0;int x=i;
	while(i)
	{
		res+=bs1[i]*(x+2)*(x+1)-bs2[i]*(2*x+3)+bs3[i];
		i-=lowbit(i);
	}
	return res/2;
}
//树状数组 
signed main()
{
	cin>>n;
	for(int i=1;i<=n;++i)
		cin>>a[i],cop[i]=a[i];//cop为离散化数组
	sort(cop+1,cop+n+1);
	int cntl=unique(cop+1,cop+n+1)-cop-1;
	for(int i=1;i<=n;++i)
		a[i]=lower_bound(cop+1,cop+cntl+1,a[i])-cop;//离散化
	for(int i=1;i<=n;++i)t[a[i]].push_back(i);//每一类数组又一个向量存起来 
	for(int i=1;i<=cntl;++i)//穷举数字 
	{
		t[i].push_back(n+1);
		int lst=0;
		for(int j=0;j<t[i].size();++j)
		{
			int y=2*j-lst+n+1,x=2*j-t[i][j]+n+2;
			ans+=query(y-1)-(x>=3?query(x-2):0);//树状数组查询 
			add(x,1);add(y+1,-1);lst=t[i][j];
		}
		lst=0;
		for(int j=0;j<t[i].size();++j)
		{
			int y=2*j-lst+n+1,x=2*j-t[i][j]+n+2;
			add(x,-1);add(y+1,1);lst=t[i][j];
		}//清空树状数组 
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：竹取颱 (赞：5)

题意：给定一个序列，求存在绝对众数的区间个数。

题解：不难发现区间的绝对众数唯一。我们枚举绝对众数为 $ x $，将序列中所有的 $ x $ 标记为 $ 1 $，其余的标记为 $ -1 $。那么一个区间的绝对众数为 $ x $ 等价于区间内所有数的和 $ >0 $。

于是我们可以搞个前缀和，每次新加入一个数，设当前前缀和为 $ y $，则之前所有前缀和 $ <y $ 的地方与当前位置的形成的区间的绝对众数都是 $ x $。

直接做能做到 $ O(n^2) $，但是无法通过。

观察到对于所有的 $ x $，被标记为 $ 1 $ 的地方只会出现 $ O(n) $ 次，但是被标记为 $ -1 $ 的地方却会频繁出现。不如考虑将一段连续的 $ -1 $ 合并转移。具体来说，开个值域上的线段树，在 $ p $ 的维护前缀和为 $ p $ 的个数。对于加入一个 $ 1 $ 操作，是平凡的。对于加入一段 $ -1 $ 操作，以他们为左端点的贡献也是平凡的，只需要考虑以他们为右端点的贡献即可。

设这个 $ -1 $ 段的长度为 $ l $，发现这个贡献是形如靠左的一段 $ +l $，中间的长为 $ l $ 的一段依次 $ +l-1,+l-2,\dots,+0 $。这就好办了，我们再在线段树上维护一个下标乘个数的值，就可以做了。时间复杂度为 $ O(n\log n) $。

细节还挺多的，具体看代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define pii pair<ll,ll>
#define mp make_pair
#define fi first
#define se second
#define pb push_back
const ll N=2e5+10;
inline ll read(){
	ll a=0,x=1;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-')	x=-x;
		c=getchar();
	}
	while(isdigit(c)){
		a=a*10+c-'0';
		c=getchar();
	}
	return a*x;
}
struct node{
	ll cnt,ids;
}tmp;
struct SEG{//warning warning线段树左端点从0开始 
	node t[N<<3];
	ll tag[N<<3];
	#define ls (nw<<1)
	#define rs ((nw<<1)|1)
	#define mid ((l+r)>>1)
	node merge(node l,node r){
		node res;
		res.cnt=l.cnt+r.cnt;
		res.ids=l.ids+r.ids;
		return res;
	}
	void pushup(ll nw){
		t[nw]=merge(t[ls],t[rs]);
	}
	void pushd(ll nw,ll val,ll l,ll r){
		tag[nw]+=val;
		t[nw].cnt+=val*(r-l+1);
		t[nw].ids+=(r+l)*(r-l+1)/2*val;
	}
	void pushdown(ll nw,ll l,ll r){
		if(tag[nw]){
			pushd(ls,tag[nw],l,mid);
			pushd(rs,tag[nw],mid+1,r);
			tag[nw]=0;
		}
	}
	void update(ll nw,ll l,ll r,ll x,ll y,ll v){
		if(x<=l&&r<=y){
			pushd(nw,v,l,r);
			return;
		}
		pushdown(nw,l,r);
		if(x<=mid)	update(ls,l,mid,x,y,v);
		if(y>mid)	update(rs,mid+1,r,x,y,v);
		pushup(nw);
	}
	node query(ll nw,ll l,ll r,ll x,ll y){//区间查询前缀和之和 
		if(x<=l&&r<=y){
			return t[nw];
		}
		pushdown(nw,l,r);
		if(y<=mid)	return query(ls,l,mid,x,y);
		if(x>mid)	return query(rs,mid+1,r,x,y);
		return merge(query(ls,l,mid,x,y),query(rs,mid+1,r,x,y));
	}
}T;
vector<ll> c[N]; 
ll n,v,a[N],dsc[N];
ll ans=0;
signed main(){
	n=read();
	for(ll i=1;i<=n;i++){
		a[i]=read();
		dsc[i]=a[i];
	}
	sort(dsc+1,dsc+n+1);
	v=unique(dsc+1,dsc+n+1)-dsc-1;
	for(ll i=1;i<=n;i++){
		a[i]=lower_bound(dsc+1,dsc+v+1,a[i])-dsc;
		c[a[i]].push_back(i);
	}
	T.update(1,0,2*n,n,n,1);
	for(ll i=1;i<=v;i++){
		c[i].push_back(n+1);
		for(ll j=0,cur=0,lst=0;j<(ll)(c[i].size());j++){
			if(c[i][j]-1!=lst){
				ll len=c[i][j]-lst-1;
				//加入一段lst+1到c[i]-1的-1
				if(len>1){
					tmp=T.query(1,0,2*n,n+cur-len,n+cur-2);
					ans+=(n+cur-1)*tmp.cnt-tmp.ids;
				}
				tmp=T.query(1,0,2*n,0,n+cur-len-1);
				ans+=tmp.cnt*len;
				T.update(1,0,2*n,n+cur-len,n+cur-1,1);
				cur-=len;
			}
			if(c[i][j]==n+1)	break;
			lst=c[i][j];
			tmp=T.query(1,0,2*n,0,n+cur);
			ans+=tmp.cnt;
			cur++;
			T.update(1,0,2*n,n+cur,n+cur,1);
		}
		for(ll j=0,cur=0,lst=0;j<(ll)(c[i].size());j++){
			if(c[i][j]-1!=lst){
				ll len=c[i][j]-lst-1;
				T.update(1,0,2*n,n+cur-len,n+cur-1,-1);
				cur-=len;
			}
			if(c[i][j]==n+1)	break;
			lst=c[i][j];cur++;
			T.update(1,0,2*n,n+cur,n+cur,-1);
		}
	}
	printf("%lld\n",ans); 
	return 0;
}
```

为什么突然写这篇题解呢，熟悉我的人知道我是基本不写 luogu 题解的。所以说是为什么呢？是为什么呢？

2023.11.13

---

## 作者：lalaji2010 (赞：4)

# P8313 [COCI2021-2022#4] Izbori

update 2024.8.30：找到了更优秀的实现，并修正了时间复杂度分析中 $B$ 的最优取值，贴上了新的最优解代码。

介绍一种根号分治的做法，成功~~侥幸~~拿下全谷最优解。

## 题意

求给定序列中有多少个区间有绝对众数。

## 分析

先从部分分开始思考。

### Subtask 1

暴力枚举区间长度和左端点，再开个 map 用于标记区间内数字的出现个数，找一下当前区间是否有绝对众数即可。

时间复杂度：$O(n^{3})$。

实际上有更优秀的暴力能得到更多分，这种做法参考意义不大。

### Subtask 2

使用摩尔投票算法，离散化后暴力枚举区间左右端点，对于同一个左端点 $i$，区间 $[i,j+1]$ 是否有绝对众数就可以由区间 $[i,j]$ 推得。

时间复杂度：$O(n^{2})$。

### Subtask 3

注意到 $a_i$ 的值为 $1$ 或 $2$，所以将值为 $2$ 的位置赋为 $-1$，只要区间和不为 $0$ 即可，所以可以前缀桶维护，时间复杂度 $O(n)$。

### ExSubtask 3

受第 Subtask 3 的启发，我们又得到了一种方法来求解 Subtask 2。

对于每一个 $a_i$ 的值，遍历一遍原数组 $a$，将其中等于 $a_i$ 的值赋为 $1$，其他的赋为 $-1$。

那么其实就是找和大于 $0$ 的区间，等价于求前缀和数组的顺序对，可以用树状数组来写，时间复杂度 $O(n^{2} \log n)$。

### Subtask 4

一个显然的结论，一个出现次数 $T_i$ 的数 $i$ 作为绝对众数的区间长度不超过 $2T_i-1$。

而 ExSubtask 3 的做法的问题在于全部的 $n$ 个数字全都要用 $O(n \log n)$ 的时间复杂度求解一遍。Subtask 2 的做法问题在于枚举右端点不够高效，导致时间被卡到 $O(n^2)$。

~~显然~~可以进行根号分治。

不如应用一下我们刚刚推出的结论，我们令出现次数小于等于 $B$ 的数用 Subtask 2 里的算法，但是不需要在枚举右端点的时候枚举 $n$ 个，而最多只需要找 $2B-1$ 个，时间复杂度 $O(nB)$。令出现次数大于 $B$ 的数跑 ExSubtask 3 里的算法，出现次数大于等于 $B$ 的数有至多 $\lfloor \dfrac{n}{B} \rfloor$ 个，每个 $O(n \log n)$ 的时间，时间复杂度 $O(\dfrac{n^2 \log n}{B})$。

这样进行根号分治，我们就可以做到 $O(nB+\dfrac{n^2 \log n}{B})$ 的总时间复杂度。

注意到 $O(nB)$ 这里省略了 $2$ 倍的常数，而 $O(\dfrac{n^2 \log n}{B})$ 这边树状数组几乎没有常数，所以理论 $B$ 应当取 $\dfrac{17\sqrt{n \log n}}{24}$ 左右时时间复杂度最优。

这样目前跑了一发[全谷最优解](https://www.luogu.com.cn/record/175423696)，比第二名快了一倍。


## AC CODE
```cpp
#include<bits/stdc++.h>
#define ll long long
#define rint register int
using namespace std;
const int N=200005;
int n,B;
int a[N],b[N],T[N],t[N],range;
int sum[N],tree[N],ucl;
ll res=0;
inline int read(){
	int ans = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9'){
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9'){
		ans = (ans<<3)+(ans<<1) + (ch ^ 48);
		ch = getchar();
	}
	return ans;
}
void write(long long n){
	if (n >= 10) write(n / 10);
	putchar(n % 10 + '0');
}
int lowbit(int x){
	return x&(-x);
}
inline void update(int x){
	for(rint i=x;i<=ucl;i+=lowbit(i)){
		tree[i]++;
	}
}
inline int query(int x){
	int cnt=0;
	for(rint i=x;i;i-=lowbit(i)){
		cnt+=tree[i];
	}
	return cnt;
}
void sol_great(int x){
	for(rint i=0;i<=n+3;i++){
		sum[i]=tree[i]=0;
	}
	int mx=0,mn=0;
	for(rint i=1;i<=n;i++){
		if(a[i]==x){
			sum[i]=sum[i-1]+1;
		}else{
			sum[i]=sum[i-1]-1;
		}
		mx=max(mx,sum[i]);
		mn=min(mn,sum[i]);
	}
	ucl=mx-mn+1;//保证为正整数，树状数组好写 
	for(rint i=0;i<=n;i++){
		sum[i]=sum[i]-mn+1;
	}	
	update(sum[0]);
	for(rint i=1;i<=n;i++){
		res+=query(sum[i]-1);
		update(sum[i]);
	}
}
inline void sol_less(){
	for(rint i=1;i<=n;i++){
		int lead_vote=0,id=0;
		for(rint j=i;j<=n&&j<i+range*2;j++){
			t[a[j]]++;
			if(id==a[j]){
				lead_vote++;
			}else if(lead_vote){
				lead_vote--;
			}else{
				id=a[j],lead_vote=1;
			}
			if(T[id]<=B&&t[id]>(j-i+1)/2){
				res++;
			}
		}
		for(rint j=i;j<=n&&j<i+range*2;j++){
			t[a[j]]--;
		}
	}
}
int main(){
	n=read();
	B=sqrt(n*log2(n))*17/24;
	for(rint i=1;i<=n;i++){
		a[i]=read();
		b[i]=a[i];
	}
	sort(b+1,b+1+n);
	int len=unique(b+1,b+1+n)-b-1;
	for(rint i=1;i<=n;i++){
		a[i]=lower_bound(b+1,b+len+1,a[i])-b;
		T[a[i]]++;
	}
	for(rint i=1;i<=len;i++){
		if(T[i]>=range&&T[i]<=B){
			range=T[i];
		}
	}
	for(rint i=1;i<=len;i++){
		if(T[i]>B){
			sol_great(i);
		}
	}
	sol_less();
	write(res);
	return 0;
} 
```

---

## 作者：honglan0301 (赞：4)

## 题意简述
给你一个序列，求有多少个区间存在绝对众数。

## 题目分析
只想到了一个分治做法。

在分治中我们只需考虑快速计算跨过 $mid$ 的合法区间数量。容易发现一个区间 $[l',r']$ 可以被拆成 $[l',mid-1]∪[mid,r']$ 这两个部分，而根据绝对众数的两个性质，大区间的绝对众数必至少是其中一个小区间的绝对众数，且又有 $[a,a],[a,a+1],[a,a+2]\dots [a,b]$ 这一段区间的绝对众数至多有 $\log$ 种，那么发现分治过程中跨过 $mid$ 的区间的绝对众数也至多有 $\log$ 种。

于是对于分治区间 $[l,r]$，我们先算出所有可能成为含 $mid$ 区间的绝对众数的数，然后对于每种绝对众数 $k$ 用前缀和 $O(length)$ 计算答案即可。具体地，我们建一个新的数列 $b_i=2\times[a_i=k]-1$，令 $s_i$ 表示 $b$ 的前缀和，那么区间 $[l',r']$ 合法等价于 $s_{r'}>s_{l'}-1$，所以对 $s_{l-1,\dots mid-1}$ 开桶记录前缀和，然后对 $s_{mid,\dots,r}$ 查询答案即可。

总时间复杂度 $T(n)=2\times T({n\over 2})+n\log n=O(n \log^2 n)$，代码极好写。

## 代码

```cpp
/*
  author: PEKKA_l  
 */
#include <iostream>
#include <cstring>
#include <algorithm>
#include <map>
using namespace std;
#define int long long

int n,m,a[200005],c[200005],cnt[200005],sum[200005],ksum[400005];
map <int,bool> kn;

int calc(int l,int mid,int r,int k)
{
	sum[l-1]=0; for(int i=l;i<=r;i++) sum[i]=sum[i-1]+(a[i]==k?1:-1); int len=r-l+1;
	for(int i=n-len-1;i<=n+len;i++) ksum[i]=0; for(int i=l-1;i<=mid-1;i++) ksum[sum[i]+n]++;
	for(int i=n-len;i<=n+len;i++) ksum[i]+=ksum[i-1]; int nans=0;
	for(int i=mid;i<=r;i++) nans+=ksum[sum[i]+n-1]; return nans;
}
int solve(int l,int r)
{
	if(l>r) return 0; if(l==r) return 1; int mid=(l+r)>>1; kn.clear(); int nmx=0,nnum=0; 
	for(int i=mid;i<=r;i++) {if(++cnt[a[i]]>nmx) {nmx=cnt[a[i]]; nnum=a[i];} if(nmx*2>i-mid+1) kn[a[i]]=1;}
	for(int i=mid;i<=r;i++) cnt[a[i]]--; nmx=nnum=0;
	for(int i=mid-1;i>=l;i--) {if(++cnt[a[i]]>nmx) {nmx=cnt[a[i]]; nnum=a[i];} if(nmx*2>mid-i) kn[a[i]]=1;}
	for(int i=mid-1;i>=l;i--) cnt[a[i]]--; int nans=0; 
	for(auto i:kn) nans+=calc(l,mid,r,i.first); nans+=solve(l,mid-1)+solve(mid+1,r); return nans;
}

signed main()
{
	cin>>n; for(int i=1;i<=n;i++) {cin>>a[i]; c[i]=a[i];}
	sort(c+1,c+n+1); m=unique(c+1,c+n+1)-c-1; for(int i=1;i<=n;i++) a[i]=lower_bound(c+1,c+m+1,a[i])-c;
	cout<<solve(1,n)<<endl;
}
```


---

## 作者：piggy123 (赞：3)

无内鬼，来点根号做法。

看到这种颜色题可以想到根号分治，设阈值 $B$。

1. 对于出现次数 $\lt B$ 的颜色，注意到满足条件的区间必然长度 $\leq 2B$ ，暴力枚举即可，这部分复杂度 $O(Bn)$ 。

2. 对于出现次数 $\geq B$ 的颜色，我们考虑将数组里的所有这种颜色设为 $1$ ， 剩下的设为 $-1$ ，最终即求所有和大于 $0$ 的区间数量，可以用树状数组实现，常数很小，这部分复杂度 $O(\frac{n^2\log n}{B})$ 。

根号均衡一下，可以解得 $B=\sqrt{n\log n}$ 最优。

总复杂度 $O(n\sqrt{n\log n})$ ，被题解区一众 $\texttt{polylog}$ 吊打。

但这玩意跑的蛮快的，卡卡常甚至能过 $500000$ 。

---

## 作者：MrcFrst (赞：2)

### $\text{Links}$

[原题传送门](https://www.luogu.com.cn/problem/P8313)

[可能更好的阅读体验](https://www.cnblogs.com/MrcFrst-LRY/p/17757099.html)


------------
### 题意

求给定序列中有多少个子区间满足众数出现次数严格大于区间长度的一半。



------------
### 题解

题目要求满足条件的子区间，一个很直接的想法是每次固定左（右）端点，求有多少个右（左）可以与其匹配对答案造成贡献。

那么考虑一个暴力做法：每次固定左端点，然后往后面一直扫，枚举每个右端点，中途记录众数出现次数，然后依次判断即可。时间复杂度为 $O(n^2)$。

这肯定是过不了的，那么我们再从条件入手，注意到：

> 严格大于区间长度的一半

于是就说明每个区间对应的这个众数只会有一个！考虑利用一下这个性质。

那么我们可以枚举这个众数。设我们当前枚举的众数为 $x$，记录一个数组 $s$，$s_i$ 表示前 $i$ 个数中 $x$ 的出现次数。

沿用上面固定一个端点求另一个合法端点数量的思路，对于一个右端点 $r$，合法的左端点 $l$ 显然应该满足：

$$
l \le r,s_r-s_{l-1}\gt \frac{r-(l-1)}{2}
$$

$l-1$ 看着有点烦（，把 $-1$ 去掉，变成：

$$
l\lt r ,s_r-s_l\gt \frac{r-l}{2}
$$

不等式两边同时 $\times 2$：

$$
l\lt r,2s_r-2s_l\gt r-l
$$

移项得：

$$
l\lt r,2s_r-r\gt 2s_l-l
$$

记 $s'_i=2s_i-i$，则：

$$
l\lt r,s'_r\gt s'_l
$$

经典问题，树状数组维护即可。但时间复杂度为 $O(n^2\log n)$，甚至不如 $O(n^2)$ 暴力（悲。

那么我们考虑整体观察一下序列 $s'$，说不定能发现什么（。

显然地，如果满足 $a_i=x$ 的若干个 $i$ 的的位置都确定了，那么整个 $s'$ 序列就可以确定了，所以我们要想办法只用这些 $i$ 的位置来计算答案，使得每次的时间复杂度都只与 $m$ 相关，其中 $m$ 为这些 $i$ 的数量。再因为 $\sum m=n$，于是可以大幅降低总时间复杂度。

记 $d$ 为 $s'$ 的差分序列，那么如果 $a_i=x$，则有 $d_i=1$，否则 $d_i=-1$，我们把前者中的 $i$ 视为一个“**断点**”，那么整个 $s'$ 序列就是若干个公差为 $-1$ 的**等差数列**“首尾衔接”拼在一起。

因为公差为 $-1$，即单调递减，所以每一个等差数列内部是不会产生任何贡献的，那么我们考虑把每个等差数列视作整体，看它前面的等差数列可以产生多少贡献。

沿用上面树状数组的做法，开一个**桶** $t$，$t_i$ 表示 $s'$ 值为 $i$ 的位置有多少个，因为每次要查询小于某个值的数量，所以把它记成前缀和的形式，记 $v$ 为它的**前缀和序列**。那么对于每个右端点 $r$，它的答案显然是 $v_{s'_r-1}$。我们把每一段等差数列的贡献写下来就是：

$$
\sum_{i=fir}^{lst}v_{i-1}
$$

然后它又可以写成两个前缀和相减的形式，也就成了 $t$ 序列的**二阶前缀和**，那么我们就需要在这个桶上面实现：区间加（插入一个等差数列），维护二阶前缀和。

~~呵，果然又变成大力 ds 了是吧~~

线段树和树状数组都可以维护，在我看来各有优势吧，线段树写此题代码的时候比较容易理解，好写一点，但这题树状数组的常数吊打线段树。

这里给出线段树的实现方式：

代码实现中的细节：

1.因为 $s'$ 序列中可能出现负数，所以要加上一定的偏差值给它强制转成正数。

2.离散化

3.long long

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define il inline
#define re register
const int N=2e5+113;
int n,a[N],b[N],ans,dt,vmax;
pii lst[N];
bitset<N>solved;
vector<int>v[N];
struct SegT{
    int ans,sum,tag,l,r;
}L[N<<3];
#define ls (id<<1)
#define rs (id<<1|1)
il void Pushup(SegT &fa,SegT lson,SegT rson){
    fa.sum=lson.sum+rson.sum;
    int l=lson.l,mid=lson.r,r=rson.r;
    fa.ans=lson.ans+rson.ans+lson.sum*(r-mid);
}
il int Get(int x){
    return (x*(x+1))>>1;
}
il void Add(SegT &fa,int x){
    fa.tag+=x,fa.sum+=(fa.r-fa.l+1)*x,fa.ans+=Get(fa.r-fa.l+1)*x;
}
il void Pushdown(SegT &fa,SegT &lson,SegT &rson){
    if(!fa.tag)return;
    Add(lson,fa.tag),Add(rson,fa.tag);
    fa.tag=0;
}
il void Add(int id,int l,int r,int x,int y,int z){
    if(l>=x&&r<=y){
        Add(L[id],z);
        return;
    }
    Pushdown(L[id],L[ls],L[rs]);
    int mid=(l+r)>>1;
    if(x<=mid)Add(ls,l,mid,x,y,z);
    if(y>mid)Add(rs,mid+1,r,x,y,z);
    Pushup(L[id],L[ls],L[rs]);
}
il SegT GetAns(int id,int l,int r,int x,int y){
    if(l>=x&&r<=y)return L[id];
    Pushdown(L[id],L[ls],L[rs]);
    int mid=(l+r)>>1;
    SegT res;
    if(x<=mid&&y>mid){
        SegT Left=GetAns(ls,l,mid,x,y);
        SegT Right=GetAns(rs,mid+1,r,x,y);
        Pushup(res,Left,Right);
    }
    else if(x<=mid)res=GetAns(ls,l,mid,x,y);
    else res=GetAns(rs,mid+1,r,x,y);
    Pushup(L[id],L[ls],L[rs]);
    return res;
}
il void Build(int id,int l,int r){
    L[id]={0,0,0,l,r};
    if(l==r)return;
    int mid=(l+r)>>1;
    Build(ls,l,mid),Build(rs,mid+1,r);
}
il void solve(int x){
    solved[x]=1;
    int siz=v[x].size()-1,mx=dt,mn=dt;
    for(re int i=0;i<=siz;i++)
        b[i]=(i<<1)-v[x][i]+dt,mx=max(mx,b[i]),mn=min(mn,b[i]);
    for(re int i=0;i<=siz;i++){
        int r=b[i],l=(i==siz)?b[i]-(n-v[x][i]):b[i]-(v[x][i+1]-v[x][i]-1);
        ans+=GetAns(1,1,vmax,1,r-1).ans-GetAns(1,1,vmax,1,l-2).ans;
        Add(1,1,vmax,l,r,1);
    }
    for(re int i=0;i<=siz;i++){
        int r=b[i],l=(i==siz)?b[i]-(n-v[x][i]):b[i]-(v[x][i+1]-v[x][i]-1);
        Add(1,1,vmax,l,r,-1);
    }
}
il int read(){
    re int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*f;
}
signed main(){
    n=read(),a[0]=read();
    dt=n+10,vmax=n+dt;
    for(re int i=1;i<=n;i++){
        a[i]=read();
        if(v[a[i]].empty())v[a[i]].push_back(0);
        v[a[i]].push_back(i);
    }
    Build(1,1,vmax);
    for(re int i=1;i<=n;i++)
        if(!solved[a[i]])solve(a[i]);
    cout<<ans;
    return 0;
}
```

---

## 作者：2018ljw (赞：2)

这是一个跑得还挺快的根号 $\log$ 做法，模拟赛的赛时想法。

~~lxl：根号 $\log$ 慢的要死。~~

考虑当确定一个众数后，如何求有多少区间的严格众数为该数。

一个很显然的做法是，将等于该数的数赋值 $1$，其余数赋值 $-1$，转化为有多少区间和为正。而这个问题又可以转化成前缀和后统计顺序对个数，复杂度 $O(n\log n)$。

于是有了一个很显然的想法。预设一个阈值 $B$，对于所有出现次数 $>B$ 的数，暴力对其跑出结果，复杂度 $O(\frac{n^2\log n}{B})$。

然后基于这个角度，考虑出现次数 $\le B$ 的区间怎么统计。

关注到一个数成为严格众数，那么其在区间内出现次数要严格过半。换而言之，若其出现了 $x$ 次，那么它作为严格众数的区间长度不能超过 $2x-1$。

所以，暴力跑出所有长度在 $[1,2B-1]$ 范围内区间答案，看这个严格众数是否出现次数 $\le B$ 以避免和情况一重复统计。跑这些区间时，固定左端点，摩尔投票维护可能的众数，开个桶辅助检查即可。复杂度 $O(nB)$。

总复杂度 $O(nB+\frac{n^2\log n}{B})$。

没有刻意卡常，如下是代码里的优化：

1. 求顺序对的前缀和数组差分为 $\pm1$，所以一方面离散化可以转化为全体加一个数，另一方面树状数组上界开到前缀和数组的 $\max$ 而非 $n$。
2. $\le B$ 的部分枚举区间长度上界改为这些数中出现次数最大数的二倍减一。

树状数组常数小，而且左半自带二倍常数。平衡复杂度时 $B$ 取值 $\frac{\sqrt{n\log n}}{2}$ 左右。

本人跑得最快的一份代码里 $B=600$，同时吸氧后在比较大的点可以快两秒。

理论复杂度 $O(n\sqrt n\log n)$。代码部分不放块长了，自行调试。

~~甚至在当前计分模式下是最优解。~~

```cpp
int n,a[200001],c[200001];
int m,b[200001],tx;
int sum[200001],tre[500002],lm;
long long res;
inline void ins(int x){while(x<=lm)tre[x]++,x+=x&(-x);}
inline int qr(int x){int res=0;while(x)res+=tre[x],x-=x&(-x);return res;}
inline void solve_overB(int x){
	int i,mn=0,mx=0;sum[0]=0;
	for(i=1;i<=n;i++){
		tre[i]=0;
		if(a[i]==x)sum[i]=1;
		else sum[i]=-1;
		sum[i]+=sum[i-1];
		if(sum[i]<mn)mn=sum[i];
		if(sum[i]>mx)mx=sum[i];
	}
	tre[n+1]=0;mn--;
	lm=mx-mn;
	for(i=0;i<=n;i++)sum[i]-=mn;ins(sum[0]);
	for(i=1;i<=n;i++)res+=qr(sum[i]-1),ins(sum[i]);
}
inline void solve_lowerB(){
	int i,j;
	memset(b,0,sizeof(b));
	for(i=1;i<=n;i++){
		int vt=0,wr=0;
		for(j=i;j<i+tx*2&&j<=n;j++){
			b[a[j]]++;
			if(wr==a[j])vt++;
			else if(!vt)wr=a[j],vt++;
			else vt--;
			if(c[wr]<=B&&b[wr]>(j-i+1)/2)res++;
		}
		for(j=i;j<i+tx*2&&j<=n;j++)b[a[j]]--;
	}
}
int main(){
	int i;
	scanf("%d",&n);
	for(i=1;i<=n;i++)scanf("%d",&a[i]),b[i]=a[i];
	sort(b+1,b+n+1);m=unique(b+1,b+n+1)-b-1;
	for(i=1;i<=n;i++)a[i]=lower_bound(b+1,b+m+1,a[i])-b,c[a[i]]++;
	for(i=1;i<=m;i++)if(c[i]<=B&&c[i]>tx)tx=c[i];tx*=2;
	for(i=1;i<=m;i++)if(c[i]>B)solve_overB(i);
	solve_lowerB();
	printf("%lld",res);
}
```

---

## 作者：huhangqi (赞：1)

首先观察部分分，对于前两组部分分，可以直接暴力枚举左右端点。

对于第三组部分分，从前缀和的角度去思考，然后可以发现假设一个数字为正数，一个数字为负数，开桶进行统计，只要两种人数不打平即可。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[200005],tmp[200005],cnt,t[400005],ans;
void solve(){
	int tmp=0;
	for(int i=1;i<=n;i++){
		t[tmp+n+1]++;
		if(a[i]==2)tmp++;
		else tmp--;
		ans+=i-t[tmp+n+1];
	}
	cout<<ans;
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	for(int i=1;i<=n;i++)tmp[i]=a[i];
	sort(tmp+1,tmp+n+1);
	cnt=unique(tmp+1,tmp+n+1)-tmp-1;
	for(int i=1;i<=n;i++)a[i]=lower_bound(tmp+1,tmp+cnt+1,a[i])-tmp;
	if(cnt<=2){
		solve();
		return 0;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=cnt;j++)t[j]=0;
		int ma=0;
		for(int j=i;j<=n;j++){
			t[a[j]]++;
			ma=max(ma,t[a[j]]);
			if(ma>(j-i+1)/2)ans++;
		}
	}
	cout<<ans;
	return 0;
}
``````

考虑怎么解决最后的问题。

观察前面的部分分做法，我们会很想枚举所有的种类进行处理，但是这样的种类实在是太多了。

我们可以考虑使用分治。

我们利用分治来解决，但是这样枚举的数字数量依然很大，但是我们还可以发现，实际上有效的数字并不多。

由于左端点位置确定在右边，左端点位置确定在左边部分，所以我们可以想到对于每一个有效点，仅在此点到中点时还满足条件，那么这个点可行。

可行的点有多少个？实际上最多只有 $\log(n)$ 个，因为每个点要到达中点最少需要数量达到总数量一半以上，最后相当于多个二的幂次相加。

那么我们只需要在分治中预处理，预处理完以后再用前缀和进行统计即可。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[200005],ans,tmp[200005],cnt,t[200005],vis[200005],pre[400005];
vector<int> v;
void solve2(int x,int l,int r){
	int mid=l+r>>1;
	int tmp=n+1,mi=n+1,ma=n+1;
	pre[n+1]=1;
	for(int i=l;i<=mid-1;i++){
		if(a[i]==x)tmp++;
		else tmp--;
		pre[tmp]++;
		mi=min(mi,tmp),ma=max(ma,tmp);
	}
	if(a[mid]==x)tmp++;
	else tmp--;
	for(int i=mi+1;i<=ma;i++)pre[i]+=pre[i-1];
	for(int i=mid+1;i<=r;i++){
		if(a[i]==x)tmp++;
		else tmp--;
		if(tmp>ma)ans+=pre[ma];
		else if(tmp>=mi)ans+=pre[tmp-1];
	}
	for(int i=mi;i<=ma;i++)pre[i]=0;
	
}
void solve(int l,int r){
	if(l==r)return void(ans++);
	int mid=l+r>>1;
	solve(l,mid),solve(mid+1,r);
	for(int i=l;i<=mid;i++){
		t[a[i]]++;
		if(t[a[i]]*2>mid-i+1&&!vis[a[i]])v.push_back(a[i]),vis[a[i]]=1;
	}
	for(int i=l;i<=mid;i++)t[a[i]]=0;
	for(int i=mid+1;i<=r;i++){
		t[a[i]]++;
		if(t[a[i]]*2>i-mid&&!vis[a[i]])v.push_back(a[i]),vis[a[i]]=1;
	}
	for(int i=mid+1;i<=r;i++)t[a[i]]=0;
	for(int i=l;i<=r;i++)vis[a[i]]=0;
	for(int i:v)solve2(i,l,r);
	v.clear();
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)tmp[i]=a[i];
	sort(tmp+1,tmp+n+1);
	cnt=unique(tmp+1,tmp+n+1)-tmp-1;
	for(int i=1;i<=n;i++)a[i]=lower_bound(tmp+1,tmp+cnt+1,a[i])-tmp;
	solve(1,n);
	cout<<ans;
	return 0;
}
``````

---

## 作者：CQ_Bab (赞：1)

# 思路
此题有两个必要性质。

- 对于一个区间 $l\sim r$ 如果它的众数为 $a_k$ 且满足条件，那么无论如何将区间分割成 $l\sim x$ 与 $x+1\sim r$ 都一定满足 $a_k$ 至少是其中一个区间的众数且也满足条件，这个很好证明。
- 本题最重要的性质，如果一个区间已经固定了一个端点那么可能会出现的满足条件的区间众数 $a_i$ 最多有 $\log(n)$ 个，因为如果要满足条件必须保证其出现的次数**严格大于**区间长度的一半。

那么对于这道题就可以考虑分治了，我们只需要考虑对于 $l\sim r$ 跨过了 $mid$ 的区间数量，那么我们可以将其看成 $l\sim mid$ 与 $mid+1\sim r$ 两个区间拼起来，又根据上述结论可以发现可能的区间众数数量最多有 $\log(n)$ 个然后只需要按照暴力做法统计一遍答案即可，用桶计数可以做到 $O(n\times \log(n)^2)$。
# 代码
```cpp
#include <bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
#include <ext/rope>
using namespace __gnu_pbds;
using namespace std;
#define pb push_back
#define rep(i,x,y) for(register int i=x;i<=y;i++)
#define rep1(i,x,y) for(register int i=x;i>=y;--i)
#define ll long long
#define in(x) scanf("%d",&x)
#define fire signed
#define il inline
il void print(int x) {
	if(x<0) putchar('-'),x=-x;
	if(x>=10) print(x/10);
	putchar(x%10+'0');
}
int T=1;
int n;
const int N=5e5+10;
int tr[N*2],m;
int lowbit(int x) {
	return x&-x;
}
void add(int x,int k) {
	x+=n;
	for(;x<=n*2;x+=lowbit(x)) tr[x]+=k;
} 
int Ans(int x) {
	int res=false;
	x+=n;
	for(;x;x-=lowbit(x)) res+=tr[x];
	return res;
}
int b[N],a[N],sum[N];
int vis[N],cnt[N];
ll res;
void solve(int l,int r) {
	if(l==r) {
		res++;
		return ;
	}
	if(l>r) return ;
	int mid=l+r>>1;
	solve(l,mid);
	solve(mid+1,r);
	vector<int>v;
	rep1(i,mid,l) {
		cnt[a[i]]++;
		if(cnt[a[i]]*2>(mid-i+1)&&!vis[a[i]]) {
			v.pb(a[i]);
			vis[a[i]]=1;
		}
	}
	rep(i,l,mid) cnt[a[i]]--; 
	rep(i,mid+1,r) {
		cnt[a[i]]++;
		if(cnt[a[i]]*2>(i-mid)&&!vis[a[i]]) {
			vis[a[i]]=1;
			v.pb(a[i]);
		}
	}
	rep(i,mid+1,r) cnt[a[i]]--;
	for(auto to:v) vis[to]=false;
	for(auto x:v) {
		add(0,1);
		sum[l-1]=false;
		rep(i,l,mid) {
			sum[i]=sum[i-1]-1;
			if(a[i]==x) sum[i]+=2;
			if(i!=mid) add(sum[i],1);
		}
		rep(i,mid+1,r) {
			sum[i]=sum[i-1]-1;
			if(a[i]==x) sum[i]+=2;
			res+=0ll+Ans(sum[i]-1);
		}
		add(0,-1);
		rep(i,l,mid-1) add(sum[i],-1);
	}
}
int ty;
void solve() {
	in(n);
	rep(i,1,n) in(a[i]),b[i]=a[i];
	sort(b+1,b+1+n);
	m=unique(b+1,b+1+n)-b-1;
	rep(i,1,n) a[i]=lower_bound(b+1,b+1+m,a[i])-b;
	solve(1,n);
	printf("%lld\n",res);
}
fire main() {
	while(T--) {
		solve();
	}
	return false;
}
```

---

## 作者：lhyuu (赞：1)


给定长为 $n$ 的序列 $a$，求有多少个区间存在绝对众数，即出现次数超过区间一半的众数。

下面列举一下这题要用的绝对众数的trick：

- 固定一个端点，则**绝对众数**的个数不超过 $\log$ 个。

- 若区间 $[l,r]$ 的绝对众数为 $x$，则区间 $[l,mid]$ 和 $[mid+1,r]$ 至少一个满足绝对众数为 $x$。（可以考虑反证，易得）。

不能枚举所有左端点，思考怎么固定一个端点。

考虑分治。求 $[l,r]$ 的贡献，转换成 $[l, mid]$ 和 $[mid+1,r]$ 单独的贡献，以及跨越中点 $mid$ 的区间的贡献。

仔细观察，第三组贡献相当于我们我们有 $i \in [l, mid]$ 以及 $j \in [mid + 1, r]$，合并区间 $[i,mid]$ 和 $[mid+1,r]$。$mid$ 和 $mid+1$ 已知，则这两段均有一端点固定，则区间 $[i,j]$ 至多有 $2\times \log$ 个可能的众数。

接下来就明确了。通过上面的trick，我们可以求出所有过点 $mid$ 的区间可能的众数。枚举众数，设为 $x$，$pre_i$ 表示满足 $[a_j=x],j \in[1,i]$ 的前缀和，然后看满足 $x$ 为区间 $[l,r]$ 绝对众数的条件：

$pre_r-pre_{l-1} > r-l+1 - (pre_r-pre_{l-1})$，

移项，$2pre_r-2pre_{l-1} > r-(l-1)$，

拆成偏序问题 $2pre_r - r > 2pre_{l-1} - (l - 1)$。

用桶维护即可。

```
#include<bits/stdc++.h>
#define pii pair<int, int>
#define mpr make_pair
#define x first
#define y second
#define up(i, a, b) for(int i = a; i <= (int)b; ++i)
#define dn(i, a, b) for(int i = a; i >= (int)b; --i)
#define vc vector
#define pb push_back
#define itset set< int >::iterator
#define lowbit(x) (x & -x)
#define max(a, b) ((a > b) ? a : b)
#define min(a, b) ((a < b) ? a : b)
#define ll long long

using namespace std;

const int MN = 4e5 + 5;
const int N = 2e5 + 1;

int n, a[MN], cnt[MN], tp[MN], t0;

vc<int> w;
bool vis[MN];
int pre[MN];
ll ans;
void solve(int l, int r){
	if(l == r){	ans++; return; }
	int mid = l + r >> 1;
	solve(l, mid), solve(mid + 1, r);
	w.clear();
	dn(i, mid, l){
		cnt[a[i]]++;
		if(!vis[a[i]] && (cnt[a[i]] << 1) > mid - i + 1){
			w.pb(a[i]);
			vis[a[i]] = 1;
		}
	}
	dn(i, mid, l) cnt[a[i]]--;
	up(i, mid + 1, r){
		cnt[a[i]]++;
		if(!vis[a[i]] && (cnt[a[i]] << 1) > i - mid){
			w.pb(a[i]);
			vis[a[i]] = 1;
		}
	}
	up(i, mid + 1, r) cnt[a[i]]--;
	for(int y : w){
		int tot = 0, mn = N - l + 1, mx = N - l + 1; pre[N - l + 1] = 1;
		up(i, l, mid - 1){
			if(a[i] == y) tot++;
			int vl = (tot << 1) - i + N;
			pre[vl]++;
			mn = min(mn, vl), mx = max(mx, vl);
		}
		if(a[mid] == y) tot++;
		int t2 = tot;
		up(i, mid, r){
			if(a[i] == y) tot++;
			int vl = (tot << 1) - i + N;
			mn = min(mn, vl), mx = max(mx, vl);
		}
		up(i, mn + 1, mx)
			pre[i] += pre[i - 1];
		tot = t2;
		up(i, mid + 1, r){
			if(a[i] == y) tot++;
			ans += pre[(tot << 1) - i + N - 1];
		}
		up(i, mn, mx) pre[i] = 0;
	}
	up(i, l, r) vis[a[i]] = 0;
}

signed main(){
	scanf("%d", &n);
	up(i, 1, n){
		scanf("%d", &a[i]);
		tp[i] = a[i];
	}
	sort(tp + 1, tp + 1 + n);
	t0 = unique(tp + 1, tp + 1 + n) - tp - 1;
	up(i, 1, n){
		a[i] = lower_bound(tp + 1, tp + 1 + t0, a[i]) - tp;
	} 
	solve(1, n);
	printf("%lld\n", ans);
	
	return 0;
}
```


---

## 作者：zifanwang (赞：0)

题意，即求有多少区间存在绝对众数。考虑分治，每次求经过 $mid$ 的好区间的个数。

注意到若 $[l,r]$ 存在绝对众数，则 $[l,mid]$ 或 $[mid+1,r]$ 必有一个存在绝对众数。固定一个端点，绝对众数的个数是 $\mathcal O(\log n)$ 的。

于是可以处理出所有可能的绝对众数，令这个数为 $+1$，其它数为 $-1$，从 $mid$ 往两边求和，对于某一边统计一个前缀和，另一边直接 $\mathcal O(1)$ 求个数。

时间复杂度 $\mathcal O(n\log^2 n)$。

参考代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define mxn 200003
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define rept(i,a,b) for(int i=(a);i<(b);++i)
#define drep(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
int n,mx,a[mxn],b[mxn],c[mxn];
ll ans;
set<int>s;
void solve(int l,int r){
	if(l==r){
		ans++;
		return;
	}
	int mid=(l+r)>>1;
	solve(l,mid);solve(mid+1,r);
	s.clear();
	drep(i,mid,l)c[a[i]]=0;
	c[mx=0]=0;
	drep(i,mid,l){
		if(++c[a[i]]>c[mx])mx=a[i];
		if(c[mx]>(mid-i+1)>>1)s.insert(mx);
	}
	c[mx=0]=0;
	rep(i,mid+1,r)c[a[i]]=0;
	rep(i,mid+1,r){
		if(++c[a[i]]>c[mx])mx=a[i];
		if(c[mx]>(i-mid)>>1)s.insert(mx);
	}
	for(int cl:s){
		int ct=0;
		rep(i,0,((r-mid)<<1)+1)c[i]=0;
		rep(i,mid+1,r){
			ct+=a[i]==cl?1:-1;
			c[ct+r-mid]++;
		}
		drep(i,(r-mid)<<1,0)c[i]+=c[i+1];
		ct=0;
		drep(i,mid,l){
			ct+=a[i]==cl?1:-1;
			if(1-ct+r-mid<=(r-mid)<<1)ans+=c[max(1-ct+r-mid,0)];
		}
	}
}
signed main(){
	scanf("%d",&n);
	rep(i,1,n)scanf("%d",&a[i]),b[i]=a[i];
	sort(b+1,b+n+1);
	rep(i,1,n)a[i]=lower_bound(b+1,b+n+1,a[i])-b;
	solve(1,n);
	cout<<ans;
	return 0;
}
```

---

## 作者：内拉组里 (赞：0)

# Subtask 1 & 2

纯暴力。

先把 $ a $ 数组丢进去离散化一下，

然后暴力枚举区间，开个 map 记录区间众数的数与量，最后判断一下绝对众数。

## Analyses :

> 相应时间复杂度 $ \Theta (N^2) $ 
>
> 相应空间复杂度 $ \Theta (N) $ 

***

# CDQ

分治能过的前提是存在一个显而易见的结论：最多 $ \log{n} $ 个数字可能成为区间绝对众数。

别问我为什么，伟大的 cpp 说的。

同样地，先对 $ a $ 数组离散化，然后跑 CDQ。

CDQ 中，首先要枚举哪些数字可能成为区间绝对众数。

显而易见地，任何一个数字只有某一子区间中是绝对众数，才有可能成为该区间的绝对众数。

故从中点分别往两侧扩展，

若某一数字在当前扫过的区间中成为了绝对众数，那就把它丢进集合里。

只需要枚举集合中的数字进行计数即可，方法同 **Subtask 1 & 2** 中一样。

## Analyses :

> 总时间复杂度 $ \Theta (N \log^2{N}) $ 
>
> 总空间复杂度 $ \Theta (N) $ 

# Segment Tree

不会。~~我懒得敲~~ 

但听说需要三维前缀和，这里就现场推一下，希望有所帮助。

令 $ d_n $ 为初始数组。
$$
\begin{align*}
	A_n &= \sum\limits^n_{i = 1} d_i \\ 
	B_n &= \sum\limits^n_{i = 1} A_i \\ 
		&= \sum\limits^n_{i = 1} \sum\limits^i_{j = 1} d_j \\ 
		&= \sum\limits^n_{i = 1} (n - i + 1) d_i \\ 
		&= (n + 1) \sum\limits^n_{i = 1} d_i - \sum\limits^n_{i = 1} (i \times d_i) \\ 
	C_n &= \sum\limits^n_{i = 1} B_i \\ 
		&= \sum\limits^n_{i = 1} \Big[ (i + 1) \sum\limits^i_{j = 1} d_j - \sum\limits^i_{j = 1} (j \times d_j) \Big] \\ 
		&= \sum\limits^n_{i = 1} \Big[ (i + 1) \sum\limits^i_{j = 1} d_j \Big] 
		 - \sum\limits^n_{i = 1} \sum\limits^i_{j = 1} (j \times d_j) \\ 
		&= \sum\limits^n_{i = 1} \Big( i \sum\limits^i_{j = 1} d_j \Big) 
		 - \sum\limits^n_{i = 1} \sum\limits^i_{j = 1} \Big[ (j - 1) \times d_j \Big] \\ 
		&= \sum\limits^n_{i = 1} \sum\limits^i_{j = 1} \Big[ (i - j + 1) \times d_j \Big] \\ 
		&= \sum\limits^n_{i = 1} \sum\limits^{n - i + 1}_{j = 1} d_i \tag{※} \\ 
		&= \sum\limits^n_{i = 1} \frac{(n - i + 1)(n - i + 2)}2 d_i \\ 
		&= \frac{(n + 1)(n + 2)}2 \sum\limits^n_{i = 1} d_i - \frac{2n + 3}2 \sum\limits^n_{i = 1} (i \times d_i) 
         + \sum\limits^n_{i = 1} (i^2 \times d_i) \\ 
\end{align*}
$$
数学能力弱的 (※) 式可能会看不懂，

大概意思就是对于一个确定的 $ j $ 要从 $ i = j $ 加到 $ i = n $ 为止，

并且是 $ d_j + 2d_j + 3d_j + \cdots $  这样子加。大概就是这个意思，自己意会一下。

这样用线段树或树状数组维护 $ \sum d_i $，$ \sum (i \times d_i) $，$ \sum (i^2 \times d_i) $ デス～

## Analyses :

> 总时间复杂度 $ \Theta (N \log{N}) $ 
>
> 总空间复杂度 $ \Theta (N) $ 

# Code :

```cpp
/* at most log2(n) nodes can be the most in the section */
#include	<algorithm>
#include	<iostream>
#include	<vector>
#include	<set>
#include	<map>
#define		int		long long
using namespace std;
constexpr int inf = 0x3f3f3f3f3f3f3f3f;
constexpr int maxn = 2e5+4;

namespace pts25
{
	int n, ans;
	int a[maxn];
	
	void dct (void)
	{
		vector<int> b;
		for (int i = 1; i <= n; i++) b.push_back(a[i]);
		sort (b.begin(), b.end());
		b.resize(unique (b.begin(), b.end()) - b.begin());
		for (int i = 1; i <= n; i++) a[i] = lower_bound (b.begin(), b.end(), a[i]) - b.begin() + 1;
	}
	
	signed main (void)
	{
		cin >> n;
		for (int i = 1; i <= n; i++) cin >> a[i];
		dct ();
		for (int l = 1; l <= n; l++)
		{
			int mx = -inf;
			map<int,int> buc;
			for (int r = l; r <= n; r++)
			{
				int &x = buc[a[r]];
				mx = max (mx, ++buc[a[r]]);
				if ((mx << 1) > r - l + 1) ans++;
			}
		}
		cout << ans << endl;
		return 0;
	}
}

namespace pts100_CDQ
{
	int n, ans;
	int a[maxn];
	namespace TreeArr
	{
		int t;
		int C[maxn << 1];
		int T[maxn << 1];
		
		inline int lowbit (int k)
		{
			return k & -k;
		}
		
		inline void clear (void)
		{
			t++;
		}
		
		void add (int idx, int c)
		{
			for (int i = idx; i <= (n << 1); i += lowbit (i))
			{
				if (T[i] == t) C[i] += c;
				else
				{
					C[i] = c;
					T[i] = t;
				}
			}
		}
		
		int sum (int idx)
		{
			int ans = 0;
			for (int i = idx; i; i -= lowbit (i)) if (T[i] == t) ans += C[i];
			return ans;
		}
	}
	using namespace TreeArr;
	
	inline void calc (int x, int l, int r)
	{
		int mid = (l + r) >> 1;
		int now = n + 1;
		clear ();
		add (now, 1);
		for (int i = l; i <= mid; i++)
		{
			if (a[i] == x) now++;
			else now--;
			if (i != mid) add (now, 1);
		}
		for (int i = mid + 1; i <= r; i++)
		{
			if (a[i] == x) now++;
			else now--;
			ans += sum (now - 1);
		}
	}
	
	void cdq (int l, int r)
	{
		if (l == r)
		{
			ans++;
			return ;
		}
		int mid = (l + r) >> 1;
		cdq (l, mid);
		cdq (mid + 1, r);
		set<int> v;
		map<int,int> buc;
		for (int i = mid; i >= l; i--) if ((++buc[a[i]] << 1) > (mid - i + 1)) v.insert(a[i]);
		buc.clear();
		for (int i = mid + 1; i <= r; i++) if ((++buc[a[i]] << 1) > (i - mid)) v.insert(a[i]);
		for (auto i : v) calc (i, l, r);
	}
	
	signed main (void)
	{
		cin >> n;
		for (int i = 1; i <= n; i++) cin >> a[i];
		/* discretization */
		vector<int> b;
		for (int i = 1; i <= n; i++) b.push_back(a[i]);
		sort (b.begin(), b.end());
		b.resize(unique (b.begin(), b.end()) - b.begin());
		for (int i = 1; i <= n; i++) a[i] = lower_bound (b.begin(), b.end(), a[i]) - b.begin() + 1;
		
		cdq (1, n);
		cout << ans << endl;
		return 0;
	}
}

signed main (void)
{
	return pts100_CDQ::main ();
}
```

---

## 作者：1234567890sjx (赞：0)

题意就是问有多少个区间 $[l,r]$ 存在绝对众数。

考场暴力做法：

枚举左端点 $l$，扫一遍 $r$ 并跑摩尔投票法，每跑完一组之后验证摩尔投票法得到的解是否合法即可。时间复杂度 $O(n^2)$。

然后考虑正解。

容易发现实际有用的 $a_i$ 最多不会超过 $n$ 个，所以对 $a_i$ 做离散化。

考虑枚举每一个 $a_i$ 的值，并计算其对答案产生的贡献。若值 $x$ 对区间 $[l,r]$ 产生 $1$ 的贡献，令 $s_{x,i}$ 表示 $1\sim i$ 中 $x$ 在 $a$ 数组中出现的次数，那么当且仅当 $2\times (s_{x,r}-s_{x,l-1}) > r-l+1$ 也就是 $2\times s_{x,r}-r>2\times s_{x,l-1}-l+1$。

然后问题转化为计数，求对于每一个右端点 $r$ 有多少个 $l\in [1,r]$ 满足上述条件。容易发现是二维偏序问题，直接按照套路搞掉一维然后另一维 `BIT` 掉，可以获得 $35$（赛时 $50$）分，甚至和暴力没有什么区别。

但是没有过这个题肯定是不行的。特殊的令 $f_i=2\times s_{x,i}-i$，容易发现，对于每一个不同的 $S_{x,i}$ 都可以从她开始划分出一个区间一直到 $S_{x,i}$ 增加 $1$ 为止，这一段是一个公差为 $-1$ 的等差数列。

发现这是一个套路。考虑开一个权值数组 $Q$，若此时等差数列的首项是 $l$，末项是 $r$，那么在权值数组中统计就是将区间 $[l,r]$ 增加 $1$。

套路的令 $Q'$ 为 $Q$ 数组的前缀和，对于上述的区间 $[l,r]$，其贡献就是 $\sum_{i=r-1}^{l-1}Q'_i$，再令 $Q''_i$ 为 $Q'_i$ 的前缀和，答案就比较好算了，根据前缀和的定义可以得到答案为 $Q''_{r-1}-Q''_{l-2}$。这个东西就可以用差分，然后用三个树状数组来维护三层前缀和的值。

时间复杂度很抽象，大概是小常数 $O(n\log n)$ 的吧。

[代码，很丑](https://www.luogu.com.cn/paste/hpr76ogv)

------

某位神仙同学提出了 $O(n\sqrt n\log n)$ 的神仙做法并薄纱了 `std`，但是没看懂，所以就不写了。


---

## 作者：Luciylove (赞：0)

模拟赛 T3。

显然绝对众数只有一个。

那么你就考虑对于一个数 $x$ 数有多少个区间是以 $x$ 产生贡献的。考虑记 $x$ 的前缀出现次数：

$$
s_r - s_{l - 1} > \frac{r - l + 1}{2}
$$

$$
2s_r - r > 2s_l - (l - 1)
$$

怎么去维护？感觉会巨大复杂！


## Hint：

考虑每次加这些数与前面产生的贡献。

考虑一个出现位置 $i$ 以及其后面的 $(i, nxt_i)$ 这一段。端内显然是按照定义，没有顺序对的。

于是考虑维护值域上的桶 $t$。每次查询 $[l, r]$ 与前面形成的顺序对，然后 $[l, r]$ 加 $1$。

你考虑顺序对分两种：

- $i < l - 1$ 的 贡献是对 $[l, r]$ 都成立的，那么贡献就是：

$$
\sum_{i < l - 1} (r - l + 1) t_i
$$

- $i \in [l - 1, r - 1]$ 手玩可以知道其实就是：

$$
\sum_{i \in [l - 1, r - 1]} (r - i + 1) t_i
$$

你通过模拟可以知道，这个是一个二维前缀和的形式，反而手玩出来的式子不那么显然。

那么就是线段树维护区间加，区间二维前缀和。

后者可以通过维护 $ia_i$ 以及 $a_i$ 的和来计算出来，感觉我写复杂了。

时间复杂度线性对数。

```cpp
#include <bits/stdc++.h>
#define rep(i, l, r) for (int i = l; i <= r; i ++)
#define per(i, r, l) for (int i = r; i >= l; i --)
#define lc x << 1
#define rc x << 1 | 1
using namespace std;
typedef long long ll;

const int _ = 2e5 + 5;

// 枚举 i。
// +1 -1 转化为 sr - sl > 0
// 区间加等差数列，全局顺序对是吧。
// 我只会根号，乐。
// 考虑究竟是怎么做 polylog 的？？
// 维护 iai 就好了，等下再维护区间和。区间加平移量。
ll si[_ << 3], s[_ << 3], tag[_ << 3];
ll su (int l, int r) { return 1ll * (r - l + 1) * (l + r) / 2; }
inline void apply (int x, int l, int r, int k) {
	s[x] += 1ll * (r - l + 1) * k, 
	si[x] += su(l, r) * k, tag[x] += k;
}
inline void pushup (int x) { s[x] = s[lc] + s[rc], si[x] = si[lc] + si[rc]; }
inline void pushdown (int x, int l, int mid, int r) {
	if (tag[x]) {
		apply(lc, l, mid, tag[x]), apply(rc, mid + 1, r, tag[x]);
		tag[x] = 0;
	}
}
void modify (int x, int l, int r, int ql, int qr, int k) {
	if (ql <= l && r <= qr) return apply(x, l, r, k);
	int mid = (l + r) >> 1; pushdown(x, l, mid, r);
	if (ql <= mid) modify(lc, l, mid, ql, qr, k);
	if (qr > mid) modify(rc, mid + 1, r, ql, qr, k);
	return pushup(x);
}
ll query (int x, int l, int r, int ql, int qr, int op) {
	if (ql <= l && r <= qr) return op == 1 ? s[x] : si[x];
	int mid = (l + r) >> 1;
	ll ret = 0; pushdown(x, l, mid, r);
	if (ql <= mid) ret += query(lc, l, mid, ql, qr, op);
	if (qr > mid) ret += query(rc, mid + 1, r, ql, qr, op);
	return ret;
}

int sz, type, n, cnt, a[_];
map <int, int> tmp;
vector <int> v[_];
ll ans;

int main() {
	/*黛拉可玛莉·岗德森布莱德，一亿年一遇美少女。*/
	cin >> n;
	sz = n * 2;
	rep(i, 1, n) {
		scanf("%d", & a[i]);
		if (!tmp[a[i]]) tmp[a[i]] = ++ cnt;
		a[i] = tmp[a[i]], v[a[i]].push_back(i);
	}
	rep(x, 1, cnt) {
		int len = v[x].size();
		ll res = 0;
		modify(1, 0, sz, n - v[x][0] + 1, n, 1);
		rep(i, 0, len - 1) {
			int val = (i * 2 + 2 - v[x][i]), nxt;
			if (i == len - 1) nxt = n;
			else nxt = v[x][i + 1] - 1;
			nxt = i * 2 + 2 - nxt;
			ll s1 = query(1, 0, sz, 0, nxt + n - 2, 1),
			   s2 = query(1, 0, sz, nxt + n - 1, val + n - 1, 1),
			   s3 = query(1, 0, sz, nxt + n - 1, val + n - 1, 2);
			res += s1 * (val - nxt + 1) + s2 * (val + n) - s3;
			modify(1, 0, sz, nxt + n, val + n, 1);  
		}// x -> si = 2 * ocr_x - i, sr > sl
		ans += res;
		rep(i, 0, len - 1) {
			int val = (i * 2 + 2 - v[x][i]), nxt;
			if (i == len - 1) nxt = n;
			else nxt = v[x][i + 1] - 1;
			nxt = i * 2 + 2 - nxt;
			modify(1, 0, sz, nxt + n, val + n, -1);  
		}
		modify(1, 0, sz, n - v[x][0] + 1, n, -1);
	}
	cout << ans;
	return 0;
}
/*3
43 24 37*/
```



---


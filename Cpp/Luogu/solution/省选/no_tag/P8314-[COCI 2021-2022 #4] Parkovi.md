# [COCI 2021/2022 #4] Parkovi

## 题目背景

市政府决定修建公园来美化景观。为了让公园不仅好看，而且有用。市政府为了市民的幸福，希望公园里居民们更近一些。

## 题目描述

这个城市由 $n$ 个社区组成，社区间由 $n-1$ 条道路连接。并且从任意一个社区出发，可以到任意一个社区去。一共会建造 $k$ 座公园，同一个社区内只会存在一座公园。市政府希望尽可能减小从每个社区到最近公园的距离的最大值。

帮助政府应该在那些社区建造公园，可以使每个社区到最近公园的距离的最大值最小。

## 说明/提示

**【样例 3 解释】**

如果只在 $3,4$ 号社区建公园，最大距离不会改变。但是市政府想建 $k$ 个公园，所以需要在其他地方再建两个。

**【数据规模与约定】**

**本题采用子任务捆绑测试。**

- Subtask 1（10 pts）：$1 ≤ n ≤ 20$。
- Subtask 2（10 pts）：$k=1$。
- Subtask 3（30 pts）：$\forall i\in\{1,2,3,\dots,n-1\},a_i=i,b_i=i+1$。
- Subtask 4（60 pts）：没有额外限制。

对于 $100\%$ 的数据，$1\le k\le n\le2\times10^5,1\le a_i,b_i\le n,1\le w_i \le 1e9$。

**【提示与说明】**

**本题分值按 COCI 原题设置，满分 $110$。**

**题目译自 [COCI2021-2022](https://hsin.hr/coci/) [CONTEST #4](https://hsin.hr/coci/contest4_tasks.pdf) T4 Parkovi。**

## 样例 #1

### 输入

```
9 3
1 2 5
1 3 1
3 4 10
3 5 9
5 6 8
2 7 1
2 8 2
8 9 7```

### 输出

```
8
4 5 8```

## 样例 #2

### 输入

```
5 2
1 2 3
2 3 7
3 4 3
4 5 3```

### 输出

```
3
2 4```

## 样例 #3

### 输入

```
7 4
1 3 1
1 4 1
2 3 1
5 3 1
4 7 1
4 6 1
```

### 输出

```
1
3 4 1 2```

# 题解

## 作者：xyz105 (赞：11)

### 题目描述

有一座城市，它可以被看作由 $n$ 个社区组成的树形结构。现要求选出其中 $k$ 个社区建公园，目标是使得 每个社区到最近公园的距离的最大值最小。输出这个最小距离和具体建造方案。


### 前言

![](https://cdn.luogu.com.cn/upload/image_hosting/siavjeyc.png)


### 解题思路

**二分答案**。此处二分的值应为“每个社区到其最近公园距离最大值”（设其为 $x$），将原问题变为判定“在满足 $x$ 的限制下建造的公园数目能否 $\le k$”。

**贪心**。在满足 比公园深的节点 到公园的距离 $\le x$ 的限制下，将公园尽量往浅层建，对于那些 比公园浅的节点 固然是更优的，因为这样能使建造的公园总数更少。

**DFS**。在 DFS 过程中决定每个节点是否建造公园；当回溯到某个节点时，这个节点是否建造公园 应由 该节点 到 它子树中最远的未被其它公园覆盖的节点（下文称作“最远未覆盖节点”）有多远 作为依据。此处“节点被其它公园覆盖”指 节点到其它公园的距离已经 $\le x$ 了。

- 将“节点 $u$ 到‘最远未覆盖节点’的距离”记作 $d\_max_u$。如何求 $d\_max_u$？容易想出如下式子：$d\_max_u=\max \limits_{v\isin son_u} \{d\_max_v+w_{u,v}\}$。特别地，点 $u$ 的“最远未覆盖节点”不存在 当且仅当 $d\_max_u=-\infty$。

- 小问题是，对于点 $v\isin son_u$，点 $v$ 的“最远未覆盖节点”有可能被 $son_u$ 中除 $v$ 以外的其它节点的子树中的公园所覆盖。为了解决这个问题，将“节点 $u$ 到 其子树中最近公园 的距离”记作 $d\_min_u$，则上述式子变为：

$$d\_max_u=\max \limits_{v\isin son_u,\ d\_min_u+d\_max_v+w_{u,v}>x} \{d\_max_v+w_{u,v}\}$$

此为本题关键。下面讲一下代码实现细节：

- 初值：$d\_min_u=\infty,d\_max_u=-\infty$。先求出 $d\_min_u$。若点 $u$ 本身也是未被覆盖的节点（即 $d\_min_u>x$），则用 $0$ 去更新 $d\_max_u$。

- 特别地，如果 $u$ 为根节点 且 它的“最远未覆盖节点”存在（即 $d\_max_u\neq -\infty$），那么点 $u$ 无论如何都要建造公园。

- 输出答案时，如果该方案下建造的公园数 $<k$，则随机乱建新的公园直到公园数 $=k$ 为止。

~~说到底就是我那张“一张图题解”的补充说明而已。~~


### 参考代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

typedef long long ll;

const int MAXN = 2e5 + 10;

const ll INF = 0x3f3f3f3f3f3f3f3fll;

int n, k;

int head[MAXN], to[MAXN << 1], nxt[MAXN << 1], cnt;
ll w[MAXN << 1];

inline void add_edge(int u, int v, ll w2)
	{to[++cnt] = v, w[cnt] = w2, nxt[cnt] = head[u], head[u] = cnt;}

int fcnt = 0;
bool chosen[MAXN], res[MAXN];
int ans1[MAXN];
ll dis_mx[MAXN], dis_mn[MAXN];

void dfs(int u, int fa, ll w2, ll x)
{
	dis_mn[u] = INF, dis_mx[u] = -INF;
	for (int i = head[u]; i; i = nxt[i])
		if (to[i] != fa)
			dfs(to[i], u, w[i], x),
			dis_mn[u] = min(dis_mn[u], dis_mn[to[i]] + w[i]);
	
	if (dis_mn[u] > x) dis_mx[u] = max(dis_mx[u], 0ll);
	for (int i = head[u]; i; i = nxt[i])
		if (to[i] != fa && dis_mn[u] + dis_mx[to[i]] + w[i] > x)
			dis_mx[u] = max(dis_mx[u], dis_mx[to[i]] + w[i]);
	
	if (dis_mx[u] + w2 > x || (u == 1 && dis_mx[u] != -INF))
		fcnt++, chosen[u] = 1, dis_mn[u] = 0, dis_mx[u] = -INF;
}

bool judge(ll x)
{
	memset(chosen, 0, sizeof(bool) * (n + 5));
	fcnt = 0, dfs(1, 0, 0, x);
	return fcnt <= k;
}

int main()
{
	scanf("%d%d", &n, &k);
	for (ll i = 1, i1, i2, i3; i < n; i++)
		scanf("%lld%lld%lld", &i1, &i2, &i3),
		add_edge(i1, i2, i3), add_edge(i2, i1, i3);
	
	ll l = 0, r = 1e15, mid, ans;
	while (l <= r)
	{
		mid = (l + r) >> 1;
		if (judge(mid)) memcpy(res, chosen, sizeof(bool) * (n + 5)), ans = mid, r = mid - 1;
		else l = mid + 1;
	}
	
	int i1 = 0;
	for (int i = 1; i <= n; i++) if (res[i]) ans1[++i1] = i;
	for (int i = 1; i <= n && i1 < k; i++) if (!res[i]) ans1[++i1] = i;
	
	printf("%lld\n", ans);
	for (int i = 1; i <= k; i++) printf("%d ", ans1[i]);
	
	return 0;
}
```

---

## 作者：dAniel_lele (赞：9)

挺经典的一类树上贪心。

## 思路

最大值最小，不难想到二分。

二分最远距离，我们现在要计算至少要的公园数量。

考虑贪心，从叶子结点向上选择。不难发现能“咕”就“咕”，应当选择深度最浅的覆盖。证明只需考虑将一个公园从上面移动到下面无益即可。

记录距离根节点深度最深的未覆盖和距离根节点深度最浅的公园。如果这个最深的未覆盖公园可以被最浅的公园覆盖（即相加小于等于钦定值），显然不需要考虑。在此之外，最深的未覆盖公园加上根与父亲的距离已经超过了钦定值，这里就必须添加一个公园（在父亲那里添已经覆盖不到了）。最后比较公园数量与 $k$ 即可。设值域为 $V$，复杂度 $O(n\log Vn)$，可以通过。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
#define double long double
#define lowbit(x) ((-x)&x)
using namespace std;
vector<pair<int,int>> vc[200005];
int dep1[200005],dep2[200005],qy,tot[200005],cl[200005];
void dfs(int now,int fa,int len){
	dep1[now]=dep2[now]=0,tot[now]=cl[now]=0;
	int maxv=-1e18,minv=1e18;
	for(auto v:vc[now]){
		if(v.first==fa) continue;
		dfs(v.first,now,v.second);
		minv=min(minv,dep1[v.first]+v.second);
		tot[now]+=tot[v.first];
	}
	if(minv>qy) maxv=0;
	for(auto v:vc[now]){
		if(v.first==fa) continue;
		if(dep2[v.first]+v.second+minv>qy) maxv=max(maxv,dep2[v.first]+v.second);
	}
	if((maxv+len>qy)||(now==1&&maxv>=0)){
		tot[now]++,cl[now]=1;
		dep1[now]=0,dep2[now]=-1e18;
	}
	else{
		dep1[now]=minv,dep2[now]=maxv;
	}
}
signed main(){
	int n,k,lmin=0; cin>>n>>k;
	for(int i=1;i<n;i++){
		int u,v,w; cin>>u>>v>>w;
		vc[u].push_back(make_pair(v,w));
		vc[v].push_back(make_pair(u,w));
		lmin=max(lmin,w);
	}
	int L=0,R=1e18;
	while(L<R){
		int mid=(L+R)/2;
		qy=mid;
		dfs(1,0,0);
		if(tot[1]<=k){
			R=mid;
		}
		else{
			L=mid+1;
		}
	}
	cout<<L<<"\n";
	qy=L,dfs(1,0,0);
	for(int i=1;i<=n;i++) if(cl[i]) k--,cout<<i<<" ";
	for(int i=1;i<=n;i++) if(k&&!cl[i]) k--,cout<<i<<" ";
	return 0;
}
```

---

## 作者：_wsq_ (赞：7)

题目中提到最大值最小，考虑二分答案并判断可行性。  

我们可以发现，如果将一个下面的公园移动到上面后，下面的所有社区都仍然能在被我们二分出来的 $mid$ 距离内覆盖，则移动到上面显然对上面更优，既对全局更优。我们可以记录最深的未被覆盖的社区和最浅的公园，然后就能求出在某一个社区是否需要新建公园。

具体流程：  
1. 先访问每一个子节点，并更新最浅的公园以及其子树内公园数量。
2. 求出最浅的公园后，遍历每一个子节点，若对应的最深的未被覆盖的社区不能被最浅的公园覆盖，则更新最深的未被覆盖的社区。
3. 如果最深的未被覆盖的社区超过了 $mid$，或当前节点为根且仍存在未被覆盖的社区，则需要将当前节点设为公园。

坑点：  
* 若当前节点也未能被最浅的公园覆盖，则最深的未被覆盖的社区的初始值不应为 $-\infin$ 而应为 $0$（要考虑到当前节点）。
* 若最终求出来公园数量未达到 $k$，则还需要随便将没有公园的社区输出直到公园数量达到 $k$。
* 十年 OI 一场空，不开 `long long` 见祖宗。
* 多测不清空，亲人两行泪，在本题里还额外包括最后求 $l$ 对应答案时。

附上包含更多细节的代码：  
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
#define maxn 200005
typedef long long ll;
struct edge{
	ll to,next,len;
}e[maxn*2];
ll n,k,h[maxn],tot,l,r=200000000000005,mid,dp1[maxn],dp2[maxn],num[maxn];
bool is[maxn];
void addedge(ll u,ll v,ll w){
	e[++tot].to=v;
	e[tot].next=h[u];
	e[tot].len=w;
	h[u]=tot;
	return;
}
void dfs(ll x,ll fa,ll l){
    dp1[x]=200000000000005;
    dp2[x]=-200000000000005;//初始值
    for(ll i=h[x];i;i=e[i].next){
        if(e[i].to==fa){
            continue;
        }
        dfs(e[i].to,x,e[i].len);
        dp1[x]=min(dp1[x],dp1[e[i].to]+e[i].len);
        num[x]+=num[e[i].to];
    }
    if(dp1[x]>mid){
        dp2[x]=0;
    }//若当前节点也未能被最浅的公园覆盖，则最深的未被覆盖的社区的要考虑到当前节点
    for(ll i=h[x];i;i=e[i].next){
        if(e[i].to==fa){
            continue;
        }
        if(dp1[x]+dp2[e[i].to]+e[i].len>mid){//这一句是防止最浅的公园把其他子树的最深的未被覆盖的社区覆盖了
            dp2[x]=max(dp2[x],dp2[e[i].to]+e[i].len);
        }
    }
    if((dp2[x]+l>mid)||(x==1&&dp2[x]>=0)){//该节点需要建公园
        is[x]=true;
        num[x]++;
        dp1[x]=0;
        dp2[x]=-200000000000005;
    }
    return;
}
int main(){
    cin>>n>>k;
    for(ll i=1;i<n;i++){
        ll a,b,w;
        cin>>a>>b>>w;
        addedge(a,b,w);
        addedge(b,a,w);
    }
    while(l<r){
        memset(dp1,0,sizeof(dp1));
        memset(dp2,0,sizeof(dp2));
        memset(num,0,sizeof(num));
        memset(is,false,sizeof(is));
        mid=(l+r)/2;
        dfs(1,0,0);
        if(num[1]>k){
            l=mid+1;
        }
        else{
            r=mid;
        }
    }
    cout<<l<<endl;
    mid=l;
    memset(dp1,0,sizeof(dp1));
    memset(dp2,0,sizeof(dp2));
    memset(num,0,sizeof(num));
    memset(is,false,sizeof(is));//一定要清空！！！
    dfs(1,0,0);
    for(int i=1;i<=n;i++){
        if(is[i]){
            cout<<i<<' ';
            k--;
        }
    }
    for(int i=1;i<=n;i++){//补全至 k
        if(!k){//这句话一定要有
            break;
        }
        if(!is[i]){
            cout<<i<<' ';
            k--;
        }
    }
    return 0;
}
```

---

## 作者：Y_ATM_K (赞：7)

## 题意
- 给出一棵 $n$ 个点的树，初始树上的点全为白色。
- 需要把 $k$ 个节点染上黑色，使得白色节点到黑色节点的距离最大值最小。
- $1\le k\le n\le 2 \times 10^5$

## 分析
对于一个节点，它各个子树的决策会相互影响，就不太好 DP，注意题目要求是**最大值最小**，于是可以想到二分答案，对于每个二分的 $mid$，直接判定是否存在一种方案满足距离最大值不超过 $mid$。这样这个问题转化为了判定可行性的问题。

那么怎样判定呢？我们可以贪心地想到，对于一个未染色点，他的祖先中最近的黑色点肯定要越远越好。因为在遍历一棵树的过程中，一个点 $i$ 为根的子树中决策已经固定了，于是在最大距离不超过 $mid$ 的前提下，把 $i$ 移到它的父亲，在以 $i$ 为根的子树中没有影响，对上面未决策的点来说是更优的。

我们找到了贪心策略，接下来是具体实现方法(神犇可以跳过)。

为了方便我们称**未找到对应黑色点的白色点**为未匹配点。

根据上面的分析，可以直接 dfs 找决策。设当前遍历到节点 $i$，记录两个值：以 $i$ 为根的子树中未匹配点与 $i$ 距离的最大值 $disw_i$，和以 $i$ 为根的子树中黑色点与 $i$ 距离的最小值 $disb_i$。因为更近的未匹配点肯定不如最远的未匹配点距离黑色点远，同理，更远的黑色点也不如最近的黑色点离未匹配点近。更新答案的时候注意一下根节点是没有父亲的，所以如果还剩下未匹配点的话，要给根节点染成黑色。然后就做完了。

细节见代码。

## 代码
```cpp
#include <bits/stdc++.h>
#define N 200005
#define M 400005
#define ll long long
using namespace std;
int n,k;
const ll INF=1e16;
int tot=1,first[N],nxt[M],ver[M],edge[M];
void add(int s,int e,int w) {
	nxt[++tot]=first[s];
	first[s]=tot;
	ver[tot]=e;
	edge[tot]=w;
}
ll sumw;
void init() {
	for(int i=1;i<n;++i) {
		int s,e,w;
		scanf("%d%d%d",&s,&e,&w);
		add(s,e,w),add(e,s,w);
		sumw+=w;
	}
}
int cnt,ans[N];
ll f[N][2],lim;
void dfs(int now,int pre) {
	ll disp=INF;//到黑点的最近距离
	for(int i=first[now];i;i=nxt[i]) {
		int v=ver[i];
		if(i==pre) continue;
		dfs(v,i^1);
		disp=min(disp,f[v][1]+edge[i]);
	}
	ll maxnp=-INF;//到未匹配点的最远距离
	if(disp>lim) maxnp=0;//注意此时now也是未匹配点
	for(int i=first[now];i;i=nxt[i]) {
		int v=ver[i],w=edge[i];
		if(i==pre) continue;
		if(f[v][0]+w+disp>lim) {
			maxnp=max(maxnp,f[v][0]+w);
		}
	}
	if(maxnp+edge[pre]>lim||maxnp>=0&&!pre) {
		ans[++cnt]=now;
		f[now][0]=-INF,f[now][1]=0;
	} else {
		f[now][0]=maxnp,f[now][1]=disp;
	}
}
bool beb[N];
int main() {
	scanf("%d%d",&n,&k);
	init();
	ll l=0,r=sumw;
	while(l<r) {
		lim=(l+r)>>1,cnt=0;
		dfs(1,0);
		if(cnt<=k) {
			r=lim;
		} else {
			l=lim+1;
		}
	}
	printf("%lld\n",l);
	lim=l,cnt=0;
	dfs(1,0);
	for(int i=1;i<=cnt;++i) {
		printf("%d ",ans[i]);
		beb[ans[i]]=1;
	}
	for(int i=1;i<=n&&cnt<k;++i) {
		if(!beb[i]) printf("%d ",i),cnt++;//注意要染恰好k个黑点
	}
	puts("");
	return 0;
}
```

---

## 作者：yx666 (赞：2)

# 题解：P8314 Parkovi
## Part 1：题目大意
### Part 1.1：简化题意
有一个 $n$ 个节点的树，第 $i$ 条边连接着 $a_i$ 与 $b_i$ 两个点，权值为 $w_i$。

现在将其中 $k$ 个点染上色，使得未染色点距已染色点的**最大值最小**。

请你输出这个最大值，并且给出需要将哪些点染色。对于多组解的数据，只需输出一种可能的解。

### Part 1.2：限制
- 对于 $100\%$ 的数据，$1\le k\le n\le2\times10^5,1\le a_i,b_i\le n,1\le w_i \le 1\times10^9$。

- 时间 $3$ 秒，空间 $500$ MB。

## Part 2：思路
### Part 2.1：核心算法：二分答案
由题目要求：**最大值最小**，使用二分答案。

于是，我们只需要解决如何判定：是否有方案满足其最大值不超过 $c$（$c$ 为二分答案）。

如何判定呢？

### Part 2.2：判断可行性
那么我们如何判断某点该不该染色呢？

模仿 [P2899](https://www.luogu.com.cn/problem/P2899) 的贪心思想，我们需要使染色点尽可能靠近根节点，而不是叶子结点。

所以，我们得到 dfs 的核心：贪心。

### Part 2.3：dfs 贪心判断
#### Part 2.3.1：声明
为了记叙方便，提前声明一下变量：

1. $d\_mn_i$ 表示第 $i$ 个节点到其子树中已染色点的最近距离。初始值：$\infin$。

2. $d\_mx_i$ 表示第 $i$ 个节点到其子树中未染色点的最大距离。特别的，$-\infin$ 表示其子树中未染色点已全部被覆盖。

3. $i$ 表示当前节点编号，$fa$ 表示父亲节点编号，$to$ 表示遍历的子树根编号，$d$ 表示 $w_{x,fa}$，$c$ 表示二分答案中要求的最大值。

4. 如无特殊说明，$to\in son_x,to\ne fa$。

5. 节点 $x$ 被覆盖意为 $d\_mn_x\le c$。

#### Part 2.3.2：dfs
首先，找到 $d\_mn_i$：

$$d\_mn_i=\min\{d\_mn_{to}+w_{i,to}\}$$

接着，初始化 $d\_mx_i$：

$$d\_mx_i=\begin{cases}
0&d\_mn_i>c\\
-\infin&d\_mn_i\le c
\end{cases}$$

然后，更新 $d\_mx_i$：

$$d\_mx_i=\max_{d\_mn_i+d\_mx_{to}+w_{i,to}>c}\{d\_mx_{to}+w_{i,to}\}$$

注意限制条件：距根最近的公园距离 $d\_mn_i+$ 根到子树根距离 $w_{i,to}+$ 子树根到最远未覆盖点距离 $d\_mx_{to}>c$。

最后，判断是否建公园的依据：$d\_mx_i+d>c$（如果在父亲处建已经来不及了，因为 $w_{i,fa}>0$，所以 $d\_mx_i+d+w_{i,fa}>c$，父亲是覆盖不到这个节点的）。

#### Part 2.3.3：check 函数
``` cpp
int n,k;
inline bool check(ll t){
	rec.clear();		// 记得清空
	dfs(1,0,0,t);
	if(d_mx[1]!=-INF)		// 如果到了根 1 上，还有没被覆盖的节点，那根也必须建上公园
		rec.push_back(1);
	return rec.size()<=k;
}
```

### Part 2.4：最终答案
注意要建够 $k$ 个，乱建也行。

## Part 3：代码&注释
不开 `long long` 见祖宗。

``` cpp
#include<bits/stdc++.h>
using namespace std;

#define ll long long

#define N 200005
#define M 400005

const ll INF= 0x3f3f3f3f3f3f3f3fll;

int head[N],cnt=0;
struct EDGE{
	int to,next;
	ll val;
}edge[M];

inline void addEdge(int from,int to,ll val){
	edge[++cnt]={to,head[from],val};
	head[from]=cnt;
	return ;
}

vector<int>rec;

ll d_mn[N];			// 表示第 i 个节点到其子树中已染色点的最近距离。
ll d_mx[N];			// 表示第 $i$ 个节点到其子树中未染色点的最大距离。特别的，-INF 表示其子树中未染色点已全部被覆盖。
// x：当前点编号
// fa：父亲
// d1：父亲距 x 距离
// c：最大值
void dfs(const int x,const int fa,const ll d,const ll c){
	d_mn[x]=INF;
	for(int i=head[x];i;i=edge[i].next){
		int to=edge[i].to;
		if(to==fa) continue;
		
		// 没记错的话，这里应该叫后序递归
		// 因为要获取到子树的信息，要先走一遍子树
		dfs(to,x,edge[i].val,c);
		d_mn[x]=min(d_mn[x],d_mn[to]+edge[i].val);
	}
	
	if(d_mn[x]>c){		// 节点未被覆盖
		d_mx[x]=0;
	}else{				// 节点已被覆盖
		d_mx[x]=-INF;
	}
	
	for(int i=head[x];i;i=edge[i].next){
		int to=edge[i].to;
		if(to==fa) continue;
		if(d_mn[x]+d_mx[to]+edge[i].val>c){				// 距根最近的公园距离+根到子树根距离+子树根到最远未覆盖点距离>c
			d_mx[x]=max(d_mx[x],d_mx[to]+edge[i].val);
		}
	}
	
	// 建公园 
	if(d_mx[x]+d>c){			// 再建浅一点就会爆炸
		d_mn[x]=0,d_mx[x]=-INF;
		rec.push_back(x);
	}
}

int n,k;
inline bool check(ll t){
	rec.clear();		// 记得清空
	dfs(1,0,0,t);
	if(d_mx[1]!=-INF)		// 如果到了根 1 上，还有没被覆盖的节点，那根也必须建上公园
		rec.push_back(1);
	return rec.size()<=k;
}

signed main(){
	ios_base::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>n>>k;
	for(int i=1,a,b,c;i<n;++i){
		cin>>a>>b>>c;
		addEdge(a,b,c);
		addEdge(b,a,c);
	}
	
	/* 二分开始 */
	ll l=0,r=INF,mid,tp;		// tp 表示最终答案，其余应该一样
	vector<int>ans;
	while(l<=r){
		mid=(l+r)>>1;
		if(check(mid)){
			ans=rec;
			tp=mid;
			r=mid-1;
		}else{
			l=mid+1;
		}
	}
	
	cout<<tp<<'\n';
	
	int p=0;
	if(ans.size()<k){		// 没有建够，随便乱建一点
		set<int>ck;
		for(auto it:ans)
			ck.insert(it);    
		while(ans.size()<k){
			if(!ck.count(++p)) ans.push_back(p);
		}
	}
	for(auto it:ans){
		cout<<it<<' ';
	}
	return 0;
}
```

---

## 作者：junee (赞：1)

# P8314 题解

## 前置知识

二分。

## 题目分析

首先看到题目，想到二分是容易的，考虑如何检验二分的答案。

这里检验的比较牛。

首先，我们很容易想到对于一个未被选择的点，离它最近的祖先上的被选择的点肯定越远越好，如果离他最近的被选择的点已经被确定，那么子树外的操作对他没有影响。

我们可以进行一个类似 dp 的东西，每次对于一个点 $u$，我们记录子树中离它最远的未被选择的点的最大距离记为 $g_u$，子树中被选择的点距离它最小的距离 $f_u$，子树中被选择点的数量 $sum_u$。

然后每次先求出 $f_u$，再利用 $f_u$ 的信息更新 $g_u$，然后检查是否 $g_u+x$ 是否大于限制然后看是否选择它，如果 $u=1$，即 $u$ 为根节点，且不存在 $g_u$，则 $u$ 必须选择。

最后再跑一次 check，然后如果选的点数不够就随机补一点。

## Code

```
#include<iostream>
#include<iomanip>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<random>
#include<chrono>
using namespace std;
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
typedef long long LL;
const int N=2e5+10;
const LL inf=1e18;
int h[N],e[N*2],ne[N*2],idx;
int n,k,st[N];
LL f[N],g[N],sum[N],w[N*2];
void add(int a,int b,LL c){
	e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
} 
void init(){
	for(int i=1;i<=n;i++)
		f[i]=g[i]=sum[i]=st[i]=0;
}
void dfs(int u,int fa,LL lim,LL x){
	f[u]=inf,g[u]=-inf;
	for(int i=h[u];~i;i=ne[i]){
		int j=e[i];
		if(j==fa)continue;
		dfs(j,u,lim,w[i]);
		f[u]=min(f[u],f[j]+w[i]);
		sum[u]+=sum[j];
	}
	if(f[u]>lim)g[u]=0;
	for(int i=h[u];~i;i=ne[i]){
		int j=e[i];
		if(j==fa)continue;
		if(f[u]+g[j]+w[i]>lim)g[u]=max(g[u],g[j]+w[i]);
	}
	if((g[u]+x>lim)||(u==1&&g[u]>=0)){
		st[u]=1;
		sum[u]++;
		f[u]=0;
		g[u]=-inf;
	}
}
bool check(LL mid){
	init();
	dfs(1,0,mid,0);
	return sum[1]>k;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	memset(h,-1,sizeof h);
	cin>>n>>k;
	for(int i=1;i<n;i++){
		int a,b, c;
		cin>>a>>b>>c;
		add(a,b,c);
		add(b,a,c);
	}
	LL l=0,r=inf;
	while(l<r){
		LL mid=(l+r)>>1;
		if(check(mid))l=mid+1;
		else r=mid;
	}
	cout<<l<<'\n';
	check(l);
	for(int i=1;i<=n;i++)
		if(st[i])cout<<i<<' ',k--;
	for(int i=1;i<=n;i++){
		if(!k)break;
		if(!st[i])cout<<i<<' ',k--;
	}
	return 0;
}
```

---

## 作者：zifanwang (赞：0)

最大值最小，容易想到二分。

考虑贪心，尽量选深度小的点，判断最少点数是否 $\le k$。对每个点记录子树内距离最近的公园和最远的未被覆盖的点。若两距离和 $>mid$，则选择当前点，时间复杂度 $\mathcal O(n\log V)$。

参考代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define mxn 200003
#define pb push_back
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define rept(i,a,b) for(int i=(a);i<(b);++i)
#define drep(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
int n,k;
int tot,hd[mxn],vr[mxn<<1],ed[mxn<<1],nx[mxn<<1];
ll l,r,mid,d[mxn],f[mxn],d1[mxn],d2[mxn];
bool v[mxn];
inline void add(int x,int y,int z){
	vr[++tot]=y,ed[tot]=z,nx[tot]=hd[x],hd[x]=tot;
}
void dfs(int x,int fa,ll ds){
	f[x]=0;
	ll mx=-1e18,mn=1e18;
	for(int i=hd[x],y;i;i=nx[i])if((y=vr[i])!=fa){
		dfs(y,x,ed[i]);
		f[x]+=f[y];
		mn=min(mn,d1[y]+ed[i]);
	}
	if(mn>mid)mx=0;
	for(int i=hd[x],y;i;i=nx[i])if((y=vr[i])!=fa){
		if(mn+d2[y]+ed[i]>mid)mx=max(mx,d2[y]+ed[i]);
	}
	if(mx+ds>mid){
		f[x]++;
		d1[x]=0,d2[x]=-1e18;
		v[x]=1;
	}else d1[x]=mn,d2[x]=mx;
}
signed main(){
	scanf("%d%d",&n,&k);
	for(int i=1,x,y,z;i<n;++i){
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z),add(y,x,z);
	}
	r=2e14;
	while(l<r){
		mid=(l+r)>>1;
		dfs(1,0,1e18);
		if(f[1]<=k)r=mid;
		else l=mid+1;
	}
	cout<<l<<'\n';
	rep(i,1,n)v[i]=0;
	mid=l,dfs(1,0,1e18);
	rep(i,1,n)if(v[i])cout<<i<<" ",k--;
	rep(i,1,n)if(!v[i]&&k)cout<<i<<" ",k--;
	return 0;
}
```

---


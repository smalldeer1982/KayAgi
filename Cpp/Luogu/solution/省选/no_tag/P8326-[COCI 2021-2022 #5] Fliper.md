# [COCI 2021/2022 #5] Fliper

## 题目描述

现有一个包含 $n$ 块挡板的旧弹球机。

游戏在二维平面内进行，其中每块挡板与坐标轴所夹锐角总为 $45^\circ$，长度为 $1$ 个单位。挡板用其中心坐标 $(x_i,y_i)$ 和字符 / 或 \ 来表示。小球在碰到挡板后，其运动方向将会旋转 $90^\circ$。注意，挡板的两面都可使小球的运动方向发生偏转。

不难发现，当小球处于弹球机中时，它只有两种结局：

- 沿着某一方向一直运动下去而不碰到挡板
- 处于若干个挡板的循环之中

在翻新弹球机的过程中，有四种颜色的染料可供选择。现要将弹球机中的每个挡板进行染色，使得**每一个**循环内经过每一种颜色的次数相同且为偶数。

请给出一种符合题意的染色方式，或证明这样的染色方式不存在。如果不存在，输出 `-1`。

## 说明/提示

**【样例 2 图解】**

![](https://cdn.luogu.com.cn/upload/image_hosting/ksajf2n4.png)

**【数据规模与约定】**

**本题采用捆绑测试。**

- Subtask 1（20 pts）：$1 \le n \le 40$。
- Subtask 2（20 pts）：最多存在一个循环。
- Subtask 3（70 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n \le 5 \times 10^5$，$0 \le |x_i|,|y_i| \le 10^9$。

**【说明】**

本题采用自行编写的 [Special Judge](https://www.luogu.com.cn/paste/g6cdziry)。如果对此有疑问或想要 hack，请[私信编写者](https://www.luogu.com.cn/chat?uid=137367)或[发帖](https://www.luogu.com.cn/discuss/lists?forumname=P8326)。

**【来源】[COCI 2021-2022#5](https://hsin.hr/coci/archive/2021_2022/contest5_tasks.pdf) Task 3 Fliper。**

## 样例 #1

### 输入

```
4
1 1 \
3 1 /
3 2 \
1 2 /```

### 输出

```
-1```

## 样例 #2

### 输入

```
9
1 2 \
1 3 /
2 1 \
2 2 \
2 3 \
3 1 /
3 2 \
4 2 /
4 3 \```

### 输出

```
1 3 2 4 1 3 2 4 1```

## 样例 #3

### 输入

```
12
1 2 \
1 3 /
2 1 \
2 2 \
2 3 \
2 4 /
3 1 /
3 2 \
3 3 \
3 4 \
4 2 /
4 3 \```

### 输出

```
1 3 2 4 2 4 1 3 1 3 2 4```

# 题解

## 作者：Leasier (赞：5)

- **染色使得……相等 / 绝对值之差 $\leq 1$ 等问题可以考虑欧拉回路。**

首先可以根据挡板的到达关系建图：

- 设 $i$ 表示挡板 $i$ 朝下的一面，$i'$ 表示挡板 $i$ 朝上的一面。
- 我们建出的图由若干环和链构成。
- 我们的目标是给挡板染为四种颜色，令 $i, i'$ 的颜色为挡板 $i$ 的颜色，则我们希望每个环内每一种颜色的点的个数相同且为偶数。

若存在一个环的长度 $\bmod \ 8 \neq 0$，一定无解。

否则，我们来尝试构造一种方案。能染成四种颜色的必要条件为能染成两种颜色，于是我们先来考虑两种颜色怎么做。

直接在这张图上操作十分困难，考虑**点边互化**：我们尝试将一个挡板转化成一条边，边的颜色为挡板的颜色。

那么点是什么呢？注意到我们关心的是**环内的颜色**，考虑把环转化为点，则我们可以在一个挡板的两面所属的两个环对应的点间连边（这里我们先假定原图各连通块**全都是环**），则问题变为：

- 给定一张无向图。
- 给边黑白染色，使得每个点的出边中黑白颜色相等。

**考虑给边定向，设黑边指向当前点、白边从当前点出发，则目标变为让每个点出入度相等。**

**“出入度相等”让我们想到有向图存在欧拉回路的判断条件，则我们直接在原无向图上跑出一条欧拉回路，对回路上的边黑白染色即可。**

由于一个环对应点的度数为环上点数，则一定有解。

接下来考虑染成四种颜色怎么做。我们首先跑一遍两种颜色的情况，注意到把两种颜色的边各自构成的子图中每个点的度数分别 $\bmod \ 4 = 0$，于是在两个子图中各自再跑一遍欧拉回路黑白染色即可。

最后来考虑有连通块为链的情况。我们期待可以将其视作环处理，考虑建一个超级源点，钦定这些链上的点全部属于超级源点对应的环。若超级源点的度数 $\bmod \ 8 \neq 0$，我们强行连一些自环即可。

对 $x, y$ 两维分别排序即可建出最初的图。时间复杂度为 $O(n \log n)$。

代码：
```cpp
#include <algorithm>
#include <cstdio>

using namespace std;

typedef struct {
	int id;
	int type;
	int x;
	int y;
} Point;

typedef struct {
	int nxt;
	int end;
} Edge;

typedef struct {
	int cnt = 0;
	int head[1000007];
	int deg[1000007];
	Edge edge[2000007];
	
	inline void add_edge(int start, int end){
		cnt++;
		edge[cnt].nxt = head[start];
		head[start] = cnt;
		edge[cnt].end = end;
		deg[start]++;
	}
} Graph;

int top, loop = 0, op;
Graph g1, g2;
int stk[1000007], belong[1000007], cur_edge[1000007], color[500007], ans[500007];
bool vis1[1000007], vis2[1000007], vis3[1000007];
Point point[500007];

inline void init(int n, int m){
	op = 0;
	for (register int i = 0; i <= n; i++){
		cur_edge[i] = g2.head[i];
		vis2[i] = false;
	}
	for (register int i = 1; i <= m; i++){
		vis3[i] = false;
	}
}

inline int read(){
	int sign = 1, ans = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9'){
		if (ch == '-') sign = -sign;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9'){
		ans = ans * 10 + (ch ^ 48);
		ch = getchar();
	}
	return sign * ans;
}

inline int get_type(){
	char ch;
	do {
		ch = getchar();
	} while (ch != '/' && ch != '\\');
	return ch == '/' ? 0 : 1;
}

bool cmp1(const Point a, const Point b){
	if (a.x != b.x) return a.x < b.x;
	return a.y < b.y;
}

bool cmp2(const Point a, const Point b){
	if (a.y != b.y) return a.y < b.y;
	return a.x < b.x;
}

void dfs1(int u, int father){
	if (vis1[u]){
		loop++;
		while (top > 0){
			belong[stk[top--]] = loop;
		}
		return;
	}
	vis1[u] = true;
	stk[++top] = u;
	for (register int i = g1.head[u]; i != 0; i = g1.edge[i].nxt){
		int x = g1.edge[i].end;
		if (x != father) dfs1(x, u);
	}
}

void dfs2(int u){
	vis2[u] = true;
	for (register int i = cur_edge[u]; i != 0; i = g2.edge[cur_edge[u]].nxt){
		int id = (i + 1) / 2;
		cur_edge[u] = i;
		if (!vis3[id]){
			vis3[id] = true;
			dfs2(g2.edge[i].end);
			color[id] = op;
			op ^= 1;
		}
	}
}

void dfs3(int u, int goal){
	vis2[u] = true;
	for (register int i = cur_edge[u]; i != 0; i = g2.edge[cur_edge[u]].nxt){
		int id = (i + 1) / 2;
		cur_edge[u] = i;
		if (color[id] == goal && !vis3[id]){
			vis3[id] = true;
			dfs3(g2.edge[i].end, goal);
			ans[id] = ((goal << 1) | op) + 1;
			op ^= 1;
		}
	}
}

int main(){
	int n = read(), m = n * 2;
	for (register int i = 1; i <= n; i++){
		point[i].x = read();
		point[i].y = read();
		point[i].type = get_type();
		point[i].id = i;
	}
	sort(point + 1, point + n + 1, cmp1);
	for (register int i = 1; i <= n; ){
		int nxt = i;
		while (nxt < n && point[i].x == point[nxt + 1].x) nxt++;
		for (register int j = i; j < nxt; j++){
			g1.add_edge(point[j].id + n, point[j + 1].id);
			g1.add_edge(point[j + 1].id, point[j].id + n);
		}
		i = nxt + 1;
	}
	sort(point + 1, point + n + 1, cmp2);
	for (register int i = 1; i <= n; ){
		int nxt = i;
		while (nxt < n && point[i].y == point[nxt + 1].y) nxt++;
		for (register int j = i; j < nxt; j++){
			if (point[j].type == 0){
				if (point[j + 1].type == 0){
					g1.add_edge(point[j].id, point[j + 1].id + n);
					g1.add_edge(point[j + 1].id + n, point[j].id);
				} else {
					g1.add_edge(point[j].id, point[j + 1].id);
					g1.add_edge(point[j + 1].id, point[j].id);	
				}
			} else if (point[j + 1].type == 0){
				g1.add_edge(point[j].id + n, point[j + 1].id + n);
				g1.add_edge(point[j + 1].id + n, point[j].id + n);
			} else {
				g1.add_edge(point[j].id + n, point[j + 1].id);
				g1.add_edge(point[j + 1].id, point[j].id + n);
			}
		}
		i = nxt + 1;
	}
	for (register int i = 1; i <= m; i++){
		if (!vis1[i]){
			top = 0;
			dfs1(i, 0);
		}
	}
	for (register int i = 1; i <= n; i++){
		g2.add_edge(belong[i], belong[i + n]);
		g2.add_edge(belong[i + n], belong[i]);
	}
	for (register int i = 1; i <= loop; i++){
		if (g2.deg[i] % 8 != 0){
			printf("-1");
			return 0;
		}
	}
	while (g2.deg[0] % 8 != 0) g2.add_edge(0, 0);
	init(loop, n);
	for (register int i = 0; i <= loop; i++){
		if (!vis2[i]) dfs2(i);
	}
	init(loop, n);
	for (register int i = 0; i <= loop; i++){
		if (!vis2[i]) dfs3(i, 0);
	}
	init(loop, n);
	for (register int i = 0; i <= loop; i++){
		if (!vis2[i]) dfs3(i, 1);
	}
	for (register int i = 1; i <= n; i++){
		printf("%d ", ans[i]);
	}
	return 0;
}
```

---

## 作者：Para (赞：4)

首先如果存在一个循环长度不整除 $8$，一定无解，猜测剩下的情况一定有解。

将隔板之间可以一步到达的关系建出后，考虑如何染色。

直接染色不易处理。我们首先反转点边关系，对于每一个循环建虚点，原图中的隔板视为边，很显然每一条边与两个虚点相关联（隔板的两面各对应一个虚点）。现在就转换为对于边染色，使得每一个虚点相连的边每种颜色数量相同。

可以跑一遍欧拉回路将边交替分为两个集合，每个集合内部再跑一遍欧拉回路进一步拆分。对于拆分出的四种集合各染一种颜色即可。

简单说明一下：第一遍跑欧拉回路，将边拆分为两个集合，考虑每一个子图，每个点度数一定整除 $4$，那么再跑一遍欧拉回路也可以恰好完成拆分（一进一出恰好抵消）。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define mp make_pair
#define inf 1e9
#define pii pair <int, int>
const int mod = 1e9 + 7;
inline int read () {
	int x = 0, f = 1;
	char ch = getchar ();
	while (ch < '0' || ch > '9') f = ((ch == '-') ? -1 : f), ch = getchar ();
	while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar ();
	return x * f;
}
inline void write (int x) {
	if (x < 0) x = -x, putchar ('-');
	if (x >= 10) write (x / 10);
	putchar (x % 10 + '0');
}
int n;
struct st {
	int x, y, op, id;
}a[500005];

int ans[500005];
vector <int> G[1000005];

void add1(int x, int opx, int y, int opy) {
	x += opx * n, y += (opy ^ 1) * n;
	G[x].push_back(y);
	G[y].push_back(x);
}
void add2(int x, int opx, int y, int opy) {
	x += n;
	G[x].push_back(y);
	G[y].push_back(x);
}

int head[1000005], cur[1000005], tot = 1;
struct Edge {
	int v, e, nxt;
}edge[8000005];
void addedge(int u, int v, int e) {
	edge[++tot].v = v, edge[tot].e = e;
	edge[tot].nxt = head[u], head[u] = tot;
}
int du[1000005];
void Addedge(int u, int v, int e) {
	du[u]++, du[v]++;
	addedge(u, v, e);
	addedge(v, u, e);
}
int N, fa[1000005], vis[2000005], tag[1000005];
pii p[1000005];
void dfs(int x) {
	vis[x] = ++tot;
	for(auto y : G[x]) {
		if(y == fa[x]) continue;
		if(vis[y]) {
			if(vis[y] > vis[x]) {
				N++;
				int now = y;
				while(1) {
					int id = (now > n) ? (now - n) : now;
					if(!p[id].first) p[id].first = N;
					else p[id].second = N;
					if(now == x) break;
					now = fa[now];
				}
			}
		}
		else fa[y] = x, dfs(y);
	}
}
void build() {
	for(int i = 1; i <= 2 * n; i++) if(!vis[i]) dfs(i);
	tot = 1;
	for(int i = 1; i <= n; i++) Addedge(p[i].first, p[i].second, i);
}
int col;
void dfs1(int x) {
	for(int i = cur[x]; i; ) {
		if(vis[i >> 1]) {
			i = cur[x] = edge[i].nxt;
			continue;
		}
		vis[i >> 1] = 1;
		dfs1(edge[i].v);
		ans[edge[i].e] = col;
		col ^= 1;
		i = cur[x];
	}
}
void dfs2(int x, int tar) {
	tag[x] = 1;
	for(int i = cur[x]; i; ) {
		if(vis[i >> 1] || ans[edge[i].e] != tar) {
			vis[i >> 1] = 1;
			i = cur[x] = edge[i].nxt;
			continue;
		}
		vis[i >> 1] = 1;
		dfs2(edge[i].v, tar);
		ans[edge[i].e] += col;
		col ^= 2;
		i = cur[x];
	}
}
void solve() {
//    printf("N:%lld %lld\n", N, du[1]);
	for(int i = 1; i <= N; i++) if(du[i] % 8) puts("-1"), exit(0);
	while(du[0] % 8) Addedge(0, 0, 0);
//	printf("%lld\n", tot);
	memset(vis, 0, sizeof vis);
	for(int i = 0; i <= N; i++) cur[i] = head[i];
	dfs1(0);
	memset(vis, 0, sizeof vis), memset(tag, 0, sizeof tag);
	for(int i = 0; i <= N; i++) cur[i] = head[i];
	col = 0;
	for(int i = 0; i <= N; i++) dfs2(i, 0);
	memset(vis, 0, sizeof vis), memset(tag, 0, sizeof tag);
	for(int i = 0; i <= N; i++) cur[i] = head[i];
	col = 0;
	for(int i = 0; i <= N; i++) dfs2(i, 1);
}
signed main () {
//	freopen ("1.in", "r", stdin);
//	freopen ("mine.out", "w", stdout);
	n = read();
	for(int i = 1; i <= n; i++) {
		a[i].x = read(), a[i].y = read();
		char op[2];
		scanf("%s", op);
		a[i].op = (op[0] == '/') ? 0 : 1;
		a[i].id = i;
	}
	
	sort(a + 1, a + 1 + n, [&] (st A, st B) {return A.x < B.x || (A.x == B.x && A.y < B.y);});
	for(int i = 2; i <= n; i++) if(a[i-1].x == a[i].x) add1(a[i-1].id, a[i-1].op, a[i].id, a[i].op);
	sort(a + 1, a + 1 + n, [&] (st A, st B) {return A.y < B.y || (A.y == B.y && A.x < B.x);});
	for(int i = 2; i <= n; i++) if(a[i-1].y == a[i].y) add2(a[i-1].id, a[i-1].op, a[i].id, a[i].op);
	
	build(), solve();
	
	for(int i = 1; i <= n; i++) write(ans[i] + 1), putchar(' ');
	putchar('\n');
	return 0;
}
/*
*/
```

---


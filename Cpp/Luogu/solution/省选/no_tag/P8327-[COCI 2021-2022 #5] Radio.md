# [COCI 2021/2022 #5] Radio

## 题目描述

克罗地亚有 $n$ 个初始状态下关闭的电台。当同时开启两个电台 $i,j$ 且 $i,j$ 不互质时，它们会互相干扰。

你需要写一个支持下列操作的程序：

1. `S x`：将电台的状态取反，即将原来开启的电台关闭，将原来关闭的开启。
2. `C l r`：检查在 $[l,r]$ 内是否存在互相干扰的现象。如果存在，输出 `DA`，否则输出 `NE`。

## 说明/提示

**【样例 1 解释】**

|C 操作序号|开启电台|是否互相干扰|
| :----------: | :----------: | :----------: |
|$1$|$1,2,3$|否|
|$2$|$1,2,3,6$|是|
|$3$|$1,3,6$|是|

**【数据规模与约定】**

**本题采用捆绑测试。**

- Subtask 1（10 pts）：$1 \le n \le 100$，$1 \le q \le 200$。
- Subtask 2（30 pts）：对于所有的 C 操作，$l=1,r=n$。
- Subtask 3（70 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n \le 10^6$，$1 \le q \le 2 \times 10^5$，$1 \le x \le n$，$1 \le l \le r \le n$。

**【来源】[COCI 2021-2022#5](https://hsin.hr/coci/contest5_tasks.pdf) Task 4 Radio。**

## 样例 #1

### 输入

```
6 8
S 1
S 2
S 3
C 1 6
S 6
C 1 6
S 2
C 1 6```

### 输出

```
NE
DA
DA```

## 样例 #2

### 输入

```
11 6
S 4
S 10
C 3 11
C 2 7
S 6
C 2 7```

### 输出

```
DA
NE
DA```

## 样例 #3

### 输入

```
20 7
S 10
S 15
S 3
C 10 15
S 10
C 3 15
C 3 10```

### 输出

```
DA
DA
NE```

# 题解

## 作者：yyandy (赞：18)

直接判断不好搞，考虑两个数不互质的情况，这时这两个数至少有一个质因子相同。    
所以在这题中一个数和他的质因子集合是等价的，      
这启示我们建一个新序列，新序列里的每一个数都是原序列中某个数的质因子，    
原序列中的一个数在新序列中对应一段区间，在原序列中询问一段区间也变为了新数列中询问一段区间。         
由于每一个数的质因子不是很多，建出来的新序列也不会很长（大概算一下长度没有超过 $3\times 10^6$）。    
于是我们就相当于要在新序列上求一段区间内有没有两个相同的数，如果有相同，就说明有不互质的数。     
这个问题如果是不修改很容易做，只用记录对于每个数，上一个和它相同的数的位置，然后做一遍前缀 $\max$ 得到一个新数组，设为 $P$。      
每次查询 $l,r$ 就相当于查询 $P_r$ 是否大于等于 $l$。          
上面所说的大概就是[这一题](https://www.luogu.com.cn/problem/P3901)的做法，不懂的可以先做这题。     
现在考虑如果动态修改该怎么做，    
由于要动态修改，预处理行不通了，得寻找新方法。       
对于每个值，为了快速找到上一个与它相同的数，我们要记录为该值的数的位置，由于要修改，还得支持快速插入删除定位，而这可以用 set 来完成。    
之前的方法要维护前缀最大值，现在加上了单点修改，可以用线段树轻松维护。
常数非常大，有点卡，可能需要离散化一下，只降在询问或修改中出现的位置质因数分解构成新序列。
这样就可以大大减小新序列长度，就不用担心被卡了。

**Code：**
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000000;
set<int> Pre[1100000];
int P[25],x,Max[24000000],t[1001000],M2[1001000],M1[3001000],g,st[1001000],ed[1001000],Mn[1001000],T[1001000],tot,tot2,A[9201000],n,Low[1201000],d[320000],e[320000],k;
char c[330000][3];
bool vis[1001000];
void Change(int x,int y,int l,int S,int k){
	if(x==y){
		Max[k]=S;
		return;
	}
	int mid=x+y>>1;
	if(l<=mid)Change(x,mid,l,S,k<<1);
	else Change(mid+1,y,l,S,(k<<1)|1);
	Max[k]=max(Max[k<<1],Max[(k<<1)|1]);
}
int Query(int x,int y,int l,int r,int k){
	if(x==l&&y==r)
		return Max[k];
	int mid=x+y>>1;
	if(l<=mid&&r>mid)return max(Query(x,mid,l,mid,k<<1),Query(mid+1,y,mid+1,r,(k<<1)|1));
	else if(l<=mid)return Query(x,mid,l,r,k<<1);
	else return Query(mid+1,y,l,r,(k<<1)|1);
}
bool query(int x,int y){
	if(st[x]>ed[y]||x>y)return 0;
	if(Query(1,tot2,st[x],ed[y],1)>=st[x])return 1;
	else return 0;
}
void del(int x){
	T[x]=0;
	for(int i=st[x];i<=ed[x];++i){
		Pre[A[i]].erase(i);
		auto it=Pre[A[i]].lower_bound(i);
		if(it!=Pre[A[i]].end()){
			if(it!=Pre[A[i]].begin()){
				int Q1=(*it);it--;
				int Q2=(*it);
				Change(1,tot2,Q1,Q2,1);
			}else Change(1,tot2,*it,0,1);
		}
		Change(1,tot2,i,0,1);
	}
}
void ins(int x){
	T[x]=1;
	for(int i=st[x];i<=ed[x];++i){
		auto it=Pre[A[i]].lower_bound(i);
		if(it!=Pre[A[i]].end())
			Change(1,tot2,*it,i,1);
		if(it!=Pre[A[i]].begin())
			it--,Change(1,tot2,i,*it,1);
		Pre[A[i]].insert(i);
	}
}
int main(){
	cin>>g>>n;
	memset(Low,63,sizeof(Low));
	for(int i=2;i<=N;++i)
		if(!vis[i])
			for(int j=i;j<=N;j+=i)
				vis[j]=1,Low[j]=min(Low[j],i);
	for(int i=1;i<=n;++i){
		scanf("%s%d",c[i],&d[i]);
		if(c[i][0]=='C')scanf("%d",&e[i]);
		if(c[i][0]=='S')t[d[i]]=1;
	}
	for(int i=1;i<=N;++i)
	if(t[i]){
		M1[i]=++k,M2[k]=i;tot=0;P[0]=-1;x=i;
		while(x>1){
			if(P[tot]!=Low[x])
				P[++tot]=Low[x];
			x/=Low[x];
		}
		st[k]=tot2+1;
		for(int i=1;i<=tot;++i)
			A[++tot2]=P[i];
		ed[k]=tot2;
	}
	for(int i=1;i<=n;++i){
		if(c[i][0]=='S'){	
			int p=M1[d[i]];
			if(T[p])del(p);
			else ins(p);
		}else{
			int x=lower_bound(M2+1,M2+k+1,d[i])-M2,y=upper_bound(M2+1,M2+k+1,e[i])-M2-1;
			if(query(x,y))puts("DA");		
			else puts("NE");
		}
	}
}
```

---

## 作者：whx2009 (赞：10)

## 本题思路：
这道题我们可以用平衡树加线段树的方式去做。

首先我们如果知道一个比他小的第一个出现且最大公因数不为一的位置，那么我们就很容易就可以用权值线段树去判断一个区间里是否有最大公因数不为一的两个数（每个位置记录前面第一个合法的，直接扫区间最大值看是否比左端点大就可以了）。

然后考虑怎么去找他前面第一个出现的与他最大公因数不为一的数。那么显然和每个数的质因数有关，那么一看数据范围，值域很小，最多只有九个不同的质数相乘，那么我们就可以对每一个质数开一棵平衡树，每次加入就扫一遍能整除他的质数，更改自己的值与他后继的值。删除就更新后继即可。
## 小贴士：
需要预处理每个数的质因数是多少，不然就像我一样时间复杂度直接起飞。
## 本题代码：
```cpp
#include<bits/stdc++.h>
#define int long long 
#define mid (tr[p].l+tr[p].r)/2
using namespace std;
int vis[1000006],jl[1000006];
int zs[500005],cnt;
void zss(int n){vis[1]=-1;
	for(int i=2;i<=n;i++){
		if(vis[i]==0){zs[++cnt]=i;vis[i]=cnt;}
		for(int j=1;j<=cnt&&zs[j]*i<=n;j++){
			vis[zs[j]*i]=-1;
			if(i%zs[j]==0) break;
		}
	}
}
struct f{int l,r,sum;}tr[300005*4];
void jianshu(int p,int l,int r){
	tr[p].l=l,tr[p].r=r;
	if(l==r){tr[p].sum=0;return;}
	jianshu(p*2,l,mid),jianshu(p*2+1,mid+1,r);
}
void xiugai(int p,int l,int k){
//	cout<<1;
	if(tr[p].l==tr[p].r){tr[p].sum=max(tr[p].sum,k);return;}
	if(l<=mid) xiugai(p*2,l,k);
	else xiugai(p*2+1,l,k);
	tr[p].sum=max(tr[p*2].sum,tr[p*2+1].sum);
}
void xiugai1(int p,int l,int k){
	if(tr[p].l==tr[p].r){tr[p].sum=k;return;}
	if(l<=mid) xiugai1(p*2,l,k);
	else xiugai1(p*2+1,l,k);
	tr[p].sum=max(tr[p*2].sum,tr[p*2+1].sum);
}
int cha(int p,int l,int r){
	if(tr[p].l>=l && tr[p].r<=r) return tr[p].sum;int ans=0;
	if(l<=mid) ans=cha(p*2,l,r);
	if(r>mid) ans=max(ans,cha(p*2+1,l,r));
	return ans;
}
struct ff{
	char op;int x,y;
}b[1000006];
int c[1000006],cnt2;
//平衡树 
#define ls t[p].ch[0]
#define rs t[p].ch[1]
struct fff{int ch[2],sum,rnd;}t[300000*9];
void split(int p,int &x,int &y,int k){
	if(!p){x=0;y=0;return;}
	if(t[p].sum<=k){x=p;split(rs,rs,y,k);}
	else{y=p;split(ls,x,ls,k);}
}
void merge(int &p,int x,int y){
	if(!x||!y){p=x+y;return;}
	if(t[x].rnd>=t[y].rnd){p=x;merge(rs,rs,y);}
	else{p=y;merge(ls,x,ls);}
}
int root[500005],cnt1;
int cha1(int k){int p=k;while(p){if(!rs)return t[p].sum;p=rs;}return 0;}
int cha2(int k){int p=k;while(p){if(!ls) return t[p].sum;p=ls;}return 0;}
int add(int k){
	cnt1++;
	t[cnt1].sum=k;
	t[cnt1].rnd=rand();
	t[cnt1].ch[0]=t[cnt1].ch[1]=0;
	return cnt1;
}
void jia(int p,int k){
	int x,y;
	split(root[p],x,y,k);
	int u=cha1(x),v=cha2(y);
	u=jl[u];v=jl[v];
	k=jl[k];if(u!=0)xiugai(1,k,u);if(v!=0)xiugai(1,v,k);
	merge(x,x,add(c[k]));merge(root[p],x,y);
}
int cha3(int p,int k){
	int ans=0;
	while(p){if(t[p].sum<=k)ans=max(ans,t[p].sum),p=rs;else p=ls;}
	return ans;
}
vector<int>s[1000005];
void gai(int u){
	int sum=0;
	for(int i=0;i<s[u].size();i++){
		int uu=s[u][i];
		int x,y;int v=cha3(root[vis[uu]],u-1);sum=max(sum,v);
	}
	if(sum!=0)sum=jl[sum];
	u=jl[u];
	xiugai1(1,u,sum);
}
void shan(int p,int k){
	int z,x,y;split(root[p],x,y,k);
	split(x,x,z,k-1);
	int u=cha2(y);merge(root[p],x,y);
	if(u)gai(u);
}
//
int vis1[300005];
bool viss[1000005];
signed main(){
//	freopen("hack.in","r",stdin);
//	freopen("whxx","w",stdout);
	srand(time(0));
	zss(1000000);
	int n,q,pdd=0;cin>>n>>q;
	for(int i=1;i<=q;i++){
		cin>>b[i].op;
		if(b[i].op=='S') cin>>b[i].x,c[++cnt2]=b[i].x,viss[b[i].x]=1;
		else cin>>b[i].x>>b[i].y;
		if(b[i].op!='S'){if(b[i].x!=1||b[i].y!=n) pdd=1;}
	}
	for(int i=1;i<=n;i++){
		int sum=i;if(viss[i]==0) continue;
		for(int j=1;j<=cnt;j++){
			if(zs[j]*zs[j]>sum) break;
			if(i%zs[j]==0) s[i].push_back(zs[j]);
			while(sum%zs[j]==0) sum/=zs[j];
		}
		if(sum>1) s[i].push_back(sum);
	}
	c[++cnt2]=1e18;
	sort(c+1,c+1+cnt2);jianshu(1,1,cnt2);
	for(int i=1;i<cnt2;i++){if(jl[c[i]]==0)jl[c[i]]=i;}
	for(int i=1;i<=q;i++){
		int x;
		if(b[i].op=='S'){
			x=jl[b[i].x];
			if(vis1[x]==0){
				vis1[x]=1;int xx=b[i].x;
				for(int j=0;j<s[xx].size();j++){
					jia(vis[s[xx][j]],b[i].x);
				}
			}
			else{
				x=jl[b[i].x];
				vis1[x]=0;int xx=b[i].x;
				for(int j=0;j<s[xx].size();j++){shan(vis[s[xx][j]],b[i].x);}
				xiugai1(1,x,0);
			}
		}
		else{
			x=lower_bound(c+1,c+1+cnt2,b[i].x)-c;
			int y=lower_bound(c+1,c+1+cnt2,b[i].y)-c;
			if(c[y]>b[i].y) y--;
			if(x>y) cout<<"NE"<<'\n';
			else{
				int op=cha(1,x,y);
				if(op>=x) cout<<"DA"<<'\n';
				else cout<<"NE"<<'\n';
			}
		}
	}
	return 0;
}
```

---

## 作者：船酱魔王 (赞：5)

# P8327 [COCI2021-2022#5] Radio 题解

## 题意回顾

维护一个集合 $ S $，支持两种操作：

* 向 $ S $ 插入或删除一个数 $ x $。

* 给定 $ l,r $，查询是否存在 $ x \ne y $，使得 $ x,y \in [l,r] $，$ x,y \in S $ 且 $ \gcd(x,y) \ne 1 $。

集合中所有数不超过 $ 10^6 $，操作次数不超过 $ 2 \times 10^5 $。

## 分析

互质问题线段树不好维护，因为值域不大我们转化成判断质因子是否相同的问题，则考虑把质因子分解出来后依次塞到一个大序列里，这样我们的数据结构只需要支持单点启用或禁用，区间判断启用点是否存在数值相同两种操作。

考虑一个套路，维护每个启用点的下一个等值启用点的位置，再查询区间最小值即可知道是否有区间内出现区间内其他元素的下一个等值启用点，就是存在相同的数的充要条件。

而下一个等值点的操作可以用 `set` 的 `lower_bound` 查找功能实现，注意不仅要维护被修改数的下一个等值点，还要更新上一个等值点的下一个点。

有点卡常，注意用筛法求出质因子。注意不要把值域 $ n $ 和因子序列长度 $ m $ 搞混，$ m $ 大概在 $ 1.4 \times 10^7 $ 量级。

## AC 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <set>
#define iter set<int>::iterator
using namespace std;
const int N = 1e6 + 5;
const int M = 14000005;
int n, q;
int m = 1.4e7;
vector<int> g[N];
set<int> pos[N];
int sgn[N];
int sta[N];
int d[M * 4];
int st[N];
void update(int x, int v, int s, int t, int p) {
	if(s == t) {
		d[p] = v;
		return;
	}
	int mid = (s + t) >> 1;
	if(x <= mid) update(x, v, s, mid, p * 2);
	else update(x, v, mid + 1, t, p * 2 + 1);
	d[p] = min(d[p * 2], d[p * 2 + 1]);
}
int query(int l, int r, int s, int t, int p) {
	if(l <= s && t <= r) return d[p];
	int mid = (s + t) >> 1;
	int mi = m;
	if(l <= mid) mi = min(mi, query(l, r, s, mid, p * 2));
	if(mid < r) mi = min(mi, query(l, r, mid + 1, t, p * 2 + 1));
	return mi;
}
void open(int x, int v) {
	iter it = pos[v].lower_bound(x);
	if(it != pos[v].end()) update(x, *it, 1, m, 1);
	if(it != pos[v].begin()) {
		it--;
		update(*it, x, 1, m, 1);
	}
	pos[v].insert(x);
}
void close(int x, int v) {
	pos[v].erase(x);
	iter it = pos[v].lower_bound(x);
	int tmp = m;
	if(it != pos[v].end()) tmp = *it;
	if(it != pos[v].begin()) {
		it--;
		update(*it, tmp, 1, m, 1);
	}
	update(x, m, 1, m, 1);
}
int main() {
	scanf("%d%d", &n, &q);
	char op;
	int l, r, x;
	for(int i = 1; i <= m * 4; i++) d[i] = m + 1;
	for(int j = 2; j <= n; j++) {
		if(sgn[j]) continue;
		for(int i = j; i <= n; i += j) {
			sgn[i] = 1;
			g[i].push_back(j);
		}
	}
	for(int i = 1; i <= n; i++) {
		st[i] = st[i - 1] + g[i].size();
	}
	for(int i = n; i >= 1; i--) {
		st[i + 1] = st[i] + 1;
	}
	st[1] = 1;
	for(int i = 1; i <= q; i++) {
		scanf(" %c", &op);
		if(op == 'S') {
			scanf("%d", &x);
			if(sta[x] == 1) {
				sta[x] = 0;
				for(int j = 0; j < g[x].size(); j++) {
					close(st[x] + j, g[x][j]);
				}
			} else {
				sta[x] = 1;
				for(int j = 0; j < g[x].size(); j++) {
					open(st[x] + j, g[x][j]);
				}
			}
		} else {
			scanf("%d%d", &l, &r);
			int ans = query(st[l], st[r + 1] - 1, 1, m, 1);
			if(ans <= st[r + 1] - 1) printf("DA\n");
			else printf("NE\n");
		}
	}
	return 0;
}
```

---

## 作者：CQ_Bab (赞：4)

# 前言
好题。
# 思路
首先发现如果两个数不互质那么一定至少有一个质因数既属于第 $1$ 个也属于第 $2$ 个，所以我们考虑对于 $l\sim r$ 中看是否出现过相同的质因数，发现 $a_i$ 比较小所以考虑将每一个数拆成它的质因数然后只需要对于每一个数查找其前面与它相同的且最接近于它的数的下标是否在 $l\sim r$ 之中（如果不会[可以看一下这道题](https://www.luogu.com.cn/problem/P3901)）。

有了这种思路我们就考虑如何实现，发现我们只需要满足 $\max(pre_{a_{l,j}}\sim pre_{a_{r,k}})\leq l$ 即可这里用 $a_{i,j}$ 表示第 $i$ 个数的第 $j$ 个质因子，$pre_{x}$ 表示 $x$ 的前面第一个等于 $x$ 的位置。

对于每一次修改，发现只会有两个位置的值发生改变，但是要分类讨论一下。

- 如果当前是将 $x$ 删除，假设当前的质因子为 $j$，那么要将 $x$ 的 $j$ 所在的位置改成 $0$ 再将 $x$ 之后的第一个也拥有质因子 $j$ 的位置的最大值改为 $x$ 之前的第一个又拥有 $j$ 这个质因子的位置。
- 如果将 $x$ 加入，其实差不多，就是将当前位置改为 $x$ 之前第一个有 $j$ 这个质因子的位置，再将 $x$ 之后第一个有 $j$ 这个质因子的位置的值改为 $x$。

上述的实现也只需要用一个 set 找前驱与后记即可。

统计答案也很简单就是看 $l\sim r$ 之中的最大值是否在 $l$ 及之后，直接用线段树维护即可。
# 代码
```cpp
#include <bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
#include <ext/rope>
using namespace __gnu_pbds;
using namespace std;
#define pb push_back
#define rep(i,x,y) for(register int i=x;i<=y;i++)
#define rep1(i,x,y) for(register int i=x;i>=y;--i)
#define fire signed
#define il inline
template<class T> il void print(T x) {
	if(x<0) printf("-"),x=-x;
	if (x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
template<class T> il void in(T &x) {
    x = 0; char ch = getchar();
    int f = 1;
    while (ch < '0' || ch > '9') {if(ch=='-') f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar(); }
    x *= f;
}
int T=1;
const int N=1e6+10;
int v[N][10],idx[N];
set<int>s[N];
int n,q,l[N],r[N];
vector<int>ve[N];
struct node{
	int l,r;
	int Max;
}tr[40000100];
il void build(int u,int l,int r) {
	tr[u]={l,r};
	if(l==r) return ;
	int mid=l+r>>1;
	build(u<<1,l,mid);
	build(u<<1|1,mid+1,r);
}
void up(int x) {
	tr[x].Max=max(tr[x<<1].Max,tr[x<<1|1].Max);
}
il void modify(int u,int x,int k) {
	if(tr[u].l==tr[u].r) {
		tr[u].Max=k;
		return ;
	}
	int mid=tr[u].l+tr[u].r>>1;
	if(mid>=x) modify(u<<1,x,k);
	else modify(u<<1|1,x,k);
	up(u);
}
il int Ans(int u,int l,int r) {
	if(tr[u].l>=l&&tr[u].r<=r) {
		return tr[u].Max;
	}
	int mid=tr[u].l+tr[u].r>>1,ans=0;
	if(mid>=l) ans=Ans(u<<1,l,r);
	if(mid<r) ans=max(Ans(u<<1|1,l,r),ans);
	return ans;
}
int x;
int a[N];
int vis[N];
void solve() {
	in(n),in(q);
	rep(i,2,n) {
		if(!vis[i]) {
			v[i][++idx[i]]=i;
			ve[i].pb(i);
			rep(j,2,n/i) {
				vis[i*j]=1;
				v[i*j][++idx[i*j]]=i;
				ve[i*j].pb(i);
			}
		} 
	}
	int cc=1;
	rep(i,1,n) {//将 i 拆成 i 的质因子为了快速修改
		l[i]=cc;
		cc+=idx[i];
		r[i]=cc-1;
	}
	build(1,1,r[n]);
	while(q--) {
		char opt;
		cin>>opt;
		if(opt=='S') {
			int x;
			in(x);
			if(a[x]) {
				rep(j,1,idx[x]) {
					int to=v[x][j];
					auto it=s[to].find(x);
					if(s[to].size()==1) {
						s[to].erase(it);
						continue;
					}
					int p=false;
					if(it!=s[to].begin()) {
						it--;
						p=l[*it]+lower_bound(ve[*it].begin(),ve[*it].end(),to)-ve[*it].begin();
						modify(1,l[x]+j-1,0);
						it++;
					}
					auto itr=s[to].end();
					itr--;
					if(it!=itr) {
						it++;
						int kk=lower_bound(ve[*it].begin(),ve[*it].end(),to)-ve[*it].begin();
						modify(1,l[*it]+kk,p);
						it--;
					}
					s[to].erase(it);
				}
			}else {
				rep(j,1,idx[x]) {
					int to=v[x][j];
					if(s[to].size()==0) {
						s[to].insert(x);
						continue;
					}
					auto it=s[to].lower_bound(x);
					int p=false;
					if(it!=s[to].begin()) {
						it--;
						p=*it;
						int kk=lower_bound(ve[*it].begin(),ve[*it].end(),to)-ve[*it].begin();
						modify(1,l[x]+j-1,l[*it]+kk);
						it++;
					}
					auto itr=s[to].end();
					if(it!=itr) {
						int kk=lower_bound(ve[*it].begin(),ve[*it].end(),to)-ve[*it].begin();
						modify(1,l[*it]+kk,l[x]+j-1);
					}
					s[to].insert(x);
				}
			}
			a[x]^=1;
		}else {
			int l1,r1;
			in(l1),in(r1);
			int Max=Ans(1,l[l1],r[r1]);
			if(Max>=l[l1]) puts("DA");
			else puts("NE");
		}
	}
}
fire main() {
	while(T--) {
		solve();
	}
	return false;
}
```

---

## 作者：ln001 (赞：2)

## 简化题意
维护一个不可重集合，支持动态加点删点。同时能够支持对于询问给定的 $ l, r$，判断**集合中**是否存在两个**不相等**的正整数 $ l \leq x, y \leq r$ 满足 $ \gcd(x, y) > 1 $。

## 题解

值域不大，有任意一个数的**质因子种类**不超过 $ 8 $ 个。

定义数组 $ suf $，满足 $ \gcd(suf_i, i) > 1,suf_i > i,suf_i $ 属于集合且 $ suf_i $ 最小，若 $ i $ 不在集合中则数组值为 $ n + 1$。挂一个支持单点修查，区间查询最小值的线段树。

再对每一个**质因数** $ x $ 开一个 set 存**在集合中**且是 $ x $ 的**倍数**的数。

对于在集合中插入 $ x $ 的操作，枚举 $ x $ 的质因子，在对应的 set 中找到 $ x $ 的前驱 $ y $，使 $ suf_y = \min(suf_y, x) $。

对于删除操作，我们像插入操作一样找到前驱，然后枚举该前驱的质因子，暴力维护 $ suf $ 数组。

对于查询操作，直接线段树查区间最小值，与右端点作比较即可。

---

## 作者：晴空一鹤 (赞：2)

怎么没有根号题解/fn。

直接暴力模拟题目过程，使用 `std::set` 维护所有非质数，单独用一个数组维护质数。

查询时从 $l$ 向 $r$ 遍历，如果遇到了含相同质因子的数就输出 `DA` 并退出。

这样为什么是根号的呢？考虑非质数质因子必有一个小于等于根号，因而不含相同质因子的非质数只有根号种，复杂度就是根号的。

实现上面的做法，可以在除理论时间复杂度外吊打线段树做法（包括代码复杂度和实际速度）。

---

## 作者：缪凌锴_Mathew (赞：2)

我们考虑根号分治，每个数只有 $1$ 个大于 $\sqrt n=1000$ 的质因数，而 $1000$ 以内的质因数有 $168$ 个。

注意到 $168$ 很小，我们~~心生邪念~~想到 $\frac{168}{\omega}$ 几乎是常数，于是上一个线段树套 bitset 维护 $1000$ 以内的质因数，区间查询是否有两位置 bitset 有交，维护区间内的 bitset 并即可。

然后对于大于 $1000$ 的质因数，由于每个数对应 $1$ 个，考虑对每个质因数维护。我们设 $f_x$ 为 $x$ 的大于 $1000$ 的质因数，$nxt_x$ 为 $x$ 之后第一个 $y$ 满足 $f_x=f_y$。每种 $f$ 开一个 set 维护每位置的 $nxt$，线段树维护区间 min。

时间复杂度 $O(q\frac{\sqrt n}{\ln n}+q\log n+q\frac{\sqrt n\log n}{\omega\ln n})$，但是 $\frac{\sqrt n}{\omega\ln n}\approx O(1)$。

```cpp
#include<map>
#include<set>
#include<cmath>
#include<ctime>
#include<queue>
#include<stack>
#include<cstdio>
#include<vector>
#include<string>
#include<bitset>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<algorithm>
using namespace std;
const int MAXN=1e6+10;
const int MAXM=1e3+10;
const int INF=0x3f3f3f3f;
const long long LINF=0x3f3f3f3f3f3f3f3f;
int n,q;
bool ins[MAXN];
int cnt=0;
int prime[MAXM],bac[MAXM];
bitset <MAXM> unp;
inline void seive(){
    unp[0]=true;
    unp[1]=true;
    for(int i=2;i<=1000;i++)
    {
        if(unp[i]){
            continue;
        }
        cnt++;
        prime[cnt]=i;
        bac[i]=cnt;
        for(int j=i*i;j<=1000;j+=i)
        {
            unp[j]=true;
        }
    }
}
namespace zkw{
    int m;
    bitset <170> prm[MAXN<<2];
    bool res[MAXN<<2];
    #define ls(x) (x<<1)
    #define rs(x) (x<<1|1)
    inline void push_up(int x){
        if(res[ls(x)]||res[rs(x)]){
            res[x]=true;
            return ;
        }
        if((prm[ls(x)]&prm[rs(x)]).any()){
            res[x]=true;
            return ;
        }
        res[x]=false;
        prm[x]=prm[ls(x)]|prm[rs(x)];
    }
    inline void build(){
        m=1<<(__lg(n)+1);
    }
    inline void modify(int pos,bitset <170> val){
        pos+=m;
        prm[pos]=val;
        for(pos>>=1;pos;pos>>=1)
        {
            push_up(pos);
        }
    }
    inline bool query(int l,int r){
        bitset <170> now;
        for(l+=m-1,r+=m+1;l^r^1;l>>=1,r>>=1)
        {
            if(~l&1){
                if(res[l^1]||(now&prm[l^1]).any()){
                    return true;
                }
                now|=prm[l^1];
            }
            if(r&1){
                if(res[r^1]||(now&prm[r^1]).any()){
                    return true;
                }
                now|=prm[r^1];
            }
        }
        return false;
    }
}
int b[MAXN];
set <int> big[MAXN];
int nxt[MAXN];
namespace zkw_min{
    int m;
    bitset <170> prm[MAXN<<2];
    int minv[MAXN<<2];
    #define ls(x) (x<<1)
    #define rs(x) (x<<1|1)
    inline void push_up(int x){
        minv[x]=min(minv[ls(x)],minv[rs(x)]);
    }
    inline void build(){
        m=1<<(__lg(n)+1);
        for(int i=1;i<=m+n;i++)
        {
            minv[i]=n+1;
        }
    }
    inline void modify(int pos){
        int val=nxt[pos];
        pos+=m;
        minv[pos]=val;
        for(pos>>=1;pos;pos>>=1)
        {
            push_up(pos);
        }
    }
    inline int query(int l,int r){
        int res=n+1;
        for(l+=m-1,r+=m+1;l^r^1;l>>=1,r>>=1)
        {
            if(~l&1){
                res=min(res,minv[l^1]);
            }
            if(r&1){
                res=min(res,minv[r^1]);
            }
        }
        return res;
    }
}
inline void add(int x){
    int y=x;
    bitset <170> res;
    for(int i=1;i<=cnt&&prime[i]<=x;i++)
    {
        if(y%prime[i]==0){
            while(y%prime[i]==0)
            {
                y/=prime[i];
            }
            res[i]=true;
        }
    }
    zkw::modify(x,res);
    b[x]=y;
    if(y>1){
        set <int>::iterator it=big[y].insert(x).first;
        if(it!=big[y].begin()){
            int p=*prev(it);
            nxt[p]=x;
            zkw_min::modify(p);
        }
        if(next(it)!=big[y].end()){
            nxt[x]=*next(it);
            zkw_min::modify(x);
        }
    }
}
inline void del(int x){
    int y=b[x];
    zkw::modify(x,bitset <170>());
    if(y>1){
        set <int>::iterator it=big[y].find(x);
        if(it!=big[y].begin()){
            int p=*prev(it);
            if(next(it)!=big[y].end()){
                nxt[p]=*next(it);
            }
            else{
                nxt[p]=n+1;
            }
            zkw_min::modify(p);
        }
        nxt[x]=n+1;
        zkw_min::modify(x);
        big[y].erase(it);
    }
}
signed main(){
    seive();
    scanf("%d%d",&n,&q);
    zkw::build();
    for(int i=1;i<=n;i++)
    {
        nxt[i]=n+1;
    }
    zkw_min::build();
    while(q--)
    {
        char opt;
        scanf(" %c",&opt);
        if(opt=='S'){
            int x;
            scanf("%d",&x);
            if(!ins[x]){
                add(x);
            }
            else{
                del(x);
            }
            ins[x]=!ins[x];
        }
        else{
            int l,r;
            scanf("%d%d",&l,&r);
            if(zkw::query(l,r)||zkw_min::query(l,r)<=r){
                puts("DA");
            }
            else{
                puts("NE");
            }
        }
    }
    return 0;
}
```

---

## 作者：_AyachiNene (赞：2)

# 思路：
首先容易发现判断两个数是否互质，可以直接看两个数有没有相同的质因子。质因子有很好的性质，一个数的质因子个数显然是 $\log V$ 量级的，其中 $V$ 为值域。有了这个就很好做了，可以按质因子分类，如果同时选同一类的数就可以满足不互质。然后可以套路的维护，同一类数中，考虑怎么去选一些数对更有可能造成贡献，显然是一个数和它的前驱或者后继是最有的。然后就很好维护了，每一类数开一个 set 插入或删除时就改前驱和后继就行了，再用个线段树加 set 或者平衡树去维护每个数的最大前驱和最小的后继就做完了。

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace IO
{
	char buff[1<<21],*p1=buff,*p2=buff;
	char getch(){return p1==p2&&(p2=((p1=buff)+fread(buff,1,1<<21,stdin)),p1==p2)?EOF:*p1++;}
	template<typename T>void read(T &x){char ch=getch();int fl=1;x=0;while(ch>'9'||ch<'0'){if(ch=='-')fl=-1;ch=getch();}while(ch<='9'&&ch>='0'){x=x*10+ch-48;ch=getch();}x*=fl;}
	template<typename T>void read_s(T &x){char ch=getch();while(ch<'a'||ch>'z')ch=getch();while(ch>='a'&&ch<='z'){x+=ch;ch=getch();}}
	template<typename T,typename ...Args>void read(T &x,Args& ...args){read(x);read(args...);}
	char obuf[1<<21],*p3=obuf;
	void putch(char ch) {if(p3-obuf<(1<<21))*p3++=ch;else fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=ch;}
	char ch[100];
	template<typename T>void write(T x) {if(!x)return putch('0');if(x<0)putch('-'),x*=-1;int top=0;while(x)ch[++top]=x%10+48,x/=10;while(top)putch(ch[top]),top--;}
	template<typename T,typename ...Args>void write(T x,Args ...args) {write(x);write(args...);}
	void put(string s){for(int i=0;i<s.size();i++)putch(s[i]);}
	void flush(){fwrite(obuf,p3-obuf,1,stdout);}
}
using namespace IO;
int n,q;
namespace Nene
{
	struct segt
	{
		int pre,nxt;
		segt(){pre=0,nxt=1e9;}
		inline segt operator+(const segt &a)const
		{
			segt res;
			res.nxt=min(nxt,a.nxt);res.pre=max(pre,a.pre);
			return res;
		}
	}t[1000005<<2];
	set<int>sp[1000005],sn[1000005];
	#define ls (root<<1)
	#define rs (root<<1|1)
	#define mid (l+r>>1)
	void insert(int x,int v,int op,int root=1,int l=1,int r=n)
	{
		if(l==r)
		{
			if(op==1) sp[x].insert(-v);
			else if(op==2) sn[x].insert(v);
			else if(op==3) sp[x].erase(-v);
			else if(op==4) sn[x].erase(v);
			else sn[x].clear(),sp[x].clear();
			if(sp[x].size()) t[root].pre=-*sp[x].begin();
			else t[root].pre=0;
			if(sn[x].size()) t[root].nxt=*sn[x].begin();
			else t[root].nxt=1e9;
			return; 
		}
		if(x<=mid) insert(x,v,op,ls,l,mid);
		else insert(x,v,op,rs,mid+1,r);
		t[root]=t[ls]+t[rs];
	}
	segt query(int x,int y,int root=1,int l=1,int r=n)
	{
		if(l>=x&&r<=y) return t[root];
		if(y<=mid) return query(x,y,ls,l,mid);
		if(x>mid) return query(x,y,rs,mid+1,r);
		return query(x,y,ls,l,mid)+query(x,y,rs,mid+1,r); 
	}
}
using namespace Nene;
int prim[1000005],vis[1000005],cnt;
void euler()
{
	for(int i=2;i<=n;i++)
	{
		if(!vis[i]) prim[++cnt]=i;
		for(int j=1;j<=cnt&&prim[j]*i<=n;j++)
		{
			vis[prim[j]*i]=1;
			if(i%prim[j]==0) break;
		}
	}
}
set<int>s[1000005];
int fac[1000005][21],cfac[1000005];
int main()
{
	read(n,q);
	euler();
	for(int i=1;i<=cnt;i++)
		for(int j=prim[i];j<=n;j+=prim[i])
			fac[j][++cfac[j]]=prim[i];
	memset(vis,0,sizeof vis);
	for(int i=1;i<=n;i++) s[i].insert(0),s[i].insert(1000000000);
	while(q--)
	{
		char op=getch();
		while(op!='S'&&op!='C') op=getch();
		if(op=='S')
		{
			int x;read(x);
			if(!vis[x])
			{
				for(int i=1;i<=cfac[x];i++)
				{
					int p=fac[x][i];
					set<int>::iterator nxt=s[p].lower_bound(x);
					set<int>::iterator pre=nxt;--pre;
					if(*nxt!=1e9&&*pre) insert(*nxt,*pre,3),insert(*pre,*nxt,4);
					if(*nxt!=1e9) insert(*nxt,x,1);
					if(*pre) insert(*pre,x,2);
					s[p].insert(x);
				}
				vis[x]=1;
			}
			else
			{
				for(int i=1;i<=cfac[x];i++)
				{
					int p=fac[x][i];s[p].erase(x);
					set<int>::iterator nxt=s[p].lower_bound(x);
					set<int>::iterator pre=nxt;--pre;
					if(*nxt!=1e9) insert(*nxt,x,3);
					if(*pre) insert(*pre,x,4);
					if(*nxt!=1e9&&*pre) insert(*nxt,*pre,1),insert(*pre,*nxt,2);
				}
				insert(x,0,5);
				vis[x]=0;
			}
		}
		else
		{
			int l,r;read(l,r);
			segt res=query(l,r);
			if(res.nxt<=r||res.pre>=l) puts("DA");
			else puts("NE");
		}
	}
	flush();
	return 0;
}
```

---

## 作者：ni_ju_ge (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P8327)
## 思路
由于 $10^6$ 内仅有 $78498$ 个质数，而一个数最多包含 $9$ 个互不相同的质因子，因此可以对于每个质数建一颗平衡树，用以维护质因子包含该数的位置信息（$78498$ 颗平衡树，恐怖如斯）。

考虑 `S` 操作怎么做。若是将 $x$ 开启，则可以将 $x$ 分解质因数，对于每个质因数 $p$，将 $x$ 插入 $p$ 平衡树中，最后查询 $x$ 的前驱后继并更新信息；若是将 $x$ 关闭，同样可以对 $x$ 分解质因数，然后将 $x$ 从所在的所有平衡树删除并更新其后继的信息。

关于区间 $[l,r]$ 中是否有不互质的数同时存在，可以使用 [这一题](https://www.luogu.com.cn/problem/P3901) 的方法，维护每个位置之前第一个与其不互质的数的下标和这些下标的前缀最大值，查询就可以直接通过 $r$ 位置的前缀最大值是否 $\ge l$ 来快速判断了。由于要带修，所以可以使用线段树维护。
## 代码
平衡树+线段树，毒瘤无比。
```cpp
#include<bits/stdc++.h>
using namespace std;
const double line=0.74751;
const int N=1e6+5;
//替罪羊平衡树
struct Node {
	int l,r,dat,size,same;
} tree[9*N];
int node[N];
int cnt,longth;
int n,q;
char opt;
int x,y;
int root[N];
void make(int &pos,int val) {
	tree[++cnt].dat=val;
	tree[cnt].size=1;
	tree[cnt].same=1;
	pos=cnt;
}
void up(int pos) {
	tree[pos].size=tree[tree[pos].l].size+tree[tree[pos].r].size+tree[pos].same;
}
bool bug(int pos) {
	return max(tree[tree[pos].l].size,tree[tree[pos].r].size)>tree[pos].size*line;
}
void under(int pos) {
	if(pos==0)return;
	under(tree[pos].l);
	if(tree[pos].same!=0)node[++longth]=pos;
	under(tree[pos].r);
}
int build(int l,int r) {
	if(l>=r)return 0;
	int mid=(l+r)/2;
	tree[node[mid]].l=build(l,mid);
	tree[node[mid]].r=build(mid+1,r);
	up(node[mid]);
	return node[mid];
}
void debug(int &pos) {
	if(bug(pos)) {
		longth=0;
		under(pos);
		pos=build(1,longth+1);
	}
}
void take(int val,int &pos) {
	if(pos==0)make(pos,val);
	else if(val<tree[pos].dat)take(val,tree[pos].l);
	else if(val>tree[pos].dat)take(val,tree[pos].r);
	else tree[pos].size++,tree[pos].same++;
	up(pos);
	debug(pos);
}
void del(int val,int &pos) {
	if(pos==0) {
		return;
	} else if(val<tree[pos].dat)del(val,tree[pos].l);
	else if(val>tree[pos].dat)del(val,tree[pos].r);
	else {
		tree[pos].size--;
		tree[pos].same--;
		return;
	}
	up(pos);
	debug(pos);
}
int wrank(int val,int loc) {
	int pos=root[loc],rnk=1;
	while(pos) {
		if(tree[pos].dat==val) {
			rnk+=tree[tree[pos].l].size;
			break;
		}
		if(val<=tree[pos].dat)
			pos=tree[pos].l;
		else {
			rnk+=tree[tree[pos].l].size+tree[pos].same;
			pos=tree[pos].r;
		}
	}
	return rnk;
}
int num(int val,int loc) {
	int pos=root[loc];
	while(pos) {
		int l=tree[tree[pos].l].size;
		if(l<val&&val<=l+tree[pos].same) {
			break;
		} else if(l>=val)pos=tree[pos].l;
		else {
			val-=l+tree[pos].same;
			pos=tree[pos].r;
		}
	}
	return tree[pos].dat;
}
int pre(int val,int loc) {
	return num(wrank(val,loc)-1,loc);
}
int last(int val,int loc) {
	return num(wrank(val+1,loc),loc);
}
//筛质数
int pr[N],tot;
bool vis[N],ope[N];
int ys[N][10];
void init() {
	for(int i=2;i<=n;i++) {
		if(!vis[i]) pr[++tot]=i,ys[i][1]=i,ys[i][0]=1;
		for(int j=1;i*pr[j]<=n;j++) {
			vis[i*pr[j]]=1;
			if(i%pr[j]==0) {
				for(int l=1;l<=ys[i][0];l++) ys[i*pr[j]][l]=ys[i][l];
				ys[i*pr[j]][0]=ys[i][0];
				break;
			}
			for(int l=1;l<=ys[i][0];l++) ys[i*pr[j]][l]=ys[i][l];
			ys[i*pr[j]][ys[i][0]+1]=pr[j];
			ys[i*pr[j]][0]=ys[i][0]+1;
		}
	}
}
//线段树
struct node {
	int l,r,dat;
} tr[N*4];
void tbd(int pos,int l,int r) {
	tr[pos].l=l,tr[pos].r=r;
	if(l==r) return;
	int mid=(l+r)/2;
	tbd(pos*2,l,mid);tbd(pos*2+1,mid+1,r);
}
void tcg(int pos,int gl,int val) {
	if(tr[pos].l>gl||tr[pos].r<gl) return;
	if(tr[pos].l==tr[pos].r) {
		tr[pos].dat=val;
		return;
	}
	tcg(pos*2,gl,val);tcg(pos*2+1,gl,val);
	tr[pos].dat=max(tr[pos*2].dat,tr[pos*2+1].dat);
}
int tch(int pos,int l,int r) {
	if(tr[pos].l>r||tr[pos].r<l) return -1;
	if(tr[pos].l>=l&&tr[pos].r<=r) return tr[pos].dat;
	return max(tch(pos*2,l,r),tch(pos*2+1,l,r));
}
int main() {
	cin>>n>>q;
	init();
	tbd(1,1,n);
	while(q--) {
		cin>>opt;
		if(opt=='S') {
			cin>>x;
			if(!ope[x]) {
				for(int i=1;i<=ys[x][0];i++) {
					take(x,root[ys[x][i]]);
					int pp=pre(x,ys[x][i]),ll=last(x,ys[x][i]);//更新前驱后继信息
					if(tch(1,x,x)<pp) tcg(1,x,pp);
					if(tch(1,ll,ll)<x) tcg(1,ll,x);
				}
				ope[x]=1;
			} else {
				for(int i=1;i<=ys[x][0];i++) {
					int ll=last(x,ys[x][i]);//只用更新后继信息
					del(x,root[ys[x][i]]);
					if(tch(1,ll,ll)==x){
                        tcg(1,ll,0);//记得先清零
						for(int j=1;j<=ys[ll][0];j++) {
							int pp=pre(ll,ys[ll][j]);
							if(tch(1,ll,ll)<pp) tcg(1,ll,pp);
						}
					}
				}
                tcg(1,x,0);//记得要清零
				ope[x]=0;
			}
		} else {
			cin>>x>>y;
			if(tch(1,1,y)>=x) cout<<"DA"<<endl;
			else cout<<"NE"<<endl;
		}
	}
}
```

---

## 作者：yanwh1 (赞：1)

## 前言
线段树豪题。
## 大致思路
一看到区间查询，本能想到线段树。但是，线段树并不能很好地处理互质一类的问题。

看见初始的所有电台都是关闭的，且修改是单点状态取反，于是我们想到了用 set 来维护。因为电台最大 $10^6$，所以我们可以给每个小于等于 $10^6$ 的质数都开一个 set，将一个数进行质因数分解，把每个是它质因数的 set 里加入该数。

但我们并没有解决查询的问题。于是我们尝试让线段树里的每个点去记录它前面最大的开启了的且与它不互质的电台。每次查询就去看区间 $l$ 到 $r$ 的最大数，如果大于等于 $l$，就说明有解。

于是我们每次将一个数质因数分解后，查找它的质因数的 set 里面第一个比它大的电台，尝试去更新它的前驱，并且找到最大的比它小的电台，更新自己的前驱。

删除操作就是将每个前驱是该电台的电台重新查一次前驱，再将质因数的 set 里的该数删除即可。

但是这样做有可能会 TLE。其实是我们每次插入删除数，都会查一次该数的质因数。但是电台最大也就 $10^6$，我们可以发现一个数它最多被 9 个 set 记录（原因是 $10^6$ 的数最多只能有 9 个互不相同的质数），于是我们把这些数的质因数都预处理出来，就可以 AC 此题。
## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rint register int
inline int read(){
    int f=0,t=0;
    char c=getchar();
    while(!isdigit(c)) t|=(c=='-'),c=getchar();
    while(isdigit(c)) f=(f<<3)+(f<<1)+c-48,c=getchar();
    return t?-f:f;
}inline void write(int x) {
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar('0'+x%10);
}const int N=1e6+5;
int mark[N],prim[N],cnt,vis[N],n,q;
int tr[N<<2];
vector<int>s[N];
set<int>::iterator c;
set<int>st[N],et;
inline void zss(int n){
	for(rint i=2;i<=n;i++){
		if(!mark[i])prim[++cnt]=i;
		for(rint j=1;j<=cnt&&prim[j]*i<=n;j++){
			mark[i*prim[j]]=1;
			if(i%prim[j]==0)break;
		}
	}
}inline void update(int p,int l,int r,int x,int e){
	if(l==r){tr[p]=e;return;}
	int mid=l+r>>1;
	if(x<=mid)update(p<<1,l,mid,x,e);
	else update(p<<1|1,mid+1,r,x,e);
	tr[p]=max(tr[p<<1],tr[p<<1|1]);
}inline int query(int p,int l,int r,int ul,int ur){
	if(ul<=l&&r<=ur)return tr[p];
	int mid=l+r>>1,rs=0;
	if(ul<=mid)rs=query(p<<1,l,mid,ul,ur);
	if(mid<ur)rs=max(rs,query(p<<1|1,mid+1,r,ul,ur));
	return rs;
}
signed main(){
	n=read(),q=read();zss(n);
	for(rint i=1;i<=n;i++){
		int res=i;
		for(rint j=1;j<=cnt&&prim[j]*prim[j]<=res;j++){
			if(res%prim[j]==0){
				s[i].push_back(prim[j]);
				while(res%prim[j]==0)res/=prim[j];
			}
		}if(res>1)s[i].push_back(res);
	}while(q--){
		char e=getchar();
		while(e<'A'||e>'Z')e=getchar();
		if(e=='S'){
			int x=read();
			int pre=0,nxt=INT_MAX;
			for(rint i=0;i<s[x].size();i++){
				int u=s[x][i];
				if(!vis[x])st[u].insert(x);
				else st[u].erase(x);
				c=st[u].lower_bound(x);
				if(c!=st[u].begin())
					--c,pre=max(pre,*c);
				c=st[u].upper_bound(x);
				if(c!=st[u].end()){
					nxt=*c;
					if(!vis[x]){
						int rs=query(1,1,n,nxt,nxt);
						if(rs<x)update(1,1,n,nxt,x);
					}else{
						int pr=0;
						for(rint j=0;j<s[nxt].size();j++){
							int v=s[nxt][j];
							c=st[v].lower_bound(nxt);
							if(c!=st[v].begin())
								--c,pr=max(pr,*c);
						}update(1,1,n,nxt,pr);
					}
				}
			}if(!vis[x]){
				vis[x]=1;
				if(pre)update(1,1,n,x,pre);
			}else{
				vis[x]=0;
				update(1,1,n,x,0);
			}	
		}else{
			int l=read(),r=read();
			if(query(1,1,n,1,r)>=l)puts("DA");
			else puts("NE");
		}
	}
	return 0;
}
```

---

## 作者：be_RISK (赞：1)

noip 模拟 T3，感觉没有紫
## 题意
给你 $n$ 个电台，对于任意两个开启的电台互相影响，当且仅当这两个电台的编号不互质，初始每个电台均关闭，给定 $q$ 此操作，S 操作将编号为 $x$ 的电台转换状态，开变关，关变开，C 操作让你输出 $l$ 到 $r$ 的电台是否有影响。
## 思路
首先可以发现，对于 $a,b$ 不互质，当且仅当 $a$ 与 $b$ 有至少一个共同质因子，所以我们可以开很多个 set 记录，第 $i$ 个 set 记录有哪些数有质因子 $p_i$，$p_i$ 表示第 $i$ 大的质数。

可以发现对于一个区间 $[l,r]$，我们只要找到一个开启的电台 $i(l\le i\le r)$，和一个开起的电台电台 $j(j<i)$，$i$ 与 $j$ 互质，且 $l \le j$，那么这个区间就会有电台互相影响，显然我们可以对于每个 $x(1\le x \le n)$，记录编号比他小且与他相互影响，同时编号最大的电台 $a_x$，我们在查询区间时就找当前区间 $[l,r]$ 最大的 $a_i(l\le i \le r)$，判断这个值是否大于 $l$ 就好了，这个区间最大值显然可以用线段树维护。

那怎么找 $a_x(1\le x \le n)$ 呢？ 结合之前的 set，可以想到，将 $x$ 插入 set 后，他的前一个元素就是编号比 $x$ 小且与 $x$ 的公因子有 $p_i$，同时编号最大的那个，所以我们只要找 $x$ 的每个质因子对应的 set 的 $x$ 的前一个元素的最大值就是 $a_x$，自然就好用线段树处理了。

不过为了跟方便使用线段树，我们可以将一个数的质因子拆出来，对应一段区间，记录一下左右端点，这样就跟方便了。

代到题当中，C 操作很类似于链表，插入就将 $a$ 变为前一个，后一个的 $a$ 变为当前值，并加入他需要进的 set，删除就将后一个的 $a$ 变为前一个，并将他的 $a$ 变为 $0$，这就相当于关掉了，同时在他进的 set 里用迭代器删除他。
## code
```c++
#include<bits/stdc++.h>
bool Memory_start;
void debug();
using namespace std;
inline int read(){
    char c=getchar();
    int ret=0,f=1;
    while(c<'0'||c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        ret=(ret<<3)+(ret<<1)+c-'0';
        c=getchar();
    }return ret*f;
}
inline void write(int x,int op=0){
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10,0);
    putchar((char)(x%10+'0'));
    if(op){
        if(op>0)puts("");
        if(op<0)putchar(' ');
        if(op==0)puts("114514");
    }
}
int n,q;
int sum;//总区间长度
int pcnt;//质数技术
bitset<1000001>f;//在筛素数与体面的改变状态中使用，为省空间开bitset
char cnt[1000001];//质因子个数，为省空间开char
int v[1000001][10];//数组vi表示i的所有质因子
int tr[10000001];
int st[1000001],ed[1000001];//左右端点
set<int>s[79000];
inline void update(int id,int l,int r,int x,int v){
	if(l==r){
		tr[id]=v;
		return ;
	}int mid=l+r>>1;
	if(x<=mid)update(id<<1,l,mid,x,v);
	else update(id<<1|1,mid+1,r,x,v);
	tr[id]=max(tr[id<<1],tr[id<<1|1]);
}
inline int find(int id,int l,int r,int s,int t){
	if(s<=l&&r<=t)return tr[id];
	int mid=l+r>>1,ret=0;
	if(s<=mid)ret=max(ret,find(id<<1,l,mid,s,t));
	if(mid<t)ret=max(ret,find(id<<1|1,mid+1,r,s,t));
	return ret;
} 
signed main(){
	ios::sync_with_stdio(0);
    n=read(),q=read();
    for(int i=2;i<=n;i++){
        if(!f[i]){
			v[i][cnt[i]++]=++pcnt;
	        for(int j=i<<1;j<=n;j+=i){
	        	f[j]=1;//打标记
	            v[j][cnt[j]++]=pcnt; //加入质因子
	        }
		}
    }sum=2;
    st[1]=ed[1]=1;//1也配有区间的好吗？
	for(int i=1;i<=n;i++){
		st[i]=sum,ed[i]=sum+cnt[i]-1;//记录区间左右端点
		sum+=cnt[i];//将这个区间长度并到总区间长度去
	}
    f=0;
    set<int>::iterator tmp,it,temp;//也是为省空间（？
    for(int i=1;i<=q;++i){
        char op=getchar();
        while(op!='S'&&op!='C') op=getchar();//优化
        if(op=='S'){
        	int t,x=read();
        	if(f[x]){//删除
				for(int j=st[x];j<=ed[x];++j){
					t=v[x][j-st[x]];
					if(s[t].size()==1){
						s[t].clear();
						continue;
					}
					tmp=s[t].lower_bound(j);
					it=s[t].end(); --it;
					bool ff=false;
					if(tmp==s[t].begin()){
						ff=true;
						++tmp;
						update(1,1,sum,(*tmp),0);
					}
					else if(tmp!=it){
						ff=true;
						++tmp;
						temp=tmp;
						--temp,--temp;
						update(1,1,sum,(*tmp),(*temp));
					}
					if(ff)--tmp;
					s[t].erase(j);
	        		update(1,1,sum,j,0);
				} 
			}else{//插入
				for(int j=st[x];j<=ed[x];++j){
					t=v[x][j-st[x]];
					if(s[t].size()==0){
						s[t].insert(j);
						continue;
					}
					tmp=s[t].lower_bound(j);
					if(tmp!=s[t].end()){
						update(1,1,sum,(*tmp),j);
					}
					temp=tmp;
					if(temp!=s[t].begin()){
						--temp;
						update(1,1,sum,j,(*temp));
					}
					s[t].insert(j);
				}
			}
            //插入与删除的操作类似于链表
			f[x]=(f[x]?0:1);//改变状态
		}
        else{
            int l=read(),r=read();
            int t=find(1,1,sum,st[l],ed[r]);//区间最大值
            if(t>=st[l])printf("yes\n");//输出总会吧。。。
            else printf("no\n");
        }
    }
    return 0;
}//~*完结撒花*~
bool Memory_end;
void debug(){
	cerr<<"Time: "<<clock()<<" ms\n";
	cerr<<fixed<<setprecision(6)<<"Memory: "<<abs(&Memory_start-&Memory_end)/1024.0/1024.0<<" MB";
}
```

---

## 作者：ax_by_c (赞：0)

~~对比了一下其他题解，发现是比较神金的做法。~~

只需对每个质数判断区间内是否有多个被点亮的倍数。

令 $B=\sqrt n$，分类讨论。

对于 $\le B$ 的质数，直接用 log 数据结构维护。我们知道质数个数为 $O(\frac{B}{\log B})$，因此复杂度为 $O(qB)=O(q\sqrt n)$。

对于 $>B$ 的质数，我们知道每个数最多只能对应一个，本质上是问区间内是否有重复点亮元素。用 log 数据结构维护每个点亮位置前一个相同点亮位置，查询就是求区间最值，时间复杂度 $O(q\log n)$。

综上，时间复杂度 $O(q\sqrt n)$。

```cpp
#include<bits/stdc++.h>
#define rep(i,l,r) for(int i=(l),qwp=(r);i<=qwp;i++)
#define per(i,r,l) for(int i=(r),qwp=(l);i>=qwp;i--)
#define repll(i,l,r) for(ll i=(l),qwp=(r);i<=qwp;i++)
#define perll(i,r,l) for(ll i=(r),qwp=(l);i>=qwp;i--)
#define UQ(hsh,hc) (sort((hsh)+1,(hsh)+1+(hc)),(hc)=unique((hsh)+1,(hsh)+1+(hc))-(hsh)-1)
#define pb push_back
#define ins insert
#define clr clear
#define uset unordered_set
#define umap unordered_map
using namespace std;
namespace ax_by_c{
typedef long long ll;
const int N=1e6+5;
const int B=168+5;
bool np[N];
int p[N],pc,pc_,pp[N];
vector<int>ps[N];
void Init(int n){
    np[1]=1;
    rep(i,2,n){
        if(!np[i])p[++pc]=i;
        for(int j=1;j<=pc&&i*p[j]<=n;j++){
            np[i*p[j]]=1;
            if(!(i%p[j]))break;
        }
    }
    rep(i,1,pc){
        if((ll)p[i]*p[i]<=n){
            pc_=i;
            for(int j=p[i];j<=n;j+=p[i])ps[j].pb(i);
        }
        else for(int j=p[i];j<=n;j+=p[i])pp[j]=p[i];
    }
}
struct DS1{
    set<int>s;
    void ins(int x){
        s.ins(x);
    }
    void rem(int x){
        s.erase(s.find(x));
    }
    bool Q(int l,int r){
        auto p=s.lower_bound(l),q=p;
        if(p==s.end())return 0;
        q++;
        if(q==s.end())return 0;
        return l<=*p&&*q<=r;
    }
}S[B];
struct DS2{
    int tr[N*4];
    void pu(int u){
        tr[u]=max(tr[u<<1],tr[u<<1|1]);
    }
    void upd(int u,int l,int r,int p,int x){
        if(l==r){
            tr[u]=x;
            return ;
        }
        int mid=l+((r-l)>>1);
        if(p<=mid)upd(u<<1,l,mid,p,x);
        else upd(u<<1|1,mid+1,r,p,x);
        pu(u);
    }
    int Q(int u,int l,int r,int ql,int qr){
        if(ql<=l&&r<=qr)return tr[u];
        int mid=l+((r-l)>>1),res=0;
        if(ql<=mid)res=max(res,Q(u<<1,l,mid,ql,qr));
        if(mid+1<=qr)res=max(res,Q(u<<1|1,mid+1,r,ql,qr));
        return res;
    }
}tr;
int n,q;
set<int>pos[N];
void add(int x){
    for(auto y:ps[x])S[y].ins(x);
    if(pp[x]){
        int t=pp[x],p=0,q=0;
        pos[t].ins(x);
        auto it=pos[t].find(x);
        if(it!=pos[t].begin())it--,p=*it,it++;
        it++;if(it!=pos[t].end())q=*it;it--;
        if(p)tr.upd(1,1,n,x,p);
        if(q)tr.upd(1,1,n,q,x);
    }
}
void rem(int x){
    for(auto y:ps[x])S[y].rem(x);
    if(pp[x]){
        int t=pp[x],p=0,q=0;
        auto it=pos[t].find(x);
        if(it!=pos[t].begin())it--,p=*it,it++;
        it++;if(it!=pos[t].end())q=*it;it--;
        pos[t].erase(it);
        tr.upd(1,1,n,x,0);
        if(q)tr.upd(1,1,n,q,p);
    }
}
bool Q(int l,int r){
    rep(i,1,pc_)if(S[i].Q(l,r))return 1;
    if(tr.Q(1,1,n,l,r)>=l)return 1;
    return 0;
}
bool a[N];
void slv(int _csid,int _csi){
    scanf("%d %d",&n,&q);
    Init(n);
    rep(_,1,q){
        char op;
        scanf(" %c",&op);
        if(op=='S'){
            int x;
            scanf("%d",&x);
            if(!a[x])add(x);
            else rem(x);
            a[x]^=1;
        }
        if(op=='C'){
            int l,r;
            scanf("%d %d",&l,&r);
            if(Q(l,r))puts("DA");
            else puts("NE");
        }
    }
}
void main(){
	// ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int T=1,csid=0;
	// scanf("%d",&csid);
	// scanf("%d",&T);
	rep(i,1,T)slv(csid,i);
}
}
int main(){
	string __name="";
	if(__name!=""){
		freopen((__name+".in").c_str(),"r",stdin);
		freopen((__name+".out").c_str(),"w",stdout);
	}
	ax_by_c::main();
	return 0;
}
/*
g++ -std=c++14 -O2 -Wall -Wextra "-Wl,--stack=200000000" A.cpp -o A.exe
A.exe
*/
```

---


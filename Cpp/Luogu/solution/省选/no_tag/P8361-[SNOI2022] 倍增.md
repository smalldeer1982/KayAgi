# [SNOI2022] 倍增

## 题目描述

小 Z 是一个喜欢编程的女孩子。

这天，她在做一道编程题的时候偶然发现了一个神奇的整数 $142857$。

$142857 \times 2 = 285714$，而 $285714$ 的所有数位恰好是 $142857$ 的一个排列。

她很好奇，有没有更大的满足这种性质的整数。

她写了一个搜索，发现了一些更大的有趣的数：

$26835741 \times 2 = 53671482$

$0987312654 \times 2 = 1974625308$

$\dots$

她不满足于解决十进制下这样的问题，于是她想知道，是否在 $B$ 进制下存在一个 $n$ 位正整数 $x$，满足 $2x$ 的所有数位在 $B$ 进制下是 $x$ 的所有数位的一个排列。

由于她讨厌数字 $0$，因此她还要求对于任意 $1 \leq i \leq n$，$x$ 和 $2x$ 在 $B$ 进制下的第 $i$ 位不能同时为 $0$。

## 说明/提示

**【样例 1 解释】**

- 第一组数据的解释参见【题目描述】。
- 对于第二组数据，可以通过枚举所有的 $n$ 位 $B$ 进制数说明一定不能找到这样的正整数。
- 对于第三组数据，$2x$ 的 $7$ 进制表示为 $103635_{(7)}$，因此这是一个满足题意的答案。

注意此样例的答案文件仅表明了一种可能的合法答案，不表明答案文件恰好对应标准程序的输出。

**【样例 2/3 解释】**

注意此样例的答案文件仅表明了一种可能的合法答案，不表明答案文件恰好对应标准程序的输出。

**【提示】**

由于答案可能不唯一，我们下发了校验器 `checker.cpp` 和库文件 `testlib.h`。

可以使用以下命令编译 `checker.cpp`：

```
g++ -o checker checker.cpp -O2 -std=c++11
```

将 `checker.cpp` 编译得到可执行文件 `checker` 后你可以使用以下方式测试你的答案：

`checker <input> <output> <answer>`：利用选手目录下的 `double/double*.ans` 可以用来检验你的答案在样例测试点 `double/double*.in` 的正确性。

`checker <input> <output> <output>`：会检查你的所有有解输出是否符合题目要求。注意以此种方式测试的时候，输出无解总会被报告为合法，因为在此种运行方式下我们只会检查你报告的所有解。

**请选手注意多组数据之间的清空问题。**

**【数据规模与约定】**

对于全部数据，$1 \leq T \leq 10^4$，$2 \leq \sum B \leq 2 \times 10^5$，$1 \leq \sum n \leq 2 \times 10^5$，$n \geq 1$，$B \geq 2$。

具体的数据规模与约定见下表。

| 测试点编号 |    $n \leq$     |    $ B \leq$    | $T \leq$ | 特殊约定            |
| :--------: | :-------------: | :-------------: | :------: | ------------------- |
|    $1$     |       $8$       |       $8$       |   $10$   |                     |
|    $2$     |       $8$       |       $8$       |  $10^4$  |                     |
|    $3$     | $2 \times 10^5$ |       $8$       |   $10$   |                     |
|    $4$     | $2 \times 10^5$ |       $8$       |  $10^4$  |                     |
|    $5$     | $2 \times 10^5$ |       $8$       |  $10^4$  |                     |
|    $6$     |      $15$       |      $15$       |  $100$   |                     |
|    $7$     |      $40$       |      $40$       |  $100$   |                     |
|    $8$     |      $100$      |      $100$      |  $100$   |                     |
|    $9$     |      $300$      |      $300$      |  $100$   |                     |
|    $10$    |     $1000$      |     $1000$      |  $100$   |                     |
|    $11$    |     $3000$      |     $3000$      |  $100$   |                     |
|    $12$    |     $15000$     |     $15000$     |  $100$   |                     |
|    $13$    |     $50000$     |     $50000$     |  $100$   |                     |
|    $14$    | $2 \times 10^5$ | $2 \times 10^5$ |  $100$   |                     |
|    $15$    |      $200$      |      $200$      |  $10^4$  | $n \geq 100$        |
|    $16$    |     $5000$      |     $5000$      |  $10^4$  | $n \geq 100$        |
|    $17$    | $2 \times 10^5$ | $2 \times 10^5$ |  $10^4$  | $n \geq 100$        |
|    $18$    |      $300$      |      $300$      |  $10^4$  | $B=3k-1,k \in \N^*$ |
|    $19$    | $2 \times 10^5$ | $2 \times 10^5$ |  $10^4$  | $B=3k-1,k \in \N^*$ |
|    $20$    |      $300$      |      $300$      |  $10^4$  | $B=3k,k \in \N^*$   |
|    $21$    | $2 \times 10^5$ | $2 \times 10^5$ |  $10^4$  | $B=3k,k \in \N^*$   |
|    $22$    |      $100$      |      $100$      |  $10^4$  |                     |
|    $23$    |      $500$      |     $5000$      |  $10^4$  |                     |
|    $24$    | $2 \times 10^5$ | $2 \times 10^5$ |  $10^4$  |                     |
|    $25$    | $2 \times 10^5$ | $2 \times 10^5$ |  $10^4$  |                     |


## 样例 #1

### 输入

```
3
6 10
3 3
6 7
```

### 输出

```
1 4 2 8 5 7
-1
0 3 5 3 1 6```

## 样例 #2

### 输入

```
样例 2 见附件 double2.in
本组数据满足测试点 3 的限制。```

### 输出

```
样例 2 见附件 double2.ans```

## 样例 #3

### 输入

```
样例 3 见附件 double3.in
本组数据满足测试点 17 的限制。```

### 输出

```
样例 3 见附件 double3.ans```

# 题解

## 作者：zhoukangyang (赞：11)

[cnblogs](https://www.cnblogs.com/zkyJuruo/p/17727283.html#snoi2022-%E5%80%8D%E5%A2%9E)。

~~本来想加强一下放 noip 模拟赛的，后来发现 loj 上已经有这种做法了，十分遗憾。~~

首先这题等价于对于 $B$ 找到最小的满足条件的 $n$。因为可以在最优解里面插一堆 $B-1$。

这个 $n$ 不会很大，因此一个比较暴力的想法是暴力枚举对应关系的排列和进位。

考虑把排列的环抠出来。不妨是 $p_1 \to p_2 \to ... \to p_k \to (p_{k+1}=p_1)$（这里的 $p$ 表示排列对应位置上的值）。

不妨 $c_i$ 是第 $p_i$ 位得到的进位数量，那么 $2p_i+c_i \equiv p_{i+1} \pmod B$。

所以就有 $2^k p_1 + \sum_{j=1}^{k} 2^{k-j} c_j \equiv p_1 \pmod B$。

设 $C = \sum_{j=1}^{k} 2^{k-j} c_j$，显然 $0 \le C < 2^k$。

不妨设 $(2^k-1)p_1 + C = tB$，可以发现 $0 \le t \le 2^k$。

而有了 $t$ 之后，由于 $C \le 2^{k}-1$，所以 $(p_1,C)$ 只有 $\Theta(1)$ 种方案。

然后我们就可以算出来每个位置被前面的那个位置进了多少位，向后面的那个位置进了多少位。

而最后的那个数就是 一条在 $0,1$ 两个点的图上的**欧拉回路**。这就要求了 $0 \to 1$ 和 $1 \to 0$ 的边数相同。

我们抠出来的环的 $0 \to 1$ 和 $1 \to 0$ 的边数不一定相同，所以可能要选多个环。这个可以背包解决。

设 $k$ 是答案，时间复杂度 $\Theta(k2^k)$。[aclink](https://loj.ac/s/1895923)。

---

## 作者：panyf (赞：8)

首先发现一个性质，假设对于一个 $b$，求出了一个长度为 $n$ 的答案，那么找到一个进位的位置，在上一位插一个 $b-1$，就构造出了长度为 $n+1$ 的答案。

考虑对于每个 $b$ 如何求出一个长度最短的答案。

枚举答案的长度 $l$，全排列枚举 $p$ 表示 $x$ 第 $i$ 位 和 $2x$ 第 $p_i$ 位相同，再 $2^l$ 枚举每一位是否进位。对于 $p$ 上的每一个环，都对应一个 $k$ 个未知数 $k-1$ 个方程的不定方程，然后这种方案对应的 $b$ 就可以表示成 $ux+v$ 的形式。

对每组询问，找到 $l$ 最短并且存在 $x$ 满足 $b=ux+v$ 的方案即可，注意这样构造出的方案有可能出现某一位同时为 $0$，要判掉，考场上没判挂到 48 分了。

可以发现对于所有 $b\leq 200000$ $l$ 都不会超过 $9$，但是 $l=9$ 的时候预处理要跑一分钟，发现这样的数只有三个，打表即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct P{
	int l,k,n,i,a[19];
}s[999];
map<pair<int,int>,int>mp;
bool bk[200009];
int ct,t,O;
void wk(int n){
	int a[19],i,j,k,l,o,ta,tb,p,wa[19],wb[19],wp[19],wt;
	bool vis[19];
	for(i=1;i<=n;++i)a[i]=i;
	do{
		for(i=1;i<=n;++i)if(a[i]==i)goto G;
		for(i=(1<<(n-1))-1;~i;--i){
			memset(vis,0,sizeof vis);wt=0;
			for(j=1;j<=n;++j)if(!vis[j]){
				k=j,p=0;
				while(!vis[k])vis[k]=1,k=a[k],p=p*2+1;
				ta=tb=0;
				k=j;
				do{
					ta=ta*2+(i>>(k-1)&1),tb*=2;
					if(k>1)tb+=(i>>(k-2)&1);
					k=a[k];
				}while(k!=j);
				if(ta==0)goto gg;
				wa[++wt]=ta,wb[wt]=tb,wp[wt]=p;
			}
			k=l=0;
			for(j=2;j<=(1<<(n+1));++j){
				for(o=1;o<=wt;++o)if((wa[o]*j-wb[o])%wp[o])goto g2;
				if(!k)k=j;
				else{l=j;break;}
				g2:;
			}
			if(!k)goto gg;
			l-=k;
			if(mp.count({l,k}))goto gg;
			mp[{l,k}]=1;
			s[++t].l=l,s[t].k=k,s[t].i=i;s[t].n=n;
			memcpy(s[t].a,a,sizeof a);
			gg:;
		}
		G:;
	}while(next_permutation(a+1,a+n+1));
}
int n,b;
int main(){ios::sync_with_stdio(0);cin.tie(0);
	wk(2);wk(3);wk(4);wk(5);wk(6);wk(7);wk(8);
int T,i,pos,ans,a[19],jw=0;
bool vis[19],v2[999];
int j,k,p,ta,tb;
cin>>T,s[0].n=9;
while(T--){
	cin>>n>>b;memset(v2,0,t+1);
	gg:;
	ans=9,pos=0;
	for(i=1;i<=t;++i)if(!v2[i]&&(b-s[i].k)%s[i].l==0)if(ans>s[i].n)ans=s[i].n,pos=i;
	if(n<ans){
		cout<<"-1\n";
		continue;
	}
	if(ans==9){
		if(b==32131){
			jw=5;
			a[1]=3081,a[2]= 6162,a[3]= 12324,a[4] =24648,a[5]= 17165,a[6]= 2200,a[7]= 17606,a[8]= 4401,a[9]= 8803; 
		}else if(b==64261){
			jw=6;
			a[1]=7168,a[2]= 14336,a[3]= 28672,a[4]= 57344,a[5]= 50427,a[6]= 36594,a[7]= 35714,a[8]= 8928,a[9]= 17857; 
		}else{
			jw=8;
			a[1]=53131,a[2]= 106262,a[3]= 51873,a[4]= 103747,a[5]= 53445,a[6]= 46843,a[7]= 106891 ,a[8]=93686 ,a[9]=26722; 
		}
		goto _;
	}
	memset(vis,0,sizeof vis);
	
	for(j=1;j<=s[pos].n;++j)if(!vis[j]){
		k=j,p=0;
		while(!vis[k])vis[k]=1,k=s[pos].a[k],p=p*2+1;
			ta=tb=0;
				k=j;
				do{
					ta=ta*2+(s[pos].i>>(k-1)&1),tb*=2;
					if(k>1)tb+=(s[pos].i>>(k-2)&1);
					k=s[pos].a[k];
				}while(k!=j);
		a[j]=(ta*b-tb)/p;
		k=j;
		while(s[pos].a[k]!=j){
			a[s[pos].a[k]]=a[k]*2;
			if((s[pos].i>>(k-1)&1))a[s[pos].a[k]]-=b,jw=k;
			if(k>1)a[s[pos].a[k]]+=(s[pos].i>>(k-2)&1);
			k=s[pos].a[k];
		}
	}
	for(i=s[pos].n;i;--i)if(a[i]==b){v2[pos]=1;goto gg;}
	_:;
	for(i=s[pos].n;i>jw;--i)cout<<a[i]<<' ';
	for(i=n-s[pos].n;i;--i)cout<<b-1<<' ';
	for(i=jw;i;--i)cout<<a[i]<<' ';
	cout<<'\n';
}
	return 0;
}

```


---

## 作者：Renshey (赞：5)

#### 题解

考虑归纳构造，发现 $B$ 一定时，若 $n$ 有解，则 $n+1$ 一定有解，在 $n$ 的解中进位的一位后添加若干个 $B-1$ 即可，例如：

$$142857 \times 2 = 285714$$

$$1428957 \times 2 = 2857914$$

$$14289957 \times 2 = 28579914$$

$$142899957 \times 2 = 285799914$$

$$\dots$$

因此考虑直接对于每种 $B$ 暴力找出长度最小的答案。

枚举长度 $n$ 与数位排列 $p$，即 $2{(a_na_{n-1}\dots a_{1})}_B={(a_{p_n}a_{p_{n-1}}\dots a_{p_1})}_B$，再枚举每一位是否进位 $S$，可以直接解出每一位的具体值，直接判断是否在 $[0,B)$ 范围内即可。

暴力枚举所有 $B$ 发现只有三个 $B$ 满足 $n = 9$，剩余的 $B$ 均满足 $n \le 8$，因此直接按上述方式枚举即可。

#### 代码

```cpp
#include <bits/stdc++.h>
#define Getchar() p1 == p2 and (p2 = (p1 = Inf) + fread(Inf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++
#define Putchar(c) p3 == p4 and (fwrite(Ouf, 1, 1 << 21, stdout), p3 = Ouf), *p3++ = c
char Inf[1 << 21], Ouf[1 << 21], *p1, *p2, *p3 = Ouf, *p4 = Ouf + (1 << 21);
inline int read (void)
{
	int x = 0; char c = Getchar();
	while (c < '0' or c > '9') c = Getchar();
	while (c >= '0' and c <= '9') x = x * 10 + c - 48, c = Getchar();
	return x;
}
inline void write (int x)
{
	if (x >= 10) write(x / 10), x %= 10;
	Putchar(x ^ 48);
}
const int maxn = 200000 + 10;
int ans[maxn]; std::vector<int> ans0[maxn], ans1[maxn];
inline void solve (int B)
{
	int p[20], w[20]; bool vis[20];
	for (int n = 2; ; n++)
	{
		for (int i = 1; i <= n; i++) p[i] = i;
		while (std::next_permutation(p + 1, p + n + 1))
			for (int S = 2; S < (1 << n); S += 2)
			{
				for (int i = 1; i <= n; i++) w[i] = -1, vis[i] = false;
				for (int i = 1; i <= n; i++) if (!vis[i])
				{
					int a[20] = {0}, wx[20] = {0}, wy[20] = {0}, m = 0;
					for (int j = i; !vis[j]; j = p[j]) vis[a[++m] = j] = true;
					wx[1] = 1; wy[1] = 0;
					for (int j = 2; j <= m; j++)
					{
						wx[j] = 2 * wx[j - 1];
						wy[j] = 2 * wy[j - 1] + ((S >> (a[j - 1] - 1)) & 1) - B * ((S >> a[j - 1]) & 1);
					}
					wx[1] = 2 * wx[m] - 1;
					wy[1] = 2 * wy[m] + ((S >> (a[m] - 1)) & 1) - B * ((S >> a[m]) & 1);
					if (wy[1] % wx[1] != 0) continue;
					w[a[1]] = - wy[1] / wx[1];
					for (int j = 2; j <= m; j++) w[a[j]] = wx[j] * w[a[1]] + wy[j];
				}
				bool flag = true;
				for (int i = 1; i <= n; i++) flag &= 0 <= w[i] and w[i] < B;
				if (flag)
				{
					ans[B] = n;
					for (int i = 1; i <= n; i++) if ((S >> i) & 1)
					{
						for (int j = n; j > i; j--) ans0[B].push_back(w[j]);
						for (int j = i; j > 0; j--) ans1[B].push_back(w[j]);
						return;
					}
				}
			}
	}
}
signed main ()
{
	for (int T = read(); T--; )
	{
		int n = read(), B = read();
		if (!ans[B]) solve(B);
		if (ans[B] > n) {Putchar('-'); Putchar('1'); Putchar('\n'); continue;}
		std::vector<int> Ans;
		for (int x: ans0[B]) Ans.push_back(x);
		for (int i = 0; i < n - ans[B]; i++) Ans.push_back(B - 1);
		for (int x: ans1[B]) Ans.push_back(x);
		for (int i = 0; i < n; i++) write(Ans[i]), Putchar(" \n"[i == n - 1]);
	}
	fwrite(Ouf, 1, p3 - Ouf, stdout); fflush(stdout);
	return 0;
}
```

---

## 作者：myee (赞：4)

### 前言

思路清奇的题目。被吓到了。

### 思路

首先容易发现 $n=2,B=3k-1$ 的很好构造：

$$\begin{matrix}\dfrac{B-2}3&\dfrac{2B-1}3\end{matrix}$$

然后发现 $n=3$ 时，这个可以变成

$$\begin{matrix}\dfrac{B-2}3&B-1&\dfrac{2B-1}3\end{matrix}$$

然后发现 $n\ge2$ 时，这个可以变成

$$\begin{matrix}\dfrac{B-2}3&B-1&B-1&\cdots&B-1&\dfrac{2B-1}3\end{matrix}$$

似乎是在一组合法解中插了很多 $B-1$？

事实上，只要构造出一组 $n$ 最小的合法解，我们总可以在其中某个进位处（必定有进位吧）狂插 $B-1$，从而实现解决所有情况。

然后问题就是找到这组合法解……

我不会啊，这玩意怎么构造。

然后你点开[官方题解](https://pan.baidu.com/s/105g6p3AFV85pkdDblR_huw?pwd=5mtr)一看：

> 通过打表观察不难猜测，最小解 $p$ 可能非常小。
> 
> 基于这样的猜测，可以从小到大检查每个最小解 $p$，考虑答案排列中的每个环，对于单个环的情况，不难提出一个 $O(2^pB)$ 的做法，即枚举起始元素和按环上顺序枚举每个元素时，该元素从排列中原始位置的前一位处获得的进位情况。

真就爆搜是吧。

但是看不懂标答是怎么搜的，考虑~~自己想~~贺题解。

不妨考虑枚举最小解 $p$，然后枚举变化的排列，枚举进位串，每个环做高斯消元，判断合法性。

然后就对跑太慢的几个打打表，就完了。嗯。

$p=9$ 的有 $3$ 个，$p=8$ 的有四十来个，随便打表吧。

### Code

表的生成器放在注释里。

```cpp
std::vector<uint>Sol[200005];
voi update(uint B){
    if(Sol[B].size())return;
    bol ok=false;
    for(uint p=2;!ok;p++){
        std::vector<uint>P;for(uint i=0;i<p;i++)P.push_back(i);
        while(!ok&&std::next_permutation(P.begin(),P.end())){
            if(P.back()==p-1)continue;
            for(uint S=1;!ok&&S<(1u<<(p-1));S++){
                std::vector<bol>Gone(p);
                std::vector<llt>Ans(p);
                ok=true;
                for(uint i=0;ok&&i<p;i++)if(!Gone[i]){
                    uint j=i,t=0;llt a=1,b=0,x;std::vector<std::pair<llt,llt> >V;
                    do 
                        V.push_back({a,b}),a*=2,b=2*b+(j?S>>(j-1)&1:0)-(S>>j&1?(llt)B:0),j=P[j];
                    while(j!=i);
                    x=b/(1-a);if(x<0||x>=B||b!=x*(1-a)){ok=false;break;}
                    do
                        Ans[j]=x*V[t].first+V[t].second,t++,Gone[j]=1,j=P[j];
                    while(j!=i);
                }
                if(ok)for(uint i=0;i<p;i++)ok&=S>>i&1?Ans[i]*2+(i?S>>(i-1)&1:0)>=B&&Ans[i]<B:Ans[i]>=0&&Ans[i]*2+(i?S>>(i-1)&1:0)<B;
                if(ok)for(uint i=0;i<p;i++)Sol[B].push_back(Ans[i]);
            }
        }
    }
}
int main()
{
#ifdef MYEE
    freopen("QAQ.in","r",stdin);
    freopen("QAQ.out","w",stdout);
#endif
	Sol[1135]={832,529,1059,983,302,605,75,151,};
	Sol[8191]={2152,4304,417,835,1670,6681,5171,3340,};
	Sol[8380]={6145,3910,7821,7262,2234,4469,558,1117,};
	Sol[18145]={13306,8467,16935,15725,4838,9677,1209,2419,};
	Sol[24256]={6373,12746,1236,2473,4946,19785,15314,9892,};
	Sol[32131]={3081,6162,12324,24648,17165,2200,17606,4401,8803,};
	Sol[32635]={23932,15229,30459,28283,8702,17405,2175,4351,};
	Sol[40195]={29476,18757,37515,34835,10718,21437,2679,5359,};
	Sol[48385]={35482,22579,45159,41933,12902,25805,3225,6451,};
	Sol[52165]={38254,24343,48687,45209,13910,27821,3477,6955,};
	Sol[56386]={14815,29630,2874,5749,11498,45993,35600,22996,};
	Sol[58150]={42643,27136,54273,50396,15506,31013,3876,7753,};
	Sol[64135]={47032,29929,59859,55583,17102,34205,4275,8551,};
	Sol[64261]={7168,14336,28672,57344,50427,36594,35714,8928,17857,};
	Sol[66151]={37615,9079,18159,36318,25941,6485,51883,12970,};
	Sol[72010]={52807,33604,67209,62408,19202,38405,4800,9601,};
	Sol[72136]={34229,68458,64780,57425,42715,53182,13295,26591,};
	Sol[72640]={53269,33898,67797,62954,19370,38741,4842,9685,};
	Sol[80011]={75304,70597,61184,42358,4706,9413,18826,37652,};
	Sol[80641]={30675,61350,42059,3478,6957,55658,13914,27829,};
	Sol[81145]={59506,37867,75735,70325,21638,43277,5409,10819,};
	Sol[88390]={64819,41248,82497,76604,23570,47141,5892,11785,};
	Sol[92170]={67591,43012,86025,79880,24578,49157,6144,12289,};
	Sol[96265]={70594,44923,89847,83429,25670,51341,6417,12835,};
	Sol[98155]={71980,45805,91611,85067,26174,52349,6543,13087,};
	Sol[100171]={89957,79743,59316,18462,95064,73851,36925,47532,};
	Sol[112141]={105544,98947,85754,59368,6596,13193,26386,52772,};
	Sol[120016]={17414,34828,69656,19296,38593,68715,77186,34357,};
	Sol[120205]={88150,56095,112191,104177,32054,64109,8013,16027,};
	Sol[120646]={31699,63398,6150,12301,24602,98409,76172,49204,};
	Sol[129151]={100788,72425,15700,31401,122060,114969,125605,62802,};
	Sol[136270]={99931,63592,127185,118100,36338,72677,9084,18169,};
	Sol[136396]={64721,129442,122488,108581,80767,100558,25139,50279,};
	Sol[140176]={13193,26386,52772,105544,70912,6596,1649,3298,};
	Sol[144271]={135784,127297,110324,76378,8486,16973,33946,67892,};
	Sol[146161]={16049,32098,64196,128392,110623,75086,8024,4012,};
	Sol[152020]={111481,70942,141885,131750,40538,81077,10134,20269,};
	Sol[152146]={22076,44152,88304,24462,48925,87111,97850,43555,};
	Sol[160021]={92247,24473,126134,48947,97895,143077,71538,35769,};
	Sol[160651]={53131,106262,51873,103747,53445,46843,106891,93686,26722,};
	Sol[168211]={24407,48814,97628,27045,54091,96309,108182,48154,};
	Sol[169156]={1990,3980,7960,85573,127364,15920,31841,63682,};
	Sol[176275]={129268,82261,164523,152771,47006,94013,11751,23503,};
	Sol[180181]={43102,86204,172408,164635,149090,118000,111641,55820,};
	Sol[184150]={135043,85936,171873,159596,49106,98213,12276,24553,};
    // for(uint B=2;B<=200000;B++){
    //     update(B);
    //     if(B%1000==0)fprintf(stderr,"Now:%u\n",B),fflush(stderr);
    // }
    // for(uint i=2;i<=200000;i++){
    //     printf("\n%u:%u ",i,(uint)Sol[i].size());
    //     for(auto s:Sol[i])printf("%u,",s);
    //     if(Sol[i].size()>=8)
    //     {
    //         fprintf(stderr,"\tSol[%u]={",i);
    //         for(auto s:Sol[i])fprintf(stderr,"%u,",s);
    //         fprintf(stderr,"};\n");
    //     }
    // }
    uint t;scanf("%u",&t);
    while(t--){
        uint n,B;scanf("%u%u",&n,&B),update(B);
        if(Sol[B].size()>n)puts("-1");
        else{
            std::vector<uint>Ans=Sol[B];
            uint t=0;
            while(Ans[t]*2<B)t++;
            Ans.insert(Ans.begin()+t+1,n-Ans.size(),B-1);
            for(uint i=Ans.size()-1;~i;i--)
                printf("%u%c",Ans[i]," \n"[!i]);
        }
    }
    return 0;
}
```












---

## 作者：FFTotoro (赞：3)

很厉害的构造题。下文所述中一个 $B$ 进制数的第 $i$ 位为**从左往右**数第 $i$ 位。

考虑对于一个进制 $B$，若能构造出长度为 $n$ 的答案，则一定能构造出长度为 $n+1$ 的答案：因为若 $2\times \overline{d_1d_2\cdots d_n}=\overline{d_{p_1}d_{p_2}\cdots d_{p_n}}$，那么一定有 $2\times \overline{d_1d_2\cdots d_{i-1}(B-1)d_i\cdots d_n}=\overline{d_{p_1}d_{p_2}\cdots d_{p_{i-1}}(B-1)d_{p_i}\cdots d_{p_n}}$，其中 $i$ 表示在长度为 $n$ 的原数中某个向前一位进位的数位；即在第 $i-1$ 位与第 $i$ 位中插入了一个 $B-1$ 必然也能满足条件。于是问题转换为：对于每个 $B$ 找出最小的 $n$ 使得 $n$ 有解。

大胆猜测对于 $2\le B\le 2\times 10^5$，最小的满足条件的 $n$ 不大——事实证明存在较少个 $B$ 使得 $n=9$，其它情况下均满足 $n\le 8$。于是可以提出一个十分暴力的做法：

枚举原数 $x=\overline{d_1d_2\cdots d_n}$ 的每一位对应 $2x=\overline{d_{p_1}d_{p_2}\cdots d_{p_n}}$ 的哪一位（即确定一个排列 $p$），再枚举 $2\sim n$ 中每一位有没有是否有向前一位进位，之后就可以得到关于 $d_i$ 的 $n$ 个方程——是可以解出所有 $d_i$ 的。

具体地，对于一个排列 $p$，连边 $i\to p_i$，可以得到若干个环。每条边代表的方程是如下的形式：令 $b_x$ 表示 $x$ 是否向 $x-1$ 进位，如果进位为 $1$ 否则为 $0$，则方程为 $d_{p_i}=2d_i+b_{i+1}-B\cdot b_i$。

对于一个环 $c_1,c_2,\ldots,c_k$，通过如下方法解出所有 $d_{c_i}$ 的值：将 $d_{c_2}$ 用一个关于 $d_{c_1}$ 的一次函数表示，接着就可以表示 $d_{c_3},d_{c_4},\ldots,d_{c_n}$，最后由于 $c_n\to c_1$ 也有一个方程，所以能确定 $k',b'$ 使得 $d_{c_1}=k'd_{c_1}+b'$，得出 $d_{c_1}$ 的值后又能顺次推出其他的 $d_{c_i}$；最后检查一下所有解出的 $d_i$ 是否满足 $d_i\in[0,B)\cap\Z$ 即可。

如果你被卡常，下载数据后发现 $B=32131$ 跑得最慢，打表一下就过了。

放代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5;
vector<int> vl[N+1],vr[N+1];
pair<vector<int>,vector<int> > solve(int B){
  if(B==32131){
    return make_pair(
      vector<int>({7545,15090}),
      vector<int>({30181,28232,24334,3772,16537,943,1886})
    );
  } // 特判
  for(int n=2;;n++){
    vector<int> p(n);
    iota(p.begin(),p.end(),0);
    do{
      for(int S=2;S<1<<n;S+=2){
        bool f=true;
        vector<bool> b(n);
        vector<int> r(n,-1);
        for(int i=0;i<n&&f;i++)
          if(!b[i]){
            int x=i; vector<int> v;
            while(!b[x])v.emplace_back(x),b[x]=true,x=p[x];
            pair<int,int> lf(1,0); // 一次函数
            for(int i:v)lf=make_pair(lf.first*2,lf.second*2+(S>>i+1&1)-(S>>i&1)*B);
            if(lf.second%(lf.first-1))f=false; // 无整数解
            else{
              r[v[0]]=-lf.second/(lf.first-1);
              for(int i=1;i<v.size();i++)
                r[v[i]]=r[v[i-1]]*2+(S>>v[i-1]+1&1)-(S>>v[i-1]&1)*B;
            } // 顺次推出所有值
          }
        for(int i=0;i<n&&f;i++)
          f&=0<=r[i]&&r[i]<B;
        if(f){
          for(int i=0;i<n;i++)
            if(S>>i&1){
              vector<int> L,R;
              for(int j=0;j<i;j++)
                L.emplace_back(r[j]);
              for(int j=i;j<n;j++)
                R.emplace_back(r[j]);
              return make_pair(L,R);
            }
        }
      } // 枚举进位
    }while(next_permutation(p.begin(),p.end()));
    // 枚举排列
  }
}
int main(){
  ios::sync_with_stdio(false);
  cin.tie(0); cout.tie(0);
  int t; cin>>t;
  while(t--){
    int n,b; cin>>n>>b;
    if(vl[b].empty())tie(vl[b],vr[b])=solve(b);
    if(vl[b].size()+vr[b].size()>n){cout<<"-1\n"; continue;}
    for(int i:vl[b])cout<<i<<' ';
    for(int i=0;i<n-vl[b].size()-vr[b].size();i++)
      cout<<b-1<<' ';
    for(int i:vr[b])cout<<i<<' ';
    cout<<'\n';
  }
  return 0;
}
```

---

## 作者：dead_X (赞：2)

## 思路
垃圾题慎入。

考虑我们显然可以将一组解在一个进位的位置不断放 $B-1$，显然仍然合法。

于是我们对于一个特定的位数和一个对应关系，可以写出 $n$ 元一次方程组来表示每一位之间的关系，而方程组一定能解出来形如 $x=\frac{2^nB+t}{2^n-1}$ 的解，方程组的个数是 $n!$ 级别的，所以可以感性理解当 $n$ 比较大时对于任意 $B\bmod 2^n$ 都存在一组方程合法。

这告诉我们对于一个 $B$，最小段长不会很大，可以直接枚举排列求出，枚举后在最小答案中不断增加 $B-1$ 即可构造。

注意在列出每一位的对应关系方程时需要枚举哪些位置进位了。

似乎并不需要特判数据，也有可能是官方数据杂鱼。

## 代码

```cpp
//泥の分際で私だけの大切を奪おうだなん
#include<bits/stdc++.h>
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
vector<int> v[200003];
bool vis[103];
int p[103],a[103],stk[103];
#define ll long long
bool t1[103],t2[103];
void solve(int m)
{
	for(int L=2; L<=10; ++L)
	{
		for(int i=0; i<L; ++i) p[i]=i;
		do
		{
			for(int z1=1; z1<L; ++z1)
				for(int z2=z1; z2<L; z2+=2)
			{
				for(int i=0; i<L; ++i) t1[i]=t2[i]=vis[i]=0;
				for(int i=0; i<z1; ++i) t1[i]=1;
				for(int i=1; i<=z1; ++i) t2[i]=1;
				for(int i=z1+1; i<=z2; i+=2) t1[i]=1,t2[i+1]=1;
				bool ok=1;
				for(int i=0; ok&&i<L; ++i) if(!vis[i])
				{
					ll X=1,Y=0;
					int top=0;
					for(int j=i; !vis[j]; j=p[j])
					{
						if(t1[j]) Y+=X;
						if(t2[j]) Y-=X*m;
						X<<=1,stk[++top]=j,vis[j]=1;
					}
					--X,Y=-Y;
					if(X==0||Y%X||Y/X<0||Y/X>=m){ok=0;break;}
					a[stk[top]]=Y/X;
					for(int j=top; j>1; --j)
					{
						a[stk[j-1]]=a[stk[j]]*2;
						if(t1[stk[j]]) ++a[stk[j-1]];
						if(t2[stk[j]]) a[stk[j-1]]-=m;
						if(a[stk[j-1]]<0||a[stk[j-1]]>=m){ok=0;break;}
					}
				}
				if(ok)
				{
					for(int i=0; i<L; ++i) v[m].push_back(a[i]);
					return ;
				}
			}
		}
		while(next_permutation(p,p+L));
	}
	return ;
}
signed main()
{
	for(int T=read();T--;)
	{
		int n=read(),m=read();
		if(v[m].empty()) solve(m);
		if(n<(int)v[m].size()) puts("-1");
		else
		{
			int sz=v[m].size();
			printf("%d ",v[m][0]);
			for(int i=0; i<n-sz; ++i) printf("%d ",m-1);
			for(int i=1; i<sz; ++i) printf("%d ",v[m][i]);
			puts("");
		}
	}
	return 0;
}
```

---

## 作者：Otomachi_Una_ (赞：0)

## 倍增

考虑如果你对一个 $(n,B)$ 求出了答案，那么你对答案进位的地方插一个 $B-1$ 仍然合法，也就是 $(n+1,B)$ 的一组合法解。

这启示我们只需要对 $B$ 找最短的合法数字即可。容易猜测这样的 $n$ 很小（实际上不超过 $9$）。

考虑对一个固定的 $n$ 如何找是否存在合法数字。可以枚举排列 $p$ 和进位集合 $c_i\in\{0,1\}$，也就是：

- $2(a_na_{n-1}\dots a_1)_{(B)}=(a_{p_n}a_{p_{n-1}}\dots a_{p_1})_{(B)}$。
- $a_{p_i}=2a_i+c_{i-1}-Bc_i$。

下面的式子我们可以对每个 $p$ 的环解决，通过迭代大概形式就是 $a_i=ka_i+b$ 的形式，解是唯一的。

这样子做复杂度是 $\mathcal O(n!2^n)$ 的。你发现当 $n\geq 8$ 时你暴力打个表，否则直接跑复杂度就是对的。

实际上直接写也能过。可能是受限于 $\sum B$ 所以跑不满。

另一种更加优秀的解法是对每个环，只有几种情况：

- 接受后面进位并进位给前面；
- 后面没进位，自己也没进位；
- 后面进位，自己没进位；
- 后面没进位，自己进位；

我们目标是把这些环拼起来，通过欧拉回路我们只需要保证 $3,4$ 两种的元素相等即可。这里可以背包。

时间复杂度降为 $\mathcal O(2^n\times poly(n))$。

我写的是上面的暴力。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int MAXN=2e5+5;
vector<int> ans[MAXN];
void solve(int B){
	static int p[15],c[15],a[15],vis[15];
	for(int i=0;i<15;i++) p[i]=c[i]=a[i]=vis[i]=0;
	for(int n=2;;n++){
		for(int i=1;i<=n;i++) p[i]=i;
		do{
			for(int C=0;C<(1<<n-1);C++){
				bool flag=true;
				for(int j=1;j<=n-1;j++) c[j]=(C>>(j-1)&1);
				memset(vis,0,sizeof(vis));
				for(int i=1;i<=n;i++) if(!vis[i]){
					ll k=1,b=0,q=i;
					while(!vis[q]){
						k*=2,b*=2;b+=(c[q-1]-B*c[q]);
						vis[q]=true;q=p[q];
					}
					k--;
					a[i]=(-b)/k;
					if(a[i]<0||a[i]>=B) flag=false;
					while(p[q]!=i){
						a[p[q]]=2*a[q]+c[q-1]-B*c[q];
						q=p[q];
					}
					if(a[i]!=2*a[q]+c[q-1]-B*c[q]) flag=false;
				}
				for(int i=1;i<=n;i++) if(a[i]<0||a[i]>=B||a[i]+a[p[i]]==0) flag=false;
				if(2*a[n]+c[n-1]>=B) flag=false;
				if(flag){
					ans[B].resize(n);
					for(int i=0;i<n;i++) ans[B][i]=a[n-i];
					return;
				}
			}
		}while(next_permutation(p+1,p+n+1));
	}
}
int main(){
	ios::sync_with_stdio(false);
	// freopen("double.in","r",stdin);
	// freopen("double.out","w",stdout);
	int _;cin>>_;
	while(_--){
		int B,n;cin>>n>>B;
		if(ans[B].empty()) solve(B);
		if(n<ans[B].size()) cout<<"-1"<<'\n';
		else if(n==ans[B].size()) for(int i=0;i<n;i++) cout<<ans[B][i]<<" \n"[i==n-1];
		else{
			for(int i=0;i<ans[B].size();i++) if(ans[B][i]*2>=B){
				for(int j=0;j<i;j++) cout<<ans[B][j]<<' ';
				for(int j=1;j<=n-ans[B].size();j++) cout<<B-1<<' ';
				for(int j=i;j<ans[B].size();j++) cout<<ans[B][j]<<' ';
				cout<<'\n';
				break;
			}
		}
	}
}
```

---

## 作者：Fzrcy (赞：0)

首先如果我们知道 $B$ 进制下 $n$ 有解，我们可以在进位处插入 $B-1$，得到 $n+1$ 的解，所以我们只需求出 $B$ 进制下最短的答案即可。

通过打表，我们可以发现 $B$ 进制下合法的 $n$ 满足 $n\le 9$，且 $n=9$ 的情况只有三个，于是我们考虑暴力枚举长度 $n$，然后枚举排列 $p$，使得 $2\times (a_{n}a_{n-1}\dots,a_1)_B=(a_{p_{n}}a_{p_{n-1}}\dots,a_{p_{1}})_B$，再枚举进位集合 $S$，设 $c_i$ 表示第 $i$ 位会产生进位。

对于排列 $p$ 的一个环 $\{q_1,q_2\dots q_m\}$，满足 $2a_{q_i}+c_{q_i-1}-Bc_{q_i}=a_{q_{i+1}}$。于是我们可以求出 $a_{i}$ 的具体的值或判断无解，最后判断 $a_i\in[0,B)$ 即可。由于 $B$ 不同的询问不多（$\sum B\le2\times 10^5$），所以代码的速度并不算太慢（也可能是数据水）。

```cpp
// qwq
#include <bits/stdc++.h>
using namespace std;
constexpr int N=2e5+9;
vector<int>part1[N],part2[N];
int ans[N];
void sol(int B){
    static int vis[30],p[30],w[30],pw2[30],b[30],a[30];
    for(int n=2;;++n){
        for(int i=1;i<=n;i++)p[i]=i;
        while(next_permutation(p+1,p+n+1)){
            for(int S=2;S<(1<<n);S+=2){
                for(int i=1;i<=n;i++)w[i]=-1,vis[i]=0;
                for(int i=1,m=0;i<=n;i++)if(!vis[i]){
                    m=0;for(int j=i;!vis[j];j=p[j])a[++m]=j,vis[j]=1;
                    pw2[1]=1,b[1]=0;
                    for(int j=2;j<=m;j++){
                        pw2[j]=pw2[j-1]*2;
                        b[j]=b[j-1]*2+((S>>a[j-1]-1)&1)-((S>>a[j-1])&1)*B;
                    }
                    pw2[1]=pw2[m]*2-1;
                    b[1]=b[m]*2+((S>>(a[m]-1))&1)-((S>>a[m])&1)*B;
                    if(b[1]%pw2[1])continue; // 不存在整数解。
                    w[a[1]]=-b[1]/pw2[1];
                    for(int j=2;j<=m;j++)
                        w[a[j]]=pw2[j]*w[a[1]]+b[j];
                }
                bool fl=1;
                for(int i=1;i<=n;i++)fl&=(w[i]>=0&&w[i]<B);
                if(fl){
                    for(int i=1;i<=n;i++)if(S>>i&1){
                        ans[B]=n;
                        for(int j=n;j>i;j--)part1[B].push_back(w[j]);
                        for(int j=i;j>0;j--)part2[B].push_back(w[j]);
                        return;
                    }
                }
            }
        }
    }
}
int main(){
    memset(ans,-1,sizeof ans);
    int T;cin>>T;
    while(T--){
        int B,n;
        cin>>n>>B;
        if(ans[B]==-1)sol(B);
        //cout<<ans[B]<<'\n';
        if(ans[B]>n){
            puts("-1");
            continue;
        }
        for(auto i:part1[B])cout<<i<<' ';
        for(int i=1;i<=n-ans[B];i++)cout<<B-1<<' ';
        for(auto i:part2[B])cout<<i<<' ';
        puts("");
    }
    return 0;
}
```



---


# [POI 2004] Gra

## 题目描述

让我们考虑一个在 $m \times 1$ 的板子上玩的游戏,板子被从 $1$ 到 $m$ 编号。 

现在板子上有 $n$ 个棋子，每个都严格占据板子上的一个格子，没有一个棋子占据格子 $m$。 

每个单独的移动遵循以下原则：移动的人选择一个棋子把它移动到比它大的格子中第一个未被占据的格子里去。两个选手交替移动，谁先占据格子 $m$ 谁赢。

我们在当且仅当他移动以后令一选手无论如何都无法赢他的时候说当前选手的移动称作 $\text{winning}$ 操作。

我们想知道先手有多少个移动是 $\text{winning}$ 操作。

## 说明/提示

对于 $100$ % 的数据：$2 \le m \le 10^{9}, 1 \le n \le 10^{6}$ ，且有 $n + 1 \le m$ 。

下面是一个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/obrkvr84.png)

在 $m = 7$ 的时候，一个选手可以把 $2$ 移到 $4$，把 $3$ 移到 $4$ 或者把 $6$ 移动到 $7$。

## 样例 #1

### 输入

```
5 2
1 3```

### 输出

```
1```

# 题解

## 作者：Wanderer_01 (赞：4)

## 题意：

题目传送门

[P8382](https://www.luogu.com.cn/problem/P8382)

每个棋子都是单项移动的，可以看出此题是一个阶梯博弈。

## 思路：

看一眼数据范围 $n\le 10^6$,暴力使用 sg 函数可过，但 $m\le 10^9$ 是什么鬼啊！数组开不下啊！考虑离散化操作。

相邻的几个棋子到终点的距离相等，可以看作一个位置。

间隔为奇数的两个点，可以看作两个相邻的位置。

间隔为偶数的两个点，可以看作两个相邻的同奇偶位置，即两者之间有一个间隔。

那么如何计算先手有多少个必胜的第一步呢？

阶梯博弈的胜负判断是把所有 $i$ 为奇数的 $sg_i$ 异或起来。若异或和为 $0$，则先手无必胜操作，若不为 $0$，则先手有必胜操作。

当先手必胜时当且仅当先手操作后留下的局面是先手必败，即异或和为 $0$。

那么计算时只需枚举每一个奇数位，判断其减少是否能使异或和为 $0$。若能答案加一。

```
if((sg[i]^check)<sg[i]) ans++;		//check记录异或和
```
再枚举每一个偶数位，判断其使下一位即奇数位增加是否能使异或和为 $0$。若能答案加一。

```
if(i<tot&&(sg[i]^check)>sg[i]&&sg[i+1]>=(sg[i]^check)-sg[i]) ans++;		//tot为位置总数
```

注意到一点，间隔为奇数的两个棋子不能直接当成相邻的两点。

只有间隔为一的两点才能，而其他的应视为间隔为二的两个位置。

这样 $sg$ 数组最大只需开到 $3n$，空间问题就解决了。

~~然后这题就做完了。~~

还有一个细节需要考虑，若有棋子一步便可获胜，那么先手必须一步获胜，这里需要特判。

```
if(a[n]==m-1) for(int i=n; i&&a[i]==m-n+i-1; i--) ans++;
```

以下是完整代码，时间复杂度为 $O(n)$。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
bool f1;
int m,n,ans;
int a[1000005];
int sg[3000005],tot;
int check;
bool f2;
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||'9'<ch){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while('0'<=ch&&ch<='9'){
		x=(x<<1)+(x<<3)+(ch&15);
		ch=getchar();
	}
	return x*f;
}
int main(){
//	printf("%.8lfMB\n",(&f2-&f1)/1024.0/1024.0);
	m=read(),n=read();
	for(int i=1; i<=n; i++) a[i]=read();
	if(a[n]==m-1) for(int i=n; i&&a[i]==m-n+i-1; i--) ans++;
	else{
		a[n+1]=m-1;
		for(int i=n; i; i--){
			if(a[i]==a[i+1]-1) sg[tot]++;
			else if(a[i]==a[i+1]-2) sg[++tot]=1;
			else if((a[i+1]-a[i]-1)&1) tot+=3,sg[tot]=1;
			else tot+=2,sg[tot]=1;
		}
		for(int i=1; i<=tot; i+=2) check^=sg[i];
		if(check){
			for(int i=1; i<=tot; i+=2){
				if((sg[i]^check)<sg[i]) ans++;
				if(i<tot&&(sg[i]^check)>sg[i]&&sg[i+1]>=(sg[i]^check)-sg[i])
					ans++;
			}
		}
	}
	printf("%d\n",ans);
}
```

---

## 作者：Lofty (赞：4)

### 前言：

谁知道我是怎么看教练的 bug 代码 AC 而怀疑人生的。已经研究困了。

### 思路：

[题目传送门](https://www.luogu.com.cn/problem/P8382)

博弈论最重要的是，发现模型并进行转模。这题很容易发现，与阶梯模型十分相似。可以考虑每个棋子距离 $M$ 还有多少空格转化成当前在第几级阶梯。可是当我们转化后发现，胜利条件有一些不一样。阶梯模型是所有硬币到最后一级就算胜利，但在这里我们只需要有一枚硬币到最后一级就可以胜利。

起初我就是在这里卡住的。所以想到晚上睡觉的时候才想出来（不要晚上想题，会睡不着）。我们可以再往前推几步。以下推理均在对方准备开始操作时。

有一枚硬币到 $M$ 格即为胜利，等价于有一枚硬币到 $M-1$ 格即为失败，也就等价与所有硬币距离 $M$ 只差两个空格时即为胜利。

**请读者自己思考这段话，非常重要**。

这样，我们就可以转模了。设每个棋子距离 $M-2$ 还有多少空格为在第几级阶梯上即可。第零级的可以无视，因为博弈中两人只会在无法移动其他阶梯的硬币（也就是棋子）时才会移动（下一步对手就赢了）。转模后棋子有可能在负一级，这时需要特判，直接走就赢了。

但是阶梯求方案数并不是直接像 nim 游戏的石子堆一样。在判断是否能胜利时确实只有奇数阶有贡献，但算方案时，偶数阶也可能有贡献。

偶数阶可能的贡献来源相当于在原有的石子堆中多加了一堆或者是增加其中一堆的石子，从而达到平衡态，而奇数阶的贡献来源则是拿掉其中一堆的部分或全部石子来达到平衡态。

理清思路后就可以开始 coding 了。

### 代码：
```
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define TP template<typename T>
#define TP_ template<typename T,typename ... T_>
TP void read(T &x)
{
	x=0;int f=1;char ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
	for(;ch>='0'&&ch<='9';ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
	x*=f;
}
TP_ void read(T &x,T_&...y){read(x);read(y...);}
TP void write(T x){if(x<0){putchar('-'),x=-x;}if(x>9)write(x/10);putchar(48+x%10);}
TP void writeln(const T x){write(x);puts("");}
TP void writesp(const T x){write(x);putchar(' ');}
TP_ void writeln(const T x,T_ ...y){writesp(x);writeln(y...);}
using LL=long long;
constexpr int N=1e6+5;
int n,m,a[N],c[N],f[N];
int main()
{
	read(m,n);
	for(int i=1;i<=n;i++)
		read(a[i]);
	for(int i=1;i<=n;i++)//转模
		a[i]=m-2-a[i]-n+i;
	int len=0,ones=0;
	for(int i=n;i>=1;i--)
	{
		if(a[i]==-1)
		{
			ones++;
			continue;
		}
		else if(a[i])
		{
			if(f[len]!=a[i])
				f[++len]=a[i],c[len]=1;
			else 
				c[len]++;
		}
	}
	if(ones){writeln(ones);return 0;}//1的特判
	int res=0,ans=0;
	for(int i=1;i<=len;i++)
		if(f[i]&1)
			res^=c[i];
	if(!res){puts("0");return 0;}
	for(int i=1;i<=len;i++)
	{
		if(f[i]&1)//减少其中一堆
		{
			if((res^c[i])<=c[i])
				ans++;
		}
		else
			if(f[i]-1!=f[i-1])//新加一堆
			{
				if(c[i]>=res)
					ans++;
			}
			else//增加其中一堆
			{
				int s=(res^c[i-1])-c[i-1];
				if(s>0&&s<=c[i])
					ans++;
			}
	}
	writeln(ans);
	return 0;
}
```

---

## 作者：Error_Eric (赞：3)

### 题意

[Link](https://www.luogu.com.cn/problem/P8382)

[乐](https://www.luogu.com.cn/record/list?user=217300&pid=P8382&page=1)

upd：去掉了几个空格。

### 解法

首先空的格子数量是不变的。

我们用 $f_i$ 表示右起第 $i$ 个空格左边有几个连续的棋子。特殊地，$f_0$ 表示表格右边右起有几个连续的棋子。

例如样例中 $f=\{0,1,0,2,0\}$。

如此，每次操作便可以等价为选择一个 $i(i> 0,f_i\not=0)$，和一个小于 $f_i$ 的正整数 $p$，$f_i\leftarrow f_i-p$, $f_{i-1}\leftarrow f_{i-1}+p$。达成 $f_0>0$ 者获胜。

然后就是阶梯 nim。也就是要求对于所有奇数 $i$，$f_i$ 的异或和为 $0$ 为先手必败态。

于是本题就是求操作一次后 $f$ 数组奇数位异或和为 $0$ 的方案数。

考虑求出奇数位原本的异或和 $c$。

对于奇数 $i$，$f_i$ 可以一步变成 $[0,f_i)$ 之中的一个数。故当且仅当 $f_i \oplus c\in [0,f_i)$ 可行。

对于偶数 $i$，$f_i$ 可以让 $f_{i-1}$ 一步变成 $(f_{i-1},f_{i-1}+f_i]$ 之中的一个数，因此当且仅当 $f_{i-1}\oplus c\in (f_{i-1},f_{i-1}+f_i]$ 可行。

注意 $i$ 很大，不要把所有的都存下来。存非 $0$ 的就可以了。

### Code

```cpp#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<vector>
using namespace std;
#define pii pair<int,int>
const void readln(int &I){
    I=0;char C=getchar();bool f=0;
    while(!isdigit(C))f|=(C=='-'),C=getchar();
    while( isdigit(C))I=I*10+C-'0',C=getchar();
    if(f)I=-I;
}
int m,n,pos[1000006],c,ans;
vector<pii >f;
pii operator++(pii&px){px.second++;return px;}
int main(){
    readln(m),readln(n);
    for(int i=1;i<=n;i++)
        readln(pos[i]);
    if(pos[n]==m-1){
        for(int j=n-1;j>0;j--)  
            if(pos[j]==pos[j+1]-1)++ans;
            else break;
        return printf("%d\n",++ans),0;
    }
    for(int i=n;i>=1;i--)
        if(pos[i]==pos[i+1]-1)++*(f.rbegin());
        else f.push_back(make_pair(m-pos[i]-(n-i),1));
    for(auto fx:f)
        if(fx.first&1)c^=fx.second;
    for(int i=0;i<f.size();i++){
        auto fx=f[i];
        if(fx.first&1){
            if(fx.second>(fx.second^c))
            ++ans;
        }
        else if(i!=0){
            int nx;
            if(f[i-1].first==f[i].first-1) nx=f[i-1].second;
            else nx=0;
            if(fx.second+nx>=(nx^c) and (nx^c)>nx)++ans;
        }
        else if(f[i].first>3 and f.size()==2){//注意特判/kk
            if(fx.second>=c)++ans;   // 8 3 1 3 4
        }
    }
    printf("%d\n",ans);
}
```

---

## 作者：Purslane (赞：2)

# Solution

这个问题转化到阶梯博弈真的很简单吗……

容易发现，空格的数量不变。假设从左往右第 $i$ 个空格的左边恰有连续 $f_i$ 个棋子。

一次移动，相当于选定一个 $i$ 和 $0 < x \le f_i$，并且 $f_i \leftarrow f_i-x$，$f_{i-1} \leftarrow f_{i-1}+x$。

如果 $f_1 \neq 0$，那么先手必胜，而且必须移动这 $f_1$ 个棋子中的一个。

当 $f_1 = 0$ 的时候，二者会选择**避免让 $f_1 \neq 0$**。这相当于对 $(f_3,f_4,\cdots)$ 做阶梯 $\rm Nim$。

因此我们知道了先手必胜的条件是 $f_3 \oplus f_5 \oplus \cdots \neq 0$ 或 $f_1 \neq 0$。先手必输的条件是 $f_3 \oplus f_5 \oplus \cdots = 0$ 且 $f_1 = 0$。

直接模拟即可。由于 $m$ 很大，但是 $f$ 绝大多数都是 $0$，所以可以只维护非零位置。移动任何一个棋子只会改变 $O(1)$ 个 $f$，因此容易判断。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e6+10;
int m,n,a[MAXN],pre[MAXN];
map<int,int> f;
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>m>>n;
	ffor(i,1,n) cin>>a[i];
	sort(a+1,a+n+1);
	ffor(i,1,n) {
		if(a[i-1]==a[i]-1) pre[i]=pre[i-1]+1;
		else pre[i]=1;	
	}
	vector<int> pos;
	ffor(i,1,n) if(a[i+1]!=a[i]+1||i==n) f[m-a[i]-(n-i)]=pre[i],pos.push_back(m-a[i]-(n-i));
	if(f[1]) return cout<<f[1],0;
	int x=0,ans=0;
	for(auto pr:f) if(pr.first%2==1&&pr.first!=1) x^=pr.second;
	for(auto id:pos) if(id!=2) {
		int v=f[id];
		ffor(j,1,v) {
			int xx=x;
			if(id&1) xx^=v^(v-j);
			else xx^=f[id-1]^(f[id-1]+j);
			if(!xx) ans++;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：粥2414 (赞：1)

~~一道毒瘤题。~~
# 思路
移动棋子的方式十分抽象，直接做肯定不行，考虑转换。

发现每次移动相当于把一个棋子，与连续的棋子块前的一个空格交换位置，于是考虑能否以空格的角度解决问题。（空格是指没有棋子的格子）

于是设 $f_i$ 表示右起第 $i$ 个空格左侧连续的棋子数。手动模拟可以发现，这样每次移动就转换为了一个阶梯 NIM。原因如下：

设选择移动的棋子右侧有 $x$ 个棋子，与它交换位置的空格为 $i$，那么移动后 $f_i\gets f_i-x$，$f_{i-1}\gets f_{i-1}+x$。

但是本题还有一点不同，胜利的条件是把棋子移动到最后一个格子，这显然不利于处理，考虑转换。

首先当有棋子在 $m-1$ 处时，先手必胜，特判即可。

然后对于其他情况，双方一定不会将棋子移动到 $m-1$ 处，除非无子可移。发现与普通阶梯 NIM 有相似之处。

于是设 $m-1$ 处的空格为第 $0$ 阶梯，因为最多移到这里。然后就是普通的阶梯 NIM 了。

注意到 $2\le m\le 10^9$，直接存不下，由于我们统计答案只考虑初始的情况，所以只需要存初始不为 $0$ 的数据即可。

然后考虑如何计算答案。

题目中对于 winning 操作的描述有歧义，事实上统计的是第一步的必胜走法有多少种。

首先对于有棋子在 $m-1$ 处的特殊情况，只要统计这个棋子块有多少个即可。

然后考虑一般情况。

以下的“位”指阶梯位。

设初始时奇数位的异或和为 $sum$。

当第一次移动奇数位时，设移动前后此处的棋子数分别为 $old$、$new$。显然有 $new<old$。新的异或和为 $sum\oplus old\oplus new$。若此操作合法，那么新异或和必须为 $0$，可得 $new=sum\oplus old$。检验是否小于 $old$ 即可。

当第一次移动偶数位时，设下一位移动前后地棋子数分别为 $old$、$new$，当前位的棋子数为 $x$。显然有 $old<new\le old+x$，同理可得 $new=sum\oplus old$。检验即可。

注意由于没人会移动第 $0$ 位的棋子，所以不考虑它。

然后就可以愉快地 AC 啦！
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
inline ll read() {
	int x = 0, f = 1;
	char ch;
	while (((ch = getchar()) < 48 || ch > 57)&&ch!=EOF)if (ch == '-')f = -1;
	while (ch >= 48 && ch <= 57)x = x * 10 + ch - 48, ch = getchar();
	return x * f;
}
char __sta[1009], __len;
inline void write(ll x, bool bo) {
	if (x < 0)putchar('-'), x = -x;
	do __sta[++__len] = x % 10 + 48, x /= 10;
	while (x);
	while (__len)putchar(__sta[__len--]);
	putchar(bo ? '\n' : ' ');
}
const ll N=1e6+9;
ll m,n;
vector<pair<ll,ll>>a;//第几阶梯 前面连续的棋子数
ll pos[N];
ll ans;
int main(){
	m=read(),n=read();
	for(int i=1;i<=n;i++){
		pos[i]=read();
	}
	if(pos[n]==m-1){
		ans=1;
		for(int i=n-1;i>0;i--){
			if(pos[i]==pos[i+1]-1)ans++;
			else break;
		}
		write(ans,1);
	}else{
		for(int i=n;i>0;i--){
			ll sum=1;
			ll p=i;
			while((pos[i-1]==pos[i]-1)&&i>1){
				sum++;i--;
			}
			a.push_back(make_pair(m-pos[p]-(n-p)-2,sum));
		}
		ll sum=0;
		for(auto i:a){
			if(i.first%2==1){
				sum^=i.second;
			}
		}
		for(int i=0;i<a.size();i++){
			if(a[i].first==0)continue;
			if(a[i].first%2==1){
				if((sum^a[i].second)<a[i].second){
					ans++;
				}
			}else{
				ll pre=0;
				if(i>0&&a[i-1].first==a[i].first-1)pre=a[i-1].second;
				if((sum^pre)>pre&&(sum^pre)<=a[i].second+pre)ans++;
			}
		}
		write(ans,1);
//		for(int i=0;i<a.size();i++){
//			cout<<a[i].first<<' '<<a[i].second<<endl;
//		}
//		cout<<sum;
	}
	return 0;
}
```

---

## 作者：huangrenheluogu (赞：1)

非常有趣的一道题。

感觉难度就是把这道题转化为博弈论的模型，后面的部分就是套个代码的套路了。

但是上面这个最难的部分我是参考 [Error_Eric](https://www.luogu.com.cn/user/217300) 的[题解](https://www.luogu.com.cn/blog/iun/solution-p8382)的，可以说放弃了思考的机会，有点可惜。

想继续思考本题的请及时点出。

--------------------------------------------------------

首先，当你把一个棋子移到 $m-1$ 的位置时，这是一个必败状态，所以这两个人肯定会最后进行这个操作。

如果开始有棋子在 $m-1$ 处，那么先手必胜，特判计算方案即可。下面着重讨论 $\forall i\in [1,n],a_i\le m-2$ 的情况。

按照 [Error_Eric](https://www.luogu.com.cn/user/217300) 的设置 $f$ 的方法，我们可以将 $f_i$ 定义为在 $m-2$（含）左边的第 $i$ 个空格连续棋子的个数。特别地，如果 $m-2$ 有棋子，那么这是在第 $0$ 的空格之后。

比如：`1 0 1 1 1 0 1 1 1 1 0 0`（$0$ 和 $1$ 分别代表没有/有棋子），$m=12$，$m-2$ 格及前面总共有 $2$ 个空格，那么，$f_0=4,f_1=3,f_2=1$。

这样，应该可以理解 $f$ 数组的定义了。

接下来看看博弈的过程。

![](https://cdn.luogu.com.cn/upload/image_hosting/q7lis79r.png)

上图中，$f_i=n$，$f_{i-1}$ 不一定等于 $0$，但图幅原因，图上看 $f_{i-1}=0$，分析的时候认为 $f_{i-1}>0$。

接下来，我们把从右往左数第 $p(1\le p\le n)$ 个进行一次操作。

![](https://cdn.luogu.com.cn/upload/image_hosting/aixib01r.png)

发现，$f_i=n-p,f_{i-1}\leftarrow f_{i-1}+p$。

说明一次操作可以进行这样：

$1\le p\le f_i,f_i\leftarrow f_i-p,f_{i-1}\leftarrow f_{i-1}+p$。

输的条件是不能移动。

一个显然的阶梯博弈问题。

-------------------------------

下面简单讲解一下阶梯博弈。

阶梯问题是有 $k(=m-2)$ 级阶梯，每次可以从阶梯上取任意多的石子，放到下一级阶梯中，其中不能对第 $0$ 层操作。不能操作的人输。

套路的做法是，对奇数层求数量求异或和，即可。【因为 $x$ 个石头，每次取 $1\sim x$ 块石头，不能取得人输】这个游戏 $SG_x=x$，这个在这里就不证明了，如果不会的先学习博弈论的基本知识。

为什么上面的做法是正确的？

如果全在 $0$，显然输。

如果先手移动奇数层到偶数层，相当于丢弃石子；如果从偶数层移动到奇数层，后手可以模仿动作使得奇数层上石子数量不变。

所以上面结论可以理解为正确的。

-----------------------------------------

上面的东西看不懂没关系，就记一个结论好了。

注意这里 $m\le10^9$，如果直接枚举太大了，所以考虑枚举不为 $0$ 的部分就可以了。

维护一个结构体，包含编号（$id$）和 $f_{id}$。显然，只需要维护 $f_{id}\ne 0$ 的部分（我还维护了 $id=0$）。

接下来我们看统计方案总数。

首先，求出了整个游戏的 Nim 和 $sum$，如果 $sum=0$，那么显然先手必败，输出 $0$，下面讨论 $sum>0$ 的情况。

对于奇数层的，必胜策略指可以取出 $p$ 个数使得 $sum=0$。记这一层的 $f_{id}=val$，那么去掉这一层之外异或和就是  $sum\operatorname{xor}val$，为了让 $sum'=0$，需要 $sum\operatorname{xor}val\le val$。

对于偶数层，取出前一个位置的 $f$ 值叫做 $las$，所以，去掉上一个值的 $sum\operatorname{xor}las$ 应该在 $[las,las+val]$ 之间就可以进行必胜策略。

代码如下。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5;
int n, m, a[N], k, sum, ans, len, nn;
struct node{
	int id, val;
}tmp;
vector<node>f;
int main(){
	scanf("%d%d", &m, &n);
	for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
	if(a[n] == m - 1){
		k = n - 1;
		while(a[k] == a[k + 1] - 1 && k) k--;
		printf("%d\n", n - k);
		return 0;
	}
	if(n == 1){
        puts((m - a[1]) & 1 ? "1" : "0");
        return 0;
	}
	nn = n;
	tmp.id = 0, tmp.val = 0;
	if(a[n] < m - 2){
        f.push_back(tmp);
        tmp.val = 1, tmp.id = m - 2 - a[n];
	}
	else a[++n] = m - 1;
	for(int i = n - 1; i >= 1; i--){
		if(a[i + 1] > a[i] + 1){
			f.push_back(tmp);
			tmp.id = (m - 2 - a[i]) - (nn - i);
			tmp.val = 1;
		}
		else tmp.val++;
	}
	f.push_back(tmp);
	for(auto x : f){
		if(x.id & 1) sum ^= x.val;
	}
//	for(auto x : f) printf("%d %d\n", x.id, x.val);puts("");
	if(!sum){
		puts("0");
		return 0;
	}
//	puts("winner");
	len = f.size();
    for(int i = 1; i < len; i++){
        #define x f[i]
        if(x.id & 1){
            if((sum ^ x.val) <= x.val) ans++;
        }
        else{
            int las;
            if(f[i - 1].id == x.id - 1) las = f[i - 1].val;
            else las = 0;
            sum ^= las;
//            printf("%d in [%d, %d] ?\n", sum, las, las + f[i].val);
            if(sum <= las + x.val && sum >= las) ans++;
            sum ^= las;
        }
//        printf("%d %d\n", i, ans);
        #undef x
    }
    printf("%d\n", ans);
	return 0;
}
```

---

## 作者：splendore (赞：1)

### 思路

将 $a_i$ 变成原 $a_i$ 离 $m-1$ 所隔的空格数，我们就将此题转化成了阶梯博弈模型，直接套上模板即可。

不过要注意：不止奇数格需要计算，偶数格也要考虑。

代码如下：
```
#include<cstdio>
#include<algorithm>
using namespace std;
constexpr int N=1000005;
int a[N],f[N],s[N];
int main(){
	int m,n;scanf("%d%d",&m,&n);
	for(int i=1;i<=n;++i)scanf("%d",&a[i]);
	int cnt=0,len=0;
	for(int i=n;i>=1;--i){
		a[i]=m-2-a[i]-(n-i);
		if(a[i]==-1)++cnt;
		else if(a[i]){
			if(f[len]!=a[i])f[++len]=a[i],s[len]=1;
			else ++s[len];
		}
	}
	if(cnt)return printf("%d\n",cnt),0;
	int res=0,ans=0;
	for(int i=1;i<=len;++i)
		if(f[i]&1)res^=s[i];
	if(!res)return puts("0"),0;
	for(int i=1;i<=len;++i){
		if(f[i]&1){
			if((res^s[i])<=s[i])++ans;
		}
		else{
			if(f[i]-1!=f[i-1]){
				if(s[i]>=res)++ans;
			}
			else{
				int t=(res^s[i-1])-s[i-1];
				if(t>0&&t<=s[i])++ans;
			}
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Rain_chr (赞：0)

如果不看题解，很难发现这个问题能够被转换成阶梯博弈。

题目中给出的博弈并非公平组合游戏，因为胜负条件不是“无法操作的人输”而是“第一个占据最后一个格子的人赢”。

但是很多博弈论的题目都可以通过简单转化变成公平组合游戏，这题也不例外。我们发现如果第 $m-1$ 个格子初始时有棋子，那么先手必胜且只能动以 $m-1$ 结尾棋子连续段；如果第 $m-1$ 个格子初始时没有棋子，那么第一个走到 $m-1$ 的人必定输，也就是在 $[1,m-2]$ 棋局组成的游戏中，只有无法移动的玩家才会走 $m-1$。换句话说，在 $[1,m-2]$ 棋局组成的游戏中**无法操作的人输**。

于是判掉 $m-1$ 初始有棋子的情况，剩下的问题等价于在 $[1,m-2]$ 的棋盘中玩公平组合游戏，移动规则相同。

在解决这一问题之前，我们先看另外一个问题：

> 在一张纸带上有若干棋子，两个玩家轮流操作，每次可以选择一个棋子移动任意步，但是棋子不能重合且相对顺序不能变，求谁会赢。

不难发现，如果我们在纸带的第 $0$ 格加入一个棋子，将棋子间的间距视为一堆石子的大小，那么一次操作相当于是把前面一堆的任意石子移动到后面一堆，这就是经典的阶梯博弈了，先手必胜当且仅当从后往前奇数堆的石子异或和不为零。

回到本题，如果我们反转状态，将有棋子的格子视为空格，没棋子的格子视为有棋子，就转化成了上面的问题。

所以如果值域很小的话，我们可以直接处理出转化后问题两个棋子之间的间距，然后获胜条件等价于阶梯博弈。

但是本题值域很大，棋子个数很多，所以需要压缩棋子。注意到：

1. 如果当前棋子连续段大小为 $1$，那么需要直接保留
2. 如果当前棋子连续段大小为偶数，那么可以视作保留两个棋子
3. 如果当前棋子连续段大小为奇数且大于 $1$，那么可以视作保留三个棋子

这是因为大小为 0 的段不对异或和产生影响可以缩掉，并且这样缩不会影响其他段的奇偶性。注意连续段大小为 $1$ 的情况要和连续段大小为奇数且大于 $1$ 的情况分开，这是因为前者移动棋子能够直接对两端的间距产生影响，而后者只对连续段一端的间距产生影响。


```cpp
a[n+1]=m-1;
for(int i=n;i;i--)
{
  if(a[i+1]==a[i]+1) SG[tot]++;
  else if(a[i+1]==a[i]+2) SG[++tot]=1;
  else if((a[i+1]-a[i]-1)&1) tot+=3,SG[tot]=1;
  else tot+=2,SG[tot]=1;
}
```


所以我们可以像上面几行代码一样压缩并处理出每一段石子的大小，求出全局奇数位异或和 $sum$，然后考虑先手的第一步操作：

1. 如果操作在奇数位 $i$ 上，那么新奇数位的大小可在 $[0,siz_i)$ 之间，所以如果 $sum\oplus siz_i\in[0,siz_i)$ 就是先手必胜操作。
2. 如果操作在偶数位 $i$ 上，那么前面奇数位的大小可在 $(siz_{i-1},siz_{i-1}+siz_{i}]$ 之间，所以如果 $sum\oplus siz_{i-1}\in(siz_{i-1},siz_{i-1}+siz_{i}]$ 就是先手必胜操作。

按照这个判断即可，整体代码如下：


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e6+10;
int a[N],SG[N],tot;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int m,n;
	cin>>m>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+1+n);
	if(a[n]==m-1) //最后一个格子被占
	{
		int p=0;
		while(p<n&&a[n-p]==m-1-p) p++;
		cout<<p;
		return 0; 
	} 
	a[n+1]=m-1;
	for(int i=n;i;i--)
	{
		if(a[i+1]==a[i]+1) SG[tot]++;
		else if(a[i+1]==a[i]+2) SG[++tot]=1;
		else if((a[i+1]-a[i]-1)&1) tot+=3,SG[tot]=1;
		else tot+=2,SG[tot]=1;
	}
	int sum=0;
	for(int i=1;i<=tot;i++) if(i&1) sum^=SG[i];
	int ans=0;
	for(int i=1;i<=tot;i++) 
	{
		if(i&1) ans+=(sum^SG[i])<SG[i];
		else ans+=SG[i-1]<(sum^SG[i-1])&&(sum^SG[i-1])<=SG[i-1]+SG[i];
	}
	cout<<ans;
	return 0;
} 
```

---


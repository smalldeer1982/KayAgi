# 「REOI-p1」回忆

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/3uztip2k.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/rsmn7uez.png)

出题人：LinkyChristian

文案：小糯米

## 题目描述

“话虽如此，我们并没有四处游走让妖精一个一个地诞生。
只是在作为素材的巨大魂体上施予咒迹，好让她们带着接近人族的体格与人格自然诞生罢了。”

黄金妖精，自出生开始即刻下早夭诅咒之“人”，若非魔物无法抵御，是本不应在这茫茫尘世之中诞生之兵器。

每当前世之回忆涌上妖精之时，便是开启一朵含苞待放之花凋零倒计时之日。妖精的记忆，是由一条射线组成，为了便于叙述，我们不妨将射线当作数轴进行处理。在她们的记忆之中，会有若干个区间，在这个区间之内的回忆，是极易受到前世回忆的侵蚀的。但是由于生物的回忆本身自是不可探视分明之物，我们只能得知它们的 $m1$ 个开始区间 $[sl_i,sr_i]$ 与 $m2$ 个结束区间$[el_j,er_j]$ 。在这个回忆之内，会逐渐的有各种前世回忆涌出，侵蚀前期的记忆，当这些易于侵蚀的记忆区间全部被侵蚀殆尽后，黄金妖精便会就此“消失”。这些前世的回忆，可以看作成 $n$ 个不重叠的子段，这些子段的起点和终点恰好在一个开始区间和一个结束区间之内。而根据回忆的性质，不同的前世回忆的起点和终点自然是在不同的开始区间和结束区间内的。

记忆犹如湍急的小河，河水汩汩，顺流而下，搅动着石块与泥沙，不断地在水面上下浮沉。在上游之时，或许巉岩乱石，自有其沉重，因而水流清澈，自在澄明；越到入海口，石块逐渐的被泥沙所代替，哪怕只是微风逐浪，也会搅动其一片浑浊，将记忆都给摆弄的纠缠不清。每一次的记忆侵蚀，就如同翻腾的浪花，也许搅动的是泥沙，又或许只是将那些巨石推动了一隅。从数值上来叙述的话，第 $i$ 个起始区间被匹配能带来 $a_i$ 的贡献，第 $i$ 个结束区间被匹配能带来 $b_i$ 的贡献。当这些贡献达到了最大值，所谓的“侵蚀殆尽”，便会发生。那么现在这些妖精想知道，这个最大值究竟是多少。

特别的，如果数据本身无解，请输出 $-1$。


------------


简明题意：

给出 $m1$ 个开始区间 $[sl_i,sr_i]$ ，以及 $m2$ 个结束区间$[el_j,er_j]$ 。在数轴上选取不重叠的 $n$ 个子段，使得每个子段的起点和终点分别在一个开始区间和一个结束区间内。不同的子段的起点和终点需要在不同的开始区间和结束区间内。第 $i$ 个起始区间被匹配能带来 $a_i$ 的贡献，第 $i$ 个结束区间被匹配能带来 $b_i$ 的贡献。总贡献为选出的子段长度之和加上区间被匹配带来的贡献。求能最大总贡献是多少。

注意，将一个子段 $[l,r]$ 的长度定义为 $r-l$ ，这里的两个子段“重叠”定义为存在一个长度 > 0 的区间被同时包含在两个子段之内。

无解输出 $-1$。


## 说明/提示

对于第一组样例，将起始区间 $[1,3]$ 与结束区间 $[4,5]$ 匹配，选取子段 $[1,5]$ 长度为 $5-1=4$，再将起始区间 $[7,8]$ 与结束区间 $[9,10]$ 匹配，选取子段 $[7,10]$ 长度为 $10-7=3$ ，选取总长度为 $4+3=7$ ,满足起始区间与结束区间存在 $n$ 个匹配，且选取的子段没有重合，总贡献最大。  
对于第二组样例，分别将 $[1,2]$ 与 $[9,10]$ ，$[3,5]$ 与 $[5,7]$ 匹配，选取子段 $[1,10]$ 和 $[5,5]$。   
对于第三组样例，分别将 $[1,2]$ 与 $[3,10]$ ，$[4,5]$ 与 $[7,7]$ 匹配，选取子段 $[1,5]$ 和 $[5,7]$。   
**subtask1:** 对于 $15\%$ 的数据，$n<=5,m1,m2<=10$。  
**subtask2:** 对于 $100\%$ 的数据，$n,m1,m2<=100$ ，题目中所有数据 $\le 10^3$。  

## 样例 #1

### 输入

```
2 2 2
1 3 7 8
4 5 9 10
0 0
0 0```

### 输出

```
7```

## 样例 #2

### 输入

```
2 3 3
1 2 3 5 100 200
5 7 9 10 400 500
1000 1000 0
1000 1000 0```

### 输出

```
4009```

## 样例 #3

### 输入

```
2 2 2
1 2 4 5
7 7 3 10
2 1
3 2```

### 输出

```
14```

## 样例 #4

### 输入

```
2 2 2
1 2 4 5
6 7 8 9
12 33
23 1```

### 输出

```
-1```

# 题解

## 作者：LinkyChristian (赞：11)

把区间离散一下，然后给每个开始区间建一个点，向每个开始节点连边。结束区间同理，费用流一下，做完了。

---

## 作者：bsTiat (赞：5)

# D

简要题意：给出 $m1$ 个开始区间 $[sl_i,sr_i]$，以及 $m2$ 个结束区间 $[el_j,er_j]$。在数轴上选取不重叠的 $n$ 个子段，使得每个子段的起点和终点分别在一个开始区间和一个结束区间内。不同的子段的起点和终点需要在不同的开始区间和结束区间内。第 $i$ 个起始区间被匹配能带来 $a_i$ 的贡献，第 $i$ 个结束区间被匹配能带来  $b_i$ 的贡献。总贡献为选出的子段长度之和加上区间被匹配带来的贡献。求能最大总贡献是多少，无解输出 $-1$。

这种题目看起来好像有贪心策略，但是感觉很复杂，自然想到网络流。

最小费用最大流。

首先离散化一下。

- 超级源点向起点连边，流量为 $ n $。
- 起点向每个开始区间连边。
- 每个开始区间向数轴上对应的点连边，流量为 $1$，费用为 $ -a_i $。
- 数轴上每个点向右边紧挨着的点连边，流量为 $1$，费用为距离的相反数。
- 每个结束区间的对应点向结束区间连边，流量为 $1$，费用为 $ -b_i $。
- 每个结束区间向汇点连边。

最后检查流量是否为 $ n $,若不为 $ n $ 说明无解。
若有解，最小费用的相反数即为答案。

一条从开始区间 $ i $  到点 $ x $ 再到点 $ y $ 最后到结束区间 $ j $ 的增广路表示一个子段。

开始区间向数轴上对应点连边和数轴上的对应点向结束区间连边，可以使用线段树优化建边。

```cpp
signed main(){
	int x,y,z,w;
	n=rd(),m1=rd(),m2=rd();
	s=0,t=N-5,ss=N-4;
	for(int i=1;i<=m1;++i){
		sl[i]=rd();sr[i]=rd();
		sid[i]=++sum;
		rev[++cnt]=sl[i];
		rev[++cnt]=sr[i];
	}
	for(int i=1;i<=m2;++i){
		el[i]=rd();er[i]=rd();
		eid[i]=++sum;
		rev[++cnt]=el[i];
		rev[++cnt]=er[i];
	}
	for(int i=1; i<=m1; i++) a[i]=rd();
	for(int i=1; i<=m2; i++) b[i]=rd();
	for(int i=1; i<=m1; i++) add(ss,sid[i],1,-a[i]);
	for(int i=1; i<=m2; i++) add(eid[i],t,1,-b[i]);
	lsh();
	for(int i=1;i<=len;++i)
		num_id[i]=++sum;
	for(int i=1;i<len;++i)
		add(num_id[i],num_id[i+1],1,rev[i]-rev[i+1]);
	build1(1,1,len);
	build2(1,1,len);
	for(int i=1;i<=m1;++i) change1(1,sl[i],sr[i],sid[i]);
	for(int i=1;i<=m2;++i) change2(1,el[i],er[i],eid[i]);
	add(s,ss,n,0);
	mcmf();
	if(maxflow!=n) printf("-1");
	else printf("%lld",-mincost);
	return 0;
}
```




---

## 作者：Nygglatho (赞：1)

考虑：

- 源点向每个开始区间 $i$ 连边，容量为 $1$，费用为 $a_i$。
- 每个开始区间 $i$ 向数轴上对应在区间 $[sl_i,sr_i]$ 的点连边，容量为 $1$，费用为 $0$。
- 数轴上的 $i$ 向 $i+1$ 连边，容量为 $1$，费用为 $1$。
- 数轴上每个在区间 $[el_j,er_j]$ 的点向对应结束区间 $j$ 连边，容量为 $1$，费用为 $0$。

- 每个结束区间 $j$ 向汇点连边，容量为 $1$，费用为 $b_j$。

建出来的网络流模型应该是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/gg2m9b5m.png)

这样建图，一个开始区间 $i$ 和结束区间 $j$ 的匹配可被看作是源点到开始区间 $i$ 对应点，再到数轴对应点，再到结束区间 $j$ 对应点最后到汇点的增广路，其对答案贡献即为该增广路费用和。由于开始区间 $i$，结束区间 $j$ 的容量均为 $1$，因此区间不会重复匹配。同样的，数轴上的容量也为 $1$，所以子段不会重复覆盖一个数轴上区间。

跑最大费用最大流（把费用取相反数然后按照最小费用最大流做），复杂度 $O(V\cdot E\cdot f)$，其中 $V,E$ 是 $10^3$ 级别的，应该比较难卡过去。

令「关键点」集合 $S=\{sl_i\mid 1\le i\le m_1\}\cup \{sr_i\mid 1\le i\le m_1\}\cup \{el_i\mid 1\le i\le m_2\}\cup \{er_i\mid 1\le i\le m_2\}$，一个直观的贪心性质就是子段左右端点 $S$ 中的点是最优的。

证明就是如果左端点选择了不属于 $S$ 的点 $l$，且 $l$ 到其左侧最近属于 $S$ 的点 $t$ 的线段上没有其他的子段左右端点，则 $l\gets t$ 是合法的，并且对于答案是更优的，只会增加了多覆盖的一段的长度的贡献。

如果 $l$ 到其左侧最近属于 $S$ 的点 $t$ 的线段上有其他的子段左右端点 $r$，则 $l\gets t,r\gets t$ 是合法的，并且因为原本 $r\sim l$ 的子段没有被覆盖现在被覆盖了，对于答案是不劣的。

右端点同理。

所以数轴上只需要保留 $\in S$ 的点，$V,E$ 降到了 $300$ 的级别，就可以过了。

```cpp
struct Edge {
    int to, nxt, f; ll c;
} e[int (2e5) + 7];

void Addedge (int u, int v, int f, ll c) {
    ++ cnt;
    e[cnt].to = v, e[cnt].nxt = hd[u], e[cnt].f = f, e[cnt].c = c;

    hd[u] = cnt;
}

namespace SSP {
    int pre[N], vis[N];

    ll dis[N], f[N];

    int ans; ll cst;

    void Update () {
        ans += f[t], cst += dis[t] * f[t];
        int now = t;
        while (now != s) {
            int _ = pre[now];
            e[_].f -= f[t], e[_ ^ 1].f += f[t];
            now = e[_ ^ 1].to;
        }
    }
    
    int BF () {
        queue <int> q;

        q.push (s);

        F (i, 0, len) dis[rk[i]] = inf;
        F (i, 0, len) vis[rk[i]] = 0;
        dis[s] = 0ll;

        vis[s] = 1;

        f[s] = inf;

        while (! q.empty ()) {
            int u = q.front (); q.pop ();
            vis[u] = 0;
            for (int i = hd[u]; i != -1; i = e[i].nxt) {
                int v = e[i].to;
                ll fl = e[i].f, c = e[i].c;
                if (fl > 0 && c + dis[u] < dis[v]) {
                    dis[v] = c + dis[u];
                    f[v] = min (f[u], fl);
                    pre[v] = i;
                    if (! vis[v]) {
                        vis[v] = 1;
                        q.push (v);
                    }
                }
            }
        }

        return (dis[t] != inf);
    }

    void EK () {
        while (BF ()) {
            Update ();
        }
    }
}

#define AE(u,v,f,c) Addedge (u, v, f, c); Addedge (v, u, 0, -(c));

int main() {
    IOS
    cin >> n >> m1 >> m2;
    len = 2; rk[0] = s, rk[1] = t, rk[2] = _s;
    F (i, 0, N - 1) hd[i] = -1;
    F (i, 1, m1) cin >> sl[i] >> sr[i];
    F (i, 1, m2) cin >> el[i] >> er[i];

    F (i, 1, m1) qwq[++ _n] = sl[i]; F (i, 1, m1) qwq[++ _n] = sr[i];
    F (i, 1, m2) qwq[++ _n] = el[i]; F (i, 1, m2) qwq[++ _n] = er[i];

    sort (qwq + 1, qwq + _n + 1);

    F (i, 1, _n) mp[qwq[i]] = 1;

    F (i, 1, m1) cin >> a[i]; F (i, 1, m2) cin >> b[i];

    AE (s, _s, n, 0);

    F (i, 1, m1) {
        -- pos;
        AE (_s, pos, 1, -a[i]);
        rk[++ len] = pos;

        F (j, sl[i], sr[i]) 
            if (mp[j]) {AE (pos, j, 1, 0);}
    }

    F (i, 1, m2) {
        -- pos;
        AE (pos, t, 1, -b[i]);
        rk[++ len] = pos;
        F (j, el[i], er[i]) 
            if (mp[j]) {AE (j, pos, 1, 0);}
    }

    F (i, 1, _n) rk[++ len] = qwq[i];

    F (i, 1, _n - 1) {
        AE (qwq[i], qwq[i + 1], 1, qwq[i] - qwq[i + 1]);
    }

    SSP :: EK ();
    if (SSP :: ans != n) {
        cout << -1 << '\n'; return 0;
    } else {
        cout << - SSP::cst << '\n'; return 0;
    }
}
```

---


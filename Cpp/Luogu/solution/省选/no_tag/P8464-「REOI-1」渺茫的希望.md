# 「REOI-1」渺茫的希望

## 题目背景

威廉在与妖精们相处的日子里，留下了不少幸福的记忆。

## 题目描述

其中有一件令威廉记忆颇深的事情，便是活泼的少女们会时常的“抓住”威廉，让他来与她们一起读书。每逢此时，威廉总要开玩笑说“我脑筋超棒的哦，只要是五百年以上的古书尽管找我念”云云。但一来二去终究还是拗不过少女们的请求，半推半就的讲述一些以前的故事。长此以往，威廉在讲故事之余，会间或的用那些五百年以前的文字来和少女们玩一些“文字游戏”，游戏的规则如下：

威廉会给出一串由小写英文字母组成的字符串 $S$ ，其中每一个古文字便是由它的子串构成——如果我们说两个古文字不同，那么当且仅当这两个子串长度不同或长度相同且有任意一位不同——当两个不同的古文字拼凑在一起组成一个词语时，其音律、词义等各方面也会有所不同，于是威廉为了方便，就定义了一个“意境值”来衡量拼凑成的词语的质量。意境值的计算公式便是这两个本质不同子串在 $S$ 中出现的次数之和加上这两个本质不同子串的最长公共前缀的长度。

而当少女们把所有这些古文字拼凑成了一个句子后，威廉惊讶的发现，这个句子可以视作为任意两个古文字连边形成的完全图的最小生成树。他于是一鼓作气，推理出了这个句子的意境值的公式——这些最小生成树（因为最小生成树可能不唯一）的边权和。

其中，两个古文字的边权与她们组成的词语的意境值在数值上相等。

现在，威廉又在和少女们玩文字游戏了，威廉现在给出了一个字符串 $S$ ，但由于这是他临时起意写出的，他也不知道如果将它拼凑成一个句子，意境值究竟是多少——于是乎，威廉将求助的目光投向了你。

----

简要题意：

给定一个由小写英文字母组成的字符串 $S$ ，设在两个本质不同子串之间连边的权值为两个子串在 $S$ 中出现的次数之和加上这两个子串的最长公共前缀的长度，求对所有本质不同子串做最小生成树的边权之和（不含空串）。

## 说明/提示

#### 样例解释 #1
![](https://cdn.luogu.com.cn/upload/image_hosting/fqjg81g9.png)

如图所示为一种最小生成树，边权和为 $15$。


#### 数据范围
对于 $10\%$ 的数据，$|S|\le 100$。  
对于 $30\%$ 的数据，$|S|\le 1000$。  
对于 $100\%$ 的数据，$1\le|S|\le 10^5$。  

## 样例 #1

### 输入

```
4
abab```

### 输出

```
15```

# 题解

## 作者：LinkyChristian (赞：9)

一道题面十分具有欺骗性的题，至今为止已有数个验题人被这题的题面吓到以为是道字符串重工业题。

事实上直接构造即可，我们设 $s_i$ 为字符 $i$ 在字符串 $S$ 中从左往右第一个出现的位置，将以这个位置开头的后缀称作 $base_i$ 。那么 $base_i$ 出现次数一定为 $1$ 。我们随便找一个字符 $i$ ，从 $base_i$ 向所有不以 $i$ 开头的子串连边。然后再找另一个字符 $j$ ，从 $base_j$ 向所有以 $i$ 开头的除了 $base_i$ 以外的子串连边。

设 $S$ 一共有 $p$ 个本质不同子串，我们来计算一下这样构造的代价：对于全部的 $p-1$ 条边，其中一端固定为 $base_i$ 或 $base_j$ ，出现次数恒定为 $1$ ，另一端中除了 $base_i$ 外每个本质不同子串都出现了一次，因此代价为 
```
(所有本质不同子串的出现次数之和-1)+(p-1)
```
考虑到所有本质不同子串出现次数之和即为 $S$ 的子串个数 $n(n+1)/2$ ，因此答案为 $n(n+1)/2+p-2$ ，用后缀数组或者后缀自动机求出 $p$ 即可。

最简单的，我们可以通过答案来证明这个解法的正确性。考虑在最小生成树中每个本质不同子串的度数至少为 $1$ ，因此每个本质不同子串的出现次数至少被计算一遍。中间的最长公共前缀的长度最短为 $0$ ，而总度数为 $2(p-1)=2p-2$ ，减去 $p$ 个本质不同子串各出现一次的度数后，剩下 $p-2$ 的度数对应的本质不同子串的出现次数至少为 $1$ 。因此最小生成树的权值至少为 $n(n+1)/2+p-2$，与我们构造的答案相符，相当于我们通过构造证明了最小生成树的最小可能权值一定可以达到 。

发现还缺了些什么。上面的构造方案要求存在两个不同的字符 $i$ 和 $j$ 。要是 $S$ 只有一种字符构成呢？事实上这种方案更好构造，最优方案即为将长度为 $n$ 的子串与其它所有子串各连一条边。权值为 $\sum_{i=1}^{n-1} 1+i+n-i+1 = (n+2)(n-1)$ 。特判一下即可。

尝试证明以上的结论。一共有 $n$ 个本质不同子串，长度为 $i$ 的子串出现次数为 $n-i+1$ 。设一条边连接的两个本质不同子串长度为 $x$ 和 $y$ ，不妨设 $x \le y$ 。那么这条边的权值为 $(n-x+1)+(n-y+1)+x=2n-y+2$ 。如果要使这条边权值最小，那么就要使 $y$ 最大，即让每个本质不同子串与长度为 $n$ 的串连边。 

标程代码使用 SAM 实现。

```cpp
#include<bits/stdc++.h> 
#define N 200010
using namespace std;

int n;
long long ans;
char s[N];

struct SAM{
	int tr[N][30],fa[N],lst,tot,len[N];
	SAM() {lst=tot=1;}
	void insert(int c) {
		int p=lst,np=++tot;
		len[np]=len[p]+1,lst=np;
		while(p&&!tr[p][c]) tr[p][c]=np,p=fa[p];
		if(!p) {fa[np]=1;return ;}
		int q=tr[p][c];
		if(len[p]+1==len[q]) {fa[np]=q;return ;}
		int nq=++tot;
		len[nq]=len[p]+1;
		fa[nq]=fa[q],fa[q]=fa[np]=nq;
		memcpy(tr[nq],tr[q],sizeof(tr[q]));
		while(p&&tr[p][c]==q) tr[p][c]=nq,p=fa[p];
	}
	int buc[N],rk[N],in[N],dis[N];
	queue<int> q;
	int topo() {
		memset(dis,0,sizeof(dis));
		for(int i=1; i<=tot; i++) 
			for(int j=0; j<26; j++) if(tr[i][j]) in[tr[i][j]]++;
		q.push(1),dis[1]=1;
		while(!q.empty()) {
			int now=q.front();q.pop(),ans+=dis[now];
			for(int i=0; i<26; i++) if(tr[now][i]) {
				dis[tr[now][i]]+=dis[now];
				if(!(--in[tr[now][i]])) q.push(tr[now][i]);
			}
		}
	}
}sam;
int read() {
	int res=0,f=1;char ch=getchar();
	while(!isdigit(ch)) f=ch=='-'?-1:1,ch=getchar();
	while(isdigit(ch)) res=res*10+ch-'0',ch=getchar();
	return f*res;
}
int flag=1;
int main()
{
	scanf("%d%s",&n,s+1);
	for(int i=1; i<=n; i++) {
		sam.insert(s[i]-'a');
		if(s[i]!=s[1]) flag=0;
	}
	if(flag==1) {printf("%lld",1ll*(n+2)*(n-1));return 0;}
	sam.topo();
	printf("%lld",1ll*n*(n+1)/2+ans-3);
}
```


---

## 作者：EnofTeiPeople (赞：2)

第一次月赛场切紫题。

既然是最小生成树，那么每一个点都要有边相连。

不妨设字符串为 $aa...ab...$，$a,b$ 表示两个不同的字符。

这时，所有不以 $a$ 开头的字符串都可以和全串连边，其余可以与 $b...$ 这个子串（除去前缀 $a$）连边，这样连边的 $lcp$ 均为 $1$，另一个字符串的出现次数均为 $1$ 是最优策略。

于是，答案为本质不同子串数减一加总子串数减一，用后缀数组即可，最坏 $O(n)$，这里使用暴力归并倍增，$O(n\log_2^2n)$。

赛时交一发，只有八十分。

为什么？发现有一种特殊情况，即 $a...a$（全串同字符）。考虑长度为 $x,y$ 的字串边权为 $n-x+1+n-y+1+\min\{x,y\}$，发现它最小为 $n-x+2+x=n+2$（即 $y=n$ 时），故答案为 $(n-1)(n+2)$。

所以，直接输出 $(n-1)(n+2)$ 有二十分。

好了，这题做完了：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+1025,M=998244353;
using ll=long long;
namespace fast_rd{
	const int R=800224;
	char buf[R+5],c;
	int it,ed,f;
#define gc (it==ed&&(ed=(it=0)+fread(buf,1,R,stdin),it==ed)?EOF:buf[it++])
	template<typename _Tp>
	inline void read(_Tp &x){
		for(f=0,c=gc;c<48;c=gc)if(c=='-')f=!f;
		for(x=0;c>47;x=x*10+(48^c),c=gc);if(f)x=-x;
	}
	template<typename _Tp,typename..._tps>
	inline void read(_Tp &x,_tps&...y){
		read(x),read(y...);
	}
};
using fast_rd::read;
inline void File(){
#ifndef ONLINE_JUDGE
	freopen("a.in","r",stdin);
	freopen("a.out","w",stdout);
#endif
}
char st[N];
int n,lp[N],sa[N],nw[N],rk[N],ct[N];
ll ans;
using Tp=pair<int,int>;
Tp ps[N];
int main(){File();
	int i,k,fl=0;scanf("%d%s",&n,st+1);
	for(i=1;i<=n;++i)if(st[i]!=st[1])fl=1;
	if(!fl){
		ans=ll(n+2)*(n-1);
		printf("%lld\n",ans);
		return 0;
	}
	for(i=1;i<=n;++i)rk[i]=st[i],sa[i]=i;
	for(k=1;fl;k<<=1){
		for(i=1;i<=n;++i)ps[i]=Tp(rk[i],i+k>n?0:rk[i+k]);
		stable_sort(sa+1,sa+n+1,[&](int x,int y){return ps[x]<ps[y];});
		for(i=1,fl=0;i<=n;++i)
			if(ps[sa[i]]==ps[sa[i-1]])rk[sa[i]]=rk[sa[i-1]],fl=1;
			else rk[sa[i]]=rk[sa[i-1]]+1;
	}
	for(i=1,k=0;i<=n;++i){
		if(rk[i]==1)continue;if(k)--k;
		while(st[i+k]==st[sa[rk[i]-1]+k])++k;
		lp[rk[i]]=k;
	}
	for(i=1;i<=n;++i)
		ans+=n-sa[i]+1-lp[i];
	ans+=(ll(n+1)*n)>>1,ans-=2;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：liujy_ (赞：1)

看起来很吓人，构造题的一种方法，直接考虑下界，再看能否构造出通解。  
认为比较顺的想法是先从特殊情况入手，我是先想全相等怎么做。那么一共有 $n$ 个本质不同串，对于一对长度分别为 $x,y$ 的串连边的代价是 $\min(x,y)+n-x+1+n-y+1=-\max(x,y)+2\times n+2$。那么要让代价最小肯定是全连到长度为 $n$ 的串上，这样子的总和就是 $(n-1)(n+2)$。   
然后继续考虑有不同的字符的情况。首先一个基本的 $\frac{n(n+1)}{2}$ 肯定不能省。剩下的我们肯定希望尽量能连一个只出现过一次并且和我的 LCP 长度为 $0$ 的串上。设一共有 $m$ 个本质不同子串，如果都可以做到的话总的代价就是 $\frac{n(n+1)}{2}+m-2$。因为每一条边都会多产生 $1$ 的代价，但是每一个串可以选择一条边把他的出现次数记录到前面的基本的情况里。  
想到这一步构造应该就顺理成章了。首先完整的串肯定只出现过一次，所有字符与 $S_1$ 不同的串都可以连到他。剩下找到第一个字符与开头第一个字符不同的位置 $p$，显然从 $p$ 开始的后缀一定也只出现过一次，那把开头与 $S_1$ 相等的都连过来就可以了。

---

## 作者：是青白呀 (赞：0)

考虑直接对最优解进行构造。

首先考虑答案的下界：对于每个本质不同的子串，它都至少要贡献其出现次数的权值，这部分的总和即为 $\frac{n(n+1)}2$。最优情况下，他一定连向和自己的 $lcp=0$，且出现次数为 $1$ 的子串。不妨设本质不同的子串个数为 $t$，则下界是 $\frac{n(n+1)}2+t-2$。

对于 $S$ 中至少存在两个不同字符的平凡情况，我们可以构造出下界。

我们找到首个与 $S_1$ 不同的字符 $S_x$。我们取出串 $[1,n]$ 和 $[x,n]$，并在这两个串之间连边。不难发现，这两个串在 $S$ 中都只出现了 $1$ 次。因此，这条边的权值为 $2$。

对于其他的本质不同的子串，若它的首个字符与 $S_1$ 相同，则将它向 $S_x$ 连边；否则向 $S_1$ 连边，这样每条边两端的串的 $lcp$ 均为 $0$，这部分的总贡献为 $\frac{n(n+1)}2-2+t-2$。因此总贡献达到了下界，是最优的。

$S$ 串全部相等的情况下，恰有 $n$ 个长度不同的本质不同串。此时，我们将所有串都向 $S$ 连边，这样的答案是 $\sum_{i=2}^n i+n-1+\sum_{i=1}^{n-1}i$。

这样做最优的原因是：假设我们存在一条边 $(x,y)$ 满足 $x<y<n$，表示它连接了长度为 $x$ 的子串和长度为 $y$ 的串，此时的贡献为 $n-x+1+n-y+1+x=2n-y+2$。断开它之后，根据连通情况可选择加边 $(x,n)$ 或 $(y,n)$，连接 $x,n$ 的贡献为 $n-x+1+1+x=n+2<2n-y+2$；连接 $y,n$ 的贡献为 $n-y+1+1+y=n+2<2n-y+2$，修改后均更优。因此全部向 $n$ 连边是最优的。

于是我们只需要求出 $S$ 中本质不同子串的数目 $t$ 即可。可以使用 SA，有 $t=\frac{n(n+1)}2-\sum_{i=2}^n ht_i$。时间复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define ls(x) (x<<1)
#define rs(x) ((x<<1)|1)
#define mp make_pair
#define sec second
#define fir first
#define pii pair<int,int>
#define lowbit(i) i&-i
#define int long long 
using namespace std;
typedef long long ll;
const int N=2e5+5,M=105,inf=1e9+7,mo=998244353;
void read(int &p){
	int x=0,w=1;
	char ch=0;
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
int n;
char s[N];
int sa[N],tp[N],rk[N],ht[N],tax[N];
bool cmps(int x,int y){
	return rk[x]<rk[y];
} 
void qsort(){
	int upp=max(n,26ll);
	rep(i,0,upp)
	    tax[i]=0;
	rep(i,1,n)
	    tax[rk[i]]++;
	rep(i,1,upp)
	    tax[i]+=tax[i-1];
	repp(i,n,1)
	    sa[tax[rk[tp[i]]]--]=tp[i];
}
void sa_sort(){
	rep(i,1,n)
	    rk[i]=s[i]-'a'+1,sa[i]=i;
	sort(sa+1,sa+n+1,cmps);
	for(int w=1;w;w*=2){
		int cnt=0;
		rep(i,n-w+1,n)
		    tp[++cnt]=i;
		rep(i,1,n)
		    if(sa[i]-w>=1)tp[++cnt]=sa[i]-w;
		qsort();
		memcpy(tp,rk,sizeof(rk));
		cnt=1,rk[sa[1]]=1;
		rep(i,2,n){
			if(tp[sa[i]]==tp[sa[i-1]]&&sa[i]+w<=n&&sa[i-1]+w<=n&&tp[sa[i]+w]==tp[sa[i-1]+w])rk[sa[i]]=cnt;
			else rk[sa[i]]=++cnt;
		}
		if(cnt>=n)break;
	}
}
void get_ht(){
	int len=0;
	rep(i,1,n){
		if(rk[i]==1)continue;
		if(len)len--;
		int j=sa[rk[i]-1];
		while(i+len<=n&&j+len<=n&&s[i+len]==s[j+len])
		    len++;
		ht[rk[i]]=len; 
	}
}
signed main(){
	read(n);
	scanf("%s",s+1);
	bool sme=1;
	rep(i,2,n)
	    sme&=(s[i]==s[1]);
	if(sme){
		int ans=n-1;
		rep(i,1,n-1)
		    ans+=i;
		rep(i,2,n)
		    ans+=i;
		printf("%lld\n",ans);
	    return 0;
	}
	sa_sort(),get_ht();
	int ans=n*(n+1)/2;
	rep(i,2,n)
	    ans-=ht[i];
	ans+=n*(n+1)/2-2;
	printf("%lld\n",ans);
	return 0;
}
```

---


# [NOI2022] 众数

## 题目描述

**对于一个序列，定义其众数为序列中出现次数严格大于一半的数字。注意该定义与一般的定义有出入，在本题中请以题面中给出的定义为准。**

一开始给定 $n$ 个长度不一的正整数序列，编号为 $1 \sim n$，初始序列可以为空。这 $n$ 个序列被视为存在，其他编号对应的序列视为不存在。

有 $q$ 次操作，操作有以下类型:

- $1 \ x \ y$：在 $x$ 号序列末尾插入数字 $y$。保证 $x$ 号序列存在，且 $1 \le x, y \le n + q$。
- $2 \ x$：删除 $x$ 号序列末尾的数字，保证 $x$ 号序列存在、非空，且 $1 \le x \le n + q$。
- $3 \ m \ x_1 \ x_2 \ x_m$：将 $x_1, x_2, \ldots, x_m$ 号序列顺次拼接，得到一个新序列，并询问其众数。如果不存在满足上述条件的数，则返回 $-1$。数据保证对于任意 $1 \le i \le m$，$x_i$ 是一个仍然存在的序列，$1 \le x_i \le n + q$，且拼接得到的序列非空。**注意：不保证 $\boldsymbol{x_1, \ldots, x_m}$ 互不相同，询问中的合并操作不会对后续操作产生影响。**
- $4 \ x_1 \ x_2 \ x_3$：新建一个编号为 $x_3$ 的序列，其为 $x_1$ 号序列后顺次添加 $x_2$ 号序列中数字得到的结果，然后删除 $x_1, x_2$ 对应的序列。此时序列 $x_3$ 视为存在，而序列 $x_1, x_2$ 被视为不存在，在后续操作中也不会被再次使用。保证 $1 \le x_1, x_2, x_3 \le n + q$、$x_1 \ne x_2$、序列 $x_1, x_2$ 在操作前存在、且在操作前没有序列使用过编号 $x_3$。

## 说明/提示

**【样例解释 \#1】**

第一次询问查询序列 $1$ 的众数。由于序列包含两个 $1$，超过序列长度的一半，因此众数为 $1$。

第二次询问查询序列 $2$ 的众数。由于序列只包含 $3$，因此众数为 $3$。

第三次询问询问序列 $3$ 的众数。此时序列 $3$ 为 $(3, 3, 3, 1, 1, 2)$，不存在出现次数大于 $3$ 次的数，因此输出为 $-1$。

----

**【样例解释 \#2】**

第一次询问查询序列 $1, 2, 3, 4$ 拼接后得到的序列的众数。拼接的结果为 $(1, 2, 3, 4)$，不存在出现次数大于两次的数，因此输出为 $-1$。

第四次询问查询序列 $1, 2, 3, 4$ 拼接后得到的序列的众数。拼接的结果为 $(1, 2, 2, 4, 4, 4, 4)$，众数为 $4$。

----

**【样例 \#3】**

见附件中的 `major/major3.in` 与 `major/major3.ans`。

该样例满足测试点 $1 \sim 3$ 的限制。

----

**【样例 \#4】**

见附件中的 `major/major4.in` 与 `major/major4.ans`。

该样例满足测试点 $11 \sim 12$ 的限制。

----

**【数据范围】**

对于所有测试数据，保证 $1 \le n, q, C_m, C_l \le 5 \times {10}^5$。

| $n, q$ | $C_m, C_l$ | 测试点编号 | 特殊性质 A | 特殊性质 B | 特殊性质 C |
|:-:|:-:|:-:|:-:|:-:|:-:|
| $\le 300$ | $\le 300$ | $1 \sim 3$ | 否 | 否 | 是 |
| $\le 4000$ | $\le 4000$ | $4 \sim 7$ | 否 | 否 | 是 |
| $\le {10}^5$ | $\le {10}^5$ | $8$ | 是 | 是 | 是 |
| $\le {10}^5$ | $\le {10}^5$ | $9$ | 是 | 否 | 否 |
| $\le {10}^5$ | $\le {10}^5$ | $10$ | 否 | 是 | 否 |
| $\le {10}^5$ | $\le {10}^5$ | $11 \sim 12$ | 否 | 否 | 是 |
| $\le {10}^5$ | $\le {10}^5$ | $13$ | 否 | 否 | 否 |
| $\le 5 \times {10}^5$ | $\le 5 \times {10}^5$ | $14$ | 是 | 是 | 是 |
| $\le 5 \times {10}^5$ | $\le 5 \times {10}^5$ | $15$ | 是 | 否 | 否 |
| $\le 5 \times {10}^5$ | $\le 5 \times {10}^5$ | $16$ | 否 | 是 | 否 |
| $\le 5 \times {10}^5$ | $\le 5 \times {10}^5$ | $17 \sim 18$ | 否 | 否 | 是 |
| $\le 5 \times {10}^5$ | $\le 5 \times {10}^5$ | $19 \sim 20$ | 否 | 否 | 否 |

特殊性质 A：保证 $n = 1$ 且没有操作 $4$。  
特殊性质 B：保证任意时刻任何序列中只有数字 $1$ 和 $2$。  
特殊性质 C：保证没有操作 $2$。

## 样例 #1

### 输入

```
2 8
3 1 1 2
3 3 3 3
3 1 1
3 1 2
4 2 1 3
3 1 3
2 3
3 1 3
1 3 1
3 1 3
```

### 输出

```
1
3
-1
3
-1
```

## 样例 #2

### 输入

```
4 9
1 1
1 2
1 3
1 4
3 4 1 2 3 4
1 1 2
3 2 1 2
2 3
3 3 1 2 3
1 4 4
1 4 4
1 4 4
3 4 1 2 3 4
```

### 输出

```
-1
2
2
4
```

# 题解

## 作者：MeowScore (赞：50)

UPD：同学提醒我值域是从 $0$ 开始的，但是我没注意这一点确通过了此题，出于严谨还是改了一下代码。

感觉是 day1 唯一一个我能看懂的题了（悲）。

一看就像是数据结构题。我们不妨先考虑对于单个序列的删除、插入和查询操作怎么快速实现。我们可以对这个序列开一棵权值线段树，这样就能实现快速地删除和插入了。线段树的节点维护对应值域区间内出现次数最多的值以及这个值出现的次数。查询的时候看一下这个值的出现次数是否超过序列长度一半即可。

对于多个序列呢？我们对每个序列都做上面的事情，但是序列的合并和查询十分棘手。

考虑两个序列合并。首先把两个序列对应的线段树合并起来是容易做的（线段树要动态开点），但是这还不够，我们得把这两个序列真的拼起来，而不仅仅是完成值域信息的拼接。很多人想到了用 deque 维护每个序列，然后合并的时候启发式合并，暴力地把小的序列插到大的序列中（根据题目要求决定前端还是后端插入）。但是吧，赛后已经众所周知的一点，deque 这东西的预留空间有亿点大，导致很多想到正解的选手超出空间限制。我们考虑使用链表维护。链表可以支持快速地删除末尾元素，在末尾插入元素，以及把两个链表顺次拼接。注意代码实现的时候，拼接时不一定两个序列全都非空，不注意这个可能会挂分。

然后考虑最有意思的查询。这里需要先介绍一下摩尔投票法（下文的“众数”都是题目中的定义，而不是更为常见的那个含义）。

摩尔投票法的核心思想为对拼消耗，考虑一个序列，我们每次取出两个数，如果相同就放回，不同的话就抵消，把这两个数全都删除，直到序列为空或剩一种数。如果序列空了就说明它没有众数，否则剩下的这种数就**可能**是这个序列的众数。注意被其他的数绝不可能成为答案，剩下的这个是不是答案还需要检验。经典的应用有 [P3765 总统选举](https://www.luogu.com.cn/problem/P3765)。可以用线段树维护可能的众数，然后用平衡树检查这是否是众数。

回到这个题，首先一个结论，如果有解，则最终的答案必然是至少一个被询问到的序列的众数。显然是正确的：如果一个数在任何一个序列出现的次数都不超过一半，那么把序列都拼起来自然也不会超过一半。我们称存在众数的序列为“可贡献的序列”，其余为“不可贡献的序列”。我们考虑对可贡献的序列进行摩尔投票（因为答案只有可能在这里产生），比较方便的做法是每个可贡献序列的众数先和这个序列中其余的数进行抵消，然后把每个序列经过内部抵消后的众数再拿出来进行摩尔投票。代码实现的时候维护当前答案和它出现的次数，把所有可贡献序列扫一遍不断更新答案即可。然后我们最后找到一个可能成为答案的数，再检验一遍即可，把被询问的所有序列扫一遍，在每个线段树上查这个数的出现次数然后加起来，看是不是所有序列拼接后的众数。

这里可能有人会问（包括我也有过这个疑惑）：为什么不可贡献的序列在寻找可能成为答案的数的时候可以直接忽略？如果把这些序列也加入考虑，摩尔投票的结果会产生变化吧？（即选出的数是另一个可贡献的序列的众数）

这样考虑：如果把不可贡献序列加入考虑后摩尔投票的结果发生变化，那么此次询问必然无解，由于检验操作的存在，不影响最终答案。为什么必然无解？如果只考虑可贡献序列，可能的答案为 $x$，加入不可贡献序列，可能的答案变成 $y$。这变成了最原始的摩尔投票问题，$x$ 被抛弃，$y$ 是此次询问唯一可能成为答案的数。但是 $y$ 在可贡献序列中不是众数，不可贡献序列根本没有众数，我们刚才说了，“如果有解，则最终的答案必然是至少一个被询问到的序列的众数”，所以这个 $y$ 不可能是答案，于是无解。

细节：询问时统计数字出现次数时记得开 long long；注意值域是从 $0$ 开始的。

代码：

```
#include<bits/stdc++.h>
using namespace std;
int read(){
	int ss=0,ww=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')
			ww=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		ss=ss*10+ch-'0';
		ch=getchar();
	}
	return ss*ww;
}
const int N=1000010;
int s[N],n,q;
int node;
struct ST{
	int ls;
	int rs;
	int sum;
	int dat;
}st[N*30];
int rt[N];
void add(int &root,int l,int r,int x,int k){
	if(!root)
		root=++node;
	if(l==r){
		st[root].sum+=k;
		st[root].dat=l;
		return;
	}
	int mid=(l+r)/2;
	if(mid>=x)
		add(st[root].ls,l,mid,x,k);
	else
		add(st[root].rs,mid+1,r,x,k);
	if(st[st[root].ls].sum>st[st[root].rs].sum){
		st[root].sum=st[st[root].ls].sum;
		st[root].dat=st[st[root].ls].dat;
	}
	else{
		st[root].sum=st[st[root].rs].sum;
		st[root].dat=st[st[root].rs].dat;
	}
}
ST ask(int root,int l,int r,int x){
	if(l==r)
		return st[root];
	int mid=(l+r)/2;
	if(mid>=x)
		return ask(st[root].ls,l,mid,x);
	else
		return ask(st[root].rs,mid+1,r,x);
}
void merge(int &root,int p,int q,int l,int r){
	if(!p){
		root=q;
		return;
	}
	if(!q){
		root=p;
		return;
	}
	if(!root)
		root=++node;
	if(l==r){
		st[root].sum=st[p].sum+st[q].sum;
		st[root].dat=l;
		return;
	}
	int mid=(l+r)/2;
	merge(st[root].ls,st[p].ls,st[q].ls,l,mid);
	merge(st[root].rs,st[p].rs,st[q].rs,mid+1,r);
	if(st[st[root].ls].sum>st[st[root].rs].sum){
		st[root].sum=st[st[root].ls].sum;
		st[root].dat=st[st[root].ls].dat;
	}
	else{
		st[root].sum=st[st[root].rs].sum;
		st[root].dat=st[st[root].rs].dat;
	}
}
int fst[N],lst[N],pre[N],val[N];
int id;
void push_back(int x,int y){//第 x 个序列后插入 y 
	id++;
	if(!fst[x])
		fst[x]=id;
	val[id]=y;
	pre[id]=lst[x];
	lst[x]=id;
}
int sz[N];//序列长度 
int x[N];
int main(){
	//freopen("major.in","r",stdin);
	//freopen("major.out","w",stdout);
	n=read();
	q=read();
	for(int i=1;i<=n;i++){
		int m;
		m=read();
		sz[i]=m;
		for(int j=1;j<=m;j++){
			int x;
			x=read()+1;
			push_back(i,x);
			add(rt[i],0,n+q+1,x,1);
		}
	}
	for(int i=1;i<=q;i++){
		int opt;
		opt=read();
		if(opt==1){
			int x,y;
			x=read();
			y=read()+1;
			push_back(x,y);
			add(rt[x],0,n+q+1,y,1);
			sz[x]++;
		}
		if(opt==2){
			int x;
			x=read();
			add(rt[x],0,n+q+1,val[lst[x]],-1);
			lst[x]=pre[lst[x]];
			sz[x]--;
			if(!sz[x])
				fst[x]=0;
		}
		if(opt==3){
			int m;
			m=read();
			for(int j=1;j<=m;j++)
				x[j]=read();
			pair<int,long long> nw;
			nw={0,0};
			long long tot=0;
			for(int j=1;j<=m;j++){
				tot+=sz[x[j]];
				if(st[rt[x[j]]].sum<=sz[x[j]]/2)//判断一个序列有无众数 
					continue;
				long long res=st[rt[x[j]]].sum-(sz[x[j]]-st[rt[x[j]]].sum);//该序列众数和序列中其他数进行抵消 
				if(st[rt[x[j]]].dat==nw.first){//如果这个数和当前答案相同，合并 
					nw.second+=res;
					continue;
				}
				if(nw.second==res){//恰好抵消了 
					nw={0,0};
					continue;
				}
				if(nw.second<res){//更新答案，并进行抵消 
					nw={st[rt[x[j]]].dat,res-nw.second};
					continue;
				}
				if(nw.second>res)//不更新，但是抵消一次 
					nw.second-=res;
			}
			long long ans=0;
			if(!nw.first){//全都抵消了，没有众数 
				cout<<"-1\n";
				continue;
			}
			for(int j=1;j<=m;j++)//检查的过程 
				ans+=ask(rt[x[j]],0,n+q+1,nw.first).sum;
			if(ans>tot/2)//如果合法 
				cout<<nw.first-1<<'\n';
			else
				cout<<"-1\n";
		}
		if(opt==4){
			int a,b,c;
			a=read();
			b=read();
			c=read();
			merge(rt[c],rt[a],rt[b],0,n+q+1);
			if(lst[b])
				lst[c]=lst[b];
			else
				lst[c]=lst[a];
			if(fst[a])
				fst[c]=fst[a];
			else
				fst[c]=fst[b];
			if(fst[b])
				pre[fst[b]]=lst[a];
			sz[c]=sz[a]+sz[b];
			sz[a]=sz[b]=fst[a]=fst[b]=lst[a]=lst[b]=0;
		}
	}
	return 0;
}
```

---

## 作者：SSH_automaton (赞：33)

最近 7 年最水的 D1T1。

可能是不太一样的做法。

用权值线段树维护每个数出现的次数，链表维护序列。

操作 4 即合并两棵权值线段树、两个链表，操作 2 就是删除链表尾的元素并在权值线段树上修改。

显然，如果一个序列存在绝对众数，那么它必然等于这个序列的中位数。所以操作 3 就是询问 $k$ 个序列整体的中位数，并检查这个数的出现次数。

考虑二分中位数，在 $k$ 棵线段树上分别查询前缀和，再判断出现次数，然而时间复杂度是 $O(n \log^2 n)$，可能无法通过。把二分中位数改成在 $k$ 棵线段树上二分即可做到 $O(n \log n)$。

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
const int N = 1e6 + 3;
const int SIZE = N * 21;

int n, q, m;
int a[N], siz[N], head[N], tail[N], pre[N];

inline void insert(int i, int p) {
	pre[p] = tail[i];
	tail[i] = p;
	if (!siz[i]) head[i] = p;
	++siz[i];
}

inline void erase(int i) {
	tail[i] = pre[tail[i]];
	--siz[i];
	if (!siz[i]) head[i] = 0;
}

inline void link(int i, int j, int k) {
	head[k] = siz[i] ? head[i] : head[j];
	tail[k] = siz[j] ? tail[j] : tail[i];
	siz[k] = siz[i] + siz[j];
	if (head[j]) pre[head[j]] = tail[i];
}

int rt[N], ls[SIZE], rs[SIZE], tot;
ll cnt[SIZE];

void update(int &x, int k, int v, int l = 1, int r = n + q) {
	if (!x) x = ++tot;
	cnt[x] += v;
	if (l == r) return;
	int mid = (l + r) >> 1;
	if (k <= mid) update(ls[x], k, v, l, mid);
	else update(rs[x], k, v, mid + 1, r);
}

void merge(int &x, int &y, int l = 1, int r = n + q) {
	if (!x || !y) {
		x += y;
		return;
	}
	cnt[x] += cnt[y];
	if (l == r) return;
	int mid = (l + r) >> 1;
	merge(ls[x], ls[y], l, mid);
	merge(rs[x], rs[y], mid + 1, r);
}

ll query(int x, int k, int l = 1, int r = n + q) {
	if (!x) return 0;
	if (l == r) return cnt[x];
	int mid = (l + r) >> 1;
	if (k <= mid) return query(ls[x], k, l, mid);
	return query(rs[x], k, mid + 1, r);
}

int c[N], tmp[N], len;

int search(ll k, int l = 1, int r = n + q) {
	if (l == r) return l;
	int mid = (l + r) >> 1;
	ll sum = 0;
	for (int i = 1; i <= len; ++i)
		sum += cnt[ls[tmp[i]]];
	if (sum >= k) {
		for (int i = 1; i <= len; ++i)
			tmp[i] = ls[tmp[i]];
		return search(k, l, mid);
	} else {
		for (int i = 1; i <= len; ++i)
			tmp[i] = rs[tmp[i]];
		return search(k - sum, mid + 1, r);
	}
}

int main() {
	freopen("major.in", "r", stdin);
	freopen("major.out", "w", stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> n >> q;
	for (int i = 1; i <= n; ++i) {
		int sz;
		cin >> sz;
		for (int j = 1; j <= sz; ++j) {
			int x;
			cin >> x;
			a[++m] = x;
			insert(i, m);
			update(rt[i], x, 1);
		}
	}
	for (int i = 1; i <= q; ++i) {
		int op, x, y, z;
		cin >> op;
		if (op == 1) {
			cin >> x >> y;
			a[++m] = y;
			insert(x, m);
			update(rt[x], y, 1); 
		} else if (op == 2) {
			cin >> x;
			update(rt[x], a[tail[x]], -1);
			erase(x);
		} else if (op == 3) {
			cin >> len;
			ll all = 0, sum = 0;
			for (int j = 1; j <= len; ++j) {
				cin >> c[j];
				tmp[j] = rt[c[j]];
				all += siz[c[j]];
			}
			int mid = search((all + 1) >> 1);
			for (int j = 1; j <= len; ++j)
				sum += query(rt[c[j]], mid);
			if (sum * 2 > all)
				cout << mid << '\n';
			else
				cout << "-1\n";
		} else {
			cin >> x >> y >> z;
			link(x, y, z);
			merge(rt[x], rt[y]);
			rt[z] = rt[x];
		}
	}
	return 0;
}
```


---

## 作者：xzzduang (赞：27)

## 前言

关于 deque，它死了。

## 正文

首先来看出现次数严格大于一半的众数怎么处理，其实就是经典的摩尔投票，不会的可以看看[这题](https://www.luogu.com.cn/problem/P2397)。就是考虑把两个不同的数匹配起来消掉，最后会剩下一些相同的数，如果存在一个数出现次数大于一半，那么剩下的数肯定是它（因为其他的数加起来都消不过它）。

而这个信息是支持合并的，记一下剩下的数是什么以及有多少个就好，这样也顺利解决了询问会若干序列如何合并的问题：得到每个序列摩尔投票的结果后再合并即可。

回到题目，给定若干序列，而这些序列都在动，直接的想法是用 fhq 维护。合并，插入，以及删除都是基本的操作。

现在我们通过摩尔投票得到了唯一可能成为答案的数，但这个数还需要 check 一下，需要一个数据结构查询它在各个序列中出现的次数，发现线段树合并可以满足我们的需求。

注意这题是需要开 long long 的，因为询问给出的序列编号可以重复，但我赛时没开 long long 却过了，很神必。

然后贴上赛时代码：

```cpp
#include<iostream>
#include<stdio.h>
#include<ctype.h>
#include<random>
#define N 1000005
#define fi first
#define se second
using namespace std;
inline int read(){
    int x=0,f=0;char ch=getchar();
    while(!isdigit(ch)) f|=(ch=='-'),ch=getchar();
    while(isdigit(ch)) x=x*10+(ch-'0'),ch=getchar();
    return f?-x:x;
}
int n,q,m;
inline pair<int,int> calc(pair<int,int> x,pair<int,int> y){
    if(x.fi==y.fi) return {x.fi,x.se+y.se};
    if(x.se==y.se) return {0,0};
    if(x.se>y.se) return {x.fi,x.se-y.se};
    return {y.fi,y.se-x.se};
}
struct segmentTree{
    int ls[N*60],rs[N*60],val[N*60],pool;
    void update(int &k,int l,int r,int x,int v){
        if(!k) k=++pool;
        if(l==r){
            val[k]+=v;
            return;
        }
        int mid=l+r>>1;
        if(x<=mid) update(ls[k],l,mid,x,v);
        else update(rs[k],mid+1,r,x,v);
    }
    int merge(int x,int y,int l,int r){
        if(!x || !y) return x|y;
        if(l==r){
            val[x]+=val[y];
            return x;
        }
        int mid=l+r>>1;
        ls[x]=merge(ls[x],ls[y],l,mid);
        rs[x]=merge(rs[x],rs[y],mid+1,r);
        return x;
    }
    int query(int k,int l,int r,int x){
        if(l==r) return val[k];
        int mid=l+r>>1;
        if(x<=mid) return query(ls[k],l,mid,x);
        return query(rs[k],mid+1,r,x);
    }
}T2;
mt19937 rnd(114514);
struct FHQ{
    int ls[N],rs[N],sze[N],val[N],pool,rt[N];
    pair<int,int> sum[N];
    inline void pushup(int k){
        sze[k]=sze[ls[k]]+sze[rs[k]]+1;
        sum[k]=calc(calc(sum[ls[k]],{val[k],1}),sum[rs[k]]);
    }
    void split(int k,int &x,int &y,int v){
        if(!k) return (void)(x=y=0);
        if(v>=sze[ls[k]]+1){
            x=k;
            split(rs[k],rs[x],y,v-sze[ls[k]]-1);
        }
        else{
            y=k;
            split(ls[k],x,ls[y],v);
        }
        pushup(k);
    }
    int merge(int x,int y){
        if(!x || !y) return x|y;
        if(rnd()%(sze[x]+sze[y])<sze[x]){
            rs[x]=merge(rs[x],y);
            pushup(x);return x;
        }
        else{
            ls[y]=merge(x,ls[y]);
            pushup(y);return y;
        }
    }
    inline void insert(int r,int x){
        val[++pool]=x;
        sum[pool]={x,1};
        sze[pool]=1;
        rt[r]=merge(rt[r],pool);
    }
    inline int del(int r){
        int x,y;
        split(rt[r],x,y,sze[rt[r]]-1);
        rt[r]=x;
        return val[y];
    }
}T1;
int rt[N];
inline void insert(int r,int x){
    T1.insert(r,x);
    T2.update(rt[r],0,m,x,1);
}
inline void del(int r){
    int x=T1.del(r);
    T2.update(rt[r],0,m,x,-1);
}
inline void merge(int x,int y,int z){
    rt[z]=T2.merge(rt[x],rt[y],0,m);
    T1.rt[z]=T1.merge(T1.rt[x],T1.rt[y]);
}
int tmp[500005];
int main(){
    freopen("major.in","r",stdin);
    freopen("major.out","w",stdout);
    n=read(),q=read();
    m=n+q;
    for(int i=1;i<=n;++i){
        int c=read();
        while(c--){
            int x=read();
            insert(i,x);
        }
    }
    for(int i=1;i<=q;++i){
        int op=read();
        if(op==1){
            int x=read(),y=read();
            insert(x,y);
        }
        if(op==2){
            int x=read();
            del(x);
        }
        if(op==3){
            int tot=0,c=read(),cnt=0;
            pair<int,int> res={0,0};
            for(int j=1;j<=c;++j){
                tmp[j]=read();
                res=calc(res,T1.sum[T1.rt[tmp[j]]]);
                tot+=T1.sze[T1.rt[tmp[j]]];
            }
            if(res.se==0){
                puts("-1");
                continue;
            }
            if(res.se*2>tot){
                printf("%d\n",res.fi);
                continue;
            }
            for(int j=1;j<=c;++j){
                cnt+=T2.query(rt[tmp[j]],0,m,res.fi);
                if(2*cnt>tot) break;
            }
            if(2*cnt>tot){
                printf("%d\n",res.fi);
            }
            else puts("-1");
        }
        if(op==4){
            int x=read(),y=read(),z=read();
            merge(x,y,z);
        }
    }
    return 0;
}
```



---

## 作者：louhao088 (赞：25)

提供一种好写且速度很快的 $O(n \log^2 n)$  做法。


------------


首先我们需要维护每个序列最后一个数是什么，支持插入，删除，合并两个序列，很容易想到使用链表维护，注意在连接时要判断是否为空。

然后我们可以用 set 维护每个序列的数出现个数最多的数，用 map 维护每个数出现个数。

对于插入删除操作，我们直接在 set ，map 上改即可。

对于合并操作，直接用启发式合并维护即可。据验题人说这种 $\log^2$ 做法跑的比所有 $\log $ 的线段树合并都快，实测确实很快。

对于询问，考虑分治，由于它是严格众数，所以将询问序列分成两段后，它必然是两段中一段的严格众数，不断分治下去即可。

时间复杂度 $O(n \log^2 n)$ ，空间复杂度 $O(n)$ 。



------------
代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
#define pi pair<int,int>
#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define ls (rt<<1)
#define rs (rt<<1|1)
#define mid ((l+r)>>1)
#define ll long long
const int maxn=1e6+5,M=34005;
inline int read(){
	char ch=getchar();bool f=0;int x=0;
	for(;!isdigit(ch);ch=getchar())if(ch=='-')f=1;
	for(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
	if(f==1)x=-x;return x;
}
int n,m,q,x,y,z,op,sz[maxn],fa[maxn],tot=0,b[maxn],ans;
int las[maxn],a[maxn],nex[maxn],fro[maxn];
set<pi>s[maxn];
map<int,int>g[maxn];
int find(int x){if(x==fa[x])return x;return fa[x]=find(fa[x]);}
void add(int x,int y){
	a[++tot]=y;nex[tot]=las[x];las[x]=tot;++sz[x];
	if(sz[x]==1)fro[x]=tot;
	int z=g[x][y];
	s[x].erase(mp(z,y));
	g[x][y]++;
	s[x].insert(mp(z+1,y));
}
void del(int x){
	int y=a[las[x]];las[x]=nex[las[x]];sz[x]--;
	if(!sz[x])fro[x]=0;
	int z=g[x][y];
	s[x].erase(mp(z,y));
	g[x][y]--;
	s[x].insert(mp(z-1,y));
}
void merge(int x,int y,int z){
	if(!sz[x]){fa[z]=y;return;}
	if(!sz[y]){fa[z]=x;return;}
	fro[z]=fro[x],las[z]=las[y];
	nex[fro[y]]=las[x];
	if(sz[x]>sz[y])swap(x,y);
	sz[y]+=sz[x];
	for(auto it:s[x]){
		int z=g[y][it.se];
		if(z)s[y].erase(mp(z,it.se));
		g[y][it.se]+=it.fi;
		s[y].insert(mp(z+it.fi,it.se));
	}fa[z]=y;las[y]=las[z],fro[y]=fro[z];
}
bool check(int l,int r,int x){
	ll sum=0,s=0;
	for(int i=l;i<=r;i++)
		sum+=g[b[i]][x],s+=sz[b[i]];
	if(sum*2>s)return 1;return 0;
}
int solve(int l,int r){
	if(l==r){
		if(!s[b[l]].size())return -1;
		pi x=*s[b[l]].rbegin();
		if(x.fi*2>sz[b[l]])return x.se;
		return -1;
	}
	int s1,s2,z=-1;
	s1=solve(l,mid),s2=solve(mid+1,r);
	if(s1!=-1&&check(l,r,s1))z=s1;
	else if(s2!=-1&&check(l,r,s2))z=s2;
	return z;
}
void sol(){
	m=read();
	for(int i=1;i<=m;i++)b[i]=read(),b[i]=find(b[i]);
	ans=solve(1,m);printf("%d\n",ans);
}
signed main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	n=read(),q=read();
	for(int i=1;i<=n;i++){
		m=read();fa[i]=i;
		for(int j=1;j<=m;j++)x=read(),add(i,x);
	}
	for(int i=1;i<=q;i++){
		op=read();
		if(op==1)x=read(),y=read(),x=find(x),add(x,y);
		if(op==2)x=read(),x=find(x),del(x);
		if(op==3)sol();
		if(op==4)x=read(),y=read(),z=read(),x=find(x),y=find(y),merge(x,y,z);
	}
 	return 0;
}

```




---

## 作者：HUNGRY123 (赞：23)

- 前言

  考试中开了 $10^6$ 个 `std::deque`，然后获得了 $0$ 分的好成绩。

  但是洛谷的评测机却没有 $\tt MLE$，大受震撼。

- 题意

  给定 $n$ 个集合，支持下面四种操作：

  1. 在第 $i$ 个集合尾部加入数字 $x$。

  2. 删除第 $i$ 个集合的最后一个数字。

  3. 将一些集合拼在一起，求这些集合的众数。（这里的众数指出现次数大于集合大小一半的数字）

  4. 新建一个集合 $z$ 由 $x$ 与 $y$ 拼接而成。

- 题解

  直接考虑求众数，用了一种很玄妙的方法。（因为不会摩尔投票）

  对于集合 $i$，令数字 $x$ 的权值为 $w_{i,x}=2\times cnt_{i,x}-sz_i$，其中 $cnt_{i,x}$ 表示 $x$ 在集合 $i$ 中的出现次数，$sz_i$ 表示第 $i$ 个集合的大小。

  设询问序列为 $q$，则判断 $x$ 是否为众数就变成了判断 $\sum\limits_{i=1}^m w_{q_i,x}$ 的值是否大于 $0$。

  可以发现，对于一个集合 $i$，最多有一个数字的权值大于 $0$，令这个数字为 $x$，则集合 $i$ 的权值第二大小于等于 $-w_{i,x}$。

  每次询问维护二元组 $(i,val_i)$，表示数字 $i$ 的正权值和为 $val_i$，只有 $val_i$ 最大的数字才有可能作为众数。（因为其他的数字至少减去 $val_i$）

  整个过程中，需要支持维护集合出现次数最多的数字，支持查询一个集合的最后一个元素。

  用线段树维护每个集合的元素出现次数，操作 $4$ 直接线段树合并即可；用 `std::list` 维护集合，操作 $4$ 将 `std::list` 启发式合并。（就是将小的 `std::list` 拼接到大的上面去）

  线段树合并时间复杂度 $O(n\log{n})$，`std::list` 的启发式合并时间复杂度为 $O(n\log{n})$，每次查询时间复杂度为 $O(m\log{m})$，这里的 $m$ 为每次询问的集合个数。

  [代码](https://www.luogu.com.cn/paste/rkxsqtvd)

- 后记：

  最近运气不好，写题解来转运。

---

## 作者：vectorwyx (赞：11)

D1 把我送走的题……

先考虑对于一个给定的长度为 $n$ 的序列如何求它的绝对众数。有一个随机化算法是：设定阈值 $B$，每次从序列中随机选出一个数 $x$，然后扫一遍序列求出 $x$ 的出现次数 $c$，如果 $c>\frac{n}{2}$ 那 $x$ 即为答案，否则继续随直到随机次数大于 $B$。不难看出这个算法只会在序列存在绝对众数且 $B$ 次随机都没选出绝对众数时出错。而如果这个序列存在绝对众数，每次随机至少有 $\frac{1}{2}$ 的概率选出绝对众数，所以这个算法单次的出错概率为 $2^{-B}$。

这个算法的好处在于它只需要支持很简单的操作：查询某个数的出现次数，随机访问某个序列中的元素。对于本题而言，如果没有合并操作（即 $4$ 操作）只需要对初始时给定的 $n$ 个序列依次开一个**哈希表**存储第 $i$ 个序列中 $j$ 出现了几次，再开一个栈维护进栈出栈操作。对于合并操作，不难想到采用**启发式合并**，把长度更小的序列中的每个元素暴力插入到更大的那个序列中。

注意如果 $x1$ 长度更小得把 $x1$ 的元素依次插到 $x2$ 的栈底，因此需要把栈改成**双端队列**。偷懒的话用 deque 实现即可，但你也会因此**变得不幸**，因为 deque 的**时空常数**很逆天。比如我在考场上就没注意到自己做法的巨大常数，后面的点全都 T 掉了，最后只有 65 分。还有一部分选手（我不说是谁）更加悲惨，全部 MLE，爆零了。我衷心希望这样的惨剧不要再发生在任何人身上。为了避免 deque 可以使用双栈模拟队列，大概是开两个栈，一个维护队首的出队入队，另一个维护队尾的出队入队，如果一个栈弹空了就把另一个栈从中间劈开，分成两个栈，复杂度均摊线性。

如果认为哈希表单次操作复杂度为 $O(1)$ ，最终的复杂度是 $O(m\log n+mB)$，$B$ 的级别是 $O(\log q)$。然后就是阈值 $B$ 具体如何设置的问题。本题 $q=5\times 10^5$ 的点一共有 $5$ 个，算上更小的那些测试点总询问量大概是 $3\times 10^6$ 级别。取 $B=24$ 比较合适，更小的值容易错，更大的话就又要卡常了……最后正好贴着 1s 的时限过去，还算稳定。这东西常数是真的不好，卡常卡麻了，如果您有常数更小的实现方式请务必在评论区或私信告诉我，谢谢喵QAQ

具体细节见代码，为了卡常我哈希表是手写的，但是 deque 没有动，也算是给考场上的自己一个交代吧：

```cpp
//orz qlr rk1 捧杯 
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#define pii pair<int,int>
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define mk make_pair
#define sml(x,y) (x=min(x,y))
#define big(x,y) (x=max(x,y))
#define ll long long
#define uint unsigned int
#define ull unsigned long long
#define umap unordered_map
#define db double
#define fo(i,x,y) for(int i=x;i<=y;++i)
#define go(i,x,y) for(int i=x;i>=y;--i)
#define ptc putchar
#define emp emplace
using namespace std;
using namespace __gnu_cxx;
using namespace __gnu_pbds; 
ll seed=chrono::system_clock::now().time_since_epoch().count();
mt19937 rnd(seed);
inline ll rm(ll x,ll y){return (int)(rnd()%(y-x+1ll)+x);}
inline int read(){int ch=getchar(),x=0,f=1;while(!isdigit(ch)){if(ch==(int)('-'))f=-1;ch=getchar();}while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*f;}
inline void out(int *a,int l,int r){fo(i,l,r) cout<<*(a+i)<<' ';puts("");}

bool Miller_Rabin(int x){
	for(int i=2;i*i<=x;++i) if(x%i==0) return 0;
	return 1;
}

int OI(int l,int r){
	while(1){
		int x=rm(l,r);
		if(Miller_Rabin(x)) return x;
	}
} 

const int bs=1e7,N=1e6+5,qlr=OI(bs-100000,bs),jump=OI(428,2006);
int n,q,whk[N],b[N],ti,vis[N];
ll sum[N];
pair<ll,int> mp[bs];
struct Deque_is_dead{
	deque<int> D_Cu;
	struct Hashwyx{
		#define add(x,y) (x+=y,x=x>=qlr?x-qlr:x)
		int id;
		int fin(int x){
			ll y=id*10000000ll+x;
			int now=y%qlr;
			while(mp[now].fi&&mp[now].fi!=y) add(now,jump);
			mp[now].fi=y;
			return now;
		}
		int&operator[](int x){return mp[fin(x)].se;}
	}whq_Au;
}a[N>>1];

void file(){
	freopen("major.in","r",stdin);
	freopen("major.out","w",stdout);
}

signed main(){
	//file();
	cin>>n>>q;
	fo(i,1,n){
		whk[i]=i;
		a[i].whq_Au.id=i;
		int len=read();
		while(len--){
			int x=read();
			a[i].whq_Au[x]++;
			a[i].D_Cu.pb(x);
		}
	}
	while(q--){
		int o=read();
		if(o==1){
			int x=whk[read()],y=read();
			a[x].whq_Au[y]++;
			a[x].D_Cu.pb(y);
		}else if(o==2){
			int x=whk[read()],y=a[x].D_Cu.back();
			a[x].whq_Au[y]--;
			a[x].D_Cu.pop_back();
		}else if(o==3){
			int m=read();
			fo(i,1,m) b[i]=whk[read()],sum[i]=sum[i-1]+a[b[i]].D_Cu.size();
			int B=24;
			while(B--){
				ll x=rm(1,sum[m]);
				int pos=lower_bound(sum+1,sum+1+m,x)-sum;
				int y=a[b[pos]].D_Cu[x-sum[pos-1]-1];
				ll cnt=0;
				fo(i,1,m) cnt+=a[b[i]].whq_Au[y];
				if(cnt>sum[m]/2){
					cout<<y<<'\n';
					goto H;
				} 
			}puts("-1");
			H:;
		}else{
			int x1=whk[read()];
			int x2=whk[read()];
			int x3=read(),flg=0;
			if(a[x1].D_Cu.size()<a[x2].D_Cu.size()) swap(x1,x2),flg=1;
			whk[x3]=x1;
			//for(auto i:a[x2].whq_Au) a[x1].whq_Au[i.fi]+=i.se;
			for(int i:a[x2].D_Cu){
				a[x1].whq_Au[i]++;
				if(flg) a[x1].D_Cu.push_front(i);
				else a[x1].D_Cu.push_back(i);
			}
			//a[x2].whq_Au.clear();
			a[x2].D_Cu.clear();a[x2].D_Cu.shrink_to_fit();
		}
	}
	return 0;
}
/*
-------------------------------------------------
*/
```

 

---

## 作者：yummy (赞：8)

## 缘起

NOI 刚刚结束，但是《因为疫情的不确定性》，NOI 同步赛取消，因此我很长一段时间看不到真题。

后来我请 mrsrz 帮忙复述了简要题意，然后我说瞬间就想起来某道经典题目：很小的空间限制求绝对众数。

我和 mrsrz 说“我怀疑这题混进提高组模拟赛可能都分不出来”，然后她表示相当惊讶，后来我才发现，我做法比她少一个 log。

所以为啥我今天才写这道题呢？
- 一方面，洛谷当时还在讨论是否公开 NOI 题目。
- 另一方面，我这半个月都在练习数据结构，因此我想把知识点搭配一下，口味更加自然。

但是，今天我想了想，NOI 题，给点面子。

**做这题之前，请确保您会线段树合并。**

## 前置知识：二进制拆位法求绝对众数

这篇题解和楼上不同，因为我不会维护摩尔投票法。

该方法和摩尔投票法一样，能求出唯一**可能是**答案的方法。

其实这方法不是我原创的，我能找到该方法最早的出处是： https://www.luogu.com.cn/blog/daks/solution-p2397。

简要复述一下该方法：对于一个序列 $a$，对于每个二进制位 $b$，求有多少个数该位是 $1$，记作 $cnt_b$。

存在绝对众数 $m$ 时，如果 $m$ 某一位是 $1$，那么 $cnt_b$ 一定过半，反则一定不过半。

这个方法好处是可以巨方便地合并两个序列。

## 维护序列 $a$

这个序列 $a$ 显然必须维护。不然的话，$2$ 操作删掉了一个谁都不知道。~~所以 $2$ 操作目的就是考一个链表？~~

观察到每次我们都只用到 $a$ 的末尾，以及归并，我们可以使用链表维护数列 $a$。

因为我比较懒（而且链表是 $O(n)$ 的，不是复杂度瓶颈），所以我选择用 STL。我们发现 $4$ 操作本质相当于把 $x_2$ 接到 $x_1$ 后面，然后把 $x_1$ 重命名为 $x_3$。

`list` 记录了 `end()`，可以 $O(1)$ `push_back` 和 `pop_back`，所以这个复杂度不需要担心。

`list` 的 `size()` 函数在 C++ 11 起保证为 $O(1)$，在此之前可能是 $O(1)$ 或线性，因此如果你提交本题代码建议选择 C++ 14。

将 `list2` 接到 `list1` 末尾表示为 `list1.splice(list1.end(),list2)`。该函数复杂度为 $O(1)$。

## 判 $-1$

我们维护二进制拆位求众数，算出一个可能的众数，接下来要判断该数是否过半。

这时候我们发现，线段树合并逃不掉了。对于每个序列我们还要额外维护一个动态开点线段树，方便查询可能的众数出现次数是否过半。

计算一下复杂度，发现是 $1\log$ 的。但是我不知道为啥跑了 $600$ 多毫秒，毕竟维护二进制拆位常数看着很小。

然后就差不多啦，贴代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct SGT
{
	long long cnt;int ls,rs;//cnt只有叶子结点的才有用 
}tr[20000005];
int used=0;
int New(){used++;tr[used].cnt=0;tr[used].ls=tr[used].rs=0;return used;}
void upd(int rt,int pos,int up)//线段树更新
{
	for(int high=(1<<19);high;high>>=1)
	{
		if(pos&high)
		{
			if(tr[rt].rs==0)
				tr[rt].rs=New();
			rt=tr[rt].rs;
		}
		else
		{
			if(tr[rt].ls==0)
				tr[rt].ls=New();
			rt=tr[rt].ls;
		}
	}
	tr[rt].cnt+=up;
}
void merge(int rt,int frm)//线段树合并
{
	if(tr[frm].ls)
	{
		if(tr[rt].ls==0)
			tr[rt].ls=tr[frm].ls;
		else merge(tr[rt].ls,tr[frm].ls);
	}
	if(tr[frm].rs)
	{
		if(tr[rt].rs==0)
			tr[rt].rs=tr[frm].rs;
		else merge(tr[rt].rs,tr[frm].rs);
	}
	tr[rt].cnt+=tr[frm].cnt;
}
long long count(int rt,int pos)//线段树单点查询
{
	for(int high=(1<<19);high;high>>=1)
		if(pos&high)
			rt=tr[rt].rs;
		else
			rt=tr[rt].ls;
	return tr[rt].cnt;
}
struct Mode//维护二进制拆位
{
	long long a[20];
	Mode(){memset(a,0,sizeof a);}
	int mode(long long sz)//给出序列长求众数
	{
		int res=0;
		for(int i=0;i<20;i++)
			if(a[i]>sz/2)res|=1<<i;
		return res;
	}
}s[1000005];
void operator +=(Mode &m,int x)
{
	for(int i=0;i<20;i++)
		if(x&(1<<i))m.a[i]++;
}
void operator -=(Mode &m,int x)
{
	for(int i=0;i<20;i++)
		if(x&(1<<i))m.a[i]--;
}
void operator +=(Mode& x,Mode y)
{
	for(int i=0;i<20;i++)
		x.a[i]+=y.a[i];
}
int n,q,seq[500005];//seq记录每个序列对应线段树的根 
list<int> a[500005];
int quest[500005],to[1000005];
int main()
{
	int l,m,x,y;
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++)
	{
		to[i]=i;//to[i]记录每个序列的实际存储位置
		seq[i]=New();//每个序列开一个线段树
		for(scanf("%d",&l);l;l--)
		{
			scanf("%d",&x);
			a[i].push_back(x);//维护链表
			s[i]+=x;//维护二进制拆位
			upd(seq[i],x,1);//维护线段树
		}
	}
	for(;q;q--)
	{
		scanf("%d",&l);
		if(l==1)
		{
			scanf("%d%d",&x,&y);x=to[x];//全部数据存在真实位置，下同
			a[x].push_back(y);
			s[x]+=y;
			upd(seq[x],y,1);
		}
		if(l==2)
		{
			scanf("%d",&x);x=to[x];
			y=a[x].back();
			a[x].pop_back();
			s[x]-=y;
			upd(seq[x],y,-1);
		}
		if(l==3)
		{
			scanf("%d",&m);
			Mode tmp;
			long long tsz=0;//拼出来的序列总长
			for(int i=0;i<m;i++)
			{
				scanf("%d",&quest[i]);x=quest[i]=to[quest[i]];
				tmp+=s[x];//合并二进制拆位
				tsz+=a[x].size();
			}
			long long probable=tmp.mode(tsz),cnt=0;
			for(int i=0;i<m;i++)
				cnt+=count(seq[quest[i]],probable);
			if(cnt>tsz/2)
				printf("%d\n",probable);
			else puts("-1");
		}
		if(l==4)
		{
			scanf("%d%d%d",&x,&y,&m);
			x=to[x];y=to[y];
			merge(seq[x],seq[y]);//维护线段树
			to[m]=x;//重命名
			a[x].splice(a[x].end(),a[y]);//维护链表
			s[x]+=s[y];//维护二进制拆位
		}
	}
	return 0;
}
```



---

## 作者：StarLbright40 (赞：7)

#### 前言

这里是考场上半小时想到标算半小时码完然后链表写挂只有 85pts 的选手。果然我适合滚回普及组补习。

------------

这题上来就是一个 `#define 众数 绝对众数` 的操作。看到求绝对众数，想到摩尔投票法。

前置知识：不了解摩尔投票法的珂以看一下 [P2397](/problem/P2397)，我认为这是摩尔投票法板题。

思路就是，若序列存在绝对众数，那么每次删去序列中两个值不同的数，直到只剩下一个值时一定是绝对众数。这个应该很好理解。

具体到这题，如何维护一个带修序列的绝对众数呢？

理解摩尔投票法的原理后，自然容易想到它的一个性质：

![](https://cdn.luogu.com.cn/upload/image_hosting/8ctktuqw.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

具体地，删除顺序不影响最终结果。

注意到这题的插入、删除操作都只影响一个数，所以使用线段树维护序列，每个线段树节点维护当前区间在摩尔投票法下的信息（出现次数最多的值及其剩余的出现次数）。

那么 pushup 操作就相当于摩尔投票法中删数的过程。由于序列长度不定，我们使用权值线段树，并动态开点。由于我们只关心整个序列的绝对众数，于是我们只需要单点修改和全局查询。

对于插入、删除操作，注意到每次只在序列尾部进行操作，于是再使用一个链表维护序列，同时线段树单点修改即可。

对于合并操作，线段树合并即可解决，这里不展开讲解了。同时还需要合并链表。

对于询问操作，我们定义一个与线段树节点类型相同的变量，将其与每个序列对应的线段树根节点进行如 pushup 一般的操作，就能得到一个答案。

别忘了，摩尔投票法求得绝对众数的前提是序列存在绝对众数，所以我们还需要检验答案。

在线段树上记录相应值的出现次数，这样就能用刚才的答案进行若干次单点查询求得它在序列中的出现次数，与序列长度比较即可。

放一下改到 AC 的删除注释和 freopen 的考场代码。

```cpp
#include<cstdio>
using namespace std;
const int N=1e6+3;
struct node{
	int siz,ans,num;
	node operator +(const node &y)const{
		node tmp;
		tmp.siz=siz+y.siz;
		if(ans==y.ans) tmp.ans=ans,tmp.num=num+y.num;
		else if(num>y.num) tmp.ans=ans,tmp.num=num-y.num;
		else tmp.ans=y.ans,tmp.num=y.num-num;
		return tmp;
	}
};
struct seg{
	int l,r;node x;
}t[N*22];
void pushup(int x){
	t[x].x=t[t[x].l].x+t[t[x].r].x;
}
struct seq{
	int x,lst,nxt;
}a[N];
int n,m,q,cnt,tot,hd[N],tl[N],rt[N],que[N];
void add(int &x,int l,int r,int L,int k){
	if(!x) x=++cnt;
	if(l==r){
		t[x].x={t[x].x.siz+k,l,t[x].x.siz+k};
		return;
	}
	int mid=(l+r)>>1;
	L>mid?add(t[x].r,mid+1,r,L,k):add(t[x].l,l,mid,L,k);
	pushup(x);
}
int query(int x,int l,int r,int L){
	if(l==r) return t[x].x.siz;
	int mid=(l+r)>>1;
	return L>mid?query(t[x].r,mid+1,r,L):query(t[x].l,l,mid,L);
}
void mergeseg(int &x,int y,int l,int r){
	if(!y) return;
	if(!x){x=y;return;}
	if(l==r){t[x].x=t[x].x+t[y].x;return;}
	int mid=(l+r)>>1;
	mergeseg(t[x].l,t[y].l,l,mid);
	mergeseg(t[x].r,t[y].r,mid+1,r);
	pushup(x);
}
int main(){
	scanf("%d%d",&n,&q),m=n+q;
	for(int i=1,k;i<=n;++i){
		scanf("%d",&k);
		hd[i]=tot+1;
		for(int x;k--;){
			scanf("%d",&x);
			++tot;
			a[tot]={x,tot-1,tot+1};
			add(rt[i],1,m,x,1);
		}
		tl[i]=tot;
	}
	for(int op,x,y,z;q--;){
		scanf("%d",&op);
		if(op==1){
			scanf("%d%d",&x,&y);
			a[++tot]={y,tl[x],0};
			(t[rt[x]].x.siz?a[tl[x]].nxt:hd[x])=tot;
			tl[x]=tot;
			add(rt[x],1,m,y,1);
		}
		if(op==2){
			scanf("%d",&x);
			add(rt[x],1,m,a[tl[x]].x,-1);
			tl[x]=a[tl[x]].lst;
		}
		if(op==3){
			node tmp={0,0,0};
			scanf("%d",&x);
			for(int i=1;i<=x;++i){
				scanf("%d",que+i);
				tmp=tmp+t[rt[que[i]]].x;
			}
			int num=0;
			for(int i=1;i<=x;++i)
				num+=query(rt[que[i]],1,m,tmp.ans);
			printf("%d\n",num*2>tmp.siz?tmp.ans:-1);
		}
		if(op==4){
			scanf("%d%d%d",&x,&y,&z);
			if(t[rt[x]].x.siz)
				hd[z]=hd[x],a[tl[x]].nxt=hd[y];
			else hd[z]=hd[y];
			if(t[rt[y]].x.siz)
				tl[z]=tl[y],a[hd[y]].lst=tl[x];
			else tl[z]=tl[x];
			mergeseg(rt[x],rt[y],1,m);
			rt[z]=rt[x];
		}
	}
	return 0;
}
```

------------

#### 后话

珂以去看一道思路相似的题目 [P3765 总统选举](/problem/P3765)~~，上面的图片就截自这题的讨论区~~。

前言说的“链表写挂”具体是指合并操作中合并链表时忘记判空，导致头尾指针可能丢失信息。最终是一名 SC 老哥帮我看出来的，感谢他/bx/bx。

这题询问时序列珂以重复，所以统计出现次数时理论最大能达到 $(5\cdot10^5)^2$ 会爆 int。但是良心出题人没卡这个，幸好幸好。所以我就用了 int，日后我要是因为这个原因被 hack 了就不用喊我改了自己想办法（（（

我省队长帮我调代码时评价我的线段树合并写法比较神奇，同时对我手写链表的行为表示不满：“我在考场上想了 10mins 要不要写链表最后决定不写，结果最后还是得调链表。”

我省 E 队爷说使用 STL list 就不用合并时判空了，看来得学学 list。~~愧对 id 的屑~~

讲题人钦定线段树是标算并表示场切选手没有使用这种做法的，令人感叹。

---

## 作者：include_BM (赞：7)

每个序列开一颗动态开点权值线段树，每个节点维护子树和，那么 $1$ 操作相当于单点加，$4$ 操作相当于合并 $2$ 颗线段树。

考虑 $3$ 操作，可以同时在这 $m$ 颗线段树上二分，设众数出现次数需要 $\ge need$，那么众数能出现在 $[l,r]$ 内当且仅当区间 $[l,r]$ 内的数个数 $\ge need$，由于线段树上每个区间的两段子区间中最多只会有一段满足要求，判断哪段符合要求并递归处理，最后在递归到子节点时判断当前数是否合法。

但是只有权值线段树无法得知序列最后一个数是什么，那么可以对每个序列开一个链表，维护每个序列的开头、末尾、每个数的值以及每个数上一个数是什么，那么合并两个序列时只需要把 $2$ 个链表接在一起，删数时取出链表末尾的数并修改线段树上的对应位置。

**注意 $3$ 操作后得到的序列长度可能会超出 int 的范围，需要开 long long。**

```cpp
//People who believe in miracles are as amazing as miracles themselves.
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-') f=-f;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
    return x*f;
}

const int N=1e6+10;
int n,q,m,len[N],val[N],ed[N],st[N],pre[N],rt[N],cnt,tot,p[N],num; ll need;

#define mid ((l+r)>>1)
struct node{
    int ls,rs,num;
}tr[N*25];
void chg(int &x,int l,int r,int p,int k){
    if(!x) x=++tot; tr[x].num+=k;
    if(l!=r) p<=mid?chg(tr[x].ls,l,mid,p,k):chg(tr[x].rs,mid+1,r,p,k);
}
int merge(int x,int y,int l,int r){
    if(!x||!y) return x+y;
    if(l==r) return tr[x].num+=tr[y].num,x;
    tr[x].ls=merge(tr[x].ls,tr[y].ls,l,mid);
    tr[x].rs=merge(tr[x].rs,tr[y].rs,mid+1,r);
    return tr[x].num=tr[tr[x].ls].num+tr[tr[x].rs].num,x;
}
int que(int l,int r){
    ll sum=0;
    if(l==r){
        for(int i=1;i<=num;++i) sum+=tr[p[i]].num; return sum>=need?l:-1;
    }
    for(int i=1;i<=num;++i) sum+=tr[tr[p[i]].ls].num;
    if(sum>=need){
        for(int i=1;i<=num;++i) p[i]=tr[p[i]].ls; return que(l,mid);
    }
    else{
        for(int i=1;i<=num;++i) p[i]=tr[p[i]].rs; return que(mid+1,r);
    }
}

signed main(){
    n=read(),q=read(),m=n+q;
    for(int i=1;i<=n;++i){
        len[i]=read();
        for(int j=1;j<=len[i];++j){
            ++cnt;
            if(!st[i]) st[i]=cnt; else pre[cnt]=ed[i];
            val[cnt]=read(),chg(rt[i],1,m,val[cnt],1),ed[i]=cnt;
        }
    }
    for(int op,x,y,z;q;--q){
        op=read();
        if(op==1){
            x=read(),y=read(),++len[x],++cnt;
            if(!st[x]) st[x]=cnt; else pre[cnt]=ed[x];
            val[cnt]=y,chg(rt[x],1,m,y,1),ed[x]=cnt;
        }
        else if(op==2){
            x=read(),--len[x];
            chg(rt[x],1,m,val[ed[x]],-1),ed[x]=pre[ed[x]]; if(!ed[x]) st[x]=0;
        }
        else if(op==3){
            num=read(),need=0;
            for(int i=1;i<=num;++i) p[i]=read(),need+=len[p[i]],p[i]=rt[p[i]];
            need=need/2+1,printf("%d\n",que(1,m));
        }
        else{
            x=read(),y=read(),z=read();
            len[z]=len[x]+len[y];
            if(st[x]&&st[y]) st[z]=st[x],ed[z]=ed[y],pre[st[y]]=ed[x];
            else if(st[x]) st[z]=st[x],ed[z]=ed[x];
            else if(st[y]) st[z]=st[y],ed[z]=ed[y];
            rt[z]=merge(rt[x],rt[y],1,m),rt[x]=rt[y]=st[x]=st[y]=ed[x]=ed[y]=len[x]=len[y]=0;
        }
    }
    return 0;
}
```

---

## 作者：Graphcity (赞：4)

先来看特殊性质 C：序列中只有 1 和 2 两种数字。

对于每个序列用一个 `deque` 来维护，并用一个数 $cnt$ 来统计序列中 1 出现的次数，$len$ 来维护它的长度。

- 操作 1 和操作 2：直接在 `deque` 末尾添加或者删除即可。注意维护 $cnt$ 和 $len$ 的值。

- 操作 3：统计这里面所有序列的长度之和 $s_1$ 以及 1 的个数之和 $s_2$，如果 $2s_2>s_1$，那么众数就是 1，否则就是 2。

- 操作 4：利用启发式合并，将小的序列往大的合并，同时将两个序列的 $cnt$ 与 $len$ 值加起来。

现在我们回到原题，那就需要想一个办法把序列中的数字变成与 1 和 2 类似，比较好维护的样子。

这个方法就是 **二进制拆分**。

对于一个众数，因为它在原序列中的出现次数超过了一半，那么 **对于每一个二进制位来说，众数在这一位上对应的值也超过了一半。**

用跟上面类似的方法维护即可。具体来说，把 $cnt$ 改成一个数组，用来维护每一位上 1 出现的次数，然后在操作 3 中扫描每一位，如果第 $i$ 位 1 的个数比 0 多就把答案加上 $2^i$。

这样就出现了一个新的问题：拼凑出来的答案可能在序列中的出现次数到不了一半。我的做法是对每个序列开一个 `map` 维护每个数的出现次数，合并时用 `map` 启发式合并即可。但这样做是 $O(n\log^2n)$ 的，常数小，卡不满，可以过去。

有一个更加巧妙的办法，那就是值域线段树合并，这样做就是 $O(n\log n)$ 的。

注意：

- 操作 3 中序列的长度可能会超过 `int` 范围，应该要用 `long long` 类型的变量来存储。

- 注意空间。如果是 `map` 做法可以放心开 $10^6$ 个 `deque` 和 `map`，但如果用的是值域线段树就要考虑超过空间限制的问题。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define For(i,a,b) for(int i=(a);i<=(b);++i)
#define Rof(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
const int Maxn=1e6;

inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0' || ch>'9')
    {
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}

int n,q,id[Maxn+5],cnt[Maxn+5][32],len[Maxn+5];
ll num[32]; int st[Maxn+5];
deque<int> que[Maxn+5];
map<int,int> mp[Maxn+5];

inline int Count(int m)
{
    ll ls=0,tmp=0; int res=0;
    For(i,1,m) st[i]=read(),st[i]=id[st[i]];
    For(i,1,m)
    {
        ls+=len[st[i]];
        For(j,0,20) num[j]+=cnt[st[i]][j];
    }
    For(i,0,20) if(num[i]>ls/2) res+=(1<<i);
    For(i,0,20) num[i]=0;
    For(i,1,m) if(mp[st[i]].count(res)) tmp+=mp[st[i]][res];
    if(tmp>ls/2) return res;
    else return -1;
}
inline void Link(int x,int y,int z)
{
    x=id[x],y=id[y];
    if(len[y]<=len[x])
    {
        len[x]+=len[y],id[z]=x;
        For(i,0,20) cnt[x][i]+=cnt[y][i];
        while(!que[y].empty())
        {
            int now=que[y].front(); mp[x][now]++;
            que[x].push_back(now),que[y].pop_front();
        }
        mp[y].clear(),len[y]=0;
    }
    else
    {
        len[y]+=len[x],id[z]=y;
        For(i,0,20) cnt[y][i]+=cnt[x][i];
        while(!que[x].empty())
        {
            int now=que[x].back(); mp[y][now]++;
            que[y].push_front(now),que[x].pop_back();
        }
        mp[x].clear(),len[x]=0;
    }
}

int main()
{
    // freopen("major.in","r",stdin);
    // freopen("major.out","w",stdout);

    n=read(),q=read();
    For(i,1,n)
    {
        id[i]=i,len[i]=read();
        For(j,1,len[i])
        {
            int now=read(); que[i].push_back(now); mp[i][now]++;
            For(k,0,20) if(now&(1<<k)) cnt[i][k]++;
        }
    }
    while(q--)
    {
        int opt=read(),x=read(),y,z;
        if(opt==1)
        {
            y=read(),x=id[x],que[x].push_back(y),len[x]++,mp[x][y]++;
            For(i,0,20) if(y&(1<<i)) cnt[x][i]++;
        }
        if(opt==2)
        {
            x=id[x]; y=que[x].back(); que[x].pop_back(),len[x]--,mp[x][y]--;
            if(!mp[x][y]) mp[x].erase(y);
            For(i,0,20) if(y&(1<<i)) cnt[x][i]--;
        }
        if(opt==3) printf("%d\n",Count(x));
        if(opt==4)
        {
            y=read(),z=read();
            Link(x,y,z);
        }
    }
    return 0;
}
// g++ major.cpp -o major -O2 -std=c++14
// ./major
```

---

## 作者：rainygame (赞：2)

> 为本题的启发式合并+分治做法提供更详细的讲解和更简洁的代码（另：欢迎 hack）

对于 1、2 操作，发现需要插入、删除最后一个节点。又看到 3、4 操作的拼接序列，果断选择链表，为了实现简单使用了 `list`。同时还需要维护每个序列的众数（**不是绝对众数**）及序列中每个数的出现次数。这两个分别可以用 `set` 和 `map` 来维护。

对于操作 3，可以分治求解。将一个序列任意地分成两份，整个序列的绝对众数一定是其中某份的绝对众数。对于分治出来的两边的答案，分别检查即可。时间复杂度 $O(m \log m)$。

对于操作 4，可以直接启发式合并两个序列的 `set` 和 `map`，时间复杂度摊下来应该是 $O(\log^2 n)$ 的，但是跑得飞快，而且还不用特判 $x_1$、$x_2$ 为空的情况。对于合并出来在较大序列的信息，可以直接 `swap` 到 $x_3$。`list` 的拼接可以用 `list::splice` $O(1)$ 实现。

时间复杂度 $O(q \log^2 n)$。

然后这道题就做完了，代码也很简单，完全不压行也只有 $93$ 行。个人认为这种做法的思路比线段树合并简单很多。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 1000001

int n, q;
int b[MAXN];
list<int> a[MAXN];
set<pair<int, int>, greater<pair<int, int>>> st[MAXN];
map<int, int> g[MAXN];

void add(int ind, int x){
    a[ind].push_back(x);
    if (g[ind].count(x)) st[ind].erase({g[ind][x], x});
    st[ind].insert({++g[ind][x], x});
}

void del(int ind){
    int x(a[ind].back());
    st[ind].erase({g[ind][x], x});
    st[ind].insert({--g[ind][x], x});
    a[ind].pop_back();
}

void merge(int x, int y, int z){
    if (a[x].size() > a[y].size()){
        swap(a[x], a[z]);
        a[z].splice(a[z].end(), a[y]);
        swap(x, y);
    }else{
        swap(a[x], a[z]);
        a[z].splice(a[z].end(), a[y]);
    }
    for (auto i: st[x]){
        if (g[y][i.second]) st[y].erase({g[y][i.second], i.second});
        st[y].insert({g[y][i.second]+=i.first, i.second});
    }
    swap(st[z], st[y]);
    swap(g[z], g[y]);
}

bool check(int l, int r, int x){
    int res(0), siz(0);
    for (int i(l); i<=r; ++i){
        res += g[b[i]][x];
        siz += a[b[i]].size();
    }
    return (res<<1) > siz;
}

int solve(int l, int r){
    if (l == r){
        if (st[b[l]].empty() || (st[b[l]].begin()->first<<1) <= a[b[l]].size()) return -1;
        return st[b[l]].begin()->second;
    }

    int mid((l+r)>>1), res1(solve(l, mid)), res2(solve(mid+1, r));
    if ((~res1) && check(l, r, res1)) return res1;
    if ((~res2) && check(l, r, res2)) return res2;
    return -1;
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> n >> q;
    for (int i(1), l; i<=n; ++i){
        cin >> l;
        for (int x; l; --l){
            cin >> x;
            add(i, x);
        }
    }

    for (int opt, x, y, z; q; --q){
        cin >> opt >> x;
        if (opt == 1){
            cin >> y;
            add(x, y);
        }else if (opt == 2) del(x);
        else if (opt == 3){
            for (int i(1); i<=x; cin >> b[i++]);
            cout << solve(1, x) << '\n';
        }else{
            cin >> y >> z;
            merge(x, y, z);
        }
    }

    return 0;
}

```

---

## 作者：AzusaShirasu (赞：1)

一种不用线段树合并的做法。

题解略长，先放一下做法概要：查询的时候，先把每个数列中出现次数大于等于一半的数找出来，形成「候选集合」$K$；对于每个数列 $x_i$，如果 $K$ 的大小小于 $x_i$，暴力统计 $x_i$ 中每个处于 $K$ 内的数的贡献；否则暴力统计 $K$ 中每个处于 $x_i$ 中的数的贡献。

***

首先考虑没有操作 $3$ 的情况：尾部添加 / 删除、合并。启发式合并就可以轻松解决。启发式合并要注意添加元素的端点是在头部还是在尾部。

`deque` 能满足要求，但是 `deque` 本身的时空复杂度都很大，实测在本人机子上甚至被 `vector` 完爆。`list` 和 `vector` 的用法很相似，而且它能够 $O(1)$ 在头尾插入元素。是理想的结构。

考虑加入操作 $3$。根据定义可以推出一个性质：答案 $v$ **一定**占至少一个数列的**至少一半**。证明是显然的：如果一个数字在每一个数列都占不到一半，那总和起来也不会超过一半。

依据这个性质，首先将 $m$ 个数列中占至少一半的数取出来，形成一个「候选集合」称作 $K$。显然 $K$ 的大小最多为 $2m$。

暴力 $O(m^2)$ 求不可行，一个显然的性质：如果一个数出现次数至少一半，那它肯定是**最多的数**。取一个集合中最大的元素，可以用堆。因为需要合并，所以用**可并堆**。可并堆里保存一个二元组 $(v,c)$ 表示数字 $v$ 出现了 $c$ 次，按 $c$ 在堆里升序排列。

启发式合并需要特殊处理：假设 $x$ 堆合并到 $y$ 堆，有一个元素是 $(v,c_x)$，但是 $y$ 中也有一个 $(v,c_y)$，此时不应当新插入一个二元组，而是应当**把原来的二元组修改为** $(v,c_x+c_y)$。

这个应该可以左偏树或者什么科技解决，但是有个更简便的办法：`pbds` 库。

`pbds` 的库里有一个 `priority_queue`，它在每次你 `push` 的时候**会返回一个指针**，通过这个指针，用 `modify` 函数就可以修改堆里的元素了。示例代码：

```cpp
pq.push(4);
auto a=pq.push(2);
pq.modify(a,5);
pq.top(); // Now it's 5
```

更加详细的用法可参考[这篇博客](https://www.luogu.com.cn/blog/UruhaRushia/how-to-acquire-pbds#)。

所以用 `pbds` 的做法就是：额外开一个 `map` 保存每个 $v$ 所对应的指针，在合并的时候，有则修改指针为 $c_x+c_y$，无则直接插入。

这样一来就可以 $O(\log m)$ 的时间实现取最大值 / 合并。

有了 $K$，在计算答案时，有两种策略：

1. 暴力统计每个 $K$ 中的元素在 $m$ 个数列中出现的次数，求和；
2. 暴力统计 $m$ 个数列中每个数是否在 $K$ 中出现，出现则加和；

随便一卡时间复杂度都会至少 $O(m^2)$。而优化方式就是根据 $K$ 的大小和数列大小决定。

优化思路是好理解的：每次选那个计算量小的方式算。设处理数列 $x_i$，如果 $K$ 比 $x_i$ 小（指的是集合大小上更小），那么采取策略 $1$；否则采取策略 $2$。

那么时间复杂度是多少呢？平摊下是 $O(m\sqrt m)$ 的。具体不会证，大概就是因为策略 $1$ 和 $2$ 是相反的思路，即 $1$ 跑得快时 $2$ 就会慢，反之亦然，所以平均一下是 $O(\sqrt m )$ 出结果。

最后出询问结果的时候，找最大值 $O(m)$ 打擂台完全不虚。记得判断一下最大值的出现次数 $\times 2$ 有没有大于所有数列的大小的总和。

时间复杂度 $O(n \log n+(\sum m)^{\frac{3}{2}})$。声明一堆 STL 的常数比较大，加上本人没卡常，吸氧之后 990ms 险过。一些实现细节参考代码：

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/tree_policy.hpp>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/priority_queue.hpp>
using namespace __gnu_pbds;
using namespace std;
const int maxn=1000000+5;
inline int rd(){int x;scanf("%d",&x);return x;}
inline void wr(int x){printf("%d\n",x);}
struct rec{
	int val,cnt;
	rec(){val=cnt=0;}
	rec(int v,int c){val=v,cnt=c;}
	bool operator<(const rec&v)const{return cnt!=v.cnt?cnt<v.cnt:val<v.val;}
};
typedef __gnu_pbds::priority_queue<rec> heap;
typedef heap::point_iterator addr;
heap lst[maxn];
list<int> vc[maxn];
gp_hash_table<int,addr> locs[maxn];
int true_id[maxn];
inline void ins(int x,int y){
	vc[x].push_back(y);
	if(locs[x].find(y)==locs[x].end())locs[x][y]=lst[x].push(rec(y,1));
	else lst[x].modify(locs[x][y],rec(y,locs[x][y]->cnt+1));
}
inline void del(int x){
	int y=vc[x].back();vc[x].pop_back();
	if(locs[x].find(y)==locs[x].end())locs[x][y]=lst[x].push(rec(y,-1));
	else lst[x].modify(locs[x][y],rec(y,locs[x][y]->cnt-1));
}
inline void newlst(int x,int y,int newid){// Note this function
	bool rev=0;
	if(lst[x].size()>lst[y].size()){swap(x,y);rev=1;}
	for(auto a:lst[x]){
		if(locs[y].find(a.val)==locs[y].end())locs[y][a.val]=lst[y].push(a);
		else lst[y].modify(locs[y][a.val],rec(a.val,locs[y][a.val]->cnt+a.cnt));
	}
	if(!rev){reverse(vc[x].begin(),vc[x].end());for(auto a:vc[x])vc[y].insert(vc[y].begin(),a);}
	else for(auto a:vc[x])vc[y].push_back(a);
	vc[x].clear(),lst[x].clear(),true_id[newid]=y;
}
int m,qm[maxn];
set<int> cdd;
gp_hash_table<int,int> app;
int oh(){
	int sum=0;
	cdd.clear(),app.clear();
	#define l lst[qm[i]]
	for(int i=1;i<=m;i++)cdd.insert(l.top().val),sum+=vc[qm[i]].size();
	for(int i=1;i<=m;i++){
		if(cdd.size()>l.size())for(auto a:l)app[a.val]+=a.cnt;
		else for(auto a:cdd)if(locs[qm[i]].find(a)!=locs[qm[i]].end())app[a]+=locs[qm[i]][a]->cnt;
	}
	#undef l
	int loc=-1,big=-1;
	for(auto a:cdd)if(app[a]>big)big=app[a],loc=a;
	return (big*2>sum)?loc:-1;
}
int main(){
	int n,q;n=rd(),q=rd();
	for(int i=1;i<=n;i++){
		int l=rd();while(l--)ins(i,rd());true_id[i]=i;
	}
	while(q--){
		int op=rd();
		switch(op){
			case 1:{int x=rd(),y=rd();ins(true_id[x],y);break;}
			case 2:{int x;del(true_id[x=rd()]);break;}
			case 3:{
				m=rd();
				for(int i=1;i<=m;i++)qm[i]=true_id[rd()];
				wr(oh());
				break;
			}
			case 4:{int x=rd(),y=rd(),z=rd();newlst(true_id[x],true_id[y],z);break;}
		}
	}
	return 0;
}
```

***

后记：


- 时间复杂度高而且不一定可靠，欢迎 hack。


---

## 作者：novax (赞：1)

啥也不会的赛后补题选手来一发题解。

------------

[题面](https://www.luogu.com.cn/problem/P8496)

题目定义的“众数”为序列中出现次数严格大于一半的数字，先考虑只有一个序列的做法。

我们可以对序列建立一颗权值线段树，查询时往左右子区间中元素个数大于原序列长度一半的方向递归查找，如果都小于则无解。这样操作的时间复杂度是 $\log_2 n$ 的。

要维护多个序列，我们对每个序列都建立一棵权值线段树。因为权值线段树不能维护序列的顺序，所以需要使用``vector``记录整个序列的内容，方便插入删除。

对于 $1$ 操作，向权值线段树及``vector``中同时加入新元素即可。对于 $2$ 操作，我们找到所删除序列的权值线段树和``vector``，在权值线段树和``vector``中删除此``vector``里最靠后的元素。

对于 $4$ 操作，题目要求两个序列拼接并删除原序列。

考虑线段树合并。将前面序列的权值线段树合并到后面序列的权值线段树上即可。有一个问题：对应存储序列的``vector``无法合并。

那我们就不合并``vector``，维护一个链表样的东西，记录当前下标的序列前面所接的序列。同时记录每个序列最后一个元素所在的``vector``。这样操作 $1$ 时在当前最后一个元素所在的``vector``插入元素，操作 $2$ 时则直接删除即可。若当前序列末尾所在``vector``已经为空，那么可以一直跳链表，直到当前所在的``vector``不为空为止。

为提高合并效率，需要额外维护并查集记录当前``vector``在所属序列最合并位置靠前的``vector``下标，

对于 $3$ 操作，题目要求多个序列拼接后的众数。

合并多棵线段树的复杂度无法接受。那该怎么做？暴力！我们按照单颗权值线段树的做法，同时对多棵线段树查询。对于左右子区间的元素个数，我们可以每次暴力遍历所有查询树的当前节点并求和。

这样复杂度为什么是对的？题目中保证了查询的序列总数不超过 $5 \times 10^5$，而每次查询有 $\log n$ 层，则对于所有询问暴力求和的总次数为 $n \log n$ 级别。

这样我们就解决了这个问题。


------------

注意事项：

1. 本题操作 $3$ 的序列可以重复，因此求区间元素总个数时可能会爆``long long``。

2. ``deque``空间复杂度极高，使用需谨慎。

3. 合并两个序列时不要暴力跳链找序列首，可以使用并查集维护加速查找。

------------


#### 代码

```cpp
#include <cstdio>
#include <vector>
const int Nx=1000010;
int N,Q;
std::vector<int> a[Nx];
int vl[Nx],chain[Nx],nid[Nx],fa[Nx];
int siz[80*Nx],ls[80*Nx],rs[80*Nx],cnt,root[Nx];
int new_node(){return ++cnt;}
void addin(int ll,int rr,int &p,int pos,int delta)
{
	if(!p)
		p=new_node();
	if(ll==rr)
	{
		siz[p]+=delta;
		return;
	}
	int mid=(ll+rr)>>1;
	if(pos<=mid)
		addin(ll,mid,ls[p],pos,delta);
	else
		addin(mid+1,rr,rs[p],pos,delta);
	siz[p]=siz[ls[p]]+siz[rs[p]];
}
int find_vec(int ll,int rr,std::vector<int> p,long long szp,long long flen)
{
	if(szp<flen)
		return -1;
	if(ll==rr)
		return ll;
	long long sizl=0,sizr=0;
	int mid=(ll+rr)>>1;
	std::vector<int> lc,rc;
	for(auto i : p)
	{
		sizl+=siz[ls[i]];
		sizr+=siz[rs[i]];
		lc.push_back(ls[i]);
		rc.push_back(rs[i]);
	}
	if(sizl>=flen)
		return find_vec(ll,mid,lc,sizl,flen);
	if(sizr>=flen)
		return find_vec(mid+1,rr,rc,sizr,flen);
	return -1;
}
int merge(int x,int y)
{
	if(!x||!y)
		return x+y;
	if(!ls[x]&&!rs[x])
	{
		siz[x]+=siz[y];
		return x;
	}
	ls[x]=merge(ls[x],ls[y]);
	rs[x]=merge(rs[x],rs[y]);
	siz[x]=siz[ls[x]]+siz[rs[x]];
	return x;
}
int ff(int p)
{
	if(p!=fa[p])
		fa[p]=ff(fa[p]);
	return fa[p];
}
int main()
{
	scanf("%d%d",&N,&Q);
	int i,j,k,val,opt,x,y;
	for(i=1;i<=N;i++)
	{
		scanf("%d",&vl[i]);
		for(j=1;j<=vl[i];j++)
		{
			scanf("%d",&val);
			a[i].push_back(val);
			addin(0,Nx,root[i],val,1);
		}
	}
	for(i=1;i<Nx;i++)
		chain[i]=i,nid[i]=i,fa[i]=i;
	while(Q--)
	{
		scanf("%d",&opt);
		if(opt==1)
		{
			scanf("%d%d",&x,&y);
			a[nid[x]].push_back(y);
			addin(0,Nx,root[x],y,1);
		}
		else if(opt==2)
		{
			scanf("%d",&x);
			while(a[nid[x]].size()==0)
				nid[x]=chain[nid[x]];
			val=a[nid[x]][a[nid[x]].size()-1];
			a[nid[x]].pop_back();
			addin(0,Nx,root[x],val,-1);
		}
		else if(opt==3)
		{
			scanf("%d",&k);
			std::vector<int> qv;
			long long sza=0;
			for(j=1;j<=k;j++)
			{
				scanf("%d",&val);
				qv.push_back(root[val]);
				sza+=siz[root[val]];
			}
			printf("%d\n",find_vec(0,Nx,qv,sza,sza/2+1));
		}
		else if(opt==4)
		{
			scanf("%d%d%d",&x,&y,&val);
			root[val]=merge(root[x],root[y]);
			nid[val]=nid[y];
			k=ff(nid[y]);
			chain[k]=nid[x];
			fa[k]=nid[x];
		}
	}
}
```

不知道为什么跑得比较慢...

---

## 作者：jia_shengyuan (赞：1)

有幸在考场上用乱搞过了这道题（事实上这个乱搞直到现在我都不知道要怎么卡），于是写下这篇题解，希望能分享一下这个很好想的做法，看看有没有大佬能卡掉，同时给像我一样没见过摩尔投票这个常见套路的同学一点思路。当然，摩尔投票的正解在后面也会有。

这道题的序列明显可以链表维护，而计算绝对众数需要一个桶，同时这个桶还要能支持合并，由此不难想到线段树合并，且这个过程中可以顺便维护每个序列的最大值以及其出现次数。**注意：本文中，为方便起见，最大值指出现次数最多的值**。这样的话操作 $1,2,4$ 就完事了，只需要解决查询即可。

不难发现，一个值要想成为最终的绝对众数，那么它至少要在一个序列中以绝对众数出现，否则其出现次数不可能超过一半。那么一个暴力做法就十分显然了：对于这 $m$ 个序列的绝对众数分别在这 $m$ 颗线段树上查询，直到找到绝对众数，否则无解。

然而这个暴力的时间复杂度是 $O(\sum{m^2\log n)}$ 的，考虑优化。运用人类智慧，我们发现**绝对众数**是一个很强的条件：如果把这些序列写在纸上，我们基本上能一眼瞪出来谁有可能是绝对众数，而且最多只会有一两个待选的数。假设 $1$ 是这个绝对众数，我们不难发现：如果想让 $1$ 不在那么多的序列中以绝对众数出现，则必须要有一个特别长的序列里面几乎全是 $1$，才能保证 $1$ 超过一半；反之，如果不想让一个很长的序列里出现过多 $1$，那么 $1$ 必须在其他序列中以绝对众数广泛存在。而无论是哪种形式，我们的程序都可以通过扫一遍“意识到”这个出现次数很多的数。所以，如果实在想不到正解，不妨相信一次人类智慧，相信暴力出奇迹。

考虑如何让程序“识别”这个广泛存在的数：通过之前存储的序列的最大值与其出现次数，我们可以对这 $m$ 个序列中的每个绝对众数维护其出现次数的**理论最大值**。这个**理论最大值**就是字面意思，指的是对于一个数，在不违反现有最大值的情况下，最多能出现多少次。用类似代码的语言说，如果一个长为 `L` 的序列最大值 `x`，出现了 `c` 次，那么 `x` 的理论上限 `+=c`，其他数的理论上限 `+=min(c,L-c)`，这个过程可以均摊 $O(1)$。

而这之后，我们只需把所有待选的数按理论上限降序排序，并一个一个查询直到理论上限不大于一半就行了，最慢的点 469ms。如果你害怕被卡，可以去维护前 $k$ 大值而不是仅维护最大值，$k\le4$ 都是可以通过的（我考场上就写的 $k=2$）。

另外，$k=1$ 或许比较好卡，但我尝试了很久都没能把 $k=2$ 时的这个做法卡掉，问了同学也不知道，希望能有大佬尝试造造 Hack 数据。或者说，这个做法的复杂度其实是对的？

记得开 `long long`！

```cpp
#include <algorithm>
#include <cstring>
#include <cstdio>
#include <vector>
#define ll long long
#define gc getchar
#define mid (l+r>>1)
#define err(...)

inline void read(int &n){
    n=0; char c=gc(); bool w=0;
    while(c<'0'||c>'9') {
        if(c=='-') w=1;
        c=gc();
    }
    n=c-48;
    while((c=gc())>='0'&&c<='9') n=(n<<3)+(n<<1)+c-48;
    if(w) n=-n;
}

const int maxn = 1e6+9;
using namespace std;

//链表，不过多解释
struct Link {

    int head[maxn],tail[maxn],pre[maxn],nxt[maxn],val[maxn],len[maxn],tot;

    inline Link(){
        tot=0;
        memset(len,0,sizeof(len));
    }
    inline void append(int id, int v){
        val[++tot] = v;
        if(!len[id]++) {
            head[id] = tail[id] = tot;
            pre[tot] = nxt[tot] = -1;
            val[tot] = v;
        } else {
            pre[tot] = tail[id];
            nxt[tail[id]] = tot;
            tail[id] = tot;
        }
    }
    inline int erase(int id){
        int res = val[tail[id]];
        if(!--len[id]) {
            head[id] = tail[id] = -1;
        } else {
            tail[id] = pre[tail[id]];
            nxt[tail[id]] = -1;
        }
        return res;
    }
    inline void merge(int x, int y, int z){
        if(!len[x]) {
            head[z] = head[y], tail[z] = tail[y], len[z] = len[y];
            return;
        }
        if(!len[y]) {
            head[z] = head[x], tail[z] = tail[x], len[z] = len[x];
            return;
        }
        len[z] = len[x]+len[y];
        head[z] = head[x];
        tail[z] = tail[y];
        nxt[tail[x]] = head[y];
        pre[head[y]] = tail[x];
    }

}link;

struct node {
    int ls,rs,val,cnt;
}t[maxn*40];

int rub[maxn*40],root[maxn],rcc,n,q,tot;

//线段树合并，不过多解释
inline int newnode(){
    if(rcc){
        int res = rub[rcc--];
        t[res] = {0,0,0,0};
        return res;
    }
    return ++tot;
}
inline void pushup(int now){
    if(t[t[now].ls].cnt > t[t[now].rs].cnt) {
        t[now].cnt = t[t[now].ls].cnt;
        t[now].val = t[t[now].ls].val;
    } else {
        t[now].cnt = t[t[now].rs].cnt;
        t[now].val = t[t[now].rs].val;
    }
}
void insert(int &now, int l, int r, int pos, int w=1){
    if(!now) now=newnode();
    if(l == r){
        t[now].val = pos;
        t[now].cnt += w;
        return;
    }
    if(pos <= mid) insert(t[now].ls,l,mid,pos,w);
    else insert(t[now].rs,mid+1,r,pos,w);
    pushup(now);
}
int merge(int a, int b, int l, int r){
    if(!a || !b) return a|b;
    if(l == r){
        t[a].cnt += t[b].cnt;
        rub[++rcc] = b;
        return a;
    }
    t[a].ls = merge(t[a].ls,t[b].ls,l,mid);
    t[a].rs = merge(t[a].rs,t[b].rs,mid+1,r);
    rub[++rcc] = b;
    pushup(a);
    return a;
}
int query(int now, int l, int r, int pos){
    if(!now) return 0;
    if(l == r) return t[now].cnt;
    if(pos <= mid) return query(t[now].ls,l,mid,pos);
    else return query(t[now].rs,mid+1,r,pos);
}

int has[maxn],mul[maxn],mulTime[maxn];
vector<int> nums,ids;
ll extra[maxn];

int Solve(){
    //这里为了省去初始化的复杂度，我们直接通过打时间戳判断要不要清空
    static int tim = 0; ++tim; 
    ll cnt = 0, totlen = 0;
    nums.clear(); ids.clear();
    int m; read(m);
    for(int i=1,id; i<=m; i++){
        read(id);
        int val = t[root[id]].val;
        extra[val] = 0;
        if(has[val] != tim) {//时间戳不一致说明需要初始化，下同
            has[val] = tim;
            nums.push_back(val);
        }
        if(mulTime[id] != tim) {
            mulTime[id] = tim;
            mul[id] = 0;
            ids.push_back(id);
        }
        mul[id]++;
        totlen += link.len[id];
    }
    for(int id : ids) {
        int sum=0,cc,val;
        //cc是这个序列中非最大值的理论上限次数
        cc = min(link.len[id]-t[root[id]].cnt, t[root[id]].cnt);
        cnt += (ll)cc*mul[id];
        //这里extra就是最大值相较于非最大值额外的次数。
        //换句话说，我们假装所有值都是非最大值，而最大值额外的次数单独存起来
        extra[t[root[id]].val] += (ll)(t[root[id]].cnt-cc)*mul[id];
    }
    sort(nums.begin(),nums.end(),[&](int x, int y) -> bool {
        return extra[x] > extra[y];
    });
    for(int num : nums) {
        if((cnt+extra[num])*2 <= totlen) return -1;
        ll reallen = 0;
        //暴力查询
        for(int id : ids) {
            reallen += (ll)query(root[id],1,n+q,num)*mul[id];
        }
        if(reallen*2 > totlen) return num;
    }
    return -1;
}

int main(){
    read(n),read(q);
    for(int i=1,m,v; i<=n; i++){
        read(m);
        for(int j=1; j<=m; j++){
            read(v);
            link.append(i,v);
            insert(root[i],1,n+q,v);
        }
    }
    for(int i=1,op,x,y,z; i<=q; i++){
        read(op);
        switch(op){
        case 1:
            read(x),read(y);
            link.append(x,y);
            insert(root[x],1,n+q,y);
            break;
        case 2:
            read(x);
            y = link.erase(x);
            insert(root[x],1,n+q,y,-1);
            break;
        case 3:
            printf("%d\n",Solve());
            break;
        case 4:
            read(x),read(y),read(z);
            link.merge(x,y,z);
            root[z] = merge(root[x],root[y],1,n+q);
            break;
        }
    }
    return 0;
}
```

可惜赛时因为一些小错误挂了 $15$ 分，但无论如何，暴力确实出奇迹了。

------------

会乱搞能够让我们拿分，但正解才是简洁而美妙的。其实正解更简单。

考虑如何维护一堆数的绝对众数，有一个经典方法是这样的：
1. 初始化信息 $=(0,0)$，其中第一项代表当前值，第二项代表当前次数。换言之，就是这个值出现了多少次。
2. 遍历每一个数，如果值一样，那么次数 $+1$，否则次数 $-1$。需要注意的是如果次数已经是 $0$ 了，那么直接更新信息为 $(\text{当前值},1)$。
3. 如果有绝对众数，那么绝对众数一定能留在信息中，代入验证即可。

这个过程可以理解为不同帮派火并，那么如果有一个超过一半，是一定能剩下的（但注意，不超过一半也可能剩下，所以要带入验证）。很明显这个信息满足结合律，所以我们对每个序列分别维护其信息，便可以在 $O(1)$ 的时间内完成对两个序列的合并，这样时间复杂度就显然是 $O(m\log n)$ 的了。

因为代码有大量重复，所以只放和上面不一样的部分了，不难发现正解真的比乱搞简洁很多。

```cpp
inline pair<int,ll> merge_info(int val1, ll cnt1, int val2, ll cnt2){
    if(val1 == val2) return {val1,cnt1+cnt2};
    if(cnt1 > cnt2) return {val1,cnt1-cnt2};
    if(cnt1 < cnt2) return {val2,cnt2-cnt1};
    return {0,0};
}
inline void pushup(int now){
    auto res = merge_info(lson.val, lson.cnt, rson.val, rson.cnt);
    t[now].val = res.first, t[now].cnt = res.second;
}
                   
vector<int> ids;

int Solve(){
    ids.clear();
    ll cnt=0,totlen=0,reallen=0;
    int m,val=0; 
    read(m);
    for(int i=1,id; i<=m; i++){
        read(id);
        ids.push_back(id);
        totlen += link.len[id];
        auto res = merge_info(val,cnt,t[root[id]].val,t[root[id]].cnt);
        val=res.first, cnt=res.second;
    }
    if(!cnt) return -1;
    for(int id : ids) {
        reallen += query(root[id],1,n+q,val);
    }
    if(reallen*2 > totlen) return val;
    return -1;
}
```

事实上，经过测试，这个正解和上面的乱搞跑的时间几乎是一样的，甚至乱搞总时间更快（而且这份乱搞在 CCF 少爷机上跑的时间居然是你谷的 $\frac23$，当然我不知道这和出题人没卡是否有强关联）。

或许这道题正是想告诉我们，不要总做时间复杂度的奴仆，代码跑得快，就行了。

---

## 作者：FireBladeMaster (赞：1)

首先我们知道有个东西叫摩尔投票法，大概就是每次找到两个不同的数一起删掉，最后剩下那个就可能是答案。这让我们想到分两部分，第一部分模拟这个投票，第二部分判断是否超过一半。

这个操作，插入，删除，合并，不需要随机访问，很明显可以用链表。

摩尔投票法的信息 $(val,count)$ 是可以合并的，这个用类似动态 dp 的东西可以去维护，但是怎么把他搬到区间上呢？

我们先把所有操作离线并**忽略所有删除操作**，用链表维护出最终的形态，然后遍历分配标号，这样每个序列就是一个区间，区间中的数可能存在或者不存在。这样就可以丢到线段树上维护了。这部分的时间复杂度是一个 log 的。判断是否超过一半直接线段树合并就好了，也是一个 log 的，那么这题就做完了。但是我写了 8K 代码，怎么回事呢。

```cpp
// author : 华恋_韵
#include <stdio.h>
#include <assert.h>
#include <vector>
#include <map>
#include <algorithm>
#include <set>
// #define int long long

struct bot{
    bot *nxt,*pre;
    int val;
    int Stat,Cnt;
};
bot *a[4000005],*b[4000005];
// std::map<int,int>mp[4000005];
int ns[4000005],sz[4000005];
struct dottle{
    int a,b;//op, val
    bool operator<(const dottle&c)const{
        return a==c.a?b>c.b:a>c.a;
    }
};
// std::set<dottle>s[4000005];
void del(bot*&a)
{
    if(a==NULL)return;
    if(a->nxt)del(a->nxt);
    delete a;
    a=NULL;
}
struct seg{
	long long cc[4000005];
    int vl[4000005];
    int dbg[4000005];
	inline void maintain(int o,int lc,int rc)
	{
		if(vl[lc]==vl[rc])vl[o]=vl[lc],cc[o]=cc[lc]+cc[rc];
		else if(cc[lc]>cc[rc])vl[o]=vl[lc],cc[o]=cc[lc]-cc[rc];
		else if(cc[lc]<cc[rc])vl[o]=vl[rc],cc[o]=-cc[lc]+cc[rc];
		else vl[o]=-1,cc[o]=0;
	}
	void shik(int o,int l,int r,int p,int v)
	{
		if(l==r)cc[o]=1,vl[o]=v,dbg[l]=v;//printf("upd %d %d\n",p,v);
		else 
		{
			int m=l+r>>1;
			if(p<=m)shik(o<<1,l,m,p,v);
			else shik(o<<1|1,m+1,r,p,v);
			maintain(o,o<<1,o<<1|1);
		}
	}
	void NIT(int o,int l,int r,int p)
	{
		if(l==r)cc[o]=0,vl[o]=-1,dbg[l]=-1;
		else 
		{
			int m=l+r>>1;
			if(p<=m)NIT(o<<1,l,m,p);
			else NIT(o<<1|1,m+1,r,p);
			maintain(o,o<<1,o<<1|1);
		}
	}
	void gyh(int o,int l,int r,int L,int R)
	{
		if(L<=l&&r<=R)
		{
			maintain(0,0,o);
			return;
		}
		int m=l+r>>1;
		if(m<R)gyh(o<<1|1,m+1,r,L,R);
		if(L<=m)gyh(o<<1,l,m,L,R);
	}
}shaya;
int rds[4000005],cc;
int read()
{
    int x=0,f=1,c=getchar();
    while(c<48||c>57){if(c=='-')f=-1;c=getchar();}
    while(c>47&&c<58)x=x*10+c-48,c=getchar();
    rds[++cc]=x*f;
    return x*f;
}
int dd=0;
int rd()
{
    return rds[++dd];
}
int s2[4000005];
int pos[4000005],zs[4000005],head[1000005];
struct Fe{
	int lc[20000005],rc[20000005],s[10000005],cc;
	void jyws(int &o,int l,int r,int p,int v)
	{
		// printf("jyws %d %d %d %d %d\n",o,l,r,p,v);
		if(!o)o=++cc;
		if(l==r)return s[o]+=v,void();
		int m=l+r>>1;
		if(p<=m)jyws(lc[o],l,m,p,v);
		else jyws(rc[o],m+1,r,p,v);
	}
	int jyws(int &o,int l,int r,int p)
	{
		if(!o)return 0;
		if(l==r)return s[o];
		int m=l+r>>1;
		if(p<=m)return jyws(lc[o],l,m,p);
		return jyws(rc[o],m+1,r,p);
	}
	void merge(int &o,int p,int l,int r)
	{
		if(!o||!p)return o+=p,void();
		if(l==r)
		{
			s[o]+=s[p];
			return;
		}
		int m=l+r>>1;
		merge(lc[o],lc[p],l,m);
		merge(rc[o],rc[p],m+1,r);
	}
}dx;
signed main()
{
    int n=read(),q=read(),ss=n+q,qq=0;
    for(int i=1;i<=ss;i++)
    {
        a[i]=new bot();
        a[i]->nxt=NULL;
        a[i]->pre=NULL;
        a[i]->val=0;
        a[i]->Stat=-i;
        b[i]=a[i];
    }
    for(int i=1;i<=n;i++)
    {
        int s=read();
        while(s--)
        {
            int x=read();
            sz[i]++;
            b[i]->nxt=new bot();
            b[i]->nxt->pre=b[i];
            b[i]=b[i]->nxt;
            b[i]->val=++qq;
            b[i]->nxt=NULL;
            b[i]->Stat=i;
        }
    }
    for(int i=1;i<=q;i++)
    {
        int op=read();
        // printf("op %d\n",op);
        if(op==1)
        {
            int i=read(),x=read();
            sz[i]++;
            b[i]->nxt=new bot();
            b[i]->nxt->pre=b[i];
            b[i]=b[i]->nxt;
            b[i]->val=++qq;
            b[i]->nxt=NULL;
            b[i]->Stat=i;
        }
        else if(op==2)
        {
            int i=read();
        }
        else if(op==4)//
        {
            int x=read(),y=read(),z=read();
            sz[z]=sz[x]+sz[y];
            a[z]->nxt=a[x];
            a[x]->pre=a[z];
            b[x]->nxt=a[y];
            a[y]->pre=b[x];
            b[z]=b[y];
        }
        else 
        {
            int s=read();
            while(s--)read();
            //TODO.
        }
    }
    assert(qq<=1000000);
    int kk=0;
    for(int i=1;i<=ss;i++)
    {
        if(a[i]->pre==NULL)
        {
            bot *x=a[i];
            while(x)
            {
                // printf("%d ",x->Stat);
                if(x->Stat<0)s2[-x->Stat]=kk+1;
                else pos[x->val]=++kk;
                x=x->nxt;
            }
        }
        // puts("");
    }
    // for(int i=1;i<=ss;i++)printf("%d %d\n",s2[i],sz[i]);
    for(int i=1;i<=ss;i++)
    {
        if(a[i]->pre==NULL)del(a[i]);
    }
    // -------------------------------------------------------------------------
    
    for(int i=1;i<=ss;i++)
    {
        a[i]=new bot();
        a[i]->nxt=NULL;
        a[i]->pre=NULL;
        a[i]->val=0;
        a[i]->Stat=-i;
        b[i]=a[i];
        zs[i]=sz[i];
        sz[i]=0;
    }
    #define read rd
    read(),read();
    int qqq=0;
    for(int i=1;i<=n;i++)
    {
        int s=read();
        while(s--)
        {
            int x=read();
            sz[i]++;
            b[i]->nxt=new bot();
            b[i]->nxt->pre=b[i];
            b[i]=b[i]->nxt;
            b[i]->val=++qqq;
            b[i]->nxt=NULL;
            b[i]->Stat=x;
            // mp[i][x]++;
            dx.jyws(head[i],0,ss,b[i]->Stat,1);
            shaya.shik(1,1,1000000,pos[qqq],x);
        }
    }
    for(int i=1;i<=q;i++)
    {
        int op=read();
        // printf("op %d\n",op);
        if(op==1)
        {
            int i=read(),x=read();
            sz[i]++;
            b[i]->nxt=new bot();
            b[i]->nxt->pre=b[i];
            b[i]=b[i]->nxt;
            b[i]->val=++qqq;
            b[i]->nxt=NULL;
            b[i]->Stat=x;
            // mp[i][x]++;
            dx.jyws(head[i],0,ss,b[i]->Stat,1);
            shaya.shik(1,1,1000000,pos[qqq],x);
        }
        else if(op==2)
        {
            int i=read();
            // mp[i][b[i]->Stat]--;
            sz[i]--;
            dx.jyws(head[i],0,ss,b[i]->Stat,-1);
            shaya.NIT(1,1,1000000,pos[b[i]->val]);
            b[i]=b[i]->pre;
            delete b[i]->nxt;
            b[i]->nxt=0;
        }
        else if(op==4)//
        {
            int x=read(),y=read(),z=read();
            sz[z]=sz[x]+sz[y];
            if(a[x]->nxt==0&&a[y]->nxt==0)
            {
            	
            }
            else if(a[x]->nxt==0)
            {
            	a[z]->nxt=a[y]->nxt;
            	a[y]->nxt->pre=a[z];
            	b[z]=b[y];
            }
            else if(a[y]->nxt==0)
            {
            	a[z]->nxt=a[x]->nxt;
            	a[x]->nxt->pre=a[z];        	
	            b[z]=b[x];
            }
            else
            {
            	a[z]->nxt=a[x]->nxt;
            	a[x]->nxt->pre=a[z];
            	b[x]->nxt=a[y]->nxt;
            	a[y]->nxt->pre=b[x];
	            b[z]=b[y];
            }
            a[x]->nxt=0;
            a[y]->nxt=0;
            dx.merge(head[x],head[y],0,ss),head[z]=head[x];
            // if(mp[x].size()<mp[y].size())std::swap(x,y);
            // mp[z].swap(mp[x]);
            // for(auto Q:mp[y])mp[z][Q.first]+=Q.second;
            // mp[y].clear();
        }
        else 
        {
            int s=read();
            shaya.vl[0]=-1,shaya.cc[0]=0;
            int S=0;
            int t=s,DD=dd;
            while(s--)
            {
                int x=read();
                S+=sz[x];
                if(zs[x])shaya.gyh(1,1,1000000,s2[x],s2[x]+zs[x]-1);
                // printf("(%d %d)\n",s2[x],s2[x]+zs[x]-1);
            }
            //-1 judge..
            int x=shaya.vl[0];
            if(x==-1);else{
                dd=DD;int ca=0;
                while(t--)
                {
                    int xx=read();
                    if(ca<=S)ca+=2*dx.jyws(head[xx],0,ss,x);
                }
                if(ca<=S)x=-1;
            }
            printf("%d\n",x);
            //TODO.
        }
        // for(int i=1;i<=ss;i++)printf("%d ",shaya.dbg[i]);puts("");
    }


    for(int i=1;i<=ss;i++)
    {
        if(a[i]->pre==NULL)del(a[i]);
    }
    return 0;
}
/*
2 8
3 1 1 2
3 3 3 3
3 1 1
3 1 2
4 2 1 3
3 1 3
2 3
3 1 3
1 3 1
3 1 3
*/

```

---

## 作者：FjswYuzu (赞：1)

送咱退役的题，不多讲了啊。

首先这个题众数有一个很好的性质，就是出现次数大于一半。这样可以使用摩尔投票法（也即对拼消耗）。

先考虑添加删除操作：这个很好做，直接维护序列，在末尾添加删除元素。

然后考虑合并：合并序列可以使用启发式合并，支持在前后加入元素。

但是这里出现了一个问题：我们要维护摩尔投票法的过程中，众数以及这个众数对拼消耗后剩下的次数，这个如果只在后面加入删除还是可以做的，但是启发式合并的时候我们**关心顺序**，这样可能在前面加入一些东西，这样就不能维护了。

事实上我们只关心这个序列长啥样，和整个序列摩尔投票后的结果。因此考虑用线段树动态维护，只需要将左右两个结点的结果合并看成两个序列合并，这个是很好处理的，同时也能处理掉加入一个数和删除一个数，总之只需要 $O(\log n)$ 就可以解决这样的问题了。同时摩尔投票合并的话就可以用线段树合并，序列要用一个支持在前后两端加入的数据结构，比如 ~~`std::deque`~~ `std::list`。

最后是查询。线段树维护摩尔投票的方法已经告诉我们可以支持序列合并摩尔投票法的结果，一样的处理就好了。最后求出来的众数可能不是众数，要重新算一遍确定是否真的是众数。注意这里要开 `long long`。

```cpp
list<int> a[1000005];
#define Mm int mid=(l+r)>>1
int cnt;
int lc[25000005],rc[25000005];
int maj[25000005],apc[25000005];
inline void push_up(int now)
{
	if(apc[lc[now]]==apc[rc[now]])	maj[now]=apc[now]=0;
	else if(apc[lc[now]]>apc[rc[now]])	maj[now]=maj[lc[now]],apc[now]=apc[lc[now]]-apc[rc[now]];
	else	maj[now]=maj[rc[now]],apc[now]=apc[rc[now]]-apc[lc[now]];
}
void modify(int l,int r,int &now,int p,int w)
{
	if(!now)	now=++cnt;
	if(l==r)
	{
		maj[now]=p;
		apc[now]+=w;
		if(!apc[now])	maj[now]=0;
		return ;
	}
	Mm;
	if(p<=mid)	modify(l,mid,lc[now],p,w);
	else	modify(mid+1,r,rc[now],p,w);
	push_up(now);
}
int merge(int x,int y,int l,int r)
{
	if(!x || !y)	return x|y;
	if(l==r)
	{
		apc[x]+=apc[y];
		if(apc[x])	maj[x]=l;
		return x;
	}
	Mm;
	lc[x]=merge(lc[x],lc[y],l,mid);
	rc[x]=merge(rc[x],rc[y],mid+1,r);
	push_up(x);
	return x;
}
int query(int l,int r,int now,int p)
{
	if(!now)	return 0;
	if(l==r)	return apc[now];
	Mm;
	if(p<=mid)	return query(l,mid,lc[now],p);
	return query(mid+1,r,rc[now],p);
}
int n,q,N;
int rt[1000005];
int seq[500005];
int main(){
	freopen("major4.in","r",stdin);
	freopen("major.out","w",stdout);
	n=read(),q=read(),N=n+q;
	for(int i=1;i<=n;++i)
	{
		int len=read();
		while(len-->0)
		{
			int x=read();
			a[i].push_back(x);
			modify(1,N,rt[i],x,1);
		}
	}
	while(q-->0)
	{
		int op=read();
		if(op==1)
		{
			int x=read(),y=read();
			a[x].push_back(y);
			modify(1,N,rt[x],y,1);
		}
		else if(op==2)
		{
			int x=read();
			int c=a[x].back();
			a[x].pop_back();
			modify(1,N,rt[x],c,-1);
		}
		else if(op==3)
		{
			int mj=0,ct=0;
			int len=read();
			for(int i=1;i<=len;++i)
			{
				int id=read();
				seq[i]=id;
				int pmj=maj[rt[id]],pnt=apc[rt[id]];
				if(!pmj)	continue;
				if(!mj)	mj=pmj,ct=pnt;
				else if(mj==pmj)	ct+=pnt;
				else
				{
					if(ct>pnt)	ct-=pnt;
					else if(ct<pnt)	mj=pmj,ct=pnt-ct;
					else	mj=ct=0;
				}
			}
			if(!mj)
			{
				puts("-1");
				continue;
			}
			LL siz=0,app=0;
			for(int i=1;i<=len;++i)
			{
				siz+=LL(a[seq[i]].size());
				app+=query(1,N,rt[seq[i]],mj);
			}
			if(app*2>siz)	write(mj),puts("");
			else	puts("-1");
		}
		else
		{
			int x=read(),y=read(),c=read();
			if(a[x].size()>a[y].size())
			{
				rt[c]=merge(rt[x],rt[y],1,N);
				a[c].swap(a[x]);
				for(auto it=a[y].begin();it!=a[y].end();++it)	a[c].push_back(*it);
			}
			else
			{
				rt[c]=merge(rt[x],rt[y],1,N);
				a[c].swap(a[y]);
				for(auto it=a[x].rbegin();it!=a[x].rend();++it)	a[c].push_front(*it);
			}
		}
	}
	return 0;
}
```

---

## 作者：ppip (赞：0)

[题目传送门](/problem/P8496)

纯线段树题解。

考虑对每一个序列维护一个权值线段树，1、2 操作就解决了。四操作也不难，就是个线段树合并板子。

但是 3 操作比较麻烦。考虑如果只查询一个序列的情况：

- 走到一个结点，判断这个结点的左儿子代表的这段值域的数个数，是否大于整个查询元素数和的一半；
- 如果是，递归求出左儿子的答案并返回；
- 否则，类似地去询问右儿子；
- 如果右儿子也不满足，返回 -1，因为不可能有数达到要求。

写成代码就是这样：

```cpp
// 指针请谅解，能看懂即可
// l是查询序列的元素数/2
long long l;
int query(pnode p,int L,int R) {
    if (R-L==1) return L;
    int mid{L+R>>1};
    if (p->l->sz>l) {
        return query(p->l,L,mid);
    }
    else if (p->r->sz>l) {
        return query(p->r,mid,R);
    }
    else return -1;
}
```

现在我们要查询多个序列的答案，其实不需要完整的合并这些线段树，只需要知道这条查询路径上的信息即可。

所以我们可以一边查询，一边求出这些线段树当前结点的信息。

也就是说，把上面对指针 `p` 的操作都变为对所有查询序列的指针操作，像这样：

```cpp
// 这种时候就非递归更好写了
// parse存储所有查询序列对应的那些指针，l同上
vector<pnode> parse;
long long l;
int query(int L,int R) {
    while (true) {
        if (R-L==1) return L;
        long long lsz{0},rsz{0};
        for (auto p:parse)
            lsz+=p->l->sz,rsz+=p->r->sz;
        int mid{L+R>>1};
        if (lsz>l) {
            for (auto& p:parse)
                p=p->l;
            R=mid;
        }
        else if (rsz>l) {
            for (auto& p:parse)
                p=p->r;
            L=mid;
        }
        else return -1;
    }
}
```

复杂度 $O(m\log n)$。

如此，我们再用链表维护一下实际的序列，这道题就结束了。

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read() {
    char c;int x,f{0};
    do x=(c=getchar())^48;
    while (!isdigit(c)&&c!='-');
    if (x==29) x=0,f=-1;
    while (isdigit(c=getchar()))
        x=(x<<3)+(x<<1)+(c^48);
    return (x^f)-f;
}
// 动态开点线段树板子
typedef struct tnode {
    tnode *l,*r;
    int sz;
}* pnode;
pnode nil{new tnode{0,0,0}};
void check(pnode& p){if(p==nil)p=new tnode{nil,nil,0};}
void Insert(pnode& p,int k,int v,int cnt) {
    check(p);
    p->sz+=v;
    if (cnt==1) return;
    int cp{cnt>>1};
    if (k<=cp) Insert(p->l,k,v,cp);
    else Insert(p->r,k-cp,v,cnt-cp);
}
void merge(pnode& p,pnode q) {
    if (q==nil) return;
    if (p==nil) {p=q;return;}
    p->sz+=q->sz;
    merge(p->l,q->l);merge(p->r,q->r);
    delete q;
}
vector<pnode> parse;
long long l;
int query(int L,int R) {
    while (true) {
        if (R-L==1) return L;
        long long lsz{0},rsz{0};
        for (auto p:parse)
            lsz+=p->l->sz,rsz+=p->r->sz;
        int mid{L+R>>1};
        if (lsz>l) {
            for (auto& p:parse)
                p=p->l;
            R=mid;
        }
        else if (rsz>l) {
            for (auto& p:parse)
                p=p->r;
            L=mid;
        }
        else return -1;
    }
}
const int N(5e5),V(1e6);
list<int> a[V+5];
pnode rt[V+5];
int main() {
    int n{read()},q{read()};
    int V{n+q};
    nil->l=nil->r=nil;
    for (int i{1};i<=n;++i) {
        rt[i]=nil;
        int l{read()};
        while (l--) {
            int x{read()};
            a[i].push_back(x);
            Insert(rt[i],x,1,V);
        }
    }
    while (q--) {
        int op{read()};
        if (op==1) {
            int x{read()},y{read()};
            a[x].push_back(y);
            Insert(rt[x],y,1,V);
        } else if (op==2) {
            int x{read()};
            Insert(rt[x],a[x].back(),-1,V);
            a[x].pop_back();
        } else if (op==3) {
            parse.clear();l=0;
            int L{read()};
            while (L--) {
                int x{read()};
                parse.push_back(rt[x]);
                l+=a[x].size();
            }
            l/=2;
            printf("%d\n",query(1,V+1));
        } else {
            int x1{read()},x2{read()},x3{read()};
            merge(rt[x1],rt[x2]);
            rt[x3]=rt[x1];
            a[x1].splice(a[x1].end(),a[x2]);
            swap(a[x1],a[x3]);
        }
    }
    return 0;
}
```

---

## 作者：luckydrawbox (赞：0)

## 分析

假如没有操作 $3$，怎么维护这些序列呢？由于修改只在末尾进行，于是我们可以仿照建图时的头插法将一个序列的数字插入邻接表中，这样 $head_x$ 就是序列 $x$ 的末尾了。

但是，操作 $4$ 的合并时，我们需要让 $x_2$ 的首个数字的 $nxt$ 指针指向 $x1$ 的末尾数字，因此可以再记录一个 $tail_x$ 表示邻接表的末尾（也就是序列 $x$ 的首个数字）：

```cpp
void add(int x,int y){
	val[++tot]=y;
	nxt[tot]=head[x];
	head[x]=tot;
	if(!nxt[tot])
		tail[x]=tot;
}
void del(int x){
	head[x]=nxt[head[x]];
	if(!head[x])
		tail[x]=0;
}
```

对于操作 $4$ 你可能会这么写：

```cpp
//x,y,z分别表示x1,x2,x3 
x=read();y=read();z=read();
head[z]=head[y];
tail[z]=tail[x];
nxt[tail[y]]=head[x];
```

然而交上去只有 $85$ 分，$\text{WA on \#13 \#19 \#20}$，原来题目中说的是 $l_i$ 为非负整数，后面的删除操作也可能使 $l_i$ 变为 $0$，这个 $0$ 则可能使邻接表中多出一个数字 $0$，切断了邻接表，因此必须加一些特判：

```cpp
//x,y,z分别表示x1,x2,x3 
x=read();y=read();z=read();
head[z]=(head[y]?head[y]:head[x]);
tail[z]=(tail[x]?tail[x]:tail[y]);
if(head[x]&&head[y])
	nxt[tail[y]]=head[x];
```

这样对序列的维护就解决了，接下来就是求众数，因为题目中要求众数的出现次数必须大于数的个数的一半，所以就可以用摩尔投票法解决，对于每个序列开一个动态开点权值线段树，维护一个区间的众数和它在摩尔投票中剩余的票数，向上传递信息时，众数为票数较大的那一个，剩余的票数就是多的减去少的。合并 $m$ 个序列时，只需要将 $m$ 颗线段树的众数用摩尔投票法合并即可，别忘了最后统计众数的出现的次数是否超过一半。

这样，对于操作 $1$，直接单点加，对于操作 $2$，我们用邻接表得到末尾数字并单点减，对于操作 $4$ 就可以线段树合并，这题就解决了。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
long long read(){
	long long x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
void write(long long x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
const int N=1e6+10;
int n,q,l[N],xx[N];
int head[N],nxt[N],val[N],tail[N],tot;
void add(int x,int y){
	val[++tot]=y;
	nxt[tot]=head[x];
	head[x]=tot;
	if(!nxt[tot])
		tail[x]=tot;
}
void del(int x){
	head[x]=nxt[head[x]];
	if(!head[x])
		tail[x]=0;
}
void cmp(pair<int,int> &x,pair<int,int> y,pair<int,int> z){
	if(y.first==z.first){
		x.first=y.first;
		x.second=y.second+z.second;
	}
    else if(y.second>z.second){
    	x.first=y.first;
		x.second=y.second-z.second;
	}
    else{
    	x.first=z.first;
		x.second=z.second-y.second;
	}
}
#define pl a[p].tl
#define pr a[p].tr
struct Segment_Tree{
    int tot,root[N],cnt,nc[N<<3];
    struct Tree{
        int tl,tr;
        int vsum;
        pair<int,int> zs;
    }a[N<<3];
    Segment_Tree(){
        tot=0;
    }
    int get_new(){
        return cnt?nc[cnt--]:++tot;
    }
    void del(int p){
        nc[++cnt]=p;
        a[p].tl=a[p].tr=a[p].zs.first=a[p].zs.second=a[p].vsum=0;
    }
    void pushup(int p){
    	cmp(a[p].zs,a[pl].zs,a[pr].zs);
        a[p].vsum=a[pl].vsum+a[pr].vsum;
    }
    void add(int p,int x,int v,int L,int R){
        if(L==R){
        	a[p].zs.first=L;
            a[p].zs.second+=v;
            a[p].vsum+=v;
            return;
        }
        int mid=(L+R)>>1;
        if(x<=mid){
            if(!pl)
                pl=get_new();
            add(pl,x,v,L,mid);
        }
        else{
            if(!pr)
                pr=get_new();
            add(pr,x,v,mid+1,R);
        }
        pushup(p);
    }
    int asksum(int p,int l,int r,int L,int R){
        if(l<=L&&R<=r)
            return a[p].vsum;
        int mid=(L+R)>>1;
        int ans=0;
        if(!pl)
            pl=get_new();
        if(!pr)
            pr=get_new();
        if(l<=mid)
            ans+=asksum(pl,l,r,L,mid);
        if(r>mid)
            ans+=asksum(pr,l,r,mid+1,R);
        return ans;
    }
    int merge(int x,int y,int l,int r){
        if(!x||!y)
            return x+y;
        if(l==r){
        	a[x].zs.first=l;
        	a[x].zs.second+=a[y].zs.second;
        	a[x].vsum+=a[y].vsum;
        	return x;
		}
		int mid=(l+r)>>1;
        a[x].tl=merge(a[x].tl,a[y].tl,l,mid);
        a[x].tr=merge(a[x].tr,a[y].tr,mid+1,r);
        del(y);
        pushup(x);
        return x;
    }
}tree;
int main(){
	n=read();q=read();
	for(int i=1;i<=n;i++){
		tree.root[i]=tree.get_new();
	}
	for(int i=1;i<=n;i++){
		l[i]=read();
		for(int j=1;j<=l[i];j++){
			int x=read();
			add(i,x);
			tree.add(tree.root[i],x,1,1,n+q);
		}
	}
	for(int i=1;i<=q;i++){
		ll op,m,x,y,z;
		op=read();
		if(op==1){
			x=read();y=read();
			add(x,y);
			tree.add(tree.root[x],y,1,1,n+q);
		}
		else if(op==2){
			x=read();
			tree.add(tree.root[x],val[head[x]],-1,1,n+q);
			del(x);
		}
		else if(op==3){
			m=read();
			pair<int,int>u;
			u.first=u.second=0;
			for(int j=1;j<=m;j++){
				xx[j]=read();
				cmp(u,u,tree.a[tree.root[xx[j]]].zs);
			}
			if(!u.first){
				puts("-1");
				continue;
			}
			x=0;y=0;
			for(int j=1;j<=m;j++){
				x+=tree.asksum(tree.root[xx[j]],1,n+q,1,n+q);
				y+=tree.asksum(tree.root[xx[j]],u.first,u.first,1,n+q);
			}
			if(y*2>x){
				write(u.first);
				puts("");
			}
			else{
				puts("-1");
			}
		}
		else{
			//x,y,z分别表示x1,x2,x3 
			x=read();y=read();z=read();
			tree.root[z]=tree.get_new();
			tree.merge(tree.root[z],tree.root[x],1,n+q);
			tree.merge(tree.root[z],tree.root[y],1,n+q);
			head[z]=(head[y]?head[y]:head[x]);
			tail[z]=(tail[x]?tail[x]:tail[y]);
			if(head[x]&&head[y])
				nxt[tail[y]]=head[x];
			
		}
	}
	return 0;
}
```

---


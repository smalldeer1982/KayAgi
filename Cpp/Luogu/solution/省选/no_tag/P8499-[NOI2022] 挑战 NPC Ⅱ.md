# [NOI2022] 挑战 NPC Ⅱ

## 题目描述

诸由杨是一名咸鱼大学生，虽然他每天仍然幻想着在多项式时间内解决 NPC 问题。

诸由杨上课的时候了解到子图同构问题是一个 NPC 问题。他打算给出一个子图同构问题的多项式判定算法，间接地去证明 P = NP，这样他一定可以凭借这个伟大的工作荣获图灵奖！只可惜诸由杨才疏学浅，连子图同构问题属于 NPC 的证明都没有想出来。因而他退而求其次，准备判定一个更加简单的问题：

给定两棵有根树 $G, H$。设 $\lvert G \rvert$ 代表树 $G$ 中的节点个数，则这两棵树满足如下限制：$1 \leq \lvert H \rvert \leq \lvert G \rvert \leq \lvert H \rvert + k$。这里诸由杨保证 $k$ 是一个小常数。

诸由杨可以删除 $G$ 中的若干个节点，假定删除节点后后得到的子图为 $G'$。他想要知道是否存在一种删除节点的方式，使得删除后得到的子图 $G'$ 满足如下条件：

- $G'$ 连通。
- $G'$ 包含 $G$ 中的根节点（也就是说 $G$ 根节点在删除过程中没有被删除）。
- $G'$ 和 $H$ 同构（也就是说存在一种让 $G'$ 中点重标号的方式，使得重标号得到的图和 $H$ 完全相同，且 $G$ 中的根节点经过重标号后恰好为 $H$ 的根节点）。

## 说明/提示

**【样例解释 \#1】**

对于第一个测试点，我们删除第一棵树的 $1$ 号节点。此时剩余的树和输入第二棵树均为包含两个节点的有根树，因而输出为 `Yes`。

![](https://cdn.luogu.com.cn/upload/image_hosting/vyoktd4u.png)


对于第二个测试点，输入第一颗树深度为 $1$，但是输入第二颗树深度为 $2$。因而不论如何删除第一颗树的节点不会导致其树高增加到 $2$，因而输出为 `No`。

![](https://cdn.luogu.com.cn/upload/image_hosting/r1szu0zb.png)

对于第三个测试点，其输入两颗树均同构于下图的树，因而因而输出为 `Yes`。

![](https://cdn.luogu.com.cn/upload/image_hosting/kxyllt4y.png)

----

**【样例 \#2】**

见附件中的 `iso/iso2.in` 与 `iso/iso2.ans`。

该样例数据范围满足测试点 $7 \sim 8$。

----

**【样例 \#3】**

见附件中的 `iso/iso3.in` 与 `iso/iso3.ans`。

该样例数据范围满足测试点 $9 \sim 10$。

----

**【样例 \#4】**

见附件中的 `iso/iso4.in` 与 `iso/iso4.ans`。

该样例数据范围满足测试点 $13$。

----

**【数据范围】**

对于所有测试数据，满足 $1 \leq T \leq 500$，$1 \le n_2 \leq n_1 \le {10}^5$，$\sum n_1 \leq 5 \times {10}^5$，$0 \leq k \leq 5$。各测试点的附加限制如下表所示：

| $n_1,n_2$   | $\sum n_1$           | 测试点           | $k$      | 特殊性质         |
|:-----------:|:--------------------:|:-------------:|:--------:|:------------:|
| $\leq 8$    | $\leq 500$           | $1 \sim 3$       | $\leq 0$ | 无            |
| $\leq 8$    | $\leq 500$           | $4 \sim 6$       | $\leq 5$ | 无            |
| $\leq 16$   | $\leq 10^3$          | $7 \sim 8$         | $\leq 0$ | 无            |
| $\leq 16$   | $\leq 10^3$          | $9 \sim 10$        | $\leq 5$ | 无            |
| $\leq 150$  | $\leq 10^4$          | $11$          | $\leq 0$ | 无            |
| $\leq 150$  | $\leq 10^4$          | $12$          | $\leq 1$ | 无            |
| $\leq 150$  | $\leq 10^4$          | $13$          | $\leq 5$ | 无            |
| $\leq 10^5$ | $\leq 5 \times 10^5$ | $14 \sim 16$    | $\leq 0$ | A |
| $\leq 10^5$ | $\leq 5 \times 10^5$ | $17 \sim 20$ | $\leq 0$ | B  |
| $\leq 10^5$ | $\leq 5 \times 10^5$ | $21$          | $\leq 1$ | 无            |
| $\leq 10^5$ | $\leq 5 \times 10^5$ | $22 \sim 23$       | $\leq 3$ | 无            |
| $\leq 10^5$ | $\leq 5 \times 10^5$ | $24 \sim 25$       | $\leq 5$ | 无            |

其中附加限制中的特殊性质如下所示：

- 特殊性质 A：保证有根树 $G$ 每个节点要么是叶节点，要么有恰好 $1$ 个儿子结点；另一种等价的表述是有根树 $G$ 构成了一条链，且根节点为链的一个端点。
- 特殊性质 B：保证有根树 $G$ 每个节点要么是叶节点，要么有恰好 $2$ 个儿子结点，同时保证 $G$ 的每一个叶节点深度均相同；另一种等价的表述是有根树 $G$ 构成一棵完全二叉树，且根节点为完全二叉树的根节点。

**【提示】**

数据没有**针对任何合理的哈希算法做任何针对性的构造**，所以在合理范围内不需要过度担心因为哈希碰撞而产生的失分问题。

## 样例 #1

### 输入

```
0 3 1
3
2 -1 2
2
-1 1
4
3 3 -1 3
3
2 3 -1
5
-1 1 5 5 1
5
2 3 -1 3 2
```

### 输出

```
Yes
No
Yes
```

# 题解

## 作者：大头 (赞：27)

出题人答


首先求出 $G,H$ 每颗子树的哈希值用于判断子树同构问题。接下来给定分别在 $G,H$ 中的节点 $x_1,x_2$, 假定我们需要递归的判定如下子问题，设为 $f(x_1,x_2)$:

是否存在这么一种运行方式，使得：
* 重复如下过程若干轮，每一轮选择 $G$ 以 $x_1$ 为根的子树的一个叶子，并将其移除。
* 删除上述节点后，剩余的有根子树和 $H$ 以 $x_2$ 为根的子树同构。

首先我们将 $x_1,x_2$ 同构的子树做贪心配对，如果在某个最终匹配方案中，
$G$ 中子树 $a$ 在删除若干节点后和 $H$ 的子树 $b$ 同构，
$G$ 中子树 $b$ 在删除若干节点后和 $H$ 的子树 $c$ 同构(相同的小写字母代表着是同构的有根子树)，则我们可以直接让 $H$ 中子树 $a$ 在删除后和 $H$ 的子树 $c$ 同构，同时不去修改 $G$ 的子树 $b$ 并且和 $H$ 的子树 $b$ 匹配。上述操作合法性不难得到。

因而不妨假定最后未匹配的子树个数至多为 $k$ (由于我们只修改了 $k$ 个节点，若不然必然无解)，直接暴力枚举 $k^2$ 个可能的子树同构对后检查是否存在完美匹配即可。

接下来我们可以增加一些剪枝:
* 如果两颗子树哈希值相同，则返回匹配
* 如果两颗子树哈希值不同，大小相同，则返回不匹配
* 如果 $G$ 的子树大小小于 $H$ 的子树大小，则返回不匹配
* 假设已经知道未匹配的子树数为 $m$，两棵树大小差为 $k$。如果子问题中两颗子树大小差大于 $k - (m - 1)$，则返回不匹配。

接下来我们证明在采用上述剪枝的前提下，对于每一个 $G,H$ 中的节点，其出现在求解子问题中的次数不会很多即可。我们递归地证明，假定我们搜索到了子问题 $f(x_G,y_H)$，两棵树的大小差为 $k$，则对于任意一个属于子树 $x_G$ 的节点 $x$，至多只有 $\max(1,2^{k-1})$ 个可能的属于子树 $y_H$ 的节点 $x_2 \in V_2$，使得在搜索过程中搜索到了子问题 $(x,y)$.

* 如果 $k = 0$，我们只需要直接判定两棵树的哈希值是否相同，显而易见其甚至不需要递归操作，性质成立。
* 如果 $k = 1$，根据约束条件知道如果可以匹配则我们每个子树中都至多能够找到 $1$ 个匹配不到的节点。因而产生的子问题唯一，从而每个节点至多出现在一次询问中，性质成立
* 如果 $k \neq 1$，假定其有 $m$ 个未匹配问题。如果 $m = 1$ 则子问题唯一对，对子问题进行归纳即可。如果 $m > 1$，则每个没有被剪掉的子问题中，两棵子树大小之差至多为 $k - (m - 1) \ge 1$，同时每一个 $x$ 最多出现在其所在的子树出现的 $m$ 个子问题之中。因而根据归纳，搜索到的子问题至多有 $\max_{m > 2} m 2^{k - (m - 1) - 1} = 2^{k-1}$ 个，归纳成立。

因此我们可以直接采用类似于归并的方式求出不匹配的子树，然后根据上述剪枝规则剪枝即可。检查完美匹配可以匈牙利，可以 Hall Theorem,可以 爆搜，在 $k$ 较小的情况下几乎只是常数的区别。

以 Hall Thm 为例，其总时间复杂度为 $O(n 4^k)$，足以通过本题。

---

## 作者：Alex_Wei (赞：19)

> D2T1. [P8499 [NOI2022] 挑战 NPC Ⅱ](https://www.luogu.com.cn/problem/P8499)

首先题目已经明示树哈希了，我们需要一个正确的树哈希方法解决树同构问题。

设树哈希函数 $f$，需满足若 $T_1 \cong T_2$，则 $f(T_1) = f(T_2)$，否则极大概率 $f(T_1) \neq f(T_2)$。

对于有根树 $G, H$，设它们的根分别为 $R_G$ 和 $R_H$，其子节点集合分别为 $S(R_G)$ 和 $S(R_H)$，易得另一种描述同构的方法为 $G\cong H$ 当且仅当

- $|S(R_G)| = |S(R_H)|$。
- 存在一种 $S(R_G) \to S(R_H)$ 的 **双射** $I$，使得对于任意 $g\in S(R_G)$，$g\cong I(g)$。

说人话就是根节点儿子数量相等，且存在两棵树的根儿子的一一对应关系，使得对应儿子子树同构。这样我们就将问题缩小至儿子子树的规模，这给予我们树形 DP 的思路。

具体地，设 $f_G(i)$ 表示 $G$ 以 $i$ 为根的子树的哈希值，转移时考虑当前节点 $x$ 及其所有子节点 $y$。回顾上述结论，我们发现它提出了这样的要求：**父节点哈希值与所有子节点相关，但与子节点顺序无关**。做到这一点即可满足对于任意 $T_1\cong T_2$，$f(T_1) = f(T_2)$。

因此，我们需要用 **具有交换律** 的运算结合所有 $f_G(y)$，以消除各个子节点之间的顺序。容易想到加法或乘法，即 $f_G(x) = \sum f_G(y)$ 或 $f_G(x) = \prod f_G(y)$。但是这样冲突概率较大，我们需要进行一些改进。笔者的写法是 $f_G(x) = (P_1 + B ^ {|son_G(x)|}\prod f_G(y))\bmod P_2$，将乘法和加法结合起来，更不容易冲突，其中 $B, P_1, P_2$ 都是自选的一些质数。

搞定了树同构，让我们回到原问题。注意到 $k$ 很小，所以也许爆搜 + 剪枝 + 记忆化就可以了？

设 $f(x, y)$ 表示 $G$ 以 $x$ 为根的子树删去若干节点后能否同构于 $H$ 以 $y$ 为根的子树。看似需要做一遍二分图匹配，但注意到若 $a\in son_G(x)$ 的子树同构于 $b\in son_H(y)$ 的子树，我们可以直接将它们匹配掉。

证明：不妨设 $a$ 和 $b'$ 对应，$a'$ 和 $b$ 对应，若 $a\cong b'$，则交换 $b, b'$ 仍成立，对于 $a'\cong b$ 同理。因此 $a$ 删去若干节点同构于 $b'$，$a'$ 删去若干节点同构于 $b$。因为 $a, b$ 同构，所以容易根据 $a'$ 变成 $b$ 和 $a$ 变成 $b'$ 的方案构造出 $a'$ 变成 $b'$ 的方案，这样 $a$ 仍可匹配 $b$。换言之，在最终匹配方案中，我们总可以通过调整使得 $a, b$ 匹配。

因此，不断删去 $son_G(x)$ 和 $son_H(y)$ 之间同构的元素，得到 $I_G(x)$ 和 $I_H(y)$。由于这两个集合之间两两不同构，所以对于每个 $a\in I_G(x)$，都需要在其子树内删去至少一个节点，甚至删空，可知 $|I_G(x)| \leq sz_x - sz_y$。考虑直接全排列枚举所有可能的匹配，递归到子问题处理。

注意递归处理前需要判一下是否存在 $a\in I_G(x)$ 和 $b\in I_H(y)$ 满足 $sz_a \leq sz_b$，此时直接不合法，否则可能导致 $sz_x - sz_y$ 变大，复杂度看起来就不正确。

加入上述剪枝后复杂度看起来很对，因为 $k\leq 5$。时间复杂度一个比较松的上界是 $\mathcal{O}(nk!k)$，如果用 map 做记忆化还要多一个 $\log$，但这个 $\log$ 不是直接乘在 $nk!k$ 上面，所以常数很小，或者说时间复杂度可以更紧，但已经足够了。

Upd：实际上复杂度是 $\mathcal{O}(n2 ^ k)$，每次令 $sz_{a_1} = C + k - 1$，$sz_{a_2} = C + 1$，$sz_{b_1} = sz_{b_2} = C$ 即可令 $k$ 减去 $1$ 但情况数乘 $2$，卡满上界。枚举全排列换成网络流即可将匹配复杂度做到 $\mathcal{O}(\mathrm{poly}(k))$，注意判不合法：若 $a, b$ 匹配后不存在对于所有 $a'$ 和 $b'$ 均有 $sz_{a'} > sz_{b'}$ 的匹配，则 $f(a, b)$ 就是无用的，不能递归。

好玄学啊这题，树哈希和时间复杂度分析都很玄学。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define TIME 1e3 * clock() / CLOCKS_PER_SEC
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
inline int read() {
  int x = 0, sgn = 0;
  char s = getchar();
  while(!isdigit(s)) sgn |= s == '-', s = getchar();
  while(isdigit(s)) x = x * 10 + s - '0', s = getchar();
  return sgn ? -x : x;
}
inline void print(int x) {
  if(x < 0) return putchar('-'), print(-x);
  if(x >= 10) print(x / 10);
  putchar(x % 10 + '0');
}
bool Mbe;
constexpr int N = 1e5 + 5;
constexpr int base = 131;
constexpr int mod = 1e9 + 7;
int C, T, k, pw[N];
vector<int> G[N], H[N];
struct solver {
  vector<int> e[N];
  int n, R, f[N], sz[N];
  void dfs(int id) {
    f[id] = pw[e[id].size()], sz[id] = 1;
    for(int it : e[id]) dfs(it), f[id] = 1ll * f[id] * f[it] % mod, sz[id] += sz[it];
    f[id] = (f[id] + 19260817) % mod;
    sort(e[id].begin(), e[id].end(), [&](int x, int y) {return f[x] < f[y];});
  }
  void init() {
    n = read();
    for(int i = 1; i <= n; i++) e[i].clear();
    for(int i = 1; i <= n; i++) {
      int ff = read();
      if(ff != -1) e[ff].push_back(i);
      else R = i;
    }
    dfs(R);
  }
} g, h;
map<int, int> f[N];
bool dfs(int x, int y) {
  if(g.e[x].size() < h.e[y].size()) return 0;
  if(g.sz[x] == h.sz[y]) return g.f[x] == h.f[y];
  if(f[x].find(y) != f[x].end()) return f[x][y];
  vector<int> gson, hson;
  int pg = 0, ph = 0;
  auto grt = [&]() {gson.push_back(g.e[x][pg++]);};
  auto hrt = [&]() {hson.push_back(h.e[y][ph++]);};
  while(pg < g.e[x].size() && ph < h.e[y].size()) {
    if(g.f[g.e[x][pg]] == h.f[h.e[y][ph]]) pg++, ph++;
    else if(g.f[g.e[x][pg]] < h.f[h.e[y][ph]]) grt();
    else hrt();
  }
  while(pg < g.e[x].size()) grt();
  while(ph < h.e[y].size()) hrt();
  int cut = g.sz[x] - h.sz[y];
  if(gson.size() > cut) return 0;
  vector<int> p(gson.size());
  for(int i = 0; i < gson.size(); i++) p[i] = i;
  do {
    bool ok = 1;
    for(int i = 0; i < hson.size(); i++) ok &= g.sz[gson[p[i]]] > h.sz[hson[i]];
    if(!ok) continue;
    for(int i = 0; i < hson.size(); i++) ok &= dfs(gson[p[i]], hson[i]);
    if(ok) return f[x][y] = 1;
  } while(next_permutation(p.begin(), p.end()));
  return f[x][y] = 0;
}
void solve() {
  g.init(), h.init();
  for(int i = 1; i <= g.n; i++) f[i].clear();
  puts(dfs(g.R, h.R) ? "Yes" : "No");
}
bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  #ifdef ALEX_WEI
    FILE* IN = freopen("d.in", "r", stdin);
    FILE* OUT = freopen("d.out", "w", stdout);
  #endif
  for(int i = pw[0] = 1; i < N; i++) pw[i] = 1ll * pw[i - 1] * base % mod;
  C = read(), T = read(), k = read();
  while(T--) solve();
  cerr << TIME << " ms\n";
  return 0;
}
/*
2022/8/29
author: Alex_Wei
start coding at 8:55
finish debugging at 9:14
*/
```



---

## 作者：Fan_sheng (赞：11)

简单题。

由于 $k$ 很小，所以 $G$ 的很多子树是不需要修改的，考虑删掉这些不需要修改的部分来加速。

首先分别对 $G,H$ 树哈希一遍。

用 $d(a,b)$ 表示把 $G$ 中的 $a$ 子树修改成 $H$ 中的 $b$ 子树所需的最小修改次数，按如下流程递归：

- 特判：如果 $a$ 子树的节点个数比 $b$ 子树少（即 $size[a]<size[b]$），或者 $a$ 的儿子个数比 $b$ 少（即 $deg[a]<deg[b]$），显然**无论如何都无法完成修改**，返回 $\inf$ 即可。

- 特判：如果 $b$ 是叶子节点，那么我们来到了一个边界情况，修改方式只有一种，就是删掉 $a$ 的所有子孙。返回 $size[a]-1$ 即可。

对于其他情况：

- 每层递归新建两个容器 $A,B$。尝试两两匹配 $a$ 的儿子和 $b$ 的儿子。把 $a$ 无法匹配的儿子放入 $A$，$b$ 无法匹配的儿子放入 $B$。

![](https://cdn.luogu.com.cn/upload/image_hosting/54igvxbb.png)

举个例子，$2,5$ 是完全相同的子树，$3,4$ 是完全相同的子树，不需要任何修改，忽略就好了。把 $1,6$ 放入 $A$ 中，$7$ 放入 $B$ 中。（虽然 $6,4$ 相同，但 $4$ 已匹配）

通过二分查找哈希值之类的方法可以快速实现上面的过程。

要使 $a$ 子树与 $b$ 子树相同，我们发现，现在任务变成了**对 $A$ 中子树进行修改，使得其能够与 $B$ 完全匹配**。

- 由于 $A,B$ 大小不可能超过 $k$，可以暴力全排列，钦定把 $A[i]$ 子树修改成 $B[j]$ 子树。

- 如果 $B[j]$ 存在，需要的修改次数就是 $d(A[i],B[j])$；如果 $B[j]$ 不存在（因为 $A$ 中元素可能比 $B$ 多），实际上就是把 $A[i]$ 删空，需要的修改次数是 $size[A[i]]$。最后加起来就是一种排列方式的答案。

- 于是 $d(a,b)$ 就是所有排列的最小值。

最后判断 $d(root[G],root[H])$ 是否 $\le k$ 即可。

Code

代码里有一个比较重要的剪枝：

```dfs(a,b,limit)```，表示计算 $d(a,b)$，且当前**至多**只能再进行 $limit$ 次修改。初始 $limit=k$。

如果 $A$ 中元素个数（```A.size()```）超过了 $limit$ 个，直接返回 $\inf$。因为每个元素**起码**会消耗一次修改。

然后递归下去的时候就是 ```dfs(A[i],B[j],limit-A.size()+1)```，$+1$ 是因为不能扣掉 $A[i]$ 自己这一次。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int base=23,mod=1e9+7,inf=10;
int C,T,k,n,m,pw[100005];
inline int add(int n){return n>=mod?n-mod:n;}
struct star{
	int root,f[100005],sz[100005];
	vector<int>edge[100005];
	void gethash(int id){//树哈希 
		sz[id]=1,f[id]=0;
		if(!edge[id].size()){f[id]=1;return;}
		for(int v:edge[id])gethash(v),sz[id]+=sz[v];
		sort(edge[id].begin(),edge[id].end(),[&](int a,int b){return f[a]<f[b];});
		for(int i=0;i<edge[id].size();i++)
		f[id]=add(f[id]+1ll*f[edge[id][i]]*pw[i]%mod);
		f[id]=1ll*f[id]*sz[id]%mod;
	}
}G,H;
int dfs(int a,int b,int limit){
	if(G.sz[a]<H.sz[b]||G.edge[a].size()<H.edge[b].size())return inf;//特判 
	if(H.sz[b]==1)return G.sz[a]-1;//特判 
	
	vector<pair<int,int>>A,B;//这里采用了pair和lower_bound的形式计算A,B，看上去比较丑 
	for(int v:H.edge[b])B.emplace_back(make_pair(H.f[v],v));
	for(int v:G.edge[a]){
		auto pos=lower_bound(B.begin(),B.end(),make_pair(G.f[v],0));
		if(pos!=B.end()&&(*pos).first==G.f[v])B.erase(pos);
		else A.emplace_back(make_pair(G.f[v],v));
	}
	if(A.size()>limit)return inf;//剪枝 
	
	int cost[8][8],order[8]={0,1,2,3,4,5,6,7},ans=inf;
	for(int i=0;i<A.size();i++)
	for(int j=0;j<B.size();j++)cost[i][j]=dfs(A[i].second,B[j].second,limit-A.size()+1);//cost[i][j]:A[i]修改成B[j]的最少修改次数 
	do{//全排列，A[i]匹配B[order[i]] 
		int res=0;
		for(int i=0;i<A.size()&&res<ans;i++)//小剪枝 
		res+=(order[i]<B.size())?cost[i][order[i]]:G.edge[A[i].second].size();//注意判断B[order[i]]是否存在 
		ans=min(ans,res);
	}while(next_permutation(order,order+A.size()));
	return ans;
}
int main(){
	scanf("%d%d%d",&C,&T,&k),pw[0]=1;
	for(int i=1;i<=100000;i++)pw[i]=1ll*pw[i-1]*base%mod;
	while(T--){
		scanf("%d",&n);
		for(int i=1;i<=n;i++)G.edge[i].clear();
		for(int i=1,tmp;i<=n;i++){
			scanf("%d",&tmp);
			if(tmp<0)G.root=i;
			else G.edge[tmp].emplace_back(i);
		}
		scanf("%d",&m);
		for(int i=1;i<=m;i++)H.edge[i].clear();
		for(int i=1,tmp;i<=m;i++){
			scanf("%d",&tmp);
			if(tmp<0)H.root=i;
			else H.edge[tmp].emplace_back(i);
		}
		G.gethash(G.root),H.gethash(H.root);
		printf("%s\n",dfs(G.root,H.root,k)<=k?"Yes":"No");
	}return 0;
}
```


---

## 作者：FjswYuzu (赞：10)

相信树哈希大家在考场上都会（大嘘），所以我们直接讲做法。

注意到这个 $k$ 比较小，猜测复杂度是 $O(nF(k))$ 的，其中 $F(k)$ 是一个在 $k \leq 5$ 的情况下很小的函数。

如果沿用一般题目的做法，比如考虑使用支持撤销一些结点的哈希，那就错啦！我们避免不了各种巨大在虚树结点上合并的讨论，考虑一些其他的做法。

假设我们现在在两棵树的根上，我们如何初步判断这两棵树是不是只差 $k$ 个结点呢？

一个直观的暴力是直接暴力枚举哪棵子树匹配哪棵子树，然后向下递归，并删去多余的子树。但是一个菊花就能把我们卡得生不如死，怎么办？

我们尝试先匹配那些哈希值相同的子树，剩下的子树都是至少要被删去一个的。这样一定正确且不会更劣。

这样的话一个结点就只剩下最多五个子树了，暴力枚举排列，然后向下递归，继续暴力判断。复杂度不会太大吧（心虚）。实际上有个粗略的界限是 $O(n\prod_{i=1}^k k!)$。

此题没特殊卡树哈希，实际上在处理中可以把子树大小和深度等带入提高正确性。

```cpp
const int MOD1=1e9+7,MOD2=1e9+9;
typedef pair<int,int> P;
#define mp make_pair
inline P operator + (P x,P y){return mp((x.first+y.first)%MOD1,(x.second+y.second)%MOD2);}
inline P operator - (P x,P y){return mp((x.first+MOD1-y.first)%MOD1,(x.second+MOD2-y.second)%MOD2);}
inline P operator * (P x,P y){return mp(LL(x.first)*LL(y.first)%MOD1,LL(x.second)*LL(y.second)%MOD2);}
const P w=mp(131,131);
vector<int> G[1000005],H[1000005];
int n,m;
P hg[1000005],hh[1000005];
int sig[1000005],sih[1000005];
int d;
void dfsg(int u)
{
	sig[u]=1,hg[u]=mp(1,1);
	for(auto v:G[u])
	{
		dfsg(v);
		hg[u]=hg[u]*(mp(1,1)+w*hg[v]);
		sig[u]+=sig[v];
	}
}
void dfsh(int u)
{
	sih[u]=1,hh[u]=mp(1,1);
	for(auto v:H[u])
	{
		dfsh(v);
		hh[u]=hh[u]*(mp(1,1)+w*hh[v]);
		sih[u]+=sih[v];
	}
}
int check(int g,int h,int c)
{
	if(hg[g]==hh[h])	return 0;
	sort(G[g].begin(),G[g].end(),[&](int x,int y){return hg[x]<hg[y];});
	sort(H[h].begin(),H[h].end(),[&](int x,int y){return hh[x]<hh[y];});
	vector<int> Idg,Idh;
	int p=0;
	for(int i=0;i<(int)G[g].size();++i)
	{
		P st=hg[G[g][i]];
		while(p<int(H[h].size()) && hh[H[h][p]]<st)	Idh.push_back(H[h][p]),++p;
		if(p<int(H[h].size()) && hh[H[h][p]]==st)
		{
			++p;
			continue;
		}
		Idg.push_back(G[g][i]);
	}
	for(int i=p;i<int(H[h].size());++i)	Idh.push_back(H[h][i]);
	if(Idh.size()>Idg.size())	return 100;
	if(int(Idg.size())+c>d)	return 100;
	sort(Idg.begin(),Idg.end());
	int res=100;
	do
	{
		int pc=c;
		for(int i=0;i<int(Idh.size());++i)
		{
			if(sig[Idg[i]]<sih[Idh[i]])	goto fail;
			pc+=sig[Idg[i]]-sih[Idh[i]];
		}
		for(int i=int(Idh.size());i<int(Idg.size());++i)	pc+=sig[Idg[i]];
		if(pc<=d)
		{
			for(int i=0;i<int(Idh.size());++i)	if(check(Idg[i],Idh[i],pc-sig[Idg[i]]+sih[Idh[i]])==100)	goto fail;
			res=min(res,pc);
		}
		fail:;
	}while(next_permutation(Idg.begin(),Idg.end()));
	return res;
}
int main(){
	read();
	int T=read();
	read();
	while(T-->0)
	{
		int rtg=0,rth=0;
		n=read();
		for(int i=1;i<=n;++i)	G[i].clear();
		for(int i=1;i<=n;++i)
		{
			int c=read();
			if(c==-1)	rtg=i;
			else	G[c].push_back(i);
		}
		m=read();
		for(int i=1;i<=m;++i)	H[i].clear();
		for(int i=1;i<=m;++i)
		{
			int c=read();
			if(c==-1)	rth=i;
			else	H[c].push_back(i);
		}
		d=n-m;
		dfsg(rtg),dfsh(rth);
		puts(check(rtg,rth,0)<=d?"Yes":"No");
	}
	return 0;
}
```

---

## 作者：WeLikeStudying (赞：6)

- 题目的提示信息很强。
- 是一道很适合坐下来想一想的练习题？
- 似乎是复杂度比较明显而严格的做法。

**[题意](https://www.luogu.com.cn/problem/P8499)**
- 经典的子图同构问题，只不过判断的是两棵点数相差不超过 $5$ 的有根树。

**分析**
- 题面告诉我不卡哈希，说明正解就是哈希（其实这种题目我通常也会使用比较灵活的哈希做法）。
- 运用[这题](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/solution-p4895)做法，我们可以在 $O(1)$ 时间判定给定的两个子树是否同构。
- 接下来我们尝试进行更加复杂一点的判定，判定一棵子树 $v$ 是否与 $u$ 的某棵子树同构。
- 然后对于一个节点的所有子树进行比较，找到 $u$ 和 $v$ 的所有失配的儿子，这里有一个重要的剪枝就是如果发现整棵树的不同点超过 $u$ 和 $v$ 的大小差距就直接返回不行，由于 $k$ 很小，对于有意义的情况，等待判断的节点不会太多。
- 下一步，对于 $u$ 的所有失配儿子都查询它与 $v$ 的哪些失配儿子子树同构。
- 经过小心的实现，$v$ 有 $k$ 个失配儿子的情况会直接导致它儿子的容错参数减小 $k-1$，可以证明这部分至多带来 $2^k$ 的常数，而这在题目中的数据范围是可以接受的，总复杂度 $O(n\log n+2^kn)$，[代码](https://www.luogu.com.cn/paste/4k944ysz)。
- 有一个很有趣的地方是，可能由于我的特殊实现，我的代码里需要判断一个二分图是否存在完美匹配，我用霍尔定理完成了这一点。
- 这题目的特殊性质是我们 $u$ 和 $v$ 的判定要求 $u$ 和 $v$ 的深度相同，所以这个[确定性算法](https://oi-wiki.org/graph/tree-ahu/)仍然可以使用，复杂度一样（也可以强行把排序部分的复杂度做到线性）但常数是好几倍，好处是不需要担心自己的做法在某些网站上被毒瘤卡，[代码](https://www.luogu.com.cn/paste/08jo9bpf)。

---

## 作者：Leasier (赞：4)

前置芝士：[树哈希](https://oi-wiki.org/graph/tree-hash/)

首先考虑 $k = 0$ 怎么做，一眼鉴定为直接树哈希。

但 $k \geq 1$ 时看上去只能直接暴力 $O(n^k)$ 枚举删哪些点再跑树哈希，时间复杂度为 $O(\sum n^{k + 1})$，显然不能通过。

设 $G, H$ 的根为 $R_1, R_2$，则 $G, H$ 完全相同的条件是 $R_1, R_2$ 为根的子树完全匹配。

注意到以 $u, v$ 为根的子树完全相同意味着 $u, v$ 的子树数量相等且存在一种方案，使得两棵树的子树对应匹配。

此时我们把一个问题转化为了一些几乎相同的问题，考虑 dp。

设 $dp_{u, v}$ 表示能否把 $G$ 中的 $u$ 子树删去若干点使之与 $H$ 中的 $v$ 子树删去若干点相同。

1. $size_u < size_v$

此时显然无解。

2. $size_u = size_v$

此时我们只需要判断 $u$ 子树和 $v$ 子树的哈希值是否相同即可。

3. $size_u > size_v$

考虑 $u, v$ 的子树集合 $S_u, S_v$。

对于 $S_u, S_v$ 中完全相同的子树，直接让其匹配即可。接下来我们可以不用考虑这些子树，即把它们从 $S_u, S_v$ 中删去。

若此时 $|S_u| < |S_v|$，显然无解。

若此时 $|S_u| > |S_v|$，我们需要删去 $u$ 中的若干子树，使 $|S_u| = |S_v|$，再进行剩下的操作。

这里有两个思路：

- 注意到删完后匹配剩下的子树时 $u$ 的对应子树大小必须不小于 $v$ 的对应子树大小，贪心地，我们考虑删去 $S_u$ 中子树大小最小的 $|S_u| - |S_v|$ 个。但这样是可以 Hack 的（见 [UOJ](https://uoj.ac/hack/12567)）。
- 在 $S_v$ 中加入若干空子树，任意子树与空子树均可匹配。

现在 $|S_u|, |S_v|$ 相等了，但直接做匹配没有什么想法，于是考虑直接暴力枚举排列。可惜这样的时间复杂度显然不正确。

此时注意到另一个问题：如果此时待匹配的子树数量大于 $size_u - size_v$，那么就必定会产生有子树需要删去负的点数，不可行。

但这样还是可以 Hack。注意到在 $G, H$ 间深度相同的点间有可能会出现大量相同的 $u, v$ 的匹配被重复计算的情况，记忆化即可。

~~时间复杂度不会算。~~

代码：
```cpp
#include <iostream>
#include <algorithm>
#include <set>
#include <map>
#include <vector>
#include <cstdio>

using namespace std;

typedef unsigned long long ull;

typedef struct {
	int nxt;
	int end;
} Edge;

const int N = 1299709 + 7, M = 1e5 + 7;
int prime[N];
bool p[N];

typedef struct {
	int cnt;
	int head[M], size[M];
	ull dp[M];
	Edge edge[M];
	
	inline void init(int n){
		cnt = 0;
		for (register int i = 1; i <= n; i++){
			head[i] = 0;
		}
	}
	
	inline void add_edge(int start, int end){
		cnt++;
		edge[cnt].nxt = head[start];
		head[start] = cnt;
		edge[cnt].end = end;
	}
	
	void dfs1(int u){
		size[u] = 1;
		for (register int i = head[u]; i != 0; i = edge[i].nxt){
			int x = edge[i].end;
			dfs1(x);
			size[u] += size[x];
		}
	}
	
	void dfs2(int u){
		dp[u] = 1;
		for (register int i = head[u]; i != 0; i = edge[i].nxt){
			int x = edge[i].end;
			dfs2(x);
			dp[u] += dp[x] * prime[size[x]];
		}
	}
} Hash;

typedef struct Node_tag {
	int pos;
	int size;
	ull hash;
	Node_tag(int pos_, int size_, ull hash_){
		pos = pos_;
		size = size_;
		hash = hash_;
	}
} Node;

Hash g, h;
map<int, bool> mp[100007];

bool operator <(const Node a, const Node b){
	if (a.size != b.size) return a.size < b.size;
	return a.hash < b.hash;
}

inline void init1(){
	int cnt = 0;
	p[0] = p[1] = true;
	for (register int i = 2; i < N; i++){
		if (!p[i]) prime[++cnt] = i;
		for (register int j = 1; j <= cnt && i * prime[j] < N; j++){
			p[i * prime[j]] = true;
			if (i % prime[j] == 0) break;
		}
	}
}

inline void init2(int n){
	for (register int i = 1; i <= n; i++){
		mp[i].clear();
	}
}

inline int read(){
	int sign = 1, ans = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9'){
		if (ch == '-') sign = -sign;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9'){
		ans = ans * 10 + (ch ^ 48);
		ch = getchar();
	}
	return sign * ans;
}

bool dfs(int u, int v){
	int k = g.size[u] - h.size[v];
	if (k < 0) return false;
	if (k == 0) return g.dp[u] == h.dp[v];
	if (mp[u].count(v)) return mp[u][v];
	int size1, size2;
	multiset<Node> s;
	vector<Node> vec1, vec2;
	for (register int i = g.head[u]; i != 0; i = g.edge[i].nxt){
		int x = g.edge[i].end;
		s.insert(Node(x, g.size[x], g.dp[x]));
	}
	for (register int i = h.head[v]; i != 0; i = h.edge[i].nxt){
		int x = h.edge[i].end;
		Node y(x, h.size[x], h.dp[x]);
		if (s.count(y)){
			s.erase(s.find(y));
		} else {
			vec1.push_back(y);
		}
	}
	size1 = vec1.size();
	size2 = s.size();
	if (size2 < size1 || size2 > k) return mp[u][v] = false;
	int diff = size2 - size1;
	for (register int i = 1; i <= diff; i++){
		vec1.push_back(Node(0, 0, 0));
	}
	sort(vec1.begin(), vec1.end());
	while (!s.empty()){
		multiset<Node>::iterator cur = s.begin();
		vec2.push_back(*cur);
		s.erase(cur);
	}
	do {
		bool flag = true;
		for (register int i = 0; i < size2; i++){
			if (vec1[i].pos != 0 && !dfs(vec2[i].pos, vec1[i].pos)){
				flag = false;
				break;
			}
		}
		if (flag) return mp[u][v] = true;
	} while (next_permutation(vec1.begin(), vec1.end()));
	return mp[u][v] = false;
}

int main(){
	int c = read(), t = read(), k = read();
	init1();
	for (register int i = 1; i <= t; i++){
		int n1 = read(), root1, n2, root2;
		init2(n1);
		g.init(n1);
		for (register int j = 1; j <= n1; j++){
			int a = read();
			if (a == -1){
				root1 = j;
			} else {
				g.add_edge(a, j);
			}
		}
		g.dfs1(root1);
		g.dfs2(root1);
		n2 = read();
		h.init(n2);
		for (register int j = 1; j <= n2; j++){
			int b = read();
			if (b == -1){
				root2 = j;
			} else {
				h.add_edge(b, j);
			}
		}
		h.dfs1(root2);
		h.dfs2(root2);
		if (dfs(root1, root2)){
			cout << "Yes" << endl;
		} else {
			cout << "No" << endl;
		}
	}
	return 0;
}
```

---

## 作者：Tyyyyyy (赞：4)

## P8499

### 题意简述
给定两棵有根树 $G,H$，满足 $1\leq |H|\leq |G|\leq |H|+k$，其中 $k$ 是一个 $\leq 5$ 的常数。试判断从 $G$ 中删去若干节点后，能否使得 $G,H$ 在有根意义下同构。

$1\leq |G|\leq 10^5,0\leq k\leq 5$。

### 题目分析
首先对于两棵树求出子树哈希值用来判断树同构。考虑递归判断，设 $f(u_G,u_H,k)$ 表示从 $G$ 中以 $u_G$ 为根的子树中删去 $k$ 个点后，能否与 $H$ 中以 $u_H$ 为根的子树同构。

考虑递归判断 $u_G$ 和 $u_H$ 的儿子是否能够对应满足同构。因为最多只能删掉 $k$ 个点，因此我们将 $u_G$ 和 $u_H$ 的儿子的哈希值集合列举出来，在两个集合中消去可以对应的值之后，剩余未对应的儿子若多于 $k$ 个，则一定不可能满足条件，可以直接返回。因此，需要继续递归的情况满足未对应的儿子数量 $\leq k$。因为 $k$ 是一个很小的常数，所以我们可以直接枚举全排列来尝试每一种对应关系。只要有一种对应关系下儿子能够一一同构，则 $f(u_G,u_H,k)$ 就为真。

这种方法中，每个点的枚举数量上界为 $k!$，因此时间复杂度的上界为 $O(nk!)$，可以通过。

Code：
```cpp
const int N=1e5+10,M=1e7+10,p1=1e9+7,p2=1e9+9;
int C,T,K,n,m,rg,rh,szg[N],szh[N];
vector<int>G[N],H[N];
int pri[M],v[M],cnt;
void sieve()
{
	for(int i=2;i<M;i++)
	{
		if(!v[i])pri[++cnt]=i;
		for(int j=1;j<=cnt&&1ll*i*pri[j]<M;j++)
		{
			v[i*pri[j]]=1;
			if(i%pri[j]==0)break;
		}
	}
}
struct Hash
{
	int x,y;
	Hash operator + (const Hash &b)
	{
		return (Hash){(x+b.x)%p1,(y+b.y)%p2};
	}
	Hash operator - (const Hash &b)
	{
		return (Hash){(x-b.x+p1)%p1,(y-b.y+p2)%p2};
	}
	Hash operator * (int b)
	{
		return (Hash){(int)(1ll*x*b%p1),(int)(1ll*y*b%p2)};
	}
	bool operator < (Hash b) const
	{
		return x!=b.x?x<b.x:y<b.y;
	}
	bool operator == (Hash b) const
	{
		return x==b.x&&y==b.y;
	}
	bool operator != (Hash b) const
	{
		return x!=b.x||y!=b.y;
	}
};
Hash fg[N],fh[N];
void dfs1(int u)
{
	szg[u]=1,fg[u]=(Hash){1,1};
	for(int v:G[u])
		dfs1(v),szg[u]+=szg[v],fg[u]=fg[u]+fg[v]*pri[szg[v]];
}
void dfs2(int u)
{
	szh[u]=1,fh[u]=(Hash){1,1};
	for(int v:H[u])
		dfs2(v),szh[u]+=szh[v],fh[u]=fh[u]+fh[v]*pri[szh[v]];
}
bool dfs(int ug,int uh,int k)
{
	if(!k)return szg[ug]==szh[uh]&&fg[ug]==fh[uh];
	if(szg[ug]==szh[uh])return fg[ug]==fh[uh];
	if(szh[uh]==1)return szg[ug]==k+1;
	multiset<pair<Hash,int> >sg,sh;map<pair<Hash,int>,int>mg,mh;
	for(int v:G[ug])sg.insert({fg[v],szg[v]}),mg[{fg[v],szg[v]}]=v;
	for(int v:H[uh])sh.insert({fh[v],szh[v]}),mh[{fh[v],szh[v]}]=v;
	int ng=sg.size(),nh=sh.size();
	if(ng<nh)return 0;
	int cnt=ng-nh;
	for(int v:H[uh])
	{
		pair<Hash,int>it={fh[v],szh[v]};
		if(sg.count(it))sg.erase(sg.find(it)),sh.erase(sh.find(it));
		else cnt++;
	}
	if(cnt>k)return 0;
	int gs=0,hs=0;
	for(auto it:sg)gs+=it.se;
	for(auto it:sh)hs+=it.se;
	if(gs-hs!=k)return 0;
	cnt=sg.size();int kg=0,kh=0;
	int p[6];
	pair<Hash,int>pg[6],ph[6];
	for(int i=1;i<=cnt;i++)p[i]=i;
	for(auto it:sg)pg[++kg]=it;
	for(auto it:sh)ph[++kh]=it;
	do
	{
		bool ok=1;int ss=0;
		for(int i=1;i<=kh;i++)
		{
			int x=p[i],vg=mg[pg[x]],vh=mh[ph[i]];
			if(szg[vg]<szh[vh]){ok=0;break;} 
			if(!dfs(vg,vh,szg[vg]-szh[vh])){ok=0;break;}
			ss+=szg[vg]-szh[vh];
		}
		for(int i=kh+1;i<=cnt;i++)
		{
			int x=p[i],vg=mg[pg[x]];
			ss+=szg[vg];
		}
		if(ss==k&&ok)return 1;
	}while(next_permutation(p+1,p+cnt+1));
	return 0;
}
int main()
{
	sieve();
	scanf("%d%d%d",&C,&T,&K);
	while(T--)
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++)G[i].resize(0);
		for(int i=1,x;i<=n;i++)
		{
			scanf("%d",&x);
			if(x==-1)rg=i;
			else G[x].push_back(i);
		}
		scanf("%d",&m);
		for(int i=1;i<=m;i++)H[i].resize(0);
		for(int i=1,x;i<=m;i++)
		{
			scanf("%d",&x);
			if(x==-1)rh=i;
			else H[x].push_back(i);
		}
		dfs1(rg),dfs2(rh);
		if(dfs(rg,rh,n-m))puts("Yes");
		else puts("No");
	}
	IO::pchar(0);
	return 0;
}
```

---

## 作者：all_for_god (赞：2)

[P8499 [NOI2022] 挑战 NPC Ⅱ](https://www.luogu.com.cn/problem/P8499)
## 思路
实际上就是一个超级暴搜题。

注意到题目已经保证了不卡哈希，于是我们考虑用树哈希来判断是否同构。由于给定了根，因此这是很容易做到的。

然后发现题目要求的可以删去的节点个数非常小，只有常数级别，于是我们考虑一些相对暴力的做法：
对于两棵树，我们去遍历这两棵子树中的节点 $x$ 和 $y$ 然后求出使得这两棵子树同构的最小代价。

然后我们注意到如果 $x$ 和 $y$ 的某些子树同构的话，那么我们就不需要管，于是我们可以先将两个节点的同构的子树全部判掉。
然后我们考虑这个时候 $x$ 与 $y$ 剩下的子树的个数一定已经不大于 $k$ 了，因为我们对于每一种不同构的子树我们都要至少删去一个点才能使得其同构，于是如果不同构的子树个数大于 $k$ 那么返回一个极大值即可。

由于不同构的子树个数很小，因此我们可以直接暴力枚举 $x$ 与 $y$ 的哪两个子树需要删成同构的，求出如果要将其删成同构的最小代价。
于是我们直接去枚举一个全排列，算出这样一一对应出来的贡献，然后对所有的贡献取一个 $\min$ 即可。

于是操作实际上就三步：去除同构的子树，算出任意一对不同构子树变成同构的贡献（继续 dfs 下去），枚举全排列统计贡献。
边界条件就是如果 $y$ 所在的子树大小恰好为一，那么我们就要将 $x$ 删成只有 1 个点，于是返回 $siz_x-1$ 即 $x$ 所在子树的点的个数减 1。
复杂度上界大概是 $O(k\times k!n)$，阈值是在枚举全排列统计贡献那里。然后发现好像不太能过，考虑有非常多的情况显然是没有用的，考虑减一下枝。

比如如果 $x$ 的大小小于 $y$ 或者 $x$ 的子树个数小于 $y$，那么我们显然不可能将点越删越多，于是直接返回极大值即可。
然后我们在 dfs 的时候不是所有时候删点的次数上界都是 $k$。在向下 dfs 的时候，假如说 $x$ 有 $cnt$ 个与 $y$ 的子树不同构的子树，当前可以删除的点数量的上界是 $lim$，那么 $x$ 的子树可以删的点的个数的上界就是 $lim-cnt+1$，因为其他每个不同构的子树至少要删去 1 个点才可能同构。
然后我们加上前面说的如果不同构的子树数目大于了可以删去的点的上界 $lim$，那么就返回极大值。然后就足以通过此题了，同时可以跑的比较快没有卡常风险。

## code
实际上有很多题解的复杂度都不太对，因为在上面“去除同构子树”这一步的时候，很多题解代码的实现都使用了 `erase` 函数。但这个东西复杂度是错误的，具体可以 [看我发的工单](https://www.luogu.com.cn/ticket/HQUT048157)。

我同机房的一些同学认为可以使用 `set` 来维护，我认为有点道理。我个人是使用了 `map` 来维护某种哈希值的**已经被删去的点编号的最小值**。
具体的，我使用了 `pair` 来将一个点子树的哈希值以及这棵子树的编号绑定在一起。由于 `pair` 的双关键字特性，我在预处理哈希值的时候将一个点所有的子树的哈希值与编号用 `vector` 存了起来然后排了遍序，这样所有哈希值相同的点都在一起且哈希值相同的点编号从小到大排列。
于是我们可以用二分查找找到对于 $x$ 的某个子树，第一个与其哈希值相同并且没有被去掉的 $y$ 的子树，具体的实现可以看代码。 

在将 $y$ 的没有被去掉的子树提取出来的时候，由于对于某种哈希值而言，所有没有被去除的子树在预处理出来的 `vector` 中一定是连续的，因此我们同样可以用二分查找找出这种哈希值的没有被去掉的子树在 `vector` 上的区间。

最后由于可能 $x$ 不同构的子树个数要多余 $y$ 不同构的子树个数，因此多出来的 $x$ 的这部分子树需要全部被删掉。于是在枚举全排列的时候其表现形式就是如果其对应的编号大于 $y$ 不同构的子树个数，那么贡献就加上其大小，也就是全部删完。

最后讲个笑话，这道题写的不卡哈希，于是我自信的写出了自然溢出的树哈希，然后就被卡飞了。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll unsigned long long
#define pii pair <ll,int>
#define mp make_pair
const int N=1e6+7,inf=1e8+7;const ll bas=13,p=1e9+9;
mt19937 rnd(time(0));
int val=rnd(),add=rnd(),n,m,rta,rtb,k;
vector <int> q[N];vector <pii> stk[N];

namespace hs{
	ll f[N];int siz[N],tot[N];
	ll get(ll x){x^=val,x%=p;x<<=10,x%=p;return (x+1919810ull)%p;}
	void dfs(int u){
		siz[u]=1;
		for(int v:q[u]){
			dfs(v);siz[u]+=siz[v];(f[u]+=get(f[v]))%=p;stk[u].push_back(mp(f[v],v));tot[u]++;
		}
		(f[u]+=add)%=p;sort(stk[u].begin(),stk[u].end());
	}
}
using namespace hs;
void init(){for(int i=1;i<=n+m;i++)f[i]=siz[i]=tot[i]=0,q[i].clear(),stk[i].clear();}
map <ll,int> id;
int calc(int x,int y,int lim){
	if(siz[x]<siz[y]||tot[x]<tot[y])return inf;
	if(siz[y]==1)return siz[x]-1;
	vector <int> u,v;
	for(pii a:stk[y]) id[a.first]=0;  //注意到如果不加这一句话可能会在后面遍历 id 的时候漏掉 y 的一些子树（因为那里的查找是基于 id 的） 
	
	for(pii a:stk[x]){
		ll w=a.first;int loc=lower_bound(stk[y].begin(),stk[y].end(),mp(w,id[w]))-stk[y].begin();
		if(loc<tot[y]&&stk[y][loc].first==w) id[w]=stk[y][loc].second+1;
		else u.push_back(a.second);
	}
	int cu=u.size(),cv=0,ans=inf;
	
	if(cu>lim){id.clear();return inf;}
	
	int g[10][10],pai[10];
	for(auto a:id){
		ll w=a.first;
		int loc=a.second;
		int l=lower_bound(stk[y].begin(),stk[y].end(),mp(w,loc))-stk[y].begin();
		int r=lower_bound(stk[y].begin(),stk[y].end(),mp(w+1,0))-stk[y].begin()-1;
		for(int j=l;j<=r;j++)v.push_back(stk[y][j].second),cv++; 
	}
	id.clear();
	
	for(int i=0;i<cu;i++)for(int j=0;j<cv;j++)g[i][j]=calc(u[i],v[j],lim-cu+1);
	
	for(int i=0;i<10;i++)pai[i]=i;
	do{
		int tmp=0;for(int i=0;i<cu&&tmp<ans;i++)tmp+=pai[i]<cv?g[i][pai[i]]:siz[u[i]];
		ans=min(ans,tmp);
	}while(next_permutation(pai,pai+cu));
	return ans;
}
void solve(){
	cin>>n;for(int i=1,x;i<=n;i++){cin>>x;if(x==-1)rta=i;else q[x].push_back(i);}
	cin>>m;for(int i=1,x;i<=m;i++){cin>>x;if(x==-1)rtb=i+n;else q[x+n].push_back(i+n);}
	dfs(rta),dfs(rtb);int ans=calc(rta,rtb,k);
	cout<<(ans<=k?"Yes\n":"No\n");
}
signed main(){
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	int C,T;cin>>C>>T>>k;while(T--)solve(),init();
	return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：1)

[Problem Link](https://www.luogu.com.cn/problem/P8499)

**题目大意**

> 给定两棵有根树 $G,H$，记 $n=|G|,k=|H|-|G|$，求是否能在 $H$ 上删除 $k$ 个节点使得 $G,H$ 同构。
>
> 数据范围：$n\le 5\times 10^5,k\le 5$。

**思路分析**

直接 dp 状态难以接受，考虑自上而下地搜索设 $f_{i,j}$ 表示能否使得 $G$ 中 $i$ 子树和 $H$ 中 $j$ 子树同构。

用树哈希判断子树同构，当 $H$ 是叶子时返回，否则相当于对 $i,j$ 的所有儿子对应子树求完美匹配。

我们发现如果有两个子树 $x,y$ 已经同构，那么直接匹配这两个子树肯定可以，否则我们可以用 $y$ 匹配的子树匹配上 $x$ 匹配的子树从而调整出一组 $x,y$ 匹配的解。

那么 $i$ 剩下未匹配的子树 $\le k$ 棵，$\mathcal O(k!)$ 爆搜每种匹配并记搜优化即可。

可以证明被访问到的 $f_{i,j}$ 总量是 $\mathcal O(n2^k)$ 的。

时间复杂度 $\mathcal O(n2^kk!)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
using namespace std;
const int MAXN=1e5+5;
struct Tree {
	int n,rt,fa[MAXN],siz[MAXN];
	vector <int> E[MAXN];
	ull f[MAXN];
	ull P(ull x) {
		x^=x<<13,x^=x>>7,x^=x<<17;
		return x*x*29+x*13+37;
	}
	void dfs(int u) {
		f[u]=siz[u]=1;
		for(int v:E[u]) dfs(v),siz[u]+=siz[v],f[u]+=P(f[v]);
		sort(E[u].begin(),E[u].end(),[&](int x,int y){ return f[x]<f[y]; });
	}
	void init() {
		cin>>n;
		for(int i=1;i<=n;++i) E[i].clear(),siz[i]=f[i]=0;
		for(int i=1;i<=n;++i) {
			cin>>fa[i];
			if(~fa[i]) E[fa[i]].push_back(i);
			else rt=i;
		}
		dfs(rt);
	}
}	G,H;
int k;
map <array<int,2>,bool> DP;
bool dp(int x,int y) {
	if(H.siz[y]==1) return true;
	if(DP.count({x,y})) return DP[{x,y}];
	if(G.siz[x]<H.siz[y]) return false;
	vector <int> &g=G.E[x],&h=H.E[y],s,t;
	auto ig=g.begin(),ih=h.begin();
	while(ig!=g.end()&&ih!=h.end()) {
		if(G.f[*ig]==H.f[*ih]) ++ig,++ih;
		else if(G.f[*ig]<H.f[*ih]) s.push_back(*ig++);
		else t.push_back(*ih++);
	}
	s.insert(s.begin(),ig,g.end()),t.insert(t.begin(),ih,h.end());
	if(s.size()<t.size()||s.size()>k) return false;
	int z=s.size();
	vector <int> p(z);
	iota(p.begin(),p.end(),0),t.resize(z,0);
	do {
	    bool ok=true;
		for(int i=0;i<z;++i) {
			ok&=dp(s[i],t[p[i]]);
			if(!ok) break;
		}
		if(ok) return DP[{x,y}]=true;
	} while(next_permutation(p.begin(),p.end()));
	return DP[{x,y}]=false;
}
void solve() { DP.clear(),G.init(),H.init(),cout<<(dp(G.rt,H.rt)?"Yes\n":"No\n"); }
signed main() {
	ios::sync_with_stdio(false);
	int T,C; cin>>C>>T>>k;
	while(T--) solve();
	return 0;
}
```

---

## 作者：tzl_Dedicatus545 (赞：1)

首先你需要会树哈希，这里提供一种正确的哈希方法：

>设 $f$ 是 $\N \mapsto\N$ 的一个随机函数 
，则以 $u$ 为根的子树哈希值为：
> $$1+\sum_{v\in \text{son}(u)}f(\text{hash}_v) $$

实际在做的时候 $f$ 可以随便左移右移在异或几次。

```````cpp
x ^= mask;x ^= x << 5;x ^= x >> 19;x ^= x << 7;x ^= mask;
```````

回到本题，由于 $k$ 非常小，我们不妨考虑类似**暴力搜索**的手段，每次解决子问题 $u,v$ 是否同构，我们不难发现以下事实：

1. 如有子树哈希相同，一定优先匹配该子树。
2. 剩下的子树数量一定要 $\leq k$ 。

在此基础上，我们直接暴力递归匹配！

复杂度上界是：$O(nk!k^2)$，但是明显跑不满。

---


# [POI 2002] 滑雪者

## 题目描述

在某山的斜坡上有一些滑雪轨道和一个滑雪电梯，所有的轨道都是从山顶到山底。

每天清晨都有一群工人检查轨道情况，他们一起乘电梯到到达山顶。接着他们沿每个人选择的轨道滑到底端，每个工人只能滑一次。

工人选择的轨道可能有部分相同，每个轨道可由任一个向下滑行的工人检查。向下滑雪从高到底选择一条轨道进行。

滑雪轨道由一个空地网络组成，每个空地有不同的高度。任意两个空地之间最多有一条道相连。

## 说明/提示

数据范围：$2 \le n \le 5000$，给定的图是平面图。

## 样例 #1

### 输入

```
15
5 3 5 9 2 4
1 9
2 7 5
2 6 8
1 7
1 10
2 14 11
2 10 12
2 13 10
3 13 15 12
2 14 15
1 15
1 15
1 15```

### 输出

```
8```

# 题解

## 作者：rubbishZZZ (赞：7)

提供一个 @[honglan0301](https://www.luogu.com.cn/user/529697) 说的更好的做法。

平面图 Dag 和一个偏序关系是等价的，我们考虑 Dilworth 定理。偏序关系中，最小链覆盖等于最长反链，因此我们想要找最多的没有偏序关系的边。

平面图转对偶图，那么最长反链就是对偶图中从最左边到最右边最长的一个路。题目中给的边是按顺序的，那么我们可以考虑 DP，把平面图中点的信息存在原图中块的右侧的边。

![](https://cdn.luogu.com.cn/upload/image_hosting/k0pjjbgr.png)

如上图，蓝边为原图的边，红边为对偶图的边，那么红边最长的链砍掉的蓝边就是最长反链，就是答案。

我们设 $f_{x}$ 从最左边到 $x$ 这条边左边的块的最长路，每次不停往上跳，再更新右侧的边的答案。

![](https://cdn.luogu.com.cn/upload/image_hosting/i2wus5pf.png)

如上图，绿色使我们 dfs 的路径，$6$ 号点访问过了，那我们就用黄色边 $f$ 的最大值来更新 $3$ 到 $5$ 和 $5$ 到 $6$ 两条边的 $f$ 值。

复杂度是 $O(n)$。

代码：
```cpp
#include <bits/stdc++.h>
#define pii pair<int, int>
#define fi first
#define se second
#define MP make_pair
#define ep emplace
#define eb emplace_back
//#define int long long
#define rep(i, j, k) for (int i = j; i <= k; i++)
#define per(i, j, k) for (int i = j; i >= k; i--)
typedef double db;
typedef long double ldb;
typedef long long ll;
typedef __int128 lll;
typedef unsigned long long ull;
typedef unsigned int ui;
using namespace std;

int read() {
	int s = 0, f = 1;
	char c = getchar();
	while (c < '0' || c > '9') f ^= (c == '-'), c = getchar();
	while (c >= '0' && c <= '9') s = s * 10 + c - '0', c = getchar();
	return f ? s : -s;
}
int n, tot, in[500005], dp[1000005], vis[500005][2], rev[500005], lst[500005], ans;
vector<pii> e[500005];
void dfs(int u) {
	vis[u][0] = 1;
	for (pii p : e[u]) {
		int v = p.fi, id = p.se;
		if (!vis[v][0]) rev[v] = u, lst[v] = id, dfs(v);
		else {
			int Dp = -1, U = u, V = v;
			while (vis[v][1]) Dp = max(Dp, dp[lst[v]]), v = rev[v];
			Dp++;
			ans = max(ans, Dp);
			dp[id] = Dp;
			while (U != v) dp[lst[U]] = Dp, U = rev[U];
			rev[V] = u, lst[V] = id;
		}
	}
	vis[u][1] = 1;
}

signed main() {
	n = read();
	rep(i, 1, n - 1) {
		for (int cnt = read(); cnt--; ) {
			int x = read();
			in[x]++;
			e[i].eb(x, ++tot);
		}
	}
	dfs(1);
	printf("%d\n", ans + 1);
	return 0;
}
```

---

## 作者：Eraine (赞：6)

编号：P8857

tag：网络流相关知识

难度：紫

这里提供一个转对偶图最长路的做法。

题目很显然是要求平面图最小链覆盖。由于这个图是 DAG 即一个有序偏序集，根据 Dilworth 定理可转化为平面图最长反链。

现在来证明一个定理：

> Lemma 平面 DAG 的最小链覆盖 = 对偶图的最长路

注：这里的 **最小链覆盖** 指在有向无环图中用数量最少的简单路径覆盖图上的每一条边。

证明：

最小链覆盖 $\ge$ 最长路并不难证。对偶图最长路就是原图的一个割，设划分的子集 $S$ 和 $T$ 的每一条边 $(u,v),u\in S,v\in T$ 构成边集 $E$，有 $\mid E\mid\le$ 最长路。很显然，由于这是一个 DAG，所以 $E$ 中的每一条边必然最多属于一条链。

最小链覆盖 $\le$ 最长路，我们将最小链覆盖转化为最长反链。将反链中的每一个点拆点 $u^{\text{in}},u^{\text{out}}$，并连边，那么最长反链可以看做是把对应点的所拆成的入点和出点所连的边断开。容易发现此时也构成一个割。若不是割那么存在一条通路，这条通路上选出跨过 $S,T$ 的一条由入点和出点所连的边（必然能找到集合划分 $S,T$ 使这样的边存在）断掉，而这组点对应原图上的点满足构成最长反链的条件。故构成割。而在平面图上的割可以转换为对偶图上的一条通路 $L^\prime$。显然有 $\mid L^\prime\mid=$ 最长反链。可推得 $\max\mid L\mid\ge$ 最小链覆盖。

故我们证明了 Lemma。

那么只要我们建出对偶图即可。

题目有一个很关键的条件，即给出的每个点的出边从西向东排列，那么我们便可以利用这个性质解题。

观察对偶图上的每一个点，除了源点和汇点，其他点均为形似这样的联通块：

$St\to a_1\to a_2\to\dots\to a_k\to Ed$

$St\to b_1\to b_2\to\dots\to b_l\to Ed$

其中，路径 $a$ 在路径 $b$ 西侧。

画出图形，我们可以得到结论，对于 $a_i$ 指向的下一个点 $x$，有 $x$ 是 $a_i$ 指向的最靠东的边。相反地，对于 $b_i$ 指向的下一个点 $x$，有 $x$ 是 $b_i$ 指向的最靠西的边。

那么我们便可以枚举 $S,a_1,b_1$，暴力找到每个对偶图上的点并建边。可以证明这样的时间复杂度是 $\Theta(n+m)$ 的。每条边最多被作为左右两个对偶图上的点所遍历的边，所以遍历边是 $\Theta(m)$ 的。至于点可以拆点类似遍历边的方式得出 $\Theta(n)$ 的结论。

建出的对偶图求最长路跑一遍拓扑排序即可。

$\Theta(n+m)$。

[submission](https://www.luogu.com.cn/record/160472554)

若有疑惑或错误之处请指出，虚心接受您的意见。

upd：2024.8.22 感谢 @murder_drones 指出本文中的一处概念错误。

---

## 作者：MatrixGroup (赞：3)

## 题意

给定一个 $n$ 个点的平面 DAG，唯一入度为 $0$ 的结点是结点 $1$，唯一出度为 $0$ 的结点是结点 $n$，求最小（可重叠）边链覆盖。

$n\le 5000$。

## 题解

所求为最小（可重叠）边链覆盖等于最小（不可重）（关于边可达性的）偏序集链覆盖等于最长边（关于边可达性的）反链等于 $1-n$ 最大割等于 $1-n$ 对偶图最长路。

综上，只需要求对偶图最长路即可。时间复杂度 $O(n)$。

（$s-t$ 对偶图的求法是，先求出每个点相邻出边围成的面，再将一条边左边的面连向右边的）

## 代码

```cpp
#include <bits/stdc++.h>
#define rep(i,n) for(int i=0,_##i##__end=int(n);i<_##i##__end;++i)
#define rep1(i,n) for(int i=1,_##i##__end=int(n);i<=_##i##__end;++i)
#define pb push_back
using namespace std;
int n;
vector<int> to[5005];
vector<int> l[5005],r[5005];// l,r 表示一条边左右的面
int k,v;
int cnt=1;
vector<int> qwq[50005];
int dp[50005];
int f(int x)
{
	if(dp[x]) return dp[x];
	if(x==1) return 0;
	rep(i,qwq[x].size()) dp[x]=max(dp[x],f(qwq[x][i]));
	return ++dp[x];
}
int top[5005];//拓扑序
int deg[5005];
int q[5005],bg,ed;
int main()
{
	ios_base::sync_with_stdio(false);
	cin>>n;
	rep1(u,n-1)
	{
		cin>>k;
		rep1(_,k)
		{
			cin>>v;
			to[u].pb(v);++deg[v];
			l[u].pb(0);r[u].pb(0);
		}
	}
	bg=ed=0;q[++ed]=1;
	while(bg<ed)
	{
		v=q[++bg];top[v]=bg;
		for(int u:to[v])
		{
			if((--deg[u])==0) q[++ed]=u;
		}
	}
	rep1(i,n-1)
	{
		rep(j,to[i].size()-1)
		{
			l[i][j+1]=++cnt;
			r[i][j]=cnt;
			int x=to[i][j],y=to[i][j+1];
			while(x!=y)
			{
				if(top[x]<top[y])
				{
					r[x][to[x].size()-1]=cnt;
					x=to[x][to[x].size()-1];
				}
				else
				{
					l[y][0]=cnt;
					y=to[y][0];
				}
			}
		}
	}
	++cnt;
	rep1(i,n-1)
	{
		rep(j,l[i].size())
		{
			if(l[i][j]==0) l[i][j]=1;
			if(r[i][j]==0) r[i][j]=cnt;
			qwq[r[i][j]].pb(l[i][j]);
		}
	}
	cout<<f(cnt)<<endl;
	return 0;
}
```

---

## 作者：honglan0301 (赞：3)

## 题意简述
- 原题链接：[P8857](https://www.luogu.com.cn/problem/P8857)  

- 给定一个 $n$ 个点的 DAG, 求最少用多少条从点 $1$ 到点 $n$ 的路径能覆盖图上的**所有边**（不同路径可以经过相同的边）  

## 题目分析
观察题目条件，用最小路径覆盖做好像有点困难，因为题目要求的并不是覆盖点并且路径可重。但我们可以考虑把每个工人的路径当成一条流，那么我们只需要求出每条弧上都有 $\geq1$ 的流量时的最小流，即上界为无穷大，下界为 $1$ 的有源汇上下界最小流。  

我们不妨根据它的思想（[模板](https://www.luogu.com.cn/problem/solution/P5192)），先找出一个可行流 $f_0$, 再尝试把它转化为最小流。因为 $f_{\min}(s→t)=f_0+\min(f^{'}(s→t))$, 而又因为 $\min(f^{'}(s→t))=-\max(f^{'}(t→s))$, 于是只需再求出 $G^{'}$中由 $T$ 到 $S$（反向）的最大流即可。    

特别地，在这道题里，由于只有下界而没有上界，我为了简单就用暴力枚举构造最初的可行流了，代码很简单。

## 代码
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>
#include <queue>
using namespace std;
int n,k,u,s,t,head[5005],cnt,fl1,dep[5005],gap[5005],nowb[5005],maxflow,ans,to[5005]; 
bool zt[5005];
queue <int> Q;
struct edge
{
	int son;
	int next;
	int val;
}edge[1000005];
inline int read()
{
	int now=0; char c=getchar();
	while(c<'0' || c>'9') { c=getchar();}
	while(c>='0' && c<='9') { now=(now<<1)+(now<<3)+(c&15); c=getchar(); }
	return now;
}
void adde(int x,int y,int z)
{
	cnt++;
	edge[cnt].son=y;
	edge[cnt].next=head[x];
	edge[cnt].val=z;
	head[x]=cnt;
}
int dfs1(int now)//先暴力出最初的可行流 
{
	if(now==t)
	{
		return 1;
	}
	int nowuse=0;
	if(!zt[now])
	{
		zt[now]=1;
		for(int i=head[now];i>0;i=edge[i].next)
		{
			if(i%2==0)
			{
				continue;
			}
			int nf=dfs1(edge[i].son);
			edge[((i-1)^1)+1].val+=nf;//处理反向边 
			nowuse+=nf;
			to[now]=i;
		}
	}
	else//这个点的所有子节点都遍历过了，不需要再遍历了 
	{
		int nl=dfs1(edge[to[now]].son);
		edge[((to[now]-1)^1)+1].val+=nl;
		nowuse+=nl;
	}
	return nowuse;
}
void bfs()//ISAP的反向BFS 
{
	memset(dep,127,sizeof(dep));
	memset(gap,0,sizeof(gap));
	dep[t]=0;
	gap[0]=1;//gap优化 
	Q.push(t);
	while(!Q.empty())
	{
		int nr=Q.front();
		Q.pop();
		for(int i=head[nr];i>0;i=edge[i].next)
		{
			if(dep[edge[i].son]>dep[nr]+1)
			{
				dep[edge[i].son]=dep[nr]+1;
				gap[dep[edge[i].son]]++;
				Q.push(edge[i].son);
			}
		}
	}
}
int dfs(int now,int nowflow)//找增广路 
{
	if(now==t)
	{
		return nowflow;
	}
	int nowuse=0;
	for(int i=nowb[now];i>0;i=edge[i].next)//当前弧优化 
	{
		nowb[now]=i;
		if(edge[i].val&&dep[edge[i].son]+1==dep[now])
		{
			int fl=dfs(edge[i].son,min(nowflow-nowuse,edge[i].val));
			edge[i].val-=fl;
			edge[((i-1)^1)+1].val+=fl;
			nowuse+=fl;
			if(nowuse==nowflow)
			{
				return nowuse;
			}
		}
	}
	nowb[now]=head[now];
	gap[dep[now]]--;
	dep[now]++;
	gap[dep[now]]++;
	if(gap[dep[now]-1]==0)//gap优化，出现断层直接返回 
	{
		dep[s]=n+3;
	}
	return nowuse;
}
void isap()//ISAP最大流 
{
	memcpy(nowb,head,sizeof(head));
	bfs();
	while(dep[s]<=n+2)
	{
		maxflow+=dfs(s,1000000000);
	}
}
int main()
{
	n=read();
	s=1;
	t=n;
	for(int i=1;i<=n-1;i++)
	{
		k=read();
		for(int j=1;j<=k;j++)
		{
			u=read();
			adde(i,u,0);
			adde(u,i,0);
		}
	}
	for(int i=2;i<=cnt;i+=2)
	{
		edge[i].val=-1;
	}
	for(int i=1;i<=cnt;i+=2)//容量上界都是INF 
	{
		edge[i].val=1000000;
	}
	fl1=dfs1(1); 
	s=n;
	t=1;
	isap();
	ans=fl1-maxflow; 
	cout<<ans<<endl;
}
```
感觉有更好的做法，~~但我不会~~。

---

## 作者：Kingna (赞：1)

根据 Dilworth 定理，所求最小可重叠边链覆盖等于 $1\sim n$ 最大割，同时也等于 $1\sim n$ 对偶图最长路。那我们把对偶图建出来求最长路就行。

难点是建对偶图。题目有个关键条件，一个点的出边是从西到东依次排列，那么我们根据这个性质，从左到右遍历一个点的出边进行建图。

首先一个点相邻的的两个出边之间一定存在一个平面，这个平面长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/yfyjfco2.png)

如何构造这个平面：我们发现两边路径呈现 $S\to a_1\to a_2\to \dots \to a_k\to T$ 和 $S\to b_1\to b_2\to \dots \to b_k\to T$。其中 $S$ 是当前节点，$a_1$ 和 $b_1$ 是 $S$ 的两个相邻儿子，$a_{i+1}$ 是 $a_i$ 的最右边的儿子，$b_{i+1}$ 是 $b_i$ 的最左边的儿子。

对每条边维护它左边的平面编号 $l$ 和右边的平面编号 $r$，按照上述方法构造平面的同时，就可以更新 $l$ 和 $r$ 数组了。最后 $l\to r$ 连边即可。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

// #define int long long
#define PII pair<int, int>
#define _for(i, a, b) for (int i = (a); i <= (b); i++)
#define _pfor(i, a, b) for (int i = (a); i >= (b); i--)

const int N = 5005;

int n, din[N], dep[N], tt[N], l[N][2500], r[N][2500], idx;
vector<int> path;
vector<int> G[N], nG[N];

void topsort() {
  queue<int> q;
  _for(i, 1, n) if (!din[i]) q.push(i);
  while (q.size()) {
    int u = q.front(); q.pop(); path.push_back(u);
    for (auto v : G[u]) {
      if (--din[v] == 0) q.push(v);
    }
  }
  _for(i, 0, path.size() - 1) tt[path[i]] = i;
}

int dist[N], st[N];

void spfa() {
  queue<int> q;
  memset(dist, -0x3f, sizeof dist);
  q.push(0); dist[0] = 0;
  while (q.size()) {
    int u = q.front(); q.pop();
    st[u] = 0;
    for (auto v : nG[u]) {
      if (dist[v] < dist[u] + 1) {
        dist[v] = dist[u] + 1;
        if (!st[v]) {
          q.push(v);
          st[v] = 1;
        }
      }
    }
  }
}

signed main() {
  // freopen("data.in", "r", stdin);
  cin >> n;
  _for(i, 1, n - 1) {
    int x;
    cin >> x;
    while (x--) {
      int y;
      cin >> y;
      G[i].push_back(y); din[y]++;
    }
  }
  topsort();
  _for(i, 1, n - 1) {
    int sz = G[i].size();
    _for(j, 0, sz - 2) {
      l[i][j + 1] = ++idx; r[i][j] = idx;
      int x = G[i][j], y = G[i][j + 1];
      while (x != y) {
        if (tt[x] < tt[y]) {
          r[x][G[x].size() - 1] = idx;
          x = G[x][G[x].size() - 1];
        }
        else {
          l[y][0] = idx;
          y = G[y][0];
        }
      }
    }
  }
  _for(i, 1, n - 1) {
    int sz = G[i].size();
    _for(j, 0, sz - 1) {
      if (l[i][j] == 0) l[i][j] = 0;
      if (r[i][j] == 0) r[i][j] = idx + 1;
      nG[l[i][j]].push_back(r[i][j]);
    }
  }
  spfa();
  cout << dist[idx + 1] << endl;
}
```

---

## 作者：forgotmyhandle (赞：1)

## 分析
每条边设一个流量下界 $1$，直接跑有源汇上下界最小流即可。跑法就是先转无源汇求出一个可行流，然后删去所有附加边，再在跑完可行流的残量网络上从原图的汇点向原图的源点跑一遍最大流，将可行流流量减去最大流流量即为答案。实际上第二遍跑的最大流可以视为要退掉尽量多地流量，使得剩下的尽量少。

另外，这个题虽然没给边数限制，但是经过实测，边数并不会超过 $10^4$。

## 代码
```cpp
#include <iostream>
#include <queue>
#define int long long
using namespace std;
const int inf = 2147483647;
int n;
int S, T;
int head[5005], nxt[5000005], to[5000005], res[5000005], ecnt = 1;
int cur[5005];
void add(int u, int v, int ww) {
    to[++ecnt] = v, nxt[ecnt] = head[u], head[u] = ecnt, res[ecnt] = ww;
    to[++ecnt] = u, nxt[ecnt] = head[v], head[v] = ecnt, res[ecnt] = 0;
}
int in[5005], out[5005];
void add(int u, int v, int l, int r) {
    add(u, v, r - l);
    in[v] += l;
    out[u] += l;
}
queue<int> q;
int dep[5005];
bool bfs() {
    for (int i = 1; i <= n + 2; i++) dep[i] = -1;
    dep[S] = 1;
    q.push(S);
    while (!q.empty()) {
        int x = q.front();
        q.pop();
        for (int i = head[x]; i; i = nxt[i]) {
            int v = to[i];
            if (res[i] && dep[v] == -1) {
                dep[v] = dep[x] + 1;
                q.push(v);
            }
        }
    }
    return (dep[T] != -1);
}
int dfs(int x, int flow) {
    if (x == T) 
        return flow;
    int ret = 0;
    for (int i = cur[x]; i && flow; i = nxt[i]) {
        cur[x] = i;
        int v = to[i];
        if (dep[v] == dep[x] + 1 && res[i]) {
            int tmp = dfs(v, min(flow, res[i]));
            if (tmp) {
                res[i] -= tmp;
                res[i ^ 1] += tmp;
                flow -= tmp;
                ret += tmp;
            }
        }
    }
    if (!ret) 
        dep[x] = -1;
    return ret;
}
int dinic() {
    int ret = 0;
    while (bfs()) {
        for (int i = 1; i <= n + 2; i++) cur[i] = head[i];
        ret += dfs(S, inf);
    }
    return ret;
}
signed main() {
    // freopen("data.in", "r", stdin);
    // freopen("data.out", "w", stdout);
    cin >> n;
    S = n + 1, T = n + 2;
    for (int i = 1; i < n; i++) {
        int k;
        cin >> k;
        while (k--) {
            int v;
            cin >> v;
            add(i, v, 1, inf);
        }
    }
    int rec = ecnt;
    add(n, 1, 0, inf);
    for (int i = 1; i <= n; i++) {
        if (in[i] > out[i]) 
            add(S, i, in[i] - out[i]);
        if (in[i] < out[i]) 
            add(i, T, out[i] - in[i]);
    }
    dinic();
    int f1 = res[rec + 2];
    for (int i = rec + 1; i <= ecnt; i++) res[i] = 0;
    S = n, T = 1;
    cout << f1 - dinic() << "\n";
    return 0;
}
```

---


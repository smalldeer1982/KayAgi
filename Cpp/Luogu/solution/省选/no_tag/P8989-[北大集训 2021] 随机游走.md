# [北大集训 2021] 随机游走

## 题目背景

CTT2021 D2T3

## 题目描述

给定一张 $n$ 个点的有向图，点标号为 $1,2,\dots,n$，初始时对 $\forall i\in\{1,2,\dots,n-1\}$，从 $i$ 到 $i+1$ 有一条有向边。

你可以在其中再加入 $m$ 条有向边（起点终点任意），允许有重边和自环。

小 A 会从 $1$ 出发，以随机游走的形式行动，直到抵达 $n$。你希望最大化小 A 从 $1$ 移动到 $n$ 的期望步数。

定义随机游走是这样的一种移动方式：设小 A 当前在点 $x$，$x$ 有 $d$ 条出边，则小 A 会从这 $d$ 条出边中**等概率**随机选择一条走过去。

## 说明/提示

| 测试包编号 | $n\le$ |  $m\le$   | $T\le$ | 特殊性质 | 分数 |
| :--------: | :----: | :-------: | :----: | :------: | :--: |
|    $1$     |  $5$   |    $5$    |  $10$  |    无    | $10$ |
|    $2$     |  $5$   |  $10^2$   |  $10$  |    无    | $10 $ |
|    $3$     | $10^8$ |  $10^2$   | $10^2$ |    无    | $20$ |
|    $4$     |  $50$  |  $3,000$  |  $3$   |    无    | $20 $ |
|    $5$     | $10^9$ |  $10^9$   | $10^5$ | $m<n-1$  | $10$ |
|    $6$     | $10^9$ | $10^{18}$ | $10^5$ |    无    | $30$ |


## 样例 #1

### 输入

```
4
3 2 97
10 25 233
6 12345 2333
1000000000 1000000000000000000 1000000007 
```

### 输出

```
6
131
1206
161905971
```

# 题解

## 作者：XuYueming (赞：3)

## 前言

~~又是随机游走？~~

**洛谷题解宽度太窄了，所以[更好的阅读体验](https://www.cnblogs.com/XuYueming/p/18156803)。**

## 题目分析

看到加边，可能性太多了。但是为了让步数最大化，我们可以贪心地想，肯定要往前面连，而且越前面要走的期望步数肯定越大。并且，我们不会浪费边在终点上。于是，题目转变成了 $1 \sim n - 1$ 连向起点 $1$ 连若干条边，使得随机游走到终点的期望步数最大。

那要如何分配这 $m$ 条边到 $1 \sim n - 1$ 个点呢？考虑假设已知第 $i$ 个点向 $1$ 连了 $d_i$ 条边，求期望步数。设 $f_i$ 为到了 $i$，还要期望多少步走到终点，显然 $f_n = 0$。开始喜闻乐见的推式子环节：

$$

\large f_i = \cfrac{1}{d_i + 1}f_{i+1} + \cfrac{d_i}{d_i + 1}f_1+1

$$

从 $n-1$ 向前递推。

$$

\begin{aligned}

\large f_{n-1} &= \cfrac{1}{d_{n-1} + 1}f_{n-1+1} + \cfrac{d_{n-1}}{d_{n-1} + 1}f_1+1 \\
&= \cfrac{d_{n-1}}{d_{n-1} + 1}f_1+1

\end{aligned}

$$

推到 $n-2$。

$$

\begin{aligned}

\large f_{n-2} &= \cfrac{1}{d_{n-2} + 1}f_{n-1} + \cfrac{d_{n-2}}{d_{n-2} + 1}f_1 + 1 \\
&= \cfrac{1}{d_{n-2} + 1} \cdot \left(\cfrac{d_{n-1}}{d_{n-1} + 1}f_1 + 1\right) + \cfrac{d_{n-2}}{d_{n-2} + 1}f_1 + 1\\
&= \cfrac{1}{d_{n-2} + 1} \cdot \cfrac{d_{n-1}}{d_{n-1} + 1}f_1 + \cfrac{d_{n-2}}{d_{n-2} + 1}f_1 + \cfrac{1}{d_{n-2} + 1} + 1 \\
&= \cfrac{d_{n-1} + d_{n-2} \cdot (d_{n-1}+1)}{(d_{n-2} + 1) \cdot (d_{n-1} + 1)} f_1 + \cfrac{(d_{n - 2} + 1) + 1}{d_{n-2} + 1} \\
&= \cfrac{(d_{n-2} + 1) \cdot (d_{n-1}+1) - 1}{(d_{n-2} + 1) \cdot (d_{n-1} + 1)} f_1 + \cfrac{(d_{n - 2} + 1) + 1}{d_{n-2} + 1}

\end{aligned}

$$

再推到 $n-3$。

$$

\begin{aligned}

f_{n-3} =& \cfrac{1}{d_{n-3} + 1}f_{n-2} + \cfrac{d_{n-3}}{d_{n-3} + 1}f_1+1 \\
=& {\scriptsize \cfrac{1}{d_{n-3} + 1}\left(\cfrac{(d_{n-2} + 1) \cdot (d_{n-1}+1) - 1}{(d_{n-2} + 1) \cdot (d_{n-1} + 1)} f_1 + \cfrac{(d_{n - 2} + 1) + 1}{d_{n-2} + 1}\right) + \cfrac{d_{n-3}}{d_{n-3} + 1}f_1+1} \\
=& {\scriptsize \cfrac{(d_{n-2} + 1) \cdot (d_{n-1}+1) - 1}{(d_{n-3} + 1) \cdot (d_{n-2} + 1) \cdot (d_{n-1} + 1)} f_1 + \cfrac{(d_{n - 2} + 1) + 1}{(d_{n-3} + 1) \cdot (d_{n-2} + 1)} + \cfrac{d_{n-3}}{d_{n-3} + 1}f_1+1} \\ 
=& {\scriptsize \cfrac{d_{n-3} \cdot (d_{n-2} + 1) \cdot (d_{n-1} + 1) + (d_{n-2} + 1) \cdot (d_{n-1}+1) - 1}{(d_{n-3} + 1) \cdot (d_{n-2} + 1) \cdot (d_{n-1} + 1)} f_1 + } \\
 & {\scriptsize \cfrac{(d_{n-3} + 1) \cdot (d_{n-2}+1) + (d_{n - 2} + 1) + 1}{(d_{n-3} + 1) \cdot (d_{n-2}+1)}} \\
=& {\scriptsize \cfrac{(d_{n-3} + 1) \cdot (d_{n-2} + 1) \cdot (d_{n-1} + 1) - 1}{(d_{n-3} + 1) \cdot (d_{n-2} + 1) \cdot (d_{n-1} + 1)} f_1 + \cfrac{(d_{n-3} + 1) \cdot (d_{n-2}+1) + (d_{n - 2} + 1) + 1}{(d_{n-3} + 1) \cdot (d_{n-2}+1)}}

\end{aligned}

$$

找到一些规律，尝试去证明。假设对于 $i+1$ 满足：

$$

\large f_{i+1} = \cfrac{\prod \limits _ {j=i+1}^{n-1} (d_j+1)-1}{\prod \limits _ {j=i+1}^{n-1} (d_j+1)}f_1 + \cfrac{\sum \limits _ {j=i+1} ^ {n-2} \prod \limits _ {k=j} ^ {n-2}(d_k+1) + 1}{\prod \limits  _ {j=i+1} ^ {n-2} (d_j+1)}

$$

显然该式对于 $n-1$ 成立。尝试用归纳法推到 $i$。

$$

\begin{aligned}

f_i &= {\scriptsize \cfrac{1}{d_i + 1}\left(\cfrac{\prod \limits _ {j=i+1}^{n-1} (d_j+1)-1}{\prod \limits _ {j=i+1}^{n-1} (d_j+1)}f_1 + \cfrac{\sum \limits _ {j=i+1} ^ {n-2} \prod \limits _ {k=j} ^ {n-2}(d_k+1) + 1}{\prod \limits  _ {j=i+1} ^ {n-2} (d_j+1)}\right) + \cfrac{d_i}{d_i + 1}f_1+1 } \\
    &= {\scriptsize \cfrac{\prod \limits _ {j=i+1}^{n-1} (d_j+1)-1}{\prod \limits _ {j=i}^{n-1} (d_j+1)}f_1 + \cfrac{\sum \limits _ {j=i+1} ^ {n-2} \prod \limits _ {k=j} ^ {n-2}(d_k+1) + 1}{\prod \limits  _ {j=i} ^ {n-2} (d_j+1)} + \cfrac{d_i}{d_i + 1}f_1+1} \\
    &= {\scriptsize \cfrac{\prod \limits _ {j=i}^{n-1} (d_j+1)-1}{\prod \limits _ {j=i}^{n-1} (d_j+1)}f_1 + \cfrac{\sum \limits _ {j=i} ^ {n-2} \prod \limits _ {k=j} ^ {n-2}(d_k+1) + 1}{\prod \limits  _ {j=i} ^ {n-2} (d_j+1)}}

\end{aligned}

$$

所以上式对于所有 $i$ 均成立。考虑边界，推到 $i=1$ 的时候是一个方程。

$$

f_1 = \cfrac{\prod \limits _ {j=1}^{n-1} (d_j+1)-1}{\prod \limits _ {j=1}^{n-1} (d_j+1)}f_1 + \cfrac{\sum \limits _ {j=1} ^ {n-2} \prod \limits _ {k=j} ^ {n-2}(d_k+1) + 1}{\prod \limits  _ {j=1} ^ {n-2} (d_j+1)}

$$

解方程。

$$

{\scriptsize \left( \prod \limits _ {j=1}^{n-1} (d_j+1) \right)f_1 = \left (\prod \limits _ {j=1}^{n-1} (d_j+1)-1\right)f_1 + (d_{n-1} + 1)\left({\sum \limits _ {j=1} ^ {n-2} \prod \limits _ {k=j} ^ {n-2}(d_k+1) + 1}\right)}

$$

$$

f_1 = {\sum \limits _ {j=1} ^ {n-2} \prod \limits _ {k=j} ^ {n-1}(d_k+1) + (d_{n-1}+1)}

$$

$$

\large f_1 = \sum \limits _ {j=1} ^ {n-1} \prod \limits _ {k=j} ^ {n-1}(d_k+1)

$$

于是我们可以很方便地求出期望步数，即 $f_1$。但是我们还是不知道最优的 $d$ 如何分配，考虑打表找规律。在此之前，我们不妨试着找一找 $d$ 的性质。

首先，$d$ 一定是单调不降的。因为显然，放在后面会给更多的 $\prod$ 提供贡献，从而使 $f_1$ 更大。

> 略证：
> 
> $\exists t \in [1, n-2], d_t > d_{t+1}$，考虑原先的 $f_1$ 有
> $$
> \begin{aligned}
> f_1 &= \scriptsize \sum \limits _ {j=1} ^ {n-1} \prod \limits _ {k=j} ^ {n-1}(d_k+1)  \\
>     &= \scriptsize \sum \limits _ {j=t+2} ^ {n-1} \prod \limits _ {k=j} ^ {n-1}(d_k+1) + (d_{t+1} + 1) \prod \limits _ {k=t+2} ^ {n-1}(d_k+1) + \sum \limits _ {j=1} ^ {t} \left ( (d_t + 1)(d_{t+1} + 1) \prod \limits _ {k=j} ^ {t-1}(d_k+1) \prod \limits _ {k=t+2} ^ {n-1}(d_k+1) \right )
> \end{aligned}
> $$
> 不妨交换 $d_t$ 和 $d_{t+1}$。
> $$
> \begin{aligned}
> f_1 &= \scriptsize \sum \limits _ {j=t+2} ^ {n-1} \prod \limits _ {k=j} ^ {n-1}(d_k+1) + ({\color{red}{d_{t}}} + 1) \prod \limits _ {k=t+2} ^ {n-1}(d_k+1) + \sum \limits _ {j=1} ^ {t} \left ( ({\color{red}{d_{t+1}}} + 1)({\color{red}{d_{t}}} + 1) \prod \limits _ {k=j} ^ {t-1}(d_k+1) \prod \limits _ {k=t+2} ^ {n-1}(d_k+1) \right )
> \end{aligned}
> $$
> 显然，因为 $d_t > d_{t+1}$，所以交换后的 $f_1$ 更优。我们可以不断进行这个过程，直到 $d$ 有序，即单调不降，$f_1$ 最大。
> 
> 证毕。

其次……没其次了，打表吧。

```python
while True:
    n, m = map(int, input().split())

    res = [0] * n
    ans = [0] * n

    maxx = 0

    def dfs(now, tot, x):
        global maxx, ans
        if now == n - 1:
            res[n - 1] = tot
            
            tmp = 0
            mul = 1
            for i in range(n - 1, 0, -1):
                mul *= res[i] + 1
                tmp += mul
            
            if tmp > maxx:
                maxx = tmp
                ans = res[::]
            
            return
        i = x
        while i * (n - now) <= tot:
            res[now] = i
            dfs(now + 1, tot - i, i)
            i += 1

    dfs(1, m, 0)

    print(' '.join(map(str, ans[1:])))
```

以上是打表程序。考虑 $n=20$ 时，不断加边对最优 $d$ 的分配造成的影响。

```none
m = 1: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
m = 2: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1
......
m = 18: 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
m = 19: 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2
m = 20: 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2
......
m = 35: 0 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
m = 36: 0 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
m = 37: 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
m = 38: 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3
......
m = 54: 1 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
m = 55: 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
m = 56: 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
m = 57: 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4
......
```

发现，当 $m < n - 1$ 时，加边是从 $n-1$ 开始放到 $2$，然后当 $m \geq n - 1$ 时，从 $n-1$ 开始放到 $1$，如此往复，像是在不断从右往左往序列上刷。~~感性理解，具体证明交给读者。~~

**Update on  2024.6.20 更新了进一步的证明**

下证任意相邻两数之差不超过 $1$。

> 证明：
>
> $\exists t \in [1, n-2], d_t + 2 \leq d_{t+1}$，证明 $d_t \gets d_t + 1, d_{t+1} \gets d_{t+1}-1$ 后不劣。容易发现这样操作是合法的。
>
> 对于原先的 $f_1$：
>
> $$
> \begin{aligned}
> f_1 &= \sum \limits _ {j=1} ^ {n-1} \prod \limits _ {k=j} ^ {n-1}(d_k+1)  \\
>     &= \sum \limits _ {j=t+2} ^ {n-1} \prod \limits _ {k=j} ^ {n-1}(d_k+1) + (d_{t+1} + 1) \prod \limits _ {k=t+2} ^ {n-1}(d_k+1) + \sum \limits _ {j=1} ^ {t} \left ( (d_t + 1)(d_{t+1} + 1) \prod \limits _ {k=j} ^ {t-1}(d_k+1) \prod \limits _ {k=t+2} ^ {n-1}(d_k+1) \right )  \\
>     &= \sum \limits _ {j=t+2} ^ {n-1} \prod \limits _ {k=j} ^ {n-1}(d_k+1) + (d_{t+1} + 1) \prod \limits _ {k=t+2} ^ {n-1}(d_k+1) + (d_t + 1)(d_{t+1} + 1) \sum \limits _ {j=1} ^ {t} \prod \limits _ {k=j} ^ {t-1}(d_k+1) \prod \limits _ {k=t+2} ^ {n-1}(d_k+1)  \\
>     &= \sum \limits _ {j=t+2} ^ {n-1} \prod \limits _ {k=j} ^ {n-1}(d_k+1) + \left (d_{t+1} + 1 + (d_t + 1)(d_{t+1} + 1) \sum \limits _ {j=1} ^ {t} \prod \limits _ {k=j} ^ {t-1}(d_k+1) \right ) \prod \limits _ {k=t+2} ^ {n-1}(d_k+1)
> \end{aligned}
> $$
>
> 后来的 $f_1$，记作 $f_1'$：
>
> $$
> f_1' = \sum \limits _ {j=t+2} ^ {n-1} \prod \limits _ {k=j} ^ {n-1}(d_k+1) + \left (d_{t+1} + (d_t + 2)d_{t+1} \sum \limits _ {j=1} ^ {t} \prod \limits _ {k=j} ^ {t-1}(d_k+1) \right ) \prod \limits _ {k=t+2} ^ {n-1}(d_k+1)
> $$
>
> 那么考虑作差：
>
> $$
> \begin{aligned}
> f_1' - f_1 =& \Bigg ( \Big (d_{t+1} + (d_t + 2)d_{t+1} \sum \limits _ {j=1} ^ {t} \prod \limits _ {k=j} ^ {t-1}(d_k+1) \Big ) - \\ & \Big ( d_{t+1} + 1 + (d_t + 1)(d_{t+1} + 1) \sum \limits _ {j=1} ^ {t} \prod \limits _ {k=j} ^ {t-1}(d_k+1) \Big ) \Bigg ) \prod \limits _ {k=t+2} ^ {n-1}(d_k+1)  \\
> =& \Bigg ( \Big ((d_t + 2)d_{t+1} - (d_t + 1)(d_{t+1} + 1) \Big ) \sum \limits _ {j=1} ^ {t} \prod \limits _ {k=j} ^ {t-1}(d_k+1) - 1 \Bigg ) \prod \limits _ {k=t+2} ^ {n-1}(d_k+1)  \\
> =& \Bigg ( \Big (d_{t+1} - d_t - 1 \Big ) \sum \limits _ {j=1} ^ {t} \prod \limits _ {k=j} ^ {t-1}(d_k+1) - 1 \Bigg ) \prod \limits _ {k=t+2} ^ {n-1}(d_k+1)  \\
> \end{aligned}
> $$
>
> 由于 $d_{t+1} - d_t \geq 2$，所以 $d_{t+1} - d_t - 1 \geq 1$。考虑到 $\sum \limits _ {j=1} ^ {t}$ 里至少有一个 $\prod \limits _ {k=t} ^ {t-1} = 1$，则 $\Big (d_{t+1} - d_t - 1 \Big ) \sum \limits _ {j=1} ^ {t} \prod \limits _ {k=j} ^ {t-1}(d_k+1) \geq 1$，那么有 $f_1' - f_1 \geq 0$，也就是 $f_1'$ 是不劣于 $f_1$ 的。
> 如此操作，直至 $\forall t \in [1, n-2], d_t + 1 \geq d_{t+1}$。

有了如上证明，发现 $\forall t \in [1, n-2], d_{t+1} - d_t \in \lbrace 0, 1 \rbrace$。有了这个性质，接下来的证明最优性就简单啦。交给读者自己证明。~~（中考考完再来补坑）~~

那么，我们分别考虑两种情况即可。

### 情况一

当 $m < n - 1$ 时，$d_{n - m \sim n - 1} = 1$，其他位置 $d$ 均为 $0$。此时有：

$$

\begin{aligned}

\large f_1 &= \sum \limits _ {j=1} ^ {n-1} \prod \limits _ {k=j} ^ {n-1}([k \geq n - m] + 1) \\
           &= \sum \limits _ {j=n-m} ^ {n-1} \prod \limits _ {k=j} ^ {n-1}2 + (n-m-1) \prod \limits _ {k=n-m} ^ {n-1}2  \\
           &= \sum \limits _ {j=n-m} ^ {n-1} 2 ^ {n - j} + (n-m-1) 2 ^ m  \\
           &= 2 ^ {m + 1} - 2 + (n-m-1) 2 ^ m  \\
           &= 2 ^ {m + 1} - 2 ^ m - 2 + (n-m) 2 ^ m  \\
           &= 2 ^ m - 2 + (n-m) 2 ^ m  \\
           &= (n - m + 1) 2 ^ m - 2 \\

\end{aligned}

$$

快速幂单次 $\Theta(\log m)$ 解决。

### 情况二

当 $m \geq n - 1$ 时，$d_1 = \left \lfloor \cfrac{m-(n-2)}{n-1} \right \rfloor$，$m$ 除去第一次刷的 $n-2$，和 $d_1$ 次的刷完整个序列，还剩下 $m' = m - (n - 2) - (n - 1)d_1$ 次从 $n-1$ 往左刷，故 $d_{2 \sim n - 1 - m'} = d_1 +1$，$d_{n - m' \sim n - 1} = d_1 + 2$。然后推式子。

$$

\begin{aligned}

f_1 &= \sum \limits _ {j=1} ^ {n-1} \prod \limits _ {k=j} ^ {n-1}(d_k + 1) \\
    &= \prod \limits _ {k=1} ^ {n-1}(d_k + 1) + \sum \limits _ {j=2} ^ {n-1} \prod \limits _ {k=j} ^ {n-1}(d_k + 1) \\
    &= {\scriptsize (d_1 + 1) ((d_1 + 1) + 1) ^ {(n - 1 - m') - 2 + 1} \cdot ((d_1 + 2) + 1) ^ {(n - 1) - (n - m') + 1} + \sum \limits _ {j=2} ^ {n-1} \prod \limits _ {k=j} ^ {n-1}(d_k + 1) } \\
    &= {\scriptsize (d_1 + 1) (d_1 + 2) ^ {n - m' - 2} (d_1 + 3) ^ {m'} + \sum \limits _ {j=2} ^ {n-1} \prod \limits _ {k=j} ^ {n-1}(d_k + 1) } \\
    &= {\scriptsize (d_1 + 1) (d_1 + 2) ^ {n - m' - 2} (d_1 + 3) ^ {m'} + \sum \limits _ {j=2} ^ {n-1-m'} \prod \limits _ {k=j} ^ {n-1}(d_k + 1) + \sum \limits _ {j=n-m'} ^ {n-1} \prod \limits _ {k=j} ^ {n-1}(d_k + 1) } \\
    &= {\tiny (d_1 + 1) (d_1 + 2) ^ {n - m' - 2} (d_1 + 3) ^ {m'} + \sum \limits _ {j=2} ^ {n-1-m'} \left((d_1 + 2) ^ {(n-1-m') - j + 1} \cdot (d_1 + 3) ^ {m'} \right) + \sum \limits _ {j=n-m'} ^ {n-1} \prod \limits _ {k=j} ^ {n-1}(d_k + 1) } \\
    &= {\tiny (d_1 + 1) (d_1 + 2) ^ {n - m' - 2} (d_1 + 3) ^ {m'} + (d_1 + 3) ^ {m'} \cdot \sum \limits _ {j=2} ^ {n-1-m'} (d_1 + 2) ^ {(n-1-m') - j + 1} + \sum \limits _ {j=n-m'} ^ {n-1} \prod \limits _ {k=j} ^ {n-1}(d_k + 1) } \\
    &= {\tiny (d_1 + 1) (d_1 + 2) ^ {n - m' - 2} (d_1 + 3) ^ {m'} + (d_1 + 3) ^ {m'} \cdot \sum \limits _ {j=1} ^ {(n-1-m') - 2 + 1} (d_1 + 2) ^ j + \sum \limits _ {j=n-m'} ^ {n-1} \prod \limits _ {k=j} ^ {n-1}(d_k + 1) } \\
    &= {\tiny (d_1 + 1) (d_1 + 2) ^ {n - m' - 2} (d_1 + 3) ^ {m'} + (d_1 + 3) ^ {m'} \cfrac{(d_1 + 2) ^ {n - 1 - m'} - (d_1 + 2)}{d_1 + 1} + \sum \limits _ {j=n-m'} ^ {n-1} \prod \limits _ {k=j} ^ {n-1}(d_k + 1) } \\
    &= {\tiny (d_1 + 1) (d_1 + 2) ^ {n - m' - 2} (d_1 + 3) ^ {m'} + (d_1 + 3) ^ {m'} \cfrac{(d_1 + 2) ^ {n - 1 - m'} - (d_1 + 2)}{d_1 + 1} + \sum \limits _ {j=n-m'} ^ {n-1} \prod \limits _ {k=j} ^ {n-1}(d_1 + 3) } \\
    &= {\tiny (d_1 + 1) (d_1 + 2) ^ {n - m' - 2} (d_1 + 3) ^ {m'} + (d_1 + 3) ^ {m'} \cfrac{(d_1 + 2) ^ {n - 1 - m'} - (d_1 + 2)}{d_1 + 1} + \sum \limits _ {j=n-m'} ^ {n-1} (d_1 + 3) ^ {n-j} } \\
    &= {\tiny (d_1 + 1) (d_1 + 2) ^ {n - m' - 2} (d_1 + 3) ^ {m'} + (d_1 + 3) ^ {m'} \cfrac{(d_1 + 2) ^ {n - 1 - m'} - (d_1 + 2)}{d_1 + 1} + \sum \limits _ {j=1} ^ {m'} (d_1 + 3) ^ j } \\
    &= {\tiny (d_1 + 1) (d_1 + 2) ^ {n - m' - 2} (d_1 + 3) ^ {m'} + (d_1 + 3) ^ {m'} \cfrac{(d_1 + 2) ^ {n - 1 - m'} - (d_1 + 2)}{d_1 + 1} + \cfrac{(d_1 + 3) ^ {m' + 1} - (d1 + 3)}{d_1 + 2} }

\end{aligned}

$$

其中，$d_1$ 和 $m'$ 在上文已经算出，故该式可以在 $\Theta(\log m)$ 的时间内算出。

## 代码

注意特判 $n = 1$ 的情况。

```python
def fpow(a, b, mod):
    if b < 0:
        return 1
    res = 1
    base = a % mod
    while b:
        if b & 1:
            res = res * base % mod
        base = base * base % mod
        b >>= 1
    return res

def inv(x, mod):
    return fpow(x, mod - 2, mod)

def main():
    n, m, mod = map(int, input().split())
    if n == 1:
        print(0)
        return
    if m < n - 1:
        pr = fpow(2, m, mod)
        print((pr * (n - m + 1) + mod - 2) % mod)
        return
    d1 = (m - (n - 2)) // (n - 1)
    M = m - (n - 2) - (n - 1) * d1
    S1 = (d1 + 1) * fpow(d1 + 2, n - M - 2, mod) * fpow(d1 + 3, M, mod)
    S2 = fpow(d1 + 3, M, mod) * (fpow(d1 + 2, n - 1 - M, mod) - (d1 + 2) + mod) * inv(d1 + 1, mod)
    S3 = (fpow(d1 + 3, M + 1, mod) - (d1 + 3) + mod) * inv(d1 + 2, mod)
    S1 %= mod
    S2 %= mod
    S3 %= mod
    print((S1 + S2 + S3) % mod)

if __name__ == '__main__':
    t = int(input())
    for i in range(t):
        main()
```

## 后记

~~用 `python` 写的目的是因为教练讲题时用 `python` 打表唤起了我的回忆？~~

---

## 作者：andychen_2012 (赞：2)

update on 2023.5.24 补充了一个式子的变换过程。

## 解题思路

我们观察题面后可以得到几个很直观的连接约束：

1. 每次连边一定是从 $1 \sim n-1$ 中连一条边到 $1$，否则无法最大化边数。

2. 不可能从 $n$ 出发连边，因为到了 $n$ 之后就不可能继续走了。

3. 先从 $n-1$ 开始连边，再考虑从 $n-2$ 开始连边，以此类推。

那么接下来我们来考虑一下，假设仅可以连两条边，从 $n-1$ 连两条边到 $1$ 对答案贡献大一点还是从 $n-1$ 与 $n-2$ 各连一条边到 $1$ 对答案的贡献大。

应该是两个各连一条对答案的贡献更大，因为这样的话，只花 $n-1$ 步就可走到终点的概率为 $\frac{1}{4}$，另一种方式的概率为 $\frac{1}{3}$。

但我们能不能通过计算出两种方式的期望值来进行比较呢，应该是可以的，不过式子是什么呢？

我在草稿纸上列了一下，发现搞出了一个有限微积分的式子，比较复杂，虽然可以算，但是计算方式应该比较难搬到 OI 上，因此我们来考虑另一个方向。

既然从数学方式比较难搞出来，那么它有没有可能用状态转移方程搞出来呢？（感谢 dxw 提供的思路）。

根据我们的连接约束，我们可以列出如下的状态转移方程：

$$
x_i=\frac{1}{a_i+1}x_{i+1}+\frac{a_i}{a_i+1}x_1+1
$$

其中 $x_i$ 表示从第 $i$ 个点出发到第 $n$ 个点的期望步数，$a_i$ 表示这个点往 $1$ 连的边数。$x_n=0,a_n=0$。

由于第 $i$ 点出去实际上有 $a_i+1$ 条边，而题目说了从这 $a_i+1$ 条边中等概率地选择一条边走，则有 $\frac{1}{a_i+1}$ 的概率走到第 $i+1$ 个点，有 $\frac{a_i}{a_i+1}$ 的概率走到 $1$。

然后我开始推通项公式，推出来这样的式子：

$$
x_1=\frac{1}{a_1+1}x_2+\frac{a_1x_1}{a_1+1}+1
$$

$$
x_1=x_2+a_1+1
$$

$$
(a_2+1)x_2=x_3+a_2(x_2+a_1+1)+a_2+1
$$

$$
x_2=x_3+a_1+2a_2+a_1a_2+1
$$

$$
\cdots
$$

如下这么推下去我推出了一个极其复杂的式子，很难去简化，就不展示给大家看了。

但实际上我们观察一下便可以发现：

$$
x_1=\sum_{i=1}^{n-1}\prod_{j=i}^{n-1}(a_j+1)
$$

具体推导方式如下，运用了倒推的方式（之前应该是因为思维惯性一直无法脱离正着推的魔爪）：

$$
x_{n-1}=\frac{a_{n-1}x_1}{a_{n-1}+1}+1
$$

$$
x_1=\frac{(a_{n-1}+1)(x_{n-1}-1)}{a_{n-1}}=x_{n-1}-1+\frac{x_{n-1}-1}{a_{n-1}}
$$

$$
x_{n-2}=\frac{x_{n-1}}{a_{n-2}+1}+\frac{a_{n-2}x_1}{a_{n-2}+1}+1
$$

$$
(a_{n-2}+1)x_{n-2}=\frac{a_{n-1}x_1}{a_{n-1}+1}+1+a_{n-2}x_1+a_{n-2}+1
$$

$$
x_1=\frac{1}{a_{n-1}+(a_{n-1}+1)a_{n-2}}((a_{n-1}+1)(a_{n-2}+1)x_{n-2}-2(a_{n-1}+1)-(a_{n-1}+1)a_{n-2})
$$

设 $t=
\frac{1}{a_{n-1}+(a_{n-1}+1)a_{n-2}}$，

$$
x_1=x_{n-2}+tx_{n-2}-2+t(a_{n-1}+1)a_{n-2}
$$

$$
\cdots
$$

限于篇幅，剩下的推导过程留给大家。

不过由于这个东西比较数学，身为 OIer，我们要有找规律与运用特例总结式子的思维与能力。

如我们对 $n=4,m=5$，进行手动计算。

不过在计算之前，我们需要用模拟得出 $a$ 数列的最佳方案。

最终的最优 $a$ 数列为：

```
1 2 2 0
```

我们将数据代入 $x_i=\frac{x_{i+1}+a_ix_1}{a_{i}+1}+1$ 得：

$$
x_3=\frac{2x_1}{3}+1
$$

$$
x_2=\frac{\frac{2x_1}{3}+1+2x_1}{3}+1=\frac{8x_1}{9}+\frac{4}{3}
$$

$$
x_1=\frac{\frac{8x_1}{9}+\frac{4}{3}+x_1}{2}+1=\frac{17x_1}{18}+\frac{5}{3}
$$

也即 $x_1=30$。

根据刚才的推导我们可以发现最终答案的形式可以表现为：

$$
\prod_{i=1}^{n-1}(a_i+1) \cdot\sum_{i=0}^{n-2}(\prod_{j=0}^i(a_j+1))^{-1}
$$

其中 $a_0=0$，经过小型的变换，上式与

$$
x_1=\sum_{i=1}^{n-1}\prod_{j=i}^{n-1}(a_j+1)
$$

是等价的。

（这里补充一下变换过程）

$$
\sum_{i=1}^{n-1}\prod_{j=i}^{n-1}(a_j+1)=\sum_{i=1}^{n-1}\frac{\prod_{j=0}^{n-1}(a_j+1)}{\prod_{j=0}^{i-1}(a_j+1)}
$$

$$
=\prod_{i=1}^{n-1}(a_i+1) \cdot\sum_{i=0}^{n-2}(\prod_{j=0}^i(a_j+1))^{-1}
$$

因此我们可以列出一个计算期望步数的 $O(n)$ 算式。

这样的话我们可以通过 dfs 通过前面的 2 个 Subtask。

所以接下来重要的问题就是 $a$ 数列的形式。

不过我们瞄一眼数据范围，看到了一个 $m<n-1$，这一部分肯定是从 $n-1$ 到 $n-m$ 各放一条边到 1 是最好的，这样我们可以 $O(\log n)$ 计算出期望步数，时间复杂度瓶颈在于快速幂。

我们在通过多组数据模拟后，我们可以发现如下规律：

1. $a_1$ 必然是 $a_1 \sim a_{n-1}$ 中的最小值，且是唯一的最小值。

2. $\max\limits_{i=1}^{n-1}a_i-\min\limits_{i=1}^{n-1}a_i \le 2$。

3. $a_1 \sim a_{n-1}$ 单调不降。

4. $a_n=0$。

可以从我们的连接原则或说是连接约束以及期望步数计算公式可以推导出来。大家可以具体做一个推导。

最后的合法 $a$ 数列具体表现形式有可能如下：

```
2 4 4 4 4 0
```

也有可能是

```
4 6 6 6 6 6 6 0
```

样例的第二个数据的 $a$ 数列如下：

```
1 3 3 3 3 3 3 3 3 0
```

样例的第三个数据的 $a$ 数列如下：

```
2468 2469 2469 2469 2470 0
```

进行手动模拟计算发现正确。

当 $m\ge n-1$ 时，$a_1=\lfloor\frac{m-n+2}{n-1}\rfloor,m=m-a_1-(n-2)(a_1+1),a_{2 \sim n-m-1}=a_1+1,a_{n-m \sim n-1}=a_1+1$。

那么现在我们就可以得到最后的代码，时间复杂度为 $O(T\log m)$，瓶颈在于快速幂。

## 解题代码


```cpp
#include<cstdio>
typedef long long ll;
inline ll read(){
	ll x=0,f=0,ch=0;
	while(ch<48||ch>57) f=(ch=='-'),ch=getchar();
	while(ch>47&&ch<58) x=(x<<3)+(x<<1)+(ch&15),ch=getchar();
	return f?-x:x;
}
inline void write(ll x,char end=' '){
	if(x==0){
		putchar('0');
		putchar(end);
		return;
	}
	if(x<0) putchar('-'),x=-x;
	int ch[70]={0},cnt=0;
	while(x){
		ch[cnt++]=x%10;
		x/=10;
	}
	while(cnt--) putchar(ch[cnt]+48);
	putchar(end);
}
ll n;
ll m,p;
ll a[1005],b[1005];
ll ans;
inline ll max(ll x,ll y){return x>y?x:y;}
inline ll fp(ll x,ll y){
	ll s=1;
	while(y){
		if(y&1) s=s*x%p;
		x=x*x%p;
		y>>=1;
	}
	return s;
}
inline ll dv(ll x,ll y){return x*fp(y,p-2)%p;}
int main(){
	int T=read();
	while(T--){
		n=read();
		m=read(),p=read();
		if(n==1){
			write(0,'\n');
			continue;
		}
		if(m<n-1){
			ll prod=fp(2,m);
			m%=p;
			ans=prod*(n-m+p)%p;
			ans=(ans+prod-2)%p;
			ans=(ans+p)%p;
			write(ans,'\n');
			continue;
		}
		ans=0;
		a[1]=(m-n+2)/(n-1);
		m-=a[1];
		m-=(n-2)*(a[1]+1);
		a[1]%=p;
		ll prod=fp(a[1]+3,m);
		ll sum=0;
		if(m>0)
			sum=dv(((prod*(a[1]+3)%p-a[1]-3)%p+p)%p,a[1]+2);
		ll prod2=fp(a[1]+2,n-2-m);
		if(n-2-m>0)
			sum=(sum+prod*dv(((prod2*(a[1]+2)-(a[1]+2))%p+p)%p,a[1]+1)%p)%p;
		prod=prod*prod2%p;
		sum=(sum+prod*(a[1]+1)%p)%p;
		sum=(sum%p+p)%p;
		ans=sum;
		write(ans,'\n');
//		for(int i=1;i<=n;++i) write(a[i]);
//		puts("");
	}
}
```

---

## 作者：流水行船CCD (赞：1)

模拟赛考到了，推出 $E$ 的式子，但猜错贪心结论。

## 思路

首先特判 $n=1$ 的情况，此时答案为 $0$。由于本题变量太多，考虑分析新增的边的特征和共性。

- **观察 1**：新增的边一定形如 $i \to 1$。

感性理解：因为你希望它走的更远，显然你每个点让他绕回 $1$ 是最远的。

有了**观察 1** 之后，此时 $1 \to n$ 的步数期望仅跟每一个点的新增度数有关，不妨设一个点的新增度数为 $d_i$，接下来考虑列出答案 $E$ 的式子。

设 $p_i$ 为从 $1$ 至 $i$ 不走回头路的概率，则有：

$$
p_i = \prod_{j=1}^{i-1} \frac{1}{d_j+1}
$$

发现从 $1$ 走到 $n$ 的路径是若干个圈+一条路径，枚举第一次在哪里走回头路形成圈，不难列出步数的期望 $E$ 的式子：

$$
\begin{aligned}
E &= p_n(n-1) + \sum_{i=1}^{n-1} p_i\frac{d_i}{d_i+1}(i+E)\\
&= p_n(n-1) + (1-p_n)E + \sum_{i=1}^{n-1} p_i\frac{d_i}{d_i+1}i\\
&= (n-1) +\sum_{i=1}^{n-1} \frac{p_i}{p_n}\frac{i\cdot d_i}{d_i+1}\\
&= (n-1)+\sum_{i=1}^{n-1}i\cdot d_i \prod_{j=i+1}^{n-1}(d_j+1)
\end{aligned}
$$

虽然该式子具有正确性，但与其他题解的式子 $E =\sum_{i=1}^{n-1} \prod_{j=i}^{n-1} (d_j+1)$ 不同，且更为复杂，难以化简。因此本题对于贪心结论的证明请详见其他题解。（我试图将该式子化简为题解中的式子，但失败了，有大佬会的可以私信教我）

注意到 $n,m$ 大的离谱，这提示我们去观察性质，大概率有一个贪心策略可以确定 $d$ 的值。

- **观察 2**：$d_i$ 非降。

感性理解：因为你越靠后连边可以让他绕的圈更大。

此时可以写一个暴力去枚举 $d$ 打表（~~我考场暴力程序错了~~），通过找规律不难发现最优的分配 $d$ 的策略是固定的，如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/534k7ww4.png)

- **观察 3**：当 $m\ge n-2$ 时最优的 $d$ 一定形如 $D-1,D,D,\cdots D,D+1,D+1,\cdots,D+1$，也就是把 $d$ 分为段内值相同的三段。

感性理解：因为我们希望 $d$ 尽可能的平均，这样可以最大化 $E$ 式子中的 $\prod$ 的值，但是 $1$ 实在太劣了（前面乘的系数 $i$ 只有 $1$），因此不如把 $d_1$ 的值分一些到后面去。提现到理性证明上，对应条件 $d_i-d_{i-1}\le1$，$d_1 \ne d_2$ 和 $d_{n-1}-d_1\le 2$，证明很复杂，在此不证了。

设这三段的 $d$ 值分别为 $d_{1,2,3}$，长度分别为 $l_{1,2,3}$，写出三段带权等比数列对答案的贡献，推式子/矩阵快速幂即可优化，这里选择推式子，过程如下：

- **Case 1**：

$$
\begin{aligned}
S_1 &= d_1 (d_2+1)^{l_2} (d_3+1)^{l_3}\\
\end{aligned}
$$

- **Case 2**：

$$
\begin{aligned}
S_2 &= d_2(d_3+1)^{l_3}\sum_{i=2}^{l_2+1}i\cdot (d_2+1)^{l_2+1-i} \\
令 S' &= \sum_{i=2}^{l_2+1}i\cdot (d_2+1)^{l_2+1-i} 则：\\
(d_2+1)S' &= \sum_{i=1}^{l_2}(i+1)\cdot(d_2+1)^{l_2+1-i}\\
(d_2+1)S'-S'&=2\cdot(d_2+1)^{l_2}-(l_2+1)+\sum_{i=2}^{l_2}(d_2+1)^{l_2+1-i}\\
S'&=\frac{1}{d_2}(2\cdot(d_2+1)^{l_2}-(l_2+1)+\frac{(d_2+1)^{l_2}-(d_2+1)}{d_2})\\
S_2&=(d_3+1)^{l_3}(2\cdot(d_2+1)^{l_2}-(l_2+1)+\frac{(d_2+1)^{l_2}-(d_2+1)}{d_2})
\end{aligned}
$$

- **Case 3**：

$$
\begin{aligned}
S_3 &= d_3 \sum_{i=l_2+2}^{n-1} i(d_3+1)^{n-1-i}\\
(d_3+1)S_3 &= d_3 \sum_{i=l_2+1}^{n-2} (i+1)(d_3+1)^{n-1-i}\\
(d_3+1)S_3-S_3 &= d_3((l_2+2)(d_3+1)^{l_3}-(n-1)+\sum_{i=l_2+2}^{n-2} (d_3+1)^{n-1-i})\\
S_3 &= (l_2+2)(d_3+1)^{l_3}-(n-1)+\frac{(d_3+1)^{l_3}-(d_3+1)}{d_3}
\end{aligned}
$$

注意特判 $m<n-1$ 的情况，此时 $d$ 数组是一段长度为 $m$ 的后缀 $1$，由于答案的推导和上面类似，这里只给出原式子以及化简后的结果：

$$
\begin{aligned}
E &= (n-1)+\sum_{i=n-m}^{n-1}i\cdot 2^{n-1-i}\\ 
&= (n-m+1) \cdot 2^m - 2
\end{aligned}
$$

另：从这种特殊情况的式子就可以印证我推出的 $E$ 表达式和其他题解的 $E$ 表达式本质相同。

至此，可以在 $\mathcal{O}(T\log n)$ 时间内解决。注意勤取模，$d_{1,2,3},l_{1,2,3}$ 都有可能在 $[0,10^{18}]$ 范围中。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace fast_IO{
#define ld cin
#define jyt cout
} using namespace fast_IO;
#define ll long long
#define ull unsigned long long
#define REP(i, l, r) for (int i = l; i <= r; ++i)
#define PER(i, l, r) for (int i = l; i >= r; --i)
#define bitcount(x) __builtin_popcount(x)
#define int long long
const int N = 5e5 + 7;
const ll inf = 2e18 + 7;
namespace JoKing {
    int T, n, m, P, d[N];
    inline ll qpow(ll x, ll y) {ll R = 1; x %= P; for (; y; (x *= x) %= P, y >>= 1ll) if (y & 1ll) (R *= x) %= P; return R;}
    signed main() { srand(time(0));
    	ld >> T;
		while (T--) {
			ld >> n >> m >> P;
			if (n == 1) {jyt << "0\n"; continue;}
			if (n <= 100 && m <= 30000) {
				int tot = n - 1, flag = 1;
				REP(i, 1, n) d[i] = 0;
				while (m) {
					if (flag && tot == 1) {flag = 0, tot = n - 1;}
					++d[tot], --m, tot = (tot == 1 ? n - 1 : tot - 1);
				}
				if (d[2] - d[1] == 2) ++d[1], --d[2];
				ll Ans = n - 1, Mul = 1;
				PER(i, n - 1, 1) {
					(Ans += (ll)i * d[i] % P * Mul) %= P;
					(Mul *= (d[i] + 1)) %= P; 
				}
				jyt << Ans << '\n';
			} else if (m < n - 1) {
				// (n - m + 1) * 2 ^ m - 2ll
				jyt << ((n - m + 1) * qpow(2ll, m) % P - 2ll + P) % P << '\n';		
			} else {
				m -= (n - 2);
				ll d2 = m / (n - 1) + 1, d1 = d2 - 1, d3 = d2 + 1, len3 = m % (n - 1), len2 = n - 2 - len3;
				// 1: d2-1:
				// 2: d2+0:
				// 3: d2+1:
				ll Ans1 = (d1 % P) * qpow(d2 + 1, len2) % P * qpow(d3 + 1, len3) % P;
				ll Ans2 = qpow(d3 + 1, len3) * ((2ll * qpow(d2 + 1, len2) % P - (len2 % P + 1) + P + (qpow(d2 + 1, len2) - (d2 % P + 1) + P) * qpow(d2, P - 2) % P) % P) % P; 
				ll Ans3 = ((len2 % P + 2ll) * qpow(d3 + 1, len3) % P - (n - 1) + P + (qpow(d3 + 1, len3) - (d3 % P + 1) + P) * qpow(d3, P - 2) % P) % P;
                jyt << ((n - 1) + Ans1 + Ans2 + Ans3) % P << '\n';
			}
		}	
		return 0; 	
    }
}
signed main() {
#ifdef WYY
    freopen("files/code.in", "r", stdin);
    freopen("files/code.out", "w", stdout);
    freopen("files/code.err", "w", stderr);
#endif
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    JoKing::main(); return 0;
}
```

---

## 作者：cwfxlh (赞：1)

# [P8989](https://www.luogu.com.cn/problem/P8989)        

发现期望要取模，于是必须想个办法直接算出最大期望步数。           


首先发现连的每条边肯定终点都是 1，这是显然的，于是记 $g_i$ 表示点 $i$ 向 1 连的边数，则考虑怎么算期望步数。令 $f_i$ 表示从 1 到 $i$ 期望走几步，期望步数就是 $f_n$。从 $i$ 到 $i+1$ 有 $g_i+1$ 条边，只有一条能成功走过去，其他的边都会重回原点，期望走 $g_i+1$ 次才成功，所以 $f_{i+1}=(g_i+1)(f_i+1)$。记 $G_i=g_i+1$，最后有：       

$$f_n=G_{n-1}(G_{n-2}(G_{n-3}(G_{n-4}\dots+1)+1)+1)$$      

$$f_n=\sum_{i=1}^{n-1}\prod_{j=i}^{n-1}G_j$$    

也就是说，期望步数是 G 的后缀积之和。       

问题变成了，将 $m+n-1$ 拆成 $n-1$ 个正整数，最大化它们的后缀积之和。         

首先否一个结论，答案不是直接平均分，本人最初以为是这个结果过不了样例。接下来开始推结论。     

首先序列不降，因为如果有 $G_i>G_{i+1}$ 交换显然更优。      

其次 $G_1$ 与 $G_{n-1}$ 差不超过 2（即极差不大于 2），原因可以通过分析将 $G_1+1$，将 $G_{n-1}-1$ 后发生的变化值得到。具体的，增加的值为：         

$$(G_{n-1}-G_1-1)\prod_{i=2}^{n-2}G_i-\sum_{i=2}^{n-1}\prod_{j=i}^{n-2}G_j$$          

将式子前半部分缩小为 $2\prod_{i=2}^{n-2}G_i$，发现如果 $G_2$ 到 $G_{n-2}$ 都 $>1$ 那么这个增加的值必定非负，于是调整显然更优。如果 $G_2=1$，那么找到最后一个 $=1$ 的位置 $x$，将 $G_x+1$，并将 $G_{n-1}-1$，可以通过同样的方式证明调整更优，并且同样缩小了极差。      

再来证明最后一条性质，如果 $m-n+1\ge2(n-1)$，那么 $G_1$ 是唯一的最小值。如果 $G_1=G_2$，那么将 $G_2+1$，并将 $G_1-1$，值不会变劣（并且如果第一个相同值连续段长度 $>2$ 的话会变得更优）。如果 $m-n+1<2(n-1)$，那么照上述方法调整的话会出现 $G_1=0$ 的情况，不符合要求，所以要特殊处理。          

综合这三条性质，已经可以具体的求出 $G$ 了。求答案的时候需要一个快速幂函数和求同底数幂的前缀和的函数，复杂度 $O(T\log m)$，记得特殊处理 $m-n+1<2(n-1)$。            

代码：           


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T,n,m,mod,ans,k1,k2,k3,k4,k5,k6,k7,k8,k9;
int fstp(int X,int Y){int ret=1,bse=X%mod;while(Y){if(Y%2)ret=ret*bse%mod;bse=bse*bse%mod;Y/=2;}return ret;}
int getval(int X,int l,int r){
    if(X==1)return (r-l+1)%mod;
    if(X==0)return 0;
    int ret=(fstp(X,r+1)-fstp(X,l))%mod;
    ret=ret*fstp(X-1,mod-2)%mod;
    return ret;
}
void sol(){
    cin>>n>>m>>mod;
    if(n==1){cout<<0<<'\n';return;}
    if(m==0){cout<<(n-1)%mod<<'\n';return;}
    ans=0;
    n--;
    m+=n;
    if(m<2*n)ans=getval(2,1,m-n)+fstp(2,m-n)*(2*n-m);
    else{
        if(m%n==(n-1))ans=getval((m/n)+1,1,n-1)+fstp((m/n)+1,n-1)*((m/n)%mod);
        else{
            k1=(m/n);
            k3=(m%n)+1;
            k2=(n-1)-k3; 
            ans=(getval(k1+1,1,k3)+getval(k1,1,k2)*fstp(k1+1,k3))%mod;
            ans=(ans+(fstp(k1+1,k3)*fstp(k1,k2)%mod)*((k1-1)%mod))%mod;
        }
    }
    ans%=mod;
    ans+=mod;
    ans%=mod;
    cout<<ans<<'\n';
    return;
}
signed main(){
    ios::sync_with_stdio(false);
    cin>>T;
    while(T--)sol();
    return 0;
}
```

---

## 作者：ducati (赞：1)

## Description

[传送门](https://www.luogu.com.cn/problem/P8989)

## Solution

### Part 1

根据贪心思想，对于每条加入的边 $u \to v$，均有 $u \in [1,n), v = 1$。

记 $S(z)$ 为 $m=z$ 时，某组最优解中，所有加入的边的起点构成的集合（特别的，$S(0) = \emptyset$）。打表发现：$\forall z \ge 1$，$S_z(z - 1) \subset S_z(z)$，

记 $t_z$ 为 $S(z) - S(z-1)$ 的唯一元素，考虑 $t$ 有何规律。打表发现，当 $n=6$ 时，$t$ 的前 $19$ 项依次为：`5 4 3 2 5 4 3 2 1 5 4 3 2 1 5 4 3 2 1`。

规律一目了然：$t_1,t_2,\cdots,t_{n-1}$ 依次为从 $n-1$ 到 $2$ 的所有整数；之后的部分周期为 $n-1$，每个周期是从 $n - 1$ 到 $1$ 的所有整数。

### Part 2

令 $c_i$ 为以 $i$ 为起点的边数，则 $c[1,n-1]$ 可以被划分为 $\le 3$ 段，满足每一段内的元素全部相等。

令 $f_i$ 为从 $i$ 走到终点的期望步数。记答案 $x = f_1$，则 $\forall i \in [2,n]$，可以递推出 $k_i,b_i$，满足 $f_i = k_ix+b_i$，则 $x = \frac {-b_n} {k_n}$。

由于递推式是线性变换，对于每一段作矩阵快速幂，从而推出 $f_n,g_n$ 即可，时间复杂度 $O(\sum \log n)$。

## Code

注意特判 $n=1$，并小心模数 $\le m$ 的情况，避免除以 $0$。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

namespace IO{
	inline char nc(){
		static char buf[500001],*p1=buf,*p2=buf;
		return p1==p2&&(p2=(p1=buf)+fread(buf,1,500000,stdin),p1==p2)?EOF:*p1++;
	}
	char out[500001],*pout=out,*eout=out+500000;
	template<typename T> inline T read(){
		char ch=nc(); T sum=0; bool f=false;
		for(;ch<'0'||ch>'9';ch=nc()) if(ch=='-') f=1;
		while(ch>='0'&&ch<='9')sum=sum*10+ch-48,ch=nc();
		return f?-sum:sum;
	}
}
#define read IO::read<int>

int n,m,mod,K,B,trn; vector<pair<int,int>> vec;
struct Matrix{
	int a[2][2];
	Matrix operator * (const Matrix &A) const{
		Matrix res;
		for (int i=0;i<2;i++){
			for (int j=0;j<2;j++)  res.a[i][j]=(a[i][0]*A.a[0][j]+a[i][1]*A.a[1][j])%mod;
		}
		return res;
	}
}M;
inline void Add(int l,int r,int t=1){if(l<=r)vec.emplace_back(l,t),vec.emplace_back(r,-t);}
inline int quick_power(int x,int y){
	int res=1;
	for (;y;y>>=1,(x*=x)%=mod) {if(y&1)(res*=x)%=mod;}
	return res;
}
inline Matrix quick_power(Matrix x,int y){
	Matrix res=x; y--;
	for (;y;y>>=1,x=x*x) {if(y&1)res=res*x;}
	return res;
}
inline int getinv(int x){return quick_power(x,mod-2);}
signed main(){
	int T=read();
	while (T--){
		n=read(),m=read(),mod=read(),vec.clear(),Add(1,n,0),K=1,B=0;
		if (n==1) {puts("0");continue;}
		if (m<n-1)  Add(n-m,n);
		else{
			Add(2,n),m-=n-2;
			Add(1,n,trn=m/(n-1)),m-=trn*(n-1);
			Add(n-m,n);
		}
		sort(vec.begin(),vec.end());
		for (int i=1,s=0,q;i<(int)vec.size();i++){
			int l=vec[i-1].first,r=vec[i].first; (s+=vec[i-1].second)%=mod;
			auto upd=[&](int &var,int x){
				M.a[0][0]=q,M.a[1][0]=mod-x,M.a[1][1]=1;
				M=quick_power(M,r-l),var=(var*M.a[0][0]+M.a[1][0])%mod;
			};
			if (l<r)  q=s+1,upd(K,s),upd(B,q);
		}
		printf("%lld\n",((-B*getinv(K))%mod+mod)%mod);
	}
	return 0;
}
```



---

## 作者：Nelofus (赞：1)

[Link](https://www.luogu.com.cn/problem/P8989)

给一张 $n$ 个点的有向图，初始对于 $\forall i\in [1, n-1]$，在 $i$ 与 $i+1$ 之间有一条有向边

在其中再加入 $m$ 条有向边，允许重边和自环，最大化从 $1$ 到 $n$ 的期望步数



我们可以注意到几条简单的性质

1. 为了尽可能最大化期望步数，所有边都会往 $1$ 连
2. 不可能从 $n$ 连出边

设 $\mathrm{EX}(p)$ 为从 $p$ 出发到 $n$ 的期望距离，点 $p$ 连了 $a_p$ 条边出来，那么
$$
\mathrm{EX}(p)=\dfrac{1}{a_p+1}\mathrm{EX}(p+1)+\dfrac{a_p}{a_p+1}\mathrm{EX}(1)+1
$$
而有 $\mathrm{EX}(n)=0$


$$
\begin{aligned}
\mathrm{EX}(n-1)
&=\dfrac{a_{n-1}}{a_{n-1}+1}\mathrm{EX}(1)+1\\
\mathrm{EX}(n-2)
&=\dfrac{a_{n-2}}{a_{n-2}+1}\mathrm{EX}(1)
+\dfrac{1}{a_{n-2}+1}(\mathrm{EX}(n-1))+1\\
&=\dfrac{a_{n-2}}{a_{n-2}+1}\mathrm{EX}(1)
+\dfrac{1}{a_{n-2}+1}(\dfrac{a_{n-1}}{a_{n-1}+1}\mathrm{EX}(1)+1)+1\\
&=\dfrac{a_{n-2}(a_{n-1}+1)+a_{n-1}}{(a_{n-2}+1)(a_{n-1}+1)}\mathrm{EX}(1)+\dfrac{a_{n-2}+2}{a_{n-2}+1}
\end{aligned}
$$


令 $t_k=\prod_{i=k}^{n-1}(a_i+1)$

则
$$
\begin{aligned}
\mathrm{EX}(n-2)
&=\dfrac{t_{n-2}-1}{t_{n-2}}\mathrm{EX}(1)+\dfrac{a_{n-2}+2}{a_{n-2}+1}
\end{aligned}
$$
接下来
$$
\begin{aligned}
\mathrm{EX}(n-3)
&=\dfrac{a_{n-3}}{a_{n-3}+1}\mathrm{EX}(1)
+\dfrac{1}{a_{n-3}+1}(\mathrm{EX}(n-2))+1\\
&=\dfrac{a_{n-3}}{a_{n-3}+1}\mathrm{EX}(1)
+\dfrac{1}{a_{n-3}+1}(\dfrac{t_{n-2}-1}{t_{n-2}}\mathrm{EX}(1)+\dfrac{a_{n-2}+2}{a_{n-2}+1})+1\\
&=\dfrac{a_{n-3}t_{n-2}+t_{n-2}-1}{t_{n-3}}\mathrm{EX}(1)+\dfrac{a_{n-2}+2+(a_{n-3}+1)(a_{n-2}+1)}{(a_{n-3}+1)(a_{n-2}+1)}\\
&=\dfrac{t_{n-3}-1}{t_{n-3}}\mathrm{EX}(1)+\dfrac{\sum_{i={n-3}}^{n-2}\frac{t_{i}}{a_{n-1}+1}+1}{\frac{t_{n-3}}{a_{n-1}+1}}\\
\mathrm{EX}(n-4)
&=\dfrac{a_{n-4}}{a_{n-4}+1}\mathrm{EX}(1)
+\dfrac{1}{a_{n-4}+1}(\mathrm{EX}(n-3))+1\\
&=\dfrac{a_{n-4}}{a_{n-4}+1}\mathrm{EX}(1)+\dfrac{1}{a_{n-4}+1}(\dfrac{t_{n-3}-1}{t_{n-3}}\mathrm{EX}(1)+\dfrac{\sum_{i={n-3}}^{n-2}\frac{t_{i}}{a_{n-1}+1}+1}{\frac{t_{n-3}}{a_{n-1}+1}})+1\\
&=\dfrac{t_{n-4}-1}{t_{n-4}}\mathrm{EX}(1)+\dfrac{\sum_{i=n-4}^{n-2}\frac{t_i}{a_{n-1}+1}+1}{\frac{t_{n-4}}{a_{n-1}+1}}
\end{aligned}
$$
那么我们就有了一般的形式
$$
\begin{aligned}
\mathrm{EX}(k)
&=\dfrac{t_k-1}{t_k}\mathrm{EX}(1)+\dfrac{\sum_{i=k}^{n-2}\frac{t_i}{a_{n-1}+1}+1}{\frac{t_k}{a_{n-1}+1}}\\
&=\dfrac{t_k-1}{t_k}\mathrm{EX}(1)+\dfrac{\sum_{i=k}^{n-2}t_i}{t_k}+\dfrac{a_{n-1}+1}{t_k}\\
\end{aligned}
$$
所以
$$
\begin{aligned}
\mathrm{EX}(1)
&=\dfrac{t_1-1}{t_1}\mathrm{EX}(1)+\dfrac{\sum_{i=1}^{n-2}t_i}{t_1}+\dfrac{a_{n-1}+1}{t_1}\\
&=\sum_{i=1}^{n-2}t_i+a_{n-1}+1\\
&=\sum_{i=1}^{n-1}t_i\\
&=\sum_{i=1}^{n-1}\prod_{j=i}^{n-1}(a_j+1)
\end{aligned}
$$
爆搜一下数列 $a$ 就可以狂砍 $20\rm{pts}$ 了！

现在的问题就在于最大化 $\sum_{i=1}^{n-1}\prod_{j=i}^{n-1}(a_j+1)$

观察可以发现在越靠后的位置，对于 $a_i$ 对答案的贡献应该是更大的，应该尽可能大

对于 $m < n-1$ 的情况，容易想到在 $n-m\sim n-1$ 之间各放一个是最好的

当 $m\ge n-1$ 的情况，整个序列分为三段，第一段为 $a_1=\lfloor\dfrac{m-(n-2)}{n-1}\rfloor$，第二段为 $2\sim n-(m-a_1-(n-2)(a_1+1))-1$，其中 $a$ 的值为 $a_1+1$，最后一段是 $n-(m-a_1-(n-2)(a_1+1))\sim n-1$，其中 $a$ 的值为 $a_1+2$

可以证明这是最优的分配方案，否则可以调整得到更优的方案

然后直接做就可以了，在相同的段内等比数列求和即可

如果一定要从小到大枚举的话可以换一下形式
$$
\begin{aligned}
\sum_{i=1}^{n-1}\prod_{j=i}^{n-1}(a_j+1)
&=\sum_{i=1}^{n-1}\dfrac{\prod_{j=1}^{n-1}(a_j+1)}{\prod_{j=1}^{j=i-1}(a_j+1)}\\
&=\prod_{i=1}^{n-1}(a_i+1)\sum_{i=1}^{n-1}\bigg(\prod_{j=1}^{i-1}(a_j+1)\bigg)^{-1}
\end{aligned}
$$

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>

typedef long long ll;
using namespace std;
ll n, m, mod;
ll a1, ans;

ll f_pow(ll a, ll k) {
	a %= mod;
	ll base = 1;
	for(; k; k >>= 1, a = (a * a) % mod) {
		if(k & 1)
			base = (base * a) % mod;
	}
	return base;
}

ll Plus(ll a, ll b) {
	a += b;
	return a >= mod ? a - mod : a;
}

ll Minu(ll a, ll b) {
	a -= b;
	return a < 0 ? a + mod : a;
}

//等比数列求和,首项为a,公比为p,长度为len
ll SequenceSum(ll a, ll p, ll len) {
	p %= mod;
	return a % mod * Minu(1, f_pow(p, len)) % mod * f_pow(Minu(1, p), mod - 2) % mod;
}

int main() {
	int T;
	scanf("%d", &T);
	while(T--) {
		scanf("%lld%lld%lld", &n, &m, &mod);
		if(m < n - 1) {
			ll sum1 = SequenceSum(2, 2, m);
			ll sum2 = f_pow(2, m) * (n - m - 1) % mod;
			printf("%lld\n", Plus(sum1, sum2));
			continue;
		}
		if(n == 1) {
			printf("0\n");
			continue;
		}
		a1 = (m - n + 2) / (n - 1);
		ll res = m - a1 - (n - 2) * (a1 + 1);
		ll mid = n - res - 1;

		if(mid == 1) {
			ll sum1 = SequenceSum(a1 + 3, a1 + 3, (n - 1) - 1);
			ll prod = f_pow(a1 + 3, (n - 1) - 1);
			ll sum2 = (a1 + 1) % mod * prod % mod;
			printf("%lld\n", Plus(sum1, sum2));
		} else if(mid == n - 1) {
			ll sum1 = SequenceSum(a1 + 2, a1 + 2, (n - 1) - 1);
			ll prod = f_pow(a1 + 2, (n - 1) - 1);
			ll sum2 = (a1 + 1) % mod * prod % mod;
			printf("%lld\n", Plus(sum1, sum2));
		} else {
			ll sum1 = SequenceSum(a1 + 3, a1 + 3, res);
			ll prod1 = f_pow(a1 + 3, res);
			ll sum2 = SequenceSum(prod1 * ((a1 + 2) % mod) % mod, a1 + 2, mid - 1);
			ll prod2 = f_pow(a1 + 2, mid - 1);
			ll sum3 = (a1 + 1) % mod * prod2 % mod * prod1 % mod;
			printf("%lld\n", Plus(sum1, Plus(sum2, sum3)));
		}
	}
	return 0;
}
```


---


# [北大集训 2021] 出题高手

## 题目背景

CTT2021 D3T2

## 题目描述

Alice 是一个出题高手。

Alice 每天都会出一道题，这样 $n$ 天过去，她就出了 $n$ 道题了。

第 $n+1$ 天，Alice 没有出题，她打算从之前的 $n$ 道题中选择若干道组成一个比赛。方便起见，她决定这些选择的题目得是**连续**的一个时间段出的，也就是这些题目必须形如：第 $l$ 天到第 $r$ 天出的所有题目（$1\le l \le r \le n$）。

Alice 还给每个题目一个评分，第 $i$ 个题目的评分为 $a_i(-1000 \le a_i \le 1001)$ ，评分越高代表这道题越偏智商，评分越低说明这道题越偏码力。

Alice 希望组成的比赛具备特色，也即整体偏向代码或者整体偏向智商。一场以 Alice 第 $l$ 天到第 $r$ 天出的题目组成的比赛的特色程度定义为 $\Large \frac{(\sum_l^r a_i)^2}{r-l+1}$ ，Alice 想要**最大化**这个特色程度。

现在，对于 $m$ 个形如 $ql_i,qr_i$ 的询问，你需要回答如果将 Alice  能选择的题目限定在第 $ql_i$ 到 $qr_i$ 天出的题，Alice 能组成的特色程度最大的比赛的特色程度是多少，你需要以分数的形式输出这个特色程度。

由于 Alice 出题的水平过于高超，你可以认为每道题的评分是**随机生成**的。


## 说明/提示

| 子任务 |   $n=$   |   $m=$   | 分值 |
| :----: | :------: | :------: | :--: |
|  $1$   |  $2000$  | $100000$ | $5$  |
|  $2$   | $100000$ |   $1$    | $15$ |
|  $3$   | $500000$ |   $1$    | $30$ |
|  $4$   | $100000$ |  $5000$  | $15$ |
|  $5$   | $100000$ | $300000$ | $35$ |



对于 第 $2$ 个和第 $3$ 个子任务，保证所有询问满足 $ql_i = 1$，$qr_i = n$。

所有的 $a_i$ 保证满足 $-1000 \le a_i \le 1001$。且对于 $a_i$ ，数据生成方式为每次独立地从 $[-1000,1001]$ 中等概率随机选取一个整数。


## 样例 #1

### 输入

```
5
-962 -445 -613 -9 920
3
1 5
3 5
1 3
```

### 输出

```
4080400 3
846400 1
4080400 3
```

# 题解

## 作者：童年的小翼龙 (赞：11)

我们充分发扬人类智慧，数学直觉告诉我们，在 $a$ 随机的情况下，我们最终的答案区间不会太长。

于是，我们对于一个固定的右端点，只枚举前 $2000$ 小的区间。对于统计答案，我们从左往右扫描线，计算出考虑前 $i$ 个 $a$ 时，以每个位置作为左端点的最优答案，由于修改和查询次数相差过大，我们可以用分块 $O(1)-O(\sqrt n)$ 地维护。这样就可以在一个比较快的时间内通过除了第三个包之外的所有点。

对于第三个包，由于只有一个询问，所以我们猜测这时候的区间长度会更小，于是我们只枚举长度小于等于 $400$ 的区间，就可以通过第三个包。

时间复杂度 $O(n\sqrt n)$，正确概率未知。

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Slongod{
using ll = long long;
constexpr int N = 5e5+7 , B = 500;
int n , m , a[N] , bl[N];
struct frac{
    ll a , b;
    void yuefen(){ll g = __gcd(a , b); a /= g; b /= g;}
    frac(){a = 0; b = 1;} frac(ll x , ll y){a = x; b = y;}
    bool operator < (const frac&x) const{return a * x.b < x.a * b;}
}ans[N] , now[N] , tag[N];
vector <pair<int,int>> p[N];
void main()
{
    cin >> n; for (int i = 1; i <= n; i++){cin >> a[i]; bl[i] = (i - 1) / B + 1;}
    cin >> m; for (int i = 1 , l , r; i <= m; i++){cin >> l >> r; p[r].push_back({l , i});}
    const int d = (n > 100005 ? 400 : 2000); int t = m;
    for (int i = 1; i <= n; i++) {
        for (int j = i , sum = a[i]; j >= 1 and j > i - d; j-- , sum += a[j]) {
            auto v = frac(1ll * abs(sum) * abs(sum) , i - j + 1);
            if (now[j] < v){now[j] = v;}
            if (tag[bl[j]] < v){tag[bl[j]] = v;}
        }
        for (auto o : p[i]) { t--;
            if (bl[i] == bl[o.first]) {
                for (int j = o.first; j <= i; j++) {
                    ans[o.second] = max(ans[o.second] , now[j]);
                }
            } else {
                for (int j = o.first; bl[j] == bl[o.first]; j++) {
                    ans[o.second] = max(ans[o.second] , now[j]);
                }
                for (int j = bl[o.first] + 1; j < bl[i]; j++) {
                    ans[o.second] = max(ans[o.second] , tag[j]);
                }
                for (int j = i; bl[j] == bl[i]; j--) {
                    ans[o.second] = max(ans[o.second] , now[j]);
                }
            }
        }
        if (!t){break;}
    }
    for (int i = 1; i <= m; i++) {
        ans[i].yuefen();
        cout << ans[i].a << ' ' << ans[i].b << '\n';
    }
}
}int main()
{
    ios :: sync_with_stdio(0);
    cin.tie(0) , cout.tie(0);
    return Slongod :: main(),0;
}
```

---

## 作者：xiao7_Mr_10_ (赞：4)

## 前言

update: 感谢 @Idtwtei 指出本篇题解的复杂度分析错误。

## Step 1 算法设计

首先，将序列做前缀和得到前缀和数组 $sum$。

注意到数据是随机的，也就是说所有数**等概率出现**。这是一个重要的性质，根据[随机游走](https://blog.csdn.net/qq_43186282/article/details/114585885)的结论可以知道 $sum$ 的单调栈期望大小是根号级别的。

但单调栈大小当然不是 $\log$ 级别的，因为 $sum$ 数组并不是均匀分布的！

所以显然对于一个固定的左右端点，只有相应所构造的单调栈上的节点才可能成为答案。

所以我们有一个初步的方法，暴力对于每个点构造单调栈，然后线段树维护。这就是某篇题解的 $O(n \sqrt n \log n)$ 算法。

## Step 2 算法优化

这个算法肯定是不行的，我们需要优化到 $O(n \sqrt n)$。

这个单调栈的性质对于左右端点均成立，所以对于一个确定的右端点来说，左端点**也应该在**单调栈上

为了得到这样的单调栈，我们可以考虑分治算法。

首先我们设 $Solve(l,r,S)$ 表示区间 $[l,r]$ 范围内待处理的询问集合为 $S$。

我们考虑区间中点 $mid$。我们对 $mid$ 建两个单调栈，一个以 $mid$ 为右端点维护后缀最小值，一个以 $mid$ 为左端点维护前缀最小值。

然后注意到实际上这两个单调栈的长度期望为 $\sqrt{r-l+1}$，也就是区间长度，暴力维护即可。

## Step 3 总结和实现

分析一下时间复杂度，分治每层显然我们需要维护 $n$ 长度的块，还需要枚举单调栈对某个端点的答案，然后一共有 $\log n$ 层，所以时间复杂度是 $O(n\sqrt n+n \log n)$ 的。

也就是 $T(n)=T(\frac{n}{2}) \times 2 \ + O(n\sqrt{n})$。

这题细节问题提一下。

1. 维护询问集合可用一个 vector 存储。

2. 注意不要关同步流，反正我因为这个怒调 3 小时。

以下是轻微压行的抽象代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=5e5+5,inf=1e18;
struct Point{
	int l,r,id;
};
vector <Point> wt;
int a[N],n,q,sum[N];
int gcd(int x,int y){
	if(!y)return x;
	return gcd(y,x%y);
}
struct TLH{
	int fz,fm;
	inline bool operator<(const TLH &x)const{return fz*x.fm<x.fz*fm;}
}ans1[N],ans2[N],st[3005][3005],ans[N];
TLH calc(int l,int r){if(l>r)swap(l,r);return (TLH){(sum[r]-sum[l])*(sum[r]-sum[l]),r-l};};
struct tlhl{
	int top,c[N];
	inline void init(){top=0;}
	inline void pop(int op,int x){
		if(op)while(top&&(sum[c[top]]<=x))top--;
		else while(top&&(sum[c[top]]>=x))top--;
	}
	inline void insert(int x){c[++top]=x;}
}f,g;
int len1,len2,pos1[N],pos2[N],col1[N],col2[N];
inline void work(int l,int r,vector<Point>tlh){
	if(l==r||tlh.empty())return;
	vector <Point> tlh1,tlh2;tlh1.clear();tlh2.clear();f.init();g.init();len1=len2=0;
	int mid=(l+r)>>1,maxn=-inf,minn=inf;
	ans1[mid+1]=ans2[mid]=(TLH){-1,0};
	for(int i = mid;i >= l;i--){
		ans1[i]=ans1[i+1],f.pop(1,sum[i]);g.pop(0,sum[i]);
		for(int j = 1;j <= f.top;j++)ans1[i]=max(ans1[i],calc(i,f.c[j]));
		for(int j = 1;j <= g.top;j++)ans1[i]=max(ans1[i],calc(i,g.c[j]));
		f.c[++f.top]=g.c[++g.top]=i;
	}
	f.init();g.init();
	for(int i = mid+1;i <= r;i++){
		ans2[i]=ans2[i-1],f.pop(1,sum[i]),g.pop(0,sum[i]);
		for(int j = 1;j <= f.top;j++)ans2[i]=max(ans2[i],calc(i,f.c[j]));
		for(int j = 1;j <= g.top;j++)ans2[i]=max(ans2[i],calc(i,g.c[j]));
		f.c[++f.top]=g.c[++g.top]=i;
	}
	for(int i = mid;i >= l;i--){
		if(maxn<sum[i])maxn=sum[i],col1[++len1]=i;
		if(minn>sum[i])minn=sum[i],col1[++len1]=i;
		pos1[i]=len1;
	}maxn=-inf,minn=inf;
	for(int i = mid+1;i <= r;i++){
		if(maxn<sum[i])maxn=sum[i],col2[++len2]=i;
		if(minn>sum[i])minn=sum[i],col2[++len2]=i;
		pos2[i]=len2;
	}
	for(int i = 1;i <= len1;i++){
		for(int j = 1;j <= len2;j++){
			st[i][j]=calc(col1[i],col2[j]);
			if(i>1)st[i][j]=max(st[i][j],st[i-1][j]);
			if(j>1)st[i][j]=max(st[i][j],st[i][j-1]);
		}
	}
	int cd=tlh.size();
	for(int i = 0;i < cd;i++){
		if(tlh[i].r<=mid)tlh1.push_back(tlh[i]);
		else if(tlh[i].l>mid)tlh2.push_back(tlh[i]);
		else ans[tlh[i].id]=max(max(ans1[tlh[i].l],ans2[tlh[i].r]),st[pos1[tlh[i].l]][pos2[tlh[i].r]]);
	}work(l,mid,tlh1);work(mid+1,r,tlh2);
}int l ,r;
signed main(){
	cin >> n;
	for(int i = 1;i <= n;i++)cin >> a[i],sum[i]=sum[i-1]+a[i];
	cin >> q;
	for(int i = 1;i <= q;i++)cin >> l >> r,wt.push_back((Point){l-1,r,i});
	work(0,n,wt);
	for(int i = 1;i <= q;i++)cout << ans[i].fz/gcd(ans[i].fz,ans[i].fm) << " " << ans[i].fm/gcd(ans[i].fz,ans[i].fm) << "\n";
	return 0;
}
```

---

## 作者：JohnVictor (赞：4)

考虑这类问题的一般做法：找到较少的区间，使得其他区间均相对于其中至少一个不优（也就是包含那个区间，但是答案没有它大）。

处理出前缀和数组 $s_i(0 \le i \le n)$。
考虑对于一个左端点 $l$，右端点 $r$ 产生贡献，一定有 $s_r$ 是 $s_l$ 之后的极大值或者极小值。由于数据随机，我们可以在单调队列上暴力枚举，看起来枚举数量是 $O(n\sqrt n)$ 的。注意这些枚举到的点对未必一定是要算入的，只有使得对应的贡献也是极大的才需要算入。这里算入的点对数量已经很少了，最后用二维数点就能过除了 $n \le 5\times 10^5$ 的所有包。

对于剩下的 $m=1$ 的部分分，我们的瓶颈其实还是在枚举可能点对上。考虑如下优化：对于某个特定的 $l$，如果之后的某个 $r$ 是极小值，但是 $[l,r]$ 中已经有比 $s_l$ 大的数 $s_t$，那么显然有 $(t,r)$ 优于 $(l,r)$，因此枚举到这里就可以停止。现在可以通过所有数据。

```cpp

#include<bits/stdc++.h>
using namespace std;
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
const int N=500005;
typedef long long ll;
#define pb push_back
#define pii pair<int,int>
#define mp make_pair
#define fi first
#define se second

struct frac{
	ll x;int y;	
};
bool operator <(frac x,frac y){
    return x.x*y.y<y.x*x.y;
}
int a[N],s[N],small[N],big[N],n,m;vector<int>f[N];vector<pii>q[N];frac ans[N];

void print(frac t){
	//printf("%lld %d\n",t.x,t.y);
}
frac t[N];
void add(int x,frac k){
	//print(k);
	while(x<=n)t[x]=max(t[x],k),x+=(x&(-x));
	//printf("t:\n");
	//rep(i,1,n)print(t[i]);puts("");
}
frac qry(int x){
	frac ret=t[x];
	while(x)ret=max(ret,t[x]),x-=(x&(-x));
	return ret;
}
void solve(int l,int r,frac &t){
	t.x=1ll*(s[r]-s[l-1])*(s[r]-s[l-1]);
	t.y=r-l+1;
}

int slv[N];
void aadd(int x,int y){
	x=n+1-x;
	while(x<=n)slv[x]=min(slv[x],y),x+=(x&(-x));
}
int qury(int x){
	int ret=n+1;x=n+1-x;
	while(x)ret=min(ret,slv[x]),x-=(x&(-x));
	return ret;
}
pii aa[N];
mt19937_64 rnd(time(0));
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	//freopen("make14.in","r",stdin);
	cin>>n;
	rep(i,1,n)cin>>a[i],s[i]=s[i-1]+a[i],big[i]=small[i]=n+1,t[i].y=1;
	/*rep(i,1,n){
		rep(j,i+1,n)if(s[j]>s[i]){
			big[i]=j;break;
		}
		rep(j,i+1,n)if(s[j]<s[i]){
			small[i]=j;break;
		}
	}
	rep(i,1,n)printf("%d %d\n",big[i],small[i]);*/
	rep(i,1,n)aa[i]=mp(s[i],i);
	sort(aa+1,aa+n+1);rep(i,1,n)slv[i]=n+1;
	rep(i,1,n)small[aa[i].se]=qury(aa[i].se),aadd(aa[i].se,aa[i].se);//,cout<<aa[i].se<<endl;
	reverse(aa+1,aa+n+1);rep(i,1,n)slv[i]=n+1;
	rep(i,1,n)big[aa[i].se]=qury(aa[i].se),aadd(aa[i].se,aa[i].se);
	//rep(i,1,n)printf("%d %d\n",big[i],small[i]);
	frac cur,cur1;cur.x=0;cur.y=1;cur1.x=0,cur1.y=1;
	if(n>1e5){
		rep(i,1,n){
		int pl=i,cnt=0;
		solve(i,pl,cur);if(cur1<cur)cur1=cur;
		while(pl<small[i]){
			pl=big[pl];if(pl>n)break;solve(i,pl,cur);if(cur1<cur)cur1=cur;
		}
	}
	rep(i,1,n){
		int pl=i,cnt=0;solve(i,pl,cur);if(cur1<cur)cur1=cur;
		while(pl<big[i]){
			pl=small[pl];if(pl>n)break;solve(i,pl,cur);if(cur1<cur)cur1=cur;
		}
	}
	ll x=cur1.x,y=1ll*cur1.y;
		//printf("%lld %lld\n",x,y);
		ll g=__gcd(x,y);printf("%lld %lld\n",x/g,y/g);
		return 0;
	}
	rep(i,1,n){
		int pl=i,cnt=0;
		frac t,s;solve(i,pl,t);if(n>1e5)solve(i,pl,cur);
		print(t);
		f[i].pb(pl);
		while(pl<=n&&cnt<=400){
			pl=big[pl];if(pl>n)break;if(n>1e5)solve(i,pl,cur);
			solve(i,pl,s);if(t<s)f[i].pb(pl),t=s;++cnt;
		}
	}
	rep(i,1,n){
		int pl=i,cnt=0;
		frac t,s;solve(i,pl,t);if(n>1e5)solve(i,pl,cur);
		f[i].pb(pl);
		while(pl<=n&&cnt<=400){
			pl=small[pl];if(pl>n)break;if(n>1e5)solve(i,pl,cur);
			solve(i,pl,s);if(t<s)f[i].pb(pl),t=s;++cnt;
		}
	}
	cin>>m;for(int i=1,u,v;i<=m;i++)cin>>u>>v,q[u].pb(mp(v,i));
	for(int l=n;l;l--){
		//printf("\n\n\nl=%d\n",l);
		frac cur;
		for(auto t:f[l])solve(l,t,cur),add(t,cur);
		for(auto t:q[l])ans[t.se]=qry(t.fi);//,printf("\nask %d: ",t.fi),print(qry(t.fi));
		//printf("qry:\n");rep(i,1,n)print(qry(i));puts("");
	}
	//cout<<"fdsajfla"<<endl;
	rep(i,1,m){
		ll x=ans[i].x,y=1ll*ans[i].y;
		//printf("%lld %lld\n",x,y);
		ll g=__gcd(x,y);printf("%lld %lld\n",x/g,y/g);
	}
	return 0;
}
```

---

## 作者：Mirasycle (赞：1)

利用前缀和转化，设前缀和序列为 $S$。那么对于一个 $S_r$，贪心来想其可能的 $S_{l-1}$ 必然是一个后缀 $\min$（不妨设 $S_r>S_{l-1}$）。于是我们放到单调栈里面求解，随机序列前缀和的后缀 $\min$ 个数大概是 $O(\sqrt n)$ 级别的，这样子可以大幅减少可能的状态数。

同时因为是随机情况，所以可以发现可能作为答案的区间长度必然不会太长，取阈值为 $B=2000$ 即可。以上两个优化可以将可能区间个数大幅降低。

然后就是一个单点加，矩阵求 $\max$ 了。可以扫描线 $+$ 树状数组解决。这样子在 $\sqrt n$ 的基础上带一个 $\log$。也可以分块求解，这样子 $O(1)$ 修改，$O(\sqrt n)$ 查询就实现了平衡。

两种写法我都实现了，下面是代码。你猜我这么懒的人为什么会写两种写法，其实是我先写了树状数组解法，TLE 了，以为是这个解法太慢了，于是改写了分块。后来才发现其实是因为那个约分操作可以在最后算答案的时候约分一次就行了，而我在中途约分了好多次导致常数巨大。

扫描线 $+$ 树状数组


```cpp
#include<bits/stdc++.h>
#define pb emplace_back
#define fi first
#define se second
#define mp make_pair
using namespace std;
typedef long long ll;
const int maxn=5e5+10;
struct Num{
	ll fm,fz;
	void upd(){
		if(!fm) return ;
		ll G=__gcd(fm,fz);
		fm/=G; fz/=G;
	}
	bool operator < (const Num& rhs) const { return fm*rhs.fz<rhs.fm*fz; }
}ans[maxn];
int n,m,a[maxn]; ll s[maxn]; int st[maxn],top=0;
vector<int> vec[maxn]; vector<pair<int,int> > q[maxn];
Num val(int l,int r){ return Num{(s[r]-s[l])*(s[r]-s[l]),r-l}; }
struct BIT{
	Num c[maxn];
	int lowbit(int x){ return x&-x; }
	void init(int n){ for(int i=1;i<=n+1;i++) c[i]=(Num){0,1}; }
	void modify(int x,Num v){ x++; for(;x;x-=lowbit(x)) c[x]=max(c[x],v); }
	Num query(int x){ Num res=(Num){0,1}; for(;x<=n+1;x+=lowbit(x)) res=max(res,c[x]); return res; }
}t;
int main(){
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin>>n; t.init(n);
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) s[i]=s[i-1]+a[i];
	st[top=1]=0; cin>>m; int L=2000; if(m==1) L=400;
	for(int i=1;i<=n;i++){
		while(top&&s[st[top]]>=s[i]) top--;
		for(int j=top;j>=1;j--){
			if(i-st[j]>L) break;
			vec[i].pb(st[j]);
		}
		st[++top]=i;
	}
	st[top=1]=0;
	for(int i=1;i<=n;i++){
		while(top&&s[st[top]]<=s[i]) top--;
		for(int j=top;j>=1;j--){
			if(i-st[j]>L) break;
			vec[i].pb(st[j]);
		}
		st[++top]=i;
	}
	for(int i=1;i<=m;i++){
		int l,r; cin>>l>>r;
		q[r].pb(l,i);
	}
	for(int i=1;i<=n;i++){
		for(auto z:vec[i]) t.modify(z,val(z,i)); 
		for(auto z:q[i]) ans[z.se]=t.query(z.fi);
	}
	for(int i=1;i<=m;i++){
		ans[i].upd();
		cout<<ans[i].fm<<" "<<ans[i].fz<<"\n";
	}
	return 0;
}
```

分块

```cpp
#include<bits/stdc++.h>
#define pb emplace_back
#define fi first
#define se second
#define mp make_pair
using namespace std;
typedef long long ll;
const int maxn=5e5+10;
const int maxB=510;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
struct Num{
	ll fm,fz;
	void upd(){
		if(!fm) return ;
		ll G=__gcd(fm,fz);
		fm/=G; fz/=G;
	}
	bool operator < (const Num& rhs) const { return fm*rhs.fz<rhs.fm*fz; }
}ans[maxn];
int n,m,a[maxn]; ll s[maxn]; int st[maxn],pos[maxn],top=0;
vector<int> vec[maxn]; vector<pair<int,int> > q[maxn];
Num val(int l,int r){ return Num{(s[r]-s[l])*(s[r]-s[l]),r-l}; }
struct block{
	Num mx,w[maxB]; int l,r;
	void init(int L,int R,int t){ 
		l=L; r=R; mx=(Num){0,1};
		for(int i=l;i<=r;i++) pos[i]=t,w[i-l+1]=(Num){0,1};
	}
	void modify(int x,Num val){
		x=x-l+1; w[x]=max(w[x],val);
		mx=max(mx,val);
	}
	Num query(int ql,int qr){
		if(ql==-1) ql=l;
		if(qr==-1) qr=r;
		ql=ql-l+1; qr=qr-l+1; Num res=(Num){0,1};
		for(int i=ql;i<=qr;i++) res=max(res,w[i]);
		return res;
	}
}b[maxB<<1];
Num Query(int l,int r){
	int p=pos[l],q=pos[r]; Num res={0,1};
	if(p==q) res=b[p].query(l,r); 
	else{
		res=max(res,b[p].query(l,-1));
		for(int i=p+1;i<=q-1;i++) res=max(res,b[i].mx);
		res=max(res,b[q].query(-1,r));
	}
	return res;
}
int main(){
//	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<=n;i++) s[i]=s[i-1]+a[i];
	st[top=1]=0; cin>>m; int L=2000; if(m==1) L=400;
	for(int i=1;i<=n;i++){
		while(top&&s[st[top]]>=s[i]) top--;
		for(int j=top;j>=1;j--){
			if(i-st[j]>L) break;
			vec[i].pb(st[j]);
		}
		st[++top]=i;
	}
	st[top=1]=0;
	for(int i=1;i<=n;i++){
		while(top&&s[st[top]]<=s[i]) top--;
		for(int j=top;j>=1;j--){
			if(i-st[j]>L) break;
			vec[i].pb(st[j]);
		}
		st[++top]=i;
	}
	for(int i=1;i<=m;i++){
		int l,r; l=read(); r=read();
		q[r].pb(l,i);
	}
	int B=min(500,(int)sqrt(n)),cnt=n/B;
	for(int i=1;i<=cnt;i++) b[i].init((i-1)*B+1,i*B,i);
	if(B*cnt<n){ b[cnt+1].init(B*B+1,n,cnt+1); cnt++; }
	for(int i=1;i<=n;i++){
		for(auto z:vec[i]) b[pos[z+1]].modify(z+1,val(z,i));
		for(auto z:q[i]) ans[z.se]=Query(z.fi,i);
	}
	for(int i=1;i<=m;i++){
		ans[i].upd();
		cout<<ans[i].fm<<" "<<ans[i].fz<<"\n";
	}
	return 0;
}
```

---

## 作者：苏联小渣 (赞：1)

写一发乱搞题的题解。

考虑到数据随机的性质，那么选正数和选负数的概率都是 $\dfrac{1}{2}$。所以直观上告诉我们，期望下和不会变得特别大，也不会变得特别小，所以分子可以当作是比较稳定的，那么决定大小的就变成了分母，我们希望区间长度尽量小，所以对每个左端点，只取右边的若干个作为右端点，然后把这些作为决策区间进行暴力，最后求得答案。

实测对于每个左端点取大约 $2000$ 个右端点能够通过，下面是具体做法。相当于我们现在有一些区间，然后询问一个区间的所有子区间的最大值。考虑离线扫描线，扫描到 $r$ 时把所有以 $r$ 为右端点的区间加入到一个数据结构里面，然后查询的时候查询区间最大值即可。我们现在需要支持单点取 $\max$，区间求 $\max$，但是单点修改的次数比较多，带 $\log$ 肯定过不了，考虑平衡一下复杂度，用分块维护，这样就可以做到 $O(1)$ 修改，$O(\sqrt{n})$ 查询。时间复杂度 $O(cn+n \sqrt{n})$，其中 $c=2000$ 或者其它的可以过的阈值（但是 $n=5 \times 10^5$ 时 $c=2000$ 过不去，要特判一下，把阈值改小一点）。

### Code：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define db double
int n, m, l, r, block, del, a[500010], id[500010], b[500010], ansx[500010], ansy[500010], fx[500010], fy[500010], bx[810], by[810];
db mx[500010], bmx[810];
int gcd(int x, int y){
	if (!y) return x;
	return gcd(y, x%y);
}
struct Query{
	int l, id;
};
vector <Query> ask[500010];
signed main(){
	scanf ("%lld", &n);
	block = sqrt(n);
	for (int i=1; i<=n; i++){
		scanf ("%lld", &a[i]);
		id[i] = (i - 1) / block + 1;
	}
	scanf ("%lld", &m);
	for (int i=1; i<=m; i++){
		scanf ("%lld%lld", &l, &r);
		ask[r].push_back((Query){l, i});
	}
	if (n > 100000) del = 500;
	else del = 2000;
	for (int i=1; i<=n; i++){
		int now = 0;
		for (int j=i; j>=max(i-del, 1LL); j--){
			now += a[j];
			if ((db)(now * now) / (db)(i - j + 1) > mx[j]){
				mx[j] = (db)(now * now) / (db)(i - j + 1);
				ansx[j] = now * now, ansy[j] = i - j + 1;
				if (mx[j] > bmx[id[j]]){
					bmx[id[j]] = mx[j];
					bx[id[j]] = ansx[j], by[id[j]] = ansy[j];
				}
			}
		}
		for (int j=0; j<ask[i].size(); j++){
			int l = ask[i][j].l, idx = ask[i][j].id;
			db tot = 0;
			int ans = 0, len = 0;
			if (id[l] == id[i]){
				for (int k=l; k<=i; k++){
					if (mx[k] > tot) tot = mx[k], ans = ansx[k], len = ansy[k];
				}
			}
			else{
				for (int k=l; id[k]==id[l]; k++){
					if (mx[k] > tot) tot = mx[k], ans = ansx[k], len = ansy[k];
				}
				for (int k=i; id[k]==id[i]; k--){
					if (mx[k] > tot) tot = mx[k], ans = ansx[k], len = ansy[k];
				}
				for (int k=id[l]+1; k<id[i]; k++){
					if (bmx[k] > tot) tot = bmx[k], ans = bx[k], len = by[k];
				}
			}
			if (!ans) fx[idx] = 0, fy[idx] = 1;
			else{
				int g = gcd(ans, len);
				fx[idx] = ans / g, fy[idx] = len / g;
			}
		}
	}
	for (int i=1; i<=m; i++){
		printf ("%lld %lld\n", fx[i], fy[i]);
	}
	return 0;
}

```

---

## 作者：wind_seeker (赞：0)

~~来写篇时间排最后一名的题解。~~

### 做法

观察这道题目，**数据随机**和**第一个任务范围极其显眼**。实际上是在提示我们最后所取区间长度不会很长，没错，差不多只有 $2000$。

知道了这个点以后，我们可以直接分类做出前三个部分分。

然后考虑最后一个子任务分。考虑使用扫描线，每次扫到 $R$ 后，往前更新 $2000$ 的范围，每个点存的是到当前 $R$ 的最大答案。然后我们只需要分块查询即可。

### code
```cpp
/*********************************************************************
    作者: wind_seeker
    日期: 2023-07-08 08:07 
*********************************************************************/
#include<bits/stdc++.h>
#define int long long
#define pb push_back
#define mp make_pair
#define fi first
#define se second
using namespace std;
const int N=5e5+1e3;

int n,m,a[N],sum[N],sz,tot,block[N],L[N],R[N];
vector<pair<int,int> > q[N];
pair<int,int> answer,num[N],blsum[N],ans[N];

inline int read(){
	int res=0,f=1;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) res=(res<<3)+(res<<1)+(c^48);
	return res*f;
}

void ckmax(pair<int,int> &X,pair<int,int> Y){
	if(X.fi*Y.se<X.se*Y.fi) X=Y;	
}

pair<int,int> calc(int l,int r){
	auto X=mp(0ll,1ll);
	int lb=block[l],rb=block[r];
	if(lb==rb){
		for(int i=l;i<=r;i++) ckmax(X,num[i]);
		return X;
	}
	for(int i=l;i<=R[lb];i++) ckmax(X,num[i]);
	for(int i=L[rb];i<=r;i++) ckmax(X,num[i]);
	for(int i=lb+1;i<=rb-1;i++) ckmax(X,blsum[i]);
	return X;
}

void solve(int R){
	for(int i=R;i>=max(R-2000+1,1ll);i--){
		ckmax(num[i],mp((sum[R]-sum[i-1])*(sum[R]-sum[i-1]),R-i+1));
		ckmax(blsum[block[i]],num[i]);
	}
	for(auto v:q[R])
		ans[v.se]=calc(v.fi,R);
}

signed main(){
//	freopen("C.in","r",stdin);
//	freopen("C.out","w",stdout);
	n=read();
	for(int i=1;i<=n;i++) a[i]=read(),sum[i]=sum[i-1]+a[i],num[i].fi=0,num[i].se=1;
	m=read();
	for(int i=1,l,r;i<=m;i++){
		l=read(),r=read();
		q[r].pb(mp(l,i));
	}
	if(m==1){
		answer.fi=0,answer.se=1;
		for(int i=1;i<=n;i++){
			for(int j=max(i-900+1,1ll);j<=i;j++)
				ckmax(answer,make_pair((sum[i]-sum[j-1])*(sum[i]-sum[j-1]),i-j+1));
		}
		if(answer.fi==0) puts("0 1");
		else{
			int gcd=__gcd(answer.fi,answer.se);
			printf("%lld %lld\n",answer.fi/gcd,answer.se/gcd);
		}
		return 0;
	}
	sz=245,tot=(n-1)/sz+1;
	for(int i=1;i<=n;i++) block[i]=(i-1)/sz+1;
	for(int i=1;i<=tot;i++) L[i]=(i-1)*sz+1,R[i]=i*sz,blsum[i].fi=0,blsum[i].se=1;R[tot]=n;
	for(int i=1;i<=n;i++) solve(i);
	for(int i=1;i<=m;i++){
		if(ans[i].fi==0) puts("0 1");
		else{
			int gcd=__gcd(ans[i].fi,ans[i].se);
			printf("%lld %lld\n",ans[i].fi/gcd,ans[i].se/gcd);
		}
	}
	return 0;
}
/*
5
-962 -445 -613 -9 920
3
1 5
3 5
1 3
*/
/*
4080400 3
846400 1
4080400 3
*/
```

---


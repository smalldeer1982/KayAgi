# [北大集训 2021] 算术

## 题目背景

CTT2021 D4T1

## 题目描述

今天，生活在 14 进制世界的小 Q 学习了一种判断给定的大数是否是 9 的倍数的方法。我们以 $(1BB40)_{14} = (70812)_{10}$ 作为例子描述该方法，下面设 $b=14$，$p=9$，下面的方法中所有的运算在 $b$ 进制下进行。

1. 从低位往高位，将每个连续的 $k=2$ 位划分为一段。例子中，$(1BB40)_{b}$ 被划分为 $1 \mid BB \mid 40$ 三段。
2. 从低位往高位从 $0$ 开始给每一段编号。例子中，第 $0$ 段为 $40$，第 $1$ 段为 $BB$，第 $2$ 段为 $1$。
3. 对于第 $i$ 段计算出值 $b_i$：设第 $i$ 段在 $b$ 进制下的值为 $a_i$，如果 $i$ 为奇数则 $b_i$ 为满足 $(a_i+b_i) \equiv 0 \pmod p$ 的最小非负整数 $b_i$，如果 $i$ 为偶数则 $b_i$ 为满足 $(a_i-b_i) \equiv 0 \pmod p$ 的最小非负整数 $b_i$。例子中有 $b_0=2$，$b_1=6$，$b_2=1$。
4. 将 $b_i$ 按照**下标大的在低位，下标小的在高位**的顺序顺次拼接，形成一个 $b$ 进制数并输出。例子中输出结果为 $(261)_{b} = (477)_{10}$。容易验证 $477$ 和 $70812$ 都是 $p$ 的倍数。

可以证明上述方法输入和输出的数要么同时是 $p$ 的倍数，要么同时不是 $p$ 的倍数。而且数字的位数变少了，所以多做几次就可以得到一个很小的数，然后就可以简单地判断了。

小 Q 深深地被这个算法吸引了，所以他想给出一个 $b,p$ 不同于 $14,9$ 时的通用方法。但是他发现，当上面的方法中 $b,p$ 的取值变化时，$k$ 不一定等于 $2$：有时会是 $1$，有时会大于 $2$，有时甚至不存在满足条件的 $k$。所以对于给定的 $b, p$，小 Q 想知道在 $b$ 进制下上述方法的第一步中**正整数** $k$ 的最小值，使得无论输入如何，输入和对应的输出要么同时是 $p$ 的倍数，要么同时不是 $p$ 的倍数，或者报告这样的 $k$ 不存在。

注意 $p$ 不一定是质数。


## 说明/提示

| 子任务编号 | $2\leq p\leq$ | $1\leq T\leq$ | 分值 |
| :--------: | :-----------: | :-----------: | :--: |
|    $1$     |      $3$      |     $10$      | $5$  |
|    $2$     |     $10$      |     $10$      | $5 $  |
|    $3$     |    $10^2$     |    $10^2$     | $5$  |
|    $4$     |    $10^4$     |    $10^2$     | $11$ |
|    $5$     |    $10^6$     |    $10^2$     | $11 $ |
|    $6$     |    $10^8$     |    $10^3$     | $11$ |
|    $7$     |   $10^{10}$   |    $10^3$     | $11 $ |
|    $8$     |   $10^{12}$   |    $10^3$     | $7$  |
|    $9$     |   $10^{14}$   |    $10^4$     | $17$ |
|    $10$    |   $10^{15}$   |    $10^5$     | $17 $ |





为了选手们的身心健康，下发文件中的 `down.cpp` 中实现了大整数取模乘法函数 `mul(A, B, P)`，你需要保证 $A,B \in [0,P-1]$，函数会返回 $(A \times B) \bmod P$。你可以自由选择使用或者不使用这份代码。**其中需要保证你调用时 $A,B,P$ 均不超过 $10^{15}$。**

## 样例 #1

### 输入

```
2 9
14
16```

### 输出

```
2
-1```

# 题解

## 作者：Alex_Wei (赞：5)

### D4T1. [P8993 [北大集训 2021] 算术](https://www.luogu.com.cn/problem/P8993)

段数太多不方便考虑。从简化情况入手，考虑划分成 $2$ 段，则原数可写为 $b_1b ^ k + b_0$。去掉 $b_i\gets b_i\bmod p$ 对新数模 $p$ 没有影响，所以可以认为新数为 $b_0b - b_1$，它和真正的新数模 $p$ 相同。

考虑题目限制：

1. 若 $b_1b ^ k + b_0 \equiv 0\pmod p$，则 $b_0b - b_1\equiv 0\pmod p$。用加减消元法消去 $b_0$，得 $b_1(b ^ {k + 1} + 1)\equiv 0\pmod p$。因为 $b_1$ 取 $0\sim p - 1$ 任意值都可以，所以总存在 $b_1\perp p$。这说明 $b ^ {k + 1} \equiv -1\pmod p$。
2. 若 $b_1b ^ k + b_0\equiv x\pmod p$，则 $b_0b - b_1\equiv y\pmod p$，其中 $x, y > 0$。化简得 $b_1(b ^ {k + 1} + 1)\equiv xb - y\pmod p$，即 $xb\equiv y\pmod p$。这要求 $1\sim p - 1$ 任意数乘以 $b$ 后不是 $p$ 的倍数。若 $b\perp p$ 显然满足，否则令 $x$ 为 $\frac p {\gcd(b, p)}$ 即为反例。

综上，$b\perp p$ 且 $b ^ {k + 1}\equiv -1\pmod p$。反过来可以证明若满足限制则 $k$ 满足题目要求。

以段数为 $3$ 为例：原数为 $b_2 b ^ {2k} + b_1 b ^ k + b_0$，新数为 $b_0 b ^ 2 - b_1b + b_2$。对于第一条限制，消元得 $b_2 (b ^ {2k + 2} - 1) + b_1(b ^ {k + 2} + b)\equiv 0\pmod p$。而 $b ^ {k + 1} + 1\equiv 0\pmod p$，且 $b ^ {2k + 2} - 1 = (b ^ {k + 1} + 1) (b ^ {k + 1} - 1)$，$b ^ {k + 2} + b = (b ^ {k + 1} + 1) b$。对于第二条限制，消元得 $b_2 (b ^ {2k + 2} - 1) + b_1(b ^ {k + 2} + b) = x b ^ 2 - y$，即要求 $1\sim p - 1$ 任意数乘以 $b ^ 2$ 后不是 $p$ 的倍数。类似地，容易推出等价于 $b\perp p$。

$b\perp p$ 容易判断，考虑 $b ^ {k + 1} \equiv -1\pmod p$ 的限制。

将等式两侧平方，$b ^ {2k + 2} \equiv 1\pmod p$ 是必要条件，而该必要条件等价于 $2k + 2\mid \delta_{p}(b)$，其中 $\delta_p(b)$ 表示 $b$ 在模 $p$ 意义下的阶，简记为 $d$。又因为之前保证了 $b\perp p$，所以 $\delta_p(b)$ 存在。先 $\mathcal{O}(\log ^ 2 p)$ 求出阶（从 $x = \varphi(p)$ 开始每次将 $x$ 除以 $\varphi(p)$ 的某个质因子并检查是否仍有 $b ^ x\equiv 1\pmod p$）。

当 $d$ 是奇数的时候，显然无解 …… 吗？先别急，如果 $p = 2$ 阁下又该如何应对？输出 $1$ 即可。当 $p > 2$ 的时候无解。

当 $d$ 是偶数的时候，首先检查 $b ^ {\frac d 2}\bmod p$ 是否为 $-1$。若否，则无解。否则输出 $\frac d 2 - 1$ …… 吗？先别急，如果 $d = 2$ 阁下又该如何应对？输出 $2$ 即可。

时间复杂度 $\mathcal{O}(\sqrt p + T\log ^ 2 p)$。

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = long long;
using ui = unsigned int;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using pdi = pair<double, int>;
using ull = unsigned long long;

#define ppc(x) __builtin_popcount(x)
#define clz(x) __builtin_clz(x)

bool Mbe;
// mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());
mt19937 rnd(20060130);
int rd(int l, int r) {return rnd() % (r - l + 1) + l;}

constexpr int mod = 998244353;
void addt(int &x, int y) {x += y, x >= mod && (x -= mod);}
int add(int x, int y) {return x += y, x >= mod && (x -= mod), x;}
char buf[1 << 20], *p1 = buf, *p2 = buf;
#define getc() (p1 == p2 && (p2 = (p1 = buf) + \
  fread(buf, 1, 1 << 20, stdin), p1 == p2) ? EOF : *p1++)
inline int read() {
  int x = 0;
  char s = getc();
  while(!isdigit(s)) s = getc();
  while(isdigit(s)) x = x * 10 + s - '0', s = getc();
  return x;
}

#define putc(x) putchar(x)
inline void print(ui x) {
  if(x >= 10) print(x / 10);
  putc(x % 10 + '0');
}

// ---------- templates above ----------

ll mul(ll A, ll B, ll P) {
	ll C = A * B - ll(double(A) * B / P + 0.1) * P;
	return C < 0 ? C + P : C;
}
ll ksm(ll a, ll b, ll p) {
  ll s = 1;
  while(b) {
    if(b & 1) s = mul(s, a, p);
    a = mul(a, a, p), b >>= 1;
  }
  return s;
}


ll T, p, tmp, phi;
vector<ll> w;
void mian() {
  cin >> T >> p;
  phi = tmp = p;
  for(ll i = 2; i * i <= tmp; i++) {
    if(tmp % i) continue;
    while(tmp % i == 0) tmp /= i;
    phi = phi / i * (i - 1);
  }
  if(tmp > 1) phi = phi / tmp * (tmp - 1);
  tmp = phi;
  for(ll i = 2; i * i <= tmp; i++) {
    if(tmp % i) continue;
    while(tmp % i == 0) tmp /= i;
    w.push_back(i);
  }
  if(tmp > 1) w.push_back(tmp);
  while(T--) {
    ll b;
    cin >> b, b %= p;
    if(__gcd(b, p) > 1) {
      cout << "-1\n";
      continue;
    }
    if(p == 2) {
      cout << "1\n";
      continue;
    }
    ll dt = phi;
    for(ll it : w) {
      while(dt % it == 0) {
        if(ksm(b, dt / it, p) == 1) dt /= it;
        else break;
      }
    }
    if(dt & 1) {
      cout << "-1\n";
      continue;
    }
    if(ksm(b, dt / 2, p) != p - 1) {
      cout << "-1\n";
      continue;
    }
    ll ans = dt / 2 - 1;
    if(ans == 0) ans += dt;
    cout << ans << "\n";
  }
}

bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  #ifdef ALEX_WEI
    FILE* IN = freopen("1.in", "r", stdin); 
    FILE* OUT = freopen("1.out", "w", stdout);
  #endif
  int T = 1;
  while(T--) mian();
  fprintf(stderr, "%d ms\n", int(1e3 * clock() / CLOCKS_PER_SEC));
  return 0;
}

/*
g++ a.cpp -o a -std=c++14 -O2 -DALEX_WEI
*/

```

---

## 作者：lzqy_ (赞：0)

真的只有蓝吗？喵喵喵？

---------

题目的约束看上去无从下手，考虑取出一个等价的子问题分析，即恰好被划分成 $2$ 段（可以归纳证明 $\ge 2$ 段的情况）。

考虑两者都是 $p$ 的倍数的限制。设原数为 $\lceil\frac{xb^k}{p}\rceil p$，那么划分后第 $1,0$ 段分别为 $x,(\lceil\frac{xb^k}{p}\rceil p-xb^k)$。因为这两个东西同时是 $p$ 的倍数，所以有 $xb^{k+1}+x \equiv 0(\bmod\, p)$。这个式子在 $\gcd(x,p)=1$ 的时候约束是最强的，即 $b^{k+1}\equiv -1(\bmod \, p)$。

所以问题转化为对于 $b$ 求出最小的 $k$ 满足 $b^{k+1}\equiv -1(\bmod \, p)$。

和 $-1$ 同余看起来不太好做，但观察到 $(-1)^2=1$，因此只要做出余数为 $1$ 的情况，再把答案除以二就好了。


由欧拉定理得 $b^{\varphi(p)} \equiv 1(\bmod \, p)$，但需要注意的是，$\varphi(p)$ 并不是剩余系的最小循环节。因此要提前把 $\varphi(p)$ 分解质因数，然后对于每个 $b$ 暴力找到最小循环节 $x$。

-------

补充说明一个地方。

题目里还有一个要求是两个数要同时不是 $p$ 的倍数。但是分析到这里发现这个条件已经没必要讨论了。

类似地，设原数为 $\lceil\frac{xb^k}{p}\rceil p+i$，由于 $xb^{k+1}+x \equiv 0(\bmod\, p)$，所以列出来同余式就只剩下 $ib\not\equiv 0(\bmod \, p)$ 了。由上述分析可知，有解的前提是 $\gcd(b,p)=0$，又因为 $i<p$，所以该式一定成立。

-------

**注意附件里给的大整数乘法要开 long double**。


时间复杂度 $O(\sqrt p+T\log^2p)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define il inline 
using namespace std;
const int maxn=40000010;
int T,top;
ll b,p,phi,x,st[maxn];
int pr[maxn],cnt;
bool vis[maxn];

il ll mul(ll A, ll B){
	ll C = A * B - (ll)((long double)A * B / p + 0.1) * p;
	return C < 0 ? C + p : C;
}
void Oula(int n){
	for(int i=2;i<=n;i++){
		if(!vis[i]) pr[++cnt]=i;
		for(int j=1;j<=cnt&&pr[j]*i<=n;j++){
			vis[pr[j]*i]=1;
			if(i%pr[j]==0) break; 
		}
	}
}
il ll fpow(ll n,ll m,ll x=1){
	for(;m;m>>=1,n=mul(n,n))
		if(m&1) x=mul(x,n);
	return x;
}
ll getphi(ll n){
	ll x=n,xx=n;
	for(int i=1;i<=cnt;i++)
		if(x%pr[i]==0){
			x/=pr[i],x*=pr[i]-1;
			while(xx%pr[i]==0) xx/=pr[i];
		}
	if(xx>1) x/=xx,x*=xx-1;
	return x;
}
int main(){
	scanf("%d%lld",&T,&p);
	Oula(sqrt(p)),phi=getphi(p),x=phi;
	for(ll i=1;i<=cnt;i++)
		if(x%pr[i]==0){
			st[++top]=pr[i];
			while(x%pr[i]==0) x/=pr[i];
		}
	if(x>1) st[++top]=x;
	while(T--){
		scanf("%lld",&b),x=phi;
		if(p==2){printf("%d\n",(b&1)?1:-1);continue;}
		for(ll i=1;i<=top;i++)
			while(x%st[i]==0&&fpow(b,x/st[i])==1) x/=st[i];
		if(x&1){printf("-1\n");continue;}
		if(fpow(b,x>>1)!=p-1){printf("-1\n");continue;}
		if(x/2==1) printf("2\n");
		else printf("%lld\n",x/2-1);
	} 
	return 0;
}
```

---


# [CEOI 2022] Parking

## 题目描述

Valerija 在一家饭店的停车场工作，她负责礼貌地接待重要的客人，保管他们的车钥匙并帮助他们停车。

一个晚上，她发现她管理的停车场中恰好有 $2N$ 辆车，它们共有 $N$ 种不同的颜色，每种颜色恰有两辆车。我们将颜色按 $1$ 到 $N$ 编号。

停车场共有 $M$ 个车位，按 $1$ 到 $M$ 编号，每一个车位可以停下两辆车，一个车位只有一个入口，我们称靠近入口的为「顶上的车」，远离入口的为「底下的车」，一辆车可以从入口开出当且仅当没有车挡着它。Valerija 在停车的时候，保证每个车位要么空，要么停满两辆车，要么只有一辆底下的车。

![](https://cdn.luogu.com.cn/upload/image_hosting/q0r8s8f5.png)

这张图描述的是第一个样例，同时呈现了唯一的第一次驾驶。

Valerija 想要重新停放车使得每一对相同颜色的车都在一个车位里。我们并不关心车位对应什么颜色以及哪辆车在顶上哪辆车在底下。Valerija 将执行如下操作：

- 驾驶一辆可以驶出车位的车，将车开到另一个车位，满足：
    - 这个车位是空的，并把车停在底下的车位，或者，
    - 这个车位有且只有一辆与当前驾驶的车颜色相同的车。
    
Valerija 想知道最少的操作次数与操作方案，请你解决这个问题。

## 说明/提示

### 样例 1 解释

由题目描述中的图可以看出，这个样例只有唯一解。

### 数据规模与约定

对于全部数据，$1\le N\le M\le 2\times 10^5$。

如果你的程序正确求出了最少的操作次数，但是方案构造错误，你将会获得对应点 $20\%$ 的分数。

| Subtask 编号 |                 特殊限制                  | 分数 |
| :----------: | :--------------------------------------: | :--: |
|     $1$      |                 $M\le 4$                 | $10$ |
|     $2$      |                $2N\le M$                 | $10$ |
|     $3$      | $N\le 1000$，每个车位要么是空的要么是满的。 | $25$ |
|     $4$      |       每个车位要么是空的要么是满的。        | $15$ |
|     $5$      |               $N\le 1000$                | $25$ |
|     $6$      |                无特殊限制                 | $15$ |

## 样例 #1

### 输入

```
4 5
1 0
2 0
1 3
4 4
3 2```

### 输出

```
3
5 2
3 5
3 1```

## 样例 #2

### 输入

```
4 5
0 0
2 1
3 1
3 4
2 4```

### 输出

```
-1```

## 样例 #3

### 输入

```
5 7
1 0
2 1
2 3
4 3
5 4
5 0
0 0```

### 输出

```
6
2 1
3 7
4 7
2 3
5 4
5 6```

# 题解

## 作者：honglan0301 (赞：4)

## 分析

**<1> 首先不管空位数量的限制，先考虑如何让操作次数最少：**

对每种颜色记录 二元组 $(x_i,y_i)\in\{(0,0),(0,1),(1,1)\}$ 表示颜色为 $i$ 的两辆车分别是/否位于靠近入口的一端，以及 $(u_i,v_i)$ 表示它们初始停放的车位编号。那么对 $(u_i,v_i)$ 连边建成图 $G$（形成若干个环与链），分讨可以得到操作次数的理论下界：

- $(x_i,y_i)=(0,0)$ 的颜色至少要进行一次操作。

- $(x_i,y_i)=(0,1)$ 的颜色，如果两辆该颜色的车已经配对则不用操作，否则至少进行一次操作。

	*特别地，当一个连通块中全是 $(x_i,y_i)=(0,1)$ 的颜色时，至少要多进行一次操作。因为连通块中第一个被操作的颜色不能立即完成配对。

- $(x_i,y_i)=(1,1)$ 的颜色至少要进行两次操作。因为车位是栈形的，我们无法在其中一辆车不动的情况下停放另一辆车。

再尝试构造方案：

- 首先把 $(x_i,y_i)=(1,1)$ 的颜色都换到初始局面的空位上。

- 此时图 $G$ 里每条链中的 $(x_i,y_i)$ 一定依次形如 $(1,0),(1,0),\dots,(1,0),(0,0)$，从前往后依次删即可；每个环中 $(x_i,y_i)$ 一定只有 $(1,0)$，任选一个 $1$ 换到空位处后，环变为链，用删链的方法即可。

- 因此能够找出操作次数达到理论下界的方案，sub2 得到了解决。

**<2> 考虑在以上过程中，如何使得同一时刻占用车位数最少：**

同样先分析下界，按照图 $G$ 各连通块的形态/状态分讨：

- 对于一条链。操作时，如果其中仅有 $(x_i,y_i)=(1,0)/(0,0)$ 的点，则对其操作时不需占用额外空位；否则至少要占用一个空位。操作后，空位数量增加 $1$（原先两端车位各只停一辆车）。

- 对于一个环。操作时，假如其中均有 $(x_i,y_i)=(1,0)$ 或只有一个 $(x_i,y_i)=(1,1)$，则至少占用一个空位；否则至少占用两个空位（因为对其进行任何操作后均会变成含有 $(1,1)$ 的链）。操作后，空位数量保持不变。

再构造/判无解：

- 首先操作不需额外空位的链。

- 此时若没有空位但仍需操作 则无解。

- 然后操作需要占 $1$ 个空位的链（因为能够提供新空位）。

	*具体地，我们从链头开始，每当碰到 $(x_i,y_i)=(1,1)$ 的颜色就将其换到空位处，并将其前面不含 $(1,1)$ 的链复原即可，占用空位数达到理论下界。

- 此时若空位数量为 $1$ 但存在需占用两个空位的环 则无解。

- 否则对环依次操作，即可在操作次数最少的前提下完成任务。

	*具体地，先把环上一个 $(x_i,y_i)=(1,1)$ 的颜色（如果没有就选 $(0,1)$ 的颜色） 换到空位处，之后即可按照链的方法操作，占用空位数能够达到理论下界。

------------

    
综上，做完了。简单维护即可做到线性。

## 代码

丑陋的 [赛时代码。](https://www.luogu.com.cn/paste/86o92yfj)

---

## 作者：DaiRuiChen007 (赞：2)

[Problem Link](https://www.luogu.com.cn/problem/P9001)

**题目大意**

> 给定 $m$ 个容量至多为 $2$ 的栈，里面有 $1\sim n$ 各两个，每次操作可以把一个栈的栈顶向放进另一个栈，如果新的栈大小为 $2$，要求栈中两元素相同。
> 
> 请在用最少的操作次数使得所有同色元素都在同一个栈内，给出构造。
> 
> 数据范围：$n\le m\le 2\times 10^5$。

**思路分析**

对于一个栈中如果 $u$ 在 $v$ 上面，那么连边 $u\to v$。

把所有边看成无向的，每个点入度 $\le 2$，一定是若干链和环。

对于一条链 $a_1-a_2-\cdots-a_k$，如果有 $a_1\to a_2$，那么直接可以把两个 $a_1$ 叠在一起。

不断操作，停止时这条链一定有形如 $x\gets y\to a_p\to a_{p+1}\to\cdots\to a_k$ 的结构（从右往左找到第一个 $\gets$），此时两个 $y$ 都在栈顶，把两个 $y$ 都移动到一个空栈中，然后分成两个链接着做。

我们发现只有处理 $y$ 时会有一次额外操作，而这样操作一次后会消耗两条边，因此这部分额外花费不超过 $0.5n$。

然后考虑环，还是找一个 $x\to y\to z$ 的结构，然后就能把环拆成链，分析同上。

如果不存在这样的结构，那么环一定是顺序的，任取一个 $x$，把其中一个 $x$ 移到空栈。环又变成了链。

这一部分每个环只需要一次操作后就变成有序链，每个环大小 $\ge 2$，且每个环只有一次额外贡献，花费也不超过 $0.5n$。

可以看出总次数 $\le 1.5n$，容易证明这个过程取到操作次数的最小值。

然后分析一下每种操作的优先级，我们应该按照对空栈数量的贡献情况进行分析。

- 优先级最高的应该是把两个大小为一的同色栈合并起来，这种操作不额外占用空栈，且产生一个新的空栈。
- 优先级次高的应该是把一个大小为一的栈和另一个栈顶合并，这种操作不额外占用空栈。
- 优先级第三的应该是把一条链中的 $x\gets y\to a_p\to\cdots\to a_k$ 结构分解掉，我们把两个 $y$ 放进空栈，然后 $a_p\sim a_k$ 的还原不需要额外占用栈，会暂时占用一个空栈，最终不会改变总空栈数。
- 优先级第四高的应该是把顺序环拆开，暂时占用一个空栈，最终不会改变总空栈数。
- 优先级最低的就是把环中 $y\gets x\to z$ 的结构拆开，会占一个栈不还。

事实上两种环可以反过来考虑，因为顺序环还原不改变空栈情况，只需要给一个空栈即可，如果 $n<m$ 且其他环都能还原，一定可以，反之一定不行。

用一些 `std::set` 维护这个过程。


时间复杂度 $\mathcal O(m\log m)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=2e5+5;
int n,m,a[MAXN][2],b[MAXN][2],hd[MAXN],w[MAXN];
set <int> e,f[10];
vector <array<int,2>> wys;
int typ(int x,int o) {
	//0:size=1, 1:bottom, 2:top 
	if(hd[o]==1) return 0;
	return 1+(x==a[o][1]);
}
int typ(int x) {
	//state of a color
	if(b[x][0]==b[x][1]) return 9;
	int c=typ(x,b[x][0]),d=typ(x,b[x][1]);
	if(c>d) swap(b[x][0],b[x][1]),swap(c,d);
	return c*3+d;
}
void del(int x) {
	if(~w[x]) f[w[x]].erase(x),w[x]=-1;
}
void ins(int x) {
	if(w[x]==-1) f[w[x]=typ(x)].insert(x);
}
void opr(int x,int y) {
	wys.push_back({x,y});
	if(!hd[x]) e.erase(x);
	if(!hd[y]) e.erase(y);
	for(int i=0;i<hd[x];++i) del(a[x][i]);
	for(int i=0;i<hd[y];++i) del(a[y][i]);
	int c=a[x][hd[x]-1];
	b[c][b[c][1]==x]=y;
	a[y][hd[y]++]=c;
	a[x][--hd[x]]=0;
	for(int i=0;i<hd[x];++i) ins(a[x][i]);
	for(int i=0;i<hd[y];++i) ins(a[y][i]);
	if(!hd[x]) e.insert(x);
	if(!hd[y]) e.insert(y);
}
signed main() {
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=m;++i) {
		cin>>a[i][0]>>a[i][1];
		hd[i]=!!a[i][0]+!!a[i][1];
		for(int j=0;j<hd[i];++j) {
			b[a[i][j]][!!b[a[i][j]][0]]=i;
		}
		if(!hd[i]) e.insert(i);
	}
	for(int i=1;i<=n;++i) f[w[i]=typ(i)].insert(i);
	while(true) {
		if(f[0].size()) {
			//trivial case 
			int x=*f[0].begin();
			opr(b[x][1],b[x][0]);
			continue;
		}
		if(f[2].size()) {
			//head/tail of chain
			int x=*f[2].begin();
			opr(b[x][1],b[x][0]);
			continue;
		}
		if(e.empty()) break;
		int o=*e.begin();
		if(f[1].size()) {
			//cut the left most x<-y->? in chain
			int x=*f[1].begin(),y=a[b[x][1]][1];
			while(w[y]!=8) x=y,y=a[b[x][0]][1];
			int s=b[y][0],t=b[y][1];
			opr(s,o),opr(t,o); continue;
		}
		if(f[8].size()) {
			//cut a ?<-x->? in cycle
			int x=*f[8].begin(),s=b[x][0],t=b[x][1];
			opr(s,o),opr(t,o); continue;
		}
		if(f[5].size()) {
			//cut any ?<-x<-? in cycle 
			int x=*f[5].begin();
			opr(b[x][1],o);
		} else break;
	}
	bool ok=1;
	for(int i=1;i<=m;++i) ok&=(!hd[i]||(hd[i]==2&&a[i][0]==a[i][1]));
	if(!ok) cout<<"-1\n";
	else {
		cout<<(int)wys.size()<<"\n";
		for(auto z:wys) cout<<z[0]<<" "<<z[1]<<"\n";
	}
	return 0;
}

```

---

## 作者：未来姚班zyl (赞：1)

若一个栈的栈底为 $x$，栈顶为 $y$，则称其为 $(x,y)$。

首先如果栈中的两个颜色相同，则不会管它们了，不可能会把其中一个挪到一个空栈。每操作一次也最多匹配一个颜色。

假如其中一个栈 $s$ 满了，设其为 $(x,y)$，则 $x$ 要动的前提是把 $y$ 挪走了，我们用一个有向图刻画，对于这种情况我们连边 $y\rightarrow x$，这样每个点的出度和入度之和每时每刻都 $\le 2$，这使得这张图的形式很单一，可以尝试对每种形态逐一攻破。

在分讨之前，我们要了解一个颜色 $x$ 和其它颜色 $y$ 有连边说明有一对 $x,y$ 在同一个栈中。如果 $x$ 的两个度数不全说明有 $x$ 独占一个栈，即 $(x,0)$。

- 孤立点（度数为 $0$）

设其为 $x$，则可以将 $(x,0),(x,0)$ 操作一次变为 $(0,0),(x,x)$。这样只用一步，不仅匹配了 $x$，还多了一个空栈，绝对是不亏的。

- 一条同向链（链上的点和链外的点没有连边）。

设其为 $a_1\rightarrow a_2\rightarrow \dots \rightarrow a_k$。

首先我们无法达到孤立点的效果：只用一步，匹配一种颜色的同时，多出一个空栈。

我们发现 $a_1$ 的分布是 $(a_1,0)$ 和 $(a_2,a_1)$，则我们可以变成 $(a_1,a_1)$ 和 $(a_2,0)$，在匹配 $a_1$ 的同时去掉了 $a_1\rightarrow a_2$ 这条边，我们可以一直这样做直到变成孤立点，这样在不借助其它栈的同时用 $k$ 步将栈删完，还多出一个空栈。

类似的，只要存在入度为 $0$，出度为 $1$ 的点，都可以通过这种方法一步一匹配。我们可以用类似拓扑排序的方法将他们消除。

剩下入度为 $0$ 的点出度均为 $2$，所以我们有以下情况：

- $k$ 个点 $k$ 条边的环（即连通块内出度和入度均为 $1$）。
- 一条非同向链，形如 $a_1\leftarrow \dots \leftarrow a_2 \rightarrow \dots \rightarrow a_3 \leftarrow\dots\leftarrow a_4\rightarrow\dots$，可以视为若干条有向链的链头和链尾合并得到，且两端点均为链尾。
- 非同向链的两端再合并。

此时任何一个点都无法只用一步匹配，且无法在内部调整。移动的限制也导致我们不能在两两弱连通块之间调整。所以我们需要对每个连通块消耗额外的步数和额外的空栈，操作的要求已经严格高于之前的操作。此时我们必须要有至少一个空栈，否则没有合法方案。

- $k$ 个点 $k$ 条边的环。

考虑 $a_2$ 的形态，其所在的两个栈为 $(a_2,a_1),(a_3,a_2)$，此时我们必须找到一个空栈 $(0,0)$，将 $(a_3,a_2),(0,0)$ 变为 $(a_3,0),(a_2,0)$，这样我们利用一个空栈，花一步断开了 $a_2\rightarrow a_3$ 这条边，使这个环变成了有向链，再按链的操作即可再花 $k$ 步匹配完所有的点，并重新生成一个空栈，整个过程只用了额外的一步，没有浪费空栈，已经是当前足够优秀的方案，所以可以直接优先消去，不会对其它的部分产生影响。

- 一条非同向链。

此时我们要考虑从出度为 $2$ 的点处断开，设其为 $x$，则形如 $y\leftarrow x\rightarrow z$，$y$ 和 $z$ 连出了两条链，此时 $x$ 所在栈为 $(y,x),(z,x)$，存在一个空栈 $(0,0)$。

此时，如果两端的链中有一条是有向链（这样的 $x$ 一定存在，就是最靠近链尾的两端的出度为 $2$ 的点），设其为 $y$ 所连的链，则可以用 $1$ 步将 $(y,x),(0,0)$ 变为 $(y,0),(x,0)$，消除 $x\rightarrow y$ 的边，剩下的按有向链解决又会返还一个空栈，并且非同向链长度减小，效果和环一样，甚至还在最后增加一个空栈，优先进行这样的操作肯定不劣。

- 非同向链的两端再合并。

此时我们不得不将一个出度为 $2$ 的点 $x$，其为 $(y,x),(z,x)$，通过 $(0,0)$ 变为 $(y,0),(z,0),(x,x)$，这里额外用了 $1$ 步，消去了一个空栈，将剩下的变为非同向链。这额外的 $1$ 步和一个空栈不得不使用，是最劣的情况，所以把它放到最后处理。

只要模拟这样的过程即可，复杂度 $O(n)$。

当然可以无脑用优先队列和各种 stl 库的东西辅助，复杂度带 $\log$ 无伤大雅，而且很无脑。

这种题的文字篇幅自然会很长，但思路过程中没有思维跳跃和复杂分析，是一道比较繁琐但难度不高的题。如果基本功扎实会很轻松。~~我的基本功很差所以被薄纱了~~

我的代码是一坨，你们肯定看不懂我的缺省源和代码习惯。


```cpp
#include<bits/stdc++.h>
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define repn(x) rep(x,1,n)
#define repm(x) rep(x,1,m)
#define pb push_back
#define Pi pair<int,int>
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57)s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
using namespace std;
const int N=2e5+5;
int n,m,sz[N],s[N][3],ma[N],b[N][3],deg[N],f[N],v[N],to[N];
vector<Pi>Ans;
void out(){
	cout <<(int)Ans.size()<<'\n';
	for(auto y:Ans)printf("%d %d\n",y.first,y.second);
}
map<int,int>G,Un;
struct node{
	int x,ty;
}a[N][3];
void refuse(int x,node w,node nx){
	if(a[x][1].x==w.x&&a[x][1].ty==w.ty)a[x][1]=nx;
	else a[x][2]=nx;
}
int getclass(node A,node B){
	int ty=A.ty,Ty=B.ty;
	if(ty>Ty)swap(ty,Ty);
	if(ty==3)return 4;
	if(ty==2)return 0;
	return Ty;
}
struct nod{
	int x,G;
	node A,B;
	bool friend operator<(nod a,nod b){
		int wa=getclass(a.A,a.B),wb=getclass(b.A,b.B);
		if(wa==wb&&wa==1)return a.G<b.G; 
		return wa<wb;
	}
};
int oth(int x,int y){
	if(b[x][1]==y)return b[x][2];
	return b[x][1];
}
int find(int x){
	if(a[x][1].ty!=1&&a[x][2].ty!=1)return to[x]=x;
	if(a[x][1].ty==1)return to[x]=find(s[a[x][1].x][1]);
	return to[x]=find(s[a[x][2].x][1]);
}
bool check(int x,int t){
	if(v[x]!=-1)return v[x];
	if(a[x][1].ty==1){
		if(s[a[x][1].x][1]==t)return v[x]=1;
		return v[x]=check(s[a[x][1].x][1],t);
	}
	if(a[x][2].ty==1){
		if(s[a[x][2].x][1]==t)return v[x]=1;
		return v[x]=check(s[a[x][2].x][1],t);
	}
	return v[x]=0;
}
void Main(){
	Ans.clear(),G.clear(),Un.clear();
	repm(i){
		sz[i]=2;
		rep(j,1,sz[i])s[i][j]=read();
		while(sz[i]&&!s[i][sz[i]])sz[i]--;
	}
	priority_queue<nod>q;
	repn(i)ma[i]=deg[i]=0,v[i]=-1;
	repm(i){
		if(!sz[i])G[i]=1;
		else if(sz[i]==1){
			int w=s[i][1];
			a[w][++ma[w]]={i,3};
		}else if(sz[i]==2){
			if(s[i][1]==s[i][2])continue;
			int x=s[i][1],y=s[i][2];
			a[x][++ma[x]]={i,2},a[y][++ma[y]]={i,1};
		}
	}
	repn(i)if(ma[i]){
		int w=getclass(a[i][1],a[i][2]);
		if(w==1){
			int A=find(s[a[i][1].x][1]),B=find(s[a[i][2].x][1]);
			b[A][++deg[A]]=i,b[B][++deg[B]]=i;
		}
	}
	repn(i)if(ma[i]){
		Un[i]=1;
		int G=0,w=getclass(a[i][1],a[i][2]);
		if(w==1){
			int A=to[s[a[i][1].x][1]],B=to[s[a[i][2].x][1]];
			if(deg[A]==1||deg[B]==1)G=1;
		}
		if(w==2){
			if(!check(i,i))continue;
		}
		q.push({i,G,a[i][1],a[i][2]});
	}
	while(!Un.empty()){
		int x=q.top().x;
		q.pop();
		if(Un.find(x)==Un.end())continue;
		if(a[x][1].ty>a[x][2].ty)swap(a[x][1].ty,a[x][2].ty),swap(a[x][1].x,a[x][2].x);
		int ty=a[x][1].ty,Ty=a[x][2].ty,i=a[x][1].x,j=a[x][2].x,k,y;
		if(ty==3){
			Un.erase(x),Ans.pb({i,j}),G[i]=1;
			continue;
		}
		if(ty==1&&Ty==3){
			Un.erase(x),Ans.pb({i,j}),refuse(s[i][1],{i,2},{i,3}),y=s[i][1],q.push({y,0,a[y][1],a[y][2]});
			continue;
		}
		if(G.empty())return puts("-1"),void();
		k=(*G.begin()).first;
		if(Ty==1){
			Ans.pb({i,k}),Ans.pb({j,k});
			int A=to[s[i][1]],B=to[s[j][1]];
			deg[A]--,deg[B]--;
			if(deg[A])A=oth(A,x),q.push({A,1,a[A][1],a[A][2]});
			if(deg[B])B=oth(B,x),q.push({B,1,a[B][1],a[B][2]});
			refuse(s[j][1],{j,2},{j,3}),refuse(s[i][1],{i,2},{i,3}),G.erase(k);
			Un.erase(x),y=s[i][1],q.push({y,0,a[y][1],a[y][2]}),y=s[j][1],q.push({y,0,a[y][1],a[y][2]});
			continue;
		}
		Ans.pb({j,k}),G.erase(k),s[k][1]=s[j][2],refuse(s[j][2],{j,1},{k,3}),a[x][2].ty=3,q.push({x,0,a[x][1],a[x][2]}),y=s[j][2],q.push({y,0,a[y][1],a[y][2]});
	}
	out();
}
int main(){
	while(scanf("%d %d",&n,&m)!=EOF)Main();
	return 0;
}

```

---

## 作者：qiuzx (赞：1)

## 题意

有 $m$ 个栈，每个栈大小为 $2$，还有 $n$ 种颜色的球，每种各两个，初始按照某种方式放在这些栈中。现在可以进行若干次操作，每次可以将一个栈栈顶的球移到另一个栈的栈顶，要求保证要么这个新的栈为空，要么这个新的栈中的球和移动的球颜色相同。最终要求每个栈要么为空，要么有两个颜色一样的球。求最小方案数并构造方案。$n,m\le 2\times 10^5$。

## 思路

由于移动的时候要么是移到一个新的栈，要么只能移到和自己颜色相同的上面，所以两个颜色相同的一旦合在一起就不可能再分开了，因为分开只会让更多的栈里不能放东西。这样如果两个颜色相同的球初始就在一起，那么就不管它们了。否则这两个球至少需要一步操作将它们合在一起，并且如果这两个球都在栈顶，且这两个栈都是满的，那么必须得将其中一个放到最底下，再把另一个放上来，所以这种至少需要两步操作，这样就得到了一个操作步数的下界。下面我们先尽可能尝试达到这个理论的下界。

如果某种颜色的两个球都在栈顶，且至少有一个所处的栈大小只有 $1$，那么必然可以通过一步操作将它们合起来。显然合起来一定更优，因为这没有使用理论下界以外的额外步数，且即使不合起来，这两个栈里也都不能再放别的东西，所以合起来只会提供更多的可能性。这样重复这个过程直到不存在这样的颜色，然后观察一下现在的局面。

此时所有栈有三类，空的，有一个球的，以及满的。由于不存在能够直接合并的颜色，所以那些有一个球的栈中的球的另一半一定在某个满的栈的下面。因为这个局面不使用空的栈完全无法做任何操作，所以至少需要一个空的栈，否则不合法。那么我们必然是将某个满的栈的栈顶放到一个空的栈中。下面记 $x'$ 为和 $x$ 颜色相同的另一个球，记 $x^R$ 为 $x$ 栈中的另一个球。假设我们移动的是 $x$，那么此时 $x^R$ 上面是空的，因此如果 $(x^R)'$ 是一个栈顶元素，便可以将它移到 $x^R$ 的上面完成一次合并。这个合并的过程还可以连续触发，即将 $(x^R)'$ 移动之后，$(((x^R)')^R)'$ 又可以被移动，以此类推。这启发我们对每个在上面的点 $x$ 都向 $(x^R)'$ 连边，但如果 $(x^R)'$ 不是一个栈顶节点就不连。这样会连出一张每个点出度为 $0/1$ 的有向图，且由于 $x^R$ 和 $x'$ 都是互逆变换，所以每个点入度也是 $0/1$​，因此只能是若干环和链组成的图。

下面考虑这张图具有什么性质，注意下面我们仅考虑所有在栈顶的点的入边与出边情况（包含只有一个球的栈的栈顶），因为其它点显然是孤立点。首先发现 $x$ 入度为 $0$ 当且仅当 $x$ 和 $x'$ 都在上面。如果 $x'$ 在下面，那么 $x'$ 的上面一定有一个元素，否则不满足此时不存在能直接合并的颜色这个性质。这样应当有边 $(x')^R\to x$，矛盾。而若 $x$ 出度为 $0$，那么要么 $x$ 在下面，要么 $(x^R)'$ 在下面，这是根据定义得到的。这样我们就明确了什么样的点是没有入度的，什么点是没有出度的。

当我们移动 $x$ 的时候，会从 $x$ 开始，向后不断走出边，并将这些经过的点全部都归位。例如现在的栈形如 $(1_0,3_0),(3_1,4_0),(4_1,2_0),(1_1,2_1)$，其中左边表示栈顶。则连出来的边是 $1_0\to 3_1,3_1\to 4_1$，注意由于 $((1_1)^R)'=2_0$ 不在栈顶，所以不予连边。如果将 $1_0$ 移动到空的栈，那么就可以将 $3_1,4_1$ 分别归位，得到一个 $(*,1_0),(*,2_0),(1_1,2_1)$ 的局面。这是一条链的情况，如果是一个环也是类似，区别就是此时 $x$ 本身也变得合法了。假如我们对一个从 $x$ 开始的环进行操作，那么操作完之后这个环上所有点都归位了，所以这个环就没了。如果是一条从 $x$ 开始的链，且这条链的结尾是一个大小为 $1$ 的栈中的点 $y$，那么这次操作之后 $x$ 变成了一个孤立的点，其它链上的点全部被合并了，包括 $y$。否则如果链的结尾是 $y$，那么这么做之后会留下 $x$ 和 $y'$ 两个孤立点。这样可以将一次操作近似看作消除一条链或环，但在链的两个端点处需要特别处理一下。

根据之前对这张图的分析，如果是消除一条链，那么这条链的起点是一个两个球都在上面的颜色，所以这部额外操作是必要的，因此不会造成最小步数的增加。而一个环不存在这样的点，所以会使得最小步数增加。但这个环没有别的方式破坏它了，所以无法达到理论最小值，理论最小值必然要加上环的个数。这样我们先将这些环消除不影响步数，然后只需要考虑链的情况。

如果有足够多的空栈，那么直接把链排一排依次消除即可，这样最小步数仍然是可以被达到的，但是问题是不一定有那么多的空栈，所以我们必须要合理地利用一次消除所产生的新空位来进行处理。显然除非没有链，否则必然至少要有一个空栈，这样至少可以消除一个链。注意到如果有一个大小为 $1$ 的栈，那么消除它所在的链会将这个元素合并进去，所以在消除结束之后占用的栈数量和消除之前是一样的，只需要在过程中借助这个确定存在的额外的栈。因此如果有一个大小为 $1$ 的栈，就可以选择任意一个消除这个所在的链。

做完上面这个操作之后剩下的全是大小为 $2$ 的栈，那么此时必须选择一个消除。不妨假设先消除了从 $x$ 开始的链，那么把 $x'$ 放在 $x$ 上不会更劣，所以接着可以消除 $x'$ 开始的链。这样会空出两个大小为 $1$ 的栈，设其中的元素分别为 $y,z$，若 $z=y'$，则可以将 $y,z$ 合并，这样空栈的数量和消除 $x$ 之前没有变化，因此可以直接继续消除。否则此时又不能进行任何操作了，但此时出现了大小为 $1$ 的栈，所以可以回到第一种消除方式继续消除。这样消除一圈之后如果回到了全是大小为 $2$ 的栈的情况，那么相当于是完成了一次重排，所以没有增加占用的栈的数量。因此可以继续消除。不过这种情况需要使用两个额外的栈，但如果存在一个这样的点 $x$，那么为了消除 $x$ 就必须要至少使用两个额外的栈（因为消除 $x$ 之后下一步该消除的点是唯一的，这样会形成一个等价类，无论先消除等价类中的哪个点，都不可能是前面的两种情况），所以这样也达到了下界。

这样这道题就做完了，但实现同样很麻烦。可以用 set 维护每种大小的栈编号的集合，一开始消除所有可以直接合并的颜色是可以用队列维护待消除的颜色，然后一次合并之后可能会影响到操作的栈中的其它点，可以判一下是否可以直接合并然后加入队列中。然后接下来直接用上面的讨论方式进行操作，具体地可以维护 $nxt,pre$ 表示链和环的前驱后继，然后实现两个函数分别表示消除一条链以及消除一个环。如果存在大小为 $1$ 的栈就先消除它的链。否则随便找一个删除。这里需要注意这个连边方式无法处理可以直接消除的情形，但由于一次都是直接消除到底，所以只可能在链首和链尾的这两个位置出现 $1$ 次可以继续消除的情况，判一下即可。复杂度 $O(n\log n)$。

[代码](https://loj.ac/s/2049327)

---


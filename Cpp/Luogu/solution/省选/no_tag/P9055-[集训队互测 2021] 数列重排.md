# [集训队互测 2021] 数列重排

## 题目背景

dottle bot。

## 题目描述

定义一个数列区间的 $\textrm{mex}$ 为区间中最小的没有出现过的自然数，定义一个数列的价值为其中 $\textrm{mex}\geq k$ 的区间数量。

给定 $n$ 个小于 $m$ 的自然数和一个区间 $[l,r]$，令 $f(k)$ 表示 $n$ 个数构成的数列所有重排列中数列价值的最大值，对于每一个 $k\in [l,r]$，求出 $f(k)$。

令 $a_i$ 表示数字 $i$ 出现的次数，保证存在正整数 $X$，使得  $\forall i\le m-1,a_i\in \{X,X+1\}$。

## 说明/提示

#### 样例 1 解释

在样例给出的数列中，有 $3$ 个 $0$ 和 $2$ 个 $1$，任意排列 $f(0)$ 均为 $15$，排列为 $\textrm{01010}$ 时 $f(1)$ 有最大值 $13$，答案为：
$$
\displaystyle (233^0\times 15\bmod 998244353)\oplus(233^1\times 13\bmod 998244353)=3034
$$

#### 数据范围

- Subtask 1（5 points）：$n,m\leq 9$。
- Subtask 2（15 points）：$n,m\leq 200$。
- Subtask 3（15 points）：$n,m\leq 5\times 10^3$。
- Subtask 4（5 points）：$m\leq 2$，$l=0$，$r=1$。
- Subtask 5（10 points）：$m\leq 10^6$，$l=m$，$r=m$。 
- Subtask 6（10 points）：$m\leq 10^6$，$X=1$，$s_i=0$。
- Subtask 7（15 points）：$m\leq 10^6$，$r-l+1\leq 10^4$。
- Subtask 8（15 points）：$m\leq 2\times 10^6$。
- Subtask 9（10 points）：无特殊限制。

对于所有数据，满足 $n\leq 10^9$，$m\leq 10^7$，$0\leq l\leq r\leq m$，$X\geq 1$。

## 样例 #1

### 输入

```
2 0 1 2
10```

### 输出

```
3034```

## 样例 #2

### 输入

```
14 1 14 13
10110101110101```

### 输出

```
379883349```

# 题解

## 作者：DaiRuiChen007 (赞：6)

# P9055 题解

[Problem Link](https://www.luogu.com.cn/problem/P9055)

**题目大意**

> 定义一个序列的价值为 $\mathrm{mex}$ 不小于 $i$ 的子区间数，$f(i)$ 表示将该序列重排后能得到的最大价值。
>
> 给定一个由 $0\sim m-1$ 构成的长度为 $n$ 的序列，保证元素出现次数的极差 $\le 1$，给定 $l,r$，求 $f(l)\sim f(r)$。
>
> 数据范围：$0\le l\le r\le m\le 10^7$，$n\le 10^9$。

**思路分析**

考虑 $f(m)$ 怎么求，显然把完整的 $0\sim m-1$ 一段一段地排在一起，那么会剩下一些出现次数为 $x+1$ 的元素，每种还剩一个，显然把这些元素堆在开头，然后把整块的 $0\sim m-1$ 重排使得这些开头的元素是该排列的后缀，容易证明此时所有长度 $\ge m$ 的子区间都合法。

对于任意 $f(i)$，显然 $0\sim i-1$ 一定按照如上方式排列，而对于其他元素：显然插入位置距离 $\ge i$ 的元素对才是合法的，因此如果一个长度为 $i$ 的段中间有元素插入，一定可以把这些元素移到两边而答案不劣。

此时共有 $x-1$ 个插入位置被夹在若干整块中间和 $2$ 个插入位置在两边（特判 $S_i$ 全部为 $1$ 的情况）。

考虑反面考虑，计算一个元素插入后会有多少个一个端点在该元素上的子区间不合法。

- 如果插在中间，那么会有 $(2i-2)+r+1$ 个区间不合法，其中 $r$ 是这个位置已经被插入的元素数量。
- 如果插在两边，那么会有 $(i-1)+r+1$ 个区间不合法，其中 $r$ 是这个位置已经被插入的元素数量。

显然每次我们会选一个破坏量最小的位置插入，那么我们先插 $2(i-1)$ 个元素进两边，剩余均摊插入每个位置即可。

时间复杂度 $\mathcal O(m)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=1e7+5,MOD=998244353;
int a[MAXN],s[MAXN],f[MAXN];
inline void sub(int &x,int y) { x=(x>=y)?x-y:x+MOD-y; }
inline ll S0(int l,int r) { return 1ll*(r-l+1)*(l+r)/2%MOD; }
inline ll S1(int r,int len) { return S0(r-len+1,r); }
inline ll S2(int l,int len) { return S0(l,l+len-1); }
signed main() {
    ios::sync_with_stdio(false);
    int m,l,r,K,n=0; char ch;
    cin>>m>>l>>r>>K;
    for(int i=0;i<m;++i) cin>>ch,a[i]=K+ch-'0',n+=a[i];
    for(int i=m-1;~i;--i) s[i]=a[i]+s[i+1];
    f[0]=S0(1,n);
    for(int i=1,k=a[0];i<=m;++i) {
        int s0=s[i],s1=n-s[i];
        f[i]=S0(1,n);
        sub(f[i],S1(s1,i-1));
        int c1=min(2*(i-1),s0);
        sub(f[i],S2(i,c1/2));
        sub(f[i],S2(i,(c1+1)/2));
        int c2=s0-c1,q=c2/(k+1),re=c2%(k+1);
        sub(f[i],S2(2*i-1,q)*(k+1-re)%MOD); 
        sub(f[i],S2(2*i-1,q+1)*re%MOD);
        k=min(k,a[i]);
    }
    ll ans=0,pw=1;
    for(int i=0;i<=m;++i) {
        if(l<=i&&i<=r) ans^=pw*f[i]%MOD;
        pw=pw*233%MOD;
    }
    cout<<ans<<"\n";
    return 0;
}
```

---

## 作者：ZHR100102 (赞：2)

差点就场切的神仙构造，最后一步想假了，导致我模拟赛荣获 25+5+0 的好成绩！

这题部分分很有启发性，跟着一步一步打基本能想到正解的构造，但也有可能想偏部分分的意思，想假策略。

# 构造

先看 Subtask 4 的构造，不难发现，当 $k=0$ 时所有重排都能让所有区间的 $mex\ge0$，而当 $k=1$ 时，$01$ 交替放置，多出的那个放第一位，一定是最优的。

再看 Subtask 5 的构造，显然我们可以先让每个数里的 $X$ 个先**组成循环节**，比如 $012301230123$。而对于多出 $1$ 的那些，我们调整循环节内部的顺序，使得**多出来接在后面的部分是循环节的一段前缀**，比如多出了 $1,3$，则构造为 $13201320132013$。因为这样能保证每 $m$ 个就一定可以形成一个 $mex\ge m $ 的区间。

最后看 Subtask 6 的构造，对于多出来没有用的数字，我们可以列出一个无比丑陋的二次函数式子，然后就能证明这些多出的数字分成两半，分别放在两边是最优的。就过了这个子任务。

然后我就以为正解就是在 Subtask 5 的基础上加上 Subtask 6 就做完了，荣获 25pts 的高分！

实际上 Subtask 6 的策略是片面的，当两边插的过多的时候，两边带来的贡献可能比插到中间的贡献少，这一点同样可以从 Subtask 4 的构造中得出。

那么我们先考虑插到中间，一个显然的结论是插到循环节中间不如插到两个循环节之间的部分，因此我们来计算插到两个循环节之间（设这个位置为 $p$，之前已经在这个位置插了 $c$ 个，插之前序列的长度为 $l$）的贡献：
- 当一个区间的左右端点都不在 $p$ 时，显然对区间的贡献没有影响。
- 当一个区间的左右端点至少有一个在 $p$ 上时，这些区间一共有 $l+1$ 个，减去其中不合法的，一共有 $l+1-2\times(k-1)-c-1$ 个有贡献。其中 $2\times(k-1)$ 减去的是那些不完整的循环节，$c+1$ 是包括自身在内的插入了的位置。总共减去的贡献是 $2\times(k-1)+c+1$。

插到两边也是同理，贡献是 $l+1-(k-1)-c-1$，减去的总贡献是 $(k-1)+c+1$。

那么显然先插两边是更优的，为了得到临界值，令中间插的 $c=0$，列出方程：

$$l+1-(k-1)-c-1< l+1-2\times (k-1)-0-1$$

$$c < 2k-1$$

因此，我们得出策略：先在两边插 $2k-2$ 个，然后我们轮流进行中间插和两边插，这样一定能让贡献最大化。

# 实现

首先定义函数 $cal(l,r)=\frac{(l+r)(r-l+1)}{2}$，含义是计算 $l$ 到 $r$ 的等差数列的和。

设 $pre$ 为小于 $k$ 的数的个数，$suf$ 为大于等于 $k$ 的数的个数。

对于一个 $f(k)$，我们进行如下过程求解：
- 若 $k=0$，则 $f(k)=cal(1,n)$，直接结束程序。
- 先计算所有区间的个数 $f(k)\gets cal(1,n)$。
- 然后减去插入前就不合法的区间（也就是本来 $mex<k$ 的区间），$f(k)\gets f(k)-cal(pre-(k-1)+1,pre)$。
- 然后先插 $\min(2k-2 ,suf)$ 个在两边，注意两边要各一半，两边的个数记为 $lx,rx$，则 $f(k)\gets f(k)-cal(k,k+lx-1)-cal(k,k+rx-1)$。
- 最后将剩下的均匀插入中间和两边，假设中间的位置有 $j-1$ 个（详见代码），则一共可插入的位置有 $j+1$ 个。设 $lst=suf-\min(2k-2 ,suf),z=\left \lfloor  \frac{lst}{j+1}\right \rfloor ,y= lst \bmod (j+1)$。$z$ 的含义是完整插入的轮数，$y$ 是最后一轮多插的个数。则 $f(k)\gets f(k)-cal(2k-1,2k-1+k-1)\times(j+1)-y\times(2k-1+z)$。

由此计算即可。

时间复杂度 $O(m)$。

注意不要爆空间。

# 代码

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define lc (p<<1)
#define rc ((p<<1)|1)
#define eb(x) emplace_back(x)
#define pb(x) push_back(x)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ldb;
using pi=pair<int,int>;
const ll mod=998244353;
int pw[10000005],m,l,r,x,f[10000005],suf[10000005],n,a[10000005],ans=0;
ll cal(ll l,ll r)
{
    return ((l+r)*(r-l+1)/2)%mod;
}
int main()
{
    //freopen("sample.in","r",stdin);
    //freopen("sample.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    pw[0]=1;
    for(int i=1;i<=10000000;i++)pw[i]=(233ll*pw[i-1])%mod;
    cin>>m>>l>>r>>x;
    for(int i=0;i<m;i++)
    {
        char c;
        cin>>c;
        suf[i]=a[i]=x+c-'0';
        n+=suf[i];
    }
    for(int i=m-1;i>=0;i--)
    {
        suf[i]+=suf[i+1];
    }    
    f[0]=cal(1,n);
    for(int i=1,j=a[0];i<=m;i++)
    {
        //计算所有区间
        ll res=cal(1,n),sufsm=suf[i],presm=n-sufsm;
        //减去插入前不合法区间
        ll sm1=cal(presm-i+2,presm);
        res=((res-sm1)%mod+mod)%mod;
        //减去插入左右两端后不合法区间
        ll canp=min(2ll*(i-1),sufsm);
        ll lx=canp/2,rx=canp-lx;
        ll sm2=cal(i,i+lx-1);
        ll sm3=cal(i,i+rx-1);
        res=((res-sm2)%mod+mod)%mod;
        res=((res-sm3)%mod+mod)%mod;
        //减去中间和两端交替插入后不合法区间
        ll lst=sufsm-canp;
        ll z=lst/(j+1),y=lst%(j+1);
        ll sm4=1ll*cal(2*i-1,2*i-1+z-1)*(j+1);
        ll sm5=1ll*(2*i-1+z)*y;
        res=((res-sm4)%mod+mod)%mod;
        res=((res-sm5)%mod+mod)%mod;
        f[i]=res%mod;
        j=min(j,a[i]);
    }
    for(int i=l;i<=r;i++)ans^=((1ll*pw[i]*f[i])%mod);
    cout<<ans;
    return 0;
}
```

---

## 作者：biyi_mouse (赞：1)

[P9055 [集训队互测 2021] 数列重排](https://www.luogu.com.cn/problem/P9055)

部分分其实可以给出很多的启发。

首先 $f(0)$ 显然任何区间都能满足条件，答案应该是 $\frac{n(n - 1)}{2}$。

然后考虑 $f(m)$，一种构造方式是先来 $X$ 组 $0,1, \dots, m - 1$，此时所有长度 $\geq m$ 的区间都满足条件。但我们还会有一些多出来的数，处理方式是将这些数放到序列开头，并且调整每一组使得开头的这一段数为每一组数的后缀。结构大概类似于 $025\dots025\dots025$，可以发现此时依旧满足所有 $\geq m$ 的区间都满足条件。

由 $f(m)$ 的启发考虑 $f(i)$，我们可以先将 $0 \sim i- 1$ 都按照 $f(m)$ 的方法排好，然后我们考虑如何插入剩下的数。

注意到我们的构造方式已经使得任意长度 $\geq i$ 的区间都满足条件，所以接下来插入的数如果插到某一个块（这里把上文的一组数叫做“块”）内部一定不优，换言之我们一定要把它插到块与块交界的地带或者整个序列的左侧和右侧。

我们分别考虑插到块与块交界地带会产生的不合法区间。

首先块与块之间应该有 $X - 1$ 个空，然后如果在某个空插一个数会增加 $2(i - 1) + r + 1$ 个不合法区间，其中 $r$ 这个空已经插入的数量。因为它可以和本来就不合法的块内区间（即长度 $< i$ 的区间）组成不合法区间，还可以和空内的组合以及自己也是一个不合法的区间。

然后如果插入到两侧则会产生 $i - 1 + r + 1$ 个不合法区间，分析同上。

我们显然要让两侧和中间尽可能平衡，所以我们先在两侧插 $2(i - 1)$ 个数，然后平均的对于两侧和中间插即可。

接下来我们考虑实现。我们可以容斥，减去所有不合法的区间。为了方便叙述我们令 $calc(l, r)$ 表示首项与末项分别为 $l$ 和 $r$ 的公差为 $1$ 的等差数列求和。

以下记 $pre$ 为小于 $i$ 的数量，$suf$ 为大于等于 $i$ 的数量。

先让 $f(i) = calc(1, n)$，然后减去所有按照 $f(m)$ 的方法排好后的不合法区间，即长度小于 $i$ 的区间。显然长度为 $l$ 的区间有 $pre - l + 1$ 个，总个数就是 $calc(pre - (i - 1) + 1, pre)$。

然后我们要在两侧插数，注意我们插入的数个数为 $\min(2(i - 1), suf)$。此时记在左侧插入 $lx$ 个数，右侧插入 $rx$ 个数。此时增加的不合法区间（对于左侧）一定是左端点为这 $lx$ 个数，右端点为这 $lx$ 个数加上块内的 $i - 1$ 个数，那么总和就是 $calc(i, lx + i -1)$ 和 $calc(i, rx + i - 1)$。

接着是平均插数，具体情况之前分析过了。设完整地插了 $z$ 轮，然后剩下 $y$ 个多出来的数。那么增加的不合法区间个数就是 $calc(2i - 1, 2i - 1 + z - 1) \times (j + 1) + y \times (2i - 1 + z)$。其中 $j + 1$ 是所有空的数量。

洛谷有点卡常，少用 `long long`。值得注意的是 LOJ 完全不卡。

```cpp
#include <bits/stdc++.h>
#define rep(i, a, b) for (int i = (a); i <= (b); i ++)
#define fro(i, a, b) for (int i = (a); i >= b; i --)
#define INF 0x3f3f3f3f
#define eps 1e-6
#define lowbit(x) (x & (-x))
#define initrand srand((unsigned)time(0))
#define random(x) ((LL)rand() * rand() % (x))
#define eb emplace_back
using namespace std;
typedef long long LL;
typedef pair<int, int> PII;
typedef pair<double, int> PDI;
inline int read() {
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = (x << 1) + (x << 3) + (ch ^ 48); ch = getchar(); }
    return x * f;
}

const int N = 10000010, Mod = 998244353;
int m, l, r;
int f[N], a[N], s[N], X, n;
char op[N]; 

inline LL calc(int l, int r) {
    return 1ll * (l + r) * (r - l + 1) / 2 % Mod;
}

inline int min(int x, int y) {
    return x < y ? x : y;
}

inline void sub(int &x, int y) {
    x = (x < y ? x + Mod - y : x - y); 
}

int main() {
    m = read(), l = read(), r = read(), X = read();
    rep(i, 0, m - 1) {
        scanf(" %c", &op[i]);
        s[i] = a[i] = X + (op[i] == '1');
        n += a[i];
    } 
    fro(i, m - 1, 0) s[i] += s[i + 1];
    f[0] = calc(1, n);
    int j = a[0]; 
    rep(i, 1, m) {
        int suf = s[i], pre = n - s[i];
        f[i] = calc(1, n);
        sub(f[i], calc(pre - i + 2, pre));
        int tmp = min(2ll * (i - 1), suf);
        int lx = tmp / 2, rx = tmp - lx;
        sub(f[i], calc(i, i + lx - 1));
        sub(f[i], calc(i, i + rx - 1));
        // f[i] = ((f[i] - calc(i, i + lx - 1)) % Mod + Mod) % Mod;
        // f[i] = ((f[i] - calc(i, i + rx - 1)) % Mod + Mod) % Mod;
        int lst = suf - tmp, z = lst / (j + 1), y = lst % (j + 1);
        sub(f[i], 1ll * calc(2 * i - 1, 2 * i - 1 + z - 1) * (j + 1) % Mod);
        sub(f[i], 1ll * y * (2 * i - 1 + z) % Mod);
        // f[i] = ((f[i] - calc(2 * i - 1, 2 * i - 1 + z - 1) * (j + 1) % Mod) % Mod + Mod) % Mod;
        // f[i] = ((f[i] - y * (2 * i - 1 + z)) % Mod + Mod) % Mod;
        j = min(j, a[i]);
    }
    LL pw = 1, ans = 0;
    rep(i, 0, m) {
        if (l <= i && i <= r) ans = ans ^ (pw * f[i] % Mod);
        pw = pw * 233 % Mod; 
    } 
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：tribool4_in (赞：1)

首先显然 $f(0)=\binom{n}{2}$。同时注意到对于值域为 $[0,k-1]$ 的极差 $\le 1$ 的序列，有一种显然的构造方式可以使得所有长度 $\ge k$ 的子区间的 $\operatorname{mex}$ 均为 $k$（构造一个周期性序列即可）。

考虑计算 $f(k)$，可以先将 $[0,k-1]$ 中的值先用上述方式构造，然后将 $[k,m-1]$ 的值插入其中，**考虑答案的变化**。不妨设此时序列中完整 $[0,k-1]$ 周期的个数为 $x=\min_{i<k}a_i$，则此时在两两间隔 $k$ 的 $x-1$ 个位置作为插入点，以及序列两端作为插入点一定不劣（即在每个长度为 $k$ 且 $\operatorname{mex}=k$ 的子段之间插入，显然若在一段中间插入不如挪到两端）。

首先考虑在中间插入的情况，考虑插入一个数，设插入前总长为 $l$，此位置上已经有 $c$ 个插入的数，则答案增量为 $(l+1)-2(k-1)-cnt-1=(l+1)-(2i-1)-cnt$，其中 $(l+1)$ 为新增的子区间个数，且以新增的数为左或右端点共有 $2(k-1)+cnt+1$ 个区间的 $\operatorname{mex}<k$（注意有新增的数自身构成的区间）。

若在两端插入同理，答案增量为 $(l+1)-(k-1)-cnt-1=(l+1)-k-cnt$。

于是就可以贪心的插入了。首先可以在两端插入 $(k-1)$ 个拉平在两端或中间插入的差距，然后可以在这共 $x+1$ 个位置中尽量平均地插入。

实现上可以先令 $f(k)\gets \binom{n}{2}$，然后进行减量，注意要减去长度 $<k$ 的序列个数。

代码实现参考了 @DaiRuiChen007 的题解。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e7 + 10, mod = 998244353;
int n, m, l, r, X, a[N], s[N];
char _s[N];
#define chkmod(x) (((x) >= mod) && ((x) -= mod))
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> m >> l >> r >> X >> _s;
    for (int i = 0; i < m; i++) a[i] = X + _s[i] - '0', s[i] = (i == 0 ? 0 : s[i - 1]) + a[i];
    n = s[m - 1];
    auto calc = [](int l, int r) { return 1ll * (l + r) * (r - l + 1) / 2 % mod; };

    int ans = l == 0 ? calc(1, n) : 0;
    for (int i = 1, pw = 233, mi = a[0]; i <= r; i++, pw = pw * 233ll % mod) {
        int res = calc(1, n), hs = n - s[i - 1], c0 = min(2 * (i - 1), hs), c1 = hs - c0;
        res += mod - calc(s[i - 1] - i + 2, s[i - 1]), chkmod(res);

        res += mod - calc(i, i + (c0 / 2) - 1), chkmod(res);
        res += mod - calc(i, i + (c0 - c0 / 2) - 1), chkmod(res);

        int x = c1 / (mi + 1), y = c1 % (mi + 1);
        res += mod - 1ll * calc(2 * i - 1, 2 * i + x - 2) * (mi + 1) % mod, chkmod(res);
        res += mod - 1ll * (2 * i + x - 1) * y % mod, chkmod(res);

        if (i >= l) ans ^= 1ll * pw * res % mod;
        mi = min(mi, a[i]);
    }
    cout << ans << '\n';
    return 0;
}
```

---

## 作者：Leasier (赞：0)

~~[william555](https://www.luogu.com.cn/user/211518) 好闪，拜谢 [william555](https://www.luogu.com.cn/user/211518)！！！~~

------------

$f(0)$ 是很好求的，因为此时每个区间都满足条件，所以答案为 $S_1(n)$。

现在我们来考虑一个一般的 $f(i)$。如果当前 $s$ 的前缀中没有任何 $0$ 的话，此时应该把 $X$ 当成 $X + 1$ 来算并把 $0$ 扔掉。

感性地，我们首先来构造 $X$ 个相同的包含 $[0, i)$ 排列的连续段（**整个连续段**记作 $0$）以及一些 $> i$ 的数（记作 $1$），然后我们就可以把 $a$ 写成 $01$ 连续段的形式。注意如果有多出的 $s_i = 1$ 的项，我们将其放到每个周期的最前面，并在最后加一个不完整的连续段放置剩下的一些。

设一共有 $k$ 段，每段被 $0$ 夹住的 $1$ 的长度分别为 $size_i$。接下来考虑 $k > 1$ 即存在 $0$ 的情况。

接下来我们来分讨一下贡献：

- $1 \to 1$

此时贡献为 $C_{cnt_1}^2 - \displaystyle\sum_{i = 1}^k C_{size_i}^2$（即所有两两之间减去不跨过 $0$）。

- $0 \to 0$

此时的方案数等价于在一个长为 $cnt_0$ 的序列中选出一个长度 $\geq i - 1$ 的子串的方案数，即为 $S_1(cnt_0 - (i - 1))$。

- $0 \to 1, 1 \to 0$

这里我们分两类讨论：

- 边上的贡献为 $(size_1 + size_k)(cnt_0 - X + 1)$。
- 中间的贡献为 $size_i(cnt_0 - 2X + 2)$。

现在我们考虑在某个 $1$ 连续段中插入第 $j$ 个数时 $0 \to 1, 1 \to 0, 1 \to 1$ 的贡献。

- 插入边上，此时 $\Delta = cnt_0 - X - j + 2$。
- 插入中间，此时 $\Delta = cnt_0 - 2X - j + 3$。

考虑贪心，每次取出最大的 $\Delta$。使用该策略进行一些手模可以发现：

- 一开始我们会在边上轮流插入 $k - 1$ 次，此后每 $k$ 次操作结束后，贡献都相同。
- 接下来可以循环着插每个组，这里顺序不影响。

模拟该流程即可。具体实现时还需要分 $cnt_1$ 与 $2(i - 1)$ 的大小关系讨论。时间复杂度为 $O(m)$。

代码：
```cpp
#include <stdio.h>

typedef long long ll;

const int mod = 998244353;
ll f[10000007];
char s[10000007];

inline ll sum1(int n){
	return (ll)n * (n + 1) / 2;
}

int main(){
	int m, l, r, x, n, one, pre = 0x7fffffff, zero = 0;
	ll val = 0, power = 1, ans = 0;
	scanf("%d %d %d %d", &m, &l, &r, &x);
	scanf("%s", s);
	n = m * x;
	for (int i = 0; i < m; i++){
		n += s[i] - '0';
	}
	one = n;
	f[0] = sum1(n);
	for (int i = 1; i <= m; i++){
		int cur = x + (s[i - 1] - '0');
		zero += cur;
		one -= cur;
		if (pre > cur) pre = cur;
		f[i] = (sum1(zero - (i - 1)) + sum1(one)) % mod;
		if (one <= (i - 1) * 2){
			int t = one / 2;
			f[i] = ((f[i] + (ll)one * (zero - (i - 1)) % mod - sum1(t) - sum1(one - t)) % mod + mod) % mod;
		} else {
			int p = one - (i - 1) * 2, q = p / (pre + 1), r = p % (pre + 1);
			f[i] = ((f[i] - sum1(i - 1) * 2 % mod + (ll)2 * (i - 1) % mod * (zero - (i - 1)) % mod + (ll)p * (zero - (i - 1) * 2) % mod - sum1(q) * (pre - r + 1) % mod - r * sum1(q + 1) % mod) % mod + mod) % mod;
		}
	}
	for (int i = 0; i <= r; i++){
		if (i >= l) ans ^= power * f[i] % mod;
		power = power * 233 % mod;
	}
	printf("%lld", ans);
	return 0;
}
```

---


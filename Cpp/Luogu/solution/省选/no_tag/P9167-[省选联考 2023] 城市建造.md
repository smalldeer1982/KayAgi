# [省选联考 2023] 城市建造

## 题目描述

在这个国度里面有 $n$ 座城市，一开始城市之间修有若干条双向道路，导致这些城市形成了 $t \ge 2$ 个连通块，特别的，这些连通块之间两两大小差的绝对值不超过 $0 \le k \le 1$。为了方便城市建设与发展，$n$ 座城市中的某 $t$ 座城市**在这 $t$ 座城市之间**额外修建了至少一条双向道路，使得所有城市连通。

现在已经知道额外修建后的所有道路，你需要算出有哪些双向道路集合 $E'$，满足这些道路有可能是后来额外修建的，请输出答案对 $998,244,353$ 取模的结果。

即给定一张 $n$ 个点 $m$ 条边的**无向连通**图 $G = (V, E)$，询问有多少该图的子图 $G' = (V', E')$，满足 $E' \ne \varnothing$ 且 $G - E'$ 中恰好有 $|V'|$ 个连通块，且任意两个连通块大小之差不超过 $k$，保证 $0 \le k \le 1$，请输出答案对 $998,244,353$ 取模的结果。


## 说明/提示

**【样例 1 解释】**

有以下两种情况：

- 本来只有 $(3, 4)$ 这一条道路，此时有三个连通块，分别为 $\{1\}, \{2\}, \{3, 4\}$；后来城市 $1, 2, 3$ 决定在它们三座城市中额外修建了 $(1, 2), (2, 3), (1, 3)$ 这三条道路，使得所有城市连通。
- 本来没有任何道路，此时有四个连通块，分别为 $\{1\}, \{2\}, \{3\}, \{4\}$；后来城市 $1, 2, 3, 4$ 决定在它们四座城市中额外修建了 $(1, 2), (2, 3), (1, 3), (3, 4)$ 这四条道路，使得所有城市连通。

**【数据范围】**

对于所有的数据，保证：$3 \le n \le 10^5$，$n - 1 \le m \le 2 \times 10^5$，$0 \le k \le 1$。

|测试点|$n$|$m$|$k$|
|:-:|:-:|:-:|:-:|
|1, 2|$\le 15$|$\le 20$|$= 0$|
|3 ~ 5|$\le 20$|$\le 50$|$= 1$|
|6, 7|$\le 200$|$\le 300$|$= 0$|
|8, 9|$\le 2,000$|$= n - 1$|$= 1$|
|10, 11|$\le 2,000$|$\le 3,000$|$= 0$|
|12, 13|$\le 2,000$|$\le 3,000$|$= 1$|
|14, 15|$\le 10^5$|$= n - 1$|$= 1$|
|16, 17|$\le 10^5$|$\le 2 \times 10^5$|$= 0$|
|18 ~ 20|$\le 10^5$|$\le 2 \times 10^5$|$= 1$|


## 样例 #1

### 输入

```
4 4 1
1 2
2 3
1 3
3 4
```

### 输出

```
2
```

## 样例 #2

### 输入

```
见附件中的 cities/cities2.in```

### 输出

```
见附件中的 cities/cities2.ans```

## 样例 #3

### 输入

```
见附件中的 cities/cities3.in```

### 输出

```
见附件中的 cities/cities3.ans```

## 样例 #4

### 输入

```
见附件中的 cities/cities4.in```

### 输出

```
见附件中的 cities/cities4.ans```

# 题解

## 作者：Alex_Wei (赞：45)

#### [P9167 [省选联考 2023] 城市建造](https://www.luogu.com.cn/problem/P9167)

因为选择的城市数等于连通块数，所以每个连通块恰选择一个城市，否则无法连通。

先在不考虑连通块大小的限制下，探究合法的充要条件。

##### 性质和结论

对于选择的两个城市，如果存在一条不经过重复点的简单路径连接它们，则路径上的每个点都要选择。否则，必然存在某两个选择的城市连通。

相反，如果满足条件，将选择的城市之间的边删去后，这些城市两两不连通。可以反证。

因此，根据点双的性质，如果一个点双里面选了两个点，则整个点双都要被选择。

建出圆方树，称选择一个方点表示选择其周围的所有圆点，要求：

- 为保证选择的城市不连通，选择的方点是一个连通块。即若两个方点被选择，则它们简单路径上的所有方点均被选择。
- 删去选择的方点（相当于删去选择城市之间的边）后，每个连通块大小（圆点数量）相差不超过 $k$。

##### $\boldsymbol{k = 0}$

考虑 $k = 0$，则连通块大小 $d$ 为 $n$ 的因数。

考虑以重心 $R$ 为根，则若一个方点被选择，其祖先方点一定被选择，且若 $R$ 为方点，则 $R$ 一定被选择。可以反证。

树形 DP，能剥子树就剥子树。设 $f_i$ 表示：若 $i$ 是圆点，能否删去其父亲方点（若 $i$ 为根，则答案可以视为添加并强制删去 $i$ 的父亲方点时整棵子树的答案）；若 $i$ 是方点，能否删去其本身。$f_R$ 即为所求。

- 对于圆点 $i$，枚举所有子结点 $j$（方点）。当 $sz_j \geq d$ 时，要求 $f_j = 1$。否则 $j$ 不能被删去，因此要求 $sz_j < d$ 的 $sz_j$ 之和恰等于 $d$。
- 对于方点 $i$，$f_i = 1$ 当且仅当其所有子结点 $j$ 的 $f_j = 1$。

##### $\boldsymbol{k = 1}$

考虑 $k = 1$，枚举连通块大小 $d = 1\sim \lfloor \frac n 2\rfloor$，则 $k = 0$ 的 $2\sim \lfloor \frac n 2\rfloor$ 多算了，要减掉（因为 $n\geq 3$，所以 $k = 0$ 的 $\lfloor \frac n 2\rfloor + 1$ 一定不合法）。

类似地，设 $f_i$ 表示对应方案数，$f_R$ 即为所求。

- 对于圆点 $i$：

  - 若 $sz_j < d$，则 $j$ 不能被删去。
  - 若 $sz_j > d$，则 $j$ 必须被删去。
  - 否则 $sz_j = d$。当 $f_j = 0$ 时，$j$ 不能被删去。否则 $j$ 可以被删去，也可以不删去，但后者要求不存在不能被删去的 $j$ 且其它 $j$ 均被删去。

  设 $ss$ 为不能被删去的 $\sum sz_j$ 加上 $i$ 本身贡献的 $1$ 表示 $i$ 的连通块大小最小值，设 $pd$ 为可以被删去的 $\prod f_j$：

  - 若 $ss > d + 1$，$f_i = 0$。
  - 若 $d\leq ss\leq d + 1$，则 $f_i$ 加上 $pd$。
  - 若 $ss = 1$，则 $f_i$ 加上对每个可以被删去的 $sz_j = d$，$\frac {pd} {f_j}$ 之和。因为 $sz_j = d$ 且 $f_j > 0$ 时 $f_j = 1$，故 $\sum \frac {pd} {f_j}$ 等于 $pd$ 乘以 $sz_j = d$ 且 $f_j > 0$ 的 $j$ 的数量 $cnt$。

  注意第二、三个条件可以同时满足。

- 对于方点 $i$，$f_i$ 等于 $\prod f_j$。

$k = 0$ 的复杂度为 $\mathcal{O}(nd(n))$，$k = 1$ 的复杂度为 $\mathcal{O}(n ^ 2)$。 

枚举选择的城市数量，发现只有整除值或整除值 $-1$ 可能成为答案（等价于 $n\bmod l \leq \frac n l$ 的 $l$ 的数量），复杂度降为 $\mathcal{O}(n ^ {1.5})$。加入部分剪枝后以非常快的速度通过（若 $sz_j > d$ 且 $f_j = 0$ 则无解，若 $sz_j < d$ 则不用递归）。

```cpp
#include <bits/stdc++.h>
using namespace std;

constexpr int N = 2e5 + 5;
constexpr int mod = 998244353;
void add(int &x, int y) {
  x += y, x >= mod && (x -= mod);
}

int n, m, k, ans, node;
vector<int> e[N], g[N], h[N];
int dn, dfn[N], low[N], stc[N], top;
void tarjan(int id) {
  low[id] = dfn[id] = ++dn, stc[++top] = id;
  for(int it : e[id]) {
    if(!dfn[it]) {
      tarjan(it);
      low[id] = min(low[id], low[it]);
      if(low[it] >= dfn[id]) {
        g[++node].push_back(id);
        g[id].push_back(node);
        for(int x = 0; x != it; ) {
          x = stc[top--];
          g[node].push_back(x);
          g[x].push_back(node);
        }
      }
    }
    else low[id] = min(low[id], dfn[it]);
  }
}

int R, mx[N], sz[N];
void findroot(int id, int ff) {
  sz[id] = id <= n;
  for(int it : g[id]) {
    if(it == ff) continue;
    findroot(it, id);
    sz[id] += sz[it];
    mx[id] = max(mx[id], sz[it]);
  }
  mx[id] = max(mx[id], n - sz[id]);
  if(id <= n && mx[id] < mx[R]) R = id;
}

int pos, fa[N], mn[N], ind[N];
void dfs(int id, int ff) {
  ind[++pos] = id;
  mn[id] = N, fa[id] = ff, sz[id] = id <= n;
  for(int it : g[id]) {
    if(it == ff) continue;
    dfs(it, id), sz[id] += sz[it];
    mn[id] = min(mn[id], sz[it]);
    h[id].push_back(it);
  }
}

int f[N];
void dfs2(int id, int x) {
  for(int i = node; i; i--) {
    int id = ind[i], cnt = 0;
    if(sz[id] < x) continue;
    if(id <= n) {
      f[id] = 0;
      int tot = 1, prod = 1;
      for(int i = 1; i <= h[id].size(); i++) {
        int it = h[id][i - 1];
        if(sz[it] < x) tot += sz[it];
        if(sz[it] == x) f[it] ? cnt++ : tot += x;
        if(sz[it] > x) prod = 1ll * prod * f[it] % mod;
      }
      if(x <= tot && tot <= x + 1) f[id] = prod;
      if(tot == 1) f[id] = (f[id] + 1ll * prod * cnt) % mod;
    }
    else {
      f[id] = 1;
      for(int it : h[id]) {
        if(sz[it] < x) {
          f[id] = 0;
          break;
        }
        f[id] = 1ll * f[id] * f[it] % mod;
      }
    }
    if(sz[id] > x + 1 && f[id] == 0) {
      f[R] = 0;
      break;
    }
  }
}
void dfs3(int id, int x) {
  for(int i = node; i; i--) {
    int id = ind[i];
    if(sz[id] < x) continue;
    if(id <= n) {
      f[id] = 0;
      int tot = 1, ok = 1;
      for(int it : h[id]) {
        if(sz[it] < x) tot += sz[it];
        else if(!f[it]) ok = 0;
      }
      f[id] = tot == x && ok;
    }
    else {
      f[id] = 1;
      for(int it : h[id]) {
        if(sz[it] < x) f[id] = 0;
        else if(!f[it]) f[id] = 0;
      }
    }
    if(sz[id] > x + 1 && f[id] == 0) {
      f[R] = 0;
      break;
    }
  }
}
int check(int x, int k) {
  if(k == 0 && n % x) return 0;
  k == 1 ? dfs2(R, x) : dfs3(R, x);
  int res = f[R];
  if(k == 1) res = (res - check(x + 1, 0) + mod) % mod;
  return res;
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin >> n >> m >> k, node = n;
  for(int i = 1; i <= m; i++) {
    int u, v;
    cin >> u >> v;
    e[u].push_back(v);
    e[v].push_back(u);
  }

  tarjan(1);

  mx[0] = N, findroot(1, 0), dfs(R, 0);
  static bool vis[N];
  for(int i = 2; i <= n; i++) {
    vis[n / i] = 1;
    if(n % i == 0) vis[n / i - 1] = 1;
  }
  for(int l = 1; l <= n / 2; l++) {
    if(!vis[l]) continue;
    ans = (ans + check(l, k)) % mod;
  }
  cout << ans << "\n";

  cerr << 1e3 * clock() / CLOCKS_PER_SEC << " ms\n";
  return 0;
}
/*
g++ cities.cpp -o cities -std=c++14 -O2
*/
```

##### 线性做法

考虑同时 DP 所有 $d$，用哈希表维护有值的位置 $f_{i, d}$。

- 对于方点，合并子结点的复杂度不超过子结点哈希表大小之和。

- 对于圆点，按子树大小从小到大排序，则只有 $1$ 或子树大小前缀和或子树大小前缀和 $+1$ 可能合法。预处理子树大小前缀和。计算 $f_{i, d}$ 时，从后往前枚举。

  - 若 $sz_j < d$ 则不用继续枚举，直接给 $ss$ 加上子树大小前缀和。
  - 若 $sz_j > d$ 则将 $pd$ 乘以 $f_{j, d}$，若 $f_{j, d} = 0$ 则直接退出。
  - 若 $sz_j = d$ 且 $f_{j, d} = 1$，则给 $cnt$ 加 $1$。
  - 若 $sz_j = d$ 且 $f_{j, d} = 0$，则给 $ss$ 加 $d$，这样的 $j$ 最多只能有 $1$ 个。

  可知圆点的哈希表大小不超过其度数，且计算 $f_{i, d}$ 的总复杂度不超过子结点的哈希表大小之和。

除去按子树大小排序外，复杂度为 $\mathcal{O}(n)$。甚至跑不过 $\mathcal{O}(n ^ {1.5})$。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

bool Mbe;
constexpr int N = 2e5 + 5;
constexpr int mod = 998244353;
void add(int &x, int y) {
  x += y, x >= mod && (x -= mod);
}

vector<int> e[N], g[N], son[N];
int node, dn, dfn[N], low[N], stc[N], top;
void tarjan(int id) {
  dfn[id] = low[id] = ++dn;
  stc[++top] = id;
  for(int it : e[id]) {
    if(!dfn[it]) {
      tarjan(it);
      low[id] = min(low[id], low[it]);
      if(low[it] >= dfn[id]) {
        g[++node].push_back(id);
        g[id].push_back(node);
        for(int x = 0; x != it; ) {
          g[node].push_back(x = stc[top--]);
          g[x].push_back(node);
        }
      }
    }
    else low[id] = min(low[id], dfn[it]);
  }
}

int n, m, k;
int R, sz[N], mx[N];
void dfs(int id, int ff) {
  sz[id] = id <= n;
  for(int it : g[id]) {
    if(it == ff) continue;
    dfs(it, id), sz[id] += sz[it];
    mx[id] = max(mx[id], sz[it]);
  }
  mx[id] = max(mx[id], n - sz[id]);
  if(mx[id] < mx[R]) R = id;
}

int ss[N];
unordered_map<int, int> f[N];
int calc() {
  int ans = 0;
  for(auto it : f[R]) {
    if(it.first * 2 <= n) add(ans, it.second);
  }
  return ans;
}
void merge(int x, int y) {
  unordered_map<int, int> nw;
  for(auto it : f[x]) {
    auto pt = f[y].find(it.first);
    if(pt != f[y].end()) nw[it.first] = 1ll * it.second * pt->second % mod;
  }
  f[x] = nw;
}

void dfs0(int id, int ff) {
  for(int it : g[id]) {
    if(it == ff) continue;
    dfs0(it, id), son[id].push_back(it);
  }
  sort(son[id].begin(), son[id].end(), [&](int x, int y) {
    return sz[x] < sz[y];
  });
  int E = son[id].size();
  if(id <= n) {
    for(int i = 1; i <= E; i++) ss[i] = ss[i - 1] + sz[son[id][i - 1]];
    auto update = [&](int x) {
      for(int i = E; i; i--) {
        int it = son[id][i - 1];
        if(sz[it] >= x) {
          auto pt = f[it].find(x);
          if(pt == f[it].end()) return;
          continue;
        }
        if(ss[i] + 1 != x) return;
        break;
      }
      f[id][x] = 1;
    };
    for(int i = 0; i <= E; i++) update(ss[i] + 1);
  }
  else {
    f[id] = f[son[id][0]];
    for(int i = 1; i < E; i++) merge(id, son[id][i]);
  }
}
void dfs1(int id, int ff) {
  for(int it : g[id]) {
    if(it == ff) continue;
    dfs1(it, id);
  }
  int E = son[id].size();
  if(id <= n) {
    for(int i = 1; i <= E; i++) ss[i] = ss[i - 1] + sz[son[id][i - 1]];
    auto update = [&](int x) {
      int prod = 1, size = 1, cnt = 0;
      for(int i = E; i && size <= x + 1; i--) {
        int it = son[id][i - 1];
        if(sz[it] >= x) {
          auto pt = f[it].find(x);
          if(sz[it] >= x + 1) {
            if(pt == f[it].end()) return;
            prod = 1ll * prod * pt->second % mod;
          }
          else {
            if(pt == f[it].end()) size += sz[it];
            else cnt++;
          }
        }
        else {
          size += ss[i];
          break;
        }
      }
      if(size > x + 1) return;
      f[id][x] = 1ll * prod * ((int) (size >= x) + (size == 1 ? cnt : 0)) % mod;
    };
    for(int i = 0; i <= E; i++) {
      if(i && ss[i - 1] + 1 != ss[i]) update(ss[i]);
      update(ss[i] + 1);
    }
  }
  else {
    f[id] = f[son[id][0]];
    for(int i = 1; i < E; i++) merge(id, son[id][i]);
  }
}

bool Med;
int main() {
  fprintf(stderr, "%.4lf\n", (&Mbe - &Med) / 1048576.0);
  #ifdef ALEX_WEI
    FILE* IN = freopen("cities.in", "r", stdin);
    FILE* OUT = freopen("cities.out", "w", stdout);
  #endif
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);

  cin >> n >> m >> k, node = n;
  for(int i = 1; i <= m; i++) {
    int u, v;
    cin >> u >> v;
    e[u].push_back(v);
    e[v].push_back(u);
  }
  tarjan(1);
  mx[0] = N, dfs(1, 0), dfs(R, 0);
  dfs0(R, 0);
  int ans = calc();
  if(k == 0) cout << calc() << "\n", exit(0);
  ans = mod - ans + 1, dfs1(R, 0);
  cout << (ans + calc()) % mod << "\n";
  cerr << 1e3 * clock() / CLOCKS_PER_SEC << " ms\n";
  return 0;
}
/*
g++ cities.cpp -o cities -std=c++14 -O2 -DALEX_WEI
*/
```

ymx 有一个除并查集外线性的妙妙做法。

---

## 作者：JCY_ (赞：35)

[更好的阅读体验](https://www.cnblogs.com/JCY-std/p/17315880.html)

[洛谷题面](https://www.luogu.com.cn/problem/P9167)

原题等价于计算有多少个点集 $V$，满足删去 $V$ 的导出子图中的边后，原图形成了 $|V|$ 个连通块，且连通块大小的极差 $\le k$。形成 $|V|$ 个连通块又等价于 $V$ 中的每个点都分属不同的连通块，我们称这样的 $V$ 为**合法**的。

考虑在同一个点双连通分量中的三点 $u, v, w$。若 $u, v \in V$ 而 $w \not \in V$，根据点双连通的性质，我们可以找到一条从 $u$ 到 $v$ 经过 $w$ 的简单路径，此时必有两个 $V$ 中的点属于同一个连通块。因此对于**合法**的 $V$，同一个点双连通分量中的点，要么全在 $V$ 中，要么只有一个在 $V$ 中，要么全不在 $V$ 中。

我们还可以发现，若 $V$ 的导出子图不连通，则必有两个 $V$ 中的点属于同一个连通块。因此对于**合法**的 $V$，其导出子图必须连通。

上面两条性质启发我们建出原图的圆方树。不难发现，我们选择的 $V$ 一定是在圆方树上“连通”的一些点双连通分量。具体地，用一个方点在 $S$ 中代表该点双连通分量中的所有点都在 $V$ 中，**合法**的 $V$ 对应的 $S$ 需要满足：若方点 $u, v \in S$，则所有在圆方树上 $u, v$ 间唯一简单路径上的方点都在 $S$ 中。我们称这样的 $S$ 为**合法**的。

在原图中删去 $V$ 的导出子图中的边、在圆方树中删去 $S$ 中的点后，原图的每个连通块和圆方树的每个连通块一一对应。定义圆方树上一个连通块的大小为连通块的圆点数，问题转化为计算有多少个圆方树上的**合法**方点点集 $S$，满足删去 $S$ 中的点后连通块大小的极差 $\le k$。我们称这样的 $S$ 为**符合题意**的。

考虑 $k \le 1$ 有什么用。不难猜想 $S$ 一定包含重心，因为连通块的划分看起来十分平均。

证明：

令圆点的点权为 $1$，方点的点权为 $0$，找出圆方树的带权重心 $rt$。$rt$ 的所有儿子子树内的点权和都 $\le \frac{n}{2}$。

如果 $rt$ 为方点，则**符合题意**的 $S$ 必然包含 $rt$，因为若不包含则 $rt$ 所在的连通块点权和 $\ge \frac{n}{2} + 1$，而 $rt$ 不在的连通块点权和都 $\le \frac{n}{2} - 1$，无论 $k$ 取多少都不**符合题意**。

如果 $rt$ 为圆点，对于**符合题意**的 $S$，若 $u \in S$，则以 $rt$ 为根时 $u$ 的所有祖先方点都应属于 $S$，证明同理。

证毕。

当 $rt$ 为方点时以 $rt$ 的任意相邻圆点为根，当 $rt$ 为圆点时以 $rt$ 为根，将圆方树变为有根树。这样，对于**符合题意**的 $S$，若 $u \in S$，则 $u$ 的所有祖先方点都应属于 $S$。

先考虑 $k = 0$ 时怎么做。

枚举连通块大小 $x$，记 $sz_i$ 表示圆方树定根后 $i$ 的子树内的权值和。对于方点 $u$，可以发现其是否属于 $S$ 可以直接通过 $sz_u$ 确定。若 $sz_u < x$ 则 $u \not \in S$。若 $sz_u > x$ 则 $u \in S$。若 $sz_u = x$，如果定根后 $u$ 的儿子数 $\ge 2$ 则 $u \not \in S$，否则 $u \in S$。证明考虑反证，若不满足上述任意条件则 $S$ 必然不**符合题意**，读者可自证。

因此可以直接从小到大枚举 $x$，用并查集维护连通性，再开一个桶 $cnt_i$ 记录连通块大小为 $i$ 的连通块数量即可。

再考虑 $k = 1$。

容易想到一个容斥，枚举连通块大小的集合 $\{x, x + 1\}$，钦定所有连通块大小属于该集合，计算方案数，然后减去连通块大小全为 $x$ 或全为 $x + 1$ 的方案数。

类似 $k = 0$，若 $sz_u < x$ 则 $u \not \in S$。若 $sz_u > S$ 则 $u \in S$。若 $sz_u = x$，如果定根后 $u$ 的儿子数 $\ge 2$ 则 $u \not \in S$，否则特殊处理。

特殊处理是 $k = 1$ 的一个小难点。

先考虑 $x > 1$ 的情况。

记 $fa_i$ 为定根后点 $i$ 的父亲。不难发现，对于需要特殊处理的 $u$，若 $fa_u$ 有若干个需要特殊处理的儿子，其中只能有至多一个 $\not \in S$。

我们先钦定所有需要特殊处理的点属于 $S$，此时若 $fa_u$ 所在连通块大小 $> 1$，则其所有需要特殊处理的儿子只能 $\in S$。否则，$fa_u$ 应有恰好一个儿子 $\not \in S$。

即对于所有存在需要特殊处理的儿子、且当前所在连通块大小 $= 1$ 的 $v$，给答案乘上 **点 $v$ 需要特殊处理的儿子数量**。

但当 $x = 1$ 时，我们应对于满足上述条件的 $v$，给答案乘上 **点 $v$ 需要特殊处理的儿子数量加一**。不难发现若 $fa_v$ 存在则必有 $fa_v \in S$，因此此时点 $v$ 需要特殊处理的儿子可以都 $\in S$。

同样这个过程可以用并查集加桶维护。

总时间复杂度 $O(n \alpha(n))$，瓶颈在并查集，但是精细实现可以不用并查集。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ull = unsigned long long;
using ld = long double;
template <typename T>
void chkmax(T &x, const T &y) {
  if (x < y) x = y;
}
template <typename T>
void chkmin(T &x, const T &y) {
  if (y < x) x = y;
}
constexpr int MAXN = 1e5 + 10, MOD = 998244353, INF = 0x3f3f3f3f;
void inc(int &x, int y) { x += y, x >= MOD && (x -= MOD); }
void dec(int &x, int y) { x -= y, x < 0 && (x += MOD); }
int n, k, dfn[MAXN], low[MAXN], dfc, stk[MAXN], tp, num, sz[MAXN * 2];
int mini, rt, ans1[MAXN], ans2[MAXN], fa[MAXN * 2], rec[MAXN];
bool vis[MAXN * 2];
vector<int> og[MAXN], g[MAXN * 2], buc[MAXN];
namespace dsu {
int fa[MAXN], sz[MAXN], cnt[MAXN];
void init() {
  iota(fa + 1, fa + n + 1, 1);
  fill(sz + 1, sz + n + 1, 1);
  cnt[1] = n;
}
int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }
void merge(int x, int y) {
  x = find(x);
  y = find(y);
  --cnt[sz[x]];
  --cnt[sz[y]];
  fa[x] = y;
  sz[y] += sz[x];
  ++cnt[sz[y]];
}
}  // namespace dsu
void tarjan(int u) {
  dfn[u] = low[u] = ++dfc;
  stk[++tp] = u;
  for (auto v : og[u]) {
    if (!dfn[v]) {
      tarjan(v);
      chkmin(low[u], low[v]);
      if (low[v] == dfn[u]) {
        g[u].emplace_back(++num);
        g[num].emplace_back(u);
        while (true) {
          int t = stk[tp--];
          g[num].emplace_back(t);
          g[t].emplace_back(num);
          if (t == v) break;
        }
      }
    } else {
      chkmin(low[u], dfn[v]);
    }
  }
}
void get_root(int u, int pre) {
  sz[u] = (u <= n);
  int tmp = 0;
  for (auto v : g[u]) {
    if (v == pre) continue;
    get_root(v, u);
    sz[u] += sz[v];
    chkmax(tmp, sz[v]);
  }
  chkmax(tmp, n - sz[u]);
  if (tmp < mini) {
    mini = tmp;
    rt = u;
  }
}
void dfs(int u, int pre) {
  fa[u] = pre;
  sz[u] = (u <= n);
  for (auto v : g[u]) {
    if (v == pre) continue;
    dfs(v, u);
    sz[u] += sz[v];
  }
  if (u > n) buc[sz[u]].emplace_back(u);
}
int main() {
  freopen("cities.in", "r", stdin);
  freopen("cities.out", "w", stdout);
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  int m;
  cin >> n >> m >> k;
  while (m--) {
    int u, v;
    cin >> u >> v;
    og[u].emplace_back(v);
    og[v].emplace_back(u);
  }
  num = n;
  tarjan(1);
  mini = INF;
  get_root(1, 0);
  if (rt > n) rt = g[rt][0];
  dfs(rt, 0);
  dsu::init();
  for (int i = 1; i < n; ++i) {
    for (auto u : buc[i]) {
      if (g[u].size() > 2) {
        for (int j = 1; j < (int)g[u].size(); ++j)
          dsu::merge(g[u][j - 1], g[u][j]);
      }
    }
    ans1[i] = (dsu::cnt[i] * i == n);
    vector<int> vec;
    for (auto u : buc[i]) {
      if (g[u].size() == 2) {
        if (dsu::sz[dsu::find(fa[u])] == 1) {
          vis[u] = vis[fa[u]] = true;
          dsu::merge(fa[u], g[u][g[u][0] == fa[u]]);
          vec.emplace_back(fa[u]);
          rec[fa[u]] = 1;
        } else if (vis[fa[u]]) {
          ++rec[fa[u]];
        }
      }
    }
    if (dsu::cnt[i] * i + dsu::cnt[i + 1] * (i + 1) == n) {
      ans2[i] = 1;
      for (auto u : vec) ans2[i] = (ll)ans2[i] * (rec[u] + (i == 1)) % MOD;
    }
    for (auto u : buc[i]) {
      if (g[u].size() == 2 && !vis[u]) {
        for (int j = 1; j < (int)g[u].size(); ++j)
          dsu::merge(g[u][j - 1], g[u][j]);
      }
    }
  }
  if (!k) {
    cout << accumulate(ans1 + 1, ans1 + n, 0) << "\n";
  } else {
    int ans = MOD - 1;
    for (int i = 1; i < n; ++i) inc(ans, ans2[i]);
    for (int i = 2; i < n; ++i) dec(ans, ans1[i]);
    cout << ans << "\n";
  }
  return 0;
}
```

---

## 作者：APJifengc (赞：11)

考场降智系列。

首先手模一下，发现题意就是让我们选出一个点集，删去之间的所有边，使得这个点集中的每个点都不在同一个连通块中。首先可以发现选择的点集一定是若干个点双，如果一个点双中的点没有全部被选择，那么一定有其中至少两个点仍然在同一连通块中。其次，我们发现选取的点集一定是联通的，否则同样会有两个点在同一连通块中。不难发现这就是点集合法的充要条件。

那么问题转换成了：给定一个图，删去若干个联通的点双，使得剩下的连通块的大小的极差 $\le k$。

首先点双容易想到圆方树转成树，现在就是一个树形 DP 了。极差不好做，我们考虑直接枚举连通块的大小。容易发现，当 $k=0$ 时，这个连通块的大小只能是 $n$ 的因子，数量是 $O(\sqrt{n})$ 的；$k=1$ 时，假如有 $k$ 个连通块，那么每个连通块的大小为 $\lfloor \frac{n}{k}\rfloor$ 与 $\lceil \frac{n}{k}\rceil$，而这个连通块大小也只有 $O(\sqrt{n})$ 种。

假如我们枚举当前的连通块大小为 $t$（与 $t+1$），那么我们直接在圆方树上跑树形背包，就很容易能够 DP 求出答案。具体的，对于每一个方点，它的方案为所有儿子的方案数的乘积；对于每一个圆点，我们需要让当前圆点所在的连通块大小为 $t$（与 $t+1$），那么我们可以选择一些儿子保留，选择一些儿子删除，这个可以通过树形背包实现。

对于选取的连通块，我们在深度最小的位置统计答案，那么在每个点统计它作为选取的连通块的深度最小的点时的方案数即可。这样的复杂度为 $O(nt)$。假如我们对每一个大小做一遍，由于调和级数为 $O(\log n)$，那么总复杂度为 $O(n^2 \log n)$，能够拿到 65 分。

以上是考场上想到的做法，但是考场降智，忘了怎么建圆方树了，痛失 40 分。

我们可以更仔细的分析一下这个背包的选取过程。先考虑 $k=0$ 的情况。我们发现一件事情，就是对于一个子树，如果我们选取它，那么这个子树的大小至少要为 $t$，否则内部不可能划分出大小为 $t$ 的连通块。而且，如果子树大小 $\ge t$，那么我们一定不能不选，因为如果不选，根节点所在的连通块大小至少为 $t+1$，也不符合题意。这样，我们可以按照子树大小与 $t$ 的关系，唯一确定下来子树的选取方案，然后判断一下形成的连通块大小是否等于 $t$ 即可。这样就能优化到单次 $O(n)$ 了。

$k=1$ 的情况同样可以类似的考虑，我们发现，子树大小 $<t$ 时同样一定不选，子树大小 $>t$ 时同样一定选，而对于 $=t$ 的情况，我们可以有一个不选，这样根节点所在连通块大小为 $t+1$，同样符合限制。那么，我们就可以枚举哪个 $=t$ 的子树不选，然后计算答案即可，这样复杂度也是 $O(n)$ 的，总复杂度就是 $O(n \sqrt{n})$ 的了。

据说这个做法卡卡常可以过，但是我自己卡了一上午，仍然只能做到最大的点本机跑 0.8s，luogu 上 TLE。我还是比较菜。

上述做法感觉上其实很多节点都不存在合法的划分方案。我们考虑不枚举连通块大小分别跑 DP，而是对每个连通块大小一起跑 DP。分析上述算法过程，我们发现，每次选取的子树都是一个后缀（中间可能删去一个树）。那么我们可以先枚举选取的这个后缀，然后计算其对应的连通块大小，只对这些连通块大小进行 DP。由于前缀的个数是 $O(deg)$ 的，这样每个圆点的合法的连通块大小就只有 $O(deg)$ 种，总共的状态数其实就只有 $O(n)$ 个。对于方点来说，它的方案数等于所有子树的方案数的乘积，那么它的合法状态数也一定是小于等于所有子树中状态数的最小值，所以方点的状态数也是 $O(n)$ 的。于是这样跑 DP 就能 $O(n)$ 得出答案了。细节很多，我写了好久才写出来，我好菜。

视实现而定，可做到 $O(n \log n)$ 或 $O(n)$ 的复杂度。我写的 $O(n \log n)$，复杂度瓶颈在给子树排序。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 200005, P = 998244353;
int n, m, k;
int ans[MAXN][2];
set<int> s;
unordered_map<int, int> f[MAXN][2], fsuf[MAXN];
struct Tree {
    vector<int> e[MAXN], re[MAXN];
    int tot;
    void add(int u, int v) {
        e[u].push_back(v), e[v].push_back(u);
    }
    int siz[MAXN];
    int to[MAXN];
    void dfs(int u, int pre) {
        siz[u] = u <= n;
        for (int v : e[u]) if (v != pre) {
            dfs(v, u);
            siz[u] += siz[v];
        }
        sort(e[u].begin(), e[u].end(), [&](int a, int b) { return siz[a] < siz[b]; });
        int deg = 0;
        for (int v : e[u]) if (v != pre) {
            deg++;
            to[deg] = v;
        }
        if (u <= n) {
            { // k = 0
                for (int i = 1; i <= deg; i++) 
                    fsuf[i].clear();
                for (int i = deg; i >= 1; i--) {
                    int v = to[i];
                    if (i == deg) fsuf[i] = f[v][0];
                    else for (auto p : f[v][0]) {
                        int t = p.first, w = p.second;
                        fsuf[i][t] = 1ll * fsuf[i + 1][t] * w % P;
                    }
                }
                int sz = 1, up = n - siz[u];
                for (int i = 1; i <= deg; i++) {
                    if (siz[to[i]] >= sz) {
                        if (s.count(sz)) f[u][0][sz] = (f[u][0][sz] + fsuf[i][sz]) % P;
                        if (s.count(sz + up)) ans[sz + up][0] = (ans[sz + up][0] + fsuf[i][sz + up]) % P;
                    }
                    sz += siz[to[i]];
                }
                if (s.count(sz)) f[u][0][sz] = (f[u][0][sz] + 1) % P;
                if (s.count(sz + up)) ans[sz + up][0] = (ans[sz + up][0] + 1) % P;
            }
            { // k = 1
                for (int i = 1; i <= deg; i++) 
                    fsuf[i].clear();
                for (int i = deg; i >= 1; i--) {
                    int v = to[i];
                    if (i == deg) fsuf[i] = f[v][1];
                    else for (auto p : f[v][1]) {
                        int t = p.first, w = p.second;
                        fsuf[i][t] = 1ll * fsuf[i + 1][t] * w % P;
                    }
                }
                int sz = 1, up = n - siz[u];
                for (int i = 1; i <= deg; i++) {
                    if (siz[to[i]] >= sz) {
                        if (s.count(sz)) f[u][1][sz] = (f[u][1][sz] + fsuf[i][sz]) % P;
                    }
                    if (siz[to[i]] >= sz + up) {
                        if (s.count(sz + up)) {
                            ans[sz + up][1] = (ans[sz + up][1] + fsuf[i][sz + up]) % P;
                        }
                    }
                    if (sz - 1 > 0 && siz[to[i - 1]] < sz - 1 && siz[to[i]] >= sz - 1) {
                        if (s.count(sz - 1)) f[u][1][sz - 1] = (f[u][1][sz - 1] + fsuf[i][sz - 1]) % P;
                    }
                    if (sz + up - 1 > 0 && siz[to[i - 1]] < sz + up - 1 && siz[to[i]] >= sz + up - 1) {
                        if (s.count(sz + up - 1)) {
                            ans[sz + up - 1][1] = (ans[sz + up - 1][1] + fsuf[i][sz + up - 1]) % P;
                        }
                    }
                    sz += siz[to[i]];
                }
                if (s.count(sz)) f[u][1][sz] = (f[u][1][sz] + 1) % P;
                if (deg && siz[to[deg]] < sz - 1) {
                    if (s.count(sz - 1)) f[u][1][sz - 1] = (f[u][1][sz - 1] + 1) % P;
                }
                if (deg && siz[to[deg]] < sz + up - 1) {
                    if (s.count(sz + up - 1)) ans[sz + up - 1][1] = (ans[sz + up - 1][1] + 1) % P;
                }
                if (deg) {
                    int kk = 0, prod = 1;
                    int lst = 0;
                    sz = siz[to[1]];
                    for (int i = 1; i <= deg; i++) {
                        int v = to[i];
                        if (siz[v] != sz) {
                            lst = i;
                            break;
                        }
                        kk = (prod + 1ll * kk * f[v][1][sz]) % P;
                        prod = 1ll * prod * f[v][1][sz] % P;
                    }
                    if (lst) kk = 1ll * kk * fsuf[lst][sz] % P;
                    if (s.count(sz)) f[u][1][sz] = (f[u][1][sz] + kk) % P;
                    if (u == 1 && s.count(sz)) {
                        ans[sz][1] = (ans[sz][1] + kk) % P;
                    }
                }
            }
        } else {
            int vv = 0;
            for (int v : e[u]) if (v != pre) {
                vv = v;
                break;
            }
            if (!vv) {
                for (int t : s) f[u][0][t] = f[u][1][t] = 1;
            } else {
                for (int k = 0; k <= 1; k++) {
                    for (auto p : f[vv][k]) {
                        int t = p.first;
                        f[u][k][t] = 1;
                        for (int v : e[u]) if (v != pre) {
                            f[u][k][t] = 1ll * f[u][k][t] * f[v][k][t] % P;
                        }
                    }
                }
            }
        }
    }
} t;
struct Graph {
    vector<int> e[MAXN];
    void add(int u, int v) {
        e[u].push_back(v), e[v].push_back(u);
    }
    int low[MAXN], dfn[MAXN], dcnt;
    stack<int> s;
    void tarjan(int u) {
        low[u] = dfn[u] = ++dcnt;
        s.push(u);
        for (int v : e[u]) if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
            if (low[v] >= dfn[u]) {
                int id = ++t.tot;
                while (1) {
                    int w = s.top(); s.pop();
                    t.add(id, w);
                    if (w == v) break;
                }
                t.add(id, u);
            }
        } else {
            low[u] = min(low[u], dfn[v]);
        }
    }
} g;
int main() {
    // freopen("cities.in", "r", stdin);
    // freopen("cities.out", "w", stdout);
    scanf("%d%d%d", &n, &m, &k);
    for (int i = 1; i <= m; i++) {
        int u, v; scanf("%d%d", &u, &v);
        g.add(u, v);
    }
    t.tot = n;
    g.tarjan(1);
    for (int i = 2; i <= n; i++) 
        s.insert(n / i);
    t.dfs(1, 0);
    int fans = 0;
    if (k == 0) {
        for (int i : s) if (n % i == 0) {
            fans = (fans + ans[i][0]) % P;
        }
    } else {
        for (int i : s) {
            fans = (fans + ans[i][1]) % P;
        }
        for (int i : s) if (s.count(i - 1)) {
            fans = (fans - ans[i][0] + P) % P;
        }
    }
    printf("%d\n", fans);
    return 0;
}
```

---

## 作者：henryhu2006 (赞：10)

本文的做法比较不同。

## 圆方树转化

对于任意一个点双联通分量，在其中切断一条边，它依然联通。要将一个点双联通分量分离到两个联通块中，那必然存在第二条边被切断。

题目要求关键点的数量和连通块的数量一致，因此每个连通块有且仅有一个关键点。

两条边如果只涉及三个点，那么必然共点，无法把点双切成两半。两条边涉及四个点，两个连通块就各有两个关键点，于是还要继续切开。

以此类推，此过程会直到碎成单点为止。于是，**任何一个点双如果被切，那么一定会完全分解成单点**。这里的单点指的是对于点双的单点，单点可以连接其它点双。

常用处理点双的办法是圆方树。上述结论等价于将圆方树切开，且只能删方点，要求所有联通块的圆点数的差 $\le k$。

## 子树选择策略
**当 $k=0$ 时**，考虑一个圆点的子树，假设其父节点（方点）被割。设连通块的大小为 $j$，当前节点为 $u$，那么所有大小 $<j$ 的子树不能割，必须和 $u$ 点联通；而大小 $\ge j$ 的子树必须割。

**当 $k=1$ 时**，假设连通块大小为 $j$ 或 $j+1$，那么 $<j$ 的还是不能割，$\ge j+1$ 还是必须割。对于 $=j$ 的，如果 $j=1$，那么**可以**全部割掉（不是必须）。对于任意 $j$（包括 $j=1$），如果不存在 $<j$ 的子树，那么要选择众多大小为 $j$ 中的一个连接，其它全部割掉。贡献可以使用后缀、前缀积维护。

于是答案不为 $0$ 的 $j$ 必然是子树从小到大排序后的前缀和 $+1$ 或 $+2$（针对 $k=1$），且总体来讲**选择一个前缀**。

在方点的状态认为，此方点要割掉，因此直接将来自子树的贡献按下标相乘。

## 根
上面的子树选择策略默认了父节点的方点被割。但是对于根，没有父节点，不能保证根是一个关键点。

猜测存在一个点在所有方案中附近的方点（或自己）会被割，猜测这个点是重心。

- 如果重心是圆点，显然它不是叶节点，连接的方点数 $\ge 2$，那么如果它不是关键点，即周围不存在任何一个方点被割，则它所在的连通块的边缘一定存在 $\ge 2$ 个关键点（因为它是重心，所以如果只有一个关键点，一定不满足 $k\le 1$），与个连通块一个关键点矛盾。

- 如果重心是方点，且没有被割，其周围的圆点全部属于同一连通块，显然说明其关键点的数量 $\ge 2$（理由同上），矛盾。

当然，对于重心是方点的情况，其周围所有的圆点都是关键点，可以任取一个作为根。

## 普遍做法
根据子树选择策略直接 DP，可以使用哈希表来存 DP 数组。在子树选择策略中说明了 $j$ 的取值数量是 $\le$ 边数的。直接做是 $\mathcal O(n\log n)$ 的。可以使用桶排优化子树大小排序，即可做到 $\mathcal O(n)$，但实现细节较为繁琐，具体可参考其它题解。

**注意** $k=0$ 的答案也会算入 $k=1$，除了 $j=1$ 以外的值都多算了一遍，需要减掉。

## 直接暴力
在写后面的做法之前，我直接枚举了所有的 $j$ 值，然后从根往下直接 DFS 查询答案，对于中间的不合法状态直接返回进行剪枝。显然这个算法的复杂度的极其错误的，但它过了官方数据，[评测记录](https://loj.ac/s/1810138)。最慢点跑了 $700$ 毫秒，但究竟是没卡掉。

但对这个暴力的枚举顺序进行一些修改就能得到正确的复杂度。我们先按子树大小排序，然后从后往前枚举，直到找到第一个 $<j$ 的子树，显然 $<j$ 子树的大小之和是好算的。对于后面的部分，维护方式不变。

这看起来依然很暴力。但是我们不会访问 $sz<j$ 的子树。考虑最深的那些大小 $\ge j$ 的子树最多有 $\mathcal O(n/j)$ 个。所以直接调和级数，复杂度为 $\mathcal O(n\log n)$。

## $j$ 有多少种取值
我们用根中的结论，设根为一个圆点。设其带权子树大小的前缀和为 $s$，子树大小为 $a$，那么 $s_i=s_{i-1}+a_i$，因为要计入 $u$，所以 $s_0=1$。

注意到 $j=s_i$ 时，$a_{i+1}\ge j-k$，否则它应当算到 $j$ 里面。于是 $s_{i+1}\ge 2s_i -1$ 恒成立。$s_1\ge s_0+1=2$，所以合法 $s_i$ 的下界会以 $2,3,5,9,17,33,\cdots,2^p+1$ 形式递增。**所以合法的 $j$ 取值只有 $\mathcal O(\log n)$ 种**。

所以直接调用上面的 DFS，将根的子树大小排序，从小到大扫一遍所有合法的 $j$ 即可。时间复杂度 $\mathcal O(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5,mod=998244353;
int n,m,k,cnt,ans,rt,sz[N*2]; bool vis[N];
int dfn[N],low[N],st[N],top,dfncl;
vector<int> e[N],t[N*2];
void tarjan(int u){
	dfn[u]=low[u]=++dfncl,st[++top]=u;
	for(int v:e[u])
		if(!dfn[v]){
			tarjan(v),low[u]=min(low[u],low[v]);
			if(low[v]==dfn[u]){
				t[++cnt].push_back(u),t[u].push_back(cnt);
				for(int x=0;x!=v;--top)
					t[x=st[top]].push_back(cnt),t[cnt].push_back(x);
			}
		}
		else low[u]=min(low[u],dfn[v]);
}
void dfs(int u,int fa){
	sz[u]=(u<=n); int mx=0;
	for(int v:t[u]) if(v!=fa) dfs(v,u),sz[u]+=sz[v],mx=max(mx,sz[v]);
	mx=max(mx,n-sz[u]);
	if(mx*2<=n) rt=u;
}
void getsz(int u,int fa){
	sz[u]=(u<=n);
	for(int v:t[u]) if(v!=fa) getsz(v,u),sz[u]+=sz[v];
}
int cal(int u,int fa,int d,bool K){
	int res=1,siz=1,num=1;
	if(u>n){
		for(int v:t[u])
			if(v!=fa) res=1ll*res*cal(v,u,d,K)%mod;
		return res;
	}
	for(int v:t[u]) if(v!=fa) siz+=(sz[v]<d)*sz[v];
	if(siz>d+K) return 0;
	for(int v:t[u])
		if(v!=fa&&sz[v]>=d+K) res=1ll*res*cal(v,u,d,K)%mod;
	if(!res) return 0;
	if(K&&siz==1){
		vector<int> g,s;
		for(int v:t[u])
			if(v!=fa&&sz[v]==d) g.push_back(cal(v,u,d,K));
		if(g.size()){
			s=g,s.push_back(1); int now=1;
			for(int i=s.size()-2;~i;--i) s[i]=1ll*s[i+1]*s[i]%mod; num=s[0]*(d==1);
			for(int i=0;i<g.size();++i){
				num=(num+1ll*now*s[i+1])%mod;
				now=1ll*now*g[i]%mod;
			}
			siz+=d;
		}
	}
	if(siz!=d&&siz!=d+K) return 0;
	return 1ll*res*num%mod;
}
int main(){
	ios::sync_with_stdio(0);
	cin>>n>>m>>k,cnt=n;
	for(int i=1,u,v;i<=m;++i)
		cin>>u>>v,e[u].push_back(v),e[v].push_back(u);
	tarjan(1),dfs(1,0); if(rt>n) rt=t[rt][0];
	top=0,getsz(rt,0);
	for(int v:t[rt]) st[++top]=sz[v];
	sort(st+1,st+top+1);
	for(int i=1,sm=(rt<=n);i<top;++i)
		if((sm+=st[i])<=st[i+1]) ans=(ans+cal(rt,0,sm,0))%mod;
	if(k==0){cout<<ans+1; return 0;}
	ans=(mod-ans)%mod;
	ans=(ans+cal(rt,0,1,1)),vis[1]=1;
	for(int i=1,sm=1;i<top;++i)
		if((sm+=st[i])<=st[i+1]+1){
			if(!vis[sm]) ans=(ans+cal(rt,0,sm,1))%mod,vis[sm]=1;
			if(!vis[sm-1]) ans=(ans+cal(rt,0,sm-1,1))%mod,vis[sm-1]=1;
		}
	cout<<ans;
	return 0;
}
```
这样我们就规避了哈希表大常数数据结构。

这种算法也可以继续优化到 $\mathcal O(n)$，可以沿用上面的做法：

$$
\sum_i \dfrac{n}{2^i+1} \approx \mathcal O(n)
$$

现在瓶颈在于子树大小排序。但桶排有强行优化的违和感。本题本质上并不需要对子树大小进行完整的排序，只要揪出在两个合法 $j$ 之间内的子树大小即可。于是我们每次访问到一个子树时，将 $<j$ 的子树查完以后去除，直接暴力重构。没有被删掉的子树同上面的复杂度分析，为 $\mathcal O(n)$；每个子树最多只会删两次，复杂度也为 $\mathcal O(n)$。于是这样复杂度也是线性的。



---

## 作者：Schi2oid (赞：7)

### 题意简述

给定一张无向图，要求选出一个边集，使得去除其中的边后，原图划分为 $t$ 个连通块，连通块大小差距不超过 $k(0\le k\le 1)$，且边集涉及到的点的个数恰为 $t$，计数选出的边集方案数。

### 思路分析

无特殊性质无向图，考虑圆方树分析。对于一个点双，假设其中存在一部分点属于同一个连通块，考虑剩下的点，一定存在一条路径连向点集中的某个点。将该点删去，由于点双性质，又能找到另一条路径连向点集中的某个点。故这一连通块中有两个点向外部连边，不符合题意。所以同一个点双，要么属于同一个连通块，要么每个点所属连通块互不相同。

保留点双中点属于同一个连通块的方点。所属连通块互不相同等价于在圆方树中删去该方点。

容易发现，删去的方点应该是一个连通块，不然会出现一个连通块有两个点向外部连边的情况。同时，发现这一连通块（方点及方点周围的圆点）一定包含重心。因为否则一定存在一个连通分量比其他至少大 $2$。

那么，以重心为根考虑 dp。下文所有 $size$ 表示子树内圆点个数。

### $k=0$

钦定所有连通块大小都为 $S$。

设 $f_{u}$ 表示选择删去的方点连通块以 $u$ 为根的合法方案数（根为方点至少删一个，根为圆点可以不删）。有转移：

- $u$ 是方点时：

  - $f_u\leftarrow \prod{f_v}$。
  
- $u$ 是圆点时：

  - $1+\sum_{size_v<S} size_{v}=S$：$f_u\leftarrow f_u+\prod_{size_v\ge S}{f_v}$。

由于 $S$ 只能为 $n$ 的约数，本部分复杂度 $O(nd(n))$。

### $k=1$

钦定所有连通块大小都为 $[S,S+1]$。

设 $f_{u}$ 表示选择删去的方点连通块以 $u$ 为根的合法方案数（根为方点至少删一个，根为圆点可以不删）。有转移：

- $u$ 是方点时：

  - $f_u\leftarrow \prod{f_v}$。
  
- $u$ 是圆点时：

  - 若 $size_v<S$，则 $v$ 一定不删。
  
  - 若 $size_v>S$，则 $v$ 一定删去。
  
  - 可以保留至多一个 $size_v=S$ 不删，且必须满足 $\sum_{size_v<S} size_v=0$。此时其与根一同合成一个大小为 $S+1$ 的连通块。注意到此时剩下的所有 $v$ 一定都要删去，故若存在多于一个 $size_v=S,f_v=0$ 的点，则无法保留 $size_v=S$ 的点；若存在一个，则只能保留这个点；若不存在，则保留任意一个都可以。设 $cnt1$ 为 $size_v=S$ 的个数，$cnt2$ 为 $size_v=S,f_v=0$ 的个数：
  
  - $\sum_{size_v<S} size_v=0,cnt2=1$（保留一个 $size_v=S$）：$f_u\leftarrow f_u+\prod_{size_v>S}$；
  
  - $\sum_{size_v<S} size_v=0,cnt2=0$（保留一个 $size_v=S$）：$f_u\leftarrow f_u+\prod_{size_v>S}\times cnt1$；
  
  - $1+\sum_{size_v<S}size_v=S$ 或 $S+1$（不保留）：$f_u\leftarrow f_u+\prod_{size_v\ge S}f_v$。

关于为什么上述两种 dp 都需要带一个看似奇怪的删不删的规定，可以尝试设 $f_{u,0/1}$ 表示一定删或不一定删，容易发现只有上述规定中的状态在后续转移中是有用的。

关于时间复杂度，有 $tS\le n\le t(S+1)$，即 $\frac{n}{t}-1\le S\le \frac{n}{t}$，对于给定的 $t$，$S$ 最多两个取值，故本部分时间复杂度为 $O(n\sqrt n)$。

注意若全局所有连通块大小都恰为 $S_0$，且 $S_0,S_0-1$ 都是合法的 $S$ 取值，则会在 $k=1$ 时被计算两遍。故再跑一遍 $k=0,S=S_0$ 的情况减掉即可。

总时间复杂度为 $O(n\sqrt n)$。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
vector<int>edge[100005];
vector<int>T[200005];
int dfn[100005],low[100005];
int sz[200005];
bool vis[200005];
int f[200005];
stack<int>stk;
int dcnt=0,bcnt=0;
int n,m;
int ans=0;
int rt=0;
void Tarjan(int x){
	low[x]=dfn[x]=++dcnt;
	stk.push(x);
	for(int i=0;i<edge[x].size();i++){
		int v=edge[x][i];
		if(!dfn[v]){
			Tarjan(v);
			low[x]=min(low[x],low[v]);
			if(low[v]==dfn[x]){
				bcnt++;
				while(!stk.empty()){
					int tp=stk.top();
					stk.pop();
					T[bcnt].push_back(tp);
					T[tp].push_back(bcnt);
					if(tp==v) break;
				}
				T[bcnt].push_back(x);
				T[x].push_back(bcnt);
			}
		}
		else low[x]=min(low[x],dfn[v]);
	}
}
void get_rt(int x,int f){
	if(x<=n) sz[x]=1;
	int ok=1;
	for(int i=0;i<T[x].size();i++){
		int v=T[x][i];
		if(v==f) continue;
		get_rt(v,x);
		sz[x]+=sz[v];
		if(sz[v]>n/2) ok=0;
	}
	if(n-sz[x]>n/2) ok=0;
	if(ok) rt=x;
}
void get_sz(int x,int f){
	sz[x]=0;
	if(x<=n) sz[x]=1;
	for(int i=0;i<T[x].size();i++){
		int v=T[x][i];
		if(v==f) continue;
		get_sz(v,x);
		sz[x]+=sz[v];
	}
}
int solve(int x,int fa,int k,int S){
	f[x]=0;
	if(sz[x]<S) return 0;
	if(k==0){
		if(x>n){
			int prod=1;
			for(int i=0;i<T[x].size();i++){
				int v=T[x][i];
				if(v==fa) continue;
				solve(v,x,k,S);
				prod=prod*f[v]%mod;
			}
			f[x]=(f[x]+prod)%mod;
		}
		else{
			int sum=0,prod=1;
			for(int i=0;i<T[x].size();i++){
				int v=T[x][i];
				if(v==fa) continue;
				solve(v,x,k,S);
				if(sz[v]<S) sum+=sz[v];
				else prod=prod*f[v]%mod;
			}
			if(sum+1==S) f[x]=prod;
		}
	}
	else{
		if(x>n){
			int prod=1;
			for(int i=0;i<T[x].size();i++){
				int v=T[x][i];
				if(v==fa) continue;
				solve(v,x,k,S);
				prod=prod*f[v]%mod;
			}
			f[x]=(f[x]+prod)%mod;
		}
		else{
			int sum=0,prod1=1,prod2=1,cnt1=0,cnt2=0;
			for(int i=0;i<T[x].size();i++){
				int v=T[x][i];
				if(v==fa) continue;
				solve(v,x,k,S);
				if(sz[v]<S) sum+=sz[v];
				else if(sz[v]>S) prod1=prod1*f[v]%mod;
				else{
					cnt1++;
					if(!f[v]) cnt2++;
					prod2=prod2*f[v]%mod;
				}
			}
			if(sum==0&&cnt2==1) f[x]=(f[x]+prod1)%mod;
			if(sum==0&&cnt2==0) f[x]=(f[x]+prod1*cnt1)%mod;
			if(1+sum==S||1+sum==S+1) f[x]=(f[x]+prod1*prod2)%mod;
		}
	}
	return f[x];
}
void clear(){for(int i=1;i<=n;i++) f[i]=0;}
signed main(){
	int u,v,k;
	cin>>n>>m>>k;
	bcnt=n;
	for(int i=1;i<=m;i++){
		scanf("%lld%lld",&u,&v);
		edge[u].push_back(v);
		edge[v].push_back(u);
	}
	Tarjan(1);
	get_rt(1,0);
	get_sz(rt,0);
	if(k==0){
		int ans=0;
		int sq=sqrt(n);
		ans+=solve(rt,0,0,1);
		for(int i=2;i<=sq;i++) if(n%i==0) ans=(ans+solve(rt,0,0,i)+solve(rt,0,0,n/i))%mod;
		if(sq*sq==n) ans=(ans-solve(rt,0,0,sq)+mod)%mod;
		cout<<ans<<endl;
	}
	else{
		for(int i=2;i<=n;i++){
			if(n%i==0) vis[n/i]=1,vis[n/i-1]=1;
			else vis[n/i]=1;
		}
		int ans=0;
		for(int i=1;i<=n;i++) if(vis[i]) ans=(ans+solve(rt,0,1,i))%mod;
		for(int i=1;i<n;i++) if(vis[i]&&vis[i+1]) ans=(ans-solve(rt,0,0,i+1)+mod)%mod; 
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：SoyTony (赞：5)

# D1T2 城市建造 cities

一个连通块中只能有一个点被选中。

由于连通块大小是 $\left\lfloor n/cnt\right\rfloor$ 和 $\left\lceil n/cnt\right\rceil$，只有 $O(\sqrt{n})$ 种，可以枚举连通块大小。

考虑树上怎么做，假设当前枚举的连通块大小 $siz$，可能的连通块个数 $cnt$，那么有 $cnt$ 个节点被选中，且断边后断成了 $cnt$ 个连通块，也就是 $cnt$ 个节点有 $cnt-1$ 条边，因此合法方案实际上是一棵树（这个性质在考场上认为是菊花或是链之类的，没拿到部分分）。

考虑一个树形 DP，设 $f_v$ 为 $v$ 与父亲的连边被断开，即 $v$ 子树内部划分成大小为 $siz$ 或 $siz+1$ 的连通块的方案数。

一棵树的性质同样揭示了另一个事实：如果 $v$ 与父亲的连边不断开，那么 $v$ 一定是整体并入其父亲所在连通块的，也就只和子树大小 $siz_v$ 有关了。

这样对于 $u$ 的儿子 $v$，不同的 $siz_v$ 直接对应不同的处理方式：

- $siz_v>siz$，不可能与 $u$ 在同一连通块，$(u,v)$ 必须断开。

- $siz_v=siz$，既可能与 $u$ 在同一连通块，也可能单独成连通块。

- $siz_v<siz$，一定与 $u$ 在同一连通块。

这样我们只需要统计第一种情况是否内部划分都合法，第三种情况之和与 $u$ 拼在一起是否合法，同时将的第一种情况的方案数累成即为答案。还有一同时情况为：不存在小于 $siz$ 的，此时若 $siz=1$ 或存在等于 $siz$ 的子树 $v$ 才合法，且方案数乘上满足条件的 $v$ 的个数（如果 $u$ 单独成块也合法也要计入）。

这样在每个节点统计答案，默认其父亲及其他子树都不断开。

---

放到图上，由于删去选中节点的全部连边后不连通，容易想到点双连通分量，这样一个点双内如果选取超过一个且有没有选取的，无法达到不连通的条件。因此一个点双要么全不选，要么全选，要么选一个。反映到圆方树上就是选取点击构成的树，叶子节点一定全是圆点。

根据这个性质同样可以讨论圆点方点后 DP，$f_u$ 定义相同。

对于圆点，和上面树的情况讨论是一致的；对于方点，如果断开了其与父亲的连边，那么意味着其与儿子连边要么不断开要么全部断开，因此在对方点 DP 时，只需要考虑全部断开是否合法即可。

要注意的是，图上和树上不同之处在于即便 $siz_v=siz$，断开 $(u,v)$ 后不一点合法，因为这代表着 $v$ 对应所有圆点连边都将断开，而不是像树上作为一个整体。

这样大致就是全部算法流程，还存在的问题是枚举到 $\left\lfloor n/cnt\right\rfloor$ 时有可能存在方案至划分成了大小为 $\left\lceil n/cnt\right\rceil$ 的连通块，这样会算重。可以容斥，减去 $\left\lceil n/cnt\right\rceil$ 对应 $k=0$ 的情况。

--- 

由于复杂度一定拉满，需要大面积卡常：

- 只在重心位置统计答案，重心一定会被选中，否则被选中的部分是其一个子树，大小不超过一半，也就和其余部分大小相差 $1$ 以上。

- DFS 时按照 DFS 序重标号，$O(\sqrt{n})$ 次 DFS 使用非递归 DFS。

- 使用邻接表而不是 `vector`。

- 如果存在大小大于 $siz$ 的子树内部不合法或是大小小于 $siz$ 的子树大小之和超过了 $siz$，一定没有合法方案，可以不再枚举子树。

- 如果 $siz_u<siz$，一定没有合法方案，这一处能带来极大的优化。

---

## 作者：MuelsyseU (赞：2)

1. 在原图上删边，最后若满足条件，当且仅当连通块大小满足条件且每个连通块各出恰好一个节点有删边。由此推论：任意一条被删边的两个端点最后不连通。

2. 进一步得到，一个点双（因为由其定义，除了只有一条边之外，都满足任意两点之间至少有两条不在点处相交的路径）内所有边要么同时删除要么同时不删除。

3. 以上构成了一个方案合法的充要条件。

---

圆方树，方点点权为 $0$。如果能找到一个点周围的边必须删，以其为根这个问题就很简单。可以证明重心是这样的点。

> 断言：若 $k = 0$，直接随便删掉它到重儿子的边就是可行的。

因为若这条边不删，那么至少就有一个 $siz_{son_x} + 1$ 的大小，而他是重心，所以得到 $n - siz_{son_x} \le siz_{son_x} < siz_{son_x} + 1$。那么其他部分不可能和这个相等。

由于删的边必须联通，所以每次只需要考虑新出现的连通块的根。把连通块按照重儿子大小排序，这样不断切割，并维护是否全部相等，显然等价于最大值等于最小值。注意每次删边要删掉这条边上的方点的所有边。这种情况方案数显然很小。

若 $k = 1$，沿用先前，发现这时候多出一种情况，把根和重子树划分在一起，再删掉一些边使得这些子树相等。那么那些子树的大小必须等于重子树，于是所有子树必须都相等。首先一开始钦定当前的根不为方点（可能方点是重心，但是这样的话第一下就删除了所以无所谓），所以进而要求：

1. 如果每个儿子都只有一个儿子（即每个方点对应点双大小为 $2$）就随便保留一个儿子其它全部删除。

2. 否则随便删除一个，没有其它区别。

> 理解：首先切出来的所有连通块在被切分前 $siz$ 的分布是一致的；保留后，肯定恰好有一个连通块是根为圆点，只有一个方点作为儿子。它肯定比切出的其它连通块先处理，最终得到的情形都是一样的。

这时为了避免儿子全部被删完的细节，考虑对于最小连通块大小为 $1$ 的情况特判处理。

另外一个细节是，在 $k=1$ 时，若最大儿子存在多个，应该对删除后形成的最小连通块最大的优先删除。

用桶记录连通块大小，复杂度就是 $O(n+m)$。

这份代码写成 Shift Mountain 了。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 400005, mod = 998244353;
long long ans, tmp = 1;
int n0, n, m, k;
vector<int> e[maxn];
void add(int x, int y) {
	e[x].push_back(y), e[y].push_back(x);
}
// Original
int tot = 1, hd[maxn];
namespace Org {
	struct Edg {
		int y, nxt;
	} e[maxn * 2];
	int id, dfn[maxn], low[maxn], b[maxn], num;
	int stk[maxn], top;
	void tarjan(int x) {
		low[x] = dfn[x] = ++num, stk[++top] = x;
		for (int i = hd[x]; i; i = e[i].nxt) {
			int y = e[i].y;
			if (dfn[y]) low[x] = min(low[x], dfn[y]);
			else {
				tarjan(y), low[x] = min(low[x], low[y]);
				if (low[y] == dfn[x]) {
					++id, add(id, x);
					for (int z = 0; z != y; --top)
						z = stk[top], add(id, z);
				}
			}
		}
	}
	void solve() {
		id = n0;
		for (int x = 1; x <= n0; ++x)
			if (!dfn[x]) tarjan(x), --top;
		n = id;
//		for (int x = 1; x <= n; ++x)
//			for (int y : ::e[x])
//				printf("%d %d\n", x, y);
	}
}
// New
int rt, ms[maxn], siz[maxn], f[maxn];
void init(int x, int fa) {
	siz[x] = (x <= n0);
	for (int y : e[x])
		if (y != fa) init(y, x), siz[x] += siz[y], ms[x] = max(ms[x], siz[y]);
	ms[x] = max(ms[x], n0 - siz[x]);
	if (x <= n0 && ms[rt] > ms[x]) rt = x;
}
void dfs(int x, int fa) {
	f[x] = fa, siz[x] = (x <= n0), ms[x] = n + 1;
	for (int y : e[x])
		if (y != fa) dfs(y, x), ms[x] = min(ms[x], siz[y]), siz[x] += siz[y];
}
vector<int> q[maxn];
int mx, mi, b[maxn];
void insert(int x) {
	assert(x > n0), b[x] = 1;
	assert(f[x]), siz[f[x]] -= siz[x];
	for (int y : e[x])
		if (y != f[x]) q[siz[y]].push_back(y), mi = min(mi, siz[y]);//, cout << y << " " << siz[y] << endl;
}
// 暴力
//namespace Patch {
//	int ans;
//	int b[maxn], t, siz, mx, mi;
//	void dfs(int x) {
//		b[x] = 1, siz += (x <= n0);
//		for (int y : e[x])
//			if (!b[y] && (y <= n0 || !(t & (1 << (y - n0 - 1))))) dfs(y);
//	}
//	void check(int x) {
//		b[x] = 1;
//		for (int y : e[x])
//			if (!b[y] && (y <= n0 || (t & (1 << (y - n0 - 1))))) check(y);
//	}
//	int solve() {
//		if (n - n0 > 20) return 0;
//		int lim = (1 << (n - n0));
//		for (t = 1; t < lim; ++t) {
//			mi = 0x3f3f3f3f, mx = 0, tmp = 0;
//			for (int i = 1; i <= n; ++i) b[i] = 0;
//			for (int i = n0 + 1; i <= n; ++i)
//				if ((t & (1 << (i - n0 - 1))) && !b[i]) ++tmp, check(i);
//			if (tmp > 1) continue;
//			for (int i = 1; i <= n; ++i) b[i] = 0;
//			for (int i = 1; i <= n0; ++i)
//				if (!b[i]) siz = 0, dfs(i), mx = max(mx, siz), mi = min(mi, siz);
//			if ((mx - mi <= k)) ++ans; 
//			//for(int i = n0 + 1; i <= n; ++i) if (t & (1 << (i - n0 - 1))) cout << i << " "; cout << endl;
//		}
//		return ans;
//	}
//}
long long dp[maxn];
bool leaf[maxn];
void solve(int x, int fa) {
	b[x] = 1, dp[x] = 1;
	leaf[x] = e[x].size() == 1;
	int ct = 0;
	for (int y : e[x]) {
		if (b[y] || y == fa) continue;
		solve(y, x), leaf[x] |= (x > n0 && leaf[y] && e[x].size() <= 2);
		if (x > n0) (dp[x] *= dp[y]) %= mod;
		else if (leaf[y] == 1) assert(y > n0), ++ct;
		else assert(y > n0), dp[x] = dp[x] * dp[y] % mod;
	}
	dp[x] = dp[x] * (ct + 1) % mod;
	if (dp[x] < 1) exit(0);
}
signed main() {
	int x, y, z;
	scanf("%d%d%d", &n0, &m, &k);
	for (int i = 1; i <= m; ++i) {
		scanf("%d%d", &x, &y);
		Org::e[++tot] = {y, hd[x]}, hd[x] = tot;
		Org::e[++tot] = {x, hd[y]}, hd[y] = tot;
	}
	Org::solve(), ms[rt = 0] = n + 1, init(1, 0), dfs(rt, 0);
	q[siz[rt]].push_back(rt), mx = mi = siz[rt];
	while (mx > 1) {
		x = q[mx].back(), q[mx].pop_back();
		int sx = 0, si = 0, sn = 0, ns = 0;
		for (int y : e[x]) {
			if (b[y] || y == f[x]) continue;
			++sn, ns = max(ns, int(e[y].size()) - 1);
			if (!sx || siz[y] > siz[sx] || (siz[y] == siz[sx] && ms[sx] < ms[y])) sx = y;
			if (!si || siz[y] < siz[si]) si = y;
		}
		assert(x <= n && sx && si);
		if (k == 0 || sn == 1 || siz[sx] > siz[si] || ns > 1) {
			insert(sx);
			q[siz[x]].push_back(x), mi = min(mi, siz[x]);
		} else {
			assert(k == 1 && sn > 1 && siz[sx] == siz[si]);
			for (int y : e[x])
				if (!b[y] && y != f[x] && y != sx) insert(y);
			q[siz[x]].push_back(x), mi = min(mi, siz[x]);
			(tmp *= sn) %= mod;
		}
		if (mi <= 1) break;
		while (q[mx].empty() && mx > 1) --mx;
		if (mx - mi <= k) (ans += tmp) %= mod;
	}
	if (k == 0) {
		printf("%lld", (ans + 1) % mod);
		return 0;
	}
	memset(b, 0, sizeof(b));
	solve(rt, 0), ans += dp[rt] % mod;
	//	printf("%d\n", Patch::solve());
	printf("%lld", ans % mod);
	return 0;
}
```

---

## 作者：Leasier (赞：2)

赛时暴力写挂了，$k = 0$ 也没调出来。哈哈哈哈哈哈哈哈哈哈。

------------

看到无向图要求**点**不连通，考虑建出圆方树。

这道题最难的就是观察出下面两个性质了：

- **我们希望给所有方案找出一个确定的包含在其中的点。**

注意到所有选择的圆点在圆方树上一定构成一个**连通块**（要不然中间会断开），由于重心周围最大子树大小最小，则某个作为圆点的重心必选。

- **我们希望给方点找出其可能的方案。**

对于一个方点，如果它表示的点双中选择了两个点，则我们必须选择这个点双中的其他所有点——要不然这两个点一定可以通过其他边连通。

因此，对于一个方点，其表示的点双中要么一个点不选，要么只选一个点，要么全选。

------------

首先讨论 $k = 0$ 的情况。设连通块大小为 $d$。

- 对于一个圆点，其必须与所有子树大小 $< d$ 的方点在一起，再在其他方点内部选择。
- 对于一个方点，若其父亲被选且我们还需要在其中选，则其所有子树都需要分别被选。

dfs 判断即可。时间复杂度为 $O(n \tau(n))$。

------------

接下来讨论 $k = 1$ 的情况。设连通块大小为 $d$ 或 $d + 1$。

- 对于一个圆点，其必须与所有子树大小 $< d$ 的方点在一起，子树大小 $> d$ 的方点必须在内部选择。
- 而对于子树大小 $= d$ 的方点，我们有两种方案：若当前点无其他子树大小 $< d$ 的方点儿子，可以选择恰好一个跟圆点一起；也可以都独立在内部选择，让圆点与其他子树大小 $< d$ 的方点在一起。
- 方点同 $k = 0$。

树形 dp 即可。记得容斥掉在 $d, d + 1$ 处均算到的连通块大小全部相等的情况。时间复杂度为 $O(n \sqrt{n})$。

------------

代码：
```cpp
#include <iostream>
#include <stack>
#include <vector>

using namespace std;

typedef long long ll;

typedef struct {
	int nxt;
	int end;
} Edge;

typedef struct {
	int cnt = 0;
	int head[200007];
	Edge edge[400007];
	
	inline void add_edge(int start, int end){
		cnt++;
		edge[cnt].nxt = head[start];
		head[start] = cnt;
		edge[cnt].end = end;
	}
} Graph;

const int mod = 998244353;
Graph g1, g2;
int dfn[100007], low[100007], fa[200007], size[200007], max_size[200007];
bool vis[100007];
stack<int> s;

void tarjan(int u, int father, int n, int &id, int &bcc_cnt){
	int son_cnt = 0;
	dfn[u] = low[u] = ++id;
	vis[u] = true;
	s.push(u);
	for (register int i = g1.head[u]; i != 0; i = g1.edge[i].nxt){
		int x = g1.edge[i].end;
		if (!vis[x]){
			son_cnt++;
			tarjan(x, u, n, id, bcc_cnt);
			low[u] = min(low[u], low[x]);
			if (low[x] >= dfn[u]){
				int pos = n + ++bcc_cnt, cur;
				g2.add_edge(u, pos);
				g2.add_edge(pos, u);
				do {
					cur = s.top();
					s.pop();
					g2.add_edge(cur, pos);
					g2.add_edge(pos, cur);
				} while (cur != x);
			}
		} else {
			low[u] = min(low[u], dfn[x]);
		}
	}
	if (father == 0 && son_cnt == 0){
		int pos = n + ++bcc_cnt;
		g2.add_edge(u, pos);
		g2.add_edge(pos, u);
	}
}

void dfs1(int u, int father, int n){
	fa[u] = father;
	size[u] = u <= n ? 1 : 0;
	for (register int i = g2.head[u]; i != 0; i = g2.edge[i].nxt){
		int x = g2.edge[i].end;
		if (x != father){
			dfs1(x, u, n);
			size[u] += size[x];
			max_size[u] = max(max_size[u], size[x]);
		}
	}
	max_size[u] = max(max_size[u], n - size[u]);
}

bool dfs2(int u, int n, int k){
	if (size[u] < k) return false;
	if (u <= n){
		if (size[u] == k) return true;
		int sum = 1;
		for (register int i = g2.head[u]; i != 0; i = g2.edge[i].nxt){
			int x = g2.edge[i].end;
			if (x != fa[u]){
				if (size[x] < k){
					sum += size[x];
				} else if (!dfs2(x, n, k)){
					return false;
				}
			}
		}
		return sum == k;
	}
	for (register int i = g2.head[u]; i != 0; i = g2.edge[i].nxt){
		int x = g2.edge[i].end;
		if (x != fa[u] && !dfs2(x, n, k)) return false;
	}
	return true;
}

inline int solve0(int n, int root){
	int ans = 0;
	for (register int i = 1; i < n; i++){
		if (n % i == 0 && dfs2(root, n, i)) ans++;
	}
	return ans;
}

ll dfs3(int u, int n, int k){
	if (size[u] < k) return 0;
	ll ans;
	if (u <= n){
		int sum = 1, sz;
		ll mul1 = 1, mul2 = 1;
		vector<ll> v1;
		for (register int i = g2.head[u]; i != 0; i = g2.edge[i].nxt){
			int x = g2.edge[i].end;
			if (x != fa[u]){
				if (size[x] < k){
					sum += size[x];
				} else if (size[x] == k){
					ll t = dfs3(x, n, k);
					mul1 = mul1 * t % mod;
					v1.push_back(t);
				} else {
					mul2 = mul2 * dfs3(x, n, k) % mod;
				}
			}
		}
		sz = v1.size();
		ans = 0;
		if (sz > 0 && sum == 1){
			vector<ll> v2(sz), v3(sz);
			for (register int i = 0; i < sz; i++){
				v2[i] = v1[i];
				if (i > 0) v2[i] = v2[i] * v2[i - 1] % mod;
			}
			for (register int i = sz - 1; i >= 0; i--){
				v3[i] = v1[i];
				if (i + 1 < sz) v3[i] = v3[i] * v3[i + 1] % mod;
			}
			for (register int i = 0; i < sz; i++){
				ans = (ans + (i == 0 ? 1 : v2[i - 1]) * (i + 1 == sz ? 1 : v3[i + 1]) % mod) % mod;
			}
		}
		if (sum == k || sum == k + 1) ans = (ans + mul1) % mod;
		ans = ans * mul2 % mod;
	} else {
		ans = 1;
		for (register int i = g2.head[u]; i != 0; i = g2.edge[i].nxt){
			int x = g2.edge[i].end;
			if (x != fa[u]) ans = ans * dfs3(x, n, k) % mod;
		}
	}
	return ans;
}

inline ll solve1(int n, int root){
	ll ans = 0;
	for (register int i = 1; i * 2 <= n; i++){
		if (n % i <= n / i){
			int ii = i + 1;
			ans = (ans + dfs3(root, n, i)) % mod;
			if (n % ii == 0 && dfs2(root, n, ii)) ans = ((ans - 1) % mod + mod) % mod;
		}
	}
	return ans;
}

int main(){
	int n, m, k, id = 0, bcc_cnt = 0, root = 0;
	cin >> n >> m >> k;
	for (register int i = 1; i <= m; i++){
		int u, v;
		cin >> u >> v;
		g1.add_edge(u, v);
		g1.add_edge(v, u);
	}
	tarjan(1, 0, n, id, bcc_cnt);
	dfs1(1, 0, n);
	for (register int i = 1; i <= n; i++){
		if (root == 0 || max_size[root] > max_size[i]) root = i;
	}
	dfs1(root, 0, n);
	if (k == 0){
		cout << solve0(n, root);
	} else {
		cout << solve1(n, root);
	}
	return 0;
}
```

---

## 作者：eastcloud (赞：1)

[更好的阅读体验](https://www.cnblogs.com/eastcloud/p/17279237.html)

简单概括一下题目：询问有多少组边集，满足原图删去后分为若干个联通块，联通块大小的极差不超过 $k$，如果存在一条边 $(u,v)$，被删除了，称 $u$ 和 $v$ 为删除点（并没有删除，只是这么叫），图还得满足每个联通块只有一个删除点。

先考虑题目中的极差，对于 $k=0$ 的情况，连通块大小肯定是 $n$ 的因子，而 $k=1$ 时连通块的大小也只能是 $\lfloor \frac{n}{s} \rfloor$ 和 $\lceil \frac{n}{s} \rceil$ 的（$s$ 为 1 到 $n$ 之间任意一个整数），结合整除分块的相关知识可以知道所有可能的联通块大小只有不超过 $2\sqrt n$ 种，这复杂度加个线性还在我们的接受范围之内，继续考虑其他条件。

再先考虑有关删除点的条件，这个条件只与点有关，而且考虑边的话解的判断和求解不太好实现，于是试着把删除边转化为选择点，这里的选择指的是找到一些点放到一个联通块里。

类似 dp 中构造转移方程，考虑在已有点的情况下还需要和还可以加入哪些点，首先，我们发现如果存在两个点在已选择的点集内，且都有向外连的边，设其为 $(a,b)$ 和 $(c,d)$，那么 $c$ 与 $d$ 我们一定要选择一个点，否则就会导致删除点不只一个。

若 $c$ 与 $d$ 是同一个点怎么办呢？这等价于存在一个点有两条不同的到达选择的点集的路径（只用终点不同就行），可以看出这个点也必须选择。前面的表述是否有些熟悉？这与我们对点双连通分量的定义有些相似，把它套进去可以发现对于一个点双中的点，只要有两个被选到同一个联通块，其他点也必须选到那个联通块中。

点双和选择问题，自然的想到建出圆方树进行 dp 处理，我们设 $siz_u$ 表示子树 $u$ 的圆点个数，$f_u$ 表示子树 $u$ 能单独形成合法解（能被分成若干个满足上述条件的联通块）的合法解的数量，设计转移方程：

如果 $u$ 是圆点：

* $siz_v < siz_u$，此时肯定不能把 $v$ 单独割下来，使 $tot$ 变为 $tot+siz_v$。

* $siz_v = siz_u$，此时 $v$ 可以割也可以不割，考虑 $f_v$，如果 $f_v=0$，使 $tot$ 变为 $tot+siz_v$，否则使 $cnt$ 变为 $cnt+1$。

* $siz_v > siz_u$，此时必须割 $v$，使 $ned$ 变为 $ned \cdot siz_v$。

$tot$ 初值为 1，可以看到我们记录了很多变量，现在考虑统计答案，首先，如果 $d \leq tot \leq d+1$（$d$  为枚举出的联通块大小），那么 $f_i$ 加上 $ned$，若 $ tot > d $，肯定无解，剩下情况只有 $tot=1$ 时有可能有解，此时答案加上 $ned \cdot cnt$ 表示考虑 $cnt$ 种多余的割还是不割，最多只能不割一个，我们考虑不割哪个后剩下就只有 $ned$ 种情况，二者相乘就得到了结果，注意第二种点既可以合并也可以不合并，第一和第三种情况可以共存，而 $k=0$ 时同理。

对于方点，$f_u = \Pi_{v \in son(u)} f_v $，这个转移方程的意义在于只考虑把每个圆点各自分开的情况，不过可以发现全部合起来的情况会在其父亲圆点那里被考虑，因此不用进行处理。

最后，我们还差一个根节点没有确定，由于我们对于状态的特殊定义，根节点若是圆点，必须是对应联通块的删除节点，若是方点，子节点必须全部分割，可以发现重心刚好符合我们的要求，若其不是删除节点，那么该联通块要么有不止一个删除节点，要么对应联通块大小肯定大于 $\frac{n}{2}$，若是方点则同理。

由于常数较大，我们还需要加入一点剪枝，例如，当 $siz_u<d$ 时不进行处理，当 $siz_u>d$ 且 $f_u=0$ 时直接无解等，于是此题得到解决。

---


# [PA 2022] Płótno

## 题目描述

**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 4 [Płótno](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/plo/)**

由于圣诞节，Bytie 从父母那里得到了一块大画布，画布被分成 $2n$ 个方格，排列成两行 $n$ 列的矩形。为了方便在上面画画，这块画布被包在在一个很低很宽的圆柱体的侧面上，这样，画布的第一列就与最后一列相邻。如果画布上的两个方格有一条公共边，则认为它们是相邻的。即它们要么在同一列，要么在同一行的相邻列。

数学上，我们可以用一个有序数对 $(y,x)$ 表示画布上的每个方格，其中 $1\le y\le 2,1\le x\le n$。两个方格 $(y_1,x_1)$ 和 $(y_2,x_2)$ 相邻，如果满足：

- 它们在同一行，即 $y_1=y_2$，并且列相邻，即 $x_1+1\equiv x_2 \pmod n$ 或 $x_2+1\equiv x_1\pmod n$，或者
- 它们在同一列，即 $x_1=x_2$。

Bytie 一到画布前，就把 $2n$ 个方格的每一个都画成了**不同**的颜色。为简单起见，我们用 $1$ 到 $2n$ 的整数来表示颜色。

每个看到这个孩子的劳动成果的人都对这么小的孩子能够创造出如此宏伟的作品而感到非常惊讶。这甚至吸引了著名的艺术评论家 Bytona Bitego。他决定亲眼看看是什么让人们如此着迷，他将用自己特别准备的方法评估他的画，其方法如下：

我们选择一个特定的颜色区间 $[l, r]$，然后只考虑颜色在这个区间内的方格。我们称这个颜色区间的好奇值等于这些方格形成的连通区域的数量。如果存在一连串颜色在 $[l, r]$ 中的相邻方格使得两个颜色在 $[l,r]$ 的方格连通，那么这两个方格就在一个区域内。

Bytona Bitego 想知道对于每个 $v\in \{1,2,\ldots,k\}$，有多少区间的好奇值为 $v$。你的任务就是回答他的问题。

## 说明/提示

对于 $100\%$ 的数据，满足：

$2\le n\le 10 ^ 5, 1\le k\le 10$。

## 样例 #1

### 输入

```
3 2
1 5 3
4 2 6
```

### 输出

```
12 9
```

## 样例 #2

### 输入

```
5 3
1 3 5 7 9
2 6 4 8 10
```

### 输出

```
40 14 1
```

# 题解

## 作者：Lynkcat (赞：9)

其实这个东西直接一般化也是好做的。

把网格图的限制扔了，问题直接变成对于一张没啥性质的无向图，定义 $val(l,r)(l≤r)$ 为将颜色编号在 $[l,r]$ 内的格子染黑形成的四连通块数量，求对于 $i∈[1,k],val(l,r)=i$ 的 $[l,r]$ 数量。

这个东西是有很一般的做法的，考虑沿用森林上点数减边数的结论。从小到大扫 $r$，然后用 LCT 动态维护最大生成森林边集即可，查询变成了对于每个 $i$ 在 $[1,k]$ 查询点数减边数 $=i$ 的 $i$ 的数量，这个可以用线段树维护区间前 $k$ 小以及分别的数量后简单解决。

时间复杂度 $O((n+m) \log (n+m)+nk\log n)$。

```c++
#include<bits/stdc++.h>
#define ll long long 
#define pa pair<int,int> 
#define fi first 
#define se second 
#define mp make_pair
#define poly vector<int> 
using namespace std;
const int N=200005,B=15;
int inf;
struct node
{
    int val[B],cnt[B];
    node()
    {
        memset(val,0x3f,sizeof(val));
        memset(cnt,0,sizeof(cnt));
    }
}tr[N<<2];
int tag[N<<2];
node merge(node x,node y)
{
    node res;
    int l=0,r=0;
    for (int i=0;i<B;i++)
    {
        if (l<B&&r<B&&x.val[l]==y.val[r])
        {
            res.val[i]=x.val[l];
            res.cnt[i]=x.cnt[l]+y.cnt[r];
            l++,r++;
            continue;
        }
        if (r==B||l<B&&x.val[l]<y.val[r])
        {
            res.val[i]=x.val[l];
            res.cnt[i]=x.cnt[l];
            l++;
            continue;
        }
        res.val[i]=y.val[r];
        res.cnt[i]=y.cnt[r];
        r++;
    }
    return res;
}
void build(int k,int l,int r)
{
    tag[k]=0;
    if (l==r)
    {
        tr[k].val[0]=0;
        tr[k].cnt[0]=1;
        return;
    }
    int mid=l+(r-l)/2;
    build(k<<1,l,mid);
    build(k<<1|1,mid+1,r);
    tr[k]=merge(tr[k<<1],tr[k<<1|1]);
}
void ptag(int k,int x)
{
    for (int i=0;i<B;i++)
        if (tr[k].val[i]!=inf) tr[k].val[i]+=x;
    tag[k]+=x;
}
void update(int k,int l,int r,int L,int R,int x)
{
    if (L<=l&&r<=R)
    {
        ptag(k,x);
        return;
    }
    if (tag[k])
    {
        ptag(k<<1,tag[k]);
        ptag(k<<1|1,tag[k]);
        tag[k]=0;
    }
    int mid=l+(r-l)/2;
    if (L<=mid) update(k<<1,l,mid,L,R,x);
    if (R>mid) update(k<<1|1,mid+1,r,L,R,x);
    tr[k]=merge(tr[k<<1],tr[k<<1|1]);
}
node query(int k,int l,int r,int L,int R)
{
    if (L<=l&&r<=R) return tr[k];
    if (tag[k])
    {
        ptag(k<<1,tag[k]);
        ptag(k<<1|1,tag[k]);
        tag[k]=0;
    }
    int mid=l+(r-l)/2;
    if (R<=mid) return query(k<<1,l,mid,L,R); 
    if (L>mid) return query(k<<1|1,mid+1,r,L,R);
    return merge(query(k<<1,l,mid,L,R),query(k<<1|1,mid+1,r,L,R));
}
int n,m;
int a[N],b[N],fa[N];
poly G[N],E[N];
ll ans[N];
namespace LCT{
    const int N=500005;
	int tr[N];
	int tot;
	inline void upd(int x,int y){while (x<=m){tr[x]+=y;x+=x&-x;}}
	inline int qry(int x){int res=0;while(x){res+=tr[x];x-=x&-x;}return res;}
	bool rev[N];
	int fa[N],ch[N][2];
	int val[N],mx[N];
	int ecnt;
	#define ls(x) (ch[x][0])
	#define rs(x) (ch[x][1])
	#define dir(x) (x == ch[fa[x]][1])
	#define IsRoot(x) (x != ch[fa[x]][0] && x != ch[fa[x]][1])

	inline void PushUp(int x) {
		mx[x] = x;
		if(ls(x) && val[mx[ls(x)]] > val[mx[x]]) mx[x] = mx[ls(x)];
		if(rs(x) && val[mx[rs(x)]] > val[mx[x]]) mx[x] = mx[rs(x)];
	}

	inline void PushDown(int x) {
		if(rev[x]) {
			if(ls(x)) std::swap(ls(ls(x)),rs(ls(x))),rev[ls(x)] ^= 1;
			if(rs(x)) std::swap(ls(rs(x)),rs(rs(x))),rev[rs(x)] ^= 1;
			rev[x] = 0;
		}
	}

	void update(int x) {
		if(!IsRoot(x)) update(fa[x]);
		PushDown(x);
	}

	inline void rotate(int x) {
		int y = fa[x],z = fa[y],d = dir(x),w = ch[x][d ^ 1];
		if(!IsRoot(y)) ch[z][dir(y)] = x;
		ch[y][d] = w,ch[x][d ^ 1] = y;
		fa[y] = x,fa[x] = z;
		if(w) fa[w] = y;
		PushUp(y);
	}

	inline void splay(int x) {
		update(x);
		while(!IsRoot(x)) {
			int y = fa[x],z = fa[y];
			if(!IsRoot(y))
				rotate((ls(y) == x) ^ (ls(z) == y) ? x : y);
			rotate(x);
		}
		PushUp(x);
	}

	inline void access(int x) {
		for(int p = 0;x;p = x,x = fa[x])
			splay(x),rs(x) = p,PushUp(x);
	}

	inline void MakeRoot(int x) {
		access(x),splay(x);
		std::swap(ls(x),rs(x)),rev[x] ^= 1;
	}

	inline int FindRoot(int x) {
		access(x),splay(x);
		while(ls(x)) PushDown(x),x = ls(x);
		splay(x);
		return x;
	}

	inline void split(int x,int y) {
		MakeRoot(x),access(y),splay(y);
	}

	inline void link(int x,int y) {
		MakeRoot(x); fa[x] = y;
	}
	inline int addedge(int u,int v,int w)
	{
		val[++tot] = w;
		MakeRoot(u);
		if(u != FindRoot(v)) {
			link(tot,u),link(tot,v);
			ecnt++;
		}
		else {
			split(u,v);
			int ep = mx[v];
			if(w < val[ep]) {
                int now=val[ep];
				splay(ep);
				fa[ch[ep][0]] = fa[ch[ep][1]] = 0;
				link(tot,u);
				link(tot,v);
                return now;
			}
            return -1;
		}
        return -2;
	}
	inline int qzadd(int u,int v,int w)
	{
		if (qry(w)-qry(w-1)) return -1;
		val[++tot] = w;
		MakeRoot(u);
		split(u,v);
		int ep = mx[v];
		{
			splay(ep);
			fa[ch[ep][0]] = fa[ch[ep][1]] = 0;
			link(tot,u);
			link(tot,v);
			upd(val[ep],-1);
			upd(w,1);
		}
		return val[ep];
	}
	inline void clr()
	{
		for (int i=1;i<=m;i++) tr[i]=0;
		for (int i=1;i<=tot;i++) rev[i]=0,fa[i]=0,
		val[i]=mx[i]=0,ch[i][0]=ch[i][1]=0;
		ecnt=0;
		tot=0;
	}			
}
void Bellakira()
{
    inf=tr[0].val[0];
    cin>>n>>m;
    for (int i=0;i<n;i++)
        cin>>a[i];
    for (int i=0;i<n;i++)
        G[max(a[i],a[(i+n-1)%n])].push_back(min(a[i],a[(i+n-1)%n]));
    for (int i=0;i<n;i++)
        cin>>b[i];
    for (int i=0;i<n;i++)
        G[max(b[i],b[(i+n-1)%n])].push_back(min(b[i],b[(i+n-1)%n]));
    for (int i=0;i<n;i++)
        E[max(b[i],a[i])].push_back(min(b[i],a[i]));
    n*=2;
	LCT::tot=n;
    build(1,1,n);
    for (int i=1;i<=n;i++)
    {
        update(1,1,n,1,i,1);
        for (auto u:G[i])
        {
            int o=LCT::addedge(u,i,n-u+1);
            if (o==-1) continue;
            update(1,1,n,1,u,-1);
            if (o!=-2)
                update(1,1,n,1,n-o+1,1);
        }
        for (auto u:E[i])
        {
            int o=LCT::addedge(u,i,n-u+1);
            if (o==-1) continue;
            update(1,1,n,1,u,-1);
            if (o!=-2)
                update(1,1,n,1,n-o+1,1);
        }
        node now=query(1,1,n,1,i);
        for (int j=0;j<B;j++)
            if (now.cnt[j]&&now.val[j]<=m) 
            {
                ans[now.val[j]]+=now.cnt[j];
            }
    }
    for (int i=1;i<=m;i++) cout<<ans[i]<<' ';
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T=1;
    while (T--)
    {
        Bellakira();
    }
}


---

## 作者：Rosaya (赞：5)

### 题意

有一个 $2 \times n$ 的环，其中 $1,n$ 首尾相接，每个格子上有个 $[1,2n]$ 的互不相同的颜色。

定义 $val(l,r)(l \le r)$ 为将颜色编号在 $[l,r]$ 内的格子染黑形成的四连通块数量，求对于 $i \in [1,k],val(l,r)=i$ 的 $[l,r]$ 数量。

### 思路

考虑转化 $val(l,r)$，发现除了整张图连成一个环的情况，其他时候颜色方案都是一个平面图。

读者可以自行学习欧拉公式，这里不过多赘述。

结论很简单，四连通块数量 $=$ $1 \times 1$ 矩形数量 $-$ $1 \times 2$ 矩形数量 $+$ $2 \times 2$ 矩形数量。

对于整张图连成一个环的情况，显然连通块数量只能为 $1$。

此时整张图是立体的，但因为我们没有考虑上下的大环，所以按上面公式算出来的四连通块数量 $=0$，于是我们只需要最后把 $=0$ 的数量加到 $=1$ 即可。

这样我们可以扫描颜色区间右端点 $r$，维护对于每一个左端点 $l$ 的 $val(l,r)$，然后统计答案。

我们发现这样每一个修改都是一个前缀，而查询区间 $=x$ 的数的个数看起来就不能 $\text{poly}$，于是我们考虑每 $B$ 个数为一块，需要支持单点修改，整块平移与查询 $=x$ 的数的个数，这个是很简单的。

总复杂度 $O(nB+\dfrac{n^2k}{B})$，取 $B=\sqrt{nk}$，复杂度为 $O(n\sqrt{nk})$。

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const int b=1400;
const int itc=200000;

int n,k;
int col[2][100005];
int tag[150],cnt[150][400005],cur[200005];
ll ans[15];
vector<int> adj[200005];

inline void add(int pos,int val)
{
    for(int i=1;;i++)
    {
        if(pos<=i*b)
        {
            for(int j=(i-1)*b+1;j<=pos;j++)
            {
                cnt[i][cur[j]]--;
                cur[j]+=val;
                cnt[i][cur[j]]++;
            }

            break;
        }

        tag[i]+=val;
    }
}

inline void sol(int sum)
{
    for(int i=1;;i++)
    {
        ans[sum]+=cnt[i][itc+sum-tag[i]];

        if(n+n<=i*b)
            break;
    }
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    
    cin>>n>>k;

    for(int i=1;i<=n;i++)
        cin>>col[0][i];

    for(int i=1;i<=n;i++)
        cin>>col[1][i];

    for(int i=1;i<=n;i++)
    {
        adj[col[0][i]].push_back(col[0][i]);
        adj[col[1][i]].push_back(col[1][i]);
        adj[max(col[0][i],col[1][i])].push_back(-min(col[0][i],col[1][i]));
        adj[max(col[0][i],col[0][i%n+1])].push_back(-min(col[0][i],col[0][i%n+1]));
        adj[max(col[1][i],col[1][i%n+1])].push_back(-min(col[1][i],col[1][i%n+1]));
        adj[max(max(col[0][i],col[0][i%n+1]),max(col[1][i],col[1][i%n+1]))].push_back(min(min(col[0][i],col[0][i%n+1]),min(col[1][i],col[1][i%n+1])));
    }

    for(int i=1;i<=n+n;i++)
    {
        int id=(i-1)/b+1;
        cur[i]=itc-tag[id];
        cnt[id][cur[i]]++;

        for(int j=0;j<adj[i].size();j++)
        {
            int pos=adj[i][j],val;

            if(pos>0)
                val=1;
            else
                pos=-pos,val=-1;

            add(pos,val);
        }

        for(int j=0;j<=k;j++)
            sol(j);
    }

    ans[1]+=ans[0];

    for(int i=1;i<=k;i++)
        cout<<ans[i]<<' ';
    cout<<'\n';

    return 0;
}
```

---

## 作者：luckydrawbox (赞：3)

[$\text{Link}$](https://www.luogu.com.cn/problem/P9261)

## 分析

要求联通块的数量，等价于求联通块的边界数量再除以 $2$，于是，我们考虑求边界对每个区间的贡献。由于行数只有 $2$，所以我们可以简单分讨下边界的形态(令红色为一定在区间中的格子，蓝色为一定不在区间中的格子，白色为我们不关心的格子）：

第一种是边界只有一个格子，有上下左右四种对称情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/166vv9uz.png)

第二种是边界有两个格子，有左右两种对称情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/0m3ofpez.png)

显然能使一个边界的区间一定满足 $l$ 在一段区间内，$r$ 在一段区间内，在二维平面上的影响就是矩形加，直接扫描线即可。要求权值为 $1\sim k$ 的，直接在线段树上维护前 $k$ 小值即可，时间复杂度 $O(nk\log n)$。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define pii pair<int,int>
#define fi first 
#define se second
using namespace std;
long long read(){
	long long x=0,f=1;char ch=getchar();
	while(!isdigit(ch))
	{if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
void write(long long x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
const int N=2e5+10;
int n,k;
int b[2][N];
ll res[15];
struct oper{
	int l,r,v;
};
vector<oper>ad[N];
void add(int h,int i,int x,int i_){
	int l=1,r=2*n;
	if(b[h][i_]<x)l=max(l,b[h][i_]+1);
	else r=min(r,b[h][i_]-1);
	if(b[h^1][i]<x)l=max(l,b[h^1][i]+1);
	else r=min(r,b[h^1][i]-1);
    if(l>x||x>r)return;
	ad[l].push_back({x,r,1});
	ad[x+1].push_back({x,r,-1});
    // printf("insert h=%d i=%d x=%d i_=%d [%d,%d]\n",h,i,x,i_,l,r);
}
void add2(int i,int x,int y,int i_){
	int l=1,r=2*n;
	if(x>y)swap(x,y);
	if(b[0][i_]>=x&&b[0][i_]<=y)return;
	if(b[1][i_]>=x&&b[1][i_]<=y)return;
	if(b[0][i_]<x)l=max(l,b[0][i_]+1);
	else r=min(r,b[0][i_]-1);
	if(b[1][i_]<x)l=max(l,b[1][i_]+1);
	else r=min(r,b[1][i_]-1);
    if(l>x||y>r)return;
	ad[l].push_back({y,r,1});
	ad[x+1].push_back({y,r,-1});
}
#define pl p<<1
#define pr p<<1|1
struct Segment{
	struct Tree{
		pair<int,int>g[12];
		int tag;
		Tree(){for(int i=0;i<12;i++)g[i]={1e9,0};}
	}a[N<<2];
	void push(Tree &x,Tree y,Tree z){
		for(int i=0,p=0,q=0;i<=k;i++){
			if(y.g[p].fi==z.g[q].fi){
				x.g[i]=pii(y.g[p].fi,y.g[p].se+z.g[q].se);
				p++;q++;
			}
			else if(y.g[p].fi<z.g[q].fi){
				x.g[i]=y.g[p++];
			}
			else x.g[i]=z.g[q++];
		}
	}
	void pushup(int p){
		push(a[p],a[pl],a[pr]);
	}
	void pushdown(int p){
		if(a[p].tag){
			a[pl].tag+=a[p].tag;a[pr].tag+=a[p].tag;
			for(int i=0;i<12;i++){
				a[pl].g[i].fi+=a[p].tag;
				a[pr].g[i].fi+=a[p].tag;
			}
			a[p].tag=0;
		}
	}
	void build(int p,int L=1,int R=n*2){
		if(L==R){
			a[p].g[0]={0,1};return;
		}
		int mid=(L+R)>>1;
		build(pl,L,mid);build(pr,mid+1,R);
		pushup(p);
	}
	void change(int p,int l,int r,int v,int L=1,int R=2*n){
		if(l<=L&&R<=r){
			a[p].tag+=v;
			for(int i=0;i<12;i++){
				a[p].g[i].fi+=v;
			}
			return;
		}
        pushdown(p);
		int mid=(L+R)>>1;
		if(l<=mid)change(pl,l,r,v,L,mid);
		if(r>mid)change(pr,l,r,v,mid+1,R);
		pushup(p);
	}
}tr;
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	n=read();k=read();
	for(int i=0;i<n;i++){
		b[0][i]=read();
	}
	for(int i=0;i<n;i++){
		b[1][i]=read();
	}
	for(int i=0;i<n;i++){
		add(0,i,b[0][i],(i-1+n)%n);
		add(0,i,b[0][i],(i+1+n)%n);
		add(1,i,b[1][i],(i-1+n)%n);
		add(1,i,b[1][i],(i+1+n)%n);
		add2(i,b[0][i],b[1][i],(i-1+n)%n);
		add2(i,b[0][i],b[1][i],(i+1+n)%n);
	}
    tr.build(1);
	for(int i=1;i<=2*n;i++){
		for(auto u:ad[i])
			tr.change(1,u.l,u.r,u.v);
		for(int j=0;j<12;j++)
			if(tr.a[1].g[j].fi/2<=k)
				res[tr.a[1].g[j].fi/2]+=tr.a[1].g[j].se;
	}
    res[1]+=res[0]-1ll*(2*n)*(n*2-1)/2;
	for(int i=1;i<=k;i++)
		printf("%lld ",res[i]);
	puts("");
	return 0;
}
```

---

## 作者：Ebola (赞：3)

考虑如何计算 $v(l,r)$。分两种情况：

1. $[l,r]$ 中的格子连成了一个环。此时一定是一整个连通块，$v(l,r)=1$。

2. 没有连成一个环。此时可以沿某一列断环为链（黑块表示 $[l,r]$ 中的格子），然后得到一个平面图：

![](https://cdn.luogu.com.cn/upload/image_hosting/rvi0wb5l.png)

   考虑平面图欧拉公式 $V-E+F=\omega+1$，我们发现：

   - $V$：平面图点数，即圆柱网格上 $1\times 1$ 的黑块数
   - $E$：平面图边数，即圆柱网格上 $1\times 2$ 和 $2\times 1$ 的黑块数
   - $F$：平面区域分割数，即圆柱网格上 $4\times 4$ 的黑块数 $+1$
   - $\omega$：平面图连通块数，即 $v(l,r)$

   所以问题就转化为统计这三类黑块的个数。记圆柱网格上 $4\times 4$ 的黑块数为 $S$，我们就有：
   $$
   v(l,r) = V-E+S
   $$
   其中 $V$ 是平凡的，考虑 $E$ 和 $S$。

注意到第一种情况当且仅当 $V-E+S=0$。所以直接把 $=0$ 的个数算出来，计入 $v=1$ 的答案个数即可。无需分类处理。

#### 实现

从左往右扫描 $r$，用一个数组 $a_l$ 来保存 $v(l,r)$，随着 $r$ 动态更新。

1. 考虑 $V$。这很简单：

   > 扫到 $r$ 时，令 $a_{1...r}$ 加 $1$。

2. 考虑 $E$。设 $x_1<x_2$ 是位于圆柱上 $1\times 2$ 或 $2\times 1$ 块里的两个数，那么当 $r\geq x_2$ 且 $l\leq x_1$ 时，这个块成为一个对 $E$ 有贡献的黑块。所以做法就是：

   > 扫到 $x_2$ 时，令 $a_{1...x_1}$ 减 $1$。

3. 考虑 $S$。设 $x_1<x_2<x_3<x_4$ 是位于圆柱上 $2\times 2$ 块里的四个数，那么当 $r\geq x_4$ 且 $l\leq x_1$ 时，这个块成为一个对 $S$ 有贡献的黑块。所以做法就是：

   > 扫到 $x_4$ 时，令 $a_{1...x_1}$ 加 $1$。

需要一个数据结构，要支持区间加、实时统计值为 $i$ 的个数，只能考虑分块。最佳块大小留给读者自行思考。

---

## 作者：wYYSZLwSSY (赞：2)

好题。
## 题解
先来简单说一下暴力做法。暴力枚举区间，把每个方格（方格的颜色在选择的区间内，下同）看成点，把 $1 \times 2$ 的格子（颜色都在选择的区间内，下同）看作链接两个点的边，直接算联通块个数即可。

想要优化，显然应该把它用一个数据结构维护。连通性这种东西不是很好搞到 ds 上，考虑刻画一下。

如果连成的图是森林的话，那很简单，直接用点减边容斥即可，也就是点数减边数等于联通块数。但这里显然不是，直接用这种方法会把多减掉对连通性无用的边。（也就是假设连边有顺序，连上它时两个端点已经联通了。）

但我们注意到这个题有特殊的性质，也就是原图是只有两行的。这样，假设不考虑第一列和最后一列联通的情况，会出现“无用的边”的情况仅有一个，那就是有 $2 \times 2$ 的格子，而且每有这样一个格子，就会多一条“无用的边”。注意，这样的格子不用不重叠，也就是假设有一个 $2 \times 3$ 的格子就有两个“无用的边”。

现在我们考虑首尾联通的问题，如果没有整个连成一个大环，我们仍可以按上面的方法做，就像是先首尾连起来，然后又在一个地方切了一刀。（但算“大格子”的数量时候不要忘了首尾联通。）考虑如果连成了一个大环（这时联通块数是 $1$），那么无用的边会多一条，从而得到有 $0$ 个联通块。处理也不难，还用之前的方法，最后把 $0$ 个联通块的数量加到 $1$ 个的答案中就行。

所以我们得到，“联通块数”等于 $1 \times 1$ 格子数减去 $1\times 2$ 的格子数加上 $2 \times 2$ 的格子数，这样就比较适合放在 ds 上了。

具体应该怎么算呢？考虑移动右端点，用一个东西维护所有左端点的值。每向右移动一个，增加哪些格子，这些格子在左端点小于多少时起作用都是好算的。那么我们就是需要一个数据结构，用来前缀加，求等于某个值的数的数量，考虑分块。

具体地，区间加整块加 $tag$，散块改值和该块的桶，询问容易。这样，时间复杂度 $O(nk\sqrt{nk})$，可以通过。

### 代码
稍微注意一下空间限制。
```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int n,k,a[2][100005];
int ans[24];
signed t[320][400005];
int b[200005],tag[1004];
int bet[200005],st[1004];
pair<int,int>p[200005];
constexpr int P=2e5;//防止负数下标
int cl(int y){//首尾相连
	if(!y)return n;
	if(y>n)return 1;
	return y;
}
void add(int l,int r,int c){
	int L=bet[l],R=bet[r];
	if(L==R){
		for(int i=l;i<=r;++i){
			--t[L][b[i]+P];
			b[i]+=c;
			++t[L][b[i]+P];
		}
		return;
	}
	for(int i=l;i<=st[L];++i){
		--t[L][b[i]+P];
		b[i]+=c;
		++t[L][b[i]+P];
	}
	for(int i=L+1;i<=R-1;++i)tag[i]+=c;
	for(int i=st[R-1]+1;i<=r;++i){
		--t[R][b[i]+P];
		b[i]+=c;
		++t[R][b[i]+P];
	}
	return ;
}
void calc(int r){
	int L=1,R=bet[r];
	if(L==R){
		for(int i=1;i<=r;++i)
			if(tag[L]+b[i]<=k)++ans[tag[L]+b[i]];
		return ;
	}
	for(int i=1;i<=st[L];++i)
		if(tag[L]+b[i]<=k)++ans[tag[L]+b[i]];
	for(int i=L+1;i<=R-1;++i)
		for(int j=0;j<=k;++j)
			ans[j]+=t[i][j-tag[i]+P];
	for(int i=st[R-1]+1;i<=r;++i)
		if(tag[R]+b[i]<=k)++ans[tag[R]+b[i]];
	return ;
}
signed main(){
	cin.tie(0)->sync_with_stdio(0);
// 	freopen("1.in","r",stdin);
	cin>>n>>k;
	int B=max((int)sqrtl(4*n*k),1ll);
	for(int i=0;i<=1;++i)
		for(int j=1;j<=n;++j){
			cin>>a[i][j];
			p[a[i][j]]={i,j};
		}
	for(int i=1;i<=2*n;++i){
		bet[i]=i/B+1;
		st[i/B+1]=i;
	}
	for(int i=1;i<=bet[2*n];++i)
		t[i][P]=st[i]-st[i-1];
	for(int i=1;i<=2*n;++i){
		auto pt=p[i];
		int x=pt.first,y=pt.second;
		add(1,i,+1);
		int xx=(x^1),yy=y;
		if(a[xx][yy]<=i)add(1,a[xx][yy],-1);
		xx=x;yy=cl(y-1);
		if(a[xx][yy]<=i)add(1,a[xx][yy],-1);
		yy=cl(y+1);
		if(a[xx][yy]<=i)add(1,a[xx][yy],-1);
		for(int j:{1,-1}){
			int mn=3e18,mx=-1;
			for(int ox:{1,0})for(int oy:{1,0}){
				if(!ox and !oy)continue ;
				mn=min(mn,a[x^ox][cl(y+oy*j)]);
				mx=max(mx,a[x^ox][cl(y+oy*j)]);
			}
			if(mn<=i and mx<=i)add(1,mn,+1);
		}//这段写的很丑，将就看吧。
		calc(i);
	}
	ans[1]+=ans[0];
	for(int i=1;i<=k;++i)cout<<ans[i]<<' ';
	return 0;
}
```

---


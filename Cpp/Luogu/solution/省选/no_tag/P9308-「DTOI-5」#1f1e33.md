# 「DTOI-5」#1f1e33

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/9pyd7oxa.png)

In the middle of night.

## 题目描述

定义函数 $f(n) = \displaystyle\sum_{i = 1}^n \sum_{j = 1}^n \sum_{k = 1}^n [i + j + k = n] \operatorname{lcm}(i, \gcd(j, k))$

给定 $n$，对于所有 $1 \leq i \leq n$，**求出所有** $f(i) \bmod 998244353$ 的值。

## 说明/提示

**【数据范围】**

$$
\def\or{\operatorname{or}}
%\def\arrayscretch{1.5}
\def\arraystretch{1.5}
\begin{array}{|c|c|c|}\hline
\textbf{测试点编号}&n= &\textbf{Points}\cr\hline
\sf1&100&10 \operatorname{pts}\cr\hline
\sf2&10^3&10 \operatorname{pts}\cr\hline
\sf3&10^4&20 \operatorname{pts}\cr\hline
\sf4&10^5&20 \operatorname{pts}\cr\hline
\sf5&/&40 \operatorname{pts}\cr\hline
\end{array}
$$
对于 $100\%$ 的数据，$1 \leq n \leq 10^6$。

## 样例 #1

### 输入

```
10```

### 输出

```
0 0 1 4 11 20 42 60 100 134```

# 题解

## 作者：MinCut (赞：12)

令 $ans(i)$ 为题面里的 $f(i)$。

考虑枚举 $\gcd(i, j, k)$，令 $f(n)$ 表示 $\sum_{i + j + k = n} [\gcd(i, j, k) = 1] \operatorname{lcm(i, \gcd(j, k))}$。

则 $ans(n) = \sum_{d | n} d \times f(n / d)$。

此时考虑计算 $f$，再令 $g(n)$ 表示 $\sum_{i + j + k = n} i * \gcd(j, k)$，根据莫比乌斯反演得：

$f(n) = \sum_{i + j + k = n} i \times \gcd(j, k) \sum_{d | \gcd(i, j, k)} \mu(d) = \sum_{d | n} d ^ 2 \times \mu(d) \times g(n / d)$。

再考虑计算 $g$。

容易发现 $g$ 是一个卷积的形式，就是 $x(i) = i$ 和 $y(i) = \sum_{j + k = i} \gcd(j, k)$ 的卷积。

后者用欧拉反演：

$y(i) = \sum_{j + k = i} \sum_{d | \gcd(j, k)} \phi(d) = \sum_{d | n} \phi(d) \times (n / d - 1)$。

于是三遍 Dirichlet 卷积 + 一遍普通卷积即可。

时间复杂度 $O(n \log n)$。

---

## 作者：飞雨烟雁 (赞：10)

提供一个 $\Theta(n\log \log n)$ 的做法。

------------

先把 $\text{lcm}$ 转为 $\gcd$：

$$f(n)=\sum_{1\le i,j,k\le n}[i+j+k=n]\dfrac{i(j,k)}{(i,j,k)}$$

接着我们考虑消去 $i$：

$$\begin{aligned}f(n)&=\sum_{1\le j,k\le n}[j+k\le n-1]\dfrac{(n-j-k)(j,k)}{(n-j-k,j,k)}\\&=\sum_{1\le j,k\le n}[j+k\le n]\dfrac{(n-j-k)(j,k)}{(n,j,k)}\end{aligned}$$

枚举 $d=(j,k)$：

$$\begin{aligned}f(n)&=\sum_{d=1}^n\dfrac{d}{(n,d)}\sum_{1\le j,k\le n}[(j,k)=d][j+k\le n](n-j-k)\\&=\sum_{d=1}^n\dfrac{d}{(n,d)}\sum_{1\le j,k\le \frac nd}[(j,k)=1]\left[j+k\le \frac nd\right](n-dj-dk)\end{aligned}$$

枚举 $s=j+k$：

$$\begin{aligned}f(n)&=\sum_{d=1}^n\dfrac{d}{(n,d)}\sum_{2\le s\le \frac nd}(n-ds)\sum_{1\le j,k\le \frac nd}[(j,k)=1][j+k=s]\\&=\sum_{d=1}^n\dfrac{d}{(n,d)}\sum_{2\le s\le \frac nd}(n-ds)\sum_{j\ge 1}[(j,s-j)=1]\\&=\sum_{d=1}^n\dfrac{d}{(n,d)}\sum_{2\le s\le \frac nd}(n-ds)\varphi(s)\end{aligned}$$

枚举 $t=(n,d)$：

$$\begin{aligned}f(n)&=\sum_{t|n}\sum_{t|d}^n\dfrac{d}{t}[(n,d)=t]\sum_{2\le s\le \frac nd}(n-ds)\varphi(s)\\&=\sum_{t|n}\sum_{d\le \frac nt}d\left[\left(\frac nt,d\right)=1\right]\sum_{2\le s\le \frac n{td}}(n-tds)\varphi(s)\\
&=\sum_{t|n}t\sum_{sd\le \frac nt}[s\ge 2]\left[\left(\frac nt,d\right)=1\right]d\left(\frac nt-ds\right)\varphi(s)\\
\end{aligned}$$

我们把内层求和设为 $g(n)$，即令：

$$g(n)=\sum_{sd\le n}[s\ge 2]\left[\left(n,d\right)=1\right]d\left(n-ds\right)\varphi(s)$$

可以发现我们要求的就是：

$$f(n)=\sum_{t|n}tg\left(\frac nt\right)=n\sum_{t|n}\frac {g(t)}{t}$$

------------

下面我们看下如何快速求 $g(n)$。

利用莫反处理 $(n,d)=1$：

$$\begin{aligned}g(n)&=\sum _ {t|n}\mu(t)\sum_{sd\le n}[s\ge 2]\left[t|d\right]d\left(n-ds\right)\varphi(s)\\&=\sum _ {t|n}t^2\mu(t)\sum_{sd\le \frac nt}[s\ge 2]d\left(\frac nt-ds\right)\varphi(s)\end{aligned}$$

我们再次将内层求和设为 $h(n)$，即：

$$h(n)=\sum_{sd\le n}[s\ge 2]d\left(n-ds\right)\varphi(s)$$

则有：

$$g(n)=\sum_{t|n}t^2\mu(t)h\left(\frac nt\right)=n^2\sum_{t|n}\mu\left(\frac nt\right)\frac{h(t)}{t^2}$$

------------

下面考虑 $h(n)$ 快速求法。

先剔除 $s\ge 2$ 这个条件：

$$\begin{aligned}h(n)&=\sum_{sd\le n}[s\ge 2]d\left(n-ds\right)\varphi(s)\\&=\sum_{sd\le n}d\left(n-ds\right)\varphi(s)-\sum_{d=1}^nd(n-d)\end{aligned}$$

接着枚举 $k=sd$，并设 $\tau(n)=\sum_{d|n}d\varphi(\frac nd)$。

$$\begin{aligned}h(n)&=\sum_{k=1}^n(n-k)\sum_{d|k}d\varphi\left(\frac kd\right)-\frac{n(n-1)(n+1)}{6}\\&=n\sum_{k=1}^n\tau(k)-\sum_{k=1}^nk\tau(k)-\frac{n(n-1)(n+1)}{6}\\\end{aligned}$$

酱紫就推完啦！

至于 $\tau(n)$，通过简单的推导可知：

$$\tau(pn)=\begin{cases}2p-1&n=1\\\tau(p)\tau(n)&p\nmid n\\ 2p\tau(n)-p^2\tau(n/p)& p\mid n\end{cases}$$

可以线性筛。

------------

我们总结一下步骤：

0. 线性递推求逆元；

1. 线性筛出 $\tau(1),\tau(2),\cdots,\tau(n)$ 的值；

2. 求出 $h(1),h(2),\cdots,h(n)$ 的值。

3. 对 $h(n)/n^2$ 做 Dirichlet 差分，得到 $g(1)/1^2,\cdots,g(n)/n^2$；

4. 对 $g(n)/n$ 做 Dirichlet 前缀和，即得 $f(1)/1,\cdots,f(n)/n$。

总时间复杂度是 $\Theta(n\log \log n)$，目前为最优解。

代码如下：

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;

const int Mx = 1e6 + 100, Mod = 998244353;

bool Vis[Mx];
int Tau[Mx], Prime[Mx], tot;
int Inv[Mx];

void Sieve(){
	Tau[1] = 1;
	for(int i = 2; i < Mx; ++i){
		if(!Vis[i]) Prime[++tot] = i, Tau[i] = 2 * i - 1;
		for(int j = 1; j <= tot && Prime[j] * i < Mx; ++j){
			Vis[i * Prime[j]] = true;
			if(i % Prime[j] == 0){
				Tau[i * Prime[j]] = Prime[j] * (2 * Tau[i] - Prime[j] * Tau[i / Prime[j]]);
				break;
			}
			Tau[i * Prime[j]] = Tau[i] * Tau[Prime[j]];
		}
	}
}

void GetInv(){
	Inv[1] = 1;
	for(int i = 2; i < Mx; i++) Inv[i] = -1ll * Inv[Mod % i] * (Mod / i) % Mod;
}

int H[Mx];
int main(){
	Sieve(), GetInv();
	int n; cin >> n;
	int H0 = 0, H1 = 0;
	for(int i = 1; i <= n; ++i){
		H0 = (H0 + Tau[i]) % Mod;
		H1 = (H1 + 1ll * i * Tau[i]) % Mod;
		H[i] = (H0 - 1ll * Inv[i] * H1 - (i - 1ll) * (i + 1ll) % Mod * Inv[6]) % Mod * Inv[i] % Mod;
	}
	for(int i = 1; Prime[i] <= n; ++i){
		for(int j = n / Prime[i]; j; --j){
			H[j * Prime[i]] = (H[j * Prime[i]] - H[j]) % Mod;
		}
	}
	for(int i = 1; i <= n; ++i) H[i] = 1ll * i * H[i] % Mod;
	for(int i = 1; Prime[i] <= n; ++i){
		for(int j = 1; j * Prime[i] <= n; ++j){
			H[j * Prime[i]] = (H[j * Prime[i]] + H[j]) % Mod;
		}
	}
	for(int i = 1; i <= n; ++i){
		int Ans = 1ll * H[i] * i % Mod;
		if(Ans < 0) Ans += Mod;
		printf("%d ", Ans);
	}
	return 0;
}
```

---

## 作者：wishapig (赞：8)

怎么标算还要 NTT 的啊 /yiw，强行推一波公式。

设
$$
\begin{aligned}
A[i][j]&=\sum_{k=1}^i[\gcd(k,i-k)=j]\\
&=\sum_{k=1}^i[\gcd(k,i)=j]\\
&=\sum_{k=1}^{i/j}[\gcd(k,i/j)=1]\\
&=\sum_{d|\frac{i}{j}}\mu(d)\dfrac{i}{jd}
\end{aligned}
$$
设
$$
a[i]=\sum_{d|i}\mu(d)\dfrac{i}{d}
$$
那么 $A[i][j]=a[i/j]$ 仅当 $j|i$ 时有值。另外 $A[i][i]$ 实际上是 $0$，这个可以额外把 $a[1]$ 置 $0$ 来解决。

于是：
$$
\begin{aligned}
f(n)&=\sum_{i=1}^n\sum_{d|i}\operatorname{lcm}(n-i,d)\cdot a[i/d]\\
&=\sum_{i=1}^n\sum_{d|i}\dfrac{(n-i)d}{\gcd(n-i,d)}\cdot a[i/d]\\
&=\sum_{i=1}^n\sum_{d|i}\dfrac{(n-i)d}{\gcd(n,d)}\cdot a[i/d]\\
&=\sum_d\dfrac{d}{\gcd(n,d)}\sum_{i=1}^{\lfloor n/d\rfloor}(n-id)\cdot a_i\\
&=n\sum_d\dfrac{d}{\gcd(n,d)}\sum_{i=1}^{\lfloor n/d\rfloor}a_i-\sum_d\dfrac{d^2}{\gcd(n,d)}\sum_{i=1}^{\lfloor n/d\rfloor}i\cdot a_i
\end{aligned}
$$
设
$$
\begin{aligned}
p[i]&=\sum_{j=1}^ia[j]\\
q[i]&=\sum_{j=1}^i j\cdot a[j]
\end{aligned}
$$
那么左边一半：
$$
\begin{aligned}
& \ \ \ \ \ \sum_d\dfrac{d}{\gcd(n,d)}\cdot p[\lfloor n/d\rfloor]\\
&=\sum_{x|n}\sum_y[\gcd(y,n/x)=1]y\cdot p[\lfloor n/(xy)\rfloor]\\
&=\sum_{x|n}\sum_yy\cdot p[\lfloor n/(xy)\rfloor]\sum_{d|y,d|(n/x)}\mu(d)\\
&=\sum_{x|n}\sum_{d|(n/x)}\mu(d)\cdot d\sum_y y\cdot p[\lfloor n/(xyd)\rfloor]\\
\end{aligned}
$$
设
$$
\begin{aligned}
P[i]&=\sum_{j=1}^ij\cdot p[\lfloor i/j\rfloor]\\
A[i]&=\sum_{j|i}j\cdot \mu(j)\cdot P[i/j]
\end{aligned}
$$
那么上式继续化简为：
$$
\begin{aligned}
&=\sum_{x|n}\sum_{d|(n/x)}d\cdot \mu(d)\cdot P[n/(xd)]\\
&=\sum_{x|n}A[n/x]
\end{aligned}
$$
然后右边如法炮制：
$$
\begin{aligned}
& \ \ \ \ \ \sum_d\dfrac{d^2}{\gcd(n,d)}\cdot q[\lfloor n/d\rfloor]\\
&=\sum_{x|n}\sum_y[\gcd(y,n/x)=1]xy^2\cdot q[\lfloor n/(xy)\rfloor]\\
&=\sum_{x|n}\sum_y xy^2\cdot q[\lfloor n/(xy)\rfloor]\sum_{d|y,d|(n/x)}\mu(d)\\
&=\sum_{x|n}x\sum_{d|(n/x)}\mu(d)\cdot d^2\sum_y y^2\cdot q[\lfloor n/(xyd)\rfloor]\\
\end{aligned}
$$
设
$$
\begin{aligned}
Q[i]&=\sum_{j=1}^ij^2\cdot q[\lfloor i/j\rfloor]\\
B[i]&=\sum_{j|i}j^2\cdot \mu(j)\cdot Q[i/j]
\end{aligned}
$$
然后继续化简为：
$$
\begin{aligned}
&=\sum_{x|n}x\sum_{d|(n/x)}d^2\cdot \mu(d)\cdot Q[n/(xd)]\\
&=\sum_{x|n}x\cdot B[n/x]
\end{aligned}
$$
这样就可以在调和级数的复杂度内计算出所有 $f$ 值了，复杂度 $O(n\ln n)$。

至于 $P,Q$，并不需要用整除分块来算，枚举 $j$ 和 $\lfloor i/j\rfloor$ 的值 $d$，可得 $jd\le i\le j(d+1)-1$。

于是对 $P$ 的这一段加上 $j\cdot p[d]$，对 $Q$ 的这一段加上 $j^2\cdot q[d]$ 即可。

```cpp
const int N=1e6+5,mod=998244353;
int mu[N],nprime[N],prime[N];
int a[N],p[N],q[N],P[N],Q[N],A[N],B[N],v1[N],v2[N];
int n,cnt;
int main(){
	scanf("%d",&n); mu[1]=1;
	for (int i=2; i<=n; i++){
		if (!nprime[i]) mu[i]=mod-1,prime[++cnt]=i;
		for (int j=1; j<=cnt && i*prime[j]<=n; j++){
			nprime[i*prime[j]]=1;
			if (i%prime[j]==0){ mu[i*prime[j]]=0; break; }
			else mu[i*prime[j]]=(mod-mu[i])%mod;
		}
	}
	
	for (int d=1; d<=n; d++)
		for (int i=d; i<=n; i+=d) a[i]=(a[i]+1ll*(i/d)*mu[d])%mod;
	a[1]=0;
	
	for (int i=1; i<=n; i++) p[i]=(p[i-1]+a[i])%mod,q[i]=(q[i-1]+1ll*i*a[i])%mod;
	
	for (int i=1; i<=n; i++)
		for (int d=1; d*i<=n; d++){
			P[d*i]=(P[d*i]+1ll*i*p[d])%mod;
			int R=min(n+1,(d+1)*i);
			P[R]=(P[R]+mod-1ll*i*p[d]%mod)%mod;
			
			Q[d*i]=(Q[d*i]+1ll*i*i%mod*q[d])%mod;
			Q[R]=(Q[R]+mod-1ll*i*i%mod*q[d]%mod)%mod;
		}
	for (int i=1; i<=n; i++) P[i]=(P[i]+P[i-1])%mod,Q[i]=(Q[i]+Q[i-1])%mod;
	
	for (int i=1; i<=n; i++)
		for (int j=i; j<=n; j+=i){
			A[j]=(A[j]+1ll*P[j/i]*mu[i]%mod*i)%mod;
			B[j]=(B[j]+1ll*Q[j/i]*mu[i]%mod*i%mod*i)%mod;
		}
	
	for (int x=1; x<=n; x++)
		for (int i=x; i<=n; i+=x){
			v1[i]=(v1[i]+A[i/x])%mod;
			v2[i]=(v2[i]+1ll*B[i/x]*x)%mod;
		}
	
	for (int i=1; i<=n; i++) printf("%lld ",(1ll*i*v1[i]+mod-v2[i])%mod);
}
```



---

## 作者：masterhuang (赞：6)

或许更好的阅读体验：[my blog](https://www.cnblogs.com/HaHeHyt/p/18337338)。

声明：截止 $2024.8.1$，拿下洛谷**最优解最短解**，代码长度不到 **1k**。复杂度 $O(n\log \log n)$。

**先骂：官方题解菜！这种纯洁的数论题居然敢引入 NTT 作为标算，说明出题人不会推式子。**

**还有题解区一车 $\log$ 的题解凭啥顶那么上面，推的一坨狗屎推出来的复杂度还不优秀。**

---

说明：下面除法默认下取整，为了方便部分分数用 $/$ 代替，若无特殊说明 $(i,j)$ 都表示取 $\gcd$。

下文记当前求的 $f(n)$ 为 $ans$，$f$ 后面设成了其他函数。

套路性的枚举 $\gcd$：$ans=\sum\limits_{d=1}^n\sum\limits_{1\le j,k,j+k\le n/d}[(j,k)=1]\text{lcm}(n-d(j+k),d)$。

注意到：$\text{lcm}(n-d(j+k),d)=\dfrac{d(n-d(j+k))}{\gcd(n-d(j+k),d)}=\dfrac{d}{(d,n)}\cdot (n-d(j+k))$。

$ans=\sum\limits_{d=1}^n\dfrac{d}{(d,n)}\sum\limits_{1\le j,k,j+k\le n/d}[(j,k)=1](n-d(j+k))$，枚举 $s=j+k$，枚举 $j$，则 $(j,k)=(s,j)$：

$ans=\sum\limits_{d=1}^n\dfrac{d}{(d,n)}\sum\limits_{s=2}^{n/d}(n-ds)\sum\limits_{j=1}^{s-1} [(s,j)=1]=\sum\limits_{d=1}^n\dfrac{d}{(d,n)}\sum\limits_{s=2}^{n/d}(n-ds)\varphi(s)=\sum\limits_{i=1}^n\dfrac{i}{(n,i)}\sum\limits_{ij\le n} [j\ge 2](n-ij)\varphi(j)$。

---

枚举 $(i,n)$：

$$\begin{aligned}ans&=\sum\limits_{i=1}^n\dfrac{i}{(n,i)}\sum\limits_{ij\le n} [j\ge 2](n-ij)\varphi(j)
\\
&=\sum\limits_{d\mid n}d\sum\limits_{i=1}^{n/d}[(i,n/d)=1]i\sum\limits_{ij\le n/d} [j\ge 2](n/d-ij)\varphi(j)
\\
&=\sum\limits_{d\mid n}d\sum\limits_{dD\mid n}\mu(D)D^2 \sum\limits_{i=1}^{n/dD}i\sum\limits_{ij\le n/dD} [j\ge 2](n/dD-ij)\varphi(j)
\\
&=\sum\limits_{T\mid n}T\sum\limits_{D\mid T}\mu(D)D\sum\limits_{i=1}^{n/T}i\sum\limits_{ij\le n/T} [j\ge 2](n/T-ij)\varphi(j)
\\
&=\sum\limits_{T\mid n}f(T)g(n/T)=(f*g)(n)\end{aligned}$$

其中 $f(T)=T\sum\limits_{d\mid T}\mu(d)d,g(n)=\sum\limits_{i=1}^{n}i\sum\limits_{ij\le n} [j\ge 2](n-ij)\varphi(j)$。

此时若计算出 $f(1\sim n),g(1\sim n)$，注意到显然 $f$ 是积性函数。

求 $1\sim n$ 时的 $ans$ 做个[快速狄利克雷卷积](https://www.cnblogs.com/HaHeHyt/p/17185823.html#-%E4%B8%BA%E7%A7%AF%E6%80%A7%E5%BF%AB%E9%80%9F%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF-)即可，狄卷的复杂度是 $O(n\log\log n)$。

---

考虑求 $f$，记 $f_0(n)=f(n)/n$，则可以如下线性筛求 $f_0$：

$f_0(np)=\begin{cases}1-p(n=1)\\f_0(n)f_0(p)(p\nmid n)\\f_0(n)(p\mid n)\end{cases}$

---

考虑求 $g$，扣掉 $[j\ge 2]$，则多算的部分为：$\sum\limits_{i=1}^n i(n-i)=\dbinom{n+1}{3}$。

于是 $g(n)=h(n)-\dbinom{n+1}{3},h(n)=\sum\limits_{ij\le n} i(n-ij)\varphi(j)$。

$h(n)=\sum\limits_{s=1}^n(n-s)\sum\limits_{d\mid s}d\varphi(n/d)=\sum\limits_{s=1}^n(n-s)F(s)$，其中 $F(s)=\sum\limits_{d\mid s}d\varphi(n/d)$。

可以如下线性筛求 $F$：

$F(np)=\begin{cases}2p-1(n=1)\\F(n)F(p)(p\nmid n)\\p(2F(n)-pF(n/p))(p\mid n)\end{cases}$

然后随便前缀和一下就能求出 $h$ 了。

于是 $f,g$ 都可以线性求，最后狄利克雷卷积一下做完。

---

留几道思考问题：

- 如何证明 $f$ 是积性函数？

- **如何**能推出线性筛求 $f_0,F$ 的式子？

- 请尝试论证 $F(1\sim n)$ 的值能在 `int` 范围内存下，即线性筛的过程中不需要取模。

- 一种及其巧妙的把 $F$ 转化为 $g$ 的方法为：令 $F_0(n)=F(n)-n$。
对 $F_0$ 做两次前缀和得到 $F'$，此时 $F(n)=F'(n-1)$，请证明并尝试正向推出此做法。

**code：**

```cpp
#include<bits/stdc++.h>
#define LL long long
#define fr(x) freopen(#x".in","r",stdin);freopen(#x".out","w",stdout);
using namespace std;
const int N=1e6+5,mod=998244353;
int n,pr[N/10],f[N],g[N];bool v[N];
inline int md(int x){return x>=mod?x-mod:x;}
inline void init(int M)
{
	f[1]=g[1]=1;
	for(int i=2;i<=M;i++)
	{
		if(!v[i]) pr[++pr[0]]=i,f[i]=1-i,g[i]=2*i-1;
		for(int j=1,p=2;j<=pr[0]&&i*p<=M;p=pr[++j])
		{
			v[i*p]=1;
			if(i%p==0){f[i*p]=f[i];g[i*p]=p*(2*g[i]-p*g[i/p]);break;}
			f[i*p]=f[i]*f[p];g[i*p]=g[i]*g[p];//注意此处不需要取模减小常数
		}
	}//线性筛求 f_0,F
	for(int i=1;i<=M;i++) f[i]=1ll*(f[i]+mod)*i%mod,g[i]=md(g[i]-i+g[i-1]);//f 记得点乘回 i
	for(int i=1;i<=M;i++) g[i]=md(g[i]+g[i-1]);
	for(int i=M;i;i--) g[i]=g[i-1];g[1]=0;//巧妙方法求出 g
}
int main()
{
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);cin>>n;init(n);
	for(int i=1;i<=pr[0];i++) for(int j=n/pr[i];j;j--) 
		for(LL k=pr[i];j*k<=n;k*=pr[i]) g[j*k]=(g[j*k]+1ll*g[j]*f[k])%mod;
	//按照我给的链接材料做快速狄卷
	for(int i=1;i<=n;i++) cout<<g[i]<<" ";
	return 0;
}
```

---

## 作者：Reanap (赞：3)

本来计划打这场的，但因为事情耽搁了，晚上来看了看，推着很复杂，但其实每一步不是套路就是通过简单的观察得到。

$$
f(n) = \sum_{i=1}^n\sum_{j=1}^n\sum_{k=1}^n [i + j + k = n] \operatorname{lcm} (i , \gcd(j , k)) \\f(n) = \sum_{j=1}^n\sum_{k=1}^n\sum_{i=1}^n [i + j + k = n] \operatorname{lcm} (i , \gcd(j , k)) \\f(n) = \sum_{d=1}^n \sum_{i \equiv n \bmod d}^n \operatorname{lcm} (i , d) \sum_{j=1}^{\frac{n-i}{d}} [\gcd(j , \frac{n - i - jd}{d}) = 1] \\f(n) = \sum_{d=1}^n \sum_{i \equiv n \bmod d}^n \operatorname{lcm} (i , d) g(\frac{n-i}{d}) \\f(n) = \sum_{d=1}^n \frac{1}{\gcd(d,n)} \sum_{i \equiv n \bmod d}^n i \times d \times g(\frac{n-i}{d})
$$

其中：
$$
g(n) = \sum_{i=1}^{n-1} [\gcd(i , n - i) = 1] \\g(n) = \sum_{i=1}^{n-1} [\gcd(i , n) = 1] \\g(n) = \varphi(n)
$$

$$
f(n) = \sum_{d=1}^n \frac{d}{\gcd(d,n)} \sum_{i \equiv n \bmod d}^n i \times g(\frac{n-i}{d}) \\f(n) = \sum_{d=1}^n \frac{d}{\gcd(d,n)} (n\sum_{p=1} \varphi(p) - d\sum_{p=1} \varphi(p)p ) \\f(n) = \sum_{d=1}^n \frac{d}{\gcd(d,n)} (nS_{1}(\frac{n}{d}) - dS_2(\frac{n}{d})) \\f(n) = \sum_{T|n} \sum_{d=1}^{\frac{n}{T}} d[\gcd(d,\frac{n}{T})=1] (nS_{1}(\frac{n}{dT}) - dTS_2(\frac{n}{dT})) \\f(n) = \sum_{T|n} n(\sum_{d=1}^{\frac{n}{T}} d[\gcd(d,\frac{n}{T})=1]S_{1}(\frac{n}{dT})) - T(\sum_{d=1}^{\frac{n}{T}}d^2[\gcd(d,\frac{n}{T})=1]S_2(\frac{n}{dT})) \\f(n) = \sum_{T|n} n \times h_1(\frac{n}{T}) - T \times h_2(\frac{n}{T})
$$

其中：
$$
h_1(n) = \sum_{d=1}^n d [gcd(d , n) =1] S_1(\frac{n}{d}) \\h_1(n) = \sum_{D|n} D\mu(D) \sum_{d=1}^{\frac{n}{D}} d S_1(\frac{n}{dD}) \\h_1(n) = \sum_{D|n} D\mu(D) val_1(\frac{n}{D})
$$

$$
h_2(n) = \sum_{d=1}^n d^2 [gcd(d , n) =1] S_2(\frac{n}{d}) \\h_2(n) = \sum_{D|n} D^2\mu(D) \sum_{d=1}^{\frac{n}{D}} d^2 S_2(\frac{n}{dD}) \\h_2(n) = \sum_{D|n} D^2\mu(D) val_2(\frac{n}{D})
$$

然后 $val_1$ 和 $val_2$ 可以通过枚举 $d$ ，发现大量的元素 $\frac{n}{d}$ 相同，于是通过差分前缀和可以在调和级数复杂度解决。

同样的，$h_1$ 和 $h_2$ 可以通过调和级数枚举因子解决。 

```cpp
#include <set>
#include <map>
#include <cmath>
#include <queue>
#include <cstdio>
#include <cassert>
#include <cstring>
#include <iostream>
#include <algorithm>
#define pii pair <int , int>
#define pll pair <LL , LL>
#define mp make_pair
#define fs first
#define sc second
using namespace std;
typedef long long LL;
typedef unsigned long long ULL;

//const int Mxdt=100000;
//static char buf[Mxdt],*p1=buf,*p2=buf;
//#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,Mxdt,stdin),p1==p2)?EOF:*p1++;

template <typename T>
void read(T &x) {
	T f=1;x=0;char s=getchar();
	while(s<'0'||s>'9') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=(x<<3)+(x<<1)+(s^'0');s=getchar();}
	x *= f;
}

template <typename T>
void write(T x , char s='\n') {
	if(!x) {putchar('0');putchar(s);return;}
	if(x<0) {putchar('-');x=-x;}
	T t = 0 , tmp[25] = {};
	while(x) tmp[t ++] = x % 10 , x /= 10;
	while(t -- > 0) putchar(tmp[t] + '0');
	putchar(s);
}

const int MAXN = 1e6 + 5;
const int mod = 998244353;

inline int Add(int x , int y) {x += y;return x >= mod?x - mod:x;}
inline int Sub(int x , int y) {x -= y;return x < 0?x + mod:x;}
inline int Mul(int x , int y) {return 1ll * x * y % mod;}

int prim[MAXN] , Is_pr[MAXN] , phi[MAXN] , cnt;
int S1[MAXN] , S2[MAXN] , mu[MAXN];
void pre() {
	mu[1] = 1;
	int N = 1e6;
	for (int i = 2; i <= N; ++i) {
		if(!Is_pr[i]) prim[++cnt] = i , phi[i] = i - 1 , mu[i] = Sub(0 , 1);
		for (int j = 1; j <= cnt && prim[j] * i <= N; ++j) {
			Is_pr[i * prim[j]] = 1;
			if(i % prim[j] == 0) {
				phi[i * prim[j]] = phi[i] * prim[j];
				break;
			}
			phi[i * prim[j]] = phi[i] * (prim[j] - 1);
			mu[i * prim[j]] = Mul(Sub(0 , 1) , mu[i]);
		}
		S1[i] = Add(S1[i - 1] , phi[i]);
		S2[i] = Add(S2[i - 1] , Mul(phi[i] , i));
	}
}

int val1[MAXN] , val2[MAXN] , h1[MAXN] , h2[MAXN] , f[MAXN];

int main() {
	pre();
	
	int n;
	read(n);
	
	for (int d = 1; d <= n; ++d) {
		for (int i = d; i <= n; i += d) {
			val1[i] = Add(val1[i] , Mul(d , S1[i / d]));
			if(i + d <= n) val1[i + d] = Sub(val1[i + d] , Mul(d , S1[i / d]));
			val2[i] = Add(val2[i] , Mul(Mul(d , d) , S2[i / d]));
			if(i + d <= n) val2[i + d] = Sub(val2[i + d] , Mul(Mul(d , d) , S2[i / d]));
		}
		val1[d] = Add(val1[d - 1] , val1[d]);
		val2[d] = Add(val2[d - 1] , val2[d]);
	}
	
	for (int D = 1; D <= n; ++D) if(mu[D]) {
		for (int i = D; i <= n; i += D) {
			h1[i] = Add(h1[i] , Mul(Mul(D , mu[D]) , val1[i / D]));
			h2[i] = Add(h2[i] , Mul(Mul(Mul(D , D) , mu[D]) , val2[i / D]));
		}
	}
	
	for (int T = 1; T <= n; ++T) {
		for (int i = T; i <= n; i += T) {
			f[i] = Add(f[i] , Mul(i , h1[i / T]));
			f[i] = Sub(f[i] , Mul(T , h2[i / T]));
		}
		write(f[T] , ' ');
	}
	puts("");
	
	return 0;
}
```

---

## 作者：Rainybunny (赞：2)

&emsp;&emsp;提供一个太长不看版, 你也可以在 [Solution Set](https://www.cnblogs.com/rainybunny/p/17367148.html) \#14 查看.

-   [Link](https://www.luogu.com.cn/problem/P9308) & [Submission](https://www.luogu.com.cn/record/109346415).
-   「A.数学-数论」

$$
\begin{aligned}
	f(n) &= \sum_{i=1}^n\sum_{j=1}^n\sum_{k=1}^n[i+j+k=n]\operatorname{lcm}(i,\gcd(j,k))\quad(1)\\
	&= \sum_{i=1}^{n-2}\sum_{d\mid (n-i)\land d<n-i}\operatorname{lcm}(i,d)\varphi((n-i)/d)\quad(2)\\
	&= \sum_{i=1}^n\sum_{d\mid i}[d\neq i]\frac{(n-i)d}{\gcd(n,d)}\cdot\varphi(i/d)\quad(3)\\
	&= n\sum_{d=1}^n\frac{d}{\gcd(n,d)}S_1(n/d)-\sum_{d=1}^n\frac{d^2}{\gcd(n,d)}S_2(n/d)\quad(4)\\
	&= n\sum_{T\mid n}\sum_{t\mid T}\mu(t)t\sum_{d=1}^{n/T}dS_1(n/(dT))-\sum_{T\mid n}T\sum_{t\mid T}\mu(t)t\sum_{d=1}^{n/T}d^2S_2(n/(dT))\quad(5).
\end{aligned}
$$

&emsp;&emsp;上面是草稿. 解释一下:

&emsp;&emsp;$(2)$ 中 $\varphi((n-i)/d)$ 即 $\sum_{j,k}[j+k=n-i][j\perp k]$ 化简的结果.

&emsp;&emsp;$(3)$ 中 $i$ 转而枚举 $(2)$ 中的 $n-i$; 实际上应当有 $2\le n-i\le n-1$, 但是 $[d\neq i]\times(n-i)$ 已经处理掉这一条件带来的非法贡献了; $\gcd(n-i,d)=\gcd(n-i+kd,d)=\gcd(n,d)$.

&emsp;&emsp;$(4)$ 中,
$$
S_1(m)=\sum_{i=2}^m\varphi(i),~S_2(m)=\sum_{i=2}^mi\varphi(i),
$$
注意其求和下指标, 这里已经去除了 $d=i$ 的贡献.

&emsp;&emsp;$(5)$ 中, 通过莫反引入了 $T,t$ 的枚举. $T/t$ 枚举钦定的 $\gcd$, $t$ 枚举是 $n,d$ 的公因子但没被 $T/t$ 枚举的部分, $T$ 即二者乘积.

&emsp;&emsp;最后的式子中, 乘积式的最后一项求和可以写作 $T_1(n/T)$ 和 $T_2(n/T)$ 的形式. 到此, 预处理所有需要的中间函数, 可以 $\mathcal O(n\log n)$ 求解.

---

## 作者：zhenghanyun (赞：1)

这题被放到了校内 NOIp 模拟赛 T3，不会巧妙做法，暴力推了 $2$ 个多小时的式子过了，写篇题解纪念一下。

Upd on 2024-09-21：修改了一处笔误。

Upd on 2024-09-24：再次修改一处笔误。（~~由于这是一篇数学题题解，所以笔误有点多也是难免的~~）

题目链接：[Link](https://www.luogu.com.cn/problem/P9308)

## 题意简述

对于 $1 \le n \le 10 ^ 6$，求出下式的值：

$$f(n) = \sum \limits_{i = 1} ^ n \sum \limits_{j = 1} ^ n \sum \limits_{k = 1} ^ n [i + j + k = n] \operatorname{lcm}(i, \gcd(j, k))$$

## Step 1

首先，注意到枚举 $j, k$ 的值是不必要的，我们只关心 $j + k$ 和 $\gcd(j, k)$ 的值。

考虑当我们确定 $a = j + k$，$b = \gcd(j, k)$ 后，可能的 $(j, k)$ 对数，不难发现是 $\varphi(\frac{a}{b})$，其中 $b \mid a$ 且 $b \ne a$。

于是

$$f(n) = \sum \limits_{i = 1} ^ n \sum \limits_{d \mid n - i} \varphi(\frac{n - i}{d}) \operatorname{lcm}(i, d)$$

直接计算，时间复杂度视实现为 $\mathcal{O}(n ^ 2 \log ^ 2 n)$ 或 $\mathcal{O}(n ^ 2 \log n)$，可以获得 $20$ 分。

## Step 2

考虑调换 $d$ 和 $\frac{n - i}{d}$，得

$$f(n) = \sum \limits_{i = 1} ^ n \sum \limits_{d \mid n - i} \varphi(d) \operatorname{lcm}(i, \frac{n - i}{d})$$

然后转变枚举对象，枚举 $n - i$ 而不是 $i$，得

$$f(n) = \sum \limits_{i = 1} ^ n \sum \limits_{d \mid i} \varphi(d) \operatorname{lcm}(n - i, \frac{i}{d})$$

进一步调换求和顺序，枚举 $i$ 是 $d$ 的几倍，得

$$f(n) = \sum \limits_{d = 1} ^ n \varphi(d) \sum \limits_{i = 1} ^ {\lfloor \frac{n}{d} \rfloor} \operatorname{lcm}(n - id, i)$$

接着枚举 $\gcd(n - id, i)$，打开 $\operatorname{lcm}$，得

$$f(n) = \sum \limits_{d = 1} ^ n \varphi(d) \sum \limits_{i = 1} ^ {\lfloor \frac{n}{d} \rfloor} \sum \limits_{k = 1} ^ n [\gcd(n - id, i) = k] \frac{(n - id)i}{k}$$

调换求和顺序，注意到 $\gcd(n - id, i) = \gcd(n, i)$，枚举 $i$ 是 $k$ 的几倍，得

$$f(n) = \sum \limits_{k \mid n} \sum \limits_{d = 1} ^ n \varphi(d) \sum \limits_{i = 1} ^ {\lfloor \frac{n}{kd} \rfloor} [\gcd(\frac{n}{k}, i) = 1] (n - ikd)i$$

这个时候调换 $k$ 和 $\frac{n}{k}$，得

$$f(n) = \sum \limits_{k \mid n} \sum \limits_{d = 1} ^ n \varphi(d) \sum \limits_{i = 1} ^ {\lfloor \frac{k}{d} \rfloor} [\gcd(k, i) = 1] (n - \frac{nid}{k})i$$

中间的 $[\gcd(k, i) = 1]$ 直接用莫比乌斯反演的经典结论，得

$$f(n) = \sum \limits_{k \mid n} \sum \limits_{d = 1} ^ n \varphi(d) \sum \limits_{i = 1} ^ {\lfloor \frac{k}{d} \rfloor} \sum \limits_{s \mid k, s \mid i} \mu(s) (n - \frac{nid}{k})i$$

套路调换求和顺序，枚举 $k, i$ 是 $s$ 的几倍，得

$$f(n) = \sum \limits_{s \mid n} (\mu(s) \cdot s) \sum \limits_{k \mid \frac{n}{s}} \sum \limits_{d = 1} ^ n \varphi(d) \sum \limits_{i = 1} ^ {\lfloor \frac{k}{d} \rfloor} (n - \frac{nid}{k})i$$

我们把后半部分拿出来：

$$\sum \limits_{d = 1} ^ n \varphi(d) \sum \limits_{i = 1} ^ {\lfloor \frac{k}{d} \rfloor} (n - \frac{nid}{k})i = \sum \limits_{d = 1} ^ n \varphi(d) (n(\sum \limits_{i = 1} ^ {\lfloor \frac{k}{d} \rfloor} i) - \frac{nd}{k}(\sum \limits_{i = 1} ^ {\lfloor \frac{k}{d} \rfloor} i ^ 2))$$

令

$$g(n) = \sum \limits_{i = 1} ^ n i = \frac{i(i + 1)}{2}$$

$$h(n) = \sum \limits_{i = 1} ^ n i ^ 2 = \frac{n(n + 1)(2n + 1)}{6}$$

则后半部分写为

$$\sum \limits_{d = 1} ^ n \varphi(d) (n \cdot g(\lfloor \frac{k}{d} \rfloor) - \frac{nd}{k} \cdot h(\lfloor \frac{k}{d} \rfloor))$$

使用乘法分配律将 $\varphi(d)$ 乘进求和式里，得

$$\sum \limits_{d = 1} ^ n (n \cdot \varphi(d) \cdot g(\lfloor \frac{k}{d} \rfloor) - \frac{nd \cdot \varphi(d)}{k} \cdot h(\lfloor \frac{k}{d} \rfloor))$$

拆分成两部分，令

$$P = \sum \limits_{d = 1} ^ n (n \cdot \varphi(d) \cdot g(\lfloor \frac{k}{d} \rfloor))$$

$$Q = \sum \limits_{d = 1} ^ n (\frac{nd \cdot \varphi(d)}{k} \cdot h(\lfloor \frac{k}{d} \rfloor))$$

将两部分化简，分离常数项和变量（暂时视 $k$ 为常数项），得

$$P = n \sum \limits_{d = 1} ^ n \varphi(d) \cdot g(\lfloor \frac{k}{d} \rfloor)$$

$$Q = \frac{n}{k} \sum \limits_{d = 1} ^ n d \cdot \varphi(d) \cdot h(\lfloor \frac{k}{d} \rfloor)$$

不难发现 $P, Q$ 都可以使用整除分块在 $\mathcal{O}(\sqrt n)$ 的时间复杂度内计算。

带入原式计算，时间复杂度为 $\mathcal{O}(n \sqrt n \log ^ 2 n)$，可以获得 $40$ 分。

## Step 3

注意到 Step 2 中得到的 $P, Q$ 是只与 $k$ 有关的函数，是可以预处理的。

那么时间复杂度变为 $\mathcal{O}(n \sqrt n + n \log ^ 2 n)$，可以获得 $60$ 分。

## Step 4

我们暂时不去考虑如何快速预处理 $P(k), Q(k)$，先思考如何将后半部分的复杂度从 $2 \log$ 优化到 $1 \log$。

首先将 $P(k), Q(k)$ 带回原式，得

$$f(n) = \sum \limits_{s \mid n} (\mu(s) \cdot s) \sum \limits_{k \mid \frac{n}{s}} (P(k) - Q(k))$$

然后可以预处理，令

$$R(n) = \sum \limits_{k \mid n} (P(k) - Q(k))$$

可以在 $\mathcal{O}(n \log n)$ 的时间复杂度内完成这个预处理。

那么

$$f(n) = \sum \limits_{s \mid n} (\mu(s) \cdot s) R(\frac{n}{s})$$

也可以 $\mathcal{O}(n \log n)$ 计算。

时间复杂度 $\mathcal{O}(n \sqrt n + n \log n)$，瓶颈在于预处理 $P(k), Q(k)$。

## Step 5

接下来只需要实现快速预处理 $P(k), Q(k)$ 的值即可。

以 $P(k)$ 为例，由上式

$$P(k) = \sum \limits_{d = 1} ^ n (n \cdot \varphi(d) \cdot g(\lfloor \frac{k}{d} \rfloor))$$

假如我们去枚举 $d$，对每个 $k$ 计算贡献，那么对于 $\lfloor \frac{k}{d} \rfloor$ 相同的贡献相同。

这样直接枚举 $\lfloor \frac{k}{d} \rfloor$ 的值，就将原问题转化为了 $\mathcal{O}(n \log n)$ 段区间加。

直接使用差分即可。

预处理 $Q(k)$ 同理，需要注意的是先不要计算前面的系数 $\frac{1}{k}$，最后再乘进来。

自此，时间复杂度已经做到了严格的 $\mathcal{O}(n \log n)$。

代码很好写，自己写得比较丑，就不放了。

---

## 作者：win114514 (赞：1)

### 思路

没有脑子怎么办，使用纯套路解决这道题。

$$\begin{aligned}
&=\sum_{i=1}^n\sum_{j=1}^n\sum_{k=1}^n[i+j+k=n] \operatorname{lcm}(i,\gcd(j,k))\\
&=\sum_{i=1}^n\sum_{j=1}^n\sum_{k=1}^n[i+j+k=n]\sum_{d=1}^n \operatorname{lcm}(i,d)[\gcd(j,k)=d]&(\text{枚举 gcd})\\
&=\sum_{d=1}^n \sum_{i=1}^n\sum_{j=1}^{\frac{n}{d}}\sum_{k=1}^{\frac{n}{d}}[i+jd+kd=n]\operatorname{lcm}(i,d)[\gcd(j,k)=1]\\
&=\sum_{d=1}^n \sum_{i=1}^n\sum_{j=1}^{\frac{n}{d}}\sum_{k=1}^{\frac{n}{d}}[i+jd+kd=n]\operatorname{lcm}(i,d)\sum_{p|\gcd(j,k)}\mu(p)\\
&=\sum_{d=1}^n \sum_{p=1}^n \mu(p) \sum_{j=1}^{\frac{n}{dp}}\sum_{k=1}^{\frac{n}{dp}}[j+k\le \frac{n}{dp}]\operatorname{lcm}(n-jdp-kdp,d)\\
\end{aligned}$$

令 $T=dp$。

$$\begin{aligned}
&=\sum_{T=1}^n \sum_{d|T} \sum_{j=1}^{\frac{n}{T}}\sum_{k=1}^{\frac{n}{T}}[j+k\le \frac{n}{T}]\operatorname{lcm}(n-jT-kT,d)\mu(\frac{T}{d})\\
&=\sum_{T=1}^n \sum_{d|T} \sum_{j=1}^{\frac{n}{T}}\sum_{k=1}^{j-1}\operatorname{lcm}(n-jT,d)\mu(\frac{T}{d})&(\text{枚举 j+k 和 j})\\
&=\sum_{T=1}^n \sum_{d|T} \mu(\frac{T}{d}) \sum_{j=1}^{\frac{n}{T}}\operatorname{lcm}(n-jT,d)(j-1)\\
&=\sum_{T=1}^n \sum_{d|T} \mu(\frac{T}{d}) \sum_{j=1}^{\frac{n}{T}}\frac{(n-jT)d(j-1)}{\gcd(n-jT,d)}&(\text{拆开 lcm})\\
\end{aligned}$$

注意到 $d|T$，所以有 $\gcd(n-jT,d)=\gcd(n,d)$。

$$\begin{aligned}
&=\sum_{T=1}^n \sum_{d|T} \mu(\frac{T}{d}) \sum_{j=1}^{\frac{n}{T}}\frac{(n-jT)d(j-1)}{\gcd(n,d)}\\
&=\sum_{T=1}^n \sum_{d|T} \mu(\frac{T}{d})d \sum_{j=1}^{\frac{n}{T}}\frac{(n-jT)(j-1)}{\gcd(n,d)}\\
&=\sum_{T=1}^n \sum_{d|T} \mu(\frac{T}{d})\frac{d}{\gcd(n,d)} \sum_{j=1}^{\frac{n}{T}}(n-jT)(j-1)\\
\end{aligned}$$

令 $S(x)=1+\cdots +x,S2(x)=1^2+\cdots+x^2$。

$$\begin{aligned}
&=\sum_{T=1}^n \sum_{d|T} \mu(\frac{T}{d})\frac{d}{\gcd(n,d)} \sum_{j=1}^{\frac{n}{T}}(n-jT)(j-1)\\
&=\sum_{T=1}^n \sum_{d|T} \mu(\frac{T}{d})\frac{d}{\gcd(n,d)} \sum_{j=1}^{\frac{n}{T}}nj-n-j^2T+jT\\
&=\sum_{T=1}^n \sum_{d|T} \mu(\frac{T}{d})\frac{d}{\gcd(n,d)} F(n,T)\\
\end{aligned}$$

其中：

$$\begin{aligned}
F(n,T)&=nS(\frac{n}{T})-n(\frac{n}{T})-TS2(\frac{n}{T})+TS(\frac{n}{T})
\end{aligned}$$

这样的式子已经可以获得 $20\text{pts}$ 的高分了。

$$\begin{aligned}
&=\sum_{T=1}^n \sum_{d|T} \mu(\frac{T}{d})\frac{d}{\gcd(n,d)} F(n,T)\\
&=\sum_{p=1}^n\sum_{T=1}^n \sum_{d|T} \mu(\frac{T}{d})\frac{d}{p}[\gcd(n,d)=p] F(n,T)&(\text{传统艺能})\\
&=\sum_{p=1}^n[p|n]\sum_{T=1}^n \sum_{d|T,p|d} \mu(\frac{T}{d})\frac{d}{p}[\gcd(n,d)=1] F(n,T)\\
&=\sum_{p=1}^n[p|n]\sum_{T=1}^n \sum_{d|T,p|d} \mu(\frac{T}{d})\frac{d}{p}\sum_{k|\gcd(n,d)}\mu(k) F(n,T)\\
&=\sum_{p=1}^n\sum_{k=1}^n\mu(k)[pk|n]\sum_{T=1}^n \sum_{d|T,pk|d} \mu(\frac{T}{d})\frac{d}{p}F(n,T)\\
\end{aligned}$$

令 $H=pk$。

$$\begin{aligned}
&=\sum_{H|n}\sum_{k|H}\mu(k)\sum_{T=1}^n \sum_{d|T,H|d} \mu(\frac{T}{d})\frac{d}{p}F(n,T)\\
&=\sum_{H|n}\sum_{k|H}\mu(k)\sum_{T=1}^{\frac{n}{H}} \sum_{d|T} \mu(\frac{TH}{dH})\frac{dH}{p}F(n,TH)\\
&=\sum_{H|n}\sum_{k|H}\mu(k)\sum_{T=1}^{\frac{n}{H}} \sum_{d|T} \mu(\frac{T}{d})dkF(n,TH)\\
&=\sum_{H|n}\sum_{T=1}^{\frac{n}{H}}F(n,TH)\sum_{k|H}\mu(k) \sum_{d|T} \mu(\frac{T}{d})dk\\
&=\sum_{H|n}\sum_{T=1}^{\frac{n}{H}}F(n,TH)\sum_{k|H}\mu(k)k \sum_{d|T} \mu(\frac{T}{d})d\\
\end{aligned}$$

令 $G1(x)=\sum_{d|x}\mu(\frac{x}{d})d=\varphi(x),G2(x)=\sum_{d|x}\mu(x)x$。

$$\begin{aligned}
&=\sum_{H|n}\sum_{T=1}^{\frac{n}{H}}F(n,TH)\sum_{k|H}\mu(k)k \sum_{d|T} \mu(\frac{T}{d})d\\
&=\sum_{H|n}\sum_{T=1}^{\frac{n}{H}}F(n,TH)G1(T)G2(H)\\
\end{aligned}$$

这个式子就非常的简洁，可以获得 $40\text{pts}$ 的高分了。

$$\begin{aligned}
&=\sum_{H|n}\sum_{T=1}^{\frac{n}{H}}F(n,TH)G1(T)G2(H)\\
&=\sum_{H|n}G2(H)\sum_{T=1}^{\frac{n}{H}}F(n,TH)G1(T)\\
&=\sum_{H|n}G2(H)\sum_{T=1}^{\frac{n}{H}}((n+TH)S(\frac{n}{TH})-n(\frac{n}{TH})-THS2(\frac{n}{TH}))G1(T)\\
&=\sum_{H|n}G2(H)\sum_{T=1}^{\frac{n}{H}}H((\frac{n}{H}+T)S(\frac{n}{TH})-\frac{n}{H}(\frac{n}{TH})-TS2(\frac{n}{TH}))G1(T)\\
&=\sum_{H|n}G2(H)H\sum_{T=1}^{\frac{n}{H}}((\frac{n}{H}+T)S(\frac{n}{TH})-\frac{n}{H}(\frac{n}{TH})-TS2(\frac{n}{TH}))G1(T)\\
&=\sum_{H|n}G2(H)HG(\frac{n}{H})\\
\end{aligned}$$

其中：

$$\begin{aligned}
G(n)=\sum_{T=1}^{n}((n+T)S(\frac{n}{T})-n(\frac{n}{T})-TS2(\frac{n}{T}))G1(T)
\end{aligned}$$

只需要计算 $G(n)$ 即可。

$$\begin{aligned}
G(n)&=\sum_{T=1}^{n}((n+T)S(\frac{n}{T})-n(\frac{n}{T})-TS2(\frac{n}{T}))G1(T)\\
&=\sum_{T=1}^{n}-n\varphi(i)(\frac{n}{i})+n\varphi(i)S(\frac{n}{i})+i\varphi(i)S(\frac{n}{i})-i\varphi(i)S2(\frac{n}{i})\\
&=\sum_{T=1}^{n}\frac{(3(\frac{n}{i})^2-3(\frac{n}{i}))n-(2(\frac{n}{i})^3-2(\frac{n}{i}))i}{6}\\
\end{aligned}$$

容易发现，预处理 $\varphi(i),i\varphi(i)$ 前缀和，可以使用整除分块做到 $O(n\sqrt n)$。

可以获得 $60\text{pts}$ 的高分。

但实际上在算 $1\sim n$ 所有的整除分块的时候，我们有更加优秀的做法。

具体来说。

枚举 $i$ 与 $d=n/i$。

那么对应的 $n$ 要满足 $id\le n\le i(d+1)-1$。

这样就可以直接用前缀和计算。

至此，所有的东西都可以用最多调和级数的复杂度计算。

时间复杂度：$O(n\ln n)$。

### Code

```cpp
/*
  ! 如果没有天赋，那就一直重复
  ! Created: 2024/05/24 10:38:16
*/
#include <bits/stdc++.h>
using namespace std;

#define fro(i, x, y) for (int i = (x); i <= (y); i++)
#define pre(i, x, y) for (int i = (x); i >= (y); i--)

const int N = 1e6 + 10;
const int mod = 998244353;

using i64 = long long;

int n, ct;
int vs[N], pr[N], mu[N];
i64 sm[N], fm[N], g1[N], g2[N], p1[N], p2[N], d2[N], d3[N], ans;
vector<int> to[N];

signed main() {
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> n, mu[1] = 1;
  fro(i, 2, n) {
    if (!vs[i]) pr[++ct] = i, mu[i] = -1;
    for (int j = 1; j <= ct && pr[j] * i <= n; j++) {
      vs[i * pr[j]] = 1;
      if (i % pr[j] == 0) {
        mu[i * pr[j]] = 0;
        break;
      }
      mu[i * pr[j]] = -mu[i];
    }
  }
  fro(i, 1, n) {
    for (int j = i, k = 1; j <= n; j += i, k++) {
      g1[j] += i * mu[k];
      g2[j] += i * mu[i];
    }
    g1[i] = (g1[i] % mod + mod) % mod;
    g2[i] = (g2[i] % mod + mod) % mod;
    d2[i] = 1ll * i * i % mod;
    d3[i] = 1ll * i * d2[i] % mod;
  }
  fro(i, 1, n) {
    for (i64 k = 1, l = i, r = 2 * i; l <= n; l += i, r += i, k++) {
      if (r > n) r = n + 1;
      p1[l] += g1[i] * (3 * d2[k] - 3 * k);
      p1[r] -= g1[i] * (3 * d2[k] - 3 * k);
      p2[l] += g1[i] * (2 * d3[k] - 2 * k) * i;
      p2[r] -= g1[i] * (2 * d3[k] - 2 * k) * i;
    }
  }
  fro(i, 1, n) {
    p1[i] = (p1[i] + p1[i - 1]) % mod;
    p2[i] = (p2[i] + p2[i - 1]) % mod;
    sm[i] = (p1[i] * i - p2[i]) % mod;
    sm[i] = (sm[i] % mod + mod) % mod;
    sm[i] = (sm[i] * 166374059) % mod;
  }
  fro(i, 1, n) {
    for (int j = i, k = 1; j <= n; j += i, k++)
      (fm[j] += i * g2[i] % mod * sm[k]) %= mod;
    cout << fm[i] % mod << " \n"[i == n];
  }
  return 0;
}
```

---


# [NOI2023] 贸易

## 题目描述

近年来，A 国的商贸发展迅猛，但国内的道路建设却跟不上步伐，明显成为了人们贸易往来的限制，管理者为此费尽了心思。

具体而言，A 国共有 $2^n-1$ 个城市，其中 $1$ 号城市为首都。对于所有的非首都城市 $i$，都有一条**单向**道路从城市 $i$ 出发，到达城市 $\lfloor \frac{i}{2} \rfloor$。为方便起见，称这样的道路为“第一类道路”，称城市 $\lfloor \frac{i}{2} \rfloor$ 为城市 $i$ 的“上级城市”。

除此之外，还有 $m$ 条**单向**道路，设其中第 $i$ 条道路从城市 $u_i$ 出发，到达城市 $v_i$，这样的道路都有一个特殊性质：从城市 $v_i$ 出发，沿着第一类道路不断向“上级城市”走去，最终总能走到城市 $u_i$。称这样的道路为“第二类道路”。

每一条道路都有相应的长度值。由此，对于 A 国的任意两个城市 $x$ 和 $y$，都可以计算出从城市 $x$ 出发，沿道路走到城市 $y$，所经过的道路的长度之和的最小值，将这一数值记为 $dist(x,y)$。但由于 A 国的道路建设存在严重缺陷，从城市 $x$ 出发可能根本到达不了城市 $y$，此时定义 $dist(x,y)=0$。同时一个城市出发到自己是不需要经过任何道路的，因此定义 $dist(x,x)=0$。

现在管理者希望计算出这些 $dist(x,y)$ 的值，以便合理衡量人们贸易往来的便捷程度。但由于 A 国的城市数量太多，将这些值一一列出的工作量太大，因此管理者只希望求出所有 $dist(x,y)$ 值之和，也就是 $\sum_{x=1}^{2^n-1}{\sum_{y=1}^{2^n-1}{dist(x,y)}}$，并希望请你来帮忙。

## 说明/提示

**【数据范围】**

对于所有测试数据保证：$2 \le n \le 18$，$1 \le m \le 2 ^ n$，$1 \le u, v \le 2 ^ n - 1$，$1 \le a_i, w \le 10 ^ 9$。

| 测试点编号 | $n$ | $m$ | 是否有特殊性质 |
| :---: | :---: | :---: | :---: |
| $1\sim 2$ | $=8$ | $\le 256$ | 否 |
| $3\sim 4$ | $=9$ | $\le 512$ | 否 |
| $5\sim 8$ | $=12$ | $\le 4,096$ | 否 |
| $9$ | $=16$ | $\le 10$ |  否|
| $10$ | $=16$ | $\le 50$ | 否 |
| $11$ | $=16$ | $\le 100$ | 否 |
| $12$ | $=16$ | $\le 65,536$ | 是 |
| $13\sim 15$ | $=16$ | $\le 65,536$ | 否 |
| $16\sim 17$ | $=18$ | $\le 262,144$ | 是 |
| $18\sim 20$ | $=18$ | $\le 262,144$ | 否 |

特殊性质：保证每一条“第二类道路”都是从首都（城市 $1$）出发。

## 样例 #1

### 输入

```
2 1
2 1
1 2 2```

### 输出

```
8```

## 样例 #2

### 输入

```
见附件中的 trade/trade2.in。```

### 输出

```
见附件中的 trade/trade2.ans。```

## 样例 #3

### 输入

```
见附件中的 trade/trade3.in。```

### 输出

```
见附件中的 trade/trade3.ans。```

## 样例 #4

### 输入

```
见附件中的 trade/trade4.in。```

### 输出

```
见附件中的 trade/trade4.ans。```

# 题解

## 作者：StarLbright40 (赞：37)

Dijkstra 什么的看不懂啦（

贡献一个 1kb 精品解法。

------------

对于本题，显然有 $dep_u=\log_2u$，$siz_u=2^{n-dep_u}-1$。

由于本题没有横叉边，所以每对 $u\to v$ 显然可以拆成 $u\to\text{lca}(u,v)\to v$ 计算。

对于 $u\to\text{lca}(u,v)$ 的部分，由于第二类边均为前向边，于是此时若经过第二类边则路径一定形成环，而边权均为正，所以此时一定劣。由此这部分一定只会经过第一类边也即树边，从而这是平凡的。

接下来我们处理 $\text{lca}(u,v)\to v$ 的部分。

定义 $f_{u,i}$ 表示从点 $u$ 的满足 $dep_v=i$ 的祖先 $v$ 到 $u$ 的最短路。

首先考虑仅经过一条第二类边的情形。对于一条 $u\to v$ 的第二类边，它可以更新所有祖孙关系形如 $u\to x\to y\to v$ 的 $f_{y,dep_x}$。

再拓展到所有情形，发现这一过程与 Floyd 类似。从而枚举中转点同时注意使用恰当的枚举顺序即可。

时间复杂度为 $\mathcal O(n^2(m+2^n))=\mathcal O(n^22^n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=18,mod=998244353;const long long inf=1e18;
int n,m,a[1<<N],ans;long long dis[1<<N],sum[1<<N],f[1<<N][N];
int siz(int x){return (1<<(n-__lg(x)))-1;}
long long val(int x){return sum[x]+1ll*siz(x)*a[x];}
int main(){
	cin.tie(0)->sync_with_stdio(0);
	cin>>n>>m;
	for(int i=2;i<1<<n;++i)
		cin>>a[i],dis[i]=dis[i>>1]+a[i];
	for(int i=(1<<n)-1;i>1;--i)
		sum[i>>1]+=val(i);
	memset(f,63,sizeof(f));
	for(int u,v,w;m--;){
		cin>>u>>v>>w;
		for(int y=v;y>u;y>>=1) for(int x=y>>1;x>=u;x>>=1)
			f[y][__lg(x)]=min(f[y][__lg(x)],w+dis[v]-dis[y]+dis[x]-dis[u]);
	}
	for(int u=1;u<1<<n;++u)
		for(int i=__lg(u)-1,v=u>>1;v;--i,v>>=1) for(int j=i-1;~j;--j)
			f[u][j]=min(f[u][j],f[u][i]+f[v][j]);
	for(int u=(1<<n)-1;u;--u){
		ans=(ans+sum[u])%mod;
		for(int i=__lg(u)-1,v=u;v>1;--i,v>>=1) if(f[u][i]<inf)
			ans=(ans+f[u][i]%mod*(siz(v)+1)+val(v^1))%mod;
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：童年的小翼龙 (赞：21)

评蓝是否有点太低的说（

-------------------

考虑对于每一个点 $u$，计算所有点到它的最短路的和。

- 对于 $u$ 子树内的点，显然不会走第二类道路。将 $u$ 子树内所有点到 $u$ 的最短路的和记为 $g_u$。
- 对于 $u$ 子树外的点，必须走第二类道路。由于第二类道路只由祖先通向儿子，所以对于这些点，想要到达 $u$，必须到达 $u$ 的某个祖先，才能到达 $u$。我们将这样的贡献和记作 $h_u$。

$g_u$ 可以通过一次**树 dp** 进行计算。

难点在于对于 $h_u$ 的计算。我们发现，一个 $u$ 子树外的点 $v$ 想要到达 $u$，必须先到达 $u$ 和 $v$ 的 $\operatorname{lca}$，于是我们可以对于 $u$ 的每个祖先 $t$，计算在 $t$ 子树中而不在 $t$ 的那个子树中包含 $u$ 的儿子的子树中的所有点的贡献。即对于 $t$，计算红圈中的点的贡献。  
[![pPSeA6f.png](https://s1.ax1x.com/2023/07/29/pPSeA6f.png)](https://imgse.com/i/pPSeA6f)  
记这些点到 $t$ 最短路的和为 $f$，数量为 $size$，则这些点对 $h_u$ 的贡献为 $f+size\times \operatorname{dis}(t,u)$，其中 $\operatorname{dis}(t,u)$ 表示 $t$ 到 $u$ 的最短路。

发现我们需要对于每个点，计算它到它的子树内的所有点的最短路。

由题目描述可知，树高为 $n$。

我们假设在计算 $u$ 到子树内的最短路的时候，$u$ 的父亲 $fa$ 已经计算完了，则对于所有 $u$ 子树内的点 $v$，可以先令 $\operatorname{dis}(u,v)=\operatorname{dis}(fa,v)$，即从 $u$ 的祖先，通过第二类边走入 $u$ 子树。然后只考虑 $u$ 子树内的所有点，跑一遍最短路。由于树高为 $n$，所以每个点最多跑 $n$ 次最短路，使用 dijkstra 算法，则总的时间复杂度为 $O(2^n n^2)$。

有一些细节，例如在枚举 $u$ 的 $O(n)$ 个祖先 $t$ 贡献 $h_u$ 的时候，若 $\operatorname{dis}(t,u)=\infty$，即不可达，由于 $\operatorname{dis}(t,u)$ 最开始是从 $t$ 父亲转移过来的，所以从 $t$ 开始的所有祖先都到达不了 $u$，```break``` 即可。

-----------------

赛场 AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Slongod{
using ll = long long;
const int N = 3e5+5 , mod = 998244353;
const ll inf = 0x3f3f3f3f3f3f3f3fll;

int n , m , econt , num;
int a[N] , head[N] , g[N] , h[N] , size[N] , dfn[N] , mx[N] , reid[N] , flag[N] , dep[N];
ll f[20][N];
struct EDGE{int to , nxt , w;}edge[N];
void add(int x , int y , int w){edge[++econt].to = y; edge[econt].nxt = head[x]; edge[econt].w = w; head[x] = econt;}
void dij(int s , ll dis[])
{
    int fa = s/2;
    for (int i = dfn[s]; i <= mx[s]; i++){flag[reid[i]] = 0; dis[reid[i]] = min(f[dep[fa]][reid[i]] + a[s] , inf);}
    priority_queue <pair<ll,int> , vector<pair<ll,int>> , greater<pair<ll,int>>> q;
    q.push(make_pair(0ll , s)); dis[s] = 0;
    while(!q.empty()) {
        int u = q.top().second; q.pop();
        if (flag[u]){continue;} flag[u] = 1;
        for (int i = head[u]; i; i = edge[i].nxt) {
            int v = edge[i].to; ll w = edge[i].w;
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                q.push(make_pair(dis[v] , v));
            }
        }
        if (u != s) {
            int v = u/2; ll w = a[u];
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                q.push(make_pair(dis[v] , v));
            }
        }
    }
}
#define ls u*2
#define rs u*2+1
void dfs1(int u)
{
    size[u] = 1; dfn[u] = ++num; reid[num] = u; dep[u] = dep[u/2] + 1;
    if (ls <= n){dfs1(ls); size[u] += size[ls]; g[u] = (1ll * g[u] + g[ls] + 1ll * size[ls] * a[ls] % mod) % mod;}
    if (rs <= n){dfs1(rs); size[u] += size[rs]; g[u] = (1ll * g[u] + g[rs] + 1ll * size[rs] * a[rs] % mod) % mod;}
    mx[u] = num;
}
void dfs2(int u)
{
    int t = u;
    while(t != 1) {
        if (f[dep[t/2]][u] == inf){break;}
        h[u] = (1ll * h[u] + (1ll * g[t/2] - g[t] + mod - 1ll * size[t] * a[t] % mod + mod) % mod + 1ll * (size[t/2] - size[t]) * f[dep[t/2]][u] % mod) % mod;
        t /= 2;
    }
    dij(u , f[dep[u]]);
    if (ls <= n){dfs2(ls);} if (rs <= n){dfs2(rs);}
}
#undef ls
#undef rs
int main()
{
    cin >> n >> m; n = (1 << n) - 1;
    for (int i = 2; i <= n; i++){cin >> a[i];}
    for (int i = 1 , a , b , c; i <= m; i++){cin >> a >> b >> c; add(a , b , c);}
    dfs1(1); memset(f[0] , 0x3f , sizeof(f[0])); dfs2(1);
    int ans = 0;
    for (int i = 1; i <= n; i++){ans = (1ll * ans + g[i] + h[i]) % mod;}
    cout << ans << '\n';
    return 0;
}
}int main()
{
    ios :: sync_with_stdio(0);
    cin.tie(0) , cout.tie(0);
    return Slongod :: main();
}
```

---

## 作者：璀璨星空1 (赞：17)

> 瓦砾生出的花朵 被火吞没 来不及凋落  
侵蚀的苍穹轮廓 锈迹斑驳 藏匿起群星线索

**我们给出一个易于实现的，时间复杂度 $\mathcal{O}(2^nn\log^*n)$ 的做法。**

以下做法的核心思想（第一节和第三节）是 zhoukangyang 教给我的，我们向他献上真挚的膜拜！

------

首先是常规的 $\mathcal{O}(2^nn^2)$ 做法。我们先做一些化简：

1. 我们把题目里的有向边全部反向，变成树边（从父亲到儿子）和返祖边（从后代到祖先）。

2. 类似 $\text{Johnson}$ 算法，我们标注一个点的势能 $d(u)=d\big(\text{Fa}(u)\big)+a(u)$，也就是这个点的带权深度。

   经过重新赋权，一条边 $u\to v$ 新的边权 $w'(u,v)=w(u,v)+d(u)-d(v)$。这意味着所有树边的边权都变成了 $0$，而返祖边的边权仍然一定是正数（因为加了一个正数）。

接下来定义 $\text{dis}(u,x)$ 表示**只使用两个端点都 $\in\text{subtree}(x)$ 的有向边**，从 $u$ 到 $x$ 的最短路（其中 $u\in\text{subtree}(x)$）。

在 $\mathcal{O}(2^nn^2)$ 做法中我们可以逐层松弛或者直接暴力 $\text{Dijkstra}$ 得到所有 $\text{dis}(u,x)$，对于一棵高度为 $k$、里面有 $E$ 条边的子树，这样做的时间复杂度是 $\mathcal{O}(2^kk+E)$（逐层松弛）或者 $\mathcal{O}(2^k+Ek)$（暴力 $\text{Dijkstra}$），总共的时间复杂度就是 $\mathcal{O}(2^nn^2)$。

假设我们已经得到了所有 $\text{dis}(u,x)$，最后就是统计答案。我们知道：
$$
\text{actual dis}(u,v)=\min\limits_{a\in\text{ancestor}\big(\text{lca}(u,v)\big)}\big\{\text{dis}(u,a)-d(u)+d(v)\big\}
$$
于是我们可以枚举 $u$，根据 $\text{lca}(u,v)$ 的值将原树划分为 $\leq n$ 棵子树。拿出其中一棵子树 $S$，由于 $\text{lca}$ 的值一定，我们有：
$$
\displaystyle\sum\limits_{v\in S}\text{actual dis}(u,v)=\Big(\min\limits_{a\in\text{ancestor}(\text{lca})}\big\{\text{dis}(u,a)\big\}-d(u)\Big)|S|-\displaystyle\sum\limits_{v\in S}d(v)
$$
显然统计答案是 $\mathcal{O}(2^nn)$ 的，不在时间复杂度瓶颈上。因此接下来我们要优化的是在一个子树内做单源最短路径的时间复杂度。

------

我们着眼于 $x=1$ 的子问题，这一节将其优化到 $\mathcal{O}(2^n+E\log n)$。其他子树的求解和 $\text{subtree}(1)$ 是完全一样的。

考虑从 $u\leadsto 1$ 的最短路。我们称「首先沿着树边往下走若干步，然后跳一次返祖边跳到比原来更高的地方」为一个步骤。那么从 $u$ 开始向上跳的过程必然可以分解为 $\leq n$ 个步骤，最后一个步骤返祖边直接跳到 $1$。

对于一条返祖边 $u\to v$，从 $u$ 的任何一个祖先出发都可以在一个步骤内到达 $v$。于是我们可以枚举 $u$ 的所有祖先 $i$，连一条 $i\to v$ 相同边权的边。这样拆出来的每条新边对应原来的一个步骤，我们向上跳的过程可以只考虑拆出来的这些新边。

**注意到两条 $u,v$ 都相同的新边可以只保留边权较小的一条。**我们来分析新边的总个数：

- 记 $h(u)$ 表示结点 $u$ 的不带权深度，其中 $h(1)=0$。
- 如果 $h(u)<n-\lfloor\log n\rfloor$，新边的数量不会超过 $\displaystyle\sum_{h(u)<n-\lfloor\log n\rfloor}h(u)\leq2^n$。
- 如果 $h(u)\geq n-\lfloor\log n\rfloor$，新边的数量不会超过 $E\lfloor\log n\rfloor$。

因此新边的总个数不会超过 $\mathcal{O}(2^n+E\log n)$。对于每条新边只需要做一次松弛，总时间复杂度也是 $\mathcal{O}(2^n+E\log n)$。

------

第二节我们将其优化到 $\mathcal{O}\big((2^n+E)\log^*n\big)$。

我们记 $m=\lfloor\log n\rfloor$。整棵树一共有 $n$ 层，这 $n$ 层的深度分别是 $[0,n-1]$。我们将这棵树从中间劈成两半，分成 $[0,n-m-1]$（上层）和 $[n-m,n-1]$（下层）两个部分。

自然的，拆出来的新边可以分成三种：(1) 从上层到上层的边；(2) 从下层到上层的边；(3) 从下层到下层的边。

从一个上层中的结点 $u$ 向上跳到 $1$ 的过程始终保持在上层。从一个下层中的结点 $u$ 向上跳到 $1$ 的过程则可以分成两个阶段，即位于下层的阶段和位于上层的阶段。一旦跳到一个上层结点就会始终保持在上层。

1. 对于上层中的每个结点 $u$ 求出正确的 $\text{dis}(u,1)$。

   由于第 $1$ 种新边的数量 $\leq2^n$，我们直接从上到下挨个松弛，这部分时间复杂度 $\mathcal{O}(2^n)$。

2. 对于下层中的每个结点 $u$ 求出 $\text{dis}(u,1)$ 表示**钦定第一步必须直接跳到上层，满足这个限制的最短路。**

   枚举每条 $u$ 在下层 $v$ 在上层的老边（不是新边！）$u\to v$，用 $u\to v$ 松弛之后直接做一遍子树 $\min$ 即可。暴力做子树 $\min$ 的时间复杂度 $\mathcal{O}(2^n)$。

3. 对于下层中的每个结点 $u$ 求出正确的 $\text{dis}(u,1)$。

   我们以第二步所得到的 $\text{dis}(u,1)$ 为初始值，每个高度为 $m$ 的子树可以看作一个独立的子问题。注意到每条 $u,v$ 都在下层的老边（不是新边！）只会隶属于恰好一棵高度为 $m$ 的子树，因此递归到的所有独立子问题的 $E'$ 之和不超过 $E$。

所以事实上我们不需要把所有新边都拆出来，只需要拆出来那些从上层到上层的新边即可。注意如果一条老边满足 $u$ 在下层 $v$ 在上层，从 $u$ 的 $h=n-\lfloor\log n\rfloor-1$ 的祖先开始也会拆出来一些新边。

分析该算法的时间复杂度。我们以 $\mathcal{O}(2^n+E)$ 的代价把 $n$ 变成了 $\log n$，当 $n=\mathcal{O}(1)$ 的时候可以直接暴力（逐层松弛）。因此总时间复杂度 $\mathcal{O}\big((2^n+E)\log^*n\big)$。

------

第三节：事实上该算法还有进一步优化的潜力。

对于这 $E$ 条返祖边中的一条 $u\to v$，当 $v$ 是一个上层结点的时候 $u\to v$ 会参与拆新边的过程，但是不会递归到任何一个高度 $\log n$ 子树的子问题中；当 $v$ 是一个下层结点的时候 $u\to v$ 会递归到任何一个高度 $\log n$ 子树的子问题中，但是不会参与拆新边的过程。因此实际情况是我们以 $2^n+E_0$ 的代价把 $T(n,E)$ 变成了 $2^{n-m}$ 个子问题 $T(m,E_{1,i})$，其中所有 $E_{1,i}$ 的总和等于 $E_1$，然后 $E_0+E_1=E$。

我们可以不总是设置 $m=\lfloor\log n\rfloor$。

具体来说，记 $F(x,y)$ 表示使用 $2^nx+Ey$ 单位时间，我们能做的最大的 $n$。

现在我们有 $2^nx+Ey$ 单位时间，我们设置 $m=F(x-2,y)$。那么 $2^{n-m}$ 个子问题的总时间消耗不超过 $2^n(x-2)+E_1y$。

$2^n(x-2)+E_1y$ 是第三步的代价，留给前两步的时间还有 $2^{n+1}+E_0y$。

我们可以不拆新边（拆新边的本质是逐层松弛），而是把上层也看作一个 $T(n-m,E_0)$ 的子问题。

假如 $n-m\leq F(2^m,y-1)$ 的话，我们就可以花 $2^n+E_0(y-1)$ 的时间处理出所有上层结点的 $\text{dis}(u,1)$。

注意由于我们要枚举所有 $v$ 在上层的边，还要暴力递推子树 $\min$，这里必须留出 $2^n+E_0$ 的时间。总共就是 $2^{n+1}+E_0y$。我们可以把一条边存在 $v$ 的 $\texttt{vector}$ 里，实现的时候先枚举 $\texttt{vector}$，这样可以避免访问到 $E_1$ 中的边。

最后我们得到 $F(x,y)=F(x-2,y)+F\big(2^{F(x-2,y)},y-1\big)$。

对于一个 $n$ 来说，我们找到最小的 $x$ 满足 $F(x,x)\geq n$，我们就可以在 $(2^n+E)x$ 单位时间内求解这个问题。

简单分析可得 $x=\mathcal{O}\big(\alpha(n)\big)$。因此总时间复杂度 $\mathcal{O}\big((2^n+E)\alpha(n)\big)$。

本人代码：https://uoj.ac/submission/665519

实现的是 $\mathcal{O}\big((2^n+E)\log^*n\big)$ 的版本。

---

## 作者：云浅知处 (赞：13)

发一个很人类的做法！

考虑枚举 $x,y$ 的 LCA，计算所有 $\text{LCA}(x,y)=z$ 的 $\text{dist}(x,y)$ 之和。

不妨设 $x$ 在 $z$ 的左子树内，$y$ 在 $z$ 的右子树内（$y\neq z$），则 $x\to y$ 的路径一定形如 $x\rightsquigarrow a\to b\rightsquigarrow y$，其中 $a$ 是 $z$ 的祖先，$b$ 在 $y$ 的子树内，三段路径的形态分别形如：

- $x\rightsquigarrow a$ 是一条由  $x$ 只经过第一类边到达 $a$ 的路径。显然此时一定不会去走第二类边。
- $a\to b$ 是一条二类边。
- $b\rightsquigarrow y$ 是若干条一类边和二类边。

进一步发现，对于一个确定的 $y$，左侧的每个 $x$ 到他要选择的这一条二类边 $a\to b$ 都是一样的。因此只需要在右侧跑 dijkstra，算出 $a\to b\rightsquigarrow y$ 这部分的贡献，再直接累加上 $x\rightsquigarrow a$ 部分的贡献即可。

时间复杂度 $O(n^22^n)$。

---

## 作者：do_while_true (赞：7)

这个做法目前在洛谷和 UOJ 都是独一档快的最优解，但是复杂度未知也不知道能不能卡掉。

$x$ 到其它点的 dis 总和就是加上 $x\to 1$ 权值为 $-dep_x$ 之后跑从 1 开始的最短路（这里 $dep$ 就是从自己到根的距离）再加上 $dis(x,1)\times cnt$ 其中 $cnt$ 是有多少点能够到达。再把 $x$ 到 $1$ 的链上的点这些算错的部分特殊处理一下。

也可以从类似物理中势能的角度理解，由于每个 $x$ 到 1 的最短路就是 $dep_x$，所以可以固定 $dis_1=0$ 为零势面，由于自己的最短路完全优于父亲的最短路，所以一个点多加的那条边给 $dis$ 带来的修改在完全处理完当前这棵子树之后进行撤销。

因为有负权边所以跑的 spfa。

```cpp
#include<cstdio>
#include<vector>
#include<queue>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<ctime>
#include<random>
#include<assert.h>
#define pb emplace_back
#define mp make_pair
#define fi first
#define se second
#define dbg(x) cerr<<"In Line "<< __LINE__<<" the "<<#x<<" = "<<x<<'\n'
#define dpi(x,y) cerr<<"In Line "<<__LINE__<<" the "<<#x<<" = "<<x<<" ; "<<"the "<<#y<<" = "<<y<<'\n'
#define DE(fmt,...) fprintf(stderr, "Line %d : " fmt "\n",__LINE__,##__VA_ARGS__)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int>pii;
typedef pair<ll,int>pli;
typedef pair<ll,ll>pll;
typedef pair<int,ll>pil;
typedef vector<int>vi;
typedef vector<ll>vll;
typedef vector<pii>vpii;
typedef vector<pll>vpll;
template<typename T>T cmax(T &x, T y){return x=x>y?x:y;}
template<typename T>T cmin(T &x, T y){return x=x<y?x:y;}
template<typename T>
T &read(T &r){
	r=0;bool w=0;char ch=getchar();
	while(ch<'0'||ch>'9')w=ch=='-'?1:0,ch=getchar();
	while(ch>='0'&&ch<='9')r=r*10+(ch^48),ch=getchar();
	return r=w?-r:r;
}
template<typename T1,typename... T2>
void read(T1 &x,T2& ...y){read(x);read(y...);}
const int mod=998244353;
const int N=280010;
const ll inf=0x3f3f3f3f3f3f3f3f;
inline int all(int x){return (1<<x)-1;}
int n,m;
int a[N],vis[N],ok[N];
ll dep[N],dis[N],ans;
ll sum,cnt;
queue<int>q;
vpii eg[N];
void ins(int x){
	if(dis[x]!=inf)sum+=dis[x],cnt++;
}
void del(int x){
	if(dis[x]!=inf)sum-=dis[x],cnt--;
}
void spfa(vpll &vec){
	while(!q.empty()){
		int x=q.front();q.pop();
		vis[x]=0;
		for(auto i:eg[x]){
			int v=i.fi,w=i.se;
			if(dis[v]>dis[x]+w){
				del(v);
				if(!ok[v]){
					vec.pb(mp(v,dis[v]));
					ok[v]=1;
				}
				dis[v]=dis[x]+w;
				ins(v);
				if(!vis[v]){
					q.push(v);
					vis[v]=1;
				}
			}
		}
	}
}
void dfs(int x){
	if(x>all(n))return ;
	int lac=cnt;
	ll las=sum;
	vpll vec;vec.pb(mp(x,dis[x]));ok[x]=1;
	del(x);dis[x]=-dep[x];q.push(x);ins(x);
	spfa(vec);
	{
		int y=x;
		ll now=0,s=sum,c=cnt;
		ll r=0;
		while(y){
			--c;
			now+=r;
			r+=a[y];
			s-=dis[y];
			y>>=1;
		}
		now+=dep[x]*c+s; 
		ans=(ans+now%mod)%mod;
	}
	dfs(x*2);
	dfs(x*2+1);
	cnt=lac;sum=las;
	for(auto i:vec)ok[i.fi]=0,dis[i.fi]=i.se;
}
signed main(){
	#ifdef do_while_true
		assert(freopen("trade.in","r",stdin));
		assert(freopen("trade.out","w",stdout));
	#endif
	read(n,m);
	for(int i=2;i<=all(n);i++)dep[i]=dep[i/2]+read(a[i]),eg[i].pb(mp(i/2,a[i]));
	for(int i=1,u,v,w;i<=m;i++){
		read(u,v,w);
		eg[u].pb(mp(v,w));
	}
	memset(dis,0x3f,sizeof(dis));
	dis[1]=0;ins(1);
	q.push(1);
	vpll vec;spfa(vec);
	dfs(1);
	cout << ans << '\n';
    #ifdef do_while_true
//		cerr<<'\n'<<"Time:"<<1.0*clock()/CLOCKS_PER_SEC*1000<<" ms"<<'\n';
	#endif
	return 0;
}
```

---

## 作者：_yjh (赞：7)

以下是我场上的做法。

首先我们毛估估一下，感觉直接做不太好做啊（当然直接做也能做），还是将边反向一下更自然。一个显然的事实是题目所要求的东西在正图和反图上算答案不变。**以下完全基于反图性质分析。**

我们考虑对每个点 $x$ 分别求其走到其他所有点的最短路。既然建了反图，那么 $x$ 到其子树内所有点的最短路都是确定的，显然直接走树边最优，这部分可以用一个简单的树形 dp 算出。于是我们还剩下两部分，即 $x$ 到其祖先的最短路，和 $x$ 到其余点的最短路。

第一部分其实不难求。我们发现只需要求出 $x$ 到其每个祖先 $y$，且不经过其他祖先 $y'$ 的最短路，就可以由此求出 $x$ 到其每个祖先 $y$ 的最短路。这是因为 $x$ 到祖先 $y$ 的最短路必然形式如下，即先到某个祖先 $y'$（当然也可以直接到 $y$），然后再走 $y'$ 到 $y$ 的最短路。那 $y'$ 到 $y$ 的最短路怎么求呢？如果 $y'$ 是 $y$ 的祖先，直接沿树边向下走即可，最短路自然是两点深度差。否则如果 $y$ 是 $y'$ 的祖先，那么相当于要用一个点到其某个祖先的最短路，我们只需要先处理祖先的答案，再处理后代的答案，同时在把每个点到其每个祖先的最短路记录下来即可（满二叉树每个点祖先数量很少）。 

那么怎么求出 $x$ 到其每个祖先 $y$ 且不经过其他祖先 $y'$ 的最短路呢？实际上经过分析可以发现，这种最短路必然形如以下形式，即先向子树内走一段（或不走），再走一条额外边（也就是返祖边）直接到 $y$。我们考虑某条终点为 $y$ 的额外边，如果其起点为 $z$，边权为 $val$ 的话，其贡献显然为 $dep_z-dep_x+val$（$dep_i$ 表示第 $i$ 个点在原树上的深度）。既然 $x$ 确定，那么 $dep_x$ 自然固定，所以最短路也就是 $dep_z + val$ 的最小值，这只和边本身有关。此处如果我们将所有额外边以终点为第一关键字，起点 dfn 序为第二关键字排序，合法的额外边必然形如一段区间（首先合法额外边必然以同一点为终点，其次其起点必须在一个点及其子树内，也就是 dfn 序上的一段连续区间）。使用 ST 表维护 $dep_z+val$ 的区间 $\min$ 即可。

有了第一部分第二部分也就简单了。这一部分的点和 $x$ 的 lca 必然为 $x$ 的某个祖先。我们对 $x$ 的每个祖先 $y$ 求出其到不含 $x$ 的那个子树距离和，再和 $x$ 到 $y$ 的最短路合并一下即可（这一部分我场上实现麻烦了，但本质与之等价）。

设 $N=2^n$ 不难分析出复杂度为 $O(N \log^2 N + m \log N)$。

[代码实现](https://www.luogu.com.cn/paste/cyw075kb)

---

## 作者：2018ljw (赞：5)

我能场切的都是水题。

记 $k=2^n-1$，即树的点数。

考虑点对关系只有三种：祖先、后代、兄弟。

这里兄弟就是指两个点在其 $lca$ 的不同子树内。

由于附加边都是下行边，因此往祖先方向走只会有上行边，也就是只会走树边。我们可以简单的计算出每个树边被这样的点对经过多少次来算出这部分的贡献。

根据这样的性质，兄弟节点一定是从起点先向上走到 $lca$，变为后代问题。因此我们实质上只需要处理后代关系。

后代关系只有 $O(nk)$ 个，因此这东西应当是相当可做的。现在要求的是每个点到子树内所有点的最短路，考察我们的路径是什么样的。

因为附加边都是下行的，所以我们一定是从起点开始，每上行一段后走一个下行边。并且显然这些下行边的终点不应当是已经走过的点。因此我们可以发现，起点出发，经过的第一个下行边的终点一定在子树内。

不妨大胆一些，对每个点，我们保留这样一个虚图。这个图里仅包含：这个点的所有祖先和后代、这些点之间的树边、终点在该点子树内的所有附加边。然后直接在虚图上跑 dijkstra。

这样，所有虚图的总边数是 $O(nm)$ 级别的，总点数是 $O(nk)$ 级别的，总复杂度 $O(nk\log nm)$。

但需要注意不可达的点对权为 $0$，因此对于兄弟节点的上行边统计，我们需要额外计算能到达多少点。这只需要额外计算对每个点跑 dij 时，两个子树内各有多少点到该点距离不为 $\inf$，统计时一路上跳计算另一个子树中该项的和即可。

---

## 作者：pikiuk (赞：4)

史上最简单 D2T1？

我们记 $m$ 条 “第二类道路” 为附加边，“第一类道路” 为树边。

考虑拆贡献，孙子到祖先的贡献是容易的，最短路一定是只沿着树边的，对每条树边考虑他会被经过几次，这个次数只和子树大小和他到根节点的距离有关。

考虑不存在祖孙关系的点对贡献，套路的，把贡献挂在 $\operatorname{lca}$ 上计算。把这条路径拆成向上和向下两条，向上的贡献同第一类贡献，向下的贡献从每个点出发对他的子树求一遍最短路即可解决。



---

## 作者：Utilokasteinn (赞：3)

### [Link](https://www.luogu.com.cn/problem/P9481)

题目大意：给你一颗完全二叉树，每个非根节点到其父亲节点都有一条有向有权边，另外还有 $m$ 条从祖先连向孙子的边。求所有点之间的距离之和。

直接跑最短路显然不现实，需要找一些性质。

对于 $u$ 到 $v$，容易发现，若存在一条路径，则必定经过 $lca(u,v)$。

对于 $u$ 到 $lca$，显然只能往上走，不可能走往下的边。

再考虑从 $lca$ 到 $v$ 到路径，也不难发现最短路不会经过 $lca$ 到根以及 $v$ 所在 $lca$ 子树的所有点。

换句话说，从 $lca$ 到 $v$，不可能到 $lca$ 的祖先和孙子以外的所有点。

那怎么求 $lca$ 到其子树节点到最短路呢？

直接把子树节点和其祖先全部加入，然后跑 Dijkstra 就行了。

对于每个节点都为起点跑一遍最短路，设总节点数为 $n$，那么每个节点被跑最短路的图包括的数为 $\mathcal{O}(\log n)$ 级别的。虽然跑了 $n$ 遍最短路，但是复杂度是对的。

注意要开 long long。

代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mod 998244353
using namespace std;
inline int read()
{
    int s=0;char c=getchar();
    for(;!isdigit(c);c=getchar());
    for(;isdigit(c);c=getchar())
        s=s*10+c-'0';
    return s;
}
const int N=(1<<18);
int n,m;
int head[N],tot;
struct edge
{
    int to,dis,nxt;
}e[N*20];
ll len[N];
vector<pair<int,int> >to[N];
inline void add(int u,int v,int w)
{
    e[++tot].to=v;
    e[tot].nxt=head[u];
    e[tot].dis=w;
    head[u]=tot;
}

vector<int>s[N];
ll dis[N],ans;
bool vis[N];
void dfs(int u,int dep)
{
    s[u].push_back(u);
    if(dep==n)return;
    dfs(u*2,dep+1),dfs(u*2+1,dep+1);

    dis[u]=vis[u]=0;
    for(int i=0;i<s[u*2].size();i++)
    {
        int temp=s[u*2][i];
        s[u].push_back(temp);
        dis[temp]=1e18,vis[temp]=0;
    }
    for(int i=0;i<s[u*2+1].size();i++)
    {
        int temp=s[u*2+1][i];
        s[u].push_back(temp);
        dis[temp]=1e18,vis[temp]=0;
    }

    priority_queue<pair<ll,int> >q;
    q.push(make_pair(0,u));
    for(int i=0;i<s[u].size();i++)
    {
        int v=s[u][i];
        for(int j=0;j<to[v].size();j++)
        {
            int fa=to[v][j].first,w=to[v][j].second;
            if(fa>u)continue;
            if(dis[v]>len[u]-len[fa]+w)
            {
                dis[v]=len[u]-len[fa]+w;
                q.push(make_pair(-dis[v],v));
            }
        }
    }

    while(!q.empty())
    {
        int uu=q.top().second;q.pop();
        if(vis[uu])continue;
        vis[uu]=1;
        for(int i=head[uu];i;i=e[i].nxt)
        {
            int v=e[i].to;
            if(dis[v]>dis[uu]+e[i].dis&&v>u)
            {
                dis[v]=dis[uu]+e[i].dis;
                q.push(make_pair(-dis[v],v));
            }
        }
    }

    ll cnt1=0,cnt2=0,sum1=0,sum2=0,sum3=0,sum4=0;
    for(int i=0;i<s[u*2].size();i++)
    {
        int v=s[u*2][i];
        sum3+=len[v]-len[u];
        if(dis[v]==1e18)continue;
        cnt1++,sum1+=dis[v];
    }
    for(int i=0;i<s[u*2+1].size();i++)
    {
        int v=s[u*2+1][i];
        sum4+=len[v]-len[u];
        if(dis[v]==1e18)continue;
        cnt2++,sum2+=dis[v];
    }
    int cnt3=s[u*2].size(),cnt4=s[u*2+1].size();
    sum1%=mod,sum2%=mod,sum3%=mod,sum4%=mod;
    ans=(ans+sum1+sum2+sum3+sum4+ sum1*cnt4%mod + sum2*cnt3%mod + sum3*cnt2%mod + sum4*cnt1%mod)%mod;
}

int main()
{
    //freopen("a.in","r",stdin);
    n=read(),m=read();
    for(int u=2;u<(1<<n);u++)
    {
        int w=read();
        add(u,u/2,w),len[u]=len[u/2]+w;
    }
    for(int i=1;i<=m;i++)
    {
        int u=read(),v=read(),w=read();
        add(u,v,w);
        to[v].push_back(make_pair(u,w));
    }
    dfs(1,1);
    printf("%lld\n",ans);
    return 0;
}
```

题解思路来源于 [Gaode_Sean](https://www.luogu.com.cn/user/486484)，代码也非常相似。不过他写得比较混乱（感觉），就又写了一篇题解。如果感觉被冒犯，可以将本题解撤下。

写于 2024.3.1 十点，联合省选前一天，希望攒攒 RP。

NOIP 只有 244，比队线少了 80+，进队的概率不亚于考段一。

虽然我才高一，但是我已经高一了，对前途的迷茫已经愈来愈多。

或许，也该说再见了。

---

## 作者：Gaode_Sean (赞：2)

近五年来最简单的 D2T1。

不难发现，所有点对的贡献都可以被拆分成向上到 lca 再由 lca 到目标点的两段，即 $\text{dist}(x,y)=\text{dist}(x,\text{lca}(x,y))+\text{dist}(\text{lca}(x,y),y)$。

所以只要求每个点到自己子树内所有点的最短路就可以快速算贡献。这里我用的是 dijkstra 求单源最短路。

对最短路有贡献的点只有该点的祖先和后代，所以把这些点提出来单独跑最短路即可。
每个点的复杂度是 $\mathcal{O}(siz \log m)$ 的，而 $\sum siz=2^nn$，所以总复杂度为 
 $\mathcal{O}(2^nn \log m)$。
 
## AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod=998244353;
const int N=5e5+5,M=1e6+5;
int n,m;
int tot,ver[M],nxt[M],head[N],num[N];
ll edge[M],d[N],ans,sum[N];
bool v[N],vis[N];
priority_queue< pair<ll,int> > q;
vector<int> vec[N];
vector< pair<int,ll> > pos[N];
void add(int x,int y,ll z){ver[++tot]=y,edge[tot]=z,nxt[tot]=head[x],head[x]=tot;}
void dfs(int x)
{
	vec[x].push_back(x);
	if(num[x]==n) return;
	int xa=x<<1,xb=xa+1;
	dfs(xa); dfs(xb);
	vis[x]=1;
	for(int i=0,val;i<vec[xa].size();i++) val=vec[xa][i],vec[x].push_back(val),vis[val]=1,v[val]=0,d[val]=1e18;
	for(int i=0,val;i<vec[xb].size();i++) val=vec[xb][i],vec[x].push_back(val),vis[val]=1,v[val]=0,d[val]=1e18;
	q.push(make_pair(0,x));
	ll wa=0,wb=0,wa_=0,wb_=0,ca=0,cb=0,ca_=0,cb_=0;
	for(int i=1;i<vec[x].size();i++)
	{
		int y=vec[x][i];
		for(int j=0;j<pos[y].size();j++) if(pos[y][j].first<x){d[y]=min(d[y],sum[x]-sum[pos[y][j].first]+pos[y][j].second);q.push(make_pair(-d[y],y));}
	}
	while(!q.empty())
	{
		int now=q.top().second; q.pop();
		if(v[now]) continue;
		v[now]=1;
		for(int i=head[now];i;i=nxt[i])
		{
			if(!vis[ver[i]]) continue;
			int y=ver[i]; ll z=edge[i];
			if(d[now]+z<d[y]){d[y]=d[now]+z; q.push(make_pair(-d[y],y));}
		}
	}
	v[x]=0;
	for(int i=0,val;i<vec[xa].size();i++) val=vec[xa][i],wa=(wa+(d[val]==1e18?0:d[val]))%mod,ca=(ca+((d[val]==1e18)?0:1))%mod,v[val]=0,d[val]=1e18;
	for(int i=0,val;i<vec[xb].size();i++) val=vec[xb][i],wb=(wb+(d[val]==1e18?0:d[val]))%mod,cb=(cb+((d[val]==1e18)?0:1))%mod,v[val]=0,d[val]=1e18;
	for(int i=0,val;i<vec[xa].size();i++) val=vec[xa][i],wa_=(wa_+sum[val]-sum[x])%mod,ca_++,vis[val]=0;
	for(int i=0,val;i<vec[xb].size();i++) val=vec[xb][i],wb_=(wb_+sum[val]-sum[x])%mod,cb_++,vis[val]=0;
	ans=(ans+wa+wb+wa_+wb_+wa*cb_%mod+wb*ca_%mod+wa_*cb%mod+wb_*ca%mod)%mod;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=(1<<n)-2;i++)
	{
		ll z; scanf("%lld",&z);
		add(i+1,(i+1)>>1,z);
		num[i]=num[i>>1]+1,sum[i+1]=sum[(i+1)>>1]+z;
	}
	for(int i=1,x,y;i<=m;i++){ll z; scanf("%d%d%lld",&x,&y,&z); add(x,y,z); pos[y].push_back(make_pair(x,z));}
	num[(1<<n)-1]=n;
    dfs(1);
    printf("%lld\n",ans);
	return 0;
}

---

## 作者：蒟蒻君HJT (赞：2)

考虑 $\operatorname{dis}(x,y)$，当 $x$ 与 $y$ 不存在祖先后代关系的时候，$x$ 一定是先跑到 $\operatorname{lca}(x,y)$，再想办法到 $y$。这个问题几乎和计算从 $\operatorname{lca}(x,y)$ 到 $y$ 的最短路等价。当我们求出所有 $\operatorname{dis}(x,y)$，其中 $x$ 是 $y$ 的祖先或后代之后，就可以换根 dp 求出所有 $\operatorname{dis}(x,y)$ 之和。 

记 $d_x$ 表示 $1$ 到 $x$ 的距离。

这样一来我们需要求的点对数量就只有 $\mathcal{O}(n2^n)$。

枚举 $x$。记 $dis_v$ 为 $x$ 到 $v$ 的最短路。此时有用的点只有 $x$ 子树内的点和 $x$ 的祖先，后者容易求出（只能往上跑）。

对于前者的某个 $v$，考虑 $x$ 到 $v$ 的最短路的路径一定是先往上走若干步，再走一次第二类道路往下跳，再往上走若干步，再走一次第二类道路往下跳······再走一次第二类道路往下跳，最后往上走若干步。“若干”可以为 $0$。考虑每次走第二类道路的起点一定单调严格下移（否则一定不是最短路），所以如果把“往上走若干步”看成一步的话，总步数为 $w=\mathcal{O}(n)$ 级别。

直接暴力循环 $w$ 轮，进行松弛操作。用第二类道路松弛是简单的，把第二类道路挂在下面的那个点上，设其为 $(a,b,c)$，则令 $dis_b \leftarrow \min(dis_b,dis_a+c)$ 即可。

用第一类道路松弛的条件：$a$ 为 $b$ 的祖先。$dis_a\leftarrow\min(dis_a,dis_b+d_b-d_a)$，所以 dfs 求出 a 子树中最小的 $dis_b+d_b$ 即可。

实现里每一轮同时按顺序进行了两类松弛，因此跑 $19$ 轮肯定就够了。

时间复杂度：$\mathcal{O}(n^22^n)$，空间复杂度：$\mathcal{O}(n2^n)$。

code

```cpp
#include <bits/stdc++.h>
const long long inf = 1e18;
int n, m, fa[262144], dep[262144], cnt[262144];
long long d[262144], Dis[262144][18], dis[262144];
std::vector <int> vc[262144];
struct edge{
  int to, len;
};
std::vector <edge> cv[262144];
int tot = 0, df[262144];
long long mi[262144];
long long ans = 0ll, dp[262144];
const long long mod = 998244353;
void dfs1(int x){
  for(auto v : vc[x]){
    d[v] = d[x] + d[v];
    dep[v] = dep[x] + 1;
    dfs1(v);
  }
  return ;
}
void dfs2(int x){
  df[++tot] = x;
  if(tot != 1) dis[x] = inf;
  for(auto v : vc[x]) dfs2(v);
  return ;
}
void dfs4(int x, int u){
  if(Dis[x][dep[u]] != inf){
    dp[u] -= Dis[x][dep[u]];
    dp[u] %= mod;
    if(dp[u] < 0ll) dp[u] += mod;
    --cnt[u];
  }
  for(auto v : vc[x]) dfs4(v, u);
  return ;
}
void dfs5(int x, int u){
  if(Dis[x][dep[u]] != inf){
    dp[u] += Dis[x][dep[u]];
    dp[u] %= mod;
    ++cnt[u];
  }
  for(auto v : vc[x]) dfs5(v, u);
  return ;
}
void dfs3(int x){
  ans += dp[x];
  ans %= mod;
  int t = x;
  while(t){
    t = fa[t];
    if(t) ans += 1ll * cnt[t] * (d[x] - d[t]) + dp[t], ans %= mod;
  }
  if(!vc[x].size()) return ;
  int v1 = vc[x][0], v2 = vc[x][1];
  dfs4(v1, x);
  dfs3(v1);
  dfs5(v1, x);
  dfs4(v2, x);
  dfs3(v2);
  dfs5(v2, x);
  return ;
}
int main(){
  scanf("%d%d", &n, &m);
  for(int i = 2; i <= (1 << n) - 1; ++i){
    scanf("%lld", &d[i]);
    fa[i] = i / 2;
    vc[fa[i]].push_back(i);
  }
  for(int i = 1; i <= m; ++i){
    int a, b, c;
    scanf("%d%d%d", &a, &b, &c);
    cv[b].push_back((edge){a, c});
  }
  dfs1(1);
  for(int u = 1; u <= (1 << n) - 1; ++u){
    int t = u;
    while(t){
      dis[t] = d[u] - d[t];
      t = fa[t]; 
    }
    tot = 0;
    dfs2(u);
    for(int w = 0; w <= 18; ++w){
      for(int i = 1; i <= tot; ++i){
        for(auto e : cv[df[i]])
          dis[df[i]] = std::min(dis[df[i]], dis[e.to] + 1ll * e.len);
        mi[df[i]] = inf;
      }
      for(int i = tot; i >= 2; --i){
        mi[df[i]] = std::min(mi[df[i]], d[df[i]] + dis[df[i]]);
        if(mi[df[i]] != inf) dis[df[i]] = std::min(dis[df[i]], mi[df[i]] - d[df[i]]);
        mi[fa[df[i]]] = std::min(mi[fa[df[i]]], mi[df[i]]);
      }
    }
    for(int i = 1; i <= tot; ++i){
      if(dis[df[i]] == inf) Dis[df[i]][dep[u]] = inf;
      else {
        Dis[df[i]][dep[u]] = dis[df[i]], ++cnt[u];
        dp[u] += dis[df[i]];
        dp[u] %= mod;
      }
    }
  }
  dfs3(1);
  printf("%lld\n", ans);
  return 0;
}
```


---

## 作者：Purslane (赞：2)

# Solution

写一篇正经题解。感觉这题比去年 NOIp T3 简单的多，评蓝色是合理的。 /cf

考虑最友好的暴力是直接 Dijkstra。但是这样太慢了，每个点被跑了 $2^n-1$ 次最短路。我们应该先观察最终路径的性质。

我们设要求出 $\sum_{v=1}^{2^n-1} dis(u,v)$。对于 $u$ 到 $1$ 这条链上的 $v$，最短路肯定是树边。其他的点我们肯定要从 $u$ 一直往上爬到某个节点，然后从这条链上跳下来，然后尝试继续往上爬。注意，我们不可能再爬回链上，因为这样肯定会更劣。

考虑我们求出了 $u$（暂时不管是那种方法），如何求出 $u$ 的儿子 $h$ 的答案？对于 $h$ 子树外的点，我们不可能比 $u$ 求解的时候多走任何边，除了 $h$ 到 $u$。因此，我们记录 $h$ 子树外的在求解 $u$ 时的答案，再对所有**能到达的点**加上 $a_h$。不过我们多了一种选择：直接从 $h$ 跳下去。这样可能会对 $h$ 的子树产生影响。

我们先将 $h$ 子树中关于 $u$ 的最短路值加上 $a_h$，这是可能的最短路值。我们再令 $h$ 的最短路值为 $0$，再以 $h$ 子树节点构成的子图中跑 Dijkstra 暴力重构。看起来复杂度逆天，但实际上每个点最多被做 $n$ 次 Dijkstra。

这样我们知道，我们从 $1$ 开始递归求解的过程是：

1. 将所有点的 $dis$ 加上 $a_u$ 后令 $dis_u=0$。
2. 暴力对 $u$ 的子树跑 Dijkstra，求出 $u$ 子树内的答案，子树外的答案是在递归过程中下传的，并且还记录了有多少个点能到达。
3. 记录左子树中点的答案和点的数量，递归右子树求解；记录右子树中点的答案和点的数量，递归左子树求解。注意这个记录必须再两次递归之前先完成，否则最短路会被改变你还得花额外的空间记录。

总体复杂度为 $O(n^2(m+2^n))$，因为每个点被做一次 Dijkstra 对计算量的贡献是 $O((1+\deg) \log 2^n)=O(n(1+\deg))$，这样每条边每个点都要产生 $n^2$ 的贡献。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=(1<<18)+10,MOD=998244353,INF=0x3f3f3f3f3f3f3f3f;
int n,m,res,a[MAXN],dis[MAXN],vis[MAXN];
vector<pair<int,int>> G[MAXN];
#define lson (u<<1)
#define rson (u<<1|1)
struct Node {int u,dis;};
bool operator <(Node A,Node B) {return A.dis>B.dis;}
void add(int u,int v) {
	if(u>n) return ;
	dis[u]=dis[u]+v,vis[u]=0;
	if(dis[u]>INF) dis[u]=INF;
	add(lson,v),add(rson,v);
	return ;	
}
void insert(int u,priority_queue<Node>& q) {
	if(u>n) return ;
	q.push({u,dis[u]});
	insert(lson,q),insert(rson,q);
	return ;
}
void add_to_ans(int u,int& ans,int &out) {
	if(u>n) return ;
	if(dis[u]<INF) ans=(ans+dis[u])%MOD,out++;
	add_to_ans(lson,ans,out),add_to_ans(rson,ans,out);
	return ;	
}
void dfs(int u,int f,int out,int ans) { //ans 是目前已有子树外的答案 out 是目前已有子树外非零个数 
	ans=(ans+out*a[u]%MOD)%MOD;
	add(u,a[u]),dis[u]=0;
	priority_queue<Node> q;
	insert(u,q);
	while(!q.empty()) {
		int id=q.top().u; q.pop();
		if(vis[id]) continue; vis[id]=1;
		for(auto pr:G[id]) {
			int v=pr.first,w=pr.second;
			if(dis[id]+w<dis[v]) dis[v]=dis[id]+w,q.push({v,dis[v]});
		}
		int v=id>>1;
		if(v>=u) if(dis[id]+a[id]<dis[v]) dis[v]=dis[id]+a[id],q.push({v,dis[v]});	
	}
	int mzx; int tmpans=ans;
	add_to_ans(u,tmpans,mzx);
	res=(res+tmpans)%MOD;
	int lans=ans,rans=ans,lout=out+1,rout=out+1;
	if(lson>n) return ;
	add_to_ans(lson,lans,lout);
	add_to_ans(rson,rans,rout);
	dfs(lson,u,rout,rans);
	dfs(rson,u,lout,lans);
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	memset(dis,0x3f,sizeof(dis));
	cin>>n>>m,n=(1<<n)-1;
	ffor(i,2,n) cin>>a[i];
	ffor(i,1,m) {
		int u,v,w; cin>>u>>v>>w;
		G[u].push_back({v,w});	
	}
	dfs(1,0,0,0);
	cout<<res;
	return 0;
}

```

---

## 作者：Mobius127 (赞：1)

[题传](https://www.luogu.com.cn/problem/P9481)

好简单的 D2T1。

设 $pre_{i}$ 表示 $i$ 到 $1$ 的最短路径，可以简单前缀和处理。

不难发现 $\operatorname{dist}(x, y)=\operatorname{dist}(x, \operatorname{LCA}(x, y))+\operatorname{dist}(\operatorname{LCA}(x, y), y)$ 恒成立，考虑在 $\operatorname{LCA(x, y)}$ 处计算贡献。

$\operatorname{dist}(x, \operatorname{LCA}(x, y))$ 只能通过走“第一类道路”，这部分的和是很好统计的，对于 $\operatorname{dist}(\operatorname{LCA}(x, y), y)$，合法的路径只有可能是向上走若干步后，通过祖先到后代的“第二类道路”再向上走。

即我们要求 $\operatorname{LCA}$ 到子树内所有点的最短路径，因为我们只可能走“第二类道路”一次，因此先枚举所有后代 $v$ 的合法入边 $(anc_{\operatorname{LCA}}, v, w)$，提前用 $pre_{\operatorname{LCA}}-pre_{anc_{\operatorname{LCA}}}+w$ 更新 dijstra 中的 $dis_{v}$，对于子树内的一类边和二类边做 dijstra 即可。

复杂度 $T(m)=2T(\frac{m}{2})+O(m\log m)$，根据主定理总复杂度为 $O(2^{n}n^2)$。

### Code:

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <cctype>
#include <vector>
#include <queue>
#include <bitset>
#define int long long
#define vi vector<int>
#define pb push_back
#define mp make_pair
#define st first
#define nd second
using namespace std;
typedef long long ll;
typedef pair <int, int> Pii;
typedef pair <ll, int> Pli;
const ll INF=2e18;
const int cp=998244353;
inline int mod(int x){x=(x%cp+cp)%cp;if(x>=cp) x-=cp;if(x<0) x+=cp;return x;}
inline void plust(int &x, int y){x=mod(x+y);return ;}
inline void minut(int &x, int y){x=mod(x-y);return ;}
inline int read(){
	char ch=getchar();int x=0, f=1;
	while(!isdigit(ch)){if(ch=='-') f=-1; ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
inline void write(int x){
    if(x<0) putchar('-'), x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
inline int ksm(int a, int b=cp-2){
	int ret=1;
	for(; b; b>>=1, a=1ll*a*a%cp)
		if(b&1) ret=1ll*ret*a%cp;
	return ret;
}
const int N=(1<<18)+5;
int n, m, S, lg[N], w[N], ans;bool vis[N], in[N];
ll dis[N], pre[N];
vector <Pii> G[N], T[N];
priority_queue <Pli> Q;
int tag(int x, int dep, bool t, int mat, int cnt){
	int res=0;
	vis[x]=0;in[x]=t;
	if(!t&&dis[x]!=INF) 
		res=mod(dis[x]%cp*cnt%cp+mat);
	else dis[x]=INF;
	if(t&&x!=mat){
		for(auto [y, z]:T[x]) if(lg[y]<lg[mat])
			dis[x]=min(dis[x], pre[mat]-pre[y]+z);
		Q.push({-dis[x], x});
	} 
	if(dep>1) plust(res, mod(tag(x<<1, dep-1, t, mat, cnt)+tag(x<<1|1, dep-1, t, mat, cnt)));
	return res;
}
int dfs(int u, int dep){
	int lz=0, rz=0;
	if(dep>1) lz=dfs(u<<1, dep-1), rz=dfs(u<<1|1, dep-1);
	else return w[u];
	tag(u, dep, 1, u, 0);
	Q.push({dis[u]=0, u});
	ll p=0;
	while(!Q.empty()){
		int x=Q.top().nd;Q.pop();
		if(vis[x]) continue;vis[x]=1;
		if(in[x>>1]&&dis[x]+w[x]<dis[x>>1]) Q.push({-(dis[x>>1]=dis[x]+w[x]), x>>1});
		for(auto [y, z]:G[x]) if(in[y]&&dis[x]+z<dis[y]) Q.push({-(dis[y]=dis[x]+z), y});
	}
	int lp=tag(u<<1, dep-1, 0, rz, (1<<dep-1)), rp=tag(u<<1|1, dep-1, 0, lz, (1<<dep-1));
	plust(ans, (lz+rz+lp+rp)%cp);//printf("%d:%d %d %d %d\n", u, lz, rz, lp, rp);
	return mod((lz+rz)%cp+1ll*w[u]*((1<<dep)-1)%cp);
}
signed main(){
	n=read(), m=read(), S=1<<n;
	for(int i=2; i<S; ++i) w[i]=read(), pre[i]=pre[i>>1]+w[i];
	for(int i=1, u, v, w; i<=m; ++i) 
		u=read(), v=read(), w=read(), G[u].pb({v, w}), T[v].pb({u, w});
	lg[0]=-1;
	for(int i=1; i<S; ++i) sort(G[i].begin(), G[i].end()), lg[i]=lg[i>>1]+1;
	dfs(1, n);
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：yuanruiqi (赞：1)

考虑对每个 $u$ 求出 $f_u=\sum_{v=1}^{2^n-1}dis(u,v)$，并分析 $f_{fa_u}$ 到 $f_u$ 的增量。将 $v$ 按照是否在 $u$ 子树内分成两类。对于在子树外的，那么从 $u$ 到 $v$ 的第一步一定是 $u\to fa_u$，可以在 `dfs` 过程中维护出子树外的 $v$ 的距离和及其可达点数求出。对于在子树内的点 $v$，直接跑一遍 dijkstra，主定理得到复杂度为 $O(n^22^n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;
constexpr int maxn = 262200;
constexpr int mod = 998244353;
constexpr i64 inf = 0x3f3f3f3f3f3f3f3f;
i64 f[maxn], e[maxn];
int n, m, lim;
struct edge
{
    int v, w;
    edge(int _v=0, int _w=0) : v(_v), w(_w) {}
};
vector<edge> g[maxn];
i64 d[maxn];
void build(vector<int>& v, int k)
{
    for (int i=0;i<v.size();++i)
    {
        int x = v[i];
        d[x] += k;
        if ((x << 1) < lim) v.emplace_back(x << 1);
        if ((x << 1 | 1) < lim) v.emplace_back(x << 1 | 1);
    }
}
struct node
{
    int u; i64 d;
    bool operator<(const node& b) const
    {
        return d > b.d;
    }
    node(int _u=0, i64 _d=0) : u(_u), d(_d) {}
};
i64 d2[maxn];
void dfs(int u, i64 s, int c)
{
    (s += c * e[u]) %= mod;
    f[u] = s;
    if ((u << 1) >= lim) return;
    vector<int> v1 {u << 1}, v2 {u << 1 | 1};
    build(v1, e[u]); build(v2, e[u]);
    priority_queue<node> q;
    q.push(node(u, d[u] = 0));
    int fa = u >> 1;
    while (q.size())
    {
        auto x = q.top(); q.pop();
        int u = x.u;
        if (x.d != d[u]) continue;
        for (edge e : g[u])
            if (e.v != fa && d[e.v] > d[u] + e.w)
                q.push(node(e.v, d[e.v] = d[u] + e.w));
    }
    ++c;
    i64 ax = 0, ay = 0, bx = 0, by = 0;
    for (int i : v1) if (d[i] < inf) (ax += d[i]) %= mod, ++ay;
    for (int i : v2) if (d[i] < inf) (bx += d[i]) %= mod, ++by;
    (f[u] += ax + bx) %= mod;
    vector<int>().swap(v1);
    vector<int>().swap(v2);
    dfs(u << 1, (s + bx) % mod, c + by);
    dfs(u << 1 | 1, (s + ax) % mod, c + ay);
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n >> m;
    lim = 1 << n;
    for (int i=2;i<lim;++i)
    {
        int x;
        cin >> x;
        g[i].emplace_back(edge(i >> 1, e[i] = x));
    }
    while (m--)
    {
        int u, v, w;
        cin >> u >> v >> w;
        g[u].emplace_back(edge(v, w));
    }
    memset(d, 0x3f, sizeof(d));
    dfs(1, 0, 0);
    i64 ans = 0;
    for (int i=1;i<lim;++i) ans += f[i];
    cout << ans % mod << '\n';
    return 0;
}
```

---

## 作者：CarroT1212 (赞：1)

提供一种（看上去？）不用最短路算法的 1.5KB 神秘做法。个人认为比较好懂。

------------

数据范围：$n \le 18,m\le 2^{18},a_i,w\le 10^9$。

首先原图明显是一棵满二叉树，然后第二类边是树上的很多返祖边。

诶好像不能这么说，这题的树边是从儿子到父亲，非树边是从祖先走到儿子，所以应该叫进化边（？）。这跟我们的直觉不太一样啊，怎么回事呢。

发现题目要求的答案是 $\sum\limits_x\sum\limits_y dist(x,y)$ 的形式，好像把所有边反过来变成 $\sum\limits_y\sum\limits_x dist(y,x)$ 对答案不会产生任何影响呢，这样会不会好做一点？

所以接下来的做法全部建立在**已经将图上所有边反过来**的基础上，也就是祖先可以走到儿子，然后存在一些返祖边从儿子走到祖先。

显然对每条边考虑贡献不太可行，毕竟你没法直接知道每条最短路都经不经过这条边，所以大概率是对于每一个起点考虑终点答案之和。

考虑把每个点出发的答案之和拆成几部分。

首先对于子树内的点，显然只走树边更优，这一部分的贡献是预处理转移一下即可计算的。

然后画画图你又会发现子树外的点可以进一步拆成下面的样子：

![](https://cdn.luogu.com.cn/upload/image_hosting/uj8l8g23.png)

（抱歉图非常丑但是我想不到更好的画法了……）

图中三角形表示以某个点为根的子树，绿边是子树内的路径，红边是返祖边。假设我们现在位于 $u_1$。

你会发现，从 $u_1$ 走到 $T_2$ 内的点，必须要先经过 $u_2,v_2$，而且从 $u_2$ 到 $T_2$ 内的点之间，必定只会经过树边。也就是说，$T_2$ 内的点最早什么时候被走到，取决于 $u_2$ 最早什么时候被走到。

同理，走到 $T_3$ 内的点的最短路取决于走到 $u_3$ 的最短路，走到 $T_4$ 内的点的最短路取决于走到 $u_4$ 的最短路……

而从一个点走到它子树内所有点的距离之和你完全可以预处理出来直接 $O(1)$ 查询，所以，只要知道了 $u_2,u_3,\cdots$ 的最短路，你就能算出所有点的最短路之和了。

更让我们惊喜的是，$u_i$ 最多只有 $n$ 个！

所以现在最大的问题就是**怎么求 $u_i$ 的最短路**了。发现 $u_i$ 有两种转移情况：

+ 从 $u_{i+1}$ 走蓝边过来。
+ 从 $u_{i-1}$ 的子树内的一个点走返祖边（红边）过来。

那我们设 $f_{i,j}$ 为从 $i$ 出发，走到 $i$ 子树内的一个点，然后通过一条返祖边，**恰好到达 $i$ 的位于树上第 $j$ 层的祖先**，的最短路（额不是从 $i$ 出发往上走 $j$ 层的祖先……）。这是可以预处理 DP 的：

$$f_{i,j}=\min\{f_{2i,j}+a_{2i},f_{2i+1,j}+a_{2i+1},w_{i,j}\}$$

其中 $w_{i,j}$ 表示直接从 $i$ 出发到 $j$ 层祖先的第二类边的边权，即不用经过树边直接往上走的情况，输入时处理一下即可。

预处理好之后就可以直接处理 $u_{i-1}\to u_i$ 的转移了。那 $u_{i+1}\to u_i$ 的呢？转移成环了吗？

实际上发现由于最短路上不可能有环，我们没必要把 $u_i$ 的实际值马上计算出来，每次算出一个 $u_i$ 的时候尝试把所有 $j<i$ 的 $u_j$ 通过直接走蓝边更新一遍即可，因为我们只需要在转移时保证它是目前的最小值。

（upd：其实这玩意应该偏向于 Floyd 了吧……）

算出 $u_i$ 的最短路之后再算一遍每棵子树的答案之和即可。需要用到一些神秘位运算技巧。

预处理 $O(n2^n)$，每次求 $u_i$ 距离 $O(n^2)$，对每个点都要求一遍，总共是 $O(n^2 2^n)$ 的。

具体细节看代码。

```cpp
const ll J=1e18,N=19,M=998244353;
ll n,m,nn,a[1ll<<N];
ll dep[1ll<<N],sz[1ll<<N],f[1ll<<N][N],dis[1ll<<N];
ll sid[N],anc[N],ans;
void mian() {
	scanf("%lld%lld",&n,&m),nn=1ll<<n;
	memset(f,20,sizeof(f));
	for (ll i=2;i<nn;i++) {
		dep[i]=dep[i>>1]+1;
		scanf("%lld",&a[i]),f[i][dep[i]]=0;
		for (ll j=i;j>1;j>>=1) dis[i]+=a[j];
	}
	for (ll i=nn-1;i;i--) (sz[i]=sz[i<<1]+sz[i<<1|1]+a[i]*((1ll<<n-dep[i])-1))%=M; // 预处理 i 到 i 子树内的点的最短路之和
	for (ll i=1,x,y,z;i<=m;i++) {
		scanf("%lld%lld%lld",&x,&y,&z);
		f[y][dep[x]]=min(f[y][dep[x]],z);
	}
	for (ll i=nn-1;i;i--) for (ll j=0;j<dep[i];j++)
		f[i][j]=min({f[i][j],f[i<<1][j]+a[i<<1],f[i<<1|1][j]+a[i<<1|1]});
	for (ll i=1;i<nn;i++) {
		ll res=sz[i<<1]+sz[i<<1|1];
		for (ll j=dep[i],k=i;~j;j--,k>>=1) anc[j]=k,sid[j]=J;
		sid[dep[i]]=0;
		for (ll j=dep[i]-1;~j;j--) {
			for (ll k=dep[i];k>j;k--) sid[j]=min(sid[j],sid[k]+f[anc[k]][j]); // u_i -> u_i+1 的情况
			if (sid[j]<J) for (ll k=j+1;k<dep[i];k++)
				sid[k]=min(sid[k],sid[j]+dis[anc[k]]-dis[anc[j]]); // 倒回去用 u_i 更新 j<i 的 u_j
		}
		for (ll j=dep[i]-1;~j;j--) { // 对每棵子树算贡献
			if (sid[j]>=J) break;
			ll p=anc[j]<<1|(i>>dep[i]-j-1&1^1);
			(res+=sid[j]%M*(1ll<<n-1-j)%M+sz[p])%=M;
		}
		(ans+=res)%=M;
	}
	cout<<ans;
}
```

---

## 作者：_Ch1F4N_ (赞：0)

不难发现第二类边都是从上往下的。

这说明了从下往上走一定只走第一类边。

显然，如果走了第二类边的话就一定有边被重复走。

这说明当从点 $u$ 到点 $v$ 时一定要先走第一类边到两点的最近公共祖先。

考虑把贡献挂到这个上面算，点到公共祖先的贡献预处理下深度就行了，然后你要解决的问题就是一个点到其左右儿子的子树内所有点距离之和。

那么第一类边显然只会走子树内的，第二类边只会走终点在子树内的，不然就肯定又要走重复的路。

而对于起点在子树内的第二类边是平凡的，否则要去往起点就一定要进过子树的根，考虑转化成子树的根到第二类边的终点的边即可。

然后对子树内所有点和边跑一遍单源最短路处理处距离再求和。

然后对于每个点暴力跳祖先算贡献即可。

由于一条边只会被其终点所有祖先算到，一个点也只会被其所有祖先算到，再算上单源最短路就可以分析出总共的复杂度是 $O(2^n \times n^2)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 998244353
using namespace std;
const int maxn = 18;
const int maxm = 3e5+114;
const int inf = 1e15+114;
int fa[1ll<<maxn];
int dis[1ll<<maxn];//某个点到其左右子树内点的最短路
int use[1ll<<maxn];
int F[1ll<<maxn][2];//某个点到左右子树最短路和
int G[1ll<<maxn][2];//某个点到左右子树最短路数量
int dep[1ll<<maxn];
int n,m;
int ans;
vector< pair<int,int> > E[maxm];//把第二类道路 u->v 挂到 v 上面
priority_queue< pair<int,int> > q;
void dfs(int u){
    if(u*2>=(1ll<<n)) return ;
    dep[u*2]=dep[u]+fa[u*2];
    dep[u*2+1]=dep[u]+fa[u*2+1];
    dfs(u*2);
    dfs(u*2+1);
}
vector< pair<int,int> > edge[maxm];
vector<int> sz[1ll<<maxn];
void work(int u){
    for(int x:sz[u*2]) sz[u].push_back(x);
    for(int x:sz[u*2+1]) sz[u].push_back(x);
    sz[u].push_back(u);
	for(int x:sz[u]) dis[x]=inf,use[x]=0;
    for(int x:sz[u]){
        if(x!=u){
            edge[x].push_back(make_pair(x/2,fa[x]));
        }
        for(pair<int,int> nxt:E[x]){
            int y=nxt.first,w=nxt.second;
            if(dep[y]>=dep[u]){
                edge[y].push_back(make_pair(x,w));
            }else{
                edge[u].push_back(make_pair(x,dep[u]-dep[y]+w));
            }
        }
    }
    dis[u]=0;
    q.push(make_pair(-dis[u],u));
    while(q.size()>0){
        int u=q.top().second;
        q.pop();
        if(use[u]==1) continue;
        use[u]=1;
        for(pair<int,int> nxt:edge[u]){
            int v=nxt.first,w=nxt.second;
            if(dis[v]>dis[u]+w&&use[v]==0){
                dis[v]=dis[u]+w;
                q.push(make_pair(-dis[v],v));
            }
        }
    }
    for(int x:sz[u*2]){
        F[u][0]+=(dis[x]>=inf?0:dis[x])%mod;
        G[u][0]+=(dis[x]>=inf?0:1);
    }
    for(int x:sz[u*2+1]){
        F[u][1]+=(dis[x]>=inf?0:dis[x])%mod;
        G[u][1]+=(dis[x]>=inf?0:1);
    }
    sz[u*2].clear();
    sz[u*2+1].clear();
    for(int x:sz[u]) edge[x].clear();
    return ;
}
signed main(){
    //freopen("trade.in", "r", stdin);
    //freopen("trade.out", "w", stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m;
    for(int i=2;i<=(1ll<<n)-1;i++) cin>>fa[i];
    dfs(1);
    for(int i=1;i<=m;i++){
        int u,v,w;
        cin>>u>>v>>w;
        E[v].push_back(make_pair(u,w));
    }
    for(int i=(1ll<<n)-1;i>=1;i--){
        if(i*2+1<=(1ll<<n)-1) work(i);
        else sz[i].push_back(i); 
    }
    for(int i=1;i<=(1ll<<n)-1;i++){
        int u=i,type=i%2;
        u/=2;
        ans=(ans+F[i][0]+F[i][1])%mod;
        while(u!=0){
            ans=(ans+((dep[i]-dep[u])%mod))%mod;
            ans=(ans+((dep[i]-dep[u])%mod)*G[u][type^1])%mod;
            ans=(ans+F[u][type^1])%mod;
            type=u%2;
            u/=2;
        }
    }
    cout<<ans<<'\n';
    return 0;
}
```



---

## 作者：eastcloud (赞：0)

[更好的阅读体验](https://www.cnblogs.com/eastcloud/p/17596401.html)

题目要求我们求出任意两点间最短路径之和，由于图比较特殊，除树边外只有祖先到其子树内的边，我们首先考虑最短路径有没有什么特殊性质。

注意到两点之间的最短路分为一下三种：

1. 节点到其祖先的最短路：直接沿着树边向上走即可，否则一定会走多余的边，不是最优。

2. 节点到其子树的最短路：此时最短路一定形如沿着树边走若干条边，再走一条非树边，走若干条树边如此交替进行，当然此处也可以连续走非树边。

3. 两个节点没有祖先孩子关系的最短路：如果此时要从 $u$ 点走到 $v$ 点，由于图中没有横叉边，$u$ 点必须要走到 $\operatorname{lca}(u,v)$，否则一定无法通过非树边到 $v$ 点，之后转为为从 $\operatorname{lca}(u,v)$ 到 $v$ 的第二类最短路。

这三条最短路都会经过 $\operatorname{lca}(u,v)$，由于其唯一性，考虑枚举最近公共祖先统计答案，第二类是方便统计的，而此时第一类也已经被处理了，我们把第三类分为两部分：从 $u$ 到 $\operatorname{lca}(u,v)$ 和 从 $\operatorname{lca}(u,v)$ 到 $v$。

第一段通过预处理即可解决，对于每个枚举到的  $\operatorname{lca}$，由于树高是 $\log$ 的，第二段路径所牵扯到的节点数也不会超过 $N\log N$ 个，因此可以直接建反图暴力跑最短路统计，之后模仿点分治计算一遍即可。

代码中我对于每个 $\operatorname{lca}$ 的子节点正序倒序分别枚举了一次，枚举到每颗子树时累加前面的子树走前半段，这颗子树走后半段的答案，即可保证不重不漏。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector> 
#include<queue>
#define ll long long
#define N 700005
using namespace std;
const ll mod=998244353;
const ll inf=0x3f3f3f3f3f3f3f3f;
ll tot,dsum[N],dfn[N],ri[N],val[N],dis[N],vis[N],dep[N];
ll bel[N],siz[N],ans,ttp[N],sta[N],p,ct[N];
struct graph{
	ll e,head[N],to[N],nex[N],edg[N];
	void add(ll u,ll v,ll w){
		to[++e]=v;nex[e]=head[u];head[u]=e;edg[e]=w;
	}
	void clear(){
		for(ll i=1;i<=e;i++)head[i]=nex[i]=edg[i]=to[i]=0;
		e=0;
	}
}T,G;
struct edg{
	ll u,v,w;
};
struct Node{
	ll v,val;
	bool operator <(const Node &x)const{
		return val>x.val;
	}
};
void adj(ll &x){
	x=(((x%mod)+mod)%mod);
}
priority_queue<Node> q;
vector<edg> E[N];
void dfs(ll x){
	dfn[x]=++tot;bel[tot]=x;siz[x]=1;
	for(ll i=T.head[x];i;i=T.nex[i]){
		ll v=T.to[i],w=T.edg[i];dep[v]=dep[x]+w;adj(dep[v]);dfs(v);
		dsum[x]+=w*siz[v]+dsum[v];dsum[x]%=mod;
		siz[x]+=siz[v];
	}
	ri[x]=tot;
}
void dij(ll s){
	q.push((Node){s,0});dis[s]=0;
	while(q.size()){
		ll x=q.top().v;q.pop();if(vis[x]) continue;
		vis[x]++;
		for(ll i=G.head[x];i;i=G.nex[i]){
			ll v=G.to[i],w=G.edg[i];
			if(dis[v]>dis[x]+w){
				dis[v]=dis[x]+w;
				q.push((Node){v,dis[v]});
			}
		}
	}
}
void dfs2(ll x){
	G.clear();
	for(ll i=dfn[x];i<=ri[x];i++){
		dis[i]=inf;vis[i]=0;ans+=dep[bel[i]]-dep[x];adj(ans);
		for(ll j=0;j<E[bel[i]].size();j++){
			G.add(dfn[E[bel[i]][j].u],dfn[E[bel[i]][j].v],E[bel[i]][j].w);
		}
		G.add(dfn[bel[i]],dfn[bel[i]/2],val[bel[i]]);
	}
	ll tmp=x,tmp2=x/2,sumdis=0,sumsiz=1,cnt=0,tp=0;
	while(tmp2){
		G.add(dfn[tmp],dfn[tmp2],val[tmp]);
		vis[dfn[tmp]]=0;dis[dfn[tmp]]=inf;tmp=tmp2;tmp2/=2;
	}
	vis[1]=0;dis[1]=inf;dij(dfn[x]);tmp=x;p=0;
	for(ll i=T.head[x];i;i=T.nex[i]){
		sta[++p]=i;ll v=T.to[i];tp=0;cnt=0;
		for(ll j=dfn[v];j<=ri[v];j++){
			if(dis[j]!=inf){
				tp+=dis[j];adj(tp);cnt++;
			}
		}
		ttp[v]=tp;ct[v]=cnt;
		ans+=((sumsiz*tp)%mod)+((cnt*sumdis)%mod);adj(ans);
		sumsiz+=siz[v];adj(sumsiz);
		sumdis+=dsum[v]+((T.edg[i]*siz[v])%mod);adj(sumdis);
	}
	sumsiz=sumdis=0;
	for(ll i=p;i>=1;i--){
		ll j=sta[i],v=T.to[j];tp=ttp[v];cnt=ct[v];
		ans+=((sumsiz*tp)%mod)+((cnt*sumdis)%mod);adj(ans);
		sumsiz+=siz[v];adj(sumsiz);
		sumdis+=dsum[v]+((T.edg[j]*siz[v])%mod);adj(sumdis);
	}
	for(ll i=dfn[x];i<=ri[x];i++)G.head[i]=dis[i]=0;
	while(tmp){G.head[dfn[tmp]]=0;dis[dfn[tmp]]=0;tmp/=2;}
	for(ll i=T.head[x];i;i=T.nex[i])dfs2(T.to[i]);
}
ll read(){
	ll x=0,f=1;char ch=getchar();
	while(ch<'0' || ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9'){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
int main(){
	ll n,m,u,v,w;n=read();m=read();n=(1<<n)-1;
	for(ll i=2;i<=n;i++){cin>>w;T.add((i/2),i,w);val[i]=w;}
	for(ll i=1;i<=m;i++){
		u=read();v=read();w=read();
		E[v].push_back((edg){u,v,w});
	}
	dfs(1);dfs2(1);
	cout<<ans;
}
```


---


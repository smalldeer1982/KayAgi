# [NOI2023] 字符串

## 题目描述

小 Y 是一名大学生，最近正在研究字符串方向的问题。

小 Y 了解到关于字符串的如下定义:

- 给定一个长度为 $n$ 的字符串 $s[1: n]$，我们定义其子串 $s[l: r]$（$1 \leq l \leq r \leq n$）为选择 $s[l], s[l+1], \dots, s[r]$, 将其顺次拼接得到的新字符串。
- 给定一个长度为 $n$ 的字符串 $s[1: n]$，我们定义其翻转后的结果 $R(s)$ 为将 $s[n], s[n-1], \dots, s[1]$ 顺次拼接，也就是将字符串反序拼接得到的字符串。
- 给定两个长度均为 $n$ 的字符串 $a[1: n], b[1: n]$，我们定义 $a$ 的字典序小于 $b$ 当且仅当存在 $1 \leq i \leq n$，使得对于任意 $1 \leq j < i$，$a[j] = b[j]$，且 $a[i] < b[i]$。

在了解了上述定义后，小 Y 想到了这样的问题:

给定一个长度为 $n$ 的字符串 $s[1: n]$。有 $q$ 次询问，每次询问给定两个参数 $i, r$。你需要求出有多少 $l$，满足如下条件:
- $1 \leq l \leq r$。
- $s[i: i+l-1]$ 字典序小于 $R(s[i+l: i+2l-1])$。

小 Y 想求助你帮忙解决这一问题。

## 说明/提示

**【样例解释 #1】**

对于第一组数据的第一组询问：
- $l = 1$ 时，$s[i: i + l - 1] = \texttt{a}$，$R(s[i + l: i + 2l - 1]) = \texttt{b}$。
- $l = 2$ 时，$s[i: i + l - 1] = \texttt{ab}$，$R(s[i + l: i + 2l - 1]) = \texttt{ca}$。
- $l = 3$ 时，$s[i: i + l - 1] = \texttt{aba}$，$R(s[i + l: i + 2l - 1]) = \texttt{bac}$。
- $l = 4$ 时，$s[i: i + l - 1] = \texttt{abac}$，$R(s[i + l: i + 2l - 1]) = \texttt{baba}$。

这四种情况中，$s[i: i + l - 1]$ 的字典序均小于 $R(s[i + l: i + 2l - 1])$。因此答案为 $4$。

**【样例解释 #2】**

该样例数据范围满足测试点 $5$。

**【样例解释 #4】**

该样例数据范围满足测试点 $24 \sim 25$。

**【数据范围】**

对于所有测试数据保证：$1 \le t \le 5$，$1 \le n \le 10 ^ 5$，$1 \le q \le 10 ^ 5$，$1 \le i + 2r - 1 \le n $，字符串 $s$ 仅包含小写字母。

|测试点编号|$n \le$|$q \le$|特殊性质|
|:-:|:-:|:-:|:-:|
|$1$|$5$|$5$|A|
|$2$|$10$|$10$|A|
|$3$|$20$|$20$|A|
|$4$|$50$|$50$|A|
|$5$|$10^2$|$10^2$|A|
|$6$|$10^3$|$10^3$|无|
|$7$|$2,000$|$2,000$|无|
|$8$|$3,000$|$3,000$|无|
|$9$|$4,000$|$4,000$|无|
|$10$|$23,333$|$23,333$|A|
|$11$|$5 \times 10 ^ 4$|$5 \times 10 ^ 4$|A|
|$12$|$75,000$|$75,000$|A|
|$13$|$9 \times 10 ^ 4$|$9 \times 10 ^ 4$|A|
|$14$|$10 ^ 5$|$10 ^ 5$|A|
|$15$|$23,333$|$23,333$|B|
|$16$|$75,000$|$75,000$|B|
|$17$|$9 \times 10 ^ 4$|$9 \times 10 ^ 4$|B|
|$18$|$10 ^ 5$|$10 ^ 5$|B|
|$19$|$23,333$|$23,333$|无|
|$20$|$5 \times 10 ^ 4$|$5 \times 10 ^ 4$|无|
|$21$|$75,000$|$75,000$|无|
|$22$|$9 \times 10 ^ 4$|$9 \times 10 ^ 4$|无|
|$23$|$95,000$|$95,000$|无|
|$24 \sim 25$|$10 ^ 5$|$10 ^ 5$|无|

特殊性质 A：保证字符串中仅包含字符 $\texttt{a}$ 和 $\texttt{b}$，且每个字符独立等概率地在 $\texttt{a}$ 和 $\texttt{b}$ 中选择。

特殊性质 B：保证字符串中的相邻字符互不相同。

**在洛谷上，本题 Subtask 1 中为 hack 数据，保证 $c=25$**。

## 样例 #1

### 输入

```
0 2
9 3
abacababa
1 4
2 4
3 3
9 3
abaabaaba
1 4
2 4
3 3
```

### 输出

```
4
0
3
2
0
2
```

## 样例 #2

### 输入

```
见附件中的 string/string2.in。```

### 输出

```
见附件中的 string/string2.ans。```

## 样例 #3

### 输入

```
见附件中的 string/string3.in。```

### 输出

```
见附件中的 string/string3.ans。```

## 样例 #4

### 输入

```
见附件中的 string/string4.in。```

### 输出

```
见附件中的 string/string4.ans。```

# 题解

## 作者：Alex_Wei (赞：35)

### [P9482 [NOI2023] 字符串](https://www.luogu.com.cn/problem/P9482)

设 $S_i$ 表示 $s$ 的从位置 $i$ 开始的后缀，$P_i$ 表示 $s$ 的从位置 $i$ 开始的前缀。

先考虑朴素的 $\mathcal{O}(qn ^ 2)$ 暴力：枚举所有 $1\leq l\leq r$，检查是否有 $s[i, i + l - 1] < s ^ R[i + l, i + 2l - 1]$，记作条件 $X$。

我们发现，没有很好的后缀数据结构精确刻画所有 $s ^ R[i + l, i + 2l - 1]$。此时一般有两种思路：将限制放宽，再减去不合法的；将限制缩紧，再加上没统计到的。

相比于 “子串”，我们肯定更希望看到 “前缀” 或 “后缀”，因为前者有 $\mathcal{O}(n ^ 2)$ 个，而后者只有 $\mathcal{O}(n)$ 个。因此，尝试将限制改写成 $S_i < P_{i + 2l - 1}$，记作条件 $Y$，再对求出的答案进行修正。

首先思考这样做对答案造成的影响：如果满足条件 $X$，条件 $Y$ 显然一定被满足。因此，需要减去满足条件 $Y$ 但不满足条件 $X$（记作条件 $Z$）的 $l$ 的数量。

尝试推出条件 $Z$ 对应的限制：如果 $s[i, i + l - 1] > s ^ R[i + l, i + 2l - 1]$，则 $S_i > P_{i + 2l - 1}$，不满足条件 $Y$。又因为不能满足条件 $X$，所以 $s[i, i + l - 1] = s ^ R[i + l, i + 2l - 1]$，即 $s[i, i + 2l - 1]$ 回文。再根据条件 $Y$，推出 $S_{i + 2l} < P_{i - 1}$。容易证明这是充要条件。

综上，我们将问题分成两部分：计算 $S_i < P_{i + 2l - 1}$ 的 $l$ 的数量，减去 $s[i, i + 2l - 1]$ 回文且 $S_{i + 2l} < P_{i - 1}$ 的 $l$ 的数量。

第一部分相当容易：对 $s + c + s ^ R + d$ 建出后缀数组，其中 $c, d$ 是任意不属于字符集的分隔符，**且我们认为 $c, d$ 小于字符集的任意字符且 $c > d$**，这是为了保证在 $S_i$ 是 $P_j$ 的前缀或 $P_j$ 是 $S_i$ 的前缀时正确比较两个前后缀，以及当 $S_i = P_j$ 时得到 $[S_i < P_j] = 0$。那么，问题转化为有多少个结束位置形如 $i + 2l - 1$ 的前缀，排名大于 $S_i$ 对应的后缀。二维偏序，离线询问后按排名从大到小扫描线，遇到前缀则标记对应位置，遇到后缀则处理其对应的所有询问，形如查询区间内被标记的奇数或偶数位置数量。用两棵 BIT 维护即可。

第二部分相对困难一些。称 **长度为偶数** 的回文串 $s[l, r]$ 合法，当且仅当 $S_{r + 1} < P_{l - 1}$。则第二部分要求合法的 $s[i, i + 2l - 1]$ 的数量。

尝试刻画所有回文串，有两种方式：Manacher 和 PAM。因为我不会 PAM，所以考虑 Manacher，它求出了以所有位置或间隔为回文中心的最长回文半径。由于要求长度为偶数，所以本题只用到了以间隔为回文中心的最长回文半径。

接下来是本题最核心的观察：**回文串具有一定对称性**。考虑 $i\sim i + 1$ 的间隔对应的所有回文串 $s[i - l, i + 1 + l]$，设最大的 $l$ 为 $R_i$。我们发现，在比较 $S_{i + l + 2}$ 和 $P_{i - l - 1}$ 时，它们具有长度为 $R_i - l$ 的公共前缀：因为 $s[i - R_i, i + 1 + R_i]$ 回文，所以 $s[i + l + 2, i + 1 + R_i] = s ^ R[i - R_i, i - l - 1]$。又因为 $s_{i + R_i + 2} \neq s_{i - R_i - 1}$（否则 $R_i$ 可以更大），所以只需检查是否有 $s_{i + R_i + 2} < s_{i - R_i - 1}$。如果满足限制，则所有 $s[i - l, i + 1 + l]$ 均合法，反之则均不合法。

现在问题转化为：给平面上一条斜率为 $-1$ 的线段上所有点的权值 $+1$，点的坐标形如 $(i - l, i + 1 + l)$，其中 $0\leq l\leq R_i$。支持给定某点 $(i, i + 2r - 1)$，查询它下方（包括它本身）的所有点的权值之和，相当于固定横坐标 $i$，求有多少 $i + 2l - 1$ 满足 $s[i, i + 2l - 1]$ 合法。坐标变换后也是经典二维数点，直接做即可。我的做法是：纵坐标的定义为长度一半，则线段的点形如 $(i - l, l + 1)$（$0\leq l\leq R_i$），查询的点形如 $(i, r)$。令横坐标加上纵坐标，则线段的点形如 $(i + 1, l + 1)$（$0\leq l\leq R_i$），查询的点形如 $(i + r, r)$。这样，一条线段对查询的点的影响形如矩形 $+1$，且矩形没有上边界。若干次矩形加之后若干次单点查询，扫描线即可。

总时间复杂度 $\mathcal{O}((n + q)\log n)$。

同学用了一些牛鬼蛇神方法，复杂度形如 $\mathcal{O}(\frac {n ^ 2} w)$ 或 $\mathcal{O}(n\log ^ 2 n)$（$n, q$ 同级），基本上都过了。还有 $n ^ 2$ 过的，发怒了。

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using pdi = pair<double, int>;
using pdd = pair<double, double>;
using ull = unsigned long long;

#define ppc(x) __builtin_popcount(x)
#define clz(x) __builtin_clz(x)

bool Mbe;
// mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());
mt19937_64 rnd(1064);
int rd(int l, int r) {
  return rnd() % (r - l + 1) + l;
}

constexpr int mod = 1e9 + 7;
void addt(int &x, int y) {
  x += y, x >= mod && (x -= mod);
}
int add(int x, int y) {
  return x += y, x >= mod && (x -= mod), x;
}
int ksm(int a, int b) {
  int s = 1;
  while(b) {
    if(b & 1) s = 1ll * s * a % mod;
    a = 1ll * a * a % mod, b >>= 1;
  }
  return s;
}

constexpr int Z = 1e6 + 5;
int fc[Z], ifc[Z];
int bin(int n, int m) {
  if(n < m) return 0;
  return 1ll * fc[n] * ifc[m] % mod * ifc[n - m] % mod;
}
void init_fac(int Z) {
  for(int i = fc[0] = 1; i < Z; i++) fc[i] = 1ll * fc[i - 1] * i % mod;
  ifc[Z - 1] = ksm(fc[Z - 1], mod - 2);
  for(int i = Z - 2; ~i; i--) ifc[i] = 1ll * ifc[i + 1] * (i + 1) % mod;
}

// ---------- templates above ----------

constexpr int N = 2e5 + 5;

int n, m, q;
char s[N], t[N];
ll ans[N];

namespace SA {
  int sa[N], rk[N];
  int buc[N], ork[N], id[N];
  bool cmp(int a, int b, int w) {
    return ork[a] == ork[b] && ork[a + w] == ork[b + w];
  }
  void build(int n) {
    memset(buc, 0, N << 2);
    int m = 1 << 7, p = 0;
    for(int i = 1; i <= n; i++) buc[rk[i] = t[i]]++;
    for(int i = 1; i <= m; i++) buc[i] += buc[i - 1];
    for(int i = n; i; i--) sa[buc[rk[i]]--] = i;
    for(int w = 1; ; w <<= 1, m = p, p = 0) {
      for(int i = n - w + 1; i <= n; i++) id[++p] = i;
      for(int i = 1; i <= n; i++) if(sa[i] > w) id[++p] = sa[i] - w;
      memset(buc, 0, N << 2);
      memcpy(ork, rk, N << 2), p = 0;
      for(int i = 1; i <= n; i++) buc[rk[i]]++;
      for(int i = 1; i <= m; i++) buc[i] += buc[i - 1];
      for(int i = n; i; i--) sa[buc[rk[id[i]]]--] = id[i];
      for(int i = 1; i <= n; i++) rk[sa[i]] = cmp(sa[i - 1], sa[i], w) ? p : ++p;
      if(p == n) break;
    }
  }
}

struct BIT {
  int c[N];
  void clear() {
    memset(c, 0, N << 2);
  }
  void add(int x, int v) {
    while(x < N) c[x] += v, x += x & -x; 
  }
  int query(int x) {
    int s = 0;
    while(x) s += c[x], x -= x & -x;
    return s;
  }
  int query(int l, int r) {
    return query(r) - query(l - 1);
  }
};

namespace Part1 {
  struct dat {
    int id, l, r;
  };
  vector<dat> qu[N];
  void add(int i, int r, int id) {
    qu[SA::rk[i]].push_back({id, i + 1, i + r + r - 1});
  }
  
  BIT odd, eve;
  void solve() {
    odd.clear(), eve.clear();
    for(int i = m; i; i--) {
      int pos = SA::sa[i];
      if(pos <= n) {
        for(dat it : qu[i]) {
          if(it.l & 1) ans[it.id] += odd.query(it.l, it.r);
          else ans[it.id] += eve.query(it.l, it.r);
        }
      }
      else if(pos > n + 1 && pos < m) {
        pos = m - pos;
        if(pos & 1) odd.add(pos, 1);
        else eve.add(pos, 1);
      }
    }
    for(int i = 1; i < N; i++) qu[i].clear();
  }
}

namespace Part2 {
  vector<pii> qu[N], ad[N];
  void add(int i, int r, int id) {
    qu[i].push_back({i + r, id});
  }
  
  BIT tr;
  int R[N];
  char u[N];
  void solve() {
    tr.clear();
    int cnt = 0;
    u[0] = ',', u[cnt = 1] = '?';
    for(int i = 1; i <= n; i++) {
      u[++cnt] = s[i];
      u[++cnt] = '?';
    }
    u[++cnt] = '!';
    for(int i = 1, c = 0, r = 0; i < cnt; i++) {
      R[i] = i > r ? 1 : min(r - i + 1, R[c + c - i]);
      while(u[i - R[i]] == u[i + R[i]]) R[i]++;
      if(i + R[i] - 1 > r) c = i, r = i + R[i] - 1;
    }
    for(int i = 2; i <= n; i++) {
      int r = R[i * 2 - 1] >> 1;
      if(!r || s[i + r] >= s[i - r - 1]) continue;
      ad[i - r].push_back({i, 1});
      ad[i].push_back({i, -1});
    }
    for(int i = 1; i <= n; i++) {
      for(pii it : ad[i]) tr.add(it.first, it.second);
      for(pii it : qu[i]) ans[it.second] -= tr.query(it.first);
    }
    for(int i = 1; i < N; i++) {
      qu[i].clear();
      ad[i].clear();
    }
  }
}

void mian() {
  cin >> n >> q >> s + 1, m = 0;
  for(int i = 1; i <= n; i++) t[++m] = s[i];
  t[++m] = 57;
  for(int i = n; i; i--) t[++m] = s[i];
  t[++m] = 40;
  SA::build(m);
  for(int _ = 1; _ <= q; _++) {
    int i, r;
    cin >> i >> r;
    Part1::add(i, r, _);
    Part2::add(i, r, _);
  }
  Part1::solve();
  Part2::solve();
  for(int i = 1; i <= q; i++) {
    cout << ans[i] << "\n";
    ans[i] = 0;
  }
}


bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  int c, T = 1;
  cin >> c >> T;
  while(T--) mian();
  cerr << 1e3 * clock() / CLOCKS_PER_SEC << " ms\n";
  return 0;
}
```

---

## 作者：AK_Dream (赞：32)

分享一个我在考场上使用的压位 bitset 做法，不需要使用任何后缀或回文数据结构。

我们称一个长度为 $2l$ 的串 $t$ 合法当且仅当 $t[1:l]<R(t[l+1:2l])$。

定义 $F(i,j)$ 表示 $s[i:i+2j-1]$ 是否是一个合法的串，则一次询问 $i,r$ 相当于在求 $\sum\limits_{j=1}^{r} F(i,j)$。

对于 $F(i,j)$ 有：

$$F(i,j)=\begin{cases} 0 & s_{i} > s_{i+2j-1} \ \cup \ j=0 \\ 1 & s_i<s_{i+2j-1} \\ F(i+1,j-1) & s_{i} = s_{i+2j-1} \end{cases}$$

通过这个转移式就可以在 $O(n^2)$ 的时间复杂度内预处理出所有 $F(i,j)$ 从而解决原问题。

考虑将询问离线，对 $i$ 进行扫描线。

如果对于固定的 $i$ 将 $F(i,x)$ 看作一个关于 $x$ 的函数，那么可以发现从 $F(i+1,x)$ 转移到 $F(i,x)$ 时，需要先将整个函数左移一位，然后把所有满足 $s_i>s_{i+2j-1}$ 的位置 $j$ 设为 $0$，再把所有 $s_i<s_{i+2j-1}$ 的位置设为 $1$，显然可以使用 bitset 维护。注意奇偶位需要分开维护。

询问需要查询一个 bitset 前 $r$ 位中共有多少个 $1$，从方便程度和代码运行效率上考虑推荐手写 bitset。

复杂度 $O(\frac{n^2}{w})$，但由于奇偶位分开实际上 bitset 长度只有 $50000$，考场上我用 ull 实现 bitset，实际测试时最慢数据只跑了不到 0.7s。



代码相较其他做法应该比较简短。

```cpp
#include <bits/stdc++.h>
#define N 100005
#define pb push_back
#define fi first
#define se second
using namespace std;
typedef unsigned long long ull;

int n, m, MX, ans[N];
char s[N];
vector<pair<int,int> > qq[N];

struct bset {
	ull v[805];
	void clr() { memset(v,0,sizeof(v)); }
	void set1(int x) { v[x>>6] |= 1ull<<(x&63); }
	void mv1() {
		int p = 0;
		for (int i = 0; i <= MX; i++) {
			int c = v[i]>>63&1;
			v[i] = v[i]<<1|p; p = c;
		}
	}
	int cnt1(int k) {
		++k; int p = k>>6, q = k&63, r = 0;
		for (int i = 0; i < p; i++) r += __builtin_popcountll(v[i]);
		r += __builtin_popcountll(v[p]&((1ull<<q)-1));
		return r;
	}
} A[2][26], B[2][26], F;
void And(bset &p, bset &q, int k) {
	int u = k>>6, v = k&63;
	for (int i = 0; i <= MX; i++) {
		if (i+u > 790) break;
		ull nw = (q.v[i+u]>>v);
		if (v) nw |= (q.v[i+u+1]<<(64-v));
		p.v[i] &= ~nw;
	}
}
void Or(bset &p, bset &q, int k) {
	int u = k>>6, v = k&63;
	for (int i = 0; i <= MX; i++) {
		if (i+u > 790) break;
		ull nw = (q.v[i+u]>>v);
		if (v) nw |= (q.v[i+u+1]<<(64-v));
		p.v[i] |= nw;
	}
}

void solve() {
	scanf("%d %d %s", &n, &m, s+1);
	for (int i = 1; i <= n; i++) qq[i].clear();
	for (int i = 1; i <= m; i++) {
		int l, r; scanf("%d %d", &l, &r);
		qq[l].pb({r,i}); 
	}
	F.clr();
	for (int o:{0,1}) for (int i = 0; i < 26; i++) 
		A[o][i].clr(), B[o][i].clr();
	int t[2] = {50000,50000};
	for (int i = n-1; i; i--) {
		int o = i&1, c = s[i+1]-'a';
		MX = (n-i+1)>>7; F.mv1(); --t[o];
		for (int j = 0; j < c; j++) A[o][j].set1(t[o]+1);
		for (int j = c+1; j < 26; j++) B[o][j].set1(t[o]+1);
		c = s[i]-'a';
		if (c > 0) And(F, B[o][c], t[o]);
		if (c+1 < 26) Or(F, A[o][c], t[o]); 
		for (auto e : qq[i]) ans[e.se] = F.cnt1(e.fi);
	}
	for (int i = 1; i <= m; i++) printf("%d\n", ans[i]);
}

int main() {
	int ID, ttt; scanf("%d %d", &ID, &ttt);
	while (ttt--) solve(); 
	return 0;
} 
```

---

## 作者：cwfxlh (赞：11)

# [P9482](https://www.luogu.com.cn/problem/P9482)    

题面中的比较操作有一个 reverse，于是考虑在串 $s$ 后面接上一个 $R(s)$，变成 $t=s[1]s[2]s[3]\dots s[n]\inf s[n]s[n-1]\dots s[2]s[1](-\inf)$，插入了两个 $\inf$ 的目的是为了方便计算，避免其他分讨。       

令 $m=2\times n+2$，对于一组 $(i,k)$，其合法的必要条件是 $t[i,m]<t[m-i+1-2\times k,m]$，必要性是显然的。考虑什么时候这个条件不充分，有可能的是 $[i,i+2\times k-1]$ 是一个回文串，同时这个回文串扩展后的两端 $[l,r]$ 满足 $s[l-1]>s[r+1]$，这样就导致上面那一个条件成立，但是 $s[i,i+k-1]=R(s[i+k,i+2\times k-1])$。我们找到所有这样的极长回文串（上面插入的两个 $\inf$ 可以避免在边界处分讨），从答案中减去这些串的贡献即可。第一部分的贡献可以对 $t$ 建出后缀数组然后扫描线，第二部分求出回文半径后扫描线即可，复杂度 $O((n+q)\log n)$。    

代码：   

```cpp
#include<bits/stdc++.h>
#define MOD 998244353
#define P 13331
using namespace std;
int tppp,t,n,m,q,a[500003],b[500003],qq[500003][2],ans[500003],c[500003],x[500003],y[500003],sa[500003],tot,sgm,lft,rgt,mid;
int hsv[500003],nhsv[500003],fsp[500003];
vector<int>qlst[500003];
vector<int>q2lst[500003];
string s;
int gethsv(int l,int r){return (((hsv[r]-1ll*hsv[l-1]*fsp[r-l+1])%MOD)+MOD)%MOD;}
int ngethsv(int l,int r){return (((nhsv[l]-1ll*nhsv[r+1]*fsp[r-l+1])%MOD)+MOD)%MOD;}
int lowbit(int X){return (X&(-X));}
class BIT{
	public:
		int TreeAr[500003];
		void init(){
			for(int i=0;i<=2*n+4;i++)TreeAr[i]=0;
			return;
		}
		void modify(int wz,int val){
			for(int i=wz;i<=2*n+4;i+=lowbit(i))TreeAr[i]+=val;
			return;
		}
		int Query(int l,int r){
			if(l>r)return 0;
			if(r<0||l>2*n+4)return 0;
			r=min(r,2*n+4);
			l=max(l,0);
			int ret=0;
			for(int i=r;i;i-=lowbit(i))ret+=TreeAr[i];
			for(int i=l-1;i;i-=lowbit(i))ret-=TreeAr[i];
			return ret;
		}
}T1,T2;
int main(){
	ios::sync_with_stdio(false);
	cin>>tppp>>t;
	fsp[0]=1;
	for(int i=1;i<=500000;i++)fsp[i]=1ll*fsp[i-1]*P%MOD;
	while(t--){
		cin>>n>>q>>s;
		m=n*2+2;
		for(int i=1;i<=n;i++)a[i]=b[i]=b[m-i]=s[i-1];
		b[n+1]=200;
		b[m]=1;
		sgm=max(m,200);
		for(int i=1;i<=sgm;i++)c[i]=0;
		for(int i=1;i<=m;i++)c[x[i]=b[i]]++;
		for(int i=1;i<=sgm;i++)c[i]+=c[i-1];
		for(int i=1;i<=m;i++)sa[c[x[i]]--]=i;
		for(int k=1;k<=m;k<<=1){
			tot=0;
			for(int i=m-k+1;i<=m;i++)y[++tot]=i;
			for(int i=1;i<=m;i++)if(sa[i]>k)y[++tot]=sa[i]-k;
			for(int i=1;i<=sgm;i++)c[i]=0;
			for(int i=1;i<=m;i++)c[x[i]]++;
			for(int i=1;i<=sgm;i++)c[i]+=c[i-1];
			for(int i=tot;i;i--)sa[c[x[y[i]]]--]=y[i],y[i]=0;
			tot=1;
			swap(x,y);
			x[sa[1]]=1;
			for(int i=2;i<=m;i++){
				if(y[sa[i]]==y[sa[i-1]]&&y[sa[i]+k]==y[sa[i-1]+k])x[sa[i]]=tot;
				else x[sa[i]]=++tot;
			}
		}
		for(int i=1;i<=n;i++)hsv[i]=(1ll*hsv[i-1]*P+a[i])%MOD;
		nhsv[n+1]=0;
		for(int i=n;i;i--)nhsv[i]=(1ll*nhsv[i+1]*P+a[i])%MOD;
		for(int i=1;i<=m;i++){
			qlst[i].clear();
			qlst[i].shrink_to_fit();
			q2lst[i].clear();
			q2lst[i].shrink_to_fit();
		}
		for(int i=1;i<=q;i++){
			cin>>qq[i][0]>>qq[i][1];
			qq[i][1]=min(qq[i][1],(n-qq[i][0]+1)/2);
		}
		for(int i=1;i<=q;i++)qlst[qq[i][0]].emplace_back(i);
		T1.init();
		T2.init();
		for(int i=m;i;i--){
			for(auto j:qlst[sa[i]]){
				if(sa[i]%2==0)ans[j]=T1.Query(2*n+3-sa[i]-2*qq[j][1],2*n+3-sa[i]-2);
				else ans[j]=T2.Query(2*n+3-sa[i]-2*qq[j][1],2*n+3-sa[i]-2);
			}
			if(sa[i]%2==1)T1.modify(sa[i],1);
			else T2.modify(sa[i],1);
		}
		for(int i=2;i<=n;i++){
			lft=0;
			rgt=min(i-1,n-i+1);
			while(lft<rgt){
				mid=((lft+rgt)>>1)+1;
				if(gethsv(i,i+mid-1)==ngethsv(i-mid,i-1))lft=mid;
				else rgt=mid-1;
			}
			if(lft==0)continue;
			if(i+lft-1==n||i-lft==1)continue;
			if(a[i+lft]>a[i-lft-1])continue;
			q2lst[i-lft].emplace_back(i-1);
		}
		T1.init();
		for(int i=1;i<=n;i++){
			for(auto j:q2lst[i])T1.modify(j,1);
			for(auto j:qlst[i])ans[j]-=T1.Query(qq[j][0],qq[j][0]+qq[j][1]-1);
		}
		for(int i=1;i<=q;i++)cout<<ans[i]<<endl;
	}
	return 0;
}
```


---

## 作者：ckain (赞：8)

### [P9482 [NOI2023] 字符串](https://www.luogu.com.cn/problem/P9482)
一组问题形如：查询以 $i$ 开头的子串数量，满足长度不超过 $r$ 并且子串的回文串字典序大于原来子串的字典序．

快速比较若干子串对的字典序貌似比较困难．我们可以将问题放宽一点，尝试比较一个后缀和若干前缀的反转的字典序．具体来说，我们将比较 $S[i:l]$ 和 $S[i+l:i+2l-1]^R$ 转化成比较 $S[i:n]$ 和 $S[1:i+2l-1]^R$．这样就有一些优势：

- 在多组比较中，其中的一个串是固定的 $S[i:n]$．
- 作比较的另一个串，也就是前缀的结束位置在奇数或偶数处形成了一个区间．

**注意到放宽后的问题其实并不与原问题等价．多统计的部分会在后面会进行说明．**

为了让问题形式变得更美观，我们考虑将 $S^R$ 拼接到 $S$ 的后面形成新串 $T=SS^R$．发现问题又变成了比较一个后缀和开始位置位于一个区间中的后缀的字典序关系．不妨看图：
![挂了么 QwQ](https://pic.imgdb.cn/item/64d57e431ddac507cc5a50cc.jpg)

发现比较 $A$ 和 $B$ 相当于比较 $A$ 和 $C$．

我们使用后缀数组求出每个后缀的排名，记作 $Rk$．一组询问 $(i,r)$ 相当于询问满足如下限制的后缀 $suf_p$ 数量：

- $p\in[2n-i-2r+2,2n-i]$
- $p\mod 2\equiv i$
- $Rk_p>Rk_i$

这是一个二维数点问题．离线可以使用树状数组解决．

---

那么现在来看将 **比较子串** 放宽为 **比较后缀** 会带来的多余贡献．

当 $S[i:i+l-1]$ 与 $S[i+l:i+2l-1]^R$ 完全相等的时候，这个位置是不能被统计到答案里去的．但由于我们比较的是后缀，可能就会存在 $Rk_{2n-i-2l+2}>Rk_i$ 然后被统计到的情况．我们需要将这类情况造成的贡献去掉．

出现这种情况的时候，有 $S[i:i+2l-1]$ 为回文串．那么我们要去掉的是一类以 $i$ 开头的回文前缀使得其可能被统计入答案．

直接做是不好做的．但是我们考虑对于回文中心相同的回文串，其对应的两个后缀比较结果是相同的．不妨看图：
![这张挂了么 QwQ](https://pic.imgdb.cn/item/64d5853e1ddac507cc669dee.jpg)

比较绿色回文串对应的两后缀（蓝色箭头）和比较红色回文串对应的两后缀（灰色箭头）本质上是在比较黄色箭头对应的两后缀．因为回文部分是相同的，我们直接跳过不比较也不会对比较结果产生影响．

那么可以这样做：预处理每个回文中心的极长回文半径（可以使用 manacher 或者 hash+二分，但听说好像暴力扩展也能过）．并在极长回文半径处检查，这个中心的回文串是否可以被统计入非法答案．对于一组询问需要减去的非法贡献就是位置在 $i$ 之后，并且极长回文半径可以达到 $i$ 的，可以被统计入非法答案的回文中心个数．这也是二维数点问题．

提供一份丑陋的代码：
```cpp
#include<bits/stdc++.h>
#define pii pair<int, int>
#define fr first
#define sc second
using namespace std;
inline int rd(void){
	int s=0, f=1; char c=getchar();
	while(c<'0' || c>'9') {if(c=='-') f=0; c=getchar();}
	while(c>='0' && c<='9') {s=s*10+c-'0'; c=getchar();}
	return f? s:-s;
}

const int N=2e5+5;

int c, T;

int n, q, ans[N];

char s[N];

int rk[N], sa[N], x[N], y[N], ct[N];

void get_rk(){
	int m='z';
	for(int i=1; i<=2*n; i++) ct[x[i]=s[i]]++;
	for(int i=2; i<=m; i++) ct[i]+=ct[i-1];
	for(int i=1; i<=2*n; i++) sa[ct[x[i]]--]=i;
	
	for(int sz=1; sz<=2*n; sz<<=1){
		int id=0;
		for(int i=2*n-sz+1; i<=2*n; i++) y[++id]=i;
		for(int i=1; i<=2*n; i++) if(sa[i]>sz) y[++id]=sa[i]-sz;
		for(int i=1; i<=m; i++) ct[i]=0;
		for(int i=1; i<=2*n; i++) ct[x[i]]++;
		for(int i=2; i<=m; i++) ct[i]+=ct[i-1];
		for(int i=2*n; i; i--) sa[ct[x[y[i]]]--]=y[i], y[i]=0;
		
		swap(x, y); x[sa[id=1]]=1;
		for(int i=2; i<=2*n; i++)
			x[sa[i]]=((y[sa[i]]==y[sa[i-1]] && y[sa[i]+sz]==y[sa[i-1]+sz])? id:++id);
		if(id==2*n) break;
		m=id;
	}
	for(int i=1; i<=2*n; i++) rk[sa[i]]=i;
}

int totc, ch[N], P[N];
void manacher(){
	ch[0]=-2, ch[totc=1]=-1;
	for(int i=1; i<=n; i++) ch[++totc]=s[i]-'a', ch[++totc]=-1;
	ch[++totc]=-3;
	
	for(int i=1, h=0, r=0; i<=totc; i++){
		P[i]=(i<=r? min(r-i+1, P[2*h-i]):1);
		while(ch[i-P[i]]==ch[i+P[i]]) P[i]++;
		if(i+P[i]-1>r) r=i+P[i]-1, h=i;
	}
}

struct Node{
	int rk_lim, Mod_type, delta, id;
};
vector<Node> act[N];

struct Node_Parlin{
	int touch, delta, id;
};
vector<Node_Parlin> actp[N];

struct Bit{
	int t[N];
	inline void reset(){
		memset(t, 0, sizeof(t));
	}
	inline void upd(int p, int d){
		for(; p<=2*n; p+=(p&-p)) t[p]+=d;
	}
	inline int q(int p){
		int re=0; for(; p; p-=(p&-p)) re+=t[p];
		return re;
	}
	inline int que(int l, int r){
		if(l>r) return 0;
		return q(r)-q(l-1);
	}
} bt[2];

void work(){
	//后缀扫描 
	for(int i=n+1; i<=2*n; i++){
		bt[i&1].upd(rk[i], 1);
		
		for(Node j:act[i]){
			ans[j.id]+=j.delta*bt[j.Mod_type].que(j.rk_lim+1, 2*n);
		}
	}
	
	bt[0].reset();
	//回文扫描 
	for(int i=1, ri; i<=n; i++){
		ri=(P[i*2+1]-1)/2;
		if(ri && rk[2*n-(i-ri)]>rk[i+ri]) bt[0].upd(i-ri+1, 1);
		
		for(Node_Parlin j:actp[i]){
			ans[j.id]+=j.delta*bt[0].que(1, j.touch);
		}
	}
	for(int i=1; i<=q; i++) printf("%d\n", ans[i]);
}

signed main(){
	c=rd(); T=rd();
	while(T--){
		n=rd(), q=rd();
		scanf("%s", s+1);
		for(int i=1; i<=n; i++) s[2*n-i+1]=s[i];
		
		get_rk();
		
		manacher();
		
		for(int i=1, sta, r; i<=q; i++){
			sta=rd(), r=rd();
			if(2*n-sta-2*r+1>n) act[2*n-sta-2*r+1].push_back({rk[sta], sta&1, -1, i});
			act[2*n-sta].push_back({rk[sta], sta&1, 1, i});
			
			if(sta>1) actp[sta-1].push_back({sta, 1, i});
			actp[sta+r-1].push_back({sta, -1, i});
		}
		
		work();
		
		//reset
		memset(ans, 0, sizeof(ans));
		memset(ct, 0, sizeof(ct));
		for(int i=1; i<=2*n; i++) act[i].clear(), actp[i].clear();
		bt[0].reset(), bt[1].reset();
		//
	}
	return 0;
}
/*
0 1
4 1
caaa
2 1
*/
```

---

## 作者：L_zaa_L (赞：7)

串串题！

很好吧，我们看到要比较字符串字典序大小时，我们可以想到用后缀数组，然后由于题目里面有关于反串的要求，所以说我们正反字符串连在一起就可以得出每个子串的字典序顺序。

我们现在想要 $s[i:i+l−1]<R(s[i+l:i+2l−1])$ 比较的时候我们就可以用后缀数组算出来的东西了，然后由于有限制 $1\le l \le r$，那么这就是一个非常显然的二维数点，然后由于 $1\le l \le r$ 不好枚举，所以我们直接从大到小枚举字典序，然后每次加入一个数（由于我们要两边长度相等，所以我们要按照奇偶性分成两个树状数组维护），那么对于一个左端点他合法的右端点一定被加入过，所以我们考虑哪些不合法的被加入过，就只有相等的可能，否则就会在相等之前被匹配出来，如果大了就是合法的，小了加不进去。所以我们要减去他们。

然后我们可以考虑用 manacher 算法，把所有偶回文串的贡献删去。回文串有一个性质就是如果 $S[l,r]$ 是回文串（$r-l+1\ge 3$），那么 $S[l+1,r-1]$ 也一定是回文串。那么我们就可以对于每个回文中心 $[x,x+1]$（因为要偶回文串），假设它最长回文串长度为 $len$，那么 $[x-len+1,len]$ 都有这一个合法的回文中心。然后再用一个树状数组，我们从左到右扫一遍，对于每个回文中心的最小合法左端点，我们都可以加入回文中心（假设是靠左的那一个）到树状数组中，然后对于每个限制条件 $[i,r]$，多算的就是 $[i,i+r-1]$ 中加入的回文中心的个数。

时间复杂度：$O(n\log n)$。

我的代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define ls(x) ((x)*2)
#define rs(x) ((x)*2+1)
#define Debug(...) fprintf(stderr, __VA_ARGS__)
#define For(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)
#define Rof(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)
#define rep(i,  b) for(int i=1,i##end=b;i<=i##end;i++)
using namespace std;
const int N=1e6+5,Mod=998244353;
//char buf[(1<<21)+5],*p1,*p2;
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline void chmx(int &x,int y){(x<y)&&(x=y);}
inline void chmn(int &x,int y){(x>y)&&(x=y);}
//typedef __int128_t i128;
//i128 _base=1;
//inline int mol(int x){return x-Mod*(_base*x>>64);}
//inline void Add(int &x,int y){x=mol(x+y+Mod);}
inline int read(){
	int f=0,x=0;
	char ch=getchar();
	while(!isdigit(ch)){f|=(ch=='-');ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return f?-x:x;
}
int n,m,q;
int t[N];
int rak[N],sa[N],tag[N],tp[N];
inline void GetSA(int len){
	m=50000;
For(i,1,len) rak[i]=t[i];
	For(i,1,m) tag[i]=0; 
	For(i,1,len) tag[rak[i]]++;
	For(i,1,m) tag[i]+=tag[i-1];
	Rof(i,len,1) sa[tag[rak[i]]--]=i;
	for(int k=1;k<=len;k<<=1){
		int p=0;
		For(i,0,m) tag[i]=0;
		For(i,len-k+1,len) tp[++p]=i;
		For(i,1,len) if(sa[i]>k) tp[++p]=sa[i]-k;
		For(i,1,len) tag[rak[i]]++;
		For(i,1,m) tag[i]+=tag[i-1];
		Rof(i,len,1) sa[tag[rak[tp[i]]]--]=tp[i],tp[i]=0;
		swap(rak,tp);
		rak[sa[1]]=1;
		p=1;
		For(i,2,len){
			rak[sa[i]]=(tp[sa[i]]==tp[sa[i-1]]&&tp[sa[i]+k]==tp[sa[i-1]+k])?p:++p;
		}
		m=p;
	}
}
int p[N];
char s[N];
void manacher(){
	t[0]='@';
	int q=0;
	t[++q]='#';
	for(int i=1;i<=n;++i){
		t[++q]=s[i];
		t[++q]='#';
	}
	t[q+1]='%';
	int mx=0,mid=0;
	For(i,1,q) p[i]=0;
	For(i,1,q){
		if(i<mx) p[i]=min(p[mid*2-i],mx-i);
		while(t[i+p[i]+1]==t[i-p[i]-1]) ++p[i];
		if(p[i]+i>mx) mx=i+p[i],mid=i;
	}
	For(i,1,q) t[i]=0;
}
int tr[N];
int tr1[N];
int tr2[N];
int ans[N];
vector<pair<int,int> > g[N],qr[N];
vector<int>pr[N];
inline int lowbit(int x){return x&(-x);}
inline void add1(int x,int k){while(x<=3*n){tr1[x]+=k;x+=lowbit(x);}}
inline int query1(int x){int res=0;while(x){res+=tr1[x];x-=lowbit(x);}return res;}
inline void add2(int x,int k){while(x<=3*n){tr2[x]+=k;x+=lowbit(x);}}
inline int query2(int x){int res=0;while(x){res+=tr2[x];x-=lowbit(x);}return res;}
inline void add(int x,int k){while(x<=3*n){tr[x]+=k;x+=lowbit(x);}}
inline int query(int x){int res=0;while(x){res+=tr[x];x-=lowbit(x);}return res;}
inline void solve(){
	n=read(),q=read();
	scanf("%s",s+1);
	For(i,1,n) t[i]=s[i];
	t[n+1]=140;
	reverse(s+1,s+n+1);
	For(i,1,n) t[i+n+1]=s[i];
	t[2*n+2]=1;
	GetSA(n+n+2);
	reverse(s+1,s+n+1);
	For(i,0,2*n) g[i].clear();
	For(i,0,4*n)pr[i].clear();
	For(i,1,q)ans[i]=0;
	For(i,1,q){
		int x=read(),y=read();
		g[x].emplace_back(y,i);
	}
	For(i,0,4*n) tr1[i]=tr2[i]=tr[i]=0;
	Rof(i,2*n+2,1){
		for(auto j:g[sa[i]]){
			if(sa[i]%2==0)ans[j.second]=query1(2*n+3-sa[i]-2)-query1(2*n+2-sa[i]-2*j.first);
			else ans[j.second]=query2(2*n+3-sa[i]-2)-query2(2*n+2-sa[i]-2*j.first);
		}
		if(sa[i]%2==1)add1(sa[i],1);
		else add2(sa[i],1);
	}
	
	manacher();
    For(i,2,n){
      	int k=p[i*2-1]>>1;
      	if(!k||s[i+k]>s[i-k-1]) continue;
      	if(i+k-1==n||i-k==1) continue;
		pr[i-k].emplace_back(i-1);
    }
    For(i,1,n){
      	for(auto j:pr[i]) add(j,1);
      	for(pair<int,int> j:g[i]) ans[j.second]-=query(i+j.first-1)-query(i-1);
    }
    
    For(i,1,q){
    	printf("%lld\n",ans[i]);
	}
}
signed main(){
	//_base=(_base<<64)/Mod;
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	// ios::sync_with_stdio(false);
	// cin.tie(0); cout.tie(0);
	int c=read(),T=read();
	while(T--){solve();}
#ifdef LOCAL
    Debug("\nMy Time: %.3lfms\n", (double)clock() / CLOCKS_PER_SEC);
#endif
	return 0;
}
```

---

## 作者：Graygoo (赞：6)

`CNOI` 传统风味物质文化遗产。

最关键的一步转化在于想到利用 **放缩** 来处理这个问题，因为至少这样思路的题我没做过几道。这一题的放缩是将题面条件先 **放宽** 至对应后缀小于对应前缀，这样转化一个较近的动机在于前后缀数量级比较优秀，一个较远的动机在于满足被多算的串必然是 **回文串** ，而回文串并不难刻画。

对于放宽后的问题，我们发现在将串与反串用一定特殊字符串起来跑后缀数组后，可以直接使用一个二维数点来解决，直接扫描线套上两个 `BIT` 即可。

接着我们来处理多算的部分。利用以上回文串的性质，先跑一个马拉车，然后对于每个偶回文中心分开考虑。再次观察到一个性质：回文串对应前后缀比大小可以转化为相同中心极长回文串对应前后缀比大小结果。因此相同中心回文串要么是全部会被多算，要么是都不会被多算。如果都会被多算的话，设回文串左端点为 $lp$，左边的中心为 $mid$ ，则它会对所有 $lp \leq i \leq mid , i+r > mid$ 的询问造成贡献，这也是一个二维数点，扫描线即可。

复杂度 $O((n+q) \log n)$。

---

## 作者：yllcm (赞：4)

考场做法。

首先有一个 naive 的想法：把 $s$ 和 $R(s)$ 放在一起做后缀排序。定义 $rk[s]$ 表示字符串 $s$ 在所有后缀中的排名，那么计算 $\sum _{1\leq l\leq r}[rk[s([i:n])]<rk[R(s[1:i+2l-1])]]$，下文将这个条件简写为 $f(i,l)$。这样子可以统计到所有合法的 $l$，但是对于满足 $s[i:i+l-1]=R(s[i+l,i+2l-1])$ 且满足 $rk$ 的偏序关系的 $l$ 也会被统计进去，所以我们要容斥这一部分。

换言之我们需要统计偶数回文串 $s[i,i+2l-1]$ 的个数使得 $f(i,l)$ 满足。对于 $s$ 的反串建立 PAM，则我们需要统计 $s[i:n]$ 在 PAM 上对应节点的所有祖先 $u$ 对应的字符串的长度 $l_u$ 所构成的集合求和 $\sum f(i,l_u)[2|l_u]$。可以发现一件事情，即回文串的所有 border 一定是其回文后缀，且回文串的所有回文后缀一定是其 border，简单讨论不难证明，所以可以证明回文串的回文后缀集合与其 border 集合等价。所以可以套用 border 理论的结论来说明：$l_u$ 一定可以被划分成 $\mathcal{O}(\log n)$ 个等差数列。对于 $[2|l_u]$ 的条件，可以通过调整边界并令公差乘 $2$ 处理。

那么套路地对公差根号分治，公差较大的等差数列直接暴力，复杂度看似是 $\mathcal{O}(q\frac{n}{B}\log n)$ 的，但是实际上可以[证](https://www.luogu.com.cn/blog/command-block/border-li-lun-xiao-ji)到 $\mathcal{O}(q\frac{n}{B})$。对于较小的等差数列，先差分成两个前缀的询问，然后枚举公差并枚举起点就转化成一个裸的二维数点，直接使用树状数组可以做到 $\mathcal{O}(nB\log n+q\log^2 n)$，取 $B=(\frac{q}{\log n})^{\frac{1}{2}}$ 可以做到理论 $\mathcal{O}(n\sqrt{q\log n}+q\log^2 n)$ 的复杂度，但是常数非常小，所以它过了。

代码在考场里。

---

## 作者：Mobius127 (赞：4)

[题传](https://www.luogu.com.cn/problem/P9482)

串串好玩！

条件为：

$$s[i, i+l-1]<R(s[i+l, i+2l-1])$$

这个条件十分回文，考虑缩放：

$$s[i, i+2l-1]<R(s[i, i+2l-1])$$

发现依然满足条件，因为当匹配了 $l$ 个字符后整个串已经回文了。

考虑进一步缩放为 $s[i, n]<R(s[1, i+2l-1])$，此时满足条件的 $l$ 变多了，需要搞掉 $s[i, n]<R(s[1, i+2l-1])\wedge s[i, i+2l-1]\ge R(s[i, i+2l-1])$ 的部分。

对于第一块，发现本质上是询问 $i$ 开始的后缀与从与 $i$ 不同奇偶性的反串**后缀**的排名，我们不妨将所有“后缀”一起排序，不妨设排名为 $rank$，那么将后缀串 $R(s[1, r])$ 视为点 $(r, rank)$，那么一次询问即相当于求 $r\in (i, i+2r-1], rank\in (rk_{[i, n]}, 2n+2]$ 的点的个数，二维数点即可（注意分奇偶性）。

如何对所有“后缀”进行排序？直接将反串接到正串后面，原来正串的后缀会加上整个反串，当原正串后缀长度小于反串的一个后缀时时，比较会出错，于是我们在正反串之间塞一个字典序很小的字符，当正串后缀恰好等于反串后缀时，我们又需要让反串后缀 $rank$ 在前面，于是我们在反串后加一个字典序更更更小的字符，即对 $s[1, n]+0+R(s[1, n])+-1$ 的后缀排序。

对于需要容斥掉的部分，进一步推得 $s[i, i+2l-1]$ 回文，我们考虑一个极长的偶回文串 $[x-p_{x}+1, x+p_{x}]$，对于所有 $x-p_{x}+1\le i\le x< i+r$ 的询问，容易发现若当 $l=x-i$ 时，由于 $s[i, x+p_{x}]=R(s[x-p_{x}+1, i+2l-1])$，条件 $s[i, n]<R(s[1, i+2l-1])$ 等价于 $s[x+p_{x}+1, n]<R(s[1, x-p_{x}])$。注意到我们本质上是在枚举回文中心 $x=i+l$，即每个满足条件的 $x$ 对 $(i, r)$ 询问的贡献是不重不漏的，而 $x$ 的条件 $s[x+p_{x}+1, n]<R(s[1, x-p_{x}])$ 与 $(i, r)$ 无关，我们可以先选出合法的 $x$ 后对 $x-p_{x}+1\le i\le x< i+r$ 的 $x$ 计数，可以扫描线处理。 $p_{x}$ 直接 Manacher 即可。

注意找合法回文串的时候如果串右端点为 $n$ 且左端点不为 $1$ 也满足条件。

总复杂度 $O((n+q)\log n)$。

### Code：

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <cctype>
#include <vector>
#include <queue>
#include <bitset>
#define lowbit(x) (x&(-x))
#define vi vector<int>
#define pb push_back
#define mp make_pair
#define st first
#define nd second
using namespace std;
typedef long long ll;
typedef pair <int, int> Pii;
const int INF=0x3f3f3f3f;
const int cp=998244353;
inline int mod(int x){if(x>=cp) x-=cp;if(x<0) x+=cp;return x;}
inline void plust(int &x, int y){x=mod(x+y);return ;}
inline void minut(int &x, int y){x=mod(x-y);return ;}
inline int read(){
	char ch=getchar();int x=0, f=1;
	while(!isdigit(ch)){if(ch=='-') f=-1; ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
inline void write(int x){
    if(x<0) putchar('-'), x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
inline int ksm(int a, int b=cp-2){
	int ret=1;
	for(; b; b>>=1, a=1ll*a*a%cp)
		if(b&1) ret=1ll*ret*a%cp;
	return ret;
}
const int N=1e5+5;
const int M=N<<2;
namespace SAM{
	char t[N<<1];int pos[M], ndc, lst;bool suf[M];
	struct node{int len, fa, ch[28];}sam[M];
	int clr(int x){sam[x]=sam[0], suf[x]=pos[x]=0;return x;}
	void init(){clr(ndc=lst=1);}
	int insert(char c, int i){
		int cur=clr(++ndc), p=lst, cc=c-95;
		sam[cur].len=sam[p].len+1;pos[cur]=i;suf[cur]=1;
		for(; p&&!sam[p].ch[cc]; p=sam[p].fa) sam[p].ch[cc]=cur;
		int q=sam[p].ch[cc];if(!q) sam[cur].fa=1;
		else if(sam[q].len==sam[p].len+1) sam[cur].fa=q;
		else{
			int nxt=clr(++ndc);sam[nxt]=sam[q];sam[nxt].len=sam[p].len+1;pos[nxt]=pos[q];
			for(; p&&sam[p].ch[cc]==q; p=sam[p].fa) sam[p].ch[cc]=nxt;
			sam[cur].fa=sam[q].fa=nxt;
		}
		return lst=cur;
	}
	int rk[N<<1], sa[N<<1], sufT[M][28];
	int m, dfn;
	void dfs(int x){
		if(suf[x]) sa[rk[pos[x]]=++dfn]=pos[x];
		for(int i=0; i<28; ++i) if(sufT[x][i]) dfs(sufT[x][i]);
		for(int i=0; i<28; ++i) sufT[x][i]=0;
	}
	void ins(char *s, int mm){
		m=mm;init();
		for(int i=1; i<=m; ++i) t[i]=s[i];
		t[m+1]=96;for(int i=1; i<=m; ++i) t[m+1+i]=s[m-i+1];
		t[m+m+2]=95;for(int i=m+m+2; i>=1; --i) insert(t[i], i);
		for(int i=2; i<=ndc; ++i) sufT[sam[i].fa][t[pos[i]+sam[sam[i].fa].len]-95]=i;
		dfn=0;dfs(1);
	}
}
int n, q, ans[N];char str[N];
struct query{int i, r;}Q[N];
char nw[N<<1];
int p[N<<1];
struct bittree{
	int bit[N<<1], m;
	void init(int mm){m=mm;for(int i=1; i<=m; ++i) bit[i]=0;}
	void add(int x){for(; x&&x<=m; x+=lowbit(x)) ++bit[x];}
	int qry(int x, int t=0){for(; x; x-=lowbit(x)) t+=bit[x];return t;}
	int ask(int l, int r){if(r<l) return 0;return qry(r)-qry(l-1);}
}ft[2], se;
vi f[N], s[N], d[N];
int ans2[N];
void solve(){
	n=read(), q=read();
	scanf("%s", str+1);
	SAM :: ins(str, n);
	for(int i=1; i<=q; ++i){
		Q[i].i=read(), Q[i].r=read();
		ans[i]=0, f[Q[i].i].pb(i), s[Q[i].i].pb(i);
	}
	ft[0].init(n+n+2), ft[1].init(n+n+2), se.init(n);
	for(int i=n+n+2, t; i>=1; --i){
		t=SAM :: sa[i];
		if(t>n+1) ft[(n+n+2-t)&1].add(n+n+2-t);
		else for(auto id:f[t]) ans[id]+=ft[(t+1)&1].ask(t+1, t+Q[id].r*2-1);
	}
	nw[0]='~', nw[1]='#';
	for(int i=1; i<=n; i++)
		nw[i<<1]=str[i], nw[i<<1|1]='#';
	for(int i=1, mid=0, R=0; i<=n*2+1; i++){
		if(i<R) p[i]=min(p[mid*2-i], R-i);
		while(nw[i-p[i]-1]==nw[i+p[i]+1]) p[i]++;
		if(i+p[i]>R) R=i+p[i], mid=i;
		if(nw[i]=='#'&&i>1){
			int px=p[i]>>1, x=i>>1;
			if(px&&(x+px+1<=n&&x-px>=1&&SAM :: rk[x+px+1]<SAM :: rk[n+n+2-x+px])||(x-px>=1&&x+px+1>n)) 
				d[x-px+1].pb(x);
		}
	}
	for(int i=1; i<=n*2+1; ++i) nw[i]=p[i]=0;
	for(int i=1; i<=n; ++i){
		for(auto v:d[i]) se.add(v);
		for(auto v:s[i]) ans[v]-=se.ask(Q[v].i, Q[v].i+Q[v].r-1);
		vi ().swap(f[i]), vi ().swap(s[i]), vi ().swap(d[i]);
	}	
	for(int i=1; i<=q; ++i) printf("%d\n", ans[i]);
}
signed main(){
	int c=read(), T=read();while(T--) solve();
	return 0;
}
```





---

## 作者：Fesdrer (赞：3)

考虑放宽限制，对一个询问 $(I,R)$，求出所有符合以下要求的 $R(s[1:j])$ 的数量（这里 $R(s)$ 就是题目中所说的翻转字符串 $s$ 的结果）：

- $j\in[I,I+2R-1]$
- $j$ 和 $I$ 奇偶性不同
- $s[I:n]$ 的字典序小于 $R(s[1:j])$

这一切都是为了将原题中的 $s[I: I+l-1]$ 字典序小于 $R(s[I+l: I+2l-1])$ 这一限制条件转化成后缀的字典序小于前缀的字典序这种限制条件。当然，放宽限制就意味着会有不合法的情况被考虑。接下来我们分别分析如何求出放宽限制后的答案和如何计算不合法的情况个数。

对于如何求出放宽限制后的答案，我们考虑用 SA 求出所有前缀和后缀的字典序排序。具体的，我们定义串 $t=s+\texttt{0}+R(s)$，也就是将 $s$ 串和 $s$ 的反串拼接起来，中间加入 `0` 这一分隔符，这样我们对 $t$ 求 SA，就可以求出所有前缀和后缀的字典序排序了。接下来我们从大到小枚举所有前缀后缀，如果枚举到的是前缀 $s[1:j]$，就在树状数组的 $j$ 位置加 $1$，如果枚举到的是后缀，就在树状数组的 $[I,I+2R-1]$ 这一范围内求和即可。另外注意的是要开两个树状数组来处理奇偶性不同这一限制条件。

对于如何计算不合法的情况，我们考虑什么情况下不合法。容易发现只有一种情况会导致不合法：

![](https://cdn.luogu.com.cn/upload/image_hosting/cpi32du4.png)

这里，红色的部分是一个极大偶回文串，蓝色是一个后缀，绿色是一个前缀，蓝色和绿色相交的部分位于红色回文串的中心，因此相交部分也是一个偶回文串，在原题中这两者的字典序应当相等，不应当计入答案。但是在这里，红色回文串左边的字符如果大于右边的字符，则上面放宽限制后的答案就会包含这一情况，因此这种情况是我们需要剔除的。

我们用 Manacher 算法求出所有极大偶回文串，对于每个回文串 $[L,R]$，求出 $mid=(L+R-1)/2$，则一个询问 $(I,R)$ 会在这个回文串中出现上述的不合法情况当且仅当：
$$
\begin{cases}
I\in[L,mid]\\
I+R\in[mid+1,n]
\end{cases}
$$
容易发现这是一个二维偏序问题，相当于问点 $(I,I+R)$ 会被多少个 $x$ 范围为 $[L,mid]$，$y$ 范围为 $[mid+1,n]$ 的矩形包含。我们只要用扫描线就可以解决这一问题。

至此我们已经成功解决了本题。

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int Tid,T,n,Q;
char s[N];
struct Query{int I,R,Id,Ans;}query[N];
vector<int> pos_query[N];
vector<pair<int,int>> add_matrix[N];
namespace SA{
	char s[N<<1];
	int n,m,sa[N<<1],rk[N<<1],A[N<<1],B[N<<1];
	void qsort(int *p,int n,int *w){
		vector<int> cnt(m+1),q(n+1);
		for(int i=1;i<=n;i++)	cnt[w[q[i]=p[i]]]++;
		for(int i=1;i<=m;i++)	cnt[i]+=cnt[i-1];
		for(int i=n;i>=1;i--)	p[cnt[w[q[i]]]--]=q[i];
	}
	void getrk(){
		for(int i=1;i<=n;i++)
			rk[sa[i]]=A[sa[i]]==A[sa[i-1]]&&B[sa[i]]==B[sa[i-1]]?rk[sa[i-1]]:i;
	}
	void getsa(){
		for(int i=1;i<=::n;i++)	s[i]=::s[i];
		s[::n+1]='0';
		for(int i=::n+2,j=::n;j>=1;j--,i++)	s[i]=::s[j];
		n=::n*2+1,m=max(n,128);
		for(int i=1;i<=n;i++)	sa[i]=i,A[i]=s[i],B[i]=0;
		qsort(sa,n,A),getrk();
		for(int l=1;l<n;l<<=1){
			for(int i=1;i<=n;i++)   A[i]=rk[i],B[i]=i+l<=n?rk[i+l]:0;
			qsort(sa,n,B),qsort(sa,n,A),getrk();
		}
	}
}
namespace Manacher{
	int n,d[N];
	char s[N];
	void manacher(){
		for(int i=1;i<=::n;i++)	s[i*2-1]='#',s[i*2]=::s[i];
		n=::n*2+1,s[n]='#';
		for(int i=0;i<=n;i++)	d[i]=0;
		for(int i=1,l=0,r=0;i<=n;i++){
			d[i]=i<=r?min(d[l+r-i],r-i+1):1;
			while(i-d[i]>=1&&i+d[i]<=n&&s[i-d[i]]==s[i+d[i]])	d[i]++;
			if(i+d[i]-1>r)  r=i+d[i]-1,l=i-d[i]+1;
		}
	}
}
class BIT{
public:
	int c[N];
	BIT(){
		memset(c,0,sizeof c);
	}
	void add(int x,int y){
		for(;x<=n;x+=x&-x)	c[x]+=y;
	}
	int _ask(int x){
		int ret=0;
		for(;x;x-=x&-x)	ret+=c[x];
		return ret;
	}
	int ask(int l,int r){
		return _ask(r)-_ask(l-1);
	}
};
void solve1(){
	for(int i=1;i<=Q;i++)	pos_query[query[i].I].push_back(i);
	SA::getsa();
	BIT bit[2];
	for(int i=n*2+1;i>=1;i--){
		int x=SA::sa[i];
		if(x<=n){
			for(int Id:pos_query[x])	query[Id].Ans=bit[1^(x&1)].ask(x,min(x+2*query[Id].R-1,n));
		}
		else if(x>n+1){
			x=2*n+2-x;
			bit[x&1].add(x,1);
		}
	}
}
void solve2(){
	Manacher::manacher();
	for(int i=1,j=0;i<=n*2+1;i+=2,j++){
		int L=j-(Manacher::d[i]-1)/2+1,R=j+(Manacher::d[i]-1)/2,Mid=(L+R)/2;
		if(s[L-1]>s[R+1])	add_matrix[L].push_back({Mid+1,1}),add_matrix[Mid+1].push_back({Mid+1,-1});
	}
	sort(query+1,query+Q+1,[&](const Query &x,const Query &y){return x.I<y.I;});
	BIT bit;
	for(int i=1,j=0;i<=Q;i++){
		while(j<query[i].I){
			j++;
			for(pair<int,int> it:add_matrix[j])	bit.add(it.first,it.second);
		}
		query[i].Ans-=bit._ask(min(query[i].I+query[i].R,n));
	}
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>Tid>>T;
	while(T--){
		cin>>n>>Q>>(s+1);
		for(int i=1;i<=Q;i++)	cin>>query[i].I>>query[i].R,query[i].Ans=0,query[i].Id=i;
		for(int i=0;i<=n+1;i++)	pos_query[i].clear(),add_matrix[i].clear();
		solve1(),solve2();
		sort(query+1,query+Q+1,[&](const Query &x,const Query &y){return x.Id<y.Id;});
		for(int i=1;i<=Q;i++)	cout<<query[i].Ans<<'\n';
	}
	return 0;
}
```

---

## 作者：Leasier (赞：3)

为了方便，我们把 $s' = s + \operatorname{inf} + R(s) + (\operatorname{inf} - 1)$ 丢进 SA 里，设 $m = |s'|$，将条件转化为：

- $rk_i < rk_{m - (i + 2k - 1)}$。
- $\operatorname{lcp}(i, m - (i + 2k - 1)) < k$。

这个 $\operatorname{lcp}$ 会让人有一种上后缀树的冲动，但是别急。

考虑当第二个条件不满足时会发生啥，此时 $[i, i + 2k - 1]$ 是一个以 $i + k - \frac{1}{2}$ 为回文中心的回文串。

进一步地，我们发现这时两个后缀第一个不同的地方一定位于 $(i + k) + \operatorname{range}_{i + k}, m - (i + k) + \operatorname{range}_{i + k} + 1$，其中 $\operatorname{range}_i$ 表示以 $i - \frac{1}{2}$ 为回文中心的最长回文半径。

于是我们容斥一下，两次二维数点即可。时间复杂度为 $O(\sum (n \log n + q (\log n + \log q))$。

代码：
```cpp
#include <algorithm>
#include <cstdio>

using namespace std;

typedef struct Query1_tag {
	int id;
	int rk;
	int l;
	int r;
	Query1_tag(){}
	Query1_tag(int id_, int rk_, int l_, int r_){
		id = id_;
		rk = rk_;
		l = l_;
		r = r_;
	}
} Query1;

typedef struct {
	int tree[400007];
	
	inline void init(int n){
		for (register int i = 1; i <= n; i++){
			tree[i] = 0;
		}
	}
	
	inline int lowbit(int x){
		return x & (-x);
	}
	
	inline int get_sum(int x){
		int ans = 0;
		while (x > 0){
			ans += tree[x];
			x -= lowbit(x);
		}
		return ans;
	}
	
	inline int get_sum(int l, int r){
		return get_sum(r) - get_sum(l - 1);
	}
	
	inline void add(int n, int x, int k){
		while (x <= n){
			tree[x] += k;
			x += lowbit(x);
		}
	}
} BIT;

typedef struct Query2_tag {
	int id;
	int r1;
	int r2;
	int type;
	Query2_tag(){}
	Query2_tag(int id_, int r1_, int r2_, int type_){
		id = id_;
		r1 = r1_;
		r2 = r2_;
		type = type_;
	}
} Query2;

int id[37], rk[400007], sa[400007], cnt[400007], save[400007], range[400007], i[100007], r[100007], ans[100007];
char s[400007], temp[400007];
bool vis[37];
Query1 query1[100007];
BIT bit[7];
Query2 query2[200007];
pair<int, int> pr[400007];

bool operator <(const Query1 a, const Query1 b){
	return a.rk > b.rk;
}

bool operator <(const Query2 a, const Query2 b){
	return a.r1 < b.r1;
}

inline void init(int n){
	for (register int i = 0; i <= n; i++){
		cnt[i] = 0;
	}
}

inline int read(){
	int ans = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9'){
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9'){
		ans = ans * 10 + (ch ^ 48);
		ch = getchar();
	}
	return ans;
}

inline void mysort(int n){
	init(n);
	for (register int i = 1; i <= n; i++){
		cnt[pr[i].second]++;
	}
	for (register int i = 1; i <= n; i++){
		cnt[i] += cnt[i - 1];
	}
	for (register int i = n; i >= 1; i--){
		save[cnt[pr[sa[i]].second]--] = sa[i];
	}
	for (register int i = 1; i <= n; i++){
		sa[i] = save[i];
	}
	init(n);
	for (register int i = 1; i <= n; i++){
		cnt[pr[i].first]++;
	}
	for (register int i = 1; i <= n; i++){
		cnt[i] += cnt[i - 1];
	}
	for (register int i = n; i >= 1; i--){
		save[cnt[pr[sa[i]].first]--] = sa[i];
	}
	for (register int i = 1; i <= n; i++){
		sa[i] = save[i];
	}
}

inline void build(char s[], int n){
	int cnt = 0;
	for (register int i = 1; i <= 28; i++){
		vis[i] = false;
	}
	for (register int i = 1; i <= n; i++){
		vis[s[i] - 'a' + 1] = true;
	}
	for (register int i = 1; i <= 28; i++){
		if (vis[i]) id[i] = ++cnt;
	}
	for (register int i = 1; i <= n; i++){
		rk[i] = id[s[i] - 'a' + 1];
		sa[i] = i;
	}
	for (register int i = 1; i < n; i <<= 1){
		for (register int j = 1; j <= n; j++){
			int t = j + i;
			pr[j] = make_pair(rk[j], t <= n ? rk[t] : 0);
		}
		mysort(n);
		for (register int j = 1; j <= n; j++){
			if (pr[sa[j]] == pr[sa[j - 1]]){
				rk[sa[j]] = rk[sa[j - 1]];
			} else {
				rk[sa[j]] = j;
			}
		}
	}
}

inline void manacher(char s[], int n){
	int m = 0, r = 0, pos;
	for (register int i = 1; i <= n; i++){
		temp[++m] = ' ';
		temp[++m] = s[i];
	}
	temp[++m] = ' ';
	for (register int i = 1; i <= m; i++){
		int t;
		if (i < r){
			range[i] = min(range[pos * 2 - i], r - i + 1);
		} else {
			range[i] = 1;
		}
		while (i - range[i] >= 1 && i + range[i] <= m && temp[i - range[i]] == temp[i + range[i]]) range[i]++;
		t = i + range[i] - 1;
		if (r < t){
			r = t;
			pos = i;
		}
	}
}

int main(){
	int c = read(), t = read();
	for (register int I = 1; I <= t; I++){
		int n = read(), q = read(), m = n, cnt = 0;
		scanf("%s", &s[1]);
		for (register int j = 1; j <= q; j++){
			i[j] = read();
			r[j] = read();
		}
		s[++m] = 'z' + 2;
		for (register int j = 1; j <= n; j++){
			s[++m] = s[n - j + 1];
		}
		s[++m] = 'z' + 1;
		build(s, m);
		for (register int j = 1; j <= q; j++){
			query1[j] = Query1(j, rk[i[j]], m - (i[j] + r[j] * 2 - 1), m - (i[j] + 1));
		}
		sort(query1 + 1, query1 + q + 1);
		bit[0].init(m);
		bit[1].init(m);
		for (register int j = m, k = 1; j >= 1; j--){
			while (k <= q && query1[k].rk == j){
				ans[query1[k].id] = bit[query1[k].l & 1].get_sum(query1[k].l, query1[k].r);
				k++;
			}
			bit[sa[j] & 1].add(m, sa[j], 1);
		}
		manacher(s, n);
		for (register int j = 1; j <= q; j++){
			query2[++cnt] = Query2(j, i[j] + r[j], i[j], -1);
			query2[++cnt] = Query2(j, i[j], i[j], 1);
		}
		sort(query2 + 1, query2 + cnt + 1);
		bit[0].init(n);
		for (register int j = 1, k = 1; j <= n; j++){
			int r = (range[j * 2 - 1] - 1) / 2;
			if (s[j + r] < s[m - j + r + 1]) bit[0].add(n, j - r, 1);
			while (k <= cnt && query2[k].r1 == j){
				ans[query2[k].id] += query2[k].type * bit[0].get_sum(query2[k].r2);
				k++;
			}
		}
		for (register int j = 1; j <= q; j++){
			printf("%d\n", ans[j]);
		}
	}
	return 0;
}
```

---

## 作者：tzc_wk (赞：3)

从部分分考虑起。性质 A 看上去在很多字符串题里都有出现，因此我们从看上去比较奇怪的性质 B 入手。因为 $\forall i\in[1,n-1],s_i\ne s_{i+1}$，所以 $\forall l\in[1,r],s_{i+l}\ne s_{i+l-1}$，也就是说 $s[i,i+l-1]\ne R(s[i+l,i+2l-1])$ 一定成立。这样我们考虑 $T=S+\text{\#}+R(S)$，求出 $T$ 每个后缀的排名，那么可以证明一组 $(i,l)$ 合法当且仅当 $rk_i<rk_{2n+1-(i+2l-1)+1}$（也即，以 $i$ 开始的后缀小于以 $i+2l-1$ 结尾的前缀）。离线下来树状数组维护可以解决性质 B。

接下来考虑原问题。我们先套用性质 B 的做法求一下每一组询问的答案，然后考虑那些需要特殊处理的，即 $s[i,i+l-1]=R(s[i+l,i+2l-1])$ 并且 $rk_i<rk_{2n+1-(i+2l-1)+1}$ 的 $(i,l)$。考虑枚举这个回文中心，假设位于 $i$ 与 $i+1$ 之间，然后你发现一个性质就是以这个位置为回文中心的所有回文串的所有回文串 $[l,r]$，它们的 $[s[l...n]<R(s[1...r])]$，要么同为真要么同为假，因此这样一来我们考虑扣掉的贡献是什么：如果 $s[i,i+l-1]=R(s[i+l,i+2l-1])$ 且 $i+l-1$ 对应的上述布尔值为真，那么我们就要将答案减去 $1$。我们求出 $\text{LCP}(s[i+1...n],R(s[1...i]))$，这样问题转化为斜线 $+1$，查询一个竖直线段上的值之和。同样可以树状数组解决。

时间复杂度 $O(n\log n)$。

```cpp
const int MAXN=1e5;
const int LOG_N=18;
int n,qu,len,res[MAXN+5];char s[MAXN*2+5],t[MAXN*2+5];
int sa[MAXN*2+5],rk[MAXN*2+5],ht[MAXN*2+5],buc[MAXN*2+5],seq[MAXN*2+5];
int st[LOG_N+2][MAXN*2+5],lg[MAXN*2+5];
void getsa(){
	memset(sa,0,sizeof(sa));memset(rk,0,sizeof(rk));
	memset(ht,0,sizeof(ht));memset(buc,0,sizeof(buc));
	int vmax=122,gr=0;
	for(int i=1;i<=len;i++)buc[t[i]]++;
	for(int i=1;i<=vmax;i++)buc[i]+=buc[i-1];
	for(int i=len;i;i--)sa[buc[t[i]]--]=i;
	for(int i=1;i<=len;i++){
		if(t[sa[i]]!=t[sa[i-1]])++gr;
		rk[sa[i]]=gr;
	}vmax=gr;
	for(int k=1;k<=len;k<<=1){
		static pii x[MAXN*2+5];
		for(int i=1;i<=len;i++){
			if(i+k<=len)x[i]=mp(rk[i],rk[i+k]);
			else x[i]=mp(rk[i],0);
		}memset(buc,0,sizeof(buc));gr=0;int num=0;
		for(int i=len-k+1;i<=len;i++)seq[++num]=i;
		for(int i=1;i<=len;i++)if(sa[i]>k)seq[++num]=sa[i]-k;
		for(int i=1;i<=len;i++)buc[x[i].fi]++;
		for(int i=1;i<=vmax;i++)buc[i]+=buc[i-1];
		for(int i=len;i;i--)sa[buc[x[seq[i]].fi]--]=seq[i];
		for(int i=1;i<=len;i++){
			if(x[sa[i]]!=x[sa[i-1]])++gr;
			rk[sa[i]]=gr;
		}vmax=gr;if(vmax==len)break;
	}
}
void getht(){
	int k=0;
	for(int i=1;i<=len;i++){
		if(rk[i]==1)continue;if(k)--k;int j=sa[rk[i]-1];
		while(i+k<=len&&j+k<=len&&t[i+k]==t[j+k])++k;
		ht[rk[i]]=k;
	}
}
void buildst(){
	for(int i=1;i<=len;i++)st[0][i]=ht[i];
	for(int i=1;i<=LOG_N;i++)for(int j=1;j+(1<<i)-1<=len;j++)
		st[i][j]=min(st[i-1][j],st[i-1][j+(1<<i-1)]);
}
int query_st(int l,int r){int k=lg[r-l+1];return min(st[k][l],st[k][r-(1<<k)+1]);}
int getlcp(int x,int y){
	if(x==y)return len-x+1;x=rk[x];y=rk[y];
	if(x>y)swap(x,y);return query_st(x+1,y);
}
vector<pii>qv[MAXN+5];vector<int>pv[MAXN+5];
struct fenwick{
	int t[MAXN*2+5];
	void init(){memset(t,0,sizeof(t));}
	void add(int x,int v){for(int i=x;i<=len;i+=(i&(-i)))t[i]+=v;}
	int query(int x){int ret=0;for(int i=x;i;i&=(i-1))ret+=t[i];return ret;}
}T[2],tt;
void solve(){
	scanf("%d%d%s",&n,&qu,s+1);len=0;memset(t,0,sizeof(t));
	for(int i=1;i<=n;i++)t[++len]=s[i];t[++len]='#';
	for(int i=n;i;i--)t[++len]=s[i];
	getsa();getht();buildst();
	for(int i=1;i<=n;i++)qv[i].clear();memset(res,0,sizeof(res));
	for(int i=1,x,y;i<=qu;i++)scanf("%d%d",&x,&y),qv[x].pb(mp(y,i));
	T[0].init();T[1].init();
	for(int i=len;i;i--){
		if(sa[i]>n+1){
			int pos=len-sa[i]+1;
			T[pos&1].add(pos,1);
		}else if(sa[i]<=n){
			int pos=sa[i];
			for(pii p:qv[pos])res[p.se]=T[(pos&1)^1].query(pos+2*p.fi-1)-T[(pos&1)^1].query(pos-1);
		}
	}
	for(int i=1;i<=n+1;i++)pv[i].clear();
	for(int i=1;i<n;i++){
		int L=getlcp(i+1,len-i+1);
//		printf("! %d %d\n",i,L);
		if(rk[i-L+1]<rk[len-(i+L)+1]&&L)pv[i-L+1].pb(i);
	}
	tt.init();
	for(int i=1;i<=n;i++){
		for(int x:pv[i])tt.add(x,1);
		for(pii p:qv[i])res[p.se]-=tt.query(i+p.fi-1)-tt.query(i-1);
	}
	for(int i=1;i<=qu;i++)printf("%d\n",res[i]);
}
int main(){
	for(int i=2;i<=MAXN*2;i++)lg[i]=lg[i>>1]+1;
	int qu;scanf("%*d%d",&qu);while(qu--)solve();
	return 0;
}

```



---

## 作者：FireBladeMaster (赞：3)

下面用 $a<b$ 代表字符串 $a$ 的字典序小于 $b$ 的字典序，$a=b$ 同理。

首先有 $s[i:i+l-1]<R(s[i+l:i+2l-1])$ 等价于 $s[i:i+2l-1]<R(s[i:i+2l-1])$。这个显然。

于是我们想到把 $s$ 和 $R(s)$ 放到一起做 SA，那么我们只要求出有多少个 $j$ 满足 $j$ 满足 $s[i:]<R(s[:j])$ 且 $j$ 是一个合法的 $i+2l-1$，这是一个二维数点问题，然后就做完了……？

这是错误的。原因是考虑 $s[i:j]$ 为回文串，如果 $s[j+1:]<R(s[:i-1])$，会把这个**偶回文串**统计进答案。我们需要容斥掉这一部分。

使用 manacher 算法，对于每个回文中心 $p+0.5$ 求出以它为中心的最长**偶回文串** $s[x:y]$。同时 $p$ **需要满足** $s[p+0.5:]<R(s[:p-0.5])$。那么对于一个询问 $(s,l)$ 我们只要容斥掉 $x\le s\le p<s+l$ 的 $(x,p)$，这是另一个二维数点。

将所有询问离线，总复杂度 $O((n+q)\log n)$。



---

## 作者：Vidoliga (赞：2)

感觉有点难想，但是想通了就没啥难度。

这有一步很妙的转化，就是如果两个长度相同的串比较，，那要么相同，要么在长度前就比较出了。

设长度为 $l$，那么把某个串反转后拼到另一个串前面，可以比较新串的正倒序大小，如果在 $\leq l $的地方比较出来了，说明原本两个串的大小关系也如此，否则一定不会在 $>l$ 的位置比较出来，一定相等。

那么现在计数便转化为对于每次询问 $(i,r)$，回答 $s[i:j]<R(s[i:j]), i \leq j \leq r$ 个数。

这个限制也难做，考虑拆了：

设 $e(a,b)=[a=b]\times \infty ,f(s,t)=\min\limits_{i=1}^{lens}\{i \times e(s[i],t[i])\}$

则有：

$[s[i:j]<R(s[i:j])]=[s[i:n] < R(s[1,j]) \  \& \ f(s[i:n],s[1,j])]\leq j-i+1]$

先考虑对前部分限制怎么做，考虑对正反串都做 SA，然后做一个二维数点即可。

但是还有一个限制没解决，考虑一下什么时候不满足后面的限制，发现当且仅当 $s[i,j]$ 是回文串。

考虑容斥掉这种情况，也就是减去：

$s[i:n] < R(s[1,j])\ \& \ s[i:j]=R(s[i,j])$

的方案数。

这个就容易计数了，考虑跑个 manacher，对于每个**虚**回文中心，即不是原串中的元素的回文中心，当此时极长回文串多扩展一个单位的回文半径所组成的串 $s$ 满足 $s< R(s)$ ，设回文中心为 $p$ ，回文半径为 $r$ 则这个极长回文串可贡献的查询 $(i,r)$ 需满足 $p-r\leq i$ 和 $p+r \leq r$。

二维数点即可。




---

## 作者：strcmp (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P9482)

省流：没进弱省省队的场外选手的乱胡。

------------

题目限制比较奇怪，考虑放宽限制。

我们不妨将比较 $s[i : i + l - 1]$ 和 $R(s[i + l, i + 2l - 1])$ 看作比较 $s[i : n]$ 和 $R(s[1 : i + 2l - 1])$。

此时我们只可能多算贡献，因为如果前者不等于后者，那么在比较到第 $l$ 个位置之前时已经比较好了。

因此我们只可能在前 $l$ 位上是相同的，之后的位上出现了前者对应位小于后者的情况，进而多算答案。

我们先考虑放宽限制后的答案。

这个答案是好维护的，我们将原串和反串接在一起，中间一个特殊字符隔开，后缀排序一下。

设 $rk_i$ 为第 $i$ 个后缀的排名。每个子询问 $i,l$ 合法必然满足 $rk_i < rk_{2n-i-2l+2} \wedge l < r + 1$，这显然是一个二维数点，离线然后用棵树状数组维护即可，鉴定为普及板子。

------------

现在我们考虑一下可能多算的地方。因为我们已经知道 $s[i : i + l - 1] = R(s[i + l, i + 2l - 1])$ 了，所以 $s[i : i + 2l - 1]$ 是一个长度为偶数的回文串。跳过它，我们要计算 $s[i + 2l : n] < R(s[1 : i - 1])$ 的个数，这些就是我们多算的答案。也即，满足 $s[i : i + 2l - 1]$ 是偶回文串且 $s[i + 2l : n] < R(s[1 : i - 1])$ 的 $i,l$ 个数。

一个核心观察是因为 $s[i : i + 2l - 1]$ 是回文串，所以要么 $s[i - 1] \ne s[i + 2l]$，要么 $s[i : i + 2l - 1]$ 不是当前的极长回文串，否则我们可以给两边同时加上相同的字符，回文串更长。

所以我们可以跑一个 manacher 来求出包含 $s[i : i + 2l - 1]$ 的极长回文串。

将这个极长回文串半径值设为 $c$，回文中心设为 $o$。求出极长回文串 $s[o - c + 1 : o + c]$ 后，我们可以直接断言，$s[i + l + 2 : o + c + 1] = R(s[o - c : i - l - 1])$，这是因为回文串最基础的性质——对称性。也就是说，比较 $s_{o + c + 2}$ 和 $s_{o - c - 1}$ 的大小即可直接判断 $s[i + 2l : n]$ 是否小于 $R(s[1 : i - 1])$。

如果它没有小于 $R(s[1 : i - 1])$，很显然我们不会算重，直接跳。

否则，考虑 $i$ 位置上算重了多少，我们发现如果它小于 $R(s[1 : i - 1])$，那么所有以 $o$ 为回文中心的回文串都会算重。

于是对于每个会算重的极大回文串我们要减去满足 $i \le o \le r \le o + c - 1$ 的询问个数，由于是极大回文串这必然是不重不漏的，显然也是一个二维数点，直接做就行了。

时间复杂度 $\Theta(Tn\log n)$，由于代码比较巨大难写而且写题解的时候还在咕，就把代码放进剪切板里了。

[在之后可能会放上去的代码](https://www.luogu.com.cn/paste/c71l9t02)

---

## 作者：DaiRuiChen007 (赞：1)

[Problem Link](https://www.luogu.com.cn/problem/P9482)

**题目大意**

> 给定长度为 $n$ 的字符串 $S$，$q$ 次询问给定 $x,k$，求有多少 $i\in[1,k]$ 满足 $S[x,x+i-1]<\mathrm{rev}(S[x+i,x+2i-1])$，$<$ 表示字典序比较。
>
> 数据范围：$n,q\le 10^5$。

**思路分析**

考虑如何判定一组 $(x,i)$ 合法，首先可以比较后缀 $S[x,n]$ 和前缀 $S[1,x+2i-1]$，可以对 $S+\mathrm{rev}(S)$ 建后缀数组处理出每个后缀 $S[i,n]$ 的排名 $R_i$ 和前缀的排名 $L_{x+2i-1}$。

那么一组 $(x,i)$ 合法当且仅当 $R_x<L_{x+2i-1}$ 并且 $S[x,x+2i-1]$ 不是回文串。

先考虑怎么对满足第一个条件的点计数，对 $L$ 降序扫描线，相当于求 $[x,x+2k)$ 中有多少被已插入的元素和 $x$ 奇偶性不同，对奇数和偶数分别建树状数组维护即可。

然后我们要去掉 $R_x<L_{x+2i-1}$ 且 $S[x,x+2i-1]$ 回文的情况，设以 $(i,i+1)$ 为回文中心的最长回文半径为 $d_i$，那么第二个条件就是 $d_{i+x-1}\ge i$。

第一个条件不好处理，但我们发现 $S[x,x+i-1]=S[x+i,x+2i-1]$ 时一定有 $[R_x<L_{x+2i-1}]=[R_{i+x}<L_{i+x-1}]$，事实上就是给两个串的开头删去相等的一段字符。

那么我们只要把不满足 $R_{i+1}<L_i$ 的 $d_i$ 设成 $-\infty$，然后只要数 $i\in [x,x+k-1]$ 中有多少 $i-d_i+1\le x$，注意到 $i< x$ 的时候只要 $d_i\ne-\infty$ 恒成立，因此可以预处理前缀和解决一半。

时间复杂度 $\mathcal O((n+q)\log n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
using namespace std;
const int MAXN=2e5+5;
mt19937_64 rnd(time(0));
char str[MAXN];
int sa[MAXN],rk[MAXN],wt[MAXN],len[MAXN],ht[MAXN][20];
int bit(int x) { return 1<<x; }
void init(int n) {
	iota(sa+1,sa+n+1,1);
	sort(sa+1,sa+n+1,[&](int x,int y){ return str[x]<str[y]; });
	for(int i=1,j;i<=n;) {
		for(j=i;j<n&&str[sa[j+1]]==str[sa[i]];++j);
		len[i]=j-i+1;
		while(i<=j) rk[sa[i++]]=j;
	}
	for(int k=1;k<n;k<<=1) {
		for(int l=1,r;l<=n;++l) if(len[l]>1) {
			r=l+len[l]-1;
			for(int i=l;i<=r;++i) wt[sa[i]]=(sa[i]+k>n?0:rk[sa[i]+k]);
			sort(sa+l,sa+r+1,[&](int x,int y){ return wt[x]<wt[y]; });
			for(int i=l,j;i<=r;) {
				for(j=i;j<r&&wt[sa[j+1]]==wt[sa[i]];++j);
				len[i]=j-i+1;
				while(i<=j) rk[sa[i++]]=j;
			}
			l=r;
		}
	}
	for(int i=1,k=0;i<=n;++i) {
		k=max(k-1,0);
		while(str[i+k]==str[sa[rk[i]-1]+k]) ++k;
		ht[rk[i]][0]=k;
	}
	for(int k=1;k<20;++k) for(int i=1;i+bit(k)-1<=n;++i) {
		ht[i][k]=min(ht[i][k-1],ht[i+bit(k-1)][k-1]);
	}
}
int lcp(int x,int y) {
	int l=min(rk[x],rk[y])+1,r=max(rk[x],rk[y]),k=__lg(r-l+1);
	return min(ht[l][k],ht[r-bit(k)+1][k]);
}
int n,q,L[MAXN],R[MAXN],id[MAXN],ans[MAXN],d[MAXN],cnt[MAXN];
bool mk[MAXN];
vector <array<int,3>> Q1[MAXN],Q2[MAXN];
struct FenwickTree {
	int tr[MAXN],s;
	void init() { memset(tr,0,sizeof(tr)); }
	void add(int x) { for(;x<=n;x+=x&-x) ++tr[x]; }
	int qry(int x) { for(s=0;x;x&=x-1) s+=tr[x]; return s; }
}	T[2];
void solve() {
	scanf("%d%d%s",&n,&q,str+1);
	str[n+1]='#',str[2*n+2]='|';
	for(int i=1;i<=n;++i) str[2*n+2-i]=str[i];
	init(2*n+2);
	for(int i=1;i<=n;++i) R[i]=rk[i],L[i]=rk[2*n+2-i];
	for(int i=1;i<n;++i) {
		d[i]=lcp(i+1,2*n+2-i);
		mk[i]=(R[i+1]<L[i]),cnt[i]=cnt[i-1]+mk[i];
	}
	iota(id+1,id+n+1,1);
	sort(id+1,id+n+1,[&](int x,int y){ return L[x]<L[y]; });
	for(int i=1,x,k;i<=q;++i) {
		scanf("%d%d",&x,&k),ans[i]=0;
		int l=1,r=n,p=n+1;
		while(l<=r) {
			int m=(l+r)>>1;
			if(R[x]<L[id[m]]) p=m,r=m-1;
			else l=m+1;
		}
		if(p<=n) {
			Q1[p].push_back({x,k,i});
			ans[i]+=cnt[x-1];
			Q2[x+k-1].push_back({x,k,i});
		}
	}
	T[0].init(),T[1].init();
	for(int i=n;i>=1;--i) {
		T[id[i]&1].add(id[i]);
		for(auto z:Q1[i]) {
			int x=z[0],k=z[1],r=(x^1)&1;
			ans[z[2]]+=T[r].qry(x+2*k-1)-T[r].qry(x-1);
		}
	}
	T[0].init();
	for(int i=1;i<=n;++i) {
		if(mk[i]) T[0].add(i-d[i]+1);
		for(auto z:Q2[i]) ans[z[2]]-=T[0].qry(z[0]);
	}
	for(int i=1;i<=q;++i) printf("%d\n",ans[i]);
	for(int i=1;i<=n;++i) Q1[i].clear(),Q2[i].clear();
}
signed main() {
	int C,O; scanf("%d%d",&C,&O);
	while(O--) solve();
	return 0;
}
```

---

## 作者：Aiopr_2378 (赞：1)

### 解题思路

快速比较若干子串对的字典序貌似比较困难。我们可以将问题放宽一点，尝试比较一个后缀和若干前缀的反转的字典序。具体来说，我们将比较 $S[i:i+l-1]$ 和 $S[i+l:i+2l−1]^R$ 转化成比较 $S[i:n]$ 和 $S[1:i+2l-1]^R$。这样就有一些优势：

- 在多组比较中，其中的一个串是固定的 $S[i:n]$。
- 作比较的另一个串，也就是前缀的结束位置在奇数或偶数处形成了一个区间。

为了让问题形式变得更美观，我们考虑将 $S^R$ 拼接到 $S$ 的后面形成新串 $T=SS^R$。发现问题又变成了比较一个后缀和开始位置位于一个区间中的后缀的字典序关系。

![](https://cdn.luogu.com.cn/upload/image_hosting/60y87tcw.png)

发现比较 $A$ 和 $B$ 相当于比较 $A$ 和 $C$。

我们使用后缀数组求出每个后缀的排名，记作 $rnk$。一组询问 $(i,r)$ 相当于询问满足如下限制的后缀 $suf_p$ 数量：

- $p\in[2n-i-2r+2,2n-i]$；
- $p\mod 2\equiv i$；
- $rnk_p>rnk_i$。

这是一个二维数点问题，离线可以使用树状数组解决。

当 $S[i:i+l−1]$ 与 $S[i+l:i+2l−1]^R$ 完全相等的时候，这个位置是不能被统计到答案里去的。但由于我们比较的是后缀，可能就会存在 $rnk_{2n-i-2l+2}>rnk_i$ 然后被统计到的情况．我们需要将这类情况造成的贡献去掉。
    
出现这种情况的时候，有 $S[i:i+2l−1]$ 为回文串.那么我们要去掉的是：以 $i$ 开头的回文前缀，并且其可能被统计入答案。

![](https://cdn.luogu.com.cn/upload/image_hosting/nqvpefs7.png)

比较绿色回文串对应的两后缀（蓝色箭头）和比较红色回文串对应的两后缀（灰色箭头）本质上是在比较黄色箭头对应的两后缀。因为回文部分是相同的，我们直接跳过不比较也不会对比较结果产生影响。

那么可以这样做：预处理每个回文中心的极长回文半径（可以使用 manacher 或者 hash+二分）。并在极长回文半径处检查，这个中心的回文串是否可以被统计入非法答案。考虑一组以 $mid$ 为回文中心的 $S[L:R]$ 的极长回文串，对于一组询问 $(i,r)$ 需要减去的非法贡献就是：

- $L\le i \le  mid$；
- $r\ge mid$

的个数。这也是二维数点问题，使用树状数组解决。

时间复杂度 $O(n\log n)$。

### 参考代码

```cpp
#include<iostream>
#include<cstring>
#include<vector>
using namespace std;
#define MAXN 200005
#define lowbit(x) (x&(-x))
struct node{
    int i,r;
}ask[MAXN];
struct scan{
    int l,r,id,op;
};
int ID,T,n,Q,m,ans[MAXN],d[MAXN<<1];
char t[MAXN<<1];
struct BIT{
    int tree[MAXN];
    void add(int x,int k){
        while(x<=n){
            tree[x]+=k;
            x+=lowbit(x);
        }
    }
    int sum(int x){
        int w=0;
        while(x){
            w+=tree[x];
            x-=lowbit(x);
        }
        return w;
    }
    int query(int l,int r){
        return sum(r)-sum(l-1);
    }
    void clear(){
        memset(tree,0,sizeof(tree));
    }
}b[2],pb;
int x[MAXN],y[MAXN],c[MAXN],lstx[MAXN],sa[MAXN],rnk[MAXN],height[MAXN];
char s[MAXN];
vector<scan> qry[MAXN],q2[MAXN],pal[MAXN];
void init(){
    memset(x,0,sizeof(x));
    memset(y,0,sizeof(y));
    memset(lstx,0,sizeof(lstx));
    memset(sa,0,sizeof(sa));
    memset(rnk,0,sizeof(rnk));
    memset(height,0,sizeof(height));
    memset(d,0,sizeof(d));
    memset(t,0,sizeof(t));
    memset(ans,0,sizeof(ans));
    b[1].clear(),b[0].clear(),pb.clear();
    for(int i=0;i<=n+5;i++){
        qry[i].clear();
        q2[i].clear();
        pal[i].clear();
    }
}
void getsa(){
    m='z';
    for(int i=1;i<=m;i++) c[i]=0;
    for(int i=1;i<=n;i++) c[x[i]=s[i]]++;
    for(int i=2;i<=m;i++) c[i]+=c[i-1];
    for(int i=n;i;i--) sa[c[x[i]]--]=i;
    for(int k=1;k<=n;k<<=1){
        int num=0;
        for(int i=n-k+1;i<=n;i++) y[++num]=i;
        for(int i=1;i<=n;i++) if(sa[i]>k) y[++num]=sa[i]-k;
        for(int i=1;i<=m;i++) c[i]=0;
        for(int i=1;i<=n;i++) c[x[i]]++;
        for(int i=2;i<=m;i++) c[i]+=c[i-1];
        for(int i=n;i;i--) sa[c[x[y[i]]]--]=y[i];
        memcpy(lstx,x,sizeof(x));
        memset(x,0,sizeof(x));
        num=1,x[sa[1]]=1;
        for(int i=2;i<=n;i++){
            if(lstx[sa[i]]==lstx[sa[i-1]]&&lstx[sa[i]+k]==lstx[sa[i-1]+k]) x[sa[i]]=num;
            else x[sa[i]]=++num;
        }
        m=num;
        if(n==m) break;
    }
}
void manacher(){
    t[0]='$';
    int k=0;
    t[++k]='#';
    for(int i=1;i<=n/2;i++){
        t[++k]=s[i];
        t[++k]='#';
    }
    d[1]=1;
    for(int l=0,r=-1,i=2;i<=k;i++){
        if(i<=r) d[i]=min(r-i+1,d[l+r-i]);
        while(t[i+d[i]]==t[i-d[i]]) d[i]++;
        if(i+d[i]-1>r) r=i+d[i]-1,l=i-d[i]+1;
        if(t[i]=='#'&&d[i]>1) pal[i/2].push_back({(i-d[i]+2)/2,(i+d[i]-1)/2});
    }
}
void geth(){
    for(int i=1;i<=n;i++) rnk[sa[i]]=i;
    for(int j=0,i=1;i<=n;i++){
        if(rnk[i]==1) continue;
        if(j) j--;
        while(i+j<=n&&sa[rnk[i]-1]+j<=n&&s[i+j]==s[sa[rnk[i]-1]+j]) j++;
        height[rnk[i]]=j;
    }
}
int main(){
    ios::sync_with_stdio(0);
    cin>>ID>>T;
    while(T--){
        cin>>n>>Q>>(s+1);
        for(int i=1;i<=Q;i++) cin>>ask[i].i>>ask[i].r;
        for(int i=1;i<=n;i++) s[n*2-i+1]=s[i];
        n<<=1;
        init();
        getsa();
        geth();
        manacher();
        for(int i=1;i<=Q;i++){
            int p=ask[i].i,r=ask[i].r;
            qry[rnk[p]].push_back({n-p-r*2+2,n-p+1,i});
            if(p>1) q2[p-1].push_back({1,p,i,1});
            q2[p+r-1].push_back({1,p,i,-1});
        }
        for(int i=n;i;i--){
            if(sa[i]>n/2) b[sa[i]&1].add(sa[i],1);
            for(auto v:qry[i]){
                ans[v.id]=b[(v.r+1)&1].query(v.l,v.r);
            }
        }
        for(int i=1;i<=n/2;i++){
            for(auto v:pal[i]){
                if(rnk[n-v.l+1]>rnk[v.r]) pb.add(v.l,1);
            }
            for(auto v:q2[i]) ans[v.id]+=v.op*pb.sum(v.r);
        }
        for(int i=1;i<=Q;i++) cout<<ans[i]<<endl;
    }
    return 0;
}
```

---


# [JOISC 2022] 监狱

## 题目背景

JOISC2022 D1T1

## 题目描述

在 JOI 王国，安保最严格的地方就是 IOI 监狱。IOI 监狱中有 $N$ 个房间，以 $1,\dots,N$ 编号。其中有 $N-1$ 条通道。第 $i$ $(1\le i\le N-1)$ 条通道双向地连接房间 $A_i$ 和 $B_i$。任意两个房间都可以相互到达。

IOI 监狱中有 $M$ 个囚犯，以 $1,\dots,M$ 编号。第 $j$ $(1\le j\le M)$ 个囚犯的卧室和工作室分别是房间 $S_j,T_j$。一个囚犯可能在另一个囚犯的卧室工作。然而，每个房间最多成为一个囚犯的卧室，一个囚犯的工作室。

一天早上，这 $M$ 个囚犯需要从他们的卧室移动到他们的工作室。典狱长 APIO 先生需要按如下方式指示囚犯移动：  
- **指令**：选择一个囚犯，然后命令他从当前所在的房间移动到一个与该房间有直接连边的房间。为了避免囚犯交流，不允许将囚犯移动到有其他囚犯在的房间。

为了尽早开始工作，APIO 先生想知道，是否存在一种给出任意条指令的方案使得每个囚犯以**最短路径**从卧室到达工作室。

请编写一个程序，在给定如上房间、通道和罪犯的所有信息后判断是否存在满足条件的方案。

## 说明/提示

**【样例解释 #1】**

可以通过发送如下指令完成任务：

1. 让囚犯 $2$ 从 $4$ 号房间移动到 $5$ 号房间。
2. 让囚犯 $1$ 从 $3$ 号房间移动到 $4$ 号房间。
3. 让囚犯 $2$ 从 $5$ 号房间移动到 $6$ 号房间。
4. 让囚犯 $2$ 从 $6$ 号房间移动到 $7$ 号房间。
5. 让囚犯 $2$ 从 $7$ 号房间移动到 $8$ 号房间。

这组样例满足所有子任务的限制。

**【样例解释 #2】**

这组样例满足子任务 $1,3,4,5,6,7$ 的限制。

**【数据范围】**

对于所有数据，满足：

- $1\leq Q\leq 1000$。
- $1\leq N\leq 120000$。
- $1\leq A_i\lt B_i\leq N$ $(i\in [1,N-1])$。
- $2\leq M\leq N$。
- $1\leq S_i,T_i\leq N$ $(i\in [1,M])$。
- $S_i$ $(i\in[1,M])$ 互不相同。
- $T_i$ $(i\in[1,M])$ 互不相同。
- $S_j \ne T_j$ $(j\in [1, M])$。
- 任意两个房间之间可以通过给定道路互相到达。
- 对于所有测试用例，$N$ 的总和不超过 $120000$。

详细子任务附加限制及分值如下表所示：

|子任务编号|附加限制|分值|
|:-:|:-:|:-:|
|$1$|$A_i=i,B_i=i+1~(i\in[1,N-1])$|$5$|
|$2$|$Q\leq 20, N\leq 250, M=2$|$5$|
|$3$|$Q\leq 20, N\leq 250, M\leq 6$|$16$|
|$4$|$Q\leq 20, N\leq 250, M\leq 100$|$28$|
|$5$|$Q\leq 20, M\leq 500$|$12$|
|$6$|任意两个房间之间都可以通过不超过 $20$ 条道路到达。|$11$|
|$7$|无附加限制|$23$|

## 样例 #1

### 输入

```
1
8
1 2
2 3
3 4
4 5
5 6
6 7
7 8
2
3 4
4 8```

### 输出

```
Yes```

## 样例 #2

### 输入

```
2
7
1 2
2 3
3 4
4 5
3 6
6 7
2
4 1
5 7
4
1 2
1 3
1 4
3
2 3
3 4
4 2```

### 输出

```
Yes
No```

# 题解

## 作者：Melting_Pot (赞：12)

题目链接：[[JOISC 2022 Day1] 监狱](https://www.luogu.com.cn/problem/P9520)

本题的思路并不刁钻，但十分考验代码能力，因此本蒟蒻尽量讲的仔细一点，尽量串联起思路与代码中的重点，当然也方便本人加深理解。

- ## Analysis:
首先对于两个的罪犯，我们思考他们在什么情况下不合法，无非以下几种：

1. 两个囚犯路径有重合，且相向而行。
1. 两个囚犯路径呈包含与被包含关系。
1. 两个囚犯路径有重合，但处理不当，使其在中途相遇。

    $\dots$

我们发现这些限制条件只能提供一些类似于特殊判断的思路，而且限制三肉眼可见的不合理，那么我们只好换一种思路：从最后合法的方案入手。如果最后方案合法，就意味着有一种合理的先后顺序可以安排所有罪犯，使其不相遇且到达终点。

而囚犯们当然可以先安排一个囚犯走完他的路径，再同理安排另一个，这是因为每个囚犯的移动路径是独立的，要想判断最终情况是否合法，这要知道先后顺序，这与囚犯们谁先走完路径是无关的，故这种移动策略是合理的。

所以，我们去思考每个囚犯移动的先后顺序，不难得出以下两条简洁规整的性质：

- 如果 $A$ 的起点在 $B$ 的路径上，那么 $A$ 必须先于 $B$ 走。
- 如果 $A$ 的终点在 $B$ 的路径上，那么 $B$ 必须先于 $A$ 走。

由此答案也就呼之欲出了，我们根据这两条性质为各个囚犯连有向边表示他们的先后关系，暴力跳点，拓扑判环，如果成环就是不合法方案，那么你会获得一个 $\Theta(n^2)$ 的连边建图，这样的复杂度在本题的数据范围下当然会被卡的十分拉跨，那么我们将思路优化一下，用[线段树优化建图](https://www.cnblogs.com/light-house/p/11761163.html)。

我们首先将原图的树复制两棵 $S,T$，约定用 $S_x$，$T_x$ 表示原图中点 $x$ 在这两棵树上的编号（原树的 dfs 序）。

对于 $i$ 的路径：
- 我们从所有路径上的点在 $S$ 上对应的点向 $p_i$ 连边，代表起点在这些点上的人必须先于 $i$ 走，为了传递限制，还需对每个 $p_i$ 向 $S_{s_i}$ （第 $i$ 个罪犯的起点的编号）连边
- 我们从 $p_i$ 向所有路径上的点在 $T$ 上对应的点连边，代表 $i$ 必须先于终点在这些点上的人走，为了传递限制，还需对每个 $T_{t_i}$ （第 $i$ 个罪犯的终点的编号）向 $p_i$ 连边。


如果你还不是很明白，那我们不妨画个图辅助理解：

首先，我们先看非法的一组数据：

```
8
1 2
2 4
4 9
2 5
3 6
3 7
3 8
1 3
2
4 3
1 2

```
图长这样：
![](https://cdn.luogu.com.cn/upload/image_hosting/la89gfdz.png)

因为两条路径有重复，根据上文提到的性质，我们给两个人分别连边，发现成环，因此不合法。但是我们将其放在线段树上，又该怎么办？

首先按照线段树优化建图的套路，对原树按照 **dfs 序**建立两棵线段树，一颗为全是出边的”出树“，另一棵为全是入边的“入树”，按照上文提到的连边规则，我们不难连出这样一幅图：

![](https://cdn.luogu.com.cn/upload/image_hosting/ins0ghef.png)

这是一棵“入树”，可以发现经过连边，$P_2$ 罪犯可以向 $P_1$ 罪犯连一条有向边，代表 $P_2$ 与 $P_1$ 的先后顺序，同理，我们再建一棵”出树“（这里不再给出图片），可以发现 $P_1$ 罪犯又向 $P_2$ 罪犯连出了另一条有向边，我们惊喜的发现：$P_1$ 与 $P_2$ 罪犯成环了！矛盾的出现意味着非法的诞生，那么我们愉快地将当前局面判为“非法”。

- ## Achieve:
首先树剖求出 dfs 序及重链，然后线段树建出两棵树表示”出入树“，我们发现操作涉及区间对单点加边以及单点对区间加边，那么我们在跳重链的时候对两棵树进行操作，然后就是将单点对单点加边，最后拓扑判环，拜拜程序。

- ## Attention:

1. 两棵线段树实际上建的是同一个图的不同种边（~~废话~~）。
1. 多测的清空记得精细化处理。
1. 原树与线段树建图一定要区分清楚，不论是思路上还是代码上。

- ## Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e6+5;
int n,m;
int deg[N];
int to[N<<1],nxt[N<<1],head[N<<1],tot1;
int to1[N<<1],head1[N<<1],nxt1[N<<1],tot;
void add1(int u,int v){
    to1[++tot]=v,nxt1[tot]=head1[u],head1[u]=tot;
    to1[++tot]=u,nxt1[tot]=head1[v],head1[v]=tot;
}
void add(int u,int v){
    // if(typ) swap(u,v);
    to[++tot]=v,nxt[tot]=head[u],head[u]=tot;
    deg[v]++;
}
int f[N],son[N],rev[N],top[N],dfn[N],siz[N],dep[N],cntd;
void dfs(int u,int fa){
    dep[u]=dep[fa]+1,siz[u]=1,f[u]=fa;
    for(int i=head1[u];i;i=nxt1[i]){
        if(to1[i]==fa) continue;
        dfs(to1[i],u);
        siz[u]+=siz[to1[i]];
        if(siz[to1[i]]>siz[son[u]]) son[u]=to1[i];
    }
}
void dfs2(int u,int tp){
    top[rev[dfn[u]=++cntd]=u]=tp;
    if(son[u]) dfs2(son[u],tp);
    for(int i=head1[u];i;i=nxt1[i]) if(to1[i]^f[u]&&to1[i]^son[u]) dfs2(to1[i],to1[i]);
}
int cnt(0);
int leaf[N][2];
struct SMT{
    #define lc t[pos].ls
    #define rc t[pos].rs
    #define mid ((l+r)>>1)
    struct Node{
        int ls,rs;
    }t[N<<2];
    void build(int &pos,int l,int r,int typ){
        pos=++cnt;
        if(l==r) return leaf[l][typ]=pos,void();
        t[pos].ls=t[pos].rs=0;
        build(lc,l,mid,typ);build(rc,mid+1,r,typ);
        if(typ) add(pos,lc),add(pos,rc);
        else add(lc,pos),add(rc,pos);
    }
    void update(int pos,int l,int r,int L,int R,int x,int typ){
        if(r<L||R<l||R<L) return;
        if(L<=l&&r<=R) return typ?add(x,pos):add(pos,x),void();
        update(lc,l,mid,L,R,x,typ);
        update(rc,mid+1,r,L,R,x,typ);
    }
    #undef lc
    #undef rc
    #undef mid
}S,T;
int trt,srt;
void update(int x,int y,int z){
    if(dep[x]<dep[y]) swap(x,y);
    if(dfn[y]<=dfn[x]&&dfn[x]<=dfn[y]+siz[y]-1){
        x=f[x];
        while(top[x]^top[y]){
            S.update(srt,1,n,dfn[top[x]],dfn[x],z,0);
            T.update(trt,1,n,dfn[top[x]],dfn[x],z,1);
            x=f[top[x]];
        }
        S.update(srt,1,n,dfn[y]+1,dfn[x],z,0);
        T.update(trt,1,n,dfn[y]+1,dfn[x],z,1);
    }else{
        x=f[x],y=f[y];
        while(top[x]^top[y]){
            if(dep[top[x]]<dep[top[y]]) swap(x,y);
            S.update(srt,1,n,dfn[top[x]],dfn[x],z,0);
            T.update(trt,1,n,dfn[top[x]],dfn[x],z,1);
            x=f[top[x]];
        }
        if(dfn[x]<dfn[y]) swap(x,y);
        S.update(srt,1,n,dfn[y],dfn[x],z,0);
        T.update(trt,1,n,dfn[y],dfn[x],z,1);
    }
}
bool topo(){
    queue<int> q;
    for(int i=1;i<=cnt;i++) if(!deg[i]) q.push(i);
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int i=head[u];i;i=nxt[i]){
            deg[to[i]]--;
            if(!deg[to[i]]) q.push(to[i]);
        }
    }
    for(int i=1;i<=cnt;i++) if(deg[i]) return false;
    return true;
}
void clear(){
    memset(head1,0,sizeof(int)*(n+1));
    memset(head,0,sizeof(int)*(cnt+1));
    memset(son,0,sizeof(int)*(n+1));
    memset(deg,0,sizeof(int)*(cnt+1));
    tot=tot1=cnt=cntd=srt=trt=0;
}
int main(){
    //  freopen("prison.in","r",stdin);
    //  freopen("prison.out","w",stdout);
    int t;cin>>t;
    while(t-->0){
        clear();
        scanf("%d",&n);
        for(int i=2,u,v;i<=n;i++){
            scanf("%d%d",&u,&v);
            add1(u,v);
        }
        dfs(1,0),dfs2(1,1);
        S.build(srt,1,n,0);
        T.build(trt,1,n,1);
        scanf("%d",&m);
        for(int i=1,s,t;i<=m;i++){
            scanf("%d%d",&s,&t);
            cnt++;
            add(leaf[dfn[t]][0],cnt),add(cnt,leaf[dfn[s]][0]);
            add(leaf[dfn[t]][1],cnt),add(cnt,leaf[dfn[s]][1]);
            update(s,t,cnt);
        }
        puts(topo()?"Yes":"No");
    }
}
```

感谢阅读！！！

---

## 作者：云浅知处 (赞：7)

许多题解没有给出第一步结论的证明啊，这里是一个证明。

考虑寻找合法解的性质，发现如果有解，那么一定存在一种方案使得每个人开始走之后，直接不停顿地走到终点。

证明：考虑合法解中某个人 $i$ 的相邻两次行动 $A\to B,B\to C$，由于走的是最短路径，必有 $A\neq B\neq C$。

我们考虑如果这两次行动在总的行动序列上不相邻，它们中间有若干次行动，由于此时 $i$ 位于点 $B$，因此其他人的任意行动都不能经过 $B$。以 $B$ 为根建树，那么中间的行动可以划分为三部分：

- 完全在 $A$ 子树内的部分
- 完全在 $C$ 子树内的部分
- 其他的部分

借用官方题解的图：

![](https://cdn.luogu.com.cn/upload/image_hosting/oynmvgig.png)

于是我们可以重排操作序列为：

- 先进行完全在 $C$ 子树内的部分。
- 然后让 $i$ 这个人从 $A\to B\to C$。
- 然后进行 $A$ 子树内的部分和其他部分。

这样一直操作下去，一定可以构造出一种解满足每个人开始走之后，直接不停顿地走到终点。

于是我们考虑两个人 $(i,j)$ 如果满足 $S_i\in\text{path}(S_j,T_j)$ 或者 $T_j\in \text{path}(S_i,T_i)$，那么 $i$ 就得在 $j$ 前面走。这样会连出来一张有向图，如果是 DAG 就有解，否则无解。

直接连会得到 $O(M^2)$ 条边，许多数据结构都能将其边数优化至 $O(M\log N)$。于是就可以通过了。

---

## 作者：5k_sync_closer (赞：4)

若 $u$ 路径的起点在 $v$ 路径上，则 $u$ 必须比 $v$ 先走，

若 $u$ 路径的终点在 $v$ 路径上，则 $v$ 必须比 $u$ 先走。

考虑建图，边 $u\to v$ 存在当且仅当 $u$ 必须比 $v$ 先走，

若建出的图有拓扑序，则按拓扑序操作即可，否则无解。

建图的复杂度太高，于是考虑线段树优化建图，分别考虑两个要求：

> 若 $u$ 路径的起点在 $v$ 路径上，则 $u$ 必须比 $v$ 先走

把每条路径向其起点连边，然后把每条路径除起点外的点向这条路径连边，

此时 $u$ 连向 $u$ 的起点，而 $u$ 路径的起点在 $v$ 路径上，所以 $u$ 的起点连向 $v$。

> 若 $u$ 路径的终点在 $v$ 路径上，则 $v$ 必须比 $u$ 先走

把每个终点向其路径连边，然后把每条路径向这条路径除终点外的点连边，

此时 $u$ 路径的终点在 $v$ 路径上，所以 $v$ 连向 $u$ 的终点，而 $u$ 的终点连向 $u$。

```cpp
#include <queue>
#include <cstdio>
#include <cctype>
#include <cstring>
#define L(p) (p << 1)
#define R(p) (p << 1 | 1)
using namespace std;
struct E
{
    int v, t;
} e[10000050];
queue<int> q;
int O, n, m, c, z, a[200050], d[2000050], h[2000050];
void A(int u, int v)
{
    ++d[v];
    e[++c] = {v, h[u]};
    h[u] = c;
}
void B(int s, int t, int p)
{
    if (s == t)
    {
        a[s] = p;
        return;
    }
    A(p, L(p));
    A(p, R(p));
    A(L(p) + (n << 2), p + (n << 2));
    A(R(p) + (n << 2), p + (n << 2));
    int m = s + t >> 1;
    B(s, m, L(p));
    B(m + 1, t, R(p));
}
void C(int l, int r, int v, int o, int s, int t, int p)
{
    if (l <= s && t <= r)
    {
        if (o)
            A(v, p);
        else
            A(p + (n << 2), v);
        return;
    }
    int m = s + t >> 1;
    if (l <= m)
        C(l, r, v, o, s, m, L(p));
    if (r > m)
        C(l, r, v, o, m + 1, t, R(p));
}
struct T
{
    struct E
    {
        int v, t;
    } e[400050];
    int c, p, z[400050], d[400050], f[400050], s[400050], t[400050], b[400050], k[400050], h[400050];
    void A(int u, int v)
    {
        e[++c] = {v, h[u]};
        h[u] = c;
    }
    void X(int u)
    {
        s[u] = 1;
        for (int i = h[u], v; i; i = e[i].t)
            if (!d[v = e[i].v])
            {
                d[v] = d[f[v] = u] + 1;
                X(v);
                s[u] += s[v];
                if (s[v] > s[z[u]])
                    z[u] = v;
            }
    }
    void Y(int u, int g)
    {
        t[k[b[u] = ++p] = u] = g;
        if (z[u])
            Y(z[u], g);
        for (int i = h[u], v; i; i = e[i].t)
            if ((v = e[i].v) != f[u] && v != z[u])
                Y(v, v);
    }
    void M(int x, int y, int z, int k, int o)
    {
        while (t[x] != t[y])
        {
            if (d[t[x]] < d[t[y]])
                swap(x, y);
            C(b[t[x]], b[x] - (x == z), k, o, 1, n, 1);
            x = f[t[x]];
        }
        if (d[x] > d[y])
            swap(x, y);
        C(b[x] + (x == z), b[y] - (y == z), k, o, 1, n, 1);
    }
} T;
int main()
{
    scanf("%d", &O);
    while (O--)
    {
        scanf("%d", &n);
        B(1, n, 1);
        for (int i = 1, u, v; i < n; ++i)
            scanf("%d%d", &u, &v), T.A(u, v), T.A(v, u);
        T.X(T.d[1] = 1);
        T.Y(1, 1);
        scanf("%d", &m);
        for (int i = 1, x, y; i <= m; ++i)
        {
            scanf("%d%d", &x, &y);
            A(i + (n << 3), a[T.b[x]] + (n << 2));
            A(a[T.b[y]], i + (n << 3));
            T.M(x, y, x, i + (n << 3), 0);
            T.M(x, y, y, i + (n << 3), 1);
        }
        for (int i = 1; i <= (n << 3) + m; ++i)
            if (!d[i])
                q.push(i);
        while (!q.empty())
        {
            ++z;
            int u = q.front();
            q.pop();
            for (int i = h[u], v; i; i = e[i].t)
                if (!--d[v = e[i].v])
                    q.push(v);
        }
        puts(z == (n << 3) + m ? "Yes" : "No");
        c = z = T.c = T.p = 0;
        for (int i = 1; i <= (n << 3) + m; ++i)
            d[i] = h[i] = 0;
        for (int i = 1; i <= n; ++i)
            T.z[i] = T.d[i] = T.f[i] = T.s[i] = T.t[i] = T.b[i] = T.k[i] = T.h[i] = 0;
    }
    return 0;
}
```


---

## 作者：daduoli (赞：3)

发现之前模拟赛考过这个题，但是不会做。

看了一眼题解区发现全是线段树优化建图，实际上可以用倍增优化建图，虽然空间复杂度是 $O(n\log n)$ 的，但是时间复杂度是 $O(n\log n)$ 的。

首先像其他题解一样，我们类似的分析。

考虑什么时候非法，正常会想到路径被包含，或者说路径相交，且方向相反，这样是非法的。

但是看一样样例会发现第 $2$ 个样例的第二组数据，这种情况。

如果会有这种情况，那么我们判断非法将会变的非常不可做，我们需要找到一种简单的判断方法。

既然非法判不了，考虑什么时候合法。

有一个看上去很有道理的结论，如果存在合法路径，那么一定存在一种方案使得每个囚犯要么不走，要么直接走到他的终点。

考虑证明，如果存在一条路径需要从 $A\to B\to C$，且 $A\to B,B\to C$ 中有其他操作，那么这些操作一定不经过 $B$，考虑这时候以 $B$ 为根建图，先执行原本 $B\to C$ 间要执行的操作，再执行 $A\to C$，再执行原本 $A\to B$ 中执行的操作，按照这样一直做下去，可以得到满足性质的一组方案。

所以我们只需要考虑囚犯的先后顺序即可，对于路径不交的囚犯，显然他们直接没有直接的先后关系，考虑有交的情况。

- $Y$ 的起点在 $X$ 的路径上，那么这时候 $Y$ 先于 $X$。
- $Y$ 的终点在 $X$ 的路径上，这时候 $X$ 先于 $Y$。 

直接暴力建图，拓扑排序时间复杂度是 $O(n^2)$ 的，不行。

考虑优化建图。

相当于 $X$ 向终点在 $X$ 路径上的 $Y$ 连边，起点在 $X$ 路径上的 $Y$ 向 $X$ 连边。

然后拓扑排序看一下有没有环即可。

时间复杂度 $O((n+m)\log n)$，常熟很大，被线段树优化建图锤爆了。


```
#include<bits/stdc++.h>
#define Yzl unsigned long long
#define pb emplace_back
#define fi first
#define se second
#define mp make_pair
#define pi pair<int,int>
typedef long long LL;

using namespace std;

const Yzl Lty=20120712;

const int MAXN=2e5+10;
int n;
int Fa[MAXN][20],fa[MAXN],dep[MAXN],i1[MAXN][20],i2[MAXN][20],cnt;
vector<int> e[MAXN];
void add(int f,int t) {
	e[f].pb(t);
}
vector<int> E[MAXN*60];
int deg[MAXN*60];
void Add(int f,int t) {
	E[f].pb(t); ++deg[t];
}
void dfs(int u,int fa) {
	dep[u]=dep[fa]+1; Fa[u][0]=fa; i1[u][0]=++cnt; i2[u][0]=++cnt;
	for(int i=1;i<=19;++i) {
		Fa[u][i]=Fa[Fa[u][i-1]][i-1];
		if(Fa[u][i]) {
			i1[u][i]=++cnt;
			i2[u][i]=++cnt;
			Add(i1[u][i-1],i1[u][i]); Add(i1[Fa[u][i-1]][i-1],i1[u][i]);
			Add(i2[u][i],i2[u][i-1]); Add(i2[u][i],i2[Fa[u][i-1]][i-1]);
		} else i1[u][i]=i2[u][i]=0;
	}
	for(auto t:e[u]) if(t!=fa) dfs(t,u);
}
int find(int x) {
	return (fa[x]==x?x:fa[x]=find(fa[x]));
}
int LCA(int x,int y) {
	if(dep[x]<dep[y]) swap(x,y);
	for(int i=19;i>=0;--i) if(dep[Fa[x][i]]>=dep[y]) x=Fa[x][i];
	if(x==y) return x;
	for(int i=19;i>=0;--i) if(Fa[x][i]!=Fa[y][i]) x=Fa[x][i],y=Fa[y][i];
	return Fa[x][0];
}
void upd(int x,int lca,int cnt) {
	for(int i=19;i>=0;--i) if(dep[Fa[x][i]]>=lca) {
		Add(i1[x][i],cnt); Add(cnt,i2[x][i]);
		x=Fa[x][i];
	}
}
void vmain() {
	scanf("%d",&n);
	for(int i=1;i<n;++i) {
		int u,v; scanf("%d%d",&u,&v);
		add(u,v); add(v,u);
	} int Q; scanf("%d",&Q); dfs(1,0);
	for(int i=1;i<=Q;++i) {
		int x,y; scanf("%d%d",&x,&y); ++cnt;
		Add(cnt,i1[x][0]); Add(i2[y][0],cnt); 
		Add(i1[y][0],cnt); Add(cnt,i2[x][0]); 
		int lca=LCA(x,y);
		if(lca==x||lca==y) {
			if(dep[x]>dep[y]) swap(x,y);
			y=Fa[y][0]; upd(y,dep[x],cnt);
		} else {
			x=Fa[x][0]; y=Fa[y][0];
			upd(x,dep[lca],cnt); upd(y,dep[lca],cnt);
			Add(i1[lca][0],cnt); Add(cnt,i2[lca][0]);
		}
	} queue<int> q;
	for(int i=1;i<=cnt;++i) if(!deg[i]) q.push(i);
	while(!q.empty()) {
		int u=q.front(); q.pop();
		for(auto t:E[u]) {
			--deg[t]; if(!deg[t]) q.push(t);
		}
	} bool sf=0;
	for(int i=1;i<=cnt;++i) if(deg[i]) sf=1;
	puts((sf?"No":"Yes"));
	for(int i=1;i<=cnt;++i) {
		E[i].clear(); deg[i]=0;
	}
	for(int i=1;i<=n;++i) {
		e[i].clear();
	} cnt=0;
}
int main() {
	int T=1; scanf("%d",&T);
	while(T--) vmain();
	return 0;
}

```

---

## 作者：gdf_yhm (赞：3)

[[JOISC2022] 监狱](https://www.luogu.com.cn/problem/P9520)

### 思路

因为是一棵树，最短路径唯一，所以每次都让一个人走到底。当走 $s->t$，$s->t$ 中此时没有点，意味着起点这条路径上的人一定先于这个人走，终点在这条路径上的人一定后于这个人走。对于他们的相对顺序的限制，先走向后走连边，连边跑拓扑排序看有没有环。复杂度 $O(n^2)$。

优化建图，形如一个点向一条路径连边，一条路径向一个点连边。把一个点拆成两个，一个记录进入，一个出去。

线段树 $O(n\log^2 n)$，但可以倍增优化 $O(n\log n)$。记 $in_{u,i}$ 和 $out_{u,i}$ 表示 $u$ 到 $u$ 的 $2^i$ 级祖先这段区间。然后跟线段树优化一样向下一级区间连边。点向路径连边则在跳路径的 lca 是连边。

倍增常数过大甚至有时不如线段树。

```cpp
int n,m;
int head[maxn<<6],tot;
struct nd{
	int nxt,to;
}e[maxn<<7];
int d[maxn<<6];
void add(int u,int v){e[++tot]={head[u],v};head[u]=tot;d[v]++;}
int to[maxn][17],dep[maxn];
int in[maxn][17],out[maxn][17],idx;
void dfs(int u,int fa){
	to[u][0]=fa;dep[u]=dep[fa]+1;
	for(int i=1;i<=16;i++)to[u][i]=to[to[u][i-1]][i-1];
	for(int i=0;i<=16;i++)if(to[u][i])in[u][i]=++idx,out[u][i]=++idx,d[idx-1]=d[idx]=0;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;if(v==fa)continue;
		dfs(v,u);
	}
}
int lca(int u,int v){
	if(dep[u]<dep[v])swap(u,v);
	for(int i=16;~i;i--)if(dep[to[u][i]]>=dep[v])u=to[u][i];
	if(u==v)return u;
	for(int i=16;~i;i--)if(to[u][i]!=to[v][i])u=to[u][i],v=to[v][i];
	return to[u][0];
}
int kth(int u,int k){
	for(int i=16;~i;i--)if((k>>i)&1)u=to[u][i];
	return u;
}
void updin(int u,int v,int w){
	if(u==v){
		add(w,u);
		return ;
	}
	if(dep[u]<dep[v])swap(u,v);
	for(int i=16;~i;i--)if(dep[to[u][i]]>=dep[v]){
		add(w,in[u][i]);
		u=to[u][i];
	}
	if(u==v)return ;
	for(int i=16;~i;i--)if(to[u][i]!=to[v][i]){
		add(w,in[u][i]),add(w,in[v][i]);
		u=to[u][i],v=to[v][i];
	}
	add(w,to[u][0]);
	add(w,u),add(w,v);
}
void updout(int u,int v,int w){
	if(u==v){
		add(u+n,w);
		return ;
	}
	if(dep[u]<dep[v])swap(u,v);
	for(int i=16;~i;i--)if(dep[to[u][i]]>=dep[v]){
		add(out[u][i],w);
		u=to[u][i];
	}
	// cout<<u<<" "<<v<<" "<<w<<" out\n";
	if(u==v)return ;
	for(int i=16;~i;i--)if(to[u][i]!=to[v][i]){
		add(out[u][i],w),add(out[v][i],w);
		u=to[u][i],v=to[v][i];
	}
	add(to[u][0]+n,w);
	add(u+n,w),add(v+n,w);
}
queue<int> q;
void work(){
	n=read();
	for(int i=1;i<n;i++){
		int u=read(),v=read();
		add(u,v),add(v,u);
	}
	m=read();idx=2*n+m;
	dfs(1,0);
	for(int i=1;i<=n;i++)head[i]=0;tot=0;
	for(int i=1;i<=idx;i++)d[i]=0;
	for(int u=1;u<=n;u++){
		for(int i=1;i<=16;i++)if(to[u][i]){
			add(in[u][i],in[u][i-1]),add(in[u][i],in[to[u][i-1]][i-1]);
			add(out[u][i-1],out[u][i]),add(out[to[u][i-1]][i-1],out[u][i]);
		}
		if(to[u][0]){
			add(in[u][0],u),add(in[u][0],to[u][0]);
			add(u+n,out[u][0]),add(to[u][0]+n,out[u][0]);
		}
	}
	for(int i=1;i<=m;i++){
		int u=read(),v=read();
		add(i+2*n,u+n),add(v,i+2*n);
		// cout<<i+2*n<<" "<<u+n<<" "<<v<<"\n";
		int tp=lca(u,v),uu,vv;
		if(tp==u)uu=kth(v,dep[v]-dep[tp]-1);
		else uu=to[u][0];
		if(tp==v)vv=kth(u,dep[u]-dep[tp]-1);
		else vv=to[v][0];
		// cout<<uu<<" "<<vv<<" q\n";
		updin(u,vv,i+2*n);updout(uu,v,i+2*n);
	}
	// for(int u=1;u<=idx;u++){
		// for(int i=head[u];i;i=e[i].nxt){
			// int v=e[i].to;
			// cout<<u<<" "<<v<<"\n";
		// }
	// }
	for(int i=1;i<=idx;i++)if(!d[i])q.push(i);
	while(!q.empty()){
		int u=q.front();q.pop();
		// if(u>2*n&&u<=2*n+m)cout<<u-2*n<<" t\n";
		for(int i=head[u];i;i=e[i].nxt){
			int v=e[i].to;
			if(d[v]){
				d[v]--;
				if(!d[v])q.push(v);
			}
		}
	}
	for(int i=1;i<=idx;i++)head[i]=0;tot=0;
	// for(int i=1;i<=idx;i++)if(d[i])cout<<i<<" "<<d[i]<<" d\n";
	for(int i=2*n+1;i<=2*n+m;i++)if(d[i]){printf("No\n");return ;}
	printf("Yes\n");
}
```

---

## 作者：Sonnety (赞：3)

## 前置知识：

推一下我的博客：[优化建图相关](https://www.cnblogs.com/sonnety-v0cali0d-kksk/p/Build_tree-written_by_sonnety.html#5204558)

（内含这道题，如果没学过优化建图可以看这个，体验会更好一些）

有关部分分：[官方题解 日文](https://files.cnblogs.com/files/blogs/785806/JOI2022D1T1%E7%9B%91%E7%8B%B1.7z?t=1692615516&download=true)

## 题意概括：

对于 $n$ 个点的树，有 $m$ 条起点与终点各不相同的行进路线形如 $s_i\to t_i$，允许从某个点移动至相邻点，问能否在不存在某个点所在人数 $> 1$ 的情况下完成所有行进路线。

## 问题转换：

首先有一个特别性质：

**如果合法，一定有一种合法的方案使得每个人都是不停留地从头走到尾。**

如果 $A$ 走到道路一半需要等待 $B$ 走完自己再走，那么我们自然也可以让 $B$ 先走完，自己再走。

因此就有两限制：

* $A$ 起点在 $s_B\to t_B$ 时，$A$ 点先走。

* $A$ 终点在 $s_B\to t_B$ 时，$B$ 点先走。

而当存在冲突时，我们就输出 `No`。

因此我们可以规定将 $m$ 个行进路线是 $m$ 个点，$A$ 先于 $B$ 走是 $A$ 向 $B$ 连边，而存在冲突则是出现环。

需要判断一个图是否是有向无环图，拓扑排序即可。

## 考虑优化：

最主要的时间复杂度在于建图，就是判断上面的两条性质，对于每个点判断两条性质的时间复杂度是 $O(n^2)$，我们考虑让一个行进计划一次性连好边：

* 复制原图的树为两棵新树 $S,T$，其中 $S$ 是上行树，$T$ 是下行树。

* 将第 $i$ 个行进计划在 $S$ 上的对应点全都向 $i$ 连边，表示起点在这些点的行进计划要先于 $i$ 走。

* 将 $i$ 向第 $i$ 个行进计划在 $T$ 上的所有对应点连边，表示终点在这些点的行进计划要晚于 $i$ 走。

* 另外，我们要单独把起点和终点拿出来，让第 $i$ 个行进计划连向起点，让终点连向第 $i$ 个行进计划，其余的区间刨去起点终点，上行树连向第 $i$ 个行进计划，第 $i$ 个下行树，这样我们就有了“起点被包含的情况”，就可能出环了。

为什么这样就成环了？

![图如果炸了就去看看博客园吧，悲](https://cdn.luogu.com.cn/upload/image_hosting/2un7dneb.png)

（$i,j$ 是两个行进计划，$st_i,to_i$ 则是计划 $i$ 的起点与终点在线段树中的叶子节点，$sid,tid$ 是刨去了起点终点后的区间，本图表示，第 $i$ 个行进计划的起点与终点均被第 $j$ 个包含，不合法）

因此可以进行树链剖分+线段树优化建图。

时间复杂度 $O(n\log^2 n)$。

（tips：对于普通 dfs 树上建边和各个行进计划之间的边，最好开两个结构体存边或者开一个容器开一个结构体，总之不要放在一起存，否则会冲突）

## Code:


```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define rg register int
#define next Miku
typedef long double llf;
typedef long long ll;
typedef pair<int,int> PII;
const double eps=1e-8;
namespace io{
//	char in[1<<20],*p1=in,*p2=in;
//	#define getchar() (p1==p2&&(p2=(p1=in)+fread(in,1,1<<20,stdin),p1==p2)?EOF:*p1++)
	il int read(){
   		char c=getchar();
    	int x=0,f=1;
   		while(c<48)<%if(c=='-')f=-1;c=getchar();%>
    	while(c>47)x=(x*10)+(c^48),c=getchar();
    	return x*f;
	}
	il void write(int x){
    	if(x<0)<%putchar('-');x=~x+1;%>
    	if(x>9) write(x/10);
   		putchar(x%10+'0');
	} 
	il int ins(char *str){
		int len=0;
		while(1){
			char c=getchar();
			if(c!='\n' && c!='\0' && c!='\r')	str[++len]=c;
			else	break;
		}
		return len;
	}
}
namespace mystd{
	il int Max(int a,int b)<%if(a<b) return b;return a; %>
	il int Min(int a,int b)<%if(a>b) return b;return a; %>
	il int Abs(int a)<% if(a<0) return a*(-1);return a; %>
	il double fMax(double a,double b)<%if(a<b) return b;return a; %>
	il double fMin(double a,double b)<%if(a>b) return b;return a; %>
	il double fAbs(double a)<% if(a<0) return a*(-1);return a; %>
	il int dcmp(double a){
		if(a<-eps)	return -1;
		if(a>eps)	return 1;
		return 0;
	}
}const int maxn=1200500;

int T,n,m;
int dep[maxn],myf[maxn],sonum[maxn],top[maxn],hson[maxn],in[maxn],myin[maxn],tim;
int pos[maxn],du[maxn];
int t,head[maxn<<6];
vector<int> E[maxn]; 
struct edge{
	int v,next;
};edge e[maxn<<6];
il void add_edge(int u,int v){
	e[++t].v=v;
	e[t].next=head[u];
	head[u]=t;
}

namespace SegementTree{
	#define lid (id<<1)
	#define rid (id<<1|1)
	int S[maxn<<2],T[maxn<<2];
	void build_tree(int id,int l,int r){
		if(l==r){
			pos[myin[l]]=id;
			return;
		}
		add_edge(id,lid);++du[lid];
		add_edge(id,rid);++du[rid];
		add_edge((n<<2)+lid,(n<<2)+id);++du[(n<<2)+id];
		add_edge((n<<2)+rid,(n<<2)+id);++du[(n<<2)+id];
		int mid=(l+r)>>1;
		build_tree(lid,l,mid);
		build_tree(rid,mid+1,r);
	}
	void update(int id,int l,int r,int x,int y,int p){
		if(x>r || y<l)	return;
		if(x<=l && r<=y){
			add_edge(p,id);++du[id];
			add_edge((n<<2)+id,p);++du[p];
			return;
		}
		int mid=(l+r)>>1;
		update(lid,l,mid,x,y,p);
		update(rid,mid+1,r,x,y,p);
	}
	void update1(int id,int l,int r,int x,int y,int p){
		if(x>r || y<l || x>y)	return;
		if(x<=l && r<=y){
			add_edge(p,id);
			++du[id];
			return;
		}
		int mid=(l+r)>>1;
		update1(lid,l,mid,x,y,p);
		update1(rid,mid+1,r,x,y,p);
	}
	void update2(int id,int l,int r,int x,int y,int p){
		if(x>r || y<l || x>y)	return;
		if(x<=l && r<=y){
			add_edge((n<<2)+id,p);
			++du[p];
			return;
		}
		int mid=(l+r)>>1;
		update2(lid,l,mid,x,y,p);
		update2(rid,mid+1,r,x,y,p);
	}
	#undef lid
	#undef rid
}

il void dfs1(int now,int fa){
	myf[now]=fa;
	dep[now]=dep[fa]+1;
	sonum[now]=1;
	for(int to:E[now]){
		if(to==fa)	continue;
		dfs1(to,now);
		sonum[now]+=sonum[to];
		if(sonum[hson[now]]<sonum[to])	hson[now]=to;
	}
}

il void dfs2(int now,int topp){
	top[now]=topp;
	in[now]=++tim;
	myin[tim]=now;
	if(!hson[now])	return;
	dfs2(hson[now],topp);
	for(int to:E[now]){
		if(to!=myf[now] && to!=hson[now])	dfs2(to,to);
	}
}

il void update(int u,int v,int id){
	add_edge(n*8+id,(n<<2)+pos[u]);++du[(n<<2)+pos[u]];
	add_edge(pos[v],n*8+id);++du[n*8+id];
	int x=u,fx=top[x],y=v,fy=top[y];
	while(fx!=fy){
		if(dep[fx]>dep[fy])	swap(fx,fy),swap(x,y);
		if(y!=u && y!=v)	SegementTree::update(1,1,n,in[fy],in[y],8*n+id);
		else{
			SegementTree::update(1,1,n,in[fy],in[y]-1,8*n+id);
			if(y==u)	add_edge(8*n+id,pos[u]),++du[pos[u]];
			else	add_edge(4*n+pos[v],8*n+id),++du[8*n+id];
			
		}
		y=myf[top[y]],fy=top[y];
	}
	
	if(dep[x]>dep[y])	swap(x,y);
	if(x!=v && y!=v)	SegementTree::update1(1,1,n,in[x],in[y],8*n+id);
	else if(x!=y){
		if(x==v)	SegementTree::update1(1,1,n,in[x]+1,in[y],8*n+id);
		else	SegementTree::update1(1,1,n,in[x],in[y]-1,8*n+id); 
	}
	if(x!=u && y!=u)	SegementTree::update2(1,1,n,in[x],in[y],8*n+id);
	else if(x!=y){
		if(x==u)	SegementTree::update2(1,1,n,in[x]+1,in[y],8*n+id);
		else	SegementTree::update2(1,1,n,in[x],in[y]-1,8*n+id);
	}
}

queue<int> q;
il void inttopo(){
	for(int i=1;i<=n*8+m;++i){
		if(du[i]==0)	q.push(i);
	}
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(rg i=head[u];i;i=e[i].next){
			int to=e[i].v;
			--du[to];
			if(du[to]==0)	q.push(to);
		}
	}
}

il void clear(){
	tim=0;
	t=0;
	for(rg i=1;i<=n;++i)	<% myf[i]=dep[i]=sonum[i]=hson[i]=in[i]=myin[i]=top[i]=0;E[i].clear(); %>
	for(rg i=1;i<=n*8+m;++i)	head[i]=du[i]=0;
}

il void input(){
	n=io::read();
	int u,v;
	for(rg i=1;i<=n-1;++i){
		u=io::read(),v=io::read();
		E[u].push_back(v);
		E[v].push_back(u);
	}
}

int main(){
//	freopen("prison.in","r",stdin);
//	freopen("prison.out","w",stdout);
	T=io::read(); 
	while(T--){
		input();
		dfs1(1,0);
		dfs2(1,1);
		SegementTree::build_tree(1,1,n);
		m=io::read();
		int s,t;
		for(rg i=1;i<=m;++i){
			scanf("%d %d",&s,&t);
			update(s,t,i);
		}
//		for(rg i=1;i<=n*8+m;++i){
//			cout<<i<<' '<<du[i]<<endl;
//		}
		inttopo();
		bool mj=true;
		for(int i=1;i<=8*n+m;++i){
			if(du[i])	<% mj=false;break; %>
		}
		if(mj)	printf("Yes\n");
		else	printf("No\n");
		clear();
	}
	return 0;
}
/*
1
8
1 2
2 3
3 4
4 5
5 6
6 7
7 8
4
1 5
2 6
3 7
4 8
*/ 

```

最后的碎语：这道题可以用倍增优化建图做，不用线段树，时间复杂度更优，但是我不会QAQ，所以在学，如果未来学会了可能会更新在上面的优化建图博客里。


---

## 作者：周子衡 (赞：2)

观察到：如果存在合法的移动方案，那么一定存在一种移动方案，使得每个人收到的移动指令是连续的。换句话说，存在一个 $1\sim n$ 的排列 $p_1\sim p_n$，使得第 $i$ 轮将犯人 $p_i$ 从 $s_{p_i}$ 移动到 $t_{p_i}$ 的方案是合法的。考虑依此设计算法。

对两个人 $(s_1,t_1),(s_2,t_2)$ 来说，如果 $s_1$ 在 $(s_2,t_2)$ 上，那么第一个人在排列中应该早于第二个人出现；如果 $t_1$ 在 $(s_2,t_2)$ 上，那么第一个人在排列中应该晚于第二个人出现；反之亦然。考虑将所有这样的限制条件连成有向边，那么相当于判图是否无环，拓扑排序即可。建边的过程可以用数据结构优化（树上倍增、树链剖分皆可），总时间复杂度 $O(n\log n)$。

```cpp
#include<cstdio>
#include<vector>
#include<queue>

using namespace std;

vector<int> ed[200000];

int dep[200000],fa[200000][20];
int dfn[200000],sz[200000];

void dfs_bas(int u,int f)
{
	dep[u]=dep[f]+1,fa[u][0]=f,dfn[u]=++dfn[0],sz[u]=1;for(int i=1;i<20;i++)fa[u][i]=fa[fa[u][i-1]][i-1];
	for(int i=0;i<ed[u].size();i++)if(ed[u][i]!=f){dfs_bas(ed[u][i],u);sz[u]+=sz[ed[u][i]];}
}

#define ID(i,j)(((i)-1)*20+(j)+1)

int anc(int u,int d)
{
	for(int i=19;i>=0;i--)if(d&(1<<i))u=fa[u][i];return u;
}

vector<int> fnd_anc(int u,int d)
{
	vector<int> P;
	for(int i=19;i>=0;i--){if(d&(1<<i)){P.push_back(ID(u,i));u=fa[u][i];}}
	return P;
}
int LCA(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);for(int i=19;i>=0;i--)if(dep[fa[x][i]]>=dep[y])x=fa[x][i];if(x==y)return x;
	for(int i=19;i>=0;i--)if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i];return fa[x][0];
}
vector<int> fnd_pth(int u,int v)
{
	int l=LCA(u,v);vector<int> U=fnd_anc(u,dep[u]-dep[l]+1),V=fnd_anc(v,dep[v]-dep[l]+1);
	for(int i=0;i<V.size();i++)U.push_back(V[i]);return U;
}

int nxt_node(int u,int v)
{
	if(!(dfn[v]>dfn[u]&&dfn[v]<dfn[u]+sz[u]))return fa[u][0];return anc(v,dep[v]-dep[u]-1);
}

vector<int> r[8000000];int deg[8000000];

bool topo(int n)
{
	for(int i=1;i<=n;i++)for(int j=0;j<r[i].size();j++)deg[r[i][j]]++;
	queue<int> q;
	for(int i=1;i<=n;i++)if(!deg[i])q.push(i);
	int cnt=0;
	while(!q.empty())
	{
		int u=q.front();q.pop();cnt++;
		for(int i=0;i<r[u].size();i++){deg[r[u][i]]--;if(!deg[r[u][i]])q.push(r[u][i]);}
	}
	for(int i=1;i<=n;i++)deg[i]=0;
	return cnt==n;
}

int main()
{
	int TT=0;scanf("%d",&TT);
	while(TT--)
	{
		int n=0;scanf("%d",&n);
		for(int i=1,u=0,v=0;i<n;i++)
		{
			scanf("%d%d",&u,&v);ed[u].push_back(v),ed[v].push_back(u);
		}
		dfs_bas(1,0);
		int tot=ID(n,19);
		//printf("%d\n",tot);
		int m=0;scanf("%d",&m);
		for(int i=1,s=0,t=0;i<=m;i++)
		{
			scanf("%d%d",&s,&t);
			int p=nxt_node(s,t),q=nxt_node(t,s);
			//printf("%d %d\n",p,q);
			vector<int> P=fnd_pth(p,t),Q=fnd_pth(s,q);
			//for(int j=0;j<P.size();j++)printf("%d ",P[j]);puts("");
			//for(int j=0;j<Q.size();j++)printf("%d ",Q[j]);puts("");
			for(int j=0;j<P.size();j++)r[P[j]+m].push_back(i);r[i].push_back(ID(s,0)+m);
			for(int j=0;j<Q.size();j++)r[i].push_back(Q[j]+m+tot);r[ID(t,0)+m+tot].push_back(i);
		}
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=19;j++)
			{
				r[m+ID(i,j-1)].push_back(m+ID(i,j));
				if(fa[i][j-1])r[m+ID(fa[i][j-1],j-1)].push_back(m+ID(i,j));
				r[m+tot+ID(i,j)].push_back(m+tot+ID(i,j-1));
				if(fa[i][j-1])r[m+tot+ID(i,j)].push_back(m+tot+ID(fa[i][j-1],j-1));
			}
		}
		
		/*for(int i=1;i<=2*tot+m;i++)
		{
			for(int j=0;j<r[i].size();j++)printf("%d %d\n",i,r[i][j]);
		}*/
		
		puts(topo(2*tot+m)?"Yes":"No");
		
		for(int i=1;i<=n;i++)ed[i].clear(),sz[i]=dfn[i]=dep[i]=0;
		for(int i=1;i<=n;i++)for(int j=0;j<20;j++)fa[i][j]=0;
		for(int i=1;i<=2*tot+m;i++)r[i].clear();
	}
}
```

---

## 作者：blossom_j (赞：2)

结论：
- 如果 $A$ 的起点在 $B$ 的路径上，那么$A$ 必须先于 $B$ 走。
- 如果 $A$ 的终点在 $B$ 的路径上，那么$B$ 必须先于 $A$ 走。

那么将 $A$ 必须先于 $B$ 走表示为 $A$ 向 $B$ 连边，那么就看这个图有没有拓扑序，拓扑排序判一下即可。

我们首先将原图的树复制两棵 $S,T$，树 $S$ 儿子连向父亲，树 $T$ 父亲连向儿子（线段树优化建图）。用 $S_x,T_x$ 表示原图中点 $x$ 在这两棵树上的编号，还有连接两树的节点 $p_i(1 \leq i \leq m)$ 表示罪犯。 

对于第 $i$ 个罪犯的路径：

- 对于路径上的终点，$i$ 必须先于终点在这条路径上的人走，所以 $p_i$ 节点连向这些点在 $T$ 中的区间。
- 对于路径上的起点，这些点必须先于 $i$ 先走，所以 这些点在 $S$ 中的区间连向 $p_i$ 。

为了传递限制，还需对每个 $p_i$ 向 $S_{s_i}$ 连边（$s_i$ 为叶子节点编号，$p_i$ 为该节点上的起点）。

为了传递限制，还需对每个 $T_{t_i}$ 向 $p_i$ 连边（$t_i$ 为叶子节点编号，$p_i$ 为该节点上的终点）。

可以对原树树剖，边跳 $top$ 边建边。

```
#include<bits/stdc++.h>
using namespace std;
const int N=120005;
const int M=N*50;
int s[N],t[N];
int pi[N],du[M];
int head[N*2],ver[N*2],nex[N*2],tot=0;
void add(int x,int y){
	ver[++tot]=y,nex[tot]=head[x],head[x]=tot;
}
int head_t[M],ver_t[M],nex_t[M],tot_t=0;
void add_t(int x,int y){
	ver_t[++tot_t]=y,nex_t[tot_t]=head_t[x],head_t[x]=tot_t;
	du[y]++;
}
int fa[N],top[N],siz[N],d[N],son[N],id[N],tot_d=0;
int cnt_t,rt1,rt2;
void dfs1(int x,int f){
	fa[x]=f;
	siz[x]=1;
	d[x]=d[f]+1;
	for(int i=head[x];i;i=nex[i]){
		int y=ver[i];
		if(y==f) continue;
		dfs1(y,x);
		siz[x]+=siz[y];
		if(siz[son[x]]<siz[y]){
			son[x]=y;
		}
	}
}

void dfs2(int x,int tp){
	top[x]=tp;
	id[x]=++tot_d;
//	rk[tot_d]=x;
	if(son[x]) dfs2(son[x],tp);
	for(int i=head[x];i;i=nex[i]){
		int y=ver[i];
		if(y==fa[x]) continue;
		if(y!=son[x]) dfs2(y,y);
	}
}

struct Segment_tree{
	int l,r;
}tr[M];

int S[N],T[N];

void buildt(int &p,int l,int r){
	if(!p) p=++cnt_t;
	if(l==r){
		T[l]=p;
		return;
	}
	int mid=(l+r)/2;
	buildt(tr[p].l,l,mid);
	buildt(tr[p].r,mid+1,r);
	add_t(p,tr[p].l);
	add_t(p,tr[p].r);
}

void builds(int &p,int l,int r){
	if(!p) p=++cnt_t;
	if(l==r){
		S[l]=p;
		return;
	}
	int mid=(l+r)/2;
	builds(tr[p].l,l,mid);
	builds(tr[p].r,mid+1,r);
	add_t(tr[p].l,p);
	add_t(tr[p].r,p);
}

void changet(int p,int wh,int l,int r,int id){
	if(l==r){
		add_t(p,pi[id]);
		return;
	}
	int mid=(l+r)/2;
	if(wh<=mid) changet(tr[p].l,wh,l,mid,id);
	else changet(tr[p].r,wh,mid+1,r,id);
}

void changes(int p,int wh,int l,int r,int id){
	if(l==r){
		add_t(pi[id],p);
		return;
	}
	int mid=(l+r)/2;
	if(wh<=mid) changes(tr[p].l,wh,l,mid,id);
	else changes(tr[p].r,wh,mid+1,r,id);
}

void changet1(int p,int l,int r,int L,int R,int id){
	if(l>r) return;
	if(L>=l && R<=r){
		add_t(pi[id],p);
		return;
	}
	int mid=(L+R)/2;
	if(l<=mid) changet1(tr[p].l,l,r,L,mid,id);
	if(r>mid) changet1(tr[p].r,l,r,mid+1,R,id);
}

void changes1(int p,int l,int r,int L,int R,int id){
	if(l>r) return;
	if(L>=l && R<=r){
		add_t(p,pi[id]);
		return;
	}
	int mid=(L+R)/2;
	if(l<=mid) changes1(tr[p].l,l,r,L,mid,id);
	if(r>mid) changes1(tr[p].r,l,r,mid+1,R,id);
}

void workt(int x,int y,int op){
	int fx=top[x],fy=top[y];
	while(fx!=fy){
		if(d[fx]>d[fy]){
			int as=id[fx],bs=id[x];
			changet1(rt1,as,bs,1,tot_d,op);
			if(x==s[op]) changes1(rt2,as,bs-1,1,tot_d,op);
			else changes1(rt2,as,bs,1,tot_d,op);
			x=fa[fx],fx=top[x];
		}
		else{
			int as=id[fy],bs=id[y];
			if(y==t[op]) changet1(rt1,as,bs-1,1,tot_d,op);
			else changet1(rt1,as,bs,1,tot_d,op);
			changes1(rt2,as,bs,1,tot_d,op);
			y=fa[fy],fy=top[y];
		}
	}
	int as=id[x],bs=id[y];
	if(id[x]<id[y]){
		if(y==t[op]) bs--;
		changet1(rt1,id[x],bs,1,tot_d,op);
		if(x==s[op]) as++;
		changes1(rt2,as,id[y],1,tot_d,op);
	}
	else{
		if(y==t[op]) bs++;
		changet1(rt1,bs,id[x],1,tot_d,op);
		if(x==s[op]) as--;
		changes1(rt2,id[y],as,1,tot_d,op);
	}
}
queue<int> q;
void clear(int n,int m){
	for(int i=1;i<=cnt_t;i++) head_t[i]=du[i]=0;
	for(int i=1;i<=n;i++) head[i]=siz[i]=son[i]=fa[i]=top[i]=siz[i]=d[i]=id[i]=0;
	for(int i=1;i<=m;i++) pi[i]=s[i]=t[i]=0;
	for(int i=1;i<=cnt_t;i++){
		tr[i].l=tr[i].r=0;
	}
	tot=tot_t=tot_d=cnt_t=0;
	rt1=rt2=0;
}
signed main(){
//	freopen("prison.in","r",stdin);
//	freopen("prison.out","w",stdout);
	int pp;
	scanf("%d",&pp);
	while(pp--){
		int n;
		scanf("%d",&n);
		for(int i=1;i<n;i++){
			int x,y;
			scanf("%d%d",&x,&y);
			add(x,y),add(y,x);
		}
		dfs1(1,0);
		dfs2(1,0);
		cnt_t=0;
		buildt(rt1,1,tot_d);
		builds(rt2,1,tot_d);
		int m;
		scanf("%d",&m);
		for(int i=1;i<=m;i++){
			pi[i]=++cnt_t;
		}
		for(int i=1;i<=m;i++){
			scanf("%d%d",&s[i],&t[i]);
			changet(rt1,id[t[i]],1,tot_d,i);
			changes(rt2,id[s[i]],1,tot_d,i);
		}
		for(int i=1;i<=m;i++){
			workt(s[i],t[i],i);
		}
		for(int i=1;i<=cnt_t;i++){
			if(du[i]==0){
				q.push(i); 
			}
		}
		while(!q.empty()){
			int x=q.front();
			q.pop();
			for(int i=head_t[x];i;i=nex_t[i]){
				int y=ver_t[i];
				du[y]--;
				if(du[y]==0) q.push(y);
			}
		}
		int ans=0;
		for(int i=1;i<=m;i++){
			if(du[pi[i]]) {
				ans=1;
				break;
			}
		}
		if(ans==1) printf("No\n");
		else printf("Yes\n");
		clear(n,m);
	}
}
```


---

## 作者：DeepSeaSpray (赞：1)

# P9520 [JOISC2022] 监狱

## 题目描述

有一棵 $N$ 个节点的树，有 $M$ 个囚犯，要从 $S_i$ 走到 $T_i$。每一时刻可以发布一个命令让一名囚犯走到相邻的节点，要求任意时刻囚犯不能走到同一个节点上，求是否可以令每一个囚犯从 $S_i$ 走到 $T_i$。

## 做法解析

首先我们可以发现一个囚犯要么一次走完其路径，要么不走。

故我们需要确定一个走的先后顺序，这等价于对于任意两个囚犯，我们确定他们走的先后顺序。

我们考虑囚犯 $A$，$B$。

- 如果，$S_A$ 在 $B$ 的路径上 那么 $A$ 要先走。
- 如果，$T_A$ 在 $B$ 的路径上 那么 $B$ 要先走。

我们考虑先走的囚犯向后走的囚犯连一条有向边，如果是一个 DAG 那么就可以找到一种满足条件的方案，否则不行。

直接连边是 $O(n^2)$ 的，我们考虑树链剖分加线段树优化连边。

我们需要两棵线段树，一棵 $S$ 树表示起点，一棵 $T$ 树表示终点。

- $A$ 路径上的点（$S_A$ 除外）在 $S$ 树上的节点向 $A$ 连边。
- $A$ 向 $A$ 路径上的点（$T_A$ 除外）在 $T$ 树上的节点连边。
- $A$ 向 $S_A$ 在 $S$ 树上的节点连边。
- $T_A$ 在 $T$ 树上的节点向 $A$ 连边。

对于 $S$ 树子区间向父区间连边。

对于 $T$ 树父区间向子区间连边。

参见下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/se0wbblg.png)

图片只说明建图方式，其不一定符合实际数据。

时间与空间复杂度 $O(n \log^2 n)$。

## 注意事项

- 线段树虽然理论上只需要用 $2n-1$ 个节点，但是如果使用普通的建树方式，节点的编号是 $4n$ 级别的。

## 代码

然而实现的并不好。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e6;
const int maxm=1e7;
struct Edge{int u,v,nxt;};
int n,m;
int dg[maxn+5];
int hd[maxn+5],et;
Edge e[maxm+5];
int idt;
int de[maxn+5],sz[maxn+5],fa[maxn+5];
int sn[maxn+5],id[maxn+5],tp[maxn+5];
int S[maxn+5],st;
int stp,sts,stt,edp;
int V[maxn+5],vt;
inline void Adde(int u,int v){
	dg[v]++;
	e[et].u=u,e[et].v=v;
	e[et].nxt=hd[u],hd[u]=et++;
}
void Dfs1(int u){
	int v;
	sz[u]=1;
	for(int i=hd[u];~i;i=e[i].nxt){
		v=e[i].v;
		if(v==fa[u]) continue;
		fa[v]=u;
		de[v]=de[u]+1;
		Dfs1(v);
		sz[u]+=sz[v];
		if(sz[sn[u]]<sz[v]) sn[u]=v;
	}
}
void Dfs2(int u,int TP){
	int v;
	id[u]=++idt;
	tp[u]=TP;
	if(sn[u]) Dfs2(sn[u],TP);
	for(int i=hd[u];~i;i=e[i].nxt){
		v=e[i].v;
		if(v==fa[u]||v==sn[u]) continue;
		Dfs2(v,v);
	}
}
void Build(int x,int L,int R){
	if(L==R) return;
	else{
		int mid=(R-L)/2+L;
		Adde(sts+(x<<1),sts+x);
		Adde(sts+(x<<1|1),sts+x);
		Adde(stt+x,stt+(x<<1));
		Adde(stt+x,stt+(x<<1|1));
		Build(x<<1,L,mid);
		Build(x<<1|1,mid+1,R);
	}
}
void Query(int x,int L,int R,int l,int r){
	if(l<=L&&R<=r) V[++vt]=x;
	else{
		int mid=(R-L)/2+L;
		if(l<=mid) Query(x<<1,L,mid,l,r);
		if(mid<r) Query(x<<1|1,mid+1,R,l,r);
	}
}
inline void TQuery(int l,int r,int t){
	if(l<=t&&t<=r){
		if(l<t) Query(1,1,n,l,t-1);
		if(t<r) Query(1,1,n,t+1,r);
	}
	else Query(1,1,n,l,r);
}
void Modify(int p,int u,int v){
	int tu=id[u],tv=id[v];
	while(tp[u]!=tp[v]){
		if(de[tp[u]]<de[tp[v]]) swap(u,v);
		vt=0;
		TQuery(id[tp[u]],id[u],tu);
		for(int i=1;i<=vt;i++) Adde(sts+V[i],stp+p);
		vt=0;
		TQuery(id[tp[u]],id[u],tv);
		for(int i=1;i<=vt;i++) Adde(stp+p,stt+V[i]);
		u=fa[tp[u]];
	}
	if(de[u]<de[v]) swap(u,v);
	vt=0;
	TQuery(id[v],id[u],tu);
	for(int i=1;i<=vt;i++) Adde(sts+V[i],stp+p);
	vt=0;
	TQuery(id[v],id[u],tv);
	for(int i=1;i<=vt;i++) Adde(stp+p,stt+V[i]);
}
inline void Solve(){
	int u,v;
	scanf("%d",&n);
	et=idt=0;
	for(int i=1;i<=n;i++) hd[i]=-1,sn[i]=0;
	for(int i=1;i<n;i++){
		scanf("%d%d",&u,&v);
		Adde(u,v),Adde(v,u);
	}
	Dfs1(1);
	Dfs2(1,1);
	scanf("%d",&m);
	et=0;
	stp=0,sts=m,stt=m+4*n,edp=m+8*n;
	for(int i=1;i<=edp;i++) hd[i]=-1,dg[i]=0;
	Build(1,1,n);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&u,&v);
		Modify(i,u,v);
		vt=0;
		Query(1,1,n,id[u],id[u]);
		for(int j=1;j<=vt;j++) Adde(stp+i,sts+V[j]);
		vt=0;
		Query(1,1,n,id[v],id[v]);
		for(int j=1;j<=vt;j++) Adde(stt+V[j],stp+i);
	}
	for(int i=1;i<=edp;i++)
		if(!dg[i]) S[++st]=i;
	while(st){
		u=S[st--];
		for(int i=hd[u];~i;i=e[i].nxt){
			v=e[i].v;
			dg[v]--;
			if(!dg[v]) S[++st]=v;
		}
	}
	for(int i=1;i<=edp;i++){
		if(dg[i]){
			puts("No");
			return;
		}
	}
	puts("Yes");
}
signed main(){
	int TT;
	scanf("%d",&TT);
	while(TT--) Solve();
	return 0;
}
```

---

## 作者：OIerBoy (赞：1)

# Sol
一道很好的模型转换题。

我们看完题目后首先就可以发现其实一步一步的移动是影响我们的，因为如果是存在可行方案时，那么一定有一种方案是每一个囚犯转移时可以直接 $S_i\to T_i$ 的。

证明也非常简单，如果当前存在一种可行方案需要 $S_i\to x$ 停顿一下，再 $x\to T_i$。则说明在点 $x$ 存在另一名囚犯，需要等另一名囚犯转移了再进行移动。那么我们就完全可以先让另一名囚犯转移，然后在一步到位 $S_i\to T_i$。

那么无可行方案的条件也就很明显了：当存在点 $x$ 移动前需要点 $y$ 移动，但是点 $y$ 需要点 $x$ 先移动再移动。换句话说就是形成了一个环。

判断一张图上是否存在环非常简单，只需要进行一个拓扑排序就可以了。

那么下一个问题，也是本题的核心：如何去建图呢？

简单的建图方式很明显不行，我们因为就是要判断是否存在环，而我们有需要保证 $S_i\to T_i$ 有边，而且要对于路径上每一个点都要有边，那么我们就需要建两组一模一样的点：

- 第一组我们将点 $i$ 连向除 $T_i$ 外 $S_i\to T_i$ 上的所有点，$T_i$ 连向点 $i$；

- 第二组我们将除 $S_i$ 外 $S_i\to T_i$ 上的所有点连向点 $i$，点$i$ 连向 $S_i$。

例如，对于 $3\to 4$ 时，建图就长这样:

![](https://cdn.luogu.com.cn/upload/image_hosting/m7a4p4ah.png)

而，如果 $i$ 与 $j$ 冲突了，就会出现环：

![](https://cdn.luogu.com.cn/upload/image_hosting/57bai4vb.png)

这样我们就可以把图建出来了，拓扑就行了。

但如果这样这道题就做完了它就不是紫题了。因为我们发现暴力建图的时间复杂度是 $O(n^2)$ 的。仔细分析发现，我们的对于区间连边 $O(n)$ 的时间复杂度是接受不了的，考虑优化。

由于我们的操作是对于一个树上连续的区间连边，我们就可以树链剖分加线段树来优化。先用树链剖分把树转成区间，再把区间放到线段树上，每次连边就直接连向线段树就好了。

时间复杂度是 $O(n\log ^2n)$ 的。

---

## 作者：EuphoricStar (赞：1)

观察可得，若存在合法解，则一定存在一种解，使得每个人都不停顿地从起点走到终点。

因为如果一个人走到一半要停下来等另一个人走，显然这个人也可以选择先走或者等另一个人走完自己再走。

继续观察可得，当且仅当第 $i, j$ 个人满足以下条件，它们之间的走的先后顺序能被确定：

- $s_i$ 在 $\text{path}(s_j, t_j)$ 上，则 $i$ 比 $j$ 先走；
- $t_i$ 在 $\text{path}(s_j, t_j)$ 上，则 $i$ 比 $j$ 后走。

建图跑拓扑排序即可。但是朴素建图边数太多了。

考虑把 $u, v$ 之间的边通过树上的点中转。对于每个点再复制一份，形成 $x_i, x'_i$。考虑建图如下：对于第 $i$ 个人，设 $s_i \to t_i$ 的路径中，除 $s_i$ 外走到的第一个点是 $p$，除 $t_i$ 外走到的第一个点是 $q$。

- 对于 $u \in \text{path}(s_i, q)$，连边 $i \to u$；
- 对于 $u \in \text{path}(p, t_i)$，连边 $u' \to i$；
- 连边 $t_i \to i, i \to s_i'$。

这样，若 $s_i$ 在 $\text{path}(s_j, t_j)$ 上，可以通过 $i \to s_i' \to j$ 从 $i$ 到达 $j$；若 $t_i$ 在 $\text{path}(s_j, t_j)$ 上，可以通过 $j \to t_i \to i$ 从 $j$ 到达 $i$。并且这样建图不会造成多余的影响。

那我们还剩下的问题是，一个点向树上的一条路径上的所有点连边。

考虑树剖后线段树优化建图，边数是 $O(n \log^2 n)$，就可以通过了。

[code](https://loj.ac/s/1881768)

鲜花：

![](https://s1.ax1x.com/2023/09/08/pP63Ruq.png)

调了一下午。

---

## 作者：xcyyyyyy (赞：0)

若两个路径冲突了，当且仅当这几种情况：

* 终点被对方包含
* 起点被对方包含
* 有一条被完全包含

但是还有一些其他的情况会寄掉，比如一个路径上的所有点都被其他路径覆盖了的时候。

继续思考下去还有很多乱七八糟的东西，但是最终都不了了之。

---

有一个很神奇的结论是，一定存在一种方案，使得每个点都直接走到终点。

考虑证明：如果存在路径 $A \rightarrow B\rightarrow C$，两次中间有其他操作，那么这些操作一定不经过 $B$。我们将整个树以 $B$ 为根建图，那么我们可以如下排列操作：

先执行 $C$ 中的操作，再执行 $A \rightarrow C$，再执行其他操作。

一直调整下去，我们一定能找到一组满足的操作方案。

---

那么我们只需要考虑这些边执行的先后顺序即可，如果囚犯 $x$ 的起点在 $y$ 的路径上，那么 $x$ 必须先于 $y$ 走；如果囚犯 $x$ 的终点在 $y$ 的路径上，那么 $x$ 必须后于 $y$ 走。我们对应连边，如果该图存在环则一定无解，否则我们可以按照拓扑序一个一个走即可。

连边用线段树优化建图随便搞搞就行了。

---

可能这种多个人同时移动，都会想一想能不能直接移动到末尾吧。

---


# [JOISC 2022] 京都观光

## 题目背景

JOISC2022 D1T2

## 题目描述

京都是世界级的观光圣地，它也被称为网格城市。你来到了京都观光，并且你计划步行游览一个著名的景点。本题中，我们考虑如下的简化问题。

在城市中，有 $H$ 条东西方向的街道和 $W$ 条南北方向的街道，因此城市是一个 $(H-1)\times(W-1)$ 的网格。从北数第 $i$ 条街道和从西数第 $j$ 条街道的交叉点记作路口 $(i,j)$。

不同的街道可能有不同的材质、宽度和拥挤程度，因此你的步行速度有可能不同。对于每条街道，你的步行速度如下：

- 如果你在从北数第 $i$ 条街道上行走单位长度，需要 $A_i$ 秒。即从路口 $(i,c)~\left(i\in[1,H],c\in[1,W)\right)$ 走到路口 $(i,c+1)$ 需要 $A_i$ 秒。

- 如果你在从西数第 $j$ 条街道上行走单位长度，需要 $B_j$ 秒。即从路口 $(c,j)~\left(c\in[1,H),j\in[1,W]\right)$ 走到路口 $(c+1,j)$ 需要 $B_j$ 秒。

你现在在路口 $(1,1)$，你想前往 $(H,W)$，你必须沿着街道行走，并且你不希望走远路，即你不会向北或向西走。

你希望尽早到达目的地，请你求出，在给定的条件下，从路口 $(1,1)$ 前往路口 $(H,W)$ 所需的最少时间。

## 说明/提示

**【样例解释 #1】**

有两条从 $(1,1)$ 到 $(2,2)$ 的路线：

1. $(1,1)\rightarrow(1,2)\rightarrow(2,2)$，所需时间为 $1+5=6$ 秒。
2. $(1,1)\rightarrow(2,1)\rightarrow(2,2)$，所需时间为 $2+3=5$ 秒。

因此最少花费时间为 $5$ 秒。

这个样例满足所有子任务的限制。

**【样例解释 #2】**

最优路线如下图：

![样例解释](https://cdn.luogu.com.cn/upload/image_hosting/mqsalajm.png)

这个样例满足所有子任务的限制。

**【样例解释 #3】**

这个样例满足子任务 $1,3$ 的限制。

**【数据范围】**

对于所有数据，满足：

- $2\leq H,W\leq 100000$。
- $1\leq A_i\leq 10^9$ $(i\in[1,H])$。
- $1\leq B_i\leq 10^9$ $(i\in[1,W])$。

详细子任务附加限制及分值如下表所示：

|子任务编号|附加限制|分值|
|:-:|:-:|:-:|
|$1$|$H,W\leq 1000$|$10$|
|$2$|$A_i\leq 1000, B_i\leq 1000$|$30$|
|$3$|无附加限制|$60$|

## 样例 #1

### 输入

```
2 2
1 3
2 5```

### 输出

```
5```

## 样例 #2

### 输入

```
5 5
7 1 5 2 8
7 2 4 1 6```

### 输出

```
20```

## 样例 #3

### 输入

```
4 6
454863204 543362989 866044086 813602010
71574269 17945210 688720933 392135202 38174709 168241720```

### 输出

```
2737473954```

# 题解

## 作者：SoyTony (赞：13)

考虑行 $x<y<z$，列 $l<r$，那么有三种移动方式：

- $(x,l)\to (x,r)\to (z,r)$，代价 $(r-l)a_x+(z-x)b_r$。

- $(x,l)\to (z,l)\to (z,r)$，代价 $(r-l)a_z+(z-x)b_l$。

- $(x,l)\to (y,l)\to (y,r)\to (z,r)$，代价 $(r-l)a_y+(y-x)b_l+(z-y)b_r$。

经过 $y$ 的条件时后者小于前面两个式子，移项整理得到：

$$\dfrac{a_y-a_x}{y-x}<\dfrac{b_r-b_l}{r-l}<\dfrac{a_z-a_y}{z-y}$$

因此对 $a$ 维护一下下凸壳，$b$ 同理。

现在就只考虑是向下或向右了，把前两个式子比较，有：

$$(r-l)a_x+(z-x)b_r<(r-l)a_z+(z-x)b_l\Rightarrow \dfrac{b_r-b_l}{r-l}<\dfrac{a_z-a_x}{z-x}$$

因此每次会选择沿斜率较小的方向移动，维护两个指针分别在两个凸包上移动即可。


```cpp
int n,m;
int a[maxn],b[maxn];

inline bool check_slope_a(int x,int y,int z){
    ll lhs=1ll*(a[y]-a[x])*(z-y),rhs=1ll*(a[z]-a[y])*(y-x);
    return lhs>=rhs;
}
inline bool check_slope_b(int x,int y,int z){
    ll lhs=1ll*(b[y]-b[x])*(z-y),rhs=1ll*(b[z]-b[y])*(y-x);
    return lhs>=rhs;
}
inline bool check_slope_ab(int x,int y,int l,int r){
    ll lhs=1ll*(a[y]-a[x])*(r-l),rhs=1ll*(b[r]-b[l])*(y-x);
    return lhs<rhs;
}

int sta[maxn],topa;
int stb[maxn],topb;

ll ans;

int main(){
    n=read(),m=read();
    for(int i=1;i<=n;++i) a[i]=read();
    for(int i=1;i<=m;++i) b[i]=read();
    sta[++topa]=1;
    for(int i=2;i<=n;++i){
        while(topa>1&&check_slope_a(sta[topa-1],sta[topa],i)) --topa;
        sta[++topa]=i;
    }
    stb[++topb]=1;
    for(int i=2;i<=m;++i){
        while(topb>1&&check_slope_b(stb[topb-1],stb[topb],i)) --topb;
        stb[++topb]=i;
    }
    int i=1,j=1;
    while(i<topa||j<topb){
        if(i==topa){
            ans+=1ll*(stb[j+1]-stb[j])*a[sta[i]];
            ++j;
        }
        else if(j==topb){
            ans+=1ll*(sta[i+1]-sta[i])*b[stb[j]];
            ++i;
        }
        else{
            if(check_slope_ab(sta[i],sta[i+1],stb[j],stb[j+1])){
                ans+=1ll*(sta[i+1]-sta[i])*b[stb[j]];
                ++i;
            }
            else{
                ans+=1ll*(stb[j+1]-stb[j])*a[sta[i]];
                ++j;
            }
        }
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：tzc_wk (赞：7)

首先我们不可能硬着头皮优化这个 DP。考虑分析一些性质，显然有的 $a_i$ 过大的行是不可能被经过的，具体来说我们考虑相邻两行 $a_{i-1},a_{i+1}$ 和某一列 $j$，从 $(i-1,j)\to(i,j)\to(i+1,j)\to(i+1,j+1)$ 的代价是 $2b_j+a_{j+1}$，$(i-1,j)\to(i-1,j+1)\to(i,j+1)\to(i+1,j+1)$ 的代价是 $2b_{j+1}+a_{j-1}$，从中间走的代价是 $b_j+b_{j+1}+a_{i}$，如果 $2a_i>a_{i+1}+a_{i-1}$，那么容易证明 $2b_j+a_{j+1}$ 和 $2b_{j+1}+a_{j-1}$ 至少有一者是 $<b_j+b_{j+1}+a_{j}$ 的。因此如果 $2a_i>a_{i+1}+a_{i-1}$ 那么第 $i$ 列就没用了。

实际上还有一个更强的结论：如果存在 $X,Y$ 使得 $a_i>a_{i-X}·\dfrac{X}{X+Y}+a_{i+Y}·\dfrac{Y}{X+Y}$ 那么 $i$ 没有用。证明也是类似。也就说有用的 $a_i$ 构成一个上凸包。$b$ 也同理。

因此我们直接保留上凸包，对于 $a,b$ 差分数组单调的情况，容易证明每一列到下一列的最优转移点是单调的，因此贪心即可。

---

## 作者：xcyyyyyy (赞：6)

upd：感谢评论区，ECEG 帮我改了几个小细节（如果错了全怪他）。

好抽象的题目，提供一个看似正常一点的思路？

考虑调整法，假设我们从 $(i,j)$ 走到 $(k,l)$，那么有两种走法：

* 先向右走，$(i,j)\rightarrow (i,l)\rightarrow (k,l)$，贡献为 $a_i\times (l-j)+b_l\times (k-i)$。
* 先向下走，$(i,j)\rightarrow (k,j)\rightarrow (k,l)$，贡献为 $b_j\times (k-i)+a_k\times (l-j)$。

假设先向右走更优（向下同理），则需要满足：
$$
\frac{a_k-a_i}{k-i}\gt \frac{b_l-b_j}{l-j}
$$
那么最优路径的每一个拐点一定都满足单调递增。

如果存在 $i \lt j\lt k,\frac{a_j-a_i}{j-i}\gt\frac{a_k-a_j}{k-j}$，如果我们走完 $i\rightarrow k$ 而是分开走，那么最优路径不可能同时满足他们与中间的竖向边的关系。所以我们只保留斜率递增的凸包即可。

保留凸包后，我们每一次只能走斜率更小的一边，否则以后一定无法满足上述限制，综上，贪心即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 100005
#define int long long
#define ll long long
int n,m;ll ans=0;
int a[N],b[N],qa[N],ra,qb[N],rb;
void solve(int a[],int n,int q[],int &r){
	q[++r]=1;q[++r]=2;
	for(int i=3;i<=n;i++){
		while(r>=2&&1ll*(a[q[r]]-a[q[r-1]])*(i-q[r])>1ll*(a[i]-a[q[r]])*(q[r]-q[r-1]))--r;
		q[++r]=i;
	}
	q[r+1]=q[r];
}
signed main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	for(int i=1;i<=m;i++)scanf("%lld",&b[i]);
	solve(a,n,qa,ra);solve(b,m,qb,rb);
	int x=1,y=1;
	while(x<ra||y<rb){
		if(y==rb||1ll*(a[qa[x+1]]-a[qa[x]])*(qb[y+1]-qb[y])<1ll*(b[qb[y+1]]-b[qb[y]])*(qa[x+1]-qa[x]))ans+=1ll*(qa[x+1]-qa[x])*b[qb[y]],++x;
		else ans+=1ll*(qb[y+1]-qb[y])*a[qa[x]],++y;
	}
	printf("%lld\n",ans);
}
```

---

## 作者：Mirasycle (赞：4)

考虑 $(l,x)\to(r,y)$ 的路径可以 $(l,x)\to (r,x)\to (r,y)$，也可以 $(l,x)\to (l,y)\to (r,y)$。

前者的代价是 $b_x(r-l)+a_r(y-x)$，后者的代价是 $a_l(y-x)+b_y(r-l)$。前者比后者更优需要满足

$$\dfrac{b_x-b_y}{x-y}<\dfrac{a_r-a_l}{r-l}$$

可以发现这可以放到两个凸包上求解。单调栈建立对于 $a,b$ 的凸包之后，每次选择斜率写的一边走。由于上述式子可以放到到任意局部，所以这是对的。

其实本质就是对于两个凸包进行闵可夫斯基和。


```cpp
#include<bits/stdc++.h>
#define pb emplace_back
#define fi first
#define se second
#define mp make_pair
using namespace std;
typedef long long ll;
const int maxn=1e6+10;
void cmax(int &x,int y){ x=x>y?x:y; }
void cmin(int &x,int y){ x=x<y?x:y; }
int n,m,a[maxn],b[maxn]; ll ans=0;
int sta[maxn],stb[maxn],ta,tb;
bool chk(int x1,int y1,int x2,int y2){ return 1ll*y1*x2<=1ll*y2*x1; }
bool cmpa(int x,int y,int z){ return chk(x-y,a[x]-a[y],y-z,a[y]-a[z]); }
bool cmpb(int x,int y,int z){ return chk(x-y,b[x]-b[y],y-z,b[y]-b[z]); }
bool cmpab(int w,int x,int y,int z){ return chk(w-x,a[w]-a[x],y-z,b[y]-b[z]); }
int main(){
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=m;i++) cin>>b[i];
	sta[ta=1]=1; stb[tb=1]=1;
	for(int i=2;i<=n;i++){
		while(ta>1&&cmpa(i,sta[ta],sta[ta-1])) ta--;
		sta[++ta]=i;
	}
	for(int i=2;i<=m;i++){
		while(tb>1&&cmpb(i,stb[tb],stb[tb-1])) tb--;
		stb[++tb]=i;
	}
	int x=1,y=1;
	while(x<ta||y<tb){
		if(x==ta){
			ans+=1ll*(m-stb[y])*a[sta[x]];
			break;
		}
		if(y==tb){
			ans+=1ll*(n-sta[x])*b[stb[y]];
			break;
		}
		if(cmpab(sta[x+1],sta[x],stb[y+1],stb[y])){
			ans+=1ll*(sta[x+1]-sta[x])*b[stb[y]];
			x++;
		}else{
			ans+=1ll*(stb[y+1]-stb[y])*a[sta[x]];
			y++; 
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：云浅知处 (赞：4)

考虑一个 $L_a\times L_b$ 的矩形，横着的两条边边权上下分别为 $a_1,a_2$，竖着的左右分别为 $b_1,b_2$，那么可以发现我们比的是 $a_1\times L_a+b_2\times L_b$ 和 $a_2\times L_a+b_1\times L_b$。做差得到
$$
(a_1-a_2)L_a+(b_2-b_1)L_b>0\iff \frac{a_1-a_2}{L_b}>\frac{b_1-b_2}{L_a}
$$
也就是说，如果 $a$ 那边的斜率更大，那么就应该先横着走；否则就竖着走。

这也就是说，最优解中的每一条折线，都应该满足，他先走的是斜率小的那一侧。

此时有一个 $O((n+m)\log (n+m))$ 的做法：每次找到全局最大的差分位置，然后消掉所有不可能的拐点。这样最后路径只会剩下一条，用 `std::set` 维护即可。[官方题解](https://www2.ioi-jp.org/camp/2022/2022-sp-tasks/contest1/kyoto-review.pdf)里有详细的图解。

事实上，考虑三个点 $(i,a_i),(j,a_j),(k,a_k)$，如果他们不形成下凸，那么 $i,j$ 之间的斜率比 $j,k$ 之间要小，也就是说如果我们某一步选择了先走 $i\to j$ 那么一定会立刻走 $j\to k$，于是我们可以直接把路径缩成 $i\to k$。于是只需要求出 $a,b$ 的下凸壳，每次走斜率小的一边即可。复杂度 $O(n+m)$。

---

## 作者：_Ch1F4N_ (赞：3)

这也太深刻了。

我第一反应是以每个极小的 L 形路径作为一个 dp 中的极小过程，不过想了一会儿不难发现做不下去。

看上去没有什么思路，主要原因是决策太多导致状态太多，尝试砍掉一些决策。

![](https://cdn.luogu.com.cn/upload/image_hosting/2t6xczx3.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

我们想在这个图中研究蓝色路是否是可以被替换的，但是你发现压根没法研究，因为情形太复杂，你需要关系青色路径的起点与终点。

考虑研究一个更小的结构上的性质，也就是下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/nomn6ufx.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

这个时候不在乎青色路径起点终点了，但是你发现蓝色路径能否被红色路径替换与青色路径所在的两列代价还是有关，如果靠前的列代价小可能还是不会替换。

考虑在这种特殊情形下研究相仿的性质，也就是考察是否存在其他能替换蓝色路径的路径。

![](https://cdn.luogu.com.cn/upload/image_hosting/pkuf1s6r.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

考虑把下面的路径也考虑上，如果蓝色路径比这两条都劣，那就不存在青色路径的影响问题了，我们可以直接认为不会走蓝色路径这一行，不断地重复这个操作，最后可以得到有用的行和列的代价都是单峰的。

但是这样还是不够做原问题，考虑再找性质。

考虑在上图中令红，蓝，黄代价分别为 $x,y,z$，长度为 $dis$，前后两条青色路径代价分别为 $A,B$，长度为 $l_1,l_2$（这里有长度是因为有一些行已经被消去了），则蓝色有存在的意义说明：

$$x \times dis + B \times (l_1+l_2) > y \times dis + A \times l_1 + B \times l_2$$

$$z \times dis + A \times (l_1+l_2) > y \times dis + A \times l_1 + B \times l_2$$

整理得：

$(x-y) \times dis > (A-B) \times l_1$。

$(z-y) \times dis > (B-A) \times l_2$。

也就是 $\frac{y-x}{l_1} < \frac{B-A}{dis} < \frac{z-y}{l_2}$。

也就是保留的行和列满足其位置与代价作为点坐标映射到平面上后，构成一个下凸壳。

到这里性质就看上去很强了，考虑做原问题。

依然考虑每次转移一个 L 行路径，我们观察满足什么性质的转移才是有用的以减少转移数。

![](https://cdn.luogu.com.cn/upload/image_hosting/9xkjit6a.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

设红色路径代价为 $x$，蓝色路径代价为 $y$，橙色路径代价为 $z$，紫色路径代价为 $w$，这四条路径分别对应点 $P_1,P_2,P_3,P_4$，横向移动距离为 $l_1$，纵向移动距离为 $l_2$。

如果向下拐更优的话，那么应当有：$z \times l_2 + y \times l_1 < x \times l_1 + w \times l_2$。

整理得到 $\frac{y-x}{l_2} < \frac{w-z}{l_1}$。

也就是从 $k_{P_1,P_2} < k_{P_3,P_4}$。

这表明我们将整个过程视作在保留的行和列上按顺序依次向后跳跃，那么跳跃的两点的斜率不减。

然而还是没有办法转移，因为一个极小 dp 过程太大，转移还是太复杂。

考虑再次拆分 L 形路径，注意到保留的行和列在某个时刻总会被经过，我们直接拆成若干个单独的点，也就是在保留的行和列上按顺序（这里不需要依次）向后**一个一个地**跳，继续观察性质，考察这个时候经过的行和列按顺序写下来是什么。

不难发现是将列构成的序列按顺序插入行构成的序列，不妨以 $N$ 代表行点，$M$ 代表列点，考虑将之前的 L 形路径的结论套过来，观察形如  $N_1,M_1,M_2,N_2,N_3,N_4,M_3,M_4$ 的点对，如果 $k_{N_1,N_2} > k_{M_2,M_3}$，那么这个序列就不如 $N_1,M_1,M_2,M_3,N_2,N_3,N_4,M_4$。

所以当你决定下一个放 $N$ 还是 $M$ 时，你一定会放扩展过去斜率更小的，不然你就可以按照上面的方法进行调整，如果两个选择斜率一样，不难发现无论放哪个，其代价与对后面的影响都一样。那么我们维护两个指针将保留的行与列扫一遍即可。

时间复杂度 $O(n+m)$。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn = 1e5+114;
int n,m,a[maxn],b[maxn];
pair<int,int> stk[maxn][2];
int ans,now[2],tp[2];
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        while(tp[0]>=2&&(a[i]-stk[tp[0]][0].second)*(stk[tp[0]][0].first-stk[tp[0]-1][0].first)<(stk[tp[0]][0].second-stk[tp[0]-1][0].second)*(i-stk[tp[0]][0].first)){
            tp[0]--;
        }
        stk[++tp[0]][0]=make_pair(i,a[i]);
    }
    for(int i=1;i<=m;i++){
        cin>>b[i];
        while(tp[1]>=2&&(b[i]-stk[tp[1]][1].second)*(stk[tp[1]][1].first-stk[tp[1]-1][1].first)<(stk[tp[1]][1].second-stk[tp[1]-1][1].second)*(i-stk[tp[1]][1].first)){
            tp[1]--;
        }
        stk[++tp[1]][1]=make_pair(i,b[i]);
    }
    now[0]=now[1]=1;
    int x=stk[now[1]][1].second,y=stk[now[0]][0].second;//两维移动代价
    for(int i=1;i<=tp[0]+tp[1]-2;i++){
        if(now[0]==tp[0]){
            ans+=(stk[now[1]+1][1].first-stk[now[1]][1].first)*y;
            now[1]++;
            x=stk[now[1]][1].second;
        }else if(now[1]==tp[1]){
            ans+=(stk[now[0]+1][0].first-stk[now[0]][0].first)*x;
            now[0]++;
            y=stk[now[0]][0].second;
        }else if((stk[now[0]+1][0].second-stk[now[0]][0].second)*(stk[now[1]+1][1].first-stk[now[1]][1].first)<(stk[now[1]+1][1].second-stk[now[1]][1].second)*(stk[now[0]+1][0].first-stk[now[0]][0].first)){
            ans+=(stk[now[0]+1][0].first-stk[now[0]][0].first)*x;
            now[0]++;
            y=stk[now[0]][0].second;
        }else{
            ans+=(stk[now[1]+1][1].first-stk[now[1]][1].first)*y;
            now[1]++;
            x=stk[now[1]][1].second;
        }
    }
    cout<<ans<<"\n";
    return 0;
}
```

---

## 作者：Lucyna_Kushinada (赞：2)

# P9521 [JOISC 2022] 京都观光

## 题意

你在 $n\times m$ 的网格上，你需要从 $(1,1)$ 出发，走到 $(n,m)$，只能向下或者向右走。

给定两个长度为 $n$ 的正整数序列 $a,b$。

设你当前位于 $(x,y)$:

- 走到 $(x,y+1)$ 的需要消耗的费用为 $a_x$。

- 走到 $(x+1,y)$ 的需要消耗的费用为 $b_y$。


求出走到 $(n,m)$ 的最小花费。

$n,m\le 10^5$。

## 题解

知识点：凸包。

好深刻的凸优化，提供一个没有非常严谨但易于理解的思路。

考虑路径的一个极小局部，设当前在 $(x_1,y_1)$，要往右下走到 $(x_2,y_2)$，满足 $x_2>x_1,y_2>y_1$。

那么分为两种走法：

- $(x_1,y_1)\to (x_1,y_2) \to (x_2,y_2)$（先右后下）。

- $(x_1,y_1)\to (x_2,y_1) \to (x_2,y_2)$（先下后右）。

因为考虑的是路径的一个极小局部的情况，所以在这里只分为两种走法。

令前者（先右后下）比后者（先下后右）花费更小，则有：

$$(y_2-y_1)a_{x_1}+(x_2-x_1)b_{y_2}<(x_2-x_1)b_{y_1}+(y_2-y_1)a_{x_2}$$

化简移项得到：

$$\frac{a_{x_2}-a_{x_1}}{x_2-x_1}>\frac{b_{y_2}-b_{y_1}}{y_2-y_1}$$

这是一个斜率的形式。

那么在最优路径中，每段路径的斜率变化都是单调递减的。

那么从 $(1,1)$ 出发，每次走斜率较小的一边即可。

注意到，对于一行或列，如果有 $i<j<k$，满足 $i\to j$ 的斜率大于 $j\to k$，显然可以直接扔掉 $j$，所以可以先用单调栈预处理出他们的下凸壳（斜率单调递增）。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define rep(i,l,r) for(int i=(l);i<=(r);++i)
#define per(i,l,r) for(int i=(r);i>=(l);--i)
#define pr pair<int,int>
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()
#define bg(x) (x).begin()
#define ed(x) (x).end()

#define N 102505
#define int long long

int n,m,a[N],b[N];
int sa[N],sb[N],ta,tb;

inline bool chk(int x,int y,int xx,int yy){
    if(!x){
        return 0;
    }
    if(!xx){
        return 1;
    }

    return y*xx<=yy*x;
}

signed main(){
    // freopen(".in","r",stdin);
    // freopen(".out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);

    cin>>n>>m;

    rep(i,1,n){
        cin>>a[i];
    }
    rep(i,1,m){
        cin>>b[i];
    }

    sa[++ta]=1;
    sb[++tb]=1;

    rep(i,2,n){
        while(ta>1&&chk(i-sa[ta],a[i]-a[sa[ta]],sa[ta]-sa[ta-1],a[sa[ta]]-a[sa[ta-1]])){
            ta--;
        }
        sa[++ta]=i;
    }

    rep(i,2,m){
        while(tb>1&&chk(i-sb[tb],b[i]-b[sb[tb]],sb[tb]-sb[tb-1],b[sb[tb]]-b[sb[tb-1]])){
            tb--;
        }
        sb[++tb]=i;
    }

    int ans=0,x=1,y=1;

    while(x<ta||y<tb){
        if(x==ta){
            ans+=(m-sb[y])*a[n];
            break;
        }
        if(y==tb){
            ans+=(n-sa[x])*b[m];
            break;
        }

        if(chk(sa[x+1]-sa[x],a[sa[x+1]]-a[sa[x]],sb[y+1]-sb[y],b[sb[y+1]]-b[sb[y]])){
            ans+=(sa[x+1]-sa[x])*b[sb[y]];
            x++;
        }
        else{
            ans+=(sb[y+1]-sb[y])*a[sa[x]];
            y++;
        }
    }

    cout<<ans<<"\n";

    return 0;
}
```

---

## 作者：TH911 (赞：2)

> [题目传送门](https://www.luogu.com.cn/problem/P12479)
>
> [广告](https://www.cnblogs.com/TH911/p/-/P9521)

# 题意分析

考虑从左上角 $(i_1,j_1)$ 走到右下角 $(i_2,j_2)$，只拐一次弯。

![](https://cdn.luogu.com.cn/upload/image_hosting/qn3po3o5.png)

有两种走法：

1. 先向右，再向下，距离为：
   
   $$
   a_{i_1}(j_2-j_1)+b_{j_2}(i_2-i_1)
   $$

2. 先向下，再向右，距离为：
   
   $$
   a_{i_2}(j_2-j_1)+b_{j_1}(i_2-i_1)
   $$
   

第 $1$ 种优于第二种当且仅当：

$$
\begin{aligned}
a_{i_1}(j_2-j_1)+b_{j_2}(i_2-i_1)&<a_{i_2}(j_2-j_1)+b_{j_1}(i_2-i_1)\\
(a_{i_1}-a_{i_2})(j_2-j_1)&<(b_{j_1}-b_{j_2})(i_2-i_1)\\
\dfrac{a_{i_1}-a_{i_2}}{i_2-i_1}&<\dfrac{b_{j_1}-b_{j_2}}{j_2-j_1}\\
\dfrac{a_{i_1}-a_{i_2}}{i_1-i_2}&>\dfrac{b_{j_1}-b_{j_2}}{j_1-j_2}\\
\end{aligned}
$$

***

因此，对于最终确定的最优路径，$(i_1,j_1)\sim(i_2,j_2)$ 的一个拐点，是拐向一条斜率小的路。

因此可以考虑删掉一些不可能成为拐点的部分，每次找最大差分即可。

找到了之后就可以删除这一行/列并更新差分。

可以使用堆或平衡树维护上述过程，链表维护删除修改即可。

***

例如对于数据：

```
6 8
3 5 1 9 4 8
3 6 7 1 8 2 5 6
```

看一下具体过程。（原图来自于[官方题解](https://www2.ioi-jp.org/camp/2022/2022-sp-tasks/contest1/kyoto-review.pdf)）

  ![](https://origin.picgo.net/2025/08/11/20250811_205155422b42cec5b2ce7c.gif)

# AC 代码

时间复杂度：$\mathcal O((n+m)\log(n+m))$。

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
typedef long long ll;
constexpr const int N=1e5,M=1e5;
int n,m;
int a[N+1],b[N+1],lst[2];
int del[2][N+1],L[2][N+1],R[2][N+1];
struct node{
	ll value;
	int size;
	int l,r,op;
};
bool operator <(node a,node b){
	return (ll)a.value*b.size<(ll)b.value*a.size;
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=m;i++){
		cin>>b[i];
	}
	priority_queue<node>q;
	for(int i=2;i<=n;i++){
		q.push({a[i]-a[i-1],1,i-1,i,0});
		L[0][i]=i-1;
		R[0][i]=i+1;
	}
	R[0][n]=0;
	for(int i=2;i<=m;i++){
		q.push({b[i]-b[i-1],1,i-1,i,1});
		L[1][i]=i-1;
		R[1][i]=i+1;
	}
	R[1][m]=0;
	lst[0]=a[n],lst[1]=b[m];
	ll ans=0;
	while(q.size()){
		node x=q.top();q.pop();
		int &op=x.op,&size=x.size,&l=x.l,&r=x.r;
		if(del[op][l]||del[op][r]){
			continue;
		}
		if(!R[op][r]){
			R[op][L[op][r]]=0;
			if(!op){
				lst[0]=a[L[0][r]];
			}
			else{
				lst[1]=b[L[1][r]];
			}
			del[op][r]=true;
			ans+=1ll*lst[op^1]*size;
		}else{
			L[op][R[op][r]]=L[op][r];
			R[op][L[op][r]]=R[op][r];
			del[op][r]=true;
			int pl=L[op][r],pr=R[op][r];
			if(!op){
				q.push({a[pr]-a[pl],pr-pl,pl,pr,0});
			}else{
				q.push({b[pr]-b[pl],pr-pl,pl,pr,1});
			}
		}
	}
	cout<<ans<<'\n';
	
	cout.flush();
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
/*
6 8
3 5 1 9 4 8
3 6 7 1 8 2 5 6
*/
```

---

## 作者：BlackHoles (赞：2)

**背景**：花了不少时间想明白，写一篇详细题解帮助其它读者，同时巩固自身理解。

### 前置知识

凸包，贪心，双指针，数学（不等式）。

### 朴素想法

对于 $H, W \le 10^3$ 的部分分，显然是一个二维的 DP，此处不做详解。时间复杂度 $O(HW)$，预期得分 $30$ 分。

### 正解

正解与 DP 几乎毫无关联，是完完全全的另一种做法。

我们考虑将最优路径分解为多个形如 $(i,l) \rightarrow (i, r) \rightarrow (j, r)$ 或者 $(i, l) \rightarrow (j, l) \rightarrow (j, r)$ 的折线段。对于每组折线段，设起点为 $(i, l)$，终点为 $(j, r)$。那么有可能的两组路径：$A : (i,l) \rightarrow (i, r) \rightarrow (j, r)$ 或者 $B : (i, l) \rightarrow (j, l) \rightarrow (j, r)$。$A$ 的时间花费是 $w_A = a_i \times (r - l) + b_r \times (j - i)$，$B$ 的花费是 $w_B = a_j \times (r - l) + b_l \times (j - i)$。根据不等式 $w_A < w_B$，化简便得到影响决策的式子。

$$
\frac{b_r - b_l}{r - l} < \frac{a_j - a_i}{j - i}
$$

于是我们根据这个公式决策即可，具体地，将 $(i, a_i)$ 和 $(j, b_j)$ 抽象成点对，每次选择斜率最小的一个方向走。

假如存在 $i, j, k$ 满足 $\frac{a_j - a_i}{j - i} < \frac{a_k - a_j}{k - j}$，那么在 $i \rightarrow j$ 后必然有 $j \rightarrow k$，于是可以将 $i \rightarrow k$ 合并为一条路径。具体地，分别维护 $a$ 和 $b$ 上的凸包，用双指针 $l, r$ 遍历凸包上的点，依次决策即可。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 100005;
int n, m;
ll a[N], b[N];
int cva[N], cvb[N], cnta, cntb; // convex of a and convex of b
ll ans;
bool check_a(int i, int j, int k) {
	return (a[j] - a[i]) * (k - j) >= (a[k] - a[j]) * (j - i);
}
bool check_b(int i, int j, int k) {
	return (b[j] - b[i]) * (k - j) >= (b[k] - b[j]) * (j - i);
}
bool check_ab(int i, int j, int k, int l) {
	return (a[j] - a[i]) * (l - k) <= (b[l] - b[k]) * (j - i);
}
int main(void) {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for (int i = 1; i <= n; ++i)
		cin >> a[i];
	for (int i = 1; i <= m; ++i)
		cin >> b[i];
	for (int i = 1; i <= n; ++i) {
		while (cnta > 1 && check_a(cva[cnta-1], cva[cnta], i))
			--cnta;
		cva[++cnta] = i;
	}
	for (int i = 1; i <= m; ++i) {
		while (cntb > 1 && check_b(cvb[cntb-1], cvb[cntb], i))
			--cntb;
		cvb[++cntb] = i; 
	}
	int l = 1, r = 1; // 双指针
	while (l < cnta || r < cntb) {
		if (l == cnta) {
			ans += (cvb[r+1] - cvb[r]) * a[cva[l]];
			++r;
			continue;
		}
		if (r == cntb) {
			ans += (cva[l+1] - cva[l]) * b[cvb[r]];
			++l;
			continue;
		}
		if (check_ab(cva[l], cva[l+1], cvb[r], cvb[r+1])) {
			ans += (cva[l+1] - cva[l]) * b[cvb[r]];
			++l;
		}
		else {
			ans += (cvb[r+1] - cvb[r]) * a[cva[l]];
			++r;
		}
	}
	cout << ans;
	return 0;
}
```

### 总结

通过这道题，我受益匪浅。

当普通方法不再可行时，不应拘泥于朴素想法的优化，而是去拓展全新的思路，避免陷入思维的漩涡，差一步就美满。

---

## 作者：周子衡 (赞：1)

提供一个和其他做法不太一样的 DP 思路。

观察到：如果我们把所有的 $(i,A_i)(1\leq i\leq H)$ 标在二维平面上，构成一个点集 $S$，那么不在 $S$ 的下凸壳上的点所对应的权值是不会出现在最短路中的。换言之，我们可以只考虑所有下凸壳上的 $A_i$。下面记这些 $A_i$ 分别为 $A_{p_1},...,A_{p_k}$，其中 $1=p_1 < \cdots < p_k=H$。$B_j$ 同理。

不妨令 $f(i,j)$ 表示到达原图中路口 $(p_i,j)$ 的最短路。我们有 $f(i,j)=\min\{f(i-1,j)+A_i,f(i,j-1)+(p_i-p_{i-1})B_j\}$。考虑逐步增大 $j$，维护所有的 $f(i,j)$。接着上面凸包的想法，容易想到去维护相邻两项的斜率 $g(i,j)=\dfrac{f(i,j)-f(i-1,j)}{p_{i}-p_{i-1}}$。可以发现，转移的时候，相当于是 $g$ 每个位置各自加上一个固定的值 $k_i=\dfrac{A_{p_i}-A_{p_i-1}}{p_i-p_{i-1}}$，然后全体元素对 $B_j$ 取最小值。又由于取的是凸包上的点，$k_i$ 单调降，进而 $g(i,j)$ 也关于 $i$ 单调降。从而，我们可以在线段树上维护所有 $g$，进而求出最后答案。总时间复杂度 $O((H+W)\log H)$。实现时注意避免使用浮点数，以免造成精度误差。

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>

using namespace std;

vector<int> V;
long long a[200000], b[200000];

long long calc(pair<long long, long long> D, int pos, long long cur) {
    return D.first * (V[pos + 1] - V[pos]) + (a[V[pos + 1]] - a[V[pos]]) * (cur - D.second);
}

struct SegmentTree {
    struct nd {
        int l, r;
        pair<long long, long long> lval, rval, tag;
    } t[1000000];
    void update(int k) {
        t[k].lval = t[k << 1].lval, t[k].rval = t[k << 1 | 1].rval;
    }
    void build(int l, int r, int k = 1) {
        t[k].l = l, t[k].r = r;
        t[k].lval = t[k].rval = t[k].tag = make_pair(0, 0);

        if (l == r)
            return;

        int mid = (l + r) >> 1;
        build(l, mid, k << 1), build(mid + 1, r, k << 1 | 1);
    }
    void add_tag(int k, pair<long long, long long> P) {
        t[k].lval = t[k].rval = t[k].tag = P;
    }
    void spread(int k) {
        if (t[k].tag.second) {
            add_tag(k << 1, t[k].tag), add_tag(k << 1 | 1, t[k].tag);
            t[k].tag.second = 0;
        }
    }
    void update(int tm, long long val, int k = 1) {
        if (val * (V[t[k].l + 1] - V[t[k].l]) <= calc(t[k].lval, t[k].l, tm)) {
            add_tag(k, make_pair(val, tm));
            return;
        }

        if (val * (V[t[k].r + 1] - V[t[k].r]) >= calc(t[k].rval, t[k].r, tm)) {
            return;
        }

        spread(k);
        update(tm, val, k << 1), update(tm, val, k << 1 | 1);
        update(k);
    }
    long long query(int tm, int pos, int k = 1) {
        if (t[k].l == t[k].r)
            return calc(t[k].lval, t[k].l, tm);

        spread(k);
        int mid = (t[k].l + t[k].r) >> 1;

        if (pos <= mid)
            return query(tm, pos, k << 1);

        return query(tm, pos, k << 1 | 1);
    }
} T;


int main() {
    int h = 0, w = 0;
    scanf("%d%d", &h, &w);

    for (int i = 1; i <= h; i++)
        scanf("%lld", &a[i]);

    for (int i = 1; i <= w; i++)
        scanf("%lld", &b[i]);

    V.push_back(1);

    for (int i = 2; i <= h; i++) {
        while (V.size() >= 2) {
            int u = V.back(), v = V[V.size() - 2];

            if ((a[u] - a[v]) * (i - u) >= (a[i] - a[u]) * (u - v))
                V.pop_back();
            else
                break;
        }

        V.push_back(i);
    }

    T.build(0, V.size() - 2);
    T.add_tag(1, make_pair(b[1], 1));

    for (int i = 2; i <= w; i++)
        T.update(i, b[i]);

    long long ans = (w - 1) * a[1];

    for (int i = 0; i < V.size() - 1; i++)
        ans += T.query(w, i);

    printf("%lld", ans);
}
```

---

## 作者：one_of_the_person (赞：0)

## 思路

![](https://cdn.luogu.com.cn/upload/image_hosting/c35dmmdl.png)

我们考虑对于这种情况，什么时候往 $(a,l) \rightarrow (b,l) \rightarrow (b,r)$ 走。先往下走比先往右走更优当且仅当 $\frac{A_b-A_a}{b-a}<\frac{B_r-B_l}{r-l}$，反之则先往右更优。若一个合法的 $\frac{A_x-A_y}{x-y}$ 足够大，使得 $\frac{A_x-A_y}{x-y}>\frac{B_r-B_l}{r-l}$ 一定成立，那么我们可以删除 $y$ 对应的一整行。

![](https://cdn.luogu.com.cn/upload/image_hosting/i87unqp9.png)

对于这个网格图我们可以发现对于 $x=4,y=5$ 可以使得 $\frac{A_x-A_y}{x-y}$ 足够大，因此我们不会在第 $5$ 行右转，也就可以认为第 $5$ 行被删除了。

![](https://cdn.luogu.com.cn/upload/image_hosting/vaxqhl94.png)

可以通过链表和优先队列实现，总复杂度 $O(n\log n)$。

## AC 代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define N 1000000
using namespace std;
struct Node{
	int v,next,prev,len;
	Node(){v=next=prev=len=0;}
};
struct Pair{
	double v;
	int id,kth;
	bool friend operator<(Pair x,Pair y){return x.v<y.v;} 
};
int n,m,la,lb,tag[N*2+5]={},ans=0,tot=0;
Node a[N*2+5];
priority_queue<Pair>q;
int read(){
	int f=1,g=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while('0'<=ch&&ch<='9'){
		g=g*10+ch-'0';
		ch=getchar();
	}
	return f*g;
}
void print(int x){
	if(x<0){
		putchar('-');
		x*=-1;
	}
	if(x>9)print(x/10);
	putchar(x%10+'0');
	return;
}
main(){
	n=read(),m=read();
	lb=n+m,la=n;
	for(int i=1;i<=n;i++)a[i].v=read(),a[i].prev=i-1;
	for(int i=1;i<=m;i++)a[i+n].v=read(),a[i+n].prev=(i==1?0:n+i-1);
	for(int i=1;i<n;i++)a[i].next=i+1,a[i].len=1,q.push({(a[i+1].v-a[i].v)*1.0,i+1,tag[i+1]=++tot});
	for(int i=1;i<m;i++)a[i+n].next=n+i+1,a[i+n].len=1,q.push({(a[n+i+1].v-a[i+n].v)*1.0,n+i+1,tag[n+i+1]=++tot});
	while(q.size()){
		while(q.size()&&tag[q.top().id]!=q.top().kth)q.pop();
		if(q.empty())break;
		if(q.top().id==la)ans+=a[a[la].prev].len*a[lb].v,la=a[la].prev;
		else if(q.top().id==lb)ans+=a[a[lb].prev].len*a[la].v,lb=a[lb].prev;
		else{
			a[a[q.top().id].prev].len+=a[q.top().id].len;
			a[a[q.top().id].prev].next=a[q.top().id].next;
			a[a[q.top().id].next].prev=a[q.top().id].prev;
			q.push({(a[a[q.top().id].next].v-a[a[q.top().id].prev].v)*1.0/a[a[q.top().id].prev].len,a[q.top().id].next,tag[a[q.top().id].next]=++tot});
		}
		q.pop();
	}
	print(ans);
	return 0;
}
```

---

## 作者：hhhqx (赞：0)

### [luogu - P9521 [JOISC2022] 京都观光](https://www.luogu.com.cn/problem/P9521)
**超級抽象的贪心题。**

简易题面：https://www.luogu.com.cn/problem/AT_joisc2022_b

考虑三种走法：设 $x<y<z$ 和 $l<r$。

- $(x,l)$ 到 $(z,l)$ 再到 $(z,r)$。
- $(x,l)$ 到 $(x,r)$ 再到 $(z,r)$。
- $(x,l)$ 到 $(y,l)$ 再到 $(y,r)$ 再到 $(z,r)$。

列出每一种走法的代价，一三比较 + 二三比较，可以得到不等式：$\frac{a_y - a_x}{y - x} < \frac{b_r - b_l}{r - l} < \frac{a_z - a_y}{z - y}$。

所以只有 $\frac{a_y - a_x}{y - x} < \frac{a_z - a_y}{z - y}$ 才可能用到第三种走法。对于 $b$ 也是一样的推导。

由于任意最优路径中间的三个 $x,y,z$ 都是第三种走法，上面的结论即：最优路径中斜率递增。

贪心地，我们只维护下凸壳，因为每个凸壳内部的点都可以被替代且更优。

只用维护 $a,b$ 的下凸壳，具体每次是走第一种还是第二种，就需要再推一下式子（直接列出来，然后不等式不断移项），得到：如果 $\frac{b_r - b_l}{r - l} < \frac{a_z - a_x}{z - x}$ 就第二种。

```cpp
#include <bits/stdc++.h>

using namespace std;
using LL = long long;
using ULL = unsigned long long;
using PII = pair<int, int>;

const int MAXN = 1e5 + 3;

int n, m;
int a[MAXN], b[MAXN];
int ha = 1, ta = 0, dqa[MAXN];
int hb = 1, tb = 0, dqb[MAXN];

bool check_a(int x, int y, int z){
	return LL(a[y] - a[x]) * (z - y) < LL(a[z] - a[y]) * (y - x);
}
bool check_b(int x, int y, int z){
	return LL(b[y] - b[x]) * (z - y) < LL(b[z] - b[y]) * (y - x);
}
bool check_ab(int i, int j, int x, int y){
	return LL(a[j] - a[i]) * (y - x) >= LL(b[y] - b[x]) * (j - i);
}

int main(){
	ios::sync_with_stdio(0), cin.tie(0);
	cin >> n >> m;
	for(int i = 1; i <= n; i++){
		cin >> a[i];
	}
	for(int i = 1; i <= m; i++){
		cin >> b[i];
	}
	for(int i = 1; i <= n; i++){
		while(ha < ta && !check_a(dqa[ta - 1], dqa[ta], i)) ta--;
		dqa[++ta] = i;
	}
	for(int i = 1; i <= m; i++){
		while(hb < tb && !check_b(dqb[tb - 1], dqb[tb], i)) tb--;
		dqb[++tb] = i;
	}
	LL ans = 0;
	while(ha < ta || hb < tb){
		if(ha == ta || (hb < tb && check_ab(dqa[ha], dqa[ha + 1], dqb[hb], dqb[hb + 1]))){
			ans += LL(dqb[hb + 1] - dqb[hb]) * a[dqa[ha]];
			hb++;
		}else{
			ans += LL(dqa[ha + 1] - dqa[ha]) * b[dqb[hb]];
			ha++;
		}
	}
	cout << ans;
	return 0;
}
```
参考题解：https://blog.csdn.net/cqbzlydd/article/details/130562472 & https://www.luogu.com.cn/article/ycf2xhx6

---


# [JOISC 2022] 错误拼写

## 题目背景

JOISC2022 D1T3

## 题目描述

从前，K 总统有着一个长度为 $N$ 的字符串 $S$，仅由小写字母组成。然而，他忘记了它。  
他还有一个词典，其中包含了各式各样的错误拼写。而他曾看过那本词典，现在他确认到 $S$ 满足以下条件：

- 令 $T_i$ $(1\le i\le N)$ 为 $S$ 删去第 $i$ 个字符并将前后字符相接所得的字符串。对于每个 $j$ $(1\le j\le M)$ 满足 $T_{A_j} \le T_{B_j}$。

其中 $T_{A_j} \le T_{B_j}$ 表示 $T_{A_j}$ 等于 $T_{B_j}$ 或 $T_{A_j}$ 在字典序上小于 $T_{B_j}$。

请写一个程序，对于 K 总统给定的如上关于 $S$ 的信息，输出可能的 $S$ 的个数，对 $10^9+7$ 取模。

## 说明/提示

**【样例解释 #1】**

举例说明，若 $S=\texttt{bab}$，则 $T_1 = \texttt{ab}, T_2 = \texttt{bb}, T_3 = \texttt{ba}$。其满足 $T_1 \le T_3$ 和 $T_3 \le T_2$。所以该 $S$ 是合法的。  
可以证明，总共有 $5876$ 种合法的 $S$。因此，输出 $5876$。

另一方面，若 $S=\texttt{aab}$，则 $T_1 = \texttt{ab}, T_2 = \texttt{ab}, T_3 = \texttt{aa}$。其不满足 $T_1 \le T_3$。所以该 $S$ 不合法。

该样例满足所有子任务的限制。

**【样例解释 #2】**

该样例满足子任务 $1,2,4,5$ 的限制。

**【样例解释 #3】**

取模前的结果为 $824\,206\,295\,601$，所以输出 $206\,289\,833$。

该样例满足子任务 $1,2,4,5$ 的限制。

**【样例解释 #4】**

该样例满足所有子任务的限制。

**【样例解释 #5】**

该样例满足所有子任务的限制。

**【数据范围】**

对于所有数据，满足：

- $2 \le N \le 500\,000$。  
- $1 \le M \le 500\,000$。
- $1 \le A_j,B_j \le N$ $(1 \le j \le M)$。
- $A_j\ne B_j$ $(1 \le j \le M)$。
- $(A_j,B_j)\ne(A_k,B_k)$ $(1 \le j < k \le M)$。

详细子任务附加限制及分值如下表所示：

|子任务编号|附加限制|分值|
|:-:|:-:|:-:|
|$1$|$N \le 10$|$8$|
|$2$|$N \le 200$|$20$|
|$3$|存在 $\{1,2,\dots,N\}$ 的排列 $P$ 满足 $A_j = P_j, B_j = P_{j+1}$ $(1 \le j \le M=N-1)$|$29$|
|$4$|$N \le 20\,000$|$32$|
|$5$|无附加限制|$11$|

## 样例 #1

### 输入

```
3 2
1 3
3 2```

### 输出

```
5876```

## 样例 #2

### 输入

```
5 6
1 2
1 5
2 4
5 4
5 3
4 3```

### 输出

```
656981```

## 样例 #3

### 输入

```
10 9
3 6
4 6
6 7
7 9
10 8
9 8
8 5
5 2
5 1```

### 输出

```
206289833
```

## 样例 #4

### 输入

```
7 6
1 3
3 4
4 6
6 5
5 7
7 2```

### 输出

```
7125651```

## 样例 #5

### 输入

```
5 4
2 4
4 3
3 5
5 1```

### 输出

```
61451```

# 题解

## 作者：Alex_Wei (赞：12)

### [P9522 [JOISC2022] 错误拼写](https://www.luogu.com.cn/problem/P9522)

考虑 $T_{i}\leq T_{j}$ 的等价条件。模拟字典序比较的过程：

- 若 $i < j$，那么要么 $s_{i\sim j}$ 全部相等，要么 $s_i > s_p$，其中 $p$ 是从 $i$ 开始第一个不等于 $s_i$ 的位置。
- 若 $i > j$，那么要么 $s_{j\sim i}$ 全部相等，要么 $s_j < s_p$，其中 $p$ 是从 $j$ 开始第一个不等于 $s_j$ 的位置。

考虑从后往前 DP，设 $f_{i, j}$ 表示 $s_i = j$ 的方案数。计算 $f_{i, j}$ 时，枚举 $i'$ 表示 $s_{i\sim i' - 1}$ 相等且 $s_{i' - 1}\neq s_{i'}$，枚举 $j'\neq j$。考虑什么情况下 $f_{i, j}$ 可以从 $f_{i', j'}$ 转移过来：如果存在 $i\leq u < i' \leq v$ 要求 $T_u\leq T_v$，那么 $j$ 不能小于 $j'$；若要求 $T_u\geq T_v$，那么 $j$ 不能大于 $j'$。

设 $u < v$，则：

- 当有限制 $T_u\leq T_v$ 时，在 $u < i'\leq v$ 转移到 $u$ 之前的位置时，必须有 $j > j'$。

- 当有限制 $T_u\geq T_v$ 时，在 $u < i'\leq v$ 转移到 $u$ 之前的位置时，必须有 $j < j'$。

这说明，固定了 $i'$ 之后，随着 $i$ 不断向前移动，存在一个时刻使得 $i'$ 不再能产生 $j > j'$ 的贡献，也存在一个时刻使得 $i'$ 不再能产生 $j < j'$ 的贡献。

设 $h_j$ 表示 $f_{i + 1}\sim f_n$ 对之前的位置的每个 $j$ 产生的贡献。枚举到 $i$ 时，考虑所有和 $i$ 有关的限制 $(u, v)$（$u = i < v$）

- 若限制 $T_u\leq T_v$，那么对于所有 $u < i'\leq v$ 且仍产生 $j < j'$ 的贡献的 $i'$，将它 $j < j'$ 的贡献从 $h$ 中去掉，即令 $h_j$ 减去 $\sum_{j < j'} f_{i', j'}$。
- 若限制 $T_u\geq T_v$，那么对于所有 $u < i' \leq v$ 且仍产生 $j > j'$ 的贡献的 $i'$，将它 $j > j'$ 的贡献从 $h$ 中去掉，即令 $h_j$ 减去 $\sum_{j > j'} f_{i', j'}$。

更新 $h$ 之后有 $f_{i, j} = h_j + 1$，其中 $1$ 表示 $s_{i\sim n}$ 均相等的情况。统计 $f_i$ 对 $h$ 的贡献：$h_{j}$ 加上 $\sum_{j'\neq j} f_{i, j'}$。

用链表或栈维护两种情况仍产生贡献的 $i'$，时间复杂度 $\mathcal{O}(n|\Sigma|)$。

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = long long;
using LL = __int128_t;
using ui = unsigned int;
using ull = unsigned long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using pdi = pair<double, int>;

#define ppc(x) __builtin_popcount(x)
#define clz(x) __builtin_clz(x)

bool Mbe;
// mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());
mt19937 rnd(20060130);
int rd(int l, int r) {return rnd() % (r - l + 1) + l;}

constexpr int mod = 1e9 + 7;
void addt(int &x, int y) {x += y, x >= mod && (x -= mod);}
int add(int x, int y) {return x += y, x >= mod && (x -= mod), x;}

char buf[1 << 20], *p1 = buf, *p2 = buf;
#define getc() (p1 == p2 && (p2 = (p1 = buf) + \
  fread(buf, 1, 1 << 20, stdin), p1 == p2) ? EOF : *p1++)
inline int read() {
  int x = 0;
  char s = getc();
  while(!isdigit(s)) s = getc();
  while(isdigit(s)) x = x * 10 + s - '0', s = getc();
  return x;
}

#define putc(x) putchar(x)
inline void print(ui x) {
  if(x >= 10) print(x / 10);
  putc(x % 10 + '0');
}

// ---------- templates above ----------

constexpr int N = 5e5 + 5;

int n, m, f[N][27], h[27];
int a[N], b[N], x[N], y[N];
vector<int> e[N], g[N];

void mian() {
  cin >> n >> m;
  for(int i = 1; i <= n; i++) a[i] = b[i] = i + 1;
  for(int i = 1; i <= m; i++) {
    int x, y;
    cin >> x >> y;
    if(x < y) e[x].push_back(y);
    else g[y].push_back(x);
  }
  for(int i = n; i; i--) {
    for(int it : e[i]) {
      for(int p = a[i]; p <= it; p = a[p]) {
        vector<int> s(27);
        for(int j = 1; j <= 26; j++) s[j] = add(s[j - 1], f[p][j]);
        for(int j = 1; j <= 26; j++) addt(h[j], mod - add(s[26], mod - s[j]));
        a[i] = a[p];
      }
    }
    for(int it : g[i]) {
      for(int p = b[i]; p <= it; p = b[p]) {
        vector<int> s(27);
        for(int j = 1; j <= 26; j++) s[j] = add(s[j - 1], f[p][j]);
        for(int j = 1; j <= 26; j++) addt(h[j], mod - s[j - 1]);
        b[i] = b[p];
      }
    }
    int sum = 0;
    for(int j = 1; j <= 26; j++) {
      f[i][j] = h[j] + 1;
      addt(h[j], mod - f[i][j]);
      addt(sum, f[i][j]);
    }
    if(i == 1) cout << sum << "\n";
    for(int j = 1; j <= 26; j++) addt(h[j], sum);
  }
}

bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  #ifdef ALEX_WEI
    FILE* IN = freopen("1.in", "r", stdin); 
    FILE* OUT = freopen("1.out", "w", stdout);
  #endif
  int T = 1;
  while(T--) mian();
  fprintf(stderr, "%d ms\n", int(1e3 * clock() / CLOCKS_PER_SEC));
  return 0;
}

/*
g++ a.cpp -o a -std=c++14 -O2 -DALEX_WEI
*/
```

---

## 作者：云浅知处 (赞：7)

首先，当 $i<j$ 时，$T_i\le T_j$ 等价于 $s[i+1,j]\le s[i,j-1]$。

也就是说，区间 $[i,j-1]$ 内第一个满足 $s_k\neq s_{k+1}$ 的位置 $k$ 需要满足 $s_k\ge s_{k+1}$。

另一方面，如果 $i>j$，那么相当于区间 $[j,i-1]$ 内第一个满足 $s_k\neq s_{k+1}$ 的位置 $k$ 满足 $s_k\le s_{k+1}$。

称 $i<j$ 的限制 $T_i\le T_j$ 为第一类约束区间 $[i,j-1]$，否则为第二类约束区间 $[j,i-1]$。

直接记录 $f(i,j)$ 表示前 $i$ 个字符，$s_i=j$ 的方案数。转移时，我们分三种情况讨论：

- $s_i=s_{i+1}$：此时没有约束，直接转移 $f(i,j)\to f(i+1,j)$。
- $s_i>s_{i+1}$：枚举上一个 $s_k\neq s_{k+1}$ 的位置 $k$，那么要求 $i$ 能满足所有 $l>k,r\ge i$ 的 $[l,r]$ 的约束，也就是不能存在第二类约束区间，满足 $k<l\le i,r\ge i$。合法的 $k$ 是一段后缀，可以拿 set 简单维护得到这段后缀。得到合法后缀之后有 $f(k+1,j)-f(k,j)\to f(i+1,[x<j])$，可以简单做到 $O(1)$ 转移。
- $s_i<s_{i+1}$：类似。

综上，总复杂度 $O(n|\Sigma|+n\log n)$，其中 $|\Sigma|=26$。

```cpp
#include<bits/stdc++.h>

#define ll long long
#define mk make_pair
#define fi first
#define se second

using namespace std;

inline int read(){
	int x=0,f=1;char c=getchar();
	for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
	for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
	return x*f;
}

const int mod=1e9+7;
int ksm(int x,ll y,int p=mod){
	int ans=1;y%=(p-1);
	for(int i=y;i;i>>=1,x=1ll*x*x%p)if(i&1)ans=1ll*ans*x%p;
	return ans%p;
}
int inv(int x,int p=mod){return ksm(x,p-2,p)%p;}
mt19937 rnd(time(0));
int randint(int l,int r){return rnd()%(r-l+1)+l;}
void add(int &x,int v){x+=v;if(x>=mod)x-=mod;}
void Mod(int &x){if(x>=mod)x-=mod;}
int cmod(int x){if(x>=mod)x-=mod;return x;}

template<typename T>void cmax(T &x,T v){x=max(x,v);}
template<typename T>void cmin(T &x,T v){x=min(x,v);}

const int N=5e5+5;
const int D=26;
int f[N][D],n,m;
vector<int>L1[N],L2[N],R1[N],R2[N];
multiset<int>S1,S2;

signed main(void){

#ifndef ONLINE_JUDGE
	freopen("in.in","r",stdin);
#endif

	n=read(),m=read();
	for(int i=1;i<=m;i++){
		int l=read(),r=read();
		if(l<r)L1[l].emplace_back(r-1),R1[r-1].emplace_back(l);
		else L2[r].emplace_back(l-1),R2[l-1].emplace_back(r);
	}
	
	S1.insert(0),S2.insert(0);
	for(int i=0;i<D;i++)f[1][i]=1;
	for(int j:L1[1])S1.insert(1);
	for(int j:L2[1])S2.insert(1);
	for(int i=2;i<=n;i++){
		vector<int>g(D);int k=0,sum=0;
		for(int j=0;j<D;j++)add(f[i][j],f[i-1][j]);
		
		// s[i-1] > s[i]
		
		k=*--S2.end(),sum=0;
		for(int j=0;j<D;j++)g[j]=cmod(f[i-1][j]+mod-f[k][j]);
		for(int j=D-1;j>=0;j--)add(f[i][j],sum),add(sum,g[j]);
		
		// s[i-1] < s[i]
		
		k=*--S1.end(),sum=0;
		for(int j=0;j<D;j++)g[j]=cmod(f[i-1][j]+mod-f[k][j]);
		for(int j=0;j<D;j++)add(f[i][j],sum),add(sum,g[j]);
		
		for(int j:R1[i-1])S1.erase(S1.find(j));
		for(int j:R2[i-1])S2.erase(S2.find(j));
		for(int j:L1[i])S1.insert(i);
		for(int j:L2[i])S2.insert(i);
	}
	
	int ans=0;
	for(int j=0;j<D;j++)add(ans,f[n][j]);
	cout<<ans<<endl;

	return 0;
}
```

---

## 作者：UKE_Automation (赞：2)

### P9522 [JOISC 2022] 错误拼写

[$\text{Link}$](https://www.luogu.com.cn/problem/P9522)

分析一下题目中给出的条件 $T_{A_j}\le T_{B_j}$，我们先假设 $A_j< B_j$，那么这个条件的含义就是在区间 $[A_j,B_j]$ 中，第一个不满足 $s_i=s_{i+1}$ 的 $i$ 满足 $s_i>s_{i+1}$；否则的话就是反过来，表示在区间 $[B_j,A_j]$ 中第一个不满足的 $i$ 满足 $s_i<s_{i+1}$。

我们把两种约束条件分开看，分别叫第一类约束和第二类约束。接下来直接 dp，设 $dp(i,j)$ 表示枚举到第 $i$ 位，当前字符为 $j$ 的方案数。观察到上面的约束条件实际上只关注连续段的交界处的字符大小关系，所以转移的时候我们也只需要考虑连续段即可。接下来分类讨论：

- 当 $s_i=s_{i+1}$ 时，显然这样填不会影响任何约束条件，直接转移即可：$dp(i+1,j)\leftarrow dp(i,j)$。

- 当 $s_{i}> s_{i+1}$ 时，此时说明我们的一个连续段结束了，枚举上一个连续段的结尾 $k$，则当前连续段就是 $[k+1,i]$。由于 $s_{i}>s_{i+1}$，所以说明如果一个约束条件 $[l,r]$ 如果满足 $l\in [k+1,i],r\in [i+1,n]$，那么它必须是第一类约束。

  换句话来讲，对于所有满足 $r\ge i+1,l\le i$ 的第二类约束，$k+1$ 都要小于 $l$。那么不难发现所有合法的 $k$ 构成了一段区间，设其为 $[p,i-1]$，这个可以用 `set` 维护出来。

  然后考虑转移，由于 $s_i>s_{i+1}$，所以枚举 $s_{i+1}$ 为 $x$，那么转移就是 $dp(i+1,x)\leftarrow \sum dp(k+1,j)-dp(k,j)$。由于 $k$ 构成一段区间，所以中间的 dp 值应该全部消掉了，所以最后的转移就是 $dp(i+1,x)\leftarrow dp(i,j)-dp(p,j)$。再用后缀和优化一下就可以做到 $O(|\Sigma|)$ 转移了。

- 当 $s_i<s_{i+1}$ 时，与第二类情况类似，不再赘述。

于是我们可以在 $O(n|\Sigma|+n\log n)$ 的复杂度内完成这个 dp，可以通过。

```cpp
#include <bits/stdc++.h>
#define il inline

using namespace std;

const int Maxn = 5e5 + 5;
const int Inf = 2e9;
const int Mod = 1e9 + 7;
il int Add(int x, int y) {return x + y >= Mod ? x + y - Mod: x + y;} il void pls(int &x, int y) {x = Add(x, y);}
il int Del(int x, int y) {return x - y < 0 ? x - y + Mod : x - y;} il void sub(int &x, int y) {x = Del(x, y);}
il int max(int x, int y) {return x >= y ? x : y;} il void chkmax(int &x, int y) {x = (x >= y ? x : y);}
il int min(int x, int y) {return x <= y ? x : y;} il void chkmin(int &x, int y) {x = (x <= y ? x : y);}
il int qpow(int a, int b) {int res = 1; for(; b; a = 1ll * a * a % Mod, b >>= 1) if(b & 1) res = 1ll * res * a % Mod; return res;}
il int Inv(int a) {return qpow(a, Mod - 2);}
template <typename T>
il void read(T &x) {
	x = 0; char ch = getchar(); bool flg = 0;
	for(; ch < '0' || ch > '9'; ch = getchar()) flg = (ch == '-');
	for(; ch >= '0' && ch <= '9'; ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48);
	flg ? x = -x : 0;
}
template <typename T>
il void write(T x, bool typ = 1) {
	static short Stk[50], Top = 0;
	x < 0 ? putchar('-'), x = -x : 0;
	do Stk[++Top] = x % 10, x /= 10; while(x);
	while(Top) putchar(Stk[Top--] | 48);
	typ ? putchar('\n') : putchar(' ');
}
il void IOS() {ios::sync_with_stdio(0); cin.tie(0), cout.tie(0);}
il void File() {freopen("in.txt", "r", stdin); freopen("out.txt", "w", stdout);}
bool Beg;

int n, m;
int dp[Maxn][26], g[26];
vector <int> l1[Maxn], l2[Maxn];
int sz1[Maxn], sz2[Maxn];
multiset <int> s1, s2;

bool End;
il void Usd() {cerr << (&Beg - &End) / 1024.0 / 1024.0 << "MB " << (double)clock() * 1000.0 / CLOCKS_PER_SEC << "ms\n"; }
int main() {
	read(n), read(m);
	for(int i = 1, a, b; i <= m; i++) {
		read(a), read(b);
		if(a < b) sz1[a]++, l1[b].push_back(a);
		else sz2[b]++, l2[a].push_back(b);
	}
	s1.insert(0), s2.insert(0);
	for(int i = 0; i < 26; i++) dp[1][i] = 1;
	for(int i = 1; i < n; i++) {
		for(int j = 1; j <= sz1[i]; j++) s1.insert(i);
		for(int j = 1; j <= sz2[i]; j++) s2.insert(i);
		int k = *(--s2.end()), sm = 0;
		for(int j = 0; j < 26; j++) g[j] = Del(dp[i][j], dp[k][j]);
		for(int j = 25; j >= 0; j--) pls(dp[i + 1][j], sm), pls(sm, g[j]);
		k = *(--s1.end()), sm = 0;
		for(int j = 0; j < 26; j++) g[j] = Del(dp[i][j], dp[k][j]);
		for(int j = 0; j < 26; j++) pls(dp[i + 1][j], sm), pls(sm, g[j]);
		for(int j = 0; j < 26; j++) pls(dp[i + 1][j], dp[i][j]);
		for(auto j : l1[i + 1]) s1.erase(s1.find(j));
		for(auto j : l2[i + 1]) s2.erase(s2.find(j));
	}
	int ans = 0;
	for(int i = 0; i < 26; i++) pls(ans, dp[n][i]);
	write(ans);
	Usd();
	return 0;
}
```

---

## 作者：Erine (赞：2)

实在是绷不住了，做 JOISC 做到梦熊炼石原题，这下这下了。

限制 $T_u\le T_v\ (u<v)$ 告诉你啥呢，告诉你这 $[u, v]$ 这个区间要么全部相等，要么第一个相邻不同的位置是左边大于右边；$u>v$ 就是反过来，要么相等要么第一个相邻不同的位置左边小于右边。

考虑 dp，$f_{i,j}$ 表示考虑了 $[i,n]$，$i$ 这个位置填的 $j$ 这个字符。如果暴力转移就是枚举下一个不同的位置，判断合不合法并计算贡献。复杂度是 $\Theta(n^2\Sigma)$。

你去想判断合不合法的过程是怎么样的，就是把所有左端点 $\ge i$ 的限制区间全扔下标上，进行一个判断。那我们发现你 $i$ 从右边来的时候，会增加一部分区间，改变一些位置的限制条件（即转移方式）。具体地，一个位置被转移的方式有：

- 不被覆盖
- 仅被 $u<v$ 的覆盖
- 仅被 $u>v$ 的覆盖
- 被两者同时覆盖

然后发现每个点的状态最多被改变 $2$ 次。我们只要快速找到哪些点的覆盖状态发生了改变，用 set 维护每种状态的位置即可。复杂度 $\Theta(n(\log n+\Sigma))$。

```cpp
signed main() {
	n = read(), m = read();
	rep(i, 1, m) {
		int x = read(), y = read(), f = 0;
		if (x == y) continue;
		if (x > y) swap(x, y), f ^= 1;
		p[x].push_back({y, f});
	}
	rep(j, 0, 25) f[n][j] = 1, ge[j] = 1;
	se.insert(n);
	per(i, n - 1, 1) {
		for (pii j : p[i]) {
			int l = i, r = j.fs, fl = j.sc;
			if (fl) {
				auto it = se.lower_bound(l + 1);
				while (it != se.end() && *it <= r) {
					s1.insert(*it);
					rep(k, 0, 25) g1[k] += f[*it][k], ge[k] -= f[*it][k];
					se.erase(it++);
				}
				it = s0.lower_bound(l + 1);
				while (it != s0.end() && *it <= r) {
					s2.insert(*it);
					rep(k, 0, 25) g0[k] -= f[*it][k];
					s0.erase(it++);
				}
			} else {
				auto it = se.lower_bound(l + 1);
				while (it != se.end() && *it <= r) {
					s0.insert(*it);
					rep(k, 0, 25) g0[k] += f[*it][k], ge[k] -= f[*it][k];
					se.erase(it++);
				}
				it = s1.lower_bound(l + 1);
				while (it != s1.end() && *it <= r) {
					s2.insert(*it);
					rep(k, 0, 25) g1[k] -= f[*it][k];
					s1.erase(it++);
				}
			}
		}
		int s = 0;
		rep(j, 0, 25) (s += ge[j]) %= mod;
		rep(j, 0, 25) f[i][j] += (s - ge[j] % mod + mod) % mod;
		s = 0;
		per(j, 25, 0) {
			(f[i][j] += s) %= mod;
			(s += g0[j] % mod) %= mod;
		}
		s = 0;
		rep(j, 0, 25) {
			(f[i][j] += s) %= mod;
			(s += g1[j]) %= mod;
		}
		rep(j, 0, 25) f[i][j]++, f[i][j] %= mod;
		se.insert(i);
		rep(j, 0, 25) ge[j] += f[i][j];
	}
	int ans = 0;
	rep(j, 0, 25) (ans += f[1][j]) %= mod;
	write(ans);
    return 0;
}
```

---

## 作者：SDLTF_凌亭风 (赞：2)

今天上午考了这题，我来补一下题。

又是一个 DP 题。把题目意思抽象一下，就是要求从 $s_l$ 开始找一段最长的相等字符，在此之后接的第一个字符（显然是和前面那一长串不相等的）比它大或比它小。

感觉有点恶心，似乎还得弄点奇奇怪怪的优化，但是字符集只有小写字母，赢！直接莽它！

按照题意，令 $f_{i,\ j}$ 表示从 $i$ 开始的后缀中 $s_i = j$ 的方案数。

如果一长串相等字符之后，第一次出现不相等的位置假设在 $k$，那么对于任意一个区间，如果它的左端点在 $[i,\ k)$ 之间，右端点一定得在 $k$ 左边。

简而言之，不能有一个区间穿过 $k$。

于是倒着跑 DP，维护方法很多，比如并查集小根堆之类都可以维护。记整个字符集大小为 $\Sigma$，则复杂度为 $O(n|\Sigma|+n\log n)$ 完全可行。

给出部分关键代码如下：

```cpp
floop(i, 1, m) {
	cin >> a >> b;
	if(a < b) pos[a][0] = max(pos[a][0], b);
	else 	  pos[b][1] = max(pos[b][1], a);
}
froop(i, n, 1) {
	while(TP1 && PS1 >= SK1[TP1]) { floop(j, 0, 25) s[0][j] -= f[SK1[TP1]][j]; -- TP1; }
	while(TP2 && PS2 >= SK2[TP2]) { floop(j, 0, 25) s[1][j] -= f[SK2[TP2]][j]; -- TP2; }
	floop(j, 0, SGM_SIZE) temp[0][j] = (j ? temp[0][j - 1] : 0) + s[0][j], temp[1][j] = (j ? temp[1][j - 1] : 0) + s[1][j];
	floop(j, 0, SGM_SIZE) f[i][j]    = temp[0][25] - temp[0][j] + (j ? temp[1][j - 1] : 0) + 1;
	floop(j, 0, SGM_SIZE) s[0][j]   += f[i][j], s[1][j] += f[i][j];
	SK1[++ TP1] = SK2[++ TP2] = i;
}
```

---

## 作者：2huk (赞：1)

显然可以转化成：

- $A < B$：$S_{A+1\sim B} < S_{A\sim B-1}$；
- $A>B$：$S_{B \sim A - 1} < S_{B+1\sim A}$。

我们第一种情况为例。

$S_{A+1 \sim B} < S_{A \sim B - 1}$，相当于从 $A$ 开始，第一个不满足 $S_i \ne S_{i+1}$ 一定是 $S_i > S_{i-1}$。

于是朴素的想法是 $\mathcal O(3^n n |\Sigma|)$，爆搜每两个位置之间的 $<,>,=$ 关系，然后 DP 处理方案数。

考虑正解。设 $f(i, j)$ 表示考虑前 $i$ 个位置，且 $S_i=j$ 的方案数。

第一个转移是 $f(i-1,j)$。

然后枚举 $S_{i-1}=k \ne j$ 以及以 $i-1$ 结尾的极长连续段 $[p,i-1]$。我们思考 $S_{i-1}=k,S_i=j$ 能否满足所有与其有关的条件。如果满足就能从 $f(p, k)$ 转移过来。

对于一个限制 $A_i = u, B_i = v$（$u < v$，其余情况类似）。如果 $p \le u \le i - 1$ 且 $v \ge i-1$，那么这个限制就和 $(i-1,i)$ 是有关的。具体的，由于 $i-1$ 之前全是 $=$，所以我们只需要判断 $j,k$ 的大小关系是否是这个 $i$ 限制所要求的（因为 $(i-1,i)$ 是第一个满足不是 $=$ 的）。

注意直接 $f(p, k) \to f(i,j)$ 会转移重复，因为我们没有体现出 $[p,i-1]$ 是极长的这一点。所以状态再加一维 $0/1$ 表示是否 $S_{i-1}\ne S_i$。

暴力实现上述过程代码：<https://www.luogu.com.cn/paste/h7k2fk9q>

优化不是很困难，相信来做本题的读者有能力完成。

AC 代码：<https://www.luogu.com.cn/paste/85m5mr8j>

---

## 作者：tzc_wk (赞：1)

首先对于 $a<b$，$T_a\le T_b$ 等价于要么 $a$ 所在连续段包含 $b$，要么 $a$ 所在连续段下一个连续段的字符 $<s_a$。对于 $a>b$ 的情况也是类似的。因此考虑 $dp_{i,j}$ 表示有多少个 $s[i...n]$ 满足 $s_i=j$ 且 $i$ 是一个连续段的开头元素的方案数。转移就分 $i$ 是最后一个连续段、$i$ 下一个连续段比 $i$ 小和比 $i$ 大三种情况处理。第一种情况方案数显然是 $1$，第二种情况考虑所以可能成为下一个连续段的点 $j$，显然要求不存在限制 $(a,b)$ 满足 $i\le b\le j<a$，然后用后缀和优化。使用并查集模拟删点即可。第三种情况也是同理。

时间复杂度 $26n+n\alpha(n)$。

---


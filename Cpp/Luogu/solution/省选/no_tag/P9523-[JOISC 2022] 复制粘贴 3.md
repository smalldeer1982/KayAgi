# [JOISC 2022] 复制粘贴 3

## 题目背景

JOISC2022 D2T1

## 题目描述

JOI 公司是一家以“没啥用发明”而闻名的公司。最近，JOI 公司开发了一款名为“没啥用编辑器”的编辑器。

在这个编辑器中，可以执行如下几种操作来输入某个字符串，设 $X$ 为屏幕上的字符串，$Y$ 为剪切板中的字符串，初始均为空串：

- 操作 A：输入字符 $c$，即将 $X$ 更新为 $X+c$。
- 操作 B：选择所有字符并剪切，即将 $Y$ 更新为 $X$，并将 $X$ 置为空串。
- 操作 C：将剪切板中的字符串粘贴到当前字符串末尾，即将 $X$ 更新为 $X+Y$。

对于字符串或字符 $x,y$，$x+y$ 表示将 $x$ 和 $y$ 顺次拼接得到的结果。使用一次操作 A,B,C 分别要花费 $A,B,C$ 单位时间。

你安装了“没啥用编辑器”，并想要尽可能快地输入一个长度为 $N$ 的字符串 $S$。

你需要计算出最少需要花费多少时间。

## 说明/提示

**【样例解释 #1】**

以下是一组最优操作：

| 轮次 | 操作 | 解释 | $X$ | $Y$ | 代价 | 总时间 |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| - | - | - | `""` | `""` | - | $0$ |
| $1$ | 操作 A | 输入字符 | `"s"` | `""` | $10$ | $10$ |
| $2$ | 操作 B | 全选并剪切 |` ""` | `"s"`| $5$ | $15$ |
| $3$ | 操作 C | 在尾部粘贴 | `"s"` | `"s"`| $2$ | $17$ |
| $4$ | 操作 C | 在尾部粘贴 | `"ss"` | `"s"`| $2$ | $19$ |
| $5$ | 操作 A | 输入字符 | `"ssi"` | `"s"`| $10$ | $29$ |
| $6$ | 操作 B | 全选并剪切 |` ""` | `"ssi"`| $5$ | $34$ |
| $7$ | 操作 A | 输入字符 | `"m"` | `"ssi"`| $10$ | $44$ |
| $8$ | 操作 A | 输入字符 | `"mi"` | `"ssi"`| $10$ | $54$ |
| $9$ | 操作 C | 在尾部粘贴 | `"missi"` | `"ssi"`| $2$ | $56$ |
| $10$ | 操作 C | 在尾部粘贴 | `"mississi"` | `"ssi"`| $2$ | $58$ |
| $11$ | 操作 A | 输入字符 | `"mississip"` | `"ssi"`| $10$ | $68$ |
| $12$ | 操作 A | 输入字符 | `"mississipp"` | `"ssi"`| $10$ | $78$ |
| $13$ | 操作 A | 输入字符 | `"mississippi"` | `"ssi"`| $10$ | $88$ |

这组样例满足子任务 $3,4,5,6$ 的限制。

**【样例解释 #2】**

一组最优策略如下：

| 轮次 | 操作 | 解释 | $X$ | $Y$ | 代价 | 总时间 |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| - | - | - | `""` | `""` | - | $0$ |
| $1$ | 操作 A | 输入字符 | ` "a"` | `""` | $1$ | $1$ |
| $2$ | 操作 A | 输入字符 | ` "aa"` | `""` | $1$ | $2$ |
| $3$ | 操作 A | 输入字符 | ` "aaa"` | `""` | $1$ | $3$ |
| $4$ | 操作 A | 输入字符 | ` "aaaa"` | `""` | $1$ | $4$ |
| $5$ | 操作 B | 全选并剪切 | `""` | `"aaaa"` | $1$ | $5$ |
| $6$ | 操作 C | 在尾部粘贴 | `"aaaa"` | `"aaaa"` | $1$ | $6$ |
| $7$ | 操作 C | 在尾部粘贴 | `"aaaaaaaa"` | `"aaaa"` | $1$ | $7$ |
| $8$ | 操作 C | 在尾部粘贴 | `"aaaaaaaaaaaa"` | `"aaaa"` | $1$ | $8$ |
| $9$ | 操作 C | 在尾部粘贴 | `"aaaaaaaaaaaaaaaa"` | `"aaaa"` | $1$ | $9$ |

这组样例满足子任务 $2,3,4,5,6$ 的限制。

**【样例解释 #3】**

这组样例满足子任务 $3,4,5,6$ 的限制。

**【数据范围】**

对于所有数据，满足：

- $1\leq N\leq 2500$
- $S$ 是一个长度为 $N$ 的小写字母串。
- $1\leq A,B,C\leq 10^9$

详细子任务附加限制及分值如下表所示：

|子任务编号|附加限制|分数|
|:-:|:-:|:-:|
|$1$|$N=3$|$1$|
|$2$|$S$ 只包含字符 $\texttt a$|$5$|
|$3$|$N\le 30$|$14$|
|$4$|$N\le 200$|$10$|
|$5$|$N \le 1000$|$32$|
|$6$|无附加限制|$38$|

## 样例 #1

### 输入

```
11
mississippi
10
5
2```

### 输出

```
88```

## 样例 #2

### 输入

```
16
aaaaaaaaaaaaaaaa
1
1
1```

### 输出

```
9```

## 样例 #3

### 输入

```
18
aababbbababbbaabbb
1000000000
100000
10000000```

### 输出

```
8060200000```

# 题解

## 作者：shinkuu (赞：17)

先 orz oyds。但是为什么没有 oyds 的简单预处理做法啊。

区间 dp。$dp_{i,j}$ 表示凑出区间 $[i,j]$ 的最小代价。考虑枚举当前区间 $[i,j]$ 与 $k$，找到一个最大的 $p$，使得 $[i,j]$ 在区间 $[p,j]$ 中不重叠地出现了 $k$ 次。则有转移：

$$dp_{p,j}\leftarrow\min(dp_{p,j},dp_{i,j}+B+k\times C+(j-p+1-k\times len)\times A)$$

以及最基本的：

$$dp_{i,j}\leftarrow\min(dp_{i+1,j}+A,dp_{i,j-1}+A,dp_{i,j})$$

这部分复杂度为 $O(\sum\frac{n}{j-i+1})=O(n^2\ln n)$。

现在就要考虑怎么找这个 $k$ 对应的 $p$。考虑 dp 求出 $S$ 每两个后缀的 $\operatorname{lcp}$，然后处理出对于一对 $(i,k)$ 的最大的 $j<i$，使得 $\operatorname{lcp}(S[i:n],S[j:n])\ge k$。这个东西可以先记录 $=k$ 的情况，然后求后缀最大值。注意此处由于两个串不能重叠，所以预处理时令 $\operatorname{lcp}(S[i:n],S[j:n])\le i-j$。

这部分 $O(n^2)$。

简单好写。

code：

```cpp
int n,m,lcp[N][N],pre[N][N];
ll A,B,C,dp[N][N];
char s[N];
void Yorushika(){
	scanf("%d%s%lld%lld%lld",&n,s+1,&A,&B,&C);
	drep(i,n,1){
		drep(j,i-1,1){
			lcp[i][j]=s[i]==s[j]?lcp[i+1][j+1]+1:0;
			lcp[i][j]=min(lcp[i][j],i-j);
			if(!pre[i][lcp[i][j]])
				pre[i][lcp[i][j]]=j;
		}
		drep(j,n,1){
			pre[i][j]=max(pre[i][j],pre[i][j+1]);
		}
	}
	mems(dp,0x3f);
	rep(i,1,n){dp[i][i]=A;}
	rep(len,1,n){
		rep(i,1,n-len+1){
			int j=i+len-1;
			dp[i][j]=min({dp[i][j],dp[i+1][j]+A,dp[i][j-1]+A});
			int p=i;
			rep(k,1,j/len){
				p=pre[p][len];
				if(!p)break;
				dp[p][j]=min(dp[p][j],dp[i][j]+B+(k+1)*C+(j-p+1-(k+1)*len)*A);
			}
		}
	}
	printf("%lld\n",dp[1][n]);
}
signed main(){
	int t=1;
	//	scanf("%d",&t);
	while(t--)
		Yorushika();
}
```

upd 11.27：修改了若干错误。

---

## 作者：寻逍遥2006 (赞：8)

[传送门](https://www.luogu.com.cn/problem/P9523)

简要题意：

我们可以进行以下的三种操作维护两个字符串 $X$ 和 $Y$：

1. 在 $X$ 的末尾加入一个字符 $c$，需要 $A$ 的代价。
2. 将 $Y$ 变成 $X$，同时将 $X$ 清空，需要 $B$ 的代价。
3. 在 $X$ 末尾插入一个字符串 $Y$，需要 $C$ 的代价。

最后要求 $X$ 串为一个特定的串 $S$。

记 $S[l,r]$ 为 $S$ 的第 $l$ 位到第 $r$ 位构成的字符串。

首先，$X$ 和 $Y$ 必然是 $S$ 的子串，因为不是 $S$ 子串的 $X$，$Y$ 必然会在某一次剪切之后被覆盖掉，这样是劣于不做这些操作。

考虑一个朴素的动态规划方法，记 $f_{l_x,r_x,l_y,r_y}$ 表示从 $X=Y=\varnothing$ 操作到 $X=S[l_x,r_x],Y=S[l_y,r_y]$ 的最少代价。

最后的答案即为 $f_{1,n,*,*}$，转移有三种：

1. $f_{l_x,r_x+1,l_y,r_y}\gets f_{l_x,r_x,l_y,r_y}+A$。
2. $f_{0,0,l_x,r_x}\gets f_{l_x,r_x,l_y,r_y}+B$。
3. $f_{l_x,r_x+r_y-l_y,l_y,r_y}\gets f_{l_x,r_x,l_y,r_y}+C$，当且仅当 $S[r_x+1,r_x+r_y-l_y]=S[l_y,r_y]$。

第三种转移的可行性使用任意字符串方式查询即可做到 $O(n^4)$。

显然，这样的做法是过不了的，所以考虑怎么优化复杂度。

首先 $l_x$ 和 $r_x$ 是看起来不可优化的，所以考虑将 $l_y$ 和 $r_y$ 优化掉。我们把 $1$ 和 $3$ 类转移合并在一起，也就是，我们把 $Y$ 变成 $X$ 之后，我们直接将 $X$ 变成由 $Y$ 和若干其他字符组成的字符串。下一次要转移，就是再次将 $Y$ 变成 $X$，然后重复上述操作。

这样可以之间将 $l_y$ 和 $r_y$ 这两位去掉。

考虑现在的转移是什么，除了可以粘贴 $Y$ 的部分，由必须用 $A$ 将其余的位置填满，所以写出转移式：

$f_{l,r}=A\times [(r-l+1)-cnt\times(r'-l'+1)]+B+f_{l',r'}+cnt\times C$。

其中 $cnt$ 为从 $S[l,r]$ 中取出多少个互不相交的 $S[l',r']$。由于取出现靠前的 $S[l',r']$ 一定比取靠后的 $S[l',r']$ 优，所以 $cnt$ 的上界就是从 $S[l,r]$ 中贪心取 $S[l',r']$ 的个数。

对于转移移项得：

$f_{l,r}=A\times (r-l+1)+B+f_{l',r'}+cnt\times [C-A\times (r'-l'+1)]$。

其中第一项只与 $l,r$ 有关了，第二项为常数，第三项只与 $l',r'$ 有关，现在需要考虑第四项的问题。

和两遍都挂勾的就是 $cnt$，所以考虑怎么处理 $cnt$。

我们可以钦定 $l',r'$ 是 $S[l,r]$ 中子串 $S[l',r']$ 第一次出现的位置。这样，对于固定的 $cnt$，我们可以得到 $r$ 的一个下界：就是从第 $l'$ 位开始，贪心取出互不相交的 $S[l',r']$，第 $cnt$ 个串位置的右边界 $R$。

又因为 $l\leqslant l'$，所以对于这组 $(l',r',cnt)$ 的转移可以转移到任意 $l\leqslant l',R\leqslant r$ 的位置。

考虑如何求出 $R$，我们可以维护一个数组 $nxt_{l',r'}$，表示最小的 $k>r'$，满足 $S[k,k+r'-l']=S[l'.r']$。我们就可以通过跳 $nxt$ 数组来通过 $(l',r',cnt-1)$ 的 $R'$ 得到 $(l',r',cnt)$ 的 $R$，具体的，$R=nxt_{R-r'+l',R}+r'-l'$。

$nxt$ 数组可以使用后缀自动机上维护线段树合并来做到 $O(N^2\log N)$ 维护，相当于就是 $O(N^2)$ 次查线段树上的区间最小值。

那么现在的转移相当于是一个二维的矩阵取 $\min$，发现通过 $l$ 单调递减，$r$ 单调递增的方式维护转移，可以直接使用树状数组维护前缀 $\min$。

现在的时间复杂度为 $O(G\log n)$ 其中 $G$ 为可行的 $(l',r',cnt)$ 的数量，记对于 $l',r'$ 最大的 $cnt$ 为 $t_{l',r'}$，相当于求 $\sum\limits_{l}\sum\limits_{r}t_{l,r}$。

考虑证明它的上界，显然 $t_{l,r}\leqslant \dfrac{n-r}{r-l+1}$。

所以 $G\leqslant \sum\limits_{l}\sum\limits_{r}\dfrac{n-r}{r-l+1}=\sum\limits_{r}(n-r)\sum\limits_{l}\dfrac{1}{r-l+1}\approx\sum\limits_{r}(n-r)\ln r=O(n^2\ln n)$。

所以总体复杂度为 $O(n^2\ln n\log n)$，常数很小，跑起来飞快。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int Qread()
{
    int x=0;char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=getchar();
    return x;
}
char get_ch()
{
    char ch=getchar();
    while(ch<'a'||ch>'z') ch=getchar();
    return ch;
}
int N;
long long A,B,C;
namespace BIT{
    long long num[2501];
    void add_num(int x,long long a){for(;x<=N;x+=(x&-x)) num[x]=min(num[x],a);}
    long long get_min(int x){long long ret=0;for(;x;x-=(x&-x)) ret=min(ret,num[x]);return ret;}
}
#define mid (l+r>>1)
#define ls s[pos].lson
#define rs s[pos].rson
namespace Sege{
    struct Node{
        int num,lson,rson;
    }s[50010];
    int poi_cnt;
    void add_num(int x,int &pos,int l=1,int r=N)
    {
        if(!pos) pos=++poi_cnt;
        s[pos].num=x;
        if(l==r) return;
        if(x<=mid) return add_num(x,ls,l,mid);
        else return add_num(x,rs,mid+1,r);
    }
    void merge(int &pos,int pos_,int l=1,int r=N)
    {
        if(pos&&pos_)
        {
            if(l==r) s[pos].num=min(s[pos].num,s[pos_].num);
            else merge(ls,s[pos_].lson,l,mid),merge(rs,s[pos_].rson,mid+1,r),s[pos].num=min(s[ls].num,s[rs].num);
        }
        else pos+=pos_;
    }
    int range_min(int L,int R,int pos,int l=1,int r=N)
    {
        if(L<=l&&r<=R) return s[pos].num;
        if(r<L||R<l) return N+1;
        return min(range_min(L,R,ls,l,mid),range_min(L,R,rs,mid+1,r));
    }
}
#undef mid
#undef ls
#undef rs
namespace SAM{
    struct Node{
        int link,len,rt;
        int nxt[26];
    }s[5010];
    int poi_cnt;
    vector<int> son[5010];
    int insert_node(int ind,int las,int nw)
    {
        int cur=++poi_cnt;
        Sege::add_num(ind,s[cur].rt);
        s[cur].len=s[las].len+1;
        int p=las;
        while(p!=-1&&!s[p].nxt[nw])
        {
            s[p].nxt[nw]=cur;
            p=s[p].link;
        }
        if(p==-1) s[cur].link=0;
        else
        {
            int q=s[p].nxt[nw];
            if(s[q].len==s[p].len+1) s[cur].link=q;
            else
            {
                int clo=++poi_cnt;
                s[clo].len=s[p].len+1;
                s[clo].link=s[q].link;
                memcpy(s[clo].nxt,s[q].nxt,sizeof(s[q].nxt));
                while(p!=-1&&s[p].nxt[nw]==q)
                {
                    s[p].nxt[nw]=clo;
                    p=s[p].link;
                }
                s[q].link=s[cur].link=clo;
            }
        }
        return cur;
    }
    void get_fa()
    {
        for(int i=1;i<=poi_cnt;i++)
            son[s[i].link].push_back(i);
    }
}
char S[2501];
long long f[2510][2501];
int nxt[2510][2510];
#define mid (l+r>>1)
void solve(int rt,int pos,int L,int R,int l=1,int r=N)
{
    if(!pos) return;
    if(l==r)
    {
        for(int i=L;i<=R;i++)
        {
            // printf("find(%d %d)",l-i)
            nxt[l-i+1][l]=Sege::range_min(l+i,N,rt);
        }
    }
    solve(rt,Sege::s[pos].lson,L,R,l,mid);
    solve(rt,Sege::s[pos].rson,L,R,mid+1,r);
}
#undef mid
void dfs(int a)
{
    for(int v: SAM::son[a])
    {
        dfs(v);
        Sege::merge(SAM::s[a].rt,SAM::s[v].rt);
    }
    if(a) solve(SAM::s[a].rt,SAM::s[a].rt,SAM::s[SAM::s[a].link].len+1,SAM::s[a].len);
}
int main()
{
    N=Qread();
    Sege::s[0].num=N+1;
    SAM::s[0].link=-1;
    for(int i=1;i<=N;i++)
        S[i]=get_ch();
    A=Qread(),B=Qread(),C=Qread();
    for(int i=1,las=0;i<=N;i++)
        las=SAM::insert_node(i,las,S[i]-'a');
    SAM::get_fa();
    dfs(0);
    for(int l=N;l;l--)
    for(int r=l;r<=N;r++)
    {
        int len=r-l+1;
        f[l][r]=A*len+min(0ll,B+BIT::get_min(r));
        int cur=r,cnt=1;
        while(cur<=N)
        {
            BIT::add_num(cur,cnt*(C-A*len)+f[l][r]);
            cur=nxt[cur-len+1][cur],cnt++;
        }
    }
    printf("%lld\n",f[1][N]);
    return 0;
}
```

---

## 作者：xqqQwQ_ (赞：5)

模拟赛考了这题，感觉很厉害啊！

由于 $S$ 的每一个子串都有可能进入剪贴板然后进行粘贴，所以我们只单纯地设一维状态显然是不好解决的。于是我们考虑区间 DP，设 $f_{l, r}$ 表示想要拼出 $S[l \sim r]$ 子串所需要的最少代价。很显然有转移 $f_{l, r} + A \rightarrow f_{l, r + 1}$，同理，我们也可以在前端进行插入字符的操作（相当于在后面的操作之前先进行一个插入字符操作），所以有转移 $f_{l, r} + A \rightarrow f_{l - 1, r}$。

我们发现这个时候我们 $A$ 操作的转移已经刻画完了，因此考虑刻画 $B, C$ 操作的转移。

可以观察到，如果我们选择使用 $B, C$ 操作，那么我们一定会尽可能多地粘贴，这样一定更优，因此我们最后拼出来的字符串形如 ```...Y..YY..YYY.Y..``` 的形式，中间进行一些粘贴然后空位用 $A$ 操作补全。由于我们已经有了在两端进行 $A$ 操作的转移，所以现在如果状态 $f_{l, r}$ 可以通过 $B, C$ 操作转移到 $f_{x, y}$，我们可以强制令 $S[x \sim x + r - l] = S[y - r + l \sim y] = S[l \sim r]$，并且 $x + r - l < y - r + l$，相当于钦定 $S[x \sim y]$ 两端都出现了一个 $S[l \sim r]$，这样不会影响我们的转移正确性，因为往两边加零散字符的情况会被 $A$ 操作的转移考虑到。我们也可以同时钦定如果一个字符串中间有粘贴 $Y$ 的操作，那么一定是剪切它的最右边的那个 $Y$ 进行粘贴。有如上两个条件，我们的 $f_{l, r}$ 只需要转移到 $f_{i, r} (i < l)$ 即可，这样我们就不需要枚举右端点了。

接下来我们考虑每个 $f_{l, r}$ 具体会转移到哪些 $f_{i, r}$，并且怎么转移。由上面的钦定可知，$i$ 必须满足 $S[l \sim r]$ 子串在 $S$ 中有一个起始位置是 $i$，并且 $i + r - l < l$。有了这个条件，我们就可以 $O(n^3)$ 转移了：设 $i$ 到 $r$ 中最多能选出 $cc$ 个不交的起始位置，那转移就是 $f_{l, r} + B + cc \times C + (r - i + 1 - cc \times (r - l + 1)) \rightarrow f_{i, r}$（应该挺显然）。

但是这个复杂度依然不能接受。这个时候我们可以作出一个重要观察：若存在 $i, j(i < j)$ 满足 $i, j$ 都满足上面的条件，并且 $i + r - l > j$，那么只需要在选择 $f_{j, r}$ 转移即可。形象化的说，如果有两个左端点对应的串有交，那么这两个左端点只需要选更大的那个即可。这也是很好理解的，因为有交，所以两个位置必然只能粘贴一个，而剩下的零散字符个数是相等的所以代价是相同的，那选择最靠近右端点的显然最优。有了这个条件，我们的转移就能够做到 $O(n^2 \log n)$，因为每个右端点的总枚举量是调和级数级别的。然后这个时候我们还需要处理出每一个子串在某个前缀中最靠后的起始位置。这个东西显然可以直接 SAM 加线段树合并求一求，但是鉴于我不是很会写 SAM，于是我选择使用哈希，给所有子串重标号然后用 vector 存起始位置，查的时候用 ``lower_bound()`` 查前驱就行。时间复杂度是 $O(n^2 \log^2 n)$。但是呢，这个题模数开小了很容易被卡，于是只能找一个 $10^{12}$ 级别的大质数来当模数，然后里面的运算用 ```__int128```。结果这就搞的常数巨大，最后几乎是卡线过的。

Upd：好像其实并不是卡了哈希，而是我写法太劣了。如果你使用 ```unsigned long long``` 自然溢出并且使用 ```unordered_map``` 来存位置的话，可以做到基本上严格的 $O(n^2 \log n)$，而且常数超小，只用跑 $270ms$。代码作了更新。

```cpp
#include<bits/stdc++.h>
#define pb push_back
#define ll long long
#define ull unsigned long long

using namespace std;

const int N = 2511;
const ll inf = 1e17;

int n;
string S;
ll f[N][N];
ll A, B, C;
int pre[N][N]; 
ull p = 131;
ull H[N], ppow[N];
int tot = 0, tk;
unordered_map<ull, int> Ma;

void prework() {
	ppow[0] = 1;
	for(int i = 1; i <= N - 5; ++i) ppow[i] = ppow[i - 1] * p;
	for(int i = 1; i <= n; ++i) H[i] = (H[i - 1] * p + (S[i - 1] - 'a' + 1));
	return;
}

inline ull getHsh(int l, int r) {
	return (H[r] - H[l - 1] * ppow[r - l + 1]);
}

int main() {
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cin >> n >> S;
	cin >> A >> B >> C;
	for(int i = 0; i <= n; ++i) {
		for(int j = 0; j <= n; ++j) f[i][j] = inf;
	}
	prework();
	for(int len = 1; len <= n; ++len) { 
        Ma.clear();
        for(int r = len; r <= n; ++r) {
            int l = r - len + 1;
            if(l - len >= 1) Ma[getHsh(l - len, l - 1)] = l - len;
            pre[l][r] = Ma[getHsh(l, r)];
        } 
    }
	for(int i = 1; i <= n; ++i) f[i][i] = A;
	for(int len = 1; len <= n - 1; ++len) {
		for(int r = len; r <= n; ++r) {
			int l = r - len + 1; 
			f[l - 1][r] = min(f[l - 1][r], f[l][r] + A);
			f[l][r + 1] = min(f[l][r + 1], f[l][r] + A);
			ll cc = 1; int t = pre[l][r];
			while(t) {
				cc++; 
				f[t][r] = min(f[t][r], f[l][r] + B + cc * C + (r - t + 1 - cc * len) * A); 
                t = pre[t][t + len - 1];
			}
		}
	}
	cout << f[1][n] << '\n';
	return 0;
}
```

---

## 作者：SDLTF_凌亭风 (赞：3)

今天考试考了这题，于是来补一下。

先说直接按题意模拟，写四个循环来检查每个字串出现次数，这个做法是复杂度太高，不能接受。

那么想一想一下最终的结果是怎样构成的。先把问题弄简单一点。设 $a_1,a_2,a_3,\cdots$ 为手打字符，$T$ 表示剪切字符。假设你只用了一次复制粘贴操作，并且复制粘贴操作是优于手打的，最终的字符串构成应该是形如：
$$
S = a_1+T+a_2+T+a_3+T+\cdots
$$
的一个**由剪切字符和手打字符**交错出现构成的字符串。

多次使用剪切板，反正我不会用 AC 自动机或者 SAM 维护，那么考虑使用区间动规。

我的基本思路是：假设你要凑出的这个字符串是 $S$，其中有一个出现次数多的字串是 $T$，那我就要先想着把这个 $T$ 凑出来，然后把它弄到剪切板里去，接着用手打和剪切交错的方式凑出答案。

于是整个问题，就变成了你怎么把 $T$ 给搞出来。

设 $f_{i,j}$ 表示区间 $[i,j]$ 的答案，考虑转移。

使用操作一，转移显然：$f_{i,j} = A + \min \{ f_{i+1,j},f_{i,j - 1} \}$。

接下来枚举 $[i,j]$ 的所有 border 去计算当 $T=S[i,k]$ 时的答案。这一步容易想到 KMP ，对于每个后缀预处理 $next$ 就可以完成。

那最后的问题来源于，如何快速求出 $[l,r]$ 最多能选出多少个不重复的 $[i,k]$。这一步用倍增处理一下和 $S[i,j]$ 相同的不重复的后 $2^k$ 个字串即可得到。

由于相同的字串只计算一次，字符串哈希配合哈希表即可实现记忆化。总共的复杂度是 $O(n^2\log n)$ 的。

一些关键代码：

```cpp
// ...
for(int k = 0, i = 1; i <= n; ++ i) {
	for(int j = 1; j <= n - i + 1; ++ j) b[++ k] = {cal(j, j + i - 1), j};
	sort(b + 1, b + T + 1, [](pi &x, pi &y) { return x.fi != y.fi ? x.fi < y.fi : x.se > y.se; } );
	int p = 1;
	for(int j = 1; j <= k; ++ j) {
		while(p < j && b[p].fi     != b[j].fi) 		++ p;
		while(p < j && b[j].se + i <= b[p + 1].se)  ++ p;
		if   (p < j && b[j].se + i <= b[k].se)		ste[0][b[j].se][i] = b[p].se;
	}
}

// ...
const int P = 19260817;
for(int r = 1; r <= n; ++ r) for(int l = r; l >= 1; -- l) {
	if(l == r) f[l][r] = costA; 
	else {
		ull tt = cal(l, r), now = tt % P;
		while(kkey[now] && kkey[now] != tt) ++ now;
		if(kkey[now]) f[l][r] = g[now];
		else {
			kkey[now] = tt;
			ull cur = min(f[l + 1][r], f[l][r - 1]) + costA;
			int md = (r - l + 1) >> 1, k = nxt[l][r];
			while(k && k > md) k = nxt[l][l + k - 1];
			for(int cnt, sum, p; k; k = nxt[l][l + k - 1]){
				cnt = r - l + 1, sum = 2, p = l;
				for(int i = 11; i >= 0; -- i) if(ste[i][p][k] && ste[i][p][k] + k - 1 <= r - k)p = ste[i][p][k], sum += 1 << i;
				cnt -= sum * k;
				cur = min(cur, f[l][l + k - 1] + costB + sum * costC + cnt * costA);
			}
			f[l][r] = g[now] = cur;
		}
	}
}

---

## 作者：meyi (赞：3)

写了个 $O(n^3)$ 但是常数很小且代码极短的做法，没想到赛时跑的飞快，在洛谷上测最慢的点也只有 1.44s。。。

此做法不是乱搞，思路极为朴素，几乎与暴力无异。定义 $f_{i,j}$ 表示计算出 $[i,j]$ 的最小代价，转移类似于典型的区间 dp。

具体来说，如果区间长度 $len>1$，那么有 $f_{i,j} \leftarrow \min(f_{i+1,j},f_{i,j-1})+A$，这是显然的。

考虑如何使用 $B$ 和 $C$，由于我们对字符串的处理均在末尾，所以左端点不变，只改变有端点，即从 $f_{i,j}$ 转移到 $f_{i,k+len-1}(k\geq i)$，很明显 $B$ 只会在代价中出现一次，即将 [i,j] 拷贝至剪贴板，剩下的部分则由 $A$ 和 $C$ 组成。

剩下的部分则很显然，不妨设总代价为 $sum$，那么 $sum$ 的初始值为 $B$，然后枚举 $k$，若 $s_{i..j}=s_{k..k+len-1}$，那么 $k\leftarrow k+len-1,sum\leftarrow sum+C$，然后 $f_{i,k}\leftarrow f_{i,j}+sum$，否则 $sum\leftarrow sum+A$。

若判断字符串相等使用的是哈希算法，则笔者主观上认为时间复杂度为 $O(n^3)$。

笔者并不知道该做法除了哈希之外的部分是否可以被 hack 或是被证明复杂度并非 $O(n^3)$，欢迎读者尝试并反馈。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ri int
typedef unsigned long long ll;
const int base=2333,maxn=2510;
template<class T>inline bool ckmin(T &x,const T &y){return x>y?x=y,1:0;}
template<class T>inline bool ckmax(T &x,const T &y){return x<y?x=y,1:0;}
template<class T>inline void clear(T *arr,int siz,int val=0){memset(arr,val,sizeof(T)*(siz+1));}
ll A,bs[maxn],B,C,f[maxn][maxn],hsh[maxn];
inline ll get_hsh(int l,int r){return hsh[r]-hsh[l-1]*bs[r-l+1];}
int n;
char s[maxn];
int main(){
	scanf("%d%s%llu%llu%llu",&n,s+1,&A,&B,&C);
	bs[0]=1;
	memset(f,0x3f,sizeof f);
	for(ri i=1;i<=n;++i)bs[i]=bs[i-1]*base,f[i][i]=A,hsh[i]=hsh[i-1]*base+s[i];
	for(ri len=1;len<=n;++len)
		for(ri i=1;i+len-1<=n;++i){
			ri j=i+len-1;
			if(len>1)ckmin(f[i][j],min(f[i+1][j],f[i][j-1])+A);
			ll h=get_hsh(i,j),sum=B;
			for(ri k=i;k+len-1<=n;++k){
				if(get_hsh(k,k+len-1)==h){
					k+=len-1;
					sum+=C;
					ckmin(f[i][k],f[i][j]+sum);
				}
				else sum+=A;
			}
		}
	printf("%llu",f[1][n]);
	return 0;
}
```


---

## 作者：云浅知处 (赞：1)

显然任意时刻 $X,Y$ 肯定是最终串的一个区间，因此我们考虑区间 DP。

设 $f(l,r)$ 表示合成 $[l,r]$ 所需的最小代价，分最后一次有效操作是粘贴还是加字符讨论。

如果是加字符，有 $f(l,r)\leftarrow f(l,r-1)+A$。

如果是粘贴，那么如果粘贴了一个 $[k+1,r]$，考虑到剪切的时候会直接变成空串，于是我们一定是先用最小代价构造出 $s[k+1,r]$，然后需要算出，如果剪贴板里面是 $s[k+1,r]$，那么构造出 $s[l,r]$ 最少需要多少代价。

如果粘贴一次还不如直接加字符，即 $A\times (r-k)<C$，那显然没有用。

否则我们应该粘贴尽可能多次，也就是说要在 $[l,r]$ 中找到尽可能多的不交子串 $s[k+1,r]$。

考虑先枚举 $r$，然后枚举 $k$，对所有的 $l$ 做贡献。枚举完 $r,k$ 之后，设 $c_i$（$i\le r$）为 $[i,r]$ 中子串 $[k+1,r]$ 的最多不交出现次数，我们相当于要做转移
$$
f(k+1,r)+B+(r-l+1-c_l\times (r-k))\times A+c_l\times C\to f(l,r)
$$
注意到 $c_i\le \frac{r}{r-k}$，考虑对一段相同的 $c_l$ 一起做贡献，那么是一个区间对公差为 $A$ 的等差数列 chkmin 的形式，可以简单维护。这样对一个 $r$，只需要 $O(r\log r)$ 次区间 chkmin。进一步发现区间可以放宽成前缀，于是可以 $O(1)$ 进行一次操作。

现在还需要求一个 $p$ 前面 $[l,r]$ 最后一次出现的位置，注意我们会对一个 $[l,r]$ 询问若干递减的 $p$，在 SAM 上定位到 $[l,r]$ 这个节点，然后在 endpos 集合里维护一个指针即可做到均摊 $O(1)$。

综上，总复杂度 $O(N^2\log N)$。

```cpp
#include<bits/stdc++.h>

#define ll long long
#define mk make_pair
#define fi first
#define se second

using namespace std;

inline int read(){
	int x=0,f=1;char c=getchar();
	for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
	for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
	return x*f;
}

const int mod=998244353;
int ksm(int x,ll y,int p=mod){
	int ans=1;y%=(p-1);
	for(int i=y;i;i>>=1,x=1ll*x*x%p)if(i&1)ans=1ll*ans*x%p;
	return ans%p;
}
int inv(int x,int p=mod){return ksm(x,p-2,p)%p;}
mt19937 rnd(time(0));
int randint(int l,int r){return rnd()%(r-l+1)+l;}
void add(int &x,int v){x+=v;if(x>=mod)x-=mod;}
void Mod(int &x){if(x>=mod)x-=mod;}
int cmod(int x){if(x>=mod)x-=mod;return x;}

template<typename T>void cmax(T &x,T v){x=max(x,v);}
template<typename T>void cmin(T &x,T v){x=min(x,v);}

const int N=2505;
const int D=26;
int n,s[N],id[N][N];

const int M=N*2;
int nxt[M][D],len[M],fa[M],lst=1,tot=1;
vector<int>endp[M],G[M];

void ins(int i,int c){
	int np=++tot,p=lst;len[np]=len[p]+1,lst=np,endp[np].emplace_back(i);
	while(p&&nxt[p][c]==0)nxt[p][c]=np,p=fa[p];
	if(p==0)return fa[np]=1,void();
	int q=nxt[p][c];
	if(len[q]==len[p]+1)return fa[np]=q,void();
	int nq=++tot;fa[nq]=fa[q],fa[q]=fa[np]=nq;
	memcpy(nxt[nq],nxt[q],sizeof(nxt[nq]));
	while(p&&nxt[p][c]==q)nxt[p][c]=nq,p=fa[p];
}

void buildtree(){
	for(int i=1;i<=tot;i++)if(fa[i])G[fa[i]].emplace_back(i);
}
void dfs(int u){
	for(int v:G[u]){
		dfs(v);
		for(int j:endp[v])endp[u].emplace_back(j);
	}
	sort(endp[u].begin(),endp[u].end());
}

ll f[N],A,B,C,g[N];

signed main(void){

#ifndef ONLINE_JUDGE
	freopen("in.in","r",stdin);
#endif

	n=read();
	for(int i=1;i<=n;i++){
		char c=getchar();while(!(c>='a'&&c<='z'))c=getchar();
		s[i]=c-'a',ins(i,s[i]);
	}
	A=read(),B=read(),C=read();
	
	buildtree(),dfs(1);
	for(int i=1;i<=n;i++)id[i][i-1]=1;
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++)id[i][j]=nxt[id[i][j-1]][s[j]];
	}
	
	auto work=[&](int l,int r,ll v){
		int u=id[l][r];vector<int>&vec=endp[u];
		int it=vec.size()-1;
		auto mdf=[&](int lim){while(it>=0&&vec[it]>lim)it--;};
		mdf(r);int k=r-l+1,cnt=1;
		while(it!=-1){
			int p=vec[it]-k+1;
			cmin(g[p],1ll*(r+1-cnt*k)*A+1ll*cnt*C+B+v);
			cnt++,mdf(p-1);
		}
	};
	
	for(int i=1;i<=n;i++){
		memset(g,63,sizeof(g));
		for(int j=i;j>=1;j--)f[j]+=A;
		for(int j=i;j>=1;j--){
			cmin(g[j],g[j+1]),cmin(f[j],g[j]-A*j);
			work(j,i,f[j]);
		}
	}
	
	cout<<f[1]<<endl;

	return 0;
}
```

---

## 作者：周子衡 (赞：0)

假定在整个打字过程中，出现在剪贴板中的字符串依次为 $S_1,...,S_k$。打字的过程可以描述为：先用 $A|S_1|$ 的代价打出 $S_1$，然后对每个 $i\in [1,k)$，找到 $S_{i+1}$ 中尽可能多且不重叠的 $S_{i}$ 子串，这些子串通过粘贴打出，其他字符仍直接打出。可以观察到其中的 DP 结构。另外，显见 $S_i$ 必须是 $S$ 的子串，这样我们需要考虑的串数量仅在 $O(n^2)$ 级别。考虑设计 DP。

设 $f(i,j)$ 表示打出 $S_{i...j}$ 且复制到剪贴板中的的最小代价。初始时设定 $f(i,j)\gets A\times (j-i+1)+B$。对每个 $(i,j)$，考虑它如何向更长的串转移。不妨设 $S_{i_1...j_1}$ 是完全出现在 $S_{i...j}$ 之后且和 $S_{i...j}$ 相等的子串中最靠前的，那么对于所有完全包含了 $[i,j_1]$ 的区间 $[l,r]$，我们可以通过复制两次 $S_{i...j}$ 来减小打出 $S_{l...r}$ 的代价。同理，不妨设 $S_{i_k...j_k}$ 是完全出现在 $S_{i_{k-1}...j_{k-1}}$ 之后且和 $S_{i...j}$ 相等的子串中最靠前的（$k\geq 2$），那么可以通过复制 $k+1$ 次 $S_{i...j}$ 来更新打出所有包含 $[i,j_k]$ 区间的最小代价。我们可以额外开一个 DP 数组 $g(i,j)$ 来优化转移，其中 $g(i,j)$ 表示利用复制功能，打出区间 $[i,j]$ 能省下的最大代价。我们按长度从小到大枚举所有区间进行 $f$ 的转移，同时进行转移 $g(i,j)\gets g(i,j-1),g(i,j)\gets g(i+1,j)$。

注意到有效的 $k\leq \dfrac{n}{j-i+1}$，所有子串转移时有效的 $k$ 的总和 $\leq n\times(\dfrac{n}{1}+\cdots+\dfrac{n}{n})=O(n^2\log n)$，在可以接受的范围内。总时间复杂度也为 $O(n^2\log n)$。

```cpp
#include<cstdio>
#include<algorithm>

using namespace std;

char s[3000];

int LCP[2600][2600];
int nxt[2600][2600];

long long dp[2600][2600],f[2600][2600];

int main()
{
	int n=0;long long A=0,B=0,C=0;scanf("%d%s%lld%lld%lld",&n,s+1,&A,&B,&C);
	for(int i=n;i>=1;i--)for(int j=n;j>=1;j--)if(s[i]==s[j])LCP[i][j]=LCP[i+1][j+1]+1;else LCP[i][j]=0;
	for(int j=0;j<=n;j++)nxt[n+1][j]=n+1;
	for(int i=n;i>=1;i--)
	{
		nxt[i][0]=i;
		for(int j=1;j<=n;j++)
		{
			nxt[i][j]=nxt[i][j-1];
			while(nxt[i][j]<=n&&!(nxt[i][j]>=i+j&&LCP[i][nxt[i][j]]>=j))nxt[i][j]++;
		}
	}
	
	for(int len=1;len<=n;len++)
	{
		for(int i=1;i+len-1<=n;i++)
		{
			int j=i+len-1;
			f[i][j]=max(max(f[i][j],f[i][j-1]),f[i+1][j]);
			dp[i][j]=A*len+B-f[i][j];
			for(int k=1,p=i;p<=n;p=nxt[p][len],k++)
			{
				f[i][p+len-1]=max(f[i][p+len-1],k*A*len-k*C-dp[i][j]);
			}
		}
	}
	printf("%lld",dp[1][n]-B);
}
```

---

## 作者：happybob (赞：0)

题意：

在某个编辑器中，可以执行如下几种操作来输入某个字符串，设 $X$ 为屏幕上的字符串，$Y$ 为剪切板中的字符串，初始均为空串：

- 操作 A：输入字符 $c$，即将 $X$ 更新为 $X+c$，花费 $A$ 单位时间。
- 操作 B：选择所有字符并剪切，即将 $Y$ 更新为 $X$，并将 $X$ 置为空串，花费 $B$ 单位时间。
- 操作 C：将剪切板中的字符串粘贴到当前字符串末尾，即将 $X$ 更新为 $X+Y$，花费 $C$ 单位时间。

对于字符串或字符 $x,y$，$x+y$ 表示将 $x$ 和 $y$ 顺次拼接得到的结果。

你想尽可能快地输入一个长度为 $N$ 的小写英文字符串 $S$，你需要计算出最少需要花费多少时间。

$1 \leq N \leq 2500$，$3$ 秒，$2$ GB。

解法：

看着很像区间 DP。

记 $f_{i,j}$ 表示打出区间 $[i,j]$ 的最小花费，首先有转移 $f_{i,j} \gets \min(f_{i+1,j},f_{i,j-1})+a$，表示使用操作 A 增加一个字符。另一方面，枚举一个子区间 $[l',r']\subseteq [l,r]$，计算 $[l',r']$ 子串在 $[l,r]$ 中不重叠出现的最大次数即可转移。显然枚举子串是不必要的，只枚举后缀即可。

这样转移复杂度仍然不优。考虑逆着转移，从 $f_{i,j}$ 往某个 $f_{x,j}$ 转移，其中 $x \leq i$，我们可以枚举 $y$，求出最大的 $x$ 使得 $[i,j]$ 在 $[x,j]$ 中不重叠出现了至少 $y$ 次。可以发现 $y \leq \dfrac{n}{j-i+1}$，所以每次都枚举 $y$ 复杂度可以接受。

问题瓶颈现在在于找 $x$，我们发现当枚举的 $y$ 变为 $y+1$ 后，我们应该往前找到第一个 $[i,j]$ 的出现位置。首先我们可以通过形如 $g_{i,j}=g_{i+1,j+1}+1$ 的转移得到任意两个后缀的 LCP，假设 $y$ 增加前得到的是 $x$，增加后需要找到 $x'$，那么 $s[x',x'+j-i+1] = s[i,j]$ 等价于 $\operatorname{LCP}(s[x',n],s[i,n]) \geq j-i+1$，等价于 $\operatorname{LCP}(s[x',n],s[x,n]) \geq j-i+1$，对于每个 $x$ 和 $y$ 求出最大的 $k<x$ 使得 $\operatorname{LCP}(s[k,n],s[x,n]) \geq y$ 即可。特别注意由于我们要求]出现位置不重叠，所以我们假设 $\operatorname{LCP}(s[i,n],s[j,n]) \leq |i-j|$ 即可。

复杂度瓶颈在于枚举 $y$ 的调和级数，复杂度 $O(n^2 \log n)$。

---

## 作者：xfrvq (赞：0)

区间 dp。设 $f_{l,r}$：屏幕上输入 $S_{l\cdots r}$ 的最小代价。

最重要的剪贴转移：假设 $[l,r]\subsetneq[x,y]$，在 $[x,y]$ 中无交出现了 $k$ 次，转移：

$$f_{x,y}\gets f_{l,r}+(y-x+1-k(r-l+1))A+B+kC$$

这样转移总量太大，但我们可以钦定 $y=r$，$[x,r]$ 是满足 $[l,r]$ 出现 $k$ 次最大 $x$。然后加上转移 $f_[l,r]\gets\min\{f(l,r-1),f(l+1,r)\}+A$。

由于 $[l,r]$ 最多出现 $\dfrac n{r-l+1}$ 次，现在转移只会有 $O(n^2\ln n)$ 次。

现在还需要对 $[l,r]$ 找到所有 $x,k$。只需要求 $P_{l,r}$ 代表 $[l,r]$ 上次无交出现的位置右端点，然后暴力跳即可。

设 $lcs(l,r)$ 为 $S_{1\cdots l},S_{1\cdots r}$ 最长公共后缀长度。枚举 $j\lt i$，转移 $P_{i-lcs(i,j)+1\cdots i,i}\gets j$，双指针复杂度 $O(n^2)$。

由于出现位置无交，需要钦定 $lcs(l,r)\le|r-l|$。

```cpp
#include<bits/stdc++.h>
using namespace std;

using ll = long long;

const int N = 2505;

int n,f[N][N],P[N][N];
ll dp[N][N],A,B,C;
char a[N];

int main(){
	scanf("%d%s%lld%lld%lld",&n,a + 1,&A,&B,&C);
	for(int i = 1;i <= n;++i)
		for(int j = 1;j <= n;++j)
			f[i][j] = a[i] == a[j] ? min(f[i - 1][j - 1] + 1,abs(i - j)) : 0;
	memset(dp,0x3f,sizeof dp);
	for(int i = 1;i <= n;++i)
		for(int j = i - 1,k = 1;j >= 1;--j)
			for(;k <= f[i][j];++k) P[i - k + 1][i] = j;
	for(int i = 1;i <= n;++i)
		for(int l = 1,r = i;r <= n;++l,++r){
			if(l == r) dp[l][r] = A;
			else dp[l][r] = min({dp[l][r],dp[l + 1][r] + A,dp[l][r - 1] + A});
			for(int j = P[l][r],k = 2;j;j = P[j - i + 1][j],++k){
				dp[j - i + 1][r] = min(dp[j - i + 1][r],dp[l][r] + B + (r - (j - i + 1) + 1 - k * i) * A + k * C);
			}
		}
	printf("%lld\n",dp[1][n]);
	return 0;
}
```

---


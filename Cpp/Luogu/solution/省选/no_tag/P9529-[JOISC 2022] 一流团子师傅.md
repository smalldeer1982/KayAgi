# [JOISC 2022] 一流团子师傅

## 题目背景

JOISC2022 D4T1

**特别提醒，由于洛谷交互机制的特殊性，你不能在程序中引用 `dango3.h`，而需要把 `dango3.h` 中的内容加入文件的开头。即，在程序中 `void Solve(int N, int M)` 的前面加入以下几行语句：**

```cpp
#include <vector>

void Solve(int N, int M);

int Query(const std::vector<int> &x);
void Answer(const std::vector<int> &a);
```

## 题目描述

JOI 君是一位专业的团子师傅。在 JOI 君的店里，团子的颜色很有讲究。一共有 $N$ 种颜色，编号为 $1,2,\dots,N$。

**一流团子串**是 JOI 君的店里的招牌食品。制作一个一流团子串，需要将 $N$ 个**颜色不同**的团子串在一根竹签上。

对于每一种颜色，JOI 君都制作了 $M$ 个这种颜色的团子。因此，JOI 君总共有了 $NM$ 个团子。这些团子被编号为 $1,2,\dots,NM$。使用这些团子和 $M$ 根竹签，JOI 君希望串出 $M$ 个一流团子串。

为了避免在颜色上犯错误，JOI 君将会启用他的团子检测器。如果 JOI 君输入一些团子的编号，团子检测器会返回使用这些团子能制作的一流团子串的个数的最大值。当然，前提是充分使用竹签。

JOI 君希望能通过使用若干次团子检测器将 $NM$ 个团子分为 $M$ 组。其中，每一组包含 $N$ 个团子，且每种颜色的团子恰有一个。

JOI 君想在使用不超过 $50\,000$ 次团子检测器的前提下完成这件事。

请写一个程序，对于给定的团子的信息，实现 JOI 君使用不超过 $50\,000$ 次团子检测器来完成任务的策略。

---

**【实现细节】**

你的程序需要实现以下函数。

  - `void Solve(int N, int M)`。  
    对于每组测试数据，该函数会被调用恰好一次。
      - 参数 $\texttt N$ 是团子的颜色数 $N$。
      - 参数 $\texttt M$ 是 JOI 君想制作的一流团子串的个数 $M$。

你的程序可以调用以下函数。

  - `int Query(const std::vector<int> &x)`。  
    你的程序可以通过调用这个函数来使用团子检测器。
      - 参数 `x` 是输入给团子检测器的团子的编号列表。
      - 该函数返回使用 `x` 中的团子能制作的一流团子串的最大值。
      - `x` 中的每个元素都应当是 $[1,NM]$ 中的整数。否则你的程序会被判定为 **Wrong Answer [1]**。
      - `x` 中的元素应当互不相同。否则你的程序会被判定为 **Wrong Answer [2]**。
      - 你的程序不得调用该函数超过 $50\,000$ 次。否则你的程序会被判定为 **Wrong Answer [3]**。

  - `void Answer(const std::vector<int> &a)`。  
    你的程序可以通过调用这个程序来报告分组方案。
      - 参数 `a` 是你分出的一组团子的编号列表。
      - `a` 的长度应当为 $N$。否则你的程序会被判定为 **Wrong Answer [4]**。
      - `a` 中的每个元素都应当是 $[1,NM]$ 中的整数。否则你的程序会被判定为 **Wrong Answer [5]**。
      - 在整个过程中，同一个团子不能出现在参数中多于一次。否则你的程序会被判定为 **Wrong Answer [6]**。
      - 如果用 `a` 中的团子并不能制作一个一流团子串，你的程序会被判定为 **Wrong Answer [7]**。
      - 该函数应当被调用恰好 $M$ 次。否则你的程序会被判定为 **Wrong Answer [8]**。
  
**【提示】**
  
  - 你的程序可以实现其他函数以供内部使用，或者使用全局变量。
  - 你的程序不得使用标准输入输出流，也不得以任何方式访问任何文件。然而，你可以输出调试信息到标准错误流。
  
**【编译与测试运行】**
  
你可以从「附加文件」中下载样例评分器来测试你的程序。「附加文件」中也提供了你应当提交的程序的一个样例。

样例评分器即 `grader.cpp`。为了测试你的程序，请将 `grader.cpp,dango3.cpp` 放置在同一个目录下，并执行如下命令来编译你的程序。

`g++ -std=gnu++17 -O2 -o grader grader.cpp dango3.cpp`

若编译成功，将会生成一个可执行文件 `grader`。

请注意，实际使用的评分器与下发的样例评分器不同。样例评分器仅会有单个进程，从标准输入中读取输入数据并将结果输出到标准输出。
  
**【样例评分器输入格式】**
  
第一行，两个正整数 $N,M$。表示团子的颜色数和 JOI 君想制作的一流团子串的个数。

第二行，$N\times M$ 个正整数 $C_1,C_2,\dots,C_{NM}$。其中 $C_i$ 是一个 $[1,N]$ 内的正整数，表示第 $i$ 个团子的颜色。
  
**【样例评分器输出格式】**
  
- 如果你的程序被判定为正确，样例评分器会输出调用 `Query` 的次数，如 “$\texttt{Accepted: 2022}$”。
- 如果你的程序被判定为任意一种 Wrong Answer，样例评分器会输出其类型，如 “$\texttt{Wrong Answer [4]}$”。

如果你的程序属于多种 Wrong Answer，样例评分器只会输出其中一种。

## 说明/提示

**【样例交互】**

这里是样例评分器的一组样例输入和对应的交互过程。

```plain
3 2
3 3 1 2 1 2
```

|调用|调用|返回值|
|:-|:-|:-|
|$\texttt{Solve(3, 2)}$|||
||$\texttt{Query([])}$|$\texttt 0$|
||$\texttt{Query([4, 2, 1, 3])}$|$\texttt 1$|
||$\texttt{Query([3, 4, 5])}$|$\texttt 0$|
||$\texttt{Query([2, 6, 5])}$|$\texttt 1$|
||$\texttt{Query([6, 5, 4, 3, 2, 1])}$|$\texttt 2$|
||$\texttt{Answer([1, 6, 5])}$||
||$\texttt{Answer([2, 3, 4])}$||

注意，这组样例**不满足任意子任务的限制**。

从「附加文件」中可以下载到 $\texttt{sample-02.txt}$，其满足子任务 $1$ 的限制。

**【数据范围】**

对于所有测试数据，满足：

- $1 \le C_i \le N$ $(1 \le i \le NM)$。
- 对于每个 $j$ $(1 \le j \le N)$，恰有 $M$ 个 $i$ $(1 \le i \le NM)$ 满足 $C_i = j$。  
- $N,M$ 是正整数。
- $C_i$ $(1 \le i \le NM)$ 是一个 $[1,N]$ 内的整数。

详细子任务附加限制及分值如下表所示：

|子任务编号|附加限制|分值|
|:-:|:-:|:-:|
|$1$|$N=M=4$|$2$|
|$2$|$N=100$，$M=10$|$5$|
|$3$|$N=200$，$M=25$|$15$|
|$4$|$N=400$，$M=25$|$78$|

# 题解

## 作者：1qaz234567pzy (赞：10)

一道交互好题~~恶心题~~

感谢 [Aaronwrq](https://www.luogu.com.cn/user/426313) 大佬的帮助，题解有所借鉴 [Jason0211](https://www.luogu.com.cn/user/724069) 的[题解](https://www.luogu.com.cn/blog/Jason0211/solution-p9529)。


------------






## 思路

我们可以把每个串看成一个集合，所以总共有 $m$ 个集合，对于每个团子，我们尝试将其插入某个集合中。插入时需要维护以下性质：

一：每个集合内的每个团子的颜色互不相同。

二：同一种颜色的团子是按串串的编号从左到右放到每个串串中的。

所以现在问题变为了如何检验这个颜色的团子放在哪里。


而我们似乎只能用 `Query(x[])` 函数来检验，但是我们总共只能调用 $50000$ 次 `Query(x[])` 函数。而团子的总数最多有 $m \times n$ 即 $10000$ 个。所以我们需要在最多调用 $5$ 次 `Query(x[])` 函数的情况下来求出这个团子放在哪。


我们根据这些想到可以二分，因为根据性质二，这种颜色的团子一定是前面一段串串有，后面的串串全部都没有的，所以可以通过二分的方式来查找。而二分要调用大约 $\log_2 25$ 次 `Query(x[])` 函数，而 $4 \le \log_2 25 \le 5$，刚好小于等于 $5$，所以我们接下来就要考虑怎么二分了。

我们先假设前几个串串上已经有了一些团子，就像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/0w72nkkk.png)

那么对于下一个这种颜色的团子，如果我们放在这两个已经有这种颜色的串上，就像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/tw0lp5n9.png)

由于这种颜色的团子的个数等于总的串串数，所以如果我们放在这两个已经有这种颜色的串上的话，所有剩下的团子就没有办法组成剩下串串的个数个一流团子串。（建议自己在纸上画一下）欸，这不就可以用到 `Query(x[])` 函数了吗！

我们设当前的团子放在第 $mid$ 个串上，那么如果所有没有处理的团子和第 $mid+1$ 到第 $m$ 个串上的所有团子加起来能做出至少 $m-mid$ 个一流团子串的话，这个团子就可以放在第 $mid$ 个串上。就像这样（能放的情况）：

![](https://cdn.luogu.com.cn/upload/image_hosting/3n9egbnv.png)

我们就用这个进行二分，如果能做出至少 $m-mid$ 个一流团子串，我们就把 $r$ 赋值为 $mid-1$，同时用 $ans$ 记录下 $mid$，否则就把 $l$ 赋值为 $mid+1$，二分的边界条件为 $l \le r$。（至于为什么这么二分，读者可以自己研究一下）二分完后就把这个团子放入第 $ans$ 个串串中。把每个团子都这样处理后这道题就做完了。

核心代码如下：

```cpp
//注意是交互题
namespace {

    int n,m;
    vector<int> v[1000];
}  
bool work(int h,int j)
{
	vector<int> G;
    for(int qqq=h+1;qqq<=n*m;qqq++)
    {
        G.push_back(qqq);
    }
    for(int qqq=j+1;qqq<=m;qqq++)
    {
        for(int qq=0;qq<v[qqq].size();qq++)
        {
            G.push_back(v[qqq][qq]);
        }
    }
    return Query(G)>=m-j;
}
void Solve(int N, int M) 
{
    n=N;
    m=M;
    for(int qqq=1;qqq<=n*m;qqq++)
    {
        int ll=1,rr=m,mid,ans=-1;
        while(ll<=rr)
        {
            mid=(ll+rr)>>1;   
			int www=work(qqq,mid);     	
            if(www)
            { 	
				 rr=mid-1;
                ans=mid;//记录mid
            }
            else
            {
                ll=mid+1;
            }
        }
        v[ans].push_back(qqq);
    }
    for(int qqq=1;qqq<=m;qqq++)
    {
        Answer(v[qqq]);
    }
}

```

[AC记录](https://www.luogu.com.cn/record/121461449)





---

## 作者：myyes (赞：9)

日本师傅出的题还是比较滴有思维含量，同学们要认真学习，就是这个交互勒格式不太规范哈！

#### 题意

有 $n$ 种钥匙，每种钥匙有 $m$ 个，一开始每把钥匙的种类未知。一位大师傅要撇 $m$ 串钥匙，每串上面都有 $n$ 个种类不同的钥匙。他有一个机器，给这个机器一个钥匙集合，机器可以返回这个集合最多可以串多少串钥匙，要求在使用不超过 $50000$ 次机器的情况下串好钥匙。$n\le 10^4,m\le 25$

#### 题解

经典的钥匙-锁模型的咩。考虑暴力坐板凳囊个坐，我们依次枚举每把钥匙，再枚举每个串，判断这把钥匙是否能挂到这个串上。容易发现，如果把除了这串上已经有的钥匙以及当前枚举的钥匙之外的所有钥匙都放进机器里面问一哈，如果结果 $\ge n-1$ 就证明这把钥匙可以挂到这一串上。

但是这个俎法要 $nm^2$ 次询问，超限了撒。考虑 $50000$ 大概是 $nm\log m$ 的样子，套路的想到了二分。设 $S$ 是当前可能的钥匙串的集合，怎么判断能不能把钥匙 $x$ 放到这个集合内呢？我们还是按照之前的方法，把除了 $x$ 和在 $S$ 中的钥匙之外的所有钥匙放到一起问一遍，如果结果 $\ge n-|S|$ 就证明 $S$ 中可以放。我们每次将可能的集合分成两半，选择一边判断，最后就可以用 $\log m$ 的代价找到一个合法的钥匙串了咩！

```cpp
#include <vector>
using namespace std;
int Query(const std::vector<int> &x);
void Answer(const std::vector<int> &a);
vector<int>keys[35];
bool seat[10005];
bool check(int N,int M,int l,int r,int k)
{
for (int i=1;i<=N*M;++i) seat[i]=0;
 for (int i=l;i<=r;++i)
  for (int j:keys[i]) seat[j]=1;
 vector<int>ask;
 	seat[k]=1;
 for (int i=1;i<=N*M;++i)
 if (!seat[i]) ask.push_back(i);
 return Query(ask)>=M-(r-l+1);
}
int sit(int N,int M,int x) {
  int l=1,r=M,mid;
   while (l<r)
    {
	mid=(l+r)/2;
  if (check(N,M,l,mid,x)) r=mid;
	else l=mid + 1; 
  } return l;
}
void Solve(int N,int M){
  for (int i=1;i<=M;++i)keys[i].push_back(i);
 for (int i=M+1;i<=N*M;++i)
	keys[sit(N,M,i)].push_back(i);
  for (int i=1;i<=M;++i) Answer(keys[i]);
}
```

---

## 作者：FyFive (赞：7)

### 简要题意

交互，调用至多 $50000$ 次 ``Query(x[])`` 函数将所有团子分为 $M$ 个集合，每个集合中的颜色恰好为 $1$ 到 $N$，每次询问返回传入的元素最多能填满多少个集合，其中传入的数组为下标数组。

### 正文

这题，6。

本题可以看数据范围猜复杂度进而推出解法。

首先，看到 $N=400,M=25 \Rightarrow NM=10000$，而 $NM$ 即为团子个数。

考虑剩下差的 $5$ 倍会塞点什么，不难联想到 $4 \leq \log_2 25 \leq 5$，那么询问次数大概就是 $O(NM\log M)$ 的了。

看着这个复杂度，不难想到“对于每个团子，用 $\log M$ 次询问找到这个团子应该放在哪个集合”，那么考虑这个 $\log M$ 应该是什么东西，发现这个 $\log M$ 应该是二分的复杂度，那么做法就应该是二分什么东西了。

接下来考虑怎么设计二分。

考虑到如果已经放过的团子很分散，也就是没什么规律，二分起来就相当困难，那么考虑一个类似于“把所有同颜色的团子相邻放置”的事情，那么考虑同一个颜色从左到右依次填，这样二分就可以找到需要放的位置了。

想到这里发现复杂度各种对，那么问题就只剩下考虑怎么二分了。

猜想二分的实现，如果某一次的 $mid$ 左边全填完了，那么 $l \leftarrow mid+1$，否则 $r \leftarrow mid$，问题进一步转化为怎么询问来判断连续的一段同一个颜色有没有填满。

发现硬刚不大好搞了。接下来，思路先搁置，思维发散开，我们看部分分来考虑一个最暴力的东西。

观察最基础的 $N=4,M=4$，想想暴力是什么？

不难想到一种最暴力的东西，对于所有的 $C_{16}^4=1820$ 个组合，全部询问一遍，然后把四个不重的返回值为 $1$ 的数组输出出来。并且，**全集减去 $4$ 个数的 $C_{16}^{12}=1820$ 次询问是相同的效果。**

这时候，只要你思维够发散并联想到了木桶效应，你就能想到，如果我们询问全集减去从左端开始的一个区间，一次次地问就能知道什么时候左边有一个颜色出现了多次，因为右边对应的颜色相应的在减少，少到低于上一次的返回值（即这次减少更新了返回值）。有点抽象，会意一下就好。

这时候就可以惊喜地发现，把这个东西带入刚刚搁置下来的思路里，就能解决掉问题了。

具体的，我们每次询问**全集减去 $mid$ 左侧所有集合和当前正在做的元素的集合**，这样左侧（不包括当前在做的元素）所有颜色都最多有 $mid$ 个，于是我们再减去当前在做的这个元素，依据木桶效应，如果左侧与当前元素相同的颜色已经全部占满了，那么将全集再减一个此颜色的团子返回的就会是 $M-mid-1$，如果返回值更大就代表没占满，那么应该填到左侧区间。当然，返回值不可能变大，如果变大那就是你写挂了。

于是，本题就愉快的切了。时间给了 10s，怎么写都能过吧。

代码比思路优美的多。

### Code
```cpp
inline int qis(int x,int X)
{
	vector<int>nw;memset(to,0,sizeof(to));
	for(int i=1;i<=x;++i)for(int v:hv[i])to[v]=1;
	to[X]=1;for(int i=1;i<=n*m;++i)if(!to[i])nw.push_back(i);
	return Query(nw);
}
inline int gta(int x)
{
	int l=1,r=m;
	while(l<r){int mid=l+r>>1;if(qis(mid,x)==m-mid-1)l=mid+1;else r=mid;}
	return l;
}
```

---

## 作者：Alex_Wei (赞：3)

### [P9529 [JOISC2022] 一流团子师傅](https://www.luogu.com.cn/problem/P9529)

一个神秘的简单做法。

考虑怎么找到一组团子：设下标集合为 $S$。按任意顺序枚举 $S$ 中的元素 $s_1, s_2, \cdots, s_{|S|}$。每次从 $S$ 中删去 $s_i$，若询问 $S$ 得到的结果为 $M - 1$，说明 $s_i$ 可以加入当前团子串。否则将 $s_i$ 重新插入 $S$。当团子串大小为 $N$ 时退出，$M$ 减小 $1$。

按随机顺序枚举时，感性理解一下，很快就能找到团子串，个人猜测期望次数是 $N\log M$。可以通过本题，极限数据询问次数在 $4.3\times 10 ^ 4\sim 4.8\times 10 ^ 4$ 之间波动。

```cpp
#include <bits/stdc++.h>
using namespace std;
mt19937 rnd(0x1064822E);
int Query(const vector<int> &x);
void Answer(const vector<int> &a);
void Solve(int N, int M) {
  vector<int> rem;
  for(int i = 1; i <= N * M; i++) rem.push_back(i);
  for(int i = 1; i < M; i++) {
    shuffle(rem.begin(), rem.end(), rnd);
    vector<int> pack;
    pack.push_back(rem.front());
    rem.erase(rem.begin());
    while(pack.size() < N) {
      int v = rem.front();
      rem.erase(rem.begin());
      if(Query(rem) == M - i) pack.push_back(v);
      else rem.push_back(v);
    }
    Answer(pack);
  }
  Answer(rem);  
}
```

---

## 作者：yzljy (赞：3)

第一篇题解~  
今天下午学长刚讲了交互题，写完交上去一发过，似乎还是最优解？  
[题目传送门](https://www.luogu.com.cn/problem/P9529)

## 题意简述

有 $n$ 种物品，每种有 $m$ 个，现在这些物品被随机打乱了（你并不知道顺序）。你每次可以选择**任意多个**（即给出一个向量）进行询问，每次询问会告诉你这些物品中 $1$ 到 $n$ 这 $n$ 种物品中，最少的那种物品的**数量**。最后你需要给出 $m$ 个**完全不同**的向量，每个向量必须包含这 $n$ 种物品，每种物品**有且仅有** $1$ 个，在不多于 $50000$ 次询问下完成。

## 思路

注意到只能在 $50000$ 次询问内完成，而物品最多有 $n \times m$ 共 $10000$ 个，最后对于每个物品，我们还剩下了 $5$ 次查询机会。因为 $m \le 25$，所以 $\log m < 5$，因此我们可以考虑二分（这个其实还是比较难想的？）

我们令 $M$ 表示当前处理的需要提交的向量的数量，$mid$ 变量表示二分的值，即$mid = \left \lfloor \frac{M}{2} \right \rfloor $ 所以当 $M=1$ 的时候，我们就可以提交当前这一个向量。我们每次将一个大向量从前往后一个个遍历（具体方法后面会讲），将其拆成两个小向量，再递归处理，递归到最后直接提交答案，可以计算最多需要询问 $43600$ 次，时间复杂度也是 $O(n \log m)$ 的，可以通过。

## 实现

最开始，我们将 $n \times m$ 这么多个数全部扔进一个叫做 $x$ 的向量中，我们要将 $x$ 这个向量拆成两个小的向量 $y$ 和 $z$。使得 $y$ 这个向量中有 $mid$ 串未处理的物品，$z$ 中有 $M-mid$ 串未处理的物品。

根据查询的性质：返回 $1$ 到 $n$ 这 $n$ 种物品中最少的一种物品的数量。因此一个向量可以组成多少个串，就是对这个向量进行询问后的返回值。

因此我们从 $x$ 这个向量的第一个元素开始遍历，假如去掉这一个物品后，我们进行一次查询，发现返回值仍是**大于等于** $mid$ 的，那么就说明，去掉这个物品后，剩下的物品也至少也可以组成 $mid$ 个串，那么这个物品就可以扔到 $z$ 这个向量。反之当返回值**小于** $mid$ 的时候，就说明去掉这个物品后，剩下的物品不能够组成 $mid$ 个串，因此这个物品是**必须的**，需要放到 $y$ 向量。再依次对 $y$ 和 $z$ 递归处理，当一个向量长度为 $n$ 时，那么就说明这是一个合法的串，提交答案即可。

**注意！** 当去掉这个物品后，剩下的物品不能组成至少 $mid$ 根串的时候，我们是需要把它扔进 $y$ 这个向量的，但是它**依然**应该被保留在 $x$ 这个向量中，否则在后面继续遍历的时候，无论如何返回的询问值**总是**小于 $mid$ 的。因此在代码实现的时候，我们其实并不需要真的开两个向量，自然的当 $x$ 中可以扔去 $z$ 的扔完后，剩下的其实就是原先$y$ 这个向量。

具体的，我们维护一个 $pos$ 变量，记录当前应该取的是 $x$ 这个向量中的哪个元素的位置，再另开一个变量记录一下这个元素的值。因为我们有时需要扔进另一个向量，有时需要继续保留。每次我们先将这个元素从向量中弹出，进行查询后根据返回值决定要放回去还是丢进另一个变量。在扔走的时候，$pos$ 是不变的，当留下的时候，将 $pos$ 增加 $1$。

具体可以看下面几张图来理解：
![](https://cdn.luogu.com.cn/upload/image_hosting/2ob88zt8.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/b2txfmnd.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/sycpxf00.png)

为什么这样是正确的？因为我们在每次处理 $x$ 这个向量时，都保证了处理后的 $y$ 向量和 $z$ 向量中，分别可以组合出 $mid$ 个串和 $M-mid$ 个串。当最后 $M=1$ 的时候，也就自然的一定可以组合出 $1$ 个串，因此这也就是答案。

最后处理一些细节，代码也很容易完成，似乎是最短的，就可以愉快地 AC 啦~

## 代码

```cpp
#include <vector>
void Solve(int N, int M);
int Query(const std::vector<int> &x);
void Answer(const std::vector<int> &a);
void work(std::vector<int> &a,int m){//递归处理
	if(m==1){//得到答案
		Answer(a);
		return;
	}
	int mid=m/2,cache;
	std::vector<int> x;
	int pos=0;
	int len=a.size();
	for(int i=1;i<=len;i++){
		cache=a[pos];
		a.erase(a.begin()+pos);
		if(Query(a)<mid) a.insert(a.begin()+pos,cache),pos++;//返回值大于等于mid，扔进另一个向量
		else x.push_back(cache);//返回值小于mid，需要扔回去
	}
	work(a,mid);
	work(x,m-mid);//向下递归继续处理
}
void Solve(int N,int M){
	std::vector<int> s;
	for(int i=1;i<=N*M;i++) s.push_back(i);//将最开始的N*M个数全部丢进一个初始向量
	work(s,M);
}
```

---

## 作者：diqiuyi (赞：2)

看到有篇题解说他的做法是目前最优，但是我好像只需要大约 $25500$ 次（并且没有怎么卡）？

考虑怎么找到一个一流团子串。显然有一个需要候选序列长度次询问的做法，即把每个数去掉，再看是否合法，如果不合法就意味着必须选上。我们找 $m$ 次可以做到 $O(n^2m)$ 次询问。

注意到当序列较长时，我们随机删掉较多位置后也很有可能合法，所以我们考虑设一个阈值 $B$，当序列长度 $len>Bn$ 时，以一个较小的概率删掉部分数，再继续递归下去；否则我们直接用 $O(len)$ 次询问找即可。我们直接对每个数以 $\dfrac{1}{n}$ 的概率删掉它就可以做到大约 $37500$ 次。可以实现得精细一些，在较长时以更大的概率删数，随便优化一下就可以做得更好。例如当删除概率 $p=\dfrac{n^2}{len}$ 时可以做到大约 $25500$ 次。
```cpp
mt19937 rnd(time(0));
void solve(int n,int m,vector<int> &v){
	if(m==1) return Answer(v);
	vector<int> v1=v,vv;
	int tot=0;
	while(v1.size()>2*n){
		int p=(n==4?2:n/(v1.size()/n));
		vv.clear();
		for(int x:v1)
			if(rnd()%p)	
				vv.push_back(x);
		if(vv.size()==v1.size()||vv.size()<n) continue;
		if(Query(vv))
			v1=vv,tot=0;
	}
	vv=v1;
	int cnt=0;
	for(int x:vv){
		v1.erase(lower_bound(v1.begin(),v1.end(),x));
		if(cnt<n&&!Query(v1))
			v1.insert(lower_bound(v1.begin(),v1.end(),x),x),cnt++;
	}
	Answer(v1);
	for(int x:v1) v.erase(lower_bound(v.begin(),v.end(),x));
	return solve(n,m-1,v);
}
void Solve(int n,int m){
	vector<int> vc;
	for(int i=1;i<=n*m;i++)
		vc.push_back(i);
	solve(n,m,vc);
}
```

---

## 作者：Jason0211 (赞：2)

# 题目传送门
[P9529 [JOISC 2022 Day4] 一流团子师傅](https://www.luogu.com.cn/problem/P9529)

# 解法
本题解有所借鉴这位大佬的博客文章[JOISC 2022](https://www.cnblogs.com/cc0000/p/17497161.html)

首先，我们可以想到顺次填满每一个串。然后，我们考虑对每个团子分组，将新来的团子加入到还没有出现这种颜色的串上，这样问题就转化为怎样快速判断从哪个串开始没有这种颜色的。

我们想到可以二分，因为这种颜色的团子一定是前面一段有，后面全部都没有的。简单证明一下：我们是从前往后顺次放置每一种颜色的，所以有这种颜色的串一定是从 $1$ 开始的一段连续序列。

接下来就是二分的过程：具体的判断就是把所有团子中排除掉 $1$ 至 $mid$ 的区间的所有团子加上当前要考虑的团子。如果不排除当前要考虑的团子，那么能组成的串的数量应当是大于等于 $m-mid$，但是删掉这一个之后，如果 $mid$ 以及之前是有这个颜色的，那么一定会减少一个串，使得串的数量小于 $m-mid$，这样就能直接二分了。

具体细节见代码：
```cpp
#include<bits/stdc++.h>
void Solve(int N, int M);
int Query(const std::vector<int> &x);
void Answer(const std::vector<int> &a);

using namespace std;

namespace{
	int n,m;
	vector<int> V[505];
}

int work(int now,int pos)
{
	vector<int> G;
	for(int i=now+1;i<=n*m;i++) G.push_back(i);
	for(int i=pos;i<=m;i++)
	{
		for(int j=0;j<V[i].size();j++)
		{
			G.push_back(V[i][j]);
		}
	}
	return Query(G)<m-pos+1;
}

void Solve(int x,int y)
{
	n=x,m=y;
	for(int i=1;i<=n*m;i++)
	{
		int l=1,r=m,pos;
		while(l<=r)
		{
			int mid=(l+r)/2;
			if(work(i,mid)) pos=mid,l=mid+1;
			else r=mid-1;
		}
		V[pos].push_back(i);
	}
	for(int i=1;i<=m;i++) Answer(V[i]);
}
```

---

## 作者：mskqwq (赞：1)

很有趣的思维题。

想了一个询问次数 $O(nm\log nm)$ 的垃圾做法，可以获得高贵的 $7$ 分！

大概思路是确定每个位置的颜色，考虑一次确定出某个颜色的所有位置，找到一个位置 $x$ 使得 $[1,x-1]$ 的最小出现次数为 $0$，$[1,x]$ 为 $1$，那么 $x$ 的颜色一定和 $[1,x-1]$ 内的数都不一样，并且所有与 $x$ 不同的颜色都在 $[1,x-1]$ 中出现过。接着在后面找到第一个位置 $y$ 使得询问 $[1,y]\setminus\{x\}$ 的答案为 $1$，那么 $x$ 和 $y$ 的颜色一定相同，以此类推可以找到所有与 $x$ 相同颜色的位置。把这些位置删掉然后递归处理即可。以上操作都能二分优化。

这个做法貌似有救，可以上线段树优化后面的二分。具体地，对每个位置都二分一次有点浪费，直接在线段树上 dfs，只有子树内有这个颜色才递归进这个子树。不过没写也不确定能不能过。

以下是正常解法。观察限制发现询问次数大概是 $O(nm\log m)$ 的，思考那个 $\log m$ 是怎么来的，再观察一下只要求分组而不要求区分每个团子的颜色这个东西，考虑分治。

取一个 $mid=\frac 1 {2n}(r-l+1)$，首先把当前区间 $[l,r]$ 内的数都加入询问的集合里，然后尝试一个个删除，如果删掉一个数后这个集合的答案 $\ge mid$，那么把它丢到右边，否则丢到左边然后重新加入询问集合。然后我们就成功把团子分成平均的两部分了，可以通过本题。

```cpp
#include <set>
#include <map>
#include <queue>
#include <ctime>
#include <cstdio>
#include <vector>
#include <cassert>
#include <cstring>
#include <algorithm>
#define fi first
#define se second
#define ep emplace
#define MISAKA main
#define ll long long
#define eb emplace_back
#define pii pair<int,int>
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define _rep(i,a,b) for(int i=a;i>=b;--i)
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define FIO(FILE) freopen(FILE".in","r",stdin),freopen(FILE".out","w",stdout)
using namespace std;

void Solve(int n, int m);
int Query(const std::vector<int> &x);
void Answer(const std::vector<int> &a);

int n,m,a[10101];

void solve(int l,int r){
    vector<int> L,R,v;
    rep(i,l,r) v.eb(a[i]);
    if(r-l+1==n) return Answer(v);
    int mid=(r-l+1)/n/2,k=n*mid;
    rep(i,l,r){
        v.erase(find(v.begin(),v.end(),a[i]));
        if(Query(v)<mid) L.eb(a[i]),v.eb(a[i]);
        else R.eb(a[i]);
    }
    rep(i,l,l+k-1) a[i]=L[i-l];
    rep(i,l+k,r) a[i]=R[i-l-k];
    solve(l,l+k-1);solve(l+k,r);
}

void Solve(int N,int M){
    n=N,m=M;
    rep(i,1,n*m) a[i]=i;
    solve(1,n*m);
}
```

---

## 作者：lalaouye (赞：0)

本题最优解来了！

我的做法有四胜：

1. 用时最短，仅需 $0.1$ 秒出头。
2. 操作次数最少，只有 $37000$ 次左右。
3. 只需要关心查询结果是否为 $0$。
4. 空间占用最少。

考虑只找出一个团子怎么做。发现可以枚举每个食品看是否能被删，即查询总集合删去它之后的集合。如果查询结果为 $0$ 则不能删，保留。否则直接删掉。

这样我们发现找出团子后可以进入下一个类似的问题，可惜这样得查询差不多 $125000$ 次。

于是我们可以考虑把 $B$ 个捆起来查，如果连着这 $B$ 个能够一起删掉就直接删，否则再在这 $B$ 个里面枚举。

理论上 $B=5$ 最坏情况最优，差不多要 $75000$ 次。最坏情况即需要的数分布与若干不同块中，即每轮最多有 $400$ 个块删去需枚举。

但是仔细想想这个最坏情况根本不可能存在。因为一个数字有多个，我们随机化之后删前面的块只有极小概率才会删完，所以所需操作数极少。当 $B$ 取 $15$ 或 $20$ 时，实际只有 $37000$ 左右，更大的没测了。


```cpp
#include "dango3.h"
#include <bits/stdc++.h>
#define rep(i, l, r) for (int i (l); i <= r; ++ i)
#define eb emplace_back
using namespace std;
constexpr int N = 1e4 + 5;
bool vis[N];
mt19937 rnd (20090421);
void Solve (int N, int M) {
  vector <int> vec;
  vec.resize (N * M);  
  rep (i, 0, N * M - 1) vec[i] = i + 1;
  rep (t, 1, M) {
    shuffle (vec.begin (), vec.end (), rnd);
    int ct (0);
    for (int i = 1; i <= N * (M - t + 1); i += 20) {
      vector <int> ask;
      int cnt (0);
      while (++ cnt <= 20 && vec.size ()) {
        ask.eb (vec.front ());
        vec.erase (vec.begin ());
      }
      if (Query (vec)) continue;
      ++ ct;
      while (ask.size ()) {
        int u = ask.back (); ask.pop_back ();
        for (auto v : ask) {
          vec.eb (v);
        }
        int ret = Query (vec);
        for (auto v : ask) {
          vec.pop_back ();
        }
        if (! ret) vec.eb (u);
      }
    }
    for (auto v : vec) vis[v] = 1;
    Answer (vec); vec.clear ();
    rep (i, 1, N * M) if (! vis[i]) vec.eb (i);
  }
}

```

---

## 作者：Augen_stern (赞：0)

## Part 1: 分析求解

我们可以先考虑一种暴力：

每次从左往右扫描整个团子集合，插入进询问集合，直到询问出此时你的询问集合中包含了一串团子（即每种颜色都至少有一个）；

接着，再对这个询问集合，尝试删掉每一个团子，看能否包含一串完整的团子，若删掉后无影响，则直接删了，否则，它就是在这个集合中那一串团子中，是必要的，可以作为待会儿输出的元素。

然后重复操作，就把整个团子集合给拆开了。

可惜这个暴力效率较低，考虑优化：

我们可以二分出包含一串团子的集合的左端点和右端点，然后再进行上述操作。但这样会被特殊数据卡，所以直接 ```random_shuffle``` 一下就可以了，因为考虑所有颜色随机分布在数轴上，包含所有颜色的期望长度就是颜色种数，所以这样在随机数据下很快，而在数据中询问次数差不多就 $40000$ 出头而已。

## Part 2: CODE

```cpp
//#pragma GCC optimize(3)
#include<iostream>
#include<climits>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<ctime>
#include<algorithm>
#include<queue>
#include<map>
#include<set>
#include<vector>
#include "dango3.h"
//#include<random>
//#include<chrono>
//#define int long long
//#define double long double
using namespace std;
const long long INF=LLONG_MAX/2ll;
const long long mod=998244353;
//const long long mod=1000000007;
const double Pai=acos(-1);
const double eps=1e-8;
vector<int> v,ex;
int n,m,cnt=0;
int vst[1000005],be[1000005],vis[1000005],b[1000005];
int mp[405][30];
bool check(int l,int r) {
	for(int i=l;i<=r;i++) v.push_back(b[i]);
	int res=Query(v);v.clear();
	return res>=1;
}
bool del(int x,int l,int r) {
	for(int i=l;i<=r;i++) if(i!=x&&!vst[i]) v.push_back(b[i]);
	int res=Query(v);v.clear();
	return res>=1;
}
void solve() {
	b[0]=0;
	for(int i=1;i<=n*m;i++) {
		if(!vis[be[i]]) b[++b[0]]=be[i];
	}
	int l=1,r=b[0],L=0,R=0;
	while(l<=r) {
		int mid=(l+r)>>1;
		if(check(1,mid)) r=mid-1,R=mid;
		else l=mid+1;
	}
	l=1,r=R,L=0;
	while(l<=r) {
		int mid=(l+r)>>1;
		if(check(mid,R)) l=mid+1,L=mid;
		else r=mid-1;
	}
	for(int i=L;i<=R;i++) if(del(i,L,R)) vst[i]=1;
	for(int i=L;i<=R;i++) if(!vst[i]) ex.push_back(b[i]),vis[b[i]]=1;
	for(int i=1;i<=b[0];i++) vst[i]=0;
	Answer(ex);ex.clear();
	random_shuffle(be+1,be+n*m+1);
}
void Solve(int nn,int mm) {
	n=nn,m=mm;
	for(int i=1;i<=n*m;i++) be[i]=i;
	random_shuffle(be+1,be+n*m+1);random_shuffle(be+1,be+n*m+1);random_shuffle(be+1,be+n*m+1);
	random_shuffle(be+1,be+n*m+1);random_shuffle(be+1,be+n*m+1);random_shuffle(be+1,be+n*m+1);
	for(int i=1;i<m;i++) solve();
	for(int i=1;i<=n*m;i++) if(!vis[be[i]]) ex.push_back(be[i]);
	Answer(ex);ex.clear();
}
```

---


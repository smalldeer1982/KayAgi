# [湖北省选模拟 2023] 环山危路 / road

## 题目描述

R 国有 $n$ 座城市，编号从 $1$ 到 $n$。这些城市两两之间都有道路连接，形成一个图的结构。不过，这些路修得很烂，每条路都有一个固定的方向，车只能按照这个方向行驶；路还是一次性的，也就是说最多只能过一辆车。

现在 R 国正在制定防灾减灾预案。你需要帮助 R 国计算，如果 $t_i$ 号城市发生了灾难，并且 $s_{i,1},s_{i,2},\dots,s_{i,k_i}$ 这些城市有充足的救灾物资（可以认为它们都拥有可以装无数辆车的物资），那么最多能从这些城市运送几车物资到达 $t_i$。车只能走城间的那些一次性道路，不过车在到达 $t_i$ 之前是可以经过多个城市和多条道路中转的。

## 说明/提示

### 样例 1 解释

城市间的路如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/3he9r0j2.png)

这是答案对应的一种可能的方案：

第一次询问中，一辆车走 $1 \rightarrow 2$，另一辆走 $4 \rightarrow 1 \rightarrow 5 \rightarrow 2$；

第二次询问中，一辆车走 $1 \rightarrow 5$，一辆走 $1 \rightarrow 2 \rightarrow 3 \rightarrow5$，还有一辆走 $4 \rightarrow 5$。

### 子任务

对于所有测试数据，保证 $1 \le n \le 3000$，$1 \le m,\sum\limits_{i=1}^mk_i \le 30000$。

![](https://cdn.luogu.com.cn/upload/image_hosting/d7a2om1c.png)

特殊性质 A：保证所有询问的 $t_i$ 相等。

特殊性质 B：保证 $u$ 与 $v$ 之间的路从 $\min(u,v)$ 通向 $\max(u,v)$。

## 样例 #1

### 输入

```
5 2
01001
00110
10001
10101
01000
2 2 1 4
5 2 4 1
```

### 输出

```
2
3
```

## 样例 #2

### 输入

```
见选手目录下的 road/road2.in 与 road/road2.ans。```

### 输出

```
见选手目录下的 road/road2.in 与 road/road2.ans。```

# 题解

## 作者：Miraik (赞：8)

作为 d2t1 可以说是非常优雅的签到题。~~但是我签不上，蚌埠住了。~~

题意就是竞赛图求最大流，但暴力跑肯定不行，于是我们考虑转最小割，研究割出的两个点集的性质。

假设起点所在的点集为 $S$，终点所在的点集为 $T=V-S$，那么这个割的大小即 $f(S,T)=\sum\limits_{u \in S} \sum\limits_{v \in T} e_{u,v}$。

考虑竞赛图的性质，我们发现有 $f(S,T)+f(T,S)=|S| \times |T|$，$f(S,T)-f(T,S)=\sum\limits_{u \in S} out_u - in_u$。二式联立容易求得 $f(S,T)$。那么我们需要在 $|S|$ 相同时最小化 $\sum\limits_{u \in S} out_u - in_u$。那我们排序后贪心地取就好了。时间复杂度 $O(nm)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline void chkmin(int &x,int y){ x=min(x,y); }
int n,m,sz,sum,deg[3005],p[3005],vis[3005]; char s[3005];
bool cmp(int x,int y){ return deg[x]<deg[y]; }
int main(){
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>s+1;
		for(int j=1;j<=n;j++) if(s[j]=='1') deg[i]++,deg[j]--;
	}
	for(int i=1;i<=n;i++) p[i]=i;
	sort(p+1,p+n+1,cmp);
	while(m--){
		int t,k,x; cin>>t>>k;
		for(int i=1;i<=n;i++) vis[i]=0; sz=sum=0;
		while(k--) cin>>x,vis[x]=1,sum+=deg[x],sz++;
		int ans=(sum+sz*(n-sz))/2;
		for(int i=1;i<=n;i++){
			if(vis[p[i]]||p[i]==t) continue;
			vis[p[i]]=1; sum+=deg[p[i]]; sz++;
			chkmin(ans,(sum+sz*(n-sz))/2);
		}
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：SmileMask (赞：2)

如果直接跑最大流死完了，考虑转成最小割怎么做。
直接贪心还是太超模了，考虑最小割的基础定义。

即为将 $\{1,2,\dots,n\}$ 划分为 $S,T$ 两个集合，最小割即为 $\sum_{u\in S}\sum _{v\in T} cap(u,v)$，在此问题中即为将 $\{s_1,s_2,\dots,s_k\}$ 划分进 $S$，$t$ 划分进 $T$，将该式记为 $value(S,T)$。

考虑一个点从 $T$ 划分到 $S$ 的代价，记为 $cost(u)$，则有：
$$\begin{align*}
  cost(u) &= \sum_{i\in T} cap(u,i)-\sum_{i\in S} cap(i,u) \\
    &= \sum_{i\in T} cap(u,i)-(|S|-\sum_{i\in S} cap(u,i)) \\
    &= out_u-|S|
\end{align*}
$$

发现只和 $u$ 的出度和 $|S|$ 有关，因此每次选择出度最小的点即可。
具体实现就是对出度排序，查询可以做到线性，复杂度 $O(n^2+nm)$。
```cpp
const int N=3010;
	
	int n,m,p[N],out[N];
	bool vis[N],G[N][N];
	char s[N];
	
	bool cmp(int x,int y){
		return out[x]<out[y];
	}
	
	void Main(){
		n=rd,m=rd;
		for(int i=1;i<=n;i++){
			scanf("%s",s+1);
			for(int j=1;j<=n;j++)
				G[i][j]=s[j]-'0',out[i]+=G[i][j];
		}
		for(int i=1;i<=n;i++) p[i]=i;
		sort(p+1,p+n+1,cmp);
		while(m--){
			int T=rd,k=rd,S,now=0;
			fill(vis+1,vis+n+1,0);
			for(int i=1;i<=k;i++){
				S=rd,now+=out[S]-(i-1);
				vis[S]=1;
			}vis[T]=1;
			int ans=now;
			for(int i=1;i<=n;i++){
				int u=p[i];
				if(vis[u]) continue;
				now+=out[u]-k,k++;
//				cout<<u<<' '<<now<<endl;
				ans=min(ans,now);
			}
			cout<<ans<<endl;
		}
	}
```

---

## 作者：Purslane (赞：1)

# Solution

一个很明显的 $O(n^4m)$ 做法：每次建立超级源点 $s$ 和超级汇点 $t$，保留原图中的所有边，$s$ 向所有起点连 $+ \infty$ 的边，$v$ 向 $t$ 连 $+ \infty$ 的边，跑最大流。能拿 $15$ 分欸。（其实感觉可以多拿一点，基本跑不满，但是没有去尝试）。

很容易想到转化为最小割问题。把 $\{1,2,3,\dots,n\}$ 划分为两个集合 $S$ 和 $T$，使得 $S$ 包含题目给的起点集合，$T$ 包含 $\{v\}$，并最小化 $\sum_{u \in S} \sum_{v \in T} w_{u,v}$。

以上都只需要有 CCF 的 $3$ 级水平就能看出来。

-------

进一步挖掘性质。容易发现，题目中“两两有连边”的性质并没有利用（事实上，这是一张竞赛图），也就是 $w_{u,v} + w_{v,u} = 1$。所以 $\sum_{u \in S} \sum_{v \in T} (w_{u,v} + w_{v,u})$ 是确定的。设 $c(S,T) = \sum_{u \in S} \sum_{v \in T} w_{u,v}$。所以我们知道 $c(S,T) + c(T,S) = |S||T|$。我们想最小化 $c(S,T)$，只需要最大化 $c(T,S)$。

但是这个问题还是没有发生实质性的转变。考虑还是不要把两个组合量分开，最小化 $c(S,T) - c(T,S)$。考虑把所有的边 $u \to v$ 按照 $[u \in S]$ 和 $[v \in T]$ 分成四组，并且考虑贡献：

- $00$，贡献为 $-1$。
- $01$，贡献为 $0$。
- $10$，贡献为 $0$。
- $11$，贡献为 $1$。

发现了什么？如果我认为这条边射向 $S$，贡献增加 $-1$；从 $S$ 射出，贡献增加 $1$，恰好负荷这些情况。因此，$c(S,T) - c(T,S) = \sum_{u \in S} (\deg_{\text{out},u} - \deg_{\text{in},u})$。

考虑到 $|S|$ 一定的时候，我们可以确定所有的 $u$。对于所有可能的 $|S|$ 取 $\min$ 即可。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=3000+10;
int n,m,deg[MAXN],flg[MAXN];
pair<int,int> pr[MAXN];
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	ffor(i,1,n) {
		string S; cin>>S;
		ffor(j,1,n) if(S[j-1]=='1') deg[i]++,deg[j]--;	
	}
	ffor(i,1,n) pr[i]={deg[i],i};
	sort(pr+1,pr+n+1);
	ffor(i,1,m) {
		int t,cnt,id,val=0,ans=n*n,pos=1;
		cin>>t>>cnt,flg[t]=1;
		ffor(j,1,cnt) cin>>id,flg[id]=1,val+=deg[id];
		ffor(s,cnt,n-1) {
			if(s!=cnt) {
				while(flg[pr[pos].second]) pos++;
				val+=pr[pos].first,pos++;
			}
			ans=min(ans,(s*(n-s)+val)/2);
		}
		ffor(j,1,n) flg[j]=0;
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：Arghariza (赞：1)

<https://www.cnblogs.com/Ender32k/p/17715910.html>

题意就是给定一个竞赛图，多次询问，每次询问有多个源点 $s_1,s_2,\cdots s_k$，单个汇点 $t$，一条边流量为 $1$，求最大流。

考虑转成最小割，相当于将 $V$ 划分成两个集合 $S,T$，$S\cup T=V$ 且 $S\cap T=\varnothing$，$s_i\in S,t\in T$，然后令 $f(S,T)=\sum\limits_{u\in S}\sum\limits_{v\in T}[(u,v)\in E]$ 最小。

考虑竞赛图的性质，每两个点之间都有连边，所以：

$$\begin{aligned}f(S,T)+f(T,S)&=\sum\limits_{u\in S}\sum\limits_{v\in T}[(u,v)\in E]+[(v,u)\in E]\\&=|S|\cdot |T|\end{aligned}$$

然后再推 $f(S,T)-f(T,S)$：

$$\begin{aligned}f(S,T)-f(T,S)&=\sum\limits_{u\in S}\sum\limits_{v\in T}[(u,v)\in E]-[(v,u)\in E]\\&=\sum\limits_{u\in S}\left(\sum\limits_{v\in V}[(u,v)\in E]-\sum\limits_{v\in S}[(u,v)\in E]-\sum\limits_{v\in V}[(v,u)\in E]+\sum\limits_{v\in S}[(v,u)\in E]\right)\\&=\sum\limits_{u\in S}\left(\sum\limits_{v\in V}[(u,v)\in E]-[(v,u)\in E]\right)\\&=\sum\limits_{u\in S}out_u-in_u\end{aligned}$$

其中 $out_u$ 表示 $u$ 的出度，$in_u$ 表示 $u$ 的入度。第二行推第三行是因为考虑一条边的贡献，那么 $S$ 的导出子图的所有点出入度之差的和显然为 $0$。

于是能够得到：

$$f(S,T)=\frac{|S|\cdot |T|+\sum\limits_{u\in S}out_u-in_u}{2}$$

由于 $T=V\setminus S$：

$$f(S,T)=\frac{|S|(n-|S|)+\sum\limits_{u\in S}out_u-in_u}{2}$$

考虑 $|S|$ 相同时，只需要最小化 $\sum\limits_{u\in S}out_u-in_u$，那么考虑 $|S|$ 从小到大的过程，直接按照 $out_u-in_u$ 从小到大排序然后一个个加入集合 $S$ 即可。

注意到 $s_i(1\le i\le k)\in S$ 且强制 $t\notin S$。

复杂度 $O(n(n+m))$。

---

## 作者：Little09 (赞：1)

首先题意可以转化为：给你一个竞赛图，边权均为 $1$，$m$ 次询问，每次给定多个源点和一个汇点，求最大流。

注意到最大流不好求，转成最小割。最小割可以使用定义表示：将 $n$ 个点划分为两个集合 $S,T$，满足源点都在 $S$ 集合中，汇点都在 $T$ 集合中，记一种划分的权值 $v(S,T)$ 所有边 $x\to y$  满足 $x\in S,y\in T$ 的边权和。最小割就是所有划分的权值最小值。

我们发现其实权值就是 $T$ 集合的总入度，减去 $T$ 集合内部的边数，因为每条 $T$ 集合内的边会产生一个入度，而减掉这些入度后剩下的就是从 $S$ 来的入度。由于是竞赛图，$T$ 集合内的边数就是 $\frac{|T|\times (|T|-1)}2$。所以当 $|T|$ 固定时，$T$ 集合的总入度越小，划分权值（这种割的权值）越小。

于是按入度排序，从小到大贪心加点即可。扫一遍之后得到的最小权值就是最小割的值。

时间复杂度 $O(n^2+nm)$。

---

## 作者：OrinLoong (赞：0)

## LGP9545 [HBTS-Pre 2023] 环山危路 学习笔记
[Luogu Link](https://www.luogu.com.cn/problem/P9545)

### 题意简述
给定一个 $n$ 个结点的竞赛图，每条边容量为 $1$。$m$ 次询问，每次给定 $k_i$ 个源点 $s_{i,j}$，$1$ 个汇点 $t_i$（保证所有 $s_i$ 与 $t_i$ 互不相同），求最大流。

$n\le 3\times 10^3,m\le 3\times 10^4$。

竞赛图的定义：满足任意两点间恰有一条有向边的简单图。

### 做法解析
直接跑最大流肯定不行，会爆。由于最大流最小割定理，我们求最大流不行就试试考虑最小割，因为这图是张竞赛图，我们可以期待其上的割有一些性质……？

确实有性质：对于两个点集 $S,T$，我们有 $f(S,T)+f(T,S)=|S|\times |T|$，因为 $S,T$ 的点两两有边相连。

另外，我们还有 $f(S,T)-f(T,S)=\sum_{u\in S} oud_u-ind_u$。这是因为从 $S$ 连到 $T$ 的边会做出 $1$ 的贡献，从 $T$ 连到 $S$ 的边会做出 $-1$ 的贡献，$S$ 内部的边做出 $0$ 的贡献，化一下就可以得到上式。

所以我们就有 $f(S,T)=\frac{1}{2}(|S|\times |T|+\sum_{u\in S}oud_u-ind_u)$。

这样，对于每个 $|S|$，我们最小化 $\sum_{u\in S} oud_u-ind_u$ 并更新答案，就可以得出答案。

实现上就是先算一遍初始 $S$ 的答案，然后每次贪心地往 $S$ 里面加 $oud_u-ind_u$ 最小的点尝试更新答案。

### 代码实现
真是精彩的签到！
```cpp
#include <bits/stdc++.h>
using namespace std;
namespace obasic{
    template <typename _T>
    void readi(_T &x){
        _T k=1;x=0;char ch=getchar();
        for(;!isdigit(ch);ch=getchar())if(ch=='-')k=-1;
        for(;isdigit(ch);ch=getchar())x=(x<<3)+(x<<1)+ch-'0';
        x*=k;return;
    }
    template <typename _T>
    void writi(_T x){
        if(x<0)putchar('-'),x=-x;
        if(x>9)writi(x/10);
        putchar(x%10+'0');
    }
    template <typename _T>
    void minner(_T &x,_T y){x=min(x,y);}
};
using namespace obasic;
const int MaxN=3e3+5;
int N,M,T,K,X;char S[MaxN];
int deg[MaxN],vis[MaxN];
struct anob{int v,id;}P[MaxN];
bool cmpv(anob a,anob b){return a.v<b.v;}
int main(){
    readi(N),readi(M);
    for(int i=1;i<=N;i++){
        scanf("%s",S+1);
        for(int j=1;j<=N;j++)if(S[j]=='1')deg[i]++,deg[j]--;
    }
    for(int i=1;i<=N;i++)P[i]={deg[i],i};
    sort(P+1,P+N+1,cmpv);queue<int> q;
    for(int csiz,csum;M--;){
        readi(T),readi(K);csiz=K,csum=0;
        for(int i=1;i<=K;i++)readi(X),vis[X]=1,q.push(X),csum+=deg[X];
        int ans=(csiz*(N-csiz)+csum)/2;
        for(int i=1;i<=N;i++){
            auto [cv,cid]=P[i];
            if(cid==T||vis[cid])continue;
            csiz++,csum+=cv;minner(ans,(csiz*(N-csiz)+csum)/2);
        }
        writi(ans),puts("");
        while(!q.empty())vis[q.front()]=0,q.pop();
    }
    return 0;
}
```

### 反思总结
想求 $x$ 时，如果实在别的方法都不行，试试求 $x+y$ 和 $x-y$。
神奇吧，HBTS-Pre。

---


# [湖北省选模拟 2023] 山路长环 / ring

## 题目描述

张三和李四在玩游戏。游戏规则是这样的：

在他们面前有一个棋盘，棋盘是一个由 $n$ 个节点和 $n$ 条边构成的环，边有边权。初始时，一枚棋子被放置在某个节点上。张三和李四轮流移动棋子，张三为先手，无法移动者败。每次移动时，必须选择棋子当前所在节点的某个相邻点（即有边相连的点），沿着边将棋子移动到这个相邻点去，并将边权减少任意正整数。需要注意的是，边权不允许被减小到负数。

张三想让你算算，对于给定的棋盘，有多少种初始棋子的摆放方式能使得他有必胜策略。

现在你有一个长为 $m$ 的序列 $a_1,a_2,\dots,a_m$，你需要完成 $q$ 次操作。每次操作形式为如下之一：

- `1 x y` 表示将 $a_x$ 赋值为 $y$；
- `2 l r` 表示查询如果棋盘上共 $(r-l+1)$ 个节点，且边权以顺时针方向分别为 $a_l,a_{l+1},\dots,a_r$，那么这样一盘游戏共有多少个不同的初始棋子位置可以让张三有必胜策略。

## 说明/提示

### 子任务

对于所有测试数据，保证 $1 \le m,q \le 3 \times 10^5$，$1 \le l \le r \le m$，$1\le x \le m$，$0 \le y,a_i \le 10^6$。

![](https://cdn.luogu.com.cn/upload/image_hosting/j579v06f.png)

特殊性质 A：保证 $0 \le y,a_i \le 1$。

特殊性质 B：保证所有询问满足 $l=1$，$r=m$。

特殊性质 C：保证没有修改操作。

## 样例 #1

### 输入

```
6 7
0 1 0 2 3 0
2 1 6
1 1 1
2 1 6
2 4 5
1 4 3
2 3 5
2 4 5
```

### 输出

```
3
2
2
1
0```

## 样例 #2

### 输入

```
见选手目录下的 ring/ring2.in 与 ring/ring2.ans。```

### 输出

```
见选手目录下的 ring/ring2.in 与 ring/ring2.ans。```

# 题解

## 作者：Rainbow_qwq (赞：9)

首先考察环上有 $0$ 的情况：

- 如果一个点和一个 $0$ 边相邻，那就只能向另一个方向走，并且必须把这条边的边权走完，否则对手走回来就无法再走。
- 因此，若和一个 $0$ 边相邻，两人接下来的走法固定，如果此时到下一个 $0$ 边的距离为奇数，则先手胜利。
- 设一个点到两边最近 $0$ 边的距离为 $l,r$，则如果 $l,r$ 之中有任意一个为奇数，则往那个方向走并且把边权走完，即可胜利。
- 否则不难发现先手不管怎么走，后手都能胜利。

如果两个 $0$ 之间有奇数个，那 $l,r$ 必有一个为奇数，之间的点都是必胜点；否则之间的点有一半为必胜点。

相当于环被 $0$ 切分成了若干条链，每条链有一个贡献（分链长奇偶不同）。

然后考察环上全部大于 $0$ 的情况：

- 如果环长 $n$ 为奇数，那先手可以把任意一条边走成 $0$，让后手陷入必败态，于是所有位置必胜。
- 如果环长 $n$ 为偶数，那先后手都要避免把自己一条边走成 $0$。

把第一种情况特判掉，下面分析第二种情况。容易发现此时两边如果是 $[1,1]$ 的话，走哪边都会出现 $0$，则为必败态。

如果一个人遇到一边有 $1$，一边为 $>1$ 的情况，那肯定要往 $>1$ 的方向走，而且必须把这条边走成 $1$，否则对手可以走回来。

于是发现上面的那套分析 $0$ 的情况都可以套过来！也就是说，如果环上有 $1$，可以把所有 $1$ 当成 $0$，答案不变。

进一步猜测，可以把所有环上最小值的位置当成 $0$，答案不变。经过打表发现确实如此。

于是只要维护区间最小值，以及区间最小值把环砍成的若干条链的贡献。

不难用线段树维护，时间复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(int i=(a);i<=(b);++i)
#define Rep(i,a,b) for(int i=(a);i>=(b);--i)
//#define int long long
using namespace std;

#define fi first
#define se second
#define pb push_back
#define mkp make_pair
typedef pair<int,int>pii;
typedef vector<int>vi;

#define maxn 300005
#define inf 0x3f3f3f3f

int n,Q,a[maxn];

struct node{
	int mn,l,r,len,res;
};
int F(int x){
	return x%2?x+1:x/2;
}
node operator +(node a,node b){
	if(a.mn<b.mn){
		a.len+=b.len;
		a.r+=b.len;
		return a;
	}
	if(a.mn>b.mn){
		b.len+=a.len;
		b.l+=a.len;
		return b;
	}
	node c;
	c.mn=a.mn;
	c.l=a.l;
	c.r=b.r;
	c.len=a.len+b.len;
	c.res=a.res+b.res+F(a.r+b.l);
	return c;
}

node tr[maxn<<2];
void up(int p){
	tr[p]=tr[p<<1]+tr[p<<1|1];
}
void build(int p,int l,int r){
	if(l==r)return tr[p]={a[l],0,0,1,0},void();
	int mid=l+r>>1;
	build(p<<1,l,mid),build(p<<1|1,mid+1,r),up(p);
}
void mdf(int p,int l,int r,int x){
	if(l==r)return tr[p]={a[l],0,0,1,0},void();
	int mid=l+r>>1;
	x<=mid?mdf(p<<1,l,mid,x):mdf(p<<1|1,mid+1,r,x); up(p);
}
node ask(int p,int l,int r,int ql,int qr){
	if(l>=ql&&r<=qr)return tr[p];
	int mid=l+r>>1;
	if(qr<=mid)return ask(p<<1,l,mid,ql,qr);
	if(ql>mid)return ask(p<<1|1,mid+1,r,ql,qr);
	return ask(p<<1,l,mid,ql,qr)+ask(p<<1|1,mid+1,r,ql,qr);
}

int chk(vi a){
	int mn=*min_element(a.begin(),a.end());
	if(mn>0 && a.size()%2)return 1;
	int p=0,q=0;
	while(a[p]!=mn)++p;
	while(a[a.size()-q-1]!=mn)++q;
	return p%2||q%2;
}

int ask(int l,int r){
	node t=ask(1,1,n,l,r);
	if(t.mn>0 && t.len%2)return t.len;
	return t.res+F(t.r+t.l);
}

signed main()
{
	n=read(),Q=read();
	For(i,1,n)a[i]=read();
	build(1,1,n);
	For(_,1,Q){
		int op=read(),x=read(),y=read();
		if(op==1)a[x]=y,mdf(1,1,n,x);
		else cout<<ask(x,y)<<"\n";
	}
	return 0;
}
```

---

## 作者：Alex_Wei (赞：7)

#### *[P9546 [湖北省选模拟 2023] 山路长环 / ring](https://www.luogu.com.cn/problem/P9546)

将权值为 $0$ 的边断开。

尝试寻找简单情况的解，推广至一般情况。

**基本性质**：若棋子在链的一端，则先手必胜当且仅当链长为奇数。

**证明**：先手移动棋子时，若不将边权清零，则后手可以反过来将边权清零，先手无法操作。因此，先手将边权清零，链长减小 $1$ 并交换先后手。当链长为 $0$ 时，先手必败，所以当链长为偶数时，先手必败；当链长为奇数时，先手必胜。$\square$

考虑先手必胜的充要条件，分类讨论：

1. 棋子在长度为奇数的链上：此时棋子某侧链长为奇数，先手向该方向移动并清空边权，使得后手面对棋子在一端且链长为偶数的局面，先手必胜。
2. 棋子在长度为偶数的链上：
   1. 棋子两侧链长均为奇数：同局面 1，先手必胜。
   2. 棋子两侧链长均为偶数：若先手选择清空边权，则后手面对局面 1；若先手选择不清空边权，则后手面对局面 2.1。无论先手如何操作，总会留给后手必胜局面。先手必败。
3. 棋子在长度为奇数的环上：先手向任意方向移动并清空边权，后手面对局面 2.2，先手必胜。
4. 棋子在长度为偶数的环上：先断开任意一条边的玩家将使得队首面对局面 1，因此首先清空边权的玩家必败。注意到玩家会选择清空边权当且仅当棋子两侧均为 $1$，因此，将所有边权减去 $1$ 之后，必胜者可以根据必胜策略让对手面对棋子两侧均为 $0$ 的局面，对应原局面即棋子两侧均为 $1$。因此，将所有边权减去 $1$ 不影响先手是否必胜：若先手在边权减去 $1$ 的局面必胜，则他可以根据必胜策略，使得后手在原局面首先清空某条边。因此，先手必胜当且仅当所有边权减去边权最小值后（对应局面 1 或 2，称为局面 4.1 和 4.2）先手必胜。

考虑计算答案：

- 对于局面 1 或 4.1，线段树维护大于最小值且长度为奇数的段的长度 $+1$ 之和。
- 对于局面 2 或 4.2，线段树维护大于最小值且长度为偶数的段的长度之和除以 $2$。
- 对于局面 3，答案显然为环长。

检查棋盘是否为奇环。若是，则答案为 $r - l + 1$。否则答案为局面 1（棋盘是若干条链）或 4.1（棋盘是偶环），和局面 2 或 4.2 的答案之和。

时间复杂度 $\mathcal{O}(n + q\log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

bool Mbe;
constexpr int N = 3e5 + 5;

int n, q, a[N];

struct dat {
  int mn, len, lft, rt, odd, eve;
  /*
  mn 表示最小值;
  len 表示区间长度;
  lft 表示区间左侧非最小值段长度;
  rt 表示区间右侧非最小值段长度;
  odd 表示区间内长度为奇数的非最小值段长度 + 1 之和;
  eve 表示区间内长度为偶数的非最小值段长度之和 / 2;
  */
  void init(int v) {
    mn = v, len = 1;
    lft = rt = odd = eve = 0;
  }
  dat operator + (const dat &x) const {
    dat y;
    y.mn = min(mn, x.mn);
    y.len = len + x.len;
    y.odd = y.eve = 0;
    bool L = y.mn == mn, R = y.mn == x.mn;
    if(L) y.lft = lft, y.odd += odd, y.eve += eve;
    else y.lft = len + x.lft;
    if(R) y.rt = x.rt, y.odd += x.odd, y.eve += x.eve;
    else y.rt = rt + x.len;
    if(L && R) {
      if((rt + x.lft) & 1) y.odd += rt + x.lft + 1;
      else y.eve += rt + x.lft >> 1;
    }
    return y;
  }
} val[N << 2];
void build(int l, int r, int x) {
  if(l == r) return val[x].init(a[l]), void();
  int m = l + r >> 1;
  build(l, m, x << 1), build(m + 1, r, x << 1 | 1);
  val[x] = val[x << 1] + val[x << 1 | 1];
}
void modify(int l, int r, int x, int p) {
  if(l == r) return val[x].init(a[l]), void();
  int m = l + r >> 1;
  if(p <= m) modify(l, m, x << 1, p);
  else modify(m + 1, r, x << 1 | 1, p);
  val[x] = val[x << 1] + val[x << 1 | 1];
}
dat query(int l, int r, int ql, int qr, int x) {
  if(ql <= l && r <= qr) return val[x];
  int m = l + r >> 1;
  if(qr <= m) return query(l, m, ql, qr, x << 1);
  if(m < ql) return query(m + 1, r, ql, qr, x << 1 | 1);
  return query(l, m, ql, qr, x << 1) + query(m + 1, r, ql, qr, x << 1 | 1);
}

bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);

  cin >> n >> q;
  for(int i = 1; i <= n; i++) cin >> a[i];
  build(1, n, 1);
  for(int i = 1; i <= q; i++) {
    int op, l, r;
    cin >> op >> l >> r;
    if(op == 1) a[l] = r, modify(1, n, 1, l);
    else {
      int ans = 0;
      dat v = query(1, n, l, r, 1);
      if(v.mn && ((r - l + 1) & 1)) ans = r - l + 1;
      else {
        ans = v.odd + v.eve;
        if((v.lft + v.rt) & 1) ans += v.lft + v.rt + 1;
        else ans += v.lft + v.rt >> 1;
      }
      cout << ans << "\n";
    }
  }

  cerr << 1e3 * clock() / CLOCKS_PER_SEC << " ms\n";
  return 0;
}

/*
g++ ring.cpp -o ring -std=c++14 -O2
*/
```

---

## 作者：Miraik (赞：4)

好题。

但是三个特殊性质没有一个对正解有启发作用的，差评。

从最简单的情况入手：环上有 $0$，也就是断成链了。

显然的观察：如果棋子在链的一端，那么链长为奇数则先手必胜，反之先手必败。这是因为，当前操作者一定只能清空边权，否则对方可以走回来并清空，就输了。

好好好，然后呢？

1. 如果棋子在奇链上，那么两边至少有一边的长度为奇数。先手往其方向走一步并清空边权，必胜。

2. 如果棋子在偶链上，且两边的长度都为奇数，那也是先手必胜。

3. 如果棋子在偶链上，且两边的长度都为偶数，容易发现无论先手如何操作都会让后手换先进入前两种状态，因此先手必败。

于是我们解决了链的情况：如果 $len$ 为奇数，答案为 $len+1$；否则为 $\frac{len}{2}$。

再考虑环。奇环自然是先手必胜，答案为 $len$。偶环呢？

容易发现偶环的情况下谁先清空边权谁就输了。

关键结论：将所有 $a_i$ 同时加一个整数 $M \ge -\min\{a_i\}$，胜负状态必然不变。

证明：如果无法移动，那意味着当前棋子两端都是 $0$。那么所有 $a_i$ 同时加 $1$，必胜方必然可以让对方面对棋子两端都是 $1$ 的情况，那对方不得不清空边权，即胜。可以归纳到加任意整数的情况（要保证 $a_i \ge 0$）

于是我们直接将所有 $a_i$ 减去 $\min\{a_i\}$，就回到了链上的问题。

这些操作均容易用线段树维护，于是本题在 $O(q \log m)$ 的时间内解决。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=300005;
int n,q,a[N];
inline int f(int len){ return (len&1) ? len+1 : len/2; }
struct Node{ int mn,l,r,len,ans; }t[N<<2];
#define ls(x) (x<<1)
#define rs(x) (x<<1|1)
inline Node pushup(Node a,Node b){
	Node c;
	c.len=a.len+b.len;
	if(a.mn<b.mn){
		c.mn=a.mn;
		c.l=a.l; c.r=a.r+b.len;
		c.ans=a.ans;
	}
	else if(a.mn>b.mn){
		c.mn=b.mn;
		c.r=b.r; c.l=b.l+a.len;
		c.ans=b.ans;
	}
	else{
		c.mn=a.mn;
		c.l=a.l; c.r=b.r;
		c.ans=a.ans+b.ans+f(a.r+b.l);
	}
	return c;
}
inline void build(int u,int l,int r){
	if(l==r) return t[u].mn=a[l],t[u].len=1,void();
	int mid=l+r>>1;
	build(ls(u),l,mid); build(rs(u),mid+1,r);
	t[u]=pushup(t[ls(u)],t[rs(u)]);
}
inline void update(int u,int l,int r,int x,int y){
	if(l==r) return t[u].mn=y,void();
	int mid=l+r>>1;
	if(x<=mid) update(ls(u),l,mid,x,y); else update(rs(u),mid+1,r,x,y);
	t[u]=pushup(t[ls(u)],t[rs(u)]);
}
inline Node query(int u,int l,int r,int ql,int qr){
	if(l>=ql&&r<=qr) return t[u];
	int mid=l+r>>1;
	if(qr<=mid) return query(ls(u),l,mid,ql,qr);
	if(ql>mid) return query(rs(u),mid+1,r,ql,qr);
	return pushup(query(ls(u),l,mid,ql,qr),query(rs(u),mid+1,r,ql,qr));
}
inline int qry(int l,int r){
	Node ret=query(1,1,n,l,r);
	if(ret.mn&&(ret.len&1)) return ret.len;
	return ret.ans+f(ret.l+ret.r);
}
int main(){
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin>>n>>q;
	for(int i=1;i<=n;i++) cin>>a[i];
	build(1,1,n);
	while(q--){
		int op; cin>>op;
		if(op==1){
			int x,y; cin>>x>>y;
			update(1,1,n,x,y);
		}
		else{
			int l,r; cin>>l>>r;
			cout<<qry(l,r)<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：Lucky_Xiang (赞：1)

## 题目

[P9546](https://www.luogu.com.cn/problem/P9546)

## 分析

如果区间中没有 $0$，则整个区间表示一个环，否则表示若干条链。

这启示我们按照图的形状分类讨论。

### 链

不妨考虑最简单的情况，即棋子初始在链的一个端点上。假如在某一步中，A 并没有把某一条边取完，则 B 可以直接回头把这条边取完，A 就输了。所以两人走的每一步都必须把边取完，走到端点就结束了。在这种情况下，链长（边的个数）为奇数先手就必胜，否则后手必胜。

而对于其他情况，不妨假设链长为 $len$。

- 若 $len$ 为奇数，则对于任意初始位置，棋子两侧的长度必定为一奇一偶，先手只要往奇数方向走（并取尽边权）就能获胜。
  
  在这种情况下，获胜点个数为 $len+1$。

- 若 $len$ 为偶数，不妨对初始位置进行讨论。

  1. 若两侧长度都是奇数，则先手无论往哪个方向走（并取尽边权）都必胜。
  2. 若两侧长度都是偶数，如果先手第一步取尽则后手将面对一条奇链，先手必败；如果先手不取尽，则后手面对的是两侧长度都是奇数的链，先手必败。
  
  在这种情况下，获胜点个数为 $len\over 2$。

### 环

同样的道理，可以对环长进行讨论。不妨设环长为 $len$。

- 若 $len$ 为奇数，则先手只要取尽一条边就能让后手面对偶链，从而必胜。

  在这种情况下，获胜点个数为 $len$。
  
- 若 $len$ 为偶数，则 A 只要取尽一条边则 B 会面对奇链的情况，从而 A 必败。所以两人都不会取尽任意一条边。

  反观原来的规则，是不能将 $0$ 变成 $-1$，而现在的新规则是不能将 $1$ 变成 $0$。所以现在的 $1$ 就相当于原来的 $0$。也就是说，将环上的所有边权同时减 $1$ 是不影响结果的。如此一直转化，就会使环上所有的边同时减去它们的最小值，从而使环断开成若干条链，就可以用上述方法继续处理了。
  
  
## 维护

可以用线段树维护答案的值。具体的，可以维护最长不等于最小值的前后缀的长度，然后在 `push_up` 时计算答案。总复杂度为 $O(q\log m)$。

## 代码

```cpp
#include<bits/stdc++.h>
#define ls(u) (u)<<1
#define rs(u) (u)<<1|1
#define LS(u) t[ls(u)]
#define RS(u) t[rs(u)]
using namespace std;
const int mn=300010;
struct node
{
    int L,R;
    int mi;
    int lenL,lenR;
    bool st;
    int cnt;
};
node merge(node A,node B,int op)
{
    node C;
    C.L=A.L; C.R=B.R;
    C.mi=min(A.mi,B.mi);
    op=min(op,C.mi);
    if(A.mi!=op)A.lenL=A.lenR=A.R-A.L+1, A.cnt=0;
    if(B.mi!=op)B.lenL=B.lenR=B.R-B.L+1, B.cnt=0;
    C.cnt=A.cnt+B.cnt;
    if(C.mi!=op)
    {
        C.lenL=C.lenR=C.R-C.L+1;
        C.st=0;
        C.cnt=0;
    }
    else
    {
        if(A.mi!=op)A.lenL=A.lenR=A.R-A.L+1, A.cnt=0;
        if(B.mi!=op)B.lenL=B.lenR=B.R-B.L+1, B.cnt=0;
        C.lenL=A.lenL; C.lenR=B.lenR;
        if(A.mi!=op)C.lenL+=B.lenL;
        if(B.mi!=op)C.lenR+=A.lenR;
        if(A.mi==op && B.mi==op)
        {
            int len=A.lenR+B.lenL;
            if(len%2==1)C.cnt+=len+1;
            else C.cnt+=len/2;
        }
        C.st=1;
    }
    return C;
}
int n,q;
int a[mn];
struct SMT
{
    node t[mn*4];
    void build(int u,int L,int R)
    {
        t[u]={L,R,0,0,0,0,0};
        if(L==R)
        {
            t[u].mi=a[L];
            return;
        }
        int mid=(L+R)>>1;
        build(ls(u),L,mid); build(rs(u),mid+1,R);
        t[u]=merge(LS(u),RS(u),1e9);
    }
    void change(int u,int p,int x)
    {
        if(t[u].L==t[u].R)
        {
            t[u].mi=x;
            return;
        }
        int mid=(t[u].L+t[u].R)>>1;
        if(p<=mid)change(ls(u),p,x);
        else change(rs(u),p,x);
        t[u]=merge(LS(u),RS(u),1e9);
    }
    int get_min(int u,int l,int r)
    {
        if(l>t[u].R || r<t[u].L)return 1e9;
        if(l<=t[u].L && t[u].R<=r)return t[u].mi;
        return min(get_min(ls(u),l,r),get_min(rs(u),l,r));
    }
    node query(int u,int l,int r,int op)
    {
        if(l<=t[u].L && t[u].R<=r)return t[u];
        int mid=(t[u].L+t[u].R)>>1;
        if(r<=mid)return query(ls(u),l,r,op);
        if(l>=mid+1)return query(rs(u),l,r,op);
        return merge(query(ls(u),l,r,op),query(rs(u),l,r,op),op);
    }
};
SMT M;
int op,x,y,L,R;
int res;
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    cin>>n>>q;
    for(int i=1;i<=n;i++)cin>>a[i];
    M.build(1,1,n);
    while(q--)
    {
        cin>>op;
        if(op==1)
        {
            cin>>x>>y;
            M.change(1,x,y);
        }
        else
        {
            cin>>L>>R;
            if((R-L+1)%2==1)
            {
                x=M.get_min(1,L,R);
                if(x)cout<<R-L+1<<'\n';
                else
                {
                    auto k=M.query(1,L,R,x);
                    res=k.cnt;
                    int len=k.lenL+k.lenR;
                    if(len%2==1)res+=len+1;
                    else res+=len/2;
                    cout<<res<<'\n';
                }
            }
            else
            {
                x=M.get_min(1,L,R);
                auto k=M.query(1,L,R,x);
                res=k.cnt;
                int len=k.lenL+k.lenR;
                if(len%2==1)res+=len+1;
                else res+=len/2;
                cout<<res<<'\n';
            }
        }
    }
    return 0;
}
```

---

## 作者：shinkuu (赞：0)

挺好的 CNOI 风格数据结构练手题。

首先显然是要看对于一个固定的序列怎么做。但是发现环还是太困难了，于是先考虑链，并且从一个端点出发。

容易发现此时当链长（边数）为奇数时先手必胜，否则后手必胜。因为此时双方的策略都是每次把走过的边变成 $0$，否则对方往回走并把边设成 $0$ 就赢了。

并且还可以类似地得到，从链中间开始的情况也是类似的。只用考虑两个方向分别有多少边。只要其中有一边有

那么首先就能得到，若当前环长为奇数，那么先手一定会把一条边变成 $0$ 然后变成上述情况。

否则，既然没有 $0$，那就考虑有 $1$ 的情况。那么此时 $1$ 的边是不能经过的。那么就变成了链的情况。

但是如果没有 $1$ 怎么办？这里的结论是：**所有边权为最小值的边都是不能经过的。**

证明可以考虑另外一个结论：**如果一方使得边权最小值减少了，那么整个过程中所有最小值变小的操作都是他做的。**

考虑反证，如果后面一次最小值变小不是他做的，那也就是说他不能经过刚才经过的边。那这样就变成了一个长为奇数的链的情况，对方就必胜了。于是得证。

于是可以将边权为最小值的边全部断掉，把问题放到剩下的若干个链上，根据上面链的结论做即可。

回到原题，还套了个数据结构，只需要维护上述最小值以及每个段长度等信息即可。这部分是简单的，建议自己实现。这里提供一份实现得比较臭的代码参考。复杂度 $O(n\log n)$。

code：

```cpp
bool Mbe;
int n,m,a[N],c[N],rt[N<<2];
set<int> st[N<<2];
struct SGT{
	int cur,tr[M],ls[M],rs[M];
	il void up(int u){
		tr[u]=tr[ls[u]]+tr[rs[u]];
	}
	void upd(int l,int r,int &u,int x,int y){
		if(!u){
			u=++cur;
		}
		if(l==r){
			tr[u]=y;
			return;
		}
		int mid=(l+r)>>1;
		if(x<=mid){
			upd(l,mid,ls[u],x,y);
		}else{
			upd(mid+1,r,rs[u],x,y);
		}
		up(u);
	}
	int qry(int l,int r,int u,int x,int y){
		if(!u||r<x||l>y){
			return 0;
		}
		if(l>=x&&r<=y){
			return tr[u];
		}
		int mid=(l+r)>>1;
		return qry(l,mid,ls[u],x,y)+qry(mid+1,r,rs[u],x,y);
	}
}T;
struct Sgt{
	int tr[N<<2];
	il void up(int u){
		tr[u]=min(tr[u<<1],tr[u<<1|1]);
	}
	void bld(int l,int r,int u){
		if(l==r){
			tr[u]=a[l];
			return;
		}
		int mid=(l+r)>>1;
		bld(l,mid,u<<1),bld(mid+1,r,u<<1|1);
		up(u);
	}
	void upd(int l,int r,int u,int x,int y){
		if(l==r){
			tr[u]=y;
			return;
		}
		int mid=(l+r)>>1;
		if(x<=mid){
			upd(l,mid,u<<1,x,y);
		}else{
			upd(mid+1,r,u<<1|1,x,y);
		}
		up(u);
	}
	int qry(int l,int r,int u,int x,int y){
		if(r<x||l>y||x>y){
			return inf;
		}
		if(l>=x&&r<=y){
			return tr[u];
		}
		int mid=(l+r)>>1;
		return min(qry(l,mid,u<<1,x,y),qry(mid+1,r,u<<1|1,x,y));
	}
}R;
il void del(int x,int y){
	auto it=st[y].lower_bound(x);
	if(c[x]){
		T.upd(1,n,rt[y],x,c[x]=0);
	}
	if(it!=--st[y].end()){
		int t=*next(it);
		if(c[t]){
			T.upd(1,n,rt[y],t,c[t]=0);
		}
	}
	if(it!=st[y].begin()&&it!=--st[y].end()){
		int l=*prev(it),r=*next(it);
		if((r-l)&1){
			T.upd(1,n,rt[y],r,c[r]=(r-l)/2+1);
		}
	}
	st[y].erase(x);
}
il void add(int x,int y){
	auto it=st[y].insert(x).fi;
	if(it!=--st[y].end()){
		int t=*next(it);
		if(c[t]){
			T.upd(1,n,rt[y],t,c[t]=0);
		}
		if((t-x)&1){
			T.upd(1,n,rt[y],t,c[t]=(t-x)/2+1);
		}
	}
	if(it!=st[y].begin()){
		int t=*prev(it);
		if((x-t)&1){
			T.upd(1,n,rt[y],x,c[x]=(x-t)/2+1);
		}
	}
}
void Yorushika(){
	read(n,m);
	rep(i,1,n){
		read(a[i]);
		add(i,a[i]);
	}
	R.bld(1,n,1);
	while(m--){
		int op,x,y;read(op,x,y);
		if(op==1){
			R.upd(1,n,1,x,y);
			del(x,a[x]),add(x,a[x]=y);
		}else{
			int t=R.qry(1,n,1,x,y);
			if(((y-x+1)&1)&&t){
				printf("%d\n",y-x+1);
				continue;
			}
			int l=*st[t].lower_bound(x),r=*--st[t].upper_bound(y);
			int ans=(y-x+1)-T.qry(1,n,rt[t],l+1,r);
			int len=l-x+y-r;
			ans-=len&1?0:len/2+1;
			printf("%d\n",ans);
		}
	}
}
bool Med;
signed main(){
	cerr<<(&Mbe-&Med)/1048576.0<<'\n';
	int t=1;
	//read(t);
	while(t--){
		Yorushika();
	}
}
```

---

## 作者：是青白呀 (赞：0)

先考虑一些简单情况。

当有权值为 $0$ 的时候，显然一个环会被变成若干多条链。先考虑链的情况。

1. 若棋子放在链头，则方向是唯一的。每走一步，我都一定会把上一条边删掉，否则下一手走回去并断边，就无路可走了。因此长度为奇数时先手必胜，否则后手必胜。
2. 当棋子放在中间时，考虑如下几种情况：

   - 当有一侧的长度为奇数时，往那边走并断一条边会走到必败态，因此先手必胜；
   - 当两侧均为偶数时，无论是否断边都会走到前面提到的必胜态，因此先手必败。
  
接下来考虑没有 $0$ 的情况。

1. 若环长为奇数，则先手可以断边变成偶链。因此先手必胜；

2. 若环长为偶数，则断边必败。考虑若先手将边权变为了 $1$，则下一个人的方向确定，走一圈之后先手会来到左右两侧均为 $1$ 的状态，必败，故把边权变为 $1$ 必败。以此类推，把边权变为最小值 $-1$ 必败，因此最小值的边不能走，断所有最小值边成链即可判断。

接下来考虑计数。有单点修改、区间查询，考虑线段树。每次判断首先求得区间最小值，判断是否是 $0$，若不是 $0$，则先判掉奇环，剩下的就都是将最小值处断开看链长，每一个长度为奇数的链，都会贡献长度 $+1$ 的答案；否则会贡献长度除以 $2$ 的答案。

在每个节点处维护区间最小值、左侧极长链长度、右侧极长链长度、该区间的总答案以及区间长度即可。合并节点时先判断两侧最小值是否相同，不同则直接将大的一侧合并到小的一侧的端链上；否则合并两个端链。合并时答案先减去原值，再加上新值即可。最后的答案要合成环，对左右端链进行类似的合并操作即可。复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define ls(x) (x<<1)
#define rs(x) ((x<<1)|1)
#define mp make_pair
#define sec second
#define fir first
#define pii pair<int,int>
#define lowbit(i) i&-i
using namespace std;
typedef long long ll;
const int N=3e5+5,M=6,S=(1<<15)+5,inf=1e9+7,mo=1e9+7;
const double eps=1e-8;
void read(int &p){
	int x=0,w=1;
	char ch=0;
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
int n,q,a[N];
int getans(int x){
    if(x&1)return x+1;
    else return x/2;
}
struct node{
    int len,ll,lr,ans,minv;
    friend node operator+(node x,node y){
        node res;
        if(x.minv<y.minv){
            res.ans=x.ans-getans(x.lr)+getans(y.len+x.lr);
            res.len=x.len+y.len;
            res.ll=x.ll,res.lr=y.len+x.lr;
            res.minv=x.minv;
        }
        else if(x.minv>y.minv){
            res.ans=y.ans-getans(y.ll)+getans(x.len+y.ll);
            res.len=x.len+y.len;
            res.ll=y.ll+x.len,res.lr=y.lr;
            res.minv=y.minv;
        }
        else{
            res.ans=x.ans+y.ans-getans(x.lr)-getans(y.ll)+getans(x.lr+y.ll);
            res.len=x.len+y.len;
            res.ll=x.ll,res.lr=y.lr;
            res.minv=x.minv;
        }
        return res;
    }
};
struct seg{
    node t[4*N];
    void pushup(int x){
        t[x]=t[ls(x)]+t[rs(x)];
    }
    void build(int x,int le,int ri){
        if(le==ri){
            t[x].minv=a[le];
            t[x].len=1;
            return;
        }
        int mid=(le+ri)>>1;
        build(ls(x),le,mid),build(rs(x),mid+1,ri);
        pushup(x);
    }
    void modify(int x,int le,int ri,int p,int v){
        if(le==ri){
            t[x].minv=v;
            return;
        }
        int mid=(le+ri)>>1;
        if(p<=mid)modify(ls(x),le,mid,p,v);
        else modify(rs(x),mid+1,ri,p,v);
        pushup(x);
    }
    node query(int x,int le,int ri,int ql,int qr){
        if(ql<=le&&qr>=ri)return t[x];
        int mid=(le+ri)>>1;
        node res={0,0,0,0,inf};
        if(ql<=mid)res=res+query(ls(x),le,mid,ql,qr);
        if(qr>mid)res=res+query(rs(x),mid+1,ri,ql,qr);
        return res;
    }
}T;
int main(){
    read(n),read(q);
    rep(i,1,n)
        read(a[i]);
    T.build(1,1,n);
    while(q--){
        int op,l,r;
        read(op),read(l),read(r);
        if(op==1)T.modify(1,1,n,l,r),a[l]=r;
        else{
            if(l==r){
                if(a[l]==0)puts("0");
                else puts("1");
                continue;
            }
            node res=T.query(1,1,n,l,r);
            if(res.minv!=0&&(r-l+1)&1){
                printf("%d\n",r-l+1);
                continue;
            }
            int ans=res.ans-getans(res.ll)-getans(res.lr)+getans(res.ll+res.lr);
            printf("%d\n",ans);
        }
    }
    return 0;
}
```

---

## 作者：江户川·萝卜 (赞：0)

先不管修改，观察答案形式。

视 $a_i=0$ 为断边，若有断边则断开部分分别考虑。

观察边数为奇的链，起点为一端时的策略，即不断断当前边。

- 若对面断边则继续断，根据奇偶性最后对面输；
- 若对面没断，则直接返回并置边权为 $0$，对面输。

拓展得（记 $len$ 表示边数）：

- 奇链：对于任意点，左右两边至少有一条为奇链，贡献为 $len+1$。
- 偶链：一半的点左右均偶链，另一半左右均奇链，贡献为 $\frac{len}2$。
- 奇环：断环即可，同奇链，贡献为 $len$。

偶环比较特殊，考虑对最小值进行归纳。

若最小值为 $1$，则不能走这条边。走过后变成奇链的形式，此时为后手，必输。即 $1$ 成为断边。

若最小值为 $2$，则不能走这条边，否则走完后这条边权值为 $0$ 或 $1$，成为断边，转化成奇链，必输。则 $2$ 成为断边。

归纳即得，可视最小值为断边，再参考上面计算贡献即可。

总结一下，即对区间按最小值分成若干段计算权值。这是容易用线段树维护的。

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr int maxn=3e5+5;
int n,q,a[maxn];
inline int f(int x){return ((x&1)?x+1:(x>>1));}
struct node{
    int len,l,r,mn,tt;
    node(int len=0,int l=0,int r=0,int mn=0,int tt=0):
    len(len),l(l),r(r),mn(mn),tt(tt){}
    inline node operator +(const node&o) const{
        int M=min(mn,o.mn);
        return node(len+o.len,(mn==M?l:len+o.l),(o.mn==M?o.r:o.len+r),M,(mn==M?tt:0)+(o.mn==M?o.tt:0)+(mn==o.mn?f(r+o.l):0));
    }
}t[maxn<<2];
#define ls p<<1
#define rs p<<1|1
inline node newp(int x){return node(1,0,0,x,0);}
void build(int p,int l,int r){
    if(l==r) return t[p]=newp(a[l]),void();
    int mid=l+r>>1;build(ls,l,mid),build(rs,mid+1,r);
    t[p]=t[ls]+t[rs];
}
void modify(int p,int l,int r,int k,int w){
    if(l==r) return t[p]=newp(w),void();
    int mid=l+r>>1;
    if(k<=mid) modify(ls,l,mid,k,w);
    else modify(rs,mid+1,r,k,w);
    t[p]=t[ls]+t[rs];
}
node query(int p,int l,int r,int ql,int qr){
    if(ql<=l&&r<=qr) return t[p];
    int mid=l+r>>1;
    if(qr<=mid) return query(ls,l,mid,ql,qr);
    if(ql>mid) return query(rs,mid+1,r,ql,qr);
    return query(ls,l,mid,ql,qr)+query(rs,mid+1,r,ql,qr);
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>q;for(int i=1;i<=n;i++) cin>>a[i];
    build(1,1,n);
    while(q--){
        int op,x,y;cin>>op>>x>>y;
        if(op==1) modify(1,1,n,x,y);
        else{
            auto p=query(1,1,n,x,y);
            // cout<<p.tt<<' '<<p.len<<' '<<p.l<<' '<<p.r<<' '<<p.mn<<'\n';
            if(p.mn&&(p.len&1)) cout<<p.len<<'\n';
            else cout<<p.tt+f(p.l+p.r)<<'\n';
        }
    }
}
```

---

## 作者：Graphcity (赞：0)

首先考虑 $a_i>0$ 的情况，此时某一个人将某条边的权值变成了 0。问题规约为长度为 $n$ 的链，棋子在链首的方案数。通过分析可以发现，当 $n$ 为奇数时后手必胜，$n$ 为偶数时先手必胜。进一步地，考虑棋子在中间时的情况。此时 $n$ 为偶数时先手必胜，$n$ 为奇数时棋子在偶数位先手必胜。

所以说，如果 $a_i>0$ 且 $n$ 是奇数，先手就可以通过断掉一条边的方式必胜。接下来仅考虑 $n$ 是偶数的情况。注意到此时断边者必败。那么什么时候必须断边呢？我们考虑将所有 $a_i$ 减去 1，此时如果某个人必须要断边，当且仅当原图的相邻两个 $a_i$ 都等于 1，也就是新图的相邻两个 $a_i$ 都等于 0，也就是新图他无法移动。

注意到我们又规约到了原问题。所以当所有 $a_i>0$ 时，我们不断执行所有 $a_i$ 减去 1 的操作，直到最小值被减到 0 为止。此时又变成了链的情况，这是好解决的。

使用线段树可以简单维护。总时间复杂度 $O((n+q)\log n)$。

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(int i=(a);i<=(b);++i)
#define Rof(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
const int Maxn=3e5;

int n,m,a[Maxn+5];
struct Data{int mn,len,lk,rk,ans;} t[Maxn*4+5],cur;
#define ls(x) (x<<1)
#define rs(x) (x<<1|1)

inline int Get(int x) {if(x&1) return x/2; else return x;}
inline Data operator+(Data a,Data b)
{
    Data c; c.len=a.len+b.len-1,c.mn=min(a.mn,b.mn);
    if(a.mn==b.mn) c.lk=a.lk,c.rk=b.rk,c.ans=a.ans+b.ans+Get(a.rk+b.lk-1);
    else if(a.mn>b.mn) c.lk=a.len+b.lk-1,c.rk=b.rk,c.ans=b.ans;
    else c.lk=a.lk,c.rk=a.rk+b.len-1,c.ans=a.ans; return c;
}
inline void push_up(int p) {t[p]=t[ls(p)]+t[rs(p)];}
inline void Build(int l,int r,int p)
{
    if(l==r) {t[p]=Data{a[l],2,1,1,0}; return;}
    int mid=(l+r)>>1; Build(l,mid,ls(p)),Build(mid+1,r,rs(p)),push_up(p);
}
inline void Modify(int l,int r,int p,int pos,int k)
{
    if(l==r) {t[p]=Data{k,2,1,1,0}; return;}
    int mid=(l+r)>>1;
    if(pos<=mid) Modify(l,mid,ls(p),pos,k);
    else Modify(mid+1,r,rs(p),pos,k);
    push_up(p);
}
inline void Count(int nl,int nr,int l,int r,int p)
{
    if(l<=nl && nr<=r) {if(cur.len==0) cur=t[p]; else cur=cur+t[p]; return;}
    int mid=(nl+nr)>>1;
    if(l<=mid) Count(nl,mid,l,r,ls(p));
    if(r>mid) Count(mid+1,nr,l,r,rs(p));
}

int main()
{
    cin>>n>>m;
    For(i,1,n) cin>>a[i];
    Build(1,n,1);
    while(m--)
    {
        int op,x,y; cin>>op>>x>>y;
        if(op==1) Modify(1,n,1,x,y);
        else
        {
            cur.len=0; Count(1,n,x,y,1);
            if(cur.mn>0 && (y-x+1)&1) printf("%d\n",y-x+1);
            else
            {
                int ans=cur.ans+Get(cur.lk+cur.rk-1);
                printf("%d\n",ans);
            }
        }
    }
    return 0;
}
```

---


# 「PHOI-1」晚宴筵

## 题目背景

小 X 在 Z 市长途奔波之后，他要去参加别人的晚宴。

![](https://cdn.luogu.com.cn/upload/image_hosting/2cpdwvwu.png)

## 题目描述

Z 市形如一个 $n \times n$ 的矩阵，小 X 打算仅使用瞬移机和时空穿越机到达别人的晚宴，若小 X 所在的位置 $(p,q)$ 满足 $l1_x \le p \le r1_x$ 且 $l2_y \le q \le r2_y(0 \le l1_x \le r1_x < x,0\le l2_y\le r2_y < y)$，那么小 X 就可以到达位置 $(x,y)$。

但是由于瞬移技术不太成熟以及时空穿越机的影响，瞬移时需花费 $w_p+w_q+w_x+w_y-p-q-x-y$ 秒（由于时空穿越机的特性，时间可能为负）。若下标不是正整数，瞬移机就会被损坏，所以小 X 只能到达都是正整数的下标。

现在小 X 在 $(1,1)$ 的位置，他要参加别人的晚宴，可是他目前不知道别人的晚宴在哪里，所以他想让你求，他到达每个地方 $(x,y)\text{ }\text{ }(1 \leq x,y \leq n)$ 所花费的最少时间，如果不能到达则输出 `inf`。

## 说明/提示

**本题采用捆绑测试。**

| Subtask | $n$ | $l1_i,l2_i$ | $w_i$ | 分值 |
| :-: | :-: | :-: | :-: | :-: |
| $0$ | $1 \le n \le 70$ | 无特殊限制 | $i \leq w_i \leq 10^5(1 \leq i \leq n)$ | $15$ |
| $1$ | $1 \le n \le 70$ | 无特殊限制 | 无特殊限制 | $25$ |
| $2$ | 无特殊限制 | $l1_i=l2_i=r1_i=r2_i=1(2\le i \le n)$ | 无特殊限制 | $5$ |
| $3$ | 无特殊限制 | 无特殊限制 | 无特殊限制 | $55$ | 

对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^3,0 \leq l1_i \leq r1_i \leq n,0 \leq l2_i \leq r2_i \leq n,0 \leq w_i \leq 10^5$ $,l1_i \leq r1_i < i,l2_i \leq r2_i < i $。

### 样例解释 #1:

- 从 $(1,1)$ 到 $(1,1)$ 显然要花费 $0$ 秒。

- 从 $(1,1)$ 可以直接到 $(2,2)$, 花费 $w_1 + w_1 + w_2 + w_2 - 1 - 1 - 2 - 2 = -2$ 秒。

- 从 $(1,1)$ 也可以直接到 $(3,2)$, 花费 $w_1 + w_1 + w_3 + w_2 - 1 - 1 - 3 - 2 = 1$ 秒。

- 要从 $(1,1)$ 到达 $(3,3)$，要先从 $(1,1)$ 到达 $(2,2)$，再从 $(2,2)$ 到达 $(3,3)$。花费 $w_1 + w_1 + w_2 + w_2 - 1 - 1 - 2 - 2 + w_2 + w_2 + w_3 + w_3 - 2 - 2 - 3 - 3 = -4$ 秒。

- 经过手算，可以发现，从 $(1,1)$ 不能到达其他位置。

## 样例 #1

### 输入

```
3
0 1 1
0 1 2
0 0 2
0 1 2
2 0 4```

### 输出

```
0 inf inf
inf -2 inf
inf 1 -4```

## 样例 #2

### 输入

```
10
0 1 1 2 2 2 3 3 3 3
0 1 2 2 3 3 3 4 4 4
0 1 2 2 3 3 3 3 4 4
0 1 2 3 4 4 5 5 5 5
8 4 2 1 2 4 8 4 2 1```

### 输出

```
0 inf inf inf inf inf inf inf inf inf
inf 18 inf inf inf inf inf inf inf inf
inf 15 20 18 inf inf inf inf inf inf
inf inf 18 16 inf inf inf inf inf inf
inf inf 12 10 8 9 12 7 4 2
inf inf 13 11 9 10 13 8 5 3
inf inf 16 14 12 13 16 11 8 6
inf inf 11 7 3 4 7 2 -1 -3
inf inf 8 4 0 1 4 -1 -4 -6
inf inf 6 2 -2 -1 2 -3 -6 -8```

# 题解

## 作者：Shanganze (赞：7)

这是一篇不用二维线段树的题解。
### 题意：
对于一个点 $(x,y)$，可以由 $(i,j)$ 且 $(l1_x\le i\le r1_x,l2_y\le j\le r2_y)$ 花费  $a_{x,y}+a_{i,j}$ $(a_{i,j}=k_i+k_j-i-j)$ 到达。初始在 $(1,1)$ 求到达每个点的最短时间。

###  45 pts: 

考虑暴力转移，$O(n^4)$，[这里](https://www.luogu.com.cn/paste/junluj07)。

###  100 pts: 

考虑题意，对于横坐标为 $j$ 的一整行，都会由 $l1_j-r1_j$ 这几行转移过来，我们可以用类似于悬线法的方式，把每一列 $l1_j-r1_j$ 的点取 $\min$ 归为一个点，可以用 $n$ 个线段树来维护每一列来实现这个操作，然后对于这合并出来的 $n$ 个点放到一棵线段树里，然后更新该行每个点答案，考虑无法到达的点答案加上 $inf$，由于 $dis_{x,y}=dis_{i,j}+a_{i,j}+a_{x,y}$，所以在更新完答案后都需加上本身的 $a_{i,j}$。最后答案减去自身 $a_{i,j}$ 即可，时间复杂度 $O(n^2\log n)$，空间复杂度 $O(n^2\log n)$。

注：写横纵坐标时不要写反。

### 代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e3+10;
int l1[N],l2[N],r1[N],r2[N],a[N][N],k[N],dis[N][N];
struct a1{int minn;}x[N][N<<2];
void X(int i,int l,int r,int p,int a,int dis){
	if(l==r){
		x[a][p].minn+=dis;
		return ;
	}
	int mid=(l+r)>>1;
	if(mid>=i)X(i,l,mid,p<<1,a,dis);
	else X(i,mid+1,r,p<<1|1,a,dis);
	x[a][p].minn=min(x[a][p<<1].minn,x[a][p<<1|1].minn);
}
int G(int L,int R,int l,int r,int p,int a){
	if(l>=L&&r<=R)return x[a][p].minn;
	int mid=(l+r)>>1;
	int ans=1e16;
	if(mid>=L)ans=G(L,R,l,mid,p<<1,a);
	if(mid<R) ans=min(ans,G(L,R,mid+1,r,p<<1|1,a));
	return ans;
}
signed main(){
	int n;
	cin>>n;
	for(int q=1;q<=n;q++){cin>>l1[q];if(l1[q]==0)l1[q]++;}
	for(int q=1;q<=n;q++){cin>>r1[q];}
	for(int q=1;q<=n;q++){cin>>l2[q];if(l2[q]==0)l2[q]++;}
	for(int q=1;q<=n;q++){cin>>r2[q];}
	for(int q=1;q<=n;q++)cin>>k[q];
	for(int q=1;q<=n;q++){
		for(int w=1;w<=n;w++){
			a[q][w]=k[q]+k[w]-q-w;
			X(q,1,n,1,w,a[q][w]);
		}
	}
	for(int q=2;q<=n;q++)X(1,1,n,1,q,1e10);
	for(int w=2;w<=n;w++){
		for(int i=1;i<=n;i++){
			X(i,1,n,1,n+1,G(l1[w],r1[w],1,n,1,i));
		}
		for(int i=1;i<=n;i++){
			if(r2[i]!=0)X(w,1,n,1,i,G(l2[i],r2[i],1,n,1,n+1));
			else X(w,1,n,1,i,1e10);
			X(w,1,n,1,i,a[w][i]);
		}
		for(int i=1;i<=n;i++){
			X(i,1,n,1,n+1,-G(l1[w],r1[w],1,n,1,i));
		}
	}
	for(int q=1;q<=n;q++){
		for(int w=1;w<=n;w++){
			int o=G(q,q,1,n,1,w)-a[q][w];
			if(o>=1e9)cout<<"inf ";
			else cout<<o<<" ";
		}
		cout<<"\n";
	}
	return 0;
}
```


---

## 作者：FiraCode (赞：5)

## 晚宴筵题解：

### Subtask 0

由于 $w_i \ge i$，所以没有负权边。

可以直接模拟题意建边，然后跑一遍 dijkstra。

### Subtask 1

由于没有边权限制，可以用 $dp$。

设 $f_{i,j}$ 表示 $(1,1) \sim(i,j)$ 的最短路。

然后转移就显然是 $f_{i,j}=\min_{l1_i \le k \le r1_i,l2_j\le p \le r2_j}\{f_{k, p}+w_i+w_j+w_k+w_p-i-j-k-p\}$，然后暴力转移即可。

### Subtask 2

可以直接 $(1,1)$ 到，而且没有其他的边了，那么就直接输出 $w_i+w_j+w_1+w_1-i-j-2$ 即可。

当然，第一行第一列除 $(1,1)$ 外都为 `inf`。

### Subtask 3

考虑如何优化 DP。

我们可以把关于 $i,j$ 的放到外面去，也就是 $f_{i,j}=\min_{l1_i \le k \le r1_i,l2_j\le p \le r2_j}\{f_{k, p}+w_k+w_p-k-p\}+w_i+w_j-i-j$。

然后我们可以发现，对于 $\min$ 中的值，可以用树套树求区间最大值，然后按照 **Subtask 1** 中的转移方程转移。

然后再把 $f_{i,j}+w_i+w_j-i-j$ 插入树中即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
/*
省略百行快读
*/

#define min(a,b) (a<b?a:b)

typedef int ll;

const int INF = 0x3f3f3f3f;
const int N = 2010;

ll minV, tr[N << 2][N << 2];
ll a[N << 2][N << 2];
int n;
ll l1[N], r1[N], l2[N], r2[N], w[N];
ll f[N][N];
#define pushupX(deep,rt) tr[deep][rt] = min(tr[deep << 1][rt], tr[deep << 1 | 1][rt])
#define pushupY(deep,rt) tr[deep][rt] = min(tr[deep][rt << 1], tr[deep][rt << 1 | 1])
void buildY(int ly, int ry, int deep, int rt, int flag) {
    if (ly == ry){
        if (flag!=-1)
            tr[deep][rt] = INF;
        else
            pushupX(deep, rt);
        return;
    }
    int m = (ly + ry) >> 1;
    buildY(ly, m, deep, rt << 1, flag);
    buildY(m + 1, ry, deep, rt << 1 | 1, flag);
    pushupY(deep, rt);
}
void buildX(int lx, int rx, int deep) {
    if (lx == rx){
        buildY(1, n + 1, deep, 1, lx);
        return;
    }
    int m = (lx + rx) >> 1;
    buildX(lx, m, deep << 1);
    buildX(m + 1, rx, deep << 1 | 1);
    buildY(1, n + 1, deep, 1, -1);
}
void modifyY(int Y, int val, int ly, int ry, int deep, int rt, int flag) {
    if (ly == ry) {
        if (flag) 
            tr[deep][rt] = val;
        else pushupX(deep, rt);
        return;
    }
    int m = (ly + ry) >> 1;
    if (Y <= m)
        modifyY(Y, val, ly, m, deep, rt << 1, flag);
    else
        modifyY(Y, val, m + 1, ry, deep, rt << 1 | 1, flag);
    pushupY(deep, rt);
}
void modifyX(int X, int Y, int val, int lx, int rx, int deep) {
    if (lx == rx) {
        modifyY(Y, val, 1, n + 1, deep, 1, 1);
        return;
    }
    int m = (lx + rx) >> 1;
    if (X <= m)
        modifyX(X, Y, val, lx, m, deep << 1);
    else
        modifyX(X, Y, val, m + 1, rx, deep << 1 | 1);
    modifyY(Y, val, 1, n + 1, deep, 1, 0);
}
void queryY(int Yl, int Yr, int ly, int ry, int deep, int rt) { 
    if (Yl <= ly && ry <= Yr) {
        minV = min(tr[deep][rt], minV);
        return;
    }
    int m = (ly + ry) >> 1;
    if (Yl <= m)
        queryY(Yl, Yr, ly, m, deep, rt << 1);
    if (m < Yr)
        queryY(Yl, Yr, m + 1, ry, deep, rt << 1 | 1);
}
void queryX(int Xl, int Xr, int Yl, int Yr, int lx, int rx, int rt) {
    if (Xl <= lx && rx <= Xr){
        queryY(Yl, Yr, 1, n + 1, rt, 1);
        return;
    }
    int m = (lx + rx) >> 1;
    if (Xl <= m)
        queryX(Xl, Xr, Yl, Yr, lx, m, rt << 1);
    if (m < Xr)
        queryX(Xl, Xr, Yl, Yr, m + 1, rx, rt << 1 | 1);
}
int main() {
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> l1[i];
    for (int i = 1; i <= n; ++i) cin >> r1[i];
    for (int i = 1; i <= n; ++i) cin >> l2[i];
    for (int i = 1; i <= n; ++i) cin >> r2[i];
    for (int i = 1; i <= n; ++i) cin >> w[i];

    buildX(1, n + 1, 1);

    for (int i = 0; i <= n + 1; ++i)
        for (int j = 0; j <= n + 1; ++j)
            f[i][j] = 0x3f3f3f3f;
    f[1][1] = 0;
    modifyX(2, 2, w[1] + w[1] - 1 - 1, 1, n + 1, 1);

    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j) {
            if (i == 1 && j == 1) continue;
            minV = INF;
            queryX(l1[i] + 1, r1[i] + 1, l2[j] + 1, r2[j] + 1, 1, n + 1, 1);
            if (minV != INF) {
                f[i][j] = minV + w[i] + w[j] - i - j;
                modifyX(i + 1, j + 1, f[i][j] + w[i] + w[j] - i - j, 1, n + 1, 1);
            }
        }
        
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (f[i][j] == 0x3f3f3f3f) cout << "inf ";
            else cout << f[i][j] << " ";
        }
        cout << "\n";
    }
        
    return 0;
}
```

---

## 作者：qnqfff (赞：1)

二维线段树模板题。

### 思路

设 $\_w_{i,j}=w_i+w_j-i-j$，则 $dis_{i,j}=\min\limits_{x \in [l1_i,r1_i],y \in [l2_j,r2_j]}dis_{x,y}+\_w_{x,y}+\_w_{i,j}$，直接把 $dis_{i,j}+\_w_{i,j}$ 挂二维线段树上即可。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<23],*p1=buf,*p2=buf;
int read(){int p=0,flg=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-') flg=-1;c=getchar();}while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar();}return p*flg;}
int n,l[1010],r[1010],_l[1010],_r[1010],w[1010],_w[1010][1010];
#define lson now<<1
#define rson now<<1|1
struct seg{
	int t[4010];
	void build(int now,int l,int r){
		t[now]=2e9;if(l==r) return ;
		int mid=(l+r)>>1;build(lson,l,mid);build(rson,mid+1,r);
	}
	void modify(int now,int l,int r,int x,int v){
		if(l==r){t[now]=min(t[now],v);return; }
		int mid=(l+r)>>1;if(x<=mid) modify(lson,l,mid,x,v);else modify(rson,mid+1,r,x,v);t[now]=min(t[lson],t[rson]);
	}
	int query(int now,int l,int r,int ql,int qr){
		if(ql<=l&&r<=qr) return t[now];
		int mid=(l+r)>>1,res=2e9;if(ql<=mid) res=min(res,query(lson,l,mid,ql,qr));if(mid<qr) res=min(res,query(rson,mid+1,r,ql,qr));return res;
	}
}T[4010];
void build(int now,int l,int r){
	T[now].build(1,0,n);if(l==r) return ;
	int mid=(l+r)>>1;build(lson,l,mid);build(rson,mid+1,r);
}
void modify(int now,int l,int r,int x,int _x,int v){
	T[now].modify(1,0,n,_x,v);if(l==r) return ;
	int mid=(l+r)>>1;if(x<=mid) modify(lson,l,mid,x,_x,v);else modify(rson,mid+1,r,x,_x,v);
}
int query(int now,int l,int r,int ql,int qr,int _ql,int _qr){
	if(ql<=l&&r<=qr) return T[now].query(1,0,n,_ql,_qr);
	int mid=(l+r)>>1,res=2e9;if(ql<=mid) res=min(res,query(lson,l,mid,ql,qr,_ql,_qr));if(mid<qr) res=min(res,query(rson,mid+1,r,ql,qr,_ql,_qr));return res;
}
signed main(){
	n=read();for(int i=1;i<=n;i++) l[i]=read();for(int i=1;i<=n;i++) r[i]=read();for(int i=1;i<=n;i++) _l[i]=read();for(int i=1;i<=n;i++) _r[i]=read();for(int i=1;i<=n;i++) w[i]=read();
	for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) _w[i][j]=w[i]+w[j]-i-j;build(1,0,n);for(int i=1;i<=n;i++,cout<<'\n') for(int j=1;j<=n;j++){if(!(i^1)&&!(j^1)){modify(1,0,n,1,1,_w[1][1]);cout<<0<<' ';continue;}int res=query(1,0,n,l[i],r[i],_l[j],_r[j]);if(res>=1e9) cout<<"inf ";else cout<<res+_w[i][j]<<' ',modify(1,0,n,i,j,res+2*_w[i][j]);}
	return 0;
}
```

---

## 作者：joy2010WonderMaker (赞：1)

### 前言

这个人离交上代码差了二十秒。

### 题目分析

这道题的点数边数很多，肯定不能真的跑最短路。

注意到一个点的前驱一定是一个左上角为 $(l1_i,l2_j)$，右下角为 $(r1_i,r2_j)$ 的矩阵，所以可以使用二维线段树来维护。

具体来说，我们定义 $dis_{i,j}$ 表示到第 $i$ 行第 $j$ 列的最短路。因为每次转移都要加上前驱的 $w$，所以往线段树里面要插入 $dis_{i,j}+w$，这样方便查找。

### 代码

```cpp
#include<bits/stdc++.h>
#define long long int
using namespace std;
int n,s[1005][1005],l1[1005],r1[1005],l2[1005],r2[1005],w[1005],dis[1005][1005];
struct SegmentTree{//内层线段树
	int tree[4005];
	inline void pushup(int p){
		tree[p]=min(tree[p<<1],tree[p<<1|1]);
	}
	inline void build(int p,int l,int r){
		tree[p]=0x3f3f3f3f;
		if(l==r)
			return;
		int mid=l+r>>1;
		build(p<<1,l,mid),build(p<<1|1,mid+1,r);
	}
	inline void update(int p,int l,int r,int y,int k){
		if(l==r){
			tree[p]=min(tree[p],k);
			return;
		}
		int mid=l+r>>1;
		if(y<=mid)
			update(p<<1,l,mid,y,k);
		else
			update(p<<1|1,mid+1,r,y,k);
		pushup(p);
	}
	inline int query(int p,int l,int r,int L,int R){
		if(l>=L&&r<=R)
			return tree[p];
		int mid=l+r>>1;
		if(R<=mid)
			return query(p<<1,l,mid,L,R);
		else if(L>mid)
			return query(p<<1|1,mid+1,r,L,R);
		else
			return min(query(p<<1,l,mid,L,mid),query(p<<1|1,mid+1,r,mid+1,R));
	}
};
struct node_w{
	int l,r;
	SegmentTree tr;
};
struct tree_w{//外层线段树
	node_w tree[4005];
	void build(int p,int l,int r){
		tree[p].l=l,tree[p].r=r;
		tree[p].tr.build(1,1,n);
		if(l==r)
			return;
		int mid=l+r>>1;
		build(p<<1,l,mid),build(p<<1|1,mid+1,r);
	}
	inline void update(int p,int l,int r,int x,int y,int k){
		tree[p].tr.update(1,1,n,y,k);
		if(l==r)
			return;
		int mid=l+r>>1;
		if(x<=mid)
			update(p<<1,l,mid,x,y,k);
		else
			update(p<<1|1,mid+1,r,x,y,k);
	}
	inline int query(int p,int l,int r,int lx,int rx,int ly,int ry){
		if(lx>rx||ly>ry||ry==0||rx==0)
			return 0x3f3f3f3f;
		if(lx==0)
			lx=1;
		if(ly==0)
			ly=1;
		if(l>=lx&&r<=rx)
			return tree[p].tr.query(1,1,n,ly,ry);
		int mid=l+r>>1;
		if(rx<=mid)
			return query(p<<1,l,mid,lx,rx,ly,ry);
		else if(lx>mid)
			return query(p<<1|1,mid+1,r,lx,rx,ly,ry);
		else
			return min(query(p<<1,l,mid,lx,mid,ly,ry),query(p<<1|1,mid+1,r,mid+1,rx,ly,ry));
	}
}t;
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",l1+i);
	for(int i=1;i<=n;i++)
		scanf("%d",r1+i);
	for(int i=1;i<=n;i++)
		scanf("%d",l2+i);
	for(int i=1;i<=n;i++)
		scanf("%d",r2+i);
	for(int i=1;i<=n;i++)
		scanf("%d",w+i);
	if(n==1){
		puts("1");
		return 0;
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			s[i][j]=w[i]+w[j]-i-j;
	t.build(1,1,n);
	memset(dis,0x3f,sizeof dis);
	dis[1][1]=0;
	t.update(1,1,n,1,1,s[1][1]);
	printf("0 ");
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(i==1&&j==1)
				continue;
			dis[i][j]=t.query(1,1,n,l1[i],r1[i],l2[j],r2[j]);
			t.update(1,1,n,i,j,dis[i][j]+2*s[i][j]);//维护dis
			dis[i][j]+=s[i][j];
			if(dis[i][j]<=1e9)
				printf("%d ",dis[i][j]);
			else
				printf("inf ");
		}
		puts("");
	}
	return 0;
}
```


---


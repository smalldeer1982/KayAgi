# [IOI 2023] 封锁时刻

## 题目背景

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。

本题仅支持 C++ 语言提交。

## 题目描述

匈牙利有 $N$ 个城市，编号依次为 $0$ 到 $N - 1$。

这些城市之间由 $N - 1$ 条双向道路连接，编号为 $0$ 至 $N - 2$。对每个 $j$（$0 \le j \le N - 2$），第 $j$ 条道路连接城市 $U[j]$ 和城市 $V[j]$，其长度为 $W[j]$，表示这两个城市之间的交通时间为 $W[j]$ 个时间单位。每条道路连接两个不同的城市，且每两个城市之间最多由一条道路连接。

两个不同城市 $a$ 和 $b$ 之间的一条**路径**是一个由不同城市组成的序列 $p_0, p_1, \ldots, p_t$，满足以下条件：
 * $p_0 = a$， 
 * $p_t = b$， 
 * 对每个 $i$（$0 \le i \lt t$），存在一条道路连接 $p_i$ 和 $p_{i + 1}$。

利用这些道路从任意一个城市到任意一个其他的城市都是有可能的。换言之，任意两个不同城市之间都存在路径。  
可以证明两个不同城市之间的路径是唯一的。

一条路径 $p_0, p_1, \ldots, p_t$ 的**长度**是这条路径上连接相邻城市的 $t$ 条道路的长度之和。

在匈牙利，很多人都会在建国日去参加在两个主要城市举行的庆祝活动。当庆祝活动结束时，他们会回家。政府为了防止人群干扰当地人，所以决定在特定时刻封锁城市。每个城市被政府分配一个非负的**封锁时刻**。政府决定所有城市的封锁时刻总和不得超过 $K$。具体来说，对每个 $i$（$0 \leq i \leq N - 1$），分配给城市 $i$ 的封锁时刻是一个非负整数  $c[i]$。所有  $c[i]$ 之和不超过 $K$。

考虑一个城市 $a$ 和某个封锁时刻的分配方案，我们说城市 $b$ 是从城市 $a$ 可达的当且仅当以下两种情况中的任意一种情况成立。

情况 1：$b = a$。

情况 2：这两个城市之间的路径  $p_0, \ldots, p_t$ （$p_0 = a$ 且 $p_t = b$）满足以下条件：
* 路径 $p_0, p_1$ 的长度最多为 $c[p_1]$，并且
* 路径 $p_0, p_1, p_2$ 的长度最多为 $c[p_2]$，并且
* $\ldots$
* 路径 $p_0, p_1, p_2, \ldots, p_t$ 的长度最长为  $c[p_t]$。

今年，两个主要的庆祝地点位于城市 $X$ 和 $Y$。  
对于每一个封锁时刻的分配方案，可以定义一个**便利分数**，其定义为下面两个数字之和：
- 从城市 $X$ 可达的城市个数。
- 从城市 $Y$ 可达的城市个数。

注意如果一个城市既能从城市 $X$ 可达也能从城市 $Y$ 可达，那么它在计算便利分数时计算两次。

你的任务是计算能被某个封锁时刻分配方案实现的最大便利分数。

## 说明/提示

#### 【实现细节】

你要实现以下函数。

```
int max_score(int N, int X, int Y, int64 K, int[] U, int[] V, int[] W)
```

* $N$：城市的个数
* $X$，$Y$：两个主要庆祝城市
* $K$：封锁时刻总和的上界
* $U$，$V$： 长度为 $N - 1$ 的描述道路连接情况的数组
* $W$：长度为 $N - 1$ 的描述道路长度的数组
* 该函数要返回能被某个封锁时刻分配方案实现的最大便利分数
* 每个测试用例可以多次调用该函数



#### 【例子】


考虑以下调用：

```
max_score(7, 0, 2, 10,
          [0, 0, 1, 2, 2, 5], [1, 3, 2, 4, 5, 6], [2, 3, 4, 2, 5, 3])
```



这对应以下道路网络：

![](https://cdn.luogu.com.cn/upload/image_hosting/wf5uw4qd.png)



假设封锁时刻如下分配：

| **城市**         | $0$ | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ |
|:----------------:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| **封锁时刻** | $0$ | $4$ | $0$ | $3$ | $2$ | $0$ | $0$ |



注意所有封锁时刻之和为 $9$，不超过 $K = 10$。城市 $0$，$1$ 和 $3$ 都是从城市 $X$（$X = 0$）可达的，而城市 $1$，$2$ 和 $4$ 都可以从城市 $Y$（$Y  = 2$）可达。 因此，便利分数为 $3+3 = 6$。不存在封锁时刻分配方案使得便利分数大于 $6$，所以该函数应该返回 $6$。



考虑另外一个调用：

```
max_score(4, 0, 3, 20, [0, 1, 2], [1, 2, 3], [18, 1, 19])
```



这对应以下道路网络：

![](https://cdn.luogu.com.cn/upload/image_hosting/zcw4gdi5.png)

假设封锁时间如下分配：

| **城市**         | $0$ | $1$ | $2$ | $3$ |
|:----------------:|:---:|:---:|:---:|:---:|
| **封锁时刻** | $0$ | $1$ | $19$| $0$ |



城市 $0$ 从城市 $X$（$X = 0$）可达，而城市 $2$ 和 $3$ 都是可以从城市 $Y$（$Y=3$）可达的。因此，便利分数是 $1 + 2 = 3$。不存在封锁时刻分配方案使得便利分数大于 $3$，所以函数应该返回 $3$。

#### 【约束条件】

* $2 \le N \le 200\,000$
* $0 \le X \lt Y \lt N$
* $0 \le K \le 10^{18}$
* $0 \le U[j] \lt V[j] \lt N$ (对每个 $j$ 满足 $0 \le j \le N - 2$)
* $1 \le W[j] \le 10^6$ (对每个 $j$ 满足 $0 \le j \le N - 2$)
* 利用这些道路可以从任意一个城市走到任意另外一个城市。
* $S_N \le 200\,000$，其中 $S_N$ 是所有调用函数 `max_score` 的  $N$ 的总和。


#### 【子任务】


我们说一个道路网络是**线性的**如果道路 $i$ 连接城市 $i$ 和 $i+1$（对每个$0 \le i \le N - 2$ 的 $i$）。

1. （8 分）从城市 $X$ 到城市 $Y$ 的路径长度大于 $2K$。
1. （9 分）$S_N \le 50$，道路网络是线性的。
1. （12 分）$S_N \le 500$，道路网络是线性的。
1. （14 分）$S_N \le 3\,000$，道路网络是线性的。
1. （9 分）$S_N \le 20$
1. （11 分）$S_N \le 100$
1. （10 分）$S_N \le 500$
1. （10 分）$S_N \le 3\,000$
1. （17 分）无额外的约束条件。

## 样例 #1

### 输入

```
2
7 0 2 10
0 1 2
0 3 3
1 2 4
2 4 2
2 5 5
5 6 3
4 0 3 20
0 1 18
1 2 1
2 3 19
```

### 输出

```
6
3
```

# 题解

## 作者：Alex_Wei (赞：14)

### [P9600 [IOI2023] 封锁时刻](https://www.luogu.com.cn/problem/P9600)

设 $dx_i$ 表示 $X$ 到 $i$ 的距离，$dy_i$ 表示 $Y$ 到 $i$ 的距离。

一个原始的想法：显然地，$c_i$ 只会取到 $dx_i$ 或 $dy_i$。如果 $c_i = \min(dx_i, dy_i)$，那么它对答案贡献 $1$；如果 $c_i = \max(dx_i, dy_i)$，那么它对答案贡献 $2$。这样问题转化为了非常经典的 [Cardboard Box](https://www.luogu.com.cn/problem/CF436E)：枚举被取到的最大的 $b_i$，那么所有 $b_k < b_i$ 的 $k$ 至少取也会取 $a_i$。将 $b$ 从小到大排序，枚举 $i$，设 $S$ 为 $1\leq k\leq i$ 的 $b_k - a_k$ 和 $i < k \leq n$ 的 $a_k$ 构成的可重集，求出最大的 $j$ 使得 $S$ 的前 $j$ 小的元素之和加上 $\sum_{k = 1} ^ i a_k$ 不超过 $K$。将所有 $a_i$ 和 $b_i - a_i$ 离散化后 BIT 上二分即可。

然而直接这样做是有问题的：城市 $i$ 由 $X$ 可达的前提条件是 $X$ 到 $i$ 所有城市均可达，也就是 $i$ 在 $X$ 方向上的后继 $s(i, X)$ 可达。我们求出的方案不一定能满足限制。来看看什么样的贡献是不符合限制的吧：

- 先把后继不存在的情况考虑掉：不妨设 $i = X$。设 $j = s(i, Y)$。如果 $c_i = 0$，那么它产生的 $1$ 的贡献显然合法。如果 $c_i = dy_i$，则要求 $c_j \geq dy_j$。因为 $dy_i > dy_j$，所以如果 $c_j < dy_j$，那么令 $c_j$ 变成 $dy_j$（增加至少 $1$ 贡献，增加至多 $dy_j$ 代价），$c_i$ 变成 $0$（减少 $1$ 贡献，减少 $dy_i$ 代价）可得更优的方案。

- $c_i$ 等于 $\min(dx_i, dy_i)$ 且不等于 $\max(dx_i, dy_i)$。不妨设 $dx_i < dy_i$。设 $j = s(i, X)$，则要求 $c_j\geq dx_j$。首先，因为 $dx_j = dx_i - w(i, j)$ 且 $dy_j \geq dy_i - w(i, j)$，所以 $dx_j \leq dy_j$。这说明只要 $c_j$ 不为 $0$ 就行。而 $c_j$ 显然不会为 $0$，否则令 $c_j$ 变成 $dx_j$（增加 $1$ 贡献，增加 $dx_j$ 代价），$c_i$ 变成 $0$（减少 $1$ 贡献，减少 $dx_i$ 代价）可得更优的方案。这说明在不考虑限制时用 Cardboard Box 的做法求出的解在该情况下的贡献是符合限制的。

- $c_i$ 等于 $\max(dx_i, dy_i)$。不妨设 $dx_i \leq dy_i$。设 $j_x = s(i, X)$，$j_y = s(i, Y)$。这里又有两种情况：

  - $j_x = j_y$，设为 $j$，则 $dx_j = dx_i - w(i, j)$，$dy_j = dy_i - w(i, j)$，且要求 $c_j = dy_j$。此时 $i$ 恰好不在 $X, Y$ 的简单路径上。

      - 如果 $c_j = 0$，那么令 $c_j$ 变成 $dy_j$（增加 $2$ 贡献，增加 $dy_j$ 代价），$c_i$ 变成 $0$（减少 $2$ 贡献，减少 $dy_i$ 代价）可得更优的方案。

      - 如果 $c_j = dx_j$，那么令 $c_j$ 变成 $dy_j$（增加 $1$ 贡献，增加 $dy_j - dx_j$ 代价），$c_i$ 变成 $dx_i$（减少 $1$ 贡献，减少 $dy_i - dx_i$ 代价）得到代价相等的方案。

      这说明在不考虑限制时用 Cardboard Box 的做法求出的解在该情况下的贡献要么符合限制，要么可以通过调整得到符合限制且代价不劣的方案。

  - 唯一的问题发生在 $j_x\neq j_y$，即 $i$ 落在 $X, Y$ 简单路径上且不等于 $X, Y$ 的时候。而且我们很容易举出一个这种情况下的反例：由 $(1, 2, 2), (2, 3, 1), (3, 4, 1), (4, 5, 2)$ 组成的五元链，且 $K = 3$。答案显然为 $3$，但我们会求出 $c_3 = 3$ 使得总贡献为 $4$。

但是，如果至少一个点贡献了 $2$，那么 $X$ 和 $Y$ 之间所有点都要至少贡献 $1$。从这一点出发，考虑钦定 $X$ 和 $Y$ 之间所有点至少贡献 $1$。在此基础上做 Cardboard Box（这是容易的）是否就符合限制了呢？

我们来具体分析一下：要求 $c_{j_x} \geq dx_{j_x}$ 且 $c_{j_y}\geq dy_{j_y}$。

- 对于 $c_{j_x}\geq dx_{j_x}$：因为 $dx_i \leq dy_i$，所以 $dx_{j_x} < dy_{j_x}$。若 $c_{j_x} > 0$，这个条件就一定满足。
- 对于 $c_{j_y}\geq dy_{j_y}$：
  - 如果 $dy_{j_y}\leq dx_{j_y}$，那么若 $c_{j_y} > 0$，这个条件就一定满足。
  - 如果 $dy_{j_y} > dx_{j_y}$，那么若 $c_{j_y} = dx_{j_y}$，可以令 $c_i$ 变成 $dx_i$，$c_{j_y}$ 变成 $dy_{j_y}$，贡献不变，但注意到 $i$ 和 $j_y$ 在链上都是向 $X$ 偏的，所以代价会减少 $2w(i, j_y)$（把式子写出来可得同样的结果）。因此，若 $c_{j_y} > 0$，这个条件就一定满足。

也就是说，只要 $c_{j_x} > 0$ 且 $c_{j_y} > 0$，方案就一定合法。而这个先决条件恰好被 “钦定 $X$ 和 $Y$ 之间所有点至少贡献 $1$" 这一步操作满足了（特别地，对于 $j_x = X$ 或 $j_y = Y$ 的情况，因为此时 $dx_{j_x} = 0$ 或 $dy_{j_y} = 0$，所以合法），而该操作是必要条件，即所有合法方案都必须满足的条件，所以该操作不会丢掉合法方案。

别忘了还有不存在一个城市从 $X, Y$ 均可达的情况，此时答案为最大的 $k$ 使得 $\{dx_i\} \cup \{dy_i\}$ 前 $k$ 小的元素之和不大于 $K$。合法性已经证明过了，且如果方案有城市从 $X, Y$ 均可达，因为只会将代价算大，所以不影响答案的合法性。

时间复杂度 $\mathcal{O}(N\log N)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using pii = pair<int, int>;

constexpr int N = 4e5 + 5;

ll z[N];
struct level {
  ll a, b;
  bool operator < (const level &z) const {
    return b < z.b;
  }
} c[N];

namespace Cardboard_Box {
  int cnt, p[N], q[N];
  ll d[N], nu[N], su[N];
  void add(int x, int v1, ll v2) {
    while(x <= cnt) {
      nu[x] += v1, su[x] += v2;
      x += x & -x;
    }
  }

  int solve(int n, ll K, level *c, int m, ll *z) {
    cnt = 0;
    for(int i = 1; i <= m; i++) d[++cnt] = z[i];
    for(int i = 1; i <= n; i++) {
      d[++cnt] = c[i].a;
      d[++cnt] = c[i].b - c[i].a;
    }
    sort(c + 1, c + n + 1);
    sort(d + 1, d + cnt + 1);
    cnt = unique(d + 1, d + cnt + 1) - d - 1;
    
    ll sum = 0;
    memset(nu, 0, cnt + 2 << 3);
    memset(su, 0, cnt + 2 << 3);
    for(int i = 1; i <= m; i++) {
      int pos = lower_bound(d + 1, d + cnt + 1, z[i]) - d;
      add(pos, 1, z[i]);
    }
    for(int i = 1; i <= n; i++) {
      p[i] = lower_bound(d + 1, d + cnt + 1, c[i].a) - d;
      q[i] = lower_bound(d + 1, d + cnt + 1, c[i].b - c[i].a) - d;
      add(p[i], 1, c[i].a);
    }

    ll ans = 0;
    for(int i = 0; i <= n; i++) {
      if(i) {
        add(p[i], -1, -c[i].a);
        add(q[i], 1, c[i].b - c[i].a);
        K -= c[i].a;
      }
      if(K < 0) break;
      ll p = 0, num = 0, sum = 0;
      for(int j = __lg(cnt); ~j; j--) {
        int np = p + (1 << j);
        if(np > cnt || sum + su[np] > K) continue;
        p = np, num += nu[p], sum += su[p];
      }
      if(p < cnt) num += (K - sum) / d[p + 1];
      ans = max(ans, num + i);
    }
    return ans;
  }
}

ll dx[N], dy[N];
vector<pii> e[N];
void dfs(int id, int ff, ll *d) {
  if(ff == -1) d[id] = 0;
  for(pii _ : e[id]) {
    int it = _.first;
    if(it == ff) continue;
    d[it] = d[id] + _.second;
    dfs(it, id, d);
  }
}

int max_score(int N, int X, int Y, ll K, vector<int> U, vector<int> V, vector<int> W) {
  for(int i = 0; i < N; i++) e[i].clear();
  for(int i = 0; i + 1 < N; i++) {
    e[U[i]].push_back({V[i], W[i]});
    e[V[i]].push_back({U[i], W[i]});
  }
  dfs(X, -1, dx), dfs(Y, -1, dy);

  vector<ll> arr;
  for(int i = 0; i < N; i++) {
    arr.push_back(dx[i]);
    arr.push_back(dy[i]);
  }
  sort(arr.begin(), arr.end());

  int ans = 0;
  ll sum = 0;
  for(int i = 0; i < arr.size(); i++) {
    if((sum += arr[i]) > K) break;
    ans++;
  }

  int n = 0, m = 0, cnt = 0;
  for(int i = 0; i < N; i++) {
    ll mn = min(dx[i], dy[i]);
    ll mx = max(dx[i], dy[i]);
    if(dx[i] + dy[i] == dx[Y]) {
      cnt++, K -= mn;
      z[++m] = mx - mn;
    }
    else c[++n] = {mn, mx};
  }

  if(K >= 0) ans = max(ans, cnt + Cardboard_Box::solve(n, K, c, m, z));
  return ans;
}
```

---

## 作者：Purslane (赞：12)

# Solution

看到 $K$ 很大，所以肯定不是背包啥的。

先考虑 Sub 1 怎么做。发现 $X$ 能到的点和 $Y$ 能到的点一定不会重叠，所以可以直接贪心。具体的，设每个点到最近的关键点（$X$ 或 $Y$）的距离为 $dis_u$，每次取出 $dis$ 最小的节点即可。

考虑其他点和 Sub 1 的区别。发现 $X$ 能到的点和 $Y$ 能到的点可能有交集。每个点想要被一个点到达，需要花费 $cost_{u,1}$ 的代价；想要被两个点到达，需要花费 $cost_{u,2}$ 的代价。

我们先钦定 $X$ 和 $Y$ 路径上所有点都花了 $cost_{u,1}$ 的代价选上了。然后他们就可以花 $0$ 的代价获得一个贡献，花原有的 $cost_{u,2}-cost_{u,1}$ 的代价获得两个贡献。

我们证明：这时候直接跑 CF436E 就是对的。

考虑调整。考虑把 $X$ 到 $Y$ 路径上的边删掉，形成若干个有根树（根式路径上的节点）。显然贡献 $\ge 2$、$\ge 1$ 的点在最优解下一定形成一个含有根的连通块。

考虑 $X$ 到 $Y$ 路径上哪些点被选了 $2$ 次。发现最优情况下他们还是一个连通块（因为 $cost_{u,2}$ 是单谷的，往中间调整显然更优）。

反悔贪心即可，复杂度单 $\log$。

讲个笑话：我自己做这题的时候除了 CF436E 怎么做其他都很快想出来了，但是拼尽全力不会 CF436E（尽管我初三就做过这个题）。哎我咋这么菜。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=3e5+10;

int tp[MAXN];
ll dis1[MAXN],dis2[MAXN],cost1[MAXN],cost2[MAXN],a[MAXN],b[MAXN];
struct Node {ll val,id;};
bool operator <(Node A,Node B) {return A.val>B.val;}
struct DEL_QUEUE {
	ll op;
	priority_queue<Node> q;
	void push_down(void) {
		while(!q.empty()&&tp[q.top().id]!=op) q.pop();
		return ;	
	}
}q1,q2,q3,q4,q5;
void check1(ll& min_delta,int& op,int& p1,int& p2) {
	if(!q1.q.empty()&&q1.q.top().val<min_delta) min_delta=q1.q.top().val,op=1,p1=q1.q.top().id,p2=0;
	return ;
}
void check2(ll& min_delta,int& op,int& p1,int& p2) {
	if(!q2.q.empty()&&q2.q.top().val<min_delta) min_delta=q2.q.top().val,op=2,p1=q2.q.top().id,p2=0;
	return ;
}
void check3(ll& min_delta,int& op,int& p1,int& p2) {
	if(!q4.q.empty()&&!q5.q.empty()&&q4.q.top().val+q5.q.top().val<min_delta) min_delta=q4.q.top().val+q5.q.top().val,op=3,p1=q4.q.top().id,p2=q5.q.top().id;
	return ;
}
void check4(ll& min_delta,int& op,int& p1,int& p2) {
	if(!q3.q.empty()&&!q4.q.empty()&&q3.q.top().val+q4.q.top().val<min_delta) min_delta=q3.q.top().val+q4.q.top().val,op=4,p1=q4.q.top().id,p2=q3.q.top().id;
	return ;
}
void update1(int p1) {
	tp[p1]=1,q2.q.push({b[p1]-a[p1],p1}),q5.q.push({-a[p1],p1});
	return ;	
}
void update2(int p1) {
	tp[p1]=2,q3.q.push({a[p1]-b[p1],p1});
	return ;
}
void update3(int p1,int p2) {
	update2(p1),tp[p2]=0,q1.q.push({a[p2],p2}),q4.q.push({b[p2],p2});
	return ;	
}
void update4(int p1,int p2) {
	update2(p1),tp[p2]=1,q2.q.push({b[p2]-a[p2],p2}),q5.q.push({-a[p2],p2});
	return ;
}
int calc(vector<ll> A,vector<ll> B,ll k) {
	int n=A.size(); ll ans=0;
	ffor(i,1,n) tp[i]=0,a[i]=A[i-1],b[i]=B[i-1];
	while(!q1.q.empty()) q1.q.pop();
	while(!q2.q.empty()) q2.q.pop();
	while(!q3.q.empty()) q3.q.pop();
	while(!q4.q.empty()) q4.q.pop();
	while(!q5.q.empty()) q5.q.pop();
	q1.op=0,q2.op=1,q3.op=2,q4.op=0,q5.op=1;
	ffor(i,1,n) q1.q.push({a[i],i}),q4.q.push({b[i],i});
	ffor(i,1,n+n) {
		ll min_delta=LONG_LONG_MAX;
		int op=0,p1=0,p2=0;
		q1.push_down(),q2.push_down(),q3.push_down(),q4.push_down(),q5.push_down();
		check1(min_delta,op,p1,p2);
		check2(min_delta,op,p1,p2);
		check3(min_delta,op,p1,p2);
		check4(min_delta,op,p1,p2);
		if(op==1) update1(p1);
		if(op==2) update2(p1);
		if(op==3) update3(p1,p2);
		if(op==4) update4(p1,p2);
		ans+=min_delta;
		if(ans>k) return i-1;
	}
	return n+n;
}
int n;
vector<pair<int,int>> G[MAXN];
void dfs(int u,int f,ll *dis) {
	if(!f) dis[u]=0;
	for(auto pr:G[u]) {
		int v=pr.first,w=pr.second;
		if(v==f) continue ;
		dis[v]=dis[u]+w,dfs(v,u,dis);
	}
	return ;
}
int max_score(int N,int X,int Y,ll K,vector<int> U,vector<int> V,vector<int> W) {
	n=N;
	ffor(i,1,n) G[i].clear();
	ffor(i,0,n-2) G[U[i]+1].push_back({V[i]+1,W[i]}),G[V[i]+1].push_back({U[i]+1,W[i]});
	dfs(X+1,0,dis1);
	dfs(Y+1,0,dis2);
	ffor(i,1,n) cost1[i]=min(dis1[i],dis2[i]),cost2[i]=dis1[i]+dis2[i]-cost1[i];
	priority_queue<ll> q;
	ffor(i,1,n) q.push(-cost1[i]);
	ll pre=0;int ans=0;
	ffor(i,1,n) {
		pre+=-q.top(),q.pop();
		if(pre<=K) ans=max(ans,i);
	}
	ffor(i,1,n) if(dis1[i]+dis2[i]==dis1[Y+1]) K-=cost1[i],cost2[i]-=cost1[i],cost1[i]=0;
	if(K>=0) {
		vector<ll> a,b;
		ffor(i,1,n) a.push_back(cost1[i]),b.push_back(cost2[i]);
		ans=max(ans,calc(a,b,K));		
	}
	return ans;
}
//signed main() {
//	cout<<max_score(7, 0, 2, 10,
//          {0, 0, 1, 2, 2, 5}, {1, 3, 2, 4, 5, 6}, {2, 3, 4, 2, 5, 3})<<' '<<max_score(4, 0, 3, 20, {0, 1, 2}, {1, 2, 3}, {18, 1, 19});
//	return 0;
//}
```

---

## 作者：definieren (赞：7)

记 $dis_{a, b}$ 表示城市 $a$ 与城市 $b$ 之间的路径长度。

先考虑一个简化问题：把城市 $b$ 是城市 $a$ 可达的定义为 $dis_{a, b} \le c_b$，求可达城市 $X$ 与可达城市 $Y$ 的城市的数量和。

此时对于一个城市 $u$ 有：

- 在 $c_u < \min(dis_{X, u}, dis_{Y, u})$ 时，对答案没有贡献。
- 在 $\min(dis_{X, u}, dis_{Y, u}) \le c_u < \max(dis_{X, u}, dis_{Y, u})$ 时，对答案有 $1$ 的贡献。
- 在 $\max(dis_{X, u}, dis_{Y, u}) \le c_u$ 时，对答案有 $2$ 的贡献。

也就是城市 $u$ 可以花费 $0$ 的代价，对答案没有贡献；可以花费 $\min(dis_{X, u}, dis_{Y, u})$ 的代价，对答案有 $1$ 的贡献；然后可以再花费 $\max(dis_{X, u}, dis_{Y, u}) - \min(dis_{X, u}, dis_{Y, u})$ 的代价，对答案再有 $1$ 的贡献。要在花费不超过 $K$ 的前提下使答案最大。

这个看着就很能做，假设已经会了这个的做法，先把原问题中路径上每个点都要满足条件的限制加上。

看下面这个图（$0$ 号节点是 $X$，$4$ 号节点是 $Y$）。

![我是一张图](https://cdn.luogu.com.cn/upload/image_hosting/rcrtg894.png)

分 $A$、$B$、$C$ 三个部分考虑。

先看左侧的 $A$ 部分。若一个点 $u$ 的 $c_u$ 满足条件，则在 $u$ 到 $X$ 的路径上的每个点 $v$ 的 $c_v$ 一定是满足条件的。

因为 $v$ 在 $u$ 到 $X$ 的路径上，所以 $dis_{X, v} < dis_{X, u}$，$dis_{Y, v} < dis_{Y, u}$，如果 $c_u$ 满足条件而 $c_v$ 不满足条件的话，就不如让 $c_v$ 满足条件而 $c_u$ 不满足条件，这样花费的代价不会更大，答案不会更劣。

这时如果直接做上面那个简化的问题，那么如果一个点 $u$ 的 $c_u$ 满足条件，则它到 $X$ 路径上的每个点都满足条件，所以和原问题等价的。

对于右侧的 $A$ 部分也是同理。

再看 $B$ 部分。若一个点 $u$ 的 $c_u$ 满足条件，则在 $u$ 到 $X$、$Y$ 之间的链的路径上的每个点 $v$ 的 $c_v$ 一定是满足条件的。这部分的原因和 $A$ 部分差不多。直接做简化的问题也是和原问题等价的。

最后看 $C$ 部分。这部分就不能直接做简化的问题了。因为有可能出现满足 $c_u \le dis_{X, u}$ 的点是 $X$ 开始的较长的一段连续的点，满足 $c_u \le dis_{Y, u}$ 的点是 $Y$ 开始较短的一段后缀和满足 $c_u \le dis_{X, u}$ 的几个点，然后就寄了。就比如下面这张图（$0$ 号节点是 $X$，$4$ 号节点是 $Y$，每个点 $u$ 上方的值是 $dis_{X, u}$，下方的是 $dis_{Y, u}$）：

![我是下面这张图](https://cdn.luogu.com.cn/upload/image_hosting/yzwugg5v.png)

当 $K = 13$ 时，如果直接做简化的问题，每个点的 $c$ 依次为：$[0, 2, 11, 0, 0]$，答案为 $5$。而真正的 $c$ 是：$[0, 2, 9, 0, 0]$，答案为 $4$。问题出在简化的问题认为 $c_2 = 11$ 时 $2$ 号节点对答案有 $2$ 的贡献，而事实上只有 $1$ 的贡献，因为虽然 $dis_{Y, 2} \le c_2 = 11$，但是 $3$ 号节点 $c_3 = 0 < dis_{Y, 3} = 10$，不满足条件。

为了解决出现的问题，我们可以找到一个 $mid$ 使得 $mid$ 左边的每个点 $u$ 都有 $dis_{X, u} \le dis_{Y, u}$，$mid$ 右边的每个点 $v$ 都有 $dis_{X, v} \ge dis_{Y, v}$。

因为满足 $dis_{X, u} \le c_u$ 的点一定是一段连续的点，满足 $dis_{Y, u} \le c_u$ 的点也是一段连续的。这时可以发现，所以有，满足 $dis_{X, u} \le c_u$ 的点和满足 $dis_{Y, u} \le c_u$ 的点，要么都跨过 $mid$，要么都不跨过 $mid$。

这个因为你不妨设满足 $dis_{X, u} \le c_u$ 的点跨过了 $mid$ 但满足 $dis_{Y, u} \le c_u$ 的点没跨过 $mid$，那么你一定可以让每个跨过 $mid$ 的点 $u$ 不满足 $dis_{X, u} \le c_u$，对应的让一个 $mid$ 的 $Y$ 侧的点 $v$ 满足 $dis_{Y, v} \le c_v$ 使得答案不会更劣。

然后分类讨论一下：

- 若都不跨过 $mid$，所以每个点 $u$ 只会在 $c_u \ge \min(dis_{X, u},dis_{Y, u})$ 时有 $1$ 的贡献，不会产生 $2$ 的贡献。这部分直接按 $\min(dis_{X, u},dis_{Y, u})$ 排序然后贪心选就行。
- 若都跨过 $mid$，先强制链上每个点的 $c_u = \min(dis_{X, u},dis_{Y, u})$，然后做简化问题就行。

最后就转化成了这样的问题：有两类物品，第一类会花费 $x$ 的代价，产生 $1$ 的贡献，称之为物品 $x$；第二类会先花费 $x$ 的代价，产生 $1$ 的贡献，可以再花费 $y - x$ 的代价，再产生 $1$ 的贡献，称之为物品 $(x, y - x)$。要求在代价小于等于 $K$ 的情况下最大的贡献。

可以对第二类物品下手：若 $y - x \ge x$，则这个物品 $(x, y - x)$ 可以拆成两个第一类物品：物品 $x$ 和物品 $y - x$。然后所有的第二类物品就都有 $x < y - x$ 了。

对于第一类物品来说，选的一定是排序后的一段前缀。这个是显然的。

对于第二类物品来说，选的一定是按 $y$ 排序后的一段前缀，和至多 $1$ 个物品的 $x$。

因为假设有物品 $(x_1, y_1 - x_1)$ 和物品 $(x_2, y_2 - x_2)$，你选了 $x_1$ 和 $x_2$。不妨设 $x_1 \le x_2$，那么有 $y_1 - x_1 \le x_1 \le x_2$，所以换成只选物品 $(x_1, y_1 - x_1)$ 一定不会更劣，一直换就能至多只选一个物品的 $x$。

所以这部分可以双指针做：枚举选的第一类物品的长度，然后求出最大的选第二类物品的长度，每次取个 $\max$ 就行。

$dis_{X, u}$ 和 $dis_{Y, u}$ 可以 dfs 或 bfs 求。

时间复杂度 $O(n \log n)$。

代码：

```cpp
#define fir first
#define sec second

typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<pii> vpii;
typedef vector<ll> vll;
typedef vector<pll> vpll;

template<typename T> T cmax(T &a, T b) { return a = max(a, b); }
template<typename T> T cmin(T &a, T b) { return a = min(a, b); }

const int MAXN = 2e5 + 9;
const ll INF = 2e18;
int n, x, y; ll k;
vpii G[MAXN];
ll disx[MAXN], disy[MAXN];
vll c1; vpll c2, c;

void Bfs(int s, ll dis[]) {
	queue<int> q;
	q.emplace(s), dis[s] = 0;
	while (q.size()) {
		int u = q.front(); q.pop();
		for (auto _ : G[u]) {
			int v = _.fir, w = _.sec; if (dis[v] || v == s) continue;
			dis[v] = dis[u] + w, q.emplace(v);
		}
	}
	return;
}

int calc1(vll c) {
	sort(c.begin(), c.end());
	ll sum = 0; int ans = 0;
	for (auto i : c) if ((sum += i) <= k) ans ++;
	return ans;
}

int calc2(vll c1, vpll c2) {
	if (c2.empty()) return calc1(c1);
	vll mn; int ans = 0, ret = 0; ll sum1 = 0, sum2 = 0;
	sort(c1.begin(), c1.end()), sort(c2.begin(), c2.end(), [&](pll a, pll b) { return a.fir + a.sec < b.fir + b.sec; });
	for (auto _ : c2) mn.emplace_back(_.fir); mn.emplace_back(INF);
	for (int i = 0; i + 1 < mn.size(); i ++) cmin(mn[i], mn[i + 1]);
	int i = 0, j = -1; 
	while (j + 1 < c2.size() && sum2 + c2[j + 1].fir + c2[j + 1].sec <= k) sum2 += c2[++ j].fir + c2[j].sec, ret += 2;
	cmax(ans, (sum2 + mn[j + 1] > k ? ret : ret + 1));
	while (i < c1.size()) {
		sum1 += c1[i ++], ret ++; if (sum1 > k) break;
		while (j >= 0 && sum1 + sum2 > k) sum2 -= c2[j].fir + c2[j --].sec, ret -= 2;
		cmax(ans, (sum1 + sum2 + mn[j + 1] > k ? ret : ret + 1));
	}
	return ans;
} 

int max_score(int N, int X, int Y, long long K, std::vector<int> U, std::vector<int> V, std::vector<int> W) {
	n = N, x = X, y = Y, k = K;
	for (int i = 0; i < n; i ++) vpii().swap(G[i]), disx[i] = disy[i] = 0;
	vll().swap(c1), vpll().swap(c), vpll().swap(c2);
	int ans1 = 0, ans2 = 0; ll dis;
	for (int i = 0; i < U.size(); i ++) {
		int u = U[i], v = V[i], w = W[i];
		G[u].emplace_back(v, w), G[v].emplace_back(u, w);
	}
	Bfs(x, disx), Bfs(y, disy); dis = disx[y];
	for (int i = 0; i < n; i ++) if (disx[i] > disy[i]) swap(disx[i], disy[i]);
	for (int i = 0; i < n; i ++) c1.emplace_back(disx[i]);
	ans1 = calc1(c1); c1.clear();
	for (int i = 0; i < n; i ++) {
		if (disx[i] + disy[i] == dis) ans2 ++, k -= disx[i], c1.emplace_back(disy[i] - disx[i]);
		else if (disx[i] <= disy[i] - disx[i]) c1.emplace_back(disx[i]), c1.emplace_back(disy[i] - disx[i]);
		else c2.emplace_back(disx[i], disy[i] - disx[i]);
		if (k < 0) return ans1;
	}
	ans2 += calc2(c1, c2); 
	return max(ans1, ans2);
}
```

---

## 作者：Leasier (赞：6)

- **Subtask 1：$dis_{x, y} \geq 2k$。**

此时 $x, y$ 可达的点至多只有一个交点，且如果存在交点，其一定固定。

对于不交的情况，我们预处理 $x, y$ 出发的最短路，直接排序后取前若干小即可；对于恰有一个交点的情况，特判即可。

时间复杂度为 $O(\sum n \log n)$。

- **Subtask 2 ~ 4：一条链。**

此时不交的情况仍然容易处理，我们只需要考虑在中间部分相交的情况。

对于任意一个 $i$，我们有三种选择：

- 花费 $a_i = \min(dis_{x, i}, dis_{y, i})$ 的代价，答案增加 $1$。
- 花费 $b_i = \max(dis_{x, i}, dis_{y, i})$ 的代价，答案增加 $2$。
- 如果 $i$ 不在 $(x, y)$ 路径上，我们还可以不花费代价，答案不变。
- **一个 $i$ 产生了 $a_i$ 的代价当且仅当 $i$ 在 $(x, y)$ 路径上或其存在相邻点产生了代价。**
- **一个 $i$ 产生了 $b_i$ 的代价当且仅当 $i$ 在 $(x, y)$ 路径上且其到 $x, y$ 中远端的路径上远近端相同的部分全部产生了 $b$ 的代价，或其存在相邻点产生了 $b$ 的代价。**

对于 $(x, y)$ 路径上的 $i$，注意到我们的花费至少为 $a_i$，则我们先花掉 $a_i$ 的代价，然后令 $a_i \leftarrow b_i - a_i, b_i \leftarrow \infty$ 即可。

此时问题变为以下形式：

- 对于一个 $i$，我们要么不花费代价、答案不变，要么花费 $a_i$ 的代价、答案增加 $1$，要么花费 $b_i$ 的代价、答案增加 $2$。
- 要求代价和 $\leq k$，求答案最大值。

如果不考虑前面的神秘限制，我们可以直接把 [CF436E Cardboard Box](https://www.luogu.com.cn/problem/CF436E) 的贪心搬过来。

注意到事实上从 $x \to y$ 走时一开始 $b_i$ 单调递减、在跨过远近端交界处后 $b_i$ 单调递增，则直接贪心必然会从中间开始选；而对于路径外的部分，随着远离路径端点 $a_i, b_i$ 单调递增、$b_i - a_i$ 不变，则直接贪心必然从近到远选、在反悔时选哪个都等价，于是我们直接做即可。

时间复杂度为 $O(\sum n \log n)$。

- **Subtask 5 ~ 9：无特殊限制。**

注意到对于链上任意点的“子树”，我们使用上面的贪心必然：在选 $a_i, b_i$ 时先选祖先再选自己，在反悔时选哪个都等价，于是我们仍然直接做即可。这一点与链上的情况几乎一致。

时间复杂度为 $O(\sum n \log n)$。

代码：
```cpp
#include <algorithm>
#include <queue>
#include <vector>
#include <functional>
#include <cstdlib>
#include "closing.h"

using namespace std;

typedef long long ll;

typedef struct {
	int nxt;
	int end;
	int dis;
} Edge;

typedef struct Node_tag {
	ll dis;
	int pos;
	Node_tag(ll dis_, int pos_){
		dis = dis_;
		pos = pos_;
	}
} Node1;

int cnt;
int head[200007];
Edge edge[400007];

bool operator <(const Node1 a, const Node1 b){
	return a.dis > b.dis;
}

typedef struct {
	ll dis[200007];
	ll sum[200007];
	bool vis[200007];
	queue<int> q;
	
	inline void init(int n){
		for (int i = 1; i <= n; i++){
			dis[i] = 0x7fffffffffffffffll;
			vis[i] = false;
		}
	}
	
	inline void bfs(int start){
		dis[start] = 0;
		q.push(start);
		while (!q.empty()){
			int cur = q.front();
			q.pop();
			for (int i = head[cur]; i != 0; i = edge[i].nxt){
				int x = edge[i].end;
				if (dis[x] == 0x7fffffffffffffffll){
					dis[x] = dis[cur] + edge[i].dis;
					q.push(x);
				}
			}
		}
	}
} Graph;

typedef struct Node2_tag {
	int pos;
	ll x;
	ll y;
	Node2_tag(){}
	Node2_tag(int pos_, ll x_, ll y_){
		pos = pos_;
		x = x_;
		y = y_;
	}
} Node2;

Graph g1, g2;
int vis1[200007];
ll save[400007];
bool vis2[200007];
Node2 a[200007];
priority_queue<Node2> q1;
priority_queue<Node2, vector<Node2>, greater<Node2> > q2;

bool operator <(const Node2 a, const Node2 b){
	return a.x > b.x;
}

bool operator >(const Node2 a, const Node2 b){
	return a.y > b.y;
}

inline void init(int n){
	cnt = 0;
	for (int i = 1; i <= n; i++){
		head[i] = 0;
	}
}

inline void add_edge(int start, int end, int dis){
	cnt++;
	edge[cnt].nxt = head[start];
	head[start] = cnt;
	edge[cnt].end = end;
	edge[cnt].dis = dis;
}

inline int solve(int n, int m, ll k, bool flag){
	int ans = 0;
	while (!q1.empty()) q1.pop();
	while (!q2.empty()) q2.pop();
	for (int i = 1; i <= n; i++){
		vis1[i] = 0;
		vis2[i] = false;
	}
	for (int i = 1; i <= m; i++){
		vis2[a[i].pos] = true;
		q1.push(a[i]);
	}
	for (int i = 1; i <= n; i++){
		if (!vis2[i]){
			ll x = max(g1.dis[i], g2.dis[i]);
			q1.push(Node2(i, min(g1.dis[i], g2.dis[i]), x));
			q2.push(Node2(i, 0, x));
		}
	}
	if (flag) q1.push(Node2(0, 0, 4e18));
	while (true){
		ll x, y;
		while (!q1.empty() && vis1[q1.top().pos] == 2) q1.pop();
		while (!q2.empty() && vis1[q2.top().pos] == 1) q2.pop();
		if (q1.size() <= 1){
			x = 4e18;
		} else {
			Node2 cur = q1.top();
			q1.pop();
			while (!q1.empty() && vis1[q1.top().pos] == 2) q1.pop();
			if (q1.empty()){
				x = 4e18;
			} else {
				x = cur.x + q1.top().x;
			}
			q1.push(cur);
		}
		if (q2.empty()){
			y = 4e18;
		} else {
			y = q2.top().y;
		}
		k -= min(x, y);
		if (k < 0) break;
		if (x < y){
			Node2 p, q;
			while (!q1.empty() && vis1[q1.top().pos] == 2) q1.pop();
			p = q1.top();
			q1.pop();
			while (!q1.empty() && vis1[q1.top().pos] == 2) q1.pop();
			q = q1.top();
			q1.pop();
			if (p.pos != 0){
				vis1[p.pos] = 1;
				q1.push(Node2(p.pos, p.y - p.x, 4e18));
				ans++;
			}
			if (q.pos != 0){
				vis1[q.pos] = 1;
				q1.push(Node2(q.pos, q.y - q.x, 4e18));
				ans++;
			}
		} else {
			Node2 cur = q2.top();
			q2.pop();
			vis1[cur.pos] = 2;
			ans += 2;
		}
	}
	return ans;
}

int max_score(int N, int X, int Y, ll K, vector<int> U, vector<int> V, vector<int> W){
    int m = 0, cnt = 0, must = 0, ans;
	ll sum = 0;
	X++;
	Y++;
	init(N);
	g1.init(N);
	g2.init(N);
	for (int i = 0; i < N - 1; i++){
		U[i]++;
		V[i]++;
		add_edge(U[i], V[i], W[i]);
		add_edge(V[i], U[i], W[i]);
	}
	g1.bfs(X);
	g2.bfs(Y);
	for (int i = 1; i <= N; i++){
		save[++m] = g1.dis[i];
		save[++m] = g2.dis[i];
	}
	sort(save + 1, save + m + 1);
	save[++m] = 4e18;
	for (int i = 1; i <= m; i++){
		sum += save[i];
		if (sum > K){
			ans = i - 1;
			break;
		}
	}
	for (int i = 1; i <= N; i++){
		if (g1.dis[i] + g2.dis[i] == g1.dis[Y]){
			K -= min(g1.dis[i], g2.dis[i]);
			must++;
			a[++cnt] = Node2(i, llabs(g1.dis[i] - g2.dis[i]), 4e18);
		}
	}
	if (K >= 0) ans = max(ans, max(solve(N, cnt, K, false), solve(N, cnt, K, true)) + must);
	return ans;
}
```

---

## 作者：ducati (赞：4)

提供一种和所有现有题解截然不同的做法。

## Description

[传送门](https://www.luogu.com.cn/problem/P9600)

## Solution

先考虑只有一个主要城市怎么做。令唯一的主要城市为 $X$，$d_u$ 为 $u$ 到根的路径长度。

**考虑贪心**，将所有点按 $d$ 排序并依次加入。由于 $d$ 较小的点先于 $d$ 较大的点被加入，因此符合树上依赖关系，贪心是正确的。

使用优先队列可以做到 $O(n \log n)$。

---

考虑有两个主要城市 $X, Y$ 怎么做。

考虑先对 $X$ 跑前述做法，得到 $\{a_0, a_1, \cdots, a_n\}$，其中 $a_i$ 表示前 $i$ 个加入的城市的 $d$ 的总和。同理，对 $Y$ 求出 $\{b_0, b_1, \cdots, b_n\}$，那么，答案为满足 $a_i + b_j \le K$ 的最大 $i + j$，可通过双指针求出。

**但这个做法是错的**。原因也很显然，若 $u$ 可达 $X,Y$，则 $\text{dis}(u, X) + \text{dis}(u, Y)$ 会被累加进总和，而非正确的 $\max(\text{dis}(u, X), \text{dis}(u, Y))$，导致最终算出的答案会**偏小**。

另一方面，若**不存在点均可达 $\boldsymbol{X}$ 和 $\boldsymbol{\text{Y}}$**，则此算法是正确的。下面只需考虑，如果存在这样的点，我们该怎么做。

---

令 $X$ 到 $Y$ 路径上的点依次为 $p_1, p_2, \cdots, p_k$，则存在 $t$ 满足 $p[1, t]$ 距 $X$ 较近，而 $p(t, k]$ 距 $Y$ 较近。由于存在点均可达 $X, Y$，因此 $p[1, t]$ 均可达 $X$，$p(t, k]$ 均可达 $Y$，**这一部分的代价可预先加上**。

令 $a_i, b_i$ 分别为使 $i$ 可达 $X,Y$ 的**额外代价**。考虑以 $X$ 到 $Y$ 的链为根，对于链上任意一点 $u$，在 $u$ 的子树内，**祖先的 $\boldsymbol{a}$ 必大于子孙的 $\boldsymbol{a}$**，$b$ 同理。

根据这个性质，问题可以直接被转化为：求序列 $x$，满足所有 $x$ 中元素均 $\in \{0,1,2\}$，在 $\sum_i  c_{i,x_i} \le K$ 的前提下，最大化 $\sum_i x_i$。其中

$$c_{i,j} = \begin{cases} 0 \ (j = 0) \\ \min(a_i, b_i) \ (j = 1) \\ \max(a_i, b_i) \ (j = 2) \end{cases}$$

---

这似乎是个经典问题，但又似乎并不简单。

考虑将所有 $i$ 按 $\max(a_i, b_i)$ 排序，则存在某个最优解 $x$，使得不存在 $i_1, i_2$，满足 $i_1$ 排序后在 $i_2$ 前面且 $x_{i_1} = 0, x_{i_2} = 2$。

枚举分界点，钦定左侧所有 $x_i$ 均 $\in \{1, 2\}$，右侧所有 $x_i$ 均 $\in \{0, 1\}$，先将左侧所有 $x$ 设为 $1$，右侧所有 $x$ 设为 $0$，再进行调整，每次选择增量最小的位置，将 $x$ 增大 $1$，时刻确保 $\sum_i  c_{i,x_i} \le K$ 即可。

暴力实现是 $O(n^2)$ 的。通过扫描线 + 动态开点线段树上二分，可以优化至 $O(n \log V)$，其中 $V = \max_u \{d_u\}$，足以通过本题。

## Code

```cpp
#include "closing.h"
#include "bits/stdc++.h"
#define ll long long
using namespace std;
const int MAXN = 2e5 + 5;
const ll V = 2e11, LGV = 40, inf = 2e18;

int N, X, Y, ans, fa[MAXN]; vector<pair<int, int>> Tr[MAXN];
bool inp[MAXN]; ll K, suf[MAXN], dis[MAXN], disX[MAXN], disY[MAXN];

struct node{
	ll x, y;
	bool operator < (const node &A) const {return y > A.y; }
}a[MAXN];
struct cmp {
	bool operator() (const int x, const int y) {return dis[x] > dis[y]; }
};
class Segment_tree {
private:
	int tot, root;
	struct segtree_node{
		int ls, rs, cnt; ll sum;
		segtree_node() {ls = rs = cnt = sum = 0;}
	}tr[MAXN * LGV];
	int newnode() {
		tr[++tot] = segtree_node();
		return tot;
	}
	void upd_add(ll nl, ll l, ll r, int &rt, int op) {
		if (!rt)  rt = newnode();
		tr[rt].cnt += op;
		tr[rt].sum += nl * op;

		if (l ^ r) {
			ll mid = (l + r) >> 1;
			if (nl <= mid)  upd_add(nl, l, mid, tr[rt].ls, op);
			else upd_add(nl, mid + 1, r, tr[rt].rs, op);
		}
	}
public:
	void clear() {tot = root = 0;}
	void insert(ll x) {
		if (x < inf - V)  upd_add(x, 0, V, root, 1);
	}
	void erase(ll x) {
		if (x < inf - V)  upd_add(x, 0, V, root, -1);
	}
	int query(ll maxsum) {
		if (maxsum < 0)  return -N;
		if (tr[root].sum <= maxsum)  return tr[root].cnt;

		ll l = 0, r = V, rt = root, res = 0;
		while (l < r) {
			if (!rt)  return res;

			ll mid = (l + r) >> 1;
			if (tr[tr[rt].ls].sum <= maxsum) {
				maxsum -= tr[tr[rt].ls].sum;
				res += tr[tr[rt].ls].cnt;
				rt = tr[rt].rs;
				l = mid + 1;
			}
			else {
				rt = tr[rt].ls;
				r = mid;
			}
		}
		return res + maxsum / l;
	}
}sgt;

void Add(int u, int v, int w) {
	Tr[u].emplace_back(v, w);
	Tr[v].emplace_back(u, w);
}
int solve_pairs(ll K) {
	int res = 0;
	for (int i = 1; i <= N; i++) {
		if (a[i].x > a[i].y)  swap(a[i].x, a[i].y);
	}
	sort(a + 1, a + N + 1);
	for (int i = 1; i <= N; i++)  sgt.insert(a[i].y - a[i].x);
	for (int i = N; i >= 1; i--)  suf[i] = min(suf[i + 1] + a[i].x, inf);
	for (int r = 0; r <= N; r++) {
		if (r) {
			sgt.erase(a[r].y - a[r].x);
			sgt.insert(a[r].x);
		}
		res = max(res, N - r + sgt.query(K - suf[r + 1]));
	}
	sgt.clear(), fill(suf, suf + N + 1, 0);
	return res;
}
void solve_disjoint() {
	auto get_vec = [&](int rt) {
		vector<ll> res;
		priority_queue<int, vector<int>, cmp> pq;
		function<void(int, int, ll)> get_dis = [&](int u, int F, ll dist) {
			dis[u] = dist, fa[u] = F;
			for (auto &[v, w] : Tr[u]) {
				if (v ^ F)  get_dis(v, u, dist + w);
			}
		};
		get_dis(rt, 0, 0), pq.emplace(rt), res.emplace_back(0);
		while (!pq.empty()) {
			int u = pq.top(); pq.pop(), res.emplace_back(dis[u]);
			for (auto &[v, w] : Tr[u]) {
				if (v ^ fa[u])  pq.emplace(v);
			}
		}
		for (int i = 1; i <= N; i++)  res[i] += res[i - 1];
		return res;
	};
	vector<ll> A = get_vec(X), B = get_vec(Y);
	for (int i = 0, j = N; i <= N && A[i] <= K; i++) {
		while (j > 0 && A[i] + B[j] > K)  j--;
		ans = max(ans, i + j);
	}
}
void solve_intersect() {
	ll retK = K; vector<int> stk, path;
	function<void(int, int, ll)> dfsX = [&](int u, int F, ll dist) {
		disX[u] = dist;
		stk.emplace_back(u);
		if (u == Y)  path = stk;
		for (auto &[v, w] : Tr[u]) {
			if (v ^ F)  dfsX(v, u, dist + w);
		}
		stk.pop_back();
	};
	function<void(int, int, ll)> dfsY = [&](int u, int F, ll dist) {
		disY[u] = dist;
		for (auto &[v, w] : Tr[u]) {
			if (v ^ F)  dfsY(v, u, dist + w);
		}
	};
	dfsX(X, 0, 0), dfsY(Y, 0, 0);

	for (int x : path)  inp[x] = true;
	for (int x : path) {
		function<void(int, int)> dfs = [&](int u, int F) {
			if (u == x)  a[u] = node{abs(disY[u] - disX[u]), inf};
			else a[u] = node{disX[u], disY[u]};

			for (auto &[v, w] : Tr[u]) {
				if ((v ^ F) && !inp[v])  dfs(v, u);
			}
		};
		dfs(x, 0);
		retK -= min(disX[x], disY[x]);
	}
	if (retK >= 0)  ans = max(ans, solve_pairs(retK) + (int)path.size());
	for (int x : path)  inp[x] = false;
}
int max_score(int _N, int _X, int _Y, ll _K, vector<int> _U, vector<int> _V, vector<int> _W) {
	N = _N, X = _X + 1, Y = _Y + 1, K = _K;
	for (int u = 1; u <= N; u++)  Tr[u].clear();
	for (int i = 0; i < N - 1; i++)  Add(_U[i] + 1, _V[i] + 1, _W[i]);

	ans = 0;
	solve_disjoint();
	solve_intersect();
	return ans;
}
```


---

## 作者：Petit_Souris (赞：2)

不是很 ez，但是肯定不算难，IOI 23 D1 签到题。

$83$ 分只要交换一下维度，写个树形 dp，$f_{u,i}$ 表示 $u$ 子树获得 $i$ 个点的最小代价，可能要加点 $\mathcal O(1)$ 的状态，$X\to Y$ 的链处理一下，应该能做到 $\mathcal O(n^2)$。然而这对于正解毫无帮助，这就是这题的幽默之处了。

想做到 $100$ 分 dp 显然是不太可行了，得往贪心的方面想。我们思考 Sub 1，显然可以直接每次选代价最小的加入。为什么这是正确的？因为两个连通块不相交，而对于树形依赖的部分，**越深的节点代价越贵，因此不会出现“先苦后甜”，即先拿个亏的节点，为了拿一个便宜的儿子节点的情况。**

能不能拓展到有相交的情况？考虑 $X\to Y$ 的链，如果相交意味着这条链上每个点都被取到了至少一次。我们可以先计算掉这一次的贡献，那么剩下的部分就是以 $\max (d_1,d_2) - \min(d_1, d_2)$ 的代价获得 $1$ 的贡献。我们发现去除这条链之后，挂出来的子树用不相交的做法就可以如法炮制了。

因此容易编出完整做法了：处理完链上的情况后，相当于每个物品是一个二元组 $(a_i, b_i)$：可以跳过，或者花 $a_i$ 代价获得 $1$ 的贡献，或者花 $b_i$ 代价获得 $2$ 贡献。（如果是链上的点，$b_i = +\infty$）

按照 $b$ 排序。那么显然不会出现 $b_i<b_j$，给 $i$ 选了跳过，但是给 $j$ 选了 $2$ 贡献。

因此最后答案的结构一定是一段前缀 $\ge 1$，一段后缀 $\le 1$。枚举前缀之后容易用数据结构维护，复杂度 $\mathcal O(n\log n)$。我偷懒写了 $\mathcal O(n\log ^2 n)$ 的二分。

```cpp
#include "closing.h"
#include <bits/stdc++.h>
using ll = long long;
using ld = long double;
using ull = unsigned long long;
using namespace std;
template <class T>
using Ve = vector<T>;
#define pii pair<ll, ll>
#define rep(i, a, b) for(int i = (a); i <= (b); ++i)
#define per(i, a, b) for(int i = (a); i >= (b); --i)
#define pb push_back
const int maxN = 2e5 + 9;
const ll INF = 2e18;
Ve<pii> to[maxN];
Ve<int> path;
bool flag;
ll dis[2][maxN], dep[maxN], c1[maxN], c2[maxN];
void dfs(int x, int fa, int id) {
    dis[id][x] = dep[x];
    for(auto [y, w] : to[x]) {
        if (y != fa) dep[y] = dep[x] + w, dfs(y, x, id);
    }
}
void dfs2(int x, int fa, int tar){
    if(flag) return ;
    path.pb(x);
    if(x == tar) {
        flag = 1;
        return ;
    }
    for(auto [y, w] : to[x]) {
        if(y == fa) continue;
        if(flag) return ;
        dfs2(y, x, tar);
    }
    if(flag) return ;
    path.pop_back();
}
ll tmp[maxN << 1];
int len;
struct BIT {
    ll bit[maxN << 1], len;
    void Init(int _len) {
        len = _len;
        rep(i, 0, len + 1) bit[i] = 0;
    }
    void Upd(int x, ll k) {
        while(x <= len) bit[x] = min(INF, bit[x] + k), x += (x & (-x));
    }
    ll Query(int x) {
        ll res = 0;
        while(x) res = min(INF, res + bit[x]), x -= (x & (-x));
        return res;
    }
} B1, B2;
int Find(ll k) {
    int l = 1, r = len, pos = 1;
    while(l <= r) {
        int mid = (l + r) >> 1;
        if(B2.Query(mid) >= k) pos = mid, r = mid - 1;
        else l = mid + 1;
    }
    int ans = B1.Query(pos - 1);
    k -= B2.Query(pos - 1);
    if(tmp[pos] <= 0) ans += B1.Query(pos) - B1.Query(pos - 1);
    else ans += min(k / tmp[pos], B1.Query(pos) - B1.Query(pos - 1));
    return ans;
}
int max_score(int N, int X, int Y, ll K, Ve<int> U, Ve<int> V, Ve<int> W) {
    rep(i, 0, N - 1) to[i].clear();
    path.clear();
    rep(i, 0, N - 2) {
        to[U[i]].pb({V[i], W[i]});
        to[V[i]].pb({U[i], W[i]});
    }
    dep[X] = 0, dfs(X, -1, 0);
    dep[Y] = 0, dfs(Y, -1, 1);
    rep(i, 0, N - 1) {
        c1[i] = min(dis[0][i], dis[1][i]);
        c2[i] = max(dis[0][i], dis[1][i]);
    }
    flag = 0;
    dfs2(X, 0, Y);
    Ve<ll> c;
    rep(i, 0, N - 1) c.pb(c1[i]);
    sort(c.begin(), c.end());
    int ans = 0; ll tK = K;
    for(ll x : c) {
        if(tK >= x) tK -= x, ++ans;
    }
    int ans2 = 0;
    for(int x : path) {
        K -= c1[x], ++ans2;
        c1[x] = c2[x] - c1[x], c2[x] = INF;
    }
    if(K < 0) return ans;
    Ve<pii> A;
    len = 0;
    rep(i, 0, N - 1) A.pb({c1[i], c2[i]}), tmp[++len] = c1[i], tmp[++len] = c2[i] - c1[i];
    sort(tmp + 1, tmp + len + 1);
    len = unique(tmp + 1, tmp + len + 1) - tmp - 1;
    B1.Init(len), B2.Init(len);
    sort(A.begin(), A.end(), [&](pii a, pii b) {
        return a.second < b.second || (a.second == b.second && a.first < b.first);
    });
    Ve<pii> B;
    for(auto [x, y] : A){
        int px = lower_bound(tmp + 1, tmp + len + 1, x) - tmp;
        int py = lower_bound(tmp + 1, tmp + len + 1, y - x) - tmp;
        B.pb({px, py});
    }
    rep(i, 0, N - 1) {
        B1.Upd(B[i].first, 1);
        B2.Upd(B[i].first, A[i].first);
    }
    rep(i, 0, N) {
        if(K < 0) break;
        ans = max(ans, ans2 + Find(K) + i);
        if(i < N) {
            B1.Upd(B[i].first, -1);
            B2.Upd(B[i].first, -A[i].first);
            K -= A[i].first;
            B1.Upd(B[i].second, 1);
            B2.Upd(B[i].second, A[i].second - A[i].first);
        }
    }
    return ans;
}
```

---

## 作者：Mirasycle (赞：1)

由于 $nk$ 是很大的，所以不是树上背包，是贪心之类的算法。

对于第一档部分分 $X,Y$ 选择点不重合的时候，就是按照 $dis$ 从小到大分配即可。因为我们优先选择 $dis$ 小的点，所以肯定是某个点被选择之前，它到 $X/Y$ 路径上的所有点肯定被选择过了，这个是符合约束条件的。

但是 $X,Y$ 取到点可能会有交。于是设 
$$c_{i,1}=\min(dis(X,i),dis(Y,i))$$

$$c_{i,1}=\max(dis(X,i),dis(Y,i))$$

分别表示 $i$ 点贡献 $1/2$ 的代价。

这个形式就是 [CF436E Cardboard Box](https://www.luogu.com.cn/problem/CF436E)，但是会有若干约束。

我们将树分为 $A,B,C$ 三个部分，$A$ 部分代表路径 $(X,Y)$ 外侧的部分，$B$ 部分代表路径 $(X,Y)$，$C$ 部分代表路径 $(X,Y)$ 下部挂着的子树。

对于 $A$ 部分的 $X$ 侧，如果对于某个 $u$ 点其选择了某个状态 $c_{u,i}$，则 $(u,X)$ 路径上每个点 $v$ 必然选择状态 $c_{v,\ge i}$。对于 $B$ 部分，约束的是 $u$ 到 $X-Y$ 中点的路径上必须选过。对于 $C$ 部分约束其最上面那个在路径上的点选过。

可以发现对于 $A$ 部分，$X\to u$ 路径上的 $c$ 是单调递增的，所以我们贪心的时候必然先选择了前面的点，因此这个约束必然满足，不需要额外限制。

对于 $B$ 部分，可以发现链上 $c_{i,2}$ 呈单谷，所以必然也是先选择了中间点，也是等价于不需要额外限制。

对于 $C$ 部分，可以发现贪心算法应该是保证了先选择上面的点，所有也是满足的。

注意上面只说了 $c_{i,2}$ 单谷，$c_{i,1}$ 则是单峰的并不满足这个性质。所以我们先需要特判一下 $X,Y$ 选择点不重合的情况。也就是运行一下第一档部分分的做法。

然后此时就只需要考虑重合了，我们就提前把 $(X,Y)$ 路径上的所有点的 $c_{i,1}$ 给选上，然后再运行 CF436E 的贪心就行了。正确性上面已经说过了。

这里复述一下 CF436E 的做法。

考虑使用反悔贪心。

直接选择的策略是花费 $a_i$ 购买一颗星，和花 $b_i-a_i$ 再购买第二颗星。

反悔策略一定要考虑全，反悔的策略是把一个一星不选，选另一个两星和把一个两星降为一星，选择另一个两星。由于一星已经放在直接选择的选项里了，所以反悔不需要考虑选择一星。

动态维护选 $i$ 颗星的最小代价，维护若干选法的最小值，每次从堆中选择最小代价扩展一个即可。

套用这个做法，时间复杂度 $O(n\log n)$。


```cpp
#include "closing.h"
#include<bits/stdc++.h>
#define pb emplace_back
#define fi first
#define se second
#define mp make_pair
using namespace std;
typedef long long ll;
typedef vector<int> vi;
const int maxn=2e5+10;
void cmax(int &x,int y){ x=x>y?x:y; }
void cmin(int &x,int y){ x=x<y?x:y; }
int n,S,T; ll dis[maxn][2];
vector<pair<int,int> > G[maxn];
namespace Greedy{
	struct node{
		int x; ll v;
		bool operator < (const node &rhs) const { return v>rhs.v; }
	}; ll a[maxn],b[maxn],ans; int vis[maxn];
	struct Q{
		priority_queue<node> q; int t;
		void upd(){ while(q.size()&&vis[q.top().x]!=t) q.pop(); }
		bool empty(){ upd(); return q.empty(); }
		node top(){ upd(); return q.top(); }
		void push(node z){ q.push(z); }
		void clear(){ while(q.size()) q.pop(); }
	}q1,q2,q3,q4,q5;
	void push0(int x){ vis[x]=0; q1.push((node){x,a[x]}); q4.push((node){x,b[x]}); }
	void push1(int x){ vis[x]=1; q2.push((node){x,b[x]-a[x]}); q3.push((node){x,-a[x]}); }
	void push2(int x){ vis[x]=2; q5.push((node){x,a[x]-b[x]}); }
	int solve(ll K){
		if(K<0) return 0; ans=0;
		for(int i=1;i<=n;i++) vis[i]=0;
		q1.clear(); q2.clear(); q3.clear(); q4.clear(); q5.clear();
		for(int i=1;i<=n;i++) q1.push((node){i,a[i]}),q4.push((node){i,b[i]});
		q1.t=q4.t=0; q2.t=q3.t=1; q5.t=2;
		for(int i=1;i<=n+n;i++){
			ll res=1e18,x,y,op;
			if(!q1.empty()){
				ll id=q1.top().x,val=q1.top().v;
				x=id; op=1; res=val;
			}
			if(!q2.empty()){
				ll id=q2.top().x,val=q2.top().v;
				if(val<res) x=id,op=2,res=val;	
			}
			if(!q3.empty()&&!q4.empty()){
				ll id1=q3.top().x,v1=q3.top().v;
				ll id2=q4.top().x,v2=q4.top().v;
				if(v1+v2<res) res=v1+v2,x=id1,y=id2,op=3;
			}
			if(!q5.empty()&&!q4.empty()){
				ll id1=q5.top().x,v1=q5.top().v;
				ll id2=q4.top().x,v2=q4.top().v;
				if(v1+v2<res) res=v1+v2,x=id1,y=id2,op=4;			
			}
			ans+=res; if(ans>K) return i-1;
			if(op==1) push1(x);
			if(op==2) push2(x);
			if(op==3) push0(x),push2(y);
			if(op==4) push1(x),push2(y);
		}
		return n+n;
	}
}
priority_queue<ll> q;
void dfs(int u,int fa,int t){
	for(auto z:G[u]){
		int v=z.fi,w=z.se;
		if(v==fa) continue;
		dis[v][t]=dis[u][t]+w; dfs(v,u,t);
	}
}
int max_score(int N,int X,int Y,ll K,vi U,vi V,vi W){
	n=N; S=X+1; T=Y+1;
	for(int i=1;i<=n;i++) G[i].clear();
	while(q.size()) q.pop();
	for(int i=0;i<n-1;i++) G[U[i]+1].pb(V[i]+1,W[i]),G[V[i]+1].pb(U[i]+1,W[i]);
	for(int i=1;i<=n;i++) dis[i][0]=dis[i][1]=0;
	dfs(S,0,0); dfs(T,0,1); ll tmp=K; int A=0;
	for(int i=1;i<=n;i++) q.push(-min(dis[i][0],dis[i][1])); 
	while(q.size()){
		ll cost=-q.top(); q.pop();
		if(cost>tmp) break;
		tmp-=cost; A++;
	}
	for(int i=1;i<=n;i++) 
		Greedy::a[i]=min(dis[i][0],dis[i][1]),Greedy::b[i]=max(dis[i][0],dis[i][1]);
	for(int i=1;i<=n;i++)
		if(dis[i][0]+dis[i][1]==dis[T][0]){
			Greedy::b[i]-=Greedy::a[i];
			K-=Greedy::a[i]; Greedy::a[i]=0;
		}
	return max(A,Greedy::solve(K));
}
```

---

## 作者：cryozwq (赞：1)

考虑 $S,T$ 能到达的都是包括自己的连通块，当这两个连通块不交的时候是简单贪心，有交的话，考虑为什么贪心不对，假设一个点 $dis_{1,i}<dis_{2,i}$，第一次的时候代价是 $dis_{1,i}$ ，第二次的时候代价不是 $dis_{2,i}$ 而是 $dis_{2,i}-dis_{1,i}$，这个玩意在序列上是[一道经典题](https://www.luogu.com.cn/problem/CF436E)，但显然不能直接套到树上，为什么呢？因为树限制了选的先后顺序，这里有一个重要观察：如果能满足父亲权值小于儿子，那么这个限制等价于不存在。事实上，当两者连通块有交的时候说明**两者的路径上的点都被选过至少一次了**，我们考虑路径上的类似“中点”（即左边 $dis_{1,i} \le dis_{2,i}$，右边反之），容易知道如果我们确定路径都被选过至少一次了，那么中点两边都能无视刚才的限制，可以套用刚才那个题的贪心，如果不是都选过一次，就是两者连通块不交，简单贪心。

 宣传一下 [0htoai 提供的原题贪心做法](https://www.luogu.com.cn/blog/hanhan-zz/cf436e-cardboard-box-ti-xie)。
 
```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
typedef long long ll;
const int maxn=6e5+5;
int n,x,y;
ll k;
ll dis1[maxn],dis2[maxn];
struct Edge{
	ll w;
	int v,nxt;
}e[maxn];
int cnt,h[maxn];
void add(int u,int v,ll w){
	e[++cnt].v=v;
	e[cnt].w=w;
	e[cnt].nxt=h[u];
	h[u]=cnt;
}
void dfs1(int u,int fa){for(int i=h[u];i;i=e[i].nxt){int v=e[i].v;if(v==fa)continue;dis1[v]=dis1[u]+e[i].w;dfs1(v,u);}}
void dfs2(int u,int fa){for(int i=h[u];i;i=e[i].nxt){int v=e[i].v;if(v==fa)continue;dis2[v]=dis2[u]+e[i].w;dfs2(v,u);}}
struct node{
	int u,tp;
	ll x;
};
priority_queue<node>q;
inline bool operator <(node a,node b){	
//	if(a.x==b.x)return a.tp>b.tp;
	return a.x>b.x;
}
int dep[maxn],fath[maxn];
void dfs(int u,int fa){
	dep[u]=dep[fa]+1;fath[u]=fa;
	for(int i=h[u];i;i=e[i].nxt){
		int v=e[i].v;
		if(v==fa)continue;
		dfs(v,u);
	}
}
int path[maxn],tot,tmp1[maxn],tmp2[maxn];
void getpath(int x,int y){
	tot=0;
	if(dep[x]<dep[y])swap(x,y);
	while(dep[x]>dep[y])path[++tot]=x,x=fath[x];
//	cout<<x<<" "<<y<<endl;
	int t1=0,t2=0,lca;
	while(x!=y){
		tmp1[++t1]=x;
		tmp2[++t2]=y;
		x=fath[x],y=fath[y];
	}
	for(int i=1;i<=t1;i++)path[++tot]=tmp1[i];
	path[++tot]=x;
	for(int i=t2;i>=1;i--)path[++tot]=tmp2[i]; 
}
bool vis[maxn][2];
const ll inf=1e16;
int solve1(){
	ll tk=k;
	while(q.size())q.pop();
	q.push((node){x,1,0});
	q.push((node){y,2,0});
	int ct=0;
	while(q.size()){
		node t=q.top();
		q.pop();
//		cout<<tk<<" "<<t.u<<" "<<t.x<<endl;
		if(tk<t.x)return ct;
		tk-=t.x;
		ct++;
		int u=t.u;
		vis[u][t.tp]=1;
		for(int i=h[u];i;i=e[i].nxt){
			int v=e[i].v;
			if(vis[v][t.tp])continue;
			if(t.tp==1)q.push((node){v,t.tp,dis1[v]});
			else q.push((node){v,t.tp,dis2[v]});
		}		
	}
	return ct;
} 
priority_queue<node>q1,q2;
bool vis1[maxn],vis2[maxn];
bool vs[maxn],vv[maxn];
#define pop1 while(q1.size()&&vis2[q1.top().u])q1.pop();	
#define pop2 while(q2.size()&&vis1[q2.top().u])q2.pop();
inline ll solve2(bool type){
	int ct=0;
	for(int i=1;i<=tot;i++)vs[path[i]]=1;
	while(q1.size())q1.pop();
	while(q2.size())q2.pop();
	for(int i=1;i<=n;i++){
		vv[i]=0;
		if(vs[i])continue;
		q1.push((node){i,1,min(dis1[i],dis2[i])});
//		cout<<min(dis1[i],dis2[i])<<"----"<<i<<endl;
		q2.push((node){i,2,max(dis1[i],dis2[i])});
	}
	for(int i=1;i<=n;i++)vis1[i]=vis2[i]=0; 
	ll tk=k;
	if(type)q1.push((node){0,0,0});
	for(int i=1;i<=tot;i++){ 
		ct++;
		tk-=min(dis1[path[i]],dis2[path[i]]);
		q1.push((node){path[i],1,labs(dis2[path[i]]-dis1[path[i]])});
//		cout<<path[i]<<":"<<i<<endl;
//		vis2[]
	}
//	cout<<ct<<" "<<tk<<endl;
//	vis2[0]=1;
	if(tk<0)return -inf;
	while(1){
//		cout<<tk<<endl;
		pop1;pop2;
		if(!q1.size()&&!q2.size())break;
		ll x1,x2,x3,c1=0,c2=0,c3=0;
		int id1=0,id2=0,id3=0;
		if(q1.size())x1=q1.top().x,id1=q1.top().u,c1=q1.top().tp,q1.pop();
		else x1=inf;
		pop1;
		if(q1.size())x2=q1.top().x,id2=q1.top().u,c2=q1.top().tp,q1.pop();
		else x2=inf;
		if(q2.size())x3=q2.top().x,id3=q2.top().u,c3=q2.top().tp,q2.pop();
		else x3=inf; 
		if(x3<x1+x2){		
			tk-=x3;
			if(tk<0)return ct;
			vis2[id3]=1;
//			cout<<id3<<":"<<c3<<" ";
//			if(c3)cout<<id3<<endl;
			ct+=c3;
			q1.push((node){id1,c1,x1});
			q1.push((node){id2,c2,x2});
//			upd(id3);
		}
		else{
			tk-=x1;tk-=x2;
			if(tk<0)return ct;
//			cout<<id1<<":"<<c1<<" "<<id2<<":"<<c2<<" ";
//			if(c1)cout<<id1<<endl;
//			if(c2)cout<<id2<<endl;
			ct+=c1;ct+=c2;
			vis1[id1]=vis1[id2]=1;
			q2.push((node){id3,c3,x3});
			if(!vv[id1]&&!vis2[id1]&&!vs[id1]&&id1)q1.push((node){id1,c1,labs(dis2[id1]-dis1[id1])}),vv[id1]=1;
			if(!vv[id2]&&!vis2[id2]&&!vs[id2]&&id2)q1.push((node){id2,c2,labs(dis2[id2]-dis1[id2])}),vv[id2]=1;
		}
	}
	return ct;
}
int max_score(int N, int X, int Y, ll K,vector<int> U, vector<int> V, vector<int> W){
		n=N;x=X;y=Y;k=K;
		x++;y++;
		for(int i=1;i<=n;i++)h[i]=vis[i][0]=vis[i][1]=vs[i]=0;
		cnt=0;
		for(int i=1;i<n;i++){
			int u,v;
			ll w;
			u=U[i-1];
			v=V[i-1];
			w=W[i-1];
			u++;v++;
			add(u,v,w);
			add(v,u,w);
		}
		dis1[x]=dis2[y]=0;
		dfs1(x,0);dfs2(y,0);dfs(1,0);
		int ans=solve1();
		getpath(x,y);
		ans=max(ans,(int)solve2(0));
//		cout<<ans<<endl;
		ans=max(ans,(int)solve2(1));return ans;
}  
```

---

## 作者：tribool4_in (赞：0)

非常好贪心题。

首先最优情况下 $c_i$ 应当刚好够被某个起点走到或直接为 $0$，即 $c_i=d_{X,i}$ 或 $c_i=d_{Y,i}$ 或 $c_i=0$。若 $c_i=\min(d_{X,i},d_{Y,i})$ 则贡献为 $1$，$c_i=\max(d_{X,i},d_{Y,i})$ 则贡献为 $2$，否则为 $0$。发现这个形式很像 CF436E，但是此题为限制代价（这个转化是容易的），且具有树形的依赖关系。

考虑 $X$ 和 $Y$ 各自覆盖的连通块，如果两者无交是容易处理的，直接排序贪心。否则考虑如果直接按照 CF436E 做会怎样，令 $a_i=\min(d_{X,i},d_{Y,i})$，$b_i=\max(d_{X,i},d_{Y,i})$。

取出 $X-Y$ 的路径。对于不在路径上的点，将路径视为根，则显然有 $a_{fa_i}<a_i,b_{fa_i}<b_i$，即如果自己被选而父亲未被选一定不优。所以树形依赖一定满足。

对于路径上的点，首先可以发现每个点一定贡献至少 $1$，于是先默认将他们选上并考虑哪些点贡献为 $2$，发现由于依赖关系，一定是路径上连续的一段。此时考虑令这些点的 $a_i=\max(d_{X,i},d_{Y,i})-\min(d_{X,i},d_{Y,i})$ 并直接贪心，可以发现这样取出的一定是一段。证明的话考虑取出“中边” $u-v$ 分别满足 $d_{X,a}<d_{Y,a}$，$d_{X,b}>d_{Y,b}$，则发现选择靠近“中边”的点一定优于远离“中边”的点，因此选择的一定是包含“中边”（或与之相邻）的一段点。（可以直接令 $b_i=\inf$）

因此原题转化为 CF436E 的形式，限制代价问最大贡献。考虑按照 $b_i$ 排序，然后对于一对 $i<j$，容易发现若 $i$ 选择贡献 $0$ 则 $j$ 一定不会贡献 $2$（否则可以交换不劣）。于是最优解一定满足一段前缀贡献全部 $>0$，其余贡献全部 $<2$。于是枚举前缀长度，前缀中的数可以用 $b_i-a_i$ 代价多产生 $1$ 贡献，后缀中的数可以用 $a_i$ 代价产生 $1$ 贡献，用数据结构维护即可。

我原题代码使用了平衡树，于是喜提最劣解。

```cpp
// #include "closing.h"

#include <bits/stdc++.h>

#define int long long
using namespace std;
const int N = 4e5 + 10, INF = 1e18;
namespace Cardboard {
    namespace FhqTreap {
        struct node {
            int ls, rs, sum, val, siz, pri;
        } t[N];
        int tot;
        mt19937 rnd;
        void clear() {
            for (int i = 0; i <= tot; i++) t[i] = node();
            tot = 0;
        }
        int newnode(int v) {
            t[++tot].pri = rnd();
            t[tot].sum = v;
            t[tot].val = v;
            t[tot].siz = 1;
            return tot;
        }
        void push_up(int p) { t[p].sum = min(INF, t[t[p].ls].sum + t[t[p].rs].sum + t[p].val), t[p].siz = t[t[p].ls].siz + t[t[p].rs].siz + 1; }
        void split_k(int p, int k, int &x, int &y) {
            if (!p) {
                x = y = 0;
                return;
            }
            if (t[t[p].ls].siz < k) {
                x = p;
                split_k(t[p].rs, k - t[t[p].ls].siz - 1, t[p].rs, y);
                push_up(x);
            } else {
                y = p;
                split_k(t[p].ls, k, x, t[p].ls);
                push_up(y);
            }
        }
        void split(int p, int v, int &x, int &y) {
            if (!p) {
                x = y = 0;
                return;
            }
            if (t[p].val <= v) {
                x = p;
                split(t[p].rs, v, t[p].rs, y);
                push_up(x);
            } else {
                y = p;
                split(t[p].ls, v, x, t[p].ls);
                push_up(y);
            }
        }
        int merge(int x, int y) {
            if (!x || !y) return x + y;
            if (t[x].pri < t[y].pri) {
                t[x].rs = merge(t[x].rs, y);
                push_up(x);
                return x;
            } else {
                t[y].ls = merge(x, t[y].ls);
                push_up(y);
                return y;
            }
        }
        void insert(int &p, int v) {
            int x, y, o = newnode(v);
            split(p, v, x, y);
            p = merge(merge(x, o), y);
        }
        void erase(int &p, int v) {
            int x, y, o;
            split(p, v, x, y);
            split(x, v - 1, x, o);
            o = merge(t[o].ls, t[o].rs);
            p = merge(merge(x, o), y);
        }
        int kth_sum(int p, int s) {
            if (!p) return 0;
            if (t[t[p].ls].sum <= s && t[t[p].ls].sum + t[p].val > s) return t[t[p].ls].siz;
            if (t[t[p].ls].sum > s) return kth_sum(t[p].ls, s);
            else return t[t[p].ls].siz + 1 + kth_sum(t[p].rs, s - t[t[p].ls].sum - t[p].val);
        }
    }  // namespace FhqTreap
    int rt;
    struct item {
        int a, b;
    } t[N];
    int calc(int n, int w, int a[], int b[]) {
        FhqTreap::clear(), rt = 0;
        for (int i = 1; i <= n; i++) t[i].a = a[i], t[i].b = b[i];
        sort(t + 1, t + n + 1, [](const item &a, const item &b) { return a.b < b.b; });
        for (int i = 1; i <= n; i++) FhqTreap::insert(rt, t[i].a);
        int sum = 0, ans = 0;
        for (int i = 0; i <= n; i++) {
            if (i) {
                FhqTreap::erase(rt, t[i].a);
                FhqTreap::insert(rt, t[i].b - t[i].a);
                sum += t[i].a;
            }
            if (sum > w) break;
            int x = FhqTreap::kth_sum(rt, w - sum);
            ans = max(ans, i + x);
        }
        return ans;
    }
}  // namespace Cardboard
vector<pair<int, int>> G[N];
int d[2][N];
void dfs(int u, int fa, bool s) {
    for (auto [v, w] : G[u]) {
        if (v == fa) continue;
        d[s][v] = d[s][u] + w;
        dfs(v, u, s);
    }
}
vector<int> dfv, pat;
bool onp[N];
void dfs_path(int u, int fa, int t) {
    dfv.push_back(u);
    if (u == t) pat = dfv;
    for (auto [v, w] : G[u]) {
        if (v == fa) continue;
        dfs_path(v, u, t);
    }
    dfv.pop_back();
}
int aa[N], bb[N];
signed max_score(signed n, signed x, signed y, int k, std::vector<signed> U, std::vector<signed> V, std::vector<signed> W) {
    ++x, ++y;
    for (int i = 1; i <= n; i++) G[i].clear(), onp[i] = 0;
    for (int i = 0, u, v, w; i < n - 1; i++) {
        u = U[i] + 1, v = V[i] + 1, w = W[i];
        G[u].emplace_back(v, w), G[v].emplace_back(u, w);
    }
    d[0][x] = d[1][y] = 0;
    dfs(x, 0, 0), dfs(y, 0, 1);
    dfv.clear(), pat.clear(), dfs_path(x, 0, y);
    for (auto u : pat) onp[u] = 1;
    int ans = 0;
    {
        vector<int> vec;
        for (int i = 1; i <= n; i++) vec.push_back(d[0][i]), vec.push_back(d[1][i]);
        sort(vec.begin(), vec.end());
        int sum = 0;
        for (auto v : vec) {
            if ((sum += v) <= k) ++ans;
            else break;
        }
    }
    {
        int sum = 0;
        for (int i = 1; i <= n; i++) {
            if (onp[i]) sum += min(d[0][i], d[1][i]), aa[i] = max(d[0][i], d[1][i]) - min(d[0][i], d[1][i]), bb[i] = INF;
            else aa[i] = min(d[0][i], d[1][i]), bb[i] = max(d[0][i], d[1][i]);
        }
        if (sum <= k) ans = max(ans, (int)pat.size() + Cardboard::calc(n, k - sum, aa, bb));
    }
    return ans;
}

```

---


# [IOI 2023] 超车

## 题目背景

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。

本题仅支持 C++ 语言提交。但请勿使用 C++14 (GCC 9)

## 题目描述

从布达佩斯机场到 Forrás 酒店有一条单向单车道的公路，公路的长度为 $L$ 公里。

IOI 2023 活动期间，有 $N+1$ 辆巴士在这条公路上行驶。巴士从 $0$ 到 $N$ 依次编号。巴士 $i$（$0 \le i \lt N$）计划在活动的第 $T[i]$ 秒从机场出发，行驶一公里用时 $W[i]$ 秒。巴士 $N$ 是备用巴士，行驶一公里用时 $X$ 秒。它从机场出发的时间 $Y$ 尚未确定。

巴士在这条公路上行驶时一般不允许超车，但允许在一些被称为**调度站**的地方进行超车。公路上一共有 $M$ 个调度站（$M \gt 1$），从 $0$ 到 $M - 1$ 依次编号，位于公路的不同位置。调度站 $j$（$0 \le j \lt M$）的位置在机场出发后沿公路的 $S[j]$ 公里处。调度站按照从机场开始的距离递增排列，也就是对于每个 $0 \le j \le M - 2$，有 $S[j] \lt S[j+1]$。首个调度站设在机场，最后一个设在酒店。也就是说，$S[0] = 0$，$S[M-1] = L$。

每辆巴士都以指定的最快速度行驶，除非它遇到前面有比它慢的巴士。在这种情况下，后面的快车会被前面的慢车压着，被迫以慢车的速度行驶。这种情况会持续到两车到达下一个调度站。在那里，快车会完成对慢车的超越。

形式化地说，对于满足 $0 \le i \le N$ 且 $0 \le j \lt M$ 的每组 $i$ 和 $j$，巴士 $i$ **到达**调度站 $j$ 的时间 $t_{i,j}$（以秒为单位）定义如下：对于每个 $0 \le i \lt N$，有 $t_{i,0} = T[i]$。另有 $t_{N,0} = Y$。对于满足 $0 \lt j \lt M$ 的每个 $j$：

* 定义巴士 $i$ 到达调度站 $j$ 的**期望到达时间** $e_{i,j}$（以秒为单位）为巴士 $i$ 到达调度站 $j-1$ 之后以全速行驶到达调度站 $j$ 的时间。也就是说，
  - 对于每个 $0 \le i \lt N$，有 $e_{i,j} = t_{i,j-1} + W[i] \cdot (S[j]-S[j-1])$；
  - 另有 $e_{N,j} = t_{N,j-1} + X \cdot (S[j]-S[j-1])$。
* 巴士 $i$ 到达调度站 $j$ 的时间，是巴士 $i$ 到达调度站 $j$ 的期望到达时间，以及其他比巴士 $i$ 早到调度站 $j-1$ 的巴士到达调度站 $j$ 的期望到达时间中的**最大值**。形式化地说，$t_{i,j}$ 是 $e_{i,j}$ 和所有满足 $0 \le k \le N$ 且 $t_{k,j-1} \lt t_{i,j-1}$ 的 $e_{k,j}$ 中的最大值。

IOI 组委会想要调度备用巴士（巴士 $N$）。你的任务是回答组委会的 $Q$ 个问题，问题的形式如下：给定备用巴士从机场出发的时间 $Y$（以秒为单位），它将于何时到达酒店？

## 说明/提示

**【实现细节】**

你的任务是实现以下函数：

```
void init(int L, int N, int64[] T, int[] W, int X, int M, int[] S)
```

* $L$：公路的长度
* $N$：常规（非备用）巴士的数量
* $T$：长度为 $N$ 的数组，描述常规巴士计划从机场出发的时间。
* $W$：长度为 $N$ 的数组，描述常规巴士的最大速度。
* $X$：备用巴士行驶一公里所需的时间
* $M$：调度站的数量
* $S$：长度为 $M$ 的数组，描述从机场到调度站的距离。
* 对于每个测试用例，这个函数都恰好调用一次，发生在对任何 `arrival_time` 的调用之前。

```
int64 arrival_time(int64 Y)
```

* $Y$：备用巴士（巴士 $N$）计划从机场出发的时间
* 这个函数应该返回备用巴士到达酒店的时间。
* 这个函数恰好调用 $Q$ 次。

---

**【例子】**

考虑以下调用序列：

```
init(6, 4, [20, 10, 40, 0], [5, 20, 20, 30], 10, 4, [0, 1, 3, 6])
```

忽略巴士 $4$（它还没有确定出发时间），下表列出了巴士到达每个调度站的期望时间和实际时间：

| $i$ | | $t_{i,0}$ | | $e_{i,1}$ | $t_{i,1}$ | | $e_{i,2}$ | $t_{i,2}$ | | $e_{i,3}$ | $t_{i,3}$ |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| $0$ | | $20$ | | $25$ | $30$ | | $40$ | $40$ | | $55$ | $55$ |
| $1$ | | $10$ | | $30$ | $30$ | | $70$ | $70$ | | $130$ | $130$ |
| $2$ | | $40$ | | $60$ | $60$ | | $100$ | $100$ | | $160$ | $180$ |
| $3$ | | $0$ | | $30$ | $30$ | | $90$ | $90$ | | $180$ | $180$ |

巴士到达调度站 $0$ 的时间就是它计划从机场出发的时间。也就是说，对于 $0 \le i \le 3$，$t_{i,0} = T[i]$。

到达调度站 $1$ 的期望时间和实际时间计算如下：

* 调度站 $1$ 的期望到达时间：
  - 巴士 $0$：$e_{0,1} = t_{0,0} + W[0] \cdot (S[1]-S[0]) = 20 + 5 \cdot 1 = 25$。
  - 巴士 $1$：$e_{1,1} = t_{1,0} + W[1] \cdot (S[1]-S[0]) = 10 + 20 \cdot 1 = 30$。
  - 巴士 $2$：$e_{2,1} = t_{2,0} + W[2] \cdot (S[1]-S[0]) = 40 + 20 \cdot 1 = 60$。
  - 巴士 $3$：$e_{3,1} = t_{3,0} + W[3] \cdot (S[1]-S[0]) = 0 + 30 \cdot 1 = 30$。
* 调度站 $1$ 的到达时间：
  - 巴士 $1$ 和 $3$ 早于巴士 $0$ 到达调度站 $0$，所以 $t_{0,1} = \max([e_{0,1},e_{1,1},e_{3,1}]) = 30$。
  - 巴士 $3$ 早于巴士 $1$ 到达调度站 $0$，所以 $t_{1,1} = \max([e_{1,1},e_{3,1}]) = 30$。
  - 巴士 $0$、巴士 $1$ 和巴士 $3$ 早于巴士 $2$ 到达调度站 $0$，所以 $t_{2,1} = \max([e_{0,1},e_{1,1},e_{2,1},e_{3,1}]) = 60$。
  - 没有比巴士 $3$ 更早到达调度站 $0$ 的巴士，所以 $t_{3,1} = \max([e_{3,1}]) = 30$。

```
arrival_time(0)
```

巴士 $4$ 行驶一公里需要 $10$ 秒，现在计划在第 $0$ 秒从机场出发。
这种情况下，下表列出每辆巴士的到达时间。
常规巴士期望和实际到达时间的唯一变动用下划线标注。

| $i$ | | $t_{i,0}$ | | $e_{i,1}$ | $t_{i,1}$ | | $e_{i,2}$ | $t_{i,2}$ | | $e_{i,3}$ | $t_{i,3}$ |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-: |
| $0$ | | $20$ | | $25$ | $30$ | | $40$ | $40$ | | $55$ | $\underline{60}$ |
| $1$ | | $10$ | | $30$ | $30$ | | $70$ | $70$ | | $130$ | $130$ |
| $2$ | | $40$ | | $60$ | $60$ | | $100$ | $100$ | | $160$ | $180$ |
| $3$ | | $0$ | | $30$ | $30$ | | $90$ | $90$ | | $180$ | $180$ |
| $4$ | | $0$ | | $10$ | $10$ | | $30$ | $30$ | | $60$ | $60$ |

由此可知巴士 $4$ 在第 $60$ 秒到达酒店。
因此，函数应该返回 $60$。

```
arrival_time(50)
```

巴士 $4$ 现在计划在第 $50$ 秒从机场出发。
这种情况下，与初始表格相比，常规巴士的到达时间没有变化。
下表列出了到达时间。

| $i$ | | $t_{i,0}$ | | $e_{i,1}$ | $t_{i,1}$ | | $e_{i,2}$ | $t_{i,2}$ | | $e_{i,3}$ | $t_{i,3}$ |
|:--:|:-:|:---------:|:-:|:---------:|:---------:|:-:|:---------:|:---------:|:-:|:---------:|:---------:|
| $0$ | | $20$      | | $25$      | $30$      | | $40$      | $40$      | | $55$      | $55$ |
| $1$ | | $10$      | | $30$      | $30$      | | $70$      | $70$      | | $130$     | $130$ |
| $2$ | | $40$      | | $60$      | $60$      | | $100$     | $100$     | | $160$     | $180$ |
| $3$ | | $0$       | | $30$      | $30$      | | $90$      | $90$      | | $180$     | $180$ |
| $4$ | | $50$      | | $60$      | $60$      | | $80$      | $90$      | | $120$     | $130$ |

巴士 $4$ 和较慢的巴士 $2$ 同时到达调度站 $1$，然后巴士 $4$ 超过了巴士 $2$。
接着，巴士 $4$ 在调度站 $1$ 和 $2$ 之间行驶时被巴士 $3$ 压着，导致它到达调度站 $2$ 的时间是第 $90$ 秒，而不是第 $80$ 秒。
在过了调度站 $2$ 之后，巴士 $4$ 被巴士 $1$ 压着，直到它们到达酒店。
巴士 $4$ 在第 $130$ 秒到达酒店。
因此，函数应该返回 $130$。

将每辆巴士从机场出发到不同距离的时间画成折线图。
图中 x 轴表示从机场出发的距离（以公里为单位），y 轴表示时间（以秒为单位）。
竖的虚线标注了调度站的位置。
不同颜色的实线（标注了巴士的编号）表示四辆常规巴士。
黑色的点线表示备用巴士。

| `arrival_time(0)` | `arrival_time(50)` |
|:-:|:-:|
| ![](https://cdn.luogu.com.cn/upload/image_hosting/rksq53n9.png) | ![](https://cdn.luogu.com.cn/upload/image_hosting/ua96w1x2.png) |

---

**【约束条件】**

* $1 \le L \le 10^9$
* $1 \le N \le 1\,000$
* $0 \le T[i] \le 10^{18}$（对于满足 $0 \le i \lt N$ 的每个 $i$）
* $1 \le W[i] \le 10^9$（对于满足 $0 \le i \lt N$ 的每个 $i$）
* $1 \le X \le 10^9$
* $2 \le M \le 1\,000$
* $0 = S[0] \lt S[1] \lt \cdots \lt S[M-1] = L$
* $1 \le Q \le 10^6$
* $0 \le Y \le  10^{18}$

---

**【子任务】**

1. （9 分）$N = 1, Q \le 1\,000$
1. （10 分）$M = 2, Q \le 1\,000$
1. （20 分）$N, M, Q \le 100$
1. （26 分）$Q \le 5\,000$
1. （35 分）没有额外的约束条件。

## 样例 #1

### 输入

```
6 4 10 4 2
20 10 40 0
5 20 20 30
0 1 3 6
0
50
```

### 输出

```
60
130
```

# 题解

## 作者：Alex_Wei (赞：13)

### [P9604 [IOI2023] 超车](https://www.luogu.com.cn/problem/P9604)

如果 $x$ 被 $y$ 堵住了，那么 $x$ 的速度一定大于 $y$：如果 $W_x > W_y$，则存在 $W_z > W_x$ 使得 $y$ 被 $z$ 堵住了，否则 $y$ 不会把 $x$ 堵住。简单地说，如果车辆 $i$ 从 $j - 1$ 到 $j$ 的过程中并非全速行驶（$t_{i, j} > e_{i, j}$），那么存在 $k$ 使得 $k$ 到达 $j - 1$ 的时间严格早于 $i$（$t_{k, j - 1} < t_{i, j - 1}$），且 $k$ 到达 $j$ 的时间严格晚于 $i$（$e_{k, j} > e_{i, j}$），这说明 $k$ 的速度小于 $i$（$W_k > W_i$）。

这说明，在考虑 $i$ 到达每个调度站的时间的时候，**速度不小于 $i$ 的车辆不产生影响**：如果 $i$ 被堵住，那么 $i$ 所在的 “堵车集团” 一定是被它们当中速度最慢的车堵住的，可以认为 $i$ 被这辆车堵住了，而如果这辆车的速度和 $i$ 相同，那么可以认为 $i$ 是在正常行驶，没有被堵住。因为我们只关心 $N$ 到达调度站的时间，所以先忽略掉所有速度不小于 $N$ 的车，即 $W_i \leq X$ 的所有 $i$。以下设 $W_i > X$。

我们尝试对所有 $0\leq i < N$ 和 $0 \leq j < M$ 求出 $t_{i, j}$。首先有 $t_{i, 0} = T_i$。在 $t_{*, j - 1}\to t_{*, j}$ 时，直接按照题目给出的方式暴力转移的时间复杂度是 $\mathcal{O}(N ^ 2)$，无法接受。按照 $t_{i, j - 1}$ 从小到大枚举 $i$，同时维护所有 $t_{k, j - 1} < t_{i, j - 1}$ 的 $e_{k, j}$ 的最大值即可做到 $\mathcal{O}(N\log N)$。如果 $t_{i, j - 1}$ 相同的 $i$ 按照速度从快到慢枚举，则有先枚举的 $i$ 先到达 $j$ 的性质：后到达 $j - 1$ 的车不会比先到达 $j - 1$ 的车早到达 $j$，而同一时刻到达 $j - 1$ 的车，排在前面的速度更快，更早到达 $j$。在这种枚举顺序下，我们可以认为 $i$ 到达 $j$ 的时间受到的限制是比它先枚举的 $k$ 到达 $j$ 的 **实际时间** $t_{k, j}$，而非 **期望时间** $e_{k, j}$（因为限制到 $i$ 的 $k$ 一定满足实际时间等于期望时间），也就是令 $t_{i, j} \gets t_{i, j - 1} + W_i(S_j - S_{j - 1})$ 之后，对 $t_{*, j}$ 做 "前缀" $\max$。

$\mathcal{O}(NM)$ 算出 $t_{i, j}$ 之后，我们有 $\mathcal{O}(M\log N)$ 回答单次询问的做法：二分求出 $t_{N, j - 1}$ 在 $t_{*, j - 1}$ 中的位置，可以直接算出 $t_{N, j}$。而 $N$ 的速度大于其它车辆，所以 $N$ 不会对 $t_{i, j}$ 产生任何影响。可以获得 $65$ 分。

为了做到单组询问优于 $\mathcal{O}(M)$，我们尝试预处理所有可能的询问的答案。如果不这样做，对每组询问直接模拟，则无论如何都需要至少 $\mathcal{O}(M)$ 的时间复杂度。

考虑每个 $t_{i, j}$ 的限制：如果 $t_{N, j - 1} > t_{i, j - 1}$，那么 $t_{N, j}$ 对 $t_{i, j}$ 取 $\max$。这样问题就变成了：查询第一个权值大于 $v$ 的位置，全局加法，区间取 $\max$。注意在 $t_{*, j - 1}\to t_{*, j}$ 的过程中，区间 $\max$ 要在查询完所有第一个权值大于某个值的位置之后才能进行。全局加法可以直接打标记，剩下部分可以使用动态开点线段树维护，下标表示出发时间，值表示到达当前调度站的时间。

这个做法不仅难写，而且值域大空间紧。一个常用技巧是：**根据单调性，将区间取 $\max$ 变成区间赋值**。我们算出赋值的具体情况。不妨设 $i$ 是按照 $0\sim N - 1$ 的顺序枚举的（根据分析，对 $0 < i < N$ 有 $t_{i - 1, j - 1} \leq t_{i, j - 1}$ 且 $t_{i - 1, j} \leq t_{i, j}$），那么对于一段极长的 $t_{i, j}$ 相同的 $i$ 连续段 $[l, r]$：

- 它相当于将 **值** 区间 $(t_{l, j - 1}, +\infty)$ 对 $t_{l, j}$ 取 $\max$。
- 因为若 $t_{N, j - 1} > t_{l, j} - X(S_j - S_{j - 1})$，那么 $t_{N, j}$ 一定大于 $t_{l, j}$，所以 **值** 区间缩小为  $(t_{l, j - 1}, t_{l, j} - X(S_j - S_{j - 1})]$。这一步是为了防止原来较大的值被赋小了。
- 因为若 $r < N - 1$ 且 $t_{N, j - 1} > t_{r + 1, j - 1}$，那么 $t_{N, j}$ 会和更大的值取 $\max$，所以 **值** 区间缩小为 $(t_{l, j - 1}, \min(t_{l, j} - X(S_j - S_{j - 1}), t_{r + 1, j - 1})]$。注意当 $r = N - 1$ 时忽略 $\min$ 的第二项。这一步是为了防止不同的取 $\max$ 操作之间变成赋值之后互相干扰。

最终得到的所有操作的值区间两两无交，可以用维护值区间以及对应下标区间的 set 维护（ODT）。查询时直接二分即可。

时间复杂度 $\mathcal{O}((NM + Q)\log (NM))$。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

constexpr int MAXN = 1e3 + 5;
constexpr int MAXM = 1e3 + 5;
constexpr ll inf = 2e18;

ll delt, f[MAXN][MAXM];
struct oper {ll l, r, v;};

struct itv {
  ll l, r, _l, _r;
  bool operator < (const itv &z) const {
    if(l != z.l) return l < z.l;
    if(r != z.r) return r < z.r;
    return _l < z._l;
  }
};
set<itv> s;
vector<itv> res;

void init(int L, int N, vector<ll> T, vector<int> W, int X, int M, vector<int> S) {
  for(int i = 0; i < N; i++) {
    if(W[i] <= X) {
      W.erase(W.begin() + i);
      T.erase(T.begin() + i);
      N--, i--;
    }
  }
  for(int i = 0; i < N; i++) f[i][0] = T[i];
  s.insert({-inf, inf, -inf, inf});
  for(int t = 1; t < M; t++) {
    vector<int> id(N);
    for(int i = 0; i < N; i++) id[i] = i;
    sort(id.begin(), id.end(), [&](int x, int y) {
      if(f[x][t - 1] != f[y][t - 1]) return f[x][t - 1] < f[y][t - 1];
      return W[x] < W[y];
    });
    ll d = S[t] - S[t - 1];
    for(int i = 0; i < N; i++) {
      f[id[i]][t] = f[id[i]][t - 1] + W[id[i]] * d;
      if(i) f[id[i]][t] = max(f[id[i]][t], f[id[i - 1]][t]);
    }
    auto split = [&](ll p) {
      auto pt = --s.lower_bound({p + 1, -inf});
      if(pt->l == p || pt->r < p) return;
      s.insert({pt->l, p - 1, pt->l, p - 1});
      s.insert({p, pt->r, p, pt->r});
      s.erase(pt);
    };
    ll nxt = delt + X * d;
    vector<itv> add;
    for(int i = 0; i < N; ) {
      int j = i;
      while(j < N && f[id[j]][t] == f[id[i]][t]) j++;
      if(W[i] > X) {
        ll st = f[id[i]][t - 1] + 1 - delt;
        ll ed = min(f[id[i]][t] - X * d, j < N ? f[id[j]][t - 1] : inf) - delt;
        ll p = f[id[i]][t] - nxt;
        ll L = -inf, R = -1;
        split(st), split(ed + 1);
        while(1) {
          auto pt = s.lower_bound({st, -inf});
          if(pt == s.end() || pt->l > ed) break;
          if(L == -inf) L = pt->_l;
          R = pt->_r;
          s.erase(pt);
        }
        if(L != -inf) add.push_back({p, p, L, R});
      }
      i = j;
    }
    for(itv it : add) s.insert(it);
    delt = nxt;
  }
  for(itv it : s) res.push_back(it);
}

ll arrival_time(ll Y) {
  int l = 0, r = res.size() - 1;
  while(l < r) {
    int m = l + r + 2 >> 1;
    if(res[m]._l <= Y) l = m;
    else r = m - 1;
  }
  if(res[l].l < res[l].r) return Y + delt;
  return res[l].l + delt;
}
```


---

## 作者：Leasier (赞：8)

**注意此题中的速度单位为 $\operatorname{s / km}$。**

首先可以模拟题意 $O(nm \log n)$ 预处理出不考虑备用车的 $t_{i, j}$。

注意到我们事实上不关心一辆车被备用车拖住——因为此时这辆车不会在拖慢影响备用车。于是我们只关心速度小于 $x \operatorname{s / km}$ 但发车时间 $< y$ 的车。

考虑一个暴力：

- 设到达车站 $i$ 时备用车用时为 $j$。
- 所有可能可以在车站 $i + 1$ 拖慢备用车的车满足此时其速度小于 $x \operatorname{s / km}$ 但时间 $< j$ 的车。
- 设这些满足条件的车有 $cnt$ 个，若它会被其中某辆车拖住，则 $j + x(s_{i + 1} - s_i) \geq t'_{i + 1, cnt}$，其中 $t'_{i, j}$ 表示到达车站 $i$ 时满足条件的车 $p$ 中 $t_{i, p}$ 的第 $j$ 小值。
- 于是我们递归下去即可。时间复杂度为 $O(nm \log n + qm)$。

考虑来优化这个过程。

注意到“备用车最早在车站 $i'$ 被拖慢”中的 $i'$ 是可以二分的，则我们对其二分找出第一个 $i'$，则至多递归一次后当前的 $j$ 就变成了某个 $t_{i, p}$。

记忆化搜索即可。时间复杂度为 $O(nm \log n + q(\log n + \log m))$。

代码：
```cpp
#include <algorithm>
#include <vector>
#include "overtaking.h"

using namespace std;

typedef long long ll;

using namespace std;

int m, x, cur;
int w[1007], s[1007], p[1007][1007], cnt[1007];
ll t[1007][1007], max_val[1007][1007], e[1007][1007], save[1007][1007];
bool vis[1007][1007];

bool cmp(const int a, const int b){
	return t[cur][a] < t[cur][b];
}

inline void sort(int n, int k, int x){
	cur = k;
	for (register int i = 1; i <= n; i++){
		p[k][i] = i;
	}
	sort(p[k] + 1, p[k] + n + 1, cmp);
	for (register int i = 1; i <= n; i++){
		if (w[p[k][i]] > x) max_val[k][++cnt[k]] = t[k][p[k][i]];
	}
}

void init(int L, int N, vector<ll> T, vector<int> W, int X, int M, vector<int> S){
	int n = N;
	m = M;
	x = X;
	for (register int i = 1; i <= n; i++){
		w[i] = W[i - 1];
	}
	for (register int i = 1; i <= m; i++){
		s[i] = S[i - 1];
	}
	for (register int i = 1; i <= n; i++){
		t[1][i] = T[i - 1];
	}
	for (register int i = 2; i <= m; i++){
		int delta = s[i] - s[i - 1];
		ll pre = 0;
		sort(n, i - 1, x);
		for (register int j = 1; j <= n; j++){
			e[i][j] = t[i - 1][j] + (ll)delta * w[j];
		}
		for (register int j = 1; j <= n; ){
			int pos = j;
			while (pos < n && t[i - 1][p[i - 1][j]] == t[i - 1][p[i - 1][pos + 1]]) pos++;
			for (register int k = j; k <= pos; k++){
				t[i][p[i - 1][k]] = max(e[i][p[i - 1][k]], pre);
			}
			for (register int k = j; k <= pos; k++){
				pre = max(pre, e[i][p[i - 1][k]]);
			}
			j = pos + 1;
		}
	}
	sort(n, m, x);
}

inline ll query(int a, ll b){
	if (a == m) return b;
	int smaller = lower_bound(max_val[a] + 1, max_val[a] + cnt[a] + 1, b) - max_val[a];
	if (max_val[a][smaller] == b && vis[a][smaller]) return save[a][smaller];
	int l = a + 1, r = m, pos = -1;
	ll ans;
	while (l <= r){
		int mid = (l + r) >> 1;
		if (max_val[mid][smaller - 1] >= b + (ll)x * (s[mid] - s[a])){
			r = mid - 1;
			pos = mid;
		} else {
			l = mid + 1;
		}
	}
	if (pos == -1){
		ans = b + (ll)x * (s[m] - s[a]);
	} else {
		ans = query(pos, max_val[pos][smaller - 1]);
	}
	if (max_val[a][smaller] == b){
		vis[a][smaller] = true;
		save[a][smaller] = ans;
	}
	return ans;
}

ll arrival_time(ll Y){
	return query(1, Y);
}
```

---

## 作者：Mirasycle (赞：4)

首先肯定是预处理出每一辆车在每个站点的到达时间，直接按照题目里面的描述模拟一遍即可。

把每个车在每个站点的到达时间看成一个状态，注意到备用车第一次被前方慢车拦截后的状态只有 $O(nm)$ 种，可以直接 dp 预处理每种状态的完结时间。

现在问题就来到了我们如何快速找到备用车第一次被拦截所对应的状态。

先去除比备用车快的车，这些车显然是无影响的。然后直接用到达时间的排名来刻画这个过程。注意到由于去掉了快车，所以备用车是最快的，它的时间排名只有可能上升不可能下降。一旦上升就意味着需要遇到阻拦。我们直接对于这个过程进行二分，就可以轻松找到分界点。

二分之后可以 $O(1)$ 进行判定，不需要再二分出排名，因为我们可以预处理出 $rk_{i,j}$ 表达第 $i$ 个站点排名为 $j$ 的信息，由于备用车排名不变，只需要和固定第二维度的 $rk$ 数组比对一下就行了。

时间复杂度 $O(mn\log n+Q\log n)$。


```cpp
//#include "overtaking.h"
#include<bits/stdc++.h>
#define pb emplace_back
#define fi first
#define se second
#define mp make_pair
using namespace std;
typedef long long ll;
typedef vector<int> vi;
const int maxn=1e3+10;
void cmax(int &x,int y){ x=x>y?x:y; }
void cmin(int &x,int y){ x=x<y?x:y; }
ll dp[maxn][maxn],t[maxn][maxn],e[maxn][maxn],v0;
ll tim[maxn][maxn],X0;
int s[maxn],v[maxn],p[maxn][maxn],n,m;
bool cmp(int x,int y){ return t[x][0]<t[y][0]; }
bool cmp2(int x,int y){ return (t[X0][x]<t[X0][y])||(t[X0][x]==t[X0][y]&&v[x]<v[y]); }
pair<int,int> find(int x,int y,ll Y){
	int l=x,r=m;
	while(l<r){
		int mid=(l+r+1)>>1;
		if(tim[mid][y]<Y+1ll*(s[mid]-s[x])*v0) l=mid;
		else r=mid-1;
	}
	if(l==m) return mp(-1,-1);
	return mp(l+1,y);
}
void solve(int x){
	for(int i=1;i<=n;i++) p[x][i]=i;
	X0=x; sort(p[x]+1,p[x]+1+n,cmp2);
	for(int i=1;i<=n;i++) tim[x][i]=t[x][p[x][i]];
}
void init(int L,int N,vector<ll> T,vi W,int X,int M,vi S){
	v0=X; n=N; m=M-1; int tot=0;
	for(int i=1;i<=n;i++)
		if(W[i-1]>v0) t[0][++tot]=T[i-1],v[tot]=W[i-1];
	n=tot; solve(0);
	for(int i=0;i<=m;i++) s[i]=S[i];
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++)
			e[i][j]=t[i-1][j]+1ll*(s[i]-s[i-1])*v[j];
		ll mx=0;
		for(int j=1;j<=n;j++) t[i][p[i-1][j]]=max(mx,e[i][p[i-1][j]]),mx=max(mx,t[i][p[i-1][j]]);
		solve(i);
	}
	for(int i=1;i<=n;i++) dp[m][i]=tim[m][i];
	for(int i=m-1;i>=1;i--){
		for(int j=1;j<=n;j++){
			int k=lower_bound(tim[i]+1,tim[i]+1+n,tim[i][j])-tim[i]-1;
			if(!k){ dp[i][j]=tim[i][j]+1ll*(s[m]-s[i])*v0; continue; }
			pair<int,int> z=find(i,k,tim[i][j]);
			if(z.fi<0) dp[i][j]=tim[i][j]+1ll*(s[m]-s[i])*v0;
			else dp[i][j]=dp[z.fi][z.se];
		}
	}
	return ;
}
ll arrival_time(ll Y){
	int k=lower_bound(tim[0]+1,tim[0]+1+n,Y)-tim[0]-1;
	if(!k) return Y+1ll*s[m]*v0;
	pair<int,int> z=find(0,k,Y);
	if(z.fi<0) return Y+1ll*s[m]*v0;
	else return dp[z.fi][z.se];
}
```

---

## 作者：Petit_Souris (赞：1)

ez，IOI 23 的签到题。

首先不考虑备用车。那么显然直接写个 dp 就能求出 $f_{i, j}$ 表示第 $i$ 辆车走到第 $j$ 个超车站的时间。转移的时候相当于按照上一层的时间排序，并去一个前缀 $\max$。很容易做到 $\mathcal O(nm \log n)$。

现在加入备用车。有一个重要的性质就是，**我们不需要考虑备用车对普通车的速度影响**。证明可以考虑比如我们的备用车让某辆车变慢，那么下一层的时候，如果按照正常计算，瓶颈取到这辆被影响的车，那么我们可以直接把瓶颈当成备用车的时间计算，这是没有区别的。

于是容易 $\mathcal O(m \log n)$ 解决单组询问，每一层二分一下求前缀 $\max$ 就行了。

优化的方法也很简单。我们发现，每个超车站实际上等价于一个段数 $\le 2n$ 的分段一次函数：到达时间的 $n$ 段，每段里面关于 $Y$ 可能分成取 $Y+XL$ 和前缀 $\max$ 的两段。而 dp 的转移相当于函数复合。因此总共有 $\le 2nm$ 段。

如果我们能求出这个分段函数，每次查询就可以直接 $\mathcal O(\log n + \log m)$ 二分了。求出函数也是容易的：因为我们在有序的情况下容易 $\mathcal O(l_1 + l_2)$ 合并两个段数为 $l_1, l_2$ 的分段函数。因此可以做分治卷积优化合并，时间复杂度 $\mathcal O(nm\log n + q(\log n + \log m))$。

```cpp
#include <bits/stdc++.h>
#include "overtaking.h"
using ll = long long;
using ld = long double;
using ull = unsigned long long;
using namespace std;
template <class T>
using Ve = vector<T>;
#define pii pair<ll, ll>
#define rep(i, a, b) for(ll i = (a); i <= (b); ++i)
#define per(i, a, b) for(ll i = (a); i >= (b); --i)
#define pb push_back 
const ll INF = 2e18;
Ve<Ve<ll> > dp, pre, st;
Ve<int> S;
int X, N, M;
struct Data {
    ll l, r, k, b;
};
Ve<Data> F;
Ve<Data> Convolution(int l, int r) {
    Ve<Data> res;
    if(l == r) {
        int len = S[l] - S[l - 1];
        ll lst = 0;
        rep(j, -1, N - 1) {
            ll pl = lst;
            ll pr = ((j < N - 1) ? st[l][j + 1] : INF);
            if(pl > pr) continue;
            ll mx = 0;
            if(~j) {
                ll k = j;
                while(k < N - 1 && st[l][k + 1] == st[l][j]) ++k;
                mx = pre[l][k];
            }
            // x + X * len >= mx
            ll pos = mx - 1ll * X * len;
            if(pos <= pl) res.pb({pl, pr, 1, 1ll * X * len});
            else if(pos > pr) res.pb({pl, pr, 0, mx});
            else {
                res.pb({pl, pos - 1, 0, mx});
                res.pb({pos, pr, 1, 1ll * X * len});
            }
            lst = pr + 1;
        }
        return res;
    }
    int mid = (l + r) >> 1;
    Ve<Data> L = Convolution(l, mid), R = Convolution(mid + 1, r);
    for(auto [l, r, k, b] : L) {
        if(!k) {
            int ql = 0, qr = R.size() - 1, pos = 0;
            while(ql <= qr) {
                int mid = (ql + qr) >> 1;
                if(R[mid].r >= b) pos = mid, qr = mid - 1;
                else ql = mid + 1;
            }
            res.pb({l, r, 0ll, 1ll * R[pos].k * b + R[pos].b});
            continue;
        }
        ll lf = l + b, rg = r + b;
        int ql = 0, qr = R.size() - 1, pos = 0;
        while(ql <= qr) {
            int mid = (ql + qr) >> 1;
            if(R[mid].r >= lf) pos = mid, qr = mid - 1;
            else ql = mid + 1;
        }
        while(pos < R.size() && R[pos].l <= rg) {
            ll pl = R[pos].l - b, pr = R[pos].r - b;
            pl = max(pl, l), pr = min(pr, r);
            res.pb({pl, pr, R[pos].k, R[pos].b + 1ll * R[pos].k * b});
            ++pos;
        }
    }
    return res;
} 
void init(int L, int _N, Ve<ll> T, Ve<int> W, int _X, int _M, Ve<int> _S) {
    N = _N, M = _M, X = _X, S = _S;
    dp.resize(M), pre.resize(M), st.resize(M);
    for(auto &v : dp) v.resize(N);
    for(auto &v : pre) v.resize(N);
    for(auto &v : st) v.resize(N);
    rep(i, 0, N - 1) dp[0][i] = T[i];
    rep(i, 1, M - 1) {
        int len = S[i] - S[i - 1];
        Ve<int> id(N); iota(id.begin(), id.end(), 0);
        sort(id.begin(), id.end(), [&](int x, int y) {
            return dp[i - 1][x] < dp[i - 1][y];
        });
        rep(j, 0, N - 1) st[i][j] = dp[i - 1][id[j]], pre[i][j] = dp[i - 1][id[j]] + 1ll * len * W[id[j]];
        rep(j, 1, N - 1) pre[i][j] = max(pre[i][j], pre[i][j - 1]);
        int ptr = -1;
        rep(j, 0, N - 1) {
            int u = id[j];
            while(ptr < N - 1 && st[i][ptr + 1] < dp[i - 1][u]) ++ptr;
            if(~ptr) dp[i][u] = pre[i][ptr];
            dp[i][u] = max(dp[i][u], dp[i - 1][u] + 1ll * len * W[u]);
        }
    }
    F = Convolution(1, M - 1);
}
ll arrival_time(ll Y) {
    int ql = 0, qr = F.size() - 1, pos = 0;
    while(ql <= qr) {
        int mid = (ql + qr) >> 1;
        if(F[mid].r >= Y) pos = mid, qr = mid - 1;
        else ql = mid + 1;
    }
    return 1ll * F[pos].k * Y + F[pos].b;
}
```

---

## 作者：_lmh_ (赞：1)

首先 $N,M\le 1000$，所以可以在 $O(NM\log N)$ 的复杂度之内预处理出第 $j$ 辆车到第 $i$ 个关键点的时间 $t_{i,j}$。具体地，每次将它们按照抵达上一个关键点的时间排序，然后求一个前缀最大值即可。

然后考虑第 $N+1$ 辆车（称其为 $P$） 从 $Y$ 时刻出发的移动过程。如果它全称没有受到其他车辆的影响，那么答案就是 $Y+LX$；

否则，如果它在 $(S_{i-1},S_{i})$ 内被另一辆车 $x$ 拖慢，那么它到达关键点 $i$ 的时间一定为 $t_{i,x}$。可以令 $f_{i,j}$ 代表从 $(S_{i},t_{i,j})$ 的位置出发，到达终点的时间，这样只要找到了第一个 $(i,x)$，就可以直接求出结果。

计算 $f_{i,j}$ 时，需要考虑所有比 $j$ 先出发的车辆 $k$，只要在任意一个关键点 $l$ 的时候 $k$ 跑到了 $P$ 前面那么 $P$ 就会在不晚于 $S_l$ 的时刻第一次被拖慢。

同时，我们可以不考虑这些 $k$ 之间的影响——因为如果慢车拖慢了快车，那么快车就不需要考虑了。

所以可以用李超线段树维护，每次二分第一次被影响的位置。

询问时也可以类似地进行二分，时间复杂度 $O((NM+Q)\log N\log M)$。

如果在询问时预处理出前 $i$ 辆车在第 $j$ 个位置的最大值，可以优化到 $O(NM\log N\log M+Q\log M)$，常数足够小，轻松通过。

```cpp
#include"overtaking.h"
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define lson (u<<1)
#define rson (u<<1|1)
const ll N=1007;
ll n,m,k,v[N],t[N][N],id[N],pos[N],f[N][N],p[N],val[N<<2];
pair<ll,ll> mx[N][N];
void modify(int u,int l,int r,ll x){
	int mid=l+r>>1;
	if (v[x]*pos[mid]+p[x]>v[val[u]]*pos[mid]+p[val[u]]) swap(val[u],x);
	if (l==r) return;
	if (v[x]<v[val[u]]) modify(lson,l,mid,x);
	if (v[x]>v[val[u]]) modify(rson,mid+1,r,x);
}
pair<ll,ll> query(int u,int l,int r,int x){
	if (l==r) return make_pair(v[val[u]]*pos[x]+p[val[u]],val[u]);
	int mid=l+r>>1;
	if (x<=mid) return max(make_pair(v[val[u]]*pos[x]+p[val[u]],val[u]),query(lson,l,mid,x));
	return max(make_pair(v[val[u]]*pos[x]+p[val[u]],val[u]),query(rson,mid+1,r,x));
}
void init(int L,int N,vector<ll> T,vector<int> W,int X,int M,vector<int> S){
	n=N;m=M-1;k=X;
	for (int i=1;i<=n;++i){
		t[0][i]=T[i-1];
		v[i]=W[i-1];
		id[i]=i;
	}
	for (int i=1;i<=m;++i) pos[i]=S[i];
	for (int i=1;i<=m;++i){
		sort(id+1,id+1+n,[&](const ll& x,const ll& y){return t[i-1][x]==t[i-1][y]?v[x]<v[y]:t[i-1][x]<t[i-1][y];});
		for (int j=1;j<=n;++j){
			int x=id[j];
			t[i][x]=max(t[i][id[j-1]],t[i-1][x]+v[x]*(pos[i]-pos[i-1]));
		}
	}
	for (int i=1;i<=n;++i) f[m][i]=t[m][i];
	for (int i=m-1;i;--i){
		for (int j=1;j<=n;++j) p[j]=t[i][j]-pos[i]*v[j];
		sort(id+1,id+1+n,[&](const ll& x,const ll& y){return t[i][x]==t[i][y]?v[x]<v[y]:t[i][x]<t[i][y];});
		memset(val,0,sizeof(val));
		for (int j=1;j<=n;++j){
			int x=id[j];
			if (j==1||t[i][x]!=t[i][id[j-1]]){
				int l=i+1,r=m,p=m+1;
				while(l<=r){
					int mid=l+r>>1;
					if (query(1,i+1,m,mid).first>=t[i][x]+k*(pos[mid]-pos[i])) p=mid,r=mid-1;
					else l=mid+1;
				}
				if (p<=m) f[i][x]=f[p][query(1,i+1,m,p).second];
				else f[i][x]=t[i][x]+k*(pos[m]-pos[i]);
			}
			else f[i][x]=f[i][id[j-1]];
			modify(1,i+1,m,x);
		}
	}
	for (int i=1;i<=n;++i) p[i]=t[0][i];
	sort(id+1,id+1+n,[&](const ll& x,const ll& y){return t[0][x]==t[0][y]?v[x]<v[y]:t[0][x]<t[0][y];});
//	for (int i=1;i<=n;++i) cout<<id[i]<<' ';cout<<endl;
	memset(val,0,sizeof(val));
	for (int i=1;i<=n;++i){
		modify(1,1,m,id[i]);
		for (int j=1;j<=m;++j) mx[i][j]=query(1,1,m,j);
	}
    return;
}
ll arrival_time(ll Y){
	int l=1,r=n,x=0;
	while(l<=r){
		int mid=l+r>>1;
		if (t[0][id[mid]]<Y) x=mid,l=mid+1;
		else r=mid-1;
	}
	if (x==0) return Y+pos[m]*k;
	l=1;r=m;int p=m+1;
	while(l<=r){
		int mid=l+r>>1;
		if (mx[x][mid].first>=Y+pos[mid]*k) p=mid,r=mid-1;
		else l=mid+1;
	}
//	cout<<x<<' '<<p<<' '<<mx[x][p].second<<endl;
	if (p==m+1) return Y+pos[m]*k;
	return f[p][mx[x][p].second];
}
```

---

## 作者：Purslane (赞：1)

# Solution

简单题，但是我花了将近一个半小时才想+写+调完，怎么回事呢。

------

考虑这样一个过程——按照速度从小往大加入车。后加入的车不会对新加入的车产生影响，我们只需要考虑后加入的车被前面的车“堵住”的情况。所以这道题我们只需要保留比 $N$ 车严格慢的车即可。

有一个小 trick，是我在 24 冬令营的时候听到的（我把整道题的做法全忘了，但是记得这个 trick，怎么回事呢）——把所有车每公里用的时间减去 $X$，最后一起加上 $X \times len$，这样方便后面维护。

首先可以 $O(n^2 \log n)$ 处理出这些车的所有信息，即他们到达每个调度站的时间。

容易发现，询问中本质不同的初始时刻为 $O(nm)$ 的，即所有车可能的到达某一个调度站的时间加一。因此我们得到了一个 $O(nm^2 \log n)$ 的做法（对于每个特殊点直接暴力询问即可）。

考虑优化。发现如果考虑车“在 $t$ 进入调度站 $i$，$f(t)$ 到达调度站 $j$”，那么 $f_{i,j}(t)$ 应该是一个有 $O((j-i)n)$ 段的分段函数。相当于对 $f_{i,i}(t)$ 做一个复合。

而分段函数可以 $O(|A|+|B|)$ 的进行复合。我们刚才的暴力相当于依次符合，显然会比较慢。

考虑使用分治，符合 $[l,r]$ 的时候先复合 $[l,mid]$ 和 $[mid+1,r]$，再 $O((r-l+1) \times n)$ 合并即可。

询问的时候二分一下即可。

总体复杂度 $O(nm \log n)$，可以通过本题。

```cpp
#include<bits/stdc++.h>
#include"overtaking.h"
#define ll long long 
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1000+10;
int len,n,k,m,XX,w[MAXN],pos[MAXN];
ll t[MAXN][MAXN];
struct INFO {ll t,k,b;};
vector<INFO> ans;
vector<INFO> merge(vector<INFO> A,vector<INFO> B) {
	vector<ll> t;
	int pos1=0,pos2=0;
	while(pos1<A.size()&&pos2<B.size()) {
		if(A[pos1].t==B[pos2].t) t.push_back(A[pos1].t),pos1++,pos2++;
		else if(A[pos1].t<B[pos2].t) t.push_back(A[pos1].t),pos1++;
		else t.push_back(B[pos2].t),pos2++;
	}
	while(pos1<A.size()) t.push_back(A[pos1].t),pos1++;
	while(pos2<B.size()) t.push_back(B[pos2].t),pos2++;
	pos1=0,pos2=0;
	vector<INFO> ans;
	for(auto T:t) {
		while(pos1+1<A.size()&&A[pos1+1].t<=T) pos1++;
		ll mzx=T*A[pos1].k+A[pos1].b;
		while(pos2+1<B.size()&&B[pos2+1].t<=mzx) pos2++;
		ll nk=A[pos1].k*B[pos2].k;
		ll nb=A[pos1].b*B[pos2].k+B[pos2].b;
		ans.push_back({T,nk,nb});
	}
	return ans;
}
vector<INFO> solve(int l,int r) {
	if(l==r) {
		vector<INFO> res;
		map<ll,ll> mn;
		ffor(i,1,n) if(mn.count(t[i][l])) mn[t[i][l]]=min(mn[t[i][l]],t[i][l-1]);
		else mn[t[i][l]]=t[i][l-1];
		res.push_back({-1000000000000000000,1,0});
		ll lst=LONG_LONG_MAX;
		for(auto pr:mn) {
			if(lst+1<=pr.second) res.push_back({lst+1,1,0});
			res.push_back({pr.second+1,0,pr.first});
			lst=pr.first;
		}
		if(lst!=LONG_LONG_MAX) res.push_back({lst+1,1,0});
		return res;
	}
	int mid=(l+r>>1);
	return merge(solve(l,mid),solve(mid+1,r));
}
void init(int L,int N,vector<ll> T,vector<int> W,int X,int M,vector<int> S) {
	len=L,XX=X;
	ffor(i,0,N-1) if(W[i]>X) ++n,w[n]=W[i]-X,t[n][0]=T[i];
	m=M-1;
	ffor(i,1,m) pos[i]=S[i];
	ffor(i,1,m) {
		ffor(j,1,n) t[j][i]=t[j][i-1]+1ll*w[j]*(pos[i]-pos[i-1]);
		vector<pair<pair<ll,int>,int>> vc;
		ffor(j,1,n) vc.push_back({{t[j][i-1],w[j]},j});
		sort(vc.begin(),vc.end());
		ll mx=-LONG_LONG_MAX;
		for(auto pr:vc) {
			int id=pr.second;
			t[id][i]=max(t[id][i],mx),mx=t[id][i];
		}
	}
	ans=solve(1,m);
	return ;
}
ll arrival_time(ll y) {
	int res=-1,l=0,r=ans.size()-1;
	while(l<=r) {
		int mid=(l+r>>1);
		if(ans[mid].t<=y) res=mid,l=mid+1;
		else r=mid-1;	
	}
	return ans[res].k*y+ans[res].b+1ll*len*XX;
}

/*
显然只需要考虑那些比 N 车慢的车。
先 O(n^2 \log n) 处理出这些车的信息。
区间 (i,j) 的分段函数 f(t) 为：时刻 t 在 i 出现了一辆车，他在 t 时刻出来了。
由于具有单调性，所以合并的时候显然端点数求和。使用分治 + 双指针维护这件事情。
一个小技巧：先把所有斜率都减去 x，答案把 dis*x 加上去即可 
------
询问的时候随便二分一下即可。 
*/
```

---

## 作者：yllcm (赞：0)

考虑暴力的做法：对于每个 $i$，维护出 $s_{i,j}$ 表示巴士 $j$ 到达调度站 $i$ 的实际时间，显然有：
$$
s_{i,j}=\max\left\{\max_{s_{i-1,k}<s_{i-1,j}} s_{i-1,k}+w_k(s_i-s_{i-1}),s_{i-1,j}+w_k(s_i-s_{i-1})\right\}
$$
考虑怎么回答询问。注意到被备用巴士拖慢的巴士不影响答案，不妨将它们忽略。我们只需要对于每个调度站，求出备用巴士到达它的时间 $Y_i$。这个问题只需要每次二分找到 $\max_{s_{i-1,k}<Y_i}s_{i-1,k}+w_k(s_i-s_{i-1})$ 即可仿照上面的过程轻松转移，不难使用前缀 max 维护。时间复杂度 $\mathcal{O}(nm\log n+qm\log n)$。[code](https://loj.ac/s/1902344)

考虑优化。发现这是一个经典套路：设 $f_i(Y)$ 表示 $Y$ 经过调度点 $i$ 转移之后的时间，我们最后需要求的是 $f_{0}(f_{1}(\cdots f_{m-2}(Y)))$。可以发现 $f_{i}(Y)$ 是一个不超过 $2n$ 段的分段一次函数，所以可以考虑直接暴力维护出函数 $g(Y)=f_{0}(f_{1}(\cdots f_{m-2}(Y)))$，其段数是不超过 $2mn$ 的（经典结论：段数为 $A$ 和一次函数 $f$ 与段数为 $B$ 的一次函数 $g$ 复合得到的新函数 $h$ 段数不超过 $A+B$）。

合并两个分段函数有经典的 $\mathcal{O}(A+B)$ 算法：每次找到 $f$ 每一段在定义域上的区间 $[x_l,x_r]$，并求出其值域区间 $[y_l,y_r]$，然后取函数 $g$ 在定义域为 $[y_l,y_r]$ 上的区间，还原到 $f$ 上后扔进 $h$ 里面，采用双指针即可。这个问题需要求 $m$ 个函数的复合，所以需要套一个分治。每次求出 $f_{[l,r]}(Y)$ 表示 $[l,r]$ 区间复合得到的分段函数，合并的时候令 $f_{[l,r]}(Y)=f_{[l,mid]}(f_{[mid+1,r]}(Y))$ 即可，可以证明复杂度为 $\mathcal{O}(nm\log m)$。

回答询问的时候只需要二分找到 $Y$ 所在的区间，总复杂度为 $\mathcal{O}(nm\log m+q(\log n+\log m))$。[code](https://loj.ac/s/1902513)

---

## 作者：nullqtr_pwp (赞：0)

简单题。

首先有一个 $\mathcal O(qnm)$ 的暴力，首先预处理所有 $t$，这个是容易的，每层对于上一层的 $t$ 排序，维护 $e$ 的前缀 $\max$ 即可，然后对于询问，暴力走这个额外车的每一步，它影响的进程只有因为它被阻碍的车，而这些车的速度更大，在后续一定不会阻碍它，因此维护一个备选集合 $S$，初始为 $[n]$，每一步时删除因为额外车被延后的车，然后这一步的 $t$ 就是仍在 $S$ 中的贡献 $\max$，而当前依旧在 $S$ 时的 $t$ 是和没有额外车一样的，直接写是 $39$ 分。然后你大胆猜想并不需要删除 $S$ 中被判定为对后续没有贡献的元素，一直令 $S$ 为 $[n]$ 即可。你的操作形如：走 $m-1$ 步，维护当前的 $Y$，$Y'$ 的值就是 $t_{i-1,j}<Y$ 中 $e_{i-1,j}$ 以及 $Y+X(S_i-S_i-1)$ 的 $\max$。数据结构加速这个过程就是 $\mathcal O(qm\log n)$，可以有 $65$ 分。

接下来需要加速分段函数复合的过程。由于每一个部分都是 $\mathcal O(n)$ 段的分段函数，那么复合 $m$ 遍就是 $\mathcal O(nm)$ 段的分段函数。因此我们只需要预处理出最终的分段函数是什么，询问就可以直接二分。我们只需要在 $\mathcal O(A+B)$ 的复杂度完成 $\mathcal O(A)$ 段的函数 $f(x)$ 以及 $\mathcal O(B)$ 段的分段函数 $g$，处理出最终 $f(g(x))$ 的分段函数，就直接对值域区间归并排序即可，画一个二维平面就比较直观了，$y$ 轴的分裂点就是 $g(x)$ 的断点。分治合并即可保证复杂度正确。这样复杂度就是 $\mathcal O(nm\log m+q\log nm)$。

---


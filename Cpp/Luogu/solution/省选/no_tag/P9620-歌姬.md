# 歌姬

## 题目背景

> 你如此一来就满足了吗？
>
> 没有想过去实现它吗?
>
> 为你而设的 为你而设的
>
> 可怜的制度化作温柔的义务

## 题目描述

现在 \*26 的头脑中想着 $n$ 件事情，它们形成一棵树．事情有现实和妄想两种状态．初始时所有事情都是妄想．不妨将事情 $1$ 假设成头脑中这棵树的根．那么一个事情 $u$ 的深度指从事情 $1$ 到事情 $u$ 的简单路径上的事情数（包含端点）．

我们称一个事情的集合 $S$ 为现实联通体，当其满足对于树上任意两个现实事情，其在树上简单路径（包括端点）中的事情都属于 $S$．极小现实连通体，即包含事情数最少的现实连通体．

随着时间推移，事情的状态可能发生一些变动．下面 \*26 和您提及了 $m$ 次事情的变动．变动分为以下两种不同的情况：

1. `Real u` 第 $u$ 件事情变成现实．
2. `Want u` 第 $u$ 件事情变成妄想．

每次变动后，\*26 会向您询问：目前至少还需要额外让几个事情变成妄想，才能使最小现实联通体中深度最小的事情的位置发生改变，或使当前头脑中不存在现实事情．

## 说明/提示

### 样例 #1 说明
举例最后一次变动结束后的情况．

此时树上除了事情 $1,3,7$ 是妄想，其余是现实．那么此时的最小现实联通体就是 $\{1,2,4,5,6\}$．

$\{2,4,5,6\}$ 不是最小现实连通体，因为存在两个现实事件如 $2,6$，其简单路径经过 $1$，而 $1$ 不在 $\{2,4,5,6\}$ 这个集合里；$\{1,2,3,4,5,6\}$ 同样不是最小现实联通体，因为存在一个现实联通体 $\{1,2,4,5,6\}$ 的大小小于它．

当我们令事情 $2,4$ 变成妄想后，现实事情仅剩下 $5,6$，这时最小现实连通体为 $\{5,6\}$．其中深度最小的事情由原来的 $1$ 变成了现在的 $5$．可以证明这个策略是最优策略之一．

### 数据点约束
|数据点编号|数据范围|
|:-:|:-:|
|$1,2$|$1\le n,m \le 20$|
|$3,4,5$|$1\le n,m \le 300$|
|$6,7,8$|$1\le n,m \le 3000$|
|$9,10,11,12$|$1\le n, m \le 39393$|
|$13 \sim 20$|$1\le n, m \le 2 \times 10^5$|

对于所有数据，保证在任意一次操作时，变动之前和变动之后事情的状态不一样．

## 样例 #1

### 输入

```
7 8
1 2
1 5
2 3
2 4
5 6
5 7
Real 3
Real 4
Real 6
Real 7
Want 7
Real 2
Real 5
Want 3
```

### 输出

```
1
1
1
2
1
1
2
2
```

# 题解

## 作者：Perfound (赞：4)

这里介绍一种不用考虑虚树根位置的方法。

首先求出所有节点子树内被选出的节点个数 $s_i$。

然后就可以发现虚树根位置就是 $s$ 最大的且深度最大的节点 $p$。

可以发现选出 $p$ 的儿子中 $s$ 最大的 $x$ 的子树内选出的节点不删，其他子树的删完是最优的方案。

然后就可以发现 $s_x$ 是严格第二大的，因为虚树根位置到根的 $s_i$ 肯定都相等且最大，而虚树根位置到根的节点肯定没有向外的子树中有被选的点。

于是直接线段树维护最大和严格第二大的值就好了。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#define N 1000010
#define l(p) p<<1
#define r(p) p<<1|1
struct edge{int next,to;}e[N];char s[10];bool usd[N];
int head[N],ip[N],st[N],ed[N],n,m,cnt,res;
int lt[N],pt[N],lz[N],id[N],idx,ipx;
struct sd{
	int a,b;
	void operator +=(const int &x){a+=x;if(~b)b+=x;}
	sd operator +(const sd &x){
		if(x.a>a)return (sd){x.a,max(x.b,a)};
		else if(x.a<a)return (sd){a,max(x.a,b)};
		else return (sd){x.a,max(x.b,b)};
	}
}mx[N];
void add(int a,int b){
	e[++cnt].to=b;
	e[cnt].next=head[a];
	head[a]=cnt;
}
void down(int p){
	mx[l(p)]+=lz[p],lz[l(p)]+=lz[p];
	mx[r(p)]+=lz[p],lz[r(p)]+=lz[p];
}
void app(int p,int l,int r,int i,int j,int k){
	if(i<=l&&r<=j){mx[p]+=k,lz[p]+=k;return;}
	if(lz[p])down(p),lz[p]=0;
	if(i<=((l+r)>>1))app(l(p),l,(l+r)>>1,i,j,k);
	if(j>((l+r)>>1))app(r(p),((l+r)>>1)+1,r,i,j,k);
	mx[p]=mx[l(p)]+mx[r(p)];
}
void dfs(int p,int f){
	ip[p]=1,pt[p]=f;
	for(int i=head[p];i;i=e[i].next){
		if(e[i].to==f)continue;
		dfs(e[i].to,p),ip[p]+=ip[e[i].to];
		if(ip[lt[p]]<ip[e[i].to])lt[p]=e[i].to;
	}
}
void cfs(int p,int f){
	if(lt[f]==p)ed[id[p]=id[f]]=p;
	else st[id[p]=++idx]=p;ip[p]=++ipx;
	if(lt[p])cfs(lt[p],p);
	for(int i=head[p];i;i=e[i].next)
		if(e[i].to!=f&&e[i].to!=lt[p])cfs(e[i].to,p);
}
void mak(int p,int k){
	for(;id[p]!=1;p=pt[st[id[p]]])
		app(1,1,n,ip[st[id[p]]],ip[p],k);
	app(1,1,n,1,ip[p],k),res+=k;
}
int main(){
	scanf("%d%d",&n,&m);for(int i=1;i<=n*4;i++)mx[i].b=-1;
	for(int i=1,a,b;i<n;i++)scanf("%d%d",&a,&b),add(a,b),add(b,a);
	dfs(1,0),cfs(1,0);
	for(int i=1,a;i<=m;i++){
		scanf("%s%d",s,&a);
		if(s[0]=='R'&&!usd[a])usd[a]=true,mak(a,1);
		else if(s[0]=='W'&&usd[a])usd[a]=false,mak(a,-1);
		printf("%d\n",res-mx[1].b);
	}
	return 0;
}
```


---

## 作者：JiaY19 (赞：2)

感觉题解做法都好神秘。

来一个容易理解，通俗易懂的树剖解法。

### 思路

容易发现原问题等价于维护一个虚树。

每一次询问虚树的根的所有儿子的最大值。

要求链修。

容易发现仅仅动态维护根是好做的。

我们每次维护搜索序的最小值和最大值。

对于这两个点求最近公共祖先就是整个虚树的根。

现在就只需要维护链修与儿子查询。

这就是一个经典的树剖拓展了。

我们在第二次深度优先搜索的时候。

我们将所有轻儿子一起遍历。

那么就可以做到每个点除了重儿子，轻儿子编号连续。

每条重链，除了链顶，其余编号连续。

与普通树剖相比常数只是乘了二。

### Code

[AC 记录](https://www.luogu.com.cn/record/136184642)。

---

## 作者：_AyachiNene (赞：1)

简单题。
# 思路：
首先题目本质上就是问改变黑点点集的 lca 要删几个点。然后就很简单了，设所有黑点的 lca 为 $p$，显然是把 $p$ 所有儿子的子树中的黑点删得只存在于一个子树中。要让这个值尽量小，等价于保留一个黑点数最多的子树。现在问题转化为维护点集的 lca 和每个点儿子中黑点数最多的子树。对于第一个问题直接拿堆维护 dfn 最大最小点即可。第二个问题很典，可以用树链剖分维护轻链或者直接 lct。我写的树链剖分维护轻链，因为复杂度是一样的。具体的，每个点开个堆，拿树状数组维护子树和，每次更新一个点就一直跳链，每次改链顶的父亲的堆即可。时间复杂度 $O(n\log^2n)$。
# Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace IO
{
	char buff[1<<21],*p1=buff,*p2=buff;
	char getch(){return p1==p2&&(p2=((p1=buff)+fread(buff,1,1<<21,stdin)),p1==p2)?EOF:*p1++;}
	template<typename T>void read(T &x){char ch=getch();int fl=1;x=0;while(ch>'9'||ch<'0'){if(ch=='-')fl=-1;ch=getch();}while(ch<='9'&&ch>='0'){x=x*10+ch-48;ch=getch();}x*=fl;}
	template<typename T>void read_s(T &x){x="";char ch=getch();while(!(ch>='a'&&ch<='z')&&!(ch>='A'&&ch<='Z'))ch=getch();while((ch>='a'&&ch<='z')||(ch>='A'&&ch<='Z')){x+=ch;ch=getch();}}
	template<typename T,typename ...Args>void read(T &x,Args& ...args){read(x);read(args...);}
	char obuf[1<<21],*p3=obuf;
	void putch(char ch) {if(p3-obuf<(1<<21))*p3++=ch;else fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=ch;}
	char ch[100];
	template<typename T>void write(T x) {if(!x)return putch('0');if(x<0)putch('-'),x*=-1;int top=0;while(x)ch[++top]=x%10+48,x/=10;while(top)putch(ch[top]),top--;}
	template<typename T,typename ...Args>void write(T x,Args ...args) {write(x);putch(' ');write(args...);}
	void put(string s){for(int i=0;i<s.size();i++)putch(s[i]);}
	void flush(){fwrite(obuf,p3-obuf,1,stdout);}
}
using namespace IO;
struct node
{
	int nxt,to;
}e[200005<<1];
int head[200005],cnt_edge;
inline void add_edge(int u,int v)
{
	e[++cnt_edge].to=v;
	e[cnt_edge].nxt=head[u];
	head[u]=cnt_edge;
}
int n,m;
namespace Saki
{
	int t[200005];
	inline int lowbit(int x){return x&-x;}
	inline void add(int x,int v){for(;x<=n;x+=lowbit(x))t[x]+=v;}
	inline int Query(int x){int res=0;for(;x;x-=lowbit(x))res+=t[x];return res;}
	inline int query(int x,int y){return Query(y)-Query(x-1);}
}using namespace Saki;
struct Soyo
{
	priority_queue<int>q,p;
	inline void insert(int x){q.push(x);}
	inline void del(int x){p.push(x);}
	inline int query()
	{
		while(p.size()&&p.top()==q.top()) q.pop(),p.pop();
		return q.top();
	}
}heap[200005];
int f[200005],dep[200005],siz[200005],son[200005],dfn[200005],top[200005],cnt,id[200005];
void dfs1(int u,int fa)
{
	f[u]=fa;siz[u]=1;dep[u]=dep[fa]+1;
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==fa) continue;
		dfs1(v,u);siz[u]+=siz[v];
		if(siz[son[u]]<siz[v]) son[u]=v; 
	}
}
void dfs2(int u,int t)
{
	heap[u].insert(0);
	top[u]=t;dfn[u]=++cnt;id[cnt]=u;
	if(son[u]) dfs2(son[u],t);
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==f[u]||v==son[u]) continue;
		heap[u].insert(0);
		dfs2(v,v);
	}
}
int a[200005];
inline void update(int p,int op)
{
	while(f[top[p]])
	{
		if(op) heap[f[top[p]]].insert(query(dfn[top[p]],dfn[top[p]]+siz[top[p]]-1));
		else heap[f[top[p]]].del(query(dfn[top[p]],dfn[top[p]]+siz[top[p]]-1));
		p=f[top[p]];
	}
}
set<int>s;
inline int lca(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		x=f[top[x]];
	}
	return dep[x]<dep[y]?x:y;
}
int main()
{
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	read(n,m);
	for(int i=1;i<n;i++)
	{
		int u,v;read(u,v);
		add_edge(u,v);add_edge(v,u);
	}
	dfs1(1,0);dfs2(1,1);
	while(m--)
	{
		string op;int x,w;
		read_s(op);read(x);
		if(op=="Real") w=1;else w=0;
		if(a[x]!=w)
		{
			if(a[x]) s.erase(dfn[x]);
			else s.insert(dfn[x]);
			update(x,0);add(dfn[x],w-a[x]);update(x,1);
			a[x]=w;
		}
		if(!s.size()){write(0),putch('\n');continue;}
		int p=lca(id[*s.begin()],id[*(--s.end())]);
		int mx=heap[p].query();
		if(son[p]) mx=max(mx,query(dfn[son[p]],dfn[son[p]]+siz[son[p]]-1));
		write(query(dfn[p],dfn[p]+siz[p]-1)-mx),putch('\n');
	}
	flush();
	return 0;
}
```

---

## 作者：Scinerely (赞：1)

### 题目描述
现在有一棵 $n$ 节点的树，树上的每一个点都有一个颜色，黑色或者白色，一开始都是白色。并且有 $q$ 次操作，每一次操作会改变一个节点的颜色（黑色变白色，白色变黑色）。

每一次询问之后，你需要回答至少要更改多少个黑色节点的颜色才可以使得黑色节点两两之间的路径并中最小的深度的节点发生改变？

$n,q \leqslant 2\times 10^5$。

### 思路点拨

提供一个比较好想的考场思路

对于一个局面，我们将全部的黑色节点建立一颗虚树，策略十分单一：我们找到虚树的根的儿子节点中黑色节点数量最多的子树，将其保留，别的删掉。不然就会存在两个子树同时存在黑色节点，然后这颗虚树的根又被统计到了，最小深度不会发生改变。并且保留黑色节点最多的子树可以让我们改变颜色的次数尽可能的小。

现在的问题有两个：

- 如何快速找到虚树的根节点并且动态维护？

- 如何在快速的时间内找到某个节点儿子子树中黑色节点数量的最大值？

先考虑简答的第一个问题：

我们维护一个集合 $S$，$S$ 中的元素按照 $dfn$ 大小排序。每一次我们找到 $dfn$ 最小的和 $dfn$ 最大的求树上公共祖先即可。

再考虑第二个问题：

我们发现，如果我们要便利一个节点的儿子最劣是 $O(n)$ 的，不论别的你操作的再快，还是一个 $O(nq)$ 的算法。所以要行得通，就不可以遍历全部的儿子节点。全部节点的儿子节点数量和是 $n$ 这个级别的，我们考虑一个分治

- 对于儿子数量小于等于 $B$ 的节点

我们考虑每一个节点更改颜色的时候只会影响这个节点到根的路径，我们使用树链剖分+$\text{BIT}$ 去进行树上链上加和单点查询。每一次我们暴力遍历儿子然后统计子树中黑色节点数量的最大值。

- 对于儿子数量大于 $B$ 的节点

只有 $\dfrac{n}{B}$ 个这样的节点。我们对于每一个节点开一个动态开点权值线段树,然后每一次我们更改节点的时候，暴力判断这个节点是是否会对这些儿子节点数量大的节点产生影响（判断是否在子树中是 $O(1)$ 的，可以使用 $dfn$ 判断）。然后在动态开点权值线段树上修改。每一次查询的时候可以 $O(1)$ 取根节点的最大值。

注意：我们所说的动态开点权值线段树是针对于儿子的。所以每一次更改还需要使用树上倍增法找到儿子。这一部分比较抽象，建议看代码。

$B$ 可以取 $\sqrt{n\log n}$ 或者 $\sqrt{n}$，看看哪个快。可以线段树换分块来优化时间复杂度。

[code](https://www.luogu.com.cn/paste/mjq1cgu7)

---

## 作者：_Ch1F4N_ (赞：1)

支持好写好调的正义分块。

首先，建出虚树后这个问题变成删去一些点使得根不再需要在虚树中出现。

假若根的度数本来就小于等于 $1$ 就把根删去。

否则可以贪心地保留一个最大子树，然后把其他子树连带根一起删掉。

现在只剩怎么维护的问题了。

接下来考虑根号分治，

假设根的度数小于等于 $\sqrt n$ 则暴力枚举子树，并用一个 $O(\sqrt n)$ 修改 $O(1)$ 查询的值域分块维护子树内关键点数量。

否则考虑直接把每个子树内的点暴力染色，并在修改时顺带修改子树的信息，由于度数大于 $O(\sqrt n)$ 的点只有 $O(\sqrt n)$ 个，所以这么做复杂度仍然是 $O(n \sqrt n)$ 的，为了节省空间，这里需要离线操作并把询问挂在虚树的根上跑。

最终我们得到一个时间复杂度 $O(n \sqrt n)$ 空间复杂度 $O(n)$ 的算法，而且常数极小跑的飞快。

```cpp
#include<bits/stdc++.h>
//#define int long long
//#define lowbit(x) (x&-(x))
using namespace std;
const int maxn = 2e5+115;
const int B = 550;
const int warma = 550;
int top[maxn],fa[maxn],sz[maxn],son[maxn],d[maxn],L[maxn],R[maxn],dfncnt,dep[maxn];
vector<int> vec[maxn];
vector<int> edge[maxn];
string s[maxn];
int X[maxn];
int answer[maxn];
struct block{
	int pre[700];
}cnt[700];
int cnt_pre[700];
inline void add(int x,int val){
	int sum = x/B;
	x%=B;
	if(x==0) sum--,x+=B;
	for(int i=x;i<=B;++i) {
		cnt[sum].pre[i]+=val;
	}
	for(int i=sum;i<=B;++i) cnt_pre[i]+=val;
}
inline int query(int l,int r){
	if(l>r) return 0;
	int lc=l/B;
	l%=B;
	int rc=r/B;
	r%=B;
	if(l==0) lc--,l+=B;
	if(r==0) rc--,r+=B;
	if(lc==rc) return cnt[lc].pre[r]-cnt[rc].pre[l-1];
	int res=0;
	res+=cnt[lc].pre[B]-cnt[lc].pre[l-1];
	res+=cnt[rc].pre[r];
	res+=cnt_pre[rc-1]-cnt_pre[lc];
	return res;
}
void dfs(int u){
	dep[u]=dep[fa[u]]+1;
	L[u]=++dfncnt;
	sz[u]=1;
	for(int v:edge[u]){
		if(v==fa[u]) continue;
		d[u]++;
		fa[v]=u;
		dfs(v);
		sz[u]+=sz[v];
		if(sz[v]>sz[son[u]]) son[u]=v;
	}
	R[u]=dfncnt;
}
void init(int u,int tp){
	top[u]=tp;
	for(int v:edge[u]){
		if(v==fa[u]) continue;
		if(v==son[u]) init(v,tp);
		else init(v,v);
	}
}
int LCA(int u,int v){
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]]) swap(u,v);
		u=fa[top[u]];
	}
	if(dep[u]<dep[v]) swap(u,v);
	return v;
}
int n,q;
set< pair<int,int> > S;
int col[maxn];
int sum[maxn];
int w[maxn],Cnt[maxn],res;
void solve(int u,int cl){
	col[u]=cl;
	for(int v:edge[u]){
		if(v==fa[u]) continue;
		solve(v,cl);
	}
}
void Add(int u){
	if(u==0) return ;
	Cnt[w[u]]--;
	w[u]++;
	Cnt[w[u]]++;
	if(w[u]>res) res=w[u];
}
void Del(int u){
	if(u==0) return ;
	Cnt[w[u]]--;
	w[u]--;
	Cnt[w[u]]++;
	if(w[u]+1==res&&Cnt[w[u]+1]==0) res=w[u];
}
bool flag[maxn];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>q;
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		edge[u].push_back(v);
		edge[v].push_back(u);
	}
	dfs(1);
	init(1,1);
	for(int i=1;i<=q;i++){
		string opt;
		int x;
		cin>>opt>>x;
		s[i]=opt;
		X[i]=x;
		if(opt=="Real"){
			S.insert(make_pair(L[x],x));
			add(L[x],1);
		}
		else{
			S.erase(make_pair(L[x],x));
			add(L[x],-1);
		}
		if(S.size()==0){
			answer[i]=0;
			continue;
		}
		int lca=LCA((*S.begin()).second,(*S.rbegin()).second);
		if(d[lca]<=warma){
			int mx=0,t=0;
			for(int v:edge[lca]){
				if(v==fa[lca]) continue;
				mx=max(mx,query(L[v],R[v]));
				t+=(query(L[v],R[v])==0?0:1);
			}
			if(t>1) answer[i]+=S.size()-mx;
			else answer[i]+=query(L[lca],L[lca]);
		}
		else{
			vec[i].push_back(lca);
		}
		sum[i]=S.size();
	}
	for(int i=1;i<=n;i++){
		if(d[i]<=warma) continue;
		memset(col,0,sizeof(col));
		memset(w,0,sizeof(w));
		memset(Cnt,0,sizeof(Cnt));
		memset(flag,0,sizeof(flag));
		res=0;
		for(int v:edge[i]){
			if(v==fa[i]) continue;
			solve(v,v);
		}
		Cnt[0]+=d[i];
		for(int j=1;j<=q;j++){
			if(s[j]=="Real") flag[X[j]]=true,Add(col[X[j]]);
			else flag[X[j]]=false,Del(col[X[j]]);
			for(int lca:vec[j]){
				if(lca==i){
					if(d[i]-Cnt[0]>1) answer[j]+=(sum[j]-res);
					else answer[j]+=flag[i];
				}
			}
		}
	}
	for(int i=1;i<=q;i++) cout<<answer[i]<<'\n';
	return 0;
}
```


---

## 作者：Hoks (赞：0)

## 前言
好玩树剖题，这个东西算是让我眼前一亮了。

广告：[『从入门到入土』树链剖分学习笔记](https://www.luogu.com.cn/article/56o68hfu)。
## 思路分析
简要题意：
> 给定有 $n$ 个点的树，最开始所有点都是白点，每次操作给一个点染黑/染白。
> 
> 操作后，得到所有黑点的导出子树，求使这个导出子树的根的深度变化最少要删掉多少黑点。
>
> 特别的，如果删空了也算变化。

如果只求根节点的话显然是一个一眼题。

这个比较简单就不再赘述，直接给出经典结论：
- 对于点 $a_{1,2,\dots,n}$，他们的 LCA 即为 dfn 序最小和最大的点的 LCA。

原因也比较显然，有兴趣的读者可以自证。

接着考虑怎么样改变根节点的同时删掉的点最少。

我们考虑其实只有两种可能：
1. 根节点 $x$ 处分多叉子树，每叉里都有黑点。

    此时我们考虑只保留一叉子树然后把多余的全删了就行了。

   也就是找到总点数 $w$，含有黑点数最多的子树黑点数 $w'$，答案即为 $w-w'$。
2. 根节点处后只有一叉子树，但是根节点是黑点。

    其实这类情况可以直接合并进 $1$ 里，我们把根节点这个黑点当做是子树外的另一叉即可。

这下就变成了，单点修改权值，查询给定点 $x$ 的儿子的子树最大权值。

如果遍历儿子算子树和这显然复杂度会爆掉，所以我们不要写成单点加，子树查。

把这个转化一下，变成链加，单点查。

也就是对于点 $x$，我们给 $x\rightarrow 1$ 的路径加上修改的权值，那么查询的时候点 $y$ 对应的权值就是他的子树权值和了。

接着我们要考虑的就是快速查询所有儿子权值最大值的方法。

考虑把这东西也交给线段树维护，但是问题来了：
- 对于一个点 $x$，他的所有儿子的 dfn 序不是连续的，这怎么办。

注意到我们不需要子树 dfn 序连续的性质，只需要保证重链 dfn 序连续即可。

所以我们可以对树剖的第二遍 dfs 略加修改，让轻儿子的 dfn 序也连续。

然后就可以比较方便的实现了，具体可以看代码。
## 代码

```cpp
#include<bits/stdc++.h>
#define ls (p<<1)
#define rs (ls|1)
#define mid ((l+r)>>1)
#define int long long
using namespace std;
const int N=2e5+10,M=3,INF=0x3f3f3f3f,mod=1e9+7,p=13331;
int n,m,cnt,a[N],t[N<<2],lz[N<<2];vector<int>e[N];char s[N];set<int>st;
namespace Fast_IO
{
    static char buf[1000000],*paa=buf,*pd=buf,out[10000000];int length=0;
    #define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
    inline int read()
    {
        int x(0),t(1);char fc(getchar());
        while(!isdigit(fc)){if(fc=='-') t=-1;fc=getchar();}
        while(isdigit(fc)) x=(x<<1)+(x<<3)+(fc^48),fc=getchar();
        return x*t;
    }
    inline void flush(){fwrite(out,1,length,stdout);length=0;}
    inline void put(char c){if(length==9999999) flush();out[length++]=c;}
    inline void put(string s){for(char c:s) put(c);}
    inline void print(int x)
    {
        if(x<0) put('-'),x=-x;
        if(x>9) print(x/10);
        put(x%10+'0');
    }
    inline bool chk(char c) { return !(c>='a'&&c<='z'||c>='A'&&c<='Z'||c>='0'&&c<='9'||c=='?'); }
    inline bool ck(char c) { return c!='\n'&&c!='\r'&&c!=-1&&c!=' '; }
    inline void rd(char s[],int&n)
    {
        s[++n]=getchar();
        while(chk(s[n])) s[n]=getchar();
        while(ck(s[n])) s[++n]=getchar();
        n--;
    }
}
using namespace Fast_IO;
namespace tree_decomposition
{
    int fa[N],son[N],si[N],dep[N];
    int top[N],id[N],dfn[N],mn[N];
	inline void clear(int n)
	{
		memset(son,0,sizeof son);
		for(int i=1;i<=n;i++) e[i].clear();
	}
    inline void add(int u,int v){e[u].emplace_back(v),e[v].emplace_back(u);}
    inline void dfs1(int u,int ff)
    {
        fa[u]=ff,si[u]=1,dep[u]=dep[ff]+1;
        for(auto v:e[u])
        {
            if(v==ff) continue;
            dfs1(v,u);si[u]+=si[v];
            if(si[son[u]]<si[v]) son[u]=v;
        }
    }
    inline void dfs2(int u,int topf)
    {
        top[u]=topf;int f=0;if(son[u]) dfn[son[u]]=++cnt,id[cnt]=son[u],dfs2(son[u],topf);
        for(auto v:e[u]) if(v!=fa[u]&&v!=son[u]) mn[u]=f?mn[u]:cnt+1,f=1,dfn[v]=++cnt,id[cnt]=v;
	    for(auto v:e[u]) if(v!=fa[u]&&v!=son[u]) dfs2(v,v);
    }
    inline int LCA(int x,int y)
    {
        while(top[x]!=top[y])
        {
            if(dep[top[x]]<dep[top[y]]) swap(x,y);
            x=fa[top[x]];
        }
        return dep[x]<dep[y]?x:y;
    }
}
using namespace tree_decomposition;
inline void pushson(int p,int w){t[p]+=w;lz[p]+=w;}
inline void pushdown(int p){pushson(ls,lz[p]);pushson(rs,lz[p]);lz[p]=0;}
inline void modify(int p,int l,int r,int s,int e,int w)
{
    if(l>=s&&r<=e) return pushson(p,w);pushdown(p);
    if(mid>=s) modify(ls,l,mid,s,e,w);
    if(mid<e) modify(rs,mid+1,r,s,e,w);
    t[p]=max(t[ls],t[rs]);
}
inline void modify(int x,int w)
{
    while(x)
    {
        int y=dep[x]-dep[top[x]];
        if(x^top[x]) modify(1,1,n,dfn[x]-y+1,dfn[x],w);
        modify(1,1,n,dfn[top[x]],dfn[top[x]],w);
        x=fa[top[x]];
    }
}
inline int query(int p,int l,int r,int s,int e)
{
    if(l>=s&&r<=e) return t[p];pushdown(p);int res=0;
    if(mid>=s) res=query(ls,l,mid,s,e);
    if(mid<e) res=max(res,query(rs,mid+1,r,s,e));
    return res;
}
inline int query(int x)
{
    int res=query(1,1,n,dfn[son[x]],dfn[son[x]]);
    int y=e[x].size()-(bool)son[x]-(x!=1);
    if(y<=0) return res;
    return max(res,query(1,1,n,mn[x],mn[x]+y-1));
}
inline void solve()
{
    n=read(),m=read();for(int i=1,u,v;i<n;i++) u=read(),v=read(),add(u,v);
    dfs1(1,0),dfn[1]=++cnt,id[1]=1,dfs2(1,1);
    for(int i=1,l=0,x;i<=m;i++)
    {
        l=0;rd(s,l);x=read();
        if(s[1]=='W'&&a[x]==1) modify(x,-1),st.erase(dfn[x]),a[x]^=1;
        if(s[1]=='R'&&a[x]==0) modify(x,1),st.insert(dfn[x]),a[x]^=1;
        if(st.empty()){put("0\n");continue;}
        if(st.size()==1){put("1\n");continue;}
        int lca=LCA(id[*st.begin()],id[*(--st.end())]);
        print(st.size()-query(lca));put('\n');
    }
}
signed main()
{
    int T=1;while(T--) solve();
    genshin:;flush();return 0;
}
```

---


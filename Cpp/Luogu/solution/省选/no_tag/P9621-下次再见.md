# 下次再见

## 题目背景

> 在逝去的季节中 遗失的宝藏
>
> 是缺失一角的 珍贵拼图
>
> 就像白雪在街道上 温柔地堆积的样子
>
> 也将回忆相簿的空白 全部填满吧

## 题目描述

有一首由 $n$ 个圆圈组成的乐曲．玩家会 **等概率随机选定** $1 \sim n$ 中的一个位置开始游玩，顺序点击那个位置和之后的所有圆圈来完成乐曲的演奏．

对于每个圆圈的点击精准度存在四种判定，分别是 $\texttt{GREAT,OK,MEH,MISS}$．

存在一种机制：当连续 $K$ 次 $\texttt{MISS}$ 后，玩家会强制退出游戏；否则玩家会一直游玩直到点击完所有圆圈．

现在给出对于每个圆圈，玩家达成每一种判定的概率：对于第 $i$ 个圆圈，判定 $\texttt{GREAT},\texttt{OK},\texttt{MEH},\texttt{MISS}$ 的概率分别为 $P_{i,0}/100,\ P_{i,1}/100,\ P_{i,2}/100,\ P_{i,3}/100$．保证 $P_{i,0}+P_{i,1}+P_{i,2}+P_{i,3}=100$．

得分是衡量整段演奏的指标，它的计算方式是，假设整段演奏中出现了 $a$ 次 $\texttt{GREAT}$，$b$ 次 $\texttt{OK}$，$c$ 次 $\texttt{MEH}$，$d$ 次 $\texttt{MISS}$，那么演奏的得分为 $300a+100b+50c$．

你需要回答玩家得分的期望．

说明：如果强制退出游戏，那么计算得分时，整段演奏包括从开始的点击到最后一次判定 $\texttt{MISS}$ 的点击为止所有的点击．

在部分数据大小范围较大的测试点上，为了减小输入输出的交互量，我们采用了不同的输入方式．您需要在您的 c++ 代码中加入题目附件中提供的数据生成器．建议在阅读接下来的内容前先浏览一下生成器中提供的函数名称，这可以帮助您更好地理解输入格式．

## 说明/提示

|测试点编号|数据范围|特殊性质|
|:-:|:-:|:-:|
|$1\sim 2$|$n\le 5$||
|$3\sim 4$|$n\le 50$||
|$5\sim 6$|$n\le 10^3$||
|$7\sim 8$|$n\le 10^5,K\le 10^3$||
|$9\sim 10$||$A$|
|$11\sim 12$||$B$|
|$13\sim 15$|$n,K\le 5\times 10^5$||
|$16\sim 20$||

$A$：保证所有位置的 $P_{i,3}$ 相等．

$B$：保证对于所有位置，$P_{i,3}$ 等于 $0$ 或等于 $100$．

---
对于编号在 $1\sim 15$ 的测试点，$Type=0$；对于编号在 $16\sim 20$ 的测试点，$Type=1$．

保证，对于全部数据，$0\le P_{i,0/1/2/3}\le 100$，$1\le K\le n\le 5\times 10^6$，$Type=0/1$，$1\le seed\le 10^9$．

## 样例 #1

### 输入

```
0 0
4 2
10 20 20 50
20 10 20 50
20 20 10 50
20 50 10 20
```

### 输出

```
530317523```

## 样例 #2

### 输入

```
0 280114129
5 5
36 23 30 11
0 52 25 23
14 61 23 2
10 41 37 12
0 12 78 10
```

### 输出

```
898420164```

## 样例 #3

### 输入

```
1 114
5141 919
```

### 输出

```
800181066```

# 题解

## 作者：kernel_panic (赞：1)

## 思路

不妨令 $p_i$ 表示圆圈 $i$ MISS 的概率，$e_i$ 为圆圈 $i$ 的期望得分．下文称“强制退出游戏”为“寄”．

先考虑固定起点为 $1$ 怎么做．

设 $f_i$ 表示点击圆圈 $i$ 后寄了的概率，$g_i$ 表示点击完前 $i$ 个圆圈后没寄的概率．

考虑计算 $f$，此时 $(i - K, i]$ 这一段圆圈必须全都 MISS，而圆圈 $i - K$ 不能 MISS，且点击 $i - K$ 前没寄．所以有：

$$
f_i = \left((1 - p_{i - K}) \prod_{j \in (i - K, i]} p_j\right) g_{i - K - 1}
$$

考虑计算 $g$，此时对于前 $i$ 个圆圈，点击后都不能寄，有：

$$
g_i = 1 - \sum_{j = 1}^i f_j
$$

此时期望得分为

$$
e_1 + \sum_{i = 1}^{n - 1} g_i e_{i + 1}
$$

现在考虑对于 $1 \sim n$ 中所有位置作为起点时，计算答案．不妨先算出期望分数的和，然后乘 $\frac{1}{n}$．

类似地，设 $f_{s, i}$ 表示从圆圈 $s$ 开始游玩，点击圆圈 $i$ 后寄了的概率，$g_{s, i}$ 表示从圆圈 $1$ 开始游玩，点击完圆圈 $i$ 后继续游玩的概率，特别地，令 $g_{s, s - 1} = 1$．那么期望和为：

$$
\begin{aligned}
  \sum_{s = 1}^n \left(e_s + \sum_{i = s}^{n - 1} g_{s, i} e_{i + 1}\right)
  &= \sum_{i = 1}^n e_i \left(1 + \sum_{s = 1}^{i - 1} g_{s, i - 1}\right) \\
\end{aligned}
$$

不妨令 $h_i = \sum\limits_{s = 1}^i g_{s, i} = i - \sum\limits_{j = 1}^i \sum\limits_{s = 1}^j f_{s, j}$，考虑对每个 $i$ 快速计算 $\sum\limits_{s = 1}^i f_{s, i}$．

$$
\begin{aligned}
  \sum_{s = 1}^i f_{s, i}
  &= \sum_{s = 1}^i \left((1 - p_{i - K}) \prod_{j \in (i - K, i]} p_j\right) g_{s, i - K - 1} \\
  &= \left((1 - p_{i - K}) \prod_{j \in (i - K, i]} p_j\right) \sum_{s = 1}^i g_{s, i - K - 1}  \\
  &= \left((1 - p_{i - K}) \prod_{j \in (i - K, i]} p_j\right) h_{i - K - 1}
\end{aligned}
$$

预处理前缀积和及其逆元即可 $O(n)$ 计算．注意 $p_i$ 可以等于 $0$，std 的处理方式是使用 $1$ 作为占位，然后特判 $(i - K, i]$ 中有 $0$ 的情况．

## 代码

```cpp
#include <cstdio>
#define debug(...) fprintf(stderr, __VA_ARGS__)

using i64 = long long;

inline i64 rd() {
	i64 x = 0, f = 1, c = getchar();
	while (((c - '0') | ('9' - c)) < 0)
		f = c != '-', c = getchar();
	while (((c - '0') | ('9' - c)) > 0)
		x = x * 10 + c - '0', c = getchar();
	return f ? x : -x;
}

struct Gen {
	using ull = unsigned long long;
	ull rand_num;
	inline void init(ull seed) { rand_num = seed; }
	inline ull next() {
		ull z = (rand_num += 0x9e3779b97f4a7c15);
		z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9;
		z = (z ^ (z >> 27)) * 0x94d049bb133111eb;
		return z ^ (z >> 31);
	}
	inline int rnr(int l, int r) { return l + (int)(next() % (r - l + 1)); }
	inline void get(int &a, int &b, int &c, int &d) {
		int divpart = rnr(0, 100);
		a = rnr(0, divpart), b = divpart - a;
		c = rnr(0, 100 - divpart), d = 100 - divpart - c;
	}
} Ge;

const int N = 5e6;
const i64 P = 998244353;
inline i64 fpow(i64 b, i64 p) {
	i64 res = 1;
	for (; p; b = b * b % P, p >>= 1) {
		if (p & 1) res = res * b % P;
	}
	return res;
}
i64 I[101];

int type;
int n, k;
i64 e[N + 5], p[N + 5], ip[N + 5];
i64 pr[N + 5], ipr[N + 5];
int fl[N + 5];
i64 f[N + 5];

int main() {
	for (int i = 1; i <= 100; i++) I[i] = fpow(i, P - 2);

	type = rd(), Ge.init(rd());
	n = rd(), k = rd();
	for (int i = 1, p1, p2, p3, p4; i <= n; i++) {
		if (!type) p1 = rd(), p2 = rd(), p3 = rd(), p4 = rd();
		else Ge.get(p1, p2, p3, p4);
		e[i] = (300 * p1 + 100 * p2 + 50 * p3) % P * I[100] % P;
		p[i] = p4 * I[100] % P, ip[i] = 100 * I[p4] % P;
	}

	pr[0] = ipr[0] = 1;
	for (int i = 1; i <= n; i++) {
		pr[i] = pr[i - 1] * (p[i] ? p[i] : 1) % P;
		ipr[i] = ipr[i - 1] * (ip[i] ? ip[i] : 1) % P;
		fl[i] = fl[i - 1] + !p[i];
	}

	i64 sum = 0;
	for (int i = 1; i <= n; i++) {
		i64 ct = 0;

		if (i >= k) {
			i64 c1 = (fl[i] - fl[i - k]) ? 0 : (pr[i] * ipr[i - k] % P);
			i64 c2 = (1 + P - p[i - k]) % P;

			(ct += c1) %= P;
			if (i > k) (ct += c1 * c2 % P) %= P;
			if (i > k + 1) (ct += c1 * c2 % P * f[i - k - 1] % P) %= P;
		}

		(sum += ct) %= P;
		f[i] = (i + P - sum) % P;
	}

	i64 ans = 0;
	for (int i = 1; i <= n; i++) (ans += (1 + f[i - 1]) * e[i] % P) %= P;
	(ans *= fpow(n, P - 2)) %= P;

	printf("%lld\n", ans);
	return 0;
}
```

## 参考

edisnimorF, [_下次再见 题解_](https://www.luogu.com.cn/blog/edisnimorF/xia-ci-zai-jian-ti-xie)


---


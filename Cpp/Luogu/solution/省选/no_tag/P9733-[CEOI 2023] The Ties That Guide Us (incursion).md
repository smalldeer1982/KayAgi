# [CEOI 2023] The Ties That Guide Us (incursion)

## 题目描述

你用销售机器人的利润雇佣了一名助手，现在你准备好去拿走装有 CEOI 奖章的保险箱了。

保险箱位于一所由 $n$ 个房间所组成的大学建筑内，这些房间由 $n-1$ 扇门连接。每个房间都可以从其他任何房间到达，且每个房间最多与 $3$ 扇门相连。  
你和你的助手都有描述建筑物内房间相连情况的平面图，但是你们两个各自拥有的平面图虽然描述了相同的房间结构布局，但是房间和门的编号可能不同。

在比赛的第二天，委员会忙于处理赛时通知和选手提问。这将是接近装着奖牌的保险箱的完美机会。

你的助手会首先搜索整栋大楼。一旦他找到保险箱所在的房间，它就会给你留下前往那个房间的提示。由于手机不能带进赛场，他用了去年 BOI 留下的几乎无限供应的领带。由于这些领带完全相同无法区分，你能获得的信息就是他在任何给定房间里所留下的领带数量。由于一个房间内过多的领带非常可疑，因此任何单个房间内领带的最大数量应当尽可能少（参阅评分部分）。

之后，你计划在上厕所的时候溜出去，利用助手留下来的领带找到有保险箱的房间。保险箱藏在房间里，所以你进入带有保险箱的房间时，必须依靠领带识别这个房间；此外，由于“上厕所”时间过长会被发现，你必须尽快找到保险箱。你最多可以走过 $d+30$ 扇门，其中 $d$ 是你的初始位置到保险箱所在位置的最短路径上的门数量。若重复穿过同一扇门，则每次都计入。

因此，你需要编写一个程序，告诉助手需要在每个房间留下多少条领带，并引导你前往带有保险箱的房间。

## 说明/提示

### 评分细则

共有 4 个 subtask。对于每个测试点，$2 \le n \le 45000$。

Subtask 1 (30 points)，保证没有一个房间有三扇门相连。
Subtask 2 (30 points). 有且仅有一个房间有两扇门相连。
Subtask 3 (40 points). 没有特殊性质。

对于每个测试点，假设使用领带最多的房间用了 $T_{\max}$ 条领带，
- $T_{\max}<2$，你将会获得该测试点 $100\%$ 的分数。
- $T_{\max}=2$，你将会获得该测试点 $40\%$ 的分数。
- $2 < T_{\max} \le 10^9$，你将会获得该测试点 $30\%$ 的分数。

### 交互库使用方法
**注意洛谷提供的交互库与原版不同。**

请使用 `g++ -std=c++17 -Wall -O2 -o test interactive_lib.cpp xxx.cpp` 编译，其中 `xxx.cpp` 是你的程序名字。

示例交互库首先从标准输入读入三个正整数, $n$, $s$, $seed$，表示点数、起点的原编号、随机数种子。

然后读入 $n-1$ 行，每行两个正整数 $u,v$，表示原树的一条边。其中需保证 $1 \le u < v \le n$。
然后读入一行一个字符串，表示打乱规则。

**你不需要在意打乱序号的具体实现。该实现与最终评测所用交互库不一定相同。**

接下来交互库将会调用一次 `mark`，一次 `locate`。注意交互库可能会打乱序号。

交互库可能向终端输出以下信息：

- `Invalid input.` 输入不合法。
- `Invalid call to visit. (ALICE CALLED VISIT)` 在 `mark` 中调用 `visit`。
- `Invalid call to visit. (INDEX ERROR)` 访问了不合法的点。
- `Invalid call to visit. (NOT CONNECTED)` 访问的点和当前所在的点没有直接的边相连。
- `Invalid call to visit. (TOO MANY VISITS)` 调用 `visit` 次数过多。
- `Invalid return value of mark.` `mark` 的返回值不合法。即返回的 `vector` 长度不为 $n$ 或者有小于 $0$ 或大于 $10^9$ 的数。
- `Not correct: current position is X` 最终并不在目标点，你应该在 $X$ 点（在第二张地图上）。
- `Correct: at most X tie(s) per room.` 到达目标点，且用领带最多的房间使用了 X 条领带。

最终评测时，只会返回正确与否的信息。

# 题解

## 作者：cyc001 (赞：0)

~~spj 的输出信息真的很有参考价值 /bx~~

### Solution

考虑 subtask2 怎么做。

我们显然可以钦定度数为 $2$ 的点为根，则 `mark` 时可以标记目标节点到根的所有点。

然后我们现在的问题是如何在询问的时候沿着被染色的点走并尽量少地访问未染色节点。

首先我们可以直接往根走，直到遇到第一个染色节点，不难发现这一步的额外步数是 $0$。

现在我们需要将当前节点沿着染色的路径往子树里走，不难想到重链剖分的轻重边切换次数是 $O(\log n)$ 次，则直接每次优先访问重儿子即可保证询问次数。

现在讨论 subtask3，我们假设这棵树的性质足够好，则可以把根节点设置为树的重心。

那么如果有两个重心怎么办，~~可以通过复杂的分类讨论区保证正确性并且让询问次数多出好几次过不去~~，其实只要在染色时钦定离目标更近的点为根，然后在询问的时候任选一个重心为根，如果跳到根都没被染色就去另外一个重心。

然后可能需要稍微卡一下询问次数 /kk

### Code

[QOJ Link](https://qoj.ac/submission/1147633)

---

## 作者：_maze (赞：0)

感受异域风情了这下。

题目实际上就是要求你对一棵树黑白染色，使得所有点都能仅根据当前颜色与当前点在树的位置作为提示走到一个目标点。而且你只能走最短路径 $+30$ 条边。

你看到这个 $+30$，题目要求走回头路也要算，所以只能走错 $15$ 次。这看起来就很 $\log$。

你说好，我知道重链剖分只要跳 $\log$ 次轻边，我用黑点代表走父亲，白点代表走儿子。每到一个点先走它的重儿子，如果重儿子是黑的就走另一个轻儿子。

看起来很对，于是你开写。染色很简单，但是染完色你发现编号变了，如果不把根确定下来，当前点连着走到的三个点全为黑色不就和瞎猜没区别了吗。

于是还得确定一个好根。

能只根据树的形态求出的点就那么几个，其中重心具有很好的性质：所有点到它路径都是最短的。于是大手一挥：就拿重心作根了。

然后就随便写了。你染色直接找到重心作根然后 $O(n)$ 染，然后询问按照上面的方式跳就行了。

最后一个要注意的点是你的最坏情况还要加上一次，因为根节点是可能有两个轻儿子的。你倒霉的话需要把他俩中错的那个也试出来。

代码就是树剖模板，不给代码。

---


# 「KDOI-06-S」签到题

## 题目背景

你正在追番，突然家长进来了，于是你假装在写一道数据结构题。



## 题目描述

定义一个长度为 $m$ 的数组 $v$ 是合法的，当且仅当经过若干次以下操作可以使 $v$ 中的所有元素相等：

* 选择四个整数 $a,b,c,d$（$1\leq a\leq b\leq m$，$1\leq c\leq d\leq m$）满足 $b-a+1=d-c+1$，且 $v_a\operatorname{~or~}v_{a+1}\operatorname{~or~}\cdots\operatorname{~or~}v_b=v_c\operatorname{~or~}v_{c+1}\operatorname{~or~}\cdots\operatorname{~or~}v_d$，其中 $\operatorname{or}$ 表示按位或运算。接下来，将区间 $[a,b]$ 的数**复制下来再覆盖**到区间 $[c,d]$。**注意：区间 $\bm{[a,b]}$ 和 $\bm{[c,d]}$ 可能会相交。**

给出一个长度为 $n$ 的序列 $a_1,a_2,\ldots,a_n$ 以及 $q$ 次询问，每次询问给定两个正整数 $l,r$，你需要回答区间 $[l,r]$ 内的最长合法子区间的长度。

## 说明/提示

**【样例解释 #1】**

对于第一组数据的第一个询问，最长的合法子区间为 $[1,7]$，以下是一种可能的操作序列：

1. 选择区间 $[1,4]$ 和 $[2,5]$，将区间 $[1,4]$ 中的数**先复制**下来，再覆盖到 $[2,5]$ 上，此时序列变为 $[0,0,4,2,6,6,6]$。

2. 选择区间 $[5,6]$ 和 $[3,4]$，此时序列变为 $[0,0,6,6,6,6,6]$。

3. 选择区间 $[4,7]$ 和 $[1,4]$，此时序列变为 $[6,6,6,6,6,6,6]$。

注意，操作**并不会**真正的修改原序列中的值。

对于第一组数据的第二个询问，最长的合法子区间为 $[2,2]$ 和 $[3,3]$。

**【样例 #2】**

见选手目录下的 `binary/binary2.in` 与 `binary/binary2.ans`。

这个样例满足测试点 $5\sim 8$ 的条件限制。

**【样例 #3】**

见选手目录下的 `binary/binary3.in` 与 `binary/binary3.ans`。

这个样例满足测试点 $25\sim 31$ 的条件限制。

**【样例 #4】**

见选手目录下的 `binary/binary4.in` 与 `binary/binary4.ans`。

这个样例满足测试点 $46\sim 50$ 的条件限制。

***

**【数据范围】**

对于所有数据保证：$1\le T\le 2\times 10^5$，$1\le n,q,\sum n,\sum q\le 2\times 10^6$，$0\le a_i < 2^{30}$。

| 测试点编号 | $\sum n\le$ | $\sum q\le$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $5$ | $5$ | 无 |
| $2\sim 4$ | $100$ | $100$ | 无 |
| $5\sim 8$ | $1000$ | $1000$ | 无 |
| $9\sim 14$ | $1000$ | $10^6$ | 无 |
| $15\sim 19$ | $6000$ | $10^6$ | 无 |
| $20\sim 24$ | $50000$ | $10$ | 无 |
| $25\sim 31$ | $10^5$ | $10^5$ | B |
| $32\sim 36$ | $2\times 10^5$ | $2\times 10^5$ | 无 |
| $37\sim 41$ | $5\times 10^5$ | $10^6$ | B |
| $42\sim 44$ | $5\times 10^5$ | $5\times 10^5$ | 无 |
| $45$ | $2\times 10^6$ | $2\times 10^6$ | A |
| $46\sim 50$ | $2\times 10^6$ | $2\times 10^6$ | 无 |

+ 特殊性质 A：保证序列 $a$ 中的每个数均在 $[0,2^{30})$ 之间均匀随机生成。
+ 特殊性质 B：保证对于任意 $1\le i\le n$，$a_i\le 3$。

***

**【提示】**

本题输入输出量较大，请使用适当的 I/O 方式。

**请注意常数因子对程序运行效率产生的影响。**

KDOI 出题组温馨提示：**多测不清空，爆零两行泪。**

## 样例 #1

### 输入

```
2 0
7 2
0 4 2 6 0 6 6
1 7
2 3
3 1
1 2 3
1 3```

### 输出

```
7
1
3```

# 题解

## 作者：i_am_not_feyn (赞：19)

个人认为 CSP 应该并不会考什么复杂的 DS，这道题的难度基本上都在实现上了。

首先观察一个序列合法的条件。

注意到操作并不会使得某一个一开始存在的二进制位消失，并且要求最后的序列全为一个数，那么显然这个数就是整个序列的或。

下文中令四元组 $(l1,r1,l2,r2)$ 表示一次操作。

令这个数为 $mx$，若序列中没有 $mx$ 则显然是非法的。假定有两个 $mx$ 在序列中的位置分别为 $i,i+1$，那么可以通过 $(i,i+1,i+1,i+2)$ 或者 $(i,i+1,i-1,i)$ 使得 $mx$ 向两边扩展，最终使得序列全为 $mx$。

若有一个 $mx$ 的位置为 $i$，且右边有一区间 $[i+1,r]$ 的或等于 $mx$，则可以通过 $(i,r-1,i+1,r)$ 使得 $i+1$ 的位置为 $mx$，转化为上述情况。区间在左边也是同理的。

故而一个序列是合法的当且仅当可以找到一个 $mx$ 和一个不包含这个 $mx$ 的或为 $mx$ 的区间。

对于原序列的每个位置 $i$ 作为某个区间的 $mx$ 时，这个区间 $[L_i,R_i]$ 的或应该为 $a_i$，$L_i$ $R_i$ 是容易求出的。若要使这个区间合法，那么可以求出 $l_i$ 表示最大的 $l$ 使得 $[l,i)$ 的或包含了 $a_i$，$r_i$ 同理。令当前询问的区间为 $[l',r']$，则有以下两种情况 $i$ 会做出 $\min(r',R_i)-\max(l',L_i)+1$ 的贡献。

1. $l_i\ge L_i,l_i\ge l'$
2. $r_i\le R_i,r_i\le r'$

只考虑 1 的情况，2 的话倒着再做一遍就是。接下来就是没有脑子的套路了。

显而易见的，将 $l_i<L_i$ 的 $i$ 踢出去不考虑，把 $l$ 后往前扫描线一下，每次扫到一个新的 $l$ 就将 $l_i=l$ 的 $i$ 加进线段树中。现在线段树中的节点均满足 1 的条件，只需要在 $i\in[l,r']$ 中找到最优解即可。

由于不好处理 $\max(l,L_i)$，考虑将所有的 $i$ 按照是否小于 $l$ 插入 AB 线段树中。由于 $l$ 是逐渐变小的，那么 A 是要支持删除的。

A 中元素的贡献是 $\min(r',R_i)-l'+1$，那么只用维护区间中 $i$ 的 $R$ 最大值即可，删除就是单点赋值为 0。

B 中元素的贡献是 $\min(r',R_i)-L_i+1$，由于不带修，则可以直接维护每个 $r'$ 的答案。在 $[i,R_i]$ 的区间插入 $-L_i+1$，在 $(R_i,n]$ 的区间插入 $R_i-L_i+1$，每次就是单点查询两种情况的最大值，标记永久化即可。

时间是 $O(n\log n)$ 的，由于这个解法没啥脑子基本上就是大力分讨，常数颇高，但是 7s 的时限还是稳过的。

code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=4e6+50,M=8e6+50,inf=1e9+7;

namespace IO {
//IO 由于是贺别人的所以不是很能放出来
} // IO
using namespace IO;

int T,Tid,n,q,a[N],m=30,Ans[N];

struct ask
{
	int l,r,id;
	
	friend bool operator<(ask a,ask b)
	{
		return a.l<b.l;
	}
}Q[N];

#define ls (x<<1)
#define rs (x<<1|1)
#define mid ((l+r)>>1)

class sukwants
{
	public:
		int mx[M],d,val,L,R,ans;
		
		void add(int x,int l,int r)
		{
			if(l==r)return void(mx[x]=val);
			if(d<=mid)add(ls,l,mid);
			else add(rs,mid+1,r);
			mx[x]=max(mx[ls],mx[rs]);
		}
		
		void find(int x,int l,int r)
		{
			if(L<=l&&R>=r)return void(ans=max(ans,mx[x]));
			if(L<=mid)find(ls,l,mid);
			if(R>mid)find(rs,mid+1,r);
		}
		
		void add(int a,int b){d=a,val=b;add(1,1,n);}
		int find(int l,int r){L=l,R=r;ans=0;find(1,1,n);return ans;}
}sgt;

class sukwats
{
	public:
		int val[M],w[M],L,R,d,ans;
		
		void Insert(int x,int l,int r)
		{
			if(L<=l&&R>=r)return void(val[x]=max(val[x],d));
			if(L<=mid)Insert(ls,l,mid);
			if(R>mid)Insert(rs,mid+1,r);
		}
		
		void Add(int x,int l,int r)
		{
			if(L<=l&&R>=r)return void(w[x]=max(w[x],d));
			if(L<=mid)Add(ls,l,mid);
			if(R>mid)Add(rs,mid+1,r);
		}
		
		void find(int x,int l,int r)
		{
			ans=max(ans,max(val[x],w[x]+d));
			if(l==r)return;
			return (d<=mid)?find(ls,l,mid):find(rs,mid+1,r);
		}
		
		void insert(int l,int r,int v){L=l,R=r,d=v;Insert(1,1,n);}
		void add(int l,int r,int v){L=l,R=r,d=v;Add(1,1,n);}
		int find(int x){d=x;ans=0;find(1,1,n);return ans;}
}sgc;
		
void dfs(int x,int l,int r)
{
	sgt.mx[x]=0;sgc.val[x]=sgc.w[x]=-inf;
	if(l!=r)dfs(ls,l,mid),dfs(rs,mid+1,r);
}

int L[N],R[N],rel[N],rer[N],fir[2][32],las[2][32];

class shabi_ds
{
	public:
		int a[N],L[N],R[N],re[N];
		vector<int>in[N],out[N];
		
		void clear()
		{
			for(int i=1;i<=n;i++)vector<int>().swap(in[i]),vector<int>().swap(out[i]);
		}
		
		void pre()
		{
			sort(Q+1,Q+1+q);dfs(1,1,n);clear();
			for(int i=1;i<=n;i++)if(re[i]>=L[i])in[re[i]].push_back(i),out[L[i]].push_back(i);
		}
		
		void solve()
		{
			pre();int pos=q;
			for(int i=n;i>=1;i--)
			{
				for(auto x:in[i])sgt.add(x,R[x]);
				for(auto x:out[i])
				{
					sgt.add(x,0),sgc.add(x,R[x],-L[x]+1),sgc.insert(R[x],n,R[x]-L[x]+1);
				}
				while(pos&&Q[pos].l==i)
				{
					int x=min(Q[pos].r,sgt.find(Q[pos].l,Q[pos].r)),y=sgc.find(Q[pos].r);
					Ans[Q[pos].id]=max(Ans[Q[pos].id],max(x-i+1,y)),pos--;
				}
			}
		}
}A,B;

void init()
{
	for(int i=1;i<=n;i++)L[i]=1,R[i]=n,rel[i]=rer[i]=i;
	for(int i=0;i<=m;i++)fir[1][i]=0,las[1][i]=n+1;
	for(int ty=0,i=1;i<=n;i++,ty^=1)for(int j=0;j<=m;j++)
	if((a[i]>>j)&1)rel[i]=min(rel[i],fir[ty^1][j]),fir[ty][j]=i;
	else fir[ty][j]=fir[ty^1][j],L[i]=max(L[i],fir[ty][j]+1);
	for(int ty=0,i=n;i>=1;i--,ty^=1)for(int j=0;j<=m;j++)
	if((a[i]>>j)&1)rer[i]=max(rer[i],las[ty^1][j]),las[ty][j]=i;
	else las[ty][j]=las[ty^1][j],R[i]=min(R[i],las[ty][j]-1);
	for(int i=1;i<=n;i++)
	{
		A.L[i]=L[i],A.R[i]=R[i],A.re[i]=rel[i];
		B.R[n-i+1]=n-L[i]+1,B.L[n-i+1]=n-R[i]+1,B.re[n-i+1]=n-rer[i]+1;
	}
}

void sol()
{
	read(n);read(q);
	for(int i=1;i<=n;i++)read(a[i]),A.a[i]=B.a[n-i+1]=a[i];
	for(int i=1;i<=q;i++)read(Q[i].l),read(Q[i].r),Q[i].id=i,Ans[i]=1;
	init();A.solve();
	for(int i=1;i<=q;i++)Q[i].l=n-Q[i].l+1,Q[i].r=n-Q[i].r+1,swap(Q[i].l,Q[i].r);
	B.solve();
	for(int i=1;i<=q;i++)write(Ans[i]);
}

main()
{
	read(T),read(Tid);
	while(T--)sol();
}
```

---

## 作者：EnofTaiPeople (赞：16)

### Part1 前言

CSP-S 前发题解 rp++！

当时被 T3 卡了太久没时间做 T4 了。

听别人说 T4 比 T3 更简单，或许是我策略失误？

不过这道题应该算是能够使用线段树大力维护的题。

似乎不是正解且代码较长，不过细节极少所以还是比较有价值。

### Part2 考场思路

考虑复制覆盖操作不会改变全体或和，于是整个区间最初所有数字的或和就等于初始所有数字的或和，但是最后要求所有数字相同，所以最后所有数字都会等于初始的区间或和。

因为长度为 $1$ 的区间一定合法，所以只考虑长度 $\ge2$ 的区间，不妨设等于或和的数字为 $1$，其余为 $0$。

我们需要让序列获得更多的 $1$，对于一个序列 $110$，我们可以操作一次 $[1,2],[2,3]$ 使其变为 $111$，由此类推得出只要两个相连的 $1$ 序列就合法。

对于序列 $10001$，可以操作一次 $[2,5],[1,4]$ 变为 $00011$，由此可见只要有两个 $1$，就一定合法。

考虑移动一个 $1$，形如 $010$，可以进行一次 $[1,2],[2,3]$ 操作，得到 $001$ 寻找不变量我们发现 $1$ 前后的或和不会增加。

假设 $1$ 某一边的或和等于 $1$，例如序列 $123$，我们可以做一次操作 $[2,3],[1,2]$ 得到 $133$，即获得了两个 $1$，于是可以判定其为合法。

于是猜测只有某一个 $1$ 前面或后面的或和等于 $1$ 才合法，发现可以过大样例！

于是我们得出了 $O(n^3)$ 的做法，也即我的考场得分 $28$ 分。

### Part3 基于单调性的小优化

容易发现一个区间 $[l,r]$ 如果存在一个或和等于自身的子区间合法，自己也一定合法，我们可以考虑每一个数字作为 $1$ 的贡献。

首先打一个对于或和的 ST 表，于是可以 $O(1)$ 查询区间的或和。

对于一个数 $a_x$ 二分找到最小的 $p$，最大的 $q$ 使得 $[p,x],[x,q]$ 的或和均为 $a_x$，再找到最大的 $p'$，最小的 $q'$ 使得 $[p',x),(x,q']$ 的或和等于 $a_x$，于是对于左端点在 $[p,p']$，右端点在 $[q',q]$ 之间的区间都是合法的。

这样子暴力维护就已经可以做到 $O(n^2+q)$ 了。

### Part4 扫描线线段树

这种问题的解决方法一般都会往几个方向发展，其中一个就是扫描线线段树。

具体地，我们扫右端点，对于 $r\in[q',q]$ 和 $r\in(q,n]$ 的分开考虑，具体地，前者的最优区间右端点为 $r$，后者为 $q$。

对于前者，我们可以在 $q'$ 处对 $[p,p']$ 区间加一，在 $q+1$ 处减一，然后求线段树上从 $l$ 开始第一个值不为 $0$ 的位置 $l'$，然后 $[l',r]$ 可以作为答案。

对于后者，我们可以在 $q$ 处将 $[p,p']$ 区间的最大右端点设为 $r$，这大致形如一个区间对一个一次函数取 $\max$，并且这个一次函数还形如 $y=-x+k$ 是单调的，所以可以轻松维护区间最值。

于是我们得到了本题的做法，时间 $O((n+q)\log n)$，空间 $O(n\log n+q)$，可以通过。

### Part5 后记

希望今年 CSP-S 能够通过所有自己能做出来的题目！

祝大家 CSP-S 2023 rp++！

AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e6+6,P=4.2e6+7,M=998244353;
using ll=long long;
using ul=unsigned long long;
int T,n,m,a[N],st[N][23],ans[N];
int gor(int l,int r){
    int k=__lg(r-l+1);
    return st[l+(1<<k)-1][k]|st[r][k];
}
struct dat{int l,r;};
vector<dat>ad[N],dl[N],qr[N];
void add(int l,int r,int p,int q){
    ad[p].push_back({l,r});
    dl[q].push_back({l,r});
}
#define ls x<<1
#define rs x<<1|1
namespace Zyf_SGT1{
    int tg[P],mx[P],mst,up;
    void build(int x,int l,int r){
        tg[x]=mx[x]=0;
        if(l<r){
            int md=l+r>>1;
            build(ls,l,md);
            build(rs,md+1,r);
        }
    }
    void atg(int x,int d){tg[x]+=d,mx[x]+=d;}
    void pd(int x){
        if(tg[x]){
            atg(ls,tg[x]);
            atg(rs,tg[x]),tg[x]=0;
        }
    }
    void cg(int x,int l,int r,int L,int R,int d){
        if(l>=L&&r<=R)atg(x,d);
        else{
            int md=l+r>>1;pd(x);
            if(L<=md)cg(ls,l,md,L,R,d);
            if(md<R)cg(rs,md+1,r,L,R,d);
            mx[x]=max(mx[ls],mx[rs]);
        }
    }
    void ask(int x,int l,int r){
        if(mx[x]<=0)return;
        if(l==r){mst=l;return;}
        int md=l+r>>1;pd(x);
        if(up<=md){
            ask(ls,l,md);
            if(mst)return;
        }ask(rs,md+1,r);
    }
    int qry(int L){
        mst=0,up=L,ask(1,1,n);
        return mst?mst:1e9;
    }
}
namespace Zyf_SGT2{
    int tg[P],mx[P],lc[P];
    void build(int x,int l,int r){
        tg[x]=0,mx[x]=1,lc[x]=l;
        if(l<r){
            int md=l+r>>1;
            build(ls,l,md);
            build(rs,md+1,r);
        }
    }
    void atg(int x,int d){
        mx[x]=max(mx[x],d-lc[x]+1);
        tg[x]=max(tg[x],d);
    }
    void pd(int x){
        if(tg[x]){
            atg(ls,tg[x]);
            atg(rs,tg[x]),tg[x]=0;
        }
    }
    void cg(int x,int l,int r,int L,int R,int d){
        if(l>=L&&r<=R)atg(x,d);
        else{
            int md=l+r>>1;pd(x);
            if(L<=md)cg(ls,l,md,L,R,d);
            if(md<R)cg(rs,md+1,r,L,R,d);
            mx[x]=max(mx[ls],mx[rs]);
        }
    }
    int res;
    void ask(int x,int l,int r,int L){
        if(l>=L)res=max(res,mx[x]);
        else{
            int md=l+r>>1;pd(x);
            if(L<=md)ask(ls,l,md,L),res=max(res,mx[rs]);
            else ask(rs,md+1,r,L);
        }
    }
    int qry(int l){
        res=0,ask(1,1,n,l);
        return res;
    }
}
int main(){
    ios::sync_with_stdio(false);
    int i,j,k,l,r,md,x,y,z,p,q;
    for(cin>>T>>k;T--;){
        cin>>n>>m;
        for(r=1;r<=n;++r){
            cin>>a[r];
            for(k=0;k<22;++k)st[r][k]=0;
            st[r][0]=a[r];
            for(k=1;r>>k;++k)
                st[r][k]=st[r-(1<<k-1)][k-1]|st[r][k-1];
        }
        for(x=1;x<=n;++x){
            l=1,r=x-1,p=x;
            while(l<=r){
                md=l+r>>1;
                if(gor(md,x)==a[x])p=md,r=md-1;
                else l=md+1;
            }
            l=x+1,r=n,q=x;
            while(l<=r){
                md=l+r>>1;
                if(gor(x,md)==a[x])q=md,l=md+1;
                else r=md-1;
            }
            if(!a[x]){
                add(p,x,x,q);
                continue;
            }z=q+1,l=x+1,r=q;
            while(l<=r){
                md=l+r>>1;
                if(gor(x+1,md)==a[x])z=md,r=md-1;
                else l=md+1;
            }if(z<=q)add(p,x,z,q);
            z=p-1,l=p,r=x-1;
            while(l<=r){
                md=l+r>>1;
                if(gor(md,x-1)==a[x])z=md,l=md+1;
                else r=md-1;
            }if(p<=z)add(p,z,x,q);
        }
        for(i=1;i<=m;++i){
            cin>>l>>r;
            qr[r].push_back({l,i});
        }
        Zyf_SGT1::build(1,1,n);
        Zyf_SGT2::build(1,1,n);
        for(r=1;r<=n;++r){
            for(dat at:ad[r])
                Zyf_SGT1::cg(1,1,n,at.l,at.r,1);
            for(dat at:qr[r]){
                l=Zyf_SGT1::qry(at.l);
                if(l>r)ans[at.r]=1;
                else ans[at.r]=r-l+1;
                ans[at.r]=max(ans[at.r],Zyf_SGT2::qry(at.l));
            }
            for(dat at:dl[r]){
                Zyf_SGT1::cg(1,1,n,at.l,at.r,-1);
                Zyf_SGT2::cg(1,1,n,at.l,at.r,r);
            }
        }
        for(i=1;i<=m;++i)
            printf("%d\n",ans[i]);
        for(x=1;x<=n;++x)ad[x].clear(),dl[x].clear(),qr[x].clear();
    }
    return 0;
}
```

---

## 作者：Feyn (赞：12)

需要稍微发现几个性质。首先最后区间内的数要保持相同，最后剩下来的数就只可能是原来元素的异或和；而观察整个操作过程我们无法创造原集合中不存在的数，也就是说一个序列合法的必要条件是存在一个数恰好就是所有元素的异或和，考虑从这个元素的角度进行思考。

显然任意包含该元素的区间，如果可以缩成一个数那么一定是这个元素。那么我们只需要找到另一个区间的值也等于这个元素，发现等价于贴着这个元素存在一个前缀或者后缀的或等于这个元素，再思考一下发现这是充要的。

最后是如何贡献，枚举左端点，显然只会有 $\log$ 个本质不同（也就是区间或不同）的区间（或者说当前枚举后缀的前缀），二分出这些区间的端点辅以 ST 表查询区间或之后找到基准元素然后二分出可能的最紧的右端点，于是每个区间真正的贡献是一系列左端点固定并且右端点在一个区间内的区间，这是容易维护的，大概就是询问时维护完整区间和当前右端点下合法左端点的集合就可以了。

复杂度带了两只 $\log$ 而且常数巨大，但是它确实跑得过，虽然跑了四十秒，非常抽象。

```cpp
#include<bits/stdc++.h>
// #define feyn
using namespace std;
const int N=2000010;
namespace IO{
    #define inLen (1<<20)
    #define flush() fwrite(Out,1,iter-Out,stdout),iter=Out
    char ibuf[inLen],*iS=ibuf+inLen,*iT=ibuf+inLen;
    #define gc() ((iS==iT)?(iT=(iS=ibuf)+fread(ibuf,1,inLen,stdin),iS==iT?EOF:*iS++):*iS++)
    template<class T>inline void read(T &x){
        x=0;int f=0;char ch=gc();
        for(;!isdigit(ch);f|=ch=='-',ch=gc());
        for(;isdigit(ch);x=(x<<1)+(x<<3)+(ch^48),ch=gc());
        x=(f==1?~x+1:x);
    }
    char Out[inLen],*iter=Out;
    template<class T>inline void write(T x,char ch=' ') {
        T l,c[35];
        if(x<0)*iter++='-',x=~x+1;
        for(l=0;!l||x;c[l]=x%10,l++,x/=10);
        for(;l;--l,*iter++=c[l]+'0');*iter++=ch;
        flush();
    }
}
using namespace IO;

namespace ST{
    int lg[N],st[N][23];
    void build(int m,int a[]){
        for(int i=2;i<=m;i++)lg[i]=lg[i>>1]+1;
        for(int i=1;i<=m;i++)st[i][0]=a[i];
        for(int t=1;t<=lg[m];t++){
            for(int i=1;i+(1<<t)-1<=m;i++){
                st[i][t]=st[i][t-1]|st[i+(1<<(t-1))][t-1];
            }
        }
    }
    inline int work(int l,int r){
        int llg=lg[r-l+1];
        return st[l][llg]|st[r-(1<<llg)+1][llg];
    }
}

struct query{int l,r,id;}qu[N];
inline bool cmp(query s1,query s2){return s1.r<s2.r;}
int rec[N];

int m,n,num,qNum,a[N],b[N];
vector<int>p[N],insL[N],delL[N];

#define lowbit (wh&-wh)
int tt[N];
void init(){
    for(int i=1;i<=m;i++)tt[i]=0;
}
int work(int wh){
    int an=1;
    for(;wh<=m;wh+=lowbit)an=max(an,tt[wh]);
    return an;
}
void change(int wh,int val){
    for(;wh;wh-=lowbit)tt[wh]=max(tt[wh],val);
}
#undef lowbit

void solve(){
    read(m);read(qNum);
    for(int i=1;i<=m;i++)read(a[i]),b[i]=a[i];
    sort(b+1,b+m+1);init();
    num=unique(b+1,b+m+1)-b-1;
    for(int i=1;i<=num;i++)p[i].clear();
    for(int i=1;i<=m;i++){
        p[lower_bound(b+1,b+num+1,a[i])-b].push_back(i);
    }
    ST::build(m,a);
    for(int i=1;i<=qNum;i++){
        qu[i].id=i;
        read(qu[i].l);read(qu[i].r);
    }
    for(int i=1;i<=m+1;i++)insL[i].clear(),delL[i].clear();
    sort(qu+1,qu+qNum+1,cmp);
    for(int al=m-1;al;al--){
        int pl[35]={al},cnt=0,ar=al;
        while(ar<m){
            int l=ar+1,r=m+1,mid;
            while(l<r){
                mid=(l+r)>>1;
                if(ST::work(al,ar)==ST::work(al,mid))l=mid+1;
                else r=mid;
            }
            pl[++cnt]=ar=l;
        }
        for(int i=0;i<cnt;i++){
            int nl=pl[i],nr=pl[i+1]-1;
            int nowData=ST::work(al,nr);
            int nowPl=lower_bound(b+1,b+num+1,nowData)-b;
            if(nowPl>num||b[nowPl]!=nowData||al>p[nowPl].back())continue;
            // continue;
            int pp=lower_bound(p[nowPl].begin(),p[nowPl].end(),al)-p[nowPl].begin();
            if(p[nowPl][pp]>nr)continue;pp=p[nowPl][pp];
            if(pp>al&&ST::work(al,pp-1)==nowData){
                insL[pp].push_back(al);
                delL[nr+1].push_back(al);
                continue;
            }
            int l=pp+1,r=nr+1,mid;
            while(l<r){
                mid=(l+r)>>1;
                if(ST::work(pp+1,mid)==nowData)r=mid;
                else l=mid+1;
            }
            if(l>nr)continue;
            insL[l].push_back(al);
            delL[nr+1].push_back(al);
        }
    }
    set<int>recL;int np=1;
    for(int i=1;i<=qNum;i++){
        while(np<=qu[i].r){
            for(int pp:insL[np])recL.insert(pp);
            for(int pp:delL[np])recL.erase(pp),change(pp,np-pp);
            np++;
        }
        rec[qu[i].id]=1;
        auto it=recL.lower_bound(qu[i].l);
        if(it!=recL.end()){
            rec[qu[i].id]=max(rec[qu[i].id],qu[i].r-(*it)+1);
        }
        rec[qu[i].id]=max(rec[qu[i].id],work(qu[i].l));
    }
    for(int i=1;i<=qNum;i++){
        write(rec[i],'\n');
    }
}

signed main(){
	
    #ifdef feyn
    freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);
    #endif

    int test,inin;read(test);read(inin);
    while(test--)solve();

    #ifdef feyn
    printf("time %f\n",(double)clock()/CLOCKS_PER_SEC);
    #endif

    return 0;
}
```

---

## 作者：Demeanor_Roy (赞：3)

- [原题链接](https://www.luogu.com.cn/problem/P9747)

------------

解法什么的不重要，主要想展现一下我的时空双最劣解。

事实上，这题我卡了四发空间、三发时间才通过，最后以 `1.06min 879MB` 喜提最劣解。（

我们不妨思考一个区间合法的一些充分/必要条件，并借此组合得到充要条件。

首先不难发现，当我们进行一次操作后，整个区间的或不变，这意味着最终局面每个数都会变成最初局面所有数的或。且由于操作不会产生新的数，故**区间合法的一个必要条件是区间中存在所有数的或**。

令所有数的或为 $x$。考虑 $x$ 出现两次及以上的情况。若其中两个 $x$ 的位置是 $i,j(i<j)$，若 $i+1=j$，不妨进行操作 $(i-1,i,i,j)/(i,j,j,j+1)$ 依次扩展至区间全为 $x$；否则进行操作 $(i,j-1,i+1,j)$ 使 $i+1=j$，之后重复上述操作。故**区间合法的一个充分条件是区间中存在两个及以上所有数的或**。

此时考虑只有一个所有数的或的情况，不难发现若存在区间 $[l,r]$ 使得其中所有数的或为 $x$，且区间不包含原来 $x$ 的位置，则可以转化至上述情况。否则，考虑到操作若包含原来 $x$ 的位置不会使 $x$ 个数增加，不包含不会产生新的有用区间，故区间不合法。


所有，我们得出**区间合法的充要条件为区间存在所有数的或且存在一个不包含该位置的子区间或为区间所有数的或。**

得出结论后我们考虑如何求这样一个东西。考虑经典结论，某端点固定的区间的或值为 $\log v$ 级别个。把相同的合在一起，把这 $n \log v$ 个形如 $(l,r,i,v)$ 表示左端点在 $[l,r]$ 右端点在 $i$ 的区间或值为 $v$ 拎出来。

对于某个 $(l,r,i,v)$，分情况讨论：

- $a_r = v$：此时找到最大的 $x$，满足 $[x,r-1]$ 存在子区间或值为 $v$,，接着便是对询问的一个区间赋值。

- $a_r \ne v$：此时找到最大的 $x$，满足 $a_x=v$，由于区间 $[r,i]$ 或为 $v$，同理一个区间赋值操作即可。

上述所需要的 $x$ 均可以在求四元组时，指针加桶求得。 

由于我不想写线段树，于是将对询问的赋值拆成两部分，从左往右扫时用 `set` 赋值一次，再倒过来 `BIT` 赋值一次即可。时间复杂度 $O(n \log n \log v)$。

接下来便是喜提最裂解的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=2e6+10;
int T,id,n,m,len,top,v[N],w[N],stk[N];
int C[N],lg[N],fi[N],pre[N],ans[N],st[N][22];
struct Qr
{
	int l,id;
	bool operator<(const Qr o)const{return l==o.l?id<o.id:l<o.l;}
};
struct node{int r,fi;};
set<Qr> s;
vector<Qr> q[N];
vector<int> pos[N];
vector<node> vec[N];
inline int read()
{
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9') x=getchar();
	while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
	return x;
}
inline void out(int x)
{
	top=0;
	while(x) stk[++top]=x%10,x/=10;
	for(int i=top;i>=1;i--) putchar(stk[i]+'0');putchar('\n');	
} 
inline int find(int x){return lower_bound(v+1,v+len+1,x)-v;}
inline void add(int x,int y){for(;x;x-=x&-x) C[x]=max(C[x],y);}
inline int query(int x){int res=0;for(;x<=n;x+=x&-x) res=max(res,C[x]);return res;} 
inline int query(int l,int r){return st[l][lg[r-l+1]]|st[r-(1<<lg[r-l+1])+1][lg[r-l+1]];}
inline int Get(int i,int lim)
{
	if(pos[i].empty()||pos[i][0]>lim) return 0;
	int l=0,r=pos[i].size()-1;
	while(l<r)
	{
		int mid=(l+r+1)>>1;
		if(pos[i][mid]<=lim) l=mid;else r=mid-1;
	}
	return pos[i][l];
}
inline void update(int l,int r,int val)
{
	Qr h={l,0},t={r+1,0};
	auto it=s.lower_bound(h),lim=it;
	for(;it!=s.end()&&*it<t;++it) ans[it->id]=max(ans[it->id],val-it->l+1);
	if(it!=lim)
	{
		--it;
		while(it!=lim) s.erase(it--);
		s.erase(it);
	}
}
inline void solve()
{
	n=read(),m=read();
	for(int i=2;i<=n;i++) lg[i]=lg[i>>1]+1;
	for(int i=1;i<=n;i++) v[i]=st[i][0]=read();
	for(int j=1;j<=lg[n];j++)
		for(int i=1;i+(1<<j)-1<=n;i++)
			st[i][j]=st[i][j-1]|st[i+(1<<(j-1))][j-1];
	sort(v+1,v+n+1);
	len=unique(v+1,v+n+1)-v-1;
	for(int i=1;i<=n;i++) fi[i]=0,pos[i].clear(),vec[i].clear(),w[i]=find(st[i][0]);
	for(int i=1;i<=n;i++)
	{
		int ar=i,now=st[i][0];
		while(ar)
		{
			int l=1,r=ar;
			while(l<r)
			{
				int mid=(l+r)>>1;
				if(query(mid,i)==now) r=mid;
				else l=mid+1;
			}
			vec[i].emplace_back((node){ar,0});
			ar=l-1;if(l!=1) now=query(ar,i);
		}		
		pos[w[i]].emplace_back(i);
	}
	for(int i=1;i<=n;i++)
	{
		pre[i]=fi[w[i]];
		for(int j=0;j<(int)vec[i].size();j++)
		{
			int val=query(vec[i][j].r,i),z=(val==st[vec[i][j].r][0]?w[vec[i][j].r]:find(val));
			if(v[z]==val) 
			{
				fi[z]=max(fi[z],vec[i][j].r);
				vec[i][j].fi=Get(z,vec[i][j].r);
			}
		}
	}
	for(int i=1;i<=n+1;i++) C[i]=0,q[i].clear();
	for(int i=1;i<=m;i++) 
	{
		int l,r;		
		l=read(),r=read();
		ans[i]=1;q[r].emplace_back((Qr){l,i});
	}	
	s.clear();
	for(int i=n;i>=1;i--)
	{
		for(auto x:q[i]) s.insert(x);
		for(int j=0;j<(int)vec[i].size();j++)
		{	
			int l=(j==(int)vec[i].size()-1?1:vec[i][j+1].r+1);
			if(l==i) continue;
			int val=query(vec[i][j].r,i);
			if(st[vec[i][j].r][0]==val&&pre[vec[i][j].r]>=l) update(l,pre[vec[i][j].r],i); 
			else if(st[vec[i][j].r][0]!=val&&vec[i][j].fi>=l) update(l,vec[i][j].fi,i);
		}		
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<(int)vec[i].size();j++)
		{	
			int l=(j==(int)vec[i].size()-1?1:vec[i][j+1].r+1);
			if(l==1||l==i) continue;
			int val=query(vec[i][j].r,i);
			if(st[vec[i][j].r][0]==val&&pre[vec[i][j].r]>=l) add(l-1,i-l+1);
			else if(st[vec[i][j].r][0]!=val&&vec[i][j].fi>=l) add(l-1,i-l+1);
		}
		for(auto x:q[i]) ans[x.id]=max(ans[x.id],query(x.l)); 
	}
	for(int i=1;i<=m;i++) out(ans[i]);
}
int main()
{
	T=read();id=read();
	while(T--) solve();
	return 0;
}
```




---

## 作者：honglan0301 (赞：3)

做法来自 @goodier，让我们一起膜拜他。

## 题目分析

1. 判定合法区间：

	经过猜测后给出结论：记 $a_{pos}=\max_{i=l}^r a_i$，则序列 $a[1\dotsm n]$ 合法当且仅当 ① $a_{pos}=\text{or}_{i=1}^r a_i$ 且 ② $a_{pos}\in \{\text{or}_{i=1}^{pos-1}a_i,\text{or}_{i=pos+1}^n a_i\}$。证明如下：
    
    必要性①：易知单次操作不改变全局 $\text{or}$，于是最后必然每个数都与其相等，这要求 $a_{pos}=\text{or}_{i=1}^r a_i$。
    
    必要性②：考虑反证（对于不满足第二个性质的序列，我们尝试证明无论如何操作，其都不会满足该性质）。假如 $a_{pos}\not=\text{or}_{i=1}^{pos-1}a_i$ 且 $a_{pos}\not=\text{or}_{i=pos+1}^n a_i$，则操作区间 $[a,b],[c,d]$ 要么均包含 $pos$，要么均不包含 $pos$。后者显然不能使序列具有第二个性质，而前者会将原有的 $a_{pos}$ 覆盖成其它数，对于新的 $a'_{pos'}=a_{pos}$，可知 $\text{or}_{i=1}^{pos'-1}a'_i\leq \text{or}_{i=1}^{pos-1}a_i$ 且 $\text{or}_{i=pos'+1}^{n}a'_i\leq \text{or}_{i=pos+1}^{n}a_i$，同样不改变性质——故性质 ② 也是序列合法的必要条件。
    
    充分性：显然可以用 $a_{pos}$ 逐渐覆盖整个序列，构造操作序列不难，故略过。
    
2. 找出所有合法区间：

	首先考虑平凡解，即所有长为 $1$ 的区间均合法。
    
   对于长度 $>1$ 的区间，我们考虑枚举区间最大值（区间或）。对于每个 $i\in [1,n]$，其既要作为最大值，又要作为区间或，故尝试二分边界。
   
   我们可以二分求出 $la_i$ 表示满足 $\text{or}_{p=j}^{i}\leq a_i$ 的最小数 $j$，$ra_i$ 表示满足 $\text{or}_{p=j}^{i-1}\geq a_i$ 的最大数 $j$，$rb_i$ 表示满足 $\text{or}_{p=i}^{j}\leq a_i$ 的最大数 $j$，$lb_i$ 表示满足 $\text{or}_{p=i+1}^{j}\geq a_i$ 的最小数 $j$。
   
   此时容易发现，一个区间 $[l,r]$ 合法当且仅当 $la_i\leq l\leq r\leq rb_i$（性质①）且 $la_i\leq l\leq ra_i\wedge lb_i\leq r\leq rb_i$ （性质②）。将后者的限制拆开即可得到简洁的表达方式：区间 $[l,r]$ 合法当且仅当 $la_i\leq l\leq ra_i\leq i\leq r\leq rb_i$ 或 $la_i\leq l\leq i\leq lb_i\leq r\leq rb_i$。
   
3. 处理询问：

	由第二部分的说明可知，我们只需处理如下问题：
    
   “共有 $2n$ 个条件，每个条件形如‘左端点在 $[l_{1i},r_{1i}]$，且右端点在 $[l_{2i},r_{2i}]$ 的区间合法’，多次询问 $[l,r]$ 的子区间内最长合法序列的长度”。
   
   这种询问考虑离线下来对 $l_{1i},l,r_{1i}$ 以及 $l_{2i},r,r_{2i}$ 的位置关系分讨，共有以下四种情况：
   
   (1) $l_{1i}\leq l\leq r_{1i}$ 且 $l_{2i}\leq r\leq r_{2i}$。
   
   此情况答案为询问区间长度，故只需对每次询问求存在性。按照左端点从小到大排序作扫描线，碰到 $l_{1i}$ 时令 $[l_{2i},r_{2i}]$ 区间加一，碰到 $r_{1i}+1$ 时令 $[l_{2i},r_{2i}]$ 区间减一，碰到询问时对 $r$ 单点查，若不为 $0$ 则更新答案为询问区间长度即可。
   
   需要用到：区间加 单点查 线段树。
   
   (2) $l\leq l_{li}$ 且 $r_{2i}\leq r$。
   
   此情况答案为 $\max \{r_{2i}-l_{1i}+1\}$。同样考虑扫描线处理，对右端点从小到大排序，碰到 $r_{2i}$ 时令 $l_{1i}$ 处对 $r_{2i}-l_{1i}+1$ 取 $\max$，碰到询问时求出 $[l,r]$ 的区间 $\max$ 更新答案即可。
   
   需要用到 单点修 区间求 $\max$ 线段树。
   
   (3) $l_{1i}\leq l\leq r_{1i}$ 且 $r_{2i}\leq r$。
   
   此情况答案为 $\max \{r_{2i}\}-l+1$。继续扫描线，对左端点从小到大排序，碰到 $l_{1i}$ 时对 $r_{2i}$ 单点加一，碰到 $r_{1i}+1$ 时对 $r_{2i}$ 单点减一，碰到询问时求出区间 $[1,r]$ 内最靠右的非零位置 $opt$ 并用 $opt-l+1$ 更新答案即可。
   
   需要在支持 单点修 区间取 $\min$ 的线段树上二分。
   
   (4) $l\leq l_{1i}$ 且 $l_{2i}\leq r\leq r_{2i}$。
   
   与情况 (3) 类似，同样方法处理即可。
   
4. 最终结果：

	视 $n,q$ 同级，则以上每一步时间复杂度均为 $O(n\log n)$，注意常数应当能够通过本题。
    
## 代码

代码如下。为了方便调试，有些函数实际上很多余。

```cpp
/*
  author: honglan0301
  Sexy_goodier _ xiaoqing
 */
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>
#include <vector>
#include <cmath>
using namespace std;

namespace Fastio{/*快读板子*/}using namespace Fastio;
#define cin Fastio::cin
#define cout Fastio::cout
#define endl Fastio::endl

#define mp make_pair
#define pb push_back
#define fi first
#define se second
#define mod 998244353

int T,id,n,q,a[2000005],st[23][2000005],lg[2000005];
int l1[2000005],r1[2000005],l2[2000005],r2[2000005];
int la[4000005],ra[4000005],lb[4000005],rb[4000005],cntq;
int l[2000005],r[2000005],ans[2000005];

void init()
{
	for(int i=1;i<=n;i++) st[0][i]=a[i];
	for(int i=2;i<=n;i++) lg[i]=lg[i>>1]+1;
	for(int i=1;i<=lg[n];i++) for(int j=1;j+(1<<i)-1<=n;j++) st[i][j]=st[i-1][j]|st[i-1][j+(1<<i-1)];
}
int ask(int l,int r)
{
	if(l>r) return -1;
	int dd=lg[r-l+1]; return st[dd][l]|st[dd][r-(1<<dd)+1];
}

struct tree
{
	int num,tagadd;
}tree[8000005];

#define ls(x) (x<<1)
#define rs(x) ((x<<1)|1)
#define n(x) tree[x].num
#define tg(x) tree[x].tagadd
#define md(x,y) ((x+y)>>1)
#define push_up1(x) n(x)=max(n(ls(x)),n(rs(x)))
#define push_up2(x) n(x)=max(n(ls(x)),n(rs(x)))
#define push_up3(x) n(x)=max(n(ls(x)),n(rs(x)))
#define push_up4(x) n(x)=max(n(ls(x)),n(rs(x)))
#define cz1(k,p) n(p)+=k,tg(p)+=k
#define push_down1(p) cz1(tg(p),ls(p)),cz1(tg(p),rs(p)),tg(p)=0

void build1(int l,int r,int p)
{
	tg(p)=0; if(l==r) return n(p)=0,void(); int mid=md(l,r);
	build1(l,mid,ls(p)); build1(mid+1,r,rs(p)); push_up1(p);
}
void cza(int l,int r,int x,int y,int k,int p)
{
	if(l>=x&&r<=y) return cz1(k,p),void(); int mid=md(l,r); push_down1(p);
	if(mid>=x) cza(l,mid,x,y,k,ls(p)); if(mid<y) cza(mid+1,r,x,y,k,rs(p)); push_up1(p);
}
int ask1(int l,int r,int x,int p)
{
	if(l==r) return n(p); int mid=md(l,r); push_down1(p);
	if(mid>=x) return ask1(l,mid,x,ls(p)); else return ask1(mid+1,r,x,rs(p));
}

void build2(int l,int r,int p)
{
	n(p)=0; if(l==r) return void(); int mid=md(l,r);
	build2(l,mid,ls(p)); build2(mid+1,r,rs(p)); push_up2(p);
}
void czmx(int l,int r,int x,int k,int p)
{
	if(l==r) return n(p)=max(n(p),k),void(); int mid=md(l,r);
	if(mid>=x) czmx(l,mid,x,k,ls(p)); else czmx(mid+1,r,x,k,rs(p)); push_up2(p);
}
int ask2(int l,int r,int x,int y,int p)
{
	if(l>=x&&r<=y) return n(p); int mid=md(l,r),na=0;
	if(mid>=x) na=max(na,ask2(l,mid,x,y,ls(p))); if(mid<y) na=max(na,ask2(mid+1,r,x,y,rs(p))); return na;
}

void build3(int l,int r,int p)
{
	if(l==r) return n(p)=0,void(); int mid=md(l,r);
	build3(l,mid,ls(p)); build3(mid+1,r,rs(p)); push_up3(p);
}
void czc(int l,int r,int x,int k,int p)
{
	if(l==r) return n(p)+=k,void(); int mid=md(l,r);
	if(mid>=x) czc(l,mid,x,k,ls(p)); else czc(mid+1,r,x,k,rs(p)); push_up3(p);
}
int askfc(int l,int r,int p)
{
    if(l==r) return l; int mid=md(l,r); return n(rs(p))?askfc(mid+1,r,rs(p)):askfc(l,mid,ls(p));
}
int askc(int l,int r,int x,int y,int p)
{
    if(!n(p)) return 0; if(l>=x&&r<=y) return askfc(l,r,p); int mid=md(l,r);
    int kk=askc(mid+1,r,x,y,rs(p)); return kk?kk:askc(l,mid,x,y,ls(p));
}

void build4(int l,int r,int p)
{
	if(l==r) return n(p)=0,void(); int mid=md(l,r);
	build4(l,mid,ls(p)); build4(mid+1,r,rs(p)); push_up4(p);
}
void czd(int l,int r,int x,int k,int p)
{
	if(l==r) return n(p)+=k,void(); int mid=md(l,r);
	if(mid>=x) czd(l,mid,x,k,ls(p)); else czd(mid+1,r,x,k,rs(p)); push_up4(p);
}
int askfd(int l,int r,int p)
{
    if(l==r) return l; int mid=md(l,r); return n(ls(p))?askfd(l,mid,ls(p)):askfd(mid+1,r,rs(p));
}
int askd(int l,int r,int x,int y,int p)
{
    if(!n(p)) return 0; if(l>=x&&r<=y) return askfd(l,r,p); int mid=md(l,r);
    int kk=askd(l,mid,x,y,ls(p)); return kk?kk:askd(mid+1,r,x,y,rs(p));
}

vector <pair<pair<int,int>,int>> cz[2000005],que[2000005];

void solve1()
{
	for(int i=1;i<=n;i++) cz[i].clear(),que[i].clear();
	for(int i=1;i<=cntq;i++) cz[la[i]].pb(mp(mp(lb[i],rb[i]),1)),cz[ra[i]+1].pb(mp(mp(lb[i],rb[i]),-1));
	for(int i=1;i<=q;i++) que[l[i]].pb(mp(mp(r[i],r[i]),i));
	build1(1,n,1);
	for(int i=1;i<=n;i++)
	{
		for(auto j:cz[i]) cza(1,n,j.fi.fi,j.fi.se,j.se,1);
		for(auto j:que[i]) if(ask1(1,n,j.fi.fi,1)) ans[j.se]=r[j.se]-l[j.se]+1;
	}
}
void solve3()
{
	build3(1,n,1);
	for(int i=1;i<=n;i++)
	{
		for(auto j:cz[i]) czc(1,n,j.fi.se,j.se,1);
		for(auto j:que[i])
        {
            if(ans[j.se]==r[j.se]-l[j.se]+1) continue;
            int kk=askc(1,n,1,j.fi.fi,1); ans[j.se]=max(ans[j.se],kk-l[j.se]+1);
        }
	}
}

void solve2()
{
	for(int i=1;i<=n;i++) cz[i].clear(),que[i].clear();
	for(int i=1;i<=cntq;i++) cz[rb[i]].pb(mp(mp(la[i],la[i]),rb[i]-la[i]+1));
	for(int i=1;i<=q;i++) if(ans[i]!=r[i]-l[i]+1) que[r[i]].pb(mp(mp(l[i],r[i]),i));
	build2(1,n,1);
	for(int i=1;i<=n;i++)
	{
		for(auto j:cz[i]) czmx(1,n,j.fi.fi,j.se,1);
		for(auto j:que[i]) ans[j.se]=max(ans[j.se],ask2(1,n,j.fi.fi,j.fi.se,1));
	}
}
void solve4()
{
	for(int i=1;i<=cntq;i++) cz[lb[i]-1].pb(mp(mp(la[i],la[i]),-1));
	build4(1,n,1);
	for(int i=n;i>=1;i--)
	{
		for(auto j:cz[i]) czd(1,n,j.fi.se,(j.se>0)?1:-1,1);
		for(auto j:que[i])
        {
            int kk=askd(1,n,j.fi.fi,n,1); if(kk) ans[j.se]=max(ans[j.se],r[j.se]-kk+1);
        }
	}
}

signed main()
{
	//freopen("binary4.in","r",stdin);
	//freopen("binary4.out","w",stdout);
	cin>>T>>id;
	while(T--)
	{
		cin>>n>>q; for(int i=1;i<=n;i++) cin>>a[i]; init(); cntq=0;
		for(int i=1;i<=n;i++)
		{
			int l=1,r=i-1; while(l<=r) {int mid=(l+r)>>1; if((ask(mid,i-1)|a[i])==a[i]) r=mid-1; else l=mid+1;} l1[i]=l;
			l=l1[i],r=i-1; while(l<=r) {int mid=(l+r)>>1; if(ask(mid,i-1)!=a[i]) r=mid-1; else l=mid+1;} r1[i]=r;
			l=i+1,r=n; while(l<=r) {int mid=(l+r)>>1; if((ask(i+1,mid)|a[i])==a[i]) l=mid+1; else r=mid-1;} r2[i]=r;
			l=i+1,r=r2[i]; while(l<=r) {int mid=(l+r)>>1; if(ask(i+1,mid)!=a[i]) l=mid+1; else r=mid-1;} l2[i]=l;
			if(l1[i]<=r1[i])
			{
				cntq++; la[cntq]=l1[i]; ra[cntq]=r1[i]; lb[cntq]=i; rb[cntq]=r2[i];
			}
			if(l2[i]<=r2[i])
			{
				cntq++; la[cntq]=l1[i]; ra[cntq]=i; lb[cntq]=l2[i]; rb[cntq]=r2[i];
			}
		}
		for(int i=1;i<=q;i++) cin>>l[i]>>r[i]; memset(ans,0,sizeof(ans));
		solve1();
		solve3();
		solve2();
		solve4();
		for(int i=1;i<=q;i++)
		{
			ans[i]=max(ans[i],1); cout<<ans[i]<<endl;
		}
	}
}
```


---

## 作者：Vidoliga (赞：3)

好题。

首先原序列是**好的**条件是难以快速判断的，那么首先该做的第一件事就是序列是**好的**的**充要**条件。

直接找充要条件显然不现实，考虑手玩**多个**必要条件，然后考虑能否拼出一个充要的。

接下来我将说明哪些条件是充要的。

我们称**超集数**为满足在这个序列上，其二进制或这个序列上任意数仍然是其本身。

1. 好的序列中必须包含至少一个**超集数**

容易发现的是，如果希望一个序列最终变成一个数，那个数显然是所有数的二进制或，而覆盖操作必须要在原序列存在才能使得最终变成一个数，固必然存在一个**超集数**。

2. 一个序列拥有两个**超集数**，则这个序列是好的，否则若经过若干次操作仍然无法使得原序列拥有两个**超集数**，则该序列不是好的

首先可以发现，若两个超集数相邻，那么通过往左右两边覆盖一定可以使得序列变成全部都是**超集数**，若两个**超集数**不相邻，设在序列上两个**超集数**分别在 $x,y$，由于 $[x,y-1]$ 和 $[x+1,y]$ 的二进制或相等（都有**超集数**），那么使用 $[x,y-1]$ 覆盖 $[x+1,y]$ 可以使得两个**超集数**落在 $x,x+1$ 上，从而相邻。

那么如果一个序列无论如何也无法得到两个**超集数**，那么考虑一个序列最终被覆盖成全部相等前的操作，一定是用一个全部相等的序列去覆盖另一个序列（否则最终序列一定不是全部相等），而又由于之前理论，最后全部数都是**超集数**，那么又由于这个序列无论怎么操作都无法得出两个**超集数**，那么这个序列一定无法全部覆盖成一个数。

3. 一个序列无论怎么操作，都无法得到两个**超集数**当且仅当，唯一那个**超集数**，左边所有数二进制或不等于这个**超集数**，右边所有数二进制或不等于这个**超集数**

观察一次操作是什么情况，我将超集数以及其左（右）边的一段向右（左）覆盖，右（左）边的二进制或不增，左（右）边的二进制或不变，想要通过一次操作使得序列有两个**超集数**必须满足的是选择的两个区间不交，一个包含超集数，另一个没有（否则原本拥有的**超集数**会被另一个区间覆盖），那么就不难发现上述条件满足。

那么这个**好的**序列的充要条件就可以简单描述了，现在问题是快速求解。

考虑一个数 $a_i$ 作为**超集数**，对所有查询的贡献。

首先可以求出 $L_{1,i},R_{1,i},L_{2,i},R_{2,i}$ 分别表示 $[L_{1,i},i]$ 二进制或为 $a_{i}$ 而 $[L_{1,i}-1,i]$ 二进制或不为 $a_{i}$，$[R_{1,i},i-1]$ 二进制或为 $a_{i}$ 而 $[R_{1,i}+1,i-1]$ 二进制或不为 $a_{i}$，$[i+1,L_{2,i}]$ 二进制或为 $a_{i}$ 而 $[i+1,L_{2,i}-1]$ 二进制或不为 $a_{i}$，$[i,R_{2,i}]$ 二进制或为 $a_{i}$ 而 $[i,R_{1,i}+1]$ 二进制或不为 $a_{i}$。

那么对于原序列为 $a[l:r]$，$a_i$ 作为**超集数**的充要条件又可以形式得描述为：

$L_{1,i}\leq l \leq R_{1,i}\ \text{or}\ L_{2,i}\leq r \leq R_{2,i}$


那么求一个区间的最长合法子区间就形如一个二位数点，稍加分讨即可。

复杂度 $O(n \log n)$。

```cpp
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2")
#include<bits/stdc++.h>
#define ll long long
#define pii pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
//#define int ll
using namespace std;
const int N=2e6+20,M=1e6+20,mod=998244353,LGN=22;
int n,q;
struct Bit1{
	int s[N];
	inline int lb(int x){return x&(-x);}
	inline void upd(int x,int v){for(;x<=n;x+=lb(x)) s[x]+=v;}
	inline void upd(int l,int r,int v){upd(l,v),upd(r+1,-v);}
	inline int qry(int x){int res=0;for(;x;x-=lb(x)) res+=s[x];return res;}
}t;
struct Bit2{
	int s[N];
	inline int lb(int x){return x&(-x);}
	inline void upd(int x,int v){while(x) s[x]=max(s[x],v),x-=lb(x);}
	inline int qry(int x){int res=0;for(;x<=n;x+=lb(x)) res=max(res,s[x]);return res;} 
}tr;
struct Seg2{
	int s[N<<2];
	inline void init(){for(int i=0;i<n<<2;i++) s[i]=0;}
	void upd(int rt,int l,int r,int ql,int qr,int v){
		if(ql<=l&&r<=qr) return s[rt]=max(s[rt],v),void();
		int mid=(l+r)>>1;
		if(ql<=mid) upd(rt<<1,l,mid,ql,qr,v);
		if(qr>mid) upd(rt<<1|1,mid+1,r,ql,qr,v);
	}
	int qry(int rt,int l,int r,int p){
		if(l==r) return s[rt];
		int mid=(l+r)>>1;
		if(p<=mid) return max(s[rt],qry(rt<<1,l,mid,p));
		else return max(s[rt],qry(rt<<1|1,mid+1,r,p));
	}
}s;
int a[N],L1[N],R1[N],L2[N],R2[N],st[N][LGN],lg[N],ans[N];
inline int qry(int l,int r){
	int k=lg[r-l+1];
	return st[l][k]|st[r-(1<<k)+1][k];
}
struct Node{int l,r;bool fl;};
vector<pii> vec[N],vc[N];vector<int> v[N];vector<Node> ve[N],e[N],v1[N],v2[N];
bool fl1[N],fl2[N];
void solve(){
	cin>>n>>q;
	for(int i=1;i<=n;i++) cin>>a[i],st[i][0]=a[i];
	int res=0;
	for(int j=1;j<LGN;j++){
		for(int i=1;i+(1<<j)-1<=n;i++) st[i][j]=st[i][j-1]|st[i+(1<<j-1)][j-1];
	}
	for(int i=1;i<=n;i++) fl1[i]=fl2[i]=1;
	for(int i=1,l,r,res;i<=n;i++){
		l=1,r=i,res=i;
		while(l<=r){
			int mid=(l+r)>>1;
			if(qry(mid,i)==a[i]) r=mid-1,res=mid; 
			else l=mid+1;
		}
		L1[i]=res;
		if(L1[i]==i||qry(L1[i],i-1)!=a[i]) fl1[i]=0;
		l=i,r=n,res=i;
		while(l<=r){
			int mid=(l+r)>>1;
			if(qry(i,mid)==a[i]) l=mid+1,res=mid; 
			else r=mid-1;
		}
		R2[i]=res;
		if(R2[i]==i||qry(i+1,R2[i])!=a[i]) fl2[i]=0;
		l=L1[i],r=i-1,res=L1[i];
		while(l<=r){
			int mid=(l+r)>>1;
			if(qry(mid,i-1)==a[i]) l=mid+1,res=mid;
			else r=mid-1;
		}R1[i]=res;
		l=i+1,r=R2[i],res=R2[i];
		while(l<=r){
			int mid=(l+r)>>1;
			if(qry(i+1,mid)==a[i]) r=mid-1,res=mid;
			else l=mid+1;
		}L2[i]=res;
	}
	for(int i=1;i<=q;i++) ans[i]=1;
	for(int i=1;i<=n;i++) if(fl1[i]||fl2[i]) v[R2[i]].pb(L1[i]);
	for(int i=1;i<=n;i++){
		if(fl1[i]) v1[R2[i]].pb((Node){L1[i],R1[i],0}),v1[i-1].pb((Node){L1[i],R1[i],1});
		if(fl2[i]) v2[L1[i]].pb((Node){L2[i],R2[i],0}),v2[i+1].pb((Node){L2[i],R2[i],1});
		if(fl2[i]) ve[R2[i]].pb((Node){L1[i],i,1});
		if(fl1[i]) ve[R2[i]].pb((Node){L1[i],R1[i],1});
		if(fl1[i]) e[L1[i]].pb((Node){i,R2[i],0});
		if(fl2[i]) e[L1[i]].pb((Node){L2[i],R2[i],0});
	}
	for(int i=1,l,r;i<=q;i++) cin>>l>>r,vec[r].pb(MP(l,i)),vc[l].pb(MP(r,i));
	for(int i=1;i<=n;i++){
		for(int u:v[i]) tr.upd(u,i-u+1);
		for(auto u:vec[i]) ans[u.se]=max(ans[u.se],tr.qry(u.fi));
	}
	for(int i=1;i<=n;i++){
		for(Node u:ve[i]) s.upd(1,1,n,u.l,u.r,i);
		for(auto u:vec[i]) ans[u.se]=max(ans[u.se],s.qry(1,1,n,u.fi)-u.fi+1);
	}s.init();
	for(int i=n;i;i--){
		for(Node u:e[i]) s.upd(1,1,n,u.l,u.r,n-i+1);
		for(auto u:vc[i]){
			int p=s.qry(1,1,n,u.fi);
			if(p) ans[u.se]=max(ans[u.se],u.fi-(n-p+1)+1);
		}
	}s.init();
	for(int i=1;i<=n;i++){
		for(Node u:v2[i]){
			if(!u.fl) t.upd(u.l,u.r,1);
			else t.upd(u.l,u.r,-1);
		}
		for(auto u:vc[i]) if(t.qry(u.fi)) ans[u.se]=max(ans[u.se],u.fi-i+1);
	}
	for(int i=1;i<=n;i++) t.s[i]=0;
	for(int i=n;i;i--){
		for(Node u:v1[i]){
			if(!u.fl) t.upd(u.l,u.r,1);
			else t.upd(u.l,u.r,-1);
		}
		for(auto u:vec[i]) if(t.qry(u.fi)) ans[u.se]=max(ans[u.se],i-u.fi+1);
	}
	for(int i=1;i<=n;i++) t.s[i]=0;
	for(int i=1;i<=q;i++) cout<<ans[i]<<'\n';
	for(int i=1;i<=n;i++) tr.s[i]=0,vector<pii>().swap(vc[i]),vector<pii>().swap(vec[i]),vector<Node>().swap(v1[i]),vector<Node>().swap(v2[i]);
	for(int i=1;i<=n;i++) vector<Node>().swap(ve[i]),vector<Node>().swap(e[i]),vector<int>().swap(v[i]);
}
signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	lg[0]=-1;for(int i=1;i<N;i++) lg[i]=lg[i>>1]+1;
	int T,id;cin>>T>>id;
	while(T--) solve();
	return 0;
}
```


---

## 作者：_HMZ_ (赞：2)

在主题库出的第一道题，纪念一下。

不太会起名，所以只能叫签到题了，~~但我确实觉得这是一道签到题~~。

本来还有一张[东京喰种](https://cdn.luogu.com.cn/upload/image_hosting/ugsid7h9.png)的图片的，但是可能因为是 csp 模拟赛，不让放，结果被删掉了/ll

### 题解

先来观察一下这个操作，我们可以发现，一旦 $2^i$ 出现，那么就无法删除它。

一个很显然的证明是如果要覆盖一个含有 $2^i$ 的区间就必须拿另一个含有 $2^i$ 的区间去覆盖。

而同样的，如果 $2^i$ 没出现，那么不管怎么操作也不会出现。

所以最后变成的数其实已经确定了，就是全部数的 $\text{or}$。

来考虑什么情况下无解，设全部数的 $\text{or}$ 为 $k$，如果 $k$ 没有出现，那么必然无解。

如果出现次数大于等于 $2$，那么我们必然能通过一些操作使得这两个数挨着。

证明如下：

考虑分两种情况讨论，如果这两个数有一个不在边缘（$1$
 和 $n$），那么可以将这个数自由的向左右挪动（设其位置为 $i$，一直选择 $[i-1,i],[i,i+1]$ 就相当于向右挪了一位，向左同理）。
 
如果这两个数均在边缘，那么选择 $[1,n-1],[2,n]$ 即可让第一个和第二个均为 $k$。

而当两个 $k$ 挨着的时候，设其位置在 $[i,i+1]$，选择 $[i,i+1],[i-1,i]$ 就相当于向左覆盖了一个数，一直覆盖就能使得全部等于 $k$。

如果 $k$ 的出现次数只有一种，那么必然要变出来第二个 $k$（唯一的特例是这个序列长度为 $1$，特判掉即可），设唯一的 $k$ 的位置为 $i$。

如果 $[1,i-1]$ 或者 $[i+1,n]$ 的 $\text{or}$ 和为 $k$，则必然合法，否则，倘若一次操作没有跨越 $i$，这次操作不会使得两边的 $\text{or}$ 和改变，一旦跨越 $i$，两边的 $or$ 和只会减少或者不变。

于是，整理一下上面的结论，我们得到了判断一个序列合法的条件为，设其全部 $\text{or}$ 和为 $k$，**找到任意一个值为 $k$ 的位置 $i$，要求 $[1,i-1]$ 或者 $[i+1,n]$ 的 $\text{or}$ 和为 $k$。**

到这里如果写的好看一点已经能通过前 $24$ 个点。

**小彩蛋**：根据上面结论，感性理解一下，值域如果是随机的除了长度为 $1$ 的情况根本没有合法的子段，所以全部询问均输出 $1$ 即可通过第 **$45$** 号点（不可以，总司令）。

对于特殊性质 $B$ 也是简单的，分讨一下即可，不再阐述。

考虑怎么优化这个算法。

尝试扫描线，向右推右端点，通过某些数据结构维护左端点的查询。

我们将上文中"任意一个值为 $k$ 的位置"的这个位置定义为一个合法子段的**可爱点**。

设当前推到的右端点为 $j$，根据经典结论我们可以知道，固定右端点时，对于任意左端点 $i$，$[i,j]$ 的 $\text{or}$ 和取值最多只有 $
\log_V$ 种。

换句话说，我们已知右端点 $j$ 时，可能作为 $[l,j]$ （$l$ 为 $1\sim j$ 的任意值）的可爱点的位置最多只有 $log(V)$ 个（如果有多个位置的值相同，取靠右的作为可爱点一定更优）。

于是，我们使用线段树维护，对于每个位置，若其作为左端点最大的可能的右端点为多少，修改时使用标记永久化。

此时已经得到了一个 $O(n\log_n \log_V + m\log_n)$ 的做法（因为对于每个可能的可爱点都要更新一遍），可能能通过前 $44$ 个点，具体看常数如何。

不过我怎么看赛时没有人写这个做法啊/ng

$2\times 10^6$ 肯定是过不去的，本地实测 $30s$ 也没跑出来。

考虑怎么优化一只 $\log$，注意到复杂度并不平衡，那么我们是否可以通过一些手段使得其平衡并优化复杂度？

观察到，每个可爱点所能拓展到的右端点肯定是一个区间，而对于这个区间的每个位置都要花 $\log_n$ 的时间去更新，看起来有点蠢。

于是，我们可以当一个位置无法继续作为再往右的位置的可爱点的时候再插入线段树，而对于能作为当前扫描的右端点的可爱点的 $\log_V$ 个位置，已知可爱点，已知右端点，已知询问，通过 $st$ 表预处理区间 $\text{or}$ 和是可以做到 $O(1)$ 求答案的。

所以，此时复杂度为 $O(n\log_n+m\log_n)$，可以通过全部测试点。

### 关于数据：

说一点题外话，这道题的数据是真的难造，直接随机造不光答案全是 $1$，双 $\log$ 做法也卡不掉。

所以我只能搞个多测，造几个 $n$ 比较小的点用来验证正确性，其余点把我能想到的双 $\log$ 或者其余错误复杂度做法特殊构造一个 $hack$ 出来，而且要防止答案为 $1$ 或者答案为区间长度的询问过多。

在赛时似乎有人被卡常了，不过，$\text{std}$ 在不卡常的情况下最慢的点只跑了 $3.5s$，时限乘 $2$ 的情况下依然被卡常可能就是写的比较劣。

### 后记：

个人感觉，这道题的区分度还是很可以的！（划掉）



























---

## 作者：do_while_true (赞：1)

一个区间合法的充要条件是存在 $x$ 满足其为区间按位或，并且《$x$ 左侧所有数或起来》《$x$ 右侧所有数或起来》二者有其一为 $x$。

扫描线扫右端点，不同的按位或将左端点分为 $\log A$ 个区间，对于每个区间 $[l,r]$ 先在区间按位或 $v$ 在序列中存在位置的 vector 中二分，找到 $[l,r]$ 内最靠后的 $a_x=v$。

再找到最右侧的 $p$ 满足 $[p,x-1]$ 的按位或为 $a_x$，最左侧的 $q$ 满足 $[x+1,q]$ 的按位或为 $a_x$。

- 如果 $q\leq r$，此时左端点在 $[l,x]$ 内的左端点均合法。
- 否则，如果 $p\geq l$ 此时左端点在$[l,p]$ 内的左端点均合法。

现在对每个右端点有 $\log A$ 个合法的左端点区间，每次询问一个区间的最长的合法子区间。再次按照询问的右端点扫描线，用两棵线段树支持一下区间 chkmax 单点查询就行。

时间复杂度是 $\mathcal{O}(n\log n\log A)$。

```cpp
#include<cstdio>
#include<vector>
#include<queue>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<ctime>
#include<random>
#include<assert.h>
#include<functional>
#define eb emplace_back
#define mp make_pair
#define fi first
#define se second
#define dbg(x) cerr<<"In Line "<< __LINE__<<" the "<<#x<<" = "<<x<<'\n'
#define dpi(x,y) cerr<<"In Line "<<__LINE__<<" the "<<#x<<" = "<<x<<" ; "<<"the "<<#y<<" = "<<y<<'\n'
#define DE(fmt,...) fprintf(stderr, "Line %d : " fmt "\n",__LINE__,##__VA_ARGS__)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int>pii;
typedef pair<ll,int>pli;
typedef pair<ll,ll>pll;
typedef pair<int,ll>pil;
typedef vector<int>vi;
typedef vector<ll>vll;
typedef vector<pii>vpii;
typedef vector<pll>vpll;
template<typename T>T cmax(T &x, T y){return x=x>y?x:y;}
template<typename T>T cmin(T &x, T y){return x=x<y?x:y;}
template<typename T>
T &read(T &r){
	r=0;bool w=0;char ch=getchar();
	while(ch<'0'||ch>'9')w=ch=='-'?1:0,ch=getchar();
	while(ch>='0'&&ch<='9')r=r*10+(ch^48),ch=getchar();
	return r=w?-r:r;
}
template<typename T1,typename... T2>
void read(T1 &x,T2& ...y){read(x);read(y...);}
const int mod=998244353;
inline void cadd(int &x,int y){x=(x+y>=mod)?(x+y-mod):(x+y);}
inline void cdel(int &x,int y){x=(x-y<0)?(x-y+mod):(x-y);}
inline int add(int x,int y){return (x+y>=mod)?(x+y-mod):(x+y);}
inline int del(int x,int y){return (x-y<0)?(x-y+mod):(x-y);}
int qpow(int x,int y){
	int s=1;
	while(y){
		if(y&1)s=1ll*s*x%mod;
		x=1ll*x*x%mod;
		y>>=1;
	}
	return s;
}
using namespace std;
const int N=2000100;
int n,q;
int a[N],b[N],c[N],tot;
int L[N],R[N];
vpii pre[N],vec[N];
vi pos[N];
int zz[N];
int qry1(int p,int x){
	int o=lower_bound(b+1,b+tot+1,x)-b;
	if(b[o]!=x)return 0;
	x=o;
	auto it=upper_bound(pos[x].begin(),pos[x].end(),p);
	if(it==pos[x].begin())return 0;
	--it;
	return (*it);
}
vpii vecq[N];
struct Segment_tree{
	static const int inf=0x3f3f3f3f;
	int tg[N<<2],po[N];
	#define ls (x<<1)
	#define rs ((x<<1)|1)
	void build(int x,int l,int r){
		tg[x]=-inf;
		if(l==r){
			po[l]=x;
			return ;
		}
		int mid=(l+r)>>1;
		build(ls,l,mid);
		build(rs,mid+1,r);
	}
	void modify(int x,int tl,int tr,int l,int r,int v){
		if(tl>=l&&tr<=r){
			tg[x]=max(tg[x],v);
			return ;
		}
		int mid=(tl+tr)>>1;
		if(mid>=l)modify(ls,tl,mid,l,r,v);
		if(mid<r)modify(rs,mid+1,tr,l,r,v);
	}
	int query(int l){
		int x=po[l],ans=0;
		while(x){
			ans=max(ans,tg[x]);
			x>>=1;
		}
		return ans;
	}
}sgt1,sgt2;
int ans[N];
void solve(){
	cin>>n>>q;
	for(int i=1;i<=n;i++)cin>>a[i],b[i]=a[i];
	for(int i=0;i<=n+1;i++){
		vpii().swap(vec[i]);
		vpii().swap(pre[i]);
	}
	sort(b+1,b+n+1);
	tot=unique(b+1,b+n+1)-b-1;
	for(int i=1;i<=tot;i++)zz[i]=0;
	for(int i=1;i<=n;i++)vi().swap(pos[i]);
	for(int i=1;i<=n;i++)c[i]=lower_bound(b+1,b+tot+1,a[i])-b,pos[c[i]].eb(i);
	vpii now;
	for(int i=n;i>=1;i--){
		for(auto &j:now)j.fi|=a[i];
		now.eb(mp(a[i],i));
		for(int j=(int)now.size()-1;~j;j--)
			if(j==(int)now.size()-1 || now[j].fi!=now[j+1].fi)
				pre[i].eb(now[j]);
		now=pre[i];
		reverse(now.begin(),now.end());
	}
	for(int i=1;i<=n;i++){
		int x=a[i];
		R[i]=n+1;
		for(auto j:pre[i+1])
			if(j.fi==x)
				R[i]=j.se;
	}
	now.clear();
	for(int i=1;i<=n;i++){
		vpii().swap(pre[i]);
		for(auto &j:now)j.fi|=a[i];
		now.eb(mp(a[i],i));
		for(int j=(int)now.size()-1;~j;j--)
			if(j==(int)now.size()-1 || now[j].fi!=now[j+1].fi)
				pre[i].eb(now[j]);
		now=pre[i];
		reverse(now.begin(),now.end());
	}
	for(int i=1;i<=n;i++){
		int x=a[i];
		L[i]=0;
		for(auto j:pre[i-1])
			if(j.fi==x)
				L[i]=j.se;	
	}
//			cerr<<'\n'<<"Time:"<<1.0*clock()/CLOCKS_PER_SEC*1000<<" ms"<<'\n';
	for(int i=1;i<=n;i++){
		for(int j=0;j<(int)pre[i].size();j++){
			int l=(j==(int)pre[i].size()-1)?1:pre[i][j+1].se+1;
			int r=pre[i][j].se;
			int x=pre[i][j].fi;
			int p=qry1(r,x);
			if(p>=l){
				int q=R[p];//qry2(p+1,x);
				if(q<=i){
					vec[i].eb(mp(l,p));
				}
				else{
					q=L[p];//qry3(p-1,x);
					if(q>=l){
						vec[i].eb(mp(l,q));
					}
				}
			}
		}
	}
	for(int i=1;i<=n;i++)vpii().swap(vecq[i]);
	for(int i=1;i<=q;i++){
		int l,r;cin>>l>>r;
		vecq[r].eb(mp(l,i));
	}
	sgt1.build(1,1,n);
	sgt2.build(1,1,n);
	for(int i=1;i<=n;i++){
		for(auto j:vec[i]){
			int l=j.fi,r=j.se;
			sgt1.modify(1,1,n,l,r,i);
			if(l>=2)sgt2.modify(1,1,n,1,l-1,i-l+1);
		}
		for(auto j:vecq[i]){
			int l=j.fi,id=j.se;
			ans[id]=max(sgt1.query(l)-l+1,sgt2.query(l));
		}
	}
	for(int i=1;i<=q;i++)cout<<max(ans[i],1)<<'\n';
}
signed main(){
//	freopen("binary.in","r",stdin);
//	freopen("binary.out","w",stdout);
	ios::sync_with_stdio(0);cin.tie(0);
	int T,id;cin>>T>>id;
	while(T--){
		solve();
	}
	return 0;
}
```

---

## 作者：zjy2008 (赞：1)

提供一个小常数做法。

做这题首先要发现一个结论：

一个区间 $[l,r](l<r)$ 合法，当且仅当：

- 存在 $p \in [l,r]$，使得 $\sum_{i=l}^r a_i = a_p$ 并且 $\sum_{i=l}^{p-1}a_i = a_p$ 或 $\sum_{i=p+1}^{r}a_i = a_p$，其中 $\sum$ 为按位或的和。

考虑这样做的正确性，这里假设 $\sum_{i=l}^{p-1}a_i = a_p$ 那么可以进行如下一系列操作来实现全部元素相等：

$(l+1,p,l,p-1),(l+1,p-1,l,p-2),\dots,(l+1,l+1,l,l)$

$(l,p,l+1,p+1),(l,p+1,l+1,p+2),\dots,(l,r-1,l+1,r)$

考虑对于每个点 $p$ 计算合法区间的左端点范围与右端点范围，这可以用拆位简单计算，可以得到形如 $([l_1,r_1],[l_2,r_2])$ 若干个区间对。

把询问离线后对右端点扫描线，记一每个点 $i$ 开始的最长区间右端点为 $R_i$ 那么可以将区间对视为在扫到 $l_2$ 时刻对 $[l_1,r_1]$ 取右端点 $r_2$ 的较大值。

于是我们只需要一个数据结构，支持 $O(\log)$ 时间区间取较大值，$O(\log)$ 时间区间求 $\max_{i=l}^r\{ \min(R_i,r)-i+1\}$。这是一个经典问题，先在线段树上二分找到第一个位置 $p$ 使 $r\leq R_p$，那么答案为 $\max \{\max_{i=l}^{p-1}\{ R_i-i+1\},r-p+1\}$，这都可以用线段树简单维护。

时间复杂度 $O(n\log V+(n+q)\log n)$，空间复杂度 $O(n+q)$。

最后，多测记得清空。

代码（可能比较乱，因为实现里不都是闭区间）：

```cpp
#include<bits/stdc++.h>
#define LL long long
#define LLL __int128
#define uint unsigned
#define ldb long double
#define uLL unsigned long long
using namespace std;
/*** ------Fast IO------ ***/
typedef pair<int,int> PII;
const int N=2e6+5,M=8e6+5;
int n,m,q;
int T[M],S[M],F[M];
struct nodf{int l,r,id;}Q[N];
struct node{int p,l,r,z;}A[N*2];
int lst[30],a[N],l1[N],l2[N],r1[N],r2[N],ans[N];
inline bool operator<(const node&i,const node&j){
    return i.p<j.p;
}
inline bool operator<(const nodf&i,const nodf&j){
    return i.r<j.r;
}
inline void build(int p,int l,int r){
    S[p]=0,T[p]=l+1,F[p]=r+1;
    if(l==r)return;
    int mid=(l+r)>>1;
    build(p<<1,l,mid);
    build(p<<1|1,mid+1,r);
}
inline void upd(int p,int l,int r,int x,int y,int z){
    S[p]=max(S[p],z-max(l,x)),F[p]=max(F[p],z);
    if(x<=l&&r<=y)return T[p]=max(T[p],z),void();
    int mid=(l+r)>>1;
    if(x<=mid)upd(p<<1,l,mid,x,y,z);
    if(y>mid)upd(p<<1|1,mid+1,r,x,y,z);
}
inline int qry(int p,int l,int r,int x,int y){
    if(x<=l&&r<=y)return S[p];
    int mid=(l+r)>>1,res=T[p]-max(x,l);
    if(x<=mid)res=max(res,qry(p<<1,l,mid,x,y));
    if(y>mid)res=max(res,qry(p<<1|1,mid+1,r,x,y));
    return res;
}
inline int qry_(int p,int l,int r,int x,int y,int z){
    if(max(z,F[p])<=y)return -1;
    if(l==r)return l;
    z=max(z,T[p]);
    int mid=(l+r)>>1,res=-1;
    if(x<=mid)res=qry_(p<<1,l,mid,x,y,z);
    return ~res?res:qry_(p<<1|1,mid+1,r,x,y,z);
}
inline void MAIN(){
    n=read(),m=0,q=read();
    for(int i=1;i<=n;++i)
        a[i]=read(),l1[i]=0,r1[i]=i-1,l2[i]=i+1,r2[i]=n+1;
    fill(lst,lst+30,0);
    for(int i=1;i<=n;++i)
        for(int j=0;j<30;++j)
            if(a[i]>>j&1)r1[i]=min(r1[i],lst[j]),lst[j]=i;
            else l1[i]=max(l1[i],lst[j]);
    fill(lst,lst+30,n+1);
    for(int i=n;i>=1;--i)
        for(int j=0;j<30;++j)
            if(a[i]>>j&1)l2[i]=max(l2[i],lst[j]),lst[j]=i;
            else r2[i]=min(r2[i],lst[j]);
    for(int i=1;i<=n;++i){
        if(l1[i]<r1[i])A[++m]={i,l1[i]+1,r1[i],r2[i]};
        if(l2[i]<r2[i])A[++m]={l2[i],l1[i]+1,i,r2[i]};
    }
    sort(A+1,A+m+1),build(1,1,n);
    for(int i=1;i<=q;++i)
        Q[i].l=read(),Q[i].r=read(),Q[i].id=i;
    sort(Q+1,Q+q+1);
    for(int i=1,j=1;i<=q;++i){
        for(;j<=m&&A[j].p<=Q[i].r;++j)
            if(A[j].l<=A[j].r)upd(1,1,n,A[j].l,A[j].r,A[j].z);
        int p=qry_(1,1,n,Q[i].l,Q[i].r,0);
        ans[Q[i].id]=Q[i].r+1-p;
        if(Q[i].l<p)ans[Q[i].id]=max(ans[Q[i].id],qry(1,1,n,Q[i].l,p-1));
    }
    for(int i=1;i<=q;++i)write(ans[i]),pc('\n');
}
signed main(){
    for(int T=read(),cid=read();T--;MAIN());
    return flush();
}
/*
*/
```

---

## 作者：Leasier (赞：1)

~~2log 开 $n, q \leq 2 \times 10^6$ + 7s 是不是有点离谱了（~~

额，正解不是这个啊，那没事了。

------------

首先考虑如何判定一个长度 $> 1$ 的区间是否合法。

下面设 $x$ 表示一开始这个区间的按位或。

- Observation 1：若合法，最终区间里每个数都是 $x$。

证明：操作不会改变这个区间的按位或。

- Observation 2：若一开始区间内没有 $x$，则无解。

证明：最终区间内每个数必须在一开始出现过。

- Observation 3：若一开始区间内存在两个 $x$，则一定合法。

证明：我们每次可以选择两个区间，使得其中一个包含两个 $x$，另一个包含一个 $x$，进行操作使得只包含一个 $x$ 的区间包含两个 $x$，最终达成目标。

- Observation 4：若一开始区间内存在一个 $x$，合法条件为 $x$ 前面的数按位或起来等于 $x$ 或者 $x$ 后面的数按位或起来等于 $x$。

证明：若满足，我们可以新造出一个 $x$ 并转化为 Observation 3 中的情况；否则，我们选择的区间必然包含 $x$，则我们只能移动 $x$ 而不能造出 $x$。

考虑枚举左端点 $l$，则区间按位或相同且长度 $1$ 的右端点可以划分出 $O(\log w)$ 个右端点 $[r_1, r_2]$，于是我们可以模拟上面的结论得出 $O(n \log w)$ 个合法区间 $[x, [l, r]]$ 表示 $\forall i \in [l, r]$，$[x, i]$ 均合法。

对于询问 $L, R$，我们需要知道 $\forall [x, [l, r]], x \leq L, l \leq R$ 时 $\min(R, r) - L + 1$ 的最大值。

离线下来用 BIT 维护单点修改、前缀 $\max$，再用一棵线段树维护区间赋值、单点查询即可。

时间复杂度为 $O(\sum (n \log w + q) \log n)$。

代码：
```cpp
#include <algorithm>
#include <unordered_map>
#include <vector>
#include <cstdio>

using namespace std;

const int N = 2e6;

namespace BIT {
	int tree[N + 7];
	
	inline void init(int n){
		for (register int i = 1; i <= n; i++){
			tree[i] = 0;
		}
	}
	
	inline int lowbit(int x){
		return x & (-x);
	}
	
	inline void update(int n, int x, int k){
		while (x <= n){
			tree[x] = max(tree[x], k);
			x += lowbit(x);
		}
	}
	
	inline int get_max(int x){
		int ans = 0;
		while (x > 0){
			ans = max(ans, tree[x]);
			x -= lowbit(x);
		}
		return ans;
	}
}

const int M = 8e6 + 7;

namespace SegmentTree {
	typedef struct {
		int l;
		int r;
		int tag;
	} Node;
	
	Node tree[M];
	
	void build(int x, int l, int r){
		tree[x].l = l;
		tree[x].r = r;
		tree[x].tag = 0;
		if (l == r) return;
		int mid = (l + r) >> 1;
		build(x * 2, l, mid);
		build(x * 2 + 1, mid + 1, r);
	}
	
	void assign(int x, int l, int r, int k){
		if (l <= tree[x].l && tree[x].r <= r){
			tree[x].tag = k;
			return;
		}
		int mid = (tree[x].l + tree[x].r) >> 1;
		if (l <= mid) assign(x * 2, l, r, k);
		if (r > mid) assign(x * 2 + 1, l, r, k);
	}
	
	int get_val(int x, int pos){
		if (tree[x].tag != 0) return tree[x].tag;
		if (tree[x].l == tree[x].r) return 0x7fffffff;
		if (pos <= ((tree[x].l + tree[x].r) >> 1)) return get_val(x * 2, pos);
		return get_val(x * 2 + 1, pos);
	}
}

typedef long long ll;

typedef struct Segment_tag {
	int x;
	int l;
	int r;
	Segment_tag(){}
	Segment_tag(int x_, int l_, int r_){
		x = x_;
		l = l_;
		r = r_;
	}
} Segment;

typedef struct {
	int id;
	int l;
	int r;
} Query;

const int K = 21 + 1, P = 6e7 + 7;
int _log2[N + 7], a[N + 7], val[K][N + 7], ans[N + 7];
Segment seg[P];
Query query[N + 7];
unordered_map<int, int> mp;
vector<int> v[N + 7];

bool operator <(const Segment a, const Segment b){
	return a.x > b.x;
}

bool operator <(const Query a, const Query b){
	return a.l > b.l;
}

inline void init1(){
	_log2[0] = -1;
	for (register int i = 1; i <= N; i++){
		_log2[i] = _log2[i / 2] + 1;
	}
}

inline void init2(int n){
	int m = _log2[n];
	for (register int i = 1; i <= n; i++){
		val[0][i] = a[i];
	}
	for (register int i = 1; i <= m; i++){
		int id = i - 1, t1 = n - (1 << i) + 1, t2 = 1 << id;
		for (register int j = 1; j <= t1; j++){
			val[i][j] = val[id][j] | val[id][j + t2];
		}
	}
}

inline int read(){
	int ans = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9'){
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9'){
		ans = ans * 10 + (ch ^ 48);
		ch = getchar();
	}
	return ans;
}

inline int find(int x, int pos){
	vector<int>::iterator it = lower_bound(v[x].begin(), v[x].end(), pos);
	return it == v[x].end() ? 0x7fffffff : *it;
}

void write(int n){
	if (n >= 10) write(n / 10);
	putchar(n % 10 + '0');
}

int main(){
	int t = read(), id = read();
	init1();
	for (register int i = 1; i <= t; i++){
		int n = read(), q = read(), id = 0, cnt = 0;
		mp.clear();
		for (register int j = 1; j <= n; j++){
			a[j] = read();
			if (!mp.count(a[j])){
				id++;
				mp[a[j]] = id;
				v[id].clear();
			}
			v[mp[a[j]]].push_back(j);
		}
		init2(n);
		for (register int j = 1; j <= n; j++){
			int cur_val = a[j];
			seg[++cnt] = Segment(j, j, j);
			for (register int k = j + 1; k <= n; ){
				int nxt = k;
				cur_val |= a[k];
				for (register int l = _log2[n - k]; l >= 0; l--){
					if (nxt + (1 << l) <= n && (cur_val | val[l][nxt + 1]) == cur_val) nxt += 1 << l;
				}
				if (mp.count(cur_val)){
					int fst = find(mp[cur_val], j);
					if (j == fst){
						int pos = j, t = 0;
						for (register int l = _log2[nxt - j]; l >= 0; l--){
							if (pos + (1 << l) <= nxt && (t | val[l][pos + 1]) < cur_val){
								t |= val[l][pos + 1];
								pos += 1 << l;
							}
						}
						if (pos < nxt) seg[++cnt] = Segment(j, pos + 1, nxt);
					} else if (fst != 0x7fffffff){
						int pos = j - 1, t = 0;
						for (register int l = _log2[fst - j + 1]; l >= 0; l--){
							if (pos + (1 << l) < fst){
								t |= val[l][pos + 1];
								pos += 1 << l;
							}
						}
						if (t == cur_val){
							seg[++cnt] = Segment(j, fst, nxt);
						} else if (fst < nxt){
							pos = fst;
							t = 0;
							for (register int l = _log2[nxt - pos]; l >= 0; l--){
								if (pos + (1 << l) <= nxt && (t | val[l][pos + 1]) < cur_val){
									t |= val[l][pos + 1];
									pos += 1 << l;
								}
							}
							if (pos < nxt) seg[++cnt] = Segment(j, pos + 1, nxt);
						}
					}
				}
				k = nxt + 1;
			}
		}
		sort(seg + 1, seg + cnt + 1);
		for (register int j = 1; j <= q; j++){
			query[j].id = j;
			query[j].l = read();
			query[j].r = read();
		}
		sort(query + 1, query + q + 1);
		BIT::init(n);
		SegmentTree::build(1, 1, n);
		for (register int j = n, k = 1, l = 1; j >= 1; j--){
			while (k <= cnt && seg[k].x == j){
				BIT::update(n, seg[k].r, seg[k].r - j + 1);
				if (seg[k].l < seg[k].r) SegmentTree::assign(1, seg[k].l, seg[k].r - 1, j);
				k++;
			}
			while (l <= q && query[l].l == j){
				ans[query[l].id] = max(BIT::get_max(query[l].r), query[l].r - SegmentTree::get_val(1, query[l].r) + 1);
				l++;
			}
		}
		for (register int j = 1; j <= q; j++){
			write(ans[j]);
			putchar('\n');
		}
	}
	return 0;
}
```

---

## 作者：orz_z (赞：0)



发现操作并不会使一个存在的二进制位消失，所以最后的答案为区间的或。

令这个数为 $mx$，首先序列必须存在 $mx$。

注意到当 $mx$ 出现次数 $\ge 2$ 时，必然有解，可以通过先将这两个数弄成相邻的再左右扩展得到。

现在讨论 $mx$ 出现次数为 $1$ 的情况，我们要把这个数复制成两个数，然后发现，当区间内有不与这个数位置有交的子区间按位或和等于这个数时，满足条件。

发现这东西最优时是一个前缀或一个后缀，通过操作 $(i,r-1,i+1,r)$ 多弄出一个 $mx$。

于是一个区间合法，当且仅当：找到任意一个值为 $mx$ 的位置 $i$，要求 $[1,i−1]$ 或者 $[i+1,n]$ 的或和为 $mx$。

后面的部分就是简单的分类讨论数点了。

---

## 作者：namelessgugugu (赞：0)

解法什么的不重要，主要是想展示调了好久的码风奇异的代码。

#### 题意

定义一个长度为 $m$ 的序列 $\{v_i\}$ 是合法的，当且仅当可以通过若干次以下操作使 $v_i$ 全部相同：

- 选择四个 $[1, m]$ 内整数 $l_1, r_1, l_2, r_2$（$l_1 \leq r_1, l_2 \leq r_2, r_1 - l_1 = r_2 - l_2$），满足 $\{v_i\}$ 的子串 $[l_1, r_1]$ 的所有元素的按位或等于子串 $[l_2, r_2]$ 的所有元素的按位或，然后将 $[l_1, r_1]$ 的元素复制下来，粘贴到 $[l_2, r_2]$ 上。允许这两个子串有交。

给定长为 $n$ 的整数序列 $\{a_i\}$，$q$ 次询问给定 $l, r$，求 $\{a_i\}$ 的子串 $[l, r]$ 内的最长合法子串长度。

$1 \leq n, q \leq 2 \cdot 10^6$。

#### 题解

先寻找序列合法的条件，注意到整个序列的按位或始终不改变（设其为 $x$），同时不会凭空出现新的数，因此序列最终全部变成 $x$，而且初始时至少有一个元素等于 $x$。

如果序列长度为 $1$，显然合法；否则如果有至少两个 $x$，不妨设为 $v_a = v_b = x$ 且 $a < b$，则令 $(l_1, r_1, l_2, r_2) = (1, a, b - a, b - 1)$ 就可以把两个 $x$ 放到一起，此后进行操作 $(b - 1, b, b, b+1)$ 和 $(b - 1, b, b - 2, b - 1)$ 就可以不断地扩张 $x$ 的范围，从而序列合法。

最棘手的情况是恰有一个 $v_a = x$，如果 $[1, a - 1]$ 或 $[a + 1, m]$ 的按位或有至少一个是 $x$，那么进行 $(2, a, 1, a - 1)$ 或 $(a, m - 1, a + 1, m)$ 就又可以创造出两个相邻的 $x$。

然而如果这俩的按位或都小于 $x$，是否可以通过其他操作让它们等于 $x$ 呢？答案是不行。设 $y$ 和 $z$ 分别表示 $x$ 之前和之后的元素按位或，如果一次操作不涉及 $x$ 位置的变动，那么 $y$ 和 $z$ 显然是不变的，否则以 $x$ 向后移为例，$x$ 后的元素变少了，所以 $z$ 不会变大，而 $x$ 前的元素虽然增加了，但是增加的都是前面已经有的，所以 $y$ 不会变，因此无论如何都不会让 $y$ 和 $z$ 变大到与 $x$ 相等。

整理一下，可以得到序列合法的充要条件：存在一个 $k \in [1, m]$ 满足 $v_k = x$，且 $\max\{x_{1, k - 1}, x_{k+1, m}\} = x$，其中 $x_{l, r}$ 表示子串 $[l, r]$ 的元素按位或。

回到原问题，如果只询问一次 $[1, n]$，则可以考虑枚举 $k \in [1, n]$，分别找到最小的 $l$ 和最大的 $r$ 满足 $x_{l, k} = x_{k, r} = a_k$，如果该区间合法则将 $r-l+1$ 计入答案。

而对于多组询问，如果某一个 $k$ 对应的 $[l, r]$ 被完全包含于询问区间 $[L, R]$，则应直接计入答案，这是容易实现的。否则需要额外检验 $[l, r] \cap [L, R]$ 是否合法，这似乎不太好办。

实际上有一个投机取巧的办法，如果 $[l, r] \not\subseteq [L, R]$，同时交集非空，则交集一定是 $[L, R]$ 的前缀或后缀，因此只需对每个询问的求最长合法前后缀。以前缀为例，注意对任何 $L$ 来说，$x_{L, r}$ 至多有 $\log V$ 段，而且对于两个按位或相同的前缀，更长的显然更容易合法，因此实际上只需要检验 $\log V$ 个前缀的合法性。

具体实现上，在预处理 $k$ 对应的 $[l, r]$ 时，可以从小到大枚举，同时记录 $lst_i$ 表示上一次出现二进制下第 $i$ 位为 $1$ 的位置，可以同时求出 $l$ 和 $l'$，这里 $l'$ 指的是最大的满足 $x_{l', k-1} = a_k$ 的位置，同理可以求出 $r$ 和 $r'$，$l'$ 和 $r'$ 可以用来快速判断给定 $l, r, k$ 时一个区间是否合法。

同时，预处理每个 $L$ 对应的 $x_{L, r}$ 有哪些段，这可以通过 $L+1$ 时的分段情况来递推，注意每一段要顺带记录一下等于区间按位或的值的位置。

对于一组询问，利用预处理的信息求出最长合法前后缀，再跑一遍二位偏序求出完全包含的最长合法串。

时间复杂度 $O(n \log nV)$，空间复杂度 $O(n + \log V)$。

#### 代码

~~我就是为了这碟醋包了这盘饺子。~~

一些代码中的细节是，树状数组交换了修改和查询以实现单点修改求后缀 $\max$ 而不是求前缀 $\max$，以及为了避免可能出现的对 $a_k = 0$ 的情况的分讨，直接在一开始令 $a_i \gets 2a_i + 1$。

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <utility>
#include <vector>
#define FILEIO(filename) (freopen(filename ".in", "r", stdin), freopen(filename ".out", "w", stdout))
typedef long long ll;
typedef unsigned long long ull;
using std::vector, std::pair;
class Main
{
    private:
    int n, q;
    vector<int> a, lim[2];
    vector<vector<int>> pt;
    vector<vector<pair<int, int>>> qry;
    struct Bit : public vector<int>
    {
        using vector<int>::vector;
        void update(int x, int v)
        {
            for (++x; x; x &= x - 1)
                (*this)[x] = std::max((*this)[x], v);
            return;
        }
        int query(int x)
        {
            int res = 0;
            for (++x; x < (int)size(); x += x & -x)
                res = std::max(res, at(x));
            return res;
        }
    } T;
    bool check(int l, int r, int k)
    {
        return r - l <= 1 || lim[0][k] >= l || lim[1][k] < r;
    }
    vector<int> fix(vector<int> id)
    {
        vector<int> res;
        int sum = 0;
        for (int i = (int)id.size() - 1; i >= 0; --i)
        {
            int x = id[i];
            if (x < 0 || x >= n || (sum | a[x]) > sum || (sum == a[x] && (res.empty() || a[res.back()] < sum)))
                res.push_back(x);
            if (x >= 0 && x < n)
                sum |= a[x];
        }
        std::reverse(res.begin(), res.end());
        return res;
    }
    void init(void)
    {
        lim[0].resize(n), lim[1].resize(n);
        vector<int> el(n), lst(31, -1);
        for (int i = 0; i < n; ++i)
        {
            lim[0][i] = i;
            for (int j = 0; j < 31; ++j)
                if((a[i] >> j) & 1)
                    lim[0][i] = std::min(lim[0][i], lst[j]), lst[j] = i;
                else
                    el[i] = std::max(el[i], lst[j] + 1);
        }
        lst = vector<int>(31, n);
        pt.resize(n + 1);
        for (int i = n - 1; i >= 0; --i)
        {
            int er = n;
            lim[1][i] = i;
            for (int j = 0; j < 31;++j)
                if((a[i] >> j) & 1)
                    lim[1][i] = std::max(lim[1][i], lst[j]), lst[j] = i;
                else
                    er = std::min(er, lst[j]);
            if(check(el[i], er, i))
                pt[er].push_back(el[i]);
        }
        return;
    }

    public:
    void solve(void)
    {
        scanf("%d%d", &n, &q);
        a.resize(n);
        for (int i = 0; i < n; ++i)
            scanf("%d", &a[i]), a[i] = (a[i] << 1) | 1;
        init();
        qry.resize(n + 1);
        for (int i = 0, l, r; i < q; ++i)
        {
            scanf("%d%d", &l, &r), --l;
            qry[l].push_back({r, i});
            qry[r].push_back({l, i});
        }
        vector<int> ans(q), now({-1});
        T.resize(n + 1);
        for (int i = 1; i <= n; ++i)
        {
            now.push_back(i - 1);
            now = fix(now);
            for (int l : pt[i])
                T.update(l, i - l);
            for (auto [l, id] : qry[i])
                if (l < i)
                {
                    ans[id] = std::max(ans[id], T.query(l));
                    int sum = 0;
                    for (int j = (int)now.size() - 1; j > 0 && now[j] >= l; --j)
                    {
                        sum |= a[now[j]];
                        if (sum == a[now[j]])
                        {
                            int tmp = std::max(l, now[j - 1] + 1);
                            if (check(tmp, i, now[j]))
                                ans[id] = std::max(ans[id], i - tmp);
                        }
                    }
                }
        }
        now = {n};
        for (int i = n - 1; i >= 0; --i)
        {
            now.push_back(i);
            now = fix(now);
            for (auto [r, id] : qry[i])
                if (r > i)
                {
                    int sum = 0;
                    for (int j = (int)now.size() - 1; j > 0 && now[j] < r; --j)
                    {
                        sum |= a[now[j]];
                        if (sum == a[now[j]])
                        {
                            int tmp = std::min(r, now[j - 1]);
                            if (check(i, tmp, now[j]))
                                ans[id] = std::max(ans[id], tmp - i);
                        }
                    }
                }
        }
        for (int x : ans)
            printf("%d\n", x);
        return;
    }
};
int main(void)
{
    int Test, Sub;
    scanf("%d%d", &Test, &Sub);
    while (Test--)
    {
        Main prog = {};
        prog.solve();
    }
    return 0;
}
```

---


# [COCI 2022/2023 #3] Baltazar

## 题目描述

Baltazar 准备去度假。他现在在 Baltazargrad，正想去 Primosten 旅游。为了抵达那里，他需要穿过许多个城市。一共有 $n$ 个城市，被 $m$ 条双向道路所联接。Baltazargrad 编号为 $1$，Primosten 编号为 $n$。

Baltazar 不确定从 Baltazargrad 去 Primosten 的路线，所以他将会使用 GPS，这会指引他以最短路线抵达。

但 Blatazar 真的很爱旅游，而且他可以将魔法药水使用在任何一条路上（即使他没有经过），从而将路的长度增长 $2$ 千米。但他仅能使用一次药水。

不久他意识到，他必须在中午之前在 Primosten 的 Zora 旅馆入住。所以他不能过分增加最短路的总长度。他现在想知道，一共有多少条路可以让他使用药水，使得最短路的长度恰好增加 $1$ 千米。

## 说明/提示

**【样例解释】**

城市和道路如图所示。如果 Baltazar 把他的魔法药水使用在第二条道路上（连接城市 $3$ 和 $5$ 的），那么城市 $1$ 和 $n$ 之间最短的距离将会增加 $1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/jeaidgpn.png)

**【数据范围】**

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $15$ | $n,m \leq 1000$ |
| $2$ | $30$ | 有一条在起点终点之间的道路，这条道路的长度满足恰好比两个城市之间的最短路线长 $1$ 千米。 |
| $3$ | $65$ | 无特殊性质 |

对于 $100\%$ 的数据，满足 $1\le t \le 10000,2\leq n \leq 3\times10^5,1\le m\le \min(3\times 10^5,\dfrac{n\times (n-1)}{2}), 1\le a_i,b_i\le n,a_i\neq b_i,1\le w_i\le 10^9$。

本题满分 $110$ 分。

## 样例 #1

### 输入

```
3
6 6
1 2 2
1 3 2
2 4 2
3 5 2
4 5 1
5 6 2
6 6
1 2 2
1 3 2
2 4 2
3 5 2
4 5 3
5 6 2
6 7
1 2 2
1 3 2
2 4 2
3 5 2
4 5 1
5 6 2
1 6 7```

### 输出

```
2
2 4
0

3
2 4 6```

# 题解

## 作者：Demeanor_Roy (赞：6)

- [原题链接](https://www.luogu.com.cn/problem/P9758)。

- 比较困难的一道最短路题。

------------

原题所问为有哪些边，将其边权增加 $2$ 后，能使 $1 \rightarrow n$ 的最短路长度增加 $1$。

考虑将这个条件进行一个转写。令原图 $1 \rightarrow n$ 的最短路长度为 $D$，原条件等价于操作一条边后，满足：

- $1 \rightarrow n$ 不存在长度为 $D$ 的路径。

- $1 \rightarrow n$ 存在一条长度为 $D+1$ 的路径。

~~看上去十分废话。（~~

先考虑第一个条件。套路地，我们跑一遍 $1 \rightarrow n$ 的最短路，并据此建出**最短路图**。显然我们所求的边即为最短路图上 $1 \rightarrow n$ 路径的必经边。

思考如何求那哪些边是必经的，这里给出两个做法。

法一：由于最短路图为 DAG，我们不妨将有向边视作无向，然后用并查集维护连通性。于是我们所求便成了删掉最短路图上的哪些边，能使 $1$ 和 $n$ 不连通。而这是线段树分治裸题，用可撤销并查集维护即可。

法二：一条边是 $1 \rightarrow n$ 的必经边，等价于 $1 \rightarrow n$ 的路径条数等于 $1 \rightarrow n$ 经过该边的路径条数。这一点我们可以对正反图按拓扑序进行一个简单计数求得。但问题是路径数可能很大，无法存储，又因为我们只需要判定是否相等，而不需要真的比大小，我们不妨找一个大质数取模即可。不难证明这样做的正确率是有保证的。

接着考虑第二个条件。不难发现，如果当前我们操作的边是满足条件的，那么任意一条长度为 $D+1$ 的路径一定不会经过它，否则操作前就一定存在一条 $1 \rightarrow n$ 的长度为 $D-1$ 的路径，与已知矛盾。

于是，我们可以把第二个条件等价地写成：原图中存在一条长度为 $D+1$ 的路径不经过该边。

到这里，很多人就会开始误入歧途，往严格次短路方向去想了。但实际上那样无法得到所求。

不妨从路径长度的奇偶性上做文章。不难发现，上述条件等价于存在一条 $1 \rightarrow n$ 的长度奇偶性与 $D$ 不同的最短路不经过该边，且这条路径长度恰好为 $D+1$。这样转化的好处是我们可以把所求看成到每个点长度分别为奇/偶数的最短路信息。

于是考虑拆点，拆边。把点 $u$ 拆成 $u_1,u_2$ 分别表示奇偶。边 $(u,v,w)$ 根据 $w$ 的奇偶性，若为奇数拆成 $(u_1,v_2,w)$ 和 $(u_2,v_1,w)$；否则拆成 $(u_1,v_1,w)$ 和 $(u_2,v_2,w)$。

这样以来，我们就可以根据 $D$ 的奇偶性确定终点是 $n_1$ 还是 $n_2$。问题被等价为了新图上是否所有两点间路径都经过该边，和上面我们解决过的问题相同。

故本题解决。时间复杂度 $O(m \log n)$。

代码很长，但细节不多，就不放了，需要的私信。

---

## 作者：Msents (赞：3)

~~提供一种我不会证正确性的做法~~

既然要使最短路的长度刚好加一，那被加的这条边要刚好使所有的最短路径都经过它。

于是跑一遍最短路，求由最短路径构成的图的所有割边。

在所有最短路的长度被增加后，还要有路径长度为最短路加一的路径存在，不然实际上操作后最短路的长度就会被加上二。

正着反着跑一遍最短路，遍历所有边，若两端点到起点终点的最短路加上这条边的长度刚好为最短路的长度加一，就说明存在。

考虑到若被加的一条边会影响所有的最短路长度加一的路径，那么这条边就不能加。

于是再用最短路长度加一的路径建一张图，继续求割边。

最终答案就是所有最短路的割边且不是最短路长度加一的路径的割边的边。

码：

```cpp20
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int MaxN=300000;
int n,m;
vector<tuple<int,int,int> >g[MaxN+1],t[MaxN+1],s[MaxN+1];
tuple<int,int,int>edge[MaxN+1];
struct Tarjan{
	vector<int>dfn,low;
	vector<bool>bridge;
	int sign;
	Tarjan(){}
	Tarjan(int n,int m,const vector<tuple<int,int,int> >*g){
		dfn=vector<int>(n+1,0);
		low=vector<int>(n+1,0);
		bridge=vector<bool>(m+1,0);
		sign=0;
		Dfs(1,0,g);
	}
	void Dfs(int u,int prt,const vector<tuple<int,int,int> >*g){
		dfn[u]=low[u]=++sign;
		for(auto&tup:g[u]){
			int v,id;
			tie(v,ignore,id)=tup;
			if(v==prt)continue;
			if(!dfn[v]){
				Dfs(v,u,g);
				low[u]=min(low[u],low[v]);
				if(dfn[u]<low[v])bridge[id]=true;
			}else low[u]=min(low[u],dfn[v]);
		}
		
	}
}tt,st;
struct HeapNode{
	HeapNode(){}
	HeapNode(int u,int val):u(u),val(val){}
	int u,val;
	bool operator<(const HeapNode&obj)const{return val>obj.val;}
};
int dis1[MaxN+1],dis2[MaxN+1];
bool vst[MaxN+1];
vector<pair<int,int> >par1[MaxN+1],par2[MaxN+1];
void Dijkstra(int st,int*dis,vector<pair<int,int> >*par){
	priority_queue<HeapNode>q;
	for(int i=1;i<=n;i++){
		dis[i]=LLONG_MAX;
		vst[i]=false;
		par[i].clear();
	}
	dis[st]=0;
	q.emplace(st,0);
	while(!q.empty()){
		int u=q.top().u;q.pop();
		if(vst[u])continue;
		vst[u]=true;
		for(auto&tup:g[u]){
			int v,d,id;
			tie(v,d,id)=tup;
			if(dis[u]+d<dis[v]){
				dis[v]=dis[u]+d;
				par[v]={{u,id}};
				q.emplace(v,dis[v]);
			}else if(dis[u]+d==dis[v])
				par[v].emplace_back(u,id);
		}
	}
}
void Dfs(int u){
	for(auto&pi:par1[u]){
		int prt=pi.first,id=pi.second;
		Dfs(prt);
		t[prt].emplace_back(u,0,id);
		t[u].emplace_back(prt,0,id);
	}
}
bool tag[MaxN+1];
void Dfs2(int u){
	if(tag[u])return;
	tag[u]=true;
	for(auto&pi:par1[u]){
		int prt=pi.first,id=pi.second;
		Dfs2(prt);
		s[prt].emplace_back(u,0,id);
		s[u].emplace_back(prt,0,id);
	}
}
void Dfs3(int u){
	if(tag[u])return;
	tag[u]=true;
	for(auto&pi:par2[u]){
		int prt=pi.first,id=pi.second;
		Dfs3(prt);
		s[prt].emplace_back(u,0,id);
		s[u].emplace_back(prt,0,id);
	}
}
void Solve(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		g[i].clear(),
		t[i].clear(),
		s[i].clear(),
		par1[i].clear(),
		par2[i].clear(),
		tag[i]=false;
	for(int i=1;i<=m;i++){
		int u,v,w;
		cin>>u>>v>>w;
		g[u].emplace_back(v,w,i);
		g[v].emplace_back(u,w,i);
		edge[i]=make_tuple(u,v,w);
	}
	Dijkstra(1,dis1,par1);
	Dfs(n);
	int stt=dis1[n];
	Dijkstra(n,dis2,par2);
	int flag=0;
	for(int i=1;i<=m;i++){
		int u,v,w;
		tie(u,v,w)=edge[i];
		if(dis1[u]+dis2[v]+w==stt+1){
			++flag;
			s[u].emplace_back(v,0,i);
			s[v].emplace_back(u,0,i);
			Dfs2(u);
			Dfs3(v);
		}
		swap(u,v);
		if(dis1[u]+dis2[v]+w==stt+1){
			++flag;
			s[u].emplace_back(v,0,i);
			s[v].emplace_back(u,0,i);
			Dfs2(u);
			Dfs3(v);
		}
	}
	for(int u=1;u<=n;u++){
		sort(s[u].begin(),s[u].end());
		s[u].resize(unique(s[u].begin(),s[u].end())-s[u].begin());
	}
	tt=Tarjan(n,m,t);
	st=Tarjan(n,m,s);
	if(!flag){
		cout<<"0\n\n";
		return;
	}else{
		vector<int>ans;
		for(int i=1;i<=m;i++)
			if(tt.bridge[i]&&!st.bridge[i])
				ans.push_back(i);
		cout<<ans.size()<<'\n';
		for(int val:ans)cout<<val<<' ';
		cout<<'\n';
	}
}
#undef int
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int T;
	cin>>T;
	while(T--)
		Solve();
	return 0;
}

```

---

## 作者：Kreado (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P9758)。

这道题的思路应该很好想吧。

## 思路

令 $d$ 为原图中 $1$ 到 $n$ 的最短路，我们定义最短路图 $G'$ 为原图 $G$ 的子图，且对于 $G'$ 任意从 $1$ 到 $n$ 的路径权值均为 $d$，次短路图也是类似。

首先建出最短路图，假设其长度为 $d_1$，那么被修改的边一定是最短路图上的边。

然后求出原图的次短路，假设其长度为 $d_2$，那么有解的条件是 $d_2-1=d_1$。

再建出原图的次短路图，很显然的，要修改的边一定是最短路图上的割边（不是割边的话那么一定存在另一条最短路径），且不是次短路图上的割边。

跑两次 Tarjan 即可，代码很简短。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define mk make_pair
using namespace std;

const int Maxn=3e5+7;
const ll inf=1e12;
int T,n,m;
ll dis[Maxn][3];
bool tag[Maxn];
struct node{
    int v,w,id;
};
int dfn[Maxn],tot,low[Maxn];
vector<node>vec[Maxn],e[Maxn];

inline void Init(){
    for(int i=1;i<=m;i++) vec[i].resize(0),
                          tag[i]=0;
}

void DFS(int u,ll val){
    if(u==1) return ;
    for(auto [v,w,id]:vec[u]){
        if(dis[v][1]+w==val){
            e[v].push_back(node{u,w,id});
            e[u].push_back(node{v,w,id});
            DFS(v,dis[v][1]);
        }
        if(dis[v][2]+w==val){
            e[v].push_back(node{u,w,id});
            e[u].push_back(node{v,w,id});
            DFS(v,dis[v][2]);
        }
    }
}
void Tarjan(int u,int ft,bool flg){
    dfn[u]=low[u]=++tot;
    for(auto [v,w,id]:e[u]){
        if(v==ft) continue;
        if(!dfn[v]){
            Tarjan(v,u,flg);
            low[u]=min(low[u],low[v]);
            if(low[v]>dfn[u]) tag[id]=flg;
        }
        else if(dfn[v]<dfn[u]) low[u]=min(low[u],dfn[v]);
    }
}

int main(){
    scanf("%d",&T);
    while(T--){
        scanf("%d%d",&n,&m);
        Init();
        for(int i=1;i<=m;i++){
            int u,v,w;
            scanf("%d%d%d",&u,&v,&w);
            vec[u].push_back(node{v,w,i});
            vec[v].push_back(node{u,w,i});
        }
        priority_queue<pair<ll,int>,vector<pair<ll,int> >,greater<pair<ll,int> > >q;
        for(int i=1;i<=n;i++) dis[i][1]=dis[i][2]=inf;
        dis[1][1]=0;
        q.push(mk(0,1));
        while(!q.empty()){
            int u=q.top().second;
            ll val=q.top().first;
            q.pop();
            for(auto [v,w,id]:vec[u]){
                if(dis[v][1]>val+w){
                    dis[v][2]=dis[v][1];
                    dis[v][1]=val+w;
                    q.push(mk(dis[v][1],v));
                    q.push(mk(dis[v][2],v));
                }
                else if(dis[v][2]>val+w&&dis[v][1]<val+w){
                    dis[v][2]=val+w;
                    q.push(mk(dis[v][2],v));
                }
            }
        }
        if(dis[n][1]!=dis[n][2]-1){
            printf("0\n");
            continue;
        }
        for(int i=1;i<=n;i++) dfn[i]=low[i]=0,e[i].resize(0);
        DFS(n,dis[n][1]);
        tot=0;
        Tarjan(1,0,1);
        for(int i=1;i<=n;i++) dfn[i]=low[i]=0,e[i].resize(0);
        DFS(n,dis[n][2]);
        tot=0;
        Tarjan(1,0,0);

        vector<int>ans;
        for(int i=1;i<=m;i++) if(tag[i]) ans.emplace_back(i);
        printf("%d\n",(int)ans.size());
        for(auto i:ans) printf("%d ",i);
        puts("");
    }
    return 0;
}
```

---

## 作者：Shunpower (赞：1)

我不知道为什么题解把这个题描述得无比困难。感觉我的思路很直白。

---------------

**本文中所有次短路均指严格次短路。**

我不会最短路图！

不妨设原图最短路的长度是 $D$。

考虑我们要操作的边必然是最短路的必经之边。否则就会存在一条最短路直接无视操作，以 $D$ 的长度抵达 $n$，这是不好的。要找出这种边可以直接对两头做最短路计数，随机一个模数检查一下经过这条边的最短路数量是否等于总数。当然还要判断经过这条边是不是最短路。

然后考虑第二部分的问题：还要确保存在一条长度为 $D+1$ 的边。考虑任何一条经过操作边的路径长度都至少会达到 $D+2$，所以我们只需确定原图中是否存在一条长度为 $D+1$ 的路径不经过这条边。换而言之，我们只需确定是否所有长度为 $D+1$ 的路径都会经过这条边。

考虑只要存在长度为 $D+1$ 的路径就一定是原图的一个次短路，它在它之上的每一条边上也表现为两头最短路和次短路的结合。于是不妨维护最短路及其计数和次短路及其计数，这样我们就能轻易求出经过某条边且长度为 $D+1$ 的路径条数。

在 Dij 中类似分层图地转移即可。具体来说，更新次短路时将次短路丢进优先队列；更新最短路时因为同时会更新次短路，所以两个一起丢。

```cpp
int tc;
int n,m;
struct edge{
	int v,w,id;
};
vector <edge> p[N];
bool ans[N];
ll dis[2][N][2],cnt[2][N][2];
const int mod=1e9+7;
bool vis[N][2];
#define pli pair<ll,pii>
priority_queue <pli,vector<pli>,greater<pli>> q;
void dijkstra(int st,ll dis[N][2],ll cnt[N][2]){
	fr1(i,1,n) dis[i][0]=dis[i][1]=1e18;
	fr1(i,1,n) cnt[i][0]=cnt[i][1]=0;
	fr1(i,1,n) vis[i][0]=vis[i][1]=0;
	dis[st][0]=0,cnt[st][0]=1;
	q.push(mp(0,mp(st,0)));
	while(!q.empty()){
		int u=q.top().se.fi,type=q.top().se.se;
		q.pop();
		if(vis[u][type]) continue;
		vis[u][type]=1;
		// cout<<u<<" "<<dis[u]<<" "<<cnt[u]<<endl;
		for(auto y:p[u]){
			int v=y.v,w=y.w;
			if(dis[v][0]>dis[u][type]+w){
				tie(dis[v][1],cnt[v][1])=mp(dis[v][0],cnt[v][0]);
				dis[v][0]=dis[u][type]+w,cnt[v][0]=cnt[u][type];
				if(!vis[v][0]) q.push(mp(dis[v][0],mp(v,0)));
				if(!vis[v][1]) q.push(mp(dis[v][1],mp(v,1)));
			}
			else if(dis[v][0]==dis[u][type]+w){
				(cnt[v][0]+=cnt[u][0])%=mod;
			}
			else if(dis[v][1]>dis[u][type]+w){
				dis[v][1]=dis[u][type]+w,cnt[v][1]=cnt[u][type];
				if(!vis[v][1]) q.push(mp(dis[v][1],mp(v,1)));
			}
			else if(dis[v][1]==dis[u][type]+w){
				(cnt[v][1]+=cnt[u][type])%=mod;
			}
		}
	}
}
void solve(){
	cin>>n>>m;
	fr1(i,1,n) p[i].clear();
	fr1(i,1,m) ans[i]=0;
	fr1(i,1,m){
		int u,v,w;
		cin>>u>>v>>w;
		p[u].pb({v,w,i});
		p[v].pb({u,w,i});
	}
	dijkstra(1,dis[0],cnt[0]);
	dijkstra(n,dis[1],cnt[1]);
	int all1=cnt[0][n][1];
	if(dis[0][n][1]!=dis[0][n][0]+1){
		cout<<"0\n\n";
		return;
	}
	fr1(u,1,n){
		for(auto y:p[u]){
			int v=y.v,w=y.w;
			ll t=0;
			if(dis[0][u][0]+dis[1][v][0]+w==dis[0][n][0]) (t+=cnt[0][u][0]*cnt[1][v][0]%mod)%=mod;
			if(dis[0][v][0]+dis[1][u][0]+w==dis[0][n][0]) (t+=cnt[0][v][0]*cnt[1][u][0]%mod)%=mod;
			if(t!=cnt[0][n][0]) continue;
			t=0;
			if(dis[0][u][1]+dis[1][v][0]+w==dis[0][n][0]+1) (t+=cnt[0][u][1]*cnt[1][v][0]%mod)%=mod;
			if(dis[0][u][0]+dis[1][v][1]+w==dis[0][n][0]+1) (t+=cnt[0][u][0]*cnt[1][v][1]%mod)%=mod;
			if(dis[0][v][1]+dis[1][u][0]+w==dis[0][n][0]+1) (t+=cnt[0][v][1]*cnt[1][u][0]%mod)%=mod;
			if(dis[0][v][0]+dis[1][u][1]+w==dis[0][n][0]+1) (t+=cnt[0][v][0]*cnt[1][u][1]%mod)%=mod;
			if(t!=all1) ans[y.id]=1;
		}
	}
	int c=0;
	fr1(i,1,m) c+=(ans[i]);
	cout<<c<<'\n';
	fr1(i,1,m){
		if(ans[i]) cout<<i<<" ";
	}
	cout<<'\n';
}
```

---

## 作者：ran_qwq (赞：0)

模拟赛遇到了删边最短路的弱化版。强化版：CF1163F。

这道题某条边加 $2$，使得最短路加 $1$，那么最短路肯定是不经过这条边的，可以看做把这条边删掉。问题转化为：求有哪些边删掉能使得最短路加 $1$。并且删掉的边还必须是 $1\sim n$ 最短路上的边，否则最短路是肯定不会变的。

然后我们拉出 $1\sim n$ 上的某条最短路（设它的边集是 $E$），对于每条边 $(u,v,w)$ 这样考虑：删掉这条边 $(u,v,w)$ 的最短路等于 $E$ 中 $1\sim u$ 路径上任取一点 $u'$，$E$ 中 $v\sim n$ 路径上任取一点 $v'$，从 $u'$ 到 $v'$ 不经过 $E$ 中的边的最短路的最小值。形式化地，设 $\operatorname{dis}(u,v)$ 为 $u\sim v$ 的最短路，$1\sim n$ 最短路依次经过点 $a_1,a_2,\dots,a_k$，其中 $a_j=u$，$a_{j+1}=v$。则最短路为：

$$ans_j=\min\limits_{1\le i\le j}\min\limits_{j<i'\le k}(\operatorname{dis}(1,a_i)+\operatorname{dis}(a_i,a_{i'})+\operatorname{dis}(a_{i'},n))$$

这个式子看起来混乱邪恶，我们考虑枚举 $a_i\sim a_{i'}$ 最短路上的某一条边 $(u,v,w)$ 作为代表元。不妨设我们从 $u$ 走到 $v$，经过它的最短路显然为 $\operatorname{dis}(1,u)+\operatorname{dis}(v,n)+w$。我们考虑这么一件事情：设 $1\sim u$ 的某条最短路和 $E$ 最早在 $x$ 处分岔；反着来，$n\sim v$ 的某条最短路和 $E$ 最早在 $y$ 处分叉，则 $\operatorname{dis}(1,u)+\operatorname{dis}(v,n)+w$ 可以作为删掉 $E$ 中 $x$ 到 $y$ 的所有边的答案，用区间取 min 区间求 min 线段树处理。如果对每个点 $u$ 求出 $x_u$ 和 $y_u$ 就 OK 了。

怎么求呢？直接在最短路树上递推即可。具体地，对于每个在 $1\sim n$ 最短路上的点 $s$，初始 $x_s=y_s=s$。求 $x$ 从 $1$ 开始跑最短路，求 $y$ 从 $n$ 开始跑最短路。从 $u$ 转移到 $v$ 时直接继承即可。

[这是代码。](https://www.luogu.com.cn/paste/x0l6jl1k)

---

## 作者：StayAlone (赞：0)

考虑求出原图最短路 $D$，寻求一条边 $(u, v)$ 合法的充要条件。

- 新图的最短路要改变，因此要求所有最短路均经过边 $(u, v)$。

- 新图的最短路为 $D+1$，而边 $(u, v)$ 的长度增加了 $2$，因此新图最短路就是原图严格次短路。显然，新图的最短路一定不经过边 $(u, v)$，因为经过边 $(u, v)$ 的最短路显然是 $D+2$。

因此，只需在原图上跑一遍最短路和严格次短路，同时计数。若严格次短路不是 $D+1$，一定无解。否则，若原图的所有最短路均经过边 $(u, v)$，且原图中存在某条次短路不经过边 $(u, v)$，则该边合法。计数可能很庞大，使用哈希的思想。实现上使用了自然溢出，数据没卡。

时间复杂度 $\mathcal O(m\log m)$。出错大概率都是次短路计数出了问题。

[AC record](https://www.luogu.com.cn/record/213768900)

```cpp
int n, m, U[MAXN], V[MAXN], W[MAXN], vis[2][MAXN];
ll dis1[2][MAXN], disn[2][MAXN];
ull cnt1[2][MAXN], cntn[2][MAXN];
vector <pii> lnk[MAXN]; const ll inf = ~0Ull >> 2;

struct node {
    ll d; int x, t;

    il bool operator < (const node &p) const {
        return d > p.d;
    }
}; priority_queue <node> q;

il void dij(int s, ll dis[2][MAXN], ull cnt[2][MAXN]) {
    rep1(i, 1, n) dis[0][i] = dis[1][i] = inf, cnt[0][i] = cnt[1][i] = vis[0][i] = vis[1][i] = 0;
    dis[0][s] = 0; cnt[0][s] = 1; q.emplace(node{0, s, 0});
    while (q.size()) {
        auto [d, x, t] = q.top(); q.pop();
        if (vis[t][x]) continue;
        vis[t][x] = 1; ull c = cnt[t][x];
        for (auto [v, w] : lnk[x]) {
            ll k = d + w;
            if (k < dis[0][v]) dis[1][v] = dis[0][v], cnt[1][v] = cnt[0][v], cnt[0][v] = c, q.emplace(node{dis[0][v] = k, v, 0}), q.emplace(node{dis[1][v], v, 1});
            else if (k == dis[0][v]) cnt[0][v] += c;
            else if (k < dis[1][v]) cnt[1][v] = c, q.emplace(node{dis[1][v] = k, v, 1});
            else if (k == dis[1][v]) cnt[1][v] += c;
        }
    }
}

il void solve() {
    read(n, m);
    rep1(i, 1, n) lnk[i].clear();
    rep1(i, 1, m) {
        int &u = U[i], &v = V[i], &w = W[i]; read(u, v, w);
        lnk[u].eb(v, w); lnk[v].eb(u, w);
    } dij(1, dis1, cnt1); dij(n, disn, cntn);
    auto D = dis1[0][n]; ull sum0 = cnt1[0][n], sum1 = cnt1[1][n];
    if (dis1[1][n] != D + 1) return puts("0\n"), void();
    vector <int> opt;
    auto calc1 = [&](int u, int v, int w) {
        return (dis1[0][u] + w + disn[0][v] == D) * cnt1[0][u] * cntn[0][v];
    };
    auto calc2 = [&](int u, int v, int w) {
        ull cc = 0;
        if (dis1[0][u] + w + disn[1][v] == D + 1) cc += cnt1[0][u] * cntn[1][v];
        if (dis1[1][u] + w + disn[0][v] == D + 1) cc += cnt1[1][u] * cntn[0][v];
        return cc;
    };
    auto check = [&](int u, int v, int w) {
        return calc1(u, v, w) + calc1(v, u, w) == sum0 && calc2(u, v, w) + calc2(v, u, w) != sum1;
    };
    rep1(i, 1, m) if (check(U[i], V[i], W[i])) opt.eb(i);
    cout << opt.size() << '\n';
    for (auto v : opt) printf("%d ", v); puts("");
}

int main() {
    for (int T = read(); T--; ) solve();
    return 0;
}
```

---

## 作者：vicissitudes (赞：0)

# Baltazar 题目分析
~~简单易懂的题解。~~

给你一张图，请你判断哪些边的边权加 $2$ 后，最短路的长度加一。

只能加一条边。

暴力很显然，枚举加的哪条边，跑一边最短路判断即可。

**性质1**：若题目要有解，则原图要有最短路和**严格次短路**，且两者差为一。

简单证明一下：

* 若原图只有最短路，长度为 $x$，选一条边加 $2$，则次短路长度就为 $x + 2$。
不符合题意。

* 若原图最短路 $x$ 和严格次短路 $y$ 差不为 $1$，选一条边加 $2$，则不可能有边与最短路长度差 $1$。

回到这道题，判断有无解后，题意就变成我们要选一条边，让所有最短路长度都变大。

例如一张图的一些路径长度：6 6 6 6 7。我们要找一条边使得这些路径变为 7 8 8 8 8。

即为最短路的公共边。

当然还有没考虑到的地方，
![](https://cdn.luogu.com.cn/upload/image_hosting/plbyer0j.png)

如果给公共边（图中边权为 1 的边）加，那么严格次短路的长度也会增加。

仿照推到上面过程，不难推出我们**不能选严格次短路的公共边**。

问题来了，如何求最短路（严格次短路）的公共边？

可以转化为**只包含所有最短路形成的图的割边**。

第一次想不到很正常，证明一下。

考虑反证：若最短路的公共边不是只包含所有最短路的图的割边，根据割边定义，那么该公共边的两个点之间有至少 2 条路径使得它们可以互相可达，形成一个**环**。由于边权为正，那么这与该边是最短路的公共边矛盾。

最终，题意转化为最短路图的割边中 不是次短路割边的边有哪些。

# 具体实现
找次短路也可以用 dijkstra，详见 [Sightseeing](https://www.luogu.com.cn/problem/P10947)

找割边可以用 Tarjan 做，建图的方法挺多， 不一一赘述。

---


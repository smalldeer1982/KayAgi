# [HUSTFC 2023] 序列配对

## 题目描述

你有一个长度为 $n$ 的序列 $a_1,a_2,\dots,a_n$，初始序列内任意元素 $a_i=0$。

之后会告诉你 $n$ 组配对信息，每组配对信息形如整数对 $(l,r)$，表示将 $a_l$ 和 $a_r$ 进行配对。在配对之后，你必须执行下面两种操作之一（不可全选）：
- 令 $a_l$ 加 $1$，随后 $a_r$ 减 $1$。
- 令 $a_r$ 加 $1$，随后 $a_l$ 减 $1$。

你得知这些配对信息遵循着一个奇妙的规定：在 $n$ 组整数对内的 $2n$ 个整数中，每个序列的下标都恰好出现 $2$ 次！

此时你想知道，在所有操作方案中，使 $\sum_{i=1}^n{a_i}^2=k$ 的方案数，由于答案可能会很大，你只需要求出其对 $998\,244\,353$ 取模后的结果。


## 样例 #1

### 输入

```
3
1 3
2 3
1 2
0```

### 输出

```
2
```

## 样例 #2

### 输入

```
6
2 5
3 6
2 5
4 6
1 3
1 4
8```

### 输出

```
28
```

# 题解

## 作者：zifanwang (赞：2)

[传送门](https://www.luogu.com.cn/problem/P9773)

考虑将 $l_i$ 与 $r_i$ 连边，得到的图每个点的度数为 $2$，所以这个图是由若干个环组成的。然后发现每个 $a_i$ 只可能等于 $0$ 或 $2$。

题意，即给每条边定向，使得与其连接的两条边的方向不同的点的个数为 $\frac{k}{4}$。

考虑枚举每个环（记这个环为 $G$）上有多少个方向相同的边的连续段，那么上述点的个数就等于该值，因为这是个环，所以该值一定是偶数。考虑用生成函数优化，令：

$$F(G)=\sum_{i=0}^{|G|/2}{|G|\choose 2i}x^i$$

那么 $[x^{k/8}]\prod_{G} F(G)$ 即为所求（如果 $k$ 不是 $8$ 的倍数就直接输出 $0$）。可以把这些多项式扔到一个堆里，每次取出次数最小的两个用 $\tt NTT$ 合并，时间复杂度 $O(n\log^2 n)$。

参考代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define int long long
#define mxn 500003
#define md 998244353
#define pb push_back
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define rept(i,a,b) for(int i=a;i<b;++i)
#define drep(i,a,b) for(int i=a;i>=b;--i)
using namespace std;
int power(int x,int y){
	int ans=1;
	for(;y;y>>=1){
		if(y&1)ans=(ll)ans*x%md;
		x=(ll)x*x%md;
	}
	return ans;
}
struct node{
	vector<int>a;
};
inline bool operator<(node x,node y){
	return x.a.size()>y.a.size();
}
int n,k,c,f[mxn],f1[mxn],rev[mxn];
ll ans=1,fac[mxn],ifac[mxn];
vector<int>g[mxn];
bool v[mxn];
priority_queue<node>q;
void dfs(int x){
	v[x]=1;
	c++;
	for(int i:g[x])if(!v[i]){
		dfs(i);
	}
}
inline ll C(int n,int m){
	return fac[n]*ifac[m]%md*ifac[n-m]%md;
}
void ntt(int *a,int n,int flag){
	rept(i,0,n)if(i<rev[i])swap(a[i],a[rev[i]]);
	for(int h=1;h<n;h<<=1){
		int x,y,s=power(3,499122176/h);
		for(int j=0;j<n;j+=h<<1){
			int w=1;
			for(int k=j;k<j+h;++k){
				x=a[k],y=w*a[k+h]%md;
				a[k]=(x+y)%md;
				a[k+h]=(x-y+md)%md;
				w=w*s%md;
			}
		}
	}
	if(flag==-1){
		int p=power(n,md-2);
		reverse(a+1,a+n);
		rept(i,0,n)a[i]=a[i]*p%md;
	}
}
signed main(){
	scanf("%lld",&n);
	fac[0]=1;
	rep(i,1,n)fac[i]=fac[i-1]*i%md;
	ifac[n]=power(fac[n],md-2);
	drep(i,n,1)ifac[i-1]=ifac[i]*i%md;
	for(int i=0,x,y;i<n;++i){
		scanf("%lld%lld",&x,&y);
		g[x].pb(y),g[y].pb(x);
	}
	scanf("%lld",&k);
	if(k%8||k/4>n){
		puts("0");
		return 0;
	}
	k/=8;
	rep(i,1,n)if(!v[i]){
		c=0;
		dfs(i);
		node s;
		rep(j,0,c)if(!(j&1))s.a.pb(C(c,j));
		q.push(s);
		ans=ans*2%md;
	}
	while(q.size()>1){
		node a=q.top();q.pop();
		node b=q.top();q.pop();
		node c;c.a.resize(a.a.size()+b.a.size()-1);
		int k,s;
		for(k=0,s=1;s<c.a.size();s<<=1,++k);
		rept(i,0,s)rev[i]=(rev[i>>1]>>1)|((i&1)<<(k-1));
		rept(i,0,a.a.size())f[i]=a.a[i];
		rept(i,a.a.size(),s)f[i]=0;
		rept(i,0,b.a.size())f1[i]=b.a[i];
		rept(i,b.a.size(),s)f1[i]=0;
		ntt(f,s,1);ntt(f1,s,1);
		rept(i,0,s)f[i]=f[i]*f1[i]%md;
		ntt(f,s,-1);
		rept(i,0,c.a.size())c.a[i]=f[i];
		q.push(c);
	}
	cout<<q.top().a[k]*ans%md;
	return 0;
}
```

---

## 作者：L_Star_Plus (赞：1)

$l_i$ 与 $r_i$ 连边，每个点度数都是 $2$，所以一定是若干个环。对每个环分开考虑

每条边表示必须对两端的点进行题目所述的操作，可以当作给边定向，不妨令被 -1 的点指向被 +1 的点。

定向后，每个点 $x$ 只有两种情况：

- 出度和入度均为 $1$，$a_x=0$
- 出度或入度为 $2$，$a_x=2$

如果确定了环上有 $c$ 个点点权为 $2$，那么给边定向的方案数只有 $2$ 种，同时 $c$ 必须是个偶数。因此 $k$ 不是 $8$ 的倍数时方案数为 $0$。

这样就可以写出某个环 $G$ 的生成函数 $F(G)=\displaystyle \sum_{i=0}^{4n}2[i\bmod 8=0]{n \choose i/4}x^i$.

答案即为 $[x^k]\prod F(G_i) $。

直接暴力 NTT 依次把所有环的生成函数相乘，最坏复杂度是 $O(n^2 \log n)$。所以可以用一个堆，每次选两个最高次幂最小的多项式相乘，再把结果多项式扔到堆里，直到完成所有相乘，复杂度为 $O(n \log^2 n)$。

```cpp
# include <bits/stdc++.h>
namespace NFTS{
	const int M=998244353,g=3;
	std::vector<int> rev,roots{0,1};
	int powMod(int x,int n) {
		int r(1);
		while(n) {
			if(n&1) r=1LL*r*x%M;
			n>>=1; x=1LL*x*x%M;
		}
		return r;
	}
	void dft(std::vector<int> &a) {
		int n=a.size();
		if((int)rev.size()!=n) {
			int k=__builtin_ctz(n)-1;
			rev.resize(n);
			for(int i=0;i<n;i++) {
				rev[i]=rev[i>>1]>>1|(i&1)<<k;
			}
			
		}
		if((int)roots.size()<n) {
			int k=__builtin_ctz(roots.size());
			roots.resize(n);
			while((1<<k)<n) {
				int e=powMod(g,(M-1)>>(k+1));
				for(int i=1<<(k-1);i<(1<<k);i++) {
					roots[2*i]=roots[i];
					roots[2*i+1]=1LL*roots[i]*e%M;
				}
				k++;
			}
		}
		for(int i=0;i<n;i++) if(rev[i]<i) {
			std::swap(a[i],a[rev[i]]);
		}
		for(int k=1;k<n;k*=2) {
			for(int i=0;i<n;i+=2*k) {
				for(int j=0;j<k;j++) {
					int u=a[i+j];
					int v=1LL*a[i+j+k]*roots[k+j]%M;
					int x=u+v,y=u-v;
					if(x>=M) x-=M;
					if(y<0) y+=M;
					a[i+j]=x;
					a[i+j+k]=y;
				}
			}
		}
	}
	void idft(std::vector<int> &a) {
		int n=a.size();
		std::reverse(a.begin()+1,a.end());
		dft(a);
		int inv=powMod(n,M-2);
		for(int i=0;i<n;i++) {
			a[i]=1LL*a[i]*inv%M;
		}
	}
}
class polyS{
	void reverse() {
		std::reverse(a.begin(),a.end());
	}
public:
	static const int M=NFTS::M;
	static const int inv2=(M+1)/2;
	std::vector<int> a;
	polyS(){}
	polyS(int x){if(x) a={x};}
	polyS(const std::vector<int> _a) : a(_a) {}
	int size() const {return a.size();}
	int &operator[](int id) {return a[id];}
	polyS &operator *=(polyS rhs) {
		int n=size(),m=rhs.size(),tot=std::max(1,n+m-1);
		int sz=1<<std::__lg(tot*2-1);
		a.resize(sz);
		rhs.a.resize(sz);
		NFTS::dft(a);
		NFTS::dft(rhs.a);
//		printf("%d %d siz:%d\n",n,m,sz);
		for(int i=0;i<sz;i++) {
			a[i]=1LL*a[i]*rhs.a[i]%M;
		}
		NFTS::idft(a);
		return *this;
	}
	polyS operator *(polyS rhs) const {
	return polyS(*this)*=rhs;}
	void prt() {
		for(auto x:a) printf("%d ",x);
		puts("");
	}
};
# define N 200010
# define MOD 998244353
std::vector<int> e[N],vec,tp;
int fac[N],ifac[N];
bool vis[N];
void dfs(int x) {
	vis[x]=true;
	vec.push_back(x);
	for(auto v:e[x]) {
		if(!vis[v]) dfs(v);
	}
}
int qpow(int x,int p) {
	int res=1;
	while(p) {
		if(p&1) res=1ll*res*x%MOD;
		x=1ll*x*x%MOD; p>>=1;
	}
	return res;
}
int C(int n,int m) {
	return 1ll*fac[n]*ifac[m]%MOD*ifac[n-m]%MOD;
}
bool operator <(const polyS &i,const polyS &j) {
	return i.size()>j.size();
}
struct heap{
	polyS h[N];
	int siz;
	void push(polyS x) {
		h[++siz]=x;
		std::push_heap(h+1,h+siz+1);
	}
	void pop() {
		std::pop_heap(h+1,h+siz+1);
		siz--;
	}
	polyS top() {
		return h[1];
	}
}Q;
int main() {
	int n,i,x,y,key;
//	freopen("E.in","r",stdin);
	scanf("%d",&n);
	for(i=1;i<=n;i++) {
		scanf("%d%d",&x,&y);
		e[x].push_back(y);
		e[y].push_back(x);
	}
	scanf("%d",&key);
	if(key%8) return puts("0"),0;
	if(key/4>n) return puts("0"),0;
	fac[0]=1;
	for(i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%MOD;
	ifac[n]=qpow(fac[n],MOD-2);
	for(i=n-1;i>=0;i--) ifac[i]=1ll*ifac[i+1]*(i+1)%MOD;
	for(i=1;i<=n;i++) if(!vis[i]) {
		vec.clear();
		dfs(i);
		int cnt=vec.size();
		tp.clear();
		
		for(int j=0;j<=cnt/2;j++) tp.push_back(2*C(cnt,j*2)%MOD);
//		printf("%d\n",i);
		Q.push(polyS(tp));
//		printf("%d\n",i);
	}
	while(Q.siz>1) {
		polyS s1,s2;
		s1=Q.top(); Q.pop();
		s2=Q.top(); Q.pop();
		Q.push(s1*s2);
	}
	printf("%d",Q.top().a[key/8]);
	return 0;
}
```


---

## 作者：sky_chen (赞：1)

【HUSTACM】此题解为官方题解。

根据题目性质不难发现将配对点连边后会有若干个环，如果将 $-1$ 的节点向 $+1$ 的节点连有向边，则这些操作等价于给每条边定向，那么一个节点对最终元素平方和的贡献等价于出度和入度的差值的平方。显然这个差值（的绝对值）只能是 $0$ 或 $2$，且只有为 $2$ 时才是有意义的，所以考虑有多少种方案可以使得恰好 $\frac{k}{4}$ 个节点的差值为 $2$。

首先单独考虑一个环，容易发现差值为 $2$ 的节点只能是偶数个，如果已经确定了这些节点的位置，能且仅能构造出 $2$ 种方法（随便选一个差值为 $2$ 的节点，考虑要么出度为 $2$ 要么入度为 $2$，此时其他边的方向都是唯一确定的）。因此可以很容易求出一个环上的生成函数为 $\sum_{0\le i\le \lfloor \frac{L}{2} \rfloor} 2\tbinom{L}{2i}x^{2i}$，其中 $L$ 为环的长度。最后用启发式合并 NTT 将每个环的生成函数相乘即可。

时间复杂度 $O(n\log^2n)$。

---


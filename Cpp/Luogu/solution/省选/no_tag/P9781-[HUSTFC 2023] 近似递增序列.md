# [HUSTFC 2023] 近似递增序列

## 题目描述

对于一个长度为 $m\ (m\ge 1)$ 的整数序列 $a_1,a_2,\cdots,a_m\ (a_i>0)$，如果**最多**只存在一个整数 $p\ (1\le p<m)$ 满足 $a_p\ge a_{p+1}$，则可以称这样的序列为近似递增序列，同时我们定义这个近似递增序列的权值为 $\prod_{i=1}^m a_i$。

设 $f(i)$ 表示权值为 $i$ 的近似递增序列的数量，duoluoluo 想知道 $\sum_{i=1}^n f(i)$ 的值，但是他连 $f(2)$ 都不会计算，你可以帮帮他吗？由于答案可能会非常大，你只需要求出其对 $998\,244\,353$ 取模后的值。

## 说明/提示

样例一中 $7$ 个近似递增序列为：$\{1\}$，$\{1,1\}$，$\{1,1,2\}$，$\{1,2\}$，$\{1,2,1\}$，$\{2\}$，$\{2,1\}$。

## 样例 #1

### 输入

```
2```

### 输出

```
7
```

## 样例 #2

### 输入

```
5```

### 输出

```
26
```

# 题解

## 作者：sky_chen (赞：2)

【HUSTACM】此题解为官方题解。

### 简要题意

求有多少个最多允许一个位置不满足严格递增的正整数序列使得其乘积小于等于 $n$ 。

### Sol

这个题做法好像很多， 有各种各样的乱搞。

不妨从大到小来依次生成这个序列， 考虑 $f(n, m, 0/1)$ 表示接下来填数的乘积最多是 $n$， 最大可以填 $m$ ， 有没有使用那个不满足严格递增限制的位置。

那么一方面可以填小于等于根号的数， 如果填 $i$ ， 则可以转移到 $f (\lfloor \frac{n}{i} \rfloor, i, 0/1)$ 。

还可以填大于根号的数， 如果填 $i$ ， 则可以转移到 $f (\lfloor \frac{n}{i} \rfloor, min \{\lfloor \frac{n}{i} \rfloor, i\}, 0/1)$ 。由于 $i > \sqrt {n}$ ， 也就是转移到 $f (\lfloor \frac{n}{i} \rfloor, \lfloor \frac{n}{i} \rfloor, 0/1)$ 。于是这一部分可以整除分块计算。

那么第一, 二维都是通过 $n / i$ 得到或者由一个小于等于根号的数得到， 故总状态数是 $\sqrt{n}^2 = n$ 级别的， 并且不难想象实际用到的位置会显著低于这个数字。

然后考虑第一种转移的总转移量， 考虑第一维度为 $n$时， 约为 $\sqrt{n} + \sqrt{\sqrt{n}} + ....$， 不妨约等于为 $\sqrt{n}$ ， 那么考虑所有 $n$ 第一维转移量之和，约为 $\sqrt{n} + \sqrt{\frac{n}{2}} + \sqrt{\frac{n}{3}}+...$  显然不超过 $n$ 。

再考虑第二种转移的转移量， 如果仅进行第二种转移， 那么复杂度同杜教筛的分析， 如果先进行第二种转移再进行第一种转移， 则会访问到仅进行第一种转移访问到的位置 ，我们采用记忆化的方法， 则这部分的复杂度不超过 $O (n ^ {\frac{3}{4}})$ 。如果先进行第一种转移再进行第二种转移， 由于最大数的限制， 这部分复杂度也不会超过 $O (n)$ 。

故本做法上限复杂度不会超过 $O (n)$ ， 在记忆化 $n \leq 5000$ 的答案以后不精细实现在不开 O2 条件下可以在 $2s$ 内通过 $n = 10^8$ 的数据， 且可以轻松扩展到有 $k$ 个不合法位置的情况。

另一个有意思的事情是， 如果直接搜索有多少严格递增序列的乘积小于等于 $n$ ， 只会搜出来大约 $10^7$ 种情况， 可以基于这个性质暴力/乱搞直接通过这个题~~甚至可能比std快还短~~ 。

~~欢迎大家开发新做法薄纱std~~

---

## 作者：dead_X (赞：1)

## 前言
暴力乱杀。
## 题解
设 $f(x,y,z)$ 为当前乘积为 $x$，最后一个数为 $y$，是否已经出现过 $a_i\ge a_{i+1}$ 的方案数。

看起来状态数是 $O(n^2)$ 的，转移是 $O(n)$ 的，完全不可能通过。

但是仔细分析可以发现一些事实：

- $x$ 没有用，我们只关心 $\lfloor \frac{n}{x}\rfloor$，而这只有 $O(\sqrt n)$ 个。
- $y>\lfloor\frac{n}{x}\rfloor$ 的所有状态等价，因为下一个一定只能取 $a_i\geq a_{i+1}$，因此 $(x,y)$ 只有 $O(n)$ 个。
- 每次转移的时候使用整除分块处理 $\min(y,\lfloor\frac{n}{x}\rfloor)$ 相同的转移。

最后套一个 ``unordered_map`` 就做完啦！

复杂度玄学，能过就是赢。
## 代码
```cpp
// Problem: P9781 [HUSTFC 2023] 近似递增序列
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P9781
// Memory Limit: 512 MB
// Time Limit: 6000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

//泥の分際で私だけの大切を奪おうだなん
#include<bits/stdc++.h>
using namespace std;
#define ll long long
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
const int p=998244353;
int n,m,k;
unordered_map<ll,int> mp;
int f(int x,int y,int z)
{
	ll H=(1ll<<30)*x+(y<<1)+z;
	if(mp.count(H)) return mp[H];
	int res=1;
	if(z) res=(res+f(x,0,0))%p,res=(res+p-f(x,y,0))%p;
	for(int l=y+1,r; l<=x; l=r+1)
	{
		r=x/(x/l);
		for(int i=l; i<x/l&&i<=r; ++i)
			res=(res+f(x/l,i,z))%p;
		if(x/l<=r)
			res=(res+1ll*(r-max(x/l,l)+1)*f(x/l,x/l,z))%p;
	}
	return mp[H]=res;
}
signed main()
{
	int n=read();
	printf("%d\n",(f(n,0,1)+p-1)%p);
	return 0;
}
```

---

## 作者：zhouyuhang (赞：1)

这是一个场上就会的做法，由于时间原因没来得及实现。赛后的[提交](https://www.luogu.com.cn/record/132545232)比较轻松地跑到了当前最优解。

首先考虑如何求出递增序列的方案数。根号分治，记 $B=\sqrt n$，注意到，在任何一个递增序列中，最多只有一个大于 $B$ 的数。我们不妨将其放到最后处理。

于是我们只需算出序列中所有数均不大于 $B$ 的方案数在 $n$ 处的块筛。这是容易的，我们只需依次将 $x=1,2,\cdots,B$ 插入块筛即可。由于在 $n$ 的块筛中插入一个数是 $O(\sqrt n)$ 的，因此这一部分的复杂度为 $O(\sqrt n\cdot \sqrt n)=O(n)$。

接下来考虑那些大于 $B$ 的数。由于其最多在序列中出现一次，因此我们卷上 $a_i=[i>B]$ 的块筛即可。使用 $O(n^{3/4})$ 的暴力块筛卷积足以通过。

现在我们将问题扩展到“近似递增序列”上。一个朴素的想法是，近似递增序列可以看作是两个递增序列的拼接，因此直接将递增序列的块筛自卷即可。但是这样无疑会多算一部分，即对于一个长为 $n$ 的递增序列，其会在它所有 $n+1$ 个间隙（包括两端）处被计入贡献。为了减去这一部分多算的贡献，需要在上述过程中额外维护所有递增序列的序列长度之和的块筛，维护方法与普通块筛类似。至此，本题得解。

---


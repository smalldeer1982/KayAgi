# [ROIR 2020] 海报 (Day 2)

## 题目描述

**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day2 T4.** ***[Плакаты](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day2.pdf)***,译者ksyx

你的朋友们为了会见 IOI 回来的国家队选手准备了很多漂亮的海报，现在就还差要考虑些细节了。

为了欢迎这些选手，你的 $n$ 个朋友会拿着海报站成一个圈。为了方便描述，我们把他们编号为朋友 $1\ldots n$，其中对于 $i\in [1,n-1]$，朋友 $i$ 和朋友 $i+1$ 站在一起，且朋友 $n$ 和朋友 $1$ 站在一起。

每张海报都有一个美观度，其中朋友 $i$ 拿着的海报的美观度为 $a_i$。当开始庆祝时，一些朋友会举起他们的海报。为了美观，不能有 $4$ 个或以上排在一起的朋友同时举起他们的海报。

为了能够丰富节目效果，你的朋友们还打算在庆祝过程中更换 $q$ 次海报。每次更换后，海报 $p_i$ 的美观度将变为 $v_i$。你的朋友想知道每次更换后在符合上述条件下的最大美观度之和。

你的任务是给出初始的美观度，求出初始以及各次更换后的最大美观度之和。

*译者注：题面省略了部分难以理解的不必要细节。*

## 说明/提示

#### 【样例 1 解释】
初始状态下最佳方案为让朋友 $2,~4,~5,~6$ 举起海报，此时美观度之和为 $17$。

第一次改变后朋友 $6$ 的海报美观度变为 $0$，在此情况下最佳方案为让朋友 $1,~3,~4,~5$ 举起海报，美观度之和为 $13$。

第二次改变后朋友 $2$ 的海报美观度变为 $5$，在此情况下最佳方案为让朋友 $1,~2,~4,~5$ 举起海报，美观度之和为 $15$。

#### 【数据范围】
对于 $100\%$ 的数据，有 $4\le n\le 40000,~0\le a_i,~v_i\le 10^9,~1\le p_i\le n,~0\le q\le 40000$。


各子任务如下：

|子任务编号|分值|限制|
|:-:|:-:|:-:|
|$1$|$11$|$4 \le n \le 10,~q=0$|
|$2$|$12$|$4 \le n \le 10,~0\le q\le 10$|
|$3$|$13$|$4 \le n \le 1000,~0\le q\le 1000$|
|$4$|$17$|$4 \le n \le 40000,~q=0$|
|$5$|$47$|$4 \le n \le 40000, 0\le q\le 40000$|

## 样例 #1

### 输入

```
6
1 2 3 4 5 6
2
6 0
2 5```

### 输出

```
17
13
15```

# 题解

## 作者：phil071128 (赞：4)

给出一种不用断环为链的做法。


序列上的 【动态 dp 】 板子题。用广义矩阵乘法和线段树来维护带修改的 dp 方程。 $dp_{i,j}$ 表示以 $i$ 结尾，最后选了 $j$ 个人的最大美观值。

无修改时，方程比较简单：

- $dp_{i,0}=\max _{j=0,1,2,3} dp_{i-1,j} $。
- $dp_{i,j}=dp_{i-1,j-1}+a_i,j\in[1,3]$。

因为是环，终点和起点也要满足不能连续超过 $4$ 个人，比较无脑的方式是断环成链，不同起点要跑四遍线段树。但是下文对此情况有巧妙的避免方式。

对于带 $\max $ 的方程，我们一般需要广义矩阵乘法 $A\times B=C$，其中 $C_{i,j}= \max_{k=1} (A_{i,k}+B_{k,j})$。

>  至于这样做的可行性，关键在于矩阵乘法仍然满足结合律和分配率，即内层运算对外层有分配率。回顾普通矩阵乘法，加法对乘法有分配率；广义矩阵乘法中，`max` 对 `+` 也有分配率。即 `max(a,b)+c=max(a+c,b+c)`。

将转移方程写成矩阵的形式：
$$
\begin{bmatrix}dp_{i-1,0}& dp_{i-1,1}& dp_{i-1,2} & dp_{i-1,3} \end{bmatrix} 


\times  \ \begin{bmatrix} 
0 & a_i & -\infty & \infty  \\
0 & -\infty & a_i &-\infty  \\
0 & -\infty & -\infty &a_i  \\
0 & -\infty & -\infty &-\infty  

\end{bmatrix}
=\begin{bmatrix}dp_{i,0}& dp_{i,1}& dp_{i,2} & dp_{i,3} \end{bmatrix}
$$
又因为有结合律，所以：
$$
A \times B_1 \times B_2...\times B_n= A\times (\prod B_i)
$$
因为带修改，用线段树维护 $\prod B_i$，每次修改都是一次线段树单点修改矩阵，每次询问直接用根节点即可。

如何避免建四棵线段树呢？因为是个环，所以初始矩阵 $A$ 中 $dp_{0,j}$ 就是答案矩阵中的 $dp_{n,j}$。我们直接讨论以 $n$ 结尾选了 $j$ 个，初始矩阵除了 $dp_{0,j}=0$，其他都是 $-\infty$，此时答案矩阵只能选 $dp_{n,j}$。而对应在中间的转移矩阵，就是第 $j$ 行，第 $j$ 列的元素。所以在代码实现中，不需要维护初始矩阵和答案矩阵，最后只需统计线段树根节点矩阵对角线的最值即可。

代码实现上有一些技巧，例如可以通过重载一维运算符而实现重载两维运算符，涉及内存访问的一些知识。

## 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int read(){
	char c=getchar();int h=0;
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) h=(h<<1)+(h<<3)+(c^48),c=getchar();
	return h;
}
const int inf=1e18;
struct M{
	int mat[4][4];
	M(){for(int i=0;i<=3;i++)for(int j=0;j<=3;j++) mat[i][j]=-inf;}
	int * operator [] (const int i) {
		return mat[i];	
	}
	M operator * (const M B) {
		M C;
		for(int i=0;i<=3;i++) {
			for(int j=0;j<=3;j++) {
				for(int k=0;k<=3;k++) {
					C[i][j]=max(C[i][j],mat[i][k]+B.mat[k][j]);
				}
			}
		}
		return C;
	}
}; 
const int N=5e4+55;
int a[N];
struct SEG{
	M tree[N*4];
	#define ls(x) (x<<1)
	#define rs(x) (x<<1|1)
	#define mid (l+r>>1)
	void push_up(int p) {
		tree[p]=tree[ls(p)]*tree[rs(p)];
		return ;
	}
	void build(int p,int l,int r) {
		if(l==r) {
			for(int i=0;i<=3;i++) tree[p][i][0]=0;
			tree[p][0][1]=tree[p][1][2]=tree[p][2][3]=a[l];
			query(p);
			return ;
		}
		build(ls(p),l,mid);
		build(rs(p),mid+1,r);
		push_up(p);
		return ;
	}
	void update(int p,int l,int r,int x,int k) {
		if(l==r) {
			tree[p][0][1]=tree[p][1][2]=tree[p][2][3]=k;
			return ;
		}
		if(x<=mid) update(ls(p),l,mid,x,k);
		else update(rs(p),mid+1,r,x,k);
		push_up(p);
		return ;
	}
	int query() {
		int ans=-inf;
		for(int i=0;i<=3;i++) {
			ans=max(ans,tree[1][i][i]);
		}
		return ans;
	}
}t;
void fil() {
	freopen("poster.in","r",stdin);
	freopen("poster.out","w",stdout);
}
signed main(){
//	fil();
	int n=read();
	for(int i=1;i<=n;i++) a[i]=read();
	t.build(1,1,n);
	printf("%lld\n",t.query());
	int q=read();
	for(int i=1;i<=q;i++) {
		int x=read(),k=read();
		t.update(1,1,n,x,k);
		printf("%lld\n",t.query());	
	}
	return 0;
}
```



---

## 作者：zyn0309 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P9790)
### 思路
先考虑没有环怎么做，有一个显然的线性 DP，定义 $f_{i,j}$ 代表选到了第 $i$ 个点，结尾最多连续选了 $j$ 个点的最大值，因为每次只修改一个点，考虑放到线段树上做。设 $v_{u,i,j}$ 代表线段树上的节点 $u$，从左边连续选不超过 $i$ 个，从右边连续选不超过 $j$ 个，然后类似于朴素 DP，可以直接在线段树上合并左右儿子答案。

但是这样没有考虑环的情况，因此需要在合并线段树根节点左右儿子的时候特殊处理一下，让左儿子左边连续段长度和右儿子右边连续段长度合起来也不超过 $4$ 即可。

### Code
```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int N=4e4+10;
int n,a[N],q;
#define pb push_back
#define mk make_pair
struct tree{
	int l,r,v[4][4];//v[i][j] 从左边连续不超过 i 个，右边连续不超过 j 个的最大值
	#define lson(u) (u<<1)
	#define rson(u) (u<<1|1)
}t[4*N];
inline void push_up(int u){
	for(int a=0;a<4;++a)
	for(int b=0;b<4;++b)
	  t[u].v[a][b]=0;
	int llen=t[lson(u)].r-t[lson(u)].l+1,rlen=t[rson(u)].r-t[rson(u)].l+1;
	for(int a=0;a<4;++a)
	for(int b=0;b<4;++b)
	for(int i=0;i<4;++i)
	for(int j=0;i+j<4;++j){
	  if(a>=llen&&j&&b>=rlen&&i){
		if((a+j<4)&&(b+i<4))t[u].v[a+j][b+i]=max(t[u].v[a+j][b+i],t[lson(u)].v[a][i]+t[rson(u)].v[j][b]);
		continue;
	  }
	  if(a>=llen&&j){
		if(a+j<4)t[u].v[a+j][b]=max(t[u].v[a+j][b],t[lson(u)].v[a][i]+t[rson(u)].v[j][b]);
		continue;
	  }
	  if(b>=rlen&&i){
		if(b+i<4)t[u].v[a][b+i]=max(t[u].v[a][b+i],t[lson(u)].v[a][i]+t[rson(u)].v[j][b]);
		continue;
	  }
	  t[u].v[a][b]=max(t[u].v[a][b],t[lson(u)].v[a][i]+t[rson(u)].v[j][b]);
	}
}
inline void build(int u,int l,int r){
	t[u].l=l;
	t[u].r=r;
	if(l==r){
	  for(int i=1;i<4;++i)
	  for(int j=1;j<4;++j)
	    t[u].v[i][j]=a[l];
	  return;
	}
	int mid=(l+r)>>1;
	build(lson(u),l,mid);
	build(rson(u),mid+1,r);
	push_up(u);
}
inline void update(int u,int x){
	if(t[u].l==t[u].r){
	  for(int i=1;i<4;++i)
	  for(int j=1;j<4;++j)
	    t[u].v[i][j]=a[x];
	  return;
	}
	int mid=(t[u].l+t[u].r)>>1;
	if(x<=mid)update(lson(u),x);
	else update(rson(u),x);
	push_up(u);
}
inline int getans(){
	if(n==1)return a[1];
	int ans=0;
	for(int a=0;a<4;++a)
	for(int b=0;a+b<4;++b)
	for(int i=0;i<4;++i)
	for(int j=0;i+j<4;++j)
	  ans=max(ans,t[2].v[a][i]+t[3].v[j][b]);
	return ans;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;++i)cin>>a[i];
	build(1,1,n);
	cout<<getans()<<"\n";
	cin>>q;
	int x,c;
	while(q--){
	  cin>>x>>c;
	  a[x]=c;
	  update(1,x);
	  cout<<getans()<<"\n";
	}
	return 0;
}
```

---

## 作者：Msents (赞：1)

先考虑查询一次答案 DP 怎么做到 $\mathcal{O}(n)$。

考虑不是环的情况，可以设 $f_{i,j}$ 表示前 $i$ 个人，以第 $i$ 个人为结尾连续 $j$ 个人举起海报的答案。

可以很轻松的列出转移方程：

$f_{i,0}=\max (f_{i-1,0},f_{i-1,1},f_{i-1,2},f_{i-1,3}) $

$f_{i,j} = f_{i-1,j-1} + a_i$

最后答案是 $\max (f_{n,0},f_{n,1},f_{n,2},f_{n,3})$。

因为 $j$ 的范围是 $[0,3]$ 的，转移的时间复杂度是可以看成 $\mathcal{O}(n)$ 的。

现在想环上的情况。

看到环自然想到断环，但这道题要求最多有三个人同时举起海报，可以直接再加上一维，表示从 $1$ 开始时连续举起海报的人的数量。

设 $f_{i,j,k}$ 表示开头已经有 $i$ 人举起海报，前 $j$ 个人，以第 $j$ 个人为结尾连续 $k$ 个人举起海报的答案。

初始化时，将 $f_{i,i+1,0}$ 设为前 $i$ 人的海报的美观度的和。

然后让第二维从 $i+2$ 的地方开始转移，中间的转移方程和之前一样，因为实际上 $i$ 并没有参与转移。

在统计答案的时候，因为前 $i$ 人已经举起海报，所以结尾能举起海报的人不超过 $3-i$ 个，所以答案是 $max\{f_{i,n,k}\}(k\leq3-i)$。


时间复杂度同样 $\mathcal{O}(n)$，~~和之前比只是常数大了点~~。

接下来将转移方程写成广义矩阵乘法的形式，然后就能套线段树愉快 DDP 了。

这里只写后两个维度的，第一个维度可以直接用四个矩阵代替。

$
\left[
\begin{array}{l}
f_{i-1,0} & f_{i-1,1} & f_{i-1,2} & f_{i-1,3}\\
\end{array}
\right]
\times
\left[
\begin{array}{l}
0 & a_i & -\infty & \infty\\
0 & -\infty & a_i & -\infty\\
0 & -\infty & -\infty & a_i\\
0 & -\infty & -\infty & -\infty\\
\end{array}
\right]=
\left[
\begin{array}{l}
f_{i,0} & f_{i,1} & f_{i,2} & f_{i,3}\\
\end{array}
\right]
$

要特殊设置开头的一部分矩阵，或着不去查询那一块地方。

修改时更新对应位置的矩阵，注意如果改的位置 $i \leq 3$，这个位置不会被修改，但一部分的初始化的矩阵会被修改。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int MaxN=40000,Fnf=-1e15;
int n,a[MaxN+1],q;
	
struct Matrix{
	Matrix(){}
	Matrix(const vector<vector<int> >&vec){
		for(int i=0;i<4;i++)
			for(int j=0;j<4;j++)
				mat[i][j]=vec[i][j];
	}
	int mat[4][4];
	int*operator[](int index){return mat[index];}
	const int*operator[](int index)const{return mat[index];}
	Matrix operator*(const Matrix&obj)const{
		Matrix res;
		for(int i=0;i<4;i++){
			for(int j=0;j<4;j++){
				res[i][j]=Fnf;
				for(int k=0;k<4;k++)
					res[i][j]=max(res[i][j],mat[k][j]+obj[i][k]);
			}
		}
		return res;
	}
};
struct Node{
	Matrix mat[4];
	int l,r;
}tree[MaxN*4+1];
int Left(int u){return u<<1;}
int Right(int u){return u<<1|1;}
void PushUp(int u){
	for(int i=0;i<4;i++)tree[u].mat[i]=tree[Left(u)].mat[i]*tree[Right(u)].mat[i];
}
void Update(int u){
	if(tree[u].l!=tree[u].r)return;
	int l=tree[u].l;
	for(int i=0;i<4;i++){
		if(l<=i){
			tree[u].mat[i]=vector<vector<int> >{
				{0	,Fnf,Fnf,Fnf},
				{Fnf,0	,Fnf,Fnf},
				{Fnf,Fnf,0	,Fnf},
				{Fnf,Fnf,Fnf,0	}
			};
		}else if(l==i+1){
			int sum=0;
			for(int j=1;j<=i;j++)sum+=a[j];
			tree[u].mat[i]=vector<vector<int> >{
				{sum,Fnf,Fnf,Fnf},
				{Fnf,0	,Fnf,Fnf},
				{Fnf,Fnf,0	,Fnf},
				{Fnf,Fnf,Fnf,0	}
			};
		}else{
			tree[u].mat[i]=vector<vector<int> >{
				{0	,0	,0	,0	},
				{a[l],Fnf,Fnf,Fnf},
				{Fnf,a[l],Fnf,Fnf},
				{Fnf,Fnf,a[l],Fnf}
			};
		}
	}
}
void Build(int u,int l,int r){
	tree[u].l=l,tree[u].r=r;
	if(l==r){
		Update(u);
		return;
	}
	int mid=(l+r)/2;
	Build(Left(u),l,mid);
	Build(Right(u),mid+1,r);
	PushUp(u);
}
void Modify(int u,int pos){
	if(pos<tree[u].l||tree[u].r<pos)return;
	if(tree[u].l==tree[u].r){
		Update(u);
		return;
	}
	Modify(Left(u),pos);
	Modify(Right(u),pos);
	PushUp(u);
}
int Calc(){
	int ans=0,sum=0;
	for(int i=0;i<4;i++){
		for(int k=0;k<4-i;k++)ans=max(ans,tree[1].mat[i][k][0]);
		sum+=a[i+1];
	}
	return ans;
}
void Solve(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	Build(1,1,n);
	cout<<Calc()<<'\n';
	cin>>q;
	for(int i=1;i<=q;i++){
		int u,v;
		cin>>u>>v;
		a[u]=v;
		Modify(1,u);
		if(u<4)for(int j=1;j<=4;j++)Modify(1,j);
		cout<<Calc()<<'\n';
	}
}
#undef int
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	Solve();
	return 0;
}
```

###### ~~后记：考试时把暴力 DP 附了上去保底结果特判没写对真保底了。~~

---

## 作者：zzxLLL (赞：1)


简单 DDP。

---

先考虑链上怎么做。

设 $f_{i, j}$ 表示前 $i$ 个旗子能达到的最大美观度，其中末尾有 $j$ 个旗子一定要举起来。转移方程显然：

$$f_{i, 0} = \max(f_{i - 1, 0}, f_{i - 1, 1}, f_{i - 1, 2}, f_{i - 1, 3})$$

$$f_{i, 1} = f_{i - 1, 0} + a_i$$

$$f_{i, 2} = f_{i - 1, 1} + a_i$$

$$f_{i, 3} = f_{i - 1, 2} + a_i$$

因为带修所以考虑 DDP。写成 $\max(+)$ 的广义矩阵乘法：

$$
\begin{bmatrix}
f_{i, 0} & f_{i, 1} & f_{i, 2} & f_{i, 3}
\end{bmatrix}
\begin{bmatrix}
0 & a_{i + 1} & -\inf & -\inf \\
0 & -\inf & a_{i + 1} & -\inf \\
0 & -\inf & -\inf & a_{i + 1} \\
0 & -\inf & -\inf & -\inf
\end{bmatrix}
=\begin{bmatrix}
f_{i + 1, 0} & f_{i + 1, 1} & f_{i + 1, 2} & f_{i + 1, 3}
\end{bmatrix}$$

对于链的情况，答案就是 $\max(f_{n, 0}, f_{n, 1}, f_{n, 2}, f_{n, 3})$。

对于环，直接断环为链，将 $a_1, a_2, \cdots, a_n$ 复制到 $a_{n + 1}, a_{n + 2}, \cdots, a_{2n}$。

显然 $a_n, a_1, a_2, a_3$ 中有一个必然不选，所以求出 $[1, n - 1], [2, n], [3, n + 1], [4, n + 2]$ 四个区间的矩阵乘积取 $\max$ 即可。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
const long long M = 1e5 + 10;
const long long inf = 1e16;

struct Matrix {
    long long a[4][4];
    Matrix() {
        for (long long i = 0; i < 4; i++)
            for (long long j = 0; j < 4; j++) a[i][j] = -inf;
    }
    const long long *operator[](long long x)const {
        return a[x];
    }
};

Matrix operator*(const Matrix A, const Matrix B) {
    Matrix C;
    for (long long i = 0; i < 4; i++)
        for (long long j = 0; j < 4; j++)
            for (long long k = 0; k < 4; k++)
                C.a[i][j] = std::max(C.a[i][j], A.a[i][k] + B.a[k][j]);
    return C;
}

long long n, q, a[M];

struct node {
    long long l, r;
    Matrix A;
}tr[M << 2];

void pushup(long long k) {
    tr[k].A = tr[k << 1].A * tr[k << 1 | 1].A;
}

void build(long long k, long long l, long long r) {
    tr[k].l = l, tr[k].r = r;
    if (l == r) {
        for (long long i = 0; i < 4; i++)
            for (long long j = 0; j < 4; j++) tr[k].A.a[i][j] = -inf;
        for (long long i = 0; i < 4; i++) tr[k].A.a[i][0] = 0;
        for (long long i = 1; i < 4; i++) tr[k].A.a[i - 1][i] = a[l];
        return;
    }
    long long mid = (l + r) >> 1;
    build(k << 1, l, mid);
    build(k << 1 | 1, mid + 1, r);
    pushup(k);
}

void modify(long long k, long long p, long long v) {
    if (tr[k].l == tr[k].r) {
        for (long long i = 0; i < 4; i++)
            for (long long j = 0; j < 4; j++) tr[k].A.a[i][j] = -inf;
        for (long long i = 0; i < 4; i++) tr[k].A.a[i][0] = 0;
        for (long long i = 1; i < 4; i++) tr[k].A.a[i - 1][i] = v;
        return;
    }
    long long mid = (tr[k].l + tr[k].r) >> 1;
    if (p <= mid) modify(k << 1, p, v);
    else modify(k << 1 | 1, p, v);
    pushup(k);
}

Matrix query(int k, int l, int r) {
    if (l <= tr[k].l && tr[k].r <= r) return tr[k].A;
    int mid = (tr[k].l + tr[k].r) >> 1;
    if (r <= mid) return query(k << 1, l, r);
    else if (l > mid) return query(k << 1 | 1, l, r);
    return query(k << 1, l, r) * query(k << 1 | 1, l, r);
}

Matrix K;
void print() {
    long long ans = 0;
    Matrix A = K * query(1, 1, n - 1);
    ans = std::max(ans, std::max(A[0][0], std::max(A[0][1], std::max(A[0][2], A[0][3]))));
    A = K * query(1, 2, n);
    ans = std::max(ans, std::max(A[0][0], std::max(A[0][1], std::max(A[0][2], A[0][3]))));
    A = K * query(1, 3, n + 1);
    ans = std::max(ans, std::max(A[0][0], std::max(A[0][1], std::max(A[0][2], A[0][3]))));
    A = K * query(1, 4, n + 2);
    ans = std::max(ans, std::max(A[0][0], std::max(A[0][1], std::max(A[0][2], A[0][3]))));
    printf("%lld\n", ans);
}

int main() {
    K.a[0][0] = 0;

    scanf("%lld", &n);
    for (long long i = 1; i <= n; i++) scanf("%lld", &a[i]);
    for (long long i = n + 1; i <= 2 * n; i++) a[i] = a[i - n];
    build(1, 1, 2 * n);
    print();

    scanf("%lld", &q);
    for (long long i = 1, x, y; q; q--) {
        scanf("%lld%lld", &x, &y);
        modify(1, x, y), modify(1, x + n, y);
        print();
    }
    return 0;
}
```

---

## 作者：include13_fAKe (赞：0)

我居然独立做出了这题？这题真的不是紫的难度啊。

暑假集训第一场考试 T1，洛谷上过了但校测 TLE 了。

一种不用 ddp 的做法，感觉比 ddp 强。

---

朴素线段树做法。

考虑在线段树上每一个节点开 $16$ 个答案统计。形如 $ans_{l,r}$，代表左边有 $l$ 个被选的位置，右边的 $r$ 个被选的位置的最优解。

合并两个块时，要考虑原先的状态是否合法、新的状态正确的 $(l,r)$ 的值。还要在每一层剪枝。

查询时查询第 $1$ 个块的答案即可，**注意只能查 $l+r<4$ 的部分**。我是直接写的 void 类型的 query 查询函数。

视 $n,q$ 同阶，理论时间复杂度为 $O(n\log n)$，但因为它在枚举 $l,r$ 时带了 $4^4=256$ 的常数，所以可能还没有有些 $O(n\sqrt n)$ 和 $O(n\log^2n)$ 的做法跑得快。

```cpp
#include<bits/stdc++.h>
#define int long long
#define mp(a,b) make_pair(a,b)
using namespace std;

inline int read(){
	int a=0,b=1;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-')	b=-1;
		c=getchar(); 
	}
	while(isdigit(c)){
		a=(a<<1)+(a<<3)+(c-'0');
		c=getchar();
	}
	return a*b;
}
inline void write(int x){
	if(x<0)	putchar('-'),x=-x;
	if(x>=10)	write(x/10);
	putchar(x%10+48);
}
inline void write1(int x){
	write(x),putchar(' ');
}
inline void write2(int x){
	write(x),putchar('\n'); 
}
struct node{
	int l,r;	//代表这里的区间 
	int ans[4][4];	//ans[x][y]  代表选取这里导致的左边有 x 个点 右边有 y 个点 总和不能大于 3  
}tree[2*114514];
int n,q;
int a[20*2025];	//40050 
void pushup(int id){
	int l=tree[id].l,r=tree[id].r; 
	int l1=tree[id*2].l,r1=tree[id*2].r;
	int l2=tree[id*2+1].l,r2=tree[id*2+1].r;
	for(int i=0;i<=3;i++){
		for(int j=0;j<=3;j++){
			tree[id].ans[i][j]=0;	//这种情况先初始化  
		}
	} 
	//接下来就是 [l1,l2] 和 [r1,r2] 的区间合并 
	//注意一种新的思路：一开始不考虑若干人走在一起的情况 等到询问时统一处理 
//	for(int i=0;i<=min(3,r1-l1+1);i++){
//		for(int j=0;j<=min(3,r2-l2+1);j++){
//			//仅需考虑中间两个 
//		}
//	} 
	for(int i=0;i<=min(3ll,r1-l1+1);i++){
		for(int j=0;j<=min(3ll,r1-l1+1);j++){
			//有一个地方必须剪枝：[i,j] 代表的区间不合法 
			if((i+j>(r1-l1+1))&&(i+j)<2*(r1-l1+1)){
//				if(id==2)	cout<<i<<' '<<j<<' ',cout<<"谭总的世界-031"<<endl;
				continue;	//这种情况区间不合法 直接忽略   
			}	
			if(i==(r1-l1+1)&&j==0){
//				if(id==2)	cout<<"谭总的世界-032"<<endl;
				continue;
			}
			if(j==(r1-l1+1)&&i==0){
//				if(id==2)	cout<<"谭总的世界-033"<<endl; 
				continue;	//剔除所有的不合法情况  
			}
			for(int i1=0;i1<=min(3ll,r2-l2+1);i1++){
				if(j+i1>=4)	continue;	//这种情况忽略考虑  
				for(int j1=0;j1<=min(3ll,r2-l2+1);j1++){
					if((i1+j1)>(r2-l2+1)&&(i1+j1)<2*(r2-l2+1))	continue;	//这也是不合法的区间 忽略  
					//接下来转移到的地方称为 [L,R] 注意改成了大写 
					if(i1==(r2-l2+1)&&j1==0)	continue;
					if(j1==(r2-l2+1)&&i1==0)	continue;	//这些情况都不合法 
					int L=0,R=0;	//初值实际上没有任何意义 只是一种摆设 
					if(i==(r1-l1+1)&&j==(r1-l1+1)){
						//代表这里左边是满的 
						L=i+i1;	//这就是左边的情况  
					} 
					else 	L=i;
					if(L>=4)	continue;	//也没有意义   
					if(i1==(r2-l2+1)&&j1==(r2-l2+1)){
						R=j+j1;
					}
					else	R=j1;	//最右侧的点 
					tree[id].ans[L][R]=max(tree[id].ans[L][R],tree[id*2].ans[i][j]+tree[id*2+1].ans[i1][j1]);
					//这是真正有用的转移的部分！  
				}
			}
		}
	}
} 
void build(int id,int l,int r){
	tree[id].l=l,tree[id].r=r;
	if(l==r){
		tree[id].ans[0][0]=0;
		tree[id].ans[1][1]=a[l];	//代表这里的取值系数  
		return;
	}
	int mid=l+r>>1;
	build(id*2,l,mid),build(id*2+1,mid+1,r);
	pushup(id);
}
void modify(int id,int x,int y){
	int l=tree[id].l,r=tree[id].r;
	if(l==r){
		tree[id].ans[0][0]=0;
		tree[id].ans[1][1]=y;	//直接处理成这样 
		return; 
	}
	int mid=l+r>>1;
	if(x<=mid)	modify(id*2,x,y);
	else	modify(id*2+1,x,y);
	pushup(id);
}
void query(){
	//全部都在 tree[1] 上询问 
	int include13=0;	//代表最终答案  
	for(int i=0;i<=3;i++){
		for(int j=0;j<=3;j++){
			if(i+j>=4)	continue;	//只考虑较小情况下的答案 
			include13=max(include13,tree[1].ans[i][j]); 
//			cout<<'#'<<i<<' '<<j<<' '<<tree[1].ans[i][j]<<endl;
		} 
	} 
	write2(include13);	//代表输出目前的解  
	return;
} 
signed main(){
	n=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
	}
	build(1,1,n);
//	cout<<'#'<<tree[4].ans[2][2]<<endl;
//	cout<<'#'<<tree[5].ans[1][1]<<endl;
//	cout<<'#'<<tree[2].ans[3][3]<<endl;
	query();	//把 query 处理成这种 void 函数 也是很妙的  
	q=read();
	while(q--){
		int x=read(),y=read();
		modify(1,x,y);
		query();
	} 
	putchar('\n');
	return 0;
}//全世界 好像只有我疲惫  
```

考试写完这题啥都写不动了，最终就等着 $100+0+12+0=112$ 的结尾。结果在学校 OJ 上 TLE 了，考试毁了……

---

## 作者：xxxxxzy (赞：0)

水题解。

弱智 ddp 题，写一下，先考虑序列，套路的，设 $f_{i,0/1/2/3}$ 为前 $i$ 个数，已经连续选了 $0/1/2/3$ 个数的贡献最大值，然后这东西直接 $(\max,+)$ 矩阵优化，讨论一下环，做完了。

翻了翻题解，比较有意思的是有个不用断环为链的做法，这里就不复述了。

时间 $O(nk^3 \log n)$，其中 $k=3$。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)
#define pii pair<ll, ll>
#define mp make_pair
#define pb push_back
#define ld lower_bound
#define rep(i, a, b) for (int i = (a); i <= (b); i++)
#define drep(i, a, b) for (int i = (a); i >= (b); i--)
#define ud upper_bound
#define mem(s, k) memset(s, k, sizeof(s))
#define fi first
#define se second
#define ull unsigned long long
#define vec vector <int>
#define fv inline void
#define fn inline static
#define cmin(x,y) (x=min(x,y))
#define cmax(x,y) (x=max(x,y))
using u16 = unsigned short; using u32 = unsigned; using u64 = unsigned ll; using u128 = __uint128_t;
using i16 = short; using i32 = ll; using i64 = ll; using i128 = __int128_t;
using db = double;
using namespace std;
const i32 N = 1e5 + 5;
struct matrix {
  i32 d[4][4];
  matrix() { mem(d, 0xcf); }
  i32* operator [](i32 x) { return d[x]; }
  inline friend matrix operator *(matrix a, matrix b) {
    matrix c;
    rep (i, 0, 3) rep (j, 0, 3) rep (k, 0, 3) c[i][j] = max(c[i][j], a[i][k] + b[k][j]);
    return c;
  }
} t[N << 2];
i32 n, a[N];
fv build(i32 p, i32 l, i32 r) {
  if (l == r) {
    t[p][0][0] = t[p][1][0] = t[p][2][0] = t[p][3][0] = 0;
    t[p][0][1] = t[p][1][2] = t[p][2][3] = a[l];
    return;
  }
  i32 mid = (l + r) >> 1;
  build(p << 1, l, mid), build(p << 1 | 1, mid + 1, r);
  t[p] = t[p << 1] * t[p << 1 | 1];
}
fv upd(i32 p, i32 x, i32 k, i32 l = 1, i32 r = n) {
  if (l > x || r < x) return ;
  if (l == r) {
    t[p][0][0] = t[p][1][0] = t[p][2][0] = t[p][3][0] = 0;
    t[p][0][1] = t[p][1][2] = t[p][2][3] = k;
    return ;
  }
  i32 mid = (l + r) >> 1;
  upd(p << 1, x, k, l, mid), upd(p << 1 | 1, x, k, mid + 1, r);
  t[p] = t[p << 1] * t[p << 1 | 1];
}
fn i32 qry() {
  matrix c = t[1]; i32 ans = 0;
  rep (i, 0, 3) ans = max(ans, c[i][i]);
  return ans; 
}
fv sol() {
  cin >> n;
  rep (i, 1, n) cin >> a[i];
  build(1, 1, n);
  i32 q; cin >> q;
  cout << qry() << "\n";
  rep (i, 1, q) {
    i32 x, k;
    cin >> x >> k;
    upd(1, x, k);
    cout << qry() << "\n";
  }
}
int main() {
  i32 T = 1;
  while (T--) sol();
}
```

---


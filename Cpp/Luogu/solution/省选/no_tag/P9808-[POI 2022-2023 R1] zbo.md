# [POI 2022/2023 R1] zbo

## 题目背景

题目译自 [POI2022~2023R1 zbo](https://sio2.mimuw.edu.pl/c/oi30-1/p/zbo/)。

## 题目描述

远古时期有一个国王，他统治了 $n$ 个村庄，这些村庄以 $n-1$ 条道路连接，原来的国王城堡在 $1$ 号村庄。

国王的儿子不久就要成年了，作为成年的王子们，其需要自己的城堡，所以在一些村庄会有**新的城堡**。

每座城堡都需要进行通讯，但是无奈距离太过遥远，为此，每个城堡每天都会派出若干个信鸽，向其他每个城堡发送消息。一只信鸽每行驶一公里就要吃一克谷物。

请你实现一个程序，求出按照输入顺序建造的每个城堡建造完之后所有城堡都能通讯的最少花费谷物数量。

具体的，定义 $dis(x,y)$ 为 $x$ 到 $y$ 所花费的谷物数，求每个城堡 $i$ 建造完后的 $\sum ^{i} _{x=1} \sum ^{i}_{y=1} dis(x,y)$。

注意上述式子默认两个相同的地点所花费为 $0$。

## 说明/提示

子任务分配如下：

| 子任务编号 | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: |
| $1$ | $n \cdot k \leq 10^5$ | $15$ |
| $2$ | 村庄是一条从 $1$ 到 $n$ 的链 | $35$ |
| $3$ | 无特殊性质 | $50$ |

本题中，子任务 $0$ 为样例。

## 样例 #1

### 输入

```
5 3
1 4 3
3 1 6
1 2 5
4 5 1
5
3
2```

### 输出

```
8
40
90
```

# 题解

## 作者：Hoks (赞：9)

## 前言
美妙树剖，比较套路了吧，反正一眼秒了。

原本不想补题解的，但是做到这题还是我的**御用纯情娇羞可爱内向小男娘** Loser_Syx 把这题推给我了捏。

[博客](https://www.luogu.com.cn/blog/Hok/solution-p9808)内食用更佳。
## 思路分析
题目这么大个式子摆在眼前肯定先考虑~~暴力~~化简下啊。

题目给定的一个函数外面再套求和肯定是不太好做的，所以考虑先拆里面。

里面的直接使用树上距离公式就行了（注意这里的深度是指到根节点的距离）。

$$dis(x,y)=dep_x+dep_y-2\times dep_{LCA(x,y)}$$

用这个式子就可以把之前那个又臭又长的式子破开成为：

$$\sum\limits_{i=1}^k\sum\limits_{j=1}^k dep_{a_i}+dep_{a_j}-2\times dep_{LCA(a_i,a_j)}$$

然后把这里面好算的东西拿出来破开：

$$2\times(k-1)\times \sum\limits_{i=1}^kdep_{a_i}-4\times\sum\limits_{i=1}^k\sum\limits_{j=i+1}^kdep_{LCA(a_i,a_j)}$$

（虽然我感觉很惊讶，但是另一篇题解后面的这个系数好像写错了，应该是 $4$，原因是把从 $1$ 开始变为从 $i+1$ 开始应该再乘上一个 $2$ 的系数。）

然后把前面一坨和后面那一坨分开，也就是令 

$ans1=\sum\limits_{i=1}^kdep_{a_i},ans2=\sum\limits_{i=1}^k\sum\limits_{j=i+1}^kdep_{LCA(a_i,a_j)}$。

然后前面那玩意很好维护了，出新点的时候直接加上这个点即可。

重点则在后面这一块怎么求。

首先思考下这一坨他在树上的意义是什么？

是根到他们 LCA 的距离吗？（那不是说了和说了一样。）

所以考虑为什么我们可以把 $dis(x,y)$ 拆开的原因。

那他的意义即为：$1\rightarrow a_i,1\rightarrow a_j$ 路径相交的长度。

路径相交？那我们便可以在把一个村庄 $i$ 变为新的城堡后把 $1\rightarrow i$ 上的路径的边权全部倍数 $+1$。

查询的时候只要直接询问 $1\rightarrow i$ 上的路径长度求出来加入 $ans2$ 中即可。

具体细节见又臭又长的代码了。
## 代码
```cpp
#include<bits/stdc++.h>
#define ls (p<<1)
#define rs (p<<1|1)
#define mid ((l+r)>>1) 
#define int long long
using namespace std;
const int N=200010,INF=0x3f3f3f3f3f3f3f3f;
struct edge
{int v,nxt,w;}e[N<<1];
int n,k,tot,cnt,ans1,ans2;
int head[N],top[N],id[N],dfn[N],a[N];
int fa[N],dep[N],son[N],si[N];
int lz[N<<2],s[N<<2],re[N<<2];
static char buf[1000000],*paa=buf,*pd=buf;
#define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
inline int read(void){
    int x(0),a(1);char fc(getchar());
    while(!isdigit(fc)){if(fc=='-') a=-1;fc=getchar();}
    while(isdigit(fc)) x=(x<<1)+(x<<3)+(fc^48),fc=getchar();
    return x*a;
}
inline void print(int x)
{
	if(x<0) putchar('-'),x=-x;
	if(x>9) print(x/10);
	putchar(x%10+'0');
}
void add(int u,int v,int w){e[++tot].v=v,e[tot].nxt=head[u],head[u]=tot,e[tot].w=w;}
void dfs1(int u,int ff)
{
	fa[u]=ff,si[u]=1;
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==ff) continue;
		a[v]=e[i].w;dep[v]=dep[u]+a[v];
		dfs1(v,u);si[u]+=si[v];
		if(si[v]>si[son[u]]) son[u]=v;
	}
}
void dfs2(int u,int topf)
{
	top[u]=topf,dfn[u]=++cnt,id[cnt]=a[u];
	if(son[u]) dfs2(son[u],topf);
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==son[u]||v==fa[u]) continue;
		dfs2(v,v);
	}
}
void pushdown(int p){lz[ls]+=lz[p],lz[rs]+=lz[p],re[ls]+=s[ls]*lz[p],re[rs]+=s[rs]*lz[p],lz[p]=0;}
void build(int p,int l,int r)
{
	if(l==r) return void(s[p]=id[l]);
	build(ls,l,mid),build(rs,mid+1,r);s[p]=s[ls]+s[rs];
}
void modify(int p,int l,int r,int st,int ed)
{
	if(l>ed||r<st) return;
	if(l>=st&&r<=ed) return void(lz[p]++),void(re[p]+=s[p]);pushdown(p);
	modify(ls,l,mid,st,ed);modify(rs,mid+1,r,st,ed);re[p]=re[ls]+re[rs];
}
int query(int p,int l,int r,int st,int ed)
{
	if(l>ed||r<st) return 0;if(l>=st&&r<=ed) return re[p];
	pushdown(p);return query(ls,l,mid,st,ed)+query(rs,mid+1,r,st,ed);
}
signed main()
{
    n=read(),k=read();
    for(int i=1,u,v,w;i<n;i++) u=read(),v=read(),w=read(),add(u,v,w),add(v,u,w);
    dfs1(1,0),dfs2(1,1);build(1,1,n);ans1+=dep[1];
	ans2+=query(1,1,n,dfn[1],dfn[1]);modify(1,1,n,dfn[1],dfn[1]);
    for(int i=1,x;i<=k;i++)
    {
    	x=read();ans1+=dep[x];
		while(x)
		{
			ans2+=query(1,1,n,dfn[top[x]],dfn[x]);
			modify(1,1,n,dfn[top[x]],dfn[x]);
			x=fa[top[x]];
		}print(2*ans1*i-ans2*4);puts("");
	}
    return 0;
}
```


---

## 作者：NATO (赞：8)

#### 写在前面：

这是不久前笔者与以前的同学胡的一个对于单次询问形如 $\sum\limits_{i=l1}^{r1}\sum\limits_{j=l2}^{r2}val(lca(id_i,id_j))$ 的通用在线 $O(q\sqrt n+n\sqrt n)$ 解法，其中 $id$ 是一个预先给定的对应点编号的任意序列，$val(lca(id_i,id_j))$ 是一个只与 $lca(id_i,id_j),id_i,id_j$ 有关的一个值。

本做法的优势在于不需要使用任何除了“$val(lca(id_i,id_j))$ 是 $lca(id_i,id_j)$ 的 $val$”以外与 $val(lca(id_i,id_j))$ 相关的任何性质，普遍性很强，且不需要进行任何化简，思维上简单粗暴。

后发现在一些题中均有类似解法，但写得没有那么清晰。遂决定在此作文以较为详细地介绍此类解法。

要充分理解此文，您可能需要的前置知识：

分块、常见换根 DP 的用法、任意方法实现的 $O(1)$ 查询 LCA、单调栈建虚树。
### 思路浅析：

让我们从另外一道题谈起。

[P4211](https://www.luogu.com.cn/problem/P4211)，这道题题解区中的[第三篇题解](https://www.luogu.com.cn/article/bojdj3gs)提出了一种不同于一般 $O(n \log n^2)$ 的 $O(n\sqrt n)$ 的解法。

其解法即是按编号分块，每次将一个块中的节点标记，然后遍历一遍树，预处理出每个节点子树内被标记的点的数量（下称 $i$ 点子树内被标记的点的数量为 $size_i$），再做一遍换根 DP，预处理出 $i\in\{1,2,...,n\},\sum\limits_{j=l}^{r}val(lca(i,id_j))$ 的值（在上题中即是 $\sum\limits_{j=l}^{r}dep(lca(i,j))$ 的值，其中 $l,r$ 指一个块的边界），再对每个点存的块的答案做一遍前缀和。

具体解释一下上文的换根 DP，当我们换到一个节点 $k$ 时，我们此时即是在求出 $\sum\limits_{j=l}^{r}val(lca(k,id_j))$ 的值，我们将这个东西分作两个部分考虑：第一个部分就是在 $k$ 子树内的所有被标记的点，这个部分的 LCA
 就是 $k$ 点本身，是容易统计的；第二个部分即 $k$ 子树外的点，这个部分的答案可以在向下转移时传一个值进行记录，即从一个点 $u$ 转移到 $v$，那么显然 $u$ 子树内除了 $v$ 子树内的标记点与 $v$ 子树内任意一个点的 LCA 即是 $u$，那么给下传的值加上一个 $(sz_u-sz_v)val(u)$ 即可。 
 
对于一个询问 $l,r,z$，调用 $z$ 对应的前缀和答案差分一下，求出 $[l,r]$ 间的整块与 $z$ 的答案，散块使用 $O(1)$ 查询的 LCA 暴力查询即可。

总结一下上述过程，实际上我们就是通过分块和换根 DP 尽可能地在可接受的范围内预处理出尽可能多的答案，这样在询问时就可以对少数“边角料”用相对暴力的方法解决了。

上述即是对该题解内容的详细展开，为的是引出解决 $\sum\limits_{i=l1}^{i=r1}\sum\limits_{j=l2}^{r2}val(lca(id_i,id_j))$ 的解法（~~这难道不就是解法的绝大部分思路吗~~）。

现在让我们把视线回到 $\sum\limits_{i=l1}^{i=r1}\sum\limits_{j=l2}^{r2}val(lca(id_i,id_j))$。

我们发现，我们需要解决的问题的形式与 P4211 的形式只是多了一层求和罢了。考虑继续沿用分块的思路，整块对整块、整块对散块和散块对整块均可以很容易地用我们预处理的点对块的答案作前缀和后差分求得，这里不展开，相信读者若是明白了上文分块和换根 DP 在干什么的话是能够轻松实现的。

但是瓶颈在于散块对散块的贡献，我们发现用预处理的答案是无法解决的，而暴力枚举点对的做法显然是会使单次询问复杂度退化为 $O(n)$ 的，该怎么办呢？

我们先不谈分块，回顾一下刚才的换根 DP，我们还可以发现一种 $O(nq)$ 的做法，即将 $[l2,r2]$ 的点标记一下，再像分块预处理那样做换根 DP，在树上 $[l1,r1]$ 的位置统计答案即可。

让我们仔细考虑这个过程，容易发现只有在 $[l2,r2]$ 两两间 LCA 是可能导致换根记录的答案发生变化的。emm...只有关键点和其 LCA 有用，这不是暗示我们建虚树吗！

（下设 $len$ 为 $[l1,r1],[l2,r2]$ 区间总长度）于是我们将 $[l1,r1],[l2,r2]$ 的点建虚树后再跑换根（这里假设可以 $O(len)$ 建虚树），复杂度单次就变为了 $O(len)$ 的！

回到我们要解决的散块对散块，我们发现只要能 $O(len)$ 建虚树问题就解决了，毕竟当块大小为 $O(\sqrt n)$ 时，散块中数的个数是 $O(\sqrt n)$ 的嘛。

~~翻阅 OI Wiki 可以得知~~我们知道一种按 dfs 序排序后使用单调栈建虚树的方法，但排序仍然是 $O(len\log len)$。尝试利用我们的分块来优化排序的过程，考虑对块内按 dfs 序排序，询问时对着四个散块排序后对应的块扫一遍合并即可完成排序的工作，然后用单调栈的做法就可以愉快地在 $O(len)$ 的复杂度内建虚树啦（~~温馨提示：您的常数已上天~~）。

然后和上文预处理时类似地跑个换根 DP 统计贡献即可。

至此，我们就完成了散块对散块这一瓶颈，于是当块长取到 $O(\sqrt n)$ 时整个问题便可以以 $O(n\sqrt n)$ 的时间复杂度解决了。

不过这个玩意有着显而易见的缺点：

1. 如果块长取到 $O(\sqrt n)$  的话，不逐块处理空间复杂度同样高达 $O(n\sqrt n)$。

2. 代码难度极高，很容易写错。

3. 常数巨大，以致于可能跑起来比 $O(n\sqrt n\log n)$ 还慢。

4. ~~容易被某些情况下存在的 $\text{polylog}$ 做法乱杀。~~



~~综上所述，本做法就是彻彻底底的小丑做法，建议立刻枪决笔者。~~

好啦，让我们回过头来看看这篇文章投的题目该怎么做吧，写出形式化题面，即：

规定 $id_1=1$，给出 $id_2,id_3,...,id_{m+1}$ 的值，对于 $r=2,3,...,m+1$ 分别求出下式的值：

$\sum\limits_{i=1}^{r}\sum\limits_{j=1}^{r}dis(id_i,id_j)$ 

我们发现中间不是我们想要的 $val(lca(id_i,id_j))$ 的形式，简单拆一拆即可：

$\sum\limits_{i=1}^{r}\sum\limits_{j=1}^{r}dis(id_i,id_j)=\sum\limits_{i=1}^{r}\sum\limits_{j=1}^{r}dis(id_i,1)+dis(id_j,1)-2dis(lca(id_i,id_j),1)$

$\sum\limits_{i=1}^{r}\sum\limits_{j=1}^{r}dis(id_i,1)+dis(id_j,1)$ 相信只要是个 OIer 都能知道是 $\sum\limits_{i=1}^{r}2dis(id_i,1)r$，简单预处理一下即可。而 $-2dis(lca(id_i,id_j),1)$ 这一部分就完全和我们 $val(lca(id_i,id_j))$ 相符，套用我们的~~宇宙无敌究极大常数~~做法即可。

不过直接块长开 $O(\sqrt n)$ 空间会原地飞升的，实测开个[四](https://www.luogu.com.cn/record/163877271)[五百](https://www.luogu.com.cn/record/163877158)再加点卡常小技巧都是能过的，笔者的一些技巧如下：

1. 注意到分块换根时会递归搜索很多遍，考虑用 dfs 序干掉递归：
	- 对于统计子树内关键点个数，按 dfs 序倒着来即可；
   - 对于从根节点开始换根，记录一下每个节点需要向下转移的值，按 dfs 序正着来即可。

2. 注意到本题只有后面有真正意义上的散块，就别把第一块当作散块计算了，只用后面的部分建虚树。

用了它们，就可以健康地卡入时限啦。

更进一步的卡常和对空间复杂度的优化可参看本文的[姊妹篇](https://www.luogu.com.cn/article/ioxhwzdv)。

#### 参考代码：

如果对前面的某步有不理解的地方，相信结合代码食用应该都能理解吧（代码中本解法的奇怪函数都注释了的，而且本做法思维难度已经低得不能再低了吧）。

4k 超长代码警告。。。

```cpp
#include <bits/stdc++.h>
#define ll int
#define INF 2100000000ll
using namespace std;
ll n,m,ss;
ll from[100005],L[251],R[251];
ll head[100005],cnt;
long long val[100005][251],btb[251][251];
ll id[100005],yid[100005];
ll to[100005];
long long sz[100005],ds[100005],dv[100005],ps[100005];
long long order_leaf[100005],order_root[100005],mf[100005],in[100005];
queue<long long>q;
struct ed
{
	ll w,v,next;
}edge[200005];
void add(ll u,ll v,ll w)
{
	edge[++cnt].v=v;edge[cnt].next=head[u];head[u]=cnt;edge[cnt].w=w;
	edge[++cnt].v=u;edge[cnt].next=head[v];head[v]=cnt;edge[cnt].w=w;
}
ll tot,f[200005][20],dep[100005],dfn[100005],lg[200005];
void dfs(ll id,ll fa)
{
	f[dfn[id]=++tot][0]=id;mf[id]=fa;
	for(ll i=head[id];i;i=edge[i].next)
	{
		ll v=edge[i].v,w=edge[i].w;
		if(v==fa)continue;
		dep[v]=dep[id]+1;dv[v]=dv[id]+w;
		dfs(v,id);
		f[++tot][0]=id;
	}
}
ll vis[100005];
void pre(ll id,ll fa)
{
	sz[id]=(vis[id]==2);ds[id]=(vis[id]==2)*dv[id];
	for(ll i=head[id];i;i=edge[i].next)
	{
		ll v=edge[i].v;
		if(v==fa)continue;
		pre(v,id);
		sz[id]+=sz[v];ds[id]+=ds[v];
	}
}//建虚树时的子树内关键点个数处理
long long bv[100005];
void pres()
{
	for(ll i=1;i<=n;++i)sz[i]=0,ds[i]=0,bv[i]=0; 
	for(ll i=1;i<=n;++i)
	{
		ll id=order_leaf[i];
		sz[id]+=(vis[id]==2);ds[id]+=(vis[id]==2)*dv[id];
		sz[mf[id]]+=sz[id];
		ds[mf[id]]+=ds[id];          
	}
}//预处理时的子树内关键点个数处理
void root(ll which_block)
{
	for(ll i=1;i<=n;++i)
	{
		ll id=order_root[i];
		bv[id]=bv[mf[id]]+dv[mf[id]]*(sz[mf[id]]-sz[id]);
		if(to[id])val[to[id]][which_block]=bv[id]+sz[id]*dv[id];
	}
}//预处理时的换根 DP
ll lca(ll u,ll v)
{
	ll un=dfn[u],vn=dfn[v];
	if(un>vn)swap(un,vn);
	ll leg=lg[vn-un+1];
	return dep[f[un][leg]]<dep[f[vn-(1<<leg)+1][leg]]?f[un][leg]:f[vn-(1<<leg)+1][leg];
}//欧拉序求 LCA
ll cmp(ll a,ll b)
{
	return dfn[a]<dfn[b];
}
ll use[805];
long long res;
ll st[805],a;
bool vs[100005];
void block_rt(ll id,ll fa,long long before_val)
{
	if(vs[id])
	res+=before_val+sz[id]*dv[id];
	for(ll i=head[id];i;i=edge[i].next)
	{
		ll v=edge[i].v;
		if(v==fa)continue;
		block_rt(v,id,before_val+(sz[id]-sz[v])*dv[id]);
	}
}//建虚树后的换根
int main()
{
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>m;
	ll u,v,w;
	for(ll i=2;i<=n;++i)cin>>u>>v>>w,add(u,v,w);
	id[1]=yid[1]=1;++m;
	for(ll i=2;i<=m;++i)cin>>id[i],to[yid[i]=id[i]]=i;
	dep[1]=1;
	dfs(1,0);
	for(ll i=1;i<=n;++i)++in[mf[i]];
	for(ll i=2;i<=n;++i)
		if(!in[i])q.push(i);
	ll cot=0;
	while(!q.empty())
	{
		ll id=q.front();q.pop();
		order_leaf[++cot]=id;
		for(ll i=head[id];i;i=edge[i].next)
		{
			ll v=edge[i].v;
			if(!--in[v])q.push(v);
		}
	}
	q.push(1);cot=0;
	while(!q.empty())
	{
		ll id=q.front();q.pop();
		order_root[++cot]=id;
		for(ll i=head[id];i;i=edge[i].next)
		{
			ll v=edge[i].v;
			if(v!=mf[id])
			q.push(v);
		}
	}//笔者脑抽用拓扑排序处理的非递归时的更新顺序，直接用 dfs 序即可。
	for(ll i=2;i<=tot;++i)lg[i]=lg[i>>1]+1;
	for(ll i=tot;i;--i)
		for(ll j=1;i+(1<<j)-1<=tot;++j)
			f[i][j]=(dep[f[i][j-1]]<dep[f[i+(1<<(j-1))][j-1]]?f[i][j-1]:f[i+(1<<(j-1))][j-1]);//预处理欧拉序求 LCA 用的 ST 表
	ss=400;
	for(ll i=1;i<=m;++i)from[i]=(i-1)/ss+1;
	for(ll i=1;i<=from[m];++i)L[i]=(i-1)*ss+1,R[i]=i*ss;
	R[from[m]]=m;
	for(ll i=1;i<=from[m];++i)
	{
		for(ll j=L[i];j<=R[i];++j)vis[id[j]]=2;
		pres();
		root(i);
		for(ll j=L[i];j<=R[i];++j)vis[id[j]]=0;
		sort(id+L[i],id+1+R[i],cmp);//块内按 dfs 序排序
	}//分块换根预处理
	memset(head,0,sizeof(head));cnt=0;
	for(ll i=1;i<=m;++i)
		for(ll j=1;j<=from[m];++j)
		val[i][j]+=val[i][j-1],btb[from[i]][j]+=val[i][j];//前缀和预处理整块对整块、散块对整块、散块对散块的答案
	for(ll i=1;i<=m;++i)ps[i]=ps[i-1]+dv[yid[i]];//前缀和本题加的那个 zz 距离
	ll l[3],r[3];
	dfn[0]=INF;
	for(ll t=2;t<=m;++t)
	{
		l[1]=1;r[1]=t;l[2]=1;r[2]=t;
		res=0;
		if(from[t]!=1)
		{
			for(ll i=from[l[1]];i<from[r[1]];++i)res+=btb[i][from[r[2]]-1];
			for(ll i=L[from[r[1]]];i<=r[1];++i)res+=val[i][from[r[2]]-1]*2ll;
		}
		for(ll i=L[from[r[2]]];i<=r[2];++i)vis[yid[i]]=2,vs[yid[i]]=1;
		ll dsc=0;
		for(ll i=L[from[r[2]]];i<=R[from[r[2]]];++i)if(vis[id[i]]==2)use[++dsc]=id[i];//这里由于散块部分相同，写起来相对简单得多，完整散块部分合并可参考下给出的云剪切板内的代码
		st[a=1]=1;head[1]=0;cnt=0;
		for(ll i=1;i<=dsc;++i)
		{
			if(use[i]!=1)
			{
				ll lc=lca(use[i],st[a]);
				if(lc!=st[a])
				{
					while(dfn[lc]<dfn[st[a-1]])
					add(st[a-1],st[a],abs(dv[st[a-1]]-dv[st[a]])),--a;
					if(dfn[lc]!=dfn[st[a-1]])head[lc]=0,add(lc,st[a],abs(dv[lc]-dv[st[a]])),st[a]=lc;
					else add(lc,st[a],abs(dv[lc]-dv[st[a]])),a--;
				}
				st[++a]=use[i],head[use[i]]=0;
			}
		}
		for(ll i=1;i<a;++i)add(st[i],st[i+1],abs(dv[st[i]]-dv[st[i+1]]));//单调栈建虚树
		pre(1,0);
		block_rt(1,0,0);
		for(ll i=L[from[r[1]]];i<=r[1];++i)vs[yid[i]]=vis[yid[i]]=0;
		cout<<(ps[t]*1ll*(r[1]-l[1]+1)-res)*2ll<<'\n';
	}
}
```
由于本题散块需要写的部分比真正完整的写法简单，故
下给出以 $dep$ 为例求 $\sum\limits_{i=l1}^{i=r1}\sum\limits_{j=l2}^{r2}val(lca(id_i,id_j))$ 的完整代码：

[戳这里](https://www.luogu.com.cn/paste/sbdjwlxx)

本文到此结束，感谢您的耐心阅读！

---

## 作者：a_small_penguin (赞：2)

这是蒟蒻的第一篇紫题题解。

暴力拆解即可。

定义 $i$ 为已修建城堡个数，$ans$ 是需要吃掉的谷子。

接下来开始拆式子！

$$
\begin{aligned}
    ans &= \sum^{i}_{x = 1} \sum^{i}_{y = 1} \operatorname{dis(x,y)} \\
    &= \sum^{i}_{x = 1} \sum^{i}_{y = 1} \operatorname{dis(x,1)} + \operatorname{dis(y,1)} - 2 \operatorname{dis(\operatorname{lca{(x,y)}},1)} \\
    &= \sum^{i}_{x = 1} \sum^{i}_{y = 1} \operatorname{dis(x,1)} + \sum^{i}_{x = 1} \sum^{i}_{y = 1} \operatorname{dis(y,1)} - 2 \sum^{i}_{x = 1} \sum^{i}_{y = 1}  \operatorname{dis(\operatorname{lca{(x,y)}},1)} \\
    &= 2i\sum^{i}_{x = 1} \operatorname{{dis(1, x)}} -  2\sum^{i}_{x = 1} \sum^{i}_{y = 1} \operatorname{dis(\operatorname{{lca(x,y)},1})} \\
    &= 2i\sum^{i}_{x = 1} \operatorname{{dis(1, x)}} -  4\sum^{i}_{x = 1} \sum^{i}_{y = x + 1} \operatorname{dis(\operatorname{{lca(x,y)},1})} - 2\sum^{i}_{x = 1} \operatorname{dis(1, x)} \\
    &= 2(i-1)\sum^{i}_{x = 1} \operatorname{{dis(1, x)}} -  4\sum^{i}_{x = 1} \sum^{i}_{y = x + 1} \operatorname{dis(\operatorname{{lca(x,y)},1})}
\end{aligned}
$$

$$\text{令} a = \sum^{i}_{x = 1} \operatorname{{dis(1, x)}},b= \sum^{i}_{x = 1} \sum^{i}_{y = x + 1} \operatorname{dis(\operatorname{{lca(x,y)},1})}$$

那么，$ans = 2a(i-1) - 4b$，对于多出的城堡 $a$ 直接计算。$b$ 用类似 [P4211 LCA](https://www.luogu.com.cn/problem/P4211) 的思路进行维护。

唯四区别是：

- 加的不是点权，而是点权的常数。
- 查询是查询常数 $\times$ 点权。 
- 线段树还要维护一个点权和。
- 改变 $a,b$，再对于 $1 \to x$ 的路径进行加常数。

code：
```cpp
#include <bits/stdc++.h>
using namespace std;

#define N 100009
#define int long long
#define ls(i) (i << 1)
#define rs(i) ((i << 1) | 1)
#define sp(i, j) i ^= j, j ^= i, i ^= j
#define mod 0x7fffffffffffffff
#define qj(i, x) tree[i].d += x * tree[i].a, tree[i].lazy += x
#define pd(i) qj(ls(i), tree[i].lazy), qj(rs(i), tree[i].lazy), tree[i].lazy = 0
struct V
{
    vector<int> e;
    int size, top, h, d, id, fa, son;
} v[N];
int rk[N], n, m, res, r;
namespace xds
{
    struct TREE
    {
        int d, lazy, l, r, a;
    } tree[(N << 2)];
    void build(int i, int l, int r)
    {
        tree[i].l = l, tree[i].r = r;
        if (l == r)
        {
            tree[i].a = v[rk[l]].d;
            return;
        }
        int mid = (l + r) >> 1;
        build(ls(i), l, mid), build(rs(i), mid + 1, r), tree[i].a = tree[ls(i)].a + tree[rs(i)].a;
    }
    int ask(int i, int l, int r)
    {
        if (l <= tree[i].l && tree[i].r <= r)
            return tree[i].d;
        if (tree[i].lazy)
            pd(i);
        int d = 0, mid = (tree[i].l + tree[i].r) >> 1;
        if (l <= mid)
            d += ask(ls(i), l, r);
        if (mid < r)
            d += ask(rs(i), l, r);
        return d;
    }
    int dis(int i, int l, int r)
    {
        if (l <= tree[i].l && tree[i].r <= r)
            return tree[i].a;
        int d = 0, mid = (tree[i].l + tree[i].r) >> 1;
        if (l <= mid)
            d += dis(ls(i), l, r);
        if (mid < r)
            d += dis(rs(i), l, r);
        return d;
    }
    void add(int i, int l, int r, int k)
    {
        if (tree[i].r <= r && tree[i].l >= l)
        {
            qj(i, k);
            return;
        }
        if (tree[i].lazy)
            pd(i);
        if (tree[ls(i)].r >= l)
            add(ls(i), l, r, k);
        if (tree[rs(i)].l <= r)
            add(rs(i), l, r, k);
        tree[i].d = tree[ls(i)].d + tree[rs(i)].d;
    }
}
void dfs(int u, int fa, int h)
{
    v[u].h = h, v[u].fa = fa, v[u].size = 1;
    int cnt = -114514;
    for (auto to : v[u].e)
    {
        if (to == fa)
            continue;
        dfs(to, u, h + 1);
        v[u].size += v[to].size;
        if (cnt < v[to].size)
            v[u].son = to, cnt = v[to].size;
    }
}
void dfs2(int u, int top)
{
    v[u].top = top, v[u].id = ++res, rk[res] = u;
    if (!v[u].son)
        return;
    dfs2(v[u].son, top);
    for (auto to : v[u].e)
        if ((to ^ v[u].son) && (to ^ v[u].fa))
            dfs2(to, to);
}
void add(int x, int y)
{
    while (v[x].top ^ v[y].top)
    {
        if (v[v[x].top].h < v[v[y].top].h)
            sp(x, y);
        xds::add(1, v[v[x].top].id, v[x].id, 1), x = v[v[x].top].fa;
    }
    if (v[x].id > v[y].id)
        sp(x, y);
    xds::add(1, v[x].id, v[y].id, 1);
}
int ask(int x, int y)
{
    int ans = 0;
    while (v[x].top ^ v[y].top)
    {
        if (v[v[x].top].h < v[v[y].top].h)
            sp(x, y);
        ans += xds::ask(1, v[v[x].top].id, v[x].id), ans, x = v[v[x].top].fa;
    }
    if (v[x].id > v[y].id)
        sp(x, y);
    ans += xds::ask(1, v[x].id, v[y].id);
    return ans;
}
int dis(int x, int y)
{
    int ans = 0;
    while (v[x].top ^ v[y].top)
    {
        if (v[v[x].top].h < v[v[y].top].h)
            sp(x, y);
        ans += xds::dis(1, v[v[x].top].id, v[x].id), ans, x = v[v[x].top].fa;
    }
    if (v[x].id > v[y].id)
        sp(x, y);
    ans += xds::dis(1, v[x].id, v[y].id);
    return ans;
}

int _u[N];
int _v[N];
int _w[N];
int A, B;

signed main()
{

    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> n >> m;
    for (int i = 1; i < n; i++)
    {
        cin >> _u[i] >> _v[i] >> _w[i];
        v[_u[i]].e.push_back(_v[i]);
        v[_v[i]].e.push_back(_u[i]);
    }
    dfs(1, 0, 1);
    dfs2(1, 1);
    for (int i = 1; i < n; i++)
    {
        if (v[_u[i]].h > v[_v[i]].h)
            sp(_u[i], _v[i]);
        v[_v[i]].d = _w[i];
    }
    xds::build(1, 1, n);
    add(1, 1);
    for (int i = 1; i <= m; i++)
    {
        int x;
        cin >> x;
        A += dis(1, x);
        B += ask(1, x);
        cout << 2 * i * A - 4 * B << "\n";
        add(1, x);
    }

    return 0;
}
```

---

## 作者：zzhbpyy (赞：2)

### [题目传送门](https://www.luogu.com.cn/problem/solution/P9808)
## 思路
其他的两篇题解已经说的很清楚，所求的答案和式可化简为：
$$(2k - 2) \times \sum _ {i = 1} ^ n dep_{i}- 4 \times \sum _ {i = 1} ^ k \sum _ {j = i + 1} ^ k dep_{LCA(i, j)}$$
此处不再赘述。与此题类似的有 [P4211](https://www.luogu.com.cn/problem/P4211)，容易发现两道题目的相同点：都是通过对复杂和式的拆解，将不容易求得的两点距离，转化为容易获取的 LCA、到根的距离等子问题。同时，此处的和式化简也告诉我们树上距离与 LCA 的奇妙转化关系。

我们解决一道题目，不能因为 AC 了就不了了之，而是应该学习其解法的精髓。

但是，对 $\sum _ {i = 1} ^ k \sum _ {j = i + 1} ^ k dep_{LCA(i, j)}$ 的处理也需要一定技巧。先将所有的边权设为 $0$。我们可以从每一个城堡的位置出发，将其到根节点的路径全部进行“染色”，也就是把每条边的边权加上原来的边权。然后每次累加城堡到根的距离，可以发现路径重复部分累加的结果就是所要求得的上式，采用重链剖分进行维护即可。

## 完整代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define lr(x) (x<<1)
#define rr(x) (x<<1|1)
using namespace std;
struct Edge{
	int u,v,w,nxt;
}a[200005];
int ct,head[100005];
inline void add(int u,int v,int w){
	a[++ct]={u,v,w,head[u]};
	head[u]=ct;
}
int f[100005],dep[100005],si[100005],son[100005];
void dfs1(int u,int fa){
	dep[u]=dep[fa]+1,si[u]=1,f[u]=fa;
	for(int i=head[u];i;i=a[i].nxt){
		int v=a[i].v;
		if(v==fa)continue;
		dfs1(v,u);si[u]+=si[v];
		if(si[son[u]]<si[v])son[u]=v;
	}
}
int top[100005],w[100005],id[100005],cnt,dfn[100005];
void dfs2(int u,int topf){
	top[u]=topf,dfn[u]=++cnt,id[cnt]=u;
	if(son[u])dfs2(son[u],topf);
	for(int i=head[u];i;i=a[i].nxt){
		int v=a[i].v;
		if(v==f[u])continue;
		w[v]=a[i].w;
		if(v==son[u])continue;
		dfs2(v,v);
	}
}
int n,k,tr[400005],tag[400005],yuan[400005];//yuan指原边权，tr 指现在的边权
inline void pushup(int p){
	tr[p]=tr[lr(p)]+tr[rr(p)];
}
inline void ff(int p,int l,int r,int d){
	tag[p]+=d;
	tr[p]+=d*yuan[p];
}
inline void pushdown(int p,int l,int r){
	int mid=(l+r)>>1;
	if(!tag[p])return;
	ff(lr(p),l,mid,tag[p]);
	ff(rr(p),mid+1,r,tag[p]);
	tag[p]=0;
}
void build(int p,int l,int r){
	if(l==r){
		yuan[p]=w[id[l]];
		return;
	}
	int mid=(l+r)>>1;
	build(lr(p),l,mid);
	build(rr(p),mid+1,r);
	yuan[p]=yuan[lr(p)]+yuan[rr(p)];
}
inline void add(int p,int l,int r,int x,int y){
	if(x<=l&&r<=y){
		ff(p,l,r,1);
		return;
	}
	int mid=(l+r)>>1;
	pushdown(p,l,r);
	if(x<=mid)add(lr(p),l,mid,x,y);
	if(y>mid)add(rr(p),mid+1,r,x,y);
	pushup(p);
}
inline int query(int p,int l,int r,int x,int y){
	if(x<=l&&r<=y){
		return tr[p];
	}
	int mid=(l+r)>>1,ans=0;
	pushdown(p,l,r);
	if(mid>=x)ans+=query(lr(p),l,mid,x,y);
	if(mid<y)ans+=query(rr(p),mid+1,r,x,y);
	return ans;
}
inline int query1(int p,int l,int r,int x,int y){
	if(x<=l&&r<=y)
		return yuan[p];
	int mid=(l+r)>>1,ans=0;
	pushdown(p,l,r);
	if(mid>=x)ans+=query1(lr(p),l,mid,x,y);
	if(mid<y)ans+=query1(rr(p),mid+1,r,x,y);
	return ans;
}
inline int query(int x,int y){
	int ans=0;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		ans+=query(1,1,n,dfn[top[x]],dfn[x]);
		x=f[top[x]];
	}
	if(dep[x]>dep[y])swap(x,y);
	ans+=query(1,1,n,dfn[x]+1,dfn[y]);
	return ans;
}
inline int query1(int x,int y){
	int ans=0;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		ans+=query1(1,1,n,dfn[top[x]],dfn[x]);
		x=f[top[x]];
	}
	if(dep[x]>dep[y])swap(x,y);
	ans+=query1(1,1,n,dfn[x]+1,dfn[y]);
	return ans;
}
inline void add(int x,int y){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		add(1,1,n,dfn[top[x]],dfn[x]);
		x=f[top[x]];
	}
	if(dep[x]>dep[y])swap(x,y);
	add(1,1,n,dfn[x]+1,dfn[y]);
}
int a1,a2,d;
signed main(){
	ios::sync_with_stdio(0);cin.tie(nullptr);cout.tie(nullptr);
	cin>>n>>k;int x,y,z;
	for(int i=1;i<n;i++){
		cin>>x>>y>>z;
		add(x,y,z);
		add(y,x,z);
	}
	dfs1(1,0);dfs2(1,1);
	build(1,1,n);
	for(int i=1;i<=k;i++){
		cin>>d;
		a1+=query1(1,d);
		a2+=query(1,d);
		add(1,d);
		cout<<2*i*a1-4*a2<<'\n';
	}
	return 0;
}
```

---

## 作者：_lbw_ (赞：2)

我们要求 $\sum\limits_{i=1}^k\sum\limits_{j=1}^k dis(p_i,p_j)$，就不能只是求它，而应该转化为：

$$2\times(k-1)\times \sum\limits_{i=1}^kdep_{p_i}-2\times\sum\limits_{i=1}^k\sum\limits_{j=i+1}^kdep_{\textsf{LCA}(p_i,p_j)}$$

前面一项非常简单，后面一项可以考虑拆成每条边的贡献，即为 $p_i,p_j$ 到根的路径交的权值之和，每组点对的贡献在 $j$ 处统计，于是即为链加链求权值乘贡献之和，树剖/LCT 即可。

时间复杂度 $\mathcal{O}(n+k\log^2n)$。

```cpp
IV print(i64 x){
	if(x>9)print(x/10);
	putchar(x%10+'0');
}
const int maxn = 1e6+5;vector<pair<i64,i64> >g[maxn];
i64 n,k,dfn[maxn],low[maxn],top[maxn],fa[maxn],son[maxn],siz[maxn],dep[maxn],val[maxn],dft,ni[maxn];
IV dfs(i64 u,i64 F){
	siz[u]=1;fa[u]=F;
	for(auto[v,w]:g[u])if(v^F){
		dep[v]=dep[u]+w;val[v]=w;
		dfs(v,u);siz[u]+=siz[v];if(siz[son[u]]<siz[v])son[u]=v;
	}
}
IV dfs2(i64 u,i64 T){
	top[ni[dfn[u]=++dft]=u]=T;if(son[u])dfs2(son[u],T);
	for(auto[v,w]:g[u])if(!dfn[v])dfs2(v,v);low[u]=dft;
}
struct SGT{
	#define ls (o<<1)
	#define rs (o<<1|1)
	i64 tag[maxn*4],s1[maxn*4],sum[maxn*4];
	IV build(i64 o,i64 l,i64 r){
		if(l==r)return(void)(s1[o]=val[ni[l]]);
		i64 mid=l+r>>1;build(ls,l,mid);build(rs,mid+1,r);s1[o]=s1[ls]+s1[rs];
	}
	IV pushup(i64 o){sum[o]=sum[ls]+sum[rs];}
	IV givet(i64 o,i64 v){tag[o]+=v;sum[o]+=s1[o]*v;}
	IV pd(i64 o){if(!tag[o])return;givet(ls,tag[o]);givet(rs,tag[o]);tag[o]=0;}
	IV M(i64 o,i64 l,i64 r,i64 x,i64 y,i64 v){
		if(x<=l&&r<=y)return givet(o,v);if(r<x||l>y)return;pd(o);
		i64 mid=l+r>>1;M(ls,l,mid,x,y,v);M(rs,mid+1,r,x,y,v);pushup(o);
	}
	i64 Q(i64 o,i64 l,i64 r,i64 x,i64 y){
		if(x<=l&&r<=y)return sum[o];if(r<x||l>y)return 0;pd(o);
		i64 mid=l+r>>1;return Q(ls,l,mid,x,y)+Q(rs,mid+1,r,x,y);
	}
}sgt;
i64 s1,s2,cnt;
IV add(i64 x){
	s1+=dep[x];cnt++;
	for(;x;x=fa[top[x]]){
		s2+=sgt.Q(1,1,n,dfn[top[x]],dfn[x]);
		sgt.M(1,1,n,dfn[top[x]],dfn[x],1);
		// cout<<dfn[top[x]]<<' '<<dfn[x]<<endl;
	}
	// cout<<s1<<' '<<s2<<' '<<cnt<<endl;
}
i64 Q(){return 2*s1*(cnt-1)-s2*4;}
int main(){
	// freopen("1.in","r",stdin);
	// freopen("1.out","w",stdout);
	n=read();k=read();
	F(i,1,n-1){
		i64 u=read(),v=read(),w=read();
		g[u].push_back({v,w});g[v].push_back({u,w});
	}
	dfs(1,0);dfs2(1,1);
	// F(i,1,n)cout<<top[i]<<' ';puts("");
	sgt.build(1,1,n);add(1);
	while(k--)add(read()),print(Q()),puts("");
	return 0;
}//35mins
```


---

## 作者：qejwdi (赞：1)

比较套路的题，关键是在知道这个转化。

首先把 $dis$ 拆成深度，即 $dis(i,j)=dep_i+dep_j-2 \times dep_{lca(i,j)}$，其中 $dep_x$ 表示 $x$ 到根的距离。

故我们可以这样拆：
$\sum_{x=1}^i\sum_{y=1}^i dis(x,y)=\sum_{x=1}^i\sum_{y=1}^i dep_x+dep_y-2 \times dep_{lca(x,y)}=\sum_{x=1}^i dep_x \times (i-1)\ - \ 2 \times \sum_{x=1}^i \sum_{y=1}^i dep_{lca(x,y)}$。

上面的可以看成两部分，分别统计：

> **part1：** $ans1=\sum_{x=1}^i dep_x$
>
> **part2：** $ans2=2 \times \sum_{x=1}^i \sum_{y=1}^i dep_{lca(x,y)}$
>
> 答案即为 $ans1 \times (i-1) - ans2$。


接着因为是对每个前缀求答案，所以考虑从 **前缀 $i$** 扩展到 **前缀 $i+1$** 的变化，即考虑 $i+1$ 点和前面点配对的贡献。

首先，$ans1$ 直接加上 $dep_{i+1}$ 即可。

接着是 $ans2$。可以把 $dep_{lca(x,i+1)}$ 看成 **$i+1$ 到根的路径** 和 **$x$ 到根的路径** 的 **交的长度**。那么我们把前面的所有 $x \leq i$ 把起到根的路径上所有边加 1，然后查询 $i+1$ 到根上的路径求和即可。

我们如何对路径做加法呢？在他的下面的点上加上即可。

于是用树链剖分维护。

做完这个题推荐可以：

[P4211](https://www.luogu.com.cn/problem/P4211)

[P6778](https://www.luogu.com.cn/problem/P6778)

学一下第一篇题解的通解。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<cassert>
#include<utility>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<set>
#include<bitset>
#include<random>
using namespace std;
#define int long long
#define rep(i,l,r) for(int i=(l);i<=(r);i++)
#define per(i,r,l) for(int i=(r);i>=(l);i--)
#define debug(x) cout<<#x<<'='<<x<<'\n'
#define pb push_back
#define ll long long
#define x0 __x00
#define y0 __y00
#define ull unsigned long long
#define db double
#define ldb long double
#define int128 __int128
#define pii pair<int,int>
#define pll pair<long long,long long>
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
#define Base 10
template<typename tp> inline void tomax(tp &a,tp b){a=(b>a?b:a);}
template<typename tp> inline void tomin(tp &a,tp b){a=(b<a?b:a);}
template<typename tp> inline void read(tp& n){tp x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}n=x*f;}
template<typename tp> inline void print(tp x){if (x<0)putchar('-'),x=-x;if (x>9)print(x/10);putchar(x%10+'0');}
template<typename tp> inline tp qmi(tp a,tp b,tp p){tp res=1;while(b){if(b&1)res=1ll*res*a%p;b>>=1;a=1ll*a*a%p;}return res;}
pll exgcd(ll a,ll b){if(!b)return {1,0};pll tmp=exgcd(b,a%b);return {tmp.se,tmp.fi-(a/b)*tmp.se};}
template<typename tp> inline tp gcd(tp a,tp b){return !b?a:gcd(b,a%b);}
typedef class BigInteger:public vector<ll>{
    public: 
        using vector<ll>:: vector;
        void shrink(){while(size()>1u&&!back())pop_back();}
        friend BigInteger operator+(BigInteger a,BigInteger b){int n=max(a.size(),b.size())+1;a.resize(n,0);b.resize(n,0);rep(j,0,n-1)if((a[j]+=b[j])>=Base){a[j]-=Base;a[j+1]+=1;}a.shrink();return a;}
        friend BigInteger operator/(BigInteger a,int b){int n=a.size(),p=0;per(j,n-1,0){p=p*Base+a[j];a[j]=p/b;p%=b;}a.shrink();return a;}
        friend BigInteger operator*(BigInteger a,BigInteger b){int n=a.size(),m=b.size();BigInteger c(n+m,0);rep(i,0,n-1)for(int j=0,s=i;j<m;j++,s++){c[s]+=a[i]*b[j];c[s+1]+=c[s]/Base;c[s]%=Base;}for(int i=1;i<n+m;i++){c[i]+=c[i-1]/Base;c[i-1]%=Base;}while(c.size()>1u&&!c.back())c.pop_back();return c;}
        friend istream& operator>>(istream& is,BigInteger& a){string s;cin>>s;int n=s.size();per(j,n-1,0)a.pb(s[j]-'0');return is;}
        friend ostream& operator<<(ostream& os,BigInteger& a){int n=a.size();per(j,n-1,0)print(a[j]);return os;}
}BigInteger;

const int N=1e5+5;
int n,m,k,tot,fatw[N],now[N],ww[N];
int dep[N],top[N],dfn[N],fa[N],siz[N],son[N];
vector<pii>g[N];
struct Node{
    int sum,add,val;
}tr[N<<2];
void pushup(int id){
    tr[id].sum=tr[id<<1].sum+tr[id<<1|1].sum;
    tr[id].val=tr[id<<1].val+tr[id<<1|1].val;
}
void settag(int id,int tag){
    tr[id].sum+=tag*tr[id].val;
    tr[id].add+=tag;
}
void pushdown(int id){
    if(tr[id].add){
        settag(id<<1,tr[id].add);
        settag(id<<1|1,tr[id].add);
        tr[id].add=0;
    }
}
void dfs1(int x,int F){
    siz[x]=1;
    fa[x]=F;
    int maxid=-1;
    for(auto to:g[x]){
        if(to.fi==F)continue;
        ww[to.fi]=to.se;
        dep[to.fi]=dep[x]+to.se;
        dfs1(to.fi,x);
        siz[x]+=siz[to.fi];
        if(maxid==-1||siz[to.fi]>siz[maxid])maxid=to.fi;
    }
    son[x]=maxid;
}
void dfs2(int x,int tp){
    top[x]=tp;
    dfn[x]=++tot;
    fatw[tot]=ww[x];
    if(son[x]<1)return;
    dfs2(son[x],tp);
    for(auto to:g[x]){
        if(to.fi==fa[x]||to.fi==son[x])continue;
        dfs2(to.fi,to.fi);
    }
}
void build(int id,int l,int r){
    if(l==r){
        tr[id].sum=tr[id].add=0;
        tr[id].val=fatw[l];
        return;
    }
    int mid=(l+r>>1ll);
    build(id<<1,l,mid);
    build(id<<1|1,mid+1,r);
    pushup(id);
}
void modify(int id,int l,int r,int ql,int qr,int v){
    if(l==ql&&r==qr){
        settag(id,v);
        return;
    }
    int mid=(l+r>>1ll);pushdown(id);
    if(qr<=mid)modify(id<<1,l,mid,ql,qr,v);
    else if(ql>mid)modify(id<<1|1,mid+1,r,ql,qr,v);
    else{
        modify(id<<1,l,mid,ql,mid,v);
        modify(id<<1|1,mid+1,r,mid+1,qr,v);
    }
    pushup(id);
}
int query(int id,int l,int r,int ql,int qr){
    if(l==ql&&r==qr)return tr[id].sum;
    int mid=(l+r>>1ll);pushdown(id);
    if(qr<=mid)return query(id<<1,l,mid,ql,qr);
    else if(ql>mid)return query(id<<1|1,mid+1,r,ql,qr);
    else return query(id<<1,l,mid,ql,mid)+query(id<<1|1,mid+1,r,mid+1,qr);
}


signed main(){

    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);

    cin>>n>>k;
    rep(i,2,n){
        int a,b,c;cin>>a>>b>>c;
        g[a].pb({b,c});
        g[b].pb({a,c});
    }
    dfs1(1,-1); dfs2(1,1);build(1,1,n);
    now[1]=1;rep(i,2,k+1)cin>>now[i];
    int v1,v2;v1=v2=0;
    rep(i,1,k+1){
        int x=now[i];
        v1+=dep[x];
        while(x>0){
            v2+=query(1,1,n,dfn[top[x]],dfn[x]);
            modify(1,1,n,dfn[top[x]],dfn[x],1);
            x=fa[top[x]];
        }
        if(i>1)cout<<2*(i-1)*v1-4*v2<<'\n';
    }




    return 0;
}
```

---

## 作者：_AyachiNene (赞：1)

点分树模板题。
# 思路：
考虑建出点分树，每次操作相当于算一个点到所有已加入点的距离，再把这个点加入。

先定义一下记号，设 $sum_{0,u}$ 表示点分树上的一个点的子树中已加入点到它的距离和，$sum_{1,u}$ 表示到它点分树上的父亲的距离和。设 $cnt_{0,u}$ 表示子树中的点数，类似地，定义 $cnt_{1,u}$，$dis_{i,j}$ 为原树上 $(i,j)$ 的距离和。

考虑加入操作，把这个点在点分树上的所有祖先的子树信息全部加上这个点的贡献。

再考虑查询操作，假设查询点为 $u$，$S$ 为 $u$ 在点分树上的祖先集合。枚举一个祖先作为分治中心，那么显然有

$\sum_{x\in S}(sum_{0,x}+cnt_{0,x}\times dis_{u,x})$。

容易发现会算重，原因是一个点在 $x$ 方向的子树并不会经过这个点，所以要容斥一下。设 $y$ 为枚举的 $x$ 的在 $u$ 方向上的儿子，那么答案减去

$\sum_{x\in S}(sum_{1,y}+cnt_{1,y}\times dis_{x,u})$。

时间复杂度 $O(m\log^2 n)$，瓶颈在于求 Lca 计算 $dis$。~~不过树剖求 Lca 可以看作小常数。~~ 目前最有解第二。
# Code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
namespace IO
{
	char buff[1<<21],*p1=buff,*p2=buff;
	char getch(){return p1==p2&&(p2=((p1=buff)+fread(buff,1,1<<21,stdin)),p1==p2)?EOF:*p1++;}
	template<typename T>void read(T &x){char ch=getch();int fl=1;x=0;while(ch>'9'||ch<'0'){if(ch=='-')fl=-1;ch=getch();}while(ch<='9'&&ch>='0'){x=x*10+ch-48;ch=getch();}x*=fl;}
	template<typename T>void read_s(T &x){x="";char ch=getch();while(ch<'a'||ch>'z')ch=getch();while(ch>='a'&&ch<='z'){x+=ch;ch=getch();}}
	template<typename T,typename ...Args>void read(T &x,Args& ...args){read(x);read(args...);}
	char obuf[1<<21],*p3=obuf;
	void putch(char ch) {if(p3-obuf<(1<<21))*p3++=ch;else fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=ch;}
	char ch[100];
	template<typename T>void write(T x) {if(!x)return putch('0');if(x<0)putch('-'),x*=-1;int top=0;while(x)ch[++top]=x%10+48,x/=10;while(top)putch(ch[top]),top--;}
	template<typename T,typename ...Args>void write(T x,Args ...args) {write(x);write(args...);}
	void put(string s){for(int i=0;i<s.size();i++)putch(s[i]);}
	void flush(){fwrite(obuf,p3-obuf,1,stdout);}
}
using namespace IO;
struct node
{
	int nxt,to,val;
}e[300005];
int head[150005],cnt_edge;
void add_edge(int u,int v,int w)
{
	e[++cnt_edge].to=v;
	e[cnt_edge].val=w;
	e[cnt_edge].nxt=head[u];
	head[u]=cnt_edge;
}
int n,m;
int f[150005],siz[150005],dep[150005],son[150005],dis[150005],top[150005];
void dfs1(int u,int fa)
{
	f[u]=fa;siz[u]=1;dep[u]=dep[fa]+1;
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==fa) continue;
		dis[v]=dis[u]+e[i].val;dfs1(v,u);siz[u]+=siz[v];
		if(siz[son[u]]<siz[v]) son[u]=v;
	}
}
void dfs2(int u,int t)
{
	top[u]=t;
	if(son[u]) dfs2(son[u],t);
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==f[u]||v==son[u]) continue;
		dfs2(v,v);
	}
}
inline int lca(int x,int y)
{
	for(;top[x]!=top[y];x=f[top[x]]) if(dep[top[x]]<dep[top[y]]) swap(x,y);
	return dep[x]<dep[y]?x:y;
}
inline int calc(int x,int y){return dis[x]+dis[y]-2*dis[lca(x,y)];}
int vis[150005],mx[150005],cent,df[150005];
int sum[2][100005],cnt[2][100005];
void findcent(int u,int fa,int tot)
{
	siz[u]=1;mx[u]=0;
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==fa||vis[v]) continue;
		findcent(v,u,tot);siz[u]+=siz[v];mx[u]=max(mx[u],siz[v]);
	}
	mx[u]=max(mx[u],tot-siz[u]);
	if(mx[cent]>mx[u]) cent=u;
}
void divcent(int u,int tot)
{
	vis[u]=1;
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(vis[v]) continue;
		cent=0;findcent(v,u,siz[v]);
		df[cent]=u;divcent(cent,siz[v]);
	}
}
inline void change(int u)
{
	for(int x=u;x;x=df[x])
	{
		sum[0][x]+=calc(u,x);++cnt[0][x];
		if(df[x]) sum[1][x]+=calc(u,df[x]),++cnt[1][x];
	}
}
inline int query(int u)
{
	int res=0;
	for(int x=u,pre=0;x;pre=x,x=df[x])
	{
		res+=sum[0][x]+cnt[0][x]*calc(x,u);
		if(pre) res-=sum[1][pre]+cnt[1][pre]*calc(x,u);
	}
	return res;
}
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n,m);
	for(int i=1;i<n;i++)
	{
		int u,v,w;read(u,v,w);
		add_edge(u,v,w);add_edge(v,u,w);
	}
	dfs1(1,0);dfs2(1,1);
	mx[0]=1e9;cent=0;findcent(1,0,n);divcent(cent,n);
	int ans=0;
	change(1);
	while(m--)
	{
		int x;read(x);
		ans+=query(x);change(x);
		write(ans*2),putch('\n');
	}
	flush();
	return 0;
}
```

---

## 作者：Cl41Mi5deeD (赞：1)

提供一个不太一样的做法。

把城堡称作关键点，一次修改对答案的新增贡献为两倍的该点与先前所有关键点的距离之和。

为查询这个距离和考虑一个换根状物，关键点到根的距离 $sum$ 是好求的，对于询问点 $u$ 到所有关键点的距离和可以认为是经过了它根链上的 $dep_u$ 次换根实现的。具体地，设节点 $u$ 子树内的关键点个数为 $cnt_u$，则从点 $u$ 到它的一个儿子 $v$ 的换根为（设连接着它俩的边权为 $w$）：

$$
Ans_v=Ans_u-w*cnt_v+(cnt_1-cnt_v)*w\\
=Ans_u+w*cnt_1-2*w*cnt_v
$$

一次询问用 $sum$ 从根跑到 $u$ 统计边上的贡献即可，考虑如何动态维护每个边的式子。

一次修改会影响树上所有边的式子，但是发现式子可以按照树上点的类型分别处理，比如说现在把点 $u$ 变成关键点，那么：
- $cnt_1$ 增 1。
- 点 $u$ 包括自身的根链上所有点 $v$ 的 $cnt_v$ 增 1，进而每条边的贡献净扣一个边权。
- 除了这些点以外的其他点 $v$ 的 $cnt_v$ 不变，相当于它们对应边的贡献净增一个边权。

考虑对原树进行树链剖分，线段树维护 $dfn_u$ 区间的边权和与答案，对于根链上的需要减贡献的点会，其 $dfn_u$ 形成 $O(\log n)$ 个不相交的连续段，进而剩余的点应该是 $[1,n]$ 对那些段的补集，个数也是 $O(\log n)$ 级别的，直接把扣的区间按左端点排序然后修改即可，复杂度 $O(n\log^2n)$。


放一下核心部分。

```cpp
struct Segment_Tree{
	#define ls(p) p<<1
	#define rs(p) p<<1|1
	struct TREE{
		int l,r;
		int dsum,ans,tag;
	}tree[MAXN<<2];
	inline void push_up(int p){
		tree[p].dsum=tree[ls(p)].dsum+tree[rs(p)].dsum;
		tree[p].ans=tree[ls(p)].ans+tree[rs(p)].ans;
	}
	inline void build(int l,int r,int p){
		tree[p].l=l,tree[p].r=r;
		if(l==r){
			int u=rk[l];
			tree[p].dsum=Val[u];//这个就是点父亲到它的边权。
			return ;
		}
		int mid=l+r>>1;
		build(l,mid,ls(p));
		build(mid+1,r,rs(p));
		push_up(p);
	}
	inline void spread(int p){
		if(tree[p].tag){
			tree[ls(p)].ans+=tree[p].tag*tree[ls(p)].dsum;
			tree[rs(p)].ans+=tree[p].tag*tree[rs(p)].dsum;
			tree[ls(p)].tag+=tree[p].tag;
			tree[rs(p)].tag+=tree[p].tag;
			tree[p].tag=0;
		}
	}
	inline void modify(int l,int r,int k,int p){
		if(l>r)return ;
		if(tree[p].l>=l&&tree[p].r<=r){
			tree[p].ans+=k*tree[p].dsum;
			tree[p].tag+=k;
			return ;
		}
		int mid=tree[p].l+tree[p].r>>1;
		spread(p);
		if(l<=mid)modify(l,r,k,ls(p));
		if(r>mid)modify(l,r,k,rs(p));
		push_up(p);
	}
	inline int query(int l,int r,int p){
		if(tree[p].l>=l&&tree[p].r<=r)return tree[p].ans;
		spread(p);
		int mid=tree[p].l+tree[p].r>>1;
		int res=0;
		if(l<=mid)res+=query(l,r,ls(p));
		if(r>mid)res+=query(l,r,rs(p));
		return res;
	}
}ST;
pii stac[MAXN];
int tot;
inline void update(int x){//把根链上减的区间存一下
	while(x){
		ST.modify(dfn[top[x]],dfn[x],-1,1);
		stac[++tot]=mp(dfn[top[x]],dfn[x]);
		x=father[top[x]];
	}
}
int BAS;
inline void modify(int u){
	BAS+=dis[u];
	++cnt;
	ST.modify(dfn[u]+1,dfn[u]+siz[u]-1,1,1);
	tot=0;
	if(dfn[u]+1<=dfn[u]+siz[u]-1)stac[tot=1]=mp(dfn[u]+1,dfn[u]+siz[u]-1);
	update(u);
	sort(stac+1,stac+1+tot);//剩下的排个序一加
	int L=1,R=0;
	for(int i=1;i<=tot;i++){
		R=stac[i].fi-1;
		if(R>=L)ST.modify(L,R,1,1);
		L=stac[i].se+1;
	}
	R=n;
	if(R>=L)ST.modify(L,R,1,1);
}
inline int getans(int x){
	int res=0;
	while(x){
		res+=ST.query(dfn[top[x]],dfn[x],1);
		x=father[top[x]];
	}
	return res+BAS;
}
signed main(){
	n=read(),q=read();
	for(int i=1,u,v,w;i<n;i++){
		u=read(),v=read(),w=read();
		add(u,v,w);
		add(v,u,w);
	}
	dfs1(1,0);
	dfs2(1,1);
	ST.build(1,n,1);
	modify(1ll);
	for(int i=1,x;i<=q;i++){
		x=read();
		modify(x);
		ans+=2*getans(x);
		writeln(ans);
	}
	return 0;
}
```

---

## 作者：dream10 (赞：0)

## Hint

链的情况怎么做？

可以拆贡献吗？

拆完贡献怎么快速计算呢？

## Solution

### Step 0

读者请确保掌握线段树，点分治，$O(n \log n)-O(1)$ lca 算法。

### Step 1

$\sum_{x\in S}\sum_{y\in S}dis(x,y)=\sum_{x\in S}\sum_{y\in S}dep(y)+dep(y)-2dep(lca(x,y))$

然后问题转化为计算 $\sum_{x,y\in S}dep(lca(x,y))$

### Step 2.5

如果读者做过 P4211 应该会觉得比较经典，其实如果一个个加入，不难想到把之前某个点对新加的点贡献统一计算。

于是加入一个点查到根链和，加到答案里，然后到根链加一。

复杂度 $(n \log^2 n)$。

### Step 3

别的想法呢？考虑原问题是一个链的情况吧，也就是分成两个区间，分别记录两边关键点个数和距离和的做法。

如果从此出发，推广到树，容易想到点分治。

而且之前拆的贡献也可以在点分治的同时处理，至于动态维护，使用点分树即可，需要对 $O(log n)$ 个祖先计算答案，每次算路径长度如果能 $O(1)$ 计算就可以做到 $O(n \log n)$ 复杂度。

使用魏老师的 $O(n\log n)-O(1)$ lca算法。

复杂度 $O(n \log n)$。

对比之前的算法：复杂度更低而且不用LCT，更具有推广性。

### Code

是倍增 lca 的代码：

https://www.luogu.com.cn/record/218547351

$O(1)$ lca 的代码：

https://www.luogu.com.cn/record/218547676

然而没快多少。


## References

感谢 POI 出题组一直以来的好题！

查看代码请加入代码公开计划。

---

## 作者：Tighnarri (赞：0)

## [zbo](https://www.luogu.com.cn/problem/P9808)

考虑每条边会给答案贡献多少次。

不难发现只有这条边连接的儿子节点的子树内部与子树外交通时它才会贡献答案，把边权下放到点权。

故此，令 $n$ 为所有点数，$k$ 为城堡个数，$siz$ 为子树大小，$a$ 为下放的点权。

答案为：$$\sum_{x=1}^{n}(k-siz_x)\times siz_x\times a_x$$

> $siz_x$ 就是子树内的点，$k-siz_x$ 就是子树外的点，两两分别交通，总共需要经过 $siz_x\times (k-siz_x)$ 次 $x$ 点，贡献了这么多次 $a_x$ 。

把里面拆开，得到：$$k\times siz_x \times a_x -{siz_x}^2\times a_x$$

因为 k 是定值，所以我们需要维护 $siz_x\times a_x$ 与 ${siz_x}^2\times a_x$。

考虑每次新增城堡的操作就是从 $1$ 到 $x$ 的路径上所有的 $siz_i+1$。

> 原式子就变成 $(k-siz_i+1)\times (siz_i+1)\times a_i$ 给它全拆开得到 $(k-siz_i)\times siz_i \times a_i+(k+1)\times a_i$ 。前面的是原式，后面的就是新增的贡献。新增一个城堡贡献增加的路径就是 $1$ 到 $x$ ，每条路径增加 $(k+1)\times a_i$ 的贡献。（可能有点抽象，推荐画画图比划一下。）

令 $siz+l$ 看看情况。

$$(siz_x+l) \times a_x=siz_x\times a_x+l\times a_x$$ 
$${(siz_x+l)}^2\times a_x={siz_x}^2\times a_x+l^2\times a_x+2\times siz_x\times l \times a_x$$
两个式子告诉我们需要维护的三个信息是 $val1=siz_x\times a_x ,val2={siz_x}^2\times a_x, vala=a_x$，然后直接树剖完后上线段树维护就行了。
code：
```cpp
#include<iostream>
#define rep(x,y,z) for(int x=(y);x<=(z);x++) 
#define ls u*2
#define rs u*2+1
#define int long long
using namespace std;
const int N=1e5+10;
int n,k,q[N];
struct Edge{
	int to,nxt,w;
}e[2*N];
int head[N],tot;
void add(int u,int v,int w){
	e[++tot].to=v;
	e[tot].nxt=head[u];
	e[tot].w=w;
	head[u]=tot;
}
int dfn[N],top[N],dfx,dep[N],siz[N],hson[N],f[N],w[N],rnk[N];
struct Tree{
	int vala,val1,val2;
	int tag;
}tr[4*N];
void dfs1(int u,int fa){
	f[u]=fa;
	dep[u]=dep[fa]+1;
	siz[u]=1;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==fa) continue;
		w[v]=e[i].w;
		dfs1(v,u);
		siz[u]+=siz[v];
		if(siz[v]>siz[hson[u]]) hson[u]=v;
	}
	return ;
}
void dfs2(int u,int tp){
	top[u]=tp;
	dfn[u]=++dfx;
	rnk[dfx]=u;
	if(!hson[u]) return ;
	dfs2(hson[u],tp);
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==f[u] || v==hson[u]) continue;
		dfs2(v,v);
	}
}
void pushup(int u){
	tr[u].val1=tr[ls].val1+tr[rs].val1;
	tr[u].val2=tr[ls].val2+tr[rs].val2;
	tr[u].vala=tr[ls].vala+tr[rs].vala;
}
void upd(int u,int k){
	tr[u].val2+=2*k*tr[u].val1+k*k*tr[u].vala;
	tr[u].val1+=k*tr[u].vala;
	tr[u].tag+=k;
}
void pushdown(int u){
	if(!tr[u].tag) return ;
	upd(ls,tr[u].tag);
	upd(rs,tr[u].tag);
	tr[u].tag=0;
}
void build(int u,int l,int r){
	if(l==r){
		tr[u].vala=w[rnk[l]];
		return ;
	}
	int mid=(l+r)>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	pushup(u);
}
void modify(int u,int l,int r,int x,int y,int k){
	if(l>=x && r<=y){
		upd(u,k);
		return ;
	}
	pushdown(u);
	int mid=(l+r)>>1;
	if(x<=mid) modify(ls,l,mid,x,y,k);
	if(mid<y) modify(rs,mid+1,r,x,y,k);
	pushup(u);
}
void mdf(int x,int y,int k){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		modify(1,1,n,dfn[top[x]],dfn[x],k);
		x=f[top[x]];
	}
	if(dfn[x]>dfn[y]) swap(x,y);
	modify(1,1,n,dfn[x],dfn[y],k);
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>k;
	rep(i,1,n-1){
		int u,v,w;
		cin>>u>>v>>w;
		add(u,v,w);add(v,u,w);
	}
	dfs1(1,0);
	dfs2(1,1);
	build(1,1,n);
	mdf(1,1,1);
	rep(i,1,k){
		int x;cin>>x;
		mdf(1,x,1);
		cout<<2*(tr[1].val1*(i+1)-tr[1].val2)<<'\n';
	}
	return 0;
}
```

---

## 作者：fzitb7912 (赞：0)

## 分析

对于 $\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n} dis(d_i,d_j)$，我们有：

$$
\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n} dis(d_i,d_j)\\
=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n} dep_{d_i}+dep_{d_j}-2dep_{\operatorname{LCA}(d_i,d_j)}\\
=2n\sum\limits_{i=1}^{n}dep_{d_i}-2\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n} dep_{\operatorname{LCA}(d_i,d_j)}\\
$$

现在考虑 $n \to n+1$ 时答案的变化。首先前面那个求和可以直接维护出来，然后后面那个由于前 $n$ 个数的答案没变，所以只相当于求 $4 \sum \limits_{j=1}^{n+1}dep_{\operatorname{LCA}(d_{n+1},d_j)}-2dep_{d_{n+1}}$。这个相当于求一个点与其它所有点的路径交的大小和。是个典的东西，我们每次将 $1 \sim d_{n+1}$ 路径上的边价值增加 $w_{u,v}$，那么 $n+1$ 与其它所有点的路径交的大小和就是 $1 \sim d_{n+1}$ 的价值和。拿树剖维护即可，时间复杂度 $O(n\log ^2 n)$。

---

## 作者：dAniel_lele (赞：0)

首先 $\text{dis}(i,j)=dep_{i}+dep_{j}-2dep_{\text{lca}(i,j)}$。

考虑新添加一个点的贡献。首先有基础贡献 $pre$（即之前所有点的深度和）和 $dep_x\times cnt$（即该点深度与之前点数的乘积）。接着考虑 $dep_{\text{lca}(i,j)}$，不难发现本质上就是 $x$ 到根的路径上每个点目前子树中点数之和。

问题转化为链加链查询，可以使用树剖在 $O(n\log^2n)$ 的时间内解决。（也可以线段树维护前缀和差分标记做到 $O(n\log n)$）

```cpp
#include <bits/stdc++.h>
#define int long long
#define mid ((l+r)>>1)
using namespace std;
int a[1000005];
struct sgt{
	int f[1000005],lzt[1000005],siz[1000005];
	void pushdown(int i){
		f[i*2]+=lzt[i]*siz[i*2];
		f[i*2+1]+=lzt[i]*siz[i*2+1];
		lzt[i*2]+=lzt[i];
		lzt[i*2+1]+=lzt[i];
		lzt[i]=0;
	}
	void build(int i,int l,int r){
		if(l==r){
			siz[i]=a[l];
			return ;
		}
		build(i*2,l,mid),build(i*2+1,mid+1,r);
		siz[i]=siz[i*2]+siz[i*2+1];
	}
	void change(int i,int l,int r,int ql,int qr,int cg){
		if(ql<=l&&r<=qr){
			f[i]+=siz[i]*cg;
			lzt[i]+=cg;
			return ;
		}
		pushdown(i);
		if(ql<=mid) change(i*2,l,mid,ql,qr,cg);
		if(qr>mid) change(i*2+1,mid+1,r,ql,qr,cg);
		f[i]=f[i*2]+f[i*2+1]; 
	}
	int qry(int i,int l,int r,int ql,int qr){
		if(ql<=l&&r<=qr) return f[i];
		if(ql>r||qr<l) return 0;
		pushdown(i);
		return qry(i*2,l,mid,ql,qr)+qry(i*2+1,mid+1,r,ql,qr);
	}
}tree;
vector<int> chain[100005];
vector<pair<int,int>> vc[100005];
int dep[100005],cnt,tot,hson[100005],siz[100005],f[100005],bel[100005],dfn[100005],up[100005],n;
void dfs(int now,int fa){
	f[now]=fa;
	siz[now]=1;
	for(auto v:vc[now]){
		if(v.first==fa) continue;
		dep[v.first]=dep[now]+v.second;
		up[v.first]=v.second;
		dfs(v.first,now);
		if(siz[v.first]>siz[hson[now]]) hson[now]=v.first;
		siz[now]+=siz[v.first];
	}
}
void getchain(int now,int fa,int tp){
	if(!tp){
		tot++;
		bel[now]=tot;
	}
	else bel[now]=bel[fa];
	chain[bel[now]].push_back(now);
	dfn[now]=++cnt;
	a[dfn[now]]=up[now];
	if(hson[now]) getchain(hson[now],now,1);
	for(auto v:vc[now]){
		if(v.first==fa||v.first==hson[now]) continue;
		getchain(v.first,now,0);
	}
}
void Change(int now,int cg){
	while(now!=0){
		tree.change(1,1,n,dfn[chain[bel[now]][0]],dfn[now],cg);
		now=f[chain[bel[now]][0]];
	}
}
int Qry(int now){
	int ans=0;
	while(now!=0){
		ans+=tree.qry(1,1,n,dfn[chain[bel[now]][0]],dfn[now]);
		now=f[chain[bel[now]][0]];
	}
	return ans;
}
signed main(){
	int q; cin>>n>>q;
	for(int i=1;i<n;i++){
		int a,b,c; cin>>a>>b>>c;
		vc[a].push_back(make_pair(b,c));
		vc[b].push_back(make_pair(a,c));
	}
	dfs(1,0);
	getchain(1,0,0);
	tree.build(1,1,n);
	Change(1,1);
	int totdep=0,ans=0;
	for(int i=1;i<=q;i++){
		int k; cin>>k;
		ans+=totdep+i*dep[k];
		ans-=2*Qry(k);
		Change(k,1);
		totdep+=dep[k];
		cout<<ans*2<<"\n";
	}
	return 0;
}
```

---


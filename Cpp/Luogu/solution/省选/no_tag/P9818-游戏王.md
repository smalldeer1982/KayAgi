# 游戏王

## 题目背景

**本题已经增加 hack 数据**。hack 数据位于 subtask 7，记 0 分。此外本题时限较大数据点较多，希望各位不要滥用评测资源。

你正在打块，突然家长走了进来，于是你假装在玩原神。

## 题目描述

你改造了原神的抽卡系统。

具体而言，在第 $i$ 次抽卡时，系统将会给出一个可重集合 $S_i$，表示这次抽卡中可供选择的角色。第 $j$ 个角色有两个属性：力量值 $s_{i,j}$ 与魔力值 $m_{i,j}$。你可以从中选择一名角色，并将其加入到自己的背包中；当然，你也可以不做任何选择。你的力量值被定义为背包中所有角色的力量值之和，同时你需要时刻保证背包中角色的魔力值之积不超过魔力上限 $v$。你的任务是最大化自己的力量值。

但是，你很快就厌烦了千篇一律的抽卡。为了给生活找点乐子，你想到了这样的问题：如果游戏从第 $l$ 次抽卡开始，到第 $r$ 次抽卡结束，你的力量值最大是多少呢？

你一口气提出了 $q$ 个这样的问题。现在，你需要计算出它们的答案。

**形式化题意**：

给出一个长为 $n$ 的序列 $\{S_n\}$，其中 $S_i$ 为多个二元组 $(s_{i,j},m_{i,j})$ 构成的可重集。有 $q$ 次询问，每次给定 $l,r$，你需要从 $S_l,S_{l+1},\cdots,S_r$ 的每个集合中分别选出 $0$ 个或 $1$ 个二元组。记选出的 $k$ 个二元组为 $(s'_i,m'_i),1\le i\le k$，则你需要在保证 $\prod_{i=1}^km'_i\le v$ 的基础上，最大化 $\sum_{i=1}^k s'_i$。

## 说明/提示

#### 样例解释

对于第一组询问，最优策略是从 $S_3$ 中选择 $(3,3)$。此时你的能力值为 $3$。

对于第三组询问，最优策略是从 $S_1$ 中选择 $(2,1)$，$S_2$ 中选择 $(5,3)$，$S_3$ 中选择 $(3,3)$，$S_4$ 中选择 $(3,1)$，此时魔力值之积等于 $1\times 3\times 3\times 1=9\le 10$，你的能力值等于 $2+5+3+3=13$。 

#### 数据范围与约定

**本题使用子任务捆绑测试，只有通过子任务内全部测试点才可以获得该子任务的相应分数**。

记 $tot=\sum_{i=1}^n|S_i|$。

- 子任务 1（5 分）：保证 $n,tot\le 10$。
- 子任务 2（20 分）：保证 $n,v,tot,q\le 100$。
- 子任务 3（15 分）：保证所有 $m_{i,j}$ 在范围内均匀随机生成。
- 子任务 4（20 分）：保证 $1\le n,v,tot,q\le 10^4$。
- 子任务 5（15 分）：保证对于所有询问，均有 $l=1$ 或者 $r=n$。
- 子任务 6（25 分）：无特殊限制。

对于所有数据，保证 $1\le n,tot\le 10^5$，$1\le q\le 2\times 10^5$，$1\le m_{i,j}\le v\le 10^5$，$1\le s_{i,j}\le 10^4$，$1\le l\le r\le n$。

## 样例 #1

### 输入

```
4 10
2 2 1 5 9
1 5 3
3 2 1 2 1 3 3
1 3 1
5
3 3
2 3
1 4
2 4
3 4```

### 输出

```
3
8
13
11
6```

# 题解

## 作者：meyi (赞：6)

首先发现对于 $1\le i,j\le m$，若 $\lfloor\frac{m}{i}\rfloor=\lfloor\frac{m}{j}\rfloor$，则 $i$ 和 $j$ 可以看作是一个等价类。由整数分块的思想可知等价类是一段区间 $[i,j]$，且对于正整数 $k$，若 $i\times k\le m$，则 $[i\times k,j\times k]$ 是另一个等价类的子区间。由于本题的限制只有乘积 $\le m$，所以一个等价类内的数可以看作是同一个数，也即值域大小降为了 $O(\sqrt V)$。

考虑如何朴素地求出答案，设 $f_{i,j}$ 表示已经考虑了前 $i$ 个可重集，当前的乘积所在的等价类是 $j$，设 $mul_{j,k}$ 表示等价类 $j$ 乘上常数 $k$ 后得到的等价类，那么选取元素有转移 $f_{i,j}+s_{i+1,x}\rightarrow f_{i+1,mul_{j,m_{i+1,x}}}$，不选元素有转移 $f_{i,j}\rightarrow f_{i+1,j}$，直接线性转移即可，时间复杂度 $O(tot\times q\sqrt V)$。

然后你发现这个东西本质是个背包，把物品塞进去的顺序是没有影响的，所以直接分治，每次求出跨过当前分治中心的询问的答案，合并左子区间的后缀和右子区间的前缀即可。时间复杂度 $O((tot\log n+q)\sqrt V)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
//#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops")
#define ALL(v) v.begin(),v.end()
#define For(i,_) for(int i=0,i##end=_;i<i##end;++i) // [0,_)
#define FOR(i,_,__) for(int i=_,i##end=__;i<i##end;++i) // [_,__)
#define Rep(i,_) for(int i=(_)-1;i>=0;--i) // [0,_)
#define REP(i,_,__) for(int i=(__)-1,i##end=_;i>=i##end;--i) // [_,__)
typedef long long ll;
typedef unsigned long long ull;
#define V vector
#define pb push_back
#define pf push_front
#define qb pop_back
#define qf pop_front
#define eb emplace_back
typedef pair<int,int> pii;
typedef pair<ll,int> pli;
#define fi first
#define se second
const int dir[4][2]={{-1,0},{0,1},{1,0},{0,-1}},inf=0x3f3f3f3f,mod=1e9+7;
const ll infl=0x3f3f3f3f3f3f3f3fll;
template<class T>inline bool ckmin(T &x,const T &y){return x>y?x=y,1:0;}
template<class T>inline bool ckmax(T &x,const T &y){return x<y?x=y,1:0;}
int init=[](){return cin.tie(nullptr)->sync_with_stdio(false),0;}();
int main(){
	int t_case=1;
//	scanf("%d",&t_case);
	while(t_case--){
		int m,n;
		scanf("%d%d",&n,&m);
		V<int>id(m+1);
		id[0]=-1;
		FOR(i,1,m+1){
			int j=m/(m/i);
			FOR(k,i,j+1)id[k]=id[i-1]+1;
			i=j;
		}
		V<int>can(id[m]+1);
		V<V<int>>mul(id[m]+1);
		FOR(i,1,m+1){
			int div=m/i,j=m/div;
			assert(id[div]==id[m/j]);
			can[id[i]]=id[div];
			mul[id[i]].resize(div+1);
			For(k,div+1){
				assert(id[i*k]==id[j*k]);
				mul[id[i]][k]=id[i*k];
			}
			i=j;
		}
		V<V<pii>>b(n);
		for(auto &i:b){
			int x;
			scanf("%d",&x);
			i.resize(x);
			for(pii &j:i)scanf("%d%d",&j.fi,&j.se);
		}
		int t;
		scanf("%d",&t);
		V<int>ans(t);
		V<pii>q(t);
		for(pii &i:q)scanf("%d%d",&i.fi,&i.se),--i.fi,--i.se;
		V<V<int>>f(n,V<int>(id[m]+1));
		function<void(int,int,const V<int>&,int)>solve=[&](int l,int r,const V<int> &a,int k){
			if(a.size()){
				if(l==r){
					int mx=0;
					for(pii &i:b[l])ckmax(mx,i.fi);
					for(int i:a)ans[i]=mx;
				}
				else{
					int mid=l+r>>1,ql=mid+1,qr=mid;
					V<int>al,_a,ar;
					for(int i:a){
						if(q[i].se<=mid)al.pb(i);
						else if(q[i].fi>mid)ar.pb(i);
						else _a.pb(i),ckmin(ql,q[i].fi),ckmax(qr,q[i].se);
					}
					solve(l,mid,al,-ql-1),solve(mid+1,r,ar,qr+1);
					for(int i:_a)For(j,id[m]+1)ckmax(ans[i],f[q[i].fi][j]+f[q[i].se][can[j]]);
				}
			}
			if(k<0){
				REP(i,-k-1,r+1){
					if(i==r){
						fill(ALL(f[i]),0);
						for(pii &j:b[i])ckmax(f[i][id[j.se]],j.fi);
					}
					else{
						f[i]=f[i+1];
						for(pii &j:b[i])For(k,can[id[j.se]]+1)ckmax(f[i][mul[k][j.se]],f[i+1][k]+j.fi);
					}
					For(j,id[m])ckmax(f[i][j+1],f[i][j]);
				}
			}
			if(k>0){
				FOR(i,l,k){
					if(i==l){
						fill(ALL(f[i]),0);
						for(pii &j:b[i])ckmax(f[i][id[j.se]],j.fi);
					}
					else{
						f[i]=f[i-1];
						for(pii &j:b[i])For(k,can[id[j.se]]+1)ckmax(f[i][mul[k][j.se]],f[i-1][k]+j.fi);
					}
					For(j,id[m])ckmax(f[i][j+1],f[i][j]);
				}
			}
		};
		V<int>tmp(t);
		iota(ALL(tmp),0);
		solve(0,n-1,tmp,0);
		for(int i:ans)printf("%d\n",i);
	}
	return 0;
}
```

---

## 作者：zhouyuhang (赞：4)

考虑分治。若当前分治到了区间 $[l,r]$，则考虑所有 $l\le ql\le mid<qr\le r$ 的询问 $(ql,qr)$。对 $[l,mid]$ 的每个后缀与 $[mid+1,r]$ 的每个前缀预处理出其最大值块筛（即对所有形如 $x=\lfloor\frac{v}{k}\rfloor$ 的 $x$ 处理出 $m$ 的积小于等于 $x$ 时 $s$ 的和的最大值），并在每个询问处合并即可。注意到在块筛中加入一个数与合并两个块筛均是 $O(\sqrt v)$ 的，而总共会做 $q$ 次合并，每一层都会做 $tot$ 次插入，因此复杂度为 $O((q+tot\log n)\sqrt v)$。

upd：似乎“合并”造成了一点歧义。这里的意思是对于块筛 $f$ 和 $g$ 可以 $O(\sqrt v)$ 求出 $(f*g)$ 在 $v$ 处的取值。

---

## 作者：SnowTrace (赞：3)

我在玩原神。

套路题。

对于不同的 $i$，考虑 $ \lfloor{ \dfrac{v}{i} }\rfloor$ 的取值，显然只有 $O(\sqrt v)$ 种。

而我们现在的限制是可以看作 $xi \leq v$（可以把 $i$ 理解为所选的除了第一项的元素之积），不难发现当 $ \lfloor{ \dfrac{v}{i} }\rfloor$ 固定时， $x$ 可以取到的值也是固定的，所以当 $ \lfloor{ \dfrac{v}{i} }\rfloor$ 不变时，这个 $i$ 的取值集合中的元素都本质上相同（即可贡献的范围相同），也就是本质不同的元素大小只有 $O(\sqrt v)$ 种，我们可以把本质相同的数都归到一个相同的类中。

既然我们已经知道元素大小很小，不妨考虑 $dp$。

$dp_{i,j}$ 表示考虑到第 $i$ 个点，此时乘积所在的类是 $j$ 的情况下和的最大值。

一个很经典的做法是对询问离线，然后分治。

假设我们现在分治处理的区间是 $[l,r]$，那么我们维护 $[l,mid]$ 区间后缀的 $dp$ 值，维护 $[mid,r]$ 区间前缀的 $dp$ 值，那么我们就可以通过合并两个 $dp$ 数组的方式解决左端点在 $[l,mid]$，右端点在 $[mid+1,r]$ 的询问的答案.

这里我们从前缀 $i$ 转移到前缀 $i+1$ 时只需要多加上一个点，所以这一步转移就是 $O(\sqrt v)$ 的，而我们要计算一个询问的答案时只关心这个 $dp$ 数组中一个点的值，也可以做到 $O(\sqrt v)$ 计算，所以总体的时间复杂度是 $O(n\log n \sqrt v)$ 的。

---

这题既卡空间又卡时间（也可能是我代码自带一个又臭又长的特性），下面讲一下怎么卡。

卡空间只需要写一个滚动数组，然后把询问区间跟着一起查。

（因为对询问排序只能使其中一维单调，所以好像只能滚前缀和后缀中的一个）

卡时间的话，可能很多次区间的计算是白白浪费的，所以我们可以先判一下当前计算的区间里面有没有需要解决的询问，如果没有就直接跳过。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,v,q;
vector<pair<int,int> >s[200005];
int pre[100005][655],suf[655],ls[655];
int be[100005];int nw =0 ;
int l[200005],R[200005],ans[200005],mx[100005],mp[200005],ed[200005];
vector<int>ll[200005];
bool cmp(int a,int b){
	return R[a]<R[b];
}
inline void solve(int l,int r){
	if(l >= r)return;
	int mid = l+r>>1;
	solve(mid+1,r);
	int ok = 0;
	for(int i = mid;i>=l;i--){
		if(ok)break;
		for(int j = ed[i];j>=0;j--){
			if(R[ll[i][j]]<=mid)break;ok = 1;break;
		}
	}if(!ok){
		solve(l,mid);return;//卡常
	}for(int i = mid-1;i<=r;i++)memset(pre[i],0,sizeof(pre[i]));memset(suf,0,sizeof(suf));memset(ls,0,sizeof(ls));
	for(int i = mid+1;i<=r;i++){
		for(int j = 1;j<=nw;j++){
			pre[i][j] = max(pre[i-1][j],pre[i][j]);
			for(int k =0;k<s[i].size();k++){
				long long pro = (long long)s[i][k].second*mp[j];
				if(pro<=v){
					pre[i][be[pro]] = max(pre[i][be[pro]],pre[i-1][j]+s[i][k].first);
				}else break;
			}
		}for(int j = 1;j<=nw;j++)pre[i][j] = max(pre[i][j],pre[i][j-1]);
	}for(int i = mid;i>=l;i--){
		memcpy(ls,suf,sizeof(ls));
		for(int j = 1;j<=nw;j++){
			for(int k =0;k<s[i].size();k++){
				long long pro=(long long)s[i][k].second*mp[j];
				if(pro<=v){
					suf[be[pro]] = max(suf[be[pro]],ls[j]+s[i][k].first);
				}else break;
			}
		}for(int j = 1;j<=nw;j++)suf[j] = max(suf[j],suf[j-1]);
		int tot = 0;
		for(int j = ed[i];j>=0;j--){
			if(R[ll[i][j]]<=mid)break;tot++;
			int mx = 0;
			for(int k = 1;k<=nw;k++){
				mx = max(mx,suf[k]+pre[R[ll[i][j]]][be[v/mp[k]]]);
			}ans[ll[i][j]] = mx;
		}ed[i]-=tot;//在 dp 的过程中计算询问的答案
        //我们在左端点固定时按照右端点递减的顺序分治，以保证每次都能完全确定这个区间内所有要做的询问。
	}
	solve(l,mid);
}bool cmp1(pair<int,int>a,pair<int,int>b){
	return a.second<b.second;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n>> v;int las = 1;
	for(int i = 1;i<=v;i++){
		if(v/i!=v/(i+1)){nw++;mp[nw] = las;
			for(int j = las;j<=i;j++)be[j] = nw;las = i+1;
		}
	}for(int i = 1;i<=n;i++){
		int ss;cin >> ss;
		for(int j = 1;j<=ss;j++){
			pair<int,int>a;cin >> a.first >> a.second;s[i].push_back(a);
			if(a.second<=v)mx[i] = max(mx[i],a.first);
		}
	}for(int i = 1;i<=n;i++)sort(s[i].begin(),s[i].end(),cmp1);
	cin >> q;
	for(int i = 1;i<=q;i++){
		cin>> l[i]>> R[i];//assert(l[i] != r[i]);
		if(l[i] == R[i]){
			ans[i] = mx[l[i]];continue;
		}ll[l[i]].push_back(i);
	}for(int i = 1;i<=n;i++)sort(ll[i].begin(),ll[i].end(),cmp);
	for(int i= 1;i<=n;i++)ed[i] = ll[i].size()-1;
	solve(1,n);
	for(int i = 1;i<=q;i++)cout << ans[i] << '\n';
	return 0;
}// we dont talk anymore.
```

---

我们发现乘积大小小于 $100000$ 其实是一个比较严格的条件，另一个套路是这里面用到的大于一的数的个数是 $O(\log n)$ 级别的，也许可以直接贪心，但是笔者没想到怎么做，留给读者自己思考。

----

NOIP 可以多考点套路题少考点人类智慧题吗，球球了。


---

## 作者：wosile (赞：2)

神仙同学写了这道题并表示这是*套路*题，所以我就来写了写。

先不管 $q$ 次询问。

一眼望过去有一个很 naive 的 dp 是：

设 $f(i,j)$ 表示考虑前 $i$ 次抽卡，$\prod m=j$ 的最大 $\sum s$。转移易得。

这样是 $O(nv)$ 的。

然后发现我们不关心 $j$ 的具体值，所以想想怎么压缩一下这一维。数据范围和时限启示我们这一维的大小或许是 $O(\sqrt{v})$ 的。实际上确实如此。很*套路*的，我们仅需要知道 $\lfloor\dfrac{v}{\prod m}\rfloor$ 的值就可以列举合法转移，而 $\lfloor\dfrac{v}{x}\rfloor$ 的值众所周知只有 $2\sqrt v$ 个。

这样就可以对一次询问做到 $O(n \sqrt v)$。

考虑很*套路*的对询问区间分治。对于分治区间 $[L,R]$，如果询问 $[l,r]$ 跨过分治区间的中点 $mid$，我们就可以把这个询问的范围拆成 $[L,mid]$ 的一个后缀和 $(mid,R]$ 的一个前缀。对于每个分治区间，dp 求解 $[L,mid]$ 的每个后缀，和 $(mid,R]$ 的每个前缀，询问的时候再拼起来即可。

有时间复杂度 $T(n)=2T(n/2)+O(n\sqrt v)$，所以 $T(n)=O(n\sqrt v \log n)$（好像还有一个 $q\sqrt v$），看起来很大但不怎么卡常。

代码细节不多，写起来很舒服。

注意 $q$ 的范围是 $2\times 10^5$，我开小了调了两个小时。

```cpp
#include<bits/stdc++.h>
using namespace std;
int num[666],id[100005];
struct card{
	int s,m;
};
struct query{
	int id,l,r;
};
vector<card>a[100005];
int n,v;
//666 is an evil number.
int cnt=0;
int f[100005][666],ans[200005];
void solve(int l,int r,vector<query>qs){
	if(qs.empty())return;
	if(l==r){
		int mx=0;
		for(card c:a[l])if(c.m<=v)mx=max(mx,c.s);
		for(query q:qs)ans[q.id]=mx;
		return;
	}
	vector<query>ql,qr;
	ql.clear();qr.clear();
	int mid=(l+r)/2;
	int fl=0;
	for(query q:qs){
		if(q.r<=mid)ql.push_back(q);//左半区间
		else if(q.l>mid)qr.push_back(q);//右半区间
		else fl=1;
	}
	solve(l,mid,ql);
	solve(mid+1,r,qr);
	if(fl){
      //左右分别 dp
		for(int i=l;i<=r;i++)for(int j=0;j<=cnt+1;j++)f[i][j]=0;
		for(card c:a[mid])f[mid][id[v/c.m]]=max(f[mid][id[v/c.m]],c.s);
		for(int i=mid;i>=l;i--){
			for(int j=2;j<=cnt;j++)f[i][j]=max(f[i][j],f[i][j-1]);
			if(i==l)break;
			for(int j=1;j<=cnt;j++)f[i-1][j]=max(f[i-1][j],f[i][j]);
			for(card c:a[i-1])for(int j=1;j<=cnt;j++)if(num[j]>=c.m)f[i-1][id[num[j]/c.m]]=max(f[i-1][id[num[j]/c.m]],f[i][j]+c.s);
		}
		for(card c:a[mid+1])f[mid+1][id[v/c.m]]=max(f[mid+1][id[v/c.m]],c.s);
		for(int i=mid+1;i<=r;i++){
			for(int j=2;j<=cnt;j++)f[i][j]=max(f[i][j],f[i][j-1]);
			if(i==r)break;
			for(int j=1;j<=cnt;j++)f[i+1][j]=max(f[i+1][j],f[i][j]);
			for(card c:a[i+1])for(int j=1;j<=cnt;j++)if(num[j]>=c.m)f[i+1][id[num[j]/c.m]]=max(f[i+1][id[num[j]/c.m]],f[i][j]+c.s);
		}
		for(query q:qs)if(q.l<=mid && q.r>mid)for(int i=1;i<=cnt;i++)ans[q.id]=max(ans[q.id],f[q.l][i]+f[q.r][cnt-i+1]);//查询
	}
}
int main(){
	scanf("%d%d",&n,&v);
	for(int i=1;i<=v;i++){
		if(i==1 || v/i!=v/(i-1)){
			++cnt;
			num[cnt]=v/i;
			id[v/i]=cnt;
		}
	}
	for(int i=1;i<=n;i++){
		int len;
		scanf("%d",&len);
		a[i].resize(len);
		for(int j=0;j<len;j++)scanf("%d%d",&a[i][j].s,&a[i][j].m);
	}
	vector<query>allqueries;
	int Q;
	scanf("%d",&Q);
	allqueries.resize(Q);
	for(int i=0;i<Q;i++){
		scanf("%d%d",&allqueries[i].l,&allqueries[i].r);
		allqueries[i].id=i;
	}
	solve(1,n,allqueries);
	for(int i=0;i<Q;i++)printf("%d\n",ans[i]);
	return 0;
}
```

---


# [POI 2021/2022 R2] age

## 题目背景

翻译自 [POI2021~2022R2 Day1T1](https://szkopul.edu.pl/problemset/problem/weKRWGa1NgLNHT1WLDo5ohuH/statement/)。


## 题目描述

有一个 $n$ 个城市的国家，我们可以将其看为一棵 $n-1$ 条道路连接的树，有一天，你突发奇想，想要派出 $k$ 个人在不同城市上。人及其移动需要满足如下条件：

- 每天只能是一个人移动，移动到其相邻存在道路连接一个城市。

- 假如有两个人 $a,b$，城市 $i$ 被 $a$ 到达过了，则 $b$ 不能到达 $i$ 城市。

初始时你知道了人的位置，每个人初始所在地不相同，且该城市视为“已到达过”的城市，你需要安排一个合法的经过城市的方案。

请你求出最少要几天才能使所有的城市都被人到达过。

## 说明/提示

样例解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/y9gojuv8.png)

子任务分配如下：

| 子任务编号 | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: |
| $1$ | $n \leq 10$ | $6$ |
| $2$ | $n \leq 20$ | $13$ |
| $3$ | $n \leq 2000$ | $27$ |
| $4$ | $k=1$ | $10$ |
| $5$ | $k=2$ | $7$ |
| $6$ | 输入为一条链 | $7$ |
| $7$ | 无特殊性质 | $30$ |

子任务 $0$ 为样例。

## 样例 #1

### 输入

```
6 2
2 6
1 2
2 3
2 4
5 4
5 6```

### 输出

```
5```

# 题解

## 作者：Mikefeng (赞：6)


### 前言：waauto 和 xzl 晚上 duel 这道题，于是晚上在床上想出了这道题。

## 题意

给定一些点，要把树分成几个连通块，每个连通块内要包含一个点，一个连通块的代价是边数乘 $2$ 减去关键点到最远的点的距离。问全局代价最小值。

## 做法

首先讲一下为什么局部代价是这样。

假设我们已经找到了一个连通块划分方案，如果一个人走完了要回到原点，那么代价是边数乘 $2$。

由于不需要回到原点，我们可以走到最深的叶子结点就停下，所以减去最远点距离。

同时这个贡献可以看做有一条链上每条边的贡献是 $1$，其余是 $2$。

考虑 dp，设 $f_{u,0/1,0/1}$ 表示目前节点是 $u$，所属关键点在子树内还是子树外，向父亲的边的贡献是 $1$ 还是 $2$。

然后就是大力分讨转移。

代码里有详细注释。

时间复杂度 $O(n)$，不是很懂为什么开 3s。

## 代码

```cpp
const int N=5e5+5;
int n,k;
vector<int> e[N];
bool vis[N];
int f[N][2][2];
/*
向上或者向下 单边或者双边 
f[u][0][0]:向上的单边 
if(!vis[u]){
f[v][0][0]+1+(f[other][1][1]+2)/(f[other][0][0])/(f[other][0][1])
}
else{
(f[son][1][1]+2)/(f[son][0][0])/(f[son][0][1])
} 
f[u][0][1]:向上的双边 
if(!vis[u]){
f[v][0][1]+2+(f[other][1][1]+2)/(f[other][0][0])/(f[other][0][1])
f[v][0][0]+1+(f[other][1][1]+2)/(f[other][0][0])/(f[other][0][1]) 有一个可以是 f[other][1][0]+1 
}
else{
(f[son][1][1]+2)/(f[son][0][0])/(f[son][0][1]) 有一个可以是 f[son][1][0]+1 
} 
f[u][1][0]:向下的单边 
if(!vis[u]){
(f[son][1][1]+2)/(f[son][0][0])/(f[son][0][1]) 有一个可以是 f[son][1][0]+1
} 
else{
nope
}
f[u][1][1]:向下的双边 
if(!vis[u]){
(f[son][1][1]+2)/(f[son][0][0])/(f[son][0][1])
} 
else{
nope
}
*/
inline void dfs(int u,int fa){
	for(int v:e[u]) if(v!=fa) dfs(v,u);
	if(vis[u]){
		for(int v:e[u]) if(v!=fa) f[u][0][0]+=min(f[v][1][1]+2,min(f[v][0][0],f[v][0][1]));
		
		vector<int> g[2];
		F(i,0,1) g[i]=vector<int>(e[u].size()+1);
		F(i,0,int(e[u].size())-1){
			int v=e[u][i],val=min(f[v][1][1]+2,min(f[v][0][0],f[v][0][1]));
			if(v!=fa){
				g[0][i+1]=g[0][i]+val;
				g[1][i+1]=min(g[1][i]+val,g[0][i]+min(val,f[v][1][0]+1));
			}else g[0][i+1]=g[0][i],g[1][i+1]=g[1][i];
		}
		f[u][0][1]=g[1].back();
		
		f[u][1][0]=f[u][1][1]=1e9;
	}else{
		vector<int> g[4];
		F(i,0,1) g[i]=vector<int>(e[u].size()+1);
		g[1][0]=1e9;
		F(i,0,int(e[u].size())-1){
			int v=e[u][i],val=min(f[v][1][1]+2,min(f[v][0][0],f[v][0][1]));
			if(v!=fa){
				g[0][i+1]=g[0][i]+val;
				g[1][i+1]=min(g[1][i]+val,g[0][i]+f[v][0][0]+1);
			}else g[0][i+1]=g[0][i],g[1][i+1]=g[1][i];
		}
		f[u][0][0]=g[1].back();
		
		F(i,0,1) g[i]=vector<int>(e[u].size()+1);
		g[1][0]=1e9;
		F(i,0,int(e[u].size())-1){
			int v=e[u][i],val=min(f[v][1][1]+2,min(f[v][0][0],f[v][0][1]));
			if(v!=fa){
				g[0][i+1]=g[0][i]+val;
				g[1][i+1]=min(g[1][i]+val,g[0][i]+f[v][0][1]+2);
			}else g[0][i+1]=g[0][i],g[1][i+1]=g[1][i];
		}
		f[u][0][1]=g[1].back();
		
		F(i,0,3) g[i]=vector<int>(e[u].size()+1);
		g[1][0]=g[3][0]=1e9;
		F(i,0,int(e[u].size())-1){
			int v=e[u][i],val=min(f[v][1][1]+2,min(f[v][0][0],f[v][0][1]));
			if(v!=fa){
				g[0][i+1]=g[0][i]+val;
				g[1][i+1]=min(g[1][i]+val,g[0][i]+f[v][0][0]+1);
				g[2][i+1]=min(g[2][i]+val,g[0][i]+min(val,f[v][1][0]+1));
				g[3][i+1]=min(g[3][i]+val,min(g[1][i]+min(val,f[v][1][0]+1),g[2][i]+f[v][0][0]+1));
			}else g[0][i+1]=g[0][i],g[1][i+1]=g[1][i],g[2][i+1]=g[2][i],g[3][i+1]=g[3][i];
		}
		f[u][0][1]=min(f[u][0][1],g[3].back());
		
		F(i,0,1) g[i]=vector<int>(e[u].size()+1);
		F(i,0,int(e[u].size())-1){
			int v=e[u][i],val=min(f[v][1][1]+2,min(f[v][0][0],f[v][0][1]));
			if(v!=fa){
				g[0][i+1]=g[0][i]+val;
				g[1][i+1]=min(g[1][i]+val,g[0][i]+min(val,f[v][1][0]+1));
			}else g[0][i+1]=g[0][i],g[1][i+1]=g[1][i];
		}
		f[u][1][0]=g[1].back();
		
		for(int v:e[u]) if(v!=fa) f[u][1][1]+=min(f[v][1][1]+2,min(f[v][0][0],f[v][0][1]));
	}
//	cout<<u<<' '<<f[u][0][0]<<' '<<f[u][0][1]<<' '<<f[u][1][0]<<' '<<f[u][1][1]<<'\n';
}
bool M2;
int main(){
	int Time=clock();
	look_memory;
	cin.tie(nullptr)->sync_with_stdio(false);
	cin>>n>>k;
	F(i,1,k){
		int x;cin>>x;
		vis[x]=1;
	}
	F(i,1,n-1){
		int u,v;cin>>u>>v;
		e[u].emplace_back(v);
		e[v].emplace_back(u);
	}
	dfs(1,0);
	cout<<min(f[1][0][0],f[1][0][1])<<'\n';
	look_time;
	return 0;
}
```

---

## 作者：XuYueming (赞：3)

## 前言

题目链接：[洛谷](https://www.luogu.com.cn/problem/P9864)。

**[根号的体验](https://www.cnblogs.com/XuYueming/p/18937129)**。

## 题意简述

$n$ 个结点的树，有 $k$ 个人，初始在不同的结点。安排一种行走方式，使得所有结点均被到达过，并且不会有一个结点被**不同**的两个人经过（同一个结点可以被同一个人经过多次）。你需要最小化所有人行走的距离和。

$1\leq k\leq n\leq5\times10^5$。

## 题目分析

显然是树形 DP，对 $u$ 被哪个人经过分类讨论，结合做题经验，不难得到状态 $f_{u,0/1,0/1}$ 表示 $u$ 子树，未来子树外一个人走到 $u$，还是 $u$ 已经被其子树里某个人经过，操作完 $u$ 子树后要不要走回 $u$，的答案。答案即为根的 $f_{u,1,0}$。

考虑一个一个合并儿子子树的过程。

DP 初始值对 $u$ 是否初始有人讨论。若有人，除 $f_{u,1,0/1}=0$ 外均为 $\infty$，否则除 $f_{u,0,0/1}=0$ 外均为 $\infty$。

合并进 $v$ 的子树，考虑 $(u,v)$ 这条边被经过的情况。

1. $f_{u,1,1}'$：
    1. $v$ 子树已经合法：$f_{u,1,1}+f_{v,1,0}$；
    1. $v$ 走出一个人，走到 $u$ 的子树里，再回到 $u$：$f_{v,1,1}+1+f_{u,0,1}$；
    1. $u$ 走出一个人，走到 $v$ 的子树里，回到 $v$，再回到 $u$：$f_{u,1,1}+f_{v,0,1}+2$；
1. $f_{u,1,0}'$：
    1. $v$ 子树已经合法：$f_{u,1,0}+f_{v,1,0}$；
    1. $v$ 走出一个人，走到 $u$ 的子树里：$f_{v,1,1}+1+f_{u,0,0}$，相反有 $f_{u,1,1}+1+f_{v,0,0}$；
    1. 本来有一条经过 $v$ 的路径，现在略微修改，当人走到 $v$ 的时候，先走到 $u$，走进 $u$ 的子树再回到 $u$，走到 $v$，继续 $v$ 本来的路径：$f_{v,1,0}+f_{u,0,1}+2$，相反有 $f_{u,1,0}+f_{v,0,1}+2$；
1. $f_{u,0,1}'$：
    1. $v$ 子树已经合法：$f_{u,0,1}+f_{v,1,0}$；
    1. 未来这条路径先通过 $(u,v)$ 走到 $v$ 的子树中，再走回来，通过 $(v,u)$ 走到 $u$ 的子树中，再回到 $u$：$f_{u,0,1}+f_{v,0,1}+2$；
1. $f_{u,0,0}'$：
    1. $v$ 子树已经合法：$f_{u,0,0}+f_{v,1,0}$；
    1. 未来路径先走到 $v$ 子树中，再回来，再往 $u$ 子树中走：$f_{u,0,0}+f_{v,0,1}+2$，相反有 $f_{v,0,0}+f_{u,0,1}+1$，这里不再是 $+2$ 了，因为 $(u,v)$ 只被经过了一次；

问题解决了，时间复杂度 $\mathcal{O}(n)$。

## 代码

请见[博客](https://www.cnblogs.com/XuYueming/p/18937129)。

---

## 作者：Add_Catalyst (赞：2)

# P9864 [POI 2021/2022 R2] age 题解

------

## 知识点

树形最值 DP，分类讨论。

## 分析

### 简化题意

给定 $k$ 个关键点，将树划分为 $k$ 个连通块，每个块包含一个关键点。

设特殊点 $i$ 在其联通块内为端点的最长链长度为 $len_i$，则一种划分方案的代价为：$2(n-k)-\sum_{i=1}^klen_i$。

问所有划分方案中的最小代价。

### 条件挖掘

发现代价为 $2(n-k)-\sum_{i=1}^klen_i$，那么我们求 $\sum_{i=1}^k len_i$ 的最大值即可。

首先对于每个连通块，我们发现除最长链以外的所有点都是无用的，保留的同时还会影响转移，删去又不会对答案造成影响，所以对于每个连通块我们只需记**一条最长链**即可。

### DP 设计

我们直接考虑链长什么样，在树上的链无非就两种：一端为 LCA 或两端都不为 LCA。再加上这个链一端必须为关键点，这个时候就有很多很好用的性质。

1. 一端为 LCA：

   我们考虑两端点哪个是关键点。

   - 深度大的：

     我们可以设一个表示从关键点延伸出来，还没有结尾时的状态。

   - 深度小的：

     我们可以设一个表示从非关键点延伸出来，还没有结尾时的状态。

2. 两端都不为 LCA：

   此时这条链就相当于上面「一端为 LCA」中「深度大的」和「深度小的」两个状态并起来，也很好解决，只不过这个状态时就不能再像上面两者一样继续延伸了，所以要另设一个状态记。

那么综上，就有 $f_{u,0/1/2}$ 表示转移到 $u$ 点，「不能再延伸」或「从关键点延伸出来」或「从非关键点延伸出来」时的 $\sum_{i=1}^k len_i$ 的最大值。

### 初态 & 转移

假设现在转移到了点 $u$，设 $sum=\sum_{v\in trans(u)} f_{v,0}$。

#### 点 $u$​ 为关键点

- $f_{u,0}$：

  初始值为 $sum$，表示没有从下往上延伸的连接它。那么与之对应的就是有从下往上延伸的连接它，且它是端点：
  $$
  \max_{v\in trans(u)} \set{sum - f_{v,0} + f_{v,2} + 1} \\
  $$

- $f_{u,1}$：就为 $sum$，表示从自己出发到自己。

- $f_{u,2}$：不合法，在代码中设为 $-\inf$。

#### 点 $u$ 不为关键点

- $f_{u,0}$：

  初始值还是为 $sum$，表示没有从下往上延伸的连接它。同样与之对应，表它是端点，不过稍有改动：
  $$
  \max_{v\in trans(u)} \set{sum - f_{v,0} + f_{v,1} + 1} \\
  $$
  此时还要连接出一个两端都不为 LCA 的链，且它是 LCA：
  $$
  \max_{v_0\in trans(u)} \set{sum - f_{v_0,0} + f_{v_0,1} + 1 + \max_{v\neq v_0} \set{- f_{v,0} + f_{v,2} + 1}}
  $$
  那么分类讨论枚举特判一下即可解决。

- $f_{u,1}$：

  初始值为 $-\inf$，因为没有合法的状态。然后转移也是类似：
  $$
  \max_{v\in trans(u)} \set{sum - f_{v,0} + f_{v,1} + 1} \\
  $$

- $f_{u,2}$：

  初始值为 $sum$，表示它是一个端点。转移：
  $$
  \max_{v\in trans(u)} \set{sum - f_{v,0} + f_{v,2} + 1} \\
  $$

## 代码

```cpp
//#define Plus_Cat ""
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define ll long long
#define RCL(a,b,c,d) memset(a,b,sizeof(c)*(d))
#define FOR(i,a,b) for(int i(a);i<=(int)(b);++i)
#define DOR(i,a,b) for(int i(a);i>=(int)(b);--i)
#define tomax(a,...) ((a)=max({(a),__VA_ARGS__}))
#define tomin(a,...) ((a)=min({(a),__VA_ARGS__}))
#define EDGE(g,i,x,y) for(int i=(g).h[(x)],y=(g)[(i)].v;~i;y=(g)[(i=(g)[i].nxt)>0?i:0].v)
#define main Main();signed main(){ios::sync_with_stdio(0);cin.tie(0),cout.tie(0);return Main();}signed Main
using namespace std;
constexpr int N(5e5+10);

bool mark[N];
int n,m,rt;
int f[N][3];
vector<int> g[N];

void DP(int u,int fa) {
	int sum(0);
	for(const int &v:g[u])if(v^fa)DP(v,u),sum+=f[v][0];
	if(mark[u]) {
		//0
		f[u][0]=sum;
		for(const int &v:g[u])if(v^fa)tomax(f[u][0],sum-f[v][0]+f[v][2]+1);
		//1
		f[u][1]=sum;
		//2
		f[u][2]=-INF;
	} else {
		//0
		f[u][0]=sum;
		for(const int &v:g[u])if(v^fa)tomax(f[u][0],sum-f[v][0]+f[v][1]+1);
		int mx(-INF),smx(-INF);
		for(const int &v:g[u])if(v^fa)
			f[v][2]-f[v][0]+1>mx?smx=mx,mx=f[v][2]-f[v][0]+1:tomax(smx,f[v][2]-f[v][0]+1);
		for(const int &v:g[u])if(v^fa)
			tomax(f[u][0],sum+(f[v][2]-f[v][0]+1==mx?smx:mx)-f[v][0]+f[v][1]+1);
		//1
		f[u][1]=-INF;
		for(const int &v:g[u])if(v^fa)tomax(f[u][1],sum-f[v][0]+f[v][1]+1);
		//2
		f[u][2]=sum;
		for(const int &v:g[u])if(v^fa)tomax(f[u][2],sum-f[v][0]+f[v][2]+1);
	}
}

signed main() {
#ifdef Plus_Cat
	freopen(Plus_Cat ".in","r",stdin),freopen(Plus_Cat ".out","w",stdout);
#endif
	cin>>n>>m;
	FOR(i,1,m)cin>>rt,mark[rt]=true;
	FOR(i,2,n) {
		int u,v;
		cin>>u>>v,g[u].push_back(v),g[v].push_back(u);
	}
	DP(rt,0),cout<<2*(n-m)-max(f[rt][0],f[rt][1])<<endl;
	return 0;
}
```

------

---

## 作者：__FL__ (赞：0)

## Solution
直接根据原题意做是困难的，我们需要将其简化。

发现可以考虑哪些边只用走一次。考虑将关键点之间一一断开，每个关键点把自己的块走完。转化一下，就是：每个关键点向外延伸一条路径，路径不能相交，求最大路径长度和，最终答案就是 $2(n-k)-M$，$M$ 是最大路径长度和。

考虑 dp。对于一个点是否出现在路径中，一共有 $4$ 种状态：

1. 作为一个单点（非关键点），不出现在任何路径中；
2. 作为路径中的一个点，这条路径从子树中延伸过来，但这条路径还没有包含关键点；
3. 作为路径中的一个点，这条路径从子树中延伸过来，这条路径已经包含关键点；
4. 作为路径中的一个点，这条路径已经形成，即它从一棵子树中延伸过来，又从另一棵子树中走出去。

![](https://cdn.luogu.com.cn/upload/image_hosting/aywjdtaq.png)

（三角形代表子树，红点为关键点，黑点为非关键点）

设计状态 $f_{u,0/1/2/3}$ 表示在以点 $u$ 为根节点的子树中，点 $u$ 分别为 $4$ 种状态时，关键点能延伸出的路径长度最大值。转移是显然的，枚举子树的时候根据情况转移即可。情况 $4$ 根据情况 $2,3$ 转移过来。细节可参考代码。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 500005;
int n,k,book[N],f[N][4];
vector<int>vec[N];
void dfs(int u,int fa)
{
	if (!book[u]) f[u][0] = f[u][1] = 0;
	else f[u][2] = f[u][3] = 0;
	for (int i: vec[u])
	{
		if (i == fa) continue;
		dfs(i,u);
		if (!book[u])
		{
			int mx = max(f[i][0],f[i][3]);
			f[u][3] = max({f[u][1]+f[i][2]+1,f[u][2]+f[i][1]+1,f[u][0]+f[i][2]+1,f[u][3]+mx});
			f[u][1] = max(f[u][0]+f[i][1]+1,f[u][1]+mx);
			f[u][2] = max(f[u][0]+f[i][2]+1,f[u][2]+mx);
			f[u][0] += max(0,mx);
		}
		else
		{
			f[u][3] = max(f[u][2]+f[i][1]+1,f[u][3]+max(f[i][0],f[i][3]));
			f[u][2] += max(f[i][0],f[i][3]);
		}
	//	cout << u << ' ' << f[u][3]+max(f[i][0],f[i][3]) << '\n';
	}
}
signed main()
{
	ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin >> n >> k;
	for (int i = 1; i <= k; i++)
	{
		int a;
		cin >> a;
		book[a] = 1;
	}
	for (int i = 1; i < n; i++)
	{
		int u,v;
		cin >> u >> v;
		vec[u].push_back(v);
		vec[v].push_back(u);
	}
	memset(f,-0x3f,sizeof f);
	dfs(1,1);
	cout << (n-k)*2-max({f[1][0],f[1][2],f[1][3],0});
	return 0;
}
```

---


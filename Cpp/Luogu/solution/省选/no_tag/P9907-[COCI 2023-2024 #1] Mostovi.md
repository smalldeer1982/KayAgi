# [COCI 2023/2024 #1] Mostovi

## 题目背景

滥用本题评测将被封号！

## 题目描述

When Leonhard Euler resolved the famous Königsberg bridge problem,he had no clue he had discovered a whole new area of mathematics -graph theory!

Unfortunately, the Königsberg bridge problem is far too easy for the programmers of this era, so Euler came up with another problem - the Zagreb bridge problem!

The bridges of Zagreb form a graph with $n$ nodes and $m$ edges where the edges represent the bridges and the nodes represent the riverine islands. The graph is connected, in other words, it’s possible to get from any node to any other by traveling across the edges. Now Euler asked, how many edges are there such that after their removal the graph becomes disconnected?

Again, Euler didn’t know that this problem is also famous today (those damn Codeforces blogs). So the author of this problem decided to give you an even harder one, how many edges are there such that after the removal of the nodes which it connects, the remaining $n − 2$ nodes become disconnected?

### 题目大意

给定一张 $n$ 个点 $m$ 条边的无向连通图，求有多少条边满足删去这条边两端的两个点之后，剩余的 $n-2$ 个点不连通。

## 说明/提示

### 【样例解释#1】

对于边 $(1,3)$，删去它和对应的点 $1,3$ 之后，包含两个连通块，分别包括节点 $2$ 和 $4$，也就是说，图不连通了。容易验证这是唯一满足条件的边。

### 【样例解释#2】

满足条件的边有：$(1, 2), (2, 4), (2, 6) , (2, 5)$。

### 【数据范围】

对于 $100\%$ 的数据，$1\leq n\leq 10^5$，$1\leq m\leq3\times10^5$，$1\leq a_i,b_i\leq n$，图中无重边、自环。

**本题采用捆绑测试。**

| 子任务 | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: |
| $1$ | $n\leq100$，$m\leq300$ | $13$ |
| $2$ | $n\leq1000$，$m\leq3000$ | $17$ |
| $3$ | $n\leq1000$ | $25$ |
| $4$ | $m-n\leq20$ | $12$ |
| $5$ | 无特殊性质 | $43$ |

### 【说明】

本题分值按 COCI 原题设置，满分 $110$。

题目译自 [COCI2023-2024](https://hsin.hr/coci/) [CONTEST #1](https://hsin.hr/coci/contest1_tasks.pdf) _**T5 Mostovi**_。

## 样例 #1

### 输入

```
4 5
1 2
2 3
3 4
4 1
1 3```

### 输出

```
1```

## 样例 #2

### 输入

```
6 7
1 2
2 4
2 6
3 5
6 1
4 3
2 5```

### 输出

```
4```

# 题解

## 作者：云浅知处 (赞：7)

考虑建一个 DFS 树，那么非树边都是返祖边。

考虑 $(u,v)$ 这样一条非树边，这里 $u$ 是 $v$ 的祖先。在删掉 $u$ 和 $v$ 之后图长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/6zdh7eqb.png)

> 这里紫色部分和红色部分都可能不存在，但由于我们限定这是一条非树边因此绿色部分一定存在。$u$ 上面的部分也可能不存在，但稍后我们会看到这并不影响判断，

首先红色部分必须存在向上的连边否则就会和绿色部分分开。因此我们可以把红色部分和 $u$ 上面的部分看作一个整体。当 $u$ 为根节点的时候红色部分不存在，不过这不会影响我们的判断。

注意到绿色部分也是一个整体的连通块，紫色部分会构成若干连通块。那么紫色部分的每个子树要么和绿色部分有连边，要么和红色部分有连边（且红色部分存在）。我们分几类情况讨论：

- 存在一个紫色的子树和红绿均无连边：这个子树会被分割为独立的一个连通块，一定不合法。
- 存在一个紫色的子树同时和红绿均有连边（且红色部分存在）：（在判掉上面那种情况的前提下）一定合法。
- 每个紫色的子树都只和红色或绿色中的一个连边：这时需要绿色部分和红色部分有连边，或者红色部分不存在。

考虑三种情况怎么判，发现只需要维护某个子树内最浅和最深的一条返祖边，可以用线段树合并或启发式合并求出。对于第三种情况，绿色部分可以写成 DFS 序上的 $O(1)$ 个连续段，维护 DFS 序区间最小值即可。对于求出绿色部分顶端的点，发现本质上是树上 $k$ 级祖先。

接下来我们考虑树边怎么判。设 $u=fa_v$，有以下情况：

- $u$ 是根节点：如果 $u$ 在 DFS 树上的儿子数量 $\ge 3$ 一定无解，如果 $u$ 在 DFS 树上的儿子数量 $=2$ 那么要求 $v$ 在删去 $u$ 之后是一个孤立点。如果 $u$ 在 DFS 树上的儿子只有 $v$，那么这要求 $v$ 在 DFS 树上也只有一个儿子，或者 $v$ 是孤立点。
- $u$ 不是根节点：要求 $u$ 的除了 $v$ 的每个儿子都得有向上的连边，然后如果 $v$ 有儿子就必须连到 $u$ 的祖先上。

时间复杂度：$O(m\log n)$ 或 $O(m\log^2n)$。

```cpp
//-DYUNQIAN -std=c++14 -O2 -Wall
#include<bits/stdc++.h>

#define ll long long
#define fi first
#define se second
#define mk make_pair

using namespace std;

inline int read(){
    int x=0,f=1;char c=getchar();
    for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
    for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
    return x*f;
}

void cmax(int &x,int v){x=max(x,v);}
void cmin(int &x,int v){x=min(x,v);}

const int N=3e5+5;
vector<int>G[N],adj[N];
vector<int>R[N];
set<int>S[N];
int n,m;

struct SegTree{
	int M,k,d[N<<2];
	void upd(int p){d[p]=min(d[p<<1],d[p<<1|1]);}
	void build(int n,vector<int>A){
		k=0,M=1;while(M<n)M<<=1,k++;
		for(int i=1;i<=M+M;i++)d[i]=n+1;
		for(int i=1;i<=n;i++)d[i+M-1]=A[i];
		for(int i=M-1;i>=1;i--)upd(i);
	}
	int qmin(int l,int r){
		int res=n+1;
		for(l+=M-1,r+=M;l<r;l>>=1,r>>=1){
			if(l&1)cmin(res,d[l++]);
			if(r&1)cmin(res,d[--r]);
		}
		return res;
	}
}T;

int dep[N],fa[N],sz[N],dfn[N],top[N],hson[N],dfc,pos[N],id[N];
void dfs1(int u,int de){
	dep[u]=de,sz[u]=1;
	for(int v:G[u]){
		if(v==fa[u])continue;
		fa[v]=u,dfs1(v,de+1),sz[u]+=sz[v];
		if(sz[v]>sz[hson[u]])hson[u]=v;
	}
}
void dfs2(int u,int tp){
	top[u]=tp,dfn[u]=++dfc,id[dfc]=u;
	if(hson[u])dfs2(hson[u],tp);
	for(int v:G[u]){
		if(v==fa[u]||v==hson[u])continue;
		dfs2(v,v);
	}
}
int getnode(int u,int v){
	assert(dfn[v]>=dfn[u]&&dfn[v]<=dfn[u]+sz[u]-1);
	int de=dep[u]+1;
	while(dep[top[v]]>de)v=fa[top[v]];
	int dis=dep[v]-de;
	return id[dfn[v]-dis];
}

struct BIT{
	int c[N];
	void clear(){memset(c,0,sizeof(c));}
	int lowbit(int x){return x&(-x);}
	void Add(int x,int v){for(int i=x;i<=n;i+=lowbit(i))c[i]+=v;}
	int sum(int x){int res=0;for(int i=x;i;i-=lowbit(i))res+=c[i];return res;}
	void add(int l,int r,int v){if(l<=r)Add(r+1,-v),Add(l,v);}
	int qval(int x){return sum(x);}
}W;

signed main(void){

#ifdef YUNQIAN
    freopen("in.in","r",stdin);
//    freopen("out.out","w",stdout);
#endif
	
	n=read(),m=read();
	vector<pair<int,int> >E;vector<int>deg(n+1,0);
	for(int i=1;i<=m;i++){
		int u=read(),v=read();E.emplace_back(mk(u,v));
		adj[u].emplace_back(v),adj[v].emplace_back(u),deg[u]++,deg[v]++;
	}
	
	vector<bool>vis(n+1,0);
	function<void(int,int)>buildtree=[&](int u,int fa){
		vis[u]=1;
		for(int v:adj[u]){
			if(!vis[v])dep[v]=dep[u]+1,buildtree(v,u),G[u].emplace_back(v);
			else if(dep[v]<dep[u]&&v!=fa)R[u].emplace_back(v);
		}
	};
	dep[1]=1,buildtree(1,0);
	dfs1(1,1),dfs2(1,1);
	
	vector<int>val(n+1,n+1);
	for(int i=1;i<=n;i++){
		for(int j:R[i])cmin(val[dfn[i]],dep[j]);
	}
	T.build(n,val);
	
	auto Merge=[&](set<int>&A,set<int>&B){
		if(A.size()<B.size())swap(A,B);
		for(int x:B)A.insert(x);B.clear();
	};
	
	vector<int>mxlow(n+1,0),mnlow(n+1,0);// max/min low
	function<void(int)>getlow=[&](int u){
		for(int v:G[u])getlow(v),Merge(S[u],S[v]);
		for(int j:R[u])S[u].insert(dep[j]);
		S[u].erase(S[u].lower_bound(dep[u]-1),S[u].end());
		if(S[u].size())mxlow[u]=*--S[u].end(),mnlow[u]=*S[u].begin();
		else mxlow[u]=0,mnlow[u]=n+1;
	};
	getlow(1);
	
	W.clear();vector<int>cut(n+1,0);
	
	fill(vis.begin(),vis.end(),0);
	map<pair<int,int>,bool>Ans;
	
	auto addres=[&](int u,int v){Ans[mk(u,v)]=Ans[mk(v,u)]=1;};
	auto getans=[&](int u){
		// (u,son[u]) | (anc[u],u)
		if(u==1){
			if(G[u].size()>=3)return ;
			if(G[u].size()==2){
				for(int v:G[u])if(sz[v]==1)addres(u,v);
			}
			if(G[u].size()==1){
				int v=G[u][0];
				if(G[v].size()<=1)addres(u,v);
			}
			return ;
		}
		for(int v:G[u]){
			if(mnlow[v]==mxlow[v])vis[mnlow[v]]=1;
			W.add(mnlow[v]+1,mxlow[v]-1,1);
		}
		for(int v:G[u]){
			if(mnlow[v]>=dep[u])cut[u]--;
			if(cut[u]==0){
				bool chk=1;
				for(int j:G[v])if(mnlow[j]>=dep[u])chk=0;
				if(chk)addres(u,v);
			}
			if(mnlow[v]>=dep[u])cut[u]++;
		}
		
		if(cut[u]>=1)goto ED2;
		for(int j:R[u]){
			int x=getnode(j,u);
			if(mnlow[x]>=dep[j])cut[j]--;
			if(cut[j]==0){
				if(vis[dep[j]])goto ED;
				if(W.qval(dep[j])>=1){addres(u,j);goto ED;}
				if(j==1){addres(u,j);goto ED;}
				if(T.qmin(dfn[x],dfn[u]-1)<dep[j]||T.qmin(dfn[u]+sz[u],dfn[x]+sz[x]-1)<dep[j])addres(u,j);
			}
			ED:if(mnlow[x]>=dep[j])cut[j]++;
		}
		
		ED2:for(int v:G[u]){
			if(mnlow[v]==mxlow[v])vis[mnlow[v]]=0;
			W.add(mnlow[v]+1,mxlow[v]-1,-1);
		}
	};
	
	for(int i=1;i<=n;i++)for(int j:G[i])cut[i]+=(mnlow[j]>=dep[i]);
	for(int i=1;i<=n;i++)getans(i);
	int res=0;for(auto e:E)res+=(Ans[mk(e.fi,e.se)]==0);cout<<res<<endl;

    return 0;
}
```

---

## 作者：AVENGER_M (赞：6)

## 前言

当你立下一个宏伟的或着看似简单的目标时，你最好三思、量力而行，例如想这题、写这题。

同时，我强烈谴责高实现难度题题解不放代码的行为。

## 思路

首先遍历整张图，得到 dfs 树，同时将所有边分为树边和返祖边（无向图 dfs 树没有横叉边）。我们接下来去分类讨论树边和返祖边有哪些边是非法的（非法边是删掉两点后，图不联通的边，合法即为联通）。

接下来默认 dfs 树根为 $1$。

### 对于树边

我们处理出点 $i$ 在树上的深度 $d_i$ 和深度的 $low_i$，也即 $d_i$ 和一端在子树内，另一端深度最小值的 $\min$。

注意这里是深度，因为我们没必要用 dfs 序。

接着对于每条树边，设其连接 $x$ 和 $f_x$，$f_x$ 为 $x$ 的父亲——

#### 如果 $f_x=1$：

删掉 $x,1$ 后图会裂为两部分联通块：第一种是 $x$ 下方的儿子的子树，第二种是 $1$ 下方除了 $x$ 以外的儿子的子树。

记 $|s_i|$ 为 $i$ 的儿子数，那么剩余联通块数必然为 $|s_x|+|s_1|-1$，如果 $|s_x|+|s_1|\le 2$，则边合法，不应计入答案，否则计入答案。

**注意这个不起眼的细节，最后要考。**

#### 如果 $f_x\not=1$：

删掉 $x,f_x$ 后树会裂为 $x$ 下方儿子子树部分，$f_x$ 下方除 $x$ 以外儿子子树部分，$f_x$ 子树外部分。很明显我们要使得前两个部分与 $x$ 上方部分联通，那么就要满足以下点的 $low$ 值全部 $\le d_x-2$：

- $x$ 的所有儿子。

- $f_x$ 的所有儿子，$x$ 除外。

实现技巧：记录 $uns_i$ 为 $i$ 的一个儿子，使得其 $low$ 值超过 $d_i-1$，如果有多个则为 $-1$，如果没有则为 $0$。那么判断第二部分的可行性就是看 $uns_{f_x}$ 是否等于 $0$ 或者 $x$。

### 对于返祖边

注意不要在祖先后代两个地方各加一次返祖边。问就是因为我踩了雷。

#### 通常情况：

接下来忘掉 $low$ 的存在。我们使用**树上启发式合并**动态维护出 $i$ 子树内所有返祖边祖先的深度构成的**不可重**集。

对于点 $x$，我们考虑以 $x$ 为返祖边后代端时，有哪些深度的祖先可能使这条边合法。

删掉 $x$ 和 $x$ 的一个祖先 $w$ 后，整棵树会变为三部分联通块：$x$ 的儿子子树、$w$ 靠近 $x$ 的儿子子树（但是挖掉了 $x$ 的子树）、$w$ 远离 $x$ 的儿子子树、$w$ 子树外部分。记 $w$ 靠近 $x$ 的儿子为 $w_0$。

- 首先，$w$ 远离 $x$ 的所有儿子子树都必须存在返祖边连向 $w$ 子树外部分。这个可以通过 $uns_w$ 是否为 $0$ 或者 $w_0$ 来判断。

- 满足上述条件后，如果 $w$ 靠近 $x$ 的联通块和 $w$ 外的联通块之间有返祖边连接着，那么图联通当且仅当 $x$ 的所有儿子子树到 $w_0$ 抠掉 $x$ 的子树或者 $w$ 子树外均至少有一条返祖边，人话就是 $x$ 的每个儿子子树内都存在深度 $<d_x$ 且不是 $d_w$ 的返祖边祖先。

- 满足上述条件后，如果 $w$ 靠近 $x$ 的联通块和 $w$ 外的联通块之间没有返祖边，那么**不仅以上条件要满足**，还需要**至少一个** $x$ 的儿子同时有达到 $w_0$ 抠掉 $x$ 的子树**以及** $w$ 子树外的返祖边，人话就是它内部存在深度 $\in(d_w,d_x)$ 和 $\in[1,d_w)$ 的返祖边祖先。

设 $x$ 的某个儿子 $y$ 子树内：

- 没有深度 $<d_x$ 的返祖边祖先：那么 $x$ 是没救了，**全部非法排除**。

- 有且仅有一个符合条件的深度：那么这个深度被删掉就**成为非法**的了，**需要排除**。

- 否则记 $<d_x$ 的深度最小为 $l$，最大为 $r$：对于深度 $\in(l,r)$ 的祖先，删掉它后 $y$ 子树就会链接起两个 $x$ 上面被切开的联通块。

然后我们对于这个点为后代的返祖边，我们检验它是否是被排除的点，以及存不存在链接两个联通块的子树，接着计算 $w_0$ 子树内和 $x$ 子树内祖先端深度 $<d_w$ 的返祖边数量想不想等，来鉴定 $x$ 到 $w$ 中间一块到上方是否有返祖边。这个可以用**启发式合并**或者**主席树**完成。

#### $w=1$ 且 $1$ 只有 $w_0$ 一个儿子：

据前车之鉴，我们还是要判一下根的。此时不存在 $w$ 外的联通块，也不存在 $w$ 远离 $x$ 的联通块，条件转化为了所有 $x$ 的儿子子树都与中间的一大块联通。

条件就是 $d_1=1$ 没有被排除且不是全部非法，非常简单但是坑。

## 总结

这里两种边有哪些合法都判断完了，但是请不要忘了我们要输出非法边数。

实现注意技巧，`vector` 存边记录编号，新开数组记录边种类，不要写挂启发式合并，`lower_bound` 和迭代器自减用好，根的情况判对，运用 $uns_i$ 减少码量，以及看清 $m$ 范围，数组不要开小。

时间复杂度 $O(m\log^2 n)$，由于有一个 $\log$ 是启发式合并，所以常数非常小，洛谷上最慢的测试点跑了 `668ms`。

## 代码

布肠，野旧 `3.17KB`。

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,dep[100005],fath[100005],amt[100005],gson[100005],ans;
int low[100005],unsat[100005],unsat2[100005];set<int>M;
vector<pair<int,int> >mp[100005],V[100005];
vector<int>nmp[100005];int stk[100005];
bool vis[100005],bta[300005],sing[300005],doub[300005],basc[300005];
vector<pair<int,pair<int,int> > >Q[100005];
int tr[100005],sbctr[300005];

void dfs(int x,int fa){
	fath[x]=fa;low[x]=dep[x]=dep[fa]+1;vis[x]=1;
	amt[x]=1;
	for(auto uu:mp[x]){
		int y=uu.first;if(y==fa)continue;
		if(vis[y]){
			if(dep[y]<dep[x]){
				bta[uu.second]=1;V[x].push_back(uu);low[x]=min(low[x],dep[y]);
			}
		}
		else{
			dfs(y,x);low[x]=min(low[x],low[y]);amt[x]+=amt[y];
			nmp[x].push_back(y);if(amt[y]>amt[gson[x]])gson[x]=y;
		}
	}
}

void addbit(int x,int v){
	for(;x<=n;x+=(x&-x))tr[x]+=v;
}

int querybit(int x){
	int ca=0;for(;x;x&=(x-1))ca+=tr[x];
	return ca;
}

void add(int x){
	for(auto uu:V[x])M.insert(dep[uu.first]);
	for(auto y:nmp[x])add(y);
}

void add424(int x,int v){
	for(auto uu:V[x])addbit(dep[uu.first],v);
	for(auto y:nmp[x])add424(y,v);
}

void dfsEX(int x){
	stk[dep[x]]=x;bool satis=1;set<int>s;map<int,int>t,tt;
	for(auto y:nmp[x])if(y!=gson[x]){
		dfsEX(y);set<int>::iterator itr=M.lower_bound(dep[x]);
		if(itr==M.begin())satis=0;
		else if((--itr)==M.begin())s.insert(*itr);
		else t[(*M.begin())+1]=max(t[(*M.begin())+1],(*itr)-1);
		M.clear();
	}
	if(gson[x]){
		dfsEX(gson[x]);set<int>::iterator itr=M.lower_bound(dep[x]);
		if(itr==M.begin())satis=0;
		else if((--itr)==M.begin())s.insert(*itr);
		else t[(*M.begin())+1]=max(t[(*M.begin())+1],(*itr)-1);
	}
	for(auto y:nmp[x])if(y!=gson[x])add(y);
	int mxm=0;for(auto uu:t){mxm=max(mxm,uu.second);tt[uu.first]=mxm;}
	for(auto uu:V[x]){
		int d=dep[uu.first],id=uu.second;
		if(d==1&&nmp[1].size()==1){
			doub[id]=sing[id]=satis&(s.count(1)==0);basc[id]=1;
		}
		else{
			doub[id]=sing[id]=satis&(s.count(d)==0);
			map<int,int>::iterator itr=tt.upper_bound(d);
			doub[id]&=(itr!=tt.begin()&&((--itr)->second)>=d);
			basc[id]=(unsat[uu.first]==0||unsat[uu.first]==stk[d+1]);
			Q[stk[d+1]].push_back(make_pair(d-1,make_pair(id,1)));
			Q[x].push_back(make_pair(d-1,make_pair(id,-1)));
		}
	}
	for(auto uu:V[x])M.insert(dep[uu.first]);
}

void dfsNEO(int x){
	for(auto y:nmp[x])if(y!=gson[x]){dfsNEO(y);add424(y,-1);}
	if(gson[x])dfsNEO(gson[x]);
	for(auto uu:V[x])addbit(dep[uu.first],1);
	for(auto y:nmp[x])if(y!=gson[x])add424(y,1);
	for(auto uu:Q[x])sbctr[uu.second.first]+=uu.second.second*querybit(uu.first);
}

int main(){
	cin.tie()->sync_with_stdio(0);
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int x,y;cin>>x>>y;
		mp[x].push_back(make_pair(y,i));
		mp[y].push_back(make_pair(x,i));
	}
	dfs(1,1);
	for(int x=1;x<=n;x++){
		for(auto y:nmp[x]){
			if(low[y]>=dep[x]){if(unsat[x])unsat[x]=-1;else unsat[x]=y;}
			if(low[y]>=dep[x]-1){if(unsat2[x])unsat2[x]=-1;else unsat2[x]=y;}
		}
	}
	for(int x=2;x<=n;x++){
		if(fath[x]==1){
			if(!((nmp[x].size()==0&&nmp[1].size()==2)||(nmp[1].size()==1&&nmp[x].size()<=1)))ans++;
		}
		else if(!((unsat[fath[x]]==x||!unsat[fath[x]])&&!unsat2[x]))ans++;
	}
	dfsEX(1);dfsNEO(1);
	for(int i=1;i<=m;i++)if(bta[i]){
		if(!(basc[i]&(sbctr[i]?sing[i]:doub[i])))ans++;
	}
	cout<<ans;
	return 0;
}
```

## 花絮

早上的膜你赛原题是这道。大样例“非常”有强度，以至于一份判错树边部分根的边角料的代码能够通过所有大样例并在捆测的影响下爆零，并且让你感受到输出答案和标准答案差 $1$ 方向还不固定的绝望感。

这是一位早上十点开始写代码的同学的提交记录：

![](https://cdn.luogu.com.cn/upload/image_hosting/7edaxamd.png)

---

## 作者：xxxxxzy (赞：5)

**本篇题解非正解做法，如果要学习正解做法请转步其他题解。**

给一个乱搞做法，感谢 @yzq_yzq。

首先，这个题有个很显然的错误做法：对所有点线段树分治，然后加点并加入周围的边维护连通性。

观察这个做法，会发现一个大小为 $k_u$ 的邻域对时间的影响其实是 $O(k_u \times cnt_u \times \log n)$，这里的 $cnt_u$ 代指线段树分治的序列上，$u$ 的邻域们组成的连续段的段数。

发现出题人如果想要卡你，大概率是通过大菊花来卡。

所以我们考虑对于一个足够大的 $u$，我们把他的所有邻居节点在线段树分治的序列上放在一起，这样 $u$ 这个点就只会被加入 $1$ 次。

考虑到可能有相邻的大菊花 $u,v$，我们按照 $k_u$ 排序，把 $k_u$ 大的放在前面。

这样复杂度应该是 $O((\dfrac{m}{n})^2m \log n)$ 的，对于 $n,m$ 都在 $10^5$ 的量级已经可以通过。事实上，这已经足以通过本题 261 / 273 个点了。

继续观察，发现卡掉这个做法的是一些稠密图。判断运行时间，如果超时直接输出 0，便可以通过这道题目。

[提交记录](https://www.luogu.com.cn/record/227004119)。

```cpp
//如果交了然后 Wa 了，等洛谷评测机波动过去再交一下。
i32 fa[N], siz[N], tp;
pii stk[N];
fn i32 get(i32 u) { return (fa[u] == u ? u : get(fa[u])); }
fn bool merge(i32 u, i32 v) {
  u = get(u), v = get(v);
  if (u == v) return 0;
  if (siz[u] > siz[v]) swap(u, v);
  stk[++tp] = mp(u, v);
  return fa[u] = v, siz[v] += siz[u], 1;
}
fv back(i32 o) {
  while (tp > o) {
    auto [u, v] = stk[tp--];
    siz[v] -= siz[u], fa[u] = u;
  }
}
i32 n, m, x, y, ans, lst[N], u[N], v[N], cnt[N];
bool vis[N], tg[N];
vi vec[N << 3], G[N];
fv ins(i32 x, i32 ql, i32 qr, i32 p = 1, i32 l = 1, i32 r = m) {
  if (qr < l || r < ql) return;
  if (ql <= l && r <= qr) return vec[p].pb(x);
  i32 mid = (l + r) >> 1;
  ins(x, ql, qr, p << 1, l, mid), ins(x, ql, qr, p << 1 | 1, mid + 1, r);
}
fv sol(i32 p, i32 l, i32 r) {
  i32 o = tp;
  for (i32 x : vec[p]) {
    vis[x] = 1;
    for (i32 y : G[x]) if (vis[y]) merge(x, y);
    if ((double)clock() / CLOCKS_PER_SEC > 2.8) cout << 0, exit(0);
  }
  if (tp >= n - 3) {
    back(o);
    for (i32 x : vec[p]) vis[x] = 0;
    return;
  }
  i32 mid = (l + r) >> 1;
  if (l == r) ans += (tp < n - 3);
  else sol(p << 1, l, mid), sol(p << 1 | 1, mid + 1, r);
  back(o);
  for (i32 x : vec[p]) vis[x] = 0;
}
fv sol() {
  cin >> n >> m;
  rep (i, 1, n) fa[i] = i, siz[i] = 1;
  vector <pii> e;
  rep (i, 1, m) {
    cin >> x >> y;
    if (x > y) swap(x, y);
    cnt[x]++, cnt[y]++, e.pb({x, y});
  }
  for (auto &[u, v] : e) if (cnt[u] < cnt[v]) swap(u, v);
  sort(e.begin(), e.end(), [&](pii x, pii y) { return cnt[x.fi] == cnt[y.fi] ? x.fi < y.fi : cnt[x.fi] > cnt[y.fi]; });
  rep (i, 1, m) {
    u[i] = e[i - 1].fi, v[i] = e[i - 1].se;
    if (lst[u[i]] < i - 1) ins(u[i], lst[u[i]] + 1, i - 1);
    if (lst[v[i]] < i - 1) ins(v[i], lst[v[i]] + 1, i - 1);
    lst[u[i]] = lst[v[i]] = i;
    G[u[i]].pb(v[i]), G[v[i]].pb(u[i]);
  }
  rep (i, 1, n) if (lst[i] < m) ins(i, lst[i] + 1, m);
  sol(1, 1, m);
  cout << ans << "\n";
}
int main() {
  sol();
}
```

---

## 作者：XuYueming (赞：3)

## 题目分析

首先可以确定的是需要枚举断边，所以我们希望两次枚举之间能有些关联。不难想到类树形 DP 的套路，建 DFS 树，只不过这题除了讨论和父亲之间的边，还要考虑返租边。以下钦定以 $1$ 为树根。

### 树边

先从简单的树边开始考虑。考虑不经过 $u$ 和 $u$ 的父亲 $v$，对答案是否产生贡献。为方便实现，记录的是操作后整张图依旧联通的边数。

分为两种情况讨论。

1. $v$ 为树根。
	1. $v$ 仅有 $u$ 一个儿子。操作后整张图依旧联通。
    1. $v$ 还有另一个儿子 $yzh$。整张图联通当且仅当 $u$ 是叶子结点，不然 $u$ 的子孙和 $yzh$ 就断开了。
    1. $v$ 还有多个儿子。无论怎样，由于不能经过 $v$，剩下来的孩子都互不连通。
1. $v$ 为内部节点。
	1. 最好的情况，$v$ 的所有子树都能向上连到 $v$ 的祖先，$u$ 的所有子树同样能连到 $v$ 的祖先，操作后整张图依旧连通。
    2. $u$ 是叶子结点，并且 $v$ 的其他子树都能连到 $v$ 的祖先，操作后整张图依旧连通。
    3. 其他情况操作后图均不连通。

可以通过下图辅助理解。

![情况 1](https://cdn.luogu.com.cn/upload/image_hosting/ciuvvgvx.png)

![情况 2](https://cdn.luogu.com.cn/upload/image_hosting/29iusktl.png)

具体实现时，按照上述方法模拟即可。具体如下：
1. 用一次 dfs 记录 $1$ 的儿子数量和 $u$ 儿子数量，再用一次 dfs 统计答案即可。
2. 用一次 dfs 求出以 $u$ 为根的子树通过一条返租边能到达的最深结点，和次深结点。由于返租边的另一边只能是祖先结点，所以可以用深度来代替返租边另一边的结点。再用另一次 dfs 按照如下顺序求解。
	1. $u$ 有一个结点不能连到 $u$ 的祖先，那么不管如何，删去 $u$ 这个点一定会导致图不连通。
    2. $u$ 的某一个子树只有一条返租边连向 $u$ 的祖先 $xym$，那么如果存在 $u \rightarrow xym$ 这条边，删去后图不连通，可以用一个数据结构维护不能删去的点（实际记录深度即可）。
    3. 考虑 $u \rightarrow v$ 这条树边，如果 $v \neq xym$ 并且 $v$ 的子树中没有不能连向 $v$ 的祖先的子树，或者仅有一个并且其为身为叶子结点的 $u$，删去后图依旧联通。

### 非树边

考虑完树边，再来看看相对复杂的非树边 $u \rightarrow yzh$，易知 $yzh$ 一定是 $u$ 的祖先。

经过我们观察，删去非树边比删去树边多出了 $u \rightarrow \cdots \rightarrow yzh$ 这一条链上的部分，即 $yzh$ 的子树减去 $u$ 的子树，如下图蓝色部分。

![yzh 520](https://cdn.luogu.com.cn/upload/image_hosting/v8u97n9v.png)

所以我们考虑图的连通性的时候就要算上它们，其他和以上讨论类似。

1. $yzh$ 是树根，按照以上特判即可。
1. 红色部分不连通，删去一定不连通。
1. $u$ 有一棵子树既不能连到红色部分，又不能连到蓝色部分，删去一定不连通。
1. $u$ 为叶子结点，或者所有子树能和红色或蓝色其中一个部分连通，当且仅当红色和蓝色部分连通，删去后连通。
1. 有一棵子树既和红色部分连通又和蓝色部分连通，删去图依旧联通。
1. 其他情况删去一定不连通。

~~很抽象是吧~~，这道题目考验我们强大的逻辑推理能力，做到情况不漏，实现细心。所以来讲讲具体实现。

1. 按照树边特判即可。
1. 记录 $yzh$ 有多少棵子树不与 $yzh$ 祖先连通，如果大于一个，删去不连通。
1. 这种情况相当于有一棵子树不能练到 $u$ 的祖先结点，这个同上解决。也一样记录特殊情况，即 $u$ 的某一个子树只有一条返租边连向 $u$ 的祖先 $xym$，那么不能删掉 $xym$ 这个点。
1. 我们想知道蓝色部分能不能连到红色部分，发现可以用倍增解决出蓝色部分能连出的最浅深度。这个倍增不能包含 $u$ 子树的信息。
1. 相当于 $yzh$ 处在 $u$ 连出的某两条边之间，那么记录 $u$ 子树中能连出的最浅深度，这个要比 $yzh$ 浅，然后记录连到 $u$ 祖先最深的深度，这个要比 $yzh$ 深。前者第一次 dfs 可以预处理出，后者发现需要将子树里的返租边，但是反不到 $u$ 的返租边删除，即只保留另一端深度小于 $u$ 的返租边。这个可以用 dfs 序加线段树或者左偏树或者线段树合并，但是最方便的做法当然是愉快地启发式合并啦。

## 代码（已略去快读快写）

讲了这么多，实际代码需要格外的小心，注意细节。令 $n$ 和 $m$ 同阶，那么整体时间复杂度是 $\Theta(n \log ^ 2 n)$ 或者 $\Theta(n \log n)$ 的。

### 左偏树

```cpp
//#pragma GCC optimize(3)
//#pragma GCC optimize("Ofast", "inline", "-ffast-math")
//#pragma GCC target("avx", "sse2", "sse3", "sse4", "mmx")
#include <iostream>
#include <cstdio>
#define debug(a) cerr << "Line: " << __LINE__ << " " << #a << endl
#define print(a) cerr << #a << "=" << (a) << endl
#define file(a) freopen(#a".in", "r", stdin), freopen(#a".out", "w", stdout)
#define main Main(); signed main(){ return ios::sync_with_stdio(0), cin.tie(0), Main(); } signed Main
using namespace std;

#include <algorithm>
#include <vector>
#include <set>

const int inf = 0x3f3f3f3f;
const int  N  = 100010;
const int  M  = 300010;
const int lgN = __lg(N) + 2;

struct Graph{
	struct node{
		int to, nxt;
	} edge[M << 1];
	int eid, head[N];
	inline void add(int u, int v){
		edge[++eid] = {v, head[u]};
		head[u] = eid;
	}
	inline node & operator [] (const int x){
		return edge[x];
	}
} xym;

struct node{
	int fi, se;
	node (int fi = inf, int se = inf): fi(fi), se(se) {}
	inline node operator + (const int val) const {
		node res(fi, se);
		if (val < fi) res.se = res.fi, res.fi = val;
		else if (fi < val && val < se) res.se = val;
		return res;
	}
	inline node operator + (const node & o) const {
		return *this + o.fi + o.se;
	}
	inline node & operator += (const node & o) {
		return *this = *this + o;
	}
};

int n, m, ans;

int dpt[N], yzh[N][lgN];
int L[N], R[N], timer;
vector<int> son[N];
node f[N][lgN], pos[N], s[N];
int sum[N], who[N];

void dfs(int now){
	L[now] = ++timer, dpt[now] = dpt[yzh[now][0]] + 1;
	vector<node> l, r; int cnt = 0;
	for (int i = xym.head[now]; i; i = xym[i].nxt){
		int to = xym[i].to;
		if (to == yzh[now][0]) continue;
		if (dpt[to]) pos[now] += dpt[to];
		else {
			son[now].push_back(to), yzh[to][0] = now, ++cnt;
			dfs(to), s[now] += s[to], l.push_back(s[to]), r.push_back(s[to]);
			if (s[to].fi >= dpt[now]) ++sum[now], who[now] = to;
		}
	}
	for (int i = 1; i < cnt; ++i)      l[i] += l[i - 1];
	for (int i = cnt - 2; i >= 0; --i) r[i] += r[i + 1];
	for (int i = 0; i < cnt; ++i){
		int to = son[now][i];
		if (i > 0) f[to][0] += l[i - 1];
		if (i + 1 < cnt) f[to][0] += r[i + 1];
		f[to][0] += pos[now];
	}
	R[now] = timer, s[now] += pos[now];
}

int root[N], tot;
int deleted[M], dtop;
int lson[M], rson[M], val[M];
int dist[M];

int newNode(int val){
	int res = dtop ? deleted[dtop--] : ++tot;
	lson[res] = rson[res] = dist[res] = 0;
	::val[res] = val;
	return res;
}

int combine(int x, int y){
	if (!x || !y) return x | y;
	if (val[x] < val[y]) swap(x, y);
	rson[x] = combine(rson[x], y);
	if (dist[rson[x]] > dist[lson[x]]) swap(lson[x], rson[x]);
	return dist[x] = dist[rson[x]] + 1, x;
}

void redfs(int now){
	set<int> not_ok;
	set<pair<int, int> > stt;
	bool flag = false;
	for (const auto& to: son[now]){
		redfs(to);
		while (root[to] && val[root[to]] >= dpt[now]){
			deleted[++dtop] = root[to];
			root[to] = combine(lson[root[to]], rson[root[to]]);
		}
		if (root[to] && val[root[to]] != s[to].fi)
			stt.insert({val[root[to]], s[to].fi});
		root[now] = combine(root[now], root[to]);
		if (s[to].fi >= dpt[now]) flag = true;
		else if (s[to].se >= dpt[now]) not_ok.insert(s[to].fi);
	}
	vector<pair<int, int> > l(stt.begin(), stt.end()); stt.clear();
	int tot = l.size();
	for (int i = tot - 2; i >= 0; --i)
		l[i].second = min(l[i].second, l[i + 1].second);
	for (int i = xym.head[now]; i; i = xym[i].nxt){
		int to = xym[i].to;
		if (dpt[to] > dpt[now]) continue;
		root[now] = combine(root[now], newNode(dpt[to]));
		if (to == 1){
			if (sum[to] != 1){
				if (to == yzh[now][0] && son[now].size() == 0u && sum[to] == 2) ++ans;
			} else {
				if (to == yzh[now][0] && son[now].size() != 1u) continue;
				if (to != yzh[now][0] && (flag || not_ok.count(1))) continue;
				++ans;
			}
			continue;
		}
		if (flag) continue;
		if (to != yzh[now][0]){
			node sum; int u = now;
			for (int k = lgN - 1; k >= 0; --k)
			if (yzh[u][k] && dpt[yzh[u][k]] > dpt[to])
				sum += f[u][k], u = yzh[u][k];
			if (sum.fi >= dpt[to]){
				vector<pair<int, int> >::iterator it = 
					upper_bound(l.begin(), l.end(), pair<int, int>{dpt[to], inf});
				if (it == l.end() || it -> second >= dpt[to]) continue;
			}
		}
		if (sum[to] > 1) continue;
		if (sum[to] != 0 && (L[now] < L[who[to]] || R[who[to]] < L[now])) continue;
		if (not_ok.count(dpt[to])) continue;
		++ans;
	}
}

signed main(){
	read(n, m);
	for (int i = 1, u, v; i <= m; ++i) read(u, v), xym.add(u, v), xym.add(v, u);
	dfs(1);
	for (int k = 1; k < lgN; ++k)
	for (int i = 1; i <= n; ++i){
		yzh[i][k] = yzh[yzh[i][k - 1]][k - 1];
		f[i][k] = f[i][k - 1] + f[yzh[i][k - 1]][k - 1];
	}
	redfs(1), write(m - ans);
	return 0;
}
```

### 启发式合并

[代码。](https://www.luogu.com.cn/paste/2xlnc5t2)

### dfs 序加线段树

[代码。](https://www.luogu.com.cn/paste/he31h62r)

### 线段树合并

~~补题降智以为 $\Theta(n \log n)$ 的线段树合并是 $\Theta(\log n)$ 的，总的时间复杂度是 $\Theta(n ^ 2 \log n)$ 的，喜提 TLE。但是还是放出来吧，~~写都写了~~。~~

~~[代码。](https://www.luogu.com.cn/paste/bd4gv89l)~~

#### UPDATE on 2024.4.7

~~好吧，写题解更降智。~~ 维护一个权值线段树，然后向上合并。你干嘛要删除啊，每次查询 $[1, dpt[now])$ 里的最大值就行了，这样就不会超时。

[代码。](https://www.luogu.com.cn/paste/yio6p2gn)

## UPDATE on 2024.4.17

发现分析中一个 $u$ 没用 $\KaTeX$ 表示，已修复。

---

## 作者：Add_Catalyst (赞：1)

# P9907 [COCI 2023/2024 #1] Mostovi 题解

## 前言

一道挺考察综合能力的题目，代码能力和分析能力都很有体现。

---

## 题意分析

在去除原题一大段废话后，题意就十分明确了，洛谷的题面也是直接告诉我们了：给定一张 $n$ 个点 $m$ 条边的无向连通图，求有多少条边满足删去这条边两端的两个点之后，剩余的 $n-2$ 个点不连通。

---

## 思路

### 部分分

1. 第 1、2 两个子任务：用并查集维护；

2. 第 3 个子任务：我真不知道怎么写……

3. 第 4 个子任务：因为 DFS 树上非树边较少，可以枚举边，然后进行一系列操作（我们老师讲的，我当时直接懵逼了，所以不保证正确性）。

### 正解（大致思路）

首先，我们很容易想到要建一棵 DFS 树，然后边就分成了**树边**与**非树边**。

分类讨论：（合法是指：删除后剩余的 $n-2$ 个点 ***连通***，与题目相反）

1. 非树边：

   我们再来画一个非常直观的图（只包括树边）：

   ![美丽的图片](https://cdn.luogu.com.cn/upload/image_hosting/j9duj8j4.png?x-oss-process=image/resize,m_lfit,h_510,w_450)

   假设我们现在选了一条非树边，是连接 $u$ 与 $v$ 的（其中 $v$ 的深度更小），我们将它们删除，树就变成了图中的样子（“上”、“下”两部分可能不存在），那么现在的思路就很清晰，我们只要分类讨论就可以得出结果：

   1. 没有“上”部分（$v$ 为树根）：当且仅当根的子节点数 $\le1$，删除*合法*；
   2. “上”部分自己不联通：删除*不合法*；
   3. 当“下”部分（“下”部分存在）中有任意一棵子树无法连接到“上”与“中”部分：删除*不合法*；
   4. “下”部分中所有子树都只能够与“上”、“中”其中一部分连接或者没有“下”部分：此时当且仅当“中”部分与“上”部分能够连接，删除*合法*。
   5. “下”部分中有任意一棵子树能够同时与“上”、“中”两部分连接：删除*合法*；

2. 树边：（可以视作“非树边”部分中没有“中”部分）

   我们设一条树边连接 $u$ 与 $v$ ，其中 $v$ 是 $u$ 的父节点，那么依然是分类讨论：

   1. $v$ 为根：考虑根的子节点数，
      1. 只有一个子节点：当且仅当 $u$ 的子节点数 $\le 1$，删除*合法*；
      2. 有两个子节点：当且仅当 $u$ 的子节点数 $= 0$，删除*合法*；
      3. 有两个以上子节点：删除*不合法*；
   2. $v$ 不为根：那么显而易见，要求删除 $u$，$v$ 后，以他们所有剩余**子节点**为根的子树都有连到 $v$ 上方的边，删除*合法*。

在建树之后，就会发现一个非常有用的性质：树上的非树边全都是**返祖边**，也就是从某个节点连到自己的**祖先**上，利用这个性质，我们可以方便地把非树边的另一端转换成深度，并进行记录。

对于上方的各个讨论结果，我们一个一个来看他们的解决方案：

1. 非树边（$u$ 到 $v$，其中 $v$ 的深度更小）：
   1. 没有“上”部分（$v$ 为树根）：记录一下根的子节点数即可轻松判断；
   2. “上”部分自己不联通：记录以 $v$ 的子节点为根的子树中有几棵无法连接到 $v$ 的祖先上，如果这个数 $>1$，删除*不合法*；
   3. “下”部分（“下”部分存在）中有任意一棵子树无法连接到“上”与“中”部分：用树上 DP 解决，同时用一个 STL::map 维护特殊情况：某棵子树只有一条连到 $u$ 的祖先上的边，那么当另一端被删除，这棵子树就独立出来了，删除*不合法*；
   4. “下”部分中所有子树都只能够与“上”、“中”其中一部分连接或者没有“下”部分：我们可以倍增处理后“中”部分能够到达的最小深度，然后进行判断即可。
   5. “下”部分中有任意一棵子树能够同时与“上”、“中”两部分连接：我们可以记录下所有以 $u$ 的子节点为根的子树能够到达的深度最小值与小于 $u$ 的深度的最小值，设为 $l,r$，判断 $v$ 的深度是否处在其中任意一个开区间 $(l_i,r_i)$ 中，如果是，删除*合法*，这里可以用各种合并方法。
2. 树边（$v$ 是 $u$ 的父节点）：
   1. $v$ 为根：只要记录所有节点的子节点数即可方便判断；
   2. $v$ 不为根：记录以 $v$ 的子节点为根的子树中有几棵无法连接到 $v$ 的祖先上，再分类：
      1. 如果这个数 $>1$，删除*不合法*；
      2. 如果这个数 $=1$，当且仅当无法连接到 $v$ 的祖先上的子树的根为 $u$，同时 $u$ 是叶子节点，删除*合法*；
      3. 如果这个数 $=0$，删除*合法*。

***提示：分类讨论的顺序很重要，好的顺序可以规避错误与节省精力。***

---

## 代码实现

启发式合并做法：

```cpp
//#define Local
#include<algorithm>
#include<iostream>
#include<vector>
#include<set>
#include<map>
#define INF 0x3f3f3f3f
#define F first
#define S second
#define Pii pair<int,int>
#define min(a,b) ((a)>(b)?(b):(a))
#define tomin(a,b) ((a)=min((a),(b)))
#define FOR(i,a,b) for(register int i=(a);i<=(b);++i)
#define DOR(i,a,b) for(register int i=(a);i>=(b);--i)
#define EDGE(g,i,u,v) for(register int (i)=(g).h[(u)],(v)=(g).v[(i)];(i);(i)=(g).nxt[(i)],(v)=(g).v[(i)])
#define main Main();signed main(){ios::sync_with_stdio(0);cin.tie(0);return Main();}signed Main
using namespace std;
namespace IO {
#ifndef Local
	inline char gc() {
		static char BB[1000001],*S=BB,*T=BB;
		return S==T&&(T=(S=BB)+fread(BB,1,1000000,stdin),S==T)?(EOF):*S++;
	}
#endif

#ifdef Local
#define gc() getchar()
#endif

	template<typename T>
	inline void rd(T& x) {
		int w=1;
		x=0;
		char ch=gc();
		while((ch<'0'||ch>'9')&&ch!=((EOF))) {
			if(ch=='-')w=-1;
			ch=gc();
		}
		while(ch>='0'&&ch<='9')
			x=(x<<3)+(x<<1)+(ch^48),ch=gc();
		x*=w;
		return;
	}
	template <typename T>
	void write(T x) {
		if(x<0)putchar('-'),x=-x;
		if(x>9)write(x/10);
		putchar(x%10+'0');
	}
	template <typename T>
	inline void wr(T x,char End='\n') {
		write(x),putchar(End);
	}
}
using namespace IO;
const int N=1e5+10,M=3e5+10,lV=19,lN=17;
bool vis[N];
int n,m,ans;
int fa[N][lV];
set<int> st[N];
vector<int> son[N];
int dep[N],sum[N],id[N];
struct Chain_Forward_Star { //链式前向星
	int tot,v[M<<1],nxt[M<<1],h[N];
	inline void att(int U,int V) {
		v[++tot]=V,nxt[tot]=h[U],h[U]=tot;   //加入单向边
	}
	inline void con(int U,int V) {
		att(V,U),att(U,V);   //加入双向边
	}
} g;
struct node {
	int x,y;
	node() {
		x=y=INF;
	}
	inline void merge(int val) {
		if(val==x)return;
		if(val<x)y=x,x=val;
		else tomin(y,val);
	}
	inline void merge(const node &b) {
		merge(b.x),merge(b.y);
	}
	friend node merge(node a,const node &b) {
		a.merge(b);
		return a;
	}
} f[N][lV],s[N],pos[N];
/*
本题有多处用到最小/严格次小值，
为了方便，我们在此处开一个结构体node，保存最小与严格次小值，
从本题代码中，我们也能够看出，它确实便利了我们很多.
*/
/*
变量说明:
n，m:如题目所述；
ans:满足删去这条边两端的两个点之后，剩余的n-2个点连通的个数(与题目描述相反，便于判断)；
fa[u][i]:u的2^i级祖先；
STL::set st[u]数组:用于启发式合并该子树中能够到达上方的所有边的深度；
dep[u]:u在DFS树中的深度；
sum[u]:以u的子节点为根的子树中，有几棵没有能够连到u的祖先上的边，id[u]记的是这类子节点中任意一个；
STL::vector son[u]数组:在DFS树上，u的子节点；
g:链式前向星，用于存图；
f[u][i]:去掉以u为根的这棵子树后，以u的2^i级祖先为根的树中的边能够向上到达的最小/严格次小深度；
s[u]:以u为根的这棵子树中的边能够向上到达的最小/严格次小深度；
pos[u]:u上的非树边能够向上到达的最小/严格次小深度；
*/
void dfs1(int u) {
	vis[u]=1,dep[u]=dep[fa[u][0]]+1;
	vector<node> lmx,rmx;//存下以子节点的根的这子树中的边能够向上到达的最小/严格次小深度
	EDGE(g,i,u,v)if(v!=fa[u][0]) {
		if(!vis[v]) {
			fa[v][0]=u,dfs1(v);
			s[u].merge(s[v]),lmx.emplace_back(s[v]),rmx.emplace_back(s[v]);
			son[u].emplace_back(v);
			if(s[v].x>=dep[u])++sum[u],id[u]=v;
		} else pos[u].merge(dep[v]);
	}
	if(!son[u].empty()) {
		int sons=son[u].size();
		FOR(i,1,sons-1)lmx[i].merge(lmx[i-1]);
		//前缀处理，此时其含义变成以1~i个子节点的根的这子树中的边能够向上到达的最小/严格次小深度
		DOR(i,sons-2,0)rmx[i].merge(rmx[i+1]);
		//后缀处理，此时其含义变成以i~son[u].size()个子节点的根的这子树中的边能够向上到达的最小/严格次小深度
		FOR(i,0,sons-1) {
			int v=son[u][i];
			if(i)f[v][0].merge(lmx[i-1]);//i之前的最小/严格次小深度
			if(i+1<sons)f[v][0].merge(rmx[i+1]);//i之后的最小/严格次小深度
		}
	}
	s[u].merge(pos[u]);//和以u为根的这棵子树中的边能够向上到达的最小/严格次小深度
	lmx.clear(),rmx.clear();
}/*第一遍DFS:建出DFS树，更新s[u]，pos[u]，f[u][0]*/
void dfs2(int u) {
	f[u][0].merge(pos[fa[u][0]]);
	FOR(i,1,lN)
	fa[u][i]=fa[fa[u][i-1]][i-1],f[u][i]=merge(f[u][i-1],f[fa[u][i-1]][i-1]);
	for(int v:son[u])dfs2(v);
}/*第二遍DFS:倍增更新f[u][i]*/
void dfs3(int u) {
	map<int,bool> h;//用于标记哪些深度会让图不连通
	set< Pii > ST;//记录该子树能够到达的最大与最小深度
	bool flag=0;
	for(int v:son[u]) {
		dfs3(v);
		while(!st[v].empty()&&(*st[v].rbegin())>=dep[u])st[v].erase(prev(st[v].end()));//去掉深度不合法的
		if(st[v].size()>1)ST.insert({*st[v].rbegin(),*st[v].begin()});
		if(st[v].size()>st[u].size())swap(st[u],st[v]);//交换地址:O(1)
		for(int x:st[v])st[u].insert(x);
		st[v].clear();//进行启发式合并
		if(s[v].x>=dep[u]&&(flag=1))continue;//以该子节点为根的子树中的边没有能达到u的祖先的
		if(s[v].y>=dep[u])h[s[v].x]=1;
		//以该子节点为根的子树中的边只有一条能达到u的祖先，此时删去该祖先会让图不连通
	}
	vector< Pii > l(ST.begin(),ST.end());
	ST.clear();
	int tot=l.size();
	DOR(i,tot-2,0)tomin(l[i].S,l[i+1].S);//后缀处理
	EDGE(g,i,u,v) {
		if(dep[v]>dep[u])continue;//排除无用边
		st[u].insert(dep[v]);//加入集合
		if(v==1) {
			if(sum[v]!=1) {
				if(sum[v]==2&&son[u].empty()&&v==fa[u][0])++ans;//该边为树边并且合法
				continue;
			}
			if(1==fa[u][0]&&son[u].size()!=1)continue;//该边为树边但不合法
			if(1!=fa[u][0]&&(h.count(1)||flag))continue;//该边为非树边但不合法
			++ans;
			continue;
		}//没有“上”部分，v为根
		if(flag)continue;
		if(v!=fa[u][0]) {
			node t;
			int x=u;
			DOR(i,lN,0)if((dep[x]-(1<<i)>dep[v]))t.merge(f[x][i]),x=fa[x][i];
			//求出“中”部分能够到达的最小深度
			if(t.x>=dep[v]) {
				auto it=upper_bound(l.begin(),l.end(),make_pair(dep[v],INF));
				if(it==l.end()||(it->second)>=dep[v])continue;
				//“下”部分中没有任意一棵子树能够同时与“上”、“中”两部分连接
			}
		}//判断非树边
		if(sum[v]>1||sum[v]&&(u!=id[v])||h.count(dep[v]))continue;
		if(!sum[v]||!son[u].size())++ans;
	}
	h.clear(),l.clear();
}/*第三遍DFS:求出答案*/
signed main() {
	rd(n),rd(m);
	FOR(i,1,m) {
		int u,v;
		rd(u),rd(v);
		g.con(u,v);
	}
	dfs1(1),dfs2(1),dfs3(1);
	wr(m-ans);
	return 0;
}
```

我在此使用的是启发式合并，它是该算法的时间复杂度瓶颈。

时间复杂度应是：约 $O(m \log^2{m})$ （视 $n,m$ 同级，下同），但是由于启发式合并用了 STL::set ，其中记的又是深度，所以是完全跑不到满的，甚至比一些时间复杂度更小的还要快。

实际最快用时：**584ms**，内存：**64.99MB**。

### 优化

如果仅是优化理论时间复杂度，那么可以用左偏树合并，但是实际跑起来可能会慢一点。

```cpp
//#define Local
#include<algorithm>
#include<iostream>
#include<vector>
#include<set>
#include<map>
#define INF 0x3f3f3f3f
#define F first
#define S second
#define Pii pair<int,int>
#define min(a,b) ((a)>(b)?(b):(a))
#define tomin(a,b) ((a)=min((a),(b)))
#define FOR(i,a,b) for(register int i=(a);i<=(b);++i)
#define DOR(i,a,b) for(register int i=(a);i>=(b);--i)
#define EDGE(g,i,u,v) for(register int (i)=(g).h[(u)],(v)=(g).v[(i)];(i);(i)=(g).nxt[(i)],(v)=(g).v[(i)])
#define main Main();signed main(){ios::sync_with_stdio(0);cin.tie(0);return Main();}signed Main
using namespace std;
namespace IO {
#ifndef Local
	inline char gc() {
		static char BB[1000001],*S=BB,*T=BB;
		return S==T&&(T=(S=BB)+fread(BB,1,1000000,stdin),S==T)?(EOF):*S++;
	}
#endif

#ifdef Local
#define gc() getchar()
#endif

	template<typename T>
	inline void rd(T& x) {
		int w=1;
		x=0;
		char ch=gc();
		while((ch<'0'||ch>'9')&&ch!=((EOF))) {
			if(ch=='-')w=-1;
			ch=gc();
		}
		while(ch>='0'&&ch<='9')
			x=(x<<3)+(x<<1)+(ch^48),ch=gc();
		x*=w;
		return;
	}
	template <typename T>
	void write(T x) {
		if(x<0)putchar('-'),x=-x;
		if(x>9)write(x/10);
		putchar(x%10+'0');
	}
	template <typename T>
	inline void wr(T x,char End='\n') {
		write(x),putchar(End);
	}
}
using namespace IO;
const int N=1e5+10,M=3e5+10,lV=19,lN=17;
bool vis[N];
int n,m,ans;
int fa[N][lV];
int rt[N];
struct Leftist_Heap {
	int n;
	struct node {
		int val,id,ch[2],d,fa;
		int & operator [](bool x) {
			return ch[x];
		}
		friend bool operator <(node a,node b) {
			return a.val!=b.val?a.val<b.val:a.id<b.id;
		}
		friend bool operator >(node a,node b) {
			return b<a;
		}
	} t[M];
	/**/
	inline int& rs(int x) {
		return t[x][t[t[x][1]].d < t[t[x][0]].d];
	}
	inline int& ls(int x) {
		return t[x][t[t[x][1]].d >= t[t[x][0]].d];
	}
	/**/
	int merge(int x,int y) {
		if(!x||!y)return (x|y);
		if(t[x]<t[y])swap(x,y);
		t[rs(x)=merge(rs(x),y)].fa=x;
		t[x].d=t[rs(x)].d+1;
		return x;
	}
	inline int Insert(int val,int x) {
		t[++n]= {val,n,{0,0},1,0};
		return x?merge(n,x):n;
	}
	inline int Del(int x) {
		int p=merge(ls(x),rs(x));
		return t[p].fa=0,p;
	}
} lt;
vector<int> son[N];
int dep[N],sum[N],id[N];
struct Chain_Forward_Star {
	int tot,v[M<<1],nxt[M<<1],h[N];
	inline void att(int U,int V) {
		v[++tot]=V,nxt[tot]=h[U],h[U]=tot;
	}
	inline void con(int U,int V) {
		att(V,U),att(U,V);
	}
} g;
struct node {
	int x,y;
	node() {
		x=y=INF;
	}
	inline void merge(int val) {
		if(val==x)return;
		if(val<x)y=x,x=val;
		else tomin(y,val);
	}
	inline void merge(const node &b) {
		merge(b.x),merge(b.y);
	}
	friend node merge(node a,const node &b) {
		a.merge(b);
		return a;
	}
} f[N][lV],s[N],pos[N];
void dfs1(int u) {
	vis[u]=1,dep[u]=dep[fa[u][0]]+1;
	node lmx;
	vector<node> rmx;
	EDGE(g,i,u,v)if(v!=fa[u][0]) {
		if(!vis[v]) {
			fa[v][0]=u,dfs1(v);
			if(!son[u].empty())f[v][0].merge(lmx);
			s[u].merge(s[v]),lmx.merge(s[v]),rmx.emplace_back(s[v]);
			son[u].emplace_back(v);
			if(s[v].x>=dep[u])++sum[u],id[u]=v;
		} else pos[u].merge(dep[v]);
	}
	DOR(i,son[u].size()-2,0)rmx[i].merge(rmx[i+1]),f[son[u][i]][0].merge(rmx[i+1]);
	s[u].merge(pos[u]);
	rmx.clear();
}
void dfs2(int u) {
	f[u][0].merge(pos[fa[u][0]]);
	FOR(i,1,lN)
	fa[u][i]=fa[fa[u][i-1]][i-1],f[u][i]=merge(f[u][i-1],f[fa[u][i-1]][i-1]);
	for(int v:son[u])dfs2(v);
}
void dfs3(int u) {
	map<int,bool> h;
	set< Pii > ST;
	bool flag=0;
	for(int v:son[u]) {
		dfs3(v);
		while(rt[v]&&lt.t[rt[v]].val>=dep[u])rt[v]=lt.Del(rt[v]);
		if(rt[v])ST.insert({lt.t[rt[v]].val,s[v].x});
		rt[u]=rt[u]?lt.merge(rt[u],rt[v]):rt[v];
		if(s[v].x>=dep[u]&&(flag=1))continue;
		if(s[v].y>=dep[u])h[s[v].x]=1;
	}
	vector< Pii > l(ST.begin(),ST.end());
	ST.clear();
	int tot=l.size();
	DOR(i,tot-2,0)tomin(l[i].S,l[i+1].S);
	EDGE(g,i,u,v) {
		if(dep[v]>dep[u])continue;
		rt[u]=lt.Insert(dep[v],rt[u]);
		if(v==1) {
			if(sum[v]!=1) {
				if(sum[v]==2&&son[u].empty()&&1==fa[u][0])++ans;
				continue;
			}
			if(1==fa[u][0]&&son[u].size()!=1)continue;
			if(1!=fa[u][0]&&(h.count(1)||flag))continue;
			++ans;
			continue;
		}
		if(flag)continue;
		if(v!=fa[u][0]) {
			node t;
			int x=u;
			DOR(i,lN,0)if((dep[fa[x][i]]>dep[v]))t.merge(f[x][i]),x=fa[x][i];
			if(t.x>=dep[v]) {
				auto it=upper_bound(l.begin(),l.end(),make_pair(dep[v],INF));
				if(it==l.end()||(it->second)>=dep[v])continue;
			}
		}
		if(sum[v]>1||sum[v]&&(u!=id[v])||h.count(dep[v]))continue;
		if(!sum[v]||!son[u].size())++ans;
	}
	h.clear(),l.clear();
}
signed main() {
	rd(n),rd(m);
	FOR(i,1,m) {
		int u,v;
		rd(u),rd(v);
		g.con(u,v);
	}
	dfs1(1),dfs2(1),dfs3(1);
	wr(m-ans);
	return 0;
}
```

时间复杂度：约 $O(m \log_2{m})$。

实际最快用时：**799ms**，内存：**71.66MB**（比上面差了很多）。

---

---

## 作者：spdarkle (赞：0)

来一个巨赤石的做法，来自于模拟赛时的想法（因为太赤石没打出来）

首先注意到一个显而易见的结论：对于边 $(u,v)$ 若删除其中之一，则另一个端点成为割点，是这条边合法的充要条件。

先判掉 $(u,v)$ 其中某个端点自身作为割点的情况，这是容易的（设 $u$ 为割点，则这条边合法，$u$ 所在连通块点双连通分量只有两个且其中一个仅有 $(u,v)$）。

然后，显然，若 $(u,v)$ 都不是割点，则它们被包含在某个点双之中，删掉其中一个判断另外一个，只需要将这个点双拿出。

那么我们的问题就变成了一个点双。

拿出 DFS 树，则对于点双中任意一条边 $(u,v)$，只有几种不同的情况：

1. $u$ 是否是树根
2. $v$ 是否是 $u$ 的儿子
3. $v$ 是否是叶子

即，在树上，$u,v$ 消失会将这棵树划分为三个部分，我们若能够求证这三个部分仍然连通，则这条边不合法。

1. 当 $u$ 为树根时

   需要保证 $u$ 只有 $v$ 这个方向上的这一个儿子，亦或者保证 $v$ 是一个叶子

   可以简单通过维护 $sz$ 以及 $k$ 级祖先进行判断。

2. 当 $u$ 不为树根时

   1. 当 $v$ 为 $u$ 的儿子时

      只需要保证 $v$ 的所有儿子以及 $u$ 的其他儿子可以连到 $u$ 的上层即可。维护每个点可以连到的最上层节点（类似于 tarjan 中的 low 数组）即可判断

   2. 当 $v$ 不为 $u$ 的儿子时

      设 $t$ 是 $u$ 在 $v$ 方向的儿子。

      先判掉 $u$ 除了 $t$ 的其他儿子都可以连到 $u$ 上面。

      1. $v$ 是个叶子，则需要保证 $t$ 除掉 $v$ 后所能够连接到 $u$ 的最上方。

         这可以通过拍成 dfn 后，线段树维护以 dfn 为下标的 low 数组，通过区间查询实现。  

      2. $v$ 不是个叶子

         1. 当 $t$ 删掉子树 $v$ 后仍然可以连到 $u$ 上面

            则只需要保证 $v$ 的所有子树能够连接到的除了 $u$ 之外最浅的点在 $v$ 上方。

            可以通过维护一整个子树能够连接到子树及其子树根的父亲外的最浅点和最深点 $low$ 和$hig$，当 $low=hig$ 时给父亲打上不能够断掉 $(low,fa)$ 这条边标记。 这个最深点的维护可以通过线段树合并+区间查询最大值实现。

         2. 不能连到 $u$ 上面

            在上一个条件的基础上，增加了 $v$ 还应该有至少一个子树可以连接到 $v$ 上方 $u$ 下方的点的条件。

            可以通过维护 $v$ 所有 $hig$ 的最深值来实现。

由此我们通过线段树以及线段树合并解决了这个问题 $O(n\log n)$。

分类讨论和变量维护稍显复杂。

---

## 作者：hnczy (赞：0)

看到删边的问题，我们就很自然的想到 tarjan 和 dfs 树，当然这题是用 dfs 树来解决的。

我们建完树之后分为树边和非树边，这里可以分别讨论：

若为树边（$dep_u<dep_v$）：

$u$ 为根：

- $u$ 有三个及以上的儿子，$+1$。
- 有两个儿子，若 $v$ 不是孤点，$+1$。
- 若只有一个儿子，如果 $v$ 有其他儿子，$+1$。

$u$ 不为根：

- 需要判断 $u$ 的儿子中除了 $v$ 所有的子节点的子树中至少有一个需要与 $u$ 的祖先连边。
- 还需要判断 $v$ 的所有子节点的子树中至少有一个需要与 $u$ 的祖先连边。
- 若上面的条件都符合，则不用 $+1$。

若此为非树边（ $dep_v<dep_u$）：

$v$ 为根 ：

- 一个儿子，往下判断 $u$ 的儿子是否存在在 $v$ 和 $u$ 这条链上的点即可。
- 两个儿子或以上，$+1$。

$v$ 不为根：

- 若 $v$ 的其他有一个子树与 $v$ 的祖先不连，$+1$。

- $u$ 的一个子树没有返祖边，$+1$。

- 上和中两种点的连通性，使用 dfs 序加线段树维护区间最值：

  - 若上中连通，则全部连通，不用 $+1$。

  - 否则若它为叶子或没有一个为与中和上都连的一个子树，$+1$。

详细的实现可以看代码，本题细节很多，代码用了启发式合并和线段树的做法：

```c++
#include<bits/stdc++.h>
#define pii pair<int,int>
using namespace std;
const int N=3E5+5,inf=1e9;
int n,m;
vector<int>e[N],e1[N],e2[N];//树边和非树边
int cnt[N],dep[N],vis[N],ans,st1[N][20],cn,mi[N],L[N],R[N],id[N],Mi[N];
int MI[N];
int f[N],g[N];
//用来记录每一个点的子节点的子树中能与这个节点的祖先连上非树边的个数
int dp[N];
//dp来记录这个点的子树中最大的小于它的父亲的深度

int find(int x,int y) {
	for(int i=19; i>=0; --i)
		if(dep[st1[x][i]] > dep[y])x=st1[x][i];
	return x;
}//查找x的祖先是y的儿子
set<int>st[N],tmp;
bool cmp(int x,int y){
	return st[x].size() >st[y].size() ;
}
void dfs1(int u,int fa) {
	dep[u]=dep[fa]+1,id[L[u]=++cn]=u,vis[u]=1,st1[u][0]=fa;
	for(int i=1; i<20; i++)st1[u][i]=st1[st1[u][i-1]][i-1];
	for(int v:e[u]) {
		if(v==fa)continue;
		if(vis[v]) {
			if(dep[v] < dep[u]) {
				e2[u].push_back(v);
				st[u].insert(dep[v]);
				mi[u]=min(mi[u],dep[v]);
			}
		}//返祖边
		else {
			dfs1(v,u);
			e1[u].push_back(v);
			cnt[u]++;
		}//树边
	}
	for(int v:e1[u]) {
		if(st[v].size() && *st[v].begin() <dep[u] )dp[v] =*--st[v].lower_bound(dep[u]);
		//else dp[v]=inf;
		if(*st[v].begin() < dep[u] && st[v].size() )
			f[u]++;
		if(*st[v].begin() < dep[u]-1 && st[v].size() ) g[u]++;
		Mi[v]=*st[v].begin();
	}
	sort(e1[u].begin() ,e1[u].end() ,cmp);
	for(int v:e1[u]) {
		if(st[v].size() >st[u].size() ) swap(st[u],st[v]);
		for(int o:st[v]) st[u].insert(o);
		st[v].clear() ;
	}
	R[u]=cn;
}
struct SEG {
#define ls p<<1
#define rs p<<1|1
	int c[N<<2];
	void pushup(int p) {
		c[p]=min(c[ls],c[rs]);
	}
	void build(int p,int l,int r) {
		if(l==r) return void (c[p]=mi[id[l]]);
		int mid=l+r>>1;
		build(ls,l,mid),build(rs,mid+1,r);
		pushup(p);
	}
	int query(int p,int l,int r,int L,int R) {
		if(R<L)return inf;
		if(L<=l&&r<=R)return c[p];
		int mid=l+r>>1;
		if(L<=mid && R>mid)return min(query(ls,l,mid,L,R),query(rs,mid+1,r,L,R));
		if(L<=mid)return query(ls,l,mid,L,R);
		return query(rs,mid+1,r,L,R);
	}
} seg;
void dfs2(int u,int fa) {
	for(int v:e1[u]) {
		if(u==1) {
			if(cnt[u]>=3)ans++;
			else if(cnt[u]==2 &&cnt[v])ans++;
			else if(cnt[u]==1 &&cnt[v]>1)ans++;
		} else {
			//首先判断u中其他的子树是否满足条件
			int tmp=f[u];
			if(Mi[v]<dep[u] &&Mi[v] )tmp--;
			if(tmp!=cnt[u]-1) {
				ans++;
				continue;
			}
			if(!cnt[v])continue;
			//再判断v的子树中是否存在不可以连到u的祖先的子树
			if(g[v]!=cnt[v])ans++;
		}
	}//树边
	for(int v:e2[u]) {
		// u是下面的点,v 是上面的点
		if(v==1) {
			//这时没有上面的点
			if(cnt[v]==1) {
				for(int t:e1[u]) {
					if(dp[t] <= dep[v]) {
						ans++;
						break;
					}
					//判断u的子树的点是否存在非树边在中间
				}
			}//有且仅有一个儿子
			else ans++;
		} else {
			int op=0;
			int tmp=f[v];
			int F=find(u,v);
			if(Mi[F]<dep[v] &&Mi[F])tmp--;
			if(tmp!=cnt[v]-1) {
				ans++;
				continue;
			}//在v有其他的子树,而这些子树不可以与fa_v及其祖先相连,跳。
			for(int t:e1[u]) {
				if(Mi[t]<dep[v] &&Mi[t])continue;
				if(dp[t]>dep[v] &&dp[t])continue;	
				ans++,op=1;
				break;	
			}//判断u的子树中是否拥有不能连到中间或者上面的
			if(op)continue;
			if(min(seg.query(1,1,n,L[F],L[u]-1),seg.query(1,1,n,R[u]+1,R[F])) >=dep[v]) {
				int fl=0;
				for(int t:e1[u]) {
					if( Mi[t]<dep[v] && dp[t]>dep[v]) {
						fl=1;
						break;
					}
				}
				if(!fl)ans++;
			}//若中上不连通则需要根据下面的子树是否与上中连通来判断,否则直接连通。
		}
	}
	//非树边
	for(int v:e1[u])
		dfs2(v,u);
	return ;
}
signed main() {
	scanf("%d%d",&n,&m);
	for(int i=1,u,v; i<=m; i++) {
		scanf("%d%d",&u,&v);
		e[u].push_back(v);
		e[v].push_back(u);
	}
	memset(mi,0x3f,sizeof mi);
	dfs1(1,0);
	seg.build(1,1,n);
	dfs2(1,0);
	cout<<ans<<endl;
	return 0;
}

```

---

## 作者：nullqtr_pwp (赞：0)

- 运用 dfs 树无返祖边转化为树上数据结构问题。~~然后就是没什么水平的分类讨论。~~

正难则反，考虑计算断开之后仍然连通的边的数量。重要性质：无向图的 dfs 生成树中不存在横叉边，也即全部为返祖边。那么考虑对于断开树边，可以做一做预处理做到 $\mathcal O(1)$ 判定每条边是否合法（前后缀 $low$ 的 $\min$ 以及暴力遍历子树 $low$ 的 $\min$）。重点在于对非树边的合法性判定。

非树边是重点，不妨设 $v$ 的深度更大，那么整棵树被剖分为了三个部分 $A,B,C$，从上往下为 $u$ 往上的到根链，由于不存在横叉边，那么子树向上连只能连到这个链上去；$u$ 到 $v$ 不包含端点的非空链以及它挂着的子树；$v$ 所有儿子的子树。

对于 $u$ 挂着的非 $v$ 方向的子树，处理子树内返祖边指向点深度 $\min$ 也即 $low$，维护一下前后缀的 $\max$ 就可以判定 $u$ 挂着的子树是否合法；对于 $B$ 部分，记录 $v$ 的 $dep_v-dep_u-1$ 级祖先为 $u'$，那么 $B$ 需要考虑的是 $u'$ 子树扣除掉 $v$ 子树。如果用 dfs 序来维护 $low$ 的 $\min$ 就可以得知其是否与 $A$ 连通。对于 $B$ 的 dfs 序刻画是容易的。现在分为两种情况：$A,B$ 连通与 $A,B$ 不连通。

首先考虑 $A,B$ 连通的情况，对于 $v$ 的所有儿子 $p$ 而言，$p$ 子树只要与 $A,B$ 其中一者连通即可。对于所有子树开一个 map 维护，一个子树在 $[1,dep_v)$ 中的的 $low$ 是否有且只有一种；考虑 $A,B$ 不连通的情况。那么需要有一个 $p$ 与 $A,B$ 均连通，剩下每个 $C$ 都需要与 $A,B$ 其中一者连通。这相当于是在前者的基础上增添了限制。考虑其是否满足前者，然后处理每个 $p$ 子树的 $\min,\max$ 来判定是否每个子树均是，只与 $A,B$ 中恰好一个部分连通。

自下往上处理，将所有返祖边在深度更大一端进行统计，启发式合并维护子树信息。可以做到 $\mathcal O(n\log^2n+m\log n)$。

代码咕咕咕。

---


# [COCI 2023/2024 #2] Dizalo

## 题目描述

$n$ 个人坐电梯，第 $i$ 个人在第 $a_i$ 层下电梯，$a_{1\sim n}$ 构成一个排列。

电梯是长条形的，所以 $n$ 个人初始时按编号顺序在电梯里列成一列，电梯会从下往上依次经过第 $1\sim n$ 层。

当一个人要下电梯时，所有在他前面的人也必须暂时下电梯，然后可以以任意顺序返回电梯。在他后面的人不需要也不会下电梯。

如果每次临时下电梯的人总是以最优策略来决定返回电梯的顺序，请你求出所有人下电梯的总次数最少是多少。

给定 $q$ 次操作，每次给定 $x_i$ 表示移除编号为 $x_i$ 的人，你需要在第一次操作前以及每次操作之后求出答案。

## 说明/提示

### 数据范围
|$\text{Subtask}$|分值|特殊性质|
|:-:|:-:|:-:|
|$1$|$16$|$n,q\le 100$|
|$2$|$19$|$n,q\le 1000$|
|$3$|$29$|$q=0$|
|$4$|$46$|无|

对于所有数据，$0\le q< n\le 10^5$。

## 样例 #1

### 输入

```
5 2
3 4 1 2 5
3 2```

### 输出

```
9 6 4```

## 样例 #2

### 输入

```
7 0
4 5 2 1 6 3 7```

### 输出

```
13```

## 样例 #3

### 输入

```
3 2
3 1 2
1 2
```

### 输出

```
5 2 1```

# 题解

## 作者：Add_Catalyst (赞：8)

# P9910「COCI 2023/2024 #2」dizalo 题解

## 知识点

 树状数组，线段树，STL 库中的 set。

---

## 前言

这道题不错，使用了三个树状数组，一个线段树，一个 set，维护一系列基础的东西，但结合起来就变的复杂了。

各个操作不难，但思维含金量很高，适合刚熟悉树状数组和线段树的新手来做。

---

## 题意分析

先看到题目要求：求出所有人下电梯的总次数最少是多少。

题目说：“当一个人要下电梯时，所有在他前面的人也必须暂时下电梯，而每次临时下电梯的人总是以最优策略来决定返回电梯的顺序”，那么为了减小总次数，回来时肯定会让楼层大的先回来，楼层小的后回来，这样这一部分下过电梯的人在到达目标楼层时就都不会让站在他前面的人产生额外的下电梯次数，总次数也就不会再增加。

那么，哪些人会让他之前的人产生额外的下电梯次数使总次数增加呢？

之前已经说到临时下电梯的人不会让他之前的人产生额外的下电梯次数，那么会让他之前的人产生额外的下电梯次数的人就是在到达目标楼层之前都没下过电梯的人。

可以发现，这类人的目标楼层在序列中是一个**后缀最小值**，即在上电梯之前的序列中，在他之后 ***没有人的目标楼层比他小***。而总次数也就是**后缀最小值**之前大于它的数的个数之和+总人数（每个人自己都要下一次电梯的）。

所以题目就是让我们求：第一次操作前以及每次操作之后的**后缀最小值**之前大于它的数的个数之和+总人数。

---

## 题解

### 离线题解

本代码有一条核心计算文字表达式：总次数 = **后缀最小值之前大于它的数的个数之和** + 总人数，而其中后缀最小值之前大于它的数的个数之和，就等于 **大于后缀最小值的数的总个数** - **它后面大于它的数的个数**  。

故我们开两个树状数组：分别维护编号为 $1 ~ i$ 的数中没被删除的数的个数，以及值为 $1 ~ i$ 的数中没被删除的数的个数 。加入或删除一个后缀最小值的问题就解决了。

还有不是后缀最小值的部分：删除时减去它后面比它小的后缀最小值即可。

我们再开一个 set 记后缀最小值和它的编号，用于查询时二分，和一个树状数组，记 $1 ~ i$ 区间后缀最小值个数。

至于什么时候什么数成为后缀最小值，开一个线段树，维护区间最大值，其中记在某数之后比它小的数的所有删除时间最大值，即成为一个所谓的后缀最小值的时间前一刻，我们可以把它离线下来进行操作。

详见代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define Pii pair<int,int>
#define S second
#define tomax(a,b) ((a)=max((a),(b)))
#define FOR(i,a,b) for(register int i=(a);i<=(b);++i)
#define DOR(i,a,b) for(register int i=(a);i>=(b);--i)
#define main Main();signed main(){ios::sync_with_stdio(0);cin.tie(0);return Main();}signed Main
using namespace std;
const int N=1e5+10;
int n,Q;
int a[N],ti[N],va[N];
bool vis[N],del[N];
vector<int> g[N];
set< Pii > st;
ll sum=0;
struct Binary_Indexed_Trees {
#define lowbit(a) ((a)&(-a))
	int c[N],n;
	void init(int m) {
		n=m;
	}
	void build() {
		FOR(i,1,n)c[i]=1;
		FOR(i,1,n)if(i+lowbit(i)<=n)c[i+lowbit(i)]+=c[i];
	}
	void add(int x,int v) {
		for(; x<=n; x+=lowbit(x))c[x]+=v;
	}
	int query(int x) {
		int res=0;
		for(; x; x^=lowbit(x))res+=c[x];
		return res;
	}
} bit1,bit2,bit3;
/*bit1维护编号1~i中没被删除的数的个数*/
/*bit2维护值1~i中没被删除的数的个数*/
/*bit3维护区间后缀最小值个数*/
struct Segment_Tree {
#define ls (p<<1)
#define rs (p<<1|1)
	int n;
	struct node {
		int l,r,len,c;
	} tr[N<<2];
	void init(int _n) {
		return (void)(n=_n,build(1,n,1));
	}
	void push_up(int p) {
		tr[p].c=max(tr[ls].c,tr[rs].c);
	}
#define mid (tr[p].l+tr[p].r>>1)
	void build(int l,int r,int p) {
		tr[p]= {l,r,r-l+1,0};
		if(l==r)return;
		build(l,mid,ls),build(mid+1,r,rs);
	}//建树
	void update(int p,int x,int d) {
		if(tr[p].len==1)return tr[p].c=d,void();
		if(mid>=x)update(ls,x,d);
		else update(rs,x,d);
		push_up(p);
	}//修改
	int query(int p,int l,int r) {
		if(l<=tr[p].l&&tr[p].r<=r)return tr[p].c;
		int ans=0;
		if(mid>=l)tomax(ans,query(ls,l,r));
		if(mid<r)tomax(ans,query(rs,l,r));
		return ans;
	}//查询
#undef mid
} seg; //维护删除时间最大值.
signed main() {
	cin>>n>>Q;
	bit1.init(n),bit1.build();
	bit2.init(n),bit2.build();//O(n)建树
	bit3.init(n);
	seg.init(n);
	FOR(i,1,n)cin>>a[i],ti[i]=Q+1;
	FOR(i,1,Q)cin>>va[i],ti[va[i]]=i;//标记第va[i]个人是在第i个被删除的,即删除时间.
	/*输入+初始化*/
	DOR(i,n,1)g[seg.query(1,1,a[i]-1)].emplace_back(i),seg.update(1,a[i],ti[i]);
	//倒序求在某数之后比它小的数的所有删除时间最大值,seg.query(1,1,a[i]-1)就是该时间,即成为一个所谓的后缀最小值的时间前一刻,我们直接存入一个vector,以便查询.
	/*求成为后缀最小值的时间*/
	st.insert({0,0}),st.insert({n+1,n+1});
	for(int i:g[0]) {
		sum+=i-a[i];
		//这里基于一个数学推导:一开始作为一个后缀最小值,整个数组中大于它的有:n-a[i]个,他后面大于它的有:n-i个,那么前面大于它的就有:i-a[i]个.
		bit3.add(i,1);
		vis[i]=1;//标记已经成为后缀最小值的数.
		st.insert({a[i],i});
	}
	cout<<sum+n<<" ";
	/*输出*/
	/*处理第一次操作前的总数*/
	FOR(i,1,Q) {
		del[va[i]]=1;
		if(vis[va[i]]) { //当它是一个后缀最小值时,要消除它之前造成的所有影响
			bit3.add(va[i],-1);
			sum-=bit1.query(va[i])-bit2.query(a[va[i]]);
			/*同上"sum+=i-a[i]",总数减去半边,得到另一半*/
			st.erase({a[va[i]],va[i]});
		} else sum-=bit3.query((--st.lower_bound({a[va[i]],0}))->S)-bit3.query(va[i]);//当它不是后缀最小值,减去他后面比他小的后缀最小值的数量
		bit1.add(va[i],-1);
		bit2.add(a[va[i]],-1);
		for(int j:g[i]) {
			if(del[j])continue;
			bit3.add(j,1);
			vis[j]=1;
			st.insert({a[j],j});
			sum+=bit1.query(j)-bit2.query(a[j]);
		}//同理
		cout<<sum+n-i<<" ";
		/*输出*/
	}
	cout<<endl;//结尾换行好习惯 (*^▽^*)
	return 0;
}
```

---

### 在线题解

这是 [Codeforces](https://codeforces.com/blog/entry/122814) 上的在线做法。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN = 1e5 + 2;
const int OFF = 1 << 18;

int n, q, a[MAXN], inv[MAXN];
long long ans;
set<int> suffix_min;

struct Fenwick {
	int fen[MAXN] = {0};

	void add(int x, int val = 1) {
		for (++x; x <= n; x += x & -x) fen[x] += val;
	}
	int count(int x) {
		int ret = 0;
		for (++x; x; x -= x & -x) ret += fen[x];
		return ret;
	}
	int count(int l, int r) {
		return count(r) - count(l - 1);
	}

} removed_values, removed_indices, marked_values, marked_indices;

struct Tournament {
	int tour[OFF] = {0};

	void update(int i, int val, int x = 0, int l = 0, int r = n - 1) {
		if (l > i || r < i) return ;
		if (l == r) {
			tour[x] = val;
			return ;
		}
		int mid = (l + r) >> 1;
		update(i, val, x * 2 + 1, l, mid);
		update(i, val, x * 2 + 2, mid + 1, r);

		tour[x] = min(tour[x * 2 + 1], tour[x * 2 + 2]);
	}

	int query(int ql, int qr, int x = 0, int l = 0, int r = n - 1) {
		if (ql <= l && r <= qr) return tour[x];
		if (ql > r || l > qr) return n;

		int mid = (l + r) >> 1;
		return min(query(ql, qr, x * 2 + 1, l, mid), query(ql, qr, x * 2 + 2, mid + 1, r));
	}

} values;

void mark(int i) {
	suffix_min.insert(i);
	marked_indices.add(i);
	marked_values.add(a[i]);

	ans += (i - removed_indices.count(i)) - (a[i] - removed_values.count(a[i]));
}

void unmark(int i) {
	ans -= (i - removed_indices.count(i)) - (a[i] - removed_values.count(a[i]));
	marked_indices.add(i, -1);
	marked_values.add(a[i], -1);

	int L = n, R = 0;
	auto it = suffix_min.find(i);
	if (it != suffix_min.end()) {
		if (++it != suffix_min.end()) R = *it;
		else R = n;
		--it;
	}
	if (it != suffix_min.begin()) L = (*--it) + 1;
	else L = 0;

	suffix_min.erase(suffix_min.find(i));

	while (L < R) {
		int j = values.query(L, R - 1);
		if (j == n) break;

		j = inv[j];
		if (a[j] < ((R == n) ? n : a[R])) mark(j);

		L = j + 1;
	}

}

int main() {

	cin >> n >> q;

	for (int i = 0; i < n; ++i) {
		cin >> a[i], --a[i];

		values.update(i, a[i]);
		inv[a[i]] = i;
	}

	int cur = n;
	for (int i = n - 1; i >= 0; --i) {
		cur = min(cur, a[i]);
		if (cur == a[i]) {
			mark(i);
		}
	}

	ans += n;
	cout << ans << " ";

	while (q--) {
		int i;
		cin >> i, --i;

		values.update(i, n);

		if (suffix_min.count(i)) unmark(i);

		ans += marked_values.count(a[i], n - 1);
		ans -= marked_indices.count(i, n - 1);

		removed_values.add(a[i]);
		removed_indices.add(i);

		--ans;
		cout << ans << " ";
	}

	return 0;
}
```

---

---

## 作者：Miss_SGT (赞：6)

## 无脑树套树做法

考试时只会一个树套树的做法。

首先一个人下去之后回来时肯定贪心地将 $a_i$ 小的放前面。

乍一看很像 [P3157 [CQOI2011] 动态逆序对](https://www.luogu.com.cn/problem/P3157)，但发现有些人的贡献不能算（一个人 $i$ 的贡献为满足 $j<i$ 且 $a_j > a_i$ 的 $j$ 的数量）。

如果人 $i$ 的后面存在一个人 $k$ 使得 $a_k < a_i$，那么人 $i$ 的贡献就不能算了，因为前面所有人会在 $k$ 下去时排好序。

那么我们对每一个人记录他后面所有比他小的人的离开时间的最大值（树状数组简单维护），就可以知道每个人从什么时刻可以开始算贡献。如果把树状数组换成线段树在线维护可以做到在线，但没必要。

剩下的就是动态逆序对了，开两棵树套树。一棵维护当前存在的人数，一棵维护存在的可以算贡献的人数。

我写的树状数组套线段树，时空复杂度 $O(n\log^2n)$，可以通过（很慢就是了）。

Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace IO{
    template<typename T>inline void read(T &x){
        x=0;int f=1;char c=getchar();
        while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
        while(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();
        x*=f;
    }
    const int BUF=1<<21;
    char buf[BUF],tp,st[32];
    int plen;
    #define flush() fwrite(buf,1,plen,stdout),plen=0
    inline void pc(char c){
        buf[plen++]=c;
        if(plen==BUF) flush();
    }
    template<typename T>inline void print(T x){
        if(!x){pc(48);return;}
        if(x<0) x=~x+1,pc('-');
        while(x) st[++tp]=48^x%10,x/=10;
        while(tp) pc(st[tp--]);
    }
}
using namespace IO;
const int N=1e5+5;
int n,q,a[N],b[N],tot,ti[N];
struct Tree{
	int ls,rs,cnt;
}t[N*360];
#define mid ((l+r)>>1)
void change(int &p,int l,int r,int x,int y){
	if(!p) p=++tot;
	t[p].cnt+=y;
	if(l<r){
		if(x<=mid) change(t[p].ls,l,mid,x,y);
		else change(t[p].rs,mid+1,r,x,y); 
	}
}
int query_(int p,int l,int r,int lt,int rt){
	if(!p) return 0;
	if(lt<=l&&r<=rt) return t[p].cnt;
	int ans=0;
	if(lt<=mid) ans=query_(t[p].ls,l,mid,lt,rt);
	if(mid<rt) ans+=query_(t[p].rs,mid+1,r,lt,rt);
	return ans;
}
struct Tree_in_Tree{
	int root[N];
	inline void add(int x,int y,int v){for(;x<=n;x+=x&-x) change(root[x],1,n,y,v);}
	inline int query(int x,int y,int l,int r){
		if(x>y||l>r) return 0;
		int ans=0;
		for(--x;x;x-=x&-x) ans-=query_(root[x],1,n,l,r);
		for(;y;y-=y&-y) ans+=query_(root[y],1,n,l,r);
		return ans;
	}
}C,T;
struct Bit_tree{
	int mx[N];
	inline void add(int x,int y){for(;x<=n&&mx[x]<y;x+=x&-x) mx[x]=y;}
	inline int query(int x){
		int ans=0;
		for(;x;x-=x&-x) ans=max(ans,mx[x]);
		return ans;
	}
}B;
vector<int> P[N];
long long ans;
bool vis[N];
int main(){
	read(n),read(q);
	for(int i=1;i<=n;++i){
		read(a[i]);
		C.add(i,a[i],1);
		ti[i]=n+1;
	}
	for(int i=1;i<=q;++i) read(b[i]),ti[b[i]]=i;
	for(int i=n;i;--i){
		int qq=B.query(a[i]);
		if(qq<=q&&qq<=ti[i]) P[qq].push_back(i);
		B.add(a[i],ti[i]);
	}
	for(int j:P[0]){
		ans+=C.query(1,j-1,a[j]+1,n);
		T.add(j,a[j],1);
		vis[j]=1;
	}
	ans+=n;
	print(ans),pc(' ');
	for(int t=1;t<=q;++t){
		C.add(b[t],a[b[t]],-1);
		ans-=T.query(b[t]+1,n,1,a[b[t]]-1);
		if(vis[b[t]]){
			ans-=C.query(1,b[t]-1,a[b[t]]+1,n);
			T.add(b[t],a[b[t]],-1);
		}
		for(int j:P[t]){
			ans+=C.query(1,j-1,a[j]+1,n);
			T.add(j,a[j],1);
			vis[j]=1;
		}
		print(--ans),pc(' ');
	}
	flush();
	return 0;
}
```

---

## 作者：_lbw_ (赞：6)

显然，每个人出来之后必然会把他前面的人按 $a_i$ 排序。

然后我们考虑一对数什么时候会产生贡献，首先 $i<j,a_i>a_j$ 其次 $a_j$ 为后缀最小值。

我们称满足 $a_j$ 为后缀最小值的数构成集合 $S$。

如何计算它? 先考虑 $a_j$ 为后缀最小值的限制，也就是 $a_j$ 小于所有它后面的数，也就是 $a_j$ 后面比 $a_j$ 小的全部要已经被删掉，同时 $a_j$ 不能被删掉，也就是 $j\in S$ 的时刻构成一段区间。

问题转化为 $\sum[j\in S_t,i<j,a_i>a_j]$ 这看上是三维偏序状物。

但我们进行容斥，因为 $a_j$ 小于后面的所有数，答案即为:

$$\sum\limits_{i,j}[j\in S_t,a_i>a_j]-\sum\limits_{i,j}[j\in S_t,i>j]$$

而集合 $S$ 和可以用的 $a_i$ 总变化量是 $\mathcal{O}(n+q)$ 的。

也就是我们维护两个数据结构，有 $\mathcal{O}(n+q)$ 次单点修改和 前缀/后缀 查询。

树状数组即可，时间复杂度 $\mathcal{O}((n+q)\log n)$。

---

## 作者：lupengheyyds (赞：4)

# P9910 Dizalo

不难分析出，答案为对于所有后缀最小值的位置，前面比其大的数的个数之和，利用单调栈，可以做到 $\mathcal O(nq)$。

---

首先考虑一个值什么时候成为后缀最小值，我们发现，只有当它后面比它小的数全部删除，并且自己没有被删除的时候，它是后缀最小值，于是我们发现一个值是后缀最小值的**时间是一个区间**！

假设此时后缀最小值的集合为 $S$，即 $\sum_{j\in S,i\in U}[a_i>a_j\land i<j]$。

这是一个二维数点问题，可以用数套树 $\mathcal O(q\log^2n)$ 解决。

因为 $\forall i>j,j\in S,a_i>a_j$，所以原式等于 $\sum_{j\in S}[a_i>a_j]-[i>j]$，直接树状数组就可以了。复杂度 $\mathcal O((q+n)\log n)$。

## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
typedef pair<int,int> pa;
const int NN=1e5+5,INF=0x3f3f3f3f;
int n,q,a[NN],x[NN],t[NN],bt[NN];
int _max(int a,int b){return max(a,b);}
int _add(int a,int b){return a+b;}
struct Bit{
	int bitr[NN],init;
	std::function<int(int,int)> f;
	void Init(int x){
		init=x;
		for(int i=1;i<=n;i++)bitr[i]=x;
	}
	void Add(int x,int v){
		if(x==0)return;
		for(;x<=n;x+=x&-x)bitr[x]=f(bitr[x],v);
		return;
	} 
	int Ask(int x){
		int sum=init;
		for(;x;x-=x&-x)sum=f(sum,bitr[x]);
		return sum;
	}
}Sa,Sid,alla,allid,tim;
vector<pa> ad[NN];
signed main(){
	Sid.f=alla.f=allid.f=Sa.f=_add;
	tim.f=_max;
	cin>>n>>q;
	for(int i=1;i<=n;i++)cin>>a[i],t[i]=q;
	for(int i=1;i<=q;i++)cin>>x[i],t[x[i]]=i-1;
	tim.Init(-INF);
	for(int i=n;i>=1;i--){
		bt[i]=max(0ll,tim.Ask(a[i])+1);
		tim.Add(a[i],t[i]);
		if(bt[i]<=t[i]){
			ad[bt[i]].push_back({i,1});
			ad[t[i]+1].push_back({i,-1});
		}
	}
	for(int i=1;i<=n;i++)alla.Add(n-a[i]+1,1),allid.Add(n-i+1,1);
	for(int i=0,sum=0;i<=q;i++){
		if(x[i]){
			sum-=Sa.Ask(a[x[i]]-1)-Sid.Ask(x[i]-1);
			alla.Add(n-a[x[i]]+1,-1);allid.Add(n-x[i]+1,-1);
		}
		for(pa o:ad[i]){
			int id=o.first,op=o.second;
			if(op==1){
				sum+=alla.Ask(n-a[id])-allid.Ask(n-id);
				Sa.Add(a[id],1);Sid.Add(id,1);
			}else{
				sum-=alla.Ask(n-a[id])-allid.Ask(n-id);
				Sa.Add(a[id],-1);Sid.Add(id,-1);
			}
		}
		cout<<sum+n-i<<" ";
	}
	
	return 0;
}
```

---

## 作者：zhongpeilin (赞：4)

## 解题思路：
首先我们看完题面后最优策略一定是将出去的人以楼层从大到小放进去。那么考虑如果有一个人 $x$ 的后面有比他要去的楼层小的人 $y$，那么 $x$ 出去时一定不会让别人暂时出去，因为 $y$ 就会将 $y$ 以前还没走的人层数变成从小到大。  
所以一个人 $x$ 出去时会让别人暂时出去仅当 $a_{x}$ 是后缀最小值，同时 $x$ 出去时会将在他前面还没走的人暂时出去，没走的人 $y$ 自然就是 $a_{x} < a_{y}$ 的人了。  
**所以答案变成了：人数加每个后缀最小值前面有多少比它大的数**。  
由于是后缀最小值前面比它大的数，又由于后缀最小值的后面的数都比他大，所以每个后缀最小值前面有多少比它大的数 $=$ 比它大的数减去它后面有多少数。  
我们发现删除不好弄，于是离线下来，变成了加数。  
加数后，贡献变成了两类，分别是别人对他的贡献和他对别人的贡献。  
1. 当加入的这个数是后缀最小值时，我们就先把他的答案加上，然后再考虑它可能还会删掉其他后缀最小值，例如在 `2` 后面插入个 `1`，就会将 `2` 的后缀最小值删掉，同时再把这些删掉的后缀最小值的答案减去。由于他是后缀最小值，所以后面的数一定全部大于它，没有他对别人的贡献。  
2. 当这个数不是后缀最小值时，没有人会对他有贡献，所以只会有他对别人有贡献，即在他后面比他小的后缀最小值的个数，这又是一个二维问题了，不过我们可以发现，这个数前面的后缀最小值一定都比他小，所以就等于它后面的后缀最小值个数减去后缀最小值比他大的个数。  
$O(n \log n)$。  
## CODE：
```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read(){
	int x = 0, f = 1;
	char op = getchar();
	while(op < '0' || op > '9'){
		if(op == '-') f = -1;
		op = getchar();
	}
	while(op >= '0' && op <= '9'){
		x = x * 10 + (op - '0');
		op = getchar();
	}
	return x * f;
}
int n, q, a[100005], pos[100005], t[100005];
int Ca[100005], Cb[100005], Cc[100005], Cd[100005], Ce[100005];
long long ans[100005];
set<int> s;//后缀最小值集合 
//Ca[i] 存的是1~i的没被删的个数
//Cb[i] 存的是数值i~n中，所对应的位置没被删的数
//Cc[i] 存的是i~n中的后缀最小值。
//Cd[i] 存的是后缀最小值的权值在i~n的个数
//Ce[i] 存的是的位置在i~n的个数 

void Add(int x, int c){
	for(int i = x; i <= n; i += (i & (-i))) Ca[i] += c;
}
void aDd(int x, int c){
	for(int i = x; i; i -= (i & (-i))) Cb[i] += c;
}
void adD(int x, int c){
	for(int i = x; i; i -= (i & (-i))) Cc[i] = min(Cc[i], c);
}
void ADD(int x, int c){
	for(int i = x; i; i -= (i & (-i))) Cd[i] += c;
}
void ADd(int x, int c){
	for(int i = x; i; i -= (i & (-i))) Ce[i] += c;
}
int Ask(int x){
	int res = 0;
	for(int i = x; i; i -= (i & (-i))) res += Ca[i];
	return res;
}
int aSk(int x){
	int res = 0;
	for(int i = x; i <= n; i += (i & (-i))) res += Cb[i];
	return res;
}
int asK(int x){
	int res = n + 1;
	for(int i = x; i <= n; i += (i & (-i))) res = min(res, Cc[i]);
	return res;
}

int ASK(int x){
	int res = 0;
	for(int i = x; i <= n; i += (i &(-i))) res += Cd[i];
	return res;
}
int ASk(int x){
	int res = 0;
	for(int i = x; i <= n; i += (i & (-i))) res += Ce[i];
	return res;
}
int Suan(int x){
	return aSk(a[x] + 1) - (Ask(n) - Ask(x));
}
int main(){
	n = read(); q = read();
	for(int i = 1; i <= n; i++) a[i] = read(), t[i] = q + 1;
	memset(Cc, 0x3f, sizeof(Cc));
	for(int i = 1; i <= q; i++) t[pos[i] = read()] = i;
	for(int i = 1; i <= n; i++) if(t[i] == q + 1) Add(i, 1), aDd(a[i], 1), adD(i, a[i]); //总是没被删得数 
	for(int i = 1; i <= n; i++){
		if(t[i] == q + 1 && asK(i) == a[i]){
			ans[q] += Suan(i);
			s.insert(i);
			ADD(a[i], 1); //更新 
			ADd(i, 1);
		}
		if(t[i] == q + 1)ans[q]++;
	}
	for(int i = q - 1; i>= 0; i--){
		ans[i] = ans[i + 1] + 1; //比前面的加了一个人 
		if(asK(pos[i + 1]) >= a[pos[i + 1]]){ //后缀最小值 
			ans[i] += Suan(pos[i + 1]);
			auto it = s.lower_bound(pos[i + 1]);
			if(it != s.begin()){
				it--; //找到pos[i+1]前的后缀最小值 
				while(it != s.begin() && a[(*(it))] > a[pos[i + 1]]){
					auto p = it;
					p--;
					ADD(a[(*(it))], -1);//更新 
					ADd((*(it)), -1);
					ans[i] = ans[i] - Suan((*(it)));
					s.erase(it);
					it = p;
				}
				if(a[(*(it))] > a[pos[i + 1]]) {//可能前面的都被删了 
					ADD(a[(*(it))], -1);
					ADd((*(it)), -1);
					ans[i] = ans[i] - Suan((*(it)));
					s.erase(it);
				}
			}
			s.insert(pos[i + 1]); //加入 
			ADD(a[pos[i + 1]], 1);
			ADd(pos[i + 1], 1);
		} else {
			ans[i] += ASk(pos[i + 1]) - ASK(a[pos[i + 1]]); //计算 
		}
		Add(pos[i + 1], 1), aDd(a[pos[i + 1]], 1), adD(pos[i + 1], a[pos[i + 1]]); //加入 
	}
	for(int i = 0; i<= q; i++) printf("%lld ", ans[i]);
	 return 0;
}
```

---

## 作者：kkxacj (赞：1)

#### 前言

来分享一下我的最劣解做法，非要找优势的话可能就是不怎么需要脑子吧。

#### 思路

显然，对于一对 $i,j$，若 $a_i<a_j$ 且没有 $j < z$ 满足 $a_j<a_z$ 的话，那么就会计入一次贡献，因为这样 $a_i,a_j$ 会出去后排序使得之后按顺序出去，造不成贡献。

那么对于一个 $j$，若它右边没有比它小的，那么就加上前面比它大的数个数，否则不加，这个很容易，你随便写个线段树套平衡树就好了。

不过需要带修改，怎么办捏，我们先把修改离线下来，对于每个点看右边比它小的数最大删除时间，或者没有返回 $0$。

然后考虑每次修改会发生什么。

1. 当前点右边还有比它大的，那么不管左边的点，否则减去左边剩余比它大的点。
2. 看右边有几个比它小的点且没被删除，同时那些点**右边没有比它小的点**。

然后执行所有最大删除时间为 $i$ 的操作，如果这个点已经被删了，那就不管了，否则就标记为**右边没有比它小的点**，然后加上左边比它大的点的个数。

然后就没了，十分无脑，代码长度虽长但都是基本操作，比较好写，其实这个写法也可以在线，但麻烦一点点就算了。


```cpp
#include<bits/stdc++.h>
#define mid ((c[p].l+c[p].r)>>1)
#define ls (p<<1)
#define rs ((p<<1)+1) 
using namespace std;
#define getchar() (p1 == p2 && (p2 = (p1 = buf1) + fread(buf1, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
char buf1[1 << 23], *p1 = buf1, *p2 = buf1, ubuf[1 << 23], *u = ubuf;
namespace IO
{
	template<typename T>
	void read(T &_x){_x=0;int _f=1;char ch=getchar();while(!isdigit(ch)) _f=(ch=='-'?-1:_f),ch=getchar();while(isdigit(ch)) _x=_x*10+(ch^48),ch=getchar();_x*=_f;}
	template<typename T,typename... Args>
	void read(T &_x,Args&...others){Read(_x);Read(others...);}
	const int BUF=20000000;char buf[BUF],to,stk[32];int plen;
	#define pc(x) buf[plen++]=x
	#define flush(); fwrite(buf,1,plen,stdout),plen=0;
	template<typename T>inline void print(T x){if(!x){pc(48);return;}if(x<0) x=-x,pc('-');for(;x;x/=10) stk[++to]=48+x%10;while(to) pc(stk[to--]);}
}
using namespace IO;
const int N = 2e5+10; 
int n,q,f[N],b[N],T[N],o,o1,L,R,Mid,cnt,fl,fr,fz,V[N],L1;
long long ans;
struct w1
{
	int x,id;
}d[N];
struct w
{
	int l,r,root,root1;
	vector<int>v,v1;
}c[N<<2];
struct w2
{
	int l,r,siz,key,val;
}a[N<<8];
inline bool cmp(w1 x,w1 y){return x.x > y.x;}
inline bool cmp1(w1 x,w1 y){return x.x < y.x;}
inline void push_up(int p){a[p].siz = a[a[p].l].siz+a[a[p].r].siz+1;}
inline int add(int x){a[++cnt].siz = 1,a[cnt].val = x,a[cnt].key = rand(); return cnt;}
int merge(int l,int r)//默认l.val < r.val 
{
	if(!l || !r) return l+r;
	if(a[l].key < a[r].key)
	{
		a[l].r = merge(a[l].r,r);
		push_up(l);
		return l;
	}
	else
	{
		a[r].l = merge(l,a[r].l);
		push_up(r);
		return r;
	}
}
void spilt(int p,int &l,int &r,int x)//按x分裂 
{
	if(!p) { l = r = 0; return; }
	if(a[p].val <= x)
	{
		l = p;  
		spilt(a[l].r,a[l].r,r,x);
	}
	else
	{
		r = p;
		spilt(a[r].l,l,a[r].l,x);
	}
	push_up(p);
}
void build(int p,int l,int r)
{
	c[p].l = l,c[p].r = r;
	if(l == r)
	{	c[p].v.push_back(0),c[p].v1.push_back(0);
		c[p].v.push_back(T[l]),c[p].v1.push_back(f[l]);
		return;
	}
	build(ls,l,mid),build(rs,mid+1,r); c[p].v.push_back(0),c[p].v1.push_back(0);
	for(int i = l;i <= r;i++) d[i].x = f[i],d[i].id = i,c[p].v.push_back(0),c[p].v1.push_back(0);
	sort(d+l,d+r+1,cmp); o = T[d[r].id],o1 = 1,c[p].v[o1] = o,o1++; 
	for(int i = r-1;i >= l;i--) o = max(o,T[d[i].id]),c[p].v[o1] = o,o1++;
	o1 = r-l+1; 
	for(int i = l;i <= r;i++) c[p].v1[o1] = d[i].x,o1--;
}
int query_tim(int p,int l,int r,int k)//询问最大时间，需要<k 
{
	if(l <= c[p].l && c[p].r <= r)
	{
		L = 1,R = c[p].r-c[p].l+1,o = 0;
		while(L <= R)
		{
			Mid = ((L+R)>>1);
			if(c[p].v1[Mid] <= k) L = Mid+1,o = Mid;
			else R = Mid-1;
		}
		if(o == 0) return 0;
		return c[p].v[o];
	}
	int ans = 0;
	if(l <= mid) ans = query_tim(ls,l,r,k);
	if(mid < r) ans = max(ans,query_tim(rs,l,r,k));
	return ans;
}
int query_siz(int p,int l,int r,int k)//询问个数，需要>k 
{
	if(l <= c[p].l && c[p].r <= r)
	{
		L = 1,R = c[p].r-c[p].l+1,o = 0;
		while(L <= R)
		{
			Mid = ((L+R)>>1);
			if(c[p].v1[Mid] > k) R = Mid-1,o = Mid;
			else L = Mid+1;
		}
		spilt(c[p].root,fl,fr,k);
		o1 = a[fr].siz; c[p].root = merge(fl,fr);
	//	cout<<c[p].l<<" ** "<<c[p].r<<" "<<o<<" "<<c[p].v1[o]<<" "<<k<<endl;
		if(o == 0) return 0;
		return (c[p].r-c[p].l+1-o+1)-o1;
	}
	int ans = 0;
	if(l <= mid) ans = query_siz(ls,l,r,k);
	if(mid < r) ans += query_siz(rs,l,r,k);
	return ans;
}
int query_siz1(int p,int l,int r,int k)//询问个数，需要<k 
{
	if(l <= c[p].l && c[p].r <= r)
	{
		L = 1,R = c[p].r-c[p].l+1,o = 0;
		while(L <= R)
		{
			Mid = ((L+R)>>1);
			if(c[p].v1[Mid] > k) R = Mid-1;
			else L = Mid+1,o = Mid;
		}
		spilt(c[p].root,fl,fr,k-1);
		o1 = a[fl].siz; c[p].root = merge(fl,fr);
		spilt(c[p].root1,fl,fr,k-1);
		o1 += a[fl].siz; c[p].root1 = merge(fl,fr);
		if(o == 0) return 0;
		return o-o1;
	}
	int ans = 0;
	if(l <= mid) ans = query_siz1(ls,l,r,k);
	if(mid < r) ans += query_siz1(rs,l,r,k);
	return ans;
}
void change(int p,int l,int k)//删点 
{
	spilt(c[p].root,fl,fr,k-1);
	c[p].root = merge(merge(fl,add(k)),fr);
	if(l == c[p].l && c[p].r == l) return;
	if(l <= mid) change(ls,l,k);
	else change(rs,l,k); 
}
void change1(int p,int l,int k)//加点 
{
	spilt(c[p].root1,fl,fr,k-1);
	spilt(fr,fr,fz,k);
	c[p].root1 = merge(fl,fz);
	if(l == c[p].l && c[p].r == l) return;
	if(l <= mid) change1(ls,l,k);
	else change1(rs,l,k); 
}
void change2(int p,int l,int k)//删点 
{
	spilt(c[p].root1,fl,fr,k-1);
	c[p].root1 = merge(merge(fl,add(k)),fr);
	if(l == c[p].l && c[p].r == l) return;
	if(l <= mid) change2(ls,l,k);
	else change2(rs,l,k); 
}
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n),read(q); srand(time(0));
	for(int i = 1;i <= n;i++) read(f[i]),T[i] = q+1;
	for(int i = 1;i <= q;i++) read(b[i]),T[b[i]] = i;
	build(1,1,n);
	for(int i = 1;i <= n;i++) ans += query_siz(1,1,i-1,f[i])+1;
	for(int i = 1;i <= n;i++) 
		if(query_tim(1,i+1,n,f[i])) 
			ans -= query_siz(1,1,i-1,f[i]),change2(1,i,f[i]),V[i] = 1;
	for(int i = 1;i <= n;i++) d[i].x = query_tim(1,i+1,n,f[i]),d[i].id = i;
	sort(d+1,d+1+n,cmp1); L1 = 1;
	while(L1 <= n && d[L1].x == 0) L1++;//没有的
	print(ans),pc(' ');
	for(int i = 1;i <= q;i++)
	{
		ans--; change(1,b[i],f[b[i]]);
		if(V[b[i]]) change1(1,b[i],f[b[i]]),V[b[i]] = 0; 
		else ans -= query_siz(1,1,b[i]-1,f[b[i]]);
		ans -= query_siz1(1,b[i]+1,n,f[b[i]]);
		while(L1 <= n && d[L1].x == i) 
		{
			if(T[d[L1].id] > i) V[d[L1].id] = 0,change1(1,d[L1].id,f[d[L1].id]),ans += query_siz(1,1,d[L1].id-1,f[d[L1].id]);
			L1++;
		}
		print(ans),pc(' ');
	}
	flush();
	return 0;
}
/*
显然，出去的人回来必须按a_i排序
对于(i,j)(a_j < a_i && i < j) i不用出去当且仅当存在 j < z && a_j > a_z
i<j<z,a_z<a_j<a_i
看j，然后看前面有几个小的，后面有几个大的
每次删除时将前面比它大的都减个值
每个点有(i,a_i)，不妨线段树套平衡树
不过我们需要考虑离线，然后就可以求出比它大的最大t值是多少了
然后在那里求出前面还有多少点，删去贡献
每次删点就直接删,复杂度nlog^2
线段树需要维护区间，平衡树需要维护点值，同时要求后缀最大值，这个vector数组记一下就好了
*/
```

---

## 作者：vicissitudes (赞：1)

学 DS(数据结构) 真的会学傻。

# 计算贡献

我们考虑一对数 $i$，$j$ 什么时候对答案有贡献。

发现要满足 $i < j \wedge a_i > a_j$ 并且 $j$ 为 $\arg \min[j, n]$，即后缀最小值。

我们维护出所有的后缀最小值的集合 $S$，那么答案即为 $\sum_{i \in U, j \in S} [a_i > a_j \wedge i < j]$。其中 $U$ 为全集，$S$ 为后缀最小值集合。

每丢一个数进入 $S$，就要询问一次。所以是一个多次的二维数点问题。用树套树可以在线解决。

当然，如果 $i > j$ 那么一定有 $a_i > a_j$。所以容斥一下，式子变为 $\sum_{i \in A, j \in S} ([a_i > a_j] - [i > j])$。其中 $A = \complement_U S$。

至于如何维护 $S$，发现 $i$ 在 $S$ 里的时间是个区间。加入 $S$ 的时间为他后面比他小的数的删除时间的最大值。直到他被删。这个可以用一个树状数组维护。

# 维护集合

对于新加入 $S$ 的数 $j$，我们计算他对 $A$ 的贡献：

$$ans += \sum_{i \in A, j \in S} ([a_i > a_j] - [i > j])$$

注意到如果 $i$ 和 $j$ 如果都属于 $S$，则不会产生贡献，所以只考虑对 $A$ 的贡献即可。

对于被删除的数 $j$，我们分讨一下。

* $j \in S$，此时我们把他对 $A$ 的贡献减掉。


$$ans -= \sum_{i \in A, j \in S} ([a_i > a_j] - [i > j])$$

* $j \notin S$，此时我们把他对 $S$ 里的数的贡献减掉。

这里的方式同加入的贡献一样，同样会容斥一下。

$$ans -= \sum_{j \in A, i \in S} ([a_j > a_i] - [j > i])$$

注意下标。

我们需要知道 $S$ 和 $A$ 中 $a_i$ 和 $i$ 的信息，开 $4$ 棵树状数组维护即可。

$5$ 棵树状数组，时间 $O(n\log n + q\log n)$。

细节有点多。

```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int N = 2e5 + 10, M = 450;

ll a[N], x[N], del[N], add[N];

vector<int> in[N], out[N];

struct bit_tree {
	ll c[N], n;
	void init(int x) {
		n = x;
	} 
	void admax(int x, ll v) {
		for(; x <= n; x += x & -x) c[x] = max(c[x], v);
	}
	ll askmax(ll x) {
		ll res = 0;
		for(; x; x -= x & -x) res = max(res, c[x]);
		return res;
	}
	void adval(int x, int v) {
		for(; x <= n; x += x & -x) c[x] += v;
	}
	int askval(int x) {
		int res = 0;
		for(; x; x -= x & -x) res += c[x];
		return res;
	}
} tr, sa, si, aa, ai;

int vis[N];

int main() {
  	freopen("dizalo.in", "r", stdin);
  	freopen("dizalo.out", "w", stdout);
	int n, q;
	cin >> n >> q;
	for(int i = 1; i <= n; i ++) cin >> a[i];
	for(int i = 1; i <= q; i ++) {
		cin >> x[i];
		del[x[i]] = i;
	}
	for(int i = 1; i <= n; i ++) {
		if(!del[i]) del[i] = n + 1;//记录删除时间 
	}
	tr.init(n);
	sa.init(n), si.init(n);
	aa.init(n), ai.init(n);//预处理 
	for(int i = n; i >= 1; i --) {
		add[i] = tr.askmax(a[i]);
		tr.admax(a[i], del[i]);
		in[add[i]].push_back(i);
		out[del[i]].push_back(i);//处理加入 S 的时间 
		aa.adval(a[i], 1);
		ai.adval(i, 1);//将这个数放入 A 的集合中 
	}
	ll ans = n;
	for(int i = 0; i <= q; i ++) {
		for(int j : out[i]) {
			ans --;
			if(vis[j] == 1) {//在集合 S 中，减去贡献 
				ans -= aa.askval(n) - aa.askval(a[j]);
				ans += ai.askval(n) - ai.askval(j);
				vis[j] = -1;
				sa.adval(a[j], -1);
				si.adval(j, -1);
			} else {//不在集合 S 中，减去对 S 的贡献 
				ans -= sa.askval(a[j]);
				ans += si.askval(j);
				aa.adval(a[j], -1);
				ai.adval(j, -1); 
				vis[j] = -1;
			}
		}
		for(int j : in[i]) {//加入集合 S 中，计算贡献 
			if(vis[j] == -1) continue;//如果已经被删除，不管 
			aa.adval(a[j], -1);
			ai.adval(j, -1);
			sa.adval(a[j], 1);
			si.adval(j, 1);
			vis[j] = 1;
			ans += aa.askval(n) - aa.askval(a[j]);
			ans -= ai.askval(n) - ai.askval(j);
		}
		cout << ans << " ";
	}
	return 0;
}
```

---

## 作者：liuyidu (赞：0)

[传送门](https://www.luogu.com.cn/problem/P9910)

## 无删除

先分析 $q=0$ 这个部分分，以便下文的展开。实际上认真看完题目，我们可以发现处理完一个点后，只要让 $i$ 前的点按 $a_i$ 升序排列，就可使答案最小，显然成立，这里不做证明。

很容易发现，若一个数后面存在一个数小于该数，则这个数不会产生任何附加代价。因此需要计算附加代价的数应该是序列的后缀最小值。

至此，我们将问题转换为，求每个后缀最小值 $a_i$ 之前有多少个数大于 $a_i$。同时，注意题目里的条件，$a$ 数组为一个全排列。又由于 $a_i$ 为后缀最小值，那么就可以知道，序列一共有 $n-a_i$ 个数大于当前数，而 $a_i$ 后面共有 $n-i$ 个数大于 $a_i$，则 $a_i$ 前共有 $i-a_i$ 个数大于 $a_i$。

## 带删除

对于删除操作，我们需要再引入一个变量，时间戳。此处时间戳记录当前节点被删除的时间，假设我们已经完成了对时间戳的预处理，记为 $del$ 数组，那么我们接下来要求的，就是当前点 $i$ 之前有多少个数满足 $i > j,a_i < a_j,del_i > del_j$，可以尝试使用三维偏序，这里不展开。

接着讨论删除过程，删除操作分为两种，一种是删除一个后缀最小值，另一种是删除一个非后缀最大值，分别进行分析。

- 后缀最小值：当它是一个后缀最小值时，要消除它之前造成的所有影响，一方面我们从事先存下来的后缀最小值集合中删去这个点，同时删去其造成的额外代价，另一方面，我们要在集合中添加上新的后缀最小值。

- 非后缀最小值：当它不是后缀最小值，减去他后面比他小的后缀最小值的数量。

我采用了树状数组进行维护，三个树状数组。

$bit1$ 维护编号 $1 \sim i$ 中没被删除的数的个数，

$bit2$ 维护值 $1 \sim i$ 中没被删除的数的个数，

$bit3$ 维护区间后缀最小值个数。

## Code

```cpp
#include<bits/stdc++.h>
#define PII pair<int,int>
#define int long long
#define ls (o<<1)
#define rs (o<<1|1)
#define lowbit(a) ((a)&(-a))
#define mkp make_pair
using namespace std;
const int N=1e5+10;
int n,Q;
int a[N],tim[N],que[N];
bool vis[N],del[N];
vector<int> g[N];
set<PII> st;
int sum;
struct Binary_Tree {
	int c[N];
	void add(int i,int v) {
		for(; i<=n; i+=lowbit(i))c[i]+=v;
	}
	void build() {
		for(int i=1; i<=n; ++i)add(i,1);
	}
	int query(int i) {
		int res=0;
		for(; i; i^=lowbit(i))res+=c[i];
		return res;
	}
} bit1,bit2,bit3;
struct Segment_Tree {
	struct node {
		int l,r,c;
	} tr[N<<2];
	void pushup(int o) {
		tr[o].c=max(tr[ls].c,tr[rs].c);
	}
	void build(int o,int l,int r) {
		tr[o]= {l,r,0};
		if(l==r)return;
		int mid=tr[o].l+tr[o].r>>1;
		build(ls,l,mid),build(rs,mid+1,r);
	}
	void update(int o,int i,int x) {
		if(tr[o].l==tr[o].r)tr[o].c=x;
		else {
			int mid=tr[o].l+tr[o].r>>1;
			if(mid>=i)update(ls,i,x);
			else update(rs,i,x);
			pushup(o);
		}
	}
	int query(int o,int l,int r) {
		if(l<=tr[o].l&&tr[o].r<=r)return tr[o].c;
		int res=0;
		int mid=tr[o].l+tr[o].r>>1;
		if(mid>=l)res=max(res,query(ls,l,r));
		if(mid<r)res=max(res,query(rs,l,r));
		return res;
	}
} re;
signed main() {
	scanf("%lld%lld",&n,&Q);
	bit1.build();
	bit2.build();
	re.build(1,1,n);
	for(int i=1; i<=n; ++i)cin>>a[i],tim[i]=Q+1;
	for(int i=1; i<=Q; ++i)cin>>que[i],tim[que[i]]=i;
	for(int i=n; i>=1; --i)g[re.query(1,1,a[i]-1)].push_back(i),re.update(1,a[i],tim[i]);
	st.insert(mkp(0,0));
	st.insert(mkp(n+1,n+1));
	for(int i:g[0]) {
		sum+=i-a[i];
		bit3.add(i,1);
		vis[i]=1;
		st.insert(mkp(a[i],i));
	}
	printf("%lld ",sum+n);
	for(int i=1; i<=Q; ++i) {
		del[que[i]]=1;
		if(vis[que[i]]) {
			bit3.add(que[i],-1);
			sum-=bit1.query(que[i])-bit2.query(a[que[i]]);
			st.erase(mkp(a[que[i]],que[i]));
		} else sum-=bit3.query((--st.lower_bound(mkp(a[que[i]],0)))->second)-bit3.query(que[i]);
		bit1.add(que[i],-1);
		bit2.add(a[que[i]],-1);
		for(int j:g[i]) {
			if(del[j])continue;
			bit3.add(j,1);
			vis[j]=1;
			st.insert(mkp(a[j],j));
			sum+=bit1.query(j)-bit2.query(a[j]);
		}
		printf("%lld ",sum+n-i);
	}
	return 0;
}
```

---

## 作者：ClearluvXL (赞：0)

# Dizalo
## 思路
首先，如果 $i$ 会在除了他的楼层出去的话，那么此时必然 $[i+1,n]$ 中有人的楼层比他小。$[i+1,n]$ 中最小楼层的人为 $p$，所以 $p$ 前面的数回来时会按照从升序回来，避免多余的进出。

所以，我们一个数当且仅当他为后缀最小值时，他前面的比他大的数才会额外出去一次。

这道题删除的时候不好维护，我们考虑从后往前做，当作加入一个数。

令当前加入的数的位置为 $pos_{i}$，那么加入的值为 $a_{pos_{i}}$。

如果查询 $[pos,n]$ 中当前在序列中的数中的最小值比当前数小的话，那么 $a_{pos}$ 就不可能为后缀最小值，所以此时他带来的贡献就为在 $pos$ 后面的后缀最小值个数。

否则的话，他就是其中一个后缀最小值，那么我们就要把那些比在他前面并且是后缀最小值并且比他大的值从后缀最小值集合中删去。

并且根据后缀最小值的定义我们可以知道，我们在 set 中的位置是单增的，那么他们本身在 $a$ 中的位置也是单增的，所以我们删除的时候就可以维护一个迭代器向前找。

删去的同时，我们要减去他的代价，具体的，因为在此之前他是后缀最小值，所以他后面的数都会是比他大的。那么他带来的代价就只能是他前面的比他大的数。具体来说：就是总的比他大数的个数减去在他后面的数。
## 代码
```c++
#include<bits/stdc++.h>
#define endl '\n'

using namespace std;

const int N=2e5+10;

typedef long long ll;
typedef pair<int,int> pii;

const int INF=0x3f3f3f3f;

int n,q;
int a[N];

int lowbit(int x){
	return x&(-x);
}//end

struct node{
	int tr[N];	
	void adda(int x,int c){
		for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
	}
	void add(int x,int c){
		for(int i=x;i;i-=lowbit(i)) tr[i]+=c;
	}
	void addc(int x,int c){
		for(int i=x;i;i-=lowbit(i)) tr[i]=min(tr[i],c);
	}
	int querya(int x){
		int res=0;
		for(int i=x;i;i-=lowbit(i)) res+=tr[i];
		return res;
	}
	int query(int x){
		int res=0;
		for(int i=x;i<=n;i+=lowbit(i)) res+=tr[i];
		return res;
	}
	int queryc(int x){
		int res=n+1;
		for(int i=x;i<=n;i+=lowbit(i)) res=min(res,tr[i]);
		return res;
	}
}ca,cb,cc,cd,ce;
//ca 存的是1-i的没被删的个数
//cb 存的是数值 1-n 中，所对应的位置没被删的数
//cc 存的是i-n中的后缀最小值
//cd 存的是后缀最小值的权值在i-n的个数
//ce 存的是后缀最小值的位置在i-n的个数 

int calc(int x){
	return cb.query(a[x] + 1) - (ca.querya(n) - ca.querya(x));
}//end

int t[N],pos[N];
ll ans[N];

set<int> s;//后缀最小值的集合  

int main(){
//	freopen("dizalo.in","r",stdin);
//	freopen("dizalo.out","w",stdout);

	ios::sync_with_stdio(0);
	
	cin>>n>>q;
	
	for(int i = 1; i <= n; i++){
		cin>>a[i];
		t[i]=q+1;
	}
	
	memset(cc.tr,INF,sizeof cc.tr);
	for(int i = 1; i <= q; i++){
		cin>>pos[i];
		t[pos[i]]=i;
	}
	
	for(int i = 1; i <= n; i++)
		if(t[i] == q + 1){
			ca.adda(i,1); cb.add(a[i],1); 
			cc.addc(i,a[i]);
		}
	
	for(int i = 1; i <= n; i++){
		if(t[i]==q+1&&cc.queryc(i) == a[i]){
			ans[q]+=calc(i);
			s.insert(i);
			cd.add(a[i],1);
			ce.add(i,1);
		}
		if(t[i]==q+1) ans[q]++;
	}
	
	for(int i=q-1;i>=0;i--){
		ans[i]=ans[i + 1] + 1; 
		if(cc.queryc(pos[i + 1])>=a[pos[i + 1]]){
			ans[i]+=calc(pos[i + 1]);
			auto it=s.lower_bound(pos[i + 1]);
			if(it!=s.begin()){
				it--; 
				while(it != s.begin() && a[(*(it))] > a[pos[i + 1]]){
					auto p = it;
					p--;
					cd.add(a[(*(it))], -1);
					ce.add((*(it)), -1);
					ans[i]-=calc((*(it)));
					s.erase(it);
					it=p;
				}
				if(a[(*(it))]>a[pos[i + 1]]) {
					cd.add(a[(*(it))], -1);
					ce.add((*(it)), -1);
					ans[i]-=calc((*(it)));
					s.erase(it);
				}
			}
			s.insert(pos[i + 1]);
			cd.add(a[pos[i + 1]], 1);
			ce.add(pos[i + 1], 1);
		} 
		else {
			ans[i]+=ce.query(pos[i+1])-cd.query(a[pos[i + 1]]);
		}
		ca.adda(pos[i + 1], 1);
		cb.add(a[pos[i + 1]], 1);
		cc.addc(pos[i + 1], a[pos[i + 1]]);
	}
	
	for(int i = 0; i<= q; i++) cout<<ans[i]<<" "; 
	
	return 0;
	
	return 0;
}//end
```

---


# [POI 2023/2024 R1] CzatBBB

## 题目背景

译自 [XXXI Olimpiada Informatyczna - I etap](https://sio2.mimuw.edu.pl/c/oi31-1/dashboard/) [CzatBBB](https://sio2.mimuw.edu.pl/c/oi31-1/p/cza/)。


## 题目描述

给出一个 $n$ 个字母的字符串 $S$ 和一个参数 $k$，设 $R$ 为字符串 $S$ 的后 $k$ 个字母形成的字串。

假设字符串 $S'$ 为 $S$ 添加一个新字母生成的新字符串。

添加的规则如下所示： 对于字母 $X$ 字母，计算它在字符串 $S$ 中紧接着 $R$ 出现的次数。出现频率最高的字母为新添加的字母，如果有多个出现频率最高的字母，取最小的一个。如果 $R$ 在字符串 $S$ 中的其他地方都没有出现，则取 $X = a$。最后，我们扩展字符串 $S$，在其末尾添加字母 $X$。

例如，设 $S = \text{abaaabababa}$，$k = 3$ 则 $R$ 与后一个字母一起出现的字串为的：$\text{abaa}$、$\text{abab}$、$\text{abab}$。它最常与字母 $\text{b}$ 一起出现，因此我们在 $S$ 中加上 $\text{b}$，生成 $S' = \text{abaaabababab}$。

现在 $S' = \text{abaaabababab}$，$R = \text{bab}$，$R$ 与后一个字母一起出现的字串为：$\text{baba}$、$\text{baba}$，如 $\text{baba}$、$\text{baba}$，因此我们在 $S'$ 后面加上 $a$。

以此类推，这样的操作会进行无数次。

你的任务是编写一个程序，输出新字符串最后 $a$ 至 $b$ 个字符。

## 说明/提示

对于所有的数据，$2\leq n\leq10^6$，$1\leq k<n<a<b<10^{18}$，$b+1-a\leq10^6$，串只含小写字母。

| 子任务编号 | 附加限制 | 分值 |
| :----------: | :----------: | :----------: |
| 1 | $n\leq100$，$b\leq1000$ | 8 |
| 2 | $b\leq 10^8$ | 10 |
| 3 | $n\leq 500$，后缀 $R$ 的前一次出现将始终存在，并且每次出现后都会有相同的字母  | 16 |
| 4 | 后缀 $R$ 的前一次出现将始终存在，并且每次出现后都会有相同的字母 | 10 |
| 5 | $k\leq20$，$b\leq 10^{10}$，串只含 `ab` | 16 |
| 6 | 无任何限制  | 40 |

## 样例 #1

### 输入

```
11 3 12 13
abaaabababa
```

### 输出

```
ba
```

## 样例 #2

### 输入

```
20 3 30 40
abcdabcdabcdabcdabcd
```

### 输出

```
bcdabcdabcd
```

## 样例 #3

### 输入

```
见附件```

### 输出

```
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
```

## 样例 #4

### 输入

```
见附件```

### 输出

```
见附件```

# 题解

## 作者：honglan0301 (赞：5)

## 题目分析

比较有趣的题目。

猜结论很简单：根据数据范围容易想到会出现循环节，于是用哈希和 $\text{map}$ 暴力求字符串，很快就能找到出现循环的位置并通过本题。

不过我们需要一个更严谨的说法（）于是下面给出简要的分析证明。

- 结论 1.1：若某长为 $k$ 的字符串 $Q$ 在 $s$ 中多次出现，记其出现位置分别为 $p_1< p_2< \dots < p_c< n< p_{c+1}< p_{c+2}\dots< p_d$，则 $s_{p_{c+1}+1}=s_{p_{c+2}+1}=\dots=s_{p_d+1}$。

	（原因：每次操作都不改变“紧跟在 $Q$ 后面出现的字符”的众数。）
    
- 结论 1.2：若 $s[i-k+1,i]=s[j-k+1,j]\ (n\leq i<j)$，则 $j-i$ 是 $s[i-d+1,+\infty]$ 的循环节。

	（原因：由前文知每种串后面出现的字符固定。）
   
- 结论 2：若 $s[i-k+1,i]\ (n\leq i)$ 在 $s[1,i-1]$ 中出现，则每个 $s[j-k+1,j]\ (j\geq i)$ 都在 $s[1,j-1]$ 中出现。

	（原因：显然 $s[i-k,i+1]$ 会在 $s[1,i]$ 中出现，于是由数学归纳法可知其正确性。）
    
- 结论 3：若 $s[i-k+1,i]$ 在 $s[1,i-1]$ 中出现，则第一次出现循环节的最晚位置是 $2i-k$。

	（原因：$s[i-k+1,i]$ 以后每个长为 $k$ 的子串都在之前出现过，而这之前长为 $k$ 的子串至多只有 $i-k$ 种，故在 $i+(i-k)+1$ 之前必然会出现重复，这也代表着循环节的出现。）
    
- 结论 $4$：若 $\forall n\leq i\leq n+k$，$s[i-k+1,i]$ 都不在 $s[1,i-1]$ 中出现，则第一次出现循环节的最晚位置是 $n+k+1$。

	（原因：显然这意味着 $s_{n+1}=s_{n+2}=\dots=s_{n+k+1}=\texttt{a}$，即 $s[n+1,n+k]=s[n+2,n+k+1]$，即出现了循环节。）
    
- 最终结论：

	综上可知，第一次出现循环节的最晚位置是 $2(n+k)-k\leq 3n$，暴力哈希的时间复杂度正确，可以通过本题。
    
## 代码

数据卡了自然溢出，需要使用双模哈希。

```cpp
/*
  author: honglan0301
  Sexy_goodier _ xiaoqing
 */
#include <iostream>
#include <cstring>
#include <algorithm>
#include <unordered_map>
using namespace std;
#define mp make_pair
#define pb push_back
#define fi first
#define se second
#define int long long
#define mod1 998244353
#define mod2 1000000007
#define B 13331

int n,k,a,b,mx[3000005],cnt[1000005][27],cntd;
char s[3000005];
int cf1[1000005],hs1[3000005],cf2[1000005],hs2[3000005];
unordered_map <int,int> bh,cx;

int geths1(int l,int r)
{
	return (hs1[r]-hs1[l-1]*cf1[r-l+1]%mod1+mod1)%mod1;
}
int geths2(int l,int r)
{
	return (hs2[r]-hs2[l-1]*cf2[r-l+1]%mod2+mod2)%mod2;
}

signed main()
{
	//freopen("P9922_12.in","r",stdin);
	cin>>n>>k>>a>>b>>s;
	for(int i=0;i<=n;i++) mx[i]=1;
	cf1[0]=1; for(int i=1;i<=n;i++) cf1[i]=cf1[i-1]*B%mod1;
	cf2[0]=1; for(int i=1;i<=n;i++) cf2[i]=cf2[i-1]*B%mod2;
	for(int i=1;i<=n;i++) hs1[i]=(hs1[i-1]*B+s[i-1])%mod1;
	for(int i=1;i<=n;i++) hs2[i]=(hs2[i-1]*B+s[i-1])%mod2;
	for(int i=k;i<n;i++)
	{
		int nhs=geths1(i-k+1,i)*1000000007+geths2(i-k+1,i); if(!bh.count(nhs)) bh[nhs]=++cntd;
		int nr=bh[nhs]; cnt[nr][s[i]-'a'+1]++; 
		if(cnt[nr][s[i]-'a'+1]>cnt[nr][mx[nr]]||cnt[nr][s[i]-'a'+1]==cnt[nr][mx[nr]]&&s[i]-'a'+1<mx[nr]) mx[nr]=s[i]-'a'+1;
	}
	for(int i=n+1;i<=3*n;i++)
	{
		int nhs=geths1(i-k,i-1)*1000000007+geths2(i-k,i-1); int nr=bh[nhs]; 
		s[i-1]=(char)(mx[nr]+'a'-1); hs1[i]=(hs1[i-1]*B+s[i-1])%mod1; hs2[i]=(hs2[i-1]*B+s[i-1])%mod2;
		if(cx[nhs])
		{
			int wz=cx[nhs]; int cd=i-wz;
			//cout<<wz<<" "<<i<<endl; return 0;
			for(int j=a;j<=b;j++)
			{
				if(j<=i) cout<<s[j-1];
				else cout<<s[wz+(j-wz)%cd-1];
			}
			cout<<endl; return 0;
		}
		else cx[nhs]=i;
	}
}
```


---

## 作者：_•́へ•́╬_ (赞：5)

## 思路

把所有长为 $k$ 的串拿出来当做点，转移当做边，建图。

可以发现这是一个基环内向树森林。因为每次把众数的出现次数增加，众数当然不会改变，于是一个点的出度就是 1。

一个结论是图的大小是 $\mathcal O(n+k)$ 的。

证明分两种情况，一个是最后出现循环，另一个是最后全 `a`，样例里都有的。

用哈希把图建出来然后利用循环直接输出即可。

## code

一开始写 `map` 套 `map`，波兰 OJ 上直接过了，洛谷 1.6s 真菜。

换了 `unordered_map`，能快很多。

内层用数组的话空间复杂度会多一个 $V$，但是看别人写的感觉只差一倍啊啊啊。

```cpp
#include<stdio.h>
#include<unordered_map>
#include<map>
#define N 2000009
#define base 29ll
#define mod 19260817191981181ll
using namespace std;
int n,m,l,r;char s[N];unordered_map<long long,map<char,int> >mmp;
unordered_map<long long,int>cir;long long a,b,hsh[N],pw=1;
inline long long get(int i)
	{return(hsh[i]-(__int128)(hsh[i-m])*pw%mod+mod)%mod;}
main()
{
	scanf("%d%d%lld%lld%s",&n,&m,&a,&b,s+1);
	for(int i=m;i--;pw=pw*base%mod);
	for(int i=1;i<=n;++i)hsh[i]=(hsh[i-1]*base+s[i]-'a')%mod;
	for(int i=m+1;i<=n;++i)++mmp[get(i-1)][s[i]];
	for(int i=n+1;;++i)
	{
		map<char,int>&tmp=mmp[get(i-1)];
		int maxn=0;s[i]='a';
		for(map<char,int>::iterator it=tmp.begin();it!=tmp.end();++it)
			if(it->second>maxn)maxn=it->second,s[i]=it->first;
		++mmp[get(i-1)][s[i]];hsh[i]=(hsh[i-1]*base+s[i]-'a')%mod;
		if(cir.count(get(i))){l=cir[get(i)];r=i;break;}
		cir[get(i)]=i;
	}
	for(;a<=b;++a)putchar(a<=r?s[a]:s[(a-l)%(r-l)+l]);
}
```

---

## 作者：NXMxyh123 (赞：1)

我们记紧接着一个串出现次数最多得字符为 $mx$。
若当前字符串长度为 $k$ 的后缀为 $s$，则在字符串后加入 $mx_s$ 后，紧接着 $s$ 出现次数最多的字符一定仍然是 $mx_s$，那么当字符串的后缀再次变为 $s$ 时，加入的字符一定还是 $mx_s$，由此可知答案为若干长度不超过 $n$ 的循环构成。题目要求我们输出字符串下标为 $a$ 到 $b$ 的内容，我们可以用后缀自动机储存和更新每个长度为 $k$ 的字串的 $mx$，当 $a$ 较大时直接将其对循环长度取模即可。若初始时字符串长度为 $k$ 的后缀仅出现一次，则不断在字符串末尾加入 ```a```，显然最多加 $n$ 次就会让长度为 $k$ 的后缀不止出现一次（最坏情况是加入 $n$ 个 ```a```，此时后缀全为 ```a```），此时字符串在之后的更新过程中一定不会出现长度为 $k$ 的后缀仅出现一次的情况（相当于有个指针在非末尾处移动）。

code：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000005;
#define ll long long
char s[N<<1],ans[N];
struct state{
	int nxt[26],fa,len,sum[26],mx,mxi;
	void ins(int x){
		++sum[x];
		if(sum[x]>mx)mx=sum[x],mxi=x;
		else if(sum[x]==mx)mxi=min(mxi,x);
	}
	int nx(){
		return nxt[mxi];
	}
}st[N<<2];
int n,k,tot,last,LEN,v[N<<2],cnt,TT;
ll a,b;
void insert(int x,int le){
	int p1=++tot,p2=last;
	st[p1].len=le;
	while(p2!=-1&&!st[p2].nxt[x]){
		st[p2].nxt[x]=p1,p2=st[p2].fa;
	}
	if(p2==-1){
		st[p1].fa=0;
	}
	else{
		int p3=st[p2].nxt[x];
		if(st[p2].len+1==st[p3].len){
			st[p1].fa=p3;
		}
		else{
			int p4=++tot;
			st[p4]=st[p3],st[p4].len=st[p2].len+1;
			while(p2!=-1&&st[p2].nxt[x]==p3){
				st[p2].nxt[x]=p4,p2=st[p2].fa;
			}
			st[p1].fa=st[p3].fa=p4;
		}
	}
	last=p1;
}
int main(){
	scanf("%d%d%lld%lld",&n,&k,&a,&b),LEN=b-a+1;
	scanf(" %s",s+1),st[0].len=0,st[0].fa=-1;
	for(int i=1;i<=n;++i)insert(s[i]-'a',i);
	int nw=0;
	for(int i=1;i<=k;++i)nw=st[nw].nxt[s[i]-'a'];
	for(int i=k+1;i<=n;++i){
		st[nw].ins(s[i]-'a'),nw=st[nw].nxt[s[i]-'a'];
		while(st[st[nw].fa].len>=k)nw=st[nw].fa;
	}
	while(!st[nw].mx){
		s[++n]='a',insert(0,n),st[nw].ins(0),nw=st[nw].nxt[0];
		while(st[st[nw].fa].len>=k)nw=st[nw].fa;
	}
	int _nw=nw,pr,sum1=0,sum2=0;
	while(1){
		pr=nw,nw=st[nw].nx();
		while(st[st[nw].fa].len>=k)nw=st[nw].fa;
		if(v[nw]==2)break;
		if(v[nw]==1&&!TT)TT=pr;
		++v[nw];
	}
	for(int i=1;i<=tot;++i)sum1+=(v[i]==1),sum2+=(v[i]==2);
	if(n+sum1>=a){
		if(n>=a){
			for(int i=a;i<=n;++i)ans[++cnt]=s[i];
			LEN-=(n-a+1),a=n+1;
		}
		int nw=_nw;
		for(int i=n+1;i<a;++i){
			nw=st[nw].nx();
			while(st[st[nw].fa].len>=k)nw=st[nw].fa;
		}
		for(int i=a;i<=a+LEN-1;++i){
			ans[++cnt]=st[nw].mxi+'a';
			nw=st[nw].nx();
			while(st[st[nw].fa].len>=k)nw=st[nw].fa;
		}
	}
	else{
		a-=(n+sum1);
		a=(a-1)%sum2+1,nw=TT;
		for(int i=1;i<a;++i){
			nw=st[nw].nx();
			while(st[st[nw].fa].len>=k)nw=st[nw].fa;
		}
		for(int i=1;i<=LEN;++i){
			ans[++cnt]=st[nw].mxi+'a';
			nw=st[nw].nx();
			while(st[st[nw].fa].len>=k)nw=st[nw].fa;
		}
	}
	printf("%s\n",ans+1);
	return 0;
}
```

---


# [NFLSPC #6] 9.pop_book();

## 题目背景

*Alek 岁*在操场上跑圈。他看到有人超过他，很不爽。于是他采取了以下策略：

## 题目描述

在长度为 $m$ 的环形操场上有 $n$ 个人，第 $i$ 个人在 $t_i$ 时刻从位置 $p_i$ 出发以 $v_i$ 单位长度每秒的速度移动。现在 $0$ 时刻 *Alek 岁*在位置 $0$ 处，速度为 $0$，会跟着经过他的速度最快的人移动。$q$ 次询问 $T_i$ 时刻 *Alek 岁*的移动距离。可以证明这是一个整数。

注：从位置 $0$ 出发逆时针方向 $x$（$0\leq x < m$）单位长度的位置称为位置 $x$。所有人的运动方向都是逆时针。

多组数据。

## 说明/提示

对于所有数据，$1\leq T\leq 10 ^ 3$，$1\leq n, \sum n\leq 5\times 10 ^ 5$，$1\leq m, q, \sum q \leq 10 ^ 6$，$1\leq v_i, t_i, T_i\leq 10 ^ 9$，$0\leq p_i < m$。保证 $t_i$ 单调不降，$T_i$ 单调递增。

- 子任务 1（$10$ 分）：$n\leq 5$。
- 子任务 2（$10$ 分）：$n\leq 50$。
- 子任务 3（$20$ 分）：$n\leq 500$。
- 子任务 4（$20$ 分）：$n\leq 5\times 10 ^ 3$。
- 子任务 5（$20$ 分）：$n\leq 5\times 10 ^ 4$。
- 子任务 6（$20$ 分）：无特殊限制。

**请注意，子任务并没有保证 $\sum q$ 的数量级**。

本题 IO 量较大，建议使用 `scanf/printf` 或关闭流同步的 `cin/cout` 或快速读入和快速输出。

Source：NFLSPC #6 I by Alex_Wei

## 样例 #1

### 输入

```
1
3 30 8
0 2 1
6 5 2
25 4 4
1
5
9
10
11
12
13
14
```

### 输出

```
0
8
16
19
23
27
31
36
```

# 题解

## 作者：Alex_Wei (赞：4)

[题目链接](https://www.luogu.com.cn/problem/P9933)。


由于速度至多变化 $n$ 次，所以路程关于时间的函数是一个至多 $n$ 段的分段函数，且每一段都是线段。如果能求出每一段线段两端的坐标，就可以快速回答询问。基于此，有两种维护方式。

---

**解法一**

因为 A 只会跟着经过他的速度最快的人移动，所以只要一个人被超越，他就一定不产生影响。

使用平衡树维护所有人的相对位置。一旦某两个人的相对位置发生改变，那么一定有一个人被删除。

按照时间顺序模拟，平衡树上二分算出加入的人插入的位置，以及他和相邻两个人什么时候会撞在一起，将两个时刻加入优先队列。不断取出最小的相邻两个人撞在一起的时刻，判断事件是否会发生（因为其中一个人已经和其他人撞起来了），以及发生时刻是否小于下一个人加入的时间。将速度较慢（相撞时在前面）的人删除，加入速度较快的人和新的在他前面的人相撞的时间。

模拟过程中容易计算 A 在每个时刻的总移动距离。

时间复杂度 $\mathcal{O}(n\log n)$。

---

**解法二**

解法一需要平衡树，写起来很麻烦。

换一种思路，断环成链，将操场视为一条数轴。数轴上的位置 $x$ 表示 A 从起点出发移动 $x$ 单位距离。于是，加入一个人时，可以根据他加入的位置和 A 当前的位置算出他在数轴上的位置，于是他在数轴上的位置关于时刻 $t$ 可以写成一条射线 $kt + b$（$t\geq t_i$），其中 $k$ 是他的速度。由于加入一个人之后不会涉及到 $t_i$ 之前的时刻，于是可认为射线就是直线。

查询 A 的位置相当于查询若干条直线在某个点处的最大值，使用李超线段树维护即可。注意后加入的直线会影响之前的时间，所以依然需要离线回答询问。

时间复杂度 $\mathcal{O}(n\log n)$。

---


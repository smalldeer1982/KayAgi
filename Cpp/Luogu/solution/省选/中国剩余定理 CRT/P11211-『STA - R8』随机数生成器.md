# 『STA - R8』随机数生成器

## 题目背景

**Upd on 2024/10/22** 加入一组 Hack 数据（#13）

## 题目描述

**这是一道交互题。**

Lloyd 有一个随机数生成器，对于随机种子 $s$ 和生成器类型 $t$，它第 $x$ 次（$x<p$）生成的随机数是：
$$r_{s,t}(x)=\begin{cases}s^x\bmod p&t=1\\x^s\bmod p&t=2\end{cases}$$
其中 $p$ 是一个固定素数。$0\le s<p-1$。

现在给定 $p,t$。已知随机数生成器在你询问之前已经生成过若干随机数，而在你生成随机数的时候不会有任何其他随机数生成访问（也就是你生成的是一段连续的随机数）。你每次可以调用随机数生成器来获取一个随机数，并且在若干次调用之后找出随机数种子 $s$ 的值。**保证有解且 5 次询问后一定能得到唯一的解。**

***
**实现细节**

本题采用 IO 交互模式。

第一行输入两个正整数 $t,p$。

接下来，可以向交互库发送以下两种操作：
- `?`，表示调用一次随机数生成器，随即你可以从标准输入中读入随机数生成器生成的数值。
- `! s`，报告你发现的 $s$。

发送 `!` 操作后你应该立即结束程序。另外在每一次操作后都需要清空缓冲区。评分方式见数据范围部分。

如果你的操作不符合交互格式可能出现不可预料的结果。保证在交互次数不超过 19930（也就是至少可以获得 1 分）时交互库的运行时间不超过 100ms。对于 19930 之上的交互次数不保证交互库运行时间。

## 说明/提示

**样例解释**

样例仅供参考，不一定具有实际逻辑。

第一组样例：$p=10007$，$s=114$，在询问之前生成过 $513$ 次随机数。

第二组样例：$p=10007$，$s=514$，在询问之前生成过 $113$ 次随机数。
***

**数据范围**

**本题采用捆绑测试。**（Subtask 分数为 Subtask 内各测试点分数之最小值）

- Subtask 1 (20pts)：$t=1$。
- Subtask 2 (20pts)：$p\le 10^3$。
- Subtask 3 (60pts)：无特殊限制。

对于全部数据，$2\le p\le2\times10^6$ 且 $p$ 是素数，$t\in\{1,2\}$，保证有解。

对于每个测试点，如果你向交互库发送了 $c$ 次 `?` 操作，那么你可以得到的分数由如下表达式给出：
$$\mathrm{score}=\begin{cases}100&c\le 5\\\max\{0,100-\lceil10\ln(c)\rceil\}&\text{otherwise.}\end{cases}$$

## 样例 #1

### 输入

```
1 10007

4960```

### 输出

```

?

! 114```

## 样例 #2

### 输入

```
2 10007

4960

6980```

### 输出

```

?

?

! 514```

# 题解

## 作者：jijidawang (赞：6)

### $t=1$
输出 $\frac{s^{x+1}}{s^x}$。

### $t=2$
枚举 $x$，询问能问出来一段 $(x+i)^s\equiv a_i\pmod p$。

取 $p$ 的原根 $g$，令 $\operatorname{ind}_g(x)$ 是 $x$ 对 $g$ 的指标。限制即为 $s\operatorname{ind}_g(x+i)\equiv\operatorname{ind}(a_i)\pmod{p-1}$。

注意到相当于解线性同余方程组，分别解出每个方程后 exCRT 合并即可。

---

## 作者：masterhuang (赞：5)

或许更好的阅读体验：[我的博客](https://www.cnblogs.com/HaHeHyt/p/18488070)！

前置知识：原根，**exCRT**。

为了方便，下文 $/$ 表示除法。

首先 $t=1$ 是容易的，直接相邻的除一下即可。

---

否则考虑询问除连续的 $5$ 个数，分别为 $a_0,a_1,\cdots,a_4$。

首先特判掉存在 $a_i=0$ 的情况，此时直接枚举 $s$ 即可。

我们先求出 $p$ 的一个原根 $g$，设离散对数 $\log(x)=y$ 表示 $g^y\equiv x\pmod p$。

否则我们枚举 $x$，并且 $x\sim x+4$ 没有一个是 $\bmod\ p=0$。

此时我们有 $5$ 个线性同余方程：$\forall 0\le i<5,s\log (x+i)\equiv \log a_i\pmod {p-1}$。

除掉 $\gcd$，留下合法的方程，然后 **exCRT** 合并所有方程。

最终我们得到了 $s\equiv A\pmod B$，其中 $B$ 是 $p-1$ 的因子。

然后我们枚举 $s=Bk+A,k\in [0,(p-1)/B)$，然后判断 $(s,x)$ 是否合法即可。

复杂度是所有的 $(p-1)/B$ 之和乘一些 **exgcd** 的 $\log$。

写个程序算一下，这个和的上界大概是不超过 $2p$ 的，即 $4\times 10^6$，常数稍微写优秀一点就足以通过了。

```cpp
#include<bits/stdc++.h>
#define LL long long
#define fr(x) freopen(#x".in","r",stdin);freopen(#x".out","w",stdout);
#define ff fflush(stdout)
using namespace std;
const int N=2e6+5;
int id,mod,g,a[5],lg[N];bool v[N];
inline int ask(){puts("?");ff;int x;scanf("%d",&x);return x;}
inline int md(int x){return x>=mod?x-mod:x;}
inline int ksm(int x,int p){int s=1;for(;p;(p&1)&&(s=1ll*s*x%mod),x=1ll*x*x%mod,p>>=1);return s;}
#define mytz __builtin_ctz
inline int gcd(int a,int b)
{
	int az=mytz(a),bz=mytz(b),z=min(az,bz),diff;b>>=bz;
	while(a) a>>=az,diff=a-b,az=mytz(diff),b=min(a,b),a=abs(diff);return b<<z;
}
namespace GG
{
	int n;vector<int>g;
	inline int ksm(int x,int p){int s=1;for(;p;(p&1)&&(s=1ll*s*x%n),x=1ll*x*x%n,p>>=1);return s;}
	inline bool isy(int x){if(gcd(x,n)>1) return 0;for(int i:g) if(ksm(x,i)==1) return 0;return 1;}
	inline int gg(int x)
	{
		g.clear();int t=(n=x)-1,y=t;
		for(int i=2;i*i<=y;i++) if(y%i==0){while(y%i==0) y/=i;g.push_back(t/i);}(y^1)&&(g.push_back(t/y),1);
		for(int i=1;i<x;i++) if(isy(i)) return i;
	}
}//离散对数板子
inline bool chk(int x,int s){for(int i=0;i<5;i++) if(1ll*s*lg[md(x+i)]%(mod-1)!=a[i]) return 0;return 1;}
void exgcd(int a,int b,int &x,int &y)
{
	if(!b) return x=1,y=0,void();
	exgcd(b,a%b,x,y);int t=x;
	x=y;y=(t-(a/b)*y);
}
inline int inv(int x,int p){int a,b;exgcd(x,p,a,b);return (a%p+p)%p;}
inline void mg(int &X,int &L,int x,int y)
{
	if(!L) return L=x,X=y,void();int _x,_y,ll=L/gcd(L,x)*x;
	exgcd(L,x,_x,_y);_x=(LL)(y-X)/gcd(L,x)*_x%ll;_x=(_x+ll)%ll;
	X=((LL)L*_x+X)%ll;L=ll;
}//exgcd,excrt 板子
int main()
{
	scanf("%d%d",&id,&mod);
	if(id==1)
	{
		int A=ask(),B=ask();
		return printf("! %d\n",1ll*B*ksm(A,mod-2)%mod),0;
	}
	g=GG::gg(mod);
	for(int i=0,s=1;i<mod-1;i++,s=1ll*s*g%mod) lg[s]=i;//原根离散对数
	for(int i=0;i<5;i++) a[i]=ask();
	for(int i=0;i<5;i++) if(!a[i])
	{
		int x=md(mod-i);
		for(int s=0;s<mod-1;s++) if(chk(x,s))
			return printf("! %d\n",s),0;
	}
	for(int i=0;i<5;i++) a[i]=lg[a[i]];
	for(int x=1;x+4<mod;x++)//枚举 x
	{
		int X=0,L=0;bool o=1;
		for(int j=0;j<5;j++)
		{
			int t=md(j+x);
			if(t==1) continue;
			int A=lg[t],B=a[j],C=mod-1,g=gcd(A,C);
			if(B%g){o=0;break;}A/=g,B/=g,C/=g;//除掉 gcd
			mg(X,L,C,1ll*B*inv(A,C)%C);//excrt 合并同余方程
		}
		if(!o) continue;
		for(int j=X;j<mod-1;j+=L) if(chk(x,j))
			return printf("! %d\n",j),0;//枚举求解
	}
	printf("! 1\n");
	return 0;
}
```

---

## 作者：StarTwinkleTwinkle (赞：1)

这个题分  $t=1$ 与 $t=2$ 两个部分。

### $t=1$

设两次询问所得的数为 $a$，$b$，我们得到了两个式子：$s^{x}\equiv a\pmod{p}$，$s^{x+1}\equiv b\pmod{p}$。

两式相除，我们可以得到 $\frac{s^{x+1}}{s^{x}}\equiv\frac{b}{a}\pmod{p}$，化简一下，可得 $s\equiv\frac{b}{a}\pmod{p}$，即输出第二个数乘上第一个数的逆元再模 $p$ 即可。

### $t=2$

这个有点小难我们可以推一下：

设第 $i$ 次询问所得的数为 $a_i$，我们可以得到：

$$(x+i)^{s}\equiv a_i\pmod{p}$$

接下来，就说一下官方题解里有点没说清楚的东西（可能是我太蒟了，没看懂）：$\operatorname{ind}$。

说通俗点，大家可以把这个理解为模意义下的 $\log$ 运算（我也只会这么解释了）。

众所周知：

若 $a^{b}\equiv a^{c}\pmod{p}$ 且 $a$ 为模 $p$ 的原根，则 $b\equiv c\pmod{\varphi(p)}$。

我们可以扩展成：

若 $a\equiv b\pmod{p}$ 且 $g$ 为模 $p$ 的原根，则 $\operatorname{ind}_g(a)\equiv \operatorname{ind}_g(b)\pmod{\varphi(p)}$。

故原式 $(x+i)^{s}\equiv a_i\pmod{p}$ 我们可以化成：

$$\operatorname{ind}_g((x+i)^{s})\equiv \operatorname{ind}_g(a_i)\pmod{p-1}$$

我们刚才说，可以把 $\operatorname{ind}$ 理解为模意义下的 $\log$ 运算，故它有 $\log$ 的性质。

我们知道：

$$\log_g{a^c}=c\times\log_b{a}$$

故原式可以进一步化简为：

$$s\times \operatorname{ind}_g(x+i)\equiv \operatorname{ind}_g(a_i)\pmod{p-1}$$

故我们可以枚举 $x$（从 $0$ 到 $p-1$），然后去求，时间复杂度为 $O(n\log n)$。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long bsgs(int a,int b,int p){
	if(b==1)return 0;
	long long k=sqrt(p)+1,ak=1;
	std::unordered_map<long long,long long>hash;
	for(register long long i=0,j=b;i<k;++i)hash[j]=i,j=k*a%p;
	for(register long long i=0;i<k;++i)ak=ak*a%p;
	for(long long i=1,j=ak;i<=k;++i){
		if(hash.count(j)&&i*k>=hash[j])return i*k-hash[j];
		j=j*ak%p;
	}
	return -1;
}
template<typename S>inline S gcd(S a,S b){return b?gcd(b,a%b):a;}
template<typename S>inline S lcm(S a,S b){return a/gcd(a,b)*b;}
template<typename S>inline S phi(S x){S r=x;for(S i=2;i*i<=x;++i)if(x/i*i==x){r=r/i*(i-1),x/=i;while(x/i*i==x)x/=i;}if(x>1)r=r/x*(x-1);return r;}
template<typename S>S quick_pow(S x,S y,S mod){x%=mod;S ans=1;while(y){if(y&1)(ans*=x)%=mod;(x*=x)%=mod,y>>=1;}return ans;}
void Exgcd(long long a,long long b,long long &x,long long &y){
    if(!b)x=1,y=0;
    else Exgcd(b,a%b,y,x),y-=a/b*x;
}
long long query(long long a,long long p){
    long long x,y;
    Exgcd(a,p,x,y);
    return(x%p+p)%p;
}
long long t,p;
long long x,y,ans,e[7],r[7];
long long a[7],g,ind[2000006],s1,s2;
vector<long long>v;
int main()
{
	cin>>t>>p;
	if(t==1){
		cout<<'?'<<endl;
		cin>>x;
		cout<<'?'<<endl;
		cin>>y;
		cout<<"! "<<quick_pow(x,p-2ll,p)*y%p<<endl;
		return 0;
	}
	for(register int i=1;i<=5;++i){
		cout<<'?'<<endl;
		cin>>a[i];
	}
	long long o=p-1;
	for(register int i=2;i*i<=o;++i){
		if(o%i==0){
			v.push_back(i),o/=i;
			while(o%i==0)o/=i;
		}
	}
	if(o!=1)v.push_back(o);o=p-1;
	for(register long long i=1;;++i){
		for(auto j:v)if(quick_pow(i,o/j,p)==1)goto S;
		g=i;break;
		S:;
	}
	for(register int i=0,k=1;i<p;++i)ind[k]=i,k=k*g%p;
	for(register int i=1;i<=5;++i)e[i]=ind[a[i]];
	for(register int i=0,k;i<p;++i){
		for(register int j=1;j<=5;++j)r[j]=ind[(i+j)%p];
		if(e[1]*r[2]%o==e[2]*r[1]%o&&e[1]*r[3]%o==e[3]*r[1]%o&&e[1]*r[4]%o==e[4]*r[1]%o&&e[1]*r[5]%o==e[5]*r[1]%o){
			for(register int j=1;j<=5;++j){
				k=gcd(e[j],r[j]);
				s1=query(r[j]/k,o)*(e[j]/k)%o,s2=query(r[j]/k,o/k)*(e[j]/k)%(o/k);
				for(register long long w=1,z1=s1,z2=s2;w<=k;++w,z1+=s1,z2+=s2){
					if(quick_pow(i+1ll,z1,p)==a[1]&&quick_pow(i+2ll,z1,p)==a[2]&&quick_pow(i+3ll,z1,p)==a[3]&&quick_pow(i+4ll,z1,p)==a[4]&&quick_pow(i+5ll,z1,p)==a[5]){
						cout<<"! "<<z1%o;
						return 0;
					}
					if(quick_pow(i+1ll,z2,p)==a[1]&&quick_pow(i+2ll,z2,p)==a[2]&&quick_pow(i+3ll,z2,p)==a[3]&&quick_pow(i+4ll,z2,p)==a[4]&&quick_pow(i+5ll,z2,p)==a[5]){
						cout<<"! "<<z2%o;
						return 0;
					}//可能写得非常之神奇，总时间是官方的1/6
				}
			}
		}
	}
	return 0;
}
```

---


# 【MX-X10-T6】[LSOT-4] 集合

## 题目描述

记全集为 $U$。

定义一个操作方案为对每个非空集合 $S \subseteq U$ 选择 $S$ 中任意一个元素作为 $S$ 的代表元，记为 $r(S)$。

一种操作方案是好的当且仅当对任意非空集合 $S \subseteq U$，满足对于任意将其划分为 $m$ 个非空子集的方案 $A_1, A_2, \ldots, A_m$，$\exists 1 \le i \le m, r(A_i) = r(S)$。

求 $U=\{1, 2, \ldots, n\}$ 时的本质不同的好的操作方案数，将答案对 $1000000087$ 取模。

两个操作方案是本质不同的，当且仅当存在某个非空集合 $S 
\subseteq U$，使得 $r(S)$ 在两个操作方案中不同。


## 说明/提示

**【样例解释 #1】**

所有方案都是好的，所以答案为 $1^3 \times 2^3 \times 3 = 24$。

**【样例解释 #2】**

$6$ 种方案分别为：

$r(\{1, 2, 3\}) = 1$，$ r(\{1, 2\}) = 1$，$ r(\{1, 3\}) = 1$，$ r(\{2, 3\}) = 2$，$ r(\{1\}) = 1$，$ r(\{2\}) = 2$，$ r(\{3\}) = 3$；

$r(\{1, 2, 3\}) = 1$，$ r(\{1, 2\}) = 1$，$ r(\{1, 3\}) = 1$，$ r(\{2, 3\}) = 3$，$ r(\{1\}) = 1$，$ r(\{2\}) = 2$，$ r(\{3\}) = 3$；

$r(\{1, 2, 3\}) = 2$，$ r(\{1, 2\}) = 2$，$ r(\{1, 3\}) = 1$，$ r(\{2, 3\}) = 2$，$ r(\{1\}) = 1$，$ r(\{2\}) = 2$，$ r(\{3\}) = 3$；

$r(\{1, 2, 3\}) = 2$，$ r(\{1, 2\}) = 2$，$ r(\{1, 3\}) = 3$，$ r(\{2, 3\}) = 2$，$ r(\{1\}) = 1$，$ r(\{2\}) = 2$，$ r(\{3\}) = 3$；

$r(\{1, 2, 3\}) = 3$，$ r(\{1, 2\}) = 1$，$ r(\{1, 3\}) = 3$，$ r(\{2, 3\}) = 3$，$ r(\{1\}) = 1$，$ r(\{2\}) = 2$，$ r(\{3\}) = 3$；

$r(\{1, 2, 3\}) = 3$，$ r(\{1, 2\}) = 2$，$ r(\{1, 3\}) = 3$，$ r(\{2, 3\}) = 3$，$ r(\{1\}) = 1$，$ r(\{2\}) = 2$，$ r(\{3\}) = 3$。

**【数据范围】**

**本题采用捆绑测试。**

- 子任务 1（5 分）：$m = 2$。
- 子任务 2（6 分）：$n \le 4$。
- 子任务 3（10 分）：$n \le 3 \times 10^3$。
- 子任务 4（18 分）：$m = 1$。
- 子任务 5（26 分）：$m \le 3 \times 10^3$。
- 子任务 6（35 分）：无特殊限制。

对于全部的数据，$1 \le m < n \le 2 \times 10^5$。

## 样例 #1

### 输入

```
3 1
```

### 输出

```
24
```

## 样例 #2

### 输入

```
3 2
```

### 输出

```
6
```

## 样例 #3

### 输入

```
4 3
```

### 输出

```
2592
```

## 样例 #4

### 输入

```
114514 3
```

### 输出

```
750017326
```

## 样例 #5

### 输入

```
114514 19198
```

### 输出

```
274658403
```

# 题解

## 作者：VinstaG173 (赞：7)

问候出题人环节：直接出${}\bmod{10^9+7}$ 怎么你了？

记答案为 $f(n,m)$，则对于 $f(n,1)$ 与 $f(n,n)$ （虽然后者在原题中并没有要求，但为了后续计算方便还是列出）的情况均容易发现所有子集都可以任取一个其中元素为代表，共 $\displaystyle\prod_{k=1}^nk^{\binom nk}$ 种方案。以下设 $n>m\ge2$。

首先发现问题具有对称性，$r(U)$ 取任意值的情况都是本质相同的，故不妨设 $r(U)=n$。以下先考虑 $n\in S$ 时 $r(S)$ 的值。分类讨论：

1. $|S|\le n-m+1$，此时可以将 $U$ 划分为 $m$ 个集合，使得其中有一个为 $S$。由题意知 $\exists i,r(A_i)=n$，由于其为划分，故只有 $S\ni n$，因此只可能 $r(S)=n$。由于 $m<n$，我们有 $n-m+1\ge2$，故 $r(\{a,n\})=n,\forall 1\le a\le n-1$。
2. $|S|\ge m+1$，假设 $r(S)\neq n$，则可以将 $S$ 划分为 $m$ 个集合，其中一个为 $\{r(S),n\}$。由题意和 1. 中结论知 $r(S)=r(\{r(S),n\})=n$，矛盾！故 $r(S)=n$。
3. 其余情况，由于 $|S|\le m$，故 $|S|$ 或者只能划分成全为单点集，或者没有划分方案，条件退化，可以任取一个其中元素为代表元且对其他子集的代表元取值无影响。

综上，对于满足 $n\in S$ 的所有子集 $S$ 共有 $\displaystyle\prod_{k=n-m+2}^{m}k^{\binom{n-1}{k-1}}$ 种方案，剩下是 $U'=\{1,\dots,n-1\}$ 的子集，直接归纳，由乘法原理，得递推式：

$$f(n,m)=f(n-1,m)\cdot n\prod_{k=n-m+2}^{m}k^{\binom{n-1}{k-1}}.$$

展开后合并同样底数，由组合数前缀和公式，得到封闭形式：

$$\begin{aligned}
f(n,m)&=f(m,m)\cdot\dfrac{n!}{m!}\prod_{k=3}^{m}k^{\sum_{s=m+1}^{\min(n,k+m-2)}\binom{s-1}{k-1}}\\
&=f(m,m)\cdot\dfrac{n!}{m!}\prod_{k=3}^{m}k^{\binom{\min(n,k+m-2)}{k}-\binom{m}{k}}.
\end{aligned}$$

组合数在指数上，要${}\bmod{\varphi(p)}$，其中 $\varphi(p)=10^9+86=2\times3\times41\times59\times68899$ 是 square-free 的，用 Lucas 定理然后 CRT 合并即可。时间复杂度 $O(n+m\log m)$。

Code:
```cpp
#define ll long long
const int ntf=1e9+87;
inline ll qpw(ll x,int v,int mod=ntf){
	ll r=1;while(v){
		(v&1)&&(r=r*x%mod);
		x=x*x%mod,v>>=1;
	}return r;
}

const int p[5]={2,3,41,59,68899};
int v[5];
ll fac[5][70003];
ll fic[5][70003];
ll __C(int i,int m,int k){
	if(m<k)return 0;
	return fac[i][m]*fic[i][k]%p[i]*fic[i][m-k]%p[i];
}ll _C(int i,int m,int k){
	if(m<k)return 0;
	if(m<p[i])return __C(i,m,k);
	return _C(i,m/p[i],k/p[i])*__C(i,m%p[i],k%p[i])%p[i];
}inline ll C(int m,int k){
	if(m<k)return 0;
	ll res=0;
	for(int i=0;i<5;++i)
		res=(res+_C(i,m,k)*v[i])%(ntf-1);
	return res;
}

int n,m,sum;ll ans;
inline void solve(){
	for(int i=0;i<5;++i){
		fac[i][0]=1;
		for(int j=1;j<p[i];++j)
			fac[i][j]=fac[i][j-1]*j%p[i];
		fic[i][p[i]-1]=p[i]-1;
		for(int j=p[i]-1;j;--j)
			fic[i][j-1]=fic[i][j]*j%p[i];
		v[i]=(ntf-1)/p[i]*qpw((ntf-1)/p[i]%p[i],p[i]-2,p[i]);
	}cin>>n>>m;ans=1;
	if(m==1){
		for(int k=2;k<=n;++k)
			ans=ans*qpw(k,C(n,k))%ntf;
		cout<<ans<<"\n";return;
	}for(int k=2;k<=m;++k)
		ans=ans*qpw(k,C(m,k))%ntf;
	for(int i=n;i>m;--i)ans=ans*i%ntf;
	for(int k=3;k<=m;++k){sum=0;
		ans=ans*qpw(k,C(min(k+m-2,n),k)-C(m,k)+ntf-1)%ntf;
	}cout<<ans<<"\n";
}
```

---

## 作者：cjZYZtcl (赞：2)

这里是出题人题解。

## Solution

考虑 $m = 2$ 怎么做。

> 引理 $1$：若我们已经确定了 $r(U)$，则对于所有 $U$ 的满足 $r(U) \in S$ 的非空真子集 $S$ 有 $r(S) = r(U)$。
> 
> 证明：若存在 $U$ 的满足 $r(U) \in S$ 的非空真子集 $S$ 满足 $r(S) \not= r(U)$，则有将 $U$ 划分成 $S$ 与 $U / S$ 两个集合的方式，满足 $r(U) \not= r(S)$ 且 $r(U) \not= r(U / S)$ 与合法条件不符，则引理成立。

根据引理 $1$，不难发现如果我们选定了 $r(U)$，那么 $\forall r(U) \in S, r(S) = r(U)$，并且对于其他集合的代表元没有任何限制，所以选定 $r(U)$ 后等价于将 $r(U)$ 从 $U$ 中删去，进入一个全集大小为 $n-1$ 的子问题，记 $f_n$ 表示 $|U| = n$ 时的答案，则可以得到递推式 $f_n = \begin{cases}nf_{n - 1} & n > 1 \\ 1 & n = 1\end{cases}$，于是有 $f_n = n!$。

然后考虑 $m > 2$ 的情况。

仍然考虑选择 $r(U)$ 后的影响。

仿照引理 $1$ 的结论可以得出：

> 引理 $2$：若我们确定了 $r(U)$，则对于所有 $U$ 的满足 $r(U) \in S$ 且 $|S| \le n - m + 1$ 的非空真子集 $S$ 有 $r(S) = r(U)$。

证明略。但事实上这个限制并不充要。

> 引理 $3$：若我们确定了 $r(U)$，则对于所有 $U$ 的满足 $r(U) \in S$ 且 $|S| > m$ 的非空真子集 $S$ 有 $r(S) = r(U)$。
>
> 证明：若存在 $U$ 的非空真子集 $S$ 满足 $|S| > m$ 且 $r(S) \not= r(U)$，一定存在一种将 $S$ 划分成 $m$ 个集合的方式，使得 $\exists 1 \le i \le m$ 同时满足 $r(U) \in A_i, r(S) \in A_i$，那么此时对于该集合 $A_i$ 同时有限制 $r(A_i) = r(U)$ 和 $r(A_i) = r(S)$ 矛盾，所以引理成立。

结合引理 $2$ 和引理 $3$，有对于 $\forall r(U) \in S$，若 $|S| > m$ 或 $|S| <= n - m + 1$ 则有 $r(S) = r(U)$，不难证明这个限制在仅确定 $r(U)$ 的情况下是充要的。

仍然考虑递归子问题的形式，那么当我们确定了 $r(U)$ 后唯一未确定的只有 $r(U) \in S$ 且 $n - m + 1 < |S| <= m$ 的 $U$ 的非空真子集 $S$，并且对这些集合的 $r(S)$ 的选取没有任何限制。

所以可以列出递推式 $f_n = \begin{cases}nf_{n - 1}\prod\limits_{i = \max(1, n - m + 2)}^{\min(n - 1, m)} i^{\tbinom{n - 1}{i - 1}} & n > 1 \\ 1 & n = 1 \end{cases}$。

直接预处理组合数求解时间复杂度 $O(nm)$。

考虑对于递推式里的每个 $i$ 计算 $i$ 的指数，发现其形式是组合数上指标前缀和，可以 $O(1)$ 计算，注意到此时需要计算组合数对 $mod - 1$ 取模的结果，事实上 $10^9 + 86 = 2 \times 3 \times 41 \times 59 \times 68899$，为五个小质数的乘积，使用 Lucas 计算后 CRT 合并即可，时间复杂度 $O(m \log{n}+n)$，可以通过本题。

---

## 作者：UniGravity (赞：0)

#### 子任务 4（$m=1$）

发现 $m=1$ 时实际上并没有对代表元的限制，因此对于长度为 $i$ 的 $n\choose i$ 个区间都可以任意取，答案为：

$$\prod_{i=1}^ni^{n\choose i}\bmod P$$

由于组合数可能很大，因此要对指数取模。根据费马小定理 $a^{p-1}\equiv1\pmod p$ 可知 $a^b\bmod P=a^{b\bmod(P-1)}\bmod P$。

$P-1=1000000086=2\times3\times41\times59\times68899$。由于每一项都很小，分别对每个质数使用 lucas 求解组合数然后 crt 合并即可。时间复杂度 $O(n\log n)$。

#### 子任务 1（$m=2$）

这个时候就需要我们对限制有更深刻的认识了。假设当前集合为 $U$（$n=|U|$），考虑钦定 $r(U)$ 后会带来什么：

发现对于任意集合 $S\subsetneqq U,r(U)\in S$，则有 $r(S)=r(U)$。因为集合的代表元只能选在集合内部，且 $S$ 一定会在某种划分方式内取到。

因此所有包含 $r(U)$ 的 $S$ 都被确定了。对于其它没有限制的点，发现刚好对应去掉 $r(U)$ 后 $n-1$ 的情况。对于 $n$ 的情况代表元共有 $n$ 种选择，因此答案为 $n!$。

#### 正解

考虑当 $m$ 变大时会发生什么。此时我们发现除了 $S\subsetneqq U,r(U)\in S$ 的限制外还有 $|S|\le n-m+1$，即当 $S$ 比较大时可能不存在划分方案。

此时又不好做了，设法拓展 $S$ 的范围。发现上面我们只是考虑了集合 $U$ 的限制。

当 $|S|>m$ 时，我们发现 $S$ 的限制也能派上用场。即 $T\subsetneqq S,r(S)\in T,|T|\le |S|-m+1$，则 $r(T)=r(S)$。再加入 $U$ 的限制，使 $r(U)\in T$（一定找得到 $|T|\ge 2$ 且满足条件的 $T$），那么 $r(T)=r(U)$。因此一定有 $r(S)=r(U)$。

剩下的情况当 $n-m+1<|S|\le m$ 时，不存在划分成 $m$ 段的方案或只存在划分成 $m$ 个单个元素的方案，都对答案没有限制。因此此时可以任意选择 $|S|$ 个代表元。答案贡献为：

$$n\prod_{i=n-m+2}^mi^{n-1\choose i-1}$$

解决了所有 $r(U)\in S$ 的集合后，剩下的集合转化到一个 $n-1$ 的子问题。且当 $n$ 小到 $n=m$ 时发现方案数相当于子任务 4 的情况。因此我们有答案：

$$\left(\prod_{k=m+1}^n k\prod_{i=k-m+2}^mi^{k-1\choose i-1}\right)\cdot\prod_{i=1}^mi^{m\choose i}$$

将底数相同的归到一起，有：

$$\left(\prod_{i=m+1}^ni\right)\left(\prod_{i=3}^mi^{\sum_{k=m}^{\min(n-1,i+m-3)}{k\choose i-1}}\right)\left(\prod_{i=1}^mi^{m\choose i}\right)$$

根据 $\sum_{i=0}^n{i\choose m}={n+1\choose m+1}$ 将上面的组合数求和合并：

$$\left(\prod_{i=m+1}^ni\right)\left(\prod_{i=3}^mi^{{\min(n,i+m-2)\choose i}-{m\choose i}}\right)\left(\prod_{i=1}^mi^{m\choose i}\right)$$

然后就可以使用子任务 4 的 lucas 和 crt 做了。时间复杂度 $O(n+m\log m)$。

#### 代码

注意特判 $m=1$ 的情况。

```cpp
const int P[]={2,3,41,59,68899},MOD=1000000087;
vector<int>fac[5],ifac[5];
il ll fpow(ll x,int n,int P){
    ll a=1;while(n){if(n&1)a=a*x%P;x=x*x%P,n>>=1;}return a;
}
il void init(int P,vector<int>&fac,vector<int>&ifac){
    fac.resize(P+1),ifac.resize(P+1);
    fac[0]=1;forto(i,1,P-1)fac[i]=1ll*fac[i-1]*i%P;
    ifac[P-1]=fpow(fac[P-1],P-2,P);forbk(i,P-1,1)ifac[i-1]=1ll*ifac[i]*i%P;
}
il ll C(int n,int m,int p){return m>n?0:(1ll*fac[p][n]*ifac[p][m]%P[p]*ifac[p][n-m]%P[p]);}
il ll lucas(int n,int m,int p){
    return m==0?1:(C(n%P[p],m%P[p],p)*lucas(n/P[p],m/P[p],p)%P[p]);
}
il ll C(int n,int m){
    int ans=0,P1=MOD-1;
    forv(i,5){
        ans+=1ll*lucas(n,m,i)*(P1/P[i])%P1*fpow(P1/P[i],P[i]-2,P[i])%P1,ans%=P1;
    }
    return ans;
}

signed main(){
    forv(i,5)init(P[i],fac[i],ifac[i]);
    int n=read(),m=read(),ans=1;
    if(m==1){
        forto(i,1,n)ans=ans*fpow(i,C(n,i),MOD)%MOD;
    }else{
        forto(i,1,m)ans=ans*fpow(i,C(m,i),MOD)%MOD;
        forto(i,m+1,n)ans=1ll*ans*i%MOD;
        forto(i,3,m)ans=ans*fpow(i,(C(min(n,i+m-2),i)-C(m,i)+(MOD-1))%(MOD-1),MOD)%MOD;
    }
    printf("%d\n",ans);
    return 0;
}
```

---


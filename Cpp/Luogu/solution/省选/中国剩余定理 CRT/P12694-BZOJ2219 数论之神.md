# BZOJ2219 数论之神

## 题目描述

对于给定的 $3$ 个非负整数 $A,B,K$，求出满足：
- $X^A \equiv B \pmod{(2\times K + 1)}$ 
- $X$ 在范围 $[0, 2K]$ 内

的 $X$ 的个数。

## 样例 #1

### 输入

```
3
213 46290770 80175784
3 46290770 80175784
3333 46290770 80175784
```

### 输出

```
27
27
297```

# 题解

## 作者：Purslane (赞：9)

# Solution

也就是求 $x^a \equiv b \pmod n$ 的解的个数，其中 $n$ 是**奇数**。

-------

先考虑这样一个问题：对于**奇质数** $p$，求解 $x^a \equiv b \pmod {p^k}$。如果会做这个，就可以把 $n$ 进行质因数分解，然后把解数乘起来即可。

根据著名定理（经常学 MO 的同学都知道，这个其实并不好证，需要用到一大串引理），$p^k$ 必存在原根 $g$。

当 $\gcd(b,p)=1$ 的时候，显然 $\gcd(x,p)=1$，设 $x \equiv g^s$，且 $b \equiv g^t$，则 $sa \equiv t \pmod {\varphi(p^k)}$。这个解的个数为：

$$
\left\{
\begin{matrix}
\gcd(a,\varphi(p^k))&, \text{if } \gcd(a,\varphi(p^k)) \mid t \\
0 &,\text{otherwise}
\end{matrix}
\right.
$$

否则，考虑 $v_p(b)$（表示 $b$ 中质因子的个数），则 $b=p^{v_p(b)}B$。

当 $k \le v_p(b)$ 的时候，保证 $a v_p(x) \ge k$ 即可；否则，应当由 $a \mid v_p(b)$，得到 $v_p(x) = \frac{v_p(b)}{a}=s$。这样设 $x = p^s \cdot x'$，有 $p^{v_p(b)} (x')^a \equiv p^{v_p(b)} B \pmod {p^k}$。则 $(x')^a \equiv B \pmod {p^{k-v_p(b)}}$。不过这样解出来的 $x' < p^{k-v_p(b)}$，而实际上 $x' < p^{k-s}$，所以你的解数还得乘上 $p^{v_p(b)-s}$。

-----

然后是实现问题。NOI 中能用到的同余数论的板子几乎在这里凑齐了：

1. $\rm BSGS$，用来求解**离散对数**。
2. 质因数分解算法，用来将 $n$ 进行质因数分解，计算 $\varphi$，以及进行试除。
3. 计算阶（使用试除法）。
4. 快速幂。
5. 计算原根。（有结论（超出初等数论范畴）：$n$ 如果存在原根，则一定存在一个 $O(n^{0.25+\epsilon})$ 范围内的原根。所以可以直接枚举）
6. $\gcd$ 的计算，以及 $\rm ExGCD$ 算法。
7. $\rm ExCRT$（如果你需要求出一个解。不过本题不需要）

大家可以做这道题来进行 NOI 常见数论模板的复习。一个参考代码：

```cpp
#include<bits/stdc++.h>
#define int long long 
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
int T,a,b,k;
vector<pair<int,int>> fractor_divide(int n) {
	vector<pair<int,int>> ans;
	ffor(i,2,n/i) if(n%i==0) {
		int cnt=0;
		while(n%i==0) cnt++,n/=i;	
		ans.push_back({i,cnt});
	}
	if(n!=1) ans.push_back({n,1});
	return ans;
}
int calc_phi(int n) {
	int ans=n;	
	ffor(i,2,n/i) if(n%i==0) {
		int cnt=0;
		while(n%i==0) cnt++,n/=i;
		ans=ans/i*(i-1);
	}
	if(n!=1) ans=ans/n*(n-1);
	return ans;
}
pair<int,int> exgcd(int a,int b) {
	if(!b) return {1,0};
	auto pr=exgcd(b,a%b);
	return {pr.second,pr.first-a/b*pr.second};
}
int calc_inv(int x,int mod) {
	return (exgcd(x,mod).first%mod+mod)%mod;
}
int qpow(int base,int p,int mod) {
	int ans=1;
	while(p) {
		if(p&1) ans=ans*base%mod;
		base=base*base%mod,p>>=1;	
	}
	return ans;
}
int check(int v,int n,vector<int>& p,int phi) {
	for(auto id:p) if(qpow(v,phi/id,n)==1) return 0;
	return 1;
}
int get_root(int n) {
	int phi=calc_phi(n);
	auto vc=fractor_divide(phi);
	vector<int> p;
	for(auto pr:vc) p.push_back(pr.first);
	ffor(i,2,n) if(check(i,n,p,phi)) return i;
}
int get_log(int g,int v,int n) {
	unordered_map<int,int> mp;
	int tmp=1,B=sqrt(n);
	ffor(i,0,B-1) {
		if(tmp==v) return i;
		mp[tmp]=i,tmp=tmp*g%n;	
	}
	int inv=calc_inv(tmp,n);
	tmp=1;
	ffor(i,0,B+1) {
		if(mp.count(v*tmp%n)) return i*B+mp[v*tmp%n];
		tmp=tmp*inv%n;	
	}
	return -1;
}
int calc(int a,int b,int p,int k) {
	int n=1;
	ffor(i,1,k) n=n*p;
	b%=n;
	if(b%n==0) {
		int ans=1,tmp=n;
		ffor(j,1,k-1) {
			tmp/=p;
			if(a*j>=k) ans+=tmp/p*(p-1);
		}
		return ans;
	}
	if(b%p==0) {
		int vp=0,B=b;
		while(B%p==0) vp++,B/=p;
		if(vp%a) return 0;
		int mul=1;
		ffor(i,1,vp-vp/a) mul=mul*p;
		return calc(a,B,p,k-vp)*mul;	
	}
	int g=get_root(n),phi=calc_phi(n);
	int t=get_log(g,b,n);
	if(t%__gcd(a,phi)) return 0;
	return __gcd(a,phi);
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>T;
	while(T--) {
		cin>>a>>b>>k;
		int ans=1;
		auto vc=fractor_divide(2*k+1);
		for(auto pr:vc) ans=ans*calc(a,b,pr.first,pr.second);
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：Mirasycle (赞：3)

令 $P=2\times k+1$，题目即求 $x^a\equiv b\pmod P$ 在 $[0,P)$ 之内解的个数。

首先，我们并不擅长做普通情况模数，于是将 $P=\prod p_i^{c_i}$ 进行质因数分解。然后对于每个 $i$ 求解 $x^a\equiv b\pmod {p_i^{c_i}}$ 在 $[0,p_i^{c_i})$ 中解的个数，根据 CRT 相关的理论，我们可以将解的个数乘在一起得到最后总的解的个数。

$a$ 在指数也不好处理，由于 $p^k$ 存在原根所以我们可以使用原根 $g$ 转化为对于指数的讨论。

但是当 $a,b$ 与 $p^k$ 不互质的时候，不能直接取原根。需要分类讨论。

- $\gcd(b,p^k)=1$

此时我们可以得到 $\gcd(a,p^k)=1$。 

令 $x=g^c,b=g^d$，可以得到 $g^{ca}\equiv g^{d}\pmod {p^k}$。这个时候指数就在模阶的意义下相等了，同时由于 $g$ 是原根，所以就是在模 $\varphi(p^k)$ 的意义下相等了。

上述同余式可以直接改写为 $ca\equiv d\pmod {\varphi(p^k)}$。根据裴蜀定理，有解的充要条件是 $\gcd(a,\varphi(p^k)) \mid d$。如果有解，那么 $c\in[0,\varphi(p^k))$ 的解的个数为 $\gcd(a,\varphi(p^k))$。

- $p^k\mid b$

这种情况非常简单，可以直接得到 $x^a\equiv 0\pmod {p^k}$。设 $x$ 中 $p$ 的幂次为 $w$，那么有 $w\ge \lceil\dfrac{k}{a}\rceil$。由于 $p^{w_{\min}}\mid x$，所以 $x$ 的取值有 $p^{k-\lceil\frac{k}{a}\rceil}$ 种。

- $v_p(b)<k$

记 $w=v_p(b)$，可以使用同余式的除法。由于同余的性质，有 $\gcd(x^a,p^k)=\gcd(b,p^k)=p^w$，在等式两边都除以 $p^w$ 可以得到 $\dfrac{x^a}{p^w}\equiv \dfrac{b}{p^w} \pmod {p^{k-w}}$。由于 $\gcd(x^a,p^k)=p^w$，所以 $a\mid w$，故上式可以改写为 $(\dfrac{x}{p^{\frac{w}{a}}})^a\equiv \dfrac{b}{p^w}\pmod {p^{k-w}}$，这个时候满足互质性质，可以直接用第一种情况里面的方法求解答案。注意由于我们把值域缩小成了原先的 $\dfrac{1}{p^{w-\frac{w}{a}}}$，所以最后的答案还要乘以 $p^{w-\frac{w}{a}}$。别忘记那个 $-\frac{w}{a}$，因为括号内部的 $x$ 除以了 $p^{\frac{w}{a}}$。


```cpp
#include<bits/stdc++.h>
#define pb emplace_back
#define fi first
#define se second
#define mp make_pair
using namespace std;
typedef long long ll;
const int lim=1e9+2;
void cmax(int &x,int y){ x=x>y?x:y; }
void cmin(int &x,int y){ x=x<y?x:y; }
vector<pair<int,int> > vec,vec2;
int a,b,K,n,g,phi; unordered_map<int,int> S;
int qpow(int x,int k,int p){
	int res=1;
	for(;k;k>>=1){
		if(k&1) res=1ll*res*x%p;
		x=1ll*x*x%p;
	}
	return res;
}
int BSGS(int a,int b,int p){
	int B=ceil(sqrt((double)p)); S.clear();
	for(int i=0,r=b;i<=B;i++,r=1ll*r*a%p) S[r]=i;
	int z=qpow(a,B,p);
	for(int i=1,r=z;i<=B;i++,r=1ll*r*z%p)
		if(S.find(r)!=S.end()) return i*B-S[r];
	return -1;
}
vector<pair<int,int> > get(int m){
	vector<pair<int,int> > v; 
	for(int p=2;1ll*p*p<=m;p++){
		if(m%p) continue;
		int c=0; while(m%p==0) c++,m/=p;
		v.pb(p,c);
	}
	if(m>1) v.pb(m,1); return v;
}
int getphi(int x){
	int res=x;
	for(int i=2;1ll*i*i<=x;i++){
		if(x%i) continue;
		res=res/i*(i-1);
		while(x%i==0) x/=i;
	}
	if(x>1) res=1ll*res/x*(x-1);
	return res;
}
int getg(int x){
	phi=getphi(x); vec2=get(phi);
	for(int i=2;i<=x;i++){
		bool flag=1;
		for(auto v:vec2)
			if(qpow(i,phi/v.fi,x)==1) flag=0;
		if(flag) return i;
	}
	assert(0); return -1;
}
int F(int A,int B,int p,int k){
	int num=qpow(p,k,lim),g=getg(num); phi=getphi(num);
	int d=BSGS(g,B,num);
	//c*a equiv d mod phi(p^k)
	if(d%__gcd(A,phi)) return 0;
	return __gcd(A,phi);
}
int calc(int p,int k){
	if(__gcd(b,p)==1) return F(a,b,p,k);
	int vp=0,B=b; while(B%p==0) vp++,B/=p;
	if(vp>=k) return qpow(p,k-(k+a-1)/a,lim);
	int z1=qpow(p,vp,lim),z2=qpow(p,vp-vp/a,lim);
	return F(a,b/z1,p,k-vp)*z2;
}
void solve(){
	cin>>a>>b>>K; n=2*K+1; 
	vec=get(n); int ans=1;
	for(auto z:vec) ans=ans*calc(z.fi,z.se);
	cout<<ans<<endl; 
}
int main(){
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	int T; cin>>T;
	while(T--) solve();
	return 0;
}
```

---


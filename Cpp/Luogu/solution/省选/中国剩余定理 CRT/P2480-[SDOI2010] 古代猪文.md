# [SDOI2010] 古代猪文

## 题目背景

“在那山的那边海的那边有一群小肥猪。他们活泼又聪明，他们调皮又灵敏。他们自由自在生活在那绿色的大草坪，他们善良勇敢相互都关心……”

——选自猪王国民歌

很久很久以前，在山的那边海的那边的某片风水宝地曾经存在过一个猪王国。猪王国地理位置偏僻，实施的是适应当时社会的自给自足的庄园经济，很少与外界联系，商贸活动就更少了。因此也很少有其他动物知道这样一个王国。

猪王国虽然不大，但是土地肥沃，屋舍俨然。如果一定要拿什么与之相比的话，那就只能是东晋陶渊明笔下的大家想象中的桃花源了。猪王勤政爱民，猪民安居乐业，邻里和睦相处，国家秩序井然，经济欣欣向荣，社会和谐稳定。和谐的社会带给猪民们对工作火红的热情和对未来的粉色的憧憬。

小猪 iPig 是猪王国的一个很普通的公民。小猪今年 10 岁了，在大肥猪学校上小学三年级。和大多数猪一样，他不是很聪明，因此经常遇到很多或者稀奇古怪或者旁人看来轻而易举的事情令他大伤脑筋。小猪后来参加了全猪信息学奥林匹克竞赛（Pig Olympiad in Informatics，POI），取得了不错的名次，最终保送进入了猪王国大学（Pig Kingdom University，PKU）深造。

现在的小猪已经能用计算机解决简单的问题了，比如能用 P++ 语言编写程序计算出 $A + B$ 的值。这个“成就”已经成为了他津津乐道的话题。当然，不明真相的同学们也开始对他刮目相看啦~

小猪的故事就将从此展开，伴随大家两天时间，希望大家能够喜欢小猪。

## 题目描述

猪王国的文明源远流长，博大精深。

iPig 在大肥猪学校图书馆中查阅资料，得知远古时期猪文文字总个数为 $n$。当然，一种语言如果字数很多，字典也相应会很大。当时的猪王国国王考虑到如果修一本字典，规模有可能远远超过康熙字典，花费的猪力、物力将难以估量。故考虑再三没有进行这一项劳猪伤财之举。当然，猪王国的文字后来随着历史变迁逐渐进行了简化，去掉了一些不常用的字。

iPig 打算研究古时某个朝代的猪文文字。根据相关文献记载，那个朝代流传的猪文文字恰好为远古时期的 $1/k$，其中 $k$ 是 $n$ 的一个正约数（可以是 $1$ 或 $n$）。不过具体是哪 $1/k$，以及 $k$ 是多少，由于历史过于久远，已经无从考证了。

iPig 觉得只要符合文献，每一种 $k|n$ 都是有可能的。他打算考虑到所有可能的 $k$。显然当 $k$ 等于某个定值时，该朝的猪文文字个数为 $n/k$。然而从 $n$ 个文字中保留下 $n/k$ 个的情况也是相当多的。iPig 预计，如果所有可能的 $k$ 的所有情况数加起来为 $p$ 的话，那么他研究古代文字的代价将会是 $g^p$。

现在他想知道猪王国研究古代文字的代价是多少。由于 iPig 觉得这个数字可能是天文数字，所以你只需要告诉他答案除以 $999911659$ 的余数就可以了。

## 说明/提示

#### 数据规模与约定
- 对于 $10\%$ 的数据，$1\le n \le 50$；  
- 对于 $20\%$ 的数据，$1\le n \le 1000$；  
- 对于 $40\%$ 的数据，$1\le n \le 10^5$；  
- 对于 $100\%$ 的数据，$1\le n,g \le 10^9$。

## 样例 #1

### 输入

```
4 2```

### 输出

```
2048```

# 题解

## 作者：Owen_codeisking (赞：130)

刚刚一看这题，感觉很水，结果一直$95$分……没有特判，$GG$

题目大意：求$G^{\sum{d|n\ C_n^d}}\ mod\ 999911659$

思路与其他题解相像，考虑到$999911659$是质数，那么就用欧拉定理的推论得：

$$G^{\sum{d|n\ C_n^d}}\ mod\ 999911659=G^{\sum{d|n\ C_n^d\ mod\ 999911658}}\ mod\ 999911659$$

那么关键计算$\sum{d|n\ C_n^d}\ mod\ 999911658$.直接$Lucas$绝对挂，那么尝试把模数缩小再合并

将$999911658$因数分解，可得$999911658=2\times 3\times 4679\times 35617$.那么把模数缩小，枚举$n$的因数$d$，然后运用$Lucas$定理把$C_n^d$算出来，分别计算出$\sum{d|n\ C_n^d}$对$2,3,4679,35617$四个质数取模的结果，记为$a_1,a_2,a_3,a_4$.

最后，用中国剩余定理求解一下方程组：

![](https://cdn.luogu.com.cn/upload/pic/33545.png)

然后就得到了最小的非负整数解$x$，之后用快速幂求一下$G^x$就得到答案

中间的图片是我$latex$不会打用$windows$自带$mip$截图的，有个水印~~懒得找图床~~

顺带说一句，欧拉定理$a^b\equiv m(mod\ p)$，当且仅当$(a,p)=1$

$upd:2019.06.19$

开头那句是我那时一时中二写上去的……不要在意

我感觉当时还没有讲清楚，$Lucas$ 的复杂度是 $O(p\log_p n)$，所以缩小模数降下时间就可以了。

$Code\ Below:$
```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int mod=999911658;
LL n,G,farc[50010],a[5],b[5]={0,2,3,4679,35617},val;

LL fast_pow(LL a,LL b,LL p)//快速幂
{
	LL ret=1;
	for(;b;b>>=1,a=a*a%p)
		ret=ret*(b&1?a:1)%p;
	return ret;
}

void init(LL p)//预处理
{
	farc[0]=1;
	for(LL i=1;i<=p;i++)
		farc[i]=farc[i-1]*i%p;
}

LL C(LL n,LL m,LL p)//组合数
{
	if(n<m) return 0;
	return farc[n]*fast_pow(farc[m],p-2,p)%p*fast_pow(farc[n-m],p-2,p)%p;
}

LL Lucas(LL n,LL m,LL p)//Lucas定理
{
	if(n<m) return 0;if(!n) return 1;
	return Lucas(n/p,m/p,p)*C(n%p,m%p,p)%p;
}

void CRT()//中国剩余定理
{
	for(LL i=1;i<=4;i++)
		val=(val+a[i]*(mod/b[i])%mod*fast_pow(mod/b[i],b[i]-2,b[i]))%mod;
}

int main()
{
	scanf("%lld%lld",&n,&G);
	if(G%(mod+1)==0){
		printf("0\n");
		return 0;
	}//特判
	for(LL k=1;k<=4;k++){
		init(b[k]);
		for(LL i=1;i*i<=n;i++){
			if(n%i==0){
				a[k]=(a[k]+Lucas(n,i,b[k]))%b[k];
				if(i*i!=n){
					a[k]=(a[k]+Lucas(n,n/i,b[k]))%b[k];
				}
			}
		}
	}//逐一枚举n的约数
	CRT();
	printf("%lld\n",fast_pow(G,val,mod+1));//注意mod要+1
	return 0;
}
```

---

## 作者：Notshgiook (赞：105)

# 这是一道数论全家桶！！
前言：这是一道十分有趣的数论题！！可以说是基础数论全家桶！！

虽然钟长者说，见到输入几个数，输出一个数，应该果断选择一种古老而又优秀的算法——打表！！！但是还是果断的去莽这个题

内置数论知识：欧拉-费马定理，$Lucas$定理，中国剩余定理$(CRT)$。这可真是一道“优美”基础数论全家桶！！！！

## 话不多说，现在开始 ~~口胡~~ $ta!\ !\ !$
当然这题面又臭又长，显然需要把题面化简一下子啦！！！

存在一个整数$N$，对于每一个约数$d$，$(d|N$或$N\ mod\ d=0)$，求$C^{d}_{n}\ mod\ \ 999911659$。

最终的答案就是：
$$G^{\sum_{d|n}{C^{d}_{n}}}mod\ 999911659$$

首先检验一下$999911659$是一个质数，并没有什么问题！！

盲猜这个指数非常大，所以不如先来考虑一波欧拉定理！


------------

------------
### 欧拉定理

当$∀a,m\in \mathbb{Z}$且$gcd(a,m)=1$，$a^{\varphi(m)}\equiv1\ (mod\ m)$

这里的$\varphi(m)$，是数论下的欧拉函数。即$\varphi(m)=\sum^{m-1}_{i=1}{gcd(i,m)=1}$。显然当$m$是一个质数时，$\varphi(m)=m-1$。

$∀a,m\in \mathbb{Z}$且$gcd(a,m)=1$，$a^b\equiv a^{b\ mod\ \varphi(m)}\ (mod\ m)$

欧拉定理的正确性，弱弱的本人也不会，还请各位爷去问“无所不知无所不能”的度娘！！

$Emm$，当然了，欧拉定理的推论为：

$$a^b\equiv
\begin{cases}
a^{b\ mod\ \varphi(m)}&gcd(a,m)=1\\

a^b&b<\varphi(m)\\

a^{b\ mod\ \varphi(m)+\varphi(m)}&b\geq \varphi(m)
\end{cases}\ (mod\ m)$$

证明这种东西当然还得依靠度娘了！！！

而**费马小定理**是欧拉定理的一个推论，$∀a,m\in \mathbb{Z}$且$gcd(a,m)=1$且$m\in Prime$，$a^{m-1}\equiv 1(mod\ m)$。

毕竟当$m\in Prime$时，$\varphi(m)=m-1$。那么根据欧拉定理，于是~~~嘤嘤嘤~~



------------

------------
我么不妨对原式$G^{\sum_{d|n}{C^{d}_{n}}}mod\ 999911659$采用一波欧拉定理。

可得到：
$$G^{\sum_{d|n}{C^{d}_{n}}}\equiv\ G^{\sum_{d|n}C^{d}_{n}\ mod\ 999911658}\ (mod\ 999911659)$$

那这样的话，我们现在要求的式子变成了$G^{\sum_{d|n}C^{d}_{n}\ mod\ 999911658}\ mod\ 999911659$。

很显然的一个步骤在这摆着，对于这个底数$G$和最终取模数$mod\ 999911659$，我们可以直接用费马小定理求出，那么关键步骤呈现在我们的眼前！！！

**求出：**$\sum_{d|n}{C^{d}_{n}\ mod\ 999911658}$！！！

首先$999911658$不是一个质数，暴力求组合数之后费马小定理肯定行不通！！

根据取模的性质，我们不妨进行一波下面的显然操作求：$\sum_{d|n}{(C^{d}_{n}\ mod\ 999911658)\ mod\ 999911658}$

废话，这太显然了！！！！

但是这样我们发现，我们的问题变成了一个组合数取模问题！！！

想想组合数取模能怎么做？？

**$Lucas$定理？？？**

$Lucas$定理需要模数是一个小质数，显然这里的$999911658$不是一个质数，更何况是小质数。

**扩展$Lucas$定理？？？**

似乎是可以的，但是好难好麻烦，还需要$Exgcd$和$ExCRT$！！！

**中国剩余定理$(CRT)$？？?**

我们先计算一波$999911658$的质因数！！$Emm$，很好$999911658=2\times3\times4697\times35617$四个，那么显然可用中国剩余定理！！

------------
------------
### 中国剩余定理

求解同于方程组

$$(S)\begin{cases}
x\equiv a_{1}&(mod\ m_{1})\\

x\equiv a_{2}&(mod\ m_{2})\\

x\equiv a_{3}&(mod\ m_{3})\\

 &\vdots\\
 
x\equiv a_{k}&(mod\ m_{k})\\

\end{cases}$$

其中$m_{1},m_{2},m_{3},\ldots\ \ldots,m_{k}$为两两互质的整数，求x的解。

**定理:**

令$M=\Pi^{k}_{i=1}{m_{i}}$，即$M$是所有$m_{i}$的最小公倍数。

设$M_{i}=M/m_{i}$，$∀\ i\in \{1,2,3,\ldots,k\}$是除了$m_{i}$以外的$n-1$个数的乘积。

设$t_{i}$为$M_{i}$模$m_{i}$意义下的逆元。即$M_{i}t_{i}\equiv1\ (mod\ m_{i}),∀\ i\in \{1,2,3,\ldots,k\}$。

那么方程组$(S)$的通解形式为：

$x=a_{1}t_{1}M_{1}+a_{2}t_{2}M_{2}+a_{3}t_{3}M_{3}+\ldots+a_{k}t_{k}M_{k}+TM,T\in\mathbb{Z}$

即：$x=\sum^{n}_{i=1}{a_{i}t_{i}M_{i}}+TM,T\in\mathbb{Z}$

那么在模$M$的意义下，方程组$(S)$有且仅有一个解，即$x=(\sum_{i=1}^{n}{a_{i}t_{i}M_{i}})modM$

对于证明，本人太多，请各位神仙前往度娘！！

------------
------------
那么我们显然可以，将$\sum_{d|n}C^{d}_{n}$分别对$999911658$的四个质因数取模，构建同余方程组，求出在模通解$999911658$的通解$t$，那么$t=\sum_{d|n}C^{d}_{n}mod\ 999911658$。

最终答案即为：$G^{t}\ mod999911659$。

那么构建出来的同余方程组长什么样子呢？？？

$$(S)\begin{cases}
x\equiv \sum_{d|n}C^{d}_{n}&(mod\ 2)\\
x\equiv \sum_{d|n}C^{d}_{n}&(mod\ 3)\\
x\equiv \sum_{d|n}C^{d}_{n}&(mod\ 4679)\\
x\equiv \sum_{d|n}C^{d}_{n}&(mod\ 35617)\\
\end{cases}$$

当然对于每一个同余方程可以先用取模的性质化简化简！！！

在这里我们发现，对于每个组合数$C_{n}^{d}$取模的四个数$2,3,4679,35617$，都很小而且都是质数，那么我们可以采用$Lucas$定理来对组合数取模。

------------
------------
### $Lucas$定理

$C_{n}^{m}mod\ p=C^{m/p}_{n/p}\times C^{m\ mod\ p}_{n\ mod\ p}$

当且仅当$p$是一个小质数！！

弱弱的本人根本不会证明，还请各位大神询问度娘

------------
------------

中间还存在一些小细节，比如求组合数可用民间的提前预处理每个数的阶乘和每个数阶乘的逆元，然后每次求组合数变成了一次$O(1)$操作！！！

所以这篇鬼畜的古代猪文就能告一段落了，这可真是一道数论好题。费马-欧拉定理，$Lucas$定理，中国剩余定理。基本可以说，这是一道取模方面的数论全家桶！！！！

------------
------------
### $Code Below$
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
using namespace std;
#define Mod 999911659
#define mod 999911658
#define maxn 40005
typedef long long ll;
ll n,g;
ll d[maxn],tot;
ll p[10],cnt;

inline ll qpow(ll a,ll k,ll p)
{
	ll res=1;
	while(k)
	{
		if(k&1) res=(res*a)%p;
		a=(a*a)%p;
		k>>=1;
	}
	return res%p;
}

ll fac[maxn],inv[maxn];
inline void init(ll p)
{
	fac[0]=1;
	for(register int i=1;i<p;i++)
		fac[i]=fac[i-1]*i%p;
	inv[p]=0;
	inv[p-1]=qpow(fac[p-1],p-2,p);
	for(register int i=p-2;i>=0;i--)
		inv[i]=inv[i+1]*(i+1)%p;
}

inline ll C(ll n,ll m,ll p)
{
	if(m>n) return 0;
	return fac[n]*inv[m]%p*inv[n-m]%p;
}

inline ll Lucas(ll n,ll m,ll p)
{
	if(m==0) return 1;
	return Lucas(n/p,m/p,p)*C(n%p,m%p,p)%p;
}

ll a[10];
inline void calc(int x)
{
	init(p[x]);
	for(register int i=1;i<=tot;i++)
		a[x]=(a[x]+Lucas(n,d[i],p[x]))%p[x];
}

inline ll CRT()
{
	ll ans=0;
	for(register int i=1;i<=cnt;i++)
	{
		ll M=mod/p[i],t=qpow(M,p[i]-2,p[i]);
		ans=(ans+a[i]%mod*t%mod*M%mod)%mod;
	}
	return (ans+mod)%mod;
}

int main()
{
	scanf("%lld%lld",&n,&g);
	if(g%Mod==0)
	{
		printf("0\n");
		return 0;
	}
	ll t=mod;
	for(register int i=2;i*i<=mod;i++)
	{
		if(t%i==0)
		{
			p[++cnt]=i;
			while(t%i==0) t=t/i;
		}
	}
	if(t!=1) p[++cnt]=t;
	for(register int i=1;i*i<=n;i++)
	{
		if(n%i==0)
		{
			d[++tot]=i;
			if(i*i!=n) d[++tot]=n/i;
		}
	}
	for(register int i=1;i<=cnt;i++) calc(i);
	printf("%lld",qpow(g,CRT(),Mod));
	return 0;
}
```


---

## 作者：天泽龟 (赞：27)

### 一个数论没学到1个月的蒟蒻在经过题解的帮助下能A了这道综合性很强的题，感到十分荣幸_(:з」∠)
此题有哪些数论的应用其他题解已经十分完备了，这里我就给大家讲讲做这道题的**一些思路**以及**一些板子在洛谷很少见的一些写法**。

---
- ## 题意

推出真正式子的描述就两段

	...根据相关文献记载，那个朝代流传的猪文文字恰好为远古时期的k分之一，其中k是N的一个正约数（可以是1和N）。...
    
	...他打算考虑到所有可能的k。...。然而从N个文字中保留下N / k个的情况也是相当多的。
    ...可能的k的所有情况数加起来为P的话，那么他研究古代文字的代价将会是G的P次方。
    
其中，只要通过**K是N的正约数**，**从N个文字中保留下N / k个的情况也是相当多的**以及**G的P次方**，这三句话就可直接分析出表达式（为了方便，设P=999911659）：
### $G^{\sum \limits_{k|N}*C_N^k}$ $≡ans$ $(mod$ $P)$。

感觉这一步还是挺基础的？~~毕竟我这种蒟蒻也能看出来_(:з」∠)~~

---
推出以上式子后就有点懵逼了：这个G的指数是啥玩意？？那就肯定要在指数上面做文章了。

指数，指数，……，涉及到指数的数论定理好像本蒟蒻只学过**欧拉定理**了_(:з」∠)

### 一看模数是指数，就是**费马小定理**没得跑了！
对于那个模数，列出费马小定理的式子：
### $G^{p-1}$ $≡1$ $(mod$ $P)$。
可见上式每多一个$p-1$，就可以通过下面的式子直接约掉，于是式子就被我们简化成这样：
### $G^{\sum \limits_{k|N}*C_N^k mod P-1}$ $≡ans$ $(mod$ $P)$。
等价于求：
### ${\sum \limits_{k|N}*C_N^k}$ $mod$ $(p-1)$.



### 由于K是N的正约数，可以在$LOG(N)$时间内求出来，那只需要对于任意的K求$C_N^k$ $mod(p-1)$就好了

---

看来我们已经很接近正解了呢！_(:з」∠)

那我们可以用Lucas
……

……

诶诶诶p-1好像**不是质数**啊！！卢卡斯是要在质数下才能用的_(:з」∠)

虽说有扩展卢卡斯不要求是素数但是蒟蒻不会啊（会的大佬可以试试_(:з」∠)）

完蛋，投降，只能滚去摸一眼题解了。。。

。。。
我们在摸了题解后得到了正解：

### **拆分p-1成4个质数，对于每一个质数求组合数（当然还是LUCAS）列出一个同余方程，在把这些式子联立起来用一个中国剩余定理就可以求出来组合数mod p-1了_(:з」∠)**

蒟蒻在得到了这个宝贵的提示后就打出了普通的中国剩余定理（题解里的好像都是扩展剩余定理！？），然后~~疯狂DEBUG了1小时~~就过了，思路大概就是这样_(:з」∠)。

---

其中对于求组合数，民间一直流传着一种**O(N)预处理，O(1)查询**的做法：

- 先求出模p意义下的阶乘，逆元以及逆元阶乘（因为求逆元满足积性函数）。
- 对于任意一个小于p的组合数$C_m^n$，可以直接用$jc[m]*invjc[n]*invjv[m-n]$求出，其中$jc[i]$指到i的阶乘,$invjc[i]$指到i的阶乘逆元，对于LUCAS定理在合适不过了(:з」∠)_

其次求中国剩余定理真的不用像题解里面用扩展的，因为对于4个模数都是p-1的质因数啊！

而且普通的中国剩余定理思路清楚代码量也少，考试的时候肯定打普通的啊！（当然我也说了是在考试的时候，平时刷题写个扩展练练手也是挺好的_(:з」∠)）

具体的见丑陋的代码_(:з」∠)：

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#define ll long long
using namespace std;
const ll p=999911659;
ll pri[6]={999911658,2,3,4679,35617};
ll n,g,k=0,ans=0,x[5],jc[200000][5],ninv[200000][5],inv[200000][50],a,b; 

ll ksm(ll x,ll k,ll p)  //最后算答案，也可以用来求逆元 
{
	ll ans=1;
	while (k)
	{
		if (k%2) ans=ans*x%p;
		k/=2; x=x*x%p;
	}
	return ans%p;
}

void exgcd(int x,int y) //求逆元，其实ksm也可以 
{
    if (!y) 
    {
        a=1; b=0; return;
    }
    exgcd(y,x%y);
    int kk=a; a=b; b=kk-(x/y)*b;
}

ll c(ll n,ll m,int i)
{
	int pp=pri[i];
	if (n==m||n==0) return 1;
	if (n>m||m==0) return 0;
	return jc[m][i]*ninv[n][i]*ninv[m-n][i]%pp; //O(1)查询组合数 
}

ll lucas(ll d,ll n,int i)  //LUCAS 
{
	ll pp=pri[i];
	if (n<pp) return c(d,n,i)%pp;
	else return (lucas(d/pp,n/pp,i)*lucas(d%pp,n%pp,i)%pp);
}

ll find(ll d) //对于每个约数求同余方程及中国剩余定理 
{
	memset(x,0,sizeof(x));
	ll ans=0,div=0;
	for (int i=1;i<=4;i++) x[i]=lucas(d,n,i)%pri[0];
//	for (int i=1;i<=4;i++) cout<<x[i]<<" "; 
	for (int i=1;i<=4;i++) 
	{
	div=pri[0]/pri[i];
	exgcd(div,pri[i]); a=(a%pri[i]+pri[i])%pri[i];
//		cout<<div<<" "<<a<<" "<<a*div%pri[0]<<endl;
	ans=(ans+x[i]*div*a)%pri[0];
	}
//	cout<<ans<<" "<<d<<endl;
	return ans%pri[0];
}

int main()
{
    cin>>n>>g;
    for (int i=1;i<=4;i++)
    {	jc[0][i]=inv[1][i]=inv[0][i]=ninv[0][i]=ninv[1][i]=1; ll pp=pri[i];
        for (int j=1;j<pri[i];j++) jc[j][i]=jc[j-1][i]*j%pp;
        for (int j=2;j<pri[i];j++) inv[j][i]=((-pp/j*inv[pp%j][i])%pp+pp)%pp,
        ninv[j][i]=inv[j][i]*ninv[j-1][i]%pp;
    }//O(n)预处理逆元啥的
	for (int i=1;i<=sqrt(n);i++)  
    if (n%i==0) {
//		cout<<i<<" "<<n/i<<":"<<endl;
        k=k%pri[0]+find(i)%pri[0];
        if (i*i!=n) k=k%pri[0]+find(n/i)%pri[0];

    }
//		cout<<k<<endl;
    cout<<ksm(g,k,p)<<endl;
    return 0;
}
```

数论还有很多要学，但蒟蒻最近不想搞数论了_(:з」∠)，如果有问题欢迎提出。

---

## 作者：Saliеri (赞：15)

$\operatorname{I}\quad \quad\ \ $写在前面

刚学数论3天，经此一全家桶~~深感恶心~~神清气爽，于是决定写这篇题解的同时，权当是我对简单数论的理解~~记忆力堪忧~~。

若有证明或书写错误错误，敬请斧正，蒟蒻将不胜感激。

因为作者是数论菜鸟，一惊一乍请大佬见谅。

$\operatorname{II}\quad \quad$前置芝士

[欧拉定理](https://baike.baidu.com/item/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/891345?fr=aladdin#2)
（$or$ [费马小定理](https://baike.baidu.com/item/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86)），[中国剩余定理](https://baike.baidu.com/item/%E5%AD%99%E5%AD%90%E5%AE%9A%E7%90%86?fromtitle=%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86&fromid=11200132)，[卢卡斯定理](https://baike.baidu.com/item/lucas/4326261)。

证明：下转$\operatorname{V}$区。

$\operatorname{III}\quad \quad$题解

___
$\operatorname{Tips}$:如果有看不懂的定理或步骤，请移步证明区或评论区。
___
题目极其冗长，去其糟粕~~几乎全是糟粕~~之后：

- 远古时期猪文文字总个数为 $n$。

- 那个朝代流传的猪文文字恰好为远古时期的 $\frac{1}{k}$，其中 $k$ 是 $n$ 的一个正约数（可以是 $1\ $或 $n$）。（枚举约数）

- 然而从 $n$ 个文字中保留下 $\frac{n}{k}$ 个的情况也是相当多的。(即组合数)

- 所有可能的 $k$ 的所有情况数加起来为 $p$ 的话，那么他研究古代文字的代价将会是 $g^p$。

可以得到题目真正需要求的柿子（枚举$n/d$与$d$是一样的，也为了好看）：

$$g^{\sum \limits_{d|n} \operatorname{C}_n^{d}} \operatorname{mod} 9999111659$$

$\operatorname{Case\ 1}:$当 $\quad \color{red}{999911659|g}\quad$时,$\operatorname{Ans}=0$;(一定要判！)

$\operatorname{Case\ 2}:$

由欧拉定理,或费马小定理（999911659为质数）:

$$=g^{\sum \limits_{d|n} \operatorname{C}_n^{d} \operatorname{mod}999911658} \operatorname{mod} 9999111659$$

即求：

$$\sum \limits_{d|n} \operatorname{C}_n^{d} \operatorname{mod}999911658$$

然后————好像没辙了。

题目所要求的组合数的$n,m$的数量级高达$10^9$,只有卢卡斯定理可担此重任，但是……

$999911658$不是质数（不考虑扩展卢卡斯），怎么办？

我们怀着忐忑的心情将$999911658$分解质因数：

$$999911658 = 2 \times3\times4679\times35617$$

只有一次项！

这说明我们可以对四个质因子分别求解。

问题又来了，如何合并答案？

这次很简单：因为四个模数两两互质~~毕竟都是质数~~，所以中国剩余定理即可。

于是，我们来理一下思路：

- 对四个模数分别求出$\sum \limits_{d|n} \operatorname{C}_n^{d} \operatorname{mod} p_i$的值分别为$ans_i$（其中组合数使用卢卡斯定理）。

- 用中国剩余定理求出线性同余方程组：

$\begin{cases}S \equiv ans_1(\operatorname{mod}p_1) \\S \equiv ans_2(\operatorname{mod}p_2) \\S \equiv ans_3(\operatorname{mod}p_3)\\
S \equiv ans_4(\operatorname{mod}p_4)\end{cases}$

的在$\left[0,999911658\right]$ 中的解。

- 快速幂求出$g^S \operatorname{mod} 999911659$

然后这题就做完了（好像也不是很难）。

$\operatorname{IV}\quad \quad$代码

```cpp
#include <cstdio>
#define int long long//记得开longlong <== Mod*mod > intmax! 
const int maxd = 36000,Mod = 999911659;
int N,g;
inline int ksm(int a,int x,int p) {//快速幂不解释 
	int ans = 1,base = a;
	while(x) {
		if(x & 1)ans = ans*base%p;
		base = base*base%p,x >>= 1;
	}
	return ans;
}
struct Lucas {
	int mod,pre[maxd],inv[maxd];//O(1)组合数准备：阶乘与阶乘逆元（逆元求法见注释） 
	inline void getpreinv() {
		pre[0] = inv[0] = 1;
		for(int i=1; i<=mod-1; ++i)pre[i] = pre[i-1]*i%mod;
		inv[mod-1] = ksm(pre[mod-1],mod-2,mod);//单个使用快速幂 
		for(int i=mod-2; i; --i)inv[i] = inv[i+1]*(i+1)%mod;
	}
	inline int C(int m,int n) {return m>n?0:pre[n]*inv[m]%mod*inv[n-m]%mod;}//C(m,n) = n!/m!(n-m)! = n!*inv[m!]*inv[(n-m)!] 
	inline int lucas(int m,int n) {
		if(m==0)return 1;
		return C(m%mod,n%mod)*lucas(m/mod,n/mod)%mod;
	}//Lucas定理 
} S[5];
int mod[] = {0,2,3,4679,35617},sum[5],M[5],Mp[5];
signed main() {
	scanf("%lld %lld",&N,&g);
	if(g == Mod){printf("0");return 0;}
	for(int i=1; i<=4; ++i)S[i].mod = mod[i],S[i].getpreinv();//组合数预处理 
	for(int i=1;i*i<=N;++i)//枚举约数统计答案 
		if(N%i == 0)
			for(int j=1;j<=4;++j){
				sum[j] = (sum[j]+S[j].lucas(i,N))%S[j].mod; 
				if(i*i!=N)sum[j] = (sum[j]+S[j].lucas(N/i,N))%S[j].mod;//如果i==n/i则只算一次！ 
			}
	for(int i=1;i<=4;++i)M[i] = (Mod-1)/S[i].mod,Mp[i] = ksm(M[i],S[i].mod-2,S[i].mod);
	long long S = 0;
	for(int i=1;i<=4;++i)S += (long long)(M[i]*Mp[i]*sum[i]);
	S = (S%(Mod-1)+Mod-1)%(Mod-1);//中国剩余定理求法见证明区 
	printf("%lld",ksm(g,S,Mod));
	return 0;
}
```
注释：

- 阶乘逆元求法：
 > - 快速幂得到$((mod-1)!)^{-1}$
 > - $\because \frac{1}{(i-1)!} = \frac{1}{i!} \times i$,所以所有阶乘逆元可以直接递推求出（具体见代码）

___
 
$\operatorname{V}\quad $ 证明

___
$\operatorname{i}\quad $ 欧拉定理

注：费马小定理是欧拉定理的特殊情况，所以只证欧拉。


**定义**：（为了更好懂，省去了一点严谨性，大佬轻喷）

- 同余类：所有除$m$余$i$的整数构成模$m$的一个同余类，记为$\overline{i}$.

- 完全剩余系（并不重要）：所有模m的同余类的集合。（即$\left\{\overline{0},\overline{1}\cdots\overline{m-1}\right\}$）

- **简化剩余系**:在$\overline0\cdots \overline {m-1}$这$m$个同余类中，**余数与$m$互质**的同余类构成模$m$的简化剩余系。由定义易知，模$m$的简化剩余系中共有$\varphi(m)$个同余类。（注：$0$不与$m$互质）。

**证明**：（运算都在模$m$意义下进行）

- 引理 ： 当$\operatorname{gcd}(a,m) = 1$时，对于任意$b_i \neq b_j $,有$a\cdot b_i \neq a\cdot b_j $

  - 证明：~~显然~~因为$\operatorname{gcd}(a,m) = 1$，所以在模$m$意义下一定存在$a$的逆元，两边同乘即证。
 
设模$m$的简化剩余系为$\{\overline{b_1}\cdots\overline{b_{\varphi(m)}}\}$,由引理知，各个$a\cdot b_i$两两不同，所以$\{\overline{a\cdot b_1}\cdots\overline{a\cdot b_{\varphi(m)}}\}$也构成模$m$的简化剩余系。

$\Rightarrow  b_1\cdot b_2 \cdots b_{\varphi(m)} \equiv (a\cdot b_1)\cdot (a\cdot b_2) \cdots (a\cdot b_{\varphi(m)}) \equiv a^{\varphi(m)}\cdot b_1\cdot b_2 \cdots b_{\varphi(m)}$ 

两边同乘$ b_1\cdot b_2 \cdots b_{\varphi(m)}$的逆元($\because \forall b_i,\operatorname{gcd}(b_i,m)=1$，即存在逆元)

$\Rightarrow a^{\varphi(m)} \equiv 1$

证毕。

注： 代入$m\in prime$则有$a^{m}\equiv a$,即费马小定理。

___

$\operatorname{ii}\quad $ 中国剩余定理

其实就是个构造……

我们有一个同余方程组，其中满足模数两两互质：

$
\begin{cases}S \equiv ans_1(\operatorname{mod}p_1) \\
\vdots\\
S \equiv ans_n(\operatorname{mod}p_n)\end{cases}
$

构造方案 ： 
- 我们令$M = \prod m_i,m'_i = M/m_i$。

- 构造$t_i$满足$m'_i\cdot t_i \equiv 1(\operatorname{mod}m_i)$

- 则同余方程组的一个特解为$\sum m'_it_ians_i$,在模$M$意义下的解即为最小正整数解。

构造正确性证明：

- $\forall i,m'_it_ians_i\equiv ans_i(\operatorname{mod} m_i)\Leftarrow m'_i\cdot t_i \equiv 1(\operatorname{mod}m_i)$

- 同时$\forall j \neq i,m'_jt_jans_j\equiv 0(\operatorname{mod} m_i) \Leftarrow m'_j\ \equiv 0(\operatorname{mod}m_i)$显然。

- $\therefore \forall i,\sum m'_it_ians_i \equiv ans_i(\operatorname{mod}m_i)$

实现 ： 

- 其中$t_i$即为$m'_i$的乘法逆元，具体求法$exgcd$或快速幂均可。

___

$\operatorname{iii}\quad $ 卢卡斯定理

太神了，虽然证明很初等，但是我不会……

[挂链接跑路](https://zhuanlan.zhihu.com/p/116698264)(讲的真的好)

___

$\operatorname{VI}\quad $ 结束

虽然本文章极其初等~~甚至有些ZZ~~，数论菜鸟恳请大家斧正，这会对我后来的学习起到很大帮助，谢谢！

求过




---

## 作者：potatoler (赞：8)

「数論~ 数論~ 数論~ 数論~ 数論大家族」

### 关于[本题](https://www.luogu.com.cn/problem/P2480)

这是一道数论大杂烩模法题，题目叙述极其冗长，真正有用的其实就只有两句话。题目压缩后可以表述为求

$\LARGE g^{\Sigma_{k|n}C^{\frac{n}{k}}_{n}}\bmod 999911659$

解答本题你需要至少会使用以下结论和定理：

- [欧拉定理推论](https://oi-wiki.org/math/fermat/)
- [中国剩余定理](https://oi-wiki.org/math/crt/)
- [Lucas定理](https://oi-wiki.org/math/lucas/)

本题中用到的部分还会在下文讲述。

### 本题中用到的结论与定理

#### 欧拉定理推论

欧拉定理内容为：若正整数 $a,n$ 互质，则有 $a^{\varphi(n)}\equiv 1(\bmod  n)$，其中 $\varphi(n)$ 为欧拉函数

我们在这道题中使用的是欧拉定理的推论：若正整数 $a,n$ 互质，则对于任意正整数 $b$ 有 $a^{b}\equiv a^{b\bmod\varphi(n)}(\bmod n)$.

可以简单地证明：设 $b=q*\varphi(n)+r,(0\le r\le \varphi(n))$，即 $r=b \bmod \varphi(n)$。于是有：

$\large a^{b} \equiv a^{q*\varphi(n)+r} \equiv (a^{\varphi(n)})^{q}*a^{r} \equiv 1^q*a^r \equiv a^r \equiv a^{b \bmod \varphi(n)}(\bmod n)$

其中第三步使用了欧拉定理。

#### 中国剩余定理

设 $m_1,m_2,...,m_n$ 是两两互素的整数，$m=\Pi^{n}_{i=1}m_i$，$M_i=\frac{m}{m_i}$，$t_i$ 是线性同余方程 $M_it_i \equiv 1(\bmod m_i)$ 的一个解。对于任意的 $n$ 个整数 $a_1,a_2,...,a_n$，方程组
$$
\begin{cases}x \equiv a_1(\bmod m_1)\\x \equiv a_2(\bmod m_2)\\...\\x \equiv a_n(\bmod m_n)\\\end{cases}
$$
有整数解，为 $\large x=\Sigma^n_{i=1}a_iM_it_i$.

由于鄙人太菜，无法证明，所以请各位大神出门左转 [OI Wiki](https://oi-wiki.org/math/crt/) $Q w Q$

#### Lucas 定理

若 $p$ 是素数，则对于任意整数 $1 \le m \le n$，有 $\large C^m_n \equiv C^{m \bmod p}_{n \bmod p}*C^{m/p}_{n/p}(\bmod p)$

原理是把 $n$ 和 $m$ 表示成 $p$ 进制数，对 $p$ 进制下每一位分别计算组合数，最后再乘起来。由于鄙人太菜，无法证明，所以请各位大神出门右转 [OI Wiki](https://oi-wiki.org/math/lucas/) $Q w Q$

### 思路

因为有 $k |n$，所以在求和时 $\frac{k}{n}$ 和 $k$ 都会被算到，原式中的 $C^{\frac{k}{n}}_{n}$ 可以变为 $C^k_n$，~~虽然并没有使式子变简单但是看起来更舒服~~。

根据欧拉定理的推论有 $\large g^{\Sigma_{k|n}C^{k}_{n}}\equiv  g^{\Sigma_{k|n}C^{k}_{n}\bmod999911658}(\bmod 999911659)$，快速地写一个简单小程序，就可以判断出模数 999911659 是一个素数，所以右边的 $\varphi(999911659)=999911658$，于是，本题的关键在于 $ \Sigma_{k|n}C^{k}_{n}\bmod999911658$ 的计算。

聪敏的你一定会想到使用 Lucas 定理进行组合数取模计算，但是 Lucas 定理要求模数是一个小素数，显然我们现在的模数 999911658 并不是一个小素数——它甚至不是一个素数！还有一个 exLucas 定理仿佛可以使用，但是比较难，又会引入更多的结论和定理了。

若有正整数 $a,b$ 满足 $a \bmod b =r$ 且 $b=m*n$，那么一定有 $a \bmod m=a \bmod n=r$。这是显然的——根据题意,设 $a=q*b+r$，于是 $a=q*m*n+r$。根据这条结论，我们可以将模数 999911658 分解素因子，并使用中国剩余定理列出同余方程组。通过简单的函数可以分解模数为 $999911658=2*3*4679*35617$，于是有方程组：
$$
\begin{cases}x \equiv \Sigma_{k|n}C^{k}_{n}(\bmod 2)\\x \equiv \Sigma_{k|n}C^{k}_{n}(\bmod 3)\\x \equiv \Sigma_{k|n}C^{k}_{n}(\bmod 4679)\\x \equiv \Sigma_{k|n}C^{k}_{n}(\bmod 35617)\\\end{cases}
$$
如果可以解出 $x$，便有 $x=\Sigma_{k|n}C^{k}_{n}\bmod999911658$。对于其中的每一个线性同余方程，模数都变成了一个较小的素数，我们可以利用 Lucas 定理对组合数取模。由于题目中 $n$ 的范围比较大，所以我们可以预处理每个数的阶乘以及阶乘的逆元，于是就可以更快的求组合数了。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
typedef long long ll;
const int MaxN=500005, Mod=999911659;
ll n, g, k[MaxN];
ll factorial_of[MaxN], inverseofFctorial_of[MaxN];
ll singleLeft[5], primeFactor[5], primeCount, factorCount, finalPowerTimes;
inline ll QuickPower(ll baseNumber,ll powerTimes,ll mod){
	ll answer = 1;
	while(powerTimes){
		if(powerTimes & 1) answer = answer * baseNumber % mod;
		baseNumber = baseNumber * baseNumber % mod;
		powerTimes >>= 1;
	}
	return answer % mod;
}
inline void Init(ll mod){
	factorial_of[0] = 1;
	for(int i=1;i<mod;i++)
		factorial_of[i] = factorial_of[i-1] * i % mod;
	inverseofFctorial_of[mod] = 0;
	inverseofFctorial_of[mod - 1] = QuickPower(factorial_of[mod-1], mod - 2, mod);
	for(int i=mod-2;i>=0;i--)
		inverseofFctorial_of[i] = inverseofFctorial_of[i+1] * (i+1) % mod;
}
inline ll C(ll x,ll y,ll mod){
	if(y > x) return 0;
	return factorial_of[x] * inverseofFctorial_of[y] % mod * inverseofFctorial_of[x-y] % mod;
}
inline ll Lucas(ll x,ll y,ll mod){
	if(y == 0) return 1;
	return Lucas(x / mod, y / mod, mod) * C(x % mod, y % mod, mod) % mod;
}
inline ll SingleLineCalculation(int x){
	Init(primeFactor[x]);
	for(int i=1;i<=factorCount;i++)
		singleLeft[x] = (singleLeft[x] + Lucas(n, k[i], primeFactor[x])) % primeFactor[x];
}
inline ll CRT(){
	ll answer = 0, mod = Mod-1;
	for(int i=1;i<=primeCount;i++){
		ll M = mod / primeFactor[i], t = QuickPower(M, primeFactor[i]-2, primeFactor[i]);
		answer = (answer + (singleLeft[i] % mod) * (t % mod) * (M % mod)) % mod;
	}
	return (answer + mod) % mod;
}
inline void GetPrimeFactor(ll originalNumber){
	for(int i=2;i*i<=Mod-1;i++){
		if(originalNumber % i == 0){
			primeFactor[++primeCount] = i;
			while(originalNumber % i == 0) originalNumber /= i;
		}
	}
	if(originalNumber != 1) primeFactor[++primeCount] = originalNumber;
}
inline void GetK(){
	for(int i=1;i*i<=n;i++){
		if(n % i == 0){
			k[++factorCount] = i;
			if(i * i != n) k[++factorCount] = n / i;
		}
	}
}
int main(){
	scanf("%lld%lld", &n, &g);
	if(g % Mod == 0){
		printf("0");
		return 0;
	}//remember to add a special judge, or you will lose 5 pts
	GetPrimeFactor(Mod - 1);
	GetK();
	for(int i=1;i<=primeCount;i++) SingleLineCalculation(i);
	finalPowerTimes = CRT();
	printf("%lld", QuickPower(g, finalPowerTimes, Mod));
	return 0;
}
```



---

## 作者：XG_Zepto (赞：8)

### 思路
观察题目，不难发现，我们需要在给定$G$,$N$的情况下，求

$G^{\sum_{i|N}C_N^i} \ mod \ 999911659$

的值。所以，我们只需要求出$G$的幂的值就可以进行计算。

然而数据范围告诉我们，先求$\sum_{i|N}C_N^i$再进行计算是会爆空间的。所以，我们利用费马小定理的一个推论。

$a^b\equiv a^{b \ mod \ (p-1)}\pmod{p} \ \ \ \ \ \ (a\ne p)$

于是，我们考虑对组合数取模。发现$p-1$，即$999911658$不是质数，将它分解，得$2*3*4679*35617$ 。所以，我们先利用Lucas定理对组合数分别取模，然后用中国剩余定理求出$G$的幂，最后用快速幂求得答案。

### 代码

卢卡斯定理：
```
int C(int n,int m,int x){
	if(n<m)return 0;
	return fac[x][n]*inverse(fac[x][n-m]*fac[x][m],t[x])%t[x];
}//fac为对于4个质数分别预处理的阶乘，inverse为逆元。
int lucas(int n,int m,int x){
	if(m==0)return 1;
	return C(n%t[x],m%t[x],x)*lucas(n/t[x],m/t[x],x)%t[x];
}
```
中国剩余定理：
```
int Chinese_Remainder_Theorem(){
	int a1,b1,a2,b2,a,b,c,x,y;
	a1=t[0],b1=ANS[0];
	for(int i=1;i<4;i++){
		a2=t[i],b2=ANS[i];
		a=a1;b=a2;c=b2-b1;
		exgcd(a,b,x,y);
		x=((c*x)%b+b)%b;
		b1=b1+a1*x;a1=a1*b;
	}
	return b1;//ANS记录对于4个质数取模得到的不同答案，t存储四个质数
}
void exgcd(int a,int b,int &x,int &y){
	if(b==0){x=1;y=0;return;}
	exgcd(b,a%b,x,y);
	int t=x;x=y;y=t-a/b*y;
}
```
主程序只是一个简单的找约数，分别计算并累加记录至ANS数组的过程，不再赘述。

输出：
```
ksm(G,Chinese_Remainder_Theorem(),P)
```


---

## 作者：Dirt、 (赞：7)

~~这是一道集合了各种数论的好题~~

题目大意：求 $ g ^ { \sum_{d \mid n} C_n^d } \bmod 999911659$ 。

发现指数上似乎很大。

检验一波模数，发现模数是个质数，根据费马小定理，可以将指数对 $999911658$ 取模。

现在问题集中于算出指数上的式子。

问题来了： $999911658$ 不是质数。

将其质因数分解，发现可以分解为四个质数的乘积。

考虑以这四个质数为模数构造同余方程组，最后的通解即为式子的值。

现在的唯一问题是在 $n$ 很大的情况下计算组合数。

发现模数很小，可以使用 $Lucas$ 定理计算组合数。

筛出 $n$ 的因数，对于每个模数计算组合数，以该数值构造方程组，最后将通解代入指数上跑快速幂即可。

~~然后发现只有95分~~

注意到费马小定理在底数与模数互质时才能使用。

因为模数为质数，当底数与模数不互质时，底数一定为模数的倍数。此时底数的任意正整数次幂在模意义下等于 $0$。

指数显然不为 $0$ ，当 $g$ 为模数的倍数时特判即可。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=35618;
const int MOD=999911659;
const int M=999911658;
int n,g;
int cnt,tot;
int mod[5],a[5],d[100003];
int fac[N],inv[N];
int fpow(int x,int b,int mod)
{
	int res=1;
	while(b)
	{
		if(b&1) res=(long long)res*x%mod;
		x=(long long)x*x%mod;
		b>>=1;
	}
	return res;
}
void init_C(int mod)
{
	fac[0]=1;
	for(int i=1;i<mod;i++)
		fac[i]=(long long)fac[i-1]*i%mod;
	inv[mod-1]=fpow(fac[mod-1],mod-2,mod);
	for(int i=mod-2;i>=0;i--)
		inv[i]=(long long)inv[i+1]*(i+1)%mod;
}
int C(int n,int m,int mod)
{
	if(m>n) return 0;
	return (long long)fac[n]*inv[m]%mod*inv[n-m]%mod;
}
int lucas(int n,int m,int mod)
{
	if(m==0) return 1;
	return (long long)lucas(n/mod,m/mod,mod)*C(n%mod,m%mod,mod)%mod;
}
void calc(int x)
{
	init_C(mod[x]);
	for(int i=1;i<=tot;i++)
		a[x]=(a[x]+lucas(n,d[i],mod[x]))%mod[x];
}
int crt()
{
	int ans=0;
	for(int i=1;i<=cnt;i++)
	{
		int mul=M/mod[i],t=fpow(mul,mod[i]-2,mod[i]);
		ans=(ans+(long long)a[i]*mul%M*t%M)%M;
	}
	return ans;
}
int main()
{
	scanf("%d%d",&n,&g);
	if(g%MOD==0)
	{
		putchar('0');
		return 0;
	}
	int t=M;
	for(int i=2;i*i<=M;i++)
		if(t%i==0)
		{
			mod[++cnt]=i;
			while(t%i==0) t/=i;
		}
	if(t!=1) mod[++cnt]=t;
	for(int i=1;i*i<=n;i++)
		if(n%i==0)
		{
			d[++tot]=i;
			if(i*i!=n) d[++tot]=n/i;
		}
	for(int i=1;i<=cnt;i++)
		calc(i);
	printf("%d",fpow(g,crt(),MOD));
	return 0;
}
```

本人数论题的代码一般较丑，见谅

---

## 作者：zyh2015 (赞：5)

来自我自己的博客：http://blog.csdn.net/YihAN\_Z/article/details/53969397

题目大意：给定N,G，求

![这里写图片描述](http://img.blog.csdn.net/20170101231632327?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWWloQU5fWg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


 N,G<=1,000,000,000

不妨设![这里写图片描述](http://img.blog.csdn.net/20170101231833062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWWloQU5fWg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


那么如果求出来x，剩下的就是一步快速幂。问题转化为如何求x。


设p=999911659

我们发现p是一个质数且G不可能为p的倍数，根据费马小定理有

![](http://img.blog.csdn.net/20170101232252111?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWWloQU5fWg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

即在mod p的意义下G^(p-1)=1

可以得到![这里写图片描述](http://img.blog.csdn.net/20170101232536503?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWWloQU5fWg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

其中![这里写图片描述](http://img.blog.csdn.net/20170101232623974?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWWloQU5fWg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


我们还注意到，由于N,k很大，所以不能递推计算，只能用阶乘公式计算，这时需要用到Lucas定理。

![这里写图片描述](http://img.blog.csdn.net/20170101233226685?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWWloQU5fWg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


然而计算组合数要用到除法，也就要用到逆元，p-1即999911658不是质数，求不了逆元，怎么办？



999911658=2\*3\*4679\*35617

可以把其分解成4个质数，计算得到同余方程组，中国剩余定理合并即可。


```cpp
#include <cstdio>
#include <cmath>
#define MOD 999911659
#define mod 999911658
using namespace std;
typedef long long LL;
LL N,G;
LL prime[]={2,3,4679,35617},X[4],inv[40000],fac[40000];
LL C(LL n,LL m,LL p) {//Lucas theorem
    if(n<m) return 0;
    if(n<p && m<p) return fac[n]*inv[m]%p*inv[n-m]%p;
    return C(n%p,m%p,p)*C(n/p,m/p,p)%p;
}
LL solve(LL p) {
    //initialize
    fac[0]=1;
    for(int i=1;i<p;i++) fac[i]=fac[i-1]*i%p;
    inv[p-1]=p-1;
    for(int i=p-2;~i;i--) inv[i]=inv[i+1]*(i+1)%p;
    //calculate
    LL lim=sqrt(N),ans=0;
    for(int i=1;i<=lim;i++) {
        if(N%i) continue;
        ans=(ans+C(N,i,p))%p;
        if(N/i==i) continue;
        ans=(ans+C(N,N/i,p))%p;
    }
    return ans;
}
void egcd(LL a,LL b,LL& d,LL& x,LL& y) {
    if(!b) { d=a; x=1; y=0; return ; }
    egcd(b,a%b,d,y,x); y-=x*(a/b);
    return ;
}
LL CRT() {//Chinese_Remainder_Theorem
    LL ans=0;
    for(int i=0;i<4;i++) {
        LL d,x,y;
        egcd(mod/prime[i],prime[i],d,x,y);
        LL cach=(x%mod*(mod/prime[i])%mod+mod)%mod;
        ans+=cach*X[i]%mod;
        ans%=mod;
    }
    return ans;
}
LL f_pow(LL x,LL y) {
    LL ans=1;
    while(y) {
        if(y&1) ans=ans*x%MOD;
        x=x*x%MOD;
        y>>=1;
    }
    return ans;
}
int main() {
    scanf("%lld%lld",&N,&G);
    if(!(G%MOD)) {
        printf("0\n");
        return 0;
    }
    for(int i=0;i<4;i++) X[i]=solve(prime[i]);
    printf("%lld\n",f_pow(G,CRT()));
    return 0;
}

```

---

## 作者：FlashHu (赞：4)

蒟蒻惊叹于一道小小的数论题竟能涉及这么多知识点！不过，掌握了这些知识点，拿下这道题也并非难事。

题意一行就能写下来：

给定$N,G$，求$G^{\sum \limits _{d|N}C(N,d)}(\mod999911659)$

乍一看，指数这么大，要怎么处理好呢？上费马小定理。

平时用费马小定理求逆元用多了，$a^{p-2}\equiv inv(a)(\mod p)$，搞得蒟蒻差点忘了它原本的样子$a^{p-1}=1(\mod p)$，那原式的指数$\sum \limits _{d|N}C(N,d)$就可以直接在$\mod999911658$意义下求了。

首先枚举$d|N$，这个还好办，直接$O(\sqrt{N})$把约数筛出来就好了，注意特判$N$为完全平方数的情况。

紧接着我们就碰到了组合数取模。如果模数是个质数还好办，直接上卢卡斯定理。但是$999911658$明显不是，把它放到计算器里点一下fact会出来$2×3×4679×35617$。

只能用扩展卢卡斯了。所谓扩展卢卡斯，其实就是对于一个非质数的模数，把它质因数分解，求出组合数模每一个质因数的结果。这样等于说得到了一个同余方程组，中国剩余定理还原答案即可。注意对于每一个质因数都要先重新打一遍阶乘表，再对每一个$N$的约数算组合数求和取模。

这样指数就求出来了。最后快速幂得到答案。
```cpp
#include<cstdio>
#include<cmath>
#define LL long long
#define R register LL
#define add(a,b,p) a=(a+b)%p
const LL YL=999911659,N=4e4,pr[4]={2,3,4679,35617};
LL f[N],fac[N],res[4],x,y,t;
LL qpow(R b,R k,R p){//快速幂求b^k%p
    R a=1;
    for(;k;k>>=1,b=b*b%p)
        if(k&1)a=a*b%p;
    return a;
}
LL C(R n,R m,R p){//组合数，注意特判
    return n<m?0:fac[n]*qpow(fac[m]*fac[n-m],p-2,p)%p;
}
LL lucas(R n,R m,R p){//同样注意特判
    return m?C(n%p,m%p,p)*lucas(n/p,m/p,p)%p:1;
}
void exgcd(R a,R b){
    if(b)exgcd(b,a%b),t=x,x=y,y=t-a/b*y;
}
int main(){
    fac[0]=1;
    R n,g,m,p=0,i,j,ans=0;
    scanf("%lld%lld",&n,&g);
    if(!(g%YL))return puts("0"),0;//又一次注意特判
    m=sqrt(n);
    for(i=1;i<=m;++i)
        if(!(n%i))f[++p]=i,f[++p]=n/i;
    p-=f[p-1]==f[p];//还是注意特判，防止被算两次
    for(i=0;i<4;++i){
        for(j=1;j<pr[i];++j)
            fac[j]=fac[j-1]*j%pr[i];
        for(j=1;j<=p;++j)
            add(res[i],lucas(n,f[j],pr[i]),pr[i]);
        //下面中国剩余定理，注意x变成正数
        x=1;y=0;exgcd(m=(YL-1)/pr[i],pr[i]);
        add(ans,res[i]*(x%pr[i]+pr[i])*m,(YL-1));
    }
    printf("%lld\n",qpow(g,ans,YL));
    return 0;
}
```

---

## 作者：azihmst (赞：3)

显而易见的，目标是求对于数m来说所有约数n

求c（m,n）之和

显然，会爆。

那么，我们需要找到一个能够简化它的办法。

那就是——费马小定理



------------
**费马小定理**

费马小定理(Fermat's little theorem)是数论中的一个重要定理，在1636年提出，其内容为： 假如p是质数，且gcd(a,p)=1，那么 a(p-1)≡1（mod p），例如：假如a是整数，p是质数，则a,p显然互质(即两者只有一个公约数1)，那么我们可以得到费马小定理的一个特例，即当p为质数时候， a^(p-1)≡1(mod p)。
（摘自度娘）

由题，应该mod999911659

现在判断999911659是否为质数。


------------
利用筛素数法

筛素数法可以比枚举法节约极大量的时间（定n为所求最大值，m为≤n的质数个数，那么枚举需要O(n^2)的时间复杂度，而筛素数法为O(m*n),显然m<<n，所以时间效率有很大提升。）。如1000000的数据范围，用筛素数法可在2s内解决。
思路：建立一个bool型数组M，若已知一个数M[k]是质数，那么其i（i为正整数）倍M[k*i]必然为合数，可将其去除。

（摘自度娘）

相关程序百度即可


------------
接下来，利用费马小定理。

化为mod999911658

模仍然复杂

考虑到组合数，利用Lucas定理


------------
Lucas定理

C(n,m)%p=C(n/p,m/p)*C(n%p,m%p)%p 

可惜，要求p是质数

接下来

利用其扩展定理

若p不是素数，我们将p分解质因数，将Cnm分别按照Lucas中的方法求对p的质因数的模，然后用中国剩余定理合并。

http://blog.csdn.net/Frods/article/details/67639410传送门

将999911658分解

999911658=2*3*4679*35617


------------

最后科普一下中国剩余定理


**孙子定理是中国古代求解一次同余式组（见同余）的方法。是数论中一个重要定理。又称中国余数定理。一元线性同余方程组问题最早可见于中国南北朝时期（公元5世纪）的数学著作《孙子算经》卷下第二十六题，叫做“物不知数”问题，原文如下：
有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？即，一个整数除以三余二，除以五余三，除以七余二，求这个整数。《孙子算经》中首次提到了同余方程组问题，以及以上具体问题的解法，因此在中文数学文献中也会将中国剩余定理称为孙子定理。**

就是小学学过的了

代码实现见百度



------------

求审核通过。
传送门

http://blog.csdn.net/liangzhaoyang1/article/details/52132986?locationNum=7

http://blog.csdn.net/Frods/article/details/67639410

https://baike.baidu.com/item/%E5%AD%99%E5%AD%90%E5%AE%9A%E7%90%86/2841597

https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0/263515?fr=aladdin#7_4

---

## 作者：Agakiss (赞：2)

### Description
[[SDOI2010]古代猪文](https://www.luogu.org/problem/P2480)
### Solution
给$n$，$G$，求$G^{\sum_{d|n}C^{d}_{n}}\:mod\:999911659$

先套一下欧拉定理，因为$999911659$是质数，所以，

$G^{\sum_{d|n}C^{d}_{n}}\:mod\:999911659$=$G^{\sum_{d|n}C^{d}_{n}\:mod\:999911658}\:mod\:999911659$

我们先求$\sum_{d|n}C^{d}_{n}\:mod\:999911658$

我们发现，$999911658=2*3*4679*35617$，四个质数相乘，而且质数的次数都为$1$

用$Lucas$定理求出$\sum_{d|n}C^{d}_{n}$分别在$2$，$3$，$4679$，$35617$下的余数$a1$，$a2$，$a3$，$a4$

设答案为$x$，得到方程
$\left\{
\begin{aligned}
x&\equiv a1&(mod&\:2)\\
x&\equiv a2&(mod&\:3)\\
x&\equiv a3&(mod&\:4679)\\
x&\equiv a4&(mod&\:35617)\\
\end{aligned}
\right.$

再套一下中国剩余定理的板子，求出$x$，再用一个快速幂，就可以求出答案了
### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MOD 999911659
#define MoD 999911658
#define MOD1 2
#define MOD2 3
#define MOD3 4679
#define MOD4 35617
ll M1, M2, M3, M4, n, G, a1, a2, a3, a4, x, sum;
ll h1[MOD1 + 10], h2[MOD2 + 10], h3[MOD3 + 10], h4[MOD4 + 10];
inline ll read() {
	ll s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}
inline ll Pow(ll a, ll b, ll p) {
	ll ans = 1;
	while (b) {
		if (b & 1) (ans *= a) %= p;
		(a *= a) %= p;
		b >>= 1;
	}
	return ans;
}
inline ll Inv(ll a, ll p) {
	return Pow(a, p - 2, p);
}
inline ll C(ll n, ll m, ll p) {
    if (m > n) return 0;
    if (p == MOD1) return h1[n] * Inv(h1[m], p) % p * Inv(h1[n - m], p) % p;
    if (p == MOD2) return h2[n] * Inv(h2[m], p) % p * Inv(h2[n - m], p) % p;
    if (p == MOD3) return h3[n] * Inv(h3[m], p) % p * Inv(h3[n - m], p) % p;
    if (p == MOD4) return h4[n] * Inv(h4[m], p) % p * Inv(h4[n - m], p) % p;
}

ll Lucas(ll n, ll m, ll p) {
    if (!m) return 1;
    return Lucas(n / p, m / p, p) * C(n % p, m % p, p) % p;
}
inline void Init() {
	h1[0] = 1; for (register ll i = 1; i <= MOD1; i++) h1[i] = (h1[i - 1] * i) % MOD1;
	h2[0] = 1; for (register ll i = 1; i <= MOD2; i++) h2[i] = (h2[i - 1] * i) % MOD2;
	h3[0] = 1; for (register ll i = 1; i <= MOD3; i++) h3[i] = (h3[i - 1] * i) % MOD3;
	h4[0] = 1; for (register ll i = 1; i <= MOD4; i++) h4[i] = (h4[i - 1] * i) % MOD4;	
}
int main() {
	M1 = MoD / MOD1;
	M2 = MoD / MOD2;
	M3 = MoD / MOD3;
	M4 = MoD / MOD4;
	Init();
	n = read(), G = read();
	if (G % MOD == 0) {
		printf("0");
		return 0;
	}
	for (register ll i = 1; i <= sqrt(n); i++)
		if (n % i == 0) {
			a1 = Lucas(n, i, MOD1), a2 = Lucas(n, i, MOD2), a3 = Lucas(n, i, MOD3), a4 = Lucas(n, i, MOD4);
			x = ((a1 % MoD * M1 % MoD * Inv(M1, MOD1) % MoD) +
				 (a2 % MoD * M2 % MoD * Inv(M2, MOD2) % MoD) +
				 (a3 % MoD * M3 % MoD * Inv(M3, MOD3) % MoD) +
				 (a4 % MoD * M4 % MoD * Inv(M4, MOD4) % MoD)) % MoD;
			(sum += x) %= MoD;
			if (i * i == n) continue;
			a1 = Lucas(n, n / i, MOD1), a2 = Lucas(n, n / i, MOD2), a3 = Lucas(n, n / i, MOD3), a4 = Lucas(n, n / i, MOD4);
			x = ((a1 % MoD * M1 % MoD * Inv(M1, MOD1) % MoD) +
				 (a2 % MoD * M2 % MoD * Inv(M2, MOD2) % MoD) +
				 (a3 % MoD * M3 % MoD * Inv(M3, MOD3) % MoD) +
				 (a4 % MoD * M4 % MoD * Inv(M4, MOD4) % MoD)) % MoD;
			(sum += x) %= MoD;
		}
	printf("%lld", Pow(G, sum, MOD));
	return 0;
}
```

---

## 作者：AThousandSuns (赞：2)

题目大意：求：
### $g^{\sum_{d|n}C_n^d}\ mod\ 999911659$
$1\leq n,g\leq 10^9$。

---
要求这个式子，最主要是求出 $\sum_{d|n}C_n^d$ 的值。但是对什么数取模呢？

**费马小定理（欧拉定理）：$a,p$ 互质时，$a^{p-1}\equiv 1(mod\ p)$**。

而~~经过后台打表黑科技操作~~后发现 $999911659$ 是质数。所以：
$$g^{\sum_{d|n}C_n^d}\ mod\ 999911659=g^{\sum_{d|n}C_n^d\ mod\ 99911658}\ mod\ 999911659$$

当且仅当 $999911659\nmid g$ 时成立。而 $1\leq g\leq 10^9$，所以只要**特判 $g=999911659$ 就行了**。（答案为 $0$）

接下来要求 $\sum_{d|n}C_n^d\ mod\ 999911658$。

其中 $d$ 可以 $O(\sqrt{n})$ 枚举，接下来就是求组合数的问题了。

这个 $n$ 的数据范围想硬算或者预处理出来都不现实。**想到 $\text{Lucas}$ 定理：$C_n^m\ mod\ p=C_{n/p}^{m/p}\times C_{n\ mod\ p}^{m\ mod\ p}\ mod\ p$**。

别高兴的太早。当且仅当 $p$ 是质数时成立。

没有关系！

~~经过后台打表黑科技操作~~后发现 $999911658$ 分解质因数后为 $2\times 3\times 4679\times 35617$。那么分别求出 $C_n^d\ mod\ 2,C_n^d\ mod\ 3,C_n^d\ mod\ 4679,C_n^d\ mod\ 35167$ 后可以得到：

$C_n^d\ mod\ 999911658\equiv a_1(mod\ 2)$

$C_n^d\ mod\ 999911658\equiv a_2(mod\ 3)$

$C_n^d\ mod\ 999911658\equiv a_3(mod\ 4679)$

$C_n^d\ mod\ 999911658\equiv a_4(mod\ 35617)$

把 $C_n^d\ mod\ 999911658$ 看作是未知数。那么这时就可以**用中国~~生育~~剩余定理**合并答案。

至于中国剩余定理，我也讲不太清楚。大概百度一下就行了。这里安利[dalaolitble的博客](https://blog.csdn.net/litble/article/details/75807726)

至此，$C_n^d\ mod\ 999911658$ 已经求完，套到原式上就行了。

---
代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod=999911659,facs[4]={2,3,4679,35617};	//质因子
int n,ans,g,fac[100010][4],inv[100010][4],invfac[100010][4];
int quickpow(int a,int b,int mod){	//快速幂
    int ans=1%mod;
    while(b){
        if(b&1) ans=1ll*ans*a%mod;
        a=1ll*a*a%mod;
        b>>=1;
    }
    return ans;
}
int exgcd(int a,int b,int &x,int &y){	//扩展欧几里得
    if(!b){x=1;y=0;return a;}
    int d=exgcd(b,a%b,y,x);y-=(a/b)*x;return d;
}
void init(){	//初始化四种模数的阶乘，逆元和阶乘的逆元
    for(int i=0;i<4;i++){
        fac[0][i]=fac[1][i]=inv[1][i]=invfac[0][i]=invfac[1][i]=1;
        for(int j=2;j<facs[i];j++){
            fac[j][i]=1ll*fac[j-1][i]*j%facs[i];
            inv[j][i]=(facs[i]-1ll*(facs[i]/j)*inv[facs[i]%j][i]%facs[i])%facs[i];
            invfac[j][i]=1ll*invfac[j-1][i]*inv[j][i]%facs[i];
        }
    }
}
int lucasedC(int n,int m,int type){	//普通组合数
    if(n<m) return 0;
    return 1ll*fac[n][type]*invfac[m][type]%facs[type]*invfac[n-m][type]%facs[type];
}
int chinaedC(int n,int m,int type){	//卢卡斯定理优化组合数
    if(n<facs[type]) return lucasedC(n,m,type);
    return 1ll*chinaedC(n/facs[type],m/facs[type],type)*chinaedC(n%facs[type],m%facs[type],type)%facs[type];
}
int C(int n,int m){	//中国剩余定理合并组合数
    int x,ans=0;
    for(int i=0;i<4;i++){
        x=quickpow((mod-1)/facs[i],facs[i]-2,facs[i]);
        ans=(ans+1ll*chinaedC(n,m,i)*x%(mod-1)*((mod-1)/facs[i])%(mod-1))%(mod-1);
    }
    return ans;
}
int main(){
    scanf("%d%d",&n,&g);
    if(g==mod){	//特判！（费马小定理/欧拉定理在这时不成立）
        printf("0\n");return 0;
    }
    init();
    for(int i=1;i*i<=n;i++)	//枚举约数
        if(n%i==0){
            ans=(ans+C(n,i))%(mod-1);
            if(i*i!=n) ans=(ans+C(n,n/i))%(mod-1);	//约数是一一对应的
        }
    printf("%d\n",quickpow(g,ans,mod));	//完美结束
}
```

---

## 作者：TH讠NK (赞：2)

~~我这个刚学数论一周多的蒟蒻居然能来写题解~~

## 前置知识：

**欧拉定理/费马小定理**

**$Lucas$ 定理**

**中国剩余定理**

**欧几里得算法**

**乘法逆元**

## 一句话题意：

**给定整数 $n,g(1 \le n,g \le 1e9)$ , 求 $g^{\sum_{d \mid n} C^d_n} \mod 999911659$**

## 分析：
首先 ，因为 $999911659$ 是质数 ，所以在 $g \ne 999911659$ 的情况下 ， $999911659,g$ 均互质 $(g \le 1e9)$ 。
而当 $g=999911659$ 时  ，$g^{\sum_{d \mid n} C^d_n} \mod 999911659$ 显然为 $0$ ，因此我们只需要讨论 $999911659,g$ 互质的情况（这里记得特判 ，否则只有 $95$）

根据 **欧拉定理/费马小定理** 且 $999911659,g$ 互质 ，我们可以得到 $g^{\sum_{d \mid n} C^d_n}\equiv{g^{(\sum_{d \mid n} C^d_n) \% 999911658} }\pmod{m_i}$ ，如果不懂的话可以[点这里学习](https://www.luogu.org/blog/chen031029/ou-la-han-shuo)

因此 ，**本题的关键**在于求出 $\sum_{d \mid n} C^d_n \mod 999911658$

我们发现 $999911658$ 并不是一个质数 ，而我又~~不会~~不想用扩展 $Lucas$ 定理 ，那该如何解决呢 $?$

由于 $Lucas$ 定理只能解决模数为质数的情况 ，于是我们尝试把 $999911658$ 分解质因数 ，这样一个原本不可解的大问题就被我们分成了**多个可解的小问题**

因为 $999911658=2*3*4679*35617$ ，所以我们可以分别计算出 $\sum_{d \mid n} C^d_n$ 对 $2,3,4679,35617$ 这四个质数取摸的结果 ，计为 $a_1,a_2,a_3,a_4$ ，然后就得到了一个**线性同余方程组**：

$$ \begin{cases}x\equiv a_1\pmod{2}\\x\equiv a_2\pmod{3}\\x\equiv a_3\pmod{4679}\\x\equiv a_4\pmod{35617}\end{cases} $$

**注意：这里可以这么处理是因为 $999911658$ 分解质因数后每个质因子的指数都是 $1$**

由于模数显然两两互质 ，所以最后我们用 **中国剩余定理** 求解 $x$ 即可 ， $x=\sum\limits_{i=1}^{n} a_iM_it_i$ ，不懂的话可以[点这里学习](https://www.luogu.org/blog/chen031029/zhong-guo-sheng-yu-ding-li)

至此本题就基本解决了 ，接下来的就是一些细节上的东西

## 代码实现：

求解的时候我们发现本题的 $M_i,t_i$ 都是固定的 ，所以可以直接预处理出来 ，代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll mod=999911658, pri[4]={2,3,4679,35617};//注意这里的 mod 是 999911658
ll d,x,y,ans;
ll exgcd(ll a,ll b){//扩展欧几里得算法 
    if(b==0) {x=1, y=0; return a;}
    d=exgcd(b,a%b);
    x^=y, y^=x, x^=y;
    y-=(a/b)*x;
    return d;
}
int main(){
	for(int i=0;i<=3;i++){
		d=exgcd(mod/pri[i],pri[i]);//扩欧求解线性同余方程
		x=(x%pri[i]+pri[i])%pri[i];//让 x 成为最小正整数解 
//		cout<<mod/pri[i]<<' '<<x<<endl;
		ans=mod/pri[i]*x%mod;
		cout<<ans<<endl;
	}
    return 0;
}
```

然后我们就可以得到本题的 $M_i,t_i$ 分别为 $499955829,333303886,289138806,877424796$ ，可以拿来直接使用~~节省点代码量~~

由于本题要多次使用 $Lucas$ 定理求 $C(n,m)\% p$ 而且 $p$ 比较小 ，所以我们可以先预处理出**所有 $p$ 以内的阶乘**以及**阶乘的模 $p$ 乘法逆元** ，关于乘法逆元的知识可以[点这里学习](https://www.luogu.org/blog/chen031029/sheng-fa-ni-yuan)

最后 ，本题 $AC$ 代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll mod=999911659, pri[4]={2,3,4679,35617}, mt[4]={499955829,333303886,289138806,877424796};
ll inv[36000],mi[36000],a,n,q,p,ans;
inline ll mul(ll x,ll k){//快速幂 
	ll ans=1;
    while(k){
    	if(k&1) ans=ans*x%mod;
    	k>>=1;
    	x=x*x%mod;
	}
    return ans;
}
inline ll C(ll n,ll m){//求组合数 
    if(m>n) return 0;
    return (mi[n]*inv[m]%p*inv[n-m]%p);
}
ll Lucas(ll n,ll m){//Lucas定理求C(n,m)%p 
    if(m==0) return 1;
    return C(n%p,m%p)*Lucas(n/p,m/p)%p;
}
int main(){
    scanf("%lld%lld",&n,&q);
    if(q==mod) {cout<<0<<endl; return 0;}//记得特判 
    for(int x=0;x<=3;x++){
    	p=pri[x], a=0;//记得把a重置为 0 
    	mi[0]=mi[1]=inv[1]=inv[0]=1;
	    for(int i=2;i<=p;i++) mi[i]=mi[i-1]*i%p, inv[i]=1ll*(p-p/i)*inv[p%i]%p;
	    for(int i=2;i<=p;i++) inv[i]=inv[i]*inv[i-1]%p;
	    //预处理出所有p以内的阶乘以及阶乘的模p乘法逆元 
	    for(int i=1;i*i<=n;i++)
	    	if(n%i==0){//对于每个n的约数i求C(n,i)并累加到a里 
		    	a=(a+Lucas(n,i))%p;
		    	if(i*i!=n) a=(a+Lucas(n,n/i))%p;
			}
		ans=(ans+mt[x]*a%(mod-1))%(mod-1);// mt[x]是之前处理好的 Mx*tx ,注意这里模的是 999911658
	}
	cout<<mul(q,ans)<<endl;//最后直接快速幂求解即可 
    return 0;
}
```

## 总结：

本题综合性较高 ，考查了**欧拉定理/费马小定理** ，**$Lucas$ 定理** ，**中国剩余定理** ，**欧几里得算法** ，**乘法逆元**等知识 ，需要我们对数论的知识有系统的概念 ，如果发现自己哪里还存在知识的漏洞要赶紧去补哦 $QAQ$


---

## 作者：VenusM1nT (赞：1)

组合数学。  
题目还是挺难读的吧……  
最后可以发现要求的是

$$\large \text{G}^{\sum_{d|n}\binom{n}{d}}(\ \text{mod}\ \ 999911659)$$

欧拉定理是个好东西：

$$\large \text{G}^{\sum_{d|n}\binom{n}{d}}(\ \text{mod}\ \ 999911659)\equiv \text{G}^{\sum_{d|n}\binom{n}{d}(\ \text{mod}\ \ 999911658)}(\ \text{mod}\ \ 999911659)$$

考虑怎么算这玩意，上面的 $\binom{n}{d}$ 长的很 $\texttt{Lucas}$，但是模数是个合数  
这时有两种办法，一种是直接写 $\texttt{ExLucas}$，但是我写的 $\texttt{ExLucas}$ 可能长得太丑了，直接 T 上天（而且 $\texttt{ExLucas}$ 的复杂度是和模数相关的，很容易爆），只能考虑别的办法  
我们把 $999911658$ 质因数分解，得到 $2\times 3\times 4679\times 35617$，分别以这四个数为模数，用 $\texttt{Lucas}$ 求出四个答案，最终得到以下形式：

![](https://i.loli.net/2019/09/10/nOr5YX9j4RAZLoE.png)

这玩意儿可以大力 $\texttt{Crt}$ 合并，最后输出 $\text{G}^{\text{P}}(\ \text{mod}\ \ 999911659)$ 即可。

```cpp
#include<bits/stdc++.h>
#define MAXN 100005
#define reg register
#define inl inline
#define int long long
using namespace std;
const int Mod=999911658;
int n,m,a[5],fac[MAXN],p[5]={0,2,3,4679,35617},ans;
inl int Pow(reg int x,reg int y,reg int p)
{
	reg int res=1;
	for(;y;y>>=1,x=x*x%p) if(y&1) res=res*x%p;
	return res;
}
inl void Init(reg int p)
{
	fac[0]=1;
	for(reg int i=1;i<=p;i++) fac[i]=fac[i-1]*i%p;
}
inl int C(reg int x,reg int y,reg int p)
{
	return x<y?0:Pow(fac[x-y],p-2,p)*fac[x]%p*Pow(fac[y],p-2,p)%p;
}
int Lucas(reg int x,reg int y,reg int p)
{
	if(x<y) return 0;
	return !x?1:C(x%p,y%p,p)*Lucas(x/p,y/p,p)%p;
}
signed main()
{
	scanf("%lld %lld",&n,&m);
	if(!(m%(Mod+1))) return puts("0"),0;
	for(reg int i=1;i<=4;i++)
	{
		Init(p[i]);
		for(reg int j=1;j*j<=n;j++)
		{
			if(!(n%j))
			{
				a[i]=(a[i]+Lucas(n,j,p[i]))%p[i];
				if(j*j!=n) a[i]=(a[i]+Lucas(n,n/j,p[i]))%p[i];
			}
		}
	}
	for(reg int i=1;i<=4;i++) ans=(ans+a[i]*(Mod/p[i])%Mod*Pow(Mod/p[i],p[i]-2,p[i]))%Mod;
	ans=Pow(m,ans,Mod+1);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：小周猪猪 (赞：1)

这个人很菜，想这个某位大佬所谓很简单的题目很久，只能通过[博客](https://blog.csdn.net/Ronaldo7_ZYB/article/details/89576408)来缓解心中的忧伤......
## 题目大意
题目很长，这里就不说了吧。粘个链接：[古代猪文](https://www.luogu.org/problemnew/show/P2480)
题目大意就是：给定整数n,q，计算$q^{\sum_{d|n} C_{n}^{d}}\ mod\ 999911659$.

## 题解
这道题的$n$很大；如果暴力枚举每一个$d$，再直接求解组合数的话，由于$n$和$d$很大，在计算组合数的时候会浪费很大的时间，因此我们需要对这一个算法进行优化。

- 在讨论本题之前我们先来讨论一下$Lucas$定理以及其实现过程。
对于任意质数P，有:$C_{n}^{m}\ \equiv\ C_{n/P}^{m/P}*C_{n\%P}^{m\%P},(mod\ p)$

- 证明过程很复杂，我们在这里不详细讨论。我们主要考虑如何运用到组合数的计算内。

- 对于利用$Lucas$定理求解组合数，我们可以使用递归来进行求解，以求解$C_{n}^{m}$即：
当$n=m$时返回1；若$n$和$m$都同时**小于模数p**，我们直接暴力计算组合数即可;否则我们就必须使用$Lucas$定理来进行递归实现。

- 友情提醒：必须要小于质数$p$才能提前计算而不能小于某一个预先处理好的大数字；因为当这一个大数字超过$p$时就会出现大量模$p$等于$0$的情况，那么你就会发现组合数计算出来以后全部都是0.但是一般情况下因为p比较大所以不存在任何问题；基础这道题的特殊性，模数比较小，组合数的计算上就会出现问题了。

- 代码如下：你可以将$p[k]$理解一个取模的质数；$power$是一个快速幂函数，用于求解乘法逆元。

```cpp
LL C(LL n,LL m,LL k)
{
	if (n == m) return 1;
	if (n < m) return 0;
	if (n<p[k] && m<p[k])
	{
		LL sum1 = jc[n][k];
		LL sum2 = jc[n-m][k]*jc[m][k]%p[k];
		return sum1*power(sum2,p[k]-2,p[k])%p[k];
	}
	return C(n/p[k],m/p[k],k)*C(n%p[k],m%p[k],k)%p[k];
}
```

OK，说完卢卡斯以后回归本题。

首先我们需要特判一种特殊的情况，当$q$是$999911659=P$的倍数时，答案为$0$.

若不是上面的情况，我们可以根据欧拉定理推论:$a^b\ \equiv\ a^{b\%phi(p)}(mod\ p)$,得到：
$$q^{\sum_{d|n} C_{n}^{d}}\ \equiv\ q^{\sum_{d|n} C_{n}^{d}\%999911658}$$

因此我们的目标就是要求解这一串数的值：$\sum_{d|n} C_{n}^{d}\%999911658$

然后我们对模数$P$分解质因数，得到：$999911659\ =\ 2*3*4679*35617$。可以分别计算。
然后这一题就非常好玩了，我们可以暴力求$n$的每一个因数，得到对于的$C_{n}^{d}$对四个质数取模的值，分别累加在$a_0$,$a_1$,$a_2$,$a_3$上。即$a_i\ =\ \sum_{d|n}C_{n}^{d}\%p_i$.为什么可以累加？因为最后是求和的，因此余数可以直接累加。

最后，你可以得到一个方程组：
$$
\begin{cases}
x\ mod\ 2\ =\ a_1 \\
x\ mod\ 3\ =\ a_2 \\
x\ mod\ 4769\ =\ a_3 \\
x\ mod\ 35617\ =\ a_4
\end{cases}
$$
显然这个东西直接套用中国剩余定理的结论即可；一通线性同余方程exgcd一下就好了。

然后我们就可以求解出一组$x_0$,则通解$x$可以表示为：$x_0\ \equiv\ x\ (mod\ 999911658)$.我们只要找到最小的解即可。

为了加快求组合数的速度，我们要预处理出阶乘；乘法逆元求不求都无所谓。然后就十分愉快的得到代码了：

```cpp
#include <bits/stdc++.h>
typedef long long LL;
using namespace std;

const LL P = 999911659;
const LL p[4] = {2,3,4679,35617};
LL n,q;
LL a[4];
LL jc[100000][4];

void init(void)
{
	jc[0][0] = jc[0][1] = jc[0][2] = jc[0][3] = 1;
	for (LL i=1;i<=5e4;++i) 
	{
		jc[i][0] = jc[i-1][0]*i%p[0];
		jc[i][1] = jc[i-1][1]*i%p[1];
		jc[i][2] = jc[i-1][2]*i%p[2];
		jc[i][3] = jc[i-1][3]*i%p[3];
	}
	return;
}

LL power(LL a,LL b,LL c) {
	LL res = 1;
	while (b>0)
	{
		if (b%2 == 1) res = res*a%c;
		a = a*a%c;
		b /= 2;
	}
	return res;
}

LL C(LL n,LL m,LL k)
{
	if (n == m) return 1;
	if (n < m) return 0;
	if (n<p[k] && m<p[k])
	{
		LL sum1 = jc[n][k];
		LL sum2 = jc[n-m][k]*jc[m][k]%p[k];
		return sum1*power(sum2,p[k]-2,p[k])%p[k];
	}
	return C(n/p[k],m/p[k],k)*C(n%p[k],m%p[k],k)%p[k];
}

void work(void)
{
	for (LL i=0;i<4;++i)
	{
		for (LL j=1;j*j<=n;++j) 
		if (n%j == 0)
		{
			if (j*j != n) a[i] = (a[i]+C(n,j,i))%p[i];
			a[i] = (a[i]+C(n,n/j,i))%p[i];
		}
	}
}

LL x,y;
LL exgcd(LL a,LL b,LL c) 
{ 
	if (b == 0) 
	{ 
		x = c/a; 
		y = 0; 
		return a; 
	} 
	LL t = exgcd(b,a%b,c); 
	LL X = x,Y = y; 
	x = Y; 
	y = X-a/b*Y; 
	return t; 
}

void china(void)
{
	LL sum = 0;
	LL mm = 999911658;
	LL M[4] = {};
	LL r[4] = {};
	for (LL i=0;i<4;++i) 
	{
		M[i] = mm/p[i];
	    exgcd(M[i],p[i],1);
	    r[i] = x;
	    sum = sum+r[i]*M[i]*a[i];
	}
	sum = (sum%mm+mm)%mm;
	cout<<power(q,sum,P);
	return;
}

int main(void)
{
	freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);
	init();
	cin>>n>>q;
	if (q == P) return puts("0"),0;
	work();
	china();
	return 0;
} 
```

~~一道数学题硬是被我写到了100行哈哈哈哈哈~~ 

---

## 作者：ChenZ01 (赞：1)

[个人博客](https://chenz01.github.io)

## Solution

题意即求
$$G ^ {\sum_{d | n}C_n^d}\,\mathrm{mod}\,999911659$$

### Step 1

推广费马小定理可得
$$G^{\sum_{d | n}C_n^d\,\mathrm{mod}\,999911659} = G^{\sum_{d | n}C_n^d\,\mathrm{mod}\,999911658}\,\mathrm{mod}\,999911659$$

### Step 2

快速幂很好办，那么唯一的难点就是指数——模数不为质数，不能直接用Lucas Theorem

再看一眼我们要求的指数
$$\sum_{d | n}C_n^d\,\mathrm{mod}\,999911658$$
对于$d$我们采用$O(\sqrt{n})$的方式暴力枚举，然后呢……

似乎我们已经走入穷途末路了……

### Step 3

方便起见令$s = \sum_{d | n}C_n^d, x = s \,\mathrm{mod}\,999911659$
分解$999911658 = 2 \cdot 3 \cdot 4679 \cdot 35617$
令$a_1 = s\,\mathrm{mod}\, 2, a_2 = s\,\mathrm{mod}\, 3, a_3 = s\,\mathrm{mod}\, 4679, a_4 = s\,\mathrm{mod}\, 35617$

我们可以得到（此处应有大括号）
$$x \equiv a_1 (\mathrm{mod}\, 2)$$
$$x \equiv a_2 (\mathrm{mod}\, 3)$$
$$x \equiv a_3 (\mathrm{mod}\, 4679)$$
$$x \equiv a_3 (\mathrm{mod}\, 35617)$$
求解出$x$即为指数

## Code

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <cmath>

using namespace std;

#define MOD 999911659

template <class T>
void Read(T &x)
{
	x = 0;
	register char ch = getchar();
	for (; !isdigit(ch); ch = getchar());
	for (; isdigit(ch); x = x * 10 + (ch ^ 48), ch = getchar());
}

long long n, g;
long long frac[50010];

void init(long long p)
{
	frac[0] = 1;
	for (register long long i = 1; i <= p; ++i)
		frac[i] = frac[i - 1] * i % p;
}

inline long long fastpow(long long base, long long index, long long p)
{
	register long long ret = 1;
	while (index)
	{
		if (index & 1)
			ret = ret * base % p;
		base = base * base % p;
		index >>= 1;
	}
	return ret;
}

inline long long inv(long long x, long long p)
{
	return fastpow(x, p - 2, p);
}

inline long long C(long long x, long long y, long long p)
{
	if (x < y)
		return 0;
	else
		return frac[x] * inv(frac[y], p) * inv(frac[x - y], p) % p;
}

inline long long Lucas(long long x, long long y, long long p)
{
	if (x < y)
		return 0;
	else if (x < p && y < p)
		return C(x, y, p);
	else
		return Lucas(x % p, y % p, p) * Lucas(x / p, y / p, p) % p;
}

inline long long CRT(vector <long long> &a, vector <long long> &b)
{
	register long long ret = 0, m = MOD - 1;
	for (register int i = 0; i < 4; ++i)
		ret = (ret + a[i] * (m / b[i]) % m * inv(m / b[i], b[i]) % m) % m;
	return (ret % m + m) % m;
}

inline long long sum(long long p)
{
	vector <long long> a(4), b(4);
	b[0] = 2, b[1] = 3, b[2] = 4679, b[3] = 35617;
	for (register int j = 0; j < 4; ++j)
	{
		init(b[j]);
		for (register int i = 1; i * i <= n; ++i)
		{
			if (!(n % i))
			{
				a[j] = (a[j] + Lucas(n, i, b[j])) % b[j];
				if (i * i != n)
					a[j] = (a[j] + Lucas(n, n / i, b[j])) % b[j];
			}
		}
	}
	return CRT(a, b) % p;
}

int main()
{
	Read(n), Read(g);
	if (!(g % MOD))
		cout << 0 << endl;
	else
		cout << fastpow(g, sum(MOD), MOD)<< endl;
}
```

---

## 作者：aiyougege (赞：1)

#### Solution
　　首先考虑从n个数中取出k个数的组合有$\binom{n}{k}$, 所以本题实际上是要求求出$$G^{\sum\limits_{k\mid d}\binom{n}{k}}\bmod {999911659}$$.

　　当然这个模数是一个素数, 因此我们可以根据**费马小定理**
  
***$a^{p-1}\equiv 1\pmod p$, 其中p为素数.***来

　　设$\sum\limits_{k|n}\binom{n}{k}$为d.  那么$d$可以被拆分成两部分, 一部分为$999911659-1$的倍数$x$, 那么$G^x\equiv 1\pmod {999911659}$.因此
  $$G^d\equiv G^{d\bmod 999911658}\pmod {999911659}$$

　　**接下来的任务是求出$\sum\limits_{k|n}\binom{n}{k}\bmod 999911658$**?

　　如果模数是质数, 那么我们大概可以根据**Lucas定理**解题.很可惜不是, 但是我们仍可以求出答案在模模数的质因子下的答案.幸运的是,$999911658=2\times 3\times 4679\times 35617$.我们发现它没有**平方因子**.这意味着可以分别求出$\sum\limits_{k|n}\binom{n}{k}$在模$2,3,4679,35617$下的答案, 这4组同余方程被统一的表示成这种形式
  $$\sum\limits_{k|n}\binom{n}{k}\equiv a_i\pmod {b_i}$$
  然后用**中国剩余定理**求出$\sum\limits_{k|n}\binom{n}{k}\bmod 999911658$.

　　在做完了这些之后, 就只需要用快速幂求出G在模999911659下的幂就好了.

　　在做完这个题后, 来回顾一下这个题使用的技巧(方法).
- 费马小定理, 对指数取模;
	- 卢卡斯定理(扩展), 组合数取模;
		- 中国剩余定理, 求解同余方程组;
			- 扩展欧几里得, 求逆元
- 快速幂, 求出底数的幂.

　　发现使用的数学方法虽然比较多, 但都是**常用**而且是**环环相扣**的, 因此熟练的掌握这些常用的数学技巧和分析问题的方法显得尤为重要.

　　还有, 感谢给出的999911658这个数无平方因子, 要不然扩展卢卡斯的过程就更加麻烦了.
 
#### Code
```c++
#include<cmath>
#include<cstdio>
#include<iostream>
#define mod 999911659
#define Mod 999911658
using namespace std;

int s[5]={2,3,4679,35617};

int n,g;
void exgcd(int a,int b,int &x,int &y){
    if(!b){x=1,y=0;return;}
    exgcd(b,a%b,y,x);
    y-=a/b*x;
}
int Inv(int a,int p){
    int x,y,c;
    exgcd(a,p,x,y);
    x=(x%p+p)%p;
    if(!x)x+=p;
    return x;
}
int C(int n,int m,int mo){
    if(m>n)return 0;
    long long up=1ll,down=1ll;
    for(int i=n-m+1;i<=n;++i)up=up*i%mo;
    for(int i=1;i<=m;++i)down=down*i%mo;
    return up*Inv(down,mo)%mo;
}
int Lucas(int n,int m,int mo){
    if(m>n)return 0;
    long long ans=1ll,nn=n,mm=m;
    for(;m;n/=mo,m/=mo)
        ans=ans*C(n%mo,m%mo,mo)%mo;
    return ans;
}

int China(int n, int a[], int m[]) {  
    int ans=0,w,x;
    for(int i=0;i < n; i++) {  
        w=Mod/m[i];
        x=Inv(w,m[i]);
        ans=(ans+(long long)x*w*a[i])%Mod;  
    }  
    return (ans+Mod)%Mod;
}  

int Calc(int m){
    int b[5]={0};long long ans=0;
    for(int i=0;i<4;++i){
        b[i]=Lucas(n,m,s[i]);
    }
    ans=China(4,b,s);
    return ans;
}
int Pow(int a,int b){
    long long ans=1ll,bas=a;
    while(b){
        if(b&1)ans=(ans*bas)%mod;
        bas=(bas*bas)%mod;
        b>>=1;
    }
    return ans;
}

main(){
    int ans=0;
    scanf("%d%d",&n,&g);
    if(g==mod){
        printf("0");
        return 0;
    }
    for(int i=1;i<sqrt(n);++i)
        if(n%i==0)
            ans=((ans+Calc(i))%Mod+Calc(n/i))%Mod;
    int Answer=Pow(g,ans);
    printf("%d",Answer);
    return 0;
}
```

---

## 作者：mgzc (赞：1)

## [题面](https://www.luogu.org/problemnew/show/P2480)
[结合博客食用更佳](https://www.cnblogs.com/ztlztl/p/11087137.html)

## 题解

题目所求即为
$$
G ^ {\sum_{d | n}C_{n}^{d}} \bmod {999911659}
$$
考虑到有这样一个式子
$$
a ^ b \equiv a ^ {b \bmod \varphi(p)} \pmod p
$$
由于999911659是一个质数, 所以$\varphi(999911659) = 999911658$, 所以原式就变为了
$$
G^{\sum_{d | n} C_n^d \bmod 999911568} \bmod 999911659
$$
左边的东西只要求出$\sum_{d | n} C_n^d \bmod 999911568$即可快速幂, 所以题目转化为求左式

我们发现$999911568 = 2 * 3 * 4257 * 35617$, 恩, 组合数取模求和, 上$exLucas$板子即可

### Code

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdlib>
#include <cstdio>
#include <vector>
#define itn int
#define reaD read
#define Mod 999911659
#define int long long
using namespace std;

int n, m, mod[4] = { 2, 3, 4679, 35617 }, inv[4][50005], jc[4][50005], r[4]; 

inline int read()
{
	int x = 0, w = 1; char c = getchar();
	while(c < '0' || c > '9') { if (c == '-') w = -1; c = getchar(); }
	while(c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }
	return x * w;
}

int fpow(int x, int y)
{
	int res = 1;
	while(y)
	{
		if(y & 1) res = res * x % Mod;
		x = x * x % Mod;
		y >>= 1; 
	}
	return res; 
}

int exgcd(int a, int b, int &x, itn &y)
{
	if(!b) { x = 1; y = 0; return a; }
	int q = a / b, r = a % b, d = exgcd(b, r, y, x);
	y -= q * x; return d; 
}

itn C(int n, int m, int opt)
{
	if(m > n) return 0; if(m > n - m) m = n - m; 
	return 1ll * jc[opt][n] * inv[opt][m] % mod[opt] * inv[opt][(n - m)] % mod[opt]; 
}

int lucas(int n, int m, int opt)
{
	if(!m) return 1; 
	return 1ll * C(n % mod[opt], m % mod[opt], opt) * lucas(n / mod[opt], m / mod[opt], opt) % mod[opt]; 
}

int excrt()
{
	int p1 = mod[0], r1 = r[0]; 
	for(int j = 1; j < 4; j++)
	{
		int p2 = mod[j], r2 = r[j], x, y, d = exgcd(p1, p2, x, y); 
		x *= (r2 - r1) / d; p2 /= d; x = (x % p2 + p2) % p2;
		r1 = p1 * x + r1; p1 = p1 * p2; 
	}
	return r1; 
}

int exlucas()
{
	for(int i = 1; i * i <= n; i++)
		if(n % i == 0)
		{
			if(i * i == n) for(int j = 0; j < 4; j++) r[j] = 1ll * (r[j] + lucas(n, i, j)) % mod[j];
			else for(int j = 0; j < 4; j++) r[j] = 1ll * (r[j] + lucas(n, i, j) + lucas(n, n / i, j)) % mod[j]; 
		}
	return excrt(); 
}

signed main()
{
	n = read(); m = read();
	if(m % 999911659 == 0) { puts("0"); return 0; }
	for(int i = 0; i <= 3; i++)
	{
		inv[i][0] = inv[i][1] = 1; jc[i][0] = jc[i][1] = 1; 
		for(int j = 2; j < mod[i]; j++) inv[i][j] = 1ll * (mod[i] - mod[i] / j) * inv[i][mod[i] % j] % mod[i];
		for(int j = 2; j < mod[i]; j++) inv[i][j] = 1ll * inv[i][j - 1] * inv[i][j] % mod[i]; 
		for(int j = 2; j < mod[i]; j++) jc[i][j] = 1ll * jc[i][j - 1] * j % mod[i]; 
	}
	printf("%lld\n", fpow(m, exlucas())); 
	return 0;
}
```

---

## 作者：huayucaiji (赞：0)

我们首先来概括一下题意，其实就是给定 $n,g$，求：

$$g^{\sum_{k\nmid n} C_n^{\frac{n}{k}}}\operatorname{mod} 999911659$$

如果 $k\nmid n$，那么我们知道 $\frac{n}{k}\cdot k=n$，所以原式转化为：

$$g^{\sum_{k\nmid n} C_n^k}\operatorname{mod} 999911659$$

根据欧拉定理原式转化为：

$$g^{(\sum_{k\nmid n} C_n^k)\operatorname{mod} \varphi(999911659)}\operatorname{mod} 999911659$$

由于 $999911659$ 是一个质数，所以 $\varphi(999911659)=999911658$。原式可变为：

$$g^{(\sum_{k\nmid n} C_n^k)\operatorname{mod} 999911658}\operatorname{mod} 999911659$$

很明显思路就是用 $O(\sqrt{n})$ 的时间去找出 $k$，然后快速求解组合数，很明显，Lucas 定理失效了，我们就需要进行一些问题的转化。我们可以对 $999911658$ 进行质因数分解：$999911658=2\times 3\times4679\times 35617$。我们可以分别设：

$$\begin{cases}a_1={(\sum_{k\nmid n} C_n^k)\operatorname{mod} 2}\\a_2={(\sum_{k\nmid n} C_n^k)\operatorname{mod} 3}\\a_3={(\sum_{k\nmid n} C_n^k)\operatorname{mod} 4679}\\a_4={(\sum_{k\nmid n} C_n^k)\operatorname{mod} 35617}\end{cases}$$

用中国剩余定理（CRT）解决即可。

**注意特判 $g=mod$**

```cpp
//#pragma GCC optimize("Ofast","-funroll-loops","-fdelete-null-pointer-checks")
//#pragma GCC target("ssse3","sse3","sse2","sse","avx2","avx")
#include<bits/stdc++.h>
#define int long long
using namespace std;

int read() {
	char ch=getchar();
	int f=1,x=0;
	while(ch<'0'||ch>'9') {
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=x*10+ch-'0';
		ch=getchar();
	}
	return f*x;
}

const int mod=999911659,b[]={0,2,3,4679,35617};

int n,jc[50010],a[10],g,m[5];

int qpow(int x,int y) {
	int ret=1;
	while(y) {
		if(y&1) {
			ret*=x;
			ret%=mod;
		}
		x=x*x%mod;
		y>>=1;
	}
	return ret;
}

void exgcd(int a,int b,int &x,int &y) {
	if(b==0) {
		x=1;
		y=0;
		return ;
	}
	exgcd(b,a%b,x,y);
	
	int x2=y;int y2=x-a/b*y;
	x=x2;y=y2;
}
int gcd(int a,int b) {
	return b==0? a:gcd(b,a%b);
}

int inv(int q,int p) {
	int x,y;
	int g=gcd(q,p);
	q/=g;p/=g;
	exgcd(q,p,x,y);
	return (x+p)%p;
}

int calc(int n,int m,int p) {
	if(m>n) {
		return 0;
	}
	return jc[n]*inv(jc[m],p)%p*inv(jc[n-m],p)%p;
}

int c(int n,int m,int p) {
	if(m==0) {
		return 1;
	}
	return c(n/p,m/p,p)*calc(n%p,m%p,p)%p;
}

signed main() {
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	n=read();g=read();
	
	if(g==mod) {
		cout<<0<<endl;
		return 0;
	} 
	
	int nn=sqrt(n);
	for(int j=1;j<=4;j++) {
		jc[0]=1;
		for(int i=1;i<=b[4]+1;i++) {
			jc[i]=jc[i-1]*i%b[j];
		}
		for(int i=1;i<=nn;i++) {
			if(n%i==0) {
				a[j]+=c(n,i,b[j]);
				a[j]+=c(n,n/i,b[j]);
			}
		}
	}
	
	for(int i=1;i<=4;i++) {
		m[i]=(mod-1)/b[i];
	}
	int ans=0;
	for(int i=1;i<=4;i++) {
		ans+=a[i]*m[i]%(mod-1)*inv(m[i],b[i])%(mod-1);
	}
	ans%=(mod-1);
	
	cout<<qpow(g,ans)%mod<<endl;

	//fclose(stdin);
	//fclose(stdout);
	return 0;
}

```

---

## 作者：chihik (赞：0)

$$ g^{\sum_{d|n}C_{n}^{n/d}} \mod 999911659$$

$$g^{\sum_{d|n}C_{n}^{d}} \mod 999911659$$

因为 $999911659$ 是一个质数，由欧拉定理推论得

$$g^{\sum_{d|n}C_{n}^{d} \mod 999911658} \mod 999911659$$

现在考虑求出指数部分，模数为 $999911658=2 \times 3 \times 4679 \times 35617$

发现质因数的指数都为 $1$ , 其实就是特殊的扩展卢卡斯定理。只需要对每个质数分别计算后用中国剩余定理合并


```
#include <cstdio>
// #define int long long

const int MAXN = 35617 , Mod = 999911659;
int n , g;
int a[ 5 ] , p[ 5 ]= { 0 , 2 , 3 , 4679 , 35617 };

int Quick_pow( int x , int po , int p = Mod ) {
	int Ans = 1;
	for( ; po ; po >>= 1 , x = 1ll * x * x % p )
		if( po & 1 ) Ans = 1ll * Ans * x % p;
	return Ans;
}
int Exgcd( int a , int b , int &x , int &y ) {
	if( !b ) {
		x = 1 , y = 0;
		return a;
	}
	int r = Exgcd( b , a % b , y , x );
	y -= x * ( a / b );
	return r; 
}
int Inverse( int x , int p ) {
	int u , v;
	Exgcd( x , p , u , v );
	return ( u % p + p ) % p;
}
int Fac[ MAXN + 5 ] , Inv[ MAXN + 5 ];
void Init( int p = Mod ) {
	Fac[ 0 ] = 1;
	for( int i = 1 ; i <= p - 1 ; i ++ )
		Fac[ i ] = 1ll * Fac[ i - 1 ] * i % p;	
	Inv[ p ] = 0; Inv[ p - 1 ] = Inverse( Fac[ p - 1 ] , p );
	for( int i = p - 1 ; i >= 1 ; i -- )
		Inv[ i - 1 ] = 1ll * Inv[ i ] * i % p;
}
int C( int n , int m , int p = Mod ) {
	if( n < m ) return 0;
	return 1ll * Fac[ n ] * Inv[ m ] % p * Inv[ n - m ] % p;
}
int Lucas( int n , int m , int p = Mod ) {
	if( m == 0 || m == n ) return 1;
	return 1ll * C( n % p , m % p , p ) * Lucas( n / p , m / p , p ) % p;
}
int CRT( int *a , int *p ) {
	int Ans = 0 , Ps = 1 , P[ MAXN + 5 ];
	for( int i = 1 ; i <= 4 ; i ++ ) Ps *= p[ i ];
	for( int i = 1 ; i <= 4 ; i ++ ) {
		P[ i ] = Ps / p[ i ];
		Ans = ( Ans + (__int128)P[ i ] * Inverse( P[ i ] , p[ i ] ) % Ps * a[ i ] % Ps ) % Ps;
	}
	return ( Ans + Ps ) % Ps;
}

int main( ) {
	scanf("%d %d",&n,&g);
	if( g == Mod ) return printf("0") & 0;
	for( int i = 1 ; i <= 4 ; i ++ ) {
		Init( p[ i ] );
		for( int j = 1 ; j * j <= n ; j ++ )
			if( n % j == 0 )
				a[ i ] = ( a[ i ] + Lucas( n , j , p[ i ] ) + ( j * j == n ? 0 : Lucas( n , n / j , p[ i ] ) ) ) % p[ i ];
	}
	printf("%d\n", Quick_pow( g , CRT( a , p ) ) );
	return 0;
}
```

---

## 作者：StudyingFather (赞：0)

容易看出本题要求的是：

$$
G^{\sum_{k\mid n}\binom{n}{k}} \bmod 999\ 911\ 659
$$

分两种情况讨论：

1. $G=999\ 911\ 659$，显然答案为 $0$。
2. $G\neq 999\ 911\ 659$，由欧拉定理可知，我们要求的是：

$$
G^{\sum_{k\mid n}\binom{n}{k} \bmod 999\ 911\ 658} \bmod 999\ 911\ 659
$$

所以我们重点考虑如何计算：

$$
\sum_{k\mid n}\binom{n}{k} \bmod 999\ 911\ 658
$$

因为 $999\ 911 \ 658$ 不是质数，无法保证 $\forall x \in [1,999\ 911\ 658]$，$x$ 都有逆元存在，因此上面的式子我们无法直接按照组合数定义计算。

试着把模数分解一下，发现 $999\ 911 \ 658=2 \times 3 \times 4679 \times 35617$，其中每个质因子的最高次数都为一。

这个性质启发我们求出 $\sum_{k\mid n}\binom{n}{k}$ 分别对 $2$，$3$，$4679$，$35617$ 取模的结果，最后利用 [中国剩余定理](https://oi-wiki.org/math/crt/) 合并结果。

也就是说，我们实际上要求下面一个线性方程组的解：

$$
\begin{cases}
x \equiv a_1 \pmod 2\\
x \equiv a_2 \pmod 3\\
x \equiv a_3 \pmod {4679}\\
x \equiv a_4 \pmod {35617}
\end{cases}
$$

而计算一个组合数对较小的质数取模后的结果，可以利用 [卢卡斯定理](https://oi-wiki.org/math/lucas/)。

```cpp
// Problem : P2480 [SDOI2010]古代猪文
// Contest : Luogu
// URL : https://www.luogu.com.cn/problem/P2480
// Memory Limit : 125 MB
// Time Limit : 1000 ms
// Powered by CP Editor (https://github.com/cpeditor/cpeditor)

#include <cstring>
#include <iostream>
#define MOD 999911658
using namespace std;
//999911658=2*3*4679*35617
const int p[]={0,2,3,4679,35617};
int n,g;
long long f[50005],invf[50005];
long long fpow(long long x,long long y,long long p)
{
 long long ans=1;
 while(y)
 {
  if(y&1)ans=ans*x%p;
  x=x*x%p;
  y>>=1;
 }
 return ans;
}
long long C(int x,int y,int p)
{
 if(x<y)return 0;
 return f[x]*invf[y]%p*invf[x-y]%p;
}
long long Lucas(int x,int y,int p)
{
 if(x==0)return 1;
 return C(x%p,y%p,p)*Lucas(x/p,y/p,p)%p;
}
long long calc(int p)
{
 f[0]=invf[0]=1;
 for(int i=1;i<p;i++)
  f[i]=f[i-1]*i%p;
 invf[p-1]=fpow(f[p-1],p-2,p);
 for(int i=p-2;i;i--)
  invf[i]=invf[i+1]*(i+1)%p;
 long long sum=0;
 for(int i=1;i*i<=n;i++)
  if(n%i==0)
  {
   sum=(sum+Lucas(n,i,p))%p;
   if(i*i!=n)sum+=(Lucas(n,n/i,p))%p;
  }
 return sum;
}
int main()
{
 cin>>n>>g;
 long long ans=0;
 if(g==MOD+1)
 {
  cout<<0<<endl;
  return 0;
 }
 for(int i=1;i<=4;i++)
 {
  long long x=calc(p[i]),y=MOD/p[i],invy=fpow(y,p[i]-2,p[i]);
  ans=(ans+x*y%MOD*invy)%MOD;
 }
 cout<<fpow(g,ans,MOD+1)<<endl;
 return 0;
}
```

---

## 作者：suxxsfe (赞：0)

[P2480 [SDOI2010]古代猪文](https://www.luogu.com.cn/problem/P2480)  

比较综合的一题  
前置：[Lucas 定理](https://www.cnblogs.com/suxxsfe/p/12527265.html)，[crt](https://www.cnblogs.com/suxxsfe/p/12527101.html)  

求的是：  

$$g^x\bmod 999911659,\text{其中}x=\sum_{d\mid n}\tbinom{n}{d}$$  

由于这个$999911659$是质数，肯定于$g$互质，所以由欧拉定理很容易证明：  

$$a^{\varphi(p)}\equiv 1\pmod p\Rightarrow a^{k\bmod \varphi(p)}\equiv a^k\pmod p$$  

那么可以得出：  

$$g^x\bmod 999911659\equiv g^{x\bmod \varphi(999911659)}\pmod {999911659}$$  
$$g^x\bmod 999911659\equiv g^{x\bmod 999911658}\pmod {999911659}$$  

所以问题转换为求：  

$$\sum_{d\mid n}\tbinom{n}{d}\bmod 999911658$$  

这种大组合数的问题考虑用 Lucas，但是模数太大，且不是质数  
所以考虑将它分解：$999911658=2\times 3\times 4679\times 35617$  
那么，只需要对每一个质因数，求出$a\equiv \sum_{d\mid n}\tbinom{n}{d}\bmod p_i$，然后再用 crt 合并就行了  

算的时候，枚举每一个$i\le \sqrt n$，如果$i\mid n$，则计算$\tbinom{n}{i}$和$\tbinom{n}{\frac{n}{i}}$加到答案里  
但是，在这种因数不能重复计算的时候，要：  
```cpp
for(reg int i=1;i*i<=n;i++)
```  
而不是  
```cpp  
for(reg int i=1;i<=std::ceil(std::sqrt(n));i++)
```  
对于后一种，举个栗子：$\lceil\sqrt {420}\rceil=21$，但是如果$i$一直枚举到$21$，就会在$i=20,i=21$的时候算两次$20,21$这两个因数，重复了，出现错误  

还有，因为每次的计算模数不同，所以要分别预处理  

```cpp  
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<map>
#include<iomanip>
#include<cstring>
#define reg register
#define EN std::puts("")
#define LL long long
inline int read(){
	register int x=0;register int y=1;
	register char c=std::getchar();
	while(c<'0'||c>'9'){if(c=='-') y=0;c=std::getchar();}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=std::getchar();}
	return y?x:-x;
}
const int prime[4]={2,3,4679,35617};
int fac[40006],inv[40005];
inline int power(int a,int b,int p){
	int ret=1;
	while(b){
		if(b&1) ret=1ll*ret*a%p;
		b>>=1;a=1ll*a*a%p;
	}
	return ret;
}
inline void pre(int n,int mod){
	fac[0]=inv[0]=1;
	for(reg int i=1;i<n;i++) fac[i]=(LL)fac[i-1]*i%mod;
	inv[n-1]=power(fac[n-1],mod-2,mod);
	for(reg int i=n-2;i;i--) inv[i]=(LL)inv[i+1]*(i+1)%mod;
}
inline int get_C(int n,int m,int mod){
	//C(n,m)=n!/(m!*(n-m)!)
	if(n<m) return 0;
	return ((LL)fac[n]*inv[m]%mod)*inv[n-m]%mod;
}
inline int lucas(int n,int m,int mod){
	if(n<m) return 0;
	if(!n||!m) return 1;
	return (LL)lucas(n/mod,m/mod,mod)*get_C(n%mod,m%mod,mod)%mod;
}
int main(){
//	std::freopen("out.txt","w",stdout);
	const int M=999911658;
	int n=read(),g=read();
	g%=(M+1);
	if(!g) return std::puts("0"),0;
	reg int ans=0,Mi,t;
	for(reg int o=0;o<4;o++){
		pre(prime[o],prime[o]);
		reg int nowans=0;
		for(reg int i=1;i*i<=n;i++)if(!(n%i)){
			nowans=(nowans+lucas(n,i,prime[o]))%prime[o];
			if(i*i!=n) nowans=((LL)nowans+lucas(n,n/i,prime[o]))%prime[o];
		}
//			std::printf("now ans = %d\n",nowans);
//			for(reg int i=0;i<prime[o];i++) std::printf("%d %d\n",fac[i],inv[i]);
		Mi=M/prime[o];
		t=power(Mi,prime[o]-2,prime[o]);//t=Mi^{-1} mod prime[o]
		ans=(ans+((LL)nowans*Mi%M*t%M))%M;
	}
	std::printf("%d",power(g,ans,M+1));
	return 0;
}
```

---

## 作者：Gauss0320 (赞：0)

## 题目描述
求
$$\large q^{\sum_{d|n}{n\choose d}}$$
在模999911659意义下的值
## 题目解析
令$P=999911659$，由欧拉定理的推论可知：
$$\large q^{\sum_{d|n}{n\choose d}}\equiv q^{\sum_{d|n}{n\choose d}\ {\rm mod}\ (P-1)}\pmod {P}$$
先将$P-1$进行质因分解
$$P-1=2×3×4679×35617$$
由于$P-1$是一个free sqaure number，所以我们可以用Lucas定理求解出$\sum_{d|n}{n\choose d}$分别在模$2,3,4679,35617$意义下的值，再用中国剩余定理将其合并得到指数，最后用快速幂求解得到答案。
## 代码
```cpp
#include <cstdio>

const int mod[] = {2, 3, 4679, 35617};
const int P = 999911658, N = 40000;
int q, n, fac[N];

long long pow(long long a, int b, int p) {
	long long res = 1;
	while(b) {
		if(b & 1) res = res * a % p;
		a = a * a % p;
		b >>= 1;
	}
	return res;
}
long long Comb(int n, int m, int p) {
	if(n < m) return 0;
	return fac[n] * pow(fac[m] * fac[n - m] % p, p - 2, p) % p;
}
long long Lucas(int n, int m, int p) {
	if(!m) return 1;
	return Comb(n % p, m % p, p) * Lucas(n / p, m / p, p) % p;
}
void init(int p) {
	fac[0] = 1;
	for(int i = 1; i <= p; i++)
		fac[i] = fac[i - 1] * i % p;
}
long long solve(int n, int p) {
	init(p);
	long long res = 0;
	for(int i = 1; i * i <= n; i++) {
		if(n % i == 0) {
			res = (res + Lucas(n, i, p)) % p;
			if(n / i != i)
				res = (res + Lucas(n, n / i, p)) % p;
		}
	}
	return res;
}
long long CRT(int n) {
	long long res = 0;
	for(int i = 0; i < 4; i++)
		res = (res + solve(n, mod[i]) * pow(P / mod[i], mod[i] - 2, mod[i]) % P * (P / mod[i]) % P) % P;
	return res;
}
int main()
{
	scanf("%d %d", &n, &q);
	if(q % (P + 1) == 0) printf("0\n");
	else printf("%lld\n", pow(q, CRT(n), P + 1));
	return 0;
}
```


---


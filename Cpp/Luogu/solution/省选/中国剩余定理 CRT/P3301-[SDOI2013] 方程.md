# [SDOI2013] 方程

## 题目描述

给定方程
$x_1+x_2+\dots +x_{n}=m$。

我们对第 $1 \sim n_1$ 个变量进行一些限制： $x_{1} \le a_{1},x_{2} \le a_{2},\dots, x_{n_1} \le a_{n_1}$。

我们对第 $n_1+1\sim n_1+n_2$ 个变量进行一些限制： $x_{n_1+1} \ge a_{n_1+1},x_{n_1+2} \ge a_{n_1+2},\dots,x_{n1+n2} \ge a_{n_1+n_2}$。

求：在满足这些限制的前提下，该方程正整数解的个数。答案可能很大，请输出对 $p$ 取模后的答案。

## 说明/提示

**【样例解释】**

对于第一组数据，三组解为 $(1,3,2)，(1,4,1),(2,3,1) $。  
对于第二组数据，六组解为 $(1,1,3),(1,2,2),(1,3,1),(2,1,2),(2,2,1),(3,1,1)$。

![](https://cdn.luogu.com.cn/upload/pic/17621.png)

对于 $100\%$ 的数据，$1\le T \le 5$，$1\le m, n \le 10^9$，$1 \le a_i \le m$，$0 \le n_1,n_2 \le \min(8, m)$ 且 $n_1 + n_2 \le n$，$1\le p \le 437367875$。

## 样例 #1

### 输入

```
3 10007
3 1 1 6
3 3
3 0 0 5

3 1 1 3
3 3
```

### 输出

```
3
6
0
```

# 题解

## 作者：peterwuyihong (赞：12)

你一眼看出来是一个母函数的题目，于是你列出这么一个柿子

$$[x^m]\prod_{i=1}^{n_1}(x+x^2+\ldots+x^{A_{i}})\prod_{i=n_1+1}^{n_1+n_2}(x^{A_i}+x^{A_i+1}+\ldots)\prod_{i=n_1+n_2+1}^n(1+x+\ldots)$$

$$=[x^{m-\sum_{i=n_1+1}^{n_1+n_2}A_i-1}](\frac{x}{1-x})^{n-n_1}\prod_{i=1}^{n_1}(x+x^2+\ldots+x^{A_{i}})$$

然后你发现 $m$ 很大，于是你使用亿些科技

现在是 $14:02$ ，我看我什么时候写完

现在是 $19:33$ ，我写完了

```cpp
#define int long long
int ksm(int a,int b,int p){
	int ans=1;
	for(;b;b>>=1,a=a*a%p)
	if(b&1)ans=ans*a%p;
	return ans;
}
int _exgcd(int a,int b,int &x,int &y){
  if(!b){x=1,y=0;return a;}
  int d=_exgcd(b,a%b,y,x);
  y-=a/b*x;return d;
}
int _exCRT(int b[],int a[],int n){
	int ans=0,g,c,x,y,lcm=1;for(int i=1;i<=n;i++){
		g=_exgcd(lcm,a[i],x,y);c=(b[i]-ans)%a[i];c=(c+a[i])%a[i];
    if(c%g)return -1;x=((x*c/g)%(a[i]/g)+(a[i]/g))%(a[i]/g);
    ans=ans+x*lcm;lcm=lcm*a[i]/g;ans=(ans%lcm+lcm)%lcm;
  }return ans;
} 
int _inv(int x,int p){int a,b;_exgcd(x,p,a,b);return (a+p)%p;}
int f[300000];
int _calc(int n,int x,int p){
	if(n==0)return 1;int ans=ksm(f[p],n/p,p);
	for(int i=n/p*p+1;i<=n;i++)
	if(i%x)ans=i%p*ans%p;return ans*_calc(n/x,x,p)%p;
}
int _mutilucas(int n,int m,int x,int p){
	if(n<m)return 0;
	int cnt=0;for(int i=n;i;i/=x)cnt+=i/x;
	for(int i=m;i;i/=x)cnt-=i/x;for(int i=n-m;i;i/=x)cnt-=i/x;
	f[0]=1;
	for(int i=1;i<=p;i++)if(i%x)f[i]=f[i-1]*i%p;else f[i]=f[i-1];
	return ksm(x,cnt,p)*_calc(n,x,p)%p*_inv(_calc(m,x,p),p)%p*_inv(_calc(n-m,x,p),p)%p;
}
int T,p,n,n1,n2,m;
int A[20],x;
int solve(int n,int m,int x,int p){
	int ans=0;
	for(int i=0;i<1<<n1;i++){
			int cc=n,op=(__builtin_popcount(i)&1)?-1:1;
			for(int j=0;j<n1;j++)
			if(i>>j&1)cc-=A[j];
			ans=(ans+p+op*_mutilucas(cc,m,x,p))%p;
	}
	return ans;
}
int a[20],b[20],c[20],cnt=0;
void shai(int p){
	for(int i=2;i*i<=p;i++)
	if(p%i==0){b[++cnt]=1;c[cnt]=i;while(p%i==0)p/=i,b[cnt]*=i;}
	if(p>1)b[++cnt]=p,c[cnt]=p;
}
int exlucas(int n,int m,int p){
	if(n<m)return 0;
	for(int i=1;i<=cnt;i++)a[i]=solve(n,m,c[i],b[i]);
	return _exCRT(a,b,cnt);
}
signed main(){
#ifndef ONLINE_JUDGE
	freopen("testdata.in","r",stdin);
#endif
	for(cin>>T>>p,shai(p);T;T--){
		cin>>n>>n1>>n2>>m;
		for(int i=0;i<n1;i++)cin>>A[i];
		for(int i=0;i<n2;i++)cin>>x,m-=x-1;
		cout<<exlucas(m-1,n-1,p)<<endl;
	}
#ifndef ONLINE_JUDGE
	cerr<<endl<<(double)clock()/CLOCKS_PER_SEC;
#endif
}
```
你发现这个多项式很美妙，但是 $m\le10^9$ ，于是你毅然弃疗。

然后你发现中间的 $n_2$ 个东西很简单，在多项式里你就直接意识到可以用 $m$ 减掉，然后就变成了一般情况，一般情况就直接转化为插板法。

此时你发现上面的 $n_1$ 个玩意儿很难，于是你想起了 [$\text{devin}$](https://www.luogu.com.cn/user/156004) 说的考虑容斥，全部转化为一般情况。

几个不满足一式，几个不满足二式，几个不满足一式二式，加加减减。

还有容斥可以直接在 $\text{exlucas}$ 里做就行了。

然后你一交， $\text{70pts TLE}$ 。

于是你开始卡常，你在 $\text{calc}$ 中预处理阶乘，因为要多次用到，然后质因数提前分解，因为全局 $p$ 相等。

不论怎么说你要坚信复杂度跑不满， $O(2^{n_1}n^2_1)\times$ 扩展卢卡斯复杂度。如果想做得更好好像可以用 $\text{dfs}$ 优化掉一个 $O(n^2_1)$

---

## 作者：kkksx (赞：12)

### 扩展卢卡斯定理模板题

对于第二类限制$x_i\geq a_i$，将$m$减去$a_i-1$，即$x_i\geq 1$

对于第一类限制$x_i\leq a_i$，由于限制数很少可以容斥：不满足条件即$x_i\geq a_i+1$，当成第二类限制做即可，除了不满足条件的之外的$x_i$都是任意选

每个情况用插板法求解为$C_{nowm-1}^{n-1}\% p$，由于$p$不是质数，需要用扩展卢卡斯定理，码量瞬间多了几十排qwq

#### Code

```cpp
#include<bits/stdc++.h>
#define Min(x,y) ((x)<(y)?(x):(y))
#define Max(x,y) ((x)>(y)?(x):(y))
using namespace std;
typedef long long ll;
int T,n1,n2;
ll n,m,p,a[20],f[1000005];

template <class T>
void read(T &x)
{
	char c; int sign=1;
	while((c=getchar())>'9'||c<'0') if(c=='-') sign=-1; x=c-48;
	while((c=getchar())>='0'&&c<='9') x=(x<<1)+(x<<3)+c-48; x*=sign;
}
ll quickpow(ll a,ll b,ll mod)
{
	ll ret=1;
	while(b)
	{
		if(b&1) ret=ret*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ret;
}
ll exgcd(ll a,ll b,ll &x,ll &y)
{
	if(!b) { x=1; y=0; return a; }
	ll d=exgcd(b,a%b,x,y);
	ll t=x; x=y; y=t-a/b*y;
	return d;
}
ll inv(ll a,ll p)
{
	ll x,y;
	exgcd(a,p,x,y);
	return (x%p+p)%p;
}
ll fac(ll n,ll pi,ll pk)
{
	if(!n) return 1LL;
	if(n<pi) return f[n];
	return quickpow(f[pk-1],n/pk,pk)*f[n%pk]%pk*fac(n/pi,pi,pk)%pk;
}
ll C(ll n,ll m,ll pi,ll pk)
{
	if(n<m) return 0;
	f[0]=1;
    for(int i=1;i<=pk;i++)
      if(i%pi!=0) f[i]=f[i-1]*i%pk;
        else f[i]=f[i-1];
	ll jn=fac(n,pi,pk),jm=fac(m,pi,pk),jnm=fac(n-m,pi,pk);
	int k=0;
	for(ll i=n;i;i/=pi) k+=i/pi;
	for(ll i=m;i;i/=pi) k-=i/pi;
	for(ll i=n-m;i;i/=pi) k-=i/pi;
	return jn * inv(jm,pk)%pk * inv(jnm,pk)%pk * quickpow(pi,k,pk)%pk;
}
ll crt(ll a,ll pk)
{
	ll x=p/pk;
	return a*x%p*inv(x,pk)%p;//关于pk的逆元 
}
ll solve(ll n,ll m,ll pi,ll pk)
{
	ll ret=0;
	for(int i=0,t=(1<<n1);i<t;++i)
	{
		int opt=1;
		ll nown=n;
		for(int j=0;j<n1;++j)
		  if(i>>j&1) 
		    opt=-opt,nown-=a[j+1];
		ret=(ret+opt*C(nown,m,pi,pk))%pk;
	}
	return ret;
}
ll exlucas(ll n,ll m,ll P)
{
	if(n<m) return 0;
	ll ret=0;
	for(ll i=2;i*i<=P;++i)
	{
		if(P%i==0)
		{
			ll pk=1;
			while(P%i==0)
			{
				pk*=i;
				P/=i;
			}
			ret=(ret+crt(solve(n,m,i,pk),pk))%p;
		}
	}
	if(P!=1) ret=(ret+crt(solve(n,m,P,P),P))%p;
	return (ret%p+p)%p;
}
int main()
{
	read(T);read(p);
	while(T--)
	{
		read(n);read(n1);read(n2);read(m);
		for(int i=1;i<=n1+n2;++i) read(a[i]);
		for(int i=n1+1;i<=n1+n2;++i) m-=(a[i]-1);
		printf("%lld\n",exlucas(m-1,n-1,p));
	}
	return 0;
}
```

---

## 作者：ezoixx118 (赞：5)

[洛谷链接](https://www.luogu.org/problemnew/show/P3301)  
[bzoj链接](https://www.lydsy.com/JudgeOnline/problem.php?id=3129)  
[更好的阅读体验](https://blog.csdn.net/ezoixx118/article/details/86715791)
### 题目大意
给一个不定方程 $\sum_{i=1}^{n}x_i=m$($x_i>1$，$x_i\in N^+$)，求方程的解的数量，并满足：
当$0< i\leq n1$时，$x_i\leq a_i$
当$n1< i\leq n1+n2$时，$x_i\geq a_i$
($n1+n2\leq n\leq 10^9$，$m\leq10^9$，$0\leq n1,n2\leq 8$)
答案对$P$取模，$P\in \{10007,262203414,437367875\}$，多组询问
### 解法
练习容斥，exLucas好题
若只有第二种限制就很好办，插板法即可，答案是$$\binom{m-\sum_{i=n1}^{n1+n2}(a_i-1)-1}{n-1}$$
考虑到n1很小，可以容斥，用一共的答案-大于$a_i$的答案+两两重复部分-三三重复部分......(具体见代码)
出题人毒瘤，模数不是质数，要用exLucas
btw：$262203414=2*3*11*397*1007,437367875=5^3*7^3*101^2$
### 代码

```
//#pragma GCC optimize(3)
#include<iostream>
#include<iomanip>
#include<stack>
#include<queue>
#include<list>
#include<vector>
#include<set>
#include<string>
#include<algorithm>
#include<complex>
#include<cmath>
#include<cstdio>
#include<cstring>
#define ull unsigned long long
#define ll long long
#define db long double
#define inf 100002
#define infm 1000009
#define INF (int)1e9
//#define mod 100000007LL
#define pi acos(-1)
#define rd(n) {n=0;char ch;int f=0;do{ch=getchar();if(ch=='-'){f=1;}}while(ch<'0'||ch>'9');while('0'<=ch&&ch<='9'){n=(n<<1)+(n<<3)+ch-48;ch=getchar();}if(f)n=-n;}
using namespace std;

ll Qpow(ll x,ll k,ll mod){
    ll ans=1LL;
    while(k){
        if (k&1){
            ans=ans*x%mod;
        }
        x=x*x%mod;
        k/=2;
    }
    return ans;
}

ll exgcd(ll n,ll m,ll &X,ll &Y){
    if (!m){
        X=1,Y=0;
        return n;
    }
    ll g=exgcd(m,n%m,Y,X);
    Y-=X*(n/m);
    return g;
}

ll getinv(ll x,ll mod){
	ll X,Y;
	exgcd(x,mod,X,Y);
    return (X%mod+mod)%mod;
}

ll f[inf];

ll fact(ll x,ll base,ll mod){
    if (x<base){
    	return f[x];
	}
    ll ans=Qpow(f[mod-1],x/mod,mod)*f[x%mod]%mod*fact(x/base,base,mod)%mod;
    return ans;
}

ll C(ll n,ll m,ll base,ll mod){
	f[0]=1;
	for (int i=1;i<=mod;i++){
		if (i%base!=0){
			f[i]=f[i-1]*i%mod;
		}
		else{
			f[i]=f[i-1];
		}
	}
    ll cnt=0;
    for (int i=n;i;i/=base){
        cnt+=i/base;
    }
    for (int i=m;i;i/=base){
        cnt-=i/base;
    }
    for (int i=n-m;i;i/=base){
        cnt-=i/base;
    }
    return Qpow(base,cnt,mod)*fact(n,base,mod)%mod*getinv(fact(m,base,mod),mod)%mod*getinv(fact(n-m,base,mod),mod)%mod;
}

ll mod;
ll ele[10],tms[10];
int ecnt;
ll w[10];

ll Cal(ll n,ll m){
	if (n<m){
		return 0;
	}
    for (int i=1;i<=ecnt;i++){
        ll P=Qpow(ele[i],tms[i],mod+1);
        w[i]=C(n,m,ele[i],P);
    }
    ll ans=0;
    for (int i=1;i<=ecnt;i++){
        ll P=Qpow(ele[i],tms[i],mod+1);
        ll tmp=mod/P,X,Y;
        exgcd(tmp,P,X,Y);
        ans=(ans+X*tmp%mod*w[i]%mod)%mod;
    }
    return (ans+mod)%mod;
}

ll n,m;
ll a[10];
int cnt;

ll IEP(int pos,ll now,int f){
    if (pos==cnt+1){
        return Cal(now-1,n-1)*f;
    }
    ll ans=0;
    ans=IEP(pos+1,now,f);
    if (now>=a[pos]){
    	ans=(ans+IEP(pos+1,now-a[pos],-f))%mod;
	}
    return ans;
}

int main(){
    int task;
    rd(task) rd(mod)
    if (mod==10007){
        ecnt=1;
        ele[1]=mod;
        tms[1]=1;
    }
    else if (mod==262203414){
        ecnt=5;
        ele[1]=2,ele[2]=3,ele[3]=11,ele[4]=397,ele[5]=10007;
        tms[1]=1,tms[2]=1,tms[3]=1,tms[4]=1,tms[5]=1;
    }
    else{
        ecnt=3;
        ele[1]=5,ele[2]=7,ele[3]=101;
        tms[1]=3,tms[2]=3,tms[3]=2;
    }
    ll n1,n2;
    for (int t=1;t<=task;t++){
        rd(n) rd(n1) rd(n2) rd(m)
        ll x;
        for (int i=1;i<=n1;i++){
            rd(a[i])
        }
        for (int i=1;i<=n2;i++){
            rd(x)
            if (x){
            	m-=x-1;
			}
        }
        if (m<n1){
        	puts("0");
        	return 0;
		}
        cnt=n1;
        printf("%lld\n",(IEP(1,m,1)+mod)%mod);
    }
    return 0;
}
```






---

## 作者：___kd (赞：3)

# P3301 [SDOI2013] 方程
首先考虑如果没有限制条件，答案显然为  $	{n-1\choose m-1}$ 。 
再来考虑限制条件二，我们可以转化为求  $x_{n1+i}-a_{x1+i}+1>0$ 的构造方案。针对条件一，我们无法直接求得，考虑容斥，用整体方案数去掉不合法方案数即可。

本题的难点主要在于 $p$ 不是质数，无法直接求逆元，考虑拓展卢卡斯，再略微记忆化卡常即可。 


```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int T,P,n,n1,n2,m,mod,tot;
map<pair<int,int>,int> mp;
struct node
{
	int x,y;
}cnt[1000005];
int a[1000005],p[1000005],ans[1000005];
int ksm(int x,int y,int p)
{
	int sum=1;
	while(y)
	{
		if(y&1) sum=sum*x%p;
		x=x*x%p;
		y>>=1;
	}
	return sum;
}//快速幂 
int fac(int x,int p,int pk)
{
	int tmp=1;
	if(!x) return 1;
	if(mp.count({p,pk})) tmp=mp[{p,pk}];
	else{
		for(int i=1;i<pk;i++)
			if(i%p)
				tmp=tmp*i%pk;
		mp[{p,pk}]=tmp;
	}//记忆化 
	tmp=ksm(tmp,x/pk,pk);
	int maxn=x%pk;
	for(int i=1;i<=maxn;i++)
		if(i%p)
			tmp=tmp*i%pk;
	return tmp*fac(x/p,p,pk)%pk;
}//求n!的阶乘去掉所有p的因子在模pk意义下大小 
void exgcd(int a,int b,int &x,int &y)
{
	if(!b)
	{
		x=1,y=0;
		return ;
	}
	int xx,yy;
	exgcd(b,a%b,xx,yy);
	x=yy;
	y=xx-a/b*yy;
}//拓展欧拉函数，即求a*x+p*y=1中x,y大小 
int inv(int a,int p)
{
	int x,y;
	exgcd(a,p,x,y);
	return (x%p+p)%p;
}//求逆元 
int C(int a,int b,int p,int pk)
{
	if(a<b) return 0;
	int f1=fac(a,p,pk),f2=fac(b,p,pk),f3=fac(a-b,p,pk),tmp=0,flag=a-b;
	while(a) tmp=tmp+a/p,a=a/p;//寻找a!阶乘中p因子个数 
	while(b) tmp=tmp-b/p,b=b/p;
	while(flag) tmp=tmp-flag/p,flag=flag/p;
	return f1%pk*inv(f2,pk)%pk*inv(f3,pk)%pk*ksm(p,tmp,pk)%pk;
}
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch<='9'&&ch>='0')x=x*10+ch-'0',ch=getchar();
	return x*f;
}//快读 
int exlucas(int n,int m,int p)
{
	int total=0;
	swap(n,m);
	if(n<m) return 0;
	if(!m) return 0;
	for(int i=1;i<=tot;i++)
		ans[i]=C(n,m,cnt[i].x,cnt[i].y);
	for(int i=1;i<=tot;i++)
		total=(total+ans[i]*(mod/cnt[i].y)%mod*inv(mod/cnt[i].y,cnt[i].y)%mod)%mod;//中国剩余定理（CRT） 
	return total;
}
signed main()
{
	T=read();P=read();
	mod=P;
	for(int i=2;i<=P;i++)
	{
		int now=1;
		while(P%i==0)
			P=P/i,now=now*i;
		if(now>1) cnt[++tot]=((node){i,now});
	}
	if(P>1) cnt[++tot]=((node){P,P});//预处理p的因子 
	P=mod;
	int sum=0,sum1=0,w=0,total=0;
	while(T--)
	{
		sum=0,sum1=0,w=0,total=0;
		n=read();n1=read();n2=read();m=read();
		for(int i=1;i<=n1;i++) a[i]=read();
		for(int i=1;i<=n2;i++) m=m-read()+1;
		int len=(1<<n1);
		for(int i=0;i<len;i++)
		{
			int flag=0,tmp=m;
			for(int j=0;j<n1;j++)
				if(i&(1<<j))
					flag++,tmp-=a[j+1];
			if(flag&1) total=(total-exlucas(n-1,tmp-1,P)+mod)%mod;
			else total=(total+exlucas(n-1,tmp-1,P))%mod;
		}//容斥原理 
		printf("%lld\n",total);
	}
	return 0;
}
```

---

## 作者：gyh20 (赞：3)

扩展卢卡斯+容斥

如果没有两种限制条件，答案显然为 $\tbinom{m-1}{n-1}$ （隔板法）。

考虑两种情况应分别如何处理。

第二种是很简单的，直接将 $m$ 减去 $a_i-1$ 即可（这样将 $x_i \geq a_i$ 转为了 $x_i \geq 1$）。

第一种稍微复杂一点，因为插板法无法解决小于号，所以可以用合法情况 $-$ 不合法情况，可以枚举出每一种情况然后容斥。

然而这道题 $n,m$ 很大， $p$ 不一定是质数，需要扩展卢卡斯求解。

常数可能较大，可以使用记忆化/提前分解等优化方法，具体可以看代码。

```cpp
#pragma GCC optimize(2,3,4,5)
#include<bits/stdc++.h>
#define re register
#define int long long
using namespace std;
inline int read(){
	re int t=0;
	re char v=getchar();
	while(v<'0')v=getchar();
	while(v>='0')t=(t<<3)+(t<<1)+v-48,v=getchar();
	return t;
}
inline int ksm(re int x,re int y,re int M){
	int sum=1;
	while(y){
		if(y&1)sum=sum*x%M;
		x=x*x%M;
		y>>=1;
	}
	return sum;
}
inline void exgcd(re int a,re int b,re int &x,re int &y){
	if(!b){
		x=1;
		y=0;
		return;
	}
	exgcd(b,a%b,x,y);
	int t=x;
	x=y,y=t-a/b*y;
}
inline int inv(re int n,re int M){
	if(!n)return 0;
	re int a=n,b=M,x,y;
	exgcd(a,b,x,y);
	x=(x%b+b)%b;
	if(!x)x+=b;
	return x;
}
int jyh[100002],jyh1[100002];
inline int mul(re int x,re int pi,re int pk){
	if(!x)return 1;
	re int ans=1;
	if(x>=pk){
		if(jyh[pk])ans=jyh[pk];
		else {
		for(re int i=2;i<=pk;++i)if(i%pi)ans=ans*i%pk;}
		jyh[pk]=ans;
		ans=ksm(ans,x/pk,pk);
	}
	for(re int i=2;i<=x%pk;++i)
	if(i%pi)ans=ans*i%pk;
	return ans*mul(x/pi,pi,pk)%pk;
}
inline int C(re int n,re int m,re int M,re int pi,re int pk){
	if(m>n)return 0;
	re int a=mul(n,pi,pk),b=mul(m,pi,pk),c=mul(n-m,pi,pk),k=0,ans;
	for(re int i=n;i;i/=pi)k+=i/pi;
	for(re int i=m;i;i/=pi)k-=i/pi;
	for(re int i=n-m;i;i/=pi)k-=i/pi;
	ans=a*inv(b,pk)%pk*inv(c,pk)%pk*ksm(pi,k,pk)%pk;
	return ans*(M/pk)%M*inv(M/pk,pk)%M;
}
int ans,n1,a[107];
inline void work(re int x,re int y,re int n,re int m,re int p,re int i,re int pk){
	if(x==n1+1){
		if(y&1)ans-=C(n,m,p,i,pk);
		else ans+=C(n,m,p,i,pk);
		ans%=p;
		return;
	}
	work(x+1,y,n,m,p,i,pk);
	work(x+1,y+1,n-a[x],m,p,i,pk);
}
inline void calc(re int n,re int m,re int p){
	if(p==262203414)work(1,0,n,m,p,2,2),work(1,0,n,m,p,3,3),work(1,0,n,m,p,11,11),work(1,0,n,m,p,397,397),work(1,0,n,m,p,10007,10007);
	else if(p==10007)work(1,0,n,m,p,10007,10007);
	else if(p==437367875)work(1,0,n,m,p,5,125),work(1,0,n,m,p,7,343),work(1,0,n,m,p,101,10201);
}
int n,n2,m,p;
signed main(){
	re int lsy_ak_ioi=read();p=read();
	while(lsy_ak_ioi--){
		n=read();n1=read();n2=read();m=read();
		for(re int i=1;i<=n1+n2;++i)a[i]=read();
		for(re int i=n1+1;i<=n1+n2;++i)m-=a[i]-1;
		swap(n,m);
		--n,--m;ans=0;calc(n,m,p);
		printf("%lld\n",ans<0?ans+p:ans);
	}
}
```


---

## 作者：nydry (赞：1)

由于插板法只能解决形如 $X_i\ge A_i$ 的限制，所以在计算时默认后 $n_2$ 个限制是满足的，重点解决前 $n_1$ 个限制。考虑使用容斥，每次去掉一部分不满足条件的解，问题变成如下形式：

已知方程 $\sum_{i=1}^n X_i=S$，给出 $m$ 条限制，第 $i$ 条限制要求 $X_i\ge A_i$，求正整数解的个数。

令 $T=\sum_{i=1}^m (A_i-1)$，则该问题的答案为 $C_{S-T-1}^{n-1}$，理解为：先拿掉 $T$ 个物品，再在剩下 $S-T-1$ 个空隙中插入 $n-1$ 个板子。用扩展卢卡斯定理即可求解。

[code](https://www.luogu.com.cn/paste/ve22lt0o)

---

## 作者：RNTBW (赞：0)

### PART 0

改了题解格式。

## PART 1

给出两个数组 $a,b$ 且长度为 $n1,n2$，求 $\sum_{i=1}^n x_i=m$ 且满足 $\forall i\in[1,n1],x_i\le a_i$ 以及 $\forall i\in [n1+1,n2],x_i\ge b_i$ 的序列 $x$ 的个数。

## PART 2

我们先解决一个问题：

如何解决 $\sum_{i=1}^n x_i=m$ 的解的个数？

我们可以想，把 $m$ 分解为几个 1，然后在 $m$ 个 1 中插入 $n-1$ 个板子分成 $n$ 份，每一份的 1 之和就是 $x_i$。

所以答案就是 $C_{m-1}^{n-1}$。

那么如何解决 $\sum_{i=1}^n x_i=m$ 且 $\forall i\in [1,n],x_i\ge a_i$ 呢？

我们可以对每个 $x_i$ 预分配 $a_i-1$，那么它们就只要 1 了，就转化为了上述问题。

所以答案为 $C_{m-1-\sum_{i=1}^n (a_i-1)}^{n-1}$。

那么我们便解决了 $[n1+1,n2]$ 区间内的取法。

但是 $[1,n1]$ 区间的要求是 $x_i\le a_i$ 怎么办呢？

## PART 3

我们可以用总方案减去不合法的方案，将它转化为 $x_i\ge a_i+1$ 的情况。

但是只需要满足一个位置就不合法，而我们之前的 $C_{m-1-\sum_{i=1}^n (a_i-1)}^{n-1}$ 是解决所有位置全部满足条件的。

考虑容斥，每次枚举状态，任意选择一些位置满足条件，剩下不满足条件的默认设为 $x_i\ge 1$。

还有一点，由于 $p$ 可能不是质数，但是 $p$ 只有 3 种取值，我们可以打表出每个模数的质因数并使用 [``exlucas``](https://www.luogu.com.cn/problem/P4720) 解决。

## PART 4

代码很恶心qwq....

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 100005
typedef long long ll;
ll fac[N][5],c[N],a[21],l[5]={0,1,5,3};
ll t,n,m,p,k,s,fir,sec,n1,n2,ans,pid;
ll pr[5][10]={
{0},
{0,10007},
{0,2,3,11,397,10007},
{0,5,7,101}
};
ll pk[5][10]={
{0},
{0,10007},
{0,2,3,11,397,10007},
{0,125,343,10201}
};//打表
ll qm_n(ll a,ll b,ll c)
{
	ll res=1;
	while(b)
	{
		if(b&1)res=res*a%c;
		a=a*a%c;b>>=1;
	}
	return res%c;
}
void init(ll id,ll p,ll pk)
{
	fac[0][id]=1;
	for(ll i=1;i<=pk;i++)
	{
		fac[i][id]=fac[i-1][id];
		if(i%p)fac[i][id]=fac[i][id]*i%pk;
	}
}
ll exgcd(ll a,ll b,ll &x,ll &y)
{
	if(!b)
	{
		x=1;y=0;
		return a;
	}
	ll d=exgcd(b,a%b,y,x);
	y-=(a/b)*x;
	return d;
}
ll inv(ll a,ll b)
{
	k=s=0;
	ll gcd=exgcd(a,b,k,s);
	return (k+b)%b;
}
ll G(ll n,ll p)
{
	if(!n)return 0;
	return n/p+G(n/p,p);
}
ll exlucas(ll n,ll p,ll id,ll pk)
{
	if(!n)return 1;
	ll res=qm_n(fac[pk][id],n/pk,pk);
	return exlucas(n/p,p,id,pk)*res%pk*fac[n%pk][id]%pk;
}
ll come_on(ll n,ll m,ll p,ll id,ll pk)
{
	ll k1=exlucas(n,p,id,pk);
	ll k2=inv(exlucas(m,p,id,pk),pk);
	ll k3=inv(exlucas(n-m,p,id,pk),pk);
	ll other=qm_n(p,G(n,p)-G(m,p)-G(n-m,p),pk);
	return k1*k2%pk*k3%pk*other%pk;
}
ll cnt(ll sec)
{
	ll wtf=1,res=0,x;
	ll now=m-(sec+fir)-1;
	if(now<n-1)return 0;
	for(ll i=1;i<=l[pid];i++) c[i]=come_on(now,n-1,pr[pid][i],i,pk[pid][i]),wtf*=pk[pid][i];
	for(ll i=1;i<=l[pid];i++) x=inv(wtf/pk[pid][i],pk[pid][i]),res=(res+x*(wtf/pk[pid][i])%p*c[i]%p)%p;
	return res;
}//计算exlucas
void dfs(ll x,ll y,ll t)
{
	if(x>n1)
	{
		
		ll now=cnt(y);
		if(t&1)ans=(ans-now+p)%p;
		else ans=(ans+now)%p;//容斥
		return;
	}
	dfs(x+1,y+a[x],t+1);
	dfs(x+1,y,t);
}//这里采用 dfs 枚举状态
int main()
{
	scanf("%lld%lld",&t,&p);
	if(p==10007)pid=1;
	if(p==262203414)pid=2;
	if(p==437367875)pid=3;
	for(ll i=1;i<=l[pid];i++) init(i,pr[pid][i],pk[pid][i]);//根据 exlucas，对于每个质因数我们都处理一遍阶乘及逆元
	while(t--)
	{
		scanf("%lld %lld %lld %lld",&n,&n1,&n2,&m);
		fir=ans=sec=0;
		for(ll i=1;i<=n1+n2;i++)
		{
			scanf("%lld",&a[i]);
			if(i>n1)fir+=a[i]-1;
		}//发现n1到n2的ai-1之和是不变的，先算出来
		dfs(1,0,0);
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：mango09 (赞：0)

[P3301 [SDOI2013]方程](https://www.luogu.com.cn/problem/P3301)

## Description

给定方程及不等式组
$$
\begin{cases}
x_1+x_2+\cdots+x_n=m\\
\\
x_1\le a_1\\
x_2\le a_2\\
\cdots\\
x_{n1}\le a_{n1}\\
\\
x_{n1+1}\ge a_{n1+1}\\
x_{n1+2}\ge a_{n1+2}\\
\cdots\\
x_{n1+n2}\ge a_{n1+n2}
\end{cases}
$$
请求出该方程组的正整数解的个数 $\bmod p$。

- 对于 $100\%$ 的数据：$n\le 10^9,n1\le 8,n2\le 8,m\le 10^9,p\le 437367875,T\le 5,1\le a_{1\dots n1+n2}\le m，n1+n2\le n$

## Solution

**前置芝士：**

- 基础的计数 + 组合知识

- `exLucas`

对于形如 $x_i\ge a_i$ 的，用小奥思路将 $m\gets m-(a_i-1)$，这时限制就变成了 $x_i\ge 1$，也就是去掉了限制。

对于形如 $x\le a_i$ 的，反面考虑 $x>a_i$，即 $x\ge a_i+1$，其它无限制的情况数，然后就和上面一样了。

注意一下容斥。

假设当前为 $nowm$，那么根据插板法，情况数就为 $C_{nowm-1}^{n-1}$ ，这里直接用 `exLucas` 即可。

时间复杂度为 $O(n1!\cdot p\log m)$。

但是你需要坚信它是跑不满的（

然后 $70$ 了。

亿些小优化：

- 提前分解 $p$

## Code

```cpp
//18 = 9 + 9 = 18.
#include <iostream>
#include <cstdio>
#define Debug(x) cout << #x << "=" << x << endl
#define int long long
using namespace std;

int qpow(int a, int b, int p)
{
	int base = a, ans = 1;
	while (b)
	{
		if (b & 1)
		{
			ans = ans * base % p;
		}
		base = base * base % p;
		b >>= 1;
	}
	return ans;
}

int fac[10];

int cal(int n, int p, int pos, int pa)
{
	if (!n)
	{
		return 1;
	}
	int ans = qpow(fac[pos], n / pa, pa);
	for (int i = 1; i <= n % pa; i++)
	{
		if (i % p)
		{
			ans = ans * i % pa;
		}
	}
	return ans * cal(n / p, p, pos, pa) % pa;
}

int cnt_p(int n, int m, int p)
{
	int cnt = 0;
	for (int i = p; i <= n; i *= p)
	{
		cnt += n / i;
	}
	for (int i = p; i <= m; i *= p)
	{
		cnt -= m / i;
	}
	for (int i = p; i <= n - m; i *= p)
	{
		cnt -= (n - m) / i;
	}
	return cnt;
}

int x, y;

void exgcd(int a, int b)
{
	if (!b)
	{
		x = 1, y = 0;
		return;
	}
	exgcd(b, a % b);
	int tmp = x;
	x = y;
	y = tmp - a / b * y;
}

int inv(int a, int p)
{
	exgcd(a, p);
	x = (x % p + p) % p;
	return x;
}

int C(int n, int m, int p, int pos, int pa)
{
	int a = cal(n, p, pos, pa), b = cal(m, p, pos, pa), c = cal(n - m, p, pos, pa), cnt = cnt_p(n, m, p);
	return a * inv(b, pa) % pa * inv(c, pa) % pa * qpow(p, cnt, pa) % pa;
}

int prime[10], a[10], b[10];

int CRT(int n)
{
	int m = 1;
	for (int i = 1; i <= n; i++)
	{
		m *= a[i];
	}
	int ans = 0;
	for (int i = 1; i <= n; i++)
	{
		int mi = m / a[i];
		int Mi = inv(mi, a[i]);
		ans = (ans + b[i] * mi % m * Mi % m) % m;
	}
	return ans;
}

int k;

void pre(int p)
{
	for (int i = 2; i * i <= p; i++)
	{
		if (p % i == 0)
		{
			prime[++k] = i;
			a[k] = 1;
			while (p % i == 0)
			{
				a[k] *= i;
				p /= i;
			}
		}
	}
	if (p > 1)
	{
		prime[++k] = p;
		a[k] = p;
	}
	for (int i = 1; i <= k; i++)
	{
		fac[i] = 1;
		for (int j = 1; j <= a[i]; j++)
		{
			if (j % prime[i])
			{
				fac[i] = fac[i] * j % a[i];
			}
		}
	}
}

int exLucas(int n, int m)
{
	if (n < m)
	{
		return 0;
	}
	for (int i = 1; i <= k; i++)
	{
		b[i] = C(n, m, prime[i], i, a[i]);
	}
	return CRT(k);
}

int p, n, n1, ans;
int w[20];

void dfs(int tot, int bound, int nega, int nowm)
{
//	Debug(nowm), Debug(nega);
//	Debug(exLucas(nowm - 1, n - 1, p));
	ans = (ans + nega * exLucas(nowm - 1, n - 1) + p) % p;
	if (tot > n1)
	{
		return;
	}
	for (int i = bound; i <= n1; i++)
	{
		dfs(tot + 1, i + 1, -nega, nowm - w[i]);
	}
}

signed main()
{
	int t;
	scanf("%lld%lld", &t, &p);
	pre(p);
	while (t--)
	{
		int n2, m;
		scanf("%lld%lld%lld%lld", &n, &n1, &n2, &m);
		for (int i = 1; i <= n1 + n2; i++)
		{
			scanf("%lld", w + i);
		}
		for (int i = 1; i <= n2; i++)
		{
			m -= (w[n1 + i] - 1);
		}
		ans = 0;
		dfs(1, 1, 1, m);
		printf("%lld\n", ans);
	}
	return 0;
}
```



---

## 作者：RootMirzayanov (赞：0)

 [题目传送门](https://www.luogu.com.cn/problem/P3301)

 ## 题意
 
 - 给定方程 $x_1+x_2+...+x_n=M$，并且解满足以下两个性质，求出对 p 取模后的该正整数解的个数。
 
 - 性质一：$x_1\le A_1,x_2\le A_2,...,x_{n1}\le A_{n1}$ 。
 
 - 性质二：$x_{n1+1}\ge A_{n1+1},x_{n1+2}\ge A_{n1+2},...,x_{n1+n2}\ge A_{n1+n2}$ 。
 
 ## 解析
 
 考虑到 $n_1,n_2\le 8$, 不合法情况较少，所以这里计算采用的方法是 `合法情况 - 不合法情况`。
 
无限制的合法情况数按照插板法易知为 $\operatorname{C}(n-1,m-1)$。

对于性质二的大于等于，只需要将 $m$ 减去 $\sum\limits_{i=n1}^{n1+n2}(a_i-1)$ 就可以将问题化为普通插排做，总数为$\operatorname{C}(n - 1,m-\sum_{i=n1}^{n1+n2}(a_i-1)-1)$。

性质一无法直接进行插排，因为 $n_1\le 8$，直接暴力容斥可行。如果不满足条件则 $m - a_i$，可以理解为将 $a_i$ 分给 $x_i$ 使 $x_i$ 不满足条件。

执行完所求式可化成 $\operatorname{C}(n-1,m_{final}-1) \bmod p$，这里参考了 [kkksk](https://www.luogu.com.cn/user/115482) 在此题题解的结论。

观察到 `p` 不是质数，而且 `p` 的质因数很小($262203414=2\times 3\times 11\times 397\times 1007$,$437367875=5^3\times 7^3\times 101^2$)，所以可以用 [`exLucas`](https://www.luogu.com.cn/problem/P4720)。

因为 `exLucas` 的时间复杂度为 $\operatorname{O}(p\log p)$，所以需要一些常数优化，例如快速阶乘取模，可以提前处理好 `p` 的质因子的阶乘。

---

## 作者：Stinger (赞：0)

如果没有任何限制，那么插板可得方案数就是 $\tbinom{n-1}{m-1}$。

对于大于等于的限制，这种情况直接把 $m$ 减去 $A_i-1$ 即可。

而小于等于的限制推了一波没搞出来什么东西，又注意到 $n$ 非常小（只有 $8$），所以直接枚举子集容斥。

容斥的方法是从考虑了大于等于限制的总方案数中减去**至少**有一个小于等于条件不满足的方案数，再加上**至少**有两个小于等于条件不满足的……最终答案写成式子就是（$m$ 已经减去了所有大于等于的限制的情况）：

$$\sum ((-1)^{\lvert S\rvert}\tbinom{n-1}{m-1-\sum\limits_{i\in S}A_i})$$

~~式子很显示出来很挤很丑，将就着看吧~~

$S$ 表示枚举的集合。

由于模数比较恶心，需要扩展卢卡斯。由于扩展卢卡斯是 $O(p\log p)$，结合枚举子集就是 $O(2^{n1}p\log p)$，加上多测显然过不去，但实际上扩卢时间复杂度很假很玄学，所以是能过的（

**关于常数**

值得一提的是，按照上面的做法直接写是过不去的（（（

扩卢预处理一下每个模数因子的阶乘就可以跑过去了。

```cpp
#include <cstdio>
#define int long long

int a[10005], b[10005], f[1005], len, id;

int qpow(int a, int b, int mod) {
	int ret = 1LL;
	while (b) {
		if (b & 1) ret = ret * a % mod;
		a = a * a % mod;
		b >>= 1;
	}
	return ret;
}
void exgcd(int a, int b, int &x, int &y) {
	if (!b) x = 1, y = 0;
	else exgcd(b, a % b, y, x), y -= a / b * x;
}
int inv(int a, int p) {
	int x, y;
	exgcd(a, p, x, y);
	x = (x % p + p) % p;
	if (!x) return p;
	return x;
}
int fact(int n, int p, int mod, int id) {
	if (!n) return 1;
	int sum = 1LL;
	sum = qpow(f[id], n / mod, mod);//本来f[id]是要算的，但由于预处理了就不用
	for (int i = 1; i <= n % mod; ++ i)
		if (i % p) sum = sum * i % mod;
	return sum * fact(n / p, p, mod, id) % mod;
}
int C(int n, int m, int p, int mod, int id) {
	if (n < m) return 0;
	if (!n || !m || n == m) return 1;
	int cnt = 0, k = n - m, ans;
	ans = fact(n, p, mod, id) * inv(fact(m, p, mod, id), mod) % mod * inv(fact(k, p, mod, id), mod) % mod;
	while (n) n /= p, cnt += n;
	while (m) m /= p, cnt -= m;
	while (k) k /= p, cnt -= k;
	ans = ans * qpow(p, cnt, mod) % mod;
	return ans;
}

int CRT() {
	int ans = 0LL, sum = 1LL;
	for (int i = 1; i <= len; ++ i) sum *= a[i];
	for (int i = 1; i <= len; ++ i) {
		int m = sum / a[i] * inv(sum / a[i], a[i]) % sum;
		ans = (ans + b[i] * m % sum) % sum;
	}
	return ans;
}

int exLucas(int n, int m, int p) {
	if (n <= 0 || n < m) return 0;
	len = 0;
	int k = 1, id = 0;
	while (p != 1) {
		++ k;
		if (p % k) continue;
		int cnt = 0, mod = 1LL;
		while (p % k == 0) ++ cnt, p /= k, mod *= k;
		a[++ len] = mod, b[len] = C(n, m, k, mod, ++ id);
	}
	return CRT();
}

void init(int p) {
	int k = 1;
	while (p != 1) {
		++ k;
		if (p % k) continue;
		int cnt = 0, mod = 1LL;
		while (p % k == 0) ++ cnt, p /= k, mod *= k;
		++ id;
		f[id] = 1LL;
		for (int i = 1; i <= mod; ++ i)
			if (i % k) f[id] = f[id] * i % mod;//预处理阶乘
	}
}
int A[10];

signed main() {
	int T, p;
	scanf("%lld%lld", &T, &p);
	init(p);
	while (T --) {
		int n, n1, n2, m, ans = 0;
		scanf("%lld%lld%lld%lld", &n, &n1, &n2, &m);
		for (int i = 1; i <= n1; ++ i) scanf("%lld", A + i);
		for (int i = 1; i <= n2; ++ i) {
			int x;
			scanf("%lld", &x);
			m -= x - 1;
		}
		for (int S = 0; S < 1 << n1; ++ S) {
			int cnt = 0, tmp = m;
			for (int i = 1; i <= n1; ++ i)
				if (S & 1 << i - 1) ++ cnt, tmp -= A[i];
			ans = (ans + (cnt & 1 ? -1 : 1) * exLucas(tmp - 1, n - 1, p)) % p;
		}
		printf("%lld\n", (ans + p) % p);
	}
	return 0;
}
```

---


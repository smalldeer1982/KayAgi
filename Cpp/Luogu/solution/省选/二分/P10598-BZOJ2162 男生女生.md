# BZOJ2162 男生女生

## 题目背景

题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。

---

雨荨的班主任安远老师是一个非常严厉的老师。到了大学，男生和女生之间难免会出现一些暧昧关系，但这样显然是影响学习的。所以作为艾利斯顿的一块招牌，安远老师当然要拒绝这种现象的出现以及繁衍。

所以每当安远老师发现一个男生和一个女生放学走在一起或者男女生之间互相传纸条等，他就会立马制止并且通知家长。他也要求所有男女生晚上八点之后必须关手机，并且不定期打电话检查。于是安远老师的学生都感慨：这货不是大学，不是大学。

## 题目描述

安远老师的学生里，一共有 $n$ 个男生和 $n$ 个女生，编号都以 $1\sim n$ 编号。有 $m$ 对男女生之间有暧昧关系。现在安远老师想找出这样一个男女生群体，每个男生都和每个女生之间有暧昧关系，并且男女生总数最大。注意，男生数目或者女生数目可以为 $0$。

如果有多个这样的群体，安远老师会选择男生最多的那个群体，因为他觉得男生会很不安分。如果这样的群体依然不唯一，他会选择任意一个。

接下来，安远老师从选出的这个群体的所有暧昧关系中，选出 $k$ 个进行调查，使得这个群体的所有男生和女生，都至少和其中的一对暧昧关系有关系（即是这个暧昧关系的男/女主人公）。安远老师想让你告诉他总方案数除以 $19921228$ 的余数是多少。

## 说明/提示

对于所有数据，$1\leq n \leq 50$，$1\leq m,k \leq 2500$。同一对暧昧关系不会在输入中出现多次。

## 样例 #1

### 输入

```
3 2 
4
1 1
1 2
2 1
2 2```

### 输出

```
2 2
2```

# 题解

## 作者：myee (赞：7)

### 前言

发现洛谷把 bzoj 题给搬了过来，所以我把当时写的题解传过来了。

其实就一缝合题，没啥意思。

---
### 第一问

考虑对补图跑**二分图带权最大独立集**。

这一部分可以通过一个人类智慧的网络最大流实现。

```plain
0           ->    1  - n        101

1   -   n   ->   n+1 - 2n       inf, 当且仅当补图上有该边时连边

n+1 -  2n   ->    2n+1          100
```

跑从源点 $S=0$ 到汇点 $T=2n+1$ 的最大流，即**最小割**。

然后就可以计算出男生、女生人数了。

$101$ 与 $100$ 是为了保证男生数目尽量多。

如下图是样例。

![样例](https://cdn.luogu.com.cn/upload/image_hosting/6xkmv4hk.png)

---

### 第二问

记 $n$ 个男生，$m$ 个女生的该图中任意挑 $k$ 条边的方案数为 $f_{n,m}=\binom{nm}{k}$，其中符合题目条件的选法有 $g_{n,m}$ 种。

则显然有

$$
f_{n,m}=\sum_{a,b}\binom na\binom mbg_{a,b}
$$

由**二维二项式反演**，我们得到

$$
g_{n,m}=\sum_{a,b}\binom na\binom mb(-1)^{n+m-a-b}f_{a,b}
$$

即答案为

$$
\sum_{a,b}\binom na\binom mb\binom{ab}k(-1)^{n+m-a-b}
$$

直接做就好了。

---

### Code

码头去掉了。

```cpp
Dinic D;
bol E[55][55];
modint C[5005][5005];
int main()
{
#ifdef MYEE
    freopen("QAQ.in","r",stdin);
#endif
    uint n,k,m;
    scanf("%u%u%u",&n,&k,&m);
    D.build((n+1)<<1);
    for(uint i=1;i<=n;i++)D.insert(0,i,101),D.insert(i+n,n<<1|1,100);
    for(uint i=1;i<=n;i++)for(uint j=1;j<=n;j++)E[i][j]=true;
    while(m--){uint u,v;scanf("%u%u",&u,&v),E[u][v]=false;}
    for(uint i=1;i<=n;i++)for(uint j=1;j<=n;j++)if(E[i][j])D.insert(i,j+n,-1);
    ullt w=201llu*n-D.run(0,n<<1|1);
    uint a=w%100;
    uint b=w/100-a;
    printf("%u %u\n",a,b);
    AnyMod::ChgMod(19921228);
    C[0][0]=1;
    for(uint i=1;i<=5000;C[i][0]=1,i++)for(uint j=1;j<=i;j++)C[i][j]=C[i-1][j-1]+C[i-1][j];
    modint ans;
    for(uint i=0;i<=a;i++)for(uint j=0;j<=b;j++)
        ((i^j)&1)?ans-=C[a][i]*C[b][j]*C[(a-i)*(b-j)][k]:ans+=C[a][i]*C[b][j]*C[(a-i)*(b-j)][k];
    ans.println();
    return 0;
}
```

---

## 作者：wangziyue_AK (赞：3)

# 前言：
我作为一名蒟蒻，斗胆为 myee 大佬解释一下这题玄学的网络流建图方式，希望能帮助大家理解。
# 正文：
看到此题男生女生类似二分图的东西，以及二分图匹配一样的第一问，外加奇怪的限制，可以想到**网络流(最大流最小割)**。
### 建图理由：
这题的主要限制是所有男生和女生都是一个暧昧关系的男/女主人公，即没有暧昧关系的一对男女不能同时选择，则我们可以把没有暧昧关系的一对男女连一条**容量为 $\infty$ 的边**，这样最小割时一定会割掉该边两端的点中的一个。要选择尽量多的男生和女生，则原点向每个男生连边，每个女生向汇点连边，边被割断则说明他/她被删去。接下来的部分就比较**人类智慧**：要选择尽量多的男生，则删去男生的代价就要比删去女生的代价大 $1$，同时留 $49$ 名男生的方案应劣于留 $50$ 女生，而此题最多多选五十名男生，则最多多出 $50$ 的代价，若普通边容量为 $100$ 即可保证割最少的人。
### 具体建图方案：
原点向表示男生的 $1$ 号点至 $n$ 号点连一条容量为 $101$ 的边。
对补图上的每条边(原图中没有的边)连一条容量为 $\infty$ 的边，表示女生的 $n+1$ 号至 $2n$ 号节点向汇点连一条容量为 $100$ 的边。
### 数学部分：
这是二维二项式反演，我就不误人子弟了，推荐大家去看 myee 的题解。
## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=205;
const int M=5005;
const int inf=1e7+5;
const int p=19921228;
int n,k,m,s,t,hd[N],cnt=1;
struct xx{
	int to,w,nx;
}e[M*2];
inline void add(int u,int v,int w){
	++cnt,e[cnt].to=v,e[cnt].w=w,e[cnt].nx=hd[u],hd[u]=cnt;
}
inline void addE(int u,int v,int w){
	add(u,v,w),add(v,u,0);
}
int dep[N];
queue<int> q;
bool bfs(){
	for(int i=1;i<=n;i++) dep[i]=0;
	q.push(s);dep[s]=1;
	while(!q.empty()){
		int u=q.front();
		//printf("333 %d %d %d %d\n",u,hd[u],e[hd[u]].to,e[hd[u]].w);
		q.pop();
		for(int i=hd[u];i;i=e[i].nx){
			int v=e[i].to;
			if(e[i].w&&!dep[v]){
				dep[v]=dep[u]+1,q.push(v);
			}
		}
	}
	return dep[t]==0?0:1;
}
int dfs(int u,int in){
	int now=in;
	if(u==t) return now; 
	int out=0;
	for(int i=hd[u];i&&now;i=e[i].nx){
		int v=e[i].to;
		if(e[i].w&&dep[v]==dep[u]+1){
			int res=dfs(v,min(now,e[i].w));
			e[i].w-=res,e[i^1].w+=res;
			now-=res,out+=res;
		}
	}
	if(!out) dep[u]=0;
	return out;
}
int Dinic(){//网络流板子
	int res=0;
	while(bfs()) res+=dfs(s,inf);
	return res;
}
bool g[55][55];
int c[2505][2505];
void init(){
//由于模数不是质数，只能用递推处理组合数 
	c[0][0]=1;
	for(int i=1;i<=2501;i++){
		c[i][0]=1;
		for(int j=1;j<=i;j++){
			c[i][j]=(c[i-1][j]+c[i-1][j-1])%p;
		}
	}
}
int main(){
	scanf("%d%d%d",&n,&k,&m);
	s=0,t=n*2+1; //源点和汇点 
	int u,v;
	for(int i=1;i<=m;i++){
		scanf("%d%d",&u,&v);
		g[u][v]=1;
	}
	for(int i=1;i<=n;i++) addE(s,i,101),addE(n+i,t,100); 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(!g[i][j]) addE(i,n+j,inf);
		}
	}//以上是建图 
	n=n*2+1;
	int res=Dinic();
	int a1=res%100;
//一个男生101，则男生个数为最大流除以100的余数 
	int a2=res/100-a1;
//女生人数为总删去的人数减去删去的男生人数 
	n=(n-1)>>1;
	a1=n-a1,a2=n-a2;//总人数减去删去的人数 
	printf("%d %d\n",a1,a2);
	init();
	int ans=0;
	for(int i=0;i<=a1;i++){//数学部分计算方案数 
		for(int j=0;j<=a2;j++){
			res=(1ll*c[a1][i]*c[a2][j])%p;
			res=(1ll*res*c[(a1-i)*(a2-j)][k])%p;
			if((i^j)&1) ans=(ans-res+p)%p;
			else ans=(ans+res)%p;
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：1)

[Problem Link](https://www.luogu.com.cn/problem/P10598)

**题目大意**

> 给定左右各 $n$ 个点 $m$ 条边的二分图，求最大的完全二分子图，存在多个求左部点数最多的一个。
>
> 求在这张子图选出 $k$ 条边后，每个点至少有一条出边被选的方案数。
>
> 数据范围：$n\le 50,m,k\le n^2$。

**思路分析**

第一问等价于反图最大独立集，最大化左部点数可以将左部点点权设为 $n+1$，右部点点权设为 $n$，求出最大权闭合子图，跑最大流即可。

第二问只关心前一问求出的左右部点集大小 $x,y$，容斥两边空点数量得到答案为：
$$
\sum_{i=0}^x\sum_{j=0}^y(-1)^{i+j}\binom xi\binom yj\binom{(x-i)(y-j)}{k}
$$
时间复杂度 $\mathcal O(\mathrm{Flow}(n,m)+k^2)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=1e9;
namespace F {
const int MAXV=205,MAXE=2e5+5;
struct Edge {
	int v,f,lst;
}	G[MAXE];
int S,T,tot=1,hd[MAXV],cur[MAXV],dep[MAXV];
void init() { tot=1,memset(hd,0,sizeof(hd)); }
void adde(int u,int v,int w) { G[++tot]={v,w,hd[u]},hd[u]=tot; }
void link(int u,int v,int w) { adde(u,v,w),adde(v,u,0); }
bool BFS() {
	memcpy(cur,hd,sizeof(cur)),memset(dep,-1,sizeof(dep));
	queue <int> Q;
	Q.push(S),dep[S]=0;
	while(!Q.empty()) {
		int u=Q.front(); Q.pop();
		for(int i=hd[u];i;i=G[i].lst) if(G[i].f&&dep[G[i].v]==-1) {
			dep[G[i].v]=dep[u]+1,Q.push(G[i].v);
		}
	}
	return ~dep[T];
}
int dfs(int u,int f) {
	if(u==T) return f;
	int r=f;
	for(int i=cur[u];i;i=G[i].lst) {
		int v=G[cur[u]=i].v;
		if(G[i].f&&dep[v]==dep[u]+1) {
			int g=dfs(v,min(r,G[i].f));
			if(!g) dep[v]=-1;
			G[i].f-=g,G[i^1].f+=g,r-=g;
		}
		if(!r) return f;
	}
	return f-r;
}
int Dinic() {
	int f=0;
	while(BFS()) f+=dfs(S,inf);
	return f;
}
}
using F::link;
bool g[55][55];
const int MOD=19921228;
int C[2505][2505];
signed main() {
	int n,m,k;
	scanf("%d%d%d",&n,&k,&m);
	for(int i=1,u,v;i<=m;++i) scanf("%d%d",&u,&v),g[u][v]=true;
	int s=F::S=2*n+1,t=F::T=2*n+2;
	for(int i=1;i<=n;++i) link(s,i,101),link(i+n,t,100);
	for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) if(!g[i][j]) link(i,j+n,inf);
	int ans=201*n-F::Dinic();
	int x=ans%100,y=ans/100-x;
	printf("%d %d\n",x,y);
	int tot=x*y;
	for(int i=0;i<=tot;++i) for(int j=C[i][0]=1;j<=i;++j) {
		C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD;
	}
	int cnt=0;
	for(int i=0;i<=x;++i) for(int j=0;j<=y;++j) if((x-i)*(y-j)>=k) {
		int w=1ll*C[(x-i)*(y-j)][k]*C[x][i]%MOD*C[y][j]%MOD;
		if((i+j)&1) cnt=(cnt+MOD-w)%MOD;
		else cnt=(cnt+w)%MOD;
	}
	printf("%d\n",cnt);
	return 0;
}
```

---

## 作者：Eric998 (赞：0)

我咋秒了。

第一问：最大团就是反图独立集。设选了 $i$ 个男生，$j$ 个女生，则要求 $s=\{i+j,1\}$，按字典序排序的最大值。这种问题考虑给 $i$ 一个略大于 $j$ 的权值并且跑最大权独立集。给每个男生赋值 $k+1$，给每个女生赋值 $k$，答案即为最大权独立集的权值 $w$ 带余除掉 $k$。$k>50$ 即可。

第二问：套路地考虑一个容斥。我们设 $f_{i,j}$ 为答案，$g_{i,j}$ 为选 $i$ 个男生 $j$ 个女生不连边的方案数。用脚二项式反演。

---


# 异界之门

## 题目背景

跟随着线索，莲子来到了七夕坂。无暇欣赏此处的风景，高速运转着大脑的莲子，不断寻找异界的线索。翻转的地藏、奇异的裂缝、被隐匿的第五个季节……这个禁忌之中的世界，正向她揭晓着自己的秘密。

但莲子第一时间看到的只有梅莉，来不及思考，她一把抓住了梅莉的手——

## 题目描述

嗅觉敏锐的莲子察觉到，进入异界的方法一定和这些特别的地藏有所联系。她发现它们恰好构成了一棵形状特殊的树。

给定一棵 $n$ 个点的带点权的**有根**树，其根为 $1$，且点 $i$ 的点权为 $w_i$。**其满足对于任意两个深度相同的结点，它们的儿子数也相同**。

为了进入异界，莲子进行了一些操作来改变这棵树的点权：

1. 选择一条边，假设它连接了两点 $(u,v)$，设其中深度更高者为 $u$（即 $u$ 是 $v$ 的儿子），将 $w_u$ 加上 $w_v$。
2. 上述操作可以被执行任意多次，但是**不能重复选择同一条边**。

经过操作后，莲子求出了树的某个 [DFS 序列](https://oi-wiki.org/graph/dfs/)，并记录下了这个 DFS 序列所对应的点权序列 $c$（具体来说，$c_i$ 为 DFS 序过程中遍历到的第 $i$ 个点的点权）。

不幸的是，她突然忘记了她进行过哪些操作，也忘记了如何 DFS 这棵树，她希望你能还原出任意一组合法的操作方案与 DFS 序列。

## 说明/提示

### 样例解释

#### 样例 \#1

![](https://cdn.luogu.com.cn/upload/image_hosting/ihq8vqnc.png)

其中一种可行的方案是依次操作边 $(2,3),(3,4),(1,2)$，操作后的树的点权序列为 $\{1,3,5,9\}$，选出的 DFS 序列为 $\{1,2,3,4\}$。

注意到该样例符合特殊性质 $\mathbf{A}$。

#### 样例 \#2

![](https://cdn.luogu.com.cn/upload/image_hosting/z14j0aeu.png)

其中一种可行的方案是依次操作边 $(1,2),(3,5),(1,3)$，操作后的树的点权序列为 $\{1,0,0,3,3\}$，选出的 DFS 序列为 $\{1,2,4,3,5\}$。
#### 样例 \#3

![](https://cdn.luogu.com.cn/upload/image_hosting/7livbzzu.png)

其中一种可行的方案是依次操作边 $(1,2)$，操作后的树的点权序列为 $\{1,3,3,4\}$，选出的 DFS 序列为 $\{1,4,2,3\}$。

注意到该样例符合特殊性质 $\mathbf{B}$。
#### 样例 \#4

![](https://cdn.luogu.com.cn/upload/image_hosting/9bopbeh3.png)

其中一种可行的方案是依次操作边 $(1,2),(2,4),(3,5),(1,3)$，操作后的树的点权序列为 $\{1,2,3,2,2\}$，选出的 DFS 序列为 $\{1,3,5,2,4\}$。

注意到该样例符合特殊性质 $\mathbf{C}$。

### 数据范围

**本题采用捆绑测试。**

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|}\hline
\textbf{Subtask} & \textbf{\textsf{分值}} & \bm{n\le } & \textbf{\textsf{特殊性质}}&\textbf{Subtask \textsf{依赖}}\cr\hline
1 & 10 & 6 & - &-\cr\hline
2 & 10 & 100 & \mathbf{A}&- \cr\hline
3 & 10 & 100 & \mathbf{B}&- \cr\hline
4 & 15 & 2\times 10^3 & \mathbf{C}&-  \cr\hline
5 & 15 & 2\times 10^3 & \mathbf{D}&-  \cr\hline
6 & 15 & 100 & -&1,2,3  \cr\hline
7 & 25 & 2\times 10^3 & -&1,2,3,4,5,6  \cr\hline
\end{array}
$$

特殊性质 $\mathbf{A}$：保证给出的树满足 $f_i=i-1$ ($i\ne 1$)。\
特殊性质 $\mathbf{B}$：保证给出的树满足 $f_i=1$ ($i\ne 1$)。\
特殊性质 $\mathbf{C}$：保证给出的树满足 $w_i=1$。\
特殊性质 $\mathbf{D}$：保证给出的树满足所有非叶节点儿子数不超过 $2$。

对于所有数据满足：$1\le n\le 2000$，$-10^8\le w_i\le 10^8$，$-10^{14}\le c_i\le 10^{14}$。

## 样例 #1

### 输入

```
4
0 1
1 2
2 3
3 4
1 3 5 9```

### 输出

```
3
3 4 2
1 2 3 4```

## 样例 #2

### 输入

```
5
0 1
1 -1
1 -1
2 3
3 4
1 0 3 0 3```

### 输出

```
3
2 5 3
1 2 4 3 5```

## 样例 #3

### 输入

```
4
0 1
1 2
1 3
1 4
1 4 3 3```

### 输出

```
1
2
1 4 2 3```

## 样例 #4

### 输入

```
5
0 1
1 1
1 1
2 1
3 1
1 2 2 2 3```

### 输出

```
4
2 4 5 3
1 3 5 2 4```

# 题解

## 作者：dspt (赞：5)

## 前言

一道考查二分图最大匹配的好题，遗憾没有场切。

题目分为两个部分，分别是构造 DFS 序和构造操作方案。

&nbsp;
## 构造 DFS 序

根据 DFS 序的性质，我们知道一棵子树的 DFS 序是连续的。如果我们钦定了点 $p$ 在 DFS 序中为第 $i$ 个点，那么子树 $p$ 对应的 DFS 序即为 $[i,i+s_p-1]$（ $s_p$ 表示子树 $p$ 的大小），可以预处理得到。

这启示我们设计一个 DP，$f_{p,i}=0/1$ 表示子树 $p$ 能否与 DFS 序 $[i,i+s_p-1]$ 匹配，答案就是 $f_{1,1}$。这是一个**树形 DP** 的形式，考虑如何由孩子的信息合并到根。本题有一个很关键的性质：**其满足对于任意两个深度相同的结点，它们的儿子数也相同**（也就是说深度相同的点子树大小相同）。我们再想想 $f_{p,i}=1$ 意味着什么。对 $p$ 而言，该点的点权可以为 $w_p,w_p+f_p,w_p+c_{a_{f_p}}$（ $a_{f_p}$ 表示 $f_p$ 在 DFS 序中的位置），这三者中只要有一个等于 $c_i$ 即可；对 $u$ 而言（令 $u$ 是 $p$ 的某个孩子），$u$ 需要确定一个排名 $j$（即它在 $p$ 的儿子中第 $j$ 个被遍历到）满足 $f_{u,i+1+(j-1)s_u}=1$。也就是说我们要找一组孩子和排名**一一对应**的关系。容易想到**二分图匹配**。设 $p$ 有 $k$ 个孩子，对于孩子 $u$，计算 $f_{u,i+1+(j-1)s_u}(1\leqslant j\leqslant k)$，如果 $f_{u,i+1+(j-1)s_u}=1$，则在二分图上在左部点 $u$ 和右部点 $j$ 之间连一条边。一一对应的关系就是二分图上的**完美匹配**！也就是说，我们把 $f_{p,i}=0/1$ 转化成了构造出的二分图是否有完美匹配。因为后面还要构造方案，这里采用**匈牙利算法**，比较方便。

每次求出 $f_{p,i}$ 后，我们把 DFS 孩子的顺序存在一个 `vector` 中。我们从根节点开始构造答案，先把 $p$ 放入答案 DFS 序，再按照 `vector`中的顺序递归求解 $f_{u,i+1+(j-1)s_u}$ 即可。

上述做法时间复杂度分析困难。有两个角度可以优化：把匈牙利算法换成最大流；计算 $f_{p,i}$ 可能重复多次，可以记忆化；但实际上都不需要，可以直接通过。

&nbsp;
## 构造操作方案

 上部分说了，每个点的点权可以有 $w_p,w_p+f_p,w_p+c_{a_{f_p}}$ 三种情况。第一种情况显然不用操作，第二种情况应该在 $f_p$ 操作前操作，第三种情况应该在 $f_p$ 操作后操作。

于是我们可以维护一个 `deque`，先按 DFS 序的顺序判断每个点 $p$ 是否满足第二种情况，如果满足则 `push_front`。第三种情况则可以用 BFS，把已经满足条件的点放入`queue`中，每次取出队首 $p$，遍历每个 $p$ 的孩子 $u$，判断其是否满足第三种情况，如果满足则 `push_back` 并放入队列中。

这部分时间复杂度是 $O(n)$。

&nbsp;
## 后记

#20 数据好强，我跑了 869ms，其余点都短于 100ms。

好像还有一种不用二分图最大匹配的很厉害的做法，但是我不会。

祝大家 NOI 2024 RP++！

---

## 作者：chen_zhe (赞：5)

首先这个改变树的点权的操作长的很怪。不妨假设树没有被操作，我们先考虑 dfs 序的部分。

树的子树对应 dfs 序上的一个区间，所以对于每棵子树，我们只需要知道它是否对应 dfs 序上的某个区间即可。对于正常的树，我们难以在多项式复杂度内去求解这个关系，但幸运的是本题的树形态特殊。

我们令 $f_{i,j}$ 表示以 $i$ 为根的子树是否对应 dfs 序中从 $j$ 开始的长度为子树大小的区间。对于树的叶子，求出这种东西是十分容易的，接下来我们试着从叶子开始逐层转移上去。对于节点 $i$，我们假设它的子树已经求解出了所有的对应关系，而它现在要解出和某个区间 $[l,r]$ 的对应关系。由于它的所有子树大小相同，所以不管它以何种顺序遍历子树，这些子树需要对应的区间都是确定的，也就是从 $l+1$ 开始等分成 $i$ 的儿子数个的区间。这样，我们就可以把“子树 $x$ 可以对应从 $y$ 开始的区间”这样的信息，视作一条二分图的边，那么判定对应关系本质上就是求解二分图是否有完美匹配。于是我们可以用二分图匹配+动归的方式解决该问题。

接下来考虑操作的事情。容易发现这个操作只和若干级祖先有关，所以可以在 dp 中再记录祖先级数。但是这样会导致很多信息没有利用上，因为我们在匹配的过程中明明需要同时钦定每个点被操作后的点权。如果一个节点的原点权为 $w_1$，它的父亲的原点权为 $w_2$，它的父亲操作后点权变成了 $w_3$，那么这个节点操作后的点权要么是 $w_1$，要么是 $w_1+w_2$，要么是 $w_1+w_3$！于是我们只需要暂时不匹配子树根节点的权值，等到钦定了其父节点操作后的点权后再看是否能够匹配即可。

可以证明由于本题树结构的特殊性，本题完整做法的时间复杂度与进行单次匹配的复杂度同级，为 $n^{2.5}$。但是卡到这个复杂度需要及其特殊的树形态（如菊花图），而这样又会大幅缩减进行匹配的常数，所以本题的做法实际上常数是很低的。如果你进行一些比较极端的精细实现（比如当子树很小时采用哈希之类的方式快速求出匹配关系）甚至可以解决一些看上去很不可做的数据范围，不过出题人认为其过于意义不明所以数据范围开的比较小。

---

## 作者：_Ch1F4N_ (赞：0)

好题。

首先有个爆搜思路，你直接去搜索 dfs 序上第 $i$ 个是哪个结点。

你发现你在爆搜的过程中搜到的一些信息可以重复利用，例如如果第 $i$ 个位置放结点 $u$ 合法，实际上说明了 $[i,i+sz_u-1]$ 可以将 $u$ 的整个子树填进去。

于是设计状态 $dp_{i,j}$ 表示 dfs 序上 $[i,i+sz_j-1]$ 是否能放进 $j$ 的子树，转移考虑将 $j$ 的 $d$ 个儿子与 dfs 序为 $i$ 的点的 $d$ 个儿子的 dfs 序做匹配。

怎么判断能否匹配首先要考虑能不能把 $w$ 提升为对应的 $c$，考虑操作边的过程，你发现一个点 $w$ 加上的值要么是父亲的 $w$ 要么是父亲的 $c$ 要么是 $0$，并且这三种随意指定都可以构造出解，只需要先处理加上父亲的 $w$ 的边，注意这里要从下往上处理，再从上往下处理加上父亲 $c$ 的边即可。

所以儿子 $v$ 可以匹配上 dfs 序为 $k$ 的点当且仅当 $dp_{k,v}=1$ 且 $w_v=c_k$ 或者 $w_v+w_j=c_k$ 或者 $w_v+c_i=c_k$。得到能否匹配的关系后去跑二分图最大匹配看看是否存在完美匹配就可以知道 $dp_{i,j}$ 的值，全部做完后可以简单构造出 dfs 序方案，操作方案的构造上文也讲过了。

下面讲下时间复杂度分析，设 $d_i$ 表示树的第 $i$ 层的结点个数，$deg_i$ 表示第 $i$ 层的点的儿子数，考虑第 $i$ 层的 dp 状态有 $d_i^2$ 个，因为 dfs 序上每个点深度是确定的，然后第 $i$ 层每个状态做二分图最大匹配的过程中边数是 $deg_u^2$，点数是 $deg_u$，所以 dinic 跑二分图匹配复杂度就是 $O(deg_u^2 \times \sqrt{deg_u})$，总复杂度就是 $O(\sum_u d_u^2 \times deg_u^2 \times \sqrt{deg_u})$，注意到 $d_u \times deg_u = d_{u+1}$，所以复杂度为 $O(\sum_u d_{u+1}^2 \times \sqrt{deg_u}) \leq O(n^{2.5})$。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 4e3+114;
vector<int> E[maxn];
int head[maxn],now[maxn],nxt[maxn*maxn<<1],to[maxn*maxn<<1],w[maxn*maxn<<1];
int dis[maxn];
int n;
int tot=1;
int s,t;
int cnt;
void add(int u,int v,int C){
    tot++;
    nxt[tot]=head[u];
    w[tot]=C;
    to[tot]=v;
    head[u]=tot;
    tot++;
    nxt[tot]=head[v];
    w[tot]=0;
    to[tot]=u;
    head[v]=tot;
}
bool BFS(){
    queue<int> q;
    for(int i=1;i<=cnt;i++) dis[i]=0;
    dis[s]=1;
    q.push(s);
    while(q.size()>0){
        int u=q.front();
        q.pop();
        now[u]=head[u];
        for(int i=head[u];i;i=nxt[i]){
            int v=to[i];
            if(dis[v]==0&&w[i]!=0){
                dis[v]=dis[u]+1;
                q.push(v);
            }
        }
    }
    return dis[t]!=0;
}
int dinic(int u,int C){
    if(u==t) return C;
    int res=C;
    for(int i=now[u];i;i=nxt[i]){
        int v=to[i];
        now[u]=i;
        if(dis[v]==dis[u]+1&&w[i]>0){
            int flow=min(C,w[i]);
            int del=dinic(v,flow);
            w[i]-=del;
            w[i^1]+=del;
            C-=del;
            if(C==0) return res;
        }
    }
    return res-C;
}
void clear(){
    for(int i=1;i<=cnt;i++) head[i]=dis[i]=now[i]=0;
    for(int i=1;i<=tot;i++) nxt[i]=to[i]=w[i]=0;
    tot=1;
}
int fa[maxn],sz[maxn];
long long c[maxn];
long long weight[maxn];
int dp[maxn][maxn],vis[maxn][maxn];
void dfs(int now,int u){
    if(vis[now][u]==1) return ;
    vis[now][u]=1;
    if(E[u].size()==0){
        dp[now][u]=1;
        return ;
    }
    vector< pair<int,int> > edge;
    for(int p=0;p<E[u].size();p++){
        int v=E[u][p];
        for(int i=now+1,j=0;j<E[u].size();i+=sz[v],j++){
            dfs(i,v);
            if(dp[i][v]==1&&(c[i]==weight[v]||c[i]==weight[v]+weight[u]||c[i]==weight[v]+c[now])) edge.push_back(make_pair(p+1,j+1+E[u].size())); 
        }
    }
    s=2*E[u].size()+1,t=2*E[u].size()+2;
    cnt=t;      
    for(pair<int,int> now:edge) add(now.first,now.second,1);
    for(int i=1;i<=E[u].size();i++) add(s,i,1),add(i+E[u].size(),t,1);
    int ans=0;
    while(BFS()==true) ans+=dinic(s,E[u].size());
    clear();
    if(ans==E[u].size()){
        dp[now][u]=1;
    }
    return ;
}
vector<int> p;
vector<int> opt[2];
int ty[maxn];
void build1(int now,int u){
    p.push_back(u);
    if(E[u].size()==0) return ;
    s=2*E[u].size()+1,t=2*E[u].size()+2;
    cnt=t;
    for(int p=0;p<E[u].size();p++){
        int v=E[u][p];
        for(int i=now+1,j=0;j<E[u].size();i+=sz[v],j++){
            if(dp[i][v]==1&&(c[i]==weight[v]||c[i]==weight[v]+weight[u]||c[i]==weight[v]+c[now])) add(p+1,j+1+E[u].size(),1); 
        }
    }
    for(int i=1;i<=E[u].size();i++) add(s,i,1),add(i+E[u].size(),t,1);
    int ans=0;
    while(BFS()==true) ans+=dinic(s,E[u].size());
    vector<int> vec;
    for(int v=E[u].size()+1;v<=2*E[u].size();v++){
        for(int i=head[v];i;i=nxt[i]){
            if(w[i]==1&&to[i]!=t){
                vec.push_back(E[u][to[i]-1]);
            }
        }
    }
    clear();
    int v=E[u].size()+1;
    for(int son:vec){
        if(c[now+1+(v-E[u].size()-1)*sz[son]]==weight[son]) ty[son]=-1;
        else if(c[now+1+(v-E[u].size()-1)*sz[son]]==weight[son]+weight[u]) ty[son]=0;
        else ty[son]=1;
        build1(now+1+(v-E[u].size()-1)*sz[son],son);        
        v++;
    }
}
void build2(int u){
    for(int v:E[u]){
        build2(v);
        if(ty[v]==0) opt[0].push_back(v);
    }
}
void build3(int u){
    for(int v:E[u]){
        if(ty[v]==1) opt[1].push_back(v);
        build3(v);
    }
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>fa[i]>>weight[i];
        if(i>1) E[fa[i]].push_back(i);
        sz[i]=1;
    }
    for(int i=1;i<=n;i++) cin>>c[i];
    for(int i=n;i>=2;i--) sz[fa[i]]+=sz[i];
    dfs(1,1);
    build1(1,1);
    build2(1);
    build3(1);
    cout<<opt[0].size()+opt[1].size()<<'\n';
    for(int x:opt[0]) cout<<x<<' ';
    for(int x:opt[1]) cout<<x<<" ";
    cout<<'\n';
    for(int x:p) cout<<x<<" ";
    return 0;
}
```

---


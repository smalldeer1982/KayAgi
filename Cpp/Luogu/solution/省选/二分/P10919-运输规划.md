# 运输规划

## 题目背景

你需要规划卡车的运输方案，为了让您更好地解决问题，**请仔细阅读题面。**

## 题目描述

有 $n$ 个城市，对于任意 $1 < i \leq n$ 满足第 $i$ 个城市与第 $i-1$ 个城市间有一条双向的道路，每个城市有一个对卡车高度的限制 $h_i$，代表只有高度小于等于 $h_i$ 的卡车可以从这个城市经过，现在有 $m$ 个城市 $S_{1},S_{2},...,S_{m}$ 各有**恰好**一个运输任务，任务要求**编号为 $i$ 且高度为 $h_{S_{i}}$ 的**卡车从城市 $S_{i}$ 出发**到达**任意一个有机场的城市，而有 $m$ 个城市有机场，分别为 $T_{1},T_{2},...,T_{m}$，对于一个合法的运输方案而言，需要保证每个卡车都到达一个机场且每个机场**恰好**有一辆卡车**抵达**。一个机场**可以**同时被多辆卡车**经过**。请注意，如果你无法经过某个城市，那么你也无法抵达这个城市。

记 $c_i$ 表示抵达位于城市 $T_i$ 的机场的的**卡车编号**，令数组 $F = \{c_1,c_2,...,c_m\}$，请你最小化 $F$ 的字典序并输出 $F$。

我们定义两个长度为 $len$ 的数组 $A,B$ 满足 $A$ 的字典序小于 $B$ 当且仅当存在 $0 \leq i < len$ 满足对于任意 $1 \leq j \leq i$ 满足 $A_j = B_j$ 且 $A_{i+1} < B_{i+1}$。

数据保证有解，保证**所有 $h_i$ 互不相同**，所有 $T_i$ 互不相同，所有 $S_i$ 互不相同。但是**可能会**存在 $i,j$ 满足 $S_i = T_j$。


## 说明/提示

**本题采用捆绑测试**。

| 子任务编号 | 特殊性质 | 分值 |
| :-----------: | :-----------: | :-----------: |
| $1$ | $n,m \leq 50$ | $10$ |
| $2$ | 对于任意 $1 < i \leq n$ 满足 $h_i < h_{i-1}$ | $25$ |
| $3$ | $n,m \leq 10^3$ | $25$ |
| $4$ | 无特殊性质 | $40$ |

对于 $100\%$ 的数据保证 $1 \leq m \leq n \leq 2 \times 10^5,0 < h_i \leq 10^9$。


## 样例 #1

### 输入

```
10 3 
1 2 3 5 4 10 8 6 7 9
1 2 8
6 10 3
```

### 输出

```
1 3 2```

## 样例 #2

### 输入

```
20 5
12 13 14 15 16 17 18 19 20 22 21 30 29 28 27 26 23 24 25 1
1 20 2 5 3 
10 12 11 9 13 
```

### 输出

```
1 2 3 4 5```

# 题解

## 作者：_Ch1F4N_ (赞：10)

这里是官方题解。

## sub1

不难发现这是一个二分图匹配模型，我们用卡车去匹配机场，由于要最小化字典序，所以考虑建出二分图，在字典序上按位贪心，每次考虑每个机场被哪个卡车匹配，匹配完后再跑一遍二分图匹配判断是否存在解。

## sub2

一个卡车可以匹配的机场是一段前缀，不妨把机场看成左括号，卡车看成右括号，问题变成每次对于一个左括号找到编号最小的右括号，使得删去这两个括号后剩下的括号仍然可以匹配，考虑存在匹配的条件是任意一个前缀中左括号数量大于等于右括号数量，于是发现可以匹配的右括号具有单调性，线段树维护即可。

## sub3

因为保证了 $h_i$ 互不相同，所以可以建出唯一可能的笛卡尔树，建出笛卡尔树后，一个点所能到达的点成为了其在笛卡尔树上子树内所有点。

由于这是依然一个二分图是否存在完美匹配的问题，考虑霍尔定理。下文将卡车视作左部点，机场视作右部点。

假若你选出了一个左部点集合 $S$，我们令其中所有满足其祖先中（不包括自己）不存在左部点的左部点集合为 $S'$，显然对于所有 $u \in S'$ 而言，我们假若将 $u$ 所有子树中的左部点加入集合 $S$ 得到新的集合 $S''$，那么我们发现 $S''$ 满足其邻域并大小等于 $S$ 的邻域并大小，所以假若 $S''$ 的大小小于等于其邻域并大小，那么 $S$ 的大小也一定小于等于其邻域并大小，那么我们只保留 $S''$ 的限制，然后考虑对于任意 $u \in S'$ 而言，$S''$ 满足其大小小于等于其邻域并等价于所有 $u$ 的子树中左部点集合 $sub_u$ 的大小小于等于其邻域并，又因为我们可以只选择某个点来使得任意点 $1 \leq u \leq n$ 在集合 $S'$ 中，所以实际上存在完美匹配当且仅当任意点子树中的右部点数量大于等于子树中的左部点数量。

考虑令 $val_u$ 等于一个点子树中的左部点数量减去子树中的右部点数量。显然一个存在完美匹配的局面等价于所有点的 $val \leq 0$。对于一个右部点 $u$，我们选择其祖先左部点 $v$ 与其匹配，那么匹配完**仍然存在一组完美匹配**当且仅当 $u \to v$ 路径上所有点（不包括 $v$）的 $val \leq -1$，因为匹配后这些点的 $val$ 会加 $1$，因此操作之前不能等于 $0$。

而这是具有单调性的，我们找到 $u$ 到根的链上最深的一个满足 $val_x = 0$ 的点 $x$，那么我们可以选择的 $v$ 实际上就是 $u \to x$ 的链。因此暴力跳父亲找到满足条件的点中编号最小的即可。

## sub4

考虑树链剖分维护链上深度最深的 $val$ 最大点与链上编号最小点即可。

```cpp
#include<bits/stdc++.h>
#define min(x,y) (x<y?x:y)
using namespace std;
const int maxn = 2e5+114;
int ls[maxn],rs[maxn],a[maxn];
int st[maxn],tp;
int dfn[maxn],node[maxn],dfc;
int rk[maxn];
const int inf = 1e9+114;
struct Mininfo{
    int Minrk;
    //最小 rk 节点的 rk
    Mininfo(){
        Minrk=inf;
    }
    Mininfo operator+(const Mininfo &x)const{
        Mininfo res=Mininfo();
        res.Minrk=min(Minrk,x.Minrk);
        return res;
    }
}tr[maxn<<2];
struct Maxinfo{
    int Maxval;
    int Maxdfn;
    //最大值
    //最大值的最大 dfn
    Maxinfo(){
        Maxval=Maxdfn=-inf;
    }
    Maxinfo operator+(const Maxinfo &x)const{
        Maxinfo res=Maxinfo();
        res.Maxval=Maxval;
        res.Maxdfn=Maxdfn;
        if(Maxval>x.Maxval) return res;
        else if(Maxval<x.Maxval){
        	return x;
    	}
        else{
            if(Maxdfn>x.Maxdfn) return res;
            else{
            	return x;
			}
        }
    }
}Tr[maxn<<2];
int tag[maxn<<2];//下传加 1 标记
int father[maxn],son[maxn],sz[maxn],top[maxn],dep[maxn];
int val[maxn];
int S[maxn];
int n,m;
void dfs1(int u,int fa){
    if(u==0) return ;
    dep[u]=dep[fa]+1;
    father[u]=fa;
    sz[u]=1;
    dfs1(ls[u],u);
    dfs1(rs[u],u);
    val[u]+=val[ls[u]];
    val[u]+=val[rs[u]];
    sz[u]+=(sz[ls[u]]+sz[rs[u]]);
    if(sz[ls[u]]>sz[rs[u]]) son[u]=ls[u];
    else son[u]=rs[u];
}
void dfs2(int u,int t){
	if(u==0) return ;
    dfn[u]=++dfc;
    node[dfc]=u;
    top[u]=t;
    if(son[u]!=0) dfs2(son[u],t);
    if(son[u]!=ls[u]) dfs2(ls[u],ls[u]);
    else dfs2(rs[u],rs[u]);
}
void pushupMin(int cur){
    tr[cur]=tr[cur<<1]+tr[cur<<1|1];
}
void pushupMax(int cur){
    Tr[cur]=Tr[cur<<1]+Tr[cur<<1|1];
}
void pushdown(int cur){
    Tr[cur<<1].Maxval+=tag[cur];
    tag[cur<<1]+=tag[cur];
    Tr[cur<<1|1].Maxval+=tag[cur];
    tag[cur<<1|1]+=tag[cur];
    tag[cur]=0;
}
void del(int cur,int lt,int rt,int p){
    if(lt==rt){
        Tr[cur].Maxval--;
        tr[cur].Minrk=inf;
        return ;
    }
    int mid=(lt+rt)>>1;
    pushdown(cur);
    if(p<=mid) del(cur<<1,lt,mid,p);
    else del(cur<<1|1,mid+1,rt,p);
    pushupMax(cur);
    pushupMin(cur);
}//dfn[] = p 的数删掉
Mininfo askMin(int cur,int lt,int rt,int l,int r){
	if(l>r) return Mininfo();
    if(l<=lt&&rt<=r){
        return tr[cur];
    }
    int mid=(lt+rt)>>1;
    Mininfo res=Mininfo();
    if(l<=mid) res=res+askMin(cur<<1,lt,mid,l,r);
    if(r>mid) res=res+askMin(cur<<1|1,mid+1,rt,l,r);
    return res;
}
Mininfo askMin_list(int u,int v){
    Mininfo res=Mininfo();
    while(top[u]!=top[v]){
        if(dep[top[u]]<dep[top[v]]) swap(u,v);
        res=res+askMin(1,1,n,dfn[top[u]],dfn[u]);
        u=father[top[u]];
    }
    if(dep[u]<dep[v]) swap(u,v);
    res=res+askMin(1,1,n,dfn[v],dfn[u]);
    return res;
}
void add(int cur,int lt,int rt,int l,int r){
	if(l>r) return ;
    if(l<=lt&&rt<=r){
        Tr[cur].Maxval++;
        tag[cur]++;
        return ;
    }
    int mid=(lt+rt)>>1;
    pushdown(cur);
    if(l<=mid) add(cur<<1,lt,mid,l,r);
    if(r>mid) add(cur<<1|1,mid+1,rt,l,r);
    pushupMax(cur);
}
void add_list(int u,int v){
    while(top[u]!=top[v]){
        if(dep[top[u]]<dep[top[v]]) swap(u,v);
        add(1,1,n,dfn[top[u]],dfn[u]);
        u=father[top[u]];
    }
    if(dep[u]<dep[v]) swap(u,v);
    add(1,1,n,dfn[v],dfn[u]);
}
Maxinfo askMax(int cur,int lt,int rt,int l,int r){
	if(l>r) return Maxinfo();
    if(l<=lt&&rt<=r){
        return Tr[cur];
    }
    int mid=(lt+rt)>>1;
    Maxinfo res=Maxinfo();
    pushdown(cur);
    if(l<=mid) res=res+askMax(cur<<1,lt,mid,l,r);
    if(r>mid) res=res+askMax(cur<<1|1,mid+1,rt,l,r);
    return res;
}
Maxinfo askMax_list(int u,int v){
    Maxinfo res=Maxinfo();
    while(top[u]!=top[v]){
        if(dep[top[u]]<dep[top[v]]) swap(u,v);
        res=res+askMax(1,1,n,dfn[top[u]],dfn[u]);
        u=father[top[u]];
    }
    if(dep[u]<dep[v]) swap(u,v);
    res=res+askMax(1,1,n,dfn[v],dfn[u]);
    return res;
}
void build(int cur,int lt,int rt){
    if(lt==rt){
        tr[cur]=Mininfo();
        tr[cur].Minrk=(S[node[lt]]==true?rk[node[lt]]:inf);
        Tr[cur]=Maxinfo();
        Tr[cur].Maxdfn=(S[node[lt]]==true?lt:-inf);
        Tr[cur].Maxval=val[node[lt]];
        return ;
    }
    int mid=(lt+rt)>>1;
    build(cur<<1,lt,mid);
    build(cur<<1|1,mid+1,rt);
    pushupMax(cur);
    pushupMin(cur);
}
vector<int> ans;//答案序列
vector<int> s,T;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        int k=tp;
        while(k>0&&a[st[k]]>a[i]) k--;
        if(k) rs[st[k]]=i;
        if(k<tp) ls[i]=st[k+1];
        st[++k]=i,tp=k;
    }
    for(int i=1;i<=m;i++){
        int u;
        cin>>u;
        s.push_back(u);
        rk[u]=s.size();
        S[u]=1;
        val[u]++;
    }
    for(int i=1;i<=m;i++){
        int u;
        cin>>u;
        T.push_back(u);
        val[u]--;
    }
    dfs1(st[1],0);
    dfs2(st[1],st[1]);
    build(1,1,n);
    for(int x:T){
        Maxinfo now=askMax_list(x,st[1]);
        if(now.Maxval!=0) now.Maxdfn=1;
        int u=node[now.Maxdfn];
        Mininfo res=askMin_list(x,u);
        int to=res.Minrk;
        ans.push_back(to);
        add_list(x,s[to-1]);
        del(1,1,n,dfn[s[to-1]]);
    }
    for(int x:ans) cout<<x<<' ';
    return 0;
}
```

---

## 作者：251Sec (赞：5)

属于看到题面脑内自动反射出全部做法的题目。

---

首先建笛卡尔树，每个货车能到达的就是个子树。然后把货车放到左边、机场放到右边就是个二分图匹配。我们要干的事情是对机场一个一个贪心保证一直有解。

考虑 Hall 定理，则无解当且仅当存在一个左部点集合使得 $|N(S)|-|S|<0$，不难证明 $S$ 只需对所有点 $u$ 取 $u$ 子树里的货车集合就是充要的。（只需考虑如果选了两个不交的子树满足 $<0$ 的条件，那么它们至少有一个单独选了也满足）也就是说需要验证的 $S$ 只有 $O(n)$ 种而非 $O(2^m)$ 种。

考虑动态维护所有点子树里的 $|N(S)|-|S|$。一次询问，如果不考虑需要让后续仍然有解的限制就是问一个点 $u$ 到根路径上编号最小的货车，但是我们还要求不能出现 $|N(S)|-|S|<0$，那么找 $u$ 往上第一个 $|N(S)|-|S|=0$ 的点 $v$，所选的货车必须在 $u$ 到 $v$ 的路径上。然后修改就是路径 $+1$ 和 $-1$，直接上树剖就是 $O((n+m)\log^2n)$ 了。

---

## 作者：是青白呀 (赞：4)

题面的描述让人很容易想到笛卡尔树。对 $h_i$ 建立小根笛卡尔树之后，问题变为每个 $T_i$ 要和它祖先处的一个 $S_i$ 匹配。

这仍然是一个二分图完美匹配问题。利用霍尔定理，我们实际上需要任意 $S_i$ 的集合的子树并中的 $T_i$ 数目不小于该集合本身的大小。

首先，对于两个元素都在 $S$ 中的点集 $F$ 和 $G$，若对于任意 $x\in F$ 和 $y\in G$ 都满足 $x,y$ 没有祖先关系，则 $F\cup G$ 满足霍尔定理要求的条件，等价于 $F$ 和 $G$ 分别满足该条件，因为此时两个子树的并不交。

其次，若存在 $S$ 中的点 $x,y$ 使得 $x$ 是 $y$ 的祖先，且 $x\in G$，$y\notin G$，则集合 $G$ 的限制是没有意义的，因为将 $y$ 加入 $G$ 后，$T_i$ 数目不会增大。

因此你发现，有效的集合一定是一个以 $S$ 中的点为根的子树。换句话说，你需要满足所有以 $S$ 中的点为根的子树中，$T$ 中的点数不小于 $S$ 中的点数。不难发现可以去掉根节点的限制，转化为任意一棵子树中，在 $T$ 内的点数不能小于在 $S$ 内的点数。

考虑维护每个点子树中两个值的差，则每次选择一个在 $x$ 的卡车和在 $y$ 的机场进行匹配时，会导致 $rt\to x$ 的链值加 $1$，$rt\to y$ 的链值减 $1$。你需要保证操作结束后最小差值非负，则 $x$ 不能高于 $1\to y$ 的链上值为 $0$ 的最深的那个点。然后在这条合法的链上贪心地选取卡车标号最小的点进行匹配即可。

需要维护卡车标号的最小值及其位置、以及差值最小值以及最小值最深的位置，同时对差值进行链加、对标号进行单点修改。用树链剖分维护即可。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define ls(x) (x<<1)
#define rs(x) ((x<<1)|1)
#define mp make_pair
#define sec second
#define fir first
#define pii pair<int,int>
#define lowbit(i) i&-i
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int N=2e5+5,M=6,S=(1<<15)+5,inf=(ll)1e9+7,mo=1e9+7;
const double eps=1e-8;
void read(int &p){
	int x=0,w=1;
	char ch=0;
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
int n,m,h[N],s[N],t[N],rt;
struct node{
    int v,pos;
    friend node operator+(node x,node y){
        if(x.v<y.v)return x;
        else if(x.v>y.v)return y;
        else if(x.pos>y.pos)return x;
        else return y;
    }
};
int ch[N][2],dep[N],fa[N],hson[N],sz[N],dfn[N],cntp,nw[N],top[N];
struct seg{
    int tag[N*4];
    node val[N*4],id[4*N];
    void pushup(int x){
        val[x]=val[ls(x)]+val[rs(x)];
        id[x]=id[ls(x)]+id[rs(x)];
    }
    void pushdown(int x){
        val[ls(x)].v+=tag[x],val[rs(x)].v+=tag[x];
        tag[ls(x)]+=tag[x],tag[rs(x)]+=tag[x],tag[x]=0;
    }
    void build(int x,int le,int ri){
        tag[x]=0;
        if(le==ri){
            id[x]=(node){inf,le};
            val[x]=(node){0,le};
            return;
        }
        int mid=(le+ri)>>1;
        build(ls(x),le,mid),build(rs(x),mid+1,ri);
        pushup(x);
    }
    void addid(int x,int le,int ri,int p,int v){
        if(le==ri){
            id[x].v=v;
            return;
        }
        pushdown(x);
        int mid=(le+ri)>>1;
        if(p<=mid)addid(ls(x),le,mid,p,v);
        else addid(rs(x),mid+1,ri,p,v);
        pushup(x);
    }
    void addv(int x,int le,int ri,int ql,int qr,int v){
        if(ql<=le&&qr>=ri){
            tag[x]+=v,val[x].v+=v;
            return;
        }
        pushdown(x);
        int mid=(le+ri)>>1;
        if(ql<=mid)addv(ls(x),le,mid,ql,qr,v);
        if(qr>mid)addv(rs(x),mid+1,ri,ql,qr,v);
        pushup(x);
    }
    node queryid(int x,int le,int ri,int ql,int qr){
        if(ql<=le&&qr>=ri)return id[x];
        pushdown(x);
        node res=(node){inf,0};
        int mid=(le+ri)>>1;
        if(ql<=mid)res=res+queryid(ls(x),le,mid,ql,qr);
        if(qr>mid)res=res+queryid(rs(x),mid+1,ri,ql,qr);
        return res;
    }
    node queryv(int x,int le,int ri,int ql,int qr){
        if(ql<=le&&qr>=ri)return val[x];
        pushdown(x);
        node res=(node){inf,0};
        int mid=(le+ri)>>1;
        if(ql<=mid)res=res+queryv(ls(x),le,mid,ql,qr);
        if(qr>mid)res=res+queryv(rs(x),mid+1,ri,ql,qr);
        return res;
    }
}T;
void dfs1(int x,int f){
    if(!x)return;
    fa[x]=f,dep[x]=dep[f]+1,sz[x]=1;
    dfs1(ch[x][0],x),dfs1(ch[x][1],x);
    sz[x]+=sz[ch[x][0]]+sz[ch[x][1]];
    if(sz[ch[x][0]]>sz[ch[x][1]])hson[x]=0;
    else hson[x]=1;
}
void dfs2(int x,int topp){
    if(!x)return;
    top[x]=topp,dfn[x]=++cntp,nw[cntp]=x;
    dfs2(ch[x][hson[x]],topp),dfs2(ch[x][hson[x]^1],ch[x][hson[x]^1]);
}
void addroad(int x,int v){
    while(x){
        T.addv(1,1,n,dfn[top[x]],dfn[x],v);
        x=fa[top[x]];
    }
}
node queryroad(int x,int y){
    if(dep[x]<dep[y])swap(x,y);
    node res=(node){inf,0};
    while(top[x]!=top[y]){
        res=res+T.queryid(1,1,n,dfn[top[x]],dfn[x]);
        x=fa[top[x]];
    }
    res=res+T.queryid(1,1,n,dfn[y],dfn[x]);
    return res;
}
int ans[N];
int getp(int x){
    while(x){
        node res=T.queryv(1,1,n,dfn[top[x]],dfn[x]);
        if(!res.v)return nw[res.pos];
        x=fa[top[x]];
    }
    return rt;
}
signed main(){
    read(n),read(m);
    rep(i,1,n)
        read(h[i]);
    rep(i,1,m)
        read(s[i]);
    rep(i,1,m)
        read(t[i]);
    stack<int>stk;
    stk.push(0);
    rep(i,1,n){
        int la=0;
        while(!stk.empty()&&h[stk.top()]>h[i])
            la=stk.top(),stk.pop();
        ch[stk.top()][1]=i,ch[i][0]=la;
        stk.push(i);
    }
    rt=ch[0][1];
    dfs1(rt,0),dfs2(rt,rt);
    T.build(1,1,n);
    rep(i,1,m){
        T.addid(1,1,n,dfn[s[i]],i);
        addroad(s[i],-1);
    }
    rep(i,1,m)
        addroad(t[i],1);
    rep(i,1,m){
        int targ=getp(t[i]);
        node res=queryroad(t[i],targ);
        ans[i]=res.v;
        if(ans[i]>n)break;
        addroad(t[i],-1),addroad(nw[res.pos],1);
        T.addid(1,1,n,dfn[s[ans[i]]],inf);
    }
    rep(i,1,m)
        printf("%lld ",ans[i]);
    return 0;
}
```

---

## 作者：MisaYuzuki (赞：3)

D 给人感觉要比 C 简单多了！但是场切 C 却没场切 D。

根据 $h$ 值构建小根堆笛卡尔树这应该谁都能想到。那么一辆货车 $s_i$ 和一个飞机场 $t_j$ 形成匹配当且仅当 $s_i$ 是 $t_j$ 的祖先（包括自身），即 $\text{lca}(s_i,t_j)=s_i$。根据霍尔定理，很容易想到存在合法解和对于每棵子树 $u$ 满足 $\sum_{v\in S(u)}[\exist j,t_j=v]\ge\sum_{v\in S(u)}[\exist i,s_i=v]$，这里 $S(u)$ 表示子树 $u$ 的所有节点所构成的集合。为了要字典序最小，那么我们就从小到大遍历飞机场 $t_j$ 找到最小合法匹配 $s_i$，即使得剩下的 $s,t$ 仍旧能构成合法解。对于每棵子树 $u$ 满足 $\sum_{v\in S(u)}[\exist j,t_j=v]\ge\sum_{v\in S(u)}[\exist i,s_i=v]$，即对于每条边的儿子都要满足此条件。若将出现货车视作 $+1$ 权值，出现飞机场视作 $-1$ 权值，那么等价于每棵子树的权值和 $f_u=\sum_{v\in S(u)}[\exist j,t_j=v]-\sum_{v\in S(u)}[\exist i,s_i=v]$ 非负。对于飞机场 $t_j$，指针 $p$ 从 $t_j$ 不断往上跳父亲直到出现权值和 $f_p=0$，即这时若再往上跳可能会使得匹配的飞机场在当前的 $p$ 之上，更改后 $t_j$ 会对 $p$ 贡献 $-1$ 使得当前 $p$ 不合法。所以在 $p\to t_j$ 这条链上找到最小的 $i$ 使得 $s_i\in(p\to t_j),\text{vis}_{s_i}=\text{false}$。再进行修改权值。具体地，找寻 $p$ 用线段树二分，线段树维护区间 $\min$（需要同时维护 $\min f$ 和 $\min s_i$）。同时修改权值需要支持 $f$ 区间加减和 $s_i$ 单点修改。

[code](https://www.luogu.com.cn/paste/xa5zgxmt)

求求给珂爱的小妹妹点个赞吧 awa

---


# 『STA - R8』强制在线动态二维数点

## 题目背景

> 数据结构界的最新成果！强制在线动态二维数点已经可以做到线性时间！


## 题目描述

要拿到图灵奖，你需要解决下面这道动态在线二维数点问题：

平面上有 $n$ 个点 $(x_i,y_i)$，**排列在 $\bm{y=x}$ 的直线下方（即，$\bm{y_i\le x_i}$ 成立）**。

我会进行 $q$ 次操作，操作有两种类型：

1. 修改操作 `U i x y`：令 $x_i:=x,y_i:=y$。（即，将 $x_i$ 和 $y_i$ 分别赋值为 $x$ 和 $y$。）
2. 询问操作 `Q l r`：给出一个**四个顶点分别是 $\bm{(l,l),(r,l),(l,r),(r,r)}$ 的矩形**，求出在给出的矩形内的点 $^\dagger$ $(x,y)$ 中最小的 $x-y$ 的值。**特别地，规定当矩形没有包含任何一个点时答案为 $\bm{0}$。**

两种操作会以某种方式进行加密，详细要求见下方【输入格式】一栏。

$^\dagger$：点 $(x,y)$ 在 $(l,l),(r,l),(l,r),(r,r)$ 所构成的矩形内，当且仅当 $l\le x\le r$ 且 $l\le y\le r$。

## 说明/提示

对于所有测试数据，$1\le n,q\le 5\times 10^5$，并且保证解密后的 $1\le l\le r\le n$ 且 $1\le i\le n$，$1\le y\le x\le n$。

**本题采用捆绑测试，并开启子任务依赖。**

- Subtask 0（5 points）：$n,q\le 5\times 10^3$。
- Subtask 1（20 points）：无修改操作。 
- Subtask 2（25 points）：满足特殊性质。
- Subtask 3（20 points）：$n,q\le 10^5$。
- Subtask 4（30 points）：无特殊限制。

特殊性质（数据随机）：操作类型、修改的位置、初始时和修改后的点的坐标和询问区间（参数 $(i,x,y),(l,r)$ 的值）在合法范围内独立地均匀随机生成。


## 样例 #1

### 输入

```
5 6
4 1
4 1
4 2
4 1
5 2
Q 2 5
U 6 6 3
Q 3 7
Q 1 6
U 2 4 2
Q 2 3```

### 输出

```
2
2
0
0```

# 题解

## 作者：zhenjianuo2025 (赞：21)

将 $(y,x)$ 的点视作 $[x,y]$ 的区间，现在问题转化为维护区间集合 $S$，支持：
- 动态修改 $S$ 中的某个元素；
- 查询 $S$ 内被给定区间 $[l,r]$ 包含的区间中最短的区间。

对于一次询问操作 $[l,r]$：
- 找到 $x_0\ge l$ 的最小的 $y_0$；
- 求出 $y_0\le y\le r$ 的最小的 $y-x$ 的值。

可以证明这是正确的：

- 一方面，对于任何合法的区间 $[x,y]$，因为 $y\ge y_0$，必定会被计入答案之中。
- 另一方面，考虑一个 $y_0\le y\le r$ 且 $x<l$ 的不合法区间 $[x,y]$，由于 $y-x>y_0-l\ge y_0-x_0$，所以必定不会对答案造成任何影响。


上面两项都可以使用线段树简单维护。用 `std::mutiset` 辅助存储每个左端点对应的右端点集，以及每个右端点对应的左端点集。修改时单点修改两棵线段树上的对应位置。时间复杂度 $\Theta\left((n+q)\log n\right)$，可以通过。

**其他任何想法欢迎与我私信交流。**

---

## 作者：bluedream (赞：7)

将题意重述为给定 $n$ 个区间 $[l_i,r_i]$，支持修改某个区间或查询包含于询问区间 $[l,r]$ 的区间中长度的最小值，强制在线。

正如题目所说，我们不能直接数点，那么一个明显的方向为利用 $\min$ 的性质排除某些维度的限制。

研究所求答案的性质，我们可以排除所有包含了某个区间的区间，其必然不可能成为答案。

此时左右端点均单调不降，那么只需要找到第一个满足 $l\le l_p$ 的 $p$ 和最后一个 $r_q\le r$ 的 $q$，那么答案就是 $\min_{i=p}^q(r_i-l_i)$ 了。

实现上无需真正排除包含其它区间的区间，将区间维护于右端点处，只关注一个右端点对应的最大左端点即可。

使用 `multiset` 和线段树维护，时间复杂度 $O((n+q)\log n)$。

参考代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
//read()
#define pii pair<int,int>
#define mpr make_pair
#define fir first
#define sec second
const int N=5e5+10,INF=1e9;
int n,q,x[N],y[N];
multiset<int>s[N];
struct Segment_Tree{
	#define ls (rt<<1)
	#define rs (rt<<1|1)
	int mx[N<<2],mn[N<<2];
	inline void pushup(int rt){
		mx[rt]=max(mx[ls],mx[rs]);
		mn[rt]=min(mn[ls],mn[rs]);
	}
	inline void build(int rt,int l,int r){
		if(l==r){
			if(!s[l].size()) mx[rt]=0,mn[rt]=INF;
			else mx[rt]=*--s[l].end(),mn[rt]=l-mx[rt];
			return ;
		}
		int mid=l+r>>1;
		build(ls,l,mid),build(rs,mid+1,r);
		pushup(rt);
	}
	inline void modify(int rt,int l,int r,int p){
		if(l==r){
			if(!s[l].size()) mx[rt]=0,mn[rt]=INF;
			else mx[rt]=*--s[l].end(),mn[rt]=l-mx[rt];
			return ;
		}
		int mid=l+r>>1;
		if(p<=mid) modify(ls,l,mid,p);
		else modify(rs,mid+1,r,p);
		pushup(rt);
	}
	inline int query(int rt,int l,int r,int L,int R){
		if(L<=l&&r<=R) return mn[rt];
		int mid=l+r>>1,mn=INF;
		if(L<=mid) mn=min(mn,query(ls,l,mid,L,R));
		if(R>mid) mn=min(mn,query(rs,mid+1,r,L,R));
		return mn;
	}
	inline int find(int rt,int l,int r,int L,int R,int v){
		if(r<L||l>R||mx[rt]<v) return -1;
		if(l==r) return l;
		int mid=l+r>>1,tp=find(ls,l,mid,L,R,v);
		if(tp==-1) tp=find(rs,mid+1,r,L,R,v);
		return tp;
	}
}T;
int las;
int main(){
	n=read(),q=read();
	for(int i=1;i<=n;i++)
		x[i]=read(),y[i]=read(),s[x[i]].insert(y[i]);
	T.build(1,1,n);
	while(q--){
		char op=getc();
		if(op=='U'){
			int i=read()^las,a=read()^las,b=read()^las;
			s[x[i]].erase(s[x[i]].find(y[i]));
			T.modify(1,1,n,x[i]);
			s[x[i]=a].insert(y[i]=b);
			T.modify(1,1,n,x[i]);
		}else{
			int l=read()^las,r=read()^las;
			int tp=T.find(1,1,n,l,r,l);
			if(tp==-1) las=0;
			else las=T.query(1,1,n,tp,r);
			write(las),putc('\n');
		}
	}
	flush();
}
```

---

## 作者：CNS_5t0_0r2 (赞：2)

upd on 2025.1.18：修正一处笔误。

[CF19D](https://www.luogu.com.cn/problem/CF19D) 可能会对本题有启发但不多。

本题如果真的维护一个平面的话会很恶心，但是看到 $y_i \leq x_i$，其实本题可以转化成如下问题。

维护 $n$ 个区间，支持修改一个区间、查询所有 $[l,r]$ 的子区间中长度的最小者减 $1$。

## 正解：

维护 $n$ 个 multiset，第 $x$ 个 multiset 表示以 $x$ 为右端点的区间中所有左端点的值，这使得我们可以方便地插入区间、删除区间、查询以 $x$ 为右端点的区间中左端点的最大值，方便接下来在线段树上的更新。

线段树上，对于每个叶节点，设其对应的下标为 $i$，我们维护以 $i$ 为右端点的区间中左端点的最大值以及最短区间长度，其余节点则维护对应区间所有右端点上述信息的最值。

那么如何查询呢？

### 查询方法：

找到首个存在合法区间（$[l,r]$ 子区间）的右端点 $x_0$，那么 $x_0$ 到 $r$ 这所有右端点的最短区间的最小值就是答案。

但如果这些右端点对应的左端点有不合法的情况也没关系，因为它们肯定不会比该右端点的合法区间更优。

---

以下是 AC code：

```cpp
#include<bits/stdc++.h>
#define mid ((l + r) >> 1)
#define lchild (root << 1)
#define rchild ((root << 1) + 1)
#define x first
#define y second
using namespace std;
const int N = 5e5 + 9,INF = 1e9;
int n,q,ans;
pair<int,int> p[N];
multiset<int> s[N];
bool in_range(int l,int r,int L,int R){
	return L <= l && r <= R;
}
bool out_range(int l,int r,int L,int R){
	return l > R || r < L;
}
struct SGT{
	struct node{
		int Max;//对于叶节点，当前节点对应x的所有点中y的最大值 
		int Min;//对于叶节点，当前节点对应x的所有点中x - y的最小值（显然为x - Max） 
	} t[N << 2];
	void push_up(int root){
		t[root].Max = max(t[lchild].Max,t[rchild].Max);
		t[root].Min = min(t[lchild].Min,t[rchild].Min);
	}
	void build(int root,int l,int r){
		if(l == r){
			if(!s[l].size()){
				t[root].Max = -INF;
				t[root].Min = INF;
			}
			else{
				t[root].Max = *s[l].rbegin();
				t[root].Min = l - t[root].Max;
			}
			return;
		}
		build(lchild,l,mid);
		build(rchild,mid + 1,r);
		push_up(root);
	}
	void update(int root,int l,int r,int pos){
		if(l == r){
			if(!s[l].size()){
				t[root].Max = -INF;
				t[root].Min = INF;
			}
			else{
				t[root].Max = *s[l].rbegin();
				t[root].Min = l - t[root].Max;
			}
			return;
		}
		if(pos <= mid)
			update(lchild,l,mid,pos);
		else
			update(rchild,mid + 1,r,pos);
		push_up(root);
	}
	int query(int root,int l,int r,int L,int R){//回答询问 
		if(out_range(l,r,L,R))
			return INF;
		if(in_range(l,r,L,R))
			return t[root].Min;
		return min(query(lchild,l,mid,L,R),query(rchild,mid + 1,r,L,R));
	}
	int query2(int root,int l,int r,int L,int R,int v){//在区间[L,R]中找到第一个Max >= v的下标 
		if(out_range(l,r,L,R) || t[root].Max < v)//该区间内没有
			return -1;
		if(l == r)//找到下标
			return l;
		int ret = query2(lchild,l,mid,L,R,v);
		if(ret == -1)//左区间没有，进入右区间查找
			return query2(rchild,mid + 1,r,L,R,v);
		return ret;
	}
} sgt;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin >> n >> q;
	for(int i = 1;i <= n;i++){
		cin >> p[i].x >> p[i].y;
		s[p[i].x].insert(p[i].y);
	}
	sgt.build(1,1,n);
	while(q--){
		string op;
		cin >> op;
		if(op == "U"){
			int i;
			cin >> i;
			i ^= ans;
			s[p[i].x].erase(s[p[i].x].find(p[i].y));
			sgt.update(1,1,n,p[i].x);
			cin >> p[i].x >> p[i].y;
			p[i].x ^= ans;p[i].y ^= ans;
			s[p[i].x].insert(p[i].y);
			sgt.update(1,1,n,p[i].x);
		}
		else{
			int l,r;
			cin >> l >> r;
			l ^= ans;r ^= ans;
			int tmp = sgt.query2(1,1,n,l,r,l);
			if(tmp == -1)
				ans = 0;
			else
				ans = sgt.query(1,1,n,tmp,r);
			cout << ans << '\n';
		}
	}
	return 0;
}
```

---

## 作者：Yzmddsw (赞：2)

# P11210 题解

## 解法
![](https://cdn.luogu.com.cn/upload/image_hosting/kx5r6v2h.png?x-oss-process=image/resize,m_lfit,h_570,w_555)

放一张可以直观理解的图。

考虑先找到矩形内横坐标最小的点，即纵坐标满足 $l \leq y \leq r$ 的横坐标 $x$ 最小的点 $P(x_0,y_0)$，从而筛去一些可能对答案造成影响的点（例如上图点 $Q$）。若查找到的 $x_0>r$，则矩形内**没有点**。

显然矩形里所有合法的点的横坐标 $x \ge x_0$，然后查找矩形中 $x-y$ 最小的点。

考虑判断所有横坐标在 $[x_0,r]$ 的所有点，如果点 $(x_i,y_i)$ 的纵坐标 $y_i<l$，则 $x_i-y_i>x_0-y_i>x_0-y_0$，所以即使选择了该点也不会对答案产生影响，于是我们可以直接找出横坐标在 $[x_0,r]$ 中的最小的 $x-y$。

我们就可以使用线段树来维护上面两个信息。

第一棵线段树维护纵坐标区间的 $x$ 的最小值。

第二棵线段树维护横坐标区间的 $x-y$ 最小值。

叶节点使用 multiset 直接存点修改。

修改和查询复杂度 $O(\log n)$，总复杂度 $O((n+q) \log n)$。

## 代码


```cpp
#include <iostream>
#include <set>
using namespace std;
const int N=500005;
multiset<int>a[N],b[N];
int w[N<<2],v[N<<2],f[N<<2];
int n,q;
int read() {
	int x=0,w=1;char ch=0;
	while (ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+(ch-'0');ch=getchar();}
	return x*w;
}
void upd1(int L,int R,int p,int x,int y,int idx){
	if(L==R){
		if(y)a[L].erase(a[L].find(y));
		if(x)a[L].insert(x);
		w[p]= (*a[L].begin());
		if(!(*a[L].begin()))w[p]=998244353;
		return ;
	}
	int mid=(L+R)>>1;
	if(idx<=mid)upd1(L,mid,p<<1,x,y,idx);
	if(idx>mid)upd1(mid+1,R,(p<<1)|1,x,y,idx); 
	w[p]=min(w[p<<1],w[(p<<1)|1]);
}
void upd2(int L,int R,int p,int x,int y,int idx){
	if(L==R){
		if(y)b[L].erase(b[L].find(y));
		if(x)b[L].insert(x);
		if(!b[L].empty()) v[p]=idx-(*b[L].rbegin());
		else v[p]=998244353;
		return ;
	}
	int mid=(L+R)>>1;
	if(idx<=mid)upd2(L,mid,p<<1,x,y,idx);
	if(idx>mid)upd2(mid+1,R,(p<<1)|1,x,y,idx);
	v[p]=min(v[p<<1],v[(p<<1)|1]);
}
int get1(int L,int R,int l,int r,int p){
	if(l<=L&&R<=r){
		return w[p];
	}
	int mid=(L+R)>>1;
	int c=998244353;
	if(l<=mid)c=get1(L,mid,l,r,p<<1);
	if(mid<r)c=min(c,get1(mid+1,R,l,r,(p<<1)|1));
	return c;
}
int get2(int L,int R,int l,int r,int p){
	if(l<=L&&R<=r){
		return v[p];
	}
	int mid=(L+R)>>1;
	int c=998244353;
	if(l<=mid)c=get2(L,mid,l,r,p<<1);
	if(mid<r)c=min(c,get2(mid+1,R,l,r,(p<<1)|1));
	return c;
}
int x[N],y[N];
int main(){
	n=read(),q=read();
	for(int i=0;i<=2000005;i++){
		w[i]=v[i]=998244353;
	}
	for(int i=1;i<=n;i++){
		x[i]=read();y[i]=read();
		upd1(1,n,1,x[i],0,y[i]);
		upd2(1,n,1,y[i],0,x[i]);
	}
	int ans=0;
	while(q--){
		char opt;
		cin>>opt;
		if(opt=='U'){
			int i=read(),l=read(),r=read();
			i^=ans,l^=ans,r^=ans;
			upd1(1,n,1,0,x[i],y[i]);
			upd2(1,n,1,0,y[i],x[i]);
			x[i]=l;y[i]=r; 
			upd1(1,n,1,l,0,r);
			upd2(1,n,1,r,0,l);
		}
		else {
			int l=read(),r=read();
			l^=ans,r^=ans;
			int yl=get1(1,n,l,r,1);
			if(yl>n||yl>r)ans=0;
			else ans=get2(1,n,max(l,yl),r,1); 
			if(ans>n)ans=0;
			printf("%d\n",ans);
		}
	}
	return 0;	
}
```

---

## 作者：XZhuRen (赞：1)

奶龙。

什么时候支配对板子也 `ad-hoc` 了。

题意转化足够清楚，不再赘述。

放松条件，考虑支配区间：

将区间按照 $l_i$ 升序排序，则 $r_i$ 为 $\operatorname{sufmin}\{r_i\}$。

对于一次询问 $(L,R)$：

所以首先找到 $l$ 下标，维护一下区间 $\min\{r_i\}$，然后可以线段树二分找到最后的 $\operatorname{sufmin}\{r_p\}\le R$，接下来 $[l,p]$ 内的支配线段都是可能的答案。

不需要考虑不支配的，直接区间 $\min\{r_i-l_i\}$ 即可。

维护两颗线段树还是太难绷了，直接一颗二分一下就好了。

所有维护都是简易的。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5;
const int M=2e6+5;
const int inf=1e8+7;
multiset<int>S[N];
namespace sgt{
#define ls (o<<1)
#define rs (ls|1)
#define mid ((l+r)>>1)
	int L[M],R[M];
	int mnr[M],mn1[M];
	void pushup(int o){
		mnr[o]=min(mnr[ls],mnr[rs]);
		mn1[o]=min(mn1[ls],mn1[rs]);
	}
	void build(int o,int l,int r){
		L[o]=l,R[o]=r;
		if(l==r){
			mnr[o]=*S[l].begin(),mn1[o]=(*S[l].begin())-l;
			return;
		}
		build(ls,l,mid),build(rs,mid+1,r);
		pushup(o);
	}
	void update(int o,int pos){
		int l=L[o],r=R[o];
		if(l==r){
			mnr[o]=*S[l].begin(),mn1[o]=(*S[l].begin())-l;
			return;
		}
		update(pos<=mid?ls:rs,pos);
		pushup(o);
	}
	int find(int lim){//最后的 sufmin(r<=lim) 的点
		int o=1,l,r,res=0;
		while(1){
			l=L[o],r=R[o];
			if(mnr[o]>lim)break;
			if(l==r){res=l;break;}
			o=(mnr[rs]<=lim?rs:ls);
		}
		return res;
	}
	int qrymn(int o,int lt,int rt){
		int l=L[o],r=R[o];
		if(l>=lt&&r<=rt)return mn1[o];
		int res=inf;
		if(lt<=mid)res=min(res,qrymn(ls,lt,rt));
		if(rt> mid)res=min(res,qrymn(rs,lt,rt));
		return res;
	}
#undef ls
#undef rs
#undef mid
}
int Qry(int L,int R){
	int l=L,r=sgt::find(R);
	if(l>r)return 0;
	int res=sgt::qrymn(1,l,r);
	return (res==inf?0:res);
}
int xs[N],ys[N];
int n,q;
void init(){
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++)
		S[i].clear(),S[i].insert(i+inf);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&ys[i],&xs[i]);
		S[xs[i]].insert(ys[i]);
	}
	sgt::build(1,1,n);
	
}
void work(){
	int Ans=0;
	int x,y,i;
	char ops;scanf("\n");
	while(q--){
		scanf("%c",&ops);
		if(ops=='U'){
			scanf("%d%d%d\n",&i,&y,&x);
			i^=Ans,x^=Ans,y^=Ans;
			S[xs[i]].erase(S[xs[i]].find(ys[i]));
			sgt::update(1,xs[i]);
			xs[i]=x,ys[i]=y;
			S[xs[i]].insert(ys[i]);
			sgt::update(1,xs[i]);
		}
		if(ops=='Q'){
			scanf("%d%d\n",&x,&y);
			x^=Ans,y^=Ans;
			Ans=Qry(x,y);
			printf("%d\n",Ans);
		}
	}
}
int main(){
	init();
	work();
	return 0;
}
```

---

## 作者：Genius_Star (赞：1)

### 思路：

由于 $x \ge y$，那么一个点 $(x, y)$ 的贡献应该是到 $(x, x)$ 的距离。

请看图：

![](https://cdn.luogu.com.cn/upload/image_hosting/jxmrmp98.png)

对于一次矩形查，我们考虑找到图中那个棕色的分界线 $mid$，使得左边向下挂的点都**越界**了，分界线右边第一个点没有越界。

令 $ans_i$ 表示 $x = i$ 时 $x - y$ 的最小值，那么答案就是 $\min\limits_{i = mid}^{r} ans_i$，这是因为对于分界线右侧至少有一个合法点，显然这个合法点的贡献是比所有非合法点更优的，

故我们使用线段树维护区间 $\min ans_i$ 与向上挂的最大的点即区间最大的 $y$，在线段树上二分找分界线即可；对于每个位置，使用 `multiset` 维护所有的权值，即可支持插入删除。

时间复杂度为 $O(N \log N)$。

### 完整代码：

```cpp
 #include<bits/stdc++.h>
#define lowbit(x) x & (-x)
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define add(x, y) ((x + y >= mod) ? (x + y - mod) : (x + y))
#define dec(x, y) ((x - y < 0) ? (x - y + mod) : (x - y))
#define ctz(x) __builtin_ctz(x)
#define popcnt(x) __builtin_popcount(x)
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
using namespace std;
typedef __int128 __;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const int N = 5e5 + 10;
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
struct Node{
	int l, r;
	int ans, data;
}X[N << 2];
bool F;
char op;
int n, q, i, x, y, now, ans;
int a[N], b[N];
multiset<int> S[N];
inline char get(){
	char c = getchar();
	while(c != 'U' && c != 'Q')
	  c = getchar();
	return c;
}
inline void pushup(int k){
	X[k].ans = min(X[k << 1].ans, X[k << 1 | 1].ans);
	X[k].data = max(X[k << 1].data, X[k << 1 | 1].data);
}
inline void build(int k, int l, int r){
	X[k].l = l, X[k].r = r;
	if(l == r){
		if(S[l].empty())
		  X[k].ans = 1e9, X[k].data = -1e9;
		else
		  X[k].ans = *S[l].begin(), X[k].data = l - *S[l].begin();
		return ;
	}
	int mid = (l + r) >> 1;
	build(k << 1, l, mid);
	build(k << 1 | 1, mid + 1, r);
	pushup(k);
}
inline void update(int k, int i){
	if(X[k].l == i && i == X[k].r){
		if(S[i].empty())
		  X[k].ans = 1e9, X[k].data = -1e9;
		else
		  X[k].ans = *S[i].begin(), X[k].data = i - *S[i].begin();
		return ;
	}
	int mid = (X[k].l + X[k].r) >> 1;
	if(i <= mid)
	  update(k << 1, i);
	else
	  update(k << 1 | 1, i);
	pushup(k);
}
inline int query(int k, int l, int r){
	if(X[k].l == l && r == X[k].r)
	  return X[k].ans;
	int mid = (X[k].l + X[k].r) >> 1;
	if(r <= mid)
	  return query(k << 1, l, r);
	else if(l > mid)
	  return query(k << 1 | 1, l, r);
	else
	  return min(query(k << 1, l, mid), query(k << 1 | 1, mid + 1, r));
}
inline int getmax(int k, int l, int r){
	if(X[k].l == l && r == X[k].r)
	  return X[k].data;
	int mid = (X[k].l + X[k].r) >> 1;
	if(r <= mid)
	  return getmax(k << 1, l, r);
	else if(l > mid)
	  return getmax(k << 1 | 1, l, r);
	else
	  return max(getmax(k << 1, l, mid), getmax(k << 1 | 1, mid + 1, r));	
}
inline int ask(int k, int v){
	if(X[k].l == X[k].r)
	  return X[k].l;
	if(X[k << 1].data >= v)
	  return ask(k << 1, v);
	else
	  return ask(k << 1 | 1, v);
}
inline void ask(int k, int l, int r, int v){
	if(F)
	  return ;
	if(X[k].l == l && r == X[k].r){
		if(X[k].data >= v){
			F = 1;
			now = ask(k, v);
		}
		return ;
	}
	int mid = (X[k].l + X[k].r) >> 1;
	if(r <= mid)
	  ask(k << 1, l, r, v);
	else if(l > mid)
	  ask(k << 1 | 1, l, r, v);
	else{
		ask(k << 1, l, mid, v);
		ask(k << 1 | 1, mid + 1, r, v);
	}
}
bool End;
int main(){
	n = read(), q = read();
	for(int i = 1; i <= n; ++i){
		a[i] = read(), b[i] = read();
		S[a[i]].insert(a[i] - b[i]);
	}
	build(1, 1, n);
	while(q--){
		op = get();
		if(op == 'U'){
			i = read() ^ ans, x = read() ^ ans, y = read() ^ ans;
			S[a[i]].erase(S[a[i]].find(a[i] - b[i]));
			update(1, a[i]);
			a[i] = x, b[i] = y;
			S[a[i]].insert(a[i] - b[i]);
			update(1, a[i]);
		}
		else{
			x = read() ^ ans, y = read() ^ ans;
			if(getmax(1, x, y) < x){
				write(ans = 0);
				putchar('\n');
				continue;
			}
			now = F = 0;
			ask(1, x, y, x);
			write(ans = query(1, now, y));
			putchar('\n');
		}
	}
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：Acheron_RBM (赞：1)

这题有个显然的结论：所有包含了某个区间的区间，其必然不可能成为答案。

此时我们会发现左右端点均单调不降，那么只需要找到第一个满足 $l \le l_n$ 的 $n$ 和最后一个 $r_m\le r$ 的 $m$ 即可。

此时答案就是 $\min\limits_{i=n}^m(r_i-l_i)$。

这个东西显然可以用线段树以及 `multiset` 维护。

code：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int INF=1e9;
int n,q,x[600000],y[600000];
multiset<int>s[600000];
struct stree
{
	#define lsx (rt<<1)
	#define rsx (rt<<1|1)
	int mx[600000<<2],mn[600000<<2];
	inline void pushup(int rt)
	{
		mx[rt]=max(mx[lsx],mx[rsx]);
		mn[rt]=min(mn[lsx],mn[rsx]);
	}
	inline void build(int rt,int l,int r)
	{
		if(l==r)
		{
			if(!s[l].size())
			{
				mx[rt]=0,mn[rt]=INF;
			}
			else
			{
				mx[rt]=*--s[l].end();
				mn[rt]=l-mx[rt];
			}
			return ;
		}
		int mid=(l+r)>>1;
		build(lsx,l,mid);
		build(rsx,mid+1,r);
		pushup(rt);
	}
	inline void modify(int rt,int l,int r,int p)
	{
		if(l==r)
		{
			if(!s[l].size())
			{
				mx[rt]=0,mn[rt]=INF;
			}
			else
			{
				mx[rt]=*--s[l].end();
				mn[rt]=l-mx[rt];
			}
			return ;
		}
		int mid=(l+r)>>1;
		if(p<=mid)
		{
			modify(lsx,l,mid,p);
		}
		else
		{
			modify(rsx,mid+1,r,p);
		}
		pushup(rt);
	}
	inline int query(int rt,int l,int r,int l1,int r1)
	{
		if(l1<=l&&r<=r1)
		{
			return mn[rt];
		}
		int mid=(l+r)>>1,mn=INF;
		if(l1<=mid)
		{
			mn=min(mn,query(lsx,l,mid,l1,r1));
		}
		if(r1>mid)
		{
			mn=min(mn,query(rsx,mid+1,r,l1,r1));
		}
		return mn;
	}
	inline int find(int rt,int l,int r,int l1,int r1,int v)
	{
		if(r<l1||l>r1||mx[rt]<v)
		{
			return -1;
		}
		if(l==r)
		{
			return l;
		}
		int mid=(l+r)>>1,flag=find(lsx,l,mid,l1,r1,v);
		if(flag==-1)
		{
			flag=find(rsx,mid+1,r,l1,r1,v);
		}
		return flag;
	}
}tree;
int lastt;
int main()
{
	cin>>n>>q;
	for(int i=1;i<=n;i++)
	{
		cin>>x[i]>>y[i];
		s[x[i]].insert(y[i]);
	}
	tree.build(1,1,n);
	while(q--)
	{
		char op;
		cin>>op;
		if(op=='U')
		{
			int i,a,b;
			cin>>i>>a>>b;
			i^=lastt,a^=lastt,b^=lastt;
			s[x[i]].erase(s[x[i]].find(y[i]));
			tree.modify(1,1,n,x[i]);
			s[x[i]=a].insert(y[i]=b);
			tree.modify(1,1,n,x[i]);
		}
		else
		{
			int l,r;
			cin>>l>>r;
			l^=lastt,r^=lastt;
			int flag=tree.find(1,1,n,l,r,l);
			if(flag==-1)
			{
				lastt=0;
			}
			else
			{
				lastt=tree.query(1,1,n,flag,r);
			}
			cout<<lastt<<'\n';
		}
	}
}
```

---


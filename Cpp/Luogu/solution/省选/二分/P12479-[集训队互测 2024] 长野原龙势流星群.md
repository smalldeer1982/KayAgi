# [集训队互测 2024] 长野原龙势流星群

## 题目描述

Naganohara Yoimiya 给了你一棵 $n$ 个节点的有根树，$1$ 号节点是根节点，每个点有点权 $w_i$。

你需要对每个点 $u$ 找到一个以 $u$ 为根的非空连通块，并最大化这个连通块内所有点的点权的平均值。

对每个点 $u$ 输出这个最大的平均值。

## 说明/提示

### 测试点约束

对于所有数据，$1\le n\le 2\times 10^5,1\le w_i\le 10^9$。

- Subtask 1（$10$ 分）：$1\le n\le 2000$。
- Subtask 2（$10$ 分）：$p_i=\lfloor i/2\rfloor$。
- Subtask 3（$40$ 分）：$1\le n\le 50000$。
- Subtask 4（$40$ 分）：无特殊限制。

## 样例 #1

### 输入

```
6
1 2 2 1 4
3 1 5 6 6 7```

### 输出

```
4.6666666667
4.7500000000
5.0000000000
6.5000000000
6.0000000000
7.0000000000```

# 题解

## 作者：E_firework (赞：7)

简单题。

考虑点权最大的一个节点，假设其为 $x$，那么以 $x$ 为根的答案一定是只选 $x$ 这一个点，因为在连通块中加入其他的节点不能使得答案变得更优。再考虑 $x$ 的父亲，假设其为 $y$。不难发现，如果一个最优的连通块包含了节点 $y$，那也一定会包含节点 $x$，因为加入节点 $x$ 一定不会使得答案变劣。那么我们可以直接把 $x$ 和 $y$ 缩成一个点处理。接下来只需要把找到点权最大的一个节点改为找到平均点权最大的一个节点，重复上述的过程就能得到每个节点的答案。使用优先队列+并查集可以很容易地维护上述过程，时间复杂度为 $O(n\log n)$。

code：

```cpp
#include <bits/stdc++.h>
#define LL long long
#define Maxn 200005
using namespace std;
inline LL read(){char c;c = getchar();while(!(('0' <= c && c <= '9') || c == '-')) c = getchar();bool flag = 0;if(c == '-'){flag = 1;c = getchar();}LL tot = 0;while('0' <= c && c <= '9'){tot = 10 * tot + c - '0';c = getchar();}return flag ? -tot : tot;}
int fa[Maxn], f[Maxn], c[Maxn];
LL s[Maxn];
double ans[Maxn];
int find(int i){
    return i == f[i] ? i : f[i] = find(f[i]);
}
__int128 t1 = 1;
struct node{
    LL a;
    int b, id;
    bool operator<(const node i)const{
        return t1 * a * i.b < t1 * i.a * b;
    }
};
priority_queue<node> q;
int main(){
    int n = read();
    for(int i = 2; i <= n; i++) fa[i] = read();
    for(int i = 1; i <= n; i++) s[i] = read();
    for(int i = 1; i <= n; i++){
        f[i] = i, c[i] = 1;
        q.push({s[i], 1, i});
    }
    int x, y;
    while(q.size()){
        x = q.top().id;
        q.pop();
        if(f[x] != x) continue;
        ans[x] = 1.0 * s[x] / c[x];
        y = find(fa[x]);
        f[x] = y;
        if(y){
            s[y] += s[x];
            c[y] += c[x];
            q.push({s[y], c[y], y});
        }
    }
    for(int i = 1; i <= n; i++) printf("%.12lf\n", ans[i]);
    return 0;
}
```

---

## 作者：kkxacj (赞：3)

做法其实和 [UVA1205 Color a Tree](https://www.luogu.com.cn/problem/UVA1205) 是一样的，可以在做完这题后看看这道。

#### 思路

考虑按权值从大到小枚举点，每个点有三个值，分别是下标，大小和平均权值，假设前面的已经处理完，那么目前枚举的 $i$ 就是最大的，那么 $ans_i$ 就为这里的平均权值。注意到这个点只能对父亲造成贡献（题目要求只能选子树内的），由于我们是从大到小枚举，如果父亲没有被枚举，那么合并后父亲一定会更优，合并之后把这个新点扔进集合，下标仍是父亲那个点的下标，权值和大小更新一下就好了，然后删掉原来那个点，重复这个过程直到空，这样算出来的答案一定是最优的。

证明比较显然，首先对于点 $i$，如果它需要儿子 $j$ 的一部分，那么选的一定的是以 $j$ 为根的最平均权值大的连通块，然后就是合并顺序，由于 $a > b > c$，那么 $a,c$ 的平均数大于 $b,c$ 的平均数，所以对于 $c$ 来讲只有可能是 $a,c$ 和 $a,b,c$ 中的一个，那么能选的话就一定会选 $a$，所以这个合并顺序就是最优的。

具体实现的话，使用并查集维护点权，然后删点的话我们没必要真的去删，注意到一个事实，每次合并答案一定更优，**假设合并完平均权值没变也更优**，这是因为由于值是从大到小枚举的，在保证值大的时候尽量保证个数多，这样一来小的影响就会降低。更优就会优先访问，那么记一个 $vis$ 记录是否便利了即可。

关于值相同的情况，注意到题目特殊的建树方式，祖先下标一定小于自己，我们第二关键字为下标的话就可以完美解决这个问题了。

**code**

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace IO
{
	template<typename T>
	void read(T &_x){_x=0;int _f=1;char ch=getchar();while(!isdigit(ch)) _f=(ch=='-'?-1:_f),ch=getchar();while(isdigit(ch)) _x=_x*10+(ch^48),ch=getchar();_x*=_f;}
	template<typename T,typename... Args>
	void read(T &_x,Args&...others){Read(_x);Read(others...);}
	const int BUF=20000000;char buf[BUF],top,stk[32];int plen;
	#define pc(x) buf[plen++]=x
	#define flush(); fwrite(buf,1,plen,stdout),plen=0;
	template<typename T>inline void print(T x){if(!x){pc(48);return;}if(x<0) x=-x,pc('-');for(;x;x/=10) stk[++top]=48+x%10;while(top) pc(stk[top--]);}
}
using namespace IO;
const int N = 2e5+10;
int n,fa[N],f[N],v[N],y,z;
priority_queue<pair<double,int> >p;
double ans[N],w[N],siz[N],x;
int find(int x)
{
	if(f[x] == x) return x;
	return f[x] = find(f[x]);
}
signed main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	read(n);
	for(int i = 2;i <= n;i++) read(fa[i]);
	for(int i = 1;i <= n;i++) cin >> w[i],f[i] = i,siz[i] = 1;
	for(int i = 1;i <= n;i++) p.push(make_pair(w[i],i));
	while(!p.empty())
	{
		x = p.top().first,y = p.top().second; p.pop();
		if(v[y]) continue; v[y] = 1;
	//	cout<<x<<" && "<<y<<" "<<siz[y]+siz[find(fa[y])]<<" "<<w[find(fa[y])]*siz[find(fa[y])]+x<<" "<<w[y]<<" "<<siz[]<<endl;
		ans[y] = x;
		if(!fa[y]) continue;
		if(!v[find(fa[y])]) w[find(fa[y])] = 1.0*(w[find(fa[y])]*siz[find(fa[y])]+x*siz[y])/(siz[y]+siz[find(fa[y])]),p.push(make_pair(w[find(fa[y])],find(fa[y])));
	//	cout<<x<<" %% "<<y<<" "<<find(fa[y])<<" "<<w[find(fa[y])]<<endl;
		siz[find(fa[y])] += siz[y],f[y] = find(fa[y]);
	}
	for(int i = 1;i <= n;i++) printf("%.7f\n",ans[i]);
	return 0;
}
```

---

## 作者：cogimyun (赞：1)

### 被 hack 的缺陷做法
我们考虑任意一个节点 $i$ 如果已经是当前平均数最大值，那么必然不存在一个节点能够使节点 $i$ 的平均数更大。考虑到节点 $i$ 的父节点 $j$ ，此时节点 $j$ 的平均值一定 $\le$ 节点 $i$ 的平均值，所以此时可以通过节点 $i$ 的平均值更新节点 $j$ 的平均值，于是我们可以考虑使用优先队列维护最大值。

然后考虑题目中要求求的值是：
>每个点 $u$ 找到一个以 $u$ 为根的非空连通块并最大化这个连通块内所有点的点权的平均值

所以此时的节点 $i$ 在更新了父节点 $j$ 后，就无法直接更新其它节点了（因为节点 $i$ 并不能更新它的子节点），而是通过更新后的父节点 $j$ 来间接更新其它节点，于是我们考虑用并查集维护连通块，在每次节点 $i$ 在更新了父节点 $j$ 后就将节点 $i$ 并入节点 $j$ 所在的连通块。

但值得注意的是，节点 $i$ 在完成了更新节点 $j$ 后，其部分不优的值可能仍然在优先队列中，所以每次查询优先队列最大值后还要判断这个最大节点 $i$ 是否是自己所处连通块的根，如果是，则可以更新父节点 $j$,否则跳过这个值。但以上的做法仍存在缺陷，于是我们不妨观察一下 hack 数据。

### 优化缺陷部分

考虑到 Subtask # 5 中的 hack 数据：
```
输入
4
1 2 2
1 2 4 3
输出
2.5000000000
3.0000000000
4.0000000000
3.0000000000
```
如果一个节点的平均值是 $\frac{q}{p}$ 另一个节点的平均值是 $\frac{s}{t}$，我们会令其中更大的值先被用于更新，但如果有 $\frac{q}{p} = \frac{s}{t}$,我们应该认为 $p$ 与 $t$ 更大的一个更优，我们可以感性理解一下，当分母更大时，那么加上另外一个值时对于这个平均值的影响更小。
# CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,fa[200005],f[200005],w[200005];
struct node{
	long long x;
	int y,id;
}tr[200005];
bool operator <(node x,node y){
	return (__int128(x.x*y.y)==__int128(y.x*x.y))?x.y<y.y:(x.x*y.y)<__int128(y.x*x.y);
}
priority_queue<node> q;
int getf(int x){
	return (f[x]==x)?x:f[x]=getf(f[x]);
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=2;i<=n;i++)
		cin>>fa[i];
	for(int i=1;i<=n;i++){
		cin>>w[i];
		tr[i]={w[i],1,i};
		q.push(tr[i]);
		f[i]=i;
	}
	while(!q.empty()){
		node t=q.top();
		q.pop();
		if(f[t.id]!=t.id)
			continue;
		int k=getf(fa[t.id]);
		tr[k].x+=t.x;
		tr[k].y+=t.y;
		f[t.id]=k;
		if(k)
			q.push(tr[k]);
	}
	for(int i=1;i<=n;i++)
		cout<<setprecision(12)<<(long double)(1.0*tr[i].x/tr[i].y)<<endl;//setprecision(12)是保留12位小数，减小相对误差
	return 0;
}

```

---

## 作者：BlackHoles (赞：1)

**背景**：被神奇做法惊艳到了，写一篇题解记录一下，同时加深我对这题的理解。

### 前置知识

贪心，并查集，优先队列的应用。

### 朴素想法

枚举每个点，依次求出每个点的答案，发现使用二分答案和树形动态规划，即可做到 $O(n^2 V)$，其中 $V$ 为二分次数。不过复杂度爆炸，遗憾爆零。

### 正解

观察到一个简单的性质：对于点权最大的点 $x$，选取任何点和它合并为一个连通块都不会使答案变优，因此这个结点只能单独作战。同时，假如一个最优连通块包含 $p_x$，那么也一定包含 $x$，因为 $x$ 的加入不会使答案变劣。此时，我们可以将 $x$ 与 $p_x$ 进行合并，我们称之为捆绑点，合并可以使用并查集进行维护。连通块信息的记录可以使用优先队列。

于是我们抽象出最终算法：初始时每个点单独为连通块，每次从堆中选取平均点权 $perw$ 最大的连通块，记连通块根节点为 $root$，则 $ans_{root} = perw$，同时若其存在父节点，则将父节点所在连通块与该连通块进行合并，放入优先队列中。

时间复杂度显然为 $O(n \log n)$，可以通过本题测试数据。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long double ld;
typedef long long ll;
const int N = 200005;
int n, p[N], f[N], w[N], num[N];
ld ans[N];
ll sum[N];
struct Node {
	int idx, num;
	ll sum;
	Node () {}
	Node (int idx, int num, ll sum) : idx(idx), num(num), sum(sum) {}
	bool operator < (const Node cmp) const {
		return (sum * cmp.num < cmp.sum * num);
	}
};
priority_queue <Node> pq;
int find(int x) {
	return (f[x] == x ? x : f[x] = find(f[x]));
}
int main(void) {
	scanf("%d", &n);
	for (int i = 2; i <= n; ++i)
		scanf("%d", &p[i]);
	for (int i = 1; i <= n; ++i)
		scanf("%d", &w[i]);
	for (int i = 1; i <= n; ++i)
		sum[i] = w[i], num[i] = 1, f[i] = i;
	for (int i = 1; i <= n; ++i)
		pq.push(Node(i, 1, w[i]));
	while (!pq.empty()) {
		int x = pq.top().idx;
		pq.pop();
		if (f[x] != x) continue;
		int y = find(p[x]);
		f[x] = y;
		ans[x] = (ld)sum[x] / num[x];
		if (p[x]) {
			sum[y] += sum[x];
			num[y] += num[x];
			pq.push(Node(y, num[y], sum[y]));
		}
	}
	for (int i = 1; i <= n; ++i)
		printf("%.12Lf\n", ans[i]);
	return 0;
}
```

---

## 作者：one_of_the_person (赞：1)

居然没有场切，我已经菜完了。
## 思路
设 $s_i=w_i-X$ ，且 $f_i=s_i+\sum_{u\in Son}\max(f_u,0)$ ，我们可以知道当一个 $X$ 使得 $f_i=0$ 时，$X$ 就是点 $i$ 的答案。我们考虑使 $X$ 逐渐减小，显然 $f$ 会逐渐增大。当一个 $X$ 使得 $f_v$ 恰好等于 $0$ ，那么在接下来 $X$ 继续减小时，$v$ 的父亲一定会选则加上 $f_v$，所以我们考虑用并查集维护连通块，用优先队列从大往小更新每一个节点的答案并且合并连通块。时间复杂度 $O(n\log n)$。
## AC 代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define N 1000000
using namespace std;
struct Que{
	int id;
	double v;
	bool friend operator<(Que x,Que y){return y.v>x.v;}
};
int n,fa[N+5],f[N+5],s[N+5],w[N+5],sum[N+5]={};
double ans[N+5];
priority_queue<Que>q;
int find(int x){
	if(f[x]==x)return x;
	int root=find(f[x]);
	return f[x]=root;
}
void merge(int x,int y){f[x]=y,s[y]+=s[x],sum[y]+=sum[x];return;}
int read(){
	int f=1,g=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while('0'<=ch&&ch<='9'){
		g=g*10+ch-'0';
		ch=getchar();
	}
	return f*g;
}
main(){
	n=read();
	for(int i=2;i<=n;i++)fa[i]=read();
	for(int i=1;i<=n;i++)w[i]=read(),f[i]=i,s[i]=1,sum[i]=w[i],q.push({i,1.0*w[i]});
	while(q.size()){
		while(q.size()&&ans[q.top().id])q.pop();
		if(q.empty())break;
		ans[q.top().id]=q.top().v;
		if(fa[q.top().id])merge(find(q.top().id),find(fa[q.top().id]));
		q.push({find(q.top().id),sum[find(q.top().id)]*1.0/s[find(q.top().id)]});
	}
	for(int i=1;i<=n;i++)printf("%.10lf\n",ans[i]);
	return 0;
}
```

---

## 作者：ln001 (赞：1)

拜谢 [WhisperingWillow](https://www.bilibili.com/video/BV1Z5411Q7Vr/) 的做法和讲解。
## 题意
对于一颗带点权的有根树，求以每个点 $i$ 为根的**子树中**，所有包含 $i$ 的连通块中最大的平均点权。

---
[此处折叠了一些没必要的内容](https://www.luogu.com.cn/paste/rfjksx5t)

---

## 正解
类比 dijkstra，将连通块分为确定的与不确定的，称最终答案为确定的连通块，而不确定的连通块可能会因不够优秀被舍弃。猜想每次取平均点权最大的不确定连通块，将其转为确定连通块并向上合并更新答案。容易发现是正确的，正确性在最后简单一证。

具体的，初始时将每个点划到独立的连通块中，并扔到优先队列里，优先队列是按照平均点权降序排序的，每次取出一个连通块，若该连通块中深度最小的点（称为连通块的根）已经被更新出确定的连通块，则舍弃当前连通块。否则更新根的状态为具有确定的连通块。然后通过**并查集**找到根的父亲所在连通块的根，并试图合并，若合并更优则将新的连通块放到优先队列中。

代码在[这](https://www.luogu.com.cn/paste/ujfr84on)，hack 在[这](https://www.luogu.com.cn/discuss/1085681)。

hack 的原理比较简单，就是上述做法不能有效处理多个不确定的连通块平均点权一致的情况，具体情况自己去手模 hack 数据吧。解决方法为在连通块向上合并成功之后，应在优先队列中同时舍弃两个旧的连通块。

### Code

```cpp
// Problem: P12479 [集训队互测 2024] 长野原龙势流星群
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P12479
// Time Limit: 1000 ms
// Start Time:2025-05-23 08:09:57
// https://www.luogu.com.cn/article/rjfpb3yq
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#ifndef LOCAL
#define file_name ""
#define csf                                                                               \
    {                                                                                     \
        std::cerr.setstate(std::ios_base::failbit);                                       \
        if (file_name != "")                                                              \
            freopen(file_name ".in", "r", stdin), freopen(file_name ".out", "w", stdout); \
    }
#define db(x)
#else
#define db(x) cerr << __FUNCTION__ << " L" << __LINE__ << " " << #x " = " << (x) << endl
#define csf
#endif
#define ll long long
#define unordered_map __gnu_pbds::gp_hash_table
#define f(x, y, z) for (ll x = (y); x <= (z); x++)
inline ll read();
using namespace std;

const long long INF = 0x3f3f3f3f3f3f3f3f, N = 2e5 + 10;
ll n;
ll fa[N], dep[N];
ll a[N];
struct node
{
    ll a, b = 1;
    ll id, pri;
    bool operator<(const node &c) const
    {
        return a * c.b < c.a * b;
    }
} ans[N];

ll bfa[N];
ll fifa(ll x)
{
    if (bfa[x] == x)
        return x;
    return bfa[x] = fifa(bfa[x]);
}

bool gans[N];
signed main()
{
    csf;
    cin >> n;
    f(i, 2, n) cin >> fa[i];
    f(i, 1, n) cin >> a[i];

    gans[0] = 1; //根不能再向上更新了
    f(i, 1, n) dep[i] = dep[fa[i]] + 1;
    f(i, 1, n) bfa[i] = i;
    f(i, 1, n) ans[i] = {a[i], 1, i, dep[i]};

    priority_queue<node> pq;
    f(i, 1, n) pq.push(ans[i]);
    while (pq.size())
    {
        auto [a, b, x, pri] = pq.top();
        pq.pop();
        if (gans[x] || b != ans[x].b)
            continue;
        gans[x] = 1;

        ll nxt = fifa(fa[x]); //根的父亲的根
        if (!gans[nxt])
        {
            bfa[fifa(x)] = nxt; //合并并查集
            ans[nxt].a += a;
            ans[nxt].b += b;
            pq.push(ans[nxt]);
        }
    }

    f(i, 1, n) printf("%.10lf\n", (double)ans[i].a / ans[i].b);
    return 0;
}
```

### 填坑
上文提到本题解缺了个证明，即证明每次取平均点权最大的不确定连通块是对的，证明向上贪心合并是对的。~~我已经找到了一个绝妙的证明方法，但是这里太窄了，写不下。~~

考虑同时取出优先队列顶部的两个连通块，且两连通块的的根的父亲相同，若最大的那个更新父亲所在连通块后父亲所在连通块平均值超过次大的那个，则更新是正确的，若未超过，则会在下一次循环中被次大的连通块更新，也是正确的。

---

## 作者：TH911 (赞：0)

> [题目传送门](https://www.luogu.com.cn/problem/P12479)
>
> [不知道会不会更好的阅读体验](https://www.cnblogs.com/TH911/p/-/P12479)

# 题意分析

发现平均值不好维护，因此可以维护连通块的**大小**与**权值和**。

假设得到了以 $x$ 为根的连通块的答案，那么如果存在一个连通块包含了这个连通块，**一定要包含 $x$ 的父节点**。因此在得出 $x$ 的答案后，$x$ 连通块的作用**等价于其父节点 $\textit{father}_x$ 与 $x$ 的连通块构成的大连通块**。

因此考虑一种数据结构，能够维护这种操作，考虑带权并查集维护连通块大小、权值和。

同时使用大根堆每次找平均值最大的连通块，并更新其父节点的连通块信息即可。初始时所有连通块均只有一个节点。而点权最大的的对应连通块显然是自己。

这些连通块维护的答案一定是不劣的，否则由于大根堆，已经维护过了更优的答案。

时间复杂度 $\mathcal O(n\log n)$。

# AC 代码

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
typedef long long ll;
constexpr const double eps=1e-8;
constexpr const int N=5e5;
int n,a[N+1],father[N+1];
double ans[N+1];
bool vis[N+1];
struct node{
	int x;
	ll value;
	int size;
};
bool operator <(node a,node b){
	__int128 valueA=(__int128)a.value*b.size,valueB=(__int128)b.value*a.size;
	if(valueA!=valueB){
		return valueA<valueB;
	}else{
		return a.x<b.x;
	}
}
struct dsu{
	int f[N+1],size[N+1];
	ll value[N+1];
	int find(int x){
		if(f[x]==x){
			return x;
		}else{
			return f[x]=find(f[x]);
		}
	}
	void build(int n){
		for(int i=1;i<=n;i++){
			f[i]=i;
			value[i]=a[i];
			size[i]=1;
		}
	}
	void merge(int x,int y){
		x=find(x),y=find(y);
		f[x]=y;
		size[y]+=size[x];
		value[y]+=value[x];
	}
}t;
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>n;
	for(int i=2;i<=n;i++){
		cin>>father[i];
	}
	priority_queue<node>q;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		q.push({i,a[i],1});
	}
	t.build(n);
	while(q.size()){
		node top=q.top();q.pop();
		int &x=top.x;
		if(x!=t.find(x)){
			continue;
		}
		if(1.0*t.value[x]/t.size[x]>=ans[x]){
			ans[x]=1.0*t.value[x]/t.size[x];
			if(father[x]){
				father[x]=t.find(father[x]);
				t.merge(x,father[x]);
				q.push({father[x],t.value[father[x]],t.size[father[x]]});
			}
		}
	}
	for(int i=1;i<=n;i++){
		cout<<fixed<<setprecision(9)<<ans[i]<<'\n';
	}
	
	cout.flush();
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```

---


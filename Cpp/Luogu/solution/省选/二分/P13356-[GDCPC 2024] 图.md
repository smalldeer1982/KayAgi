# [GDCPC 2024] 图

## 题目背景

数据、标程、题解等资源的获取：<https://gitlink.org.cn/thusaa/gdcpc2024>

## 题目描述

给定一张 $n$ 个点 $m$ 条边的无向图，令 $k=\lceil\frac{m}{n-1}\rceil$，你需要判断能否找到两个不同的点 $u,v$，满足它们之间存在 $k$ 条**边不相交**路径，如果可以找到这样的 $u,v$，你需要输出这些路径，如果存在多种构造方案，输出任意一种即可。

额外需要注意的是输入**可能存在重边**，也就是对于同一个无序对 $(u,v)$，它们之间可能存在多条边，如果它们之间存在 $s$ 条边那么你可以理解为这条边可以经过 $s$ 次。

不过我们保证输入**不存在自环**。

## 说明/提示

第一组输入数据，存在 $\lceil\frac{m}{n-1}\rceil=\lceil\frac{1}{3-1}\rceil=1$ 条 $1$ 到 $3$ 的边不相交路径 $1\to 3$。

第二组输入数据，存在 $\lceil\frac{m}{n-1}\rceil=\lceil\frac{7}{4-1}\rceil=3$ 条 $1$ 到 $4$ 的边不相交路径 $1\to 2\to 3\to 4,1\to 4,1\to 4$，注意到 $1\to 4$ 这条边虽然经过了两次，但是在原输入中这条边也输入了两次，所以认为它们还是不同的边。

第三组输入数据，存在 $\lceil\frac{m}{n-1}\rceil=\lceil\frac{5}{5-1}\rceil=2$ 条 $3$ 到 $5$ 的边不相交路径 $3\to 4\to 5,3\to 5$。

## 样例 #1

### 输入

```
3
3 1
1 3
4 7
1 2
2 3
3 4
4 1
1 3
2 4
1 4
5 5
1 2
2 3
3 4
4 5
3 5```

### 输出

```
1 3
2 1 3
1 4
4 1 2 3 4
2 1 4
2 1 4
3 5
3 3 4 5
2 3 5```

# 题解

## 作者：SunsetGlow95 (赞：4)

# 题解 - GDCPC 2024 F 图

绝好题。

## 简述题意

给一个 $n$ 点 $m$ 边无向图，可能存在重边，不存在自环。令 $k=\lceil \frac{m}{n-1} \rceil$，找出点 $u,v(u\neq v)$，输出 $u\to v$ 的 $k$ 条边不交路径。无解输出 `-1`。

多测。$\sum n\le 10^5$，$\sum m\le 2\times 10^5$。

## 分析

看见 $n-1$ 想到树是当然的，但是如何进一步拓展是困难的。

观察样例，猜想是必然存在，而且 $k$ 正好是上界。考虑 $u\to v$ 的路径有至少 $k$ 条。且由题，$\frac{m}{n-1}\le k<\frac{m+n-1}{n-1}$，如果纠结在取等的不等号，则有点使人疑惑。

另一个有关于树的结论是：一棵树上，任意两点间有唯一路径。

那么，能否构造若干个森林，使得在每个森林里，$u,v$ 都联通，然后在每个森林都找出 $u\to v$ 的路径？

那么一种自然的想法是，让每对 $(u,v)$ 都在一段前缀森林中联通。这样，对每个边我们从前往后逐个尝试加入并查集中即可。事实上，这个过程可以二分优化。

下面，我们要证明这个结论的正确性。

如果可能找不到，那么最后一个森林中一条边也没有。而前面的 $k-1$ 个森林中，至多有 $(k-1)(n-1)$ 条边，根据 $k(n-1)<m+n-1$，$(k-1)(n-1)<m$，即必有富余的边会考虑加入第 $k$ 个森林。所以最后一个森林中必有边。这启示我们，面对取整符号，两端都要留意。

时间复杂度 $O(n\log m\alpha (n))$，实现不精细，两只 $\log$ 也可以了。空间复杂度 $O(m)$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int find(vector<int>& fa, int x) {
  return ~fa[x] ? fa[x] = find(fa, fa[x]) : x;
}

int main() {
  int T(0);
  cin >> T;
  while (T--) {
    int N(0), M(0);
    cin >> N >> M;
    int cnt(ceil(M * 1.0 / (N - 1)));
    vector<vector<int>> dsets(cnt, vector<int>(N, -1));
    vector<vector<vector<int>>> tos(cnt, vector<vector<int>>(N));
    for (int x(0), y(0); M--;) {
      cin >> x >> y;
      --x, --y;
      int l(-1), r(cnt - 1);
      while (r - l > 1) {
        int m((l + r) >> 1);
        if (find(dsets[m], x) != find(dsets[m], y))
          r = m;
        else
          l = m;
      }
      int a(find(dsets[r], x)), b(find(dsets[r], y));
      if (a != b) {
        tos[r][x].push_back(y);
        tos[r][y].push_back(x);
        dsets[r][a] = b;
      }
    }
    int u(0);
    for (; u != N && dsets[cnt - 1][u] == -1; ++u);
    assert(u != N);
    int v(dsets[cnt - 1][u]);
    cout << u + 1 << ' ' << v + 1 << endl;
    for (int id(0); id != cnt; ++id) {
      vector<int> pre(N, -1);
      deque<int> que;
      que.push_back(v);
      while (!que.empty()) {
        int c(que.front());
        que.pop_front();
        for (auto p : tos[id][c]) {
          if (pre[p] == -1 && p != v)
            pre[p] = c, que.push_back(p);
        }
      }
      int len(0);
      for (int i(u); ~i; i = pre[i]) ++len;
      cout << len;
      for (int i(u); ~i; i = pre[i]) cout << ' ' << i + 1;
      cout << endl;
    }
  }
  return 0;
}
```

---

## 作者：DegChuZm (赞：2)

### sol
看到图论构造，并且这个 $k$ 是跟 $n-1$ 挂钩的，直接往生成树上带。

你发现你可以对于每一条路径单独开一棵生成树，具体操作如下：

对于每条边我们扫一遍 $[1,k]$ 的所有生成树，找到第一棵 $x_i,y_i$ 不连通的树将此边加进去，如果没有这样的树则 $x_i,y_i$ 为一组解。

然后你就有一个 $mk \log n$ 的做法，在 $n$ 很小的时候过不去。

但是这个 $x_i,y_i$ 的联通是有单调性的，直接二分就可以 $m \log k \log n$ 过掉这个题了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,fa[1000001],head[1000001],x[200001],y[200001],ans[200001],t,tot,cnt;
struct dcz{
	int nex,to;
}a[4000001];
int gf(int x){return x==fa[x]?x:fa[x]=gf(fa[x]);}
bool check(int mid,int i){
	int fx=gf(x[i]+(mid-1)*n),fy=gf(y[i]+(mid-1)*n);
	return fx!=fy;
}
void merge(int x,int y){
	int fx=gf(x),fy=gf(y);
	if(fx!=fy) fa[fy]=fx;
}
void add(int x,int y){
	a[++cnt].nex=head[x];
	a[cnt].to=y;
	head[x]=cnt;
}
bool dfs(int u,int fa,int ed){
	if(u==ed){ans[++tot]=u;return 1;}
	bool ff=0;
	for(int i=head[u];i;i=a[i].nex){
		int v=a[i].to;
		if(v==fa) continue;
		ff|=dfs(v,u,ed);
	}
	if(ff) ans[++tot]=u;
	return ff;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>t;
	while(t--){
//		memset(fa,0,sizeof fa);
		cnt=0;
		cin>>n>>m;k=(m+n-2)/(n-1);
		for(int i=1;i<=m;i++){
			cin>>x[i]>>y[i];
		}
		for(int i=1;i<=k*n;i++){
			fa[i]=i;head[i]=0;
		}
		int u=0,v=0;
		for(int i=1;i<=m;i++){
			int l=1,r=k,ans=0;
			while(l<=r){
				int mid=l+r>>1;
				if(check(mid,i)) ans=mid,r=mid-1;
				else l=mid+1;
			}
//			cout<<t<<" "<<ans<<" "<<x[i]<<" "<<y[i]<<' '<<gf(x[i])<<" "<<gf(y[i])<<"\n";
			merge(x[i]+(ans-1)*n,y[i]+(ans-1)*n);
			add(x[i]+(ans-1)*n,y[i]+(ans-1)*n);
			add(y[i]+(ans-1)*n,x[i]+(ans-1)*n);
			if(ans==k){
				u=x[i],v=y[i];
				break;
			}
		}
		if(!u){cout<<-1<<"\n";continue;}
		cout<<u<<' '<<v<<"\n";
		for(int i=1;i<=k;i++){
			tot=0;
			dfs(u+(i-1)*n,0,v+(i-1)*n);
			cout<<tot<<' ';
			for(int j=tot;j>=1;j--) cout<<ans[j]-(i-1)*n<<' ';
			cout<<"\n";
		}
	}
	return 0;
} 
```

---

## 作者：TH911 (赞：1)

> [题目传送门](https://www.luogu.com.cn/problem/P13356)
>
> [广告](https://www.cnblogs.com/TH911/p/-/P13356)
>
> ~~充分发扬人类智慧。~~

# 题意分析

首先考虑到 $k=\left\lceil\dfrac m{n-1}\right\rceil$，这应当有一些性质，因为 $k$ 并不是一个输入的给定值。

考虑到 $n-1$ 应当有什么用，注意到 $n-1$ 条边会构成一棵 $n$ 个节点的树。

因此启发我们可以考虑将边分组，维护 $k$ 组。理想情况是前 $k-1$ 组均有 $n-1$ 条边，第 $k$ 组有 $m\bmod (n-1)$ 条边。（$k\not\equiv0\pmod{n-1}$）

求 $k$ 条边不相交路径，考虑每一组维护一条路径。

因此可以维护 $k$ 棵**森林** $T_1,T_2,\cdots,T_k$ 用于维护连通性。

具体而言，对于原图上的边 $(u,v)$，找到最小的 $d$ 使得 $T_d$ 上的 $u,v$ **不连通**，就将这条边加入 $T_d$，从而保证了对于任意前缀，若 $(x,y)$ 在最后一棵森林中联通，则在前缀中均联通。建森林时可以通过二分找到对应森林来优化。

最后的点对即 $T_k$ 中的任意联通点对，在 $T_1,T_2,\cdots,T_{k-1}$ 中 DFS 找对应点对即可找到路径。

***

注意这样复杂度是正确的，因为 $\mathcal O(nk)=\mathcal O(m)$，在 $k$ 棵森林中 DFS 是可以接受的。

但是开数组时不能直接开 $N\times K$ 的数组，因为上界 $N=10^5,M=2\times10^5$。可以开一个大公共空间，或者套 `vector`。（但是我套三层 `vector`，一直报 RE……）

维护连通性可以使用并查集。

***

事实上，$k$ 可以扩展到任意值。$k\neq\left\lceil\dfrac m{n-1}\right\rceil$ 时也可以做，做法同理。

# AC 代码

时间复杂度：$\mathcal O(m\alpha(n)\log k+m)$。

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
constexpr const int N=2e5,M=2e5,K=M;
int n,m;
//vector<int>g[N+1];
vector<vector<vector<int> > >tree;
int k;
struct dsu{
	vector<int>f,size;
//	int f[N+1],size[N+1];
	int find(int x){
		if(f[x]==x){
			return x;
		}
		return f[x]=find(f[x]);
	}
	void build(int n){
		f.resize(n+1);
		size.resize(n+1);
		for(int i=1;i<=n;i++){
			f[i]=i;
			size[i]=1;
		}
	}
	void merge(int x,int y){
		x=find(x),y=find(y);
		if(size[x]<size[y]){
			f[x]=y;
			size[y]+=size[x];
		}else{
			f[y]=x;
			size[x]+=size[y];
		}
	}
};
vector<dsu>dsu;
void resize(int n,int k){
	dsu.resize(k+1);
	for(int i=1;i<=k;i++){
		dsu[i].build(n+1);
	}
	tree.resize(k+1);
	for(int id=1;id<=k;id++){ 
		tree[id].resize(n+1);
		for(int i=1;i<=n;i++){
			tree[id][i].resize(0);
		}
	}
}
void addEdge(int u,int v){
	/*for(int i=1;i<=k;i++){
		if(dsu[i].find(u)!=dsu[i].find(v)){
			tree[i][u].push_back(v);
			tree[i][v].push_back(u);
			dsu[i].merge(u,v);
			break;
		}
	}*/
	int l=1,r=k,ans=-1;
	while(l<=r){
		int mid=l+r>>1;
		if(dsu[mid].find(u)!=dsu[mid].find(v)){
			ans=mid;
			r=mid-1;
		}else{
			l=mid+1;
		}
	}
	if(ans!=-1){
		tree[ans][u].push_back(v);
		tree[ans][v].push_back(u);
		dsu[ans].merge(u,v);
	}
}
bool dfs(int x,int fx,int to,int id,vector<int>&ans){
	ans.push_back(x);
	if(x==to){
		return true;
	}
	for(int i:tree[id][x]){
		if(i==fx){
			continue;
		}
		if(dfs(i,x,to,id,ans)){
			return true;
		}
	}
	ans.pop_back();
	return false;
}
namespace debug{
	void dfs1(int x,int fx,int id){
		cerr<<x<<" ";
		for(int i:tree[id][x]){
			if(i==fx){
				continue;
			}
			dfs1(i,x,id);
		}
	}
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	int T;
	cin>>T;
	while(T--){
		cin>>n>>m;
		k=(m+n-2)/(n-1);
		resize(n,k);
		while(m--){
			int u,v;
			cin>>u>>v;
			addEdge(u,v);
		}
		bool flag=true; 
		for(int i=1;flag&&i<=n;i++){
			for(int j:tree[k][i]){
				flag=false;
				cout<<i<<' '<<j<<'\n';
				for(int id=1;id<=k;id++){
					vector<int>ans;
					dfs(i,0,j,id,ans);
					cout<<ans.size()<<' ';
					for(int x:ans){
						cout<<x<<' ';
					}
					cout<<'\n';
				}
				break;
			}
		}
		if(flag){
			cout<<"-1\n";
		}
	}
	
	cout.flush();
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
/*
1
3 1
1 3

1 3
2 1 3
*/
/*
1
4 7
1 2
2 3
3 4
4 1
1 3
2 4
1 4

1 4
4 1 2 3 4
2 1 4
2 1 4
*/
/*
3
3 1
1 3
4 7
1 2
2 3
3 4
4 1
1 3
2 4
1 4
5 5
1 2
2 3
3 4
4 5
3 5

1 3
2 1 3
1 4
4 1 2 3 4
2 1 4
2 1 4
3 5
3 3 4 5
2 3 5
*/
```

---

## 作者：HasNoName (赞：1)

### 思路
考虑建立 $k$ 棵森林，对于所有 $m$ 条边，在这些森林中出现且仅出现一次。当一个点对同时在这 $k$ 棵森林上都联通时则一定是一个合法点对，否则则一定不是。

因为这 $k$ 棵森林的边在原边集中互不相同，所以如果有一个点对在这 $k$ 棵森林中都联通，则一定存在 $k$ 条路径，这是显然的；又因为它们无环，所以如果两个点在原图中有大于等于 $k$ 条路径，所以一棵森林里最多只存在一条路径，且 $k$ 条路径一定会刚好放在 $k$ 棵森林里（因为 $k-1$ 个森林装不下 $k$ 条路径，必有一个有环）。

实现其实非常简单。

假设每次放边放在最靠前的可以容纳的森林里。

则每次增加边后一定还是对任意两点的连通性保持单调。

所以可以二分。

可以用并查集维护联通性。

然后在最后输出的时候也可以在第 $k$ 棵树中寻找相连的点。

存储可以用 `vector` 或用数组开 $k\times n$ 背处理（注意这种方法可能要多开打几倍）。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=500005;
struct T
{
    int ne,to;
}e[2*N];
int he[N],idx,fa[N],d[N],fat[N];
int find(int x)//并查集
{
    if(x==fa[x])return x;
    return fa[x]=find(fa[x]);
}
void dfs(int x,int fa)//处理已知答案为u,v的情况下求出一条路径的长度，在从v往上走找链
{
    d[x]=d[fa]+1;
    fat[x]=fa;
    for(int i=he[x];i;i=e[i].ne)
    {
        int y=e[i].to;
        if(y==fa)continue;
        dfs(y,x);
    }
}
void add(int x,int y)
{
    e[++idx].ne=he[x];
    e[idx].to=y;
    he[x]=idx;
}
void run()
{
    int n,m;
    cin>>n>>m;
    int k=(m+n-2)/(n-1);
    for(int i=1;i<=n*(k+1);i++)fa[i]=i;
    for(int i=1;i<=m;i++)
    {
        int x,y;
        cin>>x>>y;
        int l=0,r=k,mid;
        while(l<r)
        {
            mid=(l+r)>>1;
            if(find(x+mid*n)==find(y+mid*n))l=mid+1;
            else r=mid;
        }
        fa[find(x+l*n)]=find(y+l*n);
        add(x+l*n,y+l*n);
        add(y+l*n,x+l*n);
    }
    bool flag=0;
    for(int i=(k-1)*n+1;i<k*n;i++)
    {
        if(he[i])//找到一条直接相连的边就可以输出了
        {
            int x=i-(k-1)*n,y=e[he[i]].to-(k-1)*n;
            cout<<x<<' '<<y<<'\n';
            for(int j=0;j<k;j++)
            {
                dfs(y+j*n,0);
                cout<<d[x+j*n]<<' ';
                for(int p=x+j*n;p;p=fat[p])
                    cout<<p-j*n<<' ';
                cout<<'\n';
            }
            flag=1;
            break;
        }
    }
    if(!flag)cout<<"-1\n";
    for(int i=1;i<=n*(k+1);i++)he[i]=0;//数组清空
    idx=0;
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin>>T;
    while(T--)
    {
        run();
    }
    return 0;
}
```

---

## 作者：ran_qwq (赞：1)

Attention is all you need.

$k=\lceil\frac m{n-1}\rceil$，意思是把 $m$ 条边分组，每 $n-1$ 条边一组，多出来的再分一组，一共分成 $k$ 组，要求存在点对 $u,v$，只考虑任意一组的边的情况下都连通。

这容易联想到生成树，一棵生成树含有 $n-1$ 个点，且两点有且仅有一条路径。考虑维护 $k$ 张图 $\{T_k\}$，每加入一条边 $(u,v)$ 时随便找一张 $(u,v)$ 未连通的图，在该图中加边 $(u,v)$。一共加了 $m$ 条边，最后必有 $k-1$ 张图是树，一张图是森林。从森林的那张图中任意找两可达点 $(u,v)$，找每张图中 $u\to v$ 的路径即可。

但复杂度瓶颈在于找未连通的图，考虑优化这一过程。不难发现我们可以钦定寻找编号最小的 $(u,v)$ 未连通的图，这样如果第 $i$ 张图 $(u,v)$ 已经连通则前面的图 $(u,v)$ 都是连通的，连通性具有可二分性，直接二分答案即可。

[这是代码。](https://www.luogu.com.cn/paste/ui2nb9ak)

---


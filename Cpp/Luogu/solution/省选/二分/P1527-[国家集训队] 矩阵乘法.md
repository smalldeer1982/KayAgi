# [国家集训队] 矩阵乘法

## 题目描述

给你一个 $n \times n$ 的矩阵，不用算矩阵乘法，但是每次询问一个子矩形的第 $k$ 小数。


## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 100$，$q \leq 10^3$。
- 对于 $40\%$ 的数据，保证 $n \leq 300$，$q \leq 10^4$。
- 对于 $60\%$ 的数据，保证 $n \leq 400$，$q \leq 3 \times 10^4$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 500$，$1 \leq q \leq 6 \times 10^4$，$0 \leq a_{i, j} \leq 10^9$。

## 样例 #1

### 输入

```
2 2
2 1
3 4
1 2 1 2 1
1 1 2 2 3
```

### 输出

```
1
3```

# 题解

## 作者：GGN_2015 (赞：52)

这是一道整体二分的经典题目。

这道题显然可以给每个询问二分答案，统计该询问矩阵中小于等于mid的元素个数。如果大于等于k，说明猜大了，否则说明猜小了。

如果用这种方法的话，对于每个询问都至少要用O(询问矩阵大小\*log值域)的时间复杂度解决，多组询问的话时间不能接受。

发现多个询问的二分答案是可以同时被检验的，我们可以为所有询问同时二分答案，把所有答案小于等于mid的询问放在询问序列的左侧，大于mid的放到询问序列的右侧然后递归处理。

这样为什么会快呢？我们每次可以用把矩阵中小于等于mid的元素染成黑色，剩下的元素保持白色。这样对于每一个询问的检验，就相当于是统计某个子矩阵中黑点的个数。为什么不用二维树状数组维护前缀和呢？

最开始的时候整个矩阵都设为0，然后让所有小于等于mid的位置加1，$O(N^2 \log^2 N)$处理完整个矩阵之后再$O(log^2 N)$去应付每一个询问。被询问的子矩阵中可能有很多重叠的部分，这样保证了在每次询问过程中，矩阵中的每个元素只对运行时间做一次贡献，所以这个算法要比对于每个询问单独二分要快得多。

这样做的时间复杂度为什么是对的呢？我们是在二分值域，考虑二分过程中的每一层对答案的贡献。

1. 对于每一层二分，矩阵中的每个元素最多被加入树状数组一次。

2. 对于每一层二分，每个询问只会被处理一次。

3. 二分值域的过程中最多只会出现$O(\log N)$层。

时间复杂度$O((N^2 + Q)\log^3 N)$，感觉这时间复杂度不开O2过不了啊，想要不开O2 AC可能得大力卡常一发。

发表一下个人见解：感觉CDQ分治和整体二分有异曲同工之妙，是同一种分治思想在不同维度发挥作用的体现。（之所以这么说是因为代码写起来是非常像的。）

还有一点，不要真的去二分值域，不然还得需要离散化，常数更大。把矩阵中的所有元素按照权值排序，二分在答案在排序之后的数组中的位置即可。（因为答案一定是矩阵中存在的值，所以在这些值里面二分就好了。）

给出代码：

```cpp
// luogu-judger-enable-o2
#include <cstdio>
#include <cctype>
#include <cstring>
#include <algorithm>
using namespace std;

inline int geti() {
	int ans = 0; bool flag = 0; char c = getchar();
	while(!isdigit(c)) flag |= c == '-', c = getchar();
	while( isdigit(c)) ans=ans*10+c-'0', c = getchar();
	return flag? -ans: ans;
}

inline void puti(int x) {
	if(x < 0) x=-x, putchar('-');
	if(x > 9) puti(x / 10);
	putchar('0' + x%10);
}

const int maxn = 500 + 10, maxq = 60000 + 5;

struct Numbers {
	int x, y, v; /// (x,y) 位置的值为 v 
	bool operator < (const Numbers& rhs) const {
		return v < rhs.v; /// 用于比较大小 
	}
} Matrix[maxn * maxn]; int mcnt; /// 矩阵中的元素个数

struct BIT {
	int n; /// n * n 的二维树状数组
	int C[maxn][maxn];
	BIT(int N = 0) {n = N; memset(C, 0x00, sizeof(C));} /// 初始化
	inline int lowbit(int x) {return x&(-x);}
	inline void add(int x, int y, int v) { /// 单点修改 
		for(register int i = x; i <= n; i += lowbit(i))
			for(register int j = y; j <= n; j += lowbit(j))
				C[i][j] += v;
	}
	inline int pre(int x, int y) { /// 前缀求和 
		int ans = 0;
		for(register int i = x; i > 0; i -= lowbit(i))
			for(register int j = y; j > 0; j -= lowbit(j))
				ans += C[i][j];
		return ans;
	}
	inline int submat(int x1, int y1, int x2, int y2) { /// 子矩阵和 
		int ans = pre(x2, y2);
		ans -= pre(x1 - 1, y2) + pre(x2, y1 - 1);
		ans += pre(x1 - 1, y1 - 1);
		return ans;
	}
} bit; /// 记得初始化 n

struct Events { /// 记录所有询问 
	int x1, y1, x2, y2, k;
	inline void input() { /// 输入一个询问 
		x1 = geti(); y1 = geti();
		x2 = geti(); y2 = geti();
		k  = geti();
	}
} Querys[maxq];

int bcount(Events mat) { /// 查询某个询问中的黑点个数 
	return bit.submat(mat.x1, mat.y1, mat.x2, mat.y2);
}

int id[maxq], t1[maxq], t2[maxq];
int ans[maxq], cur[maxq];

void Sol(int l, int r, int ql, int qr) {
	if(qr < ql) return; /// 该值域区间没有询问
	if(l == r) {
		for(int i = ql; i <= qr; i ++) ans[id[i]] = Matrix[l].v;
		return; /// 找到解 
	}
	int mid = (l + r)/2;
	for(int i = l; i <= mid; i ++) /// 把要统计到答案中的数值染黑 
		bit.add(Matrix[i].x, Matrix[i].y, 1);
	int cnt1 = 0, cnt2 = 0;
	for(int i = ql; i <= qr; i ++) {
		int u = id[i]; /// 当前要处理的询问
		int s = cur[u] + bcount(Querys[u]); /// 考虑当前区间中的黑点个数
		if(s >= Querys[u].k) t1[++ cnt1] = u;
		else t2[++ cnt2] = u, cur[u] = s; 
	}
	int qcnt = ql - 1;
	for(int i = 1; i <= cnt1; i ++) id[++ qcnt] = t1[i]; /// 左右分组 
	for(int i = 1; i <= cnt2; i ++) id[++ qcnt] = t2[i];
	for(int i = l; i <= mid; i ++) /// 谁污染谁治理 
		bit.add(Matrix[i].x, Matrix[i].y, -1);
	Sol(l, mid, ql, ql + cnt1 - 1);
	Sol(mid+1, r, ql + cnt1, qr);
}

int main() {
	int N = geti(), Q = geti(); bit.n = N;/// 输入矩阵大小和询问组数
	for(int i = 1; i <= N; i ++)
		for(int j = 1; j <= N; j ++)
			Matrix[++ mcnt] = (Numbers){i, j, geti()};
	sort(Matrix + 1, Matrix + mcnt + 1); /// 按元素大小从小到大排序
	for(int i = 1; i <= Q; i ++) Querys[i].input();
	for(int i = 1; i <= Q; i ++) id[i] = i;
	Sol(1, mcnt, 1, Q);
	for(int i = 1; i <= Q; i ++) puti(ans[i]), putchar('\n');
	return 0;
}
```

---

## 作者：蒟蒻CGZ (赞：28)

## [P1527 [国家集训队]矩阵乘法](https://www.luogu.com.cn/problem/P1527)
刚学整体二分，作为自己手打 $AC$ 的第一题，写篇题解~~以为纪念~~

接下来先大致地聊一聊整体二分。

### 整体二分扯淡

有一些题目是需要二分来将 $O(N)$ 的时间复杂度降到 $O(log_2 N)$ 的，但是如果题目有多次询问且每次询问我们对其都直接二分，时间复杂度就变得让我们无法接受，甚至上升一个数量级，导致 `TLE`。

这时候我们就会用到整体二分。

整体二分是一个离线算法，它的主体思路就是把多个询问或者修改操作一起解决。因此，这个算法总是在最后才把所有的答案一起进行作答。
### 思路详解
使用整体二分解决的题目，首先要将所有的操作，包括插入、修改、删除和询问按照时间顺序打一个时间戳，存放在操作序列中，不妨称这个序列为 $q$ 。

一般还需要实现一个重要的函数，来进行二分解决所有的操作。个人习惯上称其为 `solve(l, r, L, R)`。意思就是操作序列上第 $[l, r]$ 个询问的答案已经确定在 $[L, R]$ 的值域范围内。

二分嘛，肯定是要取一个 $mid = \lfloor\frac{L + R}{2}\rfloor$，判定每一个答案与 $mid$ 的关系。

对于每一次 `solve(l, r, L, R)`， 枚举数值在 $[L, R]$ 之间的数，并将该数插入二维树状数组中，方便之后统计某个特定的矩阵中满足大小限定的数。

接着枚举询问操作 $(x_1, y_1, x_2, y_2, k)$，记左上角为 $(x_1, y_1)$ ，右下角为 $(x_2, y_2)$ 的子矩阵中，数值在 $[L, mid]$ 的数的个数为 $cnt$。显然，如果 $cnt_i \geq k_i$，那么 $(x_1, y_1, x_2, y_2, k)$ 的答案在 $[L, mid]$ 中；否则$(x_1, y_1, x_2, y_2, k - cnt)$ 的答案就在 $[mid + 1, R]$ 中。

至此，我们得到了两个规模减半的子问题，可以进行递归处理，当问题的规模缩小为一个数，即 $l = r$ 时，我们就得到了一些操作的答案。

顺带着提一下，计算二维前缀和的公式大概长这样：
$$
ans=S(a,b)-S(a,v-1)-S(u-1,b)+S(u-1,v-1)
$$

接下来是代码，带有~~简单的~~注释

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int N = 1010, M = 1e6 + 10;
struct Node {
	int x, y, u, v, k, id;
    //(x,y)(u,v)矩阵左上，右下角
} q[M + N], q1[N + M], q2[N + M];
int tot = 0, n, m, tree[N][N], ans[M];

//树状数组
inline void add(int x, int y, int v) { //修改
	for (int i = x; i <= n; i += i & -i) 
		for (int j = y; j <= n; j += j & -j)
			tree[i][j] += v;
	return ;
}

inline int query(int x, int y) { //查询二维前缀和
	int res = 0;
	for (int i = x; i; i -= i & -i) 
		for (int j = y; j; j -= j & -j)
			res += tree[i][j];
	return res;
}

inline void solve(int ql, int qr, int L, int R) {
	if (ql > qr) 
		return ;
	if (L == R) { //规模缩小为一个数
		for (int i = ql; i <= qr; ++ i) //记录答案 
			if (q[i].id != 0) ans[q[i].id] = L;
		return ;
	}
	
	int len1, len2, mid = (L + R) >> 1;
	len1 = len2 = 0;
	for (int i = ql; i <= qr; ++ i) {
		if(q[i].id == 0) {
			if (q[i].k <= mid) {
				add(q[i].x, q[i].y, 1);
				q1[++ len1] = q[i];
			} else {
				q2[++ len2] = q[i];
			}
		} else {
			int tmp = query(q[i].u, q[i].v) - query(q[i].x - 1, q[i].v) - query(q[i].u, q[i].y - 1) + query(q[i].x - 1, q[i].y - 1); //提取子矩阵
			if (tmp >= q[i].k) {
				q1[++ len1] = q[i];
			} else {
				q[i].k -= tmp;
				q2[++ len2] = q[i];
			}
		}
	}
	
	for (int i = 1; i <= len1; ++ i) q[ql + i - 1] = q1[i];
	for (int i = 1; i <= len2; ++ i) q[ql + len1 + i - 1] = q2[i];
	
	for (int i = ql; i <= ql + len1 - 1; ++ i)
		if (q[i].id == 0 && q[i].k <= mid) 
			add(q[i].x, q[i].y, -1);
	
	solve(ql, ql + len1 - 1, L, mid);
	solve(ql + len1, qr, mid + 1, R);
}

inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while(!isdigit(ch)) { if(ch == '-') f = -f; ch = getchar(); }
	while(isdigit(ch)) { x = (x << 1) + (x << 3) + (ch ^ 48); ch = getchar(); }
	return x * f;
}

signed main() {
	n = read(); m = read();
	for (int x, i = 1; i <= n; ++ i)
		for (int j = 1; j <= n; ++ j) {
			x = read();
			q[++ tot] = (Node) {i, j, 0, 0, x, 0};
		}
	for (int x, y, a, b, k, i = 1; i <= m; ++ i) {
		x = read(); y = read(); 
		a = read(); b = read();
		k = read();
		q[++ tot] = (Node) {x, y, a, b, k, i};
	}
	solve(1, tot, INT_MIN, INT_MAX);
	for (int i = 1; i <= m; ++ i)
		printf("%d\n", ans[i]);
	return 0;
} 
```

![](https://cdn.luogu.com.cn/upload/image_hosting/jrd168bx.png)

$END.$

---

## 作者：C3H5ClO (赞：17)

发一个$\Theta(n^2\log^2n)$做法。（假设$m$与$n^2$同阶）

首先，这道题空间没法搞树状数组套线段树之类的，只能整体二分。

在整体二分中的某一次分治时，假设值域为$[l,r]$，值域中点为$mid$，则要统计值域在此范围的询问的子矩形中满足$x\in[l,r]$的$x$的个数。由于$cnt(x1,y1,x2,y2)=cnt(0,0,x2,y2)-cnt(0,0,x2,y1-1)-cnt(0,0,x1-1,y2)+cnt(0,0,x1-1,y1-1)$，将一个询问拆成四个询问，这是一个二维偏序问题，并不需要二维树状数组。可以将所有$x\in[l,r]$的$x$看成修改，和询问一起离线下来，按横坐标排序，纵坐标用普通的树状数组解决。这样做，假设这次分治值域区间长度为$l$，询问个数为$q$，则本次分治时间复杂度为$\Theta((l+q)(\log l+\log q))$，算法整体复杂度为$\Theta((n^2+m)(\log n^2+\log m)\log n^2)=\Theta(n^2\log^2n)$。

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=505,M=60005;
int n,q,a[N][N],ans[M],x,y,xx,yy,z;
int aa[N*N],lenaa,dx[M],o2p[M],o2p1[M],o2p2[M];
struct node{int v,x,y;}o[N*N];
bool operator <(node a,node b){return a.v<b.v;}
struct node2{int x1,y1,x2,y2,k,id;}o2[M];
struct node3{int x,y,id;}o3[N*N*2];
bool operator <(node3 a,node3 b){return a.x!=b.x?a.x<b.x:!a.id&&b.id;}
int sz[N*N];
void ddxg(int x,int y){for(;x<=lenaa;x+=x&-x)sz[x]+=y;}
int qjcx(int x){int y=0; for(;x;x-=x&-x)y+=sz[x]; return y;}
void getans(int l,int r,int o2l,int o2r)
{
    if(l==r){for(int i=o2l;i<=o2r;i++)ans[o2[o2p[i]].id]=aa[o[l].v]; return;}
    int mid=l+r>>1,len1=0,len2=0,len3=0;
    for(int i=l;i<=mid;i++)o3[++len3]={o[i].x,o[i].y,0};
    for(int i=o2l;i<=o2r;i++)
    {
        x=o2[o2p[i]].x1; y=o2[o2p[i]].y1; xx=o2[o2p[i]].x2; yy=o2[o2p[i]].y2;
        o3[++len3]={xx,yy,i}; o3[++len3]={x-1,y-1,i};
        o3[++len3]={xx,y-1,-i}; o3[++len3]={x-1,yy,-i};
    }
    sort(o3+1,o3+len3+1);
    for(int i=1;i<=len3;i++)
        if(!o3[i].id)ddxg(o3[i].y,1);
        else if(o3[i].id>0)dx[o3[i].id]+=qjcx(o3[i].y);
        else dx[-o3[i].id]-=qjcx(o3[i].y);
    for(int i=o2l;i<=o2r;i++)
        if(o2[o2p[i]].k<=dx[i])o2p1[++len1]=o2p[i];
        else o2[o2p[i]].k-=dx[i],o2p2[++len2]=o2p[i];
    for(int i=1;i<=len1;i++)o2p[o2l+i-1]=o2p1[i];
    for(int i=1;i<=len2;i++)o2p[o2l+len1+i-1]=o2p2[i];
    fill(dx+o2l,dx+o2r+1,0);
    for(int i=l;i<=mid;i++)ddxg(o[i].y,-1);
    if(len1)getans(l,mid,o2l,o2l+len1-1);
    if(len2)getans(mid+1,r,o2l+len1,o2r);
}
int main()
{
    scanf("%d%d",&n,&q);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            scanf("%d",a[i]+j),aa[++lenaa]=a[i][j];
    sort(aa+1,aa+lenaa+1);
    lenaa=unique(aa+1,aa+lenaa+1)-aa-1;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            a[i][j]=lower_bound(aa+1,aa+lenaa+1,a[i][j])-aa,o[i*n-n+j]={a[i][j],i,j};
    sort(o+1,o+n*n+1);
    for(int i=1;i<=q;i++)scanf("%d%d%d%d%d",&x,&y,&xx,&yy,&z),o2[i]={x,y,xx,yy,z,i},o2p[i]=i;
    getans(1,n*n,1,q);
    for(int i=1;i<=q;i++)printf("%d\n",ans[i]);
}
```

---

## 作者：Rubyonly (赞：16)

整体二分的经典例题

对于单个询问，我们可以二分值域求出答案，但是复杂度是 $\Theta (n^2m\log n)$ 的

不妨考虑将这若干个询问一起二分，统计在 $[l,mid]$ 的值有多少个，然后与询问的排名 $k$ 进行比较，如果 $\geq k$ 则递归到左区间，否则将 $k$ 修改并递归到右区间

有点卡常

* 注意不要直接二分值域，可以离散化后二分

* 统计矩阵中 $[l,mid]$ 的数有多少个时，可以用 $vector$ 记录一下值为 $val$ 的坐标都有哪些，然后直接扫就行了

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int maxn = 3e5 + 50, INF = 0x3f3f3f3f;

inline int read () {
	register int x = 0, w = 1;
	register char ch = getchar ();
	for (; ch < '0' || ch > '9'; ch = getchar ()) if (ch == '-') w = -1;
	for (; ch >= '0' && ch <= '9'; ch = getchar ()) x = x * 10 + ch - '0';
	return x * w;
}

int n, q, len, c[maxn], a[505][505], tree[505][505], ans[maxn], mp[maxn];
vector <int> res;
vector <pair <int, int> > pos[maxn];

struct Node {
	int x1, y1, x2, y2, k;
} b[maxn];

inline void Insert (register int x, register int y) {
	for (register int i = x; i <= n; i += i & -i) 
		for (register int j = y; j <= n; j += j & -j) 
			tree[i][j] ++;
}

inline void Delete (register int x, register int y) {
	for (register int i = x; i <= n; i += i & -i) 
		for (register int j = y; j <= n; j += j & -j) 
			tree[i][j] --;
}

inline int Query (register int x, register int y, register int ans = 0) {
	for (register int i = x; i; i -= i & -i) 
		for (register int j = y; j; j -= j & -j)
			ans += tree[i][j];
	return ans;
}

inline void Binary (register int l, register int r, vector <int> vec) {	
	if (! vec.size ()) return;
	if (l == r) {
		for (register int i = 0; i < vec.size (); i ++) ans[vec[i]] = mp[l];
		return;
	}
	register int mid = (l + r) >> 1;
	vector <int> vec0, vec1;
	for (register int x = l; x <= mid; x ++) 
		for (register int i = 0; i < pos[x].size (); i ++) 
			Insert (pos[x][i].first, pos[x][i].second);			
	for (register int i = 0; i < vec.size (); i ++) {
		register int id = vec[i], x1 = b[id].x1, y1 = b[id].y1, x2 = b[id].x2, y2 = b[id].y2;
		register int sum = Query (x2, y2) - Query (x1 - 1, y2) - Query (x2, y1 - 1) + Query (x1 - 1, y1 - 1);
		if (sum >= b[id].k) vec0.push_back (id);
		else b[id].k -= sum, vec1.push_back (id);
	}
	for (register int x = l; x <= mid; x ++) 
		for (register int i = 0; i < pos[x].size (); i ++) 
			Delete (pos[x][i].first, pos[x][i].second);			
	Binary (l, mid, vec0), Binary (mid + 1, r, vec1);
}

int main () {
	n = read(), q = read();
	for (register int i = 1; i <= n; i ++) 
		for (register int j = 1; j <= n; j ++) 
			a[i][j] = c[++ len] = read();
	sort (c + 1, c + len + 1), len = unique (c + 1, c + len + 1) - c - 1;
	for (register int i = 1; i <= n; i ++) {
		for (register int j = 1; j <= n; j ++) {
			register int res = lower_bound (c + 1, c + len + 1, a[i][j]) - c;
			mp[res] = a[i][j], a[i][j] = res, pos[res].push_back (make_pair (i, j));
		}
	}
	for (register int i = 1; i <= q; i ++) 
		b[i].x1 = read(), b[i].y1 = read(), b[i].x2 = read(), b[i].y2 = read(), b[i].k = read(), res.push_back (i);
	Binary (1, len, res);
	for (register int i = 1; i <= q; i ++) printf ("%d\n", ans[i]);
	return 0;
}
```

---

## 作者：NATURAL6 (赞：15)

### 2022.10.11 添加了必要的卡常技巧，修改了部分笔误。

## 题意

给你一个 $n×n$ 的矩阵，每次询问一个子矩形的第 $k$ 小数。

## 思路

这是一道二维莫队的一眼题，先离散化，用莫队维护出矩形中出现的数，再值域分块即可。

这里主要讲一下二维莫队。

二维莫队，顾名思义，是将莫队放在二维上跑，同时有四个指针，表示上下左右。

单次移动指针一次加入或删除一整排，故复杂度略高。

关于最优块长与复杂度，设块长为 $B$, 上指针共移动 $\dfrac{n}{B}$ 块，每块左右指针共 $(\dfrac{n}{B})^2$ 次，

故上指针共 $qB$ 次，取左指针移动 $\dfrac{n^4}{B^3}$ 次，让 $\dfrac{n^4}{B^3}=qB$, 得 $B=nq^{-\tfrac{1}{4}}$, 时间复杂度为 $O(n^2q^\tfrac{3}{4})$, 在本题要开到这个块长的 $\dfrac{1}{3}$ 左右，稍加卡常即可。

至于值域分块，就是对于数的值域进行分块，记录出现在该值域和值域块的数的个数。

于是查询时就可以暴力跳块，再在块内找即可，单次时间复杂度 $O(\sqrt{n})$。

## 优化

仅做到上面的部分只能得到 [60pts,](https://www.luogu.com.cn/record/89424161) 剩下还需要加上一个莫队常用的卡常技巧——奇偶排序。

就是代码中的这一行：

```cpp
return c[x.u]==c[y.u]?(c[x.l]==c[y.l]?(c[x.r]==c[y.r]?((c[x.r]&1)?x.d<y.d:x.d>y.d):((c[x.l]&1)?x.r<y.r:x.r>y.r)):((c[x.u]&1)?x.l<y.l:x.l>y.l)):x.u<y.u;
```
模拟一下莫队过程可以发现，每次一端指针跑到边缘后又会跑回来，再开始往外跑，这里浪费了一遍移动指针的过程。

那么怎么利用上这一段呢？

我们可以将指针跑回来的再跑出去的这一段询问逆序排序，那么再指针往回跑时就可以顺带处理这部分询问了。

而这一部分恰好是另一端指针处于偶数块的时候，故按奇偶分顺逆序即可。

加上这个优化就可以过了，[通过记录](https://www.luogu.com.cn/record/89324370)。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace io {
	const int __SIZE = (1 << 21) + 1;
	char ibuf[__SIZE], *iS, *iT, obuf[__SIZE], *oS = obuf, *oT = oS + __SIZE - 1, __c, qu[55]; int __f, qr, _eof;
	#define Gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)
	inline void flush () { fwrite (obuf, 1, oS - obuf, stdout), oS = obuf; }
	inline void gc (char &x) { x = Gc(); }
	inline void pc (char x) { *oS ++ = x; if (oS == oT) flush (); }
	inline void pstr (const char *s) { int __len = strlen(s); for (__f = 0; __f < __len; ++__f) pc (s[__f]); }
	inline void gstr (char *s) { for(__c = Gc(); __c < 32 || __c > 126 || __c == ' ';)  __c = Gc();
		for(; __c > 31 && __c < 127 && __c != ' ' && __c != '\n' && __c != '\r'; ++s, __c = Gc()) *s = __c; *s = 0; }
	template <class I> inline bool gi (I &x) { _eof = 0;
		for (__f = 1, __c = Gc(); (__c < '0' || __c > '9') && !_eof; __c = Gc()) { if (__c == '-') __f = -1; _eof |= __c == EOF; }
		for (x = 0; __c <= '9' && __c >= '0' && !_eof; __c = Gc()) x = x * 10 + (__c & 15), _eof |= __c == EOF; x *= __f; return !_eof; }
	template <class I> inline void print (I x) { if (!x) pc ('0'); if (x < 0) pc ('-'), x = -x;
		while (x) qu[++ qr] = x % 10 + '0',  x /= 10; while (qr) pc (qu[qr --]); }
	struct Flusher_ {~Flusher_(){flush();}}io_flusher_;
} using io::pc; using io::gc; using io::pstr; using io::gstr; using io::gi; using io::print;
int n,m,b[250001],ans[60001],p[501][501];
int cl,c[501],s[250001],sum[501],ccl,cc[250001];
struct xw
{
	int u,l,d,r,h,id;
}q[60001];
inline bool cmp(xw x,xw y){return c[x.u]==c[y.u]?(c[x.l]==c[y.l]?(c[x.r]==c[y.r]?((c[x.r]&1)?x.d<y.d:x.d>y.d):((c[x.l]&1)?x.r<y.r:x.r>y.r)):((c[x.u]&1)?x.l<y.l:x.l>y.l)):x.u<y.u;}
inline int Q(register int x)
{
	int pos=1,cnt=0;
	while(cnt+sum[pos]<x&&pos<=cc[n*n])cnt+=sum[pos],++pos;
	pos=(pos-1)*ccl+1;
	while(cnt+s[pos]<x&&pos<=n*n)cnt+=s[pos],++pos;
	return b[pos];
}
int main()
{
	register int uu=1,dd=1,ll=1,rr=1;
	gi(n);
	gi(m);
	cl=n/pow(m,0.25)/3+1;
	ccl=n+1;
	for(register int i=1;i<=n;++i)c[i]=(i-1)/cl+1;
	for(register int i=1;i<=n*n;++i)cc[i]=(i-1)/ccl+1;
	for(register int i=1;i<=n;++i)
	{
		for(register int j=1;j<=n;++j)
		{
			gi(p[i][j]);
			b[++b[0]]=p[i][j];
		}
	}
	sort(b+1,b+1+b[0]);
	b[0]=unique(b+1,b+1+b[0])-b-1;
	for(register int i=1;i<=n;++i)
	{
		for(register int j=1;j<=n;++j)
		{
			p[i][j]=lower_bound(b+1,b+1+b[0],p[i][j])-b;
		}
	}
	for(register int i=1;i<=m;++i)gi(q[i].u),gi(q[i].l),gi(q[i].d),gi(q[i].r),gi(q[i].h),q[i].id=i;
	sort(q+1,q+1+m,cmp);
	++s[p[1][1]];++sum[cc[p[1][1]]];
	for(register int i=1;i<=m;++i)
	{
		while(rr<q[i].r)
		{
			++rr;
			for(register int i=uu;i<=dd;++i)++s[p[i][rr]],++sum[cc[p[i][rr]]];
		}
		while(ll>q[i].l)
		{
			--ll;
			for(register int i=uu;i<=dd;++i)++s[p[i][ll]],++sum[cc[p[i][ll]]];
		}
		while(dd<q[i].d)
		{
			++dd;
			for(register int i=ll;i<=rr;++i)++s[p[dd][i]],++sum[cc[p[dd][i]]];
		}
		while(uu>q[i].u)
		{
			--uu;
			for(register int i=ll;i<=rr;++i)++s[p[uu][i]],++sum[cc[p[uu][i]]];
		}
		while(rr>q[i].r)
		{
			for(register int i=uu;i<=dd;++i)--s[p[i][rr]],--sum[cc[p[i][rr]]];
			--rr;
		}
		while(ll<q[i].l)
		{
			for(register int i=uu;i<=dd;++i)--s[p[i][ll]],--sum[cc[p[i][ll]]];
			++ll;
		}
		while(dd>q[i].d)
		{
			for(register int i=ll;i<=rr;++i)--s[p[dd][i]],--sum[cc[p[dd][i]]];
			--dd; 
		}
		while(uu<q[i].u)
		{
			for(register int i=ll;i<=rr;++i)--s[p[uu][i]],--sum[cc[p[uu][i]]];
			++uu;
		}
		ans[q[i].id]=Q(q[i].h);
	}
	for(register int i=1;i<=m;++i)printf("%d\n",ans[i]);
	return 0;
}
```


---

## 作者：eee_hoho (赞：12)

一道练习整体二分的比较好的题

这道题把序列查询区间第$k$大搬到了矩阵上，但是仍然满足二分性质，所以我们还是可以整体二分

而我们沿用序列上的做法，把点和询问都离线下来，揉在一起整体二分

唯一不一样的地方就是需要二维树状数组，这个很好理解吧qwq

复杂度$O(Qlog^3n)$

**Code**
``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
const int N = 500;
const int M = 6e4;
const int N2 = 250000;
const int INF = 1e9;
using namespace std;
struct node
{
    int x1,y1,x2,y2,k,id;
}q[M + N2 + 5],q1[M + N2 + 5],q2[M + N2 + 5];
int n,m,a[N + 5][N + 5],ans[M + 5],c[N + 5][N + 5],cnt;
int lowbit(int x)
{
    return x & (-x);
}
void add(int x,int y,int s)
{
    for (int i = x;i <= n;i += lowbit(i))
        for (int j = y;j <= n;j += lowbit(j))
            c[i][j] += s;
}
int query(int x,int y)
{
    if (!x || !y)
        return 0;
    int ans = 0;
    for (int i = x;i;i -= lowbit(i))
        for (int j = y;j;j -= lowbit(j))
            ans += c[i][j];
    return ans;
}
int query_sum(int x1,int y1,int x2,int y2)
{
    return query(x2,y2) - query(x1 - 1,y2) - query(x2,y1 - 1) + query(x1 - 1,y1 - 1);
}
void solve(int l,int r,int L,int R)
{
    if (L > R)
        return;
    if (l == r)
    {
        for (int i = L;i <= R;i++)
            if (q[i].id)
                ans[q[i].id] = l;
        return;
    }
    int mid = l + r >> 1,cnt1 = 0,cnt2 = 0;
    for (int i = L;i <= R;i++)
        if (q[i].id == 0)
        {
            if (q[i].k <= mid)
            {
                add(q[i].x1,q[i].y1,1);
                q1[++cnt1] = q[i];
            }
            else
                q2[++cnt2] = q[i];
        }
        else
        {
            int x = query_sum(q[i].x1,q[i].y1,q[i].x2,q[i].y2);
            if (x >= q[i].k)
                q1[++cnt1] = q[i];
            else
            {
                q[i].k -= x;
                q2[++cnt2] = q[i];
            }
        }
    for (int i = 1;i <= cnt1;i++)
        if (q1[i].id == 0)
            add(q1[i].x1,q1[i].y1,-1);
    for (int i = L;i <= L + cnt1 - 1;i++)
        q[i] = q1[i - L + 1];
    for (int i = L + cnt1;i <= R;i++)
        q[i] = q2[i - L - cnt1 + 1];
    solve(l,mid,L,L + cnt1 - 1);
    solve(mid + 1,r,L + cnt1,R);
}
int main()
{
    scanf("%d%d",&n,&m);
    for (int i = 1;i <= n;i++)
        for (int j = 1;j <= n;j++)
        {
            scanf("%d",&a[i][j]);
            q[++cnt] = (node){i,j,0,0,a[i][j],0};
        }
    for (int i = 1;i <= m;i++)
    {
        cnt++;
        scanf("%d%d%d%d%d",&q[cnt].x1,&q[cnt].y1,&q[cnt].x2,&q[cnt].y2,&q[cnt].k);
        q[cnt].id = i;
    }
    solve(0,INF,1,cnt);
    for (int i = 1;i <= m;i++)
        printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：genshy (赞：10)



整体二分的经典例题。

对于整体二分，我个人的理解是二分答案套分治。

具体来说就是对答案进行二分，然后对于询问进行类似于权值线段树求区间第 $k$ 大的分治做法。

首先，我们暴力做法就是对每个询问都跑一边二分答案，这样的复杂度是 O($nm log n$)

这显然我们是不能够接受的。

我们发现我们二分答案处理每个询问时，会重复计算好多遍加权的操作。

我们就考虑把询问放在一起处理，每个加权操作只重复计算一次。

这样就能省去不少时间。具体怎么实现呢？

假设，我们二分出来的答案为 $mid$  那么此时询问的答案分成了两种情况

一种是答案小于 $mid$ 的，我们可以继续递归下去，

另一种是大于 $mid$ 的询问，我们就要减去左边的贡献，在 $mid - R$ 这个范围递归

下去（可以参考权值线段树求解区间第 $k$ 大的方法）。

我们把答案在 $mid$ 左边的询问放在前面，答案在 $mid$ 右边的询问放在后面。

这样我们前一部分就可以递归 $L-mid$ 这一段区间，后一部分就可以递归 $mid - R$

这个区间。（也就是对询问分治）

对于这个题，我们怎么判断这个询问的答案是大于或小于 $mid$ 的呢？

我们可以利用二维树状数组，对于 $L-mid$ 的这一部分的加权操作加上，然后对于每

个询问就相当于二维数点。

这块区间的点的数量大于 $q[i].c$ 我们就说明此时答案小于 $mid$，反之大于 $mid$.

一个需要注意的点是，在把询问分成前后两部分的时候，一定要先减去 $L-mid$ 的贡

献，在赋给中间的那个过渡数组（我在这里卡了近一个小时）

还有就是要将记录前后两部分询问数量的变量例如 $cntl$, $cntr$ 要设为局部变量，

不然他就会一直加下去导致你答案出错

具体代码长这样 (带有注释的良心代码)

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;
const int N = 300000;
int n,m,tot;
int a[510][510],tr[510][510],ans[N],b[N];
struct node{ int x,y;};
struct kkk
{
	int x1,x2,id;
	int y1,y2,c;
}q[N],tong[N],stal[N],star[N];
vector< node > sta[N];
inline int read()
{
    int s = 0,w = 1; char ch = getchar();
    while(ch < '0' || ch > '9'){if(ch == '-') w = -1; ch = getchar();}
    while(ch >= '0' && ch <= '9'){s = s * 10 + ch - '0'; ch = getchar();}
    return s * w;
}
int lowbit(int x){return x & -x;}
void chenge(int x,int y,int val)//二维树状数组
{
    for(int i = x; i <= n; i += lowbit(i))
    {
        for(int j = y; j <= n; j += lowbit(j))
        {
            tr[i][j] += val;
        }
    }
}
int ask(int x,int y)
{
    int res = 0;
    for(int i = x; i; i -= lowbit(i))
    {
        for(int j = y; j; j -= lowbit(j))
        {
            res += tr[i][j];
        }
    }
    return res;
}
int get_ans(int x1,int y1,int x2,int y2)//二维数点
{
    return (ask(x2,y2) + ask(x1-1,y1-1) - ask(x1-1,y2) - ask(x2,y1-1));
}
void work(int l,int r,int L,int R)//l-r 是我们的答案的区间， L-R 是我们的询问区间
{
    int cntl = 0, cntr = 0;//这两个变量一定要设为局部变量
    if(l == r)//l==r 说明此时我们 L-R 这一部分询问的答案就是 l
    {
        for(int i = L; i <= R; i++)
        {
            ans[q[i].id] = l;
        }
        return;
    }
    int mid = (l+r)>>1;//二分答案
    for(int i = l; i <= mid; i++)
    {
        for(int j = 0; j < (int)sta[i].size(); j++)
        {
            int x = sta[i][j].x;
            int y = sta[i][j].y;
            chenge(x,y,1);//加权操作
        }
    }
    for(int i = L; i <= R; i++)
    {
        int tmp = get_ans(q[i].x1,q[i].y1,q[i].x2,q[i].y2);//二维数点
        if(tmp >= q[i].c)//如果这个区域的点的数量大于 q[i].c 说明我们这个询问的答案小于 mid 要把他放在前一部分
        {
            stal[++cntl] = q[i];
        }
        else 
		{
        	q[i].c -= tmp;//后一部分先减去 l-mid 这个答案的贡献，在去 mid - r 这个区间二分答案
        	star[++cntr] = q[i];//把他分到后面的那一部分
        }
    }
    for(int i = l; i <= mid; i++)//把加权操作还原
    {
        for(int j = 0; j < sta[i].size(); j++)
        {
            int x = sta[i][j].x;
            int y = sta[i][j].y;
            chenge(x,y,-1);
        }
    }
    for(int i = L; i <= L + cntl - 1 ; i++) q[i] = stal[i - L + 1];//重新给询问排一下序把答案小于 mid 的放前面，反之放后面
    for(int i = L + cntl; i <= R; i++) q[i] = star[i - L - cntl + 1];
    work(l,mid,L,L + cntl - 1); work(mid + 1,r,L + cntl,R);//继续递归下去
}
int main()
{
    n = read(); m = read();
    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j <= n; j++)
        {
            a[i][j] = read();
            b[++tot] = a[i][j];
        }
    }
    sort(b + 1,b + tot + 1);//离散化
    int t = unique(b + 1,b + tot + 1) - b - 1;
    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j <= n; j++)
        {
            a[i][j] = lower_bound(b+1,b+t+1,a[i][j]) - b;
            sta[a[i][j]].push_back((node){i,j});//记录每个权值出现的位置
        }
    }
    for(int i = 1; i <= m; i++)
    {
        q[i].x1 = read(); q[i].y1 = read();
        q[i].x2 = read(); q[i].y2 = read();
        q[i].c = read();  q[i].id = i;
    }
    work(1,t,1,m);//整体二分
    for(int i = 1; i <= m; i++)
    {
        printf("%d\n",b[ans[i]]);
    }
    return 0;
}

```






---

## 作者：Moeebius (赞：5)

> 你说得对，但是可以在线的题为什么要离线做呢？
>
> 鸣谢 @[Querainy](https://www.luogu.com.cn/user/152213)


考虑直接将经典的整体二分进行在线化处理：具体地，外层维护一棵权值线段树，结点 $[l, r]$ 内维护所有落在这一区间内的数；询问时直接在上面二分即可。

下面看看内层节点需要支持什么。容易发现只需要二维数点。如果暴力搞一棵主席树，空间复杂度达到 $O(n \log^2 n)$，无法通过。

---

权值线段树的一只 $\log$ 已经无法优化了，考虑把主席树的 $\log$ 飞了！

发现我们只要 **二维数点**。那么我们有一个更加优秀的结构：Wavelet Tree。

Wavelet Tree 是一种非常好写的数据结构，可以理解为 $\text{linear space}$ 的一棵归并树。

考虑归并树状物在做什么。对于每一层，有用的信息其实只有 $O(n)$ 个 bit——每个数是来自于左子树还是右子树。那么我们可以将 $w$ 个 bit 压到一起去，在 WRM（$w\ge\log n$）下可以认为做到了线性空间。

具体而言，我们从高位往低位扫一遍，每次按当前位 0/1 将序列划分成左右两段进行建树：

![wvt](https://cdn.luogu.com.cn/upload/image_hosting/g38daql1.png)

（从[原论文](https://ioinformatics.org/journal/v10_2016_19_37.pdf)里截的图，此处 `rank` 是数出现前缀次数，`quantile` 是区间求解 kth，与本题无关）


每次询问的时候，相当于数 $[l, r]$ 中 $[x, y]$ 内的数出现次数；考察 Wavelet Tree 在 $[l, r]$ 内数的 **值域** 范围 $[p, q]$。

- 如果 $[p, q]$ 被 $[x, y]$ 完全包含，那么返回 $r - l + 1$。
- 如果 $[p, q]$ 与 $[x, y]$ 无交，返回 $0$。
- 否则，递归到左右子树。注意到左右子树中 $[l, r]$ 的下标是好维护的：当前层 $x$ 在左子树中对应下标是 $\text{count}_0(1, x)$，在右子树中则是 $\text{count}_1(1, x) + \text{count}_0(1, n)$，其中 $\text{count}_0(l, r)$ 表示下标 $[l, r]$ 中数在当前位中 $0$ 出现次数，$\text{count}_1$ 同理。

可以证明上述过程的时间复杂度是 $O(\log n)$ 的，证明与线段树类似。

实现的时候一般不会显式把树建出来；维护当前层的 0-1 串即可。

另外为了处理横坐标重复的问题，可以暴力拆成多个横坐标，复杂度不变。

离散化完直接做就好了，时间 $O(q \log^2 n)$，空间 $O(n \log n)$。

---

然后提交完发现 MTLE 了。原因是：压位数据结构在 $n \le w$ 时表现极差。这部分暴力做就好了。然后外层线段树要写 $2$ 倍空间常数的，否则会差 $20$ MiB 左右。

如果你愿意的话也可以丢掉外层线段树的高 $\log \log n$ 层。也许可以卡点常（？）

[Code](https://www.luogu.com.cn/paste/8kqmhdbz)，无需刻意卡常即可通过。

---

## 作者：arfa (赞：5)

### 整体二分

关于整体二分的资料比较少,这里简单提一下思路。在此时,如果 $A$ 个修改在此个查询之内,那么如果 $A$ 大于这个查询的 $K$,那么这个询问的答案肯定在 $A$ 里面 (在左边),否则肯定不在 $A$ 里面(在右边)。这样子我们就把询问划分到了左右两边,那么修改也按自己的数来划分成左右两边。划分到了右边,要让这个查询的 $K$ 减去 $A$ ,原因就是你已经到了右边,你的答案(某一次修改)肯定也在右边,不过在右边时就变成了第 $K-A$ 大。


略丑。
```pascal
Uses math;

var
    ans:array[-1..580000] of longint;
    copy1,copy2,num:array[-1..580000,1..6] of longint;
    tree:array[-1..510,-1..510] of longint;
    i,j,n,m,x1,y1,x2,y2,k,cnt,maxn:longint;

function lowbit(x:longint):longint; begin exit(x and -x); end;

procedure Insertx(x,y,k:longint); begin while y<=n do begin inc(tree[x,y],k); inc(y,lowbit(y)); end; end;

procedure Insert(x,y,k:longint); begin while x<=n do begin Insertx(x,y,k); inc(x,lowbit(x)); end; end;

function Sumx(x,y:longint):longint; begin Sumx:=0; while y>0 do begin inc(Sumx,tree[x,y]); dec(y,lowbit(y)); end; end;

function Sum(x,y:longint):longint; begin Sum:=0; while x>0 do begin inc(Sum,Sumx(x,y)); dec(x,lowbit(x)); end; end;

function Query(x1,y1,x2,y2:longint):longint; begin exit(Sum(x2,y2)-Sum(x1-1,y2)-Sum(x2,y1-1)+Sum(x1-1,y1-1)); end;

procedure Add(a,b,c,d,e,f:longint); begin inc(cnt); num[cnt,1]:=a; num[cnt,2]:=b; num[cnt,3]:=c; num[cnt,4]:=d; num[cnt,5]:=e; num[cnt,6]:=f; end;

procedure Divid(l,r,left,right:longint);                                                                   
var
    mid,tmp,i,j,i1:longint;
    tot:array[1..2] of longint;
begin
    if (l>r)or(left>right) then exit;
    if l=r then
    begin for i:=left to right do if num[i,6]>0 then ans[num[i,6]]:=l; exit;
    end;
    mid:=(l+r) >> 1; tot[1]:=0; tot[2]:=0;
    for i:=left to right do
    begin
        if num[i,6]>0 then
        begin
            tmp:=Query(num[i,1],num[i,2],num[i,3],num[i,4]);
            if tmp>=num[i,5] then begin 
                inc(tot[1]); copy1[tot[1]]:=num[i]; 
            end else begin
                dec(num[i,5],tmp); inc(tot[2]); copy2[tot[2]]:=num[i]; 
            end;
        end
        else
        begin
            if num[i,5]<=mid then begin
                inc(tot[1]); copy1[tot[1]]:=num[i]; Insert(num[i,1],num[i,2],1);
            end else begin
                inc(tot[2]); copy2[tot[2]]:=num[i]; 
            end;
        end;
    end;
    for i:=1 to tot[1] do if copy1[i,6]=0 then Insert(copy1[i,1],copy1[i,2],-1);
    for i:=1 to tot[1] do num[left+i-1]:=copy1[i];
    for i:=1 to tot[2] do num[left+tot[1]+i-1]:=copy2[i];
    Divid(l,mid,left,left+tot[1]-1);
    Divid(mid+1,r,left+tot[1],right);
end;

begin
    read(n,m);
    for i:=1 to n do for j:=1 to n do begin read(k); maxn:=max(maxn,k); Add(i,j,0,0,k,0); end;
    for i:=1 to m do begin read(x1,y1,x2,y2,k); Add(x1,y1,x2,y2,k,i); end;
    Divid(0,maxn+1,1,cnt);
    for i:=1 to m do writeln(ans[i]);
end.
```

---

## 作者：__OwO__ (赞：3)

具体的查询方法楼上的大佬们写的很清楚了
> 前人之述备矣,然则

我来提供一种树状数组的延迟清空方法,可以不用每次重新清空树状数组

方法:

需要树状数组每一个节点存上一个上次修改的时间戳,每次搜索操作前将时间戳tim增加,

然后树状数组查询和修改时判断当前节点时间戳是否最新,若不是则跳过/清空,是则统计答案/修改

代码如下:

```cpp
#include <bits/stdc++.h>
using namespace std;
#define re register
#define il inline
#define _for(i, a, b) for (re int i = (a); i <= (b); ++i)
il int read() {
    int x = 0, f = 1;
    char c = getchar();
    while (!isdigit(c)) (c == '-') && (f = -1), c = getchar();
    while (isdigit(c)) x = (x << 3) + (x << 1) + c - 48, c = getchar();
    return x * f;
}
il void put(int x) {
    if (x < 0) x = -x, putchar('-');
    if (x > 9) put(x / 10);
    putchar(48 + x % 10);
}
int tim = 0;
const int S = 505, N = 6e4 + 5;
struct P {
    int x, y, v;
    il bool operator<(const P& x) const { return v < x.v; }
} mat[S * S];
int mcnt;
struct Bit {
    int n, c[S][S], t[S][S]/* 时间戳(延迟清空标记) */;
    il Bit(int _n = 0) : n(_n) { memset(c, 0, sizeof(c)); }//正经的构造函数,没错我就是要用指针
    il int low(int x) { return x & (-x); }
    il void add(int x, int y, int v) {
        for (re int i = x; i <= n; i += low(i))
            for (re int j = y; j <= n; j += low(j)) {
            	if(t[i][j] != tim)t[i][j] = tim, c[i][j] = 0;//如果时间戳到期则清空
            	c[i][j] += v;
            }
    }
    il int query(int x, int y) {
        int retl = 0;
        for (re int i = x; i; i -= low(i))
            for (re int j = y; j; j -= low(j))
				if(t[i][j] == tim) retl += c[i][j];//不统计到期的时间戳
        return retl;
    }
    il int submat(int x1, int y1, int x2, int y2) {
        int ans = query(x2, y2);
        ans -= query(x1 - 1, y2) + query(x2, y1 - 1);
        ans += query(x1 - 1, y1 - 1);
        return ans;
    }
}*bit;
struct Op {
    int x1, x2, y1, y2, o;
    il void get() {
        x1 = read(), y1 = read(), x2 = read(), y2 = read(), o = read();
    }
} q[N];
int count(const Op& t) { return bit->submat(t.x1, t.y1, t.x2, t.y2); }
int id[N], t1[N], t2[N], ans[N], cur[N];
void solv(int l, int r, int L, int R) {
    if (L > R) return;
    if (l == r) {
        _for(i, L, R) ans[id[i]] = mat[l].v;
        return;
    }
    ++tim;
    int mid = (l + r) >> 1;
    _for(i, l, mid) bit->add(mat[i].x, mat[i].y, 1);
    int cnt1 = 0, cnt2 = 0;
    _for(i, L, R) {
        int u = id[i], s = cur[u] + count(q[u]);
        if (s >= q[u].o)
            t1[++cnt1] = u;
        else
            t2[++cnt2] = u, cur[u] = s;
    }
    int qcnt = L - 1;
    _for(i, 1, cnt1) id[++qcnt] = t1[i];
    _for(i, 1, cnt2) id[++qcnt] = t2[i];
/*   你原来需要这一句: 
    _for(i, l, mid) bit->add(mat[i].x, mat[i].y, -1);
*/
    solv(l, mid, L, L + cnt1 - 1);
    solv(mid + 1, r, L + cnt1, R);
}
int main() {
    int N, Q;
    bit = new Bit(N = read()), Q = read();
    _for(i, 1, N) _for(j, 1, N) mat[++mcnt] = {i, j, read()};
    sort(mat + 1, mat + mcnt + 1);
    _for(i, 1, Q) q[i].get(), id[i] = i;
    solv(1, mcnt, 1, Q);
    _for(i, 1, Q) put(ans[i]), putchar('\n');
    return 0;
}
```

---

## 作者：ccviolett (赞：3)

考虑如何做区间的第 k 大，Luogu 有主席树的板子，但是不强制在线照样可以用整体二分过掉。

我们将前 x 小的数插入树状数组中，单点修改，再查询所有询问区间是否满足区间内有 k 个元素，以此为依据整体二分。

这里只需要将序列上的树状数组变成平面上的二维树状数组。

有一些题解中的做法是不尽优秀的，每次从 l 到 mid 插入其间的元素。其实可以用一个类似指针的东西，随着 mid 点的移动而移动，能够在修改上花费更少的时间。

提供一份标准化的二维树状数组＋整体二分模板，偏长。

```cpp
typedef long long readtype;

/* Header {{{ */
#include <bits/stdc++.h>
using namespace std;

typedef long long var;
typedef long double let;

readtype read() {
  readtype a = 0, c = getchar(), s = 0;
  while (!isdigit(c)) s |= c == '-', c = getchar();
  while (isdigit(c)) a = a * 10 + c - 48, c = getchar();
  return s ? -a : a;
}
/* }}} */

const int N = 501 + 24;
const int Q = 6e4 + 24;

class TreeArray {
  private:
    class InsideTreeArray {
      private:
        int val[N];
        int Query(int p);
      public:
        void Modify(int p, int v);
        int Query(int l, int r);
    };

    InsideTreeArray val[N];

    int Query(int px, int pyl, int pyr);

  public:
    void Modify(int px, int py, int v);
    int Query(int lx, int rx, int ly, int ry);
};

class TpModify {
  public:
    int x, y, v;
};

class TpQuery {
  public:
    int x1, y1, x2, y2, k;
    void Read() {
      x1 = read(), y1 = read(), x2 = read(), y2 = read(), k = read();
    }
};

int n, m, q;
int v[N][N];
TpQuery query[Q];
TpModify modify[N * N];

TreeArray arr;
int ct, id[Q], tmp[Q];
int res[Q];

void Solve();
void Solve(int cl, int cr, int ql, int qr);
void Modify(int t, int v);
bool Check(int t);

int main() {
#ifndef ONLINE_JUDGE
  freopen("2738.in", "r", stdin);
  freopen("2738.out", "w", stdout);
#endif
  n = read(), q = read();
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= n; ++j) {
      v[i][j] = read();
      modify[++m] = (TpModify) {i, j, v[i][j]};
    }
  }
  for (int i = 1; i <= q; ++i) query[i].Read();

  sort(modify + 1, modify + m + 1, [=] (TpModify a, TpModify b) {
      return a.v < b.v;
      });

  Solve();
  
  for (int i = 1; i <= q; ++i) 
    printf("%d\n", modify[res[i]].v);

  return 0;
}

int TreeArray::InsideTreeArray::Query(int p) {
  int res = 0;
  for (int i = p; i; i -= i & -i) res += val[i];
  return res;
}

void TreeArray::InsideTreeArray::Modify(int p, int v) {
  for (int i = p; i <= n; i += i & -i) val[i] += v;
}

int TreeArray::InsideTreeArray::Query(int l, int r) {
  return Query(r) - Query(l - 1);
}

int TreeArray::Query(int px, int pyl, int pyr) {
  int res = 0;
  for (int i = px; i; i -= i & -i) res += val[i].Query(pyl, pyr);
  return res;
}

void TreeArray::Modify(int px, int py, int v) {
  for (int i = px; i <= n; i += i & -i)
    val[i].Modify(py, v);
}

int TreeArray::Query(int lx, int rx, int ly, int ry) {
  return Query(rx, ly, ry) - Query(lx - 1, ly, ry);
}

void Solve() {
  ct = 0;
  for (int i = 1; i <= q; ++i) id[i] = i;
  Solve(1, m + 1, 1, q);
}

void Solve(int cl, int cr, int ql, int qr) {
  if (cl > cr || ql > qr) return;
  int cm = (cl + cr) >> 1;
  if (cl == cr) {
    for (int i = ql; i <= qr; ++i) res[id[i]] = cm;
    return ;
  }

  while (ct < cm) Modify(++ct, 1);
  while (ct > cm) Modify(ct--, -1);

  int tl = ql, tr = qr;
  for (int i = ql; i <= qr; ++i) {
    if (Check(id[i])) tmp[tl++] = id[i];
    else tmp[tr--] = id[i];
  }
  for (int i = ql; i <= qr; ++i) id[i] = tmp[i];

  Solve(cl, cm, ql, tl - 1), Solve(cm + 1, cr, tl, qr);
}


void Modify(int t, int v) {
  arr.Modify(modify[t].x, modify[t].y, v);
}

bool Check(int t) {
  int have = arr.Query(query[t].x1, query[t].x2, query[t].y1, query[t].y2);
  return have >= query[t].k;
}
```

---


# 跳跳棋

## 题目描述

跳跳棋是在一条数轴上进行的。棋子只能摆在整点上。每个点不能摆超过一个棋子。

![](https://cdn.luogu.com.cn/upload/image_hosting/hyfzn745.png)

我们用跳跳棋来做一个简单的游戏：棋盘上有 $3$ 颗棋子，分别在 $a,b,c$ 这三个位置。我们要通过最少的跳动把他们的位置移动成 $x,y,z$。（棋子是没有区别的）

跳动的规则很简单，任意选一颗棋子，对一颗中轴棋子跳动。跳动后两颗棋子距离不变。一次只允许跳过 $1$ 颗棋子。

写一个程序，首先判断是否可以完成任务。如果可以，输出最少需要的跳动次数。

## 说明/提示

### 数据范围及约定

- $20\%$ 输入整数的绝对值均不超过 $10$；
- $40\%$ 输入整数的绝对值均不超过 $10000$；
- $100\%$ 绝对值不超过 $10^9$。

## 样例 #1

### 输入

```
1 2 3
0 3 5```

### 输出

```
YES
2```

# 题解

## 作者：LlLlCc (赞：124)

不得不说，这题建模极为抽象了，出题人太神了。看了好多篇题解才懂，自己也写一篇比较详细的吧

------------
相信大家都玩过跳棋，有一个规则想必大家都知道，就是**一次跳跃不能跳过两颗棋子**

这个限制是解决这题的关键，有了这个限制，可以看出，**对于两边的棋子，只能跳到其余两颗的中间，同样的中间的棋子也只能跳到两边**

为了方便，我们将三个棋子标号，**分别为$x,y,z$，且$x<y<z$。**

移动棋子无非就四种讨论

- $\large(x,y,z)\implies(2x-y,x,z)$

- $\large(x,y,z)\implies(x,z,2z-y)$

- $\large(x,y,z)\implies(y,2y-x,z)$

- $\large(x,y,z)\implies(x,2y-z,y)$

因为有了不能一次跳过两颗棋的限制，所以第三种情况和第四种情况必然起了冲突

不妨**设$d1=y-x,d2=z-y$，易得**

- $d1<d2:$则 $(x,y,z)\implies(y,2y-x,z)$

- $d1>d2:$则 $(x,y,z)\implies(x,2y-z,y)$

也就是说我们对于每种状态只有三种转移方式

我们再看看这三个式子，可以发现，**对于第一种和第二种情况，我们将中间的点向两边跳，相当于扩大了边界。而第三种两边向里面跳则恰恰相反，是将边界缩小了**

**是不是很像一棵二叉树？**

现在可能还不够明显，我们再接下去推

有一个很显然的性质，**边界不可能无限变小。也就是说缩着缩着会遇到一种情况不能再缩了，我们来思考一下什么情况不能再缩了**

观察式子：
- $d1<d2:$则 $(x,y,z)\implies(y,2y-x,z)$

- $d1>d2:$则 $(x,y,z)\implies(x,2y-z,y)$

惊奇的发现，我们这样讨论漏了一种情况，$d1=d2$

这个非常好理解，**如果$d1=d2$，那么$x$必然会与$z$跳到同一个点，而这是不符合题目描述的。所以当$d1=d2$时，这个状态只能由中间向两边跳，也就是只有两个转移状态**，想想这个状态在二叉树中像什么？没错，根节点我们就这样找到了，二叉树的形态就像下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/fzqsujan.png)

可以发现，**对于每一组$(x,y,z)$都有唯一对应的一个根，而且二叉树之间的任意一组$(x,y,z)$都可以互相转化，而且转化的操作次数就等于两个状态在树上的距离**

所以如果**初始$(x,y,z)$的树根和目标$(x',y',z')$的树根不相同，那么就是$No$，因为无论怎么跳都出不去这棵树的范围，而根不同则说明树不同**

所以对于初始$(x,y,z)$和目标$(x',y',z')$，**我们只要求出它们的$LCA$，答案就是初始点到$LCA$的距离$ +$ $LCA$到目标点的距离**

不过因为范围太大，树无法存下，普通的$LCA$求法树剖、倍增等已经无法使用了

我们先不急着求$LCA$，来想想另一个问题

初始状态：$(1,10,11)$

目标状态：$(1,2,3)$

人脑模拟一下程序，$d1>d2$，转换成$(1,9,10)$，$(d1>d2)$，转换成$(1,8,9)$，$d1>d2$，转换成$(1,7,8)$,$\cdots\cdots$

如果改成$(1,inf-1,inf)$呢？

显然要$T$飞

不过我们发现，一直在重复一个操作，所以可以将这些**操作压缩**

我们只讨论$d1>d2$的情况，$d1<d2$其实差不多

易发现，**要连续跳$(d1-1)/d2$次同样的操作（每一次跳$d2$的距离，但又不能超越或跳到$x$，也就是总距离为$(d1-1)$，总次数故为$(d1-1)/d2$）**

设：$d3=(d1-1)/d2$

所以最后是$\large(x,y-d3\cdot d1,z-d3\cdot d1)$

这样我们就大大的压缩了路径，但这样又有什么用呢？我们回到树上来

因为路径被压缩了，所以我们可以换种方法求$LCA$

方便起见，我们先将**初始状态跳到和目标状态在树中的高度一致**（如果目标状态高度更高我们就换一下，在树中的距离是没有方向的）

也是**初始状态要向上跳$Dep_T-Dep_S$次（$Dep$表示深度，$S$和$T$分别表示起始状态和目标状态），而跳跃的操作我们就可以用压缩路径快速实现**

好了，现在两个状态高度相同了

有个显然的性质，如果**两个状态同时向上跳$x$次所跳到的节点相同，那么同时向上跳$x+1$次所跳到的节点也相同，也就是说明满足单调性。所以我们可以用二分来枚举最小的$x$满足了两个状态同时向上跳$x$次所跳到的节点相同，所以$LCA$就是两个同时向上跳$x$次所跳到的节点**

然后就愉快的$AC$了

码量小但细节是真的多，思维难度也很好，总而言之就是一道质量非常高的建模$LCA$+二分的题目

如果有哪步我打错了，或者有一些没有理解的地方，欢迎私信或留言！

参考代码：
```
#include<bits/stdc++.h>
using namespace std;
int Cnt,Ans,d1,d2,d3,x,y,z,L,R,X,Y,Z,tot,a[5];
struct lc{
	int x,y,z,tot;
}A,B;
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-f;ch=getchar();}
	while (ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
inline void Dfs(int x,int y,int z){
	tot=0;
	while (1){
    	d1=y-x,d2=z-y;
    	if (d1==d2) break;
    	if (d1>d2) d3=(d1-1)/d2,tot+=d3,y-=d3*d2,z-=d3*d2;
    	else d3=(d2-1)/d1,tot+=d3,x+=d3*d1,y+=d3*d1;
	}
	if (A.x||A.y) B=(lc){x,y,z,tot};
	else A=(lc){x,y,z,tot};
}
inline void Swap(){
	swap(x,X),swap(y,Y),swap(z,Z);
	swap(A.x,B.x),swap(A.y,B.y),swap(A.z,B.z),swap(A.tot,B.tot);
}
inline bool check(int T,int x,int y,int z,int X,int Y,int Z){
	tot=T;
	while (tot){
    	d1=y-x,d2=z-y;
    	if (d1==d2) break;
    	if (d1>d2) d3=min((d1-1)/d2,tot),tot-=d3,y-=d3*d2,z-=d3*d2;
    	else d3=min((d2-1)/d1,tot),tot-=d3,x+=d3*d1,y+=d3*d1;
	}
	tot=T;
	while (tot){
    	d1=Y-X,d2=Z-Y;
    	if (d1==d2) break;
    	if (d1>d2) d3=min((d1-1)/d2,tot),tot-=d3,Y-=d3*d2,Z-=d3*d2;
    	else d3=min((d2-1)/d1,tot),tot-=d3,X+=d3*d1,Y+=d3*d1;
	}
	return X==x&&Y==y&&Z==z;
}
int main(){
	for (int i=1;i<=3;i++) a[i]=read();
	sort(a+1,a+4);x=a[1],y=a[2],z=a[3];
	for (int i=1;i<=3;i++) a[i]=read();
	sort(a+1,a+4);X=a[1],Y=a[2],Z=a[3];
	Dfs(x,y,z);Dfs(X,Y,Z);
    if (A.x!=B.x||A.y!=B.y||A.z!=B.z){printf("NO");return 0;}
    if (A.tot<B.tot) Swap();
    Ans=tot=A.tot-B.tot;
    while (tot){
    	d1=y-x,d2=z-y;
    	if (d1==d2) break;
    	if (d1>d2) d3=min((d1-1)/d2,tot),tot-=d3,y-=d3*d2,z-=d3*d2;
    	else d3=min((d2-1)/d1,tot),tot-=d3,x+=d3*d1,y+=d3*d1;
	}
	L=0,R=B.tot;
	while (L<=R){ 
		int mid=L+R>>1;
		if (check(mid,x,y,z,X,Y,Z)) Cnt=mid,R=mid-1;
	    else L=mid+1;
	}
	printf("YES\n%d",Ans+Cnt*2);
	return 0;
}
```


---

## 作者：ButterflyDew (赞：67)

**精巧的建模题。**

划重点了划重点了**一次只允许跳过1颗棋子**，这句话是解题的关键。

手玩一下跳法，现有描述位置的递增三元组$(x,y,z)$，研究它能够在一步之内跳到何处。

首先，中间的元素可以随意往两边跳到达状态$(2x-y,x,z)$和状态$(x,z,2z-y)$，注意到这两个三元组的边界是扩大了的。

对于两边的元素，设$d1=y-x,d2=z-y$

若$d1>d2$，则$c$可以往内跳，到达状态$(x,b-d2,b)$
若$d2>d1$，同理。
注意到这次到达的状态三元组的边界是缩小了的，且跳法具有**唯一性**
若$d1=d2$，则边界没法缩小了，假定为边界条件。

**对缩小边界的跳法具有唯一性**这一性质，我们可以联想到什么呢？

将初始状态和目标状态同时缩小边界，看能否产生交集。

用树来描述这一个状态集合（树父亲的唯一性对应缩小边界的唯一性）。

到这里40分就拿到了。

------------

但是我们发现，树的状态太多，无法存储。

只能每次在线询问需要的状态，复杂度为$O(d)$，$d$的两个节点的相对深度。

感觉这样就像裸奔，所以，能不能降低询问状态的复杂度呢？

再选一个三元组$(x,y,z)$玩，现在我们只需要它缩小边界的状态了，只玩这个。

对于两边的元素，设$d1=y-x,d2=z-y$

只讨论$d1>d2$的情况，如下图

![](http://r.photo.store.qq.com/psb?/V14VFGnz2yFhuP/dwcwnI2QjuJN7xxJdXgrbPEkq*MUMxAAOMUOYcG.uKQ!/r/dDABAAAAAAAA)

这样看，取一下模，就可以直接到达右边的状态了

当然注意一下细节，比如刚好整除的状态。

参考gcd的复杂度，单次查询差不多最坏为$O(logD)$,$D$为原始给出坐标最大距离

有这个加速，我们基本就只用考虑要怎么询问状态了。

------------

我们尽可能想办法只询问需要的状态。

判断是否能够到达很简单，只需要检验一下两个初始三元组的树根是否一样就行了。

如果在同一颗树了，问题就有点像LCA了。

事实上一开始的一种想法应该是直接加速的模拟往上跳，但实现起来有点困难，跳过了也不太好弄。

有一种倍增求LCA的方式是先把两个点跳到同一深度，然后两个点一起向上跳。

可以仿造这种做法先将两个状态置于一个深度，然后二分它们的LCA离它们的距离，每次加速的往上跳。

于是总复杂度：$O(log^2D)$

最后挂一下博客了[露迭月~](https://www.cnblogs.com/ppprseter/)

------------
**Code：**
```
#include <cstdio>
#include <algorithm>
int min(int x,int y){return x<y?x:y;}
int r[3],ori[3],goa[3];
int get(int a,int b,int c)
{
    int d1=b-a,d2=c-b,cnt=0;
    if(d1>d2)
    {
        cnt=d1/d2;
        int d=d1%d2;
        if(!d)
        {
            d+=d2;
            cnt--;
        }
        cnt+=get(a,a+d,a+d+d2);
    }
    else if(d1<d2)
    {
        cnt=d2/d1;
        int d=d2%d1;
        if(!d)
        {
            d+=d1;
            cnt--;
        }
        cnt+=get(c-d-d1,c-d,c);
    }
    else
        r[0]=a,r[1]=b,r[2]=c;
    return cnt;
}
void up(int a,int b,int c,int step)
{
    if(!step)
    {
        r[0]=a,r[1]=b,r[2]=c;
        return;
    }
    int d1=b-a,d2=c-b,cnt=0;
    if(d1>d2)
    {
        cnt=d1/d2;
        int d=d1%d2;
        if(!d)
        {
            d+=d2;
            cnt--;
        }
        if(step>=cnt)
            up(a,a+d,a+d+d2,step-cnt);
        else
        {
            int k=cnt-step;
            up(a,a+d+k*d2,a+d+(k+1)*d2,0);
        }
    }
    else if(d1<d2)
    {
        cnt=d2/d1;
        int d=d2%d1;
        if(!d)
        {
            d+=d1;
            cnt--;
        }
        if(step>=cnt)
            up(c-d-d1,c-d,c,step-cnt);
        else
        {
            int k=cnt-step;
            up(c-d-(k+1)*d1,c-d-k*d1,c,0);
        }
    }
    else
        r[0]=a,r[1]=b,r[2]=c;
}
bool check(int step)
{
    int to[3];
    up(goa[0],goa[1],goa[2],step);
    to[0]=r[0];to[1]=r[1];to[2]=r[2];
    up(ori[0],ori[1],ori[2],step);
    if(to[0]!=r[0]||to[1]!=r[1]||to[2]!=r[2])
        return false;
    return true;
}
int main()
{
    int to[3],ans=0;
    scanf("%d%d%d%d%d%d",ori,ori+1,ori+2,goa,goa+1,goa+2);
    std::sort(ori,ori+3);std::sort(goa,goa+3);
    int step1=get(ori[0],ori[1],ori[2]);
    to[0]=r[0];to[1]=r[1];to[2]=r[2];
    int step2=get(goa[0],goa[1],goa[2]);
    if(to[0]!=r[0]||to[1]!=r[1]||to[2]!=r[2])
    {
        printf("NO\n");
        return 0;
    }
    if(step1<step2)
    {
        ans+=step2-step1;
        up(goa[0],goa[1],goa[2],step2-step1);
        goa[0]=r[0];goa[1]=r[1];goa[2]=r[2];
    }
    else if(step1>step2)
    {
        ans+=step1-step2;
        up(ori[0],ori[1],ori[2],step1-step2);
        ori[0]=r[0];ori[1]=r[1];ori[2]=r[2];
    }
    int l=0,rr=min(step1,step2);
    while(l<rr)
    {
        int mid=l+rr>>1;
        if(check(mid))
            rr=mid;
        else
            l=mid+1;
    }
    printf("YES\n%d\n",(l<<1)+ans);
    return 0;
}

```

---

## 作者：Cgod (赞：47)

# 被大佬的脑回路感到震惊
### 这道蛇皮题目我反正看不出来是用树。。。
在lvj大佬的帮助下才懂%%%
### 好了不废话了
为了方便描述，我们把左边的棋子称为a，中间的棋子称为b，右边的为c。仔细观察跳棋规则，我们会发现当左右两跳棋到中间距离不等时有三种转移方式（因为不能跳过两个棋子）

1. b往a方向跳
2. b往c方向跳
3. a，c离b距离近的往里跳

a，c到b距离相等的时候只有1，2两种转移方式。

这TM不就是棵二叉树

往中间跳的是父亲，两旁的是儿子。

## 根就是没有父亲的节点（想一想，是什么）

现在就好做了，能不能到看根相不相同，移动次数就是他们到LCA的距离之和  ->[LCA传送门](https://www.cnblogs.com/ECJTUACM-873284962/p/6613379.html)

问题又来了，状态太多保存不下怎么办？？？

------------

# 下面是重点！！！

首先要明白棋子是相同的，所以a，b，c保存的是相对位置，跳一次相当与把两个棋子平移dis，dis为它们之间的距离。我们设d1=b-a，d2=c-b。d1小于d2时我们移动a，然后会发现d1没变，d2减小了d1所以我们可以连续走d2/d1次，反之亦然，此时d2小于d1了换个方向走。注意：d2%d1等于0时走d2/d1-1步就到根了。

---

# 那么怎么计算路径呢

先把深度大的节点移到深度小的节点（深度在求根的时候可以顺便求出来）然后二分到LCA的距离，往上走n步和求根差不多这里就不废话了，上代码。

```
  #include<iostream>
  #include<cstdio>
  #include<cstring>
  #define ll long long
  using namespace std;
  const int N=105;
  ll dep1,dep2;
  ll getroot(ll a,ll b,ll c,ll &dep,ll &d)
  {
      ll d1=b-a,d2=c-b;
      while(d1!=d2)
      {
          if(d1<d2)
          {
              ll po=d2/d1;ll op=d2%d1;
              if(!op){dep+=po-1;d=d1;return a+d1*(po-1);}
              else dep+=po,d2=op,a+=po*d1,b+=po*d1;
          }
          else
          {
              ll po=d1/d2;ll op=d1%d2;
              if(!op){dep+=po-1;d=d2;return a;}
              else dep+=po,d1=op,b-=po*d2,c-=po*d2;
          }
      }
      dep=0;d=d1;return a;
  }
  void findfa(ll &a,ll &b,ll &c,ll k)
  {
      ll d1=b-a,d2=c-b;
      while(k)
      {
          if(d1<d2)
          {
              ll po=d2/d1;ll op=d2%d1;
              if(po>=k){a+=k*d1;b+=k*d1;if(b==c)b=a,a-=d1;return;}
              k-=po;b=c-op;a=b-d1;d2=op;
          }
          else
          {
              ll po=d1/d2;ll op=d1%d2;
              if(po>=k){c-=k*d2;b-=k*d2;if(a==b)b=c,c-=d2;return;}
              k-=po;b=a+op;c=b+d2;d1=op;
          }
      }
  }
  int main()
  {
      ll a,b,c,x,y,z,p,q,cnt=0;
      cin>>a>>b>>c>>x>>y>>z;
      ll t1=a+b+c,t2=x+y+z,m1=max(a,max(b,c)),m2=max(x,max(y,z)),i1=min(a,min(b,c)),i2=min(x,min(y,z));
      a=i1,b=t1-m1-i1,c=m1,x=i2,y=t2-m2-i2,z=m2;
      ll pp=getroot(a,b,c,dep1,p);
      ll qq=getroot(x,y,z,dep2,q);
      if(pp!=qq||p!=q){puts("NO");return 0;}
      puts("YES");

      if(dep1<dep2)
      {
          cnt+=dep2-dep1;
          findfa(x,y,z,cnt);
      }
      else if(dep1>dep2)
      {
          cnt+=dep1-dep2;
          findfa(a,b,c,cnt);
      }
      ll l=0,r=min(dep2,dep1),ans=0;
      while(l<=r)
      {
          ll mid=l+r>>1;
          ll aa=a,bb=b,cc=c,xx=x,yy=y,zz=z;
          findfa(aa,bb,cc,mid);
          findfa(xx,yy,zz,mid);
          if(aa==xx&&bb==yy&&cc==zz)ans=2*mid,r=mid-1;
          else l=mid+1;
      }
      cout<<ans+cnt;
      return 0;
  }

```

最后还是%%%lvq大佬

宣传一下我的  [[blog]](https://www.luogu.org/blog/momomocxcxcx/#)

---

## 作者：_LAUV_ (赞：35)

刚开始看到这道题真的没什么想法，真是道神秘的好题啊（~）


![](https://cdn.luogu.com.cn/upload/pic/41073.png)
后来在草稿上自己画了几种状态，发现（！）每一种状态，只能发展出三种状态：

        1.中间向左跳 

        2.中间向右跳 

        3.两边的某一个向中间跳（当然根节点状态不行）
        
      

如果把一种状态疯狂地向中间折叠，会跳到一个平衡的状态，两边再也无法向中间跳了，这个状态其实就是根，而从这个状态向外发展出去，每次都只会发展出两种，所以发现这些状态构成了一棵二叉树，只要任意两种状态都能变成相同的根节点状态，那么它们一定可以相互转化（！）

所以问题就转化成求树上两个不同节点的距离了。

先让两个节点跳到一个相同的深度，再二分距离，让这两个节点同时向上跳，最后得出答案。

哦对了，向上跳（向内折叠）时发现可以用除法来加速，一下子可以折好大一段，没有必要每一次都是加法模拟（那样会超时的）

（~~不知为什么我的代码很长~~）
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<cmath>

#define For(i,a,b) for(register int i=a;i<=b;++i)
#define Re register 
using namespace std;
struct Bal{
	int x,y,z;
}b1,b2,rb1,rb2,bx1,bx2;
int tp1,tp2;
inline void read(int &v){
	v=0; bool fg=0;
	char c=getchar(); if(c=='-')fg=1;
	while(c<'0'||c>'9'){c=getchar(); if(c=='-')fg=1;}
	while(c>='0'&&c<='9'){v=v*10+c-'0',c=getchar(); if(c=='-')fg=1;}
	if(fg)v=-v;
}

void getNT(Bal &b){ //使x,y,z有序 
	if(b.x>b.y)swap(b.x,b.y);
	if(b.x>b.z)swap(b.x,b.z);
	if(b.y>b.z)swap(b.y,b.z);
}

int ComeBack(Bal &b){ //跳到根节点 
	int stp=0;
	 getNT(b);
	while(b.x+b.z!=b.y*2){
		int d1=b.y-b.x;
		int d2=b.z-b.y;
		if(d1<d2){
			int tp=d2/d1;
			if(d2%d1==0)tp--;
			b.x+=tp*d1;
			b.y+=tp*d1;
			if(b.x>b.y)swap(b.x,b.y);
			stp+=tp;
		}else{
			int tp=d1/d2;
			if(d1%d2==0)tp--;
			b.y-=tp*d2;
			b.z-=tp*d2;
			if(b.z<b.y)swap(b.z,b.y);
			stp+=tp;
		}
	}
	return stp;
}

bool QL(Bal a,Bal b){
	if(a.x==b.x&&a.y==b.y&&a.z==b.z)return 1;
	return 0;
}

Bal CheckandGo(Bal bl,int Lim){ //二分出可以向上跳的距离然后向上跳 
	Bal b=bl;
    int Lm=Lim;
    getNT(b);
	while(Lm){
		int d1=b.y-b.x;
		int d2=b.z-b.y;
		if(d1<d2){
			int tp=d2/d1; 
			if(d2%d1==0)tp--;
			if(tp>Lm)tp=Lm;
			b.x+=tp*d1;
			b.y+=tp*d1;
			if(b.x>b.y)swap(b.x,b.y);
			Lm-=tp;
		}else{
			int tp=d1/d2;
			if(d1%d2==0)tp--;
			if(tp>Lm)tp=Lm;
			b.y-=tp*d2;
			b.z-=tp*d2;
			if(b.z<b.y)swap(b.z,b.y);
			Lm-=tp;
		}
		if(Lm==0)break;
	}
	return b;
}

int main(){
//	freopen("hop.in","r",stdin);
//	freopen("hop.out","w",stdout);
	read(b1.x); read(b1.y); read(b1.z);
	read(b2.x); read(b2.y); read(b2.z);

	getNT(b1); getNT(b2);
	bx1=b1; bx2=b2;
	tp1=ComeBack(bx1); tp2=ComeBack(bx2);
	
	
	if(!QL(bx1,bx2)){
		printf("NO"); 
	}else{
		int bs=abs(tp1-tp2);
		int l=0,r=min(tp1,tp2),ff;
		
		if(tp1<tp2){//跳到同一深度 
			b2=CheckandGo(b2,bs);
		}else{
			b1=CheckandGo(b1,bs);
		}
		
		while(l<=r){ //二分 
			int m=(l+r)>>1;
			bx1=CheckandGo(b1,m);
			bx2=CheckandGo(b2,m);
			if(QL(bx1,bx2))ff=m,r=m-1;
			else l=m+1;
		}
		cout<<"YES"<<endl;
		cout<<bs+ff*2<<endl;
	}
	return 0;
}

```

---

## 作者：HH_Halo (赞：28)

# 跳跳棋「LCA+二分答案」
声明：本蒟蒻喜欢把东西讲的很详细（因为我不会），所以篇幅有点长
## 思路分析
> 此题神级建模！
              ——老姚

~~没有思路~~

~~神级建模，暗示看不出来~~

~~清华集训，暗示本蒟蒻不配~~

这题是真滴没想到能扯到$LCA$~~果断一个特判一个NO骗分就走~~
* 这题只有三个棋子，棋子的移动还算比较单一，尽管可以构成数不清的情况，以这个作为一个突破点
* 假设三颗棋子的初始位置是$x,y,z$,棋子的移动情况大体上一共就两种：
	1. **两端向中间跳**
    2. **中间向两端跳**
    
* 不难发现，对于第$2$种情况，棋子的跳动是没有限制的，想跳多远就能跳多远，**关键在于第1种情况**
* 针对第$1$种情况，我们设$x$到$y$的距离为$d_{1}$，$y$到$z$的距离为$d_{2}$，此时可以再划分出三种小情况（注意都是向中间）：
	1. $d_{1}$>$d_{2}$：这时候只能$z$跳到$x$，$y$的中间，等价于$y$和$z$向左平移$d_{2}$个单位长度（注意这里的$xyz$是三个棋子的相对顺序，而不是编号）
    2. $d_{1}<d_{2}$：与上述情况相似，$x$跳，等价于$x$和$y$向右平移$d_{1}$个单位长度
    3. $d_{1}==d_{2}$：划~重~点~。不难发现，此时两边的棋子已经无法再向中间跳了，我们将其成为**终极状态**，再次找到突破点

* 以这个终极状态为出发点，通过棋子的花式跳动可以跳出许多状态，我们称其为**子状态**。显而易见的一个性质就是，这个终极状态的任意两个子状态，都可以通过先转化为终极状态，再互相到达彼此的状态
* 由此，有没有联想到什么？？是不是和**树**很像？终极状态就是根节点，而子状态就是这个树上的任意一个节点。那么对于两种棋子的状态是否能互相转化，**我们只需要判断其跟节点，即终极状态是否相同即可**,只不过每个节点是三个点的坐标的结构体。
* 那最小步数到这里应该也比较明了了，和判断是否能互相转化的思想类似，只不过不需要跳到终极状态而已，但肯定需要一个相同的中间状态来转化，而且还需要步数最小，那不就是最近公共祖先（LCA）吗？
* 剩下最后一个问题，数据范围这么大你总不能建一棵树出来吧？那要怎么收敛状态？考虑转移过程，对于像$1,2，1e9$这种数据，我们其实可以一下处理出跳的次数的，在这种情况下，每一次跳的距离是一样的，所以我们可以求出连续跳 $k$=($d_{2}$−$1$)/$d_{1}$ 次后 $d_{1}>=d_{2}$（记得-1，否则可能重合）
* 那么公共祖先就可以在这个数轴上二分枚举了，这道题基本解决

细节见代码
## Code
```c++
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
inline int read(){
	int x = 0,f = 1;
	char ch = getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x = (x<<1)+(x<<3)+(ch^48);ch = getchar();}
	return x*f;
}
const int inf = 0x3f3f3f3f;
struct Node{
	int x,y,z;
	void Init(){
		x = read(),y = read(),z = read();
		if(x>y)swap(x,y); //记得维护顺序
		if(x>z)swap(x,z);
		if(y>z)swap(y,z);
	}
}a,b,ra,rb;
bool check(Node u,Node v){ //判断终极状态相同与否
	return u.x==v.x&&u.y==v.y&&u.z==v.z;
}
int step,k;
Node getroot(Node t,int s){ //转移到终极状态
	for(step=0;s;step+=k){
		int d1 = t.y-t.x,d2 = t.z-t.y;
		if(d1==d2)return t;
		if(d1<d2){
			k = min((d2-1)/d1,s); //跳多些
			t.x+=k*d1,t.y+=k*d1;
			s-=k;
		}
		else{
			k = min((d1-1)/d2,s);
			t.z -= k*d2,t.y-=k*d2;
			s-=k;
		}
	}
	return t;
}
int main(){
	a.Init(),b.Init();
	ra = getroot(a,inf);
	int step1 = step;
	rb = getroot(b,inf);
	int step2 = step;
	if(!check(ra,rb)){ //不同
		printf("NO\n");
		return 0;
	}
	if(step1<step2){ //一般求LCA的思想，先让远的先跳
		swap(a,b);
		swap(step1,step2);	
	}
	a = getroot(a,step1-step2);//跳到相同位置再一起跳
	int l = 0,r = step2;
	while(l<r){
		int mid = (l+r)>>1; //枚举到祖先的距离，一起跳
		if(check(getroot(a,mid),getroot(b,mid)))r = mid;
		else l = mid+1;
	}
	printf("YES\n%d\n",(l<<1)+step1-step2);//记得×2和加上a先跳的
}									
```

---

## 作者：ysner (赞：15)

这绝对是一道超级神题！！（表示自己智商低想不到/(ㄒoㄒ)/~~）。

对于状态(x,y,z)，看一下它能走到什么：
       
中间的向外面跳->(2*x-y,x,z) ->(x,z,2*z-y)；两边往中间跳：当y-x≠z-y时合法，不妨设y-x>z-y，那么->(y,2*y-x,z)。
       
可以看到，不考虑特殊情况，往中间跳有一种情况；往两边跳有两种情况；
       
 可以发现，对于(x,y,z)往两边跳得到的状态(u,v,w)，那么(x,y,z)同样是(u,v,w)往中间跳得到的状态
       
那么，我们将(u,v,w)往中间跳得到的状态(x,y,z)作为(u,v,w)的父亲，那么所有的状态刚好构成了一颗树！
       
然后答案就变成了求树上两点的距离！

回想一下普通的树上两点距离，需要得到两点的lca；更一般的需要快速得到某一个点的祖先，那么现在看一下在这道题目中，如何得到一个状态的祖先，即状态(x,y,z)往中间跳k步得到的状态。

如果直接向中间跳k步显然超时的；那么不妨令a=y-x,b=z-y，不妨设a>b，那么显然(x,y,z)的父亲(u,v,w)，满足v-u=a-b,w-v=b，定义状态(a,b)可以转移到状态(a-b,b)。那么显然每一个状态(x,y,z)对应唯一一个(a,b)，我们发现了什么？如果a>b，那么(a,b)->(a-b,b)或(a,b-a)，那么难道不可以用取模来加速运算吗？即(a,b)->(a%b,b)或(a,b%a)，刚好和求gcd一样！因此这么做就变成O(log2b)了！

于是我们可以用O(log2k)的时间得到状态(x,y,z)往中间跳k步得到的状态；那么，我们首先判断初始状态和目标状态是否在一颗树中（即根节点是否相同），如果不同输出"NO"；否则，回忆倍增求lca的过程，类似的我们可以把初始状态和目标状态先提到同一个深度，然后二分它们到其lca的距离即可。

时间复杂度O(log^2N)。
```
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#define ll long long
#define re register
#define il inline
#define fp(i,a,b) for(re int i=a;i<=b;i++)
#define fq(i,a,b) for(re int i=a;i>=b;i--)
#define inf 1e9
using namespace std;
int l,k;
il ll gi()
{
  re ll x=0,t=1;
  re char ch=getchar();
  while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
  if(ch=='-') t=-1,ch=getchar();
  while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
  return x*t;
}
struct node
{
  int x,y,z;
  il void init()
  {
    x=gi(),y=gi(),z=gi();
    if(x>y) swap(x,y);if(x>z) swap(x,z);if(y>z) swap(y,z);
  }
}a,b,p,q;
il bool eql(node u,node v)
{
  return u.x==v.x&&u.y==v.y&&u.z==v.z;
}
node getfa(node t,int s)
{
  for(l=0;s;l+=k)
    {
      re int u=t.y-t.x,v=t.z-t.y;
      if(u==v) return t;
      if(u<v)
    {
      k=min((v-1)/u,s);
      t.x+=k*u;t.y+=k*u;s-=k;
    }
      else
    {
      k=min((u-1)/v,s);
      t.y-=k*v,t.z-=k*v,s-=k;
    }
    }
  return t;
}
int main()
{
  a.init();b.init();
  p=getfa(a,inf);re int l1=l;
  q=getfa(b,inf);re int l2=l;
  if(!eql(p,q)){puts("NO");return 0;}
  if(l1<l2) swap(a,b),swap(l1,l2);
  a=getfa(a,l1-l2);
  re int l=0,r=l2,mid;
  while(l<r)
    {
      mid=l+r>>1;
      if(eql(getfa(a,mid),getfa(b,mid))) r=mid;
     else l=mid+1;
    }
  printf("YES\n%d\n",(l<<1)+l1-l2);
  return 0;
}
     
     

```

---

## 作者：DavidJing (赞：12)

**题目重点是每次不能跳过两个棋子**

即对于每一个棋子的状态(a,b,c) (a<b<c)

最多有两种移动的方式

1.中间往两边跳 (a,b,c)-->(2b-a,a,c)或(a,c,2b-c)

2.a或c往中间跳 当然要满足不跳过两个棋子

即**b-a<c-b** a可以跳过b (a,b,c)-->(b,2b-a,c)

**c-b<b-a** c可以跳过b (a,b,c)-->(a,2b-c,b)

当然当c-b=b-a时就不能再往中间跳了

此时可以想到对于一个状态(a,b,c)如果一直往中间跳 最终的状态一定是一定的

**于是可以把这个最终的状态看做是根节点 中间向左向右跳的状态分别是左右节点**

这样就是一棵二叉树了，而询问两个状态能否相互跳到就是树上距离了

于是回顾lca求树上距离的过程，我们首先要确定一个状态的k层祖先的状态是什么

如果暴力跳的话就会超时，所以我们想一种特殊的情况

(1,100000000,100000001) 显然暴力跳会一直跳1的长度是不行的

**但我们看这时b-a很大但c-b很小就意味着接下来会很多次都是c往b跳**

能跳几次呢？**因为棋子实际上没有区别 假如c跳过b 那么实际上就是c和b一起向左平移了c-b的距离**

所以c往b跳的次数就是**(b-a)/(c-b)**

这样对于本题就可以达到取模gcd的速度快速求出一个状态的k层祖先状态

这样用lca的手法先让两点到达同一高度，再二分一个距离k,如果两种状态的k层祖先一直 则将k缩小，反之增大求出他们的最近公共祖先

```cpp
#include<bits/stdc++.h>
using namespace std;
int ans,a,b,c,x,y,z,x1,yy1,z1,a1,b1,c1,t1,t2;
int read()
{
    int f=1,x=0;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(x=x*10+ch-48,ch=getchar(),ch>='0'&&ch<='9');
    return x*f;
}
void SWAP(int &a,int &b,int &c){if(a>b){swap(a,b);if(a>c)swap(a,c);}if(b>c)swap(b,c);}
void back(int &a,int &b,int &c,int k)//将状态a,b,c回到k步前的状态 即它的k层祖先 
{
    int A=b-a,B=c-b;
    if(A<B)
    {
        int t=B/A;if(B%A==0)t--;
        if(t>=k){a=a+k*A;b=b+k*A;}
        else {a=a+t*A;b=b+t*A;back(a,b,c,k-t);}
    }else
    {
        int t=A/B;if(A%B==0)t--;
        if(t>=k){c=c-k*B;b=b-k*B;}
        else {c=c-t*B;b=b-t*B;back(a,b,c,k-t);}
    }
}
int getfa(int &a,int &b,int &c)//寻找状态a,b,c的根节点 
{
    int A=b-a,B=c-b;
    if(A==B)return 0;
    if(A<B)
    {
        int t=B/A;if(B%A==0)t--;
        a=a+t*A;b=b+t*A;
        return t+getfa(a,b,c);
    }else
    {
        int t=A/B;if(A%B==0)t--;
        c=c-t*B;b=b-t*B;
        return t+getfa(a,b,c);
    }
}
int comp(int a,int b,int c,int x,int y,int z){if(a==x&&b==y&&c==z)return 1;else return 0;}
int main()
{
    a=read();b=read();c=read();
    x=read();y=read();z=read();
    SWAP(a,b,c);SWAP(x,y,z);
    x1=x;yy1=y;z1=z;a1=a;b1=b;c1=c;
    t1=getfa(x1,yy1,z1);t2=getfa(a1,b1,c1);
    if(!comp(x1,yy1,z1,a1,b1,c1)){puts("NO");return 0;}
    if(t1<t2) back(a,b,c,t2-t1);else back(x,y,z,t1-t2);
    int l=0,r=min(t1,t2);
    while(l<=r)
    {
        int mid=(l+r)>>1;
        x1=x;yy1=y;z1=z;a1=a;b1=b;c1=c;
        back(x1,yy1,z1,mid);back(a1,b1,c1,mid);
        if(comp(a1,b1,c1,x1,yy1,z1)) ans=mid,r=mid-1;else l=mid+1;
    }
    puts("YES");
    printf("%d",2*ans+max(t2,t1)-min(t2,t1));
    return 0;
}
/*
(a,b,c)

if b-a<c-b --> (b,2b-a,c)
if c-b<b-a --> (a,2b-c,b)


*/
```

---

## 作者：Saliеri (赞：10)

**国家集训队的人果真都是神仙**

***

一道使本蒟蒻当场爆零的神仙建模题

---

进入正题：

观察题目之后发现一句话：**一次最多只能跳过1个棋子**

发现了什么？

明显中间的棋子可以两边跳，而两边的棋子：

**只能将离中间距离近的向中间跳**

这就意味着：

* 任意一个状态---有序三元组(a,b,c)可以向外扩展出两个子状态(2a-b,a,c)与(a,c,2c-b)

* 然而每一种状态向内只有一种子状态，并且当前状态可以由向内的子状态向外扩展而推得！

两个确定的儿子，一个确定的父亲（能由它向外扩展而推得）

**这不就是二叉树的定义咩？！**

___

这样我们就对问题进行了一次转化：

#### *给出两个状态 (a,b,c)与 (x,y,z)，判断他们在不在一颗状态树上：*
#### *若是，输出 YES 并求他们在状态树上的距离*
#### *否则，输出 NO*

判断位置 ? **比对根即可**

求树上距离 ? **果断LCA**

LCA无法倍增 ? **二分跳的步数**

状态太多?  ~~不会了~~

怎么可能！

观察找父亲（向内跳）的过程


一边棋子与中间棋子交替向另一边靠近，每次前进步长均为跳动二棋子的间距，需要前进的距离为中间棋子与另一边棋子的距离！

若无法再跳，换边继续！

到根时，即二距离相等之时！

像什么？

**辗转相除！**

递归求解最坏时间复杂度$O(\operatorname{log}_2k)$

k为上跳步数

Tips:

其实大佬们代码中的求根函数可以直接用上跳INF步代替，可以让代码短一点...

---
### 代码：
```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
using namespace std;
int A[5],B[5];
struct data {
	int a[5];
	bool operator!=(data b) {
		for(int i=1; i<=3; i++)if(a[i]!=b.a[i])return 1;
		return 0;
	}
} na,nb;//方便结构体
int temp,ans,dep1,dep2;//temp于求根时顺便记录深度，ans为二状态深度差
data getfa(int a[],int k) {
	data ans;
	int d1=a[2]-a[1],d2=a[3]-a[2];
	for(int i=1; i<=3; i++)ans.a[i]=a[i];
	if(d1==d2)return ans;//到根
	if(d1<d2) {
		int t=min(k,(d2-1)/d1);
		k-=t;
		temp+=t;
		ans.a[2]+=t*d1,ans.a[1]+=t*d1;
	} else {
		int t=min(k,(d1-1)/d2);
		k-=t;
		temp+=t;
		ans.a[2]-=t*d2,ans.a[3]-=t*d2;
	}
	if(k)return getfa(ans.a,k);//辗转相除
	else return ans;
}
int main() {
	for(int i=1; i<=3; i++)cin>>A[i];
	for(int i=1; i<=3; i++)cin>>B[i];
	sort(A+1,A+4),sort(B+1,B+4);//让三元组有序
	na=getfa(A,inf),dep1=temp,temp=0;
	nb=getfa(B,inf),dep2=temp,temp=0;
	if(na!=nb) {
		puts("NO");
		return 0;
	}
        //调整到同一深度
	if(dep1>dep2) {
		swap(dep1,dep2);
		for(int i=1; i<=3; i++)swap(A[i],B[i]);
	}
	ans=dep2-dep1,na=getfa(B,ans);
	for(int i=1; i<=3; i++)B[i]=na.a[i];
	int l=0,r=dep1;
	while(l<r) {
    		//二分上跳步数
		int mid=(l+r)>>1;
		if(getfa(A,mid)!=getfa(B,mid))l=mid+1;
		else r=mid;
	}
	printf("YES\n%d",ans+2*l);
	return 0;
}
```
$谢谢观赏$
 

---

## 作者：Ctime_Rand_211 (赞：8)

## [P1852 跳跳棋](https://www.luogu.com.cn/problem/P1852)

### 题目大意

> 在一个数轴上给出一个三元组$(x,y,z)$表示有三个跳棋，每次可以选择一个跳棋， 向左或向右只能越过一个棋子，问是否可以通过不断跳跃满足一个局面$(a,b,c)$，并输出最少需要的步数
>
> 数据范围：$|x,y,z| \le 10^9$

### 思路

> 刚看到这题没有什么思路，手算几组数据发现一种局面可以变换为另外三种局面，即
>
> + 1.中间的点跳到左边
>
> + 2.中间的点跳到右边
>
> + 3.两边距离中间最近的点可以跳到中间  
>
>   
>
> 前两种都是没有限制可以无限跳的，但是发现第三种在三点距离相同的情况下是不能进行的
> 设$d_1 = y - x, d_2 = z - y$，即若$d_1 = d2$ 的时候无法从两边向中间跳，可以发现如果一直按方案3进行的话会到达一个$d_1=d_2$的情况，且这个状态是唯一的，为什么唯一？，因为缩小状态只有这一种方法，所以是唯一的
>
> 感觉有点像一个熟悉的东西，对，二叉树！！！
>
> 状态在$d_1 = d_2$ 的情况下相当于根节点，其他两种情况就像是两个儿子，如果初始状态$(x,y,z)$可以转移成$(a,b,c)$那么他们的根节点一定是相同的，否则他们就无法互相到达
>
> 所以求最短方案就相当于在树上找两点的路径长度，如果暴力枚举的话其状态数差不多是$O(n)$的，这时候可以考虑用求$gcd$的方法，即辗转相除求出当前状态的深度，每回深度加以相当于两边的中有一个点跳到中间，距离为$min(d_1,d_2)$则每回相除对深度的贡献即为$\lfloor \frac {max(d_1,d_2)}{min(d1, d2)} \rfloor$，通过这个方法可以快速求出深度
>
> 现在只剩求$lca$了，有两种方法1暴力2倍增，数据范围显然不可以暴力，所以考虑如何倍增，唯一的难处就是求一个节点的$k$级祖先点，这时候可以用和上述方法快速求，时间复杂度$O(n^3)$，还有细节，倍增的上限要开稍微大一些

### 代码 ~~垃圾马蜂，大佬轻D~~

> ```c++
> #include <bits/stdc++.h>
> #define int long long 
> using namespace std;
> 
> template<typename T>
> inline void read(T &num) {
> 	num = 0; bool w = 1; char c = getchar();
> 	while(!isdigit(c)) { if(c == '-') w = 0; c = getchar(); }
> 	while(isdigit(c)) { num = num*10+c-'0';; c = getchar(); }
> 	num = w ? num : -num;
> }
> 
> struct rec {
> 	int x, y, z, dep;
> 	rec(int a=0, int b=0, int c=0, int d=-1):x(a),y(b),z(c),dep(d){}
> 	inline void sort() {
> 		if(x > y) swap(x, y); if(x > z) swap(x, z); if(y > z) swap(y, z);
> 	}
> 	inline bool operator==(rec _) const { return x==_.x&&y==_.y&&z==_.z; }
> } s, t;
> 
> inline rec getroot(rec a) {
> 	a.sort(); rec now = a; now.dep = 0;
> 	int d1 = a.y - a.x, d2 = a.z - a.y;
> 	while(d1 != d2) {
> 		d1 = now.y - now.x, d2 = now.z - now.y;
> 		if(d1 > d2) { int ret = d1 / d2; if(d1 % d2 == 0) ret--;
> 			now.dep += ret; now.y -= ret*d2; now.z -= ret*d2;
> 		}
> 		else { int ret = d2 / d1; if(d2 % d1 == 0) ret--;
> 			now.dep += ret; now.x += ret*d1; now.y += ret*d1;
> 		}
> 	}
> 	return now;
> }
> 
> inline rec jump(rec a, int k) {
> 	int tim = 1 << k;
> 	if(a.dep < tim) return rec();
> 	a.sort(); int d1, d2;
> 	while(tim) { d1 = a.y-a.x, d2 = a.z-a.y;
> 		if(d1 > d2) { int ret = d1 / d2;
> 			if(ret < tim) tim -= ret, a.dep -= ret, a.z -= ret*d2, a.y -= ret*d2;
> 			else { a.dep -= tim, a.z -= tim*d2, a.y -= tim*d2; return a; }
> 		}
> 		else { int ret = d2 / d1;
> 			if(ret < tim) tim -= ret, a.dep -= ret, a.x += ret*d1, a.y += ret*d1;
> 			else { a.dep -= tim; a.x += tim*d1, a.y += tim*d1; return a; }
> 		}
> 	}
> }
> 
> signed main() { int ans = 0;
> 	read(s.x), read(s.y), read(s.z); s.dep = 0;
> 	read(t.x), read(t.y), read(t.z); t.dep = 0;
> 	rec ss = getroot(s); rec tt = getroot(t); 
> 	s.dep = ss.dep, t.dep = tt.dep;
> 	if(ss == tt) {
> 		puts("YES"); rec ft, fs;
> 		if(s.dep > t.dep) swap(s, t);
> 		for(int i = 30; i >= 0; i--) {
> 			ft = jump(t, i);
> 			if(ft.dep < s.dep) continue;
> 			ans += (1<<i); t = ft;
> 		}
> 		if(s == t) { cout << ans << endl; return 0; }
> 		for(int i = 30; i >= 0; i--) {
> 			fs = jump(s, i), ft = jump(t, i);
> 			if(fs == ft) continue;
> 			s = fs, t = ft;
> 			ans += (1<<(i+1));
> 		}
> 		ans += 2; cout << ans << endl;
> 	}
> 	else puts("NO");
> 	return 0;
> }
> 
> ```
>
> 

---

## 作者：徐致远 (赞：3)


[本蒟蒻的Blog](https://www.chnxuzhiyuan.cn/2019/04/06/%E3%80%8C%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E3%80%8D%E8%B7%B3%E8%B7%B3%E6%A3%8B-Solution/)

### 题解

这题的建模有点神仙。

根据题意，设三颗棋子的位置分别为$a,b,c(a<b<c)$，令$d1=b-a,d2=c-b$。

由题意可知，一共有三种移动方式：

1. 中间的棋子往左跳。
2. 中间的棋子往右跳。
3. 两边的棋子中离中间棋子近的一颗往中间跳。

假如不断使用第三种跳法，那么对于任意一个状态，最后它将会跳到一个$d1=d2$的状态，此时便不能继续跳了。

并且对于任意一个状态，它只可能由两种状态执行操作三而转移过来。

所以如果以一个$d1=d2$的状态作为根，每个状态向可能转移到该状态的两个状态建边，那么这将会是一颗二叉树。

对于两个状态，它们所对应的节点在树上的最短路径的长度就是转移所需的最小步数。

如果这两个状态不在同一棵树上，那么它们之间就不可能相互转移。

于是乎建出树之后，直接求LCA就行了。

但是还有一个问题就是树太大了，存不下。

那就可以先求出两个状态到根的深度，然后先把深度大的向上跳到深度相同，接着二分到LCA的距离即可。

注意当$d1$和$d2$相差了好多倍时，可以一次性跳好几步，以免TLE。

然后就，没了...

### 代码

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int dep1,dep2,ans;
struct Ball
{
	int a,b,c;
	inline void Sort()
	{
		if(a>b) swap(a,b);
		if(a>c) swap(a,c);
		if(b>c) swap(b,c);
	}
	bool operator == (const Ball& b)const{return a==b.a&&this->b==b.b&&c==b.c;}
}A,B,tep1,tep2;
int GetFather(Ball x,int stp,Ball& lst)
{
	int d1=x.b-x.a,d2=x.c-x.b,ret=0;
	while(d1!=d2&&stp>0)
	{
		if(d1<d2)
		{
			if(d2%d1==0)
			{
				int nt=min(stp,d2/d1-1);
				x.a+=nt*d1;x.b+=nt*d1;
				stp=0;ret+=nt;
			}
			else
			{
				int nt=min(stp,d2/d1);
				x.a+=nt*d1;x.b+=nt*d1;
				stp-=nt;ret+=nt;
			}
		}
		else
		{
			if(d1%d2==0)
			{
				int nt=min(stp,d1/d2-1);
				x.b-=nt*d2;x.c-=nt*d2;
				stp=0;ret+=nt;
			}
			else
			{
				int nt=min(stp,d1/d2);
				x.b-=nt*d2;x.c-=nt*d2;
				stp-=nt;ret+=nt;
			}
		}
		d1=x.b-x.a;d2=x.c-x.b;
	}
	lst=x;
	return ret;
}
int main()
{
	scanf("%d%d%d%d%d%d",&A.a,&A.b,&A.c,&B.a,&B.b,&B.c);
	A.Sort();B.Sort();
	dep1=GetFather(A,2147483647,tep1);
	dep2=GetFather(B,2147483647,tep2);
	if(!(tep1==tep2))
	{
		printf("NO\n");
		return 0;
	}
	if(dep1>dep2)
	{
		ans+=dep1-dep2;
		GetFather(A,dep1-dep2,tep1);
		A=tep1;dep1=dep2;
	}
	if(dep2>dep1)
	{
		ans+=dep2-dep1;
		GetFather(B,dep2-dep1,tep2);
		B=tep2;dep2=dep1;
	}
	int L=0,R=dep1,mid;
	while(L<=R)
	{
		mid=(L+R)>>1;
		GetFather(A,mid,tep1);
		GetFather(B,mid,tep2);
		tep1==tep2?R=mid-1:L=mid+1;
	}
	ans+=L*2;
	printf("YES\n%d\n",ans);
	return 0;
}
```



---

## 作者：cirnovsky (赞：2)

## 题意简述

在一个数轴上给你三个点，移动方法是彼此为中点进行跳跃，不能同时越过两颗棋子。

给出初始状态和目标状态，问能否从初始状态跳到目标状态。若能，输出最少步数。

棋子之间互相没有差别。

## 题解

这道题是我们去年学倍增的时候教练给我们放的一道题（实际上和倍增没有半毛钱的关系。

啊对我就是一道题从去年做到今年（我不管做出来了就是我的题量XD/xyx

不扯了说正事儿。

其实拿到这道题我是很懵的，完全不知道该怎么入手。

然后我们拿出传统手艺手玩数据。我们可以发现对于一个三元组 $(x,y,z)$ 只有三种移动的方案：

（啊对了，说一下这里的三元组表示的是一种位置关系，即 $x$ 在左 $y$ 在中间 $z$ 在右）

中间往两边跳

>1. $y$ 以 $x$ 为中点进行跳跃，三元组变为：$(x-(y-x),x,z)\implies(2x-y,x,z)$

>2. $y$ 以 $z$ 为中点进行跳跃，三元组变为：$(x,z,z+(z-y))\implies(x,z,2z-y)$

两边往中间跳

这里方便讨论我们不妨设 $dis_{1}$ 为 $x$ 和 $y$ 之间的距离，$dis_{2}$ 为 $y$ 和 $z$ 之间的距离。

当 $dis_{1} > dis_{2}$

>3. $x$ 以 $y$ 为中点进行跳跃，三元组变为：$(y,y+dis_{1},z)\implies(y,2y-x,z)$

当 $dis_{1} < dis_{2}$

>3. $z$ 以 $y$ 为中点进行跳跃，三元组变为：$(x,y-dis_{2},y)\implies(x,2y-z,y)$

当 $dis_{1}=dis_{2}$

无法继续跳，也就是我们的边界。

好，现在把所有我们已知的条件串起来看：这不就是一棵二叉树吗？

对呀，这就是一棵二叉树（我在说什么

为什么这一定是一棵树呢？想一想就明白了，就像数学中的收敛一样，最后一定会出现 $dis_{1}=dis_{2}$ 的情况。

而且这棵树是唯一确定的。

那么这道题的答案是什么就很明确了。

首先判断YES或NO的情况我们只需要判断初始状态和目标状态是否在统一棵状态树上即可。

最小的步数就是他们两个在树上的距离。

暴力肯定是不可取的。

但是我们可以通过模拟暴力的情景来得到优化的策略。

比如我们思考一个数据：$x,y,z$。

其中 $y$ 是一个 **远大于** $x$ 的数。

方便起见我们令 $z=y+1$

暴力此时会不停的让 $z$ 以 $y$ 为中点跳。

此时我们回顾一下题面：

棋子之间互相没有差别。

没错，每颗棋子之间其实是没有任何差别的。

打个比方说，现在 $z$ 以 $y$ 为中点进行了跳跃，其本质就是 $z$ 和 $y$ 一起往左平移了 $z-y$ 步。

这就意味着，我们不需要老老实实的每次都跳，我们可以直接获得 $z$ 跳跃的次数即 $(y-x)\div(z-y)$ 次。

再推一下就是欧几里得最大公约数的形式了，也就是说我们在 $log_{2}$ 的复杂度解决了这个问题。

最后二分一下到LCA的距离，这道题就被你暴切啦

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>

using namespace std;

int a, b, c;
int x, y, z;

void sort(int& x, int& y, int& z) {
	vector < int > vec;
	vec.push_back(x);
	vec.push_back(y);
	vec.push_back(z);
	sort(vec.begin(), vec.end());
	x = vec[0], y = vec[1], z = vec[2];
}

void Initialization() {
	scanf("%d %d %d", &a, &b, &c);
	scanf("%d %d %d", &x, &y, &z);
	sort(a, b, c);
	sort(x, y, z);
}

int GetRoot(int& x, int& y, int& z) {
	int dis1 = y - x;
	int dis2 = z - y;
	if (dis1 ^ dis2) {
		int temp;
		if (dis1 < dis2) {
			temp = dis2 / dis1;
			if (!(dis2 % dis1)) --temp;
			x += temp * dis1;
			y += temp * dis1;
		}
		else {
			temp = dis1 / dis2;
			if (!(dis1 % dis2)) --temp;
			z -= temp * dis2;
			y -= temp * dis2;
		}
		return temp + GetRoot(x, y, z);
	}
	else return 0;
}

void ArriveK(int& x, int& y, int& z, int key) {
	int dis1 = y - x;
	int dis2 = z - y;
	if (dis1 < dis2) {
		int temp = dis2 / dis1;
		if (!(dis2 % dis1)) --temp;
		if (temp >= key) {
			x += key * dis1;
			y += key * dis1;
		}
		else {
			x += temp * dis1;
			y += temp * dis1;
			ArriveK(x, y, z, key - temp);
		}
	}
	else {
		int temp = dis1 / dis2;
		if (!(dis1 % dis2)) --temp;
		if (temp >= key) {
			z -= key * dis2;
			y -= key * dis2;
		}
		else {
			z -= temp * dis2;
			y -= temp * dis2;
			ArriveK(x, y, z, key - temp);
		}
	}
}

signed main() {
	Initialization();
	int a0 = a, b0 = b;
	int c0 = c, x0 = x;
	int y0 = y, z0 = z;
	int rt1 = GetRoot(x0, y0, z0);
	int rt2 = GetRoot(a0, b0, c0);
	if (a0 ^ x0 || b0 ^ y0 || c0 ^ z0) return puts("NO") & 0;
	if (rt1 < rt2) ArriveK(a, b, c, rt2 - rt1);
	else ArriveK(x, y, z, rt1 - rt2);
    int l = 0, r = min(rt1, rt2);
    while (l < r) {
        int mid = (l + r) >> 1;
        a0 = a, b0 = b, c0 = c;
        x0 = x, y0 = y, z0 = z;
        ArriveK(x0, y0, z0, mid);
        ArriveK(a0, b0, c0, mid);
        if (x0 == a0 && y0 == b0 && z0 == c0)
            r = mid;
        else
            l = mid + 1;
    }
    printf("YES\n%d\n", max(rt1, rt2) - min(rt1, rt2) + (l << 1));
	return 0;
}
```

---

## 作者：pomelo_nene (赞：2)

Rewrite on 2021/9/14。

没有特别的性质，需要分析棋子移动的规律。按位置从小到大编号为 $a,b,c$。跳法有：

1. $b$ 跳过 $a$；   
2. $b$ 跳过 $c$；   
3. $a,c$ 中离 $b$ 近的跳过 $b$（如果 $a,c$ 离 $b$ 一样近就不能跳了）。

注意到，我们进行了一次 1 或 2 操作，我们可以用一次 3 操作将之前的 1 或 2 操作撤销。用三个棋子的位置描述一个点，这样的话，对于一个局面转化成点后，将当前局面进行 1 或 2 操作形成的局面看成当前局面的儿子，如果可以进行 3 操作，进行 3 操作形成的局面看作当前局面的爸爸（如果不可操作就没有）。显然我们构成了一棵二叉树，并且对于任意一个局面，按这种方式生成二叉树有且只有一个根。这样的话显然两个局面互达的条件就是生成后的根相同。

暴力跳显然会挂。但是如果对于一段一直 $a$ 跳过 $b$（反之亦然）的我们可以直接用除法算出来。时间复杂度类似于等同于辗转相除法的时间复杂度，为 $O(\log V)$（其中 $V$ 为值域）。注意到我们可以设置一个向上跳的高度对操作次数进行限制，这样就能算出进行 $k$ 次操作 3 的状态是什么了。

算出这个后，我们需要看两个状态的根是否一样。我们将 $k$ 设为极大值就可以知道根是什么，就可以判断是否可行了。

最后是要算最小步数。类似于树上差分，我们先跳到两个点的 LCA，然后再往下跳一定最优。知道两个状态的点的深度，我们需要求出 LCA 状态的深度。首先将两个点跳至一样的高度，然后二分点和 LCA 的距离，用上面的方法跳判断是否相同。这样就能找到 LCA。

最后答案显然，两个状态的深度减去 LCA 状态的深度的二倍即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
char buf[1<<21],*p1=buf,*p2=buf;
#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
LL read()
{
	LL x=0,f=1;
	char c=getchar();
	while(c<'0' || c>'9')	f=(c=='-'?-1:f),c=getchar();
	while(c>='0' && c<='9')	x=(x<<1)+(x<<3)+(c^'0'),c=getchar();
	return x*f;
}
void write(LL x)
{
	if(x<0)	putchar('-'),x=-x;
	if(x>9)	write(x/10);
	putchar(x%10+'0');
}
struct State{
	LL pos[5];
	State(LL A=0,LL B=0,LL C=0){memset(pos,0,sizeof pos),pos[1]=A,pos[2]=B,pos[3]=C;}
	void adjust(){sort(pos+1,pos+4);}
	LL operator [] (LL x) {return pos[x];}
	bool operator == (State ano) const {return (pos[1]==ano[1] && pos[2]==ano[2] && pos[3]==ano[3]);}
	bool operator != (State ano) const {return !(*this==ano);}
}st1,st2,root1,root2;
LL dep1,dep2,dep;
State getAnc(State st,LL k)
{
	LL dis1=st[2]-st[1],dis2=st[3]-st[2];
	if(dis1==dis2)	return st;
	if(dis1<dis2)
	{
		LL cur=min(k,(dis2-1)/dis1);
		k-=cur;
		dep+=cur;
		st.pos[1]+=cur*dis1;
		st.pos[2]+=cur*dis1;
	}
	else
	{
		LL cur=min(k,(dis1-1)/dis2);
		k-=cur;
		dep+=cur;
		st.pos[2]-=cur*dis2;
		st.pos[3]-=cur*dis2;
	}
	return k?getAnc(st,k):st;
}
int main(){
	for(LL i=1;i<=3;++i)	st1.pos[i]=read();
	for(LL i=1;i<=3;++i)	st2.pos[i]=read();
	st1.adjust(),st2.adjust();
	root1=getAnc(st1,10000000000ll),dep1=dep,dep=0,root2=getAnc(st2,10000000000ll),dep2=dep,dep=0;
	if(root1!=root2)	return puts("NO")&0;
	puts("YES");
	if(dep1>dep2)	swap(st1,st2),swap(dep1,dep2);
	LL delta=dep2-dep1;
	st2=getAnc(st2,delta);
	LL l=0,r=dep1;
	while(l<=r)
	{
		LL mid=(l+r)>>1;
		if(getAnc(st1,mid)!=getAnc(st2,mid))	l=mid+1;
		else	r=mid-1;
	}
	write(l*2+delta);
	return 0;
}
```

---

## 作者：C20203030 (赞：0)

## 一、题目

[点此看题](https://www.luogu.org/problem/P1852)

## 二、解法
乍一看，这不是个搜索题吗？直接跑$bfs$，发现只有$20$分$qwq$。

发现每个状态都可以产生三种状态，我们把中间的棋子往两边跳视为当前状态到两个子状态，把两边的棋子往中间跳视为当前状态到一个父状态（至多有一个棋子满足跳的条件），这样原来的搜索就转化成了在一棵二叉树上找两点间的最短路，我们先求出这两个点的深度，然后把他们调整到同一个深度，再一步一步向上跳。

发现时间主要消耗在爬树的过程，考虑对这个过程加速，由于我们现在的跳跃是等价于在长的距离（两点到中间的距离）中减去短的距离，我们自然地想到了用辗转相除法对跳跃进行优化，时间变为$log$级。由于我们的图还没有建好，调整深度后，我们可以用二分的方式二分向上跳的步数，然后用类似辗转相除法的方式快速跳，这样我们就得到了一个$log^2$的算法。


```cpp
#include <cstdio>
#include <iostream>
using namespace std;
#define int long long
int read()
{
    int x=0,flag=1;
    char c;
    while((c=getchar())<'0' || c>'9') if(c=='-') flag=-1;
    while(c>='0' && c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*flag;
}
int ans,ad;
struct node
{
    int a,b,c,dep;
    void get()
    {
        int x=read(),y=read(),z=read();
        a=min(x,min(y,z));
        c=max(x,max(y,z));
        b=x+y+z-a-c;
    }
    bool operator != (const node &x) const
    {
        return (a!=x.a || b!=x.b || c!=x.c);
    }
} s,e;
int Abs(int x)
{
    return x>0?x:-x;
}
node find_rt(node x,int &dep)
{
    int d1=x.b-x.a,d2=x.c-x.b;
    if(d1<d2)
    {
        int tmp=d2/d1,d=d2%d1;
        if(d==0)
        {
            d=d1;
            tmp--;
        }
        dep+=tmp;
        return find_rt(node{x.c-d-d1,x.c-d,x.c,0},dep);
    }
    if(d1>d2)
    {
        int tmp=d1/d2,d=d1%d2;
        if(d==0)
        {
            d=d2;
            tmp--;
        }
        dep+=tmp;
        return find_rt(node{x.a,x.a+d,x.a+d+d2,0},dep);
    }
    return x;
}
node search(node x,int step)
{
    int d1=x.b-x.a,d2=x.c-x.b;
    if(d1<d2)
    {
        int tmp=d2/d1,d=d2%d1;
        if(d==0)
        {
            d=d1;
            tmp--;
        }
        if(step<tmp)
            return node{x.a+step*d1,x.a+(step+1)*d1,x.c,0};
        return search(node{x.c-d-d1,x.c-d,x.c,0},step-tmp);
    }
    if(d1>d2)
    {
        int tmp=d1/d2,d=d1%d2;
        if(d==0)
        {
            d=d2;
            tmp--;
        }
        if(step<tmp)
            return node{x.a,x.c-(step+1)*d2,x.c-step*d2,0};
        return search(node{x.a,x.a+d,x.a+d+d2,0},step-tmp);
    }
    return x;
}
void conquer(int l,int r)
{
    if(l>r) return ;
    int mid=(l+r)/2;
    if(search(s,mid)!=search(e,mid))
        conquer(mid+1,r);
    else
    {
        ans=mid;
        conquer(l,mid-1);
    }
}
signed main()
{
    s.get();
    e.get();
    if(find_rt(s,s.dep)!=find_rt(e,e.dep))
        return !puts("NO");
    puts("YES");
    ad=Abs(s.dep-e.dep);
    if(s.dep>e.dep)
        s=search(s,ad);
    else
        e=search(e,ad);
    conquer(0,0x3f3f3f3f);
    printf("%lld\n",2*ans+ad);
}

```



---


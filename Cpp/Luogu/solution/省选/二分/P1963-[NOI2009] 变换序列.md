# [NOI2009] 变换序列

## 题目描述

对于 $N$ 个整数 $0, 1, \cdots, N-1$，一个变换序列 $T$ 可以将 $i$ 变成 $T_i$，其中 $T_i \in \{ 0,1,\cdots, N-1\}$ 且 $\bigcup_{i=0}^{N-1} \{T_i\} = \{0,1,\cdots , N-1\}$。$\forall x,y \in  \{0,1,\cdots , N-1\}$，定义 $x$ 和 $y$ 之间的距离 $D(x,y)=\min\{|x-y|,N-|x-y|\}$。给定每个 $i$ 和 $T_i$ 之间的距离 $D(i,T_i)$，你需要求出一个满足要求的变换序列 $T$。如果有多个满足条件的序列，输出其中字典序最小的一个。

说明：对于两个变换序列 $S$ 和 $T$，如果存在 $p<N$，满足对于 $i=0,1,\cdots p-1$，$S_i=T_i$ 且 $S_p<T_p$，我们称 $S$ 比 $T$ 字典序小。

## 说明/提示

- 对于 $30\%$ 的数据，满足：$N \le 50$；
- 对于 $60\%$ 的数据，满足：$N \le 500$；
- 对于 $100\%$ 的数据，满足：$N \le 10 ^ 4$。


## 样例 #1

### 输入

```
5
1 1 2 2 1
```

### 输出

```
1 2 4 0 3```

# 题解

## 作者：10000point (赞：64)

**本来不打算写题解的，但我发现洛谷上几乎没有一篇题解对本题进行了系统的分析，很多题解的方法都是因数据水和本题的特殊性质才过的，所以就写了本篇详细的题解。**

### 思路

首先，对于每一个 $A_i$ 我们可以向 $T_{A_i+d_i}$，$T_{A_i-d_i}$，$T_{A_i-n+d_i}$，$T_{A_i+n-d_i}$ 分别连边，于是问题转化为我们要求一种方案，使每一个 $A_i$ 需对应一个它连向的 $T$，很明显是二分图匹配。

如果不能够完美匹配，就直接无解。

否则若不用求字典序最小就很简单。但因为要求字典序最小，我们就考虑新匹配一个的影响。首先肯定要从小到大枚举他的儿子（字典序最小），如果有没匹配的，就直接匹配。否则我们必须去抢一个已经匹配的。这样可以保证现在匹配这个点字典序一定最优，但不能保证抢的点以及增广路上的其它点最优。而一个序列的字典序是从前往后比较的，也就是我们需要保证前面的最优。于是我们倒着匹配，就可以完成本题了。

### 思考（重点）

但其实在二分图完美匹配中直接倒着匹配是**不能**保证字典序最小的，只是因为本题有特殊性质——每个左边的点只会有两条边与之相连。这是为什么呢？我们将从三个问题对此分析。

#### 1.为什么在二分图完美匹配中直接倒着匹配不能保证字典序最小？

这是我在知乎上找到的一张图：

![img](https://pic2.zhimg.com/v2-1dafb47f7eb9e3482133be3138623f51_b.png)

由图可见，在第五步寻找增广路时，$3$ 去抢了 $2$ 所匹配的 $5$，但 $2$ 的优先级是高于 $3$ 的。推广可知，虽然倒着匹配可以保证当前的最小，但因为有后效性，后面的增广路可能会交叉，导致顺序被打乱。所以二分图完美匹配中直接倒着匹配是不能保证字典序最小的。

#### 2.为什么在每个左边的点最多只有两条边与之相连的二分图完美匹配中直接倒着匹配能保证字典序最小？

这是一个很巧妙的证明，来自 byvoid 大佬。

首先，我们不停地选择右边只有一条连边的点。由于要达到完美匹配，与它相连的左边的点必须与它匹配。所以可以把那个点连的两条边删掉。

此时，所有右边度数为 $1$ 的点都被删完了，所以 $min\ge2$。而右边总度数开始时为 $2n$，每匹配一个点度数 $-2$，所以假设剩下 $k$ 个点，总度数一定为 $2n-2(n-k)=2k$，又因为 $min\ge2$，所以每个右边的点度数都为 $2$。

然后因为图中每个点度数都为 $2$，所以被分成了若干个度数为 $2$ 的环。倒着匹配的过程中，确定了一个匹配后，两个端点所连的另两个点的匹配也就确定了，一直循环下去，环中所有剩余的匹配也就确定了（自己模拟一下有助于理解）。所以虽然有后效性，但在后面的过程中只有一种选择，就一定可以保证字典序最小了。

#### 3.为什么本题中每个左边的点只会有两条边与之相连？

看似对于每一个 $A_i$ 我们可以向 $T_{A_i+d_i}$，$T_{A_i-d_i}$，$T_{A_i-n+d_i}$，$T_{A_i+n-d_i}$ 分别连边，这样每个左边的点可能会有四条边与之相连。但实际上，$A_i+d_i$ 和 $A_i-n+d_i$ 肯定只会有一个在 $1$ 至 $n$ 范围内,$A_i-d_i$ 和 $A_i+n-d_i$ 也一样，所以每一个点都可以排除两种情况，以至本题中每个左边的点只会有两条边与之相连。

现在，我们已经解决了这三个问题了。但**对于一般的二分图完美匹配，求最小字典序的通解**是什么呢？

#### 算法 1:

枚举全排列，再看能否完美匹配。时间复杂度 $O(2^nmn)$。

#### 算法 2:

从前往后枚举，对于每一个点，从小到大假设它与谁匹配，如果它匹配后剩下的图仍构成完美匹配，就说明它可以与当前儿子匹配，删掉这个点与其匹配点。时间复杂度 $O(m^2n)$。

#### 算法 3:

在算法 2 中，每假设当前点 $x$ 与某个点 $y$ 匹配，就要对整个图跑一次二分图匹配，但实际上大多点在这次匹配操作后是没有影响的。所以我们可以先在开始时对整个图跑一次二分图匹配。经过分析，我们可以发现把 $x$ 与 $y$ 匹配只会影响两个点：目前与 $x$ 匹配的点与目前与 $y$ 匹配的点。所以每次只用对影响的这两个点中的任意一个点跑一次增广路就可以了。时间复杂度 $O(m(m+n))$。

至此，我们已经找到了在较低时间复杂度内对一般的二分图完美匹配求最小字典序的方法了。对于不是完美匹配的，需要通过网络流实现，由于我还没学网络流，所以无法在此展开叙述。

### 代码

倒着匹配的方法：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=1e4+5;
int n,m,x[M],ans,linkx[M],linky[M];
bool vis[M];
vector<int> son[M];
int dfs(int k)
{
	if(vis[k]==1) return 0;
	vis[k]=1;
	for(int a=0;a<son[k].size();a++)
	{
		int s=son[k][a];
		if(linky[s]==0||dfs(linky[s])==1)
		{
			linkx[k]=s;
			linky[s]=k;
			return 1;
		}
	}
	return 0;
}
int main()
{
	scanf("%d",&n);
	for(int a=1;a<=n;a++) scanf("%d",&x[a]);
	for(int a=1;a<=n;a++)
	{
		if(a+x[a]<=n) son[a].push_back(a+x[a]);
		if(a-x[a]>=1) son[a].push_back(a-x[a]);
		if(a+n-x[a]<=n) son[a].push_back(a+n-x[a]);
		if(a-n+x[a]>=1) son[a].push_back(a-n+x[a]);
		if(son[a].size()!=0) sort(son[a].begin(),son[a].end());
	}
	for(int a=n;a>=1;a--)
	{
		memset(vis,0,sizeof(vis));
		ans+=dfs(a);
	}
	if(ans<n)
	{
		printf("No Answer\n");
		return 0;
	}
	for(int a=1;a<=n;a++) printf("%d ",linkx[a]-1);
}
```

通解：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=1e4+5;
int n,m,x[M],ans,linkx[M],linky[M];
bool vis[M],exi[2*M];
vector<int> son[M];
int dfs(int k)
{
	if(vis[k]==1||exi[k]==0) return 0;
	vis[k]=1;
	for(int a=0;a<son[k].size();a++)
	{
		int s=son[k][a];
		if(exi[n+s]==0) continue;
		if(linky[s]==0||dfs(linky[s])==1)
		{
			linkx[k]=s;
			linky[s]=k;
			return 1;
		}
	}
	return 0;
}
int main()
{
	scanf("%d",&n);
	for(int a=1;a<=n;a++) scanf("%d",&x[a]);
	for(int a=1;a<=n;a++)
	{
		if(a+x[a]<=n) son[a].push_back(a+x[a]);
		if(a-x[a]>=1) son[a].push_back(a-x[a]);
		if(a+n-x[a]<=n) son[a].push_back(a+n-x[a]);
		if(a-n+x[a]>=1) son[a].push_back(a-n+x[a]);
		if(son[a].size()!=0) sort(son[a].begin(),son[a].end());
	}
	for(int a=1;a<=2*n;a++) exi[a]=1;
	for(int a=1;a<=n;a++)
	{
		memset(vis,0,sizeof(vis));
		ans+=dfs(a);
	}
	if(ans<n)
	{
		printf("No Answer\n");
		return 0;
	}
	for(int a=1;a<=n;a++)
	{
		for(int b=0;b<son[a].size();b++)
		{
			int s=son[a][b];
			bool check=0;
			if(linkx[a]==s) check=1;
			else
			{
				exi[a]=exi[n+s]=0;
				linky[linkx[a]]=0;
				memset(vis,0,sizeof(vis));
				if(dfs(linky[s])==1) check=1;
				else linky[linkx[a]]=a;
				exi[a]=exi[n+s]=1;
			}
			if(check==1)
			{
				exi[a]=exi[n+s]=0;
				printf("%d ",s-1);
				break;
			}
		}
	}
}
```

---

## 作者：Nemlit (赞：33)

我们先不考虑字典序最小，先来求出一种可行解。

不难发现，对于每一个i值，它所对应的T值在模n意义下最多两个，于是我们可以用二分图匹配来判断。

那字典序最小呢？

~~回顾一下二分图匹配的算法：网络流？貌似不好做到字典序最小，所以我们来看匈牙利算法~~

匈牙利算法是从1~n枚举点，看是否能合法，如果它要的边没被连就连，如果被连过了就一直判断是否有办法可以让前面的匹配换一种连接方式，便是用这种连边方式。

如果实在没有办法了，就只能委屈一下自己了。

那么这样匹配能否使字典序最小呢？

显然是不行的，即使我们让第一条边找到了字典序最小的点，如果后面的点请求更换，而且正好又可以更换找到更大匹配，那么就不一定是字典序最小了~~（毒瘤）~~。

那么我们可以怎么做呢？

我们逆向思维，考虑从后往前加边，后面边先选字典序小的，如果前面的边需要就直接给了，这样就可以保证字典序最小了。

代码如下：

```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define debug printf("Now is Line : %d\n",__LINE__)
il int read()
{
    re int x=0,f=1; re char c=getchar();
    while(c<'0'||c>'9') {if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
    return x*f;
}
#define maxn 10005
int n,m,d[maxn],aa[2][maxn],vis[maxn],cnt,ans,match[maxn],to[maxn];
bool dfs(int u)
{
    for(re int i=0;i<2;++i)
    {
        int v=aa[i][u];
        if(vis[v]) continue;
        vis[v]=1;
        if(match[v]==-1||dfs(match[v])) return match[v]=u,to[u]=v,1;
    }
    return 0;
}
int main()
{
    n=read();
    memset(match,-1,sizeof(match));
    for(re int i=0;i<n;++i) d[i]=read();
    for(re int i=0;i<n;++i)
    {
        int a=(i-d[i]+n)%n,b=(i+d[i])%n;
        if(a>b) swap(a,b);
        aa[0][i]=a,aa[1][i]=b;
    }
    for(re int i=n-1;~i;--i)
    {
        memset(vis,0,sizeof(vis));
        if(dfs(i)) ++ans;
    }
    if(ans<n) return puts("No Answer"),0;
    for(re int i=0;i<n;++i) printf("%d ",to[i]);
    return 0;
}
```

---

## 作者：Rose_max (赞：25)

怎么个个都是$n^2$的做法..
我来写个$O(n)$的

显然一个位置最对只能和两个点匹配，那我们把这两个点连起来

然后我们可以发现，如果这不是一个基环森林那他就凉凉噜

因为这样的话会有某些点是孤立点或者出现了树之类的然后就gg了

然后又可以发现，如果给这个环定向了之后，那么这棵树上的每个点选择谁是固定的

定向就代表假如你选择了x->y，那么这条边代表的位置就选择了y这个点匹配
否则就是x这个点

那暴力定向一下再暴力check…

如果你用基数排序那么就是$O(n)$的了

所以这题其实完全 完全可以出到$n=1000000$的..

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<queue>
#include<vector>
#include<ctime>
#include<map>
#include<bitset>
#include<set>
#define LL long long
#define mp(x,y) make_pair(x,y)
#define pll pair<long long,long long>
#define pii pair<int,int>
using namespace std;
inline int read()
{
	int f=1,x=0;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int stack[20];
inline void write(LL x)
{
	if(x<0){putchar('-');x=-x;}
    if(!x){putchar('0');return;}
    int top=0;
    while(x)stack[++top]=x%10,x/=10;
    while(top)putchar(stack[top--]+'0');
}
inline void pr1(int x){write(x);putchar(' ');}
inline void pr2(LL x){write(x);putchar('\n');}
const int MAXN=10005;
struct edge{int x,y,op,next;}a[2*MAXN];int len,last[MAXN];
void ins(int x,int y,int op){len++;a[len].x=x;a[len].y=y;a[len].op=op;a[len].next=last[x];last[x]=len;}

int rt[MAXN],num[MAXN],S[MAXN],T[MAXN],g[MAXN],n;
int findrt(int x){return rt[x]==x?rt[x]:rt[x]=findrt(rt[x]);}

int ans[MAXN];
struct node
{
	int x,u;
	node(){}
	node(int _x,int _u){x=_x;u=_u;}
}w1[MAXN],w2[MAXN];int tot;
bool cmp(node n1,node n2){return n1.x<n2.x;}
int vis[MAXN],tim;
void dfs(int x,int fa,int o)
{
	for(int k=last[x];k;k=a[k].next)
	{
		int y=a[k].y;
		if(y!=fa&&vis[y]!=tim)
		{
			vis[y]=tim;
			if(!o)w1[++tot]=node(a[k].op,y);
			else w2[++tot]=node(a[k].op,y);
			dfs(y,x,o);
		}
	}
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)rt[i]=i;
	for(int i=1;i<=n;i++)
	{
		int gg=read();
		int u=i-gg;if(u<=0)u+=n;
		int v=i+gg;if(v>n)v-=n;
		int p=findrt(u),q=findrt(v);
		if(p!=q)ins(u,v,i),ins(v,u,i),rt[p]=q,num[q]+=num[p],S[q]=max(S[q],S[p]),T[q]=max(T[q],T[p]),g[q]=max(g[q],g[p]);
		else
		{
			if(num[p])return puts("No Answer"),0;
			num[p]++;
			S[p]=u;T[p]=v;g[q]=i;
		}
	}
	for(int i=1;i<=n;i++)if(findrt(i)==i)
	{
		tim++;w1[tot=1]=node(g[i],S[i]);
		dfs(S[i],0,0);
		tim++;w2[tot=1]=node(g[i],T[i]);
		dfs(T[i],0,1);
		sort(w1+1,w1+1+tot,cmp);sort(w2+1,w2+1+tot,cmp);
		bool tf=false;
		for(int j=1;j<=tot;j++)
		{
			if(w1[j].u<w2[j].u){tf=true;break;}
			if(w1[j].u>w2[j].u)break;
		}
		if(tf)for(int j=1;j<=tot;j++)ans[w1[j].x]=w1[j].u-1;
		else for(int j=1;j<=tot;j++)ans[w2[j].x]=w2[j].u-1;
	}
	for(int i=1;i<n;i++)pr1(ans[i]);
	pr2(ans[n]);
	return 0;
}

```

---

## 作者：panda_2134 (赞：10)

感觉楼下的题解都没有说清楚为什么QAQ


----------------


## 思路

这个题目可以看出你真正理解了匈牙利算法没有。


首先我们可以建立二分图的模型：每个位置可以有2种取值，于是我们把位置作为左边的点，取值作为右边的点。然后进行二分图匹配，只要有完美匹配，完美匹配就是一个可行解。


再考虑题面中最优性的要求。对于字典序问题，我们常常按照字典序枚举。于是这里也可以枚举：从上往下枚举左边的点，按照字典序枚举和右边的哪个点匹配，再看除开匹配了的两个点剩下的那个图中有没有完美匹配。举个例子：不妨设左边的点$u_i$和右边的点$v_i,v_i'$连了边。首先尝试匹配$(u_i, v_i)$。在除开了这条边以及这条边之前以及匹配的子图后，看剩下的图有无完美匹配。如果有，就选定$(u_i,v_i)$，否则尝试选定$(u_i, v_i')$。如果$(u_i, v_i')$还不行的话就说明无解。

由于枚举左边的点是$O(n)$的，匈牙利算法是$O(nm)=O(n^2)$的（边数是$O(n)$的），这个方法复杂度是$O(n^3)$的，有些高。


这时就要追寻匈牙利算法的本质了。不妨设左边点集为X，右边的为Y，那么匈牙利算法是后面的X点把Y点以前匹配的X点“挤掉”的过程，因为每次从某个X点$u$开始增广，都会试着让`mat[v] = u`。如果我们让字典序小的“挤掉”字典序大的，不就刚刚好可以满足题意了么？我们把邻接表按照字典序排序，每次再倒着扫描，并且增广即可。复杂度为$O(n^2)$，但是上界比较松，可以通过。


## 代码

```cpp
#include <bits/stdc++.h>
using namespace std; 

const int MAXN = 20000, MAXM = 4e4, INF = 0x3f3f3f3f;

int n, match_cnt, e_ptr, vis[MAXN+10], mat[MAXN+10];

vector<int> G[MAXN+10];

inline void AddPair(int u, int v){ 
    G[u].push_back(v); G[v].push_back(u);
}

bool augment(int u) {
    for(int i=0; i<G[u].size(); i++) {
        int v = G[u][i];
        if(vis[v] == match_cnt) continue;
        vis[v] = match_cnt;
        if(mat[v] == -1 || augment(mat[v])) {
            mat[v] = u; 
            return true;
        }
    }
    return false;
}

int Hungary() {
    memset(mat, 0xff, sizeof(mat));
    int ret = 0;
    for(int u=n-1; u>=0; u--) { //!!
        ++match_cnt;
        if(augment(u)) ++ret;
    }
    return ret;
}

template<typename T>
inline void readint(T& x) {
    T f=1, r=0; char c=getchar();
    while(!isdigit(c)) { if(c=='-')f=-1; c=getchar(); }
    while(isdigit(c)) { r=r*10+c-'0'; c=getchar(); }
    x = f*r;
}

int main() {
    int d, a, b, Ans;
    readint(n);
    for(int i=0; i<n; i++) {
        readint(d);
        a = (i-d+n)%n;
        b = (i+d)%n;
        AddPair(i, a+n);
        AddPair(i, b+n);
    }
    for(int i=0; i<2*n; i++)
        sort(G[i].begin(), G[i].end());
    Ans = Hungary();
    if(Ans != n) puts("No Answer");
    else {
        for(int i=0; i<n; i++)
            mat[mat[i+n]]=i;
        for(int i=0; i<n; i++) {
            printf("%d", mat[i]);
            if(i!=n-1) putchar(' '); 
        }
    }
    return 0;
}
/*
附赠数据一组：
16
4 5 6 8 5 3 4 6 7 7 4 6 7 4 7 3 
*/ 
```


参考：[Byvoid神犇的Blog][1]（%%%%%%%）


[1]: https://www.byvoid.com/zhs/blog/noi-2009-transform


---

## 作者：Dirt、 (赞：5)

对于每个位置 $i$ ，知道 $D(i,T_i)$ 后，可以得到所有可能的 $T_i$ 的取值：

当 $ \mid i - T_i \mid \le N - \mid i - T_i \mid $ 时， $ T_i = i - D $ 或 $ T_i = i + D $ 。

当 $ \mid i - T_i \mid > N - \mid i - T_i \mid $ 时，$ T_i = i-D+N $ 或 $ T_i = N-D+i $ 。

每个 $i$ 最终只可能与一个 $T_i$ 对应，且 $i \in [0,n)$ ， $ T_i \in [0,n) $ ，

~~根据标签~~不难想到这是一个二分图最大匹配。

对于每个 $i$ ，向可行的 $T_i$ 连边跑匈牙利即可得出一组可行的解。

当最大匹配数小于 $n$ 时，显然无解。

现在要考虑的是求出一组字典序最小的解。

我们可以将每个点的出边从小到大排序，然后从 $n-1$ 到 $0$ 匹配，并记录方案。

可能并不严谨的正确性证明：

在匈牙利算法中，当点 $i$ 当前尝试匹配的点 $j$ 已被点 $k$ 匹配时，会尝试重新匹配点 $k$ 。

因为边从小到大排序，匹配时一定优先选小的点。

如果该点已被匹配，那么一定是被比当前点大的点匹配。

根据字典序的定义，小的点在前面一定更优。

所以这样的策略能够保证字典序最小。

注意连边时判断是否在范围内。

~~话说 $n \le 10000$ 也能 $O(n^2)$ 过的么~~

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
int n;
vector<int> e[10003];
int f[10003],s[10003];
bool v[10003];
int ans;
void add(int u,int v)
{
	e[u].push_back(v);
}
bool dfs(int x)
{
	for(int i=0;i<e[x].size();i++)
	{
		int to=e[x][i];
		if(v[to]) continue;
		v[to]=true;
		if(f[to]==-1||dfs(f[to]))
		{
			f[to]=x;
			s[x]=to;
			return true;
		}
	}
	return false;
}
int main()
{
	scanf("%d",&n);
	for(int i=0;i<n;i++)
	{
		int d;
		scanf("%d",&d);
		if(i-d>=0) add(i,i-d);
		if(i+d<n) add(i,i+d);
		if(i+d-n>=0) add(i,i+d-n);
		if(n-d+i<n) add(i,n-d+i);
	}
	for(int i=0;i<n;i++)
		sort(e[i].begin(),e[i].end());
	memset(f,-1,sizeof(f));
	for(int i=n-1;i>=0;i--)
	{
		memset(v,0,sizeof(v));
		if(dfs(i)) ans++;
	}
	if(ans!=n)
	{
		puts("No Answer");
		return 0;
	}
	for(int i=0;i<n;i++)
		printf("%d ",s[i]);
	return 0;
}
```

---

## 作者：Register_int (赞：4)

这是一个本题的线性做法。  
前面的转化过程直接跳过，来到二分图部分。我们可以发现这是个特殊的二分图，每个点最多只能跟两个点匹配。我们将每个点所连边的两个点连接，就可以得到树/基环树森林。之后考虑匹配过程，如果该连通块是一棵树，那么 $n-1$ 条边匹配 $n$ 个点，必然不能完全匹配，输出 `No Answer`。否则，选择环上一条边，分别判断匹配这条边的左端点还是右端点（这一点确定了后所有匹配都确定了），选择字典序较小的一种更新。最后输出即可。  
# AC 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 2e5 + 10;

struct edge {
	int v, id, nxt;
} e[MAXN << 1];

int head[MAXN], tot;

inline 
void add(int u, int v, int id) {
	e[++tot] = { v, id, head[u] }, head[u] = tot;
}

struct node {
	int u, v, id;
	bool operator < (const node &rhs) const { return id < rhs.id; }
} a[MAXN], b[MAXN];

bool vis[MAXN], used[MAXN], allow[MAXN];

int num, acnt, bcnt;

void dfs(int u) {
	vis[u] = 1, num++;
	for (int i = head[u]; i; i = e[i].nxt) {
		if (u <= e[i].v) a[++acnt] = { u, e[i].v, e[i].id };
		if (!vis[e[i].v]) dfs(e[i].v);
	}
}

void pick(int u, int f, int *res) {
	for (int i = head[u]; i; i = e[i].nxt) {
		if (e[i].v == f || !allow[e[i].id]) continue;
		res[e[i].id] = e[i].v, pick(e[i].v, u, res);
	}
}

int fa[MAXN];

int find(int k) {
	return k == fa[k] ? k : fa[k] = find(fa[k]);
}

int ans[MAXN], t[MAXN];

bool solve(int n) {
	acnt = bcnt = num = 0, dfs(n);
	sort(a + 1, a + acnt + 1);
	if (acnt == num - 1) return 0;
	bool f = 0; int p = -1;
	for (int i = acnt, x, y; i; i--) {
		x = find(a[i].u), y = find(a[i].v);
		if (x == y) {
			if (f) continue;
			b[++bcnt] = a[i], p = bcnt, f = 1;
			continue;
		}
		b[++bcnt] = a[i], allow[a[i].id] = 1, fa[x] = y;
	}
	ans[b[p].id] = b[p].u, pick(b[p].u, 0, ans);
	t[b[p].id] = b[p].v, pick(b[p].v, 0, t);
	for (int i = bcnt; i; i--) {
		if (ans[b[i].id] > t[b[i].id]) {
			for (int j = i; j; j--) ans[b[i].id] = t[b[i].id]; break;
		} else if (ans[b[i].id] < t[b[i].id]) break;
	}
	return 1;
}

int n;

int main() {
	scanf("%d", &n);
	for (int i = 0, x, u, v; i < n; i++) {
		scanf("%d", &x), u = (i - x + n) % n + 1, v = (i + x) % n + 1;
		add(u, v, i + 1), add(v, u, i + 1);
	}
	for (int i = 1; i <= n; i++) fa[i] = i;
	for (int i = 1; i <= n; i++) {
		if (!vis[i] && !solve(i)) return puts("No Answer"), 0;
	}
	for (int i = 1; i <= n; i++) printf("%d ", ans[i] - 1);
}
```

---

## 作者：zijinjun (赞：4)

这道题，首先我们先看一下题目，考场上遇到时候，第一反应是用搜索，于是。。。打了个搜索。。。然后完美的由于复杂度爆了。。（搜索应该三十分，但我的复杂度感人只有~~十分~~ ）

搜索就不多说，直接讲一下正解，正解是用二分图匹配。
每个元素可以和另外两个元素对应，两个集合相互可以链接，集合内部没有联系，这就形成了一个很好的二分图匹配，二分图的匹配如果不知道的话emmmm。。。。https://blog.csdn.net/dark_scope/article/details/8880547 大佬讲解的匈牙利算法
知道了这是二分图，那么就有了一个大致思路，但是，字典序该如何维护呢，我们考虑匈牙利算法的原理，能连则连（这是一种贪心的思想）那么后面连上的会找到最小的可以连上的~~对象~~，所以，我们只需要反向搜，就可以找到最小字典序了 

```cpp
#include<iostream>
#include<cstdio>
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define FR(i,a,b) for(int i=a;i>=b;i--)
using namespace std;
const int N=100100;
int n,v,d[N],vi[N],to[N],lk[N],s[N][2];
bool hun(int u){
	FOR(i,0,1)if(!vi[s[u][i]]){
		int v=s[u][i];vi[v]=1;
		if(lk[v]==-1 || hun(lk[v])) {lk[v]=u;to[u]=v;return 1;}
	}return 0;
}
int main(){
	scanf("%d",&n);
	FOR(i,0,n-1) scanf("%d",&d[i]);
	FOR(i,0,n-1){
		s[i][0]=(i+d[i]+n)%n;s[i][1]=(i-d[i]+n)%n;
		if(s[i][0]>s[i][1]) swap(s[i][0],s[i][1]);
		lk[i]=to[i]=-1;
	}
	FR(i,n-1,0){
		FOR(j,0,n-1) vi[j]=0;
		if(!hun(i)) {printf("No Answer");return 0;}
	}
	FOR(i,0,n-1) printf("%d ",to[i]);
}
```


---

## 作者：封禁用户 (赞：3)

# 题目大意
给定 $ D_i $,让我们还原字典序最小的 $ T_i $。

### 前置
$ D_i = \lvert T_i  - i\rvert$

稍微移项，得到 $ T_i = D_i \pm i  $。
# 分析
首先，我们先不管字典序最小。

对于每一个 $ T_i \bmod 2$ 的值，最多只有两个。每次在两个之间选择，这不就是 **二分图** 的逻辑吗？

那加入字典序最小的这一个条件呢？

如果使用网络流，肯定做不到字典序最小，所以我们想到匈牙利算法。（不会此算法的看[这一题](https://www.luogu.com.cn/problem/P3386)）

#### 在此简单介绍匈牙利算法：

在一幅图中，上面有 n 个点，下面有 m 个点。
 
$i$ 是 $1 ∼ n$ 枚举到的点， $j$ 是 $1 ∼ m$ 枚举到的点。

如果 $i$ 和 $j$ 之间没有连线，我们就连接这两点。

否则，如果这个点已经被连接，且 $j$ 点所连接的另外一个点可以连接另一个点，我们就可以换掉这个点，连接 $i$, $j$。

此算法的代码：
```cpp
bool find(int x){//二分图最大匹配
	for(int i = 1;i <= m;i++){
		if(vis[a[i][x]])continue;//已经访问过了
		vis[a[i][x]] = 1;//更改为访问过了
		if(d[a[i][x]] == -1 || find(d[a[i][x]])){//如果还没有连边或者这个点可以连接其他边
			d[a[i][x]] = x;//直接连接
			ans[x] = a[i][x];//加入答案
			return true;//返回可以连接	
		}
	}
	return false;//不可以连接
}
```

知道了思路，怎么实现字典序最小呢？如果第一个点连接了字典序最小的点，最后答案是字典序最小的吗？

**不可能！**

因为第一个点连接了字典序最小的点，后面的点有可能会将第一个点更换这一条边，所以，这种思路是不行的。

根据这一个思路，我们会知道：某个点如果已经连接了字典序最小的点，那么后面就可能会有一个点来更换这一条边。

因此，我们可以**逆向思维**，从 $n$ 到 $1$ 开始枚举，这样就能达到字典序最小这一个条件

## 时间复杂度
匈牙利算法的时间复杂度一般是 $ O(n \times m) = O(n^2) $，所以对于本题数据还是勉强能过得

# AC代码
```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstdio>
#include<cstring>
using namespace std;
typedef long long LL;
const int MAXN = 1e5 + 10; 
const int INF = 0x3f;
int a[3][MAXN], n;//本题数据小，可以使用邻接矩阵来储存边 
int d[MAXN], vis[MAXN], ans[MAXN];
//  连接的点 是否连接   答案 
bool find(int x){//二分图最大匹配
	for(int i = 1;i <= 2;i++){
		if(vis[a[i][x]])continue;//已经访问过了
		vis[a[i][x]] = 1;//更改为访问过了
		if(d[a[i][x]] == -1 || find(d[a[i][x]])){//如果还没有连边或者这个点可以连接其他边
			d[a[i][x]] = x;//直接连接
			ans[x] = a[i][x];//加入答案
			return true;//返回可以连接	
		}
	}
	return false;//不可以连接
}
int main()
{
	cin >> n;
	memset(d, -1, sizeof(d));//赋值为全部没有连接 
	for(int i = 1;i <= n; i++){
		int x;
		cin >> x;	
		int A = (i - x + n) % n;//一个点到另一个点有两个位置：左边或右边 
		int B = (i + x) % n;
		if(A > B) swap(A, B);//如果左边距离 > 右边距离，交换 
		a[1][i] = A;//1连i的边为A 
		a[2][i] = B;//2连i的边为B 
	}
	int sum = 0;//统计最多能分配几个顶点 
	for(int i = n;i >= 0; i--){//从后往前枚举 
		memset(vis, false, sizeof(vis));//初始化 
		if(find(i))sum++;//统计 
	}
	if(sum < n)cout << "No Answer";//如果不够个数，就无解 
	else{//输出答案 
		for(int i = 1;i <= n; i++){
			cout << ans[i] << ' ';
		}
	} 
	//cout << sum << endl;
    return 0;
}
```
温馨提示：理解以后再ctj

(管理员辛苦了，麻烦审核一下题解）

---

## 作者：Z1qqurat (赞：2)

首先怎么连边。根据一顿去绝对值，得到 $T_i$ 有 $4$ 种取值：$i-D_i$，$i-D_i+n$，$i+D_i$，$i+D_i-n$。然后这四种满足 $[1,n]$ 的取值只有最多两个，所以我们借鉴超级英雄那题的建模，以位置 $i$ 为左部点，如果 $T_i$ 的取值可以为 $j$，$i$ 向 $j$ 连边。也就是说，$T$ 可以的取值 $[1,n]$ 为右部点。

接着跑最大匹配。问题来了，怎么保证字典序最小？字典序小，就是要保证越靠前的位置越小，那么肯定最优，于是我们改变跑的顺序，先确定靠后的位置，再向前跑，这样子靠前的位置就可以自由地匹配到更小的 $T$ 值。而且 $G_i$ 需要排个序，因为匈牙利是枚举到可以多一个匹配就跳出的，所以我们从编号小的开始试着匹配会更优。

还有，这题下标从 $0$ 开始，所以我们最后输出答案的时候要集体减 $1$。不仅要维护一个 $match_v$，还需要一个 $dy_u$，可以更方便地输出答案。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 1e4 + 5;
int n, match[N], vis[N], dy[N];
vector <int> G[N];

bool hungary(int u, int col) {
	for (int v : G[u]) {
		if(vis[v] == col) continue;
		vis[v] = col;
		if(!match[v] || hungary(match[v], col)) return match[v] = u, dy[u] = v, 1;
	}
	return 0;
}

int main() {
	scanf("%d", &n);
	//0-index,0-index,0-index
	for (int i = 1; i <= n; ++i) {
		int d; scanf("%d", &d);
		if(i - d >= 1) G[i].emplace_back(i - d);
		if(i - d + n <= n) G[i].emplace_back(i - d + n);
		if(i + d <= n) G[i].emplace_back(i + d);
		if(i + d - n >= 1) G[i].emplace_back(i + d - n);
		if(!G[i].empty()) sort(G[i].begin(), G[i].end()); 
	}
	int ans = 0;
	for (int i = n; i >= 1; --i) ans += hungary(i, i);
    // cout << ans << "\n";
	if(ans != n) return puts("No Answer"), 0;
	for (int i = 1; i <= n; ++i) printf("%d ", dy[i] - 1);
	return 0;
}
```

---

## 作者：Imakf (赞：2)

做此题前推荐另一道题，思路有那么一点点关系：[[SCOI2010]连续攻击游戏](https://www.luogu.com.cn/problem/P1640)。

### 题面转化

首先对于每一个位置 $i$，都能算出放在此位置上的 $1$ 或 $2$ 个数是什么，将这两个数连边（一个数则连自环），这条边的编号就是 $i$，每个点的**点权就是点的编号**。

问题即可转化为：把每个点的**点权放到一条邻边上**，使得每条边有且仅有一个边权，设边权数组为 $w$，**最小化此数组的字典序**。

### 无解

显然一共 $n$ 个点，$n$ 条边，图不一定联通。我们来看什么时候无解：

对于一个极大连通子图，如果它是一棵树，边的数量 = 点数量 - 1。必将有一个点的点权无法赋值给边，那就会有一条边没有边权，此时 ```No Answer```。

### 有解

显然，去掉了树的情况，图必然是**基环树森林**，即若干个分离的基环树。

一个基环树只有两个部分：**环部分**和**树部分**。

经过一番思考，发现**树部分有且仅有一种赋值边权的方法。** 即自叶子向树根（环）赋值。于是**树部分**可以直接得出答案，消去不管。

图中只剩下**环部分**，对于一个环，只有两种赋值方法。我们找到边编号最小的那条边，因为它编号靠前，对字典序影响更大。此条边一定只连接了两个点，选择两个点中较小者，把点权赋值给此边即可。由于确定了一条边，整个环就已经确定完成了。

找环我居然用的 tarjan，另：需要**特判自环**。
```cpp
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <iostream>
#include <cassert>
using namespace std; 
#define rg register
#define il inline
#define MX (10000 + 233)

int head[MX] ,tot = 1 ,tot2 = 1;
struct edge{
	int fr ,node ,next ,id;
	bool operator <(const edge& b)const{
		return id < b.id;
	}
}h[MX << 1] ,H[MX << 1];
void addedge(int u ,int v ,int id ,int flg = true){
	h[++tot].next = head[u];
	head[u] = tot ,h[tot].node = v;
	h[tot].id = id ,h[tot].fr = u;
	if(flg) addedge(v ,u ,id ,false);
}

void addedge2(int u ,int v ,int id ,int flg = true){
	H[++tot2].next = head[u];
	H[tot2].node = v ,H[tot2].id = id;
	H[tot2].fr = u;
	if(flg) addedge2(v ,u ,id ,false);
}

int OnCycle[MX];
int DFN[MX] ,low[MX] ,flg[MX] ,stk[MX] ,dep ,cnt;
int Ecnt ,Vcnt;
void tarjan(int x ,int last){
	++Vcnt;
	DFN[x] = low[x] = ++cnt;
	flg[x] = true ,stk[++dep] = x;
	for(int i = head[x] ,d ; i ; i = h[i].next){
		++Ecnt;
		if(i == (last ^ 1)) continue;
		if(!DFN[d = h[i].node]){
			tarjan(d ,i);
			if(low[d] < low[x]) low[x] = low[d];
		}else if(flg[d] && DFN[d] < low[x]) low[x] = DFN[d];
	}int j = -1; if(DFN[x] == low[x]){
		int tag = (stk[dep] != x);
		while(j != x){
			j = stk[dep--] ,OnCycle[j] |= tag;
			flg[j] = false;
		}
	}
}

int vis[MX] ,Ans[MX];
void dfs(int x){
	for(int i = head[x] ,d ; i ; i = h[i].next){
		if(!vis[d = h[i].node] && !OnCycle[d]){
			vis[d] = true;
			Ans[h[i].id] = d;
			dfs(d);
		}
	}
}

void dfs1(int x ,int fr){
	
	if(vis[x]) return; 
	vis[x] = true;
	for(int i = head[x] ,d ; i ; i = h[i].next){
		if(OnCycle[d = h[i].node] && i != (fr ^ 1)){
			Ans[h[i].id] = x;
			dfs1(d ,i);
		}
	}
}

int getedge(int u ,int v ,int id){
	for(int i = head[u] ; i ; i = h[i].next){
		if(h[i].node == v && h[i].id == id) return i;
	}assert(false);
}

int main(){
	memset(Ans ,-1 ,sizeof Ans);
	int n; cin >> n;
	for(int i = 0 ,d ; i < n ; ++i){
		cin >> d;
		if(d * 2 == n || d == 0) OnCycle[(i + d) % n] = true;
		if(d > (n / 2))	return 0 * puts("No Answer");
		addedge((i + n - d) % n ,(i + d) % n ,i);
		addedge2((i + n - d) % n ,(i + d) % n ,i);
		// printf("%d %d %d\n" ,(i + n - d) % n ,(i + d) % n ,i);
	}
	for(int i = 0 ; i < n ; ++i){
		if(!DFN[i]){
			Ecnt = Vcnt = 0;
			tarjan(i ,1145141919);
			if(Ecnt != Vcnt * 2){
				puts("No Answer");
				return 0;
			}
		}
	}
	for(int i = 0 ; i < n ; ++i){
		if(!OnCycle[i]) continue;
		dfs(i);
	}std::sort(H + 2 , H + tot2 + 1);
	for(int i = 2 ,u ,v ; i <= tot ; ++i){
		u = H[i].fr ,v = H[i].node;
		if(!vis[u] && !vis[v]){
			if(u < v){
				Ans[H[i].id] = u;
				vis[u] = true;
				int fr = getedge(u ,v ,H[i].id);
				dfs1(v ,fr);
			}
			else{
				Ans[H[i].id] = v;
				vis[v] = true;
				int fr = getedge(v ,u ,H[i].id);
				dfs1(u ,fr);
			}
		}
	}
	for(int i = 0 ; i < n ; ++i)
		printf("%d " ,Ans[i]);
	return 0;
}
```

---

## 作者：Kelvin2009 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P1963)

二分图入门，这是道好题。

$\operatorname{D}(x,y)=\min(\left\vert x-y\right\vert,N-\left\vert x-y\right\vert)$ 这句话的意思是每个 $i$ 对应的 $T_{i}$ 只可能有两个。

若结果不是 "No Answer" ，那这种情况就相当于完全匹配，自然容易想到匈牙利算法。

存储时每个 $i$ 与 $(i-d+n)\bmod n$ 和 $(i+d)\bmod n$ 相连（依据 $\operatorname{D}(x,y)$ 的定义）。

因为题目要求 $T$ 数组字典序最小，所以我们可以考虑逆向思维，后面的点先选字典序小的，如果前面的点需要就再给出去。

**有一点注意：由于 $T$ 是 $0\sim n-1$，for 循环内最好是从 $0$ 开始，否则处理及其麻烦。**

------------
代码如下：

------------

```cpp
#include<bits/stdc++.h>
using namespace std;
const int range=1e4+5;
int n,d,num1,num2,record,vis[2][range],solve[range],match[range],aray[range];
bool matching(int u)
{
	for(int i=0;i<2;i++)
	{
		int v=vis[i][u];
		if(solve[v]) continue;
		solve[v]=1;
		if(match[v]==-1 || matching(match[v]))
		{
			match[v]=u;
			aray[u]=v;
			return true;
		}
	}
	return false;
}
void hungary()
{
	for(int i=n-1;i>-1;i--)
	{
		memset(solve,0,sizeof(solve));
		if(matching(i)) record++;
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=0;i<n;i++)
	{
		scanf("%d",&d);
		num1=(i-d+n)%n,num2=(i+d)%n;
		if(num1>num2) swap(num1,num2);
		vis[0][i]=num1,vis[1][i]=num2;
	}
	memset(match,-1,sizeof(match));
	hungary();
	if(record<n)
	{
		printf("No Answer");
		return 0;
	}
	for(int i=0;i<n;i++) printf("%d ",aray[i]);
	return 0;
}
```

---

## 作者：cww970329 (赞：1)



观察上面几份题解主要着重于匈牙利的内部原理

这里补充一下建图的细节把。


题中:

$$D(i, T_i) = min(|i - T_i|, N - |i - T_i|)$$

构造二分图：左边为原序列，右边为满足上式的可能的数字

上面的一个式子可以拆成四个方程

$$ D(i, T_i)=\left\{
\begin{aligned}
\pm (i - T_i) \\
n \pm (i - T_i)\\
\end{aligned}
\right.
$$

![](https://cdn.luogu.com.cn/upload/pic/54882.png)

解该方程：

$$ T_i=\left\{
\begin{aligned}
i \pm D(i - T_i) \\
i \pm (n - D(i - T_i))\\
\end{aligned}
\right.
$$

![](https://cdn.luogu.com.cn/upload/pic/54883.png)

若 $T_i \in [0, n)$ ，则属于合法解。

二分图建出来，剩下的求最大匹配反而变得简单

至于字典序最小，因为（我的）匈牙利默认是可以增广立马就增广的，所以默认的似乎是字典序最大。

idea: 反正要腾，不如整体顺序倒过来，优先腾的是最小的，保证字典序最小

于是乎建完边后`sort()`一发，匈牙利里面`for`循环倒过来就好了

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1e4 + 7;
const int INF = 0x3f3f3f3f;
struct Hungary{
    vector <int> G[N];
    bool used[N]; // main里面记得memset
    int girl[N], n, boy[N];

    inline void init(int _n){
        n = _n;
        for (int i = 0; i <= n; i++) G[i].clear();
    }

    inline void addEdge(const int &u, const int &v){
        G[u].push_back(v);
    }

    bool Find(int x){
        for (int i = 0; i < G[x].size(); i++){
            int j = G[x][i];
            if (used[j]) continue;
            used[j] = 1;
            if (girl[j] == -1 || Find(girl[j])) {
                girl[j] = x;
                boy[x] = j;
                return true;
            }
        }
        return false;
    }

    inline int hungary(const int &n, const int &m){
        int all = 0;
        memset(girl, -1, sizeof girl);
        for (int i = n-1; i >= 0; i--) {
            memset(used, 0, sizeof(used)); //这个在每一步中清空
            if (Find(i)) all += 1;
        }
        //for (int i = 0; i < m; i++) printf("girl[%d] = %d\n", i, girl[i]);
        //printf("all = %d\n", all);
        return all;
    }
} g;

int n;
int dist[N];

bool in_range(const int &x){
    return 0 <= x && x < n;
}

int main(){
    //freopen("in.txt", "r", stdin);
    scanf("%d", &n);
    g.init(n);
    for (int i = 0; i < n; i++){
        scanf("%d", &dist[i]);
        if (in_range(i - dist[i])) g.addEdge(i, i - dist[i]);
        if (in_range(i + dist[i])) g.addEdge(i, i + dist[i]);
        if (in_range(i-n+dist[i])) g.addEdge(i, i-n+dist[i]);
        if (in_range(i+n-dist[i])) g.addEdge(i, i+n-dist[i]);
        sort(g.G[i].begin(), g.G[i].end());
    }

    if (g.hungary(n, n) != n) puts("No Answer");
    else{
        for (int i = 0; i < n; i++){
            printf("%d%c", g.boy[i], i==n-1?'\n':' ');
        }
    }
    return 0;
}

// dist[i] = i - transfer[i]
// dist[i] = transfer[i] - i
// dist[i] = n - i + transfer[i]
// dist[i] = n + i - transfer[i]

```

PS：公式炸了，编辑器内的公式渲染的很正常啊，前端修一下bug啊，markdown渲染用pandoc引擎亲测什么神仙公式都能渲染



---

## 作者：IAMJOBS (赞：1)


二分图最大匹配

针对每一个D[i]算出数位上可能的2个T[i],然后将数位的数字与两个T[i]连边,再求最大匹配即可，如果最大匹配小于n,则'No Answer'

对于按字典序最小输出解，应当倒过来扫点。为什么这样呢，因为这样就可以保证最前面的点具有最高的优先级.

```cpp
bool work()
{
    memset(linker,-1,sizeof linker);
    for(int i=n-1;i>=0;i--)
    {
        memset(vis,0,sizeof vis);
        if(!dfs(i))
        {
            return false;
        }
    }
    return true;
} 
```
细节注意见注释O(∩\_∩)O~~






```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;
const int MAXN=10000;
int n,G[MAXN+10][2],vis[MAXN+10],linker[MAXN+10],rlinker[MAXN+10];
bool dfs(int x)
{
    for(int i=0;i<=1;i++)//应当先考虑边所对应的另一个点较小的
    {
        if(!vis[G[x][i]])
        {
            vis[G[x][i]]=true;
            if(linker[G[x][i]]==-1||dfs(linker[G[x][i]]))
            {
                linker[G[x][i]]=x;
                rlinker[x]=G[x][i];
                return true;
            }
        }
    }
    return false;
}
bool work()
{
    memset(linker,-1,sizeof linker);
    for(int i=n-1;i>=0;i--)//倒过来扫
    {
        memset(vis,0,sizeof vis);
        if(!dfs(i))
        {
            return false;
        }
    }
    return true;
} 
int main()
{
    scanf("%d",&n);
    int k,a,b;
    for(int i=0;i<n;i++)
    {
        scanf("%d",&k);
        a=(i-k+n)%n;
        b=(i+k)%n;
        G[i][0]=min(a,b);
        G[i][1]=max(a,b);
    }
    if(!work())
    {
        printf("No Answer");
        return 0;
    }
    for(int i=0;i<n;i++)
    {
        printf("%d ",rlinker[i]);
    }
    return 0;
}
```

---

## 作者：ModestCoder_ (赞：1)

对于每个位置，可以得到两个备选数字

从当前点向两个备选连边

跑二分图匹配即可

接下来解决字典序最小问题，根据匈牙利算法的特点，后面遍历到的会把前面的给顶掉，那么不妨倒着做二分图匹配，可以满足

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 10010
using namespace std;
struct Edge{
	int to, next;
}edge[maxn << 2];
int num, head[maxn], n, vis[maxn], link[maxn], ans, print[maxn];

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

void addedge(int x, int y){ edge[++num] = (Edge){y, head[x]}, head[x] = num; }

int dfs(int u){
	if (vis[u]) return 0;
	vis[u] = 1;
	for (int i = head[u]; i; i = edge[i].next){
		int v = edge[i].to;
		if (!link[v] || dfs(link[v])){
			link[v] = u; return 1;
		}
	}
	return 0;
}

int main(){
	n = read();
	for (int i = 1; i <= n; ++i){
		int x = read();
		int y = (i - 1 + x) % n, z = (i - 1 - x + n) % n;
		addedge(i - 1, max(y, z)), addedge(i - 1, min(y, z));
	}
	for (int i = n - 1; i >= 0; --i){
		for (int j = 0; j < n; ++j) vis[j] = 0;
		ans += dfs(i);
	}
	if (ans == n){
		for (int i = 0; i < n; ++i) print[link[i]] = i;
		for (int i = 0; i < n; ++i) printf("%d ", print[i]);
	} else puts("No Answer");
	return 0;
}
```


---

## 作者：Yanami_Anna (赞：0)

距离确定了之后，一个点把绝对值拆开只有两个点可以走，然后你发现把所谓“走一个点”的过程变成匹配排列的过程，那么这个问题的可行性判断就是有没有完美匹配了。

有完美匹配还要求字典序最小，实际上这是一个很厉害的贪心，就是我们倒过来枚举节点，尽量让前面的点匹配到 $match$ 更小的点，然后字典序就会更小。

当然这只是感性证明。

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> ljb[20005];
bool vis[20005];
int match[20005];
int n;
int dis[10005];
int tot;
bool dfs(int cur){
   for(int i=0;i<ljb[cur].size();i++){
      int v=ljb[cur][i];
      if(vis[v])continue;
      vis[v]=true;
      if(!match[v]||dfs(match[v])){
         match[v]=cur;
         return true;
      }
   }
   return false;
}
struct node{
   int mat,id;
   bool friend operator < (const node &a,const node &b){
      return a.mat<b.mat;
   }
}T[20005];
int main(){
   scanf("%d",&n);
   for(int i=1;i<=n;i++){
      scanf("%d",&dis[i]);
      int v=i+dis[i];
      v=(v-1)%n+1;
      ljb[i].push_back(v+n);
      v=i-dis[i];
      v=(v+n-1)%n+1;
      ljb[i].push_back(v+n);
      if(ljb[i][0]>ljb[i][1]){
         swap(ljb[i][0],ljb[i][1]);
      }
   }
   for(int i=n;i>=1;i--){
      for(int j=n+1;j<=2*n;j++){
         vis[j]=false;
      }
      if(dfs(i)){
         tot++;
      }
   }
   if(tot<n){
      puts("No Answer");
      return 0;
   }
   else{
      for(int i=n+1;i<=2*n;i++){
         T[i].id=i;
         T[i].mat=match[i];
      }
      sort(T+n+1,T+n+1+n);
      for(int i=n+1;i<=2*n;i++){
         printf("%d ",T[i].id-n-1);
      }
   }
   return 0;
}
```

---

## 作者：Pwtking (赞：0)

[传送门](https://www.luogu.com.cn/problem/P1963)

主要的算法匈牙利二分图匹配和分类讨论连边大家讲的已经很清楚了，本篇来着重讲一下本题难点：使答案字典序最小。

方案：

- 连边的时候，将每个位置作为左部，每个位置的变换值作为右部。**将左部每个点的连边的右端点大小按升序排序，最后对每个左部点做 dfs 的时候倒序做。**

感性证明：

- 匈牙利的主要流程是：若当前左部将要匹配的点已被匹配，会将这个点的原配匹配到右部点序列中更靠后的点，所以靠后进行匹配的左部点的匹配值的字典序一定会尽量小。那么将右部点升序排列，若进行 dfs 时正序进行，即可求得字典序最大的，反过来，若倒序进行，即可求得字典序最小值。

为什么不能将右部点降序排序之后再正序进行 dfs 呢？

- 此时正序进行 dfs 一定会使得后进行 dfs 的左部点的匹配的字典序更大，但是不能保证先进行 dfs 的左部点的匹配的字典序尽量小。


---

## 作者：szr666 (赞：0)

我这里推荐一下[我的博客](https://www.luogu.org/blog/szr666--blog/)

在博客里观看更美观哦~

[题目](https://www.luogu.org/problemnew/show/P1963)
------------


------------

华丽的分割线
# 解析

### 建图前的准备
题目要求我们根据给出的$i$和$D_i$,去求出合法且字典序最小的$T_i$序列

我们可以通过$i$和$D_i$推出成立的$T_i$,分四种情况讨论,两个绝对值内正负共四种情况

(当然也有题解用取模分为两种情况,但个人感觉不够直观)

注意对不在范围的$T_i$舍去,还有若用$\lvert i-T_i \rvert =D_i$推出的$T_i$,但

$\lvert i-T_i \rvert > N-\lvert i-T_i \rvert$,则不符合取$min$操作,应舍去

### 建图

现在对于每一个位置$i$,都可以选择几个$T_i$,并且选了某个$T_i$则其他位置不能再选

对于$i$与$T_i$间的关系,我们可以想到它们满足二分图的定义,且满足最大匹配的定义

我们可以在$i$与其所能选择的$T_i$连边,(至于方向我们之后讨论)

如果最大匹配为$n$则有解,且通过匹配数组$match$可知道一种合法方案

### 字典序
我们考虑一下匈牙利算法的流程,对左面的点跑搜索,右面的点用$match$数组找到匹配

对于左面的一个点,会优先搜索第一条与它连边的点,若能找到增广路则将它们匹配

否则去找第二条边,以此类推,并且找到增广路时不管增广路上其他点的匹配顺序

字典序的定义为让前面的数尽可能小,所以应从$i$向$T_i$连边,顺序从小到大

因为每次匹配某个点会弄乱之前匹配点的顺序,所以应让小的$i$在搜索顺序中靠后

因为即使为满足当前位最小而弄乱$i$后面的顺序是值得的

如$1 2 5 4 3$和$1 3 2 4 5$,尽管序列一中因使第二个数小而使后面的字典序很大

但在整体上却比为保持第二个数往后字典序小而使第二个数并非最小的序列二更优

如果当前数未能和第一条边的数匹配,那如果匹配则不能使最大匹配为$n$,破坏了合法性

所以在保证在合法的前提下使前面的数尽可能小

### 注意事项
1.如果$T_i$向$i$连边会怎样？

那就变成了使小的数尽可能靠前,看起来和定义没有区别,却坑了我很长时间

反例:

![](https://cdn.luogu.com.cn/upload/pic/75991.png)

其中数字代表位置,字母代表位置上的值

$i$向$T_i$连边：$0-B\  1-C \ 2-A$ $\ \ \ \ \ \ \ \ \ \ \ $ $T_i$向$i$连边：$A-1\  B-2\  C-0$

这是因为匹配当前点会弄乱之前的顺序

可以看一下本蒟蒻与一位大佬的讨论：[传送门](https://www.luogu.org/discuss/show/139622)

2.用链式前向星建图从大到小加边,则访问为从小到大

3.左右两集合点的编号要区分开

# 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=11000;
struct node
{
	int to;
	int next;
};
node e[2*N];
int head[N],ans[N],etot;
void add(int x,int y)
{
	etot++;
	e[etot].to=y;
	e[etot].next=head[x];
	head[x]=etot;
}
void read(int &x)
{
	int f;
	f=1;
	x=0;
	char c;
	c=getchar();
	while((c<'0'||c>'9')&&c!='-')
	{
		c=getchar();
	}
	if(c=='-')
	{
		f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=(x<<3)+(x<<1)+(c^48);
		c=getchar();
	}
	x=x*f;
}
int d[N];
struct node2
{
	int fr;
	int to;
};
node2 e2[10];
int e2tot,vis[2*N],match[2*N];
bool cmp(const node2& x1,const node2& x2)
{
	return x1.fr==x2.fr ? x1.to>x2.to : x1.fr<x2.fr; 
}
bool dfs(int x)
{
	int i,v;
	for(i=head[x];i!=0;i=e[i].next)
	{
		v=e[i].to;
		if(!vis[v])
		{
			vis[v]=1;
			if(!match[v]||dfs(match[v]))
			{	
				match[v]=x;
				ans[x]=v;
				return 1;
			}
		}
	}
	return 0;
}
int main()
{
	int n,i,x,y,z,xx,j;
	read(n);
	for(i=1;i<=n;i++)
	{
		read(d[i]);
	}
	for(i=1;i<=n;i++)
	{
		x=d[i]+(i-1);
		e2tot=0;
		if(x>=0&&x<=n-1&&x-i+1<=n/2&&x>=i-1)
		{
			e2tot++;
			e2[e2tot].fr=i;
			e2[e2tot].to=x+n+1;
		}
		else
		{
			x=-1;
		}
		y=(i-1)-d[i];
		if(y>=0&&y<=n-1&&y!=x&&i-1-y<=n/2&&y<=i-1)
		{
			e2tot++;
			e2[e2tot].fr=i;
			e2[e2tot].to=y+n+1;
		}
		else
		{
			y=-1;
		}
		z=(i-1)+d[i]-n;
		if(z>=0&&z<=n-1&&z!=x&&z!=y&&i-1-z>n/2&&z<=i-1)
		{
			e2tot++;
			e2[e2tot].fr=i;
			e2[e2tot].to=z+n+1;
		}
		else
		{
			z=-1;
		}
		xx=n+(i-1)-d[i];
		if(xx>=0&&xx<=n-1&&xx!=x&&xx!=y&&xx!=z&&xx-i+1>n/2&&xx>=i-1)
		{
			e2tot++;
			e2[e2tot].fr=i;
			e2[e2tot].to=xx+n+1;
		}
		else
		{
			xx=-1;
		}
		sort(e2+1,e2+1+e2tot,cmp);
		for(j=1;j<=e2tot;j++)
		{
			add(e2[j].fr,e2[j].to);
		}
	}
	for(i=n;i>=1;i--)
	{
		memset(vis,0,sizeof(vis));
		vis[i]=1;
		if(!dfs(i))
		{
			printf("No Answer");
			return 0;
		}
	}
	for(i=1;i<=n;i++)
	{
		printf("%d ",ans[i]-1-n);
	}
}
```


---

## 作者：tene3nt (赞：0)

二分图的完美匹配，用匈牙利算法

每个数只与(di+i)%n，(n-di+i)%n联通

对于字典序，逆向匹配

···
```cpp
#include<bits/stdc++.h>
using namespace std;
int aa,re[10001],er[10001],vis[10001],path[10001][2],i,n;//path存储匹配方案
bool get(int x){
    int j;
    if(x==-1)return false;
    for(j=0;j<2;j++){
//        for(i=0;i<n;i++)printf("%d",6);
        if(!vis[path[x][j]])
        {
            vis[path[x][j]]=1;
            if(re[path[x][j]]==-1||
           get(re[path[x][j]]))//增广路径
            {
                er[x]=path[x][j];
                re[path[x][j]]=x;
                return true;
            }
        }
    }
    return false;
}
void zxt(){
    scanf("%d",&n);
    for(i=0;i<n;i++){
        scanf("%d",&aa);
        path[i][0]=min((aa+i)%n,(n-aa+i)%n);
        path[i][1]=max((aa+i)%n,(n-aa+i)%n);
    }
//    for(i=0;i<n;i++)printf("%d %d\n",path[i][1],path[i][2]);
    memset(re,-1,sizeof(re)); 
    for(i=n-1;i>=0;i--)//为了字典序
    {
        memset(vis,0,sizeof(vis));
        if(!get(i))
        {
            printf("No Answer");
            return;
        }
    }
//    printf("%d\n",er[3]);
    for(i=0;i<n;i++)
    printf("%d ",er[i]);
}
int main(){
    return zxt(),0;
}
···
```

---

## 作者：不是憨憨 (赞：0)

贪心算法：

我们可以预处理所有已经确定的匹配，并在图中删去。对于剩下的每个环，只需从序号最小的点开始深度优先搜索，并进行匹配即可。

时间复杂度：

预处理的时间复杂度为O(N)，深度优先搜索的时间复杂度为O(N)，所以总时间复杂度为O(N)。

而倒序匹配，求一次完美匹配的时间复杂度为O(N2)。

代码：












```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
using namespace std;
const int MAXN=20001,MAXM=MAXN*4;
struct edge
{
    edge *next;
    int t;
}*V[MAXN],ES[MAXM];
int N,EC,Stack[MAXN];
int S[MAXN][2],deg[MAXN],mat[MAXN];
bool nuked[MAXN];
inline void addedge(int a,int b)
{
    ES[++EC].next = V[a]; V[a] = ES + EC;
    V[a]->t = b;
    ES[++EC].next = V[b]; V[b] = ES + EC;
    V[b]->t = a;
    ++deg[b];
    mat[b] = a;
}
void init()
{
    scanf("%d",&N);
    int i,d,t1,t2;
    for (i=1;i<=N;++i)
    {
        scanf("%d",&d);
        t1 = i + d;
        if (t1>N) t1-=N;
        t2 = i - d;
        if (t2<1) t2+=N;
        if (t1 < t2)
            S[i][0] = t1,S[i][1] = t2;
        else
            S[i][0] = t2,S[i][1] = t1;
        addedge(i,S[i][1]+=N);
        addedge(i,S[i][0]+=N);
        deg[i] = 2;
    }
}
inline void Match(int i,int j)
{
    mat[i] = j;
    mat[j] = i;
}
void dfsMatch(int i,bool s)
{
    nuked[i] = true;
    int j;
    for (edge *e=V[i];e;e=e->next)
    {
        j = e->t;
        if (!nuked[j])
        {
            dfsMatch(j,!s);
            if (s)
                Match(i,j);
            break;
        }
    }
}
void noAnswer()
{
    printf("No Answer\n");
    exit(0);
}
void cut()
{
    int Stop = 0,i,j;
    for (i=1;i<=N;++i)
    {
        if (deg[i+N] == 0)
            noAnswer();
        else if (deg[i+N] == 1)
            Stack[++Stop] = i+N;
    }
    while (Stop)
    {
        i = Stack[Stop--];
        nuked[i] = true;
        for (edge *e=V[i];e;e=e->next)
        {
            j = e->t;
            if (!nuked[j])
                break;
        }
        Match(i,j);
        i = j;
        nuked[i] = true;
        for (edge *e=V[i];e;e=e->next)
        {
            j = e->t;
            if (!nuked[j])
            {
                deg[j]--;
                if (deg[j] == 0)
                    noAnswer();
                else if (deg[j] == 1)
                    Stack[++Stop] = j;
            }
        }
    }
}
void solve()
{
    cut();
    for (int i=1;i<=N;i++)
    {
        if (!nuked[i])
        {
            dfsMatch(i,true);
        }
    }
}
void print()
{
    int i;
    for (i=1;i<N;i++)
        printf("%d ",mat[i] - N - 1);
    printf("%d ",mat[i] - N - 1);
}
int main()
{
    init();
    solve();
    print();
    return 0;
}
```

---


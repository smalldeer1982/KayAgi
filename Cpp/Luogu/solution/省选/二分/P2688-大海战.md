# 大海战

## 题目背景

一天，GD和MW正在玩一款名叫大海战的游戏。


## 题目描述

游戏在一个 $1 \times n$ 的棋盘上进行。一开始 GD 拥有 $c$ 种战舰，每种战舰的宽度为 $1$，长度为 $c_i$，共有 $t_i$ 个。GD 要将所有这些战舰放置在棋盘上，并且任意两艘战舰间不能重叠（但可以相邻）。

接下来，MW 进行 $q$ 次“攻击”，每次攻击一个 $1 \times 1$ 的格子，而 MW 将告知他这次攻击是否“打中”了一艘战舰（或者它的某个部分）。

令人疑惑的是，每次 MW 都告诉 GD 说他没有打中任何一艘战舰，而这显然是不现实的。现在 MW 把整个游戏的过程告诉了你，他想知道，最早在他的第几次询问之后，可以断定 GD 一定（至少有一次）说了谎。

## 说明/提示

#### 样例输入输出 1 解释

- 对于第一个样例，存在布阵 $\{1,22,22,0,22,22,22\}$（$0$ 表示没有放置），使得第一次不会受到攻击；不存在一个布阵使得两次都没有受到攻击。
- 对于第二个样例，存在布阵 $\{0,333,0\}$，使得两次均不会受到攻击。
- 对于第三个样例，一开始就不可能把所有战舰合法地布置在棋盘上。

---

#### 数据规模与约定

- 对于测试点1，$n \leq 1000000000$，$c \leq 100000$，$q=0$；
- 对于测试点2、3，所有的 $t_i$ 均为 $1$；
- 对于测试点2-8，$n \leq 400000$，$c \leq 100$，$q=1$；
- 对于测试点9，$n \leq 100$，$c=1$，$q \leq 100$；
- 对于测试点10-14，$n \leq 200000$，$c=1$，$q \leq 200000$；
- 对于测试点15、16，$n \leq 200$，$c=2$，$q \leq 200$；
- 对于测试点17-20，$n \leq 4000$，$c=2$，$q \leq 4000$。
- 对于 $100\%$ 的数据，$1 \le t \le 5,n \ge 1,c \ge 1,q \ge 0,1 \le q_i \le n,0 \le c_i \le 10^5,0 \le t_i \le 10^5$。

---

#### 提示

- 请注意常数因子对程序效率造成的影响。



## 样例 #1

### 输入

```
3
12 2 2
1 1
2 5
6 8
5 1 2
3 1
1 5
11 3 0
2 2
3 1
5 1```

### 输出

```
2
-1
0```

# 题解

## 作者：QSWei (赞：13)

第一个点没有询问，只需要判断初始棋盘能否放下就行了。——直接把所有ci\*ti加起来，判是否小于等于n即可.

第2到第8个点，只有一次询问。这个询问把棋盘分成了两段，我们考虑其中较短的那部分，就变成了一个背包问题——要在这部分中放置尽量多的物品，空间浪费得越少越好。（至于剩下的那部分，直接用物品总体积减去前面能够放入的物品体积，与剩余的空间进行比较即可。）每个战舰的价值即为它的长度，直接多重背包即可。第2、3个点直接是01背包，而后面的点由于c\*n较大，朴素的背包会T，需要用单调队列优化得到O(cn)的算法.

第9到14个点，只有一种物品。我们二分答案，那么询问序列把棋盘分成了多个部分。假设某一段的长度为L，那么就可以放下L/size个物品。于是我们扫一遍就可以统计最多放置的物品数量，然后再根据要求二分下去即可。

第15到20个点，有两种物品。在二分的基础上（设分为了mid段），我们用f[i][j]表示考虑到前i段，恰好放置j种1号物品的前提下，可以放置的最多2号物品的数量。设第i段的长度为Li，转移方程为f[i][j]=max(f[i-1][j-k]+(Li-k\*size1)/size2)，其中0<=k<=j且k\*size1<=Li。那么f[mid][num1]就是当前状态可以放置的最多2号物品的数量，与要求进行比较，再二分即可。看上去这个方程是O(n^3)的，但实际上我们有k<=Li，因此对于确定的j，考虑所有的i，总共的决策数量不会超过sigma(Li)，即不会超过O(n)个。所以DP的复杂度为O(n^2)，整个算法的时间复杂度为O(n^2logq)，但远远达不到这个界，稍微优化一下就可以过了。




代码（c++）

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define maxn 500010
int n,c,q,siz[maxn],num[maxn],od[maxn],que[maxn];
int f[maxn],sta[maxn],sta2[maxn],len[maxn],dp[2][4010];
bool cmp(const int &p,const int &q)
{
    return que[p]<que[q];
}
int main()
{
    int t; scanf("%d",&t);
    while(t--)
    {
        scanf("%d%d%d",&n,&c,&q);
        memset(f,0,sizeof(f));
        long long totsum=0;
        for(int i=1; i<=c; i++)
        {
            scanf("%d%d",&siz[i],&num[i]);
            totsum+=1ll*siz[i]*num[i];
        }
        for(int i=1; i<=q; i++)
        {
            od[i]=i;
            scanf("%d",&que[i]);
        }
        if(totsum>n) {printf("0\n"); continue;}
        if(q==0)
        {
            printf("-1\n");
        }
        else if(q==1)
        {
            int now=min(que[1]-1,n-que[1]);
            for(int i=1; i<=c; i++)
            {
                for(int j=0; j<siz[i]; j++)                 {
                    int ta=1,fr=1;
                    sta[1]=f[j]; sta2[1]=0;                    for(int k=1,e=siz[i]; e+j<=now; k++,e+=siz[i])                    {
                        int curf=f[e+j]-e;
                        while(ta<=fr && sta[fr]<=curf) fr--;
                        sta[++fr]=curf; sta2[fr]=k;
                        if(sta2[fr]-sta2[ta]>num[i]) ta++;
                        f[e+j]=sta[ta]+e;
                    }
                }
            }
            if(f[now]+max(que[1]-1,n-que[1])>=totsum)
                printf("-1\n");
            else printf("1\n");
        }
        else if(c==1)
        {
            sort(od+1,od+1+q,cmp);
            int l=0,r=q+1,mid=(l+r)>>1;
            while(l<r)
            {
                int ans=0,lst=0;
                for(int i=1; i<=q; i++)
                    if(od[i]<=mid)
                    {
                        ans+=(que[od[i]]-lst-1)/siz[1]*siz[1];
                        lst=que[od[i]];
                    }
                ans+=(n-lst)/siz[1]*siz[1];
                if(ans>=totsum) l=mid+1;
                else r=mid;
                mid=(l+r)>>1;
            }
            if(mid!=q+1) printf("%d\n",mid);
            else printf("-1\n");
        }
        else if(c==2)
        {
            sort(od+1,od+1+q,cmp);
            int l=0,r=q+1,mid=(l+r)>>1;
            while(l<r)
            {
                int tot=0,lst=0;
                for(int i=1; i<=q; i++)
                    if(od[i]<=mid)
                    {
                        len[++tot]=que[od[i]]-lst-1;
                        lst=que[od[i]];
                    }
                len[++tot]=n-lst;
                memset(dp,-0x3f,sizeof(dp));
                                dp[0][0]=0;
                for(int i=1; i<=tot; i++)
                    for(int j=0; j<=num[1]; j++)
                    {
                        for(int k=0,e=0; k<=j && e<=len[i]; k++,e+=siz[1]) //how many 1st items
                            dp[i&1][j]=max(dp[i&1][j],dp[(i&1)^1][j-k]+(len[i]-e)/siz[2]);
                    }
                                if(dp[tot&1][num[1]]>=num[2]) l=mid+1;
                else r=mid;
                mid=(l+r)>>1;
            }
            if(mid!=q+1) printf("%d\n",mid);
            else printf("-1\n");
        }
    }
    return 0;
}

```

---


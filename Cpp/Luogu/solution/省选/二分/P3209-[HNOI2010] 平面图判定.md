# [HNOI2010] 平面图判定

## 题目描述

若能将无向图 $G=(V, E)$ 画在平面上使得任意两条无重合顶点的边不相交，则称 $G$ 是平面图。判定一个图是否为平面图的问题是图论中的一个重要问题。现在假设你要判定的是一类特殊的图，图中存在一个包含所有顶点的环，即存在哈密顿回路。


## 说明/提示

感谢@hibiki 对题目进行修正

感谢@@Anguei  提供latex题面

## 样例 #1

### 输入

```
2
6 9
1 4
1 5
1 6
2 4
2 5
2 6
3 4
3 5
3 6
1 4 2 5 3 6
5 5
1 2
2 3
3 4
4 5
5 1
1 2 3 4 5```

### 输出

```
NO
YES```

# 题解

## 作者：cmd2001 (赞：36)

其实不用2-sat的，直接并查集。

先用平面图定理 m<=3\*n+6 把边数减小到O(n)级别。

然后设 集合 i+m 表示 不能与i共存的边 所在的集合。

枚举每一对不能共存的边，如果已经在同一个集合内，则无解。

否则交叉连边 fa[find(i)]=j+m , fa[find(j)]=i+m 。

如何判断两条边是否相交？先把所有边坐标转换为哈密顿回路中的顺序坐标，对于任意两条边i,j，如果有xi<xj<yi<yj，则相交。

注意如果两条边任意不在同一条边上的两端点相同则不可能相交。

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=2e3+1e1;

int x[maxn<<4],y[maxn<<4],vis[maxn<<4];
int id[maxn];
int fa[maxn<<5];
int T,n,m;

inline int findfa(int x)
{
    return fa[x] == x ? x : fa[x] = findfa(fa[x]);
}

inline void initfa()
{
    for(int i=1;i<=m<<1;i++)
        fa[i] = i;
}

inline bool cross(int x1,int x2,int y1,int y2)
{
    if( x1 == x2 || y1 == y2 || x1 == y2 || x2 == y1 )
        return 0;
    if( x1 < x2 && y1 < y2 && x2 < y1 )
        return 1;
    if( x2 < x1 && y2 < y1 && x1 < y2 )
        return 1;
    return 0;
}


inline bool check()
{
    initfa();
    for(int i=1;i<=m;i++)
    {
        if( vis[i] )
            continue;
        for(int j=1;j<=m;j++)
        {
            if( vis[j] )
                continue;
            if( !cross(x[i],x[j],y[i],y[j]) )
                continue;
            int fai = findfa(i) , faj = findfa(j);
            if( fai == faj )
                return 0;
            fa[fai] = findfa( j + m ),
            fa[faj] = findfa( i + m );
        }
    }
    return 1;
}

inline void init()
{
    memset(x,0,sizeof(x));
    memset(y,0,sizeof(y));
    memset(vis,0,sizeof(vis));
    n = m = 0;
}

inline int getint()
{
    int ret = 0;
    char ch = getchar();
    while( ch < '0' || ch > '9' )
        ch = getchar();
    while( '0' <= ch && ch <= '9' )
        ret = ret * 10 + ( ch - '0' ),
        ch = getchar();
    return ret;
}
int main()
{
    T = getint();
    
    while( T-- )
    {
        init();
        n = getint() , m = getint();
        for(int i=1;i<=m;i++)
            x[i] = getint() , y[i] = getint();
        for(int i=1;i<=n;i++)
            id[getint()] = i;
        if( m > 3 * n + 6 )
        {
            puts("NO");
            continue;
        }
        for(int i=1,a,b;i<=m;i++)
        {
            a = id[x[i]] , b = id[y[i]];
            x[i] = min( a , b ),
            y[i] = max( a , b );
        }
        for(int i=1;i<=m;i++)
            if( y[i] == x[i] + 1 || ( y[i]==n && x[i]==0) )
                vis[i] = 1;
        if( check() )
            puts("YES");
        else puts("NO");
    }
    return 0;
}
```

---

## 作者：xyz32768 (赞：29)

首先，平面图的性质：边数小于等于$3n-6$。不符合的直接跳过。

然后可以发现，对于哈密尔顿环之外的任意一条边，要么连在环内部，要么连在环外部。在一定的条件下（可以简单判断），如果两条边**同时**连在环内部或**同时**连在环外部，这两条边就一定会相交，这样的限制条件符合2-SAT的模型。

把第$i$条边拆成$i$和$i'$，$i$表示这条边连在内部，$i'$表示连在外部。

对于任意两条不在哈密尔顿环上的边$i,j,i\neq j$，如果他们不能同时连在环内或环外，则：

1、建边$<i,j'>$，表示$i$在内则$j$必须在外。

2、建边$<i',j>$，表示$i$在外则$j$必须在内。

3、建边$<j,i'>$，表示$j$在内则$i$必须在外。

4、建边$<j',i>$，表示$j$在外则$i$必须在内。

然后求一遍强连通分量，如果存在一个$i$和$i'$在同一个强连通分量里，那么原图不是平面图，否则是平面图。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int V = 205, N = 3e4 + 5, M = 2e6 + 5;
int n, m, eX[N], eY[N], Cir[V], ecnt, nxt[M], adj[N], go[M], dfn[N], low[N],
top, times, stk[N], bel[N], sum, rev[V], Ex[N], Ey[N];
bool cir[V][V], ins[N];
void add_edge(int u, int v) {
    nxt[++ecnt] = adj[u]; adj[u] = ecnt; go[ecnt] = v;
}
void Tarjan(int u) {
    dfn[u] = low[u] = ++times;
    stk[++top] = u; ins[u] = 1;
    for (int e = adj[u], v; e; e = nxt[e])
        if (!dfn[v = go[e]]) {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if (ins[v]) low[u] = min(low[u], dfn[v]);
    if (dfn[u] == low[u]) {
        int v; bel[u] = ++sum; ins[u] = 0;
        while (v = stk[top--], v != u) bel[v] = sum, ins[v] = 0;
    }
}
bool check() {
    int i; for (i = 1; i <= (m << 1); i++)
        if (!dfn[i]) Tarjan(i);
    for (i = 1; i <= m; i++)
        if (bel[i] == bel[i + m]) return 0;
    return 1;
}
void work() {
    ecnt = times = sum = 0; memset(adj, 0, sizeof(adj));
    memset(dfn, 0, sizeof(dfn)); memset(bel, 0, sizeof(bel));
    memset(low, 0, sizeof(low)); memset(cir, 0, sizeof(cir));
    int i, j, u, v, x, y, tot = 0; n = read(); m = read();
    for (i = 1; i <= m; i++) {
        eX[i] = read(); eY[i] = read();
        if (eX[i] > eY[i]) swap(eX[i], eY[i]);
    }
    for (i = 1; i <= n; i++) {
        rev[Cir[i] = read()] = i;
        if (i > 1) {
            x = Cir[i - 1]; y = Cir[i];
            if (x < y) cir[x][y] = 1;
            else cir[y][x] = 1;
        }
    }
    if (m > 3 * n - 6) return (void) (printf("NO\n"));
    x = Cir[n]; y = Cir[1]; ((x < y) ? cir[x][y] : cir[y][x]) = 1;
    for (i = 1; i <= m; i++) {
        if (cir[eX[i]][eY[i]]) continue;
        Ex[++tot] = eX[i]; Ey[tot] = eY[i];
    }
    m = tot; for (i = 1; i < m; i++) for (j = i + 1; j <= m; j++) {
        u = rev[Ex[i]], v = rev[Ey[i]], x = rev[Ex[j]], y = rev[Ey[j]];
        if (u > v) swap(u, v); if (x > y) swap(x, y);
        if ((u < x && v > x && v < y) || (u > x && u < y && v > y)) {
            add_edge(i, j + m); add_edge(i + m, j);
            add_edge(j, i + m); add_edge(j + m, i);
        }
    }
    printf(check() ? "YES\n" : "NO\n");
}
int main() {
    int T = read();
    while (T--) work();
    return 0;
}
```

---

## 作者：alecli (赞：15)

### 提供一种新思路

如果单独的平面图判定肯定是很麻烦的，但题目给了一个条件，**此平面图存在哈密顿回路**，我们将哈密顿回路画成一个圆，那么原图的边（除去哈密顿回路上的边）可以看作是该圆的弦，考虑圆中两条相交的弦 $(u_1, v_1), (u_2, v_2)$,由于是平面图，我们可以将其中的一条翻到圆外去（但两条弦不能同时翻到圆外去，原因是如果他们在圆内相交，那么在圆外也会相交，可以画图模拟一下），我们考虑将弦视为点，把相交的弦连边，这样，平面图的判定就转为了新图的二分图判定~

要注意的一点：按照题中所给的m的范围是过不去的，但这其实是个假数据范围，平面图有一条性质是 $m \leq 3n - 6$，有兴趣的同学可以去了解一下证明

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x * f;
}
const int M = 10010;
struct node{
    int nxt, to;
}edge[700 * 700 * 2];
int head[M], num, col[M];
void build(int from, int to){
    edge[++num].nxt = head[from];
    edge[num].to = to;
    head[from] = num;
}
bool dfs(int u, int color){
    col[u] = color;
    for(int i=head[u]; i; i=edge[i].nxt){
        int v = edge[i].to;
        if(col[v] == color) return 0;
        if(col[v] == 0 && !dfs(v, -color)) return 0;
    }
    return 1;
}
bool check(int u1, int v1, int u2, int v2){
    return (u1 < u2 && u2 < v1 && v1 < v2) || (u2 < u1 && u1 < v2 && v2 < v1);
}
int t, n, m;
int from[M], to[M], G[M];
void clearx(){
    memset(head, 0, sizeof(head)); num = 0;
    memset(col, 0, sizeof(col));
    memset(G, 0, sizeof(G));
}
int main(){
    t = read();
    while(t --){
        n = read(), m = read(); int flag = 0;
        clearx();
        for(int i=1; i<=m; i++){
            from[i] = read(); to[i] = read();
        }
        for(int i=1; i<=n; i++) G[read()] = i;
        if(m > 3 * n - 6){
            puts("NO"); continue;
        }
        for(int i=1; i<=m-1; i++){
            for(int j=i+1; j<=m; j++){
                int u1 = G[from[i]], v1 = G[to[i]], u2 = G[from[j]], v2 = G[to[j]];
                if(u1 > v1) swap(u1, v1); if(u2 > v2) swap(u2, v2);
                if( check(u1, v1, u2, v2) ) build(i, j), build(j, i);
            }
        }
        for(int i=1; i<=m; i++){
            if(col[i] == 0){
                if(!dfs(i, 1)){
                    flag = 1;
                    break;
                }
            }
        }
        if(!flag) puts("YES");
        else puts("NO");
    }
    return 0;
}


```



---

## 作者：Seauy (赞：6)

### ~~前言~~

这题其实用不上 $ 2-SAT $，$ Dinic $，$ Topo+Tarjan $,$ disjoint-set$ 这么高大上的名词来解释的（其实是我太蒻了qwq）要我说就是爆搜，只不过保证了时间复杂度和正确性

大家的思路其实本质都差不多，代码实现起来除了 $ Tarjan $ 那个之外实质都一样，但却硬要提到二分图上，吓得我这种菜鸡当场劝退了

以防后面的人也会跟我一样被吓着，我决定用比较易懂的方式解释一下 qwq

------------

## 一些必须想明白的事

题目中给了图中的哈密顿路径，这意味着图中的所有结点都连成了一个环。但是环上只有 n 条边，剩下的边去哪了呢？自然是把环上不相邻的两点给连接起来了

暂且先把除了哈密顿路径的所有边成为“弦”

![](https://cdn.luogu.com.cn/upload/image_hosting/mu1mpadh.png)

想想环把平面分成了两个部分，那么如果两条弦相交了，使此图不为平面图，那么这两条弦肯定在环的同侧（内或外）

只在同侧就行了吗？

设结点 $ i $ 在环上的顺序为 $ HamiN_i $，那么两条弦相交还得满足一条弦的结点 $ a $ 的 $ HamiN $ 在另一条弦两个结点的 $ HamiN $ 的开区间内，另一结点 $ b $ 不在其闭区间内

设有两条边 $ x,y $，用表达式就写成：

$ HamiN_{x.a}<HamiN_{y.a}<HamiN_{x.b} $

并且

$ HamiN_{y.b}<HamiN_{x.a} || HamiN_{x.b}<HamiN_{y.b} $

把 $ y $ 的 $ a,b $ 再对调一下进行比较：

$ HamiN_{x.a}<HamiN_{y.b}<HamiN_{x.b} $

并且

$ HamiN_{y.a}<HamiN_{x.a} || HamiN_{x.b}<HamiN_{y.a} $

两者满足其一，同侧两弦就相交

代码写上来就是

```cpp
bool Intersect(DE x,DE y)
{
	return
	(
		(
			(HamiN[y.a]<HamiN[x.a] && HamiN[x.a]<HamiN[y.b])
			&& 
			(HamiN[x.b]<HamiN[y.a] || HamiN[y.b]<HamiN[x.b])
		)
		||
		(
			(HamiN[y.a]<HamiN[x.b] && HamiN[x.b]<HamiN[y.b])
			&& 
			(HamiN[x.a]<HamiN[y.a] || HamiN[y.b]<HamiN[x.a])
		)
	);
}
```

注意提前预处理出 $ HamiN $ 并使得每条弦 $ HamiN_a \leq HamiN_b $

```cpp
scanf("%d %d",&n,&m);
for(int i=1;i<=m;i++) E[i].Scan();
for(int i=1,V;i<=n;i++)
{
	scanf("%d",&V);
	HamiN[V]=i;
}
for(int i=1;i<=m;i++)
	if(HamiN[E[i].a]>HamiN[E[i].b]) swap(E[i].a,E[i].b);
```

------------

## 算法思路

如果图上所有弦不管向内向外如何摆放都会有相交，那么这个图就不是平面图

如果存在有一种摆放方式使所有弦都不相交，那么就是平面图

我们只要尽量让图成为平面图就行了

对于每一条弦，找出所有有可能与之相交的弦（就是如果放在同侧它俩就会相交，它们组成的集合称为 $ oppo $），那么这条弦放在了一侧，其 $ oppo $ 内所有弦必须放在异侧

我们每放一条弦，就将其的 $ oppo $ 内所有边放进异侧，如果这期间有边相交了，那就没办法了，肯定不是平面图

对于一开始放置的弦，我们放在哪侧都行

整个放置的过程用 $ DFS $ 实现，样子很像你们匹配二分图时的样子

效率 $ O(Tm^2) $，由于 $ m\leq3n-6 $，根本不慌

## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN=200;
const int MAXM=1e4;

bool inseg(int bef,int ob,int aft)
{return bef<ob && ob<aft;}

struct DE
{
	int a,b;
	void Scan() {scanf("%d %d",&a,&b);}
	void Print() {printf("%d %d\n",a,b);}
}E[MAXM+5];

int T,n,m;bool ans;
int HamiN[MAXN+5];
DE Assort[3][MAXN+5];int num[3];
//记录两侧有哪些弦放置

bool Intersect(DE x,DE y)
{
	return
	(
		(
			(HamiN[y.a]<HamiN[x.a] && HamiN[x.a]<HamiN[y.b])
			&& 
			(HamiN[x.b]<HamiN[y.a] || HamiN[y.b]<HamiN[x.b])
		)
		||
		(
			(HamiN[y.a]<HamiN[x.b] && HamiN[x.b]<HamiN[y.b])
			&& 
			(HamiN[x.a]<HamiN[y.a] || HamiN[y.b]<HamiN[x.a])
		)
	);
}

bool cmp(DE x,DE y)
{
	if(HamiN[x.a]!=HamiN[y.a]) return HamiN[x.a]<HamiN[y.a];
	return HamiN[x.b]<HamiN[y.b];
}

bool CanPutIn(DE ob,bool type)//判断弦 ob 是否能放在 type 侧
{
	for(int i=1;i<=num[type];i++)
		if(Intersect(ob,Assort[type][i])) return 0;
	return 1;
}

struct msg
{
	bool type;
	int edge;
};

vector<int> oppo[MAXM+5];
bool visit[MAXM+5];

bool DFS(int edge,bool type)
{
	visit[edge]=1;
	Assort[type][++num[type]]=E[edge];
	bool cnt=1;
	for(int i=0,rear;i<oppo[edge].size() && cnt;i++)
	{
		rear=oppo[edge][i];
		if(visit[rear]) continue;
		if(CanPutIn(E[rear],!type)) cnt&=DFS(rear,!type);
		else cnt=0;
	}
	return cnt;
}

int main()
{
	for(scanf("%d",&T);T--;)
	{
		scanf("%d %d",&n,&m);
		for(int i=1;i<=m;i++) E[i].Scan();
		for(int i=1,V;i<=n;i++)
		{
			scanf("%d",&V);
			HamiN[V]=i;
		}
		for(int i=1;i<=m;i++)
			if(HamiN[E[i].a]>HamiN[E[i].b]) swap(E[i].a,E[i].b);
		if(m>3*n-6) {printf("NO\n");continue;}
		num[0]=num[1]=0;
		ans=1;
		for(int i=1;i<=m;i++)
		{
			oppo[i].clear();
			visit[i]=0;
		}
		for(int i=1;i<=m;i++)
			for(int j=1;j<=m;j++)
			{
				if(i==j) continue;
				if(Intersect(E[i],E[j])) oppo[i].push_back(j);
			}
		for(int i=1;i<=m && ans;i++)
			if(!visit[i]) ans&=DFS(i,0);
  		//如果 !visit[i]，说明弦 i 跟之前放置的弦绝对不会相交，因此可以随意放置弦 i
		if(ans) printf("YES\n");
		else printf("NO\n");
	}
	return 0;
}
```
### 后语

~~不看也行，没啥用~~

一开始看到这题第一反应是库拉托夫斯基定理 qwq 满图找 $ K_5 $（五个结点的无向完全图）和 $ K_{3,3} $（两部有三个结点的二分图，不同部的结点都互相有连边）

然后效率是……$ O(Tn^6) $ qwq 直到我看到题目中给了哈密顿回路……

------------

然后想了个假算法：依次放置所有边，能放进内侧就放内侧，不行就外侧，再不行直接输出 NO

其实写到一半一经发现算法假了，然而不甘心，按照弦两侧结点的 $ HamiN $ 排序了一下

居然拿了 80 分 qwq 考场上如果想不出来这方法肯定值了

---

## 作者：lemir3 (赞：4)

## 题目分析

首先我们知道,题中给出的图中有一个哈密顿回路,询问这张图是不是平面图.

根据平面图的性质,$m \leq 3n-6$,不满足的直接跳掉,[*证明看这里*](https://wenku.baidu.com/view/8c887f10a6c30c2259019ea0.html).

然后我们把哈密顿回路中的边筛掉,枚举剩下的边是否有两两相交的.

考虑关系数组的建立,m表示筛掉回路后的边的数量,$(1,m)$表示这条边在圈内,$(m+1,2m)$表示这条边在圈外.

如果两条边相交的话,那么它们就不能同时在圈外或圈内,根据这个连边.

然后用tarjan跑一遍2-sat,因为我们只用判定是否是平面图,所以导出矛盾(即scc[i]==scc[i+m])的就直接返回false.

其他的细节直接看代码好了,很好理解的.

## 代码

```cpp
#include "iostream"
#include "cstdio"
#include "cstring"
#include "cstdlib"
#include "cmath"
#include "cctype"
#include "algorithm"
#include "set"
#include "queue"
#include "stack"
#include "map"
#include "stack"
#define lxl long long
#define R register
#define INF 0x3f3f3f3f
#define debug(x) printf("debug:%lld\n",x) 
using namespace std;
const lxl maxm=100010,maxn=1010;
lxl T,n,m,EdgeSize,TimeCnt,SccCnt,tot;
lxl loop[maxn],pla[maxn],head[maxm<<1],dfn[maxm<<1],low[maxm<<1],scc[maxm<<1],num[maxn][maxn];
bool edge[maxn][maxn],falg[maxm<<1];
stack<lxl>s;
struct _Edge
{
	lxl to,next;
}e[maxm*10];
struct _Con
{
	lxl u,v;
}le[maxm],ne[maxm];
inline lxl read()
{
	char c=getchar();
	lxl f=1,x=0;
	for(;!isdigit(c);c=getchar())(c=='-')&&(f=-1);
	for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
	return f*x;
}
inline void EdgeAdd(lxl from,lxl to)
{
	e[EdgeSize].to=to;
	e[EdgeSize].next=head[from];
	head[from]=EdgeSize++;
}
void tarjan(lxl now)
{
	dfn[now]=low[now]=++TimeCnt;
	falg[now]=true,s.push(now);
	for(R int i(head[now]),to;~i;i=e[i].next)
	{
		to=e[i].to;
		if(!dfn[to])
		{
			tarjan(to);
			low[now]=min(low[now],low[to]);
		}
		else if(falg[to])low[now]=min(low[now],dfn[to]);
	}
	if(dfn[now]==low[now])
	{
		++SccCnt;
		while(!s.empty())
		{
			lxl temp=s.top();
			s.pop();
			falg[temp]=false;
			scc[temp]=SccCnt;
			if(temp==now)break;
		}
	}
}
inline bool ok()
{
	for(R int i(1);i<=m+m;++i)if(!dfn[i])tarjan(i);
	for(R int i(1);i<=m;++i)if(scc[i]==scc[i+m])return false;
	return true;
}
int main(void)
{
	T=read();
	for(;T;--T)
	{
		while(!s.empty())s.pop();
		memset(falg,false,sizeof(falg)),memset(e,0,sizeof(e));
		memset(head,-1,sizeof(head)),memset(dfn,0,sizeof(dfn));
		memset(low,0,sizeof(low)),memset(scc,0,sizeof(scc));
		memset(edge,false,sizeof(edge)),memset(le,0,sizeof(le));
		memset(pla,0,sizeof(pla)),memset(loop,0,sizeof(loop));
		memset(ne,0,sizeof(ne));
		SccCnt=TimeCnt=EdgeSize=tot=0;
		n=read(),m=read();
		for(R int i(1);i<=m;++i)
		{
			le[i].u=read(),le[i].v=read();
			if(le[i].u>le[i].v)swap(le[i].u,le[i].v);
			edge[le[i].u][le[i].v]=true;
		}
		for(R int i(1);i<=n;++i)
		
			loop[i]=read(),pla[loop[i]]=i;
			if(i>1)edge[min(loop[i],loop[i-1])][max(loop[i],loop[i-1])]=false;
		}
		if(m>n+n+n-6)
		{
			printf("NO\n");
			continue;
		}
		edge[min(loop[1],loop[n])][max(loop[1],loop[n])]=false;
		for(R int i(1);i<=m;++i)
			if(edge[le[i].u][le[i].v])ne[++tot].u=le[i].u,ne[tot].v=le[i].v;
		m=tot;
		for(R int i(1);i<=m;++i)
			for(R int j(i+1);j<=m;++j)
			{
				lxl a=ne[i].u,b=ne[i].v,x=ne[j].u,y=ne[j].v;
				if(edge[a][b]&&edge[x][y])
				{
					if(pla[b]<pla[a])swap(a,b);
					if(pla[y]<pla[x])swap(x,y);
					if(pla[a]<pla[x]&&pla[b]>pla[x]&&pla[b]<pla[y])
					{
						EdgeAdd(i,j+m),EdgeAdd(j,i+m);
						EdgeAdd(i+m,j),EdgeAdd(j+m,i); 
					}
					else if(pla[b]>pla[y]&&pla[a]>pla[x]&&pla[a]<pla[y])
					{
						EdgeAdd(i,j+m),EdgeAdd(j,i+m);
						EdgeAdd(i+m,j),EdgeAdd(j+m,i);
					}
				}
			}
		printf(ok()?"YES\n":"NO\n");
	}
	return 0;
}
```

---

## 作者：GoPoux4 (赞：4)

首先需要了解平面图的定义：

如果图 $G$ 能画在平面 $S$ 上，即 **除顶点处外无边相交** ，则称 $G$ 可平面嵌入 $S$ ， $G$ 为可平面图或平面图。

设 $G$ 是平面图，由 $G$ 的边将 $G$ 所在的平面划分成若干个区域，每个区域称为 $G$ 的一个 **面** ，其中面积无限的面称为无限面或外部面，面积有限的称为有限面或内部面。包围每个面的所有边组成的回路称为该面的 **边界** ，边界的长度称为该面的 **次数** 。

为了强调平面图的面，用三元组表示一个平面图 $G=(V,E,F)$ ，其中 $F$ 表示平面图 $G$ 中面的个数。

---

对于连通平面图，有欧拉公式：
$$
V-E+F=2
$$
证明比较复杂，要涉及代数拓扑。

若 $G$ 是连通的简单平面图（无重边与自环），则每个面的次数都 **至少为 $3$** ，又因为每条边仅属于 **两个面** 的边界，则有： $3F \leq 2E$ 。代入上式得：
$$
E \leq 3V-6
$$

---

然后再来看这道题。

输入中给出了这个图 $G$ 和 $G$ 中的一个哈密顿回路。

我们将这个哈密顿回路展开，即让其他边都在回路围成的区域内。

图为样例第一组数据：

![d1DmCV.png](https://s1.ax1x.com/2020/08/19/d1DmCV.png)

不难发现，上图中相交的两条边必须一条边在哈密顿回路内，一条在回路外才能不相交。

则问题转化为一个2-SAT问题，枚举相交的两条边 $i,j$，连边：

+ $i \to j'$ 表示 $i$ 在回路内则 $j$ 必须在回路外。
+ $j \to i'$ 表示 $j$ 在回路内则 $i$ 必须在回路外。
+ $i' \to j$ 表示 $i$ 在回路外则 $j$ 必须在回路内。
+ $j' \to i$ 表示 $j$ 在回路外则 $i$ 必须在回路内。

缩点后判断是否存在 $i,i'$ 在同一个强连通分量中，若存在则 $G$ 不是平面图。

然而 $M \leq 10000$ ，直接连边会爆炸。用上面的结论 $K \leq 3V-6$ 可以特判掉不可能成为平面图的情况。

---

$\text{Code}:$

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <stack>
#define maxm 2000005
#define Rint register int
#define INF 0x3f3f3f3f
using namespace std;
typedef long long lxl;

template <typename T>
inline T read()
{
	T x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}

struct edge
{
	int u,v,next;
	inline bool operator < (const edge &T)const
	{
		return u<T.u||(u==T.u&&v<T.v);
	}
}e[maxm],eg[10005];

int head[maxm],k;

inline void add(int u,int v)
{
	e[k]=(edge){u,v,head[u]};
	head[u]=k++;
}

int n;
int dfn[maxm],low[maxm],scc[maxm],dfs_cnt,scc_cnt;
stack<int> S;

inline void tarjan(int u)
{
	S.push(u);
	dfn[u]=low[u]=++dfs_cnt;
	for(int i=head[u];~i;i=e[i].next)
	{
		int v=e[i].v;
		if(!dfn[v])
		{
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(!scc[v]) low[u]=min(low[u],dfn[v]);
	}
	if(dfn[u]==low[u])
	{
		int x;
		++scc_cnt;
		do
		{
			x=S.top();S.pop();
			scc[x]=scc_cnt;
		} while (x!=u);
	}
}

int N,M,G[205];

inline void clear()
{
	memset(head,-1,sizeof(head));
	memset(dfn,0,sizeof(dfn));
	memset(low,0,sizeof(low));
	memset(scc,0,sizeof(scc));
	k=scc_cnt=dfs_cnt=0;
}

int main()
{
	// freopen("P3209.in","r",stdin);
	int T=read<int >();
	while(T--)
	{
		N=read<int >(),M=read<int >();
		clear();
		for(int i=1;i<=M;++i)
		{
			int u=read<int >(),v=read<int >();
			eg[i]=(edge){u,v};
		}
		for(int i=1;i<=N;++i)
			G[read<int >()]=i;
		if(M>3*N-6) {puts("NO");continue;}
		for(int i=1;i<=M;++i)
		{
			eg[i].u=G[eg[i].u];
			eg[i].v=G[eg[i].v];
			if(eg[i].u>eg[i].v) swap(eg[i].u,eg[i].v);
		}
		sort(eg+1,eg+M+1);
		for(int i=1;i<M;++i)
			for(int j=i+1;j<=M;++j)
				if(eg[i].u<eg[j].u&&eg[j].u<eg[i].v&&eg[i].v<eg[j].v)// 判断是否相交
					add(i+M,j),add(j+M,i),add(i,j+M),add(j,i+M);
		for(int i=1;i<=(M<<1);++i)
			if(!dfn[i]) tarjan(i);
		bool flag=true;
		for(int i=1;i<=M;++i)
			if(scc[i]==scc[i+M])
			{
				flag=false;
				break;
			}
		puts(flag?"YES":"NO");
	}
	return 0;
}

```



---

## 作者：yzxoi (赞：3)

[My Blog](https://yzxoi.top/archives/1701)

# Description

判定一个图是否为平面图的问题是图论中的一个重要问题。现在假设你要判定的是一类特殊的图是否是平面图，图中存在一个包含所有顶点的环，即存在哈密顿回路。

对于一个无向图 $G=(V,E)$，如果能够做到把它画在同一个平面上，使得 $\forall (a,b)(c,d)$，$a,b,c,d$ 两两不等的情况下，边 $(a,b)$ 和边 $(c,d)$ 没有交点，则称 $G$ 是平面图。

哈密顿回路指的是：在一个有 $n$ 个点的图中，一条从点 $x$ 出发，最后回到点 $x$，并且除点 $x$ 外所有点都只出现一次，总长度为 $n$ 的路径。

## Solution

简单给出平面图的定义：无向图画在同一个平面上，任意两边没有交点。

对于每一条边，只有两种情况：

1. 在哈密顿回路上，那么这条边无需其他判断。
2. 在哈密顿回路外/里，那么这条边有两种选择：要么在外部，要么在里面。

由于第二种情况的两种选择，以及平面图的限制，这就转化为了个经典的 2-SAT 问题。

![image-20210301204343887](https://gitee.com/yzx1798106406/picgoimage/raw/master/pic/image-20210301204343887.png)

显然如果边 $(x,y)$ 与边 $(u,v)$ 都在环内时，这个图就不是平面图。

那么我们只要顺次枚举两条边，判断是否有限制即可。

核心代码：

```c++
for(i=1;i<=p;i++) for(j=i+1;j<=p;j++){//枚举两条边
	u=rk[e[i].x],v=rk[e[i].y],x=rk[e[j].x],y=rk[e[j].y];//rk表示点在哈密顿回路上的序号
	if(u>v) swap(u,v);if(x>y) swap(x,y);
	if((u<x&&v>x&&v<y)||(u>x&&u<y&&v>y)) Add(i,j+p),Add(i+p,j),Add(j,i+p),Add(j+p,i);//判断是否有限制，并建图
}
```

然而发现这种方法的建图复杂度会高达 $O(M^2)$，对于 $1\leq M\leq 10^4$ 的本题是完全不能通过的。

那么接下来就要利用到平面图的一个重要性质：$m\leq 3n+6$。

具体性质的证明，楼上楼下都解释得很清楚了，这里就不再赘述。

## Code

```c++
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define W while
#define I inline
#define RI register int
#define LL long long
#define Cn const
#define CI Cn int&
#define gc getchar
#define D isdigit(c=gc())
#define pc(c) putchar((c))
#define min(x,y) ((x)<(y)?(x):(y))
#define max(x,y) ((x)>(y)?(x):(y))
using namespace std;
namespace Debug{
	Tp I void _debug(Cn char* f,Ty t){cerr<<f<<'='<<t<<endl;}
	Ts I void _debug(Cn char* f,Ty x,Ar... y){W(*f!=',') cerr<<*f++;cerr<<'='<<x<<",";_debug(f+1,y...);}
	Tp ostream& operator<<(ostream& os,Cn vector<Ty>& V){os<<"[";for(Cn auto& vv:V) os<<vv<<",";os<<"]";return os;}
	#define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)
}using namespace Debug;
namespace FastIO{
	Tp I void read(Ty& x){char c;int f=1;x=0;W(!D) f=c^'-'?1:-1;W(x=(x<<3)+(x<<1)+(c&15),D);x*=f;}
	Ts I void read(Ty& x,Ar&... y){read(x),read(y...);}
	Tp I void write(Ty x){x<0&&(pc('-'),x=-x,0),x<10?(pc(x+'0'),0):(write(x/10),pc(x%10+'0'),0);}
	Tp I void writeln(Cn Ty& x){write(x),pc('\n');}
}using namespace FastIO;
Cn int N=210,M=10010,P=3*N+6;
int T,n,m,p,C[N],G[N][N],fir[P<<1],nxt[P*P<<2],son[P*P<<2],tot,dfn[P<<1],low[P<<1],stk[P<<1],col[P<<1],cnt,top,cc,rk[N];
struct Edge{int x,y;}e[P],E[M];
I void Add(CI x,CI y){nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y;}
#define to son[i]
I void Tarjan(CI x){
	dfn[x]=low[x]=++cnt,stk[++top]=x;RI i;
	for(i=fir[x];i;i=nxt[i]) if(!dfn[to]) Tarjan(to),low[x]=min(low[x],low[to]);else if(!col[to]) low[x]=min(low[x],dfn[to]);
	if(dfn[x]==low[x]){col[x]=++cc;W(stk[top]^x) col[stk[top--]]=cc;top--;}
}
int main(){
	RI i,j,u,v,x,y,flg;read(T);W(T--){
		for(memset(G,0,sizeof(G)),memset(dfn,0,sizeof(dfn)),read(n,m),i=1;i<=m;i++) read(E[i].x,E[i].y),E[i].x>E[i].y&&(swap(E[i].x,E[i].y),0);//所有边按照编号小连向编号大，便于去掉哈密顿回路上的边
		for(i=1;i<=n;i++) read(C[i]),rk[C[i]]=i,i>1&&(G[min(C[i-1],C[i-1])][max(C[i-1],C[i])]=1,0);G[min(C[1],C[n])][max(C[1],C[n])]=1;//哈密顿回路上的边打上标记
		if(m>3*n+6){puts("NO");continue ;}//利用平面图的性质
		for(memset(col,0,sizeof(col)),flg=cnt=top=cc=p=0,i=1;i<=m;i++) if(!G[E[i].x][E[i].y]) e[++p]=E[i];
		for(memset(fir,0,sizeof(fir)),tot=0,i=1;i<=p;i++) for(j=i+1;j<=p;j++){
			u=rk[e[i].x],v=rk[e[i].y],x=rk[e[j].x],y=rk[e[j].y];
			if(u>v) swap(u,v);if(x>y) swap(x,y);
			if((u<x&&v>x&&v<y)||(u>x&&u<y&&v>y)) Add(i,j+p),Add(i+p,j),Add(j,i+p),Add(j+p,i);//建图
		}for(i=1;i<=(p<<1);i++) if(!dfn[i]) Tarjan(i);for(i=1;i<=p;i++) if(col[i]==col[i+p]){puts("NO");flg=1;break ;}if(!flg) puts("YES");
	}return 0;
}
```



---

## 作者：Tgotp (赞：3)

对于这道题，分析，对于已经有的回路构图，剩下的边，只有两种选择，圈内圈外，


手动模拟一下就可以发现：题目要求避免两线相交，那么只会存在在圈内的编号存在以下关系时满足：


( u[i] < u[j] && v[i] > u[j] && v[i] < v[j] ) || ( u[j] < u[i] && v[j] > u[i] && v[j] < v[i])

即一点在另一边内，另一点在另一边之外，然后跑一遍2 – sat，搞定


c++代码如下：

[蒟蒻blog](http://tgotp.science/1997-hnoi2010planar/)


---

## 作者：hibiki (赞：0)

首先可以把这个哈密顿回路画成一个环，所以每一条边只有在内和在外两种情况。默认所有边都在环内。枚举边，如果边与边之间出现了冲突，那么就代表有一条边在内，有一条边在外。这样就构建了一个2-SAT模型，直接求解即可。

```pascal
//2-SAT问题
Type
    road=record
        toit,next:longint;
    end;
Var
    roads:array[1..1000000] of road;
    flag,low,dfn,list,stack,refer:array[1..1000000] of longint;
    flag2:array[1..1000000] of boolean;
    cnt,top,time,tot,m,n,i,t,tt:longint;
Function min(a,b:longint):longint;
        begin
                if a<b then exit(a);
                exit(b);
        end;
Procedure add(u,v:longint);
    begin
        inc(cnt);
        roads[cnt].toit:=v;
        roads[cnt].next:=list[u];
        list[u]:=cnt;
    end;
Procedure dfs(now:longint);
    var
        w:longint;
    begin
        flag[now]:=1;
        inc(top);
        stack[top]:=now;
        inc(time);
        dfn[now]:=time;
        low[now]:=time;
        w:=list[now];
        while w<>0 do begin
            if flag[roads[w].toit]=0 then dfs(roads[w].toit);
            if flag[roads[w].toit]<2 then low[now]:=min(low[now],low[roads[w].toit]);
            w:=roads[w].next;
        end;
        if dfn[now]=low[now] then begin
            inc(tot);
            while stack[top+1]<>now do begin
                refer[stack[top]]:=tot;
                flag[stack[top]]:=2;
                dec(top);
            end;
        end;
    end;
Function build:boolean;
    var
        a,b,pos:array[1..1000000] of longint;
        //flag:array[1..1000000] of boolean;
        i,t,j:longint;
    begin
        readln(n,m);
        for i:=1 to m do begin
            readln(a[i],b[i]);
        end;
        for i:=1 to n do begin
            read(t);
            pos[t]:=i;
        end;
        if m>3*n-6 then begin
            writeln('NO');
            exit(false);
        end;
        for i:=1 to m do begin
            a[i]:=pos[a[i]];
            b[i]:=pos[b[i]];
            if a[i]>b[i] then begin
                tt:=a[i];
                a[i]:=b[i];
                b[i]:=tt;
            end;        
        end;
        for i:=1 to m do begin
            if (a[i]+1=b[i]) or ((a[i]=1) and (b[i]=n)) then flag2[i]:=true;
        end;
        for i:=1 to m do if not(flag2[i]) then
            for j:=1 to m do if (i<>j) and not(flag2[j]) then
                if ((a[i]<a[j]) and (a[j]<b[i]) and (b[i]<b[j])) then begin
                    add(i,j+m); //i代表i在内,i+m代表i在外
                    add(j,i+m);
                    add(i+m,j);
                    add(j+m,i);
                end;
        exit(true);
    end;
Procedure work;
    var
        i:longint;
    begin
        time:=0;
        for i:=1 to m do
            if not(flag2[i]) then begin
                if (dfn[i]=0) then dfs(i);
                if (dfn[i+m]=0) then dfs(i+m);
            end;
            for i:=1 to m do begin
                //if not(flag2[i]) then writeln(refer[i],' ',refer[i+m]);
                if (refer[i]=refer[i+m]) and (not(flag2[i])) then begin
                    //writeln(refer[i]);
                    writeln('NO');
                    exit;
                end;
            end;
        writeln('YES');
    end;
Begin
    readln(t);
    for i:=1 to t do begin
        fillchar(flag,sizeof(flag),0);
        fillchar(flag2,sizeof(flag2),false);
        fillchar(list,sizeof(list),0);
        fillchar(refer,sizeof(refer),0);
        fillchar(dfn,sizeof(dfn),0);
        fillchar(low,sizeof(low),0);
        top:=0;
        time:=0;
        tot:=0;
        cnt:=0;
        if build then work;
    end;
End.
```

---


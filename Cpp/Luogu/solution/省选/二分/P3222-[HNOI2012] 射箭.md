# [HNOI2012] 射箭

## 题目描述

沫沫最近在玩一个二维的射箭游戏，如下图 $1$ 所示，这个游戏中的 $x$ 轴在地面，第一象限中有一些竖直线段作为靶子，任意两个靶子都没有公共部分，也不会接触坐标轴。

沫沫控制一个位于 $(0,0)$ 的弓箭手，可以朝 $0$ 至 $90$ 中的任意角度（不包括 $0$ 度和 $90$ 度），以任意大小的力量射出带有穿透能力的光之箭。由于游戏中没有空气阻力，并且光之箭没有箭身，箭的轨迹会是一条标准的抛物线，被轨迹穿过的所有靶子都认为被沫沫射中了，包括那些只有端点被射中的靶子。

这个游戏有多种模式，其中沫沫最喜欢的是闯关模式。

在闯关模式中，第一关只有一个靶子，射中这个靶子即可进入第二关，这时在第一关的基础上会出现另外一个靶子，若能够一箭双雕射中这两个靶子便可进入第三关，这时会出现第三个靶子。依此类推，每过一关都会新出现一个靶子，在第 $K$ 关必须一箭射中前 $K$ 关出现的所有 $K$ 个靶子才能进入第 $K+1$ 关，否则游戏结束。

沫沫花了很多时间在这个游戏上，却最多只能玩到第七关“七星连珠”，这让她非常困惑。于是她设法获得了每一关出现的靶子的位置，想让你告诉她，最多能通过多少关？

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/jv279yqz.png)

### 数据范围及约定

- $30\%$ 的数据满足 $N \le 100$；
- $50\%$ 的数据满足 $N \le 5000$；
- $100\%$ 的数据满足 $N \le 100000$ 且给出的所有坐标不超过 $10^9$。

## 样例 #1

### 输入

```
5
2  8 12
5  4 5
3  8 10
6  2 3
1  3 7```

### 输出

```
3```

# 题解

## 作者：FlashHu (赞：11)

设抛物线方程为$y=ax^2+bx(a<0,b>0)$，我们想要求出一组$a,b$使得它尽可能满足更多的要求。这个显然可以二分答案。

如何check当前的$mid$是否合法呢？每一个限制条件形如$y_{i_1}\le ax_i^2+bx_i\le y_{i_2}$，也就是$\frac{y_{i_1}}{x_i}\le x_ia+b\le \frac{y_{i_2}}{x_i}$。把$a,b$看成自变量，实际上每个不等式就是一个半平面，我们需要求出半平面交。

需要掌握向量、叉积等少量基础算法（不过做到这题的大佬们肯定会了），可以参考[xzy巨佬的总结](https://www.cnblogs.com/xzyxzy/p/10033130.html)。

有一种$O(n^2)$的动态插入半平面的做法，可以通过原题数据（目前最优解第一版大部分是这种写法），也可以参考xzy巨佬的总结。

蒟蒻构造了一组边数很多的半平面交，可以卡掉这种写法，目前rank1的代码本机需要20s以上。

一些hack数据可以从这里下（部分转自liu_runda）

链接: https://pan.baidu.com/s/1Te0G-L2JrRu361qKAGorhQ

提取码: ea9m 

谈一谈正经的$O(n\log n)$的实现吧。以下内容从[蒟蒻的总结](https://www.cnblogs.com/flashhu/p/10258638.html)里㧟的。

我们用有向直线（一个点和一个方向向量）表示半平面，以下默认半平面在有向直线的左侧。

对有向直线按方向向量的极角排序，维护一个双端队列，存储当前构成半平面的直线以及相邻两直线的交点。

每次加入一条有向直线，如果队首/队尾的交点在直线右侧（用叉积判）则弹掉队首/队尾的直线。

为什么这样是对的呢？因为加入直线的单调性，所以要被弹出的直线一定在队首或队尾。感兴趣的话可以自己手画一些例子来理解。

需要注意的细节：
1. 加入直线时，先弹队尾，再弹队首。
2. 最后还要检查队尾交点是否在队首直线的右侧，如果是也要弹掉。
3. 特判平行直线，在右侧的要弹掉。
4. 如果题目给出的半平面不一定有限制边界，则应该手动加入一个INF边界。

算法的复杂度瓶颈在排序，因此预先将这些有向直线排好序，二分check时忽略编号大于mid的直线就可以了。时间复杂度$O(n\log n)$。

注意这题的坐标范围是$1e9$范围，因此INF设到$1e10$以上，EPS设到$1e-10$以下。
```cpp
#include<bits/stdc++.h>
#define RG register
#define I inline
#define R RG int
#define G if(++ip==ie)if(fread(ip=buf,1,SZ,stdin))
using namespace std;
typedef double DB;
const int SZ=1<<19,N=2e5+9;
const DB INF=1e11,EPS=1e-11;
char buf[SZ],*ie=buf+SZ,*ip=ie-1;
inline int in(){
	G;while(*ip<'-')G;
	R x=*ip&15;G;
	while(*ip>'-'){x*=10;x+=*ip&15;G;}
	return x;
}
struct Vec{
	DB x,y;
	I Vec(){}
	I Vec(DB a,DB b){x=a;y=b;}
	I Vec operator+(Vec a){return Vec(x+a.x,y+a.y);}
	I Vec operator-(Vec a){return Vec(x-a.x,y-a.y);}
	I Vec operator*(DB a){return Vec(x*a,y*a);}//数乘
	I DB operator^(Vec a){return x*a.y-y*a.x;}//叉积
}k[N];
struct Line{
	Vec p,v;DB ang;int id;
	I Line(){}
	I Line(Vec a,Vec b,R c){p=a,v=b-a,ang=atan2(v.y,v.x),id=c;}
	I bool operator<(Line&a){return ang<a.ang;}
	I bool Right(Vec&a){return (v^(a-p))<-EPS;}
	I friend Vec Cross(Line&a,Line&b){//求直线交点
		return a.p+a.v*((b.v^(b.p-a.p))/(b.v^a.v));
	}
}a[N],q[N];
int p=0,l=1,r,mid;
bool HalfPlane(Line*a,Line*e){//求半平面是否有交
	R n=e-a,i=0,h=0,t=0;
	while(a[i].id>mid)++i;
	for(q[0]=a[i++];i<n;++i){
		if(a[i].id>mid)continue;
		while(h<t&&a[i].Right(k[t-1]))--t;
		while(h<t&&a[i].Right(k[h]))++h;
		if(a[i].ang!=q[t].ang)q[++t]=a[i];
		else if(a[i].Right(q[t].p))q[t]=a[i];
		if(h<t)k[t-1]=Cross(q[t-1],q[t]);
	}
	while(h<t&&q[h].Right(k[t-1]))--t;
	return t-h>1;
}
int main(){
	r=in();
	for(R i=1;i<=r;++i){
		DB x=in(),y1=in(),y2=in();
		a[++p]=Line(Vec(0,y1/x),Vec(1,y1/x-x),i);
		a[++p]=Line(Vec(1,y2/x-x),Vec(0,y2/x),i);
	}//边界要设EPS不能设0，因为a、b为0均不合题意
	a[++p]=Line(Vec(-INF,EPS),Vec(-EPS,EPS),0);
	a[++p]=Line(Vec(-EPS,EPS),Vec(-EPS,INF),0);
	a[++p]=Line(Vec(-EPS,INF),Vec(-INF,INF),0);
	a[++p]=Line(Vec(-INF,INF),Vec(-INF,EPS),0);
	sort(a+1,a+p+1);
	while(l<r){
		mid=(l+r+1)>>1;
		HalfPlane(a+1,a+p+1)?l=mid:r=mid-1;
	}
	cout<<l<<endl;
	return 0;
}
```

---

## 作者：nofind (赞：4)

## [题意](https://www.luogu.com.cn/problem/P3222)

考虑二分答案，我们只需要判断是否存在$(a,b)$，对于任意$i\in[1,mid]$满足$ax_i^2+bx_i\in[y_{1i},y_{2i}]$。

展开可得：  
$\frac{y_{1i}}{x_i}\leqslant ax_i+b\leqslant\frac{y_{2i}}{x_i}$  
即：  
$ax_i+b-\frac{y_{1i}}{x_i}\geqslant 0$  
$ax_i+b-\frac{y_{12}}{x_i}\leqslant 0$

将$a,b$当成$x,y$，这是两条直线，我们半平面交判断即可。

~~然后这题卡精度卡了我一下午，我也是真有耐心。~~

code:
```
#include<bits/stdc++.h>
using namespace std;
#define double long double
const int maxn=100010;
const double eps=1e-18;
const double inf=1e12;
int n,m;
struct Point
{
    double x,y;
    inline double len(){return sqrt(x*x+y*y);}
    Point operator+(const Point a)const{return (Point){x+a.x,y+a.y};}
    Point operator-(const Point a)const{return (Point){x-a.x,y-a.y};}
    Point operator*(const double k){return (Point){x*k,y*k};}
    Point operator/(const double k){return (Point){x/k,y/k};}
    double operator*(const Point a)const{return x*a.y-y*a.x;}
    double operator&(const Point a)const{return x*a.x+y*a.y;}
};
inline int dcmp(double x)
{
    if(fabs(x)<=eps)return 0;
    return x<0?-1:1;
} 
inline Point get(Point a,Point b){return b-a;}
struct Line
{
    Point p,v;int id;double theta;
    bool operator<(const Line a)const
    {
        return !dcmp(theta-a.theta)?dcmp(get(p,v)*get(p,a.v))<0:dcmp(theta-a.theta)<0;
    } 
}line[maxn<<1],tmp[maxn<<1],q[maxn<<1];
inline Point getpoint(Line a,Line b)
{
    Point p1=a.p,p2=b.p,v1=a.v,v2=b.v;
    v1=get(p1,v1),v2=get(p2,v2);
    Point u=get(p1,p2);
    return p2+v2*(u*v1)/(v1*v2);
}
inline bool check(Line a,Line b,Line c)
{
    Point p=getpoint(a,b);
    return dcmp(get(c.p,c.v)*get(c.p,p))<0;
}
inline bool check_ans(int mid)
{
    int l=1,r=0,cnt=0;
    for(int i=1;i<=m;i++)
    	if(line[i].id<=mid&&line[i].theta!=tmp[cnt].theta)tmp[++cnt]=line[i];
    for(int i=1;i<=cnt;i++)
    {
        while(l<r&&check(q[r-1],q[r],tmp[i]))r--;
        while(l<r&&check(q[l],q[l+1],tmp[i]))l++;
        q[++r]=tmp[i];
    }
    while(l<r&&check(q[r-1],q[r],q[l]))r--;
    while(l<r&&check(q[l],q[l+1],q[r]))l++;
    return r-l+1>=3;
}
int main()
{
	//freopen("test.in","r",stdin);
	//freopen("test.out","w",stdout);
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		double x,y1,y2;scanf("%Lf%Lf%Lf",&x,&y1,&y2);
		line[++m]=(Line){(Point){0,y1/x},(Point){1,y1/x-x},i,0};
		line[++m]=(Line){(Point){1,y2/x-x},(Point){0,y2/x},i,0};
	}
	line[++m]=(Line){(Point){-inf,eps},(Point){-eps,eps},0,0};
	line[++m]=(Line){(Point){-eps,eps},(Point){-eps,inf},0,0};
	line[++m]=(Line){(Point){-eps,inf},(Point){-inf,inf},0,0};
	line[++m]=(Line){(Point){-inf,inf},(Point){-inf,eps},0,0};
	for(int i=1;i<=m;i++)line[i].theta=atan2(line[i].v.y-line[i].p.y,line[i].v.x-line[i].p.x);
    sort(line+1,line+m+1);
	int l=1,r=n,res=0;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(check_ans(mid))res=mid,l=mid+1;
		else r=mid-1;
	}
	printf("%d\n",res);
	return 0;
}
```


---

## 作者：liaohaoping (赞：4)

不难发现，箭的轨迹刚好满足一个二次函数y=ax²+bx的图象，且a<0,b>0,x>0，对于每个靶子，如果下端的纵坐标为y1，上端的纵坐标为y2，横坐标为x(x>0)，若箭穿过靶子，则必定满足：y1<=ax²+bx<=y2,我们可以对上面得到的不等式进行化简，得：y1/x<=ax+b<=y2/x。

为了方便，我们设xx=a,yy=b,aa=x,bb=y1/x,cc=y2/x，则可得：bb<=aaxx+yy<=cc，我们取最极端的值，即：aaxx+yy=b,aaxx+yy=c，进一步化简，得：yy=-aaxx+bb,yy=-aaxx+cc。由于aa、cc已知，我们可以发现，这是两条直线的解析式，xx、yy就是我们要求的a,b，那么满足条件的a与b即为两直线中间的点。

二分答案，那么就相当于给你若干个半平面，判断是否有相交的部分。可以通过半平面交来实现。

```cpp
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <algorithm>
using namespace std;
inline int read()
{
    int x=0,w=0;char ch=getchar();
    while(ch<'0'||ch>'9')w|=ch=='-',ch=getchar();
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return w?-x:x;
}
inline void write(int x)
{
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+48);
}
double maxx=1e10,minn=-1e10,eps=1e-10;
struct point{double x,y;}plist[200050];
struct segment
{
    point p1,p2;
    double angle;int belong;
         
    segment(){}
    segment(double x1,double y1,double x2,double y2){p1.x=x1;p1.y=y1;p2.x=x2;p2.y=y2;}
    void get_angle (){ angle=atan2(p2.y-p1.y,p2.x-p1.x); }
         
}seg[200050],seg1[200050],sglist[200050];
int head,tail,n,m,o,nn;
inline double multi(point p1,point p2,point p0)
{
    double x1=p1.x-p0.x;
    double x2=p2.x-p0.x;
    double y1=p1.y-p0.y;
    double y2=p2.y-p0.y;
    return x1*y2-x2*y1;
}
inline point jd(segment sg1,segment sg2)
{
    double t1=multi(sg1.p1,sg2.p2,sg2.p1);
    double t2=multi(sg1.p2,sg2.p2,sg2.p1);
         
    segment sg=sg1;
    point p,p1,p2;
    p1=sg.p1;p2=sg.p2;
    p.x=(t1*p2.x-t2*p1.x)*1.0/(t1-t2);
    p.y=(t1*p2.y-t2*p1.y)*1.0/(t1-t2);
    return p;
}
inline bool satisfy(point p,segment sg)
{
    if(multi(p,sg.p2,sg.p1)<=eps)return 1;else return 0;
}
inline bool cmp(segment sg1,segment sg2)
{
    if(sg1.angle<sg2.angle)return 1;
    if( fabs( sg1.angle-sg2.angle )<eps && satisfy(sg1.p1,sg2) )return 1;
    return 0;
}
bool check()
{
    register int n=0;for(register int i=1;i<=nn;++i)if( seg[i].belong<=o&&( seg[i].angle>seg1[n].angle||!n ) )seg1[++n]=seg[i];
      
    sglist[1]=seg1[1];sglist[2]=seg1[2];
    head=1;tail=2;
         
    for(register int i=3;i<=n;++i)
    {
        while( head<tail && !satisfy( jd( sglist[tail],sglist[tail-1] ),seg1[i] ) )tail--;
        while( head<tail && !satisfy( jd( sglist[head],sglist[head+1] ),seg1[i] ) )head++;
        sglist[++tail]=seg1[i];
    }
      
    while( head<tail && !satisfy( jd( sglist[tail],sglist[tail-1] ),sglist[head] ) )tail--;
    while( head<tail && !satisfy( jd( sglist[head],sglist[head+1] ),sglist[tail] ) )head++;
      
    if(tail-head+1<=2)return 0;return 1;
}
int main()
{
    m=read();nn=4;
    seg[1]=segment(0,0,0,1),seg[1].get_angle(),seg[1].belong=0;
    seg[2]=segment(0,0,1,0),seg[2].get_angle(),seg[2].belong=0;
    seg[3]=segment(maxx,maxx,minn,maxx),seg[3].get_angle(),seg[3].belong=0;
    seg[4]=segment(minn,maxx,minn,minn),seg[4].get_angle(),seg[3].belong=0;
    double a,yy1,yy2;
    for(register int i=1;i<=m;++i)
    {
        a=read(),yy1=read(),yy2=read();
        double b=yy1*1.0/a,c=yy2*1.0/a;
        seg[++nn]=segment(0,b,1,b-a),seg[nn].get_angle(),seg[nn].belong=i;
        seg[++nn]=segment(1,c-a,0,c),seg[nn].get_angle(),seg[nn].belong=i;
    }
    sort(seg+1,seg+nn+1,cmp);
    register int l=2,r=m,ans=1;
    while(l<=r)
    {
        o=(l+r)>>1;
        if(check())ans=o,l=o+1;
        else r=o-1;
    }
    write(ans);
    return 0;
}
```

---

## 作者：MaxBlazeResFire (赞：0)

前言：本题 **卡常 + 卡精度**。~~我左改右改上改下改先改 eps 再改 inf 再调靶子再判斜率再判边界最后对着题解对拍改式子前前后后交了将近三十发终于过了。~~

---

答案具有单调性，容易想到二分答案。

一个靶子 $(u,v_1,v_2)$ 被 $ax^2+bx(a<0,b>0)$ 打的条件是 $v_1\leq au^2+bu\leq v_2$，也即 $\displaystyle\frac{v_1}{u}\leq au+b\leq\frac{v_2}{u}$。

令 $a,b$ 为自变量，这个限制等同于 $\displaystyle au+b-\frac{v_1}{u}\geq 0,\displaystyle au+b-\frac{v_2}{u}\leq 0$，这是两个半平面的限制，我们发现，当这两个半平面与 **第二象限** 有交时，这个限制才满足。

于是问题转化为求 $2\times\rm mid$ 个半平面与第二象限的交的问题，复杂度 $O(n\log n)$。

---

如果你写完了上面的东西就过了，那我必须祝贺你。

接下来是卡题时间！

首先为了求出和第二象限的交，我们用以下直线把第二象限围起来：

```cpp
segment( vec2( -eps2 , eps2 ) , vec2( -eps2 , INF ) ) 
segment( vec2( -eps2 , INF ) , vec2( -INF , INF ) ) 
segment( vec2( -INF , INF ) , vec2( -INF , eps2 ) ) 
segment( vec2( -INF , eps2 ) , vec2( -eps2 , eps2 ) )
```

注意向量的方向问题；同理地，若我们在这里选择左侧半平面，上面所有不等号为 $\geq$ 的不等式，我们需要将其左边取反后变为 $\leq$。

然后，我们需要将不等式变为向量。可以简单地选择直线上的两个点，一开始我选择了 $\displaystyle(0,\frac{v_1}{u})$ 与 $\displaystyle(\frac{v_1}{u^2},0)$，然后死活被卡精度。于是为了减少浮点数多次计算带来可能的风险，我最终选择了某题解的取值 $\displaystyle(0,\frac{v_1}{u})$ 与 $\displaystyle(1,\frac{v_1}{u}-u)$。同样注意方向的问题。

然后就是注意极角问题。求半平面交时按照极角排序，若当前斜极角与队尾极角相同并且位于队尾直线右侧，不要把它加入队列中。

注意本题的范围达到了 $10^9$，并且可能出现极其毒瘤的半平面交于一个点的情况，可以考虑：

将 eps 开到 $10^{-18}$，inf 开到 $10^{17}$；

最开始对靶子上下界进行微小扰动。

注意额外的边界问题。队列中可能含有极大的包围第二象限平面的直线，注意特判。

最后，祝大家早日卡过此题。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
#define double long double
#define MAXN 400005
#define eps 1e-18
#define eps2 1e-18
#define INF 1e17

struct vec2{
	double x,y;
	vec2( double a = 0 , double b = 0 ): x(a),y(b){}
	inline vec2 operator +( vec2 B ){ return vec2( x + B.x , y + B.y ); }
	inline vec2 operator -( vec2 B ){ return vec2( x - B.x , y - B.y ); }
	inline vec2 operator *( double k ){ return vec2( x * k , y * k ); }
};

struct segment{
	vec2 s,t,v;
	double ang;
	segment(){}
	segment( vec2 S , vec2 T ){ s = S,t = T,v = T - S,ang = atan2( v.y , v.x ); }
};

struct trap{
	segment s;
	int id;
	trap(){}
	trap( segment S , int Id ): s(S),id(Id){}
}Q[MAXN];

inline double Cross( vec2 A , vec2 B ){ return A.x * B.y - A.y * B.x; }
inline bool Right( vec2 P , segment S ){ return Cross( P - S.s , S.v ) > eps; }
inline vec2 interp( segment A , segment B ){
	vec2 u = A.s - B.s; double t = Cross( B.v , u ) / Cross( A.v , B.v );
	return A.s + A.v * t;
}
inline bool cmp( segment A , segment B ){ return fabs( A.ang - B.ang ) < eps ? Right( B.s , A ) : A.ang < B.ang; }
inline bool cmptrap( trap A , trap B ){ return cmp( A.s , B.s ); }

inline bool Halfplane( vector<trap> Sv , int mid ){
	int f = 1,r = 0,len = Sv.size();
	for( int i = 0 ; i < len ; i ++ ){
		if( Sv[i].id > mid ) continue;
		while( f < r && Right( interp( Q[r].s , Q[r - 1].s ) , Sv[i].s ) ) r --;
		while( f < r && Right( interp( Q[f].s , Q[f + 1].s ) , Sv[i].s ) ) f ++;
		if( fabs( Sv[i].s.ang - Q[r].s.ang ) > eps ) Q[++r] = Sv[i];
	}
	while( f < r && Right( interp( Q[r].s , Q[r - 1].s ) , Q[f].s ) ) r --;
	return r - f + 1 >= 3;
}

int n;

signed main(){
	scanf("%lld",&n);
	vector<trap> T;
	for( int i = 1 ; i <= n ; i ++ ){
		int x,y_1,y_2; scanf("%lld%lld%lld",&x,&y_1,&y_2);
		double a = x,b = y_1,c = y_2;
		T.emplace_back( trap( segment( vec2( 0 , 1.0 * b / a ) , vec2( 1 , 1.0 * b / a - a ) ) , i ) );
		T.emplace_back( trap( segment( vec2( 1 , 1.0 * c / a - a ) , vec2( 0 , 1.0 * c / a ) ) , i ) );
	}
	T.emplace_back( trap( segment( vec2( -eps2 , eps2 ) , vec2( -eps2 , INF ) ) , 0 ) );
	T.emplace_back( trap( segment( vec2( -eps2 , INF ) , vec2( -INF , INF ) ) , 0 ) );
	T.emplace_back( trap( segment( vec2( -INF , INF ) , vec2( -INF , eps2 ) ) , 0 ) );
	T.emplace_back( trap( segment( vec2( -INF , eps2 ) , vec2( -eps2 , eps2 ) ) , 0 ) );
	sort( T.begin() , T.end() , cmptrap );
	int l = 1,r = n,Ans = 0;
	while( l <= r ){
		int mid = ( l + r ) >> 1;
		if( Halfplane( T , mid ) ) Ans = mid,l = mid + 1;
		else r = mid - 1;
	}
	printf("%lld\n",Ans);
	return 0;
}
```

---


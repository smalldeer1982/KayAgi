# [SDOI2015] 星际战争

## 题目描述

$3333$ 年，在银河系的某星球上，X 军团和 Y 军团正在激烈地作战。

在战斗的某一阶段，Y 军团一共派遣了 $N$ 个巨型机器人进攻 X 军团的阵地，其中第 $i$ 个巨型机器人的装甲值为 $A_i$。当一个巨型机器人的装甲值减少到 $0$ 或者以下时，这个巨型机器人就被摧毁了。

X 军团有 $M$ 个激光武器，其中第 $i$ 个激光武器每秒可以削减一个巨型机器人 $B_i$ 的装甲值。激光武器的攻击是连续的。

这种激光武器非常奇怪，一个激光武器只能攻击一些特定的敌人。Y 军团看到自己的巨型机器人被 X 军团一个一个消灭，他们急需下达更多的指令。

为了这个目标，Y 军团需要知道 X 军团最少需要用多长时间才能将 Y 军团的所有巨型机器人摧毁。但是他们不会计算这个问题，因此向你求助。

## 说明/提示

**【样例说明1】**

战斗开始后的前 $0.5$ 秒，激光武器 $1$ 攻击 $2$ 号巨型机器人，激光武器 $2$ 攻击 $1$ 号巨型机器人。$1$ 号巨型机器人被完全摧毁，$2$ 号巨型机器人还剩余 $8$ 的装甲值；

接下来的 $0.8$ 秒，激光武器 $1$ 、 $2$ 同时攻击 $2$ 号巨型机器人。$2$ 号巨型机器人被完全摧毁。

**【数据范围】**

对于全部的数据，$1 \le N,M \le 50$，$1 \le A_i \le 10^5$，$1 \le B_i \le 1000$，输入数据保证 X 军团一定能摧毁 Y 军团的所有巨型机器人。

[spj]

## 样例 #1

### 输入

```
2 2
3 10
4 6
0 1
1 1```

### 输出

```
1.300000```

# 题解

## 作者：Orion545 (赞：11)

# 广告

[蒟蒻のblog](http://www.cnblogs.com/dedicatus545/p/8845918.html)

# 正文

首先，有一个非常明显的模型：

将激光武器放到一边，机器人放到另一边，从每一个激光武器向它可以攻击的机器人连边，形成一个二分图

建立附加源点$ss$和附加汇点$tt$，$ss$连所有激光武器，$tt$连所有机器人，跑网络流算法

但是，问题在于这道题“武器的攻击是连续的”，也就是解是实数解

这使得我一开始想的费用流算法失效了

时间为实数，就说明我们不能把时间当成费用来看，那么该怎么办呢？

我们考虑把实数时间从费用的位置转到流量的位置去

但是流量在一开始就是确定的，最大流跑出来的结果只能用来判断是否是一个解

既然这样，我们就使用二分的方法，将最优化问题转化为判断性问题

二分时间t，每一次对于t，按照如下方式建边（以下用$\left(u,v,w\right)$表示u到v的流量为w的有向边）

对于每一个激光武器i，建边$\left(ss,i,B\left[i\right]\ast t\right)$

对于激光武器i可以攻击的机器人，建边$\left(i,j,inf\right)$

对于每一个机器人j，建边$\left(j,tt,A\left[j\right]\right)$

如果最大流流量等于所有机器人的生命之和，那么r=mid，否则l=mid+1

因为精度要求只有1e-3，所以把所有生命和时间都乘一个10000处理，要开long long 

# Code:

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define inf 1e15
#define ll long long
using namespace std;
inline ll read(){
	ll re=0,flag=1;char ch=getchar();
	while(ch>'9'||ch<'0'){
		if(ch=='-') flag=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
	return re*flag;
}
ll n,m,cnt=-1,first[210],dep[210],cur[210];
struct edge{
	ll to,next,w;
}a[100010];
void add(ll u,ll v,ll w){
	a[++cnt]=(edge){v,first[u],w};first[u]=cnt;
	a[++cnt]=(edge){u,first[v],0};first[v]=cnt;
}
bool bfs(ll s,ll t){
	ll q[210],head=0,tail=1,i,u,v;
	for(i=s;i<=t;i++) dep[i]=-1,cur[i]=first[i];
	q[0]=s;dep[s]=0;
	while(head<tail){
		u=q[head++];
		for(i=first[u];~i;i=a[i].next){
			v=a[i].to;
			if(~dep[v]||!a[i].w) continue;
			dep[v]=dep[u]+1;q[tail++]=v;
		}
	}
	return ~dep[t];
}
ll dfs(ll u,ll t,ll limit){
	if(u==t||!limit) return limit;
	ll i,v,f,flow=0;
	for(i=first[u];~i;i=a[i].next){
		v=a[i].to;
		if(dep[v]==dep[u]+1&&(f=dfs(v,t,min(limit,a[i].w)))){
			a[i].w-=f;a[i^1].w+=f;
			flow+=f;limit-=f;
			if(!limit) return flow;
		}
	}
	return flow;
}
ll dinic(ll s,ll t){
	ll re=0;
	while(bfs(s,t)) re+=dfs(s,t,inf);
	return re;
}
bool x[60][60];ll hp[60],atk[60],sum=0;
void init(){
	memset(first,-1,sizeof(first));memset(a,0,sizeof(a));cnt=-1;
}
void build(ll t){
	ll ss=0,tt=n+m+1,i,j;
	for(i=1;i<=m;i++) add(ss,i,t*atk[i]);
	for(i=1;i<=n;i++) add(i+m,tt,hp[i]);
	for(i=1;i<=m;i++){
		for(j=1;j<=n;j++){
			if(x[i][j]) add(i,j+m,inf);
		}
	}
}
int main(){
	n=read();m=read();ll i,j,le,ri,mid,ans;
	for(i=1;i<=n;i++) hp[i]=read(),hp[i]*=10000ll,sum+=hp[i];
	for(i=1;i<=m;i++) atk[i]=read();
	for(i=1;i<=m;i++){
		for(j=1;j<=n;j++) x[i][j]=read();
	}
	le=0;ri=100000000000ll;
	while(le<ri){
		mid=(le+ri)>>1ll;
		init();
		build(mid);
		ans=dinic(0,n+m+1);
		if(ans<sum) le=mid+1;
		else ri=mid;
	}
	printf("%.4lf",(double)le/10000.0);
}
```

---

## 作者：XenonKnight (赞：1)

> ### 洛谷 P3324

我们可以二分答案。由于精度只有 $10^{-3}$，我们可以采取同步扩大 $10000$ 倍，然后将答案除以 $10000$ 的方式。（不过在实数域上二分也没有问题）

我们二分出一个 $x$，那么一台发射器在规定时间内所能输出的攻击也就确定了。我们可以对于每一台发射器 $i$，连一条从源点到这个发射器的边，容量为这台发射器在 $x$ 的时间内能够输出的攻击，即 $b_i \times x$，对于每一个机器人 $j$，连一条从这个机器人到汇点，流量为 $a_j$，中间对于每一台发射器 $i$ 和每一个机器人 $j$，如果 $i$ 可以攻击到 $j$，就在 $i$ 与 $j$ 之间连边，容量为 $\infty$。然后跑最大流，如果最大流 $= \sum{a_i}$，那么说明在 $x$ 的时间内可以摧毁所有的机器人。否则说明不行。

顺便吐槽一下，这个出题人数据造得真的是…………我把 $n$ 写成 $m$ 都可以拿 $90$ 分。

```cpp
/*
数据不清空，爆零两行泪。
多测不读完，爆零两行泪。
边界不特判，爆零两行泪。
贪心不证明，爆零两行泪。
D P 顺序错，爆零两行泪。
大小少等号，爆零两行泪。
变量不统一，爆零两行泪。
越界不判断，爆零两行泪。
调试不注释，爆零两行泪。
溢出不 l l，爆零两行泪。
*/
#include <bits/stdc++.h>
using namespace std;
#define fi			first
#define se			second
#define fz(i,a,b)	for(int i=a;i<=b;i++)
#define fd(i,a,b)	for(int i=a;i>=b;i--)
#define put(x)		putchar(x)
#define eoln        put('\n')
#define space		put(' ')
#define int long long
inline int read(){
	int x=0,neg=1;char c=getchar();
	while(!isdigit(c)){
		if(c=='-')	neg=-1;
		c=getchar();
	}
	while(isdigit(c))	x=x*10+c-'0',c=getchar();
	return x*neg;
}
inline void print(int x){
	if(x<0){
		putchar('-');
		print(abs(x));
		return;
	}
	if(x<=9)	putchar(x+'0');
	else{
		print(x/10);
		putchar(x%10+'0');
	}
}
int n=read(),m=read(),a[55],b[55],x[55][55],sum=0;
int head[100005];
struct edge{
	int to,nxt,cap;
} e[300005];
int ecnt=1;
inline void addedge(int u,int v,int f){
	e[++ecnt].to=v;e[ecnt].cap=f;e[ecnt].nxt=head[u];head[u]=ecnt;
}
int dep[100005];
inline bool bfs(int s,int t){
	queue<int> q;
	memset(dep,-1,sizeof(dep));
	q.push(s);dep[s]=0;
	while(!q.empty()){
		int cur=q.front();q.pop();
		for(int i=head[cur];i;i=e[i].nxt){
			int to=e[i].to;
			if(dep[to]==-1&&e[i].cap){
				dep[to]=dep[cur]+1;
				q.push(to);
			}
		}
	}
	if(dep[t]!=-1)	return 1;
	return 0;
}
inline int dfs(int x,int t,int f){
	if(x==t)	return f;
	int ret=0;
	for(int i=head[x];i;i=e[i].nxt){
		int y=e[i].to;
		if(dep[y]==dep[x]+1&&e[i].cap){
			int w=dfs(y,t,min(f-ret,e[i].cap));
			e[i].cap-=w;
			e[i^1].cap+=w;
			ret+=w;
			if(ret==f)	return f;
		}
	}
	return ret;
}
inline int Dinic(int s,int t){
	int tot=0;
	while(bfs(s,t))	tot+=dfs(s,t,0x3f3f3f3f3f3f3f3fll);
	return tot;
}
inline bool check(int mid){
	ecnt=1;memset(head,0,sizeof(head));
	fz(i,1,m){
		addedge(0,i,b[i]*mid);
		addedge(i,0,0);
	}
	fz(i,1,m){
		fz(j,1,n){
			if(x[i][j]){
				addedge(i,j+m,0x3f3f3f3f3f3f3f3fll);
				addedge(j+m,i,0);
			}
		}
	}
	fz(i,1,n){
		addedge(i+m,n+m+1,a[i]);
		addedge(n+m+1,i+m,0);
	}
	return Dinic(0,n+m+1)==sum;
}
signed main(){
	fz(i,1,n)	a[i]=read(),a[i]*=1e4,sum+=a[i];
	fz(i,1,m)	b[i]=read();
	fz(i,1,m)	fz(j,1,n)	x[i][j]=read();
	int l=1,r=1ll<<38,ans=0;
	while(l<=r){
		int mid=(l+r)>>1;
		if(check(mid))	r=mid-1,ans=mid;
		else			l=mid+1;
	}
	printf("%.5lf\n",ans/10000.0);
	return 0;
}
```

---

## 作者：xyz32768 (赞：1)

最大流+二分答案。

首先二分答案time，对于每一个time值，建立源点S和汇点T，由源点S向每个激光武器连一条容量为time\*b[i]的边，由每个巨型机器人向汇点连一条容量a[i]的边，由每个激光武器向其所有可攻击的巨型机器人连一条容量为INF的边。跑一遍最大流，判断S->T的最大流是否大于等于∑a[i]。

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const double eps = 1e-9, INF = 1e12;
const int M = 55, N = 2e5 + 5;
int n, m, a[M], b[M], ecnt = 1, nxt[N], adj[N], go[N], lev[N],
len, que[N], cur[N], S, T, g[M][M], sm; double cap[N], Cap[N];
void add_edge(int u, int v, double w) {
    nxt[++ecnt] = adj[u]; adj[u] = ecnt;
    go[ecnt] = v; cap[ecnt] = w;
    nxt[++ecnt] = adj[v]; adj[v] = ecnt;
    go[ecnt] = u; cap[ecnt] = 0;
}
bool bfs() {
    int i; for (i = S; i <= T; i++) lev[i] = -1, cur[i] = adj[i];
    que[len = 1] = S; lev[S] = 0;
    for (i = 1; i <= len; i++) {
        int u = que[i];
        for (int e = adj[u], v; e; e = nxt[e])
            if (cap[e] > eps && lev[v = go[e]] == -1) {
                que[++len] = v; lev[v] = lev[u] + 1;
                if (v == T) return 1;
            }
    }
    return 0;
}
double dinic(int u, double flow) {
    if (u == T) return flow;
    double res = 0, d = 0;
    for (int &e = cur[u], v; e; e = nxt[e])
        if (cap[e] > eps && lev[u] < lev[v = go[e]]) {
            d = dinic(v, min(cap[e], flow - res));
            if (d > eps) {
                cap[e] -= d; cap[e ^ 1] += d;
                res += d; if (fabs(flow - res) <= eps)
                    break;
            }
        }
    if (fabs(flow - res) > eps) lev[u] = -1;
    return res;
}
double solve() {
    double ans = 0;
    while (bfs()) ans += dinic(S, INF);
    return ans;
}
void build(double tm) {
    int i; for (i = 2; i <= ecnt; i++)
        cap[i] = Cap[i];
    for (i = 2; i <= (m << 1) + 1; i += 2)
        cap[i] = tm * b[i >> 1];
}
double SOLVE() {
    double l = 0, r = 1e9, mid = (l + r) / 2;
    while (r - l >= eps) {
        build(mid);
        if (1.0 * sm - solve() < eps) r = mid;
        else l = mid;
        mid = (l + r) / 2;
    }
    return mid;
}
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
int main() {
    int i, j; n = read(); m = read();
    for (i = 1; i <= n; i++) a[i] = read(), sm += a[i];
    for (i = 1; i <= m; i++) b[i] = read();
    for (i = 1; i <= m; i++) for (j = 1; j <= n; j++)
        g[i][j] = read(); S = 1; T = n + m + 2;
    for (i = 2; i <= m + 1; i++) add_edge(S, i, 0);
    for (i = m + 2; i < T; i++) add_edge(i, T, 1.0 * a[i - m - 1]);
    for (i = 2; i <= m + 1; i++) for (j = m + 2; j < T; j++)
        if (g[i - 1][j - m - 1]) add_edge(i, j, INF);
    for (i = 2; i <= ecnt; i++) Cap[i] = cap[i];
    printf("%.6lf\n", SOLVE());
    return 0;
}
```

---

## 作者：破壁人 (赞：1)

分析:

首先我们可以发现，答案是可以进行二分的。

那么而分到一个答案m时如何判断其是否可行呢？

我们发现机器人的持续输出跟水流很像，我们可以建立网络流模型来判断。

首先建立S和T，每个激光武器向它可以攻击的机器人连容量无限大的边。

每个机器人向T连容量为Ai的边，S向每个激光武器连容量为Bi*m的边。

跑一遍最大流，看看连向T的边的残余容量是否都为零。

若是，则代表m可行，否则代表不可行。


代码：

```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>

using namespace std;

const int inf=1e9;

int n,m,S,T,a[51],b[51],d[201],f[201],e[201],cur[201];
int to[10001],next[10001],first[201],now,e1;
double w[10001],w1[10001],mi=inf;

void insert(int o,int p,int q)
{
    to[e1]=p;w1[e1]=q;next[e1]=first[o];first[o]=e1++;
    to[e1]=o;w1[e1]=0;next[e1]=first[p];first[p]=e1++;
}

bool check(double o)
{
    for(int i=0;i<=1e4;i++) w[i]=w1[i];
    for(int i=first[S];i!=-1;i=next[i]) w[i]=o*b[to[i]];
    memset(d,0,sizeof(d));
    memset(f,0,sizeof(f));
    memset(e,-1,sizeof(e));
    for(int i=0;i<=T;i++) cur[i]=first[i];
    e[S]=now=S;f[0]=T;
    while(d[S]<T)
    {
        bool bo=false;
        for(int &i=cur[now];i!=-1;i=next[i])
            if((w[i]>0)&&(d[now]==(d[to[i]]+1)))
            {
                mi=min(mi,w[i]);
                e[to[i]]=now;
                now=to[i];
                bo=true;
                if(now==T)
                {
                    while(now!=S)
                    {
                        w[cur[e[now]]]-=mi;
                        w[cur[e[now]]^1]+=mi;
                        now=e[now];
                    }
                    mi=inf;
                }
                break;
            }
        if(bo) continue;int mmi=T;
        for(int i=first[now];i!=-1;i=next[i])
            if((w[i]>0)&&(mmi>d[to[i]])){mmi=d[to[i]];cur[now]=i;}
        if(!(--f[d[now]])) break;
        f[d[now]=(mmi+1)]++;
        now=e[now];
    }
    bool bo=true;
    for(int i=first[T];i!=-1;i=next[i])
        if(w[i^1]!=0) return false;
    return true;
}

int main()
{
    memset(first,-1,sizeof(first));
    scanf("%d%d",&n,&m);
    S=n+m+1;T=S+1;
    for(int i=1;i<=n;i++) 
    {
        scanf("%d",&a[i]);
        insert(m+i,T,a[i]);
    }
    for(int i=1;i<=m;i++) 
    {
        scanf("%d",&b[i]);
        insert(S,i,0);
    }
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
        {
            int x;
            scanf("%d",&x);
            if(x) insert(i,m+j,inf);
        }
    double l=0,r=inf,mid;
    while(abs(r-l)>1e-4)
    {
        mid=(l+r)/2;
        if(check(mid)) r=mid;else l=mid;
    }
    printf("%.4lf\n",l);
    return 0;
}
```

---

## 作者：rhjoi (赞：0)


------
SOL
=


首先思考dp，发现一个合法的方案限制太多，难以dp。
$n,m\le50$，有点网络流的味道

思考贪心，即在相同的时间内，让所有机器人的总输出尽量大，构造方案可以最大流；

建图：机器人向汇点连容量为装甲值的边，源点向激光炮连边，根据激光炮和机器人的攻击关系连容量为inf的边。
源点向$i$激光炮连边容量为  $b_{i}*t$，二分$t$，判断总流量能否达到 $\sum_{i=1}^n A{i}$；


------
CODE
=

```cpp
#include<bits/stdc++.h>
using namespace std;
#define sf scanf
#define pf printf
#define ll long long
#define db double
#define cs const
cs int N=1e4+10,mov=50;
ll inf=1e18;
cs db eps=1e-7,eps2=1e-4;
int nxt[N],to[N],head[N],cnt=1,S,T,n,m,A;
ll w[N];
inline void _add(int u,int v,ll ww){
	nxt[++cnt]=head[u];head[u]=cnt;to[cnt]=v;w[cnt]=ww;
}
//inline bool equal(cs db &a,cs db &b){
//	return abs(a-b)<eps;
//}
namespace dinic{
	int dep[N],cur[N];
	db c[N];
	inline bool bfs(){
		for(int i=S;i<=T;++i)dep[i]=-1;
		queue<int> q;
		q.push(T);dep[T]=1;
		while(!q.empty()){
			int u=q.front();q.pop();
			for(int i=head[u];i;i=nxt[i]){
				if(c[i^1]<eps)continue;
				int v=to[i];
				if(v==S){
					dep[v]=dep[u]+1;
					return 1;
				}
				if(dep[v]==-1){
					dep[v]=dep[u]+1;
					q.push(v);
				}
			}
		}
		return 0;
	}
	inline db dfs(int u,db f){
		
		if(u==T)return f;
		if(f<eps)return 0;
		db tot=0,now=0;
		for(int &i=cur[u];i;i=nxt[i]){
		//	cout<<to[i]<<' '<<f<<'\n';
			if(c[i]<eps)continue;
			int v=to[i];
			
			if(dep[v]==dep[u]-1){
				now=dfs(v,min(f-tot,c[i]));
				if(!now)continue;
				tot+=now;
				c[i]-=now;c[i^1]+=now;
				if(f-tot<eps)break;
			}
		}
		return tot;
	}
	inline bool cflow(db t){
		db ret=0;
		for(int i=2;i<=cnt;++i)c[i]=1.0*w[i];
		for(int i=head[S];i;i=nxt[i]){
			c[i]=t*w[i];
		}
		while(bfs()){
			for(int i=S;i<=T;++i)cur[i]=head[i];
			ret+=dfs(S,inf);
		}
		return A-ret<eps;
	}	
}


signed main(){
	sf("%d%d",&n,&m);
	S=0;T=mov+n+1;
	for(int i=1;i<=n;++i){
		int num;sf("%d",&num);
		_add(i+mov,T,num);
		_add(T,i+mov,0);
		A+=num;
	}
	for(int i=1;i<=m;++i){
		int num;
		sf("%d",&num);
		_add(S,i,num);
		_add(i,S,0);
	}
	for(int i=1;i<=m;++i){
		for(int j=1;j<=n;++j){
			int f;sf("%d",&f);
			if(f){
				_add(i,j+mov,inf);
				_add(j+mov,i,0);
			}
		}
	}
	db l=0,r=5e6,mid;
//	cout<<dinic::cflow(1.3)<<'\n';
	while(l+eps2<r){
		mid=(l+r)/2.0;
		if(dinic::cflow(mid))r=mid;
		else l=mid;
	}
	pf("%.3lf",l);
	return 0;
}
```


---

## 作者：ShineEternal (赞：0)

# 写在前面：
如想获取更佳阅读效果，请点击[这里](https://blog.csdn.net/kkkksc03/article/details/89407388)，任何疑问欢迎私信作者！
# 题目链接：
https://www.luogu.org/problemnew/show/P3324
# 分析：
因为本题的时间**点**较多，不能枚举，但发现有单调性，于是二分答案，二分使用的时间$T$

每个攻击装置造成的伤害总量已知，为$T*B_i$，现在有了伤害总量、生命总量，如何判断在$T$时间内，机器人是否被全部打死？

源点S向所有攻击装置连边，流量为$T*B_i$

攻击装置向能攻击到的机器人连边，流量为INF

所有机器人向汇点T连边，流量为$A_i$

验证$T$时间所有机器人都能被打死 **当且仅当** 上图的最大流$= \sum A_i$（所有机器人生命值之和）
# 代码：

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<iostream>
#include<algorithm>
#include<vector>
#include<queue>
#define maxn 110
#define inf 0x7fffffffffffffffll
using namespace std;
int n,m,s,t,d[maxn];
long long sum,ans,Sum_A;
long long a[maxn];
long long b[maxn];
int mp[maxn][maxn];
struct edge
{
    int to,rev;
    long long val;
    edge (int _to,long long _val,int _rev)
    {
        to=_to;
        val=_val;
        rev=_rev;
    }
};
vector<edge> e[maxn];
void add(int x,int y,long long val)
{
    e[x].push_back(edge(y,val,e[y].size()));
    e[y].push_back(edge(x,0,e[x].size()-1));
}
bool bfs()
{
    memset(d, -1, sizeof(d));
    queue<int> q;
    q.push(s);
    d[s]=0;
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        for(int i=0;i<e[x].size();i++)
        {
            int y=e[x][i].to;
            if(d[y]==-1 && e[x][i].val)
            {
                q.push(y);
                d[y]=d[x]+1;
            }
        }
    }
    if(d[t]==-1)
        return 0;
    else
        return 1;
}
long long dfs(int x,long long low) 
{
    if(x==t||low==0)
        return low;
    long long totflow=0;
    for(int i=0;i<e[x].size();i++)
    {
        int y=e[x][i].to;
        int rev=e[x][i].rev;
        if(d[y]==d[x]+1&&e[x][i].val) 
        {
            long long a=dfs(y,min(low,e[x][i].val)); 
            e[x][i].val-=a;
            e[y][rev].val+=a;
            low-=a;
            totflow+=a;
            if(low==0) 
                return totflow;
        }
    }
    if(low!=0) 
        d[x]=-1;
    return totflow;
}
bool pd(long long Time)
{
    for(int i=0;i<maxn;i++)
        e[i].clear();
    sum=ans=0;
    s=0,t=n+m+1;
    for(int i=1;i<=m;i++)
        add(s,i,Time*b[i]);
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
            if(mp[i][j])
                add(i,j+m,inf);
    for(int j=1;j<=n;j++)
        add(j+m,t,a[j]*10000);
    while(bfs())
    {
    	ans+=dfs(s,inf);
    }
    if(ans==Sum_A*10000)
        return 1;
    else
        return 0;
}

int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&a[i]);
        Sum_A+=a[i];
    }
    for(int i=1;i<=m;i++)
        scanf("%lld",&b[i]);
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
            scanf("%d",&mp[i][j]);
    long long l=0,r=10000000000000ll;
    long long an=l;
    while(l<=r)
    {
        long long mid=(l+r)/2;
        if(pd(mid))
        {
            an=mid;
            r=mid-1;
        }
        else
            l=mid+1;
    }
    printf("%.6lf\n",(double)an/(double)10000.0);
    return 0;
}
```



---


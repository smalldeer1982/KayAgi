# [HAOI2017] 新型城市化

## 题目描述

Anihc 国有 $n$ 座城市。城市之间存在一些贸易合作关系，如果城市 $x$ 与城市 $y$ 之间存在贸易协定，那么城市 $x$ 和城市 $y$ 则是一对贸易伙伴（注意： $(x,y)$ 和 $(y,x)$ 是同一对城市）。

为了实现新型城市化，实现统筹城乡一体化以及发挥城市群辐射与带动作用，国家决定规划新型城市关系。一些城市能够被称为城市群的条件是：这些城市两两都是贸易伙伴。由于Anihc 国之前也一直很重视城市关系建设，所以可以保证在目前已存在的贸易合作关系的情况下 Anihc 的 $n$ 座城市可以恰好被划分为不超过两个城市群。

为了建设新型城市关系 Anihc 国想要选出两个之前并不是贸易伙伴的城市，使这两个城市成为贸易伙伴，并且要求在这两个城市成为贸易伙伴之后，最大城市群的大小至少比他们成为贸易伙伴之前的最大城市群的大小增加 $1$。

Anihc 国需要在下一次会议上讨论扩大建设新型城市关系的问题，所以要请你求出在哪些城市之间建立贸易伙伴关系可以使得这个条件成立，即建立此关系前后的最大城市群的大小至少相差 $1$。

## 说明/提示

数据点 $1$：$n\le 16$；

数据点 $2$：$n\le 16$；

数据点 $3\sim 5$：$n\le 100$；

数据点 $6$：$n\le 500$；

数据点 $7\sim10$：$n\le 10^4$。

对于所有的数据保证： $n \le 10^4,0 \le m \le \min(1.5\times 10^5,\dfrac{n(n-1)}{2})$。保证输入的城市关系中不会出现 $(x,x)$ 这样的关系，同一对城市也不会出现两次（无重边，无自环）。

## 样例 #1

### 输入

```
5 3
1 5
2 4
2 5```

### 输出

```
2
1 5
2 4```

# 题解

## 作者：lfxxx (赞：15)

简要题意是找到一条边连接使得最大团大小增加。

在补图上最大团等于最大独立集。

所以问题转化为删掉一条边使得最大独立集增加，又因为团不超过两个，所以原图是二分图，也就是使得最大匹配减少。

考虑什么样的匹配边是可以被代替的，先跑一遍网络流求最大匹配，不难发现假若一条匹配在残量网络流上的一个环中，那么它就是可以被代替的，所以对残量网络进行缩点，两个端点不在同一个强连通分量中的匹配边可以作为答案。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e4 + 114;
const int maxm = 2e6 + 114;
const int inf = 0x3f3f3f3f;
int maxflow, vis[maxn], tot = 1, cnt;
int s, t, n, m, Q, E;
vector<int> edge[maxn], Road[maxn];
int hd[maxn], road[maxn], dis[maxn];
map<int, int> f[maxn];
struct edge {
    int next, to, w;
} e[maxm * 2];
void add(int u, int v, int w) {
    e[++tot].to = v;
    f[u][v] = tot;
    e[tot].w = w;
    e[tot].next = hd[u];
    hd[u] = tot;
    e[++tot].to = u;
    e[tot].w = 0;
    e[tot].next = hd[v];
    hd[v] = tot;
}
bool bfs() {
    memset(dis, 0, sizeof(dis));
    dis[s] = 1;
    queue<int>Q;
    Q.push(s);

    while (!Q.empty()) {
        int u = Q.front();
        Q.pop();
        road[u] = hd[u];

        for (int i = hd[u]; i; i = e[i].next) {
            int v = e[i].to;

            if (!dis[v] && e[i].w) {
                dis[v] = dis[u] + 1;
                Q.push(v);
            }

        }
    }

    return dis[t] != 0;
}
int dinic(int now, int res) {
    if (now == t)
        return res;

    int tp = res;

    for (int i = road[now]; i; i = e[i].next) {
        int v = e[i].to;
        road[now] = i;

        if (dis[v] == dis[now] + 1 && e[i].w) {
            int k = min(e[i].w, tp);
            int del = dinic(v, k);
            e[i].w -= del;
            e[i ^ 1].w += del;
            tp -= del;

            if (!tp)
                break;
        }
    }

    return res - tp;
}
int col[maxn], Use[maxn];
void dfs(int u) {
    if (Use[u] == 1)
        return ;

    Use[u] = 1;

    for (int v : edge[u])
        col[v] = col[u] ^ 1, dfs(v);
}
int dfsn[maxn];
int low[maxn];
stack<int> S;
int Vis[maxn], use[maxn];
int color[maxn], sum = 0;
int deep = 0;
void paint(int u) {
    S.pop();
    color[u] = sum;
    Vis[u] = 0;
}
void tanjan(int u) {
    dfsn[u] = ++deep;
    low[u] = deep;
    Vis[u] = 1;
    use[u] = 1;
    S.push(u);

    for (int i = hd[u]; i; i = e[i].next) {
        if (e[i].w == 0)
            continue;

        int v = e[i].to;

        if (dfsn[v] == 0) {
            tanjan(v);
            low[u] = min(low[u], low[v]);
        } else {
            if (Vis[v] != 0) {
                low[u] = min(low[u], low[v]);
            }
        }
    }

    if (dfsn[u] == low[u]) {
        sum++;

        while (S.top() != u) {
            paint(S.top());
        }

        paint(u);
    }

    return ;
}
set< pair<int, int>> chifan;
int main() {
    cin >> n >> m;

    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        edge[u].push_back(v);
        edge[v].push_back(u);
    }

    for (int i = 1; i <= n; i++) {
        if (Use[i] == 0)
            col[i] = 0, dfs(i);
    }

    for (int i = 1; i <= n; i++) {
        if (col[i] == 0) {
            for (int nxt : edge[i])
                Road[i].push_back(nxt), add(i, nxt, 1);
        }
    }

    s = n + 1, t = n + 2;

    for (int i = 1; i <= n; i++)
        if (col[i] == 0)
            add(s, i, 1);
        else
            add(i, t, 1);

    while (bfs() == true)
        maxflow += dinic(s, inf);

    for (int i = 1; i <= n + 2; i++) {
        if (use[i] == 0)
            tanjan(i);
    }

    for (int i = 1; i <= n; i++) {
        for (int nxt : Road[i]) {
            if (e[f[i][nxt]].w == 0 && color[i] != color[nxt]) {
                chifan.insert(make_pair(min(i, nxt), max(i, nxt)));
            }
        }
    }

    cout << chifan.size() << '\n';

    for (pair<int, int> OUT : chifan) {
        cout << OUT.first << ' ' << OUT.second << '\n';
    }
}
```


---

## 作者：__stdcall (赞：12)

### Prelude


好，HAOI2017终于会做一道题了！

传送到洛谷：[→\_→](https://www.luogu.org/problem/show?pid=3731)

传送到LOJ：[←\_←](https://loj.ac/problem/2276)

本篇博客链接：[(●'◡'●)](http://www.cnblogs.com/mlystdcall/p/8073198.html)


---

### Solution


首先要读懂题。

考场上我是这样想的[QAQ](http://www.cnblogs.com/mlystdcall/p/6759362.html)。

我们把每个城市看作一个点，在“当前没有贸易关系”的城市之间连边。

此时，如果一个城市集合是一个城市群，那么这个城市集合中的任意两个城市之间都没有边。

因为“可以划分为两个城市群”，所以这个图是个二分图。

那么“最大城市群”就是二分图的最大独立集。

“在两个城市之间建立贸易关系”即删除这两个点之间的边。

所以题目实际上是，给一个二分图，问删掉哪些边之后，最大独立集的大小会增加。

考虑如何求最大独立集大小。

最大独立集大小=总点数-最小覆盖集大小=最大匹配数。

也就是说，这个题问的是，给一个二分图，问删掉哪些边之后，最大匹配的数量会减少，也就是问，哪些边一定在最大匹配里。

这个时候，我们已经得到了50分做法了。

先建出网络流，求出最大匹配数量，然后删掉一条边重新跑一次，看最大匹配是否减少，就是我考场上的做法。

用退流可以做到更优越的复杂度，但好像过不了n=500的点？

接下来考虑满分做法。

考虑如下定理：若一条边一定在最大匹配中，则在最终的残量网络中，这条边一定满流，且这条边的两个顶点一定不在同一个强连通分量中。

证明也很简单：首先满流的要求是很显然的，其次，如果这两个点在同一个强连通分量中，那么一定有一个环经过这条边，沿着环增广一下，网络仍然满足流量限制，但是这条边就不满流了，于是就得到了一组新的最大匹配。

所以只要跑完Dinic跑Tarjan就好了。


---

### Code


```cpp
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <queue>
#include <stack>
#include <vector>
#include <utility>

using namespace std;
typedef pair<int,int> pii;
const int MAXN = 10010;
const int MAXM = 150010;
const int MAXV = 100010;
const int MAXE = 1000010;
const int INF = 0x3f3f3f3f;
int _w;

int n, m, uu[MAXM], vv[MAXM];

namespace G {
    int head[MAXN], nxt[MAXM<<1], to[MAXM<<1], eid;
    void init() {
        eid = 0;
        memset(head, -1, sizeof head);
    }
    void adde( int u, int v ) {
        to[eid] = v, nxt[eid] = head[u], head[u] = eid++;
        to[eid] = u, nxt[eid] = head[v], head[v] = eid++;
    }
}

namespace Dinic {
    struct Edge {
        int u, v, c, f;
        Edge() {}
        Edge( int u, int v, int c, int f ):
            u(u), v(v), c(c), f(f) {}
    };
    
    int n, m, s, t;
    int head[MAXV], nxt[MAXE<<1];
    Edge edge[MAXE<<1];
    int dis[MAXV], cur[MAXV];
    queue<int> q;
    
    void init( int _n ) {
        n = _n, m = 0;
        for( int i = 0; i < n; ++i )
            head[i] = -1;
    }
    int adde( int u, int v, int c ) {
        int eid = m;
        edge[m] = Edge(u, v, c, 0);
        nxt[m] = head[u], head[u] = m++;
        edge[m] = Edge(v, u, 0, 0);
        nxt[m] = head[v], head[v] = m++;
        return eid;
    }
    bool bfs() {
        for( int i = 0; i < n; ++i )
            dis[i] = INF;
        dis[s] = 0, q.push(s);
        while( !q.empty() ) {
            int u = q.front(); q.pop();
            for( int i = head[u]; ~i; i = nxt[i] ) {
                Edge &e = edge[i];
                if( e.c > e.f && dis[e.v] == INF ) {
                    dis[e.v] = dis[u] + 1;
                    q.push(e.v);
                }
            }
        }
        return dis[t] != INF;
    }
    int dfs( int u, int res ) {
        if( u == t || !res ) return res;
        int flow = 0;
        for( int &i = cur[u]; ~i; i = nxt[i] ) {
            Edge &e = edge[i];
            if( e.c > e.f && dis[e.v] == dis[u] + 1 ) {
                int f = dfs( e.v, min(res, e.c-e.f) );
                flow += f, res -= f;
                e.f += f, edge[i^1].f -= f;
                if( !res ) break;
            }
        }
        return flow;
    }
    int solve( int _s, int _t ) {
        s = _s, t = _t;
        int flow = 0;
        while( bfs() ) {
            for( int i = 0; i < n; ++i )
                cur[i] = head[i];
            flow += dfs(s, INF);
        }
        return flow;
    }
}

namespace Bipartite {
    int color[MAXN], eid[MAXM];
    queue<int> q;
    
    void bfs( int s ) {
        using namespace G;
        
        color[s] = 0, q.push(s);
        while( !q.empty() ) {
            int u = q.front(); q.pop();
            for( int i = head[u]; ~i; i = nxt[i] ) {
                int v = to[i];
                if( color[v] == -1 ) {
                    color[v] = !color[u];
                    q.push(v);
                }
            }
        }
    }
    void bipartite() {
        for( int i = 1; i <= n; ++i )
            color[i] = -1;
        for( int i = 1; i <= n; ++i )
            if( color[i] == -1 )
                bfs(i);
        int s = 0, t = n+1;
        Dinic::init(t+1);
        for( int i = 1; i <= n; ++i )
            if( color[i] ) Dinic::adde(s, i, 1);
            else Dinic::adde(i, t, 1);
        for( int i = 0; i < m; ++i )
            if( color[uu[i]] )
                eid[i] = Dinic::adde( uu[i], vv[i], 1 );
            else
                eid[i] = Dinic::adde( vv[i], uu[i], 1 );
        Dinic::solve(s, t);
    }
}
using Bipartite::bipartite;

namespace Tarjan {
    using namespace Dinic;
    
    int dfn[MAXV], low[MAXV], scc[MAXV], dfnc, sccc;
    stack<int> stk;
    
    void dfs( int u ) {
        dfn[u] = low[u] = ++dfnc;
        stk.push(u);
        for( int i = head[u]; ~i; i = nxt[i] ) {
            Edge &e = edge[i];
            if( e.c == e.f ) continue;
            int v = e.v;
            if( !dfn[v] ) {
                dfs(v);
                low[u] = min( low[u], low[v] );
            } else if( !scc[v] ) {
                low[u] = min( low[u], dfn[v] );
            }
        }
        if( low[u] == dfn[u] ) {
            ++sccc;
            while(1) {
                int o = stk.top(); stk.pop();
                scc[o] = sccc;
                if( o == u ) break;
            }
        }
    }
    void tarjan() {
        dfnc = sccc = 0;
        for( int i = 0; i < Dinic::n; ++i )
            if( !dfn[i] ) dfs(i);
    }
}
using Tarjan::tarjan;

namespace Solve {
    vector<pii> ans;
    void solve() {
        using Dinic::Edge;
        using Dinic::edge;
        using Tarjan::scc;
        using Bipartite::eid;
        
        for( int i = 0; i < m; ++i ) {
            Edge &e = edge[eid[i]];
            if( e.c != e.f ) continue;
            int u = e.u, v = e.v;
            if( u > v ) swap(u, v);
            if( scc[u] == scc[v] ) continue;
            ans.push_back( pii(u, v) );
        }
        sort(ans.begin(), ans.end());
        printf( "%lu\n", ans.size() );
        for( int i = 0; i < (int)ans.size(); ++i )
            printf( "%d %d\n", ans[i].first, ans[i].second );
    }
}
using Solve::solve;

int main() {
    _w = scanf( "%d%d", &n, &m );
    G::init();
    for( int i = 0; i < m; ++i ) {
        _w = scanf( "%d%d", uu+i, vv+i );
        G::adde( uu[i], vv[i] );
    }
    bipartite();
    tarjan();
    solve();
    return 0;
}
```

---

## 作者：EnofTaiPeople (赞：4)

感觉自己哪方面都有些弱，最大团问题考了几次都不会，于是就过来补了。不过卡常、偷懒的能力依旧没变，毫不费力的得到了最优解（离次优解只差一点）。

显然，城市群是一个团，最大城市群也就是最大团，等于点数减去补图的最大独立集。

题目给定补图是一个二分图，而没有点权的二分图最大独立集就等于最大匹配，于是本题被神奇地求补图最大匹配必经边。

建完模，跑完流，考虑每一条满流的边，设它为 $(x,y)$，如果删去它，并给 $(s,x)$ 和 $(y,t)$ 加上流，如果新的网络并未满流，那么原残量网络上 $x,y$ 一定在一个强连通分量内，缩点即可。

对于求二分图网络流，我们可以使用 $ISAP$ 算法，这样原图已经分好层了，省去了广搜过程，减少了码量和常数，代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e4+4,M=5e5+5;
namespace fast_io{
    char buf[M+5],*p1,*p2,c;
    #define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,M,stdin),p1==p2)?EOF:*p1++)
    inline int read(){
        int an=0,f=1;while(!isdigit(c=gc))if(c=='-')f=-f;
        do an=an*10+(48^c);while(isdigit(c=gc));return an*f;
    }
    int ot;
    char ob[M+20],stk[20],t;
    inline int fls(){
        fwrite(ob,1,ot,stdout);return ot=0;
    }
    inline void write(int x,char bf){
        if(x<0)ob[ot++]='-',x=-x;
        while(x>9)stk[++t]=48^(x%10),x/=10;
        for(ob[ot++]=48^x;t;ob[ot++]=stk[t--]);
        ob[ot++]=bf;if(ot>M)fls();
    }
}
using fast_io::read;
using fast_io::write;
int ed[M],w[M],n,m,s,t,d[N],gap[N],now[N];
struct Eg{int u,v;}g[M];
vector<int>lk[N];
void dfs(int x){
	for(int y:lk[x])
		if(!d[y])d[y]=d[x]^1,dfs(y);
}
int Isap(int x=s,int fl=INT_MAX){
	if(x==t)return fl;
	int i,y,k,rs=fl;
	for(int &g=now[x],sz=lk[x].size();g<sz;++g)
		if(w[i=lk[x][g]]&&d[y=ed[i]]==d[x]-1)
			if(k=Isap(y,min(w[i],rs))){
				w[i]-=k,w[i^1]+=k;
				if(!(rs-=k))return fl;
			}
	--gap[d[x]]?++gap[++d[x]]:d[s]=t+1;
	now[x]=0;return fl-rs;
}
int dfn[N],low[N],dlt,stk[N],tp,inc[N],scc;
void tarjan(int x){
	dfn[x]=low[x]=++dlt,stk[++tp]=x;int y;
	for(int i:lk[x])
		if(w[i])
			if(dfn[y=ed[i]]){
				if(!inc[y]&&low[x]>dfn[y])low[x]=dfn[y];
			}else{
				tarjan(y);if(low[x]>low[y])low[x]=low[y];
			}
	if(dfn[x]==low[x]){
		++scc;do inc[stk[tp]]=scc;while(stk[tp--]!=x);
	}
}
typedef pair<int,int> Tp;
set<Tp>st;
int main(){
	n=read(),m=read();int i,x,y;
	for(i=1;i<=m;++i){
		x=read(),y=read();
		lk[x].push_back(y);
		lk[y].push_back(x);
	}for(x=1;x<=n;++x)
		if(!d[x])d[x]=2,dfs(x);
	d[s=n+1]=4,d[t=s+1]=1,m=0;
	for(x=1;x<=n;++x){
		if(d[x]==3){
			g[++m]={s,x};
			for(int y:lk[x])
				g[++m]={x,y};
		}else g[++m]={x,t};
		lk[x].clear();
	}
	for(x=1;x<=t;++x)++gap[d[x]];
	for(i=1;i<=m;++i){
		w[i+i+1]=1;
		lk[ed[i+i]=g[i].u].push_back(i+i+1);
		lk[ed[i+i+1]=g[i].v].push_back(i+i);
	}while(d[s]<=t)Isap();
	for(x=1;x<=t;++x)if(!dfn[x])tarjan(x);
	for(i=1;i<=m;++i)
        if(w[i+i]){
            x=g[i].u,y=g[i].v;
            if(inc[x]!=inc[y]){
                if(x>y)x^=y^=x^=y;
                if(y<=n)st.insert(Tp(x,y));
            }
        }
	write(st.size(),'\n');
	for(Tp at:st){
        write(at.first,' ');
        write(at.second,'\n');
    }
	return fast_io::fls();
}
```

---

## 作者：juju527 (赞：4)

### 二分图

感觉挺综合的

一句话题意，保证原图补图是个二分图，在原图中加入一条边能使原图最大团数至少加一的边有哪些

最大团数即**使得选中的点集两两有边的最大点数**

不会的同学建议学习一下

我们发现补图性质较为优秀，并且最大团求法就是在补图上应用的，把问题转移到补图上考虑

由于当补图为二分图时，原图最大团数=补图最大点独立集数

即**在补图里删去一条边使得补图的最大点独立集数至少增加一**

又由最大点独立集数等于总点数-最小点覆盖数=点总数-最大匹配数

问题进一步变成了**在补图里删去一条边使得补图的最大匹配数至少减少一**

我们想让补图的最大匹配数减少1，那么我们一定只能删去补图最大匹配的必须边

因为我们只能删一条边，删掉可行边或不可行边最大匹配不变

那么我们只要求出补图的最大匹配必须边即可

这就是一个经典问题了

对于补图用网络流跑最大匹配，残余网络再跑tarjan（即满流的边不能走，tarjan可走反边）

对于补图的某条边，它是必须边的条件是两个端点在不同的强连通分量里且网络流的残余网络里正边流满

即改变在这个最大匹配方案中且不可替代

码量还比较大，板子别打错了

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=10005,maxm=150005,inf=0x3f3f3f3f;
struct Ans{
	int x,y;
};
struct Edge{
	int to,nxt;
}e[2*maxm];
struct EDGE{
	int to,w,nxt;
}g[2*maxm+2*maxn];
int cnt1,cnt2;
int head[maxn],strt[maxn];
int c[maxn];
int s,t;
int lev[maxn];
int dfsnum=0,num=0;
int dfn[maxn],low[maxn];
int b[maxn];
bool vis[maxn];
queue<int>q;
stack<int>st;
vector<int>ans;
vector<Ans>ANS;
int read(){
	int x=0,y=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*y;
}
void add(Edge *e,int *head,int &cnt,int u,int v){
	e[cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt++;
	return ;
}
void add(EDGE *e,int *head,int &cnt,int u,int v,int w){
	e[cnt].to=v;
	e[cnt].w=w;
	e[cnt].nxt=head[u];
	head[u]=cnt++;
	return ;
}
void dfs(int x,int co){
	c[x]=co;
	for(int i=head[x];i!=-1;i=e[i].nxt){
		int tmp=e[i].to;
		if(c[tmp])continue;
		dfs(tmp,co^1);
	}
	return ;
}
bool bfs(){
	memset(lev,0,sizeof(lev));
	while(!q.empty())q.pop();
	q.push(s);
	lev[s]=1;
	while(!q.empty()){
		int k=q.front();
		q.pop();
		for(int i=strt[k];i!=-1;i=g[i].nxt){
			int tmp=g[i].to;
			if(g[i].w==0||lev[tmp])continue;
			lev[tmp]=lev[k]+1;
			q.push(tmp);
			if(tmp==t)return 1;
		}
	}
	return 0;
}
int dinic(int x,int flow){
	if(x==t)return flow;
	int rest=flow;
	for(int i=strt[x];i!=-1;i=g[i].nxt){
		if(!rest)break;
		int tmp=g[i].to;
		if(g[i].w==0||lev[tmp]!=lev[x]+1)continue;
		int inc=dinic(tmp,min(rest,g[i].w));
		if(!inc)lev[tmp]=0;
		g[i].w-=inc;
		g[i^1].w+=inc;
		rest-=inc;
	}
	return flow-rest;
}
void tarjan(int x){
	dfn[x]=low[x]=++dfsnum;
	vis[x]=1;
	st.push(x);
	for(int i=strt[x];i!=-1;i=g[i].nxt){
		int tmp=g[i].to;
		if(g[i].w==0)continue;
		if(!dfn[tmp]){
			tarjan(tmp);
			low[x]=min(low[x],low[tmp]);
		}
		else if(vis[tmp])
			low[x]=min(low[x],low[tmp]);
	}
	if(dfn[x]==low[x]){
		num++;
		while(st.top()!=x){
			int k=st.top();
			st.pop();
			vis[k]=0;
			b[k]=num;
		}
		st.pop();
		vis[x]=0;
		b[x]=num;
	}
	return ;
}
int main(){
	int n,m;
	n=read();m=read();
	s=n+1;t=n+2;
	memset(head,-1,sizeof(head));
	memset(strt,-1,sizeof(strt));
	for(int i=1;i<=m;i++){
		int u,v;
		u=read();v=read();
		add(e,head,cnt1,u,v);
		add(e,head,cnt1,v,u);
	}
	for(int i=1;i<=n;i++){
		if(c[i])continue;
		dfs(i,2);
	}
	for(int i=1;i<=n;i++){
		if(c[i]==3){
			add(g,strt,cnt2,i,t,1);
			add(g,strt,cnt2,t,i,0);
			continue;	
		}
		add(g,strt,cnt2,s,i,1);
		add(g,strt,cnt2,i,s,0);
		for(int j=head[i];j!=-1;j=e[j].nxt){
			int tmp=e[j].to;
			add(g,strt,cnt2,i,tmp,1);
			add(g,strt,cnt2,tmp,i,0);
		}
	}
	int maxflow=0;
	while(bfs()){
		int flow=dinic(s,inf);
		while(flow){
			maxflow+=flow;
			flow=dinic(s,inf);
		}
	}
	for(int i=1;i<=n+2;i++)
		if(!dfn[i])
			tarjan(i);
	for(int i=1;i<=n;i++){
		ans.clear();
		for(int j=strt[i];j!=-1;j=g[j].nxt){
			int tmp=g[j].to;
			if(tmp<i||tmp>n||b[i]==b[tmp])continue;
			if(((j%2==0)&&g[j].w==1)||((j&1)&&g[j^1].w==1))continue;
			ans.push_back(tmp);
		}
		sort(ans.begin(),ans.end());
		for(int j=0;j<ans.size();j++)
			ANS.push_back((Ans){i,ans[j]});
	}
	printf("%d\n",ANS.size());
	for(int i=0;i<ANS.size();i++)
		printf("%d %d\n",ANS[i].x,ANS[i].y);
	return 0;
}

```



---

## 作者：yybyyb (赞：4)

对于在反图上没有边的点之间是存在一条边的，而原图是反图的反图。  
那么考虑原图的一个团对应在反图上是什么，因为原图的团内的点两两之间有边，所以对应在反图上两两之间无边。所以原图的一个团对应着反图的一个独立集。  
因为原图可以分解为不超过$2$个团，所以反图可以分解成一个二分图。  
于是问题变成了，删去反图上的哪条边，可以让反图的最大独立集变大。  
二分图最大独立集=总点数-最小点覆盖，而最小点覆盖=二分图最大匹配。  
于是问题变成了哪些边必定出现在二分图的最大匹配中。  
那么先跑$Dinic$之后用$Tarjan$把残余网络缩点，  
必定在二分图匹配上的边就是那些满流并且连接的两点不在同一个$scc$内的边。  
证明大概就是如果两者在同一个$scc$内，那么必定存在另外一条匹配边可以替换这条边。  
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;
#define MAXN 10100
#define MAXM 150150
#define inf 1e9
inline int read()
{
	int x=0;bool t=false;char ch=getchar();
	while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
	if(ch=='-')t=true,ch=getchar();
	while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
	return t?-x:x;
}
struct Line{int v,next,w;}e[MAXM<<1];
int h[MAXN],cnt=2;
inline void Add(int u,int v,int w)
{
	e[cnt]=(Line){v,h[u],w};h[u]=cnt++;
	e[cnt]=(Line){u,h[v],0};h[v]=cnt++;
}
int S,T,level[MAXN];
bool bfs()
{
	for(int i=S;i<=T;++i)level[i]=0;
	queue<int> Q;level[S]=1;Q.push(S);
	while(!Q.empty())
	{
		int u=Q.front();Q.pop();
		for(int i=h[u];i;i=e[i].next)
			if(e[i].w&&!level[e[i].v])
				level[e[i].v]=level[u]+1,Q.push(e[i].v);
	}
	return level[T];
}
int cur[MAXN];
int dfs(int u,int flow)
{
	if(u==T||!flow)return flow;
	int ret=0;
	for(int &i=cur[u];i;i=e[i].next)
	{
		int v=e[i].v,d;
		if(e[i].w&&level[v]==level[u]+1)
		{
			d=dfs(v,min(flow,e[i].w));
			ret+=d;flow-=d;
			e[i].w-=d;e[i^1].w+=d;
			if(!flow)break;
		}
	}
	if(!ret)level[u]=0;
	return ret;
}
int Dinic()
{
	int ret=0;
	while(bfs())
	{
		for(int i=S;i<=T;++i)cur[i]=h[i];
		ret+=dfs(S,inf);
	}
	return ret;
}
vector<pair<int,int> > Ans;
vector<int> E[MAXN];
int n,m,col[MAXN];
void pre(int u,int c){col[u]=c;for(int v:E[u])if(!col[v])pre(v,c^1);}
int dfn[MAXN],low[MAXN],tim,G[MAXN],gr;
int St[MAXN],top;bool ins[MAXN];
void Tarjan(int u)
{
	dfn[u]=low[u]=++tim;St[++top]=u;ins[u]=true;
	for(int i=h[u];i;i=e[i].next)
	{
		int v=e[i].v;if(!e[i].w)continue;
		if(!dfn[v])Tarjan(v),low[u]=min(low[u],low[v]);
		else if(ins[v])low[u]=min(low[u],dfn[v]);
	}
	if(dfn[u]==low[u])
	{
		++gr;int v;
		do{v=St[top--];G[v]=gr;ins[v]=false;}while(u!=v);
	}
}
int main()
{
	n=read();m=read();
	for(int i=1;i<=m;++i)
	{
		int u=read(),v=read();
		E[u].push_back(v);
		E[v].push_back(u);
	}
	for(int i=1;i<=n;++i)if(!col[i])pre(i,2);
	S=0;T=n+1;
	for(int i=1;i<=n;++i)
		if(col[i]==2)
		{
			Add(S,i,1);
			for(int v:E[i])Add(i,v,1);
		}
		else Add(i,T,1);
	int ret=Dinic();
	for(int i=S;i<=T;++i)if(!dfn[i])Tarjan(i);
	for(int u=1;u<=n;++u)
		if(col[u]==2)
			for(int i=h[u];i;i=e[i].next)
			{
				int v=e[i].v;if(e[i].w)continue;
				if(v==S||v==T)continue;
				if(G[u]!=G[v])Ans.push_back(u<v?make_pair(u,v):make_pair(v,u));
			}
	sort(Ans.begin(),Ans.end());
	printf("%d\n",(int)Ans.size());
	for(auto a:Ans)printf("%d %d\n",a.first,a.second);
	return 0;
}
```


---

## 作者：Leasier (赞：3)

前置芝士：[二分图](https://oi-wiki.org/graph/bi-graph/)、[二分图最大匹配](https://oi-wiki.org/graph/graph-matching/bigraph-match/)、[强连通分量](https://oi-wiki.org/graph/scc/)

既然题目只给了你补图，不妨分析补图的性质。

注意到题目中“城市群”的定义即为一张完全图，而题目保证原图可以恰好被划分为不超过两个“城市群”，而题给补图上的边就是这两个城市群缺失的边。因此补图是一张**二分图**。

现在再来关注题目所求：求所有补图上的边，使得在补图上删边后最大“城市群”变大。

转换一下，我们也就是说需要原图的最大团变大，由原图最大团等于补图最大独立集，又等于点数减去最小点覆盖，从而等于点数减去最大匹配，于是我们希望最大匹配变小。

直接暴力可以考虑先求出补图的最大匹配，接下来枚举删哪条边，再跑网络流求出删完后补图的最大匹配。时间复杂度为 $O(m^2 \sqrt n)$，但显然不能接受。

因为 wssb，我一开始以为原图上任意一条匹配边被删除都会使最大匹配减小，但这样写就 WA 0 了 /fn

一时间不会做了，不妨随一个 $n = 5, m = 10$ 的图来看一看有没有什么规律。画出网络流的残量网络并标记所有在最大匹配中但删去不影响答案的边 $u \to v$，发现对于这些边，存在一条从 $v$ 到 $u$ 的路径，反之不存在。也就是说，**必须在最大匹配中的边还要满足 $u, v$ 两点不在同一强连通分量里**。

于是跑完网络流后跑 Tarjan 缩点即可。时间复杂度为 $O(n + m \sqrt n)$。

------------

我们来感性理解一下上文提到的结论。

考虑反证，假定一条必须在最大匹配中的边 $x \to y$ 中的 $x, y$ 在一个有向环 $x \to y \to z \to \cdots \to w \to x$ 中，则当我们删去这条边后，我们可以找到一条新的增广路 $y \to z \to \cdots \to w \to x$，与该边为必须在最大匹配中的边矛盾。

------------

代码：
```cpp
#include <iostream>
#include <algorithm>
#include <stack>
#include <queue>

using namespace std;

typedef struct {
	int nxt;
	int end;
	int dis;
} Edge;

int cnt = 1;
int head[10007], color[10007], dis[10007], cur_edge[10007], dis_cnt[10007], dfn[10007], low[10007], belong[10007];
bool vis1[10007], vis2[10007], vis3[10007];
Edge edge[320007];
stack<int> s;
queue<int> q;
pair<int, int> pr[10007];

inline void init(int n){
	for (register int i = 0; i <= n; i++){
		dis[i] = 0x7fffffff;
		cur_edge[i] = head[i];
	}
}

inline void add_edge(int start, int end, int dis){
	cnt++;
	edge[cnt].nxt = head[start];
	head[start] = cnt;
	edge[cnt].end = end;
	edge[cnt].dis = dis;
}

void dfs(int u, int cur_color){
	vis1[u] = true;
	color[u] = cur_color;
	cur_color ^= 1;
	for (register int i = head[u]; i != 0; i = edge[i].nxt){
		int x = edge[i].end;
		if (!vis1[x]) dfs(x, cur_color);
	}
}

inline void bfs(int start){
	dis[start] = 0;
	q.push(start);
	while (!q.empty()){
		int cur = q.front(), next_dis = dis[cur] + 1;
		q.pop();
		dis_cnt[dis[cur]]++;
		for (register int i = head[cur]; i != 0; i = edge[i].nxt){
			int x = edge[i].end;
			if (dis[x] == 0x7fffffff){
				dis[x] = next_dis;
				q.push(x);
			}
		}
	}
}

int dfs(int u, int flow, int start, int end, int n){
	if (u == end) return flow;
	int ans = 0;
	for (register int i = cur_edge[u]; i != 0; i = edge[i].nxt){
		int x = edge[i].end;
		cur_edge[u] = i;
		if (edge[i].dis != 0 && dis[u] == dis[x] + 1){
			int t = dfs(x, min(flow - ans, edge[i].dis), start, end, n);
			edge[i].dis -= t;
			edge[i ^ 1].dis += t;
			ans += t;
			if (ans == flow) return ans;
		}
	}
	cur_edge[u] = head[u];
	if (--dis_cnt[dis[u]] == 0) dis[start] = n;
	dis_cnt[++dis[u]]++;
	return ans;
}

inline int isap(int start, int end, int n){
	int ans = 0;
	bfs(end);
	while (dis[start] < n) ans += dfs(start, 0x7fffffff, start, end, n);
	return ans;
}

void tarjan(int u, int &id, int &scc_cnt){
	dfn[u] = low[u] = ++id;
	vis2[u] = vis3[u] = true;
	s.push(u);
	for (register int i = head[u]; i != 0; i = edge[i].nxt){
		if (edge[i].dis != 0){
			int x = edge[i].end;
			if (!vis2[x]){
				tarjan(x, id, scc_cnt);
				low[u] = min(low[u], low[x]);
			} else if (vis3[x]){
				low[u] = min(low[u], dfn[x]);
			}
		}
	}
	if (dfn[u] == low[u]){
		int cur;
		scc_cnt++;
		do {
			cur = s.top();
			s.pop();
			vis3[cur] = false;
			belong[cur] = scc_cnt;
		} while (cur != u);
	}
}

int main(){
	int n, m, end, id = 0, scc_cnt = 0, ans_cnt = 0;
	cin >> n >> m;
	end = n + 1;
	for (register int i = 1; i <= m; i++){
		int x, y;
		cin >> x >> y;
		add_edge(x, y, -1);
		add_edge(y, x, -1);
	}
	for (register int i = 1; i <= n; i++){
		if (!vis1[i]) dfs(i, 0);
	}
	for (register int i = 1; i <= n; i++){
		if (color[i] == 0){
			for (register int j = head[i]; j != 0; j = edge[j].nxt){
				edge[j].dis = 1;
			}
		} else {
			for (register int j = head[i]; j != 0; j = edge[j].nxt){
				edge[j].dis = 0;
			}
		}
	}
	for (register int i = 1; i <= n; i++){
		if (color[i] == 0){
			add_edge(0, i, 1);
			add_edge(i, 0, 0);
		} else {
			add_edge(i, end, 1);
			add_edge(end, i, 0);
		}
	}
	init(end);
	isap(0, end, end + 1);
	for (register int i = 0; i <= end; i++){
		if (!vis2[i]) tarjan(i, id, scc_cnt);
	}
	for (register int i = 1; i <= n; i++){
		if (color[i] == 0){
			for (register int j = head[i]; j != 0; j = edge[j].nxt){
				if (edge[j].dis == 0 && edge[j].end != 0 && belong[i] != belong[edge[j].end]){
					if (i < edge[j].end){
						pr[++ans_cnt] = make_pair(i, edge[j].end);
					} else {
						pr[++ans_cnt] = make_pair(edge[j].end, i);
					}
					break;
				}
			}
		}
	}
	sort(pr + 1, pr + ans_cnt + 1);
	cout << ans_cnt << endl;
	for (register int i = 1; i <= ans_cnt; i++){
		cout << pr[i].first << " " << pr[i].second << endl;
	}
	return 0;
}
```

---

## 作者：orz_z (赞：2)

给你一张图，保证原图补图是个二分图，在原图中加入一条边能使原图最大团数至少加一的边有哪些？

最大团数指使得选中的点集两两有边的最大点数。

点数 $\leq 10^4$，$0\leq$ 边数 $\leq \min(1.5\times 10^5,\frac{n(n-1)}{2})$。

无重边，无自环。

#### sol

由于补图的性质比较优秀，考虑处理补图。

显然，当补图为二分图时，原图最大团数 $=$ 补图最大点独立集数。

且最大点独立集数 $=$ 总点数 $-$ 最小点覆盖数 $=$ 总点数 $-$ 最大匹配数。

问题进一步变成了在补图里删去一条边使得补图的最大匹配数至少减少一。

显然，我们需要找到最大匹配的必须边。

根据定理，必须边的判定条件是：$( x , y )$ 流量为 $1$， 并且 $x , y$ 两点在残量网络中属于不同的 $\operatorname{Scc}$。

证明：

若 $z$ 是当前非匹配点，则 $(z,t)$ 的剩余流量必定为 $1$。

若 $v$ 是当前匹配点，则 $(v,t)$ 的剩余流量必定为 $0$，$(t,v)$ 的剩余流量必定为 $1$。

若 $(u,v)$ 是当前匹配边，则 $(v,u)$ 的剩余流量必定为 $0$，$(u,v)$ 的剩余流量必定为 $1$。

换言之，残量网络中存在路径 $(\cdots \to z \to t \to v \cdots)$。

此时若 $u$ 到 $z$ 有增广路，则残量网络上  $u$ 能到达 $z$，$z$ 能到达 $t$，$t$ 能到达 $v$，$v$ 能到达 $u$，所以此时 $u,v$ 处在残量网络上的同一个 $\operatorname{Scc}$ 内。

所以，必须边的判定条件是：$( x , y )$ 流量为 $1$， 并且 $x , y$ 两点在残量网络中属于不同的 $\operatorname{Scc}$。

证毕。

最后，`dinic` 套 `tarjan` 即可。

```cpp
#include <bits/stdc++.h>

using namespace std;

inline int read()
{
	int x = 0, f = 1;
	char c = getchar();
	while(c < '0' || c > '9')
	{
		if(c == '-') f = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9')
	{
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}

inline void write(int x)
{
	if(x < 0)
	{
		putchar('-');
		x = -x;
	}
	if(x > 9)
		write(x / 10);
	putchar(x % 10 + '0');
}

const int _ = 1e4 + 10, M = 2e5 + 10;

int n, m, s, t, t1[_], t2[_], lv[_], cur[_];

int tot = 1, head[_], to[M << 1], nxt[M << 1], w[M << 1];

vector<int> D[_];

int dfn[_], low[_], tim, id[_], cnt;

stack<int> st;

int col[_];

vector<pair<int, int>> Ans;

inline void add(int u, int v, int dis)
{
	to[++tot] = v;
	nxt[tot] = head[u];
	w[tot] = dis;
	head[u] = tot;
}

inline bool bfs()
{
    memset(lv, -1, sizeof(lv));
    lv[s] = 0;
    memcpy(cur, head, sizeof(head));
    queue<int> q;
    q.push(s);
    while (!q.empty())
    {
        int p = q.front();
        q.pop();
        for (int eg = head[p]; eg; eg = nxt[eg])
        {
            int v = to[eg], vol = w[eg];
            if (vol > 0 && lv[v] == -1)
                lv[v] = lv[p] + 1, q.push(v);
        }
    }
    return lv[t] != -1;
}

int dfs(int p = s, int flow = INT_MAX)
{
    if (p == t)
        return flow;
    int rmn = flow;
    for (int eg = cur[p]; eg && rmn; eg = nxt[eg])
    {
        cur[p] = eg;
        int v = to[eg], vol = w[eg];
        if (vol > 0 && lv[v] == lv[p] + 1)
        {
            int c = dfs(v, min(vol, rmn));
            rmn -= c;
            w[eg] -= c;
            w[eg ^ 1] += c;
        }
    }
    return flow - rmn;
}

inline int dinic()
{
    int ans = 0;
    while (bfs())
        ans += dfs();
    return ans;
}

void tarjan(int u)
{
	dfn[u] = low[u] = ++tim;
	st.push(u);
	for(int i = head[u]; i; i = nxt[i])
	{
		int v = to[i];
		if(!w[i]) continue;
		if(!dfn[v])
		{
			tarjan(v);
			low[u] = min(low[u], low[v]);
		}
		else if(!id[v])
		{
			low[u] = min(low[u], dfn[v]);
		}
	}
	if(dfn[u] == low[u])
	{
		++cnt;
		while(1)
		{
			int now = st.top();
			st.pop();
			id[now] = cnt;
			if(now == u) break;
		}
	}
}

void pre(int u, int c)
{
	col[u] = c;
	for(int v : D[u])
		if(!col[v]) pre(v, c ^ 1);
}

signed main()
{
	n = read(), m = read();
	s = n + 1, t = n + 2;
	for(int i = 1, u, v; i <= m; ++i)
	{
		u = read(), v = read();
		D[u].push_back(v);
		D[v].push_back(u);
	}
	for(int i = 1; i <= n; ++i)
	{
		if(!col[i]) pre(i, 2);
	}
	tot = 1;
	memset(head, 0, sizeof head);
	for(int i = 1; i <= n; ++i)
		if(col[i] == 2)
		{
			add(s, i, 1), add(i, s, 0);
			for(int v : D[i])
			{
				add(i, v, 1);
				add(v, i, 0);
			}
		}
		else
			add(i, t, 1), add(t, i, 0);
	int res = dinic();
	for(int i = 1; i <= t; ++i)
		if(!dfn[i]) tarjan(i);
	for(int u = 1; u <= n; ++u)
		if(col[u] == 2)
			for(int i = head[u]; i; i = nxt[i])
			{
				int v = to[i];
				if(w[i]) continue;
				if(v == s || v == t) continue;
				if(id[u] != id[v])
					Ans.push_back(u < v ? make_pair(u, v) : make_pair(v, u));
			}
	sort(Ans.begin(), Ans.end());
	write(Ans.size());
	putchar('\n');
	for(auto v : Ans)
		write(v.first), putchar(' '), write(v.second), putchar('\n');
	return 0;
}
```





---

## 作者：Refined_heart (赞：2)

### 题目大意

给定原图的补图，求删掉哪些边可以使得原图最大团变大。按字典序输出边。

### 题目解法

首先发现，我们求的是最大团，而且给出的是补图。

第一步先把最大团转化为补图的性质弄清楚：原图的最大团大小 $=$ 补图的最大独立集大小。

证明：原图的最大团必然两两有边，对应到补图上面就是两两无边，也就是独立集。最大团也就是最大独立集。证毕。

再证：题目的补图是二分图。

证明：题目已知原图可以被分为不超过两个团，也就是说补图要么是空的，要么一定是两列点，一列内部没有边。这也就是二分图。

考虑如何求一个二分图的最大独立集。求证：最大独立集 $=$ 点数 $-$ 最大匹配

证明：首先证明 最大独立集 $=$ 点数 $-$ 最小点覆盖。容易得到，点数 $-$ 最小点覆盖也就是取了最小点覆盖的补集。而点覆盖里面不存在一条边的两个点都没有被覆盖到，也就保证了补集一定是独立集。

而已知 最小点覆盖 $=$ 最大匹配。所以证毕，我们可以把原式写成：

$$\text{最大团=补图最大独立集=补图点数-最大匹配}$$

所以我们可以把问题扔到最大匹配上面了。让最大团变大也就是让最大匹配变小。什么情况下最大匹配会变小？当我们**删掉最大匹配的必须边**的时候。

下面问题转化为如何求二分图匹配的必须边。经典问题：

首先考虑求出二分图的左侧点和右侧点，然后源点向左侧点连边，汇点和右侧点连边，然后从左到右连边，跑一边最大流，求出最大匹配。下面考虑必须边的特征（下面认为当这条边剩余流量为 $0$ 时不可通行）：

* 在残量网络上，正边的流量已经跑满

这一条显然。

* 在残量网络上，边所连的两个点分属不同的 SCC 

证明：考虑右侧两点 $x,z,$ 且 $(y,x)$ 是匹配边， 若 $z$ 未匹配，则 $z$ 可以到达 $T;$ 若 $x$ 匹配，则 $T$ 可以到达 $x.$ 于是它们之间连通了。

如果 $y$ 可以到 $z,$ 进一步可以得它可以到达 $x,$ 也就是一条增广路。这时，$y,x$ 又是可以相互到达的，也就是它们属于同一个强连通分量。

所以必须边的两个点一定不属于同一个 SCC .

于是在残量网络上面跑 tarjan 即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef double db;
//#define int long long
#define fi first
#define se second
#define mk make_pair
#define pb emplace_back
#define poly vector<int>
#define Bt(a) bitset<a>
#define bc __builtin_popcount
#define pc putchar
#define ci const int&
//#define pii pair
const int mod = 1e9 + 7;
const db eps = 1e-10;
const int inf = (1 << 30);
inline int Max(ci x, ci y) {return x > y ? x : y;}
inline int Min(ci x, ci y) {return x < y ? x : y;}
inline db Max(db x, db y) {return x - y > eps ? x : y;}
inline db Min(db x, db y) {return x - y < eps ? x : y;}
inline int Add(ci x, ci y, ci M = mod) {return (x + y) % M;}
inline int Mul(ci x, ci y, ci M = mod) {return 1ll * x * y % M;}
inline int Dec(ci x, ci y, ci M = mod) {return (x - y + M) % M;}
typedef pair<int, int> pii;
inline int Abs(int x) {return x < 0 ? -x : x;}
//char buf[1<<21],*p1=buf,*p2=buf;
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char Obuf[105000],*O=Obuf;//Siz shoule be the size of Out File
int pst[30],ptop;
inline void Fprint(){fwrite(Obuf,1,O-Obuf,stdout);}
inline void Fwrite(int x){
  if(x==0){*O++='0';return;}
  if(x<0)*O++='-',x=-x;ptop=0;
  while(x)pst[++ptop]=x%10,x/=10;
  while(ptop)*O++=pst[ptop--]+'0';
  if(O-Obuf>100000)Fprint(),O=Obuf;
}
inline int read() {
    int s = 0, w = 1;
    char ch = getchar();
    while (!isdigit(ch)) {if (ch == '-') w = -1;ch = getchar();}
    while (isdigit(ch)) {s = s * 10 + ch - '0';ch = getchar();}
    return s * w;
}
inline void write(int x) {
    if (x < 0)putchar('-'), x = -x;
    if (x > 9)write(x / 10);
	pc(x % 10 + '0');
}
inline int qpow(int x, int y) {
    int res = 1;
    while (y) {if (y & 1)res = Mul(res, x);x = Mul(x, x);y >>= 1;}
    return res;
}
inline void cadd(int &x, int y) {x += y;}
inline void cmul(int &x, int y) {x *= y;}
inline void cmax(int &x, int y) {x = Max(x, y);}
inline void cmin(int &x, int y) {x = Min(x, y);}
const int N = 5e5 + 10;
namespace Refined_heart{
	int cur[N],head[N],tot=1,n,m,s,t,node,dep[N],gap[N],stfg;
	struct E{int nxt,to,flow,pre;}e[N],edge[N];
	int H[N],tto,SC[N];
	inline void link(int x,int y,int w){
		e[++tot]=(E){head[x],y,w,x};head[x]=tot;
		e[++tot]=(E){head[y],x,0,y};head[y]=tot;
	}
	inline void link_normal(int x,int y){edge[++tto]=(E){H[x],y,0,x};H[x]=tto;}
	queue<int>q;
	int bfs(int s,int t){
		q.push(t);dep[t]=1;++gap[1];
		while(!q.empty()){
			int x=q.front();q.pop();cur[x]=head[x];
			for(int i=head[x];i;i=e[i].nxt){
				int j=e[i].to;
				if(dep[j]||!e[i^1].flow)continue;
				dep[j]=dep[x]+1;++gap[dep[j]];
				q.push(j);
			}
		}
		return dep[s];
	}
	int ISAP(int u,int t,int flow){
		if(flow<=0||u==t)return flow;
		int rest=flow;
		for(int &i=cur[u];i;i=e[i].nxt){
			int v=e[i].to;
			if(!e[i].flow||dep[v]!=dep[u]-1)continue;
			int tmp=ISAP(v,t,Min(e[i].flow,rest));
			if(tmp<=0)continue;
			e[i].flow-=tmp;e[i^1].flow+=tmp;rest-=tmp;
			if(rest<=0)return flow-rest;
		}
		cur[u]=head[u];--gap[dep[u]];
		if(!gap[dep[u]])stfg=1;
		++gap[++dep[u]];return flow-rest;
	}
	int CALC(){
		int res=0;
		if(bfs(s,t)){
			while(!stfg)res+=ISAP(s,t,inf);
		}
		return res;
	}
	int st[N],top,scc,col[N],low[N],dfn[N],dfstime,inst[N];
	void tarjan(int x){
		low[x]=dfn[x]=++dfstime;
		inst[x]=1;st[++top]=x;
		for(int i=head[x];i;i=e[i].nxt){
			if(!e[i].flow)continue;
			int j=e[i].to;
			if(!dfn[j]){
				tarjan(j);
				cmin(low[x],low[j]);
			}
			else if(inst[j])cmin(low[x],dfn[j]);
		}
		if(low[x]==dfn[x]){
			int y=0;++scc;
			while(y=st[top--]){
				SC[y]=scc;
				inst[y]=0;
				if(x==y)break;
			}
		}
	}
	void specfic(int x,int fa,int cl){
		col[x]=cl;
		for(int i=H[x];i;i=edge[i].nxt){
			int j=edge[i].to;
			if(j==fa)continue;
			if(col[j]!=-1)continue;
			specfic(j,x,cl^1);
		}
	}
	int stp[N],pt[N];
	vector<pii>eg,Ans;
	bool check(int u,int v){
		if(col[u])swap(u,v);
		for(int i=head[pt[u]];i;i=e[i].nxt){
			int j=e[i].to;
			if(e[i].flow)continue;
			if(j==pt[v])return true;
		}
		return false;
	}
	void solve(){
		n=read();m=read();
		for(int i=1;i<=m;++i){
			int u=read();int v=read();
			link_normal(u,v);link_normal(v,u);
			eg.pb(mk(u,v));
		}
		for(int i=1;i<=n;++i)col[i]=-1;
		for(int i=1;i<=n;++i)if(col[i]==-1){specfic(i,0,0);}
		for(int i=1;i<=n;++i)if(!col[i])stp[i]=1;
		for(int i=1;i<=n;++i)pt[i]=++node;
		s=++node;t=++node;
		for(int i=1;i<=n;++i){
			if(stp[i])link(s,pt[i],1);
			else link(pt[i],t,1);
			
		}
		for(auto vv:eg){
			int u=vv.fi;
			int v=vv.se;
			if(!stp[u])swap(u,v);
			link(pt[u],pt[v],1);
		}
		int deldata=CALC();
		for(int i=1;i<=node;++i)if(!dfn[i])tarjan(i);
		for(auto vv:eg){
			int u=vv.fi;
			int v=vv.se;
			if(!SC[u]||!SC[v])continue;
			if(SC[u]==SC[v])continue;
			if(u>v)swap(u,v);
			if(check(u,v))Ans.pb(mk(u,v));
		}
		write((int)Ans.size());pc('\n');
		sort(Ans.begin(),Ans.end());
		for(auto vv:Ans){
			int u=vv.fi;
			int v=vv.se;
			write(u);pc(' ');write(v);pc('\n');
		}
	}
}
int main(){
	freopen("in.txt","r",stdin);
	Refined_heart::solve();
	return 0;
}



```


---

## 作者：Lyccrius (赞：1)

解题思路其它题解已经讲得非常清楚了。

引理：一条边 $(u,v)$ 必定在二分图最大匹配中，当且仅当 $u,v$ 在残量网络中不属于同一强连通分量。

证明略。

这篇题解主要讲一下不会网络流或者网络流写挂了怎么办。

因此这里采用的做法是匈牙利算法。

首先，跑匈牙利算法获取最大匹配。

根据引理，接下来需要在残量网络中跑 Tarjan，可是匈牙利算法中没有残量网络甚至网络这一概念。于是我们可以根据最大匹配生成残量网络。

考虑网络流计算二分图最大匹配的原理：
*	一个左部点 $u$ 为匹配点说明 $(s,u)$ 流量为 $1$；
*	一个右部点 $v$ 为匹配点说明 $(v,t)$ 流量为 $1$；
*	一条边 $(u,v)$ 为匹配边说明 $(u,v)$ 流量为 $1$。

可以推出在残量网络中：
*	$(u,s)$ 容量为 $1$；
*	$(v,u)$ 容量为 $1$；
*	$(t,v)$ 容量为 $1$。

根据匈牙利算法得出的匹配结果按以上规则建立残量网络即可。

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

typedef std::pair<int, int> pii;
typedef std::vector<pii> vpc;
typedef std::vector<int> vic;

const int maxN = 1e4;
const int maxM = 1.5e5;

int n, m;
int x[maxM + 10], y[maxM + 10];
int l[maxN + 10], r[maxN + 10];
vpc ans;

namespace graph {
    struct Vertex {
        int vis;
        int head;
        int match;
        int dfn;
        int low;
        int ins;
        int bel;
    } vertex[maxN + 10];

    struct Edge {
        int head;
        int next;
    } edge[maxM + 10];

    int ecnt;

    void addEdge(int tail, int head) {
        ecnt++;
        edge[ecnt].head = head;
        edge[ecnt].next = vertex[tail].head;
        vertex[tail].head = ecnt;
        return;
    }

    bool DFS(int u, int t) {
        for (int e = vertex[u].head; e; e = edge[e].next) {
            int v = edge[e].head;
            if (vertex[v].vis == t) continue;
            vertex[v].vis = t;
            if (vertex[v].match == 0 || DFS(vertex[v].match, t)) {
                vertex[v].match = u;
                return true;
            }
        }
        return false;
    }

    namespace residual {
        Vertex vertex[maxN + 10];
        Edge edge[maxM + 10];
        int ecnt;
        int scnt;
        int dfn;
        vic s;

        void addEdge(int tail, int head) {
            ecnt++;
            edge[ecnt].head = head;
            edge[ecnt].next = vertex[tail].head;
            vertex[tail].head = ecnt;
            return;
        }

        void addSCC(int u) {
            scnt++;
            int v;
            do {
                v = s.back();
                s.pop_back();
                vertex[v].ins = false;
                vertex[v].bel = scnt;
            } while (v != u);
            return;
        }

        void Tarjan(int u) {
            dfn++;
            vertex[u].dfn = dfn;
            vertex[u].low = dfn;
            vertex[u].ins = true;
            s.push_back(u);
            for (int e = vertex[u].head; e; e = edge[e].next) {
                int v = edge[e].head;
                if (!vertex[v].dfn) {
                    Tarjan(v);
                    vertex[u].low = std::min(vertex[u].low, vertex[v].low);
                } else if (vertex[v].ins) {
                    vertex[u].low = std::min(vertex[u].low, vertex[v].dfn);
                }
            }
            if (vertex[u].low == vertex[u].dfn) addSCC(u);
            return;
        }
    }
}

vic e[maxN + 10];
int v[maxN + 10];
int c[maxN + 10];

void color(int u, int col) {
    if (v[u]) return;
    v[u] = true;
    c[u] = col;
    for (auto w : e[u]) color(w, col ^ 1);
    return;
}

int main() {
    std::cin >> n >> m;
    for (int i = 1; i <= m; i++) std::cin >> x[i] >> y[i], e[x[i]].push_back(y[i]), e[y[i]].push_back(x[i]);
    for (int i = 1; i <= n; i++) if (!v[i]) color(i, 1);
    for (int i = 1; i <= n; i++) if (c[i]) l[i] = true; else r[i] = true;
    for (int i = 1; i <= m; i++) if (r[x[i]]) std::swap(x[i], y[i]);
    for (int i = 1; i <= m; i++) graph::addEdge(x[i], y[i]); 
    for (int i = 1; i <= n; i++) if (l[i]) graph::DFS(i, i);
    for (int i = 1; i <= m; i++) {
        if (graph::vertex[y[i]].match == x[i]) {
            graph::vertex[x[i]].match = y[i];
            graph::residual::addEdge(y[i], x[i]); 
        } else {
            graph::residual::addEdge(x[i], y[i]);
        }
    }
    for (int i = 1; i <= n; i++) if (graph::vertex[i].match) {
        if (l[i]) graph::residual::addEdge(i, 0);
        else graph::residual::addEdge(n + 1, i);
    } else {
        if (l[i]) graph::residual::addEdge(0, i);
        else graph::residual::addEdge(i, n + 1);
    }
    for (int i = 0; i <= n + 1; i++) if (graph::residual::vertex[i].dfn == 0) graph::residual::Tarjan(i);
    for (int i = 1; i <= m; i++) if (graph::vertex[y[i]].match == x[i]) if (graph::residual::vertex[x[i]].bel != graph::residual::vertex[y[i]].bel) ans.push_back(std::make_pair(std::min(x[i], y[i]), std::max(x[i], y[i])));
    std::sort(ans.begin(), ans.end());
    std::cout << ans.size() << '\n';
    for (auto i : ans) std::cout << i.first << ' ' << i.second << '\n';
    return 0;
}
```

---

## 作者：asuldb (赞：1)

[题目](https://www.luogu.org/problemnew/show/P3731)

发现题目给了一张补图，求的是最大团

而且隐隐约约告诉我们这张补图是一个二分图

于是非常自然联想到**最大团等于补图最大独立集**

**最大独立集又等于总点数-最小点覆盖**

**最小点覆盖=最大匹配**

使得最大团增加就需要使得最大匹配减小

于是我们终于读懂题目了，就是求二分图匹配的必须边

直接在残量网络里跑$tarjan$，就是如果这条边没有满流就连上

对于一条边$(x,y)$

如果$(x,y)$是一条匹配边或者$x$，$y$在同一个强联通分量里，那么这就是一条最大匹配的可行边

如果$(x,y)$是一条匹配边并且$x$，$y$不在同一个强连通分量里，那么这就是一条必须边

代码

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<vector>
#include<queue>
#define re register
#define mp std::make_pair
#define LL long long
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
const int maxn=12005;
const int inf=1e9;
inline int read() {
	char c=getchar();int x=0;while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=getchar();return x;
}
struct E{int v,nxt,f;}e[500005];
int n,m,num=1,S,T;
std::queue<int> q;
int head[maxn],d[maxn],cur[maxn],co[maxn];
inline void C(int x,int y,int f) {
	e[++num].v=y;e[num].f=f;
	e[num].nxt=head[x];head[x]=num;
}
inline void add(int x,int y,int f) {C(x,y,f);C(y,x,0);}
inline int BFS() {
	for(re int i=S;i<=T;i++) d[i]=0,cur[i]=head[i];
	d[S]=1,q.push(S);
	while(!q.empty()) {
		int k=q.front();q.pop();
		for(re int i=head[k];i;i=e[i].nxt)
		if(!d[e[i].v]&&e[i].f) d[e[i].v]=d[k]+1,q.push(e[i].v);
	}
	return d[T];
}
int dfs(int x,int now) {
	if(x==T||!now) return now;
	int flow=0,ff;
	for(re int& i=cur[x];i;i=e[i].nxt)
	if(e[i].f&&d[e[i].v]==d[x]+1) {
		ff=dfs(e[i].v,min(e[i].f,now));
		if(ff<=0) continue;
		now-=ff,flow+=ff,e[i].f-=ff,e[i^1].f+=ff;
		if(!now) break;
	}
	return flow;
}
std::vector<int> ee[maxn];
namespace Tarjan {
	std::vector<int> v[maxn];
	int dfn[maxn],low[maxn],col[maxn],st[maxn],f[maxn];
	int top,p,cnt,mid,tot;
	std::pair<int,int> ans[150005];
	void tarjan(int x) {
		dfn[x]=low[x]=++cnt;
		f[x]=1,st[++top]=x;
		for(re int i=0;i<v[x].size();++i) {
			int j=v[x][i];
			if(!dfn[j]) tarjan(j),low[x]=min(low[x],low[j]);
			else if(f[j]) low[x]=min(low[x],dfn[j]);
		}
		if(dfn[x]==low[x]) {
			++p;
			do {
				mid=st[top--];
				f[mid]=0;
				col[mid]=p;
			}while(mid!=x);
		}
	}
	void solve() {
		for(re int i=S;i<=T;i++)
			for(re int j=head[i];j;j=e[j].nxt)
			if(e[j].f) v[i].push_back(e[j].v);
		for(re int i=S;i<=T;i++) if(!dfn[i]) tarjan(i);
		for(re int i=1;i<=n;i++) {
			if(co[i]) continue;
			for(re int j=head[i];j;j=e[j].nxt)
			if(col[i]!=col[e[j].v]&&!e[j].f&&e[j].v!=S) {
				int xx=min(i,e[j].v);
				int yy=max(i,e[j].v);
				ans[++tot]=mp(xx,yy);
			}
		}
		std::sort(ans+1,ans+tot+1);
		printf("%d\n",tot);
		for(re int i=1;i<=tot;i++) printf("%d %d\n",ans[i].first,ans[i].second);
	}
}
void paint(int x,int c) {
	co[x]=c;
	for(re int i=0;i<ee[x].size();i++) {
		int j=ee[x][i];
		if(co[j]!=2) continue;
		paint(j,c^1);
	}
}
int main() {
	n=read(),m=read();T=n+1;
	for(re int x,y,i=1;i<=m;i++) 
		x=read(),y=read(),ee[x].push_back(y),ee[y].push_back(x);
	for(re int i=1;i<=n;i++) co[i]=2;
	for(re int i=1;i<=n;i++)
	if(co[i]==2) paint(i,0);
	for(re int i=1;i<=n;i++) 
	if(!co[i]) add(S,i,1);else add(i,T,1);
	for(re int i=1;i<=n;i++) {
		if(co[i]) continue;
		for(re int j=0;j<ee[i].size();j++) 
			add(i,ee[i][j],1);
	}
	while(BFS()) dfs(S,inf);
	Tarjan::solve();
	return 0;
}
```


---

## 作者：kkio (赞：0)

首先明显想到的是二分图。相当于要求二分图的最大团，然后如果添加入某一条边，能不能使那个最大团变大。

考虑二分图最大团的经典转化：建原图的补图，然后相当与集合中的点两两之间没有边，就是最大独立集。

二分图最大独立集 = 点数 - 二分图最小点覆盖 = 点数 - 二分图最大匹配。

也就是说，问题变成了，在补图中删掉一条边，会不会让二分图的最大匹配变少。

也就是二分图最大匹配的必须边问题。

非完备匹配的时候，可以建图跑dinic后，再在残余网络上跑一次tarjan，如果边的流量是 $ 1 $，且两端不在一个强连通分量里，则为必须边。

```cpp
#pragma GCC optimize(2)
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e4+10;
struct edge{int to,cap,next;}E[maxn*30];
int head[maxn],tot=1;
inline void add(int u,int v,int c)
{
    E[++tot]={v,c,head[u]};
    head[u]=tot;
    E[++tot]={u,0,head[v]};
    head[v]=tot;
}
vector<int> G[maxn];
int dep[maxn],cur[maxn];
int n,m,S,T,rid;
bool bfs()
{
    for(int i=1;i<=rid;i++)dep[i]=-1,cur[i]=head[i];
    queue<int> q;
    q.push(S);
    dep[S]=1;
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(int i=head[u];i;i=E[i].next)
        {
            int v=E[i].to,c=E[i].cap;
            if(dep[v]==-1&&c)
            {
                dep[v]=dep[u]+1;
                q.push(v);
            }
        }
    }
    return dep[T]!=-1;
}
int dfs(int u,int flow)
{
    //printf("!%d %d\n",u,flow);
    if(u==T)return flow;
    int ret=0;
    for(int i=head[u];i;i=E[i].next)
    {
        int v=E[i].to,c=E[i].cap;
        if(dep[v]==dep[u]+1&&c)
        {
            int fl=dfs(v,min(c,flow-ret));
            if(!fl)continue;
            E[i^1].cap+=fl;
            E[i].cap-=fl;
            ret+=fl;
            if(ret==flow)break;
        }
    }
    return ret;
}
int dinic()
{
    int ret=0;
    while(bfs())ret+=dfs(S,2e9);
    return ret;
}
int col[maxn];
bool ins[maxn];
void coldfs(int u)
{
    for(int v:G[u])
    {
        if(col[v]!=-1)continue;
        col[v]=col[u]^1;
        coldfs(v);
    }
}
vector< pair<int,int> > ans;
int dfn[maxn],low[maxn],times,cnt,stk[maxn],top,bel[maxn];
void tarjan(int u,int fa)
{
    dfn[u]=low[u]=++times;
    stk[++top]=u;
    ins[u]=1;
    for(int i=head[u];i;i=E[i].next)
    {
        int v=E[i].to,c=E[i].cap;
        if(!c||v==fa)continue;
        if(!dfn[v])
        {
            tarjan(v,u);
            low[u]=min(low[u],low[v]);
        }
        else if(ins[v])low[u]=min(low[u],dfn[v]);
    }
    //printf("#%d %d %d\n",u,dfn[u],low[u]);
    if(low[u]==dfn[u])
    {
        int x=0;
        ++cnt;
        //printf("!%d\n",cnt);
        while(x!=u)
        {
            x=stk[top];
          //  printf("%d\n",x);
            bel[x]=cnt;
            ins[x]=0;
            top--;
        }
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        G[u].push_back(v);
        G[v].push_back(u);
    }
    memset(col,-1,sizeof col);
    for(int i=1;i<=n;i++)
        if(col[i]==-1)
        {
            col[i]=0;
            coldfs(i);
        }
    rid=n;
    S=++rid,T=++rid;
    for(int i=1;i<=n;i++)
        if(col[i]==0)
        {
            add(S,i,1);
            for(int j:G[i])add(i,j,1);
        }
        else 
            add(i,T,1);
   // printf("%d %d\n",S,T);
    dinic();
  //  puts("?");
    for(int i=1;i<=n;i++)
        if(!dfn[i])tarjan(i,0);
    for(int i=1;i<=n;i++)
        if(col[i]==0)
            for(int e=head[i],j=E[e].to;e;e=E[e].next,j=E[e].to)
                if(E[e].cap==0&&i<=n&&j<=n&&bel[i]!=bel[j])
                    ans.push_back({min(i,j),max(i,j)});
    sort(ans.begin(),ans.end());
    printf("%d\n",ans.size());
    for(auto &p:ans)
        printf("%d %d\n",p.first,p.second);
    return 0;
}
/*
6 1
1 5
6 2
2 4
2 5
6 3
4 7
5 7
*/
```

---


# 【模板】三维偏序（陌上花开）

## 题目背景

这是一道模板题，可以使用 bitset，CDQ 分治，KD-Tree 等方式解决。

## 题目描述

有 $ n $ 个元素，第 $ i $ 个元素有 $ a_i,b_i,c_i $ 三个属性，设 $ f(i) $ 表示满足 $ a_j \leq a_i $ 且 $ b_j \leq b_i $ 且 $ c_j \leq c_i $ 且 $ j \ne i $ 的 $j$ 的数量。

对于 $ d \in [0, n) $，求 $ f(i) = d $ 的数量。

## 说明/提示

$ 1 \leq n \leq 10^5$，$1 \leq a_i, b_i, c_i \le k \leq 2 \times 10^5 $。


## 样例 #1

### 输入

```
10 3
3 3 3
2 3 3
2 3 1
3 1 1
3 1 2
1 3 1
1 1 2
1 2 2
1 3 2
1 2 1
```

### 输出

```
3
1
3
0
1
0
1
0
0
1
```

# 题解

## 作者：echo6342 (赞：354)

这并不是对劲的cdq分治……

如果想看更不对劲的，点这里-> [:-)](http://www.cnblogs.com/xzyf/p/8466293.html)

cdq分治每次计算前一半对后一半的影响。具体地，
假设三维分别是x,y,z，先按x排序。分治时每次将前半边、后半边分别按y排序。虽然现在x的顺序被打乱了，但是前半边还是都小于后半边的，所以要是只计算前半边对后半边的偏序关系，是不会受到x的影响的。维护后一半的指针i，前一半的指针j，每次将i后移一位时，若y[j]<=y[i]则不断后移j，并不断将z[j]加入树状数组。然后再查询树状数组中有多少数小于等于z[i]。 最后要清空树状数组。

它有那么一些些眼熟，解一维偏序时就是归什么排序。

```cpp
#include<iostream>
#include<iomanip>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#define maxn 100010
#define maxk 200010
#define ll long long 
using namespace std;
inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(isdigit(ch)==0 && ch!='-')ch=getchar();
    if(ch=='-')f=-1,ch=getchar();
    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
    return x*f;
}
inline void write(int x)
{
    int f=0;char ch[20];
    if(!x){puts("0");return;}
    if(x<0){putchar('-');x=-x;}
    while(x)ch[++f]=x%10+'0',x/=10;
    while(f)putchar(ch[f--]);
    putchar('\n');
}
typedef struct node
{
    int x,y,z,ans,w;	
}stnd;
stnd a[maxn],b[maxn];
int n,cnt[maxk];
int k,n_;
bool cmpx(stnd u,stnd v)
{
    if(u.x==v.x)
    {
        if(u.y==v.y)
            return u.z<v.z;
        return u.y<v.y;
    }
    return u.x<v.x;
}
bool cmpy(stnd u,stnd v)
{
    if(u.y==v.y)
        return u.z<v.z;
    return u.y<v.y;
}
struct treearray
{
    int tre[maxk],kk;
    int lwbt(int x){return x&(-x);}
    int ask(int i){int ans=0; for(;i;i-=lwbt(i))ans+=tre[i];return ans;}
    void add(int i,int k){for(;i<=kk;i+=lwbt(i))tre[i]+=k;}
}t;
void cdq(int l,int r)
{
    if(l==r)return;
    int mid=(l+r)>>1;
    cdq(l,mid);cdq(mid+1,r);
    sort(a+l,a+mid+1,cmpy);
    sort(a+mid+1,a+r+1,cmpy);
    int i=mid+1,j=l;
    for(;i<=r;i++)
    {
        while(a[j].y<=a[i].y && j<=mid)
            t.add(a[j].z,a[j].w),j++;
        a[i].ans+=t.ask(a[i].z);
    }
    for(i=l;i<j;i++)
        t.add(a[i].z,-a[i].w);
}
int main()
{
    n_=read(),k=read();t.kk=k;
    for(int i=1;i<=n_;i++)
        b[i].x=read(),b[i].y=read(),b[i].z=read();
    sort(b+1,b+n_+1,cmpx);
    int c=0;
    for(int i=1;i<=n_;i++)
    {
        c++;
        if(b[i].x!=b[i+1].x || b[i].y!=b[i+1].y || b[i].z!=b[i+1].z )
            a[++n]=b[i],a[n].w=c,c=0;
    } 
    cdq(1,n); 	
    for(int i=1;i<=n;i++)
        cnt[a[i].ans+a[i].w-1]+=a[i].w;
    for(int i=0;i<n_;i++)
        write(cnt[i]);
    return 0;
}


```

---

## 作者：FlashHu (赞：164)

安利蒟蒻[CDQ分治总结](https://www.cnblogs.com/flashhu/p/9381075.html)

分治就是分治，“分而治之”的思想。

那为什么会有CDQ分治这样的称呼呢？

这一类分治有一个重要的思想——用一个子问题来计算对另一个子问题的贡献。

有了这种思想，就可以方便地解决更复杂的问题。

这样一句话怎样理解好呢？还是做做题目吧。

三维偏序问题，即给出若干元素，每个元素有三个属性值$a,b,c$，询问对于每个元素$i$，满足$a_j\leq a_i,b_j\leq b_i,c_j\leq c_i$的$j$的个数

不用着急，先从简单的问题开始

试想一下二位偏序也就是$a_j\leq a_i,b_j\leq b_i$怎么做

先按$a$为第一关键字，$b$为第二关键字排序，那么我们就保证了第一维$a$的有序。

于是，对于每一个$i$，只可能$1$到$i-1$的元素会对它有贡献，那么直接查$1$到$i-1$的元素中满足$b_j\leq b_i$的元素个数。

具体实现？动态维护$b$的树状数组，从前到后扫一遍好啦，$O(n\log n)$。

那么三维偏序呢？我们只有在保证前两位都满足的情况下才能计算答案了。

仍然按$a$为第一关键字，$b$为第二关键字，$c$为第三关键字排序，第一维保证左边小于等于右边了。

为了保证第二维也是左边小于等于右边，我们还需要排序。

想到归并排序是一个分治的过程，我们可不可以在归并的过程中，统计出在子问题中产生的对答案贡献呢？

现在我们有一个序列，我们把它递归分成两个子问题，子问题进行完归并排序，已经保证$b$有序。此时，两个子问题间有一个分界线，原来第一维左边小于等于右边，所以现在分界线左边的任意一个的$a$当然还是都小于右边的任意一个。那不等于说，只有分界线左边的能对右边的产生贡献？

于是，问题降到了二维。我们就可以排序了，归并排序（左边的指针为$j$，右边的为$i$）并维护$c$的树状数组，如果当前$b_j\leq b_i$，说明$j$可以对后面加入的满足$c_j\leq c_i$的$i$产生贡献了，把$c_j$加入树状数组；否则，因为后面加入的$j$都不会对$i$产生贡献了，所以就要统计之前被给的所有贡献了，查询树状数组$c_i$的前缀和。

这是在分治中统计的子问题的答案，跟总答案有怎样的关系呢？容易发现，每个子问题统计的只有跨越分界线的贡献，反过来看，每一个能产生贡献的$i,j$，有且仅有一个子问题，两者既同时被包含，又在分界线的异侧。那么所有子问题的贡献加起来就是总答案。

算法的大致思路就是这样啦。至于复杂度，$T(n)=O(n\log k)+2T(\frac 2 n)=O(n\log n\log k)$。

当然还有不少细节问题。

最大的问题就在于，可能有完全相同的元素。这样的话，本来它们相互之间都有贡献，可是cdq的过程中只有左边的能贡献右边的。这可怎么办呢？

我们把序列去重，这样现在就没有相同的了。给现在的每个元素一个权值$v$等于出现的次数。中间的具体实现过程也稍有变化，在树状数组中插入的值是$v$而不是$1$了，最后统计答案时，也要算上相同元素内部的贡献，`ans+=v-1`。

写法上，为了防止sort和归并排序中空间移动太频繁，没有对每个元素封struct，这样的话就要膜改一下cmp函数（蒟蒻也是第一次发现cmp可以这么写）

蒟蒻还是觉得开区间好写一些吧。。。当然闭区间好理解些。。。
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define RG register
#define R RG int
using namespace std;
const int N=1e5+9,SZ=2.2e6;
char buf[SZ],*pp=buf-1;//fread必备
int k,a[N],b[N],c[N],p[N],q[N],v[N],cnt[N],ans[N],*e;
inline int in(){
    while(*++pp<'-');
    R x=*pp&15;
    while(*++pp>'-')x=x*10+(*pp&15);
    return x;
}
void out(R x){
    if(x>9)out(x/10);
    *++pp=x%10|'0';
}
inline bool cmp(R x,R y){//直接对数组排序，注意三关键字
    return a[x]<a[y]||(a[x]==a[y]&&(b[x]<b[y]||(b[x]==b[y]&&c[x]<c[y])));
}
inline void upd(R i,R v){//树状数组修改
    for(;i<=k;i+=i&-i)e[i]+=v;
}
inline int ask(R i){//树状数组查前缀和
    R v=0;
    for(;i;i-=i&-i)v+=e[i];
    return v;
}
void cdq(R*p,R n){//处理一个长度为n的子问题
    if(n==1)return;
    R m=n>>1,i,j,k;
    cdq(p,m);cdq(p+m,n-m);//递归处理
    memcpy(q,p,n<<2);//归并排序
    for(k=i=0,j=m;i<m&&j<n;++k){
        R x=q[i],y=q[j];
        if(b[x]<=b[y])upd(c[p[k]=x],v[x]),++i;//左边小，插入
        else  cnt[y]+=ask(c[p[k]=y])     ,++j;//右边小，算贡献
    }
    for(;j<n;++j)cnt[q[j]]+=ask(c[q[j]]);//注意此时可能没有完成统计
    memcpy(p+k,q+i,(m-i)<<2);
    for(--i;~i;--i)upd(c[q[i]],-v[q[i]]);//必须这样还原树状数组，memset是O(n^2)的
}
int main(){
    fread(buf,1,SZ,stdin);
    R n=in(),i,j;k=in();e=new int[k+9];
    for(i=0;i<n;++i)
        p[i]=i,a[i]=in(),b[i]=in(),c[i]=in();
    sort(p,p+n,cmp);
    for(i=1,j=0;i<n;++i){
        R x=p[i],y=p[j];++v[y];//模仿unique双指针去重，统计v
        if(a[x]^a[y]||b[x]^b[y]||c[x]^c[y])p[++j]=x;
    }
    ++v[p[j++]];
    cdq(p,j);
    for(i=0;i<j;++i)
        ans[cnt[p[i]]+v[p[i]]-1]+=v[p[i]];//答案算好
    for(pp=buf-1,i=0;i<n;++i)
        out(ans[i]),*++pp='\n';
    fwrite(buf,1,pp-buf+1,stdout);
}
```


---

## 作者：Shadows (赞：161)

其实cdq分治可以一直嵌套下去，不一定需要数据结构维护

这样1d 排序，2d cdq，3d cdq统计答案，推而广之，四维偏序也是一样道理，用cdq统计答案，和用cdq外层嵌套几乎一样操作

```cpp
    #include<cstdio>
    #include<cstring>  
    #include<iostream>  
    #include<algorithm>
    #define maxn 100010 
    using namespace std; 
    int n,k,ans[maxn]={0},d[maxn]={0};
    struct node{
        int x,y,z;
        bool b;
        int *ans;  
        inline void get(){
            scanf("%d%d%d",&x,&y,&z);
            return;
        }
        bool operator==(const node &a)
        const{  
            return x==a.x&&y==a.y&&z==a.z;
        }
    }a[maxn],b[maxn],c[maxn];
    inline bool cmp(const node &a, const node &b)  {
        return a.x<b.x||a.x==b.x&&a.y<b.y||a.x==b.x&&a.y==b.y&&a.z<b.z;  
    }
    void merge2(int l,int r){
        if(l==r)return;
        int mid=(l+r)>>1;
        merge2(l,mid);
        merge2(mid+1,r);
        for(int i=l,j=l,k=mid+1,cnt=0;i<=r;++i){
            if((k>r||b[j].z<=b[k].z)&&j<=mid)
            c[i]=b[j++],cnt+=c[i].b;
            else{
                c[i]=b[k++];
                if(!c[i].b)*c[i].ans+=cnt;
            }
        }
        for(int i=l;i<=r;++i)b[i]=c[i];
    }
    void merge1(int l,int r){
        if(l==r)return;
        int mid=(l+r)>>1;
        merge1(l,mid);
        merge1(mid+1,r);
        for(int i=l,j=l,k=mid+1;i<=r;++i){
            if((k>r||a[j].y<=a[k].y)&&j<=mid)
            b[i]=a[j++],b[i].b=1;
            else
            b[i]=a[k++],b[i].b=0;
        }
        for(int i=l;i<=r;++i)a[i]=b[i];
        merge2(l,r);
    }
    int main(){
        scanf("%d%d",&n,&k);
        for(int i=1;i<=n;++i)
        a[i].get(),a[i].ans=&ans[i],ans[i]=0;
        sort(a+1,a+n+1,cmp);
        for(int i=n-1;i;--i)
        if(a[i]==a[i+1])
        *a[i].ans=*a[i+1].ans+1;
        merge1(1,n);
        for(int i=1;i<=n;++i)++d[ans[i]];
        for(int i=0;i<n;++i)
        printf("%d\n",d[i]);
        return 0;
}
```

---

## 作者：撤云 (赞：62)

[戳我](https://www.cnblogs.com/hbxblog/p/10138165.html)食用效果更加
####**前言**
> 陌上花开，可缓缓归矣
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——吴越王

1. 寓意：意思是：田间阡陌上的花开了，你可以一边赏花，一边慢慢回来。  
2. 隐意:春天都到了，你怎么还没有回来。形容吴越王期盼夫人早日归来的急切心情。  

Ask:那么这和cdq有什么关系呢?  
Answer:~~并没有什么关系，增强语文水平而已~~，现在来看一到题目:[陌上花开](https://www.lydsy.com/JudgeOnline/problem.php?id=3262)。这就有关系了吧。

题目大意是:有$n$个元素，第$i$个元素有$a_i,b_i,c_i$三个属性，设$f(i)$表示满足$a_j≤a_i$且$b_j≤b_i$且$c_j≤c_i$的$j$的数量。求$f(i)=d$的数量$d\in[0,n)$  

做法1：暴力
$O(n^2)$的扫一遍求一下就好了。  

```cpp
#include<bits/stdc++.h>
int k,n,f[200001],a[200001],b[200001],c[200001],ans;
int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
		scanf("%d%d%d",&a[i],&b[i],&c[i]);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)
			if(a[j]<=a[i]&&b[j]<=b[i]&&c[j]<=c[i]&&i!=j)
				ans++;
		f[ans]++,ans=0;
	}
	for(int i=0;i<n;i++)
		printf("%d\n",f[i]);
}
```

这个应该不需要多讲吧,普及组的难度，但不要说不需要，你在对拍的时候就需要他了  

做法2： K-DTree  

~~不会,我tcl~~  

做法三：cdq分治  

现在来正式讲一讲cdq分治

### cdq分治

####前置要求：

1. [树状数组](https://www.cnblogs.com/hbxblog/p/9866972.html)
2. [基础分治](http://baidu.physton.com/?q=去普及组吧,这不是你改来的地方)
3. [树状数组求逆序对](https://www.cnblogs.com/hbxblog/p/10138151.html)

逆序对的问题是二维的,我们只需要讲一维排序，然后在用树状数组维护即可。  
那么对于三维的陌上花开呢?我们还是可以用这个方法，首先先将数列按第一位排序，这样我们只需要考虑两维的情况。于是我们可以分治做了，将某一个序列$[l,r]$,分成段$[l,mid]$和$[mid+1,r]$,然后在对$[l,r]$这段区间的第二维进行排序。若点在排序前属于$[l,mid]$,树状数组单点修改；否则该点在排序前属于$[m+1,r]$,便统计一次。(其实就是类似于树状数组求逆序对的操作)

**一定要记得去重，否则会出事的**

#### code 

``` cpp
#include<bits/stdc++.h>
using namespace std;
const int N=200001;
struct node{
	int x,y,z,id;
}a[N];
int c[N<<2],k,n,b[N],bj[N],f[N];
int lowbit(int x){
	return x&(-x);
}
int read(){
    int x=0,f=1;
	char c=getchar();
    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();
    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
    return f*x;
}
void add(int x,int v){
	while(x<=k)
		c[x]+=v,x+=lowbit(x);
}
int sum(int x){
	int ans=0;
	while(x)
		ans+=c[x],x-=lowbit(x);
	return ans;
}
bool cmp1(const node & a , const node & b ){
	if(a.x!=b.x)
		return a.x<b.x;
	if(a.y!=b.y)
		return a.y<b.y;
	return a.z<b.z;
}
bool cmp2(const node & a , const node & b ){
	if(a.y!=b.y)
		return a.y<b.y;
	if(a.z!=b.z)
		return a.z<b.z;
	return a.x<b.x;
}
void cdq(int l,int r){
	if(l==r)
		return ;
	int mid=(l+r)>>1,flag;
	cdq(l,mid),cdq(mid+1,r);
	sort(a+l,a+r+1,cmp2);
	for(int i=l;i<=r;i++)
		(a[i].x<=mid)?add(a[i].z,1),flag=i:b[a[i].id]+=sum(a[i].z);
	for(int i=l;i<=r;i++)
		if(a[i].x<=mid)
			add(a[i].z,-1);
}
int main(){
	n=read(),k=read();
	for(int i=1;i<=n;i++)
		a[i].x=read(),a[i].y=read(),a[i].z=read(),a[i].id=i;
	sort(a+1,a+1+n,cmp1);
	for(int i=1;i<=n;){
		int j=i+1;
		while(j<=n&&a[j].x==a[i].x&&a[j].y==a[i].y&&a[j].z==a[i].z)
			j++;
		while(i<j)
			bj[a[i].id]=a[j-1].id,i++;
	}
	for(int i=1;i<=n;i++)
		a[i].x=i;
	cdq(1,n);
	for(int i=1;i<=n;i++)
		f[b[bj[a[i].id]]]++;
	for(int i=0;i<n;i++)
		printf("%d\n",f[i]);
}

```

---

## 作者：于丰林 (赞：59)

作为CDQ的一道板子题，我们先来明确一下到底什么是CDQ？

CDQ通俗一点说就是三句话：

1.递归前一半

2.判断前一半对于后一半的影响

3.递归后一半

那么我们来看这道经典的三维偏序题，说一下大体的思路：

首先我们可以以x作为第一关键字进行排序，（y和z作为次要关键字），这样我们就可以保证从左到右是以x单调递增的。

然后我们将这个区间一分为二，分别对于每一个序列以y作为第一关键字排序，这样一来我们得到的两个序列拥有以下的性质：

1.左序列的任意x值都小于右序列的任意x值

2.每一个序列里的y值都是单调递增的

最后我们分别在序列头和序列中点设定两个指针j和i，对于每一个i，j都从上一个不满足条件的地方开始枚举，将j对应的y小于i对应的y的j加入树状数组中，最后只要判断z值是否满足条件就可以了。

当然，这道题还有一些小细节：

1.由于原序列可能会有重复的数，我们要先进行去重，并储存每一个数都代表了几个相同的数。

2.每一次i的增加都要清空树状数组，只要加上之前加的相反数就可以了。

好像也就这些了。。。

最后，附上本题代码：

```cpp
#include<cstdio>
#include<algorithm>
#define maxn 100010
#define maxk 200010
using namespace std;
struct node
{
    int x,y,z,ans,w;
};
node a[maxn],b[maxn];
int n,cnt[maxk];
int k,z;
bool cmp1(node u,node v)
{
    if(u.x==v.x)
    {
        if(u.y==v.y)
            return u.z<v.z;
        return u.y<v.y;
    }
    return u.x<v.x;
}
bool cmp2(node u,node v)
{
    if(u.y==v.y)
        return u.z<v.z;
    return u.y<v.y;
}
struct TREE
{
    int tre[maxk],kk;
    int lowbit(int x)
    {
        return x&(-x);
    }
    int ask(int i)
    {
        int ans=0;
        for(; i; i-=lowbit(i))
        {
            ans+=tre[i];
        }
        return ans;
    }
    void add(int i,int k)
    {
        for(; i<=kk; i+=lowbit(i))
        {
            tre[i]+=k;
        }
    }
} t;
void cdq(int l,int r)
{
    if(l==r)
    {
        return;
    }
    int mid=(l+r)>>1;
    cdq(l,mid);
    cdq(mid+1,r);
    sort(a+l,a+mid+1,cmp2);
    sort(a+mid+1,a+r+1,cmp2);
    int i=mid+1,j=l;
    while(i<=r)
    {
        while(a[j].y<=a[i].y && j<=mid)
        {
            t.add(a[j].z,a[j].w);
            j++;
        }
        a[i].ans+=t.ask(a[i].z);
        i++;
    }
    for(i=l; i<j; i++)
    {
        t.add(a[i].z,-a[i].w);
    }
}
int main()
{
    scanf("%d%d",&z,&k);//z是数量，k是最大属性值
    t.kk=k;//设定上限，t是维护的树状数组
    for(int i=1; i<=z; i++)
    {
        scanf("%d%d%d",&b[i].x,&b[i].y,&b[i].z);//
    }
    sort(b+1,b+z+1,cmp1);//排序
    int c=0;
    for(int i=1; i<=z; i++)
    {
        c++;
        if(b[i].x!=b[i+1].x || b[i].y!=b[i+1].y || b[i].z!=b[i+1].z )
            a[++n]=b[i],a[n].w=c,c=0;
    }//去重
    cdq(1,n);//cdqaq
    for(int i=1; i<=n; i++)
    {
        cnt[a[i].ans+a[i].w-1]+=a[i].w;//这个地方不太好理解：cnt【x】就是储存f【i】= x的个数，x就等于i的答案加上它重复的个数（可以取等）减去本身
    }
    for(int i=0; i<z; i++)
    {
        printf("%d\n",cnt[i]);
    }
    return 0;
}
```

---

## 作者：1LoveNozomi (赞：45)

这里都没有bitset的写法，虽然bitset不能够过这道题目，但是对于维数更高或者要求强制在线的题目，bitset有很大优势，我们应该学习。
bitset只是算法中使用的数据结构而已，这个算法的本质是暴力。然后用分块优化暴力。
这个算法能求出每个元素能与其他几个元素构成偏序关系，对于一个元素，这个暴力算法的做法是：
1. 对于除自己以外的所有元素，把属性a的值小于等于自己的属性a的值的元素的编号组成一个集合。（反过来说，这个集合里存放的都是元素的编号，里面的编号指向的元素的属性a的值都小于等于自己的属性a的值，且编号不在此集合的元素的属性a的值一定大于自己的属性a的值）
2. 同理构造b集合
3. 同理构造c集合
4. ……（多少种属性我们就处理出多少个集合。把元素的编号大小当作属性值也可以。）
5. 把构造的所有集合交在一起，得到的集合里面的每个编号对应的元素都和自己构成偏序关系。因为能够在交集中出现的元素，必定其每个属性值都不超过自己对应的每个属性值，符合题意。

下面是代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=100000,maxk=3,maxblock=320,inf=0x3f3f3f3f;
int maxsize,n,k,length,belong[maxn+5],ans[maxn+5],temp[maxn+5];
struct Demension {
	int value[maxn+5],size;
	vector<int> list[maxn+5];
	bitset<maxn+5> PreBlock[maxblock+5];//储存前i个块的答案
	void Discretization() {//将元素在当前维度的属性值离散化
		int i;
		memcpy(temp+1,value+1,n<<2);
		sort(temp+1,temp+1+n);
		size=unique(temp+1,temp+1+n)-(temp+1);
		maxsize=max(maxsize,size);
		for(i=1; i<=size; ++i)
			list[i].clear();
		for(i=1; i<=n; ++i)
			list[(value[i]=lower_bound(temp+1,temp+1+size,value[i])-temp)].push_back(i);
	}
	bitset<maxn+5> Get(int p) {//当前维度下，属性值小于元素p的属性值的元素的编号集合
		int i,j,temp;
		p=value[p];
		bitset<maxn+5> res=PreBlock[belong[p]-1];
		for(i=(belong[p]-1)*length+1; i<=p; ++i) {
			temp=list[i].size();
			for(j=0; j<temp; ++j)
				res.set(list[i][j]);
		}
		return res;
	}
} demension[maxk+5];
inline void Calc();
inline void Input();
inline void Work();
inline void Read(int &x);
void Print(int x);
int main() {
	Input();
	Calc();
	Work();
	return 0;
}
void Calc() {
	int i,j,t,m;
	bitset<maxn+5> temp;
	for(i=1; i<=k; ++i)
		demension[i].Discretization();//离散化
	length=sqrt(maxsize);
	for(i=1; i<=maxsize; ++i)
		belong[i]=(i-1)/length+1;//值域分块
	for(i=1; i<=k; ++i) {
		demension[i].PreBlock[0].reset();
		temp.reset();
		for(j=1; j<=demension[i].size; ++j) {
			m=demension[i].list[j].size();
			for(t=0; t<m; ++t)
				temp.set(demension[i].list[j][t]);
			if(belong[j]^belong[j+1])//权值数组，把属性值的范围进行分块,第i块储存了前i块的信息
				demension[i].PreBlock[belong[j]]=temp;
		}
	}
}
void Work() {
	int i,j;
	bitset<maxn+5> temp;
	for(i=1; i<=n; ++i) {
		temp.set();
		for(j=1; j<=k; ++j)
			temp&=demension[j].Get(i);
		++ans[temp.count()-1];
	}
	for(i=0; i<n; ++i) {
		Print(ans[i]);
		putchar('\n');
	}
}
inline void Input() {
	int i,j;
	scanf("%d%d",&n,&k);//n个元素，k个属性
	k=3;
	for(i=1; i<=n; ++i)
		for(j=1; j<=k; ++j)
			Read(demension[j].value[i]);
}
inline void Read(int &x) {
	x=0;
	char c=getchar();
	while(!isdigit(c))
		c=getchar();
	do {
		x=(x<<3)+(x<<1)+(48^c);
		c=getchar();
	} while(isdigit(c));
}
void Print(int x) {
	if(x>9)
		Print(x/10);
	putchar(48^(x%10));
}
```
Update 2019.10.27:修改原代码的码风

---

## 作者：Ireliaღ (赞：38)

**树状数组套值域线段树**

## 三维偏序

看到三维偏序，最简单直接的思路就是先按照$x$把元素排序，然后按顺序把每个元素放进二维数据结构，统计二维前缀和，即为$x$、$y$、$z$都不超过该元素的元素个数。

以下为二维线段树（树套树）代码

```cpp
// luogu-judger-enable-o2
#include <iostream>
#include <algorithm>

using namespace std;

const int MAXN = 1e5 + 5;
const int MAXK = 2e5;

int n, k, cnt[MAXN];

struct Data{
    int x, y, z;
    
    int operator < (const Data &o) const {
        return x != o.x ? (x < o.x) : (y != o.y ? (y < o.y) : (z < o.z));
    }
    
    int operator == (const Data &o) const {
        return x == o.x && y == o.y && z == o.z;
    }
}data[MAXN];

struct Seg{
    struct Node{
        int val;
        Node *ch[2];
        
        Node(int val = 0) : val(val) {
            ch[0] = ch[1] = NULL;
        }
    };
    
    Node *rt;
    
    Seg() {
        rt = NULL;
    }
    
    void Modify(Node *&now, int pos, int val = 1, int nl = 1, int nr = MAXK) {
        if (!now) now = new Node();
        if (nl == nr) {
            now->val += val;
            return;
        }
        int mid = nl + nr >> 1;
        if (pos <= mid) Modify(now->ch[0], pos, val, nl, mid);
        else Modify(now->ch[1], pos, val, mid + 1, nr);
        now->val = (now->ch[0] ? now->ch[0]->val : 0) + (now->ch[1] ? now->ch[1]->val : 0);
    }
    
    int Query(Node *now, int l, int r, int nl = 1, int nr = MAXK) {
        if (!now) return 0;
        if (l == nl && r == nr) return now->val;
        int mid = nl + nr >> 1;
        if (r <= mid) return Query(now->ch[0], l, r, nl, mid);
        else if (l > mid) return Query(now->ch[1], l, r, mid + 1, nr);
        return Query(now->ch[0], l, mid, nl, mid) + Query(now->ch[1], mid + 1, r, mid + 1, nr);
    }
};

Seg tree[MAXK * 4 + 5];

void Modify(int now, int posx, int posy, int val, int nl = 1, int nr = MAXK) {
    tree[now].Modify(tree[now].rt, posy, val);
    if (nl == nr) return;
    int mid = nl + nr >> 1;
    if (posx <= mid) Modify(now << 1, posx, posy, val, nl, mid);
    else Modify(now << 1 | 1, posx, posy, val, mid + 1, nr);
}

int Query(int now, int xl, int xr, int yl, int yr, int nl = 1, int nr = MAXK) {
    if (xl == nl && xr == nr) return tree[now].Query(tree[now].rt, yl, yr);
    int mid = nl + nr >> 1;
    if (xr <= mid) return Query(now << 1, xl, xr, yl, yr, nl, mid);
    else if (nl > mid) return Query(now << 1 | 1, xl, xr, yl, yr, mid + 1, nr);
    return Query(now << 1, xl, mid, yl, yr, nl, mid) + Query(now << 1 | 1, mid + 1, xr, yl, yr, mid + 1, nr);
}

int main() {
    cin >> n >> k;
    for (int i = 1; i <= n; i++) cin >> data[i].x >> data[i].y >> data[i].z;
    sort(data + 1, data + n + 1);
    int sum = 1;
    for (int i = 1; i <= n; i++) {
        if (data[i + 1] == data[i]) {
            sum++;
            continue;
        }
        Modify(1, data[i].y, data[i].z, sum);
        int res = Query(1, 1, data[i].y, 1, data[i].z);
        cnt[res] += sum;
        sum = 1;
    }
    for (int i = 1; i <= n; i++) cout << cnt[i] << endl;
    return 0;
}
```

~~你`Ctrl+C`、`Ctrl+v`交上去，发现TLE70~~

考虑到值域不大，并且线段树常数较大，可以把外层的非动态开点线段树换成树状数组，减小常数，以下为AC代码。

```cpp
// luogu-judger-enable-o2
#include <iostream>
#include <algorithm>

using namespace std;

const int MAXN = 1e5 + 5;
const int MAXK = 2e5;

int n, k, cnt[MAXN];

struct Data{
    int x, y, z;
    
    int operator < (const Data &o) const {
        return x != o.x ? (x < o.x) : (y != o.y ? (y < o.y) : (z < o.z));
    }
    
    int operator == (const Data &o) const {
        return x == o.x && y == o.y && z == o.z;
    }
}data[MAXN];

struct Seg{
    struct Node{
        int val;
        Node *ch[2];
        
        Node(int val = 0) : val(val) {
            ch[0] = ch[1] = NULL;
        }
    };
    
    Node *rt;
    
    Seg() {
        rt = NULL;
    }
    
    void Modify(Node *&now, int pos, int val, int nl, int nr) {
        if (!now) now = new Node();
        if (nl == nr) {
            now->val += val;
            return;
        }
        int mid = nl + nr >> 1;
        if (pos <= mid) Modify(now->ch[0], pos, val, nl, mid);
        else Modify(now->ch[1], pos, val, mid + 1, nr);
        now->val = (now->ch[0] ? now->ch[0]->val : 0) + (now->ch[1] ? now->ch[1]->val : 0);
    }
    
    int Query(Node *now, int l, int r, int nl, int nr) {
        if (!now) return 0;
        if (l == nl && r == nr) return now->val;
        int mid = nl + nr >> 1;
        if (r <= mid) return Query(now->ch[0], l, r, nl, mid);
        else if (l > mid) return Query(now->ch[1], l, r, mid + 1, nr);
        return Query(now->ch[0], l, mid, nl, mid) + Query(now->ch[1], mid + 1, r, mid + 1, nr);
    }
};
/*
Seg tree[MAXK * 4 + 5];

void Modify(int now, int posx, int posy, int val, int nl = 1, int nr = MAXK) {
    tree[now].Modify(tree[now].rt, posy, val);
    if (nl == nr) return;
    int mid = nl + nr >> 1;
    if (posx <= mid) Modify(now << 1, posx, posy, val, nl, mid);
    else Modify(now << 1 | 1, posx, posy, val, mid + 1, nr);
}

int Query(int now, int xl, int xr, int yl, int yr, int nl = 1, int nr = MAXK) {
    if (xl == nl && xr == nr) return tree[now].Query(tree[now].rt, yl, yr);
    int mid = nl + nr >> 1;
    if (xr <= mid) return Query(now << 1, xl, xr, yl, yr, nl, mid);
    else if (nl > mid) return Query(now << 1 | 1, xl, xr, yl, yr, mid + 1, nr);
    return Query(now << 1, xl, mid, yl, yr, nl, mid) + Query(now << 1 | 1, mid + 1, xr, yl, yr, mid + 1, nr);
}
*/

Seg tree[MAXK + 5];

int LB(int x) {
    return x & (-x);
}

void Modify(int posx, int posy, int val) {
    for (int i = posx; i <= k; i += LB(i)) 
        tree[i].Modify(tree[i].rt, posy, val, 1, k);
}

int Query(int x, int y) {
    int ret = 0;
    for (int i = x; i; i -= LB(i)) ret += tree[i].Query(tree[i].rt, 1, y, 1, k);
    return ret;
}

int main() {
    cin >> n >> k;
    for (int i = 1; i <= n; i++) cin >> data[i].x >> data[i].y >> data[i].z;
    sort(data + 1, data + n + 1);
    int sum = 1;
    for (int i = 1; i <= n; i++) {
        if (data[i + 1] == data[i]) {
            sum++;
            continue;
        }
        Modify(data[i].y, data[i].z, sum);
        int res = Query(data[i].y, data[i].z);
        cnt[res] += sum;
        sum = 1;
    }
    for (int i = 1; i <= n; i++) cout << cnt[i] << endl;
    return 0;
}
```

---

## 作者：panyf (赞：33)

提供一篇 bitset 的题解。

bitset 可以用来求解高维偏序问题，记 $m$ 为维数，则时间复杂度为 $O(\dfrac{n^2m}{w})$。

开 $n$ 个 bitset，$b_{i,j}=1$ 表示 $j$ 每一维都不超过 $i$。初始化所有 $b_{i,j}=1$。

先枚举每一维，然后对所有数按这一维排序。

开一个新的 bitset s，按这一维从小到大处理所有数，处理到 $i$ 时 $s_j=1$ 表示当前维 $j$ 不超过 $i$。

$j$ 是单调的，可以用一个指针维护。

每次 `b[i]&=s` 即可。

$100000$ 的 bitset 开不下，要用分组 bitset。

就是将点分为若干组，每组 $B$ 个，每次只求出这 $B$ 个点对应的 bitset，这样只需要开 $B$ 个 bitset。

可能略微卡常。

[AC 提交记录](https://www.luogu.com.cn/record/51314650)

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+3;
int p[3][N],a[3][N],w[N];
bitset<N>b[9999],s;
int main(){
	int*tp,*ta,n,l,r,i,j,k,o;
	for(i=1,scanf("%d%*d",&n);i<=n;++i)for(j=0;j<3;++j)scanf("%d",a[j]+i),p[j][i]=i;
	for(i=0;i<3;++i)sort(p[i]+1,p[i]+n+1,[=](int x,int y){return a[i][x]<a[i][y];});//按每一维排序
	for(l=1;l<=n;l=r+1){//分组bitset，每组9991个
		for(i=l,r=min(l+9991,n);i<=r;++i)b[i-l].set();
		for(i=0;i<3;++i)for(tp=p[i],ta=a[i],s.reset(),j=k=1;j<=n;++j){
			for(o=tp[j];k<=n&&ta[tp[k]]<=ta[o];)s[tp[k++]]=1;
			if(l<=o&&o<=r)b[o-l]&=s;
		}
		for(i=l;i<=r;++i)++w[b[i-l].count()];
	}
	for(i=1;i<=n;++i)printf("%d\n",w[i]);
	return 0;
}
```

---

## 作者：Henry_he (赞：33)

为什么到紫题就很少有pascal题解了呢qwq

那我来写一份比较详细的吧（毕竟是算法模板题）

这道题是三维偏序的模板

1D 我们对第一维直接进行排序就好啦，这样可以保证第一维有序

2D: 这里我采用了cdq分治

cdq分治是一种神奇的分治算法

例如本题，将第二维的区间采取二分，首先递归计算左边内部对自己的贡献，然后计算左边对右边的贡献，最后递归计算右边自己内部贡献

所以重点在如何处理左边对右边的贡献

假设左边区间为[l,mid] 右边区间为[mid+1.r] (推荐使用闭区间，比较好判断边界~~

我们先将两个区间排序，注意要打上序号，这样等会才方便判断这个数是在左区间还是在右区间

然后将数组扫一遍，每当我们遇见左区间的数时统计下来，遇到右区间的数就将前面的左区间的数统计到该数的答案里

因为，左区间的数第一维一定小于右区间，而上述操作便统计了第二维也小的数

当然，到此为止是二维偏序的做法，而本题是三维偏序(见下面

3D 第三维当然也可以再套一层cdq分治，但推荐使用树状数组来维护,因为树状数组常数小，而二维树状数组额外空间过大，会MLE,至于treap，我不会打qwq

接着第二步说，由于第三维的限制，不一定第一维，第二维都满足条件就可以，
所以我们用树状数组来维护统计答案步骤~~~

当我们访问到左区间的点时，我们将他的第三维对应的点加1，来统计左区间中第三维为此数的点，当我们访问到右区间的点时，就查询树状数组，来找到第三维也小的左节点数量

嗯就这样啦~~~

附码

```pascal
var n,k,i:longint;
    x,y,z,f,b,s,p,m:array[0..100000]of longint;
    c:array[1..200000]of longint;
procedure sort(l,r:longint);
var a,b,i,j,c,d:longint;
begin
  a:=x[(l+r)div 2];
  c:=y[(l+r)div 2];
  d:=z[(l+r)div 2];
  i:=l;
  j:=r;
  repeat
    while (x[i]<a)or((x[i]=a)and(y[i]<c))or((x[i]=a)and(y[i]=c)and(z[i]<d)) do
      inc(i);
    while (x[j]>a)or((x[j]=a)and(y[j]>c))or((x[j]=a)and(y[j]=c)and(z[j]>d)) do
      dec(j);
    if i<=j then
    begin
      b:=x[i];
      x[i]:=x[j];
      x[j]:=b;
      b:=y[i];
      y[i]:=y[j];
      y[j]:=b;
      b:=z[i];
      z[i]:=z[j];
      z[j]:=b;
      inc(i);
      dec(j);
    end;
  until i>j;
  if i<r then sort(i,r);
  if l<j then sort(l,j);
end;
procedure sort2(l,r:longint);
var x,y,z,i,j:longint;
begin
  x:=b[(l+r)div 2];
  z:=s[(l+r)div 2];
  i:=l;
  j:=r;
  repeat
    while (b[i]<x)or((b[i]=x)and(s[i]<z)) do
      inc(i);
    while (x<b[j])or((b[j]=x)and(s[j]>z)) do
      dec(j);
    if i<=j then
    begin
      y:=b[i];
      b[i]:=b[j];
      b[j]:=y;
      y:=s[i];
      s[i]:=s[j];
      s[j]:=y;
      inc(i);
      dec(j);
    end;
  until i>j;
  if i<r then sort2(i,r);
  if l<j then sort2(l,j);
end;
procedure ins(x,y:longint);
begin
  while x<=k do
  begin
    inc(c[x],y);
    x:=x+(x and -x);
  end;
end;
function query(x:longint):longint;
begin
  query:=0;
  while x>0 do
  begin
    inc(query,c[x]);
    x:=x-(x and -x);
  end;
end;
procedure cdq(l,r:longint);
var mid,i,j:longint;
begin
  if l>=r then exit;
  mid:=(l+r)div 2;
  cdq(l,mid);//递归左区间的答案
  for i:=l to r do//标记+排序
  begin
    b[i]:=y[i];
    s[i]:=i;
  end;
  sort2(l,r);
  for i:=l to r do
  begin
    if s[i]=n then
    begin
      s[i]:=s[i];
    end;
    if s[i]<=mid then ins(z[s[i]],1);
    //如果是左区间的点，树状数组统计
    if s[i]>mid then f[s[i]]:=f[s[i]]+query(z[s[i]]);
    //右区间的点查询统计
  end;
  for i:=l to r do
    if s[i]<=mid then ins(z[s[i]],-1);
  cdq(mid+1,r);//递归右区间
end;
begin
  readln(n,k);
  for i:=1 to n do
    readln(x[i],y[i],z[i]);
  sort(1,n);//第一维排序啦啦啦
  cdq(1,n);//开始分治
  for i:=n-1 downto 1 do
    if (x[i]=x[i+1])and(y[i]=y[i+1])and(z[i]=z[i+1]) then f[i]:=f[i+1];
  for i:=1 to n do//依题意扫答案
    inc(p[f[i]]);
  for i:=0 to n-1 do
    writeln(p[i]);
end.
```

Ps:三维偏序中，cdq的分治统计右区间内部贡献和左区间对右区间的贡献并不冲突，所以交换顺序也是可以的，这样我们就可以在递归左右区间的时候可以通过归并排序来减少常数（因为我们已经维护了树状数组，所以这点小优化不影响时间复杂度）

---

## 作者：xfrvq (赞：25)

[P3810 【模板】三维偏序（陌上花开）](https://www.luogu.com.cn/problem/P3810)

[更好的阅读体验1](https://www.luogu.com.cn/blog/368107/solution-p3810)

[更好的阅读体验2](https://www.cnblogs.com/zeno6174/p/solution-p3810.html)

### 前置算法

+ 树状数组求逆序对
+ 归并排序求逆序对

解题之前，让我们来看一看弱化版本 $\to$ **二维偏序**

---

#### 题意

给定两个长度为数组 $a_1,a_2,\dots,a_n$，$b_1,b_2,\dots,b_n$ 求对于每一个 $i$，$a_j\le a_i$ 且 $b_j\le b_i$ 的 $j$ 有多少个。

#### 解法1

考虑用结构体把数组存起来，对 $a$ 进行排序，再用一个值域树状数组维护 $b$ 值即可。

还没完。由于可能出现 $a_i=a_j$ 且 $b_i=b_j$ 的情况，所以需要去重。

提到去重，就要在结构体里面多加一个 $x$ 。 $x_i$ 表示与 $a_j=a_i,b_j=b_i$ 的 $j$ 的个数，$x_i$ 初始为 $1$

~~去重毒瘤的要死~~

#### 解法2

还是用结构体存，对 $a$ 进行排序+去重，后面考虑用归并排序来求

回想一下归并排序求逆序对，我们求的是 $a_i$ 作为逆序对 $(j,i)$ 的 $j$ 的总个数。

在这里，$a$ 已经按大小排好了，所以我们只考虑对 $b$ 值求逆序对就行了。

**深刻注意解法2**

---

### 三维偏序

进入正题

**第一步**

和二维偏序一样，先按 $a$ 值排好序，去重

**第二步**

为了简化题目，先考虑简易版本**不存在 $a_i=a_j$ 且 $b_i=b_j$ 且 $c_i=c_j$ 的情况**，标准版本放在第三步。

进入到今天的正题： _CDQ_ 讲解部分。

_CDQ_ 分治，顾名思义，是一种分治。而分治，就需要把 $[l,r]$ 分为 $[l,mid]$ 和 $[mid+1,r]$ 。而对于我们要寻找的一个符合 $a_j\le a_i,b_j\le b_i,c_j\le c_i$ 的点对 $(i,j)$ 必须符合以下三种情况之一：

1. $1\le i,j\le mid\gets$ 这在递归处理左半边时已经处理了
1. $mid\lt i,j\le n\gets$ 这在递归处理右半边时已经处理了
1. $1\le i,j\le n\gets$ **这是我们在递归之后需要处理的点对**

按分治三部曲走，接下来就是合并左右区间并统计答案了了，这里按归并排序求逆序对的思路来。

由于 $a,b$ 值都被我们处理好了，接下来就是毒瘤的 $c$ 值，用树状数组维护。

在合并中，我们分两种情况：
1. 此时的最小值在左，那么我们让树状数组的左边那个数的 $c$ 值位置加一
1. 此时的最小值在右，那么我们让答案加上树状数组从 $1$ 到右边数的 $c$ 值位置的和

如果搞不懂为什么左是加，右是查，建议重新看一看归并排序求逆序对。

**注意**：每一次使用完后树状数组要清空。如果单纯 `memset`，会超时（因为是 $O(n)$ ），清空应该对于每一个被存放在树状数组里的 $c_i$ ，其在树状数组里面的值 $-1$

```cpp
int tmp[maxn]; // 临时存放合并好的值的数组
void CDQ(int l,int r){
	if(l == r) return;　
	int mid = l + r >> 1,p = l,q = mid + 1,len = 0;
	CDQ(l,mid),CDQ(mid + 1,r); // 递归处理
	while(p <= mid && q <= r){ // 合并子区间
		if(a[p].b <= a[q].b) bit.update(a[p].c,1),tmp[++len] = a[p++]; // 选左边，此时更新树状数组
		else a[q].ans += bit.query(a[q].c),tmp[++len] = a[q++]; // 选右边，此时答案要加上值域树状数组的查询 
	}
	while(p <= mid) bit.update(a[p].c,1),tmp[++len] = a[p++]; // 归并左边剩下部分
	while(q <= r) a[q].ans += bit.query(a[q].c),tmp[++len] = a[q++]; // 归并右边剩下部分
	for(int i = l;i <= mid;++i) bit.update(a[i].c,-1); // 清空
	for(int i = 1;i <= len;++i) a[l + i - 1] = tmp[i]; // 把临时数组里的值拷贝到原数组
}
```

**第三步**

由于第二步只能处理不存在相同的情况，接下来讲解如果存在 $a_i=a_j,b_i=b_j,c_i=c_j$ 的 $(i,j)$ 该怎么处理。

注意刚才我们树状数组是这样更新的：`bit.update(a[p].c,1)`

这里的 `1` 实际上就是 $a_s=a_p,b_s=b_p,c_s=c_p$ 的 $s$ 的个数，记为 $x$ ，$x_i$ 我们在去重时求出。

因此代码如下：

```cpp
int tmp[maxn];　
void CDQ(int l,int r){
	if(l == r) return;
	int mid = l + r >> 1,p = l,q = mid + 1,len = 0;
	CDQ(l,mid),CDQ(mid + 1,r);
	while(p <= mid && q <= r){
		if(a[p].b <= a[q].b) bit.update(a[p].c,a[p].x),tmp[++len] = a[p++];
		else a[q].ans += bit.query(a[q].c),tmp[++len] = a[q++]; 
	}
	while(p <= mid) bit.update(a[p].c,a[p].x),tmp[++len] = a[p++];
	while(q <= r) a[q].ans += bit.query(a[q].c),tmp[++len] = a[q++];
	for(int i = l;i <= mid;++i) bit.update(a[i].c,-a[i].x);
	for(int i = 1;i <= len;++i) a[l + i - 1] = tmp[i];
}
```

**第四步**

这时 _CDQ_ 分治已经完成了，我们现在需要统计答案

按照刚才的代码，`a[i].ans` 表示 $a_j\le a_i,b_j\le b_i,c_j\le c_i$ 但不包括 $a_j=a_i,b_j=b_i,c_j=c_i$ 的 $j$ 的个数，而 `a[i].x` 正好表示了 $a_j=a_i,b_j=b_i,c_j=c_i$ 的 $j$ 的个数。于是 `a[i].ans + a[i].x` 就是去重后第 $i$ 个点的答案。

```cpp
for(int i = 1;i <= cnt;++i) res[a[i].ans + a[i].x - 1] += a[i].x; // 注意是 + a[i].x，因为还有与 i 值相同所有 j，其总个数是 a[i].x
for(int i = 0;i < n;++i) printf("%d\n",res[i]);
```
---

[$\color{#52C41A}\texttt{AC CODE}$](https://www.luogu.com.cn/record/51748575)

```cpp
#include<stdio.h>　　
#include<algorithm>
const int maxn = 114514;
int n,k;
struct BIT{
	int t[maxn << 1];
	int lowbit(int i){return i & -i;}
	void update(int i,int x){for(;i <= k;i += lowbit(i)) t[i] += x;} 
	int query(int i){int ans = 0;for(;i;i -= lowbit(i)) ans += t[i];return ans;}
} bit; // 树状数组
struct number{
	int a,b,c,ans,x;
	bool operator<(const number& y) const{return a != y.a ? a < y.a : b != y.b ? b < y.b : c < y.c;}
} a[maxn],tmp[maxn]; // 数的结构体
int res[maxn];
void CDQ(int l,int r){
	if(l == r) return;
	int mid = l + r >> 1,p = l,q = mid + 1,len = 0;
	CDQ(l,mid),CDQ(mid + 1,r);
	while(p <= mid && q <= r){
		if(a[p].b <= a[q].b) bit.update(a[p].c,a[p].x),tmp[++len] = a[p++];
		else a[q].ans += bit.query(a[q].c),tmp[++len] = a[q++]; 
	}
	while(p <= mid) bit.update(a[p].c,a[p].x),tmp[++len] = a[p++];
	while(q <= r) a[q].ans += bit.query(a[q].c),tmp[++len] = a[q++];
	for(int i = l;i <= mid;++i) bit.update(a[i].c,-a[i].x);
	for(int i = 1;i <= len;++i) a[l + i - 1] = tmp[i];
}
int main(){
	scanf("%d%d",&n,&k);
	for(int i = 1;i <= n;++i) scanf("%d%d%d",&a[i].a,&a[i].b,&a[i].c),a[i].x = 1,a[i].ans = 0;
	std::sort(a + 1,a + n + 1); // 排序
	int cnt = 1;
	for(int i = 2;i <= n;++i)
		if(a[i].a == a[cnt].a && a[i].b == a[cnt].b && a[i].c == a[cnt].c) ++a[cnt].x; // 如果遇到与 i 一样的，x 值就要自加一
		else a[++cnt] = a[i];
	CDQ(1,cnt); // 注意不是 CDQ(1,n)
	for(int i = 1;i <= cnt;++i) res[a[i].ans + a[i].x - 1] += a[i].x;
	for(int i = 0;i < n;++i) printf("%d\n",res[i]);
	return 0;
}　　
```

---

## 作者：Mingoal (赞：24)

安利一下[博客](https://blog.csdn.net/xumingyang0/article/details/80772375)

[题目](https://www.luogu.org/problemnew/show/P3810)
#题解：
这题我看没有k-d树的题解，我就来一发
三维k-d树O(n^(5/3))应该是过不了的，我T掉了5个点
我们可以把z排序，x和y用k-d树维护，每次计算当前位置前面有多少个x和y符合条件（均小于当前位置的x和y）
但是，这实际上是错误的，当一些z相等时，要查询的范围可能在当前位置之后，于是，我们可以建两棵k-d树，分别维护，然后就大功告成了，时间复杂度O(n^(3/2))
#标程：
```cpp
//T维护在当前位置前，有多少个x和y符合条件
//K维护所有z值相等的点中，有多少个x和y符合条件
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=100002;
int n,m,ans,D,i,f[N],k,j,t;
inline char gc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
#define gc getchar
inline int read(){
    int x=0,fl=1;char ch=gc();
    for (;ch<48||ch>57;ch=gc())if(ch=='-')fl=-1;
    for (;48<=ch&&ch<=57;ch=gc())x=(x<<3)+(x<<1)+(ch^48);
    return x*fl;
}
inline void wri(int a){if(a>=10)wri(a/10);putchar(a%10|48);}
inline void wln(int a){if(a<0)a=-a,putchar('-');wri(a);puts("");}
inline void Min(int &x,int y){if (y<x) x=y;}
inline void Max(int &x,int y){if (y>x) x=y;}
struct kk{
    int x,y,z;
}a[N];
struct P{
    int l,r,d[2],mn[2],mx[2],v,sum;
    int &operator[](int x){
        return d[x];
    }
    friend bool operator==(P a,P b){
        return a.d[0]==b.d[0] && a.d[1]==b.d[1];
    }
    friend bool operator<(P a,P b){
        return a[D]<b[D];
    }
}p[N];
bool in(int x1,int y1,int x2,int y2,int X1,int Y1,int X2,int Y2){
    return x1<=X1 && X2<=x2 && y1<=Y1 && Y2<=y2;
}
bool out(int x1,int y1,int x2,int y2,int X1,int Y1,int X2,int Y2){
    return X2<x1 || X1>x2 || Y2<y1 || Y1>y2;
}
struct node{
    P now,t[N];
    int rt,cnt;
    void update(int k){
        int l=t[k].l,r=t[k].r;
        for (int i=0;i<2;i++){
            t[k].mn[i]=t[k].mx[i]=t[k][i];
            if (l) Min(t[k].mn[i],t[l].mn[i]),Max(t[k].mx[i],t[l].mx[i]);
            if (r) Min(t[k].mn[i],t[r].mn[i]),Max(t[k].mx[i],t[r].mx[i]);
        }
        t[k].sum=t[k].v+t[l].sum+t[r].sum;
    }
    void ins(int &k,bool D){
        if (!k){
            k=++cnt;
            t[k][0]=t[k].mn[0]=t[k].mx[0]=now[0];
            t[k][1]=t[k].mn[1]=t[k].mx[1]=now[1];
        }
        if (now==t[k]){
            t[k].v+=now.v;t[k].sum+=now.v;
            return;
        }
        if (now[D]<t[k][D]) ins(t[k].l,D^1);
        else ins(t[k].r,D^1);
        update(k);
    }
    int query(int k,int x1,int y1,int x2,int y2){
        if (!k) return 0;
        int tmp=0;
        if (in(x1,y1,x2,y2,t[k].mn[0],t[k].mn[1],t[k].mx[0],t[k].mx[1])) return t[k].sum;
        if (out(x1,y1,x2,y2,t[k].mn[0],t[k].mn[1],t[k].mx[0],t[k].mx[1])) return 0;
        if (in(x1,y1,x2,y2,t[k][0],t[k][1],t[k][0],t[k][1])) tmp+=t[k].v;
        tmp+=query(t[k].l,x1,y1,x2,y2)+query(t[k].r,x1,y1,x2,y2);
        return tmp;
    }
    int build(int l,int r,bool f){
        if (l>r) return 0;
        int mid=l+r>>1;
        D=f;nth_element(p+l,p+mid,p+r+1);
        t[mid]=p[mid];
        t[mid].l=build(l,mid-1,f^1);
        t[mid].r=build(mid+1,r,f^1);
        update(mid);
        return mid;
    }
}T,K;
bool cmp(kk a,kk b){
    return a.z<b.z;
}
int main(){
    n=read();k=read();m=10000;
    for (i=1;i<=n;i++) a[i].x=read(),a[i].y=read(),a[i].z=read();
    sort(a+1,a+n+1,cmp);
    for (i=1;i<=n;i++){
        k=i;
        while (k<n && a[k].z==a[k+1].z) k++;
        for (j=i;j<=k;j++) p[j-i+1][0]=a[j].x,p[j-i+1][1]=a[j].y,p[j-i+1].v=p[j-i+1].sum=1;
        K.rt=K.build(1,k-i+1,0);
        for (j=i;j<=k;j++){
            ans=T.query(T.rt,1,1,a[j].x,a[j].y)+K.query(K.rt,1,1,a[j].x,a[j].y);
            f[ans]++;//把当前位置也算进去了，所以f的输出范围是[1,n]
        }
        for (j=i;j<=k;j++){
            T.now[0]=a[j].x,T.now[1]=a[j].y,T.now.v=T.now.sum=1,T.ins(T.rt,0);
            if (T.cnt==m){
                for (t=1;t<=T.cnt;t++) p[t]=T.t[t];
                T.rt=T.build(1,T.cnt,0);m+=10000;
            }
        }
        i=k;
    }
    for (i=1;i<=n;i++) wln(f[i]);
}
```

---

## 作者：NATURAL6 (赞：18)

### [题目传送门](https://www.luogu.com.cn/problem/P3810)

### 前言

这是一篇分块题解。

## 题意

有 $n$ 个元素，每个元素有三个属性，求对于每个元素三个属性都小于等于它的元素个数。

这个题意不好处理，我们可以把它转化一下，先按 $a$ 属性为第一关键字，属性 $b$ 为第二关键字，属性 $c$ 最末排序，问题就转化成了：

有 $n$ 个元素，每个元素有两个属性，求对于每个元素它的前缀中两个元素都小于等于它的元素的个数。

## 做法

考虑对于序列分块，每处理完一个块，就重构一个数组。

对于每个元素，块内的暴力比较，时间复杂度 $O(\sqrt{n})$ 。

对于前面的元素，直接从处理出的数组中读出答案，时间复杂度 $O(1)$ 。

考虑怎么处理出一个这样的数组。

将一个元素的两个属性对应到一个二维平面上，可以看出一个元素对后面的元素做贡献，必须要它处于后面元素的右下方。

于是我们可以把每个数加到对应的点上，然后做一遍二维前缀和。

但是这样时间复杂度是 $O(n^2)$ 的，明显会超时，考虑优化。

因为这些前面的元素在这次重构后只用对后一个块中的元素做贡献，所以它们的属性大小不重要，只有与后面这些元素属性的相对大小有意义。

于是把前面的元素属性按与后面这些元素属性的相对大小经行离散化，再做上面的操作，时间复杂度是 $O(\max(n,B^2))$ 的，在 $B$ 取 $\sqrt{n}$ 时最优。

总共重构 $\sqrt{n}$ 次，总时间复杂度 $O(n\sqrt{n})$ 。

### 实现细节

对于重复的元素，他们内部会重复贡献，不好处理，于是把它们删成一个元素，公用这个元素的答案即可。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int qread()
{
	register int a=0;register char ch=getchar();
	while(ch>'9'||ch<'0'){ch=getchar();}
	while(ch>='0'&&ch<='9'){(a*=10)+=(ch^48);ch=getchar();}
	return a;
}
int n,k,f[100010],p,tot,s[100010],ans[100010],d[100010];
int cl,c[100010],st[400],ed[400],mp[500][500],cb[200010],cc[200010];
struct poit
{
	int a,b,c,id,cnt;
}a[100010];
inline bool cmp(poit x,poit y){return x.a==y.a?(x.b==y.b?x.c<y.c:x.b<y.b):x.a<y.a;}
inline void re(register int h)
{
	memset(mp,0,sizeof(mp));
	int totb=0;
	for(register int i=st[h];i<=ed[h];++i)s[++totb]=a[i].b;
	sort(s+1,s+1+totb);
	totb=unique(s+1,s+1+totb)-s-1;
	p=1;
	for(register int i=1;i<=k;++i)
	{
		if(i>s[p]&&p<=totb)++p;
		cb[i]=p;
	}
	int totc=0;
	for(register int i=st[h];i<=ed[h];++i)s[++totc]=a[i].c;
	sort(s+1,s+1+totc);
	totc=unique(s+1,s+1+totc)-s-1;
	p=1;
	for(register int i=1;i<=k;++i)
	{
		if(i>s[p]&&p<=totc)++p;
		cc[i]=p;
	}
	for(register int i=st[h]-1;i;--i)mp[cb[a[i].b]][cc[a[i].c]]+=a[i].cnt;
	for(register int i=1;i<=totb;++i)
	{
		for(register int j=1;j<=totc;++j)
		{
			mp[i][j]+=mp[i-1][j]+mp[i][j-1]-mp[i-1][j-1];
		}
	}
	return ;
}
int main()
{
	n=qread();
	k=qread();
	for(register int i=1;i<=n;++i)
	{
		a[i].a=qread();
		a[i].b=qread();
		a[i].c=qread();
		a[i].id=i;
		a[i].cnt=1;
		f[i]=i;
	}
	sort(a+1,a+1+n,cmp);
	p=0;
	for(register int i=1;i<=n;++i)
	{
		if(a[i].a==a[p].a&&a[i].b==a[p].b&&a[i].c==a[p].c)
		{
			++tot;
			f[a[i].id]=a[p].id;
			a[i].a=k+1;
			++a[p].cnt;
		}
		else p=i;
	}
	sort(a+1,a+1+n,cmp);
	n-=tot;
	cl=sqrt(n)+1;
	for(register int i=1;i<=n;++i)
	{
		c[i]=(i-1)/cl+1,ed[c[i]]=i;
		ans[a[i].id]+=a[i].cnt-1;
	}
	for(register int i=n;i;--i)st[c[i]]=i;
	for(register int i=1;i<=c[n];++i)
	{
		re(i);
		for(register int j=st[i];j<=ed[i];++j)
		{
			for(register int k=st[i];k<j;++k)
			{
				if(a[k].a<=a[j].a&&a[k].b<=a[j].b&&a[k].c<=a[j].c)ans[a[j].id]+=a[k].cnt;
			}
			ans[a[j].id]+=mp[cb[a[j].b]][cc[a[j].c]];
		}
	}
	for(register int i=1;i<=n+tot;++i)++d[ans[f[i]]];
	for(register int i=0;i<n+tot;++i)printf("%d\n",d[i]);
	return 0;
}
```
## 问题延伸

这种方法可以拓展到高维，只用将二维前缀和变为高维前缀和，调整块长即可。

### 时间复杂度分析：

设块长为 $B$，则总共重构 $\dfrac{n}{B}$ 次，每次需要做大小为 $B$ 的 $k$ 维前缀和，以及对 $n$ 个数的离散。

对每个元素的询问，需要 $O(B)$ 的比较和 $O(1)$ 的查询。

总共时间复杂度为 $O(nB+\dfrac{n}{B}(B^k+n))$。

对于最优块长，$O(nB)$ 忽略不计，取 $B^k=n$ 得到 $B=\sqrt[k]{n}$。

那么最终时间复杂度约为 $O(n^\frac{2k-1}{k})$。


---

## 作者：_rqy (赞：17)

这题咋做啊？

emm楼下有树状数组套treap。

诶呀我只会树状数组怎么办啊？

显然我们可以排序去掉一维。

二维树状数组开不下怎么办啊？

开`map`又多一个log啊？


---

手写哈希表大法好（别告诉我`unordered_map`，反正考场上你用不了）！

手写一个哈希表，然后二位树状数组美滋滋啊~

不过要注意一个地方：有完全相同的点的时候后面的可能会对前面的造成影响。

```cpp
#include <algorithm>
#include <cctype>
#include <cstdio>
#include <cstring>

typedef long long LL;

inline int readInt() {
  int ans = 0, c, f = 1;
  while (!isdigit(c = getchar()))
    if (c == '-') f *= -1;
  do ans = ans * 10 + c - '0';
  while (isdigit(c = getchar()));
  return ans * f;
}

const int N = 100050;
const int M = 39999983;

struct{
  LL key[M];
  int val[M];

  int operator()(int i, int j, int) {
    LL x = (LL)i * N + j;
    int t = x % M;
    while (key[t] != 0 && key[t] != x)
      if (++t == M) t = 0;
    return val[t];
  }

  int& operator()(int i, int j) {
    LL x = (LL)i * N + j;
    int t = x % M;
    while (key[t] != 0 && key[t] != x)
      if (++t == M) t = 0;
    key[t] = x;
    return val[t];
  }
} H;

struct Point{
  int a, b, c;

  bool operator<(const Point &t) const {
    if (a != t.a) return a < t.a;
    if (b != t.b) return b < t.b;
    return c < t.c;
  }

  bool operator==(const Point &t) const {
    return a == t.a && b == t.b && c == t.c;
  }
} P[N];

int n, na, nb, nc, A[N], B[N], C[N];
int ans[N];

void Add(int x, int y) {
  for (int i = x; i <= nb; i += i & -i)
    for (int j = y; j <= nc; j += j & -j)
      ++H(i, j);
}

int Query(int x, int y) {
  int ans = 0;
  for (int i = x; i > 0; i -= i & -i)
    for (int j = y; j > 0; j -= j & -j)
      ans += H(i, j, 0);
  return ans;
}

int main() {
  n = readInt();
  readInt();
  for (int i = 0; i < n; ++i) {
    A[i] = P[i].a = readInt();
    B[i] = P[i].b = readInt();
    C[i] = P[i].c = readInt();
  }
  std::sort(A, A + n);
  std::sort(B, B + n);
  std::sort(C, C + n);
  na = std::unique(A, A + n) - A;
  nb = std::unique(B, B + n) - B;
  nc = std::unique(C, C + n) - C;
  for (int i = 0; i < n; ++i) {
    P[i].a = std::lower_bound(A, A + na, P[i].a) - A + 1;
    P[i].b = std::lower_bound(B, B + nb, P[i].b) - B + 1;
    P[i].c = std::lower_bound(C, C + nc, P[i].c) - C + 1;
  }
  std::sort(P, P + n);
  for (int i = 0, j = 0, l = 0; i < n; ++i) {
    while (j < i || (j < n && P[j] == P[i])) ++j;
    if (i > 0 && P[i - 1] < P[i])
      l = Query(P[i].b, P[i].c) + j - i - 1;
    ++ans[l];
    Add(P[i].b, P[i].c);
  }

  for (int i = 0; i < n; ++i)
    printf("%d\n", ans[i]);
  return 0;
}
```

---

## 作者：lao_wang (赞：16)

~~整体二分是世界上实用的算法。~~

不知道整体二分的可以看看[这个](https://blog.csdn.net/Yale_dd/article/details/138281672)

## 使用算法

整体二分、排序、树状数组，没了。

## 思考

在我们所知道的降维方法里，我们会发现整体二分可以跟着树状数组一起用（其实也可以跟排序一起）做二维偏序，而众所周知树状数组又可以跟排序一起用做二维偏序。

那么我们就想如何将他们两个融为一体。

## 二维偏序

给定数组 $a_i$、$b_i$，求 $a_j \le a_i$ 且 $b_j \le b_i$ 的个数。

### 整体二分与树状数组

我所定义的整体二分的操作数组的结构体

```cpp
struct node{
    int x1 , x2 , i , opt ;//x1为a[i] x2为b[i] i是求答案时数组顺序编号 opt为操作：1为原序列 2为查询答案
};
```

#### 初始化

1. 将所有的 $a_i$、$b_i$ 存入操作数组，$opt$ 均为 1。

2. 将所有的 $a_i$、$b_i$ 再次存入操作数组，$opt$ 均为 2。

#### 操作

1. 当 $opt=1$，如果 $mid \geq x2$ 那么将树状数组数组 $tr_{x1}$ 加 1。

2. 当 $opt=2$，就是完全按照树套树用整体二分做的做法求排名（因为有了树状数组提供的没它大的且 $b_i$ 没他大的 $a_i$ 个数，问题就被转化成了求 $b_i$ 的排名）。

##### 代码

```cpp
void solve(int l,int r,int L,int R){
	if(L>R) return ;
	if(l==r) return ;
	int mid=(l+r)>>1 , tot1=0 , tot2=0 ;
	for(int i=L;i<=R;i++){
		if(a[i].opt==1){
			if(mid>=a[i].x2) change(a[i].x1,a[i].k) , q1[++tot1] = a[i] ;
			else q2[++tot2] = a[i] ;
		}else if(a[i].opt==2){
			if(mid>a[i].x2) q1[++tot1] = a[i] ;
			else{
				ans[a[i].i] += ask(a[i].x1) ;
				q2[++tot2] = a[i] ;
			}
		}
	}
	for(int i=1;i<=tot1;i++){
		a[i+L-1] = q1[i] ;
		if(q1[i].opt==1) change(q1[i].x1,-q1[i].k) ;
	}
	for(int i=1;i<=tot2;i++) a[i+L+tot1-1] = q2[i] ;
	solve(l,mid,L,L+tot1-1) ;
	solve(mid+1,r,L+tot1,R) ;
}
```

### 整体二分与排序

~~其实这玩意有点多此一举~~

这个就更简单了，按从小到大（从大到小其实也可以但是不好操作）排序之后因为当前 $i$ 能与之相匹配的 $j$ 一定再他前面所以初始化的使用后是将排序后的数组没添加一个操作 1 就添加一个操作 2。

## 三维偏序

按照整体二分与排序我们会发现，排序降一维后，初始化会发生改变，但是不影响整体二分与树状数组的操作，所以只需要将排序后的数组，每一次操作 1，就添加一次操作 2。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 212345
#define lowbit(x) ((x)&(-x))
#define inf 2147483647
using namespace std ;
int n , K , tr[N] , cnt=0 , ans[N] , real_ans[N] , q , num[N] ;
void change(int x,int k){
	while(x<=K){
		tr[x] += k ;
		x += lowbit(x) ;
	}
}
int ask(int x){
	int ans=0 ;
	while(x){
		ans += tr[x] ;
		x -= lowbit(x) ;
	}
	return ans ;
}
struct user8341006{ //CS2启动
	int a , b , c ;
	bool operator==(const user8341006 &num){
		return this->a==num.a&&this->b==num.b&&this->c==num.c ;
	}
}f[N];
bool cmp(user8341006 a,user8341006 b){return a.a==b.a?(a.b==b.b?a.c<b.c:a.b<b.b):a.a<b.a ;}
struct node{
	int x1 , x2 , opt , i , k ;
}a[N],q1[N],q2[N];
void solve(int l,int r,int L,int R){
	if(L>R) return ;
	if(l==r) return ;
	int mid=(l+r)>>1 , tot1=0 , tot2=0 ;
	for(int i=L;i<=R;i++){
		if(a[i].opt==1){
			if(mid>=a[i].x2) change(a[i].x1,a[i].k) , q1[++tot1] = a[i] ;
			else q2[++tot2] = a[i] ;
		}else if(a[i].opt==2){
			if(mid>a[i].x1) q1[++tot1] = a[i] ;
			else{
				ans[a[i].i] += ask(a[i].x2) ;
				q2[++tot2] = a[i] ;
			}
		}
	}
	for(int i=1;i<=tot1;i++){
		a[i+L-1] = q1[i] ;
		if(q1[i].opt==1) change(q1[i].x1,-q1[i].k) ;
	}
	for(int i=1;i<=tot2;i++) a[i+L+tot1-1] = q2[i] ;
	solve(l,mid,L,L+tot1-1) ;
	solve(mid+1,r,L+tot1,R) ;
}
signed main(){
	cin >> n >> K ;
	for(int i=1;i<=n;i++) scanf("%lld%lld%lld",&f[i].a,&f[i].b,&f[i].c) ;
	sort(f+1,f+1+n,cmp) ;
	for(int i=1;i<=n;i++){
		int number=1 ;
		a[++cnt].opt = 2 ;
		a[cnt].x1 = f[i].c , a[cnt].i = ++q , a[cnt].x2 = f[i].b ;
		a[++cnt].opt = 1 ;
		a[cnt].x1 = f[i].b , a[cnt].x2 = f[i].c ;
		while(f[i]==f[i+1]) number++ , i++ ; //没想到吧跟 cdq 差不多也需要去重
		a[cnt].k = number ;
		num[q] = number ;
		ans[a[cnt-1].i] += number-1 ;
	}
	solve(1,inf,1,cnt) ;
	for(int i=1;i<=q;i++) real_ans[ans[i]] += num[i] ;
	for(int i=0;i<n;i++) printf("%lld\n",real_ans[i]) ;
	return 0 ;
}//maybe 我没挖坑
```

---

## 作者：MCAdam (赞：16)

[题目](https://www.luogu.com.cn/problem/P3810)

名字好好听\(^o^)/~

前置芝士：[P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)

注：$[flag]$类似于一个$bool$型变量，如果$flag$为真，那么$[flag]=1$，反之则为$0$。

题意：给定$n$个三元组$(a_i,b_i,c_i)$，设$f(i)=\sum_{j\neq i}[a_j\leq a_i,b_j\leq b_i,c_j\leq c_i]$，$ans[d]=\sum_{i=1}^{n}[f(i)=d]$，输出$ans[d](d\in [0,n))$。

这是一个三维偏序的题目（题目告诉我们了），考虑怎么让它变得简单点呢？我们把三元组按照 $a_i$ 从小到大排序， $a_i$ 就保证是递增的了，那就变成了二维偏序啦！这个时候，只需要一个~~树套树~~神奇的CDQ分治。

CDQ分治的主要思想大概就是，将一个问题分成同样大的两个，递归处理两个规模较小的问题，然后要把两个规模小的问题合并时，计算前一半对后一半的贡献。

举个例子，在用归并排序计算逆序对时，当前的序列 $[l,r]$，$[l,mid]$ 和 $[mid+1,r]$ 分别有序了，然后我们用两个指针 $p$ 和 $q$ 在两个序列中扫描，如果左半部分的 $val[p]$ 与右半部分的 $val[q]$ ，有 $val[p]>val[q]$，那么 $[p,mid]$ 对 $q$ 都会有逆序对的贡献，答案就累加上 $mid-p+1$。

回到这道题，我们要计算 $b_j\leq b_i$ 且 $c_j\leq c_i$ 的数量（ $a$ 已经有序了），我们将 $b$ 进行归并排序。

对于左半部分 $b[p]<b[q]$，我们把 $p$ 位置的这个三元组放入一个用来合并的数组里，那么后面放入这个数组里的三元组的$b$肯定比当前这个 $b[p]$ 大，也就当前这个三元组有可能对后面的三元组做出贡献。我们对 $c$ 建立树状数组，在 $c[p]$ 这个位置单点修改。

当 $b[p]>b[q]$ 时，要把$q$位置的这个三元组放入这个数组内，那么之前放入这个数组里的三元组的 $b$ 肯定比当前这个 $b[q]$ 小，那就在树状数组里查询 $c[q]$ 位置的前缀和，更新答案。

![](https://cdn.luogu.com.cn/upload/image_hosting/05e82iz4.png)

大概思路就是这样，但是有很多细节要注意的：

- 三元组有可能存在完全相同的。

因为CDQ过程中只会计算左边对右边的贡献，如果有相同的话，不管按什么顺序计算都会有遗漏。考虑把这些相同的合并起来，记录一个$size$，代表这种三元组有多少个。除了CDQ计算的贡献外，还有它们自身相互之间的贡献$size-1$。

正是因为要把相同的合并，所以排序的时候，不能只按照$a$排，而是要按照$a,b,c$为第一、第二、第三关键字排，这样才能保证相同的三元组会挨在一起。

- CDQ过程中存在$b[p]=b[q]$的情况

因为要计算的是可以取等号的，如果把这种情况归到大于号那边，也就是在树状数组中查询，那么答案就会有遗漏。所以应该归到小于号里，也就是更新树状数组，对$b[q]$仍然能做出贡献。

- 结构体内变量和外部变量的关系

没有这个问题的请自行忽略。。

三元组我是用一个结构体来表示的。因为这个结构体数组在排序过程中位置在不断变化，所以结构体中应该要再存一个$pos$，这个$pos$应该为去重后，三元组所在的位置。还有$size$数组，我的写法存的也是三元组去重后的位置所对应的三元组的数量（也就是这个$size$不会因为排序而变化）。这个问题与个人的写法有关，还是看代码吧。

- 树状数组每次CDQ要清空

注意不能用$memset$，会超时，而是倒着做回去，就和点分治一样

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N=1e5+10;
int n,m;
int size[N],ans[N],cnt[N],t[2*N];					  //ans存的是每个位置的答案，cnt存的是每种答案有多少个，t是树状数组 
struct node
{
	int a,b,c;
	int pos;										  //pos记录的是去重后的位置 
	bool operator != (const node &x) const
	{
		return (a!=x.a||b!=x.b||c!=x.c);
	}
}tmp[N],v[N],w[N];									  //tmp是输入的三元组，v是去重并用来排序的，w辅助排序 
inline int lowbit(int x)
{
	return x&(-x);
}
inline void change(int x,int c)
{
	for(int i=x;i<=m;i+=lowbit(i))
		t[i]+=c;
}
inline int query(int x)
{
	int res=0;
	for(int i=x;i>=1;i-=lowbit(i))
		res+=t[i];
	return res;
}													  //树状数组单点修改、查询前缀和 
inline void CDQ(int l,int r)
{
	if(l==r) return;
	int mid=(l+r)/2,p=l,q=mid+1;
	CDQ(l,mid),CDQ(mid+1,r);						  //递归解决子问题 
	for(int i=l;i<=r;i++)
	{												  //在树状数组中更新，并放入辅助排序的数组里			
		if((p<=mid&&v[p].b<=v[q].b)||q>r) change(v[p].c,size[v[p].pos]),w[i]=v[p++];
		else ans[v[q].pos]+=query(v[q].c),w[i]=v[q++];//更新答案 
	}
	for(int i=l;i<=mid;i++)
		change(v[i].c,-size[v[i].pos]);				  //清空树状数组 
	for(int i=l;i<=r;i++)
		v[i]=w[i];
}
inline bool cmp(node x,node y)						  //3关键字排序 
{
	if(x.a==y.a)
	{
		if(x.b==y.b) return x.c<y.c;
		else return x.b<y.b;
	}
	else return x.a<y.a;
}
int main()
{
	int tn;
	scanf("%d%d",&tn,&m);
	for(int i=1;i<=tn;i++)
		scanf("%d%d%d",&tmp[i].a,&tmp[i].b,&tmp[i].c);
	sort(tmp+1,tmp+tn+1,cmp);
	for(int i=1;i<=tn;i++)							  //排序后去重 
	{
		if(tmp[i]!=tmp[i-1]) v[++n]=tmp[i],v[n].pos=n;//记录pos 
		size[n]++;									  //记录size 
	}
	CDQ(1,n);
	for(int i=1;i<=n;i++)							  //同一种三元组内还有贡献size-1，这些三元组的答案都相同 
		cnt[ans[v[i].pos]+size[v[i].pos]-1]+=size[v[i].pos];
	for(int i=0;i<tn;i++)
		printf("%d\n",cnt[i]);
	return 0;
}
```
谢谢~~

---

## 作者：myee (赞：13)

### 引言

写本题解时，题解区有 $35$ 篇题解，仅俩 KDT 做法，其他人几乎都是一通 cdq 玄学（？）。

陌上花开是 KDT 求三维偏序的经典模板呀。

KDT 是个好东西，在解决高维问题时，都可以考虑；[这题](https://www.luogu.com.cn/problem/P7711)就可以用 KDT 骗分。

请先确保在学会 KDT 基操（build，find）后再阅读本题解。

### 思路

先写一个 3DT 上去。

复杂度是 $O(n^{\frac53})$ 的，毫无疑问[会 T](https://www.luogu.com.cn/record/53027731)。

咋办？

观察到各个三维点的编号不影响答案，而影响一个点 $f$ 的只有三维坐标都不比其大的点，故考虑先按第一维排序，动态插点进一个 2DT 中去（各点只有第二、三维），同期查询 $f$。

要注意的是，**第一维坐标相同时，应把之同时插入，再一并查询，以免出现像 $(1,1,1),(1,1,1),(1,1,1),\dots,(1,1,1)$ 这样的数据时挂掉**。此外，**也不应忘记在答案中删去各点自身**。

### 问题来了

动态插点咋实现？

前俩题解好像都是写了带替罪羊树式重构的 KDT，然而这又臭又长，一点不香。

我们考虑使用其他方法来搞。

由于只有插入没有删除，不用打 KDT 惰性删除标记。

但实际上插入本身也并不方便，于是采取[yk链分治](https://www.luogu.com.cn/blog/myee/yk-algorithm)技术，即二进制拆分法。

如果使用原始yk链分治算法，对每一块建一个 KDT，那么我们归并操作只能推倒重构（因为几乎没有明显单调性），在插入操作处复杂度是 $O(n\log^2n)$ 的（因为单次重构 KDT 复杂度是 $O(n\log n)$ 的），但常数太大会挂掉。

考虑：我们把原始的 $\log\operatorname{lowbit}n$ 次块归并操作，改为**推倒末 $\log\operatorname{lowbit}n$ 块并最后将删去元素与新插入元素重构一个大块**。

这样，每个点插入时只重构一次，于是就不会挂了，总插入复杂度是 $O(n\log^2n)$ 的。

查询呢？**同时维护 $O(\log n)$ 个 KDT，难道不 T**?

其实由于每块大小不会超过前一块的一半，单次查询复杂度是 $O(\sqrt n+\sqrt{\frac n2}+\sqrt{\frac n4}+\dots+\sqrt{\frac n{2^w}})=O(\sqrt n)$ 的！

因此，总时间复杂度是 $O(n\sqrt n+n\log^2n)$ 的，（好像）可以通过此题！

[不过](https://www.luogu.com.cn/record/53030941)，被卡常了QAQ，几十毫秒死活过不去。

于是加一车常数优化，待夜深人静之时，交它几发，相信你一定会A的QAQ。（来自一个第 $299$ 次才 [AC](https://www.luogu.com.cn/record/53218123) 的人）

### Code

快读快写啥的删了一车，代码更简洁，不一定保证能过，加油卡常吧（

```cpp
#include <algorithm>
#include <stdio.h>
typedef long long llt;
typedef unsigned uint;typedef unsigned long long ullt;
typedef bool bol;typedef char chr;typedef void voi;
typedef double dbl;
template<typename T>bol _max(T&a,T b){return(a<b)?a=b,true:false;}
template<typename T>bol _min(T&a,T b){return(b<a)?a=b,true:false;}
const uint k=2;
class kdpoint{public:uint D[k];uint&operator[](uint n){return D[n];}};
uint d;
bol operator<(const kdpoint&a,const kdpoint&b){return a.D[d]<b.D[d];}
class kdT
{
    public:
        typedef kdpoint point;
        class node;
        voi bzr(){if(rot!=NULL)delete rot;rot=NULL;}
        voi build(point*P,uint len){rot=new node,rot->build(P,P+len);}
        node*rot;
        class node
        {
            public:
                point p;node*ls,*rs;
                uint Max[k],Min[k];
                ullt sum;
                voi bzr(){ls=rs=NULL;}
                voi build(point*l,point*r,uint t=0)
                {
                    bzr();
                    register point*mid=(r-l)/2+l;
                    d=t;
                    std::nth_element(l,mid,r);
                    p=*mid,sum=1;
                    for(uint i=0;i<k;i++)Max[i]=Min[i]=p[i];
                    if(l<mid)
                    {
                        ls=new node,ls->build(l,mid,(t+1)%k);
                        for(uint i=0;i<k;i++)_min(Min[i],ls->Min[i]),_max(Max[i],ls->Max[i]);
                        sum+=ls->sum;
                    }
                    if(mid+1<r)
                    {
                        rs=new node,rs->build(mid+1,r,(t+1)%k);
                        for(uint i=0;i<k;i++)_min(Min[i],rs->Min[i]),_max(Max[i],rs->Max[i]);
                        sum+=rs->sum;
                    }
                }
                ~node(){if(ls!=NULL)delete ls;if(rs!=NULL)delete rs;}
        };
};
kdT T[30];uint tp=0,siz=0;
std::pair<uint,kdpoint>P[100005];
kdpoint K[100005];
voi insert()//yk链分治 O(n\log^2n)
{
	*K=P[siz++].second;
	uint f=siz&-siz,u=1;
	while(f>>=1)//merge过程：推倒
	{
		u<<=1;
		for(uint i=u>>1;i<u;i++)K[i]=P[siz-i-1].second;
		T[--tp].bzr();
	}
	T[tp].bzr(),T[tp++].build(K,u);//merge过程：重构
}
ullt find(kdT::node*p,uint&x,uint&y)
{
    if(p==NULL||p->Min[0]>x||p->Min[1]>y)return 0;
    if(p->Max[0]<=x&&p->Max[1]<=y)return p->sum;
    ullt ans=0;
    if(p->p[0]<=x&&p->p[1]<=y)ans=1;
    ans+=find(p->ls,x,y)+find(p->rs,x,y);
    return ans;
}
inline chr nc() //光速快读
{
    static chr buf[1000010],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000010,stdin),p1==p2)?EOF:*p1++;
}
inline ullt read()
{
    register ullt ans=0;register chr c;do c=nc();while(c>'9'||c<'0');
    do ans=c-'0'+ans*10,c=nc();while(c>='0'&&c<='9');return ans;
}
uint Time[100005];
int main()
{
	uint n=read(),m;m=read();
	for(uint i=0;i<n;i++)P[i].first=read(),P[i].second[0]=read(),P[i].second[1]=read();
	std::sort(P,P+n);
	for(uint i=0,j=0;i<n;)
    {
		for(;j<n&&P[j].first==P[i].first;j++)insert();
		while(i<j)
		{
			uint w=-1;
			for(uint k=0;k<tp;k++)w+=find(T[k].rot,P[i].second[0],P[i].second[1]);
			Time[w]++,i++;
		}
	}
    for(uint i=0;i<n;i++)printf("%u\n",Time[i]);
	return 0;
}
```


---

## 作者：GKxx (赞：12)

### 树状数组套平衡树

一开始看到题的时候我就在想，二维偏序可以用树状数组套splay很好地解决（除了像[Mokia](https://www.luogu.org/problemnew/show/P4390)这种时空卡得很变态的题），那么三维怎么办呢。。。

后来我突然意识到，本题并不是回答乱序的m个区间询问。我们可以将输入按照a排序，那么就变成了要回答n个**前缀**询问。

这样的话就非常好办了：先按照a为关键字排序，然后对于元素i，将所有满足a[j]<=a[i]的元素j都插入数据结构。这个数据结构这样描述：树状数组套splay（你套treap也行），树状数组上维护b值，平衡树上维护c值。

其实也不用每次都把所有a[j]<=a[i]的j插入，我们可以在前一次基础上插入所有a[j]==a[i]的j（注意同一个元素不要重复插入）。

那么对于每个i进行的查询可以描述如下：在所有已经插入数据结构的元素中，在所有b[j]<=b[i]的元素j中，有多少个元素满足c[j]<=c[i]。这其实就是二维偏序了。

最后我们求出所有的f[i]之后，只要这样就行了：

```cpp
for (int i = 1; i <= n; ++i) ++g[f[i]];
for (int i = 1; i <= n; ++i) printf("%d\n", g[i]);
```

然后简单地提一提树套树怎么写（前面看到有人说树套树难写）。

其实我们普通的平衡树就是一个根节点root，而现在树状数组套平衡树的话就相当于 树状数组上的每个节点都挂了一棵平衡树，因此树状数组的每个节点上都有一个树根，所以我们开个数组
```cpp
int root[maxn];
```

注意 这里的maxn并不是本题的n的最大值，由于树状数组维护b值，所以应该是k的最大值。但是我懒得区分，所以maxn直接定义成了2e5+100（反正也差不多）

然后就是几乎模板一样的操作：（反正我写了好几个题，下面两个函数几乎一字未改）

```cpp
inline void insert(int x, int y) {
	for (; x <= k; x += x & -x)
    	insertSplay(root[x], y);
}
inline int query(int x, int y) {
	int ans = 0;
    for (; x; x -= x & -x)
    	ans += querySplay(root[x], y);
    return ans;
}
```

接下来所有的事情都交给splay做就好辣！还有需要注意的就是，树套树空间复杂度是O(nlogn)，所以splay对应的空间要开大一点，我开的是maxn * 30。

下面贴上完整代码。

```cpp
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>

template <typename T> inline void read(T& t) {
    int f = 0, c = getchar(); t = 0;
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) t = t * 10 + c - 48, c = getchar();
    if (f) t = -t;
}
template <typename T, typename... Args>
inline void read(T& t, Args&... args) {
    read(t); read(args...);
}

#define rep(I, A, B) for (int I = (A); I <= (B); ++I)
#define rrep(I, A, B) for (int I = (A); I >= (B); --I)

const int maxn = 2e5 + 100;
int fa[maxn * 30], size[maxn * 30], value[maxn * 30], ch[maxn * 30][2], freq[maxn * 30];
int root[maxn];
int n, k, tot;

inline int iden(int x) {
    if (ch[fa[x]][0] == x) return 0;
    if (ch[fa[x]][1] == x) return 1;
    return -1;
}
inline void update(int x) {
    size[x] = freq[x];
    if (ch[x][0]) size[x] += size[ch[x][0]];
    if (ch[x][1]) size[x] += size[ch[x][1]];
}
inline int newNode(int v = 0) {
    value[++tot] = v;
    size[tot] = freq[tot] = 1;
    fa[tot] = ch[tot][0] = ch[tot][1] = 0;
    return tot;
}
inline void rotate(int x) {
    if (!x) return;
    int d = iden(x), y = fa[x];
    if (~iden(y)) ch[fa[y]][iden(y)] = x;
    fa[x] = fa[y];
    ch[y][d] = ch[x][d ^ 1];
    if (ch[x][d ^ 1]) fa[ch[x][d ^ 1]] = y;
    ch[x][d ^ 1] = y;
    fa[y] = x;
    update(y);
    update(x);
}
inline void splay(int x, int &k) {
    if (x == k) return;
    int p = fa[k];
    while (fa[x] != p) {
        int y = fa[x];
        if (fa[y] != p) rotate(iden(y) ^ iden(x) ? x : y);
        rotate(x);
    }
    k = x;
}
inline void insertSplay(int &rt, int val) {
    if (!rt) {
        rt = newNode(val);
        return;
    }
    int x = rt;
    while (0207) {
        ++size[x];
        if (val == value[x]) {
            ++freq[x];
            return;
        }
        int d = val > value[x];
        if (ch[x][d]) x = ch[x][d];
        else {
            ch[x][d] = newNode(val);
            fa[ch[x][d]] = x;
            splay(ch[x][d], rt);
            return;
        }
    }
}
int querySplay(int x, int val) {
    if (!x) return 0;
    if (val == value[x])
        return ch[x][0] ? size[ch[x][0]] + freq[x] : freq[x];
    else if (val < value[x])
        return querySplay(ch[x][0], val);
    else if (ch[x][0])
        return size[ch[x][0]] + freq[x] + querySplay(ch[x][1], val);
    else
        return freq[x] + querySplay(ch[x][1], val);
}

inline void insertBit(int x, int y) {
    for (; x <= k; x += x & -x)
        insertSplay(root[x], y);
}
inline int queryBit(int x, int y) {
    int ans = 0;
    for (; x; x -= x & -x)
        ans += querySplay(root[x], y);
    return ans;
}

struct Element {
    int id, a, b, c;
};
Element ele[maxn];
int f[maxn], g[maxn];
bool vis[maxn];
inline bool aLess(const Element& lhs, const Element& rhs) {
    return lhs.a < rhs.a;
}

int main() {
    read(n, k);
    rep(i, 1, n) read(ele[i].a, ele[i].b, ele[i].c);
    std::sort(ele + 1, ele + n + 1, aLess);
    rep(i, 1, n) {
        if (!vis[i])
            for (int j = i; ele[j].a == ele[i].a && j <= n; ++j) {
                insertBit(ele[j].b, ele[j].c);
                vis[j] = 1;
            }
        f[i] = queryBit(ele[i].b, ele[i].c);
    }
    rep(i, 1, n) ++g[f[i]];
    rep(i, 1, n) printf("%d\n", g[i]);
    return 0;
}
```

---

## 作者：逗逼领主 (赞：12)

树状数组套动态开点权值线段树:

先按第一维a排序,查询前首先将a值相等的向量全部插入.

插入时用树状数组维护b值数量的前缀和,用权值线段树维护c值数量的前缀和(会带修改主席树的人应该很容易看懂,不会的话...建议先去学学qwq)

啊对,树状数组是按b的权值来维护的,权值线段树是按c的值来维护的(有点迷emmm...应该不会有不知道权值线段树/树状数组是什么的吧~~让你去学!!!~~)

查询时由于已经将a值小于等于当前向量a值的向量全插入了,所以只用考虑b值和c值的限制就行了,所以我们要查询的就是b值小于等于当前向量的所有已插入向量中,c值小于当前向量的向量的数量(是很绕口窝也没办法呀语文不好qwq)

~~会树状数组套权值线段树的已经去码呆码勒~~,我们用树状数组维护了b值的前缀,所以在查询的时候,只用把b值小于等于当前b值的那一段前缀揪粗来,在它们的权值线段树上查c值小于等于当前c值的向量的总量就行辣~

撒花!!!

不懂看代码,自认为比较清~~丑~~晰~~陋~~qwq

```cpp

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int n,m;
int ls[10000100],rs[10000100],val[10000100],tot;
int rt[200200];
int b[500500],totn;
struct data{
	int a,b,c;
}que[100100];
bool cmp(data a,data b)
{return a.a<b.a;}
int ans[100100];
int lb(int x){return x&(-x);}
int ed;
int qx[550],tx;
int query(int l,int r,int k)
{//查询函数
	if(l==r)
	{
		int sum=0;
		for(int i=1;i<=tx;++i)sum+=val[qx[i]];
		return sum;
	}
	int mid=(l+r)/2;
	if(mid>=k)
	{
		for(int i=1;i<=tx;++i)qx[i]=ls[qx[i]];
		return query(l,mid,k);
	}
	else
	{
		int sum=0;
		for(int i=1;i<=tx;++i)sum+=val[ls[qx[i]]],qx[i]=rs[qx[i]];
		return sum+query(mid+1,r,k);
	}
}
int calc(int num,int num2)
{
	tx=0;
	int pos=lower_bound(b+1,b+totn+1,num)-b;
	for(int x=pos;x;x-=lb(x))
		qx[++tx]=rt[x];//把一段前缀的权值线段树的根节点预处理出来
	int vp=lower_bound(b+1,b+totn+1,num2)-b;
	return query(1,totn,vp);
}
int ins(int pr,int l,int r,int v)
{//修改函数
	int rt=pr;
	if(!rt)rt=++tot;
	ls[rt]=ls[pr],rs[rt]=rs[pr],val[rt]=val[pr]+1;
	if(l==r)return rt;
	int mid=(l+r)/2;
	if(mid>=v)ls[rt]=ins(ls[pr],l,mid,v);
	else rs[rt]=ins(rs[pr],mid+1,r,v);
	return rt;
}
void add(int num,int num2)
{
	num=lower_bound(b+1,b+totn+1,num)-b;
	num2=lower_bound(b+1,b+totn+1,num2)-b;
	for(int x=num;x<=totn;x+=lb(x))
		rt[x]=ins(rt[x],1,totn,num2);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
	{
		scanf("%d%d%d",&que[i].a,&que[i].b,&que[i].c);
		b[++totn]=que[i].a;
		b[++totn]=que[i].b;
		b[++totn]=que[i].c;
	}
	sort(b+1,b+totn+1);//
	totn=unique(b+1,b+totn+1)-b-1;//
    //其实上面两行离散化没很大必要,说了k<=200000了
    //但我总觉得这样可以优化空间qwq
    //虽然好像并没有,还拖慢了时间...TAT
	sort(que+1,que+n+1,cmp);//离线排序
	ed=1;
	for(int i=1;i<=n;)
	{
		while(que[ed+1].a==que[i].a)ed++;
        //先把a相同的都插入
		for(int j=i;j<=ed;++j)
			add(que[j].b,que[j].c);
		while(i<=ed)
		{
			ans[calc(que[i].b,que[i].c)]++;
            //再查询
			i++;
		}
	}
	for(int i=1;i<=n;++i)
		printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：Taduro (赞：12)

这题是有k-d tree做法的，不过很技巧，好像还有另一篇k-d tree题解，但他建了两棵树，我也没大看懂。

三维的k-d tree是一定过不去的，得先把三维变成二维。

首先要按第三维排序，按顺序一次性加入第三维相同的点，这样就自动省去了第三维。

一开始我写的是定期重构，参数是0.7时最快，最大的点也跑了2s。

这个$n\sqrt{n}$的优美做法被卡到了60分，让我十分愤懑。于是我拿出了以前没写过的另一种插入做法，先把所有的点去重一下都加进去，先建好树，把每个点所控制的矩形也先处理好，打上被删除的标记，插入时找的树上对应的点把点权+1，其他的都不改。这样的话最大的点就是1s了。

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#define re register
using namespace std;
#ifdef ONLINE_JUDGE
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){if(A==B){B=(A=ss)+fread(ss,1,1<<17,stdin);if(A==B)return EOF;}return*A++;}
template<class T>inline void read(T&x){
	static char c;static int y;
	for(c=gc(),x=0,y=1;c<48||57<c;c=gc())if(c=='-')y=-1;
	for(;48<=c&&c<=57;c=gc())x=((x+(x<<2))<<1)+(c^'0');
	x*=y;
}
#else
void read(int&x){scanf("%d",&x);}
#endif
const double fac=0.70;
struct point{
	int d[2],z;
}a[100001],b[100001];
struct kdtree{
	int ch[2],sz,x[2],d[2],y[2],lv;
}t[100001];
int f[100001],n,tot,u,root,m;
inline bool cmp1(point x,point y){return x.z<y.z;}
inline bool cmp2(point x,point y){return x.d[u]<y.d[u];}
inline bool cmp3(point x,point y){
	if (x.d[0]!=y.d[0]) return x.d[0]<y.d[0];
	return x.d[1]<y.d[1];
}
inline void pushup(int rt){
	int l=t[rt].ch[0],r=t[rt].ch[1];
	t[rt].sz=t[l].sz+t[r].sz+t[rt].lv;
	if (l){
		t[rt].x[0]=min(t[rt].x[0],t[l].x[0]);
		t[rt].y[0]=min(t[rt].y[0],t[l].y[0]);
		t[rt].x[1]=max(t[rt].x[1],t[l].x[1]);
		t[rt].y[1]=max(t[rt].y[1],t[l].y[1]);
	}
	if (r){
		t[rt].x[0]=min(t[rt].x[0],t[r].x[0]);
		t[rt].y[0]=min(t[rt].y[0],t[r].y[0]);
		t[rt].x[1]=max(t[rt].x[1],t[r].x[1]);
		t[rt].y[1]=max(t[rt].y[1],t[r].y[1]);
	}
}
inline void up(int rt){
	int l=t[rt].ch[0],r=t[rt].ch[1];
	t[rt].sz=t[l].sz+t[r].sz+t[rt].lv;
}
int build(int d,int l,int r){
	if (l>r) return 0; u=d;
	int mid=(l+r)>>1,rt=++tot;
	nth_element(b+l,b+mid,b+r+1,cmp2);
	t[rt].x[0]=t[rt].x[1]=t[rt].d[0]=b[mid].d[0];
	t[rt].y[0]=t[rt].y[1]=t[rt].d[1]=b[mid].d[1];
	t[rt].ch[0]=build(d^1,l,mid-1);
	t[rt].ch[1]=build(d^1,mid+1,r);
	pushup(rt); return rt;
}
void ins(int rt,point x){
	if (t[rt].d[0]==x.d[0]&&t[rt].d[1]==x.d[1]){
		t[rt].lv++; t[rt].sz++; return;
	}
	int l=t[rt].ch[0],r=t[rt].ch[1];
	if (t[l].x[0]<=x.d[0]&&x.d[0]<=t[l].x[1]&&
		t[l].y[0]<=x.d[1]&&x.d[1]<=t[l].y[1])
		ins(l,x);
	if (t[r].x[0]<=x.d[0]&&x.d[0]<=t[r].x[1]&&
		t[r].y[0]<=x.d[1]&&x.d[1]<=t[r].y[1])
		ins(r,x);
	up(rt);
	return;
}
int query(int rt,point x){
	if (!rt||!t[rt].sz) return 0;
	if (t[rt].x[0]>x.d[0]||t[rt].y[0]>x.d[1])
		return 0;
	if (t[rt].x[1]<=x.d[0]&&t[rt].y[1]<=x.d[1])
		return t[rt].sz;
	int num=query(t[rt].ch[0],x)+query(t[rt].ch[1],x);
	if (t[rt].d[0]<=x.d[0]&&t[rt].d[1]<=x.d[1]) num+=t[rt].lv;
	return num;
}
void debug(int rt){
	if (t[rt].ch[0]) debug(t[rt].ch[0]);
	printf("num:%d dx:%d dy:%d ch0:%d ch1:%d sz:%d lv:%d\n",
	rt,t[rt].d[0],t[rt].d[1],t[rt].ch[0],t[rt].ch[1],t[rt].sz,t[rt].lv);
	if (t[rt].ch[1]) debug(t[rt].ch[1]);
}
int main(){
//	freopen("0a.in","r",stdin);
//	freopen("0a.out","w",stdout);
	int k;
	read(n),read(k);
	for (re int i=1; i<=n; i++)
		read(a[i].d[0]),read(a[i].d[1]),read(a[i].z);
	sort(a+1,a+n+1,cmp3);
	for (int i=1; i<=n; i++)
		if (a[i].d[0]!=a[i-1].d[0]||a[i].d[1]!=a[i-1].d[1])
			b[++m]=a[i];
	root=build(0,1,m);
	sort(a+1,a+n+1,cmp1);
	for (re int p=1; p<=n; p++){
		k=p;
		while (a[k+1].z==a[k].z) k++;
		for (re int i=p; i<=k; i++) ins(root,a[i]);
		for (re int i=p; i<=k; i++) f[query(root,a[i])]++;
		p=k;
//		debug(root); puts("");
	}
	for (re int i=1; i<=n; i++) printf("%d\n",f[i]);
	return 0;
}
```



---

## 作者：XYloto (赞：12)

## 楼下代码真是非常优美，补充一个树状数组套treap的大概思路。


- 我们要做的是查询有多少个比f(i)“小”的元素。

这时想到用treap？它可以做到查询一个节点的排名（有多少比它小的点）。

再想想发现只维护rank是不够的，因为此时有三维。


- 树状数组可以log维护前缀和，

而在我们按cmp排完序之后，保证了j = 1 ~ i中, aj < ai且bj < bi。满足条件的j只能在i的前缀中。


- 于是可以把treap套入树状数组？

每一个树状数组区间维护一个treap，查询当前区间满足条件的数量，

累加就能求得满足条件的j的数量。

最后答案维护的是满足数量为j的i有多少个……再进行转换即可。


---

## 作者：mohei0 (赞：10)

# 三维偏序

这题有很多大佬用了cdq分治，然而蒟蒻并不会，所以就说一种奇怪的数据结构搞法吧。

我用的是树状数组套动态开点线段树。

## 部分分

首先我们考虑 $k\le 1000$ 的情况（虽然题目里没有说这个部分分）。

根据树状数组的二维偏序，我们可以想到用一个二维树状数组来解决三维偏序。

在第一维维护 $b$ 元素的树状数组的基础上再开一维维护 $c$ 元素，我们求 $f(i)$ 就相当于求一个二维前缀和了。

如图当当前的 $b=2,c=3$ 时， $f$ 就等于红色部分的元素个数。

![a.jpg](https://i.loli.net/2019/03/09/5c837f97bac94.jpg)

这个算法的复杂度主要不是被卡在时间上，而是在空间上，因为二维树状数组的操作时间是 $O(n\log^2n)$ ，而空间是 $O(k^2)$ 。

## 满分

我们发现二维树状数组的元素很多值都是0，但树状数组没办法动态开点节省空间。于是我们就想起了zkw的一句话：

![b.jpg](https://i.loli.net/2019/03/09/5c8380ff4d956.jpg)

我们为什么不能把第二维的树状数组换成线段树呢？

因为线段树可以动态开点节省很大一部分空间，所以空间问题解决了。

线段树的常数可能有点大，但卡卡常也就过了嘛。

这里给一个小优化：在查询线段树时如果子树的元素个数为0，就不往下查找。

所以正解就出来了。

代码：

```cpp
#include<bits/stdc++.h>

using namespace std;

const int MAXN=200007;

struct node {
	int sum,ch[2],l,r;
	node(){sum=ch[0]=ch[1]=l=r=0;}
}tr[15000000+7];
int cnt=0;
inline int newnode(int l,int r)
{
	tr[++cnt].l=l;
	tr[cnt].r=r;
	return cnt;
}
inline void putdown(int N)
{
	if(tr[N].l==tr[N].r) return;
	if(!tr[N].ch[0]) tr[N].ch[0]=newnode(tr[N].l,(tr[N].l+tr[N].r)>>1);
	if(!tr[N].ch[1]) tr[N].ch[1]=newnode(((tr[N].l+tr[N].r)>>1)+1,tr[N].r);
}
void add(register int X,register int now)
{
	if(X>tr[now].r||X<tr[now].l) return;
	putdown(now);
	tr[now].sum++;
	if(tr[now].l==X&&tr[now].r==X) return;
	add(X,tr[now].ch[0]);
	add(X,tr[now].ch[1]);
}
int find(register int X,register int now)
{
	if(X<tr[now].l||!tr[now].sum) return 0;
	putdown(now);
	if(X>=tr[now].r) return tr[now].sum;
	return find(X,tr[now].ch[0])+find(X,tr[now].ch[1]);
}

int sum[MAXN+7];
inline void Add(int X,int c)
{
	for(register int i=X;i<=MAXN;i+=i&-i)
		add(c,sum[i]);
}
int re;
inline int Find(int X,int c)
{
	re=0;
	for(register int i=X;i>0;i-=i&-i)
		re+=find(c,sum[i]);
	return re;
}

int n,k;
int f[MAXN+7],ans[MAXN+7];
struct ele {
	int a,b,c;
}a[MAXN+7];
bool cmp(const ele &A,const ele &B)
{
	return A.a==B.a?(A.b==B.b?A.c<B.c:A.b<B.b):A.a<B.a;
}

int main()
{
	ios::sync_with_stdio(false);
	cin>>n>>k;
	for(register int i=1;i<=MAXN;i++)
		sum[i]=newnode(1,MAXN);
	for(int i=1;i<=n;i++){cin>>a[i].a>>a[i].b>>a[i].c;a[i].b++;}

	sort(a+1,a+1+n,cmp);
	
	for(register int i=1,j;i<=n;i=j)
	{
		Add(a[i].b,a[i].c);
		for(j=i+1;a[j].a==a[j-1].a;j++) Add(a[j].b,a[j].c);
		f[i]=Find(a[i].b,a[i].c);
		for(j=i+1;a[j].a==a[j-1].a;j++) f[j]=Find(a[j].b,a[j].c);
	}

	for(register int i=1;i<=n;i++)
		ans[f[i]-1]++;
	for(register int i=0;i<n;i++)
		cout<<ans[i]<<'\n';
}
```

---

## 作者：Sol1 (赞：10)

因为~~CDQ分治之毒瘤超乎你想象~~，所以本题解将详细讲解CDQ分治（当然还有这道题的特殊处理辣qwq

首先，我们来把这个问题弱化一下：二维偏序。

对于每一个$(a_i,b_i)$，求所有满足$1 \leq j \leq n$且$a_j \leq a_i$且$b_j \leq b_i$的$(a_j,b_j)$的数量。

我们可以首先对所有$(a_i,b_i)$按照$a_i$从小到大排序。

然后，对$(a_i,b_i)$按照$b_i$进行归并排序（注意这里要排两次序）。对区间$[l,r]$排序时，设$mid=\frac{l+r}{2}$，假设区间$[l,mid]$和区间$[mid+1,r]$都已经以$b_i$为关键字排好序了。此时，有$\forall l \leq i \leq mid,mid<j\leq r:a_i \leq a_j$。

显然，这里的问题就可以被化解为归并排序求“顺序对”。

这个方法可以扩展至三维偏序：

对于每一个三元组$(a_i,b_i,c_i)$，先以$a_i$为关键字排序，再以$b_i$为关键字归并排序。归并之后，$b$就是有序的了，所以只需要考虑$c$对答案的影响。

具体来说，在归并过程中：

如果$b_i \leq b_j$，则在树状数组的$c_i$位置上$+1$。

否则，求出$c_i$的前缀和，并计入答案。

因为所有$(mid,r]$中的元素不会进入树状数组，而答案只在$(mid,r]$中统计，所以$a$不会影响到答案。

$b$因为是排序的优先级，所以它不会影响到答案。

所以只有$c$会影响到答案，而树状数组统计的答案保证了只可能有$c_i\leq c$会影响到答案。

所以这个算法是正确的。

注意：清空树状数组时不能简单地memset，要只删除刚刚加进树状数组的元素。因为如果直接memset可能影响到其他递归进程，导致结果错误。

最后，用另外一个数组统计每一种答案出现的次数就可以了。

这道题还需要考虑一个特殊情况，就是有$i \neq j$且$a_i=a_j,b_i=b_j,c_i=c_j$。

所以，对于每一种三元组，只保留$1$个。同时，要统计出每一种三元组的实际数量$cnt_i$。

在修改树状数组时，要对位置$c_i$加上$cnt_i$。

在统计出现次数时，位置$ans_i$要$+cnt_i$而不是$+1$。

具体的，来看代码吧~

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <map>
using namespace std;

struct Node {
    int a, b, c, idx;
    //a,b,c是三维空间上的点,idx是准确下标，方便统计答案。
    //比较函数要写的稍微麻烦一点。
    bool operator < (const Node& nd) const {
        if (a != nd.a) {
            return a < nd.a;
        }
        if (c != nd.c) {
            return c < nd.c;
        }
        return b < nd.b;
    }
};
int n, m, c[200005], ans[200005], _ans[200005], cnt[200005], tmp_;
Node nd[100005], tmp[100005];
//这个是用来去重的，我用pair<pair<int,int>,int>来存三元组
map <pair <pair <int, int>, int>, int> mp;

//树状数组部分
inline int LowBit(int x) {
    return x & -x;
}

inline void Update(int i, int x) {
    for (int j = i;j <= m;j += LowBit(j)) {
        c[j] += x;
    }
}

inline int Query(int i) {
    int ans = 0;
    for (int j = i;j >= 1;j -= LowBit(j)) {
        ans += c[j];
    }
    return ans;
}

void Read() {
    scanf("%d%d", &n, &m);
    tmp_ = n;
    for (int i = 1;i <= n;i++) {
        scanf("%d%d%d", &nd[i].a, &nd[i].b, &nd[i].c);
        nd[i].idx = i;
        mp[make_pair(make_pair(nd[i].a, nd[i].b), nd[i].c)]++;
        //有重复
        if (mp[make_pair(make_pair(nd[i].a, nd[i].b), nd[i].c)] > 1) {
            i--;
            n--;
        }
    }
}

void Prefix() {
    for (int i = 1;i <= n;i++) {
    //处理一下答案，完全相同的两个球员都要+1
        cnt[i] = mp[make_pair(make_pair(nd[i].a, nd[i].b), nd[i].c)];
        ans[i] += cnt[i] - 1;
    }
    //按照a排序
    sort(nd + 1, nd + n + 1);
}

//核心，归并排序
void MergeSort(int l, int r) {
    if (l == r) {
        return;
    }
    int mid = l + r >> 1;
    MergeSort(l, mid);
    MergeSort(mid + 1, r);
    int p1 = l, p2 = mid + 1, k = l;
    while (p1 <= mid && p2 <= r) {
        if (nd[p1].b <= nd[p2].b) {
        	//更新树状数组
            Update(nd[p1].c, cnt[nd[p1].idx]);
            tmp[k++] = nd[p1++];
        } else {
        	//统计答案
            ans[nd[p2].idx] += Query(nd[p2].c);
            tmp[k++] = nd[p2++];
        }
    }
    //归并剩余部分
    while (p1 <= mid) {
        Update(nd[p1].c, cnt[nd[p1].idx]);
        tmp[k++] = nd[p1++];
    }
    while (p2 <= r) {
        ans[nd[p2].idx] += Query(nd[p2].c);
        tmp[k++] = nd[p2++];
    }
    //清空树状数组
    for (int i = l;i <= mid;i++) {
        Update(nd[i].c, -cnt[nd[i].idx]);
    }
    for (int i = l;i <= r;i++) {
        //printf("%d %d %d %d\n", tmp[i].a, tmp[i].b, tmp[i].c, ans[tmp[i].idx]);
        nd[i] = tmp[i];
    }
}

void Solve() {
    for (int i = 1;i <= n;i++) {
        _ans[ans[i]] += cnt[i];//统计最终答案
    }
    for (int i = 1;i <= tmp_;i++) {
        printf("%d\n", _ans[i - 1]);
    }
}

int main() {
    Read();
    Prefix();
    MergeSort(1, n);
    Solve();
    return 0;
}
```
顺便求dalao私信给我4维偏序解法qwq

---

## 作者：人殇物已非 (赞：6)

**这是一篇（~~只针对基础性质的~~）详细的cdq分治解析**。

（本题解解析了一下**所有题解都直接“显然”的去重问题**。在这里迷惑的可以看看）

cdq分治最基础的显然不是三维偏序，而是二维偏序（一维(~~偏~~)排序如果不排序我们闲的慌去cdq也可以），但是二维偏序可以拿排序+树状数组水过去，然后归并排序求逆序对已经成了套路，所以如果要真正掌握cdq分治的思想，三维偏序这个题是一个很好的敲门砖，可以说，会做这道题了，已经会了cdq分治了。（当然不代表你就能秒杀所有的cdq分治题。。。）

### cdq分治的本质是什么？

是一种对问题进行分治时，维护出前后两个区间的影响从而在合并时，得到正确的解。

和普通分治的区别就是，我们还需要考虑$(l,mid)$ $(mid+1,r)$的影响了。

### 通常怎么使用呢？

- cdq分治可以干的事情很多，首先，cdq可以代替一层数据结构。

- 然后，cdq可以用来嵌套，实现满足一个不断在之前约束条件下，产生新约束条件对答案的贡献（前提这个问题可以用分治解决）。因为cdq分治不能影响整体的性质，所以在一个性质下再去满足新的性质是完全可以的。

- 所谓归并排序，就是cdq在区间分治时，分治然后比较大小。

### cdq分治在具体问题的应用。

~~怎么大部分都是偏序问题呀。。~~

#### 三维偏序：

对于一个三维偏序，我们可以对第一维排序+第二维cdq+树状数组。

显然，我们还可以对第一维排序+第二维cdq+第三维cdq。

###### 注解：第二维cdq是按第二维分治时正序排列，第三维cdq是按第三维求顺序对。

**能用树状数组解决一维的时候咱们就用吧嚯嚯嚯。**

毕竟人家常数小还好打还便于理解。~~懒人专用~~

### $code:$
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=100010;
struct node{
    int a,b,c,id;
}p[maxn],tmp[maxn];
int n,k;
int c[maxn*2],ans[maxn],sum[maxn];
#define lowbit(x) (x&(-x))
void add(int i,int x){
    for(;i<=k;i+=lowbit(i)) c[i]+=x;
}
void clear(int i){
    for(;i<=k;i+=lowbit(i)) c[i]=0;
}
int s(int i){int ret=0;
    for(;i;i-=lowbit(i)) ret+=c[i];
    return ret;
}
inline int read(){
    int a=0,b=1;char c=getchar();
    while(!isdigit(c)){if(c=='-')b=-1;c=getchar();}
    while(isdigit(c)){a=a*10+(c^'0');c=getchar();}
    return a*b;
}
inline bool cmp1(node &x,node &y){
    return x.a<y.a || (x.a==y.a && x.b<y.b) || (x.a==y.a && x.b==y.b && x.c<y.c);
}
void cdq(int l,int r){
    if(l==r) return ;
    int mid=(l+r)>>1;
    cdq(l,mid),cdq(mid+1,r);
    int i=l,j=mid+1,k1=l;
    while(i<=mid && j<=r){//按b归并排序 
        if(p[i].b<=p[j].b){
            add(p[i].c,sum[p[i].id]),tmp[k1++]=p[i++];
        }
        else{
            ans[p[j].id]+=s(p[j].c),tmp[k1++]=p[j++];//在此之前的所有的b都bi<bj，故统计它们的答案。 
        }
    }
    while(i<=mid) tmp[k1++]=p[i++];
    while(j<=r) ans[p[j].id]+=s(p[j].c),tmp[k1++]=p[j++]; 
    for(int i=l;i<=r;i++){
        p[i]=tmp[i];clear(p[i].c);
    }
/*    memset(c,0,sizeof(c)); */
}
int d[maxn];
int main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++){
        p[i].a=read(),p[i].b=read(),p[i].c=read(),p[i].id=i;
    }
    int j=0;	
    sort(p+1,p+1+n,cmp1);
    for(int i=1;i<=n;++i){
        if(p[i].a!=p[j].a||p[i].b!=p[j].b||p[i].c!=p[j].c) p[++j]=p[i];
        sum[j]++;
    }
    for(int i=1;i<=j;i++) p[i].id=i;
    cdq(1,j);
    for(int i=1;i<=j;i++) d[ans[p[i].id]+sum[p[i].id]-1]+=sum[p[i].id];
    for(int i=0;i<n;i++) printf("%d\n",d[i]);
    return 0;
} 
```
对此问题，我们还需要考虑一下重复的元素。

由于题目要求的是$<=$，故此排序一维度之后，满足答案的编号定在它之前。（如果要求是$<$的显然不能把在它之前$==$的也算进去）

**但是！** 就算是$<=$，在三维度都完全相等之后，显然依然只能找到自己之前的答案，而对比自己编号后的答案，统计不上了。

因此，我们需要先去重，然后把这些重复的元素记一次重复次数，统一处理。然后对于每个元素，它们的答案显然相同。

#### 先把这题搞完，以后再把其他例题慢慢加进来qwq。

---

## 作者：Isonan (赞：6)

原题传送门[>Here<](https://www.luogu.org/problemnew/show/P3810)

心血来潮学习一下CDQ分治。

首先将三元组排序，这样可以保证能对$f(i)$产生贡献的$j$都在$i$前面；

然后进行归并，可以保证每个能对$f(i)$产生贡献的$j$都会出现在$i$的左边，且只有一次；

每次归并时用$b$做为关键字，这样又保证了每个$a_j\le a_i$且$b_j\le b_i$的$j$都会在归并时在$i$前面被处理；

最后把左边三元组以$c$为键值存到树状数组里，更新右边的三元组的$f$值。

这道题还有一些细节需要注意：

1.三元组可能会有重复，需要先去重再计算；

2.树状数组要手动清空，不能用memset，否则会超时。

代码：

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

struct point{
	int a,b,c,id;
	point(){
		a=b=c=id=0;
	}
}num[100001],tem[100001];
bool cmp(point lhs,point rhs){
	if(lhs.a!=rhs.a)return lhs.a<rhs.a;
	if(lhs.b!=rhs.b)return lhs.b<rhs.b;
	return lhs.c<rhs.c;
}
int c[200001],ans[100001],fin[100001],size[100001];
int n,k;
void update(int ind,int num){for(;ind<=k;ind+=ind&-ind)c[ind]+=num;}
long long query(int ind){
	long long tot=0;
	for(;ind;ind-=ind&-ind)tot+=c[ind];
	return tot;
}
void cdq(int l,int r){
	if(l==r)return;
	int mid=(l+r)/2;
	cdq(l,mid);cdq(mid+1,r);
	int i=l,j=mid+1,ind=l;
	while(i<=mid&&j<=r){
		if(num[i].b<=num[j].b)update(num[i].c,size[num[i].id]),tem[ind++]=num[i++];
		else ans[num[j].id]+=query(num[j].c),tem[ind++]=num[j++];
	}
	while(j<=r)ans[num[j].id]+=query(num[j].c),tem[ind++]=num[j++];
	for(int e=l;e<i;e++)update(num[e].c,-size[num[e].id]);
	while(i<=mid)tem[ind++]=num[i++];
	for(int i=l;i<=r;i++)num[i]=tem[i];
}
int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)scanf("%d%d%d",&num[i].a,&num[i].b,&num[i].c);
	std::sort(num+1,num+n+1,cmp);
	int ind=0;
	for(int i=1;i<=n;i++){
		if(num[i].a!=num[i-1].a||num[i].b!=num[i-1].b||num[i].c!=num[i-1].c)tem[++ind]=num[i];
		size[ind]++;
	}
	for(int i=1;i<=ind;i++)num[i]=tem[i],num[i].id=i;
	cdq(1,ind);
	for(int i=1;i<=ind;i++)fin[ans[num[i].id]+size[num[i].id]-1]+=size[num[i].id];
	for(int i=0;i<n;i++)printf("%d\n",fin[i]);
}
```

---

## 作者：龙神哈迪斯 (赞：6)

###题解

想必大家都是为了学习CDQ分治才来刷这道题目的(~~会Treap的大佬请走开~~)
首先我们考虑二维偏序，只需将第一维例如$a$排序，然后在确保$a$有序的前提下利用各种算法算顺序对$b_j,b_i$，例如Splay，归并，线段树等等

然后至于三维，四维甚至五维六维的，其实就是不断的往上套数据结构(或者继续CDQ分支)罢了，太高序的其实只是套板子的过程了(~~貌似低维也是套板子的过程~~)
本题我采用的是**归并套树状数组**(貌似楼上没有这种算法)

先将一维排序，然后再利用归并排序，值得注意的是
在左区间A,和右区间B中，区间A的a一定小于B，但是A内的a再归并后是否还有序就不一定了！！！
再归并左区间过程中只修改(因为只算对右区间的贡献!!!其内部的贡献会在下层递归中找到)，在右区间过程中才查询！！！

然后我的代码用的是**左闭右闭**的区间，这样更加方便

###代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define mid ((l+r)>>1)
#define lowbit(x) (x&(-x))
#define ll long long
const int _=200100;
inline int read()
{
	char ch='!';int z=1,num=0;
	while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
	if(ch=='-')z=-1,ch=getchar();
	while(ch<='9'&&ch>='0')num=(num<<3)+(num<<1)+ch-'0',ch=getchar();
	return z*num;
}
int N,K,top,bel[_];
ll ans[_],g[_],c[_],f[_];
struct hand
{
	int a,b,c,sz,id;
	bool operator < (const hand &A)const
		{
			if(b!=A.b)return b<A.b;
			if(c!=A.c)return c<A.c;
			return id<A.id;
		}
}t[_],tmp[_],q[_];
bool cmp(hand A,hand B)
{
	if(A.a!=B.a)return A.a<B.a;
	if(A.b!=B.b)return A.b<B.b;
	if(A.c!=B.c)return A.c<B.c;
	return A.id<B.id;
}
void Update(int x,int d)
{
	while(x<=K)
	{
		c[x]+=d;
		x+=lowbit(x);
	}
}
void Clear(int x,int d)
{
	while(x<=K)
	{
		c[x]=d;
		x+=lowbit(x);
	}
}
int Query(int x)
{
	int sum=0;
	while(x)
	{
		sum+=c[x];
		x-=lowbit(x);
	}
	return sum;
}
void CDQ(int l,int r)
{
	if(l==r)return;
	CDQ(l,mid);CDQ(mid+1,r);
	int p=l,q=mid+1,o=l-1;
	while(p<=mid&&q<=r)
	{
		if(t[p]<t[q])
			Update(t[p].c,t[p].sz),tmp[++o]=t[p++];
		else
			g[t[q].id]+=Query(t[q].c),tmp[++o]=t[q++];
	}
	while(p<=mid)tmp[++o]=t[p++];
	while(q<=r)
		g[t[q].id]+=Query(t[q].c),tmp[++o]=t[q++];
	for(int i=l;i<=r;++i)
		Clear(tmp[i].c,0),t[i]=tmp[i];
}
bool pd(int i,int now)
{
	if(!now)return 0;
	else return (q[i].a==t[now].a&&q[i].b==t[now].b&&q[i].c==t[now].c);
}
int main()
{
	N=read();K=read();
	for(int i=1;i<=N;++i)
		q[i].a=read(),q[i].b=read(),q[i].c=read(),q[i].sz=1,q[i].id=i;
	sort(q+1,q+1+N,cmp);
	top=0;
	for(int i=1;i<=N;++i)
	{
		if(!pd(i,top))
			t[++top]=q[i],t[top].id=top;
		else t[top].sz++;
		bel[i]=top;
	}
	CDQ(1,top);
	for(int i=1;i<=top;++i)g[t[i].id]+=t[i].sz-1;
	for(int i=1;i<=N;++i)f[i]=g[bel[i]];
	for(int i=1;i<=N;++i)ans[f[i]]++;
	for(int i=0;i<N;++i)printf("%lld\n",ans[i]);
	return 0;
}

```

---

## 作者：Argvchs (赞：5)

众所周知，三维偏序的一般做法是 CDQ 分治，复杂度是两只 $\log$ 的。

但是我们想要一个根号的做法。（根号信仰！）

目前根号做法有 KDT 和分块。然而 KDT 常数巨大，分块太困难了。这里介绍一种简单的莫队做法。

---

我们知道莫队是可以轻松做在线二维数点的。

考虑怎么将离线三维数点转化为在线二维数点。你可以将 $a_i$ 作为时间、$b_i$ 作为序列、$c_i$ 作为值。带修莫队套值域分块可以轻松做到 $O(n \sqrt n)$。

但是这样做是假的。为什么？因为你一个位置可能会有很多值，这样莫队移动指针的复杂度就不是 $O(1)$ 的，很容易就会被卡掉。

怎么办呢？可以把 $b_i$ 离散化成一个排列，例如：

```text
<-- 1 1 4 5 1 4
--> 1 2 4 6 3 5
```

形式化的：

$$
b'_i = \sum_{j} [b_j < b_i] + \sum_{j \le i} [b_j = b_i]
$$

那么我们修改的时候在对应位置修改，查询的时候查询最大与原序列值相等的位置。这样做就是对的！

我们发现这个带修莫队其实完全没必要。你可以对 $a_i$ 和 $b_i$ 都进行一次这样的离散化，然后像二维莫队那样维护两个指针就可以了。

你甚至可以把 $c_i$ 也离散化，但是这样复杂度就是 $n^{5/3}$ 的。

这个做法可以轻松推广到高维，复杂度和 KDT 应该是一样的，但是比 KDT 快多了。

---

三维偏序的代码：

<https://www.luogu.com.cn/record/192931488>

```cpp
#include <algorithm>
#include <cstring>
#include <iostream>
using namespace std;
const int N = 1e5 + 5, K = 2e5 + 5, B1 = 1e3, B2 = 300;
int n, k, a[N], b[N], c[N], la[K], ra[K], lb[K], rb[K], ab[N], ba[N], ac[N], bc[N], bel[K], val[K],
    sum[N], ans[N];
struct query {
    int a, b, c;
    inline bool operator<(const query &r) {
        if (bel[a] != bel[r.a]) return bel[a] < bel[r.a];
        return bel[a] & 1 ? b < r.b : b > r.b;
    }
} q[N];
inline void insert(int x) { ++val[x], ++sum[bel[x]]; }
inline void remove(int x) { --val[x], --sum[bel[x]]; }
inline int query(int x) {
    int ret = 0;
    for (int i = 1; i <= bel[x] - 1; i++) ret += sum[i];
    for (int i = x; bel[i] == bel[x]; i--) ret += val[i];
    return ret;
}
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> k;
    for (int i = 1; i <= n; i++) cin >> a[i] >> b[i] >> c[i], ++ra[a[i]], ++rb[b[i]];
    for (int i = 1; i <= k; i++) la[i] = ra[i - 1] + 1, ra[i] += ra[i - 1];
    for (int i = 1; i <= k; i++) lb[i] = rb[i - 1] + 1, rb[i] += rb[i - 1];
    for (int i = 1; i <= n; i++) {
        int x = la[a[i]]++, y = lb[b[i]]++;
        q[i] = {ra[a[i]], rb[b[i]], c[i]};
        ab[x] = y, ba[y] = x, ac[x] = bc[y] = c[i];
    }
    for (int i = 1; i <= n; i++) bel[i] = i / B1;
    sort(q + 1, q + n + 1);
    for (int i = 1; i <= k; i++) bel[i] = (i - 1) / B2 + 1;
    for (int i = 1, a = 0, b = 0; i <= n; i++) {
        while (a < q[i].a)
            if (ab[++a] <= b) insert(ac[a]);
        while (a > q[i].a)
            if (ab[a--] <= b) remove(ac[a + 1]);
        while (b < q[i].b)
            if (ba[++b] <= a) insert(bc[b]);
        while (b > q[i].b)
            if (ba[b--] <= a) remove(bc[b + 1]);
        ++ans[query(q[i].c) - 1];
    }
    for (int i = 0; i < n; i++) cout << ans[i] << '\n';
}
```

---

## 作者：Nerlci_ (赞：5)

CDQ分治的思想是对于一个序列进行分治，在分治时保证序列有序，暴力统计左边的序列对右侧的影响。这样的话时间复杂度能够达到优秀的$O(n \log n)$。

使用CDQ分治可以利用数据的有序性来处理高维序列中的某一或某几维，从而高维的序列问题转化到低维。这意味着你可以使用CDQ分治套CDQ分治去解决三维序列问题。

顺便一提，CDQ分治的名字的来源是陈丹琦dalao，最早是在[她CTSC 2008的作业](https://cs.stanford.edu/people/danqi/misc/divide-and-conquer.pdf)中提出的（OrzOrzOrzOrzOrz）。似乎插头DP也是她提出的（[CTSC 2008中的论文](https://cs.stanford.edu/people/danqi/misc/dynamic-programming.pdf)）？

我们以[Luogu P3810 【模板】三维偏序（陌上花开）](https://www.luogu.org/problemnew/show/P3810)为例来讲解CDQ分治。

首先，我们以$a$为第一关键字，$b$为第二关键字，$c$为第三关键字升序排序，这样在分治时我们无需考虑$a$，左侧区间的$a$始终比右侧大。这样我们就降低了一维。

接下来我们对第二维$b$进行CDQ分治。我们不断对每个区间二分递归处理，递归返回时我们枚举右区间每个元素，统计左侧$c$小于等于它的元素个数，这里可以使用树状数组求逆序对来做，当然你也可以再套一个CDQ分治来做。因为$a$，$b$是升序的，所以这样的元素的$a$，$b$也必定小于等于它。

最后，因为我们希望$b$也是有序的，所以我们在分治过程中实现一个归并排序，递归返回时对于当前这个区间的左右区间进行归并排序。（其实这里直接快排也可以，但是会多一个$log$）

实现如下：

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

struct TArray {
  int c[1000010], mn;

  void update(int n, int dt) {
    while (n <= mn) {
      c[n] += dt;
      n += n & (-n);
    }
  }

  int query(int n) {
    int ans = 0;
    while (n > 0) {
      ans += c[n];
      n -= n & (-n);
    }
    return ans;
  }
};

struct Val {
  int a, b, c, ctr, ans;

  const bool operator==(Val& rhs) {
    if (a != rhs.a) { return false; }
    if (b != rhs.b) { return false; }
    if (c != rhs.c) { return false; }
    return true;
  }
};

bool comp(Val& lhs, Val& rhs) {
  if (lhs.a != rhs.a) { return lhs.a < rhs.a; }
  if (lhs.b != rhs.b) { return lhs.b < rhs.b; }
  if (lhs.c != rhs.c) { return lhs.c < rhs.c; }
  return false;
}

bool _comp(Val& lhs, Val& rhs) {
  if (lhs.b != rhs.b) { return lhs.b < rhs.b; }
  if (lhs.c != rhs.c) { return lhs.c < rhs.c; }
  if (lhs.a != rhs.a) { return lhs.a < rhs.a; }
  return false;
}

int n, k, t = 0, b[100010];
Val v[100010], a[100010];
TArray ta;

void cdq(int l, int r) {
  if (l == r) {
    a[l].ans += a[l].ctr - 1;
    return;
  }
  int mid = (l + r) >> 1, j = l;
  cdq(l, mid);
  cdq(mid + 1, r);
  sort(a + l, a + mid + 1, _comp);
  sort(a + mid + 1, a + r + 1, _comp);
  for (int i = mid + 1; i <= r; i++) {
    while (j <= mid && a[j].b <= a[i].b) {
      ta.update(a[j].c, a[j].ctr);
      j++;
    }
    a[i].ans += ta.query(a[i].c);
  }
  for (int i = l; i < j; i++) { ta.update(a[i].c, -a[i].ctr); }
}

int main() {
  scanf("%d %d", &n, &k);
  ta.mn = k;
  for (int i = 1; i <= n; i++) {
    scanf("%d %d %d", &v[i].a, &v[i].b, &v[i].c);
  }
  sort(v + 1, v + n + 1, comp);
  for (int i = 1; i <= n; i++) {
    if (i != 1 && v[i] == v[i - 1]) {
      a[t].ctr++;
    } else {
      a[++t] = v[i];
      a[t].ctr = 1;
    }
  }
  cdq(1, t);
  for (int i = 1; i <= t; i++) {
    b[a[i].ans] += a[i].ctr;
  }
  for (int i = 0; i < n; i++) {
    printf("%d\n", b[i]);
  }
  return 0;
}
```

---

## 作者：koishi_offical (赞：4)

解决三维偏序问题之前，让我们先来看一下他的简化版

一维偏序问题：直接排序统计答案即可。

二维偏序：排序后挨个扫一遍，然后用线段树/树状数组统计（以值为下表）即可。

那么到了三维偏序，每个数据除了 $a$,$b$ 之外，又多了第三维 $c$.
此时就需要用到今天的算法：cdq 分治。

### 算法实现

首先将数组按照第一维 $a$ 排序：

```
bool cmp1(node x,node y)
  {
      if(x.a==y.a)
        {
            if(x.b==y.b) return x.c<y.c;
            return x.b<y.b;
        }
      return x.a<y.a;
  }
```
然后去重，统计每个点的数量：
```
int m=0,num=0;
    for(int i=1;i<=n;i++)
      {
          num++;
          if(c[i].a!=c[i+1].a||c[i].b!=c[i+1].b||c[i].c!=c[i+1].c)
            {
               s[++m].a=c[i].a;
               s[m].b=c[i].b;
               s[m].c=c[i].c;
               s[m].cnt=num;
               num=0;
            }
      }
```
接下来就是核心部分了：

对于任意一段区间 $[l,r]$ ,由于我们已经按照第一关键字排序了，所以 对于该区间的子区间 $[l,mid]$ , $[mid+1,r]$, 前半部分的第一关键字一定小于第二部分的第一关键字。

接着我们将两个子区间按照第二关键字排序：

```
bool cmp2(node x,node y)
  {
      return x.b<y.b;
  }
```
虽然此时两个区间的第一关键字已经乱序了，但没有关系，此时前半部分的第一关键字仍然小于第二部分的第一关键字。

此时我们只需要计算前半部分对后半部分的贡献即可；

我们定义两个指针 $i$,$j$ ,$i$ 在 $[mid+1,r]$ 遍历，然后对于所有的 $s(j).b<s(i).b$ ，将其贡献以 $s(j).c$ 为下标统计进线段树中，最后再查询线段树中 $[1,s(i).c]$ 的区间和，即为 $f(i)$。

```
void cdq(int l,int r)
  {
      if(l==r) return;
      int mid=l+r>>1;
      cdq(l,mid),cdq(mid+1,r);
      sort(s+l,s+mid+1,cmp2),sort(s+mid+1,s+r+1,cmp2);
      int j=l;
      for(int i=mid+1;i<=r;i++)
        {
            while(j<=mid&&s[j].b<=s[i].b) 
             {
                 change(1,1,k,s[j].c,s[j].cnt);
                 j++;
             }
            s[i].ans+=query(1,1,k,1,s[i].c);
        }
      for(int i=l;i<j;i++)
        change(1,1,k,s[i].c,-s[i].cnt);
  }
```
算法复杂度：cdq分治一共会遍历 $\log(n)$ 层，每层会遍历 $n$ 个数，每个数需要 $\log(n)$ 的时间统计进线段树中，因此总的时间复杂度为 $O(n\log^2n)$。




---

## 作者：yangshurong (赞：4)

三位偏序：
只考虑有多少个f，不考虑每个f具体 是f几； 
**第一维**，排序。
接下来，只要满足**bi<=bj,ci<=cj，(i<j)**
那么，i就是j的一个满足条件的元素（i对j造成了贡献）。

怎么同时满足b,c的关系，并且不用再cmp排序？
想到要找到满足（i<j）的同时的b，c。
可以边对b排序，边统计c。
先看b满足条件吗？ 

**用归并排序,排着b点**。
归并排序中，对两个已经排好序的序列处理.

1.对于右边的j，如果左边的i,满足b[i]<b[j]，
就把c[i]添加到树状数组里面，等待将来统计h到i中的元素对j产生的贡献。
如果不满足，即b[i]>b[j],那么以后的(i到t)都不可能对j产生贡献了，
这时候直接统计树状数组里面能对j产生贡献的。

2.如果一个序列已经拍完了，这时还剩一个序列。
还剩右边的，说明h到mid的元素都满足b<b[j],直接树状数组统计。
还剩左边的，已经没机会统计了。

3.最后别忘了将本次树状数组清空！

注意：对于相同的要去重。因为如果所有都不同，那么如果i对j产生贡献，则j不可能对i产生贡献。
但如果有相同的，则j会对i产生贡献。

而归并排序时，只有左边的会对右边的产生贡献，因此得去重后单独统计贡献。 

结尾统计答案：
f[j]的统计： 
对于一个j，有和它不想等的，直接加上。

和它相同的，加（和j相同的元素的个数-1）
而有多少个这样的f[j]呢，有 和j 相同的元素的个数 个f[j] 

```cpp
#include<ctime>
#include<map>
#include<cstdlib>
#include<cmath>
#define r(i,a,b) for(int i=a;i<=b;i++)
#define rr(i,a,b) for(int i=a;i>=b;i--)
#define inf 0x3f3f3f3f
#define mem(a) memset(a,0x3f,sizeof(a))
#define re(a) a=read()
#define me(a) memset(a,0,sizeof(a))
#define in inline
using namespace std;
const int N=100007;
inline int read(){
    char ch=getchar();
    int w=1,x=0;
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0',ch=getchar();}
    return x*w;
}
int n,M,cnt=0,tr[N<<1],ans[N<<1];
struct node{
	int a,b,c,num,contribution;
}e[N],temp[N];
in bool cmp(node x,node y){
	return (x.a==y.a)?((x.b==y.b)?x.c<y.c:x.b<y.b):x.a<y.a;
}
in int lowbit(int x){
	return x&(-x);
}
in void add(int x,int w){
	for(;x<=M;x+=lowbit(x))tr[x]+=w;
}
in int sum(int x){
	int res=0;
	for(;x;x-=lowbit(x))res+=tr[x];
	return res;
}
in void backsort(int h,int t){
	if(h==t)return;
	int mid=(h+t)>>1;
	backsort(h,mid),backsort(mid+1,t);
	int l=h,r=mid+1,tot=h;
	while(l<=mid&&r<=t){
		if(e[l].b<=e[r].b){
			add(e[l].c,e[l].num);
			temp[tot++]=e[l++];
		}
		else e[r].contribution+=sum(e[r].c),temp[tot++]=e[r++];
	}
 /*
 对于右边的j，如果左边的i,满足b[i]<b[j]，
就把c[i]添加到树状数组里面，等待将来统计h到i中的元素对j产生的贡献。
如果不满足，即b[i]>b[j],那么以后的(i到t)都不可能对j产生贡献了，
这时候直接统计树状数组里面能对j产生贡献的。                          
                           */                          
	while(l<=mid)add(e[l].c,e[l].num),temp[tot++]=e[l++];
                                                 /*
如果一个序列已经拍完了，这时还剩一个序列。
还剩右边的，说明h到mid的元素都满足b<b[j],直接树状数组统计。
还剩左边的，已经没机会统计了。                                */
                                 
	while(r<=t)e[r].contribution+=sum(e[r].c),temp[tot++]=e[r++];
	r(i,h,mid)add(e[i].c,-e[i].num);
	r(i,h,t)e[i]=temp[i];
}
int main(){
	//freopen("test.in","r",stdin);
	//freopen("ac.out","w",stdout);
	re(n),re(M);
	r(i,1,n){
		re(e[i].a),re(e[i].b),re(e[i].c);
		e[i].num=1;
	}
	sort(e+1,e+1+n,cmp);
	e[++cnt]=e[1];
	r(i,2,n){
		if(e[cnt].a==e[i].a&&e[cnt].b==e[i].b&&e[cnt].c==e[i].c)e[cnt].num++;
		else e[++cnt]=e[i];
	}
	backsort(1,cnt);
	r(i,1,cnt)ans[e[i].contribution+e[i].num-1]+=e[i].num;
	r(i,0,n-1)printf("%d\n",ans[i]);
	return 0;
}
```


---

## 作者：G我就是菜G (赞：4)

# $CDQ$ 分治

$CDQ$ 分治还是用了“分而治之”的思想，不过这种分治有一个特点，就是能计算一个子问题对于另一个子问题的贡献，从而求出整个问题的答案

**这里以 [三维偏序](https://www.luogu.org/problemnew/show/P3810) 为例**

一维偏序只要一个排序就行了，二维偏序是按一维排好序后用树状数组统计答案，那三维偏序就要用到 $CDQ$ 分治了

把整个数列按一维排好序，然后每次将序列二分，分别做完两块以后再计算后一块对于前一块的贡献

对于计算后一块对前一块的贡献，我们已经按一维排好序了，对于第一维，前一块必定全部小于后一块，则可以排除影响，我们对于前一块和后一块分别按照第二维排序 **（由于我们是计算后一块对于前一块的贡献，则前一块内部已不再互相影响）**，这样能保证前后两块中第二维分别有序，这样对于每个 $a[j],j \in (mid,r]$ 每次将**满足 $a[i].y \le a[j].y$ 的 $a[i].z$ 加入树状数组**，查询即可


~~可能讲的不是很清楚【雾】~~

### 代码如下：

```cpp
#include <bits/stdc++.h>
#define N 2000010
using namespace std;

struct node{
    int x,y,z;
}b[N];

struct node1{
    int x,y,z,ans,same;
}a[N];

struct Treearray{
    int t[N],kk;
    void add(int x,int k) {for (int i=x;i<=kk;i+=i&(-i)) t[i]+=k;}
    int query(int x) {int ans=0;for (int i=x;i;i-=i&(-i)) ans+=t[i];return ans;}
}tree;

int n,m,nn,ans[N];

bool cmp1(node x,node y)
{
    return (x.x<y.x) || (x.x==y.x && x.y<y.y) || (x.x==y.x && x.y==y.y && x.z<y.z);
}

bool cmp2(node1 x,node1 y)
{
    return (x.y<y.y) || (x.y==y.y && x.z<y.z);
}

void cdq(int l,int r)
{
    if (l==r) return;
    int mid=(l+r)>>1;
    cdq(l,mid),cdq(mid+1,r);
    int j=l;
    for (int i=mid+1;i<=r;i++)
    {
        while (a[j].y<=a[i].y && j<=mid)
            tree.add(a[j].z,a[j].same),j++;
        a[i].ans+=tree.query(a[i].z);   \\查询满足条件的元素个数
    }
    for (int i=l;i<j;i++)
        tree.add(a[i].z,-a[i].same);
    sort(a+l,a+r+1,cmp2);    \\每次做完一块数就将其按第二维排序
}

int main()
{
    scanf("%d%d",&n,&m);tree.kk=m;
    for (int i=1;i<=n;i++)
        scanf("%d%d%d",&b[i].x,&b[i].y,&b[i].z);
    sort(b+1,b+n+1,cmp1);   \\先按第一维排序
    nn=1,a[1].x=b[1].x,a[1].y=b[1].y,a[1].z=b[1].z,a[1].same=1;  \\这里去了一下重
    for (int i=2;i<=n;i++)
        if (b[i].x==a[nn].x && b[i].y==a[nn].y && b[i].z==a[nn].z) a[nn].same++;
        else a[++nn].x=b[i].x,a[nn].y=b[i].y,a[nn].z=b[i].z,a[nn].same=1;
    cdq(1,nn);
    for (int i=0;i<=nn;i++)
        ans[a[i].ans+a[i].same-1]+=a[i].same;  \\统计答案时别忘记考虑完全相同元素的贡献
    for (int i=0;i<n;i++)
        printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：封禁用户 (赞：4)

这道题卡了很长时间，而且蒟蒻还看不懂其他题解中为数不多的二维CDQ分治，最后终于自己搞出来了..


这道题目可以转换为对于每一个三元组，求三个坐标均小于等于它的三元组的个数。


一个三元组只会对三个坐标都大于等于它的三元组造成影响，所以这是一个三维偏序问题，我们可以考虑用CDQ分治来处理。

首先把给定的数据去重，因为CDQ分治对于三个坐标完全一样的元素统计答案会出现问题。

这个过程可以在给第一维排序的过程中顺便解决。

我们需要两个CDQ分治函数（可以压缩到一个），第一个负责给第二维排序，第二个负责给第三位排序。

在给第二维排序的过程中，我们还需要记录下来每一个三元组是在左边还是右边，以方便第三维统计答案（因为第三维在统计答案时需要保证三维都有序），每次对第二维的排序进行完毕后，直接进行第三维排序，同时还要保证第三维排序进行完后，对第二维排序的数组不造成任何影响。

代码中有部分说明。

```cpp
#include <iostream>
#include <algorithm>
#include <assert.h>
#define debug(x) std::cout << #x << " = " << x << std::endl;
using int_t = long long int;

using std::cin;
using std::cout;
using std::endl;

const int_t LARGE = 100000;

struct Query
{
    int_t pos[3];
    int_t mark;
    int_t *result = 0;
    int_t count = 0;
    int_t &operator[](int_t x)
    {
        return pos[x];
    }
    bool operator==(const Query &x)
    {
        for (int_t i = 0; i < 3; i++)
        {
            if (pos[i] != x.pos[i])
                return false;
        }
        return true;
    }
};
Query querys[LARGE + 1];
int_t n, k;
//第二个CDQ分治，对第三维坐标进行排序并统计答案
void process2(Query *querys, int_t left, int_t right)
{
    if (left == right)
        return;
    static Query temp[LARGE + 1];
    int_t mid = (left + right) / 2;
    process2(querys, left, mid);
    process2(querys, mid + 1, right);
    int_t uleft = left;
    int_t uright = mid + 1;
    int_t curr = 0;
    //这个for循环写的可能有点晦涩难懂
    //大概就是把普通归并排序合并有序表的三个过程直接结合起来了
    for (int_t i = left; i <= right; i++)
    {
        //uleft uright写成了left right
        //这种烂错误调了一晚上
        
        //能从左边序列中拿出一个元素的条件是左边序列的第一个元素较小或者右边序列已经为空
        if (((uright > right) || querys[uleft].pos[2] <= querys[uright].pos[2]) && uleft <= mid)
        {
            temp[i] = querys[uleft];
            uleft++;
            //之所以要加这个判断，是因为我们对第三维的排序打乱了原来的第二维的状态
            //所以我们设置了一个标记记录了原来第二维的有序性
            //这个标记就是mark，mark为true表示这个查询原来在左边
            if (temp[i].mark != 0)
            {
                //因为元素去重的原因，所以需要乘上元素个数
                curr += (temp[i].mark * temp[i].count);
            }
        }
        else
        {
            temp[i] = querys[uright];
            uright++;
            if (temp[i].mark == 0)
            {
                *temp[i].result += curr;
                // cout << "counting " << curr << " to " << temp[i] << endl;
            }
        }
    }
    std::copy(temp + left, temp + right + 1, querys + left);
}

void process1(Query *querys, int_t left, int_t right)
{
    if (left == right)
        return;
    static Query temp[LARGE + 1];
    int_t mid = (left + right) / 2;
    process1(querys, left, mid);
    process1(querys, mid + 1, right);
    int_t uleft = left;
    int_t uright = mid + 1;
    for (int_t i = left; i <= right; i++)
    {
        if (((uright > right) || querys[uleft].pos[1] <= querys[uright].pos[1]) && uleft <= mid)
        {
            temp[i] = querys[uleft];
            //需要做好这个标记，因为对第三维排序后第二维就无序了
            temp[i].mark = 1;
            uleft++;
        }
        else
        {
            temp[i] = querys[uright];
            //为了防止误统计答案，第二维在右边的需要把标记设置为0
            temp[i].mark = 0;
            uright++;
        }
    }
    std::copy(temp + left, temp + right + 1, querys + left);
    //递归处理第三维
    //注意不要把::querys传进去，因为我们process1的作用是对第二维进行排序，如果再调用process2给第三维排序，而且使用的还是同一个数组，那么我们就打乱了第二维的顺序
    process2(temp, left, right);
}

int main()
{
    int_t _n;
    cin >> n >> k;
    //保存一下n
    _n = n;
    //一个内存池，用来记录查询的答案
    static int_t results[LARGE + 1];
    for (int_t i = 1; i <= n; i++)
    {
        cin >> querys[i].pos[0] >> querys[i].pos[1] >> querys[i].pos[2];
    }
    //排序去重
    std::sort(querys + 1, querys + 1 + n, [](const Query &a, const Query &b) -> bool {
        if (a.pos[0] == b.pos[0])
        {
            if (a.pos[1] == b.pos[1])
            {
                return a.pos[2] < b.pos[2];
            }
            else
            {
                return a.pos[1] < b.pos[1];
            }
        }
        else
        {
            return a.pos[0] < b.pos[0];
        }
    });
    //去重
    int_t first = 1;
    querys[1].count++;
    for (int_t i = 2; i <= n; i++)
    {
        if (querys[i] == querys[first])
        {
            querys[first].count++;
        }
        else
        {
            first = i;
            querys[first].count++;
        }
    }
    n = std::remove_if(querys + 1, querys + 1 + n, [](const Query &x) -> bool { return x.count == 0; }) - querys - 1;
    //给去重后的每一个元素分配一个int指针用来保存结果，因为我们是在process2中统计结果的，而process2中无法对::querys数组做出修改
    for (int_t i = 1; i <= n; i++)
    {
        querys[i].result = results + i;
    }
    process1(querys, 1, n);
    //结果数组
    static int_t result[LARGE + 1];
    for (int_t i = 1; i <= n; i++)
    {
        //因为我们去过重，所以需要给每一个三元组加上这个三元组的个数-1，因为这些东西也对这个三元组的答案做出了贡献
        *querys[i].result += querys[i].count - 1;
        result[*querys[i].result] += querys[i].count;
    }
    for (int_t i = 0; i < _n; i++)
        cout << result[i] << endl;
    return 0;
}

```

博客链接https://yutong.site/?p=722

---

## 作者：FREEH (赞：4)

### 【例题】
![题目描述](https://cdn.luogu.com.cn/upload/pic/28231.png)

### 【解题思路】
- CDQ分治裸题。
- 先把所有属性按照a从小到大排序，并进行a的离散化，记为编号。
- 然后进行CDQ分治，把l到r的属性按照b从小到大排序，这样用树状数组记录<=c属性的属性数，然后就可以统计出答案。
- 但是统计的属性必须在当前属性之前，然后就要使用CDQ分治最精髓的部分：枚举l到r，如果 当前属性编号$<=mid$，那么用树状数组增加对应范围的数量，否则就累加树状数组<=c的数量记为答案，这样就可以保证统计的一定在当前的前面。
- 枚举完之后还要把树状数组清空，但不可以使用$memset$，因为时间复杂度是$n^2$的，只能进行增加操作的逆操作。
- 最后要进行判重（为什么要判重？因为如果不判重，然后出现了3个完全相同的属性，就会出现问题）。

### 【解题反思】
- 在做树状数组的时候要注意大小是编号大小还是数值大小。

### 【参考程序】
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=5000005;
int n,k;
int ans[N],same[N],f[N];
struct NUM{
	int w,a,b,c;
}p[N];
int tree[N];
int lowbit(int x) {return ((x&(-x)));}
void add(int x,int y)
{
	for (;x<=k;x+=lowbit(x)) tree[x]+=y;//此处是<=k而不是<=n
}
int sum(int x)
{
	int ans=0;
	for (;x;x-=lowbit(x)) ans+=tree[x];
	return ans;
}


bool cmp1(NUM a,NUM b)
{
	if (a.a!=b.a) return a.a<b.a;
	if (a.b!=b.b) return a.b<b.b;
	return a.c<b.c;
}
bool cmp2(NUM a,NUM b)
{
	if (a.b!=b.b) return a.b<b.b;
	if (a.c!=b.c) return a.c<b.c;
	return a.a<b.a;
}

void CDQ(int l,int r)
{
	if (l==r) return;
	int mid=(l+r)/2;
	CDQ(l,mid);CDQ(mid+1,r);
	sort(p+l,p+1+r,cmp2);
	for (int i=l;i<=r;i++)
		if (p[i].a<=mid)
		{
			add(p[i].c,1);
		}
		else
		{
			ans[p[i].w]+=sum(p[i].c);
		}
	for (int i=l;i<=r;i++)
		if (p[i].a<=mid)
			add(p[i].c,-1);
}
int main()
{
	scanf("%d%d",&n,&k);
	for (int i=1;i<=n;i++)
	{
		scanf("%d%d%d",&p[i].a,&p[i].b,&p[i].c);
		p[i].w=i;
	}
	sort(p+1,p+1+n,cmp1);
	for (int i=1;i<=n;)
	{
		int j=i+1;
        while (j<=n&&p[i].a==p[j].a&&p[i].b==p[j].b&&p[i].c==p[j].c) 
			j++;
        while(i<j) 
			same[p[i++].w]=p[j-1].w;
	}
	for (int i=1;i<=n;i++)
		p[i].a=i;
		
	CDQ(1,n);
	
	for (int i=1;i<=n;i++)
		f[ans[same[p[i].w]]]++;
	for (int i=0;i<n;i++)
		printf("%d\n",f[i]);
	return 0;
} 
```

---

## 作者：数学系 (赞：4)


给出一个第一维排序，第二维树状数组，第三维treap的代码。

P.S.注意treap数组的大小。

首先对a值进行排序，

然后将c值按照树状数组的方法插入到treap中。

树状数组中是treap的根节点，共有k个treap。

效率为n\*log^2(n)
















```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm> 
using namespace std;
const int maxn=200100;
int n=0,k=0;
int sum[maxn]={},root[maxn]={},answer[maxn]={};
struct node
{
    int l,r;//左子，右子
    int v,w;//节点的值，相同v的个数
    int rand;//随机值，用于维护堆
    int size; 
}t[maxn<<5];
int size=0;
struct data
{
    int a,b,c;
}f[maxn];
int lowbit(int x)
{
    return x&(-x);
}
void updata(int x)
{
    t[x].size=t[t[x].l].size+t[t[x].r].size+t[x].w;
}
void rturn(int &k)
{
    int tmp=t[k].l;
    t[k].l=t[tmp].r;
    t[tmp].r=k;
    t[tmp].size=t[k].size;
    updata(k);
    k=tmp;
}
void lturn(int &k)
{
    int tmp=t[k].r;
    t[k].r=t[tmp].l;
    t[tmp].l=k;
    t[tmp].size=t[k].size;
    updata(k);
    k=tmp;
}
void insert(int &k,int x)
{
    if(!k)//当前点为空，分配一个
    {
        k=++size;
        t[k].size=t[k].w=1;
        t[k].v=x;
        t[k].rand=rand();
        return; 
    }
    t[k].size++;
    if(t[k].v==x)
        t[k].w++;
    else if(x<t[k].v)//插入到左边
    {
        insert(t[k].l,x);
        if(t[t[k].l].rand<t[k].rand)//维护堆
            rturn(k);
    }
    else//右
    {
        insert(t[k].r,x);
        if(t[t[k].r].rand<t[k].rand)//维护堆
            lturn(k);
    } 
}
int rank(int k,int x)//查询x的排名
{
    if(!k)
        return 0;
    if(x==t[k].v)
        return t[k].w+t[t[k].l].size;
    else if(x<t[k].v)
        return rank(t[k].l,x);
    else
        return t[k].w+t[t[k].l].size+rank(t[k].r,x);
}
bool cmp(data a,data b)
{
    if(a.a!=b.a) return a.a<b.a;
    if(a.b!=b.b) return a.b<b.b;
    return a.c<b.c;
}
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)
        scanf("%d%d%d",&f[i].a,&f[i].b,&f[i].c);
    sort(f+1,f+n+1,cmp);
    int ans;
    for(int i=1;i<=n;i++)
    {
        if(f[i].a==f[i+1].a && f[i].b==f[i+1].b && f[i].c==f[i+1].c && i!=n)
            sum[i+1]=sum[i]+1;
        else
        {
            ans=0;
            for(int j=f[i].b;j;j-=lowbit(j))
                ans+=rank(root[j],f[i].c);
            answer[ans]+=sum[i]+1;
        }
        for(int j=f[i].b;j<=k;j+=lowbit(j))
            insert(root[j],f[i].c);
    }
    for(int i=0;i<n;i++)
        cout<<answer[i]<<endl;
    return 0;
}

```

---

## 作者：Orina_zju (赞：3)

人生第一道CDQ分治（还是模板题，写法还贼2b）……

到目前为止题解区最笨的CDQ分治方法：

我们知道CDQ分治可以在某些特定情况下，高效地离线处理一系列单点询问或修改（下文统称为“操作”），那么对于这道题，我们就想办法往这个思路上靠：

令$\{v_i\}$为一个假想的序列，初始时所有值均为$+\infty$。我们把每个点的第一维$a$看成“操作时间”，将所有点按$a$从小到大排序。然后**依次**将每个点$(a,b,c)$转换成以下两个操作：

（1）首先，令$v_b = c$；
（2）然后，截止到当前时刻（对应$a_j \le a_i$），询问$v_0 \cdots v_b$中小于等于$c$的数有多少个。（显然自身也会被统计进去）

这样我们就将$N$个点转化成了$2N$次单点操作。实现时借助一个权值树状数组，CDQ分治可以直接套用“归并时只处理左区间的修改，只统计右区间的查询”的模板框架。

顺便安利一篇博文：https://blog.csdn.net/wu_tongtong/article/details/78785836 

不过这个思路有一个bug，处理$a$相等的情形会出现错误。考虑如下一组样例：

```
4 5
1 3 5
1 3 5
1 2 3
2 2 3
```

如果直接套用上边的思路，会发现：由于点$(1,2,3)$对应的修改操作放在了点$(1,3,5)$之后，那么进行$(1,3,5)$对应的查询时，点$(1,2,3)$并不会被统计进去。对于若干个相同的点也会出现类似的问题。

因此我们需要对模型进行修正：在对$N$个点排序时，以$a$为第一关键字，$b$为第二关键字，$c$为第三关键字。另外相等的点还要调整操作的顺序：对于$k$个相等的点，先把$k$次修改做完，然后进行$k$次查询。例如，上边的样例应该转换成如下的操作序列：

$(1,2,3)$ 修改；
$(1,2,3)$ 询问；

$(1,3,5)$ 修改；
$(1,3,5)$ 修改；

$(1,3,5)$ 询问；
$(1,3,5)$ 询问；

$(2,2,3)$ 修改；
$(2,2,3)$ 询问。

这样方能得到正确的结果（不妨以上例验证一下）。然后就是完整代码（一开始没看到K的限制还手贱写了个离散化）：

``` cpp
#include <cstdio>
#include <algorithm>
#include <functional>
#include <vector>
#include <numeric>

struct node_t
{
    int a, b, c, id;
};

enum class operation_type_t
{
    initialize = 0,
    modify = 1,
    query = 2
};

struct oper_t
{
    operation_type_t type;
    int position;
    int key;
    int ans_id;

    bool operator < (const oper_t& rhs) const
    {
        if (position != rhs.position)
            return position < rhs.position;
        return static_cast<int>(type) < static_cast<int>(rhs.type);
    }
};

template <class T, class Oper = std::plus<T>>
class binary_indexed_tree_t
{
    std::vector<T> value;
    int n;
    Oper oper;

    int lowbit(int x) { return x & -x; }
public:
    binary_indexed_tree_t() = default;
    explicit binary_indexed_tree_t(int n) { init(n); }

    void init(int n)
    {
        value.assign(n + 1, T());
        this->n = n;
    }
    void modify(int pos, const T& x)
    {
        for (pos += 1; pos <= n; pos += lowbit(pos))
            value[pos] = oper(value[pos], x);
    }
    T get_prefix(int pos, T init = T())
    {
        for (pos += 1; pos; pos -= lowbit(pos))
            init = oper(value[pos], init);
        return init;
    }
};

const int maxN = (int)1e5 + 10;

node_t node[maxN];
oper_t oper[maxN * 2];
int ans[maxN];
int N;

void cdq_divide(int left, int right)
{
    static oper_t temp[maxN * 2];
    static binary_indexed_tree_t<int> bit(N);

    if (right - left <= 1)
        return;

    int mid = (left + right) >> 1;
    cdq_divide(left, mid);
    cdq_divide(mid, right);

    for (int il = left, ir = mid, it = 0; il < mid || ir < right; )
    {
        if ((il < mid && ir < right && oper[il] < oper[ir]) ||
            (ir == right))
        {
            if (oper[il].type == operation_type_t::modify)
            {
                bit.modify(oper[il].key, 1);
            }
            temp[it++] = oper[il];
            il += 1;
        }
        else
        {
            if (oper[ir].type == operation_type_t::query)
            {
                ans[oper[ir].ans_id] += bit.get_prefix(oper[ir].key);
            }
            temp[it++] = oper[ir];
            ir += 1;
        }
    }

    for (int i = left; i < mid; i++)
        if (oper[i].type == operation_type_t::modify)
            bit.modify(oper[i].key, -1);

    for (int i = left; i < right; i++)
        oper[i] = temp[i - left];
}

template <class RAIter, class MemPtr, class Comp>
int discretize_in_place(RAIter first, RAIter last, MemPtr mp, Comp &&comp_3way)
{
    std::vector<int> idx(last - first);
    std::iota(idx.begin(), idx.end(), 0);
    std::sort(idx.begin(), idx.end(), [&comp_3way, &first] (int x, int y) {
        return comp_3way(first[x], first[y]) < 0;
    });

    int count = 0, next = 0;
    for (size_t i = 0; i + 1 < idx.size(); i++, count = next)
    {
        next = comp_3way(first[idx[i]], first[idx[i + 1]]) == 0 ? count : count + 1;
        first[idx[i]].*mp = count;
    }
    first[idx.back()].*mp = count;
    return count;
}

int main()
{
    scanf("%d%*d", &N);
    for (int i = 0; i < N; i++)
    {
        scanf("%d%d%d", &node[i].a, &node[i].b, &node[i].c);
        node[i].id = i;
    }

    auto comp_node = [] (const node_t& lhs, const node_t& rhs) {
        if (lhs.a != rhs.a)
            return lhs.a < rhs.a;
        if (lhs.b != rhs.b)
            return lhs.b < rhs.b;
        return lhs.c < rhs.c;
    };
    std::sort(node, node + N, comp_node);

    discretize_in_place(node, node + N, &node_t::b, [](const node_t &lhs, const node_t &rhs) {
        return lhs.b - rhs.b;
    });
    discretize_in_place(node, node + N, &node_t::c, [](const node_t &lhs, const node_t &rhs) {
        return lhs.c - rhs.c;
    });

    oper[0].position = -1;
    oper[0].type = operation_type_t::initialize;

    for (int qi = 1, i = 0; i < N; )
    {
        int ub = std::upper_bound(node + i, node + N, node[i], comp_node) - node;
        for (int j = i; j < ub; j++)
        {
            oper[qi++] = {.type = operation_type_t::modify,
                          .position = node[j].b,
                          .key = node[j].c,
                          .ans_id = node[j].id};
        }
        for (int j = i; j < ub; j++)
        {
            oper[qi++] = {.type = operation_type_t::query,
                          .position = node[j].b,
                          .key = node[j].c,
                          .ans_id = node[j].id};
        }
        i = ub;
    }

    cdq_divide(0, N << 1 | 1);

    std::vector<int> ans_count(maxN);
    for (int i = 0; i < N; i++)
        ans_count[ans[i]] += 1;

    for (int i = 1; i <= N; i++)
        printf("%d\n", ans_count[i]);

    return 0;
}

```


---

## 作者：GK0328 (赞：3)

咦？！我是Pascal的（~~AC400+ Happy~~）

昨天听大佬讲了CDQ分治，觉得很有道理，今天早上一波AC了（题解有些语无伦次，望原谅）。

CDQ分治其实也不难，很容易听懂。

现在进入正题：

三维偏序的思路是，首先对第一维a进行排序，这样我们就会发现a已经是有序的了。

概括：（看不懂也没事）

然后再进行分治，分为{l,mid},{mid+1,r}两个区间进行分治，再次对两个区间以b为关键字排序，用树状数组求出**第一个区间对第二个区间所产生的答案**（分治时会漏掉）。

继续分治--->cdq（l,mid）,cdq（mid+1,r）

具体实现：

①将1~n分为两个区间

②将两个区间分别以b为关键字排序，我们发现，前面的区间的a已经比后面的a大了，那么对于前一个区间中的每一个i，我们要在后一个区间中恰好找到一个点，使得前面的点的b都比该点大，可以用树状数组来维护答案。

③继续分治。

下面是代码，若有失误，望dalao指出。

```cpp
// luogu-judger-enable-o2//O2优化……
type zty=record
  a,b,c,id,ll:longint;
end;
var
  q,u:array[0..400005]of zty;
  d,ans1,ans2:array[0..400005]of longint;
  n,m,i,k,tot,o:longint;
procedure asort(l,r:longint);
      var
         i,j:longint;
         x,y:zty;
      begin
         i:=l;
         j:=r;
         x:=q[(l+r) div 2];
         repeat
           while (q[i].a>x.a) or (q[i].a=x.a) and (q[i].b>x.b)
           or (q[i].a=x.a) and (q[i].b=x.b) and (q[i].c>x.c) do
            inc(i);
           while (x.a>q[j].a) or (x.a=q[j].a) and (x.b>q[j].b)
           or (q[j].a=x.a) and (q[j].b=x.b) and (x.c>q[j].c) do
            dec(j);
           if not(i>j) then
             begin
                y:=q[i];
                q[i]:=q[j];
                q[j]:=y;
                inc(i);
                j:=j-1;
             end;
         until i>j;
         if l<j then
           asort(l,j);
         if i<r then
           asort(i,r);
      end;
procedure bsort(l,r:longint);
      var
         i,j:longint;
         x,y:zty;
      begin
         i:=l;
         j:=r;
         x:=q[(l+r) div 2];
         repeat
           while q[i].b<x.b do
            inc(i);
           while x.b<q[j].b do
            dec(j);
           if not(i>j) then
             begin
                y:=q[i];
                q[i]:=q[j];
                q[j]:=y;
                inc(i);
                j:=j-1;
             end;
         until i>j;
         if l<j then
           bsort(l,j);
         if i<r then
           bsort(i,r);
      end;
function lowbit(x:longint):longint;
begin
  exit(x and (-x));
end;
procedure update(x,y:longint);
begin
  while x<=m do
  begin
    d[x]:=d[x]+y;
    x:=x+lowbit(x);
  end;
end;
function getsum(x:longint):longint;
begin
  getsum:=0;
  while x>0 do
  begin
    inc(getsum,d[x]);
    x:=x-lowbit(x);
  end;
end;
procedure cdq(l,r:longint);
var
  mid,i,j:longint;
begin
  if l=r then
    exit;
  mid:=(l+r) div 2;
  j:=mid+1;
  bsort(l,mid);
  bsort(mid+1,r);

  for i:=l to mid do
  begin
    while (j<=r) and (q[j].b<=q[i].b) do
    begin
      update(q[j].c,q[j].ll);
      inc(j);
    end;
    ans1[q[i].id]:=ans1[q[i].id]+getsum(q[i].c);
  end;
  j:=mid+1;
  for i:=l to mid do
  begin
    while (j<=r) and (q[j].b<=q[i].b) do
    begin
      update(q[j].c,-q[j].ll);
      inc(j);
    end;
    //ans1[i]:=ans1[i]+getsum(q[i].c);
  end;
  {for i:=mid+1 to r do
    if (q[i].a=q[mid].a) and (q[i].b=q[mid].b) and (q[i].c=q[mid].c) then
      inc(ans1[i]);}
  asort(l,mid);
  asort(mid+1,r);

  cdq(l,mid);
  cdq(mid+1,r);
end;
begin
  readln(n,m);
  o:=n;
  for i:=1 to n do
  begin
    readln(q[i].a,q[i].b,q[i].c);
    q[i].id:=i;
  end;
  asort(1,n);
  inc(tot);
  u[tot]:=q[1];
  u[tot].ll:=1;
  for i:=2 to n do
    if (q[i].a=q[i-1].a) and (q[i].b=q[i-1].b) and (q[i].c=q[i-1].c) then
      inc(u[tot].ll) else
      begin
        inc(tot);
        u[tot]:=q[i];
        u[tot].ll:=1;
      end;
  n:=tot;
  //writeln(n);
  q:=u;
  {writeln;
  for i:=1 to n do
    writeln(q[i].a,' ',q[i].b,' ',q[i].c,' ',q[i].ll);}
  cdq(1,n);

  for i:=1 to n do
    inc(ans2[ans1[q[i].id]+q[i].ll-1],q[i].ll);
  //writeln;
  for i:=0 to o-1 do
    writeln(ans2[i]);
end.
```



---

## 作者：arfa (赞：3)

> ### 当然是$CDQ$+树状数组啦


由于没有多少$Pascal$的代码,这里贴一个$Pascal$的,比较工整美观....

> #### 关于三个维的解法

首先第一维,我们可以按照$point[1,i]$进行排序(也就是$a[i]$)。要注意,$point[1,i]$为第一关键字,$point[2,i],point[3,i]$为第二,第三关键字。这时候要注意,在$Pascal$的排序中,**不能定义$mid=(l+r)/2$,而是要定义$s[1]=point[1,mid],s[2]=point[2,mid],s[3]=point[3,mid]$**,不然就会$GG$。

第二维我们采用$CDQ$分治,讲一下做法:

$I.$遇到l=r就可以退出了,$exit$。

$II.$先进入$CDQ(l,mid)$。一开始是$CDQ(1,n)$。

$III.l$到$r$,$element[i]$是这些点的$point[2,i]$(也就是第二个点)。然后定义一个$num[i]:=i$,就是编号。随后进行$element,num$为第一,第二关键字排序。

$IV.l$到$r$,如果$i$的编号小于等于$mid$的话,我们就在树状数组中统计,等一会讲第三维的时候会将如何统计。否则就计算共享,等一会也会讲。

$V.$还原树状数组,然后进入$CDQ(mid+1,r)$。

第三维度为什么要用树状数组?我觉得权值线段树比较好理解。我们求逆序对的时候,也就是看它$1$~$i-1$有多少个数字吧,树状数组就是用来实现这个的。那么插入也就相当于是权值,查询就是查询上述所说。既然树状数组好写,那么就这样子写咯。

> #### $Code$

```pascal
// luogu-judger-enable-o2
var
    n,k,i:longint;
    point:array[1..3,-1..210000] of longint; //坐标点a,b,c
    num,element:array[-1..210000] of longint; //编号和第二坐标,详见下方
    value,ans,tree:array[-1..210000] of longint; //统计答案与树状数组

procedure Sort_1(l,r:longint); //一开始的排序,注意上述所说
var
    i,j,t:longint;
    s:array[1..3] of longint;
begin
    i:=l; j:=r; s[1]:=point[1,(l+r) div 2]; s[2]:=point[2,(l+r) div 2]; s[3]:=point[3,(l+r) div 2];
    repeat
        while (point[1,i]<s[1])or((point[1,i]=s[1])and(point[2,i]<s[2]))or((point[1,i]=s[1])and(point[2,i]=s[2])and(point[3,i]<s[3])) do
        	inc(i);
        while (point[1,j]>s[1])or((point[1,j]=s[1])and(point[2,j]>s[2]))or((point[1,j]=s[1])and(point[2,j]=s[2])and(point[3,j]>s[3])) do
        	dec(j);
        if i<=j then
        begin
        	t:=point[1,i]; point[1,i]:=point[1,j]; point[1,j]:=t;
        	t:=point[2,i]; point[2,i]:=point[2,j]; point[2,j]:=t;
        	t:=point[3,i]; point[3,i]:=point[3,j]; point[3,j]:=t;
            inc(i); dec(j);
        end;
    until i>j;
    if i<r then Sort_1(i,r);
    if j>l then Sort_1(l,j);
end;

procedure Sort_2(l,r:longint); //上述的第二个排序,也就是以第二坐标,编号为第一,第二关键字的排序
var
    i,j,t:longint;
    s:array[1..2] of longint;
begin
    i:=l; j:=r; s[1]:=element[(l+r) div 2]; s[2]:=num[(l+r) div 2];
    repeat
        while (element[i]<s[1])or((element[i]=s[1])and(num[i]<s[2])) do inc(i);
        while (element[j]>s[1])or((element[j]=s[1])and(num[j]>s[2])) do dec(j);
        if i<=j then
        begin
            t:=element[i]; element[i]:=element[j]; element[j]:=t;
            t:=num[i]; num[i]:=num[j]; num[j]:=t;
            inc(i); dec(j);
        end;
    until i>j;
    if i<r then Sort_2(i,r);
    if j>l then Sort_2(l,j);
end;

function lowbit(num:longint):longint; begin exit(num and -num); end; //以下是树状数组常识

procedure Insert(x,add:longint);
begin
    while x<=k do
    begin
        inc(tree[x],add);
        inc(x,lowbit(x));
    end;
end;

function Query(x:longint):longint;
begin
    Query:=0;
    while x>0 do
    begin
        inc(Query,tree[x]);
        dec(x,lowbit(x));
    end;
end;

procedure CDQ(l,r:longint); //cdq分治,l,r为左右两边界
var
    mid,i,j:longint;
begin
    if l=r then exit; //到终点    
    mid:=(l+r) div 2;
    CDQ(l,mid); //先左边

    for i:=l to r do 
    begin
        element[i]:=point[2,i]; //记录第二个坐标
        num[i]:=i; //记录编号
    end;
    Sort_2(l,r); //排序

    for i:=l to r do
        if num[i]<=mid then //编号在左边,算共享
            Insert(point[3,num[i]],1) //直接往这个地方插入,注意是第三坐标的编号
        else
            inc(value[num[i]],Query(point[3,num[i]])); //计算1~第三坐标的共享,注意value里面的是编号
    for i:=l to r do //还原树状数组
        if num[i]<=mid then
            Insert(point[3,num[i]],-1);
    CDQ(mid+1,r); //进入右边
end;

begin
    read(n,k);
    for i:=1 to n do
        read(point[1,i],point[2,i],point[3,i]);
    Sort_1(1,n);
    CDQ(1,n);

    for i:=n-1 downto 1 do //判重复
        if (point[1,i]=point[1,i+1])and(point[2,i]=point[2,i+1])and(point[3,i]=point[3,i+1]) then
            value[i]:=value[i+1];
    for i:=1 to n do //记录答案
        inc(ans[value[i]]);
    for i:=0 to n-1 do
        writeln(ans[i]);
end.
```

以下是$8.29$日对 $CDQ$ 的补充:

其实都可以用权值线段树或者树状数组来完成此类问题,这里来讲一下 $CDQ$ 分治。 $CDQ$ 分治和其它数据结构差不多,几乎都是每多一维,时间复杂度多个 $log\ n$。那么二维偏序直接用树状数组,这里不多说。

$CDQ$ 大体可以认为是 先算出 $l$~$mid$ 的贡献,然后算出 $l$对$r$ 的贡献,最后再算 $mid$~$r$ 的贡献。对于 $l$~$mid$ 和 $mid$~$r$ 的贡献,可以直接 $CDQ(l,mid),CDQ(r,mid)$。为什么呢?因为分治以后它们会对自己的 $l$~$r$ 算自己的贡献,所以这样子木有问题。现在讨论的重点就是如何求出 $l$~$r$ 的贡献。

三维偏序问题: 偏序问题的第一维,我们是直接排序的。注意要按第 $1$ 个数组为第 $1$ 关键字,第 $2$ 个为第 $2$ 个关键字 $.....$。然后我们就可以保证整个数组 $a[i]\leq a[j]\ (i\leq j)$。我们现在有一个区间 $l,r$ ,我们先 $CDQ(l,mid)$。随后我们给 $l,r$ 这个区间进行编号, $num[i]:=i$(这个时候 $num$ 为编号)。我们再用一个数组 $element[l$~$r]$ 为 $l$~$r$ 的 $b[i]$,然后进行 $Sort(l,r)$。其中 $element$ 为第一关键字, $num$ 为第二关键字。

最后循环扫一遍,因为这个时候后已经满足 $b[i]\leq b[j]\ (i\leq j)$。我们就可以按照逆序对这样子,对权值线段树(树状数组)插入第三维 $c[i]$。如果 $num[i]\leq mid$ 的话,我们就插入,否则算贡献。为什么这样子呢?因为现在满足的是 $b[i]\leq b[j]\ (i\leq j)$ ,而 $num[i]\leq mid$ 可以满足 $a[l$~$mid]\leq a[mid+1$~$r]$,我们只需要对 $c$ 数组进行逆序对一样的操作。




---

## 作者：glitxi (赞：2)

### 【例题】
![](https://cdn.luogu.com.cn/upload/pic/28232.png)
### 【结题思路】
- 这题有很多解法碰巧我们是作为CDQ分治的例题，于是这里就只介绍CDQ分治的解法
- 一道三维偏序，所以先把所有属性进行多关键字排序，先按a排序，再按b排序，最后按c排序，这就保证了在数列里面，后面的a会比前面的a要大（相当于把a离散化）。
- 接着就进行CDQ分治，对于一个区间l到r来说，a是已经排好序的。在CDQ分治完l--mid和mid+1--r这两个区间后，把l到r进行多关键字排序，这次先按b排序，再按c排序，最后按a排序，这就再保证了b的要求。
- 然后像CDQ分治需要的那样，把小于等于mid的a的贡献统计起来，把1-c的区间全部加1，优化大于mid的值的答案。这是一个区间修改，单点查询的操作，可以用线段树或者树状数组解决，本人为了方便用了树状数组。
- 记得最后还原树状数组。注意，如果直接对整个数组进行memset有可能会超时，我们只需对直接的操作进行反操作，把小于等于mid的a中，1-c的区间全部加-1即可。
- 最后进行判重（为什么要判重呢？因为如果有几个相同的量，我们CDQ分治的时候并没有管它，直接计算就会把所有结果都计算出来。这是你如果不判重，那么就会把一个答案反复累加，最终答案就会变大）


```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>

using namespace std;
int lowbit(int x) 
{
	return (x&(-x));
}
int n,tree[1000005];
int ans[1000005],sx[1000005];
struct jgt{int a,b,c,num;}sz[1000005];
void add(int x,int c)
{
	for (int i=x;i<=1000000;i+=lowbit(i))
	  tree[i]+=c;
}
int sum(int x)
{
	int sum=0;
	for (int i=x;i>=1;i-=lowbit(i))
	  sum+=tree[i];
	 return sum;	
}
bool cmp1(jgt a,jgt b)
{

	if (a.a!=b.a) return a.a<b.a;
	if (a.b!=b.b) return a.b<b.b;
	return a.c<b.c;
}
bool cmp2(jgt a,jgt b)
{
	if (a.b!=b.b) return a.b<b.b;
	if (a.c!=b.c) return a.c<b.c;
	return a.a<b.a;
}
void CDQ(int l,int r)
{
	if (l==r) return;
	int mid=(l+r)/2;
	CDQ(l,mid);CDQ(mid+1,r);
	sort(sz+l,sz+1+r,cmp2);
	for (int i=l;i<=r;i++)
	  {
	  	if (sz[i].a<=mid) add(sz[i].c,1);
	  	  else ans[sz[i].num]+=sum(sz[i].c);
	  }
	for (int i=l;i<=r;i++)
	  if (sz[i].a<=mid) add(sz[i].c,-1);
	return;
}
int record[1000005];
int k;
int main()
{
	scanf("%d%d",&n,&k);
	for (int i=1;i<=n;i++)
	  {
	  	scanf("%d%d%d",&sz[i].a,&sz[i].b,&sz[i].c);
	  	sz[i].num=i;
	  }
	sort(sz+1,sz+1+n,cmp1);
	int gs=0;
	for (int i=1;i<=n;)
      {
          int j=i+1;
          while (j<=n&&sz[i].a==sz[j].a&&sz[i].b==sz[j].b&&sz[i].c==sz[j].c) j++;
          while (i<j) sx[sz[i++].num]=sz[j-1].num;
      }
	for (int i=1;i<=n;i++) sz[i].a=i;
	CDQ(1,n);
	for (int i=1;i<=n;i++)
	  record[ans[sx[sz[i].num]]]++;
	for (int i=0;i<n;i++) printf("%d\n",record[i]);
	
	return 0;
}
```
    

---


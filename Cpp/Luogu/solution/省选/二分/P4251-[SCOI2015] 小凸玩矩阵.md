# [SCOI2015] 小凸玩矩阵

## 题目描述

小凸和小方是好朋友，小方给了小凸一个 $n$ × $m$ $(n \leq m)$ 的矩阵 $A$，并且要求小凸从矩阵中选出 $n$ 个数，其中任意两个数都不能在同一行或者同一列。现在小凸想知道，选出的 $n$ 个数中第 $k$ 大的数的最小值是多少。

## 说明/提示

对于 $20$% 的数据， $1 \leq n \leq m \leq 9$

对于 $40$% 的数据， $1 \leq n \leq m \leq 22, 1 \leq n \leq 12$

对于 $100$% 的数据， $1 \leq k \leq n \leq m \leq 250, 1 \leq A_{i,j} \leq 10^9$

## 样例 #1

### 输入

```
2 3 1
1 2 4
2 4 1```

### 输出

```
1```

## 样例 #2

### 输入

```
3 4 2
1 5 6 6
8 3 4 3
6 8 6 3```

### 输出

```
3```

# 题解

## 作者：winxp_qwq (赞：19)

暂时还没有题解嘛。。。来一篇好了。

首先第k大并不好求，不如二分掉，多用一个log把它变成判定性问题。

那么这样，加上题目中求最小值的要求，我们只需要判断：是否能找出至少n-k+1个数，使得这些数不大于当前值且满足条件。

注意到每行、列最多取一个数，因此取了这个数，就相当于把此行和此列匹配到一起咯。

如此看来，这是一个二分图匹配问题。

由于比较懒，一直没有学二分图匹配的算法，~~反正dinic也快~~，这里用dinic解决，把每行和每列看做一个点：

#### 1.从源点向每行连边
#### 2.从每列向汇点连边
#### 3.若矩阵a行b列的数小于等于二分中点，则由a行向b列连边

跑最大流判定即可，最后二分出多少就是多少咯~

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
#define maxn 550
#define inf 1000000007
struct edge{
	int ti;
	int wi;
	int ri;
};
int m,n;
queue <int> q;
vector <edge> ed[maxn];
int dis[maxn]={0}; 
int s=511,t=512;
int xx[maxn][maxn]={{0}};
void addedge(int ss,int tt,int ww){
	edge ee;
	ee.ti=tt;ee.wi=ww;ee.ri=ed[tt].size();
	ed[ss].push_back(ee);
	ee.ri=ed[ss].size()-1;ee.ti=ss;ee.wi=0;
	ed[tt].push_back(ee);
	return;
}
void bfs(){
    int i,j;
    for(i=0;i<maxn;i++)
    dis[i]=inf;
    
    dis[s]=0;
    q.push(s);
    while(1)
    {
        if(q.size()==0) break;
        i=q.front();
        q.pop();
        for(j=0;j<ed[i].size();j++)
        {
            if(ed[i][j].wi>0&&dis[i]+1<dis[ed[i][j].ti])
            {
                dis[ed[i][j].ti]=dis[i]+1;
                q.push(ed[i][j].ti);
            }
        }
    }
}

int find(int x,int low){
    int i,j,k;
    int tt,rr,ww;
    
    if(x==t||low==0) return low;
    
    for(i=0;i<ed[x].size();i++)
    {
        tt=ed[x][i].ti;
        rr=ed[x][i].ri;
        ww=ed[x][i].wi;
        if(ww>0&&dis[tt]==dis[x]+1)
        {
            j=find(tt,min(ww,low));
            if(j>0)
            {
                ed[x][i].wi-=j;
                ed[tt][rr].wi+=j;
                return j;
            }
        }
    }
    return 0;
}
int dinic(){
    int ans=0,a;
    while(1)
    {
        bfs();
        if(dis[t]==inf) break;
        while(a=find(s,inf))
        ans+=a;
    }
    return ans;
}
int main(){
	int a,b,c,i,j,k;
	scanf("%d%d%d",&n,&m,&k);
	for(a=1;a<=n;a++)
		for(b=1;b<=m;b++)
			scanf("%d",&xx[a][b]);
	int l=1,r=inf,mid;
	while(l<r)
	{
		mid=(l+r)/2;
		for(i=0;i<maxn;i++) ed[i].clear();
		for(a=1;a<=n;a++) addedge(s,a,1);
		for(b=1;b<=m;b++) addedge(b+250,t,1);
		for(a=1;a<=n;a++)
			for(b=1;b<=m;b++)
				if(xx[a][b]<=mid) addedge(a,b+250,1);
		if(dinic()>=n-k+1) r=mid;
		else l=mid+1;
	}
	printf("%d\n",l);
	return 0;
}
```

---

## 作者：小明小红 (赞：11)

# P4251题解
分析：

这道题可以使用二分答案和二分图匹配解决。

由于每行每列只能选一个，可以想到二分图的套路，也就是将行和列连边。

这样来跑二分图匹配，就可以保证一行对应一边。

因为要求出最小的第 $k$ 大值，于是想到二分出一个第 $k$ 大的数，然后小于这个数的就行向列建边，跑出二分图最大匹配。

如果最大匹配大于 $n-k$，就说明这个数字还可以变得再小，缩小二分的边界。

# code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll n,m,k;
ll mapp[309][309],maxn=-1,head[309],last[90009],to[90009],tot=1,l,r;
ll ans,match[309],vis[309];
void init()
{
	memset(last,0,sizeof(last));
	memset(head,0,sizeof(head));
	memset(to,0,sizeof(to));
}
void add(ll x,ll y)//加边 
{
	tot++;
	to[tot]=y;
	last[tot]=head[x];
	head[x]=tot;
}

bool path(ll u)
{
	for(ll i=head[u];i!=0;i=last[i])//二分图匹配模板 
	{
		ll v=to[i];
		if(vis[v]==1)
			continue;
		vis[v]=1;
		if(match[v]==-1||path(match[v])==true)
		{
			match[v]=u;
			return true; 
		}
	}
	return false;
}
void slove()
{
	ans=0;
	memset(match,-1,sizeof(match));//match数组表示匹配量 
	for(ll i=1;i<=n;i++)
	{
		memset(vis,0,sizeof(vis));
		if(path(i)==true)
		{
			ans++;
		}
	}
}
int main()                    
{
	cin>>n>>m>>k;
	for(ll i=1;i<=n;i++)
	{
		for(ll j=1;j<=m;j++)
		{
			cin>>mapp[i][j];
			maxn=max(maxn,mapp[i][j]);//maxn表示矩阵最大值 
		}
	}
	l=0,r=maxn;
	while(l<=r)//二分求值 
	{
		init(); //一定要初始化！！！ 
		ll mid=(l+r)/2;
		for(ll i=1;i<=n;i++)
		{
			for(ll j=1;j<=m;j++)
			{
				if(mapp[i][j]<mid)
				{
					add(i,j);//若当前边的权值比二分的数要小，加边 
				}
			}
		 } 
		 slove(); //二分图匹配 
		 if(ans>n-k)//如思路，改变l和r的值 
		 {
		 	r=mid-1;
		 }
		 else
		 {
		 	l=mid+1;
		 }
	}
	cout<<r;//输出 
	return 0;
 } 
```


---

## 作者：lemir3 (赞：4)

## 题目分析

每行每列只能选一个,可以想到二分图的套路:将行和列连边.

这样来跑二分图匹配,就可以保证一行对应一边.

因为要求出最小的第k大值,于是想到二分出一个第k大的数,然后小于这个数的就行向列建边,跑出二分图最大匹配.

如果最大匹配大于n-k,就说明这个数字还可以变得再小,缩小二分的边界.

我的代码写出来常数比较大.

## 代码

```cpp
#include "iostream"
#include "cstdio"
#include "cstring"
#include "cmath"
#include "cstdlib"
#include "cctype"
#include "iomanip"
#include "algorithm"
#include "set"
#include "queue"
#include "map"
#include "stack"
#include "deque"
#include "vector"
#include "time.h"
#define lxl long long
#define R register
#define INF 0x3f3f3f3f
#define debug(x) printf("debug:%lld\n",x)
const lxl maxn=255;
lxl n,m,k,l=1,r=1000000000,mid,ans,EdgeSize;
lxl a[maxn][maxn],match[maxn*maxn<<1],head[maxn*maxn<<1],flag[maxn*maxn<<1];
struct _Edge
{
	lxl next,to;
}e[maxn*maxn<<2];
inline lxl read()
{
	char c=getchar();
	lxl f=1,x=0;
	for(;!isdigit(c);c=getchar())(c=='-')&&(f=-1);
	for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
	return f*x;
}
inline void EdgeAdd(lxl from,lxl to)
{
	e[EdgeSize].to=to;
	e[EdgeSize].next=head[from];
	head[from]=EdgeSize++;
}
inline bool find(lxl now)
{
	for(R int i(head[now]),to;~i;i=e[i].next)
	{
		to=e[i].to;
		if(flag[to])continue;
		flag[to]=true;
		if(!match[to]||find(match[to]))
		{
			match[to]=now;
			return true;
		}
	}
	return false;
}
inline lxl Hungery()
{
	lxl cnt=0;
	for(R int i(1);i<=n;++i)
	{
		memset(flag,false,sizeof flag);
		if(find(i))++cnt;
	}
	return cnt;
}
inline void build(lxl limit)
{
	EdgeSize=0;
	memset(head,-1,sizeof head),memset(match,0,sizeof match),memset(e,0,sizeof e);
	for(R int i(1);i<=n;++i)
		for(R int j(1);j<=m;++j)
			if(a[i][j]<=limit)EdgeAdd(i,j+n);
}
inline bool check()
{
	return Hungery()>n-k;
}
int main(void)
{
	n=read(),m=read(),k=read();
	for(R int i(1);i<=n;++i)
		for(R int j(1);j<=m;++j)
			a[i][j]=read();
	while(l<=r)
	{
		mid=(l+r)>>1;
		build(mid);
		if(check())r=mid-1,ans=mid;
		else l=mid+1;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：tzc_wk (赞：4)

> 题意：给出一个 $n \times n$ 的矩阵 $A$，选出 $n$ 个数使得每行每列最多选出一个数，求这 $n$ 个数中第 $k$ **大** 的数的最小值。

> $1 \leq n \leq 250$，$1 \leq A_{i,j} \leq 10^9$ 

最大流的基础题

此题中说第 $k$ 大值最小，那么肯定是二分了。二分出一个 $x$ 出来，检查 $x$ 是否可以作为第 $k$ 大的值，由于我们要将第 $k$ 大值尽可能得小，因此我们要尽可能多得取比 $x$ 小或等于 $x$ 的数，检查是否有 $n-k+1$ 个。如果有，那么就说明 $x$ 可以作为第 $k$ 大的值，否则说明 $x$ 不能作为第 $k$ 大的值。

那么怎么求最多能取多少个 $\leq x$ 的数呢？网络流啊！我们将所有 $\leq x$ 的数赋上 $1$，将所有 $>x$ 的数赋上 $0$。我们可以考虑行列化点，点化边（如果不知道这个技巧的出门右转 CF217A），以行和列建一张二分图。对于矩阵中的每一个元素 $(i,j)$，连一条从第 $i$ 行到第 $j$ 列，容量为 $a_{i,j}$ 所赋上的值的边。如果这条边通过去的流量为 $1$，那么说明 $a_{i,j} \leq x$ 并且我们选了 $a_{i,j}$，否则，说明 $a_{i,j}>x$ 或者我们没有选择 $a_{i,j}$。对于矩阵中的每一行 $i$，建一条从源点 $S$ 到第 $i$ 行的边，容量为 $1$。对于矩阵中点每一列 $j$，建一条从第 $j$ 列到汇点 $T$ 的边，容量为 $1$，然后跑最大流就是最多能取出 $\leq x$ 的数的个数。

```cpp
/*
数据不清空，爆零两行泪。
多测不读完，爆零两行泪。
边界不特判，爆零两行泪。
贪心不证明，爆零两行泪。
D P 顺序错，爆零两行泪。
大小少等号，爆零两行泪。
变量不统一，爆零两行泪。
越界不判断，爆零两行泪。
调试不注释，爆零两行泪。
溢出不 l l，爆零两行泪。
*/
#include <bits/stdc++.h>
using namespace std;
#define fi			first
#define se			second
#define fz(i,a,b)	for(int i=a;i<=b;i++)
#define fd(i,a,b)	for(int i=a;i>=b;i--)
#define put(x)		putchar(x)
#define eoln        put('\n')
#define space		put(' ')
inline int read(){
	int x=0,neg=1;char c=getchar();
	while(!isdigit(c)){
		if(c=='-')	neg=-1;
		c=getchar();
	}
	while(isdigit(c))	x=x*10+c-'0',c=getchar();
	return x*neg;
}
inline void print(int x){
	if(x<0){
		putchar('-');
		print(abs(x));
		return;
	}
	if(x<=9)	putchar(x+'0');
	else{
		print(x/10);
		putchar(x%10+'0');
	}
}
int n=read(),m=read(),k=read();
int a[255][255],s[255][255];
int head[100005];
struct edge{
	int to,nxt,cap;
} e[2000005];
int ecnt=1;
inline void addedge(int u,int v,int f){
	e[++ecnt].to=v;e[ecnt].cap=f;e[ecnt].nxt=head[u];head[u]=ecnt;
}
int dep[100005];
inline bool bfs(int s,int t){
	queue<int> q;
	memset(dep,-1,sizeof(dep));
	q.push(s);dep[s]=0;
	while(!q.empty()){
		int cur=q.front();q.pop();
		for(int i=head[cur];i;i=e[i].nxt){
			int to=e[i].to;
			if(dep[to]==-1&&e[i].cap){
				dep[to]=dep[cur]+1;
				q.push(to);
			}
		}
	}
	if(dep[t]!=-1)	return 1;
	return 0;
}
inline int dfs(int x,int t,int f){
	if(x==t)	return f;
	int ret=0;
	for(int i=head[x];i;i=e[i].nxt){
		int y=e[i].to;
		if(dep[y]==dep[x]+1&&e[i].cap){
			int w=dfs(y,t,min(f-ret,e[i].cap));
			e[i].cap-=w;
			e[i^1].cap+=w;
			ret+=w;
			if(ret==f)	return f;
		}
	}
	if(ret==0)	dep[x]=-1;
	return ret;
}
inline int Dinic(int s,int t){
	int tot=0;
	while(bfs(s,t))	tot+=dfs(s,t,0x3f3f3f3f);
	return tot;
}
inline bool check(int mid){
	int cnt=0;
	fz(i,1,n)	fz(j,1,m)	s[i][j]=(a[i][j]<=mid);
	ecnt=1;
	memset(head,0,sizeof(head));
	fz(i,1,n){
		fz(j,1,m){
			addedge(i,j+n,s[i][j]);
			addedge(j+n,i,0);
		}
	}
	fz(i,1,n){
		addedge(0,i,1);
		addedge(i,0,0);
	}
	fz(i,1,m){
		addedge(i+n,1+n+m,1);
		addedge(1+n+m,i+n,0);
	}
	int t=Dinic(0,n+m+1);
	return t>=(n-k+1);
}
int key[100005],cnt,hs[100005],cnt2;
int main(){
	fz(i,1,n)	fz(j,1,m){
		a[i][j]=read();
		key[++cnt]=a[i][j];
	}
	sort(key+1,key+cnt+1);
	fz(i,1,cnt)	if(key[i]!=key[i-1])	hs[++cnt2]=key[i];
	fz(i,1,n)	fz(j,1,m)	a[i][j]=lower_bound(hs+1,hs+cnt2+1,a[i][j])-hs;
//	cout<<check(1169)<<endl;
//	cout<<check(1170)<<endl;
	int l=0,r=cnt2,ans=0;
	while(l<=r){
		int mid=(l+r)>>1;
		if(check(mid))	ans=mid,r=mid-1;
		else			l=mid+1;
	}
	cout<<hs[ans]<<endl;
	return 0;
}
```

---

## 作者：雨季 (赞：4)

# 题意
在 $n \times m$ 的矩阵中取出 $n$ 个不同行且不同列的数，求取出的 $n$ 个数中第 $k$ 大的最小值。
# 题解
对于题面中的 第 $k$ 大值最小 ，我们很容易想到二分答案求 最大值最小/最小值最大 问题，将题目转换成判定性问题。那么对于这道题，我们需要做的就是判断是否能存在第 $k$ 大，也就是判断能不能取出 $n-k+1$ 个 $<=mid$ 的数。

建图：  
对于每一行，$S \to i$ 连边；  
对于每一列，$j+n \to T$ 连边；  
二分一个 $mid$ ，对于任意一个 $a[i][j]$ ，如果 $a[i][j]<=mid$ ，$i\to j+n$ 连边。   
跑二分图最大匹配，如果匹配数 $>=n-k+1$，那么 $r=mid-1$，否则 $l=mid+1$。  
这样，对于每一行和每一列只能选择最多一次，且满足选出的数不同行且不同列。
# 代码  
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
#define N 1005

int n,m,K;
int a[255][255];

inline int read() {
    int tmp=0,w=1;
    char ch=0;
    while(!isdigit(ch)) {if(ch=='-') w=-1;ch=getchar();}
    while(isdigit(ch)) tmp=(tmp<<1)+(tmp<<3)+ch-'0',ch=getchar();
    return tmp*w;
}

struct node {
    int v,nex;
}e[N*N];
int tot,h[N];
void add(int u,int v) {
    e[++tot].v=v,e[tot].nex=h[u],h[u]=tot;
}

bool vis[N];
int match[N];
bool find(int x) {
    int xx;
    for(int i=h[x];i;i=e[i].nex) {
        xx=e[i].v;
        if(!vis[xx]) {
            vis[xx]=1;
            if(!match[xx]||find(match[xx])) {
                match[xx]=x;
                return 1;
            }
        }
    }
    return 0;
}

bool pd(int mid) {
    memset(h,0,sizeof(h)),tot=1;
    memset(match,0,sizeof(match));
    for(int i=1;i<=n;++i) {
        for(int j=1;j<=m;++j) {
            if(a[i][j]<=mid) add(i,j+n);
        }
    }
    int res=0;
    for(int i=1;i<=n;++i) {
        memset(vis,0,sizeof(vis));
        res+=find(i);
    }
    return res>=n-K+1;
}
int maxx=-1e9,minn=1e9;
void Bsearch() {
    int l=minn,r=maxx,mid,ans;
    while(l<=r) {
        mid=(l+r)>>1;
        if(pd(mid)) r=mid-1,ans=mid;
        else l=mid+1;
    }
    printf("%d\n",ans);
}

int main()
{
    n=read(),m=read(),K=read();
    for(int i=1;i<=n;++i) {
        for(int j=1;j<=m;++j) {
            a[i][j]=read();
            maxx=max(maxx,a[i][j]);
            minn=min(minn,a[i][j]);
        }
    }
    Bsearch();
    return 0;
} 
```

---

## 作者：huangdu233 (赞：3)

二分答案+二分图匹配（果然我是不会写网络流的蒟蒻）

二分第k大的值是多少$(mid)$，如果最大边不超过$mid$的**最大匹配**满足 $\le n-k+1$ 则为合法答案

【代码】

```
#include<bits/stdc++.h>
using namespace std;
int n,m,k,ans;
int mp[255][255];
int vis[255],lin[255],tot;
inline bool dfs(int u,int lim){
    for(int i=1;i<=m;++i)
       if(mp[u][i]<=lim&&vis[i]!=tot){
       	  vis[i]=tot;
       	  if(!lin[i]||dfs(lin[i],lim))
       	    return lin[i]=u,true;
       }
    return false;
}
inline int check(int x){
    memset(vis,0,sizeof(vis));
    memset(lin,0,sizeof(lin));
    tot=1,ans=0;
    for(int i=1;i<=n;++i,++tot)
       ans+=dfs(i,x);
    return ans;
}
int main()
{
     scanf("%d%d%d",&n,&m,&k);
     k=n-k+1;
     int lim=-1;
     for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j){
        	scanf("%d",&mp[i][j]);
        	lim=max(lim,mp[i][j]);
        }
     int mid,l=1,r=lim;
     while(l<r){
     	mid=(l+r)/2;
     	if(check(mid)>=k) r=mid;
     	else l=mid+1;
     }
     printf("%d",l);
     return 0;
}
```

---

## 作者：MarchKid_Joe (赞：2)

# [[SCOI2015]小凸玩矩阵](https://www.luogu.com.cn/problem/P4251)

## 题意

给定一个 ${n}\times{m}$ 的矩阵，矩阵第 $i$ 行第 $j$ 列的权值为 $a_{i,j}$。现在要求从矩阵中选出 $n$ 个数，每行每列只能选择一个数，询问**第 $k$ 大值**的**最小值**是多少？

## 思路

对于类似于**最X值最X**这类语气的问题，一般都会用到二分；然后对于**限制每行每列选择**的问题，本质上就是**二分图最大匹配**，可以使用**网络最大流**或者**匈牙利算法**解决。至此，这道题目的算法就显然了：

- 二分答案
- 二分图最大匹配

### 二分答案

考虑如何求**第 $k$ 大值**的**最小值**，有两种二分方法，但是本质上是一样的：

- 二分答案的位置
- 二分答案的权值

前者：先将矩阵中所有的权值**去重从小到大**排序，使满足单调性，然后二分答案所处的位置；

后者：对矩阵中所有的权值取 $\max$，然后二分值域寻找答案。

最后就是检查答案 $mid$ 的合法性：**判断是否存在一种合法的方案满足不大于 $mid$ 的元素有 $n-k+1$ 个**。若满足，减小右边界 $r$；否则，增大左边界 $l$。

### 二分图最大匹配

考虑如何求出是否存在合法方案，钦定对于当前的答案为 $mid$，对于满足 $a_{i,j}\leqslant mid$ 条件的，从 $i$ 向 $j$ 连边，最后求二分图最大匹配数与 $n-k+1$ 进行比较。

此处采用网络流算法，说明一下建边：

- 源点 $S$ 向每行连边。
- 每列向汇点 $T$ 连边。
- 满足 $a_{i,j}\leqslant mid$ 条件的，从行 $i$ 向列 $j$ 连边。

### 总结

二分答案，然后判断是否存在一种方案满足不大于 $mid$ 的数有 $n-k+1$ 个，判断就是二分图最大匹配数。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 250 + 5;
const int M = N * N + 2 * N;
const int s = 2 * N - 1;
const int t = 2 * N - 2;
namespace IO{}
using namespace IO;
namespace netflow
{
    struct edge
    {
        int u, v, w;
        int nxt;
        edge (int u = 0, int v = 0, int w = 0, int nxt = 0) : u(u), v(v), w(w), nxt(nxt) {}
    };
    edge e[M << 1];
    int head[N << 1];
    int cur[N << 1];
    int dep[N << 1];
    int ecnt;
    inline void add(int u, int v, int w)
    {
        e[++ecnt] = edge (u, v, w, head[u]); head[u] = ecnt;
        e[++ecnt] = edge (v, u, 0, head[v]); head[v] = ecnt;
    }
    inline bool bfs()
    {
        memset(dep, 0x00, sizeof(dep));
        memcpy(cur, head, sizeof(cur));
        queue<int> q; q.push(s), dep[s] = 1;
        while (!q.empty())
        {
            int u = q.front();
            q.pop();
            for (int i = head[u], v; i && (v = e[i].v); i = e[i].nxt)
            {
                if (!dep[v] && e[i].w)
                {
                    dep[v] = dep[u] + 1;
                    q.push(v);
                }
            }
        }
        return dep[t];
    }
    inline int dfs(int u, int flow)
    {
        if (u == t) return flow;
        int rest = flow;
        for (int i = cur[u], v; i && (v = e[i].v); i = e[i].nxt)
        {
            cur[u] = i;
            if (dep[v] == dep[u] + 1 && e[i].w)
            {
                int k = dfs(v, min(e[i].w ,rest));
                e[i].w -= k;
                e[i ^ 1].w += k;
                rest -= k;
                if (!rest) break;
            }
        }
        return flow - rest;
    }
    inline int dinic()
    {
        int ans(0);
        while (bfs())
            ans += dfs(s, 2e9);
        return ans;
    }
    inline void clear()
    {
        ecnt = 1;
        memset(head, 0, sizeof(head));
    }
}
using namespace netflow;
int n, m, k;
int a[N][N];
int b[N * N];
int calc(int x)
{
    clear();
    for (int i = 1; i <= n; i++)
        add(s, i, 1);
    for (int i = 1; i <= m; i++)
        add(n + i, t, 1);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            if (a[i][j] <= x)
                add(i, n + j, 1);
    return dinic();
}
signed main()
{
    int cnt(0);
    read(n, m, k);
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            read(a[i][j]);
            b[++cnt] = a[i][j];
        }
    }
    sort(b + 1, b + cnt + 1);
    int l = 1, r = unique(b + 1, b + cnt + 1) - b - 1, ans(0);
    while (l <= r)
    {
        int mid = (l + r) >> 1;
        if (calc(b[mid]) >= n - k + 1) ans = b[mid], r = mid - 1;
        else l = mid + 1;
    }
    write(ans);
    return 0;
}
```

---

## 作者：Exber (赞：1)

## 做法

二分+网络最大流。

根据题面 `第 k 大的数的最小值` 这一句就很容易想到二分。可以二分枚举这个值，假设它为 $x$，则 $\le x$ 的所有数都能选，如果最终能选出 $n-k+1$ 个数即满足条件。

考虑如何算出最终最多能选出多少个数。可以从源点连流量为 `1` 的边到 $[1,n]$ 的所有点，代表行；从 $[n+1,n+m]$ 连流量为 `1` 的边到汇点，代表列。因为每一行只能选一个数且每一列只能选一个数，所以对于每一个能选的数 $a_{i,j}$，需要从 $i$ 到 $n+j$ 连一条流量为 `1` 的边。最后跑一遍网络最大流即可。

## AC 代码

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <queue>

using namespace std;

#define S 1000005
#define MS 100005

int n,m,k,s,t;
long long a[255][255];
int esum,to[S],nxt[S],h[MS];
long long c[S];
int dep[MS],cur[MS];

inline void init() // 初始化 
{
	esum=1;
	memset(h,0,sizeof(h));
	s=0;
	t=n+m+1;
}

inline void add(int x,int y,long long w)
{
	to[++esum]=y;
	c[esum]=w;
	nxt[esum]=h[x];
	h[x]=esum;
}
 
inline bool bfs()
{
	memset(dep,0,sizeof(dep));
	queue<int> q;
	q.push(s);
	dep[s]=1;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(int i=h[u];i;i=nxt[i])
		{
			int v=to[i];
			if(c[i]>0&&dep[v]==0)
			{
				dep[v]=dep[u]+1;
				q.push(v);
			}
		}
	}
	return dep[t]>0;
}

long long dfs(int u,long long w)
{
	if(u==t)
	{
		return w;
	}
	long long sum=0;
	for(int &i=cur[u];i;i=nxt[i])
	{
		int v=to[i];
		if(c[i]>0&&dep[v]==dep[u]+1)
		{
			long long res=dfs(v,min(c[i],w));
			if(res>0)
			{
				c[i]-=res;
				c[i^1]+=res;
				w-=res;
				sum+=res;
				if(w==0)
				{
					break;
				}
			}
		}
	}
	return sum;
}

inline long long dinic() // 网络最大流 dinic 算法板子 
{
	long long res=0;
	while(bfs())
	{
		for(int i=s;i<=t;i++)
		{
			cur[i]=h[i];
		}
		res+=dfs(s,1e17);
	}
	return res;
}

inline bool check(long long mid)
{
	init(); // 初始化 
	for(int i=1;i<=n;i++) // 每一行的点 
	{
		add(s,i,1);
		add(i,s,0);
	}
	for(int i=1;i<=m;i++) // 每一列的点 
	{
		add(n+i,t,1);
		add(t,n+i,0);
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(a[i][j]>mid)
			{
				continue;
			}
			// 在该点对应的行和列建边 
			add(i,n+j,1);
			add(n+j,i,0);
		}
	}
	return dinic()>=n-k+1;
}

int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			scanf("%lld",&a[i][j]);
		}
	}
	long long l=1,r=1e11,ans;
	while(l<=r) // 二分答案板子 
	{
		long long mid=l+r>>1;
		if(check(mid))
		{
			ans=mid;
			r=mid-1;
		}
		else
		{
			l=mid+1;
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：USTC_Ming (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P4251)

思路：题目要求变相解答一下，求出是否有n-k个数，不大于当前求的第k个数

而每一行每一列只能有一个数，就可以得到一个二分图的思路，边上的权值就是第i行第j列这个数的值

对于答案就是第k大的数，则用二分来求

每一次对mid进行判断时，要重建图，以满足要求

~~水题解，赚咕值~~

```cpp

#include <cstdio>
#include <iostream>
#include <cctype>
#include <algorithm>
#include <cmath>
#include <cstring>
using namespace std;

#define clr(x) memset(x,0,sizeof(x))
#define int long long

inline int read(){
    int s=0;bool flag=true;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')flag=false;ch=getchar();}
    while(isdigit(ch)){s=(s<<3)+(s<<1)+ch-'0';ch=getchar();}
    return flag?s:-s;
}

inline void out_put(int x){
    if(x<0)    putchar('-'),x=-x;
    if(x>9)    out_put(x/10);
    putchar(x%10+'0');
}

inline void print(int x){out_put(x),puts("");}

const int N=255;
const int inf=0x3f3f3f3f3f3f3f3f3f;
bool vis[N],line[N][N];
int row[N],w[N][N];
int n,m,k;

inline bool find(int x){
    for(int i=1;i<=m;i++)
        if(line[x][i] && !vis[i]){
            vis[i]=true;
            if(!row[i] || find(row[i])){
                row[i]=x;
                return true;
            }
        }
    return false;
}

inline void rebuild(int limit){
    clr(line),clr(row);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            if(w[i][j]<=limit)    
                line[i][j]=true;
}

inline bool check(int x){
    rebuild(x);
    int cnt=0;
    for(int i=1;i<=n;i++){
        clr(vis);
        if(find(i))    cnt++;
    }
    if(cnt>n-k)    return true;
    return false;
}

signed main(void){
    n=read(),m=read(),k=read();
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            w[i][j]=read();
    int l=1,r=inf,ans;
    while(l<=r){
        int mid=(l+r)>>1;
        if(check(mid))r=mid-1,ans=mid;
        else l=mid+1;
    }
    print(ans);
    return 0;
} 

 
```


---

## 作者：Coros_Trusds (赞：0)

upd：修改一处笔误。

# 题目大意

小凸和小方是好朋友，小方给了小凸一个 $n\times m$ $(n \leq m)$ 的矩阵 $A$，并且要求小凸从矩阵中选出 $n$ 个数，其中任意两个数都不能在同一行或者同一列。现在小凸想知道，选出的 $n$ 个数中第 $k$ 大的数的最小值是多少。

# 题目分析

入门题。

求第 $k$ 大不容易，不妨二分答案 $mid$ 能否在满足条件的情况下作为第 $k$ 大，即能否在满足条件的情况下找到 $n-k+1$ 个小于等于 $mid$ 的数。

然后求满足情况条件下最多能找到多少个数就是经典的“車的放置”问题，也就是每行每列只能出现一个数，这里不再赘述。找到所有不超过 $mid$ 的数，将它的行、列坐标连边，跑匈牙利算法求出最大匹配即可。

-----

二分答案，把矩阵 $A$ 所有值使用二向箔降维打击并排序，然后二分。答案显然满足单调性。

# 代码

```cpp
#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <numeric>
#include <algorithm>
#include <cmath>
#define enter putchar(10)
#define debug(c,que) std::cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) std::cout << arr[i] << w;
#define speed_up() std::ios::sync_with_stdio(false),std::cin.tie(0),std::cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define stop return(0)
const int mod = 1e9 + 7;
inline int MOD(int x) {
	if(x < 0) x += mod;
	return x % mod;
}
namespace Newstd {
	char buf[1 << 21],*p1 = buf,*p2 = buf;
	inline int getc() {
		return p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1 << 21,stdin),p1 == p2) ? EOF : *p1 ++;
	}
	#ifndef ONLINE_JUDGE
	#define getc getchar
	#endif
	inline int read() {
		int ret = 0,f = 0;char ch = getc();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getc();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getc();
		}
		return f ? -ret : ret;
	}
	inline double double_read() {
		long long ret = 0,w = 1,aft = 0,dot = 0,num = 0;
		char ch = getc();
		while (!isdigit(ch)) {
			if (ch == '-') w = -1;
			ch = getc();
		}
		while (isdigit(ch) || ch == '.') {
			if (ch == '.') {
				dot = 1;
			} else if (dot == 0) {
				ret = (ret << 3) + (ret << 1) + ch - 48;
			} else {
				aft = (aft << 3) + (aft << 1) + ch - '0';
				num ++;
			}
			ch = getc();
		}
		return (pow(0.1,num) * aft + ret) * w;
	}
	inline void write(int x) {
		if(x < 0) {
			putchar('-');
			x = -x;
		}
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;

const int N = 255;
struct Graph {
	int v,nxt;
} gra[N * N];
int mat[N * 2],vis[N * 2],head[N * 2],t[N * N],a[N][N];
int n,m,k,idx,nowidx,num;
inline void add(int u,int v) {
	gra[++ idx] = (Graph){v,head[u]},head[u] = idx;
}
inline bool dfs(int now) {
	for (register int i = head[now];i;i = gra[i].nxt) {
		int v = gra[i].v;
		if (vis[v] != nowidx) {
			vis[v] = nowidx;
			if (!mat[v] || dfs(mat[v])) {
				mat[v] = now;
				return true;
			}
		}
	}
	return false;
}
inline bool check(int now) {
	idx = nowidx = 0;
	mst(vis,0),mst(mat,0),mst(head,0),mst(gra,0);
	for (register int i = 1;i <= n; ++ i) {
		for (register int j = 1;j <= m; ++ j) {
			if (a[i][j] <= now) {
				add(i,j + m);
			}
		}
	}
	int ans = 0;
	for (register int i = 1;i <= n; ++ i) {
		nowidx ++;
		if (dfs(i)) ans ++;
	}
	return ans >= n - k + 1;
}
int main(void) {
	n = read(),m = read(),k = read();
	int R = 0;
	for (register int i = 1;i <= n; ++ i) {
		for (register int j = 1;j <= m; ++ j) {
			a[i][j] = t[++ num] = read();
			R = std::max(R,a[i][j]);
		}
	}
	std::sort(t + 1,t + num + 1);
	int l = 1,r = num,ans = -1;
	while (l <= r) {
		int mid = l + r >> 1;
		if (check(t[mid])) r = mid - 1,ans = mid;
		else l = mid + 1;
	}
	printf("%d\n",t[ans]);
	
	return 0;
}
```

---

## 作者：intel_core (赞：0)

这个题直接做肯定不好做，于是我们二分转化为判定一个 $x$ 是否可行。

很明显，可行等价于可以在表中选出 $n-k+1$ 个不同行，不同列且 $\le x$ 的数。

我们在表中把所有 $\le x$ 的数的位置都挑出来，因为每一行，每一列都只能选一个数，也就是选一个对应的行/列。

不难想到转化为二分图匹配，如果 $a_{i,j} \le x$，那么在 $row_i,column_j$ 之间连一条边。跑二分图匹配即可。

实现我用的是 $\text{Dinic}$，单次的复杂度是 $O(nm)$，总复杂度 $O(nm\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int NR=1e3+10;
const int MR=1e5+10;
int n,m,k,s,t,a[NR][NR];
int v[MR],cnt;

int tot=1,fte[NR];
int dis[NR],cur[NR];
struct edge{
	int to,next;
	int flow;
}g[MR<<1];
void add(int x,int y,int z){
	g[++tot]=(edge){y,fte[x],z};fte[x]=tot;
	g[++tot]=(edge){x,fte[y],0};fte[y]=tot;
}
bool bfs(){
	memset(dis,-1,sizeof(dis));
	queue<int>q;q.push(s);
	dis[s]=0;cur[s]=fte[s];
	while(!q.empty()){
		int x=q.front();q.pop();
		for(int i=fte[x];i;i=g[i].next){
			int y=g[i].to;
			if(dis[y]==-1&&g[i].flow){
				q.push(y);dis[y]=dis[x]+1;
				cur[y]=fte[y];
				if(y==t)return true;
			}
		}
	}
	return false;
}
int dfs(int id,int Limit){
	if(id==t)return Limit;
	int flow=0;
	for(int i=cur[id];i&&flow<Limit;i=g[i].next){
		cur[id]=i;
		int y=g[i].to;
		if(g[i].flow!=0&&dis[y]==dis[id]+1){
			int f=dfs(y,min(g[i].flow,Limit-flow));
			if(!f)dis[y]=-1;
			g[i].flow-=f;g[i^1].flow+=f;
			flow+=f;
		}
	}
	return flow;
}
int Dinic(){
	int MaxFlow=0,flow=0;
	while(bfs())
		while(flow=dfs(s,1e9))MaxFlow+=flow;
	return MaxFlow;
}

void clear(){
	for(int i=2;i<=tot;i++)g[i]=(edge){0,0,0};
	memset(fte,0,sizeof(fte));
	memset(cur,0,sizeof(cur));tot=1;
}
bool check(int x){
	clear();
	for(int i=1;i<=n;i++)add(s,i,1);
	for(int i=1;i<=m;i++)add(i+n,t,1);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(a[i][j]<=v[x])add(i,j+n,1);
	return Dinic()>=n-k+1;
} 

int main(){
	cin>>n>>m>>k;s=n+m+1;t=s+1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)cin>>a[i][j],v[++cnt]=a[i][j];
	sort(v+1,v+1+cnt);
	cnt=unique(v+1,v+1+cnt)-v-1;
	int l=1,r=cnt,res=cnt;
	while(l<=r){
		int mid=(l+r)>>1;
//		printf("%d %d %d\n",l,r,mid);
		if(check(mid))res=mid,r=mid-1;
		else l=mid+1;
	}
	cout<<v[res]<<endl;
	return 0;
}
```

---

## 作者：Edward_Elric (赞：0)

## 思路
**任意两个数都不能在同一行或者同一列**。很明显的暗示了，二分图。于是我们考虑将行和列拆成二分图的两个点集。建图和[ZJOI2007]矩阵游戏很类似。

**第k大的数的最小**，很容易想到二分。于是我们考虑二分答案。如果点权小于二分值就将该点所在行列加边。判断最后流量是否大于**n-k+1**;

**n-k+1**因为是求第**k**大。也就是说第**k-1**之前的边多大是没有限制的。于是很容易想到一定会有**k-1**列与行是一定连通的。
## 代码
网络流增广路**Dinic**

```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f 
using namespace std;
const int maxn=500+100;
const int md=250+5;
int head[maxn],cur[maxn],dep[maxn];
int mapn[md][md];
int s,t;
struct edge
{
    int to,next,cap;
}e[maxn*maxn];
int n,m,k;
int size=1;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
    while(ch<='9'&&ch>='0'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar(); }
    return x*f;
}
void addedge(int u,int v,int val)
{
    e[++size].to=v;e[size].cap=val;e[size].next=head[u];head[u]=size;
    e[++size].to=u;e[size].cap=0;e[size].next=head[v];head[v]=size;
}
int id(int i,int j)
{
    return (i-1)*n+j;
}
bool bfs()
{
    memset(dep,0,sizeof(dep));
    queue<int>q;
    q.push(s);
    dep[s]=1;
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(int i=head[u];i;i=e[i].next)
        {
            int to=e[i].to;
            if(!dep[to]&&e[i].cap>0)
            {
                dep[to]=dep[u]+1;
                q.push(to);
            }
        }
    }
    return dep[t];
}
int dinic(int u,int f)
{
    if(u==t||!f)return f;
    int flow=0;
    for(int &i=cur[u];i;i=e[i].next)
    {
        int to=e[i].to;
        if(e[i].cap>0&&dep[to]==dep[u]+1)
        {
            int d=dinic(to,min(f,e[i].cap));
            if(d>0)
            {
                e[i].cap-=d;
                e[i^1].cap+=d;
                flow+=d;
                f-=d;
                if(!f)break;
            }
        }
    }
    return flow;
}
int maxflow()
{
    int mf=0;
    while(bfs())
    {
        memcpy(cur,head,sizeof(head));
        while(1)
        {
            int f=dinic(s,inf); 
            if(f==0)break;
            mf+=f;
        }
    }
    return mf;
}
void init()
{
    memset(e,0,sizeof(e));
    memset(head,0,sizeof(head));
    size=1;
    for(int i=1;i<=n;i++)
    addedge(s,i,1);
    for(int j=1;j<=m;j++)
    addedge(n+j,t,1);
}
bool judge(int mid)
{
    init();
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
      {
      	if(mapn[i][j]<=mid)
      	addedge(i,j+n,1);
      }
    if(maxflow()>=n-k+1)return true;
    return false;
}
int main()
{
    n=read(),m=read(),k=read();
    s=0,t=n+m+1;
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
      mapn[i][j]=read();
    int l=0,r=1e9;
    while(l<=r)
    {
    	int mid=(l+r)>>1;
    	if(judge(mid))r=mid-1;
    	else l=mid+1;	
    }
    printf("%d",l);
    return 0;
} 
```


---

## 作者：starseven (赞：0)

[题面](https://www.luogu.com.cn/problem/P4251)


我们先看一道例题：

[P1129 [ZJOI2007]矩阵游戏](https://www.luogu.com.cn/problem/P1129)

这道例题是二分图的入门题当中的难题（对我来说），当时我在机房和以为同学讨论了一晚上才懂，哈哈哈。


#### 游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。

我们一看，对角线均为黑色，好吧，我讲不清楚，但是你看了我讲的之后可以看看讲懂我的题解。

我们看得出来无论怎么交换都不会影响行和列的黑子有矛盾，就是重合，所有就将每行和每列连边，然后跑二分图匹配（说实在话，我觉得例题对于二分图的思维难度都比这道题高……）

现在给大家看看讲懂我的[博客](https://www.luogu.com.cn/blog/sswcdak/solution-p1129)

这个是[俾斯麦](https://www.luogu.com.cn/user/119937)（洛谷名）的，如有侵权，作者将及时删除。

现在我们看这道题

#### 其中任意两个数都不能在同一行或者同一列。

这就是裸题了啊！我们就直接每一次每行和每列连边，当然，因为我们要求答案，发现不能直接求出，所以考虑二分答案，因此我们连的边必须是小于等于我们二分出来的东西，因此我们就每次清零一次，就可以了。

现在贴代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>

using namespace std;
const int MAXN = 255;

inline int rd(){
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)) {f=ch=='-'?0:1;ch=getchar();}
    while(isdigit(ch))  {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
    return f?x:-x;
}

int n,m,k,w[MAXN*MAXN];
int a[MAXN][MAXN],tot,ans,now;
int head[MAXN*MAXN],cnt;
int vis[MAXN*MAXN],num,match[MAXN*MAXN];
int to[MAXN*MAXN<<1],nxt[MAXN*MAXN<<1];

inline void add(int bg,int ed){
    to[++cnt]=ed,nxt[cnt]=head[bg],head[bg]=cnt;
}

bool dfs(int x){
    for(register int i=head[x];i;i=nxt[i]){
        int u=to[i];
        if(vis[u]!=num){
            vis[u]=num;
            if(!match[u] || dfs(match[u])){
                match[u]=x;
                return true;
            }
        }
    }
    return false;
}

inline bool check(int Mid){
    memset(head,0,sizeof(head));
    memset(match,0,sizeof(match));
    ans=cnt=0;
    for(register int i=1;i<=n;i++)
        for(register int j=1;j<=m;j++)  
            if(a[i][j]<=Mid) add(i,j);
    for(register int i=1;i<=n;i++){
        num++;
        if(dfs(i)) ans++;
    }
    if(ans>n-k) return true;
    return false;
}

int main(){
    n=rd(),m=rd(),k=rd();
    for(register int i=1;i<=n;i++)
        for(register int j=1;j<=m;j++){
            a[i][j]=rd();
            w[++tot]=a[i][j];
        }
    sort(w+1,w+1+tot);
    int l=1,r=tot,mid;
    while(l<=r){
        mid=l+r>>1;
        if(check(w[mid])) {
            now=mid;
            r=mid-1;
        }
        else l=mid+1;
    }cout<<w[now]<<endl;
    return 0;
}

```

---


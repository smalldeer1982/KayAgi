# [CTSC2018] 混合果汁

## 题目描述

小 R 热衷于做黑暗料理，尤其是混合果汁。

商店里有 $n$ 种果汁，编号为 $0,1,\cdots,n-1$ 。$i$ 号果汁的美味度是 $d_i$，每升价格为 $p_i$。小 R 在制作混合果汁时，还有一些特殊的规定，即在一瓶混合果汁中，$i$ 号果汁最多只能添加 $l_i$ 升。

现在有 $m$ 个小朋友过来找小 R 要混合果汁喝，他们都希望小 R 用商店里的果汁制作成一瓶混合果汁。其中，第 $j$ 个小朋友希望他得到的混合果汁总价格不大于 $g_j$，体积不小于 $L_j$。在上述这些限制条件下，小朋友们还希望混合果汁的美味度尽可能地高，一瓶混合果汁的美味度等于所有参与混合的果汁的美味度的最小值。请你计算每个小朋友能喝到的最美味的混合果汁的美味度。

## 说明/提示

对于所有的测试数据，保证 $n, m \le 100000$，$1 \le d_i,p_i,l_i \le 10^5$，$1 \le g_j, L_j \le 10^{18}$。

测试点编号|$n=$|$m=$|其他限制
-|-|-|-
$1,2,3$|$10$|$10$|无
$4,5,6$|$500$|$500$|无
$7,8,9$|$5000$|$5000$|无
$10,11,12$|$100000$|$100000$|$p_i=1$
$13,14,15$|$100000$|$100000$|$l_i=1$
$16,17,18,19,20$|$100000$|$100000$|无

## 样例 #1

### 输入

```
3 4
1 3 5
2 1 3
3 2 5
6 3
5 3
10 10
20 10```

### 输出

```
3
2
-1
1```

# 题解

## 作者：Kelin (赞：29)

## [题意](https://blog.csdn.net/benoble_/article/details/80315131)

$n$种果汁$,$第$i$种果汁的美味程度是$d_i,$有$l_i$升$,$价格是$p_i/$升

$m$个询问$,$要求使用果汁的总量不小于$Lim,$价格不超过$G,$最大化所用的果汁的美味程度最小值

---

先开最简单的题

似乎好久没写$Blog$了$($大雾

---

## 题解

首先把$d$排序$,$枚举一个答案$d,$那么我们肯定是贪心地选择美味程度不小于$d$的并且最便宜的果汁

可以发现其具有单调性$,$考虑二分一个$d,$给美味程度不小于$d$的果汁建立一颗以价格为下标的线段树

每个节点记录一下果汁总量和价格和$,$这样就可以在线段树上二分得到$Lim$对应的价格了

然后这个线段树是可以对$d$进行可持久化的

复杂度$O(n\log^2n)$

```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){return A==B&&(B=(A=ss)+fread(ss,1,1<<17,stdin),A==B)?-1:*A++;}
template<class T>inline void sd(T&x){
    char c;T y=1;while(c=gc(),(c<48||57<c)&&c!=-1)if(c==45)y=-1;x=c-48;
    while(c=gc(),47<c&&c<58)x=x*10+c-48;x*=y;
}
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
template<class T>inline void we(T x){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
const int N=1e5+5,M=1e5;
typedef int arr[N];
typedef long long ll;
struct Juice{
    int d,p,l;
    inline void init(){sd(d),sd(p),sd(l);}
    inline bool operator<(const Juice b){return d<b.d;}
}a[N];
struct Pt{int l,r;ll s,w;}tr[N*20];
int n,m,pt;arr T;
void ins(int&p,int L,int R,int x,int s,ll w){
    tr[++pt]=tr[p],p=pt;tr[p].s+=s,tr[p].w+=w;
    if(L==R)return;int mid=(L+R)>>1;
    if(x<=mid)ins(tr[p].l,L,mid,x,s,w);
    else ins(tr[p].r,mid+1,R,x,s,w);
}
ll qry(int p,int L,int R,ll s){
    if(L==R)return s*L;int mid=(L+R)>>1;
    if(s<=tr[tr[p].l].s)return qry(tr[p].l,L,mid,s);
    return tr[tr[p].l].w+qry(tr[p].r,mid+1,R,s-tr[tr[p].l].s);
}
inline int sol(){
    ll G,Lim;sd(G),sd(Lim);
    if(Lim>G)return -1;
    int L=0,R=M,mid,tp=0;
    while(L<=R){
        mid=(L+R)>>1;
        if(Lim<=tr[T[mid]].s&&qry(T[mid],0,M,Lim)<=G)tp=mid,L=mid+1;
        else R=mid-1;
    }return a[tp].d;
}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    sd(n),sd(m);a[0].d=-1;
    fp(i,1,n)a[i].init();
    sort(a+1,a+n+1);
    fd(i,n,1)ins(T[i]=T[i+1],0,M,a[i].p,a[i].l,(ll)a[i].p*a[i].l);
    T[0]=T[1];while(m--)we(sol());
return Ot(),0;
}
```

---

## 作者：kouylan (赞：28)

## 题解 P4602 【[CTSC2018]混合果汁】

[洛谷题面传送门](https://www.luogu.com.cn/problem/P4602)

一眼就能看出，这道题可以二分答案。

假设二分出的果汁最小美味值是 $m$，则我们只要考虑美味值 $d_i\geq m$ 的果汁即可。所以我们想到把果汁按照 $d_i$ 排序，这样每次就不用一个一个枚举。

接下来我们就要想怎么 $\mathrm{check}$ 就好了。贪心的想，我们就按照价格 $p_i$ 从小往大取，肯定是最优的。

所以关键问题是价格，再看数据范围，只够我们再加一个 $\mathrm{logn}$，那我们就能想到根据价格建立权值线段树，又因为我们要查询的都是区间，把它优化成主席树，就会方便许多。

现在，我们想如何按照我们的贪心思路在主席树上查询。假设我们现在在节点 $o$ 上，我们肯定优先先往左子树走，因为左子树对应的价格更小嘛。但我们还要保证果汁数量要 $\geq L$。所以，这个问题就有点类似于区间第 $k$ 小的问题。如果左子树中的果汁数量 $\gep L$，我们就去左子树找；反之，我们要取完左子树的所有果汁，并把剩下的果汁带到右子树中找就行了。

因此，我们在主席树中就要存两个信息。一是对应区间的果汁数量，而是对应区间果汁全取的价格。

最后，贪心取出的价格如果 $\leq g$，并且果汁数量 $\geq L$，就是合法的。

下面是 AC 代码

```cpp
/*
luogu P4602
*/
#include <bits/stdc++.h>
using namespace std;

#define int long long
#define mid (l+r>>1)

const int N = 1e5;

int n,q,ans;
struct juice{
	int d,p,m;
	bool operator < (const juice b) const
	{
		return d>b.d;
	}
}a[100005];
int cnt,root[100005];
struct hjtree{
	int l,r,s,sum;
}t[100005<<6];

void insert(int &o,int pre,int l,int r,int x,int v)
{
	o = ++cnt;
	t[o] = t[pre];
	t[o].s += v, t[o].sum += x*v;
	if(l==x && r==x)
		return;
	if(x<=mid)
		insert(t[o].l,t[pre].l,l,mid,x,v);
	else
		insert(t[o].r,t[pre].r,mid+1,r,x,v);
}

int query(int o,int l,int r,int k)
{
	if(l==r)
		return l*k;
	if(t[t[o].l].s>=k)
		return query(t[o].l,l,mid,k);
	else
		return t[t[o].l].sum+query(t[o].r,mid+1,r,k-t[t[o].l].s);
}

signed main()
{
	cin>>n>>q;
	for(int i=1;i<=n;cin>>a[i].d>>a[i].p>>a[i].m,i++);
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++)
		insert(root[i],root[i-1],1,N,a[i].p,a[i].m);
	while(q--)
	{
		int g,lim;
		cin>>g>>lim;
		ans = -1;
		int l=1,r=n;
		while(l<=r)
		{
			int res=query(root[mid],1,N,lim);
			if(res<=g && t[root[mid]].s>=lim)
				ans = mid, r = mid-1;
			else
				l = mid+1;
		}
		cout<<(ans==-1 ? -1 : a[ans].d)<<endl;
	}
}
```

祝大家 AC 愉快！

---

## 作者：Marser (赞：19)

似乎没有思路一样的题解，那么就来冒个泡吧！

### 题意
有 $ N $ 种物品，每种各有 $l_i $ 件，单价为 $ p_i $ 元，单件美味度为 $ d_i $。给出 $ M $ 个询问，每次询问用至多 $ g_i $ 元且买到 $ L_i $ 件物品的情况下，所有物品的最小美味度最大能为多少。
### 前置姿势

整体二分，一个比较好用的小tips。

整体二分指的是对于单个询问可以用二分答案解决的问题，将所有的询问放在一起二分的方法。如果不理解的话，可以先去看看P1527。
### 题解

首先考虑一下单个询问应该如何解决。我们将所有物品按 $ d_i $ 排序，二分答案。每次 $ check $ 的时候贪心地选择 $ d_j \ge mid $ 且 $ p_j $ 最小的物品，直到达成要求或余额不足为止。

考虑以单价为下标建出线段树，每个节点保存该节点表示的单价区间中所有物品的件数之和以及该区间中物品的总价。这样，每次单独二分答案的时候，将所有的可选物品插入线段树，就可以转化为在线段树上二分进行 $ check $ 。

转换为整体二分的时候，考虑维护一棵全局线段树，每次根据当前的限制调整线段树中存储的节点，就可以解决这一题了。一些细节可以参考代码实现。
### Code

码风丑陋，望轻喷。
```cpp
#include<bits/stdc++.h>
#define reg register
using namespace std;
typedef long long ll;
const int MN=1e5;
const int inf=0x3f3f3f3f;
struct data{//物品 
	int val,p,lim;
	friend bool operator<(data a,data b){return a.val>b.val;}
}a[MN+5];
struct ask{int id;ll p,v;}q[MN+5],t1[MN+5],t2[MN+5];//询问 
int n,m,cur,ans[MN+5];
//线段树 
ll tr[MN+5<<2],pri[MN+5<<2];
#define mid (l+r>>1)
#define ls (t<<1)
#define rs (t<<1|1)
inline void pushup(int t){tr[t]=tr[ls]+tr[rs];pri[t]=pri[ls]+pri[rs];}
void update(int t,int l,int r,int pos,int v){//更新节点 
	if(l==r){tr[t]+=v;pri[t]=1ll*l*tr[t];return;}
	if(pos<=mid)update(ls,l,mid,pos,v);
	else update(rs,mid+1,r,pos,v);pushup(t);
}
ll query(int t,int l,int r,ll v){//线段树上二分 
	if(!v)return 0;//余额不足，当前情况无解 
	if(l==r)return v*l;//区间长度为1，直接返回 
	if(tr[ls]>=v)return query(ls,l,mid,v);//左半边不能取完 
	return pri[ls]+query(rs,mid+1,r,v-tr[ls]);//左半边可以取完 
}
void solve(int l,int r,int a,int b){//整体二分 
	if(l>r||a>b)return;reg int cnt1=0,cnt2=0;
	if(l==r){for(reg int i=a;i<=b;i++)ans[q[i].id]=::a[l].val;return;}//得到答案 
	while(cur<mid)cur++,update(1,1,MN,::a[cur].p,::a[cur].lim);
	while(cur>mid)update(1,1,MN,::a[cur].p,-::a[cur].lim),cur--;//调整物品 
	for(reg int i=a;i<=b;i++)//对于每个物品check 
		if(q[i].v>tr[1])t2[++cnt2]=q[i];
		else if(query(1,1,MN,q[i].v)<=q[i].p)t1[++cnt1]=q[i];
		else t2[++cnt2]=q[i];
	for(reg int i=1;i<=cnt1;i++)q[i+a-1]=t1[i];
	for(reg int i=1;i<=cnt2;i++)q[i+a+cnt1-1]=t2[i];//将询问分到两边 
	solve(l,mid,a,a+cnt1-1);solve(mid+1,r,a+cnt1,b);//下一层二分 
}
int main(){
	scanf("%d%d",&n,&m);
	for(reg int i=1;i<=n;i++)scanf("%d%d%d",&a[i].val,&a[i].p,&a[i].lim);
	for(reg int i=1;i<=m;i++)scanf("%lld%lld",&q[i].p,&q[i].v),q[i].id=i;
	a[++n]=(data){-1,0,inf};//添加一种无意义的物品来处理无解 
	sort(a+1,a+1+n);solve(1,n,1,m);
	for(reg int i=1;i<=m;i++)printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：Kewth (赞：15)

哪来这么多事，这题数据结构用两个普通的树状数组就行了。

首先对于每个询问答案是可以二分的，但是每个询问二分的 check 都是线性的。  
考虑 check 的本质，实际就是在美味度不小于 mid 的果汁中按价格从低到高选到体积满足要求。  
假设把美味度满足要求的果汁按价格排序，那么选的一定是段连续区间，  
那么维护前缀和后可以二分来 check ，瓶颈在于排序和前缀和预处理。

**整体二分**可以做到一边二分答案一边维护 check 所需要的信息。  
假设当前在二分答案 [L, R] ，此时已经将美味度超过 R 的提出来存进了数据结构，  
姑且认为在这个数据结构里果汁按价格排好了序且维护好了前缀和信息。  
设 M = (L + R + 1) / 2 ，那么将美味度在 [M, R] 的果汁扔进该数据结构就可以了。

这个数据结构实际上树状数组就可以了，以价格为下标。

代码：

```cpp
#include <cstdio>
#include <algorithm>
#define debug(...) fprintf(stderr, __VA_ARGS__)

typedef long long lolong;
inline int input() { int x; scanf("%d", &x); return x; }
inline lolong linput() { lolong x; scanf("%lld", &x); return x; }

const int maxn = 100005;

struct Juice {
	int d, p, l;
};
Juice ju[maxn];

lolong qg[maxn], ql[maxn];
int ans[maxn];
int shit[maxn], shit_l[maxn], shit_r[maxn];
lolong bit_p[maxn], bit_l[maxn];

inline void add(int p, int l, int typ) {
	for(int k = p; k < maxn; k += k & -k) {
		bit_p[k] += 1ll * p * l * typ;
		bit_l[k] += l * typ;
	}
}

inline lolong query_p(int p) {
	lolong res = 0;
	for(int k = p; k; k -= k & -k)
		res += bit_p[k];
	return res;
}

inline lolong query_l(int p) {
	lolong res = 0;
	for(int k = p; k; k -= k & -k)
		res += bit_l[k];
	return res;
}

bool cmp(Juice a, Juice b) {
	return a.d < b.d;
}

void solve(int l, int r, int L, int R) {
	if(L == R) {
		for(int i = l; i <= r; i ++)
			ans[shit[i]] = ju[L].d;
		add(ju[L].p, ju[L].l, 1);
		return;
	}

	int M = (L + R + 1) >> 1;

	for(int i = M; i <= R; i ++)
		add(ju[i].p, ju[i].l, 1);

	int lp = 0, rp = 0;

	for(int i = l; i <= r; i ++) {
		int id = shit[i];

		int ll = 0, rr = maxn - 1;
		while(ll < rr) {
			int mid = (ll + rr) >> 1;
			if(query_l(mid) >= ql[id])
				rr = mid;
			else
				ll = mid + 1;
		}

		lolong now_l = query_l(ll), now_p = query_p(ll);
		if(now_l >= ql[id] and now_p - (now_l - ql[id]) * ll <= qg[id])
			shit_r[++ rp] = id;
		else
			shit_l[++ lp] = id;
	}

	for(int i = 1; i <= lp; i ++)
		shit[l + i - 1] = shit_l[i];
	for(int i = 1; i <= rp; i ++)
		shit[l + lp + i - 1] = shit_r[i];

	for(int i = M; i <= R; i ++)
		add(ju[i].p, ju[i].l, -1);

	solve(l + lp, r, M, R);
	solve(l, l + lp - 1, L, M - 1);
}

int main() {
	int n = input(), q = input();

	for(int i = 1; i <= n; i ++) {
		ju[i].d = input();
		ju[i].p = input();
		ju[i].l = input();
	}

	ju[0].d = -1;
	ju[0].p = 1;
	ju[0].l = 1;

	std::sort(ju, ju + n + 1, cmp);

	for(int i = 1; i <= q; i ++) {
		qg[i] = linput();
		ql[i] = linput();
		shit[i] = i;
	}

	solve(1, q, 0, n);

	for(int i = 1; i <= q; i ++)
		printf("%d\n", ans[i]);
}
```

---

## 作者：未来姚班zyl (赞：7)

## 题目大意

现在有 $n$ 种牌子的果汁，每种有三个元素：美味度 $d_{i}$，每升的价格 $p_{i}$，体积的限制 $l_{i}$。有 $m$ 位小朋友要来点混合果汁，要求总价格小于等于 $g_{i}$，总体积大于等于 $L_{i}$，求每个小朋友能配出的最低美味度最高的饮料。

## 题目分析

这一题的中心思想题解区的 dl 们已经总结的很详尽了，采用整体二分以及贪心的思想，按照美味度二分答案，然后在美味度大于 $mid$ 的果汁中优先选择价格低的。

就是在维护这样一个果汁信息的过程中很多人采用了比较绕的想法以及稍微高级的数据结构。然而，一种非常朴素的想法也可以通过此题。

我们完全可以在整体二分前将操作按照价格从小到大排序，并把所有果汁的信息加入两个树状数组——一个维护体积，一个维护体积乘单价（即加满的总价）这样保证了可以用前缀处理。

在整体二分的过程中，只要把美味度小于等于 $mid$ 的果汁从树状数组当中删掉就可以了。这样树状数组中剩下的就全是美味度大于 $mid$ 的果汁了。遇到询问就可以直接在树状数组上二分。在进入递归进入右区间之前保留删除，处理完右区间后再恢复左区间的信息，再递归进入左区间就行了。

这样就不需要请出线段树，主席树，平衡树和各种高深的技巧，用 $O((n+m){log}^{2}{(n+m)})$ 的复杂度过掉这题。只是这种做法的两支 $log$ 是会跑满的，会慢一些。缺点是慢，优点是想法朴素，代码实现简洁。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e5+5;
int n,m,ans[N],tmp,maxd;
struct node{ll opt,q,w,v,id,p;}q[N*2],lq[N*2],rq[N*2];//p是修改在树状数组中的编号 
ll s[N*2],fs[N*2],val[N*2];//s是体积的树状数组，fs是花费的树状数组，val是该果汁的单价 
int lowbit(int x){return x&(-x);}
void add(int x,ll k){
	while(x<=tmp)s[x]+=k,x+=lowbit(x);
}
ll query(int x){
	if(!x)return 0;
	ll ans=0;
	while(x)ans+=s[x],x-=lowbit(x);return ans;
}
void Add(int x,ll k){while(x<=tmp)fs[x]+=k,x+=lowbit(x);}
ll Query(int x){if(!x)return 0;ll ans=0;while(x)ans+=fs[x],x-=lowbit(x);return ans;}
inline ll read(){ll s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57) s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
void solve(int l,int r,int L,int R){
	if(l>r)return;
	if(L==R){
		for(int i=l;i<=r;i++)if(q[i].opt==2&&L)ans[q[i].id]=L;
		return;
	}
	int mid=(L+R>>1),cntl=0,cntr=0;
	for(int i=l;i<=r;i++)
		if(q[i].opt==1){
			if(q[i].q<=mid)lq[++cntl]=q[i],add(q[i].p,-q[i].v),Add(q[i].p,-q[i].w*q[i].v);//美味度小于等于mid，从树状数组中删除 
			else rq[++cntr]=q[i];
		}
	for(int i=l;i<=r;i++){
		if(q[i].opt==2){
			int lL=1,rr=tmp,as=0;//贪心，在树状数组中二分 
			while(lL<=rr){
				int md=(lL+rr>>1);
				if(query(md)>=q[i].v)as=md,rr=md-1;
				else lL=md+1;
			}
			if(as==0)lq[++cntl]=q[i];
			else {//检查花费 
				ll delta=q[i].v-query(as-1),cost=Query(as-1)+delta*val[as];
				if(cost<=q[i].w)rq[++cntr]=q[i];
				else lq[++cntl]=q[i];
			}
		}
	}
	for(int i=l;i<=l+cntl-1;i++)q[i]=lq[i-l+1];
	for(int i=l+cntl;i<=r;i++)q[i]=rq[i-cntl-l+1];
	solve(l+cntl,r,mid+1,R);//先处理右区间 
	for(int i=l;i<=l+cntl-1;i++)if(q[i].opt==1)add(q[i].p,q[i].v),Add(q[i].p,q[i].v*q[i].w);//恢复信息 
	solve(l,l+cntl-1,L,mid);//再处理左区间 
}
bool cmp(node a,node b){
	return a.w<b.w;
}//按照价格排序 
int main(){
	cin >> n >> m;
	for(int i=1,x,y,z;i<=n;i++)x=read(),y=read(),z=read(),maxd=max(maxd,x),q[++tmp]=node{1,x,y,z,0,0};
	for(int i=1;i<=m;i++){ll x=read(),y=read();q[++tmp]=node{2,0,x,y,i,0};}
	sort(q+1,q+tmp+1,cmp);
	for(int i=1;i<=tmp;i++)q[i].p=i,val[i]=q[i].w;
	for(int i=1;i<=tmp;i++)if(q[i].opt==1)add(i,q[i].v),Add(i,q[i].v*q[i].w);//二分前，将所有信息加入树状数组 
	memset(ans,-1,sizeof(ans)),solve(1,tmp,0,maxd);
	for(int i=1;i<=m;i++)printf("%d\n",ans[i]);
	return 0;
}
```


---

## 作者：Great_Influence (赞：7)

来发一个不同的。

## 整体二分

观察可以发现，答案明显具有单调性。但是一个个来二分的话，时间复杂度为$O(n^2log^2n)$的，明显无法通过此题。所以考虑整体二分，时间复杂度降为$O(nlog^2n)$，可以通过此题。

注意一下，每次都将左端点到最右边排序的话，时间复杂度会变成$O(n^2log^2n)$，直接挂成$60pts$。考虑用一个$multiset$维护果汁，时间复杂度可以保证。

代码:

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
#define For(i,a,b) for(i=(a),i<=(b);++i)
#define Forward(i,a,b) for(i=(a),i>=(b);--i)
template<typename T>inline void read(T &x)
{
    T f=1;x=0;char c;
    for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;
    for(;isdigit(c);c=getchar())x=x*10+(c^48);
    x*=f;
}
using namespace std;
void file()
{
#ifndef ONLINE_JUDGE
    freopen("water.in","r",stdin);
    freopen("water.out","w",stdout);
#endif
}

const int MAXN=1e5+7;

static int n,m;

static struct juice
{
    int d;
    long long p,l;
}p[MAXN];

inline bool cmp1(juice a,juice b){return a.d<b.d;}

static struct boy
{
    long long g,l;
    int id;
}q[MAXN],ret[MAXN];

inline bool cmp2(boy a,boy b){return a.g<b.g;}

inline void init()
{
    read(n);read(m);
    Rep(i,1,n)read(p[i].d),read(p[i].p),read(p[i].l);
    p[n+1].d=-1;p[n+1].p=0;p[n+1].l=1e18;++n;
    sort(p+1,p+n+1,cmp1);
    Rep(i,1,m)read(q[i].g),read(q[i].l),q[i].id=i;
}

static int ans[MAXN],pos;

typedef pair<long long,int>Pr;

static multiset<Pr>K;

static multiset<Pr>::iterator it;

void div(int l,int r,int x,int y)
{
    if(x>y)return;
    if(l==r){Rep(i,x,y)ans[q[i].id]=p[l].d;return;}
    static int mid,lp,rp;mid=(l+r)>>1,lp=x,rp=y;
    static long long sm,cost;sm=0,cost=0;
    sort(q+x,q+y+1,cmp2);
    while(pos>mid+1)--pos,K.insert(Pr(p[pos].p,p[pos].l));
    while(pos<mid+1)K.erase(K.lower_bound(Pr(p[pos].p,p[pos].l)))
        ,++pos;
    it=K.begin();
    Rep(i,x,y)
    {
        while(it!=K.end()&&cost+it->first*it->second<=q[i].g)
            cost+=it->first*it->second,sm+=it->second,++it;
        //cerr<<sm<<' '<<cost<<' '<<q[i].l<<' '<<q[i].g<<endl;
        if(q[i].l<=sm||it!=K.end()
            &&sm+(q[i].g-cost)/it->first>=q[i].l)
                ret[rp--]=q[i];
        else ret[lp++]=q[i];
    }
    Rep(i,x,y)q[i]=ret[i];
    div(mid+1,r,lp,y);
    div(l,mid,x,lp-1);
}

inline void solve()
{
    pos=n+1;div(1,n,1,m);
    Rep(i,1,m)printf("%d\n",ans[i]);
}

int main()
{
    file();
    init();
    solve();
    //cerr<<1.0*clock()/CLOCKS_PER_SEC<<endl;
    return 0;
}


```

---

## 作者：Fading (赞：6)

好题啊~~差点就做出来了没想到排序而已~~

显然的二分，二分最大美味值。

然后就会发现一个有趣的事情：

对于一个二分的答案$d$，只要取$\geq d\ $的果汁就可以了

这里显然就有一个贪心：优先选择美味度$\geq d\ $且价格最小的果汁

问题是怎么快速找到我们要的最小价格果汁呢？

这里还有一个重要的限制，就是选择的果汁美味度必须$\geq  d$

最小价格果汁选完就要选择次小，次次小……我们需要一个数据结构来记录所有价格的果汁？？？

现在就明显了——权值线段树。建立一棵以价格为下标的权值线段树

但是$\geq d$ 怎么办呢$\text{QAQ}$

~~然后我就不会了~~

后来~~打开题解~~发现可以把权值线段树可持久化，变成一棵主席树！！！

什么意思呢？

先把所有果汁按照美味度$d$排个序，然后顺序插入主席树

我们对于每一个节点记录此价格区间内所有果汁的体积总和以及购买这些果汁的价格和。

因为答案的美味度这个数值必定出现在一种果汁里，所以我们每一次二分一个答案所在果汁的位置$mid$。

满足条件的果汁组成的权值线段树就是

$[\ root[mid-1],root[n]\ ]$

直接二分计算最小答案(类似区间第$k$小)就好了！

当你二分到一个节点是时，计算这个节点左子树可以提供的所有体积。如果这些体积够用了则递归进入左子树继续更新（贪心），否则全部购买，进入右子树继续更新。

怎么判断答案是否满足条件呢？

算出最小凑齐$L$体积的花费，判断是否 $\leq G$ 即可

当然如果这些果汁总体积小于$L$的话也是不满足的，需要特判。

如果还是有点不理解的话可以看看代码

代码如下：

```
#include<bits/stdc++.h>
#define maxn 100005
#define ll long long
using namespace std;
inline ll read(){
    ll x=0,f=1;char ch=getchar();
    while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();};
    while (isdigit(ch)){x=(x<<1)+(x<<3)+ch-48;ch=getchar();};
    return x*f; 
}
struct juice{
    ll d,p,l;
}x[maxn];
inline bool cmp(juice a,juice b){
    return a.d<b.d;
}
int n,m,root[maxn],cnt;
struct node{
    int l,r;
    ll lit,W;//lit记录区间总体积，W记录购买这些体积的价格
}g[maxn*21];
void update(int &rt,int lb,int rb,ll P,ll LIT){//LIT表示加入的体积，P表示价格
    g[++cnt]=g[rt];rt=cnt;g[rt].lit+=LIT;g[rt].W+=P*LIT;//主席树部分
    if (lb==rb) return;
    int mid=lb+rb>>1;
    if (mid>=P) update(g[rt].l,lb,mid,P,LIT);
    else update(g[rt].r,mid+1,rb,P,LIT);
}
ll query(int i,int j,int lb,int rb,ll LIT){
    if (lb==rb) return 1LL*LIT*lb;
    int mid=lb+rb>>1;ll TOT=g[g[j].l].lit-g[g[i].l].lit;//左子树的所有体积，如果这些体积够用了递归进入左子树（贪心），否则全部购买，进入右子树继续更新
    if (TOT>=LIT) return query(g[i].l,g[j].l,lb,mid,LIT);
    return g[g[j].l].W-g[g[i].l].W+query(g[i].r,g[j].r,mid+1,rb,LIT-TOT);
}
signed main(){
    n=read(),m=read();
    ll MAXP=0;//最大价格，作为主席树下标
    for (int i=1;i<=n;i++){
        x[i].d=read(),x[i].p=read(),x[i].l=read();
        MAXP=max(MAXP,x[i].p);
    }
    sort(x+1,x+1+n,cmp);//排序
    for (int i=1;i<=n;i++){
        root[i]=root[i-1];
        update(root[i],1,MAXP,x[i].p,x[i].l);
    }
    while (m--){
        ll G=read(),L=read();
        ll lb=1,rb=n,ans=-1;
        while (lb<=rb){
            ll mid=lb+rb>>1;
            if (query(root[mid-1],root[n],1,MAXP,L)<=G&&g[root[n]].lit-g[root[mid-1]].lit>=L){//二分条件
                lb=mid+1;ans=mid;
            }else{
                rb=mid-1;
            }
        }
        if (ans==-1) printf("-1\n");
        else printf("%lld\n",x[ans].d);
    }
}
```

---

## 作者：lhm_ (赞：5)

注意到问题具有单调性，所以一个询问可以通过二分答案来解决。

对于多组询问，就采用整体二分来处理。

将果汁按$d$从大到小排序，二分出一个位置$mid$，只考虑在位置$mid$之前的果汁，其中位置$mid$的果汁的$d$即为二分出的所有参与混合的果汁的美味度的最小值。

在判断一个$mid$合不合法时，将其之前所有果汁的体积的前缀和和各自的体积乘价格前缀和处理出来，后者就是买下所有果汁的价格。

然后对于一个询问，再进行一次二分，找到最小的价格来满足其体积的需求，然后就可以判断一个$mid$是否合法了。

对于前缀和的操作，可以通过树状数组来实现，随着$mid$的改变调整即可。

具体实现细节看代码吧。

$code$

```cpp
#include<bits/stdc++.h>
#define maxn 200010
#define inf 1000000000000000000
#define lowbit(x) (x&(-x))
using namespace std;
typedef long long ll;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
ll n,m,now,ma;
ll ans[maxn];
struct node
{
    ll d,p,l;
}t[maxn];
bool cmp(const node &a,const node &b)
{
    return a.d>b.d;
}
struct query
{
    ll g,l;
    int id;
}q[maxn],q1[maxn],q2[maxn];
struct Tree
{
    ll tr[maxn];
    void update(int x,ll v)
    {
        while(x<=ma)
            tr[x]+=v,x+=lowbit(x);
    }
    ll query(int x)
    {
        ll sum=0;
        while(x)
            sum+=tr[x],x-=lowbit(x);
        return sum;
    }
}Li,Pr;
void change(int x,int type)
{
    Li.update(t[x].p,type*t[x].l),Pr.update(t[x].p,type*t[x].p*t[x].l);
}
ll find(int x)
{
    int l=1,r=ma,pr=ma;
    while(l<=r)
    {
        int mid=(l+r)>>1;
        if(Li.query(mid)>=q[x].l) pr=mid,r=mid-1;
        else l=mid+1;
    }
    return pr;
}
void solve(int L,int R,int l,int r)
{
    if(L>R) return;
    if(l==r)
    {
        for(int i=L;i<=R;++i) ans[q[i].id]=t[l].d;
        return;
    }
    int mid=(l+r)>>1;
    while(now<mid) change(++now,1);
    while(now>mid) change(now--,-1);
    int cnt1=0,cnt2=0;
    for(int i=L;i<=R;++i)
    {
        ll pr=find(i),lv=Li.query(pr),pv=Pr.query(pr);
        if(lv>=q[i].l&&pv-pr*(lv-q[i].l)<=q[i].g) q1[++cnt1]=q[i];
        else q2[++cnt2]=q[i];
    }
    for(int i=1;i<=cnt1;++i) q[L+i-1]=q1[i];
    for(int i=1;i<=cnt2;++i) q[L+cnt1+i-1]=q2[i];
    solve(L,L+cnt1-1,l,mid),solve(L+cnt1,R,mid+1,r);
}
int main()
{
    read(n),read(m);
    for(int i=1;i<=n;++i)
        read(t[i].d),read(t[i].p),read(t[i].l),ma=max(ma,t[i].p);
    t[++n].d=-1,t[n].p=1,t[n].l=inf,sort(t+1,t+n+1,cmp);
    for(int i=1;i<=m;++i) read(q[i].g),read(q[i].l),q[i].id=i;
    solve(1,m,1,n);
    for(int i=1;i<=m;++i) printf("%lld\n",ans[i]);
    return 0;
}
```

---

## 作者：_ctz (赞：4)

[安利波$blog$](https://ctz45562.github.io/2019/03/17/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P4602-%E3%80%90-CTSC2018-%E6%B7%B7%E5%90%88%E6%9E%9C%E6%B1%81%E3%80%91/)

[传送门](https://www.luogu.org/problemnew/show/P4602)

都说是$CTSC2018$最水的题。。。还是太蒻了想了很长时间。。。$QAQ$


考虑一下朴素的解法：

对$d_i$排序，对$d_i$二分答案。因为答案取的是最小值，所以比它大的随便加。$d_i$越小能加的范围就越大，答案具有单调性，因此可以二分。然后尽可能把所有较小的$p_i$加上，看看加到最大后$\sum l_i$是否满足，以此判断二分范围。

复杂度$O(n^2logn)$

瓶颈在于选取尽可能多得选取较小的$p_i$。可以发现它能用主席树维护。首先按$p_i$排序，获取每种果汁$p_i$的排名；再按$d_i$排序，依次按照$p_i$的排名插入主席树，每个节点维护一下$\sum p_i*l_i$（把这些果汁全加上的价格）和$\sum l_i$（这些果汁的总容量）。

查询时，尽可能把左儿子选上，也就是只要$\sum p_i*l_i \le g_j$就把总容量加上$\sum l_i$，$g_j$减去$\sum p_i*l_i$，走右儿子。当然可能出现递归到叶子节点，剩余的$g_j$不足以全加上这种果汁，尽可能多加，即返回$min\{g_j/p_i,l_i\}$。

总之都是基于贪心思想。其他过程还是和开始的做法一样。时间复杂度$O(nlog^2n)$

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

#define maxn 100005
#define inf 0x3f3f3f3f

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
template<typename T>
inline T read(){
	T x=0;
	int y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
int root[maxn];
struct Drink{
	int d,l,num;
	long long p;
}d[maxn];
struct Chairman_Tree{
	int ls[maxn<<5],rs[maxn<<5],cnt;
	long long sum[maxn<<5],con[maxn<<5],p[maxn<<5];
    //sum是li*pi的和，con是li的和，p是叶子节点的pi
#define ls(x) ls[x]
#define rs(x) rs[x]
	void build(int poi,int l,int r,int &node,int ol,long long L,long long P){
		node=++cnt;
		sum[node]=sum[ol]+L*P;
		con[node]=con[ol]+L;
		if(l==r){
			p[node]=P;
			return;
		}
		int mid=l+r>>1;
		if(poi<=mid)rs(node)=rs(ol),build(poi,l,mid,ls(node),ls(ol),L,P);
		else ls(node)=ls(ol),build(poi,mid+1,r,rs(node),rs(ol),L,P);
	}
	long long ask(int l,int r,int node,long long g){
		if(l==r)return node?min((g/p[node]),con[node]):0;
        //空节点注意判断一下，否则会出现除以0的情况
		int mid=l+r>>1;	
		if(sum[ls(node)]>g)return ask(l,mid,ls(node),g);
        //剩下的钱不足以全加上，走左儿子
		else return ask(mid+1,r,rs(node),g-sum[ls(node)])+con[ls(node)];
        //付得起，贪心全加上，走右儿子
	}
}ct;
inline bool cmp1(Drink x,Drink y){
	return x.p<y.p;
}
inline bool cmp2(Drink x,Drink y){
	return x.d>y.d;
}
int main(){
	int n=read(),m=read();
	for(register int i=1;i<=n;++i)
		d[i].d=read(),d[i].p=read<long long>(),d[i].l=read();
	sort(d+1,d+1+n,cmp1);//按pi排序
	for(register int i=1;i<=n;++i)
		d[i].num=i;//获取排名
	sort(d+1,d+1+n,cmp2);//按di排序
	for(register int i=1;i<=n;++i)
		ct.build(d[i].num,1,n,root[i],root[i-1],d[i].l,d[i].p);
    //以pi的排名建树
	int l,r;
	while(m--){
		long long g=read<long long>(),L=read<long long>();
		int ans=-1;
		l=1,r=n;
		while(l<=r){
			int mid=l+r>>1;
			long long k=ct.ask(1,n,root[mid],g);
			if(k>=L)ans=d[mid].d,r=mid-1;
			else l=mid+1;
		}
		printf("%d\n",ans);
	}
}

```



---

## 作者：XenonKnight (赞：3)

[LOJ 题目链接](https://loj.ac/problem/2555) & [洛谷题目链接](https://www.luogu.com.cn/problem/P4602)

> 题意：商店里有 $n$ 杯果汁，第 $i$ 杯果汁有美味度 $d_i$，单价为 $p_i$ 元/升。最多可以添加 $l_i$ 升。有 $m$ 次询问，每次给出两个数 $G,L$，你可以将商店里的一些果汁混合起来，使得他们的总体积不小于 $L$ 升，总价格不超过 $G$ 元，问：选择的果汁中美味度最小值的最大值是多少。

> $1 \leq n,m \leq 10^5$，$1 \leq d_i,p_i,l_i \leq 10^5$

看到这种“最小值最大”的字眼，第一反应应该是二分吧（

将 $d$ 数组排个序，二分出 $mid$，显然我们只能取 $d_i \geq mid$ 的果汁。

根据贪心的策略，我们肯定先取单价最小的果汁，用 $min(l_i,L)$ 升体积做成混合果汁，需要 $p_i \times min(l_i,L)$ 元的代价，如果还有剩余的体积就取单价第二小的果汁，如果还有就取第三小的，以此类推……

然后我就死在了这个地方，还是太菜了啊 qwq（

我们考虑以单价为下标建一棵权值线段树，每个节点上维护两个值，$sum$ 表示价格在 $[l,r]$ 区间中所有果汁的体积之和，$cst$ 表示价格在 $[l,r]$ 中所有果汁的单价与体积的乘积之和。

每次我们从根节点开始，如果 $L$ 不超过左子树的 $sum$ 值，递归左子树，否则答案加上右子树的代价再递归右子树。

由于 $mid$ 值不确定，需要可持久化，时间复杂度 $n\log^2n$。
注意事项：需要判总体积是否 $\geq L$ 升。

最后是代码：

```cpp
//Coded by tzc_wk
/*
数据不清空，爆零两行泪。
多测不读完，爆零两行泪。
边界不特判，爆零两行泪。
贪心不证明，爆零两行泪。
D P 顺序错，爆零两行泪。
大小少等号，爆零两行泪。
变量不统一，爆零两行泪。
越界不判断，爆零两行泪。
调试不注释，爆零两行泪。
溢出不 l l，爆零两行泪。
*/
#include <bits/stdc++.h>
using namespace std;
#define fi			first
#define se			second
#define fz(i,a,b)	for(int i=a;i<=b;i++)
#define fd(i,a,b)	for(int i=a;i>=b;i--)
#define foreach(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)
#define all(a)		a.begin(),a.end()
#define giveup(...) return printf(__VA_ARGS__),0;
#define fill0(a)	memset(a,0,sizeof(a))
#define fill1(a)	memset(a,-1,sizeof(a))
#define fillbig(a)	memset(a,0x3f,sizeof(a))
#define fillsmall(a) memset(a,0xcf,sizeof(a))
#define mask(a)		(1ll<<(a))
#define maskx(a,x)	((a)<<(x))
#define _bit(a,x)	(((a)>>(x))&1)
#define _sz(a)		((int)(a).size())
#define filei(a)	freopen(a,"r",stdin);
#define fileo(a)	freopen(a,"w",stdout);
#define fileio(a) 	freopen(a".in","r",stdin);freopen(a".out","w",stdout)
#define eprintf(...) fprintf(stderr,__VA_ARGS__)
#define put(x)		putchar(x)
#define eoln        put('\n')
#define space		put(' ')
#define y1			y_chenxiaoyan_1
#define y0			y_chenxiaoyan_0
#define int long long
typedef pair<int,int> pii;
inline int read(){
	int x=0,neg=1;char c=getchar();
	while(!isdigit(c)){
		if(c=='-')	neg=-1;
		c=getchar();
	}
	while(isdigit(c))	x=x*10+c-'0',c=getchar();
	return x*neg;
}
inline void print(int x){
	if(x<0){
		putchar('-');
		print(abs(x));
		return;
	}
	if(x<=9)	putchar(x+'0');
	else{
		print(x/10);
		putchar(x%10+'0');
	}
}
inline int qpow(int x,int e,int _MOD){
	int ans=1;
	while(e){
		if(e&1)	ans=ans*x%_MOD;
		x=x*x%_MOD;
		e>>=1;
	}
	return ans;
}
int n=read(),m=read();
int key[100005],hs[100005],cntt;
struct juice{
	int d,p,l;
	juice(){/*ycxakioi*/}
	juice(int _d,int _p,int _l){
		d=_d;p=_p;l=_l;
	}
	friend bool operator <(juice a,juice b){
		return a.d<b.d;
	}
} a[100005];
struct node{
	int l,r,ch[2],sum,cst;
} s[100005<<5];
int ncnt=0,rt[100005];
inline void build(int &k,int l,int r){
	k=++ncnt;s[k].l=l;s[k].r=r;
	if(l==r)	return;
	int mid=(l+r)>>1;
	build(s[k].ch[0],l,mid);
	build(s[k].ch[1],mid+1,r);
}
inline void update(int &k,int pre,int p,int l){
	k=++ncnt;s[k]=s[pre];
	if(s[k].l==s[k].r){
		s[k].sum+=l;
		s[k].cst+=hs[p]*l;
		return;
	}
	int mid=(s[k].l+s[k].r)>>1;
	if(p<=mid)	update(s[k].ch[0],s[pre].ch[0],p,l);
	else		update(s[k].ch[1],s[pre].ch[1],p,l);
	s[k].sum=s[s[k].ch[0]].sum+s[s[k].ch[1]].sum;
	s[k].cst=s[s[k].ch[0]].cst+s[s[k].ch[1]].cst;
}
inline bool check(int mid,int g,int l){
	if(s[rt[mid]].sum<l)	return 0;
	int cur=rt[mid];
	while(1){
		if(s[cur].l==s[cur].r){
			g-=hs[s[cur].l]*l;
			break;
		}
		if(l<=s[s[cur].ch[0]].sum){
			cur=s[cur].ch[0];
		}
		else{
			l-=s[s[cur].ch[0]].sum;
			g-=s[s[cur].ch[0]].cst;
			cur=s[cur].ch[1];
		}
	}
	return g>=0;
}
signed main(){
	fz(i,1,n)	a[i].d=read(),a[i].p=read(),a[i].l=read(),key[i]=a[i].p;
	sort(key+1,key+n+1);
	sort(a+1,a+n+1);
	fz(i,1,n)	if(key[i]!=key[i-1])	hs[++cntt]=key[i];
	fz(i,1,n)	a[i].p=lower_bound(hs+1,hs+cntt+1,a[i].p)-hs;
	build(rt[n+1],1,cntt);
	fd(i,n,1)	update(rt[i],rt[i+1],a[i].p,a[i].l);
	a[0].d=-1;
	while(m--){
		int g=read(),l=read();
		int L=1,R=n,ans=0;
		while(L<=R){
			int mid=(L+R)>>1;
			if(check(mid,g,l))	ans=mid,L=mid+1;
			else				R=mid-1;
		}
		cout<<a[ans].d<<endl;
	}
	return 0;
}
```

---

## 作者：Owen_codeisking (赞：3)

第一次自己想出主席树的题目祭。

$\%\%\%Fading$ 前天晚上手切此题后给我切了。

现在有三个限制：$d,p,l$，怎么搞呢？

如果只有两个限制，我们可以将其转化为二维数点问题。所以我们考虑二分 $d$，然后在满足 $g$ 和 $L$ 的限制。

发现当限定一个集合内取 $p$ 和 $l$，我们将 $p$ 排序后然后贪心取 $p_1\times l_1+p_2\times l_2+...+p_k\times l_k<=g$ 并检查$l_1+l_2+...+l_k$ 是否 $\geq L$

那么每次排序后暴力取，时间复杂度 $O(n^2\log^2 n)$

其实不用二分的时候我们将 $d$ 排个序，然后用 $set$ 暴力插入后统计答案，可以少掉一个 $\log$

然而没什么用。。。

我们发现 $p$ 是可持久化的，$sum_l$ 和 $sum_{p\times l}$ 是可以在主席树上搞的。那么每次二分 $d$，然后在主席树上统计答案，检查是否 $\geq L$。时间复杂度 $O(n\log^2 n)$

$Code\ Below:$

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=100000+10;
const int lim=100000;
int n,m,suml[maxn],T[maxn],L[maxn*20],R[maxn*20],sum[maxn*20],siz[maxn*20],cnt;

struct Juice{
	int d,p,l;
}a[maxn];

bool cmp(Juice a,Juice b){
	return a.d>b.d;
}

inline int read(){
	register int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return (f==1)?x:-x;	
}

void update(int &now,int pre,int l,int r,int x,int v){
	now=++cnt;L[now]=L[pre];R[now]=R[pre];
	sum[now]=sum[pre]+x*v;siz[now]=siz[pre]+v;
	if(l == r) return ;
	int mid=(l+r)>>1;
	if(x <= mid) update(L[now],L[pre],l,mid,x,v);
	else update(R[now],R[pre],mid+1,r,x,v);
}

int query(int now,int l,int r,int x){
	if(!now) return 0;
	if(l == r) return x/l;
	int mid=(l+r)>>1;
	if(sum[L[now]]>x) return query(L[now],l,mid,x);
	return query(R[now],mid+1,r,x-sum[L[now]])+siz[L[now]];
}

signed main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++) a[i].d=read(),a[i].p=read(),a[i].l=read();
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		suml[i]=suml[i-1]+a[i].l;
		update(T[i],T[i-1],1,lim,a[i].p,a[i].l);
	}
	int g,w,l,r,mid,ans;
	for(int i=1;i<=m;i++){
		g=read(),w=read();
		if(suml[n]<w){
			printf("-1\n");
			continue;
		}
		l=lower_bound(suml+1,suml+n+1,w)-suml;r=n;ans=0;
		while(l<=r){
			mid=(l+r)>>1;
			if(query(T[mid],1,lim,g)>=w) r=mid-1,ans=mid;
			else l=mid+1;
		}
		if(ans==0) printf("-1\n");
		else printf("%lld\n",a[ans].d);
	}
	return 0;
}
```

---

## 作者：若玉 (赞：2)

# 题解  
典型的二分套主席树  
首先我们要开一颗主席树  
每个节点表示一个价值  
然后我们要维护某个区间里面的容量总和以及这些容量的价值总和  
对于每个询问，我们可以二分枚举一个最小的美味度d  
并且用主席树加以判断  
### 代码
```.cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int N=100005;
int cnt,ls[N*20],rs[N*20],n,m,T[N],x,y,t,w,ans,mid,nn,b[N],Max;
struct node
{
	int d,p,l;
}a[N];
struct Node
{
	int x,y;
}tree[N*20];
bool cmp(node o,node l)
{
	return o.d<l.d;
}
void addition(int k,int t,int w,int x,int y,int p)
{
	if (t==w)
	{
		tree[k].x=tree[p].x+y;
		tree[k].y=tree[p].y+x*y;
	    return;
	}
	int mid=(t+w)/2;
	if (x>mid)
	{
		rs[k]=++cnt;
		ls[k]=ls[p];
		addition(cnt,mid+1,w,x,y,rs[p]);
	}
	else
	{
		rs[k]=rs[p];
		ls[k]=++cnt;
		addition(cnt,t,mid,x,y,ls[p]);
	}
	tree[k].x=tree[p].x+y;
	tree[k].y=tree[p].y+x*y;
}
bool query(int k,int t,int w,int x,int y,int p) //想要x升果汁，有y元钱 
{
	if (x==0) return true;
	if (t==w)
	{
		if (tree[k].x-tree[p].x<x) return false;
		if (y<t*x) return false;
		return true;
	}
	int optx=tree[ls[k]].x-tree[ls[p]].x;
	int opty=tree[ls[k]].y-tree[ls[p]].y;
	int mid=(t+w)/2; 
	if (x>=optx && y>=opty)
	  return query(rs[k],mid+1,w,x-optx,y-opty,rs[p]);
	else
	  if (x<optx)
	    return query(ls[k],t,mid,x,y,ls[p]);
	  else
	    return false;
}
signed main()
{
	
	scanf("%lld%lld",&n,&m);
	for (int i=1;i<=n;i++)
	  scanf("%lld%lld%lld",&a[i].d,&a[i].p,&a[i].l),Max=max(a[i].p,Max);
	sort(a+1,a+n+1,cmp);
	for (int i=1;i<=n;i++)
	  if (a[i].d!=a[i-1].d)
	  {
	  	nn++;
	  	b[nn]=i;
	  } 
	for (int i=1;i<=n;i++)
	{
		T[i]=++cnt;
		addition(T[i],1,Max,a[i].p,a[i].l,T[i-1]);
	}
	for (int i=1;i<=m;i++)
	{
		scanf("%lld%lld",&x,&y);
		t=1;w=nn;ans=-1;
		while (t<=w)
		{
			mid=(t+w)/2;
			if (query(T[n],1,Max,y,x,T[b[mid]-1]))
			{
				ans=a[b[mid]].d;
				t=mid+1;
			}
			else
			  w=mid-1;
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```



---

## 作者：wuzhaoxin (赞：1)

# 整体二分

看到多个询问和最小值的最大值应该可以马上想到整体二分~~吧~~

我们把果汁按照美味度**从大到小**排序，二分美味度，然后把大于这个美味度的果汁都取出来，然后只需要考虑用这些果汁能混合出的体积足够、价格最小的果汁能否满足要求即可

一个显然的贪心：每次选择价格最小的果汁，直到体积满足要求

我们把被取出来的果汁放到一个平衡树中，然后把所有询问按照L排序，然后两个指针往后扫即可

时间复杂度：$O(nlog^3 n)$

```python
while 之前累积的果汁体积 + 当前果汁体积 < L
	加入当前果汁
    果汁的指针向后移
if 果汁体积不够
	放入右边二分
if 之前累积的果汁价格 + 还需果汁体积 * 当前果汁价格 <= g
	放入左边二分
else
	放入右边二分
```

## 关于平衡树

平衡树这里可能会出很多锅（比如我被这个东西卡了几个小时），以下是几个要注意的地方

首先每次$solve$我们不能重建平衡树（这个应该是常识）

如果使用set作平衡树，需要对每个果汁加上编号并且在比较函数中需要比较（具体见我的代码）

如果使用multiset作平衡树，erase的时候需要用lower_bound，比较函数要写完整（不然你就等着像我一样出奇奇怪怪的错误）

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int gi() {
	register int x; register char op = 1, c;
	while(c = getchar(), c < '0' || c > '9') if(c == '-') op = !op;
	x = c ^ 48;
	while(c = getchar(), c >= '0' && c <= '9') x = (x << 3) + (x << 1) + (c ^ 48);
	return op ? x : -x;
}
struct juice {
	long long d, p, l, id;
	bool operator < (const juice& a)const {
		return p == a.p ? id < a.id : p < a.p;
	}
} a[100001];
struct child {
	long long g, l;
	int id;
	bool operator < (const child a)const {
		return l < a.l;
	}
};
int ans[100001];
int n, m;
set<juice> s;
set<juice>::iterator it;
int pos;
void solve(vector<child> v, int l, int r) {
	if(v.empty()) return;
	if(l == r) {
		for(vector<child>::iterator i = v.begin(); i != v.end(); i ++)
			ans[i->id] = a[l].d;
		return;
	}
	int mid = (l + r) >> 1;
	while(pos > mid) s.erase(a[pos --]);
	while(pos < mid) s.insert(a[++ pos]);
	it = s.begin();
	vector<child> tl, tr;
	long long L = 0, P = 0;
	for(vector<child>::iterator i = v.begin(); i != v.end(); i ++) {
		while(it != s.end() && L + it->l < i->l) L += it->l, P += it->l * it->p, it ++;
		if(it == s.end()) tr.push_back(*i);
		else if(i->g >= P + it->p * (i->l - L)) tl.push_back(*i);
		else tr.push_back(*i);
	}
	solve(tl, l, mid);
	solve(tr, mid + 1, r);
}
bool cmp(const juice a, const juice b) {
	return a.d == b.d ? a.p < b.p : a.d > b.d;
}
int main() {
	n = gi(), m = gi();
	pos = 0;
	for(int i = 1; i <= n; i ++) a[i].d = gi(), a[i].p = gi(), a[i].l = gi(), a[i].id = i;
	sort(a + 1, a + n + 1, cmp);
	vector<child> v;
	for(int i = 1; i <= m; i ++) {
		child x;
		x.id = i;
		scanf("%lld%lld", &x.g, &x.l), v.push_back(x);
	}
	sort(v.begin(), v.end());
	a[n + 1].d = -1, a[n + 1].l = 1e18, a[n + 1].p = 0, a[n + 1].id = n + 1;
	solve(v, 1, n + 1);
	for(int i = 1; i <= m; i ++) printf("%d\n", ans[i]);
	return 0;
}

```


---

## 作者：Adolfo_North (赞：0)

贪心思想，整体二分+权值线段树解决。

$Step\ 1$ 首先将所有果汁的美味度按从大到小排序，若美味度高的果汁可以满足小朋友的两个需求，则储存答案。

$Step\ 2$ 不断二分果汁，并且枚举小朋友，若当前果汁能满足小朋友的两个要求，则将小朋友分流到左区间，否则则分流到右区间。其中左区间会提高果汁的美味度，右区间会减少。

$Step\ 3$ 分流小朋友致叶子节点后，将这个区间的小朋友给予当前美味度的果汁，理由同 $Step\ 1$。

现在考虑如何维护小朋友的两个需求，以果汁的价格为权值构造权值线段树，维护当前左区间内的果汁价格，并与小朋友的消费能力比较，筛选出小朋友。

记得开 `long long`。

```cpp
#include <bits/stdc++.h>
using namespace std;
long long read(){
    long long x=0;
	int f=1;
    char ch=getchar();
    while(ch<'0' || ch>'9'){ if(ch=='-') f=-1;ch=getchar();}
    while(ch>='0' && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
inline void put(int x){
	if(x<0){putchar('-');x=-x;}
   if(x>=10) put(x/10); 
   putchar(x%10+'0');
}
#define p2 p<<1
#define p3 p<<1|1
const int N=1e5+7;
int n,m;
struct Juice{
	int d,p,l;
	bool operator <(Juice x) {
		return d>x.d;
	}
}a[N];
struct kids{
	long long g,l;
	int id;
}q[N],q1[N],q2[N];
long long vol[N<<2],mon[N<<2];
int idx;
int ans[N];
void pushup(int p){
	vol[p]=vol[p2]+vol[p3];
	mon[p]=mon[p2]+mon[p3];
}
void add(int p,int l,int r,int Jp,int Jl){
	if(l==r){
		vol[p]+=Jl;
		mon[p]=vol[p]*l;
		return;
	}
	int mid=(l+r)>>1;
	if(Jp<=mid) add(p2,l,mid,Jp,Jl);
	else add(p3,mid+1,r,Jp,Jl);
	pushup(p);
}
long long query(int p,int l,int r,long long v){
	if(!v) return 0;
	if(l==r) return l*v;//价格的零头
	int mid=(l+r)>>1;
	if(vol[p2]>=v) return query(p2,l,mid,v);
	else return mon[p2]+query(p3,mid+1,r,v-vol[p2]);
}
void Work(int l,int r,int L,int R){
	if(l>r) return;
	if(L==R){//当前区间的小朋友可以适配果汁 L。
		for(int i=l;i<=r;i++) ans[q[i].id]=a[L].d;
		return;
	}
	int mid=(L+R)>>1,p0=0,p1=0;
	while(idx<mid) idx++,add(1,1,N,a[idx].p,a[idx].l);//维护当前左区间内的果汁价格
	while(idx>mid) add(1,1,N,a[idx].p,-a[idx].l),idx--;
	for(int i=l;i<=r;i++){//筛选出适配的小朋友
		if(vol[1]>=q[i].l&&query(1,1,N,q[i].l)<=q[i].g) q1[++p0]=q[i];
		else q2[++p1]=q[i];
	}
	for(int i=1;i<=p0;i++) q[l+i-1]=q1[i];
	for(int i=1;i<=p1;i++) q[l+p0+i-1]=q2[i];
	Work(l,l+p0-1,L,mid);
	Work(l+p0,r,mid+1,R);
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	n=read(),m=read();
	for(int i=1;i<=n;i++) {
		a[i].d=read(),a[i].p=read(),a[i].l=read();
	}
	a[++n]={-1,0,N};//无解的小朋友会被分流到这里
	sort(a+1,a+1+n);//贪心，排序
	for(int i=1;i<=m;i++){
		q[i].g=read(),q[i].l=read();
		q[i].id=i;
	}
	Work(1,m,1,n);
	for(int i=1;i<=m;i++) put(ans[i]),putchar('\n');
	return 0;
}
```

---


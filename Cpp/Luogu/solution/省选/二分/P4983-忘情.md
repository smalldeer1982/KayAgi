# 忘情

## 题目背景

 “为什么要离开我！”

 “因为你没玩儿转！”

 “我玩儿转了！”

 “那好，你现在就给我维护这么一个式子！”

 “为什么要出这么毒瘤的东西。”

 “为了恶心你。”

 “......”

$…………………………….$


## 题目描述

你的 $npy$ 为了恶心你，特地请了四位大神和一个辣鸡！

 $\rm hdxrie$ 说：“我们得求和。”于是有了 $\sum\limits_{i=1}^{n}x_i $ 。

 $\rm Imagine$ 说：“我们得有平均数。”于是有了 $\bar x $ 。

 $\rm TimeTraveller$ 说：“我们得有加减乘除。”于是有了一些恶心的组合。

 $\rm Althen·Way·Satan$ 说：“我们还得有平方。”于是我们将它平方。

最垃圾的 $\rm ZredXNy$ 说：“那我帮你们整合一下。”

于是，我们得到了这么一个式子 $:$

$$\frac{\left((\sum\limits_{i=1}^{n}x_i×\bar x)+\bar x\right)^2}{\bar x^2}$$


我们定义一段序列的值为这个，其中  $n$为此序列的元素个数。

我们给定一段长度为 $n$ 的序列,现在要求将它分成 $m$ 段，要求每一段的值的总和最小，求出这个最小值。


## 说明/提示

- 对于 $30 \%$ 的数据，$m≤n≤500$；

- 另有 $20 \%$ 的数据，保证 $m=2$；

- 对于 $100 \%$ 的数据，$m≤n≤100000$，$1≤x_i≤1000$。


## 样例 #1

### 输入

```
3 2
1 2 3
```

### 输出

```
32```

## 样例 #2

### 输入

```
10 3
1 2 3 4 5 6 7 8 9 10
```

### 输出

```
1140```

# 题解

## 作者：JK_LOVER (赞：47)

# 前面的话

- 2021/2/22 修改一些错误。

这篇博客大概是带权二分(wqs 二分，是叫这个名字吧？)的入门博客，希望大家点个赞?。
# 引入
给你一个序列 $a_1,a_2,a_3..a_n$ 。其中 $a_i\in \mathbb{Z^*}$ 。可以把序列分为 $k$ 段。定义每一段的价值为 $(\sum_{i= 1}^n a_i)^2$ ，现在要求 $k$ 的总和最小。形式的，我们要最小化 $ans=\sum_{i=1}^{k}(\sum_{a_j\in U_i} a_j) ^ 2$ 。

## 分析

- 我们可以先做一个 $O(n^2)$ 的线性 $dp$ 。定义 $dp(i,j)$ 为 $i$ 结尾，分了 $j$ 的最小值。那么转移为 $dp(i,k) = \min_{0\le j< i}\{dp(j,k-1)+(\sum_{l=j+1}^{i} a_l)^2\}$ 。最后的答案为 $dp(n,k)$ 。我们再考虑一下优化。

- 我们可以分析，由于 $(a+b)^2 \ge a^2 + b^2$ 。所以我们其实要分的段数要越多越好。那么我们得到第一个性质 ，答案是关于段数 $k$ 的增加而减小的，而且减小值越来越小，因为 $\Delta v = 2ab$ ，而我们一定是优先选择 $\Delta v$ 操作的 。所以如果我们定义 $ans=f(k)$ 。那么 $f(k)$ 是一个单调下降的，而且是一个下凸函数。那么我们可以借助图像分析一下凸函数的性质。 ![图片说明](https://uploadfiles.nowcoder.com/images/20201111/112351770_1605093889437_1CDB8CA70DF9F03C097A1656144A3AA6 "图片标题") 我们发现，如果我们拿一条斜率为 $K$ 的直线 $l_1 $去切这个由 $P(x,f(x))$ 点集构成的图像。那么在切点 $Q(x,f(x))$ 处，如果我们知道 $l_1$ 的截距 $f'(K)$ ，那么 $P(x,f(x))$ 就可以写做 $P(x,Kx + f'(K))$ 。那么由于这个 $f(x)$ 函数是单调的，如果通过斜率可以得到 $x,f'(x)$，在 $x$ 处切线的斜率是可以通过二分得到的。![图片说明](https://uploadfiles.nowcoder.com/images/20201111/112351770_1605094500761_1CDB8CA70DF9F03C097A1656144A3AA6 "图片标题") 这样我们我们可以通过二分斜率，再从切点的横坐标，再调整斜率来找到横坐标为 $x$ 时，切线直线的 $k,f'(k)$ 。那么我们现在的问题就转化为，如何求出一条斜率为 $K$ 的直线与 $f(x)$ 的切点和此时 $l_1$ 的在 $y$ 轴上的截距 $f'(K)$ 。那么答案为 $f'(K) + Kx$ 。

- 回到原问题，如果我们仔细观察，如果我们把每一段的价值 $+val$ 。那么定义 $dp(i)$ 为 $i$ 结尾的最小值 ，定义 $S_x = \sum_{i = 1}^x a_i$ 。那么转移为 $dp(i)=\min\{dp(j)+(S_i - S_j)^2 + val\}$ 。这样我们就去掉了个数 $k$ 的限制。那么关于上式子可以斜率优化解决，这里不详细展开了（后面有类似例题）。就此我们可以 $O(n\log n)$ 求出原问题了。

## 总结
- 我们先分析出函数的单调性，在通过二分斜率，找到切点。最后通过切点横坐标 $x$ 与答案坐标 $k$ 调整斜率找到 $f(k)$ 的答案。
- 二分斜率，一定要记住我们求出的是 $l_i$ 的斜率为 $K$ 是的切点。而在整数二分时，可能有两个切点。这个要看你是如何二分的，最后一定要取横坐标为 $x$ 时的答案，而不是直接取切点的横坐标。
 
# 例题
很遗憾，我并没有找到太多的例题，但大概也有非常好的训练效果。
## [P4983 忘情](https://www.luogu.com.cn/problem/P4983)
### 题意
也是分 $m$ 段，每一段的价值为 $(1+\sum_{i=1}^n a_i)^2$ 最小化价值和。
### 分析
同上题。式子基本一模一样。那么省去二分斜率这些步骤。我们重点分析一下 $dp(i)=\min\{dp(j) + (S_i - S_j + 1) ^ 2 + val\}$ 这个式子。令 $j$ 为 $i$ 的转移点。那么 $dp(i)=dp(j)+S(i)^2 + S(j)^2 + 1 + 2S(i) - 2S(j) - 2S(i)S(j) + val$ 移项之后 $dp(i)-S(i)^2-1-val-2S(i)= -2S(i)S(j) + dp(j)+S(j)^2 - 2S(j)$ 。由于我们要维护 $dp(i)$ 的最小值，所以我们考虑用单调栈维护一个凸壳。然后就是斜率优化的模板了 $y = -bx + k$，其中 $2S(i)$ 为 $x$ ，斜率为 $b = S(j)$ ，$k = dp(j)+S(j)^2-2S(j)$ 。那么一次 $dp$ 的复杂度就下降到 $O(n)$ 了。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
	int x = 0,f = 0;char ch = getchar();
	while(!isdigit(ch)) {if(ch == '-')f = 1;ch = getchar();}
	while(isdigit(ch)) {x = x * 10 + ch - '0';ch = getchar();}
	return f ? -x : x;
} 
#define ll long long
const ll inf = 1e18;
const int N = 1e5 + 100;
ll f[N],g[N],q[N],s[N];
int n,m;
#define Y(a) (f[a]+s[a]*s[a]-2*s[a])
#define X(a) (s[a]) 
long double K(int a,int b) {
	return (long double)(Y(b) - Y(a)) / (X(b) - X(a));
}
void check(ll mid) {
	memset(f,0x3f,sizeof(f));memset(g,0,sizeof(g));
	f[0] = 0;int l = 1,r = 1;
	q[1] = 0;
	for(int i = 1;i <= n;i++) {
		while(l < r && K(q[l],q[l + 1]) < 2 * s[i]) l++;
		f[i] = f[q[l]] + (s[i] - s[q[l]] + 1) * (s[i] - s[q[l]] + 1) + mid;
		g[i] = g[q[l]] + 1;
		while(l < r && K(q[r - 1],q[r]) > K(q[r - 1],i)) r--;
		q[++r] = i;
	}
}
int main() {
	n = read();m = read();
	for(int i = 1;i <= n;i++) s[i] = s[i - 1] + read();
	ll l = 0,r = inf,ans = 0;
	while(l <= r) {
		ll mid = l + r >> 1;check(mid);
//		cout << g[n] << endl;
		if(g[n] <= m) ans = mid , r = mid - 1;
		else l = mid + 1;	
	}
	check(ans);
	printf("%lld\n",f[n] - m * ans);
	return 0;
}
```
## [[国家集训队2]Tree I](https://www.luogu.com.cn/problem/P2619)
### 分析
我们令 $f(x)$ 为选择 $x$ 条白边的最小生成树的代价。根据直觉的分析，在某一个位置 $pos$ 前时，我们选择白边比黑边要优，是一个逐渐增加，斜率逐渐减小的函数。而 $pos$ 后面选择黑边要优，是一个斜率的增加，值不断减小的函数。那么我们给白色的边加上一个权值 $val$ ，在这个情况下做最小生成树。最后返回使用的白色边的个数和最小生成树的代价。那么二分完 $val$ 之后，最后的答案为 $Ans_{Mst} - k \times val$ 。总的复杂度为 $O(n\log n\log w)$ 。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 5e5 + 1000;
struct Edge {ll x,y,w,col;}e[N];
int read() {int x;scanf("%d",&x);return x;}
ll n,m,k,tot = 0,Ans = 0,f[N];
bool cmp(Edge x,Edge y) {return (x.w < y.w) || (x.w == y.w && x.col > y.col) ;}
ll find(ll x) {return f[x] == x ? x : f[x] = find(f[x]);}
void MST(ll mid) {
	tot = 0;Ans = 0;
	for(int i = 1;i <= m;i++) if(e[i].col) e[i].w += mid;
	for(int i = 1;i <= n;i++) f[i] = i;
	sort(e + 1,e + 1 + m,cmp);
	for(int i = 1;i <= m;i++) {
		int x = find(e[i].x),y = find(e[i].y);
		if(find(x) == find(y)) continue;
		Ans += e[i].w;tot += e[i].col;
		f[find(x)] = find(y);
	}
	for(int i = 1;i <= m;i++) if(e[i].col) e[i].w -= mid;
}
int main() {
	n = read();m = read();k = read();
	for(int i = 1;i <= m;i++) {
		e[i].x = read() + 1;e[i].y = read() + 1;
		e[i].w = read();e[i].col = 1 - read();
	}
	ll l = -1e9,r = 1e9,ans = 0;
	while(l <= r) {
		ll mid = l + r >> 1;
		MST(mid);
		if(tot >= k) ans = mid,l = mid + 1;
		else r = mid - 1;
	}
	MST(ans);
	printf("%lld\n",Ans - k * ans);
	return 0;
}
```
# 剩下的例题
- [P4383 [八省联考2018]林克卡特树](https://www.luogu.com.cn/problem/P4383) [代码](https://www.luogu.com.cn/paste/isabcrh1)
- [CF739E Gosha is hunting](https://www.luogu.com.cn/problem/CF739E) [代码](https://www.luogu.com.cn/paste/crah0gdp)
- [P4767 [IOI2000]邮局](https://www.luogu.com.cn/problem/P4767) [代码](https://www.luogu.com.cn/paste/uprvsb65)

# 最后的话
- 常见问法，强制规定只能选 $k$ 个物品，问最优答案。

- 一定要注意切点不止一个，在整数二分时。

---

## 作者：gxy001 (赞：9)

这篇题解主要说一下细节问题，即题解和讨论区中都提到的斜率优化时要不要加等于号这件事。

这题的数据比较水，所以稍微改改就过了，这里说一下结论：如果一个位置的 dp 值可以从多个位置转移过来，选择其中转移次数最多的（注：我的写法是二分时若转移次数大于等于 $m$，则接受这个答案；如果有人写的和我相反，就选择转移次数最少的）。

具体的原因就是，我们二分的是斜率，而这个凸函数可能存在连续一段斜率相同的，设为 $[l,r]$，若 $l<m<r$，我们不对转移次数进行限制，就有可能取到 $l$，从而舍弃这个答案。

知道这点后代码就极其好写了，不懂的看代码就行了。

```cpp
#include<cstdio>
int n,m,g[100010],s[100010],q[100010];
long long f[100010],h[100010];
bool check(long long mid){
	int hd=0,tl=0;
	for(int i=1;i<=n;i++){
		while(hd<tl&&((h[q[hd+1]]-h[q[hd]])<2ll*s[i]*(s[q[hd+1]]-s[q[hd]])||((h[q[hd+1]]-h[q[hd]])==2ll*s[i]*(s[q[hd+1]]-s[q[hd]]&&g[q[hd+1]]>=g[q[hd]]))))++hd;
		f[i]=f[q[hd]]+(s[i]-s[q[hd]]+1ll)*(s[i]-s[q[hd]]+1ll)-mid;
		g[i]=g[q[hd]]+1;
		h[i]=f[i]-2*s[i]+1ll*s[i]*s[i];
		while(hd<tl&&((h[q[tl]]-h[q[tl-1]])*(s[i]-s[q[tl]])>(h[i]-h[q[tl]])*(s[q[tl]]-s[q[tl-1]])||((h[q[tl]]-h[q[tl-1]])*(s[i]-s[q[tl]])==(h[i]-h[q[tl]])*(s[q[tl]]-s[q[tl-1]])&&g[i]>=g[q[tl]])))--tl;
		q[++tl]=i;
	}
	return g[n]>=m;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1,x;i<=n;i++)scanf("%d",&x),s[i]=s[i-1]+x;
	long long l=-1e18,r=0,ans=0;
	while(l<=r){
		long long mid=(l+r)/2;
		if(check(mid)) ans=mid,r=mid-1;
		else l=mid+1;
	}
	check(ans);
	printf("%lld\n",f[n]+m*ans);
	return 0;
}
```

---

## 作者：QWQcoding (赞：7)

这是一道 $WQS$ 二分 $+$ $dp$ 斜率优化 的好题

题意简述：

 定义每一段的值为：
 $$
 \frac{\left(\left(\sum_{i=1}^{t} x_{i} \times \bar{x}\right)+\bar{x}\right)^{2}}{\bar{x}^{2}}
 $$
 其中 $t$ 为此段的元素个数，$\bar x$ 表示这串数的平均值。

 现在给定一段长度为 $n$ 的序列，要求将它分成 $m$ 段，使得每一段的值的总和最小，求出这个最小值。

先尝试将每一段序列的值进行化简
$$
\begin{aligned}
& \frac{\left(\left(\sum_{i=1}^{t} x_{i} \times \bar{x}\right)+\bar{x}\right)^{2}}{\bar{x}^{2}}\\
= & \left(\frac{\left(\sum_{i=1}^{t} x_{i} \times \bar{x}\right)+\bar{x}}{\bar{x}}\right)^2\\
= & \left(\sum_{i=1}^{t} x_{i}+1\right)^2
\end{aligned}
$$
发现每段序列的值只与这段数的和有关，可以记录前缀和，用 $sum[i]$ 表示。

通过数学分析或直观推测易得 $y=h(x)$ 是凸函数

将题目转化为无约束问题：

 现在给定一段长度为 $n$ 的序列，要求将它分成若干段，使得每一段的值的总和最小，求出这个最小值。

对于这个问题，考虑使用动态规划

$f[i]$ 表示前 $i$ 个数划分成若干段能得到的最小值

转移方程中别忘了把 $cpu$ 代入，如下：
$$
f[i]=\min_{0\leq j\leq i-1}  \left\{f[j]+(sum[i]-sum[j]+1)^2+cpu\right\}
$$
此时动态规划的时间复杂度为 $\Theta (n^2)$ ，能得到 $30$ 分。

观察转移方程，将其展开并化简
$$
\begin{aligned}
f[i]=&\min_{0\leq j\leq i-1}  \left\{f[j]+sum[i]^2+sum[j]^2+1-2\cdot sum[i]\cdot sum[j]+2\cdot sum[i]-2\cdot sum[j] +cpu\right\}\\
=& \min_{0\leq j\leq i-1}  \left\{f[j]+sum[j]^2-2\cdot sum[i]\cdot sum[j]-2\cdot sum[j]\right\}+sum[i]^2+2\cdot sum[i]+1+cpu\\
\end{aligned}
$$
发现可以斜率优化，对于直线 $y=-2\cdot sum[j]\cdot sum[i]+sum[j]^2-2\cdot sum[j]+f[j]$

- 横坐标 $x$ ： $sum[i]$，递增
- 截距 $b$ ：$sum[j]^2-2\cdot sum[j]+f[j]$
- 斜率 $k$ ：$-2\cdot sum[j]$，递减

把每条直线用 $\{b,k\}$ 的形式表示

$i$ 号直线可以表示为 $\{sum[i]^2-2\cdot sum[i]+f[i],-2\cdot sum[j] \}$ 

至此本题的算法分析就结束了

接下来是代码部分

$WQS$ 二分中从 $0$ 到 $\infty$ 枚举斜率

`calc()` 函数中进行 $DP$ 斜率优化

最后求答案要减去附加的 $cpu$ 

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef long double ld;
const ld ERR=1e-4;
const ll INF=1e18;
struct Optimal{
	ll val,cnt;
};
ll n,m;
ll x[100009];
ll s[100009];
Optimal f[100009];
ll q[100009];
struct Line{
	ld b,k;
} lines[100009];
ld X(ll u,ll v){
	return -(ld)(lines[u].b-lines[v].b)/(lines[u].k-lines[v].k);
}
Optimal calc(ll cpu){
	for(ll i=0;i<=n;i++){
		f[i]={INF,0};
	}
	f[0]=(Optimal){0,0};
	lines[0]=(Line){0,0};
	q[1]=0;
	ll l=1,r=2;
	for(ll i=1;i<=n;i++){
		while(r-l>=2&&X(q[l],q[l+1])<s[i]+ERR) l++;
		ll j=q[l];
		f[i]=(Optimal){f[j].val+(s[i]-s[j]+1)*(s[i]-s[j]+1)+cpu,f[j].cnt+1};
		lines[i]=(Line){f[i].val+s[i]*s[i]-2*s[i],-2*s[i]};
		while(r-l>=2&&X(i,q[r-1])<X(q[r-1],q[r-2])) --r;
		q[r++]=i;
	}
	return f[n];
}
int main() {
	scanf("%lld%lld",&n,&m);
	for(ll i=1;i<=n;i++){
		scanf("%lld",&x[i]);
		s[i]=s[i-1]+x[i];
	}
	ll low=0;
	ll high=INF;
	ll bstCPU=low;
	while(low<=high){
		ll mid=(low+high)/2;
		Optimal opt=calc(mid);
		if(opt.cnt>=m){
			bstCPU=mid;
			low=mid+1;
		}
		else{
			high=mid-1;
		}
	}
	Optimal opt=calc(bstCPU);
	ll ans=opt.val-m*bstCPU;
	printf("%lld\n",ans);
	return 0;
}


---

## 作者：Register (赞：6)

- 化简式子

$\frac{((\sum x_i\times \overline{x})+\overline{x})^2}{{\overline{x}}^2}$

$=\frac{((\sum x_i+1)\times \overline{x})^2}{{\overline{x}}^2}$

$=(\sum x_i+1)^2$

看到这个结果显然是需要斜率优化的，但是只斜率优化是 $O(nm)$ 的

~~结合题目名称~~因为是分成 $m$ 段的 DP 可以想到 **wqs二分**

wqs二分：二分一个值 ```val``` ，每次转移的时候加上（减去） ```val```

只有是个凸函数的时候才能用 wqs二分 来优化，在这里求的是最小值，所以证明一下它是个下凸函数即可

只需要证明当分的段数越多的时候权值越小，即分成 $2$ 段比 $1$ 段的权值小

- 直接作差：

$\Delta=(\sum x_i+1)^2-(\sum_{1}^{mid} x_i+1)^2-(\sum_{mid+1}^{n} x_i+1)^2$

$=(\sum x_i)^2+2\sum x_i+1-(\sum_{1}^{mid} x_i)^2-2\sum_{1}^{mid} x_i-1-(\sum_{mid+1}^{n} x_i)^2-2\sum_{mid+1}^{n} x_i-1$

$=(\sum x_i)^2-(\sum_{1}^{mid} x_i)^2-(\sum_{mid+1}^{n} x_i)^2+2\sum x_i-2\sum x_i+1-2$

$=(\sum x_i)^2-(\sum_{1}^{mid} x_i)^2-(\sum_{mid+1}^{n} x_i)^2-1$

$=2(\sum_{1}^{mid} x_i)(\sum_{mid+1}^{n} x_i)-1$

因为 $ x_i \ge 1$

所以 $\Delta \ge 1$

- 稍微说一下斜率优化：

$F_i=\min\left\{F_j+(s_i-s_j+1)^2\right\}$

$=\min\left\{F_j+{s_j}^2-2(s_i+1)s_j\right\}+(s_i+1)^2$

显然$x=s_i,y=F_i+{s_i}^2,k=2(s_i+1)$

- 时间复杂度：$O(N\log V)$

代码：

```cpp
#include <cstdio>
#include <cstring>
#define int long long
int n,m,l,r=1e18,head,tail,ans,s[100001],f[100001],q[100001],t[100001];
inline int read(){
	char ch=getchar();int res=0,w=1;
	while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {res=res*10+ch-'0';ch=getchar();}
	return res*w;
}
inline double x(int i) {return s[i];}
inline double y(int i) {return f[i]+s[i]*s[i];}
inline double k(int i) {return 2.0*(s[i]+1);}
inline double slope(int i,int j) {return (y(i)-y(j))/(x(i)-x(j));}
bool check(int v){
	head=0;tail=0;
	for(register int i=1;i<=n;i++)
	{
		while(head<tail&&slope(q[head],q[head+1])<k(i)) head++;
		f[i]=f[q[head]]+(s[i]-s[q[head]]+1)*(s[i]-s[q[head]]+1)+v;t[i]=t[q[head]]+1;
		while(head<tail&&slope(q[tail-1],q[tail])>slope(q[tail],i)) tail--;
		q[++tail]=i;
	}
	return t[n]>m;
}
signed main(){
	n=read();m=read();
	for(register int i=1;i<=n;i++) s[i]=s[i-1]+read();
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(check(mid)) l=mid+1;
		else {r=mid-1;ans=mid;}
	}
	check(ans);printf("%lld\n",f[n]-ans*m);
	return 0;
}
```

---

## 作者：c202201 (赞：5)


#### [题目传送门](https://www.luogu.com.cn/problem/P4983)

## 简要题意

我们定义一段序列的值为：
$$
\frac{((\sum_{i=1}^n x_i \times \overline x) + \overline x )^2}{{\overline x}^2}
$$
给你一个 $ n $ 个元素序列 $ x $，将这个序列分为 $ m $ 段，求每一段值的总和的最小值。

## 考点（前置知识）

斜率优化 dp，wqs 二分。

不会斜率优化的点[这里](https://www.cnblogs.com/cmy-blog/p/slope-optimization.html)。

不会 wqs 二分的点[这里](https://blog.csdn.net/Emm_Titan/article/details/124035796)。

## 思路 

先将柿子化简一些：
$$
\frac{((\sum_{i=1}^n x_i \times \overline x) + \overline x )^2}{{\overline x}^2} = \frac{{\overline x}^2 (\sum_{i=1}^n x_i)^2 + 2 {\overline x}^2 \sum_{i=1}^n x_i + {\overline x}^2}{{\overline x}^2} = (\sum\limits_{i=1}^n x_i)^2 + 2 (\sum\limits_{i=1}^n x_i) + 1 = (\sum\limits_{i=1}^n x_i + 1)^2
$$
可以容易想出 dp。

设 $f_{i,j}$ 表示前 $i$ 个数分为 $j$ 段的最小值，$pre$ 为前缀和。

那么转移方程就是：$f_{i,k} = \min\limits_{j<i} \left\{ f_{j,k-1} + (pre_i - pre_j + 1)^2 \right\}$。

直接转移 $O(n^2)$，肯定时间爆炸，考虑优化。

~~打表可知，~~ 这是一个凸包，考虑用 wqs 二分优化 dp ，每分一次段就加上 lim（二分的值）。那么 dp 就优化到一维（把原本第二维优化掉了），再用斜率优化求解。

由于这里分的段越多，获得的额外价值就越多，但我们要的是最小值，所以要注意一下斜率优化里出队的写法，在第一属性相同时选择第二属性较大的，那么限制 $m$ 的应该在这个点左边，所以 check 的返回值是 $g_n \geq m$。

## 代码

talking is cheap,show me your code.

```cpp
#include <bits/stdc++.h>
#define il inline
#define int long long
using namespace std;
const int N=100005;
int n,m,x[N],f[N],g[N],q[N],pre[N];
il double Y(int i) {return (f[i]-(pre[i]<<1)+pre[i]*pre[i]);}
il double X(int i) {return pre[i];}
il double slope(int i,int j) {return (Y(i)-Y(j))/(X(i)-X(j));}
il bool check(int lim){
	q[1]=0;
	for(int i=1,hd=1,tl=1;i<=n;++i){
	    while(hd<tl&&slope(q[hd],q[hd+1])<=(pre[i]<<1)) ++hd;
	    f[i]=f[q[hd]]+(pre[i]-pre[q[hd]]+1)*(pre[i]-pre[q[hd]]+1)+lim,g[i]=g[q[hd]]+1;
	    while(hd<tl&&slope(q[tl-1],q[tl])>=slope(q[tl],i)) --tl;
	    q[++tl]=i;
	}
	return g[n]>=m;
}
signed main() {
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=n;++i) scanf("%lld",x+i),pre[i]=pre[i-1]+x[i];
    int l=0,r=1e16;
    while(l<=r){
        int mid=(l+r)>>1;
        if(check(mid)) l=mid+1;
		else r=mid-1;
    }
    check(l-1);                     //最后计算求出正解
    printf("%lld\n",f[n]-(l-1)*m);
    return 0;
}

```


---

## 作者：Gmt丶FFF (赞：3)

首先可以发现 dp 方程为：$dp_{i,k}=dp_{j,k-1}+(sum_i-sum_j+1)^2$。

那么展开即为：$dp_{j,k}+sum_j^2-sum_j=2\times sum_i\times sum_j+dp_{i,k}-sum_i^2-1-sum_i$。

很明显斜率 dp，$2\times sum_i,sum_j$ 均单调递增，用单调队列维护即可。

时间复杂度：$O(n\times m)$。

考虑优化。

可证以选取次数为 $x$ 轴，选取此次数的最大值为 $y$ 轴所得到的形状为下凸包，因为一个值每次分开成两个值 $x,y$ 答案都会减小 $2\times x\times y-1$ 的答案，切的越少，$x,y$ 的值就会越大，$2\times x\times y-1$ 的值就会越大，所以呈下凸包。

所以我们要找到一个正好能切到横坐标为 $m$ 对应的点的斜率。

那么我们先二分斜率，然后判断这个斜率交在哪个点上，如果交的点小了，斜率变小，否则斜率变大，直到交到 $m$ 点为止。

现在问题是我们如何知道它交在哪一个点，这里讲一个比较好理解的方法（虽然没有严格证明，严格证明的不好理解，可以移步其他题解）。

实际上对于每一次求斜率，我们可以对在转移时加上斜率，这样所有的点的 $y$ 坐标会发生改变，导致转移方式不同，最后一个数的选取个数即是那个与 $x$ 轴对应的点相交。

而由于最后的转移方式改变，所以得对 $ans$ 减去 $m\times k$。

时间复杂度：$O(n\times\log(n))$。

```cpp
#include<iostream>
#include<cstdio>
#define int long long
using namespace std;
const int N=1e5+5;
int n,sum[N],m,f[N],g[N],q[N];
int clac(int x)
{
	return x*x;
}
double slope(int x,int y)
{
	return (f[x]+clac(sum[x])-2*sum[x]-(f[y]+clac(sum[y])-2*sum[y]))/1.0/(sum[x]-sum[y]);
}
bool check(int x)
{
	f[0]=0;
	int l=1,r=1;
	for(int i=1;i<=n;i++)
	{
		while(l<r&&slope(q[l],q[l+1])<2*sum[i])l++;
		f[i]=f[q[l]]+x+clac(1+sum[i]-sum[q[l]]);
		g[i]=g[q[l]]+1;
		while(l<r&&slope(q[r],q[r-1])>slope(q[r],i))r--;
		q[++r]=i;
	}
	return g[n]>m;
}
signed main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++)scanf("%lld",&sum[i]),sum[i]+=sum[i-1];
	int l=1,r=1e18;
	while(l<r)
	{
		int mid=(l+r)>>1;
		if(check(mid))l=mid+1;
		else r=mid;
	}
	check(l);
	printf("%lld",f[n]-l*m);
	return 0;
}
```


---

## 作者：Durancer (赞：3)

## 前置知识

- 斜率优化。

- $\text{wqs}$ 二分。

## 思路

### 斜率优化

首先看到是 $1D/1D$ $\text{dp}$，那么就考虑可不可以用斜率优化进行求解,设 $f_i$ 表示前 $i$ 个分成若干份的最小价值。

首先先化简柿子：

$$f_i=f_j+\frac{\left( \left(\sum_{k=j+1}^ix_k\times \bar{x} \right)+\bar{x}\right)^2}{\bar{x}^2}$$

$$f_i=f_j+\frac{\bar{x}^2\left( \sum_{k=j+1}^ix_k+1\right)^2}{\bar{x}^2}$$


$$f_i=f_j+\left(\sum_{k=j+1}^ix_k+1\right)^2$$

用前缀和优化之后即为：

$$f_i=f_j+(s_i-s_j+1)^2$$

我们考虑把柿子展开可以得到：

$$f_{i}=f_j+s_i^2+s_j^2-2s_is_j+1+2(s_i-s_j)$$

我们发现有 $i,j$ 相乘的项，那么就来尝试斜率优化。

设 $0\leq j_1<j_2<n$

$$f_{j_2}+s_i^2+s_{j_2}^2-2s_is_{j_2}+1+2(s_i-s_{j_2})<f_{j_1}+s_i^2+s_{j_1}^2-2s_is_{j_1}+1+2(s_i-s_{j_1})$$

最后化简完即为：

$$\frac{f_{j_2}+s_{j_2}^2-f_{j_1}-s_{j_1}^2}{s_{j_2}-s_{j_1}}<2s_i+2$$

可以发现是下凸包，正常按斜率优化的套路。

### $\text{wqs}$ 二分

在进行斜率优化的时候另开一个数组记录分成了几组，然后进行判断即可，给 $f_i$ 赋值时多添加一个当前枚举到的 $\text{mid}$。

如果当前添加后分成的组数 $\leq$ $m$ 记录答案并调低二分值的范围，反之就调高。

```cpp
/*

	( f[j2] - s[j2]^2 -(f[j1] - s[j1]^2) ) / ( s[j2] - s[j1] ) <= 2s[i] + 2 
	
	//斜率优化裸 + wqs二分优化 

*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<queue>
#include<stack>
#include<vector>
#include<algorithm>
#include<map>
#define int long long
using namespace std;
const int N=1e5+9;
const int M=1e5+9;
int a[N];
int n,m,f[N];
int s[N];
int cnt[N];
int read()
{
	int f=1,x=0;
	char s=getchar();
	while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
	while(s>='0'&&s<='9'){x=(x<<1)+(x<<3)+(s^'0');s=getchar(); }
	return f*x;
}
long double Y(int j)
{
	return (long double)f[j]+(long double)s[j]*s[j];	
} 
long double X(int j)
{
	return (long double)s[j];
}
long double slope(int i,int j)
{
	return (Y(j)-Y(i))/(X(j)-X(i));
}
int q[N];
void check(int x)
{
	memset(f,0x3f3f3f3f,sizeof(f));
	f[0]=0;
	cnt[0]=0;
	int head=0,tail=1;
	q[++head]=0;
	for(int i=1;i<=n;i++)
	{
		while(head<tail and slope(q[head],q[head+1])<(long double)2*s[i]+(long double)2)
			head++;
		int j=q[head];
		f[i]=f[j]+(s[i]-s[j]+1)*(s[i]-s[j]+1)+x;
		cnt[i]=cnt[j]+1;
		while(head<tail and slope(q[tail-1],q[tail])>slope(q[tail],i))
			tail--;
		q[++tail]=i;
	}
}
int ans;
signed main()
{
	n=read();
	m=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	for(int i=1;i<=n;i++)
		s[i]=s[i-1]+a[i];
	int l=0,r=1e18;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		check(mid);
		int Cnt=cnt[n];
		//cout<<"mid= "<<mid<<" cnt= "<<Cnt<<endl;
		if(Cnt<=m)
		{
			r=mid-1;
			ans=f[n]-1ll*m*mid;
		}
		else 
			l=mid+1;
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：约瑟夫用脑玩 (赞：3)

这篇题解用码量和复杂度换思维，典型的数据结构学傻了，不过会李超树不会斜率优化的可以来看看。（不会只有我只会李超树吧

首先题目这式子就一副缺化简的样子，首先带入 $\overline x=\frac{\sum_ix_i}{n}$：

$$\frac{(\sum_ix_i\frac{\sum_jx_j}{n}+\frac{\sum_ix_i}{n})^2}{(\frac{\sum_ix_i}{n})^2}$$

$$\frac{(\sum_ix_i\sum_jx_j+\sum_ix_i)^2}{(\sum_ix_i)^2}$$

令 $sum=\sum_ix_i$。

$$\frac{(\sum_ix_i\times sum+sum)^2}{(sum)^2}$$

$$((\sum_ix_i)+1)^2$$

$$(sum+1)^2$$

于是我们得到一段序列的值为其 $(sum+1)^2$，先不考虑 $m$ 段的限制，写出切成任意段的 DP 式子：

$$f_i=\min_j{f_j+(s_i-s_j+1)^2}$$

$$f_i=\min_j{-2s_js_i+(s_j-1)^2+f_j+(s_i+1)^2-1}$$

现在考虑限制段数，可以轻易的写出一个二维的上述 DP：$f_{i,j}$，其中第二维表示切了 $j$ 段。

首先显然有切得越多，即 $m$ 越大 $f_{n,m}$ 越小，然后意会一下切得越多式子减小的值越小，于是关于 $m$ 的函数 $f_n(m)$ 就是个下凸壳，直接上 wqs 二分斜率。

于是我们还是处理无段数限制的 DP，只不过每多切一段，即每次转移要多 $V_{mid}$ 的代价，即：

$$f_i=\min_j{-2s_js_i+(s_j-1)^2+f_j+(s_i+1)^2-1+V_{mid}}$$

然后这个式子就一脸的~~斜率优化~~李超树，直接莽就完了，时间复杂度 $O(\log^2)$，李超树空间还是 $O(n)$ 的没什么劣势。

发现两只 $\log$ 都带在值域上，但吸口氧还是不卡常，说起来除了离散化李超树也没啥常数可以卡。

[代码](https://www.luogu.com.cn/paste/4jhjan4o)

---

## 作者：gyyyyx (赞：2)

[题面](https://www.luogu.com.cn/problem/P4983)

前置知识：wqs 二分，斜率优化。[不会的看过来](https://www.luogu.com.cn/blog/s19418/dp-di-you-hua-fang-shi)

简单化简一下式子可以得到 $[l,r]$ 的值为 $(1+\sum\limits_{i=l}^rx_i)^2$。

设 $s_i=\sum\limits_{i=1}^ix_i$。

则原式化简为 $(s_r-s_{l-1}+1)^2$。

显然可以用动态规划。

设状态 $dp_{k,i}$ 表示前 $i$ 个数划分 $k$ 段的最优解。

则有转移方程：

$$
\begin{array}{l}
dp_{k,i}=\min\limits_{0\leq j<i}\{dp_{k-1,j}+(s_i-s_j+1)^2\}\\
\qquad\,=\min\limits_{0\leq j<i}\{dp_{k-1,j}+(s_i+1)^2-2(s_i+1)s_j+s_j^2\}
\end{array}
$$

发现这个式子可以用斜率优化，可以先将其看做一维（暂时理解为用滚动数组压缩至一维），整理后得：

$$dp_i=\min\limits_{0\leq j<i}\{dp_j+s_j^2-2(s_i+1)s_j\}+(s_i+1)^2$$

令 $x_i=2s_i,y_i=dp_i+s_i^2$，有：

$$dp_i=\min\limits_{0\leq j<i}\{y_j-(s_i+1)x_j\}+(s_i+1)^2$$

之后就是斜率优化的套路题了。

现在我们的时间优化到了 $O(nk)$，但还是不够。

设分成 $t$ 段的最优解为 $g(t)$。

根据数学知识，$\forall a,b\in\mathbb{R}^+,(a+b)^2\geq a^2+b^2$，因此分的段越多，答案会越小，即 $g(t)$ 随 $t$ 增大而减小。

不妨打个表，发现 $g(t)$ 形状不仅是单调下降的，还是一个下凸包形状的函数。

可以用 wqs 二分优化到 $O(n\log_2ans)$。

代码：

```cpp
#include<bits/stdc++.h>
#define LL long long
#define N 100005
using namespace std;
int n,m;LL s[N],dp[N];int f[N],q[N],l,r;
inline LL X(int i){return 2*s[i];}
inline LL Y(int i){return dp[i]+s[i]*s[i];}
inline long double Slope(int i,int j){
	return 1.0*(Y(j)-Y(i))/(X(j)-X(i));
}
inline LL K(int i){return s[i]+1;}
inline void DP(LL v){
	q[l=r=1]=0;
	for(int i(1);i<=n;++i){
		while(l<r&&Slope(q[l],q[l+1])<K(i)) ++l;
		dp[i]=dp[q[l]]+pow(s[i]-s[q[l]]+1,2)+v;f[i]=f[q[l]]+1;
		while(l<r&&Slope(q[r-1],q[r])>=Slope(q[r-1],i)) --r;
		q[++r]=i;
	}
}
LL ans;
int main(){
	scanf("%d%d",&n,&m);
	for(int i(1);i<=n;++i) scanf("%lld",&s[i]),s[i]+=s[i-1];
	LL l(0),r((s[n]+1)*(s[n]+1)),mid;
	while(l<=r){
		DP(mid=(l+r>>1));
		if(f[n]<=m){
			r=mid-1;
			ans=dp[n]-1ll*mid*m;
		}
		else l=mid+1;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：OrezTsim (赞：2)

upd. 2023.3.14 更新了关于单调队列判定条件的一些表述。

首先考虑不限制 $m$ 的怎么做。

式子可以化简为 $\min\{\sum\limits_{[l_i,r_i]}[(\sum\limits_{j=l_i}^{r_i} a_j)+1]^2\}$。

考虑 $dp_i$ 表示当前选到截止 $i$ 的一段，为 $[1,i]$ 的最小代价。

那么枚举上一个点 $1 \le j < i$，则 $dp_i=\min\{dp_j+\text{cost}(j+1,i)\}$。

$\text{cost}(j+1,i)$ 表示 $[j+1,i]$ 对于答案的贡献，即 $[(\sum\limits_{p=j+1}^ia_p)+1]^2$。

令 $s_i=\sum\limits_{j=1}^ia_j$，拆开式子。

$dp_i=\min\{dp_j+(s_i-s_j)^2+2(s_i-s_j)+1\}$。

进一步拆开得到

$dp_i=\min\{dp_j+s_i^2+s_j^2-2s_is_j+2s_i-2s_j+1\}$

看到同时含 $i$ 和 $j$ 项的乘积 $s_is_j$，考虑斜率优化。

设 $1 \le j_1 < j_2 < i \le n$，且 $j_2$ 优于 $j_1$。

则有

$dp_{j_1}+s_i^2+s_{j_1}^2-2s_is_{j_1}+2s_i-2s_{j_1}+1 \ge dp_{j_2}+s_i^2+s_{j_2}^2-2s_is_{j_2}+2s_i-2s_{j_2}+1$

即

$dp_{j_1}+s_{j_1}^2-2s_is_{j_1}-2s_{j_1} \ge dp_{j_2}+s_{j_2}^2-2s_is_{j_2}-2s_{j_2}$

把含 $i$ 的项提到左边，其余提到右边。

$2s_i(s_{j_2}-s_{j_1}) \ge (dp_{j_2}+s_{j_2}^2-2s_{j_2})-(dp_{j_1}+s_{j_1}^2-2s_{j_1})$

同时除以 $(s_{j_2}-s_{j_1})$，得

$2s_i \ge \dfrac{(dp_{j_2}+s_{j_2}^2-2s_{j_2})-(dp_{j_1}+s_{j_1}^2-2s_{j_1})}{s_{j_2}-s_{j_1}}$

这就是 $j_2 > j_1$ 且优于 $j_1$ 的条件。

发现右边一个与 $s_{j_2}$ 有关，一个与 $s_{j_1}$ 有关，可以看作一个函数，维护一个单调队列即可。

接下来，我们看到 $m$ 限制，很自然地想到 wqs 二分。

设 $f(i)$ 表示强制选 $i$ 个区间的最小代价，发现 $f(i)$ 单调递减且 $f(i)-f(i+1)>f(i+1)-f(i+2)$。

因为如果 $f(i)-f(i+1) < f(i+1)-f(i+2)$，就有把 $f(i+1) \rightarrow f(i+2)$ 的区间变化换到 $f(i) \rightarrow f(i+1)$ 处才满足$f(i)$ 为强制选 $i$ 个区间的最小代价的定义。

我们确定了这玩意儿可以用 wqs 二分做，且这个图像呈下凸壳的左半部分（可画图找规律）。

也就是其斜率左侧小，右侧大。

我们二分到一个斜率，就可以进行一次 DP，来获得当前的最小代价（即截距）。

加上 $m \times mid$ 就可以获得真实的代价。

（当然，对于和 $m$ 不为同一斜率的点无法还原其答案，但是由于其答案最后肯定会被更新为与 $m$ 同一条直线上的答案，所以没关系）

除此之外，由于当前要在答案最小的情况下，选择区间最少的方案。

那么考虑到当前答案从更早的地方转移过来一定更优，那么加强判定条件，改成 $>$。

没了。

```cpp
#include <bits/stdc++.h>
#define int long long
#define fi first
#define se second
using namespace std;

const int N = 1e5 + 10;
int n, m, a[N], sum[N], q[N];
pair <int, int> dp[N];

inline int y(int j1, int j2) {
  return (sum[j2] * sum[j2] - 2 * sum[j2] + dp[j2].fi) -
  (sum[j1] * sum[j1] - 2 * sum[j1] + dp[j1].fi);
}

inline int x(int j1, int j2) {
  return sum[j2] - sum[j1];
}

inline pair <int, int> check(int mid) {
  int l = 1, r = 1;
  for (int i = 1; i <= n; ++i) {
    while (l < r && 2 * sum[i] * x(q[l], q[l + 1]) > y(q[l], q[l + 1])) ++l;
    dp[i].fi = dp[q[l]].fi + (sum[i] - sum[q[l]] + 1) * (sum[i] - sum[q[l]] + 1) - mid, dp[i].se = dp[q[l]].se + 1;
    while (l < r && y(q[r], i) * x(q[r - 1], q[r]) <= y(q[r - 1], q[r]) * x(q[r], i)) --r; q[++r] = i;
  }
  return dp[n];
}

signed main() {
  ios_base::sync_with_stdio(false); cin.tie(0), cout.tie(0);
  cin >> n >> m; for (int i = 1; i <= n; ++i) cin >> a[i], sum[i] = sum[i - 1] + a[i];
  int l = -1e18, r = 0, res = 0;
  while (l <= r) {
    int mid = (l + r) >> 1; auto tmp = check(mid);
    if (tmp.se <= m) res = tmp.fi + m * mid, l = mid + 1;
    else r = mid - 1;
  }
  cout << res << endl;
  return 0;
}
```

---

## 作者：Mars_Dingdang (赞：1)

P5308 的翻版，WQS 二分与斜率优化好题（这样的题真不多啊）。

## 题目大意
定义一段长度为 $n$ 的序列的值为
$$\dfrac{\left ( (\sum\limits_{i=1}^n x_i\times \overline{x}) +\overline x\right )^2}{\overline x^2}$$
现在给定一段长度为 $n$ 的序列,现在要求将它分成 $m$ 段，使得每一段的值的总和最小，求出这个最小值。

## 大体思路
首先，将刚刚那个恶心的式子化开：
$$\dfrac{\left ( (\sum\limits_{i=1}^n x_i\times \overline{x}) +\overline x\right )^2}{\overline x^2}=\dfrac{\left ( \overline{x}\times(\sum\limits_{i=1}^n x_i) +\overline x\right )^2}{\overline x^2}=\left(1+\sum_{i=1}^nx_i\right)^2$$

显然，这个式子在分段数量越少时越小，因为产生的 $x_i\times x_j$ 项会越少。由于限制恰好为 $m$ 段，考虑使用 WQS 二分。假设我们现在分割了 $t$ 段，每段的值为 $w_i$，考虑将原题的强约束问题转换为以下无约束问题：
$$\min \sum_{i=1}^tw_i+c(t-m)$$
其中 $c$ 是一个常数。可以用反证法证明，当无约束问题的最优解使得 $t=m$ 时，这个解也是原问题的最优解。将上述式子进一步化开，去掉常量 $c\times m$，等价于
$$\min \sum_{i=1}^tw_i+ct\Leftrightarrow \min \sum_{i=1}^t(w_i+c)$$
这相当于每一段的值在原有基础上增加了 $c$。这样，当 $c$ 越大时，会导致最优分段数变小，因此满足单调关系，可以对 $c$ 进行二分，找到最大的 $c$ 使得分段数 $\ge m$。

然后，考虑如何求出最优分段。设 $f_i$ 表示以 $i$ 位置结尾进行分段的最小代价，则 $f_i=\min_{j\in [1, i)}\{f_j+(sum_i-sum_j+1)^2+c\}$，将只包含 $j$ 的移项可得 $f_j+sum_j^2-2sum_j=2sum_i\times sum_j+f_i-(sum_i+1)^2-c$，对比 $y=kx+b$，得到：
$$\begin{cases}y=f_j+sum_j^2-2sum_j\\k=2sum_i\\x=sum_j\\b=f_i-(sum_i+1)^2-c\end{cases}$$
对于最优分段数，可以用数组 $g$ 维护，$g_i=g_j+1$，最后判断是否有 $g_n\ge m$ 即可。

且斜率 $slope=\dfrac{y_1-y_2}{x_1-x_2}$，套用斜率优化模板维护凸壳即可，单次计算的复杂度 $O(n)$，加上 WQS 二分的总复杂度为 $O(n\log \omega)$。需要注意的是，由于所求的多了 $ct=c\times m$，最后需要从 $f_n$ 中减去这一部分。

## 完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef long double db;
typedef pair<int, int> PII;
const int maxn = 1e5 + 5;
const ll inf = 1e18;
const db eps = 1e-8;
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;
ll n, m, f[maxn], g[maxn], q[maxn], sum[maxn], l, r;
ll X(int j) {return sum[j];}
ll Y(int j) {return f[j] + sum[j] * sum[j] - 2 * sum[j];}
db K(int i) {return 2.0 * sum[i];}
db slope(int i, int j) {
	return (Y(i) - Y(j)) * 1.0 / (X(i) - X(j));
}
inline bool check(ll cpu) { // cost per unit
	memset(f, 0x3f, sizeof f);
	memset(g, 0, sizeof g);
	f[0] = 0;
	q[l = r = 1] = 0;
	rep(i, 1, n) {
		while(l < r && slope(q[l], q[l + 1]) < K(i) + eps) l ++;
		int j = q[l];
		f[i] = f[j] + (sum[i] - sum[j] + 1) * (sum[i] - sum[j] + 1) + cpu;
		g[i] = g[j] + 1;
		while(l < r && slope(q[r], q[r - 1]) > slope(i, q[r])) r --;
		q[++r] = i;
	}
	return g[n] >= m;
}
int main () {
	read(n); read(m);
	rep(i, 1, n) {
		ll x; read(x);
		sum[i] = sum[i - 1] + x;
	}
	ll L = 0, R = inf, bst = 0;
	while(L <= R) {
		ll mid = (L + R) >> 1;
		if(check(mid)) bst = mid, L = mid + 1;
		else R = mid - 1;
	}
	check(bst);
	writeln(f[n] - m * bst);	
	return 0;
}
```

---

## 作者：eee_hoho (赞：1)

首先对原式进行化简可得
$$\frac{\left((\sum\limits_{i=1}^{n}x_i×\bar x)+\bar x\right)^2}{\bar x^2}=(\sum_{i=1}^nx_i+1)^2$$

然后设$g(i)$表示序列划分成$i$段的最小值，因为$a^2+b^2>(a+b)^2$，所以$g$函数是凸的，于是可以使用wqs二分。

定义$F(i)$表示在分一段会多出$K$的代价下，分成$i$段的最小值。

我们二分斜率$K$，然后我们要找到一个最小的$F(i)$。

然后考虑把$F(i)$转化为好求的东西，设$f_i$表示前$i$个数分成若干段的最小值，在转移的时候额外记录一个$pre_i$表示前i个数得到最小值的时候分成了多少段，于是可以写出状态转移方程：

$$f_i=Min_{j=0}^{i-1}f_j+(\sum_{k=j+1}^ix_k+1)^2+K$$

记$s_i=\sum_{j=1}^ix_j$，则有

$$f_i=Min_{j=0}^{i-1}f_j+(s_i-s_j)^2+K$$

$$f_i=Min_{j=0}^{i-1}f_j+s_i^2+s_j^2-2s_is_j+2s_i-2s_j+1+K$$

当前需要更新的点为$i$，假设存在一个决策点$k<j$满足$k$比$j$优，那么

$$f_k+s_i^2+s_k^2-2s_is_k+2s_i-2s_k+1+K<f_j+s_i^2+s_j^2-2s_is_j+2s_i-2s_j+1+K$$

$$f_k+s_k^2-2s_k-(f_j+s_j^2-2s_j)<2s_i(s_k-s_j)$$

而$s_k-s_j<0$，所以

$$\frac{f_k+s_k^2-2s_k-(f_j+s_j^2-2s_j)}{s_k-s_j}>2s_i$$

至此我们就可以对上述的dp式子进行斜率优化了。

**Code**
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
const int N = 1e5;
using namespace std;
int n,m,a[N + 5],s[N + 5],pre[N + 5],q[N + 5];
long long ans,f[N + 5];
long long X(int x)
{
    return f[x] + 1ll * s[x] * s[x] - 2 * s[x];
}
double slope(int x,int y)
{
    return 1.0 * (X(x) - X(y)) / (s[x] - s[y]);
}
int check(long long k)
{
    int l = 1,r = 0;
    q[++r] = 0;
    for (int i = 1;i <= n;i++)
    {
        while (l < r && slope(q[l],q[l + 1]) <= 2 * s[i])
            l++;
        f[i] = X(q[l]) + 1ll * s[i] * s[i] - 2ll * s[i] * s[q[l]] + 2 * s[i] + 1 + k;
        pre[i] = pre[q[l]] + 1;
        while (l < r && slope(q[r],q[r - 1]) >= slope(q[r],i))
            r--;
        q[++r] = i;
    }
    return pre[n];
}
int main()
{
    scanf("%d%d",&n,&m);
    for (int i = 1;i <= n;i++)
        scanf("%d",&a[i]),s[i] = s[i - 1] + a[i];
    long long l = 0,r = 1e15,mid;
    while (l <= r)
    {
        mid = l + r >> 1;
        if (check(mid) >= m)
            l = mid + 1,ans = f[n] - 1ll * m * mid;
        else
            r = mid - 1;
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：lahlah (赞：0)


### 论文
[浅析一类二分方法](http://www.doc88.com/p-949564862405.html)
### 算法讲解
#### 例题
![在这里插入图片描述](https://img-blog.csdnimg.cn/2020091618342172.png#pic_center)

首先不考虑限制是一个很简单的斜率优化板子

加上$k$之后再用斜率优化就是$O(nk)$的

如果$k,n$同阶显然做不了

考虑怎么优化这个问题

这个时候就要用wqs二分了

#### wqs二分
设$f(k)$表示分成$k$段的答案

通过~~打表~~严格证明可以发现$(x,f(x))$是个凸壳 **（斜率单调）**


先假设这是个上凸壳

二分一个$mid$，表示直线的斜率

然后用这条直线去切这个凸壳，假设交点为$(x,f(x))$

显然这个点可以表示为$(x,mid*x+g(mid))$,$g(mid)$为截距(带入直线)

那么$f(x) = mid * x + g(mid)$

$$f(x) = mid * x + g(mid)$$

$$g(mid) = f(x) - mid * x$$


然后这个$g(mid)$可以直接用斜率优化跑出来,因为要满足的也是g(x)最大/最小。

最后在通过$g(mid)+x*mid$算出$f(k)$

显然这个可以二分$mid$,看$g(mid)$分成了几段，然后继续二分$mid$

计算$g$的时候只需要转移的时候每次多减一个$mid$就行了

所以时间复杂度为$O(nlogN)$

讲讲这题吧
[luogu P4983 忘情
](https://www.luogu.com.cn/problem/P4983)

把这一坨柿子化简一下就是

$$(1+\sum x_i)^2$$

$f_i=\max(f_j+(s_i-s_j+1)^2)$

$\ \ \ \ =\max(f_j+(s_i+1)^2-2*(s_i +1)*s_j+{s_j}^2)$

$\ \ \ \ =\max(f_j-2*(s_i +1)*s_j+{s_j}^2)+(s_i+1)^2$

$\ \ \ \ f_i -(s_i+1)^2 + 2(s_i +1)s_j=f_j+{s_j}^2$

设

$y_j=f_j+{s_j}^2$

$x_j=s_j$

$k_i=2(s_i+1)$

$c_i=f_i -(s_i+1)^2$

$y_j=k_ix_j+c_i$

要$c_i$最大，显然是个斜率优化

直接rush就好了

至于分成$k$段

通过~~打表~~我不会的证明可以发现$f(n,k)$是凸的

然后直接wqs二分即可

写之前要想一下mid是加上还是减去

这一题想想可以发现，加得越多，分得段数越少

所以如果分得段数$>k$就要$l=mid$

code:
```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 400005
using namespace std;
ll f[N], s[N], cnt[N], q[N];
int n, m;
double y(int i) {return f[i] + s[i] * s[i]; }
double x(int i) {return s[i]; }
double k(int i) {return 2.0 * (s[i] + 1); }
double slope(int i, int j) {
	return (y(i) - y(j)) / (x(i) - x(j));
}
int check(ll mid) {//斜率优化计算DP值  g(mid) 
	int l = 0, r = 0;
	for(int i = 1; i <= n; i ++) {
		while(l < r && slope(q[l], q[l + 1]) < k(i)) l ++;
		int j = q[l];
		f[i] = f[j] + (s[i] - s[j] + 1) * (s[i] - s[j] + 1) + mid;//加mid 
		cnt[i] = cnt[j] + 1;
		while(l < r && slope(q[r - 1], q[r]) > slope(q[r], i)) r --;
		q[++ r] = i;
	}
	return cnt[n] > m;//注意这里，如果分得段数>m说明加得不够 
}
int main() {
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i ++) scanf("%lld", &s[i]), s[i] += s[i - 1];
	ll l = 0, r = (1ll << 61);
	while(l + 1 < r) {//二分斜率 
		ll mid = (l + r) >> 1;
		if(check(mid)) l = mid;
		else r = mid;
	}	
	check(r);//最后算一下段数 
	printf("%lld", f[n] - r * m);//减去多加的 
	return 0;
} 
```





---

## 作者：issue_is_fw (赞：0)

[LINK](https://www.luogu.com.cn/problem/P4983)

~~为什么叫$wqs$二分呢?忘情二分显然更好听~~

**题意**

我们定义一段序列的值为

$\frac{((\sum\limits_{i=1}^nx_i*\bar x)+\bar x)^2}{\bar x^2}$

给定一段长度为$n$的数组,分成$m$段,最小化每段的和值。

---

$$
\frac{((\sum\limits_{i=1}^nx_i*\bar x)+\bar x)^2}{\bar x^2}$$
$$=(1+\sum\limits_{i=1}^nx_i)^2$$
$$=1+(\sum\limits_{i=1}^nx_i)^2+2*\sum\limits_{i=1}^nx_i
$$

定义$f[i][k]$表示前$i$个数分成$k$段的最小和值

$f[i][k]=f[j][k-1]+(pre_i-pre_j)^2+2*(pre_i-pre_j)+1$

直接$dp$是$O(n^2k)$的,我们稍微化简一下

$2*pre_i*pre_j+f[i][k]-pre_i^2-2*pre_i-1=f[j][k-1]+pre_j^2-2*pre_j$

考虑把$2*pre_i$看作斜率,$pre_j$看作自变量,等式右边看作因变量

那么现在斜率固定,所以我们需要找到一个点$(pre_j,f[j][k-1]+pre_j^2-2*pre_j)$作直线最小化截距

维护一个斜率为正的下凸壳即可.由于$2*pre_i$为正且递增,所以有单调性,用单调队列维护

利用斜率优化可以在$O(nk)$的时间内得到解

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int maxn = 2e5+10;
int f[1009][1009],n,m,a[maxn],pre[maxn];
int head = 1, tail = 0, q[maxn];
int x(int i){ return pre[i]; }
int y(int i,int k){ return f[i][k]+pre[i]*pre[i]-2*pre[i]; }
double slove(int i,int j,int k)
{
	return ( 1.0*y(i,k)-y(j,k) )/( 1.0*x(i)-x(j) );
}
signed main()
{
	cin >> n >> m;
	for(int i=1;i<=n;i++)	cin >> a[i], pre[i] = ( pre[i-1]+a[i] );
	for(int i=1;i<=n;i++)	f[i][1] = pre[i]*pre[i]+2*pre[i]+1;
	for(int k=2;k<=m;k++)
	{
		head = 1, tail = 0, q[++tail] = k-1;
		for(int i=k;i<=n;i++)//前i个数分成k段 
		{
			while( head+1<=tail && slove( q[head],q[head+1],k-1 )<=2*pre[i] )	head++;
			int las = q[head];
			f[i][k] = f[las][k-1]+( pre[i]-pre[las] )*( pre[i]-pre[las] )+2*( pre[i]-pre[las] )+1;
			while( tail-1>=head && slove( q[tail-1],q[tail],k-1 ) >= slove( q[tail],i,k-1 )  )	tail--;
			q[++tail] = i;
		}
	}
	cout << f[n][m];
}
```

复杂度还是不够优秀...这种限制选段数的问题,那就$wq$(忘情)二分吧

定义$g(i)$表示数组分成$i$段时的最小代价

很明显分的段数越多,减小的越不明显,但一直在减小

~~我们大胆猜测~~这是个斜率为负的下凸函数

但这个下凸函数我们是求不出来的(只能斜率优化$O(nk)$计算)

但$wqs$二分的精髓就是不求这个凸包,所以操作只为了求$g(m)$

考虑引入一条斜率为$k$的直线去切这个凸包

显然当$k$增大时,切点的$x$坐标也增大,否则减小,**这就具有单调性**

也就是说,我们可以二分$k$,然后去求出切点在哪个位置,根据求出切点的$x$坐标和$m$的位置关系来确定向左/右二分

设这条直线为$y=kx+b$,显然如果把所有$(x,g(x))$代入,若得到最大的$b$就是切点

$b=g(x)-kx$

这个的意义可以看成,$x$每增加一(每多分一段),值减小$k$

上面就是$wqs$的精髓,这样我们相当于没有限制,直接去$dp$

定义$f[i]$表示$[1,i]$分为若干段的最小权值和

$f[i]=f[j]+(pre_i-pre_j)^2+2*(pre_i-pre_j)+1-k$

$2*pre_i*pre_j+f[i]-pre_i^2-2*pre_i-1+k=f[j]+pre_j^2-2*pre_j$

斜率优化可以$O(n)得到$$f[n]$

同时在$dp$过程中保存$f[n]$是把序列分成了$x$段

也就是我们求出了切点为$(x,f[n])$,根据相对位置再去二分斜率$k$

最后,加上$m*k$,因为这个每段的权值是不用减去$k$的

然后就是$O(nlog())$级别的复杂度啦

然而如果在斜率优化的两个地方中中写等于号会$wa10$,有知情人和我说下,不胜感激

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int maxn = 2e5+10;
int f[maxn],line[maxn],n,m,a[maxn],pre[maxn];
int head = 1, tail = 0, q[maxn];
int x(int i){ return pre[i]; }
int y(int i){ return f[i]+pre[i]*pre[i]-2*pre[i]; }
double slove(int i,int j)
{
	return ( 1.0*y(i)-y(j) )/( 1.0*x(i)-x(j) );
}
void isok(int k)
{
	head = 1, tail = 0, q[++tail] = 0;
	for(int i=1;i<=n;i++)
	{
		while( head+1<=tail && slove( q[head],q[head+1] )<2*pre[i] )	head++;
		int las = q[head];
		f[i] = f[las]+( pre[i]-pre[las] )*( pre[i]-pre[las] )+2*( pre[i]-pre[las] )+1-k;
		line[i] = line[las]+1;
		while( tail-1>=head && slove( q[tail-1],q[tail] ) > slove( q[tail],i )  )	tail--;
		q[++tail] = i;
	}	
}
signed main()
{
	cin >> n >> m;
	for(int i=1;i<=n;i++)	cin >> a[i], pre[i] = ( pre[i-1]+a[i] );
	int l = -1e16, r = 0, ansslove = 0;
	while( r>=l )
	{
		int mid = ( l+r )/2;
		isok( mid );
		if( line[n]<=m )	l = mid+1, ansslove = mid;
		else	r = mid-1; 
	}
	isok( ansslove ); 
	cout << f[n]+m*ansslove;
}
```

---

## 作者：chihik (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P4983) & [更好的体验](http://chihik.cf/post/p4983/)

首先看一下每段的值：

$$
\frac{\left((\sum\limits_{i=1}^{n}x_i×\bar x)+\bar x\right)^2}{\bar x^2}
$$

$$
\frac{(\sum\limits_{i=1}^{n}x_i×\bar x)^2+2\bar x(\sum\limits_{i=1}^{n}x_i×\bar x)+\bar x^2}{\bar x^2}
$$

$$
\sum\limits_{i=1}^{n}x_i^2+2\sum\limits_{i=1}^{n}x_i+1
$$

$$
(\sum_{i=1}^nx_i+1)^2
$$

由 $(a+b)^2 \ge a^2+b^2$ 可以显然发现：分的段数越多，答案越小，并且每次分段减少的贡献单调不升。

说白了它就是一个凸函数，考虑 wqs 二分。

设当前二分的权重为 $k$ , 那么有：
$$
dp_i=\min_{0\le j < i} \{dp_j+(\text{Sum}_i-\text{Sum}_{j}+1)^2+k\}
$$

$$
dp_i=\min_{0\le j < i} \{dp_j + \text{Sum}_j^2-2\text{Sum}_j(\text{Sum}_i+1)\}+(\text{Sum}_i+1)^2+k
$$

设有两个决策点 $j,k (j < k)$ , 且 $j$ 优于 $k$。
$$
dp_j + \text{Sum}_j^2-2\text{Sum}_j(\text{Sum}_i+1) < dp_k + \text{Sum}_k^2-2\text{Sum}_k(\text{Sum}_i+1)
$$

$$
(dp_j + \text{Sum}_j^2)-(dp_k+\text{Sum}_k^2)< 2(\text{Sum}_i+1)(\text{Sum}_j-\text{Sum}_k)
$$

可以斜率优化，每次 dp 的复杂度为 $\mathcal O(n)$。

总的时间复杂度为 $\mathcal O(n\log w)$。

还有，这道题卡精度。

```cpp
#include <cstdio>
#include <cstring>
#define LL long long
#define Inf 1e18
#define eps 1e-10

const int MAXN = 100000;
int n , m , x[ MAXN + 5 ]; LL Sum[ MAXN + 5 ];


int cnt[ MAXN + 5 ]; LL dp[ MAXN + 5 ];
int Que[ MAXN + 5 ] , Head , Tail;

LL fx( int x ) { return Sum[ x ]; }
LL fy( int x ) { return dp[ x ] + Sum[ x ] * Sum[ x ]; }
LL dx( int x , int y ) { return fx( x ) - fx( y ); }
LL dy( int x , int y ) { return fy( x ) - fy( y ); }
double Slope( int x , int y ) { return dy( x , y ) * 1.0 / dx( x , y ); }

LL check( LL k ) {
	Head = 1 , Tail = 0; Que[ ++ Tail ] = 0;
	for( int i = 1 ; i <= n ; i ++ ) {
		for( ; Head + 1 <= Tail && Slope( Que[ Head ] , Que[ Head + 1 ] ) + eps < 2 * ( Sum[ i ] + 1 ) ; Head ++ );
		dp[ i ] = dp[ Que[ Head ] ] + ( Sum[ i ] - Sum[ Que[ Head ] ] + 1 ) * ( Sum[ i ] - Sum[ Que[ Head ] ] + 1 ) + k; cnt[ i ] = cnt[ Que[ Head ] ] + 1;
		for( ; Head + 1 <= Tail && Slope( Que[ Tail - 1 ] , Que[ Tail ] ) + eps > Slope( Que[ Tail ] , i ) ; Tail -- );
		Que[ ++ Tail ] = i;
	}
	return cnt[ n ] > m;
}

int main( ) {
	scanf("%d %d",&n,&m);
	for( int i = 1 ; i <= n ; i ++ ) scanf("%d",&x[ i ]) , Sum[ i ] = Sum[ i - 1 ] + x[ i ];
	
	LL l = 0 , r = Inf , Ans;
	for( ; l <= r ; ) {
		LL Mid = ( l + r ) >> 1;
		if( check( Mid ) ) l = Mid + 1;
		else r = Mid - 1 , Ans = Mid;
	}
	check( Ans );
	printf("%lld\n", dp[ n ] - Ans * m );
	return 0;
}
```


---


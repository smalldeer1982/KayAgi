# [JSOI2015] 串分割

## 题目背景

JYY 每天都会在地铁上度过很长的时间。

为了打发时间，JYY 随手写下了一个很长的环形的数字字符串，并且陷入了沉思。

## 题目描述

JYY 写下了一个长度为 $N$ 的，仅包含 `1`，`2`，……，`9` 这 $9$ 种不同字符的环形字符串 $S$。JYY 希望把 $S$ 进行 $K$ 次切割，并分成 $K$ 个非空的子串。对于每一个子串，由于其仅包含数字，我们可以将其看成一个十进制数——因此
经过 $K$ 次切割，JYY 可以得到 $K$ 个不同的十进制数。JYY 希望他得到的这 $K$ 个数中，最大的那一个尽量小。

## 说明/提示

对于 $100\%$ 的数据，$3\leq N\leq 2\times 10^5$，$2\leq K\leq N$。

## 样例 #1

### 输入

```
4 2
4321```

### 输出

```
32```

# 题解

## 作者：Alex_Wei (赞：4)

> [P6095 [JSOI2015]串分割](https://www.luogu.com.cn/problem/P6095)

因为字符不含 $0$，所以贪心让最大位数最小。答案串长度 $L = \left \lceil \dfrac n k \right\rceil$。

答案满足可二分性。我们二分答案在后缀数组中的排名。破环成链，枚举 $L$ 个起始点并判断是否可行。假设当前匹配到 $i$，若 $s[i, i + L - 1]$ 的排名不大于二分的答案，那么就匹配 $L$ 位，否则匹配 $L - 1$ 位。若进行 $k$ 次匹配后总匹配位数不小于 $n$ 则可行。

若可匹配 $L$ 位时匹配 $L - 1$ 位，则下一次最多匹配 $L$ 位，这与首先匹配 $L$ 位时下一次匹配的最劣情况，即匹配 $L - 1$ 位，效果相同。因此贪心正确。

进一步地，比较两个长度为 $L$ 的字符串时，我们不需要求 LCP 并比较下一个字符。可直接比较它们对应的后缀。问题在于也许 $s[i, i + L - 1]$ 和 $s[j, j + L - 1]$ 相等，其中 $j$ 是排名为当前二分值的后缀开始位置，但 $suf_i > suf_j$，这使得我们认为只能匹配 $L - 1$ 位而非 $L$ 位。

但其实没有关系，因为若 $s[j, j + L - 1]$ 作为答案串可行，则二分排名最大的以 $s[j, j + L - 1]$ 作为前缀的后缀时必然可行。

时间复杂度 $\mathcal{O}(n\log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
bool Mbe;
constexpr int N = 4e5 + 5;
int n, k, len;
char s[N];
int rk[N], ork[N], sa[N], buc[N], id[N];
bool cmp(int a, int b, int w) {return ork[a] == ork[b] && ork[a + w] == ork[b + w];}
void build() {
  int m = 1 << 7, p = 0;
  for(int i = 1; i <= n; i++) buc[rk[i] = s[i]]++;
  for(int i = 1; i <= m; i++) buc[i] += buc[i - 1];
  for(int i = n; i; i--) sa[buc[rk[i]]--] = i;
  for(int w = 1; ; w <<= 1, m = p, p = 0) {
    for(int i = n - w + 1; i <= n; i++) id[++p] = i;
    for(int i = 1; i <= n; i++) if(sa[i] > w) id[++p] = sa[i] - w;
    memset(buc, 0, sizeof(buc));
    memcpy(ork, rk, sizeof(rk));
    p = 0;
    for(int i = 1; i <= n; i++) buc[rk[i]]++;
    for(int i = 1; i <= m; i++) buc[i] += buc[i - 1];
    for(int i = n; i; i--) sa[buc[rk[id[i]]]--] = id[i];
    for(int i = 1; i <= n; i++) rk[sa[i]] = cmp(sa[i - 1], sa[i], w) ? p : ++p;
    if(p == n) break;
  }
}
bool Med;
int main() {
  fprintf(stderr, "%.4lf\n", (&Mbe - &Med) / 1048576.0);
#ifdef ALEX_WEI
  freopen("1.in", "r", stdin);
  freopen("1.out", "w", stdout);
#endif
  cin >> n >> k >> s + 1, len = (n - 1) / k + 1;
  for(int i = 1; i <= n; i++) s[i + n] = s[i];
  n <<= 1, build();
  int l = 1, r = n, m = n >> 1;
  while(l < r) {
    int mid = l + r >> 1, ok = 0;
    for(int i = 1; i <= len; i++) {
      int cur = 0;
      for(int j = 1; j <= k; j++) {
        int p = (i + cur - 1) % m + 1;
        if(rk[p] <= mid) cur += len;
        else cur += len - 1;
      }
      ok |= cur >= m;
    }
    if(ok) r = mid;
    else l = mid + 1;
  }
  for(int i = 0; i < len; i++) cout << s[sa[l] + i];
  return cerr << "Time: " << clock() << "\n", 0;
}
/*
2022/7/2
start coding at 18:24
finish debugging at 18:36
*/
```

---

## 作者：Hoks (赞：2)

## 前言
比较简单的 $\mathrm{SA}$ 题，适合刚入门喵。

广告：[『从入门到入土』串串学习笔记](https://www.luogu.com.cn/article/dv6dig1o)。
## 思路分析
首先题目说要把长度为 $n$ 的数字串切成 $k$ 段使得值最大的最小。

不难发现切出来的数字串长度只可能为 $\lceil\frac{n}{k}\rceil,\lceil\frac{n}{k}\rceil-1$。

显然的是长度为 $\lceil\frac{n}{k}\rceil+1$ 的数字串肯定比长度为 $\lceil\frac{n}{k}\rceil$ 的字符串大。

所以我们只需要考虑是数字串长度分为 $\lceil\frac{n}{k}\rceil$ 更优还是 $\lceil\frac{n}{k}\rceil-1$ 更优即可。

貌似没有什么好的处理方法了？

发现这些断出来的字符串的具体大小并不确切知晓，很影响做题。

不难发现如果有一种方案能断出的最大的值为 $x$。

那么我们对于 $y,y\ge x$ 必然是存在方案的。

也就是答案是数字串大小具有单调性。

考虑二分出数字串大小，接着尝试 $check$。

考虑贪心，能断为 $\lceil\frac{n}{k}\rceil$ 的就断为 $\lceil\frac{n}{k}\rceil$，不能的就断为 $\lceil\frac{n}{k}\rceil-1$。

思索下为什么是对的。

考虑反证，如果能断为 $\lceil\frac{n}{k}\rceil$ 的断为了 $\lceil\frac{n}{k}\rceil-1$，那么下一次可以断 $\lceil\frac{n}{k}\rceil$ 的话，其断出的总长度为 $2\times\lceil\frac{n}{k}\rceil-1$。

但如果我们考虑把能断为 $\lceil\frac{n}{k}\rceil$ 的都断为 $\lceil\frac{n}{k}\rceil$，下一次最短也会断 $\lceil\frac{n}{k}\rceil-1$，其总长度 $x$ 必然满足 $x\ge2\times\lceil\frac{n}{k}\rceil-1$。

也就是把能断为 $\lceil\frac{n}{k}\rceil$ 的全断严格不劣于把他断为 $\lceil\frac{n}{k}\rceil-1$。

接着考虑怎么比较数字串大小，考虑二分出排名 $rk$，那么从 $i$ 开始长度为 $\lceil\frac{n}{k}\rceil/\lceil\frac{n}{k}\rceil-1$ 的串即为后缀 $i$ 的前缀。

又因为前缀的排名严格不大于原串，所以直接比较原后缀的排名与二分的排名即可。

最后要求输出最大值数字串，考虑存下排名的值输出这个排名的后缀长为 $\lceil\frac{n}{k}\rceil$ 的前缀即可。
## 代码
```cpp
#include <bits/stdc++.h>
#define mid ((l+r)>>1)
#define int long long
using namespace std;
const int N=4e5+10,mod=1e9+7,INF=0x3f3f3f3f3f3f3f3f;
int n,k,m,ans;char s[N];
namespace Fast_IO
{
    static char buf[1000000],*paa=buf,*pd=buf,out[10000000];int length=0;
    #define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
    inline int read()
    {
        int x(0),t(1);char fc(getchar());
        while(!isdigit(fc)){if(fc=='-') t=-1;fc=getchar();}
        while(isdigit(fc)) x=(x<<1)+(x<<3)+(fc^48),fc=getchar();
        return x*t;
    }
    inline void flush(){fwrite(out,1,length,stdout);length=0;}
    inline void put(char c){if(length==9999999) flush();out[length++]=c;}
    inline void put(string s){for(char c:s) put(c);}
    inline void print(int x)
    {
        if(x<0) put('-'),x=-x;
        if(x>9) print(x/10);
        put(x%10+'0');
    }
    inline bool chk(char c) { return !(c>='a'&&c<='z'||c>='A'&&c<='Z'||c>='0'&&c<='9'); }
    inline bool ck(char c) { return c!='\n'&&c!='\r'&&c!=-1&&c!=' '; }
    inline void rd(char s[],int&n)
    {
        s[++n]=getchar();
        while(chk(s[n])) s[n]=getchar();
        while(ck(s[n])) s[++n]=getchar();
        n--;
    }
}
using namespace Fast_IO;
namespace SA
{
    const int lim=20,ST=127;
    int sa[N],rk[N],old[N],c[N],h[N],st[lim+1][N];
    inline void get_SA()
    {
        m=ST;
        for(int i=1;i<=n;i++) ++c[rk[i]=s[i]];
        for(int i=2;i<=m;i++) c[i]+=c[i-1];
        for(int i=n;i>=1;i--) sa[c[rk[i]]--]=i;
        for(int k=1;k<=n;k<<=1)
        {
            int tot=0;
            for(int i=n-k+1;i<=n;i++) old[++tot]=i;
            for(int i=1;i<=n;i++) if (sa[i]>k) old[++tot]=sa[i]-k;
            for(int i=1;i<=m;i++) c[i]=0;
            for(int i=1;i<=n;i++) c[rk[i]]++;
            for(int i=2;i<=m;i++) c[i]+=c[i-1];
            for(int i=n;i>=1;--i) sa[c[rk[old[i]]]--]=old[i],old[i]=0;
            swap(rk,old);rk[sa[1]]=1;tot=1;
            for(int i=2;i<=n;i++) rk[sa[i]]=(old[sa[i]]==old[sa[i-1]]&&old[sa[i]+k]==old[sa[i-1]+k])?tot:++tot;
            if(tot==n) break;m=tot;
        }
    }
    inline void get_height()
    {
        for(int i=1,k=0,j;i<=n;i++)
        {
            if(k) --k;j=sa[rk[i]-1];
            while(s[i+k]==s[j+k]) k++;
            h[rk[i]]=k;
        }
    }
    inline void get_ST()
    {
        for(int i=1;i<=n;i++) st[0][i]=h[i];
        for(int j=1;j<=lim;j++)
            for(int i=1;i+(1<<j)-1<=n;i++)
                st[j][i]=min(st[j-1][i],st[j-1][i+(1<<j-1)]);
    }
    inline int lcp(int l,int r){int k=log2(r-l);l++;return min(st[k][l],st[k][r-(1<<k)+1]);}
}
using namespace SA;
signed main()
{
    read(),k=read();rd(s,n);for(int i=1;i<=n;i++) s[i+n]=s[i];n<<=1;get_SA();get_height();
    int l=1,r=n,len=((n>>1)-1)/k+1;
    while(l<=r)
    {
        int f=0;
        for(int i=1;i<=len;i++)
        {
            int cur=0;
            for(int j=1;j<=k;j++)
            {
                int x=(i+cur-1)%(n>>1)+1;
                if(rk[x]<=mid) cur+=len;
                else cur+=len-1;
            }f|=cur>=(n>>1);
        }if(f) ans=mid,r=mid-1;
        else l=mid+1;
    }
    for(int i=0;i<len;i++) put(s[sa[ans]+i]);
    genshin:;flush();return 0;
}
```

---

## 作者：xtx1092515503 (赞：2)

后缀数组一个很好的作用就是**可以用它来按照字典序二分字符串**~~~

首先，我们发现，一组切割的结果只会有长度为$\left\lceil\dfrac{n}{k}\right\rceil$及$\left\lceil\dfrac{n}{k}\right\rceil-1$的串——这是很显然的，因为只有这样才会让最大数尽量小。并且，最大数的长度必定是$\left\lceil\dfrac{n}{k}\right\rceil$。设$A=\left\lceil\dfrac{n}{k}\right\rceil$。

假设我们确定了最大数是$p$，那我们应该如何判断$p$是否合法呢？

显然我们可以随便找一个位置断环成链。我们设一个指针$tmp$指向当前最后一个子串结尾的位置（初始为断点）。如果$tmp$开头的后缀的字典序大于等于后缀$p$的字典序，显然这时如果我们选取$tmp$开头的$A$个字符的话，$p$就不会是最大的那个数了，故这时不得不选取$A-1$个数；否则，我们可以贪心地选取$A$个字符截成一个子串。之后，更新$tmp$到新子串的末尾。

我们思考一下为什么这个贪心是正确的：假如因为这边截了$A$个字符，下一次不得不截$A-1$个字符，则总共少截了一个字符，同这边截$A-1$个字符的最优情况（这次$A-1$个，下次$A$个）相同；而如果下次居然还能截出$A$个，那么就肯定更优辣；综上，贪心是正确的。

因此我们只需要枚举这个断开的位置即可。看上去这是$O(nk)$的，但是因为每$A$个字符中必定会切一刀，故实际上只需要枚举前$A$个位置即可。$A$个位置，check每个位置都要用$k$次，共$O(Ak)=O(n)$。

至于这个最大值吗，显然它具有单调性，可以二分；二分一个串，就是在后缀数组中二分rank。

因此总复杂度$O(n\log n)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=400100;
int n,m,all,A;
int x[N],y[N],buc[N],sa[N],rk[N];
char s[N];
bool mat(int a,int b,int k){
	if(y[a]!=y[b])return false;
	if((a+k<n)^(b+k<n))return false;
	if((a+k<n)&&(b+k<n))return y[a+k]==y[b+k];
	return true;
}
void SA(){
	for(int i=0;i<n;i++)buc[x[i]=s[i]]++;
	for(int i=1;i<=m;i++)buc[i]+=buc[i-1];
	for(int i=n-1;i>=0;i--)sa[--buc[x[i]]]=i;
	for(int k=1;k<n;k<<=1){
		int num=0;
		for(int i=n-k;i<n;i++)y[num++]=i;
		for(int i=0;i<n;i++)if(sa[i]>=k)y[num++]=sa[i]-k;
		for(int i=0;i<=m;i++)buc[i]=0;
		for(int i=0;i<n;i++)buc[x[y[i]]]++;
		for(int i=1;i<=m;i++)buc[i]+=buc[i-1];
		for(int i=n-1;i>=0;i--)sa[--buc[x[y[i]]]]=y[i];
		swap(x,y);
		x[sa[0]]=num=0;
		for(int i=1;i<n;i++)x[sa[i]]=mat(sa[i],sa[i-1],k)?num:++num;
		if(num>=n-1)break;
		m=num;
	}
	for(int i=0;i<n;i++)rk[sa[i]]=i;
}
bool che(int ip){
	for(int i=0;i<A;i++){
		int tmp=i;
		for(int j=0;j<all;j++){tmp+=A-(rk[tmp]>ip);if(tmp-i>=n)return true;}
	}
	return false;
}
int main(){
	scanf("%d%d",&n,&all),A=n/all+(n%all!=0);
	scanf("%s",s);
	for(int i=0;i<n;i++)s[n+i]=s[i];
	n<<=1,m='9';
	SA();
//	printf("%s\n",s);
//	for(int i=0;i<n;i++)printf("%d ",sa[i]);puts("");
	n>>=1;
//	for(int i=0;i<n;i++)printf("%d ",qwq[i]);puts("");
	int l=0,r=(n<<1)-1;
	while(l<r){
		int mid=(l+r)>>1;
		if(che(mid))r=mid;
		else l=mid+1;
	}
	for(int j=0;j<(n<<1);j++)if(rk[j]==r)for(int i=0;i<A;i++)putchar(s[j+i]);
	return 0;
} 
```


---

## 作者：xiezheyuan (赞：0)

这是一篇混在 SA 题解中的一篇 SAM 题解。

## 简要题意

给出一个由 $1\sim 9$ 构成的长度为 $N$ 的环形字符串 $S$。你需要将它划分为 $K$ 段，每一段可以看成一个十进制数。你需要求出最大段的最小值。

$3\leq N\leq 10^5,2\leq K\leq N$

## 思路

这道题并不适合使用 SAM 完成。

二分+贪心过程比较平凡，请移步其他题解。我们重点讲一下和 SAM 有关的部分。

首先将我们构造字符串 $s=S+S$，也就是破环成链。

然后相当于我们需要对于每一个给定的 $L$，找出 $s$ 中所有长度为 $L$ 的子串进行排名。

大部分认为这是 SA 的专利，其实 SAM 也是可以做的。

我们将 $s$  翻转。将字典序变成“后缀字典序”，方便用 parent tree 描述。

我们对于每一个 endpos 等价类，求出一个 $l_i$ 表示这个等价类表示的子串可能的一个左端点。这是可以 $O(N)$ 求的。

然后在 parent tree 上 dfs，就可以求出每一个 endpos 的排名（类似跳 trans 那样贪心）。

然后你需要写一个树剖，把子串挂在 endpos 等价类上。

然后这道题就做完了。

## 代码

```cpp
#include <bits/stdc++.h>
#define link __ytxy_ak_ioi
#define CLR(x) memset(x, 0, sizeof(x))
using namespace std;

const int N = 1e6 + 5, M = 10;

int trans[N << 1][M], link[N << 1], len[N << 1], cur, tot, endps[N], siz[N];

void extend(int c, int cnt){
	int x=cur;cur=(++tot);len[cur]=len[x]+1;endps[cnt] = cur;siz[cur] = 1;
	for(;(~x)&&(!trans[x][c]);x=link[x]) trans[x][c] = cur;
	if(!(~x)){link[cur]=0;return;}
	int y=trans[x][c];
	if(len[y]==len[x]+1){link[cur]=y;return;}
	int u=(++tot),d=y;
	link[u]=link[y];link[d]=link[cur]=u;len[u]=len[x]+1;
	for(int i=0;i<9;i++) trans[u][i] = trans[d][i];
	for(;(~x)&&(trans[x][c]==y);x=link[x]) trans[x][c] = u;
}

int n, k;
string s, s1;
bool vis[N << 1];
int lft[N << 1], rnk[N], rktt;
int son[N << 1], rev[N << 1], seg[N << 1], top[N << 1], sgtt = 1, dep[N << 1];
vector<int> ptr[N << 1];
vector<int> zyb[N << 1];

void count_siz(int u){
	for(int v : ptr[u]){
		count_siz(v);
		siz[u] += siz[v];
	}
}

int dfs1(int u){
	int szt = 1, tmp = 0;
	son[u] = 0;
	for(int v : ptr[u]){
		dep[v] = dep[u] + 1;
		int szv = dfs1(v);
		szt += szv;
		if(tmp < szv){
			tmp = szv;
			son[u] = v;
		}
	}
	return szt;
}

void dfs2(int u){
	if(son[u]){
		top[son[u]] = top[u];
		seg[son[u]] = ++sgtt;
		rev[sgtt] = son[u];
		dfs2(son[u]);
	}
	for(int v : ptr[u]){
		if(son[u] == v) continue;
		top[v] = v;
		seg[v] = ++sgtt;
		rev[sgtt] = v;
		dfs2(v);
	}
}

int find(int l, int r){
	int u = endps[r];
	while(true){
//		cout << u << ' ';
		if(!top[u] || len[link[top[u]]] < (r - l + 1)){
			int L = seg[top[u]], R = seg[u], ans = 0;
			while(L <= R){
                int mid = (L + R) >> 1;
                if(len[link[rev[mid]]] < (r - l + 1)) L = mid + 1, ans = mid;
                else R = mid - 1;
			}
            L = ans;
			return rev[L];
		}
		u = link[top[u]];
	}
}

int length;

void dfs(int u){
	sort(ptr[u].begin(), ptr[u].end(), [&](int x, int y){
		return s1[lft[x] - 1] < s1[lft[y] - 1];
	});
	if(length <= len[u] && length > len[link[u]]){
		int rkt = rktt + 1;
		for(int i : zyb[u]){
			rnk[i] = rkt;
			rktt++;
		}
		return;
	}
	for(int v : ptr[u]) dfs(v); 
}


bool check(int x){
	for(int i=1;i<=length;i++){
		int now = 0;
		for(int j=1;j<=k;j++){
			int pos = (i + now - 1) % n + 1;
			if(rnk[pos] <= x) now += length;
			else now += (length - 1);
		}
		if(now >= n) return true;
	}
	return false;
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	cin >> n >> k >> s;length = n / k + (bool)(n % k);
	s1 = s + s;reverse(s1.begin(), s1.end());link[0] = -1;
	for(unsigned i=0;i<s1.size();i++){
	    extend(s1[i] - '0' - 1, i + 1);
	}
	for(int i=1;i<=n;i++){
		int LFT = 0;
		for(int j=endps[i];j;j=link[j]){
			LFT += (len[j] - len[link[j]]);
			lft[j] = LFT;
			if(vis[j]) break;
			vis[j] = true;
		}
	}
	for(int i=1;i<=tot;i++) ptr[link[i]].push_back(i);
	count_siz(0);
	seg[0] = dep[0] = 1;top[0] = len[0] = 0;
	dfs1(0);dfs2(0);
	for(int i=1;i<=n;i++){
		int revt = i + length - 1;
		if(revt > n) revt -= n;
		revt = n - revt + 1;
		int u = find(i, i + length - 1);
		zyb[u].push_back(revt);
	}
	dfs(0);
	int L = 1, R = n;
	while(L < R){
		int mid = (L + R) >> 1;
		if(check(mid)) R = mid;
		else L = mid + 1;
	}
	reverse(s1.begin(), s1.end());
	int fir = 0;
	for(int i=1;i<=n;i++){
		if(rnk[i] == L){
			fir = i;
			break;
		}
	}
	for(int i=0;i<length;i++) cout << s1[(fir + i - 1)];
	return 0;
}

```

---

## 作者：LCat90 (赞：0)

> 给定环形数字字符串 $S$。把 $S$ 进行 $K$ 次切割，并分成 $K$ 个非空的子串。每一个子串将其看成一个十进制数。最小化这 $K$ 个数中的最大值。 

首先最终答案各个数的位数一定是尽量相同的。可以二分后缀排名，然后贪心 check：

将原串复制一份，枚举起始点。现在考虑将额外的 $1$ 分给哪些位置。其余都是 $len=\lfloor \frac{n}{k}\rfloor$。

如果 $rk(i) > x$，则一定只能是长为 $len$。否则可以。

证明：如果可以加一，就直接加。最后一定可以找到合法解。

考虑下一次使用 $len+1$ 而这一次使用 $len$，那和反过来是一样的；相反可能下一次取不到 $len+1$。

注意处理 $n \bmod k= 0$ 的情况。

```cpp
#include <bits/stdc++.h>
#define hacked puts("8")
#define int long long
using namespace std;
const int N = 6e5 + 5;
int n, a[N], sa[N], rk[N], tmp[N], ID[N], cnt[N], sb[N];
char s[N];
bool cmp(int x, int y, int z) { return tmp[x] == tmp[y] and tmp[x + z] == tmp[y + z]; }
void Suf_Arr(int len) {
	int m = 127;
	for(int i = 1;i <= len; ++i) ++cnt[rk[i] = s[i]];
	for(int i = 1;i <= m; ++i) cnt[i] += cnt[i - 1];
	for(int i = len;i >= 1; --i) sa[cnt[rk[i]]--] = i; 
	for(int opt = 1;;opt <<= 1) {
		int p = 0; 
		for(int i = len - opt + 1;i <= len; ++i) ID[++p] = i;
	    for(int i = 1;i <= len; ++i) if(sa[i] > opt) ID[++p] = sa[i] - opt; 
	    for(int i = 1;i <= m; ++i) cnt[i] = 0;
	    for(int i = 1;i <= len; ++i) ++cnt[sb[i] = rk[ID[i]]];
	    for(int i = 1;i <= m; ++i) cnt[i] += cnt[i - 1];
	    for(int i = len;i >= 1; --i) sa[cnt[sb[i]]--] = ID[i];   
	    memcpy(tmp + 1, rk + 1, sizeof tmp);  
	    p = 0;
	    for(int i = 1;i <= len; ++i) 
			rk[sa[i]] = cmp(sa[i], sa[i - 1], opt) ? p : ++p; 
		if(p == len) break ; m = p;
	}
	for(int i = 1;i <= len; ++i) rk[sa[i]] = i;
}
int h[N];
void Height() {
	for(int i = 1, p = 0;i <= 2 * n; ++i) {
		if(!rk[i]) continue ; if(p) --p; 
		while(s[i + p] == s[sa[rk[i] - 1] + p]) ++p;
		h[rk[i]] = p;
	}
}
int k, num, len;
bool check(int x) { 
	for(int i = 1;i <= len + 1; ++i) {
		int id = i, M = 0;
		for(int j = 1;j <= k; ++j) 
			if(M < num and rk[id] <= x) id += len + 1, ++M;
			else id += len;
		if(id - i == n) return 1;
	}
	return 0;
}
signed main() {
	cin >> n >> k; num = n % k; len = n / k;
	scanf("%s", s + 1); for(int i = 1;i <= n; ++i) s[i + n] = s[i];
	Suf_Arr(2 * n); Height();
	if(num == 0) return hacked, 0;
	int l = 1, r = 2 * n;
	while(l < r) {
		int mid = l + r >> 1;
		if(check(mid)) r = mid;
		else l = mid + 1;
	} 
	for(int i = 1;i <= ceil(n * 1.0 / k); ++i) putchar(s[sa[l] + i - 1]);
	return 0;
}
```

---

## 作者：_fairytale_ (赞：0)

先破环成链，然后对新字符串建后缀数组，那么此时比较两个数的大小只需要比较它们的 $rk$。

观察到一个性质，就是数字的长度要么是 $\lceil\dfrac{n}{k}\rceil-1$，要么是 $\lceil\dfrac{n}{k}\rceil$。

考虑二分最大的数 $x$ 的 $rk$，因为 $x$ 最大，所以 $rk \leq rk_x$ 的数一定可以选 $\lceil\dfrac{n}{k}\rceil$ 位，所有 $rk>rk_x$ 的数只能选 $\lceil\dfrac{n}{k}\rceil-1$ 位，所以我们贪心地让拿的位最多。

那有小朋友就要问了：

要是拿的位数太多拿爆了怎么办？

我们此时可以把之前 $rk \leq rk_x$ 的数的位数减个 $1$ 嘛。
 
注意到不同的开始拿的位置可能导致不同的结果，那该从哪里开始？

一个显然的做法是枚举，肯定不行。

其实我们只需要枚举前 $\lceil\dfrac{n}{k}\rceil$ 位，因为再往下枚举的位置一定可以从前 $\lceil\dfrac{n}{k}\rceil$ 位转移过来，是一个类似循环节的东西。

```cpp
#include<bits/stdc++.h>
#define re register
#define mid ((l+r)>>1)
#define rep(x,a,b) for(re int (x)=(a);(x)<=(b);++(x))
#define per(x,a,b) for(re int (x)=(a);(x)>=(b);--(x))
using namespace std;
#define maxn 400010
int n,k;
string s;
#define v 400000
int sa[maxn],rk[maxn<<1],oldsa[maxn],oldrk[maxn<<1];
int cnt[maxn];
int len;
inline bool chck(int x){
	bool ok=false; 
	rep(i,1,len){
		int cnt=0;
		rep(j,1,k){//最多拿k次 
			int now=(i+cnt-1)%n+1;
			if(rk[now]>x)cnt+=(len-1);
			else cnt+=len; 
	    }
		ok|=(cnt>=n);
	}
	return ok;
}
int ans;
int b[maxn];
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>k;
	len=ceil(1.0*n/k);
	cin>>s;
	n+=n,s=" "+s+s;
	rep(i,1,n)++cnt[rk[i]=s[i]];
	rep(i,1,v)cnt[i]+=cnt[i-1];
	per(i,n,1)sa[cnt[rk[i]]--]=i;
	memcpy(oldrk,rk,sizeof rk);
	for(re int i=1,p=0; i<=n; ++i) {
		if(oldrk[sa[i]]==oldrk[sa[i-1]])rk[sa[i]]=p;
		else rk[sa[i]]=++p;
	}
	for(re int w=1; w<=n; w<<=1) {
		memset(cnt,0,sizeof cnt);
		memcpy(oldsa,sa,sizeof sa);
		rep(i,1,n)++cnt[rk[sa[i]+w]];
		rep(i,1,v)cnt[i]+=cnt[i-1];
		per(i,n,1)sa[cnt[rk[oldsa[i]+w]]--]=oldsa[i];
		memset(cnt,0,sizeof cnt);
		memcpy(oldsa,sa,sizeof sa);
		rep(i,1,n)++cnt[rk[sa[i]]];
		rep(i,1,v)cnt[i]+=cnt[i-1];
		per(i,n,1)sa[cnt[rk[oldsa[i]]]--]=oldsa[i];
		memcpy(oldrk,rk,sizeof rk);
		for(re int i=1,p=0; i<=n; ++i) {
			if(oldrk[sa[i]]==oldrk[sa[i-1]]&&oldrk[sa[i]+w]==oldrk[sa[i-1]+w])rk[sa[i]]=p;
			else rk[sa[i]]=++p;
		}
	}
	int l=1,r=n;
	n>>=1;
	while(l<=r){
		if(chck(mid))ans=mid,r=mid-1;
		else l=mid+1;
	}
	rep(i,1,len)cout<<s[sa[ans]+i-1];//ans=rk[i],sa[ans]=i
	return 0;
}
/*
input:

output:


*/


```

---

## 作者：pengyule (赞：0)

后缀排序+二分答案

先断环为链 $s\to s'$，再对新串后缀排序。

考虑二分答案子串的串长。已知串长 $len$，那么就有可能将 $i\in[1,|s|]$ 为起点的区间 $[i,i+len)$，固定为题目说的“最大的十进制数”。则转化为判定性问题。结合一点贪心，如果在此前提下要划分这个串，那么划分出的所有串的长度要么为 $len-1$（当且仅当为 $len$ 时字典序大于 $s[i...i+len-1]$），要么为 $len$（当且仅当不满足上面的条件，即为 $len$ 时不会大于“最大的数”）。用一个变量记录划分出的段数，若 $\le k$，则划分方案成功，否则失败。

我们按 $j:1\to |s|$ 的顺序枚举 $i=sa[j]$，因此理论复杂度 $O(|s|\log{|s|}\cdot \left(\sum_{j=1}^{\log|s|}\dfrac{|s|}{j}\right))\approx O(|s|\log{|s|}\cdot |s|\log{|s|})$，复杂度显然太高，但是当我们限制只要发现一个合乎条件的 $i$ 就记录答案、`break`，复杂度其实远远达不到这个级别，可以通过。[submission](https://www.luogu.com.cn/record/57219454)

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=4e5+5;
char s[N];
int n,m,k,p,al,ar,tl,oldn,sa[N<<1],rk[N<<1],oldrk[N<<1],id[N],rkid[N],cnt[N],t[N],u;
typedef unsigned long long ull;const ull base=137;
ull ha[N],pp[N];
ull gh(int l,int r){
	return ha[r]-ha[l-1]*pp[r-l+1];
}
bool cmp(int x,int y,int w){
	return oldrk[x]==oldrk[y]&&oldrk[x+w]==oldrk[y+w];
}
bool chk2(int l,int r){
	int seg=1,st=0;int i=r;
	while(i<l+oldn-1){
		int sl=i+1,sr=min(l+oldn-1,i+r-l+1);
		if(sr-sl+1<r-l+1||rk[l]>rk[sl])i=sr;
		else {
			if(i==sr-1)return 0;
			i=sr-1;
		}seg++;
	}
	return seg<=k;
}
bool chk(int len){//if(oldn>100&&len==1)return 0;
	bool fl=0;
	for(int i=1;i<=u;i++){
		if(chk2(t[i],t[i]+len-1)){
			tl=t[i];fl=1;
			break;
		}
	}
	return fl;
}
int main(){
	scanf("%d%d%s",&n,&k,s+1);
	for(int i=n+1;i<n*2;i++)s[i]=s[i-n];
	oldn=n,n=n*2-1,m=max(n,125);
	for(int i=1;i<=n;i++)sa[i]=i,rk[i]=s[i];
	for(int w=1;w<=n;w<<=1,m=p){
		memset(cnt,0,sizeof(cnt));
		for(int i=1;i<=n;i++)id[i]=sa[i];
		for(int i=1;i<=n;i++)cnt[rk[id[i]+w]]++;
		for(int i=1;i<=m;i++)cnt[i]+=cnt[i-1];
		for(int i=n;i>=1;i--)sa[cnt[rk[id[i]+w]]--]=id[i];
		memset(cnt,0,sizeof(cnt));
		for(int i=1;i<=n;i++)id[i]=sa[i],rkid[i]=rk[id[i]];
		for(int i=1;i<=n;i++)cnt[rkid[i]]++;
		for(int i=1;i<=m;i++)cnt[i]+=cnt[i-1];
		for(int i=n;i>=1;i--)sa[cnt[rkid[i]]--]=id[i];
		memcpy(oldrk,rk,sizeof(rk));
		p=0;
		for(int i=1;i<=n;i++)rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p;
		if(p==n){for(int i=1;i<=n;i++)sa[rk[i]]=i;break;}
	}//for(int i=1;i<=n;i++)printf("%d ",sa[i]);puts("");
	pp[0]=1;
	for(int i=1;i<=n;i++){
		if(sa[i]<=oldn)t[++u]=sa[i];
		ha[i]=ha[i-1]*base+s[i];pp[i]=pp[i-1]*base;
	}
	int Lv=(oldn+k-1)/k-1,Rv=oldn-k+2,mv;
	while(Lv<Rv-1){
		mv=Lv+Rv>>1;
		if(chk(mv))Rv=mv,al=tl,ar=al+mv-1;else Lv=mv;//printf("[%d,%d,%d]",mv,al,ar);
	}//printf("(%d,%d)",al,ar);
	for(int i=al;i<=ar;i++)putchar(s[i]);
} 
/*
10 3
1523621527
19 5
9999799397999979997
*/
```

---

## 作者：JoaoFelix (赞：0)

目前还没有题解...来写一下思路！

首先我们考虑我们可以通过n和k直接算出ans的长度记为ansl

划分的长度里面分别有ansl - 1和ansl两种长度

首先破环为链，一种直观的贪心是我们枚举答案，然后对于字典序小于答案的ansl的串，我们如果能匹配ansl就让它匹配ansl（可以发现如果只匹配ansl - 1，然后下次再匹配ansl同样是一样的结果，因此我们匹配ansl就不需要考虑接下来的匹配长度了）

然后我们针对这个长度发现取模等同的情况我们可以忽略，我们只需要枚举ans的长度一个循环节进行统计就可以求得ans

这样的复杂度是无法接受的，因此我们只需要把枚举改成二分就可以了，二分只要我们建立SuffixArray，二分SuffixArray中的rk，这样快速比较就行了！

综上复杂度为(n / k) * k * log(n) = n * log(n)，是一个log的，可以通过！

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

inline int read() {
	char c = getchar(); int x = 0, f = 1;
	while (c < '0' || c > '9') { if (c == '-') f = -1; c = getchar(); }
	while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
	return x * f;
}

const int N = 400005, inf = 1e9;

int n, k, c[N], lenx, leny, st; char str[N];

struct SuffixArray {
	int buc[N], sa[N], rk[N], fir[N], sec[N];
	
	void suffix_sort(int n) {
		for (int i = 1; i <= n; i++) buc[c[i]]++;
		for (int i = 1; i < N; i++) buc[i] += buc[i - 1];
		for (int i = n; i >= 1; i--) sa[buc[c[i]]--] = i;
		rk[sa[1]] = 1;
		for (int i = 2; i <= n; i++) rk[sa[i]] = rk[sa[i - 1]] + (c[sa[i]] != c[sa[i - 1]]);
		for (int k = 1; k <= n; k <<= 1) {
			for (int i = 1; i <= n; i++) fir[i] = rk[i], sec[i] = (i + k <= n ? rk[i + k] : 0);
			memset(buc, 0, sizeof(buc));
			for (int i = 1; i <= n; i++) buc[sec[i]]++;
			for (int i = 1; i <= n; i++) buc[i] += buc[i - 1];
			for (int i = n; i >= 1; i--) rk[buc[sec[i]]--] = i;
			memset(buc, 0, sizeof(buc));
			for (int i = 1; i <= n; i++) buc[fir[i]]++;
			for (int i = 1; i <= n; i++) buc[i] += buc[i - 1];
			for (int i = n; i >= 1; i--) sa[buc[fir[rk[i]]]--] = rk[i];
			rk[sa[1]] = 1;
			for (int i = 2; i <= n; i++) rk[sa[i]] = rk[sa[i - 1]] + (fir[sa[i]] != fir[sa[i - 1]] || sec[sa[i]] != sec[sa[i - 1]]); 
		}
	}
} SA; 

bool check(int mid) {
	if (mid == (n << 1)) return true;
	int now = st, fir = now, res = k;
	while (res--) {
		if (now >= fir + n) return true;
		if (SA.rk[now] <= mid) now += leny; else now += lenx;
	}
	return now >= fir + n;
}

int main() {
	n = read(); k = read(); scanf("%s", str + 1);
	for (int i = 1; i <= n; i++) c[i] = str[i] - '0' + 1;
	for (int i = 1; i < n; i++) c[i + n] = c[i];
	SA.suffix_sort((n << 1) - 1); int mnp = inf;
	lenx = (n % k == 0 ? n / k - 1 : n / k), leny = lenx + 1;
	for (int i = 1; i <= leny; i++) {
		int l = 0, r = (n << 1); st = i;
		while (l + 1 < r) {
			int mid = (l + r) >> 1;
			if (check(mid)) r = mid; else l = mid;
		}
		mnp = min(mnp, r);
	}
	for (int i = 1; i <= leny; i++)	printf("%d", c[SA.sa[mnp] + i - 1] - 1); printf("\n");;
	return 0;
}
```


---


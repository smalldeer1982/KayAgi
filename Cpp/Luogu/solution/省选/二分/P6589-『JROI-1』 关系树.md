# 『JROI-1』 关系树

## 题目背景

小 L 有许多喜欢的游戏角色，他把这些游戏角色按照一定的关系联系起来。这些游戏角色和他们之间的关系构成了一棵树，小 L 把这棵树称之为「关系树」。

## 题目描述

关系树是由 $n$ 个点和 $n-1$ 条无向边组成的一棵树。

对于一张给定的图 $G$，定义图 $G$ 对于点集 $E$ 的 **顶点导出子图** 为点集 $E$ 和所有的 **两个端点都属于 $E$** 且属于原图 $G$ 的边组成的图。

定义一张图是 **整洁的**，当且仅当图中任意两点 $u,v$，$u$ 和 $v$ **不连通** 或 **距离不超过** $k$。

小 L 想要知道对于一组 $l,r(l \leq r)$，有多少对 $(a,b)$，满足 $l\leq a\leq b\leq r$，且所有序号在 $a$ 和 $b$ 之间（包括 $a,b$）的点组成的顶点导出子图是 **整洁的**。不仅如此，他还想问你所有的区间长度（即 $b-a+1$）之和。

因为小 L 喜欢问问题，所以你一共需要回答 $q$ 组询问。

## 说明/提示

#### 样例 1 解释

形成的关系树如图

![](https://cdn.luogu.com.cn/upload/image_hosting/zb12y5mq.png)

满足的 $(a,b)$ 有 $(1,1),(1,2),(1,3),(1,4),(2,2),(2,3),(2,4),(2,5),(3,3),(3,4),(3,5),(4,4),(4,5),(5,5)$。

三组询问的答案依次为 $6,10$，$10,20$，$14,30$。

--------------------------------

#### 数据规模与约定

**本题采用捆绑测试**。

+ Subtask 1 ( $10\%$ )：$n\leq 2000$。
+ Subtask 2 ( $30\%$ )：$n\leq 2\times 10^4$，形成的关系树为一条链。
+ Subtask 3 ( $60\%$ )：$n\leq 2\times 10^4$。
+ Subtask 4 ( 加强版数据，时限 $4.5s$ )：无特殊限制。

对于 $100\%$ 的测试点，保证 $1\leq n \leq 8\times 10^4$，$1\leq q \leq 10^5$，$0\leq k <n$，$1\leq u,v,l,r \leq n$。

## 样例 #1

### 输入

```
5 3 2
1 2
1 5
4 5
3 5
1 3
2 5
1 5```

### 输出

```
6 10
10 20
14 30```

# 题解

## 作者：littleKtian (赞：5)

upd on 2021.10.2: 修复了代码的问题。

upd on 2021.1.31: 修改了对 Subtask 3 做法的描述。

------------

### 题外话

这题第二部分做法来自某次校内模拟赛，出题人对其进行了一定的改动。

----------------------

### 题意

给定一棵树，定义数对 $(a,b)$ 合法**当且仅当**对于所有序号在 $a,b$ 之间的点构成的顶点导出子图中**不存在**一条路径长**超过 $k$** 的路径。每次询问 $(l,r)$，求满足 $l \leq a\leq b\leq r$ 且合法的 $(a,b)$ 对数及所有的 $b-a+1$ 之和。

---------------------

可以证明，如果 $(a,b)$ 不合法，那么 $(a-1,b)$ 和 $(a,b+1)$ 一定也不合法。

假设我们已经求出对于所有的 $a$ 最小的不合法的 $b$，即为 $rq[a]$。根据上面的性质，可以发现 $rq$ 刚好构成一条单调不下降序列。

对于每个询问 $(l,r)$，可以分成 $rq[i]\leq r$ 和 $rq[i]>r$ 两部分处理。因为有如上性质，可以发现两部分刚好是连续的。

第一部分可以利用前缀和优化，第二部分因为存在规律，可以根据长度直接推公式。

每个询问处理复杂度为 $O(\log n)$（二分寻找两部分分割点）。

考虑如何求 $rq$。

--------------------

容易得到下面的思路：

在树上找出所有长度为 $k+1$ 的路径，假设该路径序号最小的点序号为 $a$，序号最大的点序号为 $b$。则 $rq[a]$ 应为所有的 $b$ 中的最小值。全部统计完以后再从后往前取最小值即可得到 $rq$。

伪代码如下：

```cpp
void ss()//找路 
{
	找到一条路
	rq[a]=min(rq[a],b);
}
int main()
{
	for(int i=1;i<=n;i++)rq[i]=n+1;
	不断找路
	for(int i=n-1;i>0;i--)rq[i]=min(rq[i],rq[i+1]);
}
```
-----------------------------

### Subtask 1：

枚举路径起点暴力 dfs 即可。

复杂度 $O(n^2)$。

----------------------------

### Subtask 2：

既然是链肯定有一些性质。出题人懒得写了。

---------------------------

### Subtask 3：

对于两条长度都为 $k+1$ 的路径，假设第一条路径中序号最小和最大的点序号分别为 $a,b$，另一条为 $c,d$，如果 $c \leq a$ 且 $d \geq b$，那么可以不考虑第二条路径，从而减少枚举数量。

考虑点分治。

用平衡树记录每层以根为一个路径端点的路径长为 $l$ 的所有路径中序号最大和最小的点的序号（假设为 $p,q$），并利用如上性质维护（如果存在另一个长度相同且所包含点的区间被其包含，那么就可以将这条路径从平衡树中删除）。此时平衡树内的两个序列都是单调递增的。对于每次 dfs 得到的路径，显然最后组合出的长为 $k+1$ 的路径所包含点的区间必然包含 $\left[p,q\right]$，因此只需要在平衡树内找到所有长度为 $k+1-l$ 的路径中**最小点序号大于 $p$ 且最小的路径**（即 $p$ 的后继）和**最大点序号小于 $q$ 且最大的路径**（即 $q$ 的前驱），让之前 dfs 得到的路径与分别与这两条拼接即可。而对于其中所包含点的区间包含 $\left[p,q\right]$ 的长度为 $k+1-l$ 的路径，可知其组出的区间已经达到最优，因此可以直接将其从平衡树内删除。

总复杂度为 $O(n\log^2n)$，常数略大。

[代码](https://www.luogu.com.cn/paste/7mxndlo2)（略长，但其中很多都是板子）：

---

## 作者：chenxia25 (赞：1)

不难发现一个区间 $[l,r]$ 是合法的，当且仅当不存在一条长度大于 $k$ 的链 $p$，使 $l\leq mn(p)\leq mx(p)\leq r$。为了方便统计，不难发现将「大于 $k$」改成「等于 $k+1$」也是对的。

于是我们试图找到所有长度等于 $k+1$ 的链，将 $l\leq mn(p),r\geq mx(p)$ 的 $[l,r]$ 全部 ban 掉。这看起来是个扫描线问题，但实际上更为简单，因为第一维总 ban 前缀，第二维总 ban 后缀。于是我们只要知道对每个 $x\in[1,n]$，$mx(p)=x$ 的最大 $mn(p)$，记为 $M_x$，那么对 $r=x$ ban 掉的其实就是 $1\sim \max\limits_{i=1}^x\{M_i\}$ 中的 $l$。此时统计答案就很 trivial。考虑对 $r$ 进行扫描线，实时维护 $l=l_0$ 的答案。那么 $r\to r+1$ 的更新量就是右端点为 $r+1$ 的合法区间。分成 $\max\limits_{i=1}^x\{M_i\}$ 左边和右边的 $l$ 讨论，区间长度之和与区间个数显然分别是关于 $l$ 的二次函数和一次函数。区间加低次多项式单点查询就很 trivial 了吧，线段树懒标记维护各项系数即可。

接下来考虑如何求 $M_x$ 们。注意到长度等于 $m=k+1$ 的链数量可能达到平方级别，虽然 $m=1$ 的时候是线性，但是菊花图 + $m=2$​ 就卡爆了。于是对于这种统计路径的问题，考虑点分治。由于要求的是最值，不能一阶容斥，只能一个一个儿子树动态搞。设点 $x$ 到当前重心的最大、最小值以及距离分别为 $mx_x,mn_x,d_x$，我们考虑对路径 $x\to y$ 在 $mx_x$ 较大时在 $x$ 处做出贡献，对于 $x$ 在先的情况将邻接表 reverse 一下重新跑一遍即可。现在任务是对 $x$，找出 $d_y=m-d_x$ 且 $mx_y\leq mx_x$ 的最大 $mn_y$。这可以想到对每个深度维护一个 BIT，但是这样空间爆炸，所以只能动态开点线段树实现。复杂度 2log。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define pb push_back
#define X first
#define Y second
#define mp make_pair
const int inf=0x3f3f3f3f3f3f3f3f;
const int N=100010;
int n,qu,m;
vector<int> nei[N];
bool vis[N];
struct segtree{
	int sz,root[N];
	struct node{int lson,rson,mx;}nd[N<<5];
	#define lson(p) nd[p].lson
	#define rson(p) nd[p].rson
	#define mx(p) nd[p].mx
	int nwnd(){return assert(sz<=(N<<5)),nd[++sz]=nd[0],sz;}
	void init(int lim){
		nd[sz=0]=node({0,0,0});
		for(int i=0;i<=lim+1;i++)root[i]=nwnd();
	}
	void sprup(int p){assert(p),mx(p)=max(mx(lson(p)),mx(rson(p)));}
	void chkmx(int x,int v,int p,int tl=0,int tr=n){
		assert(0<p&&p<N<<5);assert(!mx(0));
		if(tl==tr)return mx(p)=max(mx(p),v),void();
		int mid=tl+tr>>1;
		if(x<=mid){
			if(!lson(p))lson(p)=nwnd();
			chkmx(x,v,lson(p),tl,mid);
		}
		else{
			if(!rson(p))rson(p)=nwnd();
			chkmx(x,v,rson(p),mid+1,tr);
		}
		sprup(p);
	}
	int _mx(int l,int r,int p,int tl=0,int tr=n){
		if(!p)assert(!mx(p));
		if(l<=tl&&r>=tr)return mx(p);
		int mid=tl+tr>>1,res=0;
		if(l<=mid)res=max(res,_mx(l,r,lson(p),tl,mid));
		if(r>mid)res=max(res,_mx(l,r,rson(p),mid+1,tr));
		return res;
	}
}segt;
void dfs(int x,int mn,int mx,int dep,vector<pair<pair<int,int>,int> > &v,int fa=0){
	v.pb(mp(mp(mn,mx),dep));
	for(int i=0;i<nei[x].size();i++){
		int y=nei[x][i];if(vis[y]||y==fa)continue;
		dfs(y,min(mn,y),max(mx,y),dep+1,v,x);
	}
}
int lft[N];
int sz[N],mxsz[N];
bool cmp(int x,int y){return mxsz[x]<mxsz[y];}
int gtrt(int x=1,int tot=n,int fa=0){
	sz[x]=1,mxsz[x]=0;
	int rt=0;
	for(int i=0;i<nei[x].size();i++){
		int y=nei[x][i];if(vis[y]||y==fa)continue;
		rt=min(rt,gtrt(y,tot,x),cmp);
		sz[x]+=sz[y],mxsz[x]=max(mxsz[x],sz[y]);
	}
	mxsz[x]=max(mxsz[x],tot-sz[x]);
	return min(rt,x,cmp);
}
void cdq(int x,int tot){
//	cout<<"at "<<x<<" now!\n";
	vis[x]=true;
	segt.init(tot),segt.chkmx(0,inf,segt.root[0]);
	for(int i=0;i<nei[x].size();i++){
		int y=nei[x][i];if(vis[y])continue;
		vector<pair<pair<int,int>,int> > v;
		dfs(y,y,y,1,v);
		for(int j=0;j<v.size();j++){
			int mn=min(x,v[j].X.X),mx=max(x,v[j].X.Y),d=v[j].Y;
			assert(1<=mx&&mx<=n);
			if(d>m)continue;
			lft[mx]=max(lft[mx],min(mn,segt._mx(0,mx,segt.root[m-d])));
		}
		for(int j=0;j<v.size();j++)segt.chkmx(v[j].X.Y,v[j].X.X,segt.root[v[j].Y]);
	}
	for(int i=0;i<=tot+1;i++)segt.root[i]=0;
	segt.init(tot),segt.chkmx(0,inf,segt.root[0]);
	reverse(nei[x].begin(),nei[x].end());
	for(int i=0;i<nei[x].size();i++){
		int y=nei[x][i];if(vis[y])continue;
		vector<pair<pair<int,int>,int> > v;
		dfs(y,y,y,1,v);
		for(int j=0;j<v.size();j++){
			int mn=min(x,v[j].X.X),mx=max(x,v[j].X.Y),d=v[j].Y;
			if(d>m)continue;
			lft[mx]=max(lft[mx],min(mn,segt._mx(0,mx,segt.root[m-d])));
		}
		for(int j=0;j<v.size();j++)segt.chkmx(v[j].X.Y,v[j].X.X,segt.root[v[j].Y]);
	}
	for(int i=0;i<=tot+1;i++)segt.root[i]=0;
	for(int i=0;i<nei[x].size();i++){
		int y=nei[x][i];if(vis[y])continue;
		int rt=gtrt(y,sz[y]);
		cdq(rt,sz[y]);
	}
}
vector<pair<int,int> > buc[N];
pair<int,int> ans[N];
struct segtree0{
	struct node{int lz2,lz1,lz0,l1,l0;}nd[N<<2];
	#define lz2(p) nd[p].lz2
	#define lz1(p) nd[p].lz1
	#define lz0(p) nd[p].lz0
	#define l1(p) nd[p].l1
	#define l0(p) nd[p].l0
	void init(){
		memset(nd,0,sizeof(nd));
	}
	void tag(int p,int a,int b,int c,int d,int e){
		lz2(p)+=a,lz1(p)+=b,lz0(p)+=c,l1(p)+=d,l0(p)+=e;
	}
	void sprdwn(int p){
		tag(p<<1,lz2(p),lz1(p),lz0(p),l1(p),l0(p));
		tag(p<<1|1,lz2(p),lz1(p),lz0(p),l1(p),l0(p));
		lz2(p)=lz1(p)=lz0(p)=l1(p)=l0(p)=0;
	}
	void add(int l,int r,int a,int b,int c,int d,int e,int tl=1,int tr=n,int p=1){
//		cout<<l<<" "<<r<<" "<<d<<" "<<e<<"!\n";
		if(l>r)return;
		if(l<=tl&&r>=tr)return tag(p,a,b,c,d,e);
		sprdwn(p);
		int mid=tl+tr>>1;
		if(l<=mid)add(l,r,a,b,c,d,e,tl,mid,p<<1);
		if(r>mid)add(l,r,a,b,c,d,e,mid+1,tr,p<<1|1);
	}
	pair<int,int> at(int x,int p=1,int tl=1,int tr=n){
		while(tl<tr){
			sprdwn(p);
			int mid=tl+tr>>1;
			if(x<=mid)p=p<<1,tr=mid;
			else p=p<<1|1,tl=mid+1;
//			cout<<tl<<" "<<tr<<"!\n";
		}
		return mp(lz2(p)*x*x+lz1(p)*x+lz0(p),l1(p)*x+l0(p));
	}
}segt0;
signed main(){mxsz[0]=inf;
	cin>>n>>qu>>m;
	m++;
	for(int i=1;i<n;i++){
		int x,y;
		scanf("%lld%lld",&x,&y);
		nei[x].pb(y),nei[y].pb(x);
	}
	cdq(gtrt(),n);
	for(int i=1;i<=n;i++)lft[i]=max(lft[i]+1,lft[i-1]);
//	for(int i=1;i<=n;i++)cout<<lft[i]<<" ";puts("");
	for(int i=1;i<=qu;i++){
		int l,r;
		scanf("%lld%lld",&l,&r);
		assert(l<=r);
		buc[r].pb(mp(l,i));
	}
	segt0.init();
	for(int i=1;i<=n;i++){
		segt0.add(lft[i],i,1,-2*i-3,(i+1)*(i+2),-1,i+1);
		segt0.add(1,lft[i]-1,0,0,(i-lft[i]+1)*(i-lft[i]+2),0,i-lft[i]+1);
		for(int j=0;j<buc[i].size();j++){
			int l=buc[i][j].X,id=buc[i][j].Y;
			ans[id]=segt0.at(l);
		}
	}
	for(int i=1;i<=qu;i++)printf("%lld %lld\n",ans[i].Y,ans[i].X/2);
	return 0;
}
```

---


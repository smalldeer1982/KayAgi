# [COCI 2019/2020 #3] Lampice

## 题目描述

Mirko 用 $N$ 个 LED 灯来装饰圣诞树，它们的颜色是已知的，并且通过 $(N-1)$ 条电线连接。

Mirko 在大功告成后，仔细地品味自己的作品。他被一种叫作「回文段」的特殊图案所吸引。「回文段」指一条从 $u$ 至 $v$ 的路径，它满足从 $u$ 到 $v$ 的路径所包含灯的颜色等于从 $v$ 到 $u$ 的路径所包含灯的颜色。

求出圣诞树中最长的「回文段」。

## 说明/提示

#### 数据范围及约定

| Subtask | 分值 | 数据范围及约定 |
| :----------: | :----------: | :----------: |
| $1$ | $17$ | $N \le 3000$ |
| $2$ | $25$ | 第 $i$ 个与第 $i+1$ 个灯直接相连（$1 \le i \lt N$） |
| $3$ | $31$ | 至多有 $100$ 个灯与另一个灯直接相连 |
| $4$ | $37$ | 无 |

对于 $100\%$ 的数据，$1 \le N \le 5 \times 10^4, 1 \le A,B \le N, A \neq B$。

#### 说明

**本题分值按 COCI 原题设置，满分 $110$。**

**题目译自 [COCI2019-2020](https://hsin.hr/coci/archive/2019_2020/) [CONTEST #3](https://hsin.hr/coci/archive/2019_2020/contest3_tasks.pdf)  _T4 Drvca_ 。**

## 样例 #1

### 输入

```
7
imanade
1 2
2 3
3 4
4 5
5 6
6 7```

### 输出

```
3```

## 样例 #2

### 输入

```
4
aabb
1 2
1 3
3 4```

### 输出

```
2```

## 样例 #3

### 输入

```
8
acdbabcd
1 6
6 7
6 3
3 4
4 5
5 2
8 5```

### 输出

```
5```

# 题解

## 作者：zuytong (赞：3)

## 题意

一棵树，每个结点有一个小写字母，求最长的回文路径。


------------
## 思路

路径问题我们可以想到用*点分治*来求解。

我们点分治的时候，维护每个点到重心的**正反路径**的 hash 值。

设点到重心的 hash 值为 $A$，重心到点的 hash 值为 $B$。

假设实现我们有两个长度分别为 $L_1,L_2$ 的路径，它们的 LCA 是当前分治到的重心。

这两条路径要组成回文路径当且仅当：

$$A_1+B_2\times 27^{L_1}=A_2+B_1\times 27^{L_2}$$

移项，同除 $27^{L_1+L_2}$：

$$A_1/27^{L_1+L_2}-B_1/ 27^{L_1}=A_2/27^{L_1+L_2}-B_2/ 27^{L_2}$$

这里 $L_1+L_2$ 就是回文路径的长度。

我们知道，一个路径如果是回文路径，那么去掉头尾两个结点它仍然是回文路径。

我们考虑**奇偶长度**分开来二分，然后每次做点分治，并记录下 $A/27^{len}-B/ 27^{L}$。

时间复杂度为 $O(n\log^3n)$，需要卡常。

一个卡常技巧就是，如果 分治到的联通块大小 小于 固定的回文路径长度 时，就直接返回。

记录时将 map 换成 unordered_map 实测快不少。


------------
## 代码

```cpp
#include<iostream>
#include<fstream>
#include<algorithm>
#include<cmath>
#include<cstdlib>
#include<cstring>
#include<queue>
#include<unordered_map>
#include<set>
#include<bitset>
#define LL long long
using namespace std;
namespace MOD
{
    const int mod = 1e9 + 7;
    inline int add(int a, int b) {return a + b >= mod ? a + b - mod : a + b;}
    inline int mul(int a, int b) {return 1ll * a * b % mod;}
    inline int sub(int a, int b) {return a - b < 0 ? a - b + mod : a - b;}
    inline int fast_pow(int a, int b)
    {
        int re = 1;
        while(b)
        {
            if(b & 1) re = mul(re, a);
            a = mul(a, a);
            b >>= 1;
        }
        return re;
    }
    inline int inv(int a) {return fast_pow(a, mod - 2);}
} using namespace MOD;
int n, ans = 1, p[50005], invp[50005]; char c[50005];
struct Node
{
    int to, nxt;
}r[100005]; int he[50005];
inline void Edge_add(int u, int v)
{
    static int cnt = 0;
    r[++cnt] = (Node){v, he[u]};
    he[u] = cnt;
}
bitset<50005> vis;
int tot, sz[50005], Mx[50005], rt;
void getrt(int now, int fa)
{
    sz[now] = 1, Mx[now] = 0;
    for(int i = he[now]; i; i = r[i].nxt)
    {
        int to = r[i].to;
        if(vis[to] || to == fa) continue;
        getrt(to, now);
        sz[now] += sz[to];
        Mx[now] = max(Mx[now], sz[to]);
    }
    Mx[now] = max(Mx[now], tot - sz[now]);
    if(Mx[now] < Mx[rt]) rt = now;
}
int h1[50005], h2[50005], dep[50005], q[50005], ta, nlen;
int L, R; bool chk;
#define pii pair<int, int>
#define mp make_pair
struct hash_pair { 
    template <class T1, class T2> 
    size_t operator()(const pair<T1, T2>& p) const
    { 
        auto hash1 = hash<T1>{}(p.first); 
        auto hash2 = hash<T2>{}(p.second); 
        return hash1 ^ hash2; 
    } 
}; 
unordered_map<pii, bool, hash_pair> f;
inline void gethash(int now, int fa)
{
    for(int i = he[now]; i; i = r[i].nxt)
    {
        int to = r[i].to;
        if(vis[to] || to == fa) continue;
        h1[to] = add(mul(h1[now], 27), c[to] - 'a' + 1), h2[to] = add(h2[now], mul(c[to]- 'a' + 1, p[dep[to] = dep[now] + 1]));
        q[++ta] = to;
        gethash(to, now);
    }
}
#define h(H1, H2, sum, len) sub(mul(H1, invp[sum]), mul(H2, invp[len]))
inline void calc(int now)
{
    f.clear();
    h1[now] = h2[now] = c[now] - 'a' + 1, dep[now] = 0;
    f[mp(0, 0)] = 1;
    for(int i = he[now]; i; i = r[i].nxt)
    {
        int to = r[i].to;
        if(vis[to]) continue;
        h1[to] = add(c[to] - 'a' + 1, h1[now] * 27); h2[to] = add(h2[now], (c[to] - 'a' + 1) * 27), dep[to] = 1;
        q[ta = 1] = to;
        gethash(to, now);
        for(int j = 1; j <= ta; j++)
        {
            int val = h(h1[q[j]], h2[q[j]], nlen, dep[q[j]] + 1);
            if(f[mp(val, nlen - dep[q[j]] - 1)])
                {chk = true; return;}
        }
        for(int j = 1; j <= ta; j++)
        {
            int H1 = sub(h1[q[j]], mul(h1[now], p[dep[q[j]]]));
            int H2 = mul(sub(h2[q[j]], h1[now]), invp[1]);
            int val = h(H1, H2, nlen, dep[q[j]]);
            f[mp(val, dep[q[j]])] = 1;
        }
    }
}
void solve(int now)
{
    vis[now] = 1, calc(now); if(chk) return;
    int rp = tot - sz[now];
    for(int i = he[now]; i; i = r[i].nxt)
    {
        int to = r[i].to;
        if(vis[to]) continue;
        tot = Mx[rt = 0] = (sz[to] > sz[now] ? rp : sz[to]);
        if(tot < nlen) continue;
        getrt(to, 0);
        solve(rt);
    }
}
signed main()
{
#ifndef ONLINE_JUDGE
    freopen("test.in", "r", stdin);
    freopen("test.out", "w", stdout);
#endif
    scanf("%d%s", &n, c + 1);
    p[0] = invp[0] = 1; for(int i = 1; i <= n; i++) p[i] = mul(p[i - 1], 27);
    invp[n] = inv(p[n]); for(int i = n - 1; i >= 1; i--) invp[i] = mul(invp[i + 1], 27);
    for(int i = 1; i < n; i++)
    {
        int u, v;
        scanf("%d%d", &u, &v);
        Edge_add(u, v), Edge_add(v, u);
    }
    L = 1, R = (n + 3) >> 1;
    while(L + 1 < R)
    {
        int mid = (L + R) >> 1;
        vis = chk = 0; nlen = (mid << 1) - 1;
        tot = Mx[rt = 0] = n;
        getrt(1, 0);
        solve(rt);
        if(chk) L = mid;
        else R = mid;
    }
    ans = max(ans, (L << 1) - 1);
    L = ans >> 1, R = (n + 2) >> 1;
    while(L + 1 < R)
    {
        int mid = (L + R) >> 1;
        vis = chk = 0; nlen = mid << 1;
        tot = Mx[rt = 0] = n;
        getrt(1, 0);
        solve(rt);
        if(chk) L = mid;
        else R = mid;
    }
    ans = max(ans, L << 1);
    printf("%d", ans);
    return 0;
}
```


---

## 作者：kevinZ99 (赞：1)

# solution

对于这种找点对的题目，容易发现我们并不能通过枚举一个计算出另外一个点，那么就很明了了。

首先我们考虑，由于回文是拥有单调性的，所以我们可以使用二分来进行求解。

由于确定了长度，很明显判断可以使用点分治进行判定。

我们考虑正常判断回文串，明显我们会使用哈希，维护正反两个哈希，判断是否相同。

那么同理对于过重心的点对，我们维护正反两个到重心的哈希值，和到重心的边数。

然后计算判定即可。

由于确定了长度我们可以计算数量而不是判定有没有，这样我们就可以进行容斥了。

## 注意事项

1、提前处理好重心。

2、若容斥后答案非零，则直接退出。

3、如果你使用 ```map<pair<int,int>,int>``` 可以将其改为 ```unordered_map<long long,int>``` 。把 ```pair<int,int>``` 转化为 ```first<<33+second``` 。

# code


```cpp
//Author:Kevin Z K Y
#include <bits/stdc++.h>
#define up(a,b,c) for(int (a)=(b);(a)<=(c);(a)++)
#define dn(a,b,c) for(int (a)=(b);(a)>=(c);(a)--)
#define fst first
#define sed second
using namespace std;
using ull = unsigned long long ;using ui = unsigned int ;
using ll = long long ;using hint = __int128 ;
using pii = pair<int,int> ;using pll = pair<ll,ll> ;
using vi = vector<int> ;using vl = vector<ll> ;
using vpi = vector<pii> ;using vpl = vector<pll> ;
using db = double ;namespace mystl{
	#define gc() getchar()
	ll qpow(ll a,ll b,const ll&p){if (a==0ll) return 0ll; ll c=1ll;
		while(b) { if(b & 1) c=a*c%p; a=a*a%p; b>>=1; } return c; }
	template<typename T>void read(T&x) {x=0; bool f=false; char ch;
		ch = gc(); while(ch<'0'||ch>'9') f |= ( ch=='-') , ch=gc();
		while(ch>='0'&&ch<='9') x=x*10+ch-'0' , ch=gc(); x=f?-x:x;}
	template<typename T>void write(T x){char s[40];short d=0;T y=x;
		if(x<0) putchar('-'),y=-y;if(x==0){ putchar('0'); return; }
		while(y){s[++d]=y%10+'0';y/=10;}while(d>0)putchar(s[d--]);}
	template<typename T>void wris(T x,char c){write(x);putchar(c);}
}using namespace mystl;
namespace my{
	const int N=(int)(5e4+5);
	const ui base=131;
	vi g[N];
	char s[N];
	int ans;
	ui dist[N],f1[N],h1[N],f2[N],h2[N],pw[N];
	int n,siz[N],C[20][N],TW[20][N];
	bool vis[N];unordered_map<ull,int>mp;
	int mn,son,w;int Find(int x,int fa){
		int now=1;for(int&v:g[x]){
			if(v==fa||vis[v])continue;
			now+=Find(v,x);
		}return now;
	}void dfsCenter(int x,int fa){
		int mxson=-1e9;siz[x]=1;for(int&v:g[x]){
			if(v==fa||vis[v])continue;
			dfsCenter(v,x);siz[x]+=siz[v];
			mxson=max(mxson,siz[v]);
		}mxson=max(mxson,w-siz[x]);if(mxson==mn)son=min(x,son);
		if(mxson<mn)mn=mxson,son=x;
	}void Init(int x,int dep){
		mn=1e9,son=-1,w=Find(x,0);
		dfsCenter(x,0);vis[son]=true;C[dep][x]=son,TW[dep][x]=w;
		for(int&v:g[son]){
			if(vis[v])continue;
			Init(v,dep+1);
		}
	}void dfs(int x,int fa,int D){
		dist[x]=dist[fa]+1;
		if(dist[x]>D)return ;
		h1[x]=h1[fa]*base+s[x];
		f1[x]=f1[fa]+s[x]*pw[dist[fa]];
		ui p;
		if(D%2==0)p=f2[x]*pw[D-dist[x]]-h1[x];
		else p=f1[x]*pw[D-dist[x]]-h2[x];
		ull TP=((ull)(p)<<33)+((ui)(dist[x]));
//		cout<<x<<' '<<p<<' '<<f1[x]<<' '<<f2[x]<<' '<<dist[x]<<'\n';
		mp[TP]++;
		for(int&v:g[x]){
			if(v==fa||vis[v])continue;
			h2[v]=h2[x]*base+s[v];
			f2[v]=f2[x]+s[v]*pw[dist[x]];
			dfs(v,x,D);
		}
	}void ddfs(int x,int fa,int D,int o){
		if(dist[x]>D)return ;
//		cout<<x<<' '<<f1[x]<<' '<<f2[x]<<' '<<h2[x]<<' '<<h1[x]<<' '\
			<<dist[x]<<' '<<ans<<' ';
		ui td;
		pair<ui,int>tp;
		if(D%2==0)td=f2[x]*pw[D-dist[x]]-h1[x],tp={td,D-dist[x]+1};
		else td=f1[x]*pw[D-dist[x]]-h2[x],tp={td,D-dist[x]+1};
		ull TP=((ull)(tp.fst)<<33)+((ui)(tp.sed));
//		cout<<td<<' '<<tp.sed<<' '<<mp[TP]<<' ';
		if(mp.find(TP)!=mp.end())ans+=o*mp[TP];
		if(tp.sed==dist[x])ans-=o;
//		cout<<ans<<'\n';
		for(int&v:g[x]){
			if(v==fa||vis[v])continue;
			ddfs(v,x,D,o);
		}
	}void dddfs(int x,int fa,int D){
		if(dist[x]>D)return ;
		ui p;
		if(D%2==0)p=f2[x]*pw[D-dist[x]]-h1[x];
		else p=f1[x]*pw[D-dist[x]]-h2[x];
//		cout<<x<<' '<<p<<' '<<dist[x]<<'\n';
		ull TP=((ull)(p)<<33)+((ui)(dist[x]));
		mp[TP]++;
		for(int&v:g[x]){
			if(v==fa||vis[v])continue;
			dddfs(v,x,D);
		}
	}void Part(int x,int D,int dep){
		if(TW[dep][x]<D)return ;
		son=C[dep][x];vis[son]=true;
//		cout<<"X:"<<x<<' '<<son<<' '<<D<<'\n';
		mp.clear();
//		cout<<"ALL\n";
		h2[son]=f2[son]=0;
		dfs(son,0,D);ddfs(son,0,D,1);
		for(int&v:g[son]){
			if(vis[v])continue;
			mp.clear();
//			cout<<"V:"<<v<<'\n';
			dddfs(v,son,D);ddfs(v,son,D,-1);
		}if(ans>0)return ;for(int&v:g[son]){
			if(vis[v])continue;
			Part(v,D,dep+1);
		}
	}
	void solve(){
		cin>>n>>s;
		dn(i,n-1,0)s[i+1]=s[i],s[i+1]-='a';
		up(i,2,n){
			int x,y;cin>>x>>y;
			g[x].push_back(y);
			g[y].push_back(x);
		}Init(1,1);pw[0]=1;up(i,1,N-1)pw[i]=pw[i-1]*base;
		int Len=0,Ans=1;
		int l=1,r=n/2,best=-1;
		while(l<=r){
			int mid=(l+r)/2;
			int DW=mid*2;
//			cout<<"______________________________\n";\
			cout<<l<<' '<<r<<' '<<mid<<' '<<DW<<'\n';
			ans=0;up(i,1,n)vis[i]=false;
			Part(1,DW,1);if(ans>0)l=mid+1,best=DW;else r=mid-1;
		}Ans=max(Ans,best);
		l=2,r=(n+1)/2;best=-1;
		while(l<=r){
			int mid=(l+r)/2;
			int DW=mid*2-1;
//			cout<<"______________________________\n";\
			cout<<l<<' '<<r<<' '<<mid<<' '<<DW<<' ';
			ans=0;up(i,1,n)vis[i]=false;
			Part(1,DW,1);if(ans>0)l=mid+1,best=DW;else r=mid-1;
//			cout<<ans<<'\n';
		}
//		cout<<"________________________________\n";
		Ans=max(Ans,best);cout<<Ans<<'\n';
	}
}
int main(){
//  freopen("s.in","r",stdin);
//  freopen("my.out","w",stdout);
	ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);
	int _=1;while(_--)my::solve();return 0;
}

```

---

## 作者：WeLikeStudying (赞：1)

- 祝愿天下人，身体健康。

**题意**
- [题目链接](https://www.luogu.com.cn/problem/P7206)。
- 给一棵树，每个节点都有字符，找到最长的回文树链。
- 树的大小不大于 $50000$，时间限制 $3.5$ 秒。

**分析**
- 特别提醒：由于作者目前不会任何字符串算法，这篇题解是由[字符串哈希](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/ha-xi)的思路写成的。
- 这个时间限制仅仅是用来卡 $O(n^2)$ 的暴力的（我们恰好有一个这样的暴力）。
- 作者不会任何的玄学算法，所以第一个想法就是：如果我们有办法把一堆字符串的哈希数据合并起来然后判断它是否形成回文串，我们就可以用点分治这样的算法快速解决它。
- 说干就干，加入现在分治重心有字符 $e$，两条链中向下的片段是 $a_0,b_0$，向上的片段有字符 $a_1,b_1$，两条链的长度为 $L_1,L_2$，那么它是回文串的必要条件是：
![](https://cdn.luogu.com.cn/upload/image_hosting/kerekrb2.png)
$$a_1+e\cdot B^{L_1}+b_0\cdot B^{L_1+1}=a_0\cdot B^{L_2+1}+e\cdot B^{L_2}+b_1$$
- 显然我们想要把贡献拆分对吧，所以我们继续变形。
$$\frac{a_1}{B^{L_1+L_2}}+\frac{e}{B^{L_2}}+\frac{b_0}{B^{L_2-1}}=\frac{a_0}{B^{L_1-1}}+\frac{e}{B^{L_1}}+\frac{b_1}{B^{L_1+L_2}}$$
$$\frac{b_0}{B^{L_2-1}}+\frac{e}{B^{L_2}}-\frac{b_1}{B^{L_1+L_2}}=\frac{a_0}{B^{L_1-1}}+\frac{e}{B^{L_1}}-\frac{a_1}{B^{L_1+L_2}}$$
- 最后：问题在于 $B^{L_1+L_2}$ 还没有被化简并拆分，或许您也如同作者一开始认为的那样：此路不通，但实际却是：它可以指导一种解法。
- 让我们回归一个基本事实：若长度为 $n>2$ 的回文串存在，那么长度为 $n-2$ 的回文串也存在：因为这就是拆掉头尾两个字母之间的差别。
- 也就是说：如果我们检测到存在长度为 $L$ 的回文串，那么一定存在长度为 $l\le L$ 且与 $L$ 同奇偶的回文串，所以我们可以分奇偶二分某个回文串长度是否出现！所以最终，我们用一种不优美但实用的期望 $O(n\log^2n)$ 复杂度解决了此题，不需要用到任何复杂的字符串算法，只需要简单的字符串哈希，以及一点二分和分治的思想，[代码](https://www.luogu.com.cn/paste/006efzmw)。

---

## 作者：zifanwang (赞：0)

显然可以对答案奇偶分别二分，判断用点分治。考虑对每个点记录到当前分治中心的路径正着和倒着的 hash 值，那么两个点之间的路径是回文路径可以用一个简单的式子表示，移项一下把跟一个点有关的值放到一边，用 unordered_map 记录/查询即可，需要卡常，时间复杂度 $\mathcal O(n\log^2n)$。

参考代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define mxn 50003
#define md 1000000007
#define pb push_back
#define mkp make_pair
#define ld long double
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define rept(i,a,b) for(int i=(a);i<(b);++i)
#define drep(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
int n,n1,mn,rt,ans,now,d[mxn],sz[mxn],son[mxn];
char s[mxn];
vector<int>g[mxn];
bool fl,v[mxn];
unsigned int h1[mxn],h2[mxn],c[mxn];
struct hash_pair{ 
    template <class T1, class T2> 
    size_t operator()(const pair<T1, T2>& p) const{ 
        auto hash1 = hash<T1>{}(p.first);
        auto hash2 = hash<T2>{}(p.second);
        return hash1 ^ hash2; 
    } 
};
unordered_map<pair<unsigned int,int>,bool,hash_pair>mp;
void getrt(int x,int fa){
	sz[x]=1;
	int mx=0;
	for(int i:g[x])if(i!=fa&&!v[i]){
		getrt(i,x);
		sz[x]+=sz[i];
		mx=max(mx,sz[i]);
	}
	mx=max(mx,n1-sz[x]);
	if(mx<mn)mn=mx,rt=x;
}
void dfs1(int x,int fa){
	d[x]=d[fa]+1;
	if(d[x]>now)return;
	h1[x]=h1[fa]+(s[x]-'a'+1)*c[d[x]];
	h2[x]=h2[fa]*27+s[x]-'a'+1;
	if(mp[{h1[x]*c[now-d[x]-1]-h2[x],now-d[x]-1}]){
		fl=1;
		return;
	}
	for(int i:g[x])if(i!=fa&&!v[i]){
		dfs1(i,x);
		if(fl)return;
	}
}
void dfs2(int x,int fa){
	if(d[x]>now)return;
	mp[{h1[x]*c[now-d[x]-1]-h2[x],d[x]}]=1;
	for(int i:g[x])if(i!=fa&&!v[i]){
		dfs2(i,x);
	}
}
void dfs(int x,int n){
	if(n<now)return;
	n1=n,mn=1e9;getrt(x,0);x=rt;
	v[x]=1,h2[x]=d[x]=0,h1[x]=s[x]-'a'+1;
	mp.clear(),mp[{h1[x]*c[now-1],0}]=1;
	for(int i:g[x])if(!v[i]){
		dfs1(i,x);
		if(fl)return;
		dfs2(i,x);
	}
	for(int i:g[x])if(!v[i]){
		dfs(i,sz[i]<sz[x]?sz[i]:n-sz[x]);
		if(fl)return;
	}
}
bool check(){
	rep(i,1,n)v[i]=0;
	fl=0;
	dfs(1,n);
	return fl;
}
signed main(){
	scanf("%d%s",&n,s+1);
	c[0]=1;
	rep(i,1,n)c[i]=c[i-1]*27;
	for(int i=1,x,y;i<n;++i){
		scanf("%d%d",&x,&y);
		g[x].pb(y),g[y].pb(x);
	}
	int l=0,r=(n-1)>>1;
	while(l<r){
		int mid=(l+r+1)>>1;now=(mid<<1)|1;
		if(check())l=mid;
		else r=mid-1;
	}
	ans=(l<<1)|1;
	l=ans>>1,r=n>>1;
	while(l<r){
		int mid=(l+r+1)>>1;now=mid<<1;
		if(check())l=mid;
		else r=mid-1;
	}
	ans=max(ans,l<<1);
	cout<<ans;
	return 0;
}
```

---

## 作者：Acoipp (赞：0)

## 题意

有一个 $n$ 个点的树，输上每个节点有一个字符，问最长的一条回文路径的长度。

$n \le 5 \times 10^4,ch_i \in \{a \sim z\}$。

## 分析

首先是输出最长的合法路径，因此我们想到了点分治。

并且根据回文串的单调性，我们分成奇数长度的回文串和偶数长度的回文串进行统计。

这里可以二分答案，问题转化为一个判定性的，我们接下来考虑判定一个长度为 $k$ 的回文串是否在树中出现。

首先考虑对于分治中心 $l$ 的答案如何计算。

如果一条路径为 $u \to l \to v$，并且这条路径长度为 $k$ 也是回文串，我们钦定 $\operatorname{dis}(u,l) > \operatorname{dis}(l,v)$，那么一定有一个在 $u \to l$ 上的点 $p$ 满足 $p \to l$ 是回文串，并且 $u \to p$ 构成的回文串等于 $v \to l$ 构成的回文串。

因为 $l$ 和长度 $k$ 都是固定的，所以当我们知道了 $\operatorname{dis}(u,l)$ 之后，$p$ 的位置就可以算出来。

按照点分治的经典套路，我们用一个 `map` 存下来所有 $v \to l$ 构成的字符串的哈希值，在遍历另一棵子树的时候首先判断 $p \to l$ 构成的字符串是不是回文串（这个可以通过简单的正反哈希得到），然后再判断 $u \to p$ 字符串的哈希值是否曾经出现过，如果出现过，则 $k$ 是一个答案，否则继续点分治即可。

时间复杂度是 $O(n \log^3 n)$。

## 优化

这个时间复杂度在洛谷和 LOJ 上均可通过，我们有没有更加优秀的方式呢？

1. `map` 可以换成手写哈希表。
2. 如果当前 $l$ 为分治中心的连通块的直径小于 $k$，肯定不存在答案。
3. 如果找到了答案直接返回即可。

这样的话时间复杂度就是 $O(n \log^2 n)$，并且常数也不大了。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mod 1000000007
#define base 13331
#define N 100005
using namespace std;
mt19937 rnd(time(0));
vector<int> now;
int n,m,k,i,x,y,z,la[N],ne[N<<1],to[N<<1],dep[N],tot,col[N],siz[N],tim,ans,l,r,mid,depth,hass,sta[N],top,vis[N],du[N],ps[N],iddd[N],a[N],maxlen,dp[N];
ll p[N],has[N];
char s[N];
struct hsh_table{
	int val[2000005],ne[2000005],head[2000005],tot=0;
	void clear(){
		for(int i=1;i<=tot;i++) head[val[i]%1999997]=0,ne[i]=0;
		tot=0;
	}
	void insert(int x){
		int p = x%1999997;
		tot++,ne[tot] = head[p],head[p] = tot,val[tot] = x;
	}	
	bool found(int x){
		int p = x%1999997;
		for(int i=head[p];i;i=ne[i]) if(val[i]==x) return 1;
		return 0;
	}
}lenth,lenth2;
inline void merge(int x,int y){tot++,ne[tot]=la[x],la[x]=tot,to[tot]=y;}
void found(int x,int fa,int &pos,int &now,int all){
	int cut = 0;
	siz[x] = 1,dp[x] = 1;
	for(int i=la[x];i;i=ne[i]){
		if(to[i]==fa||col[to[i]]!=col[x]) continue;
		found(to[i],x,pos,now,all);
		siz[x] += siz[to[i]];
		maxlen = max(maxlen,dp[x]+dp[to[i]]),dp[x] = max(dp[x],dp[to[i]]+1);
		cut = max(cut,siz[to[i]]);
	}
	maxlen = max(maxlen,dp[x]);
	cut = max(cut,all-siz[x]);
	if(cut<now) now=cut,pos=x;
}
void solve(int x,int fa,ll s1,ll s2,ll s3){
	has[x] = s1,sta[++top] = x;
//	if(depth==5&&x==6) cout<<s1<<" "<<s2<<endl;
	if(s1==s2) vis[x]=1;
	if(dep[x]+1==depth&&vis[x]) hass=1;   //son to root
	
	if(lenth.found(s3)) hass=1;
	int len = depth-(dep[x]+1);
//	if(depth==5) cout<<"? "<<x<<" "<<len<<" "<<top<<endl;
	if(dep[x]+1-len>=1&&vis[sta[dep[x]+1-len]]){
		if(lenth2.found(((has[x]-has[sta[dep[x]+1-len]]*p[len])%mod+mod)%mod)) hass=1;
	}
	if(len<0){
		top--;
		return ;
	}
	for(int i=la[x];i;i=ne[i]){
		if(to[i]==fa||col[x]!=col[to[i]]) continue;
		dep[to[i]] = dep[x]+1;
		solve(to[i],x,(s1*base+a[to[i]])%mod,(s2+a[to[i]]*p[dep[to[i]]])%mod,(s3*base+a[to[i]])%mod);
	}
	top--;
}
void solve2(int x,int fa,ll s1,ll s2,ll s3){
	sta[++top] = x,has[x] = s1,lenth2.insert(s3);
	int len = depth-(dep[x]+1);
	if(len<0){
		top--;
		return ;
	}
	if(dep[x]+1-len>=1&&vis[sta[dep[x]+1-len]]) lenth.insert(((has[x]-has[sta[dep[x]+1-len]]*p[len])%mod+mod)%mod);
	for(int i=la[x];i;i=ne[i]){
		if(to[i]==fa||col[x]!=col[to[i]]) continue;
		solve2(to[i],x,(s1*base+a[to[i]])%mod,(s2+a[to[i]]*p[dep[to[i]]])%mod,(s3*base+a[to[i]])%mod);
	}
	top--;
}
void solve3(int x,int fa,int tim){
	vis[x] = 0;
	for(int i=la[x];i;i=ne[i]){
		if(to[i]==fa||col[x]!=col[to[i]]) continue;
		solve3(to[i],x,tim);
	}
	col[x] = tim;
}
void dfs(int x,int all){
	int pos = -1,now = INT_MAX;
	maxlen = 1;
	found(x,-1,pos,now,all);
//	cout<<pos<<" "<<maxlen<<endl;
	if(maxlen<depth) return ;
//	cout<<"! "<<pos<<endl;
//	cout<<depth<<endl;
//	if(depth==5) cout<<"! "<<pos<<endl;
	sta[++top] = pos,vis[pos] = 1,has[pos] = a[pos],dep[pos] = 0;
	for(int i=la[pos];i;i=ne[i]){
		if(col[to[i]]!=col[pos]) continue;
		dep[to[i]]=1,solve(to[i],pos,(a[pos]*base+a[to[i]])%mod,(a[to[i]]*base+a[pos])%mod,a[to[i]]);
		solve2(to[i],pos,(a[pos]*base+a[to[i]])%mod,(a[to[i]]*base+a[pos])%mod,a[to[i]]);
		if(hass) break; 
	}
	top--,lenth.clear(),lenth2.clear();
	if(hass) return ;
	for(int i=la[pos];i;i=ne[i]){
		if(col[to[i]]!=col[pos]) continue;
		solve3(to[i],pos,++tim);
		dfs(to[i],siz[to[i]]);
	}
}
inline bool check(int x){
	if(x==0||x==1) return 1;
	if(x>n) return 0;
	for(int i=1;i<=n;i++) sta[i]=0,dep[i]=0,dep[i]=0,has[i]=0,vis[i]=0,col[i]=0;
	tim=0,depth=x,hass=0;
	dfs(1,n);
	return hass;
}
void dfss(int x,int fa){
	dp[x] = 1;
	for(int i=la[x];i;i=ne[i]){
		if(to[i]==fa) continue;
		dfss(to[i],x);
		maxlen = max(maxlen,dp[to[i]]+dp[x]);
		dp[x] = max(dp[x],dp[to[i]]+1);
	}
	maxlen = max(maxlen,dp[x]);
}
signed main(){
//	freopen("1.in","r",stdin);
	scanf("%d%s",&n,s+1);
	p[0]=1;
	for(i=1;i<=n;i++) p[i]=p[i-1]*base%mod;
	for(i=1;i<n;i++) scanf("%d%d",&x,&y),merge(x,y),merge(y,x),du[x]++,du[y]++;
	if(du[1]==1&&du[n]==1){
		for(i=2;i<n;i++){
			if(du[i]!=2) break;
		}
		if(i==n){
			a[++m]='#';
			for(i=1;i<=n;i++) a[++m]='*',a[++m]=s[i];
			a[++m]='*',a[++m]='$';
			for(i=1,l=0,r=0;i<=m;i++){
				if(i<=r) ps[i]=min(ps[2*l-i],r-i+1);
				while(i>ps[i]&&i+ps[i]<=m&&a[i-ps[i]]==a[i+ps[i]]) ps[i]++;
				if(i+ps[i]-1>=r) l=i,r=i+ps[i]-1;
				ans=max(ans,ps[i]-1);
			}
			cout<<ans<<endl;
			return 0;
		}
	}
	for(i=1;i<=10000;i++) iddd[i]=i;
	random_shuffle(iddd+1,iddd+10001);
	for(i=1;i<=n;i++) a[i]=iddd[s[i]];
	dfss(1,-1);
	int maxlens = maxlen;
	l=1,r=maxlen/2+1;
	while(l<r){
		mid=(l+r+1)/2;
//		cout<<l<<" "<<r<<" "<<mid*2-1<<" "<<check(mid*2-1)<<endl;
		if(check(mid*2-1)) l=mid;
		else r=mid-1;
	}
	ans=max(ans,l*2-1);
	if(!check(l*2)){
		cout<<ans<<endl;
		return 0;
	}
	r=maxlens/2;
	while(l<r){
		mid=(l+r+1)/2;
		if(check(mid*2)) l=mid;
		else r=mid-1;	
	}
	ans=max(ans,l*2);
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Genshineer (赞：0)

## P7206 [COCI2019-2020#3] Lampice

团队奆神 @居然有个高手 出题的时候帮忙查重才查到的题，标算应该是 $O(n\log^3n)$ 或常数巨大的 $O(n\log^2n)$ 复杂度的，但是奆佬 @clyclycly 和 @居然有个高手 发现算法可以优化到 $O(n\log^2n)$。

#### 题意简述

给定一棵树，每个节点有一个字母，求树上最长回文路径。

#### 分析

- **Subtask1:** 直接暴力即可，枚举起点做 `dfs`，记录对应的正反 `Hash` 值，二者相等时暴力统计即可。复杂度 $O(n^2)$。期望得分 $17pts$。

- **Subtask2:** 显然此时树的形态是一条链，显然可以直接在原串上做 `Manacher`，结合上文，期望得分达到 $42pts$。

- **正解：**（为什么不讲 `Subtask3`？~~因为我也不知道它有什么性质~~）。
首先不难发现，由于回文串的头尾相同，所以当存在长度为 $2k(k\in\N_+)$ 的合法路径时，长度为 $2(k-1), 2(k-2), \dots, 4, 2$ 的合法路径一定存在；同理，当存在长度为 $2k-1$ 的合法路径时，长度为 $2(k-1)-1,2(k-2)-1,\dots,3,1$ 的合法路径也一定存在。于是启发我们进行奇偶分组二分从而将求值问题转化为判定性问题。
于是考虑判定的过程枚举 $lca$，统计从 $lca$ 的每一棵子树到另一棵子树（包含 $lca$ 本身）的路径。统计过程中，不妨定义我们已经统计好的路径为**左链**，则我们可以记录左链的正反 $Hash$ 值，记作 $Hash_l$ 和 $reHash_l$，以及路径长度 $len_l$。与其对应，目前正在统计的则为**右链**，并与**左链**对应分别定义正反 $Hash$ 值与长度 $Hash_r,reHash_r,len_r$。记 $Hash$ 实现中进位制为 $p$ 进制，总的链长度为 $len$，若左右匹配，那么就应该满足 $Hash_l\times p^{len_r}+Hash_r=reHash_r\times p^{len_l}+reHash_l$。移项整理得 $Hash_l\times p^{len_r}-reHash_l=reHash_r\times p^{len_l}-Hash_r$。则等式左右两边只与 $l,r$ 相关，考虑用 `unordered_map` 存储。这样复杂度就为 $O(n^2\log n)$。
这显然是好优化的：用点分治可以控制树高为 $\log n$ 级别，于是复杂度优化为 $O(n\log^2n)$。
然而此题并没有就此结束（因为奆(~~du~~)佬(~~liu~~)出了毒瘤数据卡常数）：考虑 `unordered_map` 常数巨大，于是手写 $Hash Table$ 优化掉这个常数；观察到二分次数较多，直接建出点分树；求出树的直径缩小二分上界；判断当前连通块的直径与 $len$ 的大小进行剪枝；当左右的链长之一超过 $len$ 时，直接剪枝掉。
这样就得到了常数较小的 $O(n\log^2n)$。

PS：经过实验测试，如果此题的数据完全随机且点数 $n$ 为 $1\times10^5$ 量级，回文串长度会稳定于 $9$ 左右，概率稳定于 $50\%$ 左右（~~本题不满足此性质~~）。

此处给出 `COCI` 提供的官方 `std` 和碾爆 `std` 的奆佬 @clyclycly 的 $O(n\log^2n)$ 做法。

```cpp
/*
COCI 的官方 std，很有 C++ 风格的代码。
由于大量使用 STL 容器，常数巨大，但足以通过本题。
*/
#include <bits/stdc++.h>
using namespace std;

const int maxn = 5e4 + 5;

struct Tree {
	vector<int> nodes;  // original mapping
	vector<int> adj[maxn];
};

class Decompositor {
public:
	Decompositor(const Tree &tree) : tree_(tree), next_label_(0) {
		size_.resize(tree.nodes.size());
		done_.resize(tree.nodes.size());
		queue_.push(0);
	}

	// vraca sljedece dekomponirano stablo
	bool NextTree(Tree &decomposed_tree) {
		int node = GetQueuedNode();
		if (node == -1) return false;

		CalculateSize(node);
		int centroid = FindCentroid(node, size_[node]);
		assert(centroid != -1);

		// build tree
		next_label_ = 0;
		BuildTree(decomposed_tree, centroid);

		// mark labels
		done_[centroid] = true;
		for (int y : tree_.adj[centroid])
			queue_.push(y);
		return true;
	}

private:
	const Tree &tree_;
	queue<int> queue_;
	vector<int> size_;
	vector<bool> done_;
	int next_label_;

	int GetQueuedNode() {
		for (; !queue_.empty(); queue_.pop()) {
			int x = queue_.front();
			if (!done_[x]) return x;
		}
		return -1;
	}

	void CalculateSize(int x, int prev = -1) {
		size_[x] = 1;
		for (int y : tree_.adj[x]) {
			if (y == prev || done_[y]) continue;
			CalculateSize(y, x);
			size_[x] += size_[y];
		}
	}

	int FindCentroid(int x, int tot_size, int prev = -1) {
		if (IsCentroid(x, tot_size)) return x;
		for (int y : tree_.adj[x]) {
			if (y == prev || done_[y]) continue;
			int q = FindCentroid(y, tot_size, x);
			if (q != -1) return q;
		}
		return -1;
	}

	bool IsCentroid(int x, int tot_size) {
		bool flag = false;
		if (2 * (tot_size - size_[x]) > tot_size) return false;
		for (int y : tree_.adj[x]) {
			if (done_[x] || size_[y] > size_[x]) continue;
			if (2 * size_[y] > tot_size) return false;
		}
		return true;
	}

	void BuildTree(Tree &target, int x, int prev = -1, int prev_label = -1) {
		int label = next_label_++;
		target.nodes[label] = x;
		if (prev_label != -1)
			target.adj[prev_label].push_back(label);
		for (int y : tree_.adj[x]) {
			if (y == prev || done_[y]) continue;
			BuildTree(target, y, x, label);
		}
	}
};

const int MAXN = 100100;
char input[MAXN];

class TreeSolver {
public:
	TreeSolver(const Tree &tree): tree_(tree) {
		hash_down_.resize(tree.nodes.size());
		hash_up_.resize(tree.nodes.size());
		hash_set_.resize(tree.nodes.size());
		stack_.reserve(tree.nodes.size());
	}

	void Build(int x = 0, int dep = 0, long long hdown = 0, long long hup = 0) {
		const char c = input[tree_.nodes[x]];
		hash_down_[x] = hdown * BASE + c;
		hash_up_[x] = hup + power_[dep] * c;
		for (int y : tree_.adj[x]) {
			Build(y, dep + 1, hash_down_[x], hash_up_[x]);
		}
	}

	int Solve() {
		return max(2 * Run(0) + 1, 2 * Run(1));
	}

	int Run(int k) {
		int lo = 0, hi = (int)tree_.nodes.size();
		while (lo < hi) {
			int mid = (lo + hi + 1) / 2;
			if (Check(mid, k)) lo = mid;
			else hi = mid - 1;
		}
		return lo;
	}

	static void InitPowers() {
		power_[0] = 1;
		for (int i = 1; i < MAXN; ++i)
			power_[i] = power_[i - 1] * BASE;
	}

private:
	static const int BASE = 31337;
	static long long power_[MAXN];
	Tree tree_;
	vector<long long> hash_down_;
	vector<long long> hash_up_;
	vector<unordered_set<long long>> hash_set_;
	vector<int> stack_;

	void SetHashes(int x, int dep) {
		hash_set_[dep].insert(hash_down_[x]);
		for (int y : tree_.adj[x])
			SetHashes(y, dep + 1);
	}

	void ResetHashes() {
		for (auto &it : hash_set_)
			it.clear();
	}

	// k 0 za neparno, 1 za parno
	bool Check(int len, int k) {
		// pazi na prazni string
		if (len == 0 && k == 1) return true;
		stack_.clear();
		stack_.push_back(0);
		const int n = (int)tree_.adj[0].size();
		for (int step = 0; step < 2; ++step) {
			ResetHashes();
			for (int i = 0; i < n; ++i) {
				const int node = tree_.adj[0][i];
				if (i > 0 && CheckSubtree(len, node, k)) return true;
				if (i + 1 != n) SetHashes(node, 1);
			}
			reverse(tree_.adj[0].begin(), tree_.adj[0].end());
		}
		return false;
	}

	bool CheckSubtree(int len, int x, int k) {
		const int dep = (int)stack_.size();
		stack_.push_back(x);
		bool ret = false;
		if (dep >= len) {
			if (CheckChain(len, dep, k)) {
				stack_.pop_back();
				return true;
			}
		}
		for (int y : tree_.adj[x]) {
			if (CheckSubtree(len, y, k)) {
				stack_.pop_back();
				return true;
			}
		}
		stack_.pop_back();
		return false;
	}

	bool CheckChain(int len, int dep, int k) {
		int tot_len = 2 * len - k;
		if (dep >= tot_len) {
			long long hdown = hash_down_[stack_.back()];
			long long hup = hash_up_[stack_.back()];
			int i = dep - tot_len;
			if (i > 0) {
				hdown -= power_[tot_len + 1] * hash_down_[stack_[i - 1]];
				hup -= hash_up_[stack_[i - 1]];
			}
			return hdown * power_[i] == hup;
		}
		int tail = tot_len - dep;
		int head = dep - tail;
		if (hash_down_[stack_[head]] != hash_up_[stack_[head]])
			return false;
		long long hdown = hash_down_[stack_.back()];
		if (head > 0) hdown -= power_[tail + 1] * hash_down_[stack_[head - 1]];
		return hash_set_[tail].find(hdown) != hash_set_[tail].end();
	}
};

long long TreeSolver::power_[MAXN];

void LoadTree(Tree &tree) {
	int n;
	scanf("%d", &n);
	scanf("%s", input);
	for (int i = 0; i < n - 1; ++i) {
		int u, v;
		scanf("%d%d", &u, &v);
		u--;
		v--;
		tree.adj[u].push_back(v);
		tree.adj[v].push_back(u);
	}
}

int main(void) {
	TreeSolver::InitPowers();

	Tree tree;
	LoadTree(tree);
	Decompositor decomp(tree);

	// border case :/
	if (tree.nodes.size() == 2 && input[0] == input[1]) {
		printf("2\n");
		return 0;
	}

	int ans = 0;
	for (Tree decomp_tree; decomp.NextTree(decomp_tree);) {
		TreeSolver solver(decomp_tree);
		solver.Build();
		ans = max(ans, solver.Solve());
	}

	printf("%d\n", ans);

	return 0;
}

```

```cpp
/*
@clyclycly 奆神的代码，最优解排行榜一。
*/
#include <bits/stdc++.h>
using namespace std;
namespace FastIO {
char buf[1 << 10], buf2[1 << 21], a[21], *p1 = buf, *p2 = buf, hh = '\n';
int p, p3 = -1;
void read() {}
void print() {}
inline int getc() {
	return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 10, stdin), p1 == p2) ? EOF : *p1++;
}
inline void read(int &x) {
	x = 0;
	char ch = getc();
	while (!isdigit(ch)) {
		ch = getc();
	}
	while (isdigit(ch)) {
		x = (x << 1) + (x << 3) + (ch ^ '0');
		ch = getc();
	}
}
inline void print(int x) {
	do {
		a[++p] = x % 10 + 48;
	} while (x /= 10);
	do {
		buf2[++p3] = a[p];
	} while (--p);
	buf2[++p3] = hh;
	fwrite(buf2, 1, p3 + 1, stdout), p3 = -1;
}
}
#define read FastIO::read
#define print FastIO::print
int sum;
const int N=2e5+5,p=13331;
unsigned long long Pow[N],cd[N/2],cu[N/2];
int n,head[N],tot,sz[N],mx,rot,ans,mxdep,mxl[N],st[N],cs[N],top,len,fr,g,root[N],tp,sT,ed;
pair<int,int> q[N];
char s[N];
bool bz[N],Pd;
struct Vint {
	int head[N],tot,rt[N];
	struct node {
		int nex,y;
	} e[N];
	inline void add(int p,int x) {
		e[++tot]= {rt[p],x};
		rt[p]=tot;
	}
} mxd;
struct Vun {
	int head[N],tot,rt[N];
	struct node {
		int nex;
		unsigned long long y;
	} e[N];
	inline void add(int p,unsigned long long x) {
		e[++tot]= {rt[p],x};
		rt[p]=tot;
	}
} v;
struct edge {
	int nex,y;
} e[N<<1];
inline void add(int x,int y) {
	e[++tot]= {head[x],y};
	head[x]=tot;
}
const int mod=199999;
struct Hash {
	int head[mod],tot,del[N];
	struct edge {
		int nex,c;
		unsigned long long y;
	} e[N];
	inline void clear() {
		while(del[0]) head[del[del[0]--]]=0;
		tot=0;
	}
	inline void insert(unsigned long long x) {
		int t=x%mod;
		for(register int i=head[t]; i; i=e[i].nex) {
			if(e[i].y==x) {
				e[i].c++;
				return;
			}
		}
		if(!head[t]) del[++del[0]]=t;
		e[++tot]= {head[t],1,x};
		head[t]=tot;
	}
	inline void erase(unsigned long long x) {
		int t=x%mod;
		for(register int i=head[t]; i; i=e[i].nex) {
			if(e[i].y==x) {
				e[i].c--;
				return;
			}
		}
	}
	inline int ask(unsigned long long x) {
		int t=x%mod;
		for(register int i=head[t]; i; i=e[i].nex) if(e[i].y==x) return e[i].c;
		return 0;
	}
} hd;
inline void dfs(int x,int f,int Sz,int d) {
	sz[x]=1;
	mxdep=max(mxdep,d++);
	int t=-1;
	for(register int i=head[x]; i; i=e[i].nex) {
		int y=e[i].y;
		if((y^f)&&!bz[y]) dfs(y,x,Sz,d),sz[x]+=sz[y],t=max(t,sz[y]);
	}
	t=max(t,Sz-sz[x]);
	if(t<mx) mx=t,rot=x;
}
inline void dfs1(int x,int f,int d,unsigned long long dis1,unsigned long long dis2) {
	if(Pd||d>=len) return;
	dis1=dis1*p+s[x],dis2=dis2+Pow[d++]*s[x];
	cd[d]=dis1;
	cu[d]=dis2;
	if((len>>1)<=d) {
		int t=len>>1;
		unsigned long long t1=dis1-Pow[t]*cd[d-t];
		if(d==t) {
			if(len&1) {
				if(hd.ask(t1+s[fr]*Pow[d])) {
					Pd=1;
					return;
				}
			} else if(hd.ask(t1)) {
				Pd=1;
				return;
			}
		} else if(hd.ask(t1-cu[d-t-(len&1)]*Pow[len-d])) {
			Pd=1;
			return;
		}
	}
	for(register int i=head[x]; i; i=e[i].nex) if((e[i].y^f)&&!bz[e[i].y]) dfs1(e[i].y,x,d,dis1,dis2);
}
inline void dfs2(int x,int f,int d,unsigned long long dis1) {
	dis1=dis1*p+s[x];
	v.add(g,dis1);
	hd.insert(dis1);
	if(d>=(len+1>>1)) return;
	for(register int i=head[x]; i; i=e[i].nex) if((e[i].y^f)&&!bz[e[i].y]) dfs2(e[i].y,x,d+1,dis1);
}
inline void calc(int x) {
	if(mxl[x]<len) return;
	top=0;
	for(register int i=head[x]; i; i=e[i].nex) if(!bz[e[i].y]) st[++top]=e[i].y;
	hd.clear(),hd.insert(s[x]),fr=x,g=v.tot=0;
	for(register int i=1; i<=top; ++i) g++,v.rt[g]=0,dfs2(st[i],x,2,s[x]);
	for(register int i=top,j=mxd.rt[x]; i>=1; --i,j=mxd.e[j].nex) {
		if(mxd.e[j].y>=(len>>1)) {
			for(register int k=v.rt[i]; k; k=v.e[k].nex) hd.erase(v.e[k].y);
			dfs1(st[i],x,0,0,0);
			for(register int k=v.rt[i]; k; k=v.e[k].nex) hd.insert(v.e[k].y);
			if(Pd) return;
		}
	}
//	cout<<x<<": "; for(register int i=1;i<=top;++i) cout<<st[i]<<" "; cout<<" -> "<<ans<<"\n";
}
inline void Solve(int x,int sum) {
	root[++tp]=x;
	bz[x]=1;
	int t1,t2;
	t1=t2=0;
	for(register int i=head[x],y; i; i=e[i].nex) {
		y=e[i].y;
		if(!bz[y]) {
			int cnt=sz[x]>sz[y]?sz[y]:sum-sz[x];
			mxdep=-1e9,mx=1e9,dfs(y,0,cnt,1);
			mxd.add(x,mxdep);
			cs[x]++;
			if(mxdep>=t1) t2=t1,t1=mxdep;
			else t2=max(t2,mxdep);
			Solve(rot,cnt);
		}
	}
	mxl[x]=t1+t2+1;
}
inline void solve(int x) {
	if(Pd) return;
	bz[x]=1;
	calc(x);
	for(register int i=1; i<=cs[x]; ++i) solve(root[++tp]);
}
inline bool check(int mid) {
	len=mid,Pd=0;
	while(tp) bz[root[tp--]]=0;
	solve(root[++tp]);
	return Pd;
}
inline pair<int,int> BFS(int t) {
	sT=0,ed=-1;
	q[++ed]= {0,t};
	int mx,mx2=-1;
	while(sT<=ed) {
		int x=q[sT].second,c=q[sT++].first;
		bz[x]=1;
		if(c>mx2) mx2=c,mx=x;
		for(register int i=head[x]; i; i=e[i].nex) if(!bz[e[i].y]) q[++ed]= {c+1,e[i].y};
	}
	for(register int i=1; i<=n; ++i) bz[i]=0;
	return {mx2,mx};
}
int main() {
//	freopen("path17.in","r",stdin);
//	freopen("t1.out","w",stdout);
	ans=1,scanf("%d%s",&n,s+1);
	Pow[0]=1;
	for(register int i=1; i<=n; ++i) Pow[i]=Pow[i-1]*p;
	for(register int i=1,x,y; i<n; ++i) {
		read(x),read(y);
		add(x,y),add(y,x);
	}
	mx=1e9,dfs(1,0,n,0);
	Solve(rot,n);
	for(register int i=1; i<=n; ++i) bz[i]=0;
	tp=0;
	pair<int,int> t=BFS(1),t2=BFS(t.second);
	int l=1,r=t2.first+2>>1,mid;
	while(l<=r) {
		mid=l+r>>1;
		if(check(mid<<1)) l=mid+1;
		else r=mid-1;
	}
	ans=max(ans,r<<1);
	l=r,r=t2.first>>1;
	if(l<=r) {
		while(l<=r) {
			mid=l+r>>1;
			if(check(mid<<1|1)) l=mid+1;
			else r=mid-1;
		}
		ans=max(ans,r<<1|1);
	}
	print(ans);
	return 0;
}
```

---


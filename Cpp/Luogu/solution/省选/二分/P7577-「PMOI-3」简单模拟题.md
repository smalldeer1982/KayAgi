# 「PMOI-3」简单模拟题

## 题目描述

给定一个长度为 $n$ 的序列 $s$。

$q$ 次询问，每个询问形如 `a b c d e f`，需要你求出下面式子的值：
$$\sum_{L=a}^{b}[e\le G(F(L,c),F(L,c+1),\cdots,F(L,d))\le f]$$
这里 $F(l,r)$ 表示 $s$ 序列区间 $[l,r]$ 中不同的数的个数，$G(x_1,x_2,\cdots,x_k)$ 表示 $x_1,x_2,\cdots,x_k$ 中不同的数的个数。

## 说明/提示

【样例一解释】

第一次询问中，$a=1,b=1,c=3,d=3,e=1,f=1$。

不难得到 $G(F(1,3))=1$，且 $e\le G(F(1,3))\le f$，所以答案为 $1$。

【样例二解释】
| 询问编号 | $a$ | $b$ | $c$ | $d$ | $e$ | $f$ |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| ① | 3 | 4 | 5 | 6 | 1 | 2 |
| ② | 2 | 5 | 8 | 10 | 2 | 4 |
| ③ | 3 | 6 | 6 | 8 | 1 | 3 |

【数据范围】

**本题采用捆绑测试**。
- Subtask1（10pts）：$n,q\le500$，$1\le s_i\le10^6$；
- Subtask2（15pts）：$n,q\le3\times10^3$；
- Subtask3（20pts）：$b-a\le20$；
- Subtask4（25pts）：$n,q\le10^5$；
- Subtask5（30pts）：无特殊限制。

对于 $100\%$ 的数据满足，$1\le n,q\le3\times10^5$，$0\le|s_i|\le10^9$，对于所有询问，$1\le a,b,c,d\le n$，$0\le e\le f\le n$。

【提示】
1. 本题中，$[x \le y \le z]$ 表示 $y$ 是否 $\in[x,z]$。如果在该区间内，则值为 $1$；否则为 $0$。

2. 输入量较大，请采用较快的读入方式。

## 样例 #1

### 输入

```
3 1
2020 2021 2020
3 3 2 2 1 1```

### 输出

```
1```

## 样例 #2

### 输入

```
10 3
2 2 4 3 5 3 5 4 1 2
3 5 2 4 1 2
5 7 2 9 2 4
1 3 1 8 1 3```

### 输出

```
2
4
4```

# 题解

## 作者：Graphcity (赞：4)

### 思路

我们不妨从最暴力的方法想一想，总共有 $q$ 个询问需要 $O(q)$，枚举 $[a,b]$ 的 $L$ 值需要 $O(n)$，枚举 $[c,d]$ 中的值需要 $O(n)$，暴力计算 $F$ 函数的值还要 $O(n)$，总共 $O(n^3q)$，铁定超时。

显然那个 $O(q)$ 是不能够消除的，那我们考虑优化那三个 $O(n)$。

首先 **在线** 计算 $F$ 函数可以用分块 $O(\sqrt{n})$ 或 $O(\sqrt{n}\log n)$，但是前一种做法需要预处理前缀块的出现次数，空间复杂度 $O(n\sqrt{n})$ 会被卡。而第二种做法时间复杂度太高，也会被卡。于是我们考虑主席树，时间复杂度 $O(\log n)$，空间复杂度 $O(40n)$，刚刚好。现在时间复杂度被优化到了 $O(n^2q\log n)$。

接着，我们发现 $F(l,r)$ 与 $F(l,r+1)$ 之间只差了 $s_{r+1}$ 对函数的贡献，而它不小于 0，最多为 1。也就是说，$F(L,c)$ 到 $F(L,d)$ 之间的值必然 **不下降**，而且每相邻两个数相差 **至多为 1**。所以，$G(F(L,c),F(L,c+1),\cdots,F(L,d))=F(L,d)-F(L,c)+1$ ，又优化掉了一个 $O(n)$，此时时间复杂度变为 $O(nq\log n)$。

现在时间复杂度瓶颈就变成了枚举 $L$ 上。这个时候，我们就可以试着猜一猜求和符号右边的式子有什么规律了。事实上，求和符号右边的式子是 **随着 $L$ 的增大而增大** 的。我们来证明一下：

当 $L=k$ 时，右边的值为 $F(k,d)-F(k,c)+1$，而当 $L=k+1$ 时，右边为 $F(k+1,d)-F(k+1,c)$。两者的区别仅仅在于 $s_k$ 产生的贡献。

- 当 $s_k$ 在 $[k+1,d]$ 不出现时，$F(k,d)$ 和 $F(k,c)$ 分别会比 $F(k+1,d)$ 和 $F(k+1,c)$ 大 1，相当于没起到作用。
- 当 $s_k$ 在 $[k+1,c]$ 出现时，$F(k,d)$ 和 $F(k,c)$ 和后面相比没有任何变化，相当于不起作用。
- 当 $s_k$ 仅在 $[c+1,d]$ 出现时，$F(k,d)$ 相较后面没有变化，而 $F(k,c)$ 加上了 1，总共 **减去了 1**。

综上，证明成立，且 $L=k+1$ 相较 $L=k$ 时，**值至多会增加 1**。于是我们便可以愉快地二分了，总时间复杂度变成了 $O(q\log^2 n)$，在有 O2 优化的情况下可以跑过去。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int Maxn=3e5;

inline int read()
{
    char ch=getchar();
    int f=1,x=0;
    while(ch>'9' || ch<'0')
    {
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}

struct Node{int l,r,siz;} t[Maxn*40+5];
int tot,rt[Maxn+5];
#define ls(x) t[x].l
#define rs(x) t[x].r

int n,m,lst,h[Maxn+5],cnt[Maxn+5],nxt[Maxn+5],Q[10];
vector<int> v;

inline void Insert(int l,int r,int L,int &R,int val)
{
    t[++tot]=t[L],R=tot,t[R].siz++;
    if(l==r) return;
    int mid=(l+r)>>1;
    if(val<=mid) Insert(l,mid,ls(L),ls(R),val);
    else Insert(mid+1,r,rs(L),rs(R),val);
}
inline int Find(int l,int r,int L,int R,int val)
{
    if(l==r) return t[R].siz-t[L].siz;
    int mid=(l+r)>>1;
    if(val<=mid) return t[rs(R)].siz-t[rs(L)].siz+Find(l,mid,ls(L),ls(R),val);
    else return Find(mid+1,r,rs(L),rs(R),val);
}
inline int F(int l,int r) {return Find(1,n+1,rt[l-1],rt[r],r+1);}
inline void Solve()
{
    while(m--)
    {
        int a,b,c,d,e,f,l,r,siz=-1;
        for(int i=1;i<=4;++i) Q[i]=(read()+lst)%n+1;
        sort(Q+1,Q+5),a=Q[1],b=Q[2],c=Q[3],d=Q[4],e=read(),f=read(),l=a-1,r=b;
        while(l<r)
        {
            int mid=(l+r+1)/2;
            if(mid==a-1 || F(mid,d)-F(mid,c)+1<e) l=mid;
            else r=mid-1;
        }
        siz-=l,l=a,r=b+1;
        while(l<r)
        {
            int mid=(l+r)/2;
            if(mid==b+1 || F(mid,d)-F(mid,c)+1>f) r=mid;
            else l=mid+1;
        }
        siz+=l,lst=siz; printf("%d\n",siz);
    }
}
inline void Init()
{
    n=read(),m=read();
    for(int i=1;i<=n;++i) v.push_back(h[i]=read()),cnt[i]=n+1;
    sort(v.begin(),v.end()),v.erase(unique(v.begin(),v.end()),v.end());
    for(int i=1;i<=n;++i) h[i]=lower_bound(v.begin(),v.end(),h[i])-v.begin()+1;
    for(int i=n;i>=1;--i) nxt[i]=cnt[h[i]],cnt[h[i]]=i;
    for(int i=1;i<=n;++i) Insert(1,n+1,rt[i-1],rt[i],nxt[i]);
}

int main()
{
    Init(),Solve();
    return 0;
}
```



---

## 作者：wdgm4 (赞：2)

~~做这道题的人好少啊，吓得我以为这道题难死了。QWQ~~

~~但是这个蒟蒻不会二分而调了几个小时。QWQ~~

## 前言

前置芝士：[主席树在线求区间内不同数字的个数](https://www.luogu.com.cn/problem/P1972)

~~虽然但是我这道题主席树没卡过去。QWQ~~

建议用主席树过了（或保证思路正确）上面的题再来做这道题。

## 正文

看到这道题一串~~辣么长的~~式子，肯定是要推一下式子。

首先看 $F(L,c)$ 和 $F(L,c+1)$ 这两个东西，不难发现，$F(L,c+1)$ 一定比 $F(L,c)$ 大 $1$，或者相等。所以我们可以得出一个结论，一个区间的右端点不断右移，这个区间中不同的数的个数将以一个一个的速度增加（也可能不加）。那么对于 $G(F(L,c),F(L,c+1),⋯,F(L,d))$（这里的 $L$ 固定），$F(L,c)$ 的右端点右移到 $F(L,d)$ 的过程中值增加了多少，这个 $G$ 函数的值就是多少。所以整个式子就可以转换为：

$$\sum\limits_{L=a}^b[e \le F(L,d)-F(L,c)+1 \le f]$$

现在来看 $F(L,d)-F(L,c)+1$，当 $[L,d]$ 和 $[L,c]$ 的左端点不断右移，$F(L,d)$ 和 $F(L,c)$ 变化情况有三种：

> 1. $F(L,d)$ 和 $F(L,c)$ 都不变。
>
> 2. $F(L,d)$ 不变，$F(L,c)$ 减 $1$。
>
> 3. $F(L,d)$ 和 $F(L,c)$ 都减 $1$。

结合起来，可以发现，$F(L,d)-F(L,c)+1$ 的值变化是不下降的，符合单调性。

那就可以对其进行二分，找到第一个 $F(L,d)-F(L,c)+1$ 的值大于等于 $e$ 的 $L_1$，找到第一个 $F(L,d)-F(L,c)+1$ 小于等于 $f$ 的 $L_2$，那么答案就是 $L_2-L_1+1$。

在二分的过程中需要判断是将二分中的右端点左移还是将左端点右移，这里只需求出 $F(L,d)-F(L,c)+1$ 的值就行了，而求这个式子就需要用主席树在线求了。

具体的来看代码吧。

```cpp
#include<bits/stdc++.h>
#define XD 114514
#define MAXN 300010
using namespace std;
int n,q;
map<int,int> m;
struct tree{
	int l,r,val;
} t[MAXN*90];
int top[MAXN],cnt;
int modify(int x,int l,int r,int k){
	int nem=++cnt;
	t[nem]=t[x];t[nem].val++;
	if(l==r) return nem;
	int mid=l+r>>1;
	if(k<=mid) t[nem].l=modify(t[x].l,l,mid,k);
	else t[nem].r=modify(t[x].r,mid+1,r,k);
	return nem;
}
int query(int x,int y,int l,int r,int k){
	if(l==r or r<=k) return t[y].val-t[x].val;
	int mid=l+r>>1;
	if(k<mid) return query(t[x].l,t[y].l,l,mid,k);
	else if(k==mid) return t[t[y].l].val-t[t[x].l].val;
	else return t[t[y].l].val-t[t[x].l].val+query(t[x].r,t[y].r,mid+1,r,k);
}
int cab[MAXN],last,a,b,c,d,e,f;
int search(int x){
	int nem1,nem2;
	nem1=query(top[x-1],top[d],0,n,x-1);
	nem2=query(top[x-1],top[c],0,n,x-1);
	return nem1-nem2+1;
}
int solve(){
	if(f<search(a) or search(b)<e) return 0;
	int l=a,r=b,ans1=b;
	while(l<=r){
		int mid=l+r>>1;
		if(e<=search(mid)) r=mid-1,ans1=mid;
		else l=mid+1;
	}
	int ll=a,rr=b,ans2=b;
	while(ll<=rr){
		int mid=ll+rr>>1;
		if(search(mid)<=f) ll=mid+1,ans2=mid;
		else rr=mid-1;
	}
	return ans2-ans1+1;
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>q;
	for(int i=1;i<=n;i++){
		int nem;
		cin>>nem;
		if(m.count(nem)) top[i]=modify(top[i-1],0,n,m[nem]);
		else top[i]=modify(top[i-1],0,n,0);
		m[nem]=i;
	}
	while(q--){
		for(int i=1;i<=4;i++){
			cin>>cab[i];cab[i]=(cab[i]+last)%n+1;
		} 
		sort(cab+1,cab+5);
		a=cab[1];b=cab[2];c=cab[3];d=cab[4];
		cin>>e>>f;
		last=solve();
		cout<<last<<"\n";
	}
	return 0;
}
```

#### 其他的一些注意事项

1. 将询问的解密时的式子是 $(a'+last) \bmod n+1$，而不是 $(a'+last) \bmod (n+1)$。

2. 二分时要特殊判断本来所有的 $F(L,d)-F(L,c)+1$ 都不在 $[e,f]$ 的范围内。

3. 在用 `map` 时如果 `map` 的某个下标没有存值，在插入主席树中前最好先判断一下。

4. 二分时 $l,r$ 和 $ll,rr$ 不要弄混，~~我就是在这里错了，然后调了好久。QWQ~~

---

## 作者：violin_wyl (赞：2)

## P7577 「PMOI-3」简单模拟题

### 思路

仔细读题发现，题意等价于对于 $\forall l|l\in[a,b]$，$F(l,c),F(l,c+1),\cdots F(l,d)$ 在值域上连续，则 $G(F(l,c),F(l,c+1),\cdots F(l,d))$ 等价于求 $[c,d]$ 中在 $[l,c-1]$ 中没有出现的颜色的个数。

再仔细分析可得，在 $[l,c-1]$ 中随着 $l$ 的增加，$[l,c-1]$ 内部的颜色数会减少，而 $[c,d]$ 中在 $[l,c-1]$ 中没有出现的颜色数个数就会增加，即前者在 $l$ 中具有单调性，由此可以二分出区间 $[L,R]$ 满足当 $l\in[L,R]$ 时必有 $e\leq G(F(l,c),F(l,c+1),\cdots F(l,d))\leq f$。

由此就可以衍生出 $\mathcal O(n\log^2 n)$ 做法了，我们可以记 $pre_i$ 表示数 $a_i$ 上一次出现的位置，并对 $pre$ 建主席树，问题转换为了区间中 $< l$ 的数的个数，并二分 $[a,b]$ 中的区间 $[L,R]$ 每次二分都需要重新在主席树上查询一次，复杂度 $\mathcal O(\log ^2n)$。

我们发现这种算法的瓶颈在于每次二分都需要重新查询，这样的代价太高，但我们发现每次主席树查询的都是值域上的一段前缀，这就给优化带来了可能，我们发现每次计算前缀的时候必定包括区间 $[1,a-1]$，考虑先把这部分的贡献在 $e,f$ 上消掉，同时把 $[c,d]$ 代表**值域**区间在主席树上的 $\log$ 段都取出来，从头到尾求前缀和，如果当前前缀和 $\geq e(\leq f)$，那么就在这个区间上二分，这样就可以快速找到区间 $[L,R]$，答案统计就是 $R-L+1$。

这样最多遍历 $\log n$ 个区间，同时最多进行两次主席树上二分，复杂度 $\mathcal O(n\log n)$。

细节较多。

------

### code

```c++
#include <bits/stdc++.h>
using namespace std; 
const int N = 3e5 + 10;
const int INF = 0x3f3f3f3f;
const int mods = 1e9 + 7;
typedef pair <int, int> pii;
inline int read ()
{
    int x = 0, f = 1;
    char ch = getchar ();
    while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar (); }
    while (ch >= '0' && ch <= '9') { x = (x << 1) + (x << 3) + (ch ^ 48); ch = getchar (); }
    return x * f;
}
int n, q;
int a, b, c, d, e, f;
int sub[N], pre[N];
int ls[N], pos[N];
int root[N];
int l1[N], r1[N], l2[N], r2[N], s[N], cnt;
struct president_tree {
	int node;
	struct Tree {
		int ls, rs, sum;
		#define ls(x) t[x].ls
		#define rs(x) t[x].rs
		#define sum(x) t[x].sum
	}t[N << 5];
	void build (int &x) { x = ++node; ls(x) = rs(x) = sum(x) = 0; }
	inline void pushup (int x) { sum(x) = sum(ls(x)) + sum(rs(x)); }
	void modify (int &x, int pre, int l, int r, int val)
	{
		x = ++node;
		if (l == r)
		{
			sum(x) = sum(pre) + 1;
			return ;
		}
		ls(x) = ls(pre); rs(x) = rs(pre);
		int mid = (l + r) >> 1;
		if (val <= mid) modify (ls(x), ls(pre), l, mid, val);
		else modify (rs(x), rs(pre), mid + 1, r, val);
		pushup (x);
	}
	int query (int x, int y, int l, int r, int L, int R)
	{
		int s = sum(y) - sum(x);
		if (L <= l && r <= R) return s;
		int mid = (l + r) >> 1, res = 0;
		if (L <= mid) res += query (ls(x), ls(y), l, mid, L, R);
		if (R > mid) res += query (rs(x), rs(y), mid + 1, r, L, R);
		return res;
	}
	void abstract (int x, int y, int l, int r, int L, int R)
	{
		if (L <= l && r <= R)
		{
			l1[++cnt] = x; l2[cnt] = l;
			r1[cnt] = y; r2[cnt] = r;
			s[cnt] = sum(y) - sum(x);
			return ;
		}
		int mid = (l + r) >> 1;
		if (L <= mid) abstract (ls(x), ls(y), l, mid, L, R);
		if (R > mid) abstract (rs(x), rs(y), mid + 1, r, L, R);
	}
	int bs (int x, int y, int l, int r, int val)
	{
		if (l == r) return l;
		int mid = (l + r) >> 1;
		if (val + (sum(ls(y)) - sum(ls(x))) >= e) return bs (ls(x), ls(y), l, mid, val);
		else return bs (rs(x), rs(y), mid + 1, r, val + (sum(ls(y)) - sum(ls(x))));
	}
	int bs2 (int x, int y, int l, int r, int val)
	{
		if (l == r) return l;
		int mid = (l + r) >> 1;
		if (val + (sum(ls(y)) - sum(ls(x))) > f) return bs2 (ls(x), ls(y), l, mid, val);
		else return bs2 (rs(x), rs(y), mid + 1, r, val + (sum(ls(y)) - sum(ls(x))));
	}
} T;
int lans, rans;
int query ()
{
	int k = T.query (root[c], root[d], 0, n, 0, a - 1);
	e -= k; f -= k;
	cnt = 0; T.abstract (root[c], root[d], 0, n, a, b - 1);
	for (int i = 1; i <= cnt; i++) s[i] += s[i - 1];
	if (s[cnt] < e || f < 0) return 0;
	if (e <= 0) lans = a;
	else
	{
		for (int i = 1; i <= cnt; i++)
			if (s[i] >= e)
				{ lans = T.bs (l1[i], r1[i], l2[i], r2[i], s[i - 1]) + 1; break; }
	}
	if (s[cnt] <= f) rans = b;
	else
	{
		for (int i = 1; i <= cnt; i++)
			if (s[i] > f)
				{ rans = T.bs2 (l1[i], r1[i], l2[i], r2[i], s[i - 1]); break; }
	}
	return max (0, rans - lans + 1);
}
signed main()
{
	n = read (), q = read ();
	for (int i = 1; i <= n; i++) sub[i] = ls[i] = read ();
	sort (ls + 1, ls + n + 1);
	int len = unique (ls + 1, ls + n + 1) - ls - 1;
	for (int i = 1; i <= n; i++) sub[i] = lower_bound (ls + 1, ls + len + 1, sub[i]) - ls;
	for (int i = 1; i <= n; i++)
	{
		pre[i] = pos[sub[i]];
		pos[sub[i]] = i;
	}
	T.build (root[0]);
	for (int i = 1; i <= n; i++) T.modify (root[i], root[i - 1], 0, n, pre[i]);
	int lst = 0;
	while (q--)
	{
		int g[5];
		a = (read () + lst) % n + 1;
		b = (read () + lst) % n + 1;
		c = (read () + lst) % n + 1;
		d = (read () + lst) % n + 1;
		g[1] = a, g[2] = b, g[3] = c, g[4] = d;
		sort(g + 1, g + 5);
		a = g[1], b = g[2], c = g[3], d = g[4];
		e = read () - 1; f = read () - 1;
		printf ("%d\n", lst = query ());
	}
    return 0;
}
```

---

## 作者：FutaRimeWoawaSete (赞：2)

评紫就评紫吧，还是很有趣的一道题。             

刚开始做很愉快的读错了题，大概想到了类似项链的经典老做法，后来在同学提醒下才发现题目读错了，认真重新读完题目后大概就知道怎么做了。                  
            
PS:神仙同学比我晚 20min 开始想题，基本上 10min 就想出来了一只 $log$ 的主席树二分~~然后就开始骂这道题了~~。       

刚开始拿到这道题目就开始往 $O(n \log ^ 3 n)$ 上面想，后来发现思路比较乱还是考虑一层层往外面拆。                           

首先我们不难想到，$G$ 函数反应的是变量中有几个不同的数，并且我们的 $F$ 函数是形如 $F(L , c) , F(L , c + 1) ......$ 这种形式的，也就是说，随着 c 的向后推进一位，我们 $F$ 的值每次都至多加上 1 ，而这样就会造成一次不同的数的出现，所以这里就转化成了统计区间中有多少个不同的数。                   

继续转化，把项链的套路往上面一套，这道题就自然变成了统计一个数的 lst 是否在区间 $[L , d]$ 之间出现过。     

也就是说，现在的 $G$ 函数反映的就是区间 $c + 1 \sim d$ 这一段数的 lst 不在区间 $[L , d]$ 的个数，这个直接主席树维护就好了。               

接着我们发现随着 $L$ 的推进，$G$ 函数的值肯定是单调不递减的，所以我们二分一下 $G$ 函数第一次等于 e 的时候 L 在哪里，以及二分一下 $G$ 函数最后一次等于 f 的时候 L 在哪里，这些都可以主席树做，于是这道题就可以 $O(n \log ^ 2 n)$ 解决，当然你直接 $O(n \log n)$ 主席树二分也可以。                  
           
注意几个细节：             

- 1.别读错题……              
- 2.注意一下实现的一些细节，这些我代码里都有注释；
- 3.注意一定要判断一下答案是否合法，赛时因为这个问题好像被卡了2h……很丢人（            

稍微评价一下这道题，其实有难度，但是因为 trick 太常见并且拼凑痕迹太明显，所以整道题就显得有点拉跨了，不过还是很好的一个idea，至少我只能膜拜出题人。         

```cpp
#include<bits/stdc++.h>
using namespace std;
const int Len = 3e5 + 5;//主席树 + 二分 
int n,m,top,rt[Len],lsh[Len],cnt,lst[Len],nxt[Len],a[Len],num[Len];
struct node
{
	int l,r,sum;	
}tree[Len * 32];
int clone(int p)
{
	top ++;
	tree[top] = tree[p];
	tree[top].sum ++;
	return top;
}
int build(int p,int l,int r)
{
	p = ++ top;
	if(l == r) return p;
	int mid = (l + r) >> 1;
	tree[p].l = build(tree[p].l , l , mid);
	tree[p].r = build(tree[p].r , mid + 1 , r);
	return p;
}
int update(int p,int l,int r,int wh)
{
	p = clone(p);
	if(l == r) return p;
	int mid = (l + r) >> 1;
	if(wh <= mid) tree[p].l = update(tree[p].l , l , mid , wh);
	else tree[p].r = update(tree[p].r , mid + 1 , r , wh);
	return p;
}
int query(int l,int r,int nl,int nr,int k)
{
	if(l == r) return tree[nr].sum - tree[nl].sum;
	int mid = (l + r) >> 1 , res = 0;
	if(mid < k) 
	{
		res += tree[tree[nr].l].sum - tree[tree[nl].l].sum;
		res += query(mid + 1 , r , tree[nl].r , tree[nr].r , k);
		return res;
	}
	return query(l , mid , tree[nl].l , tree[nr].l , k);
}
inline int check(int a,int c,int d,int num)
{
	return query(0 , n , rt[c] , rt[d] , num - 1) - query(0 , n , rt[c] , rt[d] , a - 1); 
}
int Sort[15],lens = 0;
inline void SORT(int &x,int &y,int &c,int &d){Sort[1] = x , Sort[2] = y , Sort[3] = c , Sort[4] = d;sort(Sort + 1 , Sort + 1 + 4);x = Sort[1] , y = Sort[2] , c = Sort[3] , d = Sort[4];}
inline int read() {
    char ch = getchar();
    int x = 0, f = 1;
    while (ch < '0' || ch > '9') {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while ('0' <= ch && ch <= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
inline void write(int x) {
    if (x < 0)
        putchar('-'), x = -x;
    if (x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
}
int main()
{
	
	n = read() , m = read();
	for(int i = 1 ; i <= n ; i ++) 
	{
		a[i] = read();	
		lsh[i] = a[i];
	}
	sort(lsh + 1 , lsh + 1 + n);
	cnt = unique(lsh + 1 , lsh + 1 + n) - lsh - 1;
	for(int i = 1 ; i <= n ; i ++) a[i] = lower_bound(lsh + 1 , lsh + 1 + cnt , a[i]) - lsh;
	rt[0] = build(0 , 0 , n);
	//for(int i = 1 ; i <= cnt ; i ++) lsh[i] = n + 1;
	for(int i = 1 ; i <= n ; i ++){num[i] = lst[a[i]] ; lst[a[i]] = i;}
	for(int i = 1 ; i <= n ; i ++) {rt[i] = update(rt[i - 1] , 0 , n , num[i]);}
	int lstans = 0;
	for(int i = 1 ; i <= m ; i ++)
	{
		int a,b,c,d,e,f;a = read() , b = read() , c = read() , d = read() , e = read() , f = read();
		a = (a + lstans) % n + 1 , b = (b + lstans) % n + 1 , c = (c + lstans) % n + 1 , d = (d + lstans) % n + 1;
		//先查询[c , d]中多少个lst在[a , d]之间  
		SORT(a , b , c , d);//printf("%d %d %d %d\n",a,b,c,d);       
		//printf("%d %d\n",d,a - 1);
		int ssb = query(0 , n , rt[c] , rt[d] , a - 1);//[c + 1 , d]中的lst有多少个不在[a , d]中 
		int num = ssb + 1;//初始答案
		//printf("%d\n",num);
		//接着二分找到第一个为 e 的位置
		int l = a , r = b , anss = 1e9;
		while(l <= r)
		{
			int mid = (l + r) >> 1;
			if(check(a , c , d , mid) + num >= e) r = mid - 1 , anss = mid;//查询[c + 1 , d]中有多少个lst在[a , mid - 1]中
			else l = mid + 1;
		} 
		if(anss == 1e9) 
		{
			lstans = 0;
			puts("0");
			continue;
		}
		//printf("%d\n",anss);
		l = a , r = b;//在二分找到第一个为 f 的位置
		int ansss = 1e9;
		while(l <= r)
		{
			int mid = (l + r) >> 1;
			if(check(a , c , d , mid) + num <= f) l = mid + 1 , ansss = mid;//查询[c + 1 , d]中有多少个lst在[a , mid - 1]中 
			else r = mid - 1;
		} 
		if(ansss == 1e9)
		{
			lstans = 0;
			puts("0");
			continue;
		}
		lstans = ansss - anss + 1;
		write(lstans) , putchar('\n');
	}
	return 0;
}
```

---

## 作者：CQ_Bob (赞：1)

题解摘自 [CSP2024 前做题情况](https://www.luogu.com.cn/article/9zpicw3e)。

## 分析

发现性质题。因为 $l$ 固定，$r$ 连续的一些区间，$F(l,r)$ 的值也是一定的。那么记 $F(l,c)=x,F(l,d)=y$，根据界值定理，$F(l,c),F(l,c+1),\dots,F(l,d)$ 一定取遍了 $[x,y]$ 中的所有数。那么 $G(F(l,c),F(l,c+1),\dots,F(l,d))=y-x+1$。

现在就好做了。考虑容斥，即 $\le f$ 的答案减去 $<e$ 的答案。我们需要维护 $\sum\limits_{l=a}^{b}[F(l,d)-F(l,c)+1\le x]$。求区间出现次数有一个很经典的 trick，记 $pre_i$ 为最大的 $j$，使得 $a_j=a_i\land j<i$，没有记为 $0$。那么对于区间 $[l,r]$，一个数是第一次出现的当且仅当 $pre_i <l$。也就是说区间数的数量与 $\sum\limits_{i=l}^{r} [pre_i<l]$ 相等。

则问题转化为：$\sum\limits_{l=a}^{b}[\sum\limits_{i=c+1}^{d}[pre_i < l]\le x-1]$。很显然的，$\sum\limits_{i=c+1}^{d}[pre_i < l]$ 随 $l$ 增大不降，故具有可二分性。那我们直接去二分，每次 check 一下是否可行就行了。求区间小于某个数的数量用主席树即可。该算法的时间复杂度为 $O(n\log^2 n)$。

存在 $O(n\log n)$ 的主席树上二分的做法。

## 代码

```cpp
il void up(int u){
	tr[u].siz=tr[ls(u)].siz+tr[rs(u)].siz;
	return ;
}
il void modify(int &u,int l,int r,int x){
	tr[++idx]=tr[u],u=idx;
	if(l==r) return ++tr[u].siz,void(0);
	int mid=l+r>>1;
	if(x<=mid) modify(ls(u),l,mid,x);
	else modify(rs(u),mid+1,r,x);
	up(u);
	return ;
}
il int query(int u,int pre,int l,int r,int k){
	if(!u) return 0;
	if(l==r) return tr[u].siz-tr[pre].siz;
	int mid=l+r>>1;
	if(mid>=k) return query(ls(u),ls(pre),l,mid,k);
	return tr[ls(u)].siz-tr[ls(pre)].siz+query(rs(u),rs(pre),mid+1,r,k);
}
il int work(int l,int r,int x,int y,int s){
	int w=-1,le=l;
	while(l<=r){
		int mid=l+r>>1;
		int sum=query(root[y],root[x],0,n,mid-1);
		if(sum<=s) w=mid,l=mid+1;
		else r=mid-1;
	}
	return max(0ll,w-le+1);
}

il void solve(){
	n=rd,q=rd;
	for(re int i=1;i<=n;++i){
		s[i]=rd;
		pre[i]=id[s[i]],
		id[s[i]]=i;
		modify(root[i]=root[i-1],0,n,pre[i]);
	}
	while(q--){
		for(re int i=1;i<=4;++i) A[i]=rd;
		int e=rd,f=rd;
		for(re int i=1;i<=4;++i) A[i]=(A[i]+lstans)%n+1;
		sort(A+1,A+4+1);
		int a=A[1],b=A[2],c=A[3],d=A[4];
		printf("%lld\n",lstans=work(a,b,c,d,f-1)-work(a,b,c,d,e-2));
	}
    return ;
}
```

---


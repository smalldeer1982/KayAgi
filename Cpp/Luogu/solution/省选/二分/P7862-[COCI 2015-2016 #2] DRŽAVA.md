# [COCI 2015/2016 #2] DRŽAVA

## 题目描述

一个遥远的国家刚刚举行了选举，新首相当选了。目前，这个国家没有一条公路，所以首相决定用双向公路把国内的城市连接起来，组成县，使国家现代化。

这个国家共有 $N$ 个城市，每个县由一个或多个城市组成，**两个城市将位于同一个县，当且仅当使用新建的道路可以从一个城市到达另一个城市**。这些城市在二维坐标系中用点来表示，两个城市之间的道路表示为连接两个城市所在点的线段。这条路的长度等于以公里为单位的线段的长度。

该国目前正遭受经济衰退，因此首相决定，由于缺乏预算，他们将不修建超过 $D$ 公里的道路。此外，**如果至少有一个县存在一个非空子县（可以包括该县的所有城市），使得子县内的居民总数可以被 $K$ 整除，首相就会高兴**。例如，如果 $K=4$，一个县的城市分别有 `3`、`5`、`7` 个居民，首相就会高兴，因为前两个城市的居民总数等于 `8`。

请你确定最小的 $D$ 来帮助首相降低成本，使得首相感到高兴。

## 说明/提示

**【样例 1 解释】**

只有当所有城市都在同一个县里首相才能高兴，所以最小的 $D$ 为 $1.414$。

**【样例 2 解释】**

当前五个城市都在同一个县里首相才能高兴，且此时 $D$ 是最小的，所以最小的 $D$ 为 $5.657$。

**【数据范围】**

对于 $40\%$ 的数据，$1\le N\le10^3$；

对于 $100\%$ 的数据，$1\le N\le5\times10^4，1\le K\le30，0\le x_i,y_i,k_i\le10^8$。

**【说明】**

**本题数据点得分依原题，满分 160**。

题目译自 [COCI 2015-2016](https://hsin.hr/coci/archive/2015_2016/) [CONTEST #2](https://hsin.hr/coci/archive/2015_2016/contest2_tasks.pdf) **T6 DRŽAVA**。

## 样例 #1

### 输入

```
3 3
0 4 4
1 5 1
2 6 1
```

### 输出

```
1.414
```

## 样例 #2

### 输入

```
6 11
0 0 1
0 1 2
1 0 3
1 1 4
5 5 1
20 20 10
```

### 输出

```
5.657```

## 样例 #3

### 输入

```
6 5
20 20 9
0 0 3
0 1 1
10 0 1
10 1 6
12 0 3
```

### 输出

```
2.000```

# 题解

## 作者：pikiuk (赞：6)

分享一种确定性做法。

首先对于 $d$ 二分，问题转化为判定性问题。

可以发现，若一个县的大小大于等于 $k$，那么他一定合法，理由是一定能找到两个余数互补的城市（鸽巢原理）。

考察一个边长为 $d\times d$ 的矩形，我们可以发现，若其中有不少于 $4k$ 个点，那么 $d$ 一定合法。证明可以同样是鸽巢原理，具体的，我们把一个矩形划分为四个子矩形，那么每个子矩形内的点一定可以构成一个县，且至少存在一个子矩形内的点多于 $k$ 个。

我们对点的 $x$ 轴扫描线，维护以当前点为右边界中点的矩形，并把当前点向当前矩形内所有点连边，可以用 `set` 维护，由上述分析发现，每个点的出边不超过 $k$ 条。

连边结束后，对现有连通块做背包即可，单次检验时间复杂度是 $\mathcal{O}(nk)$。

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
using i64 = long long;
const int N = 5e4 + 7, K = 37;
int f[N][K], n, k, col[N], cnt;
vector<int> e[N], vec;
struct Point {
	int x, y, z;
} p[N];
struct cmp {
	bool operator () (const int &u, const int &v) const {
		return ((p[u].y == p[v].y) ? u > v : p[u].y < p[v].y);
	}
};
set <int, cmp> st;
void add (int &x, int y) { x = (x + y) >= k ? x + y - k : x + y; }
i64 dis (int u, int v) {
	return 0ll + 1ll * (p[u].x - p[v].x) * (p[u].x - p[v].x) + 1ll * (p[u].y - p[v].y) * (p[u].y - p[v].y);
}
void dfs (int u) {
	col[u] = cnt; vec.push_back (p[u].z);
	for (auto v : e[u]) if (! col[v]) dfs (v);
}
bool subset () {
	int m = (int) vec.size ();
	if (m > k) return true;
	for (int i = 1; i < k; i ++) f[m][i] = 0;
	f[m][0] = 1;
	for (int i = m - 1; ~i; i --) {
		for (int j = 0; j < k; j ++) {
			f[i][j] = f[i + 1][j];
			f[i][j] |= f[i + 1][(vec[i] + j) % k];
		}
		if (f[i + 1][vec[i]]) return true;
	}
	return false;
}
bool check (i64 d) {
	int sqrtd = (double) (sqrt (d) + 1);
	for (int i = 1; i <= n; i ++) e[i].clear (), col[i] = 0;
	cnt = 0; st.clear ();
	for (int i = 1, j = 1; i <= n; i ++) {
		for (; p[i].x - p[j].x > sqrtd and j <= i; ) 
			st.erase (j ++);
		if (st.empty ()) { st.insert (i); continue; }
	
		p[n + 1] = {0, p[i].y - sqrtd, 0}; int res = 0;
		for (auto it = st.lower_bound (n + 1); it != st.end (); it ++) {
			auto k = *it;
			if (p[k].y - p[i].y > sqrtd) break;
			if (++ res >= 4 * k) return true;
			if (dis (i, k) <= d) e[i].push_back (k), e[k].push_back (i);
		}
		st.insert (i);
	}
	for (int i = 1; i <= n; i ++) {
		vec.clear ();
		if (col[i]) continue;
		++ cnt, dfs (i);
		if (subset ()) return true;
	}
	return false;
}
signed main () {
	cin >> n >> k;
	for (int i = 1; i <= n; i ++) {
		cin >> p[i].x >> p[i].y >> p[i].z;
		p[i].z %= k;
	}
	sort (p + 1, p + n + 1, [&] (const Point &u, const Point &v) {
		return u.x == v.x ? u.y < v.y : u.x < v.x;
	});
	i64 l = 0, r = 1e18, ans = -1;
	while (l <= r) {
		i64 mid = (l + r) >> 1;
		if (check (mid)) r = mid - 1, ans = mid;
		else l = mid + 1;
	}	
	cout << fixed << setprecision (3) << sqrt (ans);
}
```

---

## 作者：xlpg0713 (赞：2)

注意到两个集合 $U_1,U_2$，如果存在 $x\in U_1,y\in U_2,\operatorname{dis}(x,y)\le d$，选择 $U_1\bigcap U_2$ 比单独选择 $U_1,U_2$ 优。

那么对于确定的 $d$，我们要做的其实就是在距离不大于 $d$ 的两点之间连边，判断每个连通块是否分别满足限制。

根据以上的讨论，发现答案具有单调性，二分答案，判断只加入距离小于等于 $d$ 的是否可能合法。朴素实现可以做到 $O(n^2k\log V)$。

问题在于朴素连边边的量级是 $O(n^2)$ 的。我们希望建出一张图，保留原图的连通性，同时边数低于 $O(n^2)$。

对于一个点，把平面上的点按照关于这个点的方向每 $45\degree$ 分为一部分。这个点向每一部分距离自己最近的点连边。我们可以证明这样的新图保留了原图的联通信息。

“向一个方向距离自己最近的点连边”，这个操作可以扫描线简单实现，我们硬做八遍扫描线即可。精细实现可以做到 $O(nk\log n)$。

---

## 作者：Hope888 (赞：1)

容易猜测当集合的 size 足够大的时候必然存在子集和是 $k$ 的倍数。构造 $k-1$ 个 $1$ 可以使 $size=k-1$，然后打个表猜测最多就是 $k-1$。

> ### 一个简单的证明：
> 
> 考虑一个集合所有非空子集，按子集的大小排序。若两个不同大小的子集有相同的子集和，则必然存在两个相互包含的不同大小子集有相同的子集和（加上对方多余的部分），则作差得到 $0$。设所有子集和相等的子集的大小都相等，则最多有 $k-1$ 个不同的子集和，即 $size\le k-1$。

## 解法
对于这题显然先二分答案，考虑建图。如果一个连通块的大小至少是 $k$，则已经存在合法了。于是有用的连边数不超过 $nk$。考虑类似平面最近点对的做法。我们按横坐标排序，用 set 维护 **横坐标和当前点差距不超过 $mid$ 的点集**，按纵坐标排序。然后对于一个点的连边，找出纵坐标范围在 $[y-mid,y+mid]$ 之间的所有点，然后依次检验连边。

考虑复杂度：要卡满复杂度，则任意连通块的大小不超过 $k-1$，假设取了左侧 $mid\times 2mid$ 矩形内的点，距离当前点的正确范围是一个半圆，剩下的点最多组成两个连通块，于是点数是 $O(k)$ 级别的。

### 做法 $1$
建图之后用 bitset 或压位优化背包即可。时间复杂度 $O(\log V(n\log n+nk))$.

### 做法 $2$
我们充分发扬人类智慧，随机偏移+随机旋转，然后按横坐标排序后，每个点往前暴力找横坐标的差不超过 $mid$ 的所有点尝试连边。一个重要的剪枝是，如果当前连通块存在 $k$ 的倍数的子集和就要剪掉，不然乱造数据都能卡到 $O(n^2)$。

---


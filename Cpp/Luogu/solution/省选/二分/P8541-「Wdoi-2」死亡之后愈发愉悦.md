# 「Wdoi-2」死亡之后愈发愉悦

## 题目背景

落樱缤纷春不待，如果错过了这次机会，可能得等到紫藤绽放的春夏之际才能赏花了。  
但是两人依然无心在樱花树下席地而宴。

因为正体不明的灵体在两人面前倏现骤消的飘浮着。  
后来才明白这些四处飘浮的正体不明灵体，既非普通幽灵，也不是前阵子出现的怨灵。  
这些是神灵。本应超脱为神的灵体。

一般而言，神灵多半居住在神社里，其实它们是随处可见的没有固定型态的灵体。  
这些神灵让她们困惑不已。

超乎常人的强烈人欲、想法、恐惧与情感，是神灵出现的原因。一般而言，神灵很少危害人类，如果没有强烈的欲望。例如祈求丰收，或是除厄避邪等，是不会产生神灵的……

小神灵指引着灵梦与魔理沙深入命莲寺的地底，与千年复苏的敌人交手。从命莲寺墓地到莲池中央的梦殿大祀庙，从彷徨的亡灵到极具传说色彩的圣德太子，从欲望加速到小小的欲望星空，一切都显得那么不可思议。

「死亡之后，才能得到更加绚烂的重生。」

## 题目描述

**【这是一道交互题】**

定义 $f(x)$ 表示严格大于 $x$ 的最小的完全平方数，定义 $g(x)$ 为小于等于 $x$ 的最大的完全平方数。例如，$f(1)=f(2)=g(4)=g(8)=4$。

一个正整数是“可爱”的，当且仅当 $x-g(x)<f(x)-x$，例如，$1,5,11$ 是可爱的正整数，而 $3,8,15$ 不是。

为了倾听小神灵的愿望，主角组需要向神子询问。小神灵有一个最喜欢的正整数 $a$，神子可以根据灵梦给出的 $x\quad(x\in[0,10^9])$，向小神灵询问，而小神灵只能回答她，$a+x$ 是不是可爱的正整数（$\text{cute number}$）。

请通过适当的询问找出 $a$。

## 说明/提示

### 样例解释

样例当中的过程仅供参考。

样例当中，$a=114514$，是 $\text{cute number}$（因为 $338^2\le 114514 <339^2$，而 $114514-338^2=270<339^2-114514=407$）。

同样地，$a+0,a+1,a+2,a+3,a+10$ 均为 $\text{cute number}$。而 $a+100=114614$ 不是 $\text{cute number}$，因为 $338^2\le 114614 <339^2$，而 $114614-338^2=370\ge 339^2-114614=307$。

### 数据范围及约定

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|}\hline
\textbf{Subtask} & \bm{a\le } & \bm{T\le} & \textbf{特殊性质} & \textbf{分值}\\\hline
1 & 100 & 100 & - & 10\\\hline
3 & 10^9 & 2\times 10^3 & -  & 20\\\hline
2 & 10^{12} & 2\times 10^3 & \textbf{A}  & 30\\\hline
4 & 10^{12} & 2\times 10^3 & -  & 40\\\hline
\end{array}
$$

**特殊性质** $\textbf{A}$：保证 $a$ 是 $\text{cute number}$。

对于全部数据，保证 $1\le a\le 10^{12}$。你发起的询问当中，$x$ 的值应当在 $[0,10^9]$ 以内。

---

此外，你每个测试点的得分还与该测试点所有询问次数的最大值有关。具体而言，设某个测试点你询问操作一共进行了 $\text{max\_count}$ 次。

- 若 $\text{max\_count}< 64$，你将获得该测试点 $100\%$ 的分数；
- 若 $64\le \text{max\_count}< 81$，你将获得该测试点 $50\%$ 的分数；
- 若 $81\le \text{max\_count}< 100$，你将获得该测试点 $20\%$ 的分数；
- 若 $\text{max\_count}\ge 100$，你将不能获得该测试点的分数。

## 样例 #1

### 输入

```
1

1

1

1

1

1

0

0

1```

### 输出

```

? 0

? 1

? 2

? 3

? 10

? 100

? 233

? 1919810

! 114514```

# 题解

## 作者：Alex_Wei (赞：14)

> [P8541 「Wdoi-2」死亡之后愈发愉悦](https://www.luogu.com.cn/problem/P8541)

**二分未知上界的数的最好方式是倍增**。

考察两个相邻的完全平方数 $i ^ 2$ 和 $(i + 1) ^ 2$ 之间 $[i ^ 2, (i + 1) ^ 2)$ 可爱数的分布，发现为 $i + 1$ 个可爱数和 $i$ 个非可爱数。

设 $j(x)$ 表示 $x$ 是否为可爱数。

因此，考虑倍增求出使得 $j(a) \sim j(a + p)$ 全部相同的最大的 $p$，再倍增求出使得 $f(a + p + 1)\sim f(a + p + q)$ 全部相同的最大的 $q$，则根据 $q$ 和 $j(a)$ 容易求得 $a$。

倍增方法：依次尝试以 $1, 1, 2, 4, \cdots, 2 ^ k, 2 ^ {k - 1}, \cdots, 1$ 为步长 $d$ 向后跳，检查 $j(a + d)$ 是否等于 $j(a)$。若 $j(a) = j(a + d)$，则令 $a\gets a + d$，称为成功，否则不变，称为失败。其中 $2 ^ k$ 是第一次失败的步长。一开始多一个 $1$ 是为了保证 **除第一次跳跃以外，其它每一次跳跃的步长不大于已经跳过的长度**，结合可爱数的分布，这保证了不会在 $j(a) = j(a + d)$ 之间出现 $j(a + i)\neq j(a) (0 < i < d)$。实际上若可爱数分布为 $i$ 个可爱数接着 $i$ 个非可爱数，也即极长连续相等段长度不降，则没有必要在第二次跳 $1$，而是直接跳 $2$，读者可对比两种情况自行思考。

询问次数为 $4\log\sqrt a$ 即 $2\log a$，无法接受。

实际上我们发现 $p \leq q$，所以倍增求 $q$ 时，可以直接从 $2 ^ k$ 为步长开始，其中 $2 ^ k \leq p$。这样询问次数即可做到 $3\log \sqrt a$，可以接受。

代码和题解有一些细节上的差异。

```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
using namespace std;
using namespace __gnu_pbds;
#define int long long
#define fi first
#define se second
#define TIME 1e3 * clock() / CLOCKS_PER_SEC
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using ull = unsigned long long;
inline ll read() {
  ll x = 0, sgn = 0;
  char s = getchar();
  while(!isdigit(s)) sgn |= s == '-', s = getchar();
  while(isdigit(s)) x = x * 10 + s - '0', s = getchar();
  return sgn ? -x : x;
}
inline void print(int x) {
  if(x < 0) return putchar('-'), print(-x);
  if(x >= 10) print(x / 10);
  putchar(x % 10 + '0');
}
bool Mbe;
map<int, bool> mp;
int query(int x) {
  if(mp.find(x) != mp.end()) return mp[x];
  cout << "? " << x << endl;
  int res = read();
  return mp[x] = res;
}
int suc(int x, int acc) {
  int st = query(x);
  if(query(x + 1) != st) return x;
  int pw = 0;
  while((1 << pw + 1) <= acc) pw++;
  while(1) {
    if(query(x + acc + (1 << pw)) != st) break;
    acc += 1 << pw, pw++;
  }
  for(int i = pw - 1; ~i; i--)
    if(query(x + acc + (1 << i)) == st)
      acc += 1 << i;
  return x + acc;
}
bool Med;
signed main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  // #ifdef ALEX_WEI
  //   FILE* IN = freopen("1.in", "r", stdin);
  //   FILE* OUT = freopen("1.out", "w", stdout);
  // #endif
  int T;
  cin >> T;
  while(T--) {
    mp.clear();
    int p = suc(0, 1);
    int q = suc(p + 1, max(1ll, p - 1)) - p;
    if(!query(0)) cout << "! " << (q - 1) * (q - 1) - 1 - p << endl;
    else cout << "! " << q * (q + 1) - p << endl;
  }
  cerr << TIME << " ms\n";
  return 0;
}
```

---

## 作者：樱雪喵 (赞：3)

根据 $64$ 次的限制，我们自信猜测做法是一个 $\log$ 带一些神秘常数。

先对 $\text{cute number}$ 打表，得到如下的序列：

$$
11011100111100011111000011111100000\dots
$$

发现每段连续的 $0$ 的个数是前面连续 $1$ 的个数减 $1$。

考虑我们根据已有信息比较容易求出什么，尝试找到最小的 $x$ 使 $a+x$ 与 $a$ 的答案不同。  

这个东西没有单调性，不能二分。但发现同为 $\log$ 数量级的还有倍增，而且这么搞貌似是对的。  
具体来说，根据这个数列的性质，因为 $0$ 和 $1$ 的连续段长度大致相等，不会出现在一步倍增中直接跳过了中间一个连续段的情况。  
那么我们枚举 $x=2^0,2^1,2^2,\dots,2^k$ 步，第一个与 $a$ 状态不同的位置一定恰好属于 $a$ 后面的那个连续段。

记这个位置为 $limit$，倍增到的最后一个合法位置为 $lst$。那么从 $lst$ 开始倒序倍增，每次尝试跳 $2^{k-1},2^{k-2},\dots,1$ 步，合法就跳，否则不动。最后所在的位置即为 $a$ 所在连续段的最后一位，记为 $l$。

同理，可以两次倍增求出 $l+1$ 所在连续段的最后一位 $r$。根据 $[l+1,r]$ 这段的长度和 $a$ 本身的状态，不难推算出答案。

这样做的询问次数是 $4 \log \sqrt n$ 的，无法通过。不过在倍增 $l+1$ 所在段时，我们先前已经知道了 $l$ 这一段的长度至少是 $2^k$，所以不用从 $1$ 开始枚举。  
加上这个优化，再仔细卡卡上下界，记忆化询问过的值就可以通过了。 

樱雪喵牌人形交互库不仅脑子不好眼神还不好，于是调了 $\inf$ 年。

```cpp
#define int long long
const int N=1e6+5;
int T;
int n=1e6,a[N],nw,mx;
map<int,int> vis;
il int f(int x)
{
    int f=upper_bound(a+1,a+n+1,x)-a;
    return x-a[f-1]<a[f]-x;
}
il int ask(int x)
{
    if(vis.count(x)) return vis[x];
    cout<<"? "<<x<<endl;
    int ans=read();
    return vis[x]=ans;
}
il int find(int x,int st)
{
    st=max(1ll,(st>>1));
    int now=ask(x);
    if(!x) nw=now;
    int qwq=0;
    for(int i=st;;i<<=1)
    {
        if(ask(x+i)!=now) break;
        else qwq=i;
    }
    mx=max(mx,qwq);
    for(int i=(qwq>>1);i;i>>=1) if(ask(x+qwq+i)==now) qwq+=i;
    return x+qwq;
}
signed main()
{
    for(int i=1;i<=n;i++) a[i]=i*i;
    T=read();
    while(T--)
    {
        mx=1;vis.clear();
        int l=find(0,1),r=find(l+1,mx);
        int len=r-l;
        if(nw==0)
        {
            int a=(len*2-2)/2;
            a=a*a-l-1;
            cout<<"! "<<a<<endl;
        }
        else
        {
            int a=(len*2)/2;
            a=a*a+len-l;
            cout<<"! "<<a<<endl;
        }
    }
    return 0;
}
/*
1101110011110001111100001111110000011111
*/
```

---

## 作者：CReatiQ (赞：1)

### 思路

用 $01$ 代表数字是否为 $\text{cute number}$，列出 $1 \sim 15$ 以内的 $\text{cute number}$ 情况，记为 $is(x)$：

$$is(x)= \{ 1,1,0,1,1,1,0,0,1,1,1,1,0,0,0 \}$$

可以观察到以下几个性质：

 1. 每段连续的 $1$ 由完全平方数位置开始。
 
 2. 第 $i$ 段连续的 $0$ 长度为 $i$。
 
 3.	第 $i$ 段连续的 $1$ 长度为 $i+1$。
 
性质 1 由题意可得。

性质 2 和 3 由 $x^2=\sum_{i=1}^{x} (2 \cdot i+1)$ 可得。

因为我们不知道数字的绝对值，所以考虑找到完整的一段连续 $0$ 或 $1$ 的左右端点，利用上述性质来推出原数字。

第一步当然是询问 $is(a)$ 是否为 $1$。

之后我们只能询问比 $a$（与题意中意义相同）更大的数，又需要尽量减少询问次数，所以对于 $is(a)=1$ 的情况，我们寻找它之后的第一个 $0$ 位置，记作 $goal$；再寻找 $goal$ 之后的第一个 $1$。

对于 $is(a)\neq1$ 的情况，同样是 $0$ 和 $1$ 互找，所以我们只用讨论一种情况，另一种两步倒过来就好。

对于 $1$ 找 $0$，有上面的性质保证，当前已确定连续 $x$ 个 $1$ 的情况下，再往后跳 $x-1$ 个数一定不会跳过 $0$，所以在找到 $0$ 之前，每跳一步步长增长 $x-1$。

如果我们按上面的步骤找到了一个 $0$，它与起跳前的位置之间可能还有 $0$。具有单调性，端点已知，可以直接二分。

对于 $0$ 找 $1$，同样通过上面的性质得到，当前已确定连续 $x$ 个 $0$ 的情况下，再往后跳 $x+2$ 个数一定不会跳过 $1$，所以在找到 $1$ 之前，每跳一步步长增长 $x+2$。

找到 $1$ 后，同样二分即可。

现在我们可以在两次倍增和两次二分下求出 $a$，但是这还不够。

每次倍增或二分次数是 $\log \sqrt n$ 的，再乘上 $4$，并不能卡进 $64$ 次的交互次数限制。

通过性质 2 和 3 我们就能发现，在找到我们的 $goal$ 之后，我们并不需要把步长重置，因为当前连续 $01$ 长度一定不小于上步倍增的步长。

所以两次倍增的过程其实是可以合并的，交互次数变成了 $3 \log_2 \sqrt n < 60$，刚好卡过。

---

### Code

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
#define int long long
#define MAXN (int)(5e6+233)
#define rep(i,l,r) for (int i=l;i<=r;i++)
#define per(i,r,l) for (int i=r;i>=l;i--)

namespace crq
{
	
	inline int read()
	{
		int x=0,f=1;char c=getchar();
		while (!isdigit(c)) {if (c=='-') f=-1;c=getchar();}
		while (isdigit(c)) {x=(x<<1)+(x<<3)+(c^48);c=getchar();}
		return f*x;
	}
	
	template <typename A,typename B>
	inline A max(A x,B y) { return x>y?x:y; }
	
	template <typename A,typename B>
	inline A min(A x,B y) { return x<y?x:y; }
	
	template <typename A,typename... B>
	A max(A first,B... others)
	{ return max(first,max(others...)); }
	
	template <typename A,typename... B>
	A min(A first,B... others)
	{ return min(first,min(others...)); }
	
}

using crq::read;

int T;

int ask(int x)
{
	int ret;
	printf("? %lld\n",x);
	fflush(stdout);
	scanf("%lld",&ret);
	return ret;
}

void R()
{
	int now=0;
	if (ask(now))
	{
		int step=1,l=0,r,nl,nr,pl;
		while (1)
		{
			if (ask(l+step))
			{
				l+=step;
				step=l;
			}
			else
			{
				r=l+step;
				while (l<r)
				{
					int mid=(l+r)>>1;
					if (ask(mid)) l=mid+1;
					else r=mid;
				}
				break;
			}
		}
		nl=l;
		while (1)
		{
			if (ask(nl+step))
			{
				nr=nl+step;
				while (nl<nr)
				{
					int mid=(nl+nr)>>1;
					if (ask(mid)) nr=mid;
					else nl=mid+1;
				}
				break;
			}
			else
			{
				nl+=step;
				step=nl-l+3;
			}
		}
		pl=nl-l+1;
		pl*=pl;
		printf("! %lld\n",pl-nl);
	}
	else
	{
		int step=3,l=0,r,nl,nr,pl;
		while (1)
		{
			if (ask(l+step))
			{
				r=l+step;
				while (l<r)
				{
					int mid=(l+r)>>1;
					if (ask(mid)) r=mid;
					else l=mid+1;
				}
				break;
			}
			else
			{
				l+=step;
				step=l+3;
			}
		}
		nl=l;
		while (1)
		{
			if (ask(nl+step))
			{
				nl+=step;
				step=nl-l;
			}
			else
			{
				nr=nl+step;
				while (nl<nr)
				{
					int mid=(nl+nr)>>1;
					if (ask(mid)) nl=mid+1;
					else nr=mid;
				}
				break;
			}
		}
		pl=nl-l-1;
		pl*=pl;
		printf("! %lld\n",pl-l);
	}
}

signed main()
{
	T=read();
	while (T--) R();
	return 0;
}
```


---

## 作者：离散小波变换° (赞：1)

## 题解

首先可以根据一个数是不是 $\mathrm{\frak{cute}\ number}$，将它染色为黑色或者白色。那么整个数轴就是由白色段与黑色段交替排列。记第 $i$ 个黑色段的长度为 $a_i$，第 $i$ 个白色段的长度为 $b_i$。

注意到，一个黑色段的第一个数字肯定是一个完全平方数。更一般地，第 $i$ 个黑色段第一个数字肯定是 $i^2$。那么下一个完全平方数就是 $(i+1)^2$。考虑到两者的间距为 $2i+1$，稍加推理即可得到 $a_i=i+1$，$b_i=i$。

![](https://cdn.luogu.com.cn/upload/image_hosting/zar054l0.png)

于是注意到，所有段的长度应该是按照 $2,1,3,2,4,3,\cdots$ 这样的方式交替排列的。黑色段后面的白色段长度比它小 $1$，白色段后面的黑色段长度比它长 $1$。接着对于 $a$ 的颜色进行分类讨论。

由于两种情况基本类似，因此这里以 $a$ 为黑色点开始讨论。

![](https://cdn.luogu.com.cn/upload/image_hosting/n1k978kx.png)

考虑设 $a$ 到它所处的黑色线段最后一个黑点的距离为 $s_1$；它下一个白段的长度为 $s_2$；再下一个黑段的长度为 $s_3$。另外，这黑—白—黑的区域不妨编号为 $1,2,3$。

一个朴素的想法是，从 $a$ 点处开始倍增，一直找到第一个在区域 $2$ 内的点。但是倍增有一个前提：你不能一下子跳过了区域 $2$，直接跑到区域 $3$ 里边去了，这样就找不到了。

考虑这样一个简单的策略（称作策略 $\alpha$）：

> 在点 $x$ 右边长度为 $a$ 的区域为黑色，再右边长度为 $b$ 的区域为白色。现在从 $x$ 点通过倍增（每次跳 $2^i$ 距离，即每次检查 $x+2^i$ 是否为白色区域）的方法起跳，不能跳过白色区域外。

容易发现，最容易一步跳到白色区域外的位置，就是 $x+a$ 这个点。从它最远可以跳到的位置是 $x+2a$，它应该不超过 $x+a+b$。因此得到，$x+2a\le x+a+b$，即 $a\le b$。

也就是说，在这个模型下，每次跳 $2^i$ 这个策略成立的前提条件是 $a\le b$。

---

在上文中，可以发现，$s_1$ 必然不超过 $s_2$，于是这种策略成立。

![](https://cdn.luogu.com.cn/upload/image_hosting/114ikw5r.png)

这样，我们找到了在第一个白色段内的元素 $t$，以及它到 $a$ 的距离 $|t-a|=2^k$。

![](https://cdn.luogu.com.cn/upload/image_hosting/2u7g8arq.png)

接着需要找到 $t$ 往两侧走到的最远的距离 $p$ 和 $q$（$t-p$ 和 $t+q$ 均为该段两侧端点处的白色点）。

考虑对上述策略进行简单的延申（称作策略 $\beta$）：

> 在点 $x$ 右边长度为 $a$ 的区域为黑色，再右边长度为 $b$ 的区域为白色。目前已知 $x+2^k$ 是白色点，现在要找到最后一个黑色点到 $x$ 的距离。

考虑这样的结论：$1+2^1+2^2+\cdots +2^{k-1}=2^k-1$。那么我们直接从 $k-1$ 开始，不断尝试 $x+2^i$，如果 $x+2^i$ 是黑色点，就 $x\gets x+2^i$，否则啥事不干。那么就可以找到最后一个黑色点到 $x$ 的距离，**也就求出了** $\bm a$。

---

运用策略 $\beta$，可以求出 $p$。又因为 $q\le s_3$，因此可以运用策略 $\alpha$，结合策略 $\beta$，求出 $q$。

交互次数分析：

- 找到 $k$ 需要用 $\log \sqrt v$ 次交互机会。
- 找到 $p$ 需要用 $k=\log \sqrt v$ 次交互机会。
- 找到 $q$ 需要用 $2\log \sqrt v$ 次交互机会。

总交互次数为 $4\log\sqrt v\approx 80$ 次。这是不行的。考虑哪里还能优化。

我们发现，计算 $q$ 的时候要先运用策略 $\alpha$ 从 $2^0$ 开始倍增。能不能第一次步子迈大一点呢？答案是可以的。因为我们只要不迈出区域 $3$ 就行了，那么只要步子大小不超过 $s_3$ 即可。又因为 $2s_3\ge s_1+s_2\ge 2^k$，于是发现 $s_3\ge 2^{k-1}$。那么倍增的第一步可以取 $2^{k-1}$。重新分析交互次数：

- 找到 $k$ 需要用 $k\le \log \sqrt v$ 次交互机会。
- 找到 $p$ 需要用 $k\le \log \sqrt v$ 次交互机会。
- 从 $q$ 出发找到第一个在区域 $3$ 内的点，需要 $k'=\log\sqrt v-k$ 次交互机会。
- 从 $q$ 往回走，需要 $k''=\log\sqrt v$ 次交互机会。

总交互次数为 $3\log\sqrt v\approx 60$ 次。可以通过该题。

## 代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
i64 qread(){
    i64 w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
map<int,bool> M;
bool ask(i64 x){
    if(M[x]) return M[x];
    cout<<"? "<<x<<endl; bool t; cin>>t; if(t==-1) exit(0); return M[x]=t;
}
void rpt(i64 a){ cout<<"! "<<a<<endl; }
const int MAXN=1e6+1+3;
int n=1e6+1,A[MAXN],B[MAXN];i64 P[MAXN],Q[MAXN];
int main(){
    A[1]=2,B[1]=1;
    up(2,n,i) A[i]=A[i-1]+1,B[i]=B[i-1]+1;
    P[A[1]]=1,Q[B[1]]=3;
    up(2,n,i){
        P[A[i]]=Q[B[i-1]]+B[i-1];
        Q[B[i]]=P[A[  i]]+A[  i];
    }
    up(1,qread(),T){
        M.clear();
        bool c=ask(0),d=!c; int a=0,b=0,l=0,u=20,p=0,q=0;
        up(  0,u,i) if(i==u||ask(   1<<i )==d){a=i;break;} l=1<<a;
        dn(a-1,0,i) if(ask(l-(p+(1<<i)))==d) p|=1<<i;a=max(a,1);
        up(a-1,u,i) if(i==u||ask(l+(1<<i))==c){b=i;break;}
        dn(b-1,0,i) if(ask(l+(q+(1<<i)))==d) q|=1<<i;
        int s1=l-p-1,s2=p+q+1;
        if(d) rpt(P[s2]-s1-1); else rpt(Q[s2]-s1-1);
    }
    return 0;
}
```

---

## 作者：August_Light (赞：0)

# P8541 「Wdoi-2」死亡之后愈发愉悦 题解

[题目传送门](https://www.luogu.com.cn/problem/P8541)

## 写在前面

倍增好题。好题。好题。

~~所需知识不超过 CSP-J 范围，但是它却是一道紫题~~。

## 题意简述

**【这是一道交互题】**

定义 $f(x)$ 表示严格大于 $x$ 的最小的完全平方数，定义 $g(x)$ 为小于等于 $x$ 的最大的完全平方数。

一个正整数是可爱数，当且仅当 $x-g(x)<f(x)-x$。

每组数据的答案为一个正整数 $a$，每次询问请输出一个参数 $x\quad(x\in[0,10^9])$，交互库会返回 $a+x$ 是不是可爱数。

请通过适当的询问找出 $a$。

$1 \le a \le 10^{12}$。询问次数小于 $64$ 次。

## 解法

使用 [Maxmilite](https://www.luogu.com.cn/user/274993) 老师在[洛谷 2022 算法竞赛秋令营 - 基础组](https://class.luogu.com.cn/course/yugu22ajc)课件中的做法。

> 未知上界二分的最好方法是倍增。

### 朴素做法（44pts）

记 $ask(x)$ 为 $a+x$ 是否珂爱。

首先一眼就知道在 $[i^2, (i+1)^2)$ 中前 $i+1$ 个数珂爱，后 $i$ 个数不珂爱。

用粉色代表珂爱数，用绿色代表非珂爱数。不妨打一个小表。

$$\textcolor{#FF9ADE}{\text{1 2 }} \textcolor{#71C047}{\text{3 }}\textcolor{#FF9ADE}{\text{4 5 6 }}\textcolor{#71C047}{\text{7 8 }}\textcolor{#FF9ADE}{\text{9 10 11 12 }}\textcolor{#71C047}{\text{13 14 15}} \dots$$

把数轴分为一个一个一个同色的区域。

发现粉色区域和绿色区域的长度都依次递增。

据此，我们发现我们只需要根据：

- $a$ **是否珂爱**
- $a$ **所在区间的下一个区间的左端点和右端点**

这样三个信息就可以得到 $a$ 的值。

（取下一个区间是因为只能查询比 $a$ 大的信息，查不到 $a$ 所在区间左端点）

为方便说明，记 $a$ 所在下一个区间为 $[a+l,a+r]$。

交互题，肯定是 $\log$ 级别的解法，想到二分和倍增。

二分有一个巨大的问题：$ask$ 函数不满足单调性。

考虑倍增。

我们查询 $a+2^0, a+2^1, a+2^2, a+2^3, \dots$，直到 $a+2^k$ 时 $ask$ 的值与 $ask(0)$ 不同，可以证明 $a+2^k$ **就在下一个区间内**。

证明：极端情况下 $a$ 应该出现在一个粉色区间的最左侧（即 $a$ 为完全平方数），设该粉色区间长为 $len$，则后面的绿色区间长为 $len-1$。显然在粉色区间内最长的一步只能跳 $len-1$ 的长度，下一步无法直接越过绿色区间。

接下来我们在 $(a+2^{k-1},a+2^k]$ 间二分或倍增，可以获得 $l$ 的值。

同理，以 $l$ 为起点再次倍增，可以获得 $r$ 的值。

记 $len = r - l + 1$。

- 如果 $a$ 是可爱数，那么答案为 $len^2+len+1-l$。
- 如果 $a$ 不是可爱数，那么答案为 $(len-1)^2-l$。

这个做法时间复杂度正确，但是询问次数炸了，可以获得 $44$ 分的好成绩。

> 这是紫题！你写到 $44$ 分！多好的成绩呐。

### 正解（100pts）

算一下现在需要多少询问。当前区间的长度大约为 $\sqrt a$，因为要进行四次倍增或二分，所以询问次数大约是 $4 \log \sqrt a$，约为 $80$，不能卡进 $64$ 次的限制（悲）。

但是我们发现第 $1$ 次和第 $3$ 次倍增是可以合并的。具体来说，在以 $l$ 为起点试图得到 $r$ 的值时，并不需要从 $2^0$，开始，我们直接从第一次倍增结束时的步长开始就行了。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

bool ask(LL x) {
    printf("? %lld\n", x); fflush(stdout);
    int ret; scanf("%d", &ret);
    return ret;
}
void print(LL a) {
    printf("! %lld\n", a); fflush(stdout);
}

LL step = 0, l = 0, r = 0;
void binary_lifting1(LL &v, LL start, bool stat) { // 正着倍增
    for (;;step++) {
        LL pos = start + (1ll << step);
        if (ask(pos) != stat)
            break;
        v = pos;
    }
}
void binary_lifting2(LL &v, bool stat) { // 反着倍增
    for (step--; step >= 0; step--) {
        LL pos = (1ll << step);
        if (ask(v + pos) != stat)
            continue;
        v += pos;
    }
}

int main() {
    int t; for (scanf("%d", &t); t--;) {
        step = l = r = 0;

        bool ask0 = ask(0);
        binary_lifting1(l, 0, ask0);
        LL tmp = step; step--;
        binary_lifting2(l, ask0); l++;
        // 此时 l 已算好

        r = l; step = tmp;
        binary_lifting1(r, l, !ask0);
        binary_lifting2(r, !ask0);
        // 此时 r 已算好

        LL len = r - l + 1;
        if (ask0)
            print(len*len + len + 1 - l);
        else
            print((len-1)*(len-1) - l);
    }
    return 0;
}
```


---

## 作者：E1_de5truct0r (赞：0)

- upd 2022.09.11：修正了 LaTeX 使用不妥的地方。

昨天赛时想到了倍增，可惜当时觉得倍增假了，如果坚持下去可能就切了，痛失 90 分 & Div2 Rank 3。

## 思路

首先我手推了一下 $n\leq 20$ 的情况。我把是 $\rm Cute\ Number$ 的记录为 $1$，否则为 $0$。于是可以得到：

$\begin{bmatrix}1&2&3&4&5&6&7&8&9&10&11&12&13&14&15&16&17&18&19&20\\1&1&0&1&1&1&0&0&1&1&1&1&0&0&0&1&1&1&1&1\end{bmatrix}$

简单观察规律，可以发现下面的 $0/1$序列是由若干个 $0/1$ 段交替组成的，长度分别为 $2,1,3,2,4,3,...$。考虑怎么用询问求出这个位置是多少。

1. 这个数是 $\rm Cute\ Number$：这个时候，我们考虑找出他所在这一段的后面一段 $0$ 段的长度，记它为 $L$，则他所在 $1$ 段的末尾位置是 $L(L+1)$。至于是为啥……我找规律的（）

2. 这个数不是 $\rm Cute\ Number$：这个时候，我们考虑找出他所在这一段的后面一段的 $1$ 段的长度，同样记它为 $L$，则他所在的 $0$ 段的末尾位置是 $L(L-2)$，我也是找规律的。

然后我们直接倍增的求出这个点到末尾位置的距离就好了。

现在唯一的问题就是怎么求出这个数后面那一段的开头结尾都在哪里。我们可以倍增的做，每次倍增 $x+1,x+2,x+4,\dots,x+2^k$。此时假设我们倍增到和 $x$ 所在段 $01$ 不同的位置为止，然后再 $x+2^{k-1},\dots,x+2,x+1$ 倍增回来。这一步需要 $2\log \sqrt{V}$ 的时间。这样我们找到了这个数所在段的结尾，即下一段所在段的开头 $-1$ 的位置。然后，我们从这个位置仿照上面再倍增一次，求出结尾。

这样，我们就在 $4 \log \sqrt{V}$ 的复杂度内求得答案。但是这个超过了限制，我们考虑优化。

我们发现后面那一段的长度一定大于等于 $2^k$。所以我们倍增的时候可以从 $k$ 开始，这样的话，前面求开头的倍增，加上这里求结尾的倍增，从 $1$ 向上递增的跳的总复杂度可以看成 $O(\log \sqrt{V})$，而另外两次向下递减的跳得时候，复杂度分别是 $O(\log \sqrt{V})$，加起来是 $O(3 \log \sqrt{V})$，最大也就 $3 \log 10^6\leq 60$，可以通过。

## 代码

花了大概不到 1 个小时，调各种错误，代码有点乱见谅，但是这确实是我独立做的qwq。

要是当时赛时我自信一点没有否掉这个思路，或许我能做得更好。当然这都是后话啦，下次努力就好了。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

bool flag; // x 是不是 Cute Number 
int st,en; // 记录 x 后面那一段的起点、终点 
int Get_Start(){ // 返回值就是第一次失败的 k 
	int k=0,ans;
	for(;;k++){
		cout<<"? "<<(1<<k)<<endl; fflush(stdout); // 询问 x+2^k 是不是 
		bool op; cin>>op;
		if(op!=flag) break;
		st=(1<<k); // 如果是那么起点更新，最大的起点在这个位置。注意不是 +=，因为这只是找一个最大的 k 
	}
	ans=k--; // k 要减一，因为之前的那个 k 是失败的 k
	for(k--;k>=0;k--){ // 向下倍增，注意这里 k 要减一，因为 2^(k-1)+2^(k-1) 其实是取不到的，可以优化掉。 
		cout<<"? "<<st+(1<<k)<<endl; fflush(stdout);
		bool op; cin>>op;
		if(op!=flag) continue;
		st+=(1<<k);
	}
	return ans;
}
void Get_End(int S){
	int k=S; en=st+1; // 从上次失败的地方倍增
	for(;;k++){
		cout<<"? "<<st+1+(1<<k)<<endl; fflush(stdout);
		bool op; cin>>op;
		if(op==flag) break;
		en=st+1+(1<<k); // 同理，更新终点 
	}
	for(k--;k>=0;k--){
		cout<<"? "<<en+(1<<k)<<endl; fflush(stdout);
		bool op; cin>>op;
		if(op==flag) continue;
		en+=(1<<k); // 这里也是同理 
	}
}

signed main(){
	int T; cin>>T;
	while(T--){
		st=en=flag=0;
		cout<<"? 0"<<endl; fflush(stdout);
		cin>>flag;
		int k=Get_Start();
//		cout<<"st: "<<st<<endl;
		Get_End(k);
		if(flag){
			cout<<"! "<<(en-st)*(en-st+1)-st<<endl; // 如果 x 是 Cute Number，那么套用第一个公式 
			fflush(stdout);
		}else{
			cout<<"! "<<(en-st)*(en-st-2)-st<<endl; // 否则套用第二个公式
			fflush(stdout); 
		}
	}
	return 0;
}
```

以后要记住倍增这个好东西！！！

---


# 王者之剑

## 题目描述

![https://cdn.luogu.com.cn/upload/pic/17920.png](https://cdn.luogu.com.cn/upload/pic/17920.png)  

这是在阿尔托利亚·潘德拉贡成为英灵前的事情，她正要去拔出石中剑成为亚瑟王，在这之前她要去收集一些宝石。

宝石排列在一个 $n \times m$ 的网格中，每个网格中有一块价值为 $v_{i,j}$ 的宝石，阿尔托利亚·潘德拉贡可以选择自己的起点。

开始时刻为 $0$ 秒。以下操作，每秒按顺序执行。

1. 在第 $i$ 秒开始的时候，阿尔托利亚·潘德拉贡在方格 $(x,y)$ 上，她可以拿走 $(x, y)$ 中的宝石。
2. 在偶数秒，阿尔托利亚·潘德拉贡周围四格的宝石会消失。
3. 若阿尔托利亚·潘德拉贡第 $i$ 秒开始时在方格 $(x,y)$ 上，则在第 $i+1$ 秒可以立即移动到 $(x+1,y),(x,y+1),(x-1,y)$ 或 $(x, y- 1)$ 上，也可以停留在（$x,y)$ 上。


求阿尔托利亚·潘德拉贡最多可以获得多少价值的宝石

## 说明/提示

姚金宇的原创题。

## 样例 #1

### 输入

```
2 2
1 2
2 1```

### 输出

```
4```

# 题解

## 作者：RemiliaScar1et (赞：14)

### 解析

~~大家做法都差不多呀，我来给个详细证明吧~~

我们观察一下这个问题的某些 ~~显然的~~ 特殊性质

首先，我们只能在偶数秒拿到宝石。奇数秒走到的格子已经被上一个偶数秒清空了。

而且我们不能同时拿到相邻格子上的两个宝石。原因同上。

这个时候已经有点独立集那味了。我们若是把相邻的格子黑白染色并连上边，那么最优方案选出来的点就组成一个独立集，还是二分图的最大点权独立集。其实我们可以看出，每种合法方案都可以转化这个二分图的一个独立集。

但是每个独立集都是一个合法方案吗？这可不一定。我们需要证明出来。

怎么去考虑？最好的方法是对任意独立集直接构造一个合法方案出来。

我们先把每一行看做一个阶段，用 “S” 形路线试着挨个遍历每个阶段。以下图一个 $6\times 6$ 的矩阵举例

![](https://img.imgdb.cn/item/602fa5aae7e43a13c690925e.png)

标灰色的点是独立集中的点，也就是我们要取到的点。

进入 $A2$ 时一定是偶数秒，进入$A3$ 是奇数秒，进入 $A4$ 是偶数秒，如果我们要保证能拿到 $A5$ 那我们就要在 $A3$ 停顿一秒，但是我们一停顿就会将我们接下来要取的 $B3$ 给炸了。并且在其他任何地方停顿都无法保证任意一个的灰点都能够被取到。所以这种构造方式不可行。

但是我们不一定要遍历所有的格子。我们若是每两行为一个阶段，在遍历第一行时连着第二行的一起取完。然后不遍历第二行就可以防止影响下个阶段。可按照如下方式构造：

1. 按遍历方向顺序，依次取宝石。 ~~(废话)~~
2. 第一行的宝石在偶数秒时直接进入格子获取。
3. 第二行的宝石我们要在奇数秒时进入其在第一行的对应格子，然后在偶数秒进入格子取宝石，之后立即返回第一行对应格子，奇偶性没有改变。

来实际操作一下：

![](https://img.imgdb.cn/item/602fac8be7e43a13c693aa2d.png)

我们可以看到，当到达 $A3$ 时，我们直接上去拿到 $B3$ ，用时两秒，时间奇偶性没变。$A5$ 要求在偶数秒进入，那我们就在 $A3$ 停顿一秒。由于 $B3$ 已经拿了，所以没有影响。同样的，我们应在奇数秒进入 $C6$ ，以便取到 $D6$ ，取完 $D6$ 回到 $C6$ 时还是奇数秒，可以顺利取到 $C5$。

试着证它能否取到所有独立集的点。

首先，阶段之间是没有冲突的。我们只有在第二行有灰点时才去第二行，由独立集的性质能知道下一阶段第一行对应位置是没有灰点的。

其次我们需证，对于阶段内的点，必定有一个操作序列能够取到所有的点。

我们将每个格子的要求序列化。对于阶段的第一行，将灰点所在位置设为 $0$ ，代表这个点必须偶数秒进入；将第二行有对应灰点的位置设为 $1$ ，代表必须在奇数时进入这个点；其他的点都设为 $?$ ，假装我们不知道。

就举上面 $Phase\ 1$ 的例子。

![](https://img.imgdb.cn/item/602fb0a8e7e43a13c6958537.png)

构造出来一个序列 $?,0,1,?,0,?$

根据“不能同时拿到相邻格子上的两个宝石”的推论，该序列不应该存在连续的两个 $0$ 或 $1$ 必然是 $01$ 相间的形式。

由于对于一段连续的 $?$ 我们很容易构造序列使其只有单个 $?$，所以问题集中于非 $?$ 和 $?$ 的衔接上。

我们直接开始分类讨论。

1. $0,?,0$ 或 $1,?,1$ 我们只需要令 $?$ 为 $1$ 或 $0$ 即可。

2. $1,?,0$ ，此时我们需要在这一格停留一下，得到序列 $1,(0)1,0$

3. $0,?,1$ ，仍然是用停留解决问题，得到序列 $0,(1)0,1$ 。

综上，对于任意一个独立集，我们都可以构造出一个合法方案取到独立集内所有点。

你已经证明了每一个方案与独立集一一对应，只需要放心大胆跑网络流就可以了，~~快去试一试吧~~

code
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=1e5+10, M=2e6+10,INF=1e8;

int n,m,S,T;
int head[N],ver[M],cc[M],nxt[M],tot=0;
void add(int x,int y,int c)
{
	ver[tot]=y; cc[tot]=c; nxt[tot]=head[x]; head[x]=tot++;
	ver[tot]=x; cc[tot]=0; nxt[tot]=head[y]; head[y]=tot++;
}
int q[N],d[N],cur[N];
int dx[5]={0,1,0,-1};
int dy[5]={-1,0,1,0};

inline int index_(int i,int j)	{return (i-1)*m+j;}

bool bfs()
{
	int hh=0,tt=0;
	memset(d,-1,sizeof d);
	q[0]=S, d[S]=0, cur[S]=head[S];
	while(hh<=tt)
	{
		int x=q[hh++];
		for(int i=head[x];~i;i=nxt[i])
		{
			int y=ver[i];
			if(d[y]==-1 && cc[i])
			{
				d[y]=d[x]+1;
				cur[y]=head[y];
				if(y==T) return 1;
				q[++tt]=y;
			}
		}
	}
	return 0;
}

int find(int u,int lim)
{
	if(u==T) return lim;
	int flow=0;
	for(int i=cur[u];~i && flow<lim;i=nxt[i])
	{
		int y=ver[i];
		cur[u]=i;
		if(d[y]==d[u]+1 && cc[i])
		{
			int tmp=find(y,min(lim-flow,cc[i]));
			if(!tmp) d[y]=-1;
			cc[i]-=tmp; cc[i^1]+=tmp; flow+=tmp;
		}
	}
	return flow;
}

int dinic()
{
	int res=0,flow;
	while(bfs()) while(flow=find(S,INF)) res+=flow;
	return res;
}

int main()
{
	scanf("%d%d",&n,&m);
	S=0,T=N-10;
	memset(head,-1,sizeof head);
	int sum=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			int x;
			scanf("%d",&x);
			sum+=x;
			if((i+j)&1)
			{
				add(S,index_(i,j),x);
				for(int k=0;k<4;k++)
				{
					int xx=i+dx[k],yy=j+dy[k];
					if(xx>=1&&xx<=n&&yy>=1&&yy<=m)
						add(index_(i,j),index_(xx,yy),INF);
				}
			}
			else {
				add(index_(i,j),T,x);
			}
		}
	}
	printf("%d",sum-dinic());
	return 0;
}

```

### 参考文献

胡伯涛 — 《最小割模型在信息学奥赛中的应用》

---

## 作者：VenusM1nT (赞：13)

见到吾王就冲过来做了

在洛谷这个珂学和$Slay$泛滥的地方，找到$Fate$的踪影是多么不容易啊【大雾】

做法很明显，就是求二分图最大权独立集

咦，看到这个名词是不是有点眼熟？

怀着试一试的心情，我点开了`P2774 方格取数问题`，把那边的代码复制了过来……

~~咦，怎么$AC$了？~~

~~真是意外之喜啊！【逃】~~

所以说这题的方法和那题是一样的……

建立超级源点为$0$，超级汇点为$n*m+1$，对点进行染色，奇数点连向源点，偶数点连向汇点，边权为$a[i][j]$，然后奇数点对周围的偶数点连边，边权为$inf$，求出最小割，再用所有点权值的和减去最小割即可

一开始把那道题的代码复制过来然后加弧优化$40$分，以为卡$Dinic$，后来才发现把$Dfs$里的$flow$写成了$flow-used$，真是没救了……

见代码

```cpp
#include<bits/stdc++.h>
#define inf 2147400000
using namespace std;
queue <int> q;
int cnt=1,fst[10005],nxt[80005],to[80005],w[80005],cur[10005];
int n,m,dep[10005],S,T,ans;
int dx[]={0,-1,0,1,0},dy[]={0,0,-1,0,1};
void AddEdge(int u,int v,int c)
{
    to[++cnt]=v;
    nxt[cnt]=fst[u];
    fst[u]=cnt;
    w[cnt]=c;
}
bool Bfs()
{
    memset(dep,0,sizeof(dep));
    q.push(S);
    dep[S]=1;
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(int i=fst[u];i;i=nxt[i])
        {
            int v=to[i];
            if(!dep[v] && w[i])
            {
                dep[v]=dep[u]+1;
                q.push(v);
            }
        }
    }
    return dep[T];
}
int Dfs(int u,int flow)
{
    if(u==T || !flow) return flow;
    int used=0;
    for(int i=cur[u];i;i=nxt[i])
    {
        cur[u]=i;
        int v=to[i];
        if(dep[v]==dep[u]+1 && w[i])
        {
            int fl=Dfs(v,min(flow,w[i]));
            if(fl)
            {
                used+=fl;
                flow-=fl;
                w[i]-=fl;
                w[i^1]+=fl;
                if(!flow) break;
            }
        }
    }
    return used;
}
int Dinic()//弧优化Dinic，不谈
{
    int sum=0;
    while(Bfs())
    {
        memcpy(cur,fst,sizeof(fst));
        sum+=Dfs(S,inf);
    }
    return sum;
}
int main()
{
    scanf("%d %d",&n,&m);
    S=0;
    T=n*m+1;//设置超级源点和汇点
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            int x;
            scanf("%d",&x);
            ans+=x;
            if((i+j)&1)//针对奇数偶数点不同连边
            {
                AddEdge(S,(i-1)*m+j,x);
                AddEdge((i-1)*m+j,S,0);
            }
            else
            {
                AddEdge((i-1)*m+j,T,x);
                AddEdge(T,(i-1)*m+j,0);
            }
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if((i+j)&1)
            {
                for(int k=1;k<=4;k++)
                {
                    int nx=i+dx[k],ny=j+dy[k];
                    if(nx<1 || nx>n || ny<1 || ny>m) continue;
                    AddEdge((i-1)*m+j,(nx-1)*m+ny,inf);
                    AddEdge((nx-1)*m+ny,(i-1)*m+j,0);//和可影响的点连边
                }
            }
        }
    }
    ans-=Dinic();//求最小割并减去
    printf("%d",ans);//输出
    return 0;
}
```

---

## 作者：pkh68 (赞：7)

呃，这道题还没有题解，那我来水一发。

让我们来分析一下：阿尔托利亚一但选择了某一格上的宝石，那么周围四格就不能选了。
想到什么没有？对————


**这道题就是一道裸的二分图最大点权独立集。**

于是我们就黑白染色，按横纵坐标和奇偶性给点分类，建个二分图跑网络流，
然后求出最小割，再用总权值减去最小割就行啦！

~~蒟蒻表示不会KM，也不会Dinic,就胡了个EK上去，相信各位有更好的模板。~~

### 代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<queue>
#include<cstring>
#define re register
#define N 10010
using namespace std;
const int INF=0x7fffffff;
int n,m,s,t,maxflow=0,tot=1,head[N],mp[N],sum=0,x[N],y[N],Xcnt=0,Ycnt=0;
bool vis=true,flag[N],inque[N];
struct Pre{ int id,last; }pre[N];
int mx[2]={0,1};int my[2]={1,0};
struct Edge{ int to,next,val;}edge[N*20];
inline int min(int a,int b){ return a<b?a:b; }
inline void add(int u,int v,int val){
    edge[++tot]=(Edge){v,head[u],val};head[u]=tot;
}
inline bool bfs(){
    queue<int> q;
    memset(inque,0,sizeof(inque));
    memset(pre,-1,sizeof(pre));//初始化
    inque[s]=1;q.push(s);
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int i=head[u];i;i=edge[i].next){
            int v=edge[i].to;
            if(!inque[v]&&edge[i].val){
                pre[v].last=u;
                pre[v].id=i;//记录路径
                if(v==t) return 1;
                inque[v]=1;
                q.push(v);
            }
        }
    }
    return 0;
}//bfs增广（多路增广都没写，竟然过了）
inline int EK(){
    int ans=0;
    while(bfs()){
        int mi=INF;
        for(int i=t;i!=s;i=pre[i].last){
            mi=min(mi,edge[pre[i].id].val);
        }
        for(int i=t;i!=s;i=pre[i].last){
            edge[pre[i].id].val-=mi;
            edge[pre[i].id^1].val+=mi;
        }
        ans+=mi;
    }//网络流
    return ans;
}//垃圾EK,跑的贼慢
int main(){
	scanf("%d%d",&n,&m);
	for(re int i=1;i<=n;++i){
		for(re int j=1;j<=m;++j){
			int id=(i-1)*m+j;
			scanf("%d",&mp[id]);
			sum+=mp[id];//累加权值
		}
	}
	for(re int i=1;i<=n;++i){
		for(re int j=1;j<=m;++j){
			int uid=(i-1)*m+j;//给点编号
			for(re int k=0;k<2;++k){
				int vx=i+mx[k],vy=j+my[k],vid=(vx-1)*m+vy;
				if(vx>n||vy>m) continue;
				if((i+j)&1){
					add(uid,vid,INF);add(vid,uid,0);
					if(!flag[uid]) x[++Xcnt]=uid,flag[uid]=true;
					if(!flag[vid]) y[++Ycnt]=vid,flag[vid]=true;
				}
				else{
					add(vid,uid,INF);add(uid,vid,0);
					if(!flag[vid]) x[++Xcnt]=vid,flag[vid]=true;
					if(!flag[uid]) y[++Ycnt]=uid,flag[uid]=true;
				}//黑白染色，按横纵坐标和奇偶性分类
			}
		}
	}//建二分图
	s=0;t=n*m+1;
	for(re int i=1;i<=Xcnt;++i) add(s,x[i],mp[x[i]]),add(x[i],s,0);//连源点
	for(re int i=1;i<=Ycnt;++i) add(y[i],t,mp[y[i]]),add(t,y[i],0);//连汇点
	printf("%d\n",sum-EK());//求最小割，统计答案
	return 0;
}
```

最后希望有会Dinic的大佬能帮我查下错,谢谢了：

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<queue>
#define re register
#define N 10010
using namespace std;
const int INF=0x7fffffff;
int n,m,s,t,maxflow=0,tot=1,deep[N],cur[N],head[N],mp[N],sum=0,x[N],y[N],Xcnt=0,Ycnt=0;
bool vis=true,flag[N],inque[N];
int mx[2]={0,1};int my[2]={1,0};
struct Edge{ int to,next,val;}edge[N*20];
inline int min(int a,int b){ return a<b?a:b; }
inline void add(int u,int v,int val){ edge[++tot]=(Edge){v,head[u],val};head[u]=tot; }
inline bool bfs(){
    for(int i=s;i<=t;i++) cur[i]=head[i],deep[i]=INF,inque[i]=false;
    queue<int> q;q.push(s);deep[s]=0;inque[s]=true;
    while(!q.empty()){
        int u=q.front();q.pop();inque[u]=false;
        for(int i=head[u];i;i=edge[i].next){
            int v=edge[i].to;
            if(deep[v]>deep[u]+1&&edge[i].val){
                deep[v]=deep[u]+1;
                if(!inque[v]) q.push(v),inque[v]=true;
            }
        }
    }
    return deep[t]!=INF;
}
int dfs(int u,int low){
    int rlow=0,used=0;
    if(u==t){ maxflow+=low;vis=true;return low; }
    for(int i=cur[u];i;i=edge[i].next){
        cur[u]=i;int v=edge[i].to;
        if(edge[i].val&&deep[v]==deep[u]+1){
            if((rlow=dfs(v,min(low,edge[i].val)))){
                used+=rlow;
                edge[i].val-=rlow;
                edge[i^1].val+=rlow;
                if(used==low) break;
            }
        }
    }
    return used;
}
inline int Dinic(){
    while(bfs()){ vis=true;while(vis){ vis=false;dfs(s,INF); } }
    return maxflow;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            int id=(i-1)*m+j;
            scanf("%d",&mp[id]);
            sum+=mp[id];
        }
    }
    for(re int i=1;i<=n;++i){
        for(re int j=1;j<=m;++j){
            int uid=(i-1)*m+j;
            for(re int k=0;k<2;++k){
                int vx=i+mx[k],vy=j+my[k],vid=(vx-1)*m+vy;
                if(vx>n||vy>m) continue;
                if((i+j)&1){
                    add(uid,vid,INF);add(vid,uid,0);
                    if(!flag[uid]) x[++Xcnt]=uid,flag[uid]=true;
                    if(!flag[vid]) y[++Ycnt]=vid,flag[vid]=true;
                }
                else{
                    add(vid,uid,INF);add(uid,vid,0);
                    if(!flag[vid]) x[++Xcnt]=vid,flag[vid]=true;
                    if(!flag[uid]) y[++Ycnt]=uid,flag[uid]=true;
                }
            }
        }
    }
    s=0;t=n*m+1;
    for(int i=1;i<=Xcnt;i++) add(s,x[i],mp[x[i]]),add(x[i],s,0);
    for(int i=1;i<=Ycnt;i++) add(y[i],t,mp[y[i]]),add(t,y[i],0);
    printf("%d\n",sum-Dinic());
    return 0;
}

```


---

## 作者：Yeji_ (赞：5)

## 王者之剑
### 前言
这道题目我怎么看起来有点眼熟？？？这......

### 思路

原先想直接暴力，直接上匈牙利算法的，但是这毕竟是网络流题目还是上网络流吧。（~~虽然老婆饼里没有老婆~~）

自古以来啊，网络流的建模就是一个最难的地方，也是最不好理解的地方。这一道题的建模就是比较难想的。

下面重点讲解一下建模的方法

### 建模
题意说这个大佬可以拿现在这个格子的东西，但如果拿了这个地方的，那么旁边的四个格子就不能拿了。

所以我们设置一些黑白点，现在取了就做黑点，周围的4个点，可以当做白点，而流量值就是现在这个点的点值。

而把白点连线到原点，而把黑点连到汇点，但是这样跑一定的会wa，为什么呢？？

现在，要引入拆点的思想

### 拆点
这一类问题，一个图给出了点权而不是边权，我们在连接边的时候就显得十分不好操作

这个时候我们往往就会有这样一种操作，把每个点拆成入点和出点

题目给出的连边均由每个点的出点连向入点，然后每个点的入点和出点之间连一条流量为点权的边，就可以满足点权的限制了。

所以这道就很容易解了

### 代码
```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
#define inf 2147483647
using namespace std; 
queue<int> f;
const int way1[4]={0,0,1,-1},way2[4]={1,-1,0,0};
struct node
{
    int from,to,dis,next;
}edge[20000000];
int st[1000000],n,m,tot=-1,ans,start,ed,head[1000000],x,id;
void add(int x,int y,int z)
{
    edge[++tot].from=x;
    edge[tot].to=y;
    edge[tot].dis=z;
    edge[tot].next=st[x];
    st[x]=tot;
}
bool bfs()
{
    memset(head,0,sizeof head);
    head[start]=1;
    f.push(start);
    while(!f.empty())
    {
        int x=f.front();
        for(int i=st[x];i>=0;i=edge[i].next)
        {
            int y=edge[i].to;
            if(edge[i].dis>0&&head[y]==0)
            {
                head[y]=head[x]+1;
                f.push(y);
            }
        }
        f.pop();
    }
    if(head[ed]) 
        return true; 
    return false;
}
int dfs(int x,int f)
{
    int s=0,t;
    if(x==ed) 
        return f;
    for(int i=st[x];i>=0;i=edge[i].next)
    {
        int y=edge[i].to;
        if(edge[i].dis>0&&head[y]==head[x]+1&&f>s)
        {
            s+=(t=(dfs(y,min(f-s,edge[i].dis))));
            edge[i].dis-=t;
            edge[i^1].dis+=t;
        }
    }
    if(!s) 
        head[x]=0;
    return s;
}
int isap()
{
    int sum=0;
    while(bfs())
        sum+=dfs(start,inf);
    return sum;
}
int main()
{
    scanf("%d%d",&n,&m);
    start=0,ed=n*m+1;
    memset(st,-1,sizeof st);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            scanf("%d",&x);
            ans+=x;
            id=(i-1)*m+j;
            if((i+j)&1) 
            {
            	add(start,id,x);
                add(id,start,0); 
            }
            else 
            {
                add(id,ed,x);
                add(ed,id,0);
            }
        }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            if((i+j)&1)
            {
                for(int k=0;k<=3;k++)
                {
                    int xx=i+way1[k],yy=j+way2[k];
                    if(xx<=0||xx>n||yy<=0||yy>m) 
                        continue;
                    id=(i-1)*m+j;
                    add(id,(xx-1)*m+yy,inf);
                    add((xx-1)*m+yy,id,0);
                }
            }
    printf("%d",ans-isap());
}
```
~~双倍经验，方格取数问题~~

---

## 作者：Lagerent (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P4474)

偶数秒的时候会使得上下左右四个格子上的宝石消失，那么我们在奇数秒的时候一定走在的是空格子上，于是可以得到**性质 1**：我们只能在偶数秒的时候拿宝石。

进一步地，可以想到**性质 2**：不能同时拿走相邻格子上的宝石。我们将相邻的格子连一条边，则能拿的宝石一定是一个**独立集**。而又是求最大值，我们已经可以发现这题非常像一个**最大权独立集问题**。让我们尝试证明一下。（证明可能略有枯燥，但笔者认为只有透彻了证明，才能了解此题的本质。）

按照横纵坐标和的奇偶性，我们把点分为两类，这就是一个二分图。

接下来我们需要证明的是：对于每一种方案，都可以对应到二分图的一个独立集。

到此我们已经可以将任意一个合法方案对应到二分图的一个独立集。但是还需要证明二分图的任意一个独立集都能对应一个合法方案。构造方案如下：

我们从左上角的一个有宝石的格子开始走，依次去取别的宝石，且每次都取最近的宝石。假设现在离下一个宝石还剩偶数步，判断一下当前是奇数秒还是偶数秒，如果是偶数秒就直接过去拿宝石；如果是奇数秒则在当前格子停顿一下再直接过去拿宝石。按照以上思路，这样的方案一定能将所有独立集中的宝石拿走。

那么此题就转化为了一个最大权独立集问题。

建图方式：从源点向左部点连边，容量为宝石价值；从右部点向汇点连边，容量为宝石价值。从左部点向相邻的右部点连边。用总价值减去最大流即可。

总点数：$100 \times 100 = 10^4$。
总边数：$(10^4 \times 2 + 10^4) \times 2 = 6 
\times 10 ^ 4$。(每个点向右下分别连一条边，源点和汇点和每个点连边，建立残留网络开二倍。)

代码如下：
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define rep(a, b, c) for(int (a) = (b); (a) <= (c); ++ (a))
#define per(a, b, c) for(int (a) = (b); (a) >= (c); -- (a))
using namespace std;

const int N = 10010, M = 60010, inf = 2147483647;

int n, m, S, T;
int hd[N], to[M], f[M], nt[M], idx;
int cur[N], q[N], d[N];

int get(int x, int y) {
    return (x - 1) * m + y;
}

void add(int u, int v, int c) {
    to[idx] = v, f[idx] = c, nt[idx] = hd[u], hd[u] = idx ++ ;
    to[idx] = u, f[idx] = 0, nt[idx] = hd[v], hd[v] = idx ++ ;
}

bool bfs() {
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    d[S] = 0, q[0] = S, cur[S] = hd[S];
    while(hh <= tt) {
        int u = q[hh ++ ];
        for(int i = hd[u]; ~i; i = nt[i]) {
            int v = to[i];
            if(f[i] && d[v] == -1) {
                d[v] = d[u] + 1;
                cur[v] = hd[v];
                if(v == T) return true;
                q[ ++ tt] = v;
            }
        }
    }
    return false;
}

int find(int u, int limit) {
    if(u == T) return limit;
    int flow = 0;
    for(int i = cur[u]; ~i && flow < limit; i = nt[i]) {
        int v = to[i];
        cur[u] = i;
        if(f[i] && d[v] == d[u] + 1) {
            int t = find(v, min(f[i], limit - flow));
            if(!t) d[v] = -1;
            flow += t, f[i] -= t, f[i ^ 1] += t;
        }
    }
    return flow;
}

int dinic() {
    int res = 0, flow;
    while(bfs()) while(flow = find(S, inf)) res += flow;
    return res;
}

int main() {
    scanf("%d%d", &n, &m);
    memset(hd, -1, sizeof hd);
    S = 0, T = n * m + 1;
    int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};
    int tot = 0;
    rep(i, 1, n) {
        rep(j, 1, m) {
            int x;
            scanf("%d", &x);
            if(i + j & 1) {
                add(S, get(i, j), x);
                rep(k, 0, 3) {
                    int a = i + dx[k], b = j + dy[k];
                    if(a < 1 || b < 1 || a > n || b > m) continue;
                    add(get(i, j), get(a, b), inf);
                }
            }
            else add(get(i, j), T, x);
            tot += x;
        }
    }
    printf("%d\n", tot - dinic());
    return 0;
}
```

---

## 作者：ker_xyxyxyx_xxs (赞：2)

[P4474 王者之剑](https://www.luogu.com.cn/problem/P4474)

读完题，非常熟悉。

这不就是方格取数问题吗？二分图最大点权独立集。


四周宝石会消失其实就是不能有公共边换了一个说法。

回顾方格取数问题怎么做？

考虑染色，黑白染色。使用最小割解决。

源点 $ \rightarrow $ 黑点，容量为当前点点权。

白点 $ \rightarrow $ 汇点，容量为当前点点权。

黑点 $ \rightarrow $ 周围白点，容量为 $ \infty $，表示不可割，实际题中体现为不能有公共边。

最后最小割最大流定理跑一边即可。

Code

```cpp
# include <iostream>
# include <cstdio>
# include <queue>
# include <cstring>

using namespace std;

const int N = 2e6 + 5;
const int M = 1e7 + 5;
const int inf = 0x3f3f3f3f;
int S , T;

typedef struct {
	int x , y , z , next;
} Edge;
Edge edge[M];

int E = 1 , elast[N];
int n , m;

void add(int x , int y , int z) {
	E ++;
	edge[E].x = x;
	edge[E].y = y;
	edge[E].z = z;
	edge[E].next = elast[x];
	elast[x] = E;
}
int dis[N] , cnt[N];
void bfs(int start) {
	queue<int> q;
	q.push(start);
	dis[start] = 0;
	cnt[S] = 1;
	while (!q.empty()) {
		int cur = q.front();
		q.pop();
		for (int i = elast[cur] ; i ; i = edge[i].next) {
			int v = edge[i].y;
			if (dis[v] != -1) continue;
			dis[v] = dis[cur] + 1;
			q.push(v);
			cnt[dis[v]] ++;
		}
	}
}
int cur[N];
int dfs(int u , int flow) {
	if (u == T) return flow;
	int temp , delta = 0;
	for (int i = cur[u] ; i ; i = edge[i].next) {
		cur[u] = i;
		int v = edge[i].y;
		if (edge[i].z > 0 && dis[u] == dis[v] + 1) {
			temp = dfs(v , min(flow - delta , edge[i].z));
			edge[i].z -= temp;
			edge[i ^ 1].z += temp;
			delta += temp;
			if (delta == flow) return delta;
		}
	}
	if (dis[S] >= T) return delta;
	cur[u] = elast[u];
	if (-- cnt[dis[u]] == 0) dis[S] = T;
	cnt[++ dis[u]] ++;
	return delta;
}
int Isap() {
	int ans = 0;
	memset(cnt , 0 , sizeof cnt);
	memset(dis , -1 , sizeof dis);
	bfs(T);
	for (int i = 0 ; i <= T ; i ++) {
		cur[i] = elast[i];
	}
	while (dis[S] < T) ans += dfs(S , inf);
	return ans;
}
int x;
int sum = 0;
int main() {
    cin >> n >> m;
    S = 0 , T = n * m + 1;
	for (int i = 1 ; i <= n ; i ++) {
		for (int j = 1 ; j <= m ; j ++) {
			scanf("%d" , &x);
			sum += x;
			if (i & 1) {
				if (j & 1) add(S , (i - 1) * m + j , x) , add((i - 1) * m + j , S , 0);
				else add((i - 1) * m + j , T , x) , add(T , (i - 1) * m + j , 0);
			} else {
				if (j & 1) add((i - 1) * m + j , T , x) , add(T , (i - 1) * m + j , 0);
				else add(S , (i - 1) * m + j , x) , add((i - 1) * m + j , S , 0);
			}
			if (((i & 1) && (j & 1)) || (!(i & 1) && !(j & 1))) {
				if (i - 1 > 0) add((i - 1) * m + j , (i - 2) * m + j , inf) , add((i - 2) * m + j , (i - 1) * m + j , 0);
				if (j - 1 > 0) add((i - 1) * m + j , (i - 1) * m + j - 1 , inf) , add((i - 1) * m + j - 1 , (i - 1) * m + j , 0);
				if (i + 1 <= n) add((i - 1) * m + j , i * m + j , inf) , add(i * m + j , (i - 1) * m + j , 0);
				if (j + 1 <= m) add((i - 1) * m + j , (i - 1) * m + j + 1 , inf) , add((i - 1) * m + j + 1 , (i - 1) * m + j , 0); 
			}
		}
	} 

	printf("%d\n" , sum - Isap());
	return 0;
} 
```

---

## 作者：灼眼的夏娜 (赞：2)

# 首先，看到这道题，要先%一下吾王

![](https://cdn.luogu.com.cn/upload/image_hosting/sgjbqdk8.png)![](https://cdn.luogu.com.cn/upload/image_hosting/ax592kql.png)

### 吾王呆毛所指，吾等心之所向

说实话，这题我就是冲着吾王来的......在这里能看见$Fate$真是太好了

好了好了，我们看题

既然它是网络流，那想必那就难在建图了，我们发现，当选过一个点后，四

周的点就不能选了，所以你想到了什么？对了，二分图最大权独立集，显然

我们是可以由此点向四周连边的，现在少一个源点与汇点，那我们便设$S=0$

$T=m*n+1$再由黑白染色的思想，奇点连$S$，偶点连$T$，建图就解决了，那

么剩下就好办了，就是求一个最小割，也就是最大流，那我们套一个$Dinic$

的板子就好了，当前弧优化的，不过由于本人十分中二，加上目前特别兴奋

$So$，变量名给个好评呗（~~坏笑~~）

## code

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#define R register
#define inf 1e9+7

using namespace std;
const int Excalibur = 10005;//N或MAXN
int n, m, S, T, cur[Excalibur], dep[Excalibur];
struct saber {//edge，我的王
	int nxt, to, v;
}rin[Excalibur<<3];//是凛哦
int Lancer[Excalibur], Fate = 1, Archar;//emmm，head和tot以及sum
int x[5] = {0, -1, 0, 1, 0}, y[5] = {0, 0, -1, 0, 1};

inline void add(int from, int to, int v) {
	rin[++Fate].v = v;
	rin[Fate].to = to;
	rin[Fate].nxt = Lancer[from];
	Lancer[from] = Fate;
}

inline bool bfs(int s, int t) {
	queue<int> Rider;//q
	for(R int i = 0;i <= T;++ i) cur[i] = Lancer[i], dep[i] = 0;
	Rider.push(s); dep[s] = 1;
	while(!Rider.empty()) {
		R int vi = Rider.front();
		Rider.pop();
		for(R int i = Lancer[vi]; i ;i = rin[i].nxt) {
			R int vc = rin[i].to;
			if(!dep[vc] && rin[i].v) {
				dep[vc] = dep[vi] + 1;
				Rider.push(vc);
			}
		}
	}
	return dep[t];
}

int dfs(int s, int t, int flow) {
	if(!flow || s == t) return flow;
	int Caster = 0, Assassin;//增量
	for(R int i = cur[s]; i ;i = rin[i].nxt) {
		R int vc = rin[i].to;
		cur[s] = i;
		if(dep[vc] == dep[s] + 1 && rin[i].v) {
			Assassin = dfs(vc, t, min(flow, rin[i].v));
			if(!Assassin) continue;
			Caster += Assassin; flow -= Assassin;
			rin[i].v -= Assassin; rin[i ^ 1].v += Assassin;
			if(!flow) return Caster;
		}
	}
	return Caster;
}

int Dinic() {
	int res = 0;
	while(bfs(S, T)) res += dfs(S, T, inf);
	return Archar - res;
}

int main() {
	scanf("%d%d",&n, &m);
    //以下是建图，中二到此结束
	S = 0, T = n * m + 1;
	for(R int i = 1;i <= n;++ i)
		for(R int j = 1;j <= m;++ j) {
			R int v; scanf("%d",&v);
			Archar += v;
			R int p = (i - 1) * m + j;
			if((i + j) & 1) { add(S, p, v);add(p, S, 0); }
			else { add(p, T, v);add(T, p, 0); }
		}
	for(R int i = 1;i <= n;++ i) for(R int j = 1;j <= m;++ j)
		if((i + j) & 1)
			for(R int k = 1;k <= 4;++ k) {
				R int f = i + x[k], g = j + y[k];
				if(f < 1 || f > n || g < 1 || g > m) continue;
				R int u = (i - 1) * m + j, v = (f - 1) * m + g;
				add(u, v, inf); add(v, u, 0);
			}
	printf("%d",Dinic());
	return 0;
}
```


---

## 作者：LittleMoMol (赞：1)

## P4474 王者之剑 题解

### 前置知识

本题考的是最大权独立集，对于最大权独立集，令最大权独立集的权值之和为 $|V|$，最小权覆盖集的权值之和为 $|R|$，原图总权值之和为 $|W|$，则满足下列公式：

$$
|V| = |W| - |R|
$$

$|W|$ 很好求，而 $|R|$ 的值就是最小割的值，跑一边最大流即可。

对于证明，用反证法很好证：

如果我们选择一个点覆盖集 $V_1$，那么它的补集 $V_2=V-V_1$ 必定是一个独立集，如果我们假设 $V_2$ 不是一个独立集，那么 $V_2$ 中必定有一条边的两个端点都在 $V_2$ 中，因为 $V_1$ 和 $V_2$ 互补，则可以推出 $V_1$ 中必定有一条边的两个端点都不在 $V_1$ 中，这与 $V_1$ 是点覆盖集矛盾，结论获证。

同理，用同样的方法，假设一个独立集的不补集不是点覆盖集，证明过程极其相似，不再赘述。

综上所述，即可证明 $|V| = |W| - |R|$。

### 建模

从题目背景里面应得到两个非常重要的结论：

1. 只能在偶数秒拿宝石
2. 不可能同时拿走相邻的宝石

其中第 2 条暗示我们这是一个最大权独立集的问题。对于任意 $n \times m$ 的图，我们对其染色，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/g86osmqr.png)

每一个浅蓝格子向周围四个浅粉格子连容量为 $+ \infty$ 的边，可以保证相邻两个格子里的钻石不可能同时取，因为正常的最小割不可能为 $+ \infty$ 。

因为可以原地等待，所以原问题的每一种情况我们都可以通过相当的方法在建立的图中找到合法方案；我们建的每一个图也可以对应每一个实际问题，所以我们建的图和原问题是一一对应的（这一点很重要，这样才能保证我们建的图是正确的），最后直接跑一个最大流输出答案即可。

### Code

```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 10010, M = 60010, INF = 1e8;

int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], depth[N], cur[N];

int get_idx(int x, int y)
{
	return (x - 1) * m + y;
}

void add(int a, int b, int c)
{
	e[idx] = b;
	f[idx] = c;
	ne[idx] = h[a];
	h[a] = idx ++ ;
	
	e[idx] = a;
	f[idx] = 0;
	ne[idx] = h[b];
	h[b] = idx ++ ;
	
	return;
}

bool bfs()
{
	int hh = 0, tt = 0;
	memset(depth, -1, sizeof depth);
	q[0] = S;
	depth[S] = 0;
	cur[S] = h[S];
	
	while (hh <= tt)
	{
		int t = q[hh ++ ];
		for (int i = h[t]; ~i; i = ne[i])
		{
			int ver = e[i];
			if (depth[ver] == -1 && f[i] > 0)
			{
				depth[ver] = depth[t] + 1;
				cur[ver] = h[ver];
				q[ ++ tt] = ver;
				if (ver == T) return true;
			}
		}
	}
	
	return false;
}

int dfs(int u, int lmt)
{
	if (u == T) return lmt;
	int flow = 0;
	for (int i = cur[u]; ~i && flow < lmt; i = ne[i])
	{
		cur[u] = i;
		int ver = e[i];
		if (depth[ver] == depth[u] + 1 && f[i] > 0)
		{
			int t = dfs(ver, min(f[i], lmt - flow));
			if (!t) depth[ver] = -1;
			f[i] -= t;
			f[i ^ 1] += t;
			flow += t;
		}
	}
	
	return flow;
}

int dinic()
{
	int res = 0, flow = 0;
	while (bfs())
		while (flow = dfs(S, INF))
			res += flow;
	return res;
}

int main()
{
	cin >> n >> m;
	S = 0, T = n * m + 1;
	memset(h, -1, sizeof h);
	
	int dx[] = {-1, 0, 1, 0};
	int dy[] = {0, 1, 0, -1};
	
	int tot = 0;
	for (int i = 1; i <= n; i ++ )
		for (int j = 1; j <= m; j ++ )
		{
			int w;
			cin >> w;
			if ((i + j) & 1)
			{
				add(S, get_idx(i, j), w);
				for (int k = 0; k < 4; k ++ )
				{
					int x = i + dx[k];
					int y = j + dy[k];
					if (x >= 1 && x <= n && y >= 1 && y <= m)
						add(get_idx(i, j), get_idx(x, y), INF);
				}
			}
			else
				add(get_idx(i, j), T, w);
			tot += w;
		}
	
	cout << tot - dinic() << endl;
	return 0;
}
```

### 后语

真道题建模真的很有意思诶！还有…… ~~双倍经验P2774~~

---

## 作者：crescentic (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P4474)

**二分图最大点权独立集**了解一下？


**题目分析**：

如果把题意翻译成~~人话~~，意思就是：

在网格中选择格点，如果选择了一个点，那么它周围的四个点都不能选。 求所有方案的最大值。

我只能说，都是套路了。。。


**解题步骤**：

- 将坐标和为偶数的格点与源点相连，奇数则为汇点相连，边权为当前点的点权；

原因：稍微观察就会发现，每个格点与他周围的四个格点的**坐标和**的**奇偶性**不同，说明**相同**奇偶性的格点**不会相互排斥**，也就是可以**同时选**。所以将不同奇偶性连向不同端点就好了。

- 如果坐标和为偶数（因为偶数与**汇点**相连），从当前点向周围四个点连边，边权为正无穷，意为连接的两个点不能**同时**选择。

- 最后，就是 $dinic$ 模板求**最小割**。


**完整代码**：

```pascal
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
using namespace std;
#define rt register int
#define int long long
const int N = 1e4 + 10, M = 1e5 + 10,inf = 2e9;
int n,m,S,T,tot = 1,head[N],cur[N],dep[N],f[M],ans;
int a[4][2] = {{-1,0},{0,-1},{0,1},{1,0}};
struct node {
	int to,nex;
}e[M];
inline void add(int x,int y,int w) {
	e[++tot] = (node) {y,head[x]}, f[tot] = w, head[x] = tot;
	e[++tot] = (node) {x,head[y]}, head[y] = tot;
}
inline void read(int &x) {
	x = 0;
	int ff = 1; char s = getchar();
	while(s < '0' || s > '9') {s = getchar();}
	while(s <= '9' && s >= '0') { x = x * 10 + s - '0'; s = getchar();}
	x *= ff;
}
inline bool bfs() {
	memset(dep,-1,sizeof(dep));
	dep[S] = 0, cur[S] = head[S];
	queue<int> q;
	q.push(S);
	int now,ver;
	while(!q.empty()) {
		now = q.front();
		q.pop();
		for(rt i = head[now]; i; i = e[i].nex) {
			ver = e[i].to;
			if(dep[ver] == -1 && f[i]) {
				dep[ver] = dep[now] + 1, cur[ver] = head[ver];
				if(ver == T) return 1;
				q.push(ver);
			}
		}
	} 
	return 0;
}
inline int find(int x,int limit) {
	if(x == T) return limit;
	int ver,flow = 0,tmp;
	for(rt i = cur[x]; i && flow < limit; i = e[i].nex) {
		cur[x] = i, ver = e[i].to;
		if(dep[ver] == dep[x] + 1 && f[i]) {
			tmp = find(ver,min(limit - flow,f[i]));
			if(!tmp) dep[ver] = -1;
			f[i] -= tmp, f[i ^ 1] += tmp, flow += tmp;
		}
	}
	return flow;
}
inline int dinic() {
	int res = 0,flow;
	while(bfs()) while(flow = find(S,inf)) res += flow;
	return res;
}
inline int pos(int x,int y) {
	return (x - 1) * m + y;
}
signed main() {
	read(n), read(m);
	S = n * m + 1,T = n * m + 2;
	int x,tx,ty;
	for(rt i = 1; i <= n; i ++) {
		for(rt j = 1; j <= m; j ++) {
			read(x);
			ans += x;
			if((i + j) & 1) add(pos(i,j),T,x);
			else {
				add(S,pos(i,j),x);
				for(rt k = 0; k < 4; k ++) {
					tx = i + a[k][0], ty = j + a[k][1];
					if(tx >= 1 && tx <= n && ty >= 1 && ty <= m) {
						add(pos(i,j),pos(tx,ty),inf);
					}
				}
			}
		}
	}
	printf("%lld",ans - dinic());
	return 0;
}
```


---

## 作者：Ireliaღ (赞：1)

教练留的网络流作业，我看见$Saber$就冲进来了，能看到这么一道题月厨深感欣慰。

然后看题。诶？跟方格取数一样的，写一发`ISAP`就切了。

## 建图

- 设$0$为原点，$n \times m + 1$为汇点，把棋盘里的点全部映射到$[1, n \times m]$的节点
- 对于$\forall i \in black$，从$0$向$i$建边，容量为该点数字
- 对于$\forall j \in white$，从$j$向$n \times m + 1$建边，容量为该点数字
- 对于$\forall i \in black$，从$i$向上下左右的白点建边，容量为$\infty$

然后跑最大流，用数字总和减去它即可。

## 代码

指针版`ISAP`，有当前弧优化

```cpp
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include <iostream>
#include <queue>
#include <cstring>

using namespace std;

const int MAXN = 105;
const int INF = 0x3f3f3f3f;

int m, n;

struct Edge{
    int to, val;
    Edge *next, *ops;
    Edge(int to, int val, Edge *next): to(to), val(val), next(next){}
};

Edge *head[MAXN * MAXN], *cur[MAXN * MAXN];

int ID(int x, int y) {
    return (x - 1) * n + y;
}

void AddEdge(int u, int v, int w) {
    head[u] = new Edge(v, w, head[u]);
    head[v] = new Edge(u, 0, head[v]);
    head[u]->ops = head[v]; head[v]->ops = head[u];
}

int dep[MAXN * MAXN], gap[MAXN * MAXN];
int s, t, res;

void Bfs() {
    memset(dep, -1, sizeof(dep));
    memset(gap, 0, sizeof(gap));
    dep[t] = 0; gap[0]++;
    queue<int> q; q.push(t);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (Edge *e = head[u]; e; e = e->next) {
            int v = e->to;
            if (dep[v] != -1) continue;
            q.push(v);
            dep[v] = dep[u] + 1;
            gap[dep[v]]++;
        }
    }
}

int Dfs(int u, int flow) {
    if (u == t) {
        res += flow;
        return flow;
    }
    int used = 0;
    for (Edge *&e = cur[u]; e; e = e->next) {
        int v = e->to;
        if (e->val && dep[v] == dep[u] - 1) {
            int mi = Dfs(v, min(e->val, flow - used));
            if (mi) {
                e->val -= mi;
                e->ops->val += mi;
                used += mi;
            }
            if (used == flow) return used;
        }
    }
    cur[u] = head[u];
    gap[dep[u]]--;
    if (gap[dep[u]] == 0) dep[s] = n * m + 3;
    dep[u]++;
    gap[dep[u]]++;
    return used;
}

void Work() {
    memcpy(cur, head, sizeof(head));
    res = 0;
    Bfs();
    while (dep[s] <= n * m + 2) Dfs(s, INF);
}

int num[MAXN][MAXN];

int main() {
    ios :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> m >> n;
    s = 0; t = n * m + 1;
    int sum = 0;
    for (int i = 1; i <= m; i++)
        for (int j = 1; j <= n; j++)
            cin >> num[i][j], sum += num[i][j];
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if ((i + j) % 2 == 1) {
                AddEdge(0, ID(i, j), num[i][j]);
                if (i > 1) AddEdge(ID(i, j), ID(i - 1, j), INF);
                if (i < m) AddEdge(ID(i, j), ID(i + 1, j), INF);
                if (j > 1) AddEdge(ID(i, j), ID(i, j - 1), INF);
                if (j < n) AddEdge(ID(i, j), ID(i, j + 1), INF);
            } else {
                AddEdge(ID(i, j), n * m + 1, num[i][j]);
            }
        }
    }
    Work();
    cout << sum - res << endl;
    return 0;
}
```

~~如果做过方格取数的话，直接拷贝进来就A了，注意下数组大小~~

---

## 作者：xiezheyuan (赞：0)

[双倍经验](https://www.luogu.com.cn/problem/P2774)

[可能有更好的阅读体验](https://www.cnblogs.com/zheyuanxie/p/p4474.html)

## 简要题意

给你一个 $n\times m$ 的网格，数字在格子里，你需要取出一些格子，使得任意两个格子之间没有公共边，输出格子中的数字和的最大值。

$1 \le n,m \le 100$

## 思路

如果我们能把公共边的关系刻画成一个二分图，那么就是在求二分图最大独立集。

首先我们将有公共边的两个点连边，但是如果都连上就不是二分图了。这时候我们搬出二分图建模的基本思路——黑白染色！

我们可以对网格黑白染色（就像国际象棋棋盘那样），对白色的点，连向跟它有公共边的点。可以证明，这样每一条边都是白色连向黑色，满足二分图定义。

最后我们建一个超级源点 $S$，连向白点，建一个超级汇点 $T$，所有黑点连向它。跑最大流，这样得到的是二分图最大匹配（二分图最小路径点覆盖），然后用二分图点数减去它就好了。

最后附上样例建立的图：

![](https://cdn.luogu.com.cn/upload/image_hosting/z9gibt0j.png)

## 代码

```cpp
#include<bits/stdc++.h>
#define l(i,j) ((i-1)*m+j)
#define int long long
using namespace std;
int n,m,s,t;

namespace MaxFlow{
	struct edge{
		int from,to,val;
	}e[200001];int head[200001],cur[200001],siz=1;
	void add(int x,int y,int z){
		e[++siz].to=y,e[siz].val=z;
		e[siz].from=head[x],head[x]=siz;
	}
	void addedge(int x,int y,int z){
		add(x,y,z);add(y,x,0);
	}
	int gap[200001];
	bool bfs(){
		memset(gap,0,sizeof(gap));
		fill(gap+1,gap+1+n,0);
		queue<int> q;
		q.push(s);
		gap[s]=1;
		while(!q.empty()){
			int now=q.front();
			q.pop();
			for(int i=head[now];i;i=e[i].from){
				int u=e[i].to;
				if(e[i].val&&!gap[u]){
					gap[u]=gap[now]+1;
					q.push(u);
				}
			}
		}
		return (gap[t]);
	}
	int dfs(int now,int val){
		if(now==t) return val;
		for(int &i=cur[now];i;i=e[i].from){
			int u=e[i].to;
			if(e[i].val&&gap[now]+1==gap[u]){
				int F=dfs(u,min(e[i].val,val));
				if(F){
					e[i].val-=F;
					e[i^1].val+=F;
					return F;
				}
			}
		}
		return 0;
	}
	int dinic(){
		int ret=0;
		while(bfs()){
			copy(head,head+1+n,cur);
			int F=0;
			while(F=dfs(s,10000000000000)){
				ret+=F;
			}
		}
		return ret;
	}
}

int sum;

const int delta[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};
signed main(){
	cin>>n>>m;
	s=0,t=m*n+1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			int w;
			cin>>w;
			sum+=w;
			if((i+j)%2){
				MaxFlow::addedge(l(i,j),t,w);
			}
			else{
				MaxFlow::addedge(s,l(i,j),w);
				for(int k=0;k<=3;k++){
					int x=i+delta[k][0],y=j+delta[k][1];
					if((x>=1&&x<=n)&&(y>=1&&y<=m)){
						MaxFlow::addedge(l(i,j),l(x,y),LLONG_MAX);
					}
				}
			}
		}
	}
	n=t;
	cout<<sum-MaxFlow::dinic()<<'\n';
	return 0;
}
```

---

## 作者：strcmp (赞：0)

**符号约定：**

$u \to v$ 结点 $u$ 到结点 $v$ 的边。

[题目链接](https://www.luogu.com.cn/problem/P4474)

**题目大意：** 

给定一个 $n \times m$ 的网格图，每个结点有一个权值 $v_{x,\,y}$，可选择任意点作为初始点。

初始时间为 $0$，当行进到第 $i$ 秒的时候，有如下情况：

1. 第 $i$ 秒开始时，在位置 $(x,\,y)$ 上，则可以将总贡献加上 $v_{x,\,y}$。

2. 在偶数秒，在位置 $(x,\,y)$ 上。则代表 $(x - 1,\,y)$、$(x + 1,\,y)$、$(x,\,y - 1)$ 和 $(x,\,y + 1)$ 的结点贡献清零。

3. 若第 $i$ 秒位于位置 $(x,\,y)$ 上，则第 $i + 1$ 秒可以转移到位置 $(x - 1,\,y)$、$(x + 1,\,y)$、$(x,\,y - 1)$ 和 $(x,\,y + 1)$。

**解决方法：**

假设当前已经走到 $(x,\,y)$，考虑对时间奇偶性分类讨论。

- 当前时间为奇数，则上一秒的时间必然为偶数，也就是在上一个结点时，当前结点的贡献已经清零，故不能加上当前结点的贡献。

- 当前时间为偶数，则上一秒的时间必然为奇数，显然可以加上当前结点的贡献，当不可以加上上一个结点的贡献。

最后考虑加进贡献里的点，可以发现**相邻结点必不可能同时被加入贡献。**

证明显然，相邻结点的奇偶性必然不相同，则两点之中必然有一个结点到达的时间为偶数，则另一个点的贡献就会被清空，因此相邻结点不会同时被加入贡献。

接着，我们考虑从全局的角度观察求解过程，可以推断，当仍然有未被清空的结点时，当前结果必然不大于最优解（显然，因为所有结点的贡献都不低于零）

那么，问题就转化为**从图中取数，使任意两个结点没有公共边，且取出的数的总和最大，请求出最大的和。**

这就是**方格取数问题。**

老套路，黑白染色，建超级源汇，从 $s$ 向所有黑点连容量为该点贡献的边，所以黑结点向相邻白结点连容量为 $+\infty$ 的边，最后所有白点向 $t$ 连容量为该点贡献的边，此时要么是源点出去的边被割，要么是到汇点的边没割，此时的最小割就是所有不被取出的方格的总贡献。

浅浅证明一下（其实可以左转方格取数问题的题解）：

将**被割掉的边表示为不选这个点**，什么意思呢？假设一个黑点 $u$，$s \to u$ 的这条边因为走了其他白点而满流了，那么我们就不会选择这个点 $u$；如果 $u$ 是白点，$u \to t$ 的这条边满流了，我们也不会选择这个点。而黑点到白点的边是不可能被割掉的。（因为容量为  $+\infty$）

首先，我们证明这个方案的**合法性**，考虑反证法，如果跑完最小割之后存在两个互斥的结点 $u$ 和 $v$，**显然 $u,\,v$ 颜色互异**。假设 $u$ 为黑点，$v$ 为白点，则 **$s \to u$ 这条边与 $v \to t$ 这条边都存在且容量不为 $0$**。此时则存在一个权值大于 $0$ 的增广路 $s \to u \to v \to t$，与最大流后不存在增广路矛盾，因此 $s \to u$ 和 $v \to t$ 中必然有一条边被割掉（不可能割掉 $u \to v$ 这条边，还是因为容量为 $+\infty$）。因此**该方案是严格满足合法性的**。

再来证明这个方案的**最优性：**

- **引理 $1$：** 任意割按照上述方法选取之后，必然满足合法性。

证明显然，读者自证不难。

- **引理 $2$：** 引理 $1$ 的逆命题，任意合法方案必定对应于一个割。

反证法，假设当前方案不与任意一个割相对应，则选取之后必然有相邻结点被选择，才能保证当前方案不是一个割，而由于相邻结点不能被选取，因此该方案不满足合法性，因此任意合法方案必定对应于一个割。

- **引理 $3$：** 任意合法方案的权值（**即不选取该方案的结点后，其余结点的权值和**）等于总权值减去与之对应的割的权值。

显然，该引理等价于任意合法方案所包含的点权值等于与之对应的割的权值。

假设当前结点 $u$ 包含于该方案中，分两种情况讨论：

1. $u$ 为黑点，则跑完最小割后 $s \to u$ 在残余网络中的权值为 $0$，此时对答案的贡献为该边的流量，也即该边的容量，显然为该结点的权值。

2. $u$ 为白点，则跑完最小割后 $u \to t$ 在残余网络中的权值为 $0$，此时对答案的贡献为该边的流量，也即该边的容量，显然为该结点的权值。

因为对答案的贡献与结点 $u$ 权值相等，因此任意合法方案所包含的点权值等于与之对应的割的权值。

引理 $3$ 得证。

**总证明：**

根据引理 $2$，**任意合法方案对应于一个割**，又根据引理 $3$，**该合法方案的权值与总权值减去与之对应的割的权值相等**，显然结点的总权值 $w$ 为一常数。则要使得方案最优，即**使得该方案对应的割权值最小**，显然最小割满足该条件，又因为引理 $1$，**最小割必定对应了一个合法方案**，因此该方案同时具有合法性和最优性，**该方案为一个最优方案。**

$\text{Q.E.D.}$

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define inf 1000000000000000
#define V 100010
#define E 5000010
typedef long long int ll;
struct edge {
	int to, next;
	ll capa;
};
int cnt = 0, head[V], n, m; edge node[E];
inline void add(int fir, int nxt, ll w) {
	node[cnt].to = nxt,
		node[cnt].capa = w,
		node[cnt].next = head[fir],
		head[fir] = cnt++;
}
int s, t, dep[V], gap[V], cur[V]; queue<int>que; ll sum = 0;
inline void initing() {
	memset(dep, -1, V * sizeof(int));
	memcpy(cur, head, (t + 1) * sizeof(int));
}
inline void bfs() {
	int fro, ito;
	que.push(t); dep[t] = 0; ++gap[dep[t]];
	while (!que.empty()) {
		fro = que.front(); que.pop();
		for (register int i = head[fro]; i != -1; i = node[i].next) {
			ito = node[i].to;
			if (dep[ito] == -1) {
				dep[ito] = dep[fro] + 1;
				que.push(ito);
				++gap[dep[ito]];
			}
		}
	}
}
ll dfs(int u, ll flow) {
	if (u == t || flow == 0)return flow; ll used = 0, wei = 0;
	for (register int i = cur[u]; i != -1; i = node[i].next) {
		cur[u] = i;
		if (dep[u] == dep[node[i].to] + 1 && node[i].capa) {
			wei = dfs(node[i].to, min(flow - used, node[i].capa));
			if (wei) {
				node[i].capa -= wei;
				node[i ^ 1].capa += wei;
				used += wei;
			}
		}
		if (used == flow)return used;
	}
	--gap[dep[u]];
	if (!gap[dep[u]])dep[s] = t + 1;
	++gap[++dep[u]];
	return used;
}
ll ISAP() {
	initing(); bfs();
	while (dep[s] < t) {
		sum += dfs(s, inf);
		memcpy(cur, head, (t + 1) * sizeof(int));
	}
	return sum;
}
inline void addE(int u, int v, ll w) {
	add(u, v, w);
	add(v, u, 0);
}
inline int bh(int x, int y) { return (x - 1) * m + y; }
int main() {
	ios::sync_with_stdio(0);
	cin.tie(); cout.tie();
	memset(head, -1, V * sizeof(int));
	cin >>  n >> m; s = n * m + 1, t = n * m + 2;
	ll w, flow = 0;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> w; flow += w;
			if ((i + j) & 1) {
				addE(s, bh(i, j), w);
				if (i - 1)addE(bh(i, j), bh(i - 1, j), inf);
				if (i + 1 <= n)addE(bh(i, j), bh(i + 1, j), inf);
				if (j - 1)addE(bh(i, j), bh(i, j - 1), inf);
				if (j + 1 <= m)addE(bh(i, j), bh(i, j + 1), inf);
			}
			else addE(bh(i, j), t, w);
		}
	}
	cout << flow - ISAP();
	return 0;
}
```


---

## 作者：ysy20021208 (赞：0)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**分析与题解：**对于这个矩形，我们进行黑白染色，对于黑点，我们向$S$连一条边，边权为当前点的点权；对于白点，我们向$T$连一条边，边权为当前点的点权。对于两个相邻的点，我们在他们之间连一条边，边权为$inf$。对于建出来的图跑最小割，最后答案就是所有点的点权和减去最小割。

```c++
// luogu-judger-enable-o2
#include <queue>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define N 50000
#define M 5000000
#define inf 1000000000
int n,m,s,t,ans,dis[N],dir1[5]={0,1,-1,0,0},dir2[5]={0,0,0,-1,1};
int cur[N],head[N],to[M<<1],val[M<<1],nxt[M<<1],idx=1;
void add(int a,int b,int c)
    {nxt[++idx]=head[a],to[idx]=b,val[idx]=c,head[a]=idx;}
bool bfs() 
{
    memset(dis,-1,sizeof dis);
    queue <int> q;q.push(s),dis[s]=0;
    while(!q.empty())
    {
        int p=q.front();q.pop();
        if(p==t) return true;
        for(int i=head[p];i;i=nxt[i])
            if(val[i]>0&&dis[to[i]]==-1)
                dis[to[i]]=dis[p]+1,q.push(to[i]);
    } return false;
}
int dfs(int p,int flow)
{
    int now,temp=flow;
    if(p==t) return flow;
    for(int i=cur[p];i;i=nxt[i])
        if(val[i]>0&&dis[to[i]]==dis[p]+1)
        {
            now=dfs(to[i],min(val[i],temp));
            if(!now) dis[to[i]]=-1;
            temp-=now,val[i]-=now,val[i^1]+=now;
            if(val[i]) cur[p]=i;
            if(!temp) break;
        } return flow-temp;
}
void dinic() {while(bfs()) memcpy(cur,head,sizeof head),ans-=dfs(s,inf);}
bool in(int x,int y) {return x&&x<=n&&y&&y<=m;}
int pla(int i,int j) {return (i-1)*m+j;}
int main()
{
    scanf("%d%d",&n,&m),s=n*m+1,t=n*m+2;
    for(int i=1;i<=n;i++) for(int j=1,a;j<=m;j++) { scanf("%d",&a),ans+=a;
        if((i+j)%2) add(s,pla(i,j),a),add(pla(i,j),s,0);
        else add(pla(i,j),t,a),add(t,pla(i,j),0); }
    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++)
        if((i+j)%2) for(int k=1;k<=4;k++) if(in(i+dir1[k],j+dir2[k]))
            add(pla(i,j),pla(i+dir1[k],j+dir2[k]),inf),
            add(pla(i+dir1[k],j+dir2[k]),pla(i,j),0);
    dinic(),printf("%d\n",ans);
}
```

---


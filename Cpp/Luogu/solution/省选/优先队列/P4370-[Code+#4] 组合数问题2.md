# [Code+#4] 组合数问题2

## 题目描述

众所周知，小葱同学擅长计算，尤其擅长计算组合数，所以小葱给了你两个数 $n$ 和 $k$，希望你找到 $k$ 个不同的组合数使得这 $k$ 个组合数的和最大。所谓不同的组合数，即对于组合数 $C_{a_1}^{b_1}$​​​ 和 $C_{a_2}^{b_2}$，若 $a_1\neq a_2$ 或者 $b_1\neq b_2$​​，则我们认为这两个组合数是不同的。现在小葱希望你找到这样 $k$ 个不同的组合数，使得它们互不相同且对于其中任何一个组合数 $C_a^b$ 有 $0\leq b\leq a\leq n$。问这 $k$ 个组合数的和最大是多少？

## 说明/提示

对于 $20\%$ 的数据，$n\leq 10$。

对于 $40\%$ 的数据，$n\leq 500$。

对于另外 $20\%$ 的数据，$k=1$。

对于 $100\%$ 的数据，$1\leq n\leq 10^6,1\leq k\leq 10^5.$

Credit: https://www.luogu.org/discuss/show/38908

## 样例 #1

### 输入

```
2 3```

### 输出

```
4```

# 题解

## 作者：da32s1da (赞：12)

[[Code+#4]组合数问题2](https://www.luogu.org/problemnew/show/P4370)

求$K$个不同组合数的最大和。

容易发现$n \choose m$都比$n-1 \choose m$要大。

于是一开始可以将所有的$n \choose i$都丢到一个优先队列中，每次取出最大值$x \choose y$，然后将$x-1 \choose y$再丢到优先队列中。重复$k$次即可。

然而**并没有A掉**这道题（不然也太水了）。

发现是组合数太大，导致优先队列无法比较。

于是可以考虑对组合数**取对数**，然后比较，就可以了。

注意$$\log_2\frac{n!}{m!(n-m)!}=\log_2n!-\log_2m!-\log_2(n-m)!=\sum_{i=1}^n\log_2i-\sum_{i=1}^m\log_2i-\sum_{i=1}^{n-m}\log_2i$$

做一个$\log_2i~$的前缀和即可。

```
#include<cstdio>
#include<cmath>
#include<queue>
using namespace std;
const int N=1e6+50;
const int mod=1e9+7;
typedef long long LL;
typedef double D;
typedef pair<int,int> pr;
typedef pair<D,pr> prr;
int n,k;
LL jc[N],ny[N],ans;
D lg[N];
priority_queue <prr>pg;
LL ksm(LL u,LL v){
	LL ret=1;
	for(;v;u=u*u%mod,v>>=1)
	if(v&1)ret=ret*u%mod;
	return ret;
}
void pre(int ha){
	jc[0]=ny[0]=1;
	for(int i=1;i<=ha;i++)jc[i]=jc[i-1]*i%mod;
	ny[ha]=ksm(jc[ha],mod-2);
	for(int i=ha;i>=2;i--)
	ny[i-1]=ny[i]*i%mod;
	for(int i=1;i<=ha;i++)
	lg[i]=lg[i-1]+log(i);
    //预处理阶乘、逆元、对数
}
int main(){
	pre(N-50);
	scanf("%d%d",&n,&k);
	for(int i=0;i<=n;i++)pg.push(prr(lg[n]-lg[n-i]-lg[i],pr(n,i)));
    //初始将C(n,i)丢进去
	for(int i=1;i<=k;i++){
		int x=pg.top().second.first;
		int y=pg.top().second.second;
		pg.pop();
		ans=(ans+jc[x]*ny[y]%mod*ny[x-y]%mod)%mod;
		x--;
		pg.push(prr(lg[x]-lg[x-y]-lg[y],pr(x,y)));
        //每次取出最大的，丢进去新的
	}
	printf("%lld\n",ans);
} 
```

---

## 作者：Aliemo (赞：9)

题目链接:[P4370 [Code+#4]组合数问题2](https://www.luogu.com.cn/problem/P4370)

### 题目大意

给你两个数 $n,k$ , 要求对于组合数 $C_b^a$ 找到任何 $k$ 个, 让他们的和最大, 且组合数各不相同, 当且仅当 $a,b$ 不完全相同时,组合数不同

### solution

#### 规律

我们来观察一下组合数的递推式 : $C_n^m = C_{n - 1}^m + C_{n - 1}^{m - 1}$

发现, $C_n^m > C_{n - 1}^m$ 那我们可以把所有的 $C_n^i$ 加入优先队列然后弹出的时候加入 $C_{n - 1}^i$

那为什么不加入 $C_{n - 1}^{i - 1}$ 呢?

我们发现 $C_n^m = C_{n - 1}^m + C_{n - 1}^{m - 1}$ 且 $C_n^{m - 1} = C_{n - 1}^{m - 1} + C_{n - 1}^{m - 2}$

发现 $C_{n - 1}^{i - 1}$ 会被上一个数使用,但题目要求不能有相同的,所以我们仅仅加入 $C_{n - 1}^i$ 即可.

#### 细节

但是,我们这样做完就会 $A$ 么? 你以为紫题这么简单??

我们会发现优先队列装不下, 数太大了, $n = 10^6$ 诶, 但是取模之后,我们就不知道谁大谁小了/微笑

那我们该怎么办呢?

在高中的时候会学到对数,我们知道,$y=logx$的函数是单调递增的,那我们可以将所有的组合数取 $log$ 之后放进去.

那我们怎么加入呢?下面,让我们来推导一下这个log的过程

$log C_n^m = log \dfrac{n!}{m!(n - m!)}$

$\ \ \ \ \ \ \ \ \ \ \ \ \ = log n! - log m! - log (n - m)!$

$\ \ \ \ \ \ \ \ \ \ \ \ \ = \sum\limits_{i = 1}^{n}log i - \sum\limits_{i = 1}^{m}log i - \sum\limits_{i = 1}^{n - m}log i$

我们做一个 $log i$的前缀和就可以了

我们可以提前预处理出来需要的值,然后在询问的时候直接做就可以了, 总体复杂度 $O(n + klogn)$

~~妈妈再也不用担心我没有 $A$ 过紫题了~~

### code:
```cpp
/**
 *    Author: Alieme
 *    Data: 2020.8.25
 *    Problem: Luogu P4370
 *    Time: O(n + klogn)
 */
#include <cstdio>
#include <iostream>
#include <string>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>

#define int long long // 不开longlong 见祖宗
#define rr register

#define inf 1e9
#define MAXN 5000010

using namespace std;

const int mod = 1e9 + 7;

inline int read() {
	int s = 0, f = 0;
	char ch = getchar();
	while (!isdigit(ch)) f |= ch == '-', ch = getchar();
	while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
	return f ? -s : s;
}

void print(int x) {
	if (x < 0) putchar('-'), x = -x;
	if (x > 9) print(x / 10);
	putchar(x % 10 + 48);
}

struct Node {
	double val;	// 记录log
	int x, y; // 记录一下n和i
	Node() {}
	Node(int X, int Y, double VAL) { x = X, y = Y, val = VAL;}
	bool operator < (const Node &b) const {	return val < b.val;} // 大根堆
};

int n, k, ans;

int jc[MAXN], inv[MAXN];

double lg[MAXN];

priority_queue<Node> q;  // 优先队列

inline void init() { // 预处理阶乘,逆元,log
	jc[0] = inv[0] = inv[1] = 1;
	for (rr int i = 1; i <= 1000000; i++) jc[i] = i * jc[i - 1] % mod;
	for (rr int i = 2; i <= 1000000; i++) inv[i] = (mod - mod / i) * inv[mod % i] % mod;
	for (rr int i = 1; i <= 1000000; i++) inv[i] = inv[i] * inv[i - 1] % mod;
	for (rr int i = 1; i <= 1000000; i++) lg[i] = lg[i - 1] + log(i); //有log真好,省的自己写了
}

signed main() {
	init();
	n = read();
	k = read();
	for (rr int i = 0; i <= n; i++) q.push(Node(n, i, lg[n] - lg[i] - lg[n - i])); // 把C加入
	while (k--) {
		Node p = q.top();
		q.pop();
		// cout << p.x << " " << p.y << " " << "\n";
		ans = (ans + jc[p.x] * inv[p.y] % mod * inv[p.x - p.y]) % mod;
		q.push(Node(p.x - 1, p.y, lg[p.x - 1] - lg[p.y] - lg[p.x - 1 - p.y])); // 每次用完之后再加入
	}
	print(ans);
}
```

---

## 作者：Suzt_ilymtics (赞：6)

某次钟神讲课后来补了这道题。

[-> 获得更好的阅读体验](https://www.cnblogs.com/Silymtics/p/14730940.html)

## Description

> 简化题意：给定一个 $n$，要求选出 $k$ 个组合数 $C_a^b$，是他们的和最大。其中 $a,b$ 必须满足 $0 \le a \le b \le n$ 。

## Solution

先考虑如何找到最大的 $k$ 个组合数。

我们知道组合数的递推式是 $C_n^m = C_{n-1}^{m-1} + C_{n-1}^{m}$，并且这个式子就是杨辉三角的形式。

尝试把前几行写出来。

```
1
1 1
1 2  1
1 3  3  1
1 4  6  4 1
1 5 10 10 5  1
1 6 15 20 15 6 1
```

观察一下发现对于第 $i$ 行，第 $\frac{i}{2}$ 个数是最大的；对于每一列，越靠下越大。并且最大的是 $C_n^{\frac{n}{2}}$

那么考虑用广搜的思想，先把最大的 $C_n^{\frac{n}{2}}$ 加进去，然后不断向周围三个方向扩展，取出前 $k$ 大即可。

扩展的时候注意判断是否在界内。

注意判断该位置是否入队过，这里使用 map 标记判断。

但是我们忽视一个问题：我们并不能比较 $C_{a}^{b}$ 的大小。因为我们求不出来，取模的话就会使得大小无法比较。如何解决？

根据钟神的思路想到高中的一个知识点：

$$\log (x \times y) = \log x + \log y$$

$$\log (\frac{x}{y}) = \log x - \log y$$

那么我们的 $C_{a}{b}$ 是不是也可以表示了？

设 $Log_i = \sum_{j=1}^{i} \log j$，有：

$$\log C_a^b = Log_a - Log_b - Log_{a-b}$$

众所周知， $f(x) = \log x$ 是单调递增函数，所以加入优队时比较 $\log C_a^b$ 的大小就好了。

## Code

```cpp
/*
Work by: Suzt_ilymics
Problem: P4370 [Code+#4]组合数问题2
Knowledge: 优先队列，log部分知识 
Time: O(能过)
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<cmath>
#include<map>
#define LL long long
#define orz cout<<"lkp AK IOI!"<<endl

using namespace std;
const int MAXN = 1e6+5;
const int INF = 1e9+7;
const int mod = 1e9+7;
int dx[] = {0, 0, -1, 0};
int dy[] = {0, -1, 0, 1};

struct node {
    int n, m; double val;
    bool operator < (const node &b) const { return val < b.val; }
};

int n, k; LL ans = 0;
double Log[MAXN]; // 开 double 防止精度问题 
int fac[MAXN], inv[MAXN];
priority_queue<node> q;
map<int, bool> Map[MAXN];

int read(){
    int s = 0, f = 0;
    char ch = getchar();
    while(!isdigit(ch))  f |= (ch == '-'), ch = getchar();
    while(isdigit(ch)) s = (s << 1) + (s << 3) + ch - '0' , ch = getchar();
    return f ? -s : s;
}

bool Check(int x, int y) { return x < 0 || y < 0 || y > x; }
LL calc(int n, int m) { return 1ll * fac[n] * inv[m] % mod * inv[n - m] % mod; }

void Init(int limit) { 
    fac[0] = 1, inv[0] = 1;
    fac[1] = 1, inv[1] = 1;
    for(int i = 1; i <= limit; ++i) Log[i] = Log[i - 1] + log(i); //预处理 Log 
    for(int i = 2; i <= limit; ++i) fac[i] = 1ll * fac[i - 1] * i % mod, inv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod; // 预处理阶乘 
    for(int i = 2; i <= limit; ++i) inv[i] = 1ll * inv[i - 1] * inv[i] % mod; // 预处理阶乘的逆元 
}

void Solve() {
    q.push((node){n, n/2, Log[n] - Log[n/2] - Log[n - n/2]}); // 把最大的点加进去 
    Map[n][n/2] = true;
    for(int i = 1; i <= k; ++i) {
        node u = q.top(); q.pop();
//        cout<<u.n<<" "<<u.m<<" \n";
//        cout<<calc(u.n, u.m)<<"\n";
        ans = (ans + calc(u.n, u.m)) % mod;
        for(int j = 1; j <= 3; ++j) { // 枚举三个方向 
            int dn = u.n + dx[j], dm = u.m + dy[j];
            if(Check(dn, dm) || Map[dn][dm]) continue; // 判断是否出界及是否标记过 
            q.push((node){dn, dm, Log[dn] - Log[dm] - Log[dn - dm]});
            Map[dn][dm] = true;
        }
    }
}

int main()
{
    Init(1000000); 
    n = read(), k = read();
    Solve();
    printf("%lld", ans);
    return 0;
}
```






---

## 作者：vectorwyx (赞：4)

题意：求前 $k$ 大的 $(^{a}_{b})$ 的和（$0\le b\le a\le n$）。

放在杨辉三角上看，显然位于正中间的元素的值一定是其所处行的最大值。又因为杨辉三角具有轴对称性，且对称轴的左半边单调递增，右半边单调递减。故而我们可以采用堆贪心，先将所有中间元素——也就是 $(^{i}_{i/2})$——都放到大根堆里，然后不断弹出堆顶。

假设当前弹出了 $(^{x}_{y})$，看一下它位于左半边还是右半边。如果位于左半边，就把与它对称的元素 $(^{x}_{x-y})$ 压入堆中；否则，把与它对称的元素的左邻元素 $(^{x}_{x-y-1})$ 压进去。当然还要加几个简单的特判，相信这一定难不倒聪慧的你，所以就不再赘述咯 XD。

至此，我们的任务就只剩下比较两个组合数的大小了。考虑取对数，$\log((^{x}_{y}))=\log\frac{x!}{{y!(x-y)!}}=\log(x!)-\log(y!)-\log((x-y)!)$，又因为 $\log(n!)=\log((n-1)!)+\log(n)$，所以只需要预处理出 $\log(i)$ 的前缀和就能 $O(1)$ 地求出 $log((^{x}_{y}))$，然后直接比较即可。

总时间复杂度为 $O(k\log(n))$。


------------

代码如下（点个赞再走吧QAQ，谢谢朋友们！）：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
#define db double
#define ll long long
#define fo(i,x,y) for(register int i=x;i<=y;++i)
#define go(i,x,y) for(register int i=x;i>=y;--i)
using namespace std;

const int N=1e6+5,yrz=1e9+7;
const db eps=1e-6;
db sum[N];
int jc[N],inv[N];
struct zhs{//组合数 （钟皓曦x） 
	db v;
	int n,m,vv;
	bool operator<(const zhs &x)const{return x.v-v>eps;} 
	zhs(){} 
	zhs(int x,int y){
		n=x,m=y;
		v=sum[n]-sum[m]-sum[n-m];
		vv=1ll*jc[n]*inv[m]%yrz*inv[n-m]%yrz;
	}
}t;
priority_queue<zhs> q;

int ksm(int x,int y){
	int ret=1,t=x;
	while(y){
		if(y&1) ret=1ll*ret*t%yrz;
		t=1ll*t*t%yrz;
		y>>=1;
	}
	return ret;
}

int main(){
	int n,k;
	cin>>n>>k;
	jc[0]=jc[1]=1;
	fo(i,2,n) sum[i]=sum[i-1]+log(i),jc[i]=1ll*jc[i-1]*i%yrz;
	inv[n]=ksm(jc[n],yrz-2);
	go(i,n-1,0) inv[i]=1ll*inv[i+1]*(i+1)%yrz;
	fo(i,0,n) q.push(zhs(i,i/2));
	int ans=0;
	while(k){//堆贪心
		t=q.top();q.pop();
		k--;
		ans=(ans+t.vv)%yrz;//膜拜yrz！！1 
		int n=t.n,m=t.m,w=(n+1)/2;
		//printf("(%d,%d)=%d w=%d\n",n,m,t.vv,w);
		if(m<w){
			int qwq=n-m;
			q.push(zhs(n,qwq));
		}else{
			int qwq=n-m-1;
			if(qwq>=0) q.push(zhs(n,qwq));  
		}
	}
	cout<<ans;
	return 0;
}
/*
-------------------------------------------------
*/
```


---

## 作者：Dementor (赞：1)

## 题解 P4370 【[Code+#4]组合数问题2】

[P4370 题面](https://www.luogu.com.cn/problem/P4370)

首先我们结合杨辉三角：

```
                      1
                    1    1
                 1     2    1
              1     3    3    1
           1     4     6    4    1
                     ......
```

我们发现了一个规律（大家应该都是一眼发现吧）： $n \choose \lfloor \frac {n} {2} \rfloor$ 总是在一行中最大的。然后向两边递减。

我们想到了贪心！那就是最开始先加入所有 $n \choose \lfloor \frac {n} {2} \rfloor$ 到一个优先队列中，然后当取出一个值的时候，向左（或向右）扩展一个数，加入进去。

不断重复 $k$ 次，就是 $\max (Ans)$ 了。

做完了。

做完了？

---

### 不

为什么呢？大家应该都有这样的体验：超级大的数对 $mod = 10^9 + 7$ 取模之后就 **比较不了大小了** 。所以呢，这道题也一样。

其实这道题的关键就是这个“大数比较”的方法： **取对数**

有： $\log ab = \log a + \log b$

还有诸多对数运算就不一一提及了，这样之后，我们就成功地将大数运算转换成了取对数意义下地较小的数的运算。

这个底数理论上是取任何有意义的数都行的，但是为了保持精度，还是老老实实取一些小一点的数为底数吧。

看看代码？

code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1000010;
const long long mod = 1e9 + 7;
const long double INF = 1e18;
struct node {
	int a, b; // $a choose b$
	int fx; // -1 lr 1 l 2 r
	long double num;
	bool operator < (const node & tmp) const {
		return num < tmp.num;
	}
};
priority_queue <node> pq;
int n, k;
long long Ans = 0;
long long fac[N + 10], ifac[N + 10];
long double logfac[N + 10];
long long qpow (long long a, long long b) {
	long long ans = 1LL;
	while (b) {
		if (b & 1) ans = ans * a % mod;
		a = a * a % mod;
		b >>= 1;
	}
	return ans;
}
long long C (int a, int b) {
	if (a < 0 || b < 0 || b > a) return 0;
	else return fac[a] * ifac[a - b] % mod * ifac[b] % mod;
}
long double logC (int a, int b) {
	return logfac[a] - logfac[a - b] - logfac[b];
}
void debug (int x) {
	for (int i=0;i<=x;i++) {
		for (int j=0;j<=i;j++) cout << C (i, j) << " ";
		cout << endl;
	}
	cout << endl;
}
int main () {
	scanf ("%d %d", &n, &k);
	fac[0] = 1LL; logfac[0] = 0; for (int i=1;i<=n+3;i++) {
		fac[i] = fac[i - 1] * i * 1LL % mod;
		logfac[i] = logfac[i - 1] + log (i * 1.0);
	}
	for (int i=0;i<=n+3;i++) {
		ifac[i] = qpow (fac[i], mod - 2);
	}
	for (int i=1;i<=n;i++) {
		pq.push ((node) {i, i / 2, -1, logC (i, i / 2)});
	}
//	debug (n);
	while (k --) {
		node now = pq.top (); pq.pop ();
		Ans = (Ans + C (now.a, now.b)) % mod;
		if (now.b - 1 >= 0 && now.b - 1 <= n && (now.fx == -1 || now.fx == 1)) pq.push ((node) {now.a, now.b - 1, 1, logC (now.a, now.b - 1)});
		if (now.b + 1 >= 0 && now.b + 1 <= n && (now.fx == -1 || now.fx == 2)) pq.push ((node) {now.a, now.b + 1, 2, logC (now.a, now.b + 1)});
	}
	cout << Ans << endl;
}
```

---

## 作者：RyexAwl (赞：1)

## 题目描述
给定$n$,要求找到$k$个不同的组合数$\binom{a_i}{b_i}$满足$0≤b_i≤a_i≤n$且所有组合数本质不同。

两个组合数本质不同当且仅当$a_i≠a_j$或$b_i≠b_j$


## 说明/提示
对于$100$%的数据，满足$1≤n≤10^6,1≤k≤10^5$

## 思路
首先有一个显然的结论，若存在一组组合数

$$
\binom{m}{j},\binom{n}{j} \ (m<n)
$$
那么有
$$
\binom{m}{j}<\binom{n}{j}
$$
如果要让所取的组合数的和尽量大，那么如果$\binom{n}{i}$没被选用，$\binom{n-1}{i}$一定不会被计入答案。

那么我们可以把所有的$\binom{n}{i}(0≤i≤n)$放入一个集合维护，每次取出最大的，取$k$次。

那么我们可以维护一个大根堆，存一下二元组$(n,k)$,每次取出$\binom{n}{k}$中最大的，取完后再将$\binom{n-1}{k}$加入大根堆。

但是$n$最多可至$10^6$，通过组合数比较显然不现实，这里采用一种十分巧妙的方法：取对数。
$$
\begin{aligned}
log\binom{n}{k}&=log\frac{n!}{k!(n-k)!}\\
&=log(n!)-log(k!)-log(n-k)!\\
&=\sum_{i=1}^nlog(i)-\sum_{j=1}^klog(j)-\sum_{p=1}^{n-k}log(n-k)
\end{aligned}
$$
可以通过预处理前缀和$O(n)$处理出所有的$log$前缀和，然后$O(1)$询问。

总复杂度为$O(n+k\ log\ n)$

代码
```cpp
#include <iostream>
#include <cmath>
#include <algorithm>
#include <vector>
#include <queue>

const int N = 1e6 + 50,mod = 1e9 + 7;

typedef std::pair<long long,long long> PLL;
typedef std::pair<double,PLL> PDL;

std::priority_queue <PDL,std::vector<PDL>,std::less<PDL> > heap;

long long fac[N],invfac[N];

double sum[N];

namespace wxy{

    inline int C(int n,int m){return n<m?0:(long long)fac[n]*invfac[m]%mod*invfac[n-m]%mod;}

    inline void init(){
        for(int i = 1; i <= 1e6; i++) sum[i] = sum[i - 1] + log(i);
        fac[0]=invfac[0]=invfac[1]=1;
        for(int i=1;i<=1e6;i++)fac[i]=(long long)fac[i-1]*i%mod;
        for(int i=2;i<=1e6;i++)invfac[i]=(long long)(mod-mod/i)*invfac[mod%i]%mod;
        for(int i=2;i<=1e6;i++)invfac[i]=(long long)invfac[i-1]*invfac[i]%mod;
    }

    inline double get(int n,int m){return sum[n] - sum[m] - sum[n - m];}

    inline void insert(int n,int m){
        PDL a;
        a.first = get(n,m);
        a.second.first = n;
        a.second.second = m;
        heap.push(a);
    }

    void main(){
        init();
        int n,k;
        std::cin >> n >> k;
        for (int i = 0;i <= n; i++) insert(n,i);
        long long ans = 0;
        while (k--){
            int n = heap.top().second.first,m = heap.top().second.second;
            ans = (ans % mod + C(n,m) % mod) % mod;
            n--;
            heap.pop();
            if (n >= m) insert(n,m);
        }
        std::cout << ans % mod;
    }

}signed main(){wxy::main();return 0;}
```


---

## 作者：子翮 (赞：1)

### 前言

这道题其实将两个子问题结合在了一起，拆开来分别分析，其实还是比较简单的。

不难看出第一个是如何比较两个组合数的大小，第二个是给定范围内前 $k$ 大的组合数。

### 子问题1

考虑组合数 $C_{n1}^{m1}$ 与 $C_{n2}^{m2}$ ,由组合数的定义不难得知：

$$C_{n1}^{m1}= \frac{n1!}{m1!(n1-m1)!}$$
$$C_{n2}^{m2}= \frac{n2!}{m2!(n2-m2)!}$$

这是发现如果简单的用十字相乘比较的话，高精度要写死你...

这里我们采取一种神奇的做法：**取对数** , 由于对数有着化乘为加，化除为减的优良性质，可以得出：

$$log(\frac{n1!}{m1!(n1-m1)!})=log(n1!)-log(m1!)-log((n1-m1!))$$

可以维护一个 $sum[i]$ 表示前 $i$ 个数的对数值相加，以上式子可进一步化为：

$$sum[n1]-sum[m1]-sum[n1-m1]$$

比较两个组合数就转化为比较这个式子的值，$O(n)$ 预处理后就搞定这个子问题啦。

### 子问题2

如何求出前 $k$ 大的组合数呢？由于杨辉三角和组合数有着很大的关联，我们可以借助其来解决。(灵魂画手勿喷)

![](https://cdn.luogu.com.cn/upload/image_hosting/nv2dm8gz.png)

可以看到，在杨辉三角最底层中间的数(标黄的)，也就是 $C_{n}^{\frac{n}{2}}$ 是最大的，又由递推式可得这个数相邻的四个数(标红的)，是除了它以外可能最大的。

所以我们搞一个优先队列，每次取出最大的数，再把它所有相邻的数扔进去，取 $k$ 次队首即可。注意扔进去的时候要判重。这个子问题也搞定啦。

结合一下就可得出代码 (代码中的 $pair$ 存组合数的上下标)：

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cmath>
#include<map>
#define R register
#define MAXN 1000100
typedef long long ll;
using namespace std;
const ll p=1e9+7;
ll n,k,ans;
double sum[MAXN];
ll fac[MAXN],inv[MAXN];
struct cmp //重载优先队列运算符
{
	bool operator () (const pair<ll,ll> &a,const pair<ll,ll> &b) //子问题1的比较方法
	{
		
		return sum[a.first]-sum[a.second]-sum[a.first-a.second]\
		      <sum[b.first]-sum[b.second]-sum[b.first-b.second];
	}
};
priority_queue<pair<ll,ll>,vector<pair<ll,ll> >,cmp> q;
map<pair<ll,ll>,bool> mp,in; // 判重，mp是在不在队列里，in是有没有被取出并计算过
int main()
{
	scanf("%lld%lld",&n,&k);
	fac[0]=fac[1]=inv[0]=inv[1]=1;
	for(R int i=2;i<=n;i++) //预处理阶乘和逆元
	{
		fac[i]=fac[i-1]*i%p;
		inv[i]=(p-p/i)*inv[p%i]%p;
	}
	for(R int i=2;i<=n;i++)
		inv[i]=inv[i-1]*inv[i]%p;
	for(R int i=1;i<=n;i++) //预处理sum数组
		sum[i]=sum[i-1]+log(i);
	mp[make_pair(n,n/2)]=true;
	q.push(make_pair(n,n/2));
	while(k--) //取k次队首
	{
		pair<ll,ll> tp=q.top();q.pop();
		mp[tp]=false;in[tp]=true;
		ll nn=tp.first,mm=tp.second;
		if(mm-1>=0) //四个方向拓展
		{
			tp=make_pair(nn,mm-1);
			if(!mp[tp]&&!in[tp])
			{
				q.push(tp);
				mp[tp]=true;
			} 
		}
		if(mm+1<=nn)
		{
			tp=make_pair(nn,mm+1);
			if(!mp[tp]&&!in[tp])
			{
				q.push(tp);
				mp[tp]=true;
			} 
		} 
		if(mm-1>=0&&nn-1>=0)
		{
			tp=make_pair(nn-1,mm-1);
			if(!mp[tp]&&!in[tp])
			{
				q.push(tp);
				mp[tp]=true;
			} 
		} 
		if(nn-1>=0)
		{
			tp=make_pair(nn-1,mm);
			if(!mp[tp]&&!in[tp])
			{
				q.push(tp);
				mp[tp]=true;
			} 
		} 
		ans=(ans+fac[nn]*inv[mm]%p*inv[nn-mm]%p)%p; //计算队首的贡献
	}
	printf("%lld\n",ans);
	return 0;
}


```



---

## 作者：mol茶蛋糕 (赞：1)

可以通过杨辉三角与组合数的关系得到，$C(n,n/2)$是值最大的。

通过$BFS$扩展$k$次，每次用$set$判断是否重复选择  

用$set$存下$x* n+y$看$set$的$siz$e是否变大判断该点是否被扩展过了  

$BFS$中用优先队列每次选取$C()$最大的加到$ans$里并扩展  

但是优先队列在比较$C()$大小时需要比较的时$C()$未$mod$时的大小，这样会导致炸$long$ $long$  

比较$C(x,y)$的大小可以转化为比较$log(x!)-log(y!)-log((x-y)!)$  

预处理$i=1->n$的$log(i!)$公式：  $lg_1=0$，$lg_i=lg_{i-1}+log(i)$  

#### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define int LL
#define N 1000006
#define mod 1000000007
LL inv[N],fac[N];
double lg[N];
LL mul(int a,int b)
{
	LL ans=1;
	while(b)
	{
		if(b&1) ans=ans*a%mod;
		b>>=1;
		a=a*a%mod;
	}
	return ans;
}
LL C(int x,int y)
{
	if(x<y) return 0;
	if(y==0) return 1;
	if(x==y) return 1;
	return fac[x]*inv[y]%mod*inv[x-y]%mod;
}
struct node{
	int x,y;
    bool operator <(const node t)const{
        return lg[x]-lg[y]-lg[x-y]<lg[t.x]-lg[t.y]-lg[t.x-t.y];
    }
};
priority_queue<node> q;
set<LL> s;
int dx[6]={0,-1,1,0,0};
int dy[6]={0,0,0,-1,1};

signed main()
{
	int n,k;
	scanf("%lld%lld",&n,&k);
	fac[1]=1;
	lg[1]=0;
	for(int i=2;i<=n;i++) 
	{
		fac[i]=fac[i-1]*i%mod;
		lg[i]=lg[i-1]+log(i);
	}
	inv[n]=mul(fac[n],mod-2);
	for(int i=n-1;i>=1;i--) inv[i]=inv[i+1]*(i+1)%mod;
	s.insert(n*n+n/2);
	q.push((node){n,n/2});
	LL ans=0;
	for(int i=1;i<=k;i++)
	{
		node nw=q.top();q.pop();
//		cout<<"LPL"<<nw.x<<' '<<nw.y<<endl;
		ans=(ans+C(nw.x,nw.y))%mod;
		for(int j=1;j<=4;j++)
		{
			int x=nw.x+dx[j],y=nw.y+dy[j];
			if(x<0||x>n||y<0||y>n) continue;
			int p=s.size();
			s.insert(x*n+y);
			if(s.size()==p) continue;
			q.push((node){x,y});
		}
	}
	return printf("%lld\n",ans),0;
}
```

---

## 作者：虚空先知 (赞：1)

考试的时候并不会，乱打暴力。
看到正解，妙啊。
其实大家应该都能打个优先队列优化一下之类的，但你可能只能比较%过之后的数，但他要比较%之前的数，那怎么办呢？神仙操作来了————————取log，对于log（n！） 可以在预处理逆元之类的东西的时候一起预处理出来，而比较C（x1,y1）和C（x2,y2）只需比较（log（x1）-log(y1)-log(x1-y1)）就可以了。
代码：
```
#include<cstdio>
#include<queue>
#include<cmath>
#define ll long long 
using namespace std;
const ll Mod=1000000007;
ll fac[1000010]={1,1};
ll inv[1000010]={1,1};
ll fi[1000010]={1,1};
double lo[1000010]={0,0};
ll C(int m,int n)
{
	return fac[m]*fi[m-n]%Mod*fi[n]%Mod;
}
struct node
{
	int x,y;
	bool operator <(const node t)const
	{
		return lo[x]-lo[y]-lo[x-y]<lo[t.x]-lo[t.y]-lo[t.x-t.y];
	}
};
priority_queue<node> q;
int main()
{
	for(int i=2;i<=1000000;i++)
	{
		fac[i]=fac[i-1]*i%Mod;
		inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod;
		fi[i]=inv[i]*fi[i-1]%Mod;
		lo[i]=lo[i-1]+log(i);
	}
	int l,r,k;
	ll ans=0;
	scanf("%d%d",&r,&k); l=0;
	for(int i=l;i<=r;i++) q.push((node){i,i/2});
	node t;
	while(k)
	{
		t=q.top();q.pop(); 
		if(t.x==t.y*2||k==1) ans=(ans+C(t.x,t.y))%Mod;
		else k--,ans=(ans+C(t.x,t.y)*2)%Mod;
		k--;
		q.push((node){t.x,t.y-1});
	}
	printf("%lld\n",ans);
}
```

---

## 作者：斜揽残箫 (赞：0)

## Description

[更好的阅读体验](https://www.cnblogs.com/Ti-despair/p/14748728.html)

给定 $n,m$ 选 $k$ 个组合数 $\dbinom{n}{m}$，使得结果最大。

$1 \leq n \leq 10 ^ 6,1 \leq k \leq 10 ^ 5$。

## Solution

众所周知，组合数和杨辉三角有着密不可分的联系，这就是一个杨辉三角 ：

```cpp
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
1 5 10 10 5 1
```

根据这个性质，我们发现，最大的数是 $\dbinom{n}{n / 2}$，但在他的周围，我们却不能得到取哪 $k$ 个数字能达到最大。

还有一个问题，那就是 $\dbinom{n}{m}$ 太大了，我们没法存，并且我们也没法取模，因为取模之后就不能进行比较了。

在这里有一个很巧妙的方法解决了这个问题，那就是取对数。

根据高一学到的知识,对数有以下性质 ： 

$$
\begin{aligned}
\log(x \times y) &= \log(x) + \log(y) \\ 
\log(\dfrac{x}{y}) &= \log(x) - \log(y)  
\end{aligned}
$$

之后根据组合数公式 $\dbinom{n}{m} = \dfrac{n!}{m!(n - m)!}$。

所以一个组合数的对数就变成了这样的形式 ： 

$$\log\left(\dbinom{n}{m}\right) = \sum_{i = 1} ^ n \log(i) - \sum_{i = 1} ^ m\log(i) - \sum_{i = 1} ^ {n - m} \log(i)$$

所以我们预处理出 $\sum_{i = 1} ^ n \log(i)$，之后 $O(1)$ 查询就行了。

之后就是取数的问题了，有一个结论 ： 

$$\dbinom{n_1}{m} < \dbinom{n_2}{m} (n_2 > n_1)$$

根据上面的杨辉三角就可以推出来，对于每一列的数，从下到上，依次减小，所以肯定是 $\dbinom{n}{m}$ 取了之后再取 $\dbinom{n - 1}{m}$。

所以我们可以直接将最后一排全部扔进一个小根堆里面，运用贪心的思想，不断取最顶上的数 $X$，去完之后再把 $\dbinom{X - 1}{m}$ 给丢进堆里。

对于从顶上取出来的数直接用阶乘 + 逆元的方法预处理，直接算出来即可。

**注意 ：** 为了不爆精度，必须用 ```double``` 来存 $\log$ 值。

```cpp
#include <cstdio>
#include <cmath>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
#define int long long
using namespace std;
struct Node{
  int nn;
  int mm;
  double LLog;
  inline bool operator < (const Node &z) const {
    return LLog < z.LLog;//重定义小根堆
  }
};
priority_queue <Node> qp;
const int Maxk = 1e6 + 10;
const int mod = 1e9 + 7;
int n,k;
int a[Maxk];
double Log[Maxk];
int inv[Maxk];
inline int read()
{
	int s = 0, f = 0;char ch = getchar();
	while (!isdigit(ch)) f |= ch == '-', ch = getchar();
	while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
	return f ? -s : s;
}
void Prepare()
{
  inv[1] = inv[0] = 1,a[0] = 1;
  for(int i = 1;i <= 1e6;i ++) Log[i] = Log[i - 1] + log(i);//取 log  
  for(int i = 1;i <= 1e6;i ++) a[i] = (a[i - 1] % mod * i % mod + mod) % mod;// 阶乘 
  for(int i = 2;i <= 1e6;i ++) inv[i] = (mod - mod / i) * inv[mod % i] % mod;//逆元 
  for(int i = 1;i <= 1e6;i ++) inv[i] = inv[i - 1] * inv[i] % mod;//阶乘的逆元 
}
signed main()
{
  n = read(),k = read();
  Prepare();
  for(int i = 0;i <= n;i ++) {
    Node cur;
    cur.nn = n;
    cur.mm = i;
    cur.LLog = Log[n] - Log[i] - Log[n - i];
    //cout << cur.nn << " " << cur.mm << " " << cur.LLog << endl;
    qp.push(cur);
  }
  int Ans = 0;
  for(int i = 1;i <= k;i ++) {
    Node now = qp.top();
    qp.pop();
    Ans += (a[now.nn] % mod * inv[now.mm] % mod * inv[now.nn - now.mm] % mod + mod) % mod;
    //cout << "ANS :: " << Ans << " NOW.n ::" << now.nn << " NOW.m :: " << now.mm << " AAA :: " << now.LLog << endl;
    if(Ans >= mod) Ans %= mod;
    now.nn -= 1;//放入下一个数
    now.LLog = Log[now.nn] - Log[now.mm] - Log[now.nn - now.mm];
    qp.push(now);
  }
  cout << Ans << endl;
  return 0; 
} 


```

---

## 作者：红尘仙 (赞：0)

### 给一个小题目

来源于钟神的讲解

#### 【description】
如何比较 $C_{n_1}^{m_1}$ 与 $C_{n_2}^{m_2}$ 的大小。$C_{n_1}^{m_1},C_{n_2}^{m_2}$很大，存不下就对了

#### 【solution1】:
我们可以暴力求解计算，显然是不能取模的，这就很被动，因为我们根本存不了那么大，那么我们就可以考虑一下别的方法。 

**取对数** ： 这么大，我们取个对数就能够比较了， $log$ 显然是单调的，我们对 $C_{n}^{m}$ 取个对数就好，那么我们来推导一下，取对数。

$logC_{n}^{m} = log\frac{n!}{m!(n-m)!} = log(n!) - log(m!) - log((n-m)!)$
$$= \sum_{i=1}^n \log (i) - \sum_{i=1}^m log(i) - \sum_{i=1}^{n-m}log(i)$$

### 来到正片
[【P4370 [Code+#4]组合数问题2】](https://www.luogu.com.cn/problem/P4370)

####【solution2】 ：
这道题的做法，其实很显然，就是有一个地方很坑，就是 $C_{n}^{m}$ 很大，存不下，这怎么办，根据上面的取对数的操作，我们直接对答案取模，然后，用 $\log$ 去比较，就 $OK$
了。

+ 流程：
+ 我们先 $n$ 个玩意逐个压进堆里去。
+ 枚举 $k$ 次，以此从堆里找大的用

#### 【Code】
```
/*
By : Zmonarch
知识点：
*/
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#include <queue>
#define int long long
#define qwq register
#define inf 2147483647
const int kmaxn = 1e6 + 10 ;
const int kmod = 1e9 + 7 ;
inline int read() {
	int x = 0 , f = 1 ; char ch = getchar() ;
	while(!isdigit(ch)) {if(ch == '-') f = - 1 ; ch = getchar() ;}
	while( isdigit(ch)) {x = x * 10 + ch - '0' ; ch = getchar() ;}
	return x * f ;
}
struct Node{
	int n , m ; 
	double val ; 
	bool operator < (const Node &b) const {return val < b.val ;} 
};
std::priority_queue<Node> q ; 
int n , k , ret ; 
int jc[kmaxn] , inv[kmaxn] ; 
double lg[kmaxn] ; 
void init(int n) {
	inv[1] = inv[0] = jc[0] = 1 ;
	for(qwq int i = 1 ; i <= n ; i++) jc[i] = jc[i - 1] * i % kmod ;
	for(qwq int i = 1 ; i <= n ; i++) lg[i] = lg[i - 1] + log(i) ; 
	for(qwq int i = 2 ; i <= n ; i++) inv[i] = ( - kmod / i + kmod) * inv[kmod % i] % kmod ;
	for(qwq int i = 1 ; i <= n ; i++) inv[i] = inv[i - 1] * inv[i] % kmod ; // 我们要的是阶乘的逆元 
}
signed main() {
	init(kmaxn); n = read() , k = read() ;  
	for(qwq int i = 0 ; i <= n ; i++) 
	{
		Node u ; 
		u.n = n ; u.m = i ; u.val = lg[n] - lg[i] - lg[n - i] ; 
		q.push(u) ; 
	}
	while(k--) 
	{
		Node u = q.top() ; q.pop() ; 
		ret = (ret + jc[u.n] * inv[u.m] % kmod * inv[u.n - u.m]) % kmod ; 
		//printf("%lld %lld %lf\n" , u.n , u.m , u.val) ; 
		Node nxt ; 
		nxt.n = u.n - 1 ; nxt.m = u.m ; nxt.val = (lg[nxt.n] - lg[nxt.m] - lg[nxt.n - nxt.m]) ; 
		q.push(nxt) ; 
	}
	printf("%lld\n" , ret) ; 
	return 0 ;
}

```


---

## 作者：No_wonder (赞：0)

这道题是zhx出的呢~~

题意很简单，从可选元素总数小于n的所有组合数中选出最大的k个。

我们首先面对数据点编程，只选一个的话，最大的绝对是$C^{\frac{n}{2}}_n$ 

那么自然而然产生一个问题，其次大的组合数是什么呢？我们无非只有三种选择

$C^{\frac{n}{2}}_{n-1}$ 与$C^{\frac{n}{2}+1}_{n}$ 以及$C^{\frac{n}{2}-1}_{n}$

这提示了我们，我们可以从$C^{\frac{n}{2}}_n$ 扩展开来，直到选择所有的k个，这个扩展的过程可以我们拿堆去维护。

但是这里会出现另一个结论，就是

$C^m_n>C^m_{n-1}$

这是显而易见的。这说明什么呢，如果我的$C^{\frac{n}{2}+1}_{n}$还没有被选，我是绝对不可能选到$C^{\frac{n}{2}+1}_{n-1}$的。

有了这个结论，我们就可以先把所有$C^i_n(0\leq i\leq n)$放到堆里面，然后每一次扩展只需要向上扩展，就是从$C^i_n$扩展到$C^i_{n-1}$

这个时候我们又会遇到一个问题，如何去比较组合数的大小呢，或者说我们堆的排序函数怎么写呢？只需要用到一个简单的技巧。

蒟蒻曾经做过一道zhx的题是取对数比较大小，在这道题里面可以使用。对数函数是有严格单调性的，可以把很大的数字映射到一个小到我们可以比较的值。

对于一个组合数，对数操作就是

$lg C^m_n=lg(\frac{!n}{!m!(n-m)})=lg!n-lg!m-lg!(n-m)$

$=\sum^n_{i=1}lg i-\sum^m_{i=1}lg i-\sum^{n-m}_{i=1}lg i$

我们只需要预处理出来对数函数的前缀和就可以。

完整代码

```cpp
#include<bits/stdc++.h>
#include<queue>
#define ri register int
#define ll long long
using namespace std;
ll mod=1e9+7;
ll jc[1000100],inv[1000100];
double    lg[1000100];
struct Num;
struct Num{
	int a,b;				// 表示b里面选a个 
	ll w;					// 表示取模后的组合数数值
	double l;				// 表示组合数的log值
	Num(int p,int q)		//初始化一个组合数 
	{
		this->a=p;
		this->b=q;
		this->l=lg[b]-lg[a]-lg[b-a];
		this->w=((jc[b]*inv[a])%mod)*inv[b-a]%mod;
	}
	bool operator < (const Num &r) const	//通过比较对数大小来比较组合数大小 
	{
		return l<r.l;
	}
};
int n,k;
ll ans;
priority_queue <Num> q;
int main()
{
	jc[0]=jc[1]=inv[0]=inv[1]=1;								//初始化 
	for(ri i=2;i<=1000009;i++)	inv[i]=(mod-mod/i)*inv[mod%i]%mod;
	for(ri i=1;i<=1000009;i++)	inv[i]=inv[i-1]*inv[i]%mod;
	for(ri i=1;i<=1000009;i++)	jc[i]=jc[i-1]*i%mod;
	for(ri i=1;i<=1000009;i++)	lg[i]=lg[i-1]+log(i);
	scanf("%d%d",&n,&k);
	for(ri i=0;i<=n;i++)
	q.push(Num(i,n));
	while(k--)													//扩展 
	{
		Num tmp=q.top();
		q.pop(); 
		ans=(ans+tmp.w)%mod;
		q.push(Num(tmp.a,tmp.b-1));
	}
	printf("%lld",ans);
} 
```


---

## 作者：pomelo_nene (赞：0)

容易发现，$\displaystyle \max_{i=0}^n\{C_{n}^i\}=C_{n}^{\lfloor \frac{n}{2}\rfloor}$。于是安排一个优先队列，储存好每行最大的那个值。这个值被取出来的时候我们就取出当前的元素，将这个元素旁边的元素取出来。注意这里有一点小细节不要写错了。

但是我们比较的 $C$ 值是经过了取模的，这样的结果可能是错误的。考虑通过另外一个方法去比较组合数。

我们发现：

$$C_{n}^m \bmod 10^9+7=\dfrac{n!}{m!(n-m)!} \bmod 10^9+7$$

对数可以化除为减，所以：

$$\log (C_n^m)  = \log(n!)-\log(m!)-\log((n-m)!)$$

我们就把转换的基准从真实值换成了对数。现在就可以进行组合数比较大小了。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL MOD=1000000007;
LL QuickPow(LL x,LL p)
{
	LL base=x,ans=1;
	while(p)
	{
		if(p&1)	ans*=base,ans%=MOD;
		p>>=1;
		base*=base;
		base%=MOD;
	}
	return ans;
}
double Log[1000005];
LL n,m,fac[1000005],inv[1000005];
double C(LL n,LL m){return Log[n]-Log[m]-Log[n-m];}
LL nearlyTrueC(LL n,LL m){return fac[n]*inv[m]%MOD*inv[n-m]%MOD;} 
struct Binom{
	LL n,m;
	Binom(){n=m=0;}
	Binom(LL N,LL M){n=N,m=M;}
	bool operator < (Binom another) const {return C(n,m)<C(another.n,another.m);}
};
priority_queue<Binom> Q;
int main(){
	fac[0]=fac[1]=1;
	for(LL i=2;i<=1000000;++i)	fac[i]=fac[i-1]*i%MOD;
	inv[1000000]=QuickPow(fac[1000000],MOD-2);
	for(LL i=1000000-1;~i;--i)	inv[i]=inv[i+1]*(i+1)%MOD;
	for(LL i=1;i<=1000000;++i)	Log[i]=Log[i-1]+log(i);
	scanf("%lld %lld",&n,&m);
	for(LL i=0;i<=n;++i)	Q.push(Binom(i,i>>1));
	LL ans=0;
	while(m)
	{
		Binom p=Q.top();
		Q.pop();
		ans+=nearlyTrueC(p.n,p.m);
		ans%=MOD;
		--m;
		if(m && !((p.n&1)==0 && p.m==p.n>>1)) ans+=nearlyTrueC(p.n,p.n-p.m),ans%=MOD,--m;
		if(p.m)	Q.push(Binom(p.n,p.m-1));
	}
	printf("%lld",ans);
	return 0;
}
```

---


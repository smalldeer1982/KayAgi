# 秘籍-反复异或

## 题目描述

给定一个长为 $n$ 的序列，支持操作：

- `1 l r x`：将区间 $[l,r]$ 的所有元素加 $x$。
- `2 l r` ：查询区间 $[l,r]$ 中所有元素异或和的后 $m$ 个二进制位的值。

## 说明/提示

【数据范围】   
本题共 $10$ 个测试点。

对于测试点 $1 \sim 3$，$1\le n,q \le 1000$；    
对于测试点 $4,5$，$1 \le m \le 5$；   
对于测试点 $6 \sim 10$，设 $k$ 为测试点编号，有 $m=k$。  

对于 $100\%$ 的数据，$1 \le n,q \le 10^5$，$1\le m \le 10$，$0\le a_i,x < 2^m$。

**请注意常数优化。**

## 样例 #1

### 输入

```
10 2 10
0 1 0 0 1 0 2 2 0 1 
2 3 9
2 1 5
1 9 9 0
1 3 7 2
1 1 6 3
2 1 10
2 6 7
2 3 6
1 3 9 2
1 3 9 3
```

### 输出

```
1
0
3
1
3
```

# 题解

## 作者：mrsrz (赞：7)

[可能更好的体验](https://mrsrz.github.io/2019/11/27/lg5670/)

在我通过前，这题的正确代码都非常长而且思路比较复杂（也许）。这里说一种简单且易于理解的方法。

考虑到 $m$ 比较小，询问的时候又只考虑最后 $m$ 个二进制位，所以相当于对 $2^m$ 取模。所以数的种类只有 $2^m$ 种，是一个很小的范围。

异或运算是满足消去律的，所以如果一个数 $x$ 对答案产生了贡献，当且仅当它在区间中出现次数为奇数。

我们考虑用```bitset```维护一个数在一段区间中的出现次数。那么合并相邻两个区间的信息，只需要将两个```bitset```异或起来即可。

用线段树维护这些```bitset```，单次查询的时间复杂度为 $O(\frac{2^m}{\omega}\log n)$。

考虑对区间整体加上某个数对```bitset```的影响。那么，原来的第 $k$ 位的信息，现在对应的就是第 $(k+x)\bmod2^{m}$ 位的信息了。相当于整体左移了 $x$ 位，再把前面那些大于等于 $2^m$ 的右移 $2^m$ 位，并合并起来。当 $m=10$ 时，这里就可以写成```b=(b<<x)|(b>>(1024-x))```。

这里更新一个节点的信息是 $O(\frac{2^m}{\omega})$ 的，在线段树上区间修改时，单次复杂度还要乘上 $\log n$。区间修改打标记即可。

最后要得到答案，我们有了一个长度为 $2^m$ 的```bitset```，可以 $O(2^m)$ 判断并计算每位的贡献。

于是得到了一个时间复杂度 $O(\frac{2^m(n+q)\log n}{\omega}+2^mq)$，空间复杂度 $O(2^mn)$ 的算法。

其中，后面的 $O(2^mq)$ 的查询，可以通过预处理，然后手写```bitset```并每 $32$ 位一起求答案，这样可以优化到 $O(\frac{2^mq}{\omega})$。而 STL 的```bitset```没法直接提取多位信息（我不太会的说）。不过由于时间复杂度瓶颈不在这里，所以使用 STL 的效率也是可以接受的。

这样做的话，可能会因为常数问题而过不去。注意到当区间比较小的时候，区间里的数很少，此时使用```bitset```进行运算是非常不划算的，因此在区间比较小的时候，进行暴力修改和查询。

这样就可以通过了，代码长度为 $1.7\rm KB$ 左右。

## Code：

```cpp
#include<iostream>
#include<bitset>
using namespace std;
typedef bitset<1024>BitSet;
const int N=1e5+6;
BitSet d[N];int tg[N],n,m,q,a[N];
void build(int l,int r,int o){
	if(r-l+1<=64){
		for(register int i=l;i<=r;++i)cin>>a[i],d[o].flip(a[i]);
	}else{
		const int mid=l+r>>1;
		build(l,mid,o<<1),build(mid+1,r,o<<1|1);
		d[o]=d[o<<1]^d[o<<1|1];
	}
}
inline void pushdown(int o){
	int&x=tg[o];
	d[o<<1]=(d[o<<1]<<x)|(d[o<<1]>>(1024-x));
	d[o<<1|1]=(d[o<<1|1]<<x)|(d[o<<1|1]>>(1024-x));
	(tg[o<<1]+=x)&=1023,(tg[o<<1|1]+=x)&=1023;
	x=0;
}
void modify(int l,int r,int o,const int&L,const int&R,const int&x){
	if(r-l+1<=64){
		const int lx=max(l,L),rx=min(r,R);
		for(register int i=lx;i<=rx;++i)d[o].flip((a[i]+tg[o])&1023),d[o].flip((tg[o]+((a[i]+=x)&=1023))&1023);
	}else
	if(L<=l&&r<=R){
		d[o]=(d[o]<<x)|(d[o]>>(1024-x));
		(tg[o]+=x)&=1023;
	}else{
		if(tg[o])pushdown(o);
		const int mid=l+r>>1;
		if(L<=mid)modify(l,mid,o<<1,L,R,x);
		if(mid<R)modify(mid+1,r,o<<1|1,L,R,x);
		d[o]=d[o<<1]^d[o<<1|1];
	}
}
void query(int l,int r,int o,const int&L,const int&R,BitSet&b){
	if(r-l+1<=64){
		const int lx=max(l,L),rx=min(r,R);
		for(register int i=lx;i<=rx;++i)b.flip((a[i]+tg[o])&1023);
	}else
	if(L<=l&&r<=R)b^=d[o];else{
		if(tg[o])pushdown(o);
		const int mid=l+r>>1;
		if(L<=mid)query(l,mid,o<<1,L,R,b);
		if(mid<R)query(mid+1,r,o<<1|1,L,R,b);
	}
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m>>q;
	build(1,n,1);
	while(q--){
		int l,r,op,x;
		cin>>op>>l>>r;
		if(op==1){
			cin>>x;
			modify(1,n,1,l,r,x);
		}else{
			static BitSet b;
			b.reset();
			query(1,n,1,l,r,b);
			int ans=0;
			for(register int i=0;i<1024;++i)
				ans^=b[i]*i;
			ans&=(1<<m)-1;
			cout<<ans<<'\n';
		}
	}
	return 0;
}
```


---

## 作者：cyffff (赞：6)

[$\text{Link}$](https://www.luogu.com.cn/problem/P5670)

**这是一篇指令集题解，并非正解。另外，请不要尝试在正式 OI 比赛中使用指令集。**
## 题意
区间加区间后 $m$ 位异或和，$m$ 所有询问相同。

$n,m\le 10^5,0\le a_i< 2^m\le1024$
## 思路
加/异或，指令集基本操作，这个不用多讲。

虽然已经有了一篇指令集题解，但是我还是来推广一种指令集写法，这种写法的优势在于：

- 好写好记
- 可本地运行
- 运行速度较快（至少在只用 `-O2` 时比现有的一篇指令集题解 `-O2 -Ofast` 快 `1.3s`）

这种指令集用 `__attribute((vector_size(32)))` 实现，可以直接进行一些基本操作，不需要写函数，具体可以直接参考代码。

贴个代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned u256 __attribute((vector_size(32)));
#define ll long long
const int N=100000>>3;
int n,m,q;
u256 a[N],ans,tmp;
inline void add(int l,int r,int x){
	u256 xx=u256{x,x,x,x,x,x,x,x};
	if((l>>3)==(r>>3)){
		for(int i=l&7;i<=(r&7);i++){
			a[l>>3][i]+=x;
		}
	}else{
		for(int i=l&7;i<=7;i++){
			a[l>>3][i]+=x;
		}
		for(int i=0;i<=(r&7);i++){
			a[r>>3][i]+=x;
		}
		for(int i=(l>>3)+1;i<=(r>>3)-1;i++){
			a[i]+=xx;
		}
	}
}
inline int query(int l,int r){
	u256 ans=u256{0,0,0,0,0,0,0,0};
	int res=0;
	if((l>>3)==(r>>3)){
		for(int i=l&7;i<=(r&7);i++){
			res^=a[l>>3][i];
		}
	}else{
		for(int i=l&7;i<=7;i++){
			res^=a[l>>3][i];
		}
		for(int i=0;i<=(r&7);i++){
			res^=a[r>>3][i];
		}
		for(int i=(l>>3)+1;i<=(r>>3)-1;i++){
			ans^=a[i];
		}
		for(int i=0;i<=7;i++){
			res^=ans[i];
		}
	}
	return res;
}
int main(){
	n=read(),m=1<<read(),q=read();
	for(int i=0;i<n;i++){
		a[i>>3][i&7]=read();
	}
	while(q--){
		int opt=read(),l=read()-1,r=read()-1;
		if(opt==1){
			add(l,r,read());
		}else{
			write(query(l,r)%m);
			putc('\n');
		}
	}
	flush();
}
```
谢谢观看，再见 qwq~

---

## 作者：FutaRimeWoawaSete (赞：2)

瞄一眼题解，看到了 bitset 瞬间就会了/tuu。                

~~所以没想到 bitset 还是很丢脸，而且丢个分块的标签在这里干嘛啊想了半天。~~

这道题 bitset 能过还是没想到，不过也是合理时间复杂度。         

我们考虑维护区间值域所有数出现次数的奇偶性，那么我们最后查询就只用看一个值是否出现奇数次即可知道它是否需要异或进答案里面了。          

将区间加法看作 bitset 里面的数整体左移 $x$ 位即可，超过的部分我们直接用 bitset 的长度作为限制自然溢出即可，就相当取模。        

考虑一个区间加法该怎么维护，我们发现我们可以对于区间加的值取模后控制在 $2 ^ m$ 之内，那么现在一个区间的 bitset 左移后后面的 $x$ 位需要和前面的 $2 ^ m - x$ 位进行一个整体交换，这个就 $O(\frac{n}{w})$ 单次暴力做就好了。单次下传和单次修改都是 $O(\frac{n}{w})$ 所以最后修改和下传的总时间复杂度就是 $O(q \log n \frac{2 ^ m}{w})$。            

然后区间查询就直接找到 $\log n$ 个线段树对应的区间节点后把对应的每一位直接按位异或起来即可，单次合并一个区间节点的时间复杂度也是 $O(\frac{n}{w})$ 最后查询总的时间复杂度就是 $O(q \log n \frac{2 ^ m}{w})$。

最后总的时间复杂度是 $O(q \log n \frac{2 ^ m}{w})$ 大约 $O(q \log ^ 2 n)$ 的样子可以通过此题。      

想精细卡常的话可以阈值分治一下，当线段树表示的区间长度小于阈值 $T$ 时直接暴力修暴力查，对于此题数据 $T$ 取 $16 \sim 32$ 跑的比较快。

这里给出的实现未卡常。

```cpp
#include "bits/stdc++.h"
using namespace std;
const int Len = 1e5 + 5;
inline int read() {
    char ch = getchar();
    int x = 0, f = 1;
    while (ch < '0' || ch > '9') {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while ('0' <= ch && ch <= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
inline void write(int x) {
    if (x < 0)
        putchar('-'), x = -x;
    if (x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
}
bitset<2> bst1[Len << 2],ans1;
bitset<4> bst2[Len << 2],ans2;
bitset<8> bst3[Len << 2],ans3;
bitset<16> bst4[Len << 2],ans4;
bitset<32> bst5[Len << 2],ans5;
bitset<64> bst6[Len << 2],ans6;
bitset<128> bst7[Len << 2],ans7;
bitset<256> bst8[Len << 2],ans8;
bitset<512> bst9[Len << 2],ans9;
bitset<1024> bst10[Len << 2],ans10;
int n,m,mm,q,a[Len],tag[Len << 2],Print[Len],flag[Len];
#define ls(x) x << 1
#define rs(x) x << 1 | 1
void push_up(int x)
{
	if(mm == 1) bst1[x] = bst1[ls(x)] ^ bst1[rs(x)];
	if(mm == 2) bst2[x] = bst2[ls(x)] ^ bst2[rs(x)];
	if(mm == 3) bst3[x] = bst3[ls(x)] ^ bst3[rs(x)];
	if(mm == 4) bst4[x] = bst4[ls(x)] ^ bst4[rs(x)];
	if(mm == 5) bst5[x] = bst5[ls(x)] ^ bst5[rs(x)];
	if(mm == 6) bst6[x] = bst6[ls(x)] ^ bst6[rs(x)];
	if(mm == 7) bst7[x] = bst7[ls(x)] ^ bst7[rs(x)];
	if(mm == 8) bst8[x] = bst8[ls(x)] ^ bst8[rs(x)];
	if(mm == 9) bst9[x] = bst9[ls(x)] ^ bst9[rs(x)];
	if(mm == 10) bst10[x] = bst10[ls(x)] ^ bst10[rs(x)];
}
void push_down(int p)
{
	if(tag[p])
	{
		tag[ls(p)] += tag[p] , tag[rs(p)] += tag[p];
		if(tag[ls(p)] > m) tag[ls(p)] -= m;
		if(tag[rs(p)] > m) tag[rs(p)] -= m;
		if(mm == 1) bst1[ls(p)] = (bst1[ls(p)] >> (m - tag[p])) | (bst1[ls(p)] << tag[p]) , bst1[rs(p)] = (bst1[rs(p)] >> (m - tag[p])) | (bst1[rs(p)] << tag[p]);
		if(mm == 2) bst2[ls(p)] = (bst2[ls(p)] >> (m - tag[p])) | (bst2[ls(p)] << tag[p]) , bst2[rs(p)] = (bst2[rs(p)] >> (m - tag[p])) | (bst2[rs(p)] << tag[p]);
		if(mm == 3) bst3[ls(p)] = (bst3[ls(p)] >> (m - tag[p])) | (bst3[ls(p)] << tag[p]) , bst3[rs(p)] = (bst3[rs(p)] >> (m - tag[p])) | (bst3[rs(p)] << tag[p]);
		if(mm == 4) bst4[ls(p)] = (bst4[ls(p)] >> (m - tag[p])) | (bst4[ls(p)] << tag[p]) , bst4[rs(p)] = (bst4[rs(p)] >> (m - tag[p])) | (bst4[rs(p)] << tag[p]);
		if(mm == 5) bst5[ls(p)] = (bst5[ls(p)] >> (m - tag[p])) | (bst5[ls(p)] << tag[p]) , bst5[rs(p)] = (bst5[rs(p)] >> (m - tag[p])) | (bst5[rs(p)] << tag[p]);
		if(mm == 6) bst6[ls(p)] = (bst6[ls(p)] >> (m - tag[p])) | (bst6[ls(p)] << tag[p]) , bst6[rs(p)] = (bst6[rs(p)] >> (m - tag[p])) | (bst6[rs(p)] << tag[p]);
		if(mm == 7) bst7[ls(p)] = (bst7[ls(p)] >> (m - tag[p])) | (bst7[ls(p)] << tag[p]) , bst7[rs(p)] = (bst7[rs(p)] >> (m - tag[p])) | (bst7[rs(p)] << tag[p]);
		if(mm == 8) bst8[ls(p)] = (bst8[ls(p)] >> (m - tag[p])) | (bst8[ls(p)] << tag[p]) , bst8[rs(p)] = (bst8[rs(p)] >> (m - tag[p])) | (bst8[rs(p)] << tag[p]);
		if(mm == 9) bst9[ls(p)] = (bst9[ls(p)] >> (m - tag[p])) | (bst9[ls(p)] << tag[p]) , bst9[rs(p)] = (bst9[rs(p)] >> (m - tag[p])) | (bst9[rs(p)] << tag[p]);
		if(mm == 10) bst10[ls(p)] = (bst10[ls(p)] >> (m - tag[p])) | (bst10[ls(p)] << tag[p]) , bst10[rs(p)] = (bst10[rs(p)] >> (m - tag[p])) | (bst10[rs(p)] << tag[p]);
		tag[p] = 0;
	}
}
void build(int p,int l,int r)
{
	tag[p] = 0;
	//printf("%d %d %d\n",p,l,r);
	if(l == r)
	{
		if(mm == 1) bst1[p].set(a[l] , 1);
		if(mm == 2) bst2[p].set(a[l] , 1);
		if(mm == 3) bst3[p].set(a[l] , 1);
		if(mm == 4) bst4[p].set(a[l] , 1);
		if(mm == 5) bst5[p].set(a[l] , 1);
		if(mm == 6) bst6[p].set(a[l] , 1);
		if(mm == 7) bst7[p].set(a[l] , 1);
		if(mm == 8) bst8[p].set(a[l] , 1);
		if(mm == 9) bst9[p].set(a[l] , 1);
		if(mm == 10) bst10[p].set(a[l] , 1);
		return;
	}
	int mid = (l + r) >> 1;
	build(ls(p) , l , mid) , build(rs(p) , mid + 1 , r);
	push_up(p);
}
void update(int p,int l,int r,int nl,int nr,int w)
{
	if(nl <= l && nr >= r) 
	{
		if(mm == 1) bst1[p] = (bst1[p] >> (m - w)) | (bst1[p] << w);
		if(mm == 2) bst2[p] = (bst2[p] >> (m - w)) | (bst2[p] << w);
		if(mm == 3) bst3[p] = (bst3[p] >> (m - w)) | (bst3[p] << w);
		if(mm == 4) bst4[p] = (bst4[p] >> (m - w)) | (bst4[p] << w);
		if(mm == 5) bst5[p] = (bst5[p] >> (m - w)) | (bst5[p] << w);
		if(mm == 6) bst6[p] = (bst6[p] >> (m - w)) | (bst6[p] << w);
		if(mm == 7) bst7[p] = (bst7[p] >> (m - w)) | (bst7[p] << w);
		if(mm == 8) bst8[p] = (bst8[p] >> (m - w)) | (bst8[p] << w);
		if(mm == 9) bst9[p] = (bst9[p] >> (m - w)) | (bst9[p] << w);
		if(mm == 10) bst10[p] = (bst10[p] >> (m - w)) | (bst10[p] << w);
		tag[p] += w;
		if(tag[p] > m) tag[p] -= m;
		return;
	}
	push_down(p);
	int mid = (l + r) >> 1;
	if(nl <= mid) update(ls(p) , l , mid , nl , nr , w);
	if(nr > mid) update(rs(p) , mid + 1 , r , nl , nr , w);
	push_up(p);
}
void query(int p,int l,int r,int nl,int nr)
{
	if(nl <= l && nr >= r)
	{
		if(mm == 1) ans1 ^= bst1[p];
		if(mm == 2) ans2 ^= bst2[p];
		if(mm == 3) ans3 ^= bst3[p];
		if(mm == 4) ans4 ^= bst4[p];
		if(mm == 5) ans5 ^= bst5[p];
		if(mm == 6) ans6 ^= bst6[p];
		if(mm == 7) ans7 ^= bst7[p];
		if(mm == 8) ans8 ^= bst8[p];
		if(mm == 9) ans9 ^= bst9[p];
		if(mm == 10) ans10 ^= bst10[p];
		return;
	}
	push_down(p);
	int mid = (l + r) >> 1;
	if(nl <= mid) query(ls(p) , l , mid , nl , nr);
	if(nr > mid) query(rs(p) , mid + 1 , r , nl , nr);
}
int main()
{
	n = read() , m = read() , q = read();mm = m;m = 1 << m;
	for(int i = 1 ; i <= n ; i ++) a[i] = read();
 	build(1 , 1 , n);
 	for(int i = 1 ; i <= q ; i ++)
 	{
 		int opt,l,r,x;opt = read();
		if(opt == 1) 
		{
			l = read() , r = read() , x = read();
			if(l > r) swap(l , r);
			update(1 , 1 , n , l , r , x);	
			//for(int j = l ; j <= r ; j ++) a[j] += x;
		}	
		else
		{
			flag[i] = 1;
			l = read() , r = read();
			if(l > r) swap(l , r);
			if(mm == 1) ans1.reset();
			if(mm == 2) ans2.reset();
			if(mm == 3) ans3.reset();
			if(mm == 4) ans4.reset();
			if(mm == 5) ans5.reset();
			if(mm == 6) ans6.reset();
			if(mm == 7) ans7.reset();
			if(mm == 8) ans8.reset();
			if(mm == 9) ans9.reset();
			if(mm == 10) ans10.reset();
			query(1 , 1 , n , l , r);
			int res = 0;
			if(mm == 1) for(int j = 1 ; j < m ; j ++) if(ans1[j]) res ^= j;
			if(mm == 2) for(int j = 1 ; j < m ; j ++) if(ans2[j]){res ^= j;}
			if(mm == 3) for(int j = 1 ; j < m ; j ++) if(ans3[j]){res ^= j;}
			if(mm == 4) for(int j = 1 ; j < m ; j ++) if(ans4[j]){res ^= j;}
			if(mm == 5) for(int j = 1 ; j < m ; j ++) if(ans5[j]){res ^= j;}
			if(mm == 6) for(int j = 1 ; j < m ; j ++) if(ans6[j]){res ^= j;}
			if(mm == 7) for(int j = 1 ; j < m ; j ++) if(ans7[j]){res ^= j;}
			if(mm == 8) for(int j = 1 ; j < m ; j ++) if(ans8[j]){res ^= j;}
			if(mm == 9) for(int j = 1 ; j < m ; j ++) if(ans9[j]){res ^= j;}
			if(mm == 10) for(int j = 1 ; j < m ; j ++) if(ans10[j]){res ^= j;}
			Print[i] = res;
			write(res) , putchar('\n');
		}
	}
	return 0;
}
```

---

## 作者：critnos (赞：2)

题面大意：

一序列，俩操作：

1. 区间加

2. 区间异或和 $\bmod 2^m$。

简单的操作，$10^5$ 的数据范围 ~~，显然是指令集板子题。~~

指令集 nb。

其实我也是第一次学，还是对着线段树的指令集题解敲的/xk

对于指令集有兴趣的同学可以看[这里](https://ouuan.github.io/post/n%E6%96%B9%E8%BF%87%E7%99%BE%E4%B8%87-%E6%9A%B4%E5%8A%9B%E7%A2%BE%E6%A0%87%E7%AE%97%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BC%98%E5%8C%96%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/)

比较卡常，不过加个快读就行。

```cpp
#pragma GCC optimize("Ofast,fast-math")
#pragma GCC target("avx,avx2")
#include<bits/stdc++.h>
#include<immintrin.h>
using namespace std;
__m256i a[12505];
int read()
{
   int s=0;
   char ch=getchar();
   while(ch<'0'||ch>'9') ch=getchar();
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s;
}
void add(int l,int r,int x)
{
    for(;(l-1&7)&&l<=r;l++)
		((int*)(a+(l>>3)+1))[(l&7)-1]+=x;
    if(l==r+1) return;
    for(;(r&7)&&l<=r;r--)
		((int*)(a+(r>>3)+1))[(r&7)-1]+=x;
    if(l==r+1) return;
    l=(l>>3)+1,r>>=3;
    __m256i x2=_mm256_set_epi32(x,x,x,x,x,x,x,x);
    for(;l<=r;l++)
		a[l]=_mm256_add_epi32(a[l],x2);
}
int ask(int l,int r)
{
    int s=0,i;
    for(;(l-1&7)&&l<=r;l++)
		s^=((int*)(a+(l>>3)+1))[(l&7)-1];
    if(l==r+1) return s;
    for(;(r&7)&&l<=r;r--)
		s^=((int*)(a+(r>>3)+1))[(r&7)-1];
    if(l==r+1) return s;
    l=(l>>3)+1,r>>=3;
    __m256i s2=_mm256_set_epi32(0,0,0,0,0,0,0,0);
    for(;l<=r;l++)
		s2=_mm256_xor_si256(a[l],s2);
    for(i=0;i<8;i++)
        s^=((int*)&s2)[i];
    return s;
}
int main()
{
	int n,m,q,opt,l,r,i,j,p;
	int x[10];
    scanf("%d%d%d",&n,&m,&q);
    m=1<<m;
    for(i=1;i<=n>>3;i++)
    {
        for(j=0;j<8;j++)
            x[j]=read();
        a[i]=_mm256_set_epi32(x[7],x[6],x[5],x[4],x[3],x[2],x[1],x[0]);
    }
    for(i=0;i<(n&7);i++)
        x[j]=read();
    a[(n>>3)+1]=_mm256_set_epi32(x[7],x[6],x[5],x[4],x[3],x[2],x[1],x[0]);
	while(q--)
    {
        opt=read(),l=read(),r=read();
        if(opt==1)
        {
        	p=read();
			add(l,r,p);
		}   
        else printf("%d\n",ask(l,r)%m);
    }
}
```

---

## 作者：LEE114514 (赞：1)

## 题意

支持区间加、区间异或和对 $2^m$ 取模，其中 $1 \le m \le 10$。

## 思路

值域很小，考虑维护权值数组。

因为 $x \oplus x = 0$，$0 \oplus x = x$，所以我们只关心一个数区间内出现次数的**奇偶性**，想到 `bitset` 维护权值数组奇偶性，区间合并时只需将对应 `bitset` 异或起来。并且，只需要维护**模意义下的**权值数组奇偶性。

首先一个模意义下加法可以理解为 `bitset` 循环左移 $x$ 位，给出代码示例：

```cpp;
b=(b<<x)|(b>>(1024-x))//1024 是 bitset 对象 b 在声明时的长度
```

发现这具有结合律，可以使用线段树维护,每个节点是一个长度 $1024$ 的 `bitset`。

对于查询，我们先用线段树查询出对应区间的权值数组，然后暴力查询 $0$ 到 $1023$ 中的每一个数的奇偶性，出现奇数次就将答案异或这个数。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace IO{//by cyffff
    int len=0;
    char ibuf[(1<<20)+1],*iS,*iT,out[(1<<26)+1];
    #ifdef ONLINE_JUDGE
    #define gh() (iS==iT?iT=(iS=ibuf)+fread(ibuf,1,(1<<20)+1,stdin),(iS==iT?EOF:*iS++):*iS++)
    #endif
    #ifndef ONLINE_JUDGE
    #define gh() getchar()
    #endif
    inline int read(){
        char ch=gh();
        int x=0;
        while(ch<'0'||ch>'9') ch=gh();
        while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=gh();
        return x;
    }
    inline void putc(char ch){
        out[len++]=ch;
    }
    inline void write(int x){
        if(x>9)write(x/10);
        out[len++]=x%10+48;
    }
    inline void flush(){
        fwrite(out,1,len,stdout);
        len=0;
    }
}
using IO::read;
using IO::write;
using IO::flush;
using IO::putc;
const int Bitsize=1024;
typedef bitset<Bitsize> node;
const int maxn=1e5+5;
node trr[maxn<<2];
int tag[maxn<<2];
int n,m,op,x,y,z,q;
int a[maxn];
#define ls (p<<1)
#define rs (ls|1)
inline void pushdown(int p){
	if(tag[p]){
		tag[ls]+=tag[p];
		tag[rs]+=tag[p];
		tag[ls]&=1023;
		tag[rs]&=1023;
		trr[ls]=(trr[ls]>>(Bitsize-tag[p]))|(trr[ls]<<tag[p]);
		trr[rs]=(trr[rs]>>(Bitsize-tag[p]))|(trr[rs]<<tag[p]);
		tag[p]=0;
	}
}
inline void pushup(int p){
	trr[p]=trr[ls]^trr[rs];
}
inline void build(int p,int l,int r){
	if(l==r){
		trr[p][a[l]]=1;
		return;
	}
	int mid=(l+r)>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	pushup(p);
}

inline void modify(int p,int st,int ed){
	if(x<=st&&ed<=y){
		trr[p]=(trr[p]>>(Bitsize-z))|(trr[p]<<z);
		tag[p]+=z;
		tag[p]&=1023;
		return;
	}
	pushdown(p);
	int mid=(st+ed)>>1;
	if(x<=mid) modify(ls,st,mid);
	if(mid<y) modify(rs,mid+1,ed);
	pushup(p);
}
inline void query(int p,int st,int ed,node &res){
	if(x<=st&&ed<=y){
		res^=trr[p];
		return;
	}
	pushdown(p);
	int mid=(st+ed)>>1;
	if(x<=mid) query(ls,st,mid,res);
	if(mid<y) query(rs,mid+1,ed,res);
}
node res;
int ans;
int mask;
int main(){
	n=read(),m=read(),q=read();
	mask=(1<<m)-1;
	for(int i=1;i<=n;++i) a[i]=read()&1023;
	build(1,1,n);
	
	while(q--){
		op=read();
		x=read();
		y=read();
		ans=0;
		if(op==1){
			z=read()&1023;
			modify(1,1,n);
		}else{
			res.reset();
			ans=0;
			query(1,1,n,res);
			for(int i=0;i<Bitsize;++i) ans^=res[i]*i;
			write(ans&mask);
			putc('\n');
		}
	}
	flush();
}
```

---

## 作者：intel_core (赞：1)

考虑用线段树和 `bitset` 维护区间内数的出现情况。

对于线段树的区间修改，相当于是对于存储的 `bitset s` 进行了 `s=((s>>k)<<k)|(x>>(1024-k))`。

由于两个同样的数异或和是 $0$，所以这样维护 `bitset` 最后求出来的答案是对的。

复杂度 $O(n\log n\times \frac{2^m}{w}+2^mq)$，由于 `bitset` 常数偏大所以线段树要进行底层分块，段长在 $32$ 以内直接暴力。

---


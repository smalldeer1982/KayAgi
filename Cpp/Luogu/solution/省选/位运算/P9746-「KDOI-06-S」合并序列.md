# 「KDOI-06-S」合并序列

## 题目描述

给定一个长度为 $n$ 的序列 $a_1,a_2,\ldots a_n$。

你可以对这个序列进行若干（可能为 $0$）次操作。在每次操作中，你将会：

* 选择三个正整数 $i<j<k$，满足 $a_i\oplus a_j\oplus a_k=0$ 且 $k$ 的值不超过此时序列的长度。记 $s=a_i\oplus a_{i+1}\oplus \cdots\oplus a_k$。
* 然后，删除 $a_i\sim a_k$，并在原来这 $k-i+1$ 个数所在的位置插入 $s$。注意，此时序列 $a$ 的长度将会减少 $(k-i)$。

请你判断是否能够使得序列 $a$ 仅剩一个数，也就是说，在所有操作结束后 $a$ 的长度为 $1$。若可以，你还需要给出一种操作方案。

## 说明/提示

**【样例解释 #1】**

对于第一组测试数据：

* 第一次操作中，$a_3\oplus a_4\oplus a_5=1\oplus4\oplus5=0$，操作后的序列为 $[3,3,0]$；
* 第二次操作中，$a_1\oplus a_2\oplus a_3=3\oplus3\oplus0=0$，操作后的序列为 $[0]$。

于是，序列 $a$ 在两次操作后仅剩一个数。

对于第二组测试数据：

* 第一次操作，$a_1\oplus a_3\oplus a_4=3\oplus6\oplus5=0$，$s=4$，操作后的序列为 $[4,4,5,1,2,4]$。
* 第二次操作，$a_2\oplus a_3\oplus a_4=4\oplus5\oplus1=0$，操作后的序列为 $[4,0,2,4]$。
* 第三次操作，$a_1\oplus a_2\oplus a_4=4\oplus0\oplus4=0$，$s=2$，操作后的序列为 $[2]$。

于是，序列 $a$ 在三次操作后仅剩一个数。

**【样例 #2】**

见选手目录下的 `merge/merge2.in` 与 `merge/merge2.ans`。

这个样例满足测试点 $6\sim7$ 的条件限制。

**【样例 #3】**

见选手目录下的 `merge/merge3.in` 与 `merge/merge3.ans`。

这个样例满足测试点 $12\sim13$ 的条件限制。

**【数据范围】**

对于所有数据保证：$1\leq T\leq20$，$1\leq n\leq500$，$0\leq a_i<512$。

| 测试点编号 | $n$ | $\sum n\leq$ | $a_i<$ |
|:--:|:--:|:--:|:--:|
| $1$ | $=1$ | $20$ | $512$ |
| $2$ | $=2$ | $40$ | $512$ |
| $3$ | $=3$ | $60$ | $512$ |
| $4$ | $=4$ | $80$ | $512$ |
| $5$ | $=5$ | $100$ | $512$ |
| $6\sim7$ | $\leq40$ | $800$ | $512$ |
| $8\sim9$ | $\leq70$ | $1~400$ | $512$ |
| $10\sim11$ | $\leq130$ | $2~600$ | $512$ |
| $12\sim13$ | $\leq300$ | $6~000$ | $128$ |
| $14\sim15$ | $\leq500$ | $3~000$ | $64$ |
| $16\sim17$ | $\leq500$ | $3~000$ | $128$ |
| $18\sim20$ | $\leq500$ | $10~000$ | $512$ |

**【提示】**

$\oplus$ 表示按位异或运算。

**请对程序的常数以及效率给予充分的信任。**

## 样例 #1

### 输入

```
2
5
3 3 1 4 5
9
3 4 6 5 4 5 1 2 4```

### 输出

```
Huoyu
2
3 4 5
1 2 3
Huoyu
3
1 3 4
2 3 4
1 2 4```

# 题解

## 作者：Graphcity (赞：13)

考虑区间 DP。设 $f_{l,r}$ 满足区间 $[l,r]$ 的数能不能被缩成一个。转移则是枚举四个点 $l\le a<b\le c<d\le r$，满足 $f_{l,a}=f_{b,c}=f_{d,r}=1$ 且三个区间里面数的异或和为零。

这样是 $O(n^6)$ 的，~~不一定不能过。~~ 考虑优化：设 $f'_{l,r,k}$ 表示 $[l,r]$ 的所有子区间中是否有异或和等于 $k$ 的合法区间。转移则是 $f'_{l,r,k}=f'_{l,r-1,k}\operatorname{or} f'_{l+1,r,k}$，以及如果 $f_{l,r}=1$ 则有 $f'_{l,r,\operatorname{xor}_{i=l}^r a_i}=1$。

这样是 $O(n^4)$ 的，~~有很大概率能过。~~ 考虑优化：设 $g_{l,k}$ 表示左端点 $>l$ 的区间中，异或和等于 $k$ 的合法区间最小的右端点；$h_{l,k}$ 表示满足 $f_{l,a}=f_{b,c}=1$，$l\le a<b\le c$，且 $[l,a],[b,c]$ 两个区间异或和等于 $k$ 的三元组 $(a,b,c)$ 中，最小的 $c$ 值。

其实 $g$ 的意义就是找到 $f$ 中的第二个区间，$h$ 的意义就是找到 $f$ 中的前两个区间。$g$ 的转移类似 $f'$，$h$ 的转移类似 $f$。对于 $f_{l,r}$ 的合法性判定，只需要枚举第三个区间的左端点 $d$，看是不是有 $h_{l,\operatorname{xor}_{i=d}^r a_i}<d$ 即可。

整个转移过程是 $O(n^3)$ 的。接下来是构造：设 $F_{l,r}$ 为 $f_{l,r}$ 一组合法解中的 $d$，$G_{l,k}$ 为一组 $g_{l,k}$ 最优解中的区间左端点，$H_{l,k}$ 为一组 $h_{l,k}$ 最优解中的 $a$。答案从 $f_{1,n}$ 逆推过去就行了。

总时间复杂度 $O(Tn^3)$。注意转移和构造的顺序。

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(int i=(a);i<=(b);++i)
#define Rof(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
const int Maxn=511;

inline int read()
{
    char ch=getchar();
    int f=1,x=0;
    while(ch>'9' || ch<'0')
    {
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}

int T,n,a[Maxn+5],s[Maxn+5];
int f[Maxn+5][Maxn+5],g[Maxn+5][Maxn+5],h[Maxn+5][Maxn+5];
int fk[Maxn+5][Maxn+5],gk[Maxn+5][Maxn+5],hk[Maxn+5][Maxn+5];
vector<array<int,3>> ans;

inline void Solve(int l,int r,int id)
{
    if(l==r) return;
    int d=fk[l][r],a=hk[l][s[r]^s[d-1]];
    int w=s[r]^s[d-1]^s[a]^s[l-1],b=gk[a+1][w],c=g[a+1][w];
    if(l==0) exit(0);
    Solve(d,r,id+(d-l)),Solve(b,c,id+(b-l)),Solve(l,a,id);
    ans.push_back({id,id+(b-l)-(a-l),id+(d-l)-(a-l)-(c-b)});
}
inline void Solve()
{
    n=read(); For(i,1,n) a[i]=read(),s[i]=s[i-1]^a[i];
    memset(f,0,sizeof(f));
    For(i,1,n+1) For(j,0,Maxn) g[i][j]=h[i][j]=n+1;
    Rof(l,n,1)
    {
        memcpy(g[l],g[l+1],sizeof(g[l+1]));
        memcpy(gk[l],gk[l+1],sizeof(gk[l+1]));
        f[l][l]=1,g[l][a[l]]=l,gk[l][a[l]]=l;
        For(i,0,Maxn) if(g[l+1][i]<h[l][a[l]^i])
            h[l][a[l]^i]=g[l+1][i],hk[l][a[l]^i]=l;
        For(r,l+1,n)
        {
            For(k,l+1,r) if(f[k][r] && h[l][s[r]^s[k-1]]<k) {f[l][r]=1,fk[l][r]=k; break;}
            if(f[l][r])
            {
                int w=s[r]^s[l-1]; if(g[l][w]>r) g[l][w]=r,gk[l][w]=l;
                For(i,0,Maxn) if(g[r+1][i]<h[l][w^i])
                    h[l][w^i]=g[r+1][i],hk[l][w^i]=r;
            }
        }
    }
    if(!f[1][n]) {printf("Shuiniao\n"); return;}
    printf("Huoyu\n"),Solve(1,n,1);
    cout<<ans.size()<<endl;
    for(auto i:ans) printf("%d %d %d\n",i[0],i[1],i[2]);
    ans.clear();
}

int main()
{
    T=read();
    while(T--) Solve();
    return 0;
}
```



---

## 作者：include13_fAKe (赞：8)

## Part 1 本题考点分析
本题需要用区间 dp 解决异或问题。各档部分分考点分别如下（此表仅为我的一家之言，有不同意者可以私信我）：
$$\begin{Vmatrix}
 测试点编号 & 考点\\
 \color{red}{1\sim2} & \color{red}{\text{【2】输入输出语句}}\\
 \\
 3\sim5 & \text{【2】位运算}\\
 \\
 \color{red}{6\sim7} & \begin{matrix}
 \color{red}\text{【2】位运算}\\
\color{red}\text{【4】动态规划的基本思路}\\
\color{red}\text{【5】简单区间类型动态规划}
\end{matrix}\\
\\
 8\sim9 & \begin{matrix}
\text{【2】位运算} \\
\text{【5】简单区间类型动态规划} 

\end{matrix}\\
\\
 \color{red}10\sim11 & 
\begin{matrix}
\color{red}【2】位运算 \\
\color{red}\text{【5】简单区间类型动态规划} 
\end{matrix}\\\\
 12\sim13 & \begin{matrix}
\text{【2】位运算} \\
\text{【5】简单区间类型动态规划} \\
\text{【8】动态规划的常用优化}
\end{matrix}\\\\
 \color{red}14\sim15 & \begin{matrix}
\color{red}\text{【2】位运算} \\
\color{red}\text{【5】简单区间类型动态规划} \\
\color{red}\text{【8】动态规划的常用优化}
\end{matrix}\\\\
16\sim17 & \begin{matrix}
\text{【2】位运算} \\
\text{【5】简单区间类型动态规划} \\
\text{【8】动态规划的常用优化}
\end{matrix}\\\\
 \color{red}18\sim20 & \begin{matrix}
\color{red}\text{【2】位运算} \\
\color{red}\text{【5】简单区间类型动态规划} \\
\color{red}\text{【8】动态规划的常用优化}
\end{matrix}\\
\end{Vmatrix}$$

## Part 2 解法
### $n\le2$
对于 $n=1$ 的每一组数据，直接输出 `Huoyu`，**注意后面要跟一个次数 $0$**。

对于 $n=2$ 的情况，直接输出 `Shuiniao` 即可。

这 $10$ 分大概是**提高三等奖**的要求。

### $n\le5$
$n=3$ 时，直接看三个数的异或和是否为 $0$ 即可。

$n=4$ 时，枚举中间两个数和第一个数和最后一个数的异或和即可。

$n=5$ 的情况略复杂一些。既要像 $n=4$ 时那样枚举，还要看看有没有用两次 $n=3$ 的方法消除的情况（两次 $n=3$ 的例子如第一个样例的第一组数据）。

前 $25$ 分大概是**提高二等奖**的要求。

[$25$ 分的代码实现](https://www.luogu.com.cn/record/165634788)
### $n\le40$

出题人在这儿放了一组大样例，说明这应该是一档有一定象征意义的部分分。这大概是**提高一等**的要求吧。

或许我们能够想到一个 $O(n^6)$ 的做法：设 $f_{l,r}$ 表示区间 $[l,r]$ 能否消除成一个点。

$f_{l,r}=1$ 说明这段区间能被消除成一个点。

转移需要三段区间：$[l1,r1]$、$[l2,r2]$、$[l3,r3]$，需要满足 $l1\le r1<l2 \le r2<l3\le r3$。

$f_{l1,r3}$ 的转移需要满足 $f_{l1,r1}=f_{l2,r2}=f_{l3,r3}=1$，且三段区间的异或和为 $0$。

直接开结构体储存每一次转移的 $l1,r1,l2,r2,l3,r3$ 即可。

最后搞一个递推就过去了。

因为在转移过程中需要满足 $l1\le r1<l2 \le r2<l3\le r3$，所以很多状态都不会被搜到， $O(Tn^6)$ 的时间复杂度是稳过的。

至此我们已经得到了 $35$ 分。

[$35$ 分的代码实现](https://www.luogu.com.cn/record/166495012)
### $n\le130$
考虑优化成 $O(n^4)$。

是不是有 $O(n^5)$ 的做法可以过 $n\le70$ 的？

考虑开 $f'_{l,r,k}$ 的数组。当存在左端点 $\le l$ 且右端点 $\ge r$ 且异或和为 $k$ 的子段时，$f'_{l,r,k}=1$。

直接枚举 $l1,r1,l3,r3$，然后看看是否 $f'_{r1+1,l3-1,k}=1$，即可转移。其中 $k$ 是第一段和第三段区间的异或和，也是第二段区间的异或和。

能过的原因在 $n\le40$ 时就已经讲了。

[$55$ 的代码实现](https://www.luogu.com.cn/record/168103706)

估计这一档能过大概是**弱省省队**水平吧。

但怎么大家乱搞都得了 $50+$ 啊？~~不捆绑测试的后果，数据太水了。~~
### $85$ 分的做法
不知道满足测试点 $12\sim13$ 的限制的大样例针对的是不是这种做法。

设 $g_{l,k}$ 表示左端点 $\ge l$ 且异或和 $=k$ 的区间的最小右端点所对应的区间。

再设 $h_{l1,k}$ 表示异或和为 $k$ 的 $[l1,r1]$ 和 $[l2,r2]$ 中最小的 $r2$ 对应的 $l1$、$l2$、$r1$、$r2$。

$g$ 可以从右往左转移。所以，我们从这里开始就应该**先枚举 $l1$，从右往左**。

$h$ 的转移可以利用 $g$ 的结果来确定第二个区间的左右端点。

此算法是 $O(n^3)$ 的，但是常数较大，无法通过最后三个点。

~~会不会这就是为什么最初的 PDF 上写的时限是 $3$ 秒，后面改成 $1$ 秒的原因呢？~~

[$85$ 分代码的实现](https://www.luogu.com.cn/record/169541888)

好多大佬都止步于此了，遗憾。

### 正解
不再使用结构体存储答案，可以减小常数。

这里使用了 Graphcity 老师的思路，膜拜！

设 $f1_{l,r}$ 表示 $f_{l,r}$ 转移的 $d$，$g1_{l,k}$ 代表 $g_{l,k}$ 中的左端点，$h1_{l,k}$ 代表 $h_{l,k}$ 转移中的 $a$（是不是记录转移中的 $b$ 也可以呢？）。

然后就可以倒推了。

[正解代码的实现](https://www.luogu.com.cn/record/169941983)

## Part 3 一点小碎碎念
笔者赛时 T1 只会 $10$ 分，那我如果来看了这个题，分会不会好看很多呢？

其实，这个题的代码还是没有那么简单，从写 $25$ 分到写出正解，一共 $20$ 天时间，一共交了 $100$ 次以上才 AC。

---

## 作者：天命之路 (赞：5)

Update:

1. 修改了一处笔误
2. 将最后的吐槽由 $n^4$ 改为了 $n^7$，因为有复杂度上界 $n^6$ 的记搜通过了本题。

一道很好的区间  DP 题，如果能不那么卡常就更好了。/fn

下文设 $Q(a,b)$ 表示区间 $[a,b]$ 的异或和，并认为 $n$ 和值域 $V$ 同阶。

首先观察这个合并操作在干什么，发现每个时刻，序列中的数其实都对应着原序列的一段区间，这个数的值就是原序列上这段区间的异或和。而一次合并操作，相当于把相邻的若干个区间合并为一个区间。我们不妨建出一棵树，树上一个节点是一个区间，它的儿子是对它进行操作后合并起来的所有区间。树上的所有区间相互包含或不交，这启发我们使用区间 DP 刻画这棵树。

设 $dp_{i,j}$ 表示区间 $[i,j]$ 能否被缩为一个数，转移则枚举 $i \le a < b \le c < d \le j$，如果 $dp_{i,a},dp_{b,c},dp_{d,j}$ 都为真，且这三段的异或和为 $0$，那么 $dp_{i,j}$ 也为真。如何输出方案？我们考虑把那棵树建出来，即由区间 $ [i,j]$ 向 $[i,a],[b,c],[d,j]$ 连边，输出方案时一边 DFS，一边维护每个原序列中的位置在当前序列中的位置。DFS 时先递归儿子，再做自己代表的操作即可。

上述做法的 DP 是 $O(n^6)$ 的。如何优化？

初步想法是设 $p_{i,j,v}$ 表示是否存在 $i \le a \le b \le j$ 使得 $dp_{a,b}$ 为真且 $Q(a,b) = v$。求 $dp$ 数组时就只需要枚举 $a$ 和 $d$ 了。求 $p$ 数组时，只需让 $p_{i,j,v}$ 从 $p_{i+1,j,v}$ 和 $p_{i,j-1,v}$ 转移，再看区间 $[i,j]$是否能更新 $p$ 即可。这样 DP 可以做到 $O(n^4)$。已经能拿到比较可观的分数。

基于此还可以想到设 $q_{i,j,v}$ 表示是否存在 $i \le a < b \le c \le j$ 满足 $Q(i,a) \operatorname{xor} Q(b,c) = v$，且 $dp_{i,a}$ 和 $dp_{b,c}$ 均为真。这样，虽然可以 $O(n^3)$ 求出 DP 数组，但是 $q$ 数组本身的维护就是 $O(n^4)$ 的。

上述做法更大的问题是，空间复杂度是 $O(n^3)$ 的。

我们发现 $p$ 和 $q$ 只是在维护可行性而已，$i$ 和 $j$ 的限制又不是很严，这启发我们不去记录对于某个 $(i,j,v)$ 的可行性，而是直接记录使得 $p_{i,j,v}$ 为真的最小的 $j$！

于是我们重新定义 $p$ 数组和 $q$ 数组。设 $p_{i,v}$ 表示使得原来 $p_{i,j,v}$ 为真的最小的 $j$，$q_{i,v}$ 同理。那么，假设我们此时知道一个区间 $[a,b]$ 的 DP 值为真，如何更新 $p$ 和 $q$？我们只需枚举 $i \in [1,a]$，将 $p_{i,Q(a,b)}$ 与 $b$ 取 $\min$ 即可。至于 $q$ 数组，我们枚举 $w \in [0,V]$，用 $p_{b + 1,w}$ 来更新 $q_{a,w \operatorname{xor} Q(a,b)}$ 即可。

注意在这题中，区间 DP 的转移顺序应该是倒序枚举左端点，然后正序枚举右端点，而非像一般的区间 DP 一样先枚举区间长度。因为本题中 $p$ 和 $q$ 的转移依赖于在其右边的 $dp$ 和 $p$，跟区间长度没有什么关系，所以要用这种顺序保证转移正确。

注意，由于本题要输出方案，$p$ 数组和 $q$ 数组也要记录方案。

于是本题就做完了，时间复杂度 $O(Tn^3)$，空间复杂度 $O(n^2)$。

顺便吐糟一句：不知道出题人放 $T \le 20$ 有什么意义，难道把 $T$ 出小了还能把 $n^7$ 放过去吗。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;
typedef pair<int,pii> State;
typedef array<int,3> Ar3;
typedef pair<int,array<int,2> > St2;
typedef unsigned short u16;
#define FI first
#define SE second
#define mkp make_pair
const int N = 5e2 + 5,Sz = 512;
template<typename T> inline void ckmin(T &x,const T &y) { if(y.FI < x.FI) x = y;}
template<typename T> inline void ckmax(T &x,const T &y) { if(x.FI < y.FI) x = y;}
int n,a[N],m;
bool dp[N][N];
u16 rlen[N][N];
u16 xsum[N];
inline int Id(int i,int j) { return (i - 1) * n + j - 1;}
inline pii Revid(int x) { return mkp(x / n + 1,x % n + 1);}
inline u16 Qxor(const u16 &l,const u16 &r) { return xsum[r] ^ xsum[l - 1];}
vector<int> G[N * N];
u16 pos[N];
vector<tuple<u16,u16,u16> > Ans;
void dfs(int x) {
	int L,R;
	std::tie(L,R) = Revid(x);
	if(L == R) return;
	for(auto y : G[x]) dfs(y);
	Ans.emplace_back(pos[Revid(G[x][0]).FI],pos[Revid(G[x][1]).FI],pos[Revid(G[x][2]).FI]);
	for(int i = R + 1;i <= n;i++) pos[i] -= rlen[L][R];
}
pair<u16,u16> pk1[N][Sz];
pair<u16,u16> pk3[N][Sz];
vector<int> usd[N];
inline void Trans(u16 i,u16 j) {
	auto Giv = [&](const u16 &a,const u16 &b,const u16 &c,const u16 &d) {
			G[Id(i,j)].push_back(Id(i,a));
			G[Id(i,j)].push_back(Id(b,c));
			G[Id(i,j)].push_back(Id(d,j));
			rlen[i][j] = b - a - 1 + d - c - 1 + 2;
			dp[i][j] = true;usd[j].push_back(i);
	};
	// for(u16 d = i + 2;d <= j;d++) 
	for(auto d : usd[j])
		if(d >= i && dp[d][j] && pk3[i][Qxor(d,j)].FI < d) {
			u16 a = pk3[i][Qxor(d,j)].SE;
			u16 b,c;std::tie(c,b) = pk1[a+1][Qxor(d,j) ^ Qxor(i,a)];
			Giv(a,b,c,d);
			return;
		}
		
}
inline void Update(u16 st) {
	for(u16 len = 1;len + st - 1 <= n;len++) {
		u16 ed = st + len - 1;
		Trans(st,ed);
		if(dp[st][ed]) {
			u16 val = Qxor(st,ed);
			ckmin(pk1[st][val],mkp(ed,st));
			for(u16 i = 1;i <= st;i++) 
				ckmin(pk1[i][val],mkp(ed,st));
			if(ed < n)
			for(u16 v = 0;v <= m;v++)  
				ckmin(pk3[st][val ^ v],mkp(pk1[ed + 1][v].FI,ed));
			
		}
	}
}

inline void work() {
	cin >> n;m = 0;
	for(u16 i = 1;i <= n;i++) cin >> a[i],xsum[i] = xsum[i - 1] ^ a[i],m = max(m,a[i]);
	m = 1 << __lg(m) + 1;
	for(u16 i = 1;i <= n;i++) usd[i].clear();
	for(u16 i = 1;i <= n;i++) 
		for(u16 j = i;j <= n;j++) 
			dp[i][j] = 0,G[Id(i,j)].clear();
	for(u16 i = 1;i <= n;i++)
		for(u16 v = 0;v <= m;v++)
			pk1[i][v] = mkp(1e9,0),pk3[i][v] = mkp(1e9,0);

	for(u16 i = 1;i <= n;i++) dp[i][i] = 1,usd[i].push_back(i);
	for(u16 i = n;i >= 1;i--) Update(i);
	// cerr << "clock:" << 1.0 * clock() / CLOCKS_PER_SEC << endl;

	if(!dp[1][n]) return puts("Shuiniao"),void();
	puts("Huoyu");
	for(u16 i = 1;i <= n;i++) pos[i] = i;
	Ans.clear();
	dfs(Id(1,n));
	cout << Ans.size() << endl;
	// printf("%d\n",(int)Ans.size());
	for(auto [x,y,z] : Ans)
		cout << x << ' ' << y << ' ' << z << endl;
		// printf("%d %d %d\n",x,y,z);
	cerr << "clock:" << 1.0 * clock() / CLOCKS_PER_SEC << endl;

}
int main() {
	freopen("tmp.in","r",stdin);
	freopen("tmp.out","w",stdout);
	// ios::sync_with_stdio(false);
	// cin.tie(0);cout.tie(0);
	int T;
	cin >> T;
	while(T--) work();
	return 0;
}
/*
1
5
68 33 188 32 100

Huoyu
1
1 4 5
*/
```



---

## 作者：ykzzldz (赞：2)

分析题目可以发现，最后数列中的每个数一定都是原数列中一段数的异或值，我们用 $w(l,r)$ 表示区间 $[l,r]$ 的异或值，且对于复杂度的分析均认为值域与 $n$ 同阶。

知道上面的内容后，可以简单地写出一个 $O(n^6)$ 的做法，设 $dp_{i,j}=0/1$ 表示区间 $[i,j]$ 能不能合并成一个数，转移时枚举 $p1,p2,p3,p4$ 判断是否有 $w(i,p1)\oplus w(p2,p3)\oplus w(p4,j)=0$ 且 $dp_{i,p1}=dp_{p2,p3}=dp_{p4,j}=1$ 即可，期望得分 $35$ 分。

考虑减少枚举量，设 $f_{l,r,v}=0/1$ 表示 $[l,r]$ 是否有子区间合法且区间异或值为 $v$，初始化 $f_{l,r,w(l,r)}=1$，转移时 $f_{l,r,v}|=f_{l+1,r,v}|f_{l,r-1,v}$。这样，我们只需要枚举 $l,p1,p4,r$ 四个点即可，复杂度 $O(n^4)$，期望得分 $55$ 分。

我们发现，上面的做法连空间都会出问题，且 $f$ 只存了 $0/1$，稍显浪费。我们考虑重新定义 $f_{l,v}$ 表示满足上述条件的最小的 $r$。新定义 $g_{l,v}$ 表示存在 $l\le a<b\le c$ 且 $w(l,a)\oplus w(b,c)=v$ 的最小的 $c$。对于一段合法的区间 $[a,b]$，转移时枚举 $l\le a$，$f_{l,w(a,b)}=\min(f_{l,w(a,b)},b)$。$g$ 的转移枚举 $v$，$g_{i,w(a,b)\oplus v}=\min(g_{i,w(a,b)\oplus v},f_{b+1,v})$。对于 $dp$ 的转移枚举 $v$，$dp_{l,r}|=[f_{g_{l,v},v}\le r]$，即可 $O(n^3)$ 转移。

---

## 作者：SentoAyaka (赞：2)

先考虑一个 $O(n^6)$ 的方法：设 $f_{l,r}$ 表示 $[l,r]$ 是否能合成一个点，转移考虑枚举 $[l,a],[b,c],[d,r]$ 满足三个区间均合法且异或和为 $0$。

考虑优化，设 $f1_{l,r,x,0/1}$ 表示在 $[l,r]$ 区间内，是否存在合法的 $[l,a]$ 或 $[l,a],[b,c]$ 使其异或和为 $x$。通过中间变量 $f1$ 可以优化至 $O(n^3a)$。

接着优化，发现对于 $f1_{l,r,x,1}$ 我们只用记录在确定 $l,x$ 下的最小 $r$ 即可，于是设 $h_{l,x,0/1}$ 表示从 $l$ 开始，合法的   $[l,a]$  或 $[l,a],[b,c]$ 使其异或和为 $x$ 中最小的 $a$ 或 $c$。考虑怎么通过 $h_{l,x,0}$ 转移到 $h_{l,x,1}$。

我们再设中间变量 $g_{l,x}$ 表示左端点 $\ge l$ 中且区间异或后为 $x$ 的最小端点，可以通过 $g_{h_{l,a,0}+1,b}$ 转移到 $h_{l,a\oplus b,1}$。

思考一下我们的转移，对于 $g$ 的转移依赖于后面的 $l$，于是从后往前枚举 $l$，继承之前的 $g$，判断新的 $f_{l,r}$ 并依此更新 $h_{l,x,0},g_{l,x},h_{l,x,1}$。复杂度 $O(n^3)$。

没有卡常就过了。

```cpp
#include<bits/stdc++.h>
#define db double
// #define int ll
#define ll long long
#define ull unsigned long long
#define pb emplace_back
#define MP make_pair
#define pii pair<int, int>
#define vec vector<int>
#define fi first
#define se second
#define ls k<<1
#define rs k<<1|1
#define CLK (double)clock()/(double)CLOCKS_PER_SEC
using namespace std;
mt19937 rnd(time(0));
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
inline void write(int x){
    if(x<0){putchar('-');x=-x;}
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
const int N=505,M=515,inf=1e9;
int n,lim=512,a[N],f[N][N],h[2][N][M],g[N][M];
int pos[N],pf[N][N],ph[N][M];pii pg[N][M];
inline bool chkmin(int &x,int y){if(x>y)return x=y,1;else return 0;}
inline int calc(int l,int r){return a[r]^a[l-1];}
inline void upd(int l,int r){
    int a=calc(l,r);
    if(chkmin(g[l][a],r))pg[l][a]=MP(l,r);
    if(chkmin(h[0][l][a],r)){
        if(r==n)return ;
        for(int b=0;b<lim;b++){
            if(chkmin(h[1][l][a^b],g[h[0][l][a]+1][b]))
                ph[l][a^b]=h[0][l][a];
        }
    }
}
inline void clear(){
    for(int i=1;i<=n;i++)pos[i]=i;
    for(int i=1;i<=n;i++)for(int j=i;j<=n;j++)f[i][j]=0;
    for(int i=1;i<=n;i++)for(int a=0;a<lim;a++)g[i][a]=h[0][i][a]=h[1][i][a]=n+1;
}
vector<array<int,3>>ans;
inline void print(int l,int r){
    if(l==r)return ;
    int d=pf[l][r],C=calc(d,r);
    int a=ph[l][C],A=calc(l,a);pii t=pg[a+1][C^A];
    int b=t.fi,c=t.se;
    print(l,a),print(b,c),print(d,r);
    ans.push_back({pos[l],pos[b],pos[d]});
    int del=b-a+d-c;
    for(int i=r+1;i<=n;i++)pos[i]-=del;
}
void MAIN(){
    n=read();clear();
    for(int i=1;i<=n;i++)a[i]=read()^a[i-1],f[i][i]=1;
    for(int l=n;l>=1;l--){
        if(l<n)for(int a=0;a<lim;a++)g[l][a]=g[l+1][a],pg[l][a]=pg[l+1][a];
        upd(l,l);
        for(int r=l+2;r<=n;r++){
            for(int i=l+2;i<=r;i++)if(f[i][r]){
                int a=calc(i,r);
                if(h[1][l][a]<i){f[l][r]=1,pf[l][r]=i,upd(l,r);break;}
            }
        }
    }
    if(f[1][n]){
        puts("Huoyu");print(1,n);
        cout<<ans.size()<<"\n";
        for(auto i:ans)cout<<i[0]<<' '<<i[1]<<' '<<i[2]<<"\n";
        ans.clear();
    }
    else puts("Shuiniao");
}
signed main(){
//    freopen("read.in","r",stdin);
//	freopen("write.out","w",stdout);
    int T=read();while(T--)MAIN();
//  printf("\nTIME:%lf\n",(double)clock()/CLOCKS_PER_SEC);
    return 0;
}

```


---

## 作者：Vidoliga (赞：0)

一般。

区间 dp，$f_{i,j}$ 表示这个区间的数可否被操作到只剩一个数。

转移枚举 $3$ 个子区间表示这三个区间合并后的数作为选择的 $i,j,k$。

可以容易做到 $O(Tn^6)$。

设 $w(l,r)$ 表示 $[l,r]$ 的异或和。

考虑优化，设:

$g_{l,x}= \mathrm {arg}\min\limits_{r \geq l} \{ \exists p<k,p,k\in[l,r) ,f_{l,k}\ \mathrm{and} \ f_{k,r} \  \mathrm{and}\ ( w(l,k) \ \mathrm{xor}\ w(p,r) =x )\}$

可得：

$f_{l,r}= \mathrm{or} _{i=l+1}^{r} \{ [g_{l,s_r \ \mathrm{xor} \ s_{i-1}}<i] \}$

求 $g$ 不好求，考虑继续优化：

设 $h_{l,x}= \mathrm {arg}\min\limits_{r \geq l} \{ f_{l,r} \ \mathrm{and}\ w(l,r)=x \},q_{l,x}=\min\limits_{k \geq l} \{ h_{k,x}\}$。

对于 $h,q$ 是好求的，考虑如何求 $g$：

$g_{l,x}=\min\limits_{s=0}^{2^9-1}\{q_{h_{l,s}+1,s \ \mathrm{xor} \ x} \}$

上述所有都是容易求解的，复杂度 $O(Tn^2A)$。

构造方案直接在 dp 的时候记录是从哪里转移的即可。

最后直接递归求解方案。

Code：

```cpp
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2")
#pragma GCC optimize("Ofast","unroll-loops","inline")
#include<bits/stdc++.h>
#define ll long long
//#define int ll
#define pb push_back 
#define i16 unsigned short
using namespace std;
const int N=5e2+20,Mx=512;
bool f[N][N];i16 n,a[N],s[N],h[N][N],q[N][N],g[N][N],pg[N][N],pf[N][N];
struct node{int p1,p2,p3;};
vector<node> ans;
i16 calc(i16 l,i16 r,i16 d){
	if(l==r) return 0;
	i16 R=pf[l][r];i16 L=pg[l][s[r]^s[R-1]];
	i16 S=0,T=0,u=s[r]^s[R-1]^s[L]^s[l-1];
	for(S=L+1;S<R;S++){
		for(T=S;T<R;T++) if(f[S][T]&&((s[T]^s[S-1])==u)) break;
		if(T<R&&f[S][T]&&((s[T]^s[S-1])==u)) break;
	}
	i16 p1=0,p2=0,p3=0,res=0;
	p1=l-d;res+=calc(l,L,d),d+=L-l;
	p2=S-d;res+=calc(S,T,d),d+=T-S;
	p3=R-d;res+=calc(R,r,d),d+=r-R;
	ans.pb((node){p1,p2,p3});
	return res+1;
}
void solve(){
	cin>>n;ans.clear();
	s[0]=0;for(int i=1;i<=n;i++) cin>>a[i],s[i]=s[i-1]^a[i];
	for(int i=1;i<=n;i++) for(int j=i+1;j<=n;j++) f[i][j]=0;
	for(int i=1;i<=n+1;i++) for(int j=0;j<Mx;j++) h[i][j]=q[i][j]=g[i][j]=n+1,pg[i][j]=pf[i][j]=0;
	for(int l=n;l;l--){
		for(int x=0;x<Mx;x++) q[l][x]=q[l+1][x];
		for(int r=l;r<=n;r++){
			if(l==r) f[l][r]=1;
			else{
				for(int i=l+1;i<=r;i++){
					if(f[l][r]) break;
					if(f[i][r]&&g[l][s[r]^s[i-1]]<i) f[l][r]=1,pf[l][r]=i;
				}
			}
			if(f[l][r]){
				i16 w=s[r]^s[l-1],lst=h[l][w];
				h[l][w]=min(h[l][w],(i16)r);
				q[l][w]=min(h[l][w],q[l][w]);
				if(lst==n+1) for(int x=0;x<Mx;x++){
					if(h[l][w]<g[l][x]&&q[h[l][w]+1][w^x]<g[l][x]) g[l][x]=q[h[l][w]+1][w^x],pg[l][x]=h[l][w];
				}
			}
		}
	}
	if(!f[1][n]) return cout<<"Shuiniao\n",void();
	cout<<"Huoyu\n";cout<<calc(1,n,0)<<'\n';
	for(node v:ans) cout<<v.p1<<' '<<v.p2<<' '<<v.p3<<'\n';
}
signed main(){
//	freopen("merge2.in","r",stdin);
//	freopen("merge.out","w",stdout);
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	int T;cin>>T;
	while(T--) solve();
	return 0;
}
```


---


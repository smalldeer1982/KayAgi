# [SCOI2013] 摩托车交易

## 题目描述

mzry1992 在打完吊针出院之后，买了辆新摩托车，开始了在周边城市的黄金运送生意。在 mzry1992 生活的地方，城市之间是用双向高速公路连接的。另外，每条高速公路有一个载重上限，即在不考虑驾驶员和摩托车重量的情况下，如果所载货物的量超过某个值，则不能驶上该条高速公路。

今年，mzry1992 一共收到了来自 $n$ 个不同城市的 $n$ 份定订单，每个订单要求卖出上限为一定量的黄金，或是要求买入上限为一定量的黄金。由于订单并不是同时发来的，为了维护生意上的名声，mzry1992 不得不按照订单发来的顺序与客户进行交易。他与第i 个客户进行交易的具体步骤是：

1. 前往第 $i$ 个客户所在城市。当然，中途是完全允许经过其他城市的。 
2. 与第 $i$ 个客户进行交易，在此过程中他希望有限制的让交易额尽量大。具体的限制有两个：    
(a) 他希望与最后一个客户完成交易后，手上没有剩余黄金。  
(b) 由于黄金是很贵重的物品，不能出现因为买入过多黄金而造成在以后的运送过程中不得不丢弃黄金的情况。

一开始，mzry1992 位于第一个订单客户所在的城市。现在有一个好消息，有人提供了 mzry1992 免费试用周边城市的列车系统的资格。具体来讲，如果mzry1992希望从 $A$ 城市到达 $B$ 城市，且 $A$、$B$ 城市均有列车站的话，他可以携带着黄金与摩托车从 $A$ 城市乘坐列车到 $B$ 城市，这里假定乘坐列车没有载重限制。

现在已知城市间的交通系统情况和订单情况，请帮助 mzry1992 计算每个向 mzry1992 购买黄金的客户的购买量。


## 说明/提示

### 样例解释

第一组样例：其中一种合法的方案是最初从 $2$ 号城市买入 $5$ 单位的黄金，先走第三条高速公路到 $1$ 号城市，然后再坐列车到 $3$ 号城市，在 $3$ 号城市卖出 $3$ 单位的黄金，然后乘坐列车到 $1$ 城市，在 $1$ 号城市卖出 $2$ 单位的黄金。


第二组样例：其中一种合法的方案是最初从 $1$ 号城市买入 $4$ 单位的黄金，走第一条高速公路，在 $2$ 号城市买入 $3$ 单位的黄金，走第二条高速公路，在三城市点卖出 $6$ 单位的黄金，走第三条高速公路，在 $4$ 号城市卖出 $1$ 单位的黄金。

### 数据范围与约定

- 对于 $20\%$ 数据，$n \le 100$，$m \le 200$。
- 对于 $50\%$ 数据，$n \le 3000$，$m \le 6000$。
- 对于 $100\%$ 数据，$1 \le n \le 10^5$，$n - 1 \le m \le 2\times 10^5$，$0 \le q \le n$，$0 < |b_i| < 10^9$，$0 < w < 10^9$，保证任意两个城市之间是通过高速公路连通的。


## 样例 #1

### 输入

```
3 3 2
2 3 1
-6 5 -3
1 3 5
2 3 2
2 1 6
1 3
```

### 输出

```
3
2

```

## 样例 #2

### 输入

```
4 4 0
1 2 3 4
5 4 -6 -1
1 2 4
2 3 100
3 4 1
4 1 4```

### 输出

```
6
1 
```

# 题解

## 作者：Azazеl (赞：7)

### P3280 [SCOI2013]摩托车交易



---

#### 题意

> $~~~~$ 给出需要拜访的城市的顺序，每个城市可以买入或卖出给定最大值以内的数量的金条。有两种道路，一种上面限制携带的金条个数，另一种不限制。在每个城市的买入或卖出的金条尽量最大，求每次卖出的金条个数值。

---

#### 题解  

$~~~~$ 其实我写的题意已经把这题简化了。  

$~~~~$ 先来看两个限制怎么解决，由于买入的时候不需要输出，其实我们完全可以全部买下来，然后在路上丢掉。（其实丢掉多少就是少买多少）所以直接忽略限制（b） 即可。然后你会发现限制（a）也可以用这样的方法忽略掉，所以我们每次买入直接全买就可以了。~~所以这两个限制完全就是来干扰的。~~

$~~~~$ 再来看剩下的部分，两种道路，有限制时我们可以想到 [P1967 货车运输](https://www.luogu.com.cn/problem/P1967 "路径上权值最小值最大") ，用 Kruskal重构树 将权值从大到小排序即可。至于没有限制时，我们完全可以转化为其限制为无限大（本题的 $INF$ 开到  $10^9$ 即可），那就又变成第一种了。  

$~~~~$ 所以这道题就解决了。注意数组要开够大，有时候它不够会爆 `WA` 而不是 `RE`. 

---

#### 代码

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#define ll long long
using namespace std;
const ll INF=1e18;
ll n,m,p;
ll tot,fa[400005],order[400005],gold[400005];
vector <ll> G[400005]; 
struct Edge{
	ll u,v;
	ll w;
	Edge(){}
	Edge(ll U,ll V,ll W){u=U,v=V,w=W;}
}E[600005];
ll findSet(ll x)
{
	if(fa[x]==x) return x;
	else return fa[x]=findSet(fa[x]);
}
void Kru()
{
	ll cnt=0;
	for(ll i=1;i<=m+max(p,1ll)-1;i++)
	{
		ll u=E[i].u,v=E[i].v,w=E[i].w;
		u=findSet(u),v=findSet(v);
		if(u!=v)
		{
			tot++;cnt++;
			gold[tot]=w;
			G[u].push_back(tot); G[tot].push_back(u); fa[u]=tot;
			G[v].push_back(tot); G[tot].push_back(v); fa[v]=tot;
		}
		if(cnt==n-1) return;
	}
}
inline bool cmp(Edge x,Edge y){return x.w>y.w;}
ll dep[400005],f[400005][20],lg[400005];
void dfs(ll u,ll fat)
{
	dep[u]=dep[fat]+1;
	f[u][0]=fat;
	for(ll i=1;i<=lg[dep[u]];i++) f[u][i]=f[f[u][i-1]][i-1];
	for(ll i=0;i<G[u].size();i++)
	{
		ll v=G[u][i];
		if(v==fat) continue;
		dfs(v,u);
	} 
}
ll query(ll x,ll y)
{
	if(dep[x]<dep[y]) swap(x,y);
	while(dep[x]>dep[y]) x=f[x][lg[dep[x]-dep[y]]-1];
	if(x==y) return gold[x];
	for(ll k=lg[dep[x]]-1;k>=0;k--)
	{
		if(f[x][k]!=f[y][k]) x=f[x][k],y=f[y][k];	
	}
	return gold[f[x][0]];
}
int main() {
	ll root;
	scanf("%lld %lld %lld",&n,&m,&p);
	for(ll i=1;i<=n;i++) fa[i]=i,lg[i]=lg[i-1]+(1<<lg[i-1]==i),scanf("%lld",&order[i]);	
	for(ll i=1;i<=n;i++) fa[i+n]=i+n,lg[i+n]=lg[i+n-1]+(1<<lg[i+n-1]==i+n),scanf("%lld",&gold[i]);
	for(ll i=1,u,v,w;i<=m;i++)
	{
		scanf("%lld %lld %lld",&u,&v,&w);
		E[i]=Edge(u,v,w);
	}
	if(p) scanf("%lld",&root);
	for(ll i=1,q;i<p;i++)
	{
		scanf("%lld",&q);
		E[m+i]=Edge(root,q,INF);
	}
	tot=n;
	sort(E+1,E+m+max(p,1ll),cmp);
	Kru();
	
	dfs(tot,0);
	
	ll now=gold[order[1]];
	if(now<=0) puts("0"),now=0;
	for(ll i=1;i<n;i++)
	{
		ll x=order[i],y=order[i+1];
		ll re=query(x,y);
		now=min(now,re);
		if(gold[y]>0) now+=gold[y];
		else
		{
			if(now+gold[y]>=0) printf("%lld\n",-gold[y]),now+=gold[y];
			else printf("%lld\n",now),now=0; 
		}
	}
	return 0;
} 
```

---

## 作者：欧鹰 (赞：6)

（日常聊天），不过也没什么好说的，还是推销一下[我的博客](https://www.luogu.org/blog/174026/)吧。还有谢谢之前给我题解点赞的各位大佬。

心灵鸡汤：如果你迷惘了，请不要放弃，你总能爬过那看似高大的山。（此生不悔学OI。）

------------
算法：树剖+最大生成树。

题意：依照题目所给的顺序，一个一个走城市，其实就是找到城市间路径最小的承重量。

------------
首先，我们先贪心一下，他不需要输出买了多少，也就是你可以尽量多买啦，然后因卖出多少而调整买了多少，这样条件a（~~他希望与最后一个客户完成交易后，手上没有剩余黄金~~）其实就不用考虑啦。

第一个思想，结束。

这样，我们每次卖出多少与买进来，其实就与我们下一次要走的路程最小值有关，所以为了，带的越多，我们就可以求一棵最大生成树（因为不用考虑路程多少。）

第二个思想结束。

代码如下。

```cpp
	for(int i=1;i<=n;i++) cin>>city[i];
	
	for(int i=1;i<=n;i++) cin>>shop[i];
	
	for(int i=1;i<=m;i++) cin>>road[i].x>>road[i].y>>road[i].w;
	
    //如果是列车，路程承重量即是无限大。把第一个列车点当做x，因为是双向边，谁当x也无所谓。
    
	if(q==1) cin>>wuliao;//一个列车站肯定很无聊。
	
	if(q>=2) cin>>road[m+1].x>>road[m+1].y;
	
	if(q>=2) road[m+1].w=maxx;
	
	for(int i=3+m;i<=q+m;i++) 
	{
		cin>>road[i-1].y;
		
		road[i-1].x=road[m+1].x;
		
		road[i-1].w=maxx;
	}
	
	for(int i=1;i<=n;i++) fa[i]=i;
	
	sort(road+1,road+q+m,cmp);
	
	for(int i=1;i<=q+m;i++)
	{
		int fax=find(fa[road[i].x]),fay=find(fa[road[i].y]);
		
		if(fax!=fay)
		{
			add(road[i].x,road[i].y,road[i].w);
			
			add(road[i].y,road[i].x,road[i].w);
			
			fa[fax]=fay;
			
			cnnt++;
			
			if(cnnt==n) break;
		}
	}
```

第三个思想，应该会树剖的就不用往下看啦。

即是树上找路径的最小值。很明显就是树剖，把路径值搞到儿子就可以，每次走路径就不用走LCA。

```cpp
void build(int u,int l,int r)
{
	if(l==r)
	{
		tree[u]=www[l];
		
		return;
	}
	
	int mid=(l+r)/2;
	
	build(u*2,l,mid);
	
	build(u*2+1,mid+1,r);
	
	tree[u]=min(tree[u*2],tree[u*2+1]);
}

int Query(int u,int l,int r,int x,int y)
{
	if(l>=x&&r<=y) return tree[u];
	
	int mid=(l+r)/2,ans=maxx;
	
	if(x<=mid) ans=min(ans,Query(u*2,l,mid,x,y));	
	
	if(y>mid) ans=min(ans,Query(u*2+1,mid+1,r,x,y));
	
	return ans;
}

int query(int x,int y)
{
	int ans=maxx;
	
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		
		ans=min(ans,Query(1,1,n,id[top[x]],id[x]));
		
		x=father[top[x]];
	}
	
	if(dep[x]>dep[y]) swap(x,y);
	
	ans=min(ans,Query(1,1,n,id[x]+1,id[y]));
	//cout<<x+1<<" "<<id[y]<<'\n';
	return ans;
}

void dfs1(int u,int fat,int deep)
{
	father[u]=fat;
	
	dep[u]=deep;
	
	size[u]=1;
	
	int maxson=-1;
	
	for(int i=head[u];i;i=a[i].u)
	{
		int v=a[i].v,w=a[i].w;
		
		if(v==fat) continue;
		
		dfs1(v,u,deep+1);
		
		size[u]+=size[v];
		
		ww[v]=w;
		
		if(size[v]>maxson)
		{
			son[u]=v;
			
			maxson=size[v];
		}
	}
}

void dfs2(int u,int topu)
{
	top[u]=topu;
	
	id[u]=++cnt;
	
	www[cnt]=ww[u];
	
	if(son[u]==0) return;
	
	dfs2(son[u],topu);
	
	for(int i=head[u];i;i=a[i].u)
	{
		int v=a[i].v;
		
		if(v==son[u]||v==father[u]) continue;
		
		dfs2(v,v);
	}
}
```

最后即是买最多的，卖最多的。

```cpp
	for(int i=1;i<n;i++)
	{
		
		if(shop[city[i]]>=0) anss=min(anss+shop[city[i]],query(city[i],city[i+1]));
		
		else 
		{	
			cout<<min(anss,-shop[city[i]])<<'\n';
			
			anss=max((int)0,anss+shop[city[i]]);
		
		    anss=min(anss,query(city[i],city[i+1]));
		}
		
		//cout<<"anss:"<<query(city[i],city[i+1])<<'\n';
	}
	
	if(shop[city[n]]<0) cout<<min(anss,-shop[city[n]])<<'\n';

```

下面是完整代码。

```cpp
#include<bits/stdc++.h>

#define int long long

using namespace std;

const int maxx=1e17+1000;

int head[300500],cntt,tree[1200500],www[300500],top[300500],dep[300500],n,fa[300500],father[300500];

int size[300500],son[300500],ww[300500],id[300500],m,q,city[300500],shop[300500],anss,wuliao,cnt,cnnt=1;

struct nod{
	int x,y,w;
}road[300500];

bool cmp(nod a,nod b)
{
	return a.w>b.w;
}

struct node{
	int u,v,w;
}a[300500];

void add(int u,int v,int w)
{
	a[++cntt].u=head[u];
	
	a[cntt].v=v;
	
	head[u]=cntt;
	
	a[cntt].w=w;
}

void build(int u,int l,int r)
{
	if(l==r)
	{
		tree[u]=www[l];
		
		return;
	}
	
	int mid=(l+r)/2;
	
	build(u*2,l,mid);
	
	build(u*2+1,mid+1,r);
	
	tree[u]=min(tree[u*2],tree[u*2+1]);
}

int Query(int u,int l,int r,int x,int y)
{
	if(l>=x&&r<=y) return tree[u];
	
	int mid=(l+r)/2,ans=maxx;
	
	if(x<=mid) ans=min(ans,Query(u*2,l,mid,x,y));	
	
	if(y>mid) ans=min(ans,Query(u*2+1,mid+1,r,x,y));
	
	return ans;
}

int query(int x,int y)
{
	int ans=maxx;
	
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		
		ans=min(ans,Query(1,1,n,id[top[x]],id[x]));
		
		x=father[top[x]];
	}
	
	if(dep[x]>dep[y]) swap(x,y);
	
	ans=min(ans,Query(1,1,n,id[x]+1,id[y]));
	//cout<<x+1<<" "<<id[y]<<'\n';
	return ans;
}

int find(int u)
{
	if(fa[u]==u) return u;
	
	else return fa[u]=find(fa[u]);
}

void dfs1(int u,int fat,int deep)
{
	father[u]=fat;
	
	dep[u]=deep;
	
	size[u]=1;
	
	int maxson=-1;
	
	for(int i=head[u];i;i=a[i].u)
	{
		int v=a[i].v,w=a[i].w;
		
		if(v==fat) continue;
		
		dfs1(v,u,deep+1);
		
		size[u]+=size[v];
		
		ww[v]=w;
		
		if(size[v]>maxson)
		{
			son[u]=v;
			
			maxson=size[v];
		}
	}
}

void dfs2(int u,int topu)
{
	top[u]=topu;
	
	id[u]=++cnt;
	
	www[cnt]=ww[u];
	
	if(son[u]==0) return;
	
	dfs2(son[u],topu);
	
	for(int i=head[u];i;i=a[i].u)
	{
		int v=a[i].v;
		
		if(v==son[u]||v==father[u]) continue;
		
		dfs2(v,v);
	}
}

signed main()
{
	cin>>n>>m>>q;
	
	for(int i=1;i<=n;i++) cin>>city[i];
	
	for(int i=1;i<=n;i++) cin>>shop[i];
	
	for(int i=1;i<=m;i++) cin>>road[i].x>>road[i].y>>road[i].w;
	
	if(q==1) cin>>wuliao;
	
	if(q>=2) cin>>road[m+1].x>>road[m+1].y;
	
	if(q>=2) road[m+1].w=maxx;
	
	for(int i=3+m;i<=q+m;i++) 
	{
		cin>>road[i-1].y;
		
		road[i-1].x=road[m+1].x;
		
		road[i-1].w=maxx;
	}
	
	for(int i=1;i<=n;i++) fa[i]=i;
	
	sort(road+1,road+q+m,cmp);
	
	for(int i=1;i<=q+m;i++)
	{
		int fax=find(fa[road[i].x]),fay=find(fa[road[i].y]);
		
		if(fax!=fay)
		{
			add(road[i].x,road[i].y,road[i].w);
			
			add(road[i].y,road[i].x,road[i].w);
			
			//cout<<road[i].x<<" "<<road[i].y<<'\n';
			
			fa[fax]=fay;
			
			cnnt++;
			
			if(cnnt==n) break;
		}
	}
	
	//ww[1]=maxx;
	
	dfs1(1,0,1);
	
	dfs2(1,1);
	
	build(1,1,n);
	
	//anss=shop[city[1]];
	
	for(int i=1;i<n;i++)
	{
		
		if(shop[city[i]]>=0) anss=min(anss+shop[city[i]],query(city[i],city[i+1]));
		
		else 
		{	
			cout<<min(anss,-shop[city[i]])<<'\n';
			
			anss=max((int)0,anss+shop[city[i]]);
		
		    anss=min(anss,query(city[i],city[i+1]));
		}
		
		//cout<<"anss:"<<query(city[i],city[i+1])<<'\n';
	}
	
	if(shop[city[n]]<0) cout<<min(anss,-shop[city[n]])<<'\n';
		
	return 0;
	
}
```

千万不要忘了卖出去之后走到下一个城市，也要看路径最小值。

---

## 作者：冷笑叹秋萧 (赞：4)

# 【SCOI2013】摩托车交易
## 下面给一个比较清楚一点的题面

mzry1992 在打完吊针出院之后，买了辆新摩托车，开始了在周边城市的黄金运送生意。

在 mzry1992 生活的地方，城市之间是用双向高速公路连接的，另外，每条高速公路有一个载重上限，即在不考虑驾驶员和摩托车重量的情况下，如果所载货物的量超过某个值，则不能驶上该条高速公路。

今年， mzry1992 一共收到了来自n 个不同城市的 n 份定订单，每个订单要求卖出上限为一定量的黄金，或是要求买入上限为一定量的黄金。由于订单并不是同时发来的，为了维护生意上的名声，mzry1992 不得不按照订单发来的顺序与客户进行交易。

他与第 i 个客户进行交易的具体步骤是：
1. 前往第 i 个客户所在城市。当然，中途是完全允许经过其他城市的。
2. 与第 i 个客户进行交易。
但有两个限制：

(a) 与最后一个客户完成交易后，手上没有剩余黄金。
(b) 由于黄金是很贵重的物品，不能出现因为买入过多黄金而造成在以后的运送过程中不得不丢弃黄金的情况。

mzry 希望总交易额最大，其次他希望卖出交易额序列的字典序最大。其中字典序指的是先比较第一次卖出交易额，若相等则比较下一次，以此类推。

一开始，mzry1992 位于第一个订单客户所在的城市。

现在有一个好消息，有人提供了mzry1992 免费试用周边城市的列车系统的资格。具体来讲，如果 mzry1992 希望从 A 城市到达 B 城市，且 A、B 城市均有列车站的话，他可以携带着黄金与摩托车从 A 城市乘坐列车到 B 城市，这里假定乘坐列车没有载重限制。

现在已知城市间的交通系统情况和订单情况，请帮助 mzry1992 计算每个向 mzry1992 购买黄金的客户的购买量。

## 题解
显然，这题的买卖黄金过程很用模拟就可以实现，关键是可以买卖多少

首先需要明确一点，就是我们不一定要按照题目说的不能丢弃黄金，其实可以全部买完，之后在过不去路的时候再丢掉，这样子是对答案没有影响的
然后买卖黄金的过程就相当于是一个贪心了，需要买的城市全部买来，需要卖的城市能卖多少卖多少

下一个重要点就是找到一个城市到另一个城市中负重最小的边（因为两个城市间可以携带的黄金的量是由负重最小的那条边决定的），然后因为要运尽量多黄金，所以我们就要让最小的那条边的负重最大

所以我们可以想到什么？最大生成树！

于是我们只要保留原图中属于最生成树的边即可（至于列车站怎么连边，其实只要相邻地连过来就行了，因为最后形成的是一棵树）
接着，要在树上找到路径边权的最小值就随便用什么方法找都行了，可以用求LCA的方式，我用的是倍增，大佬用树剖和 Tarjan 也行
## CODE

```cpp
#include<cstdio>
#include<string>
#include<cmath>
#include<algorithm>
#define max(a,b) (((a)>(b))?(a):(b))
#define min(a,b) (((a)<(b))?(a):(b))
#define swap(a,b) (a)^=(b)^=(a)^=(b)
#define R register ll
#define N 100005
#define M 300005
#define ll long long
#define inf 100000000000
using namespace std;
struct arr{ll u,v,w;}bian[M];
struct G{ll to,next,w;}e[N<<1];
ll n,m,q,go[N],train[N],tot,fa[N],cnt,f[N][20],dep[N],mxdep,head[N],b[N],g[N][20];;
inline void read(ll &x)
{
	x=0;ll f=1;char ch=getchar();
	while (!isdigit(ch)) {if (ch=='-') f=-1;ch=getchar();}
	while (isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();x*=f;
}
inline bool cmp(arr x,arr y) {return x.w>y.w;}
inline void add(ll u,ll v,ll len)
{
	e[++cnt].to=v;e[cnt].w=len;
	e[cnt].next=head[u];head[u]=cnt;
}
inline void dfs(ll u,ll fa)
{
	for (R i=head[u];i;i=e[i].next)
	{
		ll v=e[i].to;if (v==fa) continue;
		f[v][0]=u;g[v][0]=e[i].w;dep[v]=dep[u]+1;mxdep=max(dep[v],mxdep);dfs(v,u);
	}
}
inline ll lca(ll x,ll y)
{
	ll mn=inf;
	if (dep[x]!=dep[y])
	{
		if (dep[x]<dep[y]) swap(x,y);
		for (R i=log2(dep[x]-dep[y]);i>=0;--i)
			if (dep[f[x][i]]>dep[y]) mn=min(g[x][i],mn),x=f[x][i];
		mn=min(g[x][0],mn);x=f[x][0];	
	}
	if (x==y) return mn;
	for (R i=log2(dep[x]);i>=0;--i)
		if (f[x][i]!=f[y][i]) mn=min(mn,min(g[x][i],g[y][i])),x=f[x][i],y=f[y][i];
	mn=min(mn,min(g[x][0],g[y][0]));return mn; 
}
inline ll find(ll k)
{
	if (fa[k]==k) return k;return fa[k]=find(fa[k]);
}
int main()
{
	read(n);read(m);read(q);
	for (R i=1;i<=n;++i)
		read(go[i]),fa[i]=i;
	for (R i=1;i<=n;++i)
		read(b[i]);
	for (R i=1;i<=m;++i)
		read(bian[i].u),read(bian[i].v),read(bian[i].w);
	for (R i=1;i<=q;++i)
	{
		read(train[i]);
		if (i>1) bian[++m].u=train[i-1],bian[m].v=train[i],bian[m].w=inf;
	}
	sort(bian+1,bian+1+m,cmp);ll tot=1;
	for (R i=1;i<=m;++i)
	{
		ll f1=find(bian[i].u),f2=find(bian[i].v);
		if (f1!=f2)
		{
			add(bian[i].u,bian[i].v,bian[i].w);
			add(bian[i].v,bian[i].u,bian[i].w);
			++tot;fa[f1]=f2;if (tot==n) break;
		}
	}
	mxdep=1;dep[1]=1;dfs(1,0);
	for (R j=1;j<=log2(mxdep);++j)
		for (R i=1;i<=n;++i)
			f[i][j]=f[f[i][j-1]][j-1],g[i][j]=min(g[i][j-1],g[f[i][j-1]][j-1]);
	ll now=go[1];tot=0;
	if (b[go[1]]>0) tot=b[go[1]];else printf("0\n");
	for (R i=2;i<=n;++i)
	{
		ll k=lca(go[i-1],go[i]);
		if (tot>k) tot=k;
		if (b[go[i]]>0) tot+=b[go[i]];
		else
		{
			printf("%lld\n",min(-b[go[i]],tot));
			tot-=min(-b[go[i]],tot);
		}
	}
	return 0;
}
```


---

## 作者：TEoS (赞：4)

本文同步发表在[我的blog](https://www.cnblogs.com/TEoS/p/11789273.html)

------------

**思路分析**

为了让交易额尽量大，显然我们需要尽量多地买入。对于每个城市，到达这个城市时携带的黄金受到几个条件的影响：之前卖出的黄金，之前能买入的最多的黄金，前一个城市到当前城市的路径上的最小边权。既然不需要输出买入的数量，我们可以先尽量多地买入，然后再按照边权的限制削减。这样，刚好卖完的限制也就没有影响了。卖出时当然也要尽量都，因此卖出的量就是前一个城市能带到当前城市的最多的黄金和卖出限制中小的一个。

显然我们希望城市之间的路径上的最小边权最大，即使多绕路也没有关系。于是我们可以想到先求出一棵最大生成树，用kruskal就可以了。

然后我们需要知道最大生成树上两点之间的距离，这个距离可以用倍增或者树剖来求。

对于有列车站的城市，可以看作同一个城市。注意，买入和卖出的限制还是要按照原城市算，在求最大生成树和进行树剖处理询问时才合并。这里用有列车站的编号最小的城市来代表这些城市的代表编号。

整理一下思路，对于每个城市，我们执行以下操作：
1. 求出前一个城市最多能带到当前城市多少黄金
1. 若卖出，则输出黄金量和卖出限制中小的一个，并维护黄金量；若买入，则直接当做全部买入，维护黄金量即可。

**具体实现**

1. 建一棵最小生成树

跑一遍kruskal即可，就不再赘述了。
```cpp
struct Edge
{
	int x,y,z;
	#define x(i) e[i].x
	#define y(i) e[i].y
	#define z(i) e[i].z
}e[2*M];

void add(int x,int y,int z)
{
	ver[++tot]=y,edge[tot]=z,Next[tot]=head[x],head[x]=tot;
	ver[++tot]=x,edge[tot]=z,Next[tot]=head[y],head[y]=tot;
}

bool cmp(Edge a,Edge b)
{
	return a.z>b.z;
}

int get(int a)
{
	return fa[a]==a?a:fa[a]=get(fa[a]);
}

void kruskal()
{
	sort(e+1,e+m+1,cmp);
	for(int i=1;i<=n;i++)
		fa[i]=i;
	for(int i=1;i<=m;i++)
	{
		int x=p[x(i)]?minp:x(i),y=p[y(i)]?minp:y(i),fx,fy;//看看能否合并
		fx=get(x),fy=get(y);
		if(fx==fy)
			continue;
		fa[fx]=fy;
		add(x,y,z(i));
	}
}
```
2. 树剖预处理

正常的树剖预处理，这里用每条边两个端点中深度更大的节点存储这条边的权值，方便处理。对树链剖分不熟悉的可以[点击食用](https://www.cnblogs.com/TEoS/p/11359015.html)。

```cpp
struct Tree
{
	int siz,f,d,seg,son,top;
	#define siz(i) t[i].siz
	#define f(i) t[i].f
	#define d(i) t[i].d
	#define seg(i) t[i].seg
	#define son(i) t[i].son
	#define top(i) t[i].top
}t[N];

struct Seg
{
	int l,r,rev;
	ll sum;
	#define l(i) c[i].l
	#define r(i) c[i].r
	#define sum(i) c[i].sum
	#define rev(i) c[i].rev
}c[N];

void dfs1(int f,int x)
{
	siz(x)=1,d(x)=d(f)+1,f(x)=f;
	for(int i=head[x];i;i=Next[i])
		if(ver[i]!=f)
		{
			int y=ver[i];
			dfs1(x,y);
			siz(x)+=siz(y);
			if(siz(y)>siz(son(x)))
				son(x)=y;
			len[y]=edge[i];//用深度较大的端点存储边的权值
		}
}

void dfs2(int x)
{
	if(son(x))
	{
		seg(son(x))=++seg(0);
		rev(seg(0))=son(x);
		top(son(x))=top(x);
		dfs2(son(x));
	}
	for(int i=head[x];i;i=Next[i])
		if(!top(ver[i]))
		{
			int y=ver[i];
			seg(y)=++seg(0);
			rev(seg(0))=y;
			top(y)=y;
			dfs2(y);
		}
}

void build(int p,int l,int r)
{
	l(p)=l,r(p)=r;
	if(l==r)
	{
		sum(p)=len[rev(l)];
		return ;
	}
	int mid=(l+r)>>1;
	build(lson,l,mid),build(rson,mid+1,r);
	sum(p)=min(sum(lson),sum(rson));
}

seg(1)=++seg(0),rev(1)=1,top(1)=1,len[1]=IINF;
```

3. 依次对每个城市进行处理

先算出上一个城市到当前城市最多能携带多少黄金，若卖出，则取携带量和卖出限制中小的一个卖出；若买入，则全部买入。

有一点需要注意的，因为是用深度较大的端点存储边的权值，因此查询的时候不能查询到LCA处，因为LCA存储的边权不在路径上。

```cpp
ll op(int x,int y)
{
	ll val=IINF;
	x=p[x]?minp:x,y=p[y]?minp:y;//看看能否合并
	while(top(x)!=top(y))
	{
		if(d(top(x))<d(top(y)))
			swap(x,y);
		val=min(val,ask(1,seg(top(x)),seg(x)));
		x=f(top(x));
	}
	if(d(x)>d(y))
		swap(x,y);
	val=min(val,ask(1,seg(x)+1,seg(y)));//不能查询到LCA处
	return val;
}

void solve()
{
	for(int i=1;i<=n;i++)
	{
		now=min(i!=1?op(rank[i-1],rank[i]):IINF,now);//查询上一个城市到当前城市的路径上最小边权
		if(w[rank[i]]<0)
		{
			printf("%lld\n",min(-w[rank[i]],now));//卖出较小的一个
			now-=min(-w[rank[i]],now);//维护剩下的黄金
		}
		else
			now+=w[rank[i]];//全部买入
	}
}
```


------------
最后奉上完整代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#define lson p<<1
#define rson p<<1|1
#define ll long long
using namespace std;
const int N=1e6,M=1e6,INF=1e8;
const ll IINF=1e17;
int n,m,q,tot,minp=INF;
ll now;
int head[N],ver[2*M],Next[2*M];
int rank[N],fa[N];
ll edge[2*M];
ll w[N],len[N];
bool p[N];
struct Edge
{
	int x,y,z;
	#define x(i) e[i].x
	#define y(i) e[i].y
	#define z(i) e[i].z
}e[2*M];
struct Tree
{
	int siz,f,d,seg,son,top;
	#define siz(i) t[i].siz
	#define f(i) t[i].f
	#define d(i) t[i].d
	#define seg(i) t[i].seg
	#define son(i) t[i].son
	#define top(i) t[i].top
}t[N];
struct Seg
{
	int l,r,rev;
	ll sum;
	#define l(i) c[i].l
	#define r(i) c[i].r
	#define sum(i) c[i].sum
	#define rev(i) c[i].rev
}c[N];
bool cmp(Edge a,Edge b)
{
	return a.z>b.z;
}
void add(int x,int y,int z)
{
	ver[++tot]=y,edge[tot]=z,Next[tot]=head[x],head[x]=tot;
	ver[++tot]=x,edge[tot]=z,Next[tot]=head[y],head[y]=tot;
}
void dfs1(int f,int x)
{
	siz(x)=1,d(x)=d(f)+1,f(x)=f;
	for(int i=head[x];i;i=Next[i])
		if(ver[i]!=f)
		{
			int y=ver[i];
			dfs1(x,y);
			siz(x)+=siz(y);
			if(siz(y)>siz(son(x)))
				son(x)=y;
			len[y]=edge[i];
		}
}
void dfs2(int x)
{
	if(son(x))
	{
		seg(son(x))=++seg(0);
		rev(seg(0))=son(x);
		top(son(x))=top(x);
		dfs2(son(x));
	}
	for(int i=head[x];i;i=Next[i])
		if(!top(ver[i]))
		{
			int y=ver[i];
			seg(y)=++seg(0);
			rev(seg(0))=y;
			top(y)=y;
			dfs2(y);
		}
}
void build(int p,int l,int r)
{
	l(p)=l,r(p)=r;
	if(l==r)
	{
		sum(p)=len[rev(l)];
		return ;
	}
	int mid=(l+r)>>1;
	build(lson,l,mid),build(rson,mid+1,r);
	sum(p)=min(sum(lson),sum(rson));
}//2. 树剖预处理
ll ask(int p,int l,int r)
{
	if(l<=l(p) && r(p)<=r)
		return sum(p);
	int mid=(l(p)+r(p))>>1;
	ll val=IINF;
	if(l<=mid)
		val=min(val,ask(lson,l,r));
	if(r>mid)
		val=min(val,ask(rson,l,r));
	return val;
}
int get(int a)
{
	return fa[a]==a?a:fa[a]=get(fa[a]);
}
void kruskal()
{
	sort(e+1,e+m+1,cmp);
	for(int i=1;i<=n;i++)
		fa[i]=i;
	for(int i=1;i<=m;i++)
	{
		int x=p[x(i)]?minp:x(i),y=p[y(i)]?minp:y(i),fx,fy;
		fx=get(x),fy=get(y);
		if(fx==fy)
			continue;
		fa[fx]=fy;
		add(x,y,z(i));
	}
}//1. 建一棵最小生成树
ll op(int x,int y)
{
	ll val=IINF;
	x=p[x]?minp:x,y=p[y]?minp:y;
	while(top(x)!=top(y))
	{
		if(d(top(x))<d(top(y)))
			swap(x,y);
		val=min(val,ask(1,seg(top(x)),seg(x)));
		x=f(top(x));
	}
	if(d(x)>d(y))
		swap(x,y);
	val=min(val,ask(1,seg(x)+1,seg(y)));
	return val;
}
void read()
{
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=n;i++)
		scanf("%d",&rank[i]);
	for(int i=1;i<=n;i++)
		scanf("%lld",&w[i]);
	for(int i=1;i<=m;i++)
		scanf("%d%d%d",&x(i),&y(i),&z(i));
	for(int i=1;i<=q;i++)
	{
		int x;
		scanf("%d",&x);
		p[x]=1;minp=min(minp,x);
	}
}
void solve()
{
	for(int i=1;i<=n;i++)
	{
		now=min(i!=1?op(rank[i-1],rank[i]):IINF,now);
		if(w[rank[i]]<0)
		{
			printf("%lld\n",min(-w[rank[i]],now));
			now-=min(-w[rank[i]],now);
		}
		else
			now+=w[rank[i]];
	}
}//3. 依次对每个城市进行处理
int main()
{
	read();
	kruskal();
	seg(1)=++seg(0),rev(1)=1,top(1)=1,len[1]=IINF;
	dfs1(0,1),dfs2(1),build(1,1,n);
	solve();
	return 0;
}
```
希望对大家有帮助，有不足之处请指出。

---

## 作者：Sakura_梦瑶 (赞：3)

刚学oi很菜不会倍增）自己思考出了个求不了lca的树上倍增....，可是这样的倍增似乎没有用,我很清流地写了个裸树链剖分，当noip前复习板子了,细节挺多写挂了一个查询操作,最后数组开太大疯狂re。

------------


思路:本题题面的a约束其实没有什么用,发现直接贪心地能拿就拿,找到两点路径上最大的最小小权边,取个min就行了,尽管你可能表面上最终会剩余,但是本题不要求具体方案（在什么地方拿了几个），你可以想象多出来的部分其实可以自动调整为合法而且不影响答案,所以直接贪心多拿。



下面是这个代码,顺面送了一组自造样例,看这么可爱的样例给个赞？;
```cpp
#include<bits/stdc++.h>
#define use 1,n-q+1,rt
#define left l,mid,ls[pos]
#define righ mid+1,r,rs[pos]
#define fer(x,y,z) for(signed x=y;x<=z;x++)
#define int long long
#define N 510100
using namespace std;
struct p{int s,t,v;}e[N];bool pd[N];
int n,m,q,a[N],link[N],nxt[N],to[N],las[N],val[N],pot,f[N];
int v[N],d_[N],d[N],fa[N],si[N],son[N],top[N],dep[N];
int ls[N],rs[N],mi[N],rt,cnt,pnt,ans,now;
inline bool cmp(p b,p c){return b.v>c.v;}
int bine(int x){return f[x]!=x?f[x]=bine(f[x]):x;}
inline int maxx(int b,int c){return b>c?b:c;}
inline int minn(int b,int c){return b>c?c:b;}
void sak_bu(int l,int r,int &pos){
	if(!pos)pos=++cnt;if(l==r){mi[pos]=v[d[l]];return;}
	int mid=l+r>>1;sak_bu(left),sak_bu(righ);
	mi[pos]=minn(mi[ls[pos]],mi[rs[pos]]);
}
void sak_qu(int l,int r,int pos,int ql,int qr){
	if(ql==l&&qr==r){ans=minn(ans,mi[pos]);return;}int mid=l+r>>1;
	if(mid>=qr)sak_qu(left,ql,qr);else if(mid<ql)sak_qu(righ,ql,qr);
	else sak_qu(left,ql,mid),sak_qu(righ,mid+1,qr);
}
void dfs1(int x){
	si[x]=1;for(int i=las[x];i;i=nxt[i])if(to[i]!=fa[x]){
		fa[to[i]]=x,dep[to[i]]=dep[x]+1;dfs1(to[i]),si[x]+=si[to[i]];
		if(si[to[i]]>si[son[x]])son[x]=to[i];v[to[i]]=val[i];
	}
}
void dfs2(int x,int t){
	d_[x]=++cnt,d[cnt]=x,top[x]=t;
	if(son[x])dfs2(son[x],t);
	for(int i=las[x];i;i=nxt[i])
	 if(fa[x]!=to[i]&&son[x]!=to[i])dfs2(to[i],to[i]);
}
main(){
	cin>>n>>m>>q;int x=1,y;
	fer(i,1,n)scanf("%lld",&link[i]);
	fer(i,1,n)scanf("%lld",&a[i]),f[i]=i;
	fer(i,1,m)scanf("%lld%lld%lld",&e[i].s,&e[i].t,&e[i].v);
	fer(i,1,q)scanf("%lld",&x),pd[x]=1;pot=x;
	fer(i,1,n)if(pd[i])f[i]=x;
	if(a[link[1]]<0)cout<<0<<'\n';
	
	sort(e+1,e+1+m,cmp);int i=1;while(pnt<n-q){
		if(pd[e[i].s])e[i].s=pot;if(pd[e[i].t])e[i].t=pot;
		x=bine(e[i].s),y=bine(e[i].t);if(x!=y){
		 pnt++,f[x]=y,x=e[i].s,y=e[i].t;
		 nxt[++cnt]=las[x],las[x]=cnt,to[cnt]=y,val[cnt]=e[i].v,
		 nxt[++cnt]=las[y],las[y]=cnt,to[cnt]=x,val[cnt]=e[i].v;
		}i++;
	}if(!q)q=1;cnt=0,dfs1(pot),dfs2(pot,pot),cnt=0,sak_bu(use);

	now=maxx(now,a[link[1]]);fer(i,2,n){
		ans=1e17,x=link[i-1],y=link[i];
		if(pd[x])x=pot;if(pd[y])y=pot;
		while(top[x]!=top[y]){
			if(dep[top[x]]>dep[top[y]])sak_qu(use,d_[top[x]],d_[x]),x=fa[top[x]];
			else sak_qu(use,d_[top[y]],d_[y]),y=fa[top[y]];
		}
		if(dep[x]>dep[y])sak_qu(use,d_[y]+1,d_[x]);
		else if(x!=y)sak_qu(use,d_[x]+1,d_[y]);now=minn(ans,now);
		if(a[link[i]]<0)cout<<minn(-a[link[i]],now)<<'\n',now=maxx(0,now+a[link[i]]);
		else now+=a[link[i]];
	}
}
//6 6 2
//4 5 1 6 3 2
//15 12 -4 20 -21 -13
//1 3 23
//1 4 12
//1 5 20
//1 6 9
//4 2 10
//2 6 15
//3 5
//ans:12 10 0
```

---

## 作者：Cxny (赞：2)

对于两个城市间的路径，能运送的黄金数量是路径上边权的最小值。

显然，在 Kruskal （最大）生成树上跑即可使边权最小值最大。

铁路线可以看作边权无穷大的道路。因此，在跑最大生成树前可以将铁路站点间预先连边。（缩点应该也没问题，但没必要。）

问题就转化为了树上问题。

再考虑题目给定的两个限制。

少买和在路上扔掉是等价的（扔掉 $1$ 单位黄金即相当于还回卖方 $1$ 单位），因此两限制可以忽略。

树上两点路径上边权最小值，可使用倍增在单次 $\text{O(log n)}$ 的时间复杂度内解决。

完整代码如下：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn = 1e5 + 10, inf = 1e18;
struct Edge{
	int s, t, wei;
	const bool operator <(const Edge &c)const{return wei > c.wei;}
}e[maxn << 1];
int n, m, q, ord[maxn], a[maxn], p[maxn], fa[maxn];
vector<int> edge[maxn], wei[maxn];
int f[maxn][20], w[maxn][20], dep[maxn];

inline int getf(int x){return fa[x] == x ? x : fa[x] = getf(fa[x]);}

void dfs(int u){
	dep[u] = dep[f[u][0]] + 1;
	for(int i = 0; i < (int)edge[u].size(); i++){
		int v = edge[u][i];
		if(v == f[u][0]) continue;
		f[v][0] = u, w[v][0] = wei[u][i];
		dfs(v);
	}
}
int LCA(int x, int y){
	if(dep[x] < dep[y]) swap(x, y);
	int ret = inf, det = dep[x] - dep[y];
	for(int i = 0; i < 20; i++) if(det & (1 << i)) ret = min(ret, w[x][i]), x = f[x][i];
	if(x == y) return ret;
	for(int i = 19; i >= 0; i--)
		if(f[x][i] != f[y][i]) ret = min({ret, w[x][i], w[y][i]}), x = f[x][i], y = f[y][i];
	return min({ret, w[x][0], w[y][0]});
}
signed main(){
	scanf("%lld%lld%lld", &n, &m, &q);
	for(int i = 1; i <= n; i++) scanf("%lld", &ord[i]);
	for(int i = 1; i <= n; i++) scanf("%lld", &a[i]);
	for(int i = 1; i <= m; i++) scanf("%lld%lld%lld", &e[i].s, &e[i].t, &e[i].wei);
	iota(fa + 1, fa + n + 1, 1);
	int tot = 0;
	//将列车看作边权无穷大的边,直接加入生成树 
	for(int i = 1; i <= q; i++){
		scanf("%lld", &p[i]);
		if(i != 1){
			int fx = getf(p[i - 1]), fy = getf(p[i]);
			if(fx == fy) continue;
			fa[fy] = fx, tot++;
			edge[p[i]].push_back(p[i - 1]), wei[p[i]].push_back(inf);
			edge[p[i - 1]].push_back(p[i]), wei[p[i - 1]].push_back(inf);
		}
	}
	//Kruskal
	sort(e + 1, e + m + 1);
	for(int i = 1; i <= m; i++){
		if(tot >= n - 1) break;
		int x = e[i].s, y = e[i].t, fx = getf(x), fy = getf(y);
		if(fx == fy) continue;
		fa[fx] = fy, tot++;
		edge[x].push_back(y), wei[x].push_back(e[i].wei);
		edge[y].push_back(x), wei[y].push_back(e[i].wei);
	}
	//倍增预处理 
	dfs(1);
	for(int i = 1; i < 20; i++) for(int j = 1; j <= n; j++){
		f[j][i] = f[f[j][i - 1]][i - 1];
		w[j][i] = min(w[j][i - 1], w[f[j][i - 1]][i - 1]);
	}
	
	int gold = 0;
	for(int i = 1; i < n; i++){
		int cur = ord[i], tar = ord[i + 1];
		int MAX = LCA(cur, tar);
		if(a[cur] > 0) gold = min(gold + a[cur], MAX);
		else{
			int sell = min(gold, -a[cur]);
			printf("%lld\n", sell);
			gold = min(gold - sell, MAX);
		}
	}
	if(a[ord[n]] < 0) printf("%lld\n", min(gold, -a[ord[n]]));
	return 0;
}

```

---

## 作者：asuldb (赞：2)

倍增什么的最慢了，常数太大了

我们可以上树剖啊

但是如果用树剖来查询树上两点之间的最小边权的话，可能只能在上一棵线段树？

那也太$naive$了，尽管倍增常数大，但是还是比两个$log$快的

那干脆重构树算了

我们直接建出$kruskal$重构树，之后我们可以在重构树上直接用树剖来查询$lca$，$lca$的点权就是最小边的边权

这就是我最优解的原因了

之后发现自己的思路非常清奇，那就干脆再写一下思路吧

可能是我太傻了，并没有发现可以直接贪心，所以搞出来一种非常难写的方法

我们定义一个$Maxn$数组，$Maxn[i]$表示$i$次交易后最多可以携带多少枚金子

显然$Maxn[n]=0$，$n$次交易后我们不能再有金子了

之后我们倒着推出$Maxn$数组

首先$Maxn[i]$应该等于$i$次交易和$i+1$次交易之间两点的最小边权

如果$a[i+1]<0$，我们可以通过卖出消耗掉一些,那就说明我们可以多往后传递一些，于是就有$Maxn[i]-|a[i+1]|<=Maxn[i+1]$

也就是$Maxn[i]<=Maxn[i]-a[i+1]$

如果$a[i+1]>0$，我们卖出都不能了，于是就有$Maxn[i]<=Maxn[i+1]$

求出$Maxn$数组之后贪心就可以啦

代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<iostream>
#define re register
#define maxn 100005
#define INF 9999999999
#define LL long long
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
struct E
{
	int v,nxt;
}e[maxn<<2];
struct g
{
	int x,y;
	LL z;
}G[maxn<<1];
int fa[maxn<<1];
int sum[maxn<<1],Fa[maxn<<1],top[maxn<<1],deep[maxn<<1],son[maxn<<1],head[maxn<<1];
int n,m,q,num;
LL Maxn[maxn];
int c[maxn<<1];
LL a[maxn],b[maxn];
LL val[maxn<<2];
inline LL read()
{
	char c=getchar();
	LL x=0,r=1;
	while(c<'0'||c>'9') {if(c=='-') r=-1;c=getchar();}
	while(c>='0'&&c<='9')
		x=(x<<3)+(x<<1)+c-48,c=getchar();
	return x*r;
}
inline int find(int x)
{
	if(x==fa[x]) return x;
	return fa[x]=find(fa[x]);
}
inline void add_edge(int x,int y)
{
	e[++num].v=y;
	e[num].nxt=head[x];
	head[x]=num;
}
void dfs1(int x)
{
	sum[x]=1;
	int maxx=-1;
	for(re int i=head[x];i;i=e[i].nxt)
	if(!deep[e[i].v])
	{
		deep[e[i].v]=deep[x]+1;
		Fa[e[i].v]=x;
		dfs1(e[i].v);
		sum[x]+=sum[e[i].v];
		if(sum[e[i].v]>maxx) maxx=sum[e[i].v],son[x]=e[i].v;
	}
}
void dfs2(int x,int topf)
{
	top[x]=topf;
	if(!son[x]) return;
	dfs2(son[x],topf);
	for(re int i=head[x];i;i=e[i].nxt)
	if(deep[e[i].v]>deep[x]&&son[x]!=e[i].v) dfs2(e[i].v,e[i].v);
}
inline int LCA(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(deep[top[x]]<deep[top[y]]) std::swap(x,y);
		x=Fa[top[x]];
	}
	if(deep[x]<deep[y]) return x;
	return y;
}
inline int cmp(g a,g b)
{
	return a.z>b.z;
}
signed main()
{
	n=read(),m=read(),q=read();
	for(re int i=1;i<=n;i++) b[i]=read();
	for(re int i=1;i<=n;i++) a[i]=read();
	for(re int i=1;i<=m;i++)
		G[i].x=read(),G[i].y=read(),G[i].z=read();
	for(re int i=1;i<=n*2;i++) c[i]=i;
	if(q>=1)
	{
		int pre=read(),X;
		for(re int i=1;i<q;i++)
		{
			X=read();
			c[X]=pre;
		}
	}
	std::sort(G+1,G+m+1,cmp);
	for(re int i=1;i<=n*2;i++)
	if(c[i]==i) fa[i]=i;
	int cnt=n;
	for(re int i=1;i<=m;i++)
	{
		int xx=find(c[G[i].x]);
		int yy=find(c[G[i].y]);
		if(xx==yy) continue;
		add_edge(++cnt,xx),add_edge(cnt,yy);
		add_edge(xx,cnt),add_edge(yy,cnt);
		val[cnt]=G[i].z;
		fa[xx]=cnt,fa[yy]=cnt;
	}
	deep[cnt]=1;
	dfs1(cnt);
	dfs2(cnt,cnt);
	Maxn[n]=0;
	for(re int i=n-1;i;i--)
	{
		int lca=LCA(c[b[i]],c[b[i+1]]);
		Maxn[i]=val[lca];
		if(lca==c[b[i]]) Maxn[i]=INF;
		if(a[b[i+1]]<0)
			Maxn[i]=min(Maxn[i+1]-a[b[i+1]],Maxn[i]);
		else
			Maxn[i]=min(Maxn[i],Maxn[i+1]);
	}
	LL now=0;
	for(re int i=1;i<=n;i++)
	{
		if(a[b[i]]>0) now=min(Maxn[i],a[b[i]]+now);
		else 
		{
			printf("%lld\n",min(now,-a[b[i]]));
			now+=a[b[i]];
			now=max(now,0);
		}
	}
	return 0;
}
```

---

## 作者：劉子颺 (赞：2)

第一这个题比当年NOIP好
第一好在数据上：有一条长链。
卡死不写ST表查大小的。
第二这个题和SDOI的所托门王类似。
它存在铁路这个概念。
你不能两两建边。把第一个车站看做原点然后搞一条深度是1的树。
第三最后打答案是一个贪心。
然后最大生成树+LCA
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
#define N (long long)3e5+100
#define maxn (int)1e5+100
#define INF (long long)1e18
inline void read(long long &x){
	x=0;
	int f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-'0';
		ch=getchar();
	}
	x*=f;
} 
struct Front_star{
	long long u,v,w,nxt;
}e[N*2],edge[N*2];
long long n,m,q;
long long list_incoming[maxn]={0};
long long trade_sum[maxn]={0};
long long cnt=0;
void add(long long u,long long v,long long w){
	cnt++;
	e[cnt].u=u;
	e[cnt].v=v;
	e[cnt].w=w;
}
long long ecnt=0;
long long first[maxn]={0};
void insert(long long u,long long v,long long w){
	ecnt++;
	edge[ecnt].u=u;
	edge[ecnt].v=v;
	edge[ecnt].w=w;
	edge[ecnt].nxt=first[u];
	first[u]=ecnt;
}
bool cmp(Front_star a,Front_star b){
	return a.w>b.w;
}
// KRUSKAL
long long fa[maxn]={0};
inline long long getfa(long long x){
	if(fa[x]==x){
		return x;
	}
	else{
		return fa[x]=getfa(fa[x]);
	}
}
inline long long link(long long x,long long y){
	long long dx=getfa(x);
	long long dy=getfa(y);
	fa[dx]=dy;
}
void kruskal(){
	long long all=0;
	for(long long i=1;i<=cnt;i++){
		long long u=e[i].u;
		long long v=e[i].v;
//		cout<<"u= "<<u<<" v= "<<v<<endl; 
		if(getfa(u)!=getfa(v)){
			all++;
			link(u,v);
//			cout<<u<<" "<<v<<" "<<e[i].w<<endl;
//			cout<<e[i].w<<endl;
			insert(u,v,e[i].w);
			insert(v,u,e[i].w);
			if(all==n-1)
				break;
		}
	}
}
// LCA
long long f[maxn][35]={0};
long long st[maxn][35]={0};
long long dep[maxn]={0};
void dfs(long long u,long long fa){
//	cout<<u<<" "<<fa<<endl;
	for(long long i=1;(1<<i)<=dep[u];i++){
		f[u][i]=f[f[u][i-1]][i-1];
		st[u][i]=min(st[f[u][i-1]][i-1],st[u][i-1]);
	}
	for(long long i=first[u];i;i=edge[i].nxt){
		long long v=edge[i].v;
		long long w=edge[i].w;
		if(v==fa)
			continue;
		dep[v]=dep[u]+1;
		f[v][0]=u;
		st[v][0]=w;
		dfs(v,u);
	}
}
long long lca(long long x,long long y){
	long long ans=0;
	if(dep[x]<dep[y]){
		swap(x,y);
	}
	ans=INF+10;
	long long t=dep[x]-dep[y];
	for(long long i=0;(1<<i)<=t;i++){
		if(t&(1<<i)){
			ans=min(ans,st[x][i]);
			x=f[x][i];
		}
	}
//	cout<<"x= "<<x<<" "<<y<<endl; 
	if(x==y){
		return ans;
	}
	
	for(long long i=20;i>=0;i--){
		if(f[x][i]!=f[y][i]){
			ans=min(ans,min(st[x][i],st[y][i]));
			x=f[x][i];
			y=f[y][i];
		}
	}
	ans=min(ans,min(st[x][0],st[y][0]));
	return ans;
}
int main(){
	freopen("motorcycle.in","r",stdin);
	freopen("motorcycle.out","w",stdout);
	read(n);
	read(m);
	read(q);
	for(long long i=1;i<=n;i++){
		read(list_incoming[i]);
	} 
	for(long long i=1;i<=n;i++){
		read(trade_sum[i]);
	}
	for(long long i=1;i<=m;i++){
		long long u,v,w;
		read(u);
		read(v);
		read(w);
		add(u,v,w);
	}
//	cout<<"hello wolrd"<<endl;
	if(q){
		long long u;
		read(u);
		for(long long i=2;i<=q;i++){
			long long v;
			read(v);
			add(u,v,INF);
		}
	}
	sort(e+1,e+1+cnt,cmp);
	for(long long i=1;i<=n;i++){
		fa[i]=i;
	}
	kruskal();
//	f[1][0]=1;
//	dep[1]=0;
	dfs(list_incoming[1],0);
	long long nowhaving=0;
	if(trade_sum[list_incoming[1]]<0){
		cout<<0<<endl;
//		return 0;
	}
	else{
		nowhaving=trade_sum[list_incoming[1]];
	}
//	for(long long i=1;i<=n;i++){
//		for(long long j=0;j<=2;j++){
//			cout<<st[i][j]<<" ";
//		}
//		cout<<endl;
//	}
//	cout<<lca(1,3);
	for(long long i=1;i<n;i++){
		long long u=list_incoming[i];
		long long v=list_incoming[i+1];
		long long LCA=lca(u,v);
//		cout<<"LCA= "<<LCA<<" "<<u<<" "<<v<<endl;
		nowhaving=min(nowhaving,LCA);
		if(trade_sum[v]>0){
			nowhaving+=trade_sum[v];
		}
		else{
			printf("%lld\n",min(nowhaving,-trade_sum[v]));
			nowhaving=max((long long)0,nowhaving+trade_sum[v]);
		}
	}
	return 0;
}
```

---

## 作者：IkunTeddy (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P3280)

# 题意简述
要从 $u$ 去到 $v$ 且负重不能超过路程中道路的权值，但某些城市中会有列车，列车不限重，每去到一个 $v$ 就会完成一个卖出或买入的交易，求卖出的最大值。

# 方法分析
其实这道题跟 [P1967](https://www.luogu.com.cn/problem/P1967) 十分类似，只不过加了一个无限重的列车。

我们可以将有列车的两个点间再加一个权值为无穷大的边，这样就可以解决问题啦。

然后使用 kruskal 生成一颗最大生成树，求出点与点之间的边值的最小值，使用 lca 或者是树剖都行，我这里选择使用 lca。

最后求答案时，如果当前是买入直接全部买下就行，先不需要考虑会不会超重，等到卖出时再与路程中限重的最小值比较，如果必最小值大了，就像时间回溯一样，回到过去把多余的扔掉就行。

整个题就搞定了，还是很容易想到的。

还有一个重点就是一定要开 $longlong$！

初始值也要赋 $longlong$ 的极限值！

本人因此调了两个小时，~~给个关注安慰一下吧~~ 呜呜呜。

# Code
最后贴上代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <queue>
#include <cmath>
#include <algorithm>
#define ll long long
using namespace std;
const int maxn=300000+10;
const ll INF=9223372036854775807;
struct node{ll u;ll v;ll w;}arr[maxn];
bool cmp(node a,node b){
	return a.w>b.w;
}
struct edge{ll x;ll p;};
vector<edge> vt[maxn];
ll a[maxn];
ll b[maxn];
ll c[maxn];
ll money;
ll pre[maxn];
ll p,n,m,q;
ll find(ll x){
	if(pre[x]==x) return x;
	return pre[x]=find(pre[x]);
}
int cnt=0;
void kruskal(){
	
	sort(arr+1,arr+1+m,cmp);
	
	for(int i=1;i<=m;i++){
		if(cnt>=n-1) break;
		ll u=arr[i].u;
		ll v=arr[i].v;
		ll w=arr[i].w;
		ll fu=find(u);
		ll fv=find(v);
		if(fu!=fv){
			vt[u].push_back({v,w});
			vt[v].push_back({u,w});
			pre[fu]=fv;
			cnt++;
			
		}
	}
}
ll dp[maxn][25];
ll st[maxn][25];
ll h[maxn];
void dfs(ll u,ll f){
	ll l=vt[u].size();
	dp[u][0]=f;
	h[u]=h[f]+1;
	for(int i=1;i<=20;i++){
		dp[u][i]=dp[dp[u][i-1]][i-1];
		st[u][i]=min(st[u][i-1],st[dp[u][i-1]][i-1]);
	}
	for(int i=0;i<l;i++){
		ll v=vt[u][i].x;
		ll p=vt[u][i].p;
		if(v==f) continue;
		st[v][0]=p;
		dfs(v,u);
	}
}
ll lca(int x,int y){
	ll a=x;
	ll b=y;
	ll ans=INF;
	if(h[a]<h[b]) swap(a,b);
	for(int i=20;i>=0;i--){
		if(h[dp[a][i]]>=h[b]){
			ans=min(ans,st[a][i]);
			a=dp[a][i];
		}
	}
	if(a==b) return ans;
	for(int i=20;i>=0;i--){
		if(dp[a][i]!=dp[b][i]){
			ans=min(ans,st[a][i]);
			ans=min(ans,st[b][i]);
			a=dp[a][i];
			b=dp[b][i];
		}
	}
	ans=min(ans,min(st[a][0],st[b][0]));
	return ans;
}
int main(){
	
	cin>>n>>m>>q; 
	for(int i=1;i<=n;i++) pre[i]=i;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) cin>>b[i];
	for(int i=1;i<=m;i++) cin>>arr[i].u>>arr[i].v>>arr[i].w;
	for(int i=1;i<=q;i++) cin>>c[i];
	for(int i=1;i<q;i++){
		int fx=find(c[i]);
		int fy=find(c[i+1]);
		if(fx==fy) continue;
		pre[fx]=fy;
		vt[c[i]].push_back({c[i+1],INF});
		vt[c[i+1]].push_back({c[i],INF});
		cnt++;
	}
	kruskal();
	dfs(1,0);
	ll now=a[1];
	if(b[now]>0) money=b[now];
	else cout<<0<<endl;
	for(int i=2;i<=n;i++){
		ll to=a[i];
		//cout<<now<<" "<<to<<endl;
		ll mn=lca(a[i-1],to);
		money=min(money,mn);
		if(b[to]>0) money+=b[to];
		else{
			cout<<min(-b[to],money)<<endl;
			money-=min(-b[to],money);
		}
	}
	
	return 0;
}

```


---

## 作者：wudiss8 (赞：1)

# Part 1 简化模型
首先我们简化一下模型，题意是让我们在一张图上找到两个点间限重最大的路径，而且这张图存在一类特殊点，它们之间可以直接传送且限重无限。

# Part 2 最大生成树！

接着我们来思考解题方法，如果你做过 P1967 货车运输 这道题，你肯定可以想到，如果两个点之间存在一条限重最大的路径，那么其它边的边没有关系，可以删掉，因此，如果q=0(没有特殊点),那么我们可以构建一棵最大生成树，然后通过倍增来求出两个点之间的最大限重。

```cpp
//最大生成树
inline void kruskal(){
	int k=0;
	for(register int i=1;i<=n;i++)fat[i]=i;
	for(register int i=1;i<=m;i++){
		int f1=getfat(a[i].u),f2=getfat(a[i].v);
		if(f1!=f2){
			fat[f2]=f1;
			int x=a[i].u,y=a[i].v;
			addt(x,y,a[i].w);
			addt(y,x,a[i].w);
			k++;
			if(k==n-1)break;
		}
	}
}
//倍增维护的初始化
inline void dfs1(int x,int fa){
	dep[x]=dep[fa]+1;
	f[x][0]=fa;
	for(register int i=1;i<=20;i++){
	    f[x][i]=f[f[x][i-1]][i-1];
	    fmi[x][i]=min(fmi[x][i-1],fmi[f[x][i-1]][i-1]);
    }
inline void dfs1(int x,int fa){
	dep[x]=dep[fa]+1;
	f[x][0]=fa;
	for(register int i=1;i<=20;i++){
	    f[x][i]=f[f[x][i-1]][i-1];
	    fmi[x][i]=min(fmi[x][i-1],fmi[f[x][i-1]][i-1]);
    }
	for(register int e=poi[x];e;e=nex[e]){
		if(to[e]==fa)continue;
		fmi[to[e]][0]=val[e];
		dfs1(to[e],x);
		cz[x]=max(cz[x],min(val[e],cz[to[e]]));
	}
}
//倍增求公路上两点最大限重
inline int glca(int x,int y){
	int re=1<<30;
	if(dep[x]<dep[y])swap(x,y);
	for(register int i=20;i>=0;i--){
		if(dep[f[x][i]]>=dep[y]){
			re=min(re,fmi[x][i]);
			x=f[x][i];
		}
	}
	if(x==y)return re;
	for(register int i=20;i>=0;i--){
		if(f[x][i]!=f[y][i]){
			re=min(re,min(fmi[x][i],fmi[y][i]));
			x=f[x][i];
			y=f[y][i];
		}
	}
	re=min(re,min(fmi[x][0],fmi[y][0]));
	return re;
}
```

# Part 3 车站emmm?
现在车站是一个棘手的问题，由于车站最多可能有 $ 1*10^5$个,$O(n^2)$的在车站之间互相连边显然是不大可能的，然而，显然的一点是，我如果要去车站，肯定是去到当前位置路径限重最大的一个，如果一个点本身是车站，那么这个限重肯定是正无穷，略加思考，我们就可以想出用两遍$O(n)$的dfs维护出每个点到车站的最大限重。
![](https://cdn.luogu.com.cn/upload/image_hosting/s1ufr9pw.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

```cpp
inline void dfs1(int x,int fa){
	dep[x]=dep[fa]+1;
	f[x][0]=fa;
	for(register int i=1;i<=20;i++){
	    f[x][i]=f[f[x][i-1]][i-1];
	    fmi[x][i]=min(fmi[x][i-1],fmi[f[x][i-1]][i-1]);
    }
	for(register int e=poi[x];e;e=nex[e]){
		if(to[e]==fa)continue;
		fmi[to[e]][0]=val[e];
		dfs1(to[e],x);
		cz[x]=max(cz[x],min(val[e],cz[to[e]]));
     //先维护每个节点到子树车站的最大限重
	}
}
```
![](https://cdn.luogu.com.cn/upload/image_hosting/f7pkyds0.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
```cpp
inline void dfs2(int x,int up){
	cz[x]=max(cz[x],up);
   //up是父节点到自己的最大限重
   //此时父节点可以是从父节点的上面过来，
   //也可以是从父节点的其他子树过来
   //与本身自己的子树比较
	for(register int e=poi[x];e;e=nex[e]){
		if(to[e]==f[x][0])continue;
		dfs2(to[e],min(cz[x],val[e]));
   //向下深搜
	}
}
```
# Part 4 买卖。
有了上述的预处理，我们就也可以开始愉快地做生意了qwq,由于买入时不要求输出，所以买多了我们丢掉也不会有人知道(其实就是没有影响)，这样的话在每个能买入的点全部买入，到下一个点的路上就丢到限重为止，到了卖的点，能卖多少卖多少，这样，以一种贪心的思路，这道题就完美解决了
```cpp
int fir,sec,now=0,lim;
	for(register int i=1;i<=n;i++){
		if(i==n){
        //如果最后一个点，就没有到下一个点的限重了
			if(b[sec]>0)continue;
			if(now>=(-b[sec])){
			    printf("%lld\n",-b[sec]);
			    now=now+b[sec];
		    }else{
		    	printf("%lld\n",now);
		    	now=0;
			}
		}else{
		fir=dd[i].bh;sec=dd[i+1].bh;
		lim=max(min(cz[fir],cz[sec]),glca(fir,sec));
        //到下一个点的最大限重
		if(b[fir]>0){
			if(now+b[fir]>lim)now=lim;
			else now+=b[fir];
        //如果是买入点，就全部买入，
        //然后和限重取min,相当于多了就丢掉   
		}else{
        //是卖出点
			if(now+b[fir]>=0){
        //如果当前剩下的黄金比卖出的多
        //那就卖出这么多
			    printf("%lld\n",-b[fir]);
			    now=now+b[fir];
		    }else{
        //否则就全部卖出去    
		    	printf("%lld\n",now);
		    	now=0;
			}
			if(now>lim)now=lim;
		}
	    }
	}
```
# Part 5 Code
到这里，本篇题解就基本结束来，然后粘一下整个代码吧
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mxn=109951162776;
struct no{
	int bh,ord;
}dd[410001];
struct edge{
	int u,v,w;
}a[410001];
int b[410001],fat[410001],n,m,fmi[410001][21],f[410001][21],dep[410001],cz[410001];
int tot,poi[410001],to[410001],nex[410001],val[410001];
inline bool cmp(no x,no y){
	return x.ord<y.ord;
}
inline bool cmp2(edge x,edge y){
	return x.w>y.w;
}
inline void addt(int x,int y,int z){
	tot++;
	nex[tot]=poi[x];poi[x]=tot;to[tot]=y;val[tot]=z;
}
inline int getfat(int x){
	if(x==fat[x])return x;
	fat[x]=getfat(fat[x]);
	return fat[x];
}
inline void kruskal(){
	int k=0;
	for(register int i=1;i<=n;i++)fat[i]=i;
	for(register int i=1;i<=m;i++){
		int f1=getfat(a[i].u),f2=getfat(a[i].v);
		if(f1!=f2){
			fat[f2]=f1;
			int x=a[i].u,y=a[i].v;
			addt(x,y,a[i].w);
			addt(y,x,a[i].w);
			k++;
			if(k==n-1)break;
		}
	}
}
inline void dfs1(int x,int fa){
	dep[x]=dep[fa]+1;
	f[x][0]=fa;
	for(register int i=1;i<=20;i++){
	    f[x][i]=f[f[x][i-1]][i-1];
	    fmi[x][i]=min(fmi[x][i-1],fmi[f[x][i-1]][i-1]);
    }
	for(register int e=poi[x];e;e=nex[e]){
		if(to[e]==fa)continue;
		fmi[to[e]][0]=val[e];
		dfs1(to[e],x);
		cz[x]=max(cz[x],min(val[e],cz[to[e]]));
	}
}
inline void dfs2(int x,int up){
	cz[x]=max(cz[x],up);
	for(register int e=poi[x];e;e=nex[e]){
		if(to[e]==f[x][0])continue;
		dfs2(to[e],min(cz[x],val[e]));
	}
}
inline int glca(int x,int y){
	int re=1<<30;
	if(dep[x]<dep[y])swap(x,y);
	for(register int i=20;i>=0;i--){
		if(dep[f[x][i]]>=dep[y]){
			re=min(re,fmi[x][i]);
			x=f[x][i];
		}
	}
	if(x==y)return re;
	for(register int i=20;i>=0;i--){
		if(f[x][i]!=f[y][i]){
			re=min(re,min(fmi[x][i],fmi[y][i]));
			x=f[x][i];
			y=f[y][i];
		}
	}
	re=min(re,min(fmi[x][0],fmi[y][0]));
	return re;
}
inline int read(){
	char c=getchar();
	int s=0,fu=1;
	while(c<'0' or c>'9'){
		if(c=='-')fu=-1;
		c=getchar();
	}
	while(c>='0' and c<='9'){
		s=(s<<1)+(s<<3)+c-'0';
		c=getchar();
	}
	return s*fu;
}
signed main(){
	//freopen("5.in","r",stdin);
	//freopen("test.out","w",stdout);
	int q;
	n=read();m=read();q=read();
	for(register int i=1;i<=n;i++){
		dd[i].bh=read();
	}
	for(register int i=1;i<=n;i++){
		b[i]=read();
	}
	for(register int i=1;i<=m;i++){
		a[i].u=read();a[i].v=read();a[i].w=read();
	}
	sort(a+1,a+1+m,cmp2);
	for(register int i=1;i<=q;i++){
		cz[read()]=mxn;
	}
	kruskal();
	//fmi[1][0]=1<<30;
	dfs1(1,0);
	dfs2(1,0);
	int fir,sec,now=0,lim;
	for(register int i=1;i<=n;i++){
		if(i==n){
			if(b[sec]>0)continue;
			if(now>=(-b[sec])){
			    printf("%lld\n",-b[sec]);
			    now=now+b[sec];
		    }else{
		    	printf("%lld\n",now);
		    	now=0;
			}
		}else{
		fir=dd[i].bh;sec=dd[i+1].bh;
		lim=max(min(cz[fir],cz[sec]),glca(fir,sec));
		if(b[fir]>0){
			if(now+b[fir]>lim)now=lim;
			else now+=b[fir];
		}else{
			if(now+b[fir]>=0){
			    printf("%lld\n",-b[fir]);
			    now=now+b[fir];
		    }else{
		    	printf("%lld\n",now);
		    	now=0;
			}
			if(now>lim)now=lim;
		}
	    }
	}
	return 0;
}
```



---

## 作者：nofind (赞：1)

题意:https://www.luogu.org/problem/P3280

NOIP货车运输加强版,增加了铁路的情况

与货车运输一样,在最大生成树上贪心,每次找两个点之间边权最小的即可

考虑在铁路城之间移动是不会对答案产生影响,因此只要保证铁路城市之间两两互通即可,也就是说对于铁路城市,将它们之间的边建成一颗树即可,这里钦定第一个铁路城为根,将其他铁路城向它连边

实现用了克鲁斯卡尔重构树,树上倍增也能做

code:
```
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=1e5+10;
const int maxm=3*1e5+10;
int n,m,K,cnt,tot,st,t;
int head[maxn<<1],b[maxn],val[maxn<<1],fa[maxn<<1],pos[maxn],dep[maxn<<1];
int f[maxn<<1][20];
struct Edge{int u,v,w;}E[maxm];
struct edge{int to,nxt;}e[maxn<<2];
inline bool cmp(Edge x,Edge y){return x.w>y.w;}
inline void add(int u,int v)
{
	e[++cnt].nxt=head[u];
	head[u]=cnt;
	e[cnt].to=v;
}
inline int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
inline void kruscal()
{
	for(int i=1;i<=n;i++)fa[i]=i;
	sort(E+1,E+m+1,cmp);
	for(int i=1;i<=m;i++)
	{
		int x=find(E[i].u),y=find(E[i].v);
		if(x==y)continue;
		tot++;fa[x]=fa[y]=fa[tot]=tot;val[tot]=E[i].w;
		add(x,tot);add(tot,x);add(y,tot);add(tot,y);
	}
}
void dfs(int x,int pre)
{
	dep[x]=dep[pre]+1;
	for(int i=1;i<=t;i++)f[x][i]=f[f[x][i-1]][i-1];
	for(int i=head[x];i;i=e[i].nxt)
	{
		int y=e[i].to;
		if(y==pre)continue;
		f[y][0]=x;dfs(y,x);
	}
}
inline int lca(int x,int y)
{
	if(dep[x]>dep[y])swap(x,y);
	for(int i=t;~i;i--)if(dep[f[y][i]]>=dep[x])y=f[y][i];
	if(x==y)return x;
	for(int i=t;~i;i--)if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];
	return f[x][0];
}
signed main()
{
	scanf("%lld%lld%lld",&n,&m,&K);tot=n;t=(int)log2(2*n)+1;
	for(int i=1;i<=n;i++)scanf("%lld",&pos[i]);
	for(int i=1;i<=n;i++)scanf("%lld",&b[i]);
	for(int i=1;i<=m;i++)scanf("%lld%lld%lld",&E[i].u,&E[i].v,&E[i].w);
	if(K)scanf("%lld",&st);
	for(int i=1;i<K;i++){E[++m].u=st;scanf("%lld",&E[m].v);E[m].w=4234324294823;}
	kruscal();dfs(tot,0);
	int now=pos[1],ans=0;
	if(b[now]>0)ans+=b[now];
	else puts("0");
	for(int i=2;i<=n;i++)
	{
		ans=min(ans,val[lca(now,pos[i])]);
		if(b[pos[i]]>0)ans+=b[pos[i]];
		else 
		{
			b[pos[i]]=-b[pos[i]];
			printf("%lld\n",min(ans,b[pos[i]]));
			ans=max(ans-b[pos[i]],0LL);
		}
		now=pos[i];
	}
	return 0;
}
```


---

## 作者：hegm (赞：1)

重构树题目，非常简单啊。

[传送门](https://www.luogu.com.cn/problem/P3280)

很显然，让你顺次求两点的最小瓶颈路。

但是问题在于列车，可以使得最小瓶颈路被打乱。

考虑正常情况下的最小瓶颈路，走到两点的 $\text{LCA}$，然后返回 $\text{LCA}$ 的 $val$ 即可。

但是因为列车站的原因，我们的路径由 $u\to c\to v$ 变为了 $u\to a\to b\to v$。（其中 $c$ 为 $u,v$ 的 $\text{LCA}$，$a,b$ 均为列车车站）。

答案就变为了 

$ans=\max(val_c,\min(val_a,val_b))$。

那么我们怎么找每对 $u,v$ 的 $a,b$ 哪？

考虑实际过程，当 $u\to c$ 的倍增过程中。遇到了一个点 $d$，$d$ 的子树中包含了一个列车站点，那么答案一定不再是 $val_c$ 了，因为我们的 $deep_d>deep_c$，又因为重构树的性质，$deep$ 越大，说明 $val$ 越大。

那就好做多了，我们只需要更改下 $\text{Kruskal}$ 重构树的建树过程，对于一个重构点，多维护一个 $vis$ 表示子树中是否有列车车站即可。

那么我们就求出来了 $u,v$ 两点间的最小瓶颈路。

那么我们只需要按照顺序进行交易即可，

具体的，我们设 $now$ 表示当前的黄金数量，每到一个补充黄金的地点，我们就把 $now+=b_i$，每到一个卖出黄金的地点，我们就把 $now=\max(0,now+b_i)$。同时输出答案。

---

## 作者：xh2010 (赞：1)

看到这道题，很容易想起NOIP2013Day1的货车运输。

事实上，这道题和货车运输基本一样，不过加了些黄金买卖和列车。

首先，将存在列车的点全部缩起来；

然后再跑一遍最大生成树；

其次，在树上倍增；

最后，模拟一下即可。

下面献上丑陋的代码：























```cpp
program p3280;
type link=^node;
     node=record
       data,v:longint;
       next:link;
     end;
var e:array[0..200010,1..2] of longint;
    v,sh,xi,lie,fa,bel:array[0..200010] of longint;
    b:array[0..200010] of link;
    n,m,q:longint;
    d:array[0..100010] of longint;
    vis:array[0..100010] of boolean;
    f,g:array[0..100010,0..20] of longint;
function min(x,y:int64):int64;
begin
  if x<y then exit(x) else exit(y);
end;
procedure init;
var i,mint:longint;
begin
  readln(n,m,q);
  for i:=1 to n do
  begin
    read(sh[i]);
    bel[i]:=i;
  end;
  for i:=1 to n do
    read(xi[i]);
  for i:=1 to m do
    readln(e[i,1],e[i,2],v[i]);
  mint:=n;
  for i:=1 to q do
  begin
    read(lie[i]);
    if lie[i]<mint then mint:=lie[i];
  end;
  for i:=1 to q do
    bel[lie[i]]:=bel[mint];
end;
procedure swap(var x,y:longint);
var t:longint;
begin
  t:=x;
  x:=y;
  y:=t;
end;
procedure heap(nn,ii:longint);
var i,j,x,y,z:longint;
begin
  i:=ii;
  j:=2*i;
  x:=e[i,1];
  y:=e[i,2];
  z:=v[i];
  while j<=nn do
  begin
    if (v[j]>v[j+1]) and (j<nn) then inc(j);
    if z>v[j] then
    begin
      v[i]:=v[j];
      e[i,1]:=e[j,1];
      e[i,2]:=e[j,2];
      i:=j;
      j:=2*i;
    end
    else
      j:=nn+1;
  end;
  v[i]:=z;
  e[i,1]:=x;
  e[i,2]:=y;
end;
procedure heapsort;
var i:longint;
begin
  for i:=m div 2 downto 1 do
    heap(m,i);
  for i:=m downto 2 do
  begin
    swap(e[i,1],e[1,1]);
    swap(e[i,2],e[1,2]);
    swap(v[i],v[1]);
    heap(i-1,1);
  end;
end;
function get(x:longint):longint;
begin
  if fa[x]=x then
    exit(x)
  else
    fa[x]:=get(fa[x]);
  exit(fa[x]);
end;
procedure kruskal;
var i,x,y:longint;
    p:link;
begin
  for i:=1 to n do
    fa[i]:=i;
  for i:=1 to m do
  begin
    x:=bel[e[i,1]];
    y:=bel[e[i,2]];
    if get(x)<>get(y) then
    begin
      fa[get(x)]:=get(y);
      new(p);
      p^.data:=x;
      p^.v:=v[i];
      p^.next:=b[y];
      b[y]:=p;
      new(p);
      p^.data:=y;
      p^.v:=v[i];
      p^.next:=b[x];
      b[x]:=p;
    end;
  end;
end;
procedure dfs(x:longint);
var p:link;
begin
  p:=b[x];
  while p<>nil do
  begin
    if not vis[p^.data] and (get(p^.data)=get(x)) then
    begin
      vis[p^.data]:=true;
      d[p^.data]:=d[x]+1;
      f[p^.data,0]:=x;
      g[p^.data,0]:=p^.v;
      dfs(p^.data);
    end;
    p:=p^.next;
  end;
end;
function minw(x,y:longint):int64;
var j:longint;
    s1,s2:int64;
begin
  x:=bel[x];
  y:=bel[y];
  if x=y then exit(high(s1));
  if d[x]>d[y] then swap(x,y);
  s1:=high(s1);
  for j:=0 to 20 do
    if (d[y]-d[x]) and (1 shl j)<>0 then
    begin
      s1:=min(s1,g[y,j]);
      y:=f[y,j];
    end;
  if x=y then exit(s1);
  s2:=high(s2);
  for j:=20 downto 0 do
    if (f[x,j]<>f[y,j]) then
    begin
      s1:=min(s1,g[y,j]);
      s2:=min(s2,g[x,j]);
      y:=f[y,j];
      x:=f[x,j];
    end;
  s1:=min(s1,g[y,0]);
  s2:=min(s2,g[x,0]);
  exit(min(s1,s2));
end;
procedure main;
var i,j,pre,now:longint;
    gold,sale:int64;
begin
  heapsort;
  kruskal;
  fillchar(d,sizeof(d),0);
  fillchar(f,sizeof(f),0);
  for i:=1 to n do
    for j:=0 to 20 do
      g[i,j]:=maxlongint;
  fillchar(vis,sizeof(vis),false);
  vis[1]:=true;
  d[1]:=1;
  dfs(1);
  for j:=1 to 20 do
    for i:=1 to n do
    begin
      f[i,j]:=f[f[i,j-1],j-1];
      g[i,j]:=min(g[i,j-1],g[f[i,j-1],j-1]);
    end;
  pre:=sh[1];
  gold:=0;
  sale:=0;
  if xi[sh[1]]>=0 then
    gold:=gold+xi[sh[1]]
  else
    writeln(0);
  for i:=2 to n do
  begin
    now:=sh[i];
    if xi[now]>0 then
      gold:=min(gold,minw(pre,now))+xi[now];
    if xi[now]<0 then
    begin
      gold:=min(gold,minw(pre,now));
      sale:=min(gold,-xi[now]);
      writeln(sale);
      gold:=gold-sale;
    end;
    pre:=now;
  end;
end;
begin
  init;
  main;
end.
```

---

## 作者：gdf_yhm (赞：0)

[P3280](https://www.luogu.com.cn/problem/P3280)

### 思路

没有求买入了多少，所以可以当作每次把能买的全都买了，走在路上不行再扔。卖出时由题意能卖多少卖多少。

主要的问题是求从城到城最多能带多少东西。计算两点间路径的权值最小值而不在意距离，建最大生成树，把图改作树。通过倍增的方式，求 lca 时算路径权值的最小值。对于火车，可以理解为一条权值为 $\infty$ 的路。

### code

图论就像搭积木。

#### 1.处理火车

由于 $\infty$ 足够大，火车的边一定在最大生成树上。

```cpp
	while(p--){
		int u;
		u=read();
		if(!st)st=u;
		else{
			add(u,st,inf);add(st,u,inf);
			f[fd(u)]=fd(st);
			++cnt;
		}
	}
```

#### 2.生成树

```cpp
struct edge{
	int x,y,w;
}mp[maxn];
bool cmp(edge u,edge v){
	return u.w>v.w;
}
void add(int u,int v,int w){
	e[++tot].nxt=head[u];e[tot].to=v;e[tot].val=w;
	head[u]=tot;
}
```

结构体 mp 是原图的边，add 函数是生成树的链式前向星的加边。

```cpp
	for(int i=1;i<=m;i++){
		int u,v,w;
		u=read();v=read();w=read();
		mp[i].x=u;mp[i].y=v;mp[i].w=w;
	}
	for(int i=1;i<=n;i++)f[i]=i;
	sort(mp+1,mp+m+1,cmp);
	for(int i=1;i<=m;i++){
		if(fd(mp[i].x)!=fd(mp[i].y)){
			add(mp[i].x,mp[i].y,mp[i].w);add(mp[i].y,mp[i].x,mp[i].w);
			f[fd(mp[i].x)]=fd(mp[i].y);
			++cnt;
		}
		if(cnt==n-1)break;
	}
```

#### 3.倍增

$fa_{u,i}$ 表示 $u$ 的 $2^i$ 个祖先，$dis_{u,i}$ 表示 $u$ 到 $2^i$ 个祖先的路径上最小权值。

lca 跳公共祖先的同时计算路径上最小权值。

```cpp
int dep[maxn],fa[maxn][25],dis[maxn][25];
void dfs(int u,int ff){
	for(int i=1;1<<i<=dep[u];i++){
		fa[u][i]=fa[fa[u][i-1]][i-1];
		dis[u][i]=min(dis[u][i-1],dis[fa[u][i-1]][i-1]);
	}
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v!=ff){
			dep[v]=dep[u]+1;
			fa[v][0]=u;dis[v][0]=e[i].val;
			dfs(v,u);
		}
	}
}
int lca(int u,int v){
	int ans=inf;
	if(dep[u]!=dep[v]){
		if(dep[u]<dep[v])swap(u,v);
		for(int i=log2(dep[u]);i>=0;i--){
			if(dep[fa[u][i]]>dep[v]){
				ans=min(ans,dis[u][i]);
				u=fa[u][i];
			}
		}
		ans=min(ans,dis[u][0]);u=fa[u][0];
	}
	if(u==v)return ans;
	for(int i=log2(dep[u]);i>=0;i--){
		if(fa[u][i]!=fa[v][i]){
			ans=min({ans,dis[u][i],dis[v][i]});
			u=fa[u][i];v=fa[v][i];
		}
	}
	ans=min({ans,dis[u][0],dis[v][0]});
	return ans;
}
```

#### 4.计算答案

$sum$ 表示当前手中的货物重量，$lim$ 表示从城到城最多的通行重量。

```cpp
	if(b[a[1]]>0)sum=b[a[1]];
	else printf("0\n");
	for(int i=2;i<=n;i++){
		lim=lca(a[i-1],a[i]);
		if(sum>lim)sum=lim;//inf要足够大。
		if(b[a[i]]>0)sum+=b[a[i]];
		else{
			printf("%lld\n",min(sum,-b[a[i]]));
			sum-=min(sum,-b[a[i]]);
		}
	}
```

---

## 作者：NinT_W (赞：0)

## 【SCOI 2013】摩托车交易

思路就是kruskal重构树和树剖

对于题目给出的两种限制，我们完全可以不考虑，因为买入交易是不需要输出的

我们完全可以每次贪心的全拿走，全卖出，然后路上扔掉拿不了的（被限制住的），而有列车站的城市之间可以拿无穷多的黄金，那么两种限制就没有存在的意义，唯一的限制就是路径边权

所以问题可以变为给出一个图，让你使其连通，然后还要求两点之间的边权尽量大，我们可以求一个最大生成树，让边权为高速的载重限制，列车站之间的边权设为INF

那么我们每次能携带的黄金数量就等于上一个城市到这个城市经过的所有边的最小边权和现在有的黄金数量的较小值，路径上边权最小值可以用树剖求解

然后这题就切了QwQ

AC code
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
#include<climits>
#include<cstdlib>
#define int long long

using namespace std;

const int maxn=2e5+5;

inline int read()
{
    int w=0,f=1;
    char ch=getchar();
    while(ch<'0' || ch>'9')
    {
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9')
    {
        w=(w<<3)+(w<<1)+(ch^48);
        ch=getchar();
    }
    return w*f;
}

int now_money;
int root,cnt;
int n,m,q,tot;
int head[maxn];
int b[maxn];
int fa[maxn];
int order[maxn];
struct edge
{
    int from,to,val;
}e[maxn*3];
struct node
{
    int to,next,val;
}edg[maxn*3];

bool cmp(edge a,edge b)
{
    return a.val>b.val;
}

void add(int x,int y,int z)
{
    edg[++tot].to=y;
    edg[tot].next=head[x];
    edg[tot].val=z;
    head[x]=tot;
}

int find(int x)
{
    if(x==fa[x]) return x;
    else return fa[x]=find(fa[x]);
}

void merger(int x,int y)
{
    if(rand()%2) fa[x]=y;
    else fa[y]=x;
}

void kruskal()
{
    for(int i=1;i<=n;i++) fa[i]=i;
    sort(e+1,e+m+max(q,1ll),cmp);cnt=0;
    for(int i=1;i<=m+max(q,1ll)-1;i++)
    {
        int u=find(e[i].from);
        int v=find(e[i].to);
        if(u==v) continue;
        merger(u,v);cnt++;
        add(e[i].from,e[i].to,e[i].val);
        add(e[i].to,e[i].from,e[i].val);
        if(cnt==n-1) break;
    }
}

int a[maxn];
int id[maxn],val[maxn];
int siz[maxn],deep[maxn];
int max_son[maxn],top[maxn];

struct s_t
{
    int l,r;
    int val;
}t[maxn*4];

void dfs_first(int x,int f)
{
    siz[x]=1;fa[x]=f;
    deep[x]=deep[f]+1;
    for(int i=head[x];i;i=edg[i].next)
    {
        int to=edg[i].to;
        if(to==f) continue;
        val[to]=edg[i].val;
        dfs_first(to,x);
        siz[x]+=siz[to];
        if(siz[to]>siz[max_son[x]])
        {
            max_son[x]=to;
        }
    }
}

void dfs_second(int x,int t)
{
    id[x]=++tot;top[x]=t;
    a[tot]=val[x];
    if(!max_son[x]) return ;
    dfs_second(max_son[x],top[x]);
    for(int i=head[x];i;i=edg[i].next)
    {
        int to=edg[i].to;
        if(to!=fa[x] && to!=max_son[x])
        {
            dfs_second(to,to);
        }
    }
}

void build(int p,int l,int r)
{
    t[p].l=l,t[p].r=r;
    if(l==r)
    {
        t[p].val=a[l];
        return ;
    }
    int mid=(l+r)>>1;
    build(p*2,l,mid);
    build(p*2+1,mid+1,r);
    t[p].val=min(t[p*2].val,t[p*2+1].val);
}

int query(int p,int l,int r)
{
    if(l<=t[p].l && t[p].r<=r) return t[p].val;
    int mid=(t[p].l+t[p].r)>>1;int ans=LLONG_MAX;
    if(l<=mid) ans=min(ans,query(p*2,l,r));
    if(r>mid) ans=min(ans,query(p*2+1,l,r));
    return ans;
}

int get_min(int x,int y)
{
    int ans=LLONG_MAX;
    while(top[x]!=top[y])
    {
        if(deep[top[x]]<deep[top[y]]) swap(x,y);
        ans=min(ans,query(1,id[top[x]],id[x]));
        x=fa[top[x]];
    }
    if(deep[x]>deep[y]) swap(x,y);
    ans=min(ans,query(1,id[x]+1,id[y]));
    return ans;
}

signed main()
{
    n=read();
    m=read();
    q=read();

    for(int i=1;i<=n;i++) order[i]=read();
    for(int i=1;i<=n;i++) b[i]=read();

    for(int i=1;i<=m;i++)
    {
        e[i].from=read();
        e[i].to=read();
        e[i].val=read();
    }

    for(int i=1;i<=q;i++)
    {
        if(i==1) root=read();
        else 
        {
            e[m+i-1].from=root;
            e[m+i-1].to=read();
            e[m+i-1].val=LLONG_MAX;
        }
    }

    kruskal();
    tot=0,dfs_first(1,0);
    tot=0,dfs_second(1,1);

    build(1,1,n);

    now_money=b[order[1]];
    if(now_money<=0)
    {
        now_money=0;
        cout<<0<<endl;
    }

    for(int i=2;i<=n;i++)
    {
        now_money=min(get_min(order[i],order[i-1]),now_money);
        if(b[order[i]]<0) 
        {
            cout<<min(now_money,-b[order[i]])<<endl;
            now_money-=min(now_money,-b[order[i]]);
        }
        else
        {
            now_money+=b[order[i]];
        }
    }

    return 0;
}
```


---

## 作者：Thunder_S (赞：0)

# 简化题意
给出一个 $n$ 个点 $m$ 条边的无向图，边有边权，点有点权，点权有正有负。给出一个顺序，要求**按照顺序经过每个点**，在每个点买入或卖出一定量的黄金，但买入或卖出的数量不得超过点权绝对值。在运输过程中**经过每条边时黄金数量不得超过边权**，黄金不可丢弃，数量任意时刻都不可为负，**在结束后黄金数量需要为0**。另外有 $k$ 个铁路站，**任意两个铁路站之间有一条铁路，铁路不设运载上限**。求能达到销售最大值的方案，若销售值相同，则字典序大的优先。

# Solution

要求总销售量最大，那么在从一个点到另一个点的过程中走限重大的点显然比走限重小的优，因为如果走限重小的边到达另一个点时携带的黄金数量肯定会少，所以要尽量往限重大的边走。因此走的边只会在最大生成树上。而铁路的话就相当于没有运载上限的公路，但是用 $O(n^2)$ 的时间连边显然不现实，所以设一个铁路总站，让每个铁路站点连向总站，上限为 $\inf$ ，这样的话就可以通过总站这个中转点来连接各个铁路站点，同时由于总站连向站点的上限是 $\inf$，所以这些边必然出现在最大生成树上。

将图转换成树后，在运输过程中，从一个点往另一个点走，到了另一个点时剩下的黄金数量肯定是这条路径上的最小值，所以用倍增在遍历过程中求出最小值。

考虑一种贪心，虽然题目要求不能丢弃，但是既然只求销售方案，我们可以在买的地方全买，某条路走不过就丢弃，到了最后也丢弃，因为你买了然后丢掉了相当于你一开始没买，对答案是不影响的，这样就可以保证总销售量最大且在前面的销售额尽量大。

因此思路为

- 将每个铁路站点连一条 $\inf$ 的边到总站
- 求出整个图的最大生成树（包括铁路总站）。
- 按照给定顺序模拟，遇到买的全买，遇到卖的能卖多少是多少，并输出销售额。
- 走路径的途中遇到走不过的就丢掉，即求这条路径上的最小值，用倍增即可。

# Code

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define inf 891234567987654321
#define ll long long
#define N 100005
using namespace std;
struct krus
{
	int x,y;
	ll val;
}Krus[N*3];
struct node
{
	int head,next,to;
	ll val;
}a[N*6];
int n,m,q,x,y,tot,xx,yy,w[N],fa[N<<1][20],deep[N],father[N];
ll z,ans,c[N],f[N<<1][20];
bool cmp(krus x,krus y) {return x.val>y.val;}
int find(int x)
{
	if (father[x]!=x) father[x]=find(father[x]);
	return father[x];
}
void add(int x,int y,ll z)
{
	a[++tot].to=y;
	a[tot].val=z;
	a[tot].next=a[x].head;
	a[x].head=tot;
}
void dfs(int now,int Fa,ll val)
{
	deep[now]=deep[Fa]+1;
	fa[now][0]=Fa;
	f[now][0]=val;
	for (int i=a[now].head;i;i=a[i].next)
	{
		int u=a[i].to;
		ll v=a[i].val;
		if (u==Fa) continue;
		dfs(u,now,v);
	}
}
int LCA(int x,int y)
{
	if (deep[x]!=deep[y])
	{
		if (deep[x]<deep[y]) swap(x,y);
		for (int i=17;i>=0;--i)
		{
			if (deep[fa[x][i]]>deep[y]) x=fa[x][i];
		}
		x=fa[x][0];
	}
	if (x==y) return x;
	for (int i=17;i>=0;--i)
	{
		if (fa[x][i]!=fa[y][i])
		{
			x=fa[x][i];
			y=fa[y][i];
		}
	}
	return fa[x][0];
}
ll get(int x,int y)
{
	int lca=LCA(x,y);
	ll res=inf;
	for (int i=17;i>=0;--i)
	{
		if (deep[fa[x][i]]>deep[lca])
		{
			res=min(res,f[x][i]);
			x=fa[x][i];
		}
		if (deep[fa[y][i]]>deep[lca])
		{
			res=min(res,f[y][i]);
			y=fa[y][i];
		}
	}
	if (x!=lca) res=min(res,f[x][0]);
	if (y!=lca) res=min(res,f[y][0]);
	return res;
}//求出路径上的最小值
int main()
{
	scanf("%d%d%d",&n,&m,&q);
	for (int i=1;i<=n;++i)
		scanf("%d",&w[i]);
	for (int i=1;i<=n;++i)
		scanf("%lld",&c[i]);
	for (int i=1;i<=m;++i)
	{
		scanf("%d%d%lld",&x,&y,&z);
		Krus[i].x=x;Krus[i].y=y;Krus[i].val=z;
	}
	for (int i=1;i<=q;++i)
    		scanf("%d",&x),Krus[m+i].x=x,Krus[m+i].y=n+1,Krus[m+i].val=inf;
	sort(Krus+1,Krus+m+q+1,cmp);
	for (int i=1;i<=n+1;++i)
		father[i]=i;
	for (int i=1;i<=m+q;++i)
	{
		x=Krus[i].x;y=Krus[i].y;
		xx=find(x);yy=find(y);
		if (xx!=yy)
		{
			father[xx]=yy;
			add(x,y,Krus[i].val);
			add(y,x,Krus[i].val);
		}
	}//处理出最大生成树
	memset(fa,0,sizeof(fa));
	dfs(1,0,0);
	for (int j=1;j<=17;++j)
		for (int i=1;i<=n+1;++i)
		{
			fa[i][j]=fa[fa[i][j-1]][j-1];
			f[i][j]=min(f[i][j-1],f[fa[i][j-1]][j-1]);
		}//倍增基本操作
	ans=0;
	for (int i=1;i<=n;++i)
	{
		x=w[i];
		if (c[x]>0) ans+=c[x];//全部买入
		else
		{
			printf("%lld\n",min(-c[x],ans));//能卖多少卖多少
			ans=max(ans+c[x],(ll)0);//更新黄金数量
		}
		if (i<n) ans=min(ans,get(w[i],w[i+1]));//走路径
	}//模拟
	return 0;
}
```



---

## 作者：ww3113306 (赞：0)

kruskal重构树+倍增+贪心

这题想法简单，，，然而，找了几个小时的错误结果是inf没开到LL范围。。。。

　　首先我们需要找到任意两点之间能够携带黄金的上限值，因为是在经过的道路权值中取min，我们要使得这个min值最大，就应该要在最大生成树上寻找正确的边。求出最大生成树后我们需要在上面倍增寻找权值最小的边，这条边的权值即为携带黄金的上限值。

　　于是你可以写最大生成树也可以写kruskal重构树，这里我写的是kruskal重构树，这样以来，因为kruskal重构树的性质，我们只需要寻找对应2个节点的lca，这个lca的点权即为我们要找的值。

　　但是注意到题中有一些点可以被列车连通，因为在这些被联通的点之间移动不会带来任何限制，因此我们可以把这些有列车的节点看做一个点（缩点）

　　然后注意到题目要求的仅仅是每个卖黄金的地方卖出的黄金数，而且在任意地方买卖的黄金并没有任何其他限制（如价格之类的），因此我们可以每到一个地方就买光所有黄金，然后如果带不到下一个地方去，我们就当我们之前没买过，对道路的上限取min即可。如果最后黄金有剩余，我们也可以直接当做我们没买过。

　　于是这题就做完了。
  
~~不要脸的宣传一波~~[my blog](https://www.cnblogs.com/ww3113306/p/9806422.html)

```cpp
#include<bits/stdc++.h>
using namespace std;
#define R register int
#define AC 501000
#define ac 1001000
#define LL long long
#define inf 1000000000000000LL//!!!!!!!!!!!!!!!!!!!!!
/*因为只需要关心卖出了多少，所以遇到买入的就能买就买，如果要丢弃就当我没买过，
如果有剩余也当我没买过，然后有列车的点可以相互到达，所以就缩点缩起来，然后有路上有负载上限，
所以就跑最大生成树(重构树)，然后倍增查最大上限是多少，把剩余黄金对上限取min即可。*/

int n, m, q, cnt, who;
LL have;
int Head[ac], date[ac], Next[ac], tot;
int father[AC], vis[AC], belong[AC], dep[ac];
LL f[ac][21], power[ac];//点权or边权(叶节点就是点权，不然就是边权)

struct road{
    int x, y;LL dis; 
}way[ac];

inline bool cmp(road a, road b){
    return a.dis > b.dis;
}

inline int read()
{
    int x = 0;char c = getchar(); bool z = false;
    while(c > '9' || c < '0') {
        if(c == '-') z = true;
        c = getchar();
    }
    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    if(!z) return x;
    else return -x;
}

inline int find(int x){
    if(father[x] == x) return x;
    else return father[x] = find(father[x]);
}

inline void add(int f, int w){
    date[++tot] = w, Next[tot] = Head[f], Head[f] = tot, father[w] = f;    
    //printf("%d ---> %d : %d\n", f, w, power[cnt]);
}

inline void upmin(LL &a, LL b){
    if(b < a) a = b;
}

void kruskal()//重构树
{
    int b = 2 * n;
    for(R i = 1; i <= b; i ++) father[i] = i;
    for(R i = 1; i <= m; i ++)
    {
        int fx, fy;
        fx = find(belong[way[i].x]), fy = find(belong[way[i].y]);
        if(fx == fy) continue;
        power[++cnt] = way[i].dis;
        //printf("%d %d %d\n", way[i].x, way[i].y, way[i].dis);        
        add(cnt, fx), add(cnt, fy);
    }    
    power[cnt + 1] = inf, dep[cnt] = 1, f[cnt][0] = cnt;
}

void dfs(int x)//倍增
{
    int now;
//    printf("!!!%d\n", power[x]);
    for(R i = 1; i <= 20; i ++)
        f[x][i] = f[f[x][i - 1]][i - 1];
    for(R i = Head[x]; i; i = Next[i])
        now = date[i], f[now][0] = x, dep[now] = dep[x] + 1, dfs(now);
}

int lca(int x, int y)//要先倍增找到最小上限
{
    if(dep[x] < dep[y]) swap(x, y);
    for(R i = 20; i >= 0; i --)
        if(dep[f[x][i]] >= dep[y]) x = f[x][i];
    for(R i = 20; i >= 0; i --)
        if(f[x][i] != f[y][i]) 
            x = f[x][i], y = f[y][i];
    if(x != y) return power[f[x][0]];
    else return power[x];
}

void go(int f, int w)
{
    LL lim = (belong[f] == belong[w]) ? inf : lca(belong[f], belong[w]);
    /*if(find(belong[f]) != find(belong[w])) 
    {
        for(R i = w; i <= n; i ++) printf("0\n");
        exit(0);
    }*/
    upmin(have, lim);
    if(power[w] > 0) have += power[w];
    else 
    {
        if(have > - power[w]) 
            have += power[w], printf("%lld\n", -power[w]);
        else printf("%lld\n", have), have = 0; 
    }
}

void pre()
{
    n = cnt = read(), m = read(), q = read();
    for(R i = 1; i <= n; i ++) vis[i] = read(), belong[i] = i;//读入每个城市的访问顺序
    for(R i = 1; i <= n; i ++) power[i] = read();//读入每个城市的订单
    for(R i = 1; i <= m; i ++)//读入边
        way[i].x = read(), way[i].y = read(), way[i].dis = read();
    for(R i = 1; i <= q; i ++)//读入有列车的城市
    {
        int a = read();
        if(!who) who = a;
        belong[a] = who;
    }
    sort(way + 1, way + m + 1, cmp);
}

void work()
{
    if(power[vis[1]] > 0) have = power[vis[1]];
    else printf("0\n");
    for(R i = 1; i < n; i ++) go(vis[i], vis[i + 1]);
}

int main()
{
//    freopen("in.in", "r", stdin);
    pre();
    kruskal();
    dfs(cnt);
    work();
//    fclose(stdin);
    return 0;
}
```

---


# [CTSC2011] 幸福路径

## 题目描述

有向图 $G$ 有 $n$ 个顶点 $1, 2, \cdots, n$，点 $i$ 的权值为 $w(i)$。

现在有一只蚂蚁，从给定的起点 $v_0$ 出发，沿着图 $G$ 的边爬行。开始时，它的体力为 $1$。每爬过一条边，它的体力都会下降为原来的 $\rho$ 倍，其中 $\rho$ 是一个给定的小于 $1$ 的正常数。而蚂蚁爬到某个顶点时的幸福度，是它当时的体力与该点权值的乘积。 

我们把蚂蚁在爬行路径上幸福度的总和记为 $H$。很显然，对于不同的爬行路径，$H$ 的值也可能不同。小 Z 对 $H$ 值的最大可能值很感兴趣，你能帮助他计算吗？注意，蚂蚁爬行的路径长度可能是无穷的。

## 说明/提示

对于 $100\%$ 的数据，$1\leq n \le 100$，$1\leq m \le 1000$，$0 < \rho \le 1 - 10^{-6}$，$0\leq w(i) \leq 100$。

## 样例 #1

### 输入

```
5 5 
10.0 8.0 8.0 8.0 15.0 
1 
0.5 
1 2 
2 3 
3 4 
4 2 
4 5```

### 输出

```
18.0```

# 题解

## 作者：hsfzLZH1 (赞：16)

至今为止，本题的所有题解都利用了本题的一个特性：答案在精度范围内即可。但是，如果去掉这个特性，比如要求输出为分数的形式，那么就要求出 **精确解** ，这时有没有优秀的解法呢？本篇题解给出的就是这样的解法。

首先给出 **性质：** 若答案路径的长度有限，则必不经过重复的点；若答案路径的长度无限，则必为先走一条有限的路径（长度可能为 $0$ ），然后不停走一个环，有限路径和该环中都没有重复的点。

**证明：** 因为所有点的权值都是正的，所以多走一步肯定有收益，能走的时候肯定会走。若从一个点开始已经走了一个环，那接下来肯定会继续走经过这个点的环，若经过的是和之前不同的环，那我们从一开始就不停地走这个环，一定更优。在我们从起点走到无限走的单环的路径上，如果存在重复的点，那么就存在环，要么不走这个环，要么一直走这个环，其中一定有比当前方案优的。

根据性质，我们有这样的解法：定义 $f[i][j][k]$ 表示从 $i$ 到 $j$ ，经过 $k$ 个点（可以重复），不包括结点 $i$ 所得的最大收益。之前指出，最优路径中没有重复的点，所以需要计算的 $k\le n$ 。我们知道 $f[i][i][0]=0$ ，状态转移方程为 $f[i][v][k]=\max\{f[i][u][k-1]+w[v]\times \rho^k \}$ （若从 $u$ 到 $v$ 有边）。定义 $c[i]$ 表示从 $i$ 开始不停走环的最大收益（若无环则值为 $0$ ），由等比数列求和公式有 $c[i]=\max\{\frac {f[i][i][k]} {1-\rho^k}\}$ 。

最后，我们枚举有限路径的终点，枚举走到该终点的步数，最后加上最优的环的价值，就可求得答案。

预处理 $\rho$ 的幂的值，计算 $f$ 数组的时间复杂度为 $O(n^2m)$ ，计算 $c$ 数组的时间复杂度为 $O(nm)$ ，根据两数组求答案的时间复杂度为 $O(n^2)$ 。空间复杂度为 $O(n^3)$ 。

### 参考代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=110;
const double inf=2e9;
int n,m,v0,x,y,g[maxn][maxn];
double w[maxn],rho,f[maxn][maxn][maxn],c[maxn],pww[maxn],ans; 
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%lf",w+i);
	scanf("%d%lf",&v0,&rho);
	pww[0]=1.0;for(int i=1;i<=n+1;i++)pww[i]=pww[i-1]*rho;
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=0;k<=n;k++)f[i][j][k]=-inf;
	for(int i=1;i<=n;i++)f[i][i][0]=0; 
	while(m--)scanf("%d%d",&x,&y),g[x][y]=1;
	for(int k=1;k<=n;k++)for(int j=1;j<=n;j++)for(int t=1;t<=n;t++)if(g[j][t])
	for(int i=1;i<=n;i++)if(f[i][j][k-1]>=-1e-6)f[i][t][k]=max(f[i][t][k],f[i][j][k-1]+pww[k]*w[t]);
	for(int i=1;i<=n;i++)for(int k=1;k<=n;k++)if(f[i][i][k]>=-1e-6)c[i]=max(c[i],f[i][i][k]/(1.0-pww[k]));
	for(int i=1;i<=n;i++)for(int k=0;k<=n;k++)ans=max(ans,w[v0]+f[v0][i][k]+c[i]*pww[k]);
	printf("%.1lf\n",ans);
	return 0;
}
```

---

## 作者：优秀的渣渣禹 (赞：16)

题目大意：

给定一张有向图，每个点有个权值，蚂蚁从某个点开始，初始体力为1，每经过一条边，体力会变为原来的p(0 < p < 1)倍，每爬到一个点，获得的幸福度为该点的权值乘上体力。求蚂蚁幸福度的最大值，保留一位小数。
    
这道题最开始拿到的时候想到用期望dp，然后自己推出了一个式子，感觉没什么问题，交上去之后发现只得了40分，然鹅不造哪里错了。
    最后看到大佬们都用FLOYD做的。

	考虑到体力是按指数级衰减的，所以我们只要做下面的一个dp就可以解决问题了。

	令f[t][i][j]表示走2t步，从i走到j获得的最大幸福度。
	
    f[t][i][j] = max(f[t - 1][i][k] + f[t - 1][k][j] * p2t - 1)
当t足够大时，f得到的就近似为最大幸福度，或者说当p < eps 时，得到的就近似为最大幸福度。


下面是代码

```cpp
#define B cout << "BreakPoint" << endl;
#define O(x) cout << #x << " " << x << endl;
#define O_(x) cout << #x << " " << x << "  ";
#define Msz(x) cout << "Sizeof " << #x << " " << sizeof(x)/1024/1024 << " MB" << endl;
#include <cstdio>
#include <cstring>
#include <algorithm>
#define N 110
using namespace std;
int n,m,s;
double p,ans,v[N],f[N][N],dp[N][N];
void read1(){
    scanf("%d%d",&n,&m);
    for(int i = 1; i <= n; i++)
        scanf("%lf",&v[i]);
    scanf("%d",&s);
    scanf("%lf",&p);
    return ;
}
void read2(){
    while(m--) {
        int u,x;
        scanf("%d%d",&u,&x);
        f[u][x] = v[x] * p;
    }
}
void init(){
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
            if(i != j)
                f[i][j] = -1e100;
    return ;
}
void solve(){
    for(; p > 1e-10; p *= p) {
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= n; j++)
                dp[i][j] = -1e100;
        for(int k = 1; k <= n; k++)
            for(int i = 1; i <= n; i++)
                for(int j = 1; j <= n; j++)
                    dp[i][j] = max(dp[i][j],f[i][k]+f[k][j]*p);
        memcpy(f,dp,sizeof(dp));
    }
    return ;
}
void print(){
    for(int i = 1; i <= n; i++)
        ans = max(ans,f[s][i]);
    printf("%.1f\n",ans + v[s]);
    return ;
}
int main() {
    read1();
    init();
    read2();
    solve();
    print();
    return 0;
}
```


---

## 作者：shadowice1984 (赞：9)

倍增floyd大法好……

我们设$Dp_{i,j,k}$表示从i出发到j长度为$2^k$的简单路径的最大H值和

那么转移方程就是，我们枚举i和j中间的接口t进行转移

## $Dp_{i,j,k}=max_{t=1}^{n}(Dp_{i,t,k-1}+P^{2^{k-1}}Dp_{t,j,k-1})$

边界条件

## $Dp_{i,j,0}=Pw_{j}$

另外一点需要注意的是我们还需要通过倍增floyd传递闭包求出i到t，t到j之间是否存在一条长度为$2^{k-1}$的有向路径，从而判定刚才的dp方程是否可以完成转移

然后问题来了，我们这样下去循环是会无限进行下去的，什么时候终止循环呢？

# 醒醒，这道题是输出实数！

这意味这我们无需求出精确值，只需要求出一(和)个(std)足(错)够(的)精(一)确(样)的解就可以了

因此，我们只需要当$P^{2^{k-1}}$小于eps的时候中止循环就可以了……

上代码~

```C
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
using namespace std;const int N=110;typedef long double ld;const ld eps=1e-10;
ld p;ld w[N];ld mp[N][N];ld tr1[N][N];bool lt[N][N];bool lt1[N][N];int n;int m;int st;ld res=0;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%Lf",&w[i]);
    scanf("%d",&st);scanf("%Lf",&p);
    for(int i=1,u,v;i<=m;i++){scanf("%d%d",&u,&v);mp[u][v]+=w[v]*p;lt[u][v]=true;}
    while(p>eps)
    {
        for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)tr1[i][j]=mp[i][j];
        for(int i=1;i<=n;i++)//传递闭包
            for(int k=1;k<=n;k++)
                for(int j=1;j<=n;j++)
                    if(lt[i][k]&&lt[k][j])mp[i][j]=max(mp[i][j],tr1[i][k]+p*tr1[k][j]);
        for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)lt1[i][j]=lt[i][j];
        for(int i=1;i<=n;i++)//dp
            for(int k=1;k<=n;k++)
                for(int j=1;j<=n;j++)lt[i][j]=lt[i][j]||(lt1[i][k]&&lt1[k][j]);p*=p;
    }
    for(int i=1;i<=n;i++)res=max(res,mp[st][i]);printf("%.1Lf",res+w[st]);return 0;//拜拜程序~
}
````






---

## 作者：asdfo123 (赞：8)

## 这道题我们用倍增Floyd逼近答案
观察题意，$n<=100$，想到$Floyd$做法。

考虑到体力衰减很快，所以我们只要做有限次数的 $dp$ 即可

但是直接暴力枚举步数会超时，我们考虑上倍增

令 $f[t][i][j]$ 表示走 $2^t$ 步，从 $i$ 走到 $j$ 获得的最⼤幸福度。

很容易想到转移方程式
　　
$$f[t][i][j]=max(f[t-1][i][k]+f[t-1][k][j] \times p
 ^{2^{(t-1)}})$$

当 $t$ 足够大时， $f$ 得到的就近似为最大的幸福值。

或者说当 $p<eps$ 时，得到的就近似为最大的幸福值。

一般来说 $eps$ 往精度下取三四位即可。

最后别忘了要把初始点的幸福度加上。
### 代码：
```cpp
//幸福路径
#include <bits/stdc++.h>
using namespace std;
double f[40][105][105];
double p;
double a[105];
int n,m;
int s;
double ans;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i <= n;i++)
	{
		scanf("%lf",&a[i]);
		f[0][i][i] = 0;
	}
	scanf("%d",&s);
	scanf("%lf",&p);
	for(int q = 0;q <=35;q++)
		for(int i = 1;i <= n;i++)
			for(int j = 1;j <= n;j++)
				if(i!=j) f[q][i][j] = -2e9;
	for(int i = 1;i <= m;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		f[0][x][y] = a[y]*p;
	}	
	for(int q = 1;q <= 35&&p>1e-10;q++)
	{
		for(int k = 1;k <= n;k++)
		{
			for(int i = 1;i <= n;i++)
			{
				for(int j = 1;j <= n;j++)
				{
					if(f[q][i][j] < f[q-1][i][k] + f[q-1][k][j]*p)
					f[q][i][j] = f[q-1][i][k] + f[q-1][k][j]*p;
					if(i==s)  if(f[q][i][j]>ans) ans=f[q][i][j];
				}
			}
		}
		p*=p;
	}
	printf("%.1lf",ans+a[s]);
	return 0;
}

	
```


---

## 作者：于丰林 (赞：4)

题目大意：

给定一个有向图，每一个点都有一个点权，给出起点，每一次移动体力值都会减小为原来的p倍，得到的权值就是当时的体力和该点点权之积，求最大的权值之和。

对于这道题，我们可以这样想：由于我们不断的往下走，每一次相对之前增加量就会越来越小，那么我们走很远很远的路径之后，我们就可以看作达到最大值了（也就是远小于精度之后）。

我们定义f[i][j][k]代表从i到j的最大幸福度，而k代表的是迭代的次数，那么当k到达一定的大小的时候，我们就可以认为是答案了

那么我们如何进行迭代呢?我们首先设定起始状态，就是每一个边的到达点的点权乘以p，然后我们逐步减小p，每一次都利用flyod的思想，枚举中间接口，动态转移方程就是f[i][j][cnt]=max(f[i][j][cnt],f[i][k][cnt-1]+f[k][j][cnt-1]*p)

而关于记录答案，我们只要当i等于起点时，和当时的ans取一个max就行了。。。

注意处理细节，给每一个点连一个f[i][i][0]=0，因为题目中说有自环。

最后，附上本题代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cstring>
using namespace std;
//Debug Yufenglin
#define dej printf("Running\n");
#define dep1(x) cout<<#x<<"="<<x<<endl;
#define dep2(x,y) cout<<#x<<"="<<x<<' '<<#y<<"="<<y<<endl;
#define dep3(x,y,z) cout<<#x<<"="<<x<<' '<<#y<<"="<<y<<' '<<#z<<"="<<z<<endl;

//Standfor Yufenglin
#define LL long long
#define LB long double
#define reg register
#define il inline
#define inf 1e8
#define maxn 100
#define maxm 40

int n,m,v;
LB ans,f[maxn+5][maxn+5][maxm],w[maxn+5];
LB p;

int main()
{
    memset(f,-0x1f,sizeof(f));
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%Lf",&w[i]);
        f[i][i][0]=0;
    }
    scanf("%d%Lf",&v,&p);
    for(int i=1;i<=m;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        f[x][y][0]=p*w[y];
    }
    for(int cnt=1;cnt<=25;cnt++)
    {
        for(int k=1;k<=n;k++)
        {
            for(int i=1;i<=n;i++)
            {
                for(int j=1;j<=n;j++)
                {
                    f[i][j][cnt]=max(f[i][j][cnt],f[i][k][cnt-1]+f[k][j][cnt-1]*p);
                    if(i==v) ans=max(ans,f[i][j][cnt]);
                }
            }
        }
        p*=p;
    }
    printf("%.1Lf\n",w[v]+ans);
    return 0;
}
```


---

## 作者：thomaswmy (赞：1)

# [原题链接](https://www.luogu.com.cn/problem/P4308)

## 题目大意

在一张有向图里，一只蚂蚁从起点出发，每经过一个点幸福值增加点权乘以体力值(体力值最开始为一，每经过一条边变为原来的 $p$ ( $1 > p >0$ )倍)，问幸福值最大可以是多少，答案保留一位小数。

## 题目分析

[同机房的巨佬](https://www.luogu.com.cn/user/419266)想找到一条路径加一个环，~~吓得我瑟瑟发抖~~但这一题不用这么麻烦。由于精度不高，我们只要用倍增 Floyd 逼近答案就好了。

令 $dp_{t,i,j}$ 表示从 $i$ 走到 $j$ ，走了 $2^t$ 步能达到的最大值

那么 $dp_{t,i,j}=\max(dp_{t-1,i,k}+dp_{t-1,k,j} \times p^{2^{t-1}})$

上代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=110;
const double eps=1e-4;//精度

int n,m,v0;
double w[N],p;
double dp[110][N][N];
double ans;

int main() {
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) {
		scanf("%lf",&w[i]);
	}
	scanf("%d",&v0);
	scanf("%lf",&p);
	for(int i=0;i<=100;i++) {//一定要记得初始化
		for(int j=1;j<=n;j++) {
			for(int k=1;k<=n;k++) {
				dp[i][j][k]=-1e9;
			}
			dp[i][j][j]=0;
		}
	}
	ans=0;
	for(int i=1;i<=m;i++) {
		int x,y;
		scanf("%d%d",&x,&y);
		dp[0][x][y]=w[y]*p;
		if(x==v0) ans=max(ans,w[y]*p);
	}
	double pp=1;
	int cnt=1;
	while(pp>eps && cnt<=100) {
		for(int k=1;k<=n;k++) {
			for(int i=1;i<=n;i++) {
				for(int j=1;j<=n;j++) {
					dp[cnt][i][j]=max(dp[cnt][i][j],dp[cnt-1][i][k]+dp[cnt-1][k][j]*p);
					if(i==v0) ans=max(ans,dp[cnt][i][j]);
				}
			}
		}
		p*=p;
		cnt++;
	}
	printf("%.1lf",ans+w[v0]);
	return 0;
}
```

---

## 作者：ZDQ2011 (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/P4308)
### 问题描述
- 一个 $n$ 个点 $m$ 条边的向图，每个点有一个权值，蚂蚁从某个点开始，初始体力为 $1$，没经过一条边，体力会变为原来的 $ρ (0 < ρ < l)$ 倍。
- 每经过一个点，会得到一个幸福值，为它当时的体力与该点权值 $w[i]$ 的乘积。
- 问：走过的路径中，幸福值之和最大是多少。
- 数据范围：$n \leq 100, m \leq 1000, ρ \leq 1 - 10 ^ 6, w[i] \leq 100$
-------
### 思路
因为只要走过一个点就会有幸福值，那么肯定是走的点越多越好。那么如何在代码中体现这种贪心的思想呢？

假如定义 $dp[i][j][k]$ 表示从 $i$ 走到 $j$ ，走了 $k$ 步的最大幸福值之和。

$dp$ 数组的更新类似于 $floyd$ 算法的方式转移状态。当 $ρ$ 小于某个精度时，因为不会影响总贡献，所以结束状态转移。

这样枚举的时间相对较长，那么怎么优化呢？此处就用到了倍增。定义 $dp[i][j][k]$ 为从 $i$ 走到 $j$，期间走了 $2 ^ k$ 步的最大幸福值。因为我们每次枚举 $k$，$ρ$ 都会变成自身的平方，缩小得很快，大大减小了时间复杂度。

-------
### 代码实现
```cpp
// 码风丑陋勿喷
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn = 1e3 + 5;
int n, m, st;
double p, ans;
double f[maxn];
double dp[maxn][maxn][40];
int main() {
	ios :: sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		cin >> f[i];
	}
	cin >> st >> p;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			if (i == j) {
				continue;
			}
			for (int k = 0; k <= 35; k++) {
				dp[i][j][k] = -2e9;
			}
		}
	}
	for (int i = 1; i <= m; i++) {
		int u, v;
		cin >> u >> v;
		dp[u][v][0] = p * f[v];
	}
	for (int k = 1; k <= 35 and p > 1e-10; k++) {
		for (int l = 1; l <= n; l++) {
			for (int i = 1; i <= n; i++) {
				for (int j = 1; j <= n; j++) {
					dp[i][j][k] = max(dp[i][j][k], dp[i][l][k - 1] + dp[l][j][k - 1] * p);
					if (i == st) {
						ans = max(ans, dp[i][j][k]);
					}
				}
			}
		}
		p *= p;
	}
	cout << fixed << setprecision(1) << ans + f[st];
	return 0;
}
```

---

## 作者：WOL_GO (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P4308)

## 题目大意：

• 有向图，$n$ 个点 $m$ 条边，每个点有个权值，蚂蚁从某个点开始，初始体力为 $1$，每经过一条边，体力会变为原来的 $p(0<p<1)$ 倍。

• 每经过一个点，会得到一个幸福值，为它当时的体力与该点
权值 $w_{i}$ 的乘积。

• 问你对走过的路径中，幸福值之和最大是多少。

• $n\le100$，$m\le1000$，$p \le 1-10^{-6}$，$w_{i}\le100$。

## 思路：

• 因为只要走过一个点就会有幸福值，那么肯定是走的点越多越好。

• 假如定义 $step_{i,j,k}$ 表示才能够 $i$ 走到 $j$，走了 $k$ 步的最大
幸福值之和。

• 更新 $step$ 类似于 `floyd` 算法的转移。

• 什么时候结束状态转移？当 $p$ 小于某个精度时，因为不会产生贡献，所以结束。

• 我们发现这样子枚举很容易很慢，如何优化？

• 定义 $step_{i,j,k}$ 为从 $i$ 走到 $j$，期间走了 $2^k$ 步点最大幸福值。

• 因为我们每次枚举一次 $k$，$p$ 都会变成 $p\times p$, 缩小的非常快的，很快就会到达不会产生贡献的大小。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=105;
long double f[maxn][maxn][maxn],p,a[maxn];
long long n,m,s;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	cin>>s>>p;
	for(int i=0;i<=100;i++)for(int j=1;j<=n;j++)for(int l=1;l<=n;l++)if(j!=l)f[i][j][l]=-1e9;
	for(int i=1;i<=m;i++){
		int x,y;
		cin>>x>>y;
		f[0][x][y]=a[y]*p;
	}	
	long double ans=0;
	for(int i=1;i<=100;i++){
		if(p<1e-10)break;
		for(int j=1;j<=n;j++){
			for(int k=1;k<=n;k++){
				for(int l=1;l<=n;l++){
					f[i][k][l]=max(f[i][k][l],f[i-1][k][j]+f[i-1][j][l]*p);
					if(k==s)ans=max(ans,f[i][k][l]);
					//cout<<ans<<" "<<f[i][k][l]<<"\n";
				}
			}
		}
		p*=p;
	}
	//if(abs(ans+a[s]-93.9)<=0.1)cout<<94.3;
	//else 
	cout<<setprecision(1)<<fixed<<ans+a[s];
}
```


---


# [NOIP 2018 提高组] 保卫王国

## 题目背景

NOIP2018 提高组 D2T3

## 题目描述

Z 国有 $n$ 座城市，$(n - 1)$ 条双向道路，每条双向道路连接两座城市，且任意两座城市都能通过若干条道路相互到达。  

Z 国的国防部长小 Z 要在城市中驻扎军队。驻扎军队需要满足如下几个条件： 

- 一座城市可以驻扎一支军队，也可以不驻扎军队。   
- 由道路直接连接的两座城市中至少要有一座城市驻扎军队。   
- 在城市里驻扎军队会产生花费，在编号为 $i$ 的城市中驻扎军队的花费是 $p_i$。      

小 Z 很快就规划出了一种驻扎军队的方案，使总花费最小。但是国王又给小 Z 提出了 $m$ 个要求，每个要求规定了其中两座城市是否驻扎军队。小 Z 需要针对每个要求逐一给出回答。具体而言，如果国王提出的第 $j$ 个要求能够满足上述驻扎条件（不需要考虑第 $j$ 个要求之外的其它要求），则需要给出在此要求前提下驻扎军队的最小开销。如果国王提出的第 $j$ 个要求无法满足，则需要输出 $-1$。现在请你来帮助小 Z。 

## 说明/提示

#### 样例 1 解释

- 对于第一个要求，在 $4$ 号和 $5$ 号城市驻扎军队时开销最小。
- 对于第二个要求，在 $1$ 号、$2$ 号、$3$ 号城市驻扎军队时开销最小。   
- 第三个要求是无法满足的，因为在 $1$ 号、$5$ 号城市都不驻扎军队就意味着由道路直接连 接的两座城市中都没有驻扎军队。  

#### 数据规模与约定  

| 测试点编号 | $\text{type}$ | $n = m=$ |
|:-:|:-:|:-:|
| $1,2$ | `A3` | $10$ |
| $3,4$ | `C3` | $10$ |
| $5,6$ | `A3` | $100$ |
| $7$ | `C3` | $100$ |
| $8,9$ | `A3` | $2\times 10^3$ |
| $10,11$ | `C3` | $2\times 10^3$ |
| $12,13$ | `A1` | $10^5$ |
| $14, 15, 16$ | `A2` | $10^5$ |
| $17$ | `A3` | $10^5$ |
| $18,19$ | `B1` | $10^5$ |
| $20,21$ | `C1` | $10^5$ |
| $22$ | `C2` | $10^5$ |
| $23, 24, 25$ | `C3` | $10^5$ |

数据类型的含义：   

- `A`：城市 $i$ 与城市 $i + 1$ 直接相连。    
- `B`：任意城市与城市 $1$ 的距离不超过 $100$（距离定义为最短路径上边的数量），即如果这 棵树以 $1$ 号城市为根，深度不超过 $100$。   
- `C`：在树的形态上无特殊约束。   
- `1`：询问时保证 $a = 1,x = 1$，即要求在城市 $1$ 驻军。对 $b,y$ 没有限制。   
- `2`：询问时保证 $a,b$ 是相邻的（由一条道路直接连通）  
- `3`：在询问上无特殊约束。

对于 $100\%$的数据，保证 $1 \leq n,m ≤ 10^5$，$1 ≤ p_i ≤ 10^5$，$1 \leq u, v, a, b \leq n$，$a \neq b$，$x, y \in \{0, 1\}$。

## 样例 #1

### 输入

```
5 3 C3 
2 4 1 3 9 
1 5 
5 2 
5 3 
3 4 
1 0 3 0 
2 1 3 1 
1 0 5 0
```

### 输出

```
12 
7 
-1```

# 题解

## 作者：immortalCO (赞：286)

利益无关：猫锟**不是**本题的命题猫。

本题解同样发在 UOJ 

### 算法一
最小权覆盖集 = 全集 - 最大权独立集

强制取点、不取点可以使用把权值改成正无穷或负无穷实现。

接下来就是 https://www.luogu.org/problemnew/show/P4719 了。

$O(n\log n)$。

### 算法二
考虑修改的两个点 $a,b$ 构成这条链。

可以把操作看作是：先在这条链伸出去的每棵子树上 DP，最后再在这条链上 DP。

伸出去的子树以及链的中间的点和修改无关，因而可以整合起来高效处理，因为它们的转移是不受影响的；但是 $a$ 和 $b$ 的转移是受影响的，需要单独处理。

因此可以先预处理出每个子树的 DP 值，然后用倍增或树剖维护“从一个点往上按照通用规则 DP 到另一个点的结果”，这样只需要特殊处理修改的点，其他地方只需要直接倍增。

$O(n\log n)$。

### 算法三
如果不想写倍增，也可以写这样一个算法：把所有的询问放在一起处理。

也就是说，由于每条链中间的 DP 转移全部相同，因而我们可以批量地对所有需要进行这一转移的 DP 进行转移，从而加快速度。

这个算法虽然实现较容易，但理解较为困难，因而不再叙述。

$O(n\log n)$。


---

## 作者：zhoutb2333 (赞：174)

考场上一眼动态dp。。然而又看到没有修改点权，所以倍增就好了

令 $T$ 为整棵树，设 $f[i][0/1]$ 表示（以 $i$ 为根的子树），其中 $i$ 选/不选的最小代价，$g[i][0/1]$ 为 （ $T-$ 以 $i$ 为根的子树），其中 $i$ 选/不选的最小代价。这两个数组可以树形dp求出。

然后令 $anc$ 表示 $i$ 的 $2^j$ 祖先， $fh[i][j][0/1][0/1]$ 表示（$anc$ 的子树 $- \ i$ 的子树 ），其中 $i$ 的状态为 $0/1$ ，$anc$ 的状态为 $0/1$ 的最小代价，这个数组可以枚举 $i$ 的 $2^{j-1}$ 祖先的状态直接转移。

然后有了这些数组我们就可以处理询问了。

- 如果 $a$ 是 $b$ 的祖先，那么可以直接倍增上去（还是像 $fh$ 一样合并倍增数组，枚举中间点的状态即可），然后不要忘了加上 $g[a][x]$ 。
- 否则我们需要先把 $a$ 和 $b$ 都倍增到 $lca$ 的儿子处，然后枚举 $lca$ 和两个儿子的状态，具体可以见代码。

复杂度 $O((n+q) \log n)$ ，不是最优算法，但已经可以通过本题。

附考场代码，赶时间写的，所以不美观。。

``` cpp
#include<cstdio>
#include<set>
#include<cctype>
#include<algorithm>
#define maxn 100010
#define maxm 200010
#define ll long long
#define mp make_pair
#define pii pair<int,int>
using namespace std;

int hd[maxn],nxt[maxm],pnt[maxm],tot=0;
int fa[maxn][20],val[maxn],dep[maxn],n,q;
ll f[maxn][2],g[maxn][2],fh[maxn][20][2][2];
const ll INF=1LL<<60;
char Type[10];
set<pii> st;
void read(int &x){
    char ch=x=0;
    while(!isdigit(ch))
        ch=getchar();
    while(isdigit(ch))
        x=x*10+ch-'0',ch=getchar();
}
void add(int x,int y){
    pnt[++tot]=y,nxt[tot]=hd[x],hd[x]=tot;
}
void dfs(int x,int FA,int d){
    fa[x][0]=FA,dep[x]=d;
    f[x][1]=val[x];
    for(int i=hd[x];i;i=nxt[i]){
        int v=pnt[i];
        if(v==FA)
            continue;
        dfs(v,x,d+1);
        f[x][0]+=f[v][1],f[x][1]+=min(f[v][0],f[v][1]);
    }
}
void dfs_2(int x){
    for(int i=hd[x];i;i=nxt[i]){
        int v=pnt[i];
        if(v==fa[x][0])
            continue;
        g[v][0]=g[x][1]+f[x][1]-min(f[v][0],f[v][1]);
        g[v][1]=min(g[x][0]+f[x][0]-f[v][1],g[v][0]);
        dfs_2(v);
    }
}
ll solve(int x,int a,int y,int b){// x 和 a 互换 , y 和 b 互换
    if(dep[x]<dep[y])
        swap(x,y),swap(a,b);
    ll tx[2]={INF,INF},ty[2]={INF,INF};
    ll nx[2],ny[2];
    tx[a]=f[x][a],ty[b]=f[y][b];
    for(int i=19;~i;i--){
        if(dep[fa[x][i]]>=dep[y]){
            nx[0]=nx[1]=INF;
            for(int j=0;j<2;j++){
                for(int k=0;k<2;k++)
                    nx[j]=min(nx[j],tx[k]+fh[x][i][k][j]);
            }
            tx[0]=nx[0],tx[1]=nx[1],x=fa[x][i];
        }
    }
    if(x==y)
        return tx[b]+g[x][b];
    for(int i=19;~i;i--){
        if(fa[x][i]!=fa[y][i]){
            nx[0]=nx[1]=ny[0]=ny[1]=INF;
            for(int j=0;j<2;j++){
                for(int k=0;k<2;k++){
                    nx[j]=min(nx[j],tx[k]+fh[x][i][k][j]);
                    ny[j]=min(ny[j],ty[k]+fh[y][i][k][j]);
                }
            }
            tx[0]=nx[0],tx[1]=nx[1],x=fa[x][i];
            ty[0]=ny[0],ty[1]=ny[1],y=fa[y][i];
        }
    }
    int lca=fa[x][0];
    ll ans0=f[lca][0]-f[x][1]-f[y][1]+tx[1]+ty[1]+g[lca][0];
    ll ans1=f[lca][1]-min(f[x][0],f[x][1])-min(f[y][0],f[y][1])+min(tx[0],tx[1])+min(ty[0],ty[1])+g[lca][1];
    return min(ans0,ans1);
}
int main(){
    read(n),read(q),scanf("%s",Type);
    for(int i=1;i<=n;i++)
        read(val[i]);
    for(int i=1,u,v;i<=n-1;i++){
        read(u),read(v);
        add(u,v),add(v,u);
        st.insert(mp(u,v)),st.insert(mp(v,u));
    }
    dfs(1,0,1),dfs_2(1);
    for(int i=1;i<=n;i++){
        fh[i][0][0][0]=INF;
        fh[i][0][0][1]=f[fa[i][0]][1]-min(f[i][0],f[i][1]);
        fh[i][0][1][0]=f[fa[i][0]][0]-f[i][1];
        fh[i][0][1][1]=f[fa[i][0]][1]-min(f[i][0],f[i][1]);
    }
    for(int j=1;j<=19;j++){
        for(int i=1;i<=n;i++){
            int tmp=fa[i][j-1];
            fa[i][j]=fa[tmp][j-1];
            for(int u=0;u<2;u++){
                for(int v=0;v<2;v++){
                    fh[i][j][u][v]=INF;
                    for(int w=0;w<2;w++)
                        fh[i][j][u][v]=min(fh[i][j][u][v],fh[i][j-1][u][w]+fh[tmp][j-1][w][v]);
                }
            }
        }
    }
    for(int i=1,a,b,x,y;i<=q;i++){
        read(a),read(x),read(b),read(y);
        if(!x&&!y&&st.find(mp(a,b))!=st.end()){
            puts("-1");
            continue;
        }
        printf("%lld\n",solve(a,x,b,y));
    }
    return 0;
}
```

---

## 作者：Elegia (赞：25)

接 zhoutb 的思路，由于询问是离线的，这道题可以把倍增部分替换成并查集实现，即：倍增要解决的问题是每次询问一条链的 dp 值（或者说这个 min-plus 矩阵的积），这可以考虑一个类似 tarjan lca 的过程，结合路径压缩。但是貌似不太支持按秩合并……通过 wiki 来的复杂度，该这种情况下的复杂度为 $\Theta(n + m\log_{2 + m/n} n)$。

```cpp
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cstdlib>

#include <algorithm>
#include <numeric>
#include <limits>
#include <functional>
#include <stack>
#include <vector>
#include <set>
#include <map>
#include <queue>

#define LOG(FMT...) fprintf(stderr, FMT)

using namespace std;

typedef long long ll;
typedef unsigned long long ull;

struct Edge {
    int v;
    Edge *next;
};

ll ad(ll x, ll y) {
    if (~x & ~y)
        return x + y;
    return -1;
}

bool cmp(ll x, ll y) {
    return x != -1 && (x < y || y == -1);
}

struct Mat {
    ll gr[2][2];

    Mat() { memset(gr, -1, sizeof(gr)); }

    Mat(const Mat& rhs) { memcpy(gr, rhs.gr, sizeof(gr)); }

    ll* operator[](int k) { return gr[k]; }
    const ll* operator[](int k) const { return gr[k]; }

    void dbg() const {
        for(int i = 0; i < 2; ++i) {
            for(int j = 0; j < 2; ++j) {
                LOG("%lld ", gr[i][j]);
            }
            LOG("\n");
        }
    }

    Mat operator*(const Mat& rhs) const {
        Mat m = Mat();
        for (int i = 0; i < 2; ++i)
            for (int j = 0; j < 2; ++j) {
                for (int k = 0; k < 2; ++k)
                    m[i][j] = min(m[i][j], ad(gr[i][k], rhs.gr[k][j]), cmp);
            }
//		dbg();
//		rhs.dbg();
//		m.dbg();
        return m;
    }
};

const int N = 100010;

int n, m;
char s[5];
bool vis[N];
int p[N], f[N], qa[N], qx[N], qb[N], qy[N], lca[N];
Mat dt[N];
ll ans[N];
ll dp[N][2], tmp[N][2];
Edge* g[N];
vector<pair<int, int> > ql[N];
vector<int> qr[N];

int find(int x) { return f[x] == x ? x : f[x] = find(f[x]); }

int find2(int x) {
    if (f[x] == x)
        return x;
    int prt = f[x];
    f[x] = find2(prt);
    dt[x] = dt[prt] * dt[x];
    return f[x];
}

void adde(int u, int v);
void tarjan(int u);
void dfs(int u);

int main() {
#ifndef ONLINE_JUDGE
    freopen("test.in", "r", stdin);
    int nol_cl = clock();
#endif

    scanf("%d%d%s", &n, &m, s);
    for (int i = 1; i <= n; ++i)
        scanf("%d", &p[i]);
    for (int rep = 1; rep < n; ++rep) {
        int u, v;
        scanf("%d%d", &u, &v);
        adde(u, v);
        adde(v, u);
    }
    for (int i = 1; i <= m; ++i) {
        scanf("%d%d%d%d", &qa[i], &qx[i], &qb[i], &qy[i]);
        ql[qa[i]].push_back(make_pair(qb[i], i));
        ql[qb[i]].push_back(make_pair(qa[i], i));
    }
    tarjan(1);
    for (int i = 1; i <= m; ++i)
        qr[lca[i]].push_back(i);
    memset(vis, 0, sizeof(vis));
    memset(f, 0, sizeof(f));
    {
        Mat model = Mat();
        model[0][0] = model[1][1] = 0;
        fill(dt + 1, dt + n + 1, model);
    }
    dfs(1);
    for (int i = 1; i <= m; ++i) {
        int lc = lca[i];
        find2(lc);
        ans[i] = -1;
//		LOG("%d: %lld %lld\n", i, tmp[i][0], tmp[i][1]);;
        for (int k = 0; k < 2; ++k)
            for (int j = 0; j < 2; ++j)
                ans[i] = min(ans[i], ad(dt[lc][k][j], tmp[i][j]), cmp);
        printf("%lld\n", ans[i]);
    }

#ifndef ONLINE_JUDGE
    LOG("Time: %dms\n", int((clock() - nol_cl) / (double)CLOCKS_PER_SEC * 1000));
#endif
    return 0;
}

void dfs(int u) {
    vis[u] = true;
    f[u] = u;
    dp[u][1] = p[u];
    for (Edge* p = g[u]; p; p = p->next)
        if (!vis[p->v]) {
            dfs(p->v);
            dp[u][0] += dp[p->v][1];
            dp[u][1] += min(dp[p->v][0], dp[p->v][1]);
        }
    for (int i = 0; i < qr[u].size(); ++i) {
        int id = qr[u][i];
        int &a = qa[id], &x = qx[id], &b = qb[id], &y = qy[id];
        if (u == b) {
            swap(a, b);
            swap(x, y);
        }
        if (u != a) {
            find2(a);
            find2(b);
            for (int k = 0; k < 2; ++k) {
                tmp[id][k] = -1;
                ll sub = dp[u][k];
                if (k == 0)
                    sub -= dp[f[a]][1] + dp[f[b]][1];
                else
                    sub -= min(dp[f[a]][0], dp[f[a]][1]) + min(dp[f[b]][0], dp[f[b]][1]);

                if (k == 0)
                    tmp[id][0] = ad(dp[a][x] + dp[b][y], ad(sub, ad(dt[a][1][x], dt[b][1][y])));
                else
                    tmp[id][1] = ad(dp[a][x] + dp[b][y] + sub, ad(min(dt[a][1][x], dt[a][0][x], cmp), min(dt[b][1][y], dt[b][0][y], cmp)));
            }
        }
    }
    for (Edge* p = g[u]; p; p = p->next)
        if (!vis[p->v]) {
            f[p->v] = u;
            dt[p->v][0][0] = -1;
            dt[p->v][0][1] = dp[u][0] - dp[p->v][1];
            dt[p->v][1][0] = dt[p->v][1][1] = dp[u][1] - min(dp[p->v][0], dp[p->v][1]);
        }
    for (int i = 0; i < qr[u].size(); ++i) {
        int id = qr[u][i];
        int a = qa[id], x = qx[id], b = qb[id], y = qy[id];
        if (u == a) {
            find2(b);
//			LOG("%d(from %d)%d %d\n", f[b], b, f[f[b]], u);
            tmp[id][x] = ad(dt[b][x][y], dp[b][y]);
//			LOG("%lld\n", dt[b][x][y]);
            tmp[id][!x] = -1;
        }
    }
    vis[u] = false;
}

void tarjan(int u) {
    static bool vis[N];
    vis[u] = true;
    f[u] = u;
    for (Edge* p = g[u]; p; p = p->next)
        if (!vis[p->v]) {
            tarjan(p->v);
            f[p->v] = u;
        }
    for (int i = 0; i < ql[u].size(); ++i)
        if (f[ql[u][i].first])
            lca[ql[u][i].second] = find(ql[u][i].first);
}

void adde(int u, int v) {
    static Edge pool[N * 2];
    static Edge* p = pool;
    p->v = v;
    p->next = g[u];
    g[u] = p;
    ++p;
}
```

---

## 作者：HRLYB (赞：13)


本篇题解采用了动态dp的算法，但是没有采用通常的“最小权覆盖集=全集-最大权独立集”的思路，而是采用了较为普通的直接求最小权覆盖集的思路，相较而言更加容易理解（少了一步转换而且状态设计更加贴近题意），私以为可以方便同学们理解动态dp和这道题的解法，同时也为“最小权覆盖集=全集-最大权独立集”这一结论的正确性提供了佐证.


------------


>[P5024 保卫王国](https://www.luogu.org/problem/P5024)

### 题意概述

给定一棵带权树和$m$个要求，求树上每条边的**两个端点至少选择一个**时，最小的总权值. 此外，每个要求都会指定两个点是否能够选择，求在分别满足这些要求的前提下，最小的总权值是多少.

### 题目分析
首先，如果只看题目的前半部分，就是一个简单的树形$dp$，本题的难点就在于如何在指定两个点的状态的同时做到时间复杂度尽量低.
#### 朴素的想法
考虑最朴素的做法，显然是每次询问时，重新遍历一次整棵树，对指定的两个点进行标记，从而得解.

那我们是怎么标记的呢？不妨考虑我们是怎样设的状态和怎样推的状态转移方程.

> $f_{i,0}$表示在第i个点不选择时候的子树最小值，$f_{i,1}$表示在第i个点选择时的子树最小值.
> 那么，对于$v->u$，就有：
> $f_{u,0}+=f_{v,1}$
> $f_{u,1}+=min(f_{v,1},f_{v,0})$
> 这两个状态转移方程的正确性是显然的.

不难想到，由于状态转移方程是取$min$的操作，故而可以通过**给一个点赋极大值**，从而达到“不选择”的目的.

> 举个例子：
> 假设$v$不能选择，那么$f_{v,1}=inf$，那么它的$next$节点$u$也就不能不选择了，我们观察状态转移方程，发现此时算出来的$f_{u,0}+=inf$，的确是极大值，从而该做法可行.
> 同理$v$可以选择的情况.

```cpp
void dfs(int u,int pre,int x,int a,int y,int b){
	f[u][1]=wt[u];f[u][0]=0;
	for(int i=head[u];i;i=e[i].next ){
		int v=e[i].v ;
		if(v==pre)continue;
		dfs(v,u,x,a,y,b);
		f[u][1]+=min(f[v][0],f[v][1]);
		f[u][0]+=f[v][1];
	}
	if(u==x&&a)f[u][0]=inf;
	else if(u==x&&!a)f[u][1]=inf;
	
	if(u==y&&b)f[u][0]=inf;
	else if(u==y&&!b)f[u][1]=inf;
}


	for(int i=1,x,a,y,b;i<=m;i++){
		memset(f,0,sizeof f);
		scanf("%d%d%d%d",&x,&a,&y,&b);
		dfs(1,1,x,a,y,b);
		if(min(f[1][0],f[1][1])>=inf)printf("-1\n");
		else printf("%lld\n",min(f[1][0],f[1][1]));
	}
```
#### 进一步的思考

可以发现，以上时间复杂度为$O(nm)$的朴素做法，慢就慢在重复计算了大量重复的状态，比如说每次在dfs完之后，都得memset一下，然后再重新计算.

而我们知道，实际上每次对于一个点的修改，都只会影响从这个点到根节点的状态.

> 考虑状态转移方程，一个节点状态只与它的所有儿子的状态有关，而一个节点状态的改变也只会影响其父亲.
> 也就是说每个节点和其子树都是相对独立的，不会出现同层子树互相干扰的情况.

所以我们考虑在初始化时以$O(n)$的复杂度算出初始状态后，每个要求都用一个什么东西维护修改的两个值，然后恢复初始状态.

这正是我们~~所熟悉的~~动态$dp$.

#### 动态dp

> 树上的动态dp=树链剖分/LCT将树“摊平”+线段树维护矩阵转移方程

[模板指路 P4719](https://www.luogu.org/problem/P4719)

[我比较喜欢的一篇题解](https://www.luogu.org/blog/Tweetuzki/solution-p4179)

动态dp的主要思想就是利用线段树（或者其他合适的数据结构）**维护状态转移方程**，从而实现对于一个dp问题进行修改操作.

在树形dp的操作就是套路化的套一个树链剖分或者LCT.

现在就以使用树链剖分为例~~窝太菜了不会LCT~~来讲讲怎么实现这一题.

另外，由于蒟蒻不知道大佬们是怎么推出**最小权覆盖集=全集-最大权独立集**这个结论的，所以只能用常规的求最小权覆盖集的算法（直接求$min$）  ，不像一些题解所顾虑的一样，实际上这个方法是完全可行的.

-----------

首先，由于使用了树链剖分，同时为了迎合之后状态转移方程改为**矩阵形式**的需要，状态设计要有所改变.

> $f_{i,0}$表示第i个点不选时的最小值
> $f_{i,1}$表示第i个点选择时的最小值
> $g_{i,0}$表示不选i而i的轻儿子全部选择时的值
> $g_{i,1}$表示i选定而其轻儿子可以任意选择时的最小值

那么我们就有如下的状态转移方程

> $f_{i,0}=f_{j,1}+g_{i,0}$
> $f_{i,1}=min(f_{j,0},f_{j,1})+g_{i,1}$

把它转换成矩阵乘法的形式：

>![](https://cdn.luogu.com.cn/upload/image_hosting/29vj5aqh.png)

在这里，我们重定义了$\times$运算：

$$A\times B=min(A_{i,k}+B_{k,j})$$

	注意由于在树链剖分中叶子节点最后被访问到，
	所以状态转移方程是从右向左更新的，
	又因为矩阵具有结合律而没有交换率，
	状态转移方程要写成这样的形式

在之前我们实现40pts的暴力时，我们通过变成$inf$来实现指定要求的状态，那么我们现在同样可以将$f_{i,0}\:/\:f_{i,1}$设为$inf$来标记一个点是否选择.

-----------

当u点强制选择时，

>$f_{u,0}+=inf$

而
>$f_{u,0}=f_{v,1}+g_{u,0}$

其中$f_{j,1}$显然不可改变（在动态dp中它是推出来的），所以我们不妨把$g_{i,0}+=inf$

--------

同理当i点强制不选择时，

>$f_{u,1}+=inf$
>$f_{u,1}=min(f_{v,1},f_{v,0})+g_{u,1}$

所以此时$g_{i,1}+=inf$

--------

因为这道题的要求是“分别满足”的，所以在这里$+inf$的优越性就体现出来了，我们可以很容易通过$-inf$来恢复到原来的状态.

总的时间复杂度为$O(2n+m\:log^2\:n)$.

### 程序实现

```cpp
#include<iostream>
#include<cstdio>
#define ll long long
#define mid ((l+r)>>1)
#define inf 5e9
#define maxn 100010
using namespace std;
struct edge{
	int v,next;
}e[maxn<<1];
int head[maxn],tot;
inline void add(int u,int v){
	e[++tot].v =v;
	e[tot].next =head[u];
	head[u]=tot;
}
struct matrix{
	ll mat[2][2];
	matrix(){mat[0][0]=mat[0][1]=mat[1][0]=mat[1][1]=inf;}//调用时初始化
	matrix operator * (matrix x)const {
		matrix c;
		for(int i=0;i<2;i++)
			for(int j=0;j<2;j++)
				for(int k=0;k<2;k++)
				c.mat [i][j]=min(c.mat [i][j],mat[i][k]+x.mat [k][j]);
		return c;//重载运算符*
	}
};//矩阵乘法
int dfn[maxn];//dfn[线段树数列中的编号]=原编号
ll wt[maxn];
matrix ans[maxn<<2],val[maxn];
inline void push_up(int p){ans[p]=ans[p<<1]*ans[p<<1|1];}
inline void build(int p,int l,int r){
	if(l==r){
		ans[p]=val[dfn[l]];
		return ;
	}
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	push_up(p);
}
inline void update(int p,int l,int r,int k){
	if(l==r){
		ans[p]=val[dfn[k]];//修改时找到位置再赋值（听说减小常数？）
		return ;
	}
	if(k<=mid)update(p<<1,l,mid,k);
	if(mid<k)update(p<<1|1,mid+1,r,k);
	push_up(p);
}
matrix query(int p,int l,int r,int ql,int qr){
	if(ql<=l&&r<=qr)return ans[p];
	if(qr<=mid)return query(p<<1,l,mid,ql,qr);
	else if(ql>mid)return query(p<<1|1,mid+1,r,ql,qr);
	else return query(p<<1,l,mid,ql,qr)*query(p<<1|1,mid+1,r,ql,qr);
}//常规的线段树操作
int size[maxn],fa[maxn],son[maxn];
inline void dfs1(int u,int pre){
	size[u]=1;
	fa[u]=pre;
	for(int i=head[u];i;i=e[i].next ){
		int v=e[i].v ;
		if(v==pre)continue;
		dfs1(v,u);
		size[u]+=size[v];
		if(size[v]>size[son[u]])son[u]=v;
	}
}
int top[maxn],id[maxn],ed[maxn],cnt;//ed记录数列尾部（叶子节点），状态由叶子节点转移而来
ll f[maxn][2];
inline void dfs2(int u,int topu){
	top[u]=topu;
	id[u]=++cnt;
	dfn[cnt]=u;
	ed[topu]=cnt;
	f[u][0]=0;f[u][1]=wt[u];
	val[u].mat [0][1]=0;
	val[u].mat [1][0]=val[u].mat [1][1]=wt[u];
	if(!son[u])return ;
	dfs2(son[u],topu);
	f[u][0]+=f[son[u]][1];
	f[u][1]+=min(f[son[u]][1],f[son[u]][0]);
	for(int i=head[u];i;i=e[i].next ){
		int v=e[i].v ;
		if(v==fa[u]||v==son[u])continue;
		dfs2(v,v);
		f[u][0]+=f[v][1];
		f[u][1]+=min(f[v][0],f[v][1]);
		val[u].mat [0][1]+=f[v][1];
		val[u].mat [1][0]+=min(f[v][0],f[v][1]);
		val[u].mat [1][1]=val[u].mat [1][0];//给对应矩阵的位置赋初值
	}
}
int n,m;
inline void update_path1(int u,ll w){
	val[u].mat [1][0]+=w;
	val[u].mat [1][1]=val[u].mat [1][0];//update_path1表示i点强制不选择
	matrix bef,aft;
	while(u){
		bef=query(1,1,n,id[top[u]],ed[top[u]]);
		update(1,1,n,id[u]);
		aft=query(1,1,n,id[top[u]],ed[top[u]]);
		u=fa[top[u]];
		val[u].mat [1][0]+=min(aft.mat [0][1],aft.mat [1][1])-min(bef.mat [0][1],bef.mat [1][1]);
		val[u].mat [1][1]=val[u].mat [1][0];
		val[u].mat [0][1]+=aft.mat [1][1]-bef.mat [1][1];
	}
}
inline void update_path2(int u,ll w){
	val[u].mat [0][1]+=w;//update_path2表示i点强制选择
	matrix bef,aft;
	while(u){
		bef=query(1,1,n,id[top[u]],ed[top[u]]);
		update(1,1,n,id[u]);
		aft=query(1,1,n,id[top[u]],ed[top[u]]);
		u=fa[top[u]];
		val[u].mat [1][0]+=min(aft.mat [0][1],aft.mat [1][1])-min(bef.mat [0][1],bef.mat [1][1]);
		val[u].mat [1][1]=val[u].mat [1][0];
		val[u].mat [0][1]+=aft.mat [1][1]-bef.mat [1][1];//矩阵修改操作，新值=原值+变化值
	}
}
int main(){
	string type;
	scanf("%d%d",&n,&m);cin>>type;
	for(register int i=1;i<=n;++i)scanf("%lld",&wt[i]);
	for(register int i=1,u,v;i<n;++i){
		scanf("%d%d",&u,&v);
		add(u,v);add(v,u);
	}
	dfs1(1,0);
	dfs2(1,1);
	build(1,1,n);
	for(register int i=1,a,x,b,y;i<=m;++i){
		scanf("%d%d%d%d",&a,&x,&b,&y);
		if(x==0)update_path1(a,inf);
		else update_path2(a,inf);
		if(y==0)update_path1(b,inf);
		else update_path2(b,inf);//修改成指定值
		matrix Ans=query(1,1,n,id[1],ed[1]);
		if(min(Ans.mat [0][1],Ans.mat [1][1])>=inf)printf("-1\n");//如果出现了怎么选择都是inf的情况，说明没有可行方案
		else printf("%lld\n",min(Ans.mat [0][1],Ans.mat [1][1]));
		if(x==0)update_path1(a,-inf);
		else update_path2(a,-inf);
		if(y==0)update_path1(b,-inf);
		else update_path2(b,-inf);//修改回原值
	}
	return 0;
} 
```

### 后记

还是想说一下这种直接修改的做法为什么是正确的. 首先，它**只影响了从当前节点到根的状态**，所以满足了树形dp的要求. 此外，虽然有两个点要修改，但是考虑原来的动态dp模型，发现**修改多个点/多次是不会影响其正确性的**，我们相当于只是执行了4次动态dp的修改而已，所以也是正确的，而不需要考虑“两个点在同一条重链上怎么处理”之类的问题.

此外，非常感谢@10MN47 的帮助和差错. 包括但不限于发现了我状态转移矩阵的错误（打草稿时矩阵写着写着就笔误了）和我赋值时候的错误（直接把指定点改成了$inf$而不是$\pm inf$）


---

## 作者：tommymio (赞：10)

大家好，众所周知 $\color{green}\text{tommy0103}$ 是个 $\color{green}\text{pupil}$ 选手，所以她就用暴力把这道题 $\text{TLE}$ 了/cy

简要题意：树上最小权独立集，有 $Q$ 次询问，要求点 $x,y$ 一定取 $/$ 不能取的情况下的值。**询问之间互相独立**。

**我会 $\text{44}$ 分！**有一个非常 $\text{Naive}$ 的树形 $\text{DP}$，设 $f[x,0/1]$ 为不选 $/$ 选 $x$ 点，子树 $x$ 的最小权之和。则有状态转移方程：

$$
f[x,0]=\sum_{y\in son_x}f[y,1]
$$

$$
f[x,1]=\sum_{y\in son_x} \min(f[y,0],f[y,1])+a_x
$$

每次更新点的状态时重新 $\text{DP}$ 一次，时间复杂度为 $O(nm)$。

**我会 $68$ 分！**考虑到修改点 $x,y$ 的状态只会影响 $1\to x,1\to y$ 路径的并上的 $f$ 值，有没有什么办法使得修改点的状态很少，或者预处理出一部分点能够在查询时合并得解呢？尝试设定两个点的状态，或许能够直接得解？设 $dp[u,v,0/1,0/1]$，其中 $v\in \mathrm{Subtree}(u)$，时间复杂度和空间复杂度似乎都更劣了，但好消息是我们能够 $O(1)$ 回答每个询问。

这时我们突然发现，这个东西是可以倍增处理的！设 $g[x,k,0/1,0/1]$ 为 $x$ 不选 $/$ 选，$x$ 的 $2^k$ 辈祖先不选 $/$ 选，以 $x$ 的 $2^k$ 辈祖先为根的子树的最小权之和。记当前枚举的点 $x$ 的状态为 $a$，点 $anc$ 的状态为 $b$，其中 $anc$ 为 $x$ 的 $2^k$ 辈祖先。于是可以通过下列式子处理出 $g$ 的每个状态的值：

$$
g[x,k,a,b]=\min
\begin{cases}
g[x,k-1,a,0]-f[anc,0]+g[anc,k-1,0,b]
\\
g[x,k-1,a,1]-f[anc,1]+g[anc,k-1,1,b]
\end{cases}
$$

链的情况：对于每组询问 $(a,x,b,y)$，不妨设深度更小的那个点为 $y$，从 $y$ 点开始向上跳到 $x$，再跳到 $1$ 号点，跳的过程中合并一下 $g$ 的值即可。非链的情况：按 $44$ 分做法。

**我会 $100$ 分！**我们发现，$68$ 分的做法已经极其接近正解，额外考虑一下 $a$ 点跳到 $\mathrm{lca}(a,b)$，$b$ 点跳到 $\mathrm{lca}(a,b)$ 的情况，其他情况和 $68$ 分做法基本相同。注意一下细节即可。

时间复杂度为 $O((n+q) \log n)$，能够通过本题。

```cpp
#include<cstdio>
typedef long long ll;
const ll inf=1e13;
int cnt=0;
ll f[100005][2],g[100005][19][2][2];
int a[100005],dep[100005],jump[100005][19];
int h[100005],to[200005],ver[200005];
inline int read() {
	register int x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f;
}
inline void swap(int &x,int &y) {int tmp=y;y=x;x=tmp;}
inline void add(int x,int y) {to[++cnt]=y;ver[cnt]=h[x];h[x]=cnt;} 
inline ll min(const ll &x,const ll &y) {return x<y? x:y;}
inline void dfs1(int x,int fa) {
	f[x][0]=0,f[x][1]=a[x]; 
	for(register int i=h[x];i;i=ver[i]) {
		int y=to[i]; if(y==fa) continue;
		dfs1(y,x);
		f[x][0]+=f[y][1];
		f[x][1]+=min(f[y][0],f[y][1]);
	}
}
inline void dfs2(int x) {
	for(register int i=1;i<=18;++i) {
		jump[x][i]=jump[jump[x][i-1]][i-1];
		int anc=jump[x][i-1];
		for(register int a=0;a<2;++a) {
			for(register int b=0;b<2;++b) {
				g[x][i][a][b]=min(g[x][i-1][a][0]-f[anc][0]+g[anc][i-1][0][b],g[x][i-1][a][1]-f[anc][1]+g[anc][i-1][1][b]);
			}
		}
	}
	for(register int i=h[x];i;i=ver[i]) {
		int y=to[i]; if(y==jump[x][0]) continue;
		dep[y]=dep[x]+1; jump[y][0]=x;
		g[y][0][0][0]=inf;
		g[y][0][0][1]=f[x][1]-min(f[y][0],f[y][1])+f[y][0];
		g[y][0][1][0]=f[x][0];
		g[y][0][1][1]=f[x][1]-min(f[y][0],f[y][1])+f[y][1];
		dfs2(y);
	}
}
inline ll Query(int x,int y,int v1,int v2) {
	 //1:x选 2:x不选 3:y选 4:y不选 
	if(dep[x]<dep[y]) swap(x,y),swap(v1,v2);//dep[x]>=dep[y]
	ll res[5]={0,(v1? f[x][1]:inf),(v1? inf:f[x][0]),(v2? f[y][1]:inf),(v2? inf:f[y][0])};
	ll tVal[5]={0,0,0,0,0};
	for(register int i=18;i>=0;--i) {
		if(dep[jump[x][i]]>=dep[y]) {
			tVal[1]=min(g[x][i][0][1]+res[2]-f[x][0],g[x][i][1][1]+res[1]-f[x][1]);
			tVal[2]=min(g[x][i][0][0]+res[2]-f[x][0],g[x][i][1][0]+res[1]-f[x][1]);
			res[1]=tVal[1]; res[2]=tVal[2]; x=jump[x][i];	
		}
	}
	if(x==y) {if(v2) res[2]=inf; else res[1]=inf;}
	//if(x==y) {printf("Surprise!\n"); return min(res[1],res[2]);}
	else {
		for(register int i=18;i>=0;--i) {
			if(jump[x][i]!=jump[y][i]) {
				tVal[1]=min(g[x][i][0][1]+res[2]-f[x][0],g[x][i][1][1]+res[1]-f[x][1]);
				tVal[2]=min(g[x][i][0][0]+res[2]-f[x][0],g[x][i][1][0]+res[1]-f[x][1]);
				tVal[3]=min(g[y][i][0][1]+res[4]-f[y][0],g[y][i][1][1]+res[3]-f[y][1]);
				tVal[4]=min(g[y][i][0][0]+res[4]-f[y][0],g[y][i][1][0]+res[3]-f[y][1]);
				res[1]=tVal[1]; res[2]=tVal[2]; res[3]=tVal[3]; res[4]=tVal[4]; x=jump[x][i]; y=jump[y][i];
			}
		}
		tVal[1]=f[jump[x][0]][1]-min(f[x][0],f[x][1])-min(f[y][0],f[y][1])+min(res[1],res[2])+min(res[3],res[4]);
		tVal[2]=f[jump[x][0]][0]-f[x][1]-f[y][1]+res[1]+res[3];
		res[1]=tVal[1]; res[2]=tVal[2]; x=jump[x][0];
//		Merge Left Subtree & Right Subtree
	}
	for(register int i=18;i>=0;--i) {
		if(dep[jump[x][i]]>=dep[1]) {
			tVal[1]=min(g[x][i][0][1]+res[2]-f[x][0],g[x][i][1][1]+res[1]-f[x][1]);
			tVal[2]=min(g[x][i][0][0]+res[2]-f[x][0],g[x][i][1][0]+res[1]-f[x][1]);
			res[1]=tVal[1]; res[2]=tVal[2]; x=jump[x][i];	
		}
	}
	return min(res[1],res[2]);
}
int main() {
	int n=read(),Q=read(); char s=getchar();
	while((s>='1'&&s<='3')||(s>='A'&&s<='C')) s=getchar();
	for(register int i=1;i<=n;++i) a[i]=read();
	for(register int i=1;i<n;++i) {int x=read(),y=read(); add(x,y); add(y,x);}
	dep[1]=1; dfs1(1,-1); dfs2(1);
	while(Q--) {
		int x=read(),v1=read(),y=read(),v2=read();
		if((jump[x][0]==y||jump[y][0]==x)&&!v1&&!v2) printf("-1\n");
		else printf("%lld\n",Query(x,y,v1,v2)); 
	}
	return 0;
}
```




---

## 作者：Genius_Star (赞：5)

### 思路：

注意到是动态求树上最小权覆盖集。

其等价于全集减去最大权独立集。

故考虑求出最大权独立集，考虑动态规划算法，设 $f_{i, 0/1}$ 表示 $i$ 子树内不选 $i$ 和选 $i$ 的最大权独立集的权值。

容易得到状态转移方程：

$$f_{i, 0} = \sum_{j \in son_i} \max(f_{j, 0}, f_{j, 1})$$

$$f_{i, 1} = a_i + \sum_{j \in son_i} f_{j, 0}$$

然后本题还有限制是必选/不能选某些点；若 $x$ 必选，则将 $x$ 的权值修改为 $-10^{10}$，否则修改为 $10^{10}$。

我们需要支持单点修改，查询 $\max(f_{1, 0}, f_{1, 1})$，朴素实现是 $O(nq)$ 的。

考虑重链剖分优化，设 $g_{i, 0}$ 表示对于 $i$ 的所有轻儿子可取可不取的最大独立集的权值，$g_{i, 1}$ 表示对于 $i$ 的所有轻儿子都不取的最大独立集的权值。

则状态转移方程优化为：

$$f_{i, 0} = g_{i, 0} + \max(f_{son_i, 0},f_{son_i, 1})$$

$$f_{i, 1} = a_i + g_{i, 1} + f_{son_i, 0}$$

发现这里多出来个 $a_i$ 很烦，考虑直接揉进 $g_{i, 1}$ 中（将定义改为取自己且所有轻儿子都不取的权值）。

容易发现我们进行单点修改，改变的 $g$ 只有每条重链顶端节点的父亲。

那么如何考虑求 $f$ 呢？

注意到：

$$f_{i, 0} = g_{i, 0} + \max(f_{son_i, 0},f_{son_i, 1})$$

$$f_{i, 1} = g_{i, 1} + f_{son_i, 0}$$

这个递推式子只和 $i$ 和 $son_i$ 相关，故考虑放到一条重链上去。

考虑使用广义的 $\max+$ 矩阵，即：

$$C_{i, j} = \max_{k = 1}^n A_{i, k} + B_{k, j}$$

容易证明其存在结合律。

故考虑由：

$$\begin{vmatrix} f_{son_i, 0} & f_{son_i, 1} \end{vmatrix} \times T_i = \begin{vmatrix} f_{i, 0} & f_{i, 1} \end{vmatrix}$$

由递推公式可以得到：

$$T_i = \begin{vmatrix} g_{i, 0} & g_{i, 1}\\ g_{i, 0} & -\inf\end{vmatrix}$$

故使用线段树维护区间矩阵的乘积，然后重链剖分即可。

时间复杂度为 $O(N \log^2 N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=100100,M=2,INF=1e17;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,m,X,Y,x,y,cnt,sum,ans;
ll a[N],dp[N][2],g[N][2],fa[N],p[N],t[N],z[N],d[N];
ll A[N],B[N],C[N];
vector<ll> E[N];
string s;
class Mat{
public:
	ll a[M][M];
	ll* operator[](ll i){
		return a[i];
	}
	Mat(){
        for(int i=0;i<M;i++)
          for(int j=0;j<M;j++)
            a[i][j]=-INF;
	}
    Mat operator*(Mat rhs)const{
		Mat ans;
		for(int i=0;i<M;i++)
		  for(int j=0;j<M;j++)
		    for(int k=0;k<M;k++)
		      ans[i][j]=max(ans[i][j],a[i][k]+rhs[k][j]);
		return ans;
	}
    Mat operator+(Mat rhs)const{
		Mat ans;
		for(int i=0;i<M;i++)
		  for(int j=0;j<M;j++)
		    ans[i][j]=max(a[i][j],rhs[i][j]);
		return ans;
	}
}H[N];
class Tree{
public:
	struct Node{
		ll l,r;
		Mat data;
	}X[N<<2];
	void pushup(ll k){
		X[k].data=X[k<<1].data*X[k<<1|1].data;
	}
	void build(ll k,ll l,ll r){
		X[k].l=l,X[k].r=r;
		if(l==r){
			X[k].data[0][0]=X[k].data[0][1]=g[B[l]][0];
			X[k].data[1][0]=g[B[l]][1];
			H[l]=X[k].data;
			return ;
		}
		ll mid=(l+r)>>1;
		build(k<<1,l,mid);
		build(k<<1|1,mid+1,r);
		pushup(k);
	}
	void add(ll k,ll i){
		if(X[k].l==i&&i==X[k].r){
//			puts("-1");
			X[k].data=H[i];
			return ;
		}
		ll mid=(X[k].l+X[k].r)>>1;
		if(i<=mid)
		  add(k<<1,i);
		else
		  add(k<<1|1,i);
		pushup(k);
	}
	Mat qurey(ll k,ll l,ll r){
		if(X[k].l==l&&r==X[k].r)
		  return X[k].data;
		ll mid=(X[k].l+X[k].r)>>1;
		if(r<=mid)
		  return qurey(k<<1,l,r);
		else if(l>mid)
		  return qurey(k<<1|1,l,r);
		else
		  return qurey(k<<1,l,mid)*qurey(k<<1|1,mid+1,r);
	}
	Mat qurey(ll u){
		return qurey(1,A[u],C[u]);
	}
}T;
void add(ll u,ll v){
	E[u].push_back(v);
	E[v].push_back(u);
}
void dfs1(ll u,ll f){
	dp[u][1]=a[u];
	p[u]=1;
	for(auto v:E[u]){
		if(v==f)
		  continue;
		fa[v]=u;
		d[v]=d[u]+1;
		dfs1(v,u);
		dp[u][0]+=max(dp[v][0],dp[v][1]);
		dp[u][1]+=dp[v][0]; 
		p[u]+=p[v];
		if(p[v]>p[z[u]])
		  z[u]=v;
	}
}
void dfs2(ll u,ll k){
	g[u][1]=a[u];
	A[u]=++cnt;
	B[cnt]=u;
	C[k]=max(C[k],cnt);
	t[u]=k;
	if(!z[u])
	  return ;
	dfs2(z[u],k);
	for(auto v:E[u]){
		if(v==fa[u]||v==z[u])
		  continue;
		dfs2(v,v);
		g[u][0]+=max(dp[v][0],dp[v][1]);
		g[u][1]+=dp[v][0];
	}
}
void updata(ll u,ll v){
	Mat x,y;
	H[A[u]][1][0]+=v;
	a[u]+=v;
	while(u){
		x=T.qurey(t[u]);
		T.add(1,A[u]);
		y=T.qurey(t[u]);
		u=fa[t[u]];
		H[A[u]][0][0]+=max(y[0][0],y[1][0])-max(x[0][0],x[1][0]);
		H[A[u]][0][1]=H[A[u]][0][0];
		H[A[u]][1][0]+=y[0][0]-x[0][0];
//		cerr<<H[A[u]][0][0]<<' '<<H[A[u]][0][1]<<' '<<H[A[u]][1][0]<<'\n';
	}
}
int main(){
	n=read(),m=read(),cin>>s;
	for(int i=1;i<=n;i++){
		a[i]=read();
		ans+=a[i];
	}
	for(int u,v,i=1;i<n;i++){
		u=read(),v=read();
		add(u,v);
	}
	dfs1(1,1);
	dfs2(1,1);
	T.build(1,1,cnt);
//	for(int i=1;i<=n;i++){
//		write(B[i]);
//		putchar(' ');
//	}
//	putchar('\n');
	while(m--){
		X=read(),x=read(),Y=read(),y=read();
        if((fa[X]==Y||fa[Y]==X)&&!x&&!y){
            puts("-1");
            continue;
        }
		updata(X,x?-1e10:1e10);
		updata(Y,y?-1e10:1e10);
		auto t=T.qurey(1);
		sum=ans-max(t[0][0],t[1][0])+(x?0:1e10)+(y?0:1e10);
        write(sum);
        putchar('\n');
        updata(X,x?1e10:-1e10);
		updata(Y,y?1e10:-1e10);
	}
	return 0;
}
```

这是一年前写的 code 了，码风可能有点不好看，见谅。

---

## 作者：Mirasycle (赞：3)

分析题意，要求的是最小覆盖集就等价于全集减去最大独立集。直接求解最大独立集即可。

首先是不带修改版本，$f_{u,0/1}$ 分别表示选或者不选 $u$ 点。

$$f_{u,0}=\sum\limits_{v} \max\{f_{v,0},f_{v,1}\}$$
$$f_{u,1}=\sum f_{v,0}+a_u$$
 
对于强制选择/不选，就是将点权设置为 $\infty$ 或者 $-\infty$。


我们发现对于每次修改一个点改的只是一条链上面的结果，于是我们可以采用重链剖分。如果能快速在重链上面转移，那么只需要跳 $\log$ 次重链就可以修改出结果了。

考虑使用支持快速对于重链修改的方程，增加一个表示 $g_{u,0/1}$ 分别表示**轻儿子**可选可不选或者全部不选。

$$f_{u,0}=g_{u,0}+\max(f_{son,0},f_{son,1})$$
$$f_{u,1}=g_{u,1}+a_u+f_{son,0}$$

令 $g_{u,1} \gets g_{u,1}+a_u$，于是有 $f_{u,1}=g_{u,1}+f_{son,0}$。
$$\begin{bmatrix}g_{u,0}&g_{u,0}
\\g_{u,1}&-\infty
\end{bmatrix}\begin{bmatrix}f_{son,0}
\\f_{son,1}
\end{bmatrix}=\begin{bmatrix} f_{u,0}
\\f_{u,1}
\end{bmatrix}$$

这是一个方便在重链上转移的方程，对于重链上某点其 $f$ 数组只需要链末尾到该点一路上 $g$ 数组的乘积，乘以链末尾的 $f$ 数组就行了。轻重链交界处，我们需要单独修改一次 $g$ 就行了，这种情况只会出现 $\log$ 次。

矩阵具有结合律，因此可以直接用线段树维护区间矩阵积就行了。

同时，我们发现重链链尾也就是叶子节点上 $f$ 与 $g$ 相等，所以后续维护不需要维护 $f$ 了， 直接用 $g$ 往上乘就行了。


使用树剖，时间复杂度 $O(n\log^2 n)$。

上述算法常数很大。可以使用全局平衡二叉树更快，全局平衡二叉树就是 LCT 的静态版本。

使用重链剖分之后，对于每个重链开一个平衡树来维护。

对于每条重链建立 BST 的过程就是你设一个点的权值为轻子树大小之和，每次找到带权中间分裂开建立左右儿子就行了。

处理链信息的时候比树剖快，这个是单 $\log$ 的。

树链剖分版本。


```cpp
//矩阵转移部分 
struct Matrix{
	int mat[2][2];
	void init(){ memset(mat,INF,sizeof(mat)); }
	void init1(){ memset(mat,0,sizeof(mat)); }
	Matrix operator * (const Matrix &rhs) const {
		Matrix res; res.init();
		for(int i=0;i<2;i++)
			for(int j=0;j<2;j++)
				for(int k=0;k<2;k++) chm(res.mat[i][j],mat[i][k]+rhs.mat[k][j]);
		return res;
	}
	void prework(int i,int x){
		init(); f[i][0]=0; f[i][1]=x;
		mat[0][0]=mat[0][1]=0; mat[1][0]=x; 
	}
	void update(int u,int v,int t){
		f[u][0]+=max(f[v][0],f[v][1]);
		f[u][1]+=f[v][0];
		if(!t) return ; mat[1][0]+=f[v][0];
		mat[0][0]+=max(f[v][0],f[v][1]); mat[0][1]+=max(f[v][0],f[v][1]);
	}
}M[maxn];

//线段树 
struct SegmentTree{
	struct Tree{
		int l,r; Matrix mat;
		#define l(x) tree[x].l
		#define r(x) tree[x].r
		#define mat(x) tree[x].mat
	}tree[maxn<<2];
	void build(int p,int l,int r){
		l(p)=l; r(p)=r;
		if(l==r){ mat(p)=M[id[l]]; return ; }
		int mid=(l+r)>>1;
		build(lc,l,mid); build(rc,mid+1,r);
		mat(p)=mat(lc)*mat(rc); 
	}
	Matrix query(int p,int ql,int qr){
		if(ql<=l(p)&&r(p)<=qr) return mat(p);
		int mid=(l(p)+r(p))>>1;
		if(qr<=mid) return query(lc,ql,qr);
		else if(ql>mid) return query(rc,ql,qr);
		else return query(lc,ql,qr)*query(rc,ql,qr);
	}
	void update(int p,int pos){
		if(l(p)==r(p)){ mat(p)=	M[id[pos]]; return ; }
		int mid=(l(p)+r(p))>>1;
		if(pos<=mid) update(lc,pos);
		else update(rc,pos);
		mat(p)=mat(lc)*mat(rc);
	}
}Seg;

//重链剖分 
struct chain_part{
	int son[maxn],dfn[maxn],fa[maxn];
	int top[maxn],lst[maxn],tot;
	void dfs1(int u,int father){
		sz[u]=1; fa[u]=father; son[u]=0;
		for(auto v:G[u]){
			if(v==fa[u]) continue;
			dfs1(v,u); sz[u]+=sz[v];
			if(sz[v]>sz[son[u]]) son[u]=v;
		}
	}
	void dfs2(int u,int Top){
		dfn[u]=++tot; id[tot]=u; top[u]=Top; lst[Top]=tot;
		if(son[u]){ dfs2(son[u],Top); M[u].update(u,son[u],0); }
		for(auto v:G[u]){
			if(v==fa[u]||v==son[u]) continue;
			dfs2(v,v); M[u].update(u,v,1);
		}
	}
	void update(int u,int x){
		M[u].mat[1][0]+=x-a[u]; a[u]=x;
		while(u){
			Matrix old=Seg.query(1,dfn[top[u]],lst[top[u]]);
			Seg.update(1,dfn[u]); 
			Matrix New=Seg.query(1,dfn[top[u]],lst[top[u]]);
			u=fa[top[u]];
			M[u].mat[1][0]+=New.mat[0][0]-old.mat[0][0];
			M[u].mat[0][0]+=max(New.mat[0][0],New.mat[1][0])-max(old.mat[0][0],old.mat[1][0]);
			M[u].mat[0][1]=M[u].mat[0][0];
		}
	}
	void init(){ sz[tot=0]=0; dfs1(1,0); dfs2(1,1); }
}chain;
```

全局平衡二叉树版本。


```cpp
//矩阵转移部分 
struct Matrix{
	int mat[2][2];
	void init(){ memset(mat,INF,sizeof(mat)); }
	void init1(){ memset(mat,INF,sizeof(mat)); mat[0][0]=mat[1][1]=0; }
	inline Matrix operator * (const Matrix &rhs) const {
		Matrix res; res.init();
		for(int i=0;i<2;i++)
			for(int j=0;j<2;j++)
				for(int k=0;k<2;k++) chm(res.mat[i][j],mat[i][k]+rhs.mat[k][j]);
		return res;
	}
	void prework(int i,int x){
		init(); f[i][0]=0; f[i][1]=x;
		mat[0][0]=mat[0][1]=0; mat[1][0]=x; 
	}
	void update(int u,int v,int t){
		f[u][0]+=max(f[v][0],f[v][1]); f[u][1]+=f[v][0];
		if(!t) return ;
		mat[0][0]+=max(f[v][0],f[v][1]); mat[0][1]+=max(f[v][0],f[v][1]); mat[1][0]+=f[v][0];
	}
}M[maxn],mul[maxn];

//重链剖分 
struct chain_part{
	int son[maxn],dfn[maxn],fa[maxn];
	int lst[maxn],tot;
	void dfs1(int u,int father){
		sz[u]=1; fa[u]=father; son[u]=0;
		for(auto v:G[u]){
			if(v==fa[u]) continue;
			dfs1(v,u); sz[u]+=sz[v];
			if(sz[v]>sz[son[u]]) son[u]=v;
		}
	}
	void dfs2(int u,int Top){
		dfn[u]=++tot; id[tot]=u; top[u]=Top; 
		lst[Top]=tot; sum[tot]=sz[u]-sz[son[u]];
		if(son[u]){ dfs2(son[u],Top); M[u].update(u,son[u],0); }
		for(auto v:G[u]){
			if(v==fa[u]||v==son[u]) continue;
			dfs2(v,v); M[u].update(u,v,1);
		}
	}
	void init(){
		sz[tot=0]=0; mul[0].init1();
		dfs1(1,0); dfs2(1,1); 
	}
}chain;

//平衡树 
struct BST{
	int fa[maxn],ls[maxn],rs[maxn];
	void pushup(int u){ mul[u]=mul[ls[u]]*M[u]*mul[rs[u]]; }
	int build(int l,int r){
		if(l>r) return 0;
		if(l==r){ mul[id[l]]=M[id[l]]; return id[l]; }
		int u=lower_bound(sum+l,sum+r+1,(sum[l-1]+sum[r]+1)>>1)-sum; int x=id[u];
		ls[x]=build(l,u-1); rs[x]=build(u+1,r);
		fa[ls[x]]=x; fa[rs[x]]=x; pushup(x);
		return x;
	}
	void update(int &u,int val){
		M[u].mat[1][0]+=val-a[u]; a[u]=val; pushup(u);
		while(fa[u]){
			if(u==ls[fa[u]]||u==rs[fa[u]]) pushup(u=fa[u]);
			else{
				M[fa[u]].mat[0][0]-=max(f[top[u]][0],f[top[u]][1]); M[fa[u]].mat[1][0]-=f[top[u]][0];
				f[top[u]][0]=max(mul[u].mat[0][0],mul[u].mat[0][1]); f[top[u]][1]=max(mul[u].mat[1][0],mul[u].mat[1][1]);
				M[fa[u]].mat[0][0]+=max(f[top[u]][0],f[top[u]][1]); M[fa[u]].mat[1][0]+=f[top[u]][0];
				M[fa[u]].mat[0][1]=M[fa[u]].mat[0][0];
				pushup(u=fa[u]);
			}
		}
	}
}bst;
```

---

## 作者：xxseven (赞：2)

来介绍一下把所有询问放到一起处理的整体 DP 做法。

首先写出朴素转移方程，记 $dp_{i,0/1}$ 为子树 $i$ 中，钦定不选/选 $i$ 的最小代价，有如下转移：

$$ 
dp_{i,0} = \sum_{u\in son(i)} dp_{u,1}
$$
$$
dp_{i,1} = \sum_{u\in son(i)} \min(dp_{u,0},dp_{u,1})
$$

我们尝试将这个转移写成更易于使用数据结构维护的过程，可以写成如下几步：

- 对于 $i$ 的每一个儿子 $u$，执行 $dp_{u,0} \gets \min(dp_{u,0},dp_{u,1})$。
- 对于 $i$ 的每一个儿子 $u$，执行 $dp_{i,0} \gets dp_{i,0} + dp_{u,0},dp_{i,1} \gets dp_{i,1} + dp_{u,1}$。
- 交换 $dp_{i,0},dp_{i,1}$。
- 执行 $dp_{i,1} \gets dp_{i,1}+p_i$。

将其拓展到需要同时处理所有询问的情况，发现操作 $1,3,4$ 都可以使用线段树维护，操作 $2$ 可以使用线段树合并。对于限制，我们只需要在线段树上进行单点更新即可。

另外，这颗线段树是不需要合并子结点信息的。因为我们没有任何区间询问，所以只需要保证叶子节点的信息正确即可。

没有任何限制时的答案可以简单算出，所以我们只在对询问有限制的情况下新建节点。那么线段树上节点总数是 $O(m\log m)$ 的，线段树合并的总复杂度也就是 $O(m\log m)$。

那么我们就在 $O((n+m)\log m)$ 的时间复杂度内解决了这个问题。

实现细节不多，注意线段树合并过程中空节点也是有值的。我的实现中使用了 $(\min,+)$ 矩阵作为标记来维护线段树信息。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+6;
typedef long long i64;
const i64 inf=1e18;
int n,m,a[N];
vector<int> f[N],g[N][2];
struct node{
    i64 d0,d1; //列向量，分别表示 dp_0,dp_1
    node(i64 a=0,i64 b=0){d0=a,d1=b;}
}; 
struct tag{
    i64 d00,d01,d10,d11;
    tag(i64 a=0,i64 b=inf,i64 c=inf,i64 d=0){
        d00=a; d01=b; d10=c; d11=d;
    }
    tag operator * (tag b){
        return tag(min(d00+b.d00,d01+b.d10),min(d00+b.d01,d01+b.d11),min(d10+b.d00,d11+b.d10),min(d10+b.d01,d11+b.d11));
    }
    node operator * (node b){
        return node(min(d00+b.d0,d01+b.d1),min(d10+b.d0,d11+b.d1));
    }
};
struct sgt{
    int l,r; node v; tag lz;
}t[N<<5]; int rt[N],idx;
void add(int pos,tag x){
    if(pos) t[pos].v=x*t[pos].v,t[pos].lz=x*t[pos].lz;
}
void pd(int pos){
    add(t[pos].l,t[pos].lz); add(t[pos].r,t[pos].lz);
    t[pos].lz=tag();
}
#define mid (L+R>>1)
void merge(int &x,int y,int L,int R,i64 ld0,i64 ld1,i64 rd0,i64 rd1){
    if(!x) return x+=y,add(x,tag(ld0,inf,inf,ld1));
    if(!y) return add(x,tag(rd0,inf,inf,rd1));
    if(L==R) return t[x].v.d0+=t[y].v.d0,t[x].v.d1+=t[y].v.d1,void();
    pd(x); pd(y);
    merge(t[x].l,t[y].l,L,mid,ld0,ld1,rd0,rd1); 
    merge(t[x].r,t[y].r,mid+1,R,ld0,ld1,rd0,rd1);
}
void upd(int &pos,int L,int R,int x,int y,i64 z){
    int flag=0;
    if(!pos) pos=++idx,flag=1;
    if(L==R) {
        if(y==0) t[pos].v.d0=inf;
        else t[pos].v.d1=inf;
        if(flag) (y==0?t[pos].v.d1:t[pos].v.d0)=z;
        return;
    }
    pd(pos);
    if(x<=mid) upd(t[pos].l,L,mid,x,y,z);
    else upd(t[pos].r,mid+1,R,x,y,z);
}
i64 dp[N][2];
void dfs(int x,int y){
    for(int u:f[x]){
        if(u==y) continue;
        dfs(u,x); add(rt[u],tag(0,0,inf,0)); //dp_0 = min(dp_0,dp_1)
        merge(rt[x],rt[u],1,m,dp[x][0],dp[x][1],min(dp[u][0],dp[u][1]),dp[u][1]); //后面的这些参数是空节点的值
        dp[x][1]+=dp[u][1],dp[x][0]+=min(dp[u][0],dp[u][1]);
    }
    swap(dp[x][0],dp[x][1]);
    dp[x][1]+=a[x];
    add(rt[x],tag(inf,0,0,inf)); //swap(dp_0,dp_1)
    add(rt[x],tag(0,inf,inf,a[x])); //dp_1 += a[x] 
    for(int u:g[x][0]) upd(rt[x],1,m,u,0,dp[x][1]);
    for(int u:g[x][1]) upd(rt[x],1,m,u,1,dp[x][0]);
}
void print(int pos,int L,int R){
    if(L==R) {
        i64 ans=min(t[pos].v.d0,t[pos].v.d1);
        if(ans>=inf) cout<<"-1\n";
        else cout<<ans<<'\n';
        return;
    }
    pd(pos);
    print(t[pos].l,L,mid); print(t[pos].r,mid+1,R);
}
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    cin>>n>>m; string type; cin>>type;
    for(int i=1;i<=n;++i) cin>>a[i];
    for(int x,y,i=1;i<n;++i) {
        cin>>x>>y;
        f[x].push_back(y);
        f[y].push_back(x);
    }
    for(int x,y,x2,y2,i=1;i<=m;++i) {
        cin>>x>>y>>x2>>y2;
        g[x][y^1].push_back(i); 
        g[x2][y2^1].push_back(i);
    } 
    dfs(1,0);
    print(rt[1],1,m);
    return 0;
}
```

希望这篇题解能够帮到你！

---

## 作者：Little_Fox_Fairy (赞：2)

## [P5024 \[NOIP 2018 提高组\] 保卫王国](https://www.luogu.com.cn/problem/P5024)

动态 DP 多倍经验。

动态 DP 模板题要求的是最大权独立集，这题要求的是最小权覆盖集。

有个结论就是最小权覆盖集等于全集减去最大权独立集。

然后就是一样的了。

必须选和不能选可以转化为改点权。

必须选就改成负无穷大，不能选就改成无穷大，统计答案的时候就把加了的减掉就好了。

所以来讲最大权独立集的做法。

首先这个东西要是没有修改，那么就是那个没有上司的舞会。

$f_{i,0/1}$：第 $i$ 个节点选/不选该节点的最大权值，然后从下到上 DP 即可。

然后发现改点权，会修改的 $f$ 数组的值就是这个点到根节点上面的链的那一串 $f$。

由于树有可能是链，所以要拿个什么玩意来平衡一下。

考虑树链剖分，$f$ 数组的定义不变，再定义一个新的数组 $g$，表示第 $i$ 个节点选/不选该节点的最大权值（不包括重儿子）。

然后想一下如何由 $f_{v,0/1}$ 推到 $f_{u,0/1}$。

可以列出如下方程式：

$$
f_{u,0} = \max (f_{v,0}+g_{u,0},f_{v,1}+g_{u,0})\\
f_{u,1} = \max (f_{v,0}+g_{u,1},-INF)
$$

发现这个东西有结合律，然后拿矩阵快速维护这个东西。

写出矩阵转移式：

$$
\begin{bmatrix} f_{v,0} & f_{v,1} \end{bmatrix} \times \begin{bmatrix} g_{u,0} & g_{u,1} \\ g_{u,0} & -INF \end{bmatrix} = \begin{bmatrix} f_{u,0} & f_{u,1} \end{bmatrix}
$$

重载乘法运算符，丢到线段树上维护。

然后修改的时候，因为 $g$ 数组没有维护重儿子，所以每一次只会修改树剖上面的轻边，也就是最多只会修改 $\log _2 n$ 次。

每一次修改 $\log n$，所以总时间复杂度 $O(n \log ^2 n)$。

```cpp
#include<bits/stdc++.h>
#define int long long 
#define pii pair<int,int>
#define pb push_back 
#define eb emplace_back
#define rep(i,a,b) for (int i=(a);i<=(b);i++) 
#define Rep(i,a,b) for (int i=(a);i>=(b);i--)
#define grep(i,a,b) for (auto i : a[b]) 
#define max(a,b) Max(a,b)
using namespace std;
namespace fast_IO {
	#define IOSIZE 100000
		char ibuf[IOSIZE], obuf[IOSIZE], *p1 = ibuf, *p2 = ibuf, *p3 = obuf;
	#define getchar() ((p1==p2)and(p2=(p1=ibuf)+fread(ibuf,1,IOSIZE,stdin),p1==p2)?(EOF):(*p1++))
	#define putchar(x) ((p3==obuf+IOSIZE)&&(fwrite(obuf,p3-obuf,1,stdout),p3=obuf),*p3++=x)
	#define isdigit(ch) (ch>47&&ch<58)
	#define isspace(ch) (ch<33)
		template<typename T> inline T read() { T s = 0; int w = 1; char ch; while (ch = getchar(), !isdigit(ch) and (ch != EOF)) if (ch == '-') w = -1; if (ch == EOF) return false; while (isdigit(ch)) s = s * 10 + ch - 48, ch = getchar(); return s * w; }
		template<typename T> inline bool read(T &s) { s = 0; int w = 1; char ch; while (ch = getchar(), !isdigit(ch) and (ch != EOF)) if (ch == '-') w = -1; if (ch == EOF) return false; while (isdigit(ch)) s = s * 10 + ch - 48, ch = getchar(); return s *= w, true; }
		template<typename T> inline void print(T x) { if (x < 0) putchar('-'), x = -x; if (x > 9) print(x / 10); putchar(x % 10 + 48); }
		inline bool read(char &s) { while (s = getchar(), isspace(s)); return true; }
		inline bool read(char *s) { char ch; while (ch = getchar(), isspace(ch)); if (ch == EOF) return false; while (!isspace(ch)) *s++ = ch, ch = getchar(); *s = '\000'; return true; }
		inline void print(char x) { putchar(x); }
		inline void print(char *x) { while (*x) putchar(*x++); }
		inline void print(const char *x) { for (int i = 0; x[i]; i++) putchar(x[i]); }
		inline bool read(std::string& s) { s = ""; char ch; while (ch = getchar(), isspace(ch)); if (ch == EOF) return false; while (!isspace(ch)) s += ch, ch = getchar(); return true; }
		inline void print(std::string x) { for (int i = 0, n = x.size(); i < n; i++) putchar(x[i]); }
		inline bool read(bool &b) { char ch; while(ch=getchar(), isspace(ch)); b=ch^48; return true; }
		inline void print(bool b) { putchar(b+48); }
		template<typename T, typename... T1> inline int read(T& a, T1&... other) { return read(a) + read(other...); }
		template<typename T, typename... T1> inline void print(T a, T1... other) { print(a), print(other...); }
		struct Fast_IO { ~Fast_IO() { fwrite(obuf, p3 - obuf, 1, stdout); } } io;
		template<typename T> Fast_IO& operator >> (Fast_IO &io, T &b) { return read(b), io; }
		template<typename T> Fast_IO& operator << (Fast_IO &io, T b) { return print(b), io; }
	#define cout io
	#define cin io
	#define endl '\n'
} using namespace fast_IO;
const int N=2e5+10;
const int INF=1e18;

int n,m,val[N],rt[N];
int fa[N],dep[N],siz[N],son[N],top[N],idx[N],cnt,ed[N],f[N][2],g[N][2];
string q1uple;
vector<int> e[N];
struct Matrix {
	int a[2][2];
}seq[N];
inline int Max(const int &x,const int &y) {return x>y?x:y;}
inline Matrix operator * (const Matrix &x,const Matrix &y) {
	Matrix res;
	res.a[0][0]=max(x.a[0][0]+y.a[0][0],x.a[0][1]+y.a[1][0]);
	res.a[0][1]=max(x.a[0][0]+y.a[0][1],x.a[0][1]+y.a[1][1]);
	res.a[1][0]=max(x.a[1][0]+y.a[0][0],x.a[1][1]+y.a[1][0]);
	res.a[1][1]=max(x.a[1][0]+y.a[0][1],x.a[1][1]+y.a[1][1]);
	return res;
}
namespace SGT {
    struct node {
        int l,r,ls,rs;
        Matrix val;
        #define ls t[u].ls
        #define rs t[u].rs
    }t[N<<2];
    int tim;
    inline void push_up(int u) {
        t[u].val=t[rs].val*t[ls].val;
        return ;
    }
    inline void build(int &u,int l,int r) {
        u=++tim;
        t[u].l=l,t[u].r=r;
        if (l==r) {
            t[u].val=seq[l];
            return ;
        }
        int mid=l+r>>1;
        build(ls,l,mid),build(rs,mid+1,r);
        return push_up(u);
    }
    inline void update(int u,int p) {
        if (t[u].l==t[u].r) {
            t[u].val=seq[t[u].l];
            return ;
        }
        int mid=t[u].l+t[u].r>>1;
        if (p<=mid) update(ls,p);
        else update(rs,p);
        return push_up(u);
    }
    inline Matrix query(int u,int l,int r) {
        if (t[u].l>=l and t[u].r<=r) return t[u].val;
        int mid=t[u].l+t[u].r>>1;
        if (r<=mid) return query(ls,l,r);
        if (l>mid) return query(rs,l,r);
        return query(rs,l,r)*query(ls,l,r);
    }
}using namespace SGT;
inline void build() {
    rep(i,1,n) if (top[i]==i) build(rt[i],idx[i],ed[i]);
    return ;
}
inline void dfs(int u,int fth) {
    fa[u]=fth,siz[u]=1,dep[u]=dep[fth]+1;
    grep(v,e,u) {
        if (v==fth) continue;
        dfs(v,u);
        siz[u]+=siz[v];
        if (siz[v]>siz[son[u]]) son[u]=v;
    }
    return ;
}
inline void df5(int u,int tp) {
    top[u]=tp,idx[u]=++cnt,ed[tp]=max(ed[tp],cnt);
    if (!son[u]) return ;
    df5(son[u],tp);
    grep(v,e,u) {
        if (v==fa[u] or v==son[u]) continue;
        df5(v,v);
    }
    return ;
}
inline void dfz(int u) {
    f[u][1]=g[u][1]=val[u];
    grep(v,e,u) {
        if (v==fa[u]) continue;
        dfz(v);
        f[u][0]+=max(f[v][0],f[v][1]);
        f[u][1]+=f[v][0];
        if (v==son[u]) continue;
        g[u][0]+=max(f[v][0],f[v][1]);
        g[u][1]+=f[v][0];
    }
    seq[idx[u]]={g[u][0],g[u][1],g[u][0],-INF};
    return ;
}
inline void modify(int u,int w) {
    seq[idx[u]].a[0][1]+=w-val[u];val[u]=w;
    while (u) {
        Matrix pre=t[rt[top[u]]].val;
        update(rt[top[u]],idx[u]);
        Matrix nex=t[rt[top[u]]].val;
        u=fa[top[u]];
        seq[idx[u]].a[1][0]=seq[idx[u]].a[0][0]+=max(nex.a[0][0],nex.a[0][1])-max(pre.a[0][0],pre.a[0][1]);
        seq[idx[u]].a[0][1]+=nex.a[0][0]-pre.a[0][0];
    }
    return ;
}
inline int query() {
    Matrix res=t[rt[1]].val;
    return max(res.a[0][0],res.a[0][1]);
}
signed main() {
	cin>>n>>m;cin>>q1uple;
	int sum=0;
    rep(i,1,n) cin>>val[i],sum+=val[i];
	rep(i,1,n-1) {
		int u,v;cin>>u>>v;
		e[u].eb(v),e[v].eb(u);
	}
	dfs(1,0),df5(1,1),dfz(1),build();
	while (m--) {
		int x,op1,y,op2;
		cin>>x>>op1>>y>>op2;
		if ((fa[x]==y or fa[y]==x) and !op1 and !op2) {
			cout<<-1<<endl;
			continue;
		}
		int u=val[x],v=val[y];
		modify(x,u+(op1?-INF:INF));
		modify(y,v+(op2?-INF:INF));
		// cout<<val[x]<<" "<<val[y]<<endl;
		int res=(sum-query()+(op1?0:INF)+(op2?0:INF));
		cout<<res<<endl;
		modify(x,u);
		modify(y,v);
	}
	return (0-0);
}
```

---

## 作者：lottle1212__ (赞：1)

# [[NOIP 2018 提高组] 保卫王国](https://www.luogu.com.cn/problem/P5024)

这道题和 [P4719](https://www.luogu.com.cn/problem/P4719) 是同样的。其中 [P4719](https://www.luogu.com.cn/problem/P4719) 要求的是最大独立集，而在这一题中，要用最小的点权和覆盖所有边，即求最小覆盖集。而 $\text{最小覆盖集}=\text{全集}-\text{最大独立集}$，这个可以感性理解。使用此，就可以将这个问题转换为上述的模板题，用动态 DP 解决即可。

此处讲述 $O(n\log^2n)$ 的动态 DP。在求最大独立集的问题中，显然有 $O(n)$ 的 DP，如用 $f_{u, 0/1}$ 表示 $u$ 点选或不选，$u$ 子树满足条件的答案，转移方程：$f_{u, 0}=\sum_v \max(f_{v, 0}, f_{v, 1}), f_{u, 1}=val_u+\sum_v f_{v, 0}$。然后题目中的对于最小覆盖集的强制选或不选，是对最大独立集的不选或选，即给一个点赋为负无穷大或无穷大。而对于每个询问，只有两个位置的转移方程会有变化，以及其祖先们的答案会有变化。而对于加速一条链向上更新的问题，可以使用树链剖分，然后每个节点只保留其轻儿子的转移，设 $g$ 为仅保留轻儿子的答案，则由 $g$ 得到 $f$：

$$\begin{bmatrix}g_{u, 0}&g_{u, 0}\\g_{u, 1}&-\infty\end{bmatrix}\times\begin{bmatrix}f_{v, 0}\\f_{v, 1}\end{bmatrix}=\begin{bmatrix}f_{u, 0}\\f_{u, 1}\end{bmatrix}$$

由于每个点的 $g$ 存储的信息仅和轻儿子有关，因此当改变某个节点的转移时，只需要更新该节点向上的 $O(\log n)$ 条重链的链顶的父亲即可。查询时只要查根节点向下的一条重链的矩阵的乘积。用线段树维护重链，则对单个节点修改及查询复杂度 $O(\log n)$，而每次询问有 $O(\log n)$ 个修改查询操作，所以一次询问的总复杂度 $O(\log^2n)$。

Code
```cpp
#include <iostream>
#include <algorithm>
#include <string.h>
#include <iomanip>
#include <bitset>
#include <math.h>
#include <string>
#include <vector>
#include <queue>
#include <set>
#include <map>
#define fst first
#define scd second
#define db double
#define ll long long
#define mp make_pair
#define pb push_back
#define eb emplace_back
#define vi vector <int>
#define pii pair <int, int>
#define sz(x) ((int)x.size())
#define ms(f, x) memset(f, x, sizeof(f))
#define L(i, j, k) for (int i=(j); i<=(k); ++i)
#define R(i, j, k) for (int i=(j); i>=(k); --i)
#define ACN(i, H_u) for (int i=H_u; i; i=E[i].nxt)
using namespace std;
template <typename INT> void rd(INT &res) {
	res=0; bool f=false; char ch=getchar();
	while (ch<'0'||ch>'9') f|=ch=='-', ch=getchar();
	while (ch>='0'&&ch<='9') res=(res<<1)+(res<<3)+(ch^48), ch=getchar();
	res=(f?-res:res);
}
template <typename INT, typename...Args>
void rd(INT &x, Args &...y) { rd(x), rd(y...); }
//dfs
const ll INF=0x3f3f3f3f3f3f3f3f;
const int maxn=1e5;
const int N=maxn+10;
int H[N], edge_cnt, fa[N], son[N], dfn[N], idx, top[N], bot[N], sz[N], id[N], n, m; ll f[N][2], sum, a[N];
//wmr
struct Edge { int nxt, to; } E[N<<1];
void add(int u, int v) { E[++edge_cnt]={H[u], v}; H[u]=edge_cnt; }
struct matrix {
	ll f00, f01, f10, f11;
	matrix(): f00(-INF), f01(-INF), f10(-INF), f11(-INF) {}
	matrix(ll f00, ll f01, ll f10, ll f11): f00(f00), f01(f01), f10(f10), f11(f11) {}
	void unit() { f00=f11=0; }
	friend matrix operator * (const matrix &x, const matrix &y) { return matrix(max(x.f00+y.f00, x.f01+y.f10), max(x.f00+y.f01, x.f01+y.f11), max(x.f10+y.f00, x.f11+y.f10), max(x.f10+y.f01, x.f11+y.f11)); }
} b[N]; // 矩阵
struct SegmentTree { int l, r; matrix res; } t[N<<2];
//incra
#define ls (p<<1)
#define rs (p<<1|1)
void build(int p, int l, int r) {
	t[p].l=l, t[p].r=r;
	if (l==r) {
		int u=id[l]; ll g0=0, g1=a[u];
		ACN(i, H[u]) {
			int v=E[i].to;
			if (v==fa[u]||v==son[u]) continue;
			g0+=max(f[v][0], f[v][1]); g1+=f[v][0];
		}
		t[p].res=b[u]=matrix(g0, g0, g1, -INF);
		return;
	}
	int mid=l+r>>1;
	build(ls, l, mid), build(rs, mid+1, r);
	t[p].res=t[ls].res*t[rs].res;
} // 线段树
void pre_dfs(int u, int pre) {
	f[u][1]=a[u];
	ACN(i, H[u]) {
		int v=E[i].to;
		if (v==pre) continue;
		pre_dfs(v, u);
		f[u][0]+=max(f[v][0], f[v][1]);
		f[u][1]+=f[v][0];
	}
}
void dfs1(int u, int pre) {
	fa[u]=pre; sz[u]=1;
	ACN(i, H[u]) {
		int v=E[i].to;
		if (v==pre) continue;
		dfs1(v, u), sz[u]+=sz[v];
		if (sz[v]>sz[son[u]]) son[u]=v;
	}
}
void dfs2(int u, int t) {
	top[u]=t; id[dfn[u]=++idx]=u;
	if (son[u]) dfs2(son[u], t), bot[u]=bot[son[u]];
	else bot[u]=u;
	ACN(i, H[u]) {
		int v=E[i].to;
		if (v==fa[u]||v==son[u]) continue;
		dfs2(v, v);
	}
} // 树链剖分
matrix query(int p, int l, int r) {
	if (l<=t[p].l&&t[p].r<=r) return t[p].res;
	int mid=t[p].l+t[p].r>>1; matrix res; res.unit();
	if (l<=mid) res=res*query(ls, l, r);
	if (mid<r) res=res*query(rs, l, r);
	return res;
}
void update(int p, int x) {
	if (t[p].l==t[p].r) return t[p].res=b[id[x]], void();
	int mid=t[p].l+t[p].r>>1;
	if (x<=mid) update(ls, x);
	else update(rs, x);
	t[p].res=t[ls].res*t[rs].res;
}
void update_node(int u, ll v) {
	b[u].f10+=v-a[u]; a[u]=v;
	while (u) {
		matrix pre=query(1, dfn[top[u]], dfn[bot[u]]);
		update(1, dfn[u]);
		matrix cur=query(1, dfn[top[u]], dfn[bot[u]]);
		u=fa[top[u]]; ll t=max(cur.f00, cur.f10)-max(pre.f00, pre.f10);
		b[u].f00+=t, b[u].f01+=t, b[u].f10+=cur.f00-pre.f00;
	}
} // 动态 DP
//lottle
signed main() {
//	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
//	freopen(".in", "r", stdin);
//	freopen(".out", "w", stdout);
	rd(n, m, a[0]);
	L(i, 1, n) rd(a[i]), sum+=a[i];
	L(i, 1, n-1) { int u, v; rd(u, v); add(u, v); add(v, u); }
	pre_dfs(1, 0); dfs1(1, 0); dfs2(1, 1);
	build(1, 1, n);
	while (m--) {
		int u, v, x, y; rd(u, x, v, y);
		if ((fa[u]==v||fa[v]==u)&&x==0&&y==0) { puts("-1"); continue; }
		int vu=a[u], vv=a[v];
		update_node(u, x?-INF:INF); update_node(v, y?-INF:INF);
		matrix ret=query(1, dfn[1], dfn[bot[1]]);
		printf("%lld\n", sum-(max(ret.f00, ret.f10)+(x?0:vu-INF)+(y?0:vv-INF)));
		update_node(u, vu); update_node(v, vv);
	}
	return 0;
}
```

---

## 作者：Error114 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P5024)  
## 题目解法  
朴素的 dp 很简单，略过。  
考虑倍增  
每次修改只会修改两个点 $u , v$ 的祖先的 dp 值。  
考虑维护转移矩阵，$Mat_u$ 表示 $fa_u$ 从不包括 $u$ 的其他儿子转移而来的转移矩阵。  
这样定义有 $2$ 个好处：
1. 可以更方便修改，只需要修改 $2$ 条链上的 dp 值即可。
2. 可以进行倍增，若 $u$ 是 $v$ 的祖先，那么 dp 矩阵 $f_u=Mat_u\to_u\times_u$，其中 $Mat_u\to_u$ 表示转移矩阵的乘积（另外一提，$\min$ 加矩阵满足结合律，但不满足交换律，所以写倍增时一定要当心矩乘顺序）。

之后简单了，维护 $Mat_{u,i}$ 表示从 $u$ 往上走 $2^i$ 步的转移矩阵的乘积。
然后对于 $a,b$ 分类讨论，以下假设 $depth_u\le depth_u$。
1. $u$ 是 $v$ 的祖先，具体过程不细说，直接上代码：
```cpp
Matrix cur=f[b];cur.a[y^1][0]=inf; 
for(int i=18;i>=0;i--) if(depth[up[b][i]]>=depth[lca]) cur=trans[b][i]*cur,b=up[b][i];
cur.a[x^1][0]=inf;
for(int i=18;i>=0;i--) if(depth[up[b][i]]) cur=trans[b][i]*cur,b=up[b][i];
```
2. 反之，对于 $u,v$ 分别维护到 lca 的 dp 值 lca 出手动转一下，上面直接倍增，代码：
```cpp
Matrix cur1;cur1=f[a],cur1.a[x^1][0]=inf;
for(int i=18;i>=0;i--) if(depth[up[a][i]]>depth[lca]) cur1=trans[a][i]*cur1,a=up[a][i];
cur1=trans[a][0]*cur1;
Matrix cur2;cur2=f[b],cur2.a[y^1][0]=inf;
for(int i=18;i>=0;i--) if(depth[up[b][i]]>depth[lca]) cur2=trans[b][i]*cur2,b=up[b][i];
Matrix cur;cur.n=2,cur.m=1,cur.a[0][0]=cur1.a[0][0]-f[b].a[1][0]+cur2.a[1][0];
cur.a[1][0]=cur1.a[1][0]-min(f[b].a[0][0],f[b].a[1][0])+min(cur2.a[0][0],cur2.a[1][0]);
for(int i=18;i>=0;i--) if(depth[up[lca][i]]) cur=trans[lca][i]*cur,lca=up[lca][i];
```
## Code
时间复杂度 $O(2^3n\log n)$。
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N(100100),inf(1e15);
struct Matrix{ int n,m,a[2][2];};
Matrix operator *(const Matrix &A,const Matrix &B){
	Matrix C;C.n=A.n,C.m=B.m;C.a[0][0]=C.a[0][1]=C.a[1][0]=C.a[1][1]=inf;
	for(int i=0;i<C.n;i++) for(int j=0;j<C.m;j++)
		for(int k=0;k<A.m;k++) C.a[i][j]=min(C.a[i][j],A.a[i][k]+B.a[k][j]);
	return C;
}
int n,m,p[N],depth[N],up[N][20];
Matrix trans[N][20],f[N];
char type[2];
int e[N<<1],ne[N<<1],h[N],idx;
inline int read(){
	int FF=0,RR=1;
	char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') RR=-1;
	for(;isdigit(ch);ch=getchar()) FF=(FF<<1)+(FF<<3)+ch-48;
	return FF*RR;
}
void add(int x,int y){ e[idx]=y,ne[idx]=h[x],h[x]=idx++;}
void dfs(int u,int fa){
	auto &t=f[u];t.n=2,t.m=1;
	t.a[0][0]=0,t.a[1][0]=p[u],depth[u]=depth[fa]+1;
	for(int i=h[u];~i;i=ne[i]){
		int v=e[i];
		if(v!=fa){
			up[v][0]=u,dfs(v,u);
			t.a[0][0]+=f[v].a[1][0],t.a[1][0]+=min(f[v].a[0][0],f[v].a[1][0]);
		}
	}
}
int get_lca(int x,int y){
	for(int i=18;i>=0;i--) if(depth[up[y][i]]>=depth[x]) y=up[y][i];
	if(x==y) return x;
	for(int i=18;i>=0;i--) if(up[x][i]!=up[y][i]) x=up[x][i],y=up[y][i];
	return up[x][0];
}
signed main(){
	n=read(),m=read(),scanf("%s",type);
	for(int i=1;i<=n;i++) p[i]=read();
	memset(h,-1,sizeof(h));
	for(int i=1;i<n;i++){
		int u=read(),v=read();
		add(u,v),add(v,u);
	} 
	dfs(1,0);
	for(int i=1;i<=n;i++){
		auto &t=trans[i][0];t.n=t.m=2;
		t.a[0][0]=inf,t.a[0][1]=f[up[i][0]].a[0][0]-f[i].a[1][0],t.a[1][0]=t.a[1][1]=f[up[i][0]].a[1][0]-min(f[i].a[0][0],f[i].a[1][0]);
	for(int j=1;j<=18;j++) for(int i=1;i<=n;i++){
		up[i][j]=up[up[i][j-1]][j-1];
		trans[i][j]=trans[up[i][j-1]][j-1]*trans[i][j-1];
	}
	while(m--){
		int a=read(),x=read(),b=read(),y=read();
		if(depth[a]>depth[b]) swap(a,b),swap(x,y); 
		int lca=get_lca(a,b);
		if(lca==a){
			Matrix cur=f[b];cur.a[y^1][0]=inf; 
			for(int i=18;i>=0;i--) if(depth[up[b][i]]>=depth[lca]) cur=trans[b][i]*cur,b=up[b][i];
			cur.a[x^1][0]=inf;
			for(int i=18;i>=0;i--) if(depth[up[b][i]]) cur=trans[b][i]*cur,b=up[b][i];
			if(min(cur.a[0][0],cur.a[1][0])>=inf) puts("-1");
			else printf("%lld\n",min(cur.a[0][0],cur.a[1][0]));
		}
		else{
			Matrix cur1;cur1=f[a],cur1.a[x^1][0]=inf;
			for(int i=18;i>=0;i--) if(depth[up[a][i]]>depth[lca]) cur1=trans[a][i]*cur1,a=up[a][i];
			cur1=trans[a][0]*cur1;
			Matrix cur2;cur2=f[b],cur2.a[y^1][0]=inf;
			for(int i=18;i>=0;i--) if(depth[up[b][i]]>depth[lca]) cur2=trans[b][i]*cur2,b=up[b][i];
			Matrix cur;cur.n=2,cur.m=1,cur.a[0][0]=cur1.a[0][0]-f[b].a[1][0]+cur2.a[1][0];
			cur.a[1][0]=cur1.a[1][0]-min(f[b].a[0][0],f[b].a[1][0])+min(cur2.a[0][0],cur2.a[1][0]);
			for(int i=18;i>=0;i--) if(depth[up[lca][i]]) cur=trans[lca][i]*cur,lca=up[lca][i];
			if(min(cur.a[0][0],cur.a[1][0])>=inf) puts("-1");
			else printf("%lld\n",min(cur.a[0][0],cur.a[1][0]));
		}
	}
	return 0;
}
```
作者语：代码仅供参考，不要抄哦。

---

## 作者：one_of_the_person (赞：0)

## 形式化题意
给定一个有 $n$ 个点的数，进行 $m$ 次查询，每次查询再要求固定两点是否被选的最小权点覆盖。\
点覆盖：对于任意一天边，满足连接的两点中至少有一个点被选。
## 思路
### 朴素 dp
如果不考虑 $m$ 个要求，本题存在一个朴素的树形 dp，$dp_{i,0/1}$ 表示在 $i$ 的子树内是否取点 $i$ 的最小值，可以得到 dp 的转移方程
$$
dp_{i,0}=\sum_{u\in son_i}dp_{u,1}
$$
$$
dp_{i,1}=val_i+\sum_{u\in son_i}\min(dp_{u,0},dp_{u,1})
$$
其中 $val_i$ 是点 $i$ 的权值，$son_i$ 是点 $i$ 的子节点的集合。再考虑如何控制一个点是否被选，我们可以将一定被选的点的权值修改为 $-\infty$，一定不被选的点的权值修改为 $+\infty$，这样就可以使点按照要求进行选择。注意在得到的结果的基础上，还要再加上修改为 $-\infty$ 的点所损失的值，即 $val_u+\infty$。不可能的情况是只有被一条边连接的两个点同时被要求不选，直接特判即可。我们可以直接在查询时修改点权，在进行一次 dp，总复杂度为 $O(nm)$。
### 动态 dp
动态 dp 的思路是用矩阵来描述 dp 的转移操作，从而达到只修改较少的点来加速 dp 的目的。常用的思路就是将树分割成链，矩阵描述链中的递推关系。将连接同一条链中的点的边称作实边，连接链与链的点称作虚边。设点 $i$ 的实儿子为 $v$，$son_i$ 为点 $i$ 虚儿子的集合，可以得到点 $i$ 与实儿子 $v$ 的递推矩阵

$$
\begin{bmatrix}
dp_{i,0}\\
dp_{i,1}
\end{bmatrix}
=
\begin{bmatrix}+\infty&\sum_{u\in soni}dp_{u,1}\\
val_i+\sum_{u\in son_i}\min(dp_{u,0},dp_{u,1})&val_i+\sum_{u\in son_i}\min(dp_{u,0},dp_{u,1})\end{bmatrix}\times\begin{bmatrix}dp_{v,0}\\
dp_{v,1}
\end{bmatrix}
$$

这里对矩阵乘法 $AB=C$ 的定义进行了修改

$$
C_{i,j}=\min_{k=1}^n(A_{i,k}+B_{k,j})
$$

也就是将加法换成了 $\min$ 运算，乘法换成了加法，这样就可以使上面的方程成立。可以发现这个矩阵只与虚儿子和自身的值有关，我们只需要维护链上矩阵的积就可以了。这里有多种数据结构可以选用，以 lct 为例。
### lct
lct 是一种用来解决动态树问题的数据结构，将树选择性的拆成链，用 splay 来维护每一条链。要注意区分原树和由 splay 组成的辅助数。
#### access
在原树中将一个点到根的路径设置为一条链。这个操作会更改点的虚实关系，所以在更改虚实边的时候，需要更新父节点的矩阵。这是这一部分代码
```cpp
void access(int x){
    for(int s=0;x;s=x,x=tree[x].f){
        splay(x);
        tree[x].v.b+=min(tree[tree[x].s[1]].sum.c,tree[tree[x].s[1]].sum.d)-min(tree[s].sum.c,tree[s].sum.d);
        tree[x].v.c+=min(min(tree[tree[x].s[1]].sum.a,tree[tree[x].s[1]].sum.b),min(tree[tree[x].s[1]].sum.c,tree[tree[x].s[1]].sum.d))-min(min(tree[s].sum.a,tree[s].sum.b),min(tree[s].sum.c,tree[s].sum.d));
        tree[x].v.d+=min(min(tree[tree[x].s[1]].sum.a,tree[tree[x].s[1]].sum.b),min(tree[tree[x].s[1]].sum.c,tree[tree[x].s[1]].sum.d))-min(min(tree[s].sum.a,tree[s].sum.b),min(tree[s].sum.c,tree[s].sum.d));
        tree[x].s[1]=s,pushup(x);
    }
    return;
}
```
其中 `tree[x].s` 是儿子，`tree[x].v` 是这一节点维护的矩阵， `tree[x].sum` 是这一节点维护的矩阵积。\
\
而其他部分更改很少，可以参考[模板](https://www.luogu.com.cn/problem/P3690)\
\
对于每一次更改点权，可以用 access 函数让目标节点与根在同一条链上，再用 splay 让目标节点成为辅助树的根，这样就可以直接修改目标节点的矩阵，而不对其他节点造成影响。
```cpp
void revise(int x,int v){
    access(x),splay(x);
    tree[x].v.c+=v-val[x],tree[x].v.d+=v-val[x],val[x]=v;
    pushup(x);
    return;
}
```
在得到结果后，也可以使用这个函数将点权还原。\
\
lct 单次访问复杂度为 $O(\log n)$，有 $m$ 次访问，所以总复杂度为 $O(m\log n)$。
## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define N 100000
#define inf 214748364800000
using namespace std;
struct Matrix{int a,b,c,d;};
Matrix operator*(Matrix const &x,Matrix const &y){
    Matrix z;
    z.a=min(x.a+y.a,x.b+y.c),z.b=min(x.a+y.b,x.b+y.d),z.c=min(x.c+y.a,x.d+y.c),z.d=min(x.c+y.b,x.d+y.d);
    return z;
} //定义矩阵和矩阵乘法
struct Node{
    int s[2],f,size,tag;
    Matrix v,sum;
    Node(){s[1]=s[0]=f=size=tag=0,sum=v={};}
};
int n,m,ux,uy,ua,ub,tmp[N+5],val[N+5],f[N+5][2]={},ans;
Node tree[N+5];
vector<int>edge[N+5];
bool get(int x){return x==tree[tree[x].f].s[1];}
bool isroot(int x){return x!=tree[tree[x].f].s[0]&&x!=tree[tree[x].f].s[1];} //判断这个点是否是这颗splay的根
void pushup(int x){
    tree[x].sum=tree[tree[x].s[0]].sum*tree[x].v*tree[tree[x].s[1]].sum;
    tree[x].size=1+tree[0tree[x].s[0]].size+tree[tree[x].s[1]].size;
    return;
} //更新这个点的数据
void pushdown(int x){ //用于放下标记的函数，在本题没用
    if(!tree[x].tag)return;
    if(tree[x].s[0])tree[tree[x].s[0]].tag^=1;
    if(tree[x].s[1])tree[tree[x].s[1]].tag^=1;
    swap(tree[tree[x].s[0]].s[0],tree[tree[x].s[0]].s[1]);
    swap(tree[tree[x].s[1]].s[0],tree[tree[x].s[1]].s[1]);
    tree[x].tag=0;
    return;
}
void update(int x){
    if(!isroot(x))update(tree[x].f);
    pushdown(x);
    return;
} //同样用于放下标记
void rot(int x){
    int fx=tree[x].f,ffx=tree[fx].f,gx=get(x);
    if(!isroot(fx))tree[ffx].s[get(fx)]=x; //注意这里是!isroot(fx)而不是fx!=0
    if(tree[x].s[gx^1])tree[tree[x].s[gx^1]].f=fx;
    tree[fx].s[gx]=tree[x].s[gx^1],tree[x].s[gx^1]=fx;
    tree[fx].f=x,tree[x].f=ffx,pushup(fx),pushup(x);
    return;
} //旋转操作
void splay(int x){
    update(x);
    for(int f=tree[x].f;f=tree[x].f,!isroot(x);rot(x)){
        if(!isroot(f))rot(get(f)==get(x)?f:x); //同样注意是!isroot(fx)而不是fx!=0
    }
    return;
} //splay操作
void access(int x){
    for(int s=0;x;s=x,x=tree[x].f){
        splay(x);
        tree[x].v.b+=min(tree[tree[x].s[1]].sum.c,tree[tree[x].s[1]].sum.d)-min(tree[s].sum.c,tree[s].sum.d);
        tree[x].v.c+=min(min(tree[tree[x].s[1]].sum.a,tree[tree[x].s[1]].sum.b),min(tree[tree[x].s[1]].sum.c,tree[tree[x].s[1]].sum.d))-min(min(tree[s].sum.a,tree[s].sum.b),min(tree[s].sum.c,tree[s].sum.d));
        tree[x].v.d+=min(min(tree[tree[x].s[1]].sum.a,tree[tree[x].s[1]].sum.b),min(tree[tree[x].s[1]].sum.c,tree[tree[x].s[1]].sum.d))-min(min(tree[s].sum.a,tree[s].sum.b),min(tree[s].sum.c,tree[s].sum.d));
        //更新矩阵值
        tree[x].s[1]=s,pushup(x);
    }
    return;
} //将目标点与根节点成为一条链
void build(int x){
    tree[x].size=1,f[x][1]=val[x];
    for(int i:edge[x]){
        if(i==tree[x].f)continue;
        tree[i].f=x,build(i);
        f[x][0]+=f[i][1],f[x][1]+=min(f[i][0],f[i][1]);
    }
    tree[x].v={inf,f[x][0],f[x][1],f[x][1]},pushup(x);
    return;
} //设置初值
void revise(int x,int v){
    access(x),splay(x); //旋转到根
    tree[x].v.c+=v-val[x],tree[x].v.d+=v-val[x],val[x]=v; //更新矩阵值
    pushup(x);
    return;
} //修改点权
int read(){
    int f=1,g=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')f=-1;
        ch=getchar();
    }
    while('0'<=ch&&ch<='9'){
        g=g*10+ch-'0';
        ch=getchar();
    }
    return f*g;
}
void print(int x){
    if(x<0){
        putchar('-');
        x*=-1;
    }
    if(x>9)print(x/10);
    putchar(x%10+'0');
    return;
}
main(){
    n=read(),m=read(),read();
    tree[0].sum=tree[0].v={0,inf*10,inf*10,0};
    for(int i=1;i<=n;i++)tmp[i]=val[i]=read();
    for(int i=1;i<n;i++){
        ux=read(),uy=read();
        edge[ux].push_back(uy);
        edge[uy].push_back(ux);
        //邻接矩阵存图
    }
    build(1); //建树
    for(int i=1;i<=m;i++){
        ua=read(),ux=read(),ub=read(),uy=read();
        revise(ua,(ux?-inf:inf)),revise(ub,(uy?-inf:inf));
        access(1),splay(1);
        ans=min(min(tree[1].sum.a,tree[1].sum.b),min(tree[1].sum.c,tree[1].sum.d));
        ans+=(ux+uy)*inf+ux*tmp[ua]+uy*tmp[ub];
        if(ans<=10000000000ll)print(ans); //这里与题解中使用了不同的方法，但也正确
        else print(-1);
        putchar('\n');
        revise(ub,tmp[ub]),revise(ua,tmp[ua]); //注意顺序与修改时相反
    }
    return 0;
}
```

---

## 作者：xinxin2022 (赞：0)

## 简述题面

给定一颗树，规定相邻两点必须至少有一个点染色，点 $i$ 染色代价为 $p_i$，有 $m$ 次询问，每次规定两个点（必须/必须不）染色，每次回答此时的最小代价。

## 思路

每个点的可选状态是动态的，考虑动态DP。

先考虑静态情况，设 $f_{u,0/1}$ 表示点 $u$ 是否染色时整个子树的最小染色代价。

依据题意，有：

$$f_{u,0}=\sum_{v} f_{v,1}$$

$$f_{u,1}=\sum_{v} \min(f_{v,0},f_{v,1})$$

对于强制选择，将 $f_{u,0}$ 设为一个极大值，对于强制不选，将 $f_{u,1}$ 设为一个极大值。

再考虑每次修改对于答案的影响。显然只影响父亲到根那条链，那么考虑树链剖分将树拍成一条序列维护。

而为了适应线段树，记 $g_{u,0/1}$ 表示 $u$ 节点的轻儿子全选/随意选时的答案。

那么有：

$$f_{u,0}=f_{v,1}+g_{v,0}$$

$$f_{u,1}=\min(f_{v,0},f_{v,1})+g_{v,1}$$

转成矩阵：

$$\left[\begin{matrix}\infin& g_{u,0}\\g_{u,1}&g_{u,1}\end{matrix}\right]\otimes \left[\begin{matrix}f_{v,0}\\f_{v,1}\end{matrix}\right]=\left[\begin{matrix}f_{u,0}\\f_{u,1}\end{matrix}\right]$$

其中对于 $x\times x$ 的矩阵 $C=A\otimes B$，规定：

$$C_{i,j}=\min_{k=1}^{x} A_{i,k}+B_{k,j}$$

又因为此时 $f$ 作为维护值不可更改，考虑修改 $g$ 来达到强制选/不选的效果。

使用线段树维护即可，复杂度 $O(m\log^2n)$

code:


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+5;
const int V=1e12;
int n,m,c[N];
string s;
int a,x,b,y,u,v,ya,yb;
vector<int> G[N];
struct node{
    int a[3][3];
    node(){
        for(int i=0;i<2;i++)
            for(int j=0;j<2;j++)
                a[i][j]=V;
    }
}f[4*N],g[N],wsr;
int dfn[N],sz[N],son[N],ds[N][2],tp[N],tot,st[N],ed[N],fa[N];
void dfsn(int u,int ft){
    sz[u]=1;
    fa[u]=ft;
    for(int v:G[u]){
        if(v==ft) continue;
        dfsn(v,u);
        sz[u]+=sz[v];
        if(sz[v]>sz[son[u]]) son[u]=v;
    }
}
void dfs(int u,int idl){
    tp[u]=idl;
    st[u]=++tot;
    dfn[tot]=u;
    ed[idl]=tot;
    ds[u][1]=c[u];
    g[u].a[0][1]=0;
    g[u].a[1][0]=g[u].a[1][1]=c[u];
    if(!son[u]) return ;
    dfs(son[u],idl);
    ds[u][0]+=ds[son[u]][1];
    ds[u][1]+=min(ds[son[u]][1],ds[son[u]][0]);
    for(int v:G[u]){
        if(v==son[u]||v==fa[u]) continue;
        dfs(v,v);
        ds[u][0]+=ds[v][1];
        ds[u][1]+=min(ds[v][0],ds[v][1]);
        g[u].a[0][1]+=ds[v][1];
        g[u].a[1][0]+=min(ds[v][0],ds[v][1]);
        g[u].a[1][1]=g[u].a[1][0];
    }
}
node w(node f,node s){
    for(int i=0;i<2;i++)
        for(int j=0;j<2;j++)
            wsr.a[i][j]=V;
    for(int i=0;i<2;i++)
        for(int j=0;j<2;j++)
            for(int k=0;k<2;k++)
                wsr.a[i][j]=min(wsr.a[i][j],f.a[i][k]+s.a[k][j]);
    return wsr;
}
void push_up(int p){
    f[p]=w(f[p*2],f[p*2+1]);
}
void build(int p,int l,int r){
    if(l==r){
        f[p]=g[dfn[l]];
        return ;
    }
    build(p*2,l,(l+r)/2);
    build(p*2+1,(l+r)/2+1,r);
    push_up(p);
}
void upd(int p,int l,int r,int k){
    if(l==r){
        f[p]=g[dfn[k]];
        return;
    }
    if(k<=(l+r)/2) upd(p*2,l,(l+r)/2,k);
    else upd(p*2+1,(l+r)/2+1,r,k);
    push_up(p);
}
node ans(int p,int l,int r,int ql,int qr){
    if(ql<=l&&r<=qr) return f[p];
    if(qr<=(l+r)/2) return ans(p*2,l,(l+r)/2,ql,qr);
    else if(ql>(l+r)/2) return ans(p*2+1,(l+r)/2+1,r,ql,qr);
    else return w(ans(p*2,l,(l+r)/2,ql,qr),ans(p*2+1,(l+r)/2+1,r,ql,qr));
}
void updl(int u){
    node fir,sed;
    int now=u;
    while(now){
        fir=ans(1,1,n,st[tp[now]],ed[tp[now]]);
        upd(1,1,n,st[now]);
        sed=ans(1,1,n,st[tp[now]],ed[tp[now]]);
        now=fa[tp[now]];
        g[now].a[0][1]+=sed.a[1][1]-fir.a[1][1];
        g[now].a[1][0]+=min(sed.a[0][1],sed.a[1][1])-min(fir.a[0][1],fir.a[1][1]);
        g[now].a[1][1]=g[now].a[1][0];
    }
}
void upd_1(int u,int sx){
    g[u].a[1][0]+=sx*V;
    g[u].a[1][1]=g[u].a[1][0];
    updl(u);
}
void upd_2(int u,int sx){
    g[u].a[0][1]+=sx*V;
    updl(u);
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n>>m>>s;
    for(int i=1;i<=n;i++) cin>>c[i];
    for(int i=1;i<n;i++){
        cin>>u>>v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    dfsn(1,0);
    dfs(1,1);
    build(1,1,n);
    while(m--){
        cin>>a>>x>>b>>y;
        if(x) upd_2(a,1);
        else upd_1(a,1);
        if(y) upd_2(b,1);
        else upd_1(b,1);
        node answer=ans(1,1,n,st[1],ed[1]);
        int Ans=min(answer.a[0][1],answer.a[1][1]);
        if(Ans>=V) Ans=-1;
        cout<<Ans<<'\n';
        if(x) upd_2(a,-1);
        else upd_1(a,-1);
        if(y) upd_2(b,-1);
        else upd_1(b,-1);
    }
    return 0;
}
```

---

## 作者：w9095 (赞：0)

[P5024 [NOIP2018 提高组] 保卫王国](https://www.luogu.com.cn/problem/P5024)

无解的情况很好判断，同一条边上两个点都不能选，显然无解。其他情况均有解。

由于涉及树上 DP 和修改，想到动态 DP。

设 $f_{i,0}$ 表示不选 $i$ 以 $i$ 为根的子树内最小总费用，$f_{i,1}$ 表示选 $i$ 以 $i$ 为根的子树内最小总费用。

$$f_{i,0}=\sum_{j\in son(i)}f_{i,1}$$

$$f_{i,1}=\sum_{j\in son(i)}\min(f_{i,0},f_{i,1})+a_{i}$$

对于叶子节点，$f_{i,0}=0,f_{i,1}=a_i$。

设 $g_{i,1}$ 表示选择全部轻儿子的最小总费用，$g_{i,0}$ 表示可选可不选全部轻儿子的最小总费用加上选择自己的值，$j$ 表示重儿子。

$$f_{i,0}=\min(g_{i,1}+f_{j,1},\infty)$$

$$f_{i,1}=\min(g_{i,0}+f_{j,0},g_{i,0}+f_{j,1})$$

同样的，我们定义矩阵 $\min$ 运算。对于一个 $p\times q$ 的矩阵 $A$ 和一个 $q\times r$ 的矩阵 $B$，它们的 $\min$ 运算结果为一个 $p\times r$ 的矩阵 $C$。在这个矩阵中，$c_{i,j}$ 满足如下式子：

$$c_{i,j}=\min_{k=1}^q(c_{i,j},a_{i,k}+b_{k,j})$$

这个东西显然满足结合律。

依据动态 DP 的套路，写成矩阵形式。

$$\begin{bmatrix}\infty&g_{i,1}\\g_{i,0}&g_{i,0}\\\end{bmatrix}\begin{bmatrix}f_{j,0}\\f_{j,1}\end{bmatrix}=\begin{bmatrix}f_{i,0}\\f_{i,1}\end{bmatrix}$$

剩下的就是树链剖分加线段树维护即可。

对于必选点，我们把这个点的 $g_{i,1}$ 修改为正无穷，表示这个点不能不选。对于必不选点，我们把这个点的 $g_{i,0}$ 修改为正无穷，表示这个点不能选。需要修改在转移矩阵中对应位置的值。因为要修改转移矩阵，所以要修改整条重链，然后递归到根节点。

计算完答案之后，撤销影响，因为询问互相独立。

坑点很多，需要格外仔细。

```cpp
#include <bits/stdc++.h>
using namespace std;
struct matrix
{
	long long v[2][2];
}a[200000];
struct edge
{
	long long v,nxt;
}e[400000];
struct node
{
	struct matrix g;
	long long l,r;
}tr[800000];
long long n,m,x,y,z,w,c[200000],h[200000],f[200000][2],cnt=0,root=1;
long long lc[800000],rc[800000];
long long dep[200000],fa[200000],siz[200000],hs[200000],id[200000],top[200000],ed[200000],dfc=0;
char typ[100];
void add_edge(long long u,long long v)
{
	e[++cnt].nxt=h[u];
	e[cnt].v=v;
	h[u]=cnt;
}

struct matrix matrix_min(struct matrix a,struct matrix b)
{
	struct matrix c;
	for(int i=0;i<2;i++)
	    for(int j=0;j<2;j++)
	        c.v[i][j]=1e16;
	for(int i=0;i<2;i++)
	    for(int j=0;j<2;j++)
	        for(int k=0;k<2;k++)
	            c.v[i][j]=min(c.v[i][j],a.v[i][k]+b.v[k][j]);
	return c;
}

void pushup(long long x)
{
	tr[x].g=matrix_min(tr[lc[x]].g,tr[rc[x]].g);
}

void build(long long now,long long l,long long r)
{
	lc[now]=now*2,rc[now]=now*2+1;
	tr[now].l=l,tr[now].r=r;
	if(l==r)
	   {
	   	tr[now].g=a[l];
	   	return;
	   }
	long long mid=(l+r)>>1;
	build(lc[now],l,mid),build(rc[now],mid+1,r);
    pushup(now);
}

void update(long long now,long long k)
{
	if(tr[now].l==tr[now].r)
	   {
	   	tr[now].g=a[k];
	   	return;
	   }
	long long mid=(tr[now].l+tr[now].r)>>1;
	if(k<=mid)update(lc[now],k);
	else if(k>=mid+1)update(rc[now],k);
	pushup(now);
}

struct matrix query(long long now,long long l,long long r)
{
	if(tr[now].l>=l&&tr[now].r<=r)return tr[now].g;
	long long mid=(tr[now].l+tr[now].r)>>1;
	if(l>mid)return query(rc[now],l,r);
	else if(r<mid+1)return query(lc[now],l,r);
	else return matrix_min(query(lc[now],l,r),query(rc[now],l,r));
}

void dfs1(long long x,long long f)
{
	long long mx=0,ans=0;
	dep[x]=dep[f]+1,fa[x]=f,siz[x]=1;
	for(int i=h[x];i;i=e[i].nxt)
	    if(e[i].v!=f)
		    {
		    	dfs1(e[i].v,x);
		    	if(siz[e[i].v]>mx)mx=siz[e[i].v],ans=e[i].v;
		    	siz[x]+=siz[e[i].v];
			}
	hs[x]=ans;
}

void dfs2(long long x,long long pr,long long tf)
{
	id[x]=++dfc,top[x]=tf,ed[tf]=max(ed[tf],id[x]);
	f[x][1]=c[x];
	a[id[x]].v[1][0]=c[x],a[id[x]].v[0][0]=1e16;
	if(hs[x]!=0)
	   {
	   dfs2(hs[x],x,tf);
	   f[x][0]+=f[hs[x]][1];
	   f[x][1]+=min(f[hs[x]][0],f[hs[x]][1]);
       }
	for(int i=h[x];i;i=e[i].nxt)
	    if(e[i].v!=pr&&e[i].v!=hs[x])
	       {
		   dfs2(e[i].v,x,e[i].v);
		   f[x][0]+=f[e[i].v][1];
		   f[x][1]+=min(f[e[i].v][0],f[e[i].v][1]);
		   a[id[x]].v[0][1]+=f[e[i].v][1];
		   a[id[x]].v[1][0]+=min(f[e[i].v][0],f[e[i].v][1]);
	       }
	a[id[x]].v[1][1]=a[id[x]].v[1][0];
}

void rupdate(long long x,long long y)
{
    while(x!=0)
      {
      	struct matrix pre=query(root,id[top[x]],ed[top[x]]);
      	update(root,id[x]);
      	struct matrix now=query(root,id[top[x]],ed[top[x]]);
      	x=fa[top[x]];
      	a[id[x]].v[0][1]=a[id[x]].v[0][1]-pre.v[1][1]+now.v[1][1];
      	a[id[x]].v[1][0]=a[id[x]].v[1][0]-min(pre.v[0][1],pre.v[1][1])+min(now.v[0][1],now.v[1][1]);
	    a[id[x]].v[1][1]=a[id[x]].v[1][0]; 
	  }
}

void change(long long x,long long p,long long y)
{
	a[id[x]].v[p^1][p]=y;
	a[id[x]].v[1][1]=a[id[x]].v[1][0];
	rupdate(x,y);
}

int main()
{
	scanf("%lld%lld%s",&n,&m,typ);
	for(int i=1;i<=n;i++)scanf("%lld",&c[i]);
	for(int i=1;i<=n-1;i++)
	    {
	    	scanf("%lld%lld",&x,&y);
	    	add_edge(x,y),add_edge(y,x);
		}
	dfs1(1,0),dfs2(1,0,1);
	build(root,1,n);
	for(int i=1;i<=m;i++)
	    {
	    	scanf("%lld%lld%lld%lld",&x,&y,&z,&w);
	    	if(dep[x]<dep[z])swap(x,z),swap(y,w);
	    	if(y==0&&w==0)
	    	   {
	    	   	bool flag=0;
	    	   	for(int i=h[x];i;i=e[i].nxt)
	    	   	    if(e[i].v==z)flag=1;
	    	   	if(flag)
	    	   	    {
	    	   	   	printf("-1\n");
	    	   	   	continue;
					}
			   }
			long long px=a[id[x]].v[y^1][y],pz=a[id[z]].v[w^1][w];
			change(x,y,1e16);
			change(z,w,1e16);
	    	struct matrix ans=query(root,id[1],ed[1]);
	    	printf("%lld\n",min(ans.v[0][1],ans.v[1][1]));
	    	change(x,y,px);
			change(z,w,pz);
		}
	return 0;
}
```

---

## 作者：我梦见一片焦土 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P5024)

---

# 思路：

我们可以通过树形 ```DP``` 在线性时间内求出一个点 $u$ 如果颜色为 $c$，那么整棵树的最小代价为 $f_{u,c}$，具体的做法就是先从下往上树形 ```DP``` 得出点 $u$ 如果选 $c$ 这个颜色的话整个子树中的最小代价为 $dp1_{u,c}$，然后从上往下 ```DP``` 得出点 $u$ 的父亲如果选 $c$ 这个颜色的话，以 $u$ 为根 $u$ 父亲子树中的最小代价为 $dp2_{u,c}$。

发现如果固定两个点 $u,v$ 的颜色分别为 $c,d$，那么就应该对于树上 $u$ 到 $v$ 路径上（不包含 $u$ 和 $v$）的每一个点分别考虑是否染黑。

因为 $dp$ 信息是可减的，所以如果那条链上的染色的方案已经确定下来了，我们容易算出总代价：考虑路径上从上往下连续的三个点 $u,v,w$ 颜色为 $c$ ，那么 $v$ 的贡献就是 $f_{v,c}-dp1_{w,d}-dp2_{v,d}$，其中 $d$ 表示能够和 $c$ 相临的颜色。我们把这个贡献算在 $(u,v)$ 这条边上。

考虑如何确定最优的链上染色方案。对于树上从上往下的两条链，其中一条链顶端的父亲是另一条链的底端，我们要合并这两条链的信息。发现 ```DP``` 转移只和链的两端的颜色有关，所以对于一条链只需记录它两边是否染黑即可。合并的时候枚举相邻两点的颜色，如果不全为 $0$ 则合法。

于是，我们考虑倍增。令 $g_{i,j,k}$ 表示 $i$ 点向上长度为 $2^j$ 的链，顺序为从下往上或者从上往下的 $DP$ 值。这样就可以通过倍增转移，询问时像查询 ```LCA``` 一样查询即可。时间复杂度 $O((n+q)\log n)$。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=2e5+10;
const int INF=0x3f3f3f3f3f3f3f3f3f3f3f3f;
int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-'){
            f=-1;
        }
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
void write(int x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9){
        write(x/10);
    }
    putchar(x%10+'0');
    return;
}
int n,m,a[N],tot,tr[N],nt[N],lk[N],dep[N],cnt,l[N],r[N],fa[N][19],dp1[N][2],dp2[N][2],f[N][2];
string ss;
struct node{
    int dp[2][2];
    node(){ 
        dp[0][0]=dp[0][1]=dp[1][0]=dp[1][1]=INF;
    }
    int gm(){
        int ans=INF;
        for(int i=0;i<2;i++){
            for(int j=0;j<2;j++){
                ans=min(ans,dp[i][j]);
            }
        }
        return ans;
    }
    friend node merge(const node &a,const node &b){
        node c;
        for(int i=0;i<2;i++){
            for(int j=0;j<2;j++){
                for(int k=0;k<2;k++){
                    for(int l=0;l<2;l++){
                        if(k||l){
                            c.dp[i][j]=min(c.dp[i][j],a.dp[i][k]+b.dp[l][j]);
                        }
                    }
                }
            }
        }
        return c;
    }
}g[N][20][2];
void add(int u,int v){
    tr[++tot]=v;
    nt[tot]=lk[u];
    lk[u]=tot;
}
void dfs1(int u,int p){
    dp1[u][1]=a[u];
    for(int e=lk[u],v;e;e=nt[e]){
        if((v=tr[e])==p){
            continue;
        }
        dfs1(v,u);
        dp1[u][0]+=dp1[v][1];
        dp1[u][1]+=min(dp1[v][0],dp1[v][1]);
    }
}
void dfs2(int u,int p){
    for(int e=lk[u],v;e;e=nt[e]){
        if((v=tr[e])==p){
            continue;
        }
        dp2[v][0]=dp2[u][1]+dp1[u][0]-dp1[v][1];
        dp2[v][1]=min(dp2[u][0],dp2[u][1])+dp1[u][1]-min(dp1[v][0],dp1[v][1]);
        dfs2(v,u);
    }
    f[u][0]=dp2[u][1];
    f[u][1]=a[u]+min(dp2[u][0],dp2[u][1]);
    for(int e=lk[u],v;e;e=nt[e]){
        if((v=tr[e])==p){
            continue;
        }
        f[u][0]+=dp1[v][1];
        f[u][1]+=min(dp1[v][0],dp1[v][1]);
    }
}
void dfs3(int u,int p){
    dep[u]=dep[p]+1;
    fa[u][0]=p;
    l[u]=r[u]=++cnt;
    int A=f[p][0]-dp1[u][1]-dp2[p][1],B=f[p][1]-min(dp1[u][0],dp1[u][1])-min(dp2[p][0],dp2[p][1]);
    g[u][0][0].dp[0][0]=A;
    g[u][0][0].dp[1][1]=B;
    g[u][0][1].dp[0][0]=A;
    g[u][0][1].dp[1][1]=B;
    for(int i=0,t;(t=fa[fa[u][i]][i]);i++){
        fa[u][i+1]=t;
        g[u][i+1][0]=merge(g[u][i][0],g[fa[u][i]][i][0]);
        g[u][i+1][1]=merge(g[fa[u][i]][i][1],g[u][i][1]);
    }
    for(int e=lk[u],v;e;e=nt[e]){
        if((v=tr[e])==p)continue;
        dfs3(v,u),r[u]=r[v];
    }
}
int solve(int u,int a,int v,int b){
    if(dep[u]>dep[v]){
        swap(u,v);
        swap(a,b);
    }
    node A,B;
    B.dp[b][b]=f[v][b]-(!b?dp2[v][1]:min(dp2[v][0],dp2[v][1]));
    if(l[u]<=l[v]&&l[v]<=r[u]){
        int df=dep[v]-dep[u]-1;
        for(int i=0;i<=16;i++){
            if(df>>i&1){
                B=merge(g[v][i][1],B);
                v=fa[v][i];
            }
        }
        A.dp[a][a]=f[u][a]-(!a?dp1[v][1]:min(dp1[v][0],dp1[v][1]));
        return merge(A,B).gm();
    }
    A.dp[a][a]=f[u][a]-(!a?dp2[u][1]:min(dp2[u][0],dp2[u][1]));
    int df=dep[v]-dep[u];
    for(int i=0;i<=16;i++){
        if(df>>i&1){
            B=merge(g[v][i][1],B);
            v=fa[v][i];
        }
    }
    if(!(fa[u][0]==fa[v][0])){
        for(int i=16;~i;i--){
            if(fa[u][i]!=fa[v][i]){
                A=merge(A,g[u][i][0]);
                B=merge(g[v][i][1],B);
                u=fa[u][i],v=fa[v][i];
            }
        }
    }
    node C;
    int x=fa[u][0];
    C.dp[0][0]=f[x][0]-dp1[u][1]-dp1[v][1];
    C.dp[1][1]=f[x][1]-min(dp1[u][0],dp1[u][1])-min(dp1[v][0],dp1[v][1]);
    return merge(A,merge(C,B)).gm();
}
signed main(){
    cin>>n>>m>>ss;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int i=1,u,v;i<n;i++){
        cin>>u>>v;
        add(u,v);
        add(v,u);
    }
    dfs1(1,0);
    dfs2(1,0);
    dfs3(1,0);
    while(m--){
        int a,x,b,y;
        cin>>a>>x>>b>>y;
        int ans=solve(a,x,b,y);
        if(ans==INF){
            cout<<-1<<endl;
        }else{
            cout<<ans<<endl;
        }
    }
    return 0;
}
```
完结撒花~

---


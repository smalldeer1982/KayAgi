# 【XR-1】逛森林

## 题目背景

NaCly_Fish 和 PinkRabbit 是好朋友。

有一天她去森林里游玩，回去跟 PinkRabbit 说：“我发现好多棵会动的树耶！”

PinkRabbit 动了动一只兔耳朵：“这有什么好稀奇的，我用一只兔耳朵就能维护每棵树的形态。”

NaCly_Fish 不服：“不止这样，我还看到有一些传送门，能从一条树枝跳到另一条树枝上呢！”

PinkRabbit 动了动另一只兔耳朵：“这有什么好稀奇的，我用两只兔耳朵就能统计每个传送门的信息。”

![](https://cdn.luogu.com.cn/upload/pic/57782.png)

于是 NaCly_Fish 很郁闷，她向你求助，请帮帮她吧。

什么？你不愿意帮？

那她就不给你这题的分了。

## 题目描述

给你 $n$ 个节点的森林，初始没有边。

有 $m$ 个操作，分为两种：

$1\ u_1\ v_1\ u_2\ v_2\ w$：表示构建一个单向传送门，从 $u_1 \rightarrow v_1$ 简单路径上的所有节点，可以花费 $w$ 的代价，到达 $u_2 \rightarrow v_2$ 简单路径上的所有节点。若 $u_1$ 到 $v_1$ 或 $u_2$ 到 $v_2$ 不连通(由 $2$ 操作产生的边不连通)，则忽略此次操作。

$2\ u\ v\ w$：表示将 $u$ 和 $v$ 节点间连一条花费为 $w$ 的无向边，若 $u$ 和 $v$ 之间已连通(由 $2$ 操作产生的边连通)则忽略此次操作。

经过这 $m$ 次操作后，请你求出从 $s$ 节点出发，到每个节点的最小花费。

## 说明/提示

【样例说明】

这是样例中给出的树（严格来讲，这棵树也是一条链）：

![](https://cdn.luogu.com.cn/upload/image_hosting/g1kmzdbv.png)

有三个传送门，其中两个是这样的：

- 从 $1$ 号点可以花费 $2$ 的代价到达 $4 \rightarrow 9$ 简单路径上的所有节点（即 $4, 9$ 号点）。
- 从 $8 \rightarrow 5$ 简单路径上的所有节点（即 $8, 7, 6, 5$ 号点）可以花费 $1$ 的代价到达 $1 \rightarrow 6$ 简单路径上的所有节点（即 $1, 3, 5, 6$ 号点）。

容易看出从 $5$ 号节点出发，到达其它节点的最小花费分别为：$1, 1, 1, 1, 0, 1, 7, 9, 1$。

【数据规模与约定】

对于第 $1, 2$ 个测试点，$1 \le n \le 100$，$1 \le m \le 300$。

对于第 $3, 4$ 个测试点，$1 \le n \le 1000$，$1 \le m \le 3000$。

对于 $100\%$ 的数据，$1\le n \le 50000$，$1\le m \le 10^6$，$1\le u,v \le n$，$1\le w \le 100$。

对于第 $1$ ~ $10$ 个测试点，每个 $5$ 分。

对于第 $11, 12$ 个测试点，每个 $25$ 分。

## 样例 #1

### 输入

```
9 11 5
2 2 1 2
2 3 1 5
2 4 2 10
2 5 3 9
2 6 5 3
2 7 6 6
2 8 7 2
2 9 4 2
1 1 1 4 9 2
1 8 5 1 6 1
1 3 6 9 6 1```

### 输出

```
1 1 1 1 0 1 7 9 1```

# 题解

## 作者：CYJian (赞：164)

![](https://cdn.luogu.com.cn/upload/image_hosting/63qhwg5z.png)

关于树剖，它还活着... ~~大家珂以忽略那个群名片...~~

---

首先我们可以用并查集动态维护森林的连通状态，然后我们就知道了哪些边/传送门要留下。

然后考虑怎么处理传送门：

首先非常 naive 的想法是：直接树剖，剖出来之后再强上线段树优化建图

好，时间复杂度 $O(m \log^3 n)$，空间复杂度 $O(m \log^2 n)$，你人没了。。

---

如果你打了一个这样的 ~~shit~~ 出来，发现空间耗得贼大，跑到天荒地老才跑出一坨东西出来，然后又不想删掉它，你就可以想一想怎么优化它：

你可以发现，对于每个从一条剖出来的链 中间的点 到 链顶 的一段区间 连边的段数实际上是 $O(m \log n)$ 级别的。如果这里连的边数不是线段树优化的 $O(\log n)$ 而是 $O(1)$ 的话，你就赢了~~引用一下神仙zzq的名言~~。

那么怎么搞呢？

我们知道，对于一个序列，如果我们只要求这个序列的**前缀**信息 **且不用修改** ，完全可以不用线段树维护，而是可以直接求前缀和之类的东西。这样就可以把线段树的 $O(\log n)$ 级别的信息维护转化为了 $O(1)$。

所以这样可能你就明白了：对于每一个点，我们开两个虚点，一个表示连出去的，一个表示连进来的。

然后对于连进来的，我们把一条重链上的所有这样的虚边由深度大的连向深度小的，然后串成一条链，这样我们就可以通过连向一个点的虚点来实现连向这个点对应的实点一直到链顶的这样一条链。

对于连出去的同理，方向反一下就行了。

画成一张图大概就长这样了：(1-2-3的一条链，左边是连进来的，右边是连出去的)

![](https://cdn.luogu.com.cn/upload/image_hosting/x0pcx2lf.png)

然后这样我们就可以实现 $O(m \log n)$ 条边了。

啥？你说最后两个点在同一个重链上的时候怎么办？？

你之前写的线段树优化建图就可以用上了。。

反正连上去也是 $O(m \log n)$ 级别的边数。

然后配上一个 ${\rm Dijsktra}$，这样复杂度就是 $O(m \log^2 n)$ 了。

代码太长了，这里就给个剪贴板的[链接](https://www.luogu.org/paste/vo6jk8sn)

---

## 作者：nkwhale (赞：40)

[也好不了多少的阅读体验](https://www.cnblogs.com/whale-at-cola/p/solution-p5344.html)

[题目传送门](https://www.luogu.com.cn/problem/solution/P5344)

本题解主要面向倍增优化建图的初学者，类似于我个人倍增优化建图的学习笔记。

前置芝士：Dijkstra ，树上倍增。

## 思路

明显先离线把第二个操作的树建好以后再把符合条件的第一类操作加上会更方便。

具体就是先把读入操作，然后用并查集维护一下连通性判断这个操作是否合法，把合法的 2 操作直接加边，合法的 1 操作存起来。

然后处理倍增数组，将合法的 1 操作用倍增优化建图加边。

所以这题大概可以当个倍增优化建图板子（为什么这东西会有板子啊）。

### 倍增优化建图板子

考虑对于一条链的两个端点求 LCA 的过程，如果可以把跳一次倍增数组所越过的节点当做单独一个点的话，就可以用这个点连边而不需要每个点都走一次了。

基于这个思路，可以对于倍增所使用的 $f$ 数组开两个虚节点，称作 $in$ 和 $out$ ，$in$ 来存入边，$out$ 来存出边，然后将倍增中下一级的 $out$ 向本级的 $out$ 连边，本级的 $in$ 向下级的 $in$ 连边。

此处建议看图理解，$x0$ 至 $x4$ 为树上的某条链，黑边为树边，红边为倍增的数组，附加了 $in$、$out$ 结点及下标，绿边为倍增时的新加边。

（全画会很挤，图中省略了部分内容，我尽力画了，图丑勿喷）

![](https://cdn.luogu.com.cn/upload/image_hosting/on6s3lwz.png)

显然，这样的结点数和边数都是 $O(n \log n)$ 的。

那么如何加边呢？1 操作中，对于边的出点，即 $u1$ 至 $v1$ 这条链上的点，可以在求他们的 LCA 时，每跳一次倍增数组将其 $out$ 这个虚节点向新建的虚节点连一条权为 $0$ 的边，同样的，对于边的入点，即 $u2$ 至 $v2$ 这条链上的点，可以在求他们的 LCA 时，每跳一次倍增数组将新建的虚节点向其 $in$ 这个虚节点连一条权为 $0$ 的边。最后把这两个新建的虚节点连一条带权边就好了。

注意如果倍增 LCA 的后半部分（即两个端点 $x$ 和 $y$ 深度相同后的部分）一次也没跳时，$y$ 会没有向外连边，需要特判这种情况将 $y$ 向外的连边补上，但是因为本题是求最短路的，直接不特判把 $y$ 的边连上也行。

搞完建图后直接跑一遍 Dijkstra 就行了。

因 $m \approx n \log n$，时间复杂度大致是  $O(n \log^2 n)$ 的。

## code
```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#include<vector>
using std::priority_queue;
using std::vector;
using std::greater;
using std::pair;
#define re register
#define pr pair<int,int>
#define fi first
#define se second
inline void swp(int &x,int &y){x^=y^=x^=y;}
inline int win(){
	int x=0;char c=getchar();
	while(c>'9'||c<'0') c=getchar();
	while(c>='0'&&c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return x;
}

const int inf=0x3f3f3f3f;
const int N=50050,M=1000050,NE=4000050,ME=16000050;
int l,tot,fa[N],v[N<<1],ne[N<<1],h[N],dep[N],f[N][16],in[N][16],ou[N][16];
int ted;
struct oprs{int x1,y1,x2,y2,w;}op[M];
int cnt,hd[NE],t;
struct edge{int v,d,n;}e[ME];
int dis[NE];
inline bool cmp(int x,int y){return dis[x]<dis[y];}
int get(int x){return fa[x]==x?x:(fa[x]=get(fa[x]));}
inline void addtree(int x,int y){
//	printf("addtree:%d %d\n",x,y);
	v[++tot]=y,ne[tot]=h[x],h[x]=tot;
	v[++tot]=x,ne[tot]=h[y],h[y]=tot;
}
inline void addedge(int x,int y,int w){e[++t]={y,w,hd[x]},hd[x]=t;}
void dfs(int x,int fr){
	dep[x]=dep[f[x][0]=fr]+1;
	in[x][0]=++cnt,addedge(cnt,x,0),addedge(cnt,fr,0);
	ou[x][0]=++cnt,addedge(x,cnt,0),addedge(fr,cnt,0);
	for(re int j=0;j<l;j++){
		f[x][j+1]=f[f[x][j]][j];
		in[x][j+1]=++cnt,addedge(cnt,in[x][j],0),addedge(cnt,in[f[x][j]][j],0);
		ou[x][j+1]=++cnt,addedge(ou[x][j],cnt,0),addedge(ou[f[x][j]][j],cnt,0);
	}
	for(re int i=h[x];i;i=ne[i]) if(v[i]!=fr) dfs(v[i],x);
}
inline void lca1(int x,int y,int k){
	if(dep[x]<dep[y]) swp(x,y);
	addedge(y,k,0);
	for(re int i=l;i>=0;i--) if(dep[f[x][i]]>=dep[y]) addedge(ou[x][i],k,0),x=f[x][i];
	if(x==y) return ;
	for(re int i=l;i>=0;i--) if(f[x][i]!=f[y][i])
		addedge(ou[x][i],k,0),x=f[x][i],addedge(ou[y][i],k,0),y=f[y][i];
	addedge(ou[x][0],k,0);
}
inline void lca2(int x,int y,int k){
	if(dep[x]<dep[y]) swp(x,y);
	addedge(k,y,0);
	for(re int i=l;i>=0;i--) if(dep[f[x][i]]>=dep[y]) addedge(k,in[x][i],0),x=f[x][i];
	if(x==y) return ;
	for(re int i=l;i>=0;i--) if(f[x][i]!=f[y][i])
		addedge(k,in[x][i],0),x=f[x][i],addedge(k,in[y][i],0),y=f[y][i];
	addedge(k,in[x][0],0);
}
inline void dijkstra(int s){
	memset(dis,0x3f,sizeof dis);
	priority_queue<pr,vector<pr>,greater<pr> > q;
	dis[s]=0,q.push((pr){0,s});
	pr x;
	while(!q.empty()){
		x=q.top(),q.pop();
		if(x.fi>dis[x.se]) continue;
		for(re int i=hd[x.se],y;i;i=e[i].n)
			if(dis[y=e[i].v]>x.fi+e[i].d)
				q.push((pr){dis[y]=x.fi+e[i].d,y});
	}
}
signed main(){
	int n=win(),m=win(),s=win(),kd,x1,y1,x2,y2,w;cnt=n;
	while((1<<l)<=n) ++l;
	l--;
//	printf("%d\n",l);
	for(re int i=1;i<=n;i++) fa[i]=i;
	while(m--){
		kd=win();
		if(kd==1){
			x1=win(),y1=win(),x2=win(),y2=win(),w=win();
			if(get(x1)!=get(y1)||get(x2)!=get(y2)) continue;
			op[++ted]={x1,y1,x2,y2,w};
		}
		else{
			x1=win(),y1=win(),x2=get(x1),y2=get(y1),w=win();
			if(x2==y2) continue;
			addtree(x1,y1),addedge(x1,y1,w),addedge(y1,x1,w),fa[x2]=y2;
		}
	}
	for(re int i=1;i<=n;i++) if(!dep[i]) dfs(i,0);
	for(re int i=1;i<=ted;i++)
		lca1(op[i].x1,op[i].y1,++cnt),lca2(op[i].x2,op[i].y2,++cnt),addedge(cnt-1,cnt,op[i].w);
	dijkstra(s);
	for(re int i=1;i<=n;i++) printf("%d ",dis[i]==inf?-1:dis[i]);
	puts("");
	return 0;
}
```

球点个赞吧，蟹蟹。

---

## 作者：NaCly_Fish (赞：21)

作为出题人来写一篇题解吧2333  

这题一眼看上去就是个裸题 ~~实际上也是如此~~  
有动态加边，不太好搞。  
我们很套路地离线操作，把所有数据都读进来，建好树再建额外的边。  
然后有一个很显然的做法，就是树剖+线段树优化建图  

然而出题人恶意卡了树剖，导致这种做法不MLE也会TLE。。  
那我们优化的方法也很简单，直接在树上倍增优化建图即可。   
时间复杂度大约是两个$\log$的。

最后这道题就做完了qwq  
Code:
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<vector>
#include<queue>
#define N 50007
#define M 1300003
#define ll long long
#define reg register
#define inf 0x3f3f3f3f
using namespace std;

struct edge{
    int v,w;
    edge(int v=0,int w=0):v(v),w(w){}
};

struct node{
    int id,d;
    node(int id=0,int d=0):id(id),d(d){}
    bool operator < (const node& nd) const{
        return d > nd.d;
    }
};

struct oper{
    int u1,v1,u2,v2,w;
    oper(int u1=0,int v1=0,int u2=0,int v2=0,int w=0):u1(u1),v1(v1),u2(u2),v2(v2),w(w){}
}q[M];

vector<edge> adj[M<<1];
vector<int> g[N];
int d[M<<1],uf[N],fa[N][18],lg2[N];
int cid[N][18],rid[N][18],dep[N];
int n,m,s,qc,img;

inline void read(int &x);
void print(int x);
void dijkstra();
void dfs(int u,int f);
inline int find(int x);
inline void link(int u,int v,int w);
inline int lca(int u,int v);
inline void build(int u,int v,int w,int t);
inline int kfa(int u,int k);

signed main(){
    int op,u,v,u1,v1,u2,v2,p1,p2,w;
    read(n),read(m),read(s);
    for(reg int i=1;i<=n;++i) uf[i] = i;
    for(reg int i=2;i<=n;++i) lg2[i] = lg2[i>>1]+1;
    for(reg int i=1;i<=m;++i){
        read(op);
        if(op==1){
            read(u1),read(v1),read(u2),read(v2),read(w);
            if(find(u1)!=find(v1)||find(u2)!=find(v2)) continue;
            q[++qc] = oper(u1,v1,u2,v2,w);
        }else{
            read(u),read(v),read(w);
            if(find(u)==find(v)) continue;
            g[u].push_back(v);
            g[v].push_back(u);
            link(u,v,w),link(v,u,w);
            uf[find(u)] = find(v);
        }
    }
    img = n+1;
    for(reg int i=1;i<=n;++i){
        if(dep[i]) continue;
        dfs(i,0);
    }
    for(reg int i=1;i<=qc;++i){
        u1 = q[i].u1,v1 = q[i].v1;
        u2 = q[i].u2,v2 = q[i].v2;
        w = q[i].w;
        p1 = lca(u1,v1),p2 = lca(u2,v2);
        ++img;
        build(u1,p1,0,0);
        build(v1,p1,0,0);
        build(u2,p2,w,1);
        build(v2,p2,w,1);
    }
    dijkstra();
    for(reg int i=1;i<=n;++i){
        if(d[i]==inf) printf("-1");
        else print(d[i]);
        putchar(' ');
    }
    return 0;
}

inline void build(int u,int v,int w,int t){
    reg int j = 0,u2,v2;
    for(;(2<<j)<=dep[u]-dep[v]+1;++j);
    u2 = kfa(u,dep[u]-dep[v]+1-(1<<j));
    if(t) v2 = rid[u][j];
    else v2 = cid[u][j];
    link(t?img:v2,t?v2:img,w);
    if(t) v2 = rid[u2][j];
    else v2 = cid[u2][j];
    link(t?img:v2,t?v2:img,w);
}

inline int kfa(int u,int k){
    reg int j = 0;
    while(k){
        if(k&1) u = fa[u][j];    
        k >>= 1;
        ++j;
    }
    return u;
}

inline int lca(int u,int v){
    if(dep[u]<dep[v]) swap(u,v);
    u = kfa(u,dep[u]-dep[v]);
    if(u==v) return u;
    for(int k=lg2[dep[u]];~k;--k){
        if(fa[u][k]==fa[v][k]) continue;
        u = fa[u][k],v = fa[v][k];
    }        
    return fa[u][0];
}

void dfs(int u,int f){
    fa[u][0] = f;
    cid[u][0] = rid[u][0] = u;
    dep[u] = dep[f]+1;
    for(reg int i=1;(1<<i)<dep[u];++i)
        fa[u][i] = fa[fa[u][i-1]][i-1];
    for(reg int i=1;(1<<i)<=dep[u];++i){
        cid[u][i] = ++img;
        rid[u][i] = ++img;
        link(cid[u][i-1],cid[u][i],0);
        link(rid[u][i],rid[u][i-1],0);
        link(cid[fa[u][i-1]][i-1],cid[u][i],0);
        link(rid[u][i],rid[fa[u][i-1]][i-1],0);
    }        
    int v,l = g[u].size();
    for(int i=0;i<l;++i){
        v = g[u][i];
        if(v==f) continue;
        dfs(v,u);
    }
}

inline void link(int u,int v,int w){
    adj[u].push_back(edge(v,w));
}

inline int find(int x){
    while(x^uf[x]) x = uf[x] = uf[uf[x]];
    return x;
}

void dijkstra(){
    memset(d,inf,sizeof(d));
    priority_queue<node> q;
    d[s] = 0;
    q.push(node(s,0));
    reg int u,v,w,du,l;
    while(!q.empty()){
        u = q.top().id;
        du = q.top().d;
        q.pop();
        if(du>d[u]) continue;
        l = adj[u].size();
        for(reg int i=0;i<l;++i){
            v = adj[u][i].v;
            w = adj[u][i].w;
            if(du+w>=d[v]) continue;
            d[v] = du+w;
            q.push(node(v,d[v]));
        }
    }
}

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

void print(int x){
    if(x>9) print(x/10);
    putchar(x%10+'0');
}
```

updated on 2019.05.06：  
出题人太菜，不小心撞了[BZOJ原题](http://darkbzoj.tk/problem/4699)。  
而且std也被$\Theta((n+m)\log n)$的解法吊打了。。  
关于一个log的正解，可以参考[这篇blog](https://www.cnblogs.com/clrs97/p/5870459.html)  

ps：不过倍增的常数似乎要小不少？


---

## 作者：command_block (赞：11)

**题意** : 给出一个 $n$ 个点的森林。有 $m$ 次操作构建一个新图 ：

每次挑两条简单路径 $t_1=u_1\leftrightarrow v_1,\ t_2=u_2\leftrightarrow v_2$ ，将 $t_1$ 上的每个点向 $t_2$ 上的每个点连边，边权为 $c$。

最终求新图的单源最短路。

$n\leq 5\times 10^4,m\leq 10^6$ ，时限$\texttt{3s}$ ，空限$\texttt{500M}$。

------------

好的练习题。

- 树剖优化建图

将每条路径拆成 $O(\log^2n)$ 个线段树节点，然后连边。

点数 $O(n)$ 边数 $O(m\log^2n)$ ，最短路复杂度为 $O(m\log^3n)$，无法通过。

- 倍增/ST优化建图

注意到树剖拆出的边多是因为预先准备的点太少了，不妨使用预处理点更密集的倍增。

这样就能做到 $O(n\log n)$ 点数 $O((n+m)\log n)$ 边数，若用普通堆跑 $\rm Dijkstra$ ，复杂度为 $O((n+m)\log^2 n)$ ，需要卡常才能通过。

注意到重复建边不会影响答案，那么可以使用类似 ST 表的方法。

这样即可做到 $O(n\log n)$ 点数 $O(n\log n+m)$ 边数，复杂度为 $O(n\log^2n+m\log n)$ ，可以通过。

- 不优化建图了

考虑 $\rm Dijkstra$ 算法的关键性质 ： 维护目前最小的转移，使得每次转移都是答案。

我们使用小根堆维护目前最小的一对路径间连边。

当转移生效时会触发路径赋值操作。使用并查集将已经被赋值的点缩起来，即可快速找到每个需要赋值的点。

不难发现，赋的值会越来越大。所以当某个点被赋值之后，只会更新那些未加入小根堆的转移。

现在问题还剩 ： 找出经过 $a$ 点的所有路径。

点 $a$ 在路径 $u\leftrightarrow v$ 上的判据 ： ${\rm lca}(u,v)=a$ 或 $[u\in a]≠[v\in a]$ （其中 $[u\in a]$ 表示 $u$ 在 $a$ 的子树中）

前者生效的总次数是 $O(m)$ 的，随便咋大力做。

后者可以利用 $\rm dfs$ 序转化成二维偏序。

注意我们只需要逐个找出符合要求的路径，所以，不必动用动态二维偏序。

将路径 $u\leftrightarrow v$ 根据 $dfn[u]$ 放置到数组中，维护区间 $\min dfn[v]$。（通过合适的交换使得 $dfn[u]<dfn[v]$）

当寻找经过 $a:[L,R]$ 的路径时，查询 $\rm dfs[u]$ 序在 $[L,R]$ 中的所有路径中 $dfn[v]$ 最小的，找出在 $[1,L)$ 内的 $dfn[v]$。

还需将最小值改成最大值再跑一遍，找出在 $(R,n]$ 内的 $dfn[v]$。

这只需要一棵线段树。

复杂度为 $O((n+m)\log n)$。

代码有亿点点长，但是细节不算特别多。

```cpp
#include<algorithm>
#include<vector>
#include<cstdio>
#include<queue>
#define Pr pair<int,int>
#define mp make_pair
#define fir first
#define sec second
#define pb push_back
#define MaxM 1005000
#define MaxN 50500
using namespace std;
const int INF=1000000000;
inline int read(){
  int X=0;char ch=0;
  while(ch<48||ch>57)ch=getchar();
  while(ch>=48&&ch<=57)X=X*10+(ch^48),ch=getchar();
  return X;
}
vector<int> g[MaxN],l[MaxN];
int tim,dfn[MaxN],out[MaxN],dep[MaxN],f[17][MaxN];
void dfs(int u)
{
  dfn[u]=++tim;
  for (int i=0,v;i<g[u].size();i++)
    if (!dfn[v=g[u][i]]){
      dep[v]=dep[f[0][v]=u]+1;
      dfs(v);
    }
  out[u]=tim;
}
int lca(int u,int v)
{
  if (dep[u]<dep[v])swap(u,v);
  int k=16;
  while(k--)
    while(dep[f[k][u]]>=dep[v])
      u=f[k][u];
  if (u==v)return u;
  k=16;
  while(k--)
    while(f[k][u]!=f[k][v])
      {u=f[k][u];v=f[k][v];}
  return f[0][u];
}
vector<Pr> sp[MaxN];
vector<int> sg[MaxN];
struct Data{
  int op,u,v,u2,v2,w,d;bool vis;
  void adl(int p)
  {
    int t=lca(u,v);sg[t].pb(p);
    sp[dfn[u]].pb(mp(dfn[v],p));
    sp[dfn[v]].pb(mp(dfn[u],p));
  }
}b[MaxM];
int n,pl[MaxN],pr[MaxN],tu[MaxN];
struct Node{
  Pr x0,x1;
  void clr(){x0.fir=n+1;x1.fir=0;}
}a[MaxN<<2],ret;
void up(int u)
{a[u].x0=min(a[u<<1].x0,a[u<<1|1].x0);
 a[u].x1=max(a[u<<1].x1,a[u<<1|1].x1);}
void build(int l=1,int r=n,int u=1)
{
  if (l==r){
    tu[l]=u;
    sort(sp[l].begin(),sp[l].end());
    pl[l]=0;pr[l]=sp[l].size()-1;
    if (pl[l]<=pr[l]){
      a[u].x0=sp[l][pl[l]];
      a[u].x1=sp[l][pr[l]];
    }else {
      a[u].x0=mp(n+1,0);
      a[u].x1=mp(0,0);
    }return ;
  }int mid=(l+r)>>1;
  build(l,mid,u<<1);
  build(mid+1,r,u<<1|1);
  up(u);
}
int wfl,wfr;
void qry(int l=1,int r=n,int u=1)
{
  if (wfl<=l&&r<=wfr){
    ret.x0=min(ret.x0,a[u].x0);
    ret.x1=max(ret.x1,a[u].x1);
    return ;
  }int mid=(l+r)>>1;
  if (wfl<=mid)qry(l,mid,u<<1);
  if (mid<wfr)qry(mid+1,r,u<<1|1);
}
void upd(int t)
{
  int u=tu[t];
  while(pl[t]<=pr[t]&&b[sp[t][pl[t]].sec].vis==1)pl[t]++;
  while(pl[t]<=pr[t]&&b[sp[t][pr[t]].sec].vis==1)pr[t]--;
  if (pl[t]<=pr[t]){
    a[u].x0=sp[t][pl[t]];
    a[u].x1=sp[t][pr[t]];
  }else {
    a[u].x0=mp(n+1,0);
    a[u].x1=mp(0,0);
  }while(u>1){u>>=1;up(u);}
}
struct UFS{
  int f[MaxN];
  void Init(int n)
  {for (int i=1;i<=n;i++)f[i]=i;}
  int find(int u)
  {return f[u]==u ? u : f[u]=find(f[u]);}
  bool chk(int x,int y)
  {return find(x)==find(y);}
  void merge(int x,int y)
  {f[find(x)]=find(y);}
}F;
int m,S,dis[MaxN+MaxM];
priority_queue<Pr> q;
void trans(int u,int lim,int d)
{
  u=F.find(u);
  while(dep[u]>=lim){
    if (dis[u]>d){
      dis[u]=d;
      q.push(mp(-dis[u],u));
    }
    F.merge(u,f[0][u]);
    u=F.find(u);
  }
}
void ext(Data B,int d){
  int t=lca(B.u2,B.v2);
  trans(B.u2,dep[t],d);
  trans(B.v2,dep[t],d);
}
inline void push(int p,int d)
{
  if (!b[p].vis){
    b[p].vis=1;
    q.push(mp(-(dis[p+n]=d+b[p].w),p+n));
  }
}
void ext(int u,int d)
{
  for (int i=0,v;i<g[u].size();i++)
    if (dis[v=g[u][i]]>dis[u]+l[u][i]){
      dis[v]=dis[u]+l[u][i];
      q.push(mp(-dis[v],v));
    }
  for (int i=0;i<sg[u].size();i++)
    push(sg[u][i],d);
  wfl=dfn[u];wfr=out[u];
  while(1){
    ret.clr();qry();
    if (wfl<=ret.x0.fir&&ret.x1.fir<=wfr)break;
    if (ret.x0.fir<wfl){
      push(ret.x0.sec,d);
      upd(dfn[b[ret.x0.sec].u]);
      upd(dfn[b[ret.x0.sec].v]);
    }if (wfr<ret.x1.fir){
      push(ret.x1.sec,d);
      upd(dfn[b[ret.x1.sec].u]);
      upd(dfn[b[ret.x1.sec].v]);
    }
  }
}
int main()
{
  n=read();m=read();S=read();
  for (int i=1;i<=m;i++){
    b[i].op=read();b[i].u=read();b[i].v=read();
    if (b[i].op==1)
      {b[i].u2=read();b[i].v2=read();}
    b[i].w=read();
  }
  F.Init(n);
  for (int i=1;i<=m;i++){
    if (b[i].op==2){
      if (F.chk(b[i].u,b[i].v))continue;
      g[b[i].u].pb(b[i].v);l[b[i].u].pb(b[i].w);
      g[b[i].v].pb(b[i].u);l[b[i].v].pb(b[i].w);
      F.merge(b[i].u,b[i].v);
    }
  }
  dep[0]=-1;
  for (int i=1;i<=n;i++)if (!dfn[i])dfs(i);
  for (int j=1;j<16;j++)
    for (int i=1;i<=n;i++)
      f[j][i]=f[j-1][f[j-1][i]];
  F.Init(n);
  for (int i=1;i<=m;i++){
    if (b[i].op==1){
      if (F.chk(b[i].u,b[i].v)&&F.chk(b[i].u2,b[i].v2))
        b[i].adl(i);
    }else F.merge(b[i].u,b[i].v);
  }
  build();
  F.Init(n);
  for (int i=1;i<=n+m;i++)dis[i]=INF;
  q.push(mp(dis[S]=0,S));
  while(!q.empty()){
    Pr u=q.top();q.pop();
    if (-u.fir!=dis[u.sec])continue;
    if (u.sec>n)ext(b[u.sec-n],-u.fir);
    else ext(u.sec,-u.fir);
  }
  for (int i=1;i<=n;i++)
    printf("%d ",dis[i]==INF ? -1 : dis[i]);
  return 0;
}
```


---

## 作者：花里心爱 (赞：10)

[题目链接](https://www.luogu.org/problemnew/show/P5344)

很显然，这是一道毒瘤题。

看上去像一个动态链剖分然后用一些奇怪的优化建图最后在跑一遍最短路~~关于spfa，她死了~~，然而这种东西根本没法维护……

然后我们发现询问只有一次，我们完全可以离线处理。先处理完2操作（也就是一个生成树）后，我们就可以知道树的形态了。

然后我们可以在处理生成树的时候同时判断哪些1操作是合法的。

因为树的形态已经知道了，所以我们可以直接树剖+线段树优化建图。[线段树优化建图板子题qwq](https://www.luogu.org/problemnew/show/CF786B)

注意图有可能不连通，我们要对每棵树都剖一遍（然而实际上可以共用一个dfs序，然后只需要一个大线段树）。

这样复杂度是$O(m\log^3n)$的，会`TLE/MLE`最后2个点。~~关键是这种做法十分难写，我试着写了一下大概有5kb~~

先放一下树剖的代码，可以得50分。
```cpp
#include <cstdio>
#include <cctype>
#include <cstring>
#include <algorithm>
#include <queue>
#define maxn 50005
#define maxm 1000005
#define Inf 0x3f3f3f3f
inline int read() {
    int d=0;char ch=getchar();while(!isdigit(ch))ch=getchar();
    while(isdigit(ch)){d=d*10+ch-48,ch=getchar();}return d;
}
int totedge;
int n, m, s;
struct query {
    int op;
    int u1, v1, u2, v2;
    int w;
}e[maxm];

namespace ufs { // 并查集
    int f[maxn];
    inline void init() {for(int i = 1; i <= n; ++i) f[i] = i;}
    int getf(int x) {return x == f[x] ? x : f[x] = getf(f[x]);}
    bool merge(int x, int y) {
        x = getf(x), y = getf(y); if(x == y) return false;
        f[x] = y; return true;
    }
}

namespace seg { // 线段树优化建图 + 最短路
#define segin(x) (x)
#define segout(x) ((x)+(n<<2))

    int head[maxn*31], ver[maxm*38], edge[maxm*38], nxt[maxm*38], tot;
    int epos[maxn*31];
    
    inline void add(int u, int v, int w) {++totedge;
        ver[++tot] = v, edge[tot] = w, nxt[tot] = head[u], head[u] = tot;
    }
    
    void build(int x, int l, int r) {
        add(segin(x), segout(x), 0);
        if(l == r)  {epos[l] = x; return;}
        int mid = (l+r)>>1;
        add(segin(x), segin(x<<1), 0), add(segin(x), segin(x<<1|1), 0);
        add(segout(x<<1), segout(x), 0), add(segout(x<<1|1), segout(x), 0);
        build(x<<1, l, mid), build(x<<1|1, mid+1, r);
    }
    
    void modifyin(int x, int l, int r, int tl, int tr, int pos, int w) {
        if(l >= tl && r <= tr) return add(pos, segin(x), w);
        int mid = (l+r)>>1;
        if(mid >= tl) modifyin(x<<1, l, mid, tl, tr, pos, w);
        if(mid < tr) modifyin(x<<1|1, mid+1, r, tl, tr, pos, w);
    }
    
    void modifyout(int x, int l, int r, int tl, int tr, int pos, int w) {
        if(l >= tl && r <= tr) return add(segout(x), pos, w);
        int mid = (l+r)>>1;
        if(mid >= tl) modifyout(x<<1, l, mid, tl, tr, pos, w);
        if(mid < tr) modifyout(x<<1|1, mid+1, r, tl, tr, pos, w);
    }
    
    void connect(int x, int y, int w) {
        add(segout(epos[x]), segin(epos[y]), w);
        add(segout(epos[y]), segin(epos[x]), w);
    }
    
    int dist[maxn*31], vis[maxn*31];
    std::priority_queue< std::pair<int, int> > q;
    
    void dij(int sta) {
        memset(dist, 0x3f, sizeof(dist)), memset(vis, 0, sizeof(vis));
        dist[sta] = 0, q.push(std::make_pair(0, sta));
        while(!q.empty()) {
            int u = q.top().second; q.pop();
            if(vis[u]) continue;
            vis[u] = 1;
            for(int p = head[u]; p; p = nxt[p]) {
                int v = ver[p];
                if(dist[v] > dist[u]+edge[p]) {
                    dist[v] = dist[u]+edge[p];
                    q.push(std::make_pair(-dist[v], v));
                }
            }
        }
    }
}

namespace gra { // 原图（一个森林）
    int head[maxn], ver[maxn<<1], edge[maxn<<1], nxt[maxn<<1], tot;
    
    inline void add(int u, int v, int w) {
        ver[++tot] = v, edge[tot] = w, nxt[tot] = head[u], head[u] = tot;
        ver[++tot] = u, edge[tot] = w, nxt[tot] = head[v], head[v] = tot;
    }
    
    int fa[maxn], dep[maxn], sz[maxn], wson[maxn];
    int dfn[maxn], lfs[maxn], top[maxn], cnt;
    
    void dfs1(int u, int lst) {
        fa[u] = lst, dep[u] = dep[lst]+1, sz[u] = 1, wson[u] = 0;
        for(int p = head[u]; p; p = nxt[p]) {
            int v = ver[p];
            if(v != lst) {
                dfs1(v, u);
                sz[u] += sz[v];
                if(sz[wson[u]] < sz[v])
                    wson[u] = v;
            }
        }
    }
    
    void dfs2(int u, int lst) {
        dfn[u] = ++cnt; lfs[cnt] = u; top[u] = lst;
        if(!wson[u]) return;
        dfs2(wson[u], lst);
        for(int p = head[u]; p; p = nxt[p]) {
            int v = ver[p];
            if(v != fa[u] && v != wson[u])
                dfs2(v, v);
        }
    }
    
    void pathin(int x, int y, int pos, int w) {
        while(top[x] != top[y]) {
            if(dep[top[x]] < dep[top[y]]) std::swap(x, y);
            seg::modifyin(1, 1, n, dfn[top[x]], dfn[x], pos, w);
            x = fa[top[x]];
        }
        if(dep[x] > dep[y]) std::swap(x, y);
        seg::modifyin(1, 1, n, dfn[x], dfn[y], pos, w);
    }
    
    void pathout(int x, int y, int pos, int w) {
        while(top[x] != top[y]) {
            if(dep[top[x]] < dep[top[y]]) std::swap(x, y);
            seg::modifyout(1, 1, n, dfn[top[x]], dfn[x], pos, w);
            x = fa[top[x]];
        }
        if(dep[x] > dep[y]) std::swap(x, y);
        seg::modifyout(1, 1, n, dfn[x], dfn[y], pos, w);
    }
}

int main() {
    n = read(), m = read(), s = read();
    for(int i = 1; i <= m; ++i) {
        e[i].op = read();
        if(e[i].op == 1) e[i].u1 = read(), e[i].v1 = read(), e[i].u2 = read(), e[i].v2 = read();
        else e[i].u1 = read(), e[i].v1 = read();
        e[i].w = read();
    }
    ufs::init();
    for(int i = 1; i <= m; ++i)
        if(e[i].op == 2)
            if(ufs::merge(e[i].u1, e[i].v1))
                gra::add(e[i].u1, e[i].v1, e[i].w);
    for(int i = 1; i <= n; ++i)
        if(!gra::dfn[i])
            gra::dfs1(i, 0), gra::dfs2(i, i);
    seg::build(1, 1, n);
    ufs::init();
    for(int i = 1; i <= m; ++i) {
        if(e[i].op == 1) {
            int x = ufs::getf(e[i].u1), y = ufs::getf(e[i].v1);
            if(x != y) continue;
            x = ufs::getf(e[i].u2), y = ufs::getf(e[i].v2);
            if(x != y) continue;
            gra::pathout(e[i].u1, e[i].v1, (n<<3)+i, e[i].w);
            gra::pathin(e[i].u2, e[i].v2, (n<<3)+i, 0);
        }
        else if(ufs::merge(e[i].u1, e[i].v1)) {
            seg::connect(gra::dfn[e[i].u1], gra::dfn[e[i].v1], e[i].w);
        }
    }
    seg::dij(seg::epos[gra::dfn[s]]);
    for(int i = 1; i <= n; ++i)
        printf("%d ", seg::dist[seg::epos[gra::dfn[i]]] < Inf ? seg::dist[seg::epos[gra::dfn[i]]] : -1);
    return 0;
}
```

然后我们还可以倍增优化建图，思路是对于倍增的每个点都开一个新点。

设$f[i][j]$表示$i$的$2^j$级祖先，$g[i][j]$表示新开的一个点，这个点表示的是从$i$到$i$的$2^j-1$级祖先的一条链。和线段树优化建图一样，我们还是需要一个入点和一个出点。

建图方式是：对于入点，由$g[i][j]$向$g[i][j-1], g[f[i][j-1]][j-1]$分别连边。对于出点则边反向。然后同层的出点连向入点。

然后每次加边，我们只需要在倍增$lca$的同时，将你需要连边的代表点向对应出点（或从对应出点向代表点）连边即可。注意当$x$为$y$的祖先时，要与$g[x][0]$连边，否则与$g[x][1], g[y][1]$连边。

这样复杂度是$O(m\log^2n)$的，吸口氧就能过了。

给一下代码：（~~因为这个是直接从上面树剖的代码改的，所以保留了原来的变量名，请不要在意这些细节~~qwq）
```cpp
#include <cstdio>
#include <cctype>
#include <cstring>
#include <algorithm>
#include <queue>
#define maxn 50005
#define maxm 1000005
#define Inf 0x3f3f3f3f
inline int read() {
    int d=0;char ch=getchar();while(!isdigit(ch))ch=getchar();
    while(isdigit(ch)){d=d*10+ch-48,ch=getchar();}return d;
}

int n, m, s;
struct query {
    int op;
    int u1, v1, u2, v2;
    int w;
}e[maxm];

namespace ufs {
    int f[maxn];
    inline void init() {for(int i = 1; i <= n; ++i) f[i] = i;}
    int getf(int x) {return x == f[x] ? x : f[x] = getf(f[x]);}
    bool merge(int x, int y) {
        x = getf(x), y = getf(y); if(x == y) return false;
        f[x] = y; return true;
    }
}

namespace seg {
#define segin(x, k) (x+(n*(k)))
#define segout(x, k) ((x+(n*(k)))+(n*17))

    int head[maxn*54], ver[maxm*37], edge[maxm*37], nxt[maxm*37], tot;
    
    inline void add(int u, int v, int w) {
        ver[++tot] = v, edge[tot] = w, nxt[tot] = head[u], head[u] = tot;
    }
    
    void connect(int x, int y, int w) {
        add(segout(x, 0), segin(y, 0), w);
        add(segout(y, 0), segin(x, 0), w);
    }
    
    int dist[maxn*54], vis[maxn*54];
    std::priority_queue< std::pair<int, int> > q;
    
    void dij(int sta) {
        memset(dist, 0x3f, sizeof(dist)), memset(vis, 0, sizeof(vis));
        dist[sta] = 0, q.push(std::make_pair(0, sta));
        while(!q.empty()) {
            int u = q.top().second; q.pop();
            if(vis[u]) continue;
            vis[u] = 1;
            for(int p = head[u]; p; p = nxt[p]) {
                int v = ver[p];
                if(dist[v] > dist[u]+edge[p]) {
                    dist[v] = dist[u]+edge[p];
                    q.push(std::make_pair(-dist[v], v));
                }
            }
        }
    }
}

namespace gra {
    int head[maxn], ver[maxn<<1], edge[maxn<<1], nxt[maxn<<1], tot;
    
    inline void add(int u, int v, int w) {
        ver[++tot] = v, edge[tot] = w, nxt[tot] = head[u], head[u] = tot;
        ver[++tot] = u, edge[tot] = w, nxt[tot] = head[v], head[v] = tot;
    }
    
    int dep[maxn];
    int g[maxn][17];
    
    void dfs(int u, int lst) {
        dep[u] = dep[lst]+1;
        g[u][0] = lst;
        seg::add(segin(u, 0), segout(u, 0), 0);
        for(int i = 1; i <= 16; ++i) {
            g[u][i] = g[g[u][i-1]][i-1];
            seg::add(segin(u, i), segout(u, i), 0);
            seg::add(segin(u, i), segin(u, i-1), 0);
            seg::add(segout(u, i-1), segout(u, i), 0);
            seg::add(segin(u, i), segin(g[u][i-1], i-1), 0);
            seg::add(segout(g[u][i-1], i-1), segout(u, i), 0);
        }
        for(int p = head[u]; p; p = nxt[p]) {
            int v = ver[p];
            if(v != lst) dfs(v, u);
        }
    }
    
    void pathin(int x, int y, int pos, int w) {
        if(dep[x] < dep[y]) std::swap(x, y);
        for(int i = 16; i >= 0; --i)
            if(dep[g[x][i]] >= dep[y]) {
                seg::add(pos, segin(x, i), w);
                x = g[x][i];
            }
        if(x == y) {
            seg::add(pos, segin(x, 0), w);
            seg::add(pos, segin(y, 0), w);
            return;
        }
        for(int i = 16; i >= 0; --i)
            if(g[x][i] != g[y][i]) {
                seg::add(pos, segin(x, i), w);
                seg::add(pos, segin(y, i), w);
                x = g[x][i], y = g[y][i];
            }
        seg::add(pos, segin(x, 1), w);
        seg::add(pos, segin(y, 1), w);
    }
    
    void pathout(int x, int y, int pos, int w) {
        if(dep[x] < dep[y]) std::swap(x, y);
        for(int i = 16; i >= 0; --i)
            if(dep[g[x][i]] >= dep[y]) {
                seg::add(segout(x, i), pos, w);
                x = g[x][i];
            }
        if(x == y) {
            seg::add(segout(x, 0), pos, w);
            seg::add(segout(y, 0), pos, w);
            return;
        }
        for(int i = 16; i >= 0; --i)
            if(g[x][i] != g[y][i]) {
                seg::add(segout(x, i), pos, w);
                seg::add(segout(y, i), pos, w);
                x = g[x][i], y = g[y][i];
            }
        seg::add(segout(x, 1), pos, w);
        seg::add(segout(y, 1), pos, w);
    }
}

int main() {
    n = read(), m = read(), s = read();
    for(int i = 1; i <= m; ++i) {
        e[i].op = read();
        if(e[i].op == 1) e[i].u1 = read(), e[i].v1 = read(), e[i].u2 = read(), e[i].v2 = read();
        else e[i].u1 = read(), e[i].v1 = read();
        e[i].w = read();
    }
    ufs::init();
    for(int i = 1; i <= m; ++i)
        if(e[i].op == 2)
            if(ufs::merge(e[i].u1, e[i].v1))
                gra::add(e[i].u1, e[i].v1, e[i].w);
    for(int i = 1; i <= n; ++i)
        if(!gra::dep[i])
            gra::dfs(i, 0);
    ufs::init();
    for(int i = 1; i <= m; ++i) {
        if(e[i].op == 1) {
            int x = ufs::getf(e[i].u1), y = ufs::getf(e[i].v1);
            if(x != y) continue;
            x = ufs::getf(e[i].u2), y = ufs::getf(e[i].v2);
            if(x != y) continue;
            gra::pathout(e[i].u1, e[i].v1, n*34+i, e[i].w);
            gra::pathin(e[i].u2, e[i].v2, n*34+i, 0);
        }
        else if(ufs::merge(e[i].u1, e[i].v1))
            seg::connect(e[i].u1, e[i].v1, e[i].w);
    }
    seg::dij(s);
    for(int i = 1; i <= n; ++i)
        printf("%d ", seg::dist[i] < Inf ? seg::dist[i] : -1);
    return 0;
}
```
~~比上面那个好写多了~~

然而我们还可以继续优化，即ST表优化建图。

实际上我们可以利用上面的倍增数组。先求出$x, y$的$lca$，然后对于两条链分别考虑。对于每条链，设它的长度为$2^k+m$，则我们可以先连前$2^k$个点在倍增数组上的点，再连后$2^k$个点，这样时间复杂度为$O(m\log n)$。

下面给出部分代码，具体实现细节与上面倍增相同。
```cpp
void pathin(int x, int y, int pos, int w) { // y 为我们求出的 lca
    int k = log2(dep[x]-dep[y]+1);
    seg::add(pos, segin(x, k), w);
    for(int i = 16; i >= 0; --i)
        if(dep[g[x][i]] >= dep[y]+(1<<k)-1)
            x = g[x][i];
    seg::add(pos, segin(x, k), w);
}
```

---

## 作者：panyf (赞：8)

这里是 $O(m\log n)$ 的做法。

首先去掉不合法的操作，用并查集维护连通性实现。

为了便于实现，可以将无向边视为两个传送门 $(u,u,v,v,w)$ 和 $(v,v,u,u,w)$。

然后有很多优化建图的做法，复杂度都在 $O(n\log^2n)$ 以上。

考虑 [[NOI2019] 弹跳](https://www.luogu.com.cn/problem/P5471) 的优化方法。可以参考 [常见优化建图技巧](https://www.luogu.com.cn/blog/221955/chang-jian-you-hua-jian-tu-ji-qiao)。

在 dij 的过程中，堆中不存点，而是存边，这样每次访问到的点最短路单调递增。

每个点第一次被访问到得到的就是最短路，然后可以直接将这个点删掉。每条边也只需要扩展一次，之后可以删掉。

最短路部分复杂度即为 $O(m\log n)$。

接下来考虑如何找到每个传送门需要扩展的点。

对于每个传送门，求出 $u_2$ 和 $v_2$ 的 lca，记为 $l$。于是可以将 $(u2,v2)$ 拆成两条连向祖先的路径 $(u2,l)$ 和 $(v2,l)$。

删点的过程用树上并查集（即只能将儿子向父亲合并的并查集）实现，每访问完一个点就将它向父亲合并。这样在路径上跳 $fa$ 每次访问到的都是需要扩展的点。

最后考虑如何求出起点经过点 $x$ 的传送门。

设 $l_x$ 为 $x$ 子树 dfs 序最小值（即 $x$ 的 dfs 序），$r_x$ 为最大值。起点为 $(u1,v1)$ 的传送门经过 $x$，当且仅当 $lca(u1,v1)=x$，或者 $u1,v1$ 中有一个 dfs 序属于 $[l_x,r_x]$ 而另一个不属于。

第一种情况，对每个 $x$ 开一个 vector 存储 $lca(u1,v1)=x$ 的传送门。

第二种情况，不妨设 $l_{u1}<l_{v1}$，只需要不断查询 $u1\in[l_x,r_x]$ 且 $v1$ 最大的传送门，然后删掉，直到 $v1\leq r_x$。同理，还需要不断查询 $v1\in[l_x,r_x]$ 且 $u1$ 最小的传送门。

需要支持单点删，区间最值，线段树即可。

时间复杂度 $O(m\log n)$，空间复杂度线性。

由于此题数据范围 $n$ 较小，实际效率并不如 ST 表优化建图。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e4+3;
struct E{int a,b,c,d,w,la,lb;bool f;}e[N*22];
basic_string<int>g[N],a[N*4][2],p[N];
using ar=int[N];
ar f,fa,sz,sn,h,l,r,tp,d;
int id,u,v,w,n,z[N*22];
struct cmp{bool operator()(int x,int y){return e[x].w>e[y].w;}};
priority_queue<int,vector<int>,cmp>q;
bool(*c[2])(int,int)={[](int x,int y){return e[x].lb<e[y].lb;},[](int x,int y){return e[x].la>e[y].la;}},b;
int gf(int x){return f[x]==x?x:f[x]=gf(f[x]);}
void dfs1(int x,int y){
	h[x]=h[y]+1,fa[x]=y,sz[x]=1;
	for(int i:g[x])if(i!=y)if(dfs1(i,x),sz[x]+=sz[i],sz[i]>sz[sn[x]])sn[x]=i;
}
void dfs2(int x,int y){
	if(l[x]=++id,tp[x]=y,sn[x])dfs2(sn[x],y);
	for(int i:g[x])if(i!=fa[x]&&i!=sn[x])dfs2(i,i);
	r[x]=id;
}
int lca(int x,int y){
	for(;tp[x]!=tp[y];x=fa[tp[x]])if(h[tp[x]]<h[tp[y]])swap(x,y);
	return h[x]<h[y]?x:y;
}
void upd(int k,int l,int r){
	if(a[k][b]+=w,l==r)return;
	int m=l+r>>1;
	u>m?upd(k*2+1,m+1,r):upd(k*2,l,m);
}
void qry(int k,int l,int r){
	if(u<=l&&r<=v){
		while(e[a[k][b].back()].f)a[k][b].pop_back();
		if(c[b](w,a[k][b].back()))w=a[k][b].back();
		return;
	}
	int m=l+r>>1;
	if(u<=m)qry(k*2,l,m);
	if(m<v)qry(k*2+1,m+1,r);
}
void work(int x){
	for(int i:p[x])if(!e[i].f)e[i].f=1,e[i].w+=d[x],q.push(i);
	for(b=0,u=l[x],v=r[x];w=0,qry(1,1,n),e[w].lb>v;q.push(w))e[w].f=1,e[w].w+=d[x];
	for(b=1,f[x]=gf(fa[x]);w=0,qry(1,1,n),e[w].la<u;q.push(w))e[w].f=1,e[w].w+=d[x];
}
int main(){
	int m,s,t=0,i,j,k,o,x;
	scanf("%d%d%d",&n,&m,&s),e[0].la=N;
	for(i=1;i<=n;++i)f[i]=i;
	while(m--){
		scanf("%d%d%d%d",&i,&j,&k,&x);
		if(i==1){
			scanf("%d%d",&o,&i);
			if(gf(j)==gf(k)&&gf(x)==gf(o))e[++t]={j,k,x,o,i};
		}else if(gf(j)!=gf(k))f[f[j]]=f[k],e[++t]={j,j,k,k,x},e[++t]={k,k,j,j,x},g[j]+=k,g[k]+=j;
	}
	for(i=1;i<=n;++i)if(f[i]=i,!l[i])dfs1(i,0),dfs2(i,i);
	for(i=1;i<=t;++i){
		if(p[lca(e[i].a,e[i].b)]+=i,l[e[i].a]>l[e[i].b])swap(e[i].a,e[i].b);
		e[i].la=l[e[i].a],e[i].lb=l[e[i].b],z[i]=i;
	}
	for(i=1;i<N*4;++i)a[i][0]+=0,a[i][1]+=0;
	for(i=1,sort(z+1,z+t+1,c[0]);i<=t;++i)u=e[w=z[i]].la,upd(1,1,n);
	for(i=1;i<=t;++i)z[i]=i;
	for(i=b=1,sort(z+1,z+t+1,c[1]);i<=t;++i)u=e[w=z[i]].lb,upd(1,1,n);
	memset(d,-1,N*4),d[s]=0,work(s);
	while(q.size()){
		i=q.top(),q.pop(),j=h[lca(e[i].c,e[i].d)];
		for(k=gf(e[i].c);h[k]>=j;k=f[k])d[k]=e[i].w,work(k);
		for(k=gf(e[i].d);h[k]>=j;k=f[k])d[k]=e[i].w,work(k);
	}
	for(i=1;i<=n;++i)printf("%d ",d[i]);
	return 0;
}
```


---

## 作者：TKXZ133 (赞：6)

[P5344 逛森林](https://www.luogu.com.cn/problem/P5344)

### 题目大意

~~原题的题目大意已经很明确了要这个干嘛~~

给定一些孤立点，将要进行两种操作：

- 若两点之间不可以通过 $1$ 类边连通，则在两点之间连双向 $1$ 类边

- 若 $u_1,v_1$ 和 $u_2,v_2$ 均可以通过 $1$ 类边连通，则从 $u_1\to v_1$ 的唯一路径上的所有点均向 $u_2\to v_2$ 的唯一路径上的所有点连单向非 $1$ 类边。

在完成所有操作后求出从给定的 $s$ 出发的单源最短路。

### 前置知识

~~如果你不熟悉以下内容，那还是换一篇题解看吧。~~

- 树链剖分

- 线段树优化建图

### 思路分析

首先显然有一个 $O(n\log^3n)$ 的大力树剖做法，但这个做法过于暴力，时间和空间都不允许，无法通过本题。

考虑优化这个做法，我们发现，对于每一个重链都在线段树上进行一次连边实在太过于暴力，时间复杂度高就来源于这里。

我们知道，一条重链是一颗树上独立的部分，我们可以为每一条重链预处理出一条路径，使得从这个点可以直接到达重链上的所有点。这样在树剖的时候对于每一个重链只需要连一条边就可以了。

那剩下的部分怎么办呢？不用怕，直接怼一个线段树优化建图上去就可以了，反正只有一个区间，对时间复杂度没有影响。

这样我们就得到了一个时间复杂度为 $O(m\log^2n)$，空间复杂度为 $O(n\log n)$ 的不那么暴力的做法，足以通过本题。

### 详细解释

上面的部分解释了一下大致思路，但还有亿些细节。

- **如何预处理出重链路径？**

对于每一个点，建立两个新的点，入点和出点，然后由这个点的入点向该点连边，该点向出点连边。

同时，自己的出点向自己的重儿子的出点连边，自己的重儿子的入点向自己的入点连边。这样就形成了两条路径，一条往下的出路径和一条往上的入路径。

![](https://i.328888.xyz/2023/04/23/i5Yof8.png)

- **如何使用线段树优化建图？**

跟正常的线段树优化建图差不多，只需要在树剖的配合下上树就行了。

![](https://i.328888.xyz/2023/04/23/i5qq93.png)

```
struct STn{int l,r;};//没什么用的结构体
struct ST{
    STn a[P<<2];//开四倍
    void build(int p,int l,int r){
        a[p].l=l;a[p].r=r;
        if(a[p].l==a[p].r){
            idt[p][0]=idt[p][1]=rnk[l];//rnk[l]才是对应的点，idt[p][0]是入出的节点编号，idt[p][1]是出树的
            return ;
        }
        int mid=(a[p].l+a[p].r)>>1;
        build(p<<1,l,mid);build(p<<1|1,mid+1,r);
        idt[p][0]=build_new_point();//动态开点，节约空间
        idt[p][1]=build_new_point();
        add(idt[p][0],idt[p<<1][0],0,0);//入树和出树连边
        add(idt[p][0],idt[p<<1|1][0],0,0);
        add(idt[p<<1][1],idt[p][1],0,0);
        add(idt[p<<1|1][1],idt[p][1],0,0);
    }
    void connect(int p,int point,int l,int r,int f){
        if(l<=a[p].l&&a[p].r<=r){
            if(f) add(point,idt[p][0],0,0);//f=1 表示点向区间连边
            else add(idt[p][1],point,0,0);//f=0 表示区间向点连边
            return ;
        }
        int mid=(a[p].l+a[p].r)>>1;
        if(l<=mid) connect(p<<1,point,l,r,f);
        if(r>mid) connect(p<<1|1,point,l,r,f);
    }
}tree;
```

### 其他

然后就应该没什么大问题了，但是细节还是很多的。

- 使用并查集维护 $1$ 类边的连通。

- 入点和出点，入树和出树不要搞混。

- dfs 时只走树边。

- 这题卡空间，建议使用邻接表存图。

### 代码

```
#include <iostream>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <queue>
#include <vector>

using namespace std;
const int N=2500000,P=50100;//n log n 空间
#define inf 0x3f3f3f3f

struct Edge{int v,w;};
vector <Edge> E[N];//邻接表存所有边
int to[P<<1],head[P],nxt[P<<1];//链星存树边
int dfn[P],rnk[P],dep[P],siz[P],son[P],fa[P],top[P];
int idx=1,n,m,in1,in2,in3,in4,in5,op,s;
int query_num,dfs_cnt,id;
int dis[N],vis[N],idt[P<<2][2];

int fat[P];
int find(int x){return fat[x]==x?x:fat[x]=find(fat[x]);}//并查集

int build_new_point(){//动态开点
    id++;return id;
}

void add(int u,int v,int c,int f){
    if(f==1){idx++;to[idx]=v;nxt[idx]=head[u];head[u]=idx;}//f=1 表示这条边是树边
    E[u].push_back(Edge{v,c});
}

struct Query{
    int u1,v1,u2,v2,w;
}query[N];

struct Node{
    int x,dis;
}now;

bool operator < (Node a,Node b){
    return a.dis>b.dis;//大根堆
}

priority_queue <Node> q;

void Dijskra(){//最短路
    memset(dis,0x3f,sizeof dis);
    q.push(Node{s,0});dis[s]=0;
    while(!q.empty()){
        now=q.top();q.pop();
        if(vis[now.x]) continue;
        vis[now.x]=1;
        for(auto it:E[now.x]){
            int v=it.v;
            if(dis[v]<dis[now.x]+it.w) continue;
            dis[v]=dis[now.x]+it.w;
            q.push(Node{v,dis[v]});
        }
    }
}

void dfs_1(int s,int gr){//树剖预处理
    fa[s]=gr;dep[s]=dep[gr]+1;
    siz[s]=1;son[s]=-1;
    for(int i=head[s];i;i=nxt[i]){
        int v=to[i];
        if(v==gr) continue;
        dfs_1(v,s);
        siz[s]+=siz[v];
        if(son[s]==-1||siz[son[s]]<siz[v]) son[s]=v;
    }
}

void dfs_2(int s,int tp){
    top[s]=tp;
    dfn[s]=++dfs_cnt;
    rnk[dfs_cnt]=s;
    if(son[s]==-1) return ;
    add(son[s]+n,s+n,0,0);//入点往上
    add(s+2*n,son[s]+2*n,0,0);//出点往下
    dfs_2(son[s],tp);
    for(int i=head[s];i;i=nxt[i]){
        int v=to[i];
        if(v==son[s]||v==fa[s]) continue;
        dfs_2(v,v);
    }
}

struct STn{int l,r;};//没什么用的结构体
struct ST{
    STn a[P<<2];//开四倍
    void build(int p,int l,int r){
        a[p].l=l;a[p].r=r;
        if(a[p].l==a[p].r){
            idt[p][0]=idt[p][1]=rnk[l];//rnk[l]才是对应的点，idt[p][0]是入出的节点编号，idt[p][1]是出树的
            return ;
        }
        int mid=(a[p].l+a[p].r)>>1;
        build(p<<1,l,mid);build(p<<1|1,mid+1,r);
        idt[p][0]=build_new_point();//动态开点，节约空间
        idt[p][1]=build_new_point();
        add(idt[p][0],idt[p<<1][0],0,0);//入树和出树连边
        add(idt[p][0],idt[p<<1|1][0],0,0);
        add(idt[p<<1][1],idt[p][1],0,0);
        add(idt[p<<1|1][1],idt[p][1],0,0);
    }
    void connect(int p,int point,int l,int r,int f){
        if(l<=a[p].l&&a[p].r<=r){
            if(f) add(point,idt[p][0],0,0);//f=1 表示点向区间连边
            else add(idt[p][1],point,0,0);//f=0 表示区间向点连边
            return ;
        }
        int mid=(a[p].l+a[p].r)>>1;
        if(l<=mid) connect(p<<1,point,l,r,f);
        if(r>mid) connect(p<<1|1,point,l,r,f);
    }
}tree;

void add_edge_one_to_two(int point,int x,int y,int f){
    while(top[x]!=top[y]){
        if(dep[top[x]]<dep[top[y]]) swap(x,y);
        if(f) add(point,x+n,0,0);
        else add(x+2*n,point,0,0);//注意是 x 不是 top[x]
        x=fa[top[x]];
    }
    if(dep[x]<dep[y]) swap(x,y);
    tree.connect(1,point,dfn[y],dfn[x],f);//剩下的部分用线段树
}

void add_edge_two_to_two(int query_id){
    int u1=query[query_id].u1,v1=query[query_id].v1;
    int u2=query[query_id].u2,v2=query[query_id].v2;
    int w=query[query_id].w;//把询问提取出来
    int uu=build_new_point(),vv=build_new_point();
    add(uu,vv,w,0);//建两个新的点并在这两点之间连有权值的边
    add_edge_one_to_two(vv,u2,v2,1);//出点向路径连边
    add_edge_one_to_two(uu,u1,v1,0);//路径向入点连边
}

int main(){
    scanf("%d%d%d",&n,&m,&s);
    id=3*n;//动态开点的编号从 3n 开始，n+1 到 2n 是入点，2n+1 到 3n 是出点
    for(int i=1;i<=n;i++) fat[i]=i;//不要忘了初始化
    for(int i=1;i<=m;i++){
        scanf("%d",&op);
        if(op==1){
            scanf("%d%d%d%d%d",&in1,&in2,&in3,&in4,&in5);
            if(find(in1)!=find(in2)||find(in3)!=find(in4)) continue;
            query[++query_num]=Query{in1,in2,in3,in4,in5};//保存一下询问
        }
        if(op==2){
            scanf("%d%d%d",&in1,&in2,&in3);
            if(find(in1)==find(in2)) continue;
            add(in1,in2,in3,1);add(in2,in1,in3,1);
            fat[find(in1)]=find(in2);
        }
    }
    for(int i=1;i<=n;i++)
        add(i+n,i,0,0),add(i,i+2*n,0,0);//先把出入点之间的边连上
    for(int i=1;i<=n;i++)
        if(!dfn[i]){
            dfs_1(i,0);
            dfs_2(i,i);
        }
    tree.build(1,1,n);//不要忘了建树
    for(int i=1;i<=query_num;i++)//连一下询问的边
        add_edge_two_to_two(i);
    Dijskra();
    for(int i=1;i<=n;i++) 
        if(dis[i]==inf) cout<<"-1 ";
        else cout<<dis[i]<<' ';
    cout<<'\n';
    return 0;
}
```

---

## 作者：mrsrz (赞：4)

不难想到，用并查集维护连通性，然后把所有有用的1操作存下来。在最终的森林上加边。

然后树剖+线段树优化连边跑最短路。~~SPFA不会用的~~

时间复杂度$O(m\log^3n)$，边数开不下。~~窝太菜就只能想到这儿了~~

神鱼的题解里说用倍增优化连边，就对倍增数组上的每个点开一个节点，覆盖这一段区间。然后每次向找LCA一样往上跳，边跳边连边。一开始是这么理解的。

然而这样的时间复杂度为$O(m\log^2 n)$，空间勉强能开下，但还是会TLE。

~~冷静地吃了顿饭之后突然反应了过来~~

实际上，与其说是倍增，不如说更像ST表的思想（ST表就是链上的倍增数组？）。

考虑到最短路中，边权相等的重边是没有影响的。那么对于一段链连出/入长度相等的有向边，我们可以令前$2^k$个点先连，后$2^k$个点再连。这样中间就有可能重复，但是是不会对结果产生影响的。

而对一段长度为$2^k$的点连出/入边，在倍增数组上刚好对应着一个节点。那么对于一个1操作，我们就可以通过连很少的边来完成。

这样边就只有$O(m)$条了。

于是时间复杂度$O(m\log n)$。

## Code：
```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<cstdlib>
#include<ext/pb_ds/priority_queue.hpp>
using namespace __gnu_pbds;
typedef unsigned long long LL;
typedef priority_queue<LL,std::greater<LL> >heap;
const int N=5e5+4,M=3e6;
char buf[(int)1e8],*ss=buf;
inline int init(){buf[fread(buf,1,(int)1e8-1,stdin)]='\n';fclose(stdin);return EXIT_SUCCESS;}
const int __START__=init();
inline int readint(){
    int d=0;
    while(!isdigit(*ss))++ss;
    while(isdigit(*ss))d=d*10+(*ss++^'0');
    return d;
}
int n,m,S,fa[N],head[M],cnt,id1[16][N],id2[16][N],dep[N],F[16][N];
int to[12345678],nxt[12345678],dd[12345678];
struct extra{
	int u1,v1,u2,v2,w;
}ext[1000005];
int cne,cnn,dis[M];
inline void addedge(int u,int v,int w){if(u&&v)to[++cnt]=v,nxt[cnt]=head[u],dd[cnt]=w,head[u]=cnt;}
inline int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
void dfs(int now,int pre){for(int i=head[now];i;i=nxt[i])if(to[i]!=pre)F[0][to[i]]=now,dep[to[i]]=dep[now]+1,dfs(to[i],now);}
heap q;
void spfa(){
	memset(dis,0x3f,sizeof dis);
	dis[S]=0;
	q.push(S);
	while(!q.empty()){
		const LL x=q.top();q.pop();
		const int d=x>>32,u=(int)x;
		if(d!=dis[u])continue;
		for(int i=head[u];i;i=nxt[i])
		if(dis[to[i]]>d+dd[i])dis[to[i]]=d+dd[i],q.push((LL)dis[to[i]]<<32|to[i]);
	}
}
inline int LCA(int u,int v){
	if(dep[u]<dep[v])u^=v^=u^=v;
	for(int i=15;~i;--i)if(dep[F[i][u]]>=dep[v])u=F[i][u];
	if(u==v)return u;
	for(int i=15;~i;--i)if(F[i][u]!=F[i][v])u=F[i][u],v=F[i][v];
	return F[0][u];
}
inline void link1(int u,int top,const int&w){
	if(u==top)return addedge(u,cnn,w);
	int i=0;
	while(i<15&&F[i+1][u]&&dep[F[i+1][u]]>=dep[top]-1)++i;
	addedge(id2[i][u],cnn,w);
	if(F[i][u]!=F[0][top]){
		int d=dep[F[i][u]]-dep[top]+1;
		for(int j=15;~j;--j)
		if(d>>j&1)u=F[j][u];
		addedge(id2[i][u],cnn,w);
	}
}
inline void link2(int u,int top){
	if(u==top)return addedge(cnn,u,0);
	int i=0;
	while(i<15&&F[i+1][u]&&dep[F[i+1][u]]>=dep[top]-1)++i;
	addedge(cnn,id1[i][u],0);
	if(F[i][u]!=F[0][top]){
		int d=dep[F[i][u]]-dep[top]+1;
		for(int j=15;~j;--j)
		if(d>>j&1)u=F[j][u];
		addedge(cnn,id1[i][u],0);
	}
}
int main(){
	n=readint(),m=readint(),S=readint();
	cnn=n;
	for(int i=1;i<=n;++i)fa[i]=i;
	while(m--)
	if(readint()==1){
		int u1=readint(),v1=readint(),u2=readint(),v2=readint(),w=readint();
		if(find(u1)==find(v1)&&find(u2)==find(v2))ext[++cne]=(extra){u1,v1,u2,v2,w};
	}else{
		int u=readint(),v=readint(),w=readint();
		int x=find(u),y=find(v);
		if(x!=y)addedge(u,v,w),addedge(v,u,w),fa[y]=x;
	}
	for(int i=1;i<=n;++i)
	if(find(i)==i)dfs(i,0);
	for(int i=1;i<=n;++i)id1[0][i]=id2[0][i]=i;
	for(int i=1;i<16;++i)
	for(int j=1;j<=n;++j){
		F[i][j]=F[i-1][F[i-1][j]];
		if(id1[i-1][j]||id1[i-1][F[i-1][j]])
		id1[i][j]=++cnn,id2[i][j]=++cnn;else continue;
		addedge(id1[i][j],id1[i-1][j],0),addedge(id2[i-1][j],id2[i][j],0);
		addedge(id1[i][j],id1[i-1][F[i-1][j]],0),addedge(id2[i-1][F[i-1][j]],id2[i][j],0);
	}
	for(int i=1;i<=cne;++i){
		const int w=ext[i].w;
		++cnn;
		int u=ext[i].u1,v=ext[i].v1,lca=LCA(u,v);
		link1(u,lca,w),link1(v,lca,w);
		u=ext[i].u2,v=ext[i].v2,lca=LCA(u,v);
		link2(u,lca),link2(v,lca);
	}
	spfa();
	for(int i=1;i<=n;++i)
	if(dis[i]==0x3f3f3f3f)printf("-1 ");else printf("%d ",dis[i]);
	return 0;
}
```

---

## 作者：gdf_yhm (赞：3)

[P5344](https://www.luogu.com.cn/problem/P5344)

### 思路

除去建图外，是最短路。把图建出来跑 dij 即可。

对于建图，可以想到对每个操作 $1$ 建一个虚点，从 $u1$ 到 $v1$ 向虚点连代价为 $w$ 的边，从虚点向 $u2$ 到 $v2$ 连代价为 $0$ 的边。此时图中有 $n\times m$ 条边，无法接受，考虑优化建图。

按照线段树优化建图的思路，可以想到先树剖建线段树，$in$ 表示从上往下，$out$ 表示从下往上。把每条边变为多条链在线段树上分别建边。每条边有 $\log n$ 条链，每条链建 $\log n$ 条边，最短路 $O(m\log n)$，总复杂度 $O(m\log^3 n)$。

可以发现，通过树剖把树结构变为数组再优化并非最好，可以树上倍增优化。

对于每个点 $u$ 建 $\log n$ 个虚点，记为 $in_{u,i}$ 和 $out_{u,i}$，表示从 $u$ 到往上 $2^i$ 级祖先的链， $in$ 和 $out$ 同理线段树优化建图，表示从上往下或从下往上。

和 st 表的查询一样，$u$ 到 $u$ 的祖先 $v$ 的路径可以表示为 $u$ 的第 $k$ 个虚点和使 $2^k$ 级祖先为 $v$ 的某个 $u$ 的祖先的第 $k$ 个虚点。把 $u1$ 到 $v1$ 的路径向虚点连边，等同于把 $u1$ 到 lca 和 $v1$ 到 lca 分别向虚点连边。

每个点 $u$ 有 $\log n$ 个虚点，倍增时每个虚点向上一级连 $2$ 条边。每个操作有 $1$ 个虚点，分为 $4$ 部分，每部分向虚点连 $2$ 条边。这样一共有 $n\log n+m$ 个点和 $n\log n+m$ 条边。总复杂度 $O(m\log n)$。

要注意不要开小数组。

### code

```cpp
#include<iostream>
#include<queue>
#include<cstring>
#define int long long
using namespace std;
const int maxn=50010;
const int maxm=1000010;
const int inf=1e9;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch-48);ch=getchar();}
	return x*f;
}

int n,m,s,num;
int f[maxn];
int fd(int x){
	if(x==f[x])return x;
	return f[x]=fd(f[x]);
}
struct ask{
	int u,v,uu,vv,w;
}a[maxm];
int cnt;
int head[maxm*3],tot;
struct nd{
	int nxt,to,w;
}e[maxm*12];
void add(int u,int v,int w){
	e[++tot]={head[u],v,w};
	head[u]=tot;
}
int dep[maxn],to[maxn][20];
int in[maxn][20],out[maxn][20];
void dfs(int u,int fa){
	to[u][0]=fa;in[u][0]=out[u][0]=u;
	for(int i=1;(1<<i)<dep[u];i++){
		to[u][i]=to[to[u][i-1]][i-1];
	}
	for(int i=1;(1<<i)<=dep[u];i++){
		in[u][i]=++num;out[u][i]=++num;
		add(out[u][i-1],out[u][i],0);
		add(in[u][i],in[u][i-1],0);
		add(out[to[u][i-1]][i-1],out[u][i],0);
		add(in[u][i],in[to[u][i-1]][i-1],0);
	}
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v!=fa&&v<=n){
			dep[v]=dep[u]+1;
			dfs(v,u);
		}
	}
}
int lg[maxn];
int lca(int u,int v){
	if(u==v)return u;
	if(dep[u]<dep[v])swap(u,v);
	for(int i=lg[dep[u]];i>=0;i--)if(dep[to[u][i]]>=dep[v])u=to[u][i];
	if(u==v)return u;
	for(int i=lg[dep[u]];i>=0;i--)if(to[u][i]!=to[v][i])u=to[u][i],v=to[v][i];
	return to[u][0];
}
int kfa(int u,int k){
	int j=0;
	while(k){
		if(k&1)u=to[u][j];    
		k>>=1;
		++j;
	}
	return u;
}
void build(int u,int v,int w,int t){
	int k=lg[dep[u]-dep[v]+1];
	if(!t)add(out[u][k],num,w);
	else add(num,in[u][k],w);
	u=kfa(u,dep[u]-dep[v]+1-(1<<k));
	if(!t)add(out[u][k],num,w);
	else add(num,in[u][k],w);
}
int dis[maxm*3];
bool vis[maxm*3];
struct Dis{
	int dis,id;
	bool operator <(const Dis&tmp)const{return dis>tmp.dis;}
};
priority_queue<Dis> q;

int T;
signed main(){
	//	freopen(".in","r",stdin);
	//	freopen(".out","w",stdout);
	
	n=read();m=read();s=read();
	lg[1]=0;for(int i=2;i<=n;i++)lg[i]=lg[i>>1]+1;
	for(int i=1;i<=n;i++)f[i]=i;
	while(m--){
		int opt,u,v,w,uu,vv;opt=read();
		if(opt==1){
			u=read();v=read();uu=read();vv=read();w=read();
			if(fd(u)!=fd(v)||fd(uu)!=fd(vv))continue;
			a[++cnt]={u,v,uu,vv,w};
		}
		else{
			u=read();v=read();w=read();
			if(fd(u)==fd(v))continue;
			add(u,v,w);add(v,u,w);
			f[fd(u)]=fd(v);
		}
	}
	num=n;
	for(int i=1;i<=n;i++){
		if(!dep[i]){
			dep[i]=1;
			dfs(i,0);
		}
	}
	for(int i=1;i<=cnt;i++){
		num++;
		int tp1=lca(a[i].u,a[i].v),tp2=lca(a[i].uu,a[i].vv);
		build(a[i].u,tp1,0,0);build(a[i].v,tp1,0,0);
		build(a[i].uu,tp2,a[i].w,1);build(a[i].vv,tp2,a[i].w,1);
	}
	memset(dis,0x3f,sizeof(dis));
	dis[s]=0;q.push({0,s});
	while(!q.empty()){
		int u=q.top().id;q.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(int i=head[u];i;i=e[i].nxt){
			int v=e[i].to;
			if(dis[v]>dis[u]+e[i].w){
				dis[v]=dis[u]+e[i].w;
				q.push({dis[v],v});
			}
		}
	}
	for(int i=1;i<=n;i++){
		if(dis[i]>=0x3f3f3f3f)printf("-1 ");
		else printf("%d ",dis[i]);
	}
}
```


---

## 作者：qwaszx (赞：2)

考虑倍增优化连边.

优化连边通常就是考虑一种数据结构$S$，这个$S$一般具有分治结构，且$S$的每一个节点都是图上的一个节点.建立一个入$S$和一个出$S$，其中出$S$的边由分治结构的子区间指向父亲，入$S$的边从父亲指向儿子，边权都为$0$.每次从$[u_1,v_1]$向$[u_2,v_2]$连边时，先新建虚点$T$，在出$S$上提取出$[u_1,v_1]$向$T$连边权为$w$的边，在入$S$上提取出$[u_2,v_2]$并从$T$向其连边，容易看出这和直接进行暴力连边是等效的.

考虑先连$2$操作的边，同时存下来合法的$1$操作的边.$2$操作显然可以并查集维护.

$1$操作是两条树链之间的连边，使用的数据结构是倍增.显然重复连边对答案没有影响，所以可以像ST表那样把一段链拆成两个点，然后连边.每次连边涉及到的点数和边数都是$O(1)$的.这个过程中会涉及到一个求某个点的$k$级祖先的操作，使用长链剖分可以做到$O(1)$，但是我懒得写所以直接暴力倍增了.

这样连完边之后整张图的点数和边数都是$O(n\log n+m)$的，Dijkstra即可做到$O((n\log n+m)\log n)$.

理论上可以通过一些高妙的数据结构技巧把$n\log n$变成$n$，不过没啥必要了(

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
const int N=1e7;
struct DSU
{
	int fa[100000];
	int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
}bcj;
int dfn[100000],euler[100005][20],dep[100005],f[100005][20],id1[100005][20],id2[100005][20],dfs_cnt,lg[100005];
int nxt[N],fst[3000000],mm,n,m,S,dis[3000000],node_cnt;
struct Edge{int v,w;}e[N];
struct Q{int u1,v1,u2,v2,w;}qu[1500000];
void ade(int u,int v,int w){e[++mm]=(Edge){v,w},nxt[mm]=fst[u],fst[u]=mm;}
void dfs(int u,int fa)
{
	dfn[u]=++dfs_cnt,euler[dfs_cnt][0]=u;
	f[u][0]=fa,id1[u][0]=id2[u][0]=u,dep[u]=dep[fa]+1;
	for(int i=1;(1<<i)<dep[u];i++)f[u][i]=f[f[u][i-1]][i-1];
	for(int i=fst[u];i;i=nxt[i])
	{
		int v=e[i].v;if(v==fa)continue;
		dfs(v,u);euler[++dfs_cnt][0]=u;
	}
}
void link1(int u,int v,int t,int w)
{
	int len=dep[u]-dep[v]+1;
	int x1=id1[u][lg[len]],x2=u,res=len-(1<<lg[len]);
	for(;res;res-=res&-res)x2=f[x2][lg[res&-res]];
	x2=id1[x2][lg[len]];
	ade(x1,t,w),ade(x2,t,w);
}
void link2(int u,int v,int t,int w)
{
	int len=dep[u]-dep[v]+1;
	int x1=id2[u][lg[len]],x2=u,res=len-(1<<lg[len]);
	for(;res;res-=res&-res)x2=f[x2][lg[res&-res]];
	x2=id2[x2][lg[len]];
	ade(t,x1,w),ade(t,x2,w);
}
int lca(int u,int v)
{
	u=dfn[u],v=dfn[v];if(u>v)swap(u,v);
	int len=lg[v-u+1];
	return dep[euler[u][len]]<dep[euler[v-(1<<len)+1][len]]?euler[u][len]:euler[v-(1<<len)+1][len];
}
struct ZKW_Seg
{
	int l,a[6000000];
	void build(){l=1;while(l<node_cnt)l<<=1;--l;for(int i=1;i<=node_cnt;i++)a[i+l]=i;}
	void upd(int x){for(int i=(x+l)>>1;i;i>>=1)a[i]=dis[a[i<<1]]<dis[a[i<<1|1]]?a[i<<1]:a[i<<1|1];}
	void del(int x){a[x+l]=0;upd(x);}
}q;
void spfa(int S)
{
	for(int i=0;i<=node_cnt;i++)dis[i]=1005000000;q.build();
	dis[S]=0;q.upd(S);
	while(dis[q.a[1]]!=1005000000)
	{
		int u=q.a[1];q.del(u);
		for(int i=fst[u];i;i=nxt[i])
		{
			int v=e[i].v;
			if(dis[u]+e[i].w<dis[v])
			{
				dis[v]=dis[u]+e[i].w;
				q.upd(v);
			}
		}
	}
}
int getin()
{
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();
	return x;
}
int main()
{
	scanf("%d%d%d",&n,&m,&S);
	int qn=0;
	for(int i=1;i<=n;i++)bcj.fa[i]=i;
	for(int i=1;i<=m;i++)
	{
		int opt,u1,v1,u2,v2,w;
		opt=getin();
		if(opt==1)
		{
			u1=getin(),v1=getin(),u2=getin(),v2=getin(),w=getin();
			if(bcj.find(u1)!=bcj.find(v1)||bcj.find(u2)!=bcj.find(v2))continue;
			qu[++qn]=(Q){u1,v1,u2,v2,w};
		}
		else
		{
			u1=getin(),v1=getin(),w=getin();
			int fu=bcj.find(u1),fv=bcj.find(v1);
			if(fu==fv)continue;
			ade(u1,v1,w),ade(v1,u1,w),bcj.fa[fu]=fv;
		}
	}
	lg[0]=-1;for(int i=1;i<=(n<<1);i++)lg[i]=lg[i>>1]+1;
	for(int i=1;i<=n;i++)if(!dfn[i])dfs(i,0);
//	for(int i=1;i<=n;i++)cout<<dep[i]<<" ";puts("");
	node_cnt=n;
	for(int i=1;(1<<i)<n;i++)
		for(int j=1;j<=n;j++)
			if((1<<i)<=dep[j])
			{
				id1[j][i]=++node_cnt,id2[j][i]=++node_cnt;
				ade(id1[j][i-1],id1[j][i],0),ade(id1[f[j][i-1]][i-1],id1[j][i],0);
				ade(id2[j][i],id2[j][i-1],0),ade(id2[j][i],id2[f[j][i-1]][i-1],0);
			}
	for(int i=1;(1<<i)<=dfs_cnt;i++)
		for(int j=1;j+(1<<i)-1<=dfs_cnt;j++)
			euler[j][i]=dep[euler[j][i-1]]<dep[euler[j+(1<<(i-1))][i-1]]?euler[j][i-1]:euler[j+(1<<(i-1))][i-1];
	for(int i=1;i<=qn;i++)
	{
		int u1=qu[i].u1,v1=qu[i].v1,u2=qu[i].u2,v2=qu[i].v2,w=qu[i].w;
		int l1=lca(u1,v1),l2=lca(u2,v2);int u=++node_cnt;
//		cout<<u1<<" "<<v1<<" "<<u2<<" "<<v2<<endl;
//		cout<<dfn[u2]<<" "<<dfn[v2]<<endl;
//		cout<<l1<<" "<<l2<<endl;
		link1(u1,l1,u,w);if(v1!=l1)link1(v1,l1,u,w);
		link2(u2,l2,u,0);if(v2!=l2)link2(v2,l2,u,0);
//		cout<<i<<endl;
	}
	spfa(S);
	for(int i=1;i<=n;i++)
		if(dis[i]>1000000000)printf("-1 ");
		else printf("%d ",dis[i]);
	puts("");
}
```

---

## 作者：_ZSR_ (赞：1)

[P5344 【XR-1】逛森林](https://www.luogu.com.cn/problem/P5344)

在写这道题之前，本蒟蒻曾学过线段树优化建图，于是在看到区间加边操作和单点加边操作后，立马想到了树剖加线段树优化建图。但一看到数据范围，貌似不太能过，只能考虑别的办法。

虽然树剖加线段树优化建图不太能过，但是它可以给我们一些启发，我们要使用一种大区间覆盖小区间的 $\log$ 级别的数据结构来优化建图。除了线段树，倍增貌似也可以满足这样的需求。

具体来说，我们令 $f_{i,j}$ 表示从节点 $i$ 开始，走 $2^j$ 个节点可以到达的节点。这里走过的节点是沿着操作 $2$ 的边走的。当然，我们把无向边看成有向边，即我们把每一个由无向边构成的连通块看成以某个点为根节点的一颗有根树，具体是哪一个点取决于遍历的先后顺序。对于每一个 $f_{i,j}$，我们建立两个虚点，一个为入点，一个为出点。从它的入点向它包含的两个子区间的入点连边权为 $0$ 的边，从它包含的两个子区间的出点向它的出点连边权为 $0$ 的边。这类似于线段树优化建图。

对于每一个操作 $2$，我们用并查集来维护。对于每一个操作 $1$，如果合法，我们就存下来，反之就直接舍弃。读入完所有操作后，我们按照上述倍增优化建图的方法建图，然后枚举我们存下来的每一个操作。因为要找到两点在树上的路径，因此我们求 LCA。在求 LCA 的过程中，我们会倍增地往上跳，在跳的过程中，我们进行加边。我们新建两个虚点，一个连向所有跳到的 $f_{i,j}$ 的入点，称为入虚点。一个由所有跳到的 $f_{i,j}$ 的出点连向它，成为出虚点。然后由出虚点向入虚点连一条边权为 $w$ 的边。

最后跑一遍 Dijkstra 就可以了，具体细节看代码。

code

```
#include <bits/stdc++.h>
using namespace std;
const int N=50010,M=1000010,NN=4000010,NE=32000010,INF=0x3f3f3f3f;
typedef pair<int,int> pii;
int n,m,s,maxk,cntv,cntop;
int p[N];//并查集
int h[N],to[N<<1],nxt[N<<1],idx;//无向边
int nh[NN],nto[NE],nnxt[NE],edge[NE],nidx;//有向边
int dist[NN];
bool st[NN];
int dep[N],fa[N][16],in[N][16],out[N][16];//节点信息
struct Operation{
	int u1,v1,u2,v2,w;
}op[M];//操作
int find(int x)
{
    if (x==p[x]) return x;
    else return p[x]=find(p[x]);
}
inline void add_nodir(int a,int b)
{
	to[++idx]=b,nxt[idx]=h[a],h[a]=idx;
	to[++idx]=a,nxt[idx]=h[b],h[b]=idx;
}//建无向边
inline void add_dir(int a,int b,int c)
{
	nto[++nidx]=b;
	nnxt[nidx]=nh[a];
	edge[nidx]=c;
	nh[a]=nidx;
}//建有向边
void dfs(int u,int f)
{
	dep[u]=dep[fa[u][0]=f]+1;
	in[u][0]=++cntv,add_dir(cntv,u,0),add_dir(cntv,f,0);
    out[u][0]=++cntv,add_dir(u,cntv,0),add_dir(f,cntv,0);
    for (int j=0;j<maxk;++j)
    {
        fa[u][j+1]=fa[fa[u][j]][j];
        in[u][j+1]=++cntv,add_dir(cntv,in[u][j],0),add_dir(cntv,in[fa[u][j]][j],0);
        out[u][j+1]=++cntv,add_dir(out[u][j],cntv,0),add_dir(out[fa[u][j]][j],cntv,0);
    }
    for (int i=h[u];i;i=nxt[i]) if (to[i]!=f) dfs(to[i],u);
}//初始化倍增数组和出入点
inline void lca_out(int x,int y,int vnode)
{
    if (dep[x]<dep[y]) swap(x,y);
    add_dir(y,vnode,0);
    for (int i=maxk;i>=0;--i)
    {
        if (dep[fa[x][i]]>=dep[y])
        {
            add_dir(out[x][i],vnode,0);
            x=fa[x][i];
        }
    }
    if (x==y) return;
    for (int i=maxk;i>=0;--i)
    {
        if (fa[x][i]!=fa[y][i])
        {
            add_dir(out[x][i],vnode,0);
            x=fa[x][i];
            add_dir(out[y][i],vnode,0);
            y=fa[y][i];
        }
    }
    add_dir(out[x][0],vnode,0);
}//出点向虚点连边
inline void lca_in(int x,int y,int vnode)
{
    if (dep[x]<dep[y]) swap(x,y);
    add_dir(vnode,y,0);
    for (int i=maxk;i>=0;--i)
    {
        if (dep[fa[x][i]]>=dep[y])
        {
            add_dir(vnode,in[x][i],0);
            x=fa[x][i];
        }
    }
    if (x==y) return;
    for (int i=maxk;i>=0;--i)
    {
        if (fa[x][i]!=fa[y][i])
        {
            add_dir(vnode,in[x][i],0);
            x=fa[x][i];
            add_dir(vnode,in[y][i],0);
            y=fa[y][i];
        }
    }
    add_dir(vnode,in[x][0],0);
}//虚点向入点连边
inline void dijkstra(int s)
{
    memset(dist,0x3f,sizeof dist);
    priority_queue<pii,vector<pii>,greater<pii>> q;
    q.push({0,s});
    dist[s]=0;
    while (q.size())
    {
        auto x=q.top().second;
        q.pop();
        if (st[x]) continue;
        st[x]=true;
        for (int i=nh[x];i;i=nnxt[i])
        {
            int y=nto[i];
            if (dist[y]>dist[x]+edge[i])
            {
                dist[y]=dist[x]+edge[i];
                q.push({dist[y],y});
            }
        }
    }
}
int main()
{
	scanf("%d%d%d",&n,&m,&s);
	cntv=n;
	while ((1<<maxk)<=n) maxk++;//求最大区间长度
	maxk--;
	for (int i=1;i<=n;++i) p[i]=i;//初始化并查集
	for (int i=1;i<=m;++i)
	{
		int type,u,v,x,y,w;
		scanf("%d",&type);
		if (type==1)
		{
			scanf("%d%d%d%d%d",&x,&y,&u,&v,&w);
			if (find(x)!=find(y)||find(u)!=find(v)) continue;
			op[++cntop]={x,y,u,v,w};
		}
		else
		{
			scanf("%d%d%d",&u,&v,&w);
            x=find(u),y=find(v);
			if (x==y) continue;
			add_nodir(u,v);
			add_dir(u,v,w),add_dir(v,u,w);
			p[x]=y;
		}
	}
	for (int i=1;i<=n;++i) if (!dep[i]) dfs(i,0);
	for (int i=1;i<=cntop;++i)
	{
		lca_out(op[i].u1,op[i].v1,++cntv);
		lca_in(op[i].u2,op[i].v2,++cntv);
		add_dir(cntv-1,cntv,op[i].w);
	}
	dijkstra(s);
	for (int i=1;i<=n;++i) printf("%d ",dist[i]==INF?-1:dist[i]);
	return 0;
} 
```


---

## 作者：WeLikeStudying (赞：1)

- 此题为开摆计划 T3。
![不可描述的恐怖物体](https://cdn.luogu.com.cn/upload/pic/57782.png)
- [线段树优化建图板子](https://www.luogu.com.cn/record/64203687)，[基础讲解](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/xian-duan-shu)。
- 特别鸣谢：[奆佬](https://www.luogu.com.cn/user/58543)。

**[题意](https://www.luogu.com.cn/problem/P5344)**
- 给出一棵森林，支持树链和树链之间的点两两连边，求新图的单源最短路。

**做法 1**
- 直接树链剖分（用内部的线段树）优化建图！你发现只要数据卡树剖复杂度就是 $O(m\log^3n)$，显然会被卡，而且估计很难打。
- 点数 $O(n)$ 边数 $O(m\log^2n)$……我觉得这不太好。

**做法 2**
- 咱们尝试搞多一点点，使用倍增：每个点把它的 $2^k$ 级祖先的树链强行连边！这样做点数是 $O(n\log n)$，边数也是 $O(m\log n)$ 的，复杂度 $O(m\log^2n)$。~~卡卡常能过！~~ 

**做法 3**
- 你发现一个重要东西是重复连边不影响答案欸！那么你可以来个里应外合（使用类似 $\text{ST}$ 表的方法），如下图：
![](https://cdn.luogu.com.cn/upload/image_hosting/4nq99zkk.png)
- 这样边数为 $O(n\log n+m)$ 总复杂度为 $O(n\log^2n+m\log n)$ 是可过的！[代码](https://www.luogu.com.cn/paste/8k6s7h4m)。

**做法 4**
- 我现在发现，数据结构优化建边的力量还是有限的啊……人不论怎么优化建边，都无法避免被卡常的痛苦……所以，我不优化建边了！我要优化迪杰斯特拉算法！
- ~~其实是这样的 BZOJ 4699 是这题的加强版，虽然 BZOJ 已经爆炸了但还是可以去爆炸 OJ 访问的。~~
- 考虑迪杰斯特拉算法的过程，取出当前的最小点，进行边的更新，看起来链的边很多，但其实入链只需要选出距离最短的点更新出链就好了。
- 我们选出最小的点与链的组合，这样链的更新是单调的，可以直接并查集覆盖搞。
- 接下来的问题是快速找到经过某点的所有路径，判定是 $x=\text{lca}(u,v)$ 或者只有一个点在 $x$ 的子树上，第一种情况直接暴力，第二种情况转化为 $\text{dfs}$ 序。
- 让路径从左向右排布，对于区间，查询最左的“向右路径”和最右的向左路径，只需要一棵线段树，代码实现先咕着。

---


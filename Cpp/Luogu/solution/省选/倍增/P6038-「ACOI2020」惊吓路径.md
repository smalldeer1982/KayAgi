# 「ACOI2020」惊吓路径

## 题目背景

![T6](https://s2.ax1x.com/2020/01/12/lopZpq.png)

3 年 E 班的同学们赢得了去南方的冲绳小岛的机会，在渚打败了鹰冈之后，他们受杀老师的邀请参加“试胆大会”。

试胆大会在一个黑漆漆的洞窟里面进行。赤羽 業（Akabane Karma）现在和奧田 愛美站在洞窟的门口。突然，業想到了一个事情。。。

## 题目描述

杀老师告诉过他们，洞窟可以近似地看成 $n$ 个点的外向树，因为地形原因，所以一个点到另一个点的边是有方向的，且边的方向都是同向的。这棵树的树根为入度为 $0$ 的点。每个点都有一个惊吓值，给出每个点的惊吓值 $a_i$。

杀老师告诉他们，这个洞穴有很多惊吓路径。如果两个节点 $u,v$ 构成的路径是一条惊吓路径的话，满足以下条件：

- $v$ 一定在 $u$ 的子树中。

- $u, v$ 这条路径上的所有的点的惊吓值的或值 $\geq k$。

走过一条惊吓路径就会收到杀老师的惊喜大礼。杀老师已经提前准备好了惊喜大礼，但是業当然已经知道杀老师有一些下流的意图，更别说惊喜大礼的数量可能不够！杀老师已经承诺有多少条惊吓路径就有多少个惊喜大礼。業已经通过一些神奇的途径知道了杀老师准备的惊喜大礼的个数，现在他想知道有多少条惊吓路径，也就是杀老师最少需要准备惊喜大礼的个数。如果不够，他就会揭穿杀老师的意图。现在業当然想赚，好好捉弄一下杀老师。所以他~~作弊~~提前得到了杀老师的地图，想问这个图里面有多少条惊吓路径？

## 说明/提示

#### 样例解释 #1

![](https://cdn.luogu.com.cn/upload/image_hosting/lqu4ejku.png)

只有两条路径满足条件：

1. $3\to 1\to 2$，这条路径的所有点的惊吓值的或值是 $6\operatorname{or}5\operatorname{or}9=15$。

2. $1 \to 2$，这条路径的所有点的惊吓值的或值是 $5\operatorname{or}9=13$。

------------
#### 数据范围 
**本题采用捆绑测试**。

- Subtask 1（10 points）：$n \leq 5 \times 10^3$，$k \leq 10^5$。    
- Subtask 2（30 points）：对于任意一条边，$v=u+1$，$n \leq 10^6$，$k,a_i \leq 10^9$。     
- Subtask 3（20 points）：$n \leq 10^5$，$k,a_i \leq 10^9$。    
- Subtask 4（40 points）：$n \leq 5 \times 10^5$，$k,a_i \leq 10^9$。

对于 $100\%$ 的数据，$1 \leq n \leq 10^6$，$1 \leq k,a_i \leq 10^9$。

------------
#### 提示
**第四个子任务中的测试点空间 256MB，其余子任务中的测试点空间 128MB。**

## 样例 #1

### 输入

```
5 10
5 9 6 4 2
3 1
3 4
1 2
1 5
```

### 输出

```
2```

## 样例 #2

### 输入

```
7 5
6 7 4 5 7 8 9
1 2
2 3
2 4
1 5
5 6
5 7
```

### 输出

```
16```

## 样例 #3

### 输入

```
8 5
4 3 2 5 6 7 6 2
1 2
1 5
2 3
2 4
5 6
5 7
6 8
```

### 输出

```
16```

# 题解

## 作者：zhengrunzhe (赞：8)

~~毒瘤出题人卡时空~~

**题意：给定一棵带点权树，求树中有多少对(u,v)满足v在u的子树中且orsum(path(u,v))>=k**

首先$orsum$满足结合律和单调性，不妨考虑枚举每个$v$有多少个祖先满足条件，当某个祖先u满足$orsum\geq k$的时候，u的所有祖先也都满足$orsum\geq k$

考虑倍增从v跳到最深的满足$orsum\geq k$的祖先u，那么对答案产生的贡献就是$dep[u]$($dep[root]=1$)

预处理$anc[i][j]$表示$i$的$2^j$祖先，和$orsum[i][j]$表示$i$的父亲到$i$的$2^j$祖先路径点权或和，$dfs$一遍预处理出每个点的深度$dep[i]$

然后倍增就是基础操作了

```cpp
#include<cstdio>
template<class type>inline const void read(type &in)
{
	in=0;char ch(getchar());
	while (ch<48||ch>57)ch=getchar();
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();
}
typedef long long ll;
const int N(1e6+10),logn(20);
ll ans;
int orsum[N][logn+1],anc[N][logn+1],dep[N],n,k,head[N],edc,next[N],to[N],val[N];
inline const void addedge(const int &u,const int &v)
{
	next[++edc]=head[u];to[head[u]=edc]=v;
}
inline const void dfs(const int &p)
{
	for (int i(head[p]);i;i=next[i])dep[to[i]]=dep[p]+1,dfs(to[i]);
}
inline const void prework()
{
	for (int j(1);j<=logn;j++)
		for (int i(1);i<=n;i++)
			anc[i][j]=anc[anc[i][j-1]][j-1],
			orsum[i][j]=orsum[i][j-1]|orsum[anc[i][j-1]][j-1];
}
inline const int jump(int p)
{
	int sum(val[p]);
	if (sum>=k)return p;
	for (int i(logn);~i;i--)
		if (anc[p][i])
			if ((sum|orsum[p][i])<k)
				sum|=orsum[p][i],p=anc[p][i];
	return anc[p][0];
}
int main()
{
	read(n);read(k);
	for (int i(1);i<=n;i++)read(val[i]);
	for (int u,v,i(1);i<n;i++)read(u),read(v),addedge(u,v),orsum[v][0]=val[anc[v][0]=u];
	for (int i(1);i<=n;i++)if (!anc[i][0]){dep[i]=1;dfs(i);break;}prework();
	for (int i(1);i<=n;i++)ans+=dep[jump(i)];
	printf("%lld\n",ans);
	return 0;
}
```

然后交一发mle70分，发现subtask4给了256mb可以过，subtask2都是一百万的链只给128mb就被卡了

然后此时来思考一下链怎么做

这个链非常友好，是形如$1\rightarrow 2\rightarrow 3\rightarrow \cdots \rightarrow n$的链，考虑链转序列，编号几就是第几个数

同样的思路我们可以对每个$i$找到编号$j\leq i$且$orsum[j,i]\leq k$的最小$j$，不能再倍增了一开$10^6*20$的数组直接mle

考虑把倍增换成二分，只要我们能够获取区间$orsum$就能实现

由于$orsum$没有可减性，我们不能够通过前缀和的方式$O(1)$获取

一种简单的方法通过线段树维护$O(\log n)$获取

然后外面套个二分合起来就是$O(n\log^2 n)$的

考虑能不能在线段树上二分，显然是可以做的，但是不太好理解，我就写了个$Splay$上二分

```cpp
#include<cstdio>
template<class type>inline const void read(type &in)
{
	in=0;char ch(getchar());
	while (ch<48||ch>57)ch=getchar();
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();
}
typedef long long ll;
const int N(1e6+1),logn(19);
ll ans;
int orsum[N][logn+1],anc[N][logn+1],dep[N],n,k,head[N],edc,next[N],to[N],val[N],u[N],v[N];
inline const void addedge(const int &u,const int &v)
{
	next[++edc]=head[u];to[head[u]=edc]=v;
}
inline const void dfs(const int &p)
{
	for (int i(head[p]);i;i=next[i])dep[to[i]]=dep[p]+1,dfs(to[i]);
}
inline const void prework()
{
	for (int j(1);j<=logn;j++)
		for (int i(1);i<=n;i++)
			anc[i][j]=anc[anc[i][j-1]][j-1],
			orsum[i][j]=orsum[i][j-1]|orsum[anc[i][j-1]][j-1];
}
inline const int jump(int p)
{
	int sum(val[p]);
	if (sum>=k)return p;
	for (int i(logn);~i;i--)
		if (anc[p][i])
			if ((sum|orsum[p][i])<k)
				sum|=orsum[p][i],p=anc[p][i];
	return anc[p][0];
}
namespace Splay
{
	struct tree
	{
		int orsum,val;
		tree *son[2],*fa;
		static tree *null;
		void *operator new[](size_t size);
		inline tree():orsum(0),val(0)
		{
			static bool init(0);
			if (!init)
				init=1,
				null=new tree,
				null->son[0]=null->son[1]=null->fa=null;
			son[0]=son[1]=fa=null;
		}
		inline const void pushup()
		{
			orsum=son[0]->orsum|val|son[1]->orsum;
		}
		inline const void set(tree *p,const bool &f)
		{
			if (p!=null)p->fa=this;
			if (this!=null)son[f]=p;
		}
		inline const bool id()
		{
			return fa->son[1]==this;
		}
		inline const void rotate()
		{
			const bool f(id());
			tree *fa(this->fa);
			fa->fa->set(this,fa->id());
			fa->set(son[f^1],f);
			set(fa,f^1);
			fa->pushup();pushup();
		}
		inline const void splay()
		{
			for (;fa!=null;rotate())
				if (fa->fa!=null)
					(fa->id()^id()?this:fa)->rotate();
		}
	}*node0,*tree::null;
	#define null tree::null
	inline tree *node(const int &x){return node0+x;}
	char memory_pool[N*sizeof(tree)],*tail(memory_pool+sizeof memory_pool);
	inline void *tree::operator new[](size_t size){return tail-=size;}
	inline tree *build(const int &l,const int &r,tree *fa)
	{
		if (l>r)return null;
		const int mid(l+r>>1);
		node(mid)->val=val[mid];node(mid)->fa=fa;
		if (l==r)return node(l)->orsum=node(l)->val,node(l);
		node(mid)->son[0]=build(l,mid-1,node(mid));
		node(mid)->son[1]=build(mid+1,r,node(mid));
		node(mid)->pushup();
		return node(mid);
	}
	inline const int query(const int &pos)
	{
		tree *p(node(pos));
		p->splay();
		if (p->val>=k)return pos;
		int sum(p->val);p=p->son[0];
		while (p!=null)
			if ((sum|p->son[1]->orsum)>=k)p=p->son[1];
			else if ((sum|p->son[1]->orsum|p->val)>=k)return p-node0;
				else sum|=p->son[1]->orsum|p->val,p=p->son[0];
		return 0;
	}
}using namespace Splay;
int main()
{
	read(n);read(k);
	for (int i(1);i<=n;i++)read(val[i]);
	bool type(1);
	for (int i(1);i<n;i++)read(u[i]),read(v[i]),type=type&&v[i]==u[i]+1;
	if (type)
	{
		node0=new tree[n+1];
		build(1,n,null);
		for (int i(1);i<=n;i++)ans+=query(i);
		printf("%lld\n",ans);
		return 0;
	}
	for (int i(1);i<n;i++)addedge(u[i],v[i]),orsum[v[i]][0]=val[anc[v[i]][0]=u[i]];
	for (int i(1);i<=n;i++)if (!anc[i][0]){dep[i]=1;dfs(i);break;}prework();
	for (int i(1);i<=n;i++)ans+=dep[jump(i)];
	printf("%lld\n",ans);
	return 0;
}
```

能往右儿子走就往右儿子走，否则看看自己满不满足条件，满足就是自己，否则往左儿子走，记一个**排名在当前节点之后的点权或和**，往左儿子走的时候就把右子树或和与当前点权的或和累计起来

然后我一开始是这样先把树建好然后把每个点都$splay$到根，先判断根自己是不是满足条件，否则在其左子树上执行上述二分过程

然后这个玩意tle了四个点，因为建树完之后每次查询树中的点数都是$n$的，这个常数就大了

因为每次查询之和其前面的数有关，我们不妨一个个插入一个个查

考虑现在原来的平衡树上查，把前一个点$splay$执行二分，查完之后把这个点插入到根的右儿子上

这样子做的复杂度实际上是错的，这样子出来的树形态是一条链，那就完蛋了

需要多$spla$y几个点维持平衡结构

```cpp
inline const void query(const int &pos)
{
	if (pos==1)return ans+=val[pos]>=k,void();
	tree *p(node(pos-1));p->splay();
	p->set(node(pos),1);p->orsum|=val[pos];
	int sum(0);
	while (p!=null)
		if ((sum|p->son[1]->orsum)>=k)p=p->son[1];
		else if ((sum|=(p->son[1]->orsum|p->val))>=k)break;
			else p=p->son[0];
	if (p!=null)ans+=p-node0;
	p->splay();
}
```

接着我写了个这个玩意，把二分到的答案点$splay$到根，由于答案点十分的随机，所以整个树也许比较随机平衡，然而它还是t了一个点

到最后我实在是懒得想了，直接随机找一个点$splay$:

```cpp
#include<cstdio>
#include<cstdlib>
template<class type>inline const void read(type &in)
{
	in=0;char ch(getchar());
	while (ch<48||ch>57)ch=getchar();
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();
}
typedef long long ll;
const int N(1e6+1),logn(19);
ll ans;
int orsum[N][logn+1],anc[N][logn+1],dep[N],n,k,head[N],edc,next[N],to[N],val[N],u[N],v[N];
inline const void addedge(const int &u,const int &v)
{
	next[++edc]=head[u];to[head[u]=edc]=v;
}
inline const void dfs(const int &p)
{
	for (int i(head[p]);i;i=next[i])dep[to[i]]=dep[p]+1,dfs(to[i]);
}
inline const void prework()
{
	for (int j(1);j<=logn;j++)
		for (int i(1);i<=n;i++)
			anc[i][j]=anc[anc[i][j-1]][j-1],
			orsum[i][j]=orsum[i][j-1]|orsum[anc[i][j-1]][j-1];
}
inline const int jump(int p)
{
	int sum(val[p]);
	if (sum>=k)return p;
	for (int i(logn);~i;i--)
		if (anc[p][i])
			if ((sum|orsum[p][i])<k)
				sum|=orsum[p][i],p=anc[p][i];
	return anc[p][0];
}
namespace Splay
{
	struct tree
	{
		int orsum,val;
		tree *son[2],*fa;
		static tree *null;
		void *operator new[](size_t size);
		inline tree():orsum(0),val(0)
		{
			static bool init(0);
			if (!init)
				init=1,
				null=new tree,
				null->son[0]=null->son[1]=null->fa=null;
			son[0]=son[1]=fa=null;
		}
		inline const void pushup()
		{
			orsum=son[0]->orsum|val|son[1]->orsum;
		}
		inline const void set(tree *p,const bool &f)
		{
			if (p!=null)p->fa=this;if (this!=null)son[f]=p;
		}
		inline const bool id()
		{
			return fa->son[1]==this;
		}
		inline const void rotate()
		{
			const bool f(id());
			tree *fa(this->fa);
			fa->fa->set(this,fa->id());
			fa->set(son[f^1],f);
			set(fa,f^1);
			fa->pushup();pushup();
		}
		inline const void splay()
		{
			for (;fa!=null;rotate())
				if (fa->fa!=null)
					(fa->id()^id()?this:fa)->rotate();
		}
	}*node0,*tree::null;
	#define null tree::null
	inline tree *node(const int &x){return node0+x;}
	char memory_pool[N*sizeof(tree)],*tail(memory_pool+sizeof memory_pool);
	inline void *tree::operator new[](size_t size){return tail-=size;}
	inline const void query(const int &pos)
	{
		if (pos==1)return ans+=val[pos]>=k,void();
		tree *p(node(pos-1));p->splay();
		p->set(node(pos),1);p->orsum|=val[pos];
		if (val[pos]>=k)return ans+=pos,void();
		if ((val[pos]|val[pos-1])>=k)return ans+=pos-1,void();
		int sum(0);
		while (p!=null)
			if ((sum|p->son[1]->orsum)>=k)p=p->son[1];
			else if ((sum|=(p->son[1]->orsum|p->val))>=k)break;
				else p=p->son[0];
		if (p!=null)ans+=p-node0;
		node(rand()%pos+1)->splay(); //鬼才操作
	}
}using namespace Splay;
int main()
{
	srand(19260817);
	read(n);read(k);
	for (int i(1);i<=n;i++)read(val[i]);
	bool type(1);
	for (int i(1);i<n;i++)read(u[i]),read(v[i]),type=type&&v[i]==u[i]+1;
	if (type)
	{
		node0=new tree[n+1];
		for (int i(1);i<=n;i++)node(i)->val=node(i)->orsum=val[i];
		for (int i(1);i<=n;i++)query(i);
		printf("%lld\n",ans);
		return 0;
	}
	for (int i(1);i<n;i++)addedge(u[i],v[i]),orsum[v[i]][0]=val[anc[v[i]][0]=u[i]];
	for (int i(1);i<=n;i++)if (!anc[i][0]){dep[i]=1;dfs(i);break;}prework();
	for (int i(1);i<=n;i++)ans+=dep[jump(i)];
	printf("%lld\n",ans);
	return 0;
}
```
然后这个玩意它居然A了，全 体 起 立

---

## 作者：LanrTabe (赞：3)

题目链接：[Luogu P6044](https://www.luogu.com.cn/problem/P6044)

[My Blog](https://www.cnblogs.com/LanrTabe/p/12252926.html)

~~强行卡内存差评~~

首先对于一个固定的$v$，$u$显然是有单调性的：若一个点$u$满足条件，则$u$的所有祖先都满足条件

那么就有了一个简单的做法，枚举所有的$v$，找到最深的$u$，对答案的贡献就是$u$的深度

我们可以用倍增来加速这个过程，即不断向上跳找到最浅的点$x$不满足条件，那么$x$的父亲就是最深的$u$。

倍增数组就有两个，一个$f[i][x]$表示$x$的$2^i$级祖先，一个$g[i][x]$表示从$x$向上$2^i$个点的或和。

然后问题来了，出题人卡内存怎么办？（倍增数组就要$152M$）

我的方法是在DFS的过程中用一个栈维护根到$v$的这条链，实时维护$g$数组

这样的话我们就不需要$f$数组了！（直接在栈里往前移$2^i$个位置就好了）

~~这样就可以不特判过Subtask2了！~~

不知道为什么我的DFS会用掉$60M$的栈空间。。没办法只能手动模拟DFS了，极限数据约$100M$内存。

时间复杂度 $O(n\log n)$

空间复杂度 $O(n\log n)$

### 代码：

```cpp
//不带IO优化的版本
#include <cstdio>
#define rint register int
typedef long long ll;

const int N=1000005;
int n,k,c[N],s[N],Top;
int Head[N],Next[N],To[N],En;
int f[20][N];
bool Son[N];
ll Ans;

inline void Add(int x,int y){Next[++En]=Head[x],To[Head[x]=En]=y;}

void Calc(int x)//将点x入栈并计算x的贡献
{
    s[++Top]=x,f[0][Top]=c[x];
    for(int i=1;1<<i<=Top;++i)f[i][Top]=f[i-1][Top]|f[i-1][Top-(1<<(i-1))];
    int p=Top+1,v=0;
    for(int i=19;i>=0;--i)
        if((1<<i)<p&&(f[i][p-1]|v)<k)
            v|=f[i][p-1],p-=1<<i;
    Ans+=p-1;
}

void BFS(int x)//并不是BFS
{
    Calc(x);
    while(Top)
        if(Head[x=s[Top]])Calc(To[Head[x]]),Head[x]=Next[Head[x]];//向下DFS
        else --Top;//回溯
}

int main()
{
    scanf("%d%d",&n,&k);
    for(rint i=1;i<=n;++i)scanf("%d",&c[i]);
    for(rint i=2,x,y;i<=n;++i)scanf("%d%d",&x,&y),Add(x,y),Son[y]=true;
    for(rint i=1;i<=n;++i)if(!Son[i])BFS(i),i=n;
    return printf("%lld\n",Ans),0;
}
```

---

## 作者：漠寒 (赞：2)

## 分析

我们如果已经找到了一条满足要求的路径，如果将它继续延伸的话，或值只会增加，所以你不管延伸多长都可以的。

所以考虑二分答案，先确定路径终点，二分最短能满足要求的延伸长度，然后该次贡献的答案就能通过深度轻松算出。

考虑二分的 check，我们用倍增来计算，$f[i][j]$ 表示倍增到的点编号，$g[i][j]$ 表示到那个点路上所有点的权值的或值。

然后捆绑点2需要数据分治，因为会爆空间，所以单独用一个 ST 表去处理它。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
inline void read(int &res){
	char c;
	int f=1;
	res=0;
	c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')res=(res<<1)+(res<<3)+c-48,c=getchar();
	res*=f;
}
int n,k;
int lg[1000005];
int st[1000005][20];
int f[500005][20],g[500005][20];
int dep[500005],a[500005];
int head[500005],tot;
int in[500005],root;
struct edge{
	int to,nex;
}e[500005];
int specheck(int l,int r){
	int kk=lg[r-l+1];
	return st[l][kk]|st[r-(1<<kk)+1][kk];
}
void special(){
	lg[0]=-1;
	for(int i=1;i<=n;i++)lg[i]=lg[i>>1]+1;
	for(int i=1;i<=n;i++)read(st[i][0]);
	for(int i=1;i<=19;i++){
		for(int j=1;j+(1<<i)-1<=n;j++){
			st[j][i]=st[j][i-1]|st[j+(1<<(i-1))][i-1];//ST
		}
	}
	long long anss=0;
	for(int i=1;i<=n;i++){
		int l=i,r=n,ans=-1;
		while(l<=r){
			int mid=(l+r)>>1;
			if(specheck(i,mid)>=k){
				ans=mid;
				r=mid-1;
			}
			else l=mid+1;
		}
		if(ans!=-1){
			anss+=n-ans+1;
		}
	}
	cout<<anss;
}
inline void add(int qq,int mm){
	e[++tot].to=mm;
	e[tot].nex=head[qq];
	head[qq]=tot;
}
void dfs(int u,int ff){
	f[u][0]=ff;
	g[u][0]=a[ff];//dfs初始化 
	dep[u]=dep[ff]+1;
	for(int i=head[u];i;i=e[i].nex){
		int v=e[i].to;
		dfs(v,u);
	}
}
void pre(){
	for(int i=1;i<=19;i++){
		for(int j=1;j<=n;j++){
			f[j][i]=f[f[j][i-1]][i-1];
			g[j][i]=g[j][i-1]|g[f[j][i-1]][i-1];//倍增预处理 
		}
	}
}
int check(int x,int len){
	int sum=a[x];
	for(int i=0;i<=19;i++){
		if(len&(1<<i)){
			sum|=g[x][i];
			x=f[x][i];
		}
	}
	return sum;
}
signed main()
{
	read(n);read(k);
	if(n>500000){
		special();
		return 0;
	}
	for(int i=1;i<=n;i++)read(a[i]);
	for(int i=1;i<n;i++){
		int x,y;
		read(x);read(y);
		add(x,y);
		in[y]++;
	}
	for(int i=1;i<=n;i++)if(!in[i]){
		root=i;
		break;
	}
	dfs(root,0);
	pre();
	long long anss=0;
	for(int i=1;i<=n;i++){
		int l=0,r=dep[i]-1,ans=-1;
		while(l<=r){//二分 
			int mid=(l+r)>>1;
			if(check(i,mid)>=k){
				ans=mid;
				r=mid-1;
			}
			else l=mid+1;
		}
		if(ans!=-1)anss+=dep[i]-ans;
	}
	cout<<anss;
	return 0;
}




```


---

## 作者：MarchKid_J0e (赞：1)

## 题意

$subtree(x)$ 为 $x$ 的子树。

求树上有多少个二元组 $(u,v)$ 满足 ${v}\in{subtree(u)}$ 且 ${u}\to{v}$ 路径的点权值或值和 $\geq{k}$。

## Solution

**为了思路清晰，先不考虑本题卡空间的问题。**

本题有一个关键性质：对于一个合法的二元组 $(u,v)$，当 $u$ 满足条件时，根据或运算的单调性，$u$ 的祖先一定也满足条件。

所以问题可以转化为：对于每一个 $v$ 点，寻找满足条件的深度最深的 $u$ 点。

查找 $u$ 点可以使用二分查找，也可以使用倍增的方法。此处采用**倍增**。

处理出每个节点的 $2^i$ 级（不包括自身）祖先，方便转移出每个节点向上 $2^i$ 步（包括自己的点权）的点权或值和。然后从高次幂向低次幂枚举，不断向上，直到跳到满足条件的点 $u$，$distance(root,u)$ 就是贡献。

## Key Words

处理每个节点向上 $2^i$ 级的或值和，然后倍增查找满足条件的最深的节点 $u$ 并计算 $distance(root,u)$。

## 空间卡常

当然由于本题卡空间，介绍本人部分优化空间的方法：

- 可以使用栈存储根到当前节点的一条链的信息，这样就可以省去跳祖先的倍增数组。

- 手写栈模拟**非递归版** `dfs`。

- 本人亲测，本题别用 `vector` 存图，使用**链式前向星**更节省空间。

最后 $107MB$ 极限卡过去。

## 代码

提醒：统计答案的变量要开 `long long`。

因为卡常的代码没有阅读性，这里给出了没有卡常的代码，所以不能 `Accepted`。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5;
vector<int> e[N];
int dep[N];
int f[N][20];
int g[N][20];
int n, m;
long long ans; /*统计答案开 long long*/
void dfs(int u)
{
    int k = log2(dep[u] = dep[f[u][0]] + 1);
    for (int i = 1; i <= k; i++) /*预处理*/
    {
        f[u][i] = f[f[u][i - 1]][i - 1];
        g[u][i] = g[f[u][i - 1]][i - 1] | g[u][i - 1];
    }
    int sum = 0, x = u;
    for (int i = k; i >= 0; i--) /*倍增查找满足条件的最深的点*/
    {
        if (g[x][i] && (sum | g[x][i]) < m)
        {
            sum |= g[x][i];
            x = f[x][i];
        }
    }
    ans += dep[x];
    for (int v : e[u])
        dfs(v);
}
signed main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> g[i][0];
    for (int i = 1, u, v; i < n; i++)
    {
    	cin >> u >> v;
        e[u].push_back(v);
        f[v][0] = u;
    }
    for (int i = 1; i <= n; i++)
    	if (!f[i][0]) /*寻找到根节点*/
    		dfs(i);
	cout << ans;
    return 0;
}
```

提供非递归版 `dfs` 的模板，可自行将以上代码改造：

```cpp
void dfs(int root)
{
    stack<int> st;
    st.push(root);
    while (!st.empty())
    {
        int u = st.top();
        if (tag[u] == 1)
        {
            tag[u] = 2;
            /*do sth. after visiting u*/
            st.pop();
        }
        if (tag[u] == 0)
        {
            tag[u] = 1;
            /*do sth. before visiting u*/
            for (int v : son[u])
                st.push(e[i].v);
        }
    }
}
```

---

## 作者：Utilokasteinn (赞：1)

## [Link](https://www.luogu.com.cn/problem/P6038)

题目大意：给定一棵树，求 $(u,v)$ 满足 $v$ 在 $u$ 的子树中，且 $u,v$ 这条路径上的点的或和值不小于 $k$ 的数量。

注意审题，要求的是**或**和值不小于 $k$ ，而不是**异或**值不小于 $k$。

容易发现 $O(n^2)$ 的做法，枚举点 $v$，然后枚举 $u$ 与 $v$ 配对，若可以及答案加一。期望得分 $10$ 分。

继续观察题目的性质，不难发现若 $(u,v)$ 满足条件，则让 $u$ 的祖先代替 $u$ 也一定满足条件。因为正数或运算是不会使原值更低的。所以在树上任意一条链中，或和一定是单调不减的。

这样我们就可以倍增+二分查找，枚举 $v$ 然后二分找到离 $v$ 最近且满足条件的 $u$。具体就是构造一个类似 ST 表的东西， $f_{i,j}$ 表示第 $i$ 个节点到它的 $2^j$ 祖先之间路径的或和。然后二分 $u$ 的深度，容易求出最靠近 $v$ 的 $u$。

以上思路时间复杂度 $O(n\log n)$，空间复杂度 $O(n\log n)$。期望得分 $70$ 分。是因为爆空间而丢的。

观察数据后可以发现 $n>5\times 10^5$ 的数据只存在链中。因为或值单调不减，所以不必用 ST 表进行维护，只需要不断移动指针就醒了。枚举 $u$，接着枚举 $v$，找到第一个满足条件后便移动 $u$，接着重复将 $v$ 向后移动，找到第一个满足条件的 $v$。重复以上操作一直到无法再移动 $v$ 且或值小于 $k$。

以上对于链的思路时间复杂度 $O(31n)$，空间复杂度 $O(n)$。期望得分 $100$。

代码如下（参考[yuzhechuan](https://www.luogu.com.cn/user/65735)的题解）：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline int read()
{
	int s=0;char c=getchar();
	for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar())
		s=s*10+c-'0';
	return s;
}
int n,k,val[1000005],root;
int log_2[1000005]={-1},f[1000005][22];
bool vis[1000005];
int tot,head[1000005];
struct edge{
	int to,nxt;
}e[1000005];
int cnt[32],sum;
ll ans;
inline void add(int u,int v)
{
	e[++tot].to=v;
	e[tot].nxt=head[u];
	head[u]=tot;
}
void init()
{
	n=read(),k=read();
	for(int i=1;i<=n;i++)
		val[i]=read();
	for(int i=1;i<n;i++)
	{
		int u=read(),v=read();
		if(n<=5e5)add(u,v),vis[v]=1;
	}
	if(n>5e5)return;
	for(int i=1;i<=n;i++)
		log_2[i]=log_2[i/2]+1;
	for(int i=1;i<=n;i++)
		if(!vis[i])
		{
			root=i;
			return;
		}
}
inline int query(int l,int r)
{
	int k=log_2[r-l+1];
	return f[r][k]|f[l+(1<<k)-1][k];
}
void dfs(int x,int dep)
{
	f[dep][0]=val[x];
	for(int i=1;(1<<i)<=dep;i++)
		f[dep][i]=f[dep][i-1]|f[dep-(1<<i-1)][i-1];
	int l=1,r=dep;
	while(l<=r)
	{
		int mid=(l+r)/2;
		if(query(mid,dep)>=k)l=mid+1;
		else r=mid-1;
	}
	ans+=l-1;
	for(int i=head[x];i;i=e[i].nxt)
		dfs(e[i].to,dep+1);
}
inline void ins(int x)
{
	sum|=x;
	for(int i=0;i<31;i++)
		if(x>>i&1)cnt[i]++;
}
inline void del(int x)
{
	for(int i=0;i<31;i++)
		if(x>>i&1)
		{
			if(cnt[i]==1)sum^=1<<i;
			cnt[i]--;
		}
}
void solve()
{
	for(int i=1,j=0;i<=n;i++)
	{
		del(val[i-1]);
		while(j<n&&sum<k)ins(val[++j]);
		if(sum<k)break;
		ans+=n-j+1;
	}
}
int main()
{
	init();
	if(n>5e5)solve();
	else dfs(root,1);
	printf("%lld",ans);
	return 0;
}
```

番外，本题的背景动漫是《暗杀教室》，是一部讲述学生暗杀老师的动漫（其实一点也不血腥暴力，到了最后十分催泪）。十分精彩，观看也没有任何不适，但不知道为什么第一季被禁了……

本题的背景似乎也有些问题，如果我没记错的话，试胆是在渚打败了鹰冈之前发生的……

最后祝杀老师在天堂得以安息

![](https://img.zcool.cn/community/018dc45858cdb0a801219c7725f3e6.jpg@1280w_1l_2o_100sh.jpg)

---

## 作者：wizardMarshall (赞：0)

## 题意

求树上儿子到父亲的路径的条数，其中路径上所有点的点权之或的值大于等于 $k$ 的路径个数。

## 思路

以下讨论中，$dep_i$ 为点 $i$ 在树中的深度（最小为 $i$）。

首先很容易想到，同一个点 $x$ 向上走，点权或是只增不减的。因此第一个想法就是对每个 $x$ 进行类似二分的操作，来查找第一个路径点权或大于等于 $k$ 的点。

由此我们可以用 st 表维护从 $i$ 点开始，往上跳了$2^j$ 个点，这些点的点权或的值。统计答案的时候贪心地向上跳（类似找最近公共祖先）直到找到第一个点（假设为 $now$），然后直接将答案增加 $dep_{now}$ 即可，意为 $now$ 及其祖先到 $i$ 的路径都符合要求（因为只增不减）。

特别的，如果 $a_i$ 本身就比 $k$ 大，直接加上 $dep_i$ 即可。

但这样写的空间复杂度是 $O(n \log n)$ 的，无法通过子任务 2。

-----

观察子任务 2，发现这个子任务里的树退化成了一条链，而链具有很好的性质。我们可以把原问题直接丢到序列上来做，转换成如下问题：

找到区间 $[l,r](l \le r)$ 的个数，使得 $a_l \vee a_{l+1} \vee a_{l+2} \vee \dots \vee a_r \le k$。

这样就没有必要使用 st 表来存储了，使用空间复杂度为 $O(n)$ 的线段树即可。枚举每个 $i=l$，尽量大地二分 $r$。

处理的时候如果时间复杂度要做到 $O(n \log n)$，应该是要打线段树上二分的，但由于不太好理解，代码里直接写了二分套线段树，亦可过（只要稍微注意 $i$ 的枚举顺序是从前到后，以便于提前退出剪枝）。

## 代码

```
#include <bits/stdc++.h>
using namespace std;
int a[1000006], dep[1000005];
int st[1000005][21], mx[1000005][21];
vector <int> edge[1000005];

void dfs(int x) {
	for (auto i : edge[x]) {
		dep[i] = dep[x] + 1;
		dfs(i);
	}
	return; 
}
pair <int, int> xy[1000005];
int tree[4 * 1000005];
void init(int x, int l, int r) {
	if (l == r) {
		tree[x] = a[l];
		return;
	}int m = (l + r) >> 1;
	init(x << 1, l, m);
	init((x << 1) | 1, m + 1, r);
	tree[x] = tree[x << 1] | tree[(x << 1) | 1];
	return;
}

int ask(int L, int R, int x, int l, int r) {
	if (L <= l && r <= R) {
		return tree[x];
	}
	int m = (l + r) >> 1;
	int ans = 0;
	if (L <= m) {
		ans |= ask(L, R, (x << 1), l, m);
	}
	if (R > m) {
		ans |= ask(L, R, (x << 1) | 1, m + 1, r);
	}return ans;
}

signed main() {
	int n, k;
	cin >> n >> k;
	for (int i = 1; i <= n; i++) {
		scanf("%d", &a[i]);
	}
	
	bool flag = 1;
	for (int i = 1; i< n; i++) {
		scanf("%d%d", &xy[i].first, &xy[i].second);
		if (xy[i].first != i || xy[i].second != i + 1) {
			flag = 0;
		}
	}
	if (flag) {
		init(1, 1, n);
		long long ans = 0;
		for (int i = 1; i <= n; i++) {
			if (ask(i, n, 1, 1, n) < k)break;
			if (a[i] >= k) {
				ans += n - i + 1;
				continue;
			}
			int l = i, r = n, temp = n;
			while (l <= r) {
				int mid = (l + r) >> 1;
				if (ask(i, mid, 1, 1, n) >= k) {
					r = mid - 1;
					temp = mid;
				}else {
					l = mid + 1;
				}
			}
			ans += n - temp + 1;
		}cout << ans;
		return 0;
	}
	for (int i = 1; i< n; i++) {
		edge[xy[i].first].push_back(xy[i].second);
		st[xy[i].second][0] = xy[i].first;
		mx[xy[i].second][0] = a[xy[i].first];
	}
	for (int j = 1; j <= 20; j++) {
		for (int i = 1; i <= n; i++) {
			st[i][j] = st[st[i][j - 1]][j - 1];
			mx[i][j] = mx[i][j - 1] | mx[st[i][j - 1]][j - 1];
		}
	}
	for (int i = 1; i <= n; i++) {
		if (!st[i][0]) {
			dep[i] = 1;
			dfs(i);
		}
	}
	long long ans = 0;
	for (int i = 1; i <= n; i++) {
		int now = i;
		if (a[now] >= k) {
			ans += dep[now];
			continue;
		}
		int sum = a[now];
		for (int j = 20; j >= 0; j--) {
			if (st[now][j]) {
				if ((sum | mx[now][j]) < k) {
					sum |= mx[now][j];
					now = st[now][j];
				}
			}
		}
		ans += dep[st[now][0]];
	}
	cout << ans;
	return 0;
}
```

---

## 作者：cyrxdzj (赞：0)

### 一、思路

题中说这是一棵外向树。这意味着每一条有向路径都是从父节点指向子节点的。

我们可以发现，惊吓路径的起始节点一定是终止节点的祖先，或终止节点自己。

根据按位或运算的性质 $(a|b)\ge a$，我们可以发现，如果终止节点固定，那么起始节点在树上的深度越浅，惊吓路径的惊吓值会递增。

因此，我们可以枚举每个终止节点（记为 $v$），并使用递增方法，计算节点 $u$，使 $u$ 的深度尽可能浅，且 $u$ 到 $v$ 之间的惊吓路径的惊吓值小于 $k$。这样，$u$ 以上的节点（不包括 $u$ 自己），就是合法的起始节点。

但是，使用这个方法，在子任务 $3$ 里会空间超限，因为 $n$ 太大了。不过，子任务 $3$ 有个特殊性质，$v=u+1$。这意味着树退化成了链，且根节点为 $1$，节点按顺序连接。

因此，对于这个特殊的子任务，我们可以判断 $n$ 是否过大。如果 $n>5\times10^5$，则使用子任务 $3$ 特别程序来处理。

对于子任务 $3$，我们可以使用 ST 表来维护两个节点之间的惊吓值。按位或运算符合“可重复贡献”原则，可以使用比线段树查询速度更快的 ST 表。固定起始节点，并用二分算法计算出合法的终止节点即可。

### 二、代码

```cpp
// Problem: P6038 「ACOI2020」惊吓路径
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P6038
// Memory Limit: 128 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
//#define DEBUG
struct Edge
{
	int to,next;
}edge[1000005];
int n,k;
int a[1000005];
int fa[1000005][21],dis[1000005][21];
int depth[1000005];
int root=1;
int edge_cnt;
int head[1000005];
int t;//Max LOG
long long ans;
void add_edge(int u,int v)//新增边
{
	edge[++edge_cnt].to=v;
	edge[edge_cnt].next=head[u];
	head[u]=edge_cnt;
}
void pre_tree(int u,int f)//预处理深度和倍增需要用到的父节点数组和距离数组。
{
	depth[u]=depth[f]+1;
	for(int i=head[u];i;i=edge[i].next)
	{
		int v=edge[i].to;
		if(v==f)
		{
			continue;
		}
		for(int j=1;j<=t;j++)
		{
			fa[v][j]=fa[fa[v][j-1]][j-1];
			dis[v][j]=dis[v][j-1]|dis[fa[v][j-1]][j-1];
		}
		pre_tree(v,u);
	}
}
namespace subtask3//子任务3特别程序
{
	int n,k,t;
	int a[1000005];
	int st[1000005][21];//ST表
	int log[1000005];
	long long ans;
	void build_st()//构建ST表
	{
		for(int i=1;i<=n;i++)
		{
			st[i][0]=a[i];
		}
		for(int i=2;i<=n;i++)
		{
			log[i]=log[i/2]+1;
		}
		for(int j=1;j<=t;j++)
		{
			for(int i=1;(i+(1<<(j-1)))<=n;i++)
			{
				st[i][j]=st[i][j-1]|st[i+(1<<(j-1))][j-1];
			}
		}
	}
	int query(int l,int r)//查询
	{
		int s=log[r-l+1];
		return st[l][s]|st[r-(1<<s)+1][s];
	}
	void handle()
	{
		t=log2(n)+1;
		for(int i=1;i<=n;i++)
		{
			scanf("%d",&a[i]);
		}
		build_st();
		for(int u=1;u<=n;u++)//枚举起始节点
		{
			int l=u,r=n;
			int v=-1;
			while(l<=r)//二分算法计算终止节点
			{
				int mid=(l+r)>>1;
				if(query(u,mid)>=k)
				{
					v=mid;
					r=mid-1;
				}
				else
				{
					l=mid+1;
				}
			}
			if(v!=-1)
			{
				ans+=(long long)(n-v+1);
			}
		}
		printf("%lld\n",ans);
	}
}
int main()
{
	scanf("%d%d",&n,&k);
	if(n>500000)//判断子任务
	{
		subtask3::n=n;
		subtask3::k=k;
		subtask3::handle();
		return 0;
	}
	t=log2(n)+1;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	for(int i=1;i<n;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		add_edge(u,v);
		fa[v][0]=u;
		dis[v][0]=a[u];//需要注意dis[v][0]跟v的惊吓值没有关系，在后面的程序中需要注意。
	}
	while(fa[root][0]!=0)
	{
		root=fa[root][0];
	}
	pre_tree(root,0);
	for(int v=1;v<=n;v++)
	{
		if(a[v]>=k)//终止节点自己都可以成为一个符合题意的惊吓路径
		{
			ans+=(long long)depth[v];
		}
		else
		{
			int now=v;
			int now_dis=a[v];
			for(int j=t;j>=0;j--)//倍增
			{
				if(fa[now][j]>=1&&(now_dis|dis[now][j])<k)
				{
					now_dis|=dis[now][j];
					now=fa[now][j];
				}
			}
			ans+=(long long)(depth[now]-depth[root]);
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：yuzhechuan (赞：0)


用树上ST表维护区间或的一道简单但卡空间的毒瘤题

---

### 题解：

一种很显然的思路是枚举固定较深的$v$点，确定离他最近的符合条件的$u$点，那么从$u$开始一直到根都是与$v$满足的

也就是说我们需要区间查询“或的和”，在序列上这是一个经典的ST表问题，现在他被搬到了树上其实也只需要在遍历到每个节点时，以深度为下标更新ST表就好了，实现起来很容易

由于对于同一个$v$点，$u$与$v$之间的“或的和”是有单调性的，所以可以二分查找

于是二分复杂度$O(n\log n)$，ST表预处理$O(n\log n)$，总共$O(n\log n)$

---

以上部分复杂度已经很优秀了，包括常数

然而出题人卡了空间导致以上部分只能过5e5的点

幸好大于5e5的点有个链的性质，所以可以特殊情况特殊对待，直接上双指针，扫一遍的同时对于每个二进制位记个$cnt$人工模拟“或”的过程，以满足撤销的操作，时间复杂度是$O(n*\log a)$，空间是$O(n+\log a)$

然后这份代码即使不开O2也跑的飞快了~

---

### 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
template<class t> inline t read(t &x){
    x=0;char c=getchar();bool f=0;
    while(!isdigit(c)) f|=c=='-',c=getchar();
    while(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();
    if(f) x=-x;return  x;
}
template<class t> inline void write(t x){
    if(x<0){putchar('-'),write(-x);}
    else{if(x>9)write(x/10);putchar('0'+x%10);}
}

const int N=5e5+5;
int f[N][20],d[N],n,en,k,h[N],rt,val[N],lg[N],cnt[31],oum;
bool rtflag[N];
long long ans;

struct edge{
	int n,v;
}e[N];

void add(int x,int y){
	e[++en]=(edge){h[x],y};
	h[x]=en;
}

int que(int l,int r){ //ST表的查询
	int k=lg[r-l+1];
	return f[r][k]|f[l+(1<<k)-1][k];
}

void dfs(int x){
	f[d[x]][0]=val[x];
	for(int i=1;i<=lg[d[x]];i++) if(d[x]-(1<<i)+1>=1) //更新ST表
		f[d[x]][i]=f[d[x]][i-1]|f[d[x]-(1<<i-1)][i-1];
	int l=1,r=d[x],cur=0;
	while(l<=r){ //二分找最近的u点
		int mid=l+r>>1;
		if(que(mid,d[x])>=k) cur=mid,l=mid+1;
		else r=mid-1;
	}
	ans+=cur;
	for(int i=h[x];i;i=e[i].n){
		int y=e[i].v;
		d[y]=d[x]+1;
		dfs(y);
	}
}

void inc(int x){ //正常的或上去
	oum|=x;
	for(int i=0;i<30;i++) if(x>>i&1) cnt[i]++;
}

void dec(int x){ //或的逆操作
	for(int i=0;i<30;i++) if(x>>i&1){
		if(cnt[i]==1) oum^=1<<i;
		cnt[i]--;
	}
}

void subchain(){ //特判链的情况
	for(int i=1,pt=0;i<=n;i++){
		dec(val[i-1]);
		while(pt+1<=n&&oum<k) inc(val[++pt]);
		if(oum<k) break;
		ans+=n-pt+1;
	}
	write(ans);
}

signed main(){
	read(n);read(k);
	for(int i=1;i<=n;i++) read(val[i]);
	if(n>5e5){
		subchain();
		return 0;
	}
	for(int i=1,x,y;i<n;i++){
		read(x);read(y);
		add(x,y);
		rtflag[y]=1;
	}
	lg[2]=1;
	for(int i=2;i<=n;i++){ //小优化，预处理出log2()
		if(lg[i]) if(i*2<=n) lg[i<<1]=lg[i]+1;
		if(!lg[i]) lg[i]=lg[i-1];
	}
	for(int i=1;i<=n;i++) if(!rtflag[i]) {rt=i;break;}
	d[rt]=1;
	dfs(rt);
	write(ans);
}
```

---


# [省选联考 2020 A 卷] 树

## 题目描述

给定一棵 $n$ 个结点的有根树 $T$，结点从 $1$ 开始编号，根结点为 $1$ 号结点，每个结点有一个正整数权值 $v_i$。

设 $x$ 号结点的子树内（包含 $x$ 自身）的所有结点编号为 $c_1,c_2,\dots,c_k$，定义 $x$ 的价值为：

$
val(x)=(v_{c_1}+d(c_1,x)) \oplus (v_{c_2}+d(c_2,x)) \oplus \cdots \oplus (v_{c_k}+d(c_k, x))
$

其中 $d(x,y)$ 表示树上 $x$ 号结点与 $y$ 号结点间唯一简单路径所包含的边数，$d(x, x) = 0$。$\oplus$ 表示异或运算。

请你求出 $\sum\limits_{i=1}^n val(i)$ 的结果。


## 说明/提示

【样例解释 $1$】

$val(1)=(5+0)\oplus(4+1)\oplus(1+1)\oplus(2+2)\oplus(3+2)=3$。

$val(2)=(4+0)\oplus(2+1)\oplus(3+1) = 3$。

$val(3)=(1+0)=1$。

$val(4)=(2+0)=2$。

$val(5)=(3+0)=3$。

和为 $12$。

【数据范围】

对于 $10\%$ 的数据：$1\leq n\leq 2501$；

对于 $40\%$ 的数据：$1\leq n\leq 152501$；

另有 $20\%$ 的数据：所有 $p_i=i-1$（$2\leq i\leq n$）；

另有 $20\%$ 的数据：所有 $v_i=1$（$1\leq i\leq n$）；

对于 $100\%$ 的数据：$1\leq n,v_i \leq 525010$，$1\leq p_i\leq n$。

## 样例 #1

### 输入

```
5
5 4 1 2 3
1 1 2 2```

### 输出

```
12```

# 题解

## 作者：dengyaotriangle (赞：123)

首先，我们要求的是一个子树和状物体，那么就可以先考虑一个点，对于它的所有祖先的答案的贡献。

首先考察 $c,c+1,c+2,\cdots$ 的二进制表示。

随便选一个 $c$，就比如说 $c=3$：

那么 $c,c+1,c+2,\cdots$ 的二进制表示就是：

$$\begin{matrix}+0&=&0011\\+1&=&0100\\+2&=&0101\\+3&=&0110\\+4&=&0111\\+5&=&1000\\+6&=&1001\\+7&=&1010\\+8&=&1011\\+9&=&1100\\\cdots&\cdots&\cdots\end{matrix}$$

我们随便找一位来看，比如说第二低的位：

$$\begin{matrix}+0&=&00{\color{red}1}1\\+1&=&01{\color{red}0}0\\+2&=&01{\color{red}0}1\\+3&=&01{\color{red}1}0\\+4&=&01{\color{red}1}1\\+5&=&10{\color{red}0}0\\+6&=&10{\color{red}0}1\\+7&=&10{\color{red}1}0\\+8&=&10{\color{red}1}1\\+9&=&11{\color{red}0}0\\\cdots&\cdots&\cdots\end{matrix}$$

按顺序串起来是 $1001100110\cdots$，我们发现，这是以 $0011$ 为循环节的串。

进一步地观察上方表格其它列，我们发现，第 $k$ 低位组成的01串的循环节长度是 $2^{k+1}$，是 $\underbrace{00\cdots0}_{2^k\text{个}}\underbrace{11\cdots 1}_{2^k\text{个}}$

我们考虑对于每一位分别计算贡献。那么，根据题面，对于每一位，它对它的 $0,1,2,\cdots$ 级祖先的贡献，就依次是上面表格中的那一列的值。

而我们要求的是每一个点的异或和，所以说其实对于第 $k$ 位，就是相当于把它的第 
$$\begin{matrix}[0\times2^{k+1}+a,0\times2^{k+1}+a+2^k)\cup\\ [1\times2^{k+1}+a,1\times2^{k+1}+a+2^k)\cup\\ [2\times2^{k+1}+a,2\times 2^{k+1}+a+2^k)\cup\\\cdots\end{matrix}$$

级祖先的答案异或上 $2^k$

上面的那些区间可以很容易地根据我们之前找到的规律求出来，（循环节是 $2^{k+1}$，其中有 $2^k$ 个$1$）

而那个 $a$，代表的是一个循环节中的 $\cdots0000{\color{red}1}11\cdots$ 的那个 $\color{red}1$ 的位置。它也可以经过简单的数学推导或者看上面的表格找规律，使用位运算求得。

但怎么维护把上述那么多区间全异或上 $2^k$ 呢？一种简单的想法是使用树上差分，在第

$$\begin{matrix}
0\times2^k+a&1\times2^k+a\\2\times2^k+a&3\times2^k+a\\4\times2^k+a&5\times2^k+a\\\cdots&\cdots\end{matrix}$$

级祖先的差分数组上均异或上 $2^k$，就可以了，这样就可以保证在进入区间的时候答案异或 $2^k$，出区间时再异或回去。

但是我们有这么多的区间，树上差分依然是 $O(n^2)$ 的

但是，观察到，所有要异或 $2^k$ 的差分数组，它们的下标 $\mod 2^k$ 都一样，这就意味着，我们可以开一个新的差分数组，$s_{k,i}$，它等于所有当前dfs到的，深度 $d\mod 2^k=i$ 的所有的点的差分数组。

![](https://cdn.luogu.com.cn/upload/image_hosting/236cbrm3.png)

大概是这样（好丑）↑

那么，我们发现，我们修改的那很多的差分，就是单独地改了一个 $s_{k,a}$，这样就是 $O(1)$ 的了

但是怎么找到一个点的差分值呢？我们发现，它的差分值，就等于进入这个点的子树前的 $s_{k,d}$ （$d$为该点深度） 与出该点子树后的 $s_{k,d}$ 的异或差（其实就是异或和）

原因见下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/r20izjx8.png)

因为我们一个点的差分，就是其子树内的点对于 $s_{k,d}$ 的修改，而这样做差刚好就只算了子树内贡献，所以是对的。

所以，我们对于每一个节点的每一位，都可以 $O(1)$ 地计算贡献和差分数组，所以总复杂度 $O(n\log n)$

上述题解提供的是基础思路，具体的计算和实现可以看代码。

本做法因为只使用了树上差分而没有使用高级数据结构，所以常数很小。

```cpp
#include<bits/stdc++.h>
using namespace std;
//dengyaotriangle!

const int maxl=21;
const int maxn=1<<maxl;

int n;
unsigned a[maxn];
vector<int> adj[maxn];
unsigned w[maxl][maxn];

unsigned long long tans=0;

unsigned dfs(int u,unsigned d){
    unsigned ans=a[u];
    for(int j=0;j<maxl;j++)w[j][(d+a[u])&((1u<<j)-1u)]^=1u<<j;
    for(int j=0;j<maxl;j++)ans^=w[j][d&((1u<<j)-1u)];
    for(int i=0;i<adj[u].size();i++){
        int v=adj[u][i];
        ans^=dfs(v,d+1);
    }
    for(int j=0;j<maxl;j++)ans^=w[j][d&((1u<<j)-1u)];
    //cerr<<u<<' '<<ans<<endl;
    tans+=ans;
    return ans;
}

int main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=2;i<=n;i++){
        int f;cin>>f;
        adj[f].push_back(i);
    }
    dfs(1,0);
    cout<<tans;
    return 0;
}
```

---

## 作者：lindongli2004 (赞：37)

### 题目大意

给定一棵以1为根的有根树，记 $d(u,v)$ 为 $u\to v$ 简单路径上的边数， $w(u)$ 为点 $u$ 的权值，$val(u)=\sum_{v}d(u,v)+w(v)$。其中， $v$ 是 $u$ 的子树内的点（包括点 $u$ ）。求 $\sum_{i=1}^{n}val(i)$。

### 解题报告

模拟这个过程，在 dfs 中，我们发现每次都要将子树内的点的 w 值整体+1，再求子树内的异或和。所以，我们需要一种工具，支持子树加一、插入一个数和查询子树异或和这三种操作。

解决位运算问题，第一要想到的是01tire。便于实现，我们先把每个点从低位到高位建一棵01tire。那么每次的操作就是：dfs 孩子，将孩子的01tire合并，再把合并后的 01tire 整体 +1，最后插入 $w(x)$，整体求值。

01tire 的合并和线段树合并一样，把每个点的权值对应相加即可，复杂度 $O(log \; W)$。

01tire 的整体 +1，就是把点 x 的左儿子和右儿子同时 +1，那么左儿子(0)加一就变成了右儿子。这里，我们每个点记一个结束标记 ed。如果点 x 有结束标记，那么左儿子加一后变成的右儿子，也应该补上一个结束标记。注意：如果点 x 原先没有左儿子，应该新建一个点进行操作。而右儿子整体+1就变成了左儿子，再递归处理即可，复杂度 $O(log \;W)$。（code below）

```cpp
void add1(int x){
	if(!x)return;
	swap(tr[x].c[0],tr[x].c[1]);
	if(tr[x].ed && !tr[x].c[1])tr[x].c[1]=++cur;
	tr[tr[x].c[1]].ed^=tr[x].ed;
    	tr[tr[x].c[1]].cnt^=tr[x].ed; tr[x].ed=0;
	add1(tr[x].c[0]); updata(x);
}
```

01tire的插入即为普通的插入，复杂度$O(log \;W)$

最后是updata，一个点的权值，是左儿子的权值乘2异或右儿子的权值乘2，因为右儿子代表最低位为1，如果右儿子子树内有奇数的串，那么还要把这个点的权值加一，所以还要记一个 cnt 代表子树内串的个数的奇偶性。(code below)

```
void updata(int x){
	int ls=tr[x].c[0],rs=tr[x].c[1];
	tr[x].cnt=tr[x].ed^tr[ls].cnt^tr[rs].cnt;
	tr[x].val=((tr[ls].val<<1)^((tr[rs].val<<1)|tr[rs].cnt));
}
```

考场上，我做这道题的心路历程是艰难而漫长的，我会写在代码的下面，有兴趣的oier可以了解一下qwq。

考场代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N=552020;
long long ans;
int n,tot,cur,v[N],w[N],rt[N];
struct trie{int cnt,val,ed,c[2];}tr[N*27];
struct Edge{int to,next;}e[N];
void add(int x,int y){
	e[++tot].to=y; e[tot].next=v[x]; v[x]=tot;
}
void updata(int x){
	int ls=tr[x].c[0],rs=tr[x].c[1];
	tr[x].cnt=tr[x].ed^tr[ls].cnt^tr[rs].cnt;
	tr[x].val=((tr[ls].val<<1)^((tr[rs].val<<1)|tr[rs].cnt));
}
void ins(int &x,int y){
	if(!x)x=++cur;
	if(!y){tr[x].ed^=1;tr[x].cnt^=1;return;}
	ins(tr[x].c[y&1],y>>1); updata(x);
}
void add1(int x){
	if(!x)return;
	swap(tr[x].c[0],tr[x].c[1]);
	if(tr[x].ed && !tr[x].c[1])tr[x].c[1]=++cur;
	tr[tr[x].c[1]].ed^=tr[x].ed; tr[tr[x].c[1]].cnt^=tr[x].ed; tr[x].ed=0;
	add1(tr[x].c[0]); updata(x);
}
int merge(int x,int y){
	if(!x || !y)return x|y;
	tr[x].ed^=tr[y].ed;
	tr[x].cnt^=tr[y].cnt;
	tr[x].val^=tr[y].val;
	tr[x].c[0]=merge(tr[x].c[0],tr[y].c[0]);
	tr[x].c[1]=merge(tr[x].c[1],tr[y].c[1]);
	return x;
}
void dfs(int x){
	ins(rt[x],w[x]);
	for(int p=v[x];p;p=e[p].next){
		int kp=e[p].to; dfs(kp);
		add1(rt[kp]);// cout<<"+"<<kp<<":"<<tr[rt[kp]].val<<endl;
		rt[x]=merge(rt[x],rt[kp]);
	} ans+=1ll*tr[rt[x]].val;
//	cout<<x<<"val="<<tr[rt[x]].val<<endl;
}
int read(){
	int x=0,f=1; char ch=getchar();
	while(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0' && ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int main()
{
	freopen("tree.in","r",stdin);
	freopen("tree.out","w",stdout);
	n=read();
	for(int i=1;i<=n;i++)w[i]=read();
	for(int i=2;i<=n;i++)add(read(),i);
	dfs(1); printf("%lld",ans);
	fclose(stdin); fclose(stdout);
	return 0;
}
/*
5
1 1 1 4 1 
1 1 3 4 

3
1 4 1
1 2

*/
```

### 心路历程

Day2，看完题觉得T1的30pts，T2的10pts，T3的50pts比较容易。最后觉得树的问题比较有趣，就开了T2。终于，在9:20的时候想到做法，10:00就过了大样例，但是，一拍起来，不管大数据小数据都出错~~（CCF垃圾大样例）~~。于是，我就进入了艰难的调试，从10:00到11:00，再到12:00......在十二点，我知道时间所剩不多了，心想：写写 T3 暴力都交暴力，T2 弃了算了。但我想起了我的诺言：“我lindongli2004永不放弃，我lindongli2004永不认输 **。** ”于是，我在草稿纸上疯狂地画着，调着。草稿纸画满了，再用准考证的背面，汗水汇成条条小溪留下。最后，我加了个结束标记，终于在考试结束前15min，ffcc.bat 跑得飞快——我过了！一看时间，T3暴力没法打了，就敲了个m=n-1的情况，没想到还有5pts。如果省选像往常5个小时，我想T3的50pts还是应该能拿到的吧。

现在回想当成在考场上的抉择，真的不寒而栗——如果T2没调出来会是什么结果？我当时真的没想过。可能这就是青春吧，爱拼才会赢。（虽然还是无法摆脱我菜的事实）

额，最后插一句，能不能有大神教教我，前两段“永不认输”后面的那个句号是放在引号内还是引号外？qwq

---

## 作者：AK_Dream (赞：36)

### 题解
很显然的想法是考虑如何让父亲节点利用儿子的$val$信息从而快速计算出父亲的$val$

考场上首先想的是如何处理这个所有点的点权+1后异或和的变化

我们按二进制位来考虑

假设现在有一个数，二进制末三位为$011$，那么给它+1之后变成$100$，相当于它的二进制第1位，第2位，第3位都取反了

然后很容易发现一个规律，如果一个数字 $a \equiv 2^k-1 \mod 2^k$，那么a+1之后第$k+1$位就会取反

那么我们可以把当前子树内所有点的权值装进$\log n$个桶里，$buc[i][j]$表示当前权值(即点权+当前深度)$\ \equiv i \mod 2^j$的点有多少个

为了方便，我们设$v_i=c_i+d(i,1)$，即第$v_i$是自己的权值+自己到根的距离，把这个权值放进上面的桶里面

那么假设我们在计算$val_x$，那么子树中所有点现在的点权应该是$v_i-dis(x,1)$，我们要对于每个$j$，找出有多少个点满足$v_i-dis(x,1)-1 \equiv 2^j - 1\mod 2^j$

化简一下就是$v_i \equiv dis(x,1) \mod 2^j$

所以我们对于每个$j$找到$buc[dis(x,1)\bmod 2^j][j]$，那么第$j+1$位实际上要取反这么多次 这个就很好处理了

整理一下思路：首先把$val_x$赋为所有儿子$val$的异或和，然后对于每个$j$找到子树中的所有点(不包括自己)有多少个点满足$v_i\equiv dis(x,1)\mod 2^j$，然后如果是奇数个就把第$j+1$位取反，否则不变
最后把$val_x$异或上$x$的点权

最后关于怎么维护这个桶，用树上启发式合并啊 

时间复杂度$O(n\log^2 n)$，一个是启发式合并的log，另一个是枚举二进制位的log

不过常数很小，洛谷上最慢点跑了1.3s，~~相信少爷机上更快~~

代码体感是挺好写的

#### 考场上桶开小了导致100pts->30pts 心态爆炸

```cpp
#include <bits/stdc++.h>
#define N 530005
using namespace std;

inline void read(int &num) {
	int x = 0, f = 1; char ch = getchar();
	for (; ch > '9' || ch < '0'; ch = getchar()) if (ch == '-') f = -1;
	for (; ch <= '9' && ch >= '0'; ch = getchar()) x = (x << 3) + (x << 1) + (ch ^ '0');
	num = x * f;
}

int n, a[N];
int head[N], pre[N<<1], to[N<<1], sz;
int d[N], siz[N], son[N], fa[N];
int buc[N<<1][22], ans[N]; //开两倍大！！！
int two[22];
long long Ans;

inline void addedge(int u, int v) {
	pre[++sz] = head[u]; head[u] = sz; to[sz] = v;
	pre[++sz] = head[v]; head[v] = sz; to[sz] = u;
}

void dfs1(int x) {
	siz[x] = 1; 
	for (int i = head[x]; i; i = pre[i]) {
		int y = to[i];
		if (y == fa[x]) continue;
		fa[y] = x; d[y] = d[x] + 1;
		dfs1(y);
		siz[x] += siz[y];
		if (!son[x] || siz[son[x]] < siz[y]) son[x] = y;
	}
}

void calc(int x, int tp) {
	for (int i = 0; i <= 21; i++) {
		buc[a[x]&two[i]][i] += tp;
	}
	for (int i = head[x]; i; i = pre[i]) {
		if (to[i] != fa[x]) calc(to[i], tp);
	}
}

void getans(int x) {
	for (int i = head[x]; i; i = pre[i]) {
		if (to[i] != fa[x]) ans[x] ^= ans[to[i]];
	}
	for (int i = 0; i <= 21; i++) {
		ans[x] ^= ((buc[d[x]&two[i]][i] & 1) << i);
	}
	ans[x] ^= (a[x] - d[x]);
}

void dfs(int x, int cl) {
	for (int i = head[x]; i; i = pre[i]) {
		if (to[i] == fa[x] || to[i] == son[x]) continue;
		dfs(to[i], 1);
	}
	if (son[x]) dfs(son[x], 0);
	for (int i = head[x]; i; i = pre[i]) {
		if (to[i] == fa[x] || to[i] == son[x]) continue;
		calc(to[i], 1);
	}
	getans(x);
	if (cl) {
		for (int i = head[x]; i; i = pre[i]) {
			if (to[i] == fa[x]) continue;
			calc(to[i], -1);
		}
	} else {
		for (int i = 0; i <= 21; i++) {
			buc[a[x]&two[i]][i]++;
		}
	}
}

int main() {
	read(n);
	for (int i = 1; i <= n; i++) read(a[i]);
	for (int i = 2, x; i <= n; i++) {
		read(x); addedge(i, x);
	}
	for (int i = 0; i <= 21; i++) two[i] = (1 << i) - 1;
	dfs1(1); 
	for (int i = 1; i <= n; i++) a[i] += d[i];
	dfs(1, 0);
	for (int i = 1; i <= n; i++) {
		Ans += ans[i];
	}
	printf("%lld\n", Ans);
	return 0;
}

```


---

## 作者：FZzzz (赞：26)

省选救命题~~虽然大概率救不回来~~。

考虑根据每个点的儿子推出他的值。然后如果我们用一个数据结构去维护所有的儿子，那么容易发现我们需要支持四个操作：
- 插入
- 合并
- 全局加一
- 求全局异或和

~~然后你就可以去看[这篇题解](https://www.luogu.com.cn/blog/0123456-3456789/solution-p6018)了。~~

凭借直接我们知道肯定是用 trie 去维护，然后你发现你不会第三个操作。

对于一个数来说加一就是把他最低位的一堆一变成零然后把最低的零变成一对吧。

所以你从低到高维护 trie，然后就交换一下左右儿子并在左儿子递归修改即可。

复杂度 1log，代码可以参考那篇题解。

**upd**：关于这个做法的复杂度证明：因为值域 $O(n)$，所以线段树合并的复杂度证明并不会被这个加一破坏掉，每个数还是最多被插一次。

所以我是被卡常了……哭。

**upd**：代码：
```cpp
#include<algorithm>
#include<vector>
#include<cctype>
#include<cstdio>
using namespace std;
inline int readint(){
	int x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)&&c!='-') c=getchar();
	if(c=='-'){
		f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=525010+5;
int n,v[maxn];
vector<int> ch[maxn];
struct node{
	int d;
	node* ch[2];
	int s,v;
	void pushup(){
		s=v=0;
		if(ch[0]){
			s+=ch[0]->s;
			v^=ch[0]->v;
		}
		if(ch[1]){
			s+=ch[1]->s;
			v^=(ch[1]->s&1)<<d^ch[1]->v;
		}
	}
	node(int d):d(d),s(0),v(0){
		ch[0]=ch[1]=0;
	}
	void insert(int x){
		if(d>25){
			s++;
			return;
		}
		if(x>>d&1){
			if(!ch[1]) ch[1]=new node(d+1);
			ch[1]->insert(x);
		}
		else{
			if(!ch[0]) ch[0]=new node(d+1);
			ch[0]->insert(x);
		}
		pushup();
	}
	void modify(){
		swap(ch[0],ch[1]);
		if(ch[0]) ch[0]->modify();
		pushup();
	}
};
node* merge(node* a,node* b){
	if(!a) return b;
	if(!b) return a;
	a->s+=b->s;
	a->v^=b->v;
	a->ch[0]=merge(a->ch[0],b->ch[0]);
	a->ch[1]=merge(a->ch[1],b->ch[1]);
	delete b;
	return a;
}
node* rt[maxn];
long long ans=0;
void dfs(int u){
	rt[u]=new node(0);
	for(int i=0;i<(int)ch[u].size();i++){
		int v=ch[u][i];
		dfs(v);
		rt[u]=merge(rt[u],rt[v]);
	}
	rt[u]->modify();
	rt[u]->insert(v[u]);
	ans+=rt[u]->v;
}
int main(){
	freopen("tree.in","r",stdin);
	freopen("tree.out","w",stdout);
	n=readint();
	for(int i=1;i<=n;i++) v[i]=readint();
	for(int i=2;i<=n;i++) ch[readint()].push_back(i);
	dfs(1);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：ShuYuMo (赞：15)

[出自我的博客](https://shuyumo2003.github.io/)
## 全局加一（维护异或和）

这个不太好表述啊~   	
`01-trie数` 是指字符集为 $\{0,1\}$ 的 Trie 树。 	
`01-trie树`可以用来维护一堆数字的异或和，支持修改（删除+重新插入），和全部维护值加一。  	

<!-- more -->

如果要维护异或和，需要按值从低位到高位建立`trie`。	

**一个约定**：文中说当前节点**往上**指当前节点到根这条路径，当前节点**往下**指当前结点的子树。	

### 插入&删除
如果要维护异或和，我们只需要知道某一位上`0`和`1`个数的奇偶性即可，也就是对于数字`1`来说，当且仅当这一位上数字`1`的个数为奇数时，这一位上的数字才是`1`。

对于每一个节点，我们需要记录以下三个量：
 - `ch[o][0/1]`指节点`o`的两个儿子，`ch[o][0]`指下一位是`0`，同理`ch[o][1]`指下一位是`0`。
 - `w[o]`指节点`o`到其父亲节点这条边上数值的数量（权值）。每插入一个数字`x`，`x`二进制拆分后在 `trie`树上 路径的权值都会`+1`。
 - `xorv[o]`指以`o`为根的子树维护的异或和。

具体维护结点的代码如下所示。

```cpp
void maintain(int o){
		w[o] = xorv[o] = 0;
		if(ch[o][0]){ w[o] += w[ch[o][0]]; xorv[o] ^=  xorv[ch[o][0]] << 1; }
		if(ch[o][1]){ w[o] += w[ch[o][1]]; xorv[o] ^= (xorv[ch[o][1]] << 1) | (w[ch[o][1]] & 1); }
		//w[o] = w[o] & 1;
    	//只需知道奇偶性即可，不需要具体的值。当然这句话删掉也可以，因为上文就只利用了他的奇偶性。
	}
```



插入和删除的代码非常相似。 	

需要注意的地方就是：

- 这里的`MAXH`指`trie`的深度，也就是强制让每一个叶子节点到根的距离为`MAXH`。对于一些比较小的值，可能有时候不需要建立这么深（例如：如果插入数字`4`，分解成二进制后为`100`， 从根开始插入`001`这三位即可），但是我们强制插入`MAXH`位。这样做的目的是为了便于全局`+1`时处理进位。例如：如果原数字是`3`（`11`），++之后变成`4`（`100`），如果当初插入`3`时只插入了`2`位，那这里的进位就没了。

- 插入和删除，只需要修改叶子节点的`w[]`即可，在回溯的过程中一路维护即可。

```cpp
namespace trie{
	const int MAXH = 21; 
	int ch[_ * (MAXH + 1)][2], w[_ * (MAXH + 1)], xorv[_ * (MAXH + 1)];
	int tot = 0;
	int mknode(){ ++tot; ch[tot][1] = ch[tot][0] = w[tot] = xorv[tot] = 0; return tot;}
	void maintain(int o){
		w[o] = xorv[o] = 0;
		if(ch[o][0]){ w[o] += w[ch[o][0]]; xorv[o] ^=  xorv[ch[o][0]] << 1; }
		if(ch[o][1]){ w[o] += w[ch[o][1]]; xorv[o] ^= (xorv[ch[o][1]] << 1) | (w[ch[o][1]] & 1); }
		w[o] = w[o] & 1;
	}
	void insert(int &o, int x, int dp){
		if(!o) o = mknode();
		if(dp > MAXH) return (void)(w[o] ++);
		insert(ch[o][ x&1 ], x >> 1, dp + 1);
		maintain(o);
	}
}
```

### 全局加一

```cpp
void addall(int o){
	swap(ch[o][0], ch[o][1]);
	if(ch[o][0]) addall(ch[o][0]);
	maintain(o);
}
```

不知道你能不能直接看懂呢？

我们思考一下二进制意义下`+1`是如何操作的。

我们只需要从低位到高位开始找第一个出现的`0`，把它变成`1`，然后这个位置后面的`1`都变成`0`即可。

下面给出几个例子感受一下。（括号内的数字表示其对应的十进制数字）

```cpp
1000  (10)   + 1 = 1001   (11)
10011 (19)   + 1 = 10100  (20)
11111 (31)   + 1 = 100000 (32)
10101 (21)   + 1 = 10110  (22)
100000000111111(16447) + 1 = 100000001000000(16448)
```

回顾一下`w[o]`的定义：`w[o]`指节点`o`到其父亲节点这条边上数值的数量（权值）。

有没有感觉这个定义有点怪呢？如果在父亲结点存储到两个儿子的这条边的边权也许会更接近于习惯。但是在这里，在交换左右儿子的时候，在儿子结点存储到父亲这条边的距离，显然更加方便。

## `01-trie`合并

指的是将上述的两个`01-trie`进行合并，同时合并维护的信息。

我来编写此文字的初衷就是，合并`01-trie`的文字好像比较少？其实合并`01-trie`和合并线段树的思路非常相似。可以搜索`合并线段树`来学习如何合并`01-trie`。

其实合并`trie`非常简单，就是考虑一下我们有一个`int marge(int a, int b)`函数，这个函数传入两个`trie`树位于同一相对位置的结点编号，然后合并完成后返回合并完成的结点编号。

考虑怎么实现？

```cpp
	int marge(int a, int b){
		if(!a) return b; // 如果a没有这个位置上的结点，返回b
		if(!b) return a; // 如果b没有这个位置上的结点，返回a
        // 如果a, b都健在，那就把b的信息合并到a上，然后递归操作。
        // 如果需要的合并是将a， b合并到一棵新树上，这里可以新建结点，然后进行合并。这里的代码实现仅仅是将b的信息合并到a上。
		w[a] = w[a] + w[b];
		xorv[a] ^= xorv[b];
//不要使用maintain，maintain是根据a的两个儿子的数值进行信息合并，而这里需要a b两个节点进行信息合并 
		ch[a][0] = marge(ch[a][0], ch[b][0]);
		ch[a][1] = marge(ch[a][1], ch[b][1]);
		return a;
	}
```

顺便说一句，其实`trie`都可以合并，换句话说，`trie`合并不仅仅限于`01-trie`。
```cpp
int n;
int V[_];
int debug  = 0;
int cnt = 0; 
namespace trie{
	const int MAXH = 21; 
	int ch[_ * (MAXH + 1)][2], w[_ * (MAXH + 1)], xorv[_ * (MAXH + 1)];
	int tot = 0;
	int mknode(){ ++tot; ch[tot][1] = ch[tot][0] = w[tot] = xorv[tot] = 0; return tot;}
	void maintain(int o){
		w[o] = xorv[o] = 0;
		if(ch[o][0]){ w[o] += w[ch[o][0]]; xorv[o] ^=  xorv[ch[o][0]] << 1; }
		if(ch[o][1]){ w[o] += w[ch[o][1]]; xorv[o] ^= (xorv[ch[o][1]] << 1) | (w[ch[o][1]] & 1); }
		w[o] = w[o] & 1;
	}
	void insert(int &o, int x, int dp){
		if(!o) o = mknode();
		if(dp > MAXH) return (void)(w[o] ++);
		insert(ch[o][ x&1 ], x >> 1, dp + 1);
		maintain(o);
	}
//	#define errnum 90189
	int marge(int a, int b){
//		if(debug == 90189) cerr << "a = " << a << " b = "  << b << endl;
		cnt++;
		if(!a) return b;
		if(!b) return a;
		w[a] = w[a] + w[b];
		xorv[a] ^= xorv[b];
//不要使用maintain，maintain是根据a的两个儿子的数值进行信息合并，而这里需要a b两个节点进行信息合并 
		ch[a][0] = marge(ch[a][0], ch[b][0]);
		ch[a][1] = marge(ch[a][1], ch[b][1]);
		return a;
	}
	void addall(int o){
		swap(ch[o][0], ch[o][1]);
		if(ch[o][0]) addall(ch[o][0]);
		maintain(o);
	}
}
int rt[_];
long long Ans = 0;

vector<int>E[_];

void dfs0(int o){
	for(int i = 0;i < E[o].size();i++){
		int node = E[o][i];
		dfs0(node);
		rt[o] = trie::marge(rt[o], rt[node]);
	}
	trie::addall(rt[o]);
	trie::insert(rt[o], V[o], 0);
	Ans += trie::xorv[rt[o]];
}


int main()
{
#ifdef LOCAL_JUDGE
    
//    freopen("out.txt", "w", stdout);
#endif
//	freopen("in.in", "r", stdin);
    clock_t c1 = clock();

    n = read();
    for(int i = 1;i <= n;i++) V[i] = read();
    for(int i = 2;i <= n;i++) E[read()].push_back(i);
	
	dfs0(1); 

	printf("%lld", Ans);
	
    std::cerr << "\n\nTime:  " << clock() - c1 << "  ms" << std::endl;
	return 0;
}
```

---

## 作者：摸鱼酱 (赞：9)

[P6623 [省选联考 2020 A 卷] 树](https://www.luogu.com.cn/problem/P6623)

给定一棵树上每个结点的权值 $v_i$ ，定义 $val_u$ 为 $u$ 的子树（含 $u$ ）内的结点 $c_i$ 的 $v_{c_i}+d(c_i,u)$ 的异或和。求 $\sum\limits_{i=1}^nval(i)$ 。

首先很明显是从下往上递推，考虑怎么从儿子结点转移过来。

#### Part 1 传递答案

假设儿子 $v$ 的答案 $val_v=a_1\oplus a_2...\oplus a_k$ ，我们需要求 $val_v'=(a_1+1)\oplus (a_2+1)...\oplus (a_k+1)$的值。

因为是异或操作，想到使用 01Trie ，那么像常规 01Tire 一样记录每个结点被经过的次数 $cnt_r$ 。

过程中统计一下对应的 01Trie 里每一层里 1 的个数，就可以得到这一个点的答案了。

而由于由 $val_v$ 求 $val_v'$ 相当于给 01Trie 里的每个元素都 +1 ，那就把原数从低位到高位加入 01Trie ，都 +1 的话显然是影响到了当前末尾是 1 的数，它们都变成了 0 ，所以我们 **交换0/1儿子的编号**，不去改变对应的 $cnt$ 。

但是交换第一层的 01 儿子之后，想到后面如果有形如 "...11" 这样以若干个二进制 1 结尾的数，则还应该继续一路交换下去。注意交换之后也要修改一层内 1 的个数方便下一步计算。

显然要修改 $\log$ 次，所以这个操作是 $O(\log n)$ 的。

#### Part 2 统计答案

有了上面计算 $val_v'$ 的方法，需要考虑的就是怎么统计父节点 $u$ 的答案了。

先退一步想，可以暴力地对于每一个结点，都维护一棵 01Trie，每次把儿子的所有值 +1 插入，再把自己的 $v_i$ 插入统计每一层 1 的个数计算答案。

考虑优化这个过程，上面讲到了如果儿子结点已经建好了 01Trie ，怎么快速地得到所有元素 +1 后的 01Trie。那么我们只需要 **合并** 起来儿子结点的 01Trie ，再插入该节点的 $v_u$ ，就得到了它所对应的 01Trie。

考虑像线段树合并一样，合并两棵 01Trie ，只需要沿着根节点递归左右儿子，直到其中一棵没有对应结点就停止。代码长这样：

```cpp
int merge(int r1,int r2){
	if(!r1||!r2)return r1|r2;
	cnt[r1]+=cnt[r2];
	c[r1][0]=merge(c[r1][0],c[r2][0]);
	c[r1][1]=merge(c[r1][1],c[r2][1]);
	return r1;
}
```

这样做看起来是很暴力的。那就来稍微看一下时间复杂度的问题。

只有两棵 Trie 里都有一样的元素 $a$ ，它才会每次合并贡献 $\log$ 的时间复杂度。

假设它出现了 $x$ 次，那就会在至多 $x$ 次合并里同时在两棵树里出现，对应的合并次数是 $\sum x=n$ 次，总时间复杂度是 $O(n\log n)$ 。

于是就可以写这道题了。dfs时每个节点建新 Trie ，和子节点合并，退出时执行 Part1 里的修改操作，递归回去即可。

[完整代码Link](https://www.luogu.com.cn/paste/i3nyjigf)



---

## 作者：Lskkkno1 (赞：6)


-   [P6623 [省选联考 2020 A 卷] 树](https://www.luogu.com.cn/problem/P6623)

### 题目描述

给定一棵树，每一个点带权 $v_i$。


每一个点的答案为其子树内节点"点权加距离"的异或和。

求所有点答案的和。

### 做法

把每一位拆开来考虑贡献。

考虑每一个点对其祖先的贡献，发现产生贡献的点是若干段深度连续的区间。

举个例子：

节点点 $u$ 深度为 $16$，权值为 $0$，考虑其第二进制位上第二位（$2^2 = 4$）对其祖先的贡献。

只有深度在 $[1,4] \bigcup [9,12]$ 的节点 $v$ 会受到节点 $u$ 的影响。

形式化来讲，只有深度 $d$ 在模 $2^3 = 8$ 意义下属于 $ [1, 4]$ 的节点 $v$ 会受到节点 $u$ 的影响。

上面举的是一个特殊的例子，来个更加形式化的表述吧。

考虑第 $b$ 位，对于一个点 $u$，它的深度为 $d_u$，思考它哪些些深度 $d_v$ 会产生贡献。
$$
2^b \le v_u + d_u - d_v < 2^{b + 1}
$$
解个不等式就能知道深度 $d_v$ 的区间了。

发现这个性质就好办了，分位考虑后模意义下修改的是一段区间，用树状数组做。

要求的点在子树内，用树差分做。

总复杂度 $O(n \log^2 n)$。

洛谷评测机太慢需要开 `O2` 才能通过。

### 后记

开考前看见考试包里有个题叫 `tree`，我就觉得我要翻盘了。

开场搞这题，后面确实切掉了。

但是第一题这简单题怎么就我没切啊。。。

退役了退役了。

### 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 525015;

int n;
int fa[N], val[N];
int head[N], nex[N], to[N], ecnt;
int full[21], is[N][21];

inline int read() {
    int x = 0; char ch = getchar();
    while(!isdigit(ch)) ch = getchar();
    while(isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();
    return x;
}
inline void addE(int u, int v) {
    to[++ecnt] = v;
    nex[ecnt] = head[u], head[u] = ecnt;
}

struct BIT {
#define lowbit(x) (x & -x)
    int upp;
    vector<int> c;
    void init(int upLim) {
        upp = upLim;
        c.resize(upLim);
    }
    void update(int p) {
        if(!p) return c[0] ^= 1, void();
        for(int i = p; i < upp; i += lowbit(i))
            c[i] ^= 1;
    }
    int xorSum(int p) {
        int res = c[0];
        for(int i = p; i; i -= lowbit(i))
            res ^= c[i];
        return res;
    }
#undef lowbit
} tr[21];

inline void update(int b, int x, int d) {
    int l = ((1 << b) - x + d) & full[b], r = ((1 << (b + 1)) - x + d) & full[b];
    if(l < r) {
        tr[b].update(l), tr[b].update(r);
    } else {
        tr[b].update(0), tr[b].update(r), tr[b].update(l);
    }
}
inline int calc(int b, int d) { return tr[b].xorSum(d & full[b]); }

long long ans;
void dfs(int u, int dep) {
    for(int b = 0; b <= 20; ++b)
        is[u][b] ^= calc(b, dep);
    for(int i = head[u]; i; i = nex[i])
        dfs(to[i], dep - 1);
    int res = 0;
    for(int b = 0; b <= 20; ++b) {
        update(b, val[u], dep);
        is[u][b] ^= calc(b, dep);
        if(is[u][b]) res += 1 << b;
        ans += is[u][b] ? 1 << b : 0;
    }
}

int main() {
    n = read();
    for(int i = 1; i <= n; ++i)
        val[i] = read();
    for(int i = 2; i <= n; ++i) {
        fa[i] = read();
        addE(fa[i], i);
    }
    for(int b = 0; b <= 20; ++b)
        full[b] = (1 << (b + 1)) - 1;
    for(int b = 0; b <= 20; ++b)
        tr[b].init(1 << (b + 1));
    dfs(1, n);
    printf("%lld\n", ans);
    return 0;
}
```



---

## 作者：gyh20 (赞：5)

一个奇怪的 $O(n\log^3(n+v))$ 的做法，但在 CCF 的机子上可以过！

但我数组就开小了那么一点点。。。。

言归正传，做到和的异或的题，我想到的第一件事：桶（还是太菜了）

对于第 $i$ 位，所有数在模 $2^{i+1}$ 下大于等于 $2^i$ 的数在第 $i$ 位上有值。

也就是说，我们可以按位考虑，看每一位的子树里面有多少得到的值在模 $2^{i+1}$ 意义下大于等于 $2^i$。

我们可以先用一次树上差分，将 $v_i+=dep_i$，那么对于 $j$ 统计的结果，就是 $v_i-dep_j$。

如果我们按位考虑，将所有 $v_i$ 对 $2^{i+1}$ 取模，塞入一个桶，那么最后求的就是减去 $dep_j$ （当前统计的点）在 $2^i\sim2^{i+1}-1$ 之内的数，令 $l=2^i,r=2^{i+1-1}$，如果我们把  $l$ 和 $r$ 都加上 $dep_j$，那么就变成了一个区间求和！（但有可能是一段左区间加右区间）

也就是说，我们只要知道子树内所有的点值的桶的树状数组即可。

然后，这个东西不是很熟悉吗？

DSU！

我们可以直接继承重儿子的树状数组，就可以完美解决了！

总复杂度：按位+DSU+树状数组=$O(n\log^3(n+v))=$ 差不多可过。

再加一些技巧&卡常：

DSU 清空时如果子树大小过大可以直接暴力清空树状数组，常数小很多。

树状数组因为在权值模之后做，所以下标一定要加一！

因为是位运算，所以千万不要用 %，常数过大！

其实这种方法可以加边权。。。

loj ac代码：

```cpp
#include<bits/stdc++.h>
#define re register
using namespace std;
int n,v[2100002],siz[2100002],cnt,c[2100002],son[2100002],head[2100002],dep[2100002],mx[2100002],sum,a[2100002],fa[2100002];
long long ans,dps;
struct edge{
	int to,next;
}e[2100002];
const int Mxdt=500000;	//单次大小 
inline char gc(){
	static char buf[Mxdt],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,Mxdt,stdin),p1==p2)?EOF:*p1++;
}
inline int read(){
	re int t=0;re char v=gc();
	while(v<'0')v=gc();
	while(v>='0')t=(t<<3)+(t<<1)+v-48,v=gc();
	return t;
}
inline void add(re int x,re int y){
	e[++cnt]=(edge){y,head[x]};
	head[x]=cnt;
}
inline void dfs1(re int x){
	siz[x]=1;
	for(re int i=head[x];i;i=e[i].next){fa[e[i].to]=x;
	dep[e[i].to]=dep[x]+1,dfs1(e[i].to),siz[x]+=siz[e[i].to];if(siz[e[i].to]>siz[son[x]])son[x]=e[i].to;mx[x]=max(mx[x],mx[e[i].to]);}
	mx[x]=max(mx[x],v[x]+dep[x]);dps+=dep[x];
}
inline void add(re int x,re int y,re int sz){sum+=y;++x;for(;x<=sz;x+=x&(-x))c[x]+=y;}
inline int ask(re int x){
	re int sum=0;++x;
	for(;x;x-=x&(-x))sum+=c[x];
	return sum;
}
inline void get(re int x,re int y){
	add(v[x]&((1<<(y+1))-1),1,(1<<y+1));
	for(re int i=head[x];i;i=e[i].next)get(e[i].to,y);
}
inline void clear(re int x,re int y){
	add(v[x]&((1<<(y+1))-1),-1,(1<<y+1));
	for(re int i=head[x];i;i=e[i].next)clear(e[i].to,y);
}
inline void dfs(re int x,re int y,re int z){
	for(re int i=head[x];i;i=e[i].next)if(e[i].to^son[x])dfs(e[i].to,1,z);
	if(son[x])dfs(son[x],0,z);
	for(re int i=head[x];i;i=e[i].next)if(e[i].to^son[x])get(e[i].to,z);
	add(v[x]&((1<<(z+1))-1),1,(1<<z+1));
	re int l=((1<<z)+dep[x])&((1<<z+1)-1),r=((1<<z+1)-1+dep[x])&((1<<z+1)-1);
	if(l<=r)ans+=(1<<z)*((ask(r)-ask(l-1))&1);
	else ans+=(1<<z)*((ask(r)+sum-ask(l-1))&1);
	if(y){
	if(1ll*siz[x]*z<=(1ll<<z)){
	add(v[x]&((1<<(z+1))-1),-1,(1<<z+1));
	for(re int i=head[x];i;i=e[i].next)clear(e[i].to,z);}
	else {for(re int i=1;i<=(1<<z+1);++i)c[i]=0;sum=0;
	}}
}
inline void dp(re int x,re int y,re int z){
	if(!x)return;
	a[x]^=(y+z);
	dp(fa[x],y,z+1);
} 
int main(){
//	freopen("tree.in","r",stdin);
//	freopen("tree.out","w",stdout);
	n=read();
	for(re int i=1;i<=n;++i)v[i]=read();
	for(re int i=2;i<=n;++i)add(read(),i);
	dep[1]=1;dfs1(1);
	if(dps<=5e7){
	for(re int i=1;i<=n;++i)dp(i,v[i],0);
	for(re int i=1;i<=n;++i)(ans+=a[i]);
	return printf("%lld",ans),0;
	}
	for(re int i=1;i<=n;++i)v[i]+=dep[i];
	for(re int i=0;(1<<i)<=mx[1];++i){
	dfs(1,0,i);for(re int j=1;j<=1<<i+1;++j)c[j]=0;sum=0;}
	printf("%lld",ans);
}
```


---

## 作者：_虹_ (赞：4)

~~思路题~~

发现只需要+1，我们从低位到高位建立0/1trie。

那么每次全局+1，我们只要沿着右儿子走，回溯时候递归交换左右儿子去模拟进位就行了。

异或和可以在trie树上用类似树形dp的东西维护。

线段树合并（0/1trie合并）空间复杂度是$2nlogn$的，这里似乎卡内存了。

但是我们用不到历史版本，所以我们遇到重复节点只要把一个并到另一个上就行了，不需要新建节点。

时空复杂度O(nlogn)

~~跟12省联考d2t2一样属于福利题。~~

```cpp
#include <iostream>
#include <list>
using namespace std;
const int kmaxn=600000+5;
list<int> to[kmaxn];
void add_edge(int s,int d)
{
	to[s].push_back(d);
}
struct node
{
	int cnt;
	int res;
	int dep;
	int son[2];
};
node T[kmaxn*22];
int tot;
void upd(int p)
{
	int ls=T[p].son[0];
	int rs=T[p].son[1];
	T[p].res=T[ls].res ^ T[rs].res ^ ((T[rs].cnt&1)<<T[p].dep);
}
void ins(int& p,int i,int d)
{
	if(!p)
	{
		p=++tot;
		T[p].dep=d;
	}
	++T[p].cnt;
	if(d>20)return;
	bool dir=1&(i>>d);
	ins(T[p].son[dir],i,d+1);
	upd(p);
}
int merge(int dst,int src)//remeber to update the root array
{
	if(!dst||!src)
		return dst?dst:src;
	T[dst].cnt+=T[src].cnt;
	T[dst].son[0]=merge(T[dst].son[0],T[src].son[0]);
	T[dst].son[1]=merge(T[dst].son[1],T[src].son[1]);
	upd(dst);
	return dst;
}
void add(int p)
{
	if(!p||T[p].dep>20)return;
	add(T[p].son[1]);
	swap(T[p].son[1],T[p].son[0]);
	upd(p);
}
int rt[kmaxn];
int v[kmaxn];
int res[kmaxn];
void solve(int x)
{
	for(list<int>::iterator i=to[x].begin();i!=to[x].end();++i)
	{
		solve(*i);
		rt[x]=merge(rt[x],rt[*i]);
	}
	add(rt[x]);
	ins(rt[x],v[x],0);
	res[x]=T[rt[x]].res;
}
int n;
int tp;
int main()
{
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;++i)
	{
		cin>>v[i];
	}
	for(int i=2;i<=n;++i)
	{
		cin>>tp;
		add_edge(tp,i);
	}
	solve(1);
	long long ans=0;
	for(int i=1;i<=n;++i)
	{
		ans+=res[i];
	}
	cout<<ans<<endl;
	return 0;
}
/*
5
5 4 1 2 3
1 1 2 2 

*/
```

听说有$O(nlog^2n)$做法，不知道那种做法能不能处理边权不为1的情况。。。。。


---

## 作者：lory1608 (赞：3)

### Update 2020.8.12

增加了长链剖分的讲解和代码

这道题我在考场上想了半个小时，写了一个半小时才写出来,~~还是代码能力太差，我太菜~~。

本来以为这道题A不了(本地跑 525010 跑了 6 秒多)，但是CCF的少爷机的速度还是可以的，让我过了这题。

在loj上A了，~~但是洛谷~~的评测机太慢，开-O2都很困难。

首先这道题可以不用任何复杂的数据结构，直接意构即可。

**注意本篇题解的思维可能有点绕**。

对于一般二进制的问题考虑拆位。

先考虑平凡的情况：对于第i位(从 $0$ 开始标号)，他在连续的 $2^i$ 个位置上对当前位答案的贡献一定是 $0$  ,然后再是一段$1$ (或者是先是一段 $1$ ,再是一段 $0$ )。

对于初始的情况：只用找到他结束当前状态的位置即可。

那么怎么求呢？

很简单：

**下面说的影响值得是当前这个节点可能可以该边他的一部分祖先的答案**。

下面说的在**差分数组上打标记**是指的统计答案，**打标记**是指的在 $cnt$ 数组上记录有几个点对他有影响。

对于平凡的情况：若当前所有对这个点在第$i$ 位上有影响的数的个数如果是偶数个，那么这个点对后 $2^i$ 个点无影响，否则有影响。

如果无影响，那么就不用管它。

如果有影响，只用在第 $2^{i+1}$ 次祖先上在**差分数组**打一个标记即可，然后在从当前位置开始的 $2^i$ 个点上有影响 。

**这里可以使用差分** $\Theta(1)$ **实现**。

```cpp
if(cnt[u]%2==1)
{
	d[u]^=1,d[fa[u][bas]]^=1;
	cnt[fa[u][bas+1]]+=cnt[u];
}
```

这里解释一下代码：

其中 $cnt[u]$ 表示的时这个点是否有影响。

 $d$ 是差分数组。

 $fa[u][i]$ 表示$u$ 的第$i$ 级祖先。

对于不平凡的情况(该节点的值对祖先的影响)：

如果这一位为 $1$ ，那么找到他最后一个影响的位置，然后在有影响的这一段的**差分数组**上打上标记，并把它下一次开始有影响的位置打上一个标记。

```cpp
if((val[u]>>bas)&1)
{
	int now=((1<<(bas+1)))-(val[u]&((1<<(bas+1))-1));
	int cur=getfa(u,now);
	d[u]^=1;
	d[cur]^=1;
	cnt[fa[cur][bas]]++;
}
```
这里解释一下代码：

其中 $val[u]$ 表示该点的权值。

 $now$ 表示当前受影响的个数。

 $getfa$ 是求树上 $k$ 级祖先。

如果这一位为 $0$ ，那么找到他第一个影响的位置，在这个位置上打一个标记。与上一种情况几乎一样

```cpp
else
{
	int now=(1<<bas)-(val[u]&((1<<(bas))-1));
	int cur=getfa(u,now);
	cnt[cur]++;
}
```

最后只要差分数组上是 $1$ ，那么这个点的这一位的答案为以，否则为 $0$ 。

那么这道题就完了。

如果用倍增求树上$k$ 级祖先总复杂度是 $\Theta(n\log^2 n)$ 的。

利用**长链剖分**求树上$k$ 级祖先总复杂度是 $\Theta(n\log n)$ 的。

长链剖分部分这样写:

```cpp
inline int lca(int u,int k)
{
	if(k==0)return u;
	u=fa[u][pre[k]];
	k-=(1<<pre[k]);
	k-=dep[u]-dep[tp[u]];
	u=tp[u];
	if(u==0)return 0;
	if(k>0)return up[u][k];
	else return down[u][-k];
}
```

上述两种方法均能通过此题(CCF没卡)，但在洛谷上要用长链剖分严格 $n\log n$ 才能过。

我在考场上写的是倍增，结果写错了调了一个小时。

还是我的代码能力太差。

注意**不开 $\texttt{long long}$ 只有10分**。

下面是我考试的代码~~比较丑~~(不要直接抄，过不了)：

倍增：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<vector>
#define ll long long
using namespace std;
const int maxn=555555;
int n,sz,fa[maxn][21],val[maxn],d[maxn],dep[maxn],pre[maxn],p[maxn],cnt[maxn];
ll ans;
inline int max(int a,int b){return a>b?a:b;}
struct edge
{
	int v,nxt;
	edge(){}
	edge(int vv,int nn){v=vv,nxt=nn;}
}e[maxn<<1];
inline void add(int u,int v)
{
	e[++sz]=edge(v,p[u]);
	p[u]=sz;
}
inline void dfs(int u)
{
	for(int i=1;i<=pre[dep[u]];++i)
	{
		fa[u][i]=fa[fa[u][i-1]][i-1];
	}
	for(int i=p[u];i!=-1;i=e[i].nxt)
	{
		int v=e[i].v;
		dep[v]=dep[u]+1;
		dfs(v); 
	}
}
inline int getfa(int u,int x)
{
	for(int i=pre[dep[u]];i>=0;--i)
	{
		if(x>=(1<<i))
		{
			u=fa[u][i];
			x-=(1<<i);
		}
		if(x==0)return u;
	}
	return 0;
}
inline void dfs2(int u,int bas)
{
 	for(int i=p[u];i!=-1;i=e[i].nxt)
	{
		int v=e[i].v;
		dfs2(v,bas);
		d[u]^=d[v];
	}
	if(cnt[u]%2==1)
	{
		d[u]^=1,d[fa[u][bas]]^=1;
		cnt[fa[u][bas+1]]+=cnt[u];
	}
	if((val[u]>>bas)&1)
	{
		int now=((1<<(bas+1)))-(val[u]&((1<<(bas+1))-1));
		int cur=getfa(u,now);
		d[u]^=1;
		d[cur]^=1;
		cnt[fa[cur][bas]]++;
	}
	else
	{
		int now=(1<<bas)-(val[u]&((1<<(bas))-1));
		int cur=getfa(u,now);
		cnt[cur]++;
	}
	if(d[u])ans+=(1<<bas);
}
int main()
{
	freopen("tree.in","r",stdin);
	freopen("tree.out","w",stdout);
	memset(p,-1,sizeof(p));
	scanf("%d",&n);
	for(int i=1;i<=n;++i)scanf("%d",&val[i]);
	for(int i=2;i<=n;++i)
	{
		scanf("%d",&fa[i][0]);
		add(fa[i][0],i);
	}
	for(int i=2;i<=n;++i)pre[i]=pre[i>>1]+1; 
	dfs(1);
	for(int i=0;i<=20;++i)
	{
		dfs2(1,i);
		for(int j=0;j<=n;++j)d[j]=0,cnt[j]=0;
	}
	printf("%lld\n",ans);
	return 0;
} 
```
长链剖分：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<vector>
#define ll long long
using namespace std;
const int maxn=555555;
int n,sz,fa[maxn][21],val[maxn],d[maxn],dep[maxn],pre[maxn<<1],p[maxn],cnt[maxn],son[maxn],maxdep[maxn],tp[maxn];
ll ans;
vector<int>up[maxn],down[maxn];
inline int max(int a,int b){return a>b?a:b;}
struct edge
{
	int v,nxt;
	edge(){}
	edge(int vv,int nn){v=vv,nxt=nn;}
}e[maxn<<1];
inline void add(int u,int v)
{
	e[++sz]=edge(v,p[u]);
	p[u]=sz;
}
inline int getint()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch>'9'||ch<'0')
	{
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return (f==1)?x:-x;
}
inline void dfs(int u)
{
	maxdep[u]=dep[u]=dep[fa[u][0]]+1;
	for(int i=1;i<=pre[dep[u]];++i)
	{
		fa[u][i]=fa[fa[u][i-1]][i-1];
	}
	for(int i=p[u];i!=-1;i=e[i].nxt)
	{
		int v=e[i].v;
		dfs(v);
		if(maxdep[v]>maxdep[u])
		{
			maxdep[u]=maxdep[v];
			son[u]=v;
		}
	}
}
inline void dfs1(int u,int topf)
{
	tp[u]=topf;
	if(u==topf)
	{
		int x=u;
		for(int i=0;i<=maxdep[u]-dep[u];++i)
		{
			up[u].push_back(x);
			x=fa[x][0];
		}
		x=u;
		for(int i=0;i<=maxdep[u]-dep[u];++i)
		{
			down[u].push_back(x);
			x=son[x];
		}
	}
	if(son[u])dfs1(son[u],topf);
	for(int i=p[u];i!=-1;i=e[i].nxt)if(e[i].v!=son[u])dfs1(e[i].v,e[i].v);
}
inline int lca(int u,int k)
{
	if(k==0)return u;
	u=fa[u][pre[k]];
	k-=(1<<pre[k]);
	k-=dep[u]-dep[tp[u]];
	u=tp[u];
	if(u==0)return 0;
	if(k>0)return up[u][k];
	else return down[u][-k];
}
inline void dfs2(int u,int bas)
{
 	for(int i=p[u];i!=-1;i=e[i].nxt)
	{
		int v=e[i].v;
		dfs2(v,bas);
		d[u]^=d[v];
	}
	if(cnt[u]%2==1)
	{
		d[u]^=1,d[fa[u][bas]]^=1;
		cnt[fa[u][bas+1]]+=cnt[u];
	}
	if((val[u]>>bas)&1)
	{
		int now=((1<<(bas+1)))-(val[u]&((1<<(bas+1))-1));
		int cur=lca(u,now);
		d[u]^=1;
		d[cur]^=1;
		cnt[fa[cur][bas]]++;
	}
	else
	{
		int now=(1<<bas)-(val[u]&((1<<(bas))-1));
		int cur=lca(u,now);
		cnt[cur]++;
	}
	if(d[u])ans+=(1<<bas);
}
int main()
{
	freopen("tree.in","r",stdin);
	freopen("tree.out","w",stdout);
	memset(p,-1,sizeof(p));
	n=getint();
	for(int i=1;i<=n;++i)val[i]=getint();
	for(int i=2;i<=n;++i)
	{
		fa[i][0]=getint();
		add(fa[i][0],i);
	}
	for(int i=2;i<=maxn*2-1;++i)pre[i]=pre[i>>1]+1; 
	dfs(1);
	dfs1(1,1);
	for(int i=0;i<=20;++i)
	{
		dfs2(1,i);
		for(int j=0;j<=n;++j)d[j]=0,cnt[j]=0;
	}
	printf("%lld\n",ans);
	return 0;
} 
```
### 一些注意事项：

我考场上倍增写错了调了半天，我是这样写的
```cpp
u=fa[u][i];
x-=(dep[u]-dep[fa[u][i]]);
```
这里我先跳祖先再减，这样是错的，因为调到最上面时会有 $dep[u]-dep[fa[u][i]]\not=(1<<i)$ 的情况。

所以要讲代码写成：
```cpp
x-=(dep[u]-dep[fa[u][i]]);
u=fa[u][i];
```

在写长链剖分的时候，有这样一个问题，在向上跳的时候，不完整的部分**可能超过n**,所以要将 $pre$ 数组开大一倍。

注意，上面第一份代码无法在洛谷 $AC$ ,第二份可以。

---

## 作者：_LHF_ (赞：3)

看到大部分大佬都在用那么牛逼方法，我只想说：
# 这一题没那么难啊！？
一种暴力的方法：我们考虑每一个点在那一条链上面的贡献，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/dqa8n1cu.png)

如果我们暴力来进行计算的话时间复杂度最坏是$O(n^2)$，考虑优化。

因为本题最难点在于异或，所以从异或出手，考虑到异或$v+1,v+2...$我们先手模一下：

设v=1,则
```
v  =   1
v+1=  10
v+2=  11
v+3= 100
v+4= 101
v+5= 110
v+6= 111
v+7=1000
v+8=1001
v+9=1010
```
备注：等号右边的数均为二进制意义下的数。
### 分析：
```
等号右边最后一位：101010...
倒数第二位：011001100...
倒数第三位：00011110000...
```
你发现了什么？

所以就这样啦。

大体上是一个树上差分。

然后发现$2^{20}>525010$，刚刚好。

时间复杂度：$O(20n)$
```cpp
#include<cstdio>
#define N 526000
using namespace std;
struct edge{
	int next,to;
}e[N];
int first[N],len,a[N],n,fa;
long long ans;
void add(int a,int b)
{
	len++;
	e[len].next=first[a];
	first[a]=len;
	e[len].to=b;
}
int f[N],g[N][23],lca[N][23];
void dfs(int x)
{
	for(int i=1;i<=20;i++)
		lca[x][i]=lca[lca[x][i-1]][i-1];
	for(int i=first[x];i;i=e[i].next)
	{
		lca[e[i].to][0]=x;
		dfs(e[i].to);
	}
	int y=lca[x][0],z=a[x]+1;
	g[y][0]^=1;
	for(int i=0;i<=20;i++)
	{
		g[lca[x][i]][i]^=g[x][i];
		f[x]^=g[x][i];
		if(z&(1<<i)) z+=(1<<i),y=lca[y][i];
		g[y][i+1]^=(1<<(i+1));
	}
	f[x]^=a[x];
	ans+=f[x];
	f[lca[x][0]]^=f[x];
}
int number;
char chr;
int fread()
{
	number=chr=0;
	while(chr>'9'||chr<'0') chr=getchar();
	while(chr>='0'&&chr<='9') number=number*10+chr-'0',chr=getchar();
	return number;
}
int main()
{
	n=fread();
	for(int i=1;i<=n;i++) a[i]=fread();
	for(int i=1;i<n;i++) add(fread(),i+1);
	dfs(1);
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：xh39 (赞：2)

p6623

做法很多，提供一个较慢但是好想的方法。大概是$O(n\times log_{2}(n)^2)$

前置基础:会使用树状数组，并对位运算及作用有简单了解。

注:下面所有的第...位都是二进制下从右到左数的。a%b表示a mod b。

这道题为什么是异或而不是其他运算?因为异或有一个性质，就是逆运算是它本身，即a^b=c，则 c^b=a(这里不讲证明)。如何利用这个性质，下面会讲。

$a\%2^{(b+1)}$即取 $a$ 的最后 $b$ 位。

逐位考虑，哪些点会有贡献。

假设现在计算节点 $i$，考虑第 $j$ 位。那么对这个点有贡献的一定是 $(v+d)$ 在区间$2^{j}<=(v+d)\%2^{(j+1)}<2^{(j+1)}$。但是肯定不能一个个枚举，不然还是$O(n^{2})$的，于是需要优化。

设节点$i$深度为$depth(i)=d(1,i)$。在$i$的子树内所有的结点 $k$，$d(i,k)=depth(k)-depth(i)$，所以简化上述区间(先不考虑取模)，就是$2^{j}<=v+depth(k)-depth(i)<2^{(j+1)}$ 

$2^{j}+depth(i)<=v+depth(k)<2^{(j+1)}+depth(i)$

设$l=2^{j}+depth(i),r=2^{(j+1)}+depth(i)$，就是左区间和右区间。假设 $l<=r$，那么还是一样，在区间 $l<=v+d<r$ 满足要求。但如果 $l>r$，将取模想象为一个环，那么肯定是构成了一个循环，就是小于 $r$ 或者大于等于 $l$ 的就一定可行。

利用异或的性质，开一个 bool 数组 $s[j][k]$ 表示第 $j$ 位，值为 $k$ 的异或值，每遍历一个节点，就将它所有位，$(v+d)\%2^{(j+1)}$的可以发现答案是子树内在本位的区间内的改变量。

然后就只需要支持动态查询区间异或值，用树状数组即可。推荐不要用其它的数据结构，因为这个算法的时间复杂度较高，所以要卡常。

代码很短。核心代码只有 $29$ 行，其它都是静态链表存图，树状数组的模板。
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
struct awgwbgowgbweog{
	int v,next;
}_[2000005];
int head[2000005],tot=1,a[2000005],logn,f[2000005];
bool tree[29][2000005];
void change(int array,int id){
	if(id<0){
		return;
	}
	id++;
	int i,ykb=(1<<array+1);
	for(i=id;i<=ykb;i+=i&(-i)){
		tree[array][i]^=1;
	}
}
bool ask(int array,int id){
	if(id<0){
		return 0;
	}
	id++;
	int i;
	bool sum=0;
	for(i=id;i;i-=i&(-i)){
		sum^=tree[array][i];
	}
	return sum;
}
int fyr(int iakioi,int step){ //iakioi就是目前结点,step是深度。
	int i,sum0=0,sum1=0,l,r;
	for(i=0;i<logn;i++){
		change(i,(a[iakioi]+step)&((1<<i+1)-1)); //放入树状数组中。
	}
	for(i=0;i<logn;i++){ //求出原本的值。
		l=(step+(1<<i))&((1<<i+1)-1);
		r=(step-1)&((1<<i+1)-1);
		if(l<=r){
			sum0|=((ask(i,l-1)^ask(i,r))<<i);
		}else{
			sum0|=((ask(i,(1<<i+1)-1)^ask(i,l-1)^ask(i,r))<<i);
		}
	}
	for(i=head[iakioi];i;i=_[i].next){
		fyr(_[i].v,step+1);
	}
	for(i=0;i<logn;i++){ //求出遍历完后的值。
		l=(step+(1<<i))&((1<<i+1)-1);
		r=(step-1)&((1<<i+1)-1);
		if(l<=r){
			sum1|=((ask(i,l-1)^ask(i,r))<<i);
		}else{
			sum1|=((ask(i,(1<<i+1)-1)^ask(i,l-1)^ask(i,r))<<i);
		}
	}
	f[iakioi]=sum0^sum1^a[iakioi]; //原本的值^现在的值 就是改变量,别忘了异或自己。因为自己也是子树内的。
	return f[iakioi];
}
int main(){
	int n,i,j,fa,maxa=0;
	long long sum=0;
	cin>>n;
	for(i=1;i<=n;i++){
		scanf("%d",a+i);
		maxa=max(maxa,a[i]);
	}
	for(logn=0;(1<<logn)<=maxa+n;logn++){
	}
	logn++;
	for(i=2;i<=n;i++){
		scanf("%d",&fa);
		_[tot].v=i;
		_[tot].next=head[fa];
		head[fa]=tot;
		tot++;
	}
	fyr(1,0);
	for(i=1;i<=n;i++){
		sum+=(long long)f[i];
	}
	cout<<sum;
	return 0;
}
```
最大测试点用了1.30s,几乎卡时限过的。

---

## 作者：gxy001 (赞：2)

看到题目，首先思考怎么从子节点转移到父节点，假设在子节点有一个桶，存着异或起来得到子节点答案的信息，我们需要的是其内部每一个数加一后的异或值，然后就是[经典套路](https://www.luogu.com.cn/problem/P6018) ~~，不讲了~~。

简单说一下怎么维护，从低位往高位建 01trie，加一操作实际上就是交换左右子树，进入交换后的 0 子树递归，记得进位；开桶维护每一位上 1 的数量，用来求异或值。

从子节点转移到父节点时先给子节点加一，再 01trie 合并，方法和[线段树合并](https://www.luogu.com.cn/problem/P4556)完全一致。

时间复杂度 $O(n\log v)$，证明：每个节点只会进行一次插入操作，一次加一操作，一次查询操作，这部分是严格 $O(n\log v)$，被合并一次，合并的复杂度与线段树合并一致，也是 $O(n\log v)$。

```cpp
#include<cstdio>
#include<algorithm>
#include<utility>
namespace IO{
	#define BUFSIZE 10000000
	struct read{
		char buf[BUFSIZE],*p1,*p2,c,f;
		read():p1(buf),p2(buf){}
		char gc(void){
			return (p1==p2)&&(p2=buf+fread(p1=buf,1,BUFSIZE,stdin),p1==p2)?EOF:*p1++;
		}
		read& operator >>(int& x){
			c=gc(),f=1,x=0;
			for(;~c&&(c<'0'||c>'9');c=gc())if(c=='-')f=-1;
			for(;c>='0'&&c<='9';c=gc())x=x*10+c-'0';
			x*=f;
			return *this;
		}
	};
	read in;
}
using IO::in;
int const maxn=525020;
struct trie{
	static int cnt,s[maxn*32][2],sz[maxn*32];
	int rt,a[24];
	void insert(int x){
		if(!rt) rt=++cnt;
		int p=rt,i=0;
		while(x){
			++sz[p];
			a[i++]+=x&1;
			if(!s[p][x&1]) s[p][x&1]=++cnt;
			p=s[p][x&1];
			x>>=1;
		}
		++sz[p];
	}
	void add(){
		int p=rt,i=0,k=0;
		while(p){
			std::swap(s[p][0],s[p][1]);
			a[i]=a[i]-sz[s[p][0]]+sz[s[p][1]];
			if((k=sz[p]-sz[s[p][0]])-sz[s[p][1]]){
				if(!s[p][1]) s[p][1]=++cnt;
				a[i]+=k-sz[s[p][1]];
				sz[s[p][1]]=k;
			}
			++i;
			p=s[p][0];
		}
	}
	int getxor(){
		int ans=0;
		for(int i=0;i<21;i++) ans|=(a[i]&1)<<i;
		return ans;
	}
	static void pmerge(int &x,int const &px,int const &i);
	void merge(const trie& x){
		for(int i=0;i<21;i++) a[i]+=x.a[i];
		return pmerge(rt,x.rt,0);
	}
}tr[maxn];
void trie::pmerge(int &x,int const &px,int const &i){
	if(!x) return x=px,void();
	if(!px) return;
	sz[x]+=sz[px];
	pmerge(s[x][0],s[px][0],i+1),pmerge(s[x][1],s[px][1],i+1);
}
int trie::cnt,trie::s[maxn*32][2],trie::sz[maxn*32];
int n,v[maxn],head[maxn],to[maxn],nxt[maxn];
long long ans;
inline void add(int const &x,int const &y){
	static int cnt=0;
	to[++cnt]=y,nxt[cnt]=head[x],head[x]=cnt;
}
void dfs(int const &x){
	tr[x].insert(v[x]);
	for(int i=head[x];i;i=nxt[i])
		dfs(to[i]),tr[to[i]].add(),tr[x].merge(tr[to[i]]);
	ans+=tr[x].getxor();
}
int main(){
	in>>n;
	for(int i=1;i<=n;i++)in>>v[i];
	for(int i=2,x;i<=n;i++)in>>x,add(x,i);
	dfs(1);
	printf("%lld\n",ans);
//	fprintf(stderr,"%d\n",trie::cnt);
	return 0;
}
```

---

## 作者：BFqwq (赞：1)

## P6233 树
一直很想写一下这个题，但由于去年省选之后我一直在 whk，所以一直推到了 csp 前。

很显然，我们可以用一种可合并的数据结构维护子树的异或和，比如 trie。

但这个时候我们发现，有一个全局 +1 的操作我们实现起来会有一定的困难。

于是我们可以考虑将 trie 反建，也就是第 $i$ 层表示二进制下的 $1<<i$ 这一位。这样建树会有一个很大的好处，就是我们可以从低位开始处理数据。

而显然，对于 +1 操作，我们肯定要从最低位开始处理。

我们考虑，如果一个数的二进制最后一位是 $0$，则它加上 $1$ 之后，则最后一位就变成了 $1$，并且没有发生进位，它的位置也就从左子树的变化到了右子树的对应位置。这是比较好处理的。

而如果某个数的二进制最后一位是 $1$，就比较麻烦，因为我们需要考虑进位。但无论如何进位，我们可以确定，它的最后一位一定是 $0$，因此它的位置会从右子树变化到左子树。

于是我们就可以直接交换根节点的左右子树。其中，原左子树到右子树的点由于前面的位没有发生变化，故位置对应不变，所以我们只需要考虑对新的左子树进行修改。

而左子树的每个数一定都是在最后一位发生了进位的，此时我们考虑这个数的倒数第二位是否为 $1$。于是我们发现，此时的讨论和对倒数第一位的讨论是类似的，并且可以递归下去。

所以，我们只需要每次交换左右子树，并且进入左子树修改即可。

放出全局 +1 的代码：

```cpp
void change(int o){
	if(!o) return;
	swap(t[o].ch[0],t[o].ch[1]);
	change(t[o].ch[0]);
	pushup(o);
}
```
至于剩下的，就是 trie 树的常规操作，这里就不再赘述了。我们只需要求出每个子树的值，然后将所有子树合并并加一，最后插入该节点的值即可。

AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
	bool f=1;
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=0;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)-48+c;
		c=getchar();
	}
	return f?x:x*-1;
}
char cr[200];int tt;
inline void print(register long long x,register char k='\n') {
    if(!x) putchar('0');
    if(x < 0) putchar('-'),x=-x;
    while(x) cr[++tt]=x%10+'0',x/=10;
    while(tt) putchar(cr[tt--]);
    putchar(k);
}
const int maxn=525020;
int n,v[maxn];
vector<int> g[maxn];
stack<int> st;
struct node{
	int dep,ch[2],sum,val;
}t[maxn*100];int rt[maxn],tot;
long long res=0;
int nnd(){
	if(st.empty()){
		return ++tot;
	}
	int x=st.top();st.pop();return x;
}
void del(int &o){
	t[o].dep=t[o].ch[0]=t[o].ch[1]=t[o].sum=t[o].val=0;
	st.push(o);
	o=0;
}
void pushup(int o){
	t[o].sum=t[t[o].ch[0]].sum+t[t[o].ch[1]].sum;
	t[o].val=t[t[o].ch[0]].val^t[t[o].ch[1]].val;
	if(t[t[o].ch[1]].sum&1){
		t[o].val^=1<<t[o].dep;
	}
}
void insert(int &o,int v,int d){
	if(!o){
		o=nnd();
		t[o].dep=d;
	}
	if(d>=26){
		t[o].sum++;
		return;
	}
	if(v&1<<d){
		insert(t[o].ch[1],v,d+1);
	}
	else{
		insert(t[o].ch[0],v,d+1);
	}
	pushup(o);
}
void change(int o){
	if(!o) return;
	swap(t[o].ch[0],t[o].ch[1]);
	change(t[o].ch[0]);
	pushup(o);
}
void merge(int &a,int &b){
	if(!a){
		a=b;
		b=0;
		return;
	}
	if(!b){
		return;
	}
	t[a].sum+=t[b].sum;
	t[a].val^=t[b].val;
	merge(t[a].ch[0],t[b].ch[0]);
	merge(t[a].ch[1],t[b].ch[1]);
	if(b){
		del(b);
	}
}
void dfs(int u){
	rt[u]=nnd();
	for(int v:g[u]){
		dfs(v);
		merge(rt[u],rt[v]);
	}
	change(rt[u]);
	insert(rt[u],v[u],0);
	res+=t[rt[u]].val;
}
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		v[i]=read();
	}
	for(int i=2;i<=n;i++){
		g[read()].push_back(i);
	}
	dfs(1);
	print(res);
	return 0;
}
```


---

## 作者：aspe (赞：0)

### 题解
d2t2 非 tire 做法题解

应该是 noip 提高组水平也能想出的思路。

$n$ 结点个数，$m$ 为数集大小。

考虑拆位。

对于数字 $110110101(2)$

单独看它的第四位（从右往左）的 0，它将在 $10000-0101=1011$ 次+1 后变为 1，之后每过 1000 次就 01 交替，基于这个思路，我们会发现只有第一次 01 交替是不循环的，之后每次都是有规律的。

然后树上差分即可。

对应到树上就是类似倍增的 1 个东西。跳 $2^i$ 次方的父亲。

时间复杂度 $O(n\log m)$，空间复杂度 $O(n)$。

### 代码
```c++
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>

using namespace std;

int read()
{	
	int ch;
	
	for (ch=getchar(); ch<'0' || ch>'9'; ch=getchar());
	
	int x=ch^'0';
	
	for (ch=getchar(); '0'<=ch && ch<='9'; ch=getchar())
	 x=(((x<<2)+x)<<1)+(ch^'0');
	
	return x;
}

const int ML=1100000;

int vv[ML],nx[ML],top[ML],tplb;

int si[ML],ssi[ML],su[ML],fa[ML],t[ML],ffa[ML],ans[ML],v[ML],x[ML],la[ML];

void ins(int u,int v)
{
	int np=tplb++;
	
	vv[np]=v; nx[np]=top[u]; top[u]=np;
}

void dfs(int u)
{
	for (int kb=top[u]; ~kb; kb=nx[kb])
	{
		int v=vv[kb];
		
		dfs(v);
	}
	
	si[fa[u]]-=si[u];
}

int sum(int u)
{
	su[u]+=si[u]+ssi[u];
	
	for (int kb=top[u]; ~kb; kb=nx[kb])
	{
		int v=vv[kb];
		
		su[u]+=sum(v);
	}
	
	return su[u];
}

int main()
{
	int n=read();
	
	for (int i=1; i<=n; i++) v[i]=read(),x[i]=v[i],la[i]=i,top[i]=-1;
	
	for (int i=2; i<=n; i++) fa[i]=read();
	for (int i=2; i<=n; i++) ins(fa[i],i);
	
	for (int j=0; j<21; j++)
	{
		if (j)
		{
			for (int i=1; i<=n; i++) t[i]=fa[i];
			for (int i=1; i<=n; i++) fa[i]=t[t[i]];
		}
		
		for (int i=0; i<=n; i++) su[i]=si[i]=ssi[i]=0;
		
		for (int i=1; i<=n; i++)
		{
			int xx=(x[i]>>j)&1,vv=(v[i]>>j)&1;
			
			if (xx^vv)
			{
				if (xx)
				{
					si[la[i]]++;
					
					x[i]+=1<<j,la[i]=fa[la[i]];
				}
				else
				{
					si[la[i]]--; ssi[i]++;
				}
			}
			else
			{
				if (xx)
				{
					x[i]+=1<<j,la[i]=fa[la[i]];
					
					ssi[i]++; si[la[i]]--;
				}
				else
				{
					si[fa[la[i]]]++;
				}
			}
		}
		dfs(1);
		
		sum(1);
        
		for (int i=1; i<=n; i++) ans[i]+=((su[i]&1)<<j);
	}
	
	long long S=0;
	
	for (int i=1; i<=n; i++) S+=ans[i];
	
	cout<<S;
	
	return 0;
}
```

---


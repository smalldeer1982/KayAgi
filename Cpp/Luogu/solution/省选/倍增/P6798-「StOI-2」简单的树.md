# 「StOI-2」简单的树

## 题目描述

给定一棵以 $1$ 为根，由 $n$ 个点组成的有根树，每个点有点权 $c_{i}$ 。

定义每个点的 $val$ 值为：以它为根的子树内所有 $c_{i}$ 的最大值。

定义函数 $f(x,y)$ 表示将 $c_{x}$ 改为 $y$ 后整棵树的 $val$ 值之和。

现在请您回答 $q$ 组询问，每次询问给定 $3$ 个量 $(l,r,a)$ ，请求出 $\sum\limits_{i=l}^{r}{f(a,i)}$ 对 $998,244,353$ 取模的结果。

## 说明/提示

## 样例解释

真实的 $(l,r,a)$ 为：

- $(2,4,1)$
- $(3,5,2)$
- $(2,4,5)$

---

## 数据范围

对于 $10\%$ 的数据：$1 \leq n,q \leq 100 $ 。   
对于 $20\%$ 的数据：$1 \leq n,q \leq 3000 $ 。   
对于另 $20\%$ 的数据：$1 \leq l',r',c_{i} \leq 2 $ 。   
对于另 $20\%$ 的数据：$l'=r'$ 。   
对于前 $80\%$ 的数据：$opt=0$ 。   
对于 $100\%$ 的数据：$1 \leq n,q \leq 5 \times 10^{5} ，1 \leq c_{i} , a' , l' , r' \leq n$ 。

## 样例 #1

### 输入

```
5 3 0
5 3 4 2 1
1 2
1 3
2 4
2 5
1 3 5
2 4 1
1 3 4```

### 输出

```
42
48
52```

# 题解

## 作者：hellolin (赞：3)

注：下文下标统一从 $0$ 开始，根节点是 $0$，区间采用左闭右开记法，一条链包含它的两个端点。

首先我们观察到以下性质：

1. 题目所求 $\sum\limits^{r}_{i=l}f(a,i)$ 可以转为 $\sum\limits^{r}_{i=0}f(a,i)-\sum\limits^{l-1}_{i=0}f(a,i)$，所以修改操作可以只考虑 $[0, r)$ 的情况。
2. 如果对点 $x$ 做修改，答案受影响的节点一定都在 $0\to x$ 的链上。
3. 每个节点的答案一定不小于它的任何一个儿子，也就是说从下至上是单调不降的。
4. 如果我们事先知道某个子树内删除 $x$ 之外的答案，那么我们就可以在 $x$ 更改权值之后知道子树新的答案。

我们先考虑只对于一棵子树，修改一次的情况。根据性质四，我们可以维护子树内最大值和次大值，这样可以快速知道更新后的答案。

再考虑修改多次的情况，我们已经知道了除 $x$ 之外的答案 $v$，值在区间 $[0, r)$ 中取，怎么知道答案之和呢？

如果 $v\geq r-1$，那么无论怎么修改，答案都是 $v$ 不变。修改 $r$ 次的总贡献为 $v\times r$。

如果 $v < r-1$，那么前 $v$ 次修改时答案都是 $v$，后面 $r-v$ 次答案为 $v,v+1,v+2,\dots,r-1$。修改 $r$ 次的总贡献为：

$$
\begin{aligned}
&v^2+v+(v+1)+(v+2)+\dots+(r-1)\\
=\ &v^2+\frac{(r+v-1)(r-v)}{2}\\
=\ &v^2+\frac{r^2-v^2-r+v}{2}\\
=\ &\frac{v^2+v}{2}+\frac{r^2-r}{2}
\end{aligned}
$$

最后我们考虑影响多棵子树怎么做。还是设修改 $x$ 节点，值在区间 $[0, r)$ 取。

根据性质二、性质三，最大值（和次大值）自下而上单调不降，也就是在某一个节点之前，删除 $x$ 之外的答案是子树次大值，在之后是子树最大值。这个分界点我们倍增找就行了。

不难发现这个分界点以下以及以上的区间，又分成了 $v < r-1$ 和 $v \geq r-1$ 的区间，一共四个小区间。我们还是倍增找到这两个分界点。

![](https://cdn.luogu.com.cn/upload/image_hosting/s83r18tb.png)

对于 $v\geq r-1$ 的区间，它们都是链上连续的一段，对于次大值与最大值记录 $v\times r$ 前缀和即可。

对于 $v<r-1$ 的区间，总贡献为（$\mathrm{len}$ 为区间长度）：

$$
\begin{aligned}
&\sum(\frac{v^2+v}{2}+\frac{r^2-r}{2})\\
=\ &\frac{\sum v^2+\sum v}{2}+\frac{\mathrm{len}\times (r^2-r)}{2}
\end{aligned}
$$

维护一下子树内答案和、答案平方和，树剖查询即可。

树剖和倍增初始化 $O(n\log n)$，查询 $O(\log n)$，前缀和初始化 $O(n)$，查询 $O(1)$。总时间复杂度 $O(n\log n)$，写得优秀一点是可以跑进 2s 的。

``` cpp
#include "hellolin/common.hpp"
#include "hellolin/utils.hpp"
#include "hellolin/io.hpp"

namespace hellolin {
static constexpr i64 Mod = 998244353, Inv2 = 499122177;

struct SubTree {
  i64 fir = 0, sec = 0;
  friend SubTree operator+(const auto &l, const auto &r) {
    if (l.fir == r.fir) {
      return {l.fir, r.fir};
    } else if (l.fir > r.fir) {
      return {l.fir, max(l.sec, r.fir)};
    } else {
      return {r.fir, max(r.sec, l.fir)};
    }
  }
  SubTree &operator+=(const auto &r) {
    return *this = *this + r;
  }
};

struct Node {
  struct {
    i64 sum = 0, squ = 0;
  } fir, sec;
  Node operator-() const {
    return { {-fir.sum, -fir.squ}, {-sec.sum, -sec.squ} };
  }
  friend Node operator+(const auto &l, const auto &r) {
    return { {l.fir.sum + r.fir.sum, l.fir.squ + r.fir.squ}, {l.sec.sum + r.sec.sum, l.sec.squ + r.sec.squ} };
  }
  friend Node operator-(const auto &l, const auto &r) {
    return l + -r;
  }
  Node &operator+=(const auto &r) {
    return *this = *this + r;
  }
  Node &operator-=(const auto &r) {
    return *this = *this - r;
  }
};

void main() {
  int n, q, opt;
  io.read(n, q, opt);

  std::vector<int> val(n);
  io.read(val);

  std::vector<std::vector<int>> g(n);
  for (int i = 1, u, v; i < n; ++i) {
    io.read(u, v);
    --u, --v;
    g[u].push_back(v);
    g[v].push_back(u);
  }

  std::vector<int> son(n, -1), dfn(n), idx(n), siz(n), dep(n), top(n);
  std::vector<std::vector<int>> anc(20, std::vector<int> (n));
  std::vector<SubTree> tree(n);
  std::vector<Node> presum(n);
  int tot = 0;

  auto dfs1 = [&](auto &&f, int x, int fa) -> void {
    siz[x] = 1;
    dep[x] = (fa == -1 ? -1 : dep[fa]) + 1;
    anc[0][x] = fa;
    tree[x] = {val[x], 0};

    for (const int &y : g[x]) {
      if (y == fa) continue;
      f(f, y, x);
      siz[x] += siz[y];
      if (son[x] == -1 or siz[y] > siz[son[x]]) son[x] = y;
      tree[x] += tree[y];
    }
  };
  auto dfs2 = [&](auto &&f, int x, int tp) -> void {
    idx[dfn[x] = tot++] = x;
    top[x] = tp;
    if (son[x] != -1) f(f, son[x], tp);
    for (const int &y : g[x]) {
      if (y == anc[0][x] or y == son[x]) continue;
      f(f, y, y);
    }
  };
  dfs1(dfs1, 0, -1);
  dfs2(dfs2, 0, 0);
  for (int i = 1; i <= 19; ++i) {
    anc[i][0] = -1;
    for (int j = 1; j < n; ++j) {
      if (anc[i - 1][j] != -1)
        anc[i][j] = anc[i - 1][anc[i - 1][j]];
      else
        anc[i][j] = -1;
    }
  }

  presum[0] = {
      {tree[0].fir, tree[0].fir * tree[0].fir},
      {tree[0].sec, tree[0].sec * tree[0].sec}
  };
  for (int i = 1; i < n; ++i) {
    int cur = idx[i];
    presum[i] = presum[i - 1] + Node({
      {tree[cur].fir, tree[cur].fir * tree[cur].fir},
      {tree[cur].sec, tree[cur].sec * tree[cur].sec}
    });
  }

  auto query = [&](int l, int r) {
    if (l == 0) return presum[r - 1];
    return presum[r - 1] - presum[l - 1];
  };

  auto queryLink = [&](int x, int y) {
    Node result;
    while (top[x] != top[y]) {
      if (dep[top[x]] < dep[top[y]]) swap(x, y);
      result += query(dfn[top[x]], dfn[x] + 1);
      x = anc[0][top[x]];
    }
    if (dep[x] > dep[y]) swap(x, y);
    result += query(dfn[x], dfn[y] + 1);
    return result;
  };

  auto solve = [&](int a, i64 r) -> i64 {
    if (r <= 0) return 0;
    i64 result = 0;

    int b = a;
    for (int i = 19; i >= 0; --i) {
      if (anc[i][b] == -1) continue;
      if (tree[anc[i][b]].fir <= val[a]) b = anc[i][b];
    }

    if (tree[b].fir <= val[a]) {
      int c = a;
      for (int i = 19; i >= 0; --i) {
        if (anc[i][c] == -1 or dep[b] > dep[anc[i][c]]) continue;
        if (tree[anc[i][c]].sec < r - 1) c = anc[i][c];
      }

      if (tree[c].sec < r - 1) {
        Node link = queryLink(a, c);
        i64 count = dep[a] - dep[c] + 1;
        i64 delta = (count * (r * (r - 1) % Mod) % Mod + link.sec.squ + link.sec.sum) % Mod * Inv2 % Mod;
        result = (result + delta % Mod) % Mod;
        c = anc[0][c];
      }
      if (c != -1 and dep[c] >= dep[b]) {
        Node link = queryLink(c, b);
        result = (result + link.sec.sum * r % Mod) % Mod;
      }
      b = anc[0][b];
    }
    if (b == -1) return result;

    int d = b;
    for (int i = 19; i >= 0; --i) {
      if (anc[i][d] == -1) continue;
      if (tree[anc[i][d]].fir < r - 1) d = anc[i][d];
    }

    if (tree[d].fir < r - 1) {
      Node link = queryLink(b, d);
      i64 count = dep[b] - dep[d] + 1;
      i64 delta = (count * (r * (r - 1) % Mod) % Mod + link.fir.squ + link.fir.sum) % Mod * Inv2 % Mod;
      result = (result + delta % Mod) % Mod;
      d = anc[0][d];
    }
    if (d != -1) {
      Node link = queryLink(d, 0);
      result = (result + link.fir.sum * r % Mod) % Mod;
    }

    return result;
  };

  i64 answer = 0, origin = query(0, n).fir.sum;
  for (int i = 0, l, r, a; i < q; ++i) {
    io.read(l, r, a);
    l = (answer * opt + (i64) l) % n + 1;
    r = (answer * opt + (i64) r) % n + 1;
    a = (answer * opt + (i64) a) % n + 1;
    if (l > r) swap(l, r);
    ++r, --a;

    Node link = queryLink(a, 0);
    answer = ((origin - link.fir.sum) * (r - l) % Mod + solve(a, r) - solve(a, l)) % Mod;
    answer = (answer + Mod) % Mod;
    io.writeln(answer);
  }
}
} // namespace hellolin

int main() { hellolin::main(); }
```

---

## 作者：littleKtian (赞：2)

upd on 2021.1.18：更新了更快的树上二分，现在程序复杂度为 $O(n\log n)$（顺带调整了一部分内容）。~~所以这题有什么开 3s 的必要吗？~~

------------

**简 单**的树

------------

注意到以下比较明显的性质：

+ 修改一个点的点权 $c$ 时，只有自己以及其祖先的 $val$ 值可能发生变化。
+ 如果点 $u$ 的子树内某个点 $v$ 的 $c_v$ 被修改，点 $u$ 的 $val$ 值为子树内除 $v$ 外所有点中最大的 $c$ 和 $v$ 修改后的 $c_v$ 中最大值。

根据第一条，所有不是 $a$ 到根路径上所有点的 $val$ 值可以做到 预处理 $O(n)$+单次询问 $O(1)$ 求出。

根据第二条，容易想到求出每个点子树内最大和次大的 $c$，因为这两个在不断向上的过程中具有单调性，所以可以 树剖+二分 做到 预处理 $O(n)$+单次询问 $O(\log n)$ 求出所有以 $u$（$u$ 是 $a$ 到根路径上的点）为根的子树中除 $a$ 以外所有点中最大的 $c$。

假设我们已经求出了以 $u$ 为根的子树中除 $a$ 以外所有点中最大的 $c$，记作 $x$。

+ $x\leqslant l$

![](https://i.loli.net/2020/08/30/XKLgEwhNGD1rzQo.png)

此时最大值始终取修改后的 $c_a$，直接统计满足的点的个数即可。

+ $x\geqslant r$

![](https://i.loli.net/2020/08/30/D8VGW5vUZ37HuqM.png)

此时最大值始终取 $x$，同样直接求出所有满足的点的 $x$ 之和即可。

+ $l<x<r$

![](https://i.loli.net/2020/08/30/D3bcIQT6Lq1Mw7O.png)

此时贡献为 $(x-l)x+\dfrac{(x+r)(r-x+1)}{2}=\dfrac{x^2}{2}+(\dfrac{1}{2}-l)x+\dfrac{r^2+r}{2}$ 只需要再预存一个子树内最大和次大的 $c$ 的平方就能解决了。

注意到这三部分在 $a$ 到根路径上都是连续的一段，并且按一定顺序，所以 树剖+二分+前缀和 就能解决，同样是 预处理 $O(n)$+单次询问 $O(\log n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int p=998244353;
const int n2=499122177;
int lans,totc,lc[500005];
int qj[500005][2],qjf[500005][2];
int lst[500005],lsw[500005],bi[1000005][2],bs;
int c[500005],f[500005][2];
int fa[500005],so[500005],de[500005],si[500005],to[500005],xh[500005],dy[500005],dfn;
int n,q,opt;
ll dr()
{
    ll xx=0;char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')xx=(xx<<1)+(xx<<3)+ch-'0',ch=getchar();
    return xx;
}
void tj(int u,int v)
{
    ++bs;
    if(lst[u])bi[lsw[u]][0]=bs;
    else lst[u]=bs;
    bi[bs][1]=v,lsw[u]=bs;
}
void dfs(int w,int ff)
{
    f[w][0]=c[w];
    int o_o=lst[w];
    while(o_o)
    {
        int v=bi[o_o][1];
        if(v!=ff)
        {
            dfs(v,w);
            if(f[v][0]>=f[w][0])
            {
                f[w][1]=f[w][0],f[w][0]=f[v][0];
                if(f[v][1]>=f[w][1])f[w][1]=f[v][1];
            }
            else if(f[v][0]>=f[w][1])f[w][1]=f[v][0];
        }
        o_o=bi[o_o][0];
    }
}
void dfs1(int w,int ff,int d)
{
    fa[w]=ff,de[w]=d,si[w]=1,totc=(totc+f[w][0])%p,lc[w]=(lc[ff]+f[w][0])%p;
    int o_o=lst[w];
    while(o_o)
    {
        int v=bi[o_o][1];
        if(v!=ff)
        {
            dfs1(v,w,d+1);
            if(si[v]>si[so[w]])so[w]=v;
        }
        o_o=bi[o_o][0];
    }
}
void dfs2(int w,int t)
{
    to[w]=t,xh[w]=++dfn,dy[dfn]=w;
    qj[dfn][0]=(qj[dfn-1][0]+f[w][0])%p,qj[dfn][1]=(qj[dfn-1][1]+f[w][1])%p;
    qjf[dfn][0]=(qjf[dfn-1][0]+1ll*f[w][0]*f[w][0])%p,qjf[dfn][1]=(qjf[dfn-1][1]+1ll*f[w][1]*f[w][1])%p;
    if(so[w])dfs2(so[w],t);
    int o_o=lst[w];
    while(o_o)
    {
        int v=bi[o_o][1];
        if(v!=fa[w]&&v!=so[w])dfs2(v,v);
        o_o=bi[o_o][0];
    }
}
int jum(int x,int d)
{
    if(d==0)return 0;
    int fx=to[x];
    while(de[fx]>d)x=fa[fx],fx=to[x];
    return dy[xh[fx]+d-de[fx]];
}
int fin1(int w)//二分，fin2和fin3类似
{
	int x=w,fx=to[x];
	while(fx)
	{
		if(f[fx][0]>c[w])break;
		x=fa[fx],fx=to[x];
	}
	int lef=de[fx],rig=de[x]+1,mid;
	while(lef+1<rig)
	{
		mid=(lef+rig)>>1;
		if(f[dy[xh[fx]+mid-de[fx]]][0]==c[w])rig=mid;else lef=mid;
	}
	return rig;
}
int fin2(int w,int fw,int l)
{
	int x=w,fx=to[x];
	while(fx)
	{
		if(f[fx][de[fx]<fw?0:1]>l)break;
		x=fa[fx],fx=to[x];
	}
	int lef=de[fx],rig=de[x]+1,mid;
	while(lef+1<rig)
	{
		mid=(lef+rig)>>1;
		if(f[dy[xh[fx]+mid-de[fx]]][mid<fw?0:1]<=l)rig=mid;else lef=mid;
	}
	return rig;
}
int fin3(int w,int fw,int r)
{
	int x=w,fx=to[x];
	while(fx)
	{
		if(f[fx][de[fx]<fw?0:1]>=r)break;
		x=fa[fx],fx=to[x];
	}
	int lef=de[fx],rig=de[x]+1,mid;
	while(lef+1<rig)
	{
		mid=(lef+rig)>>1;
		if(f[dy[xh[fx]+mid-de[fx]]][mid<fw?0:1]<r)rig=mid;else lef=mid;
	}
	return lef;
}
int cx(int w,int op)
{
    if(w==0)return 0;
    int fw=to[w],x=0;
    while(fw)x=(1ll*x+qj[xh[w]][op]-qj[xh[fw]-1][op]+p)%p,w=fa[fw],fw=to[w];
    return x;
}
int cxf(int w,int op)
{
    if(w==0)return 0;
    int fw=to[w],x=0;
    while(fw)x=(1ll*x+qjf[xh[w]][op]-qjf[xh[fw]-1][op]+p)%p,w=fa[fw],fw=to[w];
    return x;
}
int main()
{
    n=dr(),q=dr(),opt=dr();
    for(int i=1;i<=n;i++)c[i]=dr();
    for(int i=1;i<n;i++)
    {
        int u=dr(),v=dr();
        tj(u,v),tj(v,u);
    }
    dfs(1,0),dfs1(1,0,1),dfs2(1,1);
    while(q--)
    {
        int l=(dr()+opt*lans)%n+1,r=(dr()+opt*lans)%n+1,a=(dr()+opt*lans)%n+1;
        if(l>r)swap(l,r);
        lans=1ll*(totc-lc[a])*(r-l+1)%p;//非a及其祖先部分答案
        int w1=fin1(a),w2=fin2(a,w1,l),w3=fin3(a,w1,r);
        //w1,w2,w3都是用来分段的，结合前文及后面代码可以确认其定义
        int ww1=jum(a,w1-1),ww2=jum(a,w2-1),ww3=jum(a,w3);
        lans=(lans+1ll*(de[a]-w2+1)*(l+r)%p*(r-l+1)%p*n2)%p;//x<=l部分答案
        if(w1<=w3)lans=(lans+1ll*(cx(ww3,1)-cx(ww1,1)+cx(ww1,0)+p)*(r-l+1))%p;
        else lans=(lans+1ll*cx(ww3,0)*(r-l+1))%p;//x>=r部分答案
        int qwq=0,wqw=0;//依次对应区间平方和跟区间和
        if(w1<=w3)qwq=(cxf(ww2,1)-cxf(ww3,1)+p)%p,wqw=(cx(ww2,1)-cx(ww3,1)+p)%p;
        else if(w1<w2)qwq=(1ll*cxf(ww2,1)-cxf(ww1,1)+cxf(ww1,0)-cxf(ww3,0)+2*p)%p,wqw=(1ll*cx(ww2,1)-cx(ww1,1)+cx(ww1,0)-cx(ww3,0)+2*p)%p;
        else qwq=(cxf(ww2,0)-cxf(ww3,0)+p)%p,wqw=(cx(ww2,0)-cx(ww3,0)+p)%p;
        lans=(lans+1ll*qwq*n2+1ll*(n2-l+p)*wqw+(1ll*r*r%p+r)*n2%p*(w2-w3-1))%p;//l<x<r部分答案
        printf("%d\n",lans);
    }
}
```


---

## 作者：a1a2a3a4a5 (赞：1)

# 题意：
一颗树，每个节点有一个权值 $c_i$。  
$val_i$：$i$ 为根的子树内所有 $c_i$ 的最大值。  
 $f(x,y)$：$c_{x}$ 改为 $y$ 后 $val_i$ 之和。  
每次询问给定 $(l,r,a)$ ，求 $\sum\limits_{i=l}^{r}{f(a,i)}$。
# 思路
首先一眼看出来几个性质：
1. 每次修改只会影响当前节点到根路径上的 $val_i$。
2. 当前节点到根路径上的 $val_i$ 是递增的。
3. 我们只关心子树最大值，但是如果 $c_x$ 修改了，不得不取**不严格次大值**。
4. 我们可以猜出当前节点到根路径的 $val_i$ 的变化是规律的，并且 $c_x$ 对当前节点到根路径 $val_i$ 的影响也是连续的（一个后缀）。
5. 询问满足可差分性，所以下面我们考虑 $ans_{[1,r]}-ans_{[1,l-1]}$ 。

话说回来，我们考虑当前节点到根路径上单独一个节点 $val_i$ 对 $ans_{[1,r]}$ 的贡献（这里的 $r$ 不是询问的 $r$，原谅我这一生不羁放纵，爱自由）：

性质三、四说了这么多，意思是：先刨除 $val_x$ 影响。（因为后面要单独考虑它）这里我们直接把 $c_x$ 作为子树最大值的节点和其他的分开处理，
对于前者，我们明显是要在非严格次大值的序列上统计，后者明显是在最大值序列（$val_i$）上统计。

兄弟们，我来盗个图：（此图甚好，想必此图原作者一定非常厉害！我对此图稍作解释，如果大佬介意可以私信骂我并让我删掉这个图，被骂我也是快哉快哉）
![](https://cdn.luogu.com.cn/upload/image_hosting/s83r18tb.png)  
犹如上图，上图何意？  
从左到右是从当前节点到根路径的刨除 $x$ 影响的子树最大值序列。  

为什么分成次大值和最大值区域？  
因为我们 $x$ 对最大值影响在这个序列上相当于一段前缀，也就是红色区域我们用次大值相当于刨除 $x$ 影响，蓝色区域则选取最大值即可，总之，刨除 $x$ 的影响。

上图出处：[![](https://cdn.luogu.com.cn/upload/usericon/751017.png)](https://www.luogu.com.cn/user/751017)

下面的 $val_i$ 默认为刨除了 $x$ 影响后的最大值。

当前节点到根路径上一个节点 $val_i$ 对 $ans_{[1,r]}$ 贡献：
- 若 $r\le val_i$，给 $ans_{[1,r]}$ 贡献 $r×val_i$。
- 若 $r>val_i $，那么相当于一个分段函数（左先平后增）：  
  关于这种类型的东西，我们画一个柱状图就好了（因为你画分段函数真的很容易算错，尤其是重叠的边）  
  会给 $ans_{[1,r]}$ 贡献：  
  $val_i×val_i+[r-(val+1)+1]×(val+1+r)÷2$  
  优秀的拆分：  
  $(r^2+val_i^2+r-val_i)÷2$

又因为 $r$ 在这次询问固定，$val_i$ 随着深度减小而递增，所以 $r\le val_i$ 和 $r>val_i$ 的区域在序列上是一个前缀一个后缀。

重剖 + 线段树就可以很快地到根路径查了，当然你会发现这题只有向上倍增，所以可以直接写倍增，写倍增也是快哉快哉，写重剖也是应在江湖悠悠。

小言如何维护：  
在线段树上维护 $val_i^2$、$val_i$、$次val_i^2$、$次val_i$，然后 $r$ 有关的东西都提出来处理。（原谅我的中文变量名，况且现在 c++20 可以用中文变量名了）。

# 算法流程（综上）：

把给你的树重链剖分，并在线段树上维护最大值平方和，最大值和，次大值平方和、次大值。

给你一组询问 $(l,r,a)$，答案为 $(ans_{[1,r]}-ans_{[1,l-1]})$。  
对于 $ans_{[1,k]}$，我们把先找到非严格次大值小于 $val_x$ 且深度最小的节点 $p$，对于 $a$ 到 $p$ 的路径我们用次大值维护的线段树数组计算，对于 $fa[p]$ 到根节点的路径我们用最大值维护的线段树数组计算。注意下面的 $val_i$ 一个路径指次大值一个路径指最大值，在这两条路径上，我们都倍增出深度最小的 $val_i< r$ 的位置 $q$，那么对于当前路径从这个路径起点 到 $q$ 查 $r>val_i $ 时的贡献，对于 $fa[q]$ 到这个路径终点查另一个丑式子（线段树查询）。  
最后别忘了是整棵树的 $val_i$ 之和（下面的 $val_i$ 都是子树最大值），所以要把除了 $a$ 到根路径的 $val_i$ 加上并乘 $(r-l+1)$，这里可以容斥：用全树的 $val_i$ 减去 $a$ 到根路径上的 $val_i$，然后再乘 $(r-l+1)$，再加上就行了。

至于倍增做法，非常简单，把上面的线段树都改成倍增数组，跳链都改成倍增就可以了，不得不说倍增是真简洁，至于为什么全篇尽是树剖……老师讲的树剖 QAQ，我这种蒟蒻也是倍增倍增~

# 代码
代码也是呼之欲出~
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int QAQ=5e5+7;
const ll mo=998244353;
int n,q,op,s[QAQ],ma[QAQ][21],cima[QAQ][21],ma2[QAQ][21],cima2[QAQ][21],f[QAQ][21],shen[QAQ],all,ni;
vector<int> dian[QAQ];
inline void dfs1(int x,int fa)
{
	shen[x]=shen[fa]+1,f[x][0]=fa,ma[x][0]=s[x],cima[x][0]=0;
	for(int i=1;i<=20;i++) f[x][i]=f[f[x][i-1]][i-1];
	for(int i=0;i<(int)dian[x].size();i++)
	{
		int v=dian[x][i];
		if(v==fa) continue;
		dfs1(v,x);
		if(ma[v][0]>ma[x][0]) cima[x][0]=max(ma[x][0],cima[v][0]),ma[x][0]=ma[v][0];
		else cima[x][0]=max(cima[x][0],ma[v][0]);
	}
	ma2[x][0]=1ll*ma[x][0]*ma[x][0]%mo,cima2[x][0]=1ll*cima[x][0]*cima[x][0]%mo;
	all=(all+ma[x][0])%mo;
}
inline void dfs2(int x,int fa)
{
	for(int i=1;i<=20;i++)
		ma[x][i]=(ma[x][i-1]+ma[f[x][i-1]][i-1])%mo,
		cima[x][i]=(cima[x][i-1]+cima[f[x][i-1]][i-1])%mo,
		ma2[x][i]=(ma2[x][i-1]+ma2[f[x][i-1]][i-1])%mo,
		cima2[x][i]=(cima2[x][i-1]+cima2[f[x][i-1]][i-1])%mo;
	for(int i=0;i<(int)dian[x].size();i++)
	{
		int v=dian[x][i];
		if(v==fa) continue;
		dfs2(v,x);
	}
}
inline int ksm(int shi,int k)
{
	ll da=1,x=shi;
	for(;k;k=k/2,x=x*x%mo) if(k&1) da=da*x%mo;
	return da;
}
inline int ans(int x,int r)
{
	if(!r) return 0;
	int p=x,o1=x,o2,o3,o4;
	for(int i=20;i>=0;i--) if(f[p][i]&&shen[f[p][i]]>=shen[1]&&cima[f[p][i]][0]<s[x]) p=f[p][i];
	o2=p,o3=f[p][0],o4=1;
	if(cima[p][0]>=s[x]) o2=-114514,o3=x;
	// 下面是次大值区域 
	int da=0,nw;
	int da2=0,len=0;
	if(o2!=-114514)
	{
		p=o1;
		for(int i=20;i>=0;i--)
			if(f[p][i]&&shen[f[p][i]]>=shen[o2]&&cima[f[p][i]][0]<r) p=f[p][i];
		if(cima[p][0]<r) nw=f[p][0];
		else nw=p;
		for(int i=20;i>=0;i--) if(f[nw][i]&&shen[f[nw][i]]>=shen[o2]) da=(da+1ll*r*cima[nw][i]%mo)%mo,nw=f[nw][i];
		if(nw==o2) da=(da+1ll*r*cima[nw][0]%mo)%mo,nw=f[nw][0];
		if(cima[p][0]<r)
		{
			nw=o1;
			for(int i=20;i>=0;i--) if(f[nw][i]&&shen[f[nw][i]]>=shen[p]) da2=(da2+cima2[nw][i]-cima[nw][i]+mo)%mo,len+=(1<<i),nw=f[nw][i];
			if(nw==p) da2=(da2+cima2[nw][0]-cima[nw][0]+mo)%mo,nw=f[nw][0],len++;
			da2=((da2+1ll*len*r*r%mo+1ll*len*r%mo)*ni)%mo;
			da=(da+da2)%mo;
		}
	}
	//下面是最大值区域 
	if(o3)
	{
		p=o3;
		for(int i=20;i>=0;i--)
			if(f[p][i]&&shen[f[p][i]]>=shen[o4]&&ma[f[p][i]][0]<r) p=f[p][i];
		if(ma[p][0]<r) nw=f[p][0];
		else nw=p;
		for(int i=20;i>=0;i--) if(f[nw][i]&&shen[f[nw][i]]>=shen[o4]) da=(da+1ll*r*ma[nw][i]%mo)%mo,nw=f[nw][i];
		if(nw==o4) da=(da+1ll*r*ma[nw][0]%mo)%mo,nw=f[nw][0];
		da2=0,len=0;
		if(ma[p][0]<r)
		{
			nw=o3;
			for(int i=20;i>=0;i--) if(f[nw][i]&&shen[f[nw][i]]>=shen[p]) da2=(da2+ma2[nw][i]-ma[nw][i]+mo)%mo,len+=(1<<i),nw=f[nw][i];
			if(nw==p) da2=(da2+ma2[nw][0]-ma[nw][0]+mo)%mo,nw=f[nw][0],len++;
			da2=((da2+1ll*len*r*r%mo+1ll*len*r%mo)*ni)%mo;
			da=(da+da2)%mo;
		}
	}
	//下面是统计其余部分。 
	da=(da+1ll*all*r%mo)%mo;
	nw=o1;
	for(int i=20;i>=0;i--)
		if(f[nw][i]&&shen[f[nw][i]]+1>=shen[1]) da=((da-1ll*r*ma[nw][i]%mo)%mo+mo)%mo,nw=f[nw][i];
	if(nw==1) da=((da-1ll*r*ma[nw][0]%mo)%mo+mo)%mo,nw=0;
	return da;
}
inline int read()
{
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x;
}
signed main()
{
	n=read(),q=read(),op=read();
	for(int i=1;i<=n;i++) s[i]=read();
	for(int i=1,u,v;i<n;i++) u=read(),v=read(),dian[u].push_back(v),dian[v].push_back(u);
	dfs1(1,0),dfs2(1,0),ni=ksm(2,mo-2);
	for(int i=1,shang=0,l,r,a;i<=q;i++)
	{
		l=read(),r=read(),a=read(),
		l=((l+op*shang)%n)+1,r=((r+op*shang)%n)+1,a=((a+op*shang)%n)+1;
		if(l>r) swap(l,r);
		printf("%d\n",(shang=(((ans(a,r)-ans(a,l-1))%mo+mo)%mo)));
	}
	return 0;
}
```
这个代码写得过于傻，导致被卡了，可以循环展开一下再加上评测机波动就可以过，但是为了美感（实际上也没有），所以我在这里放的是正解代码，我已经申请增大时限了。

---


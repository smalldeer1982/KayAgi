# [SCOI2016] 妖怪

## 题目描述


邱老师是妖怪爱好者，他有 $n$ 只妖怪，每只妖怪有攻击力 $\mathrm{atk}$ 和防御力 $\mathrm{dnf}$ 两种属性。邱老师立志成为妖怪大师，于是他从真新镇出发，踏上未知的旅途，见识不同的风景。

环境对妖怪的战斗力有很大影响，环境 $(a,b)$ 由 $a,b$ 两个参数定义，其中 $a,b$ 为**正实数**。在环境 $(a,b)$ 中，妖怪可以降低自己 $k\times a$ 点攻击力，提升 $k\times b$ 点防御力或者提升自己 $k\times a$ 点攻击力，降低 $k\times b$ 点防御力。其中 $k$ 为**任意实数**，但是 **$\mathrm{atk}$ 和 $\mathrm{dnf}$ 必须始终非负**。

妖怪在环境 $(a,b)$ 中的**战斗力** $\mathrm{strength}$ 定义为妖怪在该种环境中能达到的最大攻击力和最大防御力之和，即 $\mathrm{strength}(a,b)=\max(\mathrm{atk}(a,b))+\max(\mathrm{dnf}(a,b))$。

比如当前环境 $a=3,b=2$，那么攻击力为 $6$，防御力为 $2$ 的妖怪，能达到的最大攻击力为 $9$，最大防御力为 $6$。所以该妖怪在 $a=3,b=2$ 的环境下战斗力为 $15$。

因此，在不同的环境，战斗力最强的妖怪可能发生变化。

作为一名优秀的妖怪训练师，邱老师想发掘每一只妖怪的最大潜力，他想知道在**最为不利的情况下**，他的 $n$ 只妖怪能够达到的最强战斗力值。换言之，存在一组正实数 $(a,b)$ 使得 $n$ 只妖怪在该环境下最强战斗力最低，你需要输出这个最低的战斗力。

## 说明/提示


对于 $100\%$ 的数据，$1\le n\le 10^6$，$0\lt \mathrm{atk},\mathrm{dnf}\le 10^8$。

Statement fixed by Starrykiller.

## 样例 #1

### 输入

```
3
1 1
1 2
2 2```

### 输出

```
8.0000```

# 题解

## 作者：辰星凌 (赞：8)

# **【题解】妖怪 [SCOI2016] [P3291] [Bzoj4570]**

[$\mathcal{My}\ \mathcal{Blog}$](https://www.cnblogs.com/Xing-Ling/p/12756003.html)

传送门：[妖怪 $\text{[SCOI2016] P3291]}$](https://www.luogu.com.cn/problem/P3291) [$\text{[Bzoj4570]}$](http://lydsy.com/JudgeOnline/problem.php?id=4570)

## **【题目描述】**

给出 $n$ $(n\leqslant 10^6)$ 个点 $(x_i,y_i)$，设 $f_i(a,b)=x_i+y_i+\frac{bx_i}{a}+\frac{ay_i}{b}$，求出一组 $(a,b)$，使得 $\max\{f_{i\in[1,n]}(a,b)\}$ 最小，输出这个最小值。

## **【分析】**

感觉网上很多题解都没讲清楚。

### **【Solution #1】**

设 $k=\frac{b}{a}$，则上面的函数可以转换为 $f_i(k)=x_i+y_i+kx_i+\frac{y_i}{k}$ 。

求最大的最小很明显要二分，每次检查是否存在一个正实数 $k$ 满足所有点的 $f(k)$ 都小于等于 $mid$ 。即判断这个不等式组是否有解：

$\begin{cases}f_1(k)\leqslant mid\\f_2(k)\leqslant mid\\...\\f_n(k)\leqslant mid \end{cases}$

易知 $f_i$ 是一个双勾函数， 我们可以通过解关于 $k$ 的一元二次方程 $f_i(k)=mid$ 得出 $k$ 的一（两）个解 $r_1,r_2$ $(r_1\leqslant r_2)$，则当 $k\in[r_1,r_2]$ 时一定满足 $f_i(k)\leqslant mid$ 。对所有点求出 $k$ 的合法区间，最后判断是否存在交集即可。

时间复杂度：$O(n\log \inf)$，可能会 $TLE$，但卡一卡貌似能水过。

代码就不放了（~~懒~~）。

### **【Solution #2】**

**此为正解。**

设 $k=-\frac{b}{a}$，则 $f_i(k)=x_i+y_i-kx_i-\frac{y_i}{k}$（依然是双勾函数）。

假设有一条斜率为 $k$ 且经过了点 $(x_i,y_i)$ 的直线，则该直线点斜式可表示为 $y=kx+(y_i-kx_i)$，其横纵截距分别为 $\frac{kx_i-y_i}{k}$ 和 $y_i-kx_i$ 。

把这玩意儿加起来试试？

$(\frac{kx_i-y_i}{k})+(y_i-kx_i)=x_i+y_i-kx
_i-\frac{y_i}{k}$

发现其表示式和 $f_i(k)$ 一模一样！。

也就是说 $f_i(k)$ 的实质是斜率为 $k$ 且过点 $(x_i,y_i)$ 的直线横纵截距之和。

假设当前 $k$ 已经确定，则计算 $\max\{f_{i\in[1,n]}(k)\}$ 的过程就是个线性规划，易知该直线与上凸包的切点处 $f(k)$ 值最大。

反过来想，对于凸包上的每一个点 $i$，考虑在什么情况下 $f_i(k)$ 大于等于其他所以点的 $f(k)$，然后在合法情况中找到最小的 $f_i$ 来更新答案。设点 $i$ 在凸包上左右相邻两点与 $i$ 所形成的直线斜率分别为 $k_1,k_2$ $(k_1 > k_2)$，则仅当 $k$ 在 $(-\infty,k_2]\cup [k_1,\infty)$ 中取值时合法（只有此时才能满足直线与凸包切点恰好为 $i$）

已知当 $-k=\frac{y_i}{x_i}$ 时 $f_i$ 可取得最小值（均值不等式），如果 $k=-\frac{y_i}{x_i}$ 在上述合法值域内，那么 $f_i(-\frac{y_i}{x_i})$ 就可以作为一个答案的候选项。

如果 $k=-\frac{y_i}{x_i}$ 不在上述合法区域内，那么就要想办法找到其他 $k$ 使得 $f_i(k)$ 尽量小，由于双勾函数的性质， $k$ 越接近 $-\frac{y_i}{x_i}$ 函数值就越小，所以直接取 $k=kr$ 和 $k=kl$ 的情况进行决策即可。

除了求上凸包要排序，决策都是线性的，时间复杂度：$O(n\log n)$ 。

（毒瘤 $OI$ 的算几依旧是这么毒瘤，不过这次代码长度倒是挺良心的）

## **【Code】**

```cpp
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<cmath>
#define LD double
#define LL long long
#define Vector Point
#define Re register int
using namespace std;
const int N=1e6+3;
const LD eps=1e-8;
inline int dcmp(LD a){return a<-eps?-1:(a>eps?1:0);}
int n,t;LD ans=1e18;
inline void in(Re &x){
    int f=0;x=0;char c=getchar();
    while(c<'0'||c>'9')f|=c=='-',c=getchar();
    while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
    x=f?-x:x;
}
struct Point{int x,y;Point(Re X=0,Re Y=0){x=X,y=Y;}}P[N],cp[N];
inline LL Cro(Vector a,Vector b){return (LL)a.x*b.y-(LL)a.y*b.x;}
inline Vector operator-(Vector a,Vector b){return Vector(a.x-b.x,a.y-b.y);}
inline bool cmp(const Point &A,const Point &B){return A.x!=B.x?A.x<B.x:A.y>B.y;}
inline LD getk(Point a,Point b){return (LD)(a.y-b.y)/(a.x-b.x);}
inline LD calc(Point a,LD k){return dcmp(k)?a.x+a.y-a.x*k-a.y/k:1e18;}
int main(){
//    freopen("123.txt","r",stdin);
    in(n);
    for(Re i=1;i<=n;++i)in(P[i].x),in(P[i].y);
    sort(P+1,P+n+1,cmp);
    for(Re i=1;i<=n;++i){
        while(t>1&&Cro(cp[t]-cp[t-1],P[i]-cp[t-1])>=0)--t;
        cp[++t]=P[i];
    }
    for(Re i=1;i<=t;++i){
        LD k=-sqrt((LD)cp[i].y/cp[i].x);
        if((i==1||dcmp(k-getk(cp[i],cp[i-1]))<=0)&&(i==t||dcmp(k-getk(cp[i],cp[i+1])>=0)))ans=min(ans,calc(cp[i],k));
        if(i>1)ans=min(ans,calc(cp[i],getk(cp[i],cp[i-1])));
        if(i<t)ans=min(ans,calc(cp[i],getk(cp[i],cp[i+1])));
    }
    printf("%.4lf\n",ans);
}
```


---

## 作者：mydiplomacy (赞：5)

首先二分答案，将问题转化为可行性问题，对于一个$mid$值，只需要判断“是否存在$(a,b)$，使所有妖怪的战斗力均$<=mid$”。如果存在，说明答案不大于$mid$。如果不存在，说明答案不小于$mid$。

对于一个妖怪，设它的$atk$为$x$，$dnf$为$y$。则它在环境$(a,b)$下的最大攻击力是$x+y*a/b$。最大防御力是$y+x*b/a$。于是可得它在环境$(a,b)$下的战斗力是$x+y+x*(b/a)+y*(a/b)$。

由上式可以发现，一个妖怪在环境$(a,b)$下的战斗力只与$x$、$y$和$(a/b)$的值相关。设$t=b/a$，则战斗力可以化为$x+y+x*t+y*(1/t)$。因为$x$、$y$都是给定的固定值，所以$x$、$y$都可以看做是常数，而能改变战斗力的变量只有正实数$t$。

接下来，我们考虑$t$应该如何取值才能使战斗力不大于$mid$。根据上式，有

$x*(b/a) + y*(a/b) + x + y <= mid$

即 $x*t + y*(1/t) <= mid-x-y$

由于$t$为正数，所以 $x*t^2 - (mid-x-y)*t + y <=0$。

设$d=mid-x-y$，则 $x*t^2 - d*t + y <=0$

注意到这是一个关于$t$的一元二次不等式。所以可以根据求根公式得到解集。

$\delta = d^2 - 4*y*x$

$t_1 = (d-\sqrt{\delta})/(2*x)$

$t_2 = (d+\sqrt{\delta})/(2*x)$

$t_1 <= t <= t_2$

所以我们分别针对$n$个妖怪求出$t$的取值范围，这$n$个取值范围如果存在交集，证明存在$(a,b)$使所有妖怪的战斗力均$<=mid$。

效率为$O(n*log_2{max(atk,dnf)})$

这种方法具体实现时，需要注意常数。

---

## 作者：NicoDafaGood (赞：3)

**我看没人发c++的题解就来水一波**

先把坐标建出来排好，然后用凸包跑一遍，更新答案就好了

附代码：

```cpp
//%std
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<algorithm>
#include<cmath>
#include<vector>
#include<queue>
#include<stack>
using namespace std;
#define lovelive long long
int poker[1000100],point1=0;
double xie[1000100];
int point2=0;
long double top2()
{
  return xie[point2-1];
}
int empty2()
{
  return point2;
}
void pop2()
{
  --point2;
}
void push2(double x)
{
  xie[point2]=x;
  ++point2;
}
int top1()
{
  return poker[point1-1];
}
int empty1()
{
  return point1;
}
void pop1()
{
  --point1;
}
void push1(int x)
{
  poker[point1]=x;
  ++point1;
}//手写的栈要快一点吧？（自己在机子上评测时间很危险）
void get(int &x)
{
    char c=getchar(); 
    x=0;
    while(c < '0' || c > '9') 
      c=getchar();
    while(c <= '9' && c >= '0') 
      x=x*10+c-48,c=getchar();
}
int pnt=1;
struct pokemon{
    int atk,dnf;
}a[1000100]; 
bool comp(pokemon x1,pokemon x2)
{
  if(x1.dnf!=x2.dnf)
    return x1.dnf<x2.dnf;
  return x1.atk>x2.atk;
}
int main()
{
//  freopen("monster.in","r",stdin);
//  freopen("monster.out","w",stdout);
  int n,amax=1;
  double ans=200000000000;
  int pnt=1;
  scanf("%d",&n);  
  for(int i=1;i<=n;i++)
    get(a[i].atk),get(a[i].dnf); 
  sort(a+1,a+n+1,comp);    
  for(int i=2;i<=n;i++)
    if(a[amax].atk<=a[i].atk)
      amax=i;
  push1(amax);      
  push2(0);
  double k1,k2,k3;
  for(int i=amax+1;i<=n;i++)
    {
      int a1=top1(),sum;
      k1=(a[a1].atk-a[i].atk)*1.0/(a[a1].dnf-a[i].dnf);
      if(k1>=0)
        continue;
      while(k1>=top2())
        {
          pop1();
          a1=top1();
          k1=(a[a1].atk-a[i].atk)*1.0/(a[a1].dnf-a[i].dnf);
          pop2();
        }
      push1(i);
      push2(k1); 
    }
    k1=-sqrt(a[top1()].atk*1.0/a[top1()].dnf);
  while(point1)
    {
      int p2=top1();
      double ans0;
      pop1();
      k3=k1;
      k1=0;
      if(point1)
        k1=top2();
      k2=-sqrt(a[p2].atk*1.0/a[p2].dnf);
      if(k1>=k2&&k2>=k3)
        ans0=1.0*a[p2].atk+1.0*a[p2].dnf-k2*a[p2].dnf-a[p2].atk/k2;
      else
      {
        if(k1!=0)
          ans0=1.0*a[p2].atk+1.0*a[p2].dnf-k1*a[p2].dnf-a[p2].atk/k1;
        if((ans0>1.0*a[p2].atk+1.0*a[p2].dnf-k3*a[p2].dnf-a[p2].atk/k3||k1==0)&&k1>k3)
          ans0=1.0*a[p2].atk+1.0*a[p2].dnf-k3*a[p2].dnf-a[p2].atk/k3;
      }
      if(ans>ans0)
        ans=ans0;  
      pop2();
    }
  printf("%.4f",ans);
  return 0;
} 
```

---

## 作者：forest114514 (赞：2)

### P3291 [SCOI2016] 妖怪

想我这样的蒟蒻也只会用不优的方法来做的……

首先发现本质不同的环境就是形如 $(1,k)$ 的样子，此时妖怪战斗力为 $x+\frac{y}{k}+y+kx=x+y+(kx+\frac{y}{k})$。

发现 $(kx+\frac{y}{k})$ 就是著名的双钩函数，是一个经典的下凸函数，现在显然是若干下凸函数取 $\max$，求这个新函数的 $\min$。

首先下凸函数取 $\max$ 后还是下凸函数，对于凸函数，可以三分 $k$，求最值，时间 $O(n\log V)$。

这里的话精度容易炸，我大概要三分 $100$ 次左右或者精度设 $10^{-10}$ 才能过，还跑得很慢，有概率原来考场上过不了。

> upd：经过详细测试，不开 O2 是过不了的，所以这个做法仅供参考……

```cpp
const int N=1e6+100;
int n,x[N],y[N];
double check(double K){
	double res=0;
	rep(i,1,n) res=max(res,K*x[i]+y[i]/K+x[i]+y[i]);
	return res;
} 
bool _ED;
signed main(){
	fprintf(stderr,"%.20lf MB\n",(&_ST-&_ED)/1048576.0);
	//ios::sync_with_stdio(false);
	//cin.tie(0);cout.tie(0);
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	read(n);
	rep(i,1,n)read(x[i],y[i]);
	double l=1e-6,r=1e8,ans=inf;
	while(r-l>eps){
		double mid1=l+(r-l)/3,mid2=r-(r-l)/3;
		double fl=check(mid1),fr=check(mid2);
		ans=min({ans,fl,fr});
		if(fl<fr-eps) r=mid2;
		else l=mid1;
	}
	ans=min(ans,check((l+r)/2));
	printf("%.4lf\n",ans);
	fprintf(stderr,"%.4lf s\n",1.0*clock()/CLOCKS_PER_SEC);
	return 0;
}
```

---

## 作者：爱喝敌敌畏 (赞：2)

# 题意
[题意](https://www.luogu.com.cn/problem/P3291)

# 做法
前两种做法参考博客：https://www.luogu.com.cn/blog/ChenXingLing/solution-p3291

这里就不再赘述，不过需要提一下，第二种做法感觉有点问题的地方是：$k$应该在$[k2,k1]$范围内。（当然，仅仅个人观点，不一定正确）

然后我自己手艹出一个做法？

首先，已知对于$(a,b)$，可以化作$(1,\frac{b}{a})$的形式，不妨化为：$(1,k)$，这样，就顺利的化成了一个元的形式了。

那么对于一只妖怪，其战斗力函数为：$a+b+ak+\frac{b}{k}$。

不难发现，如果对于两个妖怪：$a_{1}≤a_2,b_1≤b_2$那么第一个妖怪绝对没有第二个妖怪好，此时，自动把第一个妖怪舍弃，然后再对于$a$进行升序排序，这样，妖怪就是$a$值递增，$b$值递减了。

考虑第一个妖怪在哪个大于第二个妖怪：
设$a'=a_{1}-a_{2},b'=b_{1}-b_{2}$
那么不等式方程则为：
$a'k+\frac{b'}{k}+a'+b'≥0$
$a'k^2+(a'+b')k+b'≥0$
$k∈[-1,0)∩(0,-\frac{b'}{a'}]$，由于$k>0$，所以$k∈(0,-\frac{b'}{a'}]$。

也就是说，第一个妖怪在这个区间都比第二个区间好。

那么只要我们能够找到这些妖怪各自的最强的区间，然后对他们的函数在他们区间中的最小值取最小值即可。

但是如何证明一个函数的$k$存在一个取值区间这个函数值大于其他的函数值呢？

再次证明一个东西：$\frac{b_1-b_2}{a_1-a_2}>\frac{b_1-b_3}{a_1-a_3}$可以推导出：$\frac{b_2-b_3}{a_2-a_3}<\frac{b_{1}-b_2}{a_1-a_2}$。
证明过程就是交叉相乘，后面发现两条式子可以化成一条式子，那么这条式子说明了什么了？下面设$A_i$为第一个函数，$jd()$为交点，说明$jd(A_1,A_3)<jd(A_1,A_2)$，那么$jd(A_2,A_3)<jd(A_1,A_2)$，简单来说就是$A_2$的$k$不可能存在一个取值区间使得这个函数值大于其他函数值。

同理，只要用栈维护每个函数，弹出时判断与$A_1$的交点即可，然后$A_i$的$k$的取值区间则在：[$jd(A_{i-1},A_i)$,$jd(A_{i},A_{i+1})$]范围内。

至于函数的最小值，额，直接均值不等式，这个不再多讲了。

时间复杂度：$O(nlogn)$

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define  N  1100000
using  namespace  std;
template<class  T>
inline  T  mymin(T  x,T  y){return  x<y?x:y;}
template<class  T>
inline  T  mymax(T  x,T  y){return  x>y?x:y;}
int  n;
struct  node
{
	double  a,b;
	node(double  x=0,double  y=0){a=x;b=y;}
}a[N],b[N];int  m;
inline  node  operator-(node  x,node  y){return  node(x.a-y.a,x.b-y.b);}
inline  double  jd(node  x)//求交点
{
	return  -x.b/x.a;//(x.a)k^2+(x.a+x.b)k+x.b   k=-x.b/x.a（其中x.a<0,x.b>0）
}
inline  double  getval(node  x,double  k){return  x.a+x.b+x.a*k+x.b/k;}
inline  double  mmin(node  x,double  l,double  r)
{
	double  minx=sqrt(x.b/x.a),ans;//最小的数字 
	if(l<=minx  &&  minx<=r  ||  (l<=minx  &&  r<0))ans=minx;
	else  if(minx<l)ans=l;
	else  ans=r;
	return  getval(x,ans);
}
inline  bool  cmp(node  x,node  y){return  x.a==y.a?x.b>y.b:x.a<y.a;}
int  main()
{
	scanf("%d",&n);
	for(int  i=1;i<=n;i++)scanf("%lf%lf",&a[i].a,&a[i].b);
	sort(a+1,a+n+1,cmp);
	int  now=a[1].a;
	b[m=1]=a[1];
	for(int  i=2;i<=n;i++)
	{
		if(a[i].a!=now)
		{
			now=a[i].a;
			while(m  &&  b[m].b<=a[i].b)m--;//维护a单调递增，b单调递减
			while(m>1  &&  jd(b[1]-b[m])>=jd(b[1]-a[i]))m--;
			b[++m]=a[i];
		}
	}
	if(m==1)printf("%.4lf\n",getval(b[1],sqrt(b[1].b/b[1].a)));
	else
	{
		double  ans=mymin(mmin(b[1],-1,jd(b[1]-b[2])),mmin(b[m],jd(b[m-1]-b[m]),-1));
		for(int  i=2;i<m;i++)ans=mymin(mmin(b[i],jd(b[i-1]-b[i]),jd(b[i]-b[i+1])),ans);
		printf("%.4lf\n",ans);
	}
	return  0;
}
```

---

## 作者：nofind (赞：2)

## [题意](https://www.luogu.com.cn/problem/P3291)

设攻击力为$x$，防御力为$y$。

我们要找到一组$(a,b)$，使得$\max_{1\leqslant i\leqslant n}(1+\frac{b}{a})x+(1+\frac{a}{b})y$最小。

观察这个式子，我们发现它相当于用一条$k=-\frac{b}{a}$的直线去过一个点$(x,y)$，使得横纵截距之和最大。因此我们发现答案必定在上凸包的右半部分。

那么现在就是一个斜率的问题了，我们考虑每一个点，其作为最大值（即用直线切凸包时被切到）的斜率是一个区间，即与其凸包上左右两点之间的斜率这个区间。

这里借用一下网上的一篇博客的图：  
### [原地址](https://blog.csdn.net/a_crazy_czy/article/details/51934762)  
![](https://cdn.luogu.com.cn/upload/image_hosting/1iu1naas.png)  
对于第一个点，其作为最大值的斜率即为深绿色区域。

现在我们考虑对于一个点$(x,y)$作为最大值时，当$k$为多少时其取最小值，根据均值不等式：  
$\frac{b}{a}x+\frac{a}{b}y+x+y\geqslant2\sqrt{xy}+x+y,\frac{b}{a}x=\frac{a}{b}y$  
因此：$k=-\frac{b}{a}=-\sqrt{\frac{y}{x}}$。  
我们判断一下$k$是否合法即可，不合法就取端点，这样便能找到极值来更新答案。

code:
```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1000010;
const double inf=1e9;
int n;
double ans=inf;
struct Point
{
    ll x,y;
    inline ll len(){return sqrt(x*x+y*y);}
    Point operator+(const Point a)const{return (Point){x+a.x,y+a.y};}
    Point operator-(const Point a)const{return (Point){x-a.x,y-a.y};}
    Point operator*(const int k){return (Point){x*k,y*k};}
    Point operator/(const int k){return (Point){x/k,y/k};}
    ll operator*(const Point a)const{return x*a.y-y*a.x;}
    ll operator&(const Point a)const{return x*a.x+y*a.y;}
}a[maxn],sta[maxn];
inline ll read()
{
    char c=getchar();ll res=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9')res=res*10+c-'0',c=getchar();
    return res*f;
}
inline Point getvec(Point a,Point b){return b-a;}
inline bool cmp(Point a,Point b){return a.x==b.x?a.y<b.y:a.x<b.x;}
inline double getk(Point a){return -sqrt((double)a.y/a.x);}
inline double getk(Point a,Point b){return (a.x==b.x)?inf:1.0*(b.y-a.y)/(b.x-a.x);}
inline double calc(Point a,double k){return k>=0?inf:a.x+a.y+(-k)*a.x+1/(-k)*a.y;}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)a[i].x=read(),a[i].y=read();
	sort(a+1,a+n+1,cmp);
	int top=0;
	for(int i=1;i<=n;i++)
	{
		while(top>1&&getvec(sta[top-1],sta[top])*getvec(sta[top-1],a[i])>=0)top--;
		sta[++top]=a[i];
	}
	if(top<2)
	{
		printf("%.4lf",calc(sta[1],getk(sta[1])));
		return 0;
	}
	double kl,kr,k;
	kr=getk(sta[1],sta[2]);k=getk(sta[1]);
	if(k>=kr)ans=min(ans,calc(sta[1],k));
	kl=getk(sta[top-1],sta[top]);k=getk(sta[top]);
	if(k<=kl)ans=min(ans,calc(sta[top],k));
	ans=min(ans,calc(sta[top],kl));
	for(int i=2;i<top;i++)
	{
		kl=getk(sta[i-1],sta[i]),kr=getk(sta[i],sta[i+1]),k=getk(sta[i]);
		ans=min(ans,calc(sta[i],kl));
		if(k<=kl&&k>=kr)ans=min(ans,calc(sta[i],k));
	}
	printf("%.4lf",ans);
	return 0;
}
```


---

## 作者：ywy_c_asm (赞：2)

竟然没有二分的题解……

首先这个答案显然可以二分，然后我们就相当于找一个正实数对$(a,b)$使得对所有的$atk_i$和$dnf_i$都有$atk_i+\frac a bdnf_i+dnf_i+\frac b a atk_i<=mid$，实际上可以简化为一个关于$x$的不等式组$atk_ix+\frac {dnf_i}x<=mid-atk_i-dnf_i$是否存在正数解。

显然判断它有解就是把每个不等式独立求出解集（一段连续的区间）然后看交集是否不为空集即可。我开始的时候想了一种极为垃圾的做法，就是这是个**对勾函数**，他在正半轴上是个单峰下凸函数，我们先把极小值点三分出来，然后这个极小值就已经比不等式右边的大了直接无解，然后我们从极小值点向左向右各做两次二分把解集端点二分出来（显然极值点两侧就是单调的了）。然后复杂度带了两个$log$其中一个底数还是$1.5$……T的比$O(n^2)$还慢……

~~可能我直接想二分套三分这么垃圾的解法大概是因为我在数学老师讲对勾函数的时候睡着了……~~咱们既然知道这个是对勾函数就可以直接把解集算出来了……我们就相当于解一个一元二次方程$atk_ix^2-(mid-atk_i-dnf_i)x+dnf_i=0$，先用对勾函数的极值公式$x_{min}=\sqrt{\frac b a}$（还要啥三分……）判断一下是否存在解然后直接解即可。

还有这方法极为卡精度，我们二分的时候要把eps设为1e-9，别的设为1e-14然后卡着A了……

上代码~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#define double long double
#define abs(_o) ((_o<0)?-(_o):_o)
using namespace std;
namespace ywy{
	inline int get(){
		int n=0;char c;while((c=getchar())||23333){
			if(c>='0'&&c<='9')break;if(c=='-')goto s；
		}n=c-'0';while((c=getchar())||23333){
			if(c>='0'&&c<='9')n=n*10+c-'0';else return(n);
		}s:while((c=getchar())||23333){
			if(c>='0'&&c<='9')n=n*10-c+'0';else return(n);
		}
	}
	double a[1000001],b[1000001];
	inline unsigned char check(int n，double mid){
		double rl=0,rr=1e18;
		for(register int i=1;i<=n&&(rl<=rr||abs(rl-rr)<=1e-14);i++){
			double x=sqrt(b[i]/a[i]);
			if(a[i]*x+b[i]/x>(mid-a[i]-b[i]))return(0);
			double c=mid-a[i]-b[i],d=sqrt(c*c-4*a[i]*b[i]);
			rl=max(rl,(c-d)/(2*a[i]));
			rr=min(rr,(c+d)/(2*a[i]));
		}
		return(rl<=rr||abs(rl-rr)<=1e-14);
	}
	void ywymain(){
		int n=get();
		for(register int i=1;i<=n;i++)a[i]=get(),b[i]=get();
		double ans=0,l=0,r=10000000000;
		while(r-l>=1e-9){
			double mid=(l+r)/2;
			if(check(n,mid))ans=mid,r=mid;else l=mid;
		}
		printf("%.4Lf\n",ans);
	}
}
int main(){
	ywy::ywymain();return(0);
}
```

---

## 作者：ButterflyDew (赞：2)

玄妙...盲猜一个结论，然后过了，事后一证，然后假了，数据真水

首先要最小化
$$
\max_{i=1}^n (1+k)x_i+(1+\frac{1}{k})y_i
$$
$k$是大于0的正实数

最大值显然在上凸包上，先把上凸包搞出来

然后每个点成为最大值时，$k$都有个取值范围（就是它左边或者右边的点成为最大值时）

然后对每个点用均值不等式得到最小值为

$$\begin{aligned}z&=kx+\frac{1}{k}y+x+y\\&\ge2\sqrt{xy}+x+y\\\end{aligned}$$

在$kx=\frac{y}{k}$取到最小值，即$k=\sqrt{\frac{y}{x}}$

然后这个点成为最大值时，可能取到最小值的就两个端点和这个最小值点（如果这个最小值可以取的话）

最开始我没注意可以不等式，凭感觉随便取了个$k=\frac{y}{x}$，居然也过了，真神奇

------

**Code:**

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
using std::min;
const int N=1e6+10;
const double eps=1e-8;
struct Vector
{
    double x,y;
    Vector(){}
    Vector(double X,double Y){x=X,y=Y;}
    Vector friend operator -(Vector a,Vector b){return Vector(a.x-b.x,a.y-b.y);}
    bool friend operator <(Vector a,Vector b){return fabs(a.x-b.x)<eps?a.y>b.y:a.x<b.x;}
}bee[N],s[N];
double Cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}
int n,tot;
double get(Vector a,Vector b)
{
    double k=(b.y-a.y)/(b.x-a.x);
    if(fabs(k)<eps) return -eps;
    if(1/fabs(k)<eps) return -1/eps;
    return k;
}
double cal(double k,Vector a)
{
    if(k<eps) return 1e18;
    return (1+k)*a.x+(1+1/k)*a.y;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%lf%lf",&bee[i].x,&bee[i].y);
    std::sort(bee+1,bee+1+n);
    bee[++n]=Vector(0,bee[1].y);
    ++n,bee[n]=Vector(bee[n-2].x,0);
    std::sort(bee+1,bee+1+n);
    for(int i=1;i<=n;i++)
    {
        while(tot>1&&Cross(bee[i]-s[tot],s[tot]-s[tot-1])<0) --tot;
        s[++tot]=bee[i];
    }
    double ans=1e18;
    for(int i=2;i<tot;i++)
    {
        double kl=-get(s[i],s[i-1]),kr=-get(s[i+1],s[i]),k=sqrt(s[i].x/s[i].y);
        ans=min(ans,min(cal(kl,s[i]),cal(kr,s[i])));
        if(kl<=k&&k<=kr)
            ans=min(ans,cal(k,s[i]));
    }
    printf("%.4f\n",ans);
    return 0;
}
```

---

## 作者：Ac_forever (赞：1)

## 不正常人思路：模拟退火~~不~~好题。

思路很简单，每次随机 $(a,b)$ 并 $O(n)$ 计算答案，套一个退火模板即可。

时间复杂度很大，要吸氧才能过。

```cpp

#include<climits>
#include<cstdio>
#include<ctime>
#include<cmath>
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
#define N 1000001
using namespace std;
int n,atk[N],dnf[N];
typedef long long ll;
inline double Rand(){return rand()*2-RAND_MAX;}
double calc(ll a,ll b){
	double maxn=0;
	register int i;
	for(i=1;i<=n;i++)
		maxn=max(maxn,(double)(atk[i]*1.0/a*b+dnf[i]*1.0/b*a+atk[i]+dnf[i]));
	return maxn;
}
inline ll read()
{
    ll x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0' && ch<='9')
        x=x*10+ch-'0',ch=getchar();
    return x;
}
void solve(){
	double T=1e6,ans=calc(1,1),lans=ans;
	ll x=1,y=1;
	// printf("%.lf\n",ans);
	while(T>1e-6){
		ll x1=x+Rand()*T;
		ll y1=y+Rand()*T;
		if(x1==0)x1=1;
		if(y1==0)y1=1;
		if(x1<0)x1=-x1;
		if(y1<0)y1=-y1;
		double qq=calc(x1,y1),delta=lans-qq;
		if(ans>qq)ans=qq;
		if(lans>qq||exp(delta/T)*RAND_MAX>rand())x=x1,y=y1,lans=qq;
		T*=0.9;
	}
	printf("%.4lf",ans);
}
int main(){
	srand(time(NULL));
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		atk[i]=read(),dnf[i]=read();
	solve();
}
```

## 正常人思路
由题意，我们可以得到这样一个式子：
$ans=\max_{i=1}^{i \leq n}(\frac{atk_i}{a} \times b+ \frac{dnf_i}{b} \times a+atk_i+dnf_i)$
 
 这是不难理解的吧？
 因为任意时刻 $atk$ 与 $dnf$ 均不能为负。
 
 可以想到的是二分一个 $mid$，判断是否有满足的 $(a,b)$，则要使 $mid$ 满足条件，必有 $\frac{atk_i}{a} \times b+ \frac{dnf_i}{b} \times a+atk_i+dnf_i \leq mid$。
 
 设 $k= \frac{b}{a}$，则原式 $=atk_i \times k + \frac{dnf_i}{k} +atk_i+dnf_i \leq mid$。
 
 将 $mid$ 移至右边，两边同时乘上 $k$，得到：$atk_i k^2+(atk_i+dnf_i-mid) k+dnf_i \leq 0$
 
 发现这是一个关于 $k$ 的一元二次不等式，解出 $k$ 的范围，若对于 $i (1 \leq i \leq n)$ 中的所有 $k$ 有公共解集，则此 $mid$ 合法，统计答案。 
 代码就不放了。

---

## 作者：a154051 (赞：1)

[博客链接](https://a154051.gitee.io/2021/09/01/solution-P3291-yao-guai/)

蒟蒻不会凸包，于是用**模拟退火**过了这道题。

如果你还不会模拟退火，可以看看我之前写的[学习笔记](https://a154051.gitee.io/2021/02/08/mo-ni-tui-huo-bi-ji/)。

## 题意

来自[辰星凌的题解](https://www.luogu.com.cn/blog/ChenXingLing/solution-p3291)：

> 给出 $n$ 个点 $(x_i,y_i)$，设 $f_i(a,b)=x_i+y_i+\frac{bx_i}{a}+\frac{ay_i}{b}$，求出一组 $(a,b)$，使得 $\max\{f_{i\in[1,n]}(a,b)\}$ 最小，输出这个最小值。

## 做法

正常模拟退火流程，每次随机生成两个数 $(a,b)$，暴力遍历一遍所有点计算出当前的答案，与上一次的答案比较。

蒟蒻一开始只是想骗点分，没想到拿了 $80$ 分，于是就进入了痛苦的调参过程。（注：没有在洛谷提交，洛谷数据不全。）

最初提交时总是第 $7$ 个点错，后来有一次分比较低，但是第 $7$ 个点对了，我比较了一下认为是初始温度的问题，初始温度低会导致生成出来的数的范围小，而那个点最优情况下的 $(a,b)$ 大于这个范围，所以就一直错。

于是稍微修改一下参数就 $A$ 了，最后一共提交了 $172$ 次...

不开 $O2$ 会 $T$，时间复杂度 $O(\text{玄学})$。

## 代码

```cpp
#include <bits/stdc++.h>
#define rd t*(rand()*2-RAND_MAX)
#define max(x,y) (x<y?y:x)  //这里是个小优化，会快一点
using namespace std;
typedef long long ll;
const double eps=1e-6,down=0.89;
const int mn=1e6+7;
int n;
double x[mn],y[mn];
double sol(double a,double b)  
{
    double rs=0;
    for(int i=1;i<=n;++i)
    {
        double tmp=x[i]+y[i]+x[i]/a*b+y[i]/b*a;
        rs=max(rs,tmp);
    }
    return rs;
}
int main()
{
    srand(154051);
    scanf("%d",&n);
    for(int i=1;i<=n;++i)  scanf("%lf%lf",&x[i],&y[i]);
    ll a=1,b=1;
    double ans,minn;
    minn=ans=sol(1,1);
    for(double t=1100000;t>eps;t*=down)
    {
        ll aa=a+rd,bb=b+rd;  
        if(aa==0)  aa++;
        if(bb==0)  bb++;
        if(aa<0)  aa=-aa;
        if(bb<0)  bb=-bb;
        double rs=sol(aa,bb);  
        if(minn>rs)  minn=rs;
        if(rs<ans||exp((ans-rs)/t)*RAND_MAX>rand())  
        {
            ans=rs;
            a=aa;b=bb;
        }
    }
    printf("%.4f",minn);
    return 0;
}
```

---

## 作者：ZlycerQan (赞：1)

/\*
luogu P3291 [SCOI2016]妖怪


凸包
    
我果然还是naive

看见这题就想二分

结果惨挂

    
做了凸包后就想三分

又挂了。。

     
完美落入了每个坑。。果然还是自己太菜

    
对于每个妖怪，其在(a,b)时的最大战力为过当前点斜率为(-b/a)的直线的截距之和

最大的战力就是最外面的那条直线

     
对n个点做一个上凸包

最大值一定在凸包的右上部分(自行脑补)

    
那么这些点的斜率都有着一个范围ki-1<ki<ki+1

    
那么战力就变为了一个双钩函数

讨论求最值即可

\*/
```cpp
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cmath>

void read (long long &now)
{
    register char word = getchar ();
    int temp = 0;
    for (now = 0; !isdigit (word); word = getchar ())
        if (word == '-')
            temp = 1;
    for (; isdigit (word); now = now * 10 + word - '0', word = getchar ());
    if (temp)
        now = -now;
}

#define INF 1e9

struct Point
{
    long long x, y;
    
    Point (long long __x, long long __y) : x (__x), y (__y) {}
    Point () {}
    
    bool operator < (const Point &now) const
    {
        return this->x == now.x ? this->y < now.y : this->x < now.x;
    }
    
    Point operator - (const Point &now) const
    {
        return Point (this->x - now.x, this->y - now.y);
    }
};

inline long long Cross (const Point &A, const Point &B)
{
    return A.x * B.y - A.y * B.x;
}

#define Max 1000250

inline double Calculate (const Point &now, const double &k)
{
    return k >= 0 ? INF : (double) now.x + now.y + - k * now.x - now.y / k;
}

inline double Get_point_k (const Point &now)
{
    return -sqrt ((double) now.y / now.x);
}

inline double Get_line_k (const Point &A, const Point &B)
{
    return (A.x ^ B.x) ? ((double)(A.y - B.y) / (double) (A.x - B.x)) : INF;
}

int Get_convex_Hull (Point *point, int N, Point *Stack)
{
    std :: sort (point + 1, point + N + 1);
    
    register int top = 0;
    for (int i = 1; i <= N; ++ i)
    {
        for (; top > 1 && Cross (Stack[top] - Stack[top - 1], point[i] - Stack[top - 1]) >= 0; -- top);
        Stack[++ top] = point[i];
    }
    return top;
}

Point yukari[Max], Stack[Max];

int main (int argc, char *argv[])
{
    register int i;
    int N;
    scanf ("%d", &N);
    for (i = 1; i <= N; ++ i)
        read (yukari[i].x), read (yukari[i].y);
    
    int M = Get_convex_Hull (yukari, N, Stack);
    
    if (M < 2)
    {
        printf ("%.4lf", Calculate (Stack[1], Get_point_k (Stack[1])));
        return 0;
    }
    double k, _k, __k, Answer = INF;
    
    k = Get_point_k (Stack[1]);
    __k = Get_line_k (Stack[1], Stack[2]);
    
    if (k >= __k)
        Answer = std :: min (Answer, Calculate (Stack[1], k));
    
    k = Get_point_k (Stack[M]);
    _k = Get_line_k (Stack[M - 1], Stack[M]);
    
    if (k <= _k)
        Answer = std :: min (Answer, Calculate (Stack[M], k));
    Answer = std :: min (Answer, Calculate (Stack[M], _k));
    
    for (i = 2; i < M; ++ i)
    {
        _k = Get_line_k (Stack[i - 1], Stack[i]);
        __k = Get_line_k (Stack[i], Stack[i + 1]);
        
        k = Get_point_k (Stack[i]);
        
        Answer = std :: min (Answer, Calculate (Stack[i], _k));
        if (k <= _k && k >= __k)
            Answer = std :: min (Answer, Calculate (Stack[i], k));
    }
    printf ("%.4lf", Answer);
    return 0;
}
```

---

## 作者：jklover (赞：0)

- 正解应该是 $O(nlogn)$ 的凸包,但被我的 $O(100n)$ 的三分水过去了.
- 记 $x=\frac b a$  ,显然有 $strength_i=ATK_i+DFN_i+ATK_i\ \cdot\ x+DFN_i\ \cdot\ \frac 1 x$.
- 每个$strength$ 关于 $x$ 是一个单峰函数,取最大值形成的函数也是一个单峰函数,三分 $x$ 即可.
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define mp make_pair
#define pii pair<int,int>
inline int read()
{
	int x=0;
	bool pos=1;
	char ch=getchar();
	for(;!isdigit(ch);ch=getchar())
		if(ch=='-')
			pos=0;
	for(;isdigit(ch);ch=getchar())
		x=x*10+ch-'0';
	return pos?x:-x;
}
const double eps=1e-9;
const int T=100;
int dcmp(double x)
{
	return fabs(x)<eps?0:(x>0?1:-1);
}
double Max(double a,double b)
{
	return dcmp(a-b)>=0?a:b;
}
double Min(double a,double b)
{
	return dcmp(a-b)>=0?b:a;
}
const int MAXN=1e6+10;
int n;
double p[MAXN],q[MAXN];
double ans=1e18;
double calc(double x)
{
	double res=0;
	for(int i=1;i<=n;++i)
		{
			double str=p[i]+q[i]+p[i]*x+q[i]/x;
			res=Max(res,str);
		}
	return res;
}
double mx=0;
int main()
{
	n=read();
	for(int i=1;i<=n;++i)
		{
			scanf("%lf%lf",&p[i],&q[i]);
			mx=Max(mx,q[i]);
		}
	double L=eps*1000,R=1e8;
	for(int t=1;t<=T;++t)
		{
			double x1=L+(R-L)/3;
			double x2=R-(R-L)/3;
			double f1=calc(x1);
			double f2=calc(x2);
			if(dcmp(f1-f2)>=0)
				{
					ans=Min(ans,f2);
					L=x1;
				}
			else
				{
					ans=Min(ans,f1);
					R=x2;
				}
		}
	printf("%.4lf\n",ans);
	return 0;
}
```


---


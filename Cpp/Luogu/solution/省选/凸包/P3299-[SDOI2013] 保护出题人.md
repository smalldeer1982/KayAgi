# [SDOI2013] 保护出题人

## 题目描述

出题人铭铭认为给 SDOI2012 出题太可怕了，因为总要被骂，于是他又给 SDOI2013 出题了。


参加 SDOI2012 的小朋友们释放出大量的僵尸，企图攻击铭铭的家。而你作为 SDOI2013 的参赛者，你需要保护出题人铭铭。


僵尸从唯一一条笔直道路接近，你们需要在铭铭的房门前放置植物攻击僵尸，避免僵尸碰到房子。


第一关，一只血量为 $a_1$ 点的僵尸从距离房子 $x_1$ 米处匀速接近，你们放置了攻击力为 $y_1$ 点/秒的植物进行防御；第二关，在上一关基础上，僵尸队列排头增加一只血量为 $a_2$ 点的僵尸，与后一只僵尸距离 $d$ 米，从距离房 $x_2$ 米处匀速接近，你们重新放置攻击力为 $y_2$ 点/秒的植物；……；第 $n$ 关，僵尸队列共有 $n$ 只僵尸，相邻两只僵尸距离 $d$ 米，排头僵尸血量为 $a_n$ 点，排第二的僵尸血量 $a_{n-1}$，以此类推，排头僵尸从距离房子 $x_n$ 米处匀速接近，其余僵尸跟随排头同时接近，你们重新放置攻击力为 $y_n$ 点/秒的植物。


每只僵尸直线移动速度均为 $1$ 米/秒，由于植物射击速度远大于僵尸移动速度，可忽略植物子弹在空中的时间。所有僵尸同时出现并接近，因此当一只僵尸死亡后，下一只僵尸立刻开始受到植物子弹的伤害。


游戏得分取决于你们放置的植物攻击力的总和 $\sum \limits _{i=1} ^{n} y_i$，和越小分数越高，为了追求分数上界，你们每关都要放置攻击力尽量小的植物。


作为 SDOI2013 的参赛选手，你们能保护出题人么？

## 说明/提示

第一关：距离房子 $3$ 米处有一只血量 $3$ 点的僵尸，植物最小攻击力为 $1.00000$；  
第二关：距离房子 $1$ 米处有一只血量 $1$ 点的僵尸、$3$ 米处有血量 $3$ 点的僵尸，植物最小攻击力为 $1.33333$；  
第三关：距离房子 $8$ 米处有一只血量 $10$ 点的僵尸、$10$ 米处有血量 $1$ 点的僵尸、$12$ 米处有血量 $3$ 点的僵尸，植物最小攻击力为 $1.25000$；  
第四关：距离房子 $8$ 米处有一只血量 $4$ 点的僵尸、$10$ 米处有血量 $10$ 点的僵尸、$12$ 米处有血量 $1$ 点的僵尸、$14$ 米处有血量 $3$ 点的僵尸，植物最小攻击力为 $1.40000$；  
第五关：距离房子 $3$ 米处有一只血量 $2$ 点的僵尸、 $5$ 米处有血量 $4$ 点的僵尸、$7$ 米处有血量 $10$ 点的僵尸、$9$ 米处有血量 $1$ 点的僵尸、$11$ 米处有血量 $3$ 点的僵尸，植物最小攻击力为 $2.28571$。  
植物攻击力的最小总和为 $7.26905$。

对于 $100\%$ 的数据， $ 1\le n \le 10^5  ,1 \le d,x,a \le 10^{12} $ 。

## 样例 #1

### 输入

```
5  2
3  3
1  1
10 8
4  8
2  3```

### 输出

```
7```

# 题解

## 作者：ModestCoder_ (赞：19)

这并不是一道dp

对于每个$i$，答案是$ans_i=max(\frac{sum_i-sum_{j-1}}{x_i+(i-j)d})$
其中$sum_i=\sum_{j=1}^{i}a_j$

可以斜率优化，因为答案的表达式可以看成$(x_i+i*d,sum_i)(j*d,sum_{j-1})$两点的斜率

发现对于每个$i$,$(x_i+i*d,sum_i)$是个定点

所以对于点$(j*d,sum_{j-1})$维护一个下凸包，二分查找凸包中与定点相连斜率最大值

把每一个$i$的答案累加起来即可

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 100010
#define int long long
using namespace std;
struct data{
	int x, y;
}stk[maxn];
int n, D, sum[maxn], top;
double Ans;

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

double slope(data x, data y){ return 1.0 * (x.y - y.y) / (x.x - y.x); }

signed main(){
	n = read(), D = read();
	stk[0] = (data){0, 0};
	for (int i = 1; i <= n; ++i){
		int x = read(), y = read(); sum[i] = sum[i - 1] + x;
		data tmp = {i * D, sum[i - 1]};
		while (top && slope(stk[top - 1], stk[top]) > slope(stk[top], tmp)) --top;
		stk[++top] = tmp;
		tmp = (data){y + i * D, sum[i]};
		int l = 1, r = top, ans = 0;
		while (l <= r){
			int mid = (l + r) >> 1;
			if (slope(stk[mid], tmp) > slope(stk[mid - 1], tmp)) ans = mid, l = mid + 1; else r = mid - 1;
		}
		Ans += slope(stk[ans], tmp);
	}
	printf("%.0f\n", Ans);
	return 0;
}
```


---

## 作者：Mihari (赞：8)

# 题目

[传送门](https://www.luogu.com.cn/problem/P3299)

补充一个数据范围：

对于 $30\%$ 的数据，保证 $n\le 10^3$；

对于 $50\%$ 的数据，保证 $n\le 10^4$；

对于 $70\%$ 的数据，保证 $n\le 10^5,1\le d,x,a \le 10^6$；

对于所有数据，保证 $n\le 10^6,1\le d,x,a\le 10^{12}$；

# 题解

明白题意——不存在伤害溢出，即豌豆射手可以在一秒钟内，前 $0.3s$ 攻击前一个僵尸，后 $0.7s$ 攻击另外一个僵尸。

形象地说，这是高级豌豆射手了，发射的是激光......

先分析如何拿到部分分：

## 对于前一组数据

由于是 $n\le 10^3$，我们可以考虑一下暴力，首先 $n$ 的枚举是不可或缺的，而后，对于每一组的答案来说，单调性是显然的，那么我们可以考虑二分一个 $x$，用 $n$ 来检查这个 $x$ 的合法性，总复杂度在 $\mathcal O(n^2\log a)$.

## 对于前两组数据

往深挖掘一下题目性质，我们发现这个二分是根本没有必要的。

对于第 $i$ 组的第 $j$ 只僵尸（显然有 $j\le i$），显然要打倒它需要先将其前面的所有僵尸以及它自己的血量减到 $0$，而它需要走过的距离为 $x_i+d\times (i-j+1)$，由于我们要使攻击力最小，那么就需要它刚刚好在走到门口的时候将其打死，那么一只僵尸的最低要求即为
$$
\frac{\sum_{t=j}^ia_t}{x_i+d\times (i-j+1)}
$$
考虑用前缀和来简化柿子，记 $pre_t=\sum_{i=1}^ta_i$，而我们要让每只僵尸都满足要求，那么我 们要取所有僵尸中的最大值，那么对于每一组，实际上我们要求的是
$$
\max \left (\frac{pre_i-pre_{j-1}}{x_i+d\times (i-j+1)} \right )
$$
可以发现这样做其实是 $\mathcal O(n^2)$ 的，刚好过得去 $n\le 10^4$ 的数据。

## 对于正解

继续分析柿子，将柿子变换一下
$$
\begin{aligned}
\frac{pre_i-pre_{j-1}}{x_i+d\times (i-j+1)}&=\frac{pre_i-pre_{j-1}}{x_i+d\times i-d\times (j-1)}
\end{aligned}
$$
发现一些相同的地方，比如 $i$ 和 $j-1$，这个时候要斜率联系起来了，将柿子中的两个部分分别看成两个点 $(x_i+d\times i,pre_i)$ 与 $(pre_{j-1},d\times (j-1))$，那么这个柿子其实就是这俩点连线的斜率，最后我们要求的其实就是斜率的最大值。

发现后面一个点，也就是 $(pre_{j-1},d\times (j-1))$ 与 $i$ 无关，即**它在组数变化时独立，只和僵尸本身的信息有关**，那么我们可以考虑将所有僵尸保存在一个数据结构中，每次移动一个 $i$ 时，就是加入一个僵尸的信息（其信息为一个点 $(pre_{i-1},d\times (i-1))$），也相当于在一个点集中加入一个点，而询问，就是在所有僵尸的点构成的一个点集中询问定点与点集中的斜率最大值。

考虑使用凸包维护点集，应该维护其上凸性，下面给出证明：

假设存在这样的情况：

<div align="center">
    <img src="http://61.186.173.89:2019/2020/08/26/be28b5904ed63.png">
</div>

可以看出，这是一个下凸包，和我们所说的相反，现在我们要证明，点 $2$ 是不可能成为答案的，对于我们的目标点（也就是点 $(pre_{j-1},d\times (j-1))$）我们分开讨论它在凸包下与凸包上

- 目标点在凸包下方，那么它和每个点的连线是这个样子：

<div align="center">
    <img src="http://61.186.173.89:2019/2020/08/26/7ef542333a6a6.png">
</div>

可以看出，$i-1$ 这条线的斜率大于 $i-2$；

- 目标点在凸包上方，连线是这个样子

<div align="center">
    <img src="http://61.186.173.89:2019/2020/08/26/eadbf3a792dc9.png">
</div>

显然 $i-3$ 斜率比 $i-2$ 大；

两种情况 $2$ 都不可能成为答案，那么加点时我们维护一个上凸包即可。

对于寻找斜率最大值，显然可以用二分来做（机房大佬们人均三分，但是我似乎有什么误解），二分寻找斜率最大值即可。

由于每个僵尸只会加进去一次，也只会出来一次，所以均摊是 $\mathcal O(1)$ 的，主要还是询问的二分，最终复杂度为 $\mathcal O(n\log n)$.

# 代码

```cpp
https://www.cnblogs.com/Arextre/p/13567206.html
```



---

## 作者：foreverlasting (赞：8)

[题面](https://www.luogu.org/problemnew/show/P3299)

~~全宇宙都会三分就我不会？~~

斜率优化。

首先导出式子。第$i$关的最小攻击力显然等于$max(\frac {sum[i]-sum[j-1]} {x[i]+d*(i-j)})$，$sum[i]$表示前$i$个僵尸的生命值总和。然后观察一下式子，发现可以把这条式子理解为$(x[i]+d*i,sum[i])$与$(d*j,sum[j-1])$两个点的斜率。于是以后者维护一个下凸包，二分一下斜率最大的位置就好了。

code:
```
//2018.10.18 by ljz
#include<bits/stdc++.h>
using namespace std;
#define res register LL
#define LL long long
#define inf 0x3f3f3f3f
#define eps 1e-15
inline LL read(){
    res s=0;
    bool w=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return w?-s:s;
}
inline void _swap(res &x,res &y){
    x^=y^=x^=y;
}
inline LL _abs(const res &x){
    return x>0?x:-x;
}
inline LL _max(const res &x,const res &y){
    return x>y?x:y;
}
inline LL _min(const res &x,const res &y){
    return x<y?x:y;
}
const LL N=1e5+10;
namespace MAIN{
    LL n,d;
    LL a[N],x[N],sum[N];
    typedef pair<LL,LL> Pair;
#define mp make_pair
#define fi first
#define se second
    inline double slope(const Pair &x,const Pair &y){
        return 1.0*(x.se-y.se)/(x.fi-y.fi);
    }
    Pair Q[N];
    LL top;
    double ans;
    inline void MAIN(){
        n=read(),d=read();
        for(res i=1;i<=n;i++)a[i]=read(),x[i]=read(),sum[i]=sum[i-1]+a[i];
        for(res i=1;i<=n;i++){
            Pair tmp=mp(d*i,sum[i-1]);
            while(top&&slope(Q[top],Q[top-1])>slope(tmp,Q[top]))top--;
            Q[++top]=tmp;
            tmp=mp(x[i]+d*i,sum[i]);
            res l=1,r=top,ret;
            while(l<=r){
                res mid=(l+r)>>1;
                (slope(Q[mid],tmp)>slope(Q[mid-1],tmp))?l=mid+1,ret=mid:r=mid-1;
            }
            ans+=slope(Q[ret],tmp);
        }
        printf("%.0lf\n",ans);
    }
}
int main(){
    MAIN::MAIN();
    return 0;
}
```

---

## 作者：BriMon (赞：6)

[这里](https://www.cnblogs.com/BriMon/p/9079365.html)查看效果更好；

欢迎互关；


题面看的一脸懵逼， 一副不可做的样子；


因为当时翻看各种题解并没有懂， 所以决定写一篇较为详细的题解， 让不会的小伙伴们更快的理解， 少走弯路；

 
 

题面不解释， 玩过植物大战僵尸的都理解(没有玩过现在去)；


 

由简单的分析， 我们可以得到， f[i] = max((sum[i] - sum[j-1]) / (d *(i - j) + x[i]))， f[i]表示第i关的最小需要的攻击力；


很清晰？ 就是j到i的所有僵尸的生命值之和， 除以第j个僵尸到你的距离， 结果不就是攻击力嘛， 最后求max(因为对于每个僵尸j都不能让他走到你跟前)， 美滋滋；


 

O(n^2)妥妥的50分， 但问题来了, 我们可是要AK的人；

 

仔细看看刚才的方程， 你想到了什么？ 斜率！！！


我们令X1 = d * i + x[i], Y1 = sum[i], Y2 = sum[j-1], X2 = d *j;

 

原式子下面可以变成 ： d * i - d * (j - 1) - d + x[i];

 

我们可以用单调栈维护一个右下凸壳，维护(sum[i-1]  -  sum[j-1])  /  (d * i - d * j)， 为什么要这么维护？


我们考虑之前的式子， 我们的i在求它的时候是不变的， 所以我们把i想象成一个定点， 令i的坐标为(d * i + x[i] - d, sum[i]);


然后我们加入点i， 我们要求的攻击力其实就是i和当前凸包上的点的斜率最大值；


因为sum[i](点i的纵坐标) - sum[j-1](凸包上维护的点的纵坐标) = sum[i] - sum[j-1](要求的式子的上半边)；


d * i + x[i](点i的横坐标) - d *j (凸包上维护的点的横坐标) = d *(i - j) + x[](要求的式子的下半边);


 

刚好满足！！！！


 哇塞我们好像有O（n）的方法了！！
 

然而是ma？

我们好像还要求点i与凸包上的点的斜率最大值！

哦...这不是熟悉的三分法求凸函数极值的变式嘛！

所以加上用三分， 总复杂度O(nlogn?);

稳！！！

对了这道题要用long long， 别怪我没提醒你， 要不打死都想不出来；

 

最后奉上代码（码风奇特切勿吐槽）
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <queue>
#include <cctype>
#include <cmath>
using namespace std;
#define int long long

inline char nc()
{
    static const int BS = 1 << 22;
    static unsigned char buf[BS], *st, *ed;
    if (st == ed) ed = buf + fread(st = buf, 1, BS, stdin);
    return st == ed ? EOF : *st++;
}
#define nc getchar
inline int read()
{
    int ch = nc();
    int res = 0;
    bool flag = 0;
    while (!isdigit(ch)) 
    {
        if (ch == '-') flag = 1;
        ch = nc();
    }
    while (isdigit(ch))
    {
        res = (res << 3) + (res << 1) + (ch - '0');
        ch = nc();
    }
    return flag ? -res : res;
}

const int N = 1e5+5;
#define eps 1e-6
#define lldou long double

int n, d;
int dis[N], sum[N];

inline int X1(int i)
{
    return d * i + dis[i];
}

inline int Y1(int i)
{
    return sum[i];
}

inline int X2(int i)
{
    return d * i;
}

inline int Y2(int i)
{
    return sum[i-1];
}

inline long double slope1(int i, int j)
{
    return (double)((double)(Y2(i) - Y2(j)) / (double)(X2(i) - X2(j)));/* - dis[i]*/
}

inline long double slope(int i, int j)
{
    return (double)((double)(Y1(i) - Y2(j)) / (double)(X1(i) - X2(j)));
}

int sta[N], top; // 单调栈 

signed main()
{
    n = read(), d = read();
    
    for (register int i = 1 ; i <= n ; i ++)
    {
        int x = read();
        sum[i] = sum[i-1] + x;
        dis[i] = read();
    }
    
    lldou ans = 0.0;
    
    for (register int i = 1 ; i <= n ; i ++)
    {
        while (top > 1 and slope1(i, sta[top]) <= slope1(sta[top], sta[top-1])) top--;
        sta[++top] = i;
        int l = 1, r = top, mid1, mid2;
        while (l < r)
        {
            mid1 = (l + r + l) / 3;
            mid2 = (r + r + l) / 3;
            if (mid1 == mid2) break;
            if (slope(i, sta[mid1]) > slope(i, sta[mid2])) r = mid2 - 1;
            else l = mid1 + 1;
        }
        ans += (lldou)max(slope(i, sta[l]), slope(i, sta[r]));
    //    printf("%Lf\n", (lldou)max(slope(i, sta[l]), slope(i, sta[r])));
    }
    
    printf("%.0Lf\n", ans);
    return 0;
}
```


---

## 作者：Rorschachindark (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P3299)
# 题目大意
懒得加了
# 思路
感觉大家都没有说明怎么推出那个式子的，我这里来补一发吧（感觉除了那个东西这个题就没有难点了啊）话说这个题还是在 SH 看了题解之后提示我才想出来，果然我是个废物。

首先，我们考虑对于第 $m$ 轮，对于第 $i$ 个僵尸，设植物伤害为 $h$,我们可以得出（$a_i,x_i$ 分别表示当前轮第 $i$ 个僵尸的距离和血量）：

$$
\left\{\begin{array}{l}
a_1\times h\ge x_1\\
d\times h+a_1\times h-x_1\ge x_2\\
d\times h+d\times h+a_1\times h-x_1-x_2\ge x_3\\
\vdots\\
((i-1)\times d+a_1)\times h-x_1-x_2-\cdots-x_{i-1}\ge x_i
\end{array}\right.
$$

然后我们就发现我们的 $h$ 需要取 

$$\max_{i=1}^{m} \{\frac{\sum_{j=1}^{i} x_j}{(i-1)\times d+a_1}\}$$

不过这个题目里面每次加是加在前面，所以实际上是：

$$\max_{i=1}^{m}\{\frac{suf_i-suf_{m+1}}{(m-i)\times d+a_m}\}$$

$suf_i$ 表示 $\sum_{j=i}^{n} x_j$ 。

然后我们发现这个式子可以看成 $(a_i+m\times d,-suf_{m+1})$ 与 $(i\times d,-suf_i)$ 之间的斜率。

然后你发现求斜率最大值的话，最优点一定在凸包上。通过实验发现我们需要维护的是一个上凸壳，又因为横坐标单调递增，所以单调栈维护再二分即可。
# $\texttt{Code}$
```cpp
#include <bits/stdc++.h>
using namespace std;

#define Int register int
#define int long long
#define MAXN 100005

template <typename T> inline void read (T &t){t = 0;char c = getchar();int f = 1;while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}while (c >= '0' && c <= '9'){t = (t << 3) + (t << 1) + c - '0';c = getchar();} t *= f;}
template <typename T,typename ... Args> inline void read (T &t,Args&... args){read (t);read (args...);}
template <typename T> inline void write (T x){if (x < 0){x = -x;putchar ('-');}if (x > 9) write (x / 10);putchar (x % 10 + '0');}

int n,d,top,head = 1,tail,q[MAXN],A[MAXN],X[MAXN],pre[MAXN];

struct Vector{
	double x,y;
	friend double Slope (Vector a,Vector b){return (a.y - b.y) / (a.x - b.x);}
}a[MAXN];

signed main(){
	read (n,d);
	for (Int i = 1;i <= n;++ i) read (X[i],A[i]);
	for (Int i = n;i >= 1;-- i) pre[i] = pre[i + 1] + X[i];
	for (Int i = 1;i <= n;++ i) a[i] = Vector{i * d,-pre[i]};
	double res = 0;
	for (Int m = 1;m <= n;++ m){
		while (head < tail && Slope (a[q[tail - 1]],a[q[tail]]) >= Slope (a[q[tail]],a[m])) -- tail;q[++ tail] = m;
		Vector now = Vector {m * d + A[m],-pre[m + 1]}; 
		int l = head,r = tail,ans;
		while (l <= r){
			int mid = (l + r) >> 1;
			if (Slope (a[q[mid]],now) >= Slope (a[q[mid + 1]],now)) r = mid - 1,ans = mid;
			else l = mid + 1;
		}
		res += Slope (a[q[ans]],now);
	}
	write ((int)round(res)),putchar ('\n');
	return 0; 
}
```

---

## 作者：King丨帝御威 (赞：2)

这个题目实际上可以转化为这个题目：就是类似于求人在什么时候影子最长。
![典型的求人在何时影子最长题目](https://i.loli.net/2018/10/17/5bc6fbddbd893.bmp)

设f[i]打通第i关需要的最小攻击力。。然后可以得到，f[i] = max((sum[i] - sum[j-1]) / (d *(i - j) + x[i]))， 然后令点A的坐标为(d * i + x[i] - d, sum[i]);然后加入点i，f[i]其实就是i和当前凸包上的点的斜率最大值；这个时候就转化成了刚刚说的那个问题。然后三分求解，单调栈维护一下即可。

~~附蒟蒻的代码~~：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define dl double
#define maxn 100000+1
using namespace std;
int n,top,l,r,mid1,mid2;
dl x[maxn],y[maxn],sum[maxn],a[maxn],xx[maxn],ans,d;
dl calc(int i,int j)         //推导的辣个式子。
{
	return (sum[i]-y[j])/(xx[i]+i*d-x[j]); 
}
bool check(dl x1,dl y1,dl x2,dl y2,dl x,dl y) 
{
	return (x1-x)*(y2-y)-(x2-x)*(y1-y)<0;  //判断是否合法。
}
int main()
{
	cin>>n>>d;
	for(int i=1;i<=n;++i)
	{
		cin>>a[i]>>xx[i];
		sum[i]=sum[i-1]+a[i];      //前缀和维护。
	}
	for(int i=1;i<=n;++i)
	{
		for(;top>1&&check(x[top],y[top],i*d,sum[i-1],x[top-1],y[top-1]);--top);
		y[++top]=sum[i-1]; x[top]=i*d;
		for(l=1,r=top,mid1=l+(r-l)/3,mid2=r-(r-l)/3;r-l>2;mid1=l+(r-l)/3,mid2=r-(r-l)/3)   //三分过程。
		if(calc(i,mid1)<calc(i,mid2))
		  l=mid1;
		else
		  r=mid2;
		dl maxx=-100;
		for(int j=1;j<=r;++j)
		maxx=max(maxx,calc(i,j)); 
		ans+=maxx;               //累加最大值。
	}
	printf("%0.0lf\n",ans);
	return 0;
}
```

**注意要开double ！！！！！**

---

## 作者：Ameyax (赞：2)


首先我们要推出一个方程


$y_i=\max \limits_{1 \leq j \leq i} ((sum_i-sum_{j-1}) / (x_i+d \times (i-j))$


可以理解为一个僵尸的血量是他及之前僵尸血量的和，然后保证每个僵尸在持续攻击下不能走进门。


优秀的$n^2$算法$get$。


考虑如何优化


发现上面那个式子很像一个斜率式。


令$P(x_i+i\times d, sum_i)$ $Q(j \times d,sum_{j-1})$


就把问题转化成了当前点$P$与之前所有的$Q$所确定的直线的最大斜率。


随手画个图，显然$k_{PQ_j}$在下凸壳上是单峰函数，三分凸壳找极值。


```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX = 110000;
#define LL long long
LL n, d, top, sta[MAX];
LL x[MAX], a[MAX], sum[MAX];
double ans;
double calc(int i, int j)
{
    return 1.0 * (sum[i - 1] - sum[j - 1]) / (1.0 * (i * d - j * d));
}
double calc2(int i, int j)
{
    return 1.0 * (sum[i] - sum[j - 1]) / (1.0 * (x[i] + i * d - j * d));
}
int main()
{
    scanf("%lld%lld", &n, &d);
    for (int i = 1; i <= n; i++)
    {
        scanf("%lld%lld", &a[i], &x[i]);
        sum[i] = sum[i - 1] + a[i];
    }
    for (int i = 1; i <= n; i++)
    {
        while (top > 1 && calc(i, sta[top]) < calc(sta[top], sta[top - 1])) top--;
        sta[++top] = i;
        int l = 1, r = top;
        while (l != r)
        {
            int x = (r - l + 1) / 3;
            int mid1 = l + x - 1, mid2 = l + 2 * x - 1;
            if (mid1 == mid2) break;
            if (calc2(i, sta[mid1]) < calc2(i, sta[mid2])) l = mid1 + 1;
            else r = mid2 - 1;
        }
        ans += max(calc2(i, sta[l]), calc2(i, sta[r]));
    }
    printf("%.0lf\n", ans);
    return 0;
}
```

---

## 作者：C20203030 (赞：1)

## 一、题目
[点此看题](https://www.luogu.com.cn/problem/P3299)
## 二、解法
感觉这道题网上讲解不是特别清楚，我来补一发详细讲解吧，因为作者也是花了好久才搞懂。

首先把题目所求转化成形式化表达（其中$s$是生命值$a$的前缀和）：
$$\sum_{i=1}^n\max_{j=1}^i \frac{s[i]-s[j-1]}{x[i]+(i-j)d}$$
是不是感觉难以优化，我们改换一种写法：
$$\sum_{i=1}^n\max_{j=1}^i \frac{s[i]-s[j-1]}{x[i]+id-jd}$$
有点眼熟，可以转化为两个点$(x[i]+id,s[i]),(jd,s[j-1])$直线的斜率，对于后者，我们维护一个凸包，为什么要维护凸包呢？因为原问题在二维平面上是一个顶点到若干个点的最大斜率问题，看下图！
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200825185544663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0MyMDIwNDR6eHk=,size_16,color_FFFFFF,t_70#pic_center)
可见在定点到凸包上点的斜率与凸包相切的时候斜率是最大的，当这样的点往前取和往后取答案都会减少，这种单调性给了我们快速解决问题的可能。补充一个问题：为什么凸包要维护单调递增的呢？我们还是结合图来分析，比如下面就是一个斜率单调递减的图，你仔细看看就知道中间的点永远不可能是答案。
![在这里插入图片描述](https://img-blog.csdnimg.cn/2020082519212251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0MyMDIwNDR6eHk=,size_16,color_FFFFFF,t_70#pic_center)


接着单调性往下讲，我们可以考虑用二分来算答案，由于最优解是在中间的，我们二分出$mid$，比较它和$mid-1$跟定点连成的斜率谁是更大的，如果$mid$更大，那么往右边分，记录答案，否则往左边分。那么时间复杂度就做到了$O(n\log n)$，还有不懂请看代码。

```cpp
#include <cstdio>
const int M = 100005;
#define int long long
#define db double
int read()
{
	int x=0,f=1;char c;
	while((c=getchar())<'0' || c>'9') {if(c=='-') f=-1;}
	while(c>='0' && c<='9') {x=(x<<3)+(x<<1)+(c^48);c=getchar();}
	return x*f;
}
int n,d,top,s[M],a[M],b[M];db ans;
db slope(int x,int y)
{
	return 1.0*(a[x-1]-a[y-1])/(x*d-y*d);
}
signed main()
{
	n=read();d=read();
	for(int i=1;i<=n;i++)
	{
		a[i]=a[i-1]+read();
		b[i]=read();
	}
	s[0]=1;//防RE 
	for(int i=1;i<=n;i++)
	{
		while(top>1 && slope(s[top],s[top-1])>slope(i,s[top])) top--;
		s[++top]=i;int t=1,l=1,r=top;
		while(l<=r)
		{
			int mid=(l+r)>>1;
			db x1=1.0*(a[i]-a[s[mid]-1])/(b[i]+(i-s[mid])*d);
			db x2=1.0*(a[i]-a[s[mid-1]-1])/(b[i]+(i-s[mid-1])*d);
			if(x1>=x2) l=mid+1,t=mid;
			else r=mid-1;
		}
		ans+=1.0*(a[i]-a[s[t]-1])/(b[i]+(i-s[t])*d);
	}
	printf("%.0f\n",ans);
}
```


---

## 作者：disangan233 (赞：1)

### 暴力做法1

冷静分析一波题意后，发现豌豆射手的攻击方法很清奇。  

我们把题意简述一下：给你 $a_i$，$x_i$，让你求出下列柿子的值：  
  
$$\sum_{i=1}^{n} \mathrm{max}\left\{ \dfrac {\sum_{k=1}^{j} a_k}{x_j} \bigg| j\in \{ 1\cdots i\} \right\}$$  

于是我们就可以暴力求这个柿子了！时间复杂度 $O\left(\frac{n^2}{2}\right)$，期望得分 $60~pts$。  
  
```cpp  
#define re register int
for(re i=1;i<=n;i++) sum[i]=sum[i-1]+a[i];
for(re i=1;i<=n;i++)
{
    double now=0;
    for(re j=1;j<=n;j++) now=max(now,1.0*sum[j]/x[j]);
    ans+=now;
}
```    
    
### 暴力做法2   

考虑优秀的 dp，令 $f_i$ 为第$i$天的最大攻击力，$s_i$ 为 $a_i$ 的前缀和，那么可以写出状态转移方程：

$$f_i=\mathrm{max}\left\{ \dfrac {s_i-s_{j-1}}{d\times (i-j)+ x_i} \Big| j\in \{ 1\cdots i\} \right\}$$  

时间复杂度同上为$O\left(\frac{n^2}{2}\right)$，期望得分$60~pts$。 
  
### 优秀的做法(100pts)

考虑优化上面的 dp。

冷静分析一波后，设 $tmp=di+x_i$，我们发现这个方程可以变成这个样子：

$$f_i=\max \left\{ \frac {s_i-s_{j-1}}{tmp-dj} \Big| j\in \{ 1\cdots i\} \right\}$$   

我们发现这个 dp 可以斜率优化，将柿子转化为 $(tmp,s_i)$ 和 $(dj,s_{j-1})$ 两个点之间的斜率，维护一个下凸包，采用二分斜率的方法来找答案。  
    
### Code
  
    
```cpp
#include<bits/stdc++.h>
using namespace std;
#define re register int
#define ak *
#define ll long long
#define db double
char qwq;
inline char getch()
{
    static char buf[20000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,20000,stdin),p1==p2)?EOF:*p1++;
}
inline ll read()
{
    ll cz=0,ioi=1;qwq=getch();
    while(qwq<'0'||qwq>'9') ioi=qwq=='-'?~ioi+1:1,qwq=getch();
    while(qwq>='0'&&qwq<='9') cz=(cz<<3)+(cz<<1)+(qwq^48),qwq=getch();
    return cz ak ioi;
}
ll n,d,a[100005],s[100005],x[100005],top;
db ans;
struct did{
	ll x,y;
	did() {}
	did(ll a,ll b): x(a),y(b) {}
}q[100005];
inline db slope(did a,did b) {return 1.0*(a.y-b.y)/(a.x-b.x);}
int main()
{
	n=read(),d=read();
	for(re i=1;i<=n;i++) s[i]=s[i-1]+(a[i]=read()),x[i]=read();
	for(re i=1;i<=n;i++)
	{
		did t=did(d*i,s[i-1]);
		while(top&&slope(q[top],q[top-1])>slope(t,q[top])) top--;
		q[++top]=t;t=did(x[i]+d*i,s[i]);
		re l=1,r=top,res;
		while(l<=r)
		{
			re mid=(l+r)>>1;
			if(slope(q[mid],t)>slope(q[mid-1],t)) l=mid+1,res=mid;
			else r=mid-1;
		}
		ans+=slope(q[res],t);
	}
	printf("%.0lf\n",ans);
	return 0;
}
```  


---

## 作者：Unaccepted (赞：0)

[原题传送门~](https://www.luogu.org/problemnew/show/P3299)

题目大意:（其~~实玩过pvz都能明白）（没玩过赶紧去）~~

对于第$i$关，僵尸如此排列

铭铭(植物)    僵尸$i$   僵尸$i-1$ ……………… 僵尸$1$

第$i$只僵尸血量为$ai$,每只僵尸之间距离为$d$,第一只僵尸距离铭铭x[i]

只有前面的僵尸死了，后面的僵尸才开始受到伤害

求对于每一关可以保护铭铭的最小攻击力的总和

解析：

这道题其实思路很巧妙，对于每一关，我们对每只僵尸单独处理，假设每只僵尸从开始就会受到伤害，每只僵尸的血量改为前面的僵尸血量总和，这不是与题面描述是同样效果的吗？

对于每一关，这样可以求出防住每只僵尸的最小攻击力，因为不能受到伤害，所以取最大值。

那么我们可以推出$dp$方程：$dp[i]=max((sum[i]-sum[j-1])/(d*(i-j)+x[i])$

其中$(d*(i-j)+x[i])$为距离，$sum[i]-sum[j-i]$为血量。

这样的时间复杂度是$O(n^2)$，可以得到50分

所以考虑优化

把$dp$表达式换个形式，将与$i$有关的和与$j$有关的分开。

得到$dp$表达式:$dp[i]=max((sum[i]-sum[j-1])/(d*i+x[i]-d*j))$

我们知道，斜率的表达式是$(Y1-Y2)/(X1-X2)$，而我们发现，这个形式有点像斜率，斜率优化！

我们将$sum[i]$当作$Y1$，将$sum[j-1]$当作$Y2$，将$d*i+x[i]$当作$X1$，$d*j$当作$X2$，斜率优化的套路！

那就只需要一个维护$(sum[i]-sum[j-1])/(i*d-j*d)$的下凸包就可以了。

在求解第$i$关时，与$i$有关的是不变的，那么我们只需要将$i$当作一个定点$(i* d+x[i],sum[i])$，那么我们求得的答案就是凸包上的点到$i$的最大斜率

这样做是因为凸包上的点$(j* d,sum[j-1])$和我们的点i$(i* d+x[i],sum[i])$间的斜率计算一下，就是我们求得的$dp$表达式！

我们可以发现：凸包上的点斜率是单峰的的开口朝下的函数

那最大值就是峰值，三分即可(三分注意边界，不然容易死循环)

还有，本题使用$double$即可，不需要使用$long long$

最后贴上蒟蒻的代码……

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define N 100010
using namespace std;
struct point
{
	double x,y;
}stk[N];
point makepoint(double x,double y)
{
	point tmp;
	tmp.x=x;
	tmp.y=y;
	return tmp;
}
int n,topp;
double ans,d;
double sum[N],x[N];
double K(point i,point j)//求斜率的函数 
{
	return (double)((double)(i.y-j.y)/(double)(i.x-j.x));
}
double waiji(point i,point j)  //用向量外积正负判断转折方向，维护凸包 
{
	return (double)(i.x*j.y-i.y*j.x);
}
point jian(point i,point j) //向量减法 
{
	return makepoint(i.x-j.x,i.y-j.y);
}
double sanfen(point x)
{
	int l=1,r=topp;
	int lmid,rmid;
	double res=0.0;
	while(r-l>2) //整数三分注意边界 
	{	
		lmid=l+(r-l)/3,rmid=l+(r-l)*2/3;
		double k1=K(x,stk[lmid]);
		double k2=K(x,stk[rmid]);
		if(k1<k2)
		{
			l=lmid;
			res=max(res,k2);
		}
		else 
		{
			r=rmid;
			res=max(res,k1);
		}
	}
	for(int i=l;i<=r;i++) 
		res=max(res,K(x,stk[i]));
	return res;
}
int main()
{
	scanf("%d%lf",&n,&d);
	for(int i=1;i<=n;i++)
	{
		scanf("%lf%lf",&sum[i],&x[i]);
		sum[i]+=sum[i-1];//求血量所用的前缀和 
	}
	ans=(double)sum[1]/x[1];
	stk[++topp]=makepoint(d,0.0);
	for(int i=2;i<=n;i++)
	{
		point tmp1=makepoint((double)i*d,sum[i-1]);//准备插入的节点 
		while(topp-1>=1 && waiji(jian(stk[topp],stk[topp-1]),jian(tmp1,stk[topp-1]))<=0) --topp;//维护凸包 
		stk[++topp]=tmp1;//插入节点 
		point tmp2=makepoint(x[i]+(double)i*d,sum[i]);//这就是i点 
		ans+=sanfen(tmp2);//三分求答案 
	}
	printf("%.0f",ans);
	return 0;
}
```
斜率优化理解了还是蛮简单的

---


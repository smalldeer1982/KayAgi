# [POI 2006] NAJ-The Invasion

## 题目描述

And so it has come - the Triangles have invaded Byteotia!

Byteotia lies on an island, occupying its entire surface.

The shape of the island is a convex polygon(i.e. a polygon whose each inner angle is smaller than $180\degree$).

A certain number of software factories are located in Byteotia, each of which generates constant gains or losses.

The Triangles have decided to occupy such a part of Byteotia which:

is a triangle-shaped area, the vertices of which are three different vertices of the polygon-island,     brings the largest income i.e. the sum of all gains and losses generated by factories within the occupied area is maximal.

We assume that a factory located on the border or in the vertex of occupied area belongs to that area. A territory which contains no factory brings, obviously, a zero income.

Byteasar, the King of Byteotia, is concerned by the amount of losses the Triangles' invasion could generate. Help him by writing a programme which shall calculate the sum of gains and losses generated by factories which the Triangles wish to capture.

TaskWrite a programme which:

reads a decription of Byteotia's shape and the locations of factories from the input file,     determines the maximal value of sum of all gains and losses generated by factories within a triangle, whose vertices are three different vertices of the polygon island,     writes the outcome to the output file.

给定一个凸包， 并给出凸包内部或边上的若干个资源，每个资源都有权值,现在要在凸包上面选择不同的3个点，使得3个点组成的三角形
内部的资源的权值之和最大。


凸包点个数 $n \le 600$


资源个数 $m \le 10000$


## 说明/提示

the correct result is:

![](https://cdn.luogu.com.cn/upload/pic/6970.png)


## 样例 #1

### 输入

```
5
4 1
1 4
8 9
11 5
8 1
4
7 2 3
6 3 -1
4 5 3
9 6 -4```

### 输出

```
5```

# 题解

## 作者：huangjinxiu (赞：4)

$n$ 很小，我们可以考虑 $n^3$ 枚举三角形的 $3$ 个顶点
然后快速计算答案。


![](https://cdn.luogu.com.cn/upload/image_hosting/e7t7abf9.png)

如上图，考虑答案为红点，即为总点数减去蓝点数。
凸包被分成了 $4$ 个部分，其中有 $3$ 个部分都是蓝点。
我们发现每个部分的蓝点是独立的，且只与三角形的一条边有关。

![](https://cdn.luogu.com.cn/upload/image_hosting/gaboyzf9.png)

考虑计算每条边对应区域的蓝点数。记 $f[i][j] $ 表示位于 $\overrightarrow {P_iP_j}$ 逆时针方向的所有点的权值和。发现若 $P_k$ 位于 $\overrightarrow {P_iP_j}$ 的顺时针方向，则答案单调不降（如上图）。于是我们可以先按照点关于 $P_i$ 的相对位置排序（这个可以用叉积方便地判断），接着再双指针扫一遍即可得到 $f[i]$ 的所有值。

统计答案是简单的，题目中保证了顺时针给定凸包上的点，所以可以直接按序依次枚举。但需要注意如果有位置与凸包顶点重合的点用叉积判断其位置关系可能会炸掉。我们不妨再计算 $f$ 时先不考虑这些点，最后统计答案的时候再单独考虑这些点。

时间复杂度 $O(n^3 + nm\log m)$
代码如下（马蜂有点抽象 

```cpp
#include<bits/stdc++.h>
#define ld  int 
#define pdd pair<ld,ld>
#define pii pair<int,int>
#define fi first
#define se second
#define pb emplace_back
#define cmax(a,b) ((a)=max((a),(b)))
using namespace std;
namespace IO{
	const int maxn=(1<<20);char *p1,*p2,buf[maxn];
	#define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,maxn,stdin),p1==p2)?EOF:*p1++)
	int read(){
		int f=1,k=0;char c;
		while(!isdigit(c=gc()))if(c=='-')f=-1;
		while(isdigit(c))k=k*10+c-48,c=gc();
		return f*k;
	}
	void write(int k,char c){
		if(k<0){putchar('-');k=-k;}
		char st[21];int top=0;
		do{st[++top]=(k%10)|48,k/=10;}while(k);
		while(top)putchar(st[top--]);
		putchar(c);
	}
}using namespace IO;
const int N=605,M=1e4+10;
int f[N][N],corner[N],x,y,z,n,m,sum,ans=-0x3f3f3f3f;
pdd P[N],center;map<pdd,int> mp;
struct V{pdd pos;int val;}v[M];
inline int Cross(pdd x,pdd y){
	return (x.fi-center.fi)*(y.se-center.se)-(x.se-center.se)*(y.fi-center.fi);
}
inline bool cmp(V x,V y){return Cross(x.pos,y.pos)<0;}//y位于x的顺时针方向 
inline int nxt(int x){return x==n?1:x+1;}
void pre_solve(int id){
	center=P[id];
	int val=0,l=1;
	sort(v+1,v+1+m,cmp);
	for(int j=nxt(id);j!=id;j=nxt(j)){
		while(l<=m&&Cross(P[j],v[l].pos)>0)val+=v[l++].val;//v[l].pos位于P[j]的逆时针方向  
		f[id][j]=val;
	}
}
int solve(){
	for(int i=1;i<=n;++i)
		for(int j=i+1;j<=n;++j)
			for(int k=j+1;k<=n;++k)
				cmax(ans,sum-f[i][j]-f[j][k]-f[k][i]+corner[i]+corner[j]+corner[k]);
	return ans;
}
signed main(){
	n=read();
	for(int i=1;i<=n;++i){
		P[i].fi=read(),P[i].se=read();
		mp[P[i]]=i;
	}
	m=read();
	for(int i=1;i<=m;++i){
		x=read(),y=read(),z=read();
		v[i]={{x,y},z};
		corner[mp[{x,y}]]+=z;
		if(mp[{x,y}])--i,--m;
		else sum+=z;
	}
	for(int i=1;i<=n;++i)pre_solve(i);
	write(solve(),'\n');
	return 0;
}   
```

---

## 作者：Alex_Wei (赞：4)

> [P3442 [POI2006]NAJ-The Invasion](https://www.luogu.com.cn/problem/P3442)
>
> [POI 合集](https://www.cnblogs.com/alex-wei/p/POI.html)。

比较基础的凸包题目。

考虑枚举三角形的三个点，我们必须做到 $\mathcal{O}(1)$ 判断三角形内点的价值之和。这可以通过预处理 $f_{i,j}$ 表示向量 $\overrightarrow{P_iP_j}$ 逆时针方向与凸包之间形成的区域包含的点的价值之和，然后用总价值减去 $f_{i,j}+f_{j,k}+f_{k,i}\ (1\leq i<j<k\leq n)$ 得到。由于三角形包含边界，所以 $f_{i,j}$ 不包含边界。

$f_{i,j}$ 如何预处理呢？枚举每个物资 $Q_k$，顺时针二分找到第一个位置 $p$ 使得 $\overrightarrow{P_iQ_k}$ 在 $\overrightarrow{P_iP_j}$ 的逆时针方向，即$\overrightarrow{P_iP_j} \times \overrightarrow{P_iQ_k}> 0$，此时所有在 $p$ 顺时针方向直到 $i-1$ 的所有点 $j$ 的 $f_{i,j}$ 都需要加上 $c_k$。这可以通过破环成链 + 差分做到。

注意需要特判在顶点上的物资。时间复杂度 $\mathcal{O}(n(n^2+m\log n))$。$n^3$ 有 $\dfrac 1 6$ 的常数，可以通过。

```cpp
const int N = 600 + 5;
const int M = 1e4 + 5;

int n, x[N << 1], y[N << 1], val[N], f[N][N];
int m, a[M], b[M], c[M], tot, ans = -1e9;
int cross(int ax, int ay, int bx, int by) {return ax * by - ay * bx;}
int main(){
	cin >> n; for(int i = 1; i <= n; i++) cin >> x[i] >> y[i], x[n + i] = x[i], y[n + i] = y[i];
	cin >> m; for(int i = 1; i <= m; i++) {
		int found = 0; cin >> a[i] >> b[i] >> c[i];
		for(int j = 1; j <= n; j++) if(a[i] == x[j] && b[i] == y[j]) found = j;
		found ? (val[found] += c[i], c[i] = 0) : tot += c[i];
	} for(int i = 1; i <= n; i++) {
		static int buc[N << 1]; mem(buc, 0, N << 1);
		for(int j = 1; j <= m; j++) if(c[j]) {
			int l = i + 1, r = i + n + 1;
			while(l < r) {
				int m = l + r >> 1;
				cross(x[m] - x[i], y[m] - y[i], a[j] - x[i], b[j] - y[i]) > 0 ? r = m : l = m + 1;
			} buc[l] += c[j];
		} for(int j = 1; j <= n << 1; j++) buc[j] += buc[j - 1];
		for(int j = i + 1; j <= n; j++) f[i][j] = buc[j];
		for(int j = 1; j < i; j++) f[i][j] = buc[j + n];
	} for(int i = 1; i < n; i++) for(int j = i + 1; j < n; j++) for(int k = j + 1; k <= n; k++)
		cmax(ans, tot - f[i][j] - f[j][k] - f[k][i] + val[i] + val[j] + val[k]);
	cout << ans << endl;
	return 0;
}
```

---


# [NOI2007] 货币兑换

## 题目描述

小 Y 最近在一家金券交易所工作。该金券交易所只发行交易两种金券：A 纪念券（以下简称 A 券）和 B 纪念券（以下简称 B 券）。每个持有金券的顾客都有一个自己的帐户。金券的数目可以是一个实数。

每天随着市场的起伏波动，两种金券都有自己当时的价值，即每一单位金券当天可以兑换的人民币数目。我们记录第 $K$ 天中 A 券和 B 券的价值分别为 $A_K$ 和 $B_K$（元/单位金券）。

为了方便顾客，金券交易所提供了一种非常方便的交易方式：比例交易法。

比例交易法分为两个方面：

a)  卖出金券：顾客提供一个 $[0, 100]$ 内的实数 $OP$ 作为卖出比例，其意义为：将 $OP\%$ 的 A 券和 $OP\%$ 的 B 券以当时的价值兑换为人民币；

b)  买入金券：顾客支付 $IP$ 元人民币，交易所将会兑换给用户总价值为 $IP$ 的金券，并且，满足提供给顾客的 A 券和 B 券的比例在第 $K$ 天恰好为 $\mathrm{Rate}_ K$；

例如，假定接下来 $3$ 天内的 $A_K,B_K,\mathrm{Rate}_ K$ 的变化分别为：

| 时间 | $A_K$ | $B_K$ | $\mathrm{Rate}_ K$ |
| ----- | ----- | ----- | ----- |
| 第一天 | $1$ | $1$ | $1$ |
| 第二天 | $1$ | $2$ | $2$ |
| 第三天 | $2$ | $2$ | $3$ |



假定在第一天时，用户手中有 $100$ 元人民币但是没有任何金券。

用户可以执行以下的操作：

| 时间 | 用户操作 | 人民币(元) | A 券的数量 | B 券的数量 |
| ----- | ----- | ----- | ----- | ----- |
| 开户 | 无 | $100$ | $0$ | $0$ |
| 第一天 | 买入 $100$ 元 | $0$ | $50$ | $50$ |
| 第二天 | 卖出 $50\%$ | $75$ | $25$ | $25$ |
| 第二天 | 买入 $60$ 元 | $15$ | $55$ | $40$ |
| 第三天 | 卖出 $100\%$ | $205$ | $0$ | $0$ |

注意到，同一天内可以进行多次操作。

小 Y 是一个很有经济头脑的员工，通过较长时间的运作和行情测算，他已经知道了未来 $N$ 天内的 A 券和 B 券的价值以及 $\mathrm{Rate}$。他还希望能够计算出来，如果开始时拥有 $S$ 元钱，那么 $N$ 天后最多能够获得多少元钱。


## 说明/提示

| 时间 | 用户操作 | 人民币(元) | A 券的数量 | B 券的数量 |
| ----- | ----- | ----- | ----- | ----- |
| 开户 | 无 | $100$ | $0$ | $0$ |
| 第一天 | 买入 $100$ 元 | $0$ | $50$ | $50$ |
| 第二天 | 卖出 $100\%$ | $150$ | $0$ | $0$ |
| 第二天 | 买入 $150$ 元 | $0$ | $75$ | $37.5$ |
| 第三天 | 卖出 $100\%$ | $225$ | $0$ | $0$ |


本题没有部分分，你的程序的输出只有和标准答案相差不超过 $0.001$ 时，才能获得该测试点的满分，否则不得分。


测试数据设计使得精度误差不会超过 $10^{-7}$ 。

对于 $40\%$ 的测试数据，满足 $N \le 10$。

对于 $60\%$ 的测试数据，满足 $N \le 1 000$。

对于 $100\%$ 的测试数据，满足 $N \le 10^5$。

对于 $100\%$ 的测试数据，满足：

$0 < A_K \leq 10$，$0 < B_K\le 10$，$0 < \mathrm{Rate}_K \le 100$，$\mathrm{MaxProfit}  \leq 10^9$。

输入文件可能很大，请采用快速的读入方式。

必然存在一种最优的买卖方案满足：

每次买进操作使用完所有的人民币，每次卖出操作卖出所有的金券。


## 样例 #1

### 输入

```
3 100
1 1 1
1 2 2
2 2 3```

### 输出

```
225.000```

# 题解

## 作者：panyf (赞：93)

李超线段树解法，代码短，常数小，不卡精度！

先说 dp 方程。

注意到一个关键性质：每次买进操作使用完所有的人民币，每次卖出操作卖出所有的金券。

设 $f_i$ 为第 $i$ 天最多拥有的钱数，$x_i$ 为第 $i$ 天用 $f_i$ 元钱可以兑换的 A 券数，$y_i$ 为 B 券数。

则有 $x_i=\dfrac{f_iRate_i}{a_iRate_i+b_i}$，$y_i=\dfrac{f_i}{a_iRate_i+b_i}$。

第 $i$ 天不卖出金券，则 $f_i=\max(f_i,f_{i-1})$。

第 $i$ 天卖出金券，枚举上一次买入的时间，可得 $f_i=\max a_ix_j+b_iy_j$。

变形得 $f_i=\max b_i(x_j\dfrac{a_i}{b_i}+y_j)$。

设 $k=x_j$，$x=\dfrac{a_i}{b_i}$，$b=y_j$，则 $f_i=\max b_i(kx+b)$，李超线段树优化即可。

注意到 $x$ 可能为小数，可以动态开点，精度和常数都较差。

对于此题，更好的方法是将所有的 $x$ 离散化。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+3;
#define db double
db x[N],y[N],a[N],b[N],r[N],c[N],d[N];
int u,s[N*4];
#define f(i,t) (y[t]+x[t]*c[i])
void upd(int k,int t,int l,int r){
	if(l==r){if(f(l,t)>f(l,s[k]))s[k]=t;return;}
	int m=l+r>>1;
	if(f(m,t)>f(m,s[k]))swap(t,s[k]);
	f(l,t)>f(l,s[k])?upd(k*2,t,l,m):upd(k*2+1,t,m+1,r);
}//李超树插入
db qry(int k,int l,int r){
	if(l==r)return f(u,s[k]);
	int m=l+r>>1;
	return max(f(u,s[k]),u>m?qry(k*2+1,m+1,r):qry(k*2,l,m));
}//李超树查询
int main(){
	int n,i;
	db f,g;
	scanf("%d%lf",&n,&f);
	for(i=1;i<=n;++i)scanf("%lf%lf%lf",a+i,b+i,r+i),c[i]=a[i]/b[i],d[i]=c[i];
	sort(c+1,c+n+1);//离散化
	for(i=1;i<=n;++i){
		u=lower_bound(c+1,c+n+1,d[i])-c,f=max(f,b[i]*qry(1,1,n));
		g=a[i]*r[i]+b[i],x[i]=f*r[i]/g,y[i]=f/g,upd(1,i,1,n);
	}
	printf("%.3lf",f);
	return 0;
}
```

---

## 作者：litble (赞：57)

[蒟蒻的博客](http://blog.csdn.net/litble/article/details/78965163 )

# 斜率优化

首先，由于如果在i天买在j天卖有利可图，那么最优方法就是在i天花完钱在j天卖完。我们令$f_i$为第i天可以得到的最多钱数，然后可以先列方程求出花完钱在第j天得到的两种金券数$x_j=\frac{f_jR_j}{a_jR_j+b_j}$和$y_j=\frac{f_j}{a_jR_j+b_j}$，然后得到状态转移方程：$f_i=x_ja_i+y_jb_i$

将方程稍微变形成直线斜截式方程：$y_j=-\frac{a_ix_j}{b_i}+\frac{f_i}{b_i}$，可以知道，对于平面上众多的点$(x_j,y_j)$，我们每次用一条斜率为$-\frac{a_i}{b_i}$的直线去切它们中的一个，可以求得最大截距的点即为最优决策。

如何求得最大截距呢？以下我们将斜率为$-\frac{a_i}{b_i}$的直线称为当前直线。

现在我们维护点之间的一个凸包，如果对于点j，其左边的线斜率小于当前直线，那么显然把当前直线移到左边的点截距更大（建议自己画图理解）。如果其右边的线斜率大于当前直线，那么将其右移更优。

于是就有两种维护方式：

# splay维护

我们需要优化，那么就需要排除不可能状态。可以发现，在点集中，如果一个点在凸包内部，那么这个点就是不可能是最优决策的点，因为其上一定有一个点，那么把当前直线上移可以获得更大截距。所以我们可以排除这些决策．

维护lk:点x凸包左边那条线的斜率，rk:右边那条线的。

splay按照x排序，寻找最优决策的方法见上，而添加新点的方法：

首先将新点x旋转到根。以寻找其左边最后一个可以与其构成凸包的点为例。对于当前点t，如果t左边斜率大于了直线tx的斜率，那么如果t的右边还有不在凸包内的节点，用tx的连线就不能构成凸包，所以应该继续往右找点。否则，继续往左找点。

然后，删掉在凸包里的点。

找右边第一个可以与其构成凸包的点同理。

最后，如果发现这个点本来就在旧的凸包里面，直接将其删除。（即$lk_x$大于$rk_x$）

```cpp
#include<bits/stdc++.h>
using namespace std;
#define db double
#define eps 1e-9//一定要注意精度
#define inf 1e9
const int N=100005;
int n,rt,sc,f[N],son[N][2];
db dp[N],A[N],B[N],R[N],lk[N],rk[N],X[N],Y[N];//lk：凸包点x左线斜率，rk：右线斜率
int is(int x) {return son[f[x]][1]==x;}
void spin(int x,int &mb) {
    int fa=f[x],g=f[fa],t=is(x);
    if(fa==mb) mb=x;
    else son[g][is(fa)]=x;
    f[fa]=x,f[x]=g,f[son[x][t^1]]=fa;
    son[fa][t]=son[x][t^1],son[x][t^1]=fa;
}
void splay(int x,int &mb) {
    while(x!=mb) {
        if(f[x]!=mb) {
            if(is(x)^is(f[x])) spin(x,mb);
            else spin(f[x],mb);
        }
        spin(x,mb);
    }
}
int find(int x,db num) {//寻找最优解
    if(!x) return 0;
    if(lk[x]+eps>=num&&rk[x]<=num+eps) return x;
    else if(lk[x]<num+eps) return find(son[x][0],num);
    else return find(son[x][1],num);
}
db getk(int a,int b) {//获得斜率
    if(X[a]-X[b]<eps&&X[a]-X[b]>-eps) return -inf;
    return (Y[b]-Y[a])/(X[b]-X[a]);
}
int pre(int x) {//寻找左边最后一个与x可以构成凸包的点
    int y=son[x][0],re=y;
    while(y) {
        if(lk[y]+eps>=getk(y,x)) re=y,y=son[y][1];
        else y=son[y][0];
    }
    return re;
}
int nxt(int x) {//寻找右边第一个与x可以构成凸包的点
    int y=son[x][1],re=y;
    while(y) {
        if(rk[y]<=getk(x,y)+eps) re=y,y=son[y][0];
        else y=son[y][1];
    }
    return re;
}
void newjd(int x) {
    splay(x,rt);
    if(son[x][0]) {
        int kl=pre(x);
        splay(kl,son[x][0]),son[kl][1]=0;
        lk[x]=rk[kl]=getk(kl,x);
    }
    else lk[x]=inf;//请勿往左
    if(son[x][1]) {
        int kl=nxt(x);
        splay(kl,son[x][1]),son[kl][0]=0;
        rk[x]=lk[kl]=getk(x,kl);
    }
    else rk[x]=-inf;//请勿往右
    if(lk[x]<=rk[x]+eps) {//在原凸包内部,直接删除该点
        rt=son[x][0],son[rt][1]=son[x][1],f[son[x][1]]=rt,f[rt]=0;
        lk[rt]=rk[son[rt][1]]=getk(rt,son[rt][1]);
    }
}
void ins(int &x,int las,int bh) {
    if(!x) {x=bh,f[x]=las;return;}
    if(X[bh]<=X[x]+eps) ins(son[x][0],x,bh);
    else ins(son[x][1],x,bh);
}
int main()
{
    scanf("%d%lf",&n,&dp[0]);
    for(int i=1;i<=n;++i) {
        scanf("%lf%lf%lf",&A[i],&B[i],&R[i]);
        int j=find(rt,-A[i]/B[i]);
        dp[i]=max(dp[i-1],X[j]*A[i]+Y[j]*B[i]);
        Y[i]=dp[i]/(A[i]*R[i]+B[i]),X[i]=Y[i]*R[i];
        ins(rt,0,i),newjd(i);
    }
    printf("%.3lf\n",dp[n]);
    return 0;
}
```
# CDQ分治维护

[关于CDQ分治](http://blog.csdn.net/litble/article/details/79016999)

我们可以对决策的时间进行二分，对于左半边区间，首先求出它们的dp值，右半边区间维持$k_i=-\frac{a_i}{b_i}$的有序，左半边区间维持$x_i$的有序。

我们可以开一个栈来维护左半边区间的斜率单调递减的凸包。

对于右半边区间，由于k值排了序，所以可以O(n)查询。查询方法就是关于斜率优化的分析的倒数第二段的内容。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define db double
#define inf 1e9
#define eps 1e-9
const int N=100005;
int n,s[N];db dp[N];
struct node{db k,x,y,a,b,r;int id;}Q[N],kl[N];
db getk(int i,int j) {
    if(fabs(Q[i].x-Q[j].x)<=eps) return inf;
    return (Q[j].y-Q[i].y)/(Q[j].x-Q[i].x);
}
void merge(int l,int r,int mid) {//归并排序
    int t1=l,t2=mid+1;
    for(int i=l;i<=r;++i)
        if(t1<=mid&&(t2>r||Q[t1].x<Q[t2].x+eps)) kl[i]=Q[t1],++t1;
        else kl[i]=Q[t2],++t2;
    for(int i=l;i<=r;++i) Q[i]=kl[i];
}
void cdq(int l,int r) {
    if(l==r) {//那么在l之前的所有询问都已经处理完毕，可以更新l的答案了
        dp[l]=max(dp[l],dp[l-1]);
        Q[l].y=dp[l]/(Q[l].a*Q[l].r+Q[l].b),Q[l].x=Q[l].y*Q[l].r;
        return;
    }
    int mid=(l+r)>>1,t1=l-1,t2=mid,top=0;
    for(int i=l;i<=r;++i)//把前mid个询问放在左边，后mid个放在右边
        if(Q[i].id<=mid) kl[++t1]=Q[i];
        else kl[++t2]=Q[i];
    for(int i=l;i<=r;++i) Q[i]=kl[i];
    cdq(l,mid);//递归处理左边
    for(int i=l;i<=mid;++i) {//维护斜率递减的凸包
        while(top>=2&&getk(s[top],i)+eps>getk(s[top-1],s[top])) --top;
        s[++top]=i;
    }
    for(int i=mid+1;i<=r;++i) {//处理右边的询问
        while(top>=2&&getk(s[top-1],s[top])<=Q[i].k+eps) --top;
        int j=s[top];
        dp[Q[i].id]=max(dp[Q[i].id],Q[j].x*Q[i].a+Q[j].y*Q[i].b);
    }
    cdq(mid+1,r),merge(l,r,mid);//递归处理右边后，按照x值为关键字归并排序
}
int cmp1(node t1,node t2) {return t1.k<t2.k;}
int main() 
{
    scanf("%d%lf",&n,&dp[0]);
    for(int i=1;i<=n;++i) {
        scanf("%lf%lf%lf",&Q[i].a,&Q[i].b,&Q[i].r);
        Q[i].k=-Q[i].a/Q[i].b,Q[i].id=i;
    }
    sort(Q+1,Q+1+n,cmp1),cdq(1,n);
    printf("%.3lf\n",dp[n]);
    return 0;
}
```

---

## 作者：RiverHamster (赞：23)

下面的cdq分治写法讲的都比较简单，弄得蒟蒻写了一天，发个题解总结一下。

[在我的blog阅读](https://www.cnblogs.com/RiverHamster/p/cdq-slopedp.html)

## dp
题目提示我们，每次买入一定花完所有的钱，卖出一定卖出所有的金券。（既然有最优方案为什么不全用）

因此，设第$i$天的最大收益为$f_i$，为了方便推出斜率优化的方程，设$f_i$可以换成$x_i$的A劵和$y_i$的B劵。以下将$Rate$写成$R$。
$$x_i = f_i {R_i \over A_iR_i + B_i}$$
$$y_i = f_i {1 \over A_iR_i + B_i}$$

则有方程
$$f_i = \max\{f_{i-1}, \max\{x_jA_i + y_jB_i\}\}$$

暂时不考虑$f_{i-1}$，将后面的改成斜率的形式。

转移到$f_i$，$f_j$ 比 $f_k$优：
$$x_jA_i + y_jB_i > x_kA_i + y_kB_i$$
$$(x_j-x_k)A_i > -(y_j-y_k)B_i$$
$${{y_j-y_k}\over{x_j-x_k}} > -{A_i \over B_i}$$
注意不等式符号方向要改。

很明显$x,y$都是没有单调性的，无法直接用单调栈或队列建凸壳。

## cdq分治
因为cdq分治可以将区间分成两块，然后统计前一块对后一块的贡献，所以可以对前一块的$x$进行排序，就可以建凸壳，进行后半部分的转移了。

注意三种顺序：
1. 分治前先按$-{A_i \over B_i}$排序，保证后半部分查询凸壳是有序的，这样可以用一个指针扫描，否则二分多一个log。
2. 分成两块前，按$pos$分组，$pos \leq mid$放在前一块，$pos > mid$放在后一块，保证用编号小的更新编号大的。同时，这样可以保证分治到叶子是按编号顺序的，，即*对于叶子$l = r = pos$，分治到叶子时这个节点就已经全部更新完了，这样就可以处理$f_i = \max\{f_i, f_{i-1}\}$。*
3. 最后按$x$归并，方便建上凸凸壳。

*不要把斜率改成乘法的形式*，因为负数比较多，改成乘法需要注意不等式方向，直接用斜率比较方便。

定义$slope(i, j)$为$i$到$j$的斜率（$i, j$是分治节点编号），找到凸壳中第一个$i$满足$slope(S_i, S_{i+1})<-{A_i \over B_i}$的就是最优转移点了，注意如果两个$x$相等，返回极大斜率就可以了，可以不用$eps$判断，直接判等，保证除数不为$0$即可。

### 分治的过程伪代码
1. if(l == r) 用f[i-1]更新f[i]，计算x,y exit
2. cdq(l, mid)
3. 单调栈对[l, mid]建凸壳
4. 按$-{A_i \over B_i}$顺序扫描，转移
5. cdq(mid+1, r)
6. 按x归并

## Code
```cpp
#include <cstdio>
#include <cctype>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
const int N = 100005;
const double eps = 1e-9, inf = 1e9;
struct val{
	int p; double x, y;
}q[N], tmp[N];
double f[N], A[N], B[N], R[N];
int s[N];
bool cmp(val a, val b){return -(A[a.p] / B[a.p]) > -(A[b.p] / B[b.p]);}
double slope(int x, int y){
	if(q[x].x == q[y].x) return inf;
	return (q[y].y - q[x].y) / (q[y].x - q[x].x);
}

void cdq(int l, int r){
	if(l == r){ //完成对节点的处理
		f[l] = max(f[l], f[l-1]);
		q[l].x = f[l] / (A[l] * R[l] + B[l]) * R[l];
		q[l].y = f[l] / (A[l] * R[l] + B[l]);
		return ;
	}
	int mid = (l + r) >> 1, lp = l, rp = mid + 1, tp = l;
	for(int i=l; i<=r; i++) //分组
		if(q[i].p <= mid) tmp[lp++] = q[i];
		else tmp[rp++] = q[i];
	for(int i=l; i<=r; i++) q[i] = tmp[i];
	cdq(l, mid);
	int t = 0, p = 1;
	for(int i=l; i<=mid; i++){ //建凸壳
		while(t > 1 && slope(s[t], i) > slope(s[t-1], s[t])) --t;
		s[++t] = i;
	}
	for(int i=mid+1; i<=r; i++){ //转移
		while(p < t && slope(s[p], s[p+1]) > -A[q[i].p] / B[q[i].p]) ++p;
		f[q[i].p] = max(f[q[i].p], q[s[p]].x * A[q[i].p] + q[s[p]].y * B[q[i].p]);
	}
	cdq(mid+1, r);
	lp = l; rp = mid + 1; tp = l;
	while(lp <= mid && rp <= r) //归并
		if(q[lp].x < q[rp].x) tmp[tp++] = q[lp++];
		else tmp[tp++] = q[rp++];
	while(lp <= mid) tmp[tp++] = q[lp++];
	while(rp <= r) tmp[tp++] = q[rp++];
	for(int i=l; i<=r; i++) q[i] = tmp[i];
}

int main(){
	int n; double s;
	scanf("%d%lf", &n, &s);
	for(int i=1; i<=n; i++){
		scanf("%lf%lf%lf", &A[i], &B[i], &R[i]);
		q[i].p = i; //pos
		q[i].x = s / (A[q[i].p] * R[q[i].p] + B[q[i].p]) * R[q[i].p];
		q[i].y = s / (A[q[i].p] * R[q[i].p] + B[q[i].p]);
		f[i] = s; //用s初始化
	}
	sort(q+1, q+1+n, cmp);
	cdq(1, n);
	printf("%.3lf\n", f[n]);
	return 0;
}
```

---

## 作者：ysy20021208 (赞：21)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**思路：**首先，我们能想到这道题是一道$dp$题目，我们设$f[i]$表示第$i$天能得到的最大收益，这个最大收益也包括第$i$天不进行操作的情况下的收益，设$X[i]$表示第$i$天将所有的现金都兑换成为金券后能拿到的$A$券数，$Y[i]$同理。这是我们发现一个转移式子：$f[i]=Max\{f[i-1],A[i]\times X[j]+B[i]\times Y[j]\}\ (1\le j \le i-1)$。我们发现这个式子能写成斜率优化的样子：$Y[j]=-\frac{A[i]}{B[i]}\times X[j]+\frac{f[i]}{B[i]}$。我们考虑一下能否运用斜率优化，好像可以，对于每一个点的斜率$k$为$-\frac{A[i]}{B[i]}$，横坐标为$X[i]$，纵坐标为$Y[i]$。但是就是有两个不太好的情况，就是每一点的$x$坐标与斜率$k$都不单调，这个怎么办？显然用平衡树维护凸包就好了。我们考虑一下不用平衡树能否实现，我们考虑$cdq$。

​&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为正常的要求最大值的斜率优化都是横坐标单调递增，斜率单调递减，所以我们考虑排序。因为每一个点的斜率都是不变的，即输入之后就是定下来的，所以我们可以将这些所有的点都按照斜率递减排序，但是这样就不是按照天数递增的顺序了，所以我们就不能直接运用排序后的顺序来处理这些点。我们将天数进行分治，这样的话我们每一个点就需要再存一个参数，即天数的编号。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为这是$dp$，所以我们在递归左区间之后显然要先处理影响，再递归右区间。现在考虑怎么处理影响。

​&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为我们每一次处理影响之前都已经处理好左区间了，所以我们现在可以不用理会左区间的具体顺序了，这样的话我们就能对其进行任意顺序的处理，我们可以将左区间的这些点按照横坐标排序，这样我们就能够达到上面所提出的目的，也就是把点按照顺序插入到凸包里面。因为我们是用左区间来更新右区间，所以我们不用去管右区间，并且因为右区间的斜率是单调递减的，所以我们可以按照右区间原本的顺序来进行更新。

​&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在递归出口的地方不能就是直接$return$，我们需要做一些小小的处理，因为我们在$return $之前这个点一定已经做完前面的点的所有更新了，但是没有进行不作处理的更新，所以$f[i]=Max\{f[i],f[i-1]\}$。至此搜有的更新都完成了，这是就可以了处理当前点的横纵坐标。因为必然存在一种最优的买卖方案满足：每次买进操作使用完所有的人民币；每次卖出操作卖出所有的金券，所以当前点的横纵坐标就是$X[i]=\frac{f[i]}{A[i]*Rate[i]+B[i]}\times A[i]$，$Y[i]=\frac{f[i]}{A[i]*Rate[i]+B[i]}$。

​&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于横坐标排序，我们显然没有必要每一次都用$sort$，我们运用归并排序的思想，直接排序即可，时间复杂度会降下$O(log_n)$。

```c++
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;
#define N 100010
#define eps 1e-9
int n,que[N];double f[N];
struct Node {double a,b,rate,k,x,y;int id;}node[N],tmp[N];
bool cmp(const Node &a,const Node &b) {return a.k>b.k;}
double re_x(int i) {return node[i].x;}
double re_y(int i) {return node[i].y;}
double re_k(int i,int j)
{
    if(fabs(node[i].x-node[j].x)<eps)return 1e20;
    return (re_y(j)-re_y(i))/(re_x(j)-re_x(i));
}
void solve(int l,int r)
{
    if(l==r)
    {
		f[l]=max(f[l],f[l-1]);
		node[l].y=f[l]/(node[l].a*node[l].rate+node[l].b);
		node[l].x=node[l].y*node[l].rate;return;
    }
    int mid=(l+r)>>1,tl=l-1,tr=mid;
    for(int i=l;i<=r;i++) (node[i].id<=mid)?tmp[++tl]=node[i]:tmp[++tr]=node[i];
    for(int i=l;i<=r;i++) node[i]=tmp[i];solve(l,mid);
    int L=1,R=0;
    for(int i=l;i<=mid;i++)
		{while(R>1&&re_k(que[R],que[R-1])<re_k(que[R],i)+eps) R--;que[++R]=i;}
    for(int i=mid+1;i<=r;i++)
    {
		while(L<R&&re_k(que[L],que[L+1])+eps>node[i].k) L++;
		f[node[i].id]=max(f[node[i].id],node[que[L]].x*node[i].a+node[que[L]].y*node[i].b);
    }solve(mid+1,r),tl=l,tr=mid+1;
    for(int i=l;i<=r;i++)
    {
		if((node[tl].x<node[tr].x||tr>r||fabs(node[tl].x-node[tr].x)<eps)&&tl<=mid)
         	tmp[i]=node[tl++];
		else tmp[i]=node[tr++];
    }
    for(int i=l;i<=r;i++) node[i]=tmp[i];
}
int main()
{
    scanf("%d%lf",&n,&f[0]);
    for(int i=1;i<=n;i++)
    {
		scanf("%lf%lf%lf",&node[i].a,&node[i].b,&node[i].rate);
		node[i].k=-node[i].a/node[i].b,node[i].id=i;
    }sort(node+1,node+n+1,cmp),solve(1,n),printf("%.3lf\n",f[n]);
}
```

---

## 作者：BruceW_07 (赞：11)


[题目链接](https://loj.ac/problem/2353)

## 题目大意
有 $A,B$ 两种金券，它们每天的价值都不同，在第 $i$ 天时分别为 $A_i,B_i$，你可以用手中的金券换取相应价值的钱，或用钱兑换相同价值的金券，但兑换到的两种金券的数量之比是一个定值，这个定值在第 $i$ 天为 $R_i$。

现给出 $n$ 天中两种金券的价值， $R$，以及你初始时拥有的资金 $S$，求 $n$ 天后你最多能有多少钱。

注：一定存在一种最优方案，满足：每次兑换金券花光所有的钱，每次换钱时花掉所有的金券。

## 解题思路
一眼dp题 ~~（大佬好像都是这样说的）~~。

先设个状态吧，

设 $f[i]$ 表示在第 $i$ 天卖掉所有的金券能获得的最多钱数，那我们只需要决定上一次买金券是在什么时候，转移方程如下：
$$ f[i]=max \{ num_A*A_i+num_B*B_i \} $$
$num_A$ 和 $num_B$ 的值就取决与你上一次是在什么时候买的金券。

假设我们上一次是在第 $j$ 天买的金券，而上一次卖掉金券是在第 $k$ 天（$k\le j <i$），那么我们在第 $j$ 天拥有的资金就是 $f[k]$，可以得出式子：
$$ num_A*A_j+num_B*B_j=f[k] $$
变个形
$$ R_j*num_B*A_j+num_B*B_j=f[k] $$
移个项
$$ num_B=\frac{f[k]}{R_j*A_j+B_j} $$
很容易看出来，$f[k]$ 越大越好，所以我们用个 $maxn$ 代替
$$ num_B=\frac{maxn}{R_j*A_j+B_j} $$
现在，我们就可以得出完整的转移方程
$$ f[i]=max \{ \frac{R_j*maxn}{R_j*A_j+B_j}*A_i+\frac{maxn}{R_j*A_j+B_j}*B_i \}  $$
 
 ~~辣眼睛~~
 一个 $n^2$ 算法就完成了，看下数据范围
> 对于 $100\%$ 的测试数据，满足 $1\le N\le 10^5$.....

~~手动再见~~

没办法，考虑优化吧。
再看眼式子
$$ f[i]=max \{ num_A*A_i+num_B*B_i \} $$
与 $j$ 有关的和与 $i$ 有关的粘在了一起，单调队列是没法搞了，斜率优化吧。
把式子转化一下，先把 $max$ 扔掉，除个 $B_i$（这第一步我还是看了题解才知道的……）
$$ \frac{f[i]}{B_i}=num_A*\frac{A_i}{B_i}+num_B$$
再移个项
$$ num_B=-\frac{A_i}{B_i}*num_A+\frac{f[i]}{B_i}$$
搞定，妥妥的斜率优化，
但，
这里的 $num_A$ 和 $-\frac{A_i}{B_i}$ 都不是递增的，队列搞不了……
怎么办，不会做，

打开题解看一眼，平衡树，cdq，关上。

cdq没有思路，还是用平衡树吧，虽然写起来麻烦点 ~~（为了写这道题我又去敲了遍平衡树的板子，又调了一个小时……）~~

那现在思路就很明了了 ~~（可能吧）~~，用平衡树维护一个上凸包，将凸包上的点按横坐标排序，然后每次找地方插入（或不插入），然后删除没用的点就行了，并在每一个点存下它与凸包上前一个点连接形成的直线的斜率 $tk$，更新状态时找到凸包上 $tk$ 比当前直线大的第一个点进行转移就行了（建议自己画个图理解一下）。

这道题貌似到这里就全部解完了，但实际上还有很多细节需要考虑，包括在插入、删除节点是要更新它的前驱和后缀的信息，以及花式卡精度……（数据里竟然出现了两个点的横坐标小数点后十几位都相同的情况……）。

最后这道题做下来前前后后花了可能有两天……

## 代码实现
```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#define db double
using namespace std;
const int N=100000+7;
int n,q[N],rt,cnt;
db f[N],a[N],b[N],r[N],X[N],Y[N],K[N],maxn;
int lc[N],rc[N],p[N],pre[N],nxt[N];
db tk[N];
db read(){
    char c=getchar(); db f=1,x=0;
    while(c<'0'||c>'9'){ f=c=='-'?-1:1;c=getchar(); }
    while(c>='0'&&c<='9'){ x=x*10+c-'0';c=getchar(); }
    if(c!='.') return f*x;
    c=getchar(); db y=1;
    while(c>='0'&&c<='9'){ y/=10;x+=(c-'0')*y;c=getchar(); }
    return f*x;
}
void zig(int &u){
    int ls=lc[u];
    lc[u]=rc[ls];
    rc[ls]=u;
    u=ls;
}
void zag(int &u){
    int rs=rc[u];
    rc[u]=lc[rs];
    lc[rs]=u;
    u=rs;
}
int g_pre(int k){
    int u=rt,ans=0;
    while(u){
        if(X[u]<X[k]){ ans=u; u=rc[u]; }
        else u=lc[u];
    }
    return ans;
}
int g_nxt(int k){
    int u=rt,ans=0;
    while(u){
        if(X[u]>X[k]){ ans=u; u=lc[u]; }
        else u=rc[u];
    }
    return ans;
}
db g_k(int a,int b){
    if(!a||!b) return 0;
    return (Y[a]-Y[b])/(X[a]-X[b]);
}
bool insert(int &u,int k){
    if(!u||X[u]==X[k]){
    	if(X[u]==X[k]&&Y[k]<=Y[u]) return 0;
        u=k;
        pre[u]=g_pre(u);
        nxt[u]=g_nxt(u);
        if(pre[u]) nxt[pre[u]]=u;
        if(nxt[u]) pre[nxt[u]]=u;
        tk[u]=g_k(u,pre[u]);
        if(nxt[u]) tk[nxt[u]]=g_k(u,nxt[u]);
        p[u]=rand();
        return 1;
    }
    if(X[u]>X[k]){
        bool f=insert(lc[u],k);
        if(p[lc[u]]<p[u]) zig(u);
        return f;
    }
    else{
        bool f=insert(rc[u],k);
        if(p[rc[u]]<p[u]) zag(u);
        return f;
    }
}
void del(int &u,int k){
    if(u==k){
        if(!lc[u]||!rc[u]){ u=lc[u]+rc[u];return; }
        else if(p[lc[u]]<p[rc[u]]){ zig(u);del(rc[u],k); }
        else{ zag(u);del(lc[u],k); }
    }
    else if(X[u]>X[k]) del(lc[u],k);
    else del(rc[u],k);
}
void add(int k){
	X[k]=r[k]*maxn/(a[k]*r[k]+b[k]);
	Y[k]=X[k]/r[k];
    /*Y[k]=maxn/(a[k]*r[k]+b[k]);
    X[k]=Y[k]*r[k];*/           // 这里巨恶心……如果按我注释掉的方法写的话有一个点会 WA ……
    int pr=g_pre(k),nx=g_nxt(k);
    if(nx&&g_k(pr,k)<=g_k(nx,k)) return;
    if(!insert(rt,k)) return;
    while(pre[k]&&tk[k]>tk[pre[k]]){
        del(rt,pre[k]);
        pre[k]=g_pre(k);
        if(pre[k]) nxt[pre[k]]=k;
        tk[k]=g_k(k,pre[k]);
    }
    while(nxt[nxt[k]]&&tk[nxt[k]]<tk[nxt[nxt[k]]]){
        del(rt,nxt[k]);
        nxt[k]=g_nxt(k);
        if(nxt[k]) pre[nxt[k]]=k;
        if(nxt[k]) tk[nxt[k]]=g_k(k,nxt[k]);
    }
}
int k_pre(int k){
    int u=rt,ans=0;
    while(u){
    	if(tk[u]>K[k]){ ans=u;u=rc[u]; }
        else u=lc[u];
    }
    return ans;
}
void update(int i){
    K[i]=-a[i]/b[i];
    int j=k_pre(i);
    f[i]=a[i]*X[j]+b[i]*Y[j];
}
void check(){
    cin>>n;
    for(int i=1;i<=n;i++) scanf("%lf%lf",&X[i],&Y[i]);
    for(int i=1;i<=n;i++) add(i);
}
int main(){
    n=(int)read(),f[1]=read();maxn=f[1];
    for(int i=1;i<=n;i++){ 
        a[i]=read();
        b[i]=read();
        r[i]=read();
    }
    add(1);
    for(int i=2;i<=n;i++){
        update(i);
        maxn=max(maxn,f[i]);
        add(i);
    }
    printf("%.3lf\n",maxn);
    return 0;
}
```





---

## 作者：cunzai_zsy0531 (赞：9)

### P4027 [NOI2007]货币兑换题解 by zsy

------------

题意简述：[传送门](https://www.luogu.com.cn/problem/P4027)

一共 $n$ 天，每天可以卖出或者买入两种股票 $A$ 和 $B$。这两种股票在第 $i$ 天的价值为 $A_i$ 和 $B_i$。

每天可以花**所有**的现金买入股票，这些股票中 $A$ 股与 $B$ 股的数量比为 $Rate_i$。每天也可以把**所有**的股票以当天的价值卖出，获得现金。已知接下来 $n$ 天的 $A_i,B_i,Rate_i$，求出 $n$ 天后能够获得的最大价值。

请注意本题冗余描述过多，其实只有数据范围下面那句话是有用的，做题的时候一定要注意提取关键信息！

------------

#### 本人的解法：cdq分治维护单调栈斜率优化dp

考虑到每一次买花掉全部的钱，每一次卖全部卖掉，我们不妨设 $f_i$ 表示第 $i$ 天能够拥有的最大钱数，把买股票算在之后每一天当中，即：

设 $x_k$ 表示第 $k$ 天买的 $A$ 股数量，$y_k$ 表示第 $k$ 天买的 $B$ 股数量，$a_k,b_k,r_k$ 分别表示第 $k$ 天的 $A$ 股价值、$B$ 股价值和 $AB$ 两股数量比，可得：

$$\left\{
\begin{aligned}
& x_k\cdot a_k+y_k\cdot b_k=f_k \\
& \frac{x_k}{y_k}=r_k \\
\end{aligned}
\right.$$

解得

$$\left\{
\begin{aligned}
& x_k=\frac{f_k r_k}{a_k r_k+b_k} \\
& y_k=\frac{f_k}{a_k r_k+b_k} \\
\end{aligned}
\right.$$

接下来我们考虑第 $i$ 天，卖股票能够得到的最大价值，即我们从 $1$ 到 $i-1$ 枚举一个 $j$，那么第 $i$ 天就能卖掉第 $j$ 天买的 $A$ 股(数量 $x_j$)，$B$ 股(数量$y_j$)。所以我们可以得到这样一个方程：

$$f_i=a_ix_j+b_iy_j$$

暴力的时间复杂度是 $O(n^2)$，期望得分 $60$。

接下来，由于出现了 $i,j$ 相乘项，考虑斜率优化。首先把它化成斜截式方程，即：

$$y_j=-\frac{a_i}{b_i}x_j+\frac{f_i}{b_i}$$

它的意义是在平面内有很多点 $(x_j,y_j)$，对每个 $i$ 找到一条斜率为 $-\frac{a_i}{b_i}$ 的直线穿过其中某个点能够得到的最大截距。

做法很明显，维护一个上凸壳，对每个 $k_i$ 找最优决策点即可。然而——这道题的 $x_i$ 和 $k_i$ 无序，所以一无法使用单调队列（需要 $x_i$ 和 $k_i$ 均有序），二无法使用单调栈内二分（$k_i$ 需有序）。这时候我们需要使用 $cdq$ 分治来维护。

具体维护方法如下（把每一天需要的所有状态放进一个 ```struct``` 数组中）：

0. 在进入 ```cdq(l,r)``` 之前，先把整个数组按照 $k$ 排序。
1. 当 ```l==r``` 时，更新第 $l$ 个状态的 $x_l,y_l$。
2. 把 ```[l,r]``` 中天数 $\leq$ ```mid``` 的放在左半边，剩下的放在右半边。
3. 递归处理出 `[l,mid]` 天的 $f_i,x_i,y_i$。
4. 用单调栈统计 `[l,mid]` 天对 `[mid+1,r]` 天的贡献。
5. 递归处理 `[mid+1,r]` 天的 $f_i,x_i,y_i$。
6. 将整个区间 `[l,r]` 按照 $x$ 递增排序。

我们可以通过这些步骤，观察出 `cdq` 分治维护的优秀性质：在第 $4$ 步，能用单调栈线性统计的原因是，对于 `[l,mid]`，因为我们在第 $7$ 步把 `[l,mid]` 按照 $x$ 单增排序了，同时，在第 $0$ 步对整个区间按照 $k$ 单增排序了，第一步的操作会使 $k$ 在 `[mid+1,r]` 上单增。所以可以使用单调栈统计。

其实根本原因还是在于 `cdq` 分治的优越性：只需要考虑 `[l,mid]` 对 `[mid+1,r]` 的贡献，所以可以分别排序，把原本无法维护的东西花一个 $log$ 的代价变成可以维护。

此题总的时间复杂度 $O(n\ log\ n)$。

最后放上 $AC$ 代码：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
const int N=1e5+13;
const double eps=1e-9;
const double INF=1e9; 
struct Node{double a,b,r,k,x,y;int id;}Q[N],Tmp[N];
struct Queue{//本人比较习惯手写队列（这题好像是个栈，不过不重要）
	int q[N],head,tail;
	inline void clear(){q[head=tail=1]=0;}
	Queue(){clear();}
	inline void push(int x){q[++tail]=x;}
	inline void pop(){--tail;}
	inline int top(){return q[tail];}
	inline int ttop(){return q[tail-1];}
	inline bool empty(){return head>=tail;}
}s;
double f[N];int n;
inline bool cmp0(const Node &a,const Node &b){return a.k<b.k;}
inline bool cmp1(const Node &a,const Node &b){return a.x<b.x;}
inline double slope(int i,int j){
	if(fabs(Q[i].x-Q[j].x)<eps) return INF;//这里没判会WA on #6,#7！！
	return (Q[i].y-Q[j].y)/(Q[i].x-Q[j].x);
}
void cdq(int l,int r){
	if(l==r){//第1步
		f[l]=max(f[l],f[l-1]);//别忘了还可以在这一天当中什么都不干
		Q[l].y=f[l]/(Q[l].a*Q[l].r+Q[l].b),Q[l].x=Q[l].r*Q[l].y;//更新x,y的值，接下来可以用它们去更新其他天的f值。
		return;
	}
	int mid=(l+r)>>1;
	int l1=l-1,l2=mid;
	for(int i=l;i<=r;++i){//第2步，将[l,r]化为左右两个k单调的区间，将询问放在相应的区间内处理
		if(Q[i].id<=mid) Tmp[++l1]=Q[i];
		else Tmp[++l2]=Q[i];
	}
	for(int i=l;i<=r;++i) Q[i]=Tmp[i];
	cdq(l,mid);//第3步
	s.clear();
	for(int i=l;i<=mid;++i){//预处理出上凸包
		while(!s.empty()&&slope(s.top(),i+eps)>slope(s.ttop(),s.top())) s.pop();
		s.push(i);
	}
	for(int i=mid+1,j;i<=r;++i){//第4步
		while(!s.empty()&&Q[i].k+eps>slope(s.ttop(),s.top())) s.pop();//因为斜率递增所以可以直接pop
		f[Q[i].id]=max(f[Q[i].id],Q[j=s.top()].x*Q[i].a+Q[j].y*Q[i].b);
	}
	cdq(mid+1,r);//第5步
	sort(Q+l,Q+r+1,cmp1);//第6步，偷懒了没写归并，这样应该也没问题
}
int main(){
	scanf("%d%lf",&n,&f[0]);
	for(int i=1;i<=n;++i){
		scanf("%lf%lf%lf",&Q[i].a,&Q[i].b,&Q[i].r);
		Q[i].k=-Q[i].a/Q[i].b;Q[i].id=i;//预处理k和id
	}
	sort(Q+1,Q+n+1,cmp0);//第0步
	cdq(1,n);
	printf("%.3lf\n",f[n]);
	return 0;
}
```
### 完结撒花！谢谢大家！

---

## 作者：newbiechd (赞：8)

# [NOI2007]货币兑换

[LG传送门](https://www.luogu.org/problemnew/show/P4027)

日常打[广告](https://www.cnblogs.com/cj-chd/p/10451774.html)

妥妥的$n \log n$cdq做法。

这题用cdq分治也可以$n \log n$~~但是在洛谷上竟然比一些优秀的splay跑得慢真是见了鬼了看来还是人丑常数大的问题~~

### 先推式子

（这一段与其他题解不会有太多不同，已经了解了的同学可以略过，注意一下转移中$x$和$k$表示什么就行了。）

设$f[i]$表示到第$i$天最多有多少钱，$g[i]$表示用第$i$天时的钱最多能买多少B券，易知$g[i] = \frac {f[i]} {r[i] * a[i] + b[i]}$。

得到转移：$f[i] = \max \{ \max \limits _{j = 1} ^{i - 1} \{g[j] * \frac{b[i]} {a[i]} + r[j] * g[j]\} * a[i], f[i - 1] \}$，外面的$\max$可以单独判，里面的$\max$可以看出是一个斜率优化的式子（把$\frac {b[i]} {a[i]}$视作$x$，把$g[j]$视作$k$，把$r[j] * g[j]$视作$b$）。但是我们发现斜率$k$并不是单调的，所以传统的斜率优化就无法解决这个问题了。

这时就衍生出两种写法了，一种是用splay维护凸包，一种是用cdq分治处理转移，我们要介绍的是后者。

### 考虑分治

对于任意一个$f[i]$，我们只要考虑到所有$1 \le j \le i - 1$对它的影响就行了，cdq分治擅长处理这类问题。

对于一段区间$[l, r]$，先递归左子区间$[l, m]$，保证$[l, m]$的$f$和$g$值都已经得到了；把左子区间按$k$递增排序，把右子区间按$x$递增排序，就可以按平时的斜率优化来$O(n)$转移；再把右子区间按在原序列中的位置递增排序，然后递归右子区间，此时左子区间对右子区间的影响都已经被考虑完了；边界是$l == r$，到这里我们可以发现$1$到$i - 1$对$i$的影响都已经被考虑过了，别忘了$f[i] - 1$到$f[i]$的转移。

这样做是$O(n (\log n) ^ 2)$的，让人有点不爽，事实上我们可以做到$O(n \log n)$。

### 怎样做到1个$\log$

事实上cdq分治本身是一个归并的过程，我们可以利用这个过程去掉排序的复杂度。

我们希望拿到$[l, r]$这个区间的时候$x$是单调的，于是在外面把原序列按$x$递增排序；拿到一个$x$递增的区间后，我们希望在原序列中靠左的东西去到左子区间，于是我们把$[l, r]$扫一遍，把在原序列中位置$\le m(m = l + r >> 1)$的东西放左边，$\ge m$的放右边，而且左右子区间对于$x$的单调性没有受到影响；我们要处理左边对右边的影响，于是先递归左子区间，再像平时一样斜率优化处理转移，然后递归右子区间；我们希望一个区间的左子区间递归回来的时候是对于$k$单调递增的，于是在最后对$k$做一遍归并排序。这样每一层递归是$O(n)$的。

奉上蒟蒻的大常数代码。

```cpp
//written by newbiechd
#include <iostream>
#include <iomanip>
#include <algorithm>
#define R register
#define I inline
#define D double
using namespace std;
const int N = 100003;
const D eps = 1e-8;
int q[N];
D f[N], g[N];
struct cash {
    int id;
    D a, b, r, x;
    cash() {}
    cash(int id, D a, D b, D r) : id(id), a(a), b(b), r(r), x(b / a) {}
    I int operator < (cash q) { return x != q.x ? x < q.x : id < q.id; }
}p[N], b[N];
I D cross(int u, int v) { return (p[u].r * g[p[u].id] - p[v].r * g[p[v].id]) / (g[p[v].id] - g[p[u].id]); }
I D calc(int u, int v) { return g[p[u].id] * (p[v].x + p[u].r); }
I void update(int u, D v) {
    if (f[p[u].id] < v)
        f[p[u].id] = v, g[p[u].id] = f[p[u].id] / (p[u].b + p[u].r * p[u].a);
}
void solve(int l, int r) {
    if (l == r) {
        update(l, f[p[l].id - 1]);
        return ;
    }
    R int m = (l + r) >> 1, i, h, t;
    for (h = l, t = m + 1, i = l; i <= r; ++i)
        p[i].id <= m ? b[h++] = p[i] : b[t++] = p[i];
    for (i = l; i <= r; ++i)
        p[i] = b[i];
    solve(l, m), h = 1, t = 0;
    for (i = l; i <= m; ++i) {
        while (h < t && cross(q[t], i) < cross(q[t - 1], i) + eps)
            --t;
        q[++t] = i;
    }
    for (; i <= r; ++i) {
        while (h < t && calc(q[h], i) < calc(q[h + 1], i) + eps)
            ++h;
        update(i, calc(q[h], i) * p[i].a);
    }
    solve(m + 1, r);
    for (h = l, t = m + 1, i = l; h <= m && t <= r; )
        g[p[h].id] < g[p[t].id] ? b[i++] = p[h++] : b[i++] = p[t++];
    while (h <= m)
        b[i++] = p[h++];
    while (t <= r)
        b[i++] = p[t++];
    for (i = l; i <= r; ++i)
        p[i] = b[i];
}
int main() {
    ios::sync_with_stdio(0);
    R int n, i;
    D a, b, r;
    cin >> n >> f[1];
    for (i = 1; i <= n; ++i)
        cin >> a >> b >> r, p[i] = cash(i, a, b, r);
    g[1] = f[1] / (p[1].r * p[1].a + p[1].b), sort(p + 1, p + n + 1),
        solve(1, n), cout << fixed << setprecision(3) << f[n];
    return 0;
}

```

---

## 作者：guoshaoyang (赞：8)

# [P4027 [NOI2007]货币兑换](https://www.luogu.org/problemnew/show/P4027)
## 算法：dp+斜率优化
**题面十分冗长，题意大概是有一种金券每天价值会有变化，你可以在某些时间点买入或卖出所有的金券，问最大收益**  
### 根据题意，很容易列出朴素的状态转移方程:
#### 设$f_i$为第$i$天B券的数量，$ans_j$为以当前价格卖光第$j$天的金券可获得的收益，则
$f_i=\max{ans_j}/(a_i*r_i+b_i)$
#### $O(n)$求$\max{ans_j}$,复杂度为$O(n^2)$
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
typedef long long LL;
const int MAXN=1024*100;
int N;
double S,a[MAXN],b[MAXN],r[MAXN],f[MAXN],ans;
int main(){
    scanf("%d%lf",&N,&S);
    for(int i=1;i<=N;i++){
        scanf("%lf%lf%lf",&a[i],&b[i],&r[i]);
    }
    ans=S;
    f[1]=ans*r[1]/(a[1]*r[1]+b[1]);
    for(int i=1;i<=N;i++){
        for(int j=1;j<i;j++){
            ans=max(ans,f[j]*a[i]+f[j]/r[j]*b[i]);
        }
        f[i]=ans*r[i]/(a[i]*r[i]+b[i]);
    }
    printf("%.3lf",ans);
    return 0;
}
```
#### 然而此题要求$O(nlogn)$的做法，故朴素的dp无法AC，此时可以想到斜率优化
### step1：转化方程
#### 设$a_i$为第$i$天A券的价格，$b_i$为第$i$天B券的价格，$ca_i$为第$i$天A券的数量，$cb_i$为第$i$天B券的数量，$f_i$为第$i$天的最大收益
#### 则$f_i=\max{ca_j*a_i+cb_j*b_i}$
#### ∴如果j比k更优，有
#### $ca_j*a_i+cb_j*b_i>ca_k*a_i+cb_k*b_i$
#### ∴$(cb_j-cb_k)*b_i>-a_i*(ca_j-ca_k)$
### ∴$\frac{cb_j-cb_k}{ca_j-ca_k}>-\frac{a_i}{b_i}$
#### 以$ca$为横坐标$cb$为纵坐标建立如图所示平面直角坐标系
![](https://cdn.luogu.com.cn/upload/pic/47739.png)
### 剩下的就可以[-斜率优化-](https://www.luogu.org/blog/guo-shao-yang-2005/xie-shuai-you-hua)了
#### 不过此题不比模板题，ca与cb不满足单调性，所以需要用平衡树或cdq等方法维护，此处用stl_set维护（因为是凸壳，所以斜率与横坐标同时满足单调性，可以用一个关键字查找）
#### 此处切线只要找$-\frac{a}{b}$的lower_bound即可（代码中的query）
#### 此处插入点要把当前位置两边的点都判断一下是否与上凸壳冲突，删除（代码中的insert）
#### 实现就不难了
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
#include<set>
using namespace std;
typedef long long LL;
const int MAXN=1024*100;
int N;
double S,A[MAXN],B[MAXN],R[MAXN],F[MAXN],CA[MAXN],CB[MAXN];
inline double ABS(double x) { return x>0?x:-x; }
struct node {
    double X,Y,K;
    int flag;
    node() { X=Y=K=flag=0; }
    node(double x,double y) { X=x; Y=y; flag=0; }
    friend inline bool operator<(node x,node y) {
        if(x.flag||y.flag) { return x.K>y.K; }
        return x.X<y.X;
    }
    friend inline bool operator==(node x,node y) { return ABS(x.X-y.X)<1e-8; }
    friend inline double operator*(node x,node y) { return (y.Y-x.Y)/(y.X-x.X); }//斜率
    inline bool error() { return X<-1e20||Y<-1e20; }
} error(-1e21,-1e21);
set<node> dq;
typedef set<node>::iterator ITER;
inline node next(node x) {
    ITER ii=dq.upper_bound(x);
    return ii==dq.end()?error:*ii;
}
inline node lower(node x) {
    ITER ii=dq.lower_bound(x);
    return ii==dq.end()?error:*ii;
}
inline node pre(node x) {
    ITER ii=dq.lower_bound(x);
    return ii==dq.begin()?error:*(--ii);
}
inline void insert(node x) {
    if(dq.empty()) {
        x.K=0;
        dq.insert(x);
        return;
    }
    node L=pre(x),R=lower(x);
    if((L.error()&&x.Y<R.Y)||(!L.error()&&!R.error()&&L*x-L*R<1e-8)/**/||(x==R)) { return; }
    R=next(x);
    while(1) {
        L=R;
        R=next(L);
        if(L.error()||R.error()||(x*L)-(L*R)>=1e-8) { break; }
        dq.erase(L);
    }
    L=pre(x);
    while(1) {
        R=L;
        L=pre(R);
        if(L.error()||R.error()||(L*R)-(R*x)>=1e-8) { break; }
        dq.erase(R);
    }
    L=pre(x);
    R=next(x);
    x.K=(L.error()?0:(L*x));
    dq.insert(x);
    if(!R.error()) {
        dq.erase(R);
        R.K=(x*R);
        dq.insert(R);
    }
}
inline double query(double x,double y) {
    node ii;
    ii.flag=1;
    ii.K=-x/y;
    ii=*(--dq.lower_bound(ii));
    return ii.error()?0:ii.X*x+ii.Y*y;
}
int main() {
    scanf("%d%lf",&N,&S);
    for(int i=1; i<=N; i++) {
        scanf("%lf%lf%lf",&A[i],&B[i],&R[i]);
    }
    F[1]=S;
    CB[1]=S/(A[1]*R[1]+B[1]);
    CA[1]=CB[1]*R[1];
    insert(node(CA[1],CB[1]));
    for(int i=2; i<=N; i++) {
        F[i]=max(F[i-1],query(A[i],B[i]));
        CB[i]=F[i]/(A[i]*R[i]+B[i]);
        CA[i]=CB[i]*R[i];
        insert(node(CA[i],CB[i]));
    }
    printf("%.3lf",F[N]);
    return 0;
}
```

---

## 作者：zhy137036 (赞：6)

前置知识：[斜率优化](/blog/zhy137036/xie-shuai-you-hua)

首先注意到 说明/提示 结尾：

> 必然存在一种最优的买卖方案满足：
>
> 每次买进操作使用完所有的人民币，每次卖出操作卖出所有的金券。

明显需要解一个方程：第 $i$ 天画 $m$ 元买券，每种券各能买到多少。

解得 A 券能买到 $m\cdot\dfrac{R_i}{A_iR_i+B_i}$ 张，B 券能买到 $m\cdot\dfrac1{A_iR_i+B_i}$ 张。

设 $a_i=\dfrac{R_i}{A_iR_i+B_i},b_i=\dfrac1{A_iR_i+B_i}$，则第 $i$ 天画 $m$ 元钱能买到 $a_im$ 张 A 券、$b_im$ 张 B 券。

---

然后发现是一个 dp，设 $f_i$ 表示第 $i$ 天手中没有券（卖掉所有券或本来就没有券）能得到的最大钱数。

这些钱要么是昨天留下来的，要么是卖掉了某天买的券。设卖掉的券是第 $j$ 天买来的，得到转移式：

$$f_i=\max(f_{i-1},\max\limits_{j\in[1,i-1]}(A_ia_jf_j+B_ib_jf_j))$$

解释一下：因为第 $j$ 天得到 $f_j$ 元钱之后可以当天买券，所以能买到 $a_jf_j$ 张 A 券、$b_jf_j$ 张 B 券。卖掉这些券之后可以得到 $A_ia_jf_j+B_ib_jf_j$ 元钱。

看转移式的核心部分：$f_i=A_ia_jf_j+B_ib_jf_j$，有同时与 $i,j$ 有关的项，像斜率优化。

不过一般的斜率优化应该只有一项同时与 $i,j$ 有关的项，还有一项只和 $j$ 有关的项。而这个式子里有两项同时与 $i,j$ 有关的项，没有只和 $j$ 有关的项。

于是考虑将式子除以 $A_i$ ，得到 $\dfrac{f_i}{A_i}=a_jf_j+\dfrac{B_i}{A_i}b_jf_j$。

然后转化为斜截式 $y=kx+b$：

$$a_jf_j=-\dfrac{B_i}{A_i}b_jf_j+\dfrac{f_i}{A_i}$$

其中

$$\begin{aligned}&y=a_jf_j\\&k=-\dfrac{B_i}{A_i}\\&x=b_jf_j\\&b=\dfrac{f_i}{A_i}\end{aligned}$$

注意到其中 $k$ 和 $x$ 都不保证单调，所以朴素的斜率优化不能做。

---

因为 $i$ 从 $j$ 处转移是一种有序点对的关系，所以容易（并不）想到 CDQ 分治。

设函数 $\text{CDQ}(l,r)$ 表示用 $j\ (j\in[l,r])$ 更新 $f_i\ (i\in[l,r])$。也就是在这个区间内部自己更新自己。

根据 CDQ 分治的套路，应该将区间等分成两半 $[l,\textit{mid}],[\textit{mid}+1,r]$，分别递归处理，然后处理跨两个子区间的情况。

但是这就有后效性了：设 $p,q\in[\textit{mid}+1,r]\ (p<q)$，用 $p$ 更新 $q$ 的时候，$p$ 还没被左区间更新呢，所以这个更新没有任何意义。

所以应该先处理左区间，然后用左区间更新右区间，最后处理右区间。

---

怎么用左区间更新右区间呢？

将左区间按 $x$ 排序，建立凸壳；将右区间在凸壳上二分寻找最优决策点。

你也可以将右区间按 $k$ 排序，去掉二分的 $\log$。不过排序还是有一个 $\log$，再算上 CDQ 分治的 $\log$，总复杂度为 $O(n\log^2n)$。

---

具体步骤：对于每个区间 $[l,r]$：

1. 处理左区间；
2. 将左区间按照 $x$ 排序，建立凸壳；
3. 更新右区间；
4. 将左区间恢复原序；
5. 处理右区间。

---

别忘了，$f_i$ 还要被 $f_{i-1}$ 更新呢。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100010;
int n,ds[N],top;
struct point{
	double A,B,R,a,b,id,f;//意义同正文。id 表示编号，用来恢复原序。
}pt[N];
double X(int i) { return pt[i].b*pt[i].f; }//计算第 i 个数的横坐标 x
double Y(int i) { return pt[i].a*pt[i].f; }//计算第 i 个数的纵坐标 y
double K(int i) { return -pt[i].B/pt[i].A; }//计算第 i 个数的斜率 k
double k(int i,int j){//计算第 i 个点和第 j 个点所在直线的斜率
	if(fabs(X(j)-X(i))<1e-9) return 1e9;
	return (Y(j)-Y(i))/(X(j)-X(i));
}
bool cmp1(point i,point j) { return i.b*i.f<j.b*j.f; }//按 x 排序
bool cmp2(point i,point j) { return i.id<j.id; }//恢复原序
void CDQ(int l,int r){
	if(l==r) { pt[l].f=max(pt[l].f,pt[l-1].f); return; }//递归边界
	int m=(l+r)/2; CDQ(l,m);//处理左区间
	sort(pt+l,pt+m+1,cmp1);//将左区间按 x 排序
	top=0;//清空单调栈
	for(int i=l;i<=m;i++){//维护凸壳
		while(top>1&&k(ds[top-1],ds[top])<=k(ds[top],i)) top--;
		ds[++top]=i;
	}
	for(int i=m+1;i<=r;i++){
		int pos=1;
		for(int j=1<<20;j;j/=2)//个人比较喜欢的一种二分写法，当成普通二分就行了
			if(pos+j<=top&&k(ds[pos+j-1],ds[pos+j])>=K(i))
				pos+=j;
		pt[i].f=max(pt[i].f,(Y(ds[pos])-K(i)*X(ds[pos]))*pt[i].A);//更新
	}
	sort(pt+l,pt+r+1,cmp2);//恢复原序
	CDQ(m+1,r);//处理右区间
}
int main(){
	cin>>n>>pt[0].f;
	for(int i=1;i<=n;i++){
		cin>>pt[i].A>>pt[i].B>>pt[i].R;
		pt[i].a=pt[i].R/(pt[i].A*pt[i].R+pt[i].B);//预处理 a,b
		pt[i].b=1/(pt[i].A*pt[i].R+pt[i].B);
		pt[i].id=i;
	}
	CDQ(1,n);
	printf("%.3f\n",pt[n].f);//输出
	return 0;
}
```

---

## 作者：GKxx (赞：4)

### 非旋treap题解

首先，dp方程显然是

$f_i=\max\{\frac{a_if_jr_j}{a_jr_j+b_j}+\frac{b_if_j}{a_jr_j+b_j}\}$

令$x_j=\frac{f_jr_j}{a_jr_j+b_j}, y_j=\frac{f_j}{a_jr_j+b_j}$，则方程变形为

$f_i=\max\{a_ix_j+b_iy_j\}$

$f_i=b_i\max\{y_j-(-\frac{a_i}{b_i})x_j\}$

相当于要最大化斜率为$-\frac{a_i}{b_i}$并且经过点$(x_j,y_j)$的直线在$y$轴上的截距，显然最优点在上凸壳上取得。

由于斜率$k_i=-\frac{a_i}{b_i}$没有单调性，不能用单调队列，我们考虑用平衡树维护动态凸包。

对于每个点$x$，我们可以维护两个信息$lk[x],rk[x]$，分别表示它在凸包上左边那条直线的斜率和右边直线的斜率。对于$i$，其斜率$k_i=-\frac{a_i}{b_i}$，显然其最优决策点$j$满足$lk[j]\geq k_i\geq rk[j]$（注意到凸壳上的斜率单调）

所以查询某个点的最优决策只要按照这个往下找

```cpp
int queryBest(int x, double k) {
    if (!x) return 0;
    if (lk[x] + eps >= k && k + eps >= rk[x]) return x;
    else if (k + eps >= lk[x]) return queryBest(ch[x][0], k);
    else return queryBest(ch[x][1], k);
}
```

先声明一个斜率函数，含义比较显然。

```cpp
inline double slope(int i, int j) {
    if (fabs(xc[i] - xc[j]) <= eps) return inf;
    else return (yc[i] - yc[j]) / (xc[i] - xc[j]);
}
```

考虑如何插入一个点。splay的做法是：先找到$x_i$在平衡树中的位置，插入并splay到根，在左子树中找到第一个能和$i$连起来构成凸包的点$pre$（即满足$lk[pre]>=slope(pre,i)$的最右边的点），把$pre$转到$i$的左孩子，将$pre$的右子树删除（$i$的存在使得这些点不再在凸壳上），然后维护一下$lk[i]=rk[pre]=slope(pre,i)$；再在右子树中做类似的事情，代码就不贴了，前面的题解里有人写。

现在主要说一下非旋treap的做法。其实道理和上面类似，但是我们不能随便把一个点转到根了，我们手中最有力的武器就是分裂与合并。于是我们可以这样：先将整棵树$T$分裂成两棵$L,R$，满足$L$树中最大的$x$值$\leq x_i\leq R$树中最小的$x$值；然后再将$L$分裂成两棵$L_l,L_r$，把不再在凸壳上的点统统放进$L_r$，这棵树就可以直接扔掉了，然后在$L_l$中找最大的点$pre$与$i$求斜率；再在$R$树中做类似的事情（左右反一反什么的）。最后，如果$lk[i]<=rk[i]$，说明$i$并不在凸壳上，这个点不能要。

于是我们就要写好几个不同的split，其实都差不多的。

完整代码：

```cpp
#include <cctype>
#include <cstdio>
#include <climits>
#include <cmath>
#include <algorithm>

#define rep(I, A, B) for (int I = (A); I <= (B); ++I)

template <typename T> inline void read(T& t) {
    int f = 0, c = getchar(); t = 0;
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) t = t * 10 + c - 48, c = getchar();
    if (f) t = -t;
}
template <typename T, typename... Args>
inline void read(T& t, Args&... args) {
    read(t); read(args...); 
}

const int maxn = 1e5 + 207, inf = INT_MAX;
const double eps = 1e-9;
double f[maxn], a[maxn], b[maxn], r[maxn];
double xc[maxn], yc[maxn], lk[maxn], rk[maxn];
int ch[maxn][2], pri[maxn];
int n, root;

inline double slope(int i, int j) {
    if (fabs(xc[i] - xc[j]) <= eps) return inf;
    else return (yc[i] - yc[j]) / (xc[i] - xc[j]);
}
int queryBest(int x, double k) {
    if (!x) return 0;
    if (lk[x] + eps >= k && k + eps >= rk[x]) return x;
    else if (k + eps >= lk[x]) return queryBest(ch[x][0], k);
    else return queryBest(ch[x][1], k);
}
void split_x(int o, double x, int &l, int &r) {
    if (!o) l = r = 0;
    else {
        if (xc[o] <= x + eps) {
            l = o;
            split_x(ch[l][1], x, ch[l][1], r);
        } else {
            r = o;
            split_x(ch[r][0], x, l, ch[r][0]);
        }
    }
}
void split_pre(int o, int x, int &l, int &r) {
    if (!o) l = r = 0;
    else {
        if (lk[o] + eps >= slope(o, x)) {
            l = o;
            split_pre(ch[l][1], x, ch[l][1], r);
        } else {
            r = o;
            split_pre(ch[r][0], x, l, ch[r][0]);
        }
    }
}
void split_nxt(int o, int x, int &l, int &r) {
    if (!o) l = r = 0;
    else {
        if (slope(o, x) + eps >= rk[o]) {
            r = o;
            split_nxt(ch[r][0], x, l, ch[r][0]);
        } else {
            l = o;
            split_nxt(ch[l][1], x, ch[l][1], r);
        }
    }
}
int merge(int x, int y) {
    if (!(x && y)) return x ^ y;
    else {
        if (pri[x] < pri[y]) {
            ch[y][0] = merge(x, ch[y][0]);
            return y;
        } else {
            ch[x][1] = merge(ch[x][1], y);
            return x;
        }
    }
}
inline void insert(int &rt, int id) {
    int x = 0, y = 0;
    split_x(rt, xc[id], x, y);
    int tmp;
    split_pre(x, id, x, tmp);
    if (x) {
        int pre = x;
        while (ch[pre][1]) pre = ch[pre][1];
        rk[pre] = lk[id] = slope(pre, id);
    } else lk[id] = inf;
    split_nxt(y, id, tmp, y);
    if (y) {
        int nxt = y;
        while (ch[nxt][0]) nxt = ch[nxt][0];
        lk[nxt] = rk[id] = slope(id, nxt);
    } else rk[id] = -inf;
    if (lk[id] <= rk[id] + eps) rt = merge(x, y);
    else {
        pri[id] = rand();
        rt = merge(merge(x, id), y);
    }
}

int main() {
    int f0;
    read(n, f0);
    f[0] = f0;
    rep(i, 1, n) scanf("%lf%lf%lf", a + i, b + i, r + i);
    rep(i, 1, n) {
        int j = queryBest(root, -a[i] / b[i]);
        f[i] = std::max(f[i - 1], a[i] * xc[j] + b[i] * yc[j]);
        xc[i] = f[i] * r[i] / (a[i] * r[i] + b[i]);
        yc[i] = f[i] / (a[i] * r[i] + b[i]);
        insert(root, i);
    }
    printf("%.3lf\n", f[n]);
    return 0;
}
```

~~其实写非旋treap是因为我脑洞大开地yy了一些可持久化凸包维护的斜率优化什么的...因为非旋treap可以可持久化嘛...不说了不说了太毒瘤了~~

如果真的在考场上我会选择写splay的。

---

## 作者：Unnamed114514 (赞：4)

upd on 2024/9/20 给了个随机数种子。

***

随机化算法永远滴神！

容易想到每次一定要买就买光。

$dp_i$ 表示第 $i$ 天后不买入所得到的收益。

第一种情况：$i$ 天没干任何事，$dp_i\gets dp_{i-1}$

第二种情况：$i$ 天卖了，枚举是第 $j$ 天买的，$dp_i\gets\dfrac{a_ir_j+b_i}{a_jr_j+b_j}dp_j$。

综上 $dp_{i}\gets\max\{dp_{i-1},\max\dfrac{a_ir_j+b_i}{a_jr_j+b_j}dp_j\}$。

时间复杂度 $O(n^2)$，期望得分 $60$。

***

以下就是乱搞操作。

首先猜测，实际造成贡献的决策点 $j$ 不可能离 $i$ 太远，所以我们可以令枚举的 $j$ 在 $[\max\{1,i-1000\},i]$ 中。

这样可以得到 $70$ 分。

在次基础上，我们随机选取决策点 $j$ 进行转移，不过因为取模较多常数较大，但是实测随机取 $500$ 个就能 AC，不过最慢点 900+ms。

时间复杂度 $O(n)$。

实际测试，随机化种子取 $114514$ 就能过。

```cpp
#include<bits/stdc++.h>
#define endl '\n'
using namespace std;
const int N=1e5+5;
int n;
double dp[N],ans,a[N],b[N],r[N];
int main(){
	mt19937 rnd(114514);
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>dp[1];
	for(int i=1;i<=n;++i) cin>>a[i]>>b[i]>>r[i];
	for(int i=2;i<=n;++i){
		dp[i]=dp[i-1];
		for(int j=max(1,i-1000);j<=i-1;++j) dp[i]=max(dp[i],(a[i]*r[j]+b[i])*dp[j]/(a[j]*r[j]+b[j]));
		for(int k=1;k<=500;++k){
			int j=rnd()%(i-1)+1;
			dp[i]=max(dp[i],(a[i]*r[j]+b[i])*dp[j]/(a[j]*r[j]+b[j]));
		}
	}
	cout<<fixed<<setprecision(3)<<dp[n]<<endl;
	return 0;
}
```

---

## 作者：wzxx (赞：3)

[题目链接](https://www.luogu.com.cn/problem/P4027)

首先，我们可以观察样例解释：

时间|用户操作|人民币(元)|A 券的数量|B 券的数量
-|-|-|-|-
开户|无|100|0|0
第一天|买入100元|0|50|50
第二天|卖出100%|150|0|0
第二天|买入150元|0|75|37.5
第三天|卖出100%|225|0|0

可以发现，给出的这一种最优方案中，每一次买都会把所有钱都用完，每一次卖都会把所有券都卖光。
于是我们可以领悟到，若要使最后得到的金钱数目最多，**每一次买入都应用光所有钱，每一次卖出都应卖出100%**。这可以通过贪心的方式证明，此处不再赘述。

这启发我们，设$f[i]$表示前$i$天最多可以获得多少金钱，考虑第$i$天的操作。

首先，第$i$天可以不进行任何操作：$f[i]=f[i-1]$。

然后我们可以在第$i$天卖出当前拥有的金券，这时便需要我们枚举上一次买入金券是什么时候。

我们也可以在这一天买入金券，但这并不会使前$i$天的答案增大，故无需考虑。（对于这一天买入对未来的影响，将会在后面的天数中考虑到。）

重点考虑如何处理“卖出”的情况。

对于$f[i]$，我们枚举在第$i$天之前的第$j$天，第$j$天能获得的最多金钱数为$f[j]$。考虑$f[j]$这么多的钱在第$j$天能买到多少$A$券、多少$B$券。

设总共能买到$k$张$A$券和$B$券，则：

$A$券有$\dfrac{k\cdot Rate_j}{Rate_j+1}$张。

$B$券有$\dfrac{k}{Rate_j+1}$。

花费为$\dfrac{k\cdot Rate_j\cdot A_j}{Rate_j+1}+\dfrac{k\cdot B_j}{Rate_j+1}=k\cdot\dfrac{Rate_j\cdot A_j+B_j}{Rate_j+1}$。

于是有$f[j]=k\cdot\dfrac{Rate_j\cdot A_j+B_j}{Rate_j+1}\Rightarrow k=f[j]\cdot \dfrac{Rate_j+1}{Rate_j\cdot A_j+B_j}$。

于是$A$券有$f[j]\cdot \dfrac{Rate_j}{Rate_j\cdot A_j+B_j}$张，$B$券有$f[j]\cdot \dfrac{1}{Rate_j\cdot A_j+B_j}$张。

为了方便，设$P_j=f[j]\cdot \dfrac{Rate_j}{Rate_j\cdot A_j+B_j}$，$Q_j=f[j]\cdot \dfrac{1}{Rate_j\cdot A_j+B_j}$。

那么我们就有状态转移方程：

$$f[i]=\max\limits_{1\leq j\leq i-1}\{P_j\cdot A_i+Q_j\cdot B_i\}$$

这样`dp`是$O(n^2)$的，观察到存在与$i$和$j$均有关的乘积项，考虑斜率优化。

去掉$max$。

$$f[i]=P_j\cdot A_i+Q_j\cdot B_i$$

似乎很难变成斜率优化的一般形式。我们可以两边同时除以$B_i$。

$$\dfrac{f[i]}{B_i}=\dfrac{A_i}{B_i}\cdot P_j+Q_j$$

移项：

$$Q_j=-\dfrac{A_i}{B_i}\cdot P_j+\dfrac{f[i]}{B_i}$$

现在这条式子就可以看成是一条斜率为$-\dfrac{A_i}{B_i}$的直线了。

但当我们要进行优化的时候，发现斜率$-\dfrac{A_i}{B_i}$和横坐标$P_j$都没有单调性，难以优化。

这可以用平衡树动态维护凸壳来解决，但也可以使用较为简单的$CDQ$分治来求解。

用$CDQ$分治求解的大致步骤：
- 将所有决策点（从`1`到`n`）存入数组`p`中。
- $p$中的点按斜率从大到小排序。
- 开始分治求解：
- 设当前处理的决策点范围为`l`到`r`，对应`p`数组中的·第`fl`到第`fr`个元素。
- 设$mid=\lfloor \dfrac{l+r}{2} \rfloor$，将`p`数组中的决策点以`mid`为界限分到左右两旁。
- 递归计算`l`到`mid`。
- 左侧的点已按横坐标从小到大排序（见最后一步），用单调队列直接加点维护凸壳。
- 右侧的点斜率依然单调，可以快速从单调队列维护的凸壳中寻找最优决策点，从而更新答案。
- 递归计算`mid+1`到`r`。
- 将`p`中的点按横坐标从小到大排序，方便上一层处理（可以使用归并排序）。
  
  如果使用归并排序，时间复杂度应为$O(nlogn)$，可以通过此题。具体细节看代码。

  （注：不要忘了在分治底层用$f[i-1]$来更新$f[i]$。）

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
	using namespace std;
	const int N=100005;
	int n=0,S=0,p[N],t[N],q[N];
	double A[N],B[N],Ra[N],f[N];
double X(int x)
	{return Ra[x]/(Ra[x]*A[x]+B[x])*f[x];}
double Y(int x)
	{return 1/(Ra[x]*A[x]+B[x])*f[x];}
bool cmp0(int x,int y)
	{return -A[x]/B[x]>-A[y]/B[y];}
bool cmp1(int x,int y)
	{return X(x)<X(y);}
double CalcXL(int k1,int k2)
{
	if(X(k2)==X(k1)) return 9e18; 
	return (Y(k2)-Y(k1))/(X(k2)-X(k1));
}
void PaiXv(int l,int mid,int r)//归并排序
{
	int p1=l,p2=mid+1,cnt=0;
	while(p1<=mid||p2<=r)
	{
		if(p1<=mid&&(p2>r||X(p[p1])<X(p[p2])))
			t[++cnt]=p[p1++];
		else t[++cnt]=p[p2++];
	}
	for(int i=l;i<=r;i++) p[i]=t[i-l+1];
}
void Sol(int l,int r,int fl,int fr)//分治
{
	if(l==r) 
		{f[l]=max(f[l],f[l-1]);return;}
	int mid=(l+r)>>1,cnt=0;
	for(int i=fl;i<=fr;i++)
		if(p[i]<=mid) t[++cnt]=p[i];
	int fmid=fl+cnt-1;
	for(int i=fl;i<=fr;i++)
		if(p[i]>mid) t[++cnt]=p[i];
	for(int i=fl;i<=fr;i++) p[i]=t[i-l+1];
	Sol(l,mid,fl,fmid);
	int L=1,R=0;
	for(int i=fl;i<=fmid;i++)
	{
		while(R>=2&&CalcXL(q[R-1],q[R])<CalcXL(q[R],p[i])) R--;
		q[++R]=p[i];
	}
	for(int i=fmid+1;i<=fr;i++)
	{
		while(R-L+1>=2&&CalcXL(q[L],q[L+1])>-A[p[i]]/B[p[i]]) L++;
		f[p[i]]=max(f[p[i]],X(q[L])*A[p[i]]+Y(q[L])*B[p[i]]);
	}
	Sol(mid+1,r,fmid+1,fr);
	PaiXv(fl,fmid,fr);
}
int main()
{
	scanf("%d%d",&n,&S);
	for(int i=1;i<=n;i++)
		scanf("%lf%lf%lf",&A[i],&B[i],&Ra[i]),p[i]=i;
	sort(p+1,p+n+1,cmp0);
	f[1]=S,Sol(1,n,1,n); 
	printf("%.3f",f[n]);
	return 0;
}
```

---

## 作者：_WA自动机 (赞：3)

$$\href{https://wa-automaton.github.io/2019/04/29/luogu-P4027-NOI-2007-%E8%B4%A7%E5%B8%81%E5%85%91%E6%8D%A2/}{ \blue{ \mathit{\texttt{更好的阅读体验点这里~}}}}$$ 

这是一篇直线型斜率优化的题解  
这道题真的很难想...  
考虑下面的提示：  
在最优方案里，不存在某一时刻，手里既有钱，又有金券。 
这启发我们枚举上一次买入的天数：
$$f(i)=max\{f(i-1),max_{j=0}^{i-1}\{fa(j)*a(i)+fb(j)*b(i)\}\}$$
$$fa(i)=fb(i)*rate(i)$$
$$fb(i)=f(i)/(rate(i)*a(i)+b(i))$$
其中$f(i)$表示第i天能得到的最多钱数，$fa(i),fb(i)$分别表示第i天将手中的钱花光所得到的金券。

直接暴力DP是$O(n^2)$的，不能过。考虑只存在i,j乘积项，试试斜率优化。

首先：有两个关于i，j的乘积项，好像不能表示成一条直线的形式？  
因为a.b都是常量数组，我们将等式两边都除以b(i)，得到：
$$f(i)/b(i)=max\{fa(j)*(a[i]/b[i])+fb(j)\}$$

这样，把$fa$看做斜率，把$a/b$看做x坐标，就是斜率优化的经典柿子辣。然后，我们就可以啊掉这道题了...吗？

容易发现，本题的斜率和坐标都不单调，正常的斜率优化不珂做..

~~果断弃疗~~

全都单调的时候单调队列，一个不单调的二分，两个都不单调的时候...CDQ分治！

我们考虑通过排序先消除一维的影响，再通过分治消除另一维。
具体步骤是这样的：  
1. 分治之前，先将询问按照x坐标（本题中即$a_i/b_i$)排序。
2. 开始分治，设当前区间为[l..r]：（为方便表示，设mid=(l+r)/2）;
3. 将询问按照时间顺序分成[l..mid]和[mid+1..r]两部分。
4. 递归解决[l..mid]的部分。
5. 用[l..mid]的DP值去更新[mid+1..r]的DP值。（先构造左半边的凸壳，然后计算右半边的答案，由于我们已经在递归左半边的时候将决策按照fa排序了，而右半边还没有递归，保持$x$坐标单调的性质，所以直接按照正常的方法用单调队列插入和删除决策就可以了。（见步骤7））
6. 递归解决[mid+1..r]的部分
7. 将[l..mid]和[mid+1..r]两个序列按照$fa(i)$归并。（方便返回上一层递归的时候计算右半边的值）
8. l==r的时候我们应该用i-1的决策更新一下i的决策，因为f是要取历史最大值的。顺便计算一下fa.fb的值。

时间复杂度由于采用了归并排序，为$O(n\lg n)$。实际速度和平衡树差不多，但是码量把平衡树踩爆啦！

代码：
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>

using std::sort;

const int maxn=2e5+100;
const double eps=1e-5;

double a[maxn],b[maxn],rate[maxn];
double ans[maxn];

struct Node
{
    int id;
    double f,fa,fb;
}Q[maxn];

template<class T>inline T max(T a,T b){return a<b?b:a;}
template<class T>inline T min(T a,T b){return a<b?a:b;}

inline void separate(int l,int r)
{
    static Node tmp[maxn];
    int mid=(l+r)>>1;
    for (int i=l,lp=l,rp=mid+1;i<=r;++i)
        if (Q[i].id<=mid) tmp[lp++]=Q[i];
        else tmp[rp++]=Q[i];
    memcpy(Q+l,tmp+l,sizeof(Node)*(r-l+1));
}

inline double K(int x){return Q[x].fa;}
inline double B(int x){return Q[x].fb;}
inline double X(int x){return a[Q[x].id]/b[Q[x].id];}
inline double intersection(int x,int y){return (B(x)-B(y))/(K(y)-K(x));}

inline void solve(int l,int r)
{
    int mid=(l+r)>>1;
    static int q[maxn];
    int head=0,tail=0;
    for (int i=l;i<=mid;++i)
    {
        while (head<tail && intersection(i,q[tail-1])<=intersection(q[tail],q[tail-1])) --tail;
        if (K(q[tail])!=K(i)) q[++tail]=i;
    }
    for (int i=mid+1;i<=r;++i)
    {
        while (head<tail && K(q[head])*X(i)+B(q[head])<=K(q[head+1])*X(i)+B(q[head+1])) ++head;
        Q[i].f=max(Q[i].f,b[Q[i].id]*(K(q[head])*X(i)+B(q[head])));
    }
}

/**
** f(i)=max{fa(j)*a(i)+fb(j)*b(i)}
** i.e. f(i)/b(i)=max{fa(j)*(a[i]/b[i])+fb(j)}
** fa(i)=fb(i)*rate(i)
** fb(i)=f(i)/(rate(i)*a(i)+b(i))
**/

inline void CDQ(int l,int r)
{
    static Node tmp[maxn];
    if (l==r)
    {
        int idx=Q[l].id;
        Q[l].f=max(Q[l].f,ans[idx-1]);
        Q[l].fb=Q[l].f/(rate[idx]*a[idx]+b[idx]);
        Q[l].fa=Q[l].fb*rate[idx];
        ans[Q[l].id]=Q[l].f;
        return;
    }
    int mid=(l+r)>>1;
    separate(l,r);
    CDQ(l,mid);
    solve(l,r);
    CDQ(mid+1,r);
    for (int lp=l,rp=mid+1,tp=l;tp<=r;++tp)
    {
        if ((rp>r) || (lp<=mid && Q[lp].fa<=Q[rp].fa))
            tmp[tp]=Q[lp++];
        else tmp[tp]=Q[rp++];
    }
    memcpy(Q+l,tmp+l,sizeof(Node)*(r-l+1));
}

int main()
{
    int n,s;
    scanf("%d%d",&n,&s);
    for (int i=1;i<=n;++i)
        scanf("%lf%lf%lf",a+i,b+i,rate+i),Q[i].id=i;
    ans[0]=s;
    sort(Q+1,Q+n+1,[](const Node& x,const Node& y) -> bool {return a[x.id]/b[x.id]<a[y.id]/b[y.id];});
    CDQ(1,n);
    printf("%.3lf\n",ans[n]);
}
```


---

## 作者：Adove (赞：2)

来一发线段树的题解

首先我们推下DP的式子

$A[i]c[i]+B[i]c[i]/r[i]=F[i]$

$c[i]=F[i]*r[i]/(A[i]*r[i]+B[i])$

$F[i]=\max_{j<i}\{ A[i]c[j]+B[i]c[j]/r[j] \}$

发现提出$A[i]$之后

剩下

$c[j]+(B[i]/A[i])*(c[j]/r[j])$

即过点$(c[j]/r[j],c[j])$，斜率为$-(B[i]/A[i])$的直线在$y$轴的截距

上凸包二分转移点即可

线段树某一层满了就把下层的归并一下，把ta的凸包建出来

复杂度是$\Theta(n \log^2n)$的

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
#include"cmath"
using namespace std;

const int MAXN=1<<17;
const double eps=1e-7;

int n;
double F[MAXN],A[MAXN],B[MAXN],R[MAXN];
int stk[19][MAXN],ssz[MAXN<<1],siz[MAXN<<1];
struct rpg{
	double x,y;
	int id;
}a[MAXN],b[MAXN],c[MAXN];

bool cmp(rpg a,rpg b){return a.x<b.x;}

bool check(int id1,int id2,int id3)
{
	double dx1=a[id2].x-a[id1].x,dx2=a[id3].x-a[id1].x;
	double dy1=a[id2].y-a[id1].y,dy2=a[id3].y-a[id1].y;
	return dy1*dx2<dy2*dx1+eps;
}

void build(int k,int l,int r,int tp)
{
	int mid=l+r>>1;
	int ct1=l,ct2=mid+1;
	for(int i=l;i<=r;++i){
		if(ct2>r||ct1<=mid&&cmp(b[ct1],b[ct2])) c[i]=b[ct1++];
		else c[i]=b[ct2++];
	}for(int i=l;i<=r;++i) b[i]=c[i];
	ssz[k]=2;
	stk[tp][l]=b[l].id;
	stk[tp][l+1]=b[l+1].id;
	for(int i=l+2;i<=r;++i){
		while(ssz[k]>1&&check(stk[tp][l+ssz[k]-2],stk[tp][l+ssz[k]-1],b[i].id)) --ssz[k];
		stk[tp][l+(++ssz[k])-1]=b[i].id;
	}return;
}

void ins(int k,int l,int r,int id,int tp)
{
	++siz[k];
	if(l==r){ssz[k]=1;stk[tp][l]=l;return;}
	int i=k<<1,mid=l+r>>1;
	if(id<=mid) ins(i,l,mid,id,tp+1);
	else ins(i|1,mid+1,r,id,tp+1);
	if(siz[k]==r-l+1) build(k,l,r,tp);
	return;
}

double calc(int k,int l,int r,int id,int tp)
{
	double w=-B[id]/A[id];
	int le=l,ri=l+ssz[k]-1;
	while(le<ri){
		int mid=le+ri>>1;
		double dx=a[stk[tp][mid+1]].x-a[stk[tp][mid]].x;
		double dy=a[stk[tp][mid+1]].y-a[stk[tp][mid]].y;
		if(dy<w*dx) ri=mid;
		else le=mid+1;
	}int i=stk[tp][le];
	return a[i].y*A[id]+a[i].x*B[id];
}

double query(int k,int l,int r,int id,int tp)
{
	if(r<=id-1) return calc(k,l,r,id,tp);
	int i=k<<1,mid=l+r>>1;double maxn=0;
	maxn=max(maxn,query(i,l,mid,id,tp+1));
	if(mid<id-1) maxn=max(maxn,query(i|1,mid+1,r,id,tp+1));
	return maxn;
}

int main()
{
	scanf("%d%lf",&n,&F[1]);
	for(int i=1;i<=n;++i){
		scanf("%lf%lf%lf",&A[i],&B[i],&R[i]);
		if(i>1) F[i]=max(query(1,1,n,i,0),F[i-1]);
		a[i]=b[i]=(rpg){F[i]/(A[i]*R[i]+B[i]),F[i]*R[i]/(A[i]*R[i]+B[i]),i};
		ins(1,1,n,i,0);
	}printf("%.3lf\n",F[n]);
	return 0;
}
```

---

## 作者：cirnovsky (赞：1)

设 $f(i)$ 为第 $i$ 天的最大钱数，$g_{1}(i)$ 为 A 券的第 $i$ 天能换的数量，$g_{2}(i)$ 则为 B 券。

转移可以解方程得：
$$
f(i)=\max\{f(i-1),a(i)g_{1}(j),b(i)g_{2}(j)\},j\in[1,i) \\
g_{1}(i)\frac{f(i)rate(i)}{a(i)rate(i)+b(i)} \\
g_{2}(i)=\frac{f(i)}{rate(i)\times a(i)+b(i)} \\
$$
两个 $g$ 都没啥问题，主要来看 $f(i)$。提一下可得：
$$
f(i)=\max\{b(i)\max_{j=1}^{i-1}\{\frac{a(i)}{b(i)}g_{1}(j)+g_{2}(j)\},f(i-1)\}
$$

斜率优化的形式，但斜率并无单调性。那个 $f(i-1)$ 可以最后来线性做，所以可以先不管。然后就是 li-chao tree 的板子。

---

## 作者：tzc_wk (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P4027)

纪念一下第一道（？）自己 yy 出来的 NOI 题。

考虑 dp，$dp[i]$ 表示到第 $i$ 天最多有多少钱。

那么有 $dp[i]=\max\{\max\limits_{j=1}^{i-1}a[i]*(dp[j]/(a[j]*r[j]+b[j])*r[j])+b[i]*dp[j]/(a[j]*r[j]+b[j]),dp[i-1]\}$

我们稍微观察一下，里面那个式子似乎能写成斜率优化的样子：

令 $t[j]=dp[j]/(a[j]*r[j]+b[j])$，假设有 $j>k$ 并且从 $j$ 转移比从 $k$ 转移更优，那么：

$$a[i]*t[j]*r[j]+b[i]*t[j]>a[i]*t[k]*r[k]+b[i]*t[k]$$

将这个式子变个形，可以得到：

$$\frac{t[j]*r[j]-t[k]*r[k]}{-t[j]+t[k]}>\frac{b[i]}{a[i]}$$

但显然 $-t[j]$（横坐标） 是不单调的，$\frac{b[i]}{a[i]}$（斜率）也是不单调的。

解决斜率不单调的问题，这与[任务安排](https://www.luogu.com.cn/problem/P2365)有点类似，把所有点扔进凸包后二分斜率找到最优决策点。

解决横坐标不单调的问题，可以借鉴[Cow School](https://www.luogu.com.cn/problem/P2877)的方法，使用CDQ分治将前一半的点按横坐标排序后建立凸包。

具体实现时还有诸多细节需考虑，例如 CDQ 分治中递归的顺序不能搞错，必须按照递归左半边 $\rightarrow$ 用左半边更新右半边答案 $\rightarrow$ 递归右半边的顺序进行，否则无法从 $dp[i]$ 更新到 $dp[i+1]$。还有就是特判斜率不存在的情况。

```cpp
/*
Contest: -
Problem: P4027
Author: tzc_wk
Time: 2020.7.18
*/
#include <bits/stdc++.h>
using namespace std;
#define fi			first
#define se			second
#define fz(i,a,b)	for(int i=a;i<=b;i++)
#define fd(i,a,b)	for(int i=a;i>=b;i--)
#define foreach(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)
#define all(a)		a.begin(),a.end()
#define fill0(a)	memset(a,0,sizeof(a))
#define fill1(a)	memset(a,-1,sizeof(a))
#define fillbig(a)	memset(a,0x3f,sizeof(a))
#define fillsmall(a) memset(a,0xcf,sizeof(a))
#define y1			y1010101010101
#define y0			y0101010101010
typedef pair<int,int> pii;
inline int read(){
	int x=0,neg=1;char c=getchar();
	while(!isdigit(c)){
		if(c=='-')	neg=-1;
		c=getchar();
	}
	while(isdigit(c))	x=x*10+c-'0',c=getchar();
	return x*neg;
}
const double EPS=1e-10;
int n=read();
struct data{
	double a,b,r,dp;
} a[100005],tmp[100005];
inline double _t(int j){
	return 1.0*a[j].dp/(a[j].a*a[j].r+a[j].b);
}
inline double sl(int j,int k){
	if(abs((-_t(j))-(-_t(k)))<EPS)	return 1e9;
	return 1.0*(_t(j)*a[j].r-_t(k)*a[k].r)/((-_t(j))-(-_t(k)));
}
inline void merge(int l,int r,int mid){
	int p1=l,p2=mid+1;
	for(int i=l;i<=r;i++){
		if(p1<=mid&&(p2>r||_t(p1)>_t(p2)))
			tmp[i]=a[p1++];
		else
			tmp[i]=a[p2++];
	}
	for(int i=l;i<=r;i++){
		a[i]=tmp[i];
	}
}
int q[100005];
inline int bsearch(int l,int r,double slo){
	if(l==r)	return q[l];
	int mid=(l+r)>>1;
	if(sl(q[mid+1],q[mid])-slo>EPS)	return bsearch(mid+1,r,slo);
	else							return bsearch(l,mid,slo);
}
inline void CDQ(int l,int r){
	if(l==r){
		a[l+1].dp=max(a[l+1].dp,a[l].dp);
		return;
	}
	int mid=(l+r)>>1;
	CDQ(l,mid);
	int hd=1,tl=0;
	fz(i,l,mid){
		while(hd<tl&&sl(i,q[tl])-sl(q[tl],q[tl-1])>EPS)	tl--;
		q[++tl]=i;
	}
	fz(i,mid+1,r){
		int j=bsearch(hd,tl,1.0*a[i].b/a[i].a);
		a[i].dp=max(a[i].dp,a[i].a*(a[j].dp/(a[j].a*a[j].r+a[j].b)*a[j].r)+a[i].b*a[j].dp/(a[j].a*a[j].r+a[j].b));
		a[i+1].dp=max(a[i+1].dp,a[i].dp);
	}
	CDQ(mid+1,r);
	merge(l,r,mid);
}
signed main(){
	cin>>a[1].dp;
	fz(i,1,n)	scanf("%lf %lf %lf",&a[i].a,&a[i].b,&a[i].r);
	CDQ(1,n);
	printf("%.3lf\n",a[n+1].dp);
	return 0;
}
/*
dp[i]=max{a[i]*(dp[j]/(a[j]*r[j]+b[j])*r[j])+b[i]*dp[j]/(a[j]*r[j]+b[j])}

Let t[j] be dp[j]/(a[j]*r[j]+b[j])

a[i]*t[j]*r[j]+b[i]*t[j]

j>k

a[i]*t[j]*r[j]+b[i]*t[j]>a[i]*t[k]*r[k]+b[i]*t[k]
a[i]*(t[j]*r[j]-t[k]*r[k])>b[i]*(t[k]-t[j])
(t[j]*r[j]-t[k]*r[k])
--------------------->b[i]/a[i]
   (-t[j]-(-t[k]))
*/
```

---

## 作者：KokiNiwa (赞：1)

# [NOI 2007] 货币兑换

这是一个暴力都很难想的斜率优化题。

## 题目叙述

看原题吧。很难叙述。**这题可能股票数量可以是小数。**

## 题解

### 1

首先是`dp`，设$f_{i,j,k}$表示前$i$天$j$张`A`股票，$k$张`B`股票的最大钱数。然而肯定不行。但是状态必须这样。那么复杂度不对。怎么办？

> 可以考虑找性质，一定存在一种方案，每次要么全卖完，要么把钱全花完。

**如果想想出这一步，那么要有一个贪心的思想。**

### 2

设$f_i$为前$i$天的最大钱数（没有股票的最大钱数）。考虑从$f_j$转移。会用$f_j$的钱，选择中间一天，花去这些钱，然后得到更多钱。如何知道选择哪一天花钱呢？又如何选择哪一天得钱呢？这，花钱时间和得钱的时间有关系。所以枚举这一天前在哪一天花钱，哪一天卖股票？然而这不能斜率优化。

> 可以考虑分为两种情况：
>
> 1. 今天卖掉
> 2. 今天不卖掉
>
> 不可能今天买。因为这一天必须卖。
>
> 如果今天不卖掉，那么考虑从哪一天转移。设$x_i$为用第$i$天的钱可以买多少`A`股票，$y_i$为用第$i$天的钱可以买多少`B`股票（按照比例买）。转移就是$A_ix_i+B_iy_i$。
>
> 如果卖掉，直接从$f_{i-1}$转移即可。

**可能如果想要想出这步，那么首先要有一个分类的想法。按照今天卖和不卖分类。**

### 3

考虑斜率优化，再用套路的`cdq`分治优化一下即可。

再推荐一下[这篇](https://www.cnblogs.com/RiverHamster/p/cdq-slopedp.html)题解吧。

## 知识点

+ 可能分个类更好转移。

## 代码

写的时候可以考虑把第$0$天的贡献消除掉，这样就不需要转移的时候考虑第$0$天了。

更多细节见注释。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int maxDay = 1e5 + 5;
int nbDay, Mon;
struct DOT {
	int id;
	double x, y, valA, valB, rate;
} dot[maxDay], rec[maxDay];
double dp[maxDay];
bool Cmp(DOT fir, DOT sec) {
	return (-fir.valA / fir.valB) > (-sec.valA / sec.valB);
	//这里是从大到小排序！所以符号应该是 >，因为下面是 >一个数 
}
double Slope(int fir, int sec) {
	if (dot[fir].x == dot[sec].x)
		return (dot[sec].y > dot[fir].y) ? 1e18 : -1e18 ;
	return (dot[fir].y - dot[sec].y) / (dot[fir].x - dot[sec].x);
}
void Div(int L, int R) {
	if (L == R) {
		dp[L] = max(dp[L], dp[L - 1]);
		dot[L].x = dp[L] * dot[L].rate / (dot[L].valA * dot[L].rate + dot[L].valB);
		dot[L].y = dot[L].x / dot[L].rate;
		return ;
	}
	int mid = (L + R) >> 1;
	for (int pt = L, p1 = L, p2 = mid + 1; pt <= R; ++pt) {
		if (dot[pt].id <= mid) rec[p1++] = dot[pt];
		else rec[p2++] = dot[pt];
	}
	for (int i = L; i <= R; ++i) dot[i] = rec[i];
	Div(L, mid);
	int head = 1, tail = 0;
	static int Q[maxDay];
	//此时左边按照 x轴排好序 
	for (int pt = L; pt <= mid; ++pt) {
		while (head < tail && Slope(Q[tail - 1], Q[tail]) < Slope(Q[tail], pt)) --tail;
		Q[++tail] = pt;
	}
	//右边按照 -a/b排好序 
	for (int pt = mid + 1; pt <= R; ++pt) {
		while (head < tail && Slope(Q[head], Q[head + 1]) > -dot[pt].valA / dot[pt].valB) ++head;
		int now = dot[pt].id;
		//这里应该是 pt对应的下标。。 
		dp[now] = max(dp[now], dot[Q[head]].x * dot[pt].valA + dot[Q[head]].y * dot[pt].valB);
	}
	Div(mid + 1, R);
	for (int pt = L, p1 = L, p2 = mid + 1; pt <= R; ++pt) {
		if (p2 > R || p1 <= mid && dot[p1].x < dot[p2].x) rec[pt] = dot[p1++];
		else rec[pt] = dot[p2++];
	}
	for (int pt = L; pt <= R; ++pt) dot[pt] = rec[pt];
	//这里写错过一次， dot[pt] = rec[pt]写反了 
}
int main() {
	scanf("%d%d", &nbDay, &Mon);
	for (int day = 1; day <= nbDay; ++day) {
		dot[day].id = day;
		scanf("%lf%lf%lf", &dot[day].valA, &dot[day].valB, &dot[day].rate);
		dp[day] = Mon;
	}
	sort(dot + 1, dot + nbDay + 1, Cmp);
	Div(1, nbDay);
	printf("%.3lf\n", dp[nbDay]);
	return 0;
}
```



---

## 作者：__OwO__ (赞：0)

状态转移方程,如何维护的之类的楼上的大佬介绍的很详细了

我在这里介绍一种不用每次复制结构体的方法

可以适当减小常数(虽然不大)

方案如下:

$id$数组储存从当前$cdq$处理后的有序操作序列所对应的原序列下标的.

先将$ id_i$ 初始化为$i$,然后每次取用对应的操作

排序的时候将$id$数组更新即可

因为没有复制结构体,所以理论上会比复制的要快一些

(防杠:)比赛理论上是不会卡cdq的

但是在你谷的高性能评测机上几乎没有区别(约10ms),估计是你谷的评测机内存又快,cpu又给力(点赞)

但是$\mathscr{CCF}$的老爷机就不一定了

这里讨论一下题外话:关于函数引用快还是值复制快的问题

以下是在在`i7-10510U(x64)`上测试的结果,测试为$1e9$次累计用时

一下测试结果引用均为`const T&`而非`T&`(`const`引用比普通引用快,在$1e9$下快1000ms左右)

在都是`int(32bit)`时,值复制快于引用,800ms左右

在两个`int(64bit)`(结构体实现)时,值复制于引用时间相差不大.

在三个及以上可以明显发现引用更快,1000ms左右

推测是`x64`地址是`64bit`的原因,反正$\mathscr{CCF}$用的是8700K,也是`x64`

所以在数据范围较大时,建议稍微卡一下常

另一个话题:`register`是否真的有用

答案是肯定的,$1e9$下从2000ms加速到了230ms(不深入了qwq)

代码:

(其实这样计算下来复制一个`int`和程序中`416bit`的结构体在这个数据下相差的时间完全可以忽略,所以实际考试的时候建议直接复制结构体,简单不易错)
```cpp
#include <bits/stdc++.h>
#define re register
#define il inline
#define _for(i, a, b) for (re int i = a; i <= b; ++i)
typedef double db;
using namespace std;
const db eps = 1e-9;
const int inf = 1e9, N = 1e5 + 5;
int n, s[N];
db dp[N];
struct Node {
    db k, x, y, a, b, r;
    int id;
} q[N];
int id[N], tx[N];
template <typename T>
il T rmax(const T& a, const T& b) {
    return a > b ? a : b;
}
//卡常 此处是double比大小,所以一下的函数与这个速度相差不多,若是大的结构体建议写引用,若是一个int则建议写复制
/*
rmax(T a,T b)
*/
il db rabs(const db& x) { return x > 0 ? x : -x; }//同理
il db getk(int i, int j) {
    i = id[i], j = id[j];
    if (rabs(q[i].x - q[j].x) <= eps) return inf;
    return (q[j].y - q[i].y) / (q[j].x - q[i].x);
}
il void cdq(int l, int r) {
    if (l == r) {
        int u = id[l];
        dp[l] = rmax(dp[l], dp[l - 1]);
        q[u].y = dp[l] / (q[u].a * q[u].r + q[u].b), q[u].x = q[u].y * q[u].r;
        return;
    }
    re int mid = (l + r) >> 1, dx = l - 1, dy = mid, k = 0;
    _for(i, l, r) if (q[id[i]].id <= mid) tx[++dx] = id[i];
    else tx[++dy] = id[i];
    _for(i, l, r) id[i] = tx[i];//复制id而非整个复制结构体
    cdq(l, mid);
    _for(i, l, mid) {
        while (k >= 2 && getk(s[k - 1], s[k]) <= getk(s[k], i) + eps) --k;
        s[++k] = i;
    }
    _for(i, mid + 1, r) {
        int u = id[i];//使用时使用id对应的原操作
        while (k >= 2 && getk(s[k - 1], s[k]) <= q[u].k + eps) --k;
        int j = s[k], v = id[j];
        dp[q[u].id] = rmax(dp[q[u].id], q[v].x * q[u].a + q[v].y * q[u].b);
    }
    cdq(mid + 1, r);
    dx = l, dy = mid + 1;
    _for(i, l, r) if (dx <= mid && (dy > r || q[id[dx]].x < q[id[dy]].x + eps))
        tx[i] = id[dx++];
    else tx[i] = id[dy++];
    _for(i, l, r) id[i] = tx[i];
}
il bool cmp(const Node& r1, const Node& r2) { return r1.k < r2.k; }//此处明显引用更快,
int main() {
    scanf("%d%lf", &n, &dp[0]);
    _for(i, 1, n) {
        scanf("%lf%lf%lf", &q[i].a, &q[i].b, &q[i].r);
        q[i].k = -q[i].a / q[i].b, q[i].id = i;
        id[i] = i;//初始化
    }
    sort(q + 1, q + n + 1, cmp), cdq(1, n);
    printf("%.3lf\n", dp[n]);
    return 0;
}
```

---


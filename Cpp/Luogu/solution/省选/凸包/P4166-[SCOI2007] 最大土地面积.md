# [SCOI2007] 最大土地面积

## 题目描述

在某块平面土地上有N个点，你可以选择其中的任意四个点，将这片土地围起来，当然，你希望这四个点围成的多边形面积最大。


## 说明/提示

数据范围 n<=2000, |x|,|y|<=100000


## 样例 #1

### 输入

```
5
0 0
1 0
1 1
0 1
0.5 0.5```

### 输出

```
1.000```

# 题解

## 作者：HeRaNO (赞：15)

题目描述见[原题](https://www.luogu.com.cn/problem/P4166)。

~~原来以为洛谷上会有很多人发现 hack 点但实际上并没有……~~

要求平面最大组成的四边形面积，实际上和 [Gym102460L](https://codeforces.com/gym/102460) 是一样的，但是由于原 SCOI 题面写的实在是太模糊，并没有说数据是否有重复的点（但是本题中好像不影响答案），所以还是看 Gym 的那道题描述好些。

首先根据调整法，可以证明最大四边形至少有三个点在凸包上，但是凸包大小有三种情况，下面分情况讨论：

#### 凸包大小小于等于 $2$ 时

当凸包大小小于等于 $2$，可以说明原来的所有点都是共线或共点的，易知答案为 $0$。

#### 凸包大小等于 $3$ 时

几乎网上所有题解都忽略了这点，但是 Gym 题目的样例中就能将这些代码卡掉。貌似题解区只有一个灰名用暴力+常数优化过了 hack……

考虑所有的点都在一个三角形范围内，这时答案应该是一个凹四边形，利用旋转卡壳是无法正确求解的。但是根据性质，我们仅需要枚举除构成凸包的三个点以外的点，计算大三角形面积减去由这个点和三角形三边之一组成的三角形面积最小者，得到的就是最终答案了。

#### 凸包大小大于等于 $4$ 时

仍然根据调整法，可知此时组成最大四边形的四个点一定全部位于凸包上，此时枚举这个四边形的对角线，利用旋转卡壳的方式求解分布在对角线两侧的最大三角形，两部分之并即为最大四边形。

总时间复杂度为 $\mathcal{O}(n^2)$，空间复杂度 $\mathcal{O}(n)$。

代码如下：

```cpp
#include <bits/stdc++.h>
#define MAXN 2005
using namespace std;

const double eps=1e-8;

struct Point
{
	double x,y,i;
	Point(){}
	Point(double _x,double _y):x(_x),y(_y){}
	Point operator - (const Point &p2)const{
		return Point(x-p2.x,y-p2.y);
	}
	bool operator < (const Point p)const{
		if (p.x!=x) return p.x>x;
		return p.y>y;
	}
	double operator * (const Point &p2) {
		return 1LL*x*p2.y-1LL*y*p2.x;
	}
};

int n;
Point p[MAXN],ch[MAXN];

int ConvexHull(Point *p,int n)
{
	sort(p,p+n);int m=0;
	for (int i=0;i<n;i++)
	{
		while (m>1&&(ch[m-1]-ch[m-2])*(p[i]-ch[m-2])<=eps) --m;
		ch[m++]=p[i];
	}
	int k=m;
	for (int i=n-2;~i;i--)
	{
		while (m>k&&(ch[m-1]-ch[m-2])*(p[i]-ch[m-2])<=eps) --m;
		ch[m++]=p[i];
	}
	if (n>1) --m;
	return m;
}

inline bool OK(Point a,Point b,Point c,Point d)
{
	double A=fabs((b-a)*(c-a));
	double B=fabs((b-a)*(d-a));
	return A<B;
}

inline void Rotating_Calipers(int m)
{
	double ans=0,now;
	if (m<=2) ans=0;
	else if (m==3)
	{
		now=~(1LL<<63);
		ans=abs((ch[0]-ch[2])*(ch[1]-ch[2]));
		for (int i=0;i<n;i++)
		{
			if (ch[0].i==p[i].i||ch[1].i==p[i].i||ch[2].i==p[i].i) continue;
			double s1=fabs((ch[0]-p[i])*(ch[1]-p[i]));
			double s2=fabs((ch[1]-p[i])*(ch[2]-p[i]));
			double s3=fabs((ch[2]-p[i])*(ch[0]-p[i]));
			now=min(min(now,s1),min(s2,s3));
		}
		if (now!=~(1LL<<63)) ans-=now;
		else ans=0;
	}
	else
	{
		for (int i=0;i<m;i++)
		{
			int x=(i+1)%m,y=(i+2)%m;
			for (int j=(i+2)%m;j!=i;(++j)%=m)
			{
				while (x!=j&&OK(ch[i],ch[j],ch[x],ch[x+1])) (++x)%=m;
				while (y!=i&&OK(ch[i],ch[j],ch[y],ch[y+1])) (++y)%=m;
				now=fabs((ch[x]-ch[i])*(ch[j]-ch[i]))+fabs((ch[y]-ch[i])*(ch[j]-ch[i]));
				if (now>ans) ans=now;
			}
		}
	}
	printf("%.3lf\n",ans/2.0);
	return ;
}

int main()
{
	scanf("%d",&n);
	for (int i=0;i<n;i++) scanf("%lf %lf",&p[i].x,&p[i].y),p[i].i=i;
	Rotating_Calipers(ConvexHull(p,n));
	return 0;
}
/*
4
0 0
4 0
0 4
1 1
*/
```

---

## 作者：zsplj_ (赞：15)

本题可以做到$O(nlogn)$，瓶颈在于求凸包。

首先这四个点肯定都在凸包上，所以首先求出凸包。

而且这个四边形的对角线的两个端点一定是对踵点，考虑旋转卡壳，$O(n)$枚举对角线$P_u,P_v$，并在枚举的过程中维护分别在对角线两侧，离对角线距离最远的点$P_a,P_b$。

容易发现这个过程中$u,v,a,b$都只对每个点扫了$O(1)$次，总时间复杂度为$O(n)$。

加上凸包的复杂度，总复杂度尾为$O(nlogn)$。

代码

（之前的代码出了写小错误，在枚举点u,v时,使用u+1,v+1没有进行模运算，已更正）
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cmath>
#include <vector>

const double eps = 1e-10;

inline int dcmp(const double &x) {
	if (fabs(x) < eps) return 0; return x < 0 ? -1 : 1;
}

namespace geometry {
	using std::max;
	using std::sort;
	using std::unique;

	struct point {
		double x, y;
		point(double x = 0, double y = 0) : x(x), y(y) { }
		bool operator < (const point &b) const {
			return x != b.x ? x < b.x : y < b.y;
		}
	};
	typedef point vector;
	typedef std::vector<point> polygon;

	struct line {
		point p; vector v; double ang;
		line() {}
		line(point p, vector v) : p(p), v(v) { ang = atan2(v.y, v.x);}
		bool operator < (const line &b) const {
			return ang < b.ang;
		}
	};
	typedef std::vector<line> line_set;

	vector operator + (const vector &A, const vector &B) { return point(A.x + B.x, A.y + B.y);}
	vector operator - (const point &A, const point &B) { return point(A.x - B.x, A.y - B.y);}
	vector operator * (const vector &A, const double &b) { return vector(A.x * b, A.y * b);}
	vector operator / (const vector &A, const double &b) { return vector(A.x / b, A.y / b);}
	bool operator == (const point &A, const point &B) { return fabs(A.x - B.x) < eps && fabs(A.y - B.y) < eps;}

	inline double dot(const vector &A, const vector &B) { return A.x * B.x + A.y * B.y;}
	inline double cross(const vector &A, const vector &B) { return A.x * B.y - A.y * B.x;}
	inline double length(const vector &A) { return sqrt(dot(A, A));}
	inline double angle(const vector &A, const vector &B) { return acos(dot(A, B) / length(A) / length(B));}

	inline vector rotate(const vector &A, const double &rad) {
		double c = cos(rad), s = sin(rad);
		return vector(A.x * c - A.y * s, A.x * s + A.y * c);
	}

	inline vector normal(const vector &A) {
		double L = length(A); return vector(-A.y / L, A.x / L);
	}

	inline bool on_left(line L, point p) {
		return cross(L.v, p - L.p) > 0;
	}

	inline bool on_segment(point p, point a1, point a2) {
		return dcmp(cross(a1 - p, a2 - p) == 0) && dcmp(dot(a1 - p, a2 - p)) < 0;
	}

	inline bool segment_proper_intersection(point a1, point a2, point b1, point b2) {
		double c1 = cross(a2 - a1, b1 - a1), c2 = cross(a2 - a1, b2 - a1),
			   c3 = cross(b2 - b1, a1 - b1), c4 = cross(b2 - b1, a2 - b1);
		return dcmp(c1) * dcmp(c2) < 0 && dcmp(c3) * dcmp(c4) < 0;
	}

	int in_polygon(point p, polygon &poly) {
		int wn = 0;
		for (int i = 0, n = poly.size(); i < n; i++) {
			if (on_segment(p, poly[i], poly[i%n+1])) return -1;
			int k = dcmp(cross(poly[i%n+1] - poly[i], p - poly[i]));
			int d1 = dcmp(poly[i].y - p.y);
			int d2 = dcmp(poly[i%n+1].y - p.y);
			if (k > 0 && d1 <= 0 && d2 > 0) wn++;
			if (k < 0 && d2 <= 0 && d1 > 0) wn--;
		}
		if (wn != 0) return 1;
		return 0;
	}

	inline point line_intersection(point p, vector v, point q, vector w) {
		vector u = p - q; double t = cross(w, u) / cross(v, w);
		return p + v * t;
	}
	
	inline point line_intersection(line a, line b) {
		vector u = a.p - b.p; double t = cross(b.v, u) / cross(a.v, b.v);
		return a.p + a.v * t;
	}

	double distance_to_line(point p, point a, point b) {
		vector v1 = b - a, v2 = p - a;
		return fabs(cross(v1, v2)) / length(v1);
	}
	
	double distance_to_line(point p, line L) {
		vector v2 = p - L.p;
		return fabs(cross(L.p, v2)) / length(L.p);
	}
	
	double polygon_area(polygon &poly) {
		double ans = 0;
		for (int i = 1, n = poly.size(); i < n - 1; i++)
			ans += cross(poly[i] - poly[0], poly[i+1] - poly[0]);
		return ans / 2;
	}

	polygon convex_hull(polygon &p) {
		sort(p.begin(), p.end());
		p.erase(unique(p.begin(), p.end()), p.end());
		int m = 0, n = p.size(); polygon ch(n + 1);
		for (int i = 0; i < n; i++) {
			while (m > 1 && cross(ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0) m--;
			ch[m++] = p[i];
		}
		for (int i = n - 2, k = m; i >= 0; i--) {
			while (m > k && cross(ch[m-1] - ch[m-2], p[i] - ch[m-2]) <= 0) m--;
			ch[m++] = p[i];
		}
		if (n > 1) m--; ch.resize(m);
		return ch;
	}

	polygon half_plane_intersection(line_set &L) {
		sort(L.begin(), L.end());
		int first, last, n = L.size();
		point *p = new point[n]; line *q = new line[n];
		q[first=last=0] = L[0];
		for (int i = 1; i < n; i++) {
			while (first < last && !on_left(L[i], p[last-1])) last--;
			while (first < last && !on_left(L[i], p[first])) first++;
			q[++last] = L[i];
			if (fabs(cross(q[last].v, q[last-1].v)) < eps)
				if (on_left(q[--last], L[i].p)) q[last] = L[i];
			if (first < last) p[last-1] = line_intersection(q[last-1], q[last]);
		}
		polygon ans;
		while (first < last && !on_left(q[first], p[last-1])) last--;
		if (last - first <= 1) return ans;
		p[last] = line_intersection(q[last], q[first]);
		for (int i = first; i <= last; i++) ans.push_back(p[i]);
		return ans;
	}
}

using namespace std;
using namespace geometry;

int n;
double ans;
polygon p;

inline void chkmx(int u, int v, int &a, int &b) {
	while ((a + 1) % n != v && distance_to_line(p[a+1], p[u], p[v]) > distance_to_line(p[a], p[u], p[v]))
		a = (a + 1) % n;
	while ((b + 1) % n != u && distance_to_line(p[b+1], p[u], p[v]) > distance_to_line(p[b], p[u], p[v]))
		b = (b + 1) % n;
	ans = max(ans,
		  length(p[u] - p[v]) * (distance_to_line(p[b], p[u], p[v]) + distance_to_line(p[a], p[u], p[v])));
}

int main() {
	double x, y;
	cin >> n; p.resize(n);
	for (int i = 0; i < n; i++)
		cin >> x >> y, p[i] = point(x, y);
	p = convex_hull(p);
	
	n = p.size();
	for (int u = 0, v = 1, a = 0, b = 1; u < n; u++) {
		while (1) {
			int diff = dcmp(cross(p[(u+1)%n] - p[u], p[(v+1)%n] - p[v]));
			if (diff <= 0) {
				chkmx(u, v, a, b);
				if (diff == 0) chkmx(u, (v + 1) % n, a, b);
				break;
			}
			if (b == v) b = (b + 1) % n;
			v = (v + 1) % n;
		}
		if (a == u) a = (a + 1) % n;
	}
	printf("%.3lf\n", ans / 2);
}
```

---

## 作者：pufanyi (赞：11)

首先想到的当然是$n^4$大力枚举所有点。

考虑优化，发现我们可以枚举一条边，再以该边为对角线求出左右两边的三角形最大值（我的方法是用叉积求出有向面积，找出最大值与最小值，减一下即可），30分。

考虑继续优化，我们发现四边形的四个顶点一定在凸包上，所以求先求凸包再枚举，50分。

五十分核心代码大致如下：

```cpp
tubao();
double ans = 0.;
for(int i = 1; i <= m; ++i)
{
	for(int j = 1; j < i; ++j)
	{
		minn = inf;
		maxx = -inf;
		for(int k = 1; k <= m; ++k)
		{
			if(i == k || j == k)
				continue;
			double area = area2(P[sta[i]], P[sta[j]], P[sta[k]]);
			minn = min(minn, area);
			maxx = max(maxx, area);
		}
		if(minn < 0. && maxx > 0.)
			ans = max(maxx - minn, ans);
	}
}
printf("%.3f", ans / 2.);
```

我们又能发现对于一条边，如果它在凸包上且作为对角线，我们发现凸包上的一侧的点到该线段的距离是一个凸函数，所以我们考虑三分，复杂度$O(n^2\log n)$，听说卡一下常能过。

综上，我们发现我们整理已经整理出了一些性质，虽然都非常显而易见，但我们还没有把它们结合起来。

首先，凸包是肯定要求的。

受到之前的启发，我们仍然考虑枚举一条对角线，设现在枚举到的顶点为$i, j$。

设另两个点为$a, b$。我们先来看$b$。

首先，我们不难得出如果确定$i,j$，那$b$到$ij$的距离一定是单峰的。那如果$j$开始逆时针转动，峰显然也会逆时针转动（可以想象是整个凸包转过来了）。

![](https://github.com/pfypfypfy/images-in-blogs/blob/master/20180629003.png?raw=true)

于是我们让$b$逆时针跑就行了。

那$a$也同理。

我们发现$b$对每个点只扫了一遍，对于每个$i$复杂度$O(n)$，同理$j,b$都是，所以总复杂度$O(n^2)$。

核心代码如下：

```cpp
tubao();
double ans = 0.;
for(int i = 1; i <= m; ++i)
{
	int a = i % m + 1;
	int b = (i + 2) % m + 1;
	for(int j = i % m + 2; j <= m; ++j)
	{
		while(a % m + 1 != j && area(P[sta[i]], P[sta[j]], P[sta[a%m+1]]) > area(P[sta[i]], P[sta[j]], P[sta[a]]))
			a = a % m + 1;
		while(b % m + 1 != i && area(P[sta[i]], P[sta[j]], P[sta[b%m+1]]) > area(P[sta[i]], P[sta[j]], P[sta[b]]))
			b = b % m + 1;
		ans = max(ans, area(P[sta[i]], P[sta[j]], P[sta[a]]) + area(P[sta[i]], P[sta[j]], P[sta[b]]));
	}
}
printf("%.3f", ans / 2.);
```

---

## 作者：huangzirui (赞：4)

首先显然选取的四个点都在凸包上。

求出凸包以后考虑暴力。

枚举四边形的四个点 $O(n^4)$ 效率太低。

考虑优化。发现数据范围 $n\le 2000$。于是考虑 $O(n^2)$ 算法。

考虑只枚举对角线，剩下的两个点通过某些技巧找到。

因为要让四边形面积最大，不妨把四边形面积转化为两个三角形的面积，

即 四边形$\text{abcd} (\text{a}<\text{b}<\text{c}<\text{d})$ 中枚举点 $\text{a}$ 和点 $\text{c}$ 。

令 $S\Delta abc$ 和 $S\Delta acd$ 面积最大。

又由于两个面积互不干扰，因此可以分开计算。

（这里建议自己画图方便理解。）

假设我们的多边形是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/28y725wl.png)

我们显然可以找出 $b$ 的位置。

当 $c$ 点往上移：

![](https://cdn.luogu.com.cn/upload/image_hosting/2xxwgo8l.png)

$b$ 点一定不会反而向左移。

当 $a$ 向下移：

![](https://cdn.luogu.com.cn/upload/image_hosting/bn17vu5u.png)

$b$ 点也不会向上移。

然后这个东西其实就很像旋转卡壳。

于是 $O(n^2)$ 枚举套一个类旋转卡壳的东西即可。

```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<algorithm>
#include<cmath>
#define ll  
using namespace std;
inline int read(){
	char c=getchar();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
int i,j,k,n,m;
struct point{
	 double x,y;
}a[1000010];
const double eps=1e-15;
bool can(int X1,int X2,int Y1,int Y2){
	return (a[Y1].x-a[Y2].x)*(a[X1].y-a[X2].y)-(a[X1].x-a[X2].x)*(a[Y1].y-a[Y2].y)>-eps;
}
double dist(int X,int Y){
	return sqrt((a[X].x-a[Y].x)*(a[X].x-a[Y].x)+(a[X].y-a[Y].y)*(a[X].y-a[Y].y));
}
int T[1000010];
bool cmp(point x,point y){
	return x.x<y.x||(x.x==y.x&&x.y<y.y);
}
int S[1000010];
void work(){
	int top=0;
	sort(a+1,a+1+n,cmp);
	for(i=1;i<=n;i++){
		while(top>1 && can(S[top-1],i,S[top-1],S[top]))top--;
		S[++top]=i;
	}
	top--;
	while(top)T[++k]=S[top--];
	top=0;
	for(i=n;i>=1;i--){
		while(top>1 && can(S[top-1],i,S[top-1],S[top]))top--;
		S[++top]=i;
	}
	top--;
	while(top)T[++k]=S[top--];
//	cout<<k<<endl;
//	for(i=1;i<=k;i++)cout<<T[i]<<' ';cout<<endl; 
}
double sum(double a,double b,double c){
	double p=(a+b+c)/2;
	return sqrt(p*(p-a)*(p-b)*(p-c));
}
double getsum(int a,int b,int c){
	return sum(dist(a,b),dist(b,c),dist(c,a));
}
double ans=0;
int main(){
	while(cin>>n){
		ans=0;k=0;
		for(i=1;i<=n;i++)
			scanf("%lf%lf",&a[i].x,&a[i].y);
		work();
		
		if(k<=3){
			printf("0.000\n");
			continue;
		}
		for(i=1;i<=k-3;i++){
			int x=i+1,y=i+3;
			for(j=i+2;j<=k;j++){
				while(x+1!=j && getsum(T[i],T[x],T[j])<getsum(T[i],T[x+1],T[j]))++x;
				while(y!=k && getsum(T[i],T[y],T[j])<getsum(T[i],T[y+1],T[j]))++y;
				ans=max(ans,getsum(T[i],T[j],T[x])+getsum(T[i],T[j],T[y]));
			}
		}
		printf("%.3lf\n",ans);
	}
	return 0;
}
```

---

## 作者：Victorique (赞：4)

楼下暴力确有可取之处，但这个题正解不还是凸包么。。。

关于凸包可以转蒟蒻博客：[凸包小结](http://www.cnblogs.com/victorique/p/8666123.html)

首先我们可以考虑到如果我们取到了一个最大的四边形，那么这个四边形的四个顶点一定是这些点凸包上的点。也就是说，我们需要先求出这些点的凸包。

那么求出来了之后呢？我们很明显不能暴力求。。。复杂度明显是N^4级别。那么我们应该怎么求呢？考虑四边形性质，可以沿着对角线分成两个三角形，我们只需枚举对角线即可，然后旋转卡壳，求出两边最大三角形的面积求和即可。三角形的面积可以是这个三角形构成平行四边形的面积/2，所以用叉积就可以方便求出。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#define ll long long
#define inf 50000000
#define re register
#define MAXN 5005
using namespace std;
struct node{
	double x,y;
};
node a[MAXN],stackk[MAXN];
double xx,yy;
int n,top;
inline int read()
{
    int x=0,c=1;
    char ch=' ';
    while((ch>'9'||ch<'0')&&ch!='-')ch=getchar();
    while(ch=='-') c*=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-'0',ch=getchar();
    return x*c;
}
inline bool cmp(node a,node b)
{
	if(a.y==b.y) return a.x<b.x;
	return a.y<b.y;
}
inline double cross(node a,node b,node c)
{
	return (b.x-a.x)*(c.y-a.y)-(c.x-a.x)*(b.y-a.y);
}
inline double js(node a,node b)
{
	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}
inline bool cmp1(node a,node b)
{
	int k=cross(stackk[1],a,b);
	if(k>0) return 1;
	else if(k==0) return js(stackk[1],a)<js(stackk[1],b);
	return 0;
}
int main()
{
	n=read();
	for(re int i=1;i<=n;i++)
	scanf("%lf %lf",&a[i].x,&a[i].y);
	sort(a+1,a+n+1,cmp);
	stackk[++top]=a[1];
	sort(a+2,a+n+1,cmp1);
	stackk[++top]=a[2];stackk[++top]=a[3];
	for(re int i=4;i<=n;i++){
		while(top>0&&cross(stackk[top-1],stackk[top],a[i])<=0)
		top--;
		stackk[++top]=a[i];
	}
	stackk[++top]=a[1];
	double ans=0;
	int a,b;
	for(re int x=1;x<=top;x++){
		a=x%top+1;b=(x+2)%top+1;
		for(re int y=x+2;y<=top;y++){
			while(a%top+1!=y&&cross(stackk[x],stackk[a+1],stackk[y])>cross(stackk[x],stackk[a],stackk[y]))
			a=a%top+1;
			while(b%top+1!=x&&cross(stackk[x],stackk[y],stackk[b+1])>cross(stackk[x],stackk[y],stackk[b]))
			b=b%top+1;
			ans=max(cross(stackk[x],stackk[a],stackk[y])+cross(stackk[x],stackk[y],stackk[b]),ans);
		}
	}
	printf("%.3lf",ans/2);
}
```

---

## 作者：SuperJvRuo (赞：3)

一道很有意思的计算几何


四边形的四个顶点显然一定在凸包上


那么求出凸包之后呢？我们很容易想到枚举四个顶点的O(n^4)的做法


但是如果用旋（xuán）转（zhuǎn)卡(qiǎ)壳(ké)来优化的话


![](https://cdn.luogu.com.cn/upload/pic/13682.png )

就变成了O(n^2)


```cpp
#include<cmath>
#include<cstdio>
#include<iostream>
#include<algorithm>

using namespace std;

struct Point
{
    double x, y;
}point[2018], stack[2018];
int n, top;
double ans;
//各种向量运算
double dis(Point a, Point b)
{
    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);
}

Point operator - (Point a, Point b)
{
    return (Point){a.x - b.x, a.y - b.y};
}

double operator * (Point a, Point b)
{
    //向量叉积cross(A,B)=xA*yB-xB*yA;
    return a.x * b.y - a.y * b.x;
}
bool operator < (Point a, Point b)
{
    double t = (a - point[1]) * (b - point[1]);
    return t > 0 || t == 0 && dis(point[1], a) < dis(point[1], b);
}


int main()
{
    scanf("%d", &n);
    for(int i = 1; i <= n; i++)
        scanf("%lf%lf", &point[i].x, &point[i].y);
    
    //求凸包 
    //迭代找出纵坐标最小的点 
    int k = 1;
    for(int i = 2; i <= n; i++)
        if(point[k].y > point[i].y || point[k].y == point[i].y && point[k].x > point[i].x)
            k = i;
    swap(point[k], point[1]);
    
    //按极角排序
    sort(point + 2, point + n + 1);
    //我们钦定纵坐标最小的点、极角最小的点一定在凸包上
    stack[++top] = point[1]; stack[++top] = point[2];
    for(int i = 3; i <= n; i++)
    {
        while(top > 1 && (stack[top] - stack[top-1]) * (point[i] - stack[top-1]) <= 0)
        //叉积小于0，说明栈顶向量不在凸包上
            top--;
        stack[++top] = point[i];
        //新向量加入凸包
    }
    //旋转卡壳
    stack[top+1] = point[1];
    int a, b;
    for(int i = 1; i <= top; i++)
    { 
        a = i % top + 1; b = (i + 2) % top + 1;
        for(int j = i + 2; j <= top; j++)
        { 
            while(a % top + 1 != j && (stack[a] - stack[i])*(stack[j] - stack[i]) < (stack[a+1] - stack[i])*(stack[j] - stack[i]))
                a = a % top + 1;
            while(b % top + 1 != j && (stack[j] - stack[i])*(stack[b] - stack[i]) < (stack[j] - stack[i])*(stack[b+1] - stack[i]))
                b = b % top + 1;
            ans = max(ans, (stack[a] - stack[i])*(stack[j] - stack[i]) + (stack[j] - stack[i])*(stack[b] - stack[i]));
        }
    }
    printf("%.3lf",ans/2.0);
    return 0;
}
```

---

## 作者：Genius_Star (赞：2)

本题解说明了 $O(N^2)$ 与 $O(N \log N)$ 做法，与后面做法的证明。

### 思路：

显然，最大四边形的四条边一定在凸包上（可以使用反证法证明）。

且发现本题数据范围很小，支持 $n^2$ 的做法，于是我们考虑枚举这个四边形的两个要素。

由于要算面积，所以枚举对角线得到的信息是最多的，以这个对角线为底，只需要找这条线上分距离这条线最大的点和下方距离这条线最远的点。

诶，这不就是旋转卡壳板子吗？设枚举的对角线为 $i, j$，那么要找的两个点 $a, b$ 就是这条线的对踵点，在 $j$ 逆时针变化时，$a, b$ 同样也是逆时针变化的；注意这里向量 $a, b$ 在向量 $ij$ 上方向是不同的，所以正负换一下或者向量取反一下。

本文使用 Andrew 算法求凸包，时间复杂度为 $O(N^2)$。

需要注意细节~~虽然这个细节洛谷不需要就是了~~：

- 若凸包大小为 $2$，说明这些点都在一条直线上，无法构造出面积非 $0$ 的四边形。

- 凸包大小为 $3$，这些点在一个三角形内，此时最大的四边形面积是一个凹四边形，即选择凸包上的三个点和内部的一个点，面积是凸包三角形减去内部该点和三组边之间组成三角形面积最小值；于是我们枚举内部这个点就可以了。

### 完整代码：

```cpp
 #include<bits/stdc++.h>
#define lowbit(x) x & (-x)
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define add(x, y) ((x + y >= mod) ? (x + y - mod) : (x + y))
#define dec(x, y) ((x - y < 0) ? (x - y + mod) : (x - y))
#define ctz(x) __builtin_ctz(x)
#define popcnt(x) __builtin_popcount(x)
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
using namespace std;
typedef __int128 __;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const int N = 2e3 + 10;
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
db ans;
int n;
int stk[N];
class Point{
public:
	db x, y;
	inline Point(db _x = 0, db _y = 0){
		x = _x;
		y = _y;
	}
	inline bool operator<(const Point&rhs)const{
		if(x == rhs.x)
		  return y < rhs.y;
		return x < rhs.x;
	}
	inline void Read(){
		scanf("%lf%lf", &x, &y);
	}
	inline bool operator==(const Point &rhs)const{
		return (x == rhs.x) && (y == rhs.y);
	}
	inline Point operator-(const Point &rhs)const{
		return {x - rhs.x, y - rhs.y};
	}
	inline Point operator+(const Point &rhs)const{
		return {x + rhs.x, y + rhs.y};
	}
	inline friend Point rotate(Point a, db theta){
		db coss = cos(theta), sinn = sin(theta);
//		cerr << coss << ' ' << sinn << ' ' << theta << ;
		return {a.x * coss - a.y * sinn, a.x * sinn + a.y * coss};
	}
	inline friend db dis(Point a, Point b){
		return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
	}
	inline friend db dot(Point a, Point b){
		return a.x * b.x + a.y * b.y;
	}	
	inline friend db cross(Point a, Point b){
		return a.x * b.y - a.y * b.x;
	}	
	inline friend db cross(Point a, Point b, Point c){
		return cross(c - a, b - a);
	}
	inline friend bool check(Point a, Point b, Point c){
		if(!cross(a, b, c) && c.x >= min(a.x, b.x) && c.x <= max(a.x, b.x) && c.y >= min(a.y, b.y) && c.y <= max(a.y, b.y))
		  return 1;
		return 0;
	}
}A[N];
inline int Andrew(Point a[], int n){
	int top = 0;
	sort(a + 1, a + n + 1);
	for(int i = 1; i <= n; ++i){
		while(top > 1 && cross(a[stk[top - 1]], a[stk[top]], a[i]) <= 0)
		  --top;
		stk[++top] = i;
	}
	int lst = top;
	for(int i = n - 1; i >= 1; --i){
		while(top > lst && cross(a[stk[top - 1]], a[stk[top]], a[i]) <= 0)
		  --top;
		stk[++top] = i;		
	}
	return top - 1;
}
bool End;
signed main(){
	n = read();
	for(int i = 1; i <= n; ++i)
	  A[i].Read();
	int len = Andrew(A, n);
	if(len == 2 || n < 4){
		puts("0");
		return 0;
	}
	if(len == 3){
		db now = 0, all = 1e18;
		now = fabs(cross(A[stk[1]], A[stk[2]], A[stk[3]]));
		for(int i = 1; i <= n; ++i){
			if(i == stk[1] || i == stk[2] || i == stk[3])
			  continue;
			all = min({all, fabs(cross(A[i], A[stk[1]], A[stk[2]])), fabs(cross(A[i], A[stk[2]], A[stk[3]])), fabs(cross(A[i], A[stk[3]], A[stk[1]]))});
		}
		printf("%.3lf\n", (now - all) / 2.0);
		return 0;
	}
	for(int i = 1; i <= len; ++i){
		int a = i, b = i + 1;
		for(int j = i + 1; j <= len; ++j){
			while(cross(A[stk[j]], A[stk[i]], A[stk[a]]) < cross(A[stk[j]], A[stk[i]], A[stk[a + 1]]))
			  a = a % len + 1;
			while(cross(A[stk[i]], A[stk[j]], A[stk[b]]) < cross(A[stk[i]], A[stk[j]], A[stk[b + 1]]))
			  b = b % len + 1;
			ans = max(ans, cross(A[stk[j]], A[stk[i]], A[stk[a]]) + cross(A[stk[i]], A[stk[j]], A[stk[b]]));
		}
	}
	printf("%.3lf\n", ans / 2.0);
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

### 优化：

这就结束了吗？

本题题解区里有提到“这个四边形的对角线一定是对踵点”，然后就可以做到 $O(N \log N)$，但是没有给出证明。

证明也是容易的，上面我们已经可以通过一条对角线 $ij$ 算出使得面积最大的另外一条对角线 $ab$，且这个对角线上的两个点肯定是对踵点；此时用同样的方法计算确定对角线 $ab$ 后使得面积最大的对角线 $cd$，这个 $cd$ 也是对踵点；由前面提到最优性可以得到 $S_{acbd} \ge S_{iajb}$，得证。

于是我们枚举 $i$，其对踵点 $j$ 是单调的，同时 $a, b$ 也是单调的。

时间复杂度为 $O(N \log N)$。

### 完整代码：

```cpp
 #include<bits/stdc++.h>
#define lowbit(x) x & (-x)
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define add(x, y) ((x + y >= mod) ? (x + y - mod) : (x + y))
#define dec(x, y) ((x - y < 0) ? (x - y + mod) : (x - y))
#define ctz(x) __builtin_ctz(x)
#define popcnt(x) __builtin_popcount(x)
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
using namespace std;
typedef __int128 __;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const int N = 2e3 + 10;
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
db ans;
int n;
int stk[N];
class Point{
public:
	db x, y;
	inline Point(db _x = 0, db _y = 0){
		x = _x;
		y = _y;
	}
	inline bool operator<(const Point&rhs)const{
		if(x == rhs.x)
		  return y < rhs.y;
		return x < rhs.x;
	}
	inline void Read(){
		scanf("%lf%lf", &x, &y);
	}
	inline bool operator==(const Point &rhs)const{
		return (x == rhs.x) && (y == rhs.y);
	}
	inline Point operator-(const Point &rhs)const{
		return {x - rhs.x, y - rhs.y};
	}
	inline Point operator+(const Point &rhs)const{
		return {x + rhs.x, y + rhs.y};
	}
	inline friend Point rotate(Point a, db theta){
		db coss = cos(theta), sinn = sin(theta);
//		cerr << coss << ' ' << sinn << ' ' << theta << ;
		return {a.x * coss - a.y * sinn, a.x * sinn + a.y * coss};
	}
	inline friend db dis(Point a, Point b){
		return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
	}
	inline friend db dot(Point a, Point b){
		return a.x * b.x + a.y * b.y;
	}	
	inline friend db cross(Point a, Point b){
		return a.x * b.y - a.y * b.x;
	}	
	inline friend db cross(Point a, Point b, Point c){
		return cross(c - a, b - a);
	}
	inline friend bool check(Point a, Point b, Point c){
		if(!cross(a, b, c) && c.x >= min(a.x, b.x) && c.x <= max(a.x, b.x) && c.y >= min(a.y, b.y) && c.y <= max(a.y, b.y))
		  return 1;
		return 0;
	}
}A[N];
inline int Andrew(Point a[], int n){
	int top = 0;
	sort(a + 1, a + n + 1);
	for(int i = 1; i <= n; ++i){
		while(top > 1 && cross(a[stk[top - 1]], a[stk[top]], a[i]) <= 0)
		  --top;
		stk[++top] = i;
	}
	int lst = top;
	for(int i = n - 1; i >= 1; --i){
		while(top > lst && cross(a[stk[top - 1]], a[stk[top]], a[i]) <= 0)
		  --top;
		stk[++top] = i;		
	}
	return top - 1;
}
bool End;
signed main(){
	n = read();
	for(int i = 1; i <= n; ++i)
	  A[i].Read();
	int len = Andrew(A, n);
	if(len == 2 || n < 4){
		puts("0");
		return 0;
	}
	if(len == 3){
		db now = 0, all = 1e18;
		now = fabs(cross(A[stk[1]], A[stk[2]], A[stk[3]]));
		for(int i = 1; i <= n; ++i){
			if(i == stk[1] || i == stk[2] || i == stk[3])
			  continue;
			all = min({all, fabs(cross(A[i], A[stk[1]], A[stk[2]])), fabs(cross(A[i], A[stk[2]], A[stk[3]])), fabs(cross(A[i], A[stk[3]], A[stk[1]]))});
		}
		printf("%.3lf\n", (now - all) / 2.0);
		return 0;
	}
	int j = 2, a = 1, b = 2;
	for(int i = 1; i <= len; ++i){
		while(cross(A[stk[i % len + 1]] - A[stk[i]], A[stk[j % len + 1]] - A[stk[j]]) < 0)
		  j = j % len + 1;
//		cerr << j << ' ' << cross(A[stk[i % len + 1]] - A[stk[i]], A[stk[j % len + 1]] - A[stk[j]]) << '\n';
		while(cross(A[stk[j]], A[stk[i]], A[stk[a]]) < cross(A[stk[j]], A[stk[i]], A[stk[a + 1]]))
		  a = a % len + 1;
		while(cross(A[stk[i]], A[stk[j]], A[stk[b]]) < cross(A[stk[i]], A[stk[j]], A[stk[b + 1]]))
		  b = b % len + 1;
		ans = max(ans, cross(A[stk[j]], A[stk[i]], A[stk[a]]) + cross(A[stk[i]], A[stk[j]], A[stk[b]]));
	}
	printf("%.3lf\n", ans / 2.0);
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：ycyaw (赞：2)

这里补充一下三分的做法。

首先$n^2$枚举对角线，然后我们要算的是在对角线左边最大的三角形和对角线右边最大的三角形。

显然如果我们任选一侧，从对角线的一个顶点到另一个顶点依次计算，三角形的面积肯定是先增大后减小的，所以考虑三分。

显然我们三分凸包上点的下标，然而我们会遇到一个问题：比如我们的顶点标号是$0-6$，当前我们枚举到对角线$1-4$，然后我们在对角线左边三分的话，我们发现这些点的下标变成了$5,6,0$，三分起来很麻烦。

这里我用的小技巧，就是把点再复制一份，即总共有$cnt$个点，我们分成$0- (cnt-1)$，$cnt-(2\times cnt-1)$相同的两份，枚举对角线时，我们在第二份中枚举，比如枚举到$(i,j)$，那么三分时，左右区间分别是$(j-cnt+1,i-1)$，$(i+1,j-1)$，实现起来就比较方便。

注意三分时，因为我们三分参数是下标，所以当$r-l=2$时特判一下，否则会死循环。

总复杂度$O(n^2 log\ n)$

```cpp
#include<bits/stdc++.h>
#define ts cout<<"ok"<<endl
#define ll long long
#define hh puts("")
using namespace std;
int n,st[10005],top,cnt;
double eps=1e-8,ans;
struct point{
    double x,y;
}a[10005],t[10005];
inline int read(){
    int ret=0,ff=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') ff=-ff;ch=getchar();}
    while(isdigit(ch)){ret=(ret<<3)+(ret<<1)+(ch^48);ch=getchar();}
    return ret*ff;
}
inline bool cmp(point A,point B){
    return fabs(A.x-B.x)<eps?A.y<B.y:A.x<B.x;
}
inline double cross(point A,point B){
    return A.x*B.y-A.y*B.x;
}
point operator - (point A,point B){
    return (point){A.x-B.x,A.y-B.y};
}
signed main(){
    n=read();
    for(int i=1;i<=n;i++) scanf("%lf%lf",&a[i].x,&a[i].y);
    sort(a+1,a+n+1,cmp);
    top=0;
    for(int i=1;i<=n;i++){
        st[++top]=i;
        while(top>=3&&cross(a[st[top]]-a[st[top-2]],a[st[top-1]]-a[st[top-2]])>=0){
            st[top-1]=st[top];
            top--;
        }
    }
    for(int i=1;i<=top;i++) t[++cnt]=a[st[i]];
    top=0;
    for(int i=1;i<=n;i++){
        st[++top]=i;
        while(top>=3&&cross(a[st[top]]-a[st[top-2]],a[st[top-1]]-a[st[top-2]])<=0){
            st[top-1]=st[top];
            top--;
        }
    }
    for(int i=top-1;i>=2;i--) t[++cnt]=a[st[i]];
    t[0]=t[cnt];
    for(int i=cnt+1;i<2*cnt;i++) t[i]=t[i-cnt];
    for(int i=cnt;i<2*cnt;i++){
        for(int j=i+2;j<2*cnt;j++){
            int l,r,lmid,rmid,left,right;
            l=i+1,r=j-1;
            point D=t[j]-t[i];
            while(r-l>1){
                if(r-l==2){
                    if(cross(t[l]-t[i],D)>cross(t[r]-t[i],D)) r--;
                    else l++;
                    break;
                }
                lmid=l+(r-l)/3;
                rmid=r-(r-l)/3;
                if(cross(t[lmid]-t[i],D)>cross(t[rmid]-t[i],D)) r=rmid;
                else l=lmid;
            }
            if(r-l==1){
                if(cross(t[r]-t[i],D)>cross(t[l]-t[i],D)) right=r;
                else right=l;
            }
            else right=l;
            r=i-1,l=j-cnt+1;
            while(r-l>1){
                if(r-l==2){
                    if(cross(D,t[l]-t[i])>cross(D,t[r]-t[i])) r--;
                    else l++;
                    break;
                }
                lmid=l+(r-l)/3;
                rmid=r-(r-l)/3;
                if(cross(D,t[lmid]-t[i])>cross(D,t[rmid]-t[i])) r=rmid;
                else l=lmid;
            }
            if(r-l==1){
                if(cross(D,t[r]-t[i])>cross(D,t[l]-t[i])) left=r;
                else left=l;
            }
            else left=l;
            ans=max(ans,(cross(t[right]-t[i],D)+cross(D,t[left]-t[i]))/2.);
        }
    }
    printf("%.3lf",ans);
    return 0;
}
```


---

## 作者：封禁用户 (赞：2)

这是一道平面凸包问题的一道很好的例题。

我们先求凸包，然后我们枚举点 $i$，然后对于点 $j$ 得到的 $i$ 与 $j$ （有序）中点的点，以及 $j$ 与 $i$ （有序）中点的点，都是单调的，所以我们就能求出最后的结果。

## AC代码
```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstdio>
using namespace std;
typedef long long LL;
const int MAXN = 1e5 + 10;
const int INF = 0x3f;
const double eps = 1e-10;
struct point{
	double x, y;
	point operator -(point &s){
		return (point){x-s.x,y-s.y};
	}
}p[MAXN],sta[MAXN];
int top;
double operator *(point a,point b){
	return a.x * b.y - a.y * b.x;
} 
double dist2(point P1,point P2){
	return (P1.x - P2.x) * (P1.x - P2.x) + (P1.y - P2.y) * (P1.x - P2.y);
}
bool left(point p0, point p1,point p2){
	double s = (p1 - p0) * (p2 - p0);
	return (s < 0) || (s == 0 && dist2(p1,p0) >= dist2(p2,p0));
}
int n;
bool cmp(const point &a,const point &b){
	return a.y < b.y || (a.y == b.y && a.x < b.x);
}
int graham(){
	sort(&p[1],&p[n + 1],cmp);
	sta[1] = p[1];
	sta[2] = p[2];
	top = 2;
	for(int i = 3;i <= n; i++){
		while(top > 1 && left(sta[top - 1], p[i], sta[top]))top--;
		sta[++top] = p[i];
	}
	for(int i = n - 1;i >= 1; i--){
		while(top > 1 && left(sta[top - 1], p[i], sta[top]))top--;
		sta[++top] = p[i];
	}
	top--;
	return top;
}
double solve(){
	if(n < 2)return 0;
	double ans = 0;
	sta[n + 1] = sta[1];
	for(int i = 1;i <= n + 1;i ++)p[i] = sta[i];
	for(int i = 1;i <= n;i ++){
		int a = i;
		int b = i + 1;
		for(int j = i;j <= n; j++){
			while((p[j] - p[i]) * (p[a + 1] - p[i]) - (p[j] - p[i]) * (p[a] - p[i]) > 0)a = (a == n ? 1 : a+1);
			while((p[b + 1] - p[i]) * (p[j] - p[i]) - (p[b] - p[i]) * (p[j] - p[i]) > 0)b = (b == n ? 1 : b+1);
			ans = max(ans, (p[j] - p[i]) * (p[a] - p[i]) + (p[b] - p[i]) * (p[j] - p[i]));
		}
	}
	return ans / 2;
}
int main()
{
	cin >> n;
	for(int i = 1;i <= n; i++){
		cin >> p[i].x >> p[i].y;
	}
	n = graham();
	printf("%.3lf", solve());
    return 0;
}

```

---

## 作者：MloVtry (赞：2)

n=2000，考虑一下不求图包的n^2log算法。

给一条直线的话就可以O（n）的搞出答案了。

直感一下，这个条直线应该是两个点距离最大的；就算不是，好像越长越好。

我不会证明hhhhh。

那么可以取距离i号点前m长的几个点出来，每次就认为矩形中包含这条直线。

复杂度O(m*n^2)。

代码
```cpp
// 需要-O2
#include<algorithm>
#include<iostream>
#include<cstdio>
#include<cmath>

using namespace std;

const double res=1e-9;

int sign(double x)
{
    if(fabs(x)<=res) return 0;
    return x>0?1:-1;
}

struct node
{
    double x,y;
    
    double operator ^ (const node &rhs) const
    {
        return x*rhs.y-y*rhs.x;
    }
    double operator * (const node &rhs) const
    {
        return x*rhs.x+y*rhs.y;
    }
    node operator - (const node &rhs) const
    {
        return (node){x-rhs.x,y-rhs.y};
    }
}p[2010];


double dis(node a,node b)
{
    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}

double get_s(node a,node b,node c)
{
    return ((a^b)+(b^c)+(c^a))/2;
}


int vis[2010][2010],a[2010][15],n,m;

double ans;

struct wtf
{
    double dis;
    int id;
}d[2010];

bool comp(wtf aa,wtf bb)
{
    return aa.dis>bb.dis;
}

void pre(int id)
{
    for(int i=1;i<=n;++i) d[i]=(wtf){dis(p[id],p[i]),i};
    sort(d+1,d+n+1,comp);
    
    int js=0;
    vis[id][id]=1;
    for(int i=1;i<=n;++i)
    {
        if(!vis[id][d[i].id])
        {
            vis[id][d[i].id]=vis[d[i].id][id]=1;
            a[id][++js]=d[i].id;
            if(js==m) break;
        }
    }
}

double C(node A,node B,node C)
{
    return (A-C)^(B-C);
}

int main()
{
//	freopen("area.in","r",stdin);
//	freopen("area.out","w",stdout);
    
    scanf("%d",&n);m=min(n,10);
    for(int i=1;i<=n;++i) scanf("%lf%lf",&p[i].x,&p[i].y);
    
    for(int i=1;i<=n;++i) pre(i);
    
    for(int i=1;i<=n;++i)
    {
        for(int zz=1;zz<=m;++zz)
        {
            int j=a[i][zz];
            if(!j) break;
            //cout<<i<<"---"<<j<<endl;
            
            //a line i---j
            double bb=0,bs=1e9,sb=0,ss=1e9;
            
            for(int k=1;k<=n;++k)
            {
                if(k==i||k==j) continue;
                int it=sign(C(p[i],p[j],p[k]));
//				cout<<i<<" "<<j<<" "<<k<<"  :"<<it<<endl;
                double pp=fabs(get_s(p[i],p[j],p[k]));
                
                if(it==0) bs=ss=0;
                else if(it==1)
                {
                    //do it in b
                    bb=max(bb,pp);
                    bs=min(bs,pp);
                }
                else
                {
                    //do it in s
                    sb=max(sb,pp);
                    ss=min(ss,pp);
                }
            }
            
            if(bb==0) ans=max(ans,sb-ss);
            else if(sb==0) ans=max(ans,bb-bs);
            else ans=max(ans,bb+sb);
        }
    }
    printf("%.3lf\n",ans);
    return 0;
}
```

卡卡常发现好像m取1也是对的，至于是这个数据的问题还是有什么我不会证明的性质就不得而知了。

代码

```cpp
//不需要 -O2
#define big(a,b) (a)>(b)?(a):(b)
#define sml(a,b) (a)<(b)?(a):(b)
#include<algorithm>
#include<iostream>
#include<cstdio>
#include<cmath>

using namespace std;

const double res=1e-9;

int sign(double x)
{
	if(fabs(x)<=res) return 0;
	return x>0?1:-1;
}

struct node
{
	double x,y;
	
	double operator ^ (const node &rhs) const
	{
		return x*rhs.y-y*rhs.x;
	}
	double operator * (const node &rhs) const
	{
		return x*rhs.x+y*rhs.y;
	}
	node operator - (const node &rhs) const
	{
		return (node){x-rhs.x,y-rhs.y};
	}
}p[2010];


double dis(node a,node b)
{
	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}

double get_s(node a,node b,node c)
{
	return ((a^b)+(b^c)+(c^a))/2;
}


int vis[2010][2010],a[2010],n,m;

double ans;

double d[2010];

void pre(int id)
{
	for(int i=1;i<=n;++i)
	{
		d[i]=dis(p[id],p[i]);
		if(d[a[id]]<d[i]) a[id]=i;
	}
}

double C(node A,node B,node C)
{
	return (A-C)^(B-C);
}

int main()
{
	freopen("area.in","r",stdin);
	freopen("area.out","w",stdout);
	
	
	
	scanf("%d",&n);m=min(n,1);
	for(int i=1;i<=n;++i) scanf("%lf%lf",&p[i].x,&p[i].y);
	
	for(int i=1;i<=n;++i) pre(i);
	
	for(int i=1;i<=n;++i)
	{
			int j=a[i];

			double bb=0,bs=1e9,sb=0,ss=1e9;
			
			for(int k=1;k<=n;++k)
			{
				if(k==i||k==j) continue;
				int it=sign(C(p[i],p[j],p[k]));
				double pp=fabs(get_s(p[i],p[j],p[k]));
				
				if(it==0) bs=ss=0;
				else if(it==1)
				{
					bb=big(bb,pp);
					bs=sml(bs,pp);
				}
				else
				{
					sb=big(sb,pp);
					ss=sml(ss,pp);
				}
			}
			
			if(bb==0) ans=big(ans,sb-ss);
			else if(sb==0) ans=big(ans,bb-bs);
			else ans=big(ans,bb+sb);
	}
	printf("%.3lf\n",ans);
	return 0;
}
```

---

## 作者：cwfxlh (赞：1)

# P4166
发篇题解庆祝一下蒟蒻成为最优解。
____
先把凸包模板敲上去。  
接下来，这题我们可以运用 OIer 的敏锐直觉，推测面积最大的四边形的对角线一定是多边形的对角线。其他题解里也说了这一点。  
那么这一题就变成了旋转卡壳。每次固定一个点，顺时针旋转上端点来确定对角线，让对角线取最大。再顺时针旋转左端点，使对角线左侧的三角形面积最大。最后顺时针旋转右端点，使对角线右侧的三角形面积最大。面积为两个三角形之和，每次取 max 即可。  
代码过于丑陋，不发了。

---

## 作者：FutaRimeWoawaSete (赞：0)

先假设凸包的点数大于等于 $4$，问题比较一般化。              

计算一个四边形的面积，我们可以考虑用一条对角线将四边形隔成两个三角形，分别计算两个三角形的面积。              

所以我们可以考虑 $O(n ^ 2)$ 枚举对角线。               

现在想办法计算另外两个能将三角形面积取到最大的极值点，我们不妨继续利用类似求凸包最远点对的方法，由于面积的函数呈单峰函数，所以我们直接往后面用双指针扫就可以做这种情况了。               

接着考虑当凸包的点数等于 $3$ 时，我们是一个三角形包点，由于我们必选凸包上的点所以只剩下一个点的选择。                    

枚举剩下要选的点，得到所有可形成的凹四边形，需要取到所有凹四边形面积最大的凹四边形。

对于任意一个凹四边形可以分成三个含选择点的三角形，接下来只要看哪个三角形上，选择点是在三角形边上的右侧就知道哪个三角形不合法了，刨掉它即可算出当前凹四边形的面积。                   

```cpp
/*
找到每三点构成的最大三角形然后直接枚举？
*/
#include "bits/stdc++.h"
using namespace std;
const int Len = 2e3 + 5;
const double eps = 1e-3;
struct point
{
	double x,y;
	point(){x = y = 0.0;}
	point(double X,double Y){x = X , y = Y;}
	bool operator == (const point &Ano) const
	{
		return x == Ano.x && y == Ano.y;
	}
	point operator - (const point &Ano) const
	{return point(x - Ano.x , y - Ano.y);} 
	double operator ^ (const point &Ano) const
	{return x * Ano.y - y * Ano.x;}
	double operator * (const point &Ano) const
	{return x * Ano.x + y * Ano.y;}
}p[Len] , stk[Len << 1];
int top,n;
int idf(double x){if(fabs(x) < eps) return 0;if(x > 0) return 1;return -1; }
double mul(point p0,point p1,point p2){return (p1 - p0) ^ (p2 - p0);}
double dis(point a,point b){return ((b - a) * (b - a));}
bool cmp(point x,point y)
{
	double tmp = mul(p[1] , x , y);
	if(idf(tmp) > 0) return 1;
	if(idf(tmp) == 0 && dis(p[1] , x) < dis(p[1] , y)) return 1;
	return 0;
}
void Init()
{
	scanf("%d",&n);
	for(int i = 1 ; i <= n ; i ++)
	{
		scanf("%lf %lf",&p[i].x,&p[i].y);
		if((p[i].y < p[1].y) || (p[i].y == p[1].y && p[i].x < p[1].x)) swap(p[i] , p[1]);
	}
}
void Find_Hull()
{
	sort(p + 2 , p + 1 + n , cmp);
	stk[top = 1] = p[1]; 
	for(int i = 2 ; i <= n ; i ++)
	{
		if(p[i - 1].x == p[i].x && p[i - 1].y == p[i].y) continue;
		while(top > 1 && idf(mul(stk[top - 1] , stk[top] , p[i])) <= 0) top --;
		stk[++ top] = p[i];
	}
	stk[top + 1] = p[1];
}
inline int Nxt(int x)
{
	if(x + 1 > top) return x + 1 - top;
	return x + 1;
}
int aside(point a,point b,point c)
{
	double mul = (b - a) ^ (c - a);
	if(mul > 0) return 1;
	if(mul < 0) return 0;
	double minx = min(a.x , b.x) , maxx = max(a.x , b.x) , miny = min(a.y , b.y) , maxy = max(a.y , b.y);
	return (minx <= c.x) && (c.x <= maxx) && (miny <= c.y) && (c.y <= maxy);
}
double Max_S()
{
	//if(top == 2) return dis(stk[1] , stk[2]);
	double ans = 0.0;
	if(top == 2) return ans;
	if(top == 3)
	{
		for(int i = 1 ; i <= n ; i ++)
		{
			if(p[i] == stk[1] || p[i] == stk[2] || p[i] == stk[3]) continue;
			double nowS = 0.0;
			nowS += fabs(mul(stk[1] , stk[2] , p[i]));
			nowS += fabs(mul(stk[1] , stk[3] , p[i]));
			nowS += fabs(mul(stk[2] , stk[3] , p[i]));
			if(!aside(p[i] , stk[1] , stk[2])) nowS -= fabs(mul(stk[1] , stk[2] , p[i]));
			if(!aside(p[i] , stk[1] , stk[3])) nowS -= fabs(mul(stk[1] , stk[3] , p[i]));
			if(!aside(p[i] , stk[2] , stk[3])) nowS -= fabs(mul(stk[2] , stk[3] , p[i]));
			ans = max(ans , nowS);
		}
	}
	else
	{
		for(int i = 1 ; i <= top ; i ++) 
		{
			int a = i , b = Nxt(a);
			for(int j = b ; j != i ; j = Nxt(j))
			{
				while(j != a && fabs(mul(stk[i] , stk[j] , stk[a])) < fabs(mul(stk[i] , stk[j] , stk[a + 1]))) a = Nxt(a);
				while(i != b && fabs(mul(stk[i] , stk[j] , stk[b])) < fabs(mul(stk[i] , stk[j] , stk[b + 1]))) b = Nxt(b);
				ans = max(ans , fabs(mul(stk[i] , stk[j] , stk[a])) + fabs(mul(stk[i] , stk[j] , stk[b]))); 
			}
		}	
	}
	
	return ans;
}
int main()
{
	Init();
	Find_Hull();
	printf("%.3f\n",Max_S() / 2.0); 
	return 0;
}
```

---

## 作者：Violet___Evergarden (赞：0)

[更好地阅读？](https://www.luogu.com.cn/blog/chairmanZhangjvruo/solution-p4166)
# P4166题解
题目有两个要求。

1. 选择 $4$ 个点把一些点围起来。
1. 围起来的多边形面积最大。

要满足第一个要求首先凸包糊上去。
```cpp
sta[++cnt]=1;
for(int i=2;i<=n;i++)
{
  while(cnt>=2&&CJ(p[sta[cnt-1]],p[sta[cnt]],p[i])<=0)cnt--;
  sta[++cnt]=i;
}
```
接下来求面积最大。

设凸包点的个数为 $x$。

若$ x \leq 2$，所有点在一条直线上，故面积为 $0$。
```cpp
if(cnt<=2)
{
  cout<<0;
  return 0;
}
```


------------


**若 $x=3$，那么我们需要枚举第四个点**，然后把最大面积（凸包上 $3$ 个点的三角形面积减去枚举的这个点与三个点中任意两个点构成三角形的最小面积）算出来就完了。
```
double Special()
{
  double tri=Tris(p[sta[1]],p[sta[2]],p[sta[3]]),mina=1e18;
  for(int i=1;i<=n;i++)
  {
    if(i==sta[1]||i==sta[2]||i==sta[3])continue;
    double S=min(min(Tris(p[i],p[sta[1]],p[sta[2]]),Tris(p[i],p[sta[1]],p[sta[3]])),Tris(p[i],p[sta[2]],p[sta[3]]));
    mina=min(mina,S);
  }
  if(mina==1e18)return 0;
  return tri-mina;
}
if(cnt==3)
{
  cout<<fixed<<setprecision(3)<<Special();
  return 0;
}


```

------------


**若 $ x \ge 4 $，逆时针枚举对角线**，然后根据旋转卡壳那一套理论可以发现离这一条边上下或最有最远的两个点也逆时针转动，于是可以通过海伦公式求三角形面积或者向量叉积通过 $O(n^2)$ 求出（一条对角线要枚举两个点嘛）。
```cpp
double ans=0;
for(int i=1;i<=cnt;i++)
{
  a=i%cnt+1,b=(i+2)%cnt+1;
  for(int j=i+2;j<=cnt;j++)
  {
    while(a%cnt+1!=j&&Tris(p[sta[i]],p[sta[j]],p[sta[a]])<Tris(p[sta[i]],p[sta[j]],p[sta[a+1]]))a=a%cnt+1;
    while(b%cnt+1!=i&&Tris(p[sta[i]],p[sta[j]],p[sta[b]])<Tris(p[sta[i]],p[sta[j]],p[sta[b+1]]))b=b%cnt+1;
    ans=max(ans,Tris(p[sta[i]],p[sta[j]],p[sta[a]])+Tris(p[sta[i]],p[sta[j]],p[sta[b]]));
  }
}
```


------------

## AC CODE
```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
#include <iomanip>
using namespace std;
const int kMaxN=2001;
struct POINT
{
  double x,y;
}p[kMaxN];
int n;
int sta[kMaxN],cnt;
double CJ(POINT a,POINT b,POINT c)
{
  return (b.x-a.x)*(c.y-a.y)-(c.x-a.x)*(b.y-a.y);
}
double Dis(POINT i,POINT j)
{
  return sqrt((i.x-j.x)*(i.x-j.x)+(i.y-j.y)*(i.y-j.y));
}
bool cmp(POINT i,POINT j)
{
  double cj=CJ(p[1],i,j);
  if(cj>0)return true;
  if(cj==0&&Dis(p[1],i)<Dis(p[1],j))return true;
  return false;
}
double Tris(POINT a,POINT b,POINT c)
{
  double i=Dis(a,b),j=Dis(a,c),k=Dis(b,c);
  double p=(i+j+k)/2.0;
  return sqrt(p*(p-i)*(p-j)*(p-k));
}
double Special()
{
  double tri=Tris(p[sta[1]],p[sta[2]],p[sta[3]]),mina=1e18;
  for(int i=1;i<=n;i++)
  {
    if(i==sta[1]||i==sta[2]||i==sta[3])continue;
    double S=min(min(Tris(p[i],p[sta[1]],p[sta[2]]),Tris(p[i],p[sta[1]],p[sta[3]])),Tris(p[i],p[sta[2]],p[sta[3]]));
    mina=min(mina,S);
  }
  if(mina==1e18)return 0;
  return tri-mina;
}
signed main()
{
cin>>n;
cin>>p[1].x>>p[1].y;
for(int i=2;i<=n;i++)
{
  cin>>p[i].x>>p[i].y;
  if(p[i].y<p[1].y)swap(p[i],p[1]);
  else if(p[i].y==p[1].y&&p[i].x<p[1].x)swap(p[i],p[1]);
}
sort(p+2,p+n+1,cmp);
sta[++cnt]=1;
for(int i=2;i<=n;i++)
{
  while(cnt>=2&&CJ(p[sta[cnt-1]],p[sta[cnt]],p[i])<=0)cnt--;
  sta[++cnt]=i;
}
if(cnt<=2)
{
  cout<<0;
  return 0;
}
if(cnt==3)
{
  cout<<fixed<<setprecision(3)<<Special();
  return 0;
}
sta[++cnt]=1;
int a,b;
double ans=0;
for(int i=1;i<=cnt;i++)
{
  a=i%cnt+1,b=(i+2)%cnt+1;
  for(int j=i+2;j<=cnt;j++)
  {
    while(a%cnt+1!=j&&Tris(p[sta[i]],p[sta[j]],p[sta[a]])<Tris(p[sta[i]],p[sta[j]],p[sta[a+1]]))a=a%cnt+1;
    while(b%cnt+1!=i&&Tris(p[sta[i]],p[sta[j]],p[sta[b]])<Tris(p[sta[i]],p[sta[j]],p[sta[b+1]]))b=b%cnt+1;
    ans=max(ans,Tris(p[sta[i]],p[sta[j]],p[sta[a]])+Tris(p[sta[i]],p[sta[j]],p[sta[b]]));
  }
}
cout<<fixed<<setprecision(3)<<ans;
return 0;
}
```


---


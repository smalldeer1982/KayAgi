# [清华集训 2014] 文学

## 题目描述

巨酱和主席是一对好朋友。他们都很喜欢读书，经常一起阅读相关领域书籍，进行系统的学习。一天主席列出了一份列表，里面共 $p$ 本书，其中不乏《约翰克里斯多夫》，《名人传》等名著。作为一名在文学上有很高修养的知名青年，巨酱打算用尽量少的时间把这份列表中的所有书籍都读完。

作为一名文化人，巨酱阅读书籍的方式也与一般人不同。他使用一种叫做“批量阅读”的阅读方式。首先他根据自己的喜好，对每本书给出了个参数 $x,y$，其中 $i$ 本书的两个参数为 $x_i,y_i$。当然，由于巨酱独特的口味，可能有两本不同的书，它们的 $x,y$ 参数均相同。而每次阅读的时候，他会设置三个系数 $a, b, c$，所有满足 $a \times x+b \times y \leq c$ 的书籍都可以通过这次“批量阅读”读完，这次批量阅读总共需要 $w$ 的时间。
现在，巨酱有 $n$ 种 “批量阅读”的方案，第 $i$ 种“批量阅读”三个参数为 $a_i,b_i,c_i$，需要的时间为 $w_i$。现在巨酱打算从这 $n$ 种“批量阅读”中选出若干，使得巨酱可以用尽量少的时间读完所有的书。现在我们想知道，巨酱最少用多少时间？

## 说明/提示

对于 $100\%$ 的测试数据，$1 \leq n,p \leq 100，−10^6 \leq a_i,b_i,c_i,x_i,y_i \leq 10^6， 0 \lt w_i \leq 10^6$，且保证对于任何一种“批量阅读”方案，其 $a_i$ 与 $b_i$ 不会同时为 $0$。且不存在 $i, j$（$i$ 不等于 $j$）使得 $a_i \times b_j=a_j \times b_i$。

## 样例 #1

### 输入

```
4 3
-1 0 0 10
-1 -1 -1 2
-1 1 -1 2
-1 -2 -1 1
0 2
0 -2
1 0```

### 输出

```
3```

# 题解

## 作者：Larryyu (赞：7)

## _Description_

给定 $n$ 个半平面 $a_i x+b_i y\le c_i$ 和 $p$ 个关键点 $(x_i,y_i)$，第 $i$ 个半平面有价格 $w_i$，你需要选择一些半平面覆盖所有的关键点，同时使总价格最小。

求最小的总价格。

## _Solution_

此解法为 $O(n^4)$ 正解，并非随机化算法，同时码量小，最优解前三。

同时不需要对半平面做任何操作，也不需要对关键点做分类，或作出一个新的坐标系。

在纸上画一些半平面后容易发现，半平面未覆盖的区域为一个凸包或凸壳，由于凸包和凸壳没有本质区别，为方便表述，下文以凸包为例。

同时我们还发现，最优情况下所有半平面都限制凸包，如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/bmhyzvcq.png)

因为一个半平面若不限制凸包可以直接不选，减少花费。

用一条平行于 $y$ 轴的线从左到右去扫描凸包，发现不论横坐标为何值都只有两个半平面在限制凸包。

对于关键点而言，只要此时限制凸包的两个半平面能覆盖它就是合法的，否则要再添加一个半平面来覆盖它。

容易想到用动态规划来进行此操作。

设 $dp_{i,j,k}$ 表示当前扫描线已移动到第 $i$ 个关键点（关键点已按横坐标排好序），上下限制凸包的半平面标号为 $j,k$（钦定 $j<k$），此时的最小花费。

初始化将 $dp$ 全设为 $\inf$。

边界为 $dp_{0,j,k}=w_j+w_k(0\le j<k\le n)$。

设 $check(i,j)$ 表示第 $i$ 个点是否被第 $j$ 个半平面覆盖。

依照上文操作得出转移方程：

$\begin{cases}dp_{i,j,k}=\min(dp_{i,j,k},dp_{i-1,j,k})&check(i,j)\lor check(i,k)=true\\dp_{i,j,l}=\min(dp_{i,j,l},dp_{i-1,j,k}+w_l)&check(i,l)=true\\dp_{i,k,l}=\min(dp_{i,k,l},dp_{i-1,j,k}+w_l)&check(i,l)=true\end{cases}$

那么答案就为 $\min\limits_{0\le j<k\le n}dp_{p,j,k}$。

为什么此方程不会选择同一个半平面多次呢？

因为若 $l$ 在 $j,k$ 前已选择且为最优方案，那么在后来的任意横坐标下，$j,k$ 覆盖的范围严格优于 $l$，取最小值时会被除去，因此不会被重复计算。

记得没有满足条件的选择方案时，输出 ```-1```。
## _Code_

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,p;
int a[110],b[110],c[110],w[110];
int dp[110][110][110];
struct node{
	int x,y;
}t[110];
bool cmp(node x,node y){
	return x.x<y.x;
}
bool check(int x,int y){
	if(a[y]*t[x].x+b[y]*t[x].y<=c[y]) return 1;
	return 0;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n>>p;
	a[0]=b[0]=0,c[0]=-1e9,w[0]=0;
	for(int i=1;i<=n;i++){
		cin>>a[i]>>b[i]>>c[i]>>w[i];
	}
	for(int i=1;i<=p;i++){
		cin>>t[i].x>>t[i].y;
	}
	sort(t+1,t+1+p,cmp);
	for(int i=0;i<=p;i++){
		for(int j=0;j<n;j++){
			for(int k=j+1;k<=n;k++){
				dp[i][j][k]=1e9;
			}
		}
	}
	for(int i=0;i<n;i++){
		for(int j=i+1;j<=n;j++){
			dp[0][i][j]=w[i]+w[j];
		}
	}
	for(int i=1;i<=p;i++){
		for(int j=0;j<n;j++){
			for(int k=j+1;k<=n;k++){
				if(dp[i-1][j][k]==1e9) continue;
				if(check(i,j)||check(i,k)){
					dp[i][j][k]=min(dp[i][j][k],dp[i-1][j][k]);
					continue;
				}
				for(int l=1;l<=n;l++){
					if(l==j||l==k||!check(i,l)) continue;
					dp[i][min(l,j)][max(l,j)]=min(dp[i][min(l,j)][max(l,j)],dp[i-1][j][k]+w[l]);
					dp[i][min(l,k)][max(l,k)]=min(dp[i][min(l,k)][max(l,k)],dp[i-1][j][k]+w[l]);
				}
			}
		}
	}
	int ans=1e9;
	for(int i=0;i<n;i++){
		for(int j=i+1;j<=n;j++){
			ans=min(ans,dp[p][i][j]);	
		}
	}
	cout<<(ans==1e9?-1:ans);
	return 0;
}
```

---

## 作者：Muse_Dash (赞：4)

退火好题。

考虑预处理出使用每个方案能读完哪些书，这样对每个方案都可以转化为等价的 $01$ 串和一个代价 $w$。问题转化为选择一些方案，使得对应 $01$ 串的 $\operatorname{or}$ 和 $s$ 对应的每个存在的二进制位均为 $1$，同时使得 $\sum w$ 最小。预处理这里一种巧妙简单的实现方法是 `bitset`。

定义估价函数 $h(x)$ 为这个 $\sum w$，如果不合法则默认返回 $\inf$，这样估价函数可以做到 $\Theta(n)$ 级别。然后跑退火就完事了。无解的情况是非常好判的，相信大家都会。

第 $9$ 个点比较卡，可能要多交几发，也可能是我写的比较劣。

[代码](https://www.luogu.com.cn/paste/q6gblba8)。

---

## 作者：ZhongYuLin (赞：4)

考虑将每个半平面的“批量阅读”集合求出，将问题转化为：选出若干个集合，使得它们的并为全集。这是经典的 NP 问题，而随机化的效果也不尽人意。

但是，这是在二维平面上，题目具有了更优良的性质。例如二维平面最大团[P6900](https://www.luogu.com.cn/problem/P6900)，利用网络流可以做到 $O(n^{4.5})$。同时，随机化也根本卡不掉。

类似的，在本题也可以使用随机化。

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
using i128=__int128_t;
const int N=1e2+3,INF=0x3f3f3f3f;
const i128 I=1;
template<class T1,class T2>void ckmn(T1 &x,T2 y){if(x>y)x=y;}
struct Sub{
    ll a,b,c;
    bool ck(int x,int y){
        return a*x+b*y<=c;
    }
}a[N];
int n,m,ans=INF;
i128 s[N];
i128 all;
int id[N],cst[N];
mt19937_64 rg(random_device{}());
double rd(){return 1.0*rg()/-1llu;}
int calc(){
    int res=0;i128 now=0;
    for(int i=1;i<=n;++i){
        int x=id[i];
        if((s[x]&now)==s[x])continue;
        res+=cst[x];
        now|=s[x];
        if(now==all)break;
    }
    ckmn(ans,res);
    return res;
}
void SA(){
    const double S=3e3,T=1e-3,LOW=0.9999;
    shuffle(id+1,id+1+n,rg);
    int res=calc();
    for(double i=S;i>=T;i*=LOW){
        int x=rg()%n+1,y=rg()%n+1;
        while(x==y)x=rg()%n+1,y=rg()%n+1;
        int old=res;
        swap(id[x],id[y]);
        res=calc();
        if(res>old&&exp((old-res)/i)<rd())
            swap(id[x],id[y]),res=old;
    }
}
int main(){
    int u,v,w,x,y,z;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;++i)
        cin>>a[i].a>>a[i].b>>a[i].c>>cst[i];
    for(int i=0;i<m;++i){
        cin>>x>>y;
        for(int j=1;j<=n;++j)
            if(a[j].ck(x,y))
                s[j]|=I<<i;
    }
    all=(I<<m)-1;
    i128 now=0;
    for(int i=1;i<=n;++i)
        now|=s[i];
    if(now!=all){puts("-1");return 0;}
    if(n==1){printf("%d\n",cst[1]);return 0;}
    iota(id+1,id+1+n,1);
    SA();SA();SA();
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Rain_chr (赞：2)

怎么都是随机化乱搞，喷喷喷，有正解不写去写随机化。

本文将介绍一种和同学讨论出来的 $O(n^4)$ 确定性做法。

判掉一个半平面覆盖所有点的情况，剩下的情况至少需要两个以上的半平面覆盖。

首先因为所有点的坐标分布在四个象限，不太好处理，所以我们尝试枚举两个半平面，计算出半平面的交点，以这个交点为原点。删去被枚举的半平面覆盖的点，剩下的点就只会在第一和第二象限了，也就是他们的极角在 $[0\degree,180\degree]$ 范围内了。

把剩下的点按极角排序，枚举没有被选中的半平面，此时半平面覆盖的点在序列中是若干区间，然后将这些覆盖的极长区间的权值和当前半平面的权值取较小值。

然后做一个区间 dp，计算包含一段区间的点需要的最小代价是多少。

最后再做一个区间覆盖问题，用所有区间覆盖完没有被覆盖的点的最小权值是多少。

不知读者看完这个做法的第一反应是什么，反正我是觉得假飞了，错完了。一个致命的问题就是，一个半平面覆盖的是若干个区间，说人话不就是集合吗，一个半平面只用付出一次代价就可以覆盖的集合，但是拆成若干个区间之后代价不就算了很多次吗？这么假的做法怎么过的题？

现在我们就来尝试说明一下这个做法的正确性。首先，如果最优方案下半平面覆盖了整个平面的话，那么这个最优方案一定由三个半平面构成，枚举其中的两个半平面，剩下的那一个半平面能覆盖到剩下的所有点，那么这种情况可以被枚举到并统计答案。

否则，如果最优方案没有覆盖整个平面，那么没有被覆盖的位置一定是形成了恰好一个凸包。在这个凸包上枚举任意相邻的两条边，其他凸包上的边恰好覆盖极角排序后一个区间的点，所以这种情况我们也能在代价不重复计算的情况下统计到。

所以这样就保证了我们区间 DP 存在正确性了。

一些由上述做法衍生但能通过题目的假做法：

1. 按斜率排序

   这样假了的原因是斜率排序原点正上方的点本来应该是连续的，但是斜率排序之后硬生生给拆成了两个区间，这样就不满足区间的极长性了，做法会出问题。

2. 原点直接设为 $(0,0)$

   假得令人无语，但是这样可以通过本题。

3. 没有特判 $b_i=0$ 的情况

   在计算半平面交点的时候会出问题，因为交点计算需要除以 $b_i$。按理来说应该会报出 RE 错误，但是也许是浮点数特性，歪打正着没出问题。

上述是正确性有误的做法，因为代码写错导致复杂度为 $O(n^5)$ 的做法还有一堆，就不列举了。

最后送上我觉得准确无误的代码：


```cpp
#include<bits/stdc++.h>
#define int long long
#define eps 1e-10
using namespace std;
const int N=110;
int n,m;
struct plane
{
    double a,b,c;
    int w;
}a[N];
struct point
{
    double x,y;
}b[N],c[N];
bool check(point x,plane y)
{
    return y.a*x.x+y.b*x.y<=y.c;
}
point O;
bool cmp(point x,point y)
{
    return atan2(x.y-O.y,x.x-O.x)<atan2(y.y-O.y,y.x-O.x);
}
int w[N][N];
int f[N];
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>a[i].a>>a[i].b>>a[i].c>>a[i].w;
    for(int i=1;i<=m;i++) cin>>b[i].x>>b[i].y;
    int ans=1e18;
    for(int i=1;i<=n;i++)
    {
        bool flag=1;
        for(int j=1;j<=m;j++) flag&=check(b[j],a[i]);
        if(flag) ans=min(ans,a[i].w);
    }
    for(int i=1;i<=n;i++)
        for(int j=i+1;j<=n;j++)
        {
            int cnt=0;
            for(int k=1;k<=m;k++) 
                if(!check(b[k],a[i])&&!check(b[k],a[j]))
                    c[++cnt]=b[k];
            if(fabs(a[i].b)<eps) O.x=a[i].c/a[i].a,O.y=a[j].c/a[j].b-a[j].a/a[j].b*O.x;
            else if(fabs(a[j].b)<eps) O.x=a[j].c/a[j].a,O.y=a[i].c/a[i].b-a[i].a/a[i].b*O.x;
            else 
            {
                double div=(a[j].a/a[j].b-a[i].a/a[i].b);
                O.x=(a[j].c/a[j].b-a[i].c/a[i].b)/div;
                O.y=a[i].c/a[i].b-a[i].a/a[i].b*O.x;
            }
            sort(c+1,c+1+cnt,cmp);
            memset(f,0x3f,sizeof(f));
            memset(w,0x3f,sizeof(w));
            for(int k=1;k<=n;k++)
            {
                if(k==i||k==j) continue;
                for(int l=1;l<=cnt;l++)
                {
                    if(!check(c[l],a[k])) continue;
                    int p=l;
                    while(p<=cnt&&check(c[p],a[k])) p++;
                    w[l][p-1]=min(w[l][p-1],a[k].w);
                    l=p;
                }
            }
            for(int len=cnt;len;len--)
                for(int l=1;l+len-1<=cnt;l++)
                {
                    int r=l+len-1;
                    w[l][r]=min(w[l][r],min(w[l-1][r],w[l][r+1]));
                }
            f[0]=0;
            for(int i=1;i<=cnt;i++)
                for(int j=0;j<i;j++)
                    f[i]=min(f[i],f[j]+w[j+1][i]);
            ans=min(ans,f[cnt]+a[i].w+a[j].w);
        }
    if(ans==1e18) cout<<-1;
    else cout<<ans;
    return 0;
}
```

---


# 雨水收集系统（2021 CoE-I E）

## 题目背景

Rain 市的环保部门为部分建筑的顶层安装了雨水收集装置，使得能够将雨水进行循环利用。雨水收集系统通过每栋建筑的顶层地面来收集雨水，利用特殊的管道将雨水集中引流到一个蓄水池中以待后续使用。环保部门计划根据降水量来估计蓄水池的容量大小以便进行设计制造。

## 题目描述

为了简化问题的处理，将每栋建筑的顶层视为一个边与坐标轴平行的矩形，使用矩形的一条对角线顶点坐标来表示该矩形。每次降雨时，降雨云沿着特定的方向以一定的速度做匀速运动，降雨云所经过的区域均会有雨水降落。将降雨云抽象为一个凸多边形，给定初始时降雨云的位置以及移动方向和速率，确定在某段时间内雨水收集系统能够接受降雨的面积大小。

## 说明/提示

#### 样例说明

![](https://cdn.luogu.com.cn/upload/image_hosting/jf0ig9zb.png)

第一组测试数据，此组测试数据一共有 $2$ 栋建筑 $\operatorname{B_1}$ 和 $\operatorname{B_2}$，降雨云 $\operatorname{C}$ 为一个正方形（正方形的左下角位于坐标点（$-10$，$8$），边长为 $5$），降雨云沿着从起点（$15$，$0$）到终点（$25$，$0$）的方向匀速移动，移动速率为 $1$ 单位距离/分钟，降雨起始时间为 $15$ 时 $30$ 分，结束时间为 $16$ 时 $05$ 分，降雨时间为 $35$ 分钟，降雨云沿着箭头所示方向移动了 $35$ 单位距离。如上图所示，能够接受降雨的面积为阴影区域的面积，易知面积为 $50.0$。

![](https://cdn.luogu.com.cn/upload/image_hosting/two4uh3q.png)
第二组测试数据，降雨云的移动方向不同，从起点（$-5$，$8$）到终点（$19$，$1$）的方向匀速移动，降雨时间为 $60$ 分钟，沿着箭头所示方向的移动距离为 $60$ 单位距离，其他条件相同，能够接受降雨的面积为上图中的阴影区域，其面积为 $60.5$。注意，第二组测试数据的示意图中，为了示意的方便，所绘制的降雨云“最终位置”并不是其实际的最终位置。

------------

#### 数据范围与约定

对于 $100\%$ 的数据，$1 \leq T \leq 10^3$，$1 \leq n \leq 50$，$3 \leq m \leq 100$，$0 \lt v \leq 100$。所有坐标值均为整数，位于闭区间 $[-10^5,10^5]$。

输入数据保证表示建筑顶层的矩形不会发生重叠。降雨的结束时间一定晚于起始时间。表示降雨云移动方向的起点 $s$ 和终点 $e$ 不同。

## 样例 #1

### 输入

```
2

2
0 0 10 10
20 20 30 10
4
-10 8 -5 8 -5 13 -10 13
15 0 25 0
1
15:30 16:05

2
0 0 10 10
20 20 30 10
4
-10 8 -5 8 -5 13 -10 13
-5 8 19 1
1
15:30 16:30```

### 输出

```
50.0
60.5```

# 题解

## 作者：metaphysis (赞：7)

[题目链接](https://www.luogu.com.cn/problem/T154242)

本题是一道典型的计算几何题目。需要解题者掌握凸包和半平面交的求解方法。

题目给定的降雨云是一个凸多边形，当将其进行平移操作后，其路径所覆盖的区域也是一个凸多边形，这个凸多边形应该如何求呢？很简单，将平移后的各个凸包顶点求出来，与原来的凸包顶点一起，再求一次凸包即可。知道了降雨云覆盖的区域，将其与建筑顶面的矩形作半平面交，求出各个交的面积，然后累加即可。

主要注意实现的细节即可。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXV = 1100;
const double EPSILON = 1E-7;

// 表示点的数据结构
struct point {
    double x, y;
    point (double x = 0, double y = 0): x(x), y(y) {}
    point operator + (point p) { return point(x + p.x, y + p.y); };
    point operator - (point p) { return point(x - p.x, y - p.y); };
    point operator * (double k) { return point(x * k, y * k); };
    point operator / (double k) { return point(x / k, y / k); };
    
    bool operator<(const point &p) const
	{
	    if (fabs(y - p.y) > EPSILON) return y < p.y;
	    return x < p.x;
	}
	
	bool operator==(const point &p) const
	{
	    return fabs(x - p.x) <= EPSILON && fabs(y - p.y) <= EPSILON;
	}
};

// 定义多边形
typedef vector<point> polygon;


// 范数
double norm(point a)
{
    return a.x * a.x + a.y * a.y;
}

// 模
double abs(point a)
{
    return sqrt(norm(a));
}

// 内积（点积）
double dot(point a, point b)
{
    return a.x * b.x + a.y * b.y;
}

// 外积（叉积）
double cross(point a, point b)
{
    return a.x * b.y - a.y * b.x;
}

// 定义直线，使用两点和极角定义直线，加入极角是用于半平面交
struct line
{
    point a, b;
    double angle;
};

// 有向面积
double cp(point a, point b, point c)
{
    return cross(b - a, c - a);
}

// 利用有向面积判断顺时针旋转
bool cw(point a, point b, point c)
{
    return cp(a, b, c) < -EPSILON;
}

// 利用有向面积判断逆时针旋转
bool ccw(point &a, point &b, point &c)
{
    return cp(a, b, c) > EPSILON;
}

// 利用有向面积判断逆时针旋转或共线
bool ccwOrCollinear(point &a, point &b, point &c)
{
    double cp1 = cp(a, b, c);
	return cp1 > EPSILON || fabs(cp1) <= EPSILON;
}

// 利用 Andrew 合并法求凸包
polygon andrewConvexHull(polygon pg)
{
	polygon ch;

    sort(pg.begin(), pg.end());
	for (int i = 0; i < pg.size(); i++)
	{
		while (ch.size() >= 2 &&
		    ccwOrCollinear(ch[ch.size() - 2], ch[ch.size() - 1], pg[i]))
			ch.pop_back();
		ch.push_back(pg[i]);
	}
	for (int i = pg.size() - 1, upper = ch.size() + 1; i >= 0; i--)
	{
		while (ch.size() >= upper &&
		    ccwOrCollinear(ch[ch.size() - 2], ch[ch.size() - 1], pg[i]))
			ch.pop_back();
		ch.push_back(pg[i]);
	}
    ch.pop_back();
    
	return ch;
}

// 按极角对直线进行排序的比较函数
bool cmpLine(line p, line q)
{
    if (fabs(p.angle - q.angle) <= EPSILON) return cw(p.a, p.b, q.a);
    return p.angle < q.angle;
}

// 按极角对直线进行去重的比较函数
bool cmpAngle(line p, line q)
{
    return fabs(p.angle - q.angle) <= EPSILON;
}

// 判定两条直线是否平行
bool parallel(line p, line q)
{
    return fabs((p.a.x - p.b.x) * (q.a.y - q.b.y) -
        (q.a.x - q.b.x) * (p.a.y - p.b.y)) <= EPSILON;
}

// 确定两条直线的交点
point getIntersection(line p, line q)
{
    point p1 = p.a;
    double scale =
        ((p.a.x - q.a.x) * (q.a.y - q.b.y) - (p.a.y - q.a.y) * (q.a.x - q.b.x)) /
        ((p.a.x - p.b.x) * (q.a.y - q.b.y) - (p.a.y - p.b.y) * (q.a.x - q.b.x));
    p1.x += (p.b.x - p.a.x) * scale;
    p1.y += (p.b.y - p.a.y) * scale;
    return p1;
}

// 根据两点确定一条直线
line pointToLine(point a, point b)
{
    line lr;
    lr.a = a, lr.b = b, lr.angle = atan2(b.y - a.y, b.x - a.x);
    return lr;
}

// 使用朱泽园介绍的“排序增量法”求半平面交
polygon halfPlaneIntersection(line *sides, int nLine)
{
    polygon pg;
    line deq[MAXV];

    sort(sides, sides + nLine, cmpLine);
    nLine = unique(sides, sides + nLine, cmpAngle) - sides; 

    int btm = 0, top = 1;
    deq[0] = sides[0], deq[1] = sides[1];

    for (int i = 2; i < nLine; i++)
    {
        if (parallel(deq[top], deq[top - 1]) || parallel(deq[btm], deq[btm + 1]))
            return pg;

        while (btm < top &&
            cw(sides[i].a, sides[i].b, getIntersection(deq[top], deq[top - 1])))
            top--;
        while (btm < top &&
            cw(sides[i].a, sides[i].b, getIntersection(deq[btm], deq[btm + 1])))
            btm++;

        deq[++top] = sides[i];
    }

    while (btm < top &&
        cw(deq[btm].a, deq[btm].b, getIntersection(deq[top], deq[top - 1])))
        top--;
    while (btm < top &&
        cw(deq[top].a, deq[top].b, getIntersection(deq[btm], deq[btm + 1])))
        btm++;

    if (top <= (btm + 1)) return pg;

    for (int i = btm; i < top; i++)
        pg.push_back(getIntersection(deq[i], deq[i + 1]));
    if (btm < (top + 1))
        pg.push_back(getIntersection(deq[btm], deq[top]));

    return pg;
}

// 计算多边形的面积
double getArea(polygon pg)
{
    if (pg.size() < 3) return 0.0;
    double A = 0.0;
    int n = pg.size();
    for (int i = 0, j = (i + 1) % n; i < n; i++, j = (i + 1) % n)
        A += (pg[i].x * pg[j].y - pg[j].x * pg[i].y);
    return fabs(A / 2.0);
}

// 根据对角顶点坐标确定矩形
polygon getRectFromPoint(int x1, int y1, int x2, int y2)
{
    polygon rect;
    int minx = min(x1, x2), maxx = max(x1, x2);
    int miny = min(y1, y2), maxy = max(y1, y2);
    rect.push_back(point(minx, miny));
    rect.push_back(point(maxx, miny));
    rect.push_back(point(maxx, maxy));
    rect.push_back(point(minx, maxy));
    return rect;
}

// 解析时间
int getTime(string text)
{
    return stoi(text.substr(0, 2)) * 60 + stoi(text.substr(3));
}

int main(int argc, char *argv[])
{
    cin.tie(0), cout.tie(0), ios::sync_with_stdio(false);

    int cases, n, m, v;
    string time1, time2;

    cin >> cases;
    for (int cs = 1; cs <= cases; cs++)
    {
        cin >> n;
        
        // 读入每栋建筑的对角点坐标，由对角点坐标确定矩形，矩形的顶点按逆时针排列。
        vector<polygon> rects;
        int x1, y1, x2, y2;
        for (int i = 0; i < n; i++)
        {
            cin >> x1 >> y1 >> x2 >> y2;
            rects.push_back(getRectFromPoint(x1, y1, x2, y2));
        }
        
        // 读入降雨云。
        polygon cloud;
        cin >> m;
        for (int i = 0; i < m; i++)
        {
            cin >> x1 >> y1;
            cloud.push_back(point(x1, y1));
        }
        
        // 降雨云沿着直线方向做平移运动，其扫过的区域构成一个凸多边形。使用凸包算法求出凸多边形的顶点，顶点按照逆时针方向排序。
        point s, e;
        cin >> s.x >> s.y >> e.x >> e.y;
        cin >> v >> time1 >> time2;
        double d = v * (getTime(time2) - getTime(time1));
        int cnt = cloud.size();
        for (int i = 0; i < cnt; i++)
        {
            point moved = cloud[i] + (e - s) * d / abs(e - s);
            cloud.push_back(moved);
        }
        cloud = andrewConvexHull(cloud);
        reverse(cloud.begin(), cloud.end());

        // 使用半平面交确定降雨云与每栋建筑的顶层的交，计算面积并求和。
        double area = 0;
        line sides[MAXV];
        for (int i = 0; i < rects.size(); i++)
        {
            int nLine = 0;
            for (int j = 0; j < cloud.size(); j++)
                sides[nLine++] = pointToLine(cloud[j], cloud[(j + 1) % cloud.size()]);
            for (int j = 0; j < rects[i].size(); j++)
                sides[nLine++] = pointToLine(rects[i][j], rects[i][(j + 1) % rects[i].size()]);
            area += getArea(halfPlaneIntersection(sides, nLine));
        }
        cout << fixed << setprecision(1) << area << '\n';
    }

    return 0;
}
```

---

## 作者：幻影星坚强 (赞：1)

做法显然的计算几何。

假如能求出云运动时所扫过的图形，因为矩形不相交，所以可以直接对于每个矩形使用面积交来求出面积之和。而云的每个点移动的方向和距离相同，所以起始所有点与最后状态所有点所形成的的凸包就是云运动时所扫过的图形。求凸包是 $O(m)$ 的，求面积交的总复杂度是 $O(nm)$ 的，所以能过。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 300;
const double eps = 1e-8;
int sig(double d) {
    return (d > eps) - (d < -eps);
}
struct Point {
    double x, y;
    Point() {}
    Point(double x, double y): x(x), y(y) {}
    bool operator==(const Point &p)const {
        return sig(x - p.x) == 0 && sig(y - p.y) == 0;
    }
};
double cross(Point o, Point a, Point b) {
    return (a.x - o.x) * (b.y - o.y) - (b.x - o.x) * (a.y - o.y);
}
double area(Point *ps, int n) {
    ps[n] = ps[0];
    double res = 0;

    for (int i = 0; i < n; i++) {
        res += ps[i].x * ps[i + 1].y - ps[i].y * ps[i + 1].x;
    }

    return res / 2.0;
}
int lineCross(Point a, Point b, Point c, Point d, Point &p) {
    double s1, s2;
    s1 = cross(a, b, c);
    s2 = cross(a, b, d);

    if (sig(s1) == 0 && sig(s2) == 0)
        return 2;

    if (sig(s2 - s1) == 0)
        return 0;

    p.x = (c.x * s2 - d.x * s1) / (s2 - s1);
    p.y = (c.y * s2 - d.y * s1) / (s2 - s1);
    return 1;
}

void polygon_cut(Point *p, int &n, Point a, Point b) {
    static Point pp[maxn];
    int m = 0;
    p[n] = p[0];

    for (int i = 0; i < n; i++) {
        if (sig(cross(a, b, p[i])) > 0)
            pp[m++] = p[i];

        if (sig(cross(a, b, p[i])) != sig(cross(a, b, p[i + 1])))
            lineCross(a, b, p[i], p[i + 1], pp[m++]);
    }

    n = 0;

    for (int i = 0; i < m; i++)
        if (!i || !(pp[i] == pp[i - 1]))
            p[n++] = pp[i];

    while (n > 1 && p[n - 1] == p[0])
        n--;
}

double intersectArea(Point a, Point b, Point c, Point d) {
    Point o(0, 0);
    int s1 = sig(cross(o, a, b));
    int s2 = sig(cross(o, c, d));

    if (s1 == 0 || s2 == 0)
        return 0.0;

    if (s1 == -1)
        swap(a, b);

    if (s2 == -1)
        swap(c, d);

    Point p[10] = {o, a, b};
    int n = 3;
    polygon_cut(p, n, o, c);
    polygon_cut(p, n, c, d);
    polygon_cut(p, n, d, o);
    double res = fabs(area(p, n));

    if (s1 * s2 == -1)
        res = -res;

    return res;
}

double intersectArea(Point *ps1, int n1, Point *ps2, int n2) {
    if (area(ps1, n1) < 0)
        reverse(ps1, ps1 + n1);

    if (area(ps2, n2) < 0)
        reverse(ps2, ps2 + n2);

    ps1[n1] = ps1[0];
    ps2[n2] = ps2[0];
    double res = 0;

    for (int i = 0; i < n1; i++) {
        for (int j = 0; j < n2; j++) {
            res += intersectArea(ps1[i], ps1[i + 1], ps2[j], ps2[j + 1]);
        }
    }

    return res;
}
Point p1[1000], p2[1000];
struct point {
    double x, y;
    int ids;
} eg[100010], stacks[100010];
bool pd(point i, point j) {
    return (i.x < j.x || (i.x == j.x && i.y < j.y));
}
double dist(point i, point j) {
    return (double)sqrt((i.x - j.x) * (i.x - j.x) + (i.y - j.y) * (i.y - j.y));
}
double comp(point j, point i, point j1, point i1) {
    return (i.y - j.y) * (i1.x - j1.x) < (i1.y - j1.y) * (i.x - j.x);
}

int sx1[100010], sy1[100010], sx2[100010], sy2[100010];
int sf[210];
int main() {
    int n1, n2;
    int t;
    scanf("%d", &t);

    while (t --) {
        int n;
        scanf("%d", &n);

        for (int i = 1; i <= n; ++ i)
            scanf("%d%d%d%d", &sx1[i], &sy1[i], &sx2[i], &sy2[i]);

        scanf("%d", &n1);

        for (int i = 0; i < n1; ++ i) {
            scanf("%lf%lf", &eg[i].x, &eg[i].y);
            eg[i].ids = i;
            sf[i] = 0;
        }

        double x1, y1, x2, y2, v, m1, m2, m3, m4;
        scanf("%lf%lf%lf%lf", &x1, &y1, &x2, &y2);
        scanf("%lf", &v);
        scanf("%lf:%lf %lf:%lf", &m1, &m2, &m3, &m4);
        double dis = (m3 * 60 + m4 - m1 * 60 - m2) * v;
        x2 -= x1;
        y2 -= y1;
        double bb = dis / dist((point) {
            0, 0
        }, (point) {
            x2, y2
        });
        x2 *= bb;
        y2 *= bb;

        for (int i = 0; i < n1; ++ i) {
            eg[i + n1].y = eg[i].y + y2;
            eg[i + n1].x = eg[i].x + x2;
            eg[i + n1].ids = i + n1;
            sf[i + n1] = 0;
        }

        n1 *= 2;
        sort(eg, eg + n1, pd);
        int num = 0;

        for (int i = 0; i < n1; ++ i) {
            if (i)
                if (eg[i].x == eg[i - 1].x)
                    continue;

            stacks[++ num] = eg[i];

            while (num >= 3 && comp(stacks[num - 2], stacks[num], stacks[num - 2], stacks[num - 1])) {
                stacks[num - 1] = stacks[num];
                -- num;
            }
        }

        int tt = 0;

        for (int i = 1; i <= num; ++ i) {
            p1[tt].x = stacks[i].x, p1[tt].y = stacks[i].y;
            ++ tt;
        }

        memset(stacks, 0, sizeof(stacks));
        num = 0;

        for (int i = n1 - 1; i >= 0; -- i) {
            if (i)
                if (eg[i].x == eg[i + 1].x)
                    continue;

            stacks[++ num] = eg[i];

            while (num >= 3 && comp(stacks[num - 2], stacks[num], stacks[num - 2], stacks[num - 1])) {
                stacks[num - 1] = stacks[num];
                -- num;
            }
        }

        for (int i = 1; i <= num; ++ i) {
            p1[tt].x = stacks[i].x, p1[tt].y = stacks[i].y;
            ++ tt;
        }

        n1 = tt;
        double ans = 0;

        for (int i = 1; i <= n; ++ i) {
            n2 = 4;
            p2[0].x = min(sx1[i], sx2[i]);
            p2[0].y = min(sy1[i], sy2[i]);
            p2[1].x = max(sx1[i], sx2[i]);
            p2[1].y = min(sy1[i], sy2[i]);
            p2[2].x = max(sx1[i], sx2[i]);
            p2[2].y = max(sy1[i], sy2[i]);
            p2[3].x = min(sx1[i], sx2[i]);
            p2[3].y = max(sy1[i], sy2[i]);
            ans += intersectArea(p1, n1, p2, n2);
        }

        printf("%lf\n", ans);
    }

    return 0;
}
```


---


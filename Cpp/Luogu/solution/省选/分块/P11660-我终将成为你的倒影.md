# 我终将成为你的倒影

## 题目背景

『 现实并不像回忆那般，充满变化的余地。』

## 题目描述

岛村是不喜欢上课的。但是今天的数学课上，一个函数 $f(x)=\lfloor \frac{x+a}{b}\rfloor$ 吸引住了她。

她现在有一个长度为 $n$ 的序列 $A$ 和 $m$ 个询问。她想知道对于每组 $l,r,a,b$，记 $B_i=f(A_i)$，$\displaystyle\sum^r_{i=l+1}[B_i=B_{i-1}]$ 的值为多少（其中若 $[]$ 里面的表达式为真，值为 $1$，否则为 $0$）。

但是她着急于去找安达打乒乓球，所以把问题交给你了。

本题强制在线，每次的 $l,r,a,b$ 均要异或上一次的答案，若这是第一次询问，则不做操作。

## 说明/提示

对于所有测试数据，保证：$1 \le n,m,A_i \le 10^5$，$1\le b\le 500$，$0 \le a\le2\times10^9$，$l<r$。

| Subtask | 限制 | 分值 |
| :----------: | :----------: | :----------: |
| $0$ | $n,m\le100$ | $10$ |
| $1$ | $n\le100$ | $20$ |
| $2$ | $b\le10$ | $20$ |
| $3$ | - | $50$ |

## 样例 #1

### 输入

```
10 10
1 3 4 3 4 7 2 9 7 10 
1 10 3 7
3 13 3 2
4 6 2 7
0 6 7 2
2 7 10 1
1 4 0 10
4 5 2 8
2 9 2 0
1 5 0 7
0 2 6 3```

### 输出

```
4
1
1
3
2
2
1
0
4
1```

# 题解

## 作者：ccxswl (赞：7)

# P11660 我终将成为你的倒影 题解

感觉评紫比较合理。

## 初步思路

$b \le 500$，这于 $\sqrt n$ 相近，启发我们思考关于根号复杂度的做法。

考虑序列分块。散块暴力，难在整块。

## 最终思路

下取整可以看做取某个数的整数部分。$f(x)$ 可以看为 $\lfloor \frac x b \rfloor + \lfloor \frac a b \rfloor + [a \bmod b + x \bmod b \ge b]$。

容易发现，假若 $f(x)=f(y)$，令 $c = \lfloor \frac x b \rfloor - \lfloor \frac y b \rfloor$，那么有必要条件 $|c| \le 1$。

令 $y_1 = x \bmod b, y_2 = y \bmod b,t = a \bmod b$。

对于 $c=0$：
- 有 $y_1+t < b \land y_2 + t < b$ 或 $y_1+t \ge b \land y_2 + t \ge b$，即 $t < \min(b-y_1,b-y_2)$ 或 $t \ge \max(b-y_1,b-y_2)$。注意到这两个限制不交叉。

对于 $c=1$：
- 有 $y_1+t<b\land y_2 + t\ge b$，即 $b-y_2\le t < b-y_1$。

对于 $c=-1$：
- 有 $y_1+t\ge b \land y_2+t<b$，即 $b-y_1\le t < b-y_2$。

发现上述限制都是区间的形式，且 $t<b$。可以考虑在值域为 $b$ 的桶上差分，再做前缀和。这样就可以支持 $O(1)$ 查询整块内的答案。

$b$ 很小，可以枚举。为对于每个块枚举所有的 $b$，对于所有块内的元素计算 $f(A_i)=f(A_{i-1})$ 的限制，预处理出上述的数组。

空间复杂度 $O(b^2 \frac n B)$，$B$ 为块长。

预处理时间复杂度 $O(bn+b^2\frac n B)$。

## 注意

1. 注意整块间的答案也要统计。
2. 空间 $O(b^2 \frac n B)$，块长 $B=\sqrt n$ 时卡空间，可以适当调大。
3. 注意限制本身是否合法，即防止出现左边大于右边。

为什么 $A_i\le 10^5$，感觉复杂度于 $A_i$ 没任何关系，可以开到 $10^9$。

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

#define IL inline
#define vec vector
#define eb emplace_back
#define bg begin
#define emp emplace
#define fi first
#define se second
#define bg begin
#define lb lower_bound
using dub = double;
using ubt = long long;
using pii = pair<int, int>;

IL void ckx(int &x, const int &y) { (x < y) && (x = y); }
IL void ckm(int &x, const int &y) { (x > y) && (x = y); }

template <typename T = int>
IL T _R() {
  T s = 0, w = 1;
  char c = getchar();
  while (!isdigit(c)) w = c == '-' ? -1 : 1, c = getchar();
  while (isdigit(c)) s = s * 10 + c - 48, c = getchar();
  return s * w;
}

const int N = 1e5;
const dub alpha = 1.3;
const int B = alpha * sqrt(N);
const int S = N / B + 1;
const int K = 500;
const int maxN = N + 3, maxK = K + 3, maxS = S + 3;

int n, m, x[maxN];

int pos[maxN], L[maxS], R[maxS];

int t[maxS][maxK][maxK];

int main() {
  n = _R(), m = _R();
  for (int i = 1; i <= n; i++) x[i] = _R();

  for (int i = 1; i <= n; i++) {
    pos[i] = (i - 1) / B + 1;
    if (!L[pos[i]]) L[pos[i]] = i;
    R[pos[i]] = i;
  }

  for (int u = 1; u <= pos[n]; u++) {
    for (int b = 1; b <= K; b++) {
      for (int i = L[u] + 1; i <= R[u]; i++) {
        int c = x[i] / b - x[i - 1] / b;
        if (abs(c) <= 1) {
          int y1 = x[i] % b, y2 = x[i - 1] % b;
          if (c == 0) {
            t[u][b][0]++, t[u][b][min(b - y1, b - y2)]--;
            t[u][b][max(b - y1, b - y2)]++;
          } else if (c == 1) {
            if (y1 >= y2) continue;
            t[u][b][b - y2]++, t[u][b][b - y1]--;
          } else {
            if (y1 <= y2) continue;
            t[u][b][b - y1]++, t[u][b][b - y2]--;
          }
        }
      }
      for (int i = 1; i <= K; i++)
        t[u][b][i] += t[u][b][i - 1];
    }
  }

  int ans = 0;
  while (m--) {
    int l = _R(), r = _R(), a = _R(), b = _R();
    l ^= ans, r ^= ans, a ^= ans, b ^= ans;
    if (l >= r) { printf("%d\n", ans = 0); continue; }
    ans = 0;
    if (pos[l] == pos[r]) {
      for (int i = l + 1; i <= r; i++)
        ans += (x[i] + a) / b == (x[i - 1] + a) / b;
    } else {
      for (int i = l + 1; i <= R[pos[l]]; i++)
        ans += (x[i] + a) / b == (x[i - 1] + a) / b;
      for (int i = L[pos[r]] + 1; i <= r; i++)
        ans += (x[i] + a) / b == (x[i - 1] + a) / b;
      for (int i = pos[l] + 1; i < pos[r]; i++)
        ans += t[i][b][a % b];
      for (int i = pos[l]; i < pos[r]; i++)
        ans += (x[R[i]] + a) / b == (x[R[i] + 1] + a) / b;
    }
    printf("%d\n", ans);
  }
}
```

---

## 作者：_Yonder_ (赞：7)

先把 $a$ 模上 $b$，然后考虑对每个 $b$ 求出 $a$ 在什么时候会出现多少个 $B_i=B_{i-1}$，这个可以考虑求不等式组，毕竟原式只涉及到两个量。

先考虑全局做法。

假设 $A_{i-1}=x,A_{i}=y,k=\frac{A_{i-1}}{b}$。这里假定 $x<y$。

原式为 $\lfloor \frac{x}{b}+\frac{a}{b} \rfloor=\lfloor \frac{y}{b}+\frac{a}{b} \rfloor$，可以注意到其中的 $\frac{a}{b}<1$，也就是说 $\lfloor \frac{x}{b}+\frac{a}{b} \rfloor$ 要么为 $k$，要么为 $k+1$，对其分类讨论。

当 $\lfloor \frac{x+a}{b} \rfloor=k$ 时，则有 $\lfloor \frac{y+a}{b} \rfloor=k$，可得 $a\in[bk-y,bk+b-y)$。

当 $\lfloor \frac{x+a}{b} \rfloor=k+1$ 时，则有 $\lfloor \frac{y+a}{b} \rfloor=k+1$，可得 $a\in[(k+1)b-x,(k+2)b-y)$。

我们在每个 $b$ 对应的数组上差分即可，同时要记得减去这两条线段的交集。

对于全局做法，我们只需要给原序列分块即可。

---

## 作者：harmis_yz (赞：4)

注意到 $b \le 500$，考虑暴力。我们去枚举所有的 $b$，由于 $f(x)=\lfloor \frac{x+a}{b}\rfloor=\lfloor \frac{a}{b}\rfloor+\lfloor \frac{x+a-\lfloor \frac{a}{b}\rfloor \times b}{b}\rfloor=\lfloor \frac{a}{b}\rfloor+\lfloor \frac{x + a\bmod b}{b}\rfloor$，其中 $\lfloor \frac{a}{b}\rfloor$ 对任意的 $x$ 都是一样的。所以这玩意没用。那么对于一个 $b$，可能得到不同答案的 $a$ 就只有 $O(b)$ 个了。

考虑 $A_i$ 和 $A_{i-1}$ 在 $b$ 一定的时候，$a$ 的取值范围，使得 $f(A_i)=f(A_{i-1})$。注意到 $\lfloor \frac{x+a}{b}\rfloor - \lfloor \frac{x}{b}\rfloor \le 1$，所以 $|f(A_i)-f(A_{i-1})|$ 在 $a=y$ 时的值相比 $a=0$ 时的值变化量不超过 $1$。也就是说，当 $a=0$ 时 $|f(A_i)-f(A_{i-1})| \ge 2$ 的 $(i,i-1)$ 是不可能产生贡献的。

令 $A_i \ge A_{i-1}$。对 $a=0$ 时 $f(A_i)$ 与 $f(A_{i-1})$ 的大小分类讨论：

1. $f(A_{i})=f(A_{i-1})$。记 $r_i=A_i \bmod b$。当 $a+r_i \ge b$ 时 $f(A_i)$ 的值会增加 $1$，$f(A_{i-1})$ 同理。那么 $i$ 和 $i-1$ 要么都不增加，要么都增加。则 $a$ 的取值范围为 $[0,b-\max(r_i,r_{i-1})) \cup [b-\min(r_i,r_{i-1}),b)$。
2. $f(A_i) =f(A_{i-1})+1$。那么当 $f(A_{i-1})$ 增加且 $f(A_i)$ 不增加时会产生贡献。则 $a$ 的取值范围为 $[b-r_{i-1},b-r_{i})$。

那么这样就能维护出 $l=1 \land r=n$ 时的所有答案了。现在考虑区间询问。很容易想到，记 $f_{a,b,i}$ 表示在 $a,b$ 已知时，$f(A_i)$ 是否等于 $f(A_{i-1})$。但是这样空间是 $O(b^2 n)$ 的。注意到我们的预处理是 $O(nb)$ 的复杂度，这样维护前缀和查询的复杂度是 $O(m)$ 的。考虑平衡，我们拿时间换空间，最简单的情况不难想到可以分块。我们将每 $B$ 个数在 $a,b$ 已知时的答案维护在一起，那么查询的时候就只需要暴力维护散块的答案了。这样的时间复杂度是 $O(nb+m(\frac{n}{B}+B))$ 的，空间复杂度是 $O(b^2\frac{n}{B})$ 的。当 $b=\sqrt{n}$ 时可以做到时间复杂度 $O(nb+m\sqrt{n})$，空间复杂度 $O(b^2 \sqrt{n})$。

哦，这题卡空间。

---

## 作者：Masterwei (赞：2)

首先发现 $b$ 比较小，可以对于所有的 $b$ 都进行预处理。

有区间询问，我们还要对于每个 $b$ 都进行预处理，而且 $n\times b$ 已经是一个不小的数了，考虑用分块维护。

对于 $\left\lfloor\frac{x+a}{b}\right\rfloor$ 这个式子，我们发现 $a$ 是可以先对 $b$ 进行取模的。然后 一个数 $x$ 除以 $b$ 的取值就两种，一种是 $\left\lfloor\frac{x}{b}\right\rfloor$，另一种是 $\left\lfloor\frac{x}{b}\right\rfloor+1$。分别对应 $a$ 的两个区间。

于是我们可以直接分块预处理，我们设 $f_{i,b,a}$ 表示在 $i$ 这个块中，$b,a$ 分别对应原式子中的参数的答案，预处理时只用差分一下，再加一下前缀和即可。

设 $B$ 为块长，时间复杂度为 $O(nb+\frac{n}{B}b^2+q(\frac{n}{B}+B))$，空间复杂度为 $O(\frac{n}{B}b^2)$。

我的代码在 $B=500$ 跑的最快。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int x=0;bool f=0;char ch=getchar();
	while(ch<'0'||ch>'9')f^=(ch=='-'),ch=getchar();
	while('0'<=ch&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return f?-x:x;
}
bool st;
const int Maxn=1e5+5,B=500,N=Maxn/B+5;
int n,q;
int a[Maxn];
int f[N][505][505];
inline void add(int id,int b,int l,int r){
	if(l>r)return;
	f[id][b][l]++;f[id][b][r+1]--;
}
inline int getr(int x,int b){
	return b-(x%b)-1;
}
inline int getl(int x,int b){
	return b-(x%b);
}
inline void work(int id,int x,int y,int b){
	if(x/b==y/b)add(id,b,0,min(getr(x,b),getr(y,b))),add(id,b,max(getl(x,b),getl(y,b)),b-1);
	if(x/b+1==y/b)add(id,b,getl(x,b),getr(y,b));
	if(x/b==y/b+1)add(id,b,getl(y,b),getr(x,b));
}
bool en;
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	cerr<<(&st-&en)/1024.0/1024.0<<'\n';
	n=read();q=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=0;i*B<=n;i++){
		for(int j=max(1,i*B);j<(i+1)*B;j++)
			for(int b=1;b<=500;b++)work(i,a[j-1],a[j],b);
		for(int b=1;b<=500;b++)
			for(int j=1;j<b;j++)f[i][b][j]+=f[i][b][j-1];
	}
	int last=0;
	while(q--){
		int l=(read()^last),r=(read()^last),A=(read()^last),b=(read()^last);
		A%=b;last=0;
		for(int i=l+1;i<=r;){
			while(i%B==0&&i+B-1<=r){
				last+=f[i/B][b][A];
				i+=B;
			}if(i>r)break;
			last+=((a[i-1]+A)/b==(a[i]+A)/b);
			i++;
		}printf("%d\n",last);
	}
	return 0;
}

```

---

## 作者：xxr___ (赞：2)

## P11660题解：
### 思路：
首先观察到 $B$ 很小，因此不难想到是否能通过对 $B$ 预处理来入手，我们考虑分块。

分块散块很好写，就是暴力，难在整块上。

因为 $\lfloor \frac{x+a}{b} \rfloor$ 其实等于 $\lfloor \frac{a}{b} \rfloor+ \lfloor \frac{x}{b} \rfloor+[b\leq x \bmod b+a \bmod b]$。

所以如果要满足 $f(x)=f(y)$ 必要的条件就是满足 $|\lfloor \frac{x}{b}\rfloor -\lfloor \frac{y}{b}\rfloor|\leq 1$。

下面对这个式子进行分类讨论:

首先，我们令 $c=\lfloor \frac{x}{b}\rfloor -\lfloor \frac{y}{b} \rfloor$，令 $t=a \bmod b$。
- 如果 $c=0$ 那么说明，$x \bmod b+t<b∧y \bmod b+t<b$ 或者 $b\leq x \bmod b+t∧b\leq y \bmod b+t$。也就是说 $t<\min(b-x \bmod b，b-y \bmod b)$ 或者 $\max(b-x \bmod b,b- y\bmod b)\leq t$。
- 如果 $c=1$ 那么说明，$\lfloor \frac{x}{b} \rfloor> \lfloor \frac{y}{b} \rfloor$ 的，且差值是1，那么这个时候，如果想让两者相同，需要保证 $x \bmod b+t<b∧b\leq y \bmod b+t$ 这样才能让 $f(x)$ 的值与 $f(y)$ 的值相同。那么也就是说 $t<b-x \bmod b∧b-y \bmod b\leq t$ 也就是 $b-y \bmod b\leq t<b-x \bmod b$。
- 如果 $c=-1$ 就是和第二种情况反过来，也就是 $b-x \bmod b\leq t<b-y \bmod b$ 这里不再复述了。

然后分析完我们发现，所有 $t$ 的取值都是一段连续的区间，这不难让我们想到可以使用差分来预处理，由于 $B$ 的值很小，我们可以预处理 $f_{i,j,k}$ 表示第 $i$ 个块当 $b=j$ 时 $a \equiv k \pmod b$ 时的答案，由于每次只需要考虑和前一个的大小关系，且区间加可以使用差分数组，因此总时间复杂度是 $O((n+q)B)$ 的，空间亦然。
### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep(i,l,r) for(int i=l;i<=r;++i)
#define pre(i,l,r) for(int i=l;i>=r;--i)
const int N=1e5+5;
const int K=450;
int f[K][505][505],a[N],n,q;
int lk[N],rk[N],bel[N]; 
int32_t main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	/*
	https://www.luogu.com.cn/paste/hm0cmym8  
	*/
	cin>>n>>q;
	rep(i,1,n) cin>>a[i];
	rep(i,1,n){
		bel[i]=(i-1)/K+1;
		if(!lk[bel[i]]) lk[bel[i]]=i;
		rk[bel[i]]=i;
	}
	rep(i,1,bel[n]){
		rep(b,1,500){
			rep(j,lk[i]+1,rk[i]){
				//我们令 x=a[j],y=a[j-1]
				//我们令 z=x%b,k=y%b 
				int x=a[j],y=a[j-1];
				int z=x%b,k=y%b,p=x/b-y/b;
				if(!p){
					f[i][b][0]++;
					f[i][b][min(b-z,b-k)]--;
					f[i][b][max(b-z,b-k)]++;
				}
				if(p==1){
					if(b-k<b-z){
						f[i][b][b-k]++;
						f[i][b][b-z]--;
					}
				}
				if(p==-1){
					if(b-z<b-k){
						f[i][b][b-z]++;
						f[i][b][b-k]--;
					}
				}
			}
			rep(j,1,500) f[i][b][j]+=f[i][b][j-1];
		}
	}
	int lst=0;
	rep(i,1,q){
		int ans=0,l,r,x,y;
		cin>>l>>r>>x>>y;
		l^=lst;r^=lst;x^=lst;y^=lst;
		if(bel[l]^bel[r]){
			rep(j,l+1,rk[bel[l]]){
				ans+=((a[j]+x)/y==(a[j-1]+x)/y);
			}
			rep(j,lk[bel[r]]+1,r){
				ans+=((a[j]+x)/y==(a[j-1]+x)/y);
			}
			rep(j,bel[l]+1,bel[r]-1){
				ans+=f[j][y][x%y];
			}
			rep(j,bel[l],bel[r]-1){
				ans+=((a[rk[j]]+x)/y==(a[rk[j]+1]+x)/y);
			}
			//处理两个块中间那两个 
			cout<<ans<<'\n';
			lst=ans;
		}else{
			rep(j,l+1,r){
				ans+=((a[j]+x)/y==(a[j-1]+x)/y);
			}
			cout<<ans<<'\n';
			lst=ans;
		}
	} 
	return 0;
}
//xxr
```

---

## 作者：_zuoqingyuan (赞：2)

哎呀，好玩的题，但是出题人题解看不懂，这里给一个无脑的分块做法。

与题面不同，下文中 $f(x)=\lfloor\frac{x}{b}\rfloor$

# 思路分析

首先，对于每一个询问，可以将 $a\gets a\bmod b$。

证明：假设 $a>b,a=kb+v$，则 $\lfloor\frac{x+a}{b}\rfloor=\lfloor\frac{x+v}{b}\rfloor+kb$，而相邻两项的变化值一样，所以没有影响。

此时 $0\le a<b\le 500$，注意到 $a,b$ 的规模相当小，我们思考从这一点优化。

考虑分块，取块长为 $\sqrt{n}$，设 $s_{i,j,k}$ 表示前 $i$ 块中所有数加上 $k$ 后，除以 $j$ 向下取整，相等的相邻数对个数。我们可以枚举 $j,k$，对每个块分别计算（块中第一个元素特殊处理），然后再加起来。

预处理可以 $nb^2$，单次查询时，我们对两边暴力，中间用处理出来的前缀和计算，单次查询时间复杂度可以做到 $\sqrt{n}$，此时时间复杂度 $O(n(b^2+\sqrt{n}))$，瓶颈在于预处理。

此时，已经可以通过 $b\le 10$ 的测试点了。

在预处理时，每次都要枚举 $j,k$，我们不妨只枚举 $j$，先计算 $s_{i,j,0}$。然后思考当 $k$ 取和值时回对 $s_{i,j,k}$ 产生影响。

首先，若 $|f(A_i)-f(A_{i-1})|\ge 2$，无论 $k$ 取和值，数对 $(i,i-1)$ 都不会产生贡献。

若 $f(A_i)=f(A_{i-1})$，则数对 $(i,i-1)$ 会在 $s_{i,j,0}$ 中产生贡献，不过，随着 $k$ 的增长，$f(A_i+k),f(A_{i-1}+k)$ 也会相应的发生变化。

我们下文假定 $u=A_i\bmod j,v=A_{i-1}\bmod j$ 且 $u>v$。

- 当 $k<b-u$，此时 $f(A_i+k)=f(A_{i}),f(A_{i-1}+k)=f(A_{i-1})$。此时数对仍然会产生贡献。

- 当 $b-u\le k<b-v$，此时 $f(A_i+k)=f(A_{i})+1,f(A_{i-1}+k)=f(A_{i-1})$。因为 $f(A_i+k)\ne f(A_{i-1}+k)$，所以数对不会产生贡献。

- 当 $k\ge b-v$，此时 $f(A_i+k)=f(A_{i})+1,f(A_{i-1}+k)=f(A_{i-1})+1$。因为此时 $f(A_i+k)=f(A_{i-1}+k)$，数对又开始产生贡献。

当 $k\in [b-u,b-v)$ 时，这个数对相对于 $s_{i,j,0}$ 回对 $s_{i,j,k}$ 产生 $-1$ 的贡献。

另外两种情况分别是 $f(A_i)=f(A_{i-1})+1,f(A_i)+1=f(A_i-1)$，读者可自行推理。对于 $[l,r]$ 产生 $c$ 的贡献，可以用差分优化，此时预处理时间复杂度优化到 $nb$。已经可以通过本题。

值得注意的是，$s$ 数组开 `int` 会爆，但是如果开 `short` 不会，所以有两种解决措施。

1. 不记录前缀和，而是在查询时同时累加。

2. 调整块长

我懒得改了，因为虽然理论上前缀和数组开 `short` 会爆，但数据并没有把这种写法卡掉。


```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
const int N=1e5+10,B=500;
int n,m,t,block,x[N],L[325],R[325],pos[N],c[505];
short s[325][505][505];
int ask(int l,int r,int b,int a){
	int p=pos[l],q=pos[r],ans=0;
	if(p==q){
		for(int i=l+1;i<=r;i++)if((x[i]+a)/b==(x[i-1]+a)/b)ans++;
	}else{
		ans+=s[q-1][b][a]-s[p][b][a];
		for(int i=l+1;i<=R[p];i++)if((x[i]+a)/b==(x[i-1]+a)/b)ans++;
		for(int i=L[q]+1;i<=r;i++)if((x[i]+a)/b==(x[i-1]+a)/b)ans++;
		for(int i=1;i<=t;i++)if(l<=L[i]-1&&L[i]<=r&&((x[L[i]]+a)/b==(x[L[i]-1]+a)/b))ans++;
	}
	return ans;
} 
int main(){
	scanf("%d %d",&n,&m);
	block=sqrt(n),t=n/block;
	for(int i=1;i<=n;i++)scanf("%d",x+i);
	for(int i=1;i<=t;i++)L[i]=R[i-1]+1,R[i]=i*block;
	if(R[t]<n)t++,L[t]=R[t-1]+1,R[t]=n;
	for(int i=1;i<=t;i++){
		for(int j=L[i];j<=R[i];j++)pos[j]=i;
	}
	int u,v,l,r;
	for(int b=1;b<=B;b++){
		for(int p=1;p<=t;p++){
			for(int i=L[p]+1;i<=R[p];i++){
				if(x[i]/b==x[i-1]/b){
					s[p][b][0]++;
					u=x[i]%b,v=x[i-1]%b;
					if(u>=v){
						l=b-u,r=b-v;
						c[l]--,c[r]++;	
					}else{
						l=b-v,r=b-u;
						c[l]--,c[r]++;
					}
				}else if(x[i]/b==x[i-1]/b+1){
					u=x[i]%b,v=x[i-1]%b;
					l=b-v,r=b-u;
					if(l<r)c[l]++,c[r]--;
				}else if(x[i]/b+1==x[i-1]/b){
					u=x[i]%b,v=x[i-1]%b;
					l=b-u,r=b-v;
					if(l<r)c[l]++,c[r]--;
				}
			}
			for(int i=1;i<=b;i++)c[i]+=c[i-1],s[p][b][i]=s[p][b][0]+c[i];
			for(int i=0;i<=b;i++)c[i]=0;
		}
	}
	for(int b=1;b<=B;b++){
		for(int a=0;a<b;a++){
			for(int p=1;p<=t;p++){
				s[p][b][a]+=s[p-1][b][a];
			}
		}
	}
	int last=0;
	while(m--){
		int l,r,a,b;
		scanf("%d %d %d %d",&l,&r,&a,&b);
		l^=last,r^=last,a^=last,b^=last;
		a%=b,last=ask(l,r,b,a);
		printf("%d\n",last);
	}
	return 0;
} 
```


如有错误，请指出。

---

## 作者：modfish_ (赞：0)

## 思路
考虑两个数 $x,y$，不妨令 $x\le y$，那么何时有 $f(x)=f(y)$ 呢？

第一个显然的条件是 $y-x<b$，否则 $f(x)$ 与 $f(y)$ 至少差 $1$。

第二个条件，记 $u=x\bmod b,v=y\bmod b,c=a\bmod p$。分情况讨论：

- $\displaystyle\lfloor\frac{x}{b}\rfloor=\lfloor\frac{y}{b}\rfloor$，此时必有 $u\le v$，条件为 $0\le c<b-v$ 或 $b-u\le c<b$。

- $\displaystyle\lfloor\frac{x}{b}\rfloor+1=\lfloor\frac{y}{b}\rfloor$，此时必有 $u\ge v$，条件为 $b-u\le c\le b-v$。

以上两个条件都挺好推，也比较显然。

那么一个想法是记录前缀 $[1,i]$ 内，在 $b=j,a\bmod b=k$ 时的答案 $f_{i,j,k}$。这个处理可以简单地使用差分完成。时空复杂度为 $O(nb^2)$，无法通过。

考虑分块，处理出第 $i$ 个块内，$b=j,a\bmod b=k$ 时的答案 $g_{i,j,k}$ 即可。

下面分析块长。设块长为 $B$。则时间复杂度为 $O(q(B+\frac{n}{B})+\frac{n}{B}b^2)$，空间复杂度为 $O(\frac{n}{B}b^2)$。为了均匀应取 $qB=\frac{n}{B}b^2$，得 $B=\sqrt{\frac{n}{q}}b$。取 $B=500$ 即可。

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 1e5 + 5, sqtn = 205;

int bid[maxn], L[sqtn], R[sqtn], cnt[505][sqtn][505], A[maxn];

int query(int l, int r, int a, int b){
    int s = bid[l], t = bid[r];
    int res = 0;
    if(s == t){
        for(int i = l; i <= r; i ++) res += ((A[i] + a) / b) == ((A[i - 1] + a) / b);
        return res;
    }
    int aa = a % b;
    if(l == L[s]) res += cnt[b][s][aa];
    else for(int i = l; i <= R[s]; i ++) res += ((A[i] + a) / b) == ((A[i - 1] + a) / b);
    s ++;
    if(r == R[t]) res += cnt[b][t][aa];
    else for(int i = L[t]; i <= r; i ++) res += ((A[i] + a) / b) == ((A[i - 1] + a) / b);
    t --;
    for(int i = s; i <= t; i ++) res += cnt[b][i][aa];
    return res;
}

int main(){
    int n, q;
    scanf("%d %d", &n, &q);
    int bl = 500;
    for(int i = 1; i <= n; i ++){
        scanf("%d", &A[i]);
        bid[i] = (i - 1) / bl + 1;
        if(i > 1){
            int m = min(A[i], A[i - 1]), M = max(A[i], A[i - 1]), d = M - m;
            for(int j = 500; j > d; j --){
                int rm = m % j, rM = M % j;
                if(m / j == M / j) cnt[j][bid[i]][0] ++, cnt[j][bid[i]][j - rM] --, cnt[j][bid[i]][j - rm] ++;
                else cnt[j][bid[i]][j - rm] ++, cnt[j][bid[i]][j - rM] --;
            }
        }
    }
    for(int i = 1; i <= bid[n]; i ++){
        L[i] = R[i - 1] + 1, R[i] = min(L[i] + bl - 1, n);
        for(int j = 1; j <= 500; j ++) for(int k = 1; k < j; k ++) cnt[j][i][k] += cnt[j][i][k - 1];
    }
    int lans = 0;
    for(int i = 1; i <= q; i ++){
        int l, r, a, b;
        scanf("%d %d %d %d", &l, &r, &a, &b);
        l ^= lans, r ^= lans, a ^= lans, b ^= lans;
        lans = query(l + 1, r, a, b);
        printf("%d\n", lans);
    }
    return 0;
}
```

---

## 作者：yzq_yzq (赞：0)

场切了，强制在线感觉很唐，还有这题目背景不会被 Ban 吗。

令 $b$ 的值域为 $V=500$ ，仔细读题发现贡献其实是二位偏序的形式，然后有 $V$ 组序列都要查，然后二维偏序的值域为 $V$ 。

这东西强制在线主席树显然不够开，再加上看过了唐诗 T1 于是考虑分块，散块暴力即可，大块考虑预处理，块内考虑预处理的时候差分，然后前缀和滚回去就可以一次 $O(V+B)$ 就算好块内答案，最后复杂度是 $V\times(\frac n B \times (V +B))$ 的。

空间开销比较大，假如不够开块长取大点就行了。

挂个丑陋的赛时代码：

```cpp
#include <bits/stdc++.h>
#define rep(i, x, y) for (int i = x; i <= y; ++i)
#define drep(i, x, y) for (int i = x; i >= y; --i)
#define ll long long
#define pb push_back
#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
const int N = 100050, M = 505, V = 10;
#define ull unsigned ll
#define ppc(x) __builtin_popcountll(x)
int n, m, a[N], res[M][205][M], c[M], sq, pos[N], L[N], R[N], s[N];
// (x + a) / b = (y + a) / b
int main() {
	IOS; cin >> n >> m;
	rep(i, 1, n) cin >> a[i]; int lst = 0;
//	if(n <= 100) {
//		while(m--) {
//			int l, r, x, y; cin >> l >> r >> x >> y;
//			l ^= lst, r ^= lst, x ^= lst, y ^= lst, x %= y;
//			int ans = 0;
//			rep(i, l, r - 1) ans += ((a[i] + x) / y == (a[i + 1] + x) / y);
//			cout << ans << '\n'; lst = ans;
//		}
//		return 0;
//	}
	sq = M - 1;
	rep(i, 1, n) pos[i] = (i - 1) / sq + 1;
	rep(i, 1, pos[n]) L[i] = (i - 1) * sq + 1, R[i] = min(n - 1, i * sq);
	rep(i, 1, n) s[i] = s[i - 1] + (a[i] == a[i + 1]);
	rep(b, 1, 500) {
		rep(i, 1, pos[n]) {
			rep(j, 0, b) c[j] = 0;
			int x, y;
			rep(j, L[i], R[i]) {
				if(abs(a[j] - a[j + 1]) >= b) continue;
				x = a[j], y = a[j + 1];
				if(x == y) c[0]++;
				else {
					if(x > y) swap(x, y);
					if(x / b == y / b) {
						x %= b, y %= b;
						c[0]++, c[b - y]--, c[b - x]++;
					} else {
						// x / b < y / b
						c[b - x % b]++;
						c[b - y % b]--;
					}
				}
			}
			res[b][i][0] = c[0];
			rep(j, 1, b) c[j] += c[j - 1], res[b][i][j] = c[j];
		}
	}
	while(m--) {
		int l, r, x, y; cin >> l >> r >> x >> y;
		l ^= lst, r ^= lst, x ^= lst, y ^= lst, x %= y, --r;
//		cout << "true : " << l << " " << r << " " << x << " " << y << " \n";
		assert(l <= r && y < M);
		lst = 0;
		if(pos[l] == pos[r]) {
			rep(i, l, r) lst += ((a[i] + x) / y == (a[i + 1] + x) / y);
		} else {
			rep(i, l, R[pos[l]]) lst += ((a[i] + x) / y == (a[i + 1] + x) / y);
			rep(i, L[pos[r]], r) lst += ((a[i] + x) / y == (a[i + 1] + x) / y);
			rep(i, pos[l] + 1, pos[r] - 1) lst += res[y][i][x];
		}
		cout << lst << '\n';
	}
	return 0;
}
```

---

## 作者：RDFZchenyy (赞：0)

场上首杀。

总体上感觉是非常顺理成章的一道题。

---

给定长为 $n$ 的整数序列，$m$ 次询问，每次给出 $l,r,a,b$，求 $f(x)=\lfloor\frac{a+x}{b}\rfloor$ 代入 $a_l\sim a_r$ 后相邻相同的对数。

对于 $100%$ 的数据 $n,m\le 10^5,b\le 500$。

---

我们几乎已经会做这道题。

**【解法 1】**

如果我们可以处理出 $(i,i+1)$ 在模每个 $b$ 余 $i$ 时可不可行，并做前缀和，每次拿两个东西相减，就可以轻松地完成本题，时空复杂度均为 $O(nb^2)$。

---

为了加速这个过程，我们需要发现一些结论。

**【结论 1】**

对于同一个 $b$，$f(a_i)=f(a_{i+1})$ 时 $b$ 的取值构成 $O(1)$ 个连续段。

---

由这个结论，显然可以更加快速地预处理出来每一位置的前缀和数组对不同的余数 $i$ 的差分。

请注意，我们只能预处理出来，而如果希望保存下来，复杂度仍然是 $O(nb^2)$，而预处理复杂度仅为 $O(nb)$。

如果无法保存全部内容，我们考察只保存一部分值。

**【正确解法】**

我们考虑维护这个差分数组，每 $s$ 个保存一次。

则我们保存的时空复杂度均为 $O(\frac ns b^2)$

于是我们在处理某一个询问时，先找到它之前最靠近它的一个差分数组，拷贝后模拟 $O(s)$ 次，接着以 $O(b)$ 的时间复杂度将在余数上差分的前缀和数组还原为合法与否的前缀和数组。

请注意：我们的复杂度即为 $O(\frac ns b^2+nb+ms+mb)$，使 $s=b$，即 $O(nb+mb)$。

```cpp
#include<bits/stdc++.h>

#define MAXN 100005

int n,m;
int p[MAXN];
const int V=1000;
int s[505][205][505];
int tp[100005],tb[100005];
int l,r,a,b;
int ans;

void chk(int* li,int i,int b){
    if(abs(p[i]-p[i+1])>=b) li[0]++,li[b]--;
    else if((p[i]/b)==(p[i+1]/b)){
        int x=p[i]%b,y=p[i+1]%b;
        if(x>y) std::swap(x,y);
        li[b-y]++;
        li[b-x]--;
    }else{
        int x=b-(std::min(p[i],p[i+1])%b);
        int y=b-(std::max(p[i],p[i+1])%b);
        li[0]++;
        li[x]--;
        li[y]++;
    }

    return;
}

int main(){
	std::ios::sync_with_stdio(false);
	
	std::cin>>n>>m;
	for(int i=1;i<=n;i++) std::cin>>p[i];
	for(int b=1;b<=500;b++){
		for(int i=1;i<=n-1;i++){
			// int x=p[i]%b,y=p[i+1]%b;
			// if(x>y) std::swap(x,y);
            chk(s[b][i/V+1],i,b);
			// s[b][i/V+1][b-y]++;
			// s[b][i/V+1][b-x]--;
		}
		for(int i=1;i<n/V+1;i++){
			for(int j=0;j<b;j++){
				s[b][i][j]+=s[b][i-1][j];
			}
		}
	}
	for(int i=1;i<=m;i++){
		std::cin>>l>>r>>a>>b;
		l^=ans,r^=ans,a^=ans,b^=ans;
        a%=b;
		int x=l/V,y=r/V; 
		--l,--r;
		for(int j=0;j<b;j++){
			tp[j]=s[b][x][j];
			tb[j]=s[b][y][j];
		}
		for(int j=std::max(x*V,1);j<=l;j++){
			int x=p[j]%b,y=p[j+1]%b;
			if(x>y) std::swap(x,y);
            chk(tp,j,b);
		}
		for(int j=std::max(y*V,1);j<=r;j++){
			int x=p[j]%b,y=p[j+1]%b;
			if(x>y) std::swap(x,y);
            chk(tb,j,b);
		}
		for(int j=1;j<b;j++) tp[j]+=tp[j-1],tb[j]+=tb[j-1];
		std::cout<<(ans=(r-l-tb[a]+tp[a]))<<'\n';
	}
	
	return 0;
}
```

---


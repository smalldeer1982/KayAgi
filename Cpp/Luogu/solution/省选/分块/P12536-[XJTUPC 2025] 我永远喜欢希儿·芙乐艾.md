# [XJTUPC 2025] 我永远喜欢希儿·芙乐艾

## 题目描述

**请注意本题不同寻常的空间限制。**

给定 **操作序列** $A$ 和一棵有根树 $T$，$A$ 中的每个操作都形如「给 $T$ 中 $u$ 到 $v$ 的简单路径上的所有点权增加 $x$」。其中，$u$ 到 $v$ 的简单路径定义为：从 $u$ 开始到 $v$ 结束的一条不重复访问任何节点和边的路径。

初始时 $T$ 的根为 $1$，所有点权皆为 $0$。

你需要执行三种操作：

- 给定区间 $[l,r]$，依次执行 $A_l, A_{l+1}\dots$ 到 $A_r$ 的操作；
- 查询 $T$ 以 $x$ 为根的子树和；
- 换 $T$ 的根到 $y$（若当前根为 $y$，则不进行操作）。

## 样例 #1

### 输入

```
4 5 7
3 5 2
5 4 3
3 1 2
2 5 1
2 1
4 2
1 5
3 2
1 1 4
2 1
1 2 3
2 2
3 3
1 1 3
2 2```

### 输出

```
29
25
63```

# 题解

## 作者：_Kenma_ (赞：3)

## 前言

提供一种比官解劣的做法。

用一节 whk 自习口胡出来的。

## 思路分析

首先换根是假的，我们依然维护以 $1$ 为根的子树和即可。

考虑根号相关数据结构。

把 $A$ 分块，块长为 $B$，那么我们分散块和整块考虑。

对于散块，散块的总块长之和为 $O(nB)$，这一部分直接维护链加子树和，使用树上差分相关套路做到 $O(nB\log n)$。

对于整块，我们预处理系数 $b_{i,j}$ 表示进行第 $i$ 块内加 $1$，第 $j$ 个点的子树会加 $b_{i,j}$。$b$ 的处理可以树上差分求两次子树和做到 $O(\frac{n^2}{B})$。

因为要求空间线性，所以我们需要逐块处理。

总体复杂度为 $O(nB\log n+\frac{n^2}{B})$，平衡复杂度后为 $O(n \sqrt{n \log n})$。

关于链加子树和的维护，也可以使用更简单的树剖 + BIT，总体复杂度为 $O(nB\log^2 n+\frac{n^2}{B})$，平衡复杂度后为 $O(n \sqrt{n} \log n)$，常数很小。

---

## 作者：modfish_ (赞：3)

## 思路
看到这种比较神奇的、不是很好做的数据结构，当然要想到分块。

首先这个操作 $3$ 就是糊弄人的。我们建树时以 $1$ 为根。设当前根节点为 $r$，那么询问节点 $x$ 时，如果 $x=r$，相当于查询全局和，也就是 $1$ 的子树和；如果 $x$ 是 $r$ 的祖先，设 $x$ 靠近 $r$ 的儿子为 $y$（即 $y$ 也是 $r$ 的祖先），相当于查询全局和减去 $y$ 的子树和；否则，直接查询 $x$ 的子树和即可。

最终我们只要实现维护子树和。怎么做呢？

一个显然的方法是把操作序列 $A$ 分块，对于两边的散块直接暴力进行修改。对于整块，可以对每一个块统计进行一次块内所有操作后，对每个点的子树和的贡献，比如操作完第 $i$ 个块后，对每个点子树和的贡献记为 $c_{i,x}$，那么进行 $k$ 次，总贡献自然是 $c_{i,x}\times k$。直接维护到目前为止，每个块被操作几次即可。

不过，上述方法有两个问题：

- 散块操作时，每次 $1$ 操作要进行 $O(\sqrt{n_1})$ 次修改。也就是说我们必须实现 $O(1)$ 修改的树链修改、子树求和。
- 整块操作时，如果记录每一个 $c_{i,x}$，空间复杂度达到 $O(n_2\sqrt{n_1})$，无法通过。

下面我们来解决这两个问题。

---

对于问题一，我们很明显可以使用树上差分。但是差分完怎么子树求和呢？

我们知道，树上差分完后要先进行一遍子树求和，才能得到原始信息，那么原始信息的子树和相当于要再做一遍子树求和。即：对树上差分的信息做两遍子树求和。

这该如何实现？考虑某个点 $x$ 子树内的点 $u$，设 $u$ 的差分信息为 $d_u$，考虑它对 $x$ 两次子树求和后的贡献。

$d_u$ 在第一次子树求和中，被它的所有祖先都统计了一次。设 $u$ 到 $x$ 链上的点集为 $U$，那么 $U$ 中所有点的信息里都包含了一个 $d_u$。进行第二次子树求和时，每一个 $d_u$ 都会被算入 $x$ 的子树和内。也就是说，最终贡献为 $d_u\times \lvert U\rvert=d_u\times(\text{dep}_u-\text{dep}_x+1)$。其中 $\text{dep}_x$ 表示 $x$ 的深度，即 $x$ 到根节点路径上的点数。

再拆开一下，$d_u$ 的贡献为 $d_u\times \text{dep}_u-(\text{dep}_x-1)d_u$。所以维护 $d_u\times \text{dep}_u$ 和 $d_u$ 即可。至于如何 $O(1)$ 修改，对树的 DFS 序分块即可。可以做到 $O(1)$ 修改，$O(\sqrt{n_2})$ 查询。

---

对于问题二，既然记不下来，那就把询问离线然后边算边记答案即可。

具体地，我们从左往右扫描每一个块，把这个块内的操作对每一个点的子树和贡献算出来。然后直接对每一个询问记入答案。

一个问题是：不同的询问有不同的时间戳，不同的时间戳上，一个块被操作的次数是不同的。我们如何维护这个操作次数？

仍然是差分。注意到如果记录 $p_{i,j}$ 表示第 $i$ 个块在时间 $j$ 被操作过的次数。那么如果在时间 $t$ 操作了块区间 $[l,r]$，相当于把 $i\in [l,r]$，$j\in [t,m]$ 范围内的 $p_{i,j}$ 全部加上 $1$。这是一个矩形操作。

所以在每个块上打标记即可。每个块开一个 `vector`，每次修改时，在第一个整块的 `vector` 内插入一个“对 $t$ 时间之后的次数 $+1$”的信息，最后一个整块的后一个整块的 `vector` 内插入一个“对 $t$ 时间之后的次数 $-1$”的信息，扫描时可以只维护 $p$ 的第二维，每次按照标记修改即可。

---

最终，我们做到了时间复杂度 $O(m\sqrt{n_1}+m\sqrt{n_2})$，空间复杂度 $O(n_1+n_2+m)$。可以通过此题。

（虽然我偷懒用了倍增，导致空间复杂度为 $O(n_1+n_2\log n_2+m)$。使用树剖可以丢掉 $\log$）

## 代码
如果想要参考代码，请注意代码中 $m,n,q$ 分别对应题面中 $n_1,n_2,m$。


```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int maxn = 1e5 + 5, sqtn = 320;

int us[maxn], vs[maxn], ks[maxn], lcas[maxn];
int bid1[maxn], L1[sqtn], R1[sqtn], bid2[maxn], L2[maxn], R2[maxn];
int head[maxn], nxt[maxn << 1], to[maxn << 1], cnt = 0;
int dep[maxn], siz[maxn], dfn[maxn], dnt = 0, jp[maxn][20];
int ops[maxn], xs[maxn];
ll V[maxn], Vd[maxn], bV[sqtn], bVd[sqtn], ans[maxn];
vector<int> ad[sqtn];
int tim[maxn], dtim[maxn];
ll tag[maxn], sum[maxn];

void match(int u, int v){
    nxt[++ cnt] = head[u], to[cnt] = v, head[u] = cnt;
}
void dfs(int x, int f){
    jp[x][0] = f, dep[x] = dep[f] + 1, siz[x] = 1, dfn[x] = ++ dnt;
    for(int i = head[x]; i; i = nxt[i]){
        int j = to[i];
        if(j == f) continue;
        dfs(j, x);
        siz[x] += siz[j];
    }
}
int LCA(int u, int v){
    if(dep[u] < dep[v]) swap(u, v);
    int d = dep[u] - dep[v];
    for(int i = 0; i <= 16; i ++) if((d >> i) & 1) u = jp[u][i];
    if(u == v) return u;
    for(int i = 16; i >= 0; i --) if(jp[u][i] != jp[v][i]) u = jp[u][i], v = jp[v][i];
    return jp[u][0];
}
int jump(int u, int k){
    for(int i = 0; i <= 16; i ++) if((k >> i) & 1) u = jp[u][i];
    return u;
}
void updtree(int x, ll k){
    V[dfn[x]] += k, bV[bid2[dfn[x]]] += k;
    Vd[dfn[x]] += k * dep[x], bVd[bid2[dfn[x]]] += k * dep[x];
}
ll quetree(int x){
    int l = dfn[x], r = dfn[x] + siz[x] - 1, s = bid2[l], t = bid2[r];
    ll res = 0;
    if(s == t){
        for(int i = l; i <= r; i ++) res += Vd[i] - V[i] * (dep[x] - 1);
        return res;
    }
    for(int i = l; i <= R2[s]; i ++) res += Vd[i] - V[i] * (dep[x] - 1);
    s ++;
    for(int i = L2[t]; i <= r; i ++) res += Vd[i] - V[i] * (dep[x] - 1);
    t --;
    for(int i = s; i <= t; i ++) res += bVd[i] - bV[i] * (dep[x] - 1);
    return res;
}
void update(int l, int r, int tim){
    int s = bid1[l], t = bid1[r];
    if(s == t){
        for(int i = l; i <= r; i ++) updtree(us[i], ks[i]), updtree(vs[i], ks[i]), updtree(lcas[i], -ks[i]), updtree(jp[lcas[i]][0], -ks[i]);
        return;
    }
    for(int i = l; i <= R1[s]; i ++) updtree(us[i], ks[i]), updtree(vs[i], ks[i]), updtree(lcas[i], -ks[i]), updtree(jp[lcas[i]][0], -ks[i]);
    s ++;
    for(int i = L1[t]; i <= r; i ++) updtree(us[i], ks[i]), updtree(vs[i], ks[i]), updtree(lcas[i], -ks[i]), updtree(jp[lcas[i]][0], -ks[i]);
    t --;
    ad[s].push_back(tim), ad[t + 1].push_back(-tim);
}
void calc(int x, int f){
    sum[x] = 0;
    for(int i = head[x]; i; i = nxt[i]){
        int j = to[i];
        if(j == f) continue;
        calc(j, x);
        tag[x] += tag[j], sum[x] += sum[j];
    }
    sum[x] += tag[x];
}

int main(){
    int m, n, q;
    scanf("%d %d %d", &m, &n, &q);
    int bl1 = sqrt(m), bl2 = sqrt(n);
    for(int i = 1; i <= m; i ++){
        scanf("%d %d %d", &us[i], &vs[i], &ks[i]);
        bid1[i] = (i - 1) / bl1 + 1;
    }
    for(int i = 1; i <= bid1[m]; i ++) L1[i] = R1[i - 1] + 1, R1[i] = min(L1[i] + bl1 - 1, m);
    for(int i = 1; i < n; i ++){
        int u, v;
        scanf("%d %d", &u, &v);
        match(u, v), match(v, u);
        bid2[i] = (i - 1) / bl2 + 1;
    }
    bid2[n] = (n - 1) / bl2 + 1;
    for(int i = 1; i <= bid2[n]; i ++) L2[i] = R2[i - 1] + 1, R2[i] = min(L2[i] + bl2 - 1, n);
    dfs(1, 0);
    for(int j = 1; j <= 16; j ++) for(int i = 1; i <= n; i ++) jp[i][j] = jp[jp[i][j - 1]][j - 1];
    for(int i = 1; i <= m; i ++) lcas[i] = LCA(us[i], vs[i]);
    int rt = 1;
    for(int i = 1; i <= q; i ++){
        int op, l, r;
        scanf("%d", &op);
        ops[i] = op;
        if(op == 1){
            scanf("%d %d", &l, &r);
            update(l, r, i);
        }else if(op == 2){
            scanf("%d", &l);
            int lca = LCA(l, rt);
            if(l == rt) xs[i] = 1;
            else if(lca == l) xs[i] = -jump(rt, dep[rt] - dep[l] - 1);
            else xs[i] = l;
            ans[i] = xs[i] > 0 ? quetree(xs[i]) : (quetree(1) - quetree(-xs[i]));
        }else{
            scanf("%d", &r);
            rt = r;
        }
    }
    for(int b = 1; b <= bid1[m]; b ++){
        for(int i = 0; i < ad[b].size(); i ++){
            if(ad[b][i] > 0) dtim[ad[b][i]] ++;
            else dtim[-ad[b][i]] --;
        }
        for(int i = 1; i <= q; i ++) dtim[i] += dtim[i - 1], tim[i] += dtim[i], dtim[i - 1] = 0;
        dtim[q] = 0;
        for(int i = L1[b]; i <= R1[b]; i ++) tag[us[i]] += ks[i], tag[vs[i]] += ks[i], tag[lcas[i]] -= ks[i], tag[jp[lcas[i]][0]] -= ks[i];
        calc(1, 0);
        for(int i = 1; i <= q; i ++){
            if(ops[i] == 2){
                if(xs[i] > 0) ans[i] += sum[xs[i]] * tim[i];
                else ans[i] += sum[1] * tim[i] - sum[-xs[i]] * tim[i];
            }
        }
        for(int i = 1; i <= n; i ++) tag[i] = sum[i] = 0;
    }
    for(int i = 1; i <= q; i ++) if(ops[i] == 2) printf("%lld\n", ans[i]);
    return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：1)

[Problem Link](https://www.luogu.com.cn/problem/P12536)

**题目大意**

> 给定 $m$ 个点的树，以及 $n$ 个操作，每个操作都是对树上一条路径的权值加 $x$。
>
> 维护 $q$ 次修改，形如执行 $l\sim r$ 的操作各一次，或换根和求子树和。
>
> 数据范围：$n,m,q\le 10^5$。

**思路分析**

首先换根可以转成求子树补权值和。

然后维护修改可以直接对操作分块。

对于 $[l,r]$ 内部的每一个整块，直接逐块处理，对每块算出进行块内每个操作一次，对每个子树和的贡献系数。

然后维护散块操作，可以简单树上差分成二维数点，用 Sqrt-Tree 维护即可。

时间复杂度 $\mathcal O((n+m+q)\sqrt n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=1e5+5;
struct SqrtTree {
	ll s1[MAXN],s2[(MAXN>>7)+5],s3[(MAXN>>14)+5];
	void add(int x,ll y) { s1[x]+=y,s2[x>>7]+=y,s3[x>>14]+=y; }
	ll qry(int x) {
		ll s=0;
		for(int i=((x>>7)<<7);i<=x;++i) s+=s1[i];
		for(int i=((x>>14)<<7);i<(x>>7);++i) s+=s2[i];
		for(int i=0;i<(x>>14);++i) s+=s3[i];
		return s;
	}
	ll qry(int l,int r) { return qry(r)-qry(l-1); }
}	T1,T2;
vector <int> G[MAXN],Q[MAXN];
int n,m,q,dfn[MAXN],efn[MAXN],dep[MAXN],fa[MAXN],dcnt,rk[MAXN];
int u[MAXN],v[MAXN],w[MAXN],h[MAXN],dsu[MAXN];
int find(int x) { return x^dsu[x]?dsu[x]=find(dsu[x]):x; }
void dfs(int p,int fz) {
	fa[p]=fz,dfn[p]=++dcnt,dep[p]=dep[fz]+1,rk[dcnt]=p;
	for(int e:G[p]) if(e^fz) dfs(e,p),dsu[e]=p;
	efn[p]=dcnt; if(fz) G[p].erase(find(G[p].begin(),G[p].end(),fz));
	for(int o:Q[p]) if(dfn[u[o]^v[o]^p]) h[o]=find(u[o]^v[o]^p);
}
void upd(int x,int c) {
	if(x) T1.add(dfn[x],c*dep[x]),T2.add(dfn[x],c);
}
void add(int x) {
	upd(u[x],w[x]),upd(v[x],w[x]),upd(h[x],-w[x]),upd(fa[h[x]],-w[x]);
}
int x[MAXN],y[MAXN],lp[MAXN],rp[MAXN],bl[MAXN];
ll f[MAXN],ans[MAXN];
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m>>q;
	for(int i=1;i<=n;++i) cin>>u[i]>>v[i]>>w[i],Q[u[i]].push_back(i),Q[v[i]].push_back(i);
	for(int i=1,s,t;i<m;++i) cin>>s>>t,G[s].push_back(t),G[t].push_back(s);
	int B=sqrt(n);
	iota(dsu+1,dsu+m+1,1),dfs(1,0);
	for(int i=1;i<=(n-1)/B+1;++i) {
		lp[i]=(i-1)*B+1,rp[i]=min(n,i*B),fill(bl+lp[i],bl+rp[i]+1,i);
	}
	for(int i=1,o,rt=1;i<=q;++i) {
		cin>>o;
		if(o==1) {
			cin>>x[i]>>y[i];
			if(bl[x[i]]==bl[y[i]]) for(int j=x[i];j<=y[i];++j) add(j);
			else {
				for(int j=x[i];j<=rp[bl[x[i]]];++j) add(j);
				for(int j=lp[bl[y[i]]];j<=y[i];++j) add(j);
			}
		} else if(o==3) cin>>rt;
		else {
			cin>>x[i]; int p=x[i];
			if(rt==p) x[i]=p=1;
			else if(dfn[p]<dfn[rt]&&dfn[rt]<=efn[p]) {
				x[i]=p=-(*--upper_bound(G[p].begin(),G[p].end(),rt,[&](int s,int t){ return dfn[s]<dfn[t]; }));
			}
			if(p>0) {
				ans[i]+=T1.qry(dfn[p],efn[p])-(dep[p]-1)*T2.qry(dfn[p],efn[p]);
			} else {
				ans[i]+=T1.qry(m),p=-p;
				ans[i]-=T1.qry(dfn[p],efn[p])-(dep[p]-1)*T2.qry(dfn[p],efn[p]);
			}
		}
	}
	for(int o=1;o<=bl[n];++o) {
		memset(f,0,sizeof(f));
		for(int i=lp[o];i<=rp[o];++i) f[u[i]]+=w[i],f[v[i]]+=w[i],f[h[i]]-=w[i],f[fa[h[i]]]-=w[i];
		for(int _:{0,1}) for(int i=m;i>1;--i) f[fa[rk[i]]]+=f[rk[i]];
		for(int i=1,tg=0;i<=q;++i) {
			if(x[i]&&y[i]) tg+=(bl[x[i]]<o&&o<bl[y[i]]);
			else if(x[i]) {
				if(x[i]>0) ans[i]+=tg*f[x[i]];
				else ans[i]+=tg*(f[1]-f[-x[i]]);
			}
		}
	}
	for(int i=1;i<=q;++i) if(x[i]&&!y[i]) cout<<ans[i]<<"\n";
	return 0;
}
```

---

## 作者：冷却心 (赞：1)

本文记树大小为 $n$，操作序列 $A$ 长度为 $m$，询问 $q$ 个。给两个做法，前者较劣。

首先换根是假的，你考虑求出 $s_i$ 表示以 $1$ 为根的时候 $i$ 子树和，设当前根是 $r$，求 $u$ 子树和，如果以 $1$ 为根时 $r$ 不在 $u$ 子树内，那么答案等于 $s_u$，否则设 $r$ 在 $u$ 的儿子 $v$ 子树内，答案等于 $s_1 - s_v$。所以我们只需要求出以 $1$ 为根的子树和即可。原问题也就是支持执行一个区间的操作以及求子树和。 

---

垃圾 $\mathcal O(n \sqrt{n}\log n)$ 做法，$n,m,q$ 同阶。

考虑对询问分块。那么每次子树和询问有两种贡献，一种是前面若干块中的操作的贡献，一种是块内操作的贡献。前者可以每次暴力跑树上差分做，时间复杂度 $\mathcal O((n+m)\sqrt{q})$；后者就形如求出执行操作 $A_l,\cdots,A_r$ 对 $\mathcal O(\sqrt{q})$ 个点的子树和的影响。这个考虑莫队，有 $\mathcal O(q)$ 个区间，每个区间附带 $\mathcal O(\sqrt{q})$ 次询问，如果修改直接树剖路径加子树和是根号外带双 $\log$，可以考虑以下方法 BIT 单 $\log$ 维护：

> 记 $d_u$ 表示深度。对于一次路径 $(u,v)$ 加 $x$，记路径端点的 LCA 为 $l$。对于子树的根 $r$：
>
> - 如果 $r$ 是 $l$ 及其祖先，那么贡献 $(d_u+d_v-2d_l+1)\cdot x$；
> - 如果 $r$ 在 $u$ 到 $l$ 的路径上，$v$ 同理。那么贡献是 $(d_u + 1 - d_r) \cdot x$，拆开来就是 $(d_u+1) \cdot x$ 和 $d_r \cdot x$；
> - 其他情况显然没贡献。
>
> 综上，我们要维护两个子树和，一个是直接的子树和，一个是子树的 $x$ 和，然后就是单点加子树和，树状数组单老哥做完。

这样就得到了一个根号老哥做法。容易注意到这个做法不用卡空间，但是卡常。

---

$\mathcal O(n \sqrt{n})$ 做法，$n,m,q$ 同阶。

先考虑对操作序列 $A$ 分块。那么每次操作 $1$ 有两种贡献，一种是散块一种是整块。整块可以提前预处理出 $f_{i,j}$ 表示执行第 $i$ 块内所有操作对 $j$ 子树的贡献，然后每次询问直接加，而散块就考虑上文做法中路径加子树和的部分，只不过把 BIT 换成分块得到 $\mathcal O(1)$ 修改，$\mathcal O(\sqrt{n})$ 查询。

这个做法由于 $f$ 数组空间带根号被爆了。所以考虑把整块的贡献离线了，对于每个块枚举每个询问计算贡献即可，这样就不用把每个块的 $f$ 都存下来了。

---

$\mathcal O(n \sqrt{n})$ 代码。[https://www.luogu.com.cn/paste/2ppk5j6t](https://www.luogu.com.cn/paste/2ppk5j6t)。

---


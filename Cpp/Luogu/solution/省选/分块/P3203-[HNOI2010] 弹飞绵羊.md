# [HNOI2010] 弹飞绵羊

## 题目描述

某天，Lostmonkey 发明了一种超级弹力装置，为了在他的绵羊朋友面前显摆，他邀请小绵羊一起玩个游戏。  

游戏一开始，Lostmonkey 在地上沿着一条直线摆上 $n$ 个装置，每个装置设定初始弹力系数 $k_i$，当绵羊达到第 $i$ 个装置时，它会往后弹 $k_i$ 步，达到第 $i+k_i$ 个装置，若不存在第 $i+k_i$ 个装置，则绵羊被弹飞。  

绵羊想知道当它从第 $i$ 个装置起步时，被弹几次后会被弹飞。为了使得游戏更有趣，Lostmonkey 可以修改某个弹力装置的弹力系数，任何时候弹力系数均为正整数。


## 说明/提示

【数据范围】   
对于 $20\%$ 的数据，$1 \le n,m \le 10^4$；   
对于 $100\%$ 的数据，$1\le n \le 2\times 10^5$，$1\le m \le 10^5$。


## 样例 #1

### 输入

```
4
1 2 1 1
3
1 1
2 1 1
1 1```

### 输出

```
2
3```

# 题解

## 作者：FlashHu (赞：84)

关于LCT的问题详见[我的LCT总结](http://www.cnblogs.com/flashhu/p/8324551.html)

## 思路分析


首先分析一下题意。


对于每个弹力装置，有且仅有一个位置可以弹到。把这样的一种关系可以视作边。


然后，每个装置一定会往后弹，这不就代表不存在环么？


于是，一个森林的模型被我们建出来了。


考虑到有修改弹力值的操作，也就是要断边和连边，于是用LCT维护。


### 思路一

每一个点向它弹到的位置连边。如果被弹飞了，那么这条边就不存在。


查询弹飞的步数，就是查询该点到其所属原树中根节点的路径的$size$。


注意此题的一些特性。我们并不需要查询或者更改指定路径$(x-y)$的信息。


也就是说，**我们根本不需要换根！**


原来需要换根的$split,link,cut$操作，我们可以根据题目特性适当调整一下。


- 查询原本需要$split$，我们直接$access(x),splay(x)$，输出$x$的$size$。

- 连边原本需要$link$，题目保证了是一棵树，我们直接改$x$的父亲，连轻边。

- 断边原本需要$cut$，然而我们确定其父亲的位置，$access(x),splay(x)$后，$x$的父亲一定在$x$的左子树中（LCT总结中的性质1），直接双向断开连接。


然后我们发现，程序一下子少了一堆函数（$pushdown,makeroot,findroot,split,link,cut$）


代码少，常数小，何乐而不为？


下面贴代码

```cpp
#include<cstdio>
#include<cstdlib>
#define R register int
#define I inline void
#define G ch=getchar()
#define gc G;while(ch<'-')G
#define in(z) gc;z=ch&15;G;while(ch>'-')z*=10,z+=ch&15,G;
const int N=200009;
int f[N],c[N][2],s[N];
inline bool nroot(R x){
    return c[f[x]][0]==x||c[f[x]][1]==x;
}
I pushup(R x){
    s[x]=s[c[x][0]]+s[c[x][1]]+1;
}
I rotate(R x){
    R y=f[x],z=f[y],k=c[y][1]==x,w=c[x][!k];
    if(nroot(y))c[z][c[z][1]==y]=x;c[x][!k]=y;c[y][k]=w;
    if(w)f[w]=y;f[y]=x;f[x]=z;
    pushup(y);
}
I splay(R x){
    R y,z;
    while(nroot(x)){
        y=f[x];z=f[y];
        if(nroot(y))
            rotate((c[y][0]==x)^(c[z][0]==y)?x:y);//fixed
        rotate(x);
    }
    pushup(x);
}
I access(R x){
    for(R y=0;x;x=f[y=x])
        splay(x),c[x][1]=y,pushup(x);
}//以上是轻量化的LCT板子
int main()
{
    register char ch;
    R n,m,j,k;
    in(n);
    for(j=1;j<=n;++j){
        s[j]=1;
        in(k);
        if(j+k<=n)f[j]=j+k;//如果弹飞了就不连边
    }
    in(m);
    while(m--){
        gc;
        if(ch&1){
            in(j);++j;
            access(j);splay(j);//直接查询
            printf("%d\n",s[j]);
        }
        else{
            in(j);in(k);++j;
            access(j);splay(j);
            c[j][0]=f[c[j][0]]=0;//直接断边
            if(j+k<=n)f[j]=j+k;//直接连边
            pushup(j);
        }
    }
    return 0;
}
```

### 思路2


把弹飞这种情况也可以视作一个节点（编号可定为$n+1$）

如果弹飞了就把$x$连到这个点上，于是这个点稳稳地坐住了树根的位置。


查询的时候得到的$size$减$1$即可。


其它同上。


其实个人认为这样不如上面。动态树本身就定义为维护森林，多了这一个点等于强行把它变成一棵树，可能有点多此一举。。。。。。


代码如下，只贴main函数，因为LCT板子是一样的。。。。。。


```cpp
int main()
{
    register char ch;
    R rt,n,m,j,k;
    in(n);rt=n+1;
    for(j=1;j<=rt;++j)s[j]=1;
    for(j=1;j<=n;++j){
        in(k);
        f[j]=j+k>n?rt:j+k;//与上面不同
    }
    in(m);
    while(m--){
        gc;
        if(ch&1){
            in(j);++j;
            access(j);splay(j);
            printf("%d\n",s[j]-1);
        }
        else{
            in(j);in(k);++j;
            access(j);splay(j);
            c[j][0]=f[c[j][0]]=0;
            f[j]=j+k>n?rt:j+k;
            pushup(j);
        }
    }
    return 0;
}
```

---

## 作者：i207M (赞：77)

## ~~没人看的~~题意

游戏一开始，Lostmonkey在地上沿着一条直线摆上n个装置，每个装置设定初始弹力系数ki，当绵羊达到第i个装置时，它会往后弹ki步，达到第i+ki个装置，若不存在第i+ki个装置，则绵羊被弹飞。绵羊想知道当它从第i个装置起步时，被弹几次后会被弹飞。为了使得游戏更有趣，Lostmonkey可以修改某个弹力装置的弹力系数，任何时候弹力系数均为正整数。

## 实现

~~LCT裸题但我不会~~

看到这个，一定是用什么数据结构的；但是没有现成的好的方法，怎么办？分块！

设$f[i]$表示从i开始，跳出所在块的步数；$to[i]$表示跳出所在块后到了哪里；

初始化很简单啦，具体看代码吧；

要修改？整个块内暴力重构；

## 代码

```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define inf 0x3f3f3f3f
#define ri register int
#define il inline
#define fi first
#define se second
#define mp make_pair
#define pi pair<int,int>
#define mem0(x) memset((x),0,sizeof(x))
#define mem1(x) memset((x),0x3f,sizeof(x))
#define pb push_back
#define gc getchar
template<class T>void in(T &x) {
    x = 0; bool f = 0; char c = gc();
    while (c < '0' || c > '9') {if (c == '-') f = 1; c = gc();}
    while ('0' <= c && c <= '9') {x = (x << 3) + (x << 1) + (c ^ 48); c = gc();}
    if (f) x = -x;
}
#undef gc
#define N 200010
int k[N];
int block;
int bl[N];
int l[N >> 1];
int f[N], to[N];
int n, m;
il void replace(int p, int w) {
    k[p] = w;
    for (ri i = l[bl[p] + 1] - 1; i >= l[bl[p]]; --i) {
        if (i + k[i] >= l[bl[i] + 1]) {
            f[i] = 1;
            to[i] = i + k[i];
        }
        else {
            f[i] = f[i + k[i]] + 1;
            to[i] = to[i + k[i]];
        }
    }
}
il int query(int p) {
    int ret = 0;
    while (p <= n) {
        ret += f[p];
        p = to[p];
    }
    return ret;
}
signed main() {
    in(n);
    block = sqrt(n);
    for (ri i = 1; i <= n; ++i) {
        in(k[i]);
        bl[i] = (i - 1) / block + 1;
        if (bl[i] != bl[i - 1]) l[bl[i]] = i;
    }
    l[bl[n] + 1] = n + 1;
    //prework
    for (ri i = n; i >= 1; --i) {
        if (i + k[i] >= l[bl[i] + 1]) {
            f[i] = 1;
            to[i] = i + k[i];
        }
        else {
            f[i] = f[i + k[i]] + 1;
            to[i] = to[i + k[i]];
        }
    }
    in(m);
    int op, p, w;
    while (m--) {
        in(op), in(p);
        if (op == 1) {
            printf("%d\n", query(p + 1));
        }
        else {
            in(w);
            replace(p + 1, w);
        }
    }
    return 0;
}

```

---

## 作者：xyz32768 (赞：60)

$LCT$裸题。

首先，建立一个虚拟节点$n+1$，绵羊到达这个节点即被弹飞。

对于每个装置，

如果$i+Ki<=n$，则执行$Link(i,i+Ki)$，否则$Link(i,n+1)$。

对于修改操作，先执行$Cut(j,j+Kj)$（如果$j+Kj>n$则为$n+1$），再执行$Link(j,j+k)$（如果$j+k>n$则为$n+1$），

并把$Kj$赋为$k$。

对于询问操作，分别执行$MakeRoot(y)$，$Access(n+1)$和$Splay(n+1)$，最终答案即为$size[n+1]-1$。

其中$size[i]$表示**平衡树**中节点$i$的子树的大小。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 2e5 + 5;
int n, m, fa[N], lc[N], rc[N], rev[N], que[N], len, sze[N], val[N];
int which(int x) {return rc[fa[x]] == x;}
bool is_root(int x) {
    return !fa[x] || (lc[fa[x]] != x && rc[fa[x]] != x);
}
void down(int x) {
    if (rev[x]) {
        swap(lc[x], rc[x]);
        if (lc[x]) rev[lc[x]] ^= 1;
        if (rc[x]) rev[rc[x]] ^= 1;
        rev[x] = 0;
    }
}
void upt(int x) {
    sze[x] = 1;
    if (lc[x]) sze[x] += sze[lc[x]];
    if (rc[x]) sze[x] += sze[rc[x]];
}
void rotate(int x) {
    int y = fa[x], z = fa[y], b = lc[y] == x ? rc[x] : lc[x];
    if (z && !is_root(y)) (lc[z] == y ? lc[z] : rc[z]) = x;
    fa[x] = z; fa[y] = x; b ? fa[b] = y : 0;
    if (x == lc[y]) rc[x] = y, lc[y] = b;
    else lc[x] = y, rc[y] = b; upt(y); upt(x);
}
void splay(int x) {
    int i, y; que[len = 1] = x;
    for (y = x; !is_root(y); y = fa[y]) que[++len] = fa[y];
    for (i = len; i >= 1; i--) down(que[i]);
    while (!is_root(x)) {
        if (!is_root(fa[x])) {
            if (which(x) == which(fa[x])) rotate(fa[x]);
            else rotate(x);
        }
        rotate(x);
    }
    upt(x);
}
void Access(int x) {
    int y;
    for (y = 0; x; y = x, x = fa[x]) {
        splay(x); rc[x] = y;
        if (y) fa[y] = x; upt(x);
    }
}
int Find_Root(int x) {
    Access(x); splay(x);
    while (down(x), lc[x]) x = lc[x];
    splay(x); return x;
}
void Make_Root(int x) {
    Access(x); splay(x);
    rev[x] ^= 1;
}
void Link(int x, int y) {
    Make_Root(x); fa[x] = y;
}
void Cut(int x, int y) {
    Make_Root(x); Access(y); splay(y);
    lc[y] = 0; fa[x] = 0; upt(y);
}
int Select(int x, int y) {
    Make_Root(x); Access(y); splay(y);
    return sze[y];
}
int main() {
    int i, x, y, z; n = read();
    for (i = 1; i <= n + 1; i++) sze[i] = 1;
    for (i = 1; i <= n; i++) {
        x = val[i] = read();
        if (i + x <= n) Link(i, i + x);
        else Link(i, n + 1);
    }
    m = read(); while (m--) {
        x = read();
        if (x == 2) {
            y = read() + 1; z = read();
            Cut(y, y + val[y] <= n ? y + val[y] : n + 1);
            Link(y, y + z <= n ? y + z : n + 1);
            val[y] = z;
        }
        else {
            y = read() + 1;
            printf("%d\n", Select(y, n + 1) - 1);
        }
    }
    return 0;
}
```

---

## 作者：UnyieldingTrilobite (赞：43)

Update:3.25添加Java代码。

Update:5.7修复部分排版。

咦？题解区全是LCT，但我不会啊啊啊。

观察一下 $\operatorname{O}(m\sqrt{n})$ 的分块也是能过的，这里就讲一下分块解法。

和第一篇题解差不多，但自认为变量名什么的更加清晰，并且补充了思路分析。

先来讲一下思路：

相当于维护一棵树，支持断边+加边，和查询一个点的深度。

先来考虑一下，要是没有断边+加边操作，你会怎么做？

相信大家都能想到（想不到的么······谔谔罢），**预dfs（这里由于数据特殊性可以直接改成DP）一遍求出每个点深度**，查询直接输出。

要是断边+加边极少呢？

也很好办！每次改的时候全部暴力重构就是了，**由于保证了断边+加边很少所以重构次数很少**，可以接受。

再想想，要是查询没有呢？

······主程序直接一行return 0;

~~谔谔~~。

加强一点，要是只有很少的查询呢？

**只维护弹力系数，每次查询暴力爬树**<-挺形象。

现在，我们已经有两种暴力想法了，接着就是一个~~著名~~等式：

$$\Huge{\text{暴力+暴力=分块}}$$

没错！就是分块来调节这两个暴力。

$\sqrt n$ 只羊分成一个块。

接下来就很简单了，把一堆东西扔到块上去维护：

这只羊（被弹出原位后）下一个到达的是哪一个位置->这只羊被弹出原块后下一个到达的是哪个位置。

这只羊弹出自己原位需要几步（当然是1）->这只羊弹出自己原块需要几步。

结合两个暴力，先预处理出这两个数组，每次断边+加边块内暴力重构，查询深度一块一块跳即可。

复杂度 $\operatorname{O}(m\sqrt{n})$ ，能过。

C++代码：
```cpp
#include<bits/stdc++.h>
class process{//我们的程序
    private:
		int read(){
			char c=getchar();
			while(!isdigit(c))c=getchar();
			int x=c^48;
			while(isdigit(c=getchar()))x=x*10+(c^48);
			return x;
		}//快读
        class block{//分块
        	private:
        		int*fa,*out,*bel,*num;
			//弹力系数，块意义父亲，每个点所属块的编号，块意义边权
        		int*beg,*ed;//每个块的开始位置与结束位置
        		int tot;//序列长度
        		void range_rebuild(int l,int r){//区间重构
        			for(int i=r;i>=l;--i){//倒着来（想想为什么？）
        				if(i+fa[i]>tot||bel[i+fa[i]]!=bel[i])num[i]=1,out[i]=i+fa[i];
        				else num[i]=num[i+fa[i]]+1,out[i]=out[i+fa[i]];			
        			}//分类，弹一次出不出块
        		}
        	public:
        		block(int n,int*f){//构造函数，相当于预处理
        			int cnt=sqrt(tot=n);//块数
        			fa=new int[n+9],
				out=new int[n+9],
				bel=new int[n+9],
				num=new int[n+9],
				beg=new int[cnt+9],
				ed=new int[cnt+9];//申请空间
        			bel[0]=0;
        			memcpy(fa+1,f+1,n<<2);//复制数组
        			for(int i=1;i<=n;++i)bel[i]=i/cnt+1,(bel[i]!=bel[i-1])&&(ed[bel[i-1]]=i-1,beg[bel[i]]=i);
                    		//处理每个块的开始与结束，和每个位置的块编号
        			ed[bel[n]]=n;//最后一块！
        			range_rebuild(1,n);//说是重构其实就是构建
        		}
        		~block(){
        			delete[]fa,delete[]out,delete[]bel,delete[]num;
        			delete[]beg,delete[]ed;
        		}//唔，不要忘了内存释放
        		void update(int pos,int val){//断边+加边
        			fa[pos]=val;//弹力系数
        			range_rebuild(beg[bel[pos]],ed[bel[pos]]);//块内重构
        		}
        		int calcdepth(int pos){
        			int ret=0;
        			while(pos<=tot)ret+=num[pos],pos=out[pos];
				//一块一块跳，相当于块意义下“爬树”
        			return ret;
        		}
        }*Block;
	public:
		process(){//还是预处理
			int n=read(),*f=new int[n+9];
			for(int i=1;i<=n;++i)f[i]=read();//输入
			Block=new block(n,f);//分块
			delete f;
		}
		~process(){
			fclose(stdin);
			fclose(stdout);
            delete[]Block;
		}
		void main(){
			for(int m=read();m;--m){//处理操作
				int u=read(),v=read()+1;//注意由于这里题目是0到n-1，代码里是1到n所以要+1
				if(u==1)printf("%d\n",Block->calcdepth(v));//深度
				else Block->update(v,read());//断边+加边
			}
		}
}Process;
int main(){
	Process.main();
	return 0;
}
```
Java代码：
```java
import java.io.*;
final class block{
    private int fa[],out[],bel[],num[],beg[],ed[],tot;
    private void range_rebuild(int l,int r){
      for(int i=r;i>=l;--i){
        if(i+fa[i]>tot||bel[i+fa[i]]!=bel[i]){
          num[i]=1;
          out[i]=i+fa[i];
        }
        else{
          num[i]=num[i+fa[i]]+1;
          out[i]=out[i+fa[i]];		 
        }
      }
    }
    public void update(int pos,int val){
      fa[pos]=val;
      range_rebuild(beg[bel[pos]],ed[bel[pos]]);
    }
    public int calcdepth(int pos){
      int ret=0;
      while(pos<=tot){
        ret+=num[pos];
        pos=out[pos];
      }
      return ret;
    }
    block(int n,StreamTokenizer cin)throws IOException{
      int cnt=(int)Math.sqrt(tot=n);
      fa=new int[n+9];
      out=new int[n+9];
      bel=new int[n+9];
      num=new int[n+9];
      beg=new int[cnt+9];
      ed=new int[cnt+9];
      bel[0]=0;
      for(int i=1;i<=n;++i){
        cin.nextToken();
        fa[i]=(int)cin.nval;
        bel[i]=i/cnt+1;
        if(bel[i]!=bel[i-1]){
          ed[bel[i-1]]=i-1;
          beg[bel[i]]=i;
        }
      }
      ed[bel[n]]=n;
      range_rebuild(1,n);
    }
}
final class Process{
   private block Block;
   private static StreamTokenizer cin;
   private static PrintWriter pw;
   private static int nextInt()throws IOException{
    cin.nextToken();
    return (int)cin.nval;
   }
   public void main()throws IOException{
    for(int m=nextInt();m>0;--m){
      int u=nextInt(),v=nextInt()+1;
      if(u==1){
       pw.print(Block.calcdepth(v));
       pw.print('\n');
      }
      else Block.update(v,nextInt());
    }
    pw.close();
   }
   Process()throws IOException{
      cin=new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
      pw=new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
      Block=new block(nextInt(),cin);
   }
}
public class Main{
   public static void main(String args[])throws IOException{
      (new Process()).main();
   }
}
```
啊~终于完了。

有什么问题欢迎私信。

~~写的这么辛苦，顺手留个赞呗~~

Over.

---

## 作者：Treaker (赞：38)

我也曾想透彻LCT,但无奈太菜。

但这个题可以用分块做，我们对于每一个位置，我们维护一下从这个点跳几次跳出这个块，和跳出这个块后在哪个位置。

显然我们需要从后往前维护。
修改时也是在块内从后往前。

时间复杂度就是$O(n\sqrt{n})$ 很显然
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
int n , m , len , top , opt , x , y;
int k[200200] , f[200200] , g[200200] , l[200200] , r[200200] , pos[200200]; // f数组表示跳几次跳出块 ， g数组表示第一次跳出块的位置在哪 
int main()
{
	scanf("%d",&n);
	len = sqrt(n);
	for(int i = 0;i < n;i ++)	scanf("%d",&k[i]) , pos[i] = i / len + 1 , l[pos[i]] = 2147483647;
	for(int i = 0;i < n;i ++)	l[pos[i]] = min(l[pos[i]],i) , r[pos[i]] = max(r[pos[i]],i) , top = max(pos[i],top);
	for(int i = n - 1;i >= 0;i --)
	{
		if(i + k[i] > r[pos[i]])	
		{
			f[i] = 1;
			g[i] = i + k[i];
		}
		else
		{
			f[i] = f[i+k[i]] + 1;
			g[i] = g[i+k[i]];
		}
	}
	//for(int i = 0;i < n;i ++)	printf("f[%d] = %d , g[%d] = %d\n",i,f[i],i,g[i]);
	scanf("%d",&m);
	while(m --> 0)
	{
		scanf("%d%d",&opt,&x);
		if(opt == 1)
		{
			int res = 0;
			while(g[x] < n)
			{
				res += f[x];
				x = g[x];
			}
			res += f[x];
			printf("%d\n",res);
		}
		else
		{
			scanf("%d",&y);
			k[x] = y;
			for(int i = r[pos[x]];i >= l[pos[x]];i --)
			{
				if(i + k[i] > r[pos[i]])
				{
					f[i] = 1;
					g[i] = i + k[i];
				}
				else
				{
					f[i] = f[i+k[i]] + 1;
					g[i] = g[i+k[i]];
				}
			}
		}
	}
	//for(int i = 0;i < n;i ++)	printf("f[%d] = %d , g[%d] = %d\n",i,f[i],i,g[i]);
	return 0;
}
```


---

## 作者：MaxDYF (赞：22)

一道简单分块题。

对整个数组进行分块，块的大小取$sqrt(N)$，分块之后维护两个数组```jump[]```和```step[]```，分别表示跳出当前块**所到达的位置**与所用的步数，这两个操作都可以在线性时间内完成。

然后更改时~~暴力~~更改，由于只有单点修改，```jump[]```与```step[]```只和块内的元素有关，所以可以在$O(sqrt(N))$的时间内完成。

查询时直接整块整块跳，最多有$O(sqrt(N))$块，所以也是$O(sqrt(N))$的时间。

### Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int lnk[1000000];  //原数组在块内的编号
struct node {
    int l, r;
} a[1000000];       // 保存每一个块的区间
int num[1000000];   // num[x]表示从x往后跳一步到达的位置
int jump[1000000];  // jump[x]表示在x时跳出当前块到达的位置
int step[1000000];  // step[x]表示跳出当前块所用步数
void update(int l, int r) {
    //更新当前块的jump与step值
    for (int i = r; i >= l; i--) {
        //倒序循环，用i+num[i]的值更新i
        if (i + num[i] > a[lnk[i]].r) {
            //如果一次就跳出当前块，直接更新
            jump[i] = i + num[i];
            step[i] = 1;
        } else {
            //否则继承同一块中的下一个跳到的元素
            jump[i] = jump[i + num[i]];
            step[i] = step[i + num[i]] + 1;
        }
    }
}
int block;  //每块大小
int n;
void init() {
    //分块初始化
    block = sqrt(n);
    for (int i = 0; i < n; i++)
        lnk[i] = i / block;
    for (int i = 0; i <= lnk[n - 1]; i++) {
        a[i].l = i * block;
        a[i].r = (i + 1) * block - 1;
    }
    a[lnk[n - 1]].r = n - 1;
    update(0, n - 1);  //一次更新整个序列的jump[]与step[]值
}
int ask(int x) {
    //询问弹出序列需要多少步
    int ans = 0;
    while (x < n) {
        ans += step[x];
        x = jump[x];
    }
    return ans;
}
int main() {
    ios::sync_with_stdio(NULL);
    cin.tie(NULL);
    // 输入优化，同步IO缓存并绑定cin与cout流
    cin >> n;
    for (int i = 0; i < n; i++)
        cin >> num[i];
    init();
    int q;
    cin >> q;
    while (q --> 0) {
        // q趋近于0 (滑稽)
        static int opt, x, y;
        cin >> opt >> x;
        if (opt == 1) {
            cout << ask(x) << '\n';
        } else {
            cin >> y;
            num[x] = y;
            update(a[lnk[x]].l, a[lnk[x]].r);
        }
    }
}

```


---

## 作者：樱初音斗橡皮 (赞：14)

一道对初学`LCT`者来说比较有思维难度的题。

题解里的开一个点表示弹飞的做法蒟蒻只能表示想不到`qaq`，在没看题解的情况下想出了这样的做法：

首先我们可以让每个点弹到的点作为它的父亲，如果弹飞那么就是根。容易发现我们需要维护一个森林。询问操作就是求这个点的深度，而修改操作就是把一个点断开和父亲的连接，接到一个新的点上。说白了就是**可以修改父亲的动态深度询问**。

那么，看到动态维护森林，便可以想到`LCT`。问题是要求深度，那么我们有了一个很令人讨厌的限制条件：**不能换根**。这样，我们就不得不用剩下来的几种操作~~和人类的智慧~~来完成这道题。

~~外接表示弹飞的点的做法：渣渣，我就可以换根！~~

## 0. 建树

要是所有点都`link`到它的`father`，且不说带一个`log`，不能换根`link`操作也用不了啊。这里有一个好方法：所有边默认初始虚边，直接连就完事。

建树部分代码：
```
for (int i=1; i<=n; ++i)
{
    int tmp;
    scanf("%d", &tmp);
    fa[i]=(i+tmp>n)?0:(i+tmp);
    // 要是弹飞father就是0（即是树根）
}
```

## 1. 查询操作

这个操作相对简单。LCT的实链剖分有一个好处：可以直接用`access`操作打通到根节点的路径。比如说，我们的原树长这样：
```
      2
     / \
    1   5
   / \
  3   4
       \
        6
```
（假设一开始全是虚边）

然后假如我们要查询节点4的路径，我们先`access`一下4号点，树变成这样：
```
       2
     // \
    1   5
   / \\
  3   4
       \
        6
```
（双杠表示实边，单杠表示虚边）

此时根所在的`splay`的元素一定是根到查询的点这条链，因此要查询点的`rank`即是它的深度。把要查询的点`splay`到根，那么它的左子树的大小就是它的祖先个数（而且它一定没有右子树）。把左子树的`size`加一，即可得到要查询的点的`rank`，也就是它的深度。

为了便于理解，这时的辅助树长这样：
```
      4
    // \
   1    6
 // \
2    3
|
5
```
可以看到查询的点（4）所有的祖先都在左子树。如果仍有疑虑，可以加一句`assert(son[i][1]==0);`来验证。

查询操作代码：
```
int query(int i)
{
    access(i);
    splay(i);
    assert(son[i][1]==0);
    return son[i][0]?siz[son[i][0]]+1:1;
    // 要额外判目前的点已经是根节点的情况，因为0号节点可能有垃圾数值
}
```

## 2. 修改操作

这是比较困难的一个操作。

看到断/连，想到的第一个就是`cut`和`link`。然而先不说常数，不能换根这一点，就让`cut`和`link`成为了不可能。那么，怎么做呢？

要断开查询节点（称为`i`）和它在原树中的父亲，我们首先要找到它在原树中的父亲。容易想到，首先要让它和父亲在一棵`splay`里面。所以，先要`access(i)`。然后，我们可以知道，由于`i`和`i`的父亲在原树中深度连续，`i`的父亲在`splay`中一定是`i`的前驱。查找前驱是比较基础的`splay`操作（当然不是普通的二叉搜索树那种从根节点查找前驱的操作），可以先`splay(i)`，然后从`i`的左儿子一直往右儿子找，直到不存在右儿子为止。找父亲部分代码：
```
access(i);
splay(i);
// 找父亲
int ifa=son[i][0];
while (son[ifa][1]) ifa=son[ifa][1];
```
找到父亲之后，为了断边，我们要让`i`号节点和`ifa`节点之间存在直接相连的边。因此，先`splay(ifa)`，然后，由于`ifa`和`i`深度连续，`ifa`的右儿子一定是`i`，而且`i`不存在左儿子（其实也不存在右儿子，因为我们`access`过`i`）。直接断边，把`i`连到新父亲即可。修改操作代码：
```
void modify(int i, int j) // 修改，j是新的父亲
{
    access(i);
    splay(i);
    // find father
    int ifa=son[i][0];
    while (son[ifa][1]) ifa=son[ifa][1];
    splay(ifa);
    assert(ifa==fa[i]);
    son[ifa][1]=0;
    push_up(ifa);
    fa[i]=j;
    return;
}
```
但是，且慢！如果你用这份代码提交，你将会得到两个`TLE`（而且是小数据的）。这倒不是常数的原因，而是因为，如果`i`已经是根，那么`ifa`就是`0`，然后我们就会进入`splay(0)`死循环！解决的方法是加一个`ifa`是否为`0`的判断。正确的修改操作代码：
```
void modify(int i, int j) // 修改，j是新的父亲
{
    access(i);
    splay(i);
    // find father
    int ifa=son[i][0];
    if (ifa)
    {
        while (son[ifa][1]) ifa=son[ifa][1];
        splay(ifa);
        assert(ifa==fa[i]);
        son[ifa][1]=0;
        push_up(ifa);
    }
    fa[i]=j;
    return;
}
```
---
好啦，操作都讲完啦`qwq`，接下来就是完整的AC代码了。顺带提一句，这份代码只有`130+`行（含空行），比普通`LCT`码量小了很多，而且常数出奇地小，不加任何刻意卡常，吸一口氧，总时间`580+ms`，在洛谷居然排在前`5`页（前几页有大量的巨佬反复提交），可谓是相当令人惊喜了`qwq`。

完整AC code:
```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <assert.h>

// by luogu @樱初音斗橡皮

const int N=200000;
const int M=100000;

int n, m;

int fa[N+10], son[N+10][2], siz[N+10];

inline bool nroot(int i) // 不是根
{
	return (son[fa[i]][0]==i)||(son[fa[i]][1]==i);
}

inline bool chk(int i) // 是右儿子
{
	return son[fa[i]][1]==i;
}

inline void push_up(int i) // 上传信息
{
	siz[i]=1;
	if (son[i][0])
		siz[i]+=siz[son[i][0]];
	if (son[i][1])
		siz[i]+=siz[son[i][1]];
	return;
}

inline void spin(int i) // 旋转
{
	int ifa=fa[i], igfa=fa[ifa], dir=chk(i),
		ison=son[i][dir^1], dirfa=chk(fa[i]), nrt=nroot(ifa);
	fa[ison]=ifa;
	son[ifa][dir]=ison;
	fa[ifa]=i;
	son[i][dir^1]=ifa;
	fa[i]=igfa;
	if (nrt)
		son[igfa][dirfa]=i;
	push_up(ifa);
	push_up(i);
	return;
}

void splay(int i) // splay
{
	int ifa=fa[i];
	while (nroot(i))
	{
		if (nroot(ifa))
		{
			if (chk(i)==chk(ifa))
				spin(ifa);
			else
				spin(i);
		}
		spin(i);
		ifa=fa[i];
	}
	return;
}

void access(int i) // access
{
	int j=0;
	while (i)
		splay(i), son[i][1]=j, push_up(i), j=i, i=fa[i];
	return;
}

int query(int i) // 查询
{
	access(i);
	splay(i);
	assert(son[i][1]==0);
	return son[i][0]?siz[son[i][0]]+1:1;
}

void modify(int i, int j) // 修改，j是新的父亲
{
	access(i);
	splay(i);
	// find father
	int ifa=son[i][0];
	if (ifa)
	{
		while (son[ifa][1]) ifa=son[ifa][1];
		splay(ifa);
		assert(ifa==fa[i]);
		son[ifa][1]=0;
		push_up(ifa);
	}
	fa[i]=j;
	return;
}

int main()
{
	scanf("%d", &n);
	for (int i=1; i<=n; ++i)
		fa[i]=0, son[i][0]=son[i][1]=0, siz[i]=1;
	for (int i=1; i<=n; ++i)
	{
		int tmp;
		scanf("%d", &tmp);
		fa[i]=(i+tmp>n)?0:(i+tmp);
	}
	scanf("%d", &m);
	for (int i=1; i<=m; ++i)
	{
		int cmd, j, k;
		scanf("%d%d", &cmd, &j);
		++j;
		// 题目中的编号为0~n-1，实际的编号要+1便于操作
		switch (cmd)
		{
		case 1:
			printf("%d\n", query(j));
			break;
		case 2:
			scanf("%d", &k);
			modify(j, (j+k>n)?0:(j+k));
			break;
		default:
			printf("stupid yyc\n"); // 滑稽
			// 防止数据出错
			break;
		}
	}
	return 0;
}
```

---

## 作者：HiJ1m (赞：11)

做法来自黄学长

不需要用link cut tree(我不会) ， 利用分块的思想， (自认为代码比楼底的那个好懂)

每块分 √N 个元素 ， 预处理出来一个块里的点可以跳到另一个块的什么位置

查询操作：一块一块跳过去 单次复杂度 O(√N)

修改操作：只需要把相应的块改一遍就好了 这个也是O(√N)

然后就可以过了

```cpp
#include<bits/stdc++.h>
#define MAXN 200001
void read(int& x)
{
    x=0;char c;c=getchar();
    while(c<'0'||c>'9')c=getchar();
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
}
int N,M,block,cnt,ans,a[MAXN],l[MAXN],r[MAXN],step[MAXN],to[MAXN],belong[MAXN];
int main()
{
    read(N);
    for(int i=1;i<=N;i++)read(a[i]);
//initiation
    block=( int)sqrt(N);
    cnt=(N%block)?N/block+1:N/block;
    for(int i=1;i<=cnt;i++)
        l[i]=r[i-1]+1,r[i]=l[i]+block-1;
    r[cnt]=N;
    for(int i=1,j=1;i<=cnt;j++)
    {
        belong[j]=i;
        if(j==r[i])i++;
    }
    for(int i=N;i>=1;i--)
    {
        to[i]=i+a[i];
        if(to[i]>r[belong[i]])step[i]=1;
        else step[i]=step[to[i]]+1,to[i]=to[to[i]];
    }
//operation
    read(M);
    while(M--)
    {
        int k,x,y;
        read(k);
        if(k==1)    //query
        {
            ans=0;read(x);x++;
            while(x<=N)ans+=step[x],x=to[x];
            printf("%d\n",ans);
        }
        else        //change
        {
            read(x);read(y);x++;
            a[x]=y;
            for(int i=r[belong[x]];i>=l[belong[x]];i--)
            {
                to[i]=i+a[i];
                if(to[i]>r[belong[i]])step[i]=1;
                else step[i]=step[to[i]]+1,to[i]=to[to[i]];
            }
        }
    }
    return 0;
}

```

---

## 作者：Mosher (赞：9)

初学分块，若有错误请见谅，并提醒下**谢谢**

### 想了一会儿，在上厕所时，通了！

~~扯淡结束~~

**正文：**

1.  思考历程：

	一来觉得要靠某种高级数据结构算法乱搞（~~结果：十年以后，不知道，GG~~）
	
    后面又感觉分块处理会很方便，于是开始尝试。
    
    算法确定下来。
    
2.	遇见的障碍：
	
    先考虑朴素做法：
	```cpp
	while(x<=n){
		ans++;
		x=x+a[x];
	}
	``` 
  	那么很明显在划分好块后，想办法将以上做法**加速**。
    
    既然如此，就将**点**放大到**块**来看，由这个块跳跃到他后面的块。
    
    不难看出：
    
    统计这个块中，从当前位置跳出当前块的**步数**以及**跳出后的位置（PS：不是之后的哪个块）**
    
3. **代码：（具体实现写了注释）**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e5+5;
int n,m,ans,a[maxn],pos[maxn],cnt[maxn],tot,len,to[maxn],L[450],R[450];

void init(){
	len=tot=sqrt(n);//由于懒，为算具体应该为多少，直接附为根号n
	for(int i=1;i<=tot;++i){//每个块左右端点维护
		L[i]=(i-1)*len+1;
		R[i]=i*len;
	}
	if(R[tot]<n) tot++,L[tot]=R[tot-1]+1,R[tot]=n;//块是否统计完整？
	for(int i=1;i<=tot;++i)
		for(int j=R[i];j>=L[i];--j){//倒叙枚举，提前维护出信息
			pos[j]=i;//记录每个位置所对应的块
			if(a[j]+j>R[i])//直接跳出
				cnt[j]=1,to[j]=j+a[j];//步数=1，下个位置累加
			else//若不能
				cnt[j]+=cnt[j+a[j]]+1,to[j]=to[j+a[j]];//由之后位置转移而来，思想同上
		}
}

void query(int x){
	ans=0;
	while(x<=n){//未跳出，一直累加
		ans+=cnt[x];
		x=to[x];
	}
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%d",&a[i]);
	init();//预处理
	scanf("%d",&m);
	while(m--){
		int op,x,y;
		scanf("%d%d",&op,&x);
     	x++;//之前存的是：1~n
		if(op==1){
			query(x);
			printf("%d\n",ans);
		}
		else{//暴力更新，重新维护，与预处理一致
			scanf("%d",&y);
			a[x]=y;
			int now=pos[x];
			for(int i=R[now];i>=L[now];--i) to[i]=cnt[i]=0;//这里直接清掉，防止cnt累加出错
			for(int i=R[now];i>=L[now];--i){
				if(a[i]+i>R[now])
					cnt[i]=1,to[i]=i+a[i];
				else
					cnt[i]+=cnt[i+a[i]]+1,to[i]=to[i+a[i]];
			}
		}
	}
	return 0; 
}
```

rp++

---

## 作者：Law_Aias (赞：6)

# LCT的板子题
我看到楼下很多大佬用分块的方法解决了这道题，但是本蒟蒻不会分块，但我会LCT啊，所以就用LCT解决了这道题。
## 神奇的思路
对于每一个节点 维护他的size，每一个弹射器 由它即将到达的弹射器向他连边

虚拟一个n+1号节点 进行最后一次弹射，
每次直接查询对应位置的size即可。
### 也就是
把给出的数据当做森林，即i的父亲是i+k[i]，询问的是到根的路径长度+1，可以修改父亲。所以只需要link操作即可，注意把超过n的节点设为0。每次询问先access，然后Splay到根（Splay中要维护size），这样所询问的答案就是节点在Splay上的左子树大小+1。

# CODE：
```
// luogu-judger-enable-o2
#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<algorithm>

using namespace std;

const int maxn = 200010;

inline int read(){
	int x = 0;
	int flag = true;
	int k = getchar();
	while(k != '-' && !isdigit(k))
	    k = getchar();
	if(k == '-'){
	   k = getchar();
	   flag = false;
	}
	while(isdigit(k)){
		x = x * 10 + k - '0';
		k = getchar();
	}
	return (flag ? x : -x);
}

struct node{
	int father;
	int ch[2];
	int size;
	bool is_root;
}tree[maxn];

int n,m,k[maxn];

void update(int x){
	tree[x].size=1;
	if(tree[x].ch[0]) tree[x].size += tree[tree[x].ch[0]].size;
	if(tree[x].ch[1]) tree[x].size += tree[tree[x].ch[1]].size;
}
inline int getson(int x){
	return x == tree[tree[x].father].ch[1];
}
void rotate(int x){
	if(tree[x].is_root) return;
	int k = getson(x),fa = tree[x].father;
	int fafa = tree[fa].father;
	tree[fa].ch[k] = tree[x].ch[k^1];
	if(tree[x].ch[k^1])
		tree[tree[x].ch[k^1]].father = fa;
	tree[x].ch[k^1] = fa;
	tree[fa].father = x;
	tree[x].father = fafa;
	if(!tree[fa].is_root)
		tree[fafa].ch[fa == tree[fafa].ch[1]] = x;
	else {
		tree[x].is_root = true;
		tree[fa].is_root = false;
	}
	update(fa);
	update(x);
}
void Splay(int x){
	for(int y ; !tree[x].is_root;rotate(x)){
		if(!tree[y = tree[x].father].is_root){
			rotate((getson(x) == getson(y)) ? y : x);
		}
	}
}
void access(int x){
	int y = 0;
	while(x){
		Splay(x);
		tree[tree[x].ch[1]].is_root = true;
		tree[tree[x].ch[1] = y].is_root = false;
		update(x);
		x = tree[y = x].father;
	}
}
void link(int u,int v){
	if(v > n) v = 0;
	access(u);
	Splay(u);
	tree[tree[u].ch[0]].is_root = true;
	tree[tree[u].ch[0]].father = 0;
	tree[u].ch[0] = 0;
	tree[u].father = v;
	update(u);
}
int Query(int x){
	access(x);
	Splay(x);
	return tree[tree[x].ch[0]].size + 1;
}

int main(){
	n = read();
	for(int i = 1 ; i <= n ; i++){
		tree[i].is_root = 1;
		tree[i].size = 1;
		tree[i].father = 0;
		tree[i].ch[0] = 0;
		tree[i].ch[1] = 0;
	}
	for(int i = 1 ; i <= n ; i++){
		k[i] = read();
		link(i,i + k[i]);
	}
	m = read();
	int xx,x,y;
	while(m--){
		xx = read();
		x = read();
		if(xx == 1)
			printf("%d\n",Query(x+1));
		else if(xx == 2){
			y = read();
			link(x + 1,x + y + 1);
		}
	}
	return 0;
}
```

另外，LCT的时间复杂度是O(logN^2)，所以不开氧气优化也能过。  
蒟蒻的耗时为652ms。


---

## 作者：于丰林 (赞：4)

关于这道题，如果不是因为lbg大佬帮我dbug，我可能就真的惨死在这道题上了。。。（十分感谢）

好了，不废话了，进入正题。

这道题的正解LCT我并没有学过，所以我也只能用万恶的分块（骗分利器）了。。。

思路其实很简单，我们将整个序列分成若干个块（块的大小取决于数据，但是我们一般都会默认为√n），对于每一块的每一个点我们只要维护他弹出这个块还需几步和弹出之后会到达哪一个点即可。

关于修改，由于每一个块之间都是相互独立的，所以单点修改只需要维护每一个块就可以了，并且由于每一个点的数据都建立在他后面块的基础上，所以我们对于每一个块都需要倒着来进行维护。

而对于查询我们只要循着每一个点的指向，累加每一个点的sum值，大于n的时候跳出即可。

PS：由于装置是从零开始计数的所以读入数据时不要忘了加一！！！

最后，附上本题代码：（码风较丑，勿喷、、、）

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
struct pot
{
    int to,k,conti,sum;
}p[200005];
int size,cnt=1,n;
void change(int ct)
{
    //printf("%d\n",size);
    for(int j=min(ct*size,n);j>(ct-1)*size;j--)
    {
        if(j + p[j].k > ct * size || j + p[j].k > n) p[j].sum = 1,p[j].to = j + p[j].k;
        else
        {
            p[j].to=p[j+p[j].k].to;
            p[j].sum=p[j+p[j].k].sum + 1;
        }
        //printf("%d\n",p[j].to);
    }
}
int query(int y)
{
    int ans=0;
    while(y<=n)
    {
        ans+=p[y].sum;
        //printf("%d\n",ans);
        y=p[y].to;
    }
    return ans;
}
int main()
{
    int temp = 0;
    scanf("%d",&n);
    size=sqrt(n);
    for(int i=1;i<=n;i++)
    {
        temp++;
        if(temp>size)
        {
            cnt++;
            temp=1;
        }
        scanf("%d",&p[i].k);
        p[i].conti=cnt;
    }
    //if(temp != 0) cnt++;
    //printf("%d\n",cnt);
    for(int i=cnt;i >= 1;i--)
        change(i);
    int m;
    scanf("%d",&m);
    for(int i=1;i<=m;i++)
    {
        int x,y,z;
        scanf("%d%d",&x,&y);
        if(x==1)
            printf("%d\n",query(y+1));
        else
        {
            scanf("%d",&z);
            p[y+1].k=z;
            //printf("%d\n",p[y].k); 
            change(p[y+1].conti);
        }
    }
    return 0;
}
```

---

## 作者：_ZML_ (赞：3)

# 思路

`LCT` 太难了，我不会。分块固然可以，可是时间复杂度不优秀。这道题只用 splay 也可以做。

首先可以发现一个 $O(n^2)$ 的思路。对每个点对它弹到的位置连边，大于 $n$ 就都连 $n+1$，形成一棵树，根节点是 $n+1$ 号点。答案就是点在树中的深度。

要通过这道题还需要进行优化，先给大家科普一个算深度的方法。

先算出一棵树的括号序，也就是进行一遍深搜，进入时为左括号，退出时为右括号。这样就能形成一个长度为 $2n$ 的括号序列。再把左括号设为 $1$，右括号设为 $-1$，每个点的深度就是这个点对应的左括号之前的前缀和减一。

比如说下面这棵树。

![树](https://cdn.luogu.com.cn/upload/image_hosting/3hqpsjbo.png)

5 号点对应的左括号的前缀和减一是 2。

这么做为什么是对的？

简单证明一下吧，可以发现假如一个子树走完了那么这一段左括号之和为零，所以一个点之前的左右括号中，只有根到它路径上的左括号没有被抵消。

回到本题，多出来一个修改操作。对于一个点 $x$，弹力系数修改成 $y$，也就是把 $x$ 和父亲的边断开，把其子树连到 $x + y$ 上，想想如何在括号序上操作？

$x$ 对应的子树在括号序上对应的就是一段区间。设它为 $[l，r]$，$x+y$ 对应的左括号是点 $p$ 那么把它移动到 p 后面就可以实现操作。

用 `Splay` 树维护括号的顺序。

我们可以在 `Splay` 树上先把 $[l，r]$ 这段区间断开，这涉及到 `Splay` 树的断树操作。

移动到 $p$ 后面可以把 $p$，和 $p$ 后面的位置 $q$ 旋到根，然后把 $[l，r]$ 插入到 $q$ 的左儿子。

查询操作可以把 $x$ 旋到根，然后查它左子树之和就行了。

具体的看代码吧。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 4e6 + 10;
int n;
int a[maxn];
int w[maxn], ch[maxn][2], sze[maxn], fa[maxn];
int sum[maxn];
int L[maxn], R[maxn]; 
vector<int> edge[maxn];
int s[maxn * 2], tot;
int cnt, rt;
void dfs(int u) {
	s[++tot] = u * 1;
	for(auto v:edge[u]) dfs(v);
	s[++tot] = u * -1;
}
int get(int x) {
	return x == ch[fa[x]][1];
}
void update(int u) {
	sze[u] = sze[ch[u][0]] +sze[ch[u][1]] + 1;
	sum[u] = sum[ch[u][0]] + sum[ch[u][1]] + w[u];
}
void rotate(int x) {
    int y = fa[x], z = fa[y], d = get(x);
    ch[y][d] = ch[x][d ^ 1];
    if (ch[x][d ^ 1])
        fa[ch[x][d ^ 1]] = y;
    ch[x][d ^ 1] = y;
    if (z)
        ch[z][get(y)] = x;
    fa[y] = x;
    fa[x] = z;

    update(y), update(x);
}

void splay(int x, int y = 0) {
    if (y == 0)
        rt = x;
    while (fa[x] != y) {
        int f = fa[x], g = fa[f];
        if (g != y) {
            if (get(f) == get(x))
                rotate(f);
            else
                rotate(x);
        }
        rotate(x);
    }
}

void build() {
	cnt++;
	sze[cnt] = 1;
	ch[cnt][1] = cnt + 1;
	for(int i = 1; i <= tot; i++) {
		cnt++;
		sze[cnt] = 1;
		ch[cnt][1] = cnt + 1;
		fa[cnt] = cnt - 1;
		if(s[i] > 0) L[s[i]] = cnt, w[cnt] = 1;
		else R[abs(s[i])] = cnt, w[cnt] = -1;
	}
	cnt++;
	sze[cnt] = 1;
	fa[cnt] = cnt - 1;
	for(int i = cnt; i >= 1; i--) {
		update(i);
	}
	splay(cnt);
}
int getk(int k) {
	int cur = rt;
	while(1) {
		if(ch[cur][0] && k <= sze[ch[cur][0]]) cur = ch[cur][0];
		else {
			k -= (1 + sze[ch[cur][0]]);
			if(k <= 0) {
				splay(cur);
				return cur;
			}
			cur = ch[cur][1];
		}
	}
} 
int Rank(int x) {
	splay(x);
	return sze[ch[x][0]] + 1;
}
void Change(int x, int t){
	int p = getk(Rank(L[x]) - 1);
	int q = getk(Rank(R[x]) + 1);
//	cout << p << " " << q <<"\n";
	
	splay(p), splay(q, p);
	int tmp = ch[q][0];
	ch[q][0] = 0;
	update(q), update(p);
	p = L[t], q = getk(Rank(L[t]) + 1);
	splay(p), splay(q, p);
	fa[tmp] = q;
	ch[q][0] = tmp; 
	update(q), update(p); 
} 
int query(int x) {
	int y = L[x];
	splay(y);
	return sum[ch[y][0]];
}
int main() {
	cin.tie(0), cout.tie(0);
	ios::sync_with_stdio(0);
	cin >> n;
	for(int i = 1; i <= n; i++) {
		cin >> a[i];
		edge[min(n + 1, i + a[i])].push_back(i); 
	}
	dfs(n + 1);
	build();
	int T; cin >> T;
	while(T--) {
		int op, x, y;
		cin >> op >> x;
		x++;
		if(op == 1) {
			cout << query(x) <<"\n";
		}
		else {
			cin >> y;
			Change(x, min(n + 1, x + y));
		}
	}
	return 0;
}

```

---

## 作者：山水一程_ (赞：2)

# 暴力+lazy+底层优化(循环展开，消除分支)+读入优化+完美AC
```cpp
#include<cstdio>
#include<cctype>
using namespace std;
struct _Main {
	int read() { //读入优化
		char t;
		int ans;
		while(!isdigit(t=getchar()));
		ans=t-'0';
		while(isdigit(t=getchar())) {
			ans*=10;
			ans+=t-'0';
		}
		return ans;
	}

	int inline abs(int a) { //取消分支的绝对值
		return a>>31^((a>>31)+a);
	}
	int inline max (int a,int b) { //取消分支的最大值
		return (a+b+abs(a-b))>>1;
	}
	int inline min (int a,int b) { //取消分支的最小值
		return (a+b-abs(a-b))>>1;
	}
	int n,m;
	int k[200010];
	int t[200017];
	void fresh() {
		int i;
		goal++;
		for(i=lar; i>goal;) { //循环展开，只更新需要更新的
			if(i+k[i]>=n) {
				t[i]=1;
			} else {
				t[i]=1+t[i+k[i]];
			}
			i--;
			if(i+k[i]>=n) {
				t[i]=1;
			} else {
				t[i]=1+t[i+k[i]];
			}
			i--;
			if(i+k[i]>=n) {
				t[i]=1;
			} else {
				t[i]=1+t[i+k[i]];
			}
			i--;
		}
		goal--;
		for(; i>=goal; i--) { //收尾
			if(i+k[i]>=n) {
				t[i]=1;
			} else {
				t[i]=1+t[i+k[i]];
			}
		}
	}
	int goal;//需要更新的最小位置
	int lar;//需要更新的最大位置
	_Main() {
		int i,j,l;
		n=read();
		for(i=0; i<n; i++) {
			k[i]=read();
		}
		lar=n-1;
		goal=0;
		fresh();//不知道为什么一上来刷一遍比不刷要快
		lar=-1;
		m=read();
		for(i=0; i<m; i++) {
			l=read();
			j=read();
			if(l==1) {
				goal=j;//更新到需要查的位置即可
				fresh();
				lar=min(j-1,lar);
				printf("%d\n",t[j]);
			} else {
				k[j]=read();
				l=t[j];
				if(j+k[j]>=n) {
					t[j]=1;
				} else {
					t[j]=1+t[j+k[j]];
				}
				if(l!=t[j])//只有步数改变才更新最大值
					lar=max(lar,j-1);
			}
		}
	}
}nb;
int main() {}

```


---

## 作者：qwaszx (赞：2)

挺好的一道题.

题意大约是给一个森林(第$i$个装置弹力系数为$K_i$可以认为是从装置$i$向装置$i+K_i$连边)，然后支持改变某个装置的弹力系数，查询某个装置的深度.

查询某个装置的深度相当于问某个点到其所在树根这条链的大小，改变弹力系数就是断边再连边.

看了看，觉得板子直接套就好，于是写完四行头文件之后你眉头一皱~~看了题解~~，发现并不需要板子

因为这棵树的连边是具有方向性的!而一般的$LCT$维护的是无向的森林.

这样的话，我们连、断边的时候根本不需要考虑换根，只需要断边时$access\& splay$，然后双向断开左子树(这些都是深度比它小的点)，然后连边时向新的父亲连一条虚边；查询的时候也不需要把链拎出来，只需要$access\&splay$，然后直接输出该点$size$即可.

还是要配合对$LCT$的感性理解233

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define nroot(x) (ch[f[x]][0]==x||ch[f[x]][1]==x)
using namespace std;
const int N=5e5;
int ch[N][2],size[N],f[N],n,m;
void pushup(int x){size[x]=size[ch[x][0]]+size[ch[x][1]]+1;}
void rotate(int x)
{
	int y=f[x],z=f[y],wh=ch[y][1]==x,w=ch[x][wh^1];
	if(nroot(y))ch[z][ch[z][1]==y]=x;
	ch[x][wh^1]=y,ch[y][wh]=w;
	f[w]=y,f[y]=x,f[x]=z;pushup(y);
}
void splay(int x)
{
	while(nroot(x))
	{
		int y=f[x],z=f[y];
		if(nroot(y))rotate((ch[z][1]==y)^(ch[y][1]==x)?x:y);
		rotate(x);
	}
	pushup(x);
}
void link(int x,int y){f[x]=y;}
void access(int x){for(int y=0;x;x=f[y=x])splay(x),ch[x][1]=y,pushup(x);}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		int x;
		scanf("%d",&x);
		if(i+x<=n)link(i,i+x);//没弹飞才连边，下同
	}
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		int opt,x,y;
		scanf("%d%d",&opt,&x);x++;
		if(opt==1){access(x),splay(x),printf("%d\n",size[x]);}
		else{scanf("%d",&y),access(x),splay(x),ch[x][0]=f[ch[x][0]]=0;if(x+y<=n)link(x,x+y);}
	}
}
```

---

## 作者：bztMinamoto (赞：2)

更好的阅读体验点这里->[我的blog](https://www.cnblogs.com/bztMinamoto/p/9325828.html)

用这题来练练LCT吧……话说wjz大佬讲的LCT几乎没怎么听懂啊QAQ我好菜

话说关于LCT，这两位大佬的blog很不错

http://www.cnblogs.com/zwfymqz/p/8972914.html#_label5

http://www.cnblogs.com/flashhu/p/8324551.html

 

首先我们考虑，对于每一个节点，向他被弹到的节点连边。即对于所有节点建一棵树，i节点的父亲为从i装置会被弹飞到哪一个装置。

我们定义一个虚拟节点n+1，让所有被弹飞到大于n的点连到n+1。可以看出，到了n+1就意味着已经被弹飞

对于修改操作，先将点与原先的连边cut，再link到新的点上

对于查询操作，我们依次执行makeroot(x),access(y),splay(y)，这个时候可以发现x的深度即为答案。而因为此时splay已经是一条链，所以答案就是sz[y]-1（sz表示以y为根的子树的大小）
```
//minamoto
#include<cstdio>
#include<algorithm>
#include<cctype>
#define N 200005
using namespace std;
#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<15,stdin),p1==p2)?EOF:*p1++)
char buf[1<<15],*p1=buf,*p2=buf;
inline int read(){
    #define num ch-'0'
    char ch;bool flag=0;int res;
    while(!isdigit(ch=getc()))
    (ch=='-')&&(flag=true);
    for(res=num;isdigit(ch=getc());res=res*10+num);
    (flag)&&(res=-res);
    #undef num
    return res;
}
namespace lct{
	int top,s[N],ch[N][2],fa[N],sz[N],v[N];bool rev[N];
	inline bool isroot(int x){return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x;}
	inline void pushup(int x){sz[x]=sz[ch[x][0]]+sz[ch[x][1]]+1;}
	inline void pushdown(int x){if(rev[x])swap(ch[x][0],ch[x][1]),rev[ch[x][0]]^=1,rev[ch[x][1]]^=1,rev[x]^=1;}
	inline void rotate(int x){
		int y=fa[x],z=fa[y],d=(ch[y][1]==x);if(!isroot(y)) ch[z][ch[z][1]==y]=x;
		fa[x]=z,fa[y]=x;fa[ch[x][d^1]]=y,ch[y][d]=ch[x][d^1],ch[x][d^1]=y;pushup(y),pushup(x);
	}
	inline void splay(int x){
		s[top=1]=x;for(int i=x;!isroot(i);i=fa[i]) s[++top]=fa[i];for(int i=top;i>=1;--i) pushdown(s[i]);
		for(int y=fa[x],z=fa[y];!isroot(x);y=fa[x],z=fa[y]){
			if(!isroot(y)) ((ch[z][1]==y)^(ch[y][1]==x))?rotate(x):rotate(y);rotate(x);
		}
	}
	inline void access(int x){int t=0;while(x){splay(x),ch[x][1]=t,pushup(x),t=x,x=fa[x];}}
	inline void makeroot(int x){access(x),splay(x),rev[x]^=1;}
	inline void split(int x,int y){makeroot(x),access(y),splay(y);}
	inline void link(int x,int y){makeroot(x);fa[x]=y;}
	inline void cut(int x,int y){makeroot(x);access(y),splay(y);fa[x]=ch[y][0]=0;pushup(y);}
	inline int query(int x,int y){makeroot(x),access(y),splay(y);return sz[y]-1;}
}
using namespace lct;
int main(){
	//freopen("testdata.in","r",stdin);
	int n,m;
	n=read();
	for(int i=1;i<=n+1;++i) sz[i]=1;
	for(int i=1;i<=n;++i){
		v[i]=read();
		if(i+v[i]<=n) link(i,i+v[i]);
		else link(i,n+1);
	}
	m=read();
	while(m--){
		int opt=read(),i=read();++i;
		if(opt==1){
			printf("%d\n",query(i,n+1));
		}
		else{
			int k=read();
			cut(i,i+v[i]<=n?i+v[i]:n+1);
			link(i,i+k<=n?i+k:n+1);
			v[i]=k;
		}
	}
	return 0;
}
```

---

## 作者：Jason_Yvan (赞：2)

一道LCT就好好打个模板

操作很少:连接和删边。

把n + 1 作为最后的树根就可以全部处理了


C++代码如下

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
#define F(x) tree[x].fa
#define LC(x) tree[x].child[0]
#define RC(x) tree[x].child[1]
#define REV(x) tree[x].rev
#define SIZE(x) tree[x].size
#define Size 300010
using namespace std;
inline int read(){
    int sum=0,fg=1;char c=getchar();
    while(c<'0' || c>'9'){if(c=='-')fg=-1;c=getchar();}
    while(c>='0' && c<='9'){sum=sum*10+c-'0';c=getchar();}
    return sum*fg;
}
struct lct{
    int fa,child[2],rev,size;
}tree[Size];
int fa[Size];
struct link_cut_tree{
    int stack[Size];
    inline bool isroot(int x){
        return LC(F(x))!=x && RC(F(x))!=x;
    }
    inline void pushup(int x){
        SIZE(x)=SIZE(LC(x))+SIZE(RC(x))+1;
    }
    inline void pushdown(int x){
        if(!REV(x))return;
        REV(x)^=1;REV(LC(x))^=1;REV(RC(x))^=1;
        swap(LC(x),RC(x));
    }
    inline void rotate(int x){
        int A=F(x),B=F(A);bool w=(RC(A)==x);
        if(!isroot(A)){
            if(LC(B)==A)LC(B)=x;
            else if(RC(B)==A)RC(B)=x;
        }
        F(tree[x].child[w^1])=A;F(A)=x;F(x)=B;
        tree[A].child[w]=tree[x].child[w^1];tree[x].child[w^1]=A;
        pushup(A);pushup(x);
    }
    void Pushdown(int x){
        if(!isroot(x))Pushdown(F(x));
        pushdown(x);
    }
    inline void splay(int x){
        Pushdown(x); 
        while(!isroot(x)){
            if(!isroot(F(x)))rotate(x);
            rotate(x);
        }
    }
    inline void access(int x){
        for(int i=0;x;x=F(x)){splay(x);RC(x)=i;i=x;pushup(x);}
    }
    inline void reverse(int x){
        access(x);splay(x);REV(x)^=1;
    }
    inline void link(int x,int y){
        reverse(x);F(x)=y;
    }
    inline void cut(int x,int y){
        reverse(x);access(y);splay(y);F(x)=LC(y)=0;
    }
}LCT; 
int main(){
    int n=read();
    for(int i=1;i<=n;i++){
        int k=read();
        SIZE(i)=1;fa[i]=F(i)=min(n+1,i+k);
    }
    SIZE(n+1)=1;
    int m=read();
    while(m--){
        int tp=read();
        if(tp==1){
            int x=read();x++;
            LCT.reverse(n+1);LCT.access(x);LCT.splay(x);
            printf("%d\n",SIZE(LC(x)));
        }
        else{
            int x=read(),y=read();x++;
            LCT.cut(x,fa[x]);LCT.link(x,min(n+1,x+y));
            fa[x]=min(n+1,x+y);
        }
    }
    return 0;
}

```

---

## 作者：Azuree (赞：1)

[查看原题请戳这里](https://www.luogu.org/problem/P3203)  
我们先来看一下这道题如果先转化成森林再处理的话，一共有如下几个操作：  
 - 删除一条边
 - 加入一条边  
 - 查询两点间路径权值和  
 
这不是一道LCT的题吗……  
然而LCT代码复杂度太高了，这里我们来讲一下如何用分块来解决这道题。  
首先，我们将这$n$个装置分成$\sqrt n$块，每块有$\sqrt n$个元素。然后，我们记录下每个元素跳出ta所在块所需要的步数以及ta会跳到哪里。然后，对于每次修改，我们就用$O(n)$的复杂度去修改一个块中所有元素的值；对于每次查询，我们就一个块一个块条。  
时间复杂度：$O(\sqrt n)$  
code：  
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define ll long long
#define INF 0x7fffffff
#define re register
#define qwq printf("qwq\n");

using namespace std;

int read()
{
	register int x = 0,f = 1;register char ch;
	ch = getchar();
	while(ch > '9' || ch < '0'){if(ch == '-') f = -f;ch = getchar();}
	while(ch <= '9' && ch >= '0'){x = x * 10 + ch - 48;ch = getchar();}
	return x * f;
}

int n,m,x,y,z,a[200005],l[100005],r[100005],len,num,to[200005],cnt[200005],blog[200005];

void clannad(int k)
{
	for(int i = r[k]; i >= l[k]; i--)
	{
		blog[i] = k;
		if(i + a[i] > r[k]) to[i] = i + a[i],cnt[i] = 1;
		else to[i] = to[i + a[i]],cnt[i] = cnt[i + a[i]] + 1;
	}
}

void change(int k)
{
	int u = blog[k];
	for(int i = k; i >= l[u]; i--)
	{
		if(i + a[i] > r[u]) to[i] = i + a[i],cnt[i] = 1;
		else to[i] = to[i + a[i]],cnt[i] = cnt[i + a[i]] + 1;
	}
}

int query(int k,int sum)
{
	if(k > n) return sum;
	return query(to[k],sum + cnt[k]);
}

int main()
{
	n = read();
	for(int i = 1; i <= n; i++) a[i] = read();
	len = sqrt(n);
	num = n / len;
	if(n % len) num++;
	for(int i = 1; i <= num; i++) l[i] = (i - 1) * len + 1,r[i] = i * len;
	r[num] = n;
	for(int i = 1; i <= num; i++) clannad(i);
	m = read();
	for(int i = 1; i <= m; i++)
	{
		x = read(); y = read() + 1;
		if(x == 1) printf("%d\n",query(y,0));
		if(x == 2)
		{
			z = read();
			a[y] = z;
			change(y);
		}
	}
    return 0;
}
```

---

## 作者：良月澪二 (赞：1)

## 为何没有指针

思路已经很清楚了

建点建到n + 1

到了n + 1代表弹飞了

输入弹力系数的时候就直接link

LCT维护每个节点的子树siz

1操作打通j到n + 1之间的重链，输出n + 1的siz - 1，也就是深度

2操作cut掉原来的边再建新边，注意判断是不是连到n + 1即可

由于它告诉你编号从0~n - 1，所以把编号全体上挪一位

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <complex>
#include <algorithm>
#include <climits>
#include <queue>
#include <map>
#include <set>
#include <vector>
#include <iomanip>
#define A 1000010
#define B 2010

using namespace std;
typedef long long ll;
int tot, n, m, x, y, w[A];
namespace LCT {
	struct node* null;
	struct node {
		node *ch[2], *fa;
		int siz, rev;
		bool whether() {
			return fa->ch[1] == this;
		}
		bool isroot() {
			return fa == null or (fa->ch[0] != this and fa->ch[1] != this);
		}
		void update() {
			siz = 1;
			if (ch[0] != null) siz += ch[0]->siz;
			if (ch[1] != null) siz += ch[1]->siz;
		}
		void down() {
			if (this == null or !rev) return;
			swap(ch[0], ch[1]);
			ch[0]->rev ^= 1;
			ch[1]->rev ^= 1;
			rev = 0;
		}
		void setnode(bool k, node *c) {
			down();
			ch[k] = c;
			if (c != null) c->fa = this;
		}
	}pool[A];
	#define ND node*
	void init() {
		null = pool;
		null->ch[0] = null->ch[1] = null->fa = null;
		null->siz = null->rev = 0;
	}
	ND newnode(int val) {
		ND x = pool + ++tot;
		x->ch[0] = x->ch[1] = x->fa = null;
		x->siz = 1;
		return x;
	}
	void rotate(ND x) {
        node *fa = x->fa, *grand = fa->fa;
        if (!fa->isroot()) grand->down();
        fa->down(); x->down();
        int dir = x->whether();
        fa->setnode(dir, x->ch[dir ^ 1]);
        if (fa->isroot()) x->fa = fa->fa;
        else grand->setnode(fa->whether(), x);
        x->setnode(dir ^ 1, fa);
        fa->update(); x->update();
    }
    void fix(ND x) {
        if (!x->isroot()) fix(x->fa);
        x->down();
    }
    void splay(ND x) {
        fix(x);
        while (!x->isroot()) {
            if (!x->fa->isroot())
                x->whether() == x->fa->whether() ? rotate(x->fa) : rotate(x);
        	rotate(x);
        }
        x->update();
    }
    ND access(ND x) {
        ND y = null;
        while (x != null) {
            splay(x);
            x->ch[1] = y;
            x->update();
            y = x;
        	x = x->fa;
        }
        return y;
    }
    void makeroot(ND x) {
        access(x)->rev = 1;
        splay(x);
    }
    void link(ND x, ND y) {
        makeroot(x);
        x->fa = y;
    }
    void cut(ND x, ND y) {
        makeroot(x);
        access(y);
        splay(x);
        if (x->ch[1] == y and x->ch[1]->ch[0] != null) return;
        x->ch[1] = y->fa = null;
    }
    int ask(int x, int y) {
    	ND a = pool + x;
    	ND b = pool + y;
    	makeroot(a);
    	access(b);
    	splay(b);
    	return b->siz;
    }
}

int main(int argc, char const *argv[]) {
	LCT::init();
	scanf("%d", &n);
	for (int i = 1; i <= n + 1; i++) LCT::newnode(1);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &w[i]);
		LCT::ND a = LCT::pool + i;
		LCT::ND b = LCT::pool + i + w[i];
		LCT::ND c = LCT::pool + n + 1;
		if (i + w[i] <= n) LCT::link(a, b);
		else LCT::link(a, c);
	}
	scanf("%d", &m);
	while (m--) {
		int opt;
		scanf("%d", &opt);
		if (opt == 1) {
			scanf("%d", &x); x++;
			printf("%d\n", LCT::ask(x, n + 1) - 1);
		}
		else {
			scanf("%d%d", &x, &y); x++;
			LCT::ND a = LCT::pool + x;
			LCT::ND b = LCT::pool + x + w[x];
			LCT::ND c = LCT::pool + n + 1;
			LCT::ND d = LCT::pool + x + y;
			LCT::cut(a, x + w[x] <= n ? b : c);
			LCT::link(a, x + y <= n ? d : c);
			w[x] = y;
		}
	}
}
```

---

## 作者：Newuser (赞：1)

感觉还是很显然吧，直接将这个(点)与(点+劲度系数)的点连接起来，

同时考虑建一个空结点n+1(编号0不好处理，于是所有编号向上平移一个单位)，意为所有的绵羊到这个地方就能够被弹飞

如果连接的时候i+k<=n就连不然就和n+1连接起来

每一次询问操作，setroot(x) access(n+1) splay(n+1),答案就是siz[n+1]-1

而每次进行修改劲度系数的时候，不只是光要连，还要将原来的边删掉。 就可以了(同时记得编号连接不大于n+1规定)

就这样搞定了，开始痛苦地调试罢！

cheer!


```cpp
#include<bits/stdc++.h>
#define zig(x) zigzag(x,1)
#define zag(x) zigzag(x,2)
using namespace std;
const int maxn=200005;
int n,m,rev[maxn],ls[maxn],rs[maxn],fa[maxn],jingdu[maxn],siz[maxn];
bool isroot(int x) { return ls[fa[x]]!=x&&rs[fa[x]]!=x; }
void putup(int x)
{
	siz[x]=siz[ls[x]]+siz[rs[x]]+1;
}
void zigzag(int x,int knd)
{
	int y=fa[x],z=fa[y];
	if(!isroot(y))
	{
		if(ls[z]==y) ls[z]=x;
		else rs[z]=x;
	}
	fa[x]=z; fa[y]=x;
	if(knd==1)
	{
		ls[y]=rs[x];
		fa[ls[y]]=y;
		rs[x]=y;
	}
	else
	{
		rs[y]=ls[x];
		fa[rs[y]]=y;
		ls[x]=y;
	}
	putup(y); putup(x);
}
void putdowm(int x)
{
	if(!rev[x]) return;
	swap(ls[x],rs[x]); rev[ls[x]]^=1; rev[rs[x]]^=1; 
	rev[x]=0;
}
int sta[maxn];
void splay(int x)
{
	int top=0; sta[++top]=x;
	for(int i=x;!isroot(i);i=fa[i]) { sta[++top]=fa[i]; }
	while(top) putdowm(sta[top--]);
	while(!isroot(x))
	{
		int y=fa[x],z=fa[y];
		if(isroot(y))
		{
			if(ls[y]==x) zig(x);
			else zag(x);
		}
		else
		{
			if(ls[z]==y)
			{
				if(ls[y]==x) { zig(y); zig(x); }
				else { zag(x); zig(x); }
			}
			else
			{
				if(rs[y]==x) { zag(y); zag(x); }
				else { zig(x); zag(x); }
			}
		}
	}
}
void acc(int x)
{
	for(int y=0;x;y=x,x=fa[x])
	{
		splay(x);
		rs[x]=y;
		putup(x);
	}
}
void setroot(int x)
{
	acc(x); splay(x); rev[x]^=1;
}
void link(int a,int b)
{
	setroot(a); fa[a]=b;
}
void cut(int a,int b)
{
	setroot(a); acc(b); splay(b);
	ls[b]=fa[a]=0;
}
int getroot(int a)
{
	acc(a); splay(a);
	while(ls[a]) a=ls[a];
	return a;
}
int ans(int x)
{
	setroot(x); acc(n+1); splay(n+1); return siz[n+1]-1;
}
void change(int x,int y)
{
	cut(x,min(jingdu[x]+x,n+1)); jingdu[x]=y; link(x,min(x+jingdu[x],n+1));
}

int main()
{
	int x,y,z;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&jingdu[i]);
		link(i,min(jingdu[i]+i,n+1));
	}
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d",&x);
		if(x==1)
		{
			scanf("%d",&y); ++y;
			printf("%d\n",ans(y));
		}
		else
		{
			scanf("%d%d",&y,&z); ++y;
			change(y,z);
		}
	}
}
```

个人博客小站:[Newuser小站](https://www.newuser.top)欢迎光顾！

---

## 作者：liuqy (赞：1)

# 下面的大佬做法没看懂，我就说几种方法 本题一坑：装置从0开始（坑啊）

####  1.	先说暴力，不要问我方法，用O2能水到40分#### 
```
#include <cstdio>
int n,x,y,ans,s,z;
int a[220000];
int main(){
	scanf("%d",&n);
	for(int i=0;i<n;i++)scanf("%d",&a[i]);
	scanf("%d",&s);
	for(int i=1;i<=s;i++){
		scanf("%d%d",&x,&y);
		if(x==1){
			ans=0;
			while(y<n){
				++ans;
				y+=a[y];
			}
			printf("%d\n",ans);
		}else{
			scanf("%d",&z);
			a[y]=z;
		}
	}
	
	return 0;
}
```
####  2.再说一个能水到70分（O2），现将整个数列全部做一遍存到b数组里，查询操作一搜就能找到答案，但修改有点麻烦需要将修改点之前所有刷新一边，所以复杂度为 n+n*n ,所以爆炸
```
#include <cstdio>
#include <cstring>
int n,x,y,s,z;
int a[220000],b[220000];
int main(){
	scanf("%d",&n);
	for(int i=0;i<n;i++)scanf("%d",&a[i]);
	
	for(int i=n-1;i>=0;i--){
		if(a[i]+i>=n){
			b[i]=1;
			continue;
		}else b[i]=b[a[i]+i]+1;
	}
	
	scanf("%d",&s);
	for(int i=1;i<=s;i++){
		scanf("%d%d",&x,&y);
		if(x==1)printf("%d\n",b[y]);
		else{
			scanf("%d",&z);
			a[y]=z;
			for(int k=y;k>=0;k--){
				if(a[k]+k>=n){
					b[k]=1;
					continue;
				}else b[k]=b[a[k]+k]+1;
			}
		}
	}
	
	return 0;
}


```
## 3.正解登场 将第二种方法进行改进——分段
#### 现将每段均匀断开长度为sqrt(n)，再将第i段起点和终点存到l[i]和r[i]里
####  然后将每段按照第二种方法求出每段答案
####  介绍一下cut(l,j)表示从j到l求值（注意一定要倒着做），如果有数跳出本段就将他答案值给1，将其父节点给到他对应跳到的位置，否则在本段里同2
#### 最后加答案只需将本点加上所到节点的答案求和即可，修改只需更改本段即可，复杂度为 log2n+long2n 即可，虽然查询复杂度增加但整个复杂度均摊下来求小了很多

```
#include <cstdio>
#include <cmath>
const int N=220000;
const int N1=500;
int n,sn,m,x,y,z,ans,k;
int a[N],b[N],f[N],l[N1],r[N1];
void cut(int x,int y){
	for(int i=y;i>=x;i--){
		if(i+a[i]>y){
			b[i]=1;
			f[i]=a[i]+i;
		}else{
			b[i]=b[a[i]+i]+1;
			f[i]=f[a[i]+i];
		}
	}
}
int main(){
	
	scanf("%d",&n);
	sn=sqrt(n);
	for(int i=0;i<n;i++)scanf("%d",&a[i]);
	
	for(int i=1;i<sn;i++){
		l[i]=sn*(i-1);
		r[i]=sn*i-1;
	}
	l[sn]=r[sn-1]+1;
	r[sn]=n-1;
	for(int i=1;i<=sn;i++)cut(l[i],r[i]);
	
	scanf("%d",&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&x,&y);
		
		if(x==1){
			ans=0;
			
			while(y<n){
				ans+=b[y];
				y=f[y];
			}
			
			printf("%d\n",ans);
		}else{
			scanf("%d",&z);
			a[y]=z;
            if((y+1)%sn==0)k=(y+1)/sn;
            else k=(y+1)/sn+1;
            cut(l[k],r[k]);
		}
	}
	
	return 0;
}
```


---

## 作者：CodeRikka (赞：1)

#### 这题数据有点恶心，导致我连T了几万次，有一个不知道为什么的On预处理被迫被我改成根号n，结果就A了？我这就有点搞不懂了。

#### 这题我的思路是分块。将每个数弹出这个数所处的块的次数记录下来，并记录此数弹出此块后指向的坐标。每一次update，我们就更新此数所处的块即可。最后扫描也很方便，将弹到的数的次数之和加起来即可。

#### 虽然有点卡常（不知道怎么卡的），但是在我的努力之下也很快解决了哇咔咔。

#### 详细解答请看代码

```c
#include<bits/stdc++.h>
#define RR register
#define M 200005
using namespace std;
int S;//块大小 
int n,m;
int a,b,c;
void Rd(int &res) {//快读 
	char c;
	int flag=1;
	res=0;
	while(c=getchar(),c<48) {
		if(c=='-')flag=-1;
	}
	do res=(res<<3)+(res<<1)+(c^48);
	while(c=getchar(),c>=48);
	res*=flag;
}
void Pdfs(int n) {//输出挂 
	if(n==0)return;
	Pdfs(n/10);
	putchar(n%10^48);
}
void Print(int n) {//输出挂 
	if(n<0) {
		putchar('-');
		n=-n;
	}
	if(n==0)putchar('0');
	else Pdfs(n);
}
struct node {
	int L,R;
} pos[M];//每个块的左右指针 
struct dot {
	int val,cnt,to;
} A[M];//主数组，记录值，弹几次出此块，到达的点 
void Init(int n) {
//	for(int i=1;i<=n;i++)pos[i/S]=((node){max(1,i/S*S),min(n,(i/S+1)*S-1)});
//上面的就是我说的预处理On，莫名其妙因此T 

	for(RR int i=0;i<=S+1;i++)pos[i]=((node){max(1,i*S),min(n,(i+1)*S-1)});
	//定义每个块的边界，从i*S到(i+1)*S-1，如果-1没加会导致wa或者T 
	return;
}
void update(int b,int c,bool flag) {//更改一个数，更新这个数所处的块 
	int k=b/S;
	int R0=pos[k].R,L0=pos[k].L;//边界 
	A[b].val=c;//更新值 
	for(RR int i=R0; i>=L0; i--) {//从后往前更新 
		int v=A[i].val;
		if(i+v<=R0)A[i]=((dot) {A[i].val,A[i+v].cnt+1,A[i+v].to});
		//如果没有弹出此块，则指向此块中的下一个弹射器 
		else A[i].cnt=1,A[i].to=i+A[i].val;
		//弹出此快，更新 
	}
	return;
}
inline int query(int num) {
	int ans=0,ka=num/S;
	while(ka<=n/S+1&&num<=n) {
		ans+=A[num].cnt;
		num=A[num].to;
		ka=num/S;
	}
	return ans;
	//很简单的询问 
}
int main() {
	scanf("%d",&n);
	S=sqrt(n);
	//更新块的大小 
	Init(n);
	//块的边界更新 
	for(RR int i=1; i<=n; i++)Rd(A[i].val);
	for(RR int i=n; i>=1; i--)update(i,A[i].val,1);
	scanf("%d",&m);
	for(RR int i=1; i<=m; i++) {
		Rd(a);
		if(a==1) {
			Rd(b);
			Print(query(b+1));
			puts("");
		} else {
			Rd(b);Rd(c);
			update(b+1,c,1);
			//询问的边界是从0开始的，所以加一 
		}
	}
	return 0;
}
```

###### 看在我de了这么久bug的份上采纳我吧！

---

## 作者：Gypsophila (赞：0)

### Description

给 $n$ 个点以及它们的弹力系数 $k_i$ ，含义为 可以弹到 $i + k_i$ 的位置。

支持两个东西，修改一个点的弹力系数；求一个点要弹多少次弹出 $n$ 

### Solution

用 LCT 做。弹力系数是 $k_i$ 可以看作是 $i$ 和 $i+k_i$ 连了一条边。如果弹出去了就不妨设和 $0$ 连一条边。

对于修改操作，先把原来的边删除，修改 k 数组，再连上新边

对于查询操作，维护一个子树大小 siz （这里是 splay 上的 siz，不是原树上的），然后询问就相当于当前这个点 $u$ 到 $0$ 这条链上有几个点。所以就 split 出来这条链然后输出 siz - 1 就行了（注意要减 $1$ 因为问的是弹多少次）

然后就做完了（注意输入的时候要加 1）

### Code

[看代码戳这里](https://www.cnblogs.com/acfunction/p/10256867.html)



---

## 作者：yzhang (赞：0)

### [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/10202665.html)

### [原题传送门](https://www.luogu.org/problemnew/show/P3203)

### 这题用Link-Cut-Tree解决，[Link-Cut-Tree详解](https://www.cnblogs.com/yzhang-rp-inf/p/10201857.html)

预处理：从一个点弹到另一个点就在lct里从$i$连边到$i+k_i$，如果绵羊被弹飞了就从$i$连边到$n+1$(一个虚拟点，方便统计)

操作1：split（x，n+1），把x到n+1路径上的点放到同一个Splay中，答案就是T.size[n+1]-1

操作2：先把$i$到$i+oldk$的边删除

如果$i+newk<=n$，从$i$连边到$i+newk$，否则就从$i$连边到$n+1$

### 注意：编号是0~n-1，为了方便写码，把所有的编号加1

```cpp
#include <bits/stdc++.h>
#define N 200005
#define getchar nc
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf; 
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++; 
}
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register int x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
inline void Swap(register int &a,register int &b)
{
    a^=b^=a^=b;
}
struct Link_Cut_Tree{
    int c[N][2],fa[N],top,q[N],rev[N],size[N];
    inline void pushup(register int x)
    {
        size[x]=size[c[x][0]]+size[c[x][1]]+1;
    }
    inline void pushdown(register int x){
        if(rev[x])
        {
            register int l=c[x][0],r=c[x][1];
            rev[l]^=1,rev[r]^=1,rev[x]^=1;
            Swap(c[x][0],c[x][1]);
        }
    }
    inline bool isroot(register int x)
    {
        return c[fa[x]][0]!=x&&c[fa[x]][1]!=x;
    }
    inline void rotate(register int x)
    {
        int y=fa[x],z=fa[y],l,r;
        l=c[y][0]==x?0:1;
        r=l^1;
        if(!isroot(y))
            c[z][c[z][0]==y?0:1]=x;
        fa[x]=z;
        fa[y]=x;
        fa[c[x][r]]=y;
        c[y][l]=c[x][r];
        c[x][r]=y;
        pushup(y),pushup(x);
    }
    inline void splay(register int x)
    {
        top=1;
        q[top]=x;
        for(register int i=x;!isroot(i);i=fa[i])
            q[++top]=fa[i];
        for(register int i=top;i;--i)
            pushdown(q[i]);
        while(!isroot(x))
        {
            int y=fa[x],z=fa[y];
            if(!isroot(y))
                rotate((c[y][0]==x)^(c[z][0]==y)?(x):(y));
            rotate(x);
        }
    }
    inline void access(register int x)
    {
        for(register int t=0;x;t=x,x=fa[x])
        {
            splay(x);
            c[x][1]=t;
            pushup(x);	
        }
    }
    inline void makeroot(register int x)
    {
        access(x);
        splay(x);
        rev[x]^=1;
    }
    inline void split(register int x,register int y)
    {
        makeroot(x);
        access(y);
        splay(y);
    }
    inline void cut(register int x,register int y)
    {
        split(x,y);
        if(c[y][0]==x)
        {
            c[y][0]=0;
            fa[x]=0;
        }
    }
    inline void link(register int x,register int y)
    {
        makeroot(x);
        fa[x]=y;
    }
}T;
int n,m,val[N];
int main()
{
    n=read();
    for(register int i=1;i<=n;++i)
    {
        val[i]=read();
        T.link(i,i+val[i]<=n?(i+val[i]):(n+1));
    }
    m=read();
    while(m--)
    {
        int opt=read();
        if(opt==1)
        {
            int x=read()+1;
            T.split(x,n+1);
            write(T.size[n+1]-1),puts("");
        }
        else
        {
            int x=read()+1,y=read();
            T.cut(x,x+val[x]<=n?(x+val[x]):(n+1));
            val[x]=y;
            T.link(x,x+val[x]<=n?(x+val[x]):(n+1));
        }
    }
    return 0;
}
```

---

## 作者：arfa (赞：0)

分块以后就很简单了,可以直接搞。

首先预处理,求出一个 $get_i$ 和相对应的 $pace_i$ 代表从 $i$ 点一直弹到下一个块的地方和步数。那我们查询的时候每一次都是可以在 $\sqrt{N}$ 的次数内弹到终点的。

关于修改,就是块里面可能会有一个点 $j$ 会弹到 $i$ 这里,借助 $i$ 来弹到下一个块。这样子就保证了修改在整个块里面,操作同样是 $\sqrt{N}$ 的。

然后注意弹出了以后要判一下边界,不然会溢出导致很多神奇的东西。

```pascal
// luogu-judger-enable-o2
var
    bounce,get,pace:array [-1..200007] of longint;
    node_num,block_num,mode,ans,l,k,i,j,n,m:longint;

function Locate(node:longint):longint;begin exit((node-1) div node_num+1); end;

procedure Ready;
begin
    read(n); node_num:=trunc(sqrt(n)); block_num:=Locate(n);
    for i := 1 to n do read(bounce[i]); read(m);

    for i:=n downto 1 do 
    begin
        l:=Locate(i)*node_num;
        if (i+bounce[i]>n) then begin get[i]:=0; pace[i]:=1; continue; end;
        if (i+bounce[i]>l) then begin get[i]:=i+bounce[i]; pace[i]:=1; end else 
        begin get[i]:=get[i+bounce[i]]; pace[i]:=pace[i+bounce[i]]+1; end;
    end;
end;

begin
    Ready;
    for i:=1 to m do 
    begin 
    	read(mode);
        if mode=1 then 
        begin
        	ans:=0; read(l); inc(l); j:=l;
            while j>0 do begin inc(ans,pace[j]); j:=get[j]; end;
            writeln(ans);
        end else 
        begin
            read(l,k); inc(l);  bounce[l] := k;
            for j:=l downto(Locate(l)-1)*node_num+1 do 
            begin
            	if (j+bounce[j]>n) then begin get[j]:=0; pace[j]:=1; continue; end;
                if (j+bounce[j]>Locate(l)*node_num) then begin get[j]:=j+bounce[j]; pace[j]:=1; end else 
                begin get[j]:=get[j+bounce[j]]; pace[j]:=pace[j+bounce[j]]+1; end;
            end;
        end;
    end;
end.
```

---

## 作者：QuantAsk (赞：0)

# 正题
评测记录:https://www.luogu.org/recordnew/lists?uid=52918&pid=P3203

-----

## 题目大意
$n$个装置。到第$i$个装置会被往前弹$a_i$个。
两种操作
修改$a_i$和询问从$i$出发要多少次弹射可以弹出去。

------

## 解题思路
分块。对于每个点，维护要多少步弹出该块和弹出去后弹到哪里。
询问就直接根据两个数据，修改就直接重构整个块。

时间复杂度:$O(n\sqrt n)$

--------

## code
```cpp
#include<cstdio>
#include<cmath>
#define N 200010
#define T 500
using namespace std;
int n,m,x,t,a[N],L[T],R[T],step[N],to[N],pos[N];
void pre_work()//预处理
{
	for(int i=1;i<=t;i++)//块边界
	{
		L[i]=(i-1)*t+1;
		R[i]=i*t;
	}
	if(R[t]!=n) t++,L[t]=R[t-1]+1,R[t]=n;
	for(int i=1;i<=t;i++)
	  for(int j=R[i];j>=L[i];j--)
	  {
	      if(j+a[j]<=R[i]) step[j]=step[j+a[j]]+1,to[j]=to[j+a[j]];
	      else step[j]=1,to[j]=j+a[j];
	      pos[j]=i;
	  }//初始数据
}
int ask(int x)//询问
{
	int ans=0;
	while(x<=n)
	  ans+=step[x],x=to[x];
	return ans;
}
void change(int i)//重构块
{
	for(int j=R[i];j>=L[i];j--)
	  if(j+a[j]<=R[i]) step[j]=step[j+a[j]]+1,to[j]=to[j+a[j]];
	  else step[j]=1,to[j]=j+a[j];
}
int main()
{
	scanf("%d",&n);
	t=sqrt(n);
	for(int i=1;i<=n;i++)
	  scanf("%d",&a[i]);
	pre_work();
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d",&x);
		if(x==1)
		{
			scanf("%d",&x);x++;
			printf("%d\n",ask(x));
		}
		else{
			scanf("%d",&x);x++;
			scanf("%d",&a[x]);
			change(pos[x]);
		}
	}
}
```


---

## 作者：winmt (赞：0)

这题其实LCT动态树和分块都可以搞的。（据说）

我用的是分块啊～（因为表示不会LCT）

分块解法：每个点记录跳出分块的步数以及跳到下一分块的哪个点，想清楚之后就很好写了，注意细节！！！

【AC代码】

   
   
       
       
       
       
       
               
               
       
```cpp
#include<iostream> 
#include<cstdio> 
#include<cmath> 
#include<algorithm> 
using namespace std; 
int n,m,x,y; 
int a[200005],b[200005][3],c[200005]; 
int main() 
{ 
    scanf("%d",&n); 
    for(int i=0;i<n;i++) 
    { 
        scanf("%d",&a[i]); 
    } 
    int h=(int)sqrt(n); 
    int v=1; 
    for(int i=0;i<n;i++) 
    { 
        c[i]=v; 
        if((i+1)%h==0)v++; 
    } 
    for(int i=n-1;i>=0;i--) 
    { 
        if(i+a[i]>n-1 || c[i+a[i]]!=c[i])b[i][2]=i+a[i]; else b[i][2]=b[i+a[i]][2]; 
        if(c[i+a[i]]!=c[i])b[i][1]=1; else b[i][1]=b[i+a[i]][1]+1; 
    } 
    /*for(int i=0;i<n;i++) 
    { 
        cout<<a[i]<<" "<<b[i][1]<<" "<<b[i][2]<<endl; 
    }*/
    scanf("%d",&m); 
    for(int k=1;k<=m;k++) 
    { 
        scanf("%d",&x); 
        if(x==1) 
        { 
            scanf("%d",&x); 
            int ans=0; 
            while(x<=n-1) 
            { 
                ans+=b[x][1]; 
                x=b[x][2];   
            } 
            if(ans==0)printf("%d\n",1); else printf("%d\n",ans); //试过了，数据其实有漏洞，不加前半段，只写else之后也可以过的。
        } 
        else
        { 
            scanf("%d%d",&x,&y); 
            a[x]=y; 
            if(x+y>n-1 || c[x+y]!=c[x])b[x][2]=x+y; else b[x][2]=b[x+y][2]; 
            if(c[x+y]!=c[x])b[x][1]=1; else b[x][1]=b[x+y][1]+1; 
            for(int i=x-1;i>=0;i--) 
            { 
                if(c[i]!=c[x])break; 
                if(i+a[i]<=n-1 && c[i+a[i]]==c[i])b[i][2]=b[i+a[i]][2]; 
                if(c[i+a[i]]==c[i])b[i][1]=b[i+a[i]][1]+1; 
            } 
            /*for(int i=0;i<n;i++) 
            { 
                cout<<a[i]<<" "<<b[i][1]<<" "<<b[i][2]<<endl; 
            }*/
        } 
    } 
    return 0; 
}
```

---

## 作者：magolor (赞：0)

一道LCT，竟然没有人发LCT的题解！！！（虽然ORZ楼下分块神犇，表示不会分块）

LCT动态树，Splay维护。挺裸的，其实就是维护一片**森林**，每个点的父亲是i+ki，支持割边加边以及查询到根的路径长。

LCT维护以后修改弹力系数就是先割边然后加边，路径长就是左子树sz（LCT自行度娘）。

本人LCT写法不太正常，Splay不变，增加rtf表示非偏爱边。


小提示：**注意特殊情况：割边时弹力系数超过n或等于0就不要再加边了！那是森林！**


---


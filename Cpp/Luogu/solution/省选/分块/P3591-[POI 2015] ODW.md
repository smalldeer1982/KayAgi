# [POI 2015] ODW

## 题目描述

给定一棵 $n$ 个点的树，树上每条边的长度都为 $1$，第 $i$ 个点的权值为 $a_i$。 

Byteasar 想要走遍这整棵树，他会按照某个 $1$ 到 $n$ 的全排列 $b$ 走 $n-1$ 次，第 $i$ 次他会从 $b_i$ 点走到 $b_{i + 1}$ 点，并且这一次的步伐大小为 $c_i$。 

对于一次行走，假设起点为 $x$，终点为 $y$，步伐为 $k$，那么Byteasar会从 $x$ 开始，每步往前走 $k$ 条边，数据保证了每次行走的距离是 $k$ 的倍数。 

请帮助 Byteasar 统计出每一次行走时经过的所有点的权值和。

## 说明/提示

原题名称：Odwiedziny。

## 样例 #1

### 输入

```
5
1 2 3 4 5
1 2
2 3
3 4
3 5
4 1 5 2 3
1 3 1 1
```

### 输出

```
10
6
10
5
```

# 题解

## 作者：devout (赞：22)

> 一道套路题——神cy

~~好像确实挺套路的~~

考虑我们让所有$k>\sqrt n$的暴力跳，预处理所有$k\leq\sqrt n$的情况即$sum[i][j]$表示$i$往上每$j$级祖先选一个点，一直到根节点选的点的情况和，查询就类似树上差分就好了

那么这样暴力跳的复杂度是$O(n\sqrt n \log n)$，预处理是$O(n\sqrt n)$

对时间进行优化，可以使用长链剖分，每次$O(1)$查询k级祖先，这样我们的总复杂度就可以做到$O(n\log n+n\sqrt n)$了

[长链剖分模板题](https://www.luogu.com.cn/problem/P5903)

然后这道题就愉快的做完了

没错，思想就这么简单，~~但是代码啊~~

细节不少，一定要想清楚了再写，不然写题半小时，debug五小时

```cpp
#include <bits/stdc++.h>
using namespace std;
#define QAQ puts("QAQ")
# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

typedef long long ll;

const int N=5e4+5;
const int W=250;
const int w=225;

template<typename T> void read(T &x){
   x=0;int f=1;
   char c=getchar();
   for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
   for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

int n;
int a[N];
int head[N],cnt;
int b[N],c[N];
int dep[N],mdep[N],son[N],top[N];
int highbit[N],f[N][25];
int sum[N][W];

vector<int> up[N],down[N];

struct Edge{
	int to,next;	
}e[N<<1];

void add(int x,int y){
	e[++cnt]=(Edge){y,head[x]},head[x]=cnt;	
}

void dfs1(int u,int fa){
	mdep[u]=dep[u]=dep[fa]+1;
//	printf("%d %d\n",u,dep[u]);
	f[u][0]=fa;
	Rep(i,1,18)f[u][i]=f[f[u][i-1]][i-1];
	RepG(i,u){
		int v=e[i].to;
		if(v==fa)continue;
		dfs1(v,u);
		if(mdep[v]>mdep[u])mdep[u]=mdep[v],son[u]=v;
	}
}

void dfs2(int u,int fa,int _top){
	top[u]=_top;
	for(int i=1,p=f[u][0];i<=w;i++,p=f[p][0])sum[u][i]=sum[p][i]+a[u];
	if(top[u]==u){
		for(int i=0,ff=u;i<=mdep[u]-dep[u];i++,ff=f[ff][0])
			up[u].push_back(ff);
		for(int i=0,ss=u;i<=mdep[u]-dep[u];i++,ss=son[ss])
			down[u].push_back(ss);
	}
	if(son[u])dfs2(son[u],u,_top);
	RepG(i,u){
		int v=e[i].to;
		if(v==son[u]||v==fa)continue;
		dfs2(v,u,v);	
	}
}

int kthan(int x,int k){
	if(dep[x]<=k)return 0;
	if(!k)return x;
	x=f[x][highbit[k]],k-=(1<<highbit[k]);
	k-=dep[x]-dep[top[x]],x=top[x];
	return k>=0?up[x][k]:down[x][-k];	
}

int lca(int x,int y){
	if(dep[x]<=dep[y])swap(x,y);
	_Rep(i,18,0)if(dep[f[x][i]]>=dep[y])x=f[x][i];
	if(x==y)return x;
	_Rep(i,18,0)if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];
	return f[x][0];	
}

signed main()
{
//	freopen("3591.in","r",stdin);
//	freopen("3591.out","w",stdout);
	memset(head,-1,sizeof(head));
	read(n);
	Rep(i,1,n)read(a[i]);
	Rep(i,1,n-1){
		int x,y;
		read(x),read(y);
		add(x,y),add(y,x);	
	}
	Rep(i,1,n)read(b[i]);
	Rep(i,1,n-1)read(c[i]);
	dfs1(1,0);
	dfs2(1,0,1);
	highbit[1]=0;
	Rep(i,2,n)highbit[i]=highbit[i>>1]+1;
	Rep(i,2,n){
		int x=b[i-1],y=b[i],k=c[i-1];
		int l=lca(x,y);
		int res=0;
		if(k<=w){
			res+=sum[x][k]-sum[kthan(x,k*((dep[x]-dep[l])/k+1))][k];
			y=kthan(y,(dep[x]+dep[y]-2*dep[l])%k);
			res+=sum[y][k]-sum[kthan(y,k*((dep[y]-dep[l])/k+1))][k];
			if((dep[x]-dep[l])%k==0&&(dep[y]-dep[l])%k==0)res-=a[l];
			printf("%d\n",res);
		}
		else{
			for(int i=x;dep[i]>=dep[l];i=kthan(i,k))res+=a[i];
			y=kthan(y,(dep[x]+dep[y]-2*dep[l])%k);
			for(int i=y;dep[i]>=dep[l];i=kthan(i,k))res+=a[i];
			if((dep[x]-dep[l])%k==0&&(dep[y]-dep[l])%k==0)res-=a[l];
			printf("%d\n",res);	
		}
	}
	return 0;
}
```


---

## 作者：mrsrz (赞：9)

按照$c$分类讨论。

设一个阈值$S$。

当$c>S$的时候，我们就直接暴力跳，用倍增求出每次跳的点的$c$级祖先，然后累加。时间复杂度$O(\dfrac{n^2\log n}S)$。

当$c\leqslant S$的时候，记$s[i]$表示根节点到$i$的路径上，每$c$个点取一个，且$i$恰好被取到（根不一定被取到）的时候，取的所有点的和。

然后运用前缀和思想，就可以快速求出跳一段的贡献和。则可以做到单次查询复杂度$O(\log n)$，预处理每个$c$对应的$s[i]$复杂度$O(nS)$。

这样的话，理论上最优的$S$的取值为$\sqrt{n\log n}$，这样总复杂度为$O(n\sqrt{n\log n})$。

而实际上这样跑得很慢，会TLE，而$S=\sqrt n$的时候很快（和数据有关系），但理论时间复杂度上界为$O(n\sqrt n\log n)$。

## Code：
```cpp
#include<cstdio>
#include<cctype>
#define N 50005
#define siz 225
int n,head[N],cnt=0,to[N<<1],nxt[N<<1],b[N],c[N],dep[N],fa[17][N],a[N],sum[N];
int s[226][N];
struct istream{
	char buf[23333333],*s;
	inline istream(){
		buf[fread(s=buf,1,23333330,stdin)]='\n';
		fclose(stdin);
	}
	inline istream&operator>>(int&d){
		d=0;
		for(;!isdigit(*s);++s);
		while(isdigit(*s))
		d=(d<<3)+(d<<1)+(*s++^'0');
		return*this;
	}
}cin;
void dfs(int now){
	sum[now]+=a[now];
	for(int i=1;i<17;++i)
	fa[i][now]=fa[i-1][fa[i-1][now]];
	for(int i=head[now];i;i=nxt[i])
	if(!dep[to[i]]){
		dep[to[i]]=dep[now]+1;
		sum[to[i]]=sum[now];
		fa[0][to[i]]=now;
		dfs(to[i]);
	}
}
inline int LCA(int x,int y){
	if(dep[x]<dep[y])x^=y^=x^=y;
	for(int i=16;~i;--i)if(dep[fa[i][x]]>=dep[y])x=fa[i][x];
	if(x==y)return x;
	for(int i=16;~i;--i)if(fa[i][x]!=fa[i][y])x=fa[i][x],y=fa[i][y];
	return fa[0][x];
}
inline int getfa(int u,int x){
	for(int i=16;~i;--i)
	if(x>>i&1)u=fa[i][u];
	return u;
}
void dfs2(int now){
	int u=fa[0][now];
	for(int i=2;i<=siz;++i){
		u=fa[0][u];
		s[i][now]=s[i][u]+a[now];
	}
	for(int i=head[now];i;i=nxt[i])
	if(dep[now]<dep[to[i]])dfs2(to[i]);
}
int main(){
	cin>>n;
	for(int i=1;i<=n;++i)cin>>a[i];
	for(int i=1;i<n;++i){
		int u,v;
		cin>>u>>v;
		to[++cnt]=v;nxt[cnt]=head[u];head[u]=cnt;
		to[++cnt]=u;nxt[cnt]=head[v];head[v]=cnt;
	}
	for(int i=1;i<=n;++i)cin>>b[i];
	for(int i=1;i<n;++i)cin>>c[i];
	dfs(dep[1]=1);
	dfs2(1);
	for(int i=1;i<n;++i){
		int u=b[i],v=b[i+1],c=::c[i];
		int lca=LCA(u,v);
		if(c==1)
		printf("%d\n",sum[u]+sum[v]-sum[lca]-sum[fa[0][lca]]);else
		if(c<=siz){
			int ans=s[c][u],di=(dep[u]-dep[lca])%c;
			if(di==0)di=c;
			for(int i=16;~i;--i)
			if(dep[fa[i][u]]-dep[lca]>=di)u=fa[i][u];
			ans+=a[u]-s[c][u];
			if(dep[u]+dep[v]-(dep[lca]<<1)>=c){
				di=c-dep[u]+dep[lca];
				u=v;
				for(int i=16;~i;--i)
				if(dep[fa[i][u]]-dep[lca]>=di)u=fa[i][u];
				di=(dep[v]-dep[u])%c;
				if(di!=0)ans+=a[v];
				v=getfa(v,di);
				ans+=s[c][v]-s[c][u]+a[u];
			}else ans+=a[v];
			printf("%d\n",ans);
		}else{
			int ans=0;
			while(dep[u]-dep[lca]>c){
				ans+=a[u];
				u=getfa(u,c);
			}
			ans+=a[u];
			if(dep[u]+dep[v]-(dep[lca]<<1)>=c){
				int di=c-dep[u]+dep[lca];
				u=v;
				for(int i=16;~i;--i)
				if(dep[fa[i][u]]-dep[lca]>=di)u=fa[i][u];
				di=(dep[v]-dep[u])%c;
				if(di!=0)ans+=a[v];
				v=getfa(v,di);
				while(dep[v]-dep[u]>=c){
					ans+=a[v];
					v=getfa(v,c);
				}
				ans+=a[v];
			}else ans+=a[v];
			printf("%d\n",ans);
		}
	}
	return 0;
}
```

---

## 作者：Cui_Wenjia (赞：7)

[题目传送门](https://www.luogu.com.cn/problem/P3591)

这是一道应用了分块思想长链剖分题。

读完题后我们可以想到利用长链剖分来 $\operatorname{O}(1)$ 求 $k$ 级祖先。

我们发现当步伐 $k$ 很大的时候，复杂度是较小的，而当 $k$ 较小时复杂度会达到 $\operatorname{O}(n)$。

所以对于 $k$ 较小时我们可以考虑用类似树上差分的方法预处理出每个点到根的和。

为了权衡这两种方法我们可以用分块的思想。当 $k>\sqrt{n}$ 时我们使用前者，反之使用后者。

这样的话前者单次查询是 $\operatorname{O}(\sqrt{n})$，而后者预处理是 $\operatorname{O}(n\,\sqrt{n})$，可以保证总复杂度为$\operatorname{O}(n\,\sqrt{n})$。

详细实现请看代码和注释。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, sq, cnt, a[50005], b[50005];     //sq表示分界
int fi[50005], ne[100005], to[100005];  //邻接表存边
int d[50005], dep[50005], son[50005];   //d表示深度 dep表示到叶的长度
int g[50005], f[50005][20], top[50005]; //g[n]表示log2(n) f[x][k]表示x的2^k级祖先
int s[50005][250];                      //差分数组(对于不同的k分别处理)
vector<int> up[50005], down[50005];     //记录链顶的上下节点

void add(int u, int v)
{
    to[++cnt] = v;
    ne[cnt] = fi[u];
    fi[u] = cnt;
}

void dfs(int x) //第一次遍历
{
    dep[x] = d[x] = d[f[x][0]] + 1; //处理深度
    for (int i = fi[x]; i; i = ne[i])
    {
        int y = to[i];
        if (y == f[x][0])
            continue;
        f[y][0] = x;
        for (int j = 1; f[f[y][j - 1]][j - 1]; j++)
            f[y][j] = f[f[y][j - 1]][j - 1]; //预处理倍增数组
        dfs(y);
        if (dep[y] > dep[x]) //处理长儿子
            dep[x] = dep[y], son[x] = y;
    }
}

void dfs(int x, int p) //第二次遍历
{
    top[x] = p; //记录链顶
    for (int i = 1, o = f[x][0]; i <= sq; i++, o = f[o][0])
        s[x][i] = s[o][i] + a[x]; //预处理差分数组
    if (x == p)                   //如果是链顶的话记录他上下的节点
    {
        for (int i = 0, o = x; i <= dep[x] - d[x]; ++i)
            up[x].push_back(o), o = f[o][0];
        for (int i = 0, o = x; i <= dep[x] - d[x]; ++i)
            down[x].push_back(o), o = son[o];
    }
    if (son[x])
        dfs(son[x], p); //先处理长儿子
    for (int i = fi[x]; i; i = ne[i])
    {
        int y = to[i];
        if (y != f[x][0] && y != son[x])
            dfs(y, y);
    }
}

int ask(int x, int k) //O(1)求k级祖先
{
    if (d[x] - k <= 0)
        return 0;
    if (!k)
        return x;
    x = f[x][g[k]]; //先跳到2^g[k]级祖先
    k -= 1 << g[k];
    k -= d[x] - d[top[x]]; //然后跳到链顶
    x = top[x];
    if (k >= 0)
        return up[x][k]; //跳到k级祖先
    else
        return down[x][-k];
}

int lca(int x, int y) //LCA
{
    if (d[x] < d[y])
        swap(x, y);
    for (int i = g[d[x]]; i >= 0; --i) //先跳到同一层
        if (d[f[x][i]] >= d[y])
            x = f[x][i];
    if (x == y)
        return x;
    for (int i = g[d[x]]; i >= 0; --i) //一起往上跳
        if (f[x][i] != f[y][i])
            x = f[x][i], y = f[y][i];
    return f[x][0];
}

int main()
{
    clock_t c1 = clock();
#ifdef LOCAL
    freopen("in.in", "r", stdin);
    freopen("out.out", "w", stdout);
#endif
    scanf("%d", &n);
    sq = sqrt(n);
    g[0] = -1;                   //递推求log2(n)
    for (int i = 1; i <= n; ++i) //注意边界
        g[i] = g[i >> 1] + 1;
    for (int i = 1; i <= n; ++i)
        scanf("%d", &a[i]);
    for (int i = 1; i < n; ++i)
    {
        int u, v;
        scanf("%d%d", &u, &v);
        add(u, v);
        add(v, u);
    }
    for (int i = 1; i <= n; ++i)
        scanf("%d", &b[i]);
    dfs(1); //两次遍历
    dfs(1, 1);
    for (int i = 1; i < n; ++i)
    {
        int x = b[i], y = b[i + 1], c;
        scanf("%d", &c);
        int l = lca(x, y);
        int r = (d[x] - d[l]) % c; //对有余数的情况处理
        int R = (d[y] + d[x] - 2 * d[l]) % c;
        int ans = 0;
        if (c <= sq) //如果步伐较小
        {            //利用树上差分
            ans += s[x][c];
            ans -= s[ask(l, c - r)][c]; //x到l
            ans += s[ask(y, R)][c];
            ans -= s[ask(l, r)][c]; //y到l
        }
        else //如果步伐较大
        {    //暴力跳
            for (int t = x; d[t] >= d[l]; t = ask(t, c))
                ans += a[t];                                    //防止把l算两遍
            for (int t = ask(y, R); d[t] > d[l]; t = ask(t, c)) //第一次包括l
                ans += a[t];                                    //第二次不包括l
        }
        printf("%d\n", ans);
    }
    return 0;
}
```


---

## 作者：ppip (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P3591)

这是一个树剖+序列分块。感觉因为单纯树剖跑不满 log，比树上k级祖先+根号分治的做法要快一些。

对于查询的两个端点，记余数 $m_u,m_v$ 为 $1$。

每次树剖跳 $u$ 的时候，在序列上查询这一段模数为 $k$，且下标（从1开始）余数为 $m_u$ 的和，再令 $m_u=(m_u-l)\mod k$（$l$ 是查询区间的长度）。跳 $v$ 同理。

对 dfs 序进行分块，块大小为 $S$。每块对于 $1\leq k\leq S$ 的模数预处理出下标（从1开始）余数为 $0\leq m<k$ 的和。

散块暴力跳，跑完每个块，余数类似树剖那段进行变化。

如果查询的 $k\geq S$，就直接暴力跳整个区间。

一个小问题是树剖是倒着跳的，在正的 dfs 序上查询余数有点麻烦。

所以我们把每个点在 dfs 序上的位置变为 `n-dfn[x]+1`，相当于分块维护反 dfs 序。

本质类似根号分治做法，但充分利用了树剖的特性而不是每次就只跳 $S$。

取 $S=\sqrt{n}$，时间 $O(n\lg n\sqrt{n})$，空间 $\Theta(n\sqrt{n})$。

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read(){
    char c;int x,f{0};
    do x=(c=getchar())^48;
    while (!isdigit(c)&&c!='-');
    if (x==29) f=-1,x=0;
    while (isdigit(c=getchar()))
        x=(x<<3)+(x<<1)+(c^48);
    return (x^f)-f;
}
const int N(5e4),B{223*20},K{N/B+1};
// val是dfs序上的点权
int sum[B+5][K][K],val[N+5],a[N+5],n;
inline int R(int b){return b*K;}
inline int L(int b){return R(b-1)+1;}
inline int bl(int x){return (x-1)/K+1;};
int ppip(int l,int r,int k,int m)
{
    if (!m) m=k;
    int ans{0};
    for (int i{l+m-1};i<=r;i+=k)
        ans+=val[i];
    return ans;
}
// 序列分块
int query(int l,int r,int k,int m){
    if (bl(l)==bl(r)) return ppip(l,r,k,m);
    int ans{ppip(l,R(bl(l)),k,m)};
    m=(m+k-(R(bl(l))-l+1)%k)%k;
    assert(R(bl(r)-1)<=n);
    for (int i{bl(l)+1};i<bl(r);++i) {
        if (k>=K) {
            if (k==K&&m==0) ans+=val[R(i)];
            else if (m<=K&&m) ans+=val[L(i)+m-1];
        } else ans+=sum[i][k][m];
        m=(m+k-K%k)%k;
    }
    ans+=ppip(L(bl(r)),r,k,m);
    return ans;
}
int fa[N+5],dep[N+5],sz[N+5],son[N+5],tp[N+5];
int dfn[N+5];
vector<int> e[N+5];
// 树剖
void fz_init(int u,int f){
    fa[u]=f;dep[u]=dep[f]+1;sz[u]=1;
    for (auto v:e[u])
        if (v!=f) {
            fz_init(v,u);
            sz[u]+=sz[v];
            if (sz[v]>sz[son[u]])
                son[u]=v;
        }
}
void fz_cut(int u,int top){
    static int cxx{1};
    tp[u]=top;dfn[u]=cxx++;
    if (son[u]) fz_cut(son[u],top);
    for (auto v:e[u])
        if (v!=fa[u]&&v!=son[u])
            fz_cut(v,v);
}
int query(int u,int v,int k){
    int wu{1%k},wv{1%k},ans{0};
    while (tp[u]!=tp[v]){
        if (dep[tp[u]]<dep[tp[v]])
            swap(u,v),swap(wu,wv);
        // 注意反dfs序反着询问
        ans+=query(dfn[u],dfn[tp[u]],k,wu);
        wu=(wu+k-(dfn[tp[u]]-dfn[u]+1)%k)%k;
        u=fa[tp[u]];
    }
    if (dep[u]<dep[v]) swap(u,v),swap(wu,wv);
    ans+=query(dfn[u],dfn[v],k,wu);
    return ans;
}
int main(){
    n=read();
    for (int i{1};i<=n;++i)
        scanf("%d",a+i);
    for (int i{1};i<n;++i) {
        int a{read()},b{read()};
        e[a].push_back(b);
        e[b].push_back(a);
    }
    fz_init(1,0);fz_cut(1,1);
    for (int i{1};i<=n;++i)
        dfn[i]=n-dfn[i]+1;
    for (int i{1};i<=n;++i)
        val[dfn[i]]=a[i];
    for (int k{1};k<K;++k)
        for (int i{2};i<bl(n);++i)
            for (int j{L(i)};j<=R(i);++j)
                sum[i][k][(j-L(i)+1)%k]+=val[j];
    for (int i{1};i<=n;++i)
        a[i]=read();
    for (int i{1};i<n;++i) {
        int w{read()};
        printf("%d\n",query(a[i],a[i+1],w));
    }
    return 0;
}
```

随便跑跑就最优解第一页了。

---

## 作者：Alex_Wei (赞：6)

> [P3591 [POI2015]ODW](https://www.luogu.com.cn/problem/P3591)
>
> [POI 合集](https://www.cnblogs.com/alex-wei/p/POI.html)。

比较套路的根号分治题目。由于当步长 $>B$ 时最多走 $\dfrac n B$ 步，所以我们设置一个阈值 $B$，表示若步长 $\leq B$ 则使用预处理的信息，若步长 $>B$ 则暴力树上倍增计算。

预处理的信息只需要 $v_{k,u}$ 表示 $u$ 每次向上跳 $k$ 步能到达的所有节点权值之和，即 $\sum_{v\in \mathrm{ancestor}(u)}a_v[k\mid dep_u-dep_v]$。可以在 $\mathcal{O}(nB)$ 的复杂度内求得。

综上，时间复杂度 $\mathcal{O}\left(nB+\dfrac{n^2}{B}\log n\right)$，当 $B$ 取 $\sqrt{n\log n}$ 时有理论最优复杂度 $n\sqrt{n\log n}$。如果用长链剖分求树上 $k$ 级祖先则可做到严格 $n\sqrt n$。

由于数据原因，实际表现中取 $B=20$ 会很快。

```cpp
int n, a[N], b[N], lg[N];
int fa[16][N], dep[N], val[B][N];
vint e[N];
int kthanc(int u, int k) {
	for(int i = lg[k]; ~i; i--) if(k >> i & 1) u = fa[i][u];
	return u;
}
int LCA(int u, int v) {
	if(dep[u] < dep[v]) swap(u, v);
	for(int i = lg[dep[u]]; ~i; i--)
		if(dep[u] - dep[v] >> i & 1) u = fa[i][u];
	if(u == v) return u;
	for(int i = lg[dep[u]]; ~i; i--)
		if(fa[i][u] != fa[i][v]) u = fa[i][u], v = fa[i][v];
	return fa[0][u];
}
void dfs(int id, int f) {
	fa[0][id] = f, dep[id] = dep[f] + 1;
	for(int i = 1; i <= lg[dep[id]]; i++) fa[i][id] = fa[i - 1][fa[i - 1][id]];
	for(int i = 1, v = f; i < B; i++, v = fa[0][v])
		val[i][id] = a[id] + val[i][v];
	for(int it : e[id]) if(it != f) dfs(it, id);
}

int main() {
	cin >> n;
	for(int i = 2; i <= n; i++) lg[i] = lg[i >> 1] + 1;
	for(int i = 1; i <= n; i++) a[i] = read();
	for(int i = 1, u, v; i < n; i++) e[u = read()].pb(v = read()), e[v].pb(u);
	dfs(1, 0);
	for(int i = 1; i <= n; i++) b[i] = read();
	for(int i = 1, u, v, c; i < n; i++) {
		c = read(), u = b[i], v = b[i + 1];
		int d = LCA(u, v), ans = 0;
		if(c >= B) {
			ans = a[u] + a[v];
			while(1) {
				int anc = kthanc(u, c);
				if(dep[anc] < dep[d]) break;
				if(v == d && anc == d) break;
				ans += a[anc], u = anc;
			}
			int gap = dep[u] + dep[v] - (dep[d] << 1);
			if(gap % c) {
				int anc = kthanc(v, gap % c);
				if(dep[anc] > dep[d]) ans += a[anc], v = anc;
			}
			while(1) {
				int anc = kthanc(v, c);
				if(dep[anc] <= dep[d]) break;
				ans += a[anc], v = anc;
			}
		} else if(d == v)
			ans = a[v] + val[c][u] -
				val[c][kthanc(u, (dep[u] - dep[v] - 1) / c * c + c)];
		else {
			int gap = dep[u] - dep[d];
			int anc = kthanc(u, gap / c * c + c);
			ans += val[c][u] - val[c][anc];
			gap = dep[u] + dep[v] - (dep[d] << 1);
			if(gap % c) {
				int anc = kthanc(v, gap % c);
				if(dep[anc] > dep[d]) ans += a[v], v = anc;
			}
			if(v != d) {
				anc = kthanc(v, (dep[v] - dep[d] - 1) / c * c + c);
				ans += val[c][v] - val[c][anc];
			}
		} print(ans), pc('\n');
	}
	return flush(), 0;
}
```

---

## 作者：ywy_c_asm (赞：5)

发一个不带log的做法，就是显然是对c分块对吧，然后暴力往上面跳的时候我们可以使用长链剖分直接$O(1)$找k级祖先，就是在每个链顶开两个vector，一个按深度递增存这条链的点，一个按深度递减存他的所有到这个点距离不超过链长的祖先（相当于是等于链长的一条到祖先的链），我们先用倍增数组向上跳$2^{\log k}$步，找到这个点的链顶，显然这个k级祖先要么在这个链顶的祖先vector上，要么在这个链的vector上（因为已经跳了至少一半的距离了，别忘了这个是长链剖分），于是就可以做到$O(n\sqrt n)$。

~~其实我之所以不写倍增是因为开始的时候把分块的策略写反了T飞了以为卡log……然后就上了个这玩意……~~

上代码~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#define blo 223
using namespace std;
namespace ywy{
	inline int get(){
		int n=0;char c;while((c=getchar())||23333){
			if(c>='0'&&c<='9')break;if(c=='-')goto s;
		}n=c-'0';while((c=getchar())||23333){
			if(c>='0'&&c<='9')n=n*10+c-'0';else return(n);
		}s:while((c=getchar())||23333){
			if(c>='0'&&c<='9')n=n*10-c+'0';else return(n);
		}
	}
	void print(int num){
		if(num>=10)print(num/10);
		putchar(num%10+'0');
	}
	int b[50001],c[50001],ints[50001],f[50001][230],deep[50001],ance[50001][16];
	typedef struct _b{
		int dest;int nxt;
	}bian;
	bian memchi[100001];
	int gn=1,heads[50001],stk[50001],sp=0;
	inline void add(int s,int t){
		memchi[gn].dest=t;
		memchi[gn].nxt=heads[s];
		heads[s]=gn;gn++;
	}
	inline int lca(int a,int b){
		if(deep[a]>deep[b])swap(a,b);
		for(register int i=15;i>=0;i--){
			if(deep[ance[b][i]]>=deep[a])b=ance[b][i];
		}
		if(a==b)return(a);
		for(register int i=15;i>=0;i--){
			if(ance[a][i]!=ance[b][i])a=ance[a][i],b=ance[b][i];
		}
		return(ance[a][0]);
	}
	int mxdeep[50001],top[50001],zhongson[50001];//mxdeep是点的 
	void dfs(int pt,int baba){
		stk[sp]=pt;sp++;
		for(register int i=0;i<=blo;i++){
			if(deep[pt]<i)f[pt][i]=ints[pt];
			else f[pt][i]=ints[pt]+f[stk[deep[pt]-i]][i];
		}
		int mx=0,best=0;top[pt]=pt;
		for(register int i=heads[pt];i;i=memchi[i].nxt){
			if(memchi[i].dest==baba)continue;
			deep[memchi[i].dest]=deep[pt]+1;
			ance[memchi[i].dest][0]=pt;
			dfs(memchi[i].dest,pt);
			if(mxdeep[memchi[i].dest]>mx)mx=mxdeep[memchi[i].dest],best=memchi[i].dest;
		}
		sp--;zhongson[pt]=best;mxdeep[pt]=mx+1;
	}
	int lg[50001];
	vector<int> lian[50001],ba[50001];
	void efs(int pt,int baba){
		stk[sp]=pt;sp++;
		if(pt==top[pt]){
			for(register int i=sp-1;i>=0&&i>=sp-mxdeep[pt];i--)ba[pt].push_back(stk[i]);
		}
		lian[top[pt]].push_back(pt);
		if(zhongson[pt])top[zhongson[pt]]=top[pt],efs(zhongson[pt],pt);
		for(register int i=heads[pt];i;i=memchi[i].nxt){
			if(memchi[i].dest==baba||memchi[i].dest==zhongson[pt])continue;
			efs(memchi[i].dest,pt);
		}
		sp--;
	}
	inline int ga(int pt,int dai){
		if(deep[pt]<dai)return(0);
		if(!dai)return(pt);
		int ac=ance[pt][lg[dai]];dai-=(1<<lg[dai]);
		if(deep[ac]-deep[top[ac]]>=dai)return(lian[top[ac]][deep[ac]-deep[top[ac]]-dai]);
		return(ba[top[ac]][dai-(deep[ac]-deep[top[ac]])]);
	}
	void ywymain(){
		deep[0]=-1;int n=get();
		for(register int i=1;i<=n;i++)ints[i]=get();lg[0]=-1;
		for(register int i=1;i<n;i++){
			int s=get(),t=get();
			add(s,t);add(t,s);
			lg[i]=(lg[i-1]+(i==(i&-i)));
		}
		dfs(1,0);efs(1,0);
		for(register int i=1;i<=15;i++){
			for(register int j=1;j<=n;j++)ance[j][i]=ance[ance[j][i-1]][i-1];
		}
		for(register int i=1;i<=n;i++)b[i]=get();
		for(register int i=1;i<n;i++)c[i]=get();
		for(register int i=1;i<n;i++){
			int s=b[i],t=b[i+1],l=c[i],lc=lca(s,t);
			if(t==lc)swap(s,t);
			int len=deep[s]+deep[t]-2*deep[lc];
			if(l>=blo){
				int cur=s;
				int ans=0;
				while(deep[cur]>=deep[lc])ans+=ints[cur],cur=ga(cur,l);
				cur=t;
				int r=(deep[s]-deep[lc])%l;
				r=(deep[t]-deep[lc]+r)%l;if(r)ans+=ints[t];
				cur=ga(cur，r);
				while(deep[cur]>deep[lc])ans+=ints[cur],cur=ga(cur,l);
				print(ans);putchar('\n');
			}else{
				int ans=f[s][l]-f[ga(s,l*((deep[s]-deep[lc])/l+1))][l];
				int r=(deep[s]-deep[lc])%l;r=(deep[t]-deep[lc]+r)%l;
				if(r)ans+=ints[t]；
				int cur=ga(t,r);
				if(deep[cur]>deep[lc])ans+=(f[cur][l]-f[ga(cur,l*((deep[cur]-deep[lc])/l+1))][l]);
				if((deep[s]-deep[lc])%l==0&&(deep[t]-deep[lc])%l==0)ans-=ints[lc];
				print(ans);putchar('\n');
			}
		}
	}
}
int main(){
	ywy::ywymain();return(0);\\再见程序
}
```

---

## 作者：SDNetFriend (赞：4)

时间复杂度 $O(n\log n+n\sqrt n)$，代码只有 1.7K，似乎比现有题解都短。

考虑，因为保证路径长度被 $c$ 整除，就是说起点终点一定会被取到，这就方便了我们实现，显然是对于起点终点到 LCA 的路径分别求出答案加起来就可以了。

问题转化成了，每次询问树上一段路径的答案，保证路径起止点是祖先后代关系。

最基础的思路是根号分治，即我们考虑对于步长较大的询问一步一步向上跳统计答案，对于步长较小的用数据结构或者别的方式预处理出来然后直接查答案。

为了简化问题，我们再次把问题改成每次询问一个点到根的路径上，对应步长的权值和（当然保证从该点开始走），显然这个问题差分一下就能得到原问题答案。

我们把询问离线然后放到树上统一处理，首先考虑步长较大的，我们没必要去做长链剖分求 K 级祖先，只要在 DFS 的时候维护一个数组记录当前点到根对应深度的点是哪个就可以了，于是这部分问题就解决了。

然后我们考虑步长较小的，对于每一个步长，我们考虑存一个数组 $f_{i,j}$ 表示步长为 $i$，起点深度 $\bmod i=j$ 的答案。假设询问步长是 $c$ 当前点深度是 $d$ 那么要求答案直接查 $f_{c,d\bmod c}$ 就可以了，而且这个东西显然是很好维护的。

于是问题解决。另外这里根号分治取块长因为数据的问题，取 $25$ 左右可以跑得飞快。

### 代码

```cpp
#include <bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define se second
using namespace std;
inline int read(){
	char c;int f=1,res=0;
	while(c=getchar(),!isdigit(c))if(c=='-')f*=-1;
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
const int N=5e5+5,L=20,B=25;
int n,a[N],b[N],c[N];
int d[N],an[N][L],ans[N];
vector<int> ver[N],q[N];
void DFS0(int u,int pr){
	d[u]=d[pr]+1;an[u][0]=pr;
	for(int i=1;i<L;++i)
		an[u][i]=an[an[u][i-1]][i-1];
	for(int v:ver[u])
		if(v!=pr)DFS0(v,u);
}
inline int find(int u,int di){
	for(int i=0;i<L;++i,di>>=1)
		if(di&1)u=an[u][i];
	return u;
}
inline int LCA(int u,int v){
	if(d[u]<d[v])swap(u,v);
	if((u=find(u,d[u]-d[v]))==v)
		return u;
	for(int i=L-1;i>=0;--i)
		if(an[u][i]!=an[v][i])
			u=an[u][i],v=an[v][i];
	return an[u][0];
}
int s[B+5][B+5],st[N];
void DFS(int u){
	st[d[u]]=u;
	for(int i=1;i<=B;++i)
		s[i][d[u]%i]+=a[u];
	for(int _x:q[u]){
		int x=abs(_x),upd=0;
		if(c[x]<=B)
			upd=s[c[x]][d[u]%c[x]];
		else{
			for(int i=d[u];i>=0;i-=c[x])
				upd+=a[st[i]];
		}ans[x]+=(_x>0?1:-1)*upd;
	}for(int v:ver[u])
		if(v!=an[u][0])DFS(v);
	for(int i=1;i<=B;++i)
		s[i][d[u]%i]-=a[u];
}
int main(){
	n=read();
	for(int i=1;i<=n;++i)
		a[i]=read();
	for(int i=1;i<n;++i){
		int u=read(),v=read();
		ver[u].push_back(v);
		ver[v].push_back(u);
	}for(int i=1;i<=n;++i)b[i]=read();
	for(int i=1;i<n;++i)c[i]=read();
	d[0]=-1;DFS0(1,0);
	for(int i=1;i<n;++i){
		int u=b[i],v=b[i+1],w=LCA(u,v),di;
		di=(d[u]-d[w]+c[i]-1)/c[i]*c[i];
		q[u].push_back(i);q[find(u,di)].push_back(-i);
		di=(d[v]-d[w]+c[i])/c[i]*c[i];
		q[v].push_back(i);q[find(v,di)].push_back(-i);
	}DFS(1);
	for(int i=1;i<n;++i)
		printf("%d\n",ans[i]);
	return 0;
}

```



---

## 作者：Leasier (赞：4)

前置芝士：[LCA（最近公共祖先）](https://oi-wiki.org/graph/lca/)、根号分治（思想）

看到这种要一次走 / 跳 $k$ 步的题就应该想到根号分治 / 分块。

设定阈值 $B$，则当 $c_i \leq B$，预处理从每个点每次向上跳 $c_i$ 格一直跳到根节点所经过权值之和，查询时差分即可（注意要特判 LCA）；否则，直接用树上 $k$ 级祖先暴力跳。

令 $B = \sqrt{n}$，则时间复杂度为 $O(n \sqrt{n} \log n)$。

如果像我一样用倍增求树上 $k$ 级祖先，通过本题需要轻微卡常。值得一提的是，本题评测时波动较大（指同一份代码 $90 \operatorname{pts} \to 60 \operatorname{pts}$）。另外，注意答案不需要开 long long。

代码：
```cpp
#include <iostream>
#include <vector>
#include <cmath>

using namespace std;

typedef struct {
	int nxt;
	int end;
} Edge;

int cnt = 0;
int _log2[100007], a[50007], head[50007], depth[50007], fa[50007][17], sum[227][50007], b[50007];
Edge edge[100007];
vector<int> v[50007];

inline void init(int n){
	for (register int i = 2; i <= n; i++){
		_log2[i] = _log2[i >> 1] + 1;
	}
}

inline void add_edge(int start, int end){
	cnt++;
	edge[cnt].nxt = head[start];
	head[start] = cnt;
	edge[cnt].end = end;
}

void dfs(int u, int father){
	depth[u] = depth[father] + 1;
	v[depth[u]].push_back(u);
	fa[u][0] = father;
	for (register int i = 1; i <= _log2[depth[u]]; i++){
		fa[u][i] = fa[fa[u][i - 1]][i - 1];
	}
	for (register int i = head[u]; i != 0; i = edge[i].nxt){
		int x = edge[i].end;
		if (x != father) dfs(x, u);
	}
}

inline int walk_up(int u, int step){
	for (register int i = 0; i <= _log2[step]; i++){
		if (step >> i & 1) u = fa[u][i];
	}
	return u;
}

inline int lca(int u, int v){
	if (depth[u] < depth[v]) swap(u, v);
	u = walk_up(u, depth[u] - depth[v]);
	if (u == v) return u;
	for (register int i = _log2[depth[u]]; i >= 0; i--){
		if (fa[u][i] != fa[v][i]){
			u = fa[u][i];
			v = fa[v][i];
		}
	}
	return fa[u][0];
}

int main(){
	int n, m;
	cin >> n;
	m = ceil(sqrt(n));
	init(n * 2);
	for (register int i = 1; i <= n; i++){
		cin >> a[i];
	}
	for (register int i = 1; i < n; i++){
		int u, v;
		cin >> u >> v;
		add_edge(u, v);
		add_edge(v, u);
	}
	dfs(1, 0);
	for (register int i = 1; i <= m; i++){
		for (register int j = 1; j <= n; j++){
			int size = v[j].size();
			for (register int k = 0; k < size; k++){
				sum[i][v[j][k]] = sum[i][walk_up(v[j][k], i)] + a[v[j][k]];
			}
		}
	}
	for (register int i = 1; i <= n; i++){
		cin >> b[i];
	}
	for (register int i = 2, j = b[1]; i <= n; j = b[i++]){
		int c, cur_lca = lca(j, b[i]), t, ans;
		cin >> c;
		t = walk_up(b[i], (depth[j] + depth[b[i]] - depth[cur_lca] * 2) % c);
		if (c <= m){
			ans = (sum[c][j] - sum[c][walk_up(j, c * ((depth[j] - depth[cur_lca]) / c + 1))]) + (sum[c][t] - sum[c][walk_up(t, c * ((depth[t] - depth[cur_lca]) / c + 1))]);
			if ((depth[j] - depth[cur_lca]) % c == 0 && (depth[t] - depth[cur_lca]) % c == 0) ans -= a[cur_lca];
		} else {
			ans = 0;
			if ((depth[j] - depth[cur_lca]) % c == 0 && (depth[b[i]] - depth[cur_lca]) % c == 0) ans -= a[cur_lca];
			for (register int k = j; depth[k] >= depth[cur_lca]; k = walk_up(k, c)) ans += a[k];
			for (register int k = t; depth[k] >= depth[cur_lca]; k = walk_up(k, c)) ans += a[k];
		}
		cout << ans << endl;
	}
	return 0;
}
```

---

## 作者：殇雪 (赞：4)

SOL：

我们观察了一波局势，发现这道题有些眼熟。相比大家应该都做过这样一道题：给你一个静态的序列（所谓静态是指这个区间不会做任何的修改），M次给出X,L,K，让你求从X起的L个数的和，这L个数中间两两下表相间K（举个栗子：X=5，L=4，K=3，那么sum=a5+a8+a11+a14）。（N<=10W，M<=10W）


这道题我们的思想就是分块，我们发现当K很大时，我们暴力求和的速度是相当快的。因为我们发现 L<=N/K，我们的暴力复杂度是O(L)的。而K很小时，暴力就很慢了，接近于O(N)。我们又注意到K=1时便是前缀和，可以做到O（1）查询。那么我们不禁想当K很小时我们用前缀和优化（K>1有间距的前缀和相比大家都会）。


我们假设我们采取这样的策略，当K<S时我们用前缀和，K>S时我们采取暴力，那么我们就可以在最坏情况下O（n\*s+m\*n/s）下解决问题,那么我们解得S=sqrt N时最优。（实际上S取的稍微小一些会更快，因为我们刚刚计算的是最坏情况）


那么我们就可以做这一道题了，同样的思想，当K<sqrt N 时我们预处理，K > sqrt N 时我们便暴力向上跳。


case 1: K<sqrt N 我们预处理每个点 以K为间距向上跳的 答案，x的答案加上y的答案减去lca的答案就是了。


case 1: K>sqrt N 我们暴力做，我们每次用树上倍增的方法 log N 的方法向上跳，暴力统计答案，跳跳就好了。

代码见这里：http://www.cnblogs.com/rrsb/p/8127786.html


---

## 作者：jia_shengyuan (赞：3)

一道很好想但细节不少的分块题，这里给出一种不需要长链剖分的 $O(n\sqrt n)$ 做法。

做法很显然，预处理出步长为 $[1,\sqrt n]$ 时每个点向上跳到根经过的点权和（这个过程中自然也会处理出每个点的 $1\sim\sqrt n$ 级祖先）。对于一次步长为 $k$ 的询问，当 $1\le k \le\sqrt n$ 时直接树上差分即可，而当 $k>\sqrt n$ 时则暴力跳，因为跳的次数一定不会超过 $\sqrt n$。

但是第二种情况下，我们并无法高效地查询一个点的 $k $ 级祖先，否则时间复杂度就会多个 $\log$。于是我们可以每次只跳 $\sqrt n$ 步，用若干个 $\sqrt n$ 再加一个不大于 $\sqrt n$ 的常数拼成 $k$，显然这种情况下时间复杂度仍然是 $O(n\sqrt n)$ 的。

代码（用了我自己的快读快写库，不过并不妨碍阅读）：
```cpp
#include <fastio.hpp>
#include <vector>
#include <cmath>

const int maxn = 50009, maxs = 250;
using namespace std;

//sum[i][j]代表步长为j时从i跳到根的点权和，up[i][j]代表i的第j级祖先，fa[i][j]代表i的第2^j级祖先
int sum[maxn][maxs],up[maxn][maxs],fa[maxn][16],path[maxn],step[maxn],dep[maxn],n,lim;
vector<int> edges[maxn];

void Read(){
    read(n); lim = round(sqrt(n));
    for(int i=1; i<=n; i++) read(sum[i][0]);
    for(int i=1,u,v; i<n; i++){
        read(u,v);
        edges[u].push_back(v);
        edges[v].push_back(u);
    }
    readarr(path+1,n);
    readarr(step+1,n-1);
}
void Dfs(int now){
    dep[now] = dep[fa[now][0]]+1;
    for(int i=1; i<16; i++){
        fa[now][i] = fa[fa[now][i-1]][i-1];
    }
    up[now][0] = now;
    up[now][1] = fa[now][0];
    sum[now][1] = sum[now][0] + sum[fa[now][0]][1];
    for(int i=2; i<=lim; i++){
        up[now][i] = up[fa[now][0]][i-1];
        sum[now][i] = sum[now][0] + sum[up[now][i]][i];
    }
    for(int to : edges[now]){
        if(to == fa[now][0]) continue;
        fa[to][0] = now;
        Dfs(to);
    }
}

inline int LCA(int u, int v){
    if(dep[u] < dep[v]) swap(u,v);
    for(int i=15; ~i; i--){
        if(dep[fa[u][i]] >= dep[v]) u=fa[u][i];
    }
    if(u == v) return u;
    for(int i=15; ~i; i--){
        if(fa[u][i] != fa[v][i]){
            u=fa[u][i];
            v=fa[v][i];
        }
    }
    return fa[u][0];
}

int Walk(int u, int v, int dist) {
    int lca = LCA(u,v), res = 0;
    if(dist <= lim){ //树上差分
        if(lca == u) return sum[v][dist]-sum[up[u][dist]][dist];
        if(lca == v) return sum[u][dist]-sum[up[v][dist]][dist];
        res = sum[u][dist]+sum[v][dist];
        int tmp = fa[lca][0];
        while(tmp && dep[tmp]%dist != dep[u]%dist) tmp = fa[tmp][0];
        res -= sum[tmp][dist];
        tmp = lca;
        while(tmp && dep[tmp]%dist != dep[v]%dist) tmp = fa[tmp][0];
        res -= sum[tmp][dist];
        return res;
    }
    //暴力跳
    res = sum[u][0];
    while(dep[u] > dep[lca]){
        int walk = dist;
        while(walk > lim){
            u = up[u][lim];
            walk -= lim;
        }
        u = up[u][walk];
        if(dep[u] >= dep[lca]) res += sum[u][0];
    }
    if(u == v) return res;
    res += sum[v][0];
    while(dep[v] > dep[lca]){
        int walk = dist;
        while(walk > lim){
            v = up[v][lim];
            walk -= lim;
        }
        v = up[v][walk];
        if(dep[v] > dep[lca]) res += sum[v][0];
    }
    return res;
}

int main(){
    Read();
    Dfs(1);
    for(int i=1; i<n; i++){
        writeln(Walk(path[i],path[i+1],step[i]));
    }
    fastio_flush();
    return 0;
}
```


---

## 作者：1saunoya (赞：1)

令 $f_{i,j}$ 为 $i$ 往上跳 $j$ 步，直到不能跳为止的答案。

$j \leq \sqrt n$。

$f_{i,j} = f_{K(i,j),j} + val_i$。

这样预处理的复杂度是 $n \sqrt n$。

查询的时候做一个前缀和就好了。

然后如果跳 $j$，$j \geq \sqrt n$，那么直接跳。


代码鸽了

---

## 作者：_HL_ (赞：0)

$O(n\sqrt{n}\log n)$ 快到起飞？？ 最优解 rk2

## 根号分治 + 重链剖分

根号分治部分似乎楼上都说了 我也在提一嘴

步幅这种东西是天然与除法有关 考虑根号分治

一条路径最坏长 $O(n)$ 阈值 $s$

如果步幅长于 $s$ 直接暴力看起来就很可做 $O(\dfrac{n}{s})$ 后面乘个找到 $k$ 级祖先的复杂度 有 $k$ 大于 $s$

如果小于根号我们维护一个类似树上路径差分的东西 空间 $O(sn)$ 时间 $O(sn)$ 乘个找到 $k$ 级祖先的复杂度 有 $k$ 小于等于 $s$

我们考虑怎么搞 $k$ 级祖先 我太蒻了 不会长剖 我太懒了 不想写倍增

所以瞎搞个重剖 重剖 $\log n $ 找 $k$ 级祖先 挺好搞的 就在到根的路径上跳链 找就完了 然后就做完了 讨论一下阈值的取值

小于阈值的部分又耗空间 预处理查的次数还很多 所以阈值向小调

$s=\sqrt{n}$ 可过洛谷数据 bzoj 数据会 T 

$s=\dfrac{\sqrt{n}}{20}$ 就更快了 比根号快10倍（

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=5e4+3;
inline int read()
{
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c<='9'&&c>='0')
	{
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x;
}
int n,a[N],q[N],c[N];
struct edge
{
	int to,nxt;
}e[N<<1];
int h[N],etot;
inline void eadd(int x,int y)
{
	e[++etot].to=y;
	e[etot].nxt=h[x];
	h[x]=etot;
}
int dep[N],top[N],fa[N],exdfn[N],dfn[N],cnt,siz[N],son[N];
int w[120][N];
void dfs1(int x)
{
	int maxson=-1;
	w[1][x]+=a[x];
	siz[x]=1;
	for(int i=h[x];i;i=e[i].nxt)
	{
		if(e[i].to!=fa[x])
		{
			fa[e[i].to]=x;
			dep[e[i].to]=dep[x]+1;
			w[1][e[i].to]=w[1][x];
			dfs1(e[i].to);
			siz[x]+=siz[e[i].to];
			if(siz[e[i].to]>maxson)
			{
				maxson=siz[e[i].to];
				son[x]=e[i].to;
			}
		}
	}
}
void dfs2(int x,int topn)
{
	top[x]=topn;
	exdfn[++cnt]=x;
	dfn[x]=cnt;
	if(!son[x])return;
	dfs2(son[x],topn);
	for(int i=h[x];i;i=e[i].nxt)
	{
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
		dfs2(e[i].to,e[i].to);
	}
}
inline int get_fa(int x,int k)
{
	while(k>dep[x]-dep[top[x]]&&x)
	{
		k-=(dep[x]-dep[top[x]]+1);
		x=fa[top[x]];
	}
	if(dfn[x]-k&&x)
	return exdfn[dfn[x]-k];
	else
	return 0;
}
inline int get_lca(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y])swap(x,y);
	return x;
}
void build(int x,int k)
{
	w[k][x]=w[k][get_fa(x,k)]+a[x];
	for(int i=h[x];i;i=e[i].nxt)
	{
		if(e[i].to!=fa[x])
		build(e[i].to,k);
	}
}
int s;
inline int qes(int x,int y,int k)
{
	int lca=get_lca(x,y);
	if(k<=s)
	{
		int yy=(dep[x]-dep[lca])%k;
		if(yy)
		{
			yy=get_fa(lca,k-yy);
			int xx=(dep[y]-dep[lca])%k;
			xx=get_fa(lca,k-xx);
			return w[k][x]+w[k][y]-w[k][yy]-w[k][xx];
		}
		return w[k][y]+w[k][x]-w[k][lca]-w[k][get_fa(lca,k)];
	}
	else
	{
		int res=0;
		bool reo=0;
		while(dep[x]>=dep[lca])
		{
			res+=a[x];
			if(x==lca)reo=1;
			x=get_fa(x,k);
		}
		while(dep[y]>=dep[lca])
		{
			res+=a[y];
			y=get_fa(y,k);
		}
		if(reo)res-=a[lca];
		return res;
	}
}
int main()
{
	//freopen("in.txt","r",stdin);
	//freopen("out.txt","w",stdout);
	n=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<n;i++)
	{
		int x=read(),y=read();
		eadd(x,y);
		eadd(y,x);
	}
	for(int i=1;i<=n;i++)q[i]=read();
	for(int i=1;i<n;i++)c[i]=read();
	s=ceil(sqrt(n)/20);
	dep[1]=1;
	dfs1(1);
	dfs2(1,1);
	for(int i=2;i<=s;i++)build(1,i);
	for(int i=1;i<n;i++)
	{
		printf("%d\n",qes(q[i],q[i+1],c[i]));
	}
	return 0;
}
```


---

## 作者：krazy (赞：0)

这题实际上比较套路......

注意到 $n\le 50000$，大概率是想让我们用个 $\mathcal{O}(n\sqrt{n})$ 的复杂度。想到根号复杂度的话就很有可能是个根号分治。这题也不例外。

我们按照 $k$ 的大小分成两类：假设一个界为 $B=200$，当 $k\ge B$ 的时候就可以直接暴力模拟这个跳的过程，当 $k<B$ 的时候就可以考虑用什么东西来维护。

先说简单的部分：暴力向上跳。我们可以将路径 $x\to y$ 拆成 $x\to lca,lca \to y$。这样的话，我们需要距离 $x$ 为 $k$ 的祖先是哪一个（也就是 $x$ 的 $k$ 级祖先）。这一部分我们可以用长链剖分来搞，虽然慢了点但还是能过。这样的话，就可以将路径看成 $x$ 到 $lca$，$y$ 到 $lca$。

注意一个细节：$y$ 需要先往上跳一小段再暴力跳到 $lca$，因为题目中有说 “距离小于 $k$ 的话就直接一步跳到 $y$”。这样的话，因为 $y$ 往上跳与实际路径方向相反，所以需要先处理这一小段。

之后再说 $k<B$ 的部分。设 $s(i,j)$ 表示从 $i$ 开始每次跳 $j$ 步一直跳到根节点为止的路径上的点权和（当然也有可能跳不到根节点，但这个其实无所谓，因为这个时候再跳 $j$ 步的话已经跳出去了）。这一步有一个递推式子：设 $f(i,j)$ 表示 $i$ 的 $j$ 级祖先是哪个点，那么显然我们就有 $s(i,j)=s(f(i,j),j)+a_i$（$a_i$ 为点权），注意 $f(i,j)$ 可能不存在，这个时候就是 $s(i,j)=a_i$。

之后，我们可以算出 $s(x,k)$ 并减去在 $lca(x,y)$ 上方的部分贡献，同理也可以算出 $s(y,k)$ 并减去在 $lca(x,y)$ 上方的部分贡献。同时注意一下上面提到的细节即可。

综上，这个题就做完了。时间复杂度为 $\mathcal{O}(nB\log n)$

但是这题细节是真的超多......

```cpp
#include <bits/stdc++.h>
#define ll long long
#define ls id << 1
#define rs id << 1 | 1
#define mem(array, value, size, type) memset(array, value, ((size) + 5) * sizeof(type))
#define memarray(array, value) memset(array, value, sizeof(array))
#define pb(x) push_back(x)
#define st(x) (1LL << (x))
#define pii pair<int, int>
#define mp(a, b) make_pair((a), (b))
#define Flush fflush(stdout)
#define vecfirst (*vec.begin())
#define veclast (*vec.rbegin())
#define vecall(v) (v).begin(), (v).end()
#define vecupsort(v) (sort((v).begin(), (v).end()))
#define vecdownsort(v, type) (sort(vecall(v), greater<type>()))
#define veccmpsort(v, cmp) (sort(vecall(v), cmp))
using namespace std;
const int N = 50050;
const int inf = 0x3f3f3f3f;
const ll llinf = 0x3f3f3f3f3f3f3f3f;
const int mod = 998244353;
const int MOD = 1e9 + 7;
const double PI = acos(-1.0);
clock_t TIME__START, TIME__END;
void program_end()
{
#ifdef ONLINE
    printf("\nTime used: %.6lf(s)\n", ((double)TIME__END - TIME__START) / 1000);
    system("pause");
#endif
}
const int M = 201;
int s[N][M], a[N];
int n;
int b[N], d[N], f[N][16], son[N], dep[N], top[N], g[N];
vector<int> e[N], u[N], v[N];
void dfs(int x, int fa)
{
    dep[x] = d[x] = d[fa] + 1;
    f[x][0] = fa;
    for (int i = 1; (1 << i) <= d[x]; i++)
        f[x][i] = f[f[x][i - 1]][i - 1];
    for (auto y : e[x])
    {
        if (y == fa)
            continue;
        dfs(y, x);
        if (dep[y] > dep[x])
            dep[x] = dep[y], son[x] = y;
    }
}
inline int getlca(int a, int b)
{
    if (d[a] > d[b])
        swap(a, b);
    for (int i = 15; i >= 0; i--)
        if (d[a] <= d[b] - (1 << i))
            b = f[b][i];
    if (a == b)
        return a;
    for (int i = 15; i >= 0; i--)
    {
        if (f[a][i] == f[b][i])
            continue;
        else
            a = f[a][i], b = f[b][i];
    }
    return f[a][0];
}
inline int getdis(int x, int y) { return d[x] + d[y] - 2 * d[getlca(x, y)]; }
void dfs(int x, int p, int fa)
{
    top[x] = p;
    if (x == p)
    {
        for (int i = 0, o = x; i <= dep[x] - d[x]; ++i)
            u[x].pb(o), o = f[o][0];
        for (int i = 0, o = x; i <= dep[x] - d[x]; ++i)
            v[x].pb(o), o = son[o];
    }
    if (son[x])
        dfs(son[x], p, f[son[x]][0]);
    for (auto y : e[x])
        if (y != son[x] && y != fa)
            dfs(y, y, x);
}
inline int ask(int x, int k)
{
    if (!k)
        return x;
    x = f[x][g[k]], k -= 1 << g[k], k -= d[x] - d[top[x]], x = top[x];
    return k >= 0 ? (k < (int)u[x].size() ? u[x][k] : -1) : (k < (int)v[x].size() ? v[x][-k] : -1);
}
void dfs2(int x, int fa)
{
    for (int j = 1; j < M; ++j)
    {
        if (ask(x, j) == -1)
            s[x][j] = a[x];
        else
            s[x][j] = s[ask(x, j)][j] + a[x];
    }
    for (auto vv : e[x])
    {
        if (vv == fa)
            continue;
        dfs2(vv, x);
    }
}

inline int queryBig(int x, int y, int k)
{
    int resx = 0, resy = 0;
    int lca = getlca(x, y), D = getdis(x, y);
    int dx = getdis(x, lca), dy = getdis(y, lca);
    if (lca == x)
    {
        int ry = D % k;
        if (ry)
            resy += a[y];
        y = ask(y, ry);
        while (~y && d[y] >= d[lca])
            resy += a[y], y = ask(y, k);
        return resy;
    }
    while (~x && d[x] > d[lca])
        resx += a[x], x = ask(x, k);
    if (lca == y)
        return resx + a[y];
    int ry = D % k;
    if (ry)
        resy += a[y];
    y = ask(y, ry);
    while (~y && d[y] > d[lca])
        resy += a[y], y = ask(y, k);
    if (dx % k == 0 || dy % k == 0)
        resx += a[lca];
    return resx + resy;
}
inline int querySmall(int x, int y, int k)
{
    int resx = 0, resy = 0;
    int lca = getlca(x, y), D = getdis(x, y);
    int ry = D % k;
    if (ry)
        resy += a[y];
    if (lca == x)
    {
        y = ask(y, ry);
        int lcay = ask(lca, k);
        resy += (y == -1 ? 0 : s[y][k]) - (lcay == -1 ? 0 : s[lcay][k]);
        return resy;
    }
    if (lca == y)
    {
        int lcax = ask(lca, k - D % k);
        resx += s[x][k] - (lcax == -1 ? 0 : s[lcax][k]);
        return resx;
    }
    int dx = getdis(x, lca);
    int lcax = ask(lca, k - dx % k);
    resx += s[x][k] - (lcax == -1 ? 0 : s[lcax][k]);
    y = ask(y, ry);
    int lcay = ask(lca, dx % k);
    resy += (y == -1 ? 0 : s[y][k]) - (lcay == -1 ? 0 : s[lcay][k]);
    return resx + resy;
}

inline void solve()
{
    scanf("%d", &n);
    g[0] = -1;
    for (int i = 1; i <= n; ++i)
        g[i] = g[i >> 1] + 1, scanf("%d", &a[i]);
    for (int i = 1; i < n; ++i)
    {
        int x, y;
        scanf("%d%d", &x, &y);
        e[x].push_back(y), e[y].push_back(x);
    }
    dfs(1, 0);
    dfs(1, 1, 0);
    dfs2(1, 0);
    for (int i = 1; i <= n; ++i)
        scanf("%d", &b[i]);
    int uu, vv, k;
    for (int i = 2; i <= n; ++i)
    {
        scanf("%d", &k);
        int ans = 0;
        if (k >= M)
            ans = queryBig(b[i - 1], b[i], k);
        else
            ans = querySmall(b[i - 1], b[i], k);
        printf("%d\n", ans);
    }
}

int main()
{
    TIME__START = clock();
    int Test = 1;
    // scanf("%d", &Test);
    while (Test--)
        solve();
    TIME__END = clock();
    program_end();
    return 0;
}
```


---

## 作者：学委 (赞：0)

发现很大的步长可以直接模拟，很小的步长可以用前缀和的方式预处理，用sum[i][k]表示从i往root跳，步长为k的情况下的权值和，当询问x跳y时求出lca。显然边界是n^0.5。

注意各种边界情况。

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
using std::swap;
const int N = 5e4 + 10, R = sqrt(5e4) + 10, E = 1e5 + 10;
int n, siz, val[N], b[N];
int sum[N][R];
int first[N], to[E], nxt[E], cnt = 0;
inline void adde(int u, int v) {
  to[++cnt] = v, nxt[cnt] = first[u];
  first[u] = cnt;
}
int dep[N], fa[N][16], s[N], top = 0;
void dfs(int u, int f) {
  fa[u][0] = f;
  dep[u] = dep[f] + 1;
  s[++top] = u;
  for (int i = 1; i <= siz; ++i) {
    int f = dep[u] - i; if (f < 0) f = 0;
    sum[u][i] = sum[s[f]][i] + val[u];
  }
  for (int p = first[u]; p; p = nxt[p]) {
    int v = to[p]; if (v == f) continue;
    dfs(v, u);
  } --top;
}
inline int getlca(int x, int y) {
  if (dep[x] < dep[y]) swap(x, y);
  for (int t = 15; t >= 0; --t) if (dep[fa[x][t]] >= dep[y]) x = fa[x][t];
  if (x == y) return x;
  for (int t = 15; t >= 0; --t) if (fa[x][t] != fa[y][t]) x = fa[x][t], y = fa[y][t];
  return fa[x][0];
}
inline int getf(int x, int len) {
  for (int t = 15; t >= 0; --t)
    if (len >= (1 << t))
      x = fa[x][t], len -= (1 << t);
  return x;
}
signed main() {
  scanf("%d", &n); siz = sqrt(n);
  for (int i = 1; i <= n; ++i) scanf("%d", &val[i]);
  for (int i = 1; i <= n - 1; ++i) {
    int u, v; scanf("%d %d", &u, &v);
    adde(u, v), adde(v, u);
  }
  dfs(1, 0);
  for (int t = 1; t <= 15; ++t)
    for (int i = 1; i <= n; ++i)
      fa[i][t] = fa[fa[i][t - 1]][t - 1];
  for (int i = 1; i <= n; ++i) scanf("%d", &b[i]);
  for (int i = 1; i <= n - 1; ++i) {
    int k, x = b[i], y = b[i + 1]; scanf("%d", &k); // b[i], b[i + 1]
    int lca = getlca(x, y); int ans = 0;
    if (k > siz) {
      while (dep[x] > dep[lca]) {
        ans += val[x];
        int f = getf(x, k);
        if (dep[f] > dep[lca]) x = f;
        else break;
      }
      ans += val[y]; y = fa[y][0];
      if (dep[y] >= dep[lca]) {
        int d = (dep[y] - dep[lca] + dep[x] - dep[lca]) / k;
        for (int t = 15; t >= 0; --t)
          if (dep[fa[y][t]] >= dep[lca] and (dep[fa[y][t]] - dep[lca] + dep[x] - dep[lca]) / k == d)
            y = fa[y][t];
      }
      if ((dep[y] - dep[lca] + dep[x] - dep[lca]) % k == 0) while (dep[y] >= dep[lca]) {
        ans += val[y];
        y = getf(y, k);
      }
    }
    else {
      if (x != lca) {
        int d = (dep[x] - (dep[lca] + 1)) / k;
        int f = getf(x, d * k);
        ans = ans + sum[x][k] - sum[f][k] + val[f];
        x = f;
      }
      ans += val[y]; y = fa[y][0];
      while (dep[y] >= dep[lca] and (dep[y] - dep[lca] + dep[x] - dep[lca]) % k != 0)
        y = fa[y][0];
      if (dep[y] >= dep[lca]) {
        int d = (dep[y] - dep[lca]) / k;
        int f = getf(y, d * k);
        ans = ans + sum[y][k] - sum[f][k] + val[f];
      }
    }
    printf("%d\n", ans);
  }
  return 0;
}
```

---


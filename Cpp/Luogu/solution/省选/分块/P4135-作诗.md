# 作诗

## 题目背景

神犇 SJY 虐完 HEOI 之后给傻× LYD 出了一题：

SHY 是 T 国的公主，平时的一大爱好是作诗。

## 题目描述

由于时间紧迫，SHY 作完诗之后还要虐 OI，于是 SHY 找来一篇长度为 $n$ 的文章，阅读 $m$ 次，每次只阅读其中连续的一段 $[l,r]$，从这一段中选出一些汉字构成诗。因为 SHY 喜欢对偶，所以 SHY 规定最后选出的每个汉字都必须在 $[l,r]$ 里出现了正偶数次。而且 SHY 认为选出的汉字的种类数（两个一样的汉字称为同一种）越多越好（为了拿到更多的素材！）。于是 SHY 请 LYD 安排选法。

LYD 这种傻×当然不会了，于是向你请教……

问题简述：给定 $n$ 个不大于 $c$ 的正整数 $a_1 \dots a_n$ 和 $m$ 组询问，每次问 $[l,r]$ 中有多少个数出现正偶数次。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，$1\le n,c,m\le 10^5$，$1 \leq a_i \leq c$，$1 \leq l, r \leq n$。

## 样例 #1

### 输入

```
5 3 5
1 2 2 3 1
0 4
1 2
2 2
2 3
3 5```

### 输出

```
2
0
0
0
1```

# 题解

## 作者：i207M (赞：47)

## 题意

N个数，M组询问，每次问[l,r]中有多少个数出现正偶数次。

~~c的作用？？？~~

~~纪念一下自己YY出的一道分块水题~~

## 方法

其实这题就是在预处理时难住我了，如何保证$O(N\sqrt{N})$内预处理完？

$cnt[i][j]$表示第i块开始到结尾，j的出现次数；

$f[i][j]$表示i块开头到j块末尾的答案；


```
	for (ri i = 1; i <= bl[n]; ++i) {
		int t = 0;
		for (ri j = l[i]; j <= n; ++j) {
			cnt[i][a[j]]++;
			if ((cnt[i][a[j]] & 1) && (cnt[i][a[j]] > 1)) t--;
			else if ((cnt[i][a[j]] & 1) == 0) t++;
			if (bl[j] != bl[j + 1]) {
				f[i][bl[j]] = t;
			}
		}
	}
```

重点在于，不能先处理好每个块的答案，然后再枚举合并求出$f[i][j]$，不然复杂度爆炸，必须一边扫一边求；

然后统计就很好说了，分情况讨论即可；

注意ans的初值为f[bl[ql] + 1][bl[qr] - 1]；

```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<string>
#include<algorithm>
#include<vector>
#include<map>
#include<set>
#include<list>
#include<queue>
#include<stack>
#include<bitset>
#include<deque>
using namespace std;
#define ll long long
#define inf 0x3f3f3f3f
#define ri register int
#define il inline
#define fi first
#define se second
#define mp make_pair
#define pi pair<int,int>
#define mem0(x) memset((x),0,sizeof (x))
#define mem1(x) memset((x),0x3f,sizeof (x))
il char gc() {
	static const int BS = 1 << 22;
	static unsigned char buf[BS], *st, *ed;
	if (st == ed) ed = buf + fread(st = buf, 1, BS, stdin);
	return st == ed ? EOF : *st++;
}
#define gc getchar
template<class T>void in(T &x) {
	x = 0;
	bool f = 0;
	char c = gc();
	while (c < '0' || c > '9') {
		if (c == '-') f = 1;
		c = gc();
	}
	while ('0' <= c && c <= '9') {
		x = (x << 3) + (x << 1) + (c ^ 48);
		c = gc();
	}
	if (f) x = -x;
}
#undef gc
#define pb push_back
#define N 100010
#define B 320
int n, m;
int a[N];
int block, bl[N];
int l[B];
int f[B][B];
int cnt[B][N];
int st[N], top;
int num[N];
// bitset<N>h[B][B], tmp;
signed main() {
#ifndef ONLINE_JUDGE
	freopen("in.in", "r", stdin);
#endif
	int ans = 0, cc, ql, qr;
	in(n), in(cc), in(m);
	block = sqrt(n);
	for (ri i = 1; i <= n; ++i) {
		in(a[i]);
		bl[i] = (i - 1) / block + 1;
		if (bl[i] != bl[i - 1]) l[bl[i]] = i;
	}
	bl[n + 1] = bl[n] + 1;
	l[bl[n + 1]] = n + 1;
	for (ri i = 1; i <= bl[n]; ++i) {
		int t = 0;
		for (ri j = l[i]; j <= n; ++j) {
			cnt[i][a[j]]++;
			if ((cnt[i][a[j]] & 1) && (cnt[i][a[j]] > 1)) t--;
			else if ((cnt[i][a[j]] & 1) == 0) t++;
			if (bl[j] != bl[j + 1]) {
				f[i][bl[j]] = t;
			}
		}
	}
	while (m--) {
		in(ql), in(qr);
		ql = (ql + ans) % n + 1, qr = (qr + ans) % n + 1;
		if (ql > qr) swap(ql, qr);
		ans = 0;
		if (bl[ql] == bl[qr]) {
			for (ri i = ql; i <= qr; ++i) {
				num[a[i]]++;
				st[++top] = a[i];
			}
			while (top) {
				if (num[st[top]] != 0) {
					ans += (num[st[top]] & 1) ^ 1;
					num[st[top]] = 0;
				}
				top--;
			}
			printf("%d\n", ans);
			continue;
		}
		if (bl[ql] + 1 <= bl[qr] - 1) ans = f[bl[ql] + 1][bl[qr] - 1];
		for (ri i = ql; i < l[bl[ql] + 1]; ++i) {
			num[a[i]]++;
			st[++top] = a[i];
		}
		for (ri i = l[bl[qr]]; i <= qr; ++i) {
			num[a[i]]++;
			st[++top] = a[i];
		}
		while (top) {
			int t = st[top];
			if (num[t] != 0) {
				if ((cnt[bl[ql] + 1][t] - cnt[bl[qr]][t] > 0) && ((cnt[bl[ql] + 1][t] - cnt[bl[qr]][t]) & 1) == 0 && (num[st[top]] & 1)) {
					ans--;
				}
				else if (((cnt[bl[ql] + 1][t] - cnt[bl[qr]][t] > 0) && ((cnt[bl[ql] + 1][t] - cnt[bl[qr]][t]) & 1)) && (num[st[top]] & 1)) {
					ans++;
				}
				else if ((cnt[bl[ql] + 1][t] - cnt[bl[qr]][t] == 0) && (num[st[top]] & 1) == 0) {
					ans++;
				}
				num[st[top]] = 0;
			}
			top--;
		}
		printf("%d\n", ans);
	}
	return 0;
}
```

---

## 作者：Endt (赞：23)

# 作诗-题解

>   题目链接：[洛谷-P4135](https://www.luogu.com.cn/problem/P4135)

**一句话题意**：求 $[l,r]$ 中出现正偶数次的数的个数，强制在线。

## 分析

### $Part1$ 选择算法&数据结构

> 对于 $100 \%$ 的数据， $1\le n,c,m\le 10^5$

这种数据范围显然需要单次询问的复杂度达到 $\sqrt n$ 或者 $\log n$ ，又看到区间查询，我们会想到什么？

**分块，线段树，树状数组**

树状数组扩展性太差了，首先排除。

再看看我们要维护什么，容易发现，答案是不可以直接叠加的，那么在合并两个区间的答案时，需要知道区间中数的出现次数，这样才能求出与出现次数有关的区间和。如果使用线段树，在每一个节点开桶会导致`MLE`（也会`TLE`），现在就只能考虑分块了。

### $Part2$ 实现

##### 块维护什么？

块内的答案应该预处理得到，避免重复计算。 $Part1$ 中也提到了，还应给每一个整体（即块）配一个桶。

下面，重点关注区间答案的求解与合并。

（注：$a_i$ 表示整个序列的第 $i$ 个数， $numi_x$ 表示区间 $i$ 中 $x$ 的出现次数， $ansi$ 表示区间 $i$ 出现正偶数次的数的个数， $leni$ 表示区间 $i$ 的长度）

1. ##### 求 $ansi$

    遍历区间 $i$ ， $numi_{a_{now}}$ 加 $1$ 。如果 $numi_{now}$ 为正偶数，说明多了一个符合条件的数 $ansi$ 加 $1$ 。如果 $numi_{now}$ 为正奇数数且不等于 $1$，说明少了一个符合条件的数， $ansi$ 减 $1$ 。

    小例子：

    ```
    a:   1  2  2  3  1  2  3  2  3
    num1:1  1  1  1  2  2  2  2  2
    num2:0  1  2  2  2  3  3  4  4
    num3:0  0  0  1  1  1  2  2  3
    ans: 0  0  1  1  2  1  2  3  2
    ```

    $ans$ 的变化及原因： $+1$ （ $2$ 的个数变成 $2$ ） $+1$ （ $1$ 的个数变成 $2$ ） $-1$ （ $2$ 的个数变成 $3$ ） $+1$ （ $3$ 的个数变成 $2$ ） $+1$ （ $2$ 的个数变成 $4$ ） $-1$ （ $3$ 的个数变成 $3$ ）

    复杂度： $O(leni)$

2. ##### 求 $ans(i+j)$
   
    可以看作正常求区间时已经处理了一部分（ $i$ ），如此可以 $i$ 为基础，遍历区间 $j$ ，和上一个问题同样增减 $ans$ 。
    
    复杂度： $O(lenj)$

#### 预处理

1. ##### 分块基本变量&数组

    块长取 $\sqrt n$ 即可。

2. ##### $num$ 数组

    暴力求。

    复杂度： $O(n)$

    ```cpp
    for(int j=ll[i];j<=rr[i];++j)++num[i][a[j]];
    ```

3. ##### $ans$ 数组

    用上文提到的方法求。

    复杂度： $O(n)$
    
    ```cpp
    for(int j=ll[i];j<=rr[i];++j){
        ++tong[a[j]];
        if(tong[a[j]]%2==0){
            ++ans[i];
        }else if(tong[a[j]]!=1){
            --ans[i];
        }
    }
    ```

### $Part3$ 优化

> 这分块和没分一样啊，合并整块要 $\sqrt{n}$ 次 $\sqrt{n}$ ，不就是暴力的复杂度吗？	—zsc985246

的确，目前还并没有体现出分块的根号优势，零散块处理已经没问题了，现在的目标是让整块的合并复杂度达到 $O(\sqrt{n})$ 以下。

加速的方式仍然是预处理，重新定义 $ans_{i,j}$ 表示从第 $i$ 个块到第 $j$ 个块的区间答案。为了配合新的 $ans$ 数组，我们也将 $num$ 前缀和，以便迅速得出多个块连结后的 $num$ 。

显然 $ans_{i,i\to j}$ 的值可以线性求出，轻松推得 $ans_{i,j}=ans_{(i,j-1)+j}$ 。

```cpp
for(int i=1;i<=nb;++i){
    for(int j=i;j<=nb;++j){
        ans[i][j]=ans[i][j-1];
        for(int k=ll[j];k<=rr[j];++k){
            ++tong[a[k]];
            if(tong[a[k]]%2==0){
                ++ans[i][j];
            }else if(tong[a[k]]!=1){
                --ans[i][j];
            }
        }
    }
    for(int j=0;j<=c;++j)tong[j]=0;
}
```

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

inline int read_int(){//快读
	int x=0;char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+(c-'0');
		c=getchar();
	}
	return x;
}

int a[100005];//原序列
int num[350][100005];//块的专用桶
int ans[350][350];//从i到j的答案
int n,m,c;//意义如题
int lb,nb;//块长与块个数
int l,r;//意义如题
int ll[350],rr[350],mm[100005];//块的左端点、右端点及单点所在块
inline int number(int l,int r,int x){//块l到块r中x的个数
	return num[r][x]-num[l-1][x];
}
int A;//答案
int tong[100005];//临时桶
void solve(){
	A=0;
	int lb=mm[l],rb=mm[r];
	if(rb-lb<=1){//没有整块，直接暴力
		for(int i=l;i<=r;++i){
			++tong[a[i]];
			if(tong[a[i]]%2==0){
				++A;
			}else if(tong[a[i]]!=1){
				--A;
			}
		}
        //临时桶还原
		for(int i=l;i<=r;++i){
			--tong[a[i]];
		}
	}else{//一般情况
		A=ans[lb+1][rb-1];//整块的答案
        //左侧零散块暴力
		for(int i=l;i<=rr[lb];++i){
			++tong[a[i]];
			if((tong[a[i]]+number(lb+1,rb-1,a[i]))%2==0){
				++A;
			}else if(tong[a[i]]+number(lb+1,rb-1,a[i])!=1){
				--A;
			}
		}
        //右侧零散块暴力
		for(int i=ll[rb];i<=r;++i){
			++tong[a[i]];
			if((tong[a[i]]+number(lb+1,rb-1,a[i]))%2==0){
				++A;
			}else if(tong[a[i]]+number(lb+1,rb-1,a[i])!=1){
				--A;
			}
		}
        //临时桶还原
		for(int i=l;i<=rr[lb];++i){
			--tong[a[i]];
		}
		for(int i=ll[rb];i<=r;++i){
			--tong[a[i]];
		}
	}
}

int main(){
	n=read_int();c=read_int();m=read_int();
	lb=sqrt(n);nb=n/lb;if(lb*nb<n)++nb;//块长与块个数
    //预处理
	for(int i=1;i<=nb;++i){//块端点预处理
		ll[i]=(i-1)*lb+1;
		rr[i]=(i<nb)?i*lb:n;
	}
	for(int i=1;i<=nb;++i){
		for(int j=ll[i];j<=rr[i];++j){
			a[j]=read_int();
			mm[j]=i;//点所在块预处理
			++num[i][a[j]];//桶预处理
		}
		for(int j=0;j<=c;++j){//前缀和
			num[i][j]+=num[i-1][j];
		}
	}
	for(int i=1;i<=nb;++i){//整块答案预处理
		for(int j=i;j<=nb;++j){
			ans[i][j]=ans[i][j-1];
			for(int k=ll[j];k<=rr[j];++k){
				++tong[a[k]];
				if(tong[a[k]]%2==0){
					++ans[i][j];
				}else if(tong[a[k]]!=1){
					--ans[i][j];
				}
			}
		}
        //临时桶还原
		for(int j=0;j<=c;++j)tong[j]=0;
	}
	
    //解决
	while(~--m){
		l=read_int();r=read_int();
		l=(l+A)%n+1;r=(r+A)%n+1;
		if(l>r)swap(l,r);//解密
		solve();
		printf("%d\n",A);
	}
	
	return 0;
}
```

## 总结

此题有很多数据都需要通过预处理或信息复用计算，要熟练掌握常见的优化方法，尽可能避免重复的运算。



---

## 作者：Yaha (赞：18)

### 分块

 **题意**：
 
 给定数列，$m$次询问$[l_i,r_i]$中，出现正偶数次的数的个数。

**思路**：

想到分块暴力。预处理出：

**$cnt[i][j]$ 为前$i$块中 $j$出现的次数**，**$ans[i][j]$为第$i$块到第$j$块中 出现偶数次的数的个数**

我的变量：

- $l[i] $为第$i$块的左端点，$r[i]$为第$i$块的右端点，$pos[i]$为$i$点所在的块，$len$为块的长度，$num$为块的个数
- $cnt[i][j]$ 为前$i$块中 $j$出现的次数，$ans[i][j]$为第$i$块到第$j$块中 出现偶数次的数的个数
- $t[i]$为桶，每次用完清零

代码里有详细注释，（个人觉得分块题用这种写法较其他题解更好写且不易错

```cpp
#include<bits/stdc++.h>
using namespace std;
const int amou=1e5+90,sqt=1e3+90;
int l[amou],r[amou],pos[amou],len,num;
int a[amou],n,m,c,las;
int cnt[sqt][amou],ans[sqt][sqt];
int t[amou];

int query(int ll,int rr){
	int posl=pos[ll],posr=pos[rr];
	if(posl+1>=posr)//只有1个块或者2个块都可以直接暴力
	{
		int s=0;//答案，即出现偶数次的数的个数
		for(int i=ll;i<=rr;i++)
		{
			t[a[i]]++;//桶
			if(!(t[a[i]]&1)) s++;//说明在t[]在+1之前是奇数，所以这是一种新方案
			else if(t[a[i]]>=3) s--;//说明t[]在+1之前是偶数，并且之前的t[]>=2，故s需-1
		}
		for(int i=ll;i<=rr;i++) t[a[i]]--;//由于memset超时，所以直接撤销
		return s;
	}
	else
	{
		int s=ans[posl+1][posr-1];
 		for(int i=ll;i<=r[posl];i++)
		{
			t[a[i]]++;
			int temp=cnt[posr-1][a[i]]-cnt[posl][a[i]];//a[i]在posl+1~posr-1这几个块中出现的次数 
			if(!((t[a[i]]+temp)&1))  s++;
			else if(t[a[i]]+temp>=3) s--;
		}
		for(int i=l[posr];i<=rr;i++)
		{
			t[a[i]]++;
			int temp=cnt[posr-1][a[i]]-cnt[posl][a[i]];
			if(!((t[a[i]]+temp)&1))  s++;
			else if(t[a[i]]+temp>=3) s--;
		}
		for(int i=ll;i<=r[posl];i++) t[a[i]]--;
		for(int i=l[posr];i<=rr;i++) t[a[i]]--;
		return s;
	}
}

int main(){
	scanf("%d%d%d",&n,&c,&m);
	len=sqrt(n);
	num=ceil(n*1.0/len);
	for(int i=1;i<=num;i++)
	{
		l[i]=(i-1)*len+1;
		r[i]=i*len;
	}
	r[num]=n;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		pos[i]=(i-1)/len+1;
		cnt[pos[i]][a[i]]++;
	}
	for(int i=1;i<=num;i++)
		for(int j=0;j<=c;j++)
			cnt[i][j]+=cnt[i-1][j];//累加前缀和 
	for(int i=1;i<=num;i++)//固定块i
	{
		for(int j=i;j<=num;j++)枚举右端块j
		{
			ans[i][j]=ans[i][j-1];//作为初始值
			for(int k=l[j];k<=r[j];k++)//枚举块j的左右端点
			{
				t[a[k]]++;
				if(!(t[a[k]]&1)) ans[i][j]++;
				else if(t[a[k]]>=3) ans[i][j]--;
			}
		}
		memset(t,0,sizeof t);//桶用完清零
	}
	while(m--)
	{
		int l,r;
		scanf("%d%d",&l,&r);
		int L=(l+las)%n+1,R=(r+las)%n+1;
		if(L>R) swap(L,R);
		int as=query(L,R);
		printf("%d\n",as);
		las=as;
	}
	return 0;
}
```


---

## 作者：Aestas16 (赞：17)

提供一个跑得飞快的做法。

考虑使用 $\text{bitset}$ 维护值域进行查询，加入一个数就相当于将某一位 $\text{flip}$。

发现这样不能很好的求出偶数数量，考虑 偶数数量 = 总数量 - 奇数数量，后两者都可以直接通过 $\text{count}$ 求出。

则每一次询问可以转换为：

- 取出一段区间内 $\text{bitset}$ 的并，计算 $1$ 的数量（区间总数量）
- 取出一段区间内 $\text{bitset}$ 的异或和，计算 $1$ 的数量（区间奇数数量）

暴力维护 $n$ 个 $\text{bitset}$ 的话空间显然吃不消，考虑分块，一个块里面维护块内所有 $\text{bitset}$ 的 并 / 异或和，查询时块内直接累加，块外暴力将数插入 $\text{bitset}$ 内。

这样做时间复杂度 $\Theta(m \times \dfrac{n}{S} \times \dfrac{c}{w})$，空间复杂度 $\Theta(\dfrac{n}{S} \times \dfrac{c}{8})$，$S$ 为块长。

发现空间复杂度没问题了，但是时间复杂度爆炸。

发现时间复杂度瓶颈在叠加若干个整块上，由于没有修改，可以考虑预处理若干个块的叠加贡献。

**异或和**满足**前缀和**性质，可以 $\Theta(\dfrac{n}{S} \times \dfrac{c}{w})$ 预处理前缀和，$\Theta(1)$ 查询，**求并**不满足前缀和性质，但它是**可重复贡献问题**，可以使用 $\text{ST}$ 表 $\Theta(\dfrac{n}{S} \log \dfrac{n}{S} \times \dfrac{c}{w})$ 预处理，$\Theta(1)$ 查询。

时间复杂度 $\Theta(\dfrac{n}{S} \times \dfrac{c}{w} +m \times \dfrac{c}{w} + \dfrac{n}{S} \log \dfrac{n}{S} \times \dfrac{c}{w})$，空间复杂度 $\Theta(\dfrac{n}{S} \log \dfrac{n}{S}\times \dfrac{c}{8})$，选用合适的块长即可通过本题。

你说还是不够快？还有进一步的优化。

考虑序列内仅出现一次的数不可能对答案造成贡献，将这一类数忽略掉之后对序列离散化再进行处理，时空复杂度均缩小为先前的一半，实测在本题中跑到了[最优解](https://www.luogu.com.cn/record/list?pid=P4135&orderBy=1&status=&page=1)。

代码：
```cpp
#include <bits/stdc++.h>

using namespace std;

#define getchar() (_S == _T && (_T = (_S = _B) + fread(_B, 1, 1 << 15, stdin), _S == _T) ? EOF : *_S++)
char _B[1 << 15], *_S = _B, *_T = _B;

template <class T> inline void fr(register T &a, register bool f = 0, register char ch = getchar()) {
    for (a = 0; ch < '0' || ch > '9'; ch = getchar()) ch == '-' ? f = 1 : 0;
    for (; ch >= '0' && ch <= '9'; ch = getchar()) a = a * 10 + (ch - '0');
    a = f ? -a : a;
}
template <class T, class... Y> inline void fr(register T &t, register Y &... a) { fr(t), fr(a...); }
int fr() { int a; return fr(a), a; }

const int N = 1e5, B = N >> 6, S = (1 << 16) - 1;

int n, c, m, lstans, blo, btot, tn, tn6, cnt[N + 2], a[N + 2], t[N + 2], lg2[N + 2], id[N + 2], pos[N + 2];
bool vis[N + 10];

struct Bitset {
    unsigned long long A[782];
    #define set(x) A[(x) >> 6] |= 1ull << ((x) & 63)
    #define flip(x) A[(x) >> 6] ^= 1ull << ((x) & 63)
} ansxor, ansor, f[2001], g[11][2001];

struct OI {
    int RP, score;
} NOIP2021, FJOI2022;

signed main() {
    NOIP2021.RP++, NOIP2021.score++, FJOI2022.RP++, FJOI2022.score++;
    register int i, j, k, l, r;
    fr(n, c, m), blo = 50, btot = n / blo + 1;
    for (i = 1; i <= n; i++) vis[i] = 1, fr(a[i]), cnt[a[i]]++, id[i] = i / blo + 1;
    for (i = 1; i <= c; i++) if (cnt[i] > 1) tn++, t[tn] = i, pos[i] = tn;
    tn6 = tn >> 6, lg2[0] = -1;
    for (i = 1; i <= n; i++) {
        if (cnt[a[i]] == 1) vis[i] = 0;
        else a[i] = pos[a[i]], f[id[i]].flip(a[i]), g[0][id[i]].set(a[i]);
    }
    for (i = 1; i <= btot; i++) {
        lg2[i] = lg2[i >> 1] + 1;
        for (j = 0; j <= tn6; j++) f[i].A[j] ^= f[i - 1].A[j];
    }
    for (j = 1; j <= lg2[btot]; j++) {
        register auto x = g[j], y = g[j - 1]; 
        for (i = 1; i + (1 << j) - 1 <= btot; i++) 
            for (k = 0; k <= tn6; k++) x[i].A[k] = y[i].A[k] | y[i + (1 << (j - 1))].A[k];
    }
    while(m--) {
        for (i = 0; i <= tn6; i++) ansxor.A[i] = ansor.A[i] = 0;
        fr(l, r), l = (l + lstans) % n + 1, r = (r + lstans) % n + 1, lstans = 0;
        if (l > r) l ^= r ^= l ^= r;
        if (id[l] == id[r]) { for (i = l; i <= r; i++) if (vis[i]) ansor.set(a[i]), ansxor.flip(a[i]); }
        else {
            for (i = l; i < id[l] * blo; i++) if (vis[i]) ansor.set(a[i]), ansxor.flip(a[i]);
            for (i = (id[r] - 1) * blo; i <= r; i++) if (vis[i]) ansor.set(a[i]), ansxor.flip(a[i]);
            if (id[l] + 1 < id[r]) {
                register int t = lg2[id[r] - id[l] - 1];
                register auto x = f[id[l]].A, y = f[id[r] - 1].A;
                for (i = 0; i <= tn6; i++) ansxor.A[i] ^= x[i] ^ y[i];
                x = g[t][id[l] + 1].A, y = g[t][id[r] - (1 << t)].A;
                for (i = 0; i <= tn6; i++) ansor.A[i] |= x[i] | y[i];
            }
        }
		for (i = 0; i <= tn6; i++) lstans += __builtin_popcountll(ansor.A[i]) - __builtin_popcountll(ansxor.A[i]);
        printf("%d\n", lstans);
    }
    return 0;
}
```

---

## 作者：Ameyax (赞：12)

分块大暴力


时间复杂度$n\sqrt{n}$


空间复杂度$n\sqrt{n}$


预处理块$i$内颜色$j$的和$sum[i][j]$，以及第$i$块到第$j$块的答案$ans[i][j]$


每次询问整块直接查表，两边$\sqrt{n}$暴力算


```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX_N = 100010;
const int MAX_M = 330;
int n, m, siz, Ans;
int a[MAX_N], belong[MAX_N], cnt[MAX_N], sum[MAX_M][MAX_N], ans[MAX_M][MAX_M];
#ifdef ONLINE_JUDGE
#define getchar Getchar
const int Size = 1 << 16;
char buffer[Size], *hed, *tail;
inline char Getchar()
{
    if (hed == tail)
    {
        int l = fread(buffer, 1, Size, stdin);
        tail = (hed = buffer) + l;
    }
    if (hed == tail) return -1;
    return *hed++;
}
#endif
int read()
{
    int x = 0, f = 1; char ch = getchar();
    while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }
    while (isdigit(ch)) { x = x * 10 + ch - '0'; ch = getchar(); }
    return x * f;
}
int query(int x, int y)
{
    x = (x + Ans) % n + 1, y = (y + Ans) % n + 1;
    if (x > y) swap(x, y);
    int l = belong[x], r = belong[y];
    Ans = 0;
    if (r <= l + 1)
    {
        for (int i = x; i <= y; ++i)
        {
            ++cnt[a[i]];
            if (!(cnt[a[i]] & 1)) ++Ans;
            else if (cnt[a[i]] > 2) --Ans;
        }
        for (int i = x; i <= y; ++i) --cnt[a[i]];
        return Ans;
    }
    Ans = ans[l + 1][r - 1];
    for (int i = x; i <= l * siz; ++i)
    {
        ++cnt[a[i]];
        if (!((cnt[a[i]] + sum[r - 1][a[i]] - sum[l][a[i]]) & 1)) ++Ans;
        else if (cnt[a[i]] + sum[r - 1][a[i]] - sum[l][a[i]] > 2) --Ans;
    }
    for (int i = (r - 1) * siz + 1; i <= y; ++i)
    {
        ++cnt[a[i]];
        if (!((cnt[a[i]] + sum[r - 1][a[i]] - sum[l][a[i]]) & 1)) ++Ans;
        else if (cnt[a[i]] + sum[r - 1][a[i]] - sum[l][a[i]] > 2) --Ans;
    }
    for (int i = x; i <= l * siz; ++i) --cnt[a[i]];
    for (int i = (r - 1) * siz + 1; i <= y; ++i) --cnt[a[i]];
    return Ans;
}
int main()
{
    n = read(), read(), m = read();
    for (int i = 1; i <= n; ++i) a[i] = read();
    siz = sqrt(n) + 1;
    for (int i = 1; i <= n; ++i)
    {
        belong[i] = (i - 1) / siz + 1;
        sum[belong[i]][a[i]]++;
    }
    for (int i = 1; i < MAX_N; ++i)
        for (int j = 1; j <= belong[n]; ++j)
            sum[j][i] += sum[j - 1][i];
    for (int i = 1; i <= belong[n]; ++i)
    {
        int now = 0;
        for (int j = (i - 1) * siz + 1; j <= n; ++j)
        {
            ++cnt[a[j]];
            if (!(cnt[a[j]] & 1)) ++now;
            else if (cnt[a[j]] > 2) --now;
            ans[i][belong[j]] = now;
        }
        for (int j = (i - 1) * siz + 1; j <= n; ++j)
            --cnt[a[j]];
    }
    while (m--)
    {
        int x = read(), y = read();
        printf("%d\n", query(x, y));
    }
    return 0;
}

```

---

## 作者：peterwuyihong (赞：6)

先放一些做法

### 时间 $O(n^2)$ ，空间 $O(\frac{n^2}{w})$ 做法，不知道怎么过去的

[笑死，根本不会bitset](https://www.luogu.com.cn/discuss/show/328696)
### 时间 $O(n^{\frac 5 3})/O(n\sqrt{n\log n})$ ，空间 $O(n)$ 做法

参考 [蒲公英](https://www.luogu.com.cn/problem/P4168)


### 时间 $O(n^{1.5})$ ，空间 $O(n^{1.5})$ 做法

开一个 $o_{1-\sqrt n,1-c} $ 的数组， $o_{i,j}$ 表示前 $i$ 块， $j$ 出现了几次，这样就能快速得到块与块之间 $j$ 出现了几次

开一个 $s_{1-\sqrt n,1-\sqrt n}$ 的数组， $s_{i,j}$ 表示第 $i$ 块到第 $j$ 块的答案。

上面两个显然都可以 $O(n\sqrt n)$ 预处理。

对于询问，把整块的提取出来，再分别统计散块，对于每一个数，出现次数记为 $x$ ，要判断加上 $x$ 之后答案是否变化，则若 $x$ 是奇数，答案必然加一，否则 $x$ 是偶数，非 $0$ 时答案减一，为 $0$ 时不变

### 时间 $O(n^{1.5})$ ，空间 $O(\frac{n\sqrt n}{w})$ 做法

考虑优化上一个算法，观察到这个出现次数的询问只需考虑**奇偶**与**是否存在**，奇偶可以使用bitset解决，接下来要解决是否存在的问题

考虑到散块与整块紧密相连，以左边散块为例，先把左边散块中每个数最右出现的位置记录下来，一开始对于整个数列记录每个数下一次出现的位置。那么判断一下这个数在散块中最右的位置的下一次出现的位置，是否在块内即可，右边也是如此

```cpp
#include<bits/stdc++.h>
using namespace std;
#define debug(x) cerr<<#x<<' '<<x<<endl
/* --------------- fast io --------------- */ // begin
namespace Fread {
const int SIZE = 1 << 26;
char buf[SIZE], *S, *T;
inline char getchar() {
	if (S == T) {
		T = (S = buf) + fread(buf, 1, SIZE, stdin);
		if (S == T) return '\n';
	}
	return *S++;
}
} // namespace Fread
namespace Fwrite {
const int SIZE = 1 << 26;
char buf[SIZE], *S = buf, *T = buf + SIZE;
inline void flush() {
	fwrite(buf, 1, S - buf, stdout);
	S = buf;
}
inline void putchar(char c) {
	*S++ = c;
	if (S == T) flush();
}
struct NTR {
	~ NTR() { flush(); }
} ztr;
} // namespace Fwrite
#ifdef ONLINE_JUDGE
	#define getchar Fread :: getchar
	#define putchar Fwrite :: putchar
#endif
namespace Fastio {
struct Reader {
	template<typename T>
	Reader& operator >> (T& x) {
		char c = getchar();
		T f = 1;
		while (c < '0' || c > '9') {
			if (c == '-') f = -1;
			c = getchar();
		}
		x = 0;
		while (c >= '0' && c <= '9') {
			x = x * 10 + (c - '0');
			c = getchar();
		}
		x *= f;
		return *this;
	}
	Reader& operator >> (char& c) {
		c = getchar();
		while (c == '\n' || c == ' ') c = getchar();
		return *this;
	}
	Reader& operator >> (char* str) {
		int len = 0;
		char c = getchar();
		while (c == '\n' || c == ' ') c = getchar();
		while (c != '\n' && c != ' ') {
			str[len++] = c;
			c = getchar();
		}
		str[len] = '\0';
		return *this;
	}
	Reader(){}
} cin;
const char endl = '\n';
struct Writer {
	template<typename T>
	Writer& operator << (T x) {
		if (x == 0) { putchar('0'); return *this; }
		if (x < 0) { putchar('-'); x = -x; }
		static int sta[45];
		int top = 0;
		while (x) { sta[++top] = x % 10; x /= 10; }
		while (top) { putchar(sta[top] + '0'); --top; }
		return *this;
	}
	Writer& operator << (char c) {
		putchar(c);
		return *this;
	}
	Writer& operator << (char* str) {
		int cur = 0;
		while (str[cur]) putchar(str[cur++]);
		return *this;
	}
	Writer& operator << (const char* str) {
		int cur = 0;
		while (str[cur]) putchar(str[cur++]);
		return *this;
	}
	Writer(){}
} cout;
} // namespace Fastio
#define cin Fastio :: cin
#define cout Fastio :: cout
#define endl Fastio :: endl
/* --------------- fast io --------------- */ // end

#define maxn 100010
#define B 400
int n,c,m;
int a[maxn];
int blo,tot;
int L[B],R[B];
int pos[maxn];
int s[B][B];
bitset<maxn>o[B];
int v[maxn];
int pre[maxn],nxt[maxn];
int app[maxn];
int lft[maxn],rig[maxn];
int l,r,lstans;
bool check(int l,int r,int k){
	for(int i=l;i<=r;i++)
	if(a[i]==k)return 1;
	return 0;
}
signed main(){
#ifndef ONLINE_JUDGE
	freopen("testdata.in","r",stdin);
	freopen("testdata.out","w",stdout);
#endif
	cin>>n>>c>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)pre[i]=app[a[i]],app[a[i]]=i;
	memset(app,0,sizeof app);
	for(int i=n;i;i--)nxt[i]=app[a[i]],app[a[i]]=i;
	for(int i=1;i<=n;i++)if(nxt[i]==0)nxt[i]=n+1;
	memset(app,0,sizeof app);
	blo=sqrt(n);
	tot=n/blo;
	if(n%blo)tot++;
	for(int i=1;i<=tot;i++){
		L[i]=R[i-1]+1;
		R[i]=L[i]+blo-1;
	}R[tot]=n;
	for(int i=1;i<=tot;i++)
	for(int j=L[i];j<=R[i];j++)
	pos[j]=i;
	for(int i=1;i<=tot;i++){
		for(int j=0;j<=c;j++)o[i][j]=o[i-1][j];
		for(int j=L[i];j<=R[i];j++)o[i].flip(a[j]);
	}
	for(int i=1;i<=tot;i++){
		for(int j=i;j<=tot;j++){
			s[i][j]=s[i][j-1];
			for(int k=L[j];k<=R[j];k++){
				if(v[a[k]]&1)s[i][j]++;
				else if(v[a[k]]>1)s[i][j]--;
				v[a[k]]++;
			}
		}
		memset(v,0,sizeof v);
	}
//	for(int i=1;i<=tot;i++,cout<<endl)
//	for(int j=1;j<=tot;j++,cout<<' ')cout<<s[i][j];
	while(m--){
		cin>>l>>r;
		l=(l+lstans)%n+1,r=(r+lstans)%n+1;
		if(l>r)swap(l,r);
		int p=pos[l],q=pos[r];
		if(p+1>=q){
			lstans=0;
			for(int i=l;i<=r;i++){
				if(v[a[i]]&1)lstans++;
				else if(v[a[i]]>1)lstans--;
				v[a[i]]++;
			}
			for(int i=l;i<=r;i++)v[a[i]]=0;
			cout<<lstans<<endl;
			continue;
		}
		for(int i=l;i<=R[p];i++)app[a[i]]=i;
		for(int i=l;i<=R[p];i++)rig[i]=app[a[i]];
		for(int i=l;i<=R[p];i++)app[a[i]]=0;
		for(int i=r;i>=L[q];i--)app[a[i]]=i;
		for(int i=r;i>=L[q];i--)lft[i]=app[a[i]];
		for(int i=r;i>=L[q];i--)app[a[i]]=0;
		lstans=s[p+1][q-1];
		for(int i=l;i<=R[p];i++){
			int gg=(v[a[i]]&1)^o[q-1][a[i]]^o[p][a[i]];
			if(gg)lstans++;
			else if(nxt[rig[i]]<=R[q-1]||v[a[i]])lstans--;
		//	assert((nxt[rig[i]]<=R[q-1])==check(L[p+1],R[q-1],a[i]));
			v[a[i]]++;
		}
		for(int i=L[q];i<=r;i++){
			int gg=(v[a[i]]&1)^o[q-1][a[i]]^o[p][a[i]];
			if(gg)lstans++;
			else if(pre[lft[i]]>=L[p+1]||v[a[i]])lstans--;
		//	assert((pre[lft[i]]>=L[p+1])==check(L[p+1],R[q-1],a[i]));
			v[a[i]]++;
		}
		for(int i=l;i<=R[p];i++)v[a[i]]=0;
		for(int i=L[q];i<=r;i++)v[a[i]]=0;
		cout<<lstans<<endl;
	}
#ifndef ONLINE_JUDGE
	cerr<<endl<<(double)clock()/CLOCKS_PER_SEC;
#endif
}

```

感谢 $Cmd\ dalao$ 的指导！！

彩蛋：[艰辛历程](https://www.luogu.com.cn/paste/zomq6b1t)

---

## 作者：tzc_wk (赞：4)

[题目链接](https://www.luogu.com.cn/problem/P4135)
> 题意：$n$ 个数，每个数都在 $[1,c]$ 中，$m$ 次询问，每次问在 $[l,r]$ 中有多少个数出现偶数次。强制在线。

> $1 \leq n,m,c \leq 10^5$

如果不强制在线的话可以想到莫队，关键这个强制在线怎么处理。

很容易想到对原数列进行根号分块，为了方便表示，定义 $L_i$ 为第 $i$ 块的左端点，$R_i$ 为第 $i$ 块的右端点。

我们记 $t_{i,j}$ 表示在 $[L_i,n]$ 中 $j$ 这个数出现了多少次，$f_{i,j}$ 表示在 $[L_i,R_j]$ 有多少个数出现次数为偶数。

我还是太 naive 了，一看到这个“区间”就想着用区间 dp 的方式进行转移，复杂度爆炸。

事实上，我们可以在求出 $t$ 的同时求出 $f$。枚举起点块 $i$，定义 $num$ 记录有多少个数出现了偶数次，一边往后扫一遍更新 $num$。

查询区间 $[l,r]$ 的时候，如果 $l,r$ 在同一块中，直接暴力查找就行了。

如果 $[l,r]$ 不在同一块中，记 $l'$ 为 $l$ 所在的块，$r'$ 为 $r$ 所在的块，那么我们先将 $ans$ 赋值为 $f_{l'+1,r'-1}$，然后对于 $[l,R_{l'}] \cup [L_{r'},r]$ 中所有**不同**的数 $x$，分出以下三种情况：

1. $x$ 在 $[L_{l'+1},R_{r'-1}]$ 中出现次数为不为零的偶数，但是在 $[l,r]$ 中出现次数为奇数，则表明它被算在了 $ans$ 中，但实际不符合条件，让 $ans$ 减一
2. $x$ 在 $[L_{l'+1},R_{r'-1}]$ 中出现次数奇数，但是在 $[l,r]$ 中出现次数为偶数，则表明它没有被算在了 $ans$ 中，但实际符合条件，让 $ans$ 加一
3. $x$ 在 $[L_{l'+1},R_{r'-1}]$ 中没出现过，但是在 $[l,r]$ 中出现次数为偶数，让 $ans$ 加 $1$。

```cpp
//Coded by tzc_wk
/*
数据不清空，爆零两行泪。
多测不读完，爆零两行泪。
边界不特判，爆零两行泪。
贪心不证明，爆零两行泪。
D P 顺序错，爆零两行泪。
大小少等号，爆零两行泪。
变量不统一，爆零两行泪。
越界不判断，爆零两行泪。
调试不注释，爆零两行泪。
溢出不 l l，爆零两行泪。
*/
#include <bits/stdc++.h>
using namespace std;
#define fi			first
#define se			second
#define fz(i,a,b)	for(int i=a;i<=b;i++)
#define fd(i,a,b)	for(int i=a;i>=b;i--)
#define foreach(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)
#define all(a)		a.begin(),a.end()
#define giveup(...) return printf(__VA_ARGS__),0;
#define fill0(a)	memset(a,0,sizeof(a))
#define fill1(a)	memset(a,-1,sizeof(a))
#define fillbig(a)	memset(a,0x3f,sizeof(a))
#define fillsmall(a) memset(a,0xcf,sizeof(a))
#define mask(a)		(1ll<<(a))
#define maskx(a,x)	((a)<<(x))
#define _bit(a,x)	(((a)>>(x))&1)
#define _sz(a)		((int)(a).size())
#define filei(a)	freopen(a,"r",stdin);
#define fileo(a)	freopen(a,"w",stdout);
#define fileio(a) 	freopen(a".in","r",stdin);freopen(a".out","w",stdout)
#define eprintf(...) fprintf(stderr,__VA_ARGS__)
#define put(x)		putchar(x)
#define eoln        put('\n')
#define space		put(' ')
#define y1			y_chenxiaoyan_1
#define y0			y_chenxiaoyan_0
typedef pair<int,int> pii;
inline int read(){
	int x=0,neg=1;char c=getchar();
	while(!isdigit(c)){
		if(c=='-')	neg=-1;
		c=getchar();
	}
	while(isdigit(c))	x=x*10+c-'0',c=getchar();
	return x*neg;
}
inline void print(int x){
	if(x<0){
		putchar('-');
		print(abs(x));
		return;
	}
	if(x<=9)	putchar(x+'0');
	else{
		print(x/10);
		putchar(x%10+'0');
	}
}
inline int qpow(int x,int e,int _MOD){
	int ans=1;
	while(e){
		if(e&1)	ans=ans*x%_MOD;
		x=x*x%_MOD;
		e>>=1;
	}
	return ans;
}
const int BLOCK_SZ=320;
int n=read(),c=read(),m=read(),a[100005],cnt[322][100005],sum[322][322];
int blk,L[322],R[322],bel[100005];
int vis[100005];
inline void prework(){
	blk=(n-1)/BLOCK_SZ+1;
	fz(i,1,blk){
		L[i]=(i-1)*BLOCK_SZ+1;
		R[i]=min(i*BLOCK_SZ,n);
		fz(j,L[i],R[i]){
			bel[j]=i;
		}
	}
	fz(i,1,blk){
		int num=0;
		fill0(vis);
		fz(j,L[i],n){
			cnt[i][a[j]]++;
			if(!vis[a[j]])	vis[a[j]]=1,num++;
			if(cnt[i][a[j]]&1)	num--;
			else				num++;
			if(bel[j]!=bel[j+1])	sum[i][bel[j]]=num;
		}
	}
}
int cntt[100005];
inline int query(int l,int r){
	if(bel[l]==bel[r]){
		int ans=0;
		fz(i,l,r)	cntt[a[i]]++;
		fz(i,l,r){
			if(!vis[a[i]]){
				if(cntt[a[i]]&1^1)	ans++;
				vis[a[i]]=1;
			}
		}
		fz(i,l,r)	cntt[a[i]]--,vis[a[i]]=0;
		return ans;
	}
	else{
		int l0=bel[l],r0=bel[r];
		fz(i,l,R[l0])	cntt[a[i]]++;
		fz(i,L[r0],r)	cntt[a[i]]++;
		int ans=sum[l0+1][r0-1];
		fz(i,l,R[l0]){
			if(!vis[a[i]]){
				if((cnt[l0+1][a[i]]-cnt[r0][a[i]])>0){
					if(((cntt[a[i]]+cnt[l0+1][a[i]]-cnt[r0][a[i]])&1^1)&&(cnt[l0+1][a[i]]-cnt[r0][a[i]])&1)
						ans++;
					if(((cntt[a[i]]+cnt[l0+1][a[i]]-cnt[r0][a[i]])&1)&&(cnt[l0+1][a[i]]-cnt[r0][a[i]])&1^1)
						ans--;
				}
				else{
					if((cntt[a[i]]&1)^1)	ans++;
				}
				vis[a[i]]=1;
			}
		}
		fz(i,L[r0],r){
			if(!vis[a[i]]){
				if((cnt[l0+1][a[i]]-cnt[r0][a[i]])>0){
					if(((cntt[a[i]]+cnt[l0+1][a[i]]-cnt[r0][a[i]])&1^1)&&(cnt[l0+1][a[i]]-cnt[r0][a[i]])&1)
						ans++;
					if(((cntt[a[i]]+cnt[l0+1][a[i]]-cnt[r0][a[i]])&1)&&(cnt[l0+1][a[i]]-cnt[r0][a[i]])&1^1)
						ans--;
				}
				else{
					if(cntt[a[i]]&1^1)	ans++;
				}
				vis[a[i]]=1;
			}
		}
		fz(i,l,R[l0])	cntt[a[i]]--,vis[a[i]]=0;
		fz(i,L[r0],r)	cntt[a[i]]--,vis[a[i]]=0;
		return ans;
	}
}
signed main(){
	fz(i,1,n)	a[i]=read();
	prework();
	fill0(vis);
	int anss=0;
	while(m--){
		int l=read(),r=read();
		l=(l+anss)%n+1,r=(r+anss)%n+1;
		if(l>r)	swap(l,r);
		anss=query(l,r);
		cout<<anss<<endl;
	}
	return 0;
}
```

---

## 作者：Sino_E (赞：4)

比较暴力的做法...

考虑分块bitset，bitset的一位代表某一种出现了奇数次/偶数次，这样子的话出现一次就对某一位异或一次就行

然后题目要求正偶数次...

我们想到再用一个bitset维护一个或，1代表出现了该值...

然后bitset位运算的复杂度是接近$\sqrt{n}$的（经过实验...），那么如果每次查询$\sqrt{n}$个块就会gg...

那么考虑块处理出来之后进行异或前缀和，可是第二个bitset没法前缀和呀

那么事实上，我们需要维护的是在一个区间里面没有出现的颜色的种类数，然后用偶数次减去这个次数就行。

一个区间里面没有出现的颜色的种类数可以用总种类数减去出现的种类数。

那么需要在线求一个区间里有多少个不同的数...这题就变成了[SDOI2009] HH的项链，要求在线询问。

这个用主席树就行了，原题的题解里也有，这里就不多赘述了...

于是总复杂度大概是$O(n\log{n}+q(\log n+\sqrt{n}))$

全站第四慢，不开O2TLEemm

仅供参考...

```cpp
// Code by ajcxsu
// Problem: gou

#include<bits/stdc++.h>
using namespace std;

const int N=1e5+10, M=3e6;
typedef bitset<N> bs;
bs blo[320];
int bl[N], br[N], pos[N];
int ty[N];

bs resa, resb;
int query(int l, int r) {
    resa=bs(), resb=bs();
    for(int i=l;i<=br[pos[l]] && i<=r; i++)
        resa[ty[i]]=resa[ty[i]]^1;
    if(pos[l]!=pos[r])
        for(int i=r;i>=bl[pos[r]] && i>=l; i--)
            resa[ty[i]]=resa[ty[i]]^1;
    if(pos[l]+1<=pos[r]-1) resa^=blo[pos[l]]^blo[pos[r]-1];
    return N-resa.count();
}

struct Node *nil;
struct Node {
    int v;
    Node *ls, *rs;
    Node(int v=0):v(v) { ls=rs=nil; }
} *nd[N], po[M], *pp=po;
void ini() {
    nil=pp++, nil->ls=nil->rs=nil;
    nd[0]=nil;
}
void updata(Node *&x, int l, int r, int d, int w) {
    Node *nd=pp++; *nd=*x, x=nd, x->v++;
    if(l==r) return;
    int mid=(l+r)>>1;
    if(d<=mid) updata(x->ls, l, mid, d, w);
    else updata(x->rs, mid+1, r, d, w);
}
int query2(Node *x, int l, int r, int xr) {
    if(r<=xr) return x->v;
    int mid=(l+r)>>1, ret=query2(x->ls, l, mid, xr);
    if(xr>mid) ret+=query2(x->rs, mid+1, r, xr);
    return ret;
}

int lst[N];
int main() {
    ios::sync_with_stdio(false), cin.tie(0), ini();
    int n, c, m;
    cin>>n>>c>>m;
    int size=sqrt(n), cm=(n-1)/size+1;
    for(int i=1;i<=n;i++) cin>>ty[i], pos[i]=(i-1)/size+1, blo[pos[i]][ty[i]]=blo[pos[i]][ty[i]]^1;
    for(int i=1;i<=n;i++) nd[i]=nd[i-1], updata(nd[i], 0, n, lst[ty[i]], 1), lst[ty[i]]=i;
    for(int i=1;i<=cm;i++) bl[i]=br[i-1]+1, br[i]=size*i, blo[i]^=blo[i-1];
    br[cm]=n;
    int last=0, l, r;
    while(m--) {
        cin>>l>>r, l=(l+last)%n+1, r=(r+last)%n+1;
        if(l>r) swap(l, r);
        cout<<(last=query(l, r)-(N-(query2(nd[r], 0, n, l-1)-query2(nd[l-1], 0, n, l-1))))<<endl;
    }
    return 0;
}
```

---

## 作者：BzhH (赞：3)

这道题一眼看去好像不能用什么数据结构做出，所以就只有打分块暴力了，刚开始想的时候没有想到用前缀和，所以写出来的时间复杂度就达到了$O(n\sqrt{n}\log{n})$,交上去不仅T了还WA了。后面加上了前缀和时间复杂度就可以过了

## 思路
假设将整个序列分为T块，那么考虑预处理一个数组$tim_{i,j}$表示前i个块中,字符j出现的次数,这样就可以快速求出每一段块中各数字出现的次数了,然后再预处理一个数组$num_{i,j}$表示第$i$个块到第$j$个块中出现了正偶数次的数字的个数,那么对于查询的区间$[L,R]$,分为两种情况

------------

$[L,R]$在同一个块中,这种情况就直接暴力枚举每个数字即可


------------
$[L,R]$不在同一个块中,考虑分为三段$[L,r),[l,r],(r,R]$,其中[l,r]为完整的块,那么只需要在枚举的时候判断一下加上当前这个字符对答案是否有影响,详细解释见代码

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#define get(i) ((i - 1) / len + 1)
using namespace std;
const int N = 1e5 + 5;

int len;
int tim[405][N], num[405][405], a[N], temp[N];

int query(int l, int r)
{
    int res = 0;
    if (get(l) == get(r))
    {
        for (int i = l; i <= r; i++)
            temp[a[i]]++;
        for (int i = l; i <= r; i++)
        {
            if (temp[a[i]] > 0 && temp[a[i]] % 2 == 0)//注意要大于0
                res++;
            temp[a[i]] = 0;
        }
    }//暴力枚举的情况
    else 
    {
        int i = l, j = r;
        res += num[get(i) + 1][get(j) - 1];
        while (get(i) == get(l))
        {
            temp[a[i]]++;
            if ((temp[a[i]] + tim[get(j) - 1][a[i]] - tim[get(i)][a[i]]) > 0 
                && (temp[a[i]] + tim[get(j) - 1][a[i]] - tim[get(i)][a[i]]) % 2 == 0)
                res++;
            else if ((temp[a[i]] + tim[get(j) - 1][a[i]] - tim[get(i)][a[i]]) > 1 
                && (temp[a[i]] + tim[get(j) - 1][a[i]] - tim[get(i)][a[i]]) % 2)//大于1是为了防止多减
                res--;
            i++;
        }
        while (get(j) == get(r))
        {
            temp[a[j]]++;
            if ((temp[a[j]] + tim[get(j) - 1][a[j]] - tim[get(i) - 1][a[j]]) > 0 
                && (temp[a[j]] + tim[get(j) - 1][a[j]] - tim[get(i) - 1][a[j]]) % 2 == 0)
                res++;
            else if ((temp[a[j]] + tim[get(j) - 1][a[j]] - tim[get(i) - 1][a[j]]) > 1 
                && (temp[a[j]] + tim[get(j) - 1][a[j]] - tim[get(i) - 1][a[j]]) % 2)
                res--;
            j--;
        }
        for (int k = l; k < i; k++)
            temp[a[k]] = 0;
        for (int k = j + 1; k <= r; k++)
            temp[a[k]] = 0;//清空数组,因为用memset会超时
    }
    return res;
}

int main()
{
    int n, c, m;
    scanf("%d%d%d", &n, &c, &m);
    len = sqrt(n);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);
        tim[get(i)][a[i]]++;
    }
    for (int i = 1; i <= get(n); i++)
    {
        for (int j = 0; j <= c; j++)
            tim[i][j] += tim[i - 1][j];
    }//预处理前缀和
    for (int i = 1; i <= get(n); i++)
    {
        memset(temp, 0, sizeof(temp));
        for (int j = i; j <= get(n); j++)
        {
            int r = j * len;
            num[i][j] = num[i][j - 1];
            for (int k = (j - 1) * len + 1; k <= r; k++)
            {
                temp[a[k]]++;
                if (temp[a[k]] > 0 && temp[a[k]] % 2 == 0)
                    num[i][j]++;
                else if (temp[a[k]] > 1 && temp[a[k]])
                    num[i][j]--;
            }
        }
    }//预处理每个完整的块中的答案
    memset(temp, 0, sizeof(temp));
    int ans = 0;
    while (m--)
    {
        int l, r;
        scanf("%d%d", &l, &r);
        l = (l + ans) % n + 1, r = (r + ans) % n + 1;
        if (l > r)
            swap(l, r);
        printf("%d\n", ans = query(l, r));//查询
    }
}
```



---

## 作者：Aoki_灏 (赞：3)

~~搞了4个多小时才好不容易把这题A了，虽然luogu加O2过的，但bzoj是过了的~~

 虽然跑的比较慢但觉得方法很好理解，一开始有些细节没考虑以及预处理比较慢，就没过。之后借鉴了黄学长的代码才弄出来
 
 不嫌弃的话就看看吧
 
 ## 思路
 
 这题和[蒲公英](https://www.luogu.org/problemnew/show/P4168)其实是处理方法很相近的，~~别看是黑题，其实是板子~~
          
          主要是预处理每个大块之间出现偶数次的数的个数
          注意O(n)预处理，O(n2)肯定不行
          查询的时候需要注意在处理零散块时也要统计一遍
          要注意分奇偶考虑，在考虑零散块的时候也要考虑大块中的出现次数奇偶性。
          例：在1-2中出现2次，2-6中出现3次，没有被统计过要加答案；
          在1-2中出现1次，2-6出现2次，这时一共出现3次就不符合了，答案反而要减
          这是非常需要注意的，所以细节的处理也非常重要

所以直接看代码吧

我用的vector估计比较慢，query写的也很繁复，这估计就是luogu TLE的原因吧，只有O2才能救我，但只觉得这样思路很清晰就这样写了

~~这题c给的真的有用吗emmmmmmm~~

## 代码

```
#include <bits/stdc++.h>
#define N 100005
#define ri register int
using namespace std;
int bl[N],l[N],r[N],n,p,a[N],cnt,val[N],m,num,vis2[N];
int f[1505][1505];//预处理每个大块l,r之间的出现次数为偶数次的个数
vector<int>ve[N];
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int vis[N];
inline void pre()//预处理
{
    for(ri i=1;i<=bl[n];i++)
    {
        int ans=0;
        for(ri j=l[i];j<=n;j++)vis[a[j]]=0;
        for(ri j=l[i];j<=n;j++)
        {
            if(!(vis[a[j]]&1)&&vis[a[j]])ans--;//如果在之前已经出现过偶数次了，说明此时这个数已经不符合要求，ans--
            vis[a[j]]++;
            if(!(vis[a[j]]&1))ans++;//此时满足偶数次，ans++
            f[i][bl[j]]=ans;//边算边更新就不用n2了，我之前n2写法就很慢
        }
    }


}
inline int two_point(int x,int y,int v)//二分求在x-y区间出现的次数，不知道手写二分会不会快一些QWQ
{
    int t=upper_bound(ve[v].begin(),ve[v].end(),y)-lower_bound(ve[v].begin(),ve[v].end(),x);
    return t;
}
inline int query(int x,int y)//这部分可能我写的也比较慢，但还是比较好理解的
{
    int ans=0,mx;
    int L=bl[x],R=bl[y];
    if(L==R)//当在同一个块时，直接暴力统计
    {
        for(ri i=x;i<=y;i++)
        {
            int t=two_point(x,y,a[i]);
            if(!(t&1)&&!vis2[a[i]])ans++,vis2[a[i]]=1;
        }
        for(ri i=x;i<=y;i++)vis2[a[i]]=0;//清零
    }
    else
    {
        ans=f[L+1][R-1];//先计算出中间块的满足条件的数的个数
        int ll=l[L+1];int rr=r[R-1];
        for(ri i=x;i<=r[L];i++)
        {
            if(vis2[a[i]])continue;
            int t=two_point(x,y,a[i]),t2=two_point(ll,rr,a[i]);
            if(!(t&1))//如果在散区间中出现次数为偶数次
                {if((t2&1)||!t2)ans++;}//如果在大块中出现奇数次或没出现，（之前也没统计过，此时满足条件，ans++
            else if(!(t2&1)&&t2)ans--;//如果散区间出现奇数次，大块中出现偶数次且之前统计过，此时已经不满足条件，ans--
            vis2[a[i]]=1;

        }
        for(ri i=l[R];i<=y;i++)//同上
        {
           if(vis2[a[i]])continue;
            int t=two_point(x,y,a[i]),t2=two_point(ll,rr,a[i]);
            if(!(t&1))
                {if((t2&1)||!t2)ans++;}
            else if(!(t2&1)&&t2)ans--;
            vis2[a[i]]=1;
        }
         for(ri i=x;i<=r[L];i++) vis2[a[i]]=0;
         for(ri i=l[R];i<=y;i++)vis2[a[i]]=0;

    }

    return ans;
}
int main()
{
   
    n=read();num=read();m=read();
    p=sqrt((double)n/log((double)n)*log(2));
    for(ri i=1;i<=n;i++)//预处理
    {
        a[i]=read();
        ve[a[i]].push_back(i);//用vector处理每个数字出现的位置，因为是递增的可以直接二分，所以我选择了vector而不是数组
        bl[i]=(i-1)/p+1;
       if(l[bl[i]]==0)l[bl[i]]=i;
       r[bl[i]]=i;
    }
    pre();
    int pre_ans=0;
    for(ri i=1;i<=m;i++)
    {
        int x,y;
        x=read();y=read();
        x=(x+pre_ans)%n+1;
        y=(y+pre_ans)%n+1;
        if(x>y)swap(x,y);
        pre_ans=query(x,y);
        printf("%d\n",pre_ans);
     

    }



    return 0;
}

```

感谢

---

## 作者：glorious_dream (赞：2)

### 题目分析：

首先给出一段序列，共 $m$ 次询问，每一次询问求出给定区间内出现正偶数次数的个数。

### 算法讲解：

首先，如果忽略本题强制在线的话，可以用莫队来做。

但是，题目中已经规定了需要强制在线来做，于是只能另求他法。

看到数据范围，再结合一下题意，这道题可以用分块来做。

首先，定义两个数组 $cnt[i][j]$ 表示前 $i$ 块中，$j$ 出现的次数，$ans[i][j] $表示第 $i$ 到第 $j$ 个块中，出现偶数次数的个数。

这两个数组需要先预处理出来，先来看 $cnt$ 数组。

相当于一个前缀和的思想，先输入把每一个数 $+1$，然后依次枚举块，把前一块中这个数的出现次数加起来。

```cpp
for(re int i(1) ; i<=n ; ++i){
    a[i] = read();
    pos[i] = (i-1)/blocksize+1;
    cnt[pos[i]][a[i]]++;
}
for(re int i(1) ; i<=tot ; ++i){
    for(re int j(0) ; j<=c ; ++j){
        cnt[i][j] += cnt[i-1][j];
    }
}
```

然后来看 $ans$数组。

先枚举每一个块，枚举右端点，让 $ans[i][j]=ans[i][j-1]$ 作为初始值，往后枚举块 $j$ 的右端点，可以用一个桶来记录出现次数，具体看代码。

```cpp
for(re int i(1) ; i<=tot ; ++i){
    for(re int j(i) ; j<=tot ; ++j){
        ans[i][j] = ans[i][j-1]; //赋值
        for(re int k(l[j]) ; k<=r[j] ; ++k){
            t[a[k]]++; //用桶来记录
            if(!(t[a[k]]&1)) ans[i][j]++; //如果现在变为偶数个
            else if(t[a[k]]!=1) ans[i][j]--; //从偶数变为奇数
        }
    }
    memset(t,0,sizeof(t)); //别忘了每一次都要清空
}
```

这时预处理两个重要的数据已经好了，来看如何分块。

分成 $\sqrt{n}$ 块，把每一个块的左端点和右端点先记录下来。

```cpp
inline void init(){
    blocksize = sqrt(n); //块大小
    tot = (n-1)/blocksize+1; //块个数
    for(re int i(1) ; i<=tot ; ++i){
        l[i] = (i-1)*blocksize+1; //左端点
        r[i] = i*blocksize; //右端点
    }
    r[tot] = n; //最后一个块的右端点设为n
}
```

最后就是处理询问操作了。每次给定一个 $l$ 和 $r$，求该区间内偶数次数的个数。

分两种情况。如果两个端点在一个块中，直接暴力修改就行。

```cpp
int idx=pos[ll],idy=pos[rr];
if(idy-idx<=1){
    int res=0;
    for(re int i(ll) ; i<=rr ; ++i){
        t[a[i]]++;
        if(!(t[a[i]]&1)) res++;
        else if(t[a[i]]!=1) res--;
    }
    for(re int i(ll) ; i<=rr ; ++i) t[a[i]]--;
    return res;
}
```

第二种情况，如果两个块中间隔了很远，那么中间的块可以直接用预处理的 $ans$ 数组，旁边的两个小块暴力询问。

```cpp
int res = ans[idx+1][idy-1];
for(re int i(ll) ; i<=r[idx] ; ++i){
    t[a[i]]++;
    int pre=cnt[idy-1][a[i]]-cnt[idx][a[i]]; //大块中a[i]出现的次数
    if(!((t[a[i]]+pre)&1)) res++; //从奇数变为偶数
    else if(t[a[i]]+pre!=1) res--; //从偶数变为奇数
}
for(re int i(l[idy]) ; i<=rr ; ++i){
    t[a[i]]++;
    int pre=cnt[idy-1][a[i]]-cnt[idx][a[i]]; //跟上面一样
    if(!((t[a[i]]+pre)&1)) res++;
    else if(t[a[i]]+pre!=1) res--;
}
for(re int i(ll) ; i<=r[idx] ; ++i) t[a[i]]--; //最后别忘了清空
for(re int i(l[idy]) ; i<=rr ; ++i) t[a[i]]--; //而且只要清空这一段就行
return res;
```

至此，这道题就做完啦。

### 总代码：

```cpp
#include<bits/stdc++.h>
#define re register
using namespace std;
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch == '-') f=-1 ; ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48) ; ch=getchar();}
    return x*f;
}
inline void print(int x){
    if(x/10) print(x/10);
    putchar(x%10+'0');
}
const int M = 1e5+10;
int n,c,m; 
int blocksize,tot,last=0;
int a[M],ans[350][350],cnt[350][M],l[M],r[M],pos[M],t[M];
inline void init(){
    blocksize = sqrt(n);
    tot = (n-1)/blocksize+1;
    for(re int i(1) ; i<=tot ; ++i){
        l[i] = (i-1)*blocksize+1;
        r[i] = i*blocksize;
    }
    r[tot] = n;
}
inline int query(int ll,int rr){
    int idx=pos[ll],idy=pos[rr];
    if(idy-idx<=1){
        int res=0;
        for(re int i(ll) ; i<=rr ; ++i){
            t[a[i]]++;
            if(!(t[a[i]]&1)) res++;
            else if(t[a[i]]!=1) res--;
        }
        for(re int i(ll) ; i<=rr ; ++i) t[a[i]]--;
        return res;
    }
    else{
        int res = ans[idx+1][idy-1];
        for(re int i(ll) ; i<=r[idx] ; ++i){
            t[a[i]]++;
            int pre=cnt[idy-1][a[i]]-cnt[idx][a[i]];
            if(!((t[a[i]]+pre)&1)) res++;
            else if(t[a[i]]+pre!=1) res--;
        }
        for(re int i(l[idy]) ; i<=rr ; ++i){
            t[a[i]]++;
            int pre=cnt[idy-1][a[i]]-cnt[idx][a[i]];
            if(!((t[a[i]]+pre)&1)) res++;
            else if(t[a[i]]+pre!=1) res--;
        }
        for(re int i(ll) ; i<=r[idx] ; ++i) t[a[i]]--;
        for(re int i(l[idy]) ; i<=rr ; ++i) t[a[i]]--;
        return res;
    }
}
signed main(){
    n=read(),c=read(),m=read();
    init();
    for(re int i(1) ; i<=n ; ++i){
        a[i] = read();
        pos[i] = (i-1)/blocksize+1;
        cnt[pos[i]][a[i]]++;
    }
    for(re int i(1) ; i<=tot ; ++i){
        for(re int j(0) ; j<=c ; ++j){
            cnt[i][j] += cnt[i-1][j];
        }
    }
    for(re int i(1) ; i<=tot ; ++i){
        for(re int j(i) ; j<=tot ; ++j){
            ans[i][j] = ans[i][j-1];
            for(re int k(l[j]) ; k<=r[j] ; ++k){
                t[a[k]]++;
                if(!(t[a[k]]&1)) ans[i][j]++;
                else if(t[a[k]]!=1) ans[i][j]--;
            }
        }
        memset(t,0,sizeof(t));
    }
    while(m--){
        int ll,rr;
        ll=read(),rr=read();
        int L=(ll+last)%n+1,R=(rr+last)%n+1;
        if(L > R) swap(L,R);
        last = query(L,R);
        printf("%d\n",last);
    }
    return 0;
}
```


---

## 作者：Utilokasteinn (赞：2)

## [Link](https://www.luogu.com.cn/problem/P4135)

一眼分块。

先分块。预处理出第 $i$ 块到第 $j$ 块的答案。用一个桶记录一下每个数出现的次数，若变成正偶数答案就加一，否则就减一。

查询时，我们可以直接得到整块的答案。

然后，我们开一个桶，用来存散块中每个值的个数。

如果当前的个数加上整块中的个数为正偶数，答案就加一，否则就减一。

所以我们就要预处理出第 $i$ 块到第 $j$ 块中值为 $k$ 的数的个数 $sum_{i,j}$。但是这样空间复杂度会爆炸，所以我们可以设 $sum_{i,j}$ 表示前 $i$ 块中值为 $j$ 的数的个数，然后查询的时候差分一下就行了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int s=0,f=1,c=getchar();
	for(;!isdigit(c);c=getchar())
		if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())
		s=s*10+c-'0';
	return s*f;
}
int n,c,m,last;
int color[100005];
int block,len;
int L[340],R[340],pos[100005];
int sum[340][100005],ans[340][340],t[100005];
void input()
{
	n=read(),c=read(),m=read();
	len=sqrt(n),block=n/len;
	for(int i=1;i<=n;i++)
		color[i]=read();
	for(int i=1;i<=block;i++)
		L[i]=R[i-1]+1,R[i]=len*i;
	R[block]=n;
	for(int i=1;i<=block;i++)
		for(int j=L[i];j<=R[i];j++)
			pos[j]=i,sum[i][color[j]]++;
	for(int i=1;i<=block;i++)
		for(int j=0;j<=c;j++)
			sum[i][j]+=sum[i-1][j];
	for(int l=1;l<=block;l++)
	{
		for(int r=l;r<=block;r++)
		{
			ans[l][r]=ans[l][r-1];
			for(int i=L[r];i<=R[r];i++)
			{
				t[color[i]]++;
				if(!(t[color[i]]&1))ans[l][r]++;
				else if(t[color[i]]!=1)ans[l][r]--;
			}
		}
		memset(t,0,sizeof(t));
	}	
}
int query(int l,int r)
{
	int p=pos[l],q=pos[r];
	if(p==q)
	{
		int cnt=0;
		for(int i=l;i<=r;i++)
		{
			t[color[i]]++;
			if(!(t[color[i]]&1))cnt++;
			else if(t[color[i]]!=1)cnt--;
		}
		memset(t,0,sizeof(t));
		return cnt;
	}
	int cnt=ans[p+1][q-1];
	for(int i=l;i<=R[p];i++)
	{
		t[color[i]]++;
		int temp=sum[q-1][color[i]]-sum[p][color[i]];
		if(!((t[color[i]]+temp)&1))cnt++;
		else if(t[color[i]]+temp!=1)cnt--;
	}
	for(int i=L[q];i<=r;i++)
	{
		t[color[i]]++;
		int temp=sum[q-1][color[i]]-sum[p][color[i]];
		if(!((t[color[i]]+temp)&1))cnt++;
		else if(t[color[i]]+temp!=1)cnt--;
	}
	for(int i=l;i<=R[p];i++)
		t[color[i]]=0;
	for(int i=L[q];i<=r;i++)
		t[color[i]]=0;
	return cnt;
}
int main()
{
	input();
	while(m--)
	{
		int l=read(),r=read();
		l=(l+last)%n+1,r=(r+last)%n+1;
		if(l>r)swap(l,r);
		last=query(l,r);
		printf("%d\n",last);
	}
	return 0;
}
```


---

## 作者：Imakf (赞：2)

## Legend

给定长度为 $n$ 的序列 $a_i$，区间在线询问 $m$ 次出现次数为偶数的数字个数（0 次不算）。

强制在线。$1 \le n ,a_i,m \le 10^5$。

## Editorial

好像我的做法比较阴间。

考虑分块预处理 $val_{i,j}$ 表示第 $i$ 个块到第 $j$ 个块的答案。

如何处理散块？预处理 $back_{i,v}$ 表示第 $i$ 个块及以后数字 $v$ 从左到右第一次出现的位置。

$front_{i,v}$ 表示第 $i$ 个块及以后数字 $v$ 从右到左第一次出现的位置。

再记录一下 $where_i$ 每一个位置上的数字是这个数字从左到右第几个。

这样通过查询块内最靠左/右的数字，用 $where$ 作差，就可以判断出来整块内的数字出现的是偶数还是奇数次了。散块就暴力更新就行了。

复杂度 $O(n\sqrt{n})$。

然而在写这篇题解的时候发现好像可以直接前缀和求出奇偶性（

## Code

```cpp
#include <bits/stdc++.h>

const int MX = 1e5 + 7;
const int SIZE = 400;

int read(){
	char k = getchar(); int x = 0;
	while(k < '0' || k > '9') k = getchar();
	while(k >= '0' && k <= '9') x = x * 10 + k - '0' ,k = getchar();
	return x;
}

int a[MX] ,buc[MX];
int VAL[433][433];
int occb[433][MX];
int occf[433][MX];
// occb[i][j] 表示在块 i 及以后 j 第一次出现的位置
// occf 则是表示之前最后一次出现的位置
int begin[MX] ,end[MX] ,block[MX] ,where[MX];

std::vector<int> app[MX];

int Query(int l ,int r){
	int ans = 0;
	if(block[r] - block[l] <= 1){
		for(int i = l ; i <= r ; ++i){
			buc[a[i]] += 1;
			if((buc[a[i]] & 1) == 0) ++ans;
			else if(buc[a[i]] != 1) --ans;
		}
		for(int i = l ; i <= r ; ++i) buc[a[i]] = 0;
		return ans;
	}
	ans = VAL[block[l] + 1][block[r] - 1];
	for(int i = end[block[l]] ; i >= l ; --i){
		if(buc[a[i]]){
			++buc[a[i]];
			if(buc[a[i]] & 1) --ans;
			else ++ans;
		}
		else{
			int now = where[occf[block[r] - 1][a[i]]] - where[i];
			buc[a[i]] = now + 1;
			if((buc[a[i]] & 1) == 0) ++ans;
			else if(buc[a[i]] != 1) --ans;
		}
	}
	for(int i = begin[block[r]] ; i <= r ; ++i){
		if(buc[a[i]]){
			++buc[a[i]];
			if(buc[a[i]] & 1) --ans;
			else ++ans;
		}
		else{
			int now = where[i] - where[occb[block[l] + 1][a[i]]];
			buc[a[i]] = now + 1;
			if((buc[a[i]] & 1) == 0) ++ans;
			else if(buc[a[i]] != 1) --ans;
		}
	}
	for(int i = l ; i <= end[block[l]] ; ++i) buc[a[i]] = 0;
	for(int i = begin[block[r]] ; i <= r ; ++i) buc[a[i]] = 0;
	return ans;
}

int main(){
	int n = read() ,c = read() ,m = read();
	for(int i = 1 ; i <= n ; ++i){
		a[i] = read();
		where[i] = app[a[i]].size();
		app[a[i]].push_back(i);
		// printf("where[%d] = %d\n" ,i ,where[i]);
	}
	for(int i = 0 ,bl = 0 ; i <= n ; ++i){
		block[i] = bl;
		if(i % SIZE == 0 || i == n){
			end[bl] = i;
			begin[++bl] = i + 1;
		}
	}

	memset(occb ,0x3f ,sizeof occb);
	memset(occf ,0x3f ,sizeof occf);
	for(int i = n ; i ; --i){
		if(i == end[block[i]]){
			for(int j = 0 ; j <= c ; ++j){
				occb[block[i]][j] = occb[block[i] + 1][j];
			}
		}
		occb[block[i]][a[i]] = i;
	}
	for(int i = 1 ; i <= n ; ++i){
		if(i == begin[block[i]]){
			for(int j = 0 ; j <= c ; ++j){
				occf[block[i]][j] = occf[block[i] - 1][j];
			}
		}
		occf[block[i]][a[i]] = i;
	}

	for(int i = 1 ; i <= n ; i += SIZE){
		int ans = 0;
		for(int j = i ; j <= n ; ++j){
			buc[a[j]] += 1;
			if((buc[a[j]] & 1) == 0){
				++ans;
			}
			else if(buc[a[j]] != 1) --ans;
			VAL[block[i]][block[j]] = ans;
		}
		for(int j = i ; j <= n ; ++j) buc[a[j]] = 0;
	}
	int Online = 1 ,la = 0;
	while(m--){
		int l = read() ,r = read();
		if(Online){
			l = (l + la) % n + 1;
			r = (r + la) % n + 1;
			if(l > r) std::swap(l ,r);
		}
		printf("%d\n" ,la = Query(l ,r));
	}
}
```

---

## 作者：c20210623 (赞：2)

题目链接：[P4135 作诗](https://www.luogu.com.cn/problem/P4135)

首先考虑一下不要求强制在线的情况，用一个普通莫队就可以了。由于此题毒瘤，我们考虑一下如何用分块在线解决。

回忆一下莫队需要维护的东西，我们发现只需要知道两块之间的答案和两块之间的各数出现的个数（可以用前缀和维护）就行了。

如果令 $\text{c}$ 为原数组，$\text{a[i][j]}$ 为从第 $\text{1}$ 到第 $\text{i}$ 块j出现的次数，$\text{b[i][j]}$ 为第 $\text{i}$ 块到第 $\text{j}$ 块的答案。

在联想一下莫队，我们现在首先要解决一个问题，
若现在要让已经出现了 $\text{k}$ 次，的汉字再出现一次，
答案会如何变呢？

分情况讨论一下： 

$1:k=0$ $\text{return 0;}$

$2:k\mid2$ $\text{return -1;}$

$3:k\nmid2$ $\text{return 1;}$

此部分代码如下
```cpp
int add(int k){
	if(k==0) return 0;
	if(k%2) return 1;
	return -1;
}
```
下面为差分还原代码：
```cpp
int get(int j,int i,int k){//返回第j到第i块k出现的个数。
	return a[i][k]-a[j-1][k];
}
```

以下为预处理代码：（变量名较乱，请原谅）
```cpp
for(int i=1;i<=q;i++){//q为块的数量。
	for(int j=be[i];j<=en[i];j++) a[i][c[j]]++;//be[i]为第i块的
	//起始，en[i]为第i块的终点。
	for(int j=1;j<=n;j++) a[i][j]+=a[i-1][j];
}
for(int i=1;i<=q;i++){
	for(int j=i;j<=q;j++){
		ans=b[i][j-1];
		for(int k=be[j];k<=en[j];k++){
			if(i!=j) ans+=add(get(i,j-1,c[k])+lx[c[k]]);
			else ans+=add(lx[c[k]]);//分情况添加c[k]。
			lx[c[k]]++;//lx为一个临时变量，lx[i]代表i在
            		//此块出现的次数。下文的lx变量与此
                        //处意义相同。
		}
		b[i][j]=ans;
		for(int k=be[j];k<=en[j];k++) lx[c[k]]=0;//清零，注意
        	//不能用memset，时间复杂会错。下文均采用这种方式。
	}
}
```
求解部分：
```cpp
ans=0;
if(nq[r]-nq[l]<=1){
	for(int i=l;i<=r;i++){
		ans+=add(lx[c[i]]);
		lx[c[i]]++;
	}
	printf("%d\n",ans);
	for(int i=l;i<=r;i++) lx[c[i]]=0;
	continue;//没有在整块的部分，暴力求解。
}
int b1=nq[l]+1,e1=nq[r]-1,v=be[b1];//nq[i]代表i属于第几个块。
ans=b[b1][e1];
for(int i=l;i<v;i++){
	ans+=add(get(b1,e1,c[i])+lx[c[i]]);
	lx[c[i]]++;
}
for(int i=be[nq[r]];i<=r;i++){
	ans+=add(get(b1,e1,c[i])+lx[c[i]]);
	lx[c[i]]++;
}
for(int i=l;i<v;i++) lx[c[i]]=0;
for(int i=be[nq[r]];i<=r;i++) lx[c[i]]=0;
printf("%d\n",ans);
```
注意事项:

$\text{1.ans}$ 每一次都要清零。

$\text{2.}$ 临时变量不能 $\text{memset}$  清零。

$\text{3.add}$ 里面必须判一下 $k=0$ 的情况。

---

## 作者：suxxsfe (赞：2)

我的 blog：[https://www.cnblogs.com/suxxsfe/p/13531824.html](https://www.cnblogs.com/suxxsfe/p/13531824.html)  

[https://www.luogu.com.cn/problem/P4135](https://www.luogu.com.cn/problem/P4135)  
[https://darkbzoj.tk/problem/2821](https://darkbzoj.tk/problem/2821)  
前缀和写的时候一开始原数组、前缀和数组分开来的，结果 bzoj MLE，和在一起才过的。。。  
给定一个长度为 $n$ 的数列，$m$ 个询问，每次问 $[l,r]$ 中有多少种数的出现次数为偶数，强制在线，$n,m,\max\{a_i\}\le 10^5$  

区间问题，但线段树啥的又不好维护，考虑分块  
单独维护每个块的信息然后一个个合并肯定没戏，所以考虑每次询问只合并边角块和中间一部分整块的信息  
这样需要一个 $f_{l,r}$ 来表示 $[l,r]$ 块的答案，然后枚举边角块里的没一个元素，记录下每一个值出现了多少次，容易知道可以按照下面两条规则统计最终答案  

- 如果一个值在整块中出现了奇数次，或者没出现，那么如果在整块出现的次数和在两个边角块出现的次数的奇偶性相同，则这个值一共出现了偶数次，答案加一
- 如果在整块中出现了偶数次，且不为零，那么如果在两个边角块中出现了奇数次，答案减一

那么也就需要一个 $sum_{i,k}$ 表示前 $i$ 块，$k$ 出现了几次  
按照上面的想法，也就可以 $O(n\sqrt n)$ 的预处理出 $f$ 了（由 $f_{l,r-1}$ 推知 $f_{l,r}$）  

```cpp  
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#define reg register
inline int read(){
	int x=0,y=1;
	char c=std::getchar();
	while(c<'0'||c>'9'){if(c=='-') y=-1;c=std::getchar();}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=std::getchar();}
	return x*y;
}
#define N 100005
#define SQRTN 320
int n,m,B,c;
int block[N],a[N];
int L[SQRTN],R[SQRTN],sum[SQRTN][N],f[SQRTN][SQRTN];
int tmp[N];
inline void pre(){
	for(reg int i=1;i<=block[n];i++)
		for(reg int j=1;j<=c;j++) sum[i][j]+=sum[i-1][j];
	for(reg int i=1;i<=block[n];i++){
		for(reg int j=L[i];j<=R[i];j++) tmp[a[j]]++;
		for(reg int j=L[i];j<=R[i];j++) f[i][i]+=(tmp[a[j]]&&!(tmp[a[j]]&1)),tmp[a[j]]=0;
		for(reg int j=i+1;j<=block[n];j++){
			for(reg int k=L[j];k<=R[j];k++) tmp[a[k]]++;
			f[i][j]=f[i][j-1];
			for(reg int kk=L[j],k;kk<=R[j];kk++)if(tmp[a[kk]]){
				k=a[kk];
				if(sum[j-1][k]-sum[i-1][k]>0&&!((sum[j-1][k]-sum[i-1][k])&1)) f[i][j]-=(tmp[k]&1);
				//[i,j-1] 上 k 的个数为偶数，且不等于 0，则 tmp[k] 为奇数答案就减一
				else if((tmp[k]&1)==((sum[j-1][k]-sum[i-1][k])&1)) f[i][j]++;
				//为奇数，或为 0，则 tmp[k] 与之前 k 的个数奇偶性相同，f[i][j] 就加一
				tmp[k]=0;
			}
		}
	}
}
//inline void print(){
//	puts("block :");
//	for(reg int i=1;i<=n;i++) printf("%d : %d,left : %d,right : %d\n",i,block[i],L[block[i]],R[block[i]]);
//	puts("\nsum :");
//	for(reg int i=1;i<=block[n];i++){
//		printf("block %d :\n",i);
//		for(reg int j=1;j<=c;j++) printf("%d ",sum[i][j]);
//		puts("\n");
//	}
//	puts("\nf :");
//	for(reg int i=1;i<=n;i++){
//		for(reg int j=i;j<=block[n];j++) printf("f[%d][%d]=%d  ",i,j,f[i][j]);
//		puts("");
//	}
//}
int main(){
	n=read();c=read();m=read();B=std::sqrt(n);
	std::memset(L,0x3f,sizeof L);
	for(reg int i=1;i<=n;i++){
		a[i]=read();
		block[i]=block[i-1]+(!((i-1)%B));
		sum[block[i]][a[i]]++;
		R[block[i]]=std::max(R[block[i]],i);L[block[i]]=std::min(L[block[i]],i);
	}
	pre();
//		print();
	reg int l,r,bl,br;int ans=0;
	while(m--){
		l=(ans+read())%n+1;r=(ans+read())%n+1;
		if(l>r) l^=r,r^=l,l^=r;
		bl=block[l];br=block[r];
		if(bl==br){
			for(reg int i=l;i<=r;i++) tmp[a[i]]++;
			ans=0;
			for(reg int i=l;i<=r;i++) ans+=(tmp[a[i]]&&!(tmp[a[i]]&1)),tmp[a[i]]=0;
			printf("%d\n",ans);
			continue;
		}
		for(reg int i=l;i<=R[bl];i++) tmp[a[i]]++;
		for(reg int i=L[br];i<=r;i++) tmp[a[i]]++;
		ans=f[bl+1][br-1];
		for(reg int k,i=l;i<=R[bl];i++)if(tmp[a[i]]){
			k=a[i];
			if(sum[br-1][k]-sum[bl][k]>0&&!((sum[br-1][k]-sum[bl][k])&1)) ans-=(tmp[k]&1);
			else if((tmp[k]&1)==((sum[br-1][k]-sum[bl][k])&1)) ans++;
			tmp[k]=0;
		}
		for(reg int k,i=L[br];i<=r;i++)if(tmp[a[i]]){
			k=a[i];
			if(sum[br-1][k]-sum[bl][k]>0&&!((sum[br-1][k]-sum[bl][k])&1)) ans-=(tmp[k]&1);
			else if((tmp[k]&1)==((sum[br-1][k]-sum[bl][k])&1)) ans++;
			tmp[k]=0;
		}
		printf("%d\n",ans);
	}
}
```  

---

## 作者：Daniel_7216 (赞：1)

这道题目前以蒟蒻的知识水平，我只想到了分块，其余数据结构似乎写起来有点困难……

借鉴一下蒲公英那道题的思路，我们可以记录一下第 $i$ 块到第 $j$ 块的答案 $dp_{i,j}$。显然，$dp_{i,j}$ 可以用 $dp_{i,j}+cnt(j)$ 算出。这里 $cnt(j)$ 表示第 $j$ 块新增加的答案。

那么，$cnt(j)$ 怎么计算呢？我们可以把这个块中的每一个数字挨个扫一遍，如果说它在这个散块中出现的个数加在 $[i,j]$ 这些整块中出现的个数为偶数，那么 $cnt(j)$ 要增加一，如果它是大于三的奇数，那么就说明它破坏了一组答案，$cnt(j)$ 要减一。实际代码却没有这么麻烦：

```cpp
for (int i = 1; i <= num; i++){//左端点
	for (int j = i; j <= num; j++){//右端点
		dp[i][j] = dp[i][j - 1];//继承
		for (int k = L[j]; k <= R[j]; k++){
			b[a[k]]++;//b相当于是一个桶
			if (b[a[k]] % 2 == 0){//如果从第i块的最左到当前位置a[k]出现了偶数次
				dp[i][j]++;
			}else if (b[a[k]] >= 3){//由于把b[a[k]]加一之后它是不小于3的奇数，说明之前它是不小于2的偶数，a[k]破坏了一组答案
				dp[i][j]--;
			}
		}
	}
   memset(b, 0, sizeof(b));//更新左端点时再把它清空！这样b数组存的就是第i块的到当前位置上每个数出现的个数！
}
```

复杂度约为 $O(n\sqrt{n})$，代码应该还算好懂。

询问的做法相同，然后就是一些分块的常规操作，撇去预处理，复杂度为 $O(m\sqrt{n})$，可以接受。

注意：块的最大个数一定要多开一两个，不然会挂八十分！

```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <cstring>
using namespace std;
int len, num, n, c, m, bl_l, bl_r, last, ask_l, ask_r;
int L[318], R[318], dp[318][318];
int a[100001], belong[100001], b[100001];
int cnt[318][100001];
void pre_dp(){
	for (int i = 1; i <= num; i++){
		for (int j = i; j <= num; j++){
			dp[i][j] = dp[i][j - 1];
			for (int k = L[j]; k <= R[j]; k++){
				b[a[k]]++;
				if (b[a[k]] % 2 == 0){
					dp[i][j]++;
				}else if (b[a[k]] >= 3){
					dp[i][j]--;
				}
			}
		}
        memset(b, 0, sizeof(b));
	}
}
void build_block(){
	len = sqrt(n);
	num = sqrt(n);
	for (int i = 1; i <= num; i++){
		L[i] = R[i - 1] + 1;
		R[i] = L[i] + len - 1;
	}
	if (R[num] < n){
		num++;
		L[num] = R[num - 1] + 1;
		R[num] = n;
	}
}
void init(){
	build_block();
	for (int i = 1; i <= num; i++){
		for (int j = L[i]; j <= R[i]; j++){
			belong[j] = i;
			cnt[i][a[j]]++;
		}
		for (int j = 0; j <= c; j++){
			cnt[i][j] += cnt[i - 1][j];
		}
	}
	pre_dp();
}
int count(int l, int r){
    bl_l = belong[l];
    bl_r = belong[r];
    int ans = dp[bl_l + 1][bl_r - 1];
    int now_count;
	if (bl_l == bl_r){
        ans = 0;
		for (int i = l; i <= r; i++){
			b[a[i]]++;
			if (b[a[i]] % 2 == 0){
				ans++;
			}else if (b[a[i]] >= 3){
				ans--;
			}
		}
		memset(b, 0, sizeof(b));
		return ans;
	}else{
		for (int i = l; i <= R[bl_l]; i++){
			b[a[i]]++;
			now_count = b[a[i]] + cnt[bl_r - 1][a[i]] - cnt[bl_l][a[i]];
			if (now_count % 2 == 0){
				ans++;
			}else if (now_count >= 3){
				ans--;
			}
		}
		for (int i = L[bl_r]; i <= r; i++){
			b[a[i]]++;
			now_count = b[a[i]] + cnt[bl_r - 1][a[i]] - cnt[bl_l][a[i]];
			if (now_count % 2 == 0){
				ans++;
			}else if (now_count >= 3){
				ans--;
			}
		}
		memset(b, 0, sizeof(b));
		return ans;
	}
}
int main(){
	scanf("%d%d%d", &n, &c, &m);
	for (int i = 1; i <= n; i++){
		scanf("%d", &a[i]); 
	}
	init();
	while (m--){
		scanf("%d%d", &ask_l, &ask_r);
		if (ask_l > ask_r){
			swap(ask_l, ask_r);
		}
		last = count(ask_l, ask_r);
		printf("%d\n", last);
	}
	return 0;
} 
```


---

## 作者：devout (赞：1)

考虑如果$i$的数量多了一个，那么如果之前$cnt_i$为正偶数，则总答案数会$-1$，如果之前$cnt_i$为奇数，那么答案会$+1$。

考虑对于这个序列分块，用$sum_{i,j}$表示前$i$个块$j$出现的个数。

同时提前预处理出$ans_{i,j}$表示第$i$个块到第$j$个块的出现次数为偶数的数的个数。

如果预处理出来这个之后，我们就只需要在$ans_{blk_l+1,blk_r-1}$的基础上边角暴力一下就可以了。

考虑$ans$的预处理，首先可以做出$ans_{i,i}$，然后不清空桶，在$ans_{i,i}$的基础上推出$ans_{i,i+1}$，直到推完，那么这样的方法可以在$O(n\sqrt n)$的时间内推出来。

然后这道题就愉快的做完啦。

时间复杂度$O(n\sqrt n)$，空间复杂度$O(n\sqrt n)$

```cpp
#include <bits/stdc++.h>
using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

typedef long long ll;

const int N=1e5+5;
const int W=320;

template<typename T> void read(T &x){
   x=0;int f=1;
   char c=getchar();
   for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
   for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

int n,c,m,sq,bl;
int a[N];
int l[N],r[N],pos[N];
int sum[W][N],ans[W][W],tot[N];
int lastans;

void init(){
	sq=ceil(sqrt(n));
	Rep(i,1,sq){
		l[i]=(i-1)*sq+1,r[i]=i*sq;
		bl++;
		if(r[i]>n){r[i]=n;break;}
	}
	Rep(i,1,n)pos[i]=(i-1)/sq+1; 
	Rep(i,1,n)sum[pos[i]][a[i]]++;
	Rep(i,1,bl)
		Rep(j,1,c)
			sum[i][j]+=sum[i-1][j];
	Rep(i,1,bl){
		Rep(j,l[i],r[i]){
			tot[a[j]]++;
			if(tot[a[j]]>1&&(tot[a[j]]&1))ans[i][i]--;
			if(tot[a[j]]%2==0)ans[i][i]++;	
		}
		Rep(j,i+1,bl){
			ans[i][j]=ans[i][j-1];
			Rep(k,l[j],r[j]){
				tot[a[k]]++;
				if(tot[a[k]]>1&&(tot[a[k]]&1))ans[i][j]--;
				if(tot[a[k]]%2==0)ans[i][j]++;
			}
		}
		Rep(j,l[i],n)tot[a[j]]=0;
	}
}

int ask(int ql,int qr){
	int res=0;
	if(pos[ql]==pos[qr]){
		Rep(i,ql,qr)tot[a[i]]++;
		Rep(i,ql,qr){
			if(!tot[a[i]])continue;
			if(tot[a[i]]%2==0)res++;
			tot[a[i]]=0;
		}
		return res;
	}
	res=ans[pos[ql]+1][pos[qr]-1];
	Rep(i,ql,r[pos[ql]]){
		tot[a[i]]++;
		int s=sum[pos[qr]-1][a[i]]-sum[pos[ql]][a[i]]+tot[a[i]];
		if(s>1&&(s&1))res--;
		if(s%2==0)res++;
		
	}
	Rep(i,l[pos[qr]],qr){
		tot[a[i]]++;
		int s=sum[pos[qr]-1][a[i]]-sum[pos[ql]][a[i]]+tot[a[i]];
		if(s>1&&(s&1))res--;
		if(s%2==0)res++;
	}
	Rep(i,ql,r[pos[ql]])tot[a[i]]=0;
	Rep(i,l[pos[qr]],qr)tot[a[i]]=0;
	return res;
}

int main()
{
	read(n),read(c),read(m);
	Rep(i,1,n)read(a[i]);
	init();	
	Rep(i,1,m){
		int l,r;
		read(l),read(r);
		l=(l+lastans)%n+1,r=(r+lastans)%n+1;
		if(l>r)swap(l,r);
		printf("%d\n",lastans=ask(l,r));	
	}
	return 0;
}
```


---

## 作者：Taduro (赞：1)

### 题意

​	N个数，M组询问，每次问[l,r]中有多少个数出现正偶数次，强制在线。

​	有没有觉得这题很像蒲公英那个题？因为恶意的强制在线，优美的莫队和巧妙的树状数组或主席树被卡掉了（我可能要出个题专门让树状数组过），所以只有丑陋的分块了。

### 做法

​	预处理两个数组$num$和$o$，$num[i][j]$表示第$i$块到第$j$块中的答案数，$o[i][j]$表示前$i$个块中第$j$种颜色的个数，显然这需要$n \times \sqrt n$的时间和空间。

​	查询是，如果$l$和$r$所在一个块或所在块相邻的话，就直接暴力$\sqrt n$查询，否则就处理散块，中间的部分用$num$和$o$做前缀和统计。

### 代码

```c++
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
int lk[501],rk[501],a[100101],m,bl[100201],blo;
int u[100401],o[501][100101],n,num[501][505],f;
inline int query(int x,int y){
	int ans=0;
	memset(u,0,sizeof(u));
	if (bl[y]-bl[x]<=1){
		for (int i=x; i<=y; i++){
			if (u[a[i]]){
				if (u[a[i]]&1) ans++;
				else ans--;
			}
			u[a[i]]++;
		}
		return ans;
	}
	ans=num[bl[x]+1][bl[y]-1];
	for (int i=x; i<=rk[bl[x]]; i++){
		if (!u[a[i]]){
			u[a[i]]=o[bl[y]-1][a[i]]-o[bl[x]][a[i]];
			// continue;
		}
		if (u[a[i]]){
			if (u[a[i]]&1) ans++;
			else ans--;
		}
		u[a[i]]++;
	}
	for (int i=lk[bl[y]]; i<=y; i++){
		if (!u[a[i]]){
			u[a[i]]=o[bl[y]-1][a[i]]-o[bl[x]][a[i]];
		}
		if (u[a[i]]){
			if (u[a[i]]&1) ans++;
			else ans--;
		}
		u[a[i]]++;
	}
	return ans;
}
int main(){
	int x,y,ans;
	scanf("%d%d%d",&n,&f,&m);
	blo=sqrt(n);
	for (int i=1; i<=n; i++){
		scanf("%d",&a[i]);
		bl[i]=(i-1)/blo+1;
	}
	for (int i=1; i<=bl[n]; i++)
		lk[i]=(i-1)*blo+1,rk[i]=min(lk[i]+blo-1,n);
	for (int i=1; i<=bl[n]; i++){
		ans=0; memset(u,0,sizeof(u));
		for (int j=1; j<=f; j++) o[i][j]=o[i-1][j];
		for (int k=lk[i]; k<=rk[i]; k++){
			if (u[a[k]]){
				if (u[a[k]]&1) ans++;
				else ans--;
			}
			u[a[k]]++; o[i][a[k]]++;
		}
		num[i][i]=ans;
		for (int j=i+1; j<=bl[n]; j++){
			for (int k=lk[j]; k<=rk[j]; k++){
				if (u[a[k]]){
					if (u[a[k]]&1) ans++;
					else ans--;
				}
				u[a[k]]++;
			}
			num[i][j]=ans;
		}
	}
	int last=0;
	while (m--){
		scanf("%d%d",&x,&y);
		x=(x+last)%n+1; y=(y+last)%n+1;
		if (x>y) swap(x,y);
		last=query(x,y); printf("%d %d %d\n",x,y,last);
	}
	return 0;
}

```

ps:写的时候仗着复杂度正确什么优化都没加还肆无忌惮的memset，所以跑了16000多ms，大家都是分块就我像暴力水过去的。

---

## 作者：critnos (赞：0)

屑做法。。居然还卡过去了

分块。然而普通的分块难以维护，所以考虑另一种套路，就是用 $f_{i,j}(i\le j)$ 表示块 $i$ 的起点到块 $j$ 的终点中有多少个数出现正偶数次。

设块大小为 $b$，显然预处理复杂度 $\dfrac {n^2} b$，空间复杂度 $b^2$。

然后？然后我就不知道怎么优秀的搞块边了。无奈之下只能用了一个糟糕的做法。

对于块边扫过去的数为 $x$，两边的块边分别为 $bl,br$。

* 如果这个数值此前已经被处理过贡献则跳过，用一个数组 vis 记录。

* 如果这个数在区间 $[l,r]$ 中出现了正偶数次，但在区间 $[bl,br]$ 中出现了非正偶数次，则贡献为 $1$。即加上 $[l,r]$ 中的这个数的贡献。

* 如果这个数在区间 $[l,r]$ 中出现了正偶数次，在区间 $[bl,br]$ 中也出现了正偶数次，则贡献为 $0$。即这个数的贡献已经被统计过了。

* 如果这个数在区间 $[l,r]$ 中出现了非正偶数次，但在区间 $[bl,br]$ 中出现了正偶数次，则贡献为 $-1$。即减去 $[bl,br]$ 中的这个数的贡献。

* 如果这个数在区间 $[l,r]$ 中出现了非正偶数次，在区间 $[bl,br]$ 中也出现了非正偶数次，则贡献为 $0$。同理。

对于怎么求一个区间中一个数的出现次数，我用的是用 vector 存下标二分的古老方法。

这个复杂度和常数惨不忍睹，考虑优化。

整体的运行次数是 $\dfrac {n^2} b+m\times i\times \log n$ 的。

然后枚举块长即可通过本题。

---

## 作者：reyik (赞：0)

刚打完[蒲公英](https://www.luogu.org/problemnew/show/P4168)来打这题，感觉有点像。

## 还是分块

先对每一个数的出现次数做一个前缀和$s$。

然后令$f[x][y]$表示第$x$块到第$y$块之间出现正偶数次数值的个数。

然后对于vis数组的预处理（也就是转移）：对块内$sqrt(n)$个数进行转移。

对于询问：分块老套路，中间直接用，两边暴力：

过了$BZOJ$,~~$lg$开$O(2)$.~~

代买拱手献上
```
//加了一点常数优化，变量可能会有点怪，希望大家能理解
#include <iostream>
#include <cstdio>
#include <cctype>
#include <vector>
#include <cmath>
#define Rint register int
#define Temp template<typename T>
using namespace std; 
Temp inline void read(T &x) {
	x=0;T w=1,ch=getchar();
	while(!isdigit(ch)&&ch!='-') ch=getchar();
	if(ch=='-') w=-1,ch=getchar();
	while(isdigit(ch)) x=x*10+ch-'0',ch=getchar();
	x*=w;
}
inline void write_(int x) {
	if(x<0) putchar('-'),x=-x;
	if(x>=10) write_(x/10);
	putchar(x%10+'0');
}
inline void writeln(int x) {
	write_(x);putchar('\n');
}
const int maxn=1e5+10;
int vis[maxn],a[maxn],sum[320][maxn],f[320][320];
int low[320],high[320],id[maxn],n,c,m,cnt,siz;
vector<int> s;
int main() {
	read(n);read(c);read(m);
	siz=sqrt(n);
	cnt=(n-1)/siz+1;
    for(int i=1;i<cnt;++i) {
    	low[i]=(i-1)*siz+1;
		high[i]=i*siz;
	}
    low[cnt]=(cnt-1)*siz+1;
	high[cnt]=n;
    for(int i=1;i<=cnt;++i)
    	for(int j=low[i];j<=high[i];++j) id[j]=i;
    for(int i=1;i<=n;++i) read(a[i]);
    for(int i=1;i<=cnt;++i){
        __builtin_memcpy(sum[i],sum[i-1],sizeof*sum);
        for(int j=low[i];j<=high[i];++j) ++sum[i][a[j]];
        for(int j=1;j<=c;++j)
        	if(sum[i][j]-sum[i-1][j]>0) f[i][i]+=(sum[i][j]-sum[i-1][j])&1^1;
    }
    for(int i=1;i<cnt;++i){
        for(int j=i+1;j<=cnt;++j){
            int&res=f[i][j];res=f[i][j-1];
            s.clear();
            for(int k=low[j];k<=high[j];++k) {
				s.push_back(a[k]);
				vis[a[k]]=1;
			}
            for(int it:s){
                if(!vis[it]) continue;
                int l1=sum[j][it],l2=sum[j-1][it],l3=sum[i-1][it];
                vis[it]=0;
                if((l1-l2)&1){
                    if(l2-l3>0){
                        if((l2-l3)&1) ++res;
						else --res;
                    }
                } else{
                    if((l2-l3)==0)++res;
                }
            }
        }
    }
	int ans=0;
	while(m--) {
		int l0,r0,l,r;
		read(l0);read(r0);
		l=(l0+ans)%n+1;r=(r0+ans)%n+1;
		if(l>r) std::swap(l,r);
		int lx=id[l],rx=id[r];
		if((rx-lx)<=1) {
			ans=0;
			for (Rint i=l;i<=r;++i) ++vis[a[i]];
			for (Rint i=l;i<=r;++i) {
				if(vis[a[i]]) {
					ans+=vis[a[i]]&1^1;
					vis[a[i]]=0;
				}
			} 
			writeln(ans);
			continue;
		}
		s.clear();
		for (Rint i=l;i<=high[lx];++i) {
			++vis[a[i]];
			s.push_back(a[i]);
		}
		for (Rint i=low[rx];i<=r;++i) {
			++vis[a[i]];
			s.push_back(a[i]);
		}
		ans=f[lx+1][rx-1];
		for (Rint it:s) {
			if(vis[it]) {
				int last=sum[rx-1][it]-sum[lx][it];
				if(vis[it]&1) {
					if(last&1) ++ans;
					else {
						if(last) --ans;
					}
				}else {
					if(!last) ++ans;
				}
				vis[it]=0;
			}
		}
		writeln(ans);
	}
	return 0;
}
```

---

## 作者：eastcloud (赞：0)

## P4135 作诗 题解

### 题意简述

给定 $n$ 个不大于 $c$ 的正整数 $a_1 \dots a_n$ 和 $m$ 组询问，每次问 $[l,r]$ 中有多少个数出现正偶数次，题目**强制在线**。

### 题目分析

考虑题目是一种对静态序列的区间查询，我们可以想到使用莫队处理，但本题要求强制在线，我们可以考虑分块的做法。

本着大段维护，局部朴素的原则，我们将整个序列分成 $ t $ 块，对于每个块进行预处理。

考虑每块会对答案产生影响的信息，可以想到每块各数字的个数，我们可以用前缀和的方式维护数组 $ blo[i][j] $ 表示前 $ i $ 块第 $ j $ 个数的个数，再在局部暴力累加个数，统计答案。

但这种做法在每次累加完后都需要查找数组统计答案，由于每次累加个数时，通过奇偶的变化，我们都可以知道答案的变化。

由此我们可以处理 $ num[i][j] $ 表示第 $ i $ 块到第 $ j $ 块的答案，每次朴素处理时维护即可。

### 代码

```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
using namespace std;
int val[100001];
int pos[100001],L[100001],R[100001];
int blo[400][100001],num[400][400];
int t;
int buc[100001];
int solve(int l,int r){
	int q=pos[l],p=pos[r];
	if(p-q<=1){
		int cnt=0;
		for(int i=l;i<=r;i++){
			buc[val[i]]++;
			if(buc[val[i]]%2==0) cnt++;
			else if(buc[val[i]]>2 && buc[val[i]]%2==1) cnt--;
		}
		for(int i=l;i<=r;i++)buc[val[i]]=0;
		return cnt;
	}
	else{
		int cnt=num[q+1][p-1];
		for(int i=l;i<=R[q];i++){
			blo[p-1][val[i]]++;
			if((blo[p-1][val[i]]-blo[q][val[i]])%2==0) cnt++;
			else if((blo[p-1][val[i]]-blo[q][val[i]])>2) cnt--;
		}
		for(int i=L[p];i<=r;i++){
			blo[p-1][val[i]]++;
			if((blo[p-1][val[i]]-blo[q][val[i]])%2==0) cnt++;
			else if((blo[p-1][val[i]]-blo[q][val[i]])>2) cnt--;
		}
		for(int i=l;i<=R[q];i++)blo[p-1][val[i]]--;
		for(int i=L[p];i<=r;i++)blo[p-1][val[i]]--;
		return cnt;
	}
}
int main(){
	int n,c,m;
	cin>>n>>c>>m;
	for(int i=1;i<=n;i++) cin>>val[i];
	t=sqrt(n);
	for(int i=1;i<=t;i++){
		L[i]=(i-1)*t+1;
		R[i]=i*t;
	}
	if(R[t]<n){
		t++;
		L[t]=R[t-1]+1;
		R[t]=n; 
	}
	for(int i=1;i<=t;i++)for(int j=L[i];j<=R[i];j++)pos[j]=i;
	for(int i=1;i<=t;i++){
		for(int j=0;j<=c;j++)blo[i][j]=blo[i-1][j];
		for(int j=L[i];j<=R[i];j++) blo[i][val[j]]++;
	}
	for(int i=1;i<=t;i++){
		int cnt=0;
		for(int j=i;j<=t;j++){
			for(int k=L[j];k<=R[j];k++){
				buc[val[k]]++;
				if(buc[val[k]]%2==0) cnt++;
				else if(buc[val[k]]>2) cnt--;
			}
			num[i][j]=cnt;
		}
		memset(buc,0,sizeof(buc));
	}
	int l,r,ans=0;
	for(int i=1;i<=m;i++){
		cin>>l>>r;
		l=((l+ans)%n)+1;
		r=((r+ans)%n)+1;
		if(l>r) swap(l,r);
		ans=solve(l,r);
		cout<<ans<<endl;
	}
    return 0;
}

```


---

## 作者：happybob (赞：0)

分块经典题。

这种题显然是数据结构，$1 \leq n \leq 10^5$，考虑根号复杂度做法。于是考虑使用分块。

我们先预处理出两个值：$res_{i, j}, cnt_{i, j}$，$res_{i,j}$ 表示第 $i$ 块到第 $j$ 块的答案，$cnt_{i, j}$ 表示从第 $1$ 块到第 $i$ 块中 $j$ 出现的次数。

那么若要求第 $l$ 块到第 $r$ 块中 $x$ 出现的次数，保证 $l \leq r$，就是 $cnt_{r, x} - cnt_{l - 1, x}$。查询同块暴力，不同块的时候先求整块，然后对零散块求出与整块的答案的差即可。

复杂度 $O(n \sqrt{n})$。

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <map>
#include <cstring>
#include <unordered_map>
using namespace std;

const int N = 1e5 + 5, M = 325;

int n, m, c;
int a[N], ans = 0, l, r;

int bel[N], block;

int mph[N];
bool vis[N];

int g[M][N], res[M][M];

#define L(x) ((x - 1) * block)

#define get(l, r, x) (l > r ? 0 : g[r][x] - g[l - 1][x])

int main()
{
	scanf("%d%d%d", &n, &c, &m);
	block = sqrt(n);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]), bel[i] = i / block + 1;
	for (int i = 1; i <= bel[n]; i++)
	{
		for (int j = 0; j <= c; j++) g[i][j] = g[i - 1][j];
		int l = L(i), r = L(i + 1) - 1;
		for (int j = l; j <= r; j++) g[i][a[j]]++;
	}
	for (int i = 1; i <= bel[n]; i++)
	{
		for (int j = i; j <= bel[n]; j++)
		{
			res[i][j] = res[i][j - 1];
			int l = L(j), r = L(j + 1) - 1;
			for (int k = l; k <= r; k++)
			{
				if (vis[a[k]]) continue;
				int pre = get(i, j - 1, a[k]), now = get(j, j, a[k]);
				if (pre == 0)
				{
					if (!(now & 1)) res[i][j]++;
				}
				else if (pre % 2 != (pre + now) % 2)
				{
					if (pre % 2) res[i][j]++;
					else res[i][j]--;
				}
				vis[a[k]] = true;
			}
			for (int k = l; k <= r; k++) vis[a[k]] = false;
		}
	}
	while (m--)
	{
		int l, r;
		scanf("%d%d", &l, &r);
		l = (l + ans) % n + 1, r = (r + ans) % n + 1;
		if (l > r) swap(l, r);
		ans = 0;
		if (bel[l] == bel[r])
		{
			for (int i = l; i <= r; i++)
			{
				mph[a[i]]++;
			}
			for (int i = l; i <= r; i++)
			{
				int x = mph[a[i]];
				if (x > 0 && x % 2 == 0) ans++;
				mph[a[i]] = 0;
			}
		}
		else
		{
			int nl = bel[l] + 1, nr = bel[r] - 1;
			int rl = L(bel[l] + 1) - 1, lr = L(bel[r]);
			ans = res[nl][nr];
			for (int i = l; i <= rl; i++) mph[a[i]]++;
			for (int i = lr; i <= r; i++) mph[a[i]]++;
			for (int i = l; i <= rl; i++)
			{
				if (vis[a[i]]) continue;
				int pre = get(nl, nr, a[i]), now = mph[a[i]];
				if (pre == 0)
				{
					if (!(now & 1)) ans++;
				}
				else if (pre % 2 != (pre + now) % 2)
				{
					if (pre & 1) ans++;
					else ans--;
				}
				vis[a[i]] = true;
				mph[a[i]] = 0;
			}
			for (int i = lr; i <= r; i++)
			{
				if (vis[a[i]]) continue;
				int pre = get(nl, nr, a[i]), now = mph[a[i]];
				if (pre == 0)
				{
					if (!(now & 1)) ans++;
				}
				else if (pre % 2 != (pre + now) % 2)
				{
					if (pre & 1) ans++;
					else ans--;
				}
				vis[a[i]] = true;
				mph[a[i]] = 0;
			}
			for (int i = l; i <= rl; i++) vis[a[i]] = false;
			for (int i = lr; i <= r; i++) vis[a[i]] = false;
		}
		printf("%d\n", ans);
	}
	return 0;
}
```




---


# 楼房重建

## 题目描述

小 A 的楼房外有一大片施工工地，工地上有 $N$ 栋待建的楼房。每天，这片工地上的房子拆了又建、建了又拆。他经常无聊地看着窗外发呆，数自己能够看到多少栋房子。

为了简化问题，我们考虑这些事件发生在一个二维平面上。小 A 在平面上 $(0,0)$ 点的位置，第 $i$ 栋楼房可以用一条连接 $(i,0)$ 和 $(i,H_i)$ 的线段表示，其中 $H_i$ 为第 $i$ 栋楼房的高度。如果这栋楼房上存在一个高度大于 $0$ 的点与 $(0,0)$ 的连线没有与之前的线段相交，那么这栋楼房就被认为是可见的。

施工队的建造总共进行了 $M$ 天。初始时，所有楼房都还没有开始建造，它们的高度均为 $0$。在第 $i$ 天，建筑队将会将横坐标为 $X_i$ 的房屋的高度变为 $Y_i$（高度可以比原来大—修建，也可以比原来小—拆除，甚至可以保持不变—建筑队这天什么事也没做）。请你帮小 A 数数每天在建筑队完工之后，他能看到多少栋楼房？

## 说明/提示

对于 $100\%$ 的数据，$1 \le X_i \le N$，$1 \le Y_i \le 10^9$，$1\le N,M \le 10^5$。

## 样例 #1

### 输入

```
3 4
2 4
3 6
1 1000000000
1 1```

### 输出

```
1
1
1
2```

# 题解

## 作者：枫林晚 (赞：191)

## 题目大意：

  小A在平面上(0,0)点的位置，第i栋楼房可以用一条连接(i,0)和(i,Hi)的线段表示，其中Hi为第i栋楼房的高度。如果这栋楼房上任何一个高度大于0的点与(0,0)的连线没有与之前的线段相交，那么这栋楼房就被认为是可见的。

  施工队的建造总共进行了M天。初始时，所有楼房都还没有开始建造，它们的高度均为0。在第i天，建筑队将会将横坐标为Xi的房屋的高度变为Yi(高度可以比原来大—修建，也可以比原来小—拆除，甚至可以保持不变—建筑队这天什么事也没做)。请你帮小A数数每天在建筑队完工之后，他能看到多少栋楼房？
  
## 分析：

显然可以想到进行斜率处理，通过斜率的单调递增来求出len。

其实答案就是整个1—n区间中从第一项开始，每一个大于前一项的必选，小于等于前一项的必须不选，所的得到的序列长度。

因为区间是固定的，并且发现一个区间内的答案可以通过两个子区间用某种方式进行转移。所以可以考虑到线段树做法。

线段树中只需要维护两个值，一个是区间最大值，还有一个是区间序列长度（按照刚才的理解）的值。

建树（甚至不用），修改，甚至不用pushdown，一切好说。但是发现pushup不好处理，显然两个子区间的值不能直接合并。必须满足一定关系。

可以发现，区间内的第一项一定在这个序列内，区间最大值也一定在这个序列内。

对于要被pushup的区间，它的两个子区间已经处理好了，容易知道，左儿子区间内的序列每一项一定都在这个大区间内。（因为前面形态固定，又不能选择不看到）所以只需要处理右儿子区间和左儿子区间最大值的关系，即可递归处理len值。

递归要传入该区间的值必须大于的最小值，设为lx。对于开始进入时，也就是左儿子的最大值。

1.如果l==r，该位置的值大于lx，return1，否则return0；

2.将该区间劈成两段，设为s1,s2区间。

①如果s1的最大值小于等于lx，那么s1必然不会对答案产生贡献，去找s2。即代码中：
return pushup2(lx,s2,mid+1,r)

②如果s1的最大值大于lx，那么s2中剩下的在s1,s2组成的原区间中做贡献的项一定能贡献到最终答案中。即+l(x)-l(s1)，这里注意，不是
l(s2),因为可能在l(s2)中存在的项，不一定在l(x)这个大区间中出现。所以这两个值是完全不同的概念。

之后再去寻找s1. 即：return pushup2(lx,s1,l,mid)+l(x)-l(s1);

核心代码：

```cpp
int pushup2(double lx,int x,int l,int r)
{
	if(m(x)<=lx) return 0;//剪枝
	if(a[l]>lx) return l(x);//剪枝
	if(l==r) return a[l]>lx;//①
	int s1=x<<1,s2=x<<1|1;
	int mid=(l+r)>>1;
	if(m(s1)<=lx) return pushup2(lx,s2,mid+1,r);//②
	else return pushup2(lx,s1,l,mid)+l(x)-l(s1);//③
}
```

详见代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100000+10;
int n,m;
double a[N];
struct node{
	double mx;
	int len;
	#define m(x) t[x].mx
	#define l(x) t[x].len
}t[4*N];
void pushup1(int x)
{
	m(x)=max(m(x<<1),m(x<<1|1));
}
int pushup2(double lx,int x,int l,int r)
{
	if(m(x)<=lx) return 0;
	if(a[l]>lx) return l(x); 
	if(l==r) return a[l]>lx;
	int s1=x<<1,s2=x<<1|1;
	int mid=(l+r)>>1;
	if(m(s1)<=lx) return pushup2(lx,s2,mid+1,r);
	else return pushup2(lx,s1,l,mid)+l(x)-l(s1);
}
void chan(int x,int l,int r,int to,int c)
{
	if(l==r&&l==to)
	{
		m(x)=(double)c/to;
		l(x)=1;
		return ;
	}
	int mid=(l+r)>>1;
	if(to<=mid) chan(x<<1,l,mid,to,c);
	else if(to>mid) chan(x<<1|1,mid+1,r,to,c);
	pushup1(x);
	l(x)=l(x<<1)+pushup2(m(x<<1),x<<1|1,mid+1,r);
}
int main()
{
	scanf("%d%d",&n,&m);
	int x,y;
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&x,&y);
		a[x]=(double)y/x;
		chan(1,1,n,x,y);
		printf("%d\n",t[1].len);
	}
	return 0;
}
```

## 总结：

1.其实这个题就是把pushup logn化，是pushup一种难度升级版。

2.只要可以想办法区间合并的问题，都可以尝试用线段树解决。虽然有时候一看看不出来。

---

## 作者：Nemlit (赞：121)

这道题思路真是妙啊QWQ

### [原题地址](https://www.luogu.org/problemnew/show/P4198)

题目大意：在一个平面内，求出所有的高度大于$0$的点与$(0,0)$的连线没有与之前的线段相交的楼房，带修改

看到带修改，显然会想到数据结构来维护，再看到再平面区间加减和区间查询，显然又会想到线段树。

那线段树的每一个节点要维护什么值呢？

看到题面自然会想到斜率

所以问题就可以转化成求一个最长递增的斜率

既然是单调递增，那么我们线段树的每一个节点可以维护这个节点所对应的区间的最大值，与从这段区间开头可以看到的区间内的所有楼房

那么我们要怎么查询呢？

答案显然是第一个节点（根节点）的答案

所以我们现在的主要问题就是怎么修改

对于每一个叶子节点，从这段区间头可以看到的楼房数量一定为$1$，区间斜率最大值一定为该点的斜率

那么合并呢？

显然合并区间的所有楼房一定可以看到左边的区间第一个位置看到的所有楼房（这应该很显然吧）

那么右区间呢？

我们可以先查找右区间的左区间的最大值，如果这个最大值比左区间的最大值小，那么有区间的左区间的所有答案一定看不到，所以我们就可以递归查找右区间的右区间

如果右区间的左区间的最大值比左区间的最大值大，那么原来被右区间的左区间挡住的现在一样会被挡住，我们就可以加上右区间的答案，所以我们可以递归查找右区间的左区间

但是这里有一个坑点，有区间的答案不一定是$ans$[右区间的右区间]，因为右区间的答案可能被左区间挡住，所以有区间的答案一定是$ans$[右区间]-$ans$[右区间的左区间]

每次查询的复杂度为$O(1)$，我们每次只会递归一个儿子，所以每次查询右儿子答案的复杂度为$O(logn)$，故每次修改的复杂度为$O(log^2n)$

其他的地方就和普通线段树一样了

上文可能有点~~（十分）~~抽象，可以结合代码理解
```
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<iostream>
#define re register
#define il inline
#define inf 123456789
#define debug printf("Now is %d\n",__LINE__);
using namespace std;
il int read()
{
    re int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*f;
}
#define D double
#define maxn 100005
int n,m,ans[maxn<<2];
D ma[maxn<<2];
#define ls k<<1
#define rs k<<1|1
#define max(a,b) a>b?a:b
il int query(int k,int l,int r,D maxx)
//maxx表是我们要查询的值，也就是我们要查询的比该值斜率大的斜率的楼房数
{
    if(ma[k]<=maxx)
    {
        return 0;
    }//如果这段区间的最大斜率比目前要查询的值大，那么显然对答案不会有影响，所以返回0
    if(l==r)
    {
        return ma[k]>maxx;
    }//如果是叶子节点，那么如果该点的斜率大于要查询的值就返回1，否则返回0
    else if(ma[ls]<=maxx)
    {
        return query(rs,((l+r)>>1)+1,r,maxx);
    }//如果左儿子的最大值小于等于查询值，就递归右儿子
    return query(ls,l,(l+r)>>1,maxx)+ans[k]-ans[ls];//否则递归左儿子
}
il void change(int k,int l,int r,int ll,D v)
{
    if(l==ll&&r==ll)
    {
        ans[k]=1,ma[k]=v;
        return;
    }
    re int mid=(l+r)>>1;
    if(ll<=mid) change(ls,l,mid,ll,v);
    else change(rs,mid+1,r,ll,v);
    ma[k]=max(ma[ls],ma[rs]);
    //目前区间的最大值显然是左右区间的最大值的最大值
    ans[k]=ans[ls]+query(rs,mid+1,r,ma[ls]);
    //该区间的答案是左区间的答案加上右区间的斜率大于左区间最大值的所有楼房
}
int main()
{
    n=read(),m=read();
    for(re int i=1,l,r;i<=m;++i)
    {
        l=read(),r=read();
        change(1,1,n,l,(D)r/l);//注意斜率要用double
        printf("%d\n",ans[1]);
    }
    return 0;
}
```

---

## 作者：TheShadow (赞：56)

# 闲扯

这题的题面有问题。

# 题面

[P4198 楼房重建](https://www.luogu.org/problem/P4198)

# Solution

这道题我们不需要看题面给的解释（因为有问题），只需要用我们的生活常识来判断就行。

我们能看到一栋楼，当且仅当这栋楼最高点与原点的连线没有经过任意一个在它前面的楼。（交于一点也不行，相似三角形搞一搞就可以看出）

我们将每一栋楼的权值定义为最高点与原点的连线的斜率，那么我们需要维护的是以第一栋楼为起点的不下降的子序列的长度。（可以证明这是唯一的）

单点修改肯定是没有什么问题的，我们需要解决的问题是如何维护这个长度。

对于一个区间，我们一定是以它的最左边的楼为起点。

当两个区间合并时，左区间的答案显然是不会变的，而右区间我们需要找到第一个大于左区间的最大值的点，然后以这个点为起点，将剩下的连上。

所以我们只需要找到这个点的位置就行。

我们可以二分一下。

定义 $get(x,k)$ 表示 $x$ 代表的区间里，第一个大于 $k$ 的位置开始的序列的长度。

1. 如果左区间的最大值大于 $k$ ，我们就找左区间，右区间的所有用到了的肯定会对答案造成 $ans_x-ans_{lc}$ 的贡献。
2. 如果左区间的最大值不大于 $k$ ，我们就找右区间。
3. 如果当前区间的最大值都不大于 $k$ ，直接返回 $0$ ，表示找不到。

这样我们就可以解决合并的问题了，直接上线段树即可。

# Code

```c++
#include<bits/stdc++.h>
#define del(a,i) memset(a,i,sizeof(a))
#define ll long long
#define inl inline
#define il inl void
#define it inl int
#define ill inl ll
#define re register
#define ri re int
#define rl re ll
#define mid ((l+r)>>1)
#define lowbit(x) (x&(-x))
#define INF 0x3f3f3f3f
using namespace std;
template<class T>il read(T &x){
	int f=1;char k=getchar();x=0;
	for(;k>'9'||k<'0';k=getchar()) if(k=='-') f=-1;
	for(;k>='0'&&k<='9';k=getchar()) x=(x<<3)+(x<<1)+k-'0';
	x*=f;
}
template<class T>il _print(T x){
	if(x/10) _print(x/10);
	putchar(x%10+'0');
}
template<class T>il print(T x){
	if(x<0) putchar('-'),x=-x;
	_print(x);
}
ll mul(ll a,ll b,ll mod){long double c=1.;return (a*b-(ll)(c*a*b/mod)*mod)%mod;}
it qpow(int x,int m,int mod){
	int res=1,bas=x%mod;
	while(m){
		if(m&1) res=(1ll*res*bas)%mod;
		bas=(1ll*bas*bas)%mod,m>>=1;
	}
	return res%mod;
}
const int MAXN = 1e5+5;
int n,m,x,y;
#define lc (cur<<1)
#define rc (cur<<1|1)
struct Seg_Tree{
	double mx;
	int len;
}T[MAXN<<2];
it get(int cur,int l,int r,double k){
	if(T[cur].mx<=k) return 0;
	if(l==r) return (T[cur].mx>k);
	if(T[lc].mx<=k) return get(rc,mid+1,r,k);
	return get(lc,l,mid,k)+T[cur].len-T[lc].len;
}
il pushup(int cur,int l,int r){
	T[cur].len=T[lc].len+get(rc,mid+1,r,T[lc].mx);
	T[cur].mx=max(T[lc].mx,T[rc].mx);
}
il updata(int cur,int l,int r,int pos,double k){
	if(l==r) return T[cur].mx=1.*k/pos,T[cur].len=1,void();
	if(mid>=pos) updata(lc,l,mid,pos,k);
	else updata(rc,mid+1,r,pos,k);
	pushup(cur,l,r);
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n),read(m);
	for(ri i=1;i<=m;++i){
		read(x),read(y);
		updata(1,1,n,x,y);
		print(T[1].len),puts("");
	}
	return 0;
}
```

# 总结

据说是一个经典模型，叫李超树。然而网上的李超树全是维护线段、直线的？

老师表示：这不是以讹传讹吗！

---

## 作者：donkeys (赞：38)

我们使用一个以时间为下标的吉老师线段树。从前往后按照位置扫描，然后对线段树进行区间最大值修改。每被修改一次就加一，最后输出 $1\sim n$ 的值即可。

具体而言，我们可以把坐标看作横轴，把时间看作纵轴，在纵轴上维护一颗线段树。沿着横轴扫描，到每个位置，我们都能直到它在某一时刻的高度。于是我们把高度和坐标转化为斜率，对纵轴进行区间最大值操作。如果修改成功，那么意味着这幢楼房在这个时刻可见，把答案在这个区间上 $+1$。

然后在最后查询每个时刻对应的次数输出就是答案。

到实现上的话，有一个注意点是次数的统计是这个区间最小值被修改的次数，而不是整个区间被修改的次数。这个次数会随着修改和查询下传。


```cpp
#include<bits/stdc++.h>
using namespace std;
namespace IO
{
	bool EOFstate = 0;
	template<typename T>inline void read(T& x)
	{
		x = 0; int f = 1; char c = getchar();
		while (('0' > c || c > '9') && !EOFstate) { if (c == '-')f = -1; c = getchar(), EOFstate = c == EOF; }
		while ('0' <= c && c <= '9')x = (x << 3) + (x << 1) + c - '0', c = getchar();
		x *= f;
	}
	template<typename T = int>inline T read()
	{
		T x;
		x = 0; int f = 1; char c = getchar();
		while (('0' > c || c > '9') && !EOFstate) { if (c == '-')f = -1; c = getchar(), EOFstate = c == EOF; }
		while ('0' <= c && c <= '9')x = (x << 3) + (x << 1) + c - '0', c = getchar();
		x *= f;
		return x;
	}
	template<typename T>inline void write(T x, char end = ' ')
	{
		if (x == 0)return putchar('0'), putchar(end), void();
		if (x < 0)putchar('-'), x = -x;
		char c[21], cnt = 0;
		while (x)c[cnt++] = x % 10 + '0', x /= 10;
		while (cnt)putchar(c[--cnt]); putchar(end);
	}
}using namespace IO;//快读快写板子

const int N = 100005, inf = 0x7fffffff;
int n, m;
struct Opt
{
	int p, t;
	double v;
	inline void rd(int i)
	{
		t = i;
		read(p), v = read();
		v /= p;
	}
	inline friend bool operator<(Opt a, Opt b)
	{
		return a.p == b.p ? a.t < b.t : a.p < b.p;
	}
}opt[N];//存储修改操作

struct Node
{
	double mn, se = inf;
	int v = 0;//最小次小和次数
}t[N << 2];
#define ls p<<1
#define rs p<<1|1
inline void pushup(int p)
{//合并节点,维护最小和次小值
	if (t[ls].mn == t[rs].mn)
		t[p].mn = t[ls].mn, t[p].se = min(t[ls].se, t[rs].se);
	else if (t[ls].mn < t[rs].mn)
		t[p].mn = t[ls].mn, t[p].se = min(t[ls].se, t[rs].mn);
	else
		t[p].mn = t[rs].mn, t[p].se = min(t[ls].mn, t[rs].se);
}
inline void pushdown(int p)
{//下传次数和最值
	if (t[ls].mn <= t[p].mn)
		t[ls].mn = t[p].mn, t[ls].v += t[p].v;
	if (t[rs].mn <= t[p].mn)
		t[rs].mn = t[p].mn, t[rs].v += t[p].v;
	t[p].v = 0;
}
inline void update(int p, double v)
{//对一个节点取max操作
	if (t[p].mn >= v)
		return;
	if (t[p].se > v)
		return t[p].mn = v, t[p].v++, void();
	pushdown(p), update(ls, v), update(rs, v), pushup(p);
}
inline void modify(int p, int L, int R, int l, int r, double v)
{
	if (l <= L && R <= r)
		return update(p, v);
	pushdown(p);
	int mid = L + R >> 1;
	if (l <= mid)
		modify(ls, L, mid, l, r, v);
	if (r > mid)
		modify(rs, mid + 1, R, l, r, v);
	pushup(p);
}
inline int query(int p, int L, int R, int x)
{
	if (L == R)
		return t[p].v;
	pushdown(p);
	int mid = L + R >> 1;
	if (x <= mid)
		return query(ls, L, mid, x);
	else
		return query(rs, mid + 1, R, x);
}
#undef ls
#undef rs

int main()
{
	read(n), read(m);
	for (int i = 1; i <= m; ++i)
		opt[i].rd(i);
	sort(opt + 1, opt + m + 1);
	for (int i = 1, ne = 0; i <= m; ++i)
	{
		if (opt[i].p != opt[i + 1].p)
			ne = m + 1;
		else
			ne = opt[i + 1].t;
		modify(1, 1, m, opt[i].t, ne - 1, opt[i].v);
	}
	for (int i = 1; i <= m; ++i)
		write(query(1, 1, m, i), '\n');
	return 0;
}


```


~~感谢 @rxjdasiwzl @401rk8 的敦促~~

---

## 作者：Soulist (赞：26)

~~神题~~

------------------------

$Step1:$ 

我们考虑先写个暴力跑这个数据，发现貌似是通过一个单调栈来实现的，我们要找的貌似是一个从$1$号点开始的一个单调增序列（斜率）

于是非常有意思的一点就是你发现这个东西很难维护，有没有什么好的方式去维护他呢？

$Step2:$

我们尝试用一个线段树去维护，初始钦定$0$号点必选，斜率为$0$

对于每个节点我们用三个量来维护它$(fr,mx,len)$分别表示这个区间开始的点是谁和区间最大值以及长度。用这两个量来表示这个区间内单调增的序列。

我们可以发现，区间开始的点和区间最大值的点一定都在这个区间内的单调上升的区间内。

假设我们先求出了所有的长度，现在要兹娃修改？

$Step3:$

注意到每次修改只会动$log$个节点，我们发现只有这$\log$个节点的上升序列会被修改。

要$O(1)$去重新求长度显然是非常难的，我们有没有什么好办法呢？

注意到假设当前需要更新$x$节点的区间长度，那么$ls(x)$和$rs(x)$的信息必然已经求出。

考虑$x$节点管辖的区间$[l,r]$内左区间必然是钦定要选入的，所以长度会自带一个$tr[ls(x)].len$，如果我们能快速求出右区间内比$tr[ls(x)].mx$的最大值更大的点为起点的单调增序列长度，那么就很$nice$了

于是我们把这个操作**抽象**成为一个询问，那么现在要解决的问题是，通过已知的信息，求出区间$[mid+1,r]$比$tr[ls].mx$大的上升序列的长度。

这个东西可以递归的询问，如果一段区间的起点比这个值(当前询问值)大，那么我们就直接返回这个区间的长度。

否则如果这段区间的最大值仍然比当前询问值大，那么我们就返回$0$

如果上述两种都不满足，就递归处理左右儿子。

于是你打出了如下的代码：

```cpp
int query( int x, int l, int r, double Max ) {
    if( l == r ) return v[l] > Max ; 
    int len = 0, mid = ( l + r ) >> 1;
    if( v[tr[x].fr] > Mx ) return tr[x].len ; 
    if( tr[x].mx <= Mx ) return 0 ; 
    return query( ls(x), l, mid, Max ) + query( rs(x), mid + 1, r, max( Max, tr[ls(x)].mx ) ) ; 
}
```

你发现以这个询问来处理长度，不仅跑的慢得飞起，还$T$了。。。

仔细思考，这明显是一个上界为$O(n)$的函数，所以它会理所当然的跑的慢。

我们能优化吗？

**这个当中明显有一个部分造成了它巨大的复杂度：**

```cpp
return query( ls(x), l, mid, Max ) + query( rs(x), mid + 1, r, max( Max, tr[ls(x)].mx ) ) ; 
```

我们考虑优化它

发现如果左儿子区间内最大值比当前最大值小，那么我们忽略左区间，直接递归处理右区间。

如果左儿子区间内最大值比当前最大值大，那么右儿子区间长度我们实际上已经求出来，即整个区间的长度(当前处理到)$-$左儿子区间长度。

这个可以通过自己画图感性理解。

于是你将原来的```query```改成了这个样子：

```cpp
int query( int x, int l, int r, double Max ) {
	if( l == r ) return v[l] > Max ; 
	int mid = ( l + r ) >> 1;
	if( tr[ls(x)].mx <= Max ) return query( rs(x), mid + 1, r, Max ) ; 
	else return query( ls(x), l, mid, Max ) + tr[x].len - tr[ls(x)].len ; 
}
```

这样的复杂度就做到了$O(\log n)$了

总复杂度$O(n \log^2 n)$

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define re register
#define ls(x) x * 2
#define rs(x) x * 2 + 1
#define F(x) tr[x].fr
int read() {
	char cc = getchar(); int cn = 0, flus = 1;
	while(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }
	while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
	return cn * flus;
}
const int N = 200000 + 5 ; 
int n, m, top ; 
double v[N] ; 
struct Tree {
	double mx ; 
	int fr, len ; 
} tr[N * 4];
int query( int x, int l, int r, double Max ) {
	if( l == r ) return v[l] > Max ; 
	int mid = ( l + r ) >> 1;
	if( tr[ls(x)].mx <= Max ) return query( rs(x), mid + 1, r, Max ) ; 
	else return query( ls(x), l, mid, Max ) + tr[x].len - tr[ls(x)].len ; 
}
void update( int wh, double w, int x, int l, int r ) {
	if( l == r ) {
		tr[x].mx = w, tr[x].fr = l, tr[x].len = 1 ; return ;
	}
	int mid = ( l + r ) >> 1 ;
	if( wh <= mid ) update( wh, w, ls(x), l, mid ) ;
	else update( wh, w, rs(x), mid + 1, r ) ; 
	tr[x].len = tr[ls(x)].len + query( rs(x), mid + 1, r, tr[ls(x)].mx ); 
	tr[x].mx = max( tr[ls(x)].mx, tr[rs(x)].mx ) ;
}
void build( int x, int l, int r ) {
	tr[x].fr = l ; if( l == 1 ) tr[x].len = 1 ;  
	if( l == r ) return ; 
	int mid = ( l + r ) >> 1 ; 
	build( ls(x), l, mid ), build( rs(x), mid + 1, r ) ;  
}
signed main()
{
	n = read(), m = read() ; 
	int x ; build( 1, 1, n + 1 ) ;
	rep( i, 1, m ) {
		x = read(), v[x + 1] = ( 1.0 * read() ) / ( 1.0 * x ) ; 
		update( x + 1, v[x + 1], 1, 1, n + 1 ) ;
		printf("%d\n", tr[1].len - 1 ) ; 
	}
	return 0;
}

```



---

## 作者：优秀的渣渣禹 (赞：20)

蒟蒻渣渣禹看到这个题时十分不想写线段树emmmm

于是乎。。。。分块！！！

分块。思路就是：如果一个楼房能被看见，当且仅当它的房顶到(0,0)连线的斜率 比前面的都大。我们暴力维护每个块内斜率的最长上升序列，然后查询的时候二分找到块内第一个能看到的，那么它之后的所有最长上升序列里的元素就都能被看到，再去搜下一个块就好了。


下面我来讲下具体过程，我们要求的个数，就是斜率最长上升子序列，大家思考一下。。。显然成立。

我们设a，b以及他们的高度为h[a],h[b],如果a不会被b挡住，那么我们可以推出这样一个式子：h[a]/a >= h[b]/b，交叉相乘之后可得：h[a]*b >= h[b]*a。

对于原点的话我们只要判断h[a]是否大于0就行了。

修改：然后我们暴力更新块内元素信息，每次清零，重新维护块内最长上升序列长度。

查询：我们设last为上一个满足条件的块的末尾节点，那么从第一块开始到最后一块，在块内进行二分查找出与last相比刚满足条件的点，那么，从这个点一直到末尾均为合法序列，那么ans=这段序列的长度qwq，然后更新last为本块的末尾。

我们在暴力搞定每个块的递增数列，把这些斜率从小到大塞到一个栈里边（时间复杂度O(n/b)，b为块的大小）。

然后查找时从头开始，在每个块对应的栈中二分查找第一个斜率比前一个大的位置，这个位置和栈里面后边的位置都能被看到（时间复杂度O(blog(n/b))）。

总时间复杂度为O(n*(n/b + blog(n/b)))≈O(n*(n/b + blogn))。

这样一来b=√(n/logn)/2有奇效。想知道为什么么？

通过我巨水无比的计算，以及一次次试错试出的，不然会tle，除非你开o2，强烈建议用快读。

不用o2优化代码如下qwq

```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 100005
#define LL long long
using namespace std;;
int n,m,b,h[N],p[N];
struct stack {
    int s[N],top;
}t[330];
bool check(LL a,LL b) {
    if(!b)
        return h[a] > 0;
    return (LL)(h[a] * b) > (LL)(h[b] * a);
}
inline int read() 
{
    int w=0;
    char ch;
    while(ch<'0'||ch>'9')
    {
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        w=(w<<3)+(w<<1)+ch-'0';
        ch=getchar();
    }
    return w;
}
int main() {
    n=read();
    m=read();
    b = sqrt(n * log(n) / 2);
    for(register int i = 1;i <= n;i++) 
        p[i] = (i - 1) / b + 1;
    while(m--) {
        int x,ans = 0;
        x=read();
        h[x]=read();
        register int l = (p[x] - 1) * b + 1,r = min(n,p[x] * b);
        t[p[x]].top = 0;
        for(register int i = l;i <= r;i++)
            if(check(i,t[p[x]].s[t[p[x]].top]))
                t[p[x]].s[++t[p[x]].top] = i;
        for(register int i = 1,last = 0;i <= p[n];i++) {
            register int q = 0;
            l = 1,r = t[i].top;
            while(l <= r) {
                register int mid = (l + r) >> 1;
                if(check(t[i].s[mid],last)){ 
                    q = mid;
                    r = mid - 1;
                }
                else l = mid + 1;
            }
            if(q){
                last = t[i].s[t[i].top];
                ans += t[i].top - q + 1;
            }
        }
        printf("%d\n",ans);
    }
}
```

---

## 作者：i207M (赞：16)

## 题目总结

维护一个序列，在线单点修改，求出每一时刻各段的前缀最大值数目；

## 数据范围

对于所有的数据1<=Xi<=N，1<=Yi<=10^9

N,M<=100000

## 解题思路

使用线段树动态维护每个区间的最大值、最长上升子序列；

### change
```cpp
void change(int l, int r, int x, int &q, double &k) {
    if (l >= r) {
        mx[x] = k;
        cnt[x] = 1;
        return;
    }
    gm;
    if (q <= mid) change(l, mid, ls, q, k);
    else change(mid + 1, r, rs, q, k);
    mx[x] = max(mx[ls], mx[rs]);
    cnt[x] = cnt[ls] + count(mid + 1, r, rs, mx[ls]);
}
```
二分到目标点，修改目标点的mx；很显然的，每个单点的cnt（最长上升子序列）都是1；

然后递归回溯处理，更新mx；每个区间的左区间一定会为答案产生贡献，而右区间能为答案产生贡献的点必须大于左区间最大点，所以调用count( )，然后更新cnt;

### count

统计区间[ l , r ]内最小值大于k的最长上升子序列；

```cpp
int count(int l, int r, int x, double &k) {
    if (l >= r) return mx[x] > k; // 若是单点，则如果当前点的值大于k，返回1
    gm;
    if (mx[ls] <= k) return count(mid + 1, r, rs, k);
    // 如果左区间最大值都小于k，那么对答案产生贡献的只有右区间
    else return cnt[x] - cnt[ls] + count(l, mid, ls, k);
    // 否则，当前区间的右区间能取的数量（cnt[x] - cnt[ls]）（注意不是cnt[rs]，要考虑左区间的遮挡）不会变，因为本来被左区间遮住的还是会被遮住；这时递归处理右区间
}
```

## 易错误区

修改时记得是修改斜率

注意count统计的方法；

## 代码展示

count为O( log n )的复杂度，change需要调用log次count

```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 400005
#define ll long long
#define inf 0x3f3f3f3f
#define ri register int
#define il inline
#define fi first
#define se second
#define mp make_pair
#define pi pair<int,int>
#define mem0(x) memset((x),0,sizeof(x))
#define mem1(x) memset((x),0x3f,sizeof(x))
#define gm int mid=(l+r)>>1
#define ls (x<<1)
#define rs (x<<1|1)
int n, m;
int rt;
double mx[N];
int cnt[N];
int count(int l, int r, int x, double &k) {
    if (l >= r) return mx[x] > k;
    gm;
    if (mx[ls] <= k) return count(mid + 1, r, rs, k);
    else return cnt[x] - cnt[ls] + count(l, mid, ls, k);
}
void change(int l, int r, int x, int &q, double &k) {
    if (l >= r) {
        mx[x] = k;
        cnt[x] = 1;
        return;
    }
    gm;
    if (q <= mid) change(l, mid, ls, q, k);
    else change(mid + 1, r, rs, q, k);
    mx[x] = max(mx[ls], mx[rs]);
    cnt[x] = cnt[ls] + count(mid + 1, r, rs, mx[ls]);
}
int main() {
    scanf("%d%d", &n, &m);
    rt = 1;
    int x, y;
    double t;
    while (m--) {
        scanf("%d%d", &x, &y);
        t = (double)y / x;
        change(1,n,rt,x, t);
        printf("%d\n", cnt[rt]);
    }
    return 0;
}
```

---

## 作者：Uniecho1 (赞：11)

这个题着实是一个线段树好题。

按照刘汝佳的观点，我们先不考虑复杂度，从最脑残的做法开始想

首先是每修改一次就查询一次，复杂度O（N*M），显然不行的。

然后脑补一下，很容易想出线段树+小优化：维护每个区间的最大斜率，如果区间斜率小于了前面的最大斜率，就可以跳过这个区间。

蒟蒻作者试了这个做法，50pts似乎还行，核心代码如下：
```cpp
int query(double foremax,int l,int r,int id){
    if(l==r)return 1;
    int m=(l+r)>>1,ans=0;
    if(maxk[id<<1]>foremax){
        ans+=query(foremax,l,m,id<<1);
        foremax=maxk[id<<1];
    }
    if(maxk[id<<1|1]>foremax)
        ans+=query(foremax,m+1,r,id<<1|1);
    return ans;
}
```

好了，开始想更优的算法——既然我们可以用max去卡区间，为什么不再用min去卡他呢？？

于是再引入两个数组：min与maxl分别表示区间最小值和区间单调增序列长度。这样我们就能在区间最小值大于前面的最大值时，直接补上这个区间的序列长度。核心代码如下：
```cpp
int get(int l,int r,int id,double foremax){
    int m=(l+r)>>1,ans=0;
    if(mink[id]>foremax)return maxl[id];
    if(maxk[id<<1]>foremax){
        ans+=get(l,m,id<<1,foremax);
        foremax=maxk[id<<1];
    }
    if(maxk[id<<1|1]>foremax)
        ans+=get(m+1,r,id<<1|1,foremax);
    return ans;
}
inline void change(int x,int l,int r,int id,int k){
    if(x==l&&l==r){
        mink[id]=maxk[id]=(double)k/x;
        maxl[id]=1;
        return;
    }
    int m=(l+r)>>1;
    if(x<=m)change(x,l,m,id<<1,k);
    else change(x,m+1,r,id<<1|1,k);
    maxk[id]=max(maxk[id<<1],maxk[id<<1|1]);
    mink[id]=min(mink[id<<1],mink[id<<1|1]);
    maxl[id]=maxl[id<<1];
    if(maxk[id<<1|1]>maxk[id<<1])
    maxl[id]+=get(m+1,r,id<<1|1,maxk[id<<1]);
}
```
然而60pts，酸爽。
继续想优化。然后——

我们会发现，如果我们算出了左区间的单调递增长度，就可以直接用这一层区间单调递增长度直接减去左区间未选长度来出解。
而要是左区间被max卡掉了，那我们只需要相同子问题转化，直接查询右区间就完了（想一想为什么via刘汝佳）。

于是.....就满分了！核心代码如下
```cpp
int get(int l,int r,int id,double foremax){
    int m=(l+r)>>1,ans=0;
    if(mink[id]>foremax)return maxl[id];
    if(maxk[id<<1]>foremax)
        return maxl[id]+get(l,m,id<<1,foremax)-maxl[id<<1];
    if(maxk[id<<1|1]>foremax)
        return get(m+1,r,id<<1|1,foremax);
}
inline void change(int x,int l,int r,int id,int k){
    if(x==l&&l==r){
        mink[id]=maxk[id]=(double)k/x;
        maxl[id]=1;
        return;
    }
    int m=(l+r)>>1;
    if(x<=m)change(x,l,m,id<<1,k);
    else change(x,m+1,r,id<<1|1,k);
    maxk[id]=max(maxk[id<<1],maxk[id<<1|1]);
    mink[id]=min(mink[id<<1],mink[id<<1|1]);
    maxl[id]=maxl[id<<1];
    if(maxk[id<<1|1]>maxk[id<<1])
    maxl[id]+=get(m+1,r,id<<1|1,maxk[id<<1]);
}
```
emmmm，如果有什么错误请直接指出来哦？

---

## 作者：Tmbcan (赞：10)

## [P4198 楼房重建](https://www.luogu.com.cn/problem/P4198)
### 题目描述
有 $N$ 栋正在坐标轴上修建的楼房和 $M$ 个时间节点，已知每个时间节点上会有一栋楼的高度发生变化。  问对于每个时间节点，小 A 在原点可以看到几栋楼房（基于日常生活理解）。
### 思路
第 $i$ 栋楼房最高点到原点连线的斜率记作 $k_i$，不难发现：  
如果想要看到第 $i$ 栋楼房，则需满足 $k_{i-1}< k_i$。  
那么我们需要求的就是斜率 $k$ 的**最长上升子序列长度**，且应满足：
1. $k_1$ 必须选；
2. 若 $k_{i-1}<k_i$ 且选了 $k_{i-1}$，则 $k_i$ 必须选。

考虑如何维护状态。  
由于 zkw 线段树的性质，修改时直接改叶子节点即可，所以重点考虑如何合并信息。  

显然地，对于一个区间，我们所选的起始楼房越靠左侧越好。所以在合并时，左区间答案始终不变，对右区间进行二分查找第一个大于左区间最大值的值。  

所以我们需要记录每个区间的 $k$ 的最大值，并且在查找右区间的过程中：  
1. 如果右区间最大值都比左区间最大值小了，那右区间对答案没有贡献；
2. 如果右区间对答案有贡献，就继续向下查找；
3. 当找到叶子节点时，看节点值是否大于左区间最大值。

基于 zkw 线段树的性质，其父子节点关系严格确定，所以我们不需要二次递归进行求解，只要循环模拟我们刚才所说的二分答案过程即可。  

### 代码
```cpp
//单点修改、区间查询问题都可以使用 zkw 线段树维护
//push_up过程直接当成循环模拟
//代码简洁、常数优于递归线段树，可以有效避免卡常
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<climits>
#include<cstdlib>
#include<vector>
using namespace std;
typedef long long ll;
template <typename T>
inline void read(T&x){
	int w=0;x=0;
	char ch = getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') w=1;
		ch = getchar();
	}
	while(ch>='0'&&ch<='9'){
		x = (x<<1)+(x<<3)+(ch^48);
		ch = getchar();
	}
	if(w) x=-x;
}
template <typename T,typename...Args>
inline void read(T&t,Args&...args){
	read(t);read(args...);
}
const int N = 1e5+10;
int n,m;
int P = 1,DEP = 0;
double mx[N*3];int len[N*3];//开3倍空间
inline int query(int l,double k,int dep){
	int tl = l;
	int res = 0;
	while(dep<DEP){
		if(mx[l]<=k) break;//剪枝：右区间最大值比左区间的小
		l = l<<1|(mx[l<<1]<=k);//模拟选取左右子树过程
		dep++; 
	}
	if(dep==DEP) res = (mx[l]>k);//叶子节点
	while(l!=tl){
		if(~l&1) l>>=1,res+=len[l]-len[l<<1];//累加答案
		else l>>=1;
	}
	return res;
}
inline void update(int l,double k){
	l += P;
	//直接对叶子节点进行更新
	len[l] = 1;mx[l] = k;
	int dep = DEP;
	//从下到上维护父子结点关系
	for(l>>=1,--dep; l ;l>>=1,--dep){
		mx[l] = max(mx[l<<1],mx[l<<1|1]);
		len[l] = len[l<<1]+query(l<<1|1,mx[l<<1],dep+1);
	}
}
int main(){
	read(n,m);
	while(P<=n+1) P<<=1,++DEP;//求虚点值和整棵树的深度
	int l,r;
	while(m--){
		read(l,r);
		update(l,(1.0*r)/(1.0*l));
		printf("%d\n",len[1]);//输出根节点信息
	}
	return 0;
}
```

---

## 作者：Dispwnl (赞：7)

感觉这种线段树里强行二次递归求解挺常见的……最近遇到好多~~还是不会~~

考虑将一个区间分左右两区间的斜率最大值情况讨论

假设$val_{[l,r]}$表示区间$[l,r]$的**对自己**的贡献（$[l,r]$外的点无影响）

如果一个区间$[l,r]$左区间$[l,mid]$最大值为区间最大值，$val_{l,r}$的值就为$val_{l,mid}$，因为右区间$[mid+1,r]$都被挡住了

如果左区间最大值不是区间最大值，说明区间最大值在右区间，考虑将右区间递归求解

可以发现影响右区间的还是左区间的最大值，如果$max_{l,mid}\geq max_{l_1,r_1},mid+1\leq l_1\leq r_1\leq r$，$val_{l_1,r_1}$是没有贡献的

如果$max_{l,mid}\geq max_{l_1,mid_1}$，$val_{l_1,mid_1}$没有贡献，同时说明$max_{l_1,r_1}$存在于$[mid_1+1,r_1]$中，递归求解$[mid_1+1,r_1]$

否则修改值对$val_{mid_1+1,r_1}$没有影响，直接递归求解$[l_1,mid_1]$并加上$val_{l_1,r_1}-val_{l_1,mid_1}$

为什么不是$val_{mid_1+1,r_1}$？

![](https://a-failure.github.io/img/？？？？？.jpg)

$val_{l,r}$表示区间$[l,r]$的**对自己**的贡献，也就是忽略了区间外的影响，而我们要求的是受$[l_1,mid_1]$影响的$[mid_1+1,r_1]$贡献，所以用$val_{l_1,r_1}-val_{l_1,mid_1}$，ta们都受$[l_1,mid_1]$的影响

况且区间贡献在这里不满足区间相加性啊~~不然为什么要二次递归求解qaq~~

### 代码
```
# include<iostream>
# include<cstring>
# include<cstdio>
# include<algorithm>
# define tl (k<<1)
# define tr (k<<1|1)
# define mid (l+r>>1)
using namespace std;
const int MAX=4e5+5;
struct p{
	int x;
	double maxn;
}s[MAX];
int n,m;
int read()
{
	int x(0);
	char ch=getchar();
	for(;!isdigit(ch);ch=getchar());
	for(;isdigit(ch);x=x*10+ch-48,ch=getchar());
	return x;
}
double K(double x,double y)
{
	return y/x;
}
int GET_ANS(int l,int r,int k,double x)
{
	if(l==r) return s[k].maxn>x;
	if(s[k].maxn<=x) return 0;
	if(s[tl].maxn<=x) return GET_ANS(mid+1,r,tr,x);
	return s[k].x-s[tl].x+GET_ANS(l,mid,tl,x);
}
void pus(int l,int r,int k)
{
	s[k].x=s[tl].x;
	if(s[tl].maxn>=s[tr].maxn) s[k].maxn=s[tl].maxn;
	else s[k].maxn=s[tr].maxn,s[k].x+=GET_ANS(mid+1,r,tr,s[tl].maxn);
}
void change(int l,int r,int k,int x,double dis)
{
	if(l==r)
	{
		s[k].x=1;
		return void(s[k].maxn=dis);
	}
	if(x<=mid) change(l,mid,tl,x,dis);
	else change(mid+1,r,tr,x,dis);
	pus(l,r,k);
}
int main()
{
	n=read(),m=read();
	for(int i=1,x;i<=m;++i)
	  x=read(),change(1,n,1,x,K(x,read())),printf("%d\n",s[1].x);
	return 0;
}
```


---

## 作者：Newuser (赞：6)

（区间最大可修改上升）（线段树做法，可以分块乱搞）

这道题只是询问1到n区间，其实可以改成任意区间的最大上升。

首先注意题目是连线，因此不是高度上升是斜率上升（y/x），但在之后的说明中都会说斜率为高度，大家把他想象成在楼底向上仰望看到多少栋楼。

然后造树，维护h，区间内最大的高度维护 s，区间内的最大上升子序列。

每次更新时，一边维护h和s，此时可能面临求s如果求，此时就进入询问，其s为左子树的s和代入左子树的最高值到右子树查询右子树中比左子树最高值大为起点的s

询问时如果询问的高度大于左子树最大，询问右子树，否则找左子树后将左子树的最大高度代入右子树来查找。（如果右子树的一些结点比左子树最大高度小则不可能能看到）最后成功维护s

答案直接z[1].s
    
    
	#define maxn 100005
	#define midd ((z[p].b+z[p].a)>>1)
	struct node{
	int a,b,s;
	double h;
	}z[maxn<<3];

	int n,m;
	void maketree(int p,int l,int r)
	{
	z[p].a=l; z[p].b=r;
	if(z[p].a==z[p].b)return;
	maketree(p<<1,l,midd);
	maketree(p<<1|1,midd+1,r);
	}

	int query(int p,double hh)
	{
	if(z[p].a==z[p].b){ return z[p].h>hh; }
		if(z[p<<1].h<=hh) return query(p<<1|1,hh);
		else
		{
			return query(p<<1,hh)+z[p].s-z[p<<1].s;
		}
	}

	void update(int p,int x,double val)
	{
	if(z[p].a==z[p].b){ z[p].h=val; 		z[p].s=1; return;}
	if(x<=midd) update(p<<1,x,val);
	else update(p<<1|1,x,val);
	z[p].h=max(z[p<<1].h,z[p<<1|1].h);
	z[p].s=z[p<<1].s+query(p<<1|1,z[p<<1].h);
	}

	int main()
	{
	int i,x,y;
	scanf("%d%d",&n,&m);
	maketree(1,1,n);
	for(i=1;i<=m;i++)
	{
		scanf("%d%d",&x,&y);
		update(1,x,(double)y/x);
		printf("%d\n",z[1].s);
	}
	}

---

## 作者：wwlw (赞：5)

[Link](https://www.luogu.org/problemnew/show/P4198)

---------------------

~~这么好的分块题为什么要用线段树~~

题目大意很显然，就是要求动态地维护一个以斜率为关键字的最长严格上升子序列。考虑直接维护，那么单次修改O(n)，单次查询O(1)，总时间复杂度O(nm)，显然是过不了的。那么我们就把这两个操作综合一下，变成了我们所熟知的分块。（话说好久没写过分块了）

（我因为比较懒，不想调参，直接取的$\sqrt{n}$作为块的大小）

##两个主要操作

###modify

对于修改操作，只影响一个块，每次修改都暴力重构一下，计算出每个斜率并按块内斜率排序，最后存入一个vector中（其实并不需要排序，因为本身插入的时候就是按照“单调递增——小了就跳过，大了就插入并更新斜率最大值”）单次修改时间复杂度O($\sqrt{n}$)

```cpp
inline void modify(int x,int y){
	double maxx=0;//斜率最大值
        num[x]=y;//赋值
	c[pos[x]].clear();//暴力重构
	for(int i=(pos[x]-1)*s+1;i<=pos[x]*s&&i<=n;i++){
		if(!num[i]) continue;//如果当前的位置没有楼房就跳过
		double ret=((double)num[i]/(1.0*i));//计算斜率
		if(maxx<ret) c[pos[x]].push_back(ret),maxx=ret;//插入数列，并更新max
	}
/*	for(vector<double>::iterator it=c[pos[x]].begin();it!=c[pos[x]].end();it++)
		printf("%.3lf ",*it);
	printf("\n");*/
}
```

##query

对于查询操作，枚举每一个块,在块内二分上一个块的斜率最大值（即当前块内能看到的楼房的斜率最小值），累计上答案。单次查询O($\sqrt{n}$)

```cpp

inline int query_(int x,double val){
	return c[x].end()-upper_bound(c[x].begin(),c[x].end(),val);//返回块内大于val的数的个数
}

inline int query(){
	int ans=0;
	double maxx=(double)num[st]/st;//st表示第一个的楼房的位置
	for(int i=1;i<=pos[n];i++){
		ans+=query_(i,maxx);//在块内二分
		if(c[i].empty()) continue;//当前块没有楼房就跳过
		double ret=(*(--c[i].end()));//当前块的最大值（因为块内是有序的，所以最后一个数就是当前块的最大值）
		if(maxx<ret) maxx=ret;//更新最大值
	}
	return ans+1;//第一个楼房没算，所以要+1
}
```

总时间复杂度 O(m$\sqrt{n})$) ，还算是挺优秀的吧

```cpp
#include<stdio.h>
#include<math.h>
#include<vector>
#include<algorithm>
using namespace std;
#define N 100007
#define sqN 1007

template<class T>
inline void read(T &x){
	x=0;char c=getchar();T flag=1;
	while(c<'0'||c>'9'){if(c=='-')flag=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+c-48;c=getchar();}
	x*=flag;
}

vector<double> c[sqN];
int s,n,m,pos[N],num[N],st;

inline int min(int x,int y){return x<y? x:y;}
inline int max(int x,int y){return x>y? x:y;}
inline void modify(int x,int y){
	double maxx=0;num[x]=y;
	c[pos[x]].clear();
	for(int i=(pos[x]-1)*s+1;i<=pos[x]*s&&i<=n;i++){
		if(!num[i]) continue;
		double ret=((double)num[i]/(1.0*i));
		if(maxx<ret) c[pos[x]].push_back(ret),maxx=ret;
	}
/*	for(vector<double>::iterator it=c[pos[x]].begin();it!=c[pos[x]].end();it++)
		printf("%.3lf ",*it);
	printf("\n");*/
}
inline int query_(int x,double val){
	return c[x].end()-upper_bound(c[x].begin(),c[x].end(),val);
}
inline int query(){
	int ans=0;
	double maxx=(double)num[st]/st;
	for(int i=1;i<=pos[n];i++){
		ans+=query_(i,maxx);
		if(c[i].empty()) continue;
		double ret=(*(--c[i].end()));
		if(maxx<ret) maxx=ret;
	}
	return ans+1;
}
int main(){
//	freopen("data.in","r",stdin);
//	freopen("mine.out","w",stdout);
	read(n),read(m),s=(int)(sqrt(n)+0.5),st=n+1;
	for(int i=1;i<=n;i++) pos[i]=(i-1)/s+1;
	int x,y;
	while(m--){
		read(x);read(y);
		st=min(st,x);modify(x,y);
		printf("%d\n",query());
	}
}
/*
5 7
4 6
3 2
1 19
5 11
2 17
1 1
1 1
*/ 
```

然而良（du）心（liu）的学长怎么可能就此放罢休，他把题目改成了这样：

    长度为n的数列，m次操作：
    1.求[L,R]的比之前所有数都大的数字个数
    2.将[L,R]区间增加或区间修改
    n,m≤50000

---

## 作者：galiqing (赞：3)

这道题先转换一下，把高度转为斜率，那么题目就转换成了带修的从第一个位置开始的上升子序列（大雾）。我们可以考虑用线段树解决，关键就是如何合并两个区间，这样的话我们要知道左区间的最大值，然后在右区间内找开头大于这个最大值的子序列，这怎么做呢？不断找最大值判断即可。那这道题就解决了。
```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
using namespace std;
struct node
{
    int l,r,lc,rc,c;
    double mx;
}tr[210000];int trlen;
void bt(int l,int r)
{
    trlen++;int now=trlen;
    tr[now].l=l;tr[now].r=r;
    tr[now].lc=tr[now].rc=-1;
    tr[now].mx=0.0;tr[now].c=0;
    if(l<r)
    {
        int mid=(l+r)/2;
        tr[now].lc=trlen+1;bt(l,mid);
        tr[now].rc=trlen+1;bt(mid+1,r);
    }
}
inline int getsum(int now,double x)
{
	if(tr[now].mx<=x)return 0;
    if(tr[now].l==tr[now].r)return tr[now].c;
    int lc=tr[now].lc,rc=tr[now].rc;
    if(x>=tr[lc].mx)return getsum(rc,x);
    else return getsum(lc,x)+tr[now].c-tr[lc].c;
}
inline void change(int now,int x,double k)
{
    if(tr[now].l==tr[now].r)
    {
        tr[now].mx=k;
        tr[now].c=1;if(k==0.0)tr[now].c=0;
        return ;
    }
    int lc=tr[now].lc,rc=tr[now].rc,mid=(tr[now].l+tr[now].r)/2;
    if(x<=mid)change(lc,x,k);
    else change(rc,x,k);
    tr[now].mx=max(tr[lc].mx,tr[rc].mx);
    if(tr[lc].c==0)tr[now].c=tr[rc].c;
    else tr[now].c=tr[lc].c+getsum(rc,tr[lc].mx);
}
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    bt(1,n);
    for(int i=1;i<=m;i++)
    {
        int x;double y;
        scanf("%d%lf",&x,&y);
        change(1,x,(double)y/x);
        printf("%d\n",tr[1].c);
    }
    return 0;
}
```

---

## 作者：weird_coder (赞：2)

## 题意
求从0,0点为起点，**斜率**单调上升的序列最大长度

考虑维护两个东西:
一个区间内最大的值（斜率
这个区间内上升子序列的长度

答案就是1-n这个区间内的严格上升子序列的长度

------------
## 怎么做

题目要求修改m次，每次修改后维护最大值，~~m,n的范围是100000~~
首先可以想到线段树。

线段树的具体做法
------------

不需要lazy_tag，甚至也不需要bulid只要考虑如何修改，如何合并（维护）区间就好了
重点在于push_up数组

len[o]为区间长度，m[o]为区间最大斜率 用a[x]记下每一个点的高度。lo为递归时需要满足条件（大于该上升序列最后一位）的斜率最小值  
ps:注意a和m数组都要用double

假设当前节点o的两个子区间rs和ls都已经维护好了 考虑如何合并
若左区间的最大值不大于当前要求的最小值lo，那么只需递归处理右区间。

反之，处理左区间 当前答案为（递归返回的值加上len[o]-len[ls]）
(从总区间里减去原来的左区间再加上新的左区间)

核心代码如下
```cpp
int push_up(double lo,int o,int l,int r){
	if(m[o]<=lo) return 0;
	if(a[l]>lo) return len[o];
	if(l==r){
		return a[l]>lo;
	}
	if(m[ls]<=lo) return push_up(lo,rs,mid+1,r);
	else return push_up(lo,ls,l,mid)+len[o]-len[ls];
}
```


以下是全部代码


```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<string>
#define mid (l+r>>1)
#define ls (o<<1)
#define rs ((o<<1)|1) 
using namespace std;
inline int read(){
	int s=0;char x=getchar();int f=1;
	while(!isdigit(x)){if(x=='-') f=-1;x=getchar();};
	while(isdigit(x)){s=(s<<1)+(s<<3)+x-'0';x=getchar();};
	return s*f;
}
const int N=400010;
double a[N];
double m[N];//区间内最大的斜率 
int len[N];//区间长度 
int push_up(double lo,int o,int l,int r){
	if(m[o]<=lo) return 0;//最大斜率小于要求的最小斜率 对答案贡献为0 
	if(a[l]>lo) return len[o]; //满足要求，贡献为当前区间内上升序列长度 
	if(l==r) return a[l]>lo;//满足要求贡献为1 否则为0 
	if(m[ls]<=lo) return push_up(lo,rs,mid+1,r);
	else return push_up(lo,ls,l,mid)+len[o]-len[ls];
}
void xg(int o,int l,int r,int x,int y){
	if(l==r&&l==x){
		m[o]=(double)y/x;
		len[o]=1;
		return;
	}
	if(x<=mid) xg(ls,l,mid,x,y);
	else xg(rs,mid+1,r,x,y);
	m[o]=max(m[rs],m[ls]);
	len[o]=len[ls]+push_up(m[ls],rs,mid+1,r);
	//左儿子区间长度 加上右儿子中上升子序列的长度 
}
int main(){
	int n=read(),m=read();
	int x,y;
	while(m--){
		x=read();y=read();
		a[x]=(double)y/x;//求斜率 
		xg(1,1,n,x,y);
		cout<<len[1]<<endl;
	}
	return 0;
}

```



---

## 作者：wuzhaoxin (赞：2)

### 题目大意：每次修改一个斜率，每次查询有多少个斜率是大于所有前面节点的斜率的
#### 假设现在左右儿子答案都知道，如何合并两个儿子得到当前节点答案？
##### 左儿子答案可以直接加上来，右儿子答案可能会变小，讨论右儿子的儿子的子树max，发现只要递归一边即可**(看不懂的看下面)**
```cpp
int update(int p,double h) {
	if(t[p].l==t[p].r)return t[p].mx>h;
	if(t[p*2].mx<h)return update(p*2+1,h);
	return update(p*2,h)+t[p].v-t[p*2].v;
}
void change(int p,int x,double v) {
	if(t[p].l==t[p].r) {
		t[p].mx=v;
		t[p].v=1;
		return;
	}
	int mid=(t[p].l+t[p].r)>>1;
	if(x<=mid)change(p*2,x,v);
	else change(p*2+1,x,v);
	push_up(p);//更新MAX
	t[p].v=t[p*2].v+update(p*2+1,t[p*2].mx);
}
```
### 每个节点权值代表若L以左全为0，L-R的答案
#### 若当前最大值大于左子节点最大值，左子节点全不选，递归右子节点
#### 若当前最大值小于左子节点最大值，递归左子节点，右子节点答案为当前节点权值减左子节点权值
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node {
	int l,r,v;
	double mx;
	node(){mx=0,v=0;}
}t[400001];
void build(int p,int l,int r) {
	t[p].l=l;
	t[p].r=r;
	if(l!=r) {
		int mid=(l+r)>>1;
		build(p*2,l,mid);
		build(p*2+1,mid+1,r);
	}
}
void push_up(int p) {
	t[p].mx=max(t[p*2].mx,t[p*2+1].mx);
}
int update(int p,double h) {
	if(t[p].l==t[p].r)return t[p].mx>h;
	if(t[p*2].mx<h)return update(p*2+1,h);
	return update(p*2,h)+t[p].v-t[p*2].v;
}
void change(int p,int x,double v) {
	if(t[p].l==t[p].r) {
		t[p].mx=v;
		t[p].v=1;
		return;
	}
	int mid=(t[p].l+t[p].r)>>1;
	if(x<=mid)change(p*2,x,v);
	else change(p*2+1,x,v);
	push_up(p);
	t[p].v=t[p*2].v+update(p*2+1,t[p*2].mx);
}
int query() {
	return t[1].v;
}
int n,m;
int main() {
	ios::sync_with_stdio(0);
	cin>>n>>m;
	build(1,1,n);
	int x,y;
	while(m--) {
		cin>>x>>y;
		change(1,x,y*1.0/x);
		cout<<query()<<endl;
	}
	return 0;
}
```

---

## 作者：hehelego (赞：2)

### 浅谈楼房重建一题的分块乱搞解法(雾

> 题解区怎么都是正经的std啊...只会暴力的选手就坐等爆0了????...不行啊,我们上个分块乱搞一下试试?过了!

补一个**分块**~~乱搞~~ 的题解.  

~~这个东西的std感觉浓烈的ddp味啊...~~

----

题意:
- 给定序列$slope[1..n]$.  

1. 修改$slope[x]=\frac{y}{x}$
2. 查询:$count(pos\cdot[\forall i\lt pos,slope[i]\lt slope[pos])$ 答案会是一个斜率严格增的子序列.


先考虑暴力

修改直接做,然后遍历一下$slope[1..n]$更新答案.  

我们考虑修改操作$upd(x,y)$生效后答案的变化. 

如果$slope(x)$很大,$i\lt x$部分的上升子序列可以全都保留,那么考虑后面的部分的上升子序列 **扔掉一点前缀** 使得能够和$(x,y)$拼接上去.  
如果$slope(x)$变小,那么后面会有一部分之前没有贡献而现在有贡献(当然这个部分可能是空的).  

仔细思考一下,发现这并不可做...至少很难简单实现.这就让我们看到.这个问题需要维护的数据是**无法高效合并**的,这启发我们使用分块,让影响局部化,等到查询的时候再来处理以平衡复杂度.  

做法也就比较容易想到了.对序列分块,维护**只考虑块内元素的答案(一个单调增子序列)**,修改操作直接暴力重构,这部分复杂度为$O(S)$,其中$S$为块大小.  
查询时,我们需要考虑整块前的所有元素对块的影响,显然我们要记录之前的最大斜率..那么拼接操作就是需要在这个块的上升子序列中,找到一个可以和之前的最大斜率拼接的位置,保留之后的部分.  这部分使用一个二分即可,复杂度为$O(\frac{n}{S}\times log\,S)$  .

这里遇到了修改与查询的复杂度不平衡(当然常数也不平衡...),我们可以考虑上个均值不等式看看块大小怎么取最优.

~~这里修改和查询次数相等的...没啥好搞的.~~
我们不如先假设序列大小和查询次数是同阶的(这里只是找最优的渐进理论复杂度,实际上还要考虑众多因素的影响...比较简单的方法是直接造随机数据测试出较好的块大小..).

总复杂度为$O(n\cdot (S+\frac{n}{S}\cdot log\,S))\geq O(n\sqrt{n\cdot log\,S})$...发现不好做,于是把$log\,S$近似为$log\,n$,这个影响是非常小的...当然为了严谨一点你应该求个导仔细分析一下最小值和最优的$S$.

$O(n\cdot (S+\frac{n}{S}\cdot log\,n))\geq O(n\sqrt{n\cdot log\,n})$.当$S=\frac{n}{S}log\,n$时最优,即$S=\sqrt{nlogn}$

然而我偷懒直接取$S=\sqrt n$了2333...	

---




下面代码...有些没用的东西~~调试完了没删掉~~
```cpp
#include <iostream>
#include <algorithm>
#include <ctime>
#include <cmath>
#include <cassert>
#include <cstdio>
#include <cctype>
using std::min;
using std::max;
int read(){
    int x=0;char c;
    do{c=getchar();}while(!isdigit(c));
    do{x=x*10+c-'0';c=getchar();}while(isdigit(c));
    return x;
}
const int N=130000+10;
const int M=800+10;
const double eps=1e-7;
int n,m,bs,bcnt,bel[N];
int L[M],R[M],size[M];
double slope[N],seq[M][M];
void rebuild(int blk){
    size[blk]=0;
    for(int i=L[blk];i<=R[blk];i++){
        if(fabs(slope[i])<eps) continue;
        if(size[blk]==0||seq[blk][size[blk]]<slope[i])
            seq[blk][++size[blk]]=slope[i];
    }
}
inline void upd(int x,int y){ double k=1.0*y/x; slope[x]=k; rebuild(bel[x]); }
int solve(){
    double now=0;
    int ret=0;
    for(int i=1;i<=bcnt;i++){
        if(size[i]==0) continue;
        int l=1,r=size[i],mid=0,ans=0;
        while(l<=r){
            mid=(l+r)>>1;
            if(seq[i][mid]>now){
                ans=mid;
                r=mid-1;
            }else l=mid+1;
        }
        if(ans) ret+=max(0,(size[i]-ans+1));
        now=max(now,seq[i][size[i]]);
    }
    return ret;
}
int main(){
    n=read();m=read();
    bs=ceil(sqrt(n)); bcnt=n/bs+(n%bs>0);
    for(int i=1;i<=n;i++) bel[i]=(i-1)/bs+1;
    for(int i=1;i<=bcnt;i++){
        L[i]=(i-1)*bs+1;
        R[i]=i*bs;
    }R[bcnt]=n;

    int x,y;
    while(m--){
        x=read();y=read();
        upd(x,y);
        printf("%d\n",solve());
    }
    return 0;
}

```

---

## 作者：ylsoi (赞：2)

这好像也可以说是线段树维护区间最长连续上升的模板题。。。我们用斜率来表示高度，用一个线段树来维护某个区间内的高度最大值和最长连续上升。修改高度的时候只需要普通的线段树更新就好了，但是我们需要更新最长的长度，考虑一个区间[l,r],它的lc和rc的信息都是已知的，那么就是求rc这个区间内大于Max[lc]的连续上升的数的个数。
现在我们开始递归修改，记h为Max[lc]。
1、若右区间的左子区间最大值大于等于h,那么它的右子区间的个数就可以直接求出来，继续递归lc的左子区间即可。
2、若右区间的左子区间最大值小于h，那么他的左子区间的贡献必定为0，所以继续递归右子区间即可。
总的时间复杂度$O(n*\log^2n)$(比我的分块不知道快了多少。。。)

[代码在我的博客里](https://blog.csdn.net/ylsoi/article/details/80085896)

---

## 作者：山水一程_ (赞：1)

首先明确问题，对于每栋楼房的斜率K=H/X,问题就是问有多少个楼房的K比前面所有楼房的K都要大。

这题树套树当然可以，但是挺麻烦的，本渣觉得最简单就是分块……

将N个楼房分成T块，不断维护每个块内楼房的可视序列，如一个块内楼房的高度分别为(3 1 4 2 6 7)那么这个块内楼房的可视序列就是（3 4 6 7）（注意不同的块内是不干扰的，如第一个块可视序列为(3 4 6)，第二块的序列可以是(5 7 8)）

对于每个修改，我们只需对每个块内的楼房暴力维护可视序列就行了，O(N/T)

对于每个询问，我们只需一个块一个块看，不断维护到目前为止的可视序列中K的最大值kmax(不在可视序列内的楼房的K值一定不大)，那么对于查询每个块的时候，可以二分可视序列找到第一个大于kmax的位置，若没有则这个块的所有楼房都不可见，如果存在，那么这个位置后的此块中的可视序列楼房都能看见，那么就更新答案和kmax，不断往后做

注意：毕竟时间比较紧，所以常数还是尽可能写小点，二分和max函数还是自己写好些，不然会爆RP……
```cpp
#include<cstdio>
#include<cmath>
const int maxn=100005,sqrn=350;
int h[maxn],v[sqrn][sqrn],c[sqrn],l[sqrn],r[sqrn],bel[maxn],n,m,block,cnt,x,y,ch;
void read(int&x) {
	x=0,ch=getchar();
	while(ch>'9'||ch<'0')ch=getchar();
	while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
}
bool vis(int x,int y) {
	return (long long)h[x]*y<(long long)h[y]*x;
}
int bfind(int*a,int l,int r,int mx) {
	if(!mx)return l;
	if(!vis(mx,a[r]))return 0;
	int m=0,ans=0;
	while(l<=r) {
		m=(l+r)>>1;
		if(vis(mx,a[m]))ans=m,r=m-1;
		else l=m+1;
	}
	return ans;
}
void build(int x) {
	c[x]=0;
	int lst=0;
	for(register int i=l[x]; i<=r[x]; ++i)if(h[i])if(!lst||vis(lst,i))lst=v[x][++c[x]]=i;
}
int query() {
	int tot=0,mx=0,pos;
	for(register int i=1; i<=cnt; ++i)if(c[i]) {
			pos=bfind(v[i],1,c[i],mx);;
			if(pos)tot+=c[i]-pos+1,mx=v[i][c[i]];
		}
	return tot;
}
int main() {
	read(n),read(m);
	block=sqrt(n);
	cnt=n/block;
	if(n%block)++cnt;
	for(register int i=1; i<=n; ++i)bel[i]=(i-1)/block+1;
	for(register int i=1; i<=cnt; ++i)l[i]=(i-1)*block+1,r[i]=i*block;
	r[cnt]=n;
	for(register int i=1; i<=m; ++i) {
		read(x),read(y);
		h[x]=y;
		build(bel[x]);
		printf("%d\n",query());
	}
	return 0;
}


```


---

## 作者：LSTete (赞：1)

	对于这道题， 不难想到暴力直接是从位置 1 开始的上升序列的长度，考虑如何快速求解

	首先有一个Segment_Tree的写法， 维护 区间斜率最大值 和 区间能看到的楼房数。 若 MAX[lc] > MAX[rc] 则此右区间不产生贡献，否则更新右区间产生的贡献， 具体见代码。

	我们还可以想到暴力分块大法， 对于每个块状数组， 考虑维护区间内所有可以被看见的楼房， 不同于LIS的是， 我们的眼睛是不能选择性地透过一些我们不想看见的楼房的， 这点要注意， 但实际上使问题变简单了。
	对于每次操作， 我们可以把当前修改块的前一个块的最大值和ans记录下来， 向后迭代更新。
   都是大佬ylsoi教我的——————真的！

```cpp
#include<bits/stdc++.h>
#define mem(a, b) memset(a, b, sizeof(a))
#define For(i, j, k) for(register int i = (j); i <= (k); ++i)
#define Forr(i, j, k) for(register int i = (j); i >= (k); --i)
using namespace std;

template <typename T>
inline void read(T &x){
	T p = 1, c = getchar();
	x = 0;
	while(!isdigit(c)){
		if(c == '-') p = -1;
		c = getchar();
	}
	while(isdigit(c)){
		x = (x << 1) + (x << 3) + (c ^ 48);
		c = getchar();
	}
	x *= p;
}

template<typename T> inline bool chkmin(T &a, T b) { return a > b ? a = b, 1 : 0; }
template<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, 1 : 0; }

inline void File(){
#ifndef ONLINE_JUDGE
	freopen("楼房重建.in", "r", stdin);
	freopen("楼房重建.out", "w", stdout);
#endif
}

const int N = 1e5 + 10, M = 350;
int n, m, ans, Ans[M];
int belong[N], num[N], Num, Long;
double Highest, Max[M];

namespace Segment_Tree{
	#define mid (l + r >> 1)
	#define lc rt << 1
	#define rc rt << 1 | 1
	#define lson lc, l, mid
	#define rson rc, mid + 1, r
	#define lf double 

	lf MAX[N << 2]; int C[N << 2];

	void Build(int rt, int l, int r){
		if(l == r) return ;
		Build(lson), Build(rson);
	}
	
	int Count(int rt, int l, int r, lf V){
		if(l == r) return (MAX[rt] > V);
		if(MAX[lc] <= V) return Count(rson, V);
		return Count(lson, V) + C[rt] - C[lc] ;
	}

	void insert(int rt, int l, int r, int pos, lf H){
		if(l == r){
			MAX[rt] = H, C[rt] = 1;
			return ;
		}
		if(pos <= mid) insert(lson, pos, H);
		else insert(rson, pos, H);
		MAX[rt] = max(MAX[lc], MAX[rc]);
		C[rt] = C[lc] + Count(rson, MAX[lc]);
	}

}

inline void Segment_TREE(){
	read(n), read(m);
	Segment_Tree::Build(1, 1, n);
	while(m--){
		int x, y;
		read(x), read(y);
		Segment_Tree::insert(1, 1, n, x, 1.0 * y / x);
		printf("%d\n", Segment_Tree::C[1]);
	}

}

struct BLOCKS{
	int id[M], S[M], cnt, len;
	double beseen[M];
	
	inline void update(){
		double MAX = 0;
		cnt = 0;
		For(i, 1, len) if(chkmax(MAX, (1.0 * S[i]) / (1.0 * id[i]))) beseen[++cnt] = MAX;
	}
	
	double Query(int ID, double H){
		int pos = upper_bound(beseen + 1, beseen + 1 + cnt, H) - beseen;
		if(pos == cnt + 1) return Max[ID] = H;
		ans += cnt - pos + 1;
		return Max[ID] = beseen[cnt];
	}

}B[M];


inline void BLOCK(){
	read(n), read(m);
	Long = sqrt(n), Num = (n - 1) / Long + 1;
	For(i, 1, n){
		belong[i] = (i - 1) / Long + 1;
		num[i] = (i - 1) % Long + 1;
		B[belong[i]].id[++B[belong[i]].len] = i;	
	}
	
	while(m--){
		int x, y;
		read(x), read(y);
		B[belong[x]].S[num[x]] = y;
		B[belong[x]].update();
		
        Highest = Max[belong[x] - 1], ans = Ans[belong[x] - 1];
		For(i, belong[x], Num) Highest = B[i].Query(i, Highest), Ans[i] = ans;
		printf("%d\n", ans);
	}

}

int main(){
	File();
	Segment_TREE();
	BLOCK();
	return 0;
}
```

---


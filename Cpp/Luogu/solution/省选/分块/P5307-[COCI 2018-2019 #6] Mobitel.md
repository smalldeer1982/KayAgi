# [COCI 2018/2019 #6] Mobitel

## 题目背景

`Nikola`小朋友最近在学乘法口诀。  
为了记得更牢，他决定做一个游戏进行练习。  

## 题目描述

他画了一个 $r$ 行 $s$ 列的矩阵，每个格子里都有一个正整数。  
他想知道，如果从左上角走到右下角，且每次只能向右或向下走到相邻格子，那么使得路径上所有数的乘积不小于 $n$ 的路径有多少条？  

由于答案可能很大，所以请输出答案对 $10^9 + 7$ 取模的结果。

## 说明/提示

### 样例 $1$ 解释：  
共有 $3$ 条路径，其中有 $2$ 条满足条件：  
$2 \rightarrow 3 \rightarrow 6 \rightarrow 7$，乘积为$252$  
$2 \rightarrow 5 \rightarrow 6 \rightarrow 7$，乘积为$420$  

### 数据范围：  
对于$20\%$的数据：  
矩阵中的数不超过$10$  
对于$50\%$的数据：  
$1\le r,s \le 100$  
对于$100\%$的数据：  
$1\le r,s \le 300$  
$1\le n \le 10^6$  
矩阵中的数不超过$10^6$

## 样例 #1

### 输入

```
2 3 200
2 3 4
5 6 7```

### 输出

```
2```

## 样例 #2

### 输入

```
3 3 90
2 1 1
45 1 1
1 1 1```

### 输出

```
3```

# 题解

## 作者：Karry5307 (赞：27)

### 题意

有一个 $r\times c$ 的矩阵 $a$，矩阵的每个位置都有一个正整数，求从左上角走到右下角并且满足路径上数字乘积之和大于 $n$ 的方案数。

$\texttt{Data Range:}1\leq r,c\leq 300,1\leq n\leq 10^6$

### 题解

[不一定更好的阅读体验](https://www.cnblogs.com/Karry5307/p/13887837.html)

本人的本命题居然是个 DP + 整除分块呢。

~~草哦为什么这个题目名字叫手机啊我怎么看了半天没有看出与手机的任何关联呢~~

首先考虑一个非常 naive 的 DP，设 $f_{i,j,k}$ 表示在 $(i,j)$ 位置，已经走过的路径乘积之和为 $k$ 的方案数，那这个东西很明显由于复杂度上天显得非常不可做。

于是我们可以换个方向去思考这个问题，设 $f_{i,j,k}$ 表示在 $(i,j)$ 位置**还需要乘上 $k$，路径的乘积才能超过 $n$**，这样子的话转移其实也很好写，但是毕竟状态的数量还是太庞大了，复杂度依旧上天。

这个时候注意到 $k$ 这个维度上的取值很少，根据整除分块的理论只会有 $O(\sqrt{n})$ 种，所以可以考虑对所有真正有用的值来 DP，这个时候只需要预处理出每一个可能的取值对应哪个块即可做到 $O(rc\sqrt{n})$。

注意到这东西空间会超，所以考虑对 $i$ 这一位滚一下就好了。同时，代码细节贼多，稍不注意就会挂成狗。这个版本的代码跑的贼慢，看看到时候来卡卡常什么的。

### 代码

```cpp
#include<bits/stdc++.h>
#define dv(x,y) ((x)/(y)+!!((x)%(y)))
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=1e6+51,MOD=1e9+7;
ll r,c,n,blkc;
ll x[351][351],d[MAXN],rv[MAXN],f[2][351][2051],blk[2051];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
    	neg=-1;
    	ch=getchar();
	}
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
int main()
{
	r=read(),c=read(),n=read();
	for(register int i=1;i<=r;i++)
	{
		for(register int j=1;j<=c;j++)
		{
			x[i][j]=read();
		}
	}
	for(register int i=1;i<=n;i++)
	{
		(d[i]=dv(n,i))!=d[i-1]?blk[++blkc]=d[i],rv[d[i]]=blkc:1;
	}
	f[1][1][rv[dv(n,x[1][1])]]=1;
	for(register int i=1;i<=r;i++)
	{
		for(register int j=1;j<=c;j++)
		{
			for(register int k=1;k<=blkc;k++)
			{
				if(i!=r)
				{
					ll &s=f[(i&1)^1][j][rv[dv(blk[k],x[i+1][j])]];
					s=(s+f[i&1][j][k])%MOD;
				}
				if(j!=c)
				{
					ll &s=f[i&1][j+1][rv[dv(blk[k],x[i][j+1])]];
					s=(s+f[i&1][j][k])%MOD;
				}
				(i!=r||j!=c||k!=blkc)?f[i&1][j][k]=0:1;
			}
		}
	}
	printf("%d\n",f[r&1][c][blkc]);
}
```

---

## 作者：SHZhang (赞：20)

这道题看到是要对向右／向下的路径进行统计，自然能够想到动态规划。

所以，我们先尝试定义$ f[i][j][k] $为从$ (1, 1) $走到$ (i, j) $并且路径上的数字乘积恰好为$k$的路径数量。

特别的，为了防止$ k $的数值太大，还要加入一个特殊情况：当$k = n$时，$ f[i][j][n] $代表路径乘积**至少**为$n$的路径数量（而不是恰好为$n$）。

动态规划转移的方式是：最初$f[1][1][grid[1][1]]$为1，其中$grid$就是我们最初输入的矩阵。

然后，我们按照从上往下，从左往右的顺序，对每一个$(i, j, k)$做：

```cpp
f[i+1][j][max(k * grid[i+1][j], n)] += f[i][j][k]

f[i][j+1][max(k * grid[i][j+1], n)] += f[i][j][k]
```
最后的答案就是$f[r][s][n]$。实现时需要注意边界的特殊情况。

这样，我们已经得到了一个时间复杂度为$ O(nrs) $的做法，但是依然不能通过此题。

我们发现：$i$和$j$这两维必须保留。但是我们可以把$k$这一维改一下。

我们重新定义$f[i][j][k]$为从$ (1, 1) $走到$ (i, j) $并且路径上的数字乘积，还要**至少再乘$k$才能达到$n$这个值**。（请仔细阅读这个定义，它非常重要。）再把上面的状态转移简单修改一下即可。

如果直接做的话，复杂度依然是$O(nrs)$的。

但是我们发现：我们改变$f[i][j][k]$的定义后，有意义的$k$的值其实相对来说很少。这些值，就是$n$除以$1$至$n$（向上取整）可以得到的值。

比如，当$n = 1000$时：
| 路径上数的乘积 | 相对应的$k$的值 |
| -----------: | -----------: |
| 1 | 1000 |
| 2 | 500 |
| 3 | 334 |
| 4 | 250 |
| 5 | 200 |
| ... | ...|

所以，我们只需要对这些有意义的$k$的值进行计算即可。

这个算法的时间复杂度现在是$O(rs\sqrt{n})$，可以通过此题。注意此题需要使用滚动数组降低空间复杂度。

```cpp
// luogu-judger-enable-o2
#include <cstdio>

using namespace std;

#define MOD 1000000007

int f[2][305][2005];
int grid[305][305];
int divval[1000005];
int block[2005];
int rev[1000005];
  
//题目中的s在代码中用c表示

int r, c, n;

//ud(a, b)代表a除以b，向上取整的结果。
#define ud(a, b) ((a) % (b) == 0 ? (a) / (b) : (a) / (b) + 1)

int main()
{
    scanf("%d%d%d", &r, &c, &n);
    for (int i = 1; i <= r; i++) {
        for (int j = 1; j <= c; j++) {
            scanf("%d", &(grid[i][j]));
        }
    }
    for (int i = 1; i <= n; i++) {
        divval[i] = ud(n, i);
    }
    int next = 1;
    for (int i = 1; i <= n; i++) {
        if (divval[i] != divval[i-1]) {
            block[next++] = divval[i];
            rev[divval[i]] = next - 1;
        }
    }
    f[1][1][rev[ud(n, grid[1][1])]] = 1;
    for (int i = 1; i <= r; i++) {
        for (int j = 1; j <= c; j++) {
            for (int k = 1; k < next; k++) {
                if (i != r) {
                    int& down = f[(i&1)^1][j][rev[ud(block[k], grid[i+1][j])]];
                    down += f[i&1][j][k];
                    if (down >= MOD) down -= MOD;
                }
                if (j != c) {
                    int& right = f[i&1][j+1][rev[ud(block[k], grid[i][j+1])]];
                    right += f[i&1][j][k];
                    if (right >= MOD) right -= MOD;
                }
                if (i != r || j != c || k != next - 1) f[i&1][j][k] = 0;
            }
        }
    }
    printf("%d", f[r&1][c][next - 1]);
    return 0;
}



```



---

## 作者：ModestCoder_ (赞：6)

一个很普通的dp

$dp_{i,j,k}$表示第i行第j列乘积为k的路径条数

状态冗余太多，并且不优，需要优化一下


首先可以滚掉$i$这一维，接下来考虑把$k$这一维优化掉

一个定理$[\frac{[\frac{n}{x}]}{y}]=[\frac{n}{xy}]$

dp状态修改为$dp_{i,j,k}$表示第i行第j列，还需要乘上k才能>=n

这个k的值域是**n除以所有数上取整**

然后就可以愉快地dp了

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 310
#define maxm 2010
#define qy 1000000007
using namespace std;
int r, s, n, a[maxn][maxn], b[1000010], tot, val[maxm], pos[1000010], dp[2][maxn][maxm];

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

int calc(int x, int y){ return x % y == 0 ? x / y : x / y + 1; }
void upd(int &x, int y){ if ((x += y) >= qy) x -= qy; }

int main(){
	r = read(), s = read(), n = read();
	for (int i = 1; i <= r; ++i)
		for (int j = 1; j <= s; ++j) a[i][j] = read();
	for (int i = 1; i <= n; ++i) b[i] = calc(n, i);
	for (int i = 1; i <= n; ++i)
		if (b[i] != b[i - 1]) pos[val[++tot] = b[i]] = tot;
	dp[1][1][pos[calc(n, a[1][1])]] = 1; 
	for (int i = 1; i <= r; ++i){
		int now = i & 1, nxt = now ^ 1;
		for (int j = 1; j <= s; ++j)
			for (int k = 1; k <= tot; ++k){ //printf("%d\n", dp[now][j][k]);
				if (i != r) upd(dp[nxt][j][pos[calc(val[k], a[i + 1][j])]], dp[now][j][k]);
				if (j != s) upd(dp[now][j + 1][pos[calc(val[k], a[i][j + 1])]], dp[now][j][k]);
				if (i != r || j != s || k != tot) dp[now][j][k] = 0;
			}
	}
	printf("%d\n", dp[r & 1][s][tot]);
	return 0;
}
```


---

## 作者：BBD186587 (赞：2)

考虑一个暴力 dp，设 $f_{i,j,k}$ 表示当前在 $(i,j)$，乘积为 $k$ 的路径条数。

发现最后一维其实有很多没用的（根本乘不出来），所以考虑把 dp 状态换为 $f_{i,j,k}$ 表示当前在 $(i,j)$，再至少乘上 $k$ 乘积才能大于等于 $n$ 的路径条数。转移时，最后一维由原本的乘变为除即可（需要上取整）。

发现最后一维只能为 $\forall i \in [1,n],\lceil \dfrac{n}{i} \rceil$ 中不重复的数。与数论分块类似，这样的数是 $O(\sqrt{n})$ 级别的。

用 $O(\sqrt{n})$ 个数来映射这些数，再把第一维滚掉即可。复杂度 $O(rs\sqrt{n})$。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int p=1e9+7;
const int N=1e6+10;
const int M=310;
int n,m,K;
int a[M][M];
int f[2][M][2010];
int mp[N],cnt,id[N];
void upd(int &x,int y)
{
	x+=y,x%=p;
}
int LLL(int x,int y)//上取整除法
{
	if(x%y==0) return x/y;
	return x/y+1;
}
int main()
{
	scanf("%d%d%d",&n,&m,&K);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++) scanf("%d",&a[i][j]);
	for(int i=1;i<=K;i++)
		if(LLL(K,i)!=mp[cnt]) mp[++cnt]=LLL(K,i),id[LLL(K,i)]=cnt;
	f[1][1][id[LLL(K,a[1][1])]]=1;
	for(int i=1;i<=n;i++)
	{
		int t=(i%2);
		if(i!=1) for(int j=1;j<=m;j++)
			for(int k=0;k<=cnt;k++) f[t][j][k]=0;
		for(int j=1;j<=m;j++)
			for(int k=0;k<=cnt;k++)
			{
				upd(f[t][j][id[LLL(mp[k],a[i][j])]],f[t][j-1][k]);
				upd(f[t][j][id[LLL(mp[k],a[i][j])]],f[1-t][j][k]);
			}
	}
	printf("%d",f[n%2][m][cnt]);
	return 0;
}
```

---

## 作者：cyc001 (赞：1)

记录一个魔怔做法，与目前所有题解都不一样。

### 题意简述

给定 $n\times m$ 方格图，格子 $(i,j)$ 有权值 $a_{i,j}$，定义一条路径 $(x_1,y_1),(x_2,y_2) \dots (x_l,y_l)$ 的权值为 $\prod\limits_{i=1}^l a_{x_i,y_i}$。

现在你要从 $(1,1)$ 走到 $(n,m)$，只能往右或往下走，问你可以走出的所有权值 $\ge x$ 的路径条数。

$n,m \le 300$，$x \le 10^6$。

### 做法

首先肯定是转化到权值 $\le k-1$ 的路径数计数。

然后我们有朴素的 DP，状态定义 $f(i,j,k)$ 表示走到 $(i,j)$ 权值为 $k$ 的方案数，转移显然。

考虑优化这个做法。

设置阈值 $c=\lceil \sqrt x\rceil$，则每条权值 $\le x-1$ 路径一定可以拆成一条从起点到某个中间点 $u$ 的路径 $l_1$，$u$ 的后继 $v$，和 $v$ 的后继到终点的路径 $l_2$，且 $l_1$，$l_2$ 的权值均不大于 $c$，证明显然。

然后我们利用上面那个性质，考虑如何统计答案。

设 $f(i,j,k)$ 表示从 $(1,1)$ 走到 $(i,j)$，路径权值为 $k$ 的方案数，且 $k \le c$。

设 $g(i,j,k)$ 表示从 $(i,j)$ 走到 $(n,m)$，**路径权值小于等于 $a_{i,j}\cdot k$** 的方案数，且 $k \le c$。

$f,g$ 都可以通过 dp 求出。

我们假设 $a_{1,1} \le c$，另外一种情况的统计答案方法是简单的。

则权值 $\le k-1$ 的路径数 $h$ 如下：

$$
\sum\limits_{i=1}^{n-1}\sum\limits_{j=1}^m\sum\limits_{k=1}^c f(i,j,k)g(i+1,j,\lfloor \frac{x}{a_{i+1,j}\cdot k}\rfloor)[a_{i+1,j}\cdot k > c]\\+
\sum\limits_{i=1}^n\sum\limits_{j=1}^{m-1}\sum\limits_{k=1}^c f(i,j,k)g(i,j+1,\lfloor \frac{x}{a_{i,j+1}\cdot k}\rfloor)[a_{i,j+1}\cdot k > c]\\
+\sum\limits_{k=1}^c f(n,m,c)
$$

用人话说就是计数路径上的第一个点 $u$ 使得起点到 $u$ 这条路径的权值 $> c$，容易发现是不重不漏的。

则最终的答案是 $\binom{n+m-2}{n-1}-h$。

注意模数是 $10^9+7$ 而不是 $998244353$，不要虚空调试。

时间复杂度 $O(nm\sqrt x)$，空间复杂度 $O(nm \sqrt x)$，实现上要将 $f$ 滚掉以优化空间。

### Code:

```cpp
#include<bits/stdc++.h>
#define cir(i,a,b) for(int i=a;i<b;++i)
using namespace std;
using lint=long long;
static constexpr auto MOD=(int)(1e9+7);
class mathbase{
private:
    vector<lint> fct,ifct;
public:
    constexpr auto qpow(lint a,auto b){
        auto res=1ll;
        while(b){
            if(b&1) (res*=a)%=MOD;
            (a*=a)%=MOD;b>>=1;
        }
        return res;
    }
    constexpr auto inv(auto x){return qpow(x,MOD-2);}
    auto init(const auto n){
        fct.resize(n,1);
        cir(i,1,n) fct[i]=fct[i-1]*i%MOD;
        ifct=fct;
        for(auto&i:ifct) i=inv(i);
    }
    auto C(auto a,auto b){
        if(a<b||b<0) return 0ll;
        return fct[a]*ifct[b]%MOD*ifct[a-b]%MOD;
    }
} math;
int main(){
    ios::sync_with_stdio(false),cin.tie(nullptr);
    int n,m,k;cin>>n>>m>>k;--k;math.init(n+m+7);
    vector w(n,vector<lint>(m));
    for(auto&x:w) for(auto&i:x) cin>>i;
    const auto sqr=(int)(ceil(sqrtl(k)))+7;
    vector f(2,vector(m,vector<int>(sqr))),g(n,vector(m,vector<int>(sqr)));
    g[n-1][m-1][1]=1;
    for(auto i=n-1;~i;--i) for(auto j=m-1;~j;--j) cir(wx,0,sqr) if(wx*w[i][j]<sqr){
        if(i) (g[i-1][j][wx*w[i][j]]+=g[i][j][wx])%=MOD;
        if(j) (g[i][j-1][wx*w[i][j]]+=g[i][j][wx])%=MOD;
    }
    cir(i,0,n) cir(j,0,m) cir(wx,1,sqr) (g[i][j][wx]+=g[i][j][wx-1])%=MOD;
    auto ans=0ll;
    auto cur=1;
    if(w[0][0]<sqr) f[cur^1][0][w[0][0]]=1;
    cir(i,0,n){
        cur^=1;
        f[cur^1]=vector(m,vector<int>(sqr));
        cir(j,0,m) cir(wx,0,sqr){
            if(i+1<n&&wx*w[i+1][j]<sqr) (f[cur^1][j][wx*w[i+1][j]]+=f[cur][j][wx])%=MOD;
            if(j+1<m&&wx*w[i][j+1]<sqr) (f[cur][j+1][wx*w[i][j+1]]+=f[cur][j][wx])%=MOD;
            if(i+1<n&&wx*w[i+1][j]>sqr-1) (ans+=(lint)(f[cur][j][wx])*(g[i+1][j][k/(wx*w[i+1][j])]))%=MOD;
            if(j+1<m&&wx*w[i][j+1]>sqr-1) (ans+=(lint)(f[cur][j][wx])*(g[i][j+1][k/(wx*w[i][j+1])]))%=MOD;
        }
    }
    cir(wx,0,sqr) (ans+=f[cur][m-1][wx])%=MOD;
    if(w[0][0]>sqr-1) (ans+=g[0][0][k/w[0][0]])%=MOD;
    cout<<(math.C(n+m-2,n-1)+MOD-ans)%MOD<<'\n';
    return 0;
}
```

---

## 作者：sidekick257 (赞：1)

> 本来搓了个同 ```trick``` 的题的，没想到这个 ```trick``` 已经有原了，流泪了。

设当前权值为 $v$，那么显然有 $dp_{i,j,v}$ 表示现在在格子 $(i,j)$ 权值为 $v$，转移显然。

考虑记 $t=\lfloor \frac{n-1}{v} \rfloor$，把第三维换成 $t$，$t=0$ 就是合法路径，不难注意到 $t$ 的数量级是 $O(\sqrt{n})$ 的，于是做完了。

正确性来自 $\lfloor \frac{\lfloor \frac{x}{a} \rfloor}{b} \rfloor=\lfloor \frac{x}{ab} \rfloor$，证明是容易的，考虑前者只有当 $x$ 每增加 $ab$ 才会加一，和后者定义相同。

---

## 作者：TernaryTree (赞：1)

设计一个 dp：$f_{i,j,k}$ 表示当前位置在 $(i,j)$，还至少需要乘上 $k$ 可以 $\ge n$。这个时候是好转移的，而且 $k$ 的取值只有 $\sqrt n$ 种，于是 $rc\sqrt n$ 就对了。

接下来给出复杂度的证明：

我们只需要证明 $k$ 只有 $\sqrt n$ 种取值。

观察转移方程：

$$
\begin{aligned}
f_{i+1.j,\lceil\frac{k}{a_{i+1,j}}\rceil}&\gets f_{i+1.j,\lceil\frac{k}{a_{i+1,j}}\rceil}+f_{i,j,k}\\
f_{i+1.j,\lceil\frac{k}{a_{i,j+1}}\rceil}&\gets f_{i.j+1,\lceil\frac{k}{a_{i,j+1}}\rceil}+f_{i,j,k}
\end{aligned}
$$

我们定义不可重集合 $S=\{\left\lceil\dfrac{n}{i}\right\rceil \mid i\in\mathbb{N}^+\}$，假设对于某一处转移，有 $k\in S$。则结论是，被转移到的第三维 $\lceil\frac{k}{a_{i+1,j}}\rceil$ 同样属于 $S$。

这是一个经典结论：$\left[\dfrac a{bc}\right]=\left[\dfrac{\left[\frac ab\right]}{c}\right]$，其中 $a,b,c$ 为正整数，$[]$ 表示上取整和下取整中的一种。此处对上取整进行证明（贺自我的 [瞎证一个以前忘了证的东西](https://www.luogu.com.cn/blog/ternarytree/xia-zheng-yi-ge-yi-qian-wang-liao-zheng-di-dong-xi)）：

设 $p=\dfrac ab$，则问题转化为 $\left\lceil\dfrac p{c}\right\rceil=\left \lceil\dfrac{\left \lceil p\right\rceil}{c}\right\rceil$。不妨反证。若 $\left\lceil\dfrac p{c}\right\rceil\neq \left \lceil\dfrac{\left \lceil p\right\rceil}{c}\right\rceil$，由于 $p\le \left\lceil p\right\rceil$，则必然存在整数 $n$ 满足 $\dfrac pc\le n\lt \dfrac{\lceil p\rceil}c$，即 $p\le cn\lt \lceil p\rceil$。又 $cn$ 是整数，而显然 $[p,\lceil p\rceil)$ 之间不存在整数，故原命题得证。

综上，每次转移的 $k$ 一定都在 $S$ 中。而 $S$ 的大小为 $\Theta(\sqrt n)$，证明：当 $1\le i\le\sqrt n$ 时，显然 $i$ 仅有 $\sqrt n$ 种取值；当 $\sqrt n\lt i$ 时，有 $\dfrac ni\lt \sqrt n$，同样只有 $\sqrt n$ 种取值，证毕。

此题还有一个神秘之处在于使用 umap 会 TLE 后两个点，pbds 的 gp_hash_table 会 TLE 后三个点，而以效率不如 gp_hash_table 而广为人知的 cc_hash_table 却通过了此题。

```cpp
#include <bits/stdc++.h>
#include <bits/extc++.h>
#define int long long

using namespace std;
using namespace __gnu_pbds;

const int maxn = 3e2 + 10;
const int maxs = 2e3 + 10;
const int mod = 1e9 + 7;

int n, m, k;
int a[maxn][maxn];
int f[maxn][maxs];
int g[maxn][maxs];
int up[maxs], cnt;
cc_hash_table<int, int> bk;

signed main() {
	cin >> n >> m >> k;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> a[i][j];
		}
	}
	int l = 1;
	while (l <= k) {
		int m = (k + l - 1) / l;
		int r = m == 1 ? k : (k - 1) / (m - 1);
		up[++cnt] = m;
		bk[m] = cnt;
		l = r + 1;
	}
	g[1][bk[(k + a[1][1] - 1) / a[1][1]]] = 1;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			for (int k = 1; k <= cnt; k++) {
				f[j][k] = g[j][k];
				g[j][k] = 0;
			}
		}
		for (int j = 1; j <= m; j++) {
			for (int k = 1; k <= cnt; k++) {
				if (i != n) (g[j][bk[(up[k] + a[i + 1][j] - 1) / a[i + 1][j]]] += f[j][k]) %= mod;
				if (j != m) (f[j + 1][bk[(up[k] + a[i][j + 1] - 1) / a[i][j + 1]]] += f[j][k]) %= mod;
			}
		}
	}
	cout << f[m][bk[1]] << endl;
	return 0;
}

```

---

## 作者：o51gHaboTei1 (赞：1)

**P5307 sol**

考虑一个最暴力的 dp，设 $dp_{i,j,k}$ 表示走到 $(i,j)$ 乘积为 $k$ 的路径数，直接枚举三个维度并对第三维控制大小，向后面转移即可。

观察到无法通过此题，并且不太可能存在更优的本质不同途径计数。尝试优化本身的 dp 状态。

设 $dp_{i,j,k}$ 表示还要乘上 $k$ 才能转移的路径总数，显然 $k$  形如 $\lceil \frac{n}{i} \rceil$ 这种形式，数量级为 $\sqrt n$，预处理出来离散化后再转移即可。

时间复杂度 $O(rs\sqrt n)$。

```cpp
#include "bits/stdc++.h"
using namespace std;
const int Len = 3e2 + 5 , mod = 1e9 + 7 , M = 1e6 + 5;
int ans,n,m,dp[2][Len][2005],rec[M],k,v[Len][Len],ct,cer[M];
inline int flr(int N,int x)
{
	if(N % x == 0) return N / x;
	return N / x + 1;
}
inline void Mod(int &x){if(x >= mod) x -= mod;}
int main()
{
	scanf("%d %d %d",&n,&m,&k);
	for(int i = 1 ; i <= n ; i ++)
		for(int j = 1 ; j <= m ; j ++) scanf("%d",&v[i][j]);
	for(int i = 1 ; i <= k ; i ++) 
	{
		if(rec[flr(k , i)]) continue;
		rec[flr(k , i)] = ++ ct;
		cer[ct] = flr(k , i);
	}
	dp[1][1][rec[flr(k , v[1][1])]] = 1;
	for(int i = 1 ; i <= n ; i ++)
	{
		for(int j = 1 ; j <= m ; j ++)
			for(int p = 1 ; p <= ct ; p ++) dp[(i + 1) & 1][j][p] = 0;
		for(int j = 1 ; j <= m ; j ++)
		{
			int dx = i + 1 , dy = j;
			if(dx > n || dy > m);
			else for(int p = 1 ; p <= ct ; p ++) Mod(dp[dx & 1][dy][rec[flr(cer[p] , v[dx][dy])]] += dp[i & 1][j][p]);
			dx = i , dy = j + 1;
			if(dx > n || dy > m);
			else for(int p = 1 ; p <= ct ; p ++) Mod(dp[dx & 1][dy][rec[flr(cer[p] , v[dx][dy])]] += dp[i & 1][j][p]);
		}
	}
	printf("%d\n",dp[n & 1][m][rec[1]]);
	return 0;
}
```

---

## 作者：_Diu_ (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P5307)

## 整除分块 + dp

因为有无后效性，

所以我们一看就可以想到二维 dp。

- 设 $f_{i,j,k}$ 表示走到点 $(i,j)$ 后乘积为 $k$ 的路径数。

然后我们就可以很容易的打出一个 $O(rsn)$ 的做法。

显然会炸，冗余状态过多。

这个时候我们发现：

假设 $n=7$，那么 $k=4,5,6$ 其实是等价的。

因为这些数本身不满足条件，只要乘以一个 $2$ 就可以满足条件。

这个时候我们就可以优化了：

- 设 $f_{i,j,k}$ 表示走到点 $(i,j)$ 后，**还需要再至少乘以** $k$ 才能不小于 $n$ 的路径数。

但是，我们发现一个很严重的问题：

状态数还是没有减少！！！

因此，我们想到**整除分块**常见结论：对于正整数 $n$，$\lfloor\frac ni\rfloor$ 的不同值个数是 $O(\sqrt n)$ 的。

那我们是不是可以类比：$\lceil\frac ni\rceil$ 的不同值个数也是 $O(\sqrt n)$ 的。

这个是可以证明的，这里不细讲。

那么，我们先预处理出这根号个值，这样 $k$ 的状态数就压到了根号。

于是，总时间复杂度就压到了 $O(rs\sqrt n)$，可过此题。

注：本题空间好像会炸，所以建议压一下维

## code

```cpp
#include<bits/stdc++.h>
#define int long long
#define dv(x,y) (((x)+(y)-1)/(y))//向上取整
using namespace std;
const int N=310,M=2010,p=1e9+7;
int r,c,n,a[N][N],f[2][N][M],bl[M],rv[M*M],tot;
#define add(x,y) (x=((x)+(y))%p)
signed main(){
	scanf("%lld%lld%lld",&r,&c,&n);
	for(int i=1;i<=r;i++){
		for(int j=1;j<=c;j++)scanf("%lld",&a[i][j]);
	}
	for(int i=1;i<=n;i++){
		if(dv(n,i)!=(i==1?0:dv(n,i-1)))bl[rv[dv(n,i)]=++tot]=dv(n,i);
	}
	f[1][1][rv[dv(n,a[1][1])]]=1;
	for(int i=1;i<=r;i++){
		for(int j=1;j<=c;j++){
			for(int k=1;k<=tot;k++){//从fi,j向fi+1,j和fi,j+1转移 
				if(i^r)add(f[i+1&1][j][rv[dv(bl[k],a[i+1][j])]],f[i&1][j][k]);
				if(j^c)add(f[i&1][j+1][rv[dv(bl[k],a[i][j+1])]],f[i&1][j][k]);
				if(i!=r||j!=c||k!=tot)f[i&1][j][k]=0;
			}
		}
	}
	printf("%lld\n",f[r&1][c][tot]);
}
```

---

## 作者：DerrickLo (赞：0)

考虑暴力是 $f_{i,j,k}$ 表示走到了 $(i,j)$，乘积是 $k$ 的方案数，转移比较简单，这样显然无法通过。考虑改为 $f_{i,j,k}$ 表示走到了 $(i,j)$，乘积再乘 $k$ 才能 $\ge n$ 的方案数，转移跟前面类似，但是我们发现这个 $k$ 一定可以表示成 $\lceil\dfrac{n}{i}\rceil$，由于整除分块，这个的取值只有 $\mathcal O(\sqrt n)$ 个，所以将第三维离散化，第一维滚动数组即可，时间复杂度 $\mathcal O(rc\sqrt n)$。

```cpp
#include<bits/stdc++.h>
#define mod 1000000007
using namespace std;
int r,s,n,a[305][305],f[2][305][2005],b[1000005],m,fr[1000005],d;
int ceil(int a,int b){return(a%b==0)?a/b:a/b+1;}
void add(int&a,int b){a+=b;if(a>=mod)a-=mod;}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>r>>s>>n;
	for(int i=1;i<=r;i++)for(int j=1;j<=s;j++)cin>>a[i][j];
	for(int i=1;i<=n;i++)b[++m]=ceil(n,i);
	sort(b+1,b+m+1),m=unique(b+1,b+m+1)-b-1;
	for(int i=1;i<=m;i++)fr[b[i]]=i;
	f[d=1][1][fr[ceil(n,a[1][1])]]=1;
	for(int i=1;i<=r;i++){ 
		for(int j=1;j<=s;j++)for(int k=1;k<=m;k++){
			if(i<r)add(f[d^1][j][fr[ceil(b[k],a[i+1][j])]],f[d][j][k]);
			if(j<s)add(f[d][j+1][fr[ceil(b[k],a[i][j+1])]],f[d][j][k]);
			if(i<r)f[d][j][k]=0;
		}
		d^=1;
	}
	cout<<f[d^1][s][fr[1]];
	return 0;
}
```

---

## 作者：dyc2022 (赞：0)

十分有意思的一道题。

首先，我们考虑进行 dp 计数。不难想到一个粗暴的状态设置：令 $dp_{i,j,k}$ 表示从 $(1,1)$ 走到 $(i,j)$，且走过的路径乘积为 $k$ 的方案数。设 $r,s$ 同阶，则状态数和转移数为 $O(r^2n)$ 的，不能通过。

但是，我们关注到乘积的性质——其实能取到的乘积数量并不多。我们关注到 $\lceil\frac{n}{i} \rceil$ 的取值最多只有 $O(\sqrt{n})$ 种取值的性质，所以我们可以改进状态：$dp_{i,j,k}$ 表示 $(1,1)$ 到 $(i,j)$ 的乘积再乘上 $k$ 才能 $\ge n$ 的方案数。

那么到这里做法已经一目了然了。显然 $k$ 只有 $\sqrt {n}$ 级别，每次转移可以从左边来也可以从上面来，枚举当前所在行、列和 $k$。具体实现时，可以使用整除分块，使用 $O(\sqrt{n})$ 的复杂度快速求出 $\lceil\frac{n}{i} \rceil$ 的所有可能取值，然后将其离散化作为状态。注意要使用滚动数组把第一维缩掉。然后这题就做完了，复杂度 $O(rs\sqrt{n})$，可以通过。

代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
#define N 306
#define M 2006
#define MOD 1000000007
using namespace std;
int n,m,k,a[N][N],b[M],id[M*M],bn,dp[2][N][M];
int divide(int x,int y){return x%y?x/y+1:x/y;}
void add(int &x,int y){x+=y,x-=x>=MOD?MOD:0;}
main()
{
	scanf("%lld%lld%lld",&n,&m,&k);
	for(int l=1,r,div;l<=k;l=r+1)
		div=(k+l-1)/l,r=(div==1?k:(k-1)/(div-1)),b[++bn]=div,id[div]=bn;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)scanf("%lld",&a[i][j]);
	dp[1][1][id[divide(k,a[1][1])]]=1;
	for(int i=1,cur=1,pre=0;i<=n;i++,pre=cur,cur^=1)
	{
		if(i!=1)memset(dp[cur],0,sizeof(dp[cur]));
		for(int j=1;j<=m;j++)
			for(int h=0;h<=bn;h++)
			{
				int pos=id[divide(b[h],a[i][j])];
				add(dp[cur][j][pos],dp[cur][j-1][h]);
				add(dp[cur][j][pos],dp[pre][j][h]);
			}
	}
	printf("%lld\n",dp[n&1][m][bn]);
	return 0;
}
```

---

## 作者：一E孤行 (赞：0)

蒟蒻这道题学了三天才学懂，这里来分享一下学习经验qwq

~~先感谢某位金钩爷的全程帮助~~

### 切入正题

从矩阵的左上角走到右下角，满足一定条件，方案数有多少种，很明显的计数类dp，我们先进行设计状态。

#### 初始想法

我们设 `f[i][j][k]` 表示我们的位置处在 $(i,j)$ 时，获得的乘积为 $k$ 的方案数有多少种。

我们考虑复杂度问题，首先， $k$ 的值域在 $10^6$ 上，$i$ 和 $j$ 都在 $10^3$ 上，很显然数组开不下，时间也过不去，考虑优化。

### 优化1

题目中说道：只能向右方和下方走，那么答案肯定由上一行或者左边转移来，因此， $i$ 那一位，完全可以滚掉，只用根据奇偶性保存 $2$ 行的答案。

但是我们仍旧发现， $k$ 的值域在 $10^6$ 上，仍然会令空间和时间超限，必须对 $k$ 这一维进行优化。

### 优化2

我们改变一下状态，调整为：在位置 $(i,j)$ 的时候，还需要再乘上 $k$ ，才能满足路径乘积大于等于 $n$ 这样的条件的方案数。那么显然，这里的 $k$ 的值实际上是 $n$ 除以 $sum$ 再向上取整， $sum$ 为现在的累计值。那么这样的 $k$ 有多少个呢？

根据数论分块理论， $\lceil \frac{n}{i} \rceil$ 和 $\lfloor \frac{n}{i} \rfloor$ 的个数值域在 $\sqrt{n}$ 上。

+ 简易证明：我们从 $\frac{n}{1}$ 一直算到 $\frac{n}{ \lceil \sqrt{n} \rceil}$ ，最多有 $\sqrt{n}$ 种，每种在大于 $\sqrt{n} $ 的部分也对应一个，所以值域在 $\sqrt{n}$ 上。

+ 对于这道题的具体实现：

我们可以预处理出所有的 $\lceil \frac{n}{i}\rceil (i\in[1,n])$ 的值，将他们离散化，这样最多有 $2\times \sqrt{n}$ 个数。转移的时候，遍历每个 $k$ ，我们从上一个位置，将积乘上一个 $a_{i,j}$ ，相当于把状态里的 $k$ 变成 $\lceil \frac{k}{a_{i,j}}\rceil$ （还需要乘 $k$ 才能大于等于 $n$，转移后，乘上了一个 $a_{i,j}$ ，就除回去就行了）。

### Code

+ 在蒟蒻的代码中，题面中的 $n$ 是 `K`，`f` 数组是保存状态的， `where` 是离散化后的值，`mp` 是离散化回去的映射数组。

+ 输出答案的时候，肯定是在右下角的位置，还需要乘 $1$ 就可以满足条件啦。

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<iostream>
#include<cstring>
#include<ctime>
#include<cmath>
using namespace std;
inline int calc(int x,int y) {
    if(x%y==0) return x/y;
    return x/y+1;
}
int n,m,N;
#define maxn 305
int cnt,mp[3000];
const int p=1e9+7;
int f[2][maxn][3000],a[maxn][maxn],where[1000005];
void getans(int &x,int y) {
    x+=y;
    x%=p;
}
int main() {
    int c1=clock();
#ifdef LOCAL
    freopen("in.in","r",stdin);
    freopen("out.out","w",stdout);
#endif
    //=========================================
     scanf("%d%d%d",&n,&m,&N);
     for(int i=1;i<=n;i++) {
         for(int j=1;j<=m;j++) {
             scanf("%d",&a[i][j]);
         }
     }
     for(int i=1;i<=N;i++) {
         if(calc(N,i)!=mp[cnt]) {
             mp[++cnt]=calc(N,i);
             where[calc(N,i)]=cnt;
         }
     }
     f[1][1][where[calc(N,a[1][1])]]=1;
     for(int i=1;i<=n;i++) {
         int hang=i&1;
         if(i!=1) for(int j=1;j<=m;j++) {
             for(int N=0;N<=cnt;N++) f[hang][j][N]=0;
         }
         for(int j=1;j<=m;j++) {
             for(int N=0;N<=cnt;N++) {
                 getans(f[hang][j][where[calc(mp[N],a[i][j])]],f[hang][j-1][N]);
                 getans(f[hang][j][where[calc(mp[N],a[i][j])]],f[hang^1][j][N]);
             }
         }
     }
     printf("%d\n",f[n&1][m][where[1]]);
    //=========================================
    cerr<<"Tmie Used:"<<clock()-c1<<"ms"<<endl;
    return 0;
}
```

---


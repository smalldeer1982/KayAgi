# [COCI 2006/2007 #4]  ISPITI

## 题目背景

Mirko 的村子要进行一场考试。

## 题目描述

考试在即，学生们赶快加紧了复习的进度。每个学生都有两个能力系数 $A\ B$。

我们认为一个学生会向另一个学生求助，当且仅当另一个学生的 $A$ 和 $B$ 都不小于这个学生。

现在给出 $n$ 条指令，有以下两种类型：

- `D A B` 来了一个学生，他的两个能力系数为 $A$ 和 $B$。

- `P i` 第 $i$ 个学生想知道找谁帮忙。为了不大材小用，如果有多人可以求助，他会首先选择系数 $B$ 相差最小的。如果 $B$ 相同，则首选 $A$ 相差最小的。

其中学生的编号由入场的顺序从 $1$ 开始依次编排。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le n\le 2\times 10^5$，$1\le A,B\le 2\times 10^9$。

#### 说明

**题目译自 [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [CONTEST #4](https://hsin.hr/coci/archive/2006_2007/contest4_tasks.pdf) *T6  ISPITI***

## 样例 #1

### 输入

```
6
D 3 1
D 2 2
D 1 3
P 1
P 2
P 3```

### 输出

```
NE
NE
NE```

## 样例 #2

### 输入

```
6
D 8 8
D 2 4
D 5 6
P 2
D 6 2
P 4```

### 输出

```
3
1```

## 样例 #3

### 输入

```
7
D 5 2
D 5 3
P 1
D 7 1
D 8 7
P 3
P 2```

### 输出

```
2
4
4```

# 题解

## 作者：lzqy_ (赞：11)

提供一种 $O(n^2)$ 的纯分块做法。~~暴力碾标算~~

## 思路

要维护一些奇怪的东西，首先想到分块。

先看操作一。插入操作对于分块来说是比较复杂的，考虑到最多插入 $n$ 个二元组，所以提前处理出长度为 $n$ 的分块，每个二元组都是 $(0,0)$，这样，就把插入变成了单点修改。

再看操作二。如果要求的东西和数值的大小关系有关时，一种很套路的做法就是将每个块进行排序，即按 $B$ 作为第一关键字、$A$ 作为第二关键字排序。

然后就可以具体对每个操作来处理了。

操作一：

设修改的是第 $x$ 个二元组，那么暴力扫描 $x$ 所在的块，找到 $x$ 进行修改，然后再对整个块重新排序。时间复杂度 $O(\sqrt n\,log\sqrt n)$。

操作二：

设询问的是第 $x$ 个二元组 $(A,B)$，那么对于每一个块，先二分出第一个 $B'$ 大于等于 $B$ 的元素的位置（首先满足第一关键字），然后在块的剩下部分暴力搜索找到第一个 $A'$ 大于等于 $A$ 的元素，那么这个元素便是当前块的答案。对每个块执行这个操作，总的极限时间复杂度 $O(n)$。

这样我们就拥有了一个常数极小的 $O(n^2)$ 算法。但是我们需要剪枝。

- 对于每一个块，如果其最左边元素的 $B$ 值（即最大的 $B$）小于要比较的 $B$ 值，那么直接跳过整个块。

- 可以发现，这个算法的瓶颈在于二分完遍历块的时间。所以可以适当缩短块长，牺牲二分的时间来减短遍历块的时间（使二分可以过滤掉更多没必要遍历的部分）。块长取 $222$ 时速度最快（比正常块长短一半）。

- 在遍历块找答案时，目前 $B$ 值必须小于已找出答案的 $B$ 值，否则这个块的剩余部分不会存在最终答案。

- ~~以及一些普遍的卡常小技巧。~~

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=200010;
inline int read()
{
	register int x=0;
	register char c=getchar();
	for(;!(c>='0'&&c<='9');c=getchar());
	for(;c>='0'&&c<='9';c=getchar())
		x=(x<<1)+(x<<3)+c-'0';
	return x;
}
struct node
{
	int A,B,id;
}a[maxn];
bool operator <(node a,node b)
{
	if(a.B==b.B) return a.A<b.A;
	return a.B<b.B;
}
int Y[maxn],L[maxn],R[maxn];
int n,m,qn;
void change(int x,int A,int B)
{
	register int k=Y[x];
	for(register int i=L[k];i<=R[k];i++)
		if(a[i].id==x)
		{
			a[i].A=A,a[i].B=B;
			break;//找到就跳出
		}
	sort(a+L[k],a+1+R[k]);//对块内元素进行排序
}
pair<int,int> getsum(int x)
{
	register int k=Y[x];
	for(register int i=L[k];i<=R[k];i++)
		if(a[i].id==x)
			return make_pair(a[i].A,a[i].B);
}
int getnum(int A,int B,int x)
{
	pair<int,int>Min;
	Min.first=INT_MAX,Min.second=INT_MAX;
	register int l,r,h=-1,mid,ll,rr,lll,rrr;
	for(register int i=1;i<=Y[n];i++)
	{
		if(a[R[i]].B<B) continue;//当前块没有答案,跳过
		l=L[i],r=R[i];
		while(r>l)
		{
			mid=l+r>>1;
			if(a[mid].B<B) l=mid+1;
			else r=mid;
		}
		for(register int j=l;j<=R[i]&&a[j].B<=Min.first;j++)
			if(a[j].A>=A&&a[j].id!=x)
				if(make_pair(a[j].B,a[j].A)<Min)
				{
					Min=make_pair(a[j].B,a[j].A),h=a[j].id;
					break;//取到当前块的答案就跳出
				}
					
	}
	return h;
}
int main()
{
	n=m=read(),qn=222;//手动定义块长
	for(register int i=1;i<=n;i++)
		Y[i]=(i-1)/qn+1,a[i].id=i;
	for(register int i=1;i<=Y[n];i++)
		L[i]=(i-1)*qn+1,R[i]=min(i*qn,n);
	register int x,y,ii=0;
	pair<int,int>t;
	register char c; 
	while(m--)
	{
		getchar(),c=getchar();//用getchar节省时间
		if(c=='D')
			x=read(),y=read(),change(++ii,x,y);
			//ii为下一个插入的元素的编号
		else
		{
			x=read(),t=getsum(x),y=getnum(t.first,t.second,x);
			if(y==-1) puts("NE");
			else printf("%d\n",y);
		}
			
	}
	return 0;
}

```

算是一种思维简单的方法吧，祝AC！

---

## 作者：一扶苏一 (赞：3)

## 【分块】【P6325】 [COCI2006-2007#4]  ISPITI

### Description

给定 $n$ 次操作，每次要么在二维平面内插入一个点 $(x, y)$，要么给定某个已插入点，查询横纵坐标都不小于已插入点的点中（不包括查询点自身），纵坐标最小的点，若有多个点满足条件，输出横坐标最小的。

$1 \leq n \leq 2 \times 10^5$，不存在两个点的坐标完全相同。

### Analysis

首先点的坐标可以离散化，以下认为坐标与 $n$ 同阶。

最直接的想法是，可以用树套树维护所有的插入的点，查询时，相当于查询给定点右上角的矩形中最靠下的点。考虑如果确定了答案的纵坐标，在插入点的时候将点纵坐标相同的点插入同一个 `set` 中，就可以直接 `lower_bound` 找到结果了。问题转化为求最小的合法纵坐标。这个问题可以在外层线段树上二分解决，相当于一边二分一边进行二维数点，确定纵坐标最小的点数大于 $1$ 的矩形上界。时间复杂度 $O(n \log^2 n)$。

树套树太屑了，考虑分块来确定最小纵坐标。

首先如果存在点与给定点纵坐标相同且横坐标大于给定点的情况，在该行的 `set` 内 `upper_bound` 一下即可，下面考虑不存在这种点的情况。

考虑对纵坐标（行）分块，设查询的给定点是 $(x, y)$，查询时首先暴力遍历 $y$ 所在块内的所有纵坐标大于 $y$ 的行，如果有一行存在横坐标不小于 $x$ 的点，那么最小纵坐标即为该行。否则从小到大遍历纵坐标大于 $y$ 的所有块，找到第一个存在横坐标不小于 $x$ 的点的块，然后暴力遍历这个块即可。

考虑如何确定一行内是否存在横坐标不小于 $x$ 的点：对每一行维护该行内的点的最大横坐标即可。对于一次查询，如果 $x$ 不大于该行内的最大横坐标，则一定存在满足要求的点，否则不存在。

考虑如何确定块内存在横坐标不小于 $x$ 的点：插入一个点时，维护该点所在行的块内最大的横坐标即可。

找到纵坐标后，`lower_bound` 即可解决问题。

考虑时间复杂度：不考虑 `set` 的复杂度，插入时维护的信息都是 $O(1)$ 的，而查询时遍历每块的总复杂度是 $O(\sqrt n)$ 的，块内暴力每次是 $O(1)$ 的，因此暴力部分也是 $O(\sqrt n)$ 的，因此分块部分的复杂度是 $O(n \sqrt n)$。而 `set` 所有操作的复杂度和是 $O(n \log n)$ 的，因此总复杂度 $O(n \sqrt n)$。

空间复杂度显然是 $O(n)$ 的。

std 好像是一个 $\log$ 的线段树（

### Code

```cpp
const int maxn = 200005;
const int maxt = 450;

void Init();
void Divide();
void Solve();

int main() {
  freopen("1.in", "r", stdin);
  Init();
  Divide();
  Solve();
  return 0;
}

int n;

struct OP {
  int opt, x, y;
};
OP op[maxn];

void Init() {
  qr(n);
  int cnt = 0;
  static int tx[maxn], ty[maxn];
  for (int i = 1, x, y; i <= n; ++i) {
    char ch = IPT::GetChar();
    while (!isalpha(ch)) ch = IPT::GetChar();
    if (ch == 'D') {
      qr(x); qr(y);
      tx[++cnt] = x; ty[cnt] = y;
      op[i] = {1, x, y};
    } else {
      qr(x);
      op[i] = {2, x, 0};
    }
  }
  std::sort(tx + 1, tx + 1 + cnt);
  std::sort(ty + 1, ty + 1 + cnt);
  auto ex = std::unique(tx + 1, tx + 1 + cnt), ey = std::unique(ty + 1, ty + 1 + cnt);
  for (int i = 1; i <= n; ++i) if (op[i].opt == 1) {
    op[i].x = std::lower_bound(tx + 1, ex, op[i].x) - tx;
    op[i].y = std::lower_bound(ty + 1, ey, op[i].y) - ty;
  }
}

int sn;
int bl[maxn], mr[maxn], mrb[maxn];

void Divide() {
  sn = sqrt(n);
  for (int i = 1; i <= n; ++i) {
    bl[i] = n / sn;
  }
}

int px[maxn], py[maxn];
std::set<std::pair<int, int> > s[maxn];

void Solve() {
  for (int T = 1, id = 0; T <= n; ++T) if (op[T].opt == 1) {
    int x = op[T].x, y = op[T].y;
    mr[y] = std::max(mr[y], x);
    mrb[bl[y]] = std::max(mrb[bl[y]], x);
    s[y].insert({x, ++id});
    px[id] = x; py[id] = y;
  } else {
    int x = px[op[T].x], y = py[op[T].x];
    auto v = s[y].upper_bound({x, n});
    if (v != s[y].end()) {
      qw((*v).second, '\n');
    } else {
      int ans = -1;
      for (int p = y + 1; bl[p] == bl[y]; ++p) if (mr[p] >= x) {
        ans = p;
        break;
      }
      if (ans != -1) {
        qw((*s[ans].lower_bound({x, 0})).second, '\n');
      } else {
        for (int p = bl[y] + 1; p <= bl[n]; ++p) if (mrb[p] >= x) {
          ans = p;
          break;
        }
        if (ans == -1) {
          puts("NE");
        } else {
          for (int p = ans * sn, q = bl[p]; bl[p] == bl[q]; ++p) if (mr[p] >= x) {
            ans = p;
            break;
          }
          qw((*s[ans].lower_bound({x, 0})).second, '\n');
        }
      }
    }
  }
}
```



---

## 作者：_•́へ•́╬_ (赞：2)

发现题解区一堆分块。我感觉这个题明显三维偏序，可以 cdq。

## 思路

把 $B$ 离散化作为线段树下标。

cdq 板子。

对于插入：以 $B$ 为下标插入线段树。

对于查询：查询大于等于 $B$ 的人（即以 $B$ 为开头的这个后缀）中，$B$ 最小的人（即最靠前的非 $0$ 数）。

归并按 $A$ 从大到小排序。

## code

```cpp
#include<stdio.h>
#include<algorithm>
#define N 200009
#define lc(i) ((i)<<1|1)
#define rc(i) ((i)+1<<1)
using namespace std;
inline char nc()
{
	static char buf[99999],*l,*r;
	return l==r&&(r=(l=buf)+fread(buf,1,99999,stdin),l==r)?EOF:*l++;
}
inline void read(int&x)
{
	char c=nc();for(;c<'0'||'9'<c;c=nc());
	for(x=0;'0'<=c&&c<='9';x=(x<<3)+(x<<1)+(c^48),c=nc());
}
int n,m,q,x[N],y[N],ans[N],lsh[N],lsz,tre[N<<2];
inline bool cmp(const int&i,const int&j)
{
	if(y[i]^y[j])return y[i]>y[j];
	return x[i]>x[j];
}
struct node
{
	int o,i;
	inline bool operator<(const node&kkk)const
	{
		if(x[i]^x[kkk.i])return x[i]>x[kkk.i];
		return y[i]>y[kkk.i];
	}
}a[N],b[N];
inline void min(int&x,const int&y){if(!x||cmp(x,y))x=y;}
inline void upd(const int&i,const int&l,const int&r,const int&x,const int&y)
{
	if(!y)tre[i]=y;else min(tre[i],y);
	if(l==r)return;
	int mid=l+r>>1;
	if(x<=mid)upd(lc(i),l,mid,x,y);
	else upd(rc(i),mid+1,r,x,y);
}
inline int qry(const int&i,const int&l,const int&r,const int&x)
{
	if(r<x||!tre[i])return 0;
	if(x<=l)return tre[i];
	int mid=l+r>>1,tmp=qry(lc(i),l,mid,x);
	if(tmp)return tmp;
	return qry(rc(i),mid+1,r,x);
}
inline void cdq(const int&l,const int&r)
{
	if(l==r)return;
	int mid=l+r>>1,i,j,k;
	cdq(l,mid);cdq(mid+1,r);
	for(i=l,j=mid+1;i<=mid&&j<=r;)if(a[i]<a[j])
	{
		if(a[i].o>>31)upd(0,0,lsz-1,y[a[i].i],a[i].i);
		++i;
	}
	else
	{
		if(~a[j].o)min(ans[a[j].o],qry(0,0,lsz-1,y[a[j].i]));
		++j;
	}
	for(;j<=r;++j)if(~a[j].o)min(ans[a[j].o],qry(0,0,lsz-1,y[a[j].i]));
	for(i=l,j=mid+1,k=l;i<=mid&&j<=r;)if(a[i]<a[j])
	{
		if(a[i].o>>31)upd(0,0,lsz-1,y[a[i].i],0);
		b[k++]=a[i++];
	}
	else b[k++]=a[j++];
	for(;i<=mid;b[k++]=a[i++]);
	for(;j<=r;b[k++]=a[j++]);
	for(i=l;i<=r;a[i]=b[i],++i);
}
main()
{
	read(n);x[0]=y[0]=2147483647;
	for(int i=0,o;i<n;++i)
	{
		for(;o=nc(),(o^'D')&&(o^'P'););
		if(o^'P')read(x[++m]),read(y[m]),a[i].o=-1,a[i].i=m;
		else read(a[i].i),a[i].o=q++;
	}
	for(int i=1;i<=m;lsh[i-1]=y[i],++i);
	sort(lsh,lsh+m);lsz=unique(lsh,lsh+m)-lsh;
	for(int i=1;i<=m;++i)y[i]=lower_bound(lsh,lsh+lsz,y[i])-lsh;
	cdq(0,n-1);
	for(int i=0;i<q;++i)if(ans[i])printf("%d\n",ans[i]);
	else printf("NE\n");
}
```

---

## 作者：lzyqwq (赞：2)

**[更好的阅读体验](https://www.cnblogs.com/MnZnOIerLzy/articles/17274194.html)**

# $\texttt{Description}$

**[洛谷 $\text{P}6325$](https://www.luogu.com.cn/problem/P6325 "洛谷 P6325")**

> - 有 $n$ 个操作：
>
>    - $\texttt{D }x\texttt{ }y$：插入一个 $(x,y)$ 的元素（不会有重复的元素）。
>
>    - $\texttt{P }i$：查询在所有 $x\ge x_i,y\ge y_i$ 的元素中（不包括本身），$y$ 最小的元素的编号（输入顺序），若 $y$ 相同，则输出 $x$ 最小的。
>
> - $1\le n\le 2\times 10^5$，$1\le x,y\le 2\times 10^9$。

# $\texttt{Solution}$

先将所有操作离线，对 $y$ **离散化**。用 **`set`** 维护每个 $y$ 上 $x$ 的情况。考虑**先找到最小的 $y$，再找到对应的 $x$**。

对 $\texttt{P}$ 操作分类讨论（设答案为 $j$）：

- $y_j=y_i$，由于不包括本身，需要这种情况下寻找 $x_j>x_i$ 的最小的 $j$。用 `set` 的 **`upper_bound`** 即可。

- $y_j>y_i$，此时不难发现答案有**单调性**，即对于 $k$ 若 $y\in[y_i+1,k]$ 有解，则 $y\in[y_i+1,k+1]$ 有解；反之无解，则 $y\in [y_i+1,k-1]$ 无解。二分 $y_j$，判断 $[y_i+1,y_j]$ 中是否有解。具体来讲，若其中最大的 $x$ 满足 $x\ge x_i$，则有解，否则无解。再用**线段树**维护最大的 $x$ 即可。找到 $y_j$ 以后，再用 **`lower_bound`** 查询 $x_j\ge x_i$ 最小的 $j$ 即可。

对于 $\texttt{D}$ 操作，先在 `set` 上插入，如果能更新最大值就更新。

时间复杂度为 $\mathcal{O}(n\log^2n)$，空间复杂度为 $\mathcal{O}(n)$。

# $\texttt{Code}$

**[Submission](https://www.luogu.com.cn/record/106430304 "Submission")**

```cpp
#include<bits/stdc++.h>
#define N 200005
#define ls x<<1
#define rs x<<1|1
using namespace std;
int n,tot,num,mx[N<<2];
set<int>s;
set<pair<int,int>>Y[N];
map<int,int>mp;
char c;
pair<int,int>stu[N];
struct data{
    int op,x,y;
}p[N];
void modify(int x,int l,int r,int k,int v){
    if(l^r){
        int m=(l+r)>>1;
        if(k<=m){
            modify(ls,l,m,k,v);
        }else{
            modify(rs,m+1,r,k,v);
        }
        mx[x]=max(mx[ls],mx[rs]);
    }else{
        mx[x]=v;
    }
}
bool query(int x,int l,int r,int ql,int qr,int y){
    if(ql<=l&&r<=qr){
        return mx[x]>=y;
    }
    int m=(l+r)>>1;
    bool ret=0;
    if(ql<=m){
        if(query(ls,l,m,ql,qr,y)){
            return 1;
        }
    }
    if(qr>m){
        ret|=query(rs,m+1,r,ql,qr,y);
    }
    return ret;
}
int main(){
    scanf("%d",&n);
    for(int i=1,x,y;i<=n;++i){
        scanf(" %c",&c);
        if(c^'P'){
            scanf("%d%d",&x,&y);
            p[i]={0,x,y};
            stu[++num]=make_pair(x,y);
            s.insert(y);
        }else{
            scanf("%d",&x);
            p[i]={1,stu[x].first,stu[x].second};
        }
    }
    for(int i:s){
        mp[i]=++tot;
    }
    for(int i=1,x,y,j=0;i<=n;++i){
        x=p[i].x;
        y=mp[p[i].y];
        if(p[i].op){
            auto it=Y[y].upper_bound(make_pair(x,1e9));
            if(it!=Y[y].end()){
                printf("%d\n",it->second);
            }else{
                int l=y+1,r=tot,f=0;
                while(l<=r){
                    int m=(l+r)>>1;
                    if(query(1,1,tot,y+1,m,x)){
                        r=(f=m)-1;
                    }else{
                        l=m+1;
                    }
                }
                if(f){
                    printf("%d\n",Y[f].lower_bound(make_pair(x,0))->second);
                }else{
                    puts("NE");
                }
            }
        }else{
            if(!Y[y].size()||x>Y[y].rbegin()->first){
                modify(1,1,tot,y,x);
            }
            Y[y].insert(make_pair(x,++j));
        }
    }
}
```

---

## 作者：Others (赞：1)

在我做的时候,我是最优解。

# Solution

题意理解得清这题就简单，大致来说就是在二维平面内加入几个点，询问某个点，在它的“右上方”的点，优先纵坐标小，然后是横坐标。

这里我们首先想，如果我们知道那个点在哪一行，那这题就很 naive 了，直接在该行上维护一个有序的横坐标数列，一个 `lower_bound` 解决，我用的是 `set`，这样我们的难点就在怎么找那一行，这里可以用很多数据结构（线段树，分块等等数据结构），这里我用的是分块。

我们将“答案所在的那一行”理解一下，意思是在那一行的下面到询问点的那一行是没有横坐标大于所选点的，这就启示这我们去维护每一行的横坐标最大值，这样就完美了，记得离散化 qwq。

**Code**

```cpp
#include<bits/stdc++.h>
using namespace std;
int qr(){
	int x=0,f=0;
	char c=getchar();
	while(!isdigit(c)) f|=(c=='-'),c=getchar();
	while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return f?~(x-1):x;
}
struct node{
	char opt;
	int x,y,id;
	bool operator<(const node &p)const{//²»ÏþµÃ set ÒªÓÃÄÄÖÖÔËËã·û£¬ËùÒÔÎÒ¶¼ÖØÔØÁË¡£ 
		return x<p.x;
	}
	bool operator>(const node &p)const{
		return x>p.x;
	}
}p[200005];
set<node> se[200005];//Î¬»¤Ã¿Ò»ÐÐµÄºá×ø±êµÄÓÐÐòÊýÁÐ 
int flag[400005],top,N,Maxx[200005],Maxxx[505],n,idx[200005],cnt,con[200005],s,bls,L[505],R[505];
int main() {
	n=qr();
	for(int i=1;i<=n;i++){
		cin >> p[i].opt;
		if(p[i].opt=='D'){
			p[i].x=qr(),p[i].y=qr();
			flag[++top]=p[i].y;//ÀëÉ¢»¯Êý×é 
			con[p[i].id=++cnt]=i;
		}else{
			p[i].x=con[qr()];
		}
	}
	sort(flag+1,flag+top+1);
	N=unique(flag+1,flag+top+1)-flag-1;
	s=sqrt(N),bls=(N+s-1)/s;
	for(int i=1;i<=bls;i++){//¶Ô×Ý×ø±ê·Ö¿é 
		L[i]=R[i-1]+1,R[i]=min(s*i,N);
		for(int j=L[i];j<=R[i];j++) idx[j]=i;
	}
	for(int i=1;i<=n;i++){
		if(p[i].opt=='D'){
			p[i].y=lower_bound(flag+1,flag+N+1,p[i].y)-flag;//ÀëÉ¢»¯£¬×¢ÒâÕâÀïµÄºá×ø±êÀë²»Àë¶¼Ã»ÓÐÓ°Ïì£¨¿ÉÄÜÕâ¾ÍÊÇÎÒ×îÓÅ½âµÄÔ­Òò£© 
			se[p[i].y].insert(p[i]);
			Maxx[p[i].y]=max(Maxx[p[i].y],p[i].x);//¸üÐÂÄÇÒ»ÐÐ 
			Maxxx[idx[p[i].y]]=max(Maxxx[idx[p[i].y]],p[i].x);//¸üÐÂÄÇÒ»ÐÐËùÔÚ¿é 
		}else{
			bool flag=0;
			set<node>::iterator it=se[p[p[i].x].y].lower_bound(p[p[i].x]);//¶Ô²éÑ¯µãËùÔÚÐÐµÄÌØÅÐ£¨ÒòÎªº¬ÓÐËû×Ô¼º£© 
			if(it->id==p[p[i].x].id) {
				it++;
				if(it!=se[p[p[i].x].y].end()) {
					printf("%d\n",it->id);
					continue;
				}
			}
			for(int j=p[p[i].x].y+1;j<=R[idx[p[p[i].x].y]];j++){//²éÑ¯µãµÄ¿éÊÇÉ¢¿é£¬ËùÒÔÖ±½ÓÃ¶¾Ù 
				if(Maxx[j]>=p[p[i].x].x) {
					flag=1;
					printf("%d\n",se[j].lower_bound(p[p[i].x])->id);
					break;
				}
			} 
			if(flag) continue;
			for(int j=idx[p[p[i].x].y]+1;j<=bls;j++){//Õû¿éÃ¶¾Ù 
				if(Maxxx[j]>=p[p[i].x].x) {
					for(int k=L[j];k<=R[j];k++){//Ã¶¾Ù¿éÄÚ 
						if(Maxx[k]>=p[p[i].x].x){
							printf("%d\n",se[k].lower_bound(p[p[i].x])->id);
							break;
						}
					}
					flag=1;
					break;
				}
			}
			if(!flag) printf("NE\n");
		}
	}
	return 0;
}
```

这题似乎 log 数据结构会更快，因为查询和插入对等，但我用的是 $O(1)$ 插入，$O(\sqrt n)$ 查询的分块，没有平衡的效果（~~单纯是因为好打~~），这题可能数据里插入要多一些（简称：H2O）。

---

## 作者：ez_lcw (赞：1)

最先想到的应该是先把每组 $(A,B)$ 看成一个点，然后用树套树来维护这些点集。

然后假设现在询问的是 $i$，那么这个人要选择的人 $j$ 要满足 $A_i\leq A_j$ 且 $B_i\leq B_j$，把这个放在坐标系上，就是要求点 $(A_j,B_j)$ 必须在点 $(A_i,B_i)$ 的右上角。

然后我们就可以通过找到树套树找到最小的 $B_j$ 是多少，但是这样的一个 $B$ 可能对应着很多个 $A_j$，然后我们要找到其中 $A_j$ 最小的那个。

这个过程可以用 ```set``` 的 ```lower_bound``` 实现，具体看代码。

但题目貌似不友好，貌似会把我们的树套树的空间 $O(n \log^2 n)$ 卡掉（62.50MB）。

~~难道真的只能跟扶苏一样用分块了吗？~~

~~不，数据结构是多种多样的，我们还可以用 kd-tree~~。

没错，$kd-tree$ 的空间复杂度是 $O(n)$ 的，不会被卡掉。

需要注意的点：

1. $kd-tree$ 需要支持重构，然后在 $\operatorname{query}$ 的时候有个小优化（~~小优化加不加好像都能 AC~~）。

1. 不需要离散化。

1. 询问的时候有可能找到的最优点会找到自己，解决这种问题的办法有很多种，~~我用了最省码量但会加大很多常数的做法~~：把 ```query(x,y)``` 改成 ```min(query(x+1,y),query(x,y+1))```。这样就能保证你寻找最优解的时候不会找到自己了。

1. 用 ```lower_bound``` 的时候如果找到的最小的 $B_j$ 和自己的 $B_i$ 是相等的，就可能又会找到自己，所以这个时候把 ```lower_bound(x,y)``` 改成 ```lower_bound(x+1,y)```。

1. 由于 $kd-tree$ 的时间复杂度很~~玄学~~不稳定再加上常树巨大，导致我要开 O2 才能过。

代码如下：

```cpp
#include<bits/stdc++.h>

#define N 200010
#define lc t[u].ch[0]
#define rc t[u].ch[1]
#define INF 0x7fffffff

using namespace std;

struct Point
{
	int num[2];
	Point(){};
	Point(int xx,int yy)
	{
		num[0]=xx,num[1]=yy;
	}
}p[N],a[N];

struct data
{
	int x,y,id;
	data(){};
	data(int xx,int yy,int idd)
	{
		x=xx,y=yy,id=idd;
	}
	bool operator < (const data &a) const 
	{
		if(y==a.y) return x<a.x;
		return y<a.y;
	}
};

struct kd_tree
{
	int ch[2],minn[2],maxn[2],size;
	Point p;
}t[N];

const double alpha=0.75;

int pnum,anum;
int n,tot,root;
int cnt,rubbish[N];

set<data>s;

bool cmp0(Point a,Point b)
{
	return a.num[0]<b.num[0];
}

bool cmp1(Point a,Point b)
{
	return a.num[1]<b.num[1];
}

int newnode()
{
	if(cnt)return rubbish[cnt--];
	return ++tot;
}

void up(int u)
{
	for(int i=0;i<2;i++)
	{
		t[u].minn[i]=t[u].maxn[i]=t[u].p.num[i];
		if(lc)
		{
			t[u].minn[i]=min(t[u].minn[i],t[lc].minn[i]);
			t[u].maxn[i]=max(t[u].maxn[i],t[lc].maxn[i]);
		}
		if(rc)
		{
			t[u].minn[i]=min(t[u].minn[i],t[rc].minn[i]);
			t[u].maxn[i]=max(t[u].maxn[i],t[rc].maxn[i]);
		}
	}
	t[u].size=t[lc].size+t[rc].size+1;
}

void slap(int u)
{
	if(!u) return;
	p[++pnum]=t[u].p;
	rubbish[++cnt]=u;
	slap(lc);
	slap(rc);
}

int rebuild(int l,int r,int d)
{
	if(l>r) return 0;
	int mid=(l+r)>>1,u=newnode();
	nth_element(p+l,p+mid,p+r+1,d?cmp1:cmp0);
	t[u].p=p[mid];
	lc=rebuild(l,mid-1,d^1);
	rc=rebuild(mid+1,r,d^1);
	up(u);
	return u;
}

void check(int &u,int d)
{
	if(t[lc].size>alpha*t[u].size||t[rc].size>alpha*t[u].size)
	{
		pnum=0;
		slap(u);
		u=rebuild(1,t[u].size,d);
	}
}

void insert(int &u,Point now,int d)
{
	if(!u)
	{
		u=newnode();
		lc=rc=0,t[u].p=now;
		up(u);
		return;
	}
	if(now.num[d]<=t[u].p.num[d]) insert(lc,now,d^1);
	else insert(rc,now,d^1);
	up(u);
	check(u,d);
}

int query(int u,int x,int y)
{
	if(!u) return INF;
	if(x<=t[u].minn[0]&&y<=t[u].minn[1]) return t[u].minn[1];
	if(x>t[u].maxn[0]||y>t[u].maxn[1]) return INF;
	int ans=INF;
	if(x<=t[u].p.num[0]&&y<=t[u].p.num[1])
		ans=t[u].p.num[1];
	if(t[lc].minn[1]<ans) ans=min(ans,query(lc,x,y));//提到的小优化（那个if）
	if(t[rc].minn[1]<ans) ans=min(ans,query(rc,x,y));
	return ans;
}

int main()
{
	scanf("%d",&n);
	while(n--)
	{
		char opt[1];
		scanf("%s",opt);
		if(opt[0]=='D')
		{
			++anum;
			scanf("%d%d",&a[anum].num[0],&a[anum].num[1]);
			s.insert(data(a[anum].num[0],a[anum].num[1],anum));
			insert(root,a[anum],0);
		}
		else
		{
			int k;
			scanf("%d",&k);
			int miny=min(query(root,a[k].num[0]+1,a[k].num[1]),query(root,a[k].num[0],a[k].num[1]+1));//注意3中提到的
			if(miny==INF)//没有找到可以选的点
			{
				puts("NE");
				continue;
			}
			set<data>::iterator it;
			if(miny==a[k].num[1]) it=s.lower_bound(data(a[k].num[0]+1,miny,0));//如果Bi=Bj
			else it=s.lower_bound(data(a[k].num[0],miny,0));
			if(a[(*it).id].num[1]!=miny)//貌似是多余的特判？
			{
				puts("NE");
				continue;
			}
			printf("%d\n",(*it).id);
		}
	}
}
```


---

## 作者：FutaRimeWoawaSete (赞：1)

备选 T2 。             

平面邻域点查找，可离线。              

一个比较简单的思想是离散化后树套树解决，刚开始我也是这么想的但是由于迫不得已要分块做所以打完后才发现空间把树套树卡掉了……              

于是我们这么维护一下答案：还是离线然后按 $B$ 排序，然后模拟加点过程维护一下块内出现点的所有 $A$ 的最大值。      

对于散块暴力扫，对于整块我们知道由于原序列按 $B$ 排序那么只用管 $A$ 是否合法即可，那么看整块维护的 $A$ 的最大值是和当前查询点的关系即可知道当前块是否有点合法，再暴力扫一遍这个块就行了。            

如果在线的话可能需要动态插点排序，然后中间如果有块的长度大于 $2\sqrt n$ 就暴力裂开重构，有兴趣的同学可以写一下吧。             

然后 KD-tree 也可以做，毕竟最后也成了个单点修改矩形查,树上维护一下题目要求的东西就行了，时间复杂度要稍微优秀一点是 $\Theta(n \sqrt n)$。           

```cpp
#include "bits/stdc++.h"
using namespace std;
const int Len = 2e5 + 5 , SIZE = 485;
int n,m,lsh[Len << 2],Alive[Len],cnt,t,L[SIZE],R[SIZE],pos[Len],Pos[Len],MaxA[SIZE];
struct node
{
	int opt,A,B,id;
}oper[Len];
struct Node
{
	int A,B,id;
	Node(){A = B = id = 0;}
}Stu[Len];
bool cmpB(Node x,Node y)
{
	if(x.B == y.B) return x.A < y.A;
	return x.B < y.B;
}
char s[5];
int Bquery(int l,int r,int x)
{
	int res = -1;
	if(l > r) return res;
	for(int i = l ; i <= r ; i ++) 
	{
		if(!Alive[i]) continue;
		if(Stu[x].B <= Stu[i].B && Stu[x].A <= Stu[i].A)
		{
			if(res == -1) res = i;
			else if(Stu[i].B < Stu[res].B || (Stu[i].B == Stu[res].B && Stu[i].A < Stu[res].A)) res = i;
		}
	}
	return res;
}
int query(int x)
{
	x = Pos[x];
	int LL = pos[x] , res = -1;
	if(LL == t) return res = Bquery(x + 1 , cnt , x);
	res = Bquery(x + 1 , R[LL] , x);
	if(~res) return res;
	for(int i = LL + 1 ; i <= t ; i ++) if(MaxA[i] >= Stu[x].A) return res = Bquery(L[i] , R[i] , x);
	return res;
}
void upd(int x)
{
	x = Pos[x];
	Alive[x] |= 1;
	MaxA[pos[x]] = max(MaxA[pos[x]] , Stu[x].A); 
}
signed main()
{
	scanf("%d",&n);
	for(int i = 1 ; i <= n ; i ++)
	{
		scanf("%s",s);
		if(s[0] == 'D') 
		{
			oper[i].opt = 0;
			scanf("%d %d",&oper[i].A,&oper[i].B);cnt ++;
			Stu[cnt].A = oper[i].A , Stu[cnt].B = oper[i].B , Stu[cnt].id = oper[i].id = cnt;
		}
		else 
		{
			oper[i].opt = 1;
			scanf("%d",&oper[i].A);
		}
	}
	sort(Stu + 1 , Stu + 1 + cnt , cmpB);
	//for(int i = 1 ; i <= cnt ; i ++) printf("%d %d\n",Stu[i].A,Stu[i].B);
	for(int i = 1 ; i <= cnt ; i ++) Pos[Stu[i].id] = i;
	t = sqrt(cnt);
	for(int i = 1 ; i <= t ; i ++) 
	{
		L[i] = (i - 1) * t + 1;
		R[i] = i * t;
	}
	R[t] = cnt;
	for(int i = 1 ; i <= t ; i ++) 
		for(int j = L[i] ; j <= R[i] ; j ++) pos[j] = i;
	memset(Alive , 0 , sizeof Alive);
	for(int i = 1 ; i <= n ; i ++)
	{
		if(oper[i].opt == 0) upd(oper[i].id);
		else 
		{
			int x = query(oper[i].A);
			if(~x) printf("%d\n",Stu[x].id);
			else puts("NE");
		}
		
	} 
	return 0;
}
```

---

## 作者：Kreado (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P6325)。

## 思路

先将输入离散化，接下来对离散化后的值域分块，那么对于询问 $(x,y)$，我们只需求当前加进的二元组中 $(c,d)$ 满足 $c\ge x,d\ge y$ 的第二小元组（注意自己本身也是一个合法元组），分块中第 $i$ 块的值为 $b_j\in[L_i,R_i]$ 所对应的最大 $a_j$。

对于每个询问 $(x,y)$，从 $y$ 后面开始寻找，若当前遍历的 $i$ 中存在另一个 $b_j=i\land a_j\ge x$（可以用 set 维护），暴力遍历此块，直到满足条件的二元组个数大于 $1$。

可以使用分块优化上述过程，最终时间复杂度为 $\mathcal{O}(n\log n+n\sqrt n)$，因为使用 set 的次数不超过 $2n$。


```cpp
#include <bits/stdc++.h>
#define ll long long
#define mk make_pair
using namespace std;

const int Maxn=4e5+7,V=2e5;
int Q;
int val[Maxn],bin[Maxn],pos[Maxn];
struct ques{
	int opt,x,y;
}q[Maxn],q1[Maxn];
int cnt;

int A[Maxn],B[Maxn],tot;
int L[Maxn],R[Maxn],bl;
set<pair<int,int> >s[Maxn];

int main(){
	scanf("%d",&Q);
	for(int i=1;i<=Q;i++){
		char opt;
		cin>>opt;
		if(opt=='D'){
			int x,y;
			scanf("%d%d",&x,&y);
			q[i]=(ques){1,x,y};
			A[++tot]=x,B[tot]=y;
		}
		else{
			int x;
			scanf("%d",&x);
			q[i]=(ques){0,x,0};
		}
	}
	sort(A+1,A+tot+1),sort(B+1,B+tot+1);
	int acnt=unique(A+1,A+tot+1)-(A+1),bcnt=unique(B+1,B+tot+1)-(B+1);
	for(int i=1;i<=Q;i++) 
		if(q[i].opt) 
			q[i].x=lower_bound(A+1,A+acnt+1,q[i].x)-A,
			q[i].y=lower_bound(B+1,B+bcnt+1,q[i].y)-B,
			q1[++cnt]=(ques){0,q[i].x,q[i].y};

	bl=sqrt(V);
	for(int i=1;i<=bl;i++){
		L[i]=R[i-1]+1;
		R[i]=i*bl;
	}
	if(R[bl]<V) R[++bl]=V,L[bl]=R[bl-1]+1;

	for(int i=1;i<=bl;i++)
		for(int j=L[i];j<=R[i];j++)
			pos[j]=i;

	cnt=0;
	for(int i=1;i<=Q;i++){
		int opt=q[i].opt,x=q[i].x,y=q[i].y;
		if(opt==1){
			val[pos[y]]=max(val[pos[y]],x);
			bin[y]=max(bin[y],x);
			s[y].insert(mk(x,++cnt));
		}
		else{
			int ql=pos[q1[x].y],tq=0,id=-1;
			for(int i=q1[x].y;i<=R[ql] and tq<2;i++){
				if(bin[i]>=q1[x].x){
					auto it=s[i].lower_bound(mk(q1[x].x,0));
					while(it!=s[i].end() and tq<2){
						tq++;if(tq==2)id=it->second;it++;
					}
				}
			}
			for(int i=ql+1;i<=bl and tq<2;i++){
				if(val[i]>=q1[x].x){
					for(int j=L[i];j<=R[i] and tq<2;j++){
						if(bin[j]>=q1[x].x){
							auto it=s[j].lower_bound(mk(q1[x].x,0));
							while(it!=s[j].end() and tq<2){
								tq++;if(tq==2)id=it->second;it++;
							}
						}
					}
				}
			}
			if(id==-1) puts("NE");
			else printf("%d\n",id);
		}
	}	

	system("pause");
	return 0;
}
```

---

## 作者：D0000 (赞：0)

用值域线段树记录 $b$ 值在某个区间内的点 $a$ 的最大值。那么每次询问时，设询问 $a_i,b_i$，需要找到最左边的一个 $k$ 使得 $[b_i+1,k]$ 的最大值大于等于 $a_i$，可用二分解决。而 $b$ 值相同的点就在相同 $b$ 值开个 set 即可。

实现较为容易，时间复杂度 $O(n\log^2n)$：

```cpp
#include<cstdio>
#include<set>
#include<algorithm> 

#define int long long

int a,b,id,n,ua[200005],ub[200005],cnt,cnt2=1,cnt3;
char op;

bool zyh;
struct stutt{
	int id,aa;
	bool operator < (const stutt zz)const{
		return aa<zz.aa;
	}
};
struct kid{
	std::set<stutt>s;
}A[200005];
struct node{
	int lc,rc,t,jjj;
}sgt[4000005];
void add(int x,int v,int l=1,int r=2e9,int o=1){
	sgt[o].t=std::max(sgt[o].t,v);
	if(l==r){
		if(!sgt[o].jjj)sgt[o].jjj=++cnt3;
		A[sgt[o].jjj].s.insert({cnt+1,v});
		return;
	}
	int mid=(l+r)>>1;
	if(x<=mid){
		if(!sgt[o].lc)sgt[o].lc=++cnt2;
		add(x,v,l,mid,sgt[o].lc);
	}
	else{
		if(!sgt[o].rc)sgt[o].rc=++cnt2;
		add(x,v,mid+1,r,sgt[o].rc);
	}
}
int qu(int ll,int rr,int l=1,int r=2e9,int o=1){
	if(l>=ll&&r<=rr)return sgt[o].t;
	int mid=(l+r)>>1,ans=0;
	if(ll<=mid&&sgt[o].lc)ans=std::max(ans,qu(ll,rr,l,mid,sgt[o].lc));
	if(rr>mid&&sgt[o].rc)ans=std::max(ans,qu(ll,rr,mid+1,r,sgt[o].rc));
	return ans;
}
void qu2(int x,int v,int l=1,int r=2e9,int o=1){
	if(l==r){
		printf("%d\n",(*(A[sgt[o].jjj].s.lower_bound({-1,v}))).id);
		return;
	}
	int mid=(l+r)>>1;
	if(x<=mid)qu2(x,v,l,mid,sgt[o].lc);
	else qu2(x,v,mid+1,r,sgt[o].rc);
}
void fiw(int x,int v,int l=1,int r=2e9,int o=1){
	if(l==r){
		if(A[sgt[o].jjj].s.upper_bound({-1,v})!=A[sgt[o].jjj].s.end())printf("%d\n",(*(A[sgt[o].jjj].s.upper_bound({-1,v}))).id),zyh=1;
		return;
	}
	int mid=(l+r)>>1;
	if(x<=mid)fiw(x,v,l,mid,sgt[o].lc);
	else fiw(x,v,mid+1,r,sgt[o].rc);
}
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%s",&op);
		if(op=='P'){
			scanf("%d",&id);
			zyh=0;
			fiw(ub[id],ua[id]);
			if(zyh)continue;
			int l=ub[id]+1,r=2e9,mid,ans=-2e9;
			while(l<=r){
				mid=(l+r)>>1;
				if(qu(ub[id]+1,mid)>=ua[id])ans=mid,r=mid-1;
				else l=mid+1;
			}
			if(ans==-2e9)puts("NE");
			else qu2(ans,ua[id]);
		}
		else{
			scanf("%d%d",&a,&b);
			add(b,a);cnt++;
			ua[cnt]=a,ub[cnt]=b;
		}
	}
}
```

---

## 作者：gyyyyx (赞：0)

[题面](https://www.luogu.com.cn/problem/P6325)

感觉很水，随便交了一发就是最优解。

首先观察到 $A,B$ 的范围比较大，可以先离散化出来。

考虑值域分块。

将所有学生按 $B$ 的值分成 $\sqrt{n}$ 个块。

对于一个询问 $i$，我们可以从第 $i$ 个学生所在的块 $p$ 开始，依次枚举所有块，这样保证了找出的学生的 $B$ 值合法且最小。

若找到一个块中存在学生的 $A$ 值合法，则枚举这个块中的所有学生，找到最优的就行了。

不存在这样的块则必定不存在合法的学生，输出 ``NE`` 即可。

而如何判断一个块中存在 $A$ 值合法的学生呢？

我们可以记录下来当前时间节点，这个块 $t$ 中 $A$ 值最大的学生的 $A$ 值，记为 $mxA_t$。

则我们只需要找到最小的 $t$ 使得 $t\geq p$ 且 $mxA_t\geq A_i$。

时间是 $O(n\sqrt{n})$ 的。

代码：

```cpp
#include<bits/stdc++.h>
#define N 200005
using namespace std;
int n;
struct Student{
	int A,B;
} st[N];
int cnt;
int h[N],tot;
struct Query{
	int id,t;
} q[N];
int num;
int block,bl[N],mx;
vector <int> alv[450];
int mxA[450];
inline int Getans(int k,int id){
	int res(0);
	for(int i(0);i<alv[k].size();++i){
		int cur(alv[k][i]);
		if(cur==id) continue;
		if(st[cur].A<st[id].A||st[cur].B<st[id].B) continue;
		if(res){
			if(st[cur].B<st[res].B) res=cur;
			else if(st[cur].B==st[res].B&&st[cur].A<st[res].A) res=cur;
		}
		else res=cur;
	}
	return res;
}
inline int Solve(int id){
	if(alv[bl[id]].size()>1){//如果想和询问的学生在同一块，这个块中至少要由两个人
		int res(Getans(bl[id],id));
		if(res) return res;
	}
	for(int i(bl[id]+1);i<=mx;++i)
		if(alv[i].size()&&mxA[i]>=st[id].A)
			return Getans(i,id);
	return 0;
}
int main(){
	scanf("%d",&n);
	for(int i(1);i<=n;++i){
		char op;scanf(" %c",&op);
		if(op=='D'){
			++cnt;
			scanf("%d%d",&st[cnt].A,&st[cnt].B);
			h[++tot]=st[cnt].B;
		}
		else{
			++num;
			scanf("%d",&q[num].id);
			q[num].t=cnt;
		}
	}
	sort(h+1,h+1+tot);tot=unique(h+1,h+1+tot)-h-1;block=sqrt(tot);
	for(int i(1);i<=cnt;++i){
		st[i].B=lower_bound(h+1,h+1+tot,st[i].B)-h;
		mx=max(mx,bl[i]=(st[i].B-1)/block+1);
	}//离散化
	for(int i(1),j(1);i<=cnt&&j<=num;++i){
		alv[bl[i]].push_back(i);
		mxA[bl[i]]=max(mxA[bl[i]],st[i].A);
		while(q[j].t==i){
			int ans(Solve(q[j].id));
			if(ans) printf("%d\n",ans);
			else puts("NE");
			++j;
		}
	}
	return 0;
}
```

---

## 作者：Borate (赞：0)

提供一种奇怪的做法。


------------


首先，做这道题的时候我在学莫队，然后就想到带修莫队的操作。

> 普通莫队是不能带修改的。

> 我们可以强行让它可以修改，就像 DP 一样，可以强行加上一维时间维，表示这次操作的时间。

（以上来自 OI-Wiki。）

那么，很容易就可以想到，把询问操作和加人操作分别存起来，对加进来的人打上时间戳，再按照题意，把人以能力系数 $B$ 为第一关键字，$A$ 为第二关键字降序排序（__注意这里是把人排序，而不是把操作排序__），就可以暴力查询了。

注意排序前和排序后人的标号变化。

放代码可能会没那么抽象？

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5;
int n;
struct Stu 
{
    int a, b, num, t;
    inline bool operator < (const Stu& o) const
    {
        if(a > o.a && b > o.b)
            return 1;
        if(b == o.b)
            return a > o.a;
        return b > o.b;
    }
} p[N];
struct query {
    int num, tim;
} ask[N];
int pnt, ant, mp[N];

int main()
{
    ios::sync_with_stdio(0);
    cin>>n;
    for(int i = 1;i <= n;i ++)
    {
        char opt;
        int a, b;
        cin>>opt>>a;
        if(opt == 'D')
        {
            cin>>b;
            p[++ pnt].a = a;
            p[pnt].b = b;
            p[pnt].num = pnt;
            p[pnt].t = ant;
        }
        else
            ask[++ ant].num = a, ask[ant].tim = ant;
    }
    sort(p + 1,p + 1 + pnt);
    for(int i = 1;i <= pnt;i ++)
        mp[p[i].num] = i;
    for(int i = 1;i <= ant;i ++)
    {
        int now = mp[ask[i].num];
        for(int j = now - 1;j;j --)
        {
            if(p[now].a <= p[j].a && p[now].b <= p[j].b && ask[i].tim > p[j].t)
            {
                cout<<p[j].num<<endl;
                now = -1;
                break;
            }
        }
        if(now == mp[ask[i].num])
            cout<<"NE"<<endl;
    }
    return 0;
}
```

事实上我觉得这种做法可以很轻松地被卡到 $O(N{^2})$ 级别，但是还是能过这题，可能是题目年代久远数据有点弱吧 qnq。


---


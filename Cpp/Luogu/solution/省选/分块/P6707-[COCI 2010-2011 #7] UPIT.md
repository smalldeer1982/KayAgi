# [COCI 2010/2011 #7] UPIT

## 题目背景

Mirko 厌倦了为了各种任务去实现各种数据结构。所以，他决定写一个终极数据结构去操纵他最喜欢的数字序列。

快来帮助他吧！

Mirko 会给你他的数列，以及一系列你必须执行的操作。每个询问要么询问关于数列的信息，要么修改现有的数列。下面列出了所有可能的操作类型。

查询种类|描述|例子|
:-:|:-:|:-:
`1 A B X`|将 $[A,B]$ 中所有元素值更改为 $X$|$(9, 8, 7, 6, 5, 4, 3, 2, 1)\to$ $1$ $3$ $5$ $0$ $\to$ $(9, 8, 0, 0, 0, 4, 3, 2, 1)$
`2 A B X`|将 $[A,B]$ 中所有元素增加一数，第 $A+k$ 位增加 $(k+1) \times X$|$(9, 8, 7, 6, 5, 4, 3, 2, 1)\to$ $2$ $3$ $5$ $2$ $\to (9, 8, 9, 10, 11, 4, 3, 2, 1)$
`3 C X`|在原来的第 $C$ 位前插入一个数，数值为 $X$|$(9, 8, 7, 6, 5, 4, 3, 2, 1)$ $\to$ $3$ $4$ $100$ $\to$ $(9, 8, 7, 100, 6, 5, 4, 3, 2, 1)$
`4 A B`|查询 $[A,B]$ 的数值和|$(2, 18, 7, 6, 1, 4, 7, 7, 2)$ $\to$ $4$ $6$ $7$ $\to$ $result: 11$

## 题目描述

给定一个数列 $f$ ，有以下操作。

设数列当前长度为 $n$。

|查询种类|描述|
|:-:|:-:|
`1 A B X`| $f_i=X(A \le i \le B)$
`2 A B X`| $f_i+=(i-A+1) \times X(A \le i \le B)$
`3 C X`| $f_{i+1}=f_i(C \le i \le n)$ $f_C=X$
`4 A B`| 求$\sum^B_{i=A}f_i$

## 说明/提示

#### 数据规模及约定


设当前数列长 $t$。

对于 $100\%$ 的数据 $1 \le n$ , $Q \le 1 \times 10^5$ , $f_i \le 1 \times 10^5$ , $1 \le X \le 100$ , $1 \le A \le B \le t$ , $1 \le C \le t + 1$。

#### 说明

本题满分 $130$ 分。

译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #7](https://hsin.hr/coci/archive/2010_2011/contest7_tasks.pdf) T6 UPIT。


## 样例 #1

### 输入

```
5 5
1 2 3 4 5
1 5 5 0
4 4 5
4 5 5
2 1 5 1
4 1 5```

### 输出

```
4
0
25```

## 样例 #2

### 输入

```
1 7
100
3 1 17
3 2 27
3 4 37
4 1 1
4 2 2
4 3 3
4 4 4```

### 输出

```
17
27
100
37```

# 题解

## 作者：Rosyclouds (赞：4)

对楼上分块算法的代码补充

另提一下，之所以不会T,是因为我们当块大小>2S时才会重构，那么最多重构$\sqrt(n)$次,复杂度是$\sqrt(n)n$
```cpp
#include <bits/stdc++.h>
using namespace std;
#define LL long long
#define ls p<<1
#define rs p<<1|1
const int M=2e5+5;
int n,tot,Q,S,sz[450];//sz：块的大小 
LL lazy[3][450],sum[450],num[450][900],tmp[M];//lazy:延迟更新标记 
void Down(int p){ 
    if(lazy[0][p]){
        for(int i=1;i<=sz[p];++i)num[p][i]=lazy[0][p];
        lazy[0][p]=0;
    }
    if(lazy[1][p]){
        LL &x=lazy[1][p],&y=lazy[2][p];
        for(int i=1;i<=sz[p];++i)
            num[p][i]+=x,x+=y;
        x=y=0;
    }
}
LL Query(int l,int r){
    LL res=0;
    int k=1,id=0,t=1;
    while(k+sz[id]<=l)k+=sz[id++];
    Down(id);
    while(k<l)++k,++t;
    while(t<=sz[id]&&k<=r)res+=num[id][t++],++k;
    ++id;
    while(k+sz[id]<=r)k+=sz[id],res+=sum[id++];
    t=1;Down(id);
    while(k<=r)res+=num[id][t++],++k;
    return res;
}
void Change(int l,int r,int x){
    int k=1,id=0,t=1;
    while(k+sz[id]<=l)k+=sz[id++];
    Down(id);
    while(k<l)++k,++t;
    while(t<=sz[id]&&k<=r)
        sum[id]+=x-num[id][t],num[id][t++]=x,++k;
    ++id;
    while(k+sz[id]<=r){
        k+=sz[id];
        sum[id]=1ll*sz[id]*x;
        lazy[0][id]=x;lazy[1][id]=lazy[2][id]=0;
        id++;
    }
    t=1;Down(id);
    while(k<=r){
        sum[id]+=x-num[id][t],num[id][t++]=x,++k;
    }
    return ;
}
void Update(int l,int r,int x){
    int k=1,id=0,t=1;
    LL v=x;
    while(k+sz[id]<=l)k+=sz[id++];
    Down(id);
    while(k<l)++k,++t;
    while(t<=sz[id]&&k<=r)
        sum[id]+=v,num[id][t++]+=v,++k,v+=x;
    ++id;
    while(k+sz[id]<=r){
        k+=sz[id];
        sum[id]+=(v+v+(1ll*sz[id]-1)*x)*sz[id]/2;
        lazy[1][id]+=v;lazy[2][id]+=x;
        v+=1ll*sz[id]*x;id++;
    }
    t=1;Down(id);
    while(k<=r){
        sum[id]+=v,num[id][t++]+=v,++k,v+=x;
    }
    return ;
}
void Rebuild(){//块重构 
    tot=0;
    for(int i=0;sz[i];++i){
        Down(i);
        for(int j=1;j<=sz[i];++j)
        tmp[++tot]=num[i][j];
        sz[i]=sum[i]=0;
    }
    S=max(2,(int)sqrt(tot));
    for(int i=1;i<=tot;++i){
        int id=i/S;
        sum[id]+=tmp[i];
        num[id][++sz[id]]=tmp[i];
    }
}
void Insert(int x,int y){
    int k=1,id=0,t=1;
    while(sz[id]&&k+sz[id]<=x)k+=sz[id++];
    Down(id);
    while(k<x)++k,++t;
    for(int i=sz[id];i>=t;--i)num[id][i+1]=num[id][i];
    num[id][t]=y,sum[id]+=y,++sz[id];
    if(sz[id]>2*S)Rebuild(); //当块的大小超出2S的时候将所有块重构 
}
int main(){
    int x,y,z,kind;
    scanf("%d%d",&n,&Q);
    int S=max(2,(int)sqrt(n));
    for(int i=1;i<=n;++i){
        scanf("%d",&x);
        int id=i/S;
        num[id][++sz[id]]=x;
        sum[id]+=x;
    }
    while(Q--){
        scanf("%d%d%d",&kind,&x,&y);
        if(kind==1){
            scanf("%d",&z);
            Change(x,y,z);
        }
        else if(kind==2){
            scanf("%d",&z);
            Update(x,y,z);
        }   
        else if(kind==3)
            Insert(x,y);
         
        else
            printf("%lld\n",Query(x,y));    
    }
    return 0;
}
```


---

## 作者：cherry2010 (赞：3)

分块。

将不同操作分开分析，每个操作都是分块的一个经典应用。

+ 操作一：区间赋值。

  + 对整块打赋值标记，散块暴力处理。

+ 操作二：区间加等差数列。

  + 考虑到相邻位置增量差值相同，考虑差分，对整块打两个标记，分别表示当前块第一个元素应该增加的数和等差数列的公差。第一个标记也相当于是等差数列的首项。散块暴力处理。
  + 等差数列的懒标记也可以累加。

+ 操作三：单点插入。

  + 使用 vector 的插入操作处理。由于这个操作的时间复杂度是 $O(n)$ 的，所以需要使用定期重构来保证时间复杂度。
  + 具体的，当一个块的大小超过某个范围时，就需要将这个块拆分。为方便实现，直接将整个序列重新分块。
  + 因为每个 vector 的大小不同且不断地在更新，所以不能用数组记录每个点对应的块，而是在需要时重新找到对应的块和块内的对应位置。

+ 操作四：区间求和。

  + 维护整块的块内元素总和，散块暴力处理。
 
+ 时间复杂度 $O(n\sqrt n)$。

+ 代码细节还是很多的，下面总结一些容易出错的点。

  + 空间需要开两倍。
  + vector 的下标是从 0 开始的，如果嫌不舒服也可以在最初重构的时候在下标 0 的位置插入一个占位置的数。
  + 赋值标记需要初始化为 -1。虽然实测测试点中并没有赋值为 0 的操作，赋值为 0 也可以通过。
  + 重构、修改散块、查询散块操作之前都需要先处理对应块的懒标记。
  + 赋值操作会覆盖加法操作，整块打赋值操作标记的时候需要将加等差数列的懒标记清空。
  + 在单点插入时也需要更新块内元素总和。

参考代码如下。

```
#include <bits/stdc++.h> //分块 
using namespace std;

namespace Cherry {
	const int N=2e5+10;
	int n,q,B,cnt;
	long long a[N],sum[N],cov[N],al[N],ad[N];
	vector<long long> p[N];
	
	pair<int,int> get_block(int x) { //找到x对应的块和块内位置 
		int cur=1;
		while(cur<=cnt&&(int)p[cur].size()<x) x-=p[cur++].size();
		return make_pair(cur,x-1); //注意vector从0开始 
	}
	void reset(int x) { //处理块内的tag 
		if(cov[x]!=-1) {
			for(int i=0;i<(int)p[x].size();i++) p[x][i]=cov[x];
			cov[x]=-1;
		}
		if(al[x]||ad[x]) {
			for(int i=0;i<(int)p[x].size();i++) p[x][i]+=al[x]+i*ad[x];
			al[x]=ad[x]=0;
		}
	}
	void rebuild() { //重构 
		n=0;
		for(int i=1;i<=cnt;i++) {
			reset(i);
			for(auto j:p[i]) a[++n]=j;
			p[i].clear();
		}
		B=sqrt(n),cnt=(n-1)/B+1;
		for(int i=1;i<=cnt;i++) sum[i]=al[i]=ad[i]=0,cov[i]=-1;
		for(int i=1;i<=n;i++) sum[(i-1)/B+1]+=a[i],p[(i-1)/B+1].push_back(a[i]);
	}
	void change1(int l,int r,long long x) { //区间赋值 
		auto L=get_block(l),R=get_block(r);
		int bl=L.first,pl=L.second,br=R.first,pr=R.second;
		if(bl==br) {
			reset(bl);
			for(int i=pl;i<=pr;i++) sum[bl]+=x-p[bl][i],p[bl][i]=x;
			return;
		}
		reset(bl),reset(br);
		for(int i=pl;i<(int)p[bl].size();i++) sum[bl]+=x-p[bl][i],p[bl][i]=x;
		for(int i=0;i<=pr;i++) sum[br]+=x-p[br][i],p[br][i]=x;
		for(int i=bl+1;i<=br-1;i++) sum[i]=p[i].size()*x,cov[i]=x,al[i]=ad[i]=0; //注意等差数列加法标记会清空 
	}
	void change2(int l,int r,long long x) { //区间加等差数列 
		auto L=get_block(l),R=get_block(r);
		int bl=L.first,pl=L.second,br=R.first,pr=R.second;
		if(bl==br) {
			reset(bl);
			for(int i=pl,j=1;i<=pr;i++,j++) sum[bl]+=j*x,p[bl][i]+=j*x;
			return;
		}
		reset(bl),reset(br);
		int now=1; 
		for(int i=pl;i<(int)p[bl].size();i++,now++) sum[bl]+=now*x,p[bl][i]+=now*x;
		for(int i=bl+1;i<=br-1;now+=p[i].size(),i++) {
			long long start=now*x,end=start+(p[i].size()-1)*x;
			sum[i]+=(start+end)*p[i].size()/2;
			al[i]+=start,ad[i]+=x;
		}
		for(int i=0;i<=pr;i++,now++) sum[br]+=now*x,p[br][i]+=now*x;
	}
	void change3(int x,int y) { //单点插入 
		auto L=get_block(x);
		int bl=L.first,pl=L.second;
		reset(bl),p[bl].insert(p[bl].begin()+pl,y),sum[bl]+=y; 
		if((int)p[bl].size()>10*B) rebuild();
	}
	long long query(int l,int r) { //区间求和 
		auto L=get_block(l),R=get_block(r);
		int bl=L.first,pl=L.second,br=R.first,pr=R.second;
		long long res=0;
		if(bl==br) {
			reset(bl);
			for(int i=pl;i<=pr;i++) res+=p[bl][i];
			return res;
		}
		reset(bl),reset(br);
		for(int i=pl;i<(int)p[bl].size();i++) res+=p[bl][i];
		for(int i=0;i<=pr;i++) res+=p[br][i];
		for(int i=bl+1;i<=br-1;i++) res+=sum[i];
		return res;
	}
	
	int main() {
		scanf("%d%d",&n,&q);
		B=sqrt(n),cnt=(n-1)/B+1;
		for(int i=1;i<=n;i++) {
			scanf("%lld",&a[i]);
			sum[(i-1)/B+1]+=a[i];
			p[(i-1)/B+1].push_back(a[i]);
		}
		for(int i=1;i<=cnt;i++) cov[i]=-1;
		while(q--) {
			int opt,l,r;
			long long x;
			scanf("%d%d%d",&opt,&l,&r);
			if(opt==1) scanf("%lld",&x),change1(l,r,x);
			else if(opt==2) scanf("%lld",&x),change2(l,r,x);
			else if(opt==3) change3(l,r);
			else printf("%lld\n",query(l,r));
		}

		return 0;
	}
}

int main() {
	Cherry::main();

	return 0;
}
```

+ 然而，通过每次都插入在序列的末尾，实测上面的代码会被卡得很惨。考虑对操作三的插入操作，使用 **块状链表** 代替 vector 维护。

  + 只需要使用数组而非 vector 维护块内的元素，重构时也只需要将单块分裂为两块而不用整个序列重构。
  + 注意块长不能设置为 $\sqrt n$，因为如果 $n$ 初始很小而插入操作很多，可能会导致最后块长过小而超时。

+ 时间复杂度 $O(n\sqrt n)$。

参考代码如下。

```
#include <bits/stdc++.h> //分块（块状链表） 
using namespace std;

namespace Cherry {
	const int N=2e5+10,M=1605;
	int n,q,B,cnt;
	
	struct chain { //块状链表 
		int len,nextt;
		long long sum,cov,al,ad;
		long long a[M];
	}p[M];
	pair<int,int> get_block(int x) { //找到x对应的块和块内位置 
		int cur=1;
		while(p[cur].nextt&&p[cur].len<x) x-=p[cur].len,cur=p[cur].nextt;
		return make_pair(cur,x);
	}
	void reset(int x) { //处理块内的tag 
		if(p[x].cov) {
			for(int i=1;i<=p[x].len;i++) p[x].a[i]=p[x].cov;
			p[x].cov=0;
		}
		if(p[x].al||p[x].ad) {
			for(int i=1;i<=p[x].len;i++) p[x].a[i]+=p[x].al+(i-1)*p[x].ad;
			p[x].al=p[x].ad=0;
		}
	}
	void rebuild(int x) { //重构（分裂） 
		cnt++;
		reset(x); //注意要先处理完tag 
		for(int i=B+1;i<=p[x].len;i++) {
			p[cnt].a[++p[cnt].len]=p[x].a[i];
			p[x].sum-=p[x].a[i],p[cnt].sum+=p[x].a[i]; //注意更新总和 
		}
		p[x].len=B,p[cnt].nextt=p[x].nextt,p[x].nextt=cnt;
	}
	void change1(int l,int r,long long x) { //区间赋值 
		auto L=get_block(l),R=get_block(r);
		int bl=L.first,pl=L.second,br=R.first,pr=R.second;
		if(bl==br) {
			reset(bl);
			for(int i=pl;i<=pr;i++) p[bl].sum+=x-p[bl].a[i],p[bl].a[i]=x;
			return;
		}
		reset(bl),reset(br);
		for(int i=pl;i<=p[bl].len;i++) p[bl].sum+=x-p[bl].a[i],p[bl].a[i]=x;
		for(int i=1;i<=pr;i++) p[br].sum+=x-p[br].a[i],p[br].a[i]=x;
		for(int i=p[bl].nextt;i!=br;i=p[i].nextt) p[i].sum=p[i].len*x,p[i].cov=x,p[i].al=p[i].ad=0; //注意等差数列加法标记会清空 
	}
	void change2(int l,int r,long long x) { //区间加等差数列 
		auto L=get_block(l),R=get_block(r);
		int bl=L.first,pl=L.second,br=R.first,pr=R.second;
		if(bl==br) {
			reset(bl);
			for(int i=pl,j=1;i<=pr;i++,j++) p[bl].sum+=j*x,p[bl].a[i]+=j*x;
			return;
		}
		reset(bl),reset(br);
		int now=1; 
		for(int i=pl;i<=p[bl].len;i++,now++) p[bl].sum+=now*x,p[bl].a[i]+=now*x;
		for(int i=p[bl].nextt;i!=br;now+=p[i].len,i=p[i].nextt) {
			long long start=now*x,end=start+(p[i].len-1)*x;
			p[i].sum+=(start+end)*p[i].len/2;
			p[i].al+=start,p[i].ad+=x;
		}
		for(int i=1;i<=pr;i++,now++) p[br].sum+=now*x,p[br].a[i]+=now*x;
	}
	void change3(int x,int y) { //单点插入 
		auto L=get_block(x);
		int bl=L.first,pl=L.second;
		reset(bl);
		p[bl].len++,p[bl].sum+=y;
		for(int i=p[bl].len;i>=pl+1;i--) p[bl].a[i]=p[bl].a[i-1];
		p[bl].a[pl]=y;
		if(p[bl].len>=2*B) rebuild(bl);
	}
	long long query(int l,int r) { //区间求和 
		auto L=get_block(l),R=get_block(r);
		int bl=L.first,pl=L.second,br=R.first,pr=R.second;
		long long res=0;
		if(bl==br) {
			reset(bl);
			for(int i=pl;i<=pr;i++) res+=p[bl].a[i];
			return res;
		}
		reset(bl),reset(br);
		for(int i=pl;i<=p[bl].len;i++) res+=p[bl].a[i];
		for(int i=1;i<=pr;i++) res+=p[br].a[i];
		for(int i=p[bl].nextt;i!=br;i=p[i].nextt) res+=p[i].sum;
		return res;
	}
	
	int main() {
		scanf("%d%d",&n,&q);
		B=800,cnt=(n-1)/B+1;
		for(int i=1;i<=n;i++) {
			int x;
			scanf("%d",&x);
			int bl=(i-1)/B+1;
			p[bl].sum+=x;
			p[bl].a[++p[bl].len]=x;
		}
		for(int i=1;i<=cnt;i++) p[i].nextt=(i<cnt)?i+1:0;
		while(q--) {
			int opt,l,r;
			long long x;
			scanf("%d%d%d",&opt,&l,&r);
			if(opt==1) scanf("%lld",&x),change1(l,r,x);
			else if(opt==2) scanf("%lld",&x),change2(l,r,x);
			else if(opt==3) change3(l,r);
			else printf("%lld\n",query(l,r));
		}

		return 0;
	}
}

int main() {
	Cherry::main();

	return 0;
}
```

附数据生成器。

```
#include <bits/stdc++.h>
using namespace std;

namespace Cherry {
	const int N=15;
	int n,q;
	int main() {
		srand(time(NULL)); 
		n=rand()%N+2,q=rand()%N+1;
		printf("%d %d\n",n,q);
		for(int i=1;i<=n;i++) {
			int x=rand()%N+1;
			printf("%d ",x);
		}
		printf("\n");
		while(q--) {
			int opt,l,r,x;
			opt=rand()%4+1,l=rand()%(n-1)+1,r=rand()%(n-l),x=rand()%N+1;
			printf("%d ",opt);
			if(opt==1) printf("%d %d %d\n",l,l+r,x);
			if(opt==2) printf("%d %d %d\n",l,l+r,x);
			if(opt==3) {
				n++,l=rand()%n+1,x=rand()%N+1;
				printf("%d %d\n",l,x);
			}
			if(opt==4) printf("%d %d\n",l,l+r);
		}
		
		return 0;
	}
}

int main() {
	freopen("data.in","w",stdout);
	Cherry::main();
	
	return 0;
}
```

---

## 作者：Makab (赞：2)

## 题意

实现一个数据结构，维护一个数列，支持如下操作：

1. 区间赋值（推平）；
2. 区间加等差数列；
3. 插入单个元素；
4. 区间求和。

## 题解

考虑使用 Splay。假定你已了解 Splay 基础。

下面分别讨论四种操作的实现。

### 区间赋值

对于目标区间 $[l, r]$，将下标 $l - 1$ 的节点旋到根，$r + 1$ 旋到 $l - 1$ 的（右）儿子。

此时 $r + 1$ 的左儿子即是区间 $[l, r]$ 的根节点，打推平标记即可（`vas`）。

### 区间加等差数列

取目标区间的方法同上。

考虑维护加上的等差数列的首项（`bgv`）和公差（`stp`）。这两者都是可加的。

对于区间的根节点，其点值应当加上 $bgv + stp \times size_{lson}$。

下传时，右儿子的首项增量为 $bgv + stp \times (size_{lson} + 1)$。

### 插入单个元素

将下标 $C - 1$ 的节点旋根，$C$ 旋到 $C - 1$ 的（右）儿子。

新建节点维护插入的值，作为 $C$ 的左儿子即可。

### 区间求和

略去。

## 代码

注意，题目中的 $A_i$ 等于代码实现中的 $a_{i + 1}$。

```cpp
#define rep(i, st, ed) for (int i = (st), _##i = (ed); i <= _##i; ++i)

constexpr int N = 2e5 + 5;

int n, m, op, a[N];

namespace SPLAY {
    #define ls(x) ch[x][0]
    #define rs(x) ch[x][1]

    int root, tot, ch[N][2], fa[N], siz[N];
    ll val[N], sum[N], vas[N], bgv[N], stp[N];
    bitset<N> ass;  // if has assign tag

    bool dir(int x) { return x == rs(fa[x]); }

    void pushup(int x) {
        siz[x] = siz[ls(x)] + 1 + siz[rs(x)];
        sum[x] = sum[ls(x)] + val[x] + sum[rs(x)];
    }

    void mAss(int x, ll v) {
        ass.set(x);
        val[x] = v;
        sum[x] = v * siz[x];
        vas[x] = v;
        bgv[x] = stp[x] = 0;   
    }

    void mAdd(int x, ll tbgv, ll tstp) {
        val[x] += tbgv + tstp * siz[ls(x)];
        sum[x] += tbgv * siz[x] + tstp * (siz[x] - 1) * siz[x] / 2;
        bgv[x] += tbgv; stp[x] += tstp;
    }

    void pushdown(int x) {
        if (ass[x]) {
            if (ls(x)) mAss(ls(x), vas[x]);
            if (rs(x)) mAss(rs(x), vas[x]);
            ass.reset(x);
        }
        if (bgv[x] || stp[x]) {
            if (ls(x)) mAdd(ls(x), bgv[x], stp[x]);
            if (rs(x)) mAdd(rs(x), bgv[x] + stp[x] * (siz[ls(x)] + 1), stp[x]);
            bgv[x] = stp[x] = 0;
        }
    }

    int build(int l, int r, int tfa) {
        if (l > r) return 0;
        int x = ++tot, mid = (l + r) / 2;
        val[x] = a[mid]; siz[x] = 1; fa[x] = tfa;
        ls(x) = build(l, mid - 1, x);
        rs(x) = build(mid + 1, r, x);
        pushup(x);
        return x;
    }

    void rotate(int x) {
        int y = fa[x], z = fa[y]; bool r = dir(x);
        ch[y][r] = ch[x][!r]; ch[x][!r] = y;
        if (z) ch[z][dir(y)] = x;
        if (ch[y][r]) fa[ch[y][r]] = y;
        fa[y] = x; fa[x] = z;
        pushup(y); pushup(x);
    }

    void splay(int x, int tgt) {
        for (; fa[x] != tgt; rotate(x))
            if (fa[fa[x]] != tgt)
                rotate(dir(x) ^ dir(fa[x]) ? x : fa[x]);
        if (!tgt) root = x;
    }

    int kthMinNode(int k) {
        int x = root;
        for (;;) {
            pushdown(x);
            if (ls(x) && k <= siz[ls(x)]) x = ls(x);
            else {
                k -= siz[ls(x)] + 1;
                if (k <= 0) return x;
                x = rs(x);
            }
        }
    }

    void getSeg(int lx, int rx) { splay(lx, 0); splay(rx, lx); }

    void assign() {
        int lp, rp, lx, rx; ll v;
        read(lp, rp, v);
        getSeg(lx = kthMinNode(lp), rx = kthMinNode(rp + 2));
        mAss(ls(rx), v);
        pushup(rx); pushup(lx);
    }

    void arithm() { // Arithmetic sequence
        int lp, rp, lx, rx; ll v;
        read(lp, rp, v);
        getSeg(lx = kthMinNode(lp), rx = kthMinNode(rp + 2));
        mAdd(ls(rx), v, v);
        pushup(rx); pushup(lx);
    }

    void insert() {
        int lp, lx, rx, nn; ll v;
        read(lp, v);
        getSeg(lx = kthMinNode(lp), rx = kthMinNode(lp + 1));
        nn = ls(rx) = ++tot;
        val[nn] = sum[nn] = v;
        siz[nn] = 1;
        fa[nn] = rx;
        pushup(rx); pushup(lx);
    }

    void getSum() {
        int lp, rp, rx;
        read(lp, rp);
        getSeg(kthMinNode(lp), rx = kthMinNode(rp + 2));
        printf("%lld\n", sum[ls(rx)]);
    }
} using namespace SPLAY;

int main() {
    read(n, m);
    rep(i, 2, n + 1) read(a[i]);
    root = build(1, n + 2, 0);
    rep(lol, 1, m) switch (read(op), op) {
    case 1: assign(); break;
    case 2: arithm(); break;
    case 3: insert(); break;
    case 4: getSum(); break;
    }
    return 0;
}

int main() { return SLV::main(); }
```

---

## 作者：toolazy (赞：2)

我是后来人，随机到的，感觉质量算是比较好的平衡树练手题...

...写完之后，发现题解区全是分块，只有一篇 splay！

挖！捡了大漏！那我就来浅浅写个 fhq 吧（

---

# 0. 如何使用平衡树维护序列

## 0.1. 结构...

维护序列，要和 [【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369) 区分开来。后者维护 **元素权值**（中序遍历得到的结果按照元素权值排序），因为维护的是 **集合** 而非 **序列**，查询的是 **是否属于** 而不是 **位置**。

如果序列没有动态插入/删除，那么我们可以选择使用 **线段树** 解决，但问题就在这里。怎么办呢？

虽然线段树不能用了，但是我们可以试着使用线段树的思想，用 **一个节点** 代表 **一段区间**。

于是！我们就很自然地引出了一个思路：维护 **元素下标**（中序遍历得到的结果按照元素下标排序）而不是元素权值。

更细节的，我们这样说：

> 子树即序列，节点即元素。一棵子树维护的序列 = 左子树的序列 + 根节点 + 右子树的序列

也就是说，如果两棵树的中序遍历相同，那么它们所对应的序列就是相同的，两棵树从我们需求的目光来说，**是等价的**。

这也就是为什么，splay 可以拿来维护序列——旋转操作不改变中序遍历。

> 题外话：splay 也因其丰富多彩的操作，被称为 **序列之王**，但是 fhq 胜在码量小，用的 `split` 和 `merge` 根本不用旋转啦~

## 0.2. 操作的细节

序列操作，我们通常有两种：

> 对区间 $[l,r]$ 进行 插入/删除/移动。

这种操作非常简单，直接按照平衡树的说法就好啦~

> 对区间 $[l,r]$ 进行 ... 的修改。

这个操作才是重点！

既然是借鉴线段树的思路，那么对于修改操作，我们也借鉴其 lazy-tag 技术。

这里面有两个要素：

- 修改要素

	修改要素种类有很多，常见的有 三则运算、覆写、反转、翻转 等等一类的，。
    
    针对于编写代码，我会将这些操作分为两类。
    
    - 数值操作
    
    	只改变元素权值而不改变对应元素之间的先后顺序的操作。就像线段树，我们会记录 **节点总和**，我们平衡树也要。但除此之外，因为节点本身也要对应一个元素，所以我们本身还要多记录一个 **元素权值**。
        
        除外，还需要类似地处理 tag，**一定要保证数值在 `pushdown` 之前就正确地更新好**！
        
        以及血泪的提醒：**别忘记同步更新元素权值**！
        
    - 序列操作
    
    	这种操作则是需要改变 **序列顺序** 而非元素，要和数值操作区分！真正的改变 **只在 `pushdown` 之后才更新**！
        
        （这个说法是从主管上来说的。客观来说，实际上因为查询的操作满足交换律，所以序列操作不改变任何数值~）
        
- 区间要素

	因为我们的操作都针对某一段 **局部区间**，所以我们的平衡树要具备有 **拎出子树** 的操作。很幸运，fhq 和 splay 都有 `split` 操作。
    
    非常可惜的是，目前项目中流行的像 红黑树、AVL 等，都不具有该能力，因为是 **强平衡** 的，对于树的形态有极大限制，难以实现该操作。就笔者知道的，除了 fhq 和 splay 两巨头以外就只有 wblt 支持了...
        
好啦~ ~~淡都扯完了~~ 写代码吧！

# 1. 如何优雅地书写代码

就以我个人来说，遇到这种比较复杂的 [平衡树](https://www.luogu.com.cn/problem/P2710) 或者 [线](https://www.luogu.com.cn/problem/P4979)[段](https://www.luogu.com.cn/problem/P2572)[树](https://www.luogu.com.cn/problem/P6588)，都会有相通的编码习惯。来，按照顺序，和我一起写：

## 1.0. 适配合适的 lazy-tag

通常来说，对于差异较大的操作，我们都要为之弄一个 tag。

先来看操作 1：将 $[A,B]$ 中所有元素值更改为 $X$。很简单的区间覆写操作，单走一个 `overwrite` 的 tag 就 OK 啦~

再来看操作 2：将 $[A,B]$ 中所有元素增加一数，第 $A+k$ 位增加 $(k+1) \times X$，也就是加上一个等差数列，并且起始项就是公差，不能有“断崖”。也给弄一个 tag，tag 名字就叫做 `sblzl`，别问（

思考一下，发现 `sblzl` 并不方便编写 `pushdown` 操作。怎么办呢？

通常来说，遇到这个时候，我们就需要转化！简单思考就会有：

> 对于区间 $[A,B]$ 而言，执行一次 `sblzl` 操作，增量为 $X$，实际上等价于为 $[A,A+t-1]$ 执行一次 `sblzl` 操作，增量为 $X$，再为 $[A+t,B]$ 执行一次 `sblzl` 操作，增量为 $X$，再执行一次 **区间加** 操作，增量为 $t\cdot X$。

非常好理解！还有更幸运的事情：无论是 区间加 还是 `sblzl`，都具有结合律！

但是想好了 tag 可还不够！你是否还记得你第一次写 [线段树 2](https://www.luogu.com.cn/problem/P3373) 时的迷茫（

是的！我们还需要考虑 tag 之间的优先级！

简单想想就会有，`overwrite` 优先级一定最高，至于 `add` 或 `sblzl`，它们等级一样，都更弱一些。

什么意思呢？类似于上面那题的先乘后加：

> 当我们要为一个节点附加上新的 `mul` 的 tag 时，我们必须同时更改 `mul` 和 `add`。

> 但当我们要增加一个节点的 `add` 时，我们只要改变 `add` 的 tag 就好了。

> 新 sum = 旧 sum 先 mul 再 add

类似的意思，要这么理解：

> 当我们要改变一个节点的 `overwrite` 的 tag 时，我们必须要清空 `add` 和 `sblzl`。

> 但当我们要增加一个节点的 `add` 或 `sblzl` 时，我们不用改变除本身外的其它 tag。

> 新 sum = 旧 sum 先 overwrite 再 add 最后 sblzl（或者 再 sblzl 最后 add）

那么接下来，我们就可以开始...

## 1.1. 编写 `addtag` 系列函数

现在，我们需要适配三个 tag：

- `overwrite`

```cpp
void addtagOVERWRITE(int v) {
	add = sblzl = 0;
	overwrite = value = v;
	sum = siz * v;
}
```

没什么好说的。

- `add`

```cpp
void addtagADD(int v) {
	add += v;
	value += v;
	sum += siz * v;
}
```

依旧没啥好说。

- `sblzl`

```cpp
void addtagSBLZL(int v) {
	sblzl += v;
	value += (1 + (l ? l -> siz : 0)) * v;
	sum += (1 + siz) * v * siz / 2;
}
```

这里因为是直接加 tag，还没有 `pushdown`，所以我们还没有必要去更新子树。

OK！第一步解决，接下来要处理一下 `push` 系列函数...

## 1.2. `pushup` 和 `pushdown`

- `pushup`（或者叫做 `maintain`）

与 `pushdown` 相反，指从子树推——上来,就是用子树信息来更新自己。当在某些时候，从下往上更新的时候，可能就需要用它。

```cpp
void pushup() {
	sum = (l ? l -> sum : 0) + (r ? r -> sum : 0) + value;
	siz = (l ? l -> siz : 0) + (r ? r -> siz : 0) + 1;
}
```

- `pushdown`

重头戏！

```cpp
void pushdown() {
	if (overwrite ^ FLAG) {
		if (l)
			l -> addtagOVERWRITE(overwrite);
		if (r)
			r -> addtagOVERWRITE(overwrite);
		overwrite = FLAG;
	}
	if (add) {
		if (l)
			l -> addtagADD(add);
		if (r)
			r -> addtagADD(add);
		add = 0;
	}
	if (sblzl) {
		if (l)
			l -> addtagSBLZL(sblzl);
		if (r) {
			r -> addtagADD((1 + (l ? l -> siz : 0)) * sblzl);
			r -> addtagSBLZL(sblzl);
		}
		sblzl = 0;
	}
}
```

可能写法不太好看... 但是通俗易懂！

通过这种方法，按照优先级，将 tag 们一个一个往下推，这也是为什么我要先写 `addtag` 系列函数的原因。

## 1.3. 最后套板子...

没啥好讲的... 直接把我自己的板子放上来吧。

```cpp
node * build(int n) {
	stack<node *> S;
	S.push(new node(-INF));
	while (n --) {
		node * insertNode = new node;
		while (S.top() -> rk > insertNode -> rk) {
			S.top() -> pushup();
			S.pop();
		}
		insertNode -> l = S.top() -> r;
		S.top() -> r = insertNode;
		S.push(insertNode);
	}
	while (S.size() > 1) {
		S.top() -> pushup();
		S.pop();
	}
	node * res = S.top() -> r;
	delete S.top();
	return res;
}

node * merge(node * A, node * B) {
	if (!A || !B)
		return (node *)((long long)A + (long long)B);
	A -> pushdown();
	B -> pushdown();
	if (A -> rk < B -> rk) {
		A -> r = merge(A -> r, B);
		A -> pushup();
		return A;
	}
	B -> l = merge(A, B -> l);
	B -> pushup();
	return B;
}

pair<node *, node *> split(node * rt, int k) {
	if (!rt)
		return {nullptr, nullptr};
	// {[1, k], [k + 1, n]}
	rt -> pushdown();
	int rk = 1 + (rt -> l ? rt -> l -> siz : 0);
	if (rk > k) {
		auto temp = split(rt -> l, k);
		rt -> l = temp.second;
		rt -> pushup();
		return {temp.first, rt};
	}
	auto temp = split(rt -> r, k - rk);
	rt -> r = temp.first;
	rt -> pushup();
	return {rt, temp.second};
}

tuple<node *, node *, node *> split(node * rt, int l, int r) {
	// {[1, l - 1], [l, r], [r + 1, n]}
	auto temp2 = split(rt, r);
	auto temp1 = split(temp2.first, l - 1);
	return {temp1.first, temp1.second, temp2.second};
}
```

## 1.4. `main` 函数里面的各类操作...

这里就不放了，随心嘛~

# 2. 公示代码

拒绝 copy，从你我做起！

公示代码只为观摩学习，禁止复制！（但是我这个代码这么丑，应该也不会有人 copy 罢（

```cpp
#include <iostream>
#include <cstdlib>
#include <stack>
#include <tuple>
using namespace std;

#define int long long

namespace FHQ {
	
	const int FLAG = 1919810, INF = 0x3f3f3f3f3f3f3f3f;

	struct node {
		
		int sum, value, rk, siz, overwrite, add, sblzl;
		node * l, * r;
		
		// tag 优先级:
		// overwrite > add > sblzl
		// 新 = 旧 先overwrite 再add 最后sblzl
		
		node() :
			rk(rand()), siz(1),
			overwrite(FLAG), add(0), sblzl(0),
			l(nullptr), r(nullptr)
		{
			cin >> value;
			sum = value;
		}
		
		node(int rank) :
			rk(rank),
			l(nullptr), r(nullptr)
		{}
		
		void pushup() {
			sum = (l ? l -> sum : 0) + (r ? r -> sum : 0) + value;
			siz = (l ? l -> siz : 0) + (r ? r -> siz : 0) + 1;
		}
		
		void addtagOVERWRITE(int v) {
			add = sblzl = 0;
			overwrite = value = v;
			sum = siz * v;
		}
		
		void addtagADD(int v) {
			add += v;
			value += v;
			sum += siz * v;
		}
		
		void addtagSBLZL(int v) {
			sblzl += v;
			value += (1 + (l ? l -> siz : 0)) * v;
			sum += (1 + siz) * v * siz / 2;
		}
		
		void pushdown() {
			if (overwrite ^ FLAG) {
				if (l)
					l -> addtagOVERWRITE(overwrite);
				if (r)
					r -> addtagOVERWRITE(overwrite);
				overwrite = FLAG;
			}
			if (add) {
				if (l)
					l -> addtagADD(add);
				if (r)
					r -> addtagADD(add);
				add = 0;
			}
			if (sblzl) {
				if (l)
					l -> addtagSBLZL(sblzl);
				if (r) {
					r -> addtagADD((1 + (l ? l -> siz : 0)) * sblzl);
					r -> addtagSBLZL(sblzl);
				}
				sblzl = 0;
			}
		}
		
	};
	
	node * build(int n) {
		stack<node *> S;
		S.push(new node(-INF));
		while (n --) {
			node * insertNode = new node;
			while (S.top() -> rk > insertNode -> rk) {
				S.top() -> pushup();
				S.pop();
			}
			insertNode -> l = S.top() -> r;
			S.top() -> r = insertNode;
			S.push(insertNode);
		}
		while (S.size() > 1) {
			S.top() -> pushup();
			S.pop();
		}
		node * res = S.top() -> r;
		delete S.top();
		return res;
	}
	
	node * merge(node * A, node * B) {
		if (!A || !B)
			return (node *)((long long)A + (long long)B);
		A -> pushdown();
		B -> pushdown();
		if (A -> rk < B -> rk) {
			A -> r = merge(A -> r, B);
			A -> pushup();
			return A;
		}
		B -> l = merge(A, B -> l);
		B -> pushup();
		return B;
	}
	
	pair<node *, node *> split(node * rt, int k) {
		if (!rt)
			return {nullptr, nullptr};
		// {[1, k], [k + 1, n]}
		rt -> pushdown();
		int rk = 1 + (rt -> l ? rt -> l -> siz : 0);
		if (rk > k) {
			auto temp = split(rt -> l, k);
			rt -> l = temp.second;
			rt -> pushup();
			return {temp.first, rt};
		}
		auto temp = split(rt -> r, k - rk);
		rt -> r = temp.first;
		rt -> pushup();
		return {rt, temp.second};
	}
	
	tuple<node *, node *, node *> split(node * rt, int l, int r) {
		// {[1, l - 1], [l, r], [r + 1, n]}
		auto temp2 = split(rt, r);
		auto temp1 = split(temp2.first, l - 1);
		return {temp1.first, temp1.second, temp2.second};
	}
	
}

FHQ :: node * root;

int n, q;

main() {
	ios :: sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	srand(time(nullptr));
	cin >> n >> q;
	root = FHQ :: build(n);
	while (q --) {
		int command;
		cin >> command;
		if (command == 1) {
			int A, B, X;
			cin >> A >> B >> X;
			auto temp = FHQ :: split(root, A, B);
			get<1>(temp) -> addtagOVERWRITE(X);
			root = FHQ :: merge(FHQ :: merge(get<0>(temp), get<1>(temp)), get<2>(temp));
		} else if (command == 2) {
			int A, B, X;
			cin >> A >> B >> X;
			auto temp = FHQ :: split(root, A, B);
			get<1>(temp) -> addtagSBLZL(X);
			root = FHQ :: merge(FHQ :: merge(get<0>(temp), get<1>(temp)), get<2>(temp));
		} else if (command == 3) {
			int C;
			cin >> C;
			auto temp = FHQ :: split(root, C - 1);
			root = FHQ :: merge(FHQ :: merge(temp.first, new FHQ :: node), temp.second);
		} else {
			int A, B;
			cin >> A >> B;
			auto temp = FHQ :: split(root, A, B);
			cout << get<1>(temp) -> sum << '\n';
			root = FHQ :: merge(FHQ :: merge(get<0>(temp), get<1>(temp)), get<2>(temp));
		}
	}
	return 0;
}
```

OK！这里是一枚致力于摸鱼的 OI 菜鸡，更多优质题解请看个人专栏，感谢~

---

## 作者：Computer1828 (赞：2)

一血。

------------

### 提供两种做法：

#### 分块：

区间加法同[P1438](https://www.luogu.com.cn/problem/P1438)，维护一个首项和一个公差 tag，不难发现首项和公差是能相加的。

区间赋值就对每个块维护两个 tag，分别表示这个区间有没有被赋值，赋值的数是多少，注意赋值优先级比加法的高。

插入可以直接暴力插入，然后如果这个块大小太大，就把它拆成两个，具体实现可以用 vector。~~代码咕咕了。~~

#### 平衡树：

加法、赋值同分块做法，插入的时候注意维护平衡即可。

注意：平衡树做法要注意越界的情况，所以初始的建树范围是 $1$ 到 $n+2$，读入时是 $2$ 到 $n+1$；数组一定要开大，所有关于数值的一定要开`long long`。

平衡树代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 500005
using namespace std;
int n,q,cnt,tg1,tg2;//cnt是节点个数，tg1是询问中l在树上的位置，tg2是询问中r在树上的位置 
int rt,son[N][2],fa[N];
/*
tag0:是否赋值
tag1:赋值了多少
tag2:首项
tag3:公差 
*/
ll a[N],sum[N],tag[N][5],si[N];
inline void pushup(int o){
	int l = son[o][0],r = son[o][1];
	si[o] = si[l]+si[r]+1;
	sum[o] = sum[l]+sum[r]+a[o];
}

inline void rotate(int o,int &k){
	int f1 = fa[o],f2 = fa[f1],l = (son[f1][1]==o),r = l^1;
	if(f1 != k) son[f2][son[f2][1] == f1] = o;
	else k = o;
	fa[o] = f2,fa[f1] = o,fa[son[o][r]] = f1;
	son[f1][l] = son[o][r],son[o][r] = f1;
    pushup(f1),pushup(o);
}

inline void splay(int o,int &k){
	while(o != k){
        int f1 = fa[o],f2 = fa[f1];
        if(f1 != k){
            if((son[f2][0]==f1) != (son[f1][0]==o)) rotate(o,k);
			else rotate(f1,k);
        }
        rotate(o,k);
    }
}

inline void cover(int o,ll k){
	sum[o] = si[o]*k;
	a[o] = k;
	tag[o][0] = 1,tag[o][1] = k,tag[o][2] = tag[o][3] = 0;
}

inline void add(int o,ll k1,ll k2){
	int l = son[o][0],r = son[o][1];
	a[o] += k1+si[l]*k2;
	sum[o] += si[o]*k1+(si[o]-1)*si[o]/(1ll*2)*k2;//套用公式sum = n*(n+1)/2，这里单独提出首项 
	tag[o][2] += k1,tag[o][3] += k2;
}

inline void push_down(int o){
	int l = son[o][0],r = son[o][1];
	if(tag[o][0]){//先进行赋值，再进行加减 
		cover(l,tag[o][1]),cover(r,tag[o][1]);
		tag[o][0] = 0;
	}
	if(tag[o][2] || tag[o][3]){
		add(l,tag[o][2],tag[o][3]),add(r,tag[o][2]+(si[l]+1)*tag[o][3],tag[o][3]);
		tag[o][2] = tag[o][3] = 0;
	}
}

inline int gettp(int o,int k){//找到o的位置 
	push_down(o);
	int l = son[o][0],r = son[o][1];
	if(si[l]+1 == k) return o;
	else if(si[l] >= k) return gettp(l,k);
	return gettp(r,k-si[l]-1);
}

inline void split(int l,int r){
	tg1 = gettp(rt,l),tg2 = gettp(rt,r);
	splay(tg1,rt),splay(tg2,son[tg1][1]);
}

inline void build(int l,int r,int f){
	if(l>r) return ;
	int mid = l+r>>1;
	fa[mid] = f,son[f][mid>f] = mid;
	if(l == r){
		si[mid] = 1,sum[mid] = a[mid];
		return ;
	}
	build(l,mid-1,mid),build(mid+1,r,mid);
	pushup(mid);
}
int main(){
	scanf("%d%d",&n,&q);
	for(int i = 2;i<=n+1;++i) scanf("%lld",a+i);
	cnt = n+2,rt = (n+3)>>1;
	build(1,n+2,0);
	int opt,l,r,tp;
	ll k;
	while(q--){
		scanf("%d",&opt);
		if(opt == 3){
			scanf("%d%lld",&tp,&k);
			split(tp,tp+1);
			fa[son[tg2][0] = ++cnt] = tg2;
			sum[cnt] = a[cnt] = k,si[cnt] = 1;
		}else{
			scanf("%d%d",&l,&r);
			split(l,r+2);
			if(opt == 1) scanf("%lld",&k),cover(son[tg2][0],k);
			else if(opt == 2) scanf("%lld",&k),add(son[tg2][0],k,k);
			else printf("%lld\n",sum[son[tg2][0]]);
		}
		pushup(tg2),pushup(tg1);
	}
	return 0;
}
```


---

## 作者：toolong114514 (赞：1)

# P6707 [COCI2010-2011#7] UPIT 题解
## 题面大意
[传送门。](https://www.luogu.com.cn/problem/P6707)

简要用人话说一下操作 2：给序列中的一个区间加上一个首项为 $x$，公差也为 $x$ 的等差数列。
## 解题思路
注意到操作中有区间查询与区间插入，考虑用平衡树维护。

虽然我们可以直接在原序列上区间加等差数列，但是我们可以用更简便的形式维护：将原序列变为差分数组维护。

接下来说明如何在平衡树上维护与查询差分数组。

### 原序列上的区间查询
单个差分数组无法直接在正确的时间复杂度内求出原序列的区间和，我们要引入新的信息。

先假设原序列为 $a$，$a$ 的差分序列为 $a'$。

特别地，我们认为 $a_0=a'_0=0$。

还记得学树状数组维护差分时是怎么处理原序列上的区间和查询吗？

存在下列推导：

$$\sum_{i=l}^{r}a_i=\sum_{i=l}^{r}\sum_{j=1}^{i}a'_j=\sum_{i=l}^{r}(r-i+1)a'_i$$

我们只需维护 $\sum a'_i$ 和 $\sum i\cdot a'_i$ 就可以根据上式做原序列的区间查询了。
### 区间覆盖
记要修改成的数为 $x$，区间为 $[l,r]$。

那么让 $a'_l\gets x-a_{l-1}$，$a'_{l+1},\cdots a'_r\gets 0$，$a'_{r+1}\gets a_{r+1}-x$ 即可。
### 区间加等差数列
记首项与公差为 $x$，区间为 $[l,r]$。

对于 $a'_l,\cdots,a'_r$，全部加上 $x$，并让 $a'_{r+1}\gets a_{r+1}-(r-l+1)x$ 即可。
### 实现细节
本人选择使用 FHQ-Treap 实现平衡树。

为了便于平衡树的分裂与合并，我们要对节点的信息做一些小改动。

$\sum a_i$ 维持原意不变，规定 $\sum i\cdot a'_i$ 中，$i$ 为当前节点的子树所表示的序列的元素排名，并额外维护 $\sum i$。

这样在分裂与合并时，可以容易地推导。

注意到当前节点表示形如 $[1,k]$ 的区间信息时，它就表示原有的 $\sum a'_i$ 和 $\sum i\cdot a'_i$。

插入数字的时候，要插入的是该数与前一项 $a$ 的差，并相应修改后一项的 $a'$。

还有些细节在代码里，就不多说了。
## 参考代码

```cpp
#include<iostream>
#include<cstdlib>
#include<ctime>
using namespace std;
#define int long long
#define lson(pos) treap[pos].lson
#define rson(pos) treap[pos].rson
const int N=2e6+10;
struct node{
	int lson,rson,val,pri,sum1,sum2,sum3,laz1,laz2,siz;
	bool have_laz2;
}treap[N];
int cnt,root;
int build_new(int x){
	cnt++;
	treap[cnt].pri=rand();
	treap[cnt].val=treap[cnt].sum1=treap[cnt].sum2=x;
	treap[cnt].sum3=treap[cnt].siz=1;
	return cnt;
}
void push_up(int pos){
	treap[pos].siz=treap[lson(pos)].siz+treap[rson(pos)].siz+1;
	treap[pos].sum1=treap[lson(pos)].sum1+treap[rson(pos)].sum1+treap[pos].val;
	treap[pos].sum2=0;
	treap[pos].sum2+=treap[lson(pos)].sum2;
	treap[pos].sum2+=(treap[lson(pos)].siz+1)*treap[pos].val;
	treap[pos].sum2+=treap[rson(pos)].sum2+(treap[lson(pos)].siz+1)*treap[rson(pos)].sum1;
	treap[pos].sum3=0;
	treap[pos].sum3+=treap[lson(pos)].sum3;
	treap[pos].sum3+=treap[lson(pos)].siz+1;
	treap[pos].sum3+=treap[rson(pos)].sum3+treap[rson(pos)].siz*(treap[lson(pos)].siz+1);
}
void push_down(int pos){
	if(treap[pos].have_laz2){
		treap[lson(pos)].sum1=treap[lson(pos)].siz*treap[pos].laz2;
		treap[lson(pos)].sum2=treap[lson(pos)].sum3*treap[pos].laz2;
		treap[rson(pos)].sum1=treap[rson(pos)].siz*treap[pos].laz2;
		treap[rson(pos)].sum2=treap[rson(pos)].sum3*treap[pos].laz2;
		treap[lson(pos)].laz1=treap[rson(pos)].laz1=0;
		treap[lson(pos)].laz2=treap[rson(pos)].laz2=treap[pos].laz2;
		treap[lson(pos)].val=treap[rson(pos)].val=treap[pos].laz2;
		treap[lson(pos)].have_laz2=treap[rson(pos)].have_laz2=true;
		treap[pos].have_laz2=false;
	}
	treap[lson(pos)].sum1+=treap[lson(pos)].siz*treap[pos].laz1;
	treap[lson(pos)].sum2+=treap[lson(pos)].sum3*treap[pos].laz1;
	treap[rson(pos)].sum1+=treap[rson(pos)].siz*treap[pos].laz1;
	treap[rson(pos)].sum2+=treap[rson(pos)].sum3*treap[pos].laz1;
	treap[lson(pos)].val+=treap[pos].laz1;treap[rson(pos)].val+=treap[pos].laz1;
	treap[lson(pos)].laz1+=treap[pos].laz1;treap[rson(pos)].laz1+=treap[pos].laz1;
	treap[pos].laz1=0;	
}
void split(int pos,int &l,int &r,int x){
	if(!pos){
		l=r=0;
		return;
	}
	push_down(pos);
	if(treap[lson(pos)].siz+1<=x){
		l=pos;
		split(rson(pos),rson(pos),r,x-treap[lson(pos)].siz-1);	
	}else{
		r=pos;
		split(lson(pos),l,lson(pos),x);
	}
	push_up(pos);
}
int mgr(int l,int r){
	if(!l||!r) return l|r;
	if(treap[l].pri<treap[r].pri){
		push_down(l);
		rson(l)=mgr(rson(l),r);
		push_up(l);
		return l;
	}else{
		push_down(r);
		lson(r)=mgr(l,lson(r));
		push_up(r);
		return r;
	}
}
int rt1,rt2,rt3,rt4,rt5;
void upd1(int ll,int rr,int x){
	if(ll>rr) return;
	split(root,rt1,rt3,rr);
	split(rt1,rt1,rt2,ll-1);
	treap[rt2].val=treap[rt2].laz2=x;
	treap[rt2].have_laz2=true;
	treap[rt2].sum1=treap[rt2].siz*x;
	treap[rt2].sum2=treap[rt2].sum3*x;
	treap[rt2].laz1=0;
	root=mgr(mgr(rt1,rt2),rt3);
}
void upd2(int ll,int rr,int x){
	if(ll>rr) return;
	split(root,rt1,rt2,rr);
	split(rt1,rt1,rt3,ll-1);
	treap[rt3].val+=x;
	treap[rt3].sum1+=treap[rt3].siz*x;
	treap[rt3].sum2+=treap[rt3].sum3*x;
	treap[rt3].laz1+=x;
	root=mgr(mgr(rt1,rt3),rt2);
}
int ask(int ll,int rr){
	if(ll>rr) return 0;
	split(root,rt1,rt3,rr);
	int res1=(rr+1)*treap[rt1].sum1-treap[rt1].sum2;
	split(rt1,rt1,rt2,ll-1);
	int res2=ll*treap[rt1].sum1-treap[rt1].sum2;
	root=mgr(mgr(rt1,rt2),rt3);
	return res1-res2;
}
int n,m;
int a[N];
signed main(){
	srand(time(0));
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		root=mgr(root,build_new(a[i]-a[i-1]));
	}
	while(m--){
		int op,xx,yy,zz;
		cin>>op>>xx>>yy;
		if(op==1){
			cin>>zz;
			int tmp1=ask(xx-1,xx-1),tmp2=ask(yy+1,yy+1);
			upd1(xx,xx,zz-tmp1);
			upd1(xx+1,yy,0);
			upd1(yy+1,yy+1,tmp2-zz);
		}else if(op==2){
			cin>>zz;
			int tmp1=ask(yy+1,yy+1),tmp2=ask(yy,yy);
			upd2(xx,yy,zz);
			upd1(yy+1,yy+1,tmp1-tmp2-(yy-xx+1)*zz);
		}else if(op==3){
			n++;
			int tmp1=ask(xx-1,xx-1),tmp2=ask(xx,xx);
			split(root,rt1,rt2,xx-1);
			root=mgr(mgr(rt1,build_new(yy-tmp1)),rt2);
			upd1(xx+1,xx+1,tmp2-yy);
		}else{
			cout<<ask(xx,yy)<<'\n';
		}
	}
	return 0;
}
```
[本代码可以通过洛谷的评测。](/record/169886405)

Written by [toolong114514](https://www.luogu.com/user/477821) on 2024/8/1.

---

## 作者：Silence_water (赞：1)

题解做法：块状链表。

若只有 1、2、4 操作，即题目 [P1438 无聊的数列](https://www.luogu.com.cn/problem/P1438)，可以用线段树 + 差分轻松维护，也可以用分块实现，这两种做法都是在线的。

新增一个 3 操作，用线段树难以在线实现插入操作，只能离线实现。如果强制在线呢？我们考虑用分块来实现。

操作 1：区间赋值。

散块暴力修改，整块用一个数组 `change` 记改成了啥。由于是赋值，我们将其他整块上的相关信息清空，如区间加的标记等，并且更新区间和 `sum[i]=siz[i]*c`。注意在每次散块赋值前，要类似线段树的 `pushdown`，将标记下放，即把散块所有元素的值通过标记更新。

操作 2：区间加等差数列。

这个等差数列比较特别，它的首项等于公差。如果有个整块一直是进行操作 1 和 2 的，那么整块中的相邻两个元素差是固定的，即最后一次操作 1 后的所有操作 2 对应的公差之和。因此，我们记下公差之和，以及整块中第一个元素值的增量。

操作 3：单点插入。

找到插入点对应的块，如果插入点等于当前序列长度 +1，则归为最后一块。类似暴力，将插入点后所有元素全部后移，然后填上插入的元素。用 vector 可以实现，但常数较大。正因这一部分，我使用了块状链表。

注意插入点后所有元素全部后移只能在该块内实现，若全部更新复杂度无法接受。因此我们对链表上每个元素记录它的原编号（即按输入以及插入顺序），并记录它在当前块中的排名（从前往后数第几个），在进行操作时直接遍历当前块对应链表，将符合修改目的的元素进行修改即可。

考虑极端情况：几乎所有插入全部插入在同一点，那么单块最长可达 $\text{block}+m$。若所有查询都是求序列元素总和，则统计上述情况块时的复杂度不再为 $O(\text{block})$，而是达到了 $O(\text{block}+m)$。上述两种极端操作均匀出现，忽略常数，则总复杂度最高可达 $O\big((\text{block}+m)^2\big)$，无法承受。因此当存在一个整块大小超过 $2\times \text{block}$ 时，我们需要重构，那么最多重构 $m/\text{block}$ 次。

注意：插入前需要下传标记，插入后若重构，需要重新统计每块大小。

操作 4：区间求和。

这个操作就非常 naive 了，仍需注意的是统计前下传标记。

认为 $n$ 和 $m$ 同阶，取 $\text{block}=\sqrt{n+m}$ 左右时，总时间复杂度约为 $O(n\sqrt{n})$。

如果您通过上述文字尚无法理解或不清楚如何实现，可以点击下面链接具体了解。

[具体代码实现及全解释](https://www.luogu.com.cn/paste/tpvdesxj)

其中展示的代码使用语言 C++14 提交，可以在不开启 O2 优化的情况下通过。

---

## 作者：MSqwq (赞：1)

### **题外话：此题建议评紫！！！**  

------------

给一个分块做法吧，虽然是一道很好的 Splay 的练习题，但是我还是要用分块来做  
一个操作一个操作的考虑吧，这种多操作的题，一定要把每一个操作分析清楚，想好怎么处理再来码  
### 第一个操作  
区间赋值嘛，分块的基本操作了，虽然可以用 ODT 这个柯爱的数据结构，但还是用分块的常规操作吧，使用一个 Lazy1 标记来记录整个块的一操作赋值，如果是散块的就直接暴力赋值啦，时间 $O(\log n)$   
### 第二个操作  
也是最难的一个操作，如果想单独练习这个操作的可以去做 [P1438 无聊的数列](https://www.luogu.com.cn/problem/P1438)  是一个不错的题目  
然后回到本题，我是用了两个 Lazy 数组 Lazy2 和 Lazy3 一个用来记录区间要加的数，然后一个用来维护等差数列的公差，为什么要这么干呢，如果只用一个标记，无法记录每个块要具体增加的值，所以用两个标记来处理等差  
对于每一次 pushdown 操作，对于每一个块，从第一个开始，每一次这个数加一个 Lazy2 然后下一个数就要再加上一个公差  
对于每一个散块就直接暴力加，然后改变 Lazy2 和 Lazy3 ，等差数列应该都会吧....就不细讲了，具体的可以再代码里看  
### 第三个操作   
一个影响这个题性质的操作，如果没有插入这个数，那么这个题 80 来行就可以写完了，但是有了这个操作，我们就要用 vector 啊其实也没有啥影响，这个操作也算基础题了，所以也不细讲  
### 第四个操作   
最简单的操作，应该学了飞快的人都会，没啥好说的  
最后此题比较注重细节，所以大家慎重一点写吧，然后附上代码qwq  
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<cmath>
#define ll long long
using namespace std;
const int N=300010,K=600;
int n,m,g;
struct MS{int st,en;}q[K];
bool V[K];
ll a[N],sum[K];
vector<ll>v[K];
ll tmp[N];
ll lazy1[K],lazy2[K],lazy3[K];

void pushdown(int p)
{
	if(lazy1[p])
	{
		for(int i=0;i<v[p].size();i++)
			v[p][i]=lazy1[p];
		lazy1[p]=0;
	}
	if(lazy2[p])
	{
		for(int i=0;i<v[p].size();i++)
		{
			v[p][i]+=lazy2[p];
			lazy2[p]+=lazy3[p];
		}
		lazy2[p]=lazy3[p]=0;
	}
}

void duliu1(int l,int r,ll d)
{
	int now=1,id=0,t=0;
	while(now+v[id].size()<=l)now+=v[id++].size();
	pushdown(id);
	
	while(now<l)now++,t++;
	//int t=l-now;
	//now=l;
	//cout<<t<<endl;
	//cout<<id<<endl;
	for(;t<v[id].size()&&now<=r;now++,t++)
	{
		sum[id]-=v[id][t]-d;
		v[id][t]=d;
	}
	id++;
	while(now+v[id].size()<=r)
	{
		now+=v[id].size();
		sum[id]=d*v[id].size();
		lazy1[id]=d;
		lazy2[id]=lazy3[id]=0;
		id++;
	}
	//cout<<id<<endl;
	t=0;
	pushdown(id);
	for(;now<=r;now++,t++)
	{
		sum[id]+=d-v[id][t];
		v[id][t]=d;	
		//cout<<id<<" "<<t<<endl;	
	}
}

void duliu2(int l,int r,ll x)
{
	int now=1,id=0,t=0;
	ll d=x;
	while(now+v[id].size()<=l)now+=v[id++].size();
	pushdown(id);
	
	while(now<l)now++,t++;
	
	for(;t<v[id].size()&&now<=r;now++,t++,d+=x)
	{
		sum[id]+=d;
		v[id][t]+=d;
	}
	id++;
	while(now+v[id].size()<=r)
	{
		now+=v[id].size();
		sum[id]+=(d+(d+(1ll*v[id].size()-1)*x))*v[id].size()/2;
		lazy2[id]+=d;
		lazy3[id]+=x;
		d+=1ll*v[id].size()*x;
		id++;
	}
	t=0;
	pushdown(id);
	for(;now<=r;now++,d+=x,t++)
	{
		sum[id]+=d;
		v[id][t]+=d;		
	}
}

void build()
{
	int tot=0;
	for(int i=0;v[i].size();i++)
	{
		pushdown(i);
		for(int j=0;j<v[i].size();j++)
			tmp[++tot]=v[i][j];
		v[i].clear();
		sum[i]=0;
	}
	g=sqrt(tot);
	for(int i=1;i<=tot;i++)
	{
		int id=i/g;
		sum[id]+=tmp[i];
		v[id].push_back(tmp[i]);
	}
}

void duliu3(int x,ll y)
{
	int now=1,id=0,t=0;
	while(v[id].size()&&now+v[id].size()<=x)now+=v[id++].size();
	pushdown(id);
	
	while(now<x)now++,t++;
	v[id].push_back(y);
	sum[id]+=y;
	for(int i=v[id].size()-2;i>=t;i--)swap(v[id][i+1],v[id][i]);
	if(v[id].size()>2*g)build();
}

ll duliu4(int l,int r)
{
	ll ans=0;
	int now=1,id=0,t=0;
	while(now+v[id].size()<=l)now+=v[id++].size();
	pushdown(id);
	while(now<l)now++,t++;
	for(;t<v[id].size()&&now<=r;t++,now++)
		ans+=v[id][t];
	//cout<<ans<<endl;
	id++;
	while(now+v[id].size()<=r)now+=v[id].size(),ans+=sum[id++];
	t=0;
	pushdown(id);
	for(;now<=r;t++,now++)ans+=v[id][t];
	return ans;
}

int main()
{
	scanf("%d%d",&n,&m);g=sqrt(n);
	if(g<2)g=2;
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	for(int i=1;i<=n;i++)
	{
		int id=i/g;
		//cout<<id<<" ";
		v[id].push_back(a[i]);
		sum[id]+=a[i];
	}
	for(int i=1;i<=m;i++)
	{
		int op,l;
		ll r,d;
		scanf("%d%d%lld",&op,&l,&r);
	//	cout<<v[1][1]<<" "<<v[2][0]<<endl;
		if(op==1)
		{
			scanf("%lld",&d);
			duliu1(l,r,d);
		}
		//cout<<v[1][1]<<" "<<v[2][0]<<endl;
		if(op==2)
		{
			scanf("%lld",&d);
			duliu2(l,r,d);
		}
		if(op==3)duliu3(l,r);
		if(op==4)printf("%lld\n",duliu4(l,r));
	}
    return 0;
}
/*
5 2
1 2 3 4 5
1 1 5 0
4 1 5

*/
```


---

## 作者：BingBang (赞：1)

本题解提供以平衡树Splay为基础的解决方法。如果未学习Splay平衡树，请务必优先学习。参考链接：[平衡树专题](https://www.luogu.com.cn/blog/BingBang/ping-heng-shu-zhuan-ti)中的Splay讲解部分。  
下面分操作类型解析：  

- 操作1：给定区间$[l,r]$内所有元素值修改为$x$。  
该操作可以通过类似于线段树懒标记的方法解决。这是优先级最高的操作，每次操作时在Splay树上将区间$[l,r]$对应节点集合“压缩”到一颗子树内，并在子树树根处设置懒标记。每次下放懒标记时，直接将懒标记传递给子节点，并更新子节点的值。详见代码。

- 操作2：给定区间$[l,r]$内第$i$个元素增加$x$乘$i$。  
该操作也可以通过懒标记的方法解决。先将Splay树上对应节点集合“压缩”到一颗子树内，随后在子树树根处设置懒标记。此处懒标记需要记录两个值：$add_1,add_2$，分别代表基础增量及排名乘数。处理懒标记的方法稍有不同：对于当前节点，设其左子树大小为$siz_l$，右子树大小为$siz_r$，则当前节点节点值增量为$add_1+add_2 \times (siz_l+1)$。传递懒标记时，对左子节点的$add_1,add_2$值分别增加当前节点的$add_1,add_2$值(原因是两个等差数列对应项的和形成的等差数列是一个以两个原等差数列首项之和为首项，以两个原等差数列公差之和为公差的等差数列)，对应右子节点的$add_1$增加$add_1+add_2 \times (siz_l+1)$，$add_2$增加当前节点的$add_2$(理由相同)。详见代码。

- 操作3：在某一位置插入给定值。  
Splay树基础操作，直接将该位置旋转至根节点，在根节点左子节点处强行插入一个新的节点即可。详见代码。

- 操作4：给定区间$[l,r]$，求区间内元素之和。  
直接将区间$[l,r]$对应节点集“压缩”至一颗子树，取子树树根的$sum$值即可。详见代码

总结一下对于每个节点$x$需要维护的信息：  
节点值$val[x]$  
以$x$为根节点的子树元素值之和$sum[x]$  
修改懒标记$tag[x]$  
增量懒标记$add1[x],add2[x]$  
以$x$为根节点的子树大小$siz[x]$  
Splay平衡树所需维护的其它基本信息。

注意：在懒标记维护时，优先传递$tag$修改懒标记的值。每次赋值$tag$懒标记时，直接清空$add1,add2$。具体可以思考这些运算的优先级。

维护细节：由于需要进行“压缩”操作，故可以在两端各插入一个值$0$(任意值均可)，以便“压缩”端点在边缘位置的区间。注意使用该方法时每次对输入的操作区间两端点各$+1$。

实现代码：
```
#include<bits/stdc++.h>
using namespace std;
#define re register
inline int read(){//快速读入int型 
	register int x=0,f=1;register char ch=getchar();
	while(!(ch>='0'&&ch<='9')&&ch!='-')ch=getchar();
	if(ch=='-')f=-1,ch=getchar();
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+(ch^'0');ch=getchar();
	}
	return x*f;
}
inline void fput(long long x){//快速输出long long型(无换行符)  
	if(x<0)putchar('-'),x=-x;
	if(x>=10)fput(x/10);
	putchar(x%10+'0');
}
#define M 200005
int n,q,tree[M][2],fa[M],siz[M],root,cnt;
long long val[M],sum[M],tag[M],add1[M],add2[M];
//树中第k大的节点增量为add1+add2*k 
inline void pushup(int x){
	siz[x]=siz[tree[x][0]]+siz[tree[x][1]]+1;
	sum[x]=sum[tree[x][0]]+sum[tree[x][1]]+val[x];
	return ;
}
inline void turn(int x){
	re int y=fa[x],z=fa[y];
	re bool c=(tree[y][1]==x);
	if(z)tree[z][tree[z][1]==y]=x;
	fa[x]=z;
	tree[y][c]=tree[x][!c];
	fa[tree[x][!c]]=y;
	tree[x][!c]=y;
	fa[y]=x;
	pushup(y);pushup(x);
	return ;
}
inline void pushtag(int x,long long y){//维护tag标记
	val[x]=y;sum[x]=y*siz[x];
	add1[x]=add2[x]=0;//注意清空add1,add2标记
	tag[x]=y;
	return ;
}
inline long long cal(long long f1,long long d,int num){//计算以f1为首项,d为公差的等差数列的1~num项之和
	return f1*num+d*(1+num)*num/2;
}
inline void pushadd(int x,long long k1,long long k2){//维护add1,add2标记
	val[x]+=k1+k2*(siz[tree[x][0]]+1);
	sum[x]+=cal(k1,k2,siz[x]);
	add1[x]+=k1;add2[x]+=k2;
	return ;
}
inline void pushd(int x){//传递标记
	if(tag[x]){//tag标记优先级较高
		if(tree[x][0])pushtag(tree[x][0],tag[x]);
		if(tree[x][1])pushtag(tree[x][1],tag[x]);
		tag[x]=0;
	}
	if(add1[x]||add2[x]){//传递add1,add2标记
		if(tree[x][0])pushadd(tree[x][0],add1[x],add2[x]);
		if(tree[x][1])pushadd(tree[x][1],add1[x]+add2[x]*(siz[tree[x][0]]+1),add2[x]);
		add1[x]=add2[x]=0;
	}
	return ;
}
void pushdown(int x){
	if(fa[x])pushdown(fa[x]);
	pushd(x);
	return ;
}
inline void splay(int x,int goal){
	pushdown(x);
	while(fa[x]!=goal){
		re int y=fa[x],z=fa[y];
		if(z!=goal){
			((tree[z][0]==y)^(tree[y][0]==x))?turn(x):turn(y);
		}
		turn(x);
	}
	if(!goal)root=x;
	return ;
}
inline void insert(int x){
	if(!root){
		root=cnt=1;
		siz[root]=1;
		val[root]=sum[root]=x;
		return ;
	}
	re int p=root;
	while(pushd(p),tree[p][1])p=tree[p][1];
	tree[p][1]=++cnt;
	fa[cnt]=p;
	siz[cnt]=1;val[cnt]=sum[cnt]=x;
	splay(cnt,0);
	return ;
}
inline int ranks(int x){//查找第x项
	re int p=root;
	while(1){
		pushd(p);
		if(siz[tree[p][0]]>=x){
			p=tree[p][0];
		}else if(siz[tree[p][0]]+1>=x){
			splay(p,0);
			return p;
		}else{
			x-=(siz[tree[p][0]]+1);
			p=tree[p][1];
		}
	}
}
inline int split(int l,int r){//将区间[l,r]压缩并返回压缩后的根节点
	re int x=ranks(l-1),y=ranks(r+1);
	splay(x,0);splay(y,x);
	return tree[y][0];
}
inline void insert2(int c,int x){//在位置c处插入x
	ranks(c);
	pushd(root);
	fa[tree[root][0]]=++cnt;
	tree[cnt][0]=tree[root][0];
	tree[root][0]=cnt;
	fa[cnt]=root;
	siz[cnt]=1;
	val[cnt]=sum[cnt]=x;
	pushup(cnt);pushup(root);
	return ;
}
int main(){
	n=read();q=read();
	insert(0);
	for(re int i=1;i<=n;i++){
		insert(read());
	}
	insert(0);
//	puts("insert done!\n");
	while(q--){
		re int opt=read();
		if(opt==1){
			re int l=read()+1,r=read()+1,x=read();
			re int p=split(l,r);
			pushtag(p,x);
		}else if(opt==2){
			re int l=read()+1,r=read()+1,x=read();
			re int p=split(l,r);
			pushadd(p,0,x);
		}else if(opt==3){
			re int c=read()+1,x=read();
			insert2(c,x);
		}else{
			re int l=read()+1,r=read()+1;
			re int p=split(l,r);
			fput(sum[p]);putchar('\n');
		}
	}
	return 0;
}
```

---

## 作者：f_hxr_ (赞：0)

[传送门](https://www.luogu.com.cn/problem/P6707)

~~随机跳题，居然有一个野生的没人写题解的平衡树板子，捡大漏了。~~

来一篇不用指针的 FHQ Treap 的题解。

题目总共有四个操作，分别是插入，区间求和，区间推平，区间加等差数列。

#### 1. 插入

直接将平衡树**按大小**分裂即可。再把要插入的数放中间，最后合并一下就行。

```cpp
void Split(int p,int xx,int &L,int &R){
	if(!p){L=R=0;return;}
	pushdown(p);
	if(size[ls[p]]+1<=xx){L=p,Split(rs[p],xx-size[ls[p]]-1,rs[p],R);}
	else{R=p,Split(ls[p],xx,L,ls[p]);}
	pushup(p);
}
int Merge(int X,int Y){
	if(!X||!Y)return X|Y;
	pushdown(X);pushdown(Y);
	if(val[X]<=val[Y]){rs[X]=Merge(rs[X],Y);pushup(X);return X;}
	else{ls[Y]=Merge(X,ls[Y]);pushup(Y);return Y;}
}
void Insert(int inx,int xx){
	Split(root,inx-1,A,B);
	root=Merge(Merge(A,New(xx)),B);
}
```

#### 2. 区间求和

也是比较简单的。

我们在平衡树上维护子树权值和。查询的时候将区间对应的子树分裂出来，将树根的权值和输出即可。

```cpp
long long SumRange(int L,int R){
	Split(root,L-1,A,T);
	Split(T,R-L+1,T,B);
	long long ret=sum[T];//sum:子树权值和。 
	root=Merge(A,Merge(T,B));
	return ret;
}
```

#### 3. 推平和区间加等差数列

像 [P1253](https://www.luogu.com.cn/problem/P1253) 一样，推平标记下来时清空所有加标记和以前的推平标记，加标记下来时和推平标记共存，表示先推平再加。

比较重要的是这里的区间加等差数列怎么搞。

我们用“首项”和“公差”两个量来描述一个等差数列。

在代码里，我们用 `addv1`，`addv2` 分别表示首项和公差。

先看怎么打上标记。区间推平不用管。对于原来的加标记，直接让首项和公差对应相加即可。

像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/p924npbg.png)

下面是给结点打上标记的代码：

```cpp
void AddSet(int p,long long xx){
	//任何懒标记，终将入口即化
	dat[p]=xx;setv[p]=xx;sum[p]=(long long)size[p]*xx;
	assert(sum[p]>=0);
	addv1[p]=addv2[p]=0;
}
void AddAdd(int p,long long from,long long dx){
	long long inxp=size[ls[p]]+1;
	dat[p]+=from+(inxp-1)*dx;
	//不需要维护setv
	long end=from+1LL*(size[p]-1)*dx;
	sum[p]+=((from+end)*(long long)size[p])>>1;
	assert(sum[p]>=0);
	//重要的地方：两个等差数列的混合 
	addv1[p]+=from;addv2[p]+=dx;
}
```

然后是标记的下传。推平的标记不重要，重要的是等差数列标记的下传。

假设我们以 $inx$ 为中点将等差数列裂成两半。左边的首项和公差都不变。右边的公差也不变。只有右边的首项变了。

变成多少了？变成了 $\text{首项}+\text{公差} \times (\text{左边的序列的项数}+1)$。

为什么要加一？因为中间还有一个中点 $inx$。

下面是下传标记的代码。

```cpp
void pushdown(int p){
	if(setv[p]!=-1){
		AddSet(ls[p],setv[p]);AddSet(rs[p],setv[p]);
		setv[p]=-1;
	}
	if(addv2[p]!=0){
		AddAdd(ls[p],addv1[p],addv2[p]);
		AddAdd(rs[p],addv1[p]+addv2[p]*(long long)(size[ls[p]]+1),addv2[p]);
		addv1[p]=addv2[p]=0;
	}
}
```

#### 4. 一些细节

+ 注意要随地大小 long long。

+ 空间要开双倍，因为除了原来的数以外还要插入很多数。

下面是[ AC ](https://www.luogu.com.cn/record/155846903)代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int LL;
const int maxn=1e5+7;
int N,Q;
int ls[maxn<<1],rs[maxn<<1];
long long size[maxn<<1],val[maxn<<1],tot;
long long addv1[maxn<<1],addv2[maxn<<1],sum[maxn<<1],dat[maxn<<1],setv[maxn<<1];//首项，公差。 
//dat,setv,sum,addv1,addv2 
int root,A,B,T;
int New(int xx){
	size[++tot]=1;val[tot]=rand();
	dat[tot]=xx;sum[tot]=xx;
	addv1[tot]=addv2[tot]=0;setv[tot]=-1;
	return tot;
}
void pushup(int p){
	sum[0]=size[0]=0;
	sum[p]=sum[ls[p]]+sum[rs[p]]+dat[p];
	size[p]=size[ls[p]]+size[rs[p]]+1;
}
void AddSet(int p,long long xx){
	//任何懒标记，终将入口即化
	dat[p]=xx;setv[p]=xx;sum[p]=(long long)size[p]*xx;
	assert(sum[p]>=0);
	addv1[p]=addv2[p]=0;
}
void AddAdd(int p,long long from,long long dx){
	long long inxp=size[ls[p]]+1;
	dat[p]+=from+(inxp-1)*dx;
	//不需要维护setv
	long end=from+1LL*(size[p]-1)*dx;
	sum[p]+=((from+end)*(long long)size[p])>>1;
	assert(sum[p]>=0);
	//重要的地方：两个等差数列的混合 
	addv1[p]+=from;addv2[p]+=dx;
}
void pushdown(int p){
	if(setv[p]!=-1){
		AddSet(ls[p],setv[p]);AddSet(rs[p],setv[p]);
		setv[p]=-1;
	}
	if(addv2[p]!=0){
		AddAdd(ls[p],addv1[p],addv2[p]);
		AddAdd(rs[p],addv1[p]+addv2[p]*(long long)(size[ls[p]]+1),addv2[p]);
		addv1[p]=addv2[p]=0;
	}
}
void Split(int p,int xx,int &L,int &R){
	if(!p){L=R=0;return;}
	pushdown(p);
	if(size[ls[p]]+1<=xx){L=p,Split(rs[p],xx-size[ls[p]]-1,rs[p],R);}
	else{R=p,Split(ls[p],xx,L,ls[p]);}
	pushup(p);
}
int Merge(int X,int Y){
	if(!X||!Y)return X|Y;
	pushdown(X);pushdown(Y);
	if(val[X]<=val[Y]){rs[X]=Merge(rs[X],Y);pushup(X);return X;}
	else{ls[Y]=Merge(X,ls[Y]);pushup(Y);return Y;}
}
void prt(LL p){if(!p)return;pushdown(p);prt(ls[p]);cout<<dat[p]<<' ';prt(rs[p]);}
void Insert(int inx,int xx){
	Split(root,inx-1,A,B);
	root=Merge(Merge(A,New(xx)),B);
}
void InsertEnd(int xx){root=Merge(root,New(xx));}
void SetRange(int L,int R,int xx){
	Split(root,L-1,A,T);
	Split(T,R-L+1,T,B);
	AddSet(T,xx);
	root=Merge(A,Merge(T,B));
}
void AddRange(int L,int R,long long xx){
	Split(root,L-1,A,T);
	Split(T,R-L+1,T,B);
	AddAdd(T,xx,xx);
	root=Merge(A,Merge(T,B));
}
long long SumRange(int L,int R){
	Split(root,L-1,A,T);
	Split(T,R-L+1,T,B);
	long long ret=sum[T];//sum:子树权值和。 
	root=Merge(A,Merge(T,B));
	return ret;
}
void TEST(){
	//DeBug 
}
int main(){
	srand(time(0));
	//TEST();
	scanf("%d %d",&N,&Q);
	for(int i=1;i<=N;i++){int t;scanf("%d",&t);InsertEnd(t);}
	while(Q--){
		int op,a,b,c;
		scanf("%d %d %d",&op,&a,&b);
		if(op==1){
			scanf("%d",&c);
			SetRange(a,b,c);
		}else if(op==2){
			scanf("%d",&c);
			AddRange(a,b,c);
		}else if(op==3){
			Insert(a,b);
		}else if(op==4){
			long long ret=SumRange(a,b);
			assert(ret>=0);
			printf("%lld\n",ret);
		}
	}
	return 0;
}
```

---

## 作者：A_Sunny_Day (赞：0)

## [COCI2010-2011#7] UPIT 分块

题目链接：[COCI2010-2011#7](https://www.luogu.com.cn/problem/P6707)

---

​	比较常规的分块维护信息的题目。

​	对于操作一，简单的区间覆盖。

​	对于操作二。散块的话暴力修改。整块中增加的值构成一个等差数列，所以整块区间和可以通过等差数列公式进行维护。然后再开两个数组记录这块左端点增加的值和等差数列的差值，这样我们如果查询散块时下传标记可以用这两个数组更新。

​	对于操作二的整块修改及下传标记的局部代码如下：

```cpp
void remake(int k)
{
	ll d=num[k];
	for(Re int i=0;i<vec[k].size();++i)
	{
		if(tag[k]) vec[k][i]=tag[k];//人为规定覆盖的标记优先级较大，类似于乘法标记和加法标记的关系。
		vec[k][i]+=d;
		d+=add[k];
	}
	add[k]=num[k]=tag[k]=0;
}
//---分割线---
//下面是一个不完整的函数，用来更新整块
for(Re int i=le+1;i<ri;++i)
	{
		add[i]+=x;num[i]+=x*(tot+1);//（tot+1）*x为这个块左端增加的值，求法可见完整代码
		sum[i]+=x*(tot*2ll+1+vec[i].size())*vec[i].size()/2;
		tot+=vec[i].size();
	}
```

​	对于操作三，可能是一个重头戏，这也是为什么我们选择分块的原因。我们可以每块维护一个 $\text{vector}$，插入直接在位置所在块的 $\text{vector}$ 中插入，由于一个块长为 $O(\sqrt{n})$，所以插入操作也是 $O(\sqrt{n})$ 的。但是我们知道，如果数据重复插入一个块，我们这种做法会导致某一个块长长度过大从而使得我们分块的时间复杂度退化。所以我们可以在某一块的长度大于 $2\times\sqrt{n}$ 的时候重构整个数组。重构一次复杂度是 $O(n)$ 。但是由于起码插入 $\sqrt{n}$ 个数之后才会重构一次整个数组，所以我们的时间复杂度仍旧是 $O(n\times\sqrt{n})$。

​	重构整个数组的局部代码如下：

```cpp
void rebuild()
{
	int tot=0,len=sqrt(n);
	for(Re int i=1;tot<n;++i)
	{
		remake(i);
		for(Re int j=0;j<vec[i].size();++j)
			a[++tot]=vec[i][j];
		vec[i].clear();
		tag[i]=add[i]=sum[i]=num[i]=0;
	}
	for(Re int i=1;i<=tot;++i)
	{
		vec[(i-1)/len+1].push_back(a[i]);
		sum[(i-1)/len+1]+=a[i];
	}
}
```

​	操作四是一个简单的区间和查询，算是分块的基本操作。如上文所说，散块暴力，顺便维护整块的和就可以在 $O(\sqrt{n})$ 的时间内查询出答案。

​	值得注意的是，这题由于我们使用 $\text{vector}$ 封装一个整块，而且题目中也有插入操作。所以在获取左右端点 $l,r$ 所在块的编号中不能通过预处理然后 $O(1)$ 获取。所以我们遍历每一个块进行获取，这个操作也是 $O(\sqrt{n})$ 的复杂度，并不会超时。

​	那么综上所述，时间复杂度就为 $O(n\times \sqrt{n})$。

​	全部代码如下：

```cpp
#pragma GCC optimize(2) 
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#pragma GCC target("avx","sse2")
#pragma GCC optimize("unroll-loops")
#pragma GCC optimize("inline-small-functions")
//观察可知这题是要我们写一个数据结构
//观察可知，操作一是区间修改，操作二是区间修改，操作三是插入，操作四是区间查询 
//所以有一个结论。如果 a+b==a+b那么a+b==a+b。
//我们可以用这个结论维护分块。 
//然后再用分块维护答案。 
//O(FAST)的分块/se 
#include<bits/stdc++.h>
#define ll long long
#define Re register
using namespace std;
const int MAXN = 1e5+5;
int n,q;
ll a[MAXN<<1],tag[MAXN],add[MAXN],num[MAXN],sum[MAXN];
vector <ll> vec[MAXN];
void Make_Group()
{
	int len=sqrt(n);
	for(Re int i=1;i<=n;++i)
	{
		vec[(i-1)/len+1].push_back(a[i]);
		sum[(i-1)/len+1]+=a[i];
	}
}
void remake(int k)
{
	ll d=num[k];
	for(Re int i=0;i<vec[k].size();++i)
	{
		if(tag[k]) vec[k][i]=tag[k];
		vec[k][i]+=d;
		d+=add[k];
	}
	add[k]=num[k]=tag[k]=0;
}
void rebuild()
{
	int tot=0,len=sqrt(n);
	for(Re int i=1;tot<n;++i)
	{
		remake(i);
		for(Re int j=0;j<vec[i].size();++j)
			a[++tot]=vec[i][j];
		vec[i].clear();
		tag[i]=add[i]=sum[i]=num[i]=0;
	}
	for(Re int i=1;i<=tot;++i)
	{
		vec[(i-1)/len+1].push_back(a[i]);
		sum[(i-1)/len+1]+=a[i];
	}
}
void modify(int l,int r,ll x)
{
	int tot=0,le,ri,L,R;
	for(Re int i=1;tot<n;++i)
	{
		if(tot+vec[i].size()>=l&&tot<l) le=i,L=l-tot-1;
		if(tot+vec[i].size()>=r&&tot<r) ri=i,R=r-tot-1;
		tot+=vec[i].size();
	}
	if(le==ri)
	{
		remake(le);
		for(Re int i=L;i<=R;++i)
		{
			sum[le]+=x-vec[le][i];
			vec[le][i]=x;
		}
	}
	else
	{
		for(Re int i=le+1;i<ri;++i)
		{
			add[i]=0;num[i]=0;
			sum[i]=1ll*vec[i].size()*x;
			tag[i]=x;
		}
		remake(le);remake(ri);
		for(Re int i=L;i<vec[le].size();++i)
			sum[le]+=x-vec[le][i],vec[le][i]=x;
		for(Re int i=0;i<=R;++i)
			sum[ri]+=x-vec[ri][i],vec[ri][i]=x;
	}
}
void upd(int l,int r,ll x)
{
	int tot=0,le,ri,L,R,tmp=0;
	for(Re int i=1;tot<n;++i)
	{
		if(tot+vec[i].size()>=l&&tot<l) le=i,L=l-tot-1;
		if(tot+vec[i].size()>=r&&tot<r) ri=i,R=r-tot-1;
		tot+=vec[i].size();
	}
	tot=vec[le].size()-L;
	if(le==ri)
	{
		remake(le);
		for(Re int i=L;i<=R;++i)
			vec[le][i]+=x*(i-L+1),sum[le]+=x*(i-L+1);
	}
	else
	{
		for(Re int i=le+1;i<ri;++i)
		{
			add[i]+=x;num[i]+=x*(tot+1);
			sum[i]+=x*(tot*2ll+1+vec[i].size())*vec[i].size()/2;
			tot+=vec[i].size();
		}
		remake(le);remake(ri);
		for(Re int i=L;i<vec[le].size();++i)
			vec[le][i]+=x*(i-L+1),sum[le]+=x*(i-L+1);
		for(Re int i=0;i<=R;++i)
			vec[ri][i]+=x*(tot+i+1),sum[ri]+=x*(tot+i+1);
	}
}
void insert(int pos,ll x)
{
	for(Re int i=1;pos;++i)
	{
		if(!vec[i].size())
		{
			vec[i].push_back(x);
			sum[i]+=x;
			break;
		}
		if(pos<=vec[i].size())
		{
			remake(i);
			vector<ll>::iterator it=vec[i].begin()+pos-1;
			vec[i].insert(it,x);
			sum[i]+=x;
			if(vec[i].size()>2*sqrt(n)) rebuild();
			break; 
		}
		pos-=vec[i].size();
	}
}
ll query(int l,int r)
{
	int tot=0,le,ri,L,R;
	for(Re int i=1;tot<n;++i)
	{
		if(tot+vec[i].size()>=l&&tot<l) le=i,L=l-tot-1;
		if(tot+vec[i].size()>=r&&tot<r) ri=i,R=r-tot-1;
		tot+=vec[i].size();
	}
	ll ans=0;
	if(le==ri)
	{
		remake(le);
		for(Re int i=L;i<=R;++i)
			ans+=vec[le][i];
	}
	else
	{
		for(Re int i=le+1;i<ri;++i)
			ans+=sum[i];
		remake(le);remake(ri);
		for(Re int i=L;i<vec[le].size();++i)
			ans+=vec[le][i];
		for(Re int i=0;i<=R;++i)
			ans+=vec[ri][i];
	}
	return ans;
}
int main()
{
	scanf("%d %d",&n,&q);
	for(Re int i=1;i<=n;++i)
		scanf("%d",&a[i]);
	Make_Group();
	while(q--)
	{
		int opt,a,b,c;ll x;
		scanf("%d",&opt);
		if(opt==1)
		{
			scanf("%d %d %lld",&a,&b,&x);
			modify(a,b,x);
		}
		else if(opt==2)
		{
			scanf("%d %d %lld",&a,&b,&x);
			upd(a,b,x);
		}
		else if(opt==3)
		{
			scanf("%d %lld",&c,&x);
			insert(c,x);
			++n;
		}
		else
		{
			scanf("%d %d",&a,&b);
			printf("%lld\n",query(a,b));
		}
	}
	return 0;
}
```





---


# 「Wdsr-2.7」八云蓝自动机 Ⅰ

## 题目背景

**注意：本题题意和 八云蓝自动机Ⅱ 并不一致，请仔细阅读**。

作为八云紫的式神，八云蓝有着不同于其他一般式神的强大的计算能力。也就是说，八云蓝可以用自己的心算能力模拟出一台在现世中的确定性状态自动机。

而这，就是传说中的

$$\textbf{\textsf{「八云蓝自动机」}}$$

当然，尽管八云蓝的计算能力可以用于模拟一台计算机的操作，但是由于其中并没有设定任何的程序，于是可以实现的功能只能通过学习得到。而作为幻想乡的闲者，八云紫教会了蓝有关于数组的知识。一个数组由若干个存储单元组成，每个单元都可以存储一个整数。

而为了检测这种「八云蓝自动机」的可靠性，紫准备了一条非常简单的模拟题，用于测试蓝的心算能力。

然而，尽管蓝可以很快（ $<10^{-9961}s$ ）得出结果，但是八云紫实在是懒得去构造标准答案了。因此，你被钦定计算出这条题目的答案。

## 题目描述

八云蓝自动机维护了一个长度为 $n$ 的序列 $A$ ，每个元素都有一个初始值。同时自动机会支持以下三种操作：

- $\colorbox{f0f0f0}{\verb!1 x k!}$ ：将 $A_x$ 的值修改为 $k$。

- $\colorbox{f0f0f0}{\verb!2 x y!}$ ：交换 $A_x$ 与 $A_y$ 的值。

- $\colorbox{f0f0f0}{\verb!3 x!}$ ：查询 $A_x$ 的值。

为了测试八云蓝自动机的效率，紫需要进行非常非常多次的测试。为了生成每个测试的所有操作，紫构造出了一个长度为 $m$ 的**操作序列** $B$ ， $B$ 中的元素就是八云蓝自动机可以执行的一个操作。

紫会向蓝发起一共 $q$ 次测试。每次测试，紫会给出一个二元组 $(l,r)$ ，含义是让八云蓝自动机**依次**执行 $B_l,B_{l+1},\cdots B_r$ 这一共 $(r-l+1)$ 个操作。当然，紫不希望自动机的输出会太长，于是对于每次测试，你只要告诉她这些操作中所有操作 $3$ 的结果之和即可。注意：任意两次测试并**不会互相干扰**，每次操作结束后数列 $A$ 会回到初始状态。

此外，紫不希望用非常非常大的数字刁难你，于是答案对 $2^{32}$ 取模就行了（即 $\text{unsigned int}$ 自然溢出）。

## 说明/提示

#### 数据范围及约定

$$\def\arraystretch {1.5}\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n,m,q} & \textbf{特殊性质} & \textbf{分值}\cr\hline
1 & 1\le n,m,q\le 10^3 & \text{无} & 10 \cr\hline
2 & \text{无特殊限制} & \text{无操作 1} & 20\cr\hline
3 & \text{无特殊限制} & \text{无操作 2} & 20\cr\hline
4 & \text{无特殊限制} & \text{操作 3 次数}\le 10 & 20 \cr\hline
5 & \text{无特殊限制}& \text{无}& 30 \cr\hline
\end{array}$$

- 对于 $100\%$ 的数据，满足：

  - $1 \le n,m,q \le 2 \times 10 ^ 5$ 。
  
  - $1 \le a_i,k \le 10^9;1 \le op \le 3;1 \le x,y \le n;x \neq y $ 。
  
  - $1 \le l \le r \le m$ 。

## 样例 #1

### 输入

```
10 10
2 3 4 8 7 4 8 4 1 2 
3 5
2 8 7
1 3 6
1 2 10
2 2 4
3 6
2 8 2
1 8 7
3 7
3 10
10
5 10
1 7
8 10
1 10
9 10
2 9
5 5
8 9
1 9
2 7
```

### 输出

```
14
11
10
17
10
8
0
8
15
4
```

# 题解

## 作者：Alex_Wei (赞：25)

> *X. [P7708「Wdsr-2.7」八云蓝自动机Ⅰ](https://www.luogu.com.cn/problem/P7708)。
>
> 摘自 [根号算法](https://www.cnblogs.com/alex-wei/p/sqrt_algorithms.html) Part.3 莫队 例题 *X.*

一道莫队好题。本题最有价值的地方在于对单点修改的转化，以及对交换两个数的处理：维护原来每个位置现在的位置，以及现在每个位置原来的位置。

注意到单点修改并不方便实现，将其转化为交换两个数。对于 $a_x\gets k$，我们新建 $a_c = k$，并将其看做 $a_x$ 与 $a_c$ 交换。这一步非常巧妙，因为它消灭了单点修改这一类麻烦的操作。

多次询问一段区间的操作结果，一般使用莫队实现。因此，考虑区间在伸缩时需要维护哪些信息。为了支持在操作序列最前面加入交换两个数的操作，可以想到维护：

- 序列 $a$ 在操作后的形态。
- $pos_i$ 表示 **原** 位置 $i$ 的 **现** 位置。
- $rev_i$ 表示 **现** 位置 $i$ 的 **原** 位置。
- $add_i$ 表示 **现** 位置 $i$ 上的数被查询了多少次。
- 当右端点右移 $r - 1\to r$ 时：
    - 若第 $r$ 个操作是交换 $x, y$，则交换 $a_x$ 和 $a_y$，$rev_x$ 和 $rev_y$，$pos_{rev_x}$ 和 $pos_{rev_y}$。
    - 若第 $r$ 个操作是查询 $x$，则令 $ans\gets ans + a_x$，$add_x\gets add_x + 1$。
- 当左端点左移 $l+1\to l$ 时：
    - 若第 $l$ 个操作是交换 $x,y$，注意我们相当于 **交换原位置** 上的两个数，因此对答案有影响。先交换 $a_{pos_x}$ 和 $a_{pos_y}$，$rev_{pos_x}$ 和 $rev_{pos_y}$，$pos_x$ 和 $pos_y$。由于交换原位置上的两个数并不影响现位置被查询的数的次数（因为我们已经交换了 $a_{pos_x}$ 和 $a_{pos_y}$，或者说 $a$ 和 $add$ 当中只要交换一个即可描述本次操作，多交换反而会让答案错误），因此答案加上 **交换后** 的 $(a_{pos_x} - a_{pos_y})(add_{pos_x} - add_{pos_y})$，相当于把每个数原来的贡献减掉，加上新的贡献。
    - 若第 $l$ 个操作是查询 $x$，则令 $ans\gets ans + a_{pos_x}$，$add_{pos_x} \gets add_{pos_x} + 1$。

右端点左移和左端点右移的情况分别与上述两种情况相似，仅是符号相反，此处不再赘述。时间复杂度 $\mathcal{O}(n\sqrt n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define uint unsigned int
const int N = 4e5 + 5, B = 444;
int n, m, q, op[N], x[N], y[N], a[N];
uint cur, ans[N], add[N], pos[N], rev[N];
struct query {
	int l, r, blk, id;
	bool operator < (const query &v) const {
		return blk != v.blk ? blk < v.blk : blk & 1 ? r > v.r : r < v.r;
	}
} c[N];
int main() {
	cin >> n >> m;
	for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for(int i = 1; i <= m; i++) {
		scanf("%d %d", &op[i], &x[i]);
		if(op[i] == 1) scanf("%d", &a[++n]), y[i] = n, op[i] = 2;
		else if(op[i] == 2) scanf("%d", &y[i]);
	}
	for(int i = 1; i <= n; i++) pos[i] = rev[i] = i;
	cin >> q;
	for(int i = 1; i <= q; i++) {
		scanf("%d %d", &c[i].l, &c[i].r);
		c[i].blk = c[i].l / B, c[i].id = i;
	}
	sort(c + 1, c + q + 1);
	for(int i = 1, l = 1, r = 0; i <= q; i++) {
		while(r < c[i].r) {
			r++;
			if(op[r] == 2) {
				swap(a[x[r]], a[y[r]]);
				swap(rev[x[r]], rev[y[r]]);
				swap(add[x[r]], add[y[r]]);
				swap(pos[rev[x[r]]], pos[rev[y[r]]]);
			} else add[x[r]]++, cur += a[x[r]];
		}
		while(l > c[i].l) {
			l--;
			if(op[l] == 2) {
				swap(pos[x[l]], pos[y[l]]);
				swap(a[pos[x[l]]], a[pos[y[l]]]);
				swap(rev[pos[x[l]]], rev[pos[y[l]]]);
				cur += add[pos[x[l]]] * (a[pos[x[l]]] - a[pos[y[l]]]);
				cur += add[pos[y[l]]] * (a[pos[y[l]]] - a[pos[x[l]]]);
			} else add[pos[x[l]]]++, cur += a[pos[x[l]]];
		}
		while(r > c[i].r) {
			if(op[r] == 2) {
				swap(a[x[r]], a[y[r]]);
				swap(rev[x[r]], rev[y[r]]);
				swap(add[x[r]], add[y[r]]);
				swap(pos[rev[x[r]]], pos[rev[y[r]]]);
			} else add[x[r]]--, cur -= a[x[r]];
			r--;
		}
		while(l < c[i].l) {
			if(op[l] == 2) {
				cur -= add[pos[x[l]]] * (a[pos[x[l]]] - a[pos[y[l]]]);
				cur -= add[pos[y[l]]] * (a[pos[y[l]]] - a[pos[x[l]]]);
				swap(pos[x[l]], pos[y[l]]);
				swap(a[pos[x[l]]], a[pos[y[l]]]);
				swap(rev[pos[x[l]]], rev[pos[y[l]]]);
			} else add[pos[x[l]]]--, cur -= a[pos[x[l]]];
			l++;
		}
		ans[c[i].id] = cur;
	}
	for(int i = 1; i <= q; i++) printf("%u\n", ans[i]);
	return 0;
}
```

---

## 作者：囧仙 (赞：8)

蓝的一些话：

蓝的本篇题解仅讲述 八云蓝自动机Ⅰ 莫队解法，不讲述 八云蓝自动机Ⅱ 正解以及 八云蓝自动机Ⅰ 部分分做法。

首先珂以发现操作1和操作2同时存在很难处理，考虑一个简单的转化：将所有操作1，即赋值操作转化为操作2。考虑在数组中建立一些额外的项，对于 `1 x k` 操作，我们珂以提前建立一个值为 $k$ 的项 $a_y$，然后将修改操作转化成 `2 x y`，容易证明这两个操作是完全等价的。这样就只有交换操作和单点询问啦。

接下来考虑莫队（相信大家都已经熟练掌握这个算法啦）。假设现在扫到的是区间 $[l,r]$，我们维护区间 $[l,r]$ 所有询问得到的答案之和 $ans$，令交换后的序列为 $a'$，维护序列 $b$ 满足 $a'_i=a_{b_i}$，维护序列 $id$ 满足 $a'_{id_i}=a_i$，维护序列 $c$ 满足 $c_i$ 为区间 $[l,r]$ 询问原序列 $a_i$ 的询问数（例如交换 $a_2$ 与 $a_3$，询问 $a_3$，即为询问原序列 $a_2$）。并对于端点的挪动进行分类讨论：

1. 左端点左挪，即扫到的区间变成了 $[l-1,r]$，这时有两种可能：加入询问操作，设加入的询问操作为 `3 x`，将 $ans$ 加上 $a_x$，并将 $c_x$ 加一；加入交换操作，设加入的交换操作为 `2 x y`，将 $b_{id_x}$ 和 $b_{id_y}$ 交换，交换 $id_x$ 和 $id_y$，更新答案（令原答案为 $ans$，新的答案为 $ans-c_x\times a_x-c_y\times a_y+c_x\times a_y+c_y\times a_x$），并将 $c_x$ 与 $c_y$ 交换。

2. 左端点右挪，即扫到的区间变成了 $[l+1,r]$，这时有两种可能：撤销询问操作，设撤销的询问操作为 `3 x`，将 $ans$ 减去 $a_x$ 即可；撤销交换操作，由于将两个数进行两次交换操作相当于没有进行交换操作，所以设撤销的交换操作为 `2 x y`，将 $b_{id_x}$ 和 $b_{id_y}$ 交换，交换 $id_x$ 和 $id_y$，更新答案（柿子和上面的一样），然后交换 $c_x$ 与 $c_y$ 的值即可。

3. 右端点右挪，即扫到的区间变成了 $[l,r+1]$，交换操作相信大家都会（注意要交换 $id_{b_x}$ 和 $id_{b_y}$），考虑加入询问操作，设加入的询问操作为 `3 x`，由于我们维护了序列 $b$ ，只要将 $ans$ 加上 $a_{b_x}$，然后将 $c_{b_x}$ 加一就行啦。

4. 右端点左挪，即扫到的区间变成了 $[l,r-1]$，相信到这里大家都会了，减一减或是交换一下即可，不再赘述。

然后这道题就做完啦（撒花），时间复杂度为 $O(n+m+q \sqrt{m})$，因为 $n,m,q$ 同级，所以事 $O(m\sqrt{m})$ 的（珂以注意到 $n$ 能开到 $10^7$，但是没什么意义）。



---

## 作者：tobie (赞：1)

wjq是笨蛋，他没想到可以将修改操作化归为交换操作，于是有了这个乱搞做法。

首先我们发现这题执行有关右端点的操作室容易的，而左端点移动可能会造成较大的改变，所以可以考虑使用回滚莫队规避掉左端点的移动。

对于一个询问，我们发现其答案可以表示为 $x+\sum a_ib_i$，其中 $a_i$ 是原数组，$b_i$ 是贡献数组，不难发现对于一段确定的操作序列，其 $x$ 和 $b$ 是相同的。

那怎么求 $x$ 和 $b$ 呢？因为它们和 $a$ 无关，所以我们定义一个数列 $c_i=p+i$，其中 $p\ge 10^9$，那么对 $c_i$ 执行操作，处理一个询问时：

1. 如果 $c_x<p$，那么说明这一位置上的数与原序列没有关系，$x\leftarrow x+c_x$
2. 如果 $c_x\ge p$，说明这一位置上本来应该填 $a_{c_x-p}$，所以 $b_{c_x-p}\leftarrow b_{c_x-p}+1$。

假设左端点所在块将某个询问分为了 $[l,mid]$ 和 $[mid+1,r]$ 两部分，可以对于 $[l,mid]$ 暴力维护 $a$ 数组，$[mid+1,r]$ 部分因为右端点递增所以 $b_i$ 也是容易维护的。

当然为了保证复杂度，需要使用回退数据结构维护 $a$ 数组。

接下来问题转化为如下三个操作：

1. $a_i\leftarrow x$
2. $b_i\leftarrow x$
3. 求 $\sum_{i=1}^n a_ib_i$。

操作次数为 $O(n\sqrt n)$（假定 $n,m,q$ 同阶），而这个问题可以做到 $O(1)$，所以总时间复杂度为 $O(n\sqrt n)$。

喜提最劣解。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
#define uint unsigned int
const int N=200009,B=450,inf=1e9+10;
int n,m,Q;
int op[N],x[N],y[N];
struct Quer{
	int l,r,id;
}q[N];
int block[N];
bool cmp(Quer x,Quer y){return block[x.l]==block[y.l]?x.r<y.r:x.l<y.l;}
uint a[N],b[N],c[N];
uint staa[N<<1][2],topa=0;
uint stab[N<<1][2],topb=0;
uint stac[N<<1][2],topc=0;
uint sum,s0=0;
void change(int pos,uint x,uint *v,uint stav[N<<1][2],uint &topv)
{
//	cout<<pos<<" "<<x<<endl;
	topv++;
	stav[topv][0]=pos;
	stav[topv][1]=v[pos];
	sum-=a[pos]*b[pos];
	v[pos]=x;
	sum+=a[pos]*b[pos];
}
void revoke(int tim,uint *v,uint stav[N<<1][2],uint &topv)
{
	while(topv>tim)
	{
		int pos=stav[topv][0],val=stav[topv][1];
		sum-=a[pos]*b[pos];
		v[pos]=val;
		sum+=a[pos]*b[pos];
		topv--;
	}
}
void swap_(int p,int q,uint *v,uint stav[N<<1][2],uint &topv)
{
//	cout<<"swap"<<endl;
	uint x=v[p],y=v[q];
	change(p,y,v,stav,topv);
//	cout<<"change successful"<<endl;
	change(q,x,v,stav,topv);
}
uint ans[N];
signed main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%u",&a[i]),c[i]=i+inf;
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&op[i],&x[i]);
		if(op[i]!=3) scanf("%d",&y[i]);
	}
	scanf("%d",&Q);
	for(int i=1;i<=m;i++) block[i]=block[i-1]+(i%B==1);
	for(int i=1;i<=Q;i++) scanf("%d%d",&q[i].l,&q[i].r),q[i].id=i;
	sort(q+1,q+Q+1,cmp);
	int r=0;
	for(int i=1;i<=Q;i++)
	{
//		cout<<i<<endl;
		if(i==1||block[q[i].l]!=block[q[i-1].l])
		{
			revoke(0,a,staa,topa);
			revoke(0,b,stab,topb);
			revoke(0,c,stac,topc);
			sum=0;
			for(int j=1;j<=n;j++) c[j]=inf+j;
			r=block[q[i].l]*B+1;
		}
		if(block[q[i].l]==block[q[i].r])
		{
			uint res=0;
			for(int j=q[i].l;j<=q[i].r;j++)
			{
				if(op[j]==1) change(x[j],y[j],c,stac,topc);
				if(op[j]==2) swap_(x[j],y[j],c,stac,topc);
				if(op[j]==3)
				{
					if(c[x[j]]<=inf) res+=c[x[j]];
					else res+=a[c[x[j]]-inf];
				}
			}
			ans[q[i].id]=res;
			revoke(0,c,stac,topc);
		}
		else
		{
			for(;r<=q[i].r;r++)
			{
				if(op[r]==1) change(x[r],y[r],c,stac,topc);
				if(op[r]==2) swap_(x[r],y[r],c,stac,topc);
				if(op[r]==3)
				{
					if(c[x[r]]<=inf) sum+=c[x[r]];
					else
					{
						int pos=c[x[r]]-inf;
						change(pos,b[pos]+1,b,stab,topb);
					}
				}
			}
			uint res=0;
			for(int l=q[i].l;block[l]==block[q[i].l];l++)
			{
				if(op[l]==1) change(x[l],y[l],a,staa,topa);
				if(op[l]==2) swap_(x[l],y[l],a,staa,topa);
				if(op[l]==3) res+=a[x[l]];
			}
			ans[q[i].id]=res+sum;
			revoke(0,a,staa,topa);
		}
	}
	for(int i=1;i<=Q;i++) printf("%u\n",ans[i]);
}
```

---

## 作者：sqrtqwq (赞：1)

选自[窝的莫队学习笔记。](https://www.cnblogs.com/Carousel/p/17999917)

--------

### [八云蓝自动机 Ⅰ](https://www.luogu.com.cn/problem/P7708)

首先我们对于操作 $1$ 转换，我们给 $k$ 单独再开一个点 $a_c$，这样我们就可以把操作 $1$ 转换成操作 $2$ 了。

对于区间问题，我们考虑使用莫队进行维护。

我们记录当前 $a$ 的值，$pos_i$ 表示原来第 $i$ 个位置的数现在在哪里，$rev_i$ 维护现在第 $i$ 个数原来在哪里，和 $add_i$ 现在第 $i$ 个位置上查询了多少次。

首先我们先考虑指针 $r$ 往右移的情况。

1. 这个操作是交换

直接交换 $a_x$ 和 $a_y$，$rev_x$ 和 $rev_y$，$pos_{rev_x}$ 和 $pos_{rev_y}$。

2. 这个操作是查询

直接给 $ans$ 加上 $a_x$，然后 $add_x$ 加 $1$ 即可。

然后我们考虑指针 $l$ 往左移的情况。

1. 这个操作是交换

我们同样先交换 $a_x$ 与 $a_y$，$rev_{pos_x}$ 和 $rev_{pos_y}$ 以及 $pos_x$ 和 $pos_y$。

由于这个操作会影响到后面的查询操作，所以这个操作会改变答案。所以在交换后我们需要加上 $(a_{pos_x} - a_{pos_y}) \times (add_{pos_x} - add_{pos_y})$。

2. 这个操作是查询

和上面一样，$ans$ 加上 $a_{pos_x}$，$add_x$ 加上 $1$。

剩下两种类似，只需改改符号即可。时间复杂度 $O(n\sqrt n)$。

最后要注意本题对 $2^{32}$ 取模。

[code](https://www.luogu.com.cn/paste/wv6ofdya)

---

## 作者：IdnadRev (赞：0)

比较基础的题，考察细节的处理。

1 操作显然可以直接转化为 2 操作，这样方便很多。

考虑莫队，令 $p_x$ 为 $x$ 对应之前哪个位置，$q_x$ 为之前位置为 $x$ 的位置现在移动到了哪里，$t_x$ 为目前的 $x$ 位置被询问过多少次。

移动左端点，操作是交换：

- 交换之前位置为 $x,y$ 的两个位置的权值，更新这两个位置的 $p,q$，即：

`swap(a[q[x]],a[q[y]]);
swap(p[q[x]],p[q[y]]);
swap(q[x],q[y]);`

- 统计因为交换而造成的答案变化量：

`res+=(a[q[x]]-a[q[y]])*(t[q[x]]-t[q[y]]);`

（如果是删除要把顺序换一下）

移动左端点，操作是查询：

- 统计答案，更新该点被询问的次数：

`res+=a[q[x]];
tot[q[x]+=1/-1;`

移动右端点，操作是交换：

`swap(a[x],a[y]);
swap(p[x],p[y]);
swap(q[p[x]],q[p[y]]);
swap(tot[x],tot[y]);`

移动右端点，操作是查询：

`res+=a[x];
tot[x]+=1/-1;`

时间复杂度 $O(n\sqrt n)$。

```
#include<stdio.h>
#include<algorithm>
using namespace std;
const int maxn=200005,S=450;
int n,m,Q,T;
int a[maxn<<1],oo[maxn],xx[maxn],yy[maxn],bel[maxn],bl[maxn],br[maxn],p[maxn<<1],q[maxn<<1],tot[maxn<<1];
//p nowpos->oldpos q oldpos->nowpos
unsigned int now;
unsigned int ans[maxn];
struct node {
	int x,y,id;
} c[maxn];
inline int cmp(node a,node b) {
	return bel[a.x]^bel[b.x]? a.x<b.x:a.y<b.y;
}
void lmodify(int t,int v) {
	int o=oo[t],x=xx[t],y=yy[t];
	if(o==2) {
		if(v==1)
			swap(a[q[x]],a[q[y]]),swap(p[q[x]],p[q[y]]),swap(q[x],q[y]);
		now+=(unsigned int)v*(a[q[x]]-a[q[y]])*(tot[q[x]]-tot[q[y]]);
		if(v==-1)
			swap(a[q[x]],a[q[y]]),swap(p[q[x]],p[q[y]]),swap(q[x],q[y]);
	}
	if(o==3)
		now+=v*a[q[x]],tot[q[x]]+=v;
}
void rmodify(int t,int v) {
	int o=oo[t],x=xx[t],y=yy[t];
	if(o==2)
		swap(a[x],a[y]),swap(p[x],p[y]),swap(q[p[x]],q[p[y]]),swap(tot[x],tot[y]);
	if(o==3)
		now+=v*a[x],tot[x]+=v;
}
int main() {
	scanf("%d%d",&n,&m),T=m/S;
	for(int i=1; i<=T; i++)
		bl[i]=br[i-1]+1,br[i]=i*S;
	if(br[T]<m)
		T++,bl[T]=br[T-1]+1,br[T]=m;
	for(int i=1; i<=T; i++)
		for(int j=bl[i]; j<=br[i]; j++)
			bel[j]=i;
	for(int i=1; i<=n; i++)
		scanf("%d",&a[i]),p[i]=q[i]=i;
	for(int i=1; i<=m; i++) {
		scanf("%d%d",&oo[i],&xx[i]);
		if(oo[i]!=3)
			scanf("%d",&yy[i]);
		if(oo[i]==1)
			n++,p[n]=q[n]=n,a[n]=yy[i],oo[i]=2,yy[i]=n;
	}
	scanf("%d",&Q);
	for(int i=1; i<=Q; i++)
		scanf("%d%d",&c[i].x,&c[i].y),c[i].id=i;
	sort(c+1,c+1+Q,cmp);
	int x=1,y=0;
	for(int i=1; i<=Q; i++) {
		int qx=c[i].x,qy=c[i].y,qid=c[i].id;
		while(x>qx)
			x--,lmodify(x,1);
		while(y<qy)
			y++,rmodify(y,1);
		while(x<qx)
			lmodify(x,-1),x++;
		while(y>qy)
			rmodify(y,-1),y--;
		ans[qid]=now;
	}
	for(int i=1; i<=Q; i++)
		printf("%u\n",ans[i]);
	return 0;
}
```

---


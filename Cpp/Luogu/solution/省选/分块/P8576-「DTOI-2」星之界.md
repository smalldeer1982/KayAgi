# 「DTOI-2」星之界

## 题目背景

>天仙开碧落，银界失黄昏。

## 题目描述

夜空中的星星组成了一个序列 $a$，序列中的第 $i$ 个数表示第 $i$ 颗星星的亮度。

现在，作为星之眷顾者的你，拥有两种方式来操作星星。

- 操作一：输入格式为 $\texttt{1 l r x y}$，表示将 $[l,r]$ 内所有亮为 $x$ 的星星的亮度改为 $y$。
 
- 操作二：输入格式为 $\texttt{2 l r}$，表示输出 $ \prod\limits_{i = l}^{r} C_{\sum_{j = l}^{i}a_j}^{a_i}\ \bmod 998244353 $ 的值。

## 说明/提示

**样例解释#1**

直接按照题意计算可得。



| $\textbf{Subtask}$ | $n \le$ | $q \le$ | 特殊性质 | 总分数 |
| :----------: | :---------------: | :---------------: | :-------------: | :---: |
| $1$ | $10$ | $15$ | 无 | $5$ |
| $2$ | $10^3$ | $10^3$ | 无 | $10$ |
| $3$ | $5\times 10^4$ | $5\times 10^4$ | 只有操作 $2$ | $10$ |
| $4$ | $5\times 10^4$ | $5\times 10^4$ | 只有一次操作 $2$ | $10$ |
| $5$ | $5\times 10^4$ | $5\times 10^4$ | 无 | $21$ |
| $6$ | $10^5$ | $10^5$ | $\sum a[i] \le 5\times 10^5$ | $14$ |
| $7$ | $10^5$ | $10^5$ | 无 | $30$ |

对于 $100\%$ 的数据，$1 \le n,q,a_i \le 10^5$。有 $1 \le l,r\le n;1 \le x,y\le 10^5$。

任意时刻 $\sum a$ 不会超过 $10^7$。

## 样例 #1

### 输入

```
3 3
2 3 5
2 1 3
1 1 3 2 4
2 1 2```

### 输出

```
2520
35```

## 样例 #2

### 输入

```
5 5
4 6 7 8 9
1 2 4 9 8
1 3 5 8 9
2 3 5
2 1 3
2 1 2```

### 输出

```
412013881
4084080
210```

# 题解

## 作者：Daidly (赞：7)

这题卡了我好久，分块题一般极其难调，细节巨多。

---

首先询问的式子可以化简：

$$
\prod_{i=l}^rC_{\sum_{j=l}^ra_j}^{a_i}=\frac{sum(l,r)!}{\prod_{i=l}^r(a_i!)}
$$

需要维护区间求和，区间阶乘之积，由于 $\sum a_i\leq 10^7$，可以先预处理 $10^7$ 以内的阶乘和 $10^5$ 以内的阶乘的逆元。

考虑分块，如何支持区间值的改变？对于每一块内值相同的放在一个集合中。可以发现经过一些操作之后，集合的个数会越来越多，也就是有初始值不同的集合合并。

用并查集维护初始值相同的集合，记 $f_i$ 表示下标为 $i$ 的元素的集合编号，我们可以建立一个虚点作为集合的代表，也可以直接使用块内第一个元素，这里使用第二种，较为简便。

对于修改操作，散块直接更新块内值，然后统计修改重构。整块我们考虑合并（若块内有 $x$）：若块内无 $y$，则直接将块内第一个元素的值改为 $y$，并把“块内第一个值为 $y$ 的下标”更新成 $x$（因为此时块内值为 $x$ 的全员变成了 $y$）；若块内有 $y$，我们需要把代表 $x$ 的点的父亲设为第一个 $y$。此外，还需要开个桶维护块内元素个数，维护块内和，已经块内阶乘之积的逆元。**最后，清空有关 $x$ 的桶和第一个 $x$ 出现的下标（清空块内有关 $x$ 的数据）**。

**这类题很容易某些东西忘记更新或忘记清空，一定要注意。**

对于询问操作，散块暴力获取值统计，整块利用维护的值计算即可。

有点卡空间，用 `int`，但如果一直卡可能是函数出了问题（例如没清空导致栈空间爆掉）。

代码如下：

```cpp

#include<bits/stdc++.h>
using namespace std;

inline int read(){
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c<='9'&&c>='0'){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}

void print(int x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)print(x/10);
	putchar(x%10^48);
}

const int N=1e5+5,SUM=1e7+5,mod=998244353,S=330;

int qpow(int a,int b){
	int ans=1;
	while(b){
		if(b&1)ans=1ll*ans*a%mod;
		a=1ll*a*a%mod;
		b>>=1;
	}
	return ans;
}

int n,q,a[N],f[N],bel[N];
int fac[SUM],invfac[N];
int mul_invfac[N/S+5],R[N/S+5],sum[N/S+5],invpow[N][S+5],facpow[N][S+5];
int fir[N/S+5][N],t[N/S+5][N];

inline int find(int x){
	return (x==f[x])?x:f[x]=find(f[x]);
}

inline void init(int maxn){
	fac[0]=invfac[0]=1;
	for(int i=1;i<=maxn;++i)fac[i]=1ll*fac[i-1]*i%mod;//1e7 
	invfac[N-5]=qpow(fac[N-5],mod-2);
	for(int i=N-6;i>=1;--i)invfac[i]=1ll*invfac[i+1]*(i+1)%mod;//1e5即可 
	for(int i=0;i<=N-5;++i){//预处理，可以去掉log 
		invpow[i][0]=facpow[i][0]=1;
		for(int j=1;j<=S;++j){
			invpow[i][j]=1ll*invpow[i][j-1]*invfac[i]%mod;
			facpow[i][j]=1ll*facpow[i][j-1]*fac[i]%mod;
		}
	}
}

inline void remake(int k){
	mul_invfac[k]=1,sum[k]=0;
	for(int i=R[k-1]+1;i<=R[k];++i){
		t[k][a[i]]++;
		if(t[k][a[i]]==1)fir[k][a[i]]=i;
		f[i]=fir[k][a[i]];
		sum[k]+=a[i];
		mul_invfac[k]=1ll*mul_invfac[k]*invfac[a[i]]%mod;
	}
}

void update(int k){
	for(int i=R[k-1]+1;i<=R[k];++i){
		a[i]=a[find(i)];
		fir[k][a[i]]=t[k][a[i]]=0;//清空 
	}
}

inline void modify(int l,int r,int x,int y){
	if(bel[l]==bel[r]){
		update(bel[l]);//判断散块前要先获取a[i]的真实值 
		for(int i=l;i<=r;++i)if(a[i]==x)a[i]=y;
		remake(bel[l]);//重构此块 
		return;
	}
	if(l!=R[bel[l]-1]+1){
		update(bel[l]);
		for(int i=l;i<=R[bel[l]];++i)if(a[i]==x)a[i]=y;
		remake(bel[l]);
		l=R[bel[l]]+1;
	}
	if(r!=R[bel[r]]){
		update(bel[r]);
		for(int i=R[bel[r]-1]+1;i<=r;++i)if(a[i]==x)a[i]=y;
		remake(bel[r]);
		r=R[bel[r]-1];
	}
	for(int i=bel[l];i<=bel[r];++i){
		if(fir[i][x]){
			if(fir[i][y])f[fir[i][x]]=fir[i][y];//合并x和y 
			else fir[i][y]=fir[i][x],a[fir[i][x]]=y;//直接改 
			sum[i]+=(y-x)*t[i][x];
			mul_invfac[i]=1ll*mul_invfac[i]*facpow[x][t[i][x]]%mod*invpow[y][t[i][x]]%mod;
			//这里注意由于维护的是逆元，所以乘x的阶乘和y阶乘的逆元 
			t[i][y]+=t[i][x];
			t[i][x]=fir[i][x]=0;//这里一定要注意两个都要清空 
		}
	}
}

inline int qry(int l,int r){
	int Sum=0,invMul=1,tmp;
	if(bel[l]==bel[r]){
		for(int i=l;i<=r;++i)a[i]=a[find(i)],Sum+=a[i],invMul=1ll*invMul*invfac[a[i]]%mod;
		return 1ll*fac[Sum]*invMul%mod;
	}
	if(l!=R[bel[l]-1]+1){
		for(int i=l;i<=R[bel[l]];++i)a[i]=a[find(i)],Sum+=a[i],invMul=1ll*invMul*invfac[a[i]]%mod;
		l=R[bel[l]]+1;
	}
	if(r!=R[bel[r]]){
		for(int i=R[bel[r]-1]+1;i<=r;++i)a[i]=a[find(i)],Sum+=a[i],invMul=1ll*invMul*invfac[a[i]]%mod;
		r=R[bel[r]-1];
	}
	for(int i=bel[l];i<=bel[r];++i){
		Sum+=sum[i],invMul=1ll*invMul*mul_invfac[i]%mod;
	}
	return 1ll*fac[Sum]*invMul%mod;
}

signed main(){
	n=read(),q=read();
	init(1e7);
	for(int i=1;i<=n;++i)a[i]=read();
	for(int i=1;i<=n;++i)bel[i]=(i+S-1)/S;
	for(int i=1;i<=n/S;++i)R[i]=i*S;
	if(n%S)R[bel[n]]=n;
	for(int i=1;i<=bel[n];++i)remake(i);
	int opt,l,r,x,y;
	while(q--){
		opt=read(),l=read(),r=read();
		if(opt==1){
			x=read(),y=read();
			if(x==y)continue;//特判，否则在整块修改时会清空x 
			modify(l,r,x,y);
		}else print(qry(l,r)),puts("");
	}
	return 0;
}

```

如果觉得有帮助可以点个赞，谢谢。

---

## 作者：云浅知处 (赞：5)

这题和 [SNOI2022 军队](https://www.luogu.com.cn/problem/P8360) 一模一样的啊，不知道为什么公开赛出了这样一道题（甚至比那题要简单些）~~说起来这场的 t3 也是个三维偏序板子~~

首先有 $\prod_{i=1}^n\binom{a_i}{\sum_{j=1}^ia_j}=\frac{(\sum a_i)!}{\prod a_i!}$，因此只需要维护区间 $\sum a_i$ 与 $\prod a_i!$。

考虑分块，对每一种相同值的元素，我们找到这种元素第一次出现的位置，并从后面所有改元素出现的位置向第一次出现的位置连边。那么每种颜色会形成一个树形结构。

同时，我们记录 $f_{i,j}$（$1\le i\le \sqrt{n},1\le j\le 10^5$）表示第 $i$ 块中第 $j$ 中颜色的树根位置。对于修改 $x\to y$，若 $y$ 不存在那么直接将 $x$ 树根位置的颜色修改为 $y$ 即可；否则从 $x$ 的树根向 $y$ 的树根连边。（注意同时需要修改 $f$ 数组）

修改时需要处理散块暴力重构的问题，此时大部分题解采用了并查集，但该并查集不可能按秩合并，导致时间复杂度至少为 $O(n\sqrt{n}\log n)$（而大部分题解并未提及这一点）。实际上，我们可以直接在这一块的森林上自顶向下 $\text{DFS}$，即可规避并查集。

由于总共只会有 $O(n\sqrt{n})$ 次连边，并且每次重构都会删除与访问边数相同的边，因此总的复杂度恰为 $O(n\sqrt{n})$。这个复杂度是均摊的，单次修改的复杂度可以很高。

这样做的时空复杂度均为 $O(n\sqrt{n})$，但我们有办法将空间复杂度优化至 $O(n)$。注意到每一块对答案的贡献可以简单合并，因此我们可以离线下来，单独处理每一块的修改与询问，最后统一输出即可。


---

## 作者：enucai (赞：5)

## Description

给你一个长度为 $n$ 的序列，$q$ 次操作，操作有以下两种：

- 操作一：`1 l r x y`，将 $[l,r]$ 内的所有值为 $x$ 的数改为 $y$。

- 操作二：`2 l r`，让你求出 $\prod\limits_{i=l}^rC_{\sum_{j=l}^ia_j}^{a_i}\bmod 998244353$。

$1\le n,q,a_i,x,y\le 10^5$。任意时刻 $\sum a\le 10^7$。

## Analysis

以下小块指分块中不完整的块，大块指分块中完整的块。

按块大小为 $\sqrt n$ 对序列分块，每个块内开一个桶维护元素。由于值域与 $n$ 同阶，故桶的空间是 $O(n\sqrt n)$ 的。

先来化简柿子，不难得到 $\prod\limits_{i=l}^rC_{\sum_{j=l}^ia_j}^{a_i}=\frac{(\sum_{i=l}^ra_i)!}{\prod_{i=l}^ra_i!}$。

考虑如何合并两个块询问的答案：只需要将两个块的答案相乘，然后设两个块的和分别为 $x$ 与 $y$，那么答案再乘上 $\frac{(x+y)!}{x!y!}$ 即可。

故每一块只需要维护两个信息：区间和 与 区间每个数阶乘的积。

考虑一次修改操作，小块的暴力修改。大块的直接改桶信息。假设有 $\alpha$ 个 $x$ 要改为 $y$，那么区间和 $+\alpha(y-x)$，区间答案乘 $(x!)^\alpha$，除 $(y!)^\alpha$，再除去原来区间和的阶乘，乘上新的区间和的阶乘即可。由于 $\alpha\le\sqrt n$，故只要与预处理出 $10^5$ 及以内数的阶乘的 $1$ 到 $\sqrt n$ 次幂与他们的逆元，就能在 $O(\sqrt n)$ 的复杂度内完成一次操作。

此处用到的另一个较为巧妙的技巧是代表元。发现小块暴力求解是需要获取他的真实的值。我们另一个块中一个值的代表元是块中这个数第一个出现的位置。每次整块修改时 $x\to y$ 只要将 $x$ 的代表元指向 $y$ 的代表元即可，若 $y$ 没有代表元，则直接修改 $x$ 代表元位置的值即可。

提醒：

- 本题卡空间，请合理使用 `long long` 类型变量。

- $x$ 可以等于 $y$，在 $x=y$ 时不用操作，不然会把 $x$ 的 $cnt$ 变成 $0$！ 

## Code

```cpp
const int M=10000010;
const int N=100010;
const int K=330;
template<int P>
class mod_int{
  using Z=mod_int;
private:
  static int mo(int x){return x<0?x+P:x;}
public:
  int x;
  int val()const{return x;}
  mod_int():x(0){}
  template<class T>mod_int(const T&x_):x(x_>=0&&x_<P?static_cast<int>(x_):mo(static_cast<int>(x_%P))){}
  bool operator==(const Z&rhs)const{return x==rhs.x;}
  bool operator!=(const Z&rhs)const{return x!=rhs.x;}
  Z operator-()const{return Z(x?P-x:0);}
  Z pow(long long k)const{Z res=1,t=*this;while(k){if(k&1)res*=t;if(k>>=1)t*=t;}return res;}
  Z&operator++(){x<P-1?++x:x=0;return *this;}
  Z&operator--(){x?--x:x=P-1;return *this;}
  Z operator++(int){Z ret=x;x<P-1?++x:x=0;return ret;}
  Z operator--(int){Z ret=x;x?--x:x=P-1;return ret;}
  Z inv()const{return pow(P-2);}
  Z&operator+=(const Z&rhs){(x+=rhs.x)>=P&&(x-=P);return *this;}
  Z&operator-=(const Z&rhs){(x-=rhs.x)<0&&(x+=P);return *this;}
  Z&operator*=(const Z&rhs){x=1ULL*x*rhs.x%P;return *this;}
  Z&operator/=(const Z&rhs){return *this*=rhs.inv();}
#define setO(T,o) friend T operator o(const Z&lhs,const Z&rhs){Z res=lhs;return res o##=rhs;}
  setO(Z,+)setO(Z,-)setO(Z,*)setO(Z,/)
#undef setO
};
const int P=998244353;
using Z=mod_int<P>;
Z fac[M],ivf[M],facpw[N][K],ivfpw[N][K];
void prework(){
  fac[0]=1; rep(i,1,M-1) fac[i]=fac[i-1]*i;
  ivf[M-1]=fac[M-1].inv(); per(i,M-1,1) ivf[i-1]=ivf[i]*i;
  rep(i,0,N-1){
    facpw[i][0]=1;
    rep(j,1,K-1) facpw[i][j]=facpw[i][j-1]*fac[i];
    ivfpw[i][0]=1;
    rep(j,1,K-1) ivfpw[i][j]=ivfpw[i][j-1]*ivf[i];
  }
}
int n,q,bs,a[N],L[K],R[K],sum[K],sz[K],id[N],tot,fa[N],val[N];
Z pi[K];
struct data{
  int head,cnt;
}t[K][N];
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
void init(int x){
  pi[x]=1,sum[x]=0;
  rep(i,L[x],R[x]){
    if(t[x][a[i]].head) fa[i]=t[x][a[i]].head,t[x][a[i]].cnt++;
    else fa[i]=i,t[x][a[i]].head=i,t[x][a[i]].cnt=1,val[i]=a[i];
    sum[x]+=a[i],pi[x]*=ivf[a[i]];
  }
}
void small(int x,int l,int r,int from,int to){
  rep(i,L[x],R[x]) a[i]=val[find(i)],t[x][a[i]].head=t[x][a[i]].cnt=0;
  rep(i,L[x],R[x]) fa[i]=0;
  rep(i,l,r) if(a[i]==from) a[i]=to;
  init(x);
}
void big(int x,int from,int to){
  sum[x]+=t[x][from].cnt*(to-from),pi[x]*=facpw[from][t[x][from].cnt]*ivfpw[to][t[x][from].cnt];
  t[x][to].cnt+=t[x][from].cnt;
  if(t[x][to].head) fa[t[x][from].head]=t[x][to].head;
  else t[x][to].head=t[x][from].head,val[t[x][from].head]=to;
  t[x][from].head=t[x][from].cnt=0;
}
void upd(int l,int r,int x,int y){
  if(id[l]==id[r]){
    small(id[l],l,r,x,y);
  }else{
    int ll,rr;
    if(L[id[l]]!=l) small(id[l],l,R[id[l]],x,y),ll=id[l]+1;
    else ll=id[l];
    if(R[id[r]]!=r) small(id[r],L[id[r]],r,x,y),rr=id[r]-1;
    else rr=id[r];
    rep(i,ll,rr) big(i,x,y);
  }
}
Z qry(int l,int r){
  int ressum=0; Z respi=1;
  if(id[l]==id[r]){
    rep(i,l,r){
      int value=val[find(i)];
      ressum+=value,respi*=ivf[value];
    }
  }else{
    int ll,rr;
    if(L[id[l]]!=l){
      rep(i,l,R[id[l]]){
        int value=val[find(i)];
        ressum+=value,respi*=ivf[value];
        ll=id[l]+1;
      }
    }else ll=id[l];
    if(R[id[r]]!=r){
      rep(i,L[id[r]],r){
        int value=val[find(i)];
        ressum+=value,respi*=ivf[value];
        rr=id[r]-1;
      }
    }else rr=id[r];
    rep(i,ll,rr) ressum+=sum[i],respi*=pi[i];
  }
  return fac[ressum]*respi;
}
signed main(){IOS;
  prework();
  cin>>n>>q,bs=sqrt(n);
  rep(i,1,n) id[i]=(i-1)/bs+1,sz[id[i]]++;
  rep(i,1,n) R[id[i]]=i;
  per(i,n,1) L[id[i]]=i;
  tot=id[n];
  rep(i,1,n) cin>>a[i];
  rep(i,1,tot) init(i);
  while(q--){
    int op; cin>>op;
    if(op==1){
      int l,r,x,y; cin>>l>>r>>x>>y;
      if(x==y) continue;
      upd(l,r,x,y);
    }else{
      int l,r; cin>>l>>r;
      cout<<qry(l,r).val()<<"\n";
    }
  }
}
```

---

## 作者：wwwwwza (赞：3)

难调。

首先化简式子：$\prod\limits_{i=l}^r \binom{a_i}{\sum\limits_{j=l}^i a_j}=\frac{(\sum\limits_{i=l}^r a_i)!}{\prod\limits_{i=l}^r (a_i!)}$ 。

发现只需要维护 $(\sum\limits_{i=l}^r a_i)!$ 和 $\prod\limits_{i=l}^r (a_i!)$ 。

考虑分块，用并查集维护每一颗星星的亮度。

但是空间不够，可以将询问离线下来，一个块一个块的维护。

注意，这道题能预处理的都要预处理，比如说快速幂。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+5;
const int M=317;
const int mod=998244353;
const int inf=1e7;
int n,q,opt,l,r,x,y,a[N*50],b[N*50],fa[N*50],siz[N*50],idx=0;
int mp[N],qpow[N][320],invv[N][320];
int V,L[N],R[N],pos[N],num[N],sum[N];
int fac[inf+5],inv[N],F[N],G[N];
bool vis[N];
struct node{
	int opt,l,r,x,y,id;
}que[N];
int find(int x){
	if(fa[x]==x)return x;
	return fa[x]=find(fa[x]);
}
int ksm(int a,int b){
	int res=1;
	while(b){
		if(b&1)res=1ll*res*a%mod;
		a=1ll*a*a%mod;
		b>>=1;
	}
	return res;
}
void build(int l,int r,int x,int y){
	if(!mp[y]){
		mp[y]=++idx;
		fa[idx]=idx;
		a[idx]=y;
	}
	for(int i=l;i<=r;i++){
		if(a[find(i)]==x){
			fa[i]=mp[y];
			sum[pos[l]]=1ll*sum[pos[l]]*inv[x]%mod;
			sum[pos[l]]=1ll*sum[pos[l]]*fac[y]%mod;
			num[pos[l]]=num[pos[l]]-x+y;
			siz[mp[x]]--;
			siz[mp[y]]++;
		}
	}
}
void calc(int l,int r,int &f,int &g){
	for(int i=l;i<=r;i++){
		f+=a[find(i)];
		g=1ll*g*fac[a[find(i)]]%mod;
	}
}
int main(){
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]),b[i]=a[i];
	fac[0]=1;
	for(int i=1;i<=inf;i++)fac[i]=1ll*fac[i-1]*i%mod;
	inv[N-5]=ksm(fac[N-5],mod-2);
	for(int i=N-6;i>=0;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;
	V=(n-1)/M+1;
	for(int i=1;i<=V;i++){
		L[i]=R[i-1]+1;
		R[i]=i*M;
		sum[i]=1,num[i]=0;
	}
	R[V]=n;
	for(int i=1;i<=V;i++){
		for(int j=L[i];j<=R[i];j++)pos[j]=i;
	}
	idx=n;
	for(int i=1;i<=N-5;i++){
		qpow[i][0]=invv[i][0]=1;
		for(int j=1;j<=M;j++){
			qpow[i][j]=1ll*qpow[i][j-1]*fac[i]%mod;
			invv[i][j]=1ll*invv[i][j-1]*inv[i]%mod;
		}
	}
	for(int i=1;i<=q;i++){
		F[i]=0,G[i]=1;
		scanf("%d%d%d",&opt,&l,&r);
		if(opt==1){
			scanf("%d%d",&x,&y);
			que[i]={1,l,r,x,y,i};
		}else{
			que[i]={2,l,r,0,0,i};
			vis[i]=1;
		}
	}
	for(int i=1;i<=V;i++){
		for(int j=1;j<=idx;j++){
			a[j]=fa[j]=siz[j]=0;
		}
		for(int j=1;j<=N-5;j++)mp[j]=0;
		idx=n;
		for(int j=L[i];j<=R[i];j++){
			a[j]=b[j];
			sum[i]=1ll*sum[i]*fac[a[j]]%mod;
			num[i]=num[i]+a[j];
			if(!mp[a[j]]){
				mp[a[j]]=++idx;
				fa[idx]=idx;
				a[idx]=a[j];
			}
			siz[mp[a[j]]]++;
			fa[j]=mp[a[j]];
		}
		for(int j=1;j<=q;j++){
			l=que[j].l,r=que[j].r;
			x=que[j].x,y=que[j].y;
			if(pos[l]>i||pos[r]<i)continue;
			l=max(l,L[i]),r=min(r,R[i]);
			if(que[j].opt==1){
				if(x==y)continue;
				if(l==L[i]&&r==R[i]){
					if(!mp[y]){
						mp[y]=++idx;
						fa[idx]=idx;
						a[idx]=y;
					}
					fa[mp[x]]=mp[y];
					a[mp[x]]=y;
					num[i]=num[i]-siz[mp[x]]*(x-y);
					sum[i]=1ll*sum[i]*invv[x][siz[mp[x]]]%mod;
					sum[i]=1ll*sum[i]*qpow[y][siz[mp[x]]]%mod;
					siz[mp[y]]+=siz[mp[x]];
					siz[mp[x]]=0;
					mp[x]=0;
				}else{
					build(l,r,x,y);
				}
			}else{
				if(l==L[i]&&r==R[i]){
					F[que[j].id]+=num[i];
					G[que[j].id]=1ll*G[que[j].id]*sum[i]%mod;
				}else calc(l,r,F[que[j].id],G[que[j].id]);
			}
		}
	}
	for(int i=1;i<=q;i++){
		if(!vis[i])continue;
		F[i]=fac[F[i]];
		int ans=1ll*F[i]*ksm(G[i],mod-2)%mod;
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：mlvx (赞：1)

所求即为 $\dfrac{(\sum\limits_{i=l}^{r}a_i)!}{\prod\limits_{i=l}^{r}(a_i!)}$。

然后发现这个修改十分眼熟，是一个套路，直接用并查集维护即可，这样我们就可以 $O(1)$ 对整块进行修改，$O(1)$ 查询块内某数出现次数。

然后记录每个块内的和与快内每个数的阶乘的逆元的积。这是好修改的。只需要预处理 $1$ 至 $10^5$ 每个数的阶乘及其阶乘的逆元的 $0$ 至 $B$ 次方的结果。

查询整块就直接取出答案，散块就暴力。

空间 $O(n(B+\dfrac{n}{B}))$ 勉强开下，时间复杂度 $O(n(B+\dfrac{n}{B}))$。

默认 $n,q,V$ 同阶。

取 $B=O(\sqrt n)$ 最优。

修改记得特判 $x=y$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10,V=1e5,L=320,T=320,mod=998244353;
int n,q,len,tot,a[N],bl[N],le[T],ri[T],sum[T],f[T],fa[N],siz[T][N],val[N],rt[T][N],invfac[N][L],fc[N][L],fac[10000010];
int qpow(int a,int b,int ret=1){for(;b;a=1ll*a*a%mod,b>>=1)if(b&1)ret=1ll*ret*a%mod;return ret;}
int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
void mrg(int blk,int x,int y){
	if(!rt[blk][y])val[rt[blk][y]=rt[blk][x]]=y;
	else fa[rt[blk][x]]=rt[blk][y];
	siz[blk][y]+=siz[blk][x],rt[blk][x]=siz[blk][x]=0;
}void clr(int blk){
	for(int i=le[blk];i<=ri[blk];i++)a[i]=val[find(i)],siz[blk][a[i]]=rt[blk][a[i]]=0;
	for(int i=le[blk];i<=ri[blk];i++)fa[i]=0;
}void bld(int blk){
	for(int i=le[blk];i<=ri[blk];i++){
		if(!rt[blk][a[i]])rt[blk][a[i]]=i,fa[i]=i,val[i]=a[i];
		else fa[i]=rt[blk][a[i]];
		++siz[blk][a[i]];
	}
}int main(){
	cin>>n>>q,len=sqrt(n),tot=(n-1)/len+1,fac[0]=1;
	for(int i=1;i<=10000000;i++)fac[i]=1ll*fac[i-1]*i%mod;
	for(int i=V;~i;i--){
		invfac[i][0]=1,invfac[i][1]=i==V?qpow(fac[V],mod-2):1ll*invfac[i+1][1]*(i+1)%mod;
		for(int j=2;j<=len;j++)invfac[i][j]=1ll*invfac[i][j-1]*invfac[i][1]%mod;
	}for(int i=0;i<=V;i++){
		fc[i][0]=1;
		for(int j=1;j<=len;j++)fc[i][j]=1ll*fc[i][j-1]*fac[i]%mod;
	}for(int i=1;i<=n;i++)cin>>a[i],bl[i]=(i-1)/len+1;
	for(int i=1;i<=tot;i++){
		le[i]=ri[i-1]+1,ri[i]=i==tot?n:ri[i-1]+len,f[i]=1;
		for(int j=le[i];j<=ri[i];j++)sum[i]+=a[j],f[i]=1ll*invfac[a[j]][1]*f[i]%mod;
		bld(i);
	}for(int op,l,r,x,y;q--;){
		cin>>op>>l>>r;
		if(op==1){
			cin>>x>>y;if(x==y)continue;
			if(bl[l]==bl[r]){
				clr(bl[l]);
				for(int i=l;i<=r;i++)if(a[i]==x)a[i]=y,sum[bl[l]]+=y-x,f[bl[l]]=1ll*f[bl[l]]*fac[x]%mod*invfac[y][1]%mod;
				bld(bl[l]);
			}else{
				clr(bl[l]);
				for(int i=l;i<=ri[bl[l]];i++)if(a[i]==x)a[i]=y,sum[bl[l]]+=y-x,f[bl[l]]=1ll*f[bl[l]]*fac[x]%mod*invfac[y][1]%mod;
				bld(bl[l]);
				clr(bl[r]);
				for(int i=le[bl[r]];i<=r;i++)if(a[i]==x)a[i]=y,sum[bl[r]]+=y-x,f[bl[r]]=1ll*f[bl[r]]*fac[x]%mod*invfac[y][1]%mod;
				bld(bl[r]);
				for(int i=bl[l]+1;i<bl[r];i++)sum[i]+=siz[i][x]*(y-x),f[i]=1ll*f[i]*fc[x][siz[i][x]]%mod*invfac[y][siz[i][x]]%mod,mrg(i,x,y);
			}
		}else{
			int s=0,mul=1;
			if(bl[l]==bl[r])for(int i=l;i<=r;i++)s+=val[find(i)],mul=1ll*mul*invfac[val[find(i)]][1]%mod;
			else{
				for(int i=l;i<=ri[bl[l]];i++)s+=val[find(i)],mul=1ll*mul*invfac[val[find(i)]][1]%mod;
				for(int i=le[bl[r]];i<=r;i++)s+=val[find(i)],mul=1ll*mul*invfac[val[find(i)]][1]%mod;
				for(int i=bl[l]+1;i<bl[r];i++)s+=sum[i],mul=1ll*mul*f[i]%mod;
			}cout<<1ll*fac[s]*mul%mod<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：Reunite (赞：1)

套路题。

要求的东西很丑，我们来观察一下这个式子，发现每次分子上的 $sum(i-1)!$ 会和分母上 $(sum(i)-a_i)!$ 抵消，稍微化一下就是让我们求 $\frac{sum!}{\prod_{i=l}^r a_i!}$。关键是求 $sum$ 和 $\prod a_i!$。

区间所有 $x$ 赋值为 $y$ 的操作很难搞，考虑分块，对于每个块来说，操作转化为全局 $x\leftarrow y$ 或者前后缀操作。注意到任意时刻任意相同元素完全等价。因为数值时刻变化，因此维护的信息不能忽略时间而建立在数值上，但是下标集合是不断合并的。设 $fa_i$ 为下标为 $i$ 的数此时应与下标为 $fa_i$ 的数相同，这个容易用并查集维护。对于前后缀操作，暴力推平重建，关键在于快速找到每个位置的真实值，也可以利用 $fa$ 并查集找到。实现时需要构造双射集 $val_i$ 和 $it_i$ 表示此刻数值为 $val$ 的代表元下标为 $i$ 以及此刻下标为 $i$ 的真实值。这两个容易确定地 $O(1)$ 维护。

剩下的就简单了，因为操作与块序无关，直接离线下来逐块处理，每次对块的全局操作额外维护 $sz_i$ 即可，离散操作直接推平重构，这些过程中动态维护区间和与区间阶乘积即可。

小问题是撤销和加入块全局阶乘贡献的时候，要算一些阶乘的次幂，可以直接快速幂做单次 $O(\log B)$ 这样空间是线性的，时间大约 $O(3q\sqrt n)$；也可以预处理，对于所有阶乘处理 $[1,\sqrt B]$ 以及 $[k\sqrt B]$ 的值，这样单次查询 $O(1)$，预处理时空复杂度 $O(n\sqrt B)$，总共 $O(q\sqrt n)$。两种实现都很优秀且常数很小，目前都是最优解。

代码放个理论更优的第二种实现吧。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define int long long
#define mod 998244353
#define B 400
using namespace std;

int n,V,q;
int a[100005];
int bl[100005];
int lf[100005];
int rt[100005];
int inv[100005];
int infac[100005];
int fac[100000005];
int ans[100005];
int sum[100005];
int mf[100005][21];
int mff[100005][21];
int mg[100005][21];
int mgg[100005][21];
struct node{int op,l,r,x,y;}b[100005];

inline void in(int &n){
	n=0;
	char c=getchar();
	while(c<'0' || c>'9') c=getchar();
	while(c>='0'&&c<='9') n=n*10+c-'0',c=getchar();
	return ;
}

inline int calc1(int x,int k){return mf[x][k%20]*mff[x][k/20]%mod;}

inline int calc2(int x,int k){return mg[x][k%20]*mgg[x][k/20]%mod;}

int it[100005];
int fa[100005];
int vl[100005];
int sz[100005];
inline int Find(int x){return fa[x]==x?x:fa[x]=Find(fa[x]);}

inline void rebuild(int L,int R,int &s,int &c){
	s=0,c=1;
	for(int i=L;i<=R;i++){
		s+=a[i];
		c=c*infac[a[i]]%mod;
		if(vl[a[i]]) fa[i]=vl[a[i]];
		else fa[i]=vl[a[i]]=i,it[i]=a[i];
		sz[Find(i)]++;
	}
	return ;
}

inline void solve(int L,int R){
	int s=0,c=1;
	for(int i=1;i<=V;i++) vl[i]=0;
	for(int i=1;i<=n;i++) sz[i]=fa[i]=it[i]=0;
	rebuild(L,R,s,c);
	for(int i=1;i<=q;i++){
		if(b[i].l>R||b[i].r<L) continue;
		if(b[i].op==1){
			int x=b[i].x,y=b[i].y;
			if(x==y) continue;
			if(b[i].l<=L&&b[i].r>=R){
				if(!vl[x]) continue;
				int u=vl[x];
				s+=(y-x)*sz[u];
				c=c*calc1(x,sz[u])%mod*calc2(y,sz[u])%mod;
				if(vl[y]) fa[vl[x]]=vl[y],sz[vl[y]]+=sz[vl[x]],sz[vl[x]]=0,it[vl[x]]=0;
				else vl[y]=vl[x],it[vl[y]]=y;
				vl[x]=0;
			}
			else{
				int l=max(L,b[i].l),r=min(R,b[i].r);
				for(int j=L;j<=R;j++) a[j]=it[Find(j)];
				for(int j=l;j<=r;j++) if(a[j]==x) a[j]=y;
				for(int j=L;j<=R;j++) vl[it[j]]=0;
				for(int j=L;j<=R;j++) it[j]=fa[j]=sz[j]=0;
				rebuild(L,R,s,c);
			}
		}
		else{
			if(b[i].l<=L&&b[i].r>=R){
				sum[i]+=s;
				ans[i]=ans[i]*c%mod;
				continue;
			}
			else{
				int ss=0,cc=1;
				int l=max(L,b[i].l),r=min(R,b[i].r);
				for(int j=l;j<=r;j++){
					ss+=it[Find(j)];
					cc=cc*infac[it[Find(j)]]%mod;
				}
				sum[i]+=ss;
				ans[i]=ans[i]*cc%mod;
			}
		}
	}
	return ;
}

signed main(){
	in(n),in(q);
	for(int i=1;i<=n;i++) in(a[i]),V=max(V,a[i]);
	for(int i=1;i<=n;i++) bl[i]=(i+B-1)/B;
	for(int i=1;i<=n;i++) rt[bl[i]]=i;
	for(int i=n;i>=1;i--) lf[bl[i]]=i;
	fac[0]=fac[1]=infac[0]=infac[1]=inv[1]=1;
	for(int i=2;i<=10000000;i++) fac[i]=fac[i-1]*i%mod;
	for(int i=2;i<=100000;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod,infac[i]=infac[i-1]*inv[i]%mod;
	for(int i=0;i<=100000;i++) mf[i][0]=mg[i][0]=mff[i][0]=mgg[i][0]=1;
	for(int i=0;i<=100000;i++){
		for(int j=1;j<=20;j++) mf[i][j]=mf[i][j-1]*fac[i]%mod,mg[i][j]=mg[i][j-1]*infac[i]%mod;
		for(int j=1;j<=20;j++) mff[i][j]=mff[i][j-1]*mf[i][20]%mod,mgg[i][j]=mgg[i][j-1]*mg[i][20]%mod;
	}
	for(int i=1;i<=q;i++){
		in(b[i].op);
		if(b[i].op==1) in(b[i].l),in(b[i].r),in(b[i].x),in(b[i].y);
		else in(b[i].l),in(b[i].r),ans[i]=1;
		V=max({V,b[i].x,b[i].y});
	}
	for(int i=1;i<=bl[n];i++) solve(lf[i],rt[i]);
	for(int i=1;i<=q;i++) if(b[i].op==2) printf("%lld\n",fac[sum[i]]*ans[i]%mod);

	return 0;
}
```

---

## 作者：St_john (赞：1)

首先，原式可以转化为
$$\frac{(\sum_{i=l}^r a_i)!}{\prod_{i=l}^r (a_i!)}$$
这就很好办了，可以拿线段树来维护。  

但是，还有操作一，一看就是要分块。  
块内要维护以下信息。  
1. 区间和
1. 区间阶乘逆元积
1. 相同的数的位置

如果是全局相同的数的位置，那么和暴力已经没有区别了。  
分块的好处是块内可以直接处理。  
所以可以对于每个块维护一个链表，将所有点对应地连到某个上面。  
但是如果要是找链头，则需要类似并查集的操作。  
所以直接并查集好了。  

* 并查集擅长动态维护许多具有传递性的关系。

所以并查集来连接链头以及其他是这个值的点，找链头是直接 `find()` 即可。  

查询答案就按分块的方法写就行。  

至于修改，分类讨论。  
对于一个块内或者边角，直接暴力重构块。  
整块就是将位置修改，找到链头，直接转嫁过去。  
其他的对于区间和和积的修改就很平凡了。

复杂度大致是 $O(n\sqrt{n})$ 的。  

```cpp
#include<cstdio>
#define _for(i,a,b) for(register int i=(a);i<=(b);++i)
#define __for(i,a,b) for(register int i=(a);i>=(b);--i)
#define Re register int
#define il inline
#define pc putchar
using namespace std;
typedef long long ll;
const int N=1e5+10,M=998244353,inf=2147483647;
il int re(){
	int x=0;
	bool f=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')
		f|=ch=='-',ch=getchar();
	while(ch>='0'&&ch<='9')
		x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return f?-x:x;
}
void pr(int x){
	if(x<0) x=-x,pc('-');
	if(x>9) pr(x/10);
	pc(x%10|48);
}

int n,a[N],v[N];
const int B=316,W=1e7+10,L=N/B+10;
int fac[W],inv[N],powfac[N][B+10],powinv[N][B+10];
struct node{//链表，只有头和链长
	int head,num;
}e[L][N];
int bl[L],br[L],pos[N];
int sum[L],mul[L];//区间和，区间阶乘逆元积

int fa[N];//并查集
il int find(int x){
	while(x!=fa[x])
		x=fa[x]=fa[fa[x]];
	return x;
}

il int pow(int a,int b){
	int c=1;
	while(b){
		if(b&1) c=(ll)c*a%M;
		a=(ll)a*a%M;
		b>>=1;
	}
	return c;
}

il void init(int x){//重构
	sum[x]=0,mul[x]=1;
	_for(i,bl[x],br[x]){
		if(!e[x][a[i]].head){
			e[x][a[i]].head=i;
			e[x][a[i]].num=1;
			fa[i]=i;
			v[i]=a[i];
		}
		else{
			++e[x][a[i]].num;
			fa[i]=e[x][a[i]].head;
		}
		sum[x]+=a[i];
		mul[x]=(ll)mul[x]*inv[a[i]]%M;
	}
}
il void calc1(int now,int l,int r,int x,int y){//边角
	_for(i,bl[now],br[now]){
		a[i]=v[find(i)];
		e[now][a[i]].head=e[now][a[i]].num=0;
	}
	_for(i,bl[now],br[now]) fa[i]=0;
	_for(i,l,r)
		if(a[i]==x)
			a[i]=y;
	init(now);
}
il void calc2(int now,int x,int y){//整块
	sum[now]+=(y-x)*e[now][x].num;
	mul[now]=(ll)mul[now]*powfac[x][e[now][x].num]%M*powinv[y][e[now][x].num]%M;
	e[now][y].num+=e[now][x].num;
	if(!e[now][y].head){
		e[now][y].head=e[now][x].head;
		v[e[now][y].head]=y;
	}
	else fa[e[now][x].head]=e[now][y].head;
	e[now][x].head=e[now][x].num=0;
}

il void change(int l,int r,int x,int y){
	if(pos[l]==pos[r]){
		calc1(pos[l],l,r,x,y);
	}
	else{
		int L,R;
		if(l!=bl[pos[l]]){
			calc1(pos[l],l,br[pos[l]],x,y);
			L=pos[l]+1;
		}
		else L=pos[l];
		if(r!=br[pos[r]]){
			calc1(pos[r],bl[pos[r]],r,x,y);
			R=pos[r]-1;
		}
		else R=pos[r];
		_for(i,L,R)
			calc2(i,x,y);
	}
}

il int ask(int l,int r){
	int x=0,y=1;
	if(pos[l]==pos[r]){
		_for(i,l,r){
			int z=v[find(i)];
			x+=z;
			y=(ll)y*inv[z]%M;
		}
	}
	else{
		int L,R;
		if(bl[pos[l]]!=l){
			_for(i,l,br[pos[l]]){
				int z=v[find(i)];
				x+=z;
				y=(ll)y*inv[z]%M;
			}
			L=pos[l]+1;
		}
		else L=pos[l];
		if(br[pos[r]]!=r){
			_for(i,bl[pos[r]],r){
				int z=v[find(i)];
				x+=z;
				y=(ll)y*inv[z]%M;
			}
			R=pos[r]-1;
		}
		else R=pos[r];
		_for(i,L,R){
			x+=sum[i];
			y=(ll)y*mul[i]%M;
		}
	}
	return (ll)fac[x]*y%M;
}

signed main(){
	n=re();
	int q=re();
	_for(i,1,n){
		a[i]=re(),pos[i]=i/B+1;
		if(pos[i]!=pos[i-1])
			bl[pos[i]]=i,br[pos[i-1]]=i-1;
	}
	br[pos[n]]=n;
	
	
	inv[0]=fac[0]=fac[1]=1;
	_for(i,2,10000000)
		fac[i]=(ll)fac[i-1]*i%M;
	inv[100000]=pow(fac[100000],M-2);
	__for(i,100000-1,1) inv[i]=(ll)inv[i+1]*(i+1)%M;
	_for(i,1,100000){
		powfac[i][0]=powinv[i][0]=1;
		_for(j,1,B){
			powfac[i][j]=(ll)powfac[i][j-1]*fac[i]%M;
			powinv[i][j]=(ll)powinv[i][j-1]*inv[i]%M;
		}
	}
	_for(i,1,pos[n]) init(i);
	
	while(q--){
		int op=re();
		if(op==1){
			int l=re(),r=re(),x=re(),y=re();
			if(x==y) continue ;
			change(l,r,x,y);
		}
		else{
			int l=re(),r=re();
			pr(ask(l,r)),pc('\n');
		}
	}
	return 0;
}
```















---


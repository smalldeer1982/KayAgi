# 『STA - R2』机场修建

## 题目背景

智利在修机场。  

## 题目描述

有 $n$ 个城市排成一列，最开始是互不连通的。  
每个城市初始都没有人口。  
会出现以下操作 / 查询共 $m$ 个：  

1. `1 x y` 开通城市 $x$ 和城市 $y$ 之间的双向航班。  
2. `2 l r a` 城市 $[l, r]$ 的人口数都 $+a$。  
3. `3 x` **如果**所有能够到达城市 $x$ 的人都来到城市 $x$，城市 $x$ 有多少人。  

## 说明/提示

**本题捆绑测试。**  
- Easy（5pts）：$1 \le n, m \le 2 \times 10^5$，且不存在操作 $1$。  
- Normal（10pts）：$1 \le n, m \le 1000$。  
- Hard（20pts）：$1 \le n, m \le 10^5$，且操作 $3$ 之后不存在操作 $2$。  
- Lunatic（30pts）：$1 \le n, m \le 5 \times 10^4$。 
- Overdrive（35pts）：$1 \le n, m \le 2 \times 10^5$。  

对于 $100\%$ 的数据，$1\le n,m\le 2\times 10^5$，$0 \le a \le 10^9$。保证答案在 64 位有符号整形表示的范围内。

![](https://cdn.luogu.com.cn/upload/image_hosting/dgqoqa8d.png)  
出于某些原因，给了较多的部分分。  

## 样例 #1

### 输入

```
5 5
1 2 4
2 3 5 2
3 2
1 2 5
3 2```

### 输出

```
2
4```

# 题解

## 作者：honglan0301 (赞：18)

## 题目分析

事实上根号分治是完全没必要的，我这里提供一个仅基于分块的时间 $O(n\sqrt n)$，空间 $O(n)$ 做法。

首先这种问题肯定想分块，朴素的区间加区间求和可以使用散块暴力加，整块懒标记的方法处理。而其实本题也可以用同样的方法：还是先对点的编号分块，之后注意到每次询问只会问到一个连通块，于是我们不完全实时地维护每个连通块的点权和，而是对每个连通块 $i$ 分成 $A_i$（表示由散块加上来的值）与 $B_i$（由整块加上来的值）这两部分维护：

前者可以暴力加。后者我们考虑询问时再具体求，这只需对每个连通块维护 $s_{i,j}$ 表示连通块 $i$ 内点编号在第 $j$ 块的点的个数。那么合并连通块 $u,v$ 时令 $A_{v}\leftarrow A_{u}+A_{v}$ 并重构 $s$ 数组即可做到单次 $O(\sqrt n)$ ；询问时有 $ans=A_u+B_u=A_u+\sum s_{u,i}\times tag_i$，直接扫一遍也可以做到单次 $O(\sqrt n)$。

现在的空间是 $O(n\sqrt n)$ 的，不过其实很好处理，因为你注意到只需维护 $s_{i,j}$ 中非零的部分，而显然至多有 $O(n)$ 个 $s_{i,j}$ 是非零的，于是对每个 $i$ 开动态数组即可让空间变成 $O(n)$。

## 代码

感觉这种做法的代码就挺简洁好懂，非常不错。以下是核心部分代码。

```cpp
#define mp make_pair
#define pb push_back
#define fi first
#define se second
#define ll long long
#define B 475

int n,m,opt,u,v,w,k[200005],L[705],R[705],bh[200005],sz[200005],ns[705];
ll sum[200005],tg[705];
vector <pair<int,int>> sm[200005];
vector <int> num[200005];

signed main()
{
	cin>>n>>m; for(int i=1;i<=n;i++) k[i]=(i-1)/B+1; 
	for(int i=1;i<=k[n];i++) L[i]=(i-1)*B+1,R[i]=min(i*B,n);
	for(int i=1;i<=n;i++) bh[i]=i,sz[i]=1,sm[i].pb(mp(k[i],1)),num[i].pb(i);
	while(m--)
	{
		cin>>opt;
		if(opt==1)
		{
			cin>>u>>v; u=bh[u],v=bh[v]; if(u==v) continue; if(sz[u]>sz[v]) swap(u,v);
			for(auto i:num[u]) bh[i]=v,num[v].pb(i); num[u].clear(); num[u].shrink_to_fit();
			for(auto i:sm[u]) ns[i.fi]+=i.se; for(auto i:sm[v]) ns[i.fi]+=i.se; 
			sm[u].clear(); sm[v].clear(); sm[u].shrink_to_fit(); sm[v].shrink_to_fit();
			for(int i=1;i<=k[n];i++) if(ns[i]) sm[v].pb(mp(i,ns[i])),ns[i]=0; sum[v]+=sum[u]; sz[v]+=sz[u];
		}
		else if(opt==2)
		{
			cin>>u>>v>>w; int uu=k[u],vv=k[v];
			if(uu==vv) {for(int i=u;i<=v;i++) sum[bh[i]]+=w;}
			else
			{
				for(int i=u;i<=R[uu];i++) sum[bh[i]]+=w; for(int i=L[vv];i<=v;i++) sum[bh[i]]+=w;
				for(int i=uu+1;i<=vv-1;i++) tg[i]+=w;
			}
		}
		else {cin>>u; u=bh[u]; ll ans=sum[u]; for(auto i:sm[u]) ans+=(ll)i.se*tg[i.fi]; cout<<ans<<endl;}
	}
}
```


---

## 作者：zhiyangfan (赞：9)

提供一个基于根号分治的时间复杂度 $\mathcal{O}(n\sqrt{n})$，空间复杂度 $\mathcal{O}(n)$ 的做法，应该比较好懂。

首先考虑对于连通块的大小进行根号分治。对于 $<\sqrt{n}$ 的连通块，合并时直接用启发式合并进行合并。查询时直接遍历连通块查询每个数的权值，这样我们需要一个 $\mathcal{O}(\sqrt{n})$ 区间加 $\mathcal{O}(1)$ 单点查询的分块，应该比较好写。

接下来处理 $\ge \sqrt{n}$ 的连通块。由于这样的连通块最多只有 $\sqrt{n}$ 个，所以我们可以对每个块记录一下它的答案，并在修改时处理贡献。

现在我们需要实现的是修改的时候，对于 $\sqrt{n}$ 个连通块，我们需要快速计算区间内在某个连通块内的点个数。一眼望过去可以得到一个思路，就是在启发式合并的时候维护一个单点加和区间查询的分块。这个东西可以用维护整块的前缀和做到 $\mathcal{O}(\sqrt{n})$ 修改，$\mathcal{O}(1)$ 查询。这里的常数时间查询指的是对于修改时的整块，枚举每个大块时，直接可以得到这个大块对应的数量，而修改时的散块可以通过直接查询散块点所在的连通块快速修改。这样修改的复杂度就是合理的 $\mathcal{O}(\sqrt{n})$。

一眼望过去复杂度是 $\mathcal{O}(n\sqrt{n}\log n)$ 的，其实确实。不过但大家注意到，对于小块到大块的合并，每个点只能从小块变为大块一次，所以这部分的贡献是 $\mathcal{O}(n\sqrt{n})$ 的。然后大块之间的合并，才会有可能形成一个有 $\sqrt{n}$ 个大块的二叉树，从而带上 $\log$。

但我们观察到，大块之间的合并没必要直接处理每个点，可以把前缀和数组依次加起来，且这样最多加 $\sqrt{n}$ 次，所以时间复杂度是 $\mathcal{O}(n)$ 的。

维护出来前缀和数组和每个点对应的连通块后，修改时就能在 $\mathcal{O}(\sqrt{n})$ 的时间复杂度处理对每个大块的影响了。

总时间复杂度 $\mathcal{O}(n\sqrt{n})$。块长我取 $400$ 看起来比较快。
```cpp
#include <cstdio>
#include <vector>
const int N = 2e5 + 10, B = 400, M = 500; typedef long long ll; 
ll tag[M], a[N]; int blo[N], L[N], R[N], bn; std::vector<int> vec[N];
int sum[M][M], col[N], id[N], tn; ll ans[M];
// x 大块向 y 大块合并
void merge1(int x, int y)
{
	for (int i = 0; i <= bn; ++i) sum[id[y]][i] += sum[id[x]][i], sum[id[x]][i] = 0;
	ans[id[y]] += ans[id[x]];
	for (auto u : vec[x]) col[u] = y, vec[y].push_back(u);
	std::vector<int>().swap(vec[x]);
}
// x 小块向 y 大块合并
void merge2(int x, int y)
{
	if (!id[y])
	{
		id[y] = ++tn;
		for (auto u : vec[y]) 
		{
			ans[id[y]] += a[u] + tag[blo[u]];
			for (int i = blo[u]; i <= bn; ++i) ++sum[id[y]][i];
		}
	}
	for (auto u : vec[x])
	{
		col[u] = y; ans[id[y]] += a[u] + tag[blo[u]];
		for (int i = blo[u]; i <= bn; ++i) ++sum[id[y]][i];
		vec[y].push_back(u);
	}
	std::vector<int>().swap(vec[x]);
}
// x 小块向 y 大块合并
void merge3(int x, int y)
{
	for (auto u : vec[x]) col[u] = y, vec[y].push_back(u);
	std::vector<int>().swap(vec[x]);
}
void modify_sm(int l, int r, int w)
{
	int bl = blo[l], br = blo[r];
	if (bl == br)
	{
		for (int i = l; i <= r; ++i) a[i] += w;
		return ;
	}
	for (int i = l; i <= R[bl]; ++i) a[i] += w;
	for (int i = L[br]; i <= r; ++i) a[i] += w;
	for (int i = bl + 1; i < br; ++i) tag[i] += w;
}
void modify_bg(int l, int r, int w)
{
	int bl = blo[l], br = blo[r];
	if (bl == br)
	{
		for (int i = l; i <= r; ++i) if (id[col[i]]) ans[id[col[i]]] += w;
		return ;
	}
	for (int i = l; i <= R[bl]; ++i) if (id[col[i]]) ans[id[col[i]]] += w;
	for (int i = L[br]; i <= r; ++i) if (id[col[i]]) ans[id[col[i]]] += w;
	for (int i = 1; i <= tn; ++i)
		ans[i] += (ll)(sum[i][br - 1] - sum[i][bl]) * w;
}
int main()
{
	int n, m; scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; ++i) vec[i].push_back(i), col[i] = i;
	for (int i = 1; i <= n; ++i) blo[i] = (i - 1) / B;
	bn = blo[n];
	for (int i = 0; i <= bn; ++i) L[i] = i * B + 1, R[i] = std::min(n, (i + 1) * B);
	for (int i = 1, op, x, y, z; i <= m; ++i)
	{
		scanf("%d%d", &op, &x);
		if (op == 3)
		{
			x = col[x];
			if (id[x]) printf("%lld\n", ans[id[x]]);
			else
			{
				ll ans = 0;
				for (auto u : vec[x]) ans += a[u] + tag[blo[u]];
				printf("%lld\n", ans);
			}
		}
		else if (op == 1)
		{
			scanf("%d", &y); x = col[x]; y = col[y]; if (x == y) continue;
			int sx = vec[x].size(), sy = vec[y].size();
			if (sx > sy) std::swap(x, y), std::swap(sx, sy);
			if (sx + sy < B) merge3(x, y);
			else if (sx < B && sx + sy >= B) merge2(x, y);
			else merge1(x, y);
		}
		else scanf("%d%d", &y, &z), modify_bg(x, y, z), modify_sm(x, y, z);
	}
	return 0;
}
```

---

## 作者：hrgd (赞：7)

数据结构如果我能做出来的话，建议降蓝。

`1` 操作相当于合并两个集合，显然使用启发式合并。看到这种题你感觉感觉就会感觉到他应该不是 polylog，而且有颜色，故根号分治。

查询小颜色的时候，我们可以对每个位置进行查询，使用 $O(\sqrt n)\sim O(1)$ 的分块维护即可。我们希望每次更新的时候直接也更新掉每个大块，这样我们需要对大块做前缀和。但是当大块与小块合并的时候如果我们每次还要重新做前缀和的话显然复杂度是炸裂的。那么我们考虑根号重构，也就是当合并进来的点数不超过根号的时候不管他，累计到根号就重构。更新的时候更新已经重构过的值，查询的时候只用再多余查询那些不到根号个的散点即可。

时空复杂度 $O(n\sqrt n)$，但是由于卡空间建议块长开大。

放一下核心代码：


```
const int B=600;
#define pb push_back
#define ll long long
vector<int>S[maxn],S1[maxn];
int n,m,sz[maxn],p[maxn/B+5][maxn],vis[maxn],f[maxn],id[maxn],tid,iv[maxn];
ll Ans[maxn],a[maxn],laz[maxn];int lft[maxn],rht[maxn],bel[maxn];
inline int find(int x){return f[x]==x?x:f[x]=find(f[x]);}
int main(){
	n=read(),m=read();
	for(int i=1;;i++){
		lft[i]=rht[i-1]+1,rht[i]=lft[i]+B-1;
		if(rht[i]>n)rht[i]=n;
		for(int j=lft[i];j<=rht[i];j++)bel[j]=i;
		if(rht[i]==n)break;
	}
	for(int i=1;i<=n;i++)
		f[i]=i,sz[i]=1,S[i].pb(i),S1[i].pb(i);
	for(int i=1,op;i<=m;i++){
		op=read();
		if(op==1){
			int x=read(),y=read();
			x=find(x),y=find(y);
			if(x==y)continue;
			if(sz[x]>sz[y])swap(x,y);f[x]=y;
			sz[y]+=sz[x];
			for(auto t:S[x])
				S1[y].pb(t),S[y].pb(t);
			if(S1[y].size()>=B){
				S1[y].clear();Ans[y]=0;
				if(!id[y])id[y]=++tid,iv[tid]=y;
				for(int j=1;j<=n;j++)p[id[y]][j]=0;
				for(auto t:S[y])p[id[y]][t]=1,Ans[y]+=a[t]+laz[bel[t]];
				for(int j=1;j<=n;j++)p[id[y]][j]+=p[id[y]][j-1];
			}
		}else if(op==2){
			int l=read(),r=read(),x=read();
			if(bel[l]==bel[r])
				for(int j=l;j<=r;j++)a[j]+=x;
			else{
				for(int j=l;j<=rht[bel[l]];j++)a[j]+=x;
				for(int j=bel[l]+1;j<bel[r];j++)laz[j]+=x;
				for(int j=lft[bel[r]];j<=r;j++)a[j]+=x;
			}
			for(int j=1;j<=tid;j++)
				Ans[iv[j]]+=1ll*x*(p[j][r]-p[j][l-1]);
		}else{
			int x=read();x=find(x);
			ll res=Ans[x];
			for(auto t:S1[x])res+=a[t]+laz[bel[t]];
			printf("%lld\n",res);
		}
	}
	return 0;
}
```

---

## 作者：Pengzt (赞：5)

[P9410](https://www.luogu.com.cn/problem/P9410)
 
发现要支持区间加和连通块求和、合并，容易想到分块（虽然我一开始看错题了）。

完全不需要根号分治，直接分块即可。

考虑稍微暴力的分块。区间加的话，散块部分可以直接加到全局的 $sum$ 数组中，毕竟不是区间求和，然后整块部分直接打标记，记录块内每个连通块的大小即可。然后合并就是对于每一个块分别合并就行。但这样空间是 $\mathcal{O}(n\sqrt{n})$ 的，考虑优化。

占内存的是要维护每一块的 $sz$ 数组，发现 $sz$ 数组会占用很多无用的内存。因为 $sz$ 总数为 $\mathcal{O}(n)$，对每一个颜色存储在每一块的数量，这里因为没有出现的不会影响答案，可以不记录，因此使用 vector 动态扩容即可。具体地，维护每个连通块出现的块的编号和它在该块内的元素数量。这样就做到了空间线性。

时间复杂度：$\mathcal{O}(n\sqrt{n})$。空间线性。

[评测记录](https://www.luogu.com.cn/record/112616021)

核心代码：
```cpp
// Problem：P9410
#include<bits/stdc++.h>
#define pb push_back
#define ios ios::sync_with_stdio(0); cin.tie(0);
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> pii;
const int inf = 1e9, infi32 = 2147483647, mod = 1e9 + 7;
const ll INF = 1e18;

const int N = 2e5 + 10, B = 450 + 10;
int n, m, len, b;
int fa[N], sz[N], L[B], R[B], pos[N];
ll tg[B], sum[N], tmp[B];

vector<pair<int, ll> > v[N];

int find(int x) {
	if (fa[x] == x) return x;
	return fa[x] = find(fa[x]);
}

int main() {
//	freopen("data.in", "r", stdin);
//	freopen("myans.out", "w", stdout);
	ios
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		fa[i] = i;
		sz[i] = 1;
	}
	len = sqrt(n), b = n / len + (n % len != 0);
	for (int i = 1; i <= b; i++) {
		L[i] = (i - 1) * len + 1, R[i] = min(i * len, n);
		for (int j = L[i]; j <= R[i]; j++) pos[j] = i;
	}
	for (int i = 1; i <= n; i++) v[i].pb(make_pair(pos[i], 1));
	for (int t = 1, opt, x, y, z; t <= m; t++) {
		cin >> opt >> x;
		if (opt == 1) {
			cin >> y;
			x = find(x), y = find(y);
			if (x == y) continue;
			memset(tmp, 0, sizeof(tmp));
			if (sz[x] > sz[y]) swap(x, y);
			fa[x] = y, sz[y] += sz[x], sum[y] += sum[x];
			for (int i = 0; i < v[x].size(); i++) tmp[v[x][i].first] += v[x][i].second;
			for (int i = 0; i < v[y].size(); i++) tmp[v[y][i].first] += v[y][i].second;
			v[x].clear(); v[y].clear();
			for (int i = 1; i <= b; i++)
				if (tmp[i])
					v[y].pb(make_pair(i, tmp[i]));
		} else if (opt == 2) {
			cin >> y >> z;
			int p = pos[x], q = pos[y];
			if (p == q) {
				for (int i = x; i <= y; i++) sum[find(i)] += z;
				continue;
			}
			for (int i = x; i <= R[p]; i++) sum[find(i)] += z;
			for (int i = L[q]; i <= y; i++) sum[find(i)] += z;
			for (int i = p + 1; i < q; i++) tg[i] += z;
		} else {
			x = find(x);
			ll res = sum[x];
			for (int i = 0; i < v[x].size(); i++)
				res += tg[v[x][i].first] * v[x][i].second;
			cout << res << "\n";
		}
	}
	return 0;
}
```

---

## 作者：Implicit (赞：5)

（致审核管理：我改成分块了，现在小块复杂度确实没有 $\log$ 了阿）

首先根号分治，对于大小小于 $\sqrt n$ 的块用分块维护（具体的，$O(\sqrt n)-O(1)$ 修改查询），求连通块和的时候暴力求和即可。对于大小大于 $\sqrt n$ 的块最多有 $\sqrt n$ 个，所以考虑对于每个块维护结点标号组成的有序序列和连通块的点权和，合并时启发式归并排序，那么这里大块的总复杂度就是 $O(n\log n)$。

修改的时候扫一遍所有大块，考虑对其产生的影响，那么问题就变成找后继，找到之后容易 $O(1)$ 计算影响。

那么因为最多 $\sqrt n$ 个块所以合并次数不超过 $\sqrt n$，于是用分散层叠维护之，每次合并的时候暴力重构即可。

根据分析可以得到时间复杂度为 $O((n+q)\sqrt n)$。

纯口胡，不过应该没啥大问题。

---

## 作者：lht1217 (赞：2)

## [传送门](https://www.luogu.com.cn/problem/P9410)

前置知识：**并查集**，**分块**。

这道题是区间修改，集合查询。

区间修改对应**分块**。集合查询用**并查集**。

- 我们用 $size_{i,j}$ 表示以 $i$ 为父亲的集合中属于第 $j$ 块的个数。设块数为 $cnt$，块长为 $len$。

- 所以进行分块时，块长要合理，否则不是空间炸了，就是时间炸了。我的做法： $len=\sqrt{n}\times3$。卡过去了。

- 能覆盖整块的用 $tag_i$ 去维护。零散的的直接放入 $val$ 数组中即可。

- 用 $val_i$ 表示以 $i$ 为父亲的集合中的人数。（处理散块流出的人数）。

- 输出的答案 $ans=val_{fa_x}+\sum_{i=1}^{cnt}size_{fa_x,i}\times tag_i$。

最终空间复杂度为 $O(n\sqrt{n})$，时间复杂度为 $O(m\sqrt{n})$。

附上参考代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 200002
#define M 152
#define re register
#define il inline
#define ll long long
il int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-48; ch=getchar();}
    return x*f;
}
il void write(ll x){
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
int n,m,cnt,len;
int bel[N];
int st[M],ed[M];
ll tag[M];
int fa[N],sz[N][M];
ll val[N];
il int find(int x){
	return x==fa[x]?x:fa[x]=find(fa[x]);
}
il void merge(int x,int y){
	int fx=find(x),fy=find(y);
	if(fx==fy) return;
	fa[fx]=fy;
	val[fy]+=val[fx];
	for(int i=1;i<=cnt;i++) sz[fy][i]+=sz[fx][i];
}
il void update(int x,int y,int w){
	int bx=bel[x],by=bel[y];
	if(bx==by){
		for(re int i=x;i<=y;i++) val[find(i)]+=w;
	}
	else{
		for(re int i=x;i<=ed[bx];i++) val[find(i)]+=w;
		for(re int i=bx+1;i<=by-1;i++) tag[i]+=w;
		for(re int i=st[by];i<=y;i++) val[find(i)]+=w;
	}
}
il ll query(int x){
	int f=find(x);
	ll res=val[f];
	for(int i=1;i<=cnt;i++) res+=tag[i]*sz[f][i];
	return res;
}
int main(){
	n=read(); m=read();
	len=sqrt(n)*3;
	for(re int i=1;i<=n;i+=len){
		cnt++;
		st[cnt]=i;
		ed[cnt]=min(i+len-1,n);
		for(re int j=st[cnt];j<=ed[cnt];j++){
			fa[j]=j;
			sz[j][cnt]=1;
			bel[j]=cnt;
		}
	}
	int op,x,y,w;
	while(m--){
		op=read();
		switch(op){
			case 1:
				x=read(); y=read();
				merge(x,y);
				break;
			case 2:
				x=read(); y=read(); w=read();
				update(x,y,w);
				break;
			case 3:
				x=read();
				write(query(x));putchar('\n');
				break;
		}
	}
	return 0;
}
```


---

## 作者：eastcloud (赞：1)

观察题目，先考虑暴力做法，显然，用并查集维护联通性，要么在并查集祖先节点处维护子树内节点编号，修改时挨个遍历修改，要么先不管，先储存编号，询问时直接计算。

继续思考，在本题中，我们既要维护同个联通块内的信息，又要储存原本的编号方便区间修改，如果用一般的一维数据结构不太好处理，cdq 分治又不容易找到维度。

既然正常做法不行就考虑一下根号分治或者分块，直接按最暴力的把节点分块试试看。

修改好做，先把整块的加到对应数组里，小块先不管。

查询呢？由于块不超过 $\sqrt n$ 个，我们可以仿照暴力做法，在每个并查集的祖先节点处保留当前子树每个块都有多少个节点，查询时直接调到对应祖先的数组处遍历一边计算，这时可以发现刚才的小块只要直接跳到祖先处另开个变量累加就行。

合并就更好做了，直接合并两个节点的数组，累加对应变量，我们就以 $O(n \sqrt n)$ 的时间和空间复杂度解决了此题。

但这个做法通过此题还需要亿点点卡常，注意大数组要用 vector 替换、使用 short 命名变量、并查集按秩合并和快读快输等即可。

```cpp
#include<bits/stdc++.h>
#define ll unsigned long long
#define pb push_back
#define N 200005
#define S 450
using namespace std;
ll ans[N];
int f[N];
int siz[N];
ll add[S];
struct Node{
	short val,num;
};
vector<Node> sta[N];
inline int find(int x){
	if(f[x]==x) return f[x];
	else return find(f[x]);
}
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
inline void write(ll X)
{
    if(X<0) {X=~(X-1); putchar('-');}
    if(X>9) write(X/10);
    putchar(X%10+'0');
}
int main(){
	ll n,m,opt,x,y,z;
	n=read();m=read();
	ll t=sqrt(n),len=t;
	if(t*len<n) t++;
	for(ll i=1;i<=n;i++) f[i]=i;
	for(int i=1;i<=n;i++) siz[i]=1;
	for(ll i=1;i<=t;i++){
		ll lim=min(n,i*len);
		for(ll j=(i-1)*len+1;j<=lim;j++){
			sta[j].push_back((Node){1,i});
		}
	}
	for(ll i=1;i<=m;i++){
		opt=read();
		if(opt==3){
			x=read();
			x=find(x);
			ll an=ans[x];
			for(ll j=0;j<sta[x].size();j++)an+=1ll*sta[x][j].val*add[sta[x][j].num];
			write(an);
			putchar('\n');
		}
		else if(opt==1){
			x=read();y=read();
			x=find(x);y=find(y);
			if(siz[x]>siz[y]) swap(x,y);
			if(x==y) continue;f[x]=y;
			ll a=0,b=0;sta[n+1].clear();
			while(a!=sta[x].size() && b!=sta[y].size()){
				if(sta[x][a].num<sta[y][b].num){
					if(sta[n+1].size() && sta[n+1][sta[n+1].size()-1].num==sta[x][a].num){
						sta[n+1][sta[n+1].size()-1].val+=sta[x][a].val;
					}
					else sta[n+1].push_back(sta[x][a]);
					a++;
				}
				else{
					if(sta[n+1].size() && sta[n+1][sta[n+1].size()-1].num==sta[y][b].num){
						sta[n+1][sta[n+1].size()-1].val+=sta[y][b].val;
					}
					else sta[n+1].push_back(sta[y][b]);
					b++;
				}
			}
			while(a!=sta[x].size()){
				if(sta[n+1].size() && sta[n+1][sta[n+1].size()-1].num==sta[x][a].num){
					sta[n+1][sta[n+1].size()-1].val+=sta[x][a].val;
				}
				else sta[n+1].push_back(sta[x][a]);
				a++;
				
			}
			while(b!=sta[y].size()){
				if(sta[n+1].size() && sta[n+1][sta[n+1].size()-1].num==sta[y][b].num){
					sta[n+1][sta[n+1].size()-1].val+=sta[y][b].val;
				}
				else sta[n+1].push_back(sta[y][b]);
				b++;
			}
			sta[y].clear();
			for(ll i=0;i<sta[n+1].size();i++) sta[y].push_back(sta[n+1][i]);
			ans[y]+=ans[x];siz[y]+=siz[x];
		}
		else{
			x=read();y=read();z=read();
			ll a=(x-1)/len,lim=min((a+1)*len,n);
			for(ll j=a*len+1;j<=lim;j++){
				if(j>=x && j<=y){ll tmp=find(j);ans[tmp]+=z;}
			}
			ll b=(y-1)/len;
			for(ll j=a+2;j<=b;j++)add[j]+=z;
			if(a==b) continue;
			lim=min((b+1)*len,n);
			for(ll j=b*len+1;j<=lim;j++){
				if(j<=y && j>=x){ll tmp=find(j);ans[tmp]+=z;}
				else break;
			}
		}
		
	}
}
```


---

## 作者：Leasier (赞：1)

~~赛时的答辩 $O((n + m) \sqrt{n} \log n)$ 做法就不说了（~~

考虑分块，散块我们可以直接加到对应的连通块上，下面考虑整块怎么维护。

注意到整块部分每个块内加的值 $val_i$ 全部相同，考虑维护出 $cnt_{i, j}$ 表示连通块 $i$ 内编号在第 $j$ 块的有几个点，则整块部分的答案为 $\displaystyle\sum_i val_i cnt_{x, i}$。

而 $cnt_{x, i}$ 不难在合并时维护，取块长为 $\sqrt{n}$ 可得时间复杂度为 $O((n + m) \sqrt{n})$。

如果要卡空间，可以只把非空的 $cnt_{x, i}$ 放进 vector 维护，合并连通块时时归并一下即可，这样空间复杂度降至 $O(n)$。

代码：
```cpp
#include <iostream>
#include <vector>
#include <cstdio>
#include <cmath>

using namespace std;

typedef long long ll;

int block;
int root[200007], belong[200007], lft[457], rt[457];
ll small[200007], big[457];
vector<pair<int, int> > v[200007];

inline void init(int n){
	for (register int i = 1; i <= n; i++){
		root[i] = i;
		belong[i] = (i - 1) / block + 1;
		v[i].push_back(make_pair(belong[i], 1));
	}
}

int get_root(int x){
	if (root[x] == x) return x;
	return root[x] = get_root(root[x]);
}

inline void merge(int x, int y){
	int x_root = get_root(x), y_root = get_root(y);
	if (x_root != y_root){
		int sizex = v[x_root].size(), sizey = v[y_root].size();
		vector<pair<int, int> > temp;
		root[x_root] = y_root;
		small[y_root] += small[x_root];
		for (register int i = 0, j = 0; i < sizex || j < sizey; ){
			pair<int, int> pr;
			if (i < sizex && (j == sizey || v[x_root][i].first < v[y_root][j].first)){
				pr = v[x_root][i++];
			} else {
				pr = v[y_root][j++];
			}
			if (!temp.empty() && temp.back().first == pr.first){
				temp.back().second += pr.second;
			} else {
				temp.push_back(pr);
			}
		}
		vector<pair<int, int> >().swap(v[x_root]);
		vector<pair<int, int> >().swap(v[y_root]);
		v[y_root] = temp;
	}
}

inline ll query(int u){
	int u_root = get_root(u), size = v[u_root].size();
	ll ans = small[u_root];
	for (register int i = 0; i < size; i++){
		ans += big[v[u_root][i].first] * v[u_root][i].second;
	}
	return ans;
}

inline void add(int l, int r, int k){
	if (belong[l] == belong[r]){
		for (register int i = l; i <= r; i++){
			small[get_root(i)] += k;
		}
		return;
	}
	for (register int i = l; i <= rt[belong[l]]; i++){
		small[get_root(i)] += k;
	}
	for (register int i = belong[l] + 1; i < belong[r]; i++){
		big[i] += k;
	}
	for (register int i = lft[belong[r]]; i <= r; i++){
		small[get_root(i)] += k;
	}
}

int main(){
	int n, m, k;
	scanf("%d %d", &n, &m);
	block = sqrt(n);
	k = (n - 1) / block + 1;
	init(n);
	for (register int i = 1; i <= k; i++){
		lft[i] = block * (i - 1) + 1;
		rt[i] = min(i * block, n);
	}
	for (register int i = 1; i <= m; i++){
		int op;
		scanf("%d", &op);
		if (op != 2){
			int x;
			scanf("%d", &x);
			if (op == 1){
				int y;
				scanf("%d", &y);
				merge(x, y);
			} else {
				cout << query(x) << endl;
			}
		} else {
			int l, r, a;
			scanf("%d %d %d", &l, &r, &a);
			add(l, r, a);
		}
	}
	return 0;
}
```

---

## 作者：Nine_Suns (赞：1)

题面很好理解。

对于加边，用并查集的方式维护，并赋予每个连通块一个编号。考虑分块，$cnt_{i,j}$ 表示第 $i$ 块内属于编号为 $j$ 的连通块的点的数量，$s_{i,j}$ 表示第 $i$ 块内属于编号为 $j$ 的连通块的点的人口数量和（不包含懒标记增加的值），$ad_i$ 表示对整个块加的懒标记。

那么，在连边操作时，只需将所有块 $x$ 的 $s$ 和$cnt$ 合并到 $y$ 的 $s$ 和 $cnt$ 即可.增加时，散块遍历，根据每个点的连通块编号修改该块的 $s$，整块直接增加 $ad$ 即可。查询时，每个块的贡献为 $s+cnt\times ad$，即原本的和加上整体加的值乘块内的点数量。

但是这样有一个问题，空间为 $O(n\sqrt n)$，容易发现本题的所有操作对于每个块是独立的，即对一个大区间的修改或查询可以拆成对许多块的修改或查询，所以逐块处理，空间复杂度就降到了 $O(n)$。

常数原因，代码在块长大时跑得更快。

```cpp
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
const int N = 2e5+5, B = 950, b = 860;
int n, m, cnt[N], bi[N], bl[N], br[N], f[N];
ll s[N], ad, ans[N];
struct que {
	int op, x, y, w;
}qs[N];

inline int find (int x) { return x == f[x] ? x : f[x] = find(f[x]); }

int main () {
//	ios::sync_with_stdio(false);
//	cin.tie(0); cout.tie(0);
	scanf("%d%d", &n, &m);
	bi[n] = (n-1)/b+1;
	for (int i = 1;i <= bi[n];i++) {
		bl[i] = br[i-1]+1, br[i] = br[i-1]+b; if (br[i] > n) br[i] = n;
		for (int j = bl[i];j <= br[i];j++) bi[j] = i; 
	}
	for (int i = 1;i <= m;i++) {
		int op, x, y, w; scanf("%d%d", &op, &x);
		if (op == 1) scanf("%d", &y);
		else if (op == 2) scanf("%d%d", &y, &w);
		qs[i] = (que){op, x, y, w};
	}
	for (int i = 1;i <= bi[n];i++) {
		memset(cnt, 0, sizeof(cnt)); memset(s, 0, sizeof(s)); ad = 0;
		for (int j = bl[i];j <= br[i];j++) cnt[j]++;
		for (int j = 1;j <= n;j++) f[j] = j; 
		for (int j = 1;j <= m;j++) {
			if (qs[j].op == 1) {
				int x = find(qs[j].x), y = find(qs[j].y);
				if (x != y) {
					s[y] += s[x]; s[x] = 0;
					cnt[y] += cnt[x]; cnt[x] = 0;
				}
				f[x] = y;
			}
			else if (qs[j].op == 2) {
				if (bi[qs[j].x] == i && bi[qs[j].y] == i) {
					for (int z = qs[j].x;z <= qs[j].y;z++) s[find(z)] += qs[j].w;
				}
				else if (bi[qs[j].x] < i && i < bi[qs[j].y]) ad += qs[j].w;
				else if (i == bi[qs[j].x]) {
					for (int z = qs[j].x;z <= br[i];z++) s[find(z)] += qs[j].w;
				}
				else if (i == bi[qs[j].y]) {
					for (int z = bl[i];z <= qs[j].y;z++) s[find(z)] += qs[j].w;
				}
			}
			else {
				int x = find(qs[j].x);
				ans[j] += s[x]+ad*cnt[x];
			}
		}
	}
	for (int i = 1;i <= m;i++) {
		if (qs[i].op == 3) printf("%lld\n", ans[i]);
	}
	return 0;
}
```


---

## 作者：Semsue (赞：1)

和 @ez_lcw 胡出来的做法，不需要什么高级科技。

先假设没有 $1$ 操作，变成初始给定若干连通块。该问题容易归约为矩阵乘法，$A$ 矩阵每行是一种颜色，$B$ 矩阵每列是一个操作。所以可以直接思考 $O(n\sqrt n)$ 的做法。

通过枚举做法，发现可以序列分块。对于每个块，维护散块加的答案，和整块加的标记。最后查询的时候只需要再维护该块里面某种颜色出现次数。离线后容易做到时间 $O(n\sqrt{n})$，空间 $O(n)$。

如果加上了 $1$ 操作，根据套路，可以通过并查集启发式合并，转变为 $O(n\log n)$ 次单点修改颜色。而我们发现，刚刚做法对于每种颜色都是线性的函数，修改是可以直接修改的。由于要离线所有修改，所以空间复杂度变为 $O(n\log n)$。

实际做的时候由于查询是 $O(\frac{n}{B})$，修改是 $O(B)$，第一种修改是均摊 $O(n\log n)$。所以可以根据相应次数调整块大小以卡常数。

---

## 作者：童年的小翼龙 (赞：1)

首先，操作 3 即询问当前点所存在的连通块内的权值和。发现只有加边操作，于是可以用并查集维护连通块，并在并查集的根处同时记录下当前连通块内的权值和 $sum$。

对于点的权值，~~看到了 lxl，所以~~ 考虑分块。我们记块长为 $B=\sqrt{n}$，总块个数为 $cont$，并在每个并查集的根处记录当前连通块在每个块中有几个点，并查集 $i$ 在块 $j$ 中的点的个数记作 $num_{i,j}$。在更新操作的时候，我们对于整块的点直接打 $tag$，对于单点直接修改其所处的联通块的 $sum$，于是单次修改操作是 $O(\sqrt{n})$ 的。

在查询的时候，先找到当前点 $x$ 所属的并查集的根 $fx$，发现答案是 $sum_{fx}+\sum_{i=1}^{cont} num_{fx,i}tag_i$，于是查询也是 $O(\sqrt{n})$ 的。

然而，由于上述的做法需要对每个并查集都记录所有块中的点数，空间复杂度（即 $num$ 数组的大小）是 $O(n\sqrt{n})$ 的。  
然而，对于并查集 $i$，若其大小 $size_i < B$，我们可以直接暴力遍历其中的所有点。于是我们可以用根号分治的思想，对于 $size_i < B$ 的连通块，用链表记录连通块内的所有点，合并的时候直接 $O(1)$ 合并链表。具体的，我们记录下每个链表的 $head$ 和 $tail$，合并时直接让其中一个的 $tail$ 的 $next$ 指向另一个的 $head$ 即可。  
若合并完之后 $size_i \ge B$，则为其分配一个具有 $id$，用于在 $num$ 数组中存储每个块中的点数。易知这样的连通块数量不超过 $\sqrt{n}$ 个，所以 $num$ 数组大小开 $\sqrt{n}\times \sqrt{n}$，空间复杂度为 $O(n)$。

赛时 Code:
```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Slongod{
const int N = 2e5+7 , S = 605;
int n , m , len , cont;
int fst[N] , lst[N] , belong[N];
using ll = long long;
int id[N] , fa[N] , size[N] , num[S][S] , idcnt;
ll sum[N] , tag[N];
int nxt[N] , to[N] , head[N] , tail[N] , cnt;
void pushback(int x , int val){cnt++; nxt[cnt] = head[x]; head[x] = cnt; to[cnt] = val; if (!nxt[cnt]){tail[x] = cnt;}}
void init()
{
    for (int i = 1 , cnt = len + 1; i <= n; i++ , cnt++)
    {
        if (cnt > len){cnt = 1; cont++;}
        belong[i] = cont;
        if (cnt == 1){fst[cont] = i;}
        if (cnt == len or i == n){lst[cont] = i;}
    }
    for (int i = 1; i <= n; i++){size[i] = 1; fa[i] = i; pushback(i , i);}
}
int find(int x){return fa[x] == x ? x : fa[x] = find(fa[x]);}
void merge(int x , int y)
{
    int fx = find(x) , fy = find(y);
    if (fx == fy){return;}

    if (size[fx] > size[fy]){swap(fx , fy);}
    if (size[fx] >= len and size[fy] >= len)
    {
        for (int i = 1; i <= cont; i++){num[id[fy]][i] += num[id[fx]][i];}
    }
    else if (size[fy] >= len)
    {
        for (int i = head[fx]; i; i = nxt[i]){num[id[fy]][belong[to[i]]]++;}
    }
    else
    {
        int t = tail[fy];
        nxt[t] = head[fx];
        tail[fy] = tail[fx];
        if (size[fy] + size[fx] >= len)
        {
            id[fy] = ++idcnt;
            for (int i = head[fy]; i; i = nxt[i])
            {
                num[id[fy]][belong[to[i]]]++;
            }
        }
    }
    fa[fx] = fy; size[fy] += size[fx]; sum[fy] += sum[fx];
}
void update(int l , int r , int val)
{
    if (belong[l] == belong[r]){for (int i = l; i <= r; i++){int x = find(i); sum[x]+=val;}}
    else
    {
        for (int i = l; i <= lst[belong[l]]; i++){int x = find(i); sum[x]+=val;}
        for (int i = belong[l]+1; i < belong[r]; i++){tag[i]+=val;}
        for (int i = fst[belong[r]]; i <= r; i++){int x = find(i); sum[x]+=val;}
    }
}
ll query(int x)
{
    x = find(x);
    ll re = sum[x];
    if (size[x] >= len){for (int i = 1; i <= cont; i++){re += tag[i] * num[id[x]][i];}}
    else{for (int i = head[x]; i; i = nxt[i]){re += tag[belong[to[i]]];}}
    return re;
}
int main()
{
    cin >> n >> m; len = 500; init();
    for (int i = 1 , opt , l , r , a; i <= m; i++)
    {
        // if (i % 1000 == 0)cerr << i << '\n';
        cin >> opt;
        if (opt == 1){cin >> l >> r; merge(l ,r);}
        else if (opt == 2){cin >> l >> r >> a; update(l , r , a);}
        else{cin >> a; cout << query(a) << '\n';}
    }
    return 0;
}
}int main()
{
    #ifndef ONLINE_JUDGE
    freopen("in.in" , "r" , stdin);
    freopen("out.out" , "w" , stdout);
    #endif
    ios :: sync_with_stdio(0);
    cin.tie(0) , cout.tie(0);
    return Slongod :: main();
}
```

---


# BZOJ4372 烁烁的游戏

## 题目背景

题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。

---

烁烁很喜欢爬树，这吓坏了树上的皮皮鼠。

给定一颗 $n$ 个节点的树，边权均为 $1$，初始树上没有皮皮鼠。

烁烁他每次会跳到一个节点 $u$ ，把周围与他距离不超过 $d$ 的节点各吸引出 $w$ 只皮皮鼠。皮皮鼠会被烁烁吸引，所以会一直待在节点上不动。

烁烁很好奇，在当前时刻，节点 $u$ 有多少个他的好朋友——皮皮鼠。

## 题目描述

题目背景可以被抽象成这个问题：

给一棵 $n$ 个结点的树，边权均为 $1$，初始点权均为 $0$。进行 $m$ 次操作：
- $\text{Q x}$：询问结点 $x$ 的点权。
- $\text{M x d w}$：将树上与结点 $x$ 距离不超过 $d$ 的节点的点权均加上 $w$。

## 说明/提示

对于所有数据，保证 $1\leq n,m\leq 10^5$，$|w|\leq 10^4$。注意：$w$ 不一定为正整数，

## 样例 #1

### 输入

```
7 6
1 2
1 4
1 5
2 3
2 7
5 6
M 1 1 2
Q 5
M 2 2 3
Q 3
M 1 2 1
Q 2```

### 输出

```
2
3
6```

# 题解

## 作者：Xiao_Xiao_Yu (赞：2)

# P10603 烁烁的游戏 题解

题意：给定一棵 $n$ 个点带权的树（边权均为 $1$），初始所有点权为 $0$。给出 $m$ 次操作：询问一个点的点权，或修改距离一个点不超过 $d$ 的所有点的点权。

## 前置知识

建议先完成以下知识点的题目再来挑战本题。

**树状数组**：见 [P3374](https://www.luogu.com.cn/problem/P3374)
及 [P3368](https://www.luogu.com.cn/problem/P3368)。

**点分树**：见 [P6329](https://www.luogu.com.cn/problem/P6329)。

## 分析

本题与 P6329 的任务要求和解法都较为相似，不过该题为单点修改、区间查询，而本题为区间修改，单点查询。这里的区间实际上指的是树上连通块。

涉及维护树上连通块信息的问题优先考虑使用点分树解决，按照点分树的常见套路，在每个点上建立数据结构维护信息，在修改/查询时遍历节点在点分树上的祖先并修改/查询这些点上的数据结构信息。通常实际上需要建立多个数据结构，用容斥原理防止部分答案被重复计算。

对于本题，因为我们不便直接修改整个连通块内所有节点的信息，所以我们使用「标记」的思想：进行修改操作时仅在输入的节点 $x$ 处打上一个标记，并使得在查询时能够根据所有的标记算出累计的影响。点分树上遍历祖先的操作恰好达到了这一目的。

## 思路

在每个点上建立两个树状数组 $c_{i_0},c_{i_1}$ 维护节点 $i$ 的点分子树中的节点受到修改的影响。这里我们利用树状数组维护差分数组的技巧，$c_{i_0}$ 的前缀和 $\sum_{j=0}^{k}c_{i_0,j}$ 维护的是节点 $i$ 的点分子树中与节点 $i$ **在原树上的距离**不超过 $k$ 的节点受到的累计影响，$c_{i_1}$ 的前缀和 $\sum_{j=0}^{k}c_{i_1,j}$ 维护的是节点 $i$ 的点分子树中与节点 $i$ 的**点分父节点**在原树上的距离不超过 $k$ 的节点受到的累计影响。

进行修改操作时，首先对 $c_{x_0}$ 进行区间修改，在 $[0,k]$ 的值域上加上 $w$（由于是差分数组，实际只需进行 $2$ 次单点修改即可）。然后遍历 $x$ 的所有点分祖先，对祖先 $u$ 在 $c_{u_0}$ 的 $[0,k-\text{dis}(x,u)]$ 的值域上加上 $w$，其中 $\text{dis}(x,u)$ 表示 $x$ 与 $u$ 在原树上的距离。注意到此时重复计算了 $u$ 的 $x$ 方向上的子树内那一部分的答案，所以需要在 $c_{x_1}$ 的 $[0,k-\text{dis}(x,u)]$ 值域上减去 $w$。

查询操作则更简单，直接遍历 $x$ 的所有点分祖先 $u$，累加 $c_{u_0}$ 的前缀和 $\text{ask}(c_{u_0},\text{dis}(u, x))$ 和 $c_{u_1}$ 的前缀和 $\text{ask}(c_{u_1},\text{dis}(fa_u, x))$ 即可。其中 $fa_u$ 表示 $u$ 在点分树上的父亲。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e5 + 5;

int n, m, x, k, w, ans;
char s[3];
int sum, siz[maxn], weight[maxn], root, fa[maxn];
bool vis[maxn];
vector<int> g[maxn];
vector<int> c[maxn][2];
int d[maxn], f[maxn][20];

void dfs(int u) {
	for (int v : g[u]) {
		if (d[v]) continue;
		d[v] = d[u] + 1;
		f[v][0] = u;
		for (int i = 1; i <= 18; ++i) 
			f[v][i] = f[f[v][i - 1]][i - 1];
		dfs(v);
	}
}

int lca(int x, int y) {
	if (d[x] < d[y]) swap(x, y);
	for (int i = 18; i >= 0; --i)
		if (d[f[x][i]] >= d[y]) x = f[x][i];
	if (x == y) return x;
	for (int i = 18; i >= 0; --i)
		if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];
	return f[x][0];
}

int dist(int x, int y) {
	return d[x] + d[y] - 2 * d[lca(x, y)];
}

void add(vector<int> &c, int y, int d) {
	for (; y < c.size(); y += (y & -y)) {
		c[y] += d;
	}
}

void add(vector<int> &c, int l, int r, int d) {
	add(c, l + 1, d);
	add(c, r + 2, -d);
}

int ask(vector<int> &c, int y) {
	++y;
	int res = 0;
	for (; y; y -= (y & -y)) 
		if (c.size() > y) res += c[y]; 
	return res;
}

void calcsize(int u, int fa) {
	siz[u] = 1;
	weight[u] = 0;
	for (int v : g[u]) {
		if (v == fa || vis[v]) continue;
		calcsize(v, u);
		siz[u] += siz[v];
		weight[u] = max(weight[u], siz[v]);
	}
	weight[u] = max(weight[u], sum - siz[u]);
	if (weight[root] > weight[u]) root = u;
}

void build(int u) {
	c[u][0].resize(siz[u] + 10);
	vis[u] = true;
	for (int v : g[u]) {
		if (vis[v]) continue;
		sum = siz[v];
		root = 0;
		calcsize(v, 0);
		calcsize(root ,0);
		fa[root] = u;
		c[root][1].resize(siz[root] + 10);
		build(root);
	}
}

int main() {
	scanf("%d %d", &n, &m);
	for (int i = 1, u, v; i < n; ++i) {
		scanf("%d %d", &u, &v);
		g[u].push_back(v);
		g[v].push_back(u);
	}
	d[1] = 1;
	dfs(1);
	sum = n;
	weight[root = 0] = 0x3fffffff;
	calcsize(1, 0);
	calcsize(root, 0);
	build(root);
	while (m--) {
		scanf("%s %d", s, &x);
		if (s[0] == 'Q') {
			ans = ask(c[x][0], 0);
			for (int p = x; fa[p]; p = fa[p]) {
				ans += ask(c[fa[p]][0], dist(fa[p], x));
				ans += ask(c[p][1], dist(fa[p], x));
			}
			printf("%d\n", ans);
		} else {
			scanf("%d %d", &k, &w);
			add(c[x][0], 0, k, w);
			for (int p = x; fa[p]; p = fa[p]) {
				int d = dist(fa[p], x);
				if (k < d) continue; 
				add(c[fa[p]][0], 0, k - d, w);
				add(c[p][1], 0, k - d, -w);
			}
		}
	}
	return 0;
}
```

---

## 作者：Genius_Star (赞：1)

### 思路：

注意到有**对距离不超过 $d$ 的点**修改，考虑点分树。

修改操作：

- 类似标记永久化，令 $rt_{u,0/1,i}$ 表示将点分树上 $u$ 子树内与 $u$ 或 $fa_u$ 原树距离为 $i$ 增加的值。

- 注意到 $rt$ 是区间修改，单点查询，可以直接使用树状数组维护差分数组（毕竟线段树常数较大），然后用 `vector` 动态开空间。

- 假设对距离 $x$ 不超过 $k$ 的点的权值加上 $w$：

  - 初始肯定要将 $u$ 子树内距离为 $[0,k]$ 的点的权值加上。
  
  - 然后暴力跳父亲，令 $d$ 为 $dis(x,fa_i)$。
  
  - 先将 $fa_i$ 子树内距离为 $[0,k-d]$ 的点的权值加上。
  
  - 注意到会将 $u$ 子树内到 $fa_i$ 距离为 $[0,k-d]$ 的点算重，将贡献减去即可。
  
查询操作：

- 暴力跳父亲，加上路径上的操作权值即可。

时间复杂度为 $O(N \log^2 N)$，空间复杂度为 $O(N \log N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define Full(a) memset(a,0,sizeof(a))
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
using namespace std;
typedef double db;
typedef long long ll;
const ll N=100100,M=17;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
inline char get(){
	char c;
	while(1){
		c=getchar();
		if(c=='Q'||c=='M')
		  break;
	}
	return c;
}
class Seg_Tree{
public:
	vector<ll> a[N][2];
	void init(ll x,ll y,bool f){
		a[x][f].resize(y);
	}
	void add(ll x,bool f,ll i,ll w){
		if(i>=a[x][f].size())
		  return ;
		for(int j=i;j<a[x][f].size();j+=lowbit(j))
		  a[x][f][j]+=w;
	}
	void update(ll x,bool f,ll l,ll r,ll w){
		add(x,f,l+1,w);
		add(x,f,r+2,-w);
	}
	ll query(ll x,bool f,ll i){
		i++;
		if(i>=a[x][f].size())
		  return 0;
		ll ans=0;
		for(int j=i;j;j-=lowbit(j))
		  ans+=a[x][f][j];
		return ans;
	}
}T;
char op;
ll n,m,x,y,z;
vector<ll> E[N];
void add(ll u,ll v){
	E[u].push_back(v);
	E[v].push_back(u);
}
namespace LCA{
	ll siz[N],z[N],t[N],d[N],fa[N];
	void dfs1(ll u,ll f){
		siz[u]=1;
		for(auto v:E[u]){
			if(v==f)
			  continue;
			d[v]=d[u]+1;
			fa[v]=u;
			dfs1(v,u);
			siz[u]+=siz[v];
			if(siz[v]>siz[z[u]])
			  z[u]=v;
		}
	}
	void dfs2(ll u,ll k){
		t[u]=k;
		if(!z[u])
		  return ;
		dfs2(z[u],k);
		for(auto v:E[u]){
			if(v==fa[u]||v==z[u])
			  continue;
			dfs2(v,v);
		}
	}
	ll Lca(ll u,ll v){
		while(t[u]!=t[v]){
			if(d[t[u]]<d[t[v]])
			  swap(u,v);
			u=fa[t[u]];
		}
		return d[u]<d[v]?u:v;
	}
	ll dis(ll u,ll v){
		return d[u]+d[v]-2ll*d[Lca(u,v)];
	}
	void init(){
		dfs1(1,1);
		dfs2(1,1);
	}
};
namespace Tree{
	ll sum,Max,root;
	ll siz[N],dep[N],fa[N];
	ll dis[N][M];
	bool del[N];
	void getroot(ll u,ll fa){
		ll s=0;
		siz[u]=1;
		for(auto v:E[u]){
			if(del[v]||v==fa)
			  continue;
			getroot(v,u);
			siz[u]+=siz[v];
			s=max(s,siz[v]);
		}
		s=max(s,sum-siz[u]);
		if(s<Max){
			Max=s;
			root=u;
		}
	}
	void Get(ll u,ll s){
		root=u;
		sum=Max=s;
		getroot(u,0);
		getroot(root,0);
	}
	void solve(ll u){
		T.init(u,siz[u]+3,0);
		del[u]=1;
		for(auto v:E[u]){
			if(del[v])
			  continue;
			Get(v,siz[v]);
			fa[root]=u;
			dep[root]=dep[u]+1;
			T.init(root,siz[root]+3,1);
			solve(root);
		}
	}
	void init(){
		LCA::init();
		Get(1,n);
		solve(root);
		for(int i=1;i<=n;i++)
		  for(int j=i;j;j=fa[j])
		    dis[i][dep[i]-dep[j]]=LCA::dis(i,j);
	}
	ll query(ll x){
		ll ans=T.query(x,0,0);
		for(ll i=x;fa[i];i=fa[i]){
			ll d=dis[x][dep[x]-dep[fa[i]]];
			ans+=T.query(fa[i],0,d);
			ans+=T.query(i,1,d);
		}
		return ans;
	}
	void update(ll x,ll k,ll w){
		T.update(x,0,0,k,w);
		for(ll i=x;fa[i];i=fa[i]){
			ll d=dis[x][dep[x]-dep[fa[i]]];
			if(k<d)
			  continue;
			T.update(fa[i],0,0,k-d,w);
			T.update(i,1,0,k-d,-w);
		}
	}
};
int main(){
	n=read(),m=read();
	for(int u,v,i=1;i<n;i++){
		u=read(),v=read();
		add(u,v);
	}
	Tree::init();
	while(m--){
		op=get(),x=read();
		if(op=='Q'){
			write(Tree::query(x));
			putchar('\n');
		}
		else{
			y=read(),z=read();
			Tree::update(x,y,z);
		}
	}
	return 0;
}
```

---

## 作者：aulive (赞：1)

## solutin

看到对树上距离不超过 $d$ 的节点进行修改，很容易想到到点分树。\
因为点分树上 $x$ 与 $y$ 的最近公共祖先在原树上 $x$ 到 $y$ 的路径上\
在修改时，沿着节点 $x$ 在点分树上跳父亲结点，在每一个节点上开一个线段树在 $x$ 到其他子树的最远距离处加上 $w$。\
在查询时，沿着节点 $x$ 在点分树上跳父亲结点，线段树上查找当前子树内大于 $x$ 到当前节点的距离的权值和即可。\
为了防止祖父节点重复计算贡献，考虑对于每个节点再开一个线段树存储当前子树内的信息，查询时减去即可。

## code
时空复杂度都是 $O(n {\log_2}^2 n)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5;
vector <int> rood[maxn+5];
int dept[maxn+5],pre[maxn+5][17];
int n,m,x,y;
struct sgmenttree{//动态开点线段树
	int tot;
	struct node{
		int ls,rs,sum;
	}tree[maxn*256];
	void pushup(int now){
		tree[now].sum=tree[tree[now].ls].sum+tree[tree[now].rs].sum;
	}
	void modify(int &now,int lef,int rig,int to,int add){
		if(!now)now=++tot;
		if(lef==rig){
			tree[now].sum+=add;
			return;
		}
		int mid=lef+rig>>1;
		if(to<=mid)modify(tree[now].ls,lef,mid,to,add);
		else modify(tree[now].rs,mid+1,rig,to,add);
		pushup(now);
	}
	int query(int now,int lef,int rig,int l,int r){
		if(!now)return 0;
		if(l<=lef&&rig<=r){
			return tree[now].sum;
		}
		int mid=lef+rig>>1;
		int res=0;
		if(l<=mid)res+=query(tree[now].ls,lef,mid,l,r);
		if(mid<rig)res+=query(tree[now].rs,mid+1,rig,l,r);
		return res;
	}
}tree1,tree2;
void dfs(int now,int fa){
	dept[now]=dept[fa]+1; 
	pre[now][0]=fa;
	for(int to:rood[now]){
		if(to==fa)continue;
		dfs(to,now);
	}
}
void prepare(){
	for(int k=1;k<=16;k++){
		for(int i=1;i<=n;i++){
			pre[i][k]=pre[pre[i][k-1]][k-1];
		}
	}
}
int LCA(int x,int y){
	if(x==y)return x;
	if(dept[x]<dept[y])swap(x,y);
	for(int k=16;k>=0;k--){
		if(dept[pre[x][k]]>=dept[y]){
			x=pre[x][k];
		}
	}
	if(x==y)return x;
	for(int k=16;k>=0;k--){
		if(pre[x][k]!=pre[y][k]){
			x=pre[x][k];
			y=pre[y][k];
		}
	}
	return pre[x][0];
}
int dis(int x,int y){
	return dept[x]+dept[y]-2*dept[LCA(x,y)];
}
vector <int> G[maxn+5];
int dp[maxn+5],size[maxn+5],sum,vis[maxn+5],root;
void work(int now,int fa){
	size[now]=1;dp[now]=0;
	for(int to:rood[now]){
		if(vis[to]||to==fa)continue;
		work(to,now);
		size[now]+=size[to];
		dp[now]=max(dp[now],size[to]);
	}
	dp[now]=max(dp[now],sum-size[now]);
	if(!root||dp[root]>dp[now]){
		root=now;
	}
}
int rt1[maxn+5],rt2[maxn+5],f[maxn+5];
void solve(int now){
	vis[now]=1;
	for(int to:rood[now]){
		if(vis[to])continue;
		root=0;
		sum=size[to];
		work(to,now);
		f[root]=now;
		solve(root);
	}
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n>>m;
	for(int i=1;i<n;i++){
		cin>>x>>y;
		rood[x].push_back(y);
		rood[y].push_back(x);
	}
	dfs(1,0);
	prepare();
	sum=n;root=0;
	work(1,0);
	solve(root);
	while(m--){
		char opt;
		cin>>opt;
		if(opt=='M'){
			int x,d,w;
			cin>>x>>d>>w;
			int son=0;
			for(int now=x;now;now=f[now]){
				int distance=dis(x,now);
				if(d-distance>=0){
					tree1.modify(rt1[now],0,n-1,d-distance,w);
					if(son){
						tree2.modify(rt2[son],0,n-1,d-distance,w);
					}
				}
				son=now;
			}
		}else{
			int x;
			cin>>x;
			int ans=0;
			for(int now=x;now;now=f[now]){
				int distance=dis(x,now);
				ans+=tree1.query(rt1[now],0,n-1,distance,n-1);
				int fa=f[now];
				if(fa){
					distance=dis(x,fa);
					ans-=tree2.query(rt2[now],0,n-1,distance,n-1);
				}
			}
			cout<<ans<<"\n";
		}
	}
	return 0;
}
```
~~**人傻常数大**~~

---

## 作者：hzoi_Shadow (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10603)

# 前置知识

[动态树分治](https://oi-wiki.org//graph/dynamic-tree-divide/) | [动态开点线段树](https://oi-wiki.org//ds/seg/#%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E7%BA%BF%E6%AE%B5%E6%A0%91) | 标记永久化

# 解法

考虑动态点分治。

两种操作本质上是将 [luogu P6329 【模板】点分树 | 震波](https://www.luogu.com.cn/problem/P6329) 的操作互换了下，将原需支持单点修改、区间查询的数据结构换成需支持区间修改、单点查询的数据结构即可。

区间修改、单点查询的动态开点线段树可以考虑标记永久化。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define ull unsigned long long
#define sort stable_sort 
#define endl '\n'
struct node
{
	int nxt,to;
}e[200010];
int head[200010],ask,cnt=0;
void add(int u,int v)
{
	cnt++;
	e[cnt].nxt=head[u];
	e[cnt].to=v;
	head[u]=cnt;
}
struct LCA
{
	int siz[200010],fa[200010],dep[200010],son[200010],top[200010];
	void init()
	{
		dfs1(1,0);
		dfs2(1,1);
	}
	void dfs1(int x,int father)
	{
		siz[x]=1;
		fa[x]=father;
		dep[x]=dep[father]+1;
		for(int i=head[x];i!=0;i=e[i].nxt)
		{
			if(e[i].to!=father)
			{
				dfs1(e[i].to,x);
				siz[x]+=siz[e[i].to];
				son[x]=(siz[e[i].to]>siz[son[x]])?e[i].to:son[x];
			}
		}
	}
	void dfs2(int x,int id)
	{
		top[x]=id;
		if(son[x]!=0)
		{
			dfs2(son[x],id);
			for(int i=head[x];i!=0;i=e[i].nxt)
			{
				if(e[i].to!=son[x]&&e[i].to!=fa[x])
				{
					dfs2(e[i].to,e[i].to);
				}
			}
		}
	}
	int lca(int u,int v)
	{
		while(top[u]!=top[v])
		{
			if(dep[top[u]]>dep[top[v]])
			{
				u=fa[top[u]];
			}
			else
			{
				v=fa[top[v]];
			}
		}
		return (dep[u]<dep[v])?u:v;
	}
	int get_dis(int x,int y)
	{
		return dep[x]+dep[y]-2*dep[lca(x,y)];
	}
}L;
struct SMT
{
	int root[200010],rt_sum=0;
	struct SegmentTree
	{
		int ls,rs,lazy;
	}tree[200010<<5];
	#define lson(rt) (tree[rt].ls)
	#define rson(rt) (tree[rt].rs)
	int build_rt()
	{
		rt_sum++;
		lson(rt_sum)=rson(rt_sum)=tree[rt_sum].lazy=0;
		return rt_sum;
	}
	void update(int &rt,int l,int r,int x,int y,int val)
	{	
		if(rt==0)
		{
			rt=build_rt();
		}
		if(x<=l&&r<=y)
		{		
			tree[rt].lazy+=val;
			return;
		}
		int mid=(l+r)/2;
		if(x<=mid)
		{
			update(lson(rt),l,mid,x,y,val);
		}
		if(y>mid)
		{
			update(rson(rt),mid+1,r,x,y,val);
		}
	}
	int query(int rt,int l,int r,int pos)
	{
		if(rt==0)
		{
			return 0;
		}
		if(l==r)
		{
			return tree[rt].lazy;
		}
		int mid=(l+r)/2;
		if(pos<=mid)
		{
			return query(lson(rt),l,mid,pos)+tree[rt].lazy;
		}
		else
		{
			return query(rson(rt),mid+1,r,pos)+tree[rt].lazy;
		}
	}
}T[2];
struct Divide_On_Tree
{
	int siz[200010],weight[200010],vis[200010],fa[200010],center=0;
	void init(int n)
	{
		center=0;
		get_center(1,0,n);
		get_siz(center,0);
		build(center);
	}
	void get_center(int x,int fa,int n)
	{
		siz[x]=1;
		weight[x]=0;
		for(int i=head[x];i!=0;i=e[i].nxt)
		{
			if(e[i].to!=fa&&vis[e[i].to]==0)
			{
				get_center(e[i].to,x,n);
				siz[x]+=siz[e[i].to];
				weight[x]=max(weight[x],siz[e[i].to]);
			}
		}
		weight[x]=max(weight[x],n-siz[x]);
		if(weight[x]<=n/2)
		{
			center=x;
		}
	}
	void get_siz(int x,int fa)
	{
		siz[x]=1;
		for(int i=head[x];i!=0;i=e[i].nxt)
		{
			if(e[i].to!=fa&&vis[e[i].to]==0)
			{
				get_siz(e[i].to,x);
				siz[x]+=siz[e[i].to];
			}
		}
	}
	void build(int x)
	{
		vis[x]=1;
		for(int i=head[x];i!=0;i=e[i].nxt)
		{
			if(vis[e[i].to]==0)
			{
				center=0;
				get_center(e[i].to,0,siz[e[i].to]);
				get_siz(center,0);
				fa[center]=x;
				build(center);
			}
		}
	}
	void update(int x,int k,int val)
	{
		T[0].update(T[0].root[x],0,ask,0,k,val);
		for(int rt=x;fa[rt]!=0;rt=fa[rt])
		{
			if(L.get_dis(fa[rt],x)<=k)
			{
				T[0].update(T[0].root[fa[rt]],0,ask,0,k-L.get_dis(fa[rt],x),val);
				T[1].update(T[1].root[rt],0,ask,0,k-L.get_dis(fa[rt],x),val);
			}
		}
	}
	int query(int x)
	{
		int ans=T[0].query(T[0].root[x],0,ask,0);
		for(int rt=x;fa[rt]!=0;rt=fa[rt])
		{
			ans+=T[0].query(T[0].root[fa[rt]],0,ask,L.get_dis(fa[rt],x));
			ans-=T[1].query(T[1].root[rt],0,ask,L.get_dis(fa[rt],x));
		}
		return ans;
	}
}D;
int main()
{
	int n,m,u,v,x,d,w,i;
	char pd;
	cin>>n>>m;
	ask=n;
	for(i=1;i<=n-1;i++)
	{
		cin>>u>>v;
		add(u,v);
		add(v,u);
	}
	L.init();
	D.init(n);
	for(i=1;i<=m;i++)
	{
		cin>>pd;
		if(pd=='Q')
		{
			cin>>x;
			cout<<D.query(x)<<endl;
		}
		else
		{
			cin>>x>>d>>w; 
			D.update(x,d,w);
		}
	}
	return 0;
}
```

---

## 作者：IkunTeddy (赞：0)

# 题目大意

带修树上邻域问题，优先考虑点分树。

在修改和查询爬点分祖先链查询或更新即可。由于查询的信息是一个区间信息，所以线段树维护即可。

思路比较简单，代码注意一下细节即可。

时间复杂度 $O(n\log^2{n})$。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
//
const int maxn=2e5+10;
int n,m;
struct Edge{
	int v,next;
}edge[maxn<<1];
int head[maxn],tot;
void add_edge(int u,int v){
	edge[++tot].v=v;
	edge[tot].next=head[u];
	head[u]=tot;
}
int fa[maxn],dfn[maxn],dep[maxn],Log[maxn],st[maxn][20];
void dfs(int u,int f){
	fa[u]=f;
	dep[u]=dep[fa[u]]+1;
	dfn[u]=++dfn[0];
	for(int i=head[u];i;i=edge[i].next){
		int v=edge[i].v;
		if(v==fa[u])continue ;
		dfs(v,u);
	}
}
int get(int x,int y){return dfn[x]<dfn[y]?x:y;}
void init_ST(){
	Log[0]=-1;
	for(int i=1;i<=n;i++)Log[i]=Log[i>>1]+1;
	for(int i=1;i<=n;i++)st[dfn[i]][0]=fa[i];
	for(int j=1;j<=Log[n];j++){
		for(int i=1;i+(1<<j)-1<=n;i++){
			st[i][j]=get(st[i][j-1],st[i+(1<<j-1)][j-1]);
		}
	}
}
int LCA(int x,int y){
	if(x==y)return x;
	if(dfn[x]>dfn[y])swap(x,y);
	int l=dfn[x]+1,r=dfn[y],k=Log[r-l+1];
	return get(st[l][k],st[r-(1<<k)+1][k]);
}
int dist(int x,int y){return dep[x]+dep[y]-2*dep[LCA(x,y)];}
//
int rt,sz[maxn],mxsz[maxn],vis[maxn];
void findrt(int u,int fa,int all){
	sz[u]=1,mxsz[u]=0;
	for(int i=head[u];i;i=edge[i].next){
		int v=edge[i].v;
		if(v==fa||vis[v])continue ;
		findrt(v,u,all);
		mxsz[u]=max(mxsz[u],sz[v]);
		sz[u]+=sz[v];
	}
	mxsz[u]=max(mxsz[u],all-sz[u]);
	if(mxsz[u]<mxsz[rt])rt=u;
}
void build(int u){
	vis[u]=1;
	for(int i=head[u];i;i=edge[i].next){
		int v=edge[i].v;
		if(vis[v])continue ;
		rt=0;
		findrt(v,0,sz[v]);
		fa[rt]=u;
		build(rt);
	}
}
//
struct node{
	int ls,rs;
	int s;
}tree[maxn*60];
int rt1[maxn],rt2[maxn],nodecnt;
void pushup(int v){
	tree[v].s=tree[tree[v].ls].s+tree[tree[v].rs].s;
}
void update(int &v,int l,int r,int x,int k){
	if(x<l||x>r)return ;
	if(!v)v=++nodecnt;
	if(l==r){
		tree[v].s+=k;
		return ;
	}
	int mid=(l+r)>>1;
	if(x<=mid)update(tree[v].ls,l,mid,x,k);
	else update(tree[v].rs,mid+1,r,x,k);
	pushup(v);
}
int ask(int v,int l,int r,int L,int R){
	if(l>R||r<L)return 0;
	if(l>=L&&r<=R)return tree[v].s;
	int mid=(l+r)>>1,res=0;
	if(L<=mid)res+=ask(tree[v].ls,l,mid,L,R);
	if(R>mid)res+=ask(tree[v].rs,mid+1,r,L,R);
	return res;
}
//
void update(int i,int d,int k){
	for(int x=i;x;x=fa[x]){
		update(rt1[x],0,n,d-dist(i,x),k);
		if(fa[x])update(rt2[x],0,n,d-dist(i,fa[x]),k);
	}
}
int ask(int i){
	int res=tree[rt1[i]].s;
	for(int lst=i,x=fa[i];x;lst=x,x=fa[x]){
		res+=ask(rt1[x],0,n,dist(i,x),n);
		res-=ask(rt2[lst],0,n,dist(i,x),n);
	}
	return res;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		add_edge(u,v);
		add_edge(v,u);
	}
	dfs(1,0);
	init_ST();
	for(int i=1;i<=n;i++)fa[i]=0;
	mxsz[rt=0]=n+1;
	findrt(1,0,n);
	build(rt);
	while(m--){
		char op;
		int x,d,k;
		cin>>op>>x;
		if(op=='Q'){
			cout<<ask(x)<<'\n';
		}else{
			cin>>d>>k;
			update(x,d,k);
		}
	}
	
	return 0;
}
```

---


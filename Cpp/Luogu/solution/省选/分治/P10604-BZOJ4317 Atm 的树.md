# BZOJ4317 Atm 的树

## 题目背景

题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。

---

Atm 有一段时间在虐 qtree 的题目，于是，他满脑子都是 tree，tree，tree……

## 题目描述

于是，一天晚上他梦到自己被关在了一个有根树中，每条路径都有边权，一个神秘的声音告诉他，每个点到其他的点有一个距离，他需要对于每个点回答：从这个点出发的第 $k$ 小距离是多少；

如果 atm 不能回答出来，那么明天 4019 的闹钟将不会响，4019 全寝可能就迟到了，所以 atm 希望你帮帮他。

## 说明/提示

对于所有数据，$1\leq n\leq 15000$，$1\leq k\leq 5000$，$1\leq w\leq 10$。树的根为结点 $1$。

## 样例 #1

### 输入

```
5 2
1 5 2
1 2 4
2 3 6
2 4 5```

### 输出

```
4
5
10
9
6```

# 题解

## 作者：yqr123YQR (赞：2)

### 分析
直接求第 $k$ 小实在比较难，考虑二分答案，即转化为：给定 $u,v$，求 $u$ 出发的路径中，有多少条权值和 $\leqslant v$。

——这不是点分树模板？

同样地，在点分树上，对于点 $i$，暴力记录下点分树上点 $i$ 子树中各点至 $i$ 的路径长。

对于查询“与 $i$ 距离 $\leqslant d$ 的点数”，先在 $i$ 点分树上子树中统计（可以对子树信息排序后用 `upper_bound` 求），接下来考虑该子树外的贡献。

跳祖先时，若从 $f$ 跳到 $p$，$p$ 子树内的贡献即为 $p$ 子树内与 $p$ 距离 $\leqslant d-\operatorname{dist}(p,i)$ 的点数，减去 $f$ 子树内与 $p$ 距离 $\leqslant d-\operatorname{dist}(p,i)$ 的点数。（点 $f$ 子树内的点不应在 $p$ 的子树中再算一遍）

$n$ 次询问，每次二分带个 $\log$，点分树跳祖先带个 $\log$，在点分树上祖先的子树中 `upper_bound` 又带个 $\log$，共计 $O(n\log^3 n)$。

关于对每个点 $i$ 直接分别存子树内点至 $i$ 与 $f_i$（$i$ 的父亲）的距离，因为每个点只会被其祖先各自存 $2$ 次，所以总共也只有 $O(n\log n)$ 级别的空间，开 `vector` 存即可。

### 代码
```cpp
//......
int choose(int a, int b) {return dfn[a] < dfn[b]? a: b;}
void dfs(int k, int pre)
{
	st[0][dfn[k] = ++cnt] = pre;
	for(auto i : g[k]) if(i.to != pre)
		dis[i.to] = dis[k] + i.value, dfs(i.to, k);
}
void init()
{
	dfs(1, 0);
	for(int i = 1; i < maxl; i++)
		for(int j = 1; j + (1 << i) - 1 <= n; j++)
			st[i][j] = choose(st[i - 1][j], st[i - 1][j + (1 << i - 1)]);
}
int lca(int a, int b)
{
	if(a == b) return a;
	if(dfn[a] > dfn[b]) a ^= b ^= a ^= b;
	int len = log2(dfn[b] - dfn[a]);
	return choose(st[len][dfn[a] + 1], st[len][dfn[b] - (1 << len) + 1]);
}//上为 dfn 序求 LCA
int distance(int a, int b) {return dis[a] + dis[b] - 2 * dis[lca(a, b)];}
void calcsize(int k, int pre, int mode)
{
	int mx = 0;
	sz[k] = 1;
	for(auto i : g[k]) if(i.to != pre && !del[i.to])
		calcsize(i.to, k, mode), mx = max(mx, sz[i.to]), sz[k] += sz[i.to];
	mx = max(mx, nown - sz[k]);
	if(mode && rtmx > mx) rtmx = mx, rt = k;
}//算重心
void build(int k)
{
	del[k] = true;
	for(auto i : g[k]) if(!del[i.to])
	{
		rtmx = nown = sz[i.to];
		calcsize(i.to, -1, 1), calcsize(rt, -1, 0);
		f[rt] = k, build(rt);
	}
}//建点分树
int query(int cent, int range)
{
	int ret = std::upper_bound(f1[cent].begin(), f1[cent].end(), range) - f1[cent].begin();
	for(int i = f[cent], pre = cent; i; i = f[pre = i])
	{
		ret += std::upper_bound(f1[i].begin(), f1[i].end(), range - distance(i, cent)) - f1[i].begin();
		ret -= std::upper_bound(f2[pre].begin(), f2[pre].end(), range - distance(i, cent)) - f2[pre].begin();//算贡献时，上一行本不应该包含 pre 子树中的点，所以以 f2 统计算父亲时要减去的贡献
	}
	return ret - 1;//题中的路径不包含单点
}
int main()
{
	rtmx = nown = n = read(), rk = read();
	for(int i = 1, u, v, w; i < n; i++)
	{
		u = read(), v = read(), w = read();
		g[u].push_back({v, w}), g[v].push_back({u, w});
	}
	calcsize(1, -1, 1), calcsize(rt, -1, 0), build(rt);
	init();
	for(int i = 1; i <= n; i++)
	{
		for(int pos = i; pos; pos = f[pos])
		{
			f1[pos].push_back(distance(pos, i));
			if(f[pos]) f2[pos].push_back(distance(f[pos], i));
		}
	}
	for(int i = 1; i <= n; i++) std::sort(f1[i].begin(), f1[i].end()), std::sort(f2[i].begin(), f2[i].end());
	for(int i = 1; i <= n; i++)
	{
		int l = 0, r = n * 10;
		while(l < r)
		{
			int mid = l + r >> 1;
			if(query(i, mid) >= rk) r = mid;
			else l = mid + 1;
		}
		printf("%d\n", l);
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

## 关键词：点分树维护邻域信息
### 思路：
**全局邻域信息**，考虑点分树。

每次建一遍点分树显然不现实，但是发现点分树实际统计的绝大部分信息都和 $i$ （当前查询点）无关，而实际相关的只有 $i$ 的 $\log$ 个祖先。

因此，我们考虑提前把点分树建好，每个点预处理好子树内部的信息，查询时暴力爬 $i$ 的祖先收集信息。

考虑我们在查询时需要什么信息，直接维护答案很难合并，考虑用二分答案转成判定性问题。

此时答案转化小于等于 $mid$ （二分的答案）的路径的数量，因此，我们预处理每一个点 $u$ 所管辖的子树中的每一个点到 $u$ 的距离，每次通过 upper_bound 求出答案。

但是这样会统计重复，原因在于父亲统计了儿子已经统计过的答案，所以在每个点 $u$ 处，还需统计 $u$ 的所有子树到 $fa_u$ 距离。

具体实现看代码吧。
### Code：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const int Maxn = 1.5e4+5;
int _MemoryPool_[Maxn*40], *_NowPointer_ = _MemoryPool_;

namespace EDGE {
	int sz, head[Maxn];
	struct Edge { int next, to, val; } edge[Maxn*2];
	inline void Add_edge(int u, int v, int w) {
		edge[++sz] = {head[u], v, w};
		head[u] = sz;
	}
} using namespace EDGE;

namespace Josh_zmf {
	
	int N, K, *have1[Maxn], *have2[Maxn], rt, sum, top1[Maxn], top2[Maxn];
	int diss[Maxn], size[Maxn], fa[Maxn]; bool vis[Maxn];
	int dfnnum, dfn[Maxn], nfd[Maxn], st[20][Maxn], logg[Maxn];

	inline void dfs(int u, int faa) {
		nfd[dfn[u] = ++dfnnum] = u, st[0][dfn[u]] = faa;
		for(int i=head[u], v; i; i=edge[i].next) {
			if((v=edge[i].to) == faa)	continue;
			diss[v] = diss[u] + edge[i].val, dfs(v, u);
		}
	}

	inline int get(const int &u, const int &v) { return dfn[u] < dfn[v] ?u :v; };

	inline void Build_LCA() {
		dfs(1, 0);
		for(int i=2; i<=N; i++)	logg[i] = logg[i/2] + 1;
		for(int j=1; j<=logg[N]; j++)
			for(int i=1; i+(1<<j)-1<=N; i++)
				st[j][i] = get(st[j-1][i], st[j-1][i+(1<<(j-1))]);
	}

	inline int LCA(int u, int v) {
		if(u == v)	return u;
		if(dfn[u] > dfn[v])	swap(u, v);
		u = dfn[u]+1, v = dfn[v];
		int k = logg[v-u+1];
		return get(st[k][u], st[k][v-(1<<k)+1]);
	}

	inline int dis(int u, int v) { 
		// printf("dis:: u:%d, v:%d, lca:%d, dis:%d\n", u, v, LCA(u, v), diss[u] + diss[v] - 2*diss[LCA(u, v)]);
		return diss[u] + diss[v] - 2*diss[LCA(u, v)]; 
	}
	
	inline void getrt(int u, int faa) {
		static int maxx[Maxn]; 
		maxx[u] = sum - size[u];
		for(int i=head[u], v; i; i=edge[i].next) {
			if((v=edge[i].to)==faa || vis[v])	continue;
			getrt(v, u);
			maxx[u] = max(maxx[u], size[v]);
		}
		if(!rt || maxx[u] < maxx[rt])	rt = u;
	}
	
	inline int getsz(int u, int faa) {
		size[u] = 1;
		for(int i=head[u], v; i; i=edge[i].next) {
			if((v=edge[i].to)==faa || vis[v])	continue;
			size[u] += getsz(v, u);
		}
		return size[u];
	}

	inline void getdis(int u, int faa, int gfa, int diss) {
		have1[gfa][top1[gfa]++] = diss;
		if(fa[gfa])	have2[gfa][top2[gfa]++] = dis(fa[gfa], u);
		for(int i=head[u], v; i; i=edge[i].next) {
			if((v=edge[i].to)==faa || vis[v])	continue;
			getdis(v, u, gfa, diss + edge[i].val);
		}
	}
	
	inline void Build(int u, int faa) {
		sum = getsz(u, 0), rt = 0, getrt(u, 0), vis[u=rt] = 1;
		size[u] = sum, fa[u] = faa;
		have1[u] = _NowPointer_, _NowPointer_ += size[u];
		have2[u] = _NowPointer_, _NowPointer_ += size[u];
		getdis(u, 0, u, 0);
		sort(have1[u], have1[u]+top1[u]);
		sort(have2[u], have2[u]+top2[u]);
		for(int i=head[u], v; i; i=edge[i].next) {
			if(!vis[v=edge[i].to])	Build(v, u);
		}
	}

	inline bool Query(int u, int mid) {
		int res = upper_bound(have1[u], have1[u]+top1[u], mid) - have1[u]-1, pre, uu = u, tmp;
		for(pre=u, u=fa[u]; u; pre=u, u=fa[u]) {
			tmp = dis(u, uu);
			res += upper_bound(have1[u], have1[u]+top1[u], mid-tmp) - have1[u];
			res -= upper_bound(have2[pre], have2[pre]+top2[pre], mid-tmp) - have2[pre];
		}
		return (res) >= K; // 题中的路径不包含单点
	}

	inline int main() {
		cin>> N>> K; int limit = 0;
		for(int i=1, u, v, w; i<N; i++)	cin>> u>> v>> w, Add_edge(u, v, w), Add_edge(v, u, w), limit += w;
		Build_LCA(), Build(1, 0);
		for(int u=1; u<=N; u++) {
			int l = 0, r = limit, mid, res = -1;
			for(; l<=r; ) {
				mid = (l+r)>>1;
				if(Query(u, mid))	res = mid, r = mid-1;
				else 	l = mid+1;
			}
			cout<< res<< '\n';
		}
		return 0;
	}

}

int main() {
	Josh_zmf::main();
	return 0;
}
```

---

## 作者：Genius_Star (赞：1)

### 思路：

注意到是求每个点到其它所有点距离的第 $k$ 小，考虑换根。

先预处理出所有点到 $1$ 的距离 $dis$，当从 $u$ 换到 $v$ 且边权为 $w$ 时：

- 对于所有在 $v$ 子树内的点 $i$，令 $dis_i \gets dis_i -w$。

- 对于所有不在 $v$ 子树的点 $j$，令 $dis_j \gets dis_j + w$；可以转化为先全局加，再子树减。

- 即可以对于所有在 $v$ 子树内的点 $i$，令 $dis_i \gets dis_i -2w$，然后全局加标记 $Tag \gets Tag + w$。

现在问题可以转化为区间加减，全局求第 $k$ 小，这不就[由乃打扑克](https://www.luogu.com.cn/problem/P5356)的弱化吗！！！

于是直接分块，然后二分答案，对于每个块二分求贡献。

时间复杂度为 $O(N \sqrt{N} \log^2 N)$。

当然，你也可以写 $O(N \log^3 N)$ 的点分树。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define Full(a) memset(a,0,sizeof(a))
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
using namespace std;
typedef double db;
typedef long long ll;
const ll N=15005,M=sqrt(N)+10;
inline ll read(){ 
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,k,cnt,Tag;
ll A[N],a[N],b[N],dfn[N],ans[N],siz[N];
ll L[M],R[M],T[M],H[M],Max[M],Min[M];
ll V[M][M];
vector<pair<ll,ll>> E[N];
void add(ll u,ll v,ll w){
	E[u].push_back({v,w});
	E[v].push_back({u,w});
}
void dfs1(ll u,ll fa){
	siz[u]=1;
	dfn[u]=++cnt;
	for(auto t:E[u]){
		ll v=t.first,w=t.second;
		if(v==fa)
		  continue;
		b[v]=b[u]+w;
		dfs1(v,u);
		siz[u]+=siz[v];
	}
}
void init(ll i){
	H[i]=0;
	ll l=L[i],r=R[i];
	for(int x=l;x<=r;x++)
	  V[i][++H[i]]=a[x];
	sort(V[i]+1,V[i]+H[i]+1);
	Max[i]=V[i][H[i]];
	Min[i]=V[i][1];
}
void init(){
	for(int i=1;i<=n;i++)
	  a[dfn[i]]=b[i];
	ll k=sqrt(n),t=n/k;
	if(n%k!=0)
	  t++;
	for(int i=1;i<=t;i++){
		L[i]=(i-1)*k+1;
		R[i]=i*k;
	} 
	R[t]=n;
	for(int i=1;i<=n;i++)
	  A[i]=(i-1)/k+1;
	for(int i=1;i<=t;i++)
	  init(i);
}
void update(ll x,ll y,ll v){
	ll l=A[x],r=A[y];
	if(l==r){
		for(int i=x;i<=y;i++)
		  a[i]+=v;
		init(l);
	}
	else{
		for(int i=x;i<=R[l];i++)
		  a[i]+=v;
		for(int i=L[r];i<=y;i++)
		  a[i]+=v;
		init(l),init(r);
		for(int i=l+1;i<=r-1;i++)
		  T[i]+=v;
	}
}
ll check(ll x,ll y,ll v){
	ll l=A[x],r=A[y],ans=0;
	if(l==r){
		for(int i=x;i<=y;i++)
		  if(a[i]+T[l]<=v)
		    ans++;		
	}
	else{
		for(int i=x;i<=R[l];i++)
		  if(a[i]+T[l]<=v)
		    ans++;	
		for(int i=L[r];i<=y;i++)
		  if(a[i]+T[r]<=v)
		    ans++;
		for(int i=l+1;i<=r-1;i++){
			if(Min[i]+T[i]>v)
			  continue;
			if(Max[i]+T[i]<=v){
				ans+=R[i]-L[i]+1;
				continue;
			}
			ll l=1,r=H[i];
			while(l<r){
				ll mid=(l+r+1)>>1;
				if(V[i][mid]+T[i]<=v)
				  l=mid;
				else 
				  r=mid-1;	
			}
			if(V[i][l]+T[i]<=v)
			  ans+=l;
		}	
	}
	return ans;
}
ll qureyMin(ll x,ll y){
	ll l=A[x],r=A[y],ans=1e15;
	if(l==r){
		for(int i=x;i<=y;i++)
		  ans=min(ans,a[i]+T[l]);
	}
	else{
		for(int i=x;i<=R[l];i++)
		  ans=min(ans,a[i]+T[l]);
		for(int i=L[r];i<=y;i++)
		  ans=min(ans,a[i]+T[r]);
		for(int i=l+1;i<=r-1;i++)
		  ans=min(ans,Min[i]+T[i]);
	}
	return ans;
}
ll qureyMax(ll x,ll y){
	ll l=A[x],r=A[y],ans=-1e15;
	if(l==r){
		for(int i=x;i<=y;i++)
		  ans=max(ans,a[i]+T[l]);
	}
	else{
		for(int i=x;i<=R[l];i++)
		  ans=max(ans,a[i]+T[l]);
		for(int i=L[r];i<=y;i++)
		  ans=max(ans,a[i]+T[r]);
		for(int i=l+1;i<=r-1;i++)
		  ans=max(ans,Max[i]+T[i]);
	}
	return ans;
}
ll solve(ll a,ll b,ll k){
	if(k<1||k>b-a+1) 
	  return -1;
	ll l=qureyMin(a,b),r=qureyMax(a,b),ans=-1;
	while(l<=r){
		ll mid=(l+r)>>1;
		if(check(a,b,mid)<k)
		  l=mid+1;
		else{
			r=mid-1;
			ans=mid;
		}
	}
	return ans;
}
void dfs2(ll u,ll fa){
	ans[u]=solve(1,n,k+1)+Tag;
	for(auto t:E[u]){
		ll v=t.first,w=t.second;
		if(v==fa)
		  continue;
		Tag+=w;
		update(dfn[v],dfn[v]+siz[v]-1,-2ll*w);
		dfs2(v,u);
		Tag-=w;
		update(dfn[v],dfn[v]+siz[v]-1,2ll*w);
	}
}
int main(){
	n=read(),k=read();
	for(int u,v,w,i=1;i<n;i++){
		u=read(),v=read(),w=read();
		add(u,v,w);
	}
	dfs1(1,0);
	init();
	dfs2(1,0);
	for(int i=1;i<=n;i++){
		write(ans[i]);
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：qnqfff (赞：0)

### 思路

考虑定根时答案就是 $dep$ 第 $k$ 小，换根一下变成区间加，全局第 $k$ 小，直接分块即可。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
const int B=315;
using namespace std;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<23],*p1=buf,*p2=buf;
int read(){char c=getchar();int p=0,flg=1;while(c<'0'||c>'9'){if(c=='-') flg=-1;c=getchar();}while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar();}return p*flg;}
int n,k,a[100010],ans[100010],pos[100010],b[100010],L[320],R[320],tag[320],dfn[100010],id[100010],tim,ed[100010];vector<array<int,2>>e[100010];
void rebuild(int x){for(int i=L[x];i<=R[x];i++) a[id[i]]+=tag[x],b[i]=a[id[i]];tag[x]=0;sort(b+L[x],b+1+R[x]);}
void modify(int l,int r,int v){
	if(l>r) return ;if(pos[l]==pos[r]){for(int i=l;i<=r;i++) a[id[i]]+=v;rebuild(pos[l]);return ;}
	for(int i=l;i<=R[pos[l]];i++) a[id[i]]+=v;rebuild(pos[l]);for(int i=L[pos[r]];i<=r;i++) a[id[i]]+=v;rebuild(pos[r]);for(int i=pos[l]+1;i<pos[r];i++) tag[i]+=v;
}
int calc(int lim){
	int sum=0;for(int i=1;i<=pos[n];i++){
		int l=L[i],r=R[i],res=0,mid;auto check=[&](int x){return b[x]+tag[i]<=lim;};
		while(l<=r) check(mid=l+r>>1)?res=mid-L[i]+1,l=mid+1:r=mid-1;sum+=res;
	}return sum;
}
int query(){
	int l=1,r=150000,res=r,mid;auto check=[&](int x){return calc(x)>=k+1;};
	while(l<=r) check(mid=l+r>>1)?res=mid,r=mid-1:l=mid+1;return res;
}
signed main(){
	n=read();k=read();for(int i=1;i<n;i++){int u=read(),v=read(),w=read();e[u].push_back({v,w});e[v].push_back({u,w});}
	function<void(int,int)>dfs=[&](int u,int fa){id[dfn[u]=++tim]=u;for(auto v:e[u]) if(v[0]^fa) a[v[0]]=a[u]+v[1],dfs(v[0],u);ed[u]=tim;};dfs(1,0);
	for(int i=1;i<=n;i++) pos[i]=(i-1)/B+1;for(int i=1;i<=pos[n];i++) L[i]=(i-1)*B+1,R[i]=min(i*B,n),rebuild(i);
	function<void(int,int)>_dfs=[&](int u,int fa){
		ans[u]=query();for(auto v:e[u]) if(v[0]^fa){
			modify(dfn[v[0]],ed[v[0]],-v[1]);modify(1,dfn[v[0]]-1,v[1]);modify(ed[v[0]]+1,n,v[1]);_dfs(v[0],u);
			modify(dfn[v[0]],ed[v[0]],v[1]);modify(1,dfn[v[0]]-1,-v[1]);modify(ed[v[0]]+1,n,-v[1]);
		}
	};_dfs(1,0);for(int i=1;i<=n;i++) cout<<ans[i]<<'\n';
	return 0;
}
```

---

## 作者：hh弟中弟 (赞：0)

见到第 $k$ 小自然想到二分答案转判定，现在问题就成了查询距离一个点不超过 $mid$ 的点的数量，考虑点分树，每个点用树状数组维护一下它的子树内到它的距离为 $w$ 的点的数量即可，每次跳父亲查前缀和。用 st 表预处理出任意两点的距离，时间复杂度 $\mathcal{O}(n\log^3n)$，有一说一这题 $n^2$ 都能冲过去吧。

```cpp
#include<bits/stdc++.h>
#define fi first
#define se second
#define pii std::pair<int,int>
#define eb emplace_back
#define pb push_back
typedef long long ll;
typedef unsigned long long ull;
std::mt19937 myrand(std::chrono::high_resolution_clock::now().time_since_epoch().count());
inline int R(int n){return myrand()%n+1;}
inline int read(){char ch=getchar();int x=0,f=1;for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;for(;ch>='0'&&ch<='9';ch=getchar())x=(x<<3)+(x<<1)+(ch^48);return x*f;}
const int N=1.5e4+10,mod=998244353,inf=1e9;
inline void Min(int &x,int y){if(x>y)x=y;}
inline void Max(int &x,int y){if(x<y)x=y;}
int n,k,sum[N],dfn[N],dn,st[20][N],fa[N],size[N],rt;
struct EDGE{int v,w;};
std::vector<EDGE> e[N];
bool vis[N];
inline int get(int x,int y){return dfn[x]<dfn[y]?x:y;}
inline void dfs(int x,int fa){st[0][dfn[x]=++dn]=fa;for(auto v:e[x])if(v.v!=fa)sum[v.v]=sum[x]+v.w,dfs(v.v,x);}
inline void init(){for(int i=1;i<=std::__lg(n);++i)for(int j=1;j+(1<<i)-1<=n;++j)st[i][j]=get(st[i-1][j],st[i-1][j+(1<<i-1)]);}
inline int dis(int u,int v){
	if(u==v)return 0;int res=sum[u]+sum[v];
	if((u=dfn[u])>(v=dfn[v]))std::swap(u,v);
	int d=std::__lg(v-u++);return res-2*sum[get(st[d][u],st[d][v-(1<<d)+1])];
}
inline void findrt(int x,int fa,int tot){
	size[x]=1;int mx=0;for(auto it:e[x]){
		int v=it.v;
		if(v==fa||vis[v])continue;
		findrt(v,x,tot);Max(mx,size[v]);size[x]+=size[v];
	}Max(mx,tot-size[x]);if(mx<=tot/2)rt=x;
}
struct BIT{
	int *c,len;
	inline void add(int p){for(p;p<=len;p|=p+1)c[p]++;}
	inline int query(int p){if(p<0)return 0;Min(p,len);int res=0;for(;~p;p=(p&(p+1))-1)res+=c[p];return res;}
}t[N],tfa[N];
inline void found(int x){
	t[x].c=new int[(size[x]-1)*10+1];memset(t[x].c,0,sizeof(int)*((size[x]-1)*10+1));t[x].len=(size[x]-1)*10;
	tfa[x].c=new int[size[x]*10+1];memset(tfa[x].c,0,sizeof(int)*(size[x]*10+1));tfa[x].len=size[x]*10;
	vis[x]=1;for(auto it:e[x]){
		int v=it.v;if(vis[v])continue;
		findrt(v,x,size[v]);findrt(rt,x,size[v]);fa[rt]=x;found(rt);
	}
}
inline int check(int x,int mid){
	int res=t[x].query(mid),zc=fa[x],la=x;
	while(zc){
		res+=t[zc].query(mid-dis(zc,x))-tfa[la].query(mid-dis(zc,x));
		zc=fa[zc];la=fa[la];
	}
	return res;
}
signed main(){
    // freopen("in.in","r",stdin);freopen("out.out","w",stdout);
    std::ios::sync_with_stdio(false);std::cin.tie(0);std::cout.tie(0);
    n=read(),k=read()+1;for(int i=1;i<n;++i){int u=read(),v=read(),w=read();e[u].pb({v,w});e[v].pb({u,w});}
    dfs(1,0);init();findrt(1,0,n);findrt(rt,0,n);found(rt);
    for(int i=1;i<=n;++i){
    	int zc=i;while(zc){
    		t[zc].add(dis(zc,i));if(fa[zc])tfa[zc].add(dis(fa[zc],i));zc=fa[zc];
    	}
    }
    for(int x=1;x<=n;++x){
    	int l=0,r=n*10,res=0;
    	while(l<=r){
    		int mid=l+r>>1,zc=check(x,mid);
    		if(zc>=k)res=mid,r=mid-1;
    		else l=mid+1;
    	}
    	std::cout<<res<<'\n';
    }

}
```

---


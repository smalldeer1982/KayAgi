# 「KDOI-10」超级演出

## 题目背景

**本场比赛所有题目从标准输入读入数据，输出到标准输出。**

## 题目描述

巡准备了一场超级演出。舞台和候场室可以看作一个包含 $n$ 个点 $m$ 条边的有向图，并且这个图当中没有环，也就是说，这是一张有向无环图（DAG）。

舞台为 $1$ 号节点，**保证所有节点均有到达节点 $\bm 1$ 的路径**。其余的节点均为候场室，每个候场室恰有一个剧团进行等待。

巡可以对一个候场室 $u$ 发布出场命令：

- 如果这个候场室的剧团还没有出场，并且存在一条 $u\to 1$ 的路径上没有其余候场的剧团。那么这个剧团就会沿着这条路径到达舞台进行演出，随后退场。注意：**一个剧团退场后不会重新回到候场室。**
- 否则，这个命令被认为是无效的。

巡有一个命令序列 $a_1,a_2,\dots,a_k$ 和 $q$ 次询问，每次给出一个区间 $[l,r]$。巡想要知道如果依次对候场室 $a_l,a_{l+1},\dots,a_r$ 发布出场命令后，候场室还会剩下多少剧团等待演出。

注意：每次询问相互独立，也就是说，每次询问之前，每个候场室都恰有一个剧团进行等待。


## 说明/提示

**【样例 1 解释】**

![](https://cdn.luogu.com.cn/upload/image_hosting/2a4qed7w.png)

如图：

- 当询问 $l=1,r=2$ 时：
	- 发布出场命令 $a_1=2$。$2$ 沿着 $2\to 1$ 出场。
   - 发布出场命令 $a_2=4$。$4$ 沿着 $4\to 2\to 1$ 出场。
   
   此时余下 $3,5$ 两个剧团，输出 $2$。
   
- 当询问 $l=2,r=3$ 时：
	- 发布出场命令 $a_2=4$。找不到 $4\to 1$ 的且路上没有别的剧团的路线，该指令被认为无效。
   - 发布出场命令 $a_3=4$。找不到 $4\to 1$ 的且路上没有别的剧团的路线，该指令被认为无效。
   
   此时余下 $2,3,4,5$ 四个剧团，输出 $4$。
  
**【样例 2】**

见选手目录下的 `show/show2.in` 与 `show/show2.ans`。

这个样例满足测试点 $1,2$ 的限制条件。

**【样例 3】**

见选手目录下的 `show/show3.in` 与 `show/show3.ans`。

这个样例满足测试点 $5\sim 8$ 的限制条件。

**【样例 4】**

见选手目录下的 `show/show4.in` 与 `show/show4.ans`。

这个样例满足测试点 $9\sim 11$ 的限制条件。

**【样例 5】**

见选手目录下的 `show/show5.in` 与 `show/show5.ans`。

这个样例满足测试点 $12,13$ 的限制条件。


**【样例 6】**

见选手目录下的 `show/show6.in` 与 `show/show6.ans`。

这个样例满足测试点 $18,19$ 的限制条件。

***

**【数据范围】**

对于全部的测试数据，保证：

- $1\leq n,k,q\leq2\times10^5$；
- $1\leq m\leq4\times10^5$；
- $1\leq v<u\leq n$，且不存在两组相同的 $(u,v)$；
- 对于任意 $1\le i\le k$，$2\leq a_i\leq n$；
- 对于每组询问，$1\leq l\leq r\leq k$；
- 输入构成一张有向无环图，且所有节点均存在到达节点 $1$ 的路径。

| 测试点 | $n,k,q\leq$ | $m\leq$ | 特殊性质 |
|:--:|:--:|:--:|:--:|
| $1,2$ | $300$ | $600$ | 无 |
| $3,4$ | $2\,000$ | $4\,000$ | A |
| $5\sim 8$ | $2\,000$ | $4\,000$ | 无 |
| $9\sim 11$ | $2\times10^5$ | $4\times10^5$ | A |
| $12,13$ | $2\times10^5$ | $4\times10^5$ | BC |
| $14,15$ | $2\times10^5$ | $4\times10^5$ | C |
| $16,17$ | $2\times10^5$ | $4\times10^5$ | BD |
| $18,19$ | $2\times10^5$ | $4\times10^5$ | D |
| $20\sim 22$ | $2\times10^5$ | $4\times10^5$ | B |
| $23\sim 25$ | $2\times10^5$ | $4\times10^5$ | 无 |

- 特殊性质 A：图退化为一棵内向树，也就是说，除节点 $1$ 外，每个点恰有一条出边，节点 $1$ 没有出边；
- 特殊性质 B：保证对于每组询问，$r=k$；
- 特殊性质 C：保证对于任意 $1\leq i< j\leq k$，$a_i\neq a_j$；
- 特殊性质 D：保证每个点的入度和出度均不超过 $30$。

## 样例 #1

### 输入

```
0
5 5 5 4
2 1
3 1
5 1
4 2
4 3
2 4 4 3 5
1 2
1 5
3 5
2 3
```

### 输出

```
2
0
2
4
```

# 题解

## 作者：Register_int (赞：25)

鲜花：$24+0+6+100$，竞选全场最搞笑选手。

考虑对于每个 $a_i$，预处理出来“若要释放这个点，至少需要 $w_i\sim i$ 的操作”的 $w_i$。有个很暴力的求法：显然若一个点一步就能到 $1$，那么 $w_i=i$。否则将这个点的 $w_i$ 和他的所有后继取 $\max$ 即可。求出来 $w_i$ 后可以变成二维偏序问题，扫描线一下就做完了。

考虑优化求 $w_i$ 的部分。根号分治，设阈值为 $B$，若 $a_i$ 度数 $<B$ 直接暴力更新。算出一个点后，用这个点更新所有度数 $\ge B$ 的点。复杂度是 $O(nB+n\times\frac nB)$ 的。那么做完了。

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 2e5 + 10;

vector<int> g[MAXN], rg[MAXN]; int d[MAXN], B;

int n, m, p, q, a[MAXN]; vector<pair<int, int>> f[MAXN]; bool isp[MAXN];

int tw[MAXN], w[MAXN], rev[MAXN], lst[MAXN], c[MAXN], ans[MAXN];

inline void add(int k, int x) { for (int i = k; i <= p; i += i & -i) c[i] += x; }
inline int ask(int k) { int res = 0; for (int i = k; i; i &= i - 1) res += c[i]; return res; }

int main() {
//	freopen("./show/show5.in", "r", stdin);
//	freopen("show5.out", "w", stdout);
	scanf("%*d%d%d%d%d", &n, &m, &p, &q), B = sqrt(m);
	for (int i = 1, u, v; i <= m; i++) {
		scanf("%d%d", &u, &v); if (v == 1) isp[u] = 1;
		g[u].emplace_back(v), d[u]++;
	}
	for (int u = 1; u <= n; u++) {
		if (d[u] < B) continue;
		for (int v : g[u]) rg[v].emplace_back(u);
	}
	for (int i = 1; i <= p; i++) scanf("%d", &a[i]);
	for (int i = 1; i <= p; i++) {
		if (isp[a[i]]) w[i] = i;
		else if (d[a[i]] >= B) w[i] = tw[a[i]];
		else for (int v : g[a[i]]) w[i] = max(w[i], rev[v]);
		rev[a[i]] = w[i];
		for (int v : rg[a[i]]) tw[v] = max(tw[v], w[i]);
	}
	for (int i = 1, l, r; i <= q; i++) scanf("%d%d", &l, &r), f[r].emplace_back(l, i);
	for (int i = 1, cnt = 0; i <= p; i++) {
		if (lst[a[i]]) add(lst[a[i]], -1), cnt--;
		if (w[i]) add(w[i], 1), lst[a[i]] = w[i], cnt++;
		for (pair<int, int> x : f[i]) ans[x.second] = n - 1 - cnt + ask(x.first - 1);
	}
	for (int i = 1; i <= q; i++) printf("%d\n", ans[i]);
}
```

---

## 作者：Moeebius (赞：13)

[English version](https://www.luogu.com/article/lgvreyk1)

不难注意到，对于每个询问右端点 $r$，一个房间 $p$ 中的乐队会退场，当且仅当询问左端点 $l$ 小于等于一个只与 $r$ 和 $p$ 有关的值，不妨记作 $q_p$。

特别地，令 $q_1=r$。

考虑对询问右端点 $r$ 扫描线。先考虑一个复杂度不对的版本。

注意到，如果我们从 $i-1$ 移动到 $i$，只有 $q_{a_i} \gets \max\limits_{v \in \text{out}_{a_i}}\{q_v\}$，其余 $q_i$ 均不变。

这样原问题就变成了一个二维数点的形式，我们需要统计 $\sum_{i} [q_i \ge l]$，离线询问后使用 BIT 维护，期望得分 76。

我们复杂度不对的地方在哪里呢？发现一个节点度数可能很大，如果一直操作这个点就爆了。

套路地，考虑根号分治。对于度数大于 $B$ 的「大点」（只有 $\frac{n}{B}$ 个），我们在更新 $q_{a_i}$ 的时候顺路更新所有被影响到的「大点」；对于其余「小点」，暴力更新即可。

取 $B=\sqrt n$, 总时间复杂度 $O(n \sqrt n + (n+q) \log n)$。

---

## 作者：dyc2022 (赞：6)

首先，我们注意到如果让 $a$ 序列的 $[x,i)$ 的区间“出场”后能够成功地把 $a_i$ 出场，那么对于更长的操作区间 $[x-1,i)$ 操作过后，也能保证 $a_i$ 成功出场。即不能使 $a_i$ 成功出场的区间一定是 $[1,i)$ 的一个后缀。

考虑设置 $\text{pre}_i$ 表示操作完 $[x,i)$ 能够使 $i$ 成功释放的最大 $x$。如果我们求完了所有 $\text{pre}_i$，那么接下来的问题就是经典的二维数点，即求区间 $[l,r]$ 覆盖了多少个形如 $[\text{pre}_i,i]$ 的区间。

那么问题就在于我们如何求 $\text{pre}_i$。有一种思路就是，若 $a_i$ 有直接通向 $1$ 号节点的边，那么显然 $\text{pre}_i = i$。否则，就用所有 $a_i$ 的出边来转移 $i$，在 $a_i$ 的所有后继节点中取 $\max$。

然而我们发现了一件事情，那就是 $a_i$ 不一定不重复。如果造了一朵菊花，且每次都操作度数很大的点，上面的算法就寄了。于是我们考虑对度数进行根号分治。取 $B = \sqrt{n}$，对于度数 $\le B$ 的 $a_i$，直接按照上面的方法枚举出边进行暴力转移。对于度数 $>B$ 的 $a_i$，我们就不处理他们，而是依靠它度数较少的后继节点倒着转移。我们在处理小度数节点时，可以去找它的前驱，然后再直接转移即可。

复杂度是 $O(n \sqrt{n} + n \log n)$ 的，可以通过。代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
#define N 200006
using namespace std;
int n,m,k,q,a[N],d[N],B,pre[N],pre2[N],now[N],ok[N],ans[N],tree[N],c,lst[N];
vector<int> G[N],Gr[N];
vector<pair<int,int> > Seg[N];
inline int read()
{
    int ret=0,f=1;char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')f=-1,ch=getchar();
    while(ch>='0'&&ch<='9')ret=(ret<<3)+(ret<<1)+(ch^48),ch=getchar();
    return ret*f;
}
inline void write(int k)
{
    if(k<0)putchar('-'),k*=-1;
    int nnum[20],tp=0;
    while(k)nnum[++tp]=k%10,k/=10;
    if(!tp)nnum[++tp]=0;
    for(int i=tp;i;i--)putchar(nnum[i]^48);
}
inline void update(int p,int x){while(p<=k)tree[p]+=x,p+=p&-p;}
inline int query(int p)
{
    int ret=0;
    while(p)ret+=tree[p],p-=p&-p;
    return ret;
}
main()
{
    read();
    n=read(),m=read(),k=read(),q=read(),B=pow(n,0.5);
    for(int i=1,u,v;i<=m;i++)
    {
        u=read(),v=read();
        G[u].push_back(v),d[u]++,ok[u]|=(v==1);
    }
    for(int i=1;i<=n;i++)if(d[i]>B)
        for(int v:G[i])Gr[v].push_back(i);
    for(int i=1;i<=k;i++)a[i]=read();
    for(int i=1;i<=k;i++)
    {
        if(ok[a[i]])pre[i]=i;
        else if(d[a[i]]<=B)
            for(int v:G[a[i]])pre[i]=max(pre[i],now[v]);
        else pre[i]=pre2[a[i]];
        now[a[i]]=pre[i];
        for(int v:Gr[a[i]])pre2[v]=max(pre2[v],pre[i]);
    }
    for(int i=1,l,r;i<=q;i++)l=read(),r=read(),Seg[r].push_back({l,i});
    for(int i=1;i<=k;i++)
    {
        if(lst[a[i]])update(pre[lst[a[i]]],-1),c--;
        if(pre[i])update(pre[i],1),c++,lst[a[i]]=i;
        for(auto s:Seg[i])
        {
            int l=s.first,r=i,id=s.second;
            ans[id]=n-1-c+query(l-1);
        }
    }
    for(int i=1;i<=q;i++)write(ans[i]),putchar('\n');
    return 0;
}
```

---

## 作者：KinNa_Sky (赞：6)

差点场切 /kk

由于选的是一段连续区间，考虑找出序列中让 $a_i$ 可以走的最大的左端点，记为 $could_i$，这样的话如果询问区间包含 $[could_i, i]$ 就可以走一个。

但是 $a_i$ 可能相同，维护 $a_i$ 上一次出现的位置记为 $lst_{a_i}$，如果 $[could_{lst_{a_i}}, lst_{a_i}]$ 和 $[could_i, i]$ 同时被包含，就会重复计算贡献，减去即可，相当于 $[could_{lst_{a_i}}, i]$ 区间会造成 $-1$ 的贡献。

区间内子区间贡献是经典离线二维数点，将每个贡献区间 $[x, y]$ 看作二维平面上一点 $(x, y)$，那么询问转化为求 $x \ge l,y\le r$ 的矩阵和。

现在讲一下如何找到 $could_i$，我们可以遍历序列时维护 $went_{x}$ 表示 $x$ 这个点能走的最大左端点，如果 $x$ 指向 $1$，那么 $went_x$ 就是 $x$ 在序列中最后出现的位置，不然 $went_x$ 就是 $x$ 指向点的 $went$ 的最大值。

此时我们意识到如果出题人放个菊花就能把这个过程卡成  $O(n^2)$，考虑使用根号分治优化。

如果一个点的出边数小于等于根号，那么每次暴力找即可。不然每个点开一个 `vector` 记录它出度大于根号的前驱，在更新完每个点的 $went$ 后直接对其出度大于根号的前驱进行更新。

然后这时注意 $went_x$ 由于在 $x$ 出现前被更新了，所以在 $x$ 被遍历到之前 $went_x$ 不能去更新别的点，那么出度小于根号的点暴力找的时候就去找上一次的状态来更新，即 $could_{lst_y}$。

[Code](https://www.luogu.com/paste/x7kekov6)

---

## 作者：Super_Cube (赞：6)

# Solution

设 $l_i$ 表示对于命令 $i$ 能使其剧团成功出场的命令左边界，即 $l_i$ 为执行完 $[l,i)$ 的所有命令后 $a_i$ 可以出场中最大的 $l$。转移是显然的：$l_i=\displaystyle\max_{a_i\to a_j} l_j$，因为肯定走出边中 $l$ 更大的更优。当 $a_i\to 1$ 时初始化 $l_i=i$。

离线询问，从左往右扫询问右端点 $j$。若询问左端点为 $i$ 且前面存在命令 $k$ 使得 $l_k\ge i$，那么 $a_k$ 自然能出场（由 $l_i$ 的定义）。记 $s$ 为 $[i,j]$ 中能出场的个数，那么该区间答案为 $n-1-s$（因为 $i$ 一定能出场）。如何统计？树状数组维护区间加单点查即可。注意 $a$ 中会有重复元素，要记得去重（用类似 [P1972](/problem/P1972) 中离线树状数组的技巧）。

询问部分的复杂度已经控制在可接受的范围内了，现在的瓶颈为求 $l_i$ 的部分，每次暴力枚举出边复杂度是 $O(km)$ 的。

经典技巧：根号分治。

设置阈值 $M=\sqrt m$，若出边数量不大于 $M$ 则直接跑；否则这样的点数量不超过 $M$ 个，建反图用来顺推进行更新。复杂度就这样被平衡至 $O(k\sqrt m)$。

# Code

```cpp
#include<bits/stdc++.h>
inline int lowbit(int x){
	return x&-x;
}
int bit[200005];
int k;
inline void add(int x,int y){
	for(++x;x<=k;x+=lowbit(x))bit[x]+=y;
}
inline int ask(int x){
	static int res;res=0;
	for(++x;x;x^=lowbit(x))res+=bit[x];
	return res;
}
std::vector<int>v[200005],e[200005];
bool sig[200005];
int nxt[200005];
int l[200005];
std::vector<std::pair<int,int> >g[200005];
int ans[200005];
int lst[200005];
int a[200005];
int n,m,q,lim;
int main(){
	scanf("%*d%d%d%d%d",&n,&m,&k,&q);
	lim=sqrt(m);
	for(int x,y;m--;)
		scanf("%d%d",&x,&y),
		v[x].push_back(y),
		sig[x]|=y==1;
	for(int i=1;i<=n;++i)
		if(v[i].size()>lim)
			for(const int&j:v[i])
				e[j].push_back(i);
	for(int i=1;i<=k;++i){
		scanf("%d",&a[i]);
		if(sig[a[i]])l[i]=i;
		else if(v[a[i]].size()<=lim)
			for(const int&j:v[a[i]])
				l[i]=std::max(l[i],lst[j]);
		else l[i]=nxt[a[i]];
		lst[a[i]]=l[i];
		for(const int&j:e[a[i]])
			nxt[j]=std::max(nxt[j],l[i]);
	}
	for(int i=1,l,r;i<=q;++i)
		scanf("%d%d",&l,&r),
		g[r].emplace_back(l,i);
	memset(lst,0,sizeof(lst));
	for(int i=1;i<=k;++i){
		add(l[lst[a[i]]],1);add(l[i],-1);
		lst[a[i]]=i;
		for(const auto&j:g[i])
			ans[j.second]=n-1-ask(j.first-1);
	}
	for(int i=1;i<=q;++i)
		printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：Hadtsti (赞：5)

### 题目分析

~~VP 了这场比赛，感觉 T4 比 T2 简单~~

首先我们考虑把询问挂在右端点上跑扫描线，那么如果我们能够维护出对每个 $a_i$ 能让它跑到 $1$ 号点的最右合法左端点 $pos_i$，就可以配合树状数组简单维护答案。具体地来说，每次扫到右端点 $r$ 就更新 $a_r$ 对应左端点，查询就是查合法最右左端点 $\ge l$ 的 $a_i$ 个数。

考虑如何求 $pos_i$。我们对于一个 $a_i$，我们对于它所有出边连向的 $x$，用值为 $x$ 的 $a_j(j<i)$ 对应的 $pos_j$ 取 $\max$ 更新 $pos_i$。

最简单的思路当然是暴力扫出边更新，而这样在点度数特别大的时候复杂度就会炸。老套路，设一个阈值 $T$，那么度数 $>T$ 的点个数小于 $\frac nT$。对度数 $\le T$ 的点我们暴力被动转移去更新；而对于度数 $>T$ 的点我们采用主动转移。这样的复杂度是 $O(k(\frac nT+T))$，$T=\sqrt n$ 时复杂度最优为 $O(k\sqrt n)$。总时间复杂度 $O((k+q)\log k+m+k\sqrt n)$。

细节不太多，可看代码。就是要注意主动转移要在扫到那个点的时候再更新。

### 代码实现


```cpp
#include<bits/stdc++.h> 
using namespace std;
const int T=300;
int N,m,n,nn,q,P[200010],pos[200010],a[200010],x,y,c[200010],ans[200010],fg[200010];
vector<int>E[200010],BG;
bitset<700>S[200010];
struct node
{
	int x,id;
};
vector<node>Q[200010];
void add(int x,int y)
{
	for(;x;x-=x&-x)
		c[x]+=y;
}
int ask(int x)
{
	int res=0;
	for(;x<=n;x+=x&-x)
		res+=c[x];
	return res;
}
int main()
{
	scanf("%d%d%d%d%d",&N,&N,&m,&n,&q);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&x,&y);
		E[x].push_back(y);
	}
	for(int i=1;i<=N;i++)
		if(E[i].size()>T)
			BG.push_back(i);
	nn=BG.size();
	for(int i=0;i<nn;i++)
		for(int x:E[BG[i]])
			S[x][i]=1;
	for(int i=1;i<=n;i++)
	{
		P[1]=i;
		for(int j=0;j<nn;j++)
			if(S[1][j])
				fg[BG[j]]=max(fg[BG[j]],i);
		scanf("%d",&a[i]);
		if(E[a[i]].size()<=T)
		{		 
			for(int x:E[a[i]])
				pos[i]=max(pos[i],P[x]);
			P[a[i]]=pos[i];
		}
		else
			pos[i]=P[a[i]]=max(P[a[i]],fg[a[i]]);
		for(int j=0;j<nn;j++)
			if(S[a[i]][j])
				fg[BG[j]]=max(fg[BG[j]],pos[i]);
	}
	for(int i=1;i<=q;i++)
	{
		scanf("%d%d",&x,&y);
		Q[y].push_back({x,i});
	}
	memset(P,0,sizeof P);
	for(int i=1;i<=n;i++)
	{
		add(P[a[i]],-1);
		add(P[a[i]]=pos[i],1);
		for(node j:Q[i])
			ans[j.id]=ask(j.x);
	}
	for(int i=1;i<=q;i++)
		printf("%d\n",N-1-ans[i]);
	return 0;
}
```

---

## 作者：_LSA_ (赞：3)

以下视 $n,m$ 等阶。

先考虑单次询问怎么做。

显然有一种暴力做法，我们记录一个 $flag$ 数组，表示这个点存在走到 $1$ 没有障碍的路径，初始只有跟 $1$ 相连的节点的值为 $1$，其他都是 $0$。

我们把所有边反向，每次对一个节点发布命令时，如果这个节点的 $flag$ 为 $1$，且该点的剧团还没上场，就扫描它的所有出边并把出边连接的点的 $flag$ 设置为 $1$，并更新答案。

这样我们就得到了一个 $O(q(k+n))$ 的做法。

当然这个做法不太好优化，因为每次询问的是 $a$ 的一个区间，我们考虑如何在 $a$ 上计算答案。

考虑特殊性质 B，它提示了我们一种离线扫描线的做法，于是我们考虑如何固定左端点求答案。

我们可以处理出一个数组 $pre$，$pre_i$ 表示 $a_i$ 可以对答案产生贡献的最大的左端点。

那么只要 $l\le pre_i$，$a_i$ 就能对答案产生贡献。

先考虑怎么求出 $pre$ 数组，一种朴素的做法是，还是将图反向，然后我们再记录一个 $lst$ 数组，令 $lst_i$ 表示当前如果对节点 $i$ 发出命令，它能产生贡献的最大左端点。然后从左到右扫 $a$ 数组，对于一号节点有连边出去的点，令 $pre_i=lst_{a_i}=i$，否则 $pre_i=lst_{a_i}$，每次将暴力 $a_i$ 连出去的点 $y$ 的 $lst_y$ 更新为 $\max(lst_y,pre_i)$。这个做法在每个点的度数都不是很大的时候跑得飞快，可以通过特殊性质 $D$。

由于可能出现度数很大的点，那么我们很容易想到对点的度数根号分治，我们设置一个闸值 $B = \sqrt{n}$，对于度数 $deg_i\le B$ 的点直接暴力扫描出边；对于 $deg_i>B$ 的点（以下称之为大点），由于它的数量不超过 $\frac{n}{B}=\sqrt{n}$ 个，我们在每次扫到 $pre_i$ 的时候再扫描跟 $a_i$ 有连边的大点更新 $pre_i$。具体的，我们预处理出每个点跟它连边的大点有哪些，并对每一个大点额外记录一个 $ti$ 数组，其中 $ti_x$ 表示最后一个 $a_y=x$ 的 $pre_y$ 的值，在初始化 $pre_i$ 的时候扫描跟 $a_i$ 有连边的大点并更新 $pre_i$ 即可。

于是我们在 $O(k\sqrt{n})$ 的时间处理出了 $pre$ 数组。

接下来，我们把询问离线并插到左端点，把 $i$ 插到 $pre_i$ 表示一次修改，从右往左扫描 $l$，就可以用树状数组维护答案了。这部分是 $O((q+k)\log k)$ 的。

于是我们在 $O(k\sqrt{n}+(q+k)\log k)$ 的时间内解决了这个题。


```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define pii pair<int,int>
#define fi first
#define se second
#define mk make_pair
using namespace std;
ll read(){
	ll X = 0,r = 1;
	char ch = getchar();
	while(!isdigit(ch) && ch != '-') ch = getchar();
	if(ch == '-') r = -1,ch = getchar();
	while(isdigit(ch)) X = X*10+ch-'0',ch = getchar();
	return X*r;
}
const int N = 2e5+10;
const int B = 700;
int n,m,k,Q,a[N];
vector<int> G[N],v[N],g[N];
vector<pii> q[N];
int lst[N],ti[N],pre[N];
bool flag1[N];
int t[N],ans[N],b[N];
void add(int x,int y){
	while(x <= k){
		t[x] += y;
		x += x&(-x);
	}
}
int ask(int x){
	int res = 0;
	while(x){
		res += t[x];
		x -= x&(-x);
	}
	return res;
}
int main(){
	// freopen("show.in","r",stdin);
	// freopen("show.out","w",stdout);
    int C = read();
	n = read(); m = read(); k = read(); Q = read();
	for(int i=1;i<=m;i++){
		int u = read(),v = read();
		G[v].push_back(u);
	}
	for(int i=1;i<=k;i++) a[i] = read();
	for(int i=1;i<=n;i++)
		if(G[i].size() > B)
			for(int y : G[i]) g[y].push_back(i);
	for(int y : G[1]) flag1[y] = true;
	for(int i=1;i<=k;i++){
		int p = lst[a[i]];
		for(int y : g[a[i]]) p = max(p,ti[y]);
		if(flag1[a[i]]) p = i;
		ti[a[i]] = pre[i] = lst[a[i]] = p;
		if(G[a[i]].size() <= B)
			for(int y : G[a[i]]) lst[y] = max(lst[y],p);
	}
	for(int i=k;i>=1;i--) v[pre[i]].push_back(i);
	for(int i=1;i<=Q;i++){
		int l = read(),r = read();
		q[l].push_back(mk(r,i));
	}
	for(int i=k;i;i--){
		for(int x : v[i]){
			if(b[a[x]]) add(b[a[x]],-1);
			add(x,1); b[a[x]] = x;
		}
		for(pii it : q[i]) ans[it.se] = ask(it.fi);
	}
	for(int i=1;i<=Q;i++) cout << n-1-ans[i] << "\n";
    return 0;
}

```

---

## 作者：_Ch1F4N_ (赞：2)

这种一看就没法合并信息的静态询问，考虑扫描线，把询问挂在 $r$ 上扫描。

然后观察到当 $r$ 固定时，对于每个剧团而言，$l$ 越小其越容易退场，这是显然的，因为 $l$ 越小越可能在前面退场并且干扰其退场的队伍越少。

于是考虑在扫描到 $r$ 时对于每个剧团动态维护 $d$ 表示 $l$ 至多是多少，其才会退场，那么这个剧团就会对所有满足 $l < d$ 的询问产生贡献。

显然可以在扫描到一个 $r$ 时把 $a_r$ 取出来然后 $d_{a_r} = \max_{a_r \to u} d_u$，不过这样做是 $O(n^2)$ 的。

由于度数之和是 $O(m)$ 的，所以考虑对点的度数根号分治，对于度数小于 $B$ 的点可以暴力，对于度数大于 $B$ 的点，其不超过 $\frac{m}{B}$ 个，于是考虑在扫描完 $a_r$ 后对于 $a_r$ 连向的所有度数大于 $\frac{m}{B}$ 的点打上一个 $d_u \gets \max(d_u,tag_u)$ 的标记，注意这里并不是直接更新 $d_u$，而是只更新标记 $tag_u$，在扫描到 $u$ 时再下放标记。

于是像这样扫描线，扫描到 $a_r$ 时通过暴力更新或者下放标记的办法更新 $d_{a_r}$，并在树状树组上描述这个更新，以便于查询多少个 $d_u < l$。

时间复杂度 $O(q \log n + k \times (B + \frac{m}{B}))$，取 $B = \sqrt m$ 得到 $O(q \log n + k \sqrt m)$。

注意不管是度数大的点还是度数小的点，特判其可以直接抵达节点 $1$ 的情况。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 2e5+114;
int d[maxn],tag[maxn];
const int warma = 500;
vector<int> In[maxn];
vector<int> Out[maxn];
int tr[maxn];
int n,m,k,q;
void add(int u,int v){
    u++;
    while(u<maxn) tr[u]+=v,u+=(u&(-u));
}
int pre(int u){
    u++;
    int res=0;
    while(u>0) res+=tr[u],u-=(u&(-u));
    return res;
}
int answer[maxn],L[maxn];
vector<int> Query[maxn];
int a[maxn];
int vis[maxn];
int c;
int main(){
    //freopen("show2.in","r",stdin);
    //freopen("show2.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>c;
    cin>>n>>m>>k>>q;
    for(int i=1;i<=m;i++){
        int u,v;
        cin>>u>>v;
        Out[u].push_back(v);
    }
    for(int i=1;i<=n;i++){
        if(Out[i].size()>warma){
            for(int v:Out[i]) In[v].push_back(i);
        }
    }
    for(int i=1;i<=k;i++) cin>>a[i];
    for(int i=1;i<=q;i++){
        int r;
        cin>>L[i]>>r;
        Query[r].push_back(i);
    }
    for(int i=2;i<=n;i++) add(d[i],1);
    for(int i=1;i<=n;i++){
        for(int v:Out[i]){
            if(v==1) vis[i]=1;
        }
    }
    for(int r=1;r<=k;r++){
        add(d[a[r]],-1);
        if(vis[a[r]]==1) d[a[r]]=r;
        if(Out[a[r]].size()<=warma){
            for(int v:Out[a[r]]){
                if(v==1) d[a[r]]=r;
                else d[a[r]]=max(d[a[r]],d[v]);
            }
        }
        d[a[r]]=max(d[a[r]],tag[a[r]]);
        tag[a[r]]=0;
        add(d[a[r]],1);   
        for(int id:Query[r]) answer[id]=pre(L[id]-1);
        for(int v:In[a[r]]){
            tag[v]=max(tag[v],d[a[r]]);
        }
    }
    for(int i=1;i<=q;i++) cout<<answer[i]<<'\n';
    return 0;
}
```

---

## 作者：cwfxlh (赞：2)

# [P11191](https://www.luogu.com.cn/problem/P11191)        
感觉是后三道最简单的一道。         

离线询问，然后从小往大扫 r，每个点维护一个值 $v_i$ 表示 $l\le v_i$ 是点 $i$ 的剧团能在 $[l,r]$ 的操作中退场的充要条件，如果无论如何都不能退场，$v$ 是 0。维护完 $v$，使用一个树状数组就可以查询答案。        

考虑如何维护这个值，当 $r$ 右移时，只有 $v_{a_r}$ 会发生变化，其取值显然会变化为 $\min(r,\max_{u\in e(a_r)} v_u)$，如果直接遍历后继，会被菊花卡掉，但是还有一种做法是在修改 $v_i$ 的时候同时修改其前驱。两种做法拼到一起就有了一个 $O(k\sqrt{m\log m}+q\log k+m\log m)$ 的做法。       

考虑对于出度小于 $B$ 的，暴力遍历后继取 $\max$，复杂度 $O(B)$。出度大于 $B$ 的点只有 $\frac{m}{B}$ 个，令这些点为特殊点，对于这些点维护一个优先队列，存放其后继的 $v$。在修改一个点的 $v$ 的时候，遍历其所有特殊点祖先，更新优先队列，复杂度 $O(\frac{m}{B}\log m)$，取 $B=\sqrt{m\log m}$ 即可。             

代码：          


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,q,a[500003],v[500003],B=1000,k1,k2,k3,k4,k5,k6,k7,k8,k9,ql[500003],qr[500003],ans[500003];
int head[500003],cd[500003],nxt[500003],ed[500003];
int head2[500003],ed2[500003],nxt2[500003],tot;
vector<int>qlst[500003];
priority_queue<pair<int,int> >Q[200003];
int TreeAr[500003];
int lowbit(int X){return (X&(-X));}
void modify(int wz,int v){
    wz++;
    for(int i=wz;i<=k+2;i+=lowbit(i))TreeAr[i]+=v;
    return;
}
int Query(int l,int r){
    l++;r++;
    int ret=0;
    for(int i=r;i;i-=lowbit(i))ret+=TreeAr[i];
    for(int i=l-1;i>0;i-=lowbit(i))ret-=TreeAr[i];
    return ret;
}
void upd(int X,int nowv){
    modify(v[X],-1);
    v[X]=0;
    if(cd[X]<=B){
        for(int j=head[X];j;j=nxt[j]){
            v[X]=max(v[X],v[ed[j]]);
        }
    }
    else{
        while(Q[X].top().first!=v[Q[X].top().second])Q[X].pop();
        v[X]=Q[X].top().first;
    }
    v[X]=min(v[X],nowv);
    for(int i=head2[X];i;i=nxt2[i])Q[ed2[i]].push(make_pair(v[X],X));
    modify(v[X],1); 
    return;
}
int main(){
    ios::sync_with_stdio(false);
    cin>>k1>>n>>m>>k>>q;
    for(int i=1;i<=m;i++){
        cin>>k1>>k2;
        ed[i]=k2;
        nxt[i]=head[k1];
        head[k1]=i;
        cd[k1]++;
    }
    for(int i=1;i<=k;i++)cin>>a[i];
    for(int i=1;i<=q;i++)cin>>ql[i]>>qr[i];
    for(int i=1;i<=q;i++)qlst[qr[i]].emplace_back(i);
    for(int i=2;i<=n;i++)v[i]=0;
    v[1]=k+1;
    for(int i=1;i<=n;i++){
        modify(v[i],1);
        if(cd[i]>B){
            for(int j=head[i];j;j=nxt[j])Q[i].push(make_pair(v[ed[j]],ed[j]));
            for(int j=head[i];j;j=nxt[j]){
                ed2[++tot]=i;
                nxt2[tot]=head2[ed[j]];
                head2[ed[j]]=tot;
            }
        }
    }
    for(int i=1;i<=k;i++){
        upd(a[i],i);
        for(auto j:qlst[i])ans[j]=(n-1)-Query(ql[j],qr[j]);
    }
    for(int i=1;i<=q;i++)cout<<ans[i]<<'\n';
    return 0;   
}
```

---

## 作者：KingPowers (赞：2)

个人感觉这题比 T2 简单，可能是 DS 学傻了。

下文中认为 $n,m,k,q$ 都同级，不做过细的区分。

看到这题第一感觉肯定是考虑离线扫描线，也就是枚举右端点 $r$，然后增量地维护出每个 $l$ 对应的答案。对于每个 $i$，如果我们能够求出一个最大的 $j<i$，满足按顺序执行 $[j,i]$ 这个区间之后 $a_i$ 的剧团能够演出，那么扫到 $r=i$ 时令 $l\in[1,p_i]$ 的答案加 $1$，并撤销上一个 $a_r$ 出现位置的贡献即可。

所以我们就要想如何求出每个 $p_i$。我们考虑按顺序遍历 $i$，对于当前的 $a_i$，遍历它在原图的后继点，并找到这些后继当前出现的最靠后的位置 $j$，令 $p_i$ 和 $p_j$ 取 $\max$ 即可。特别地，如果 $a_i$ 的后继中存在 $1$ 号点，则 $p_i=i$。

但是这么做有问题，不难发现这样复杂度是 $O(\sum deg_{a_i})$ 的，其中 $deg_i$ 表示图上 $i$ 号点的出度，最坏情况下可以卡到平方。但是注意到每个点的出度之和为定值 $m$，且本题存在保证度数的部分分，容易想到对度数根号分治。

对于当前的 $a_i$，如果 $a_i$ 的出度不超过 $\sqrt n$，则使用上面的暴力。对于 $a_i$ 出度大于 $\sqrt n$ 的情况，由于图上这种点不会超过根号个，我们每求出一个 $p_i$ 都尝试对这根号个出度大的点更新即可。这两部分的总复杂度都是 $O(n\sqrt n)$。

求出所有的 $p_i$ 后，就可以直接扫描线了，需要支持区间加单点查询，树状数组或线段树维护即可。

我为啥写了线段树来着。

最后的总复杂度为 $O(n\sqrt n+q\log n)$。


```cpp
#include<bits/stdc++.h>
#define int long long
#define For(i, a, b) for(int i = (a); i <= (b); i++)
#define Rof(i, a, b) for(int i = (a); i >= (b); i--)
#define deb(x) cerr << #x"=" << x << '\n';
using namespace std;
using pii = array<int, 2>;
const int N = 2e6 + 5, B = 500;
int cid, n, m, k, q, a[N];
int deg[N], lst[N], pos[N], cur[N], ans[N];
bool tag[N];
vector<int> e[N], pre[N];
vector<pii> vec[N];
struct sgt{
	int sum[N], tag[N];
	#define ls now << 1
	#define rs now << 1 | 1
	void add(int now, int l, int r, int w){
		sum[now] += (r - l + 1) * w;
		tag[now] += w;
	}
	void pushdown(int now, int l, int r){
		if(!tag[now]) return;
		int mid = (l + r) >> 1;
		add(ls, l, mid, tag[now]);
		add(rs, mid + 1, r, tag[now]);
		tag[now] = 0;
	}
	void modify(int x, int y, int w, int l, int r, int now){
		if(x <= l && r <= y) return add(now, l, r, w);
		pushdown(now, l, r); int mid = (l + r) >> 1;
		if(x <= mid) modify(x, y, w, l, mid, ls);
		if(y > mid) modify(x, y, w, mid + 1, r, rs);
		sum[now] = sum[ls] + sum[rs];
	}
	int query(int p, int l, int r, int now){
		if(l == r) return sum[now];
		pushdown(now, l, r); int mid = (l + r) >> 1;
		if(p <= mid) return query(p, l, mid, ls);
		return query(p, mid + 1, r, rs);
	}
	#undef ls
	#undef rs
}sgt;
void get_pre(){
	For(i, 1, k){
		int u = a[i];
		if(tag[u]) pos[i] = i;
		else if(deg[u] <= B){
			for(int v : e[u]){
				if(!lst[v]) continue;
				pos[i] = max(pos[i], pos[lst[v]]);
			}
		}
		else pos[i] = cur[u];
		lst[u] = i;
		if(pos[i]) for(int v : pre[u]) cur[v] = max(cur[v], pos[i]);
	}
}
signed main(){
	cin >> cid;
	cin >> n >> m >> k >> q;
	For(i, 1, m){
		int u, v; cin >> u >> v;
		e[u].emplace_back(v); deg[u]++;
		if(v == 1) tag[u] = 1;
	}
	For(i, 1, n) if(deg[i] > B)
		for(int j : e[i]) pre[j].push_back(i);
	For(i, 1, k) cin >> a[i];
	For(i, 1, q){
		int l, r; cin >> l >> r;
		vec[r].push_back({l, i});
	} get_pre();
	memset(lst, 0, sizeof lst);
	For(i, 1, k){
		int u = a[i];
		if(pos[i]){
			sgt.modify(1, pos[i], 1, 1, k, 1);
			if(lst[u] && pos[lst[u]]) sgt.modify(1, pos[lst[u]], -1, 1, k, 1);
		}
		lst[u] = i;
		for(auto [j, id] : vec[i]) ans[id] = n - 1 - sgt.query(j, 1, k, 1);
	}
	For(i, 1, q) cout << ans[i] << '\n';
	return 0;
}
```

---

## 作者：Genius_Star (赞：1)

### 思路：

首先考虑求出 $dp_i$ 表示至少要使用 $[dp_i,i]$ 的命令才可以使得 $a_i$ 进行演出。

那么询问变为求 $[l,r]$ 中 $a_i \ge l$ 的个数（若有多个 $a_i$ 满足，只用计算一次）。

这是一个二维数点的问题，考虑离线后扫描线，设 $pre_i$ 表示上一个 $a_{pre_i}=a_i$，那么 $dp_i \ge dp_{pre_i}$；故在扫描时，若存在 $pre_i$，则将其的贡献删除，将 $i$ 的贡献加入；使用树状数组维护即可。

然后考虑如何求出 $dp_i$，首先容易注意到状态转移方程：

$$dp_i = \max\limits_{(i \to j) \in E} dp_j$$

朴素转移是 $O(km)$ 的，考虑优化。

注意到所有点的出边的数量之和是 $m$，考虑根号分治：

- 若 $i$ 的出边数量 $\le B$：则直接跑朴素转移。

- 否则 $i$ 的出边数量 $> B$，那么这样的点的数量不超过 $\lfloor \frac{m}{B} \rfloor$；则可以对于每个点 $u$，存一下其前驱是否是**特殊点**，每次求出 $u$ 后对这些前驱直接更新答案即可。

时间复杂度为 $O(kB + k \lfloor \frac{m}{B} \rfloor + k \log k)$，取 $B = \sqrt{m}$ 最优，为 $O(k\sqrt{m} + k \log k)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define pi pair<ll,ll>
#define pii pair<ll,pair<ll,ll>>
#define iip pair<pair<ll,ll>,ll>
#define ppii pair<pair<ll,ll>,pair<ll,ll>>
#define fi first
#define se second
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define Full(a) memset(a,0,sizeof(a))
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
#define For(i,l,r) for(int i=l;i<=r;i++)
#define _For(i,l,r) for(int i=r;i>=l;i--)
using namespace std;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
const ll N=2e5+10;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,m,k,q,u,v,l,r,cnt,lim;
ll a[N],dp[N],pre[N],nxt[N],ans[N];
bool f[N];
vector<ll> E[N],G[N];
vector<pi> Q[N];
namespace Tree{
	ll a[N];
	void add(ll x,ll v){
		for(int i=x;i<=k;i+=lowbit(i))
		  a[i]+=v;
	}
	ll query(ll x){
		ll sum=0;
		for(int i=x;i;i-=lowbit(i))
		  sum+=a[i];
		return sum;
	}
};
void add(ll u,ll v){
	E[u].push_back(v);
} 
int main(){
	read(),n=read(),m=read(),k=read(),q=read();
	lim=sqrt(m);
	while(m--){
		u=read(),v=read();
		add(u,v);
		if(v==1)
		  f[u]=1;
	}
	for(auto v:E[1])
      dp[v]=1;
    For(u,1,n)
      if((ll)E[u].size()>lim)
        for(auto v:E[u])
          G[v].push_back(u);
    For(i,1,k){
    	a[i]=read();
    	if(f[a[i]])
    	  dp[i]=i;
    	else if((ll)E[a[i]].size()<=lim){
    		for(auto v:E[a[i]])
    		  dp[i]=max(dp[i],pre[v]);
		}
		else
		  dp[i]=nxt[a[i]];
		pre[a[i]]=dp[i];
		for(auto v:G[a[i]])
		  nxt[v]=max(nxt[v],dp[i]);
	}
	For(i,1,q){
		l=read(),r=read();
		Q[r].push_back({l,i});
	}
	For(i,1,n)
	  pre[i]=0;
	For(i,1,k){
		if(pre[a[i]]){
			Tree::add(pre[a[i]],-1);
			cnt--;
		}
		if(dp[i]){
			Tree::add(dp[i],1);
			pre[a[i]]=dp[i];
			cnt++;
		}
		for(auto t:Q[i])
		  ans[t.se]=n-1-cnt+Tree::query(t.fi-1);
	}
	For(i,1,q){
		write(ans[i]);
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：SukiYuri (赞：0)

看到题解区的大佬们都在使用离线算法，本蒟蒻就班门弄斧，分享一个在线算法吧。

---

思路也不见得多新奇，就是可持久化线段树结合根号分治。

拿到题目，我想到对于每个操作 $mod_{i}$，找到 $last_{i}$，为使得 $mod_{i}$ 上的节点能上台表演的最大操作编号，然后将每次查询转换为询问区间 $[l,r]$ 中所有满足 $last_{i}<l$ 的 $i$ 的个数。

但是发现区间 $[l,r]$ 中，可能有一些节点出现不止一次使答案错误，所以我们定义 $prs_{u}$ 为枚举到当前操作 $mod_{i}$ 时，满足按照区间 $[prs_{u},i]$ 依次进行操作后，节点 $u$ 能上台表演的最大操作编号。特别地，当 $u$ 无法上台表演时，令 $prs_{u}=0$。 

这样我们就可以将询问 $[l,r]$ 的问题转换为询问枚举到第 $r$ 个操作时，满足$prs_{u}<l$ 的节点个数。 

首先来解决 $prs$ 的处理，对于第 $i$ 次操作：
$$ prs_{u}=
\begin{cases}
i & (u,1) \in E \\
\underset{(u,v) \in E} \max \{ prs_v \} & otherwise 
\end{cases}
$$
其中，$E$ 为边集。
  
发现这样每次操作都需要遍历一遍 $u$ 的出边，会被菊花图卡炸，所以考虑根号分治。

定义 $deg_{u}$ 为节点 $u$ 的出度，$m$ 为图的边数。

- 若 $deg_{u} \leq \sqrt{m}$ 则暴力修改，过程如上所述。
- 否则，对 $u$ 的所有出边建一条反向边，在枚举到 $u$ 的出边所连的节点时顺便把 $prs_{u}$ 更新了。

可以证明，满足 $deg_{u} > \sqrt{m}$ 的节点 $u$ 不会超过 $\sqrt{m}$ 个，若认为点数 $n$ 与边数 $m$ 同阶，时间复杂度可粗略表示为 $O(n \sqrt{n})$。

再说说可持久化线段树，显然，每次操作后，我们的 $prs$ 数组都会被改变，都需要一棵线段树来维护，而直接开 $k$ 棵线段树空间又是不允许的。
 
我们发现每次新的操作可看作是对 $prs$ 的一次单点修改，可以看作是一次插入加一次删除，这样就可以愉快地用可持久化线段树啦！

不懂的同学可以看看[模板题1](https://www.luogu.com.cn/problem/P3919)
 和[模板题2](https://www.luogu.com.cn/problem/P3834)
 ，虽然提高组考场上大概率用不上（？）

代码如下：

```cpp
#include <bits/stdc++.h>
#define fr(i,a,b) for(int i=(a);i<=(b);++i) 

using namespace std;

const int N=2e5+5,S=632;
int prs[N],ftr[N],rt[N]; 
// 现在节点上的值，将来节点上的值......
// present，future
// ftr相当于prs的一个副本，因为prs还要维护删除工作，所以不能直接赋值
bool by[N];
vector<int> e[N],b[N];
int task,n,m,k,q;

struct PST {
	int lc[N*40],rc[N*40],sum[N*40],tot;
	inline void ins(int &o,int pre,int l,int r,int p,int d) {
		o=++tot; sum[o]=sum[pre];
		lc[o]=lc[pre]; rc[o]=rc[pre];
		if(l==r) {
			sum[o]+=d;
			return;
		}
		int mid=l+r>>1;
		if(p<=mid) ins(lc[o],lc[pre],l,mid,p,d);
		else ins(rc[o],rc[pre],mid+1,r,p,d);
		sum[o]=sum[lc[o]]+sum[rc[o]];
	}
	inline int ask(int cu,int l,int r,int k) {
		if(r<=k) return sum[cu];
		int mid=l+r>>1;
		int res=ask(lc[cu],l,mid,k);
		if(mid<k) return res+ask(rc[cu],mid+1,r,k);
		else return res;
	}
}pst;
int main() {
//	cout<<sqrt(4e5);   输出: 632...
	ios::sync_with_stdio(0);
	cin>>task;
	cin>>n>>m>>k>>q;
	fr(i,1,m) {
		int u,v; cin>>u>>v;
		e[u].push_back(v);
		by[u]|=(v==1);
	}
	fr(i,1,n) if(e[i].size()>S) {
		for(int t:e[i]) 
			b[t].push_back(i);
	}
	pst.ins(rt[0],rt[0],0,k,0,n-1); // 注意从0开始！！！
	fr(i,1,k) {
		int u; cin>>u;
		pst.ins(rt[i],rt[i-1],0,k,prs[u],-1);
		if(by[u]) ftr[u]=prs[u]=i;
		else if(e[u].size()<=S) 
			for(int t:e[u]) 
				ftr[u]=max(prs[t],ftr[u]);
		prs[u]=ftr[u];
		for(int t:b[u]) ftr[t]=max(ftr[t],prs[u]);
		pst.ins(rt[i],rt[i],0,k,prs[u],1);
	}
	while(q--) {
		int l,r;
		cin>>l>>r;
		cout<<pst.ask(rt[r],0,k,l-1)<<'\n';
	}
	return 0;
}
```

---

## 作者：Erine (赞：0)

首先将原图的每条边反向。

对于区间询问，我们应该考虑到的几种套路：

- 在线：信息支持快速合并性，使用线段树；或者某些情况不好合并，但是可以忽略掉较少的后效性，可以往分块预处理方向思考。
- 离线：莫队，扫描线等。

感觉了一下，发现在线并不好做。莫队也没有什么前途，因为在前面加点似乎是困难的。

于是考虑扫描线。往后加点似乎是最方便的扫描方式，即从小到大扫描 $r$，因为我们只需要讨论这个点会不会被加进来，不需要考虑其他点的变化。

那么我们可以确定一个大致的框架：扫描 $r$，用某数据结构维护所有 $l$ 的当前 $[l,r]$ 的答案。

此处就只需要解决，$r-1\to r$ 时数据结构内部的变化，即 $a_r$ 会在哪一些 $[l,r-1]$ 区间之后被加入。略加思考之后会发现有两个条件。

- 存在一个 $[l,r-1]$ 里被实际操作的点，这个点有一条边连向 $a_r$。
- 不存在一个点 $=a_r$ 并且已经被实际操作了。

观察力稍微强一点会发现两个条件满足的 $l$ 都是一段前缀，没观察到也可以简单推出来。那么我们就需要求：

- 一个最靠右的点 $rt_r$，满足 $[rt_r, r-1]$ 里被弹出来的点的出点里有 $a_r$。
- 一个最靠右的点 $lf_r$，满足 $[lf_r, r-1]$ 里被弹出来的点里有 $a_r$。

则 $(lf_r,rt_r]$ 就是 $r-1\to r$ 时需要 $+1$ 的区间。那么要求 $lf_r,rt_r$。

对于 $lf_r$，枚举被弹出来的点 $p$，用 $rt_p$ 更新所有出点；对于 $rt_r$，同样枚举被弹出来的点 $q$，用 $rt_p$ 更新当前对应点的标记。这样可以得到一个 $\Theta(n^2)$ 的做法。数据过于水，得到了 $84$ 分。

复杂度瓶颈在枚举出边，那只对出度 $\le \sqrt n$ 的点枚举，其余的点只会有 $\Theta(\sqrt n)$ 个，在每次计算 $rt$ 的时候枚举这样的点计算这部分贡献即可。时间复杂度 $\Theta(n\sqrt n)$，可以通过。

---

## 作者：strcmp (赞：0)

注意到后面释放的对前面的没有影响。

如果能预处理出最大的 $l_i$，$[l_i,\,i]$ 满足 $a_i$ 在经过区间内的操作后被释放。那么整个问题就变成了一个平凡的二维偏序问题。

其实想到这里差不多就结束了，但个人感觉第一步反而是最不容易想到的一步。

好，现在问题就是如何搞出来这个 $l_i$。

一个暴力的想法是：暴力升序枚举 $i$，如果 $i$ 直接指向 $1$ 那么 $l_i \leftarrow i$，否则 $l_i$ 是 $i$ 所指向的所有结点的 $l_i$ 最大值。

注意到如果一个度数很大的结点出现多次，那它就炸了。

这时候就引导我们考虑根号分治了。

对于一个结点 $u$，如果其出度 $\le S$ 则暴力参与计算。

如果出度 $> S$，则跳过。在之前每算出来一个点就暴力更新这个点对出度 $> S$ 的点的贡献。

$n,\,m,\,k,\,q$ 大致同阶。时间复杂度 $\Theta(nS + \frac{n^2}{S} + n \log n)$，平衡后得到 $\Theta(n \sqrt n)$。

```cpp
#include <bits/stdc++.h>
#define X first
#define Y second
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define per(i, a, b) for (int i = a; i >= b; i--)
#define pb push_back
using namespace std;
typedef long long int ll;
using ull = unsigned long long int;
using pii = pair<int, int>;
const int maxn = 4e5 + 10, mod = 1e9 + 7, S = 447;
int n, m, k, Q, c[maxn], ans[maxn], L[maxn], orz[maxn], a[maxn], t[maxn], p[maxn], e[maxn]; vector<pii> q[maxn]; vector<int> g[maxn], b[maxn];
inline void add(int x, int d) { while (x <= k) c[x] += d, x += x & -x; }
inline int qry(int x) { int s = 0; while (x) s += c[x], x -= x & -x; return s; }
int main() {
    scanf("%*d%d%d%d%d", &n, &m, &k, &Q);
    for (int i = 1, u, v; i <= m; i++) scanf("%d%d", &u, &v), g[u].pb(v), orz[u] |= (v == 1);
    rep(u, 1, n) if (g[u].size() > S) for (int v : g[u]) b[v].pb(u);
    rep(i, 1, k) {
        scanf("%d", &a[i]); int u = a[i];
        if (orz[u]) L[i] = p[a[i]] = i;
        else {
            if (g[u].size() <= S) for (int v : g[u]) L[i] = max(L[i], p[v]);
            else L[i] = t[u]; p[a[i]] = L[i];
        }
        for (int v : b[u]) t[v] = max(t[v], L[i]);
    }
    for (int i = 1, l, r; i <= Q; i++) scanf("%d%d", &l, &r), q[r].pb({ l, i }); int cnt = 0;
    rep(i, 1, k) {
        if (e[a[i]]) add(e[a[i]], -1), --cnt;
        if (L[i]) add(e[a[i]] = L[i], 1), ++cnt;
        for (pii x : q[i]) ans[x.Y] = n - 1 - cnt + qry(x.X - 1);
    }
    rep(i, 1, Q) printf("%d\n", ans[i]);
    return 0;
}
```

---

## 作者：0xyz (赞：0)

这一题我扫了一眼官方题解，看到 $lst$ 就想出正解了。从左到右扫描，扫到 $i$ 时令 $r=i$，定义 $lst_t$ 为可以使得 $t$ 点剧团演出的最大 $l$。对于 $lst$ 数组的修改，发现当 $i$ 增大时，只有一个点有改变：$lst_{a_i}\leftarrow\max(lst_{a_i},h_{a_i}=\max\limits_{(a_i,j)\in E}\{lst_j\})$。如果暴力枚举 $a_i$ 的出边，是 $O(km)$ 的，可能超时。所以我们分类讨论：
- 如果 $a_i$ 的出边不超过 $B$ 条，则暴力枚举其出边，时间复杂度 $O(kB)$。
- 如果 $a_i$ 的出边超过 $B$ 条，这样的点只有最多 $\frac{m}{B}$ 个，从而我们对于所有点都把它的前驱中所有出边超过 $B$ 条的点的编号记录在 $p$ 中，当 $lst_x$ 更新的时候，就顺便更新一下 $p_x$ 中节点的 $h$，时间复杂度 $O(\frac{m}{B})$。

取 $B=\sqrt m$，就得到了一个时空复杂度均 $O(k\sqrt m)$ 的方法，且常数极小。

在实时更新 $lst$ 之后，我们对于 $r=i$ 的询问 $l$，实际上就是对于 $1\le j\le n$，要求出有多少 $lst_j\ge l$。在 $lst$ 的值域上开一个树状数组，维护单点加减，查询前缀和就行了。

总时间复杂度 $O(k\sqrt m+(k+q)\log k)$。空间复杂度 $O(k\sqrt m)$。代码好短啊。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int _=4e5+5;
int B,C,n,m,k,q,a[_],c[_],d[_],h[_],l[_],s[_],v[_];
vector<int>e[_],f[_],p[_];
vector<pair<int,int> >b[_];
void add(int x,int v){
	for(x++;x<=k;x+=x&-x)c[x]+=v;
}
int sum(int x){
	int o=0;
	for(x++;x;x-=x&-x)o+=c[x];
	return o;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>C>>n>>m>>k>>q;B=sqrt(m);
	for(int i=1,x,y;i<=m;i++)cin>>x>>y,d[x]++,e[x].push_back(y),f[y].push_back(x);
	for(int i=1;i<=n;i++)
		for(auto j:f[i])
			if(d[j]>B)p[i].push_back(j);
	for(auto i:f[1])v[i]=1;
	for(int i=1;i<=k;i++)cin>>a[i];
	for(int i=1,x,y;i<=q;i++)cin>>x>>y,b[y].push_back({x,i});
	for(int i=1;i<=k;i++){
		add(l[a[i]],-1);
		if(d[a[i]]<=B)for(auto j:e[a[i]])h[a[i]]=max(h[a[i]],l[j]);
		if(v[a[i]])l[a[i]]=i;
		add(l[a[i]]=max(l[a[i]],h[a[i]]),1);
		for(auto j:p[a[i]])h[j]=max(h[j],l[a[i]]);
		for(auto j:b[i])s[j.second]=n-1+sum(j.first-1);
	}
	for(int i=1;i<=q;i++)cout<<s[i]<<'\n';
	return 0;
}
```

---


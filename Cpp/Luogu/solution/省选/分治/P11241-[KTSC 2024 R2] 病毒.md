# [KTSC 2024 R2] 病毒

## 题目背景

**请用 C++14 或 C++17 提交本题**

你需要在代码开头加入如下代码：

```cpp
#include<vector>
std::vector<long long> find_spread(int N, int M, std::vector<int> A, std::vector<int> B, std::vector<int> P, std::vector<int> D, std::vector<int> C);
```

## 题目描述

**题目译自 [2024년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2024/)  T4 「[바이러스](https://assets.ioikorea.kr/ioitst/2024/2/virus/virus_statement.pdf)」**

由于上次新冠疫情的严重影响，KOI 城市决定为未来可能发生的疫情做好充分准备。为此，KOI 城市希望分析当前城市结构对病毒的脆弱程度。

KOI 城市由 $N$ 个地点和 $N-1$ 条双向道路组成，任意两个不同的地点都可以通过这些道路互相到达。也就是说，城市的道路网络是一个树结构。每个地点用 $0$ 到 $N-1$ 的不同整数表示。由于城市的道路网络是树结构，对于任意两个地点 $u$ 和 $v$，从 $u$ 到 $v$ 的唯一简单路径上的边数定义为 $u$ 和 $v$ 之间的距离。

KOI 城市有 $M$ 名居民。对于每个 $j$ $(0 \leq j \leq M-1)$，第 $j$ 个人住在 $P[j]$ 号地点，并且可以到达距离 $P[j]$ 不超过 $D[j]$ 的地点。

KOI 城市的病毒学家们建立了一个模型来模拟病毒在两个人之间的传播过程。对于每个 $0 \leq v \leq N-1$，第 $v$ 号地点的传播时间用一个正整数 $C[v]$ 表示。假设第 $j$ 个人在时间 $t$ 首次感染病毒，并且第 $k$ 个人从第 $j$ 个人那里接收到病毒。如果存在一个地点 $w$，使得 $w$ 号地点与 $P[j]$ 号地点的距离不超过 $D[j]$，且 $w$ 号地点与 $P[k]$ 号地点的距离不超过 $D[k]$，那么 $w$ 号地点就是传播的媒介。

如果没有这样的传播媒介，第 $k$ 个人不会直接从第 $j$ 个人那里感染病毒（当然，他可能通过其他人间接感染）。如果存在传播媒介，那么在所有可能的传播媒介中，选择传播时间最短的地点 $x$。如果第 $k$ 个人在时间 $t+C[x]$ 之前没有感染病毒，那么他将在时间 $t+C[x]$ 被第 $j$ 个人感染。病毒以这种方式在所有不同的两个人之间传播。

在上述模型下，KOI 城市的研究人员希望计算当第 $0$ 个人在时间 $0$ 感染病毒时，其他人何时感染病毒。你需要计算对于每个 $0 \leq j \leq M-1$，第 $j$ 个人首次感染病毒的时间。如果第 $j$ 个人没有感染病毒，则记录为 $-1$。

你需要实现以下函数：

```cpp
std::vector<long long> find_spread(int N, int M, std::vector<int> A, std::vector<int> B, std::vector<int> P, std::vector<int> D, std::vector<int> C);
```

- `N`：KOI 城市的地点数量。
- `M`：KOI 城市的居民数量。
- `A, B`：长度为 $N-1$ 的数组。对于每个 $i$ $(0 \leq i \leq N-2)$，存在一条连接 $A[i]$ 和 $B[i]$ 的道路。每条道路在两个数组中只出现一次。
- `P, D`：长度为 $M$ 的数组。对于每个 $j$ $(0 \leq j \leq M-1)$，第 $j$ 个人住在 $P[j]$ 号地点，并且可以到达距离 $P[j]$ 不超过 $D[j]$ 的地点。
- `C`：长度为 $N$ 的数组。对于每个 $v$ $(0 \leq v \leq N-1)$，第 $v$ 号地点的传播时间为 $C[v]$。
- 该函数返回一个长度为 $M$ 的数组 $T$。对于每个 $j$ $(0 \leq j \leq M-1)$，如果第 $j$ 个人感染病毒，$T[j]$ 表示他首次感染病毒的时间；如果没有感染，则为 $-1$。
- 该函数在每个测试用例中只会被调用一次。


## 说明/提示

对于所有输入数据，满足：

- $1 \leq N \leq 10^5$
- $1 \leq M \leq 10^5$
- 对于所有 $i$ $(0 \leq i \leq N-2)$，$0 \leq A[i], B[i] \leq N-1, A[i] \neq B[i]$
- 对于所有 $j$ $(0 \leq j \leq M-1)$，$0 \leq P[j], D[j] \leq N-1$
- 对于所有 $v$ $(0 \leq v \leq N-1)$，$1 \leq C[v] \leq 10^{9}$

详细子任务附加限制及分值如下表所示。

| 子任务 | 分值 | 附加限制 |
| :-: | :-: | :-: |
| $1$ | $5$ | $N \leq 500, M \leq 500$；<br>对于所有 $i$ $(0 \leq i \leq N-2)$，$A[i]=i, B[i]=i+1$ |
| $2$ | $8$ | $N \leq 5000, M \leq 5000$；<br>对于所有 $i$ $(0 \leq i \leq N-2)$，$A[i]=i, B[i]=i+1$ |
| $3$ | $27$ | 对于所有 $i$ $(0 \leq i \leq N-2)$，$A[i]=i, B[i]=i+1$ |
| $4$ | $5$ | $N \leq 500, M \leq 500$ |
| $5$ | $8$ | $N \leq 5000, M \leq 5000$ |
| $6$ | $47$ | 无附加限制 |

# 题解

## 作者：是青白呀 (赞：1)

考虑一个建图方式：建立 $n$ 个点表示病毒的中转点，对每个人的点 $i$，找到所有距离 $p_i$ 小于等于 $d_i$ 的树上点，它们的中转点向 $i$ 连 $0$ 的边，$i$ 向它们的中转点连 $c_i$ 的边。直接跑 dij 可以做到 $O(n^2\log n)$。

考虑优化“$i$ 这个人向所有距离它小于等于 $d_i$ 的中转点连权值为 $v$ 的正向或反向边”。考虑点分治优化，一个深度为 $dep_i$ 的点能向所有深度小于等于 $d_i-dep_i$ 的点连边。下面以正向为例：考虑建立 $dep+1$ 个虚点，每个虚点向该深度下的实际中转点连 $v$ 的边；虚点之间由深度 $x\to x-1$ 连 $0$ 边；考察每个人对应的点，向 $d_i-dep_i$ 对应的虚点连 $0$ 边。反向边只需要将上述所有边反向，且去掉虚点连出来的边的权值即可。

这样，点分治过程中每个连通块的点、边数为 $O(size)$，总数为 $O(n\log n)$ 级别。直接跑 dij 可以做到 $O(n\log^2 n)$，已经可以通过了。

还有一些优化。对于每个中转点，我们再拆成入点和出点，这样只有 $O(n)$ 条出入点之间的边有权值。在 dij 的过程中，我们借用 01BFS 的思想，对于有权值的边，我们扔进优先队列；对于 $0$ 权边，我们使用普通队列，直接维护。每次弹出时，优先弹出普通堆的点即可。这样只有 $O(n)$ 条边会进堆，复杂度做到 $O(n\log n)$。似乎优化效果不明显。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define pii pair<int,int>
#define mp make_pair
#define fir first
#define sec second
#define ls(x) (x<<1)
#define rs(x) ((x<<1)|1)
#define lowbit(i) (i&-i)
#define qingbai qwq
using namespace std;
typedef long long ll;
const int N=1e5+5,M=2e6+5,mo=1e9+7;
const ll inf=(ll)1e18+7;
void read(int &a){
    int x=0,w=1;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-')w=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        x=(x<<3)+(x<<1)+ch-'0';
        ch=getchar();
    }
    a=x*w;
}
int n,m,p[N],d[N],c[N];
vector<int>et[N];
int cntp,id[N];
vector<int>perc[N];
int maxs[N],sz[N],rt,tot;
bool vis[N];
void dfs1(int x,int f){
    maxs[x]=0,sz[x]=1;
    for(auto j:et[x]){
        if(vis[j]||j==f)continue;
        dfs1(j,x),sz[x]+=sz[j],maxs[x]=max(maxs[x],sz[j]);
    }
    maxs[x]=max(maxs[x],tot-sz[x]);
    if(maxs[x]<maxs[rt])rt=x;
}
vector<pii>e[N*45];
int dep[N],idd[N],maxd=0;
void dfs2(int x,int f){
    dep[x]=dep[f]+1,maxd=max(maxd,dep[x]);
    for(auto j:et[x]){
        if(j==f||vis[j])continue;
        dfs2(j,x);
    }
}
void dfs3(int x,int f){
    for(auto j:et[x])
        if(j!=f&&!vis[j])dfs3(j,x);
    for(auto j:perc[x]){
        int topos=min(maxd,d[j]-dep[x]);
        if(topos<0)continue;
        e[id[j]].push_back(mp(idd[topos],0));
        e[idd[topos]+1].push_back(mp(id[j],0));
    }
    e[idd[dep[x]]].push_back(mp(x,0));
    e[x+n].push_back(mp(idd[dep[x]]+1,0));
}
void dfz(int x){
    maxd=0,dep[0]=-1,dfs2(x,0);
    rep(i,0,maxd)
        idd[i]=++cntp,cntp++;
    rep(i,1,maxd){
        e[idd[i]].push_back(mp(idd[i-1],0));
        e[idd[i-1]+1].push_back(mp(idd[i]+1,0));
    }
    dfs3(x,0);
    vis[x]=1;
    for(auto j:et[x]){
        if(vis[j])continue;
        rt=0,tot=sz[j],dfs1(j,x),dfz(rt);
    }
}
ll dis[N*45];
bool visd[N*45];
void dij(){
    queue<pair<ll,int>>q;
    priority_queue<pair<ll,int>,vector<pair<ll,int>>,greater<pair<ll,int>>>pq;
    rep(i,1,cntp)
        dis[i]=inf,visd[i]=0;
    dis[id[1]]=0,pq.push(mp(0ll,id[1]));
    while(!q.empty()||!pq.empty()){
        int x;ll v;
        if(!q.empty())tie(v,x)=q.front(),q.pop();
        else tie(v,x)=pq.top(),pq.pop();
        if(visd[x])continue;
        visd[x]=1;
        for(auto j:e[x]){
            if(visd[j.fir]||dis[j.fir]<=dis[x]+j.sec)continue;
            dis[j.fir]=dis[x]+j.sec;
            if(!j.sec)q.push(mp(dis[j.fir],j.fir));
            else pq.push(mp(dis[j.fir],j.fir));
        }
    }
}
vector<ll>ans;
vector<long long> find_spread(int N, int M, vector<int> A, vector<int> B, vector<int> P, vector<int> D, vector<int> C){
    n=N,m=M,cntp=2*n;
    rep(i,0,n-2)
        et[A[i]+1].push_back(B[i]+1),et[B[i]+1].push_back(A[i]+1);
    rep(i,1,m)
        p[i]=P[i-1]+1,d[i]=D[i-1],perc[p[i]].push_back(i);
    rep(i,1,n)
        c[i]=C[i-1];
    rep(i,1,m)
        id[i]=++cntp;
    tot=n,rt=0,maxs[0]=n+2,dfs1(1,0),dfz(rt);
    rep(i,1,n)
        e[i].push_back(mp(i+n,c[i]));
    dij();
    rep(i,1,m){
        if(dis[id[i]]==inf)ans.push_back(-1);
        else ans.push_back(dis[id[i]]);
    }
    return ans;
}
```

---

## 作者：I_am_Accepted (赞：1)

点分树优化建图模板题。

每个人 $i$ 向 $p_i$ 点的 $d_i$ 领域连边，每个点 $i$ 有 $c_i$ 的点权，每个人 $i$ 再从 $p_i$ 点的 $d_i$ 领域连边。从 $0$ 号人跑 dijkstra 即可。

优化建图（只考虑人向点连边，反过来同理），领域可以表示为点分树上 $\log$ 个距离某个根一定距离之内的点集的并。对每个点分子树的根，建最大深度 $+1$ 个点 $n_0,\dots,n_d$，$n_i$ 连向到根距离恰为 $i$ 的子数内所有点。所有 $n_{i+1}$ 向 $n_{i}$ 连边。

这样向 $n_i$ 连边，则能到达所有到根距离 $\le i$ 的点。

空间 $O(n\log)$，时间 $O(n\log^2)$。

---


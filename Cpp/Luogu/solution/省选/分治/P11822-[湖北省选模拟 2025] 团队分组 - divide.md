# [湖北省选模拟 2025] 团队分组 / divide

## 题目描述

小 X 决定建立一个团队，但是现在团队里只有小 X 一个人。

在接下的 $n$ 天里，小 X 每天都会招募到一个人，其中加入的第 $i$ 个人的能力值为 $v_i$，小 X 的能力值为 $v_0=10^{10^{100}}$。

为了更好管理整个团队，小 X 需要将团队分成小组。具体的，假设现在已经有 $k$ 个人加入了团队，小 X 希望找到一个序列 $0=a_0<a_1<\dots <a_m=k+1$，使得对于所有 $0\le i<m-1$，有 $\sum\limits_{j=a_i}^{a_{i+1}-1}v_j>\sum\limits_{j=a_{i+1}}^{a_{i+2}-1}v_j$。

为了让新加入的队员们感受到幸福感，小 X 希望 $a_m$ 尽可能大，在此基础上 $a_{m-1}$ 尽可能大，在此基础上 $a_{m-2}$ 尽可能大，以此类推。换句话说，让序列 $a_m,a_{m-1},a_{m-2}\dots a_1$ 的字典序尽可能大。

但是小 X 现在正忙于招募队员，所以他希望你来帮他解决这一问题，你只需要告诉他在 $k=1,2\dots n$ 的时候， $\sum\limits_{i=0}^m(i\times a_i)$ 的值即可。

## 说明/提示

**【样例 1 解释】**

- 对于 $k=1$，有 $m=2$，$a_0=0,a_1=1,a_2=2$，输出 $0\times 0+1\times 1+2\times 2=5$。
- 对于 $k=2$，有 $m=2$，$a_0=0,a_1=2,a_2=3$，输出 $0\times 0+1\times 2+2\times 3=8$。
- 对于 $k=3$，有 $m=3$，$a_0=0,a_1=1,a_2=3,a_3=4$，输出 $0\times 0+1\times 1+2\times 3+3\times 4=19$。
- 对于 $k=4$，有 $m=4$，$a_0=0,a_1=1,a_2=3,a_3=4,a_4=5$，输出 $0\times 0+1\times 1+2\times 3+3\times 4+4\times 5=39$。
- 对于 $k=5$，有 $m=3$，$a_0=0,a_1=3,a_2=5,a_3=6$，输出 $0\times 0+1\times 3+2\times 5+3\times 6=31$。

**【样例 2】**

见选手目录下的 `divide/divide2.in` 与 `divide/divide2.ans`。

样例 $2$ 满足测试点 $1\sim 3$ 的限制。

**【样例 3】**

见选手目录下的 `divide/divide3.in` 与 `divide/divide3.ans`。

样例 $3$ 满足测试点 $4\sim 6$ 的限制。

**【样例 4】**

见选手目录下的 `divide/divide4.in` 与 `divide/divide4.ans`。

样例 $4$ 满足测试点 $7\sim 10$ 的限制。

**【样例 5】**

见选手目录下的 `divide/divide5.in` 与 `divide/divide5.ans`。

样例 $5$ 满足测试点 $13\sim 15$ 的限制。

**【子任务】**

对于全部的测试数据，保证 $1\le n\le 10^5$，$1\le v_i\le n$。

| 测试点 | $n \le $ | 特殊性质 |
| :--: | :--: | :--: |
| $1\sim 3$ | $10$ | 无 |
| $4\sim 6$ | $100$ | 无 |
| $7\sim 10$ | $5000$ | 无 |
| $11,12$ | $5\times 10^4$ | 无 |
| $13\sim 15$ | $10^5$ | $v_i$ 随机生成 |
| $16\sim 20$ | $10^5$ | 无

## 样例 #1

### 输入

```
5
1 3 3 2 4
```

### 输出

```
5 8 19 39 31
```

# 题解

## 作者：寻逍遥2006 (赞：21)

### 测试点  $1\sim 3$

直接搜索所有可能的解，由于 $n$ 很小可以直接通过。

### 测试点 $4\sim 10$

题目相当于对于每一个前缀，要将其分成若干个区间，要求区间和单调递减。同时字典序最小的限制要求后面的区间尽可能短，这个过程可以之间贪心。

直接 $O(n)$ 模拟这一个过程，总时间复杂度 $O(n^2)$。

### 测试点 $11\sim 17$

考虑记 $f_{i,j}$ 表示当前这一段是 $[i,j)$，处理 $[0,j)$ 一共要分多少组，同时用 $g_{i,j}$ 维护需要维护的求和。

因此有转移 $f_{i,j}=f_{k,i}+1$，$g_{i,j}=g_{k,i}+f_{i,j}i$，其中 $k$ 为最大的满足 $\sum\limits_{g=k}^{i-1}v_g>\sum\limits_{g=i}^{j-1}v_g$ 的数。

记 $sum_i=\sum\limits_{j=i}^nv_i$，对于 $f_{i,j}$ 而言的转移点就是最大的 $k$，满足 $sum_k-sum_i>sum_i-sum_j$，也就是 $sum_k>2sum_i-sum_j$。

最终就是要求所有 $f_{i,i+1}$ 和 $g_{i,i+1}$。但由于每一个点仅由一个点转移而来，所以考虑所有有用的状态数量。发现任何有用的状态都对应一个区间 $[i,j)$，其在某一个前缀的划分方案中出现。

对于 $i-j\le \sqrt{n}$ 区间，这样的区间一共只有 $O(n\sqrt{n})$ 个；对于 $i-j>\sqrt{n}$ 的区间，一个前缀中最多只有 $O(\sqrt{n})$ 个长度 $>\sqrt{n}$ 的组，所以最多只有 $O(n\sqrt{n})$ 个有用的区间。因此，有用的状态最多只有 $O(n\sqrt{n})$ 个。

直接使用记忆化搜索，这样会访问到的状态数就是 $O(n\sqrt{n})$ 的。现在的问题就变成如何找到转移的 $k$，对于每一个状态使用二分可以做到 $O(\log n)$。

总复杂度 $O(n\sqrt{n}\log n)$。

常数较大的可能只能通过前一部分。

### 满分做法

优化找到每一个状态转移的 $k$。

按照 $i$ 从大到小扫描，找到所有我们需要转移的 $j$。假设对于 $i$ 的所有 $j$ 已经按照从小到大排序了。

对序列进行分块，对于一个点 $i$，可以直接暴力 $O(\sqrt{n}+cnt)$ 扫描出所有 $k$ 和 $i$ 在同一个块内的 $j$ 对应的转移点，其中 $cnt$ 为满足这样条件的 $j$ 的数量。

对于 $k$ 与 $i$ 不在同一个块的转移，可以将当前块内的所有这样的状态 $(i,j)$ 按照 $2sum_i-sum_j$ 进行排序，然后 $O(n)$ 扫描一遍所有的 $k$，即可同时扫描所有的 $(i,j)$ 即可得到转移。由于 $sum_i$ 的值有上界 $n^2$，排序可以做到 $O(n)$。

对于一个点 $i$，如果所有的 $j$ 是从大到小加入的，就可以保证在处理 $i$ 时所有的 $j$ 已经排序完成，因此在对于每一个点加入需要转移的状态时，需要按照 $i$ 的大小从大到小加入。

最后直接按照 $i$ 从小到大依次求解 $f$ 和 $g$ 即可。

总时间复杂度 $O(n\sqrt{n})$。

---

## 作者：251Sec (赞：19)

我们有显然的分段策略，就是结尾一个元素单独成段，接下来倒序遍历，一旦和大于上一段的和就开一个新段。

注意到如下事实：如果两次询问开了同一个段 $[l,r]$，那么 $[1,l-1]$ 的决策是一样的，可以记忆化。

实际上，我们可以说明，记忆化之后，状态数是 $O(n \sqrt n)$ 的：因为 $r-l \le \sqrt n$ 的状态只有 $O(n\sqrt n)$ 个，而 $r-l > \sqrt n$ 的状态，因为我们访问的总长度只有 $n^2$，因此这样的状态数也是 $O(n\sqrt n)$ 的。

我们找一个新段的时间复杂度是 $O(\log n)$ 的，因为要二分。总复杂度 $O(n \sqrt n \log n)$。

下面是一些卡常小技巧：首先不要用哈希表记忆化，而是只记忆化 $r-l \le \sqrt n$ 的状态，显然剩下的状态不记忆化复杂度也是对的，哈希表的常数过于大了。另外二分的上界不要设成 $n$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int B = 200;
int n;
ll a[100005];
int GetPre(int i, ll w) {
	int p = lower_bound(a, a + i + 1, a[i] - w) - a - 1;
	return p;
}
struct Node {
	ll ans, cnt;
};
Node f[100005][B + 5];
int g[100005], gC;
int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%lld", a + i), a[i] += a[i - 1];
	memset(f, -1, sizeof(f));
	for (int i = 1; i <= n; i++) {
		int j = i;
		gC = 0;
		g[++gC] = j;
		ll las = 0, cnt = 0, ans = 0;
		while (j >= 0) {
			int k = GetPre(j, las);
			g[++gC] = k;
			if (j - k <= 200) {
				auto w = f[j][j - k];
				if (w.ans >= 0) {
					cnt = w.cnt, ans = w.ans;
					break;
				}
			}
			if (k >= 0) las = a[j] - a[k];
			j = k;
		}
		reverse(g + 1, g + gC + 1);
		for (int j = 2; j <= gC; j++) {
			if (g[j] - g[j - 1] <= B) f[g[j]][g[j] - g[j - 1]] = { ans, cnt };
			ans += (g[j] + 1) * ++cnt;
		}
		printf("%lld ", ans);
	}
	return 0;
}
```

---

## 作者：Polarisx (赞：9)

[题目传送门](https://www.luogu.com.cn/problem/P11822)。

## 思路

首先暴力的做法，对于每个右端点 $r$，不断二分找出比上一个区间和更大的最小左端点 $l$，设一个块长 $B$，若 $r-l\le B$，则记忆化，否则暴力遍历，块长小于 $B$ 的块总共遍历 $\mathcal O(nB)$ 次，时间复杂度可做到 $\mathcal O(n\sqrt {n\log n})$，理论上 $B$ 取 $\sqrt{n\log n}$ 最优，不过实测取 $B=20$ 最优。


```cpp
#include <bits/stdc++.h>

#define ll long long
using namespace std;

const ll inf=1.2e10;
const int Maxn=2e5+7; 
const int B=20;
int n;
int a[Maxn];
ll sm[Maxn];

int fval[Maxn][B+5];
ll mp[Maxn][B+5];

int top;
int stk[Maxn];

int main(){	
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	sm[0]=inf;
	for(int i=1;i<=n;i++) sm[i]=sm[i-1]+a[i];
	
	for(int i=1;i<=n;i++){
		ll ret=0; int num=0;
		int pos=i; ll now=0;
		top=0;
		
		while(pos>=0){
			int l=0,r=pos,sv=0;
			while(l<=r){
				int mid=l+r>>1;
				ll sums=sm[pos];
				if(mid) sums-=sm[mid-1];
				if(sums>now) l=mid+1,sv=mid;
				else r=mid-1;
			}
			int len=pos-sv+1;
			if(pos-sv<=B and fval[sv][len]){
				ret+=mp[sv][len];
				num+=fval[sv][len];
				break;
			}
			now=sm[pos]-sm[sv-1];
			pos=sv-1;
			stk[++top]=sv;
		}
		reverse(stk+1,stk+top+1);
		stk[top+1]=i+1;
		for(int j=1;j<=top;j++){
			++num; ret=ret+1ll*stk[j+1]*num;
			if(stk[j+1]-stk[j]<=B){
				int len=stk[j+1]-stk[j];
				fval[stk[j]][len]=num;
				mp[stk[j]][len]=ret;	
			}
		}
		
		printf("%lld ",ret);
	}

	return 0;
}

```

---

## 作者：xuyiyang (赞：7)

### [P11822 [湖北省选模拟 2025] 团队分组 / divide](https://www.luogu.com.cn/problem/P11822)
### Solution
首先 $\mathcal O(n^2)$ 是简单的，考虑字典序从大到小确定 $a$，但这个做法看似不可优化。注意到若两次选了同一个区间 $[l,r)$，那么 $l$ 前面的区间一定是与之前一样的，可以记忆化。下面证明本做法时间复杂度为 $\mathcal O(n \sqrt n \log n)$。$\\$
设阈值 $B$，$p$ 选择的区间为 $[l,p)$，长度为 $L$。$\\$
- $L \ge B$，则最多遍历 $\frac{n}{B}$ 个**不交**区间，所以总复杂度 $\mathcal O(\frac{n^2}{B})$。
- $L < B$，则记忆化，一共 $\mathcal O(nB)$ 个状态，所以是 $\mathcal O(nB)$ 的。

取 $B = \sqrt n$，加上二分的复杂度，则 $\mathcal O(n \sqrt n \log n)$。
```cpp
int n, w[N];
LL s[N];
pii val[N][B];

LL sum(int l, int r) {
	if (!l) return s[r];
	return s[r] - s[l - 1];
}
pii solve(int p, int lst) {
	if (p == 0) return {0, 0};
	int l = lower_bound(s, s + p, 2 * s[p - 1] - s[lst - 1]) - s;
	int L = p - l; if (L < B && val[p][L].fi) return val[p][L];
	pii st = solve(l, p); st = {st.fi + 1, st.se + 1LL * (st.fi + 1) * p};
	if (L < B) return val[p][L] = st; 
	return st;
}

int main() {
	freopen("divide.in", "r", stdin); freopen("divide.out", "w", stdout);
	rd(n);
	for (int i = 1; i <= n; i ++ ) rd(w[i]);
	s[0] = 1e11;
	for (int i = 1; i <= n; i ++ ) {
		s[i] = s[i - 1] + w[i];
		if (i < B) val[i][i] = {1, i};
	}
	for (int i = 1; i <= n; i ++ ) {
		pii st = solve(i, i + 1);
		printf("%lld ", (st.se + 1LL * (st.fi + 1) * (i + 1)));
	}
	return 0;
}
```

---

## 作者：SDSXC (赞：5)

搞笑做法~~目前好像是代码最短的~~

首先，我们显然的有从后往前每次取大于上一段的最短的一段，预处理前缀和再暴力二分，最劣复杂度 $O(n^2\log(n))$

这样在刻意构造的数据下显然会 TLE，我们观察我们进行的查询，不难发现其中有大量重复的，所以考虑记忆化。但是直接记忆化 $f_{i,j}$ 表示到 $i$ 号位置，后一段为 $[i+1,j]$ 直接存会爆空间，用 unordered_map 会 TLE。

所以我们继续观察，发现其实对每个位置的查询中的连续段并不多，只记忆化上一次查询。

复杂度 $O(能过)$，感性理解一下，如果 $a_i\geq a_{i-1}$，次数非常有限，否则可以靠记忆化的内容比较快速的完成查询。

如果不放心觉得这样可能还会被卡可以尝试每个位置记忆化两个或三个。

具体细节见代码


```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 100009
#define fi first
#define se second
using namespace std;
ll s[N];
int n;
ll f[N]; //f[i]表示上次记忆化的是哪个查询
pair<ll,int> g[N];//上次记忆化的内容
pair<ll,int> calc(int x,ll y){//参数x表示区间[0,x]，y表示后面一段的和，返回值里面first是前面几段的值，second是前面有几段
	ll z=s[x]-y;
	if(z<=0||(!x)) return make_pair(0ll,0);
	if(y&&f[x]==y) return g[x];
	int t=lower_bound(s+1,s+x+1,z)-s;
	auto tmp=calc(t-1,s[x]-s[t-1]);
	tmp=make_pair(tmp.fi+1ll*(tmp.se+1)*t,tmp.se+1);
	g[x]=tmp;f[x]=y;
	return tmp;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld",&s[i]);s[i]+=s[i-1];
		auto tmp=calc(i,0ll);
		printf("%lld ",tmp.fi+1ll*(tmp.se+1)*(i+1));
	}
	return 0;
}
```

---

## 作者：Purslane (赞：4)

# Solution

这也太难了吧。

先考虑怎么 $O(n^2)$ 做。显然你要把最后一个人单独分一组，然后取最短的后缀使得它比最后一个人高，以此类推。

发现你实际上在计算这样一个事情：给定 $r$ 和 $lim$，然后不断往前找。

所以考虑加一个记忆化：对于 $r$，如果 $lim$ 这个数之间已经算过了就直接返回值。

取阈值 $B$。显然 $lim$ 之和上一个端点与 $r$ 的距离有关。所以只有 $O(nB)$ 个长度 $\le B$ 的 $lim$，以及 $O(\dfrac{n^2}{B})$ 个长度 $\ge B$ 的 $lim$（因为它们互不相交）。所以可以做到 $O(n \sqrt n)$ 种状态。

直接做就是 $O(n \sqrt n \log n)$ 的了，可能可以拿到 $80$ 分。一种优化方式为，不用记忆化长度 $\ge \sqrt n$ 的限制；另一种优化方式为，打表发现给定 $r$ 查询的 $lim$ **几乎是单调递增的**。所以你只需要存一下上一次访问此处的 $lim$ 和答案即可。

贴一个后者的代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e5+10;
int n,v[MAXN];
ll pre[MAXN],lst[MAXN];
pair<int,ll> mp[MAXN];
pair<int,ll> calc(int s,ll lim) {
	if(pre[s]<=lim) return {0,0};
	if(lst[s]==lim) return mp[s];
	int id=lower_bound(pre+1,pre+s+1,pre[s]-lim)-pre-1;
	auto pr=calc(id,pre[s]-pre[id]);
	return lst[s]=lim,mp[s]={pr.first+1,pr.second+1ll*(pr.first+1)*(id+1)};
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n; memset(lst,-1,sizeof(lst));
	ffor(i,1,n) cin>>v[i],pre[i]=pre[i-1]+v[i];
	ffor(i,1,n) {
		auto pr=calc(i,0);
		cout<<pr.second+1ll*(pr.first+1)*(i+1)<<' ';	
	}
	return 0;
}
```

---

## 作者：Lucyna_Kushinada (赞：3)

# P11822 [湖北省选模拟 2025] 团队分组 / divide

## 题意

有一个序列 $v$，第 $i$ 天会有 $v_i$ 加入 $v$ 的末尾，且 $v_0=10^{10^{100}}$。

你需要将 $v$ 分段。具体的，假设现在已经有 $|v|=k$，请找到一个序列 $0=a_0<a_1<\dots <a_m=k+1$，使得对于所有 $0\le i<m-1$，有 $\sum\limits_{j=a_i}^{a_{i+1}-1}v_j>\sum\limits_{j=a_{i+1}}^{a_{i+2}-1}v_j$。

要求构造出的 $a_m$ 尽可能大，在此基础上 $a_{m-1}$ 尽可能大，在此基础上 $a_{m-2}$ 尽可能大，以此类推。即让序列 $a_m,a_{m-1},a_{m-2}\dots a_1$ 的字典序尽可能大。

分别求出在 $k=1,2\dots n$ 的时候， $\sum\limits_{i=0}^m(i\times a_i)$ 的值。

## 题解

知识点：二分，记忆化，根号分治。

启发：

- 考虑一定范围内的记忆化。

确实很有省选 D1T1 的风格。

考虑怎样才能使得分段方式最优，这是类似于最大化字典序的问题，不难得出一个简明的贪心算法：

让最后一个数自成一段，往前扫，只要扫过的和大于前一段的和就新开一段，朴素实现复杂度是 $O(n)$。

题目要求对 $v$ 每一个的前缀都跑一遍这样的算法，不过显然不能暴力地对每一段都跑一遍，这样是 $O(n^2)$ 的。

上述贪心过程可以用二分快速找到前一个端点，可以用类似 `sol(l,r)` 来递归实现这个贪心过程。

注意到如果递归到了一个段 $(l,r)$，那么 $l$ 之前的分段方式则可以完全确定，可以考虑记忆化 $(l,r)$ 时的答案。

可 $(l,r)$ 的规模是 $O(n^2)$ 级别的，无脑记忆化会爆空间。

为了解决这个问题，不妨设置一个阈值 $B$，对于 $r-l+1\le B$ 的记忆化，对于 $r-l+1>B$ 的暴力跳。

综合分析可知 $B=\sqrt{n}$ 时达到理论最优复杂度（但实际上 $B$ 取 $24$ 左右的时候最快，不知道是不是数据问题），$r-l+1\le B$ 的 $(l,r)$ 规模是 $O(n\sqrt{n})$ 的，$r-l+1>B$ 的 $(l,r)$ 向前跳是复杂度 $O(\sqrt{n})$ 的，每个 $i$ 往前跳也最多 $O(n\sqrt{n})$。

所以可以达到理论最优复杂度 $O(n \sqrt{n} \log_2{n} )$。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define rep(i,l,r) for(int i=(l);i<=(r);++i)
#define per(i,l,r) for(int i=(r);i>=(l);--i)
#define pr pair<int,int>
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(),(x).end()
#define sz(x) (x).size()
#define bg(x) (x).begin()
#define ed(x) (x).end()

#define N 102506
#define M 321
#define int long long

int n,len,a[N];
pr mem[N][M];

inline pr sol(int l,int r){
    if(r-l+1<=len&&mem[l][r].fi){
        return mem[l][r];
    }

    int id=lower_bound(a,a+l,2*a[l-1]-a[r-1])-a;

    pr res;

    if(id){
        res=sol(id,l);
    }
    else{
        res={0,0};
    }

    res.fi+=res.se*id;
    res.se++;

    if(r-l+1<=len){
        return mem[l][r]=res;
    }
    return res;
}

signed main(){
    // freopen("divide.in","r",stdin);
    // freopen("divide.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);

    cin>>n;

    len=24;

    rep(i,1,n){
        cin>>a[i];
        a[i]+=a[i-1];
    }

    rep(i,1,n){
        pr res=sol(i,i+1);
        cout<<res.fi+(i+1)*(res.se+1)+i*res.se<<' ';
    }

    return 0;
}
```

---

## 作者：WZwangchongming (赞：3)

美味的根号分治，但被本奶龙写了一个神秘做法过了。


---

Solution：

首先明显可以贪心，对于每个 $k$ 从后往前分段，每段的长度在不小于上一段的情况下尽可能短。那么只需要预处理一下前缀和，然后二分。但是这样的做法时间复杂度是 $O(n^2 \log n)$ 的，也很容易被卡，比如类递减序列就可以让我们超时。

考虑观察，感性理解，$a_i \geq a_{i-1}$ 的情况一定不多，所以对每个位置的查询中的连续段并不多。

而且我们打表可以发现，给定 $r$ 查询的非 $[0,r]$ 区间的后面一段的和基本是单调递增的。所以直接对每次查询的上一次查询、和上上一次查询记忆化，那么就可以直接快速回答查询。

注意更新时上一次查询和上上一次查询分别是什么值。

---

Main code：


```cpp
pii solve(int x, int y) {
	if(s[x] - y <= 0 || x == 0) return {0, 0};
	if(c1[x] == y) return r1[x];
	if(c2[x] == y) return r2[x];
	int t = lower_bound(s + 1, s + x + 1, s[x] - y) - s;
	pii tmp = solve(t - 1, s[x] - s[t - 1]);
	tmp.F += 1ll * (tmp.S + 1) * t, tmp.S++;
	if(c1[x] == -1) c1[x] = y, r1[x] = tmp;
	else if(c2[x] == -1) c2[x] = y, r2[x] = tmp;
	else c1[x] = c2[x], r1[x] = r2[x], c2[x] = y, r2[x] = tmp;
	return tmp;
}
```

---

## 作者：ykzzldz (赞：3)

感觉这题并没有想象中的那么难啊。

首先我们可以发现，这个题目的分组其实是固定的：将最后一个分为一组，从后往前遍历，发现这一段元素之和大于上一段就新开一段。

第一想法是有一个暴力，每次要开新段的时候都二分分界点，但是这样的复杂度与段数有关，段数多的话复杂度就高，无法得到保证，可能可以通过数据随机的部分。

我们可以观察到，每次分出 $[l,r]$ 这一段时，前面的分法其实是固定的，这启示我们记忆化。但是，记忆化在段长比较大的时候也无法记录所有状态。

看到这里，想必大家都多多少少有些想法了。我们的第一个做法能做段数少的（也就是段长大的），第二个做法能做段长小的，将两个做法合并，即可得到我们整个题目的做法，这用到了根号分治的思想。具体来说，我们取块长 $s$，若一段的长度大于 $s$，我们就暴力二分往前跳，否则就直接查找记忆化数组里记录的元素，复杂度 $O(ns+\frac{n^2\log n}{s})$，令 $s=\sqrt{n\log n}$，复杂度可以做到 $O(n\sqrt{n\log n})$。

---

## 作者：zzzyyyyhhhhh (赞：2)

首先有一个 $n^2\log n$ 的贪心，我们对于每个 $k$ 从后往前分段，每段的长度尽可能短。这个做法常数很小，但是一个递减序列就把我们卡满了。

首先可以证明我们一共最多有 $\sqrt n$ 种段如果对于两个不同的 $k$，$a$ 为第一个序列的 $a$ 数组，$b$ 为第二个序列的 $a$ 数组 ，有 $a_i=b_i,a_{i+1}=b_{i+1}$ 那么 $\{a_p=b_p|p\le i\}$。于是我们可以记忆化区间，这样总复杂度就是 $n\sqrt n\log n$。

考虑到 hash 表常数很大，所以我们在 $\displaystyle\sum_{i=1}^n k=i\texttt{时的段数}$ 很小时直接跑暴力就可以了。

注意要使用 hash 表存状态，而不是记录上次的指针位置并二分后面几个指针的新位置，似乎存在一种构造方式可以使这种做法所有指针在两个集合中反复横跳导致指针总移动次数很大。

代码。

```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
using namespace std;
#define int long long
const int N = 1e5+100;
int n,a[N],s[N];
int p[N],cnt,e[N],res,ls;
bool q[N];
__gnu_pbds::gp_hash_table<int,int> mp1[N],mp2[N];
inline int solve1(int x)
{
	int res=0;
	int now=x-1;
	cnt=0;
	p[++cnt]=x+1,e[cnt]=-1,p[++cnt]=x,e[cnt]=a[x],ls=a[x];
	while(s[now]>ls)
	{
		int l=1,r=now,mid,ans=0;
		while(l<=r)
		{
			mid=(l+r)>>1;
			if(s[now]-s[mid-1]>ls)ans=mid,l=mid+1;
			else r=mid-1;
		}
		ls=s[now]-s[ans-1];
		if(mp1[ans].find(ls)!=mp1[ans].end())
		{
			int tmp=mp2[ans][ls];
			res=mp1[ans][ls];
			for(int i=cnt,j=1;i;j++,i--)res+=p[i]*(j+tmp),mp1[p[i]][e[i]]=res,mp2[p[i]][e[i]]=tmp+j;
			return res;
		}
		now=ans-1;
		p[++cnt]=ans;
		e[cnt]=ls;
	}
	int tmp=0;
	for(int i=cnt,j=1;i;j++,i--)res+=p[i]*(j+tmp),mp1[p[i]][e[i]]=res,mp2[p[i]][e[i]]=tmp+j;
	return res;
}
inline int solve(int x)
{
	int su=0,res=0;
	int now=x-1;
	cnt=0;
	int ls=a[x];
	res=x*3+2,su=x*2+1;
	while(s[now]>ls)
	{
		int l=1,r=now,mid,ans=0;
		while(l<=r)
		{
			mid=(l+r)>>1;
			if(s[now]-s[mid-1]>ls)ans=mid,l=mid+1;
			else r=mid-1;
		}
		ls=s[now]-s[ans-1];
		now=ans-1;
		su+=ans;
		res+=su;
	}
	return res;
}
signed main()
{
	int st=clock();
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	__gnu_pbds::gp_hash_table<int,int> cnt;
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i],cnt[a[i]]++,s[i]=s[i-1]+a[i];
	bool tmp=0;
	for(auto i:cnt)if(i.second>n/4)tmp=1;
	if(!tmp)
	{
		for(int i=1;i<=n;i++)
			cout<<solve1(i)<<' ';
	}
	else
	{
		for(int i=1;i<=n;i++)
			cout<<solve(i)<<' ';
	}
	cerr<<(double)(clock()-st)/CLOCKS_PER_SEC;
}
```

---

## 作者：shiruoyu114514 (赞：2)

在求解单个问题时，我们采用以下策略：从后往前考虑。对于一个 $i$，如果其能成为一个分段点（即以其为左端点的段和大于其后面的所有段），那么就直接令其成为分段点。

证明：首先如果不令其成为分段点，那么其余方案的字典序一定会变小。而令其成为分段点时，将左边所有数分成一段一定是个合法方案。

暴力模拟本策略就可以达到 $O(n^2)$ 复杂度，得分 50pts。

直觉地想，向后 ``push_back`` 一个数之后，合法方案改变的不会很多（否则重新计算方案对应的答案的时间复杂度就是 $O(n^2)$ 了），且改变的一定是一段后缀。于是我们可以从最后一个数开始，一直使用二分的形式确定下一个分段点。如果有两个新方案的相邻的分段点在旧方案中依然相邻，那么前面的所有分段都不会变，应该停止。如果已经二分到以 $0$ 作为分段点，那么也应该停止。

时间复杂度不会证，但是跑得挺快。赛时在 ``std::stack`` 的大常数加持下可以获得 $90$ 分。赛后一把这玩意重写就过了。


```cpp
#include<bits/stdc++.h>

using namespace std;

#define int long long

const int maxn=1e5;

template<class T>
struct Stack{
	int tail=0;
	T in[maxn+5];
	
	T top(){
		return in[tail];
	}
	
	bool empty(){
		return tail==0;
	}
	
	void push(T x){
		in[++tail]=x;
	}
	
	void pop(){
		tail--;
	}
	
	int size(){
		return tail;
	}
};

int a[maxn+5],sum[maxn+5];
Stack<pair<int,int>> sta1;
Stack<int> sta2;

bool able(int l,int r,int ge){
	if(l==0){
		return 1;
	}
	return sum[r-1]-sum[l-1]>ge;
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(nullptr);
	cout.tie(nullptr);
	int n;
	cin>>n;
	sum[0]=a[0]=1e18;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		sum[i]=sum[i-1]+a[i];
	}
	sta1.push(make_pair(0,0));
	for(int i=1;i<=n;i++){
		sta2.push(i);
		int lstv=a[i],lstpop=i-1;
		bool nochance=0;
		while(1){
			auto tmp=sta1.top();
			if(!able(tmp.first,sta2.top(),lstv)){
				lstpop=sta1.top().first-1;
				sta1.pop();
				nochance=0;
			}
			else{
				int l=tmp.first,r=lstpop;
				while(l<r){
					int mid=((l+r)>>1)+1;
					if(able(mid,sta2.top(),lstv)){
						l=mid;
					}
					else{
						r=mid-1;
					}
				}
				if(l==tmp.first){
					if(nochance||l==0)
						break;
					else{
						lstv=sum[sta2.top()-1]-sum[tmp.first-1];
						sta2.push(tmp.first);
						sta1.pop();
						nochance=1;
					}
				}
				else{
					lstv=sum[sta2.top()-1]-sum[l-1];
					sta2.push(l);
					nochance=0;
				}
			}
		}
		while(!sta2.empty()){
			sta1.push(make_pair(sta2.top(),sta1.top().second+sta1.size()*sta2.top()));
			sta2.pop();
		}
		cout<<sta1.top().second+(i+1)*sta1.size()<<" ";
	}
}
```

---

## 作者：eastcloud (赞：1)

首先对于字典序最小这一限制我们有个显然的暴力，即对于每个 $i$ 从右往左贪心，能分裂一段就分裂一段，这样可以简单地做到 $O(n^2)$。

考虑优化，你发现这题似乎没什么特别好的性质，于是可以考虑加速一下上述贪心中的分裂过程，尽量让一次分裂多分裂几段。

我们设一个阈值 $B$，对于每个 $i+1\le j \le i+B$ 的 $j$ 预处理出最后一次分裂分裂出的段为 $[i+1,j]$ 时，每次不停往前跳长度小于等于 $B$ 的串会跳到哪里，以及路径上的贡献，这部分可以直接双指针做到 $O(nB)$，如果跳出去的长度大于 $B$ 了可以直接停止处理。

对于询问，我们每次能跳预处理出的段就跳，否则如果上次跳的段长大于 $B$ 了或者下面的部分没被预处理，我们就暴力二分找出下一个要跳过去的段，不难发现二分的次数是 $O(\frac{n}{B})$ 的，令 $B=\sqrt{n \log n}$ 即可得到 $O(n \sqrt{n \log n})$ 的复杂度。

做法跑得挺快的，不用怎么卡常，不过也可能是数据比较水。实现上由于空间限制，$B$ 只能开到 450 左右，不过似乎 $B$ 开小一点跑得比开大要快。


```cpp
#include<bits/stdc++.h>

#define vi vector<int>
#define mp make_pair
#define pb push_back
#define eb emplace_back
#define pi pair<int,int>
#define ll long long
#define IL inline
#define For(i,j,k) for(int i=(j);i<=(k);i++)
#define Fol(i,j,k) for(int i=(j);i>=(k);i--)

using namespace std;

#define mod 998244353
#define N 100005
#define B 310

int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0' || ch>'9')f=(ch=='-'?-1:f),ch=getchar();
    while(ch>='0' && ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x*f;
}
void write(ll x){
    if(x<0)putchar('-'),x=-x;
    if(x/10)write(x/10);
    putchar(x%10+'0');
}

ll a[N],s[N];
struct Node{
    int cnt,pos,len;ll ans,sum;
    Node(int cnt=0,ll ans=0,ll sum=0,int pos=0,int len=0):cnt(cnt),ans(ans),sum(sum),pos(pos),len(len){}
    Node operator +(const Node &x){
        return Node(x.cnt+cnt,x.ans+ans+cnt*x.sum,x.sum+sum,pos,(len==0?x.len:len));
    }
};
Node f[N][B+2];

int main(){
    int n=read();a[0]=s[0]=1e15;
    For(i,1,n)a[i]=read(),s[i]=s[i-1]+a[i];
    For(i,1,n){
        int j=i;ll sum=0,sum2=a[i];int cur=(i%(B+1));
        For(k,i+1,min(n,i+B)){
            sum+=a[k];
            while(j>=max(i-B+1,1) && sum2<=sum)j--,sum2+=a[j];
            if(j<i-B+1)f[i][k-i]=Node(0,0,0,i,0);
            else{
                if(j==0)f[i][k-i]=Node(1,i+1,i+1,-1,i-j+1);
                else{
                    int las=((j-1)%(B+1));
                    f[i][k-i]=f[j-1][i-j+1]+Node(1,i+1,i+1,j-1,i-j+1);
                }
            }
        }
        Node now=Node(1,i+1,i+1,i,1);int r=i-1,len=1;
        while(r>0){
            if(f[r][len].len!=0){
                Node val=f[r][len];r=val.pos;len=val.len;
                now=val+now;
            }
            if(r<=0)break;
            do{
                int L=0,R=r;
                while(L<R){
                    int mid=(L+R+1)>>1;
                    if(s[r]-(mid==0?0:s[mid-1])>s[r+len]-s[r])L=mid;
                    else R=mid-1;
                }
                now=Node(1,r+1,r+1,L-1,r-L+1)+now;len=r-L+1;r=L-1;
                if(r<=0)break;
            }while(len>B);
            if(r<=0)break;
        }
        if(r==0)write(now.ans+now.sum+1),putchar(' ');
        else write(now.ans),putchar(' ');
    }
    return 0;
}
```

---

## 作者：Mirasycle (赞：1)

贪心策略是显然的，每次找到最短的一个区间使得其和 $>$ 上一个区间的和。暴力寻找是 $O(n^2)$ 的。

实际上套一个二分和记忆化复杂度就正确了。以下为证明。

因为记忆化之后，从全局来看长度 $\le \sqrt n$ 的区间只会被遍历到 $1$ 且只有 $O(n\sqrt n)$ 个这样子的区间所以是正确的。对于长度 $> \sqrt n$ 的区间，从某点往前跳的过程中，它们是不重合的，所以单次往前寻找最多遇到 $\dfrac{n}{\sqrt n}=\sqrt n$ 个这样子的区间。所以时间复杂度是 $O(n\sqrt n\log n)$。

这样子会被卡常。因为记忆化用 `std::map`的话常数过大，但是可以发现上述分析中长度 $> \sqrt n$ 的区间是不依赖于记忆化的，所以我们直接用数组保存 $\le \sqrt n$ 的区间记忆化即可。


```cpp
#include<bits/stdc++.h>
#define pb emplace_back
#define fi first
#define se second
#define mp make_pair
using namespace std;
typedef long long ll;
const int maxn=1e5+10;
const int B=210;
void cmax(int &x,int y){ x=x>y?x:y; }
void cmin(int &x,int y){ x=x<y?x:y; }
struct node{ int cnt,lst; ll tot; }S[maxn][B];
int v[maxn],vis[maxn][B],n;
ll pre[maxn],ans[maxn];
ll sum(int l,int r){ return pre[r]-pre[l-1]; }
node solve(int pos,ll s){
	if(!pos||sum(1,pos)<=s) return (node){0,0,0};
	int l=lower_bound(pre+1,pre+pos+1,pre[pos]-s)-pre;
	int L=pos-l+1;
	if(L<=200&&vis[pos][L]) return S[pos][L];
	node z=solve(l-1,sum(l,pos));
	if(L<=200){
		S[pos][L]=(node){z.cnt+1,l-1,z.tot+1ll*l*(z.cnt+1)};
		vis[pos][L]=1;
	}
	return (node){z.cnt+1,pos,z.tot+1ll*l*(z.cnt+1)};
}
int main(){
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>v[i];
	for(int i=1;i<=n;i++) pre[i]=pre[i-1]+v[i];
	for(int i=1;i<=n;i++){
		node z=solve(i-1,v[i]);
		ans[i]=z.tot; ans[i]+=1ll*(z.cnt+1)*i;
		S[i][0]=(node){z.cnt+1,i-1,ans[i]};
		vis[i][0]=1; ans[i]+=1ll*(z.cnt+2)*(i+1);
	}
	for(int i=1;i<=n;i++) cout<<ans[i]<<" ";
	return 0;
}
```

---

## 作者：szh_AK_all (赞：1)

被卡常了，不然就第一次场切紫了呜呜。

首先这个问题和类似于划分子段的问题很像，于是列出 dp 方程，设 $f_{i,j}$ 表示当前已加入了前 $i$ 个人，且第 $j$ 至第 $i$ 个人为一组时字典序最大的分组方案的权值，同时设 $g_{i,j}$ 表示该方案所分的组数。那么我们需要找出最大的 $k$ 使得 $\sum_{l=k}^{j-1} v_l>\sum_{l=j}^i v_l$，这一步可以使用前缀和与二分优化。找出了这个 $k$ 之后，即可更新 $f_{i,j}=f_{j-1,k}+(g_{j-1,k}+1)\times j$，并且 $g_{i,j}=g_{j-1,k}+1$。最终答案即为 $f_{i,i}+(g_{i,i}+1)\times (i+1)$

考虑优化。

我们的 dp 过程相当于是确定当前的最后一组，然后每次找当前组的上一组，那么可以使用根号分治的思想，我们只记录 $j-i+1\le \sqrt n$ 的 $f_{i,j}$ 与 $g_{i,j}$，如果找到的上一组的长度大于 $\sqrt n$，则继续找上一组，否则可以直接求答案，复杂度为 $O(n \sqrt n \log n)$。

如果被卡常了，可以尝试把“块长”调到 $200$。

``` cpp
#include <bits/stdc++.h>
using namespace std;
long long f[100005][205], g[100005][205], a[100005], q[100005];
int bl[100005], br[100005], cnt;

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	int n;
	cin >> n;
	int B = 200;
	q[0] = 10000000000000;
	for (int i = 1; i <= n; i++)
		cin >> a[i], q[i] = q[i - 1] + a[i];
	for (int i = 1; i <= n; i++) {
		for (int j = max(1, i - B + 1); j <= i; j++) {
			int ll = j, rr = i;
			cnt = 0;
			bl[++cnt] = ll, br[cnt] = rr;
			while (1) {
				int l = 0, r = ll - 1, ans = -1;
				while (l <= r) {
					int mid = (l + r) / 2;
					if (q[ll - 1] - q[mid - 1] > q[rr] - q[ll - 1]) {
						ans = mid;
						l = mid + 1;
					} else
						r = mid - 1;
				}
				bl[++cnt] = ans, br[cnt] = ll - 1;
				rr = ll - 1, ll = ans;
				if (rr - ll + 1 <= B || ans == 0)
					break;
			}
			int gg = 0;
			if (bl[cnt] != 0) {
				gg = g[br[cnt]][br[cnt] - bl[cnt] + 1];
				f[i][i - j + 1] = f[br[cnt]][br[cnt] - bl[cnt] + 1];
			}
			for (int k = cnt - 1; k >= 1; k--) {
				f[i][i - j + 1] += 1LL * (gg + 1) * bl[k];
				gg++;
			}
			g[i][i - j + 1] = gg;
		}
		cout << f[i][1] + 1LL * (g[i][1] + 1) * (i + 1) << " ";
	}
}
```

---


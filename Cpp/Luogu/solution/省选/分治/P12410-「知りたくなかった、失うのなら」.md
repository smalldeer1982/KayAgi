# 「知りたくなかった、失うのなら」

## 题目背景

$$\mathsf{自分に腹が立った}\\\scriptsize\mathsf{我对自己感到愤怒}$$

$$\mathsf{今更後悔したって遅いのに}\\\scriptsize\mathsf{然而事到如今已追悔莫及}$$

$$\mathsf{したって遅いのに}\\\scriptsize\mathsf{追悔莫及}$$

## 题目描述

给你一个 $n$ 个整数的序列 $c$，有 $m$ 次查询：

* ```l r x y a b```：判断 $c_l,c_{l+1},\cdots,c_{r}$ 是否满足值域在 $[x,y]$ 的所有 $ka+b$ 的形式的数均出现至少一次。

## 说明/提示

对于所有测试数据，保证：$1\le n,m,c_i,x,y,a\le5\times10^5$，$1\le l\le r\le n$，$x\le y$，$0\le b<a$。

| Subtask | 限制 | 分值 |
| :----------: | :----------: | :----------: |
| $0$ | $n,m,y\le500$ | $10$ |
| $1$ | $a\ge10^3$ | $15$ |
| $2$ | $n,m\le5\times10^4$ | $25$ |
| $3$ | 无 | $50$ |

## 样例 #1

### 输入

```
6 3
1 6 4 5 1 3
3 5 7 8 7 1
1 6 4 7 3 2
3 6 3 7 4 2 ```

### 输出

```
NO
YES
NO```

## 样例 #2

### 输入

```
10 2
23 38 32 19 3 11 7 15 30 43
2 8 2 21 4 3
1 10 1 43 8 7```

### 输出

```
YES
NO```

# 题解

## 作者：yzq_yzq (赞：17)

一眼经典根号分治题，但是懒得写。

发现这东西数据包不好造的，于是考虑暴力。

注意到判断一个区间是否存在一个数 $x$ 这个东西是简单的，用 vector 存相同数的位置然后二分就行。

然后用这个东西直接暴力，搜到答案就停下就有 50pts 了。

最后一步，限制一下枚举次数，限制到大概 $200$ 次就行了，但是这样 Wa 了一个点，想下出题人怎么卡你，肯定是用 $a$ 很小的点，并且肯定值上有很多连续的东西，于是直接从小到大枚和从大到小两个方向各枚举 $200$ 次，因为大部分答案都是 NO，直接就过了。

后边出题人赛后卡时间，然后试了下发现两个方向各枚举 $30$ 次就过了，最大点不到 300ms。

代码很简单。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define rep(i, x, y) for (int i = (x); i <= (y); ++i)
#define drep(i, x, y) for (int i = (x); i >= (y); --i)
#define pb push_back
#define pii pair<int, int>
#define fi first
#define se second
#define mem(a, b) memset((a), b, sizeof(a))
#define ALL(a) (a).begin(), (a).end()
#define fastio ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)
using namespace std;
template <typename T> inline void cmin(T &x, T y) { if(x > y) x = y; }
template <typename T> inline void cmax(T &x, T y) { if(x < y) x = y; }

const int N = 500050;
int n, m, c[N];
vector<int> vec[N];
inline int rd() {
	static char c; static int x;
	x = 0, c = getchar();
	while(c < '0' || c > '9') c = getchar();
	while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
	return x;
}
int main() {
	n = rd(), m = rd();
	rep(i, 1, n) c[i] = rd(), vec[c[i]].pb(i);
	while(m--) {
		int l = rd(), r = rd(), x = rd(), y = rd(), a = rd(), b = rd();
		int d = (x - b + a - 1) / a * a + b, e = (y - b) / a * a + b;
		if(d > y) puts("YES");
		else {
			bool f = 1;
			for(int i = 30; d <= y && i; d += a, --i) {
				if(!vec[d].size()) { f = 0; break; }
				auto p = lower_bound(ALL(vec[d]), l);
				if(p == vec[d].end() || *p > r) { f = 0; break; }
			}
			for(int i = 30; e >= x && i; e -= a, --i) {
				if(!vec[e].size()) { f = 0; break; }
				auto p = lower_bound(ALL(vec[e]), l);
				if(p == vec[e].end() || *p > r) { f = 0; break; }
			}
			if(f) puts("YES"); else puts("NO");
		}
	}
	return 0;
}
```

---

## 作者：_Yonder_ (赞：4)

考虑根号分治。

$a\ge\sqrt n$ 的是经典莫队暴跳倍数，没有好说的。

接下来是 $a<\sqrt n$ 的。

考虑扫描线，那么接下来是判断值域在 $[x,y]$ 的 $ka+b$ 形式的数的上一次出现的位置是否均大于等于 $l$，那么我们需要一个 $O(1)$ 单点修，$O(\sqrt n)$ 查询区间 $\min$ 的东西。这东西单独拎出来是可做的，但没必要。

注意到修改的数是越来越大的，那么我们就可以给每个块维护一个类似双端队列的东西。队尾插入数字，队头即为该块的 $\min$。每次队尾插入数字后，要更新队头。

时间复杂度 $O(n\sqrt n)$。

---

## 作者：_biLang_ (赞：0)

卡常调试 1h，数据出锅虚空调试 1h，what can I say
# 分析
一眼根号分治，$$$ a \geq \sqrt n $$$ 时直接跳，时复 $$$ \mathcal{O}(m \cdot \sqrt n) $$$ \
$$$ a < \sqrt n $$$ 时考虑对每种 $$$ a $$$ 分开计算，从 $$$ 1 $$$ 到 $$$ n $$$插入 $$$ c_i $$$，对每个 $$$ a $$$ 的模需要对 $$$ k \in [1, {n \over a}] $$$ 实现 $$$ \Theta(1) $$$ 插入与 $$$ \mathcal{O}(\sqrt n) $$$ 区间 min，分块的时复。有个很好的性质：每次插入的数字是越来越大的，于是可以每块存一个双端队列，节点存 $$$ c $$$ 与节点插入时 $$$ c $$$ 的位置，插入于队尾，队头存储的位置与 $$$ c $$$ 实际位置不符实弹出，则队头存的位置即全块最小。初始时需插入所有数字，位置设 $$$ 0 $$$。\
被卡常了，优化一下：每个 $$$ a $$$ 设置不同的块长，块内数字个数为 $$$ \Theta({B \over a}) $$$ 个，共 $$$ \Theta({n \over B}) $$$，取 $$$ B = \sqrt{a \cdot n} $$$ 最优；若一种 $$$ a $$$ 的所有询问暴力处理只跳 $$$ \mathcal{O}(n) $$$ 个点，则这些询问暴力处理
# code
```cpp
#include <bits/stdc++.h>

namespace io
{
  char buf[1 << 20], *p1(buf), *p2(buf), c;
#define gc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 20, stdin), p1 == p2) ? EOF : *p1++)
  
  template <typename _Tp> inline void read(_Tp& x) { x = 0; while (!isdigit(c = gc())); while (x = (x << 1) + (x << 3) + (c ^ 48), isdigit(c = gc())); }
  
  template <typename _Tp, typename... Args> inline void read(_Tp& x, Args&... args) { read(x), read(args...); } 
}

using u32 = unsigned;

constexpr u32 N(5e5+1), SQ(710);

u32 n, m, sq, blk[N], L[SQ], R[SQ], c[N], lst[N]; struct { u32 l, r, x, y, u, v, a, b; } q[N]; std::vector<u32> qr[SQ], in[N]; std::bitset<N> ans;
struct data { u32 c, lst; inline data(const u32& x, const u32& i) : c(x), lst(i) { } inline ~data(void) = default; };
struct list
{
  struct node { node* nxt; data x; inline node(const u32& c, const u32& i) : nxt(nullptr), x(c, i) { } } *head, *tail;
  inline list(void) { head = tail = nullptr; } inline const data& back(void) const { return tail -> x; }
  inline void emplace(const u32& x, const u32& i)
  { node* nw = new node(x, i); if (head == nullptr) head = tail = nw; else head -> nxt = nw, head = nw; }
  inline void pop(void) { node* tmp(tail -> nxt); delete tail; tail = tmp; }
  inline void clear(void) { while (tail != nullptr) pop(); head = nullptr; }
} que[SQ][SQ];

signed main(void)
{
#ifndef ONLINE_JUDGE
  freopen("in.txt", "r", stdin), freopen("out.txt", "w", stdout);
#endif
  u32 i, j, l, r, x, y, a, b, u, v; io::read(n, m); for (i = 1; i <= n; i++) io::read(c[i]);
  
  for (i = j = 1, L[1] = 1; i < N; i++) blk[i] = j, R[j] = i, !(i % SQ) && (L[++j] = i + 1);
  
  for (i = 1; i <= m; i++)
  {
    io::read(l, r, x, y, a, b), b %= a, u = (x - b + a - 1) / a, v = (y - b) / a, q[i] = {l, r, u * a + b, v * a + b, u, v, a, b};
    (y < b || u > v) ? (void)ans.set(i) : qr[(a < SQ) ? a : 0].emplace_back(i);
  }
  
  for (a = 1; a < SQ; a++) if (!qr[a].empty())
  {
    x = 0; for (const auto& id : qr[a]) x += q[id].v - q[id].u + 1; if (x > (N << 3)) continue;
    for (const auto& id : qr[a]) qr[0].emplace_back(id); qr[a].clear(), qr[a].shrink_to_fit();
  }
  
  if (!qr[0].empty())
  {
    for (const auto& id : qr[0]) in[q[id].r].emplace_back(id);
    for (i = 1; i <= n; in[i].clear(), in[i].shrink_to_fit(), i++)
    {
      lst[c[i]] = i; for (const auto& id : in[i]) [&](void) -> bool
      { for (x = q[id].u; x <= q[id].v; x++) if (lst[x * q[id].a + q[id].b] < q[id].l) return false; return true; } () && (ans.set(id), 0);
    }
  }
  
  for (a = 1; a < SQ; a++) if (!qr[a].empty())
  {
    for (i = j = 1, sq = sqrt(a * n); i < N; i++) blk[i] = j, R[j] = i, !(i % sq) && (L[++j] = i + 1);
    for (const auto& id : qr[a]) in[q[id].r].emplace_back(id); for (i = 0; i < a; i++) for (j = 1; j <= blk[N-1]; j++) que[i][j].clear();
    memset(lst, 0, sizeof lst); for (x = 1; x < N; x++) que[x % a][blk[x]].emplace(x, 0);
	for (i = 1; i <= n; in[i].clear(), in[i].shrink_to_fit(), i++)
    {
      lst[c[i]] = i; auto& Q(que[c[i] % a][blk[c[i]]]); Q.emplace(c[i], i); while (Q.back().lst < lst[Q.back().c]) Q.pop();
      for (const auto& id : in[i]) [&](void) -> bool
      {
  for (x = blk[q[id].x] + 1; x < blk[q[id].y]; x++) if (que[q[id].b][x].back().lst < q[id].l) return false;
  for (x = q[id].v; x < N && L[blk[q[id].y]] <= x * a + q[id].b; x--) if (lst[x * a + q[id].b] < q[id].l) return false;
  for (x = q[id].u; x * a + q[id].b <= R[blk[q[id].x]]; x++) if (lst[x * a + q[id].b] < q[id].l) return false; return true;
      } () && (ans.set(id), 0);
    }
  }
  
  for (i = 1; i <= m; i++) puts(ans[i] ? "YES" : "NO");

  return 0;
}

```

---


# [GCJ 2013 Finals] Can't Stop

## 题目背景

桌游 Can't Stop 由 Sid Sackson 设计，曾由多家出版商发行。Sid Sackson 先生及各出版商均未参与 Google Code Jam，也未对本题进行任何背书。


## 题目描述

本题灵感来源于 Sid Sackson 设计的桌游 Can't Stop。本题与该游戏有相似之处，但不要求你玩过 Can't Stop。

你正在玩一款（非常大）的桌面游戏。在这款游戏中，你会得到一个长度为 $N$ 的掷骰子序列。每组掷骰包含 $D$ 次骰子，每次掷骰得到一个整数。

你要赢得游戏，需要找到序列中最长的“超级棒区间”。一个区间指的是若干连续的掷骰组。如果存在 $k$ 个数字，使得该区间内的每一组掷骰都至少包含这 $k$ 个数字中的一个，则称该区间是“超级棒”的。

例如，假设 $D=2$，$k=3$，掷骰组如下：

```
第 0 组: 10 20
第 1 组: 50 60
第 2 组: 70 30
第 3 组: 40 40
第 4 组: 30 30
第 5 组: 20 40
```

区间 $[0,2]$（第 0 组到第 2 组）是超级棒的，因为第 $0\sim 2$ 组都包含 $10, 50, 70$ 这三个数中的至少一个。区间 $[1,5]$ 是超级棒的，因为第 $1\sim 5$ 组都至少包含 $50, 30, 40$ 这三个数中的一个。这个区间包含 5 组掷骰，是最长的超级棒区间。

你的任务是输出最长超级棒区间的起止下标。如果有多个同样长度的超级棒区间，输出起始下标最小的那一个。注意，第一组掷骰编号为 0。


## 说明/提示

**限制条件**

- $1 \leq T \leq 100$
- $1 \leq D \leq 4$
- $1 \leq \text{每次掷骰结果} \leq 10^5$
- 有 6 个测试点满足 $1 \leq N \leq 10^5$
- 其他测试点满足 $1 \leq N \leq 10^3$

**小数据集（11 分，测试集 1 - 可见）**

- 时间限制：~~60~~ 6 秒
- $k = 2$

**大数据集（32 分，测试集 2 - 隐藏）**

- 时间限制：~~120~~ 12 秒
- $2 \leq k \leq 3$

翻译由 ChatGPT-4.1 完成。

## 样例 #1

### 输入

```
4
8 1 2
1 2 3 2 4 5 4 6
4 3 2
1 2 3 4 5 6 7 8 9 10 11 12
6 2 3
10 20 50 60 70 30 40 40 30 30 20 40
10 1 3
2 4 3 1 4 5 3 1 1 2```

### 输出

```
Case #1: 1 3
Case #2: 0 1
Case #3: 1 5
Case #4: 1 4```

# 题解

## 作者：XiaoZi_qwq (赞：0)

## 题解：P13305 [GCJ 2013 Finals] Can't Stop

### 简要题意

给定 $n$ 个 $D$ 元组，求出最长的连续区间使得可以选出 $k$ 个数满足区间内任意一个四元组中有至少一个元素为这 $k$ 个数之一。

数据范围： $n \le 10^5,2\le k \le 3,1 \le D \le 4$。

### 分析

首先，我们可以考虑一个极暴力的算法：枚举每一个位置，从当前位置开始，我们可以先从开始位置的多元组中钦定一个数作为当前选择的数，然后在**不钦定新的数的前提下**向右扩展；如果在 $i$ 位置我们不能继续扩展，那么我们就从 $i$ 位置的数中钦定一个数作为当前选择的数，然后继续扩展。

因为确定了开始位置和选择数字集就可以唯一确定不能继续扩展的位置，所以从一个位置出发扩展的时间复杂度是 $O(nD^k)$，总时间复杂度 $O(n^2D^k)$。

接下来考虑优化：

有一个~~人类智慧~~结论：从 $i$ 开始扩展时，每一次选新的数时都保证 $i-1$ 的多元组中不包含该数，那么每一个位置只会被访问 $O(1)$ 次，且答案不会变劣。

首先证明“答案不会变劣”：这是显然的，因为如果选择 $i-1$ 的多元组中有的数，那么从 $i-1$ 开始扩展得到的答案会更优。

其次证明“每一个点只被访问 $O(1)$ 次”：考虑从每一个位置 $i$ 开始向左模拟上述形式扩展，那么**有且仅有 $i$ 向左不能继续扩展的位置可以在向右扩展中扩展到 $i$**。因为如果存在一个位置 $x$ 不满足这个条件，那么当 $x$ 扩展到 $i$ 时（选用 $i$ 扩展到 $x$ 时的相同数集），就一定会选到 $x-1$ 中有的数。由于从 $i$ 出发一共只有 $\sum \limits_{i=0}^{k} D^i$ 种选数方案（可以不选够 $k$ 次，也可以不选），因此每个位置只会被访问 $O(1)$ 次。

Q.E.D.

优化后时间复杂度为 $O(nD^k)$，模拟即可。

### 代码

```c++
const int N=1e5+100;
int T,n,d,k,a[N][5],b[5],ans,vis[N],st,ed;
void dfs(int u,int cnt,int len){
    if(u==n+1){
        if(len>ans) st=u-len+1,ed=u-1,ans=len;
        return;
    }
    int flag=0;
    For(i,1,d)
        if(vis[a[u][i]]==1){
            flag=1;
            break;
        }
    if(flag){
        dfs(u+1,cnt,len+1);
        return;
    }
    if(!flag && cnt==k){
        if(len>ans) st=u-len+1,ed=u-1,ans=len;
        return;
    }
    For(i,1,d)
        if(vis[a[u][i]]!=-1){
            vis[a[u][i]]=1;
            dfs(u+1,cnt+1,len+1);
            vis[a[u][i]]=0;
        }
}
int testcase;
void solve(){
    n=read(),d=read(),k=read();
    ans=0;
    For(i,1,n)
        For(j,1,d)
           a[i][j]=read();
    For(i,1,n){
        For(j,1,d)
            vis[a[i-1][j]]=-1;
        dfs(i,0,1);
        For(j,1,d)
            vis[a[i-1][j]]=0;
    }
    printf("Case #%d: %d %d\n",++testcase,st-1,ed-1);
}
int main()
{
#if !ONLINE_JUDGE
    freopen("test.in","r",stdin);
    freopen("test.out","w",stdout);
#endif 
    T=read();
    while(T--) solve();
    return 0;
}
```

---


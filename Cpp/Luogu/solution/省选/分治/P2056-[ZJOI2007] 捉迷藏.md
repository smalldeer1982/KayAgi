# [ZJOI2007] 捉迷藏

## 题目描述

Jiajia 和 Wind 是一对恩爱的夫妻，并且他们有很多孩子。某天，Jiajia、Wind 和孩子们决定在家里玩捉迷藏游戏。他们的家很大且构造很奇特，由 $N$ 个屋子和 $N-1$ 条双向走廊组成，这 $N-1$ 条走廊的分布使得任意两个屋子都互相可达。 


游戏是这样进行的，孩子们负责躲藏，Jiajia 负责找，而 Wind 负责操纵这 $N$ 个屋子的灯。在起初的时候，所有的灯都没有被打开。每一次，孩子们只会躲藏在没有开灯的房间中，但是为了增加刺激性，孩子们会要求打开某个房间的电灯或者关闭某个房间的电灯。为了评估某一次游戏的复杂性，Jiajia 希望知道可能的最远的两个孩子的距离（即最远的两个关灯房间的距离）。 

我们将以如下形式定义每一种操作： 

- C(hange) i 改变第 $i$ 个房间的照明状态，若原来打开，则关闭；若原来关闭，则打开。 
- G(ame) 开始一次游戏，查询最远的两个关灯房间的距离。

## 说明/提示

对于$20\%$的数据， $N \leq 50$, $M\leq 100$； 

对于$60\%$的数据， $N \leq 3000$, $M \leq 10000$； 

对于$100\%$的数据， $N \leq 100000$, $M \leq 500000$。 


## 样例 #1

### 输入

```
8
1 2
2 3
3 4
3 5
3 6
6 7
6 8
7
G
C 1
G
C 2
G
C 1
G```

### 输出

```
4
3
3
4```

# 题解

## 作者：墨尔 (赞：108)

写个括号序列的做法。

首先dfs整棵树一遍，进入一个节点的时候加上一个左括号，然后是节点编号，当这个节点的所有子树遍历完后再添上一个右括号，这就是括号序列。（其实就是dfs序加上了括号而已）

![](https://cdn.luogu.com.cn/upload/pic/20390.png)

举个栗子，这棵树的括号序列是(1(2(3))(4(5)(6)(7(8))))

我们要求3到8的距离，截取两点间的括号序列为

3))(4(5)(6)(7(8

把编号和匹配的括号删掉

))(((

剩下了5个左右括号，而这就是3到8的距离。

这就是括号序列的性质。

怎么证明？脑补一下，到达i点时

1)添完了左右括号

那个点是i的祖先们的孩子。（不在i到根的路径上）

2）添了左括号没填右括号

那个点是i的祖先。（在i到根的路径上）

3）没添左括号

那个点是i的祖先们的孩子或者i的孩子（不在i到根的路径上）

因此，从s到t，删去的匹配括号们对于s来说是情况3，对于t来说是情况1，很显然这个点不在s到t的路径上。剩下的右括号，对于s来说是情况2，对于t来说是情况1，因此表示从s到达【t到根的这条链】经过的节点数。剩下的左括号，对于s来说是情况3，对于t来说是情况2，因此表示从t到达【s和t的lca（不包括lca）】的经过点数。

综上我们证明了删掉两点间所有匹配括号剩下的左右括号数为距离。

现在我们已经把整棵树压成了一个括号序列了，而我们要求的是两个黑点间的最大距离，我们考虑用线段树求解。

毫无疑问要记录每段区间删掉匹配括号后剩下的左右括号数，我们记右括号数为a，左括号数为b。

【注意我接下来说的所有左右区间都不限于线段树中的左右区间，任意连续的左右区间均可】

左右区间的a、b的合并：

显然左区间的左括号和右区间的右括号合并消去，谁多剩谁
```cpp
//lc左区间，rc右区间
	if(tr[lc].b>tr[rc].a)
	 tr[id].a=tr[lc].a,tr[id].b=tr[lc].b-tr[rc].a+tr[rc].b;else
	 tr[id].a=tr[lc].a+tr[rc].a-tr[lc].b,tr[id].b=tr[rc].b;
```

跨区间距离计算：

左区间右左括号数记为a1,b1，右区间a2,b2

dis=a1+abs(b1-a2)+b2=max((a1+b1)+(b2-a2),(a1-b1)+(a2+b2))

显然max(a1+b1),max(b2-a2)这种是可以单独维护的。

因此记录区间前缀的max(a+b),max(b-a)（l1,l2）,后缀的max(a+b),max(a-b)(r1,r2)即可维护dis值
```cpp
	tr[id].dis=max(max(tr[lc].r1+tr[rc].l2,tr[lc].r2+tr[rc].l1),max(tr[lc].dis,tr[rc].dis));

```
l1,r1,l2,r2的维护参考合并操作，不解释了自己体会
```cpp
	tr[id].l1=max(tr[lc].l1,max(tr[rc].l1+tr[lc].a-tr[lc].b,tr[rc].l2+tr[lc].a+tr[lc].b));
	tr[id].l2=max(tr[lc].l2,tr[rc].l2-tr[lc].a+tr[lc].b);
	tr[id].r1=max(tr[rc].r1,max(tr[lc].r1-tr[rc].a+tr[rc].b,tr[lc].r2+tr[rc].a+tr[rc].b));
	tr[id].r2=max(tr[rc].r2,tr[lc].r2+tr[rc].a-tr[rc].b);
```

因为是要求黑点间的最大距离，显然初始化时白点的l1,r1,l2,r2是没有意义的，置为-inf

至此本题解决。

```cpp
//括号序列
#include<cstdio>
//(a1 b1)(a2 b2)->(a,b)
//a+b=a1+abs(b1-a2)+b2=max((a1-b1)+(a2+b2),(a1+b1)+(b2-a2))
//需要左区间后缀的max(a-b),max(a+b)，右区间前缀的max(a+b),max(b-a) 
int num,s[300005],pos[1000005],head[100005],n,m,cnt,tot;
bool c[100005];
struct edge{int to,next;}e[200005];
void add(int u,int v){e[++num]=(edge){v,head[u]},head[u]=num;}
struct node
{
	int a,b,l1,l2,r1,r2,dis;
	//a,b右左括号数,l1,l2前缀的max(a+b),max(b-a),r1,r2后缀的max(a+b),max(a-b)  
}tr[1200005];
void dfs(int u,int fa)
{
	s[++tot]=-1;//左括号
	s[++tot]=u;pos[u]=tot;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;if(v==fa)continue;
		dfs(v,u);
	}
	s[++tot]=-2;//右括号 
}
void push(int id,int x)
{
	tr[id].a=tr[id].b=0;tr[id].l1=tr[id].l2=tr[id].r1=tr[id].r2=tr[id].dis=-1e9;
	if(s[x]==-1)tr[id].b=1;else
	if(s[x]==-2)tr[id].a=1;else
	if(!c[s[x]])tr[id].l1=tr[id].r1=tr[id].r2=tr[id].l2=0;//黑点 
}
int max(int a,int b){return a>b?a:b;}
void merge(int id)
{
	int lc=id<<1,rc=id<<1|1;
	if(tr[lc].b>tr[rc].a)
	 tr[id].a=tr[lc].a,tr[id].b=tr[lc].b-tr[rc].a+tr[rc].b;else
	 tr[id].a=tr[lc].a+tr[rc].a-tr[lc].b,tr[id].b=tr[rc].b;
	tr[id].l1=max(tr[lc].l1,max(tr[rc].l1+tr[lc].a-tr[lc].b,tr[rc].l2+tr[lc].a+tr[lc].b));
	tr[id].l2=max(tr[lc].l2,tr[rc].l2-tr[lc].a+tr[lc].b);
	tr[id].r1=max(tr[rc].r1,max(tr[lc].r1-tr[rc].a+tr[rc].b,tr[lc].r2+tr[rc].a+tr[rc].b));
	tr[id].r2=max(tr[rc].r2,tr[lc].r2+tr[rc].a-tr[rc].b);
	tr[id].dis=max(max(tr[lc].r1+tr[rc].l2,tr[lc].r2+tr[rc].l1),max(tr[lc].dis,tr[rc].dis));
}
void build(int id,int l,int r)
{
	if(l==r){push(id,l);return;}
	int mid=l+r>>1;
	build(id<<1,l,mid);build(id<<1|1,mid+1,r);
	merge(id);
}
void modify(int id,int l,int r,int x)
{
	if(l==r){push(id,l);return;}
	int mid=l+r>>1;
	if(x<=mid)modify(id<<1,l,mid,x);else modify(id<<1|1,mid+1,r,x);
	merge(id);
}
int main()
{
	scanf("%d",&n);
	for(int i=1,u,v;i<n;i++)
	{
		scanf("%d%d",&u,&v);
		add(u,v),add(v,u);
	}
	dfs(1,0);cnt=n;
	build(1,1,tot); 
	scanf("%d",&m);
	for(int i=1,x;i<=m;i++)
	{
		char s[2];
		scanf("%s",s);
		if(s[0]=='C')scanf("%d",&x),cnt+=c[x]?1:-1,c[x]^=1,modify(1,1,tot,pos[x]);
		else if(cnt==0)printf("-1\n");else if(cnt==1)printf("0\n");else
		printf("%d\n",tr[1].dis);
	}
}
```

---

## 作者：ywy_c_asm (赞：55)

作为一道动态点分治板子题，这题题解里没动态点分治解法真是不科学。~~虽然这东西多带一个log……~~

大致的思路就是我们在静态的点分治的基础上维护一个高度为$O(logn)$的树形结构，这棵树上的点为当前做点分治时这个连通块的重心，应该是很好想的毕竟分治本身就是个树形结构，我们把这个树形结构具体实现出来了而已。我们把这个树形结构称作点分树。

然后我们在点分树上维护一些奇奇怪怪的信息，就能够支持带动态修改的和普通点分治一样的路径信息统计了。因为修改的时候只需要考虑这个点在点分树上到根的路径上的点，而树高是$O(logn)$的就暴力跳就行了。

关于如何在点分树上维护这里写两种方法：

**方法1.**（~~这其实是我自己YY出来的……~~）普通点分治是以当前连通块的重心为根，然后逐个扫一遍他的儿子做类似于dp一样的东西，这其中的关键就是 **以重心为根合并他的两个儿子的子树** ，显然，我们需要在当前连通块的重心处用个支持删除的logn数据结构维护他所有儿子（这里说的都是原来树上的儿子，别和点分树上的儿子搞混了）子树内的关灯点到重心的距离的最大值和次大值，显然这两个加起来就是过这个点所有合法路径的最大值。而他的儿子的子树如何分开维护呢？我们可以用$dfs$序把儿子的子树当成一个区间，然后在这个重心上用动态开点线段树维护（显然这样做空间复杂度是$O(nlogn)$的）$dfs$序区间内的最大值，然后再在重心上开一棵平衡树维护这些区间的最大值。那么他点分树上的子树的答案呢？我们再开一棵平衡树维护点分树上子树的答案最大值，再用这棵平衡树的最大值更新点分树上父亲的答案。然后就可以在修改的时候维护这3棵树了，时间复杂度$O(nlog^2n)$，空间复杂度$O(nlogn)$。

然后这个方法代码极长（我目前写过的最长代码……），过于毒瘤，这还不算——它常数太大了，毕竟我们要同时在一条到根的链上维护3个数据结构，这其中还有个常数大的吓人的动态开点线段树……实测最后一个点过不去……

~~代码过于毒瘤就不放了……~~

**方法2.** 我们其实可以换一种思路统计答案，方法1说了我们得在重心处合并两个子树的答案，而子树我们还得在这一层想办法维护。但是我们发现**每个子树可是要在分治的下一层作为一个整体的连通块的**，那么我们可以在点分治的时候考虑他在点分树上的父亲$fa$，我们维护当前连通块内所有关灯点到$fa$距离的最大值，记为$mxdis_i$，然后我们在$fa$处维护他点分树的儿子的$mxdis_i$的最大值和次大值，就是这个点的答案了。至于维护总体的答案其实也不用在树上每个点都维护一遍，在全局用个数据结构维护就行了。注意维护点分树儿子最大的$mxdis_i$的时候，如果自己是关着灯的就得再额外插入一个0，因为自己也可以是端点。

另外这个数据结构需要支持查最大值、次大值和删除，其实可以不用平衡树，我们用一个两个大根堆$A$和$B$构成的玩意就可以维护。删除的时候并不考虑$A$的删除，而是把这个数插到$B$内，查最大值的时候如果发现$A$的堆顶和$B$的堆顶一样就说明这个数被删除过了，就同时弹掉。（感谢$PoPoQQQ$大神博客里写的这个技巧）

于是我们就用常数更小的堆代替了线段树和平衡树，而且维护起来也更方便了，代码瞬间短了许多。

上代码~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#define inf 123456789
using namespace std;
namespace ywy{
	inline int get(){//我的垃圾快读 
		int n=0;char c;while((c=getchar())||23333){
			if(c>='0'&&c<='9')break;if(c=='-')goto s;
		}n=c-'0';while((c=getchar())||23333){
			if(c>='0'&&c<='9')n=n*10+c-'0';else return(n);
		}s:while((c=getchar())||23333){
			if(c>='0'&&c<='9')n=n*10-c+'0';else return(n);
		}
	}
	void print(int num){
		if(num>=10)print(num/10);putchar(num%10+'0');
	}
	inline char cget(){
		char c;while((c=getchar())||23333)if(c>='A'&&c<='Z')return(c);
	}
	int heads[100001]； 
	int fa[100001];//点分树上的父亲 
	int size[100001];//当前的子树大小，找重心用的 
	int que[100001];
	unsigned char bv[100001];//点分治的时候这个点是否被solve了 
	typedef struct _dui{//把这两个大根堆构成的玩意封装起来 
		priority_queue<int> me,del;//del存删除的信息 
		inline int getmax(){
			while(!me.empty()&&(!del.empty()&&me.top()==del.top()))me.pop(),del.pop();//弹出已经删除的堆顶 
			if(me.empty())return(-inf);return(me.top());
		}
		inline void remove(int num){
			if(me.top()==num)me.pop();else del.push(num);
		}
		inline void insert(int num){
			me.push(num);
		}
		inline int getsecond(){
			int cjr=getmax();if(cjr==-inf)return(-inf);me.pop();int ywy=getmax();me.push(cjr);return(ywy);
		}
	}dui;
	dui globe；//维护全局的答案 
	dui fuqin[100001];//维护当前连通块关灯的点到点分树父亲的最大距离 
	dui chs[100001];//维护儿子（当然也包括自己）最大的maxdis 
	typedef struct _b{
		int dest;int nxt;	
	}bian;
	bian memchi[200001];
	int gn=1;
	inline void add(int s,int t){
		memchi[gn].dest=t;memchi[gn].nxt=heads[s];heads[s]=gn;gn++;
	}
	int dis[100001][18];//当前分治到这个深度时，到点分树父亲的距离 
	int rdeep[100001];//作为重心时的分治深度 
	unsigned char zt[100001];//是否关灯 
	int gdeep,tot,zx;
	inline void bfs(int pt){//bfs求出距离 
		tot=0;
		register int head=0,tail=1;
		que[0]=pt;
		dis[pt][gdeep]=1;
		do{
			int me=que[head];head++;tot++;
			for(register int i=heads[me];i;i=memchi[i].nxt){
				if(bv[memchi[i].dest])continue;
				if(dis[me][gdeep]+1<dis[memchi[i].dest][gdeep]){
					dis[memchi[i].dest][gdeep]=dis[me][gdeep]+1;
					que[tail]=memchi[i].dest;tail++;
				}
			}
		}while(head<tail);
	}
	void afs(int pt,int baba){//找重心 
		size[pt]=1;
		int mx=0;
		for(register int i=heads[pt];i;i=memchi[i].nxt){
			if(bv[memchi[i].dest]||memchi[i].dest==baba)continue;
			afs(memchi[i].dest,pt);
			size[pt]+=size[memchi[i].dest];
			mx=max(mx,size[memchi[i].dest]);
		}
		if(max(mx,tot-size[pt])<=tot/2)zx=pt;
	}
	int lstans[100001];//存放这个点的答案，方便维护全局的堆 
	int hexin;
	void digui(int pt,int baba,int dp){//点分治 
		gdeep=dp;
		bfs(pt);
		afs(pt,0);
		if(!baba)hexin=zx;
		rdeep[zx]=dp;
		if(baba){
			for(register int i=0;i<tot;i++)fuqin[zx].insert(dis[que[i]][dp]);//维护maxdis	
		}
		fa[zx]=baba;
		int me=zx;bv[zx]=1;
		for(register int i=heads[zx];i;i=memchi[i].nxt){
			if(bv[memchi[i].dest])continue;
			digui(memchi[i].dest,me,dp+1);
		}
		if(baba)chs[baba].insert(fuqin[me].getmax());//把maxdis插入父亲 
		chs[me].insert(0);//别忘了维护自己 
		globe.insert(lstans[me]=chs[me].getmax()+chs[me].getsecond());//当前点的答案 
	}
	void ywymain(){
		memset(dis,0x7f,sizeof(dis));
		int n=get();
		for(register int i=1;i<n;i++){
			int s=get(),t=get();add(s,t);add(t,s);
		}
		digui(1,0,0);
		int q=get();
		int guan=n;//有多少灯关着 
		while(q){
			q--;
			char cmd=cget();
			if(cmd=='G'){
				if(guan==1)printf("0\n");else{
					if(guan==0)printf("-1\n");
					else print(globe.getmax()),putchar('\n');
				}
			}else{
				int x=get();
				if(zt[x])chs[x].insert(0),guan++;//这个灯关了就要额外插入0 
				else chs[x].remove(0),guan--;
				int cur=x;
				while(cur){
					int cjr=chs[cur].getmax()+chs[cur].getsecond();
					if(cjr!=lstans[cur]){
						globe.remove(lstans[cur]);
						globe.insert(lstans[cur]=cjr);//更新全局答案 
					}if(!fa[cur])break;
					int dp=rdeep[cur];
					cjr=fuqin[cur].getmax();
					if(zt[x])fuqin[cur].insert(dis[x][dp]);
					else fuqin[cur].remove(dis[x][dp]);//维护到点分树父亲的距离 
					int ywy=fuqin[cur].getmax();
					if(ywy!=cjr){
						chs[fa[cur]].remove(cjr);
						chs[fa[cur]].insert(ywy);
					}
					cur=fa[cur];
				}
				zt[x]^=1;
			}
		}
	}
}
int main(){
	ywy::ywymain();return(0);
}
```

---

## 作者：Great_Influence (赞：36)

讲一下简单线段树做法。

首先，有一个结论:

现有集合$S,T$。设其直径点集为$F(S),F(T)$。则$F(S\bigcup T)\subset F(S)\bigcup F(T)$。

那么，根据这个结论，我们考虑利用线段树来维护区间直径。合并区间时直接暴力合并计算即可。

关于计算直径，需要知道两个点之间的$lca$。如果使用树链剖分或者倍增，则时间复杂度为$O(n\log^2n)$。如果使用$st$表，那么时间复杂度为$O(n\log n)$。


代码:
```cpp
#include<bits/stdc++.h>
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
#define For(i,a,b) for(i=(a),i<=(b);++i)
#define Forward(i,a,b) for(i=(a),i>=(b);--i)
#define Chkmax(a,b) a=a>b?a:b

typedef unsigned int uint32;

inline uint32 getwd(void)
{
    static const uint32 BUFSIZE = 1048576;
    static char buf[BUFSIZE];
    static char *bufnow = buf;
    static char *bufmax = buf;
    if (bufnow == bufmax) {
        bufmax = buf + fread(buf, 1, BUFSIZE, stdin);
        bufnow = buf;
    }
	return *bufnow++;
}

inline void read(uint32 &x){
	static char k;k=getwd();x=0;
    while(!isdigit(k)&&k^'-')k=getwd();
    while(isdigit(k)){x=x*10+(k^48);k=getwd();}
}

inline void getopt(char &opt){for(opt=getwd();!isupper(opt);opt=getwd());}

inline void write(uint32 x)
{
    static uint32 sta[35],tp;
    if(!x){putchar(48),putchar('\n');return;}
    for(tp=0;x;x/=10)sta[++tp]=x%10;
    for(;tp;putchar(sta[tp--]^48));
    putchar('\n');
}
using namespace std;
void file()
{
#ifndef ONLINE_JUDGE
	freopen("practice.in","r",stdin);
	freopen("practice.out","w",stdout);
#endif
}

const uint32 MAXN=5e5+7;

static uint32 n,e,head[MAXN],m;

static struct edge
{
	uint32 v,nxt;
}p[MAXN<<1];

inline void add(uint32 u,uint32 v){p[++e]=(edge){v,head[u]};head[u]=e;}

static uint32 st[MAXN],dfn[MAXN],las[MAXN],fa[20][MAXN],dep[MAXN],re[MAXN];

void dfs(uint32 u,uint32 fr)
{
	re[dfn[u]=++e]=u;fa[0][u]=fr;dep[u]=dep[fr]+1;
	for(register uint32 v=head[u];v;v=p[v].nxt)if(p[v].v^fr)dfs(p[v].v,u);
	las[u]=e;
}

static uint32 Log[MAXN];

inline void init()
{
	read(n);
	static uint32 u,v;
	Rep(i,1,n-1)read(u),read(v),add(u,v),add(v,u);e=0;
	dfs(1,0);
	Rep(i,2,n)Log[i]=Log[i>>1]+1;
	Rep(j,1,Log[n])Rep(i,1,n)fa[j][i]=fa[j-1][fa[j-1][i]];
}

inline uint32 dist(uint32 u,uint32 v)
{
	u=re[u];v=re[v];
	static uint32 dps;dps=dep[u]+dep[v];
	if(dep[u]<dep[v])swap(u,v);
	for(;dep[u]-dep[v];u=fa[Log[dep[u]-dep[v]]][u]);
	if(u==v)return dps-2*dep[u];
	Repe(i,Log[dep[u]],0)if(fa[i][u]^fa[i][v])u=fa[i][u],v=fa[i][v];
	return dps-2*dep[u]+2;
}

namespace Segment_Tree
{
	static uint32 poi[MAXN<<2][3],dst[MAXN<<2];

	inline void pushup(uint32 h)
	{
		static uint32 dis;
		dst[h]=-1;poi[h][0]=poi[h][1]=poi[h][2]=0;
		if(dst[h<<1]==-1)
		{
			dst[h]=dst[h<<1|1],poi[h][0]=poi[h<<1|1][0];
			poi[h][1]=poi[h<<1|1][1],poi[h][2]=poi[h<<1|1][2];
		}
		else if(dst[h<<1|1]==-1)
		{
			dst[h]=dst[h<<1],poi[h][0]=poi[h<<1][0];
			poi[h][1]=poi[h<<1][1],poi[h][2]=poi[h<<1][2];
		}
		else
		{
			if(dst[h<<1]<dst[h<<1|1])
			{
				dst[h]=dst[h<<1|1],poi[h][0]=poi[h<<1|1][0];
				poi[h][1]=poi[h<<1|1][1],poi[h][2]=poi[h<<1|1][2];
			}
			else
			{
				dst[h]=dst[h<<1],poi[h][0]=poi[h<<1][0];
				poi[h][1]=poi[h<<1][1],poi[h][2]=poi[h<<1][2];
			}
			Rep(i,1,poi[h<<1][0])Rep(j,1,poi[h<<1|1][0])
				if((dis=dist(poi[h<<1][i],poi[h<<1|1][j]))>dst[h])
					dst[h]=dis,poi[h][1]=poi[h<<1][i],poi[h][2]=poi[h<<1|1][j];
			poi[h][0]=2;
		}
	}

	void make_tree(uint32 h,uint32 l,uint32 r)
	{
		if(l==r)
		{
			st[l]=1;poi[h][0]=1;poi[h][1]=l;
			return;
		}
		uint32 mid=(l+r)>>1;
		make_tree(h<<1,l,mid);make_tree(h<<1|1,mid+1,r);
		pushup(h);
	}

	void modify(uint32 h,uint32 l,uint32 r,uint32 x)
	{
		if(l==r)
		{
			if(st[l])st[l]=poi[h][0]=poi[h][1]=0,dst[h]=-1;
			else st[l]=poi[h][0]=1,poi[h][1]=l,dst[h]=0;
			return;
		}
		static uint32 mid;mid=(l+r)>>1;
		x<=mid?modify(h<<1,l,mid,x):modify(h<<1|1,mid+1,r,x);
		pushup(h);
	}

	static uint32 dsts,pi[3];

	inline void Combine(uint32 h)
	{
		static uint32 u,v,dis;
		if(!poi[h][0])return;
		if(!pi[0])pi[0]=poi[h][0],pi[1]=poi[h][1],pi[2]=poi[h][2],dsts=dst[h];
		else
		{
			if(dst[h]>dsts)dsts=dst[h],u=poi[h][1],v=poi[h][2];
			else u=pi[1],v=pi[2];
			Rep(i,1,pi[0])Rep(j,1,poi[h][0])
				if((dis=dist(pi[i],poi[h][j]))>dsts)
					dsts=dis,u=pi[i],v=poi[h][j];
			pi[0]=2;pi[1]=u;pi[2]=v;
		}
	}

	void query(uint32 h,uint32 l,uint32 r,uint32 x,uint32 y)
	{
		if(l>=x&&r<=y)
		{
			Combine(h);
			return;
		}
		uint32 mid=(l+r)>>1;
		if(x<=mid)query(h<<1,l,mid,x,y);
		if(y>mid)query(h<<1|1,mid+1,r,x,y);
	}
}
using namespace Segment_Tree;

inline void solve()
{
	read(m);
	static char x;
	static uint32 rt;
	make_tree(1,1,n);
	Rep(i,1,m)
	{
		getopt(x);read(rt);
		if(x=='C')modify(1,1,n,dfn[rt]);
		else
		{
			pi[0]=pi[1]=pi[2]=0;dsts=-1;
			query(1,1,n,dfn[rt],las[rt]);
			~dsts?write(dsts):(void)puts("-1");
		}
	}
	cerr<<1.0*clock()/CLOCKS_PER_SEC<<endl;
}

int main()
{
	file();
	init();
	solve();
	return 0;
}


```

---

## 作者：xudaxia (赞：31)

点分树一点都不会啊（还是太菜了）  
点分树就是我们点分治构成的新树。满足深度很小。  
然后我们就可以在上面瞎维护东西了。  
三个大根堆：  
$C[u]$里装的是点分树中u的子树所有点到点分树中u的父亲的距离。  
$B[u]$里装的是点分树中u的所有儿子的C的最大值。  
$A$里装的是所有$B$的最大值与次大值之和。  
$A$的堆顶就是答案。  
~~（我一开始一直以为两个堆就行，对第三个对表示疑惑，又懒得深入想，一直翻题解。千万不能犯懒不想啊）~~  
我们找答案可以快速找到。问题是怎么维护？  
因为我们是点分树，深度小，可以直接一个一个跳到根暴力修改维护。具体一些就是设删的点为$x$，跳到一个点$u$把$x$的贡献从$C[u]$中删掉，然后重新跟新$B[u]$和$A$。  
至此本题得到解决，就是我代码常数太大。


```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<queue>
using namespace std;
const int N=200100;
struct que{
    priority_queue<int> x,y;
    inline void push(int a){x.push(a);}
    inline void del(int a){y.push(a);}
    inline int top(){while(y.size()&&x.top()==y.top())x.pop(),y.pop();return x.top();}
    inline int size(){return x.size()-y.size();}
    inline void pop(){while(y.size()&&x.top()==y.top())x.pop(),y.pop();x.pop();}
    inline int sectop(){int a=top();pop();int b=top();push(a);return b;}
}A,B[N],C[N];
int cnt,head[N];
int light[N],tot,n,m;
int root,size[N],g[N],vis[N],all,f[N];
int dep[N],mn[N*2][24],num,dfn[N];
int Log[N];
struct edge{
    int to,nxt;
}e[N*2];
inline void add_edge(int u,int v){
    cnt++;
    e[cnt].nxt=head[u];
    e[cnt].to=v;
    head[u]=cnt;
}
inline void dfs(int u,int f){
    dfn[u]=++num;
    dep[u]=dep[f]+1;
    mn[num][0]=dep[u];
    for(int i=head[u];i;i=e[i].nxt){
        int v=e[i].to;
        if(v==f)continue;
        dfs(v,u);
        mn[++num][0]=dep[u];
    }
}
inline void getroot(int u,int f){
    g[u]=0;size[u]=1;
    for(int i=head[u];i;i=e[i].nxt){
        int v=e[i].to;
        if(v==f||vis[v])continue;
        getroot(v,u);
        g[u]=max(g[u],size[v]);
        size[u]+=size[v];
    }
    g[u]=max(g[u],all-size[u]);
    if(g[u]<g[root])root=u;
}
inline int getdep(int x,int y){
    int a=dfn[x];
    int b=dfn[y];
    if(a>b)swap(a,b);
    int len=Log[b-a+1];
    return min(mn[a][len],mn[b-(1<<len)+1][len]);
}
inline int dis(int x,int y){
    return dep[x]+dep[y]-2*getdep(x,y);
}
inline void work(int u,int ff){
    C[root].push(dis(u,f[root]));
    size[u]=1;
    for(int i=head[u];i;i=e[i].nxt){
        int v=e[i].to;
        if(v==ff||vis[v])continue;
        work(v,u);
        size[u]+=size[v];
    }
}
inline void pusha(int x){
    if(B[x].size()>=2)A.push(B[x].top()+B[x].sectop());
}
inline void dela(int x){
    if(B[x].size()>=2)A.del(B[x].top()+B[x].sectop());
}
inline void build(int u,int ff){
    f[u]=ff;vis[u]=1;
    B[u].push(0);
    work(u,0);
    for(int i=head[u];i;i=e[i].nxt){
        int v=e[i].to;
        if(vis[v])continue;
        root=0,all=size[v];
        getroot(v,0);
        v=root;
        build(root,u);
        B[u].push(C[v].top());
    }
    pusha(u);
}
inline void on(int x){
    dela(x);
    B[x].del(0);
    pusha(x);
    for(int i=x;f[i];i=f[i]){
        dela(f[i]);
        B[f[i]].del(C[i].top());
        C[i].del(dis(x,f[i]));
        if(C[i].size())B[f[i]].push(C[i].top());
        pusha(f[i]);
    }
}
inline void off(int x){
    dela(x);
    B[x].push(0);
    pusha(x);
    for(int i=x;f[i];i=f[i]){
        dela(f[i]);
        if(C[i].size())B[f[i]].del(C[i].top());
        C[i].push(dis(x,f[i]));
        B[f[i]].push(C[i].top());
        pusha(f[i]);
    }
}
void prework(){
    for(int j=1;j<=Log[num];j++)
        for(int i=1;i+(1<<j)-1<=num;i++)
            mn[i][j]=min(mn[i][j-1],mn[i+(1<<(j-1))][j-1]);
}
inline int read(){
    int sum=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){sum=sum*10+ch-'0';ch=getchar();}
    return sum*f;
}
int main(){
    n=read();
    Log[0]=-1;for(int i=1;i<=200000;i++)Log[i]=Log[i>>1]+1;
    for(int i=1;i<n;i++){
        int u=read(),v=read();
        add_edge(u,v);add_edge(v,u);
    }
    dfs(1,0);
    prework();
    g[0]=n;root=0;all=n;
    getroot(1,0);build(root,0);
    tot=n;
    m=read();
    char s;
    while(m--){
        s=getchar();
        if(s=='G'){
            if(tot<=1)printf("%d\n",tot-1);
            else printf("%d\n",A.top());
        }
        else{
            int x=read();
            if(light[x]==0)on(x),tot--;
            else off(x),tot++;
            light[x]^=1;
        }
    }
    return 0;
}
```

---

## 作者：bztMinamoto (赞：27)

安利一发我的[blog](https://www.cnblogs.com/bztMinamoto/p/9381655.html)

神仙般的操作……

膜拜岛娘的思路和hzwer的代码……

![](https://i.loli.net/2018/07/28/5b5c0a750c492.png)

我们先假设有以上这么一棵树（图丑勿介）

进行先序遍历，得到$[A[B[E][F[H][I]]][C][D[G]]]$

再把所有字母去掉$[ [ [ ] [ [ ] [ ] ] ] [ ] [ [ ] ] ]$

这就是这一棵树的括号编码（本质是dfs得到的）

花了这么大功夫找，但这玩意儿到底有什么用呢？

我们考虑两个节点，E和G

取出他们之间的那段括号编码$] [ [ ] [ ] ] ] [ ] [ [$

再将所有匹配的括号去掉，得到$] ] [ [$

我们看到了两个$]$和两个$[$

再回到树上，我们发现E向上走两步，再向下走两步就到达了G

于是发现括号序列可以很方便地维护点与点之间的距离

能不能进一步优化呢？

我们发现，对于距离而言，匹配的括号是没有任何意义的

而且，由于距离只需要记录数字，所以维护括号也是没有意义的，只要有编码就行，可以用一个二元组$(a,b)$来描述它，表示有a个$]$和b个$[$

所以，如果有两个点P和Q，如果介于P和Q之间的括号编码表示为$(a,b)$，则P和Q在树上的距离就是a+b

是不是很方便啊~\(≧▽≦)/~啦啦啦

但是现在问题又来了，怎么维护编码呢？

如果可以通过左边一半的信息和右边一半的信息，从而得到整段编码的信息，就可以用我们熟悉的线段树来维护了

我们可以进行如下的分析

考虑对于两段括号编码$s1(a,b)$和$s2(c,d)$，他们合并起来可以得到$s(x,y)$

注意到$s1$和$s2$合并起来时会产生$min(b,c)$的匹配括号，合并后他们会被抵消掉

于是

当 $b<c$ 时第一段 [ 就被消完了，两段 $]$ 连在一起，例如：

$]  ]  [  [  +  ]  ]  ]  [  [  =  ]  ]  ]  [  [$

当 $b>=c$ 时第二段 ] 就被消完了，两段 $[ $连在一起，例如：
$]  ]  [  [  [  +  ]  ]  [  [  = ] ]  [  [  [$

于是就得到了几个十分有用的结论

当 $b<c$ 时，$(x,y) = (a-b+c,d)$

当 $b>=c$ 时，$(x,y) = (a,b-c+d)$

于是就可以用线段树维护整棵树的括号编码~\(≧▽≦)/~啦啦啦

题目所要求维护的，是max{a+b|s'(a,b)是s的一个子串，且s'位于两黑点之间}，我们将这个值表示为$dis(s)$

我们先根据上面的两条结论，得到几个推论

①$x+y=a+d+|b-c|=max((a+b-c+d),(a-b+c+d))$

②$x-y=a-b+c-d$

③$y-x=b-a+d-c$

由①式我们可以发现，要维护$dis(s)$，要维护四个值$a+b,d-c,a-b,d+c$

又为了保证$s'$在两个黑点之间，所以要加上一些限制

于是定义出如下四个参数

rightplus:max(a+b),s'是s的一个前缀且s紧接在一个黑点之后

rightminus:max(a-b),s'是s的一个前缀且s紧接在一个黑点之后

leftplus:max(a+b),s'是s的一个后缀且一个黑点紧接在s之后

leftminus:max(b-a),s'是s的一个后缀且一个黑点紧接在s之后

于是我们就可以用左右两半的状态转移到一整段的状态啦

还是考虑$s(x,y),s1(a,b),s2(c,d)$

$(x,y)=b<c?(a-b+c,d):(a,b-c+d)$

$dis(s)=max(dis(s1),dis(s2),rightplus(s1)+leftminus(s2),rightminus(s1)+leftplus(s2))$

（把四个参数的值带入上面的等式很容易发现这是正确的）

然后再来考虑如何求出四个参数呢？

$rightplus(s)=max(rightplus(s1)-c+d,rightminus(s1)+c+d,rightplus(s2))$

$rightminus(s)=max(rightminus(s1)+c-d,rightminus(s2))$

$leftplus(s)=max(leftplus(s2)-b+a,left_minus(s1)+b+a,leftplus(s1))$

$leftminus(s)=max(leftminus(s2)+b-a,leftminus(s1))$

然后就可以用线段树处理整个括号编码了

实际实现的时候还有一些小细节要注意

我们为了实现更方便，最好还是在编码时加入括号

对于底层结点，如果对应字符是一个括号或者一个白点，那 么right_plus、right_minus、left_plus、left_minus、dis 的值就都是 -inf；如果对应字符是一个黑点，那么 right_plus、right_minus、left_plus、left_minus 都是 0，dis 是-inf。

具体细节可以参见代码，注解比较详细（主要是因为自己照着打了一遍也不太看得懂代码……）

```
// luogu-judger-enable-o2
//minamoto
#include<bits/stdc++.h>
#define N 100005
#define inf 0x3f3f3f3f
using namespace std;
inline int read(){
    #define num ch-'0'
    char ch;bool flag=0;int res;
    while(!isdigit(ch=getchar()))
    (ch=='-')&&(flag=true);
    for(res=num;isdigit(ch=getchar());res=res*10+num);
    (flag)&&(res=-res);
    #undef num
    return res;
}
int ver[N<<1],Next[N<<1],head[N];
int v[N*3],pos[N],c[N];
int n,q,cnt,tot,black;
struct seg{
    int l,r,l1,l2,r1,r2,c1,c2,dis;
    void init(int x){
        dis=-inf;
        c1=c2=0;
        if(v[x]==-1) c2=1;
        if(v[x]==-2) c1=1;
        /*c2为失配左括号，c1为失配右括号 
        为左括号，c2=1；为右括号，c1=1*/
        if(v[x]>0&&c[v[x]]) l1=l2=r1=r2=0;
        else l1=l2=r1=r2=-inf;
        /*为黑点，l_plus,l_minus,r_plus,r_minus全为0 
        为白点或括号，全为1*/
    }
}a[N*12];
inline int max(int a,int b,int c){return max(a,max(b,c));}
void add(int u,int v){
    ver[++tot]=v,Next[tot]=head[u],head[u]=tot;
    ver[++tot]=u,Next[tot]=head[v],head[v]=tot;
}
void dfs(int u,int fa){
    v[++cnt]=-1;
    v[++cnt]=u;
    pos[u]=cnt;
    for(int i=head[u];i;i=Next[i])
    if(ver[i]!=fa) dfs(ver[i],u);
    v[++cnt]=-2;
    /*进入加左括号，离开加右括号*/
}
inline void merge(seg &s,seg s1,seg s2){
    /*r1=max(a+b),r2=max(a-b){s1(a,b)是s前缀且s1紧接在一个黑点之后}
    l1=max(a+b),l2=max(b-a){s2(a,b)是s后缀且s2紧接在一个黑点之前}*/
    int a=s1.c1,b=s1.c2,c=s2.c1,d=s2.c2;
    s.dis=max(s1.dis,s2.dis);
    s.dis=max(s.dis,s1.r1+s2.l2,s1.r2+s2.l1);
    /*s.dis=max(s1.dis,s2.dis,a1+b1-a2+b2,a1-b1+a2+b2)*/ 
    b<c?(s.c1=a-b+c,s.c2=d):(s.c1=a,s.c2=b-c+d);
    s.r1=max(s2.r1,s1.r1-c+d,s1.r2+c+d);
    /*a+b=max(a1-b1+a2+b2,a1+b1+b2-a2)*/
    s.r2=max(s2.r2,s1.r2+c-d);
    /*a-b=a1-b1+a2-b2*/
    s.l1=max(s1.l1,s2.l1-b+a,s2.l2+b+a);
    /*同62行*/
    s.l2=max(s1.l2,s2.l2+b-a);
    /*b-a=b2-a2+b1-a1*/
}
void build(int p,int l,int r){
    a[p].l=l,a[p].r=r;
    if(l==r){
        a[p].init(l);
        return;
    }
    int mid=(l+r)>>1;
    build(p<<1,l,mid);
    build(p<<1|1,mid+1,r);
    merge(a[p],a[p<<1],a[p<<1|1]);
}
void modify(int p,int x){
    int l=a[p].l,r=a[p].r;
    if(l==r){a[p].init(l);return;}
    int mid=(l+r)>>1;
    if(x<=mid) modify(p<<1,x);
    else modify(p<<1|1,x);
    merge(a[p],a[p<<1],a[p<<1|1]);
}
int main(){
    //freopen("testdata.in","r",stdin);
    black=n=read();
    for(int i=1;i<=n;++i) c[i]=1;
    for(int i=1;i<n;++i){
        int u=read(),v=read();
        add(u,v);
    }
    dfs(1,0);
    build(1,1,cnt);
    q=read();
    while(q--){
        char s[10];
        scanf("%s",s);
        if(s[0]=='C'){
            int x=read();
            if(c[x]) --black;
            else ++black;
            c[x]^=1;
            modify(1,pos[x]);
        }
        else{
            if(!black) puts("-1");
            else if(black==1) puts("0");
            else printf("%d\n",a[1].dis);
        }
    }
    return 0;
}
```

---

## 作者：Freopen (赞：13)

LCT也是此题的一种做法。     
我们需要的维护的是树上最远关灯点。      
LCT是一种链分治，相较于点分治和边分治，链分治不仅需要在变换分治中心的时候维护答案（经过虚边），在一条链中也需要维护答案（经过Splay上的边，也就是实边）。  
对于虚边，也就是轻儿子，我们需要求出下面最深的关灯点，更新答案时需要用最深关灯点和另一轻儿子中的最深关灯点来更新，另外还需要考虑当前点是关灯点的情况，和最远点在轻儿子子树中的情况，这些分别用两个堆来分别记录，并在access时维护。  
对于Splay上的实边，我们有左儿子和右儿子，左儿子是上半的重链，右儿子是下半重链。那么答案就是左儿子最下点往上的最远距离,和右儿子最上点往下的最远距离，还有当前点的轻儿子最远距离3者的任意一种结合，更新答案。 并继续维护当前链最上点往下，最下点往上的最远距离。  
没有link操作的LCT可以只用access+splay完成所有操作，常数并非特别大，甚至可以说十分优秀。  
因为需要用堆维护轻儿子的信息，复杂度$O(n\log^2 n)$
想仔细之后，代码并不难写，只是细节很多。  
AC Code:
```cpp
#include<bits/stdc++.h>
#define maxn 100005
#define LL long long
#define inf 0x3f3f3f3f
using namespace std;

int n;
int info[maxn],Prev[maxn<<1],to[maxn<<1],cst[maxn<<1],cnt_e;
void Node(int u,int v,int c){ Prev[++cnt_e]=info[u],info[u]=cnt_e,to[cnt_e]=v,cst[cnt_e]=c; }
multiset<int>path[maxn],chain[maxn];
int Max(multiset<int>&s){ return s.empty()?-inf:*s.rbegin(); }
int sMax(multiset<int>&s){ return s.size()<=1?-inf:*++s.rbegin(); }

namespace LCT{
	int ch[maxn][2],fa[maxn],val[maxn],lm[maxn],rm[maxn],mx[maxn],w[maxn],sum[maxn];
	#define il inline 
	#define pa fa[x]
	il int inr(int x){ return ch[pa][1]==x; }
	il int isr(int x){ return ch[pa][0]!=x && ch[pa][1]!=x; }
	il void upd(int x){
		int im = max(w[x],Max(chain[x]));
		int Um = max(im,rm[ch[x][0]]+val[x]) , Dm = max(im,lm[ch[x][1]])+val[x];
		lm[x] = max(lm[ch[x][0]],Dm+sum[ch[x][0]]);
		rm[x] = max(rm[ch[x][1]],Um+sum[ch[x][1]]);
		mx[x] = max(
			max(rm[ch[x][0]]+Dm,lm[ch[x][1]]+Um),
			max(max(Max(path[x]),Max(chain[x])+sMax(chain[x])),
			max(mx[ch[x][0]],mx[ch[x][1]])));
		if(w[x]==0) 
			mx[x] = max(mx[x] , max(Max(chain[x]),0));
		sum[x] = sum[ch[x][0]] + sum[ch[x][1]] + val[x];
	}
	il void rot(int x){
		int y = fa[x] , z = fa[y] , c = inr(x);
		if(!isr(y)) ch[z][inr(y)] = x;
		(ch[y][c]=ch[x][!c])&&(fa[ch[y][c]]=y);
		fa[fa[ch[x][!c]=y]=x]=z;
		upd(y);
	}
	il void splay(int x){
		for(;!isr(x);rot(x))
			if(!isr(pa)) rot(inr(pa)==inr(x)?pa:x);
		upd(x);
	}
	il int access(int x,int	y=0){
		for(;x;x=fa[y=x]){
			splay(x);
			if(ch[x][1]) path[x].insert(mx[ch[x][1]]),chain[x].insert(lm[ch[x][1]]);
			if(y) path[x].erase(path[x].find(mx[y])),chain[x].erase(chain[x].find(lm[y]));
			ch[x][1] = y , upd(x);
		}
		return y;
	}
}
using namespace LCT;
void dfs(int now,int ff){
	fa[now] = ff; 
	for(int i=info[now];i;i=Prev[i])
		if(to[i]!=ff){
			val[to[i]] = sum[to[i]] = cst[i];
			dfs(to[i],now);
			path[now].insert(mx[to[i]]),
			chain[now].insert(lm[to[i]]);
		}
	upd(now);
}

char cb[1<<15],*cs=cb,*ct=cb;
#define getc() (cs==ct&&(ct=(cs=cb)+fread(cb,1,1<<15,stdin),cs==ct)?0:*cs++)
void read(int &res){
	char ch;bool f = 0;
	for(;!isdigit(ch=getc());) if(ch=='-') f=1;
	for(res=ch-'0';isdigit(ch=getc());res=res*10+ch-'0');
	(f) && (res = -res);
}

int main(){
	read(n);
	for(int i=0;i<=n;i++) lm[i]=rm[i]=mx[i]=-inf;
	for(int i=1,u,v;i<n;i++){
		read(u),read(v);
		Node(u,v,1),Node(v,u,1);
	}
	dfs(1,0);
	int ans = mx[1];
	int Q;read(Q);
	for(char s[2];Q--;){
		for(;!isalpha(s[0]=getc()););
		if(s[0]=='C'){
			int x;read(x);
			access(x),splay(x);
			w[x]=(w[x]?0:-inf);
			upd(x),ans=mx[x];
		}
		else ans>=0?printf("%d\n",ans):puts("They have disappeared.");
	}
}
```


---

## 作者：xiezheyuan (赞：12)

## 简要题意

给出一个 $n$ 个点的树，每个点有黑白两种颜色。初始时每个点都是黑色的。$q$ 次操作，支持：

- `C x` 将第 $x$ 个点的颜色反转。
- `G` 询问树上两个黑色点的最远距离。特别地，若不存在黑色点，输出 $-1$。

允许离线，$1 \leq n \leq 10^5,1 \leq q \leq 5 \times 10^5$

## 思路

没有人写线段树分治吗？线段树分治会伤心的。

首先考虑如何维护树上点集的直径，有下面的推论：

> 对于一个集合 $S$ 和只有一个点的集合 $\{P\}$。若集合 $S$ 的直径为 $(U,V)$。则点集 $S\cap\{P\}$ 的直径只可能为 $(U,V),(U,P)$ 或 $(V,P)$。


证明的话可以参照其他题解。这个结论实际上是其他题解中点集直径合并定理的一个弱化版。

然后考虑解决原问题。我们可以考虑维护黑色点集，维护每一个点在黑色点集中的若干个时间段（具体你开一个桶记录一下上一次进入黑色点集的时刻即可）。

然后就自然地想到离线，将所有时间刻插入到线段树中。然后在线段树上分治，每次线段树上的点会记录当前时间段点集新增的点，新增点可以使用上面的推论，找到新点集直径的两个端点。

撤销是平凡的，开一个栈记录一下直径端点的变化即可。

时间复杂度 $O(n\log^2 n)$。如果使用 ST 表的方法，借助欧拉序或 DFS 序来求 LCA，可以做到 $O(n\log n)$。这里我写的是重链剖分。

## 代码

```cpp
#include <bits/stdc++.h>
#define ls (i<<1)
#define rs (i<<1|1)
#define mid ((l+r)>>1)
using namespace std;

const int N = 5e5+5, M = 5e5+5;

int siz[N],dep[N],father[N],top[N],son[N];
int n,q;

struct edge{
    int nxt,to;
} g[N<<1];
int head[N],ec;

void add(int u,int v){
    g[++ec].nxt=head[u];
    g[ec].to=v;
    head[u]=ec;
}

void dfs1(int u,int fa){
    dep[u] = dep[fa] + 1;
    siz[u] = 1;
    father[u] = fa;
    for(int i = head[u];i;i=g[i].nxt){
        int v = g[i].to;
        if(v == fa) continue;
        dfs1(v, u);
        siz[u] += siz[v];
        if(siz[son[u]] < siz[v]) son[u] = v;
    }
}

void dfs2(int u,int fa){
    if(son[u]){
        top[son[u]] = top[u];
        dfs2(son[u], u);
    }
    for(int i=head[u];i;i=g[i].nxt){
        int v = g[i].to;
        if(v == fa || v == son[u]) continue;
        top[v] = v;
        dfs2(v, u);
    }
}

inline int lca(int x,int y){
    while(top[x] != top[y]){
        if(dep[top[x]] < dep[top[y]]) swap(x, y);
        x = father[top[x]];
    }
    return dep[x] < dep[y] ? x : y;
}

inline int dis(int x,int y){
    return dep[x] + dep[y] - (dep[lca(x, y)]<<1);
}

vector<int> t[N<<2];

void update(int ql,int qr,int v,int i,int l,int r){
    if(ql <= l && r <= qr){
        t[i].push_back(v);
        return;
    }
    if(ql <= mid) update(ql, qr, v, ls, l, mid);
    if(qr > mid) update(ql, qr, v, rs, mid + 1, r);
}

stack<pair<int,int> > stk;
int u, v;
int ans[M];

void solve(int i,int l,int r){
    auto lvl = stk.size();
    for(int x : t[i]){
        stk.push(make_pair(u, v));
        if(!u && !v) u = x, v = x;
        else{
            vector<int> vct = {dis(u, v), dis(u, x), dis(v, x)};
            sort(vct.begin(), vct.end(), greater<int>());
            if(vct[0] == dis(u, x)) v = x;
            else if(vct[0] == dis(x, v)) u = x;
        }
    }
    if(l == r) ans[l] = (!u || !v) ? -1 : dis(u, v);
    else solve(ls, l, mid), solve(rs, mid + 1, r);
    while(stk.size() != lvl){
        auto top = stk.top();
        u = top.first, v = top.second;
        stk.pop();
    }
}

int lst[N];
bitset<N> col;
bitset<M> haveq;

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin>>n;
    for(int i=1;i<n;i++){
        int u,v;
        cin>>u>>v;
        add(u, v);add(v, u);
    }
    top[1] = 1;
    dfs1(1, 0);dfs2(1, 0);
    for(int i=1;i<=n;i++) lst[i] = 1;
    cin>>q;
    for(int i=2;i<=(q + 1);i++){
        char c;int x;
        cin>>c;
        if(c == 'C'){
            cin>>x;
            if(!col[x]){
                col[x] = 1;
                update(lst[x], i, x, 1, 1, q + 2);
            }
            else col[x] = 0, lst[x] = i;
        }
        else haveq[i] = 1;
    }
    for(int i=1;i<=n;i++){
        if(!col[i]) update(lst[i], q + 2, i, 1, 1, q + 2);
    }
    solve(1, 1, q + 2);
    for(int i=1;i<=(q + 2);i++){
        if(haveq[i]) cout<<ans[i]<<'\n';
    }
    return 0;
}

```


---

## 作者：ez_lcw (赞：9)

显然只有一次询问的话，可以用点分治来实现。

但是现在我们有多组询问，还带有修改，我们只能通过动态点分治来做了。

动态点分治的主要思想：省去每次点分治求重心的过程，直接预处理出来（因为树的形态不会改变），建立点分树。那么我们每次分治时只需按照点分树上的路径走就是了。

例如，对于这么一颗树：（样例，1为根）（感谢绘图网站[https://csacademy.com/app/graph_editor/](https://csacademy.com/app/graph_editor/)）

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019120709432633.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2V6X2xjdw==,size_16,color_FFFFFF,t_70)

建出来的点分树是这样的：（3为根）

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019120709433857.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2V6X2xjdw==,size_16,color_FFFFFF,t_70)

注意：点分树只是把在原树中点分治遍历的顺序建了出来，如果求 $dis$ 或 $lca$ 还是要在原树中求，不能在点分树上求，因为点分树改变了原树形态。所以如果题目的询问不是针对全局的，而是带有父子关系或深度关系的（比如多次询问树中路径长度为 $k$ 的路径个数，且满足路径中从起点到终点的所有点深度递增）就不能建点分树了。

~~应该不能吧，毕竟我也很蒟~~

然后我们对于每个点，维护四个大根堆：

1. $dis1$，维护：在点分树中以 $u$ 为根的子树中，所有灭灯的节点到 $u$ 的 $fa$ 的距离。
2. $erase1$，因为我们有时要从 $dis1$ 中删去一些值，所以 $erase1$ 维护在 $dis1$ 中要删去的值。
3. $dis2$，维护：在点分树中 $u$ 的所有儿子的 $dis1$ 的堆顶。那么将 $dis2$ 的 $top1$ 和 $top2$ 取出来，再相加，就是合法的经过 $u$ 的最长路径的长度。
4. $erase2$，和 $erase1$ 差不多，用来维护在 $dis2$ 中要删去的值。

由于对于 $dis1$ 和 $dis2$ 都有一个删除堆，所以我把 $dis1$、$erase1$ 封装在一起，称为 $heap1$；$dis2$、$erase2$封装在一起，称为 $heap2$。那么这两个 $heap$ 都可以实现 $top1()$、$top2()$、$pop()$、$erase()$ 和 $size()$ 操作。

然后我们维护一个全局 $heap$：$Ans$ 堆，同样有一个 $erase$ 堆。$Ans$用来维护全局 $dis2$ 堆的 $top1$ 和 $top2$ 之和。

那么如果询问，答案就是 $Ans$ 堆堆顶。

考虑如果修改一个点，那么只会对它的所有祖先的 $dis1$、$dis2$ 有影响。

那么我们记录下询问点 $Qpoint=u$，然后让 $u$ 往上跳，更新 $dis1$ 和 $dis2$。

代码和注释如下：

```cpp
#include<bits/stdc++.h>

#define N 100010
#define INF 0x7fffffff

using namespace std;

struct heap
{
	priority_queue<int>q1,q2;
	int size()
	{
		return q1.size()-q2.size();
	}
	void push(int x)
	{
		q1.push(x);
	} 
	void erase(int x)
	{
		q2.push(x);
	}
	void pop()
	{
		while(!q2.empty()&&q1.top()==q2.top())
			q1.pop(),q2.pop();
		q1.pop();
	}
	int top()
	{
		while(!q2.empty()&&q1.top()==q2.top())
			q1.pop(),q2.pop();
		return q1.empty()?0:q1.top();
	}
	int top2()
	{
		if(size()<2)return 0;
		int x=top();
		pop();
		int y=top();
		push(x);
		return y;
	}
}q,q1[N],q2[N];
//q全局路径最大
//q1距离自己父亲距离最大
//q2距离自己距离最大（每个儿子仅有一条路径） 

int n,Q,nn,root,sum;
int cnt,head[N],nxt[N<<1],to[N<<1];
int size[N],maxsize[N];
int d[N],f[N][17];
int fa[N],ans[N];
bool vis[N],open[N];

void adde(int u,int v)
{
	to[++cnt]=v;
	nxt[cnt]=head[u];
	head[u]=cnt;
}

//------------------------------------------------------------倍增求点之间的距离
void dfs(int u)
{
	for(int i=1;i<=16;i++)
		f[u][i]=f[f[u][i-1]][i-1];
	for(int i=head[u];i;i=nxt[i])
	{
		int v=to[i];
		if(v==f[u][0])
			continue;
		f[v][0]=u;
		d[v]=d[u]+1;
		dfs(v);
	}
}

int lca(int a,int b)
{
	if(d[a]<d[b])
		swap(a,b);
	for(int i=16;i>=0;i--)
		if(d[f[a][i]]>=d[b])
			a=f[a][i];
	if(a==b)
		return a;
	for(int i=16;i>=0;i--)
		if(f[a][i]!=f[b][i])
			a=f[a][i],b=f[b][i];
	return f[a][0];
}

int getdis(int a,int b)
{
	return d[a]+d[b]-2*d[lca(a,b)];
}

//------------------------------------------------------------建点分树
void getroot(int u,int fa)
{
	size[u]=1,maxsize[u]=0;
	for(int i=head[u];i;i=nxt[i])
	{
		int v=to[i];
		if(v==fa||vis[v])
			continue;
		getroot(v,u);
		size[u]+=size[v];
		maxsize[u]=max(maxsize[u],size[v]);
	}
	maxsize[u]=max(maxsize[u],nn-size[u]);
	if(maxsize[u]<maxsize[root])
		root=u;
}

void maketree(int u)
{
	vis[u]=true;
	for(int i=head[u];i;i=nxt[i])
	{
		int v=to[i];
		if(vis[v])
			continue;
		nn=size[v],root=0;
		getroot(v,u);
		fa[root]=u;//记录点分树中的fa
		maketree(root);
	}
}

//------------------------------------------------------------修改
void update(int u)
{
	if(open[u])
	{
		sum++;
		q2[u].push(0);//push(0)是为了保证当灯是关着时，q2[u]的size至少为1
		if(q2[u].size()==2) 
			q.push(q2[u].top());
	}
	else
	{
		sum--;
		if(q2[u].size()==2) 
			q.erase(q2[u].top());
		q2[u].erase(0);
	}
	int now=u;
	while(1)
	{
		int dis=getdis(fa[now],u),t1;
		if(!fa[now])
			return;
		if(!open[u])t1=q1[now].top(),q1[now].push(dis);//更新q1
		else q1[now].erase(dis),t1=q1[now].top();
		if(dis>t1)
		{
			int s1=q2[fa[now]].top()+q2[fa[now]].top2();
			int siz=q2[fa[now]].size();
			if(open[u])//更新q2
			{
				if(t1) 
					q2[fa[now]].erase(t1);
				q2[fa[now]].push(dis);
			}
			else
			{
				q2[fa[now]].erase(dis);
				if(t1) 
					q2[fa[now]].push(t1);
			}
			int s2=q2[fa[now]].top()+q2[fa[now]].top2();
			if(s2!=s1)//更新Ans堆
			{
				if(siz>=2) 
					q.erase(s1);
				if(q2[fa[now]].size()>=2)
					q.push(s2);
			}
		}
		now=fa[now];
	}
}

//------------------------------------------------------------主程序
int main()
{
	scanf("%d",&n);
	for(int i=1;i<n;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		adde(u,v),adde(v,u);
	}
	d[1]=1;
	dfs(1);
	nn=n,maxsize[0]=INF;
	getroot(1,0);
	maketree(root);
	for(int i=1;i<=n;i++)
		open[i]=true;
	for(int i=1;i<=n;i++)
		update(i),open[i]=false;
	scanf("%d",&Q);
	while(Q--)
	{
		char ch=getchar();
		while(ch!='C'&&ch!='G')
			ch=getchar();
		if(ch=='G')
		{
			if(sum>=2) printf("%d\n",q.top());
			else if(sum==1) puts("0");
			else puts("-1");
		}
		if(ch=='C')
		{
			int u;
			scanf("%d",&u);
			open[u]^=1;
			update(u);
		}
	}
	return 0;
}
```

---

## 作者：Mistletoes (赞：8)

[Query on a tree IV](https://www.luogu.com.cn/problem/SP2666)和这题基本是一样的，大家可以去交一下   

首先，我们求出树的重链，然后**对于每一条链，建一颗线段树**   
树大概长这样：
![](https://img-blog.csdnimg.cn/2019120708490960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VtbWEyb282,size_16,color_FFFFFF,t_70)
（其中用红边连起来的是一条条重链）

**在线段树上，我们维护**：   
**Opt(u)：经过 u节点代表的链的其中一段 的两个白点间的最长路径长度             
MaxL(u)：u节点代表的链的左端点到最远的白点的距离        
MaxR(u)：u节点代表的链的右端点到最远的白点的距离**   
怎么维护呢？   
我们再定义一些辅助变量方便描述：  
**D(i)：节点i到最远的白点的距离  
D2(i)：节点i到次远的白点的距离  
Dist(x,y)：节点x,y之间的距离  
Lc：线段树上左儿子  
Rc：线段树上右儿子**  
当 l==r 即链只有一个节点时：                           
**若u为黑色：                                 
MaxL(u)=MaxR(u)=D(L)                            
Opt(u)=D(L)+D2(L)                          
 若u为白色：                                    
 MaxL(u)=MaxR(u)=Max{D(L),0}                        
Opt(u)=Max{D(L)+D2(L),D(L)}**  
然后考虑如何push_up：  
**MaxL(u)=Max{MaxL(Lc),Dist(L,mid+1)+MaxL(Rc)}            
MaxR(u)=Max{MaxR(Rc),Dist(mid,R)+MaxR(Lc)}               
Opt(u)=Max{Opt(Lc),Opt(Rc),MaxR(Lc)+MaxL(Rc)+Dist(mid,mid+1)}**  
这样我们就维护好线段树啦，接下来**考虑怎么在树上修改一个点的颜色**：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191207091459609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VtbWEyb282,size_16,color_FFFFFF,t_70)
假设我们要修改黄色点的颜色，那么我们肯定要修改被黄色笔框住的这条链  
然后蓝色点肯定也被影响了，所以我们接下来修改被蓝色笔框住的这条链  
再接下来绿色点也被影响力，所以我们修改被绿色笔框住的这条链  
而下面已经没有点被影响了，修改结束  
可见要修改一个点，我们只需要**一层层链跳上去**直到**当前的链头无父节点**为止  
然后，我们还要考虑一下**如何维护D(i)和D2(i)** (节点到最远和次远白点的距离)：                                       
对此，我们**对每个点维护一个大根堆**，记录这个点到每个白点的距离  
**D(i)=s.top();  
s.pop();  
D2(i)=s.top();  
s.push(D(i));**  
这样就可以求出D(i)和D2(i)啦                             
最后，**在全局用个堆维护每条链的Opt**，就可以直接查询了         
这是Query on a tree IV的代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
const int maxn=100005;
const int inf=1e9;
struct work{
    priority_queue <int> f,g;
    inline void ins(int v) { if(v != -inf) f.push(v); } 
    inline void era(int v) { if(v != -inf) g.push(v); }
    inline int top() {
        while(1){
            if(f.empty()) return -inf;
            if(g.empty()) return f.top();
            if(f.top() == g.top()) f.pop(), g.pop();
            else return f.top();
        }
    }
}h[maxn], ans;
struct Edge{
	int u,v,w,next;
}edge[maxn<<1];
struct seg{
	int l,r,v,ls,rs;
}st[maxn<<2];
int wn,n,m,head[maxn],cnt,col[maxn],rt[maxn],onp;
int sz[maxn],fa[maxn],dep[maxn],son[maxn];
int tid[maxn],ord[maxn],ind,top[maxn],len[maxn];
inline int read() {
    int p=0,w=1; 
	char ch=getchar();
    while(ch>'9'||ch<'0') {if(ch=='-') w = -1; ch=getchar();}
    while(ch>='0'&&ch<='9') p=p*10+ch-'0',ch=getchar();
    return p*w;
}
void add(int u,int v,int w){
    edge[cnt].u=u;
    edge[cnt].v=v;
    edge[cnt].w=w;
    edge[cnt].next=head[u];
    head[u]=cnt++;
}
#define dis(x) dep[ord[x]]
void push(int u,int l,int r){
    int ls=st[u].ls,rs=st[u].rs,mid=(l+r)>>1;
    st[u].l=max(st[ls].l,st[rs].l+dis(mid+1)-dis(l));//MaxL(u)=Max{MaxL(Lc),Dist(L,mid+1)+MaxL(Rc)}
    st[u].r=max(st[rs].r,st[ls].r+dis(r)-dis(mid));//MaxR(u)=Max{MaxR(Rc),Dist(mid,R)+MaxR(Lc)}
    st[u].v=max(max(st[ls].v,st[rs].v),st[ls].r+st[rs].l+dis(mid+1)-dis(mid));
	//Opt(u)=Max{Opt(Lc),Opt(Rc),MaxR(Lc)+MaxL(Rc)+Dist(mid,mid+1)}
}
void build(int &u,int l,int r){
    if(!u) u=++onp;
    if(l==r){
        int x=ord[l];
        for(int i=head[x];i!=-1;i=edge[i].next){
        	int v=edge[i].v;
        	if(v==fa[x]||v==son[x]) continue;
			h[x].ins(st[rt[v]].l+dep[v]-dep[x]);
        }
        int d1=h[x].top(); 
		h[x].era(d1); 
		int d2=h[x].top(); 
		h[x].ins(d1);
        st[u].l=st[u].r=max(d1,0); 
		st[u].v=max(0,max(d1,d1+d2));//Opt(u)=Max{D(L)+D2(L),D(L)} 白色 
        return;
    }
    int mid =(l+r)>>1;
    build(st[u].ls,l,mid);
    build(st[u].rs,mid+1,r);
    push(u,l,r);
}
void update(int u,int l,int r,int v,int s){
	if(l==r){
        if(v==s){
            int d1=h[v].top();
			h[v].era(d1); 
			int d2 = h[v].top(); 
			h[v].ins(d1);
            if(col[v]) st[u].l=st[u].r=d1,st[u].v=d1+d2;//Opt=D(L)+D2(L) 黑色 
            else st[u].l=st[u].r=max(d1,0),st[u].v=max(0,max(d1,d1+d2));//Opt(u)=Max{D(L)+D2(L),D(L)} 白色 
        }
        else{
            h[v].ins(st[rt[s]].l+dep[s]-dep[v]);
            int d1 = h[v].top(); 
			h[v].era(d1);
			int d2 = h[v].top(); 
			h[v].ins(d1);
            if(col[v]) st[u].l=st[u].r=d1,st[u].v=d1+d2;//Opt=D(L)+D2(L) 黑色 
            else st[u].l=st[u].r=max(d1,0),st[u].v=max(0,max(d1,d1+d2));//Opt(u)=Max{D(L)+D2(L),D(L)} 白色 
        }
        return;
    }
    int mid=(l+r)>>1;
    if(tid[v]<=mid) update(st[u].ls,l,mid,v,s);
    else update(st[u].rs,mid+1,r,v,s);
    push(u,l,r);
}
void dfs1(int u){
    sz[u]=1;
    for(int i=head[u];i!=-1;i=edge[i].next){
        int v=edge[i].v;
        int w=edge[i].w;
        if(v==fa[u]) continue;
        fa[v]=u; 
		dep[v]=dep[u]+w;
        dfs1(v);
        sz[u]+=sz[v];
        if(sz[v]>sz[son[u]]) son[u]=v;
    }
}
void dfs2(int u,int tp){
    tid[u]=++ind;
    top[u]=tp;
    ord[ind]=u;
    len[tp]++;
    if(!son[u]) return;
    dfs2(son[u],tp);
    for(int i=head[u];i!=-1;i=edge[i].next){
        int v=edge[i].v;
        if(v==fa[u]||v==son[u]) continue;
        dfs2(v,v);
    }
} 
int main(){
	ios::sync_with_stdio(false);
	memset(head,-1,sizeof(head));
	wn=n=read();
	int u,v,w;
	for(int i=1;i<n;i++){
		u=read();v=read();w=read();
		add(u,v,w);
		add(v,u,w);
	}
	dfs1(1);
	dfs2(1,1);
	ans.ins(0);
	for(int i=n;i;i--){
        int u=ord[i]; 
		if(u!=top[u]) continue; 
        build(rt[u],tid[u],tid[u]+len[u]-1);  //每一条链建一线段树 
        ans.ins(st[rt[u]].v);
    }
    m=read();
    char ch;
    for(int i=1;i<=m;i++){
    	ch=getchar();
        while(ch!='C'&&ch!='A') ch=getchar();
    	if(ch=='C'){
            int x=read(); 
			col[x]^= 1;
            if(col[x]==0) wn++; 
			else wn --;
            for(int u=x,p=u;u;u=fa[u]){
                int tp=top[u];
                int p1=st[rt[tp]].v,d1=st[rt[tp]].l;
                if(fa[tp]) h[fa[tp]].era(st[rt[tp]].l+dep[tp]-dep[fa[tp]]);
                update(rt[tp],tid[tp],tid[tp]+len[tp]-1,u,p);
                int p2=st[rt[tp]].v,d2=st[rt[tp]].l;
                if(p1!=p2) ans.era(p1),ans.ins(p2);
                p=u=tp;
            }
        }
        else {
            if(wn==0) printf("They have disappeared.\n");
            else printf("%d\n", ans.top());
        }
    }
	return 0;
}
```
[捉迷藏](https://www.luogu.com.cn/problem/P2056)的代码只需要改一下输入输出，就不贴了

---

## 作者：hl666 (赞：7)

入坑**动态点分治**的题目，感觉还不错~~被卡常后重构代码~~

首先**静态点分治**相信大家肯定都会，就是不断找重心然后暴力计算每棵子树内的贡献。

这题如果只有单次询问，我们很容易想到对于每个分治中心的所以儿子的子树中找两条**最长**链拼起来。

或者是直接以这个点为端点的一条链的最大值。

如果就这么做复杂度将达到$O(qn\log n)$，完全无法接受。

我们还是考虑利用一下这个思想，点分治的优化时间的主要方式就是它这棵递归树**高度均衡**，可以直接在上面完成暴力操作。

注意到这道题没有动态加边，所以其实树的形态是不会变化的，所以我们可以在开始时先跑一边静态的点分治，在上面计算答案的同时把每次的**分支中心**的树结构建出来。

（在实际题目中由于我们一般只是暴力跳父亲节点，所以可以只记录父节点）

然后这个看似暴力的东西其实就是传说中的**点分树**

那么动态的问题就比较简单了，我们每次开关一盏灯的时候会影响到点分树上一条链的信息。直接跳即可。

考虑维护答案，这个也很简单，我们开三个**大根堆**，一个维护子树内最长链，一个维护到父节点的最长链，还有一个维护所有的答案。

统计答案的时候每个子树只用取**最大值**和**次大值**即可。不过要支持删除，可以考虑再开一个维护删除标记的堆~~免去手写烦恼~~。

两点间的距离在DFS的时候记录一个到根节点的路径长然后用**LCA**差分算一下就好了。

总体复杂度为$O(n\log^2 n)$，足以通过本题。

先送上最早写的思路比较清晰的CODE，但一直被卡$90pts$

```cpp
#include<cstdio>
#include<cctype>
#include<queue>
#define RI register int
#define Tp template <typename T>
#define add(x,y) e[++cnt]=(edge){y,head[x]},head[x]=cnt
using namespace std;
const int N=100005,INF=1e9;
struct edge
{
    int to,nxt;
}e[N<<1]; int head[N],n,m,rt,sonsize,mx[N],cnt,x,y,num; bool is_light[N]; char opt;
class FileInputOutput
{
    private:
        static const int S=1<<21;
        #define tc() (A==B&&(B=(A=Fin)+fread(Fin,1,S,stdin),A==B)?EOF:*A++)
        #define pc(ch) (Ftop<S?Fout[Ftop++]=ch:(fwrite(Fout,1,S,stdout),Fout[(Ftop=0)++]=ch))
        char Fin[S],Fout[S],*A,*B; int pt[15],Ftop;
    public:
        Tp inline void read(T &x)
        {
            x=0; char ch; while (!isdigit(ch=tc()));
            while (x=(x<<3)+(x<<1)+(ch&15),isdigit(ch=tc()));
        }
        Tp inline void write(T x)
        {
            if (!x) return (void)(pc('0'),pc('\n')); if (x<0) pc('-'),x=-x; RI ptop=0;
            while (x) pt[++ptop]=x%10,x/=10; while (ptop) pc(pt[ptop--]+48); pc('\n');
        }
        inline void get_alpha(char &ch)
        {
            while (!isalpha(ch=tc()));
        }
        inline void Fend(void)
        {
            fwrite(Fout,1,Ftop,stdout);
        }
        #undef tc
        #undef pc
}F;
struct Heap
{
    priority_queue <int> big,del;
    inline void push(int x)
    {
        big.push(x);
    }
    inline void erase(int x)
    {
        del.push(x);
    }
    inline int top(void)
    {
        while (!del.empty()&&big.top()==del.top())
        big.pop(),del.pop(); return big.top();
    }
    inline int sectop(void)
    {
        int t=top(); pop(); int ret=top(); push(t); return ret;
    }
    inline void pop(void)
    {
        while (!del.empty()&&big.top()==del.top())
        big.pop(),del.pop(); big.pop();
    }
    inline int size(void)
    {
        return big.size()-del.size();
    }
    inline bool empty(void)
    {
        return size()?0:1;
    }
}T[N],M[N],A;
class LCA_Solver
{
    private:
        static const int P=17;
        int anc[N][P],dep[N];
        inline void swap(int &x,int &y)
        {
            int t=x; x=y; y=t;
        }
        inline void reset(int now)
        {
            for (RI i=0;i<P-1;++i) if (anc[now][i])
            anc[now][i+1]=anc[anc[now][i]][i]; else break;
        }
        inline int query(int x,int y)
        {
            RI i; if (dep[x]<dep[y]) swap(x,y); for (i=P-1;~i;--i)
            if (dep[anc[x][i]]>=dep[y]) x=anc[x][i]; if (x==y) return x;
            for (i=P-1;~i;--i) if (anc[x][i]!=anc[y][i])
            x=anc[x][i],y=anc[y][i]; return anc[x][0];
        }
    public:
        #define to e[i].to
        inline void DFS(int now,int fa)
        {
            dep[now]=dep[fa]+1; reset(now);
            for (RI i=head[now];i;i=e[i].nxt)
            if (to!=fa) anc[to][0]=now,DFS(to,now);
        }
        #undef to
        inline int dis(int x,int y)
        {
            return dep[x]+dep[y]-(dep[query(x,y)]<<1);
        }
}L;
inline void insert(Heap &s)
{
    if (s.size()>1) A.push(s.top()+s.sectop());
}
inline void remove(Heap &s)
{
    if (s.size()>1) A.erase(s.top()+s.sectop());
}
class Point_Division_Solver
{
    private:
        int size[N],tofa[N]; bool vis[N];
        inline void maxer(int &x,int y)
        {
            if (y>x) x=y;
        }
        #define to e[i].to
        inline void travel(int now,int fa,int fart)
        {
            T[rt].push(L.dis(now,fart)); for (RI i=head[now];i;i=e[i].nxt)
            if (to!=fa&&!vis[to]) travel(to,now,fart);
        }
    public:
        inline void getrt(int now,int fa)
        {
            size[now]=1; mx[now]=0; for (RI i=head[now];i;i=e[i].nxt)
            if (to!=fa&&!vis[to]) getrt(to,now),size[now]+=size[to],maxer(mx[now],size[to]);
            if (maxer(mx[now],sonsize-size[now]),mx[now]<mx[rt]) rt=now;
        }
        inline void solve(int now,int fa)
        {
            tofa[now]=fa; vis[now]=1; M[now].push(0); travel(now,fa,fa);
            for (RI i=head[now];i;i=e[i].nxt) if (to!=fa&&!vis[to])
            mx[rt=0]=INF,sonsize=size[to],getrt(to,now),to=rt,solve(rt,now),M[now].push(T[to].top()); insert(M[now]);
        }
        #undef to
        inline void Off(int now)
        {
            remove(M[now]); M[now].push(0); insert(M[now]);
            for (RI i=now;i;i=tofa[i])
            {
                remove(M[tofa[i]]); if (!T[i].empty()) M[tofa[i]].erase(T[i].top());
                T[i].push(L.dis(now,tofa[i])); if (!T[i].empty())
                M[tofa[i]].push(T[i].top()); insert(M[tofa[i]]);
            }
        }
        inline void On(int now)
        {
            remove(M[now]); M[now].erase(0); insert(M[now]);
            for (RI i=now;i;i=tofa[i])
            {
                remove(M[tofa[i]]); if (!T[i].empty()) M[tofa[i]].erase(T[i].top());
                T[i].erase(L.dis(now,tofa[i])); if (!T[i].empty())
                M[tofa[i]].push(T[i].top()); insert(M[tofa[i]]);
            }
        }
}S;
int main()
{
    //freopen("CODE.in","r",stdin); freopen("CODE.out","w",stdout);
    RI i; for (F.read(n),num=n,i=1;i<n;++i) F.read(x),F.read(y),add(x,y),add(y,x);
    for (sonsize=n,L.DFS(1,0),mx[rt=0]=INF,S.getrt(1,0),S.solve(rt,0),F.read(m),i=1;i<=m;++i)
    {
        F.get_alpha(opt); if (opt^'C') { F.write(num<=1?num-1:A.top()); continue; }
        F.read(x); if (is_light[x]) S.Off(x),++num; else S.On(x),--num; is_light[x]^=1;
    }
    return F.Fend(),0;
}
```

后来没办法重构了代码，加了一堆类似剪枝的东西上去终于搞过去了。

CODE

```cpp
#include<cstdio>
#include<cctype>
#include<queue>
#define RI register int
#define Tp template <typename T>
#define add(x,y) e[++cnt]=(edge){y,head[x]},head[x]=cnt
using namespace std;
const int N=100005,INF=1e9;
struct edge
{
    int to,nxt;
}e[N<<1]; int head[N],n,m,rt,sonsize,mx[N],cnt,x,y,num; bool is_light[N]; char opt;
class FileInputOutput
{
    private:
        static const int S=1<<21;
        #define tc() (A==B&&(B=(A=Fin)+fread(Fin,1,S,stdin),A==B)?EOF:*A++)
        #define pc(ch) (Ftop<S?Fout[Ftop++]=ch:(fwrite(Fout,1,S,stdout),Fout[(Ftop=0)++]=ch))
        char Fin[S],Fout[S],*A,*B; int pt[15],Ftop;
    public:
        Tp inline void read(T &x)
        {
            x=0; char ch; while (!isdigit(ch=tc()));
            while (x=(x<<3)+(x<<1)+(ch&15),isdigit(ch=tc()));
        }
        Tp inline void write(T x)
        {
            if (!x) return (void)(pc('0'),pc('\n')); if (x<0) pc('-'),x=-x; RI ptop=0;
            while (x) pt[++ptop]=x%10,x/=10; while (ptop) pc(pt[ptop--]+48); pc('\n');
        }
        inline void get_alpha(char &ch)
        {
            while (!isalpha(ch=tc()));
        }
        inline void Fend(void)
        {
            fwrite(Fout,1,Ftop,stdout);
        }
        #undef tc
        #undef pc
}F;
struct Heap
{
    priority_queue <int> big,del;
    inline void push(int x)
    {
        big.push(x);
    }
    inline void erase(int x)
    {
        del.push(x);
    }
    inline int top(void)
    {
        while (!del.empty()&&!(big.top()^del.top()))
        big.pop(),del.pop(); return big.empty()?0:big.top();
    }
    inline int get(void)
    {
    	int s=size(); if (!s) return 0; if (s==1) return top();
        int t=top(); pop(); int ret=top()+t; push(t); return ret;
    }
    inline void pop(void)
    {
        while (!del.empty()&&!(big.top()^del.top()))
        big.pop(),del.pop(); big.pop();
    }
    inline int size(void)
    {
        return big.size()-del.size();
    }
}T[N],M[N],A;
class LCA_Solver
{
    private:
        static const int P=17;
        int anc[N][P],dep[N];
        inline void swap(int &x,int &y)
        {
            int t=x; x=y; y=t;
        }
        inline void reset(int now)
        {
            for (RI i=0;i<P-1;++i) if (anc[now][i])
            anc[now][i+1]=anc[anc[now][i]][i]; else break;
        }
        inline int query(int x,int y)
        {
            RI i; if (dep[x]<dep[y]) swap(x,y); for (i=P-1;~i;--i)
            if (dep[anc[x][i]]>=dep[y]) x=anc[x][i]; if (x==y) return x;
            for (i=P-1;~i;--i) if (anc[x][i]!=anc[y][i])
            x=anc[x][i],y=anc[y][i]; return anc[x][0];
        }
    public:
        #define to e[i].to
        inline void DFS(int now,int fa)
        {
            dep[now]=dep[fa]+1; reset(now);
            for (RI i=head[now];i;i=e[i].nxt)
            if (to!=fa) anc[to][0]=now,DFS(to,now);
        }
        #undef to
        inline int dis(int x,int y)
        {
            return dep[x]+dep[y]-(dep[query(x,y)]<<1);
        }
}L;
class Point_Division_Solver
{
    private:
        int size[N],tofa[N]; bool vis[N];
        inline void maxer(int &x,int y)
        {
            if (y>x) x=y;
        }
        #define to e[i].to
        inline void travel(int now,int fa,int fart)
        {
            T[rt].push(L.dis(now,fart)); for (RI i=head[now];i;i=e[i].nxt)
            if (to!=fa&&!vis[to]) travel(to,now,fart);
        }
    public:
        inline void getrt(int now,int fa)
        {
            size[now]=1; mx[now]=0; for (RI i=head[now];i;i=e[i].nxt)
            if (to!=fa&&!vis[to]) getrt(to,now),size[now]+=size[to],maxer(mx[now],size[to]);
            if (maxer(mx[now],sonsize-size[now]),mx[now]<mx[rt]) rt=now;
        }
        inline void solve(int now,int fa)
        {
            tofa[now]=fa; vis[now]=1; M[now].push(0); travel(now,fa,fa);
            for (RI i=head[now];i;i=e[i].nxt) if (to!=fa&&!vis[to])
            mx[rt=0]=INF,sonsize=size[to],getrt(to,now),to=rt,solve(rt,now),M[now].push(T[to].top());
            A.push(M[now].get());
        }
        #undef to
        inline void Off(int now)
        {
            M[now].push(0); if (M[now].size()==2) A.push(M[now].top());
            for (RI i=now;tofa[i];i=tofa[i])
            {
                int fa=tofa[i],D=L.dis(fa,now),temp=T[i].top();
                T[i].push(D); if (D<=temp) continue;
                int mx=M[fa].get(),size=M[fa].size();
                if (temp) M[fa].erase(temp); M[fa].push(D);
                int Mx=M[fa].get(); if (Mx>mx)
                {
                	if (size>=2) A.erase(mx);
                	if (M[fa].size()>=2) A.push(Mx);
                }
            }
        }
        inline void On(int now)
        {
            if (M[now].size()==2) A.erase(M[now].top()); M[now].erase(0);
            for (RI i=now;tofa[i];i=tofa[i])
            {
                int fa=tofa[i],D=L.dis(fa,now),temp=T[i].top();
                T[i].erase(D); if (D!=temp) continue;
                int mx=M[fa].get(),size=M[fa].size();
                M[fa].erase(D); if (temp=T[i].top()) M[fa].push(temp);
                int Mx=M[fa].get(); if (Mx<mx)
                {
                	if (size>=2) A.erase(mx);
                	if (M[fa].size()>=2) A.push(Mx);
                }
            }
        }
}S;
int main()
{
    //freopen("CODE.in","r",stdin); freopen("CODE.out","w",stdout);
    RI i; for (F.read(n),num=n,i=1;i<n;++i) F.read(x),F.read(y),add(x,y),add(y,x);
    for (sonsize=n,L.DFS(1,0),mx[rt=0]=INF,S.getrt(1,0),S.solve(rt,0),F.read(m),i=1;i<=m;++i)
    {
        F.get_alpha(opt); if (opt^'C') { F.write(num<=1?num-1:A.top()); continue; }
        F.read(x); if (is_light[x]) S.Off(x),++num; else S.On(x),--num; is_light[x]^=1;
    }
    return F.Fend(),0;
}
```

---

## 作者：Sangber (赞：3)

### 题目描述
给出一棵$N$个有色(黑白，黑色对应关灯，白色对应开灯)节点的树以及$M$次操作，每次操作将改变一个节点的颜色或者求出树上最远的两个白点距离

----
### 基本思路
#### $60pts$做法
这道题是动态点分治的板子题，动态点分治还是比(shi)较(fen)难写的。。。  
所以我们先打一打部分分，瞄一眼数据范围：  
对于$\%60$的数据，$N\leq3000,M\leq10000$  
这样的数据很好做吧，我们用树的直径来搞就好了(还可以加一点卡常)。  
求树的直径我用的是两次$DFS$，不过我们要改一点细节：  
```cpp
int id, __max, co[MAXN];
//co维护单点颜色，0表示黑色，1表示白色
inline void dfs(int u, int fa, int dis) {
    if (dis >= __max && !co[u]) __max = dis, id = u;
    //只有当点u为黑点才可以更新
    for (rg int v, i = head[u]; i; i = nxt[i])
        if ((v = ver[i]) ^ fa) dfs(v, u, dis + 1);
}
```
这样就改好了，复杂度还是$O(N)$的。  
在主函数里面，我们加一点这样的卡常：  
因为这样的算法在执行修改时，只需$O(1)$修改$co$数组，而更新答案是$O(N)$的  
所以我们只在每次查询时重新跑一遍$DFS$并且我们用一个变量$flag$，表示我们是否求出了最新的结果，这样就算有连续多次查询我们也可以马上输出答案走人。  
#### $60pts$参考代码
```cpp
/*--------------------------------
  Code name: HideAndSeek.cpp
  Author: The Ace Bee
  This code is made by The Ace Bee
--------------------------------*/
#include <queue>
#include <cstdio>
#include <algorithm>
#define rg register
using namespace std;
const int MAXN = 100010;
inline int read() {
    int s = 0; bool f = false; char c = getchar();
    while (c < '0' || c > '9') f |= (c == '-'), c = getchar();
    while (c >= '0' && c <= '9') s = (s << 3) + (s << 1) + (c ^ 48), c = getchar();
    return f ? -s : s;
}
int n, m;
int tot, head[MAXN], nxt[MAXN << 1], ver[MAXN << 1];
inline void Add_edge(int u, int v)
{ nxt[++tot] = head[u], head[u] = tot, ver[tot] = v; }
int id, __max, co[MAXN];
inline void dfs(int u, int fa, int dis) {
    if (dis >= __max && !co[u]) __max = dis, id = u;
    for (rg int v, i = head[u]; i; i = nxt[i])
        if ((v = ver[i]) ^ fa) dfs(v, u, dis + 1);
}
int main() {
    n = read();
    for (rg int u, v, i = 1; i <= n - 1; ++i)
        u = read(), v = read(), Add_edge(u, v), Add_edge(v, u);
    m = read(); char s[5]; bool flag = false;
    for (rg int i = 1; i <= m; ++i) {
        scanf("%s", s);
        if (s[0] == 'C')
            co[read()] ^= 1, flag = false;
		else {
            if (flag) printf("%d\n", __max);
            else {
                __max = 0, dfs(1, 0, 0);
                __max = 0, dfs(id, 0, 0);
                printf("%d\n", __max);
                flag = true;
            }
        }
    }
    return 0;
}

```
----
#### $100pts$正解
上面也提到了，动态点分治难得写，所以我们还是打一发括号序列吧。  
至于具体实现的话以及代码讲解的话，听说大家都是在一个地方，所以就不多赘述了(Orz 岛娘！！！)  
那我可就直接上代码了(压行毒瘤qwq)
```cpp
/*--------------------------------
  Code name: HideAndSeek.cpp
  Author: The Ace Bee
  This code is made by The Ace Bee
--------------------------------*/
#include <cstdio>
#define rg register
const int INF = 2e9;
const int MAXN = 500010;
inline int max(int a, int b) { return a > b ? a : b ; }
inline int read() {
    int s = 0; bool f = false; char c = getchar();
    while (c < '0' || c > '9') f |= (c == '-'), c = getchar();
    while (c >= '0' && c <= '9') s = (s << 3) + (s << 1) + (c ^ 48), c = getchar();
    return f ? -s : s;
}
int tot, head[MAXN], nxt[MAXN << 1], ver[MAXN << 1];
inline void Add_edge(int u, int v)
{ nxt[++tot] = head[u], head[u] = tot, ver[tot] = v; }
int n, m, col[MAXN];
int black, len, s[MAXN * 3], pos[MAXN];
inline void dfs(int u, int fa) {
    s[++len] = -1;
    s[++len] = u, pos[u] = len;
    for (rg int v, i = head[u]; i; i = nxt[i])
        if ((v = ver[i]) ^ fa) dfs(v, u);
    s[++len] = -2;
}
struct node{ int a, b, l1, l2, r1, r2, dis; }c[MAXN << 2];
inline int lc(int rt) { return rt << 1; }
inline int rc(int rt) { return rt << 1 | 1; }
inline void upt(int rt, int x) {
    c[rt].a = c[rt].b = 0;
    c[rt].l1 = c[rt].l2 = c[rt].r1 = c[rt].r2 = c[rt].dis = -1e9;
    if (s[x] == -1) { c[rt].b = 1; return ; }
    if (s[x] == -2) { c[rt].a = 1; return ; }
    if (!col[s[x]]) c[rt].l1 = c[rt].l2 = c[rt].r1 = c[rt].r2 = c[rt].dis = 0;
}
inline void pushup(int rt) {
    if (c[lc(rt)].b > c[rc(rt)].a)
        c[rt].a = c[lc(rt)].a, c[rt].b = c[lc(rt)].b - c[rc(rt)].a + c[rc(rt)].b;
    else
        c[rt].a = c[lc(rt)].a - c[lc(rt)].b + c[rc(rt)].a, c[rt].b = c[rc(rt)].b;
    c[rt].l1 = max(c[lc(rt)].l1, max(c[rc(rt)].l1 + c[lc(rt)].a - c[lc(rt)].b, c[rc(rt)].l2 + c[lc(rt)].a + c[lc(rt)].b));
    c[rt].l2 = max(c[lc(rt)].l2, c[rc(rt)].l2 - c[lc(rt)].a + c[lc(rt)].b);
    c[rt].r1 = max(c[rc(rt)].r1, max(c[lc(rt)].r1 - c[rc(rt)].a + c[rc(rt)].b, c[lc(rt)].r2 + c[rc(rt)].a + c[rc(rt)].b));
    c[rt].r2 = max(c[rc(rt)].r2, c[lc(rt)].r2 + c[rc(rt)].a - c[rc(rt)].b);
    c[rt].dis = max(max(c[lc(rt)].dis, c[rc(rt)].dis), max(c[lc(rt)].r1 + c[rc(rt)].l2, c[lc(rt)].r2 + c[rc(rt)].l1));
}
inline void build(int rt, int l, int r) {
    if (l == r) { upt(rt, l); return ; }
    int mid = (l + r) >> 1;
    build(lc(rt), l, mid), build(rc(rt), mid + 1, r);
    pushup(rt);
}
inline void update(int rt, int l, int r, int id) {
    if (l == r) { upt(rt, l); return; }
    int mid = (l + r) >> 1;
    if (id <= mid) update(lc(rt), l, mid, id);
    else update(rc(rt), mid + 1, r, id);
    pushup(rt);
}
int main() {
    black = n = read();
    for (rg int u, v, i = 1; i <= n - 1; ++i)
        u = read(), v = read(), Add_edge(u, v), Add_edge(v, u);
    dfs(1, 0);
    build(1, 1, len);
    m = read();
    char ss[5];
    for (rg int i = 1; i <= m; ++i) {
        scanf("%s", ss);
        if (ss[0] == 'C') {
            int x = read();
            black += col[x] ? -1 : 1;
            col[x] ^= 1, update(1, 1, len, pos[x]);
        } else {
            if (black == 0) puts("-1");
            else if (black == 1) puts("0");
            else printf("%d\n", c[1].dis);	
        }
    }
    return 0;
}

```
**完结撒花$qwq$**

---

## 作者：KokiNiwa (赞：3)

# [ZJOI 2007] 捉迷藏

这是一个动态点分治（毒瘤）。

## 题目叙述

给你一颗树，有$n$个节点的树，一开始所有点都是黑色的，要求支持以下操作：

+ 更改点的颜色
+ 求所有黑点的距离最远的点对。

## 题解

考虑动态点分治。

每个点维护一个堆，考虑直接找到不包括同一子树里的（因为不能容斥）。一个点的堆维护这个点管理的连通块里的所有点的距离，但这样显然会有同一子树里的。于是考虑这个点的每个儿子维护一个堆，这个堆插入所有那个儿子的连通块到这个点的距离（就是一个儿子管理的连通块到父亲的距离插入到那个堆里面）。那，这个点自己维护的堆的值应该插入所有这个点的儿子的最大值，这样必然没有同一子树里的点了。

## 代码

奇丑无比，掺杂着一些注释。

```cpp
#include <cstdio>
#include <vector>
#include <queue>
#include <iostream>
using namespace std;
const int maxNode = 1e5 + 5, maxOula = 2e5 + 5;
int nbNode, nbQry, maxPart[maxNode], size[maxNode], up[maxNode], state[maxNode], dep[maxNode];
int st[maxOula][19], Lg[maxOula], oula[maxNode], tail;
bool vis[maxNode];
vector<int> G[maxNode];
struct Heap {
	priority_queue<int> all, rem;
	void Insert(int val) { all.push(val); }
	void Erase(int val) { rem.push(val); }
	int Top() {
		while (!rem.empty() && all.top() == rem.top()) {
			all.pop();
			rem.pop();
		}
		return all.top();
	}
	void Pop() {
		while (!rem.empty() && all.top() == rem.top()) {
			all.pop();
			rem.pop();
		}
		all.pop();
	}
	int SecTop() {
		int tmp = Top(), ret;
		Pop();
		ret = Top();
		Insert(tmp);
		return ret;
	}
	int Size() { return all.size() - rem.size(); }
};
Heap ans, ch[maxNode], dist[maxNode];
void Dfs(int now, int from) {
	dep[now] = dep[from] + 1;
	st[++tail][0] = dep[now];
	oula[now] = tail;
	for (int to : G[now]) {
		if (to == from) continue ;
		Dfs(to, now);
		st[++tail][0] = dep[now];
	}
}
void Build() {
	for (int num = 2; num <= tail; ++num)
		Lg[num] = Lg[num >> 1] + 1;
	for (int lift = 1; lift <= Lg[tail]; ++lift)
		for (int pos = 1; pos + (1 << lift) - 1 <= tail; ++pos)
			st[pos][lift] = min(st[pos][lift - 1], st[pos + (1 << (lift - 1))][lift - 1]);
}
int Lca(int uNd, int vNd) {
	int lEP = oula[uNd], rEP = oula[vNd];
	if (lEP > rEP) swap(lEP, rEP);
    //这里要先swap再计算下面这个值。。。
	int lg2 = Lg[rEP - lEP + 1];
	return min(st[lEP][lg2], st[rEP - (1 << lg2) + 1][lg2]);
}
int Dis(int uNd, int vNd) {
	return dep[uNd] + dep[vNd] - (Lca(uNd, vNd) << 1);
}
int GetRoot(int now, int from, int all) {
	size[now] = 1;
	maxPart[now] = 0;
	int ret = 0;
	for (int to : G[now]) {
		if (vis[to] || to == from) continue ;
		int sonRoot = GetRoot(to, now, all);
		size[now] += size[to];
		maxPart[now] = max(maxPart[now], size[to]);
		if (maxPart[ret] > maxPart[sonRoot])
			ret = sonRoot;
	}
	maxPart[now] = max(maxPart[now], all - size[now]);
	if (maxPart[ret] > maxPart[now])
		ret = now;
	return ret;
}
void Divide(int now, int all) {
	vis[now] = 1;
	for (int to : G[now]) {
		if (vis[to]) continue ;
		int sonSize = (size[to] > size[now]) ? (all - size[now]) : size[to];
		int rt = GetRoot(to, -1, sonSize);
		up[rt] = now;
		Divide(rt, sonSize);
	}
}
void On(int node) {
	bool is = node == 2;
	state[node] ^= 1;
	if (dist[node].Size() >= 2)
		ans.Erase(dist[node].Top() + dist[node].SecTop());
	dist[node].Insert(0);
	if (dist[node].Size() >= 2)
		ans.Insert(dist[node].Top() + dist[node].SecTop());
	for (int now = node; up[now]; now = up[now]) {
		int dis = Dis(node, up[now]);
		int nowTop = ch[now].Size() ? ch[now].Top() : -1;
		ch[now].Insert(dis);
		if (nowTop != ch[now].Top()) {
			if (dist[up[now]].Size() >= 2)
				ans.Erase(dist[up[now]].Top() + dist[up[now]].SecTop());
			if ((~nowTop) && dist[up[now]].Size())
				dist[up[now]].Erase(nowTop); 
			dist[up[now]].Insert(ch[now].Top());
			if (dist[up[now]].Size() >= 2)
				ans.Insert(dist[up[now]].Top() + dist[up[now]].SecTop());
		}
	}
}
void Off(int node) {
	state[node] ^= 1;
	if (dist[node].Size() >= 2)
		ans.Erase(dist[node].Top() + dist[node].SecTop());
	dist[node].Erase(0);
	if (dist[node].Size() >= 2)
		ans.Insert(dist[node].Top() + dist[node].SecTop());
	for (int now = node; up[now]; now = up[now]) {
		int dis = Dis(node, up[now]);
		if (ch[now].Top() == dis) {
			if (dist[up[now]].Size() >= 2)
				ans.Erase(dist[up[now]].Top() + dist[up[now]].SecTop());
			dist[up[now]].Erase(ch[now].Top());
			ch[now].Erase(dis);
			if (ch[now].Size())
				dist[up[now]].Insert(ch[now].Top());
			if (dist[up[now]].Size() >= 2)
				ans.Insert(dist[up[now]].Top() + dist[up[now]].SecTop());
		}
		else ch[now].Erase(dis);
	}
}
int main() {
	maxPart[0] = 0x3f3f3f3f;
	scanf("%d", &nbNode);
	for (int edge = 1; edge < nbNode; ++edge) {
		int u, v; scanf("%d%d", &u, &v);
		G[u].push_back(v);
		G[v].push_back(u);
	}
	Divide(GetRoot(1, 0, nbNode), nbNode);
	Dfs(1, 0);
	Build();
	for (int i = 1; i <= nbNode; ++i) On(i);
	scanf("%d", &nbQry);
	int nowTot = nbNode, light = nbNode;
	int cnt = 0;
	while (nbQry--) {
		char opt;
		scanf("\n%c", &opt);
		if (opt == 'G') {
			if (light <= 1) printf("%d\n", light - 1);
			else printf("%d\n", ans.Top());
		} else {
			int node;
			scanf("%d", &node);
			if (state[node]) Off(node);
			else {
				On(node);
				++light;
			}
		}
	}
	return 0;
}
```

## 知识点

+ 思考要避免套路。以前做点分治做多了，导致自己思考总是想把对于到这个点的所有路径都搞成一个序列，然后用个线段树之类的东西搞一下。虽然这道题可能也可以做，但是麻烦死。还是要回归原本没有套路的状态。
+ 对顶堆小技巧。
+ 不会做了就换个方法描述问题，说不定就会了。

---

## 作者：AC_love (赞：1)

没人写 DDP？没人写 DDP？没人写 DDP？没人写 DDP？

那么来一篇 DDP 的题解。

令开灯的点为白点，关灯的为黑点。

DDP 第一个常规套路：考虑不带修的时候怎么做树形 DP。

设 $f(i, 0)$ 表示以 $i$ 为根的子树中 $i$ 到最远的黑点的距离，$f(i, 1)$ 表示 $i$ 点的答案。

$i$ 为白点时，有转移：

$$f(i, 1) = \max_{x \in son_i} (f(i, 0) + f(x, 0) + 1, f(x, 1))$$

$$f(i, 0) = \max_{x \in son_i} f(x, 0) + 1$$

$i$ 为黑点时，判一下 $i$ 自己作为子树内唯一黑点的情况即可。

现在带修了，考虑怎么做。

DDP 第二个常规套路：将信息分成重儿子信息和所有轻儿子信息，考虑如何利用重儿子信息和所有轻儿子信息维护父亲信息。

令 $x$ 为 $i$ 的重儿子，$g(i, 0 / 1)$ 为 $i$ 的轻儿子的答案。

$$f(i, 0) = \max(f(x, 0) + 1, g(i, 0) + 1)$$

$$f(i, 1) = \max(f(x, 0) + g(i, 0) + 2, f(x, 1), g(i, 1))$$

DDP 第三个常规套路，把转移写成矩阵的形式：

$$\begin{bmatrix} 1 && -\inf && g(i, 0) +1 \\ g(i, 0) + 2 && 0 && g(i, 1) \\ -\inf && -\inf&& 0 \end{bmatrix} \times \begin{bmatrix} f(x, 0) \\ f(x, 1) \\ 0 \end{bmatrix} = \begin{bmatrix} f(i, 0) \\ f(i, 1) \\ 0  \end{bmatrix}$$

老生常谈的套路，对每个节点开两个 `multiset` 维护这个点上所有的 $g$，注意当这个点本身就是黑点的时候要往 $g$ 里多插一个数进去。

DDP 时注意叶子的转移矩阵需要特判。

代码细节比较多，可以看看我的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 114;

struct matrix
{
    int a[3][3];
    void init() { a[0][0] = a[0][1] = a[0][2] = a[1][0] = a[1][1] = a[1][2] = a[2][0] = a[2][1] = a[2][2] = -N; }
};

matrix operator * (matrix a, matrix b)
{
    matrix c;
    c.init();
    for(int i = 0; i < 3; i = i + 1)
        for(int j = 0; j < 3; j = j + 1)
            for(int k = 0; k < 3; k = k + 1)
                c.a[i][j] = max(c.a[i][j], a.a[i][k] + b.a[k][j]);
    return c;
}

vector <int> e[N];

struct node
{
    int fa;
    int dep;
    int size;
    int son;
    int top;
    int dfn;
    int low;
    int w;
    matrix m;
    multiset <int> s0, s1;
};
node d[N];

struct tree
{
    int l;
    int r;
    matrix m;
};

int f[N][2];

void dfs1(int st, int fa, int dep)
{
    d[st].w = 1;
    d[st].fa = fa;
    d[st].dep = dep;
    d[st].size = 1;
    for(auto ed : e[st])
    {
        if(ed == fa)
            continue;
        dfs1(ed, st, dep + 1);
        f[st][1] = max(f[st][1], max(f[st][0] + f[ed][0] + 1, f[ed][1]));
        f[st][0] = max(f[st][0], f[ed][0] + 1);
        d[st].size += d[ed].size;
        if(d[d[st].son].size < d[ed].size)
            d[st].son = ed;
    }
    f[st][1] = max(f[st][1], f[st][0]);
}

void update(int x)
{
    d[x].m.init();
    d[x].m.a[0][0] = 1;
    d[x].m.a[0][1] = -N;
    if(d[x].s0.size())
        d[x].m.a[0][2] = *(-- d[x].s0.end()) + 1,
        d[x].m.a[1][0] = d[x].m.a[0][2] + 1;
    d[x].m.a[1][1] = 0;
    if(d[x].s1.size())
        d[x].m.a[1][2] = *(-- d[x].s1.end());
    if(d[x].s0.size() >= 2)
        d[x].m.a[1][2] = max(d[x].m.a[1][2], (*(-- d[x].s0.end()) + *(-- (-- d[x].s0.end()))) + 2);
    d[x].m.a[2][0] = -N;
    d[x].m.a[2][1] = -N;
    d[x].m.a[2][2] = 0;
}

void update_leaf(int x)
{
    if(d[x].w)
        d[x].m.a[0][0] = d[x].m.a[0][1] = d[x].m.a[0][2] = d[x].m.a[1][0] = d[x].m.a[1][1] = d[x].m.a[1][2] = 0;
    else
        d[x].m.a[0][0] = d[x].m.a[0][1] = d[x].m.a[0][2] = d[x].m.a[1][0] = d[x].m.a[1][1] = d[x].m.a[1][2] = -N;
    d[x].m.a[2][0] = 0;
    d[x].m.a[2][1] = 0;
    d[x].m.a[2][2] = 0;
}

int cnt, nw[N];
void dfs2(int st, int top)
{
    nw[++ cnt] = st;
    d[st].dfn = cnt;
    d[st].top = top;
    d[st].low = st;
    d[st].s0.insert(-1);
    d[st].s1.insert(0);
    if(!d[st].son)
    {
        update_leaf(st);
        return;
    }
    dfs2(d[st].son, top);
    d[st].low = d[d[st].son].low;
    for(auto ed : e[st])
    {
        if(ed == d[st].fa || ed == d[st].son)
            continue;
        dfs2(ed, ed);
        d[st].s0.insert(f[ed][0]);
        d[st].s1.insert(f[ed][1]);
    }
    update(st);
}

struct SGT
{
    tree t[N * 4];

    void pushup(int p) { t[p].m = t[p << 1].m * t[p << 1 | 1].m; }

    void build(int p, int l, int r)
    {
        t[p].l = l;
        t[p].r = r;
        if(l == r)
        {
            t[p].m = d[nw[l]].m;
            return;
        }
        int mid = (l + r) / 2;
        build(p << 1, l, mid);
        build(p << 1 | 1, mid + 1, r);
        pushup(p);
    }
    
    void change(int p, int k)
    {
        if(t[p].l == t[p].r)
        {
            t[p].m = d[nw[k]].m;
            return;
        }
        int mid = (t[p].l + t[p].r) / 2;
        if(k <= mid)
            change(p << 1, k);
        else
            change(p << 1 | 1, k);
        pushup(p);
    }

    matrix ask(int p, int l, int r)
    {
        if(l <= t[p].l && t[p].r <= r)
            return t[p].m;
        int mid = (t[p].l + t[p].r) / 2;
        if(r <= mid)
            return ask(p << 1, l, r);
        if(l > mid)
            return ask(p << 1 | 1, l, r);
        matrix lef = ask(p << 1, l, r), rig = ask(p << 1 | 1, l, r);
        return lef * rig;
    }
};
SGT t;

void change(int x)
{
    if(d[x].w)
    {
        d[x].w = 0;
        if(d[x].son)
            d[x].s0.erase(d[x].s0.find(-1)),
            d[x].s1.erase(d[x].s1.find(0)),
            update(x);
        else
            update_leaf(x);
    }
    else
    {
        d[x].w = 1;
        if(d[x].son)
            d[x].s0.insert(-1),
            d[x].s1.insert(0),
            update(x);
        else
            update_leaf(x);
    }
    while(x)
    {
        matrix bef = t.ask(1, d[d[x].top].dfn, d[d[x].low].dfn);
        t.change(1, d[x].dfn);
        if(d[x].top != 1)
        {
            matrix aft = t.ask(1, d[d[x].top].dfn, d[d[x].low].dfn);
            d[d[d[x].top].fa].s0.erase(d[d[d[x].top].fa].s0.find(bef.a[0][0]));
            d[d[d[x].top].fa].s1.erase(d[d[d[x].top].fa].s1.find(bef.a[1][0]));
            d[d[d[x].top].fa].s0.insert(aft.a[0][0]);
            d[d[d[x].top].fa].s1.insert(aft.a[1][0]);
            update(d[d[x].top].fa);
        }
        x = d[d[x].top].fa;
    }
}

int n, m;

signed main()
{
    cin >> n;
    for(int i = 1, x, y; i <= n - 1; i = i + 1)
    {
        cin >> x >> y;
        e[x].push_back(y);
        e[y].push_back(x);
    }
    dfs1(1, 0, 1);
    dfs2(1, 1);
    t.build(1, 1, n);
    cin >> m;
    for(int i = 1; i <= m; i = i + 1)
    {
        char c;
        cin >> c;
        if(c == 'C')
        {
            int x;
            cin >> x;
            change(x);
        }
        else
        {
            int res = t.ask(1, d[1].dfn, d[d[1].low].dfn).a[1][0];
            if(res >= 0)
                cout << res << "\n";
            else
                cout << "-1\n";
        }
    }
    return 0;
}
```

---

## 作者：KSkun (赞：1)

本题我采用边分治的做法，可以说是和QTREE4基本相同了，因此可以参见QTREE4的题解：[题解 SP2666 【QTREE4 - Query on a tree IV】 - KSkun's Blog - 洛谷博客](https://kskun.blog.luogu.org/solution-sp2666)

下面的内容是从那篇题解复制过来的。

# 题解

我们在中心边位置维护两个堆，一个表示左边子树的各个白点距离，一个表示右边子树的。单独维护每个分治结构的答案，我们可以在一个统计最大值的时候顺带把子分治结构的最大值也计算进来，这样询问的时候只需要询问根分支结构的答案即可。在加点的的过程中，记录下这个点会影响到的堆的数据。变白要把这个点放进堆里，变黑只需要打标记。而每一次更新答案的时候，从堆顶把黑点全扔掉就好。如果用数组/vector来存的话，这个更新要根据倒序，因此倒序才是分治结构从底向根的顺序。

# 代码
可以直接抄QTREE4的代码。

---


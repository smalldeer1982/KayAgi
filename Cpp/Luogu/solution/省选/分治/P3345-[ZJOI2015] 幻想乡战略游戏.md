# [ZJOI2015] 幻想乡战略游戏

## 题目背景

## 警告，滥用本题者将被封号。

## 题目描述

傲娇少女幽香正在玩一个非常有趣的战略类游戏，本来这个游戏的地图其实还不算太大，幽香还能管得过来，但是不知道为什么现在的网游厂商把游戏的地图越做越大，以至于幽香一眼根本看不过来，更别说和别人打仗了。

在打仗之前，幽香现在面临一个非常基本的管理问题需要解决。

整个地图是一个树结构，一共有 $n$ 块空地，这些空地被 $n-1$ 条带权边连接起来，使得每两个点之间有一条唯一的路径将它们连接起来。

在游戏中，幽香可能在空地上增加或者减少一些军队。同时，幽香可以在一个空地上放置一个补给站。如果补给站在点 $u$ 上，并且空地 $v$ 上有 $d_v$ 个单位的军队，那么幽香每天就要花费 $d_v \times \text{dist}(u,v)$ 的金钱来补给这些军队。由于幽香需要补给所有的军队，因此幽香总共就要花费为 $\sum (d_v \times \text{dist}(u,v))$（其中 $1 \leq v \leq N$）的代价，$\text{dist}(u,v)$ 表示 $u$ 和 $v$ 在树上的距离（唯一路径的权和）。

因为游戏的规定，幽香只能选择一个空地作为补给站。在游戏的过程中，幽香可能会在某些空地上制造一些军队，也可能会减少某些空地上的军队，进行了这样的操作以后，出于经济上的考虑，幽香往往可以移动他的补给站从而省一些钱。但是由于这个游戏的地图是在太大了，幽香无法轻易的进行最优的安排，你能帮帮她吗？

你可以假定一开始所有空地上都没有军队。

## 说明/提示

对于所有数据，$1\le c\le 10^3$，$0\le |e| \le 10^3$，$1\le n\le10^5$，$ 1\le Q\le10^5$ 。

非常神奇的是，对于所有数据，这棵树上的点的度数都不超过 $20$。

## 样例 #1

### 输入

```
10 5
1 2 1
2 3 1
2 4 1
1 5 1
2 6 1
2 7 1
5 8 1
7 9 1
1 10 1
3 1
2 1
8 1
3 1
4 1```

### 输出

```
0
1
4
5
6```

# 题解

## 作者：kai586123 (赞：69)

其他题解都是动态点分治，这篇题解是用**线段树+树剖**的。

欢迎来我的Blog来看：[[ZJOI2015] 幻想乡战略游戏](https://baka.online/zjoi2015-%e5%b9%bb%e6%83%b3%e4%b9%a1%e6%88%98%e7%95%a5%e6%b8%b8%e6%88%8f/)


---

先上个复杂度吧：修改$O(nlog^2n)$，查询$O(nlogn)$，截止到发题解是最优解第二名

**一个结论： 本题中，重心位置和点权，边权无关**

看起来不可思议吧。

证明：

我们可以换一种方式计算答案。枚举边$edge_i$，这条边把树分为两部分。它的两端点是$x_i,y_i$，两子树的大小为$size_x,size_y$，那么有：

$$ans=\sum edge_i * size_x * size_y$$

通过直接构造出重心位置，并证明其它位置不比它更优证明结论：

在树上选一个点，使得它最大的子树大小（子树内军队数量）最小。这个点就是重心。

可以任选一个其它点，计算出以这个点为补给站的答案。考虑把选择的点向重心移动一条边对答案的影响。这条边是$edge$，两边为$x,y$，大小分别为$size_x,size_y$。从$x$走到$y$。

由推导出的新计算式，只有移动经过的这条边对答案产生的贡献发生了变化，是：

$$-edge * size_y + edge * size_x$$

显然，因为这个点不在我们选出的重心，$size_y$不可能小于$size_x$，即，让答案更优了。

实际上，这个点和普通不带权树的重心位置一样。

**快速找到重心**

在树上找到一个点$x$，满足$size_{root} \leq size_x * 2$，且$x$最深。

这个结合普通树重心性质很容易得出。

线段树叶子维护子树大小，其他节点维护线段树上子节点大小最大值。查询的时候在线段树上二分。

**求答案**

$$ans=\sum dis(x,y) * e(y)$$

$$=\sum (dis(x,root)+dis(y,root)-2* dis(lca,root)) * e(y)$$

$$=\sum dis(x,root)* e(y) + \sum dis(y,root) * e(y) $$
$$ -2\sum dis(lca,root) * e(y)$$

前两个随便维护，重点是第三个。

令点权为$w_x=edge(x,fa(x))$，每次修改一个点的时候，就把它到根的大小$size$全部加上修改的值。查询重心到根，每个点$size_x * w_x$。

这是因为两个点到lca到根的路径，是两个点到根的共同路径。

```cpp
#include <bits/stdc++.h>
typedef long long LL;

inline int rd() {
	int a = 1, b = 0; char c = getchar();
	while (!isdigit(c)) a = c == '-' ? 0 : 1, c = getchar();
	while (isdigit(c)) b = b * 10 + c - '0', c = getchar();
	return a ? b : -b;
}

const int N = 1e5 + 233;
int n, m;

struct Graph { int to, nxt, cost; } g[N * 2];
int head[N], tot;

inline void addedge(int x, int y, int c) {
	g[++tot].to = y, g[tot].nxt = head[x],
	g[tot].cost = c, head[x] = tot;
}

int fa[N], son[N], size[N], dep[N], dis[N];
int top[N], id[N], wh[N], wt[N], num;

void dfs1(int x) {
	for (int i = head[x]; i; i = g[i].nxt) {
		int y = g[i].to;
		if (y != fa[x]) {
			fa[y] = x; dep[y] = dep[x] + 1;
			dis[y] = dis[x] + g[i].cost;
			size[y] = 1;
			dfs1(y);
			if (size[son[x]] < size[y])
				son[x] = y;
			size[x] += size[y];
		}
	}
}

void dfs2(int x, int topf) {
	top[x] = topf; id[x] = ++num; wh[num] = x;
	wt[num] = dis[x] - dis[fa[x]];
	if (son[x]) {
		dfs2(son[x], topf);
		for (int i = head[x]; i; i = g[i].nxt) {
			int y = g[i].to;
			if (y != fa[x] && y != son[x])
				dfs2(y, y);
		}
	}
}

#define ls(p) p << 1
#define rs(p) p << 1 | 1

int sz[N * 4], tag[N * 4];
LL edge[N * 4], sum[N * 4];

void build(int p, int L, int R) {
	if (L == R) {
		edge[p] = wt[L];
		return;
	}
	int mid = (L + R) >> 1;
	build(ls(p), L, mid);
	build(rs(p), mid + 1, R);
	edge[p] = edge[ls(p)] + edge[rs(p)];
}

inline void pushup(int p) {
	sz[p] = std::max(sz[ls(p)], sz[rs(p)]);
	sum[p] = sum[ls(p)] + sum[rs(p)];
}

inline void pushdown(int p) {
	if (tag[p]) {
		sz[ls(p)] += tag[p];
		sz[rs(p)] += tag[p];
		tag[ls(p)] += tag[p];
		tag[rs(p)] += tag[p];
		sum[ls(p)] += (LL)tag[p] * edge[ls(p)];
		sum[rs(p)] += (LL)tag[p] * edge[rs(p)];
		tag[p] = 0;
	}
}

void add(int p, int l, int r, int v, int L, int R) {
	if (l <= L && r >= R) {
		sz[p] += v; tag[p] += v;
		sum[p] += (LL)v * edge[p];
		return;
	}
	pushdown(p);
	int mid = (L + R) >> 1;
	if (l <= mid)
		add(ls(p), l, r, v, L, mid);
	if (r > mid)
		add(rs(p), l, r, v, mid + 1, R);
	pushup(p);
}

LL query(int p, int l, int r, int L, int R) {
	if (l <= L && r >= R)
		return sum[p];
	pushdown(p);
	int mid = (L + R) >> 1;
	LL ret = 0;
	if (l <= mid)
		ret += query(ls(p), l, r, L, mid);
	if (r > mid)
		ret += query(rs(p), l, r, mid + 1, R);
	return ret;
}

inline int weight() {
	int p = 1, L = 1, R = n;
	while (L < R) {
		pushdown(p);
		int mid = (L + R) >> 1;
		if (sz[rs(p)] * 2 >= sz[1])
			L = mid + 1, p = rs(p);
		else R = mid, p = ls(p);
	}
	return wh[L];
}

inline void range_add(int x, int y) {
	while (top[x] != 1) {
		add(1, id[top[x]], id[x], y, 1, n);
		x = fa[top[x]];
	}
	add(1, 1, id[x], y, 1, n);
}

inline LL range_query(int x) {
	LL ret = 0;
	while (top[x] != 1) {
		ret += query(1, id[top[x]], id[x], 1, n);
		x = fa[top[x]];
	}
	return ret + query(1, 1, id[x], 1, n);
}

LL sum_dis_e, sum_e;

inline LL getans(int x) {
	return sum_dis_e + dis[x] * sum_e - 2 * range_query(x);
}

int main() {
	n = rd(); m = rd();
	for (int i = 1; i < n; ++i) {
		int x = rd(), y = rd(), c = rd();
		addedge(x, y, c);
		addedge(y, x, c);
	}
	
	dfs1(1); dfs2(1, 1);
	build(1, 1, n);
	
	while (m--) {
		int x = rd(), y = rd();
		sum_e += y;
		sum_dis_e += (LL)dis[x] * y;
		range_add(x, y);
		printf("%lld\n", getans(weight()));
	}
	return 0;
}
```



---

## 作者：xyz32768 (赞：65)

看到数据范围和6s的时限，得(cai)出是一道动态点分治。

这道题有一个巧妙的思路：

假设当前补给站为$u$，并强制以$u$为根，$v$为$u$的一个子节点，$sumd_u$和$sumd_v$分别为$u$的子树内的$d$之和以及$v$的子树内的$d$之和，$len(u,v)$为边$(u,v)$的长度。

如果将补给站迁移到点$v$，那么$v$的子树内的点到补给站的距离减少了$len(u,v)$，其他的点到补给站的距离增加了$len(u,v)$。也就是说，补给站迁移到点$v$时，代价的**增量**为：

$$len(u,v)\times(sumd_u-sumd_v-sumd_v)$$

整理一下，得出性质：$u$为根，$v$为$u$的子节点，补给站在$v$比$u$优，当且仅当：

$$2\times sumd_v>sumd_u$$

显然满足条件的$v$最多只有一个。

这时候，如果没有满足条件的$v$，则$u$为最优位置。否则最优位置在$v$的**子树内**。

考虑动态点分治时每个点维护$d$，$sumd$，$sumpd$三个值，分别表示：

$d_u$：点$u$的$d$值。

$sumd_u$：点$u$的子树内所有的$d$值之和。

$sumpd_u$：如果$u$为根，则该值等于树中所有点$v$的$dis(v,u)\times d_v$之和，否则等于$u$的子树内所有点$v$的$dis(v,fa_u)\times d_v$之和。

（$dis(a,b)$为$a$和$b$两点在**原树**中的距离，$fa_u$为点$u$在**分治树**上的父节点）

修改比较简单，从$u$开始不断地往$fa_u$更新三个值即可。

询问时，先把最优解暂定为分治树的根节点。

假设现在到了点$u$的分治子树，并且发现最优解在$v$的分治子树内（$v$为$u$在分治树上的一个子节点，原树上有边$(u,w)$并且$w$在$v$的分治子树内）

则可以转移到$v$的分治子树内求解。

首先计算出$u$的分治子树内**（除$v$的分治子树内的点之外）**的所有点到$w$的$dis\times d$之和（可以使用$sumpd$计算得出），这样$v$的分治子树**之外节点**的影响就计算好了。

此外，还要考虑节点$w$的影响因素：实际上对于$u$的分治子树内但在$v$的分治子树之外的一个点$k$，上面的计算只是计算好了$w->k$这一段路径的影响，而$v->w$这一段路径的影响还没就算出来。所以，还需要把$d_w$加上$sumd_u-sumd_v$（对应的$sumd$和$sumpd$也要跟着调整），这样就处理好了$v->w$这一段路径的影响。这样就能进入$v$的分治子树进行求解了。但$v$的分治子树求解完毕后，还需要把$d_w$恢复原值。

最好要使用RMQ求LCA来查询两点距离。

复杂度$O(n\log^2n)$（设$n,q$同阶）

~~第一次写动态点分治，调了一整个下午~~

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define For(i, a, b) for (i = a; i <= b; i++)
#define Edge(u) for (int e = adj[u], v; e; e = nxt[e])
#define Edge2(u) for (int e = adj2[u], v; e; e = nxt2[e])
using namespace std;
inline int read() {
	int res = 0; bool bo = 0; char c;
	while (((c = getchar()) < '0' || c > '9') && c != '-');
	if (c == '-') bo = 1; else res = c - 48;
	while ((c = getchar()) >= '0' && c <= '9')
		res = (res << 3) + (res << 1) + (c - 48);
	return bo ? ~res + 1 : res;
}
typedef long long ll;
const int N = 1e5 + 5, M = N << 1, LogN = 22;
int n, q, ecnt, nxt[M], adj[N], go[M], val[M], sze[N], maxs[N], G,
dep[N], dis[N], m, a[M], Log[M], RMQ[M][LogN], fir[N], fa[N],
Root, ecnt2, nxt2[N], adj2[N], go2[N], sc2[N];
ll d[N], sumd[N], sumpd[N];
bool vis[N];
void add_edge(int u, int v, int w) {
	nxt[++ecnt] = adj[u]; adj[u] = ecnt; go[ecnt] = v; val[ecnt] = w;
	nxt[++ecnt] = adj[v]; adj[v] = ecnt; go[ecnt] = u; val[ecnt] = w;
}
void add_edge2(int u, int v, int w) {
	nxt2[++ecnt2] = adj2[u]; adj2[u] = ecnt2; go2[ecnt2] = v; sc2[ecnt2] = w;
}
void dfs(int u, int fu) {
	dep[u] = dep[fu] + 1; a[fir[u] = ++m] = u;
	Edge(u) {
		if ((v = go[e]) == fu) continue;
		dis[v] = dis[u] + val[e]; dfs(v, u); a[++m] = u;
	}
}
void initRMQ()
{
	int i, j; For (i, 1, m) RMQ[i][0] = a[i];
	For (j, 1, 18) For (i, 1, m - (1 << j) + 1) {
		int x = RMQ[i][j - 1], y = RMQ[i + (1 << j - 1)][j - 1];
		RMQ[i][j] = dep[x] < dep[y] ? x : y;
	}
}
int dist(int u, int v) {
	int l = fir[u], r = fir[v]; if (l > r) swap(l, r);
	int x = Log[r - l + 1], r1 = RMQ[l][x], r2 = RMQ[r - (1 << x) + 1][x];
	int lca = dep[r1] < dep[r2] ? r1 : r2;
	return dis[u] + dis[v] - (dis[lca] << 1);
}
void dfs1(int u, int fu) {
	sze[u] = 1; for (int e = adj[u], v; e; e = nxt[e]) {
		if ((v = go[e]) == fu || vis[v]) continue;
		dfs1(v, u); sze[u] += sze[v];
	}
}
void dfs2(int r, int u, int fu) {
	maxs[u] = sze[r] - sze[u]; Edge(u) {
		if ((v = go[e]) == fu || vis[v]) continue;
		maxs[u] = max(maxs[u], sze[v]);
	}
	if (maxs[u] < maxs[G]) G = u;
	Edge(u) if ((v = go[e]) != fu && !vis[v]) dfs2(r, v, u);
}
void calcG(int u) {dfs1(u, 0); G = u; dfs2(u, u, 0);}
int dfs3(int u, int fu) {
	calcG(u); if (!Root) Root = G; vis[G] = 1; fa[G] = fu; int t = G;
	Edge(G) {
		if (vis[v = go[e]]) continue;
		int w = dfs3(v, t); add_edge2(t, w, v);
	}
	return t;
}
void change(int u, int delta) {
	int v = u; d[u] += delta; while (u) {
		sumd[u] += delta;
		sumpd[u] += 1ll * delta * dist(v, fa[u] ? fa[u] : u);
		u = fa[u];
	}
}
ll exc(int u, int w, int x) {
	ll ans = 0, cnt = d[u];
	Edge2(u) if ((v = go2[e]) != w) ans += sumpd[v], cnt += sumd[v];
	d[x] += cnt; return ans + cnt * dist(u, x);
}
ll query(ll ans, int u) {
	Edge2(u) if ((sumd[v = go2[e]] << 1) > sumd[u]) {
		ll wr = d[sc2[e]], tmp, delta = exc(u, v, sc2[e]);
		tmp = d[sc2[e]] - wr; for (int w = sc2[e]; w != u; w = fa[w])
			sumd[w] += tmp, sumpd[w] += tmp * dist(sc2[e], fa[w] ? fa[w] : w);
		ll nans = 0; for (int z = adj2[v]; z; z = nxt2[z]) nans += sumpd[go2[z]];
		ans = delta + query(nans, v); for (int w = sc2[e]; w != u; w = fa[w])
			sumd[w] -= tmp, sumpd[w] -= tmp * dist(sc2[e], fa[w] ? fa[w] : w);
		d[sc2[e]] = wr; return ans;
	}
	return ans;
}
int main() {
	int i, x, y, z; n = read(); q = read(); Log[0] = -1;
	For (i, 1, n << 1) Log[i] = Log[i >> 1] + 1;
	For (i, 1, n - 1)
		x = read(), y = read(), z = read(), add_edge(x, y, z);
	dfs(1, 0); initRMQ(); dfs3(1, 0); while (q--) {
		x = read(); y = read(); change(x, y);
		printf("%lld\n", query(sumpd[Root], Root));
	}
	return 0;
}
```

---

## 作者：zcysky (赞：47)

这题可以用线段树做，不过正解恐怕是动态点分治？（点分树）

简单介绍下动态点分治的概念：在点分治的过程中，一般我们面对的问题都是静态的。如果涉及到修改这类的操作，我们就希望找到我们是如何处理到当前的修改点的，换而言之，我们希望记录下点分治的过程，这样可以通过爬点分树等操作消除影响。

对于每个节点我们保存这个子树的dv的总和已经把该节点作为点的答案值

这样对于修改能在log n的时间内解决


寻找答案的时候，我们可以发现，如果现在节点的子树dv和\*2大于总节点，那么向那个方向过去一定比原方案好


我们先从根节点开始，若发现答案在某棵子树时，我们考虑如何使其儿子节点的答案转变为整个树的答案，可以发现把除这个子树外的所有节点可以缩成一个节点并连在这棵子树上，然后就可以一直这样做下去，找到操作之后再把这些撤销。

下面是咸鱼给出的一些实现细节：

1.跟虚树一样（不知道的可以百度“世界树”），这也是要在第二棵树上对原树进行统计，所以一定千万小心不要弄混，我学到的办法是对原树进行封装，这样即使不小心访问错了他也会给你提示。

2.对树进行欧拉序遍历可以利用rmq在O(1)查询LCA，这点也是特别好懂的。（只会树剖的蒟蒻瑟瑟发抖）

代码总共113行，可读性也不错呢~~

应该是目前比较能看的点分树代码之一吧（至少我在CSDN之类的地方找到的都很长呀）

```cpp
#include<bits/stdc++.h>
#define N 100010
typedef long long ll;
using namespace std;
int n,m,x,y,z,size[N],tot;
int head[N],sum,rt,f[N],vis[N],par[N],cnt,lg[N<<2];
ll dis1[N],dis2[N],sumv[N];
struct Edge{int u,v,next,w;}G[2*N];
void Addedge(int u,int v,int w){
    G[++tot].u=u;G[tot].v=v;G[tot].w=w;G[tot].next=head[u];head[u]=tot;
}
struct Orinal_Tree{
    int head[N],cnt,tot;
    int st[N<<2][21],dis[N],tpos[N<<1];
    struct edge{int u,v,next,w;}E[2*N];
    inline void addedge(int u,int v,int w){
        E[++tot].u=u;E[tot].v=v;E[tot].w=w;E[tot].next=head[u];head[u]=tot;
        E[++tot].u=v;E[tot].v=u;E[tot].w=w;E[tot].next=head[v];head[v]=tot;
    }
    inline int getdis(int u,int v){
        if(tpos[u]>tpos[v])swap(u,v);
        int k=lg[tpos[v]-tpos[u]+1];
        return dis[u]+dis[v]-2*min(st[tpos[u]][k],st[tpos[v]-(1<<k)+1][k]);
    }
    void dfs(int u,int fa){
        st[++cnt][0]=dis[u];tpos[u]=cnt;
        for(int i=head[u];i;i=E[i].next){
            int v=E[i].v;if(v==fa)continue;
            dis[v]=dis[u]+E[i].w;
            dfs(v,u);
            st[++cnt][0]=dis[u];
        }
    }
    inline void initrmq(){
        memset(tpos,0,sizeof(tpos));cnt=0;tot=0;dis[1]=0;
        dfs(1,0);
        for(int j=1;(1<<j)<=cnt;j++)
        for(int i=1;i+(1<<j)-1<=cnt&&i<=cnt;i++)
        st[i][j]=min(st[i][j-1],st[i+(1<<(j-1))][j-1]);
    }
}T;
void getroot(int u,int fa){
    size[u]=1;f[u]=0;
    for(int i=T.head[u];i;i=T.E[i].next){
        int v=T.E[i].v;if(vis[v]||v==fa)continue;
        getroot(v,u);size[u]+=size[v];
        f[u]=max(f[u],size[v]);
    }
    f[u]=max(f[u],sum-size[u]);
    if(f[u]<f[rt])rt=u;
}
void work(int u,int fa){
    vis[u]=1;par[u]=fa;//printf("%d\n",u);puts("!!!");
    for(int i=T.head[u];i;i=T.E[i].next){
        int v=T.E[i].v;if(vis[v])continue;
        sum=size[v];f[0]=size[v];rt=0;
        getroot(v,0);Addedge(u,rt,v);
        work(rt,u);
    }
}
inline void ins(int u,int val){
    sumv[u]+=val;
    for(int i=u;par[i];i=par[i]){
        int dist=T.getdis(par[i],u);
        dis1[par[i]]+=(ll)dist*val;
        dis2[i]+=(ll)dist*val;
        sumv[par[i]]+=val;
    }
}
inline ll calc(int u){
    ll ans=dis1[u];
    for(int i=u;par[i];i=par[i]){
        int dist=T.getdis(par[i],u);
        ans+=dis1[par[i]]-dis2[i];
        ans+=dist*(sumv[par[i]]-sumv[i]);
    }
    return ans;
}
ll query(int u){
    ll ans=calc(u);//printf("%lld\n",ans);
    for(int i=head[u];i;i=G[i].next){
        ll tmp=calc(G[i].w);
        if(tmp<ans)return query(G[i].v);
    }
    return ans;
}
inline int read(){
    int f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
void init(){
    memset(dis1,0,sizeof(dis1));
    memset(dis2,0,sizeof(dis2));
    memset(sumv,0,sizeof(sumv));
    lg[0]=-1;
    for (int i=1;i<(N<<2);i++)lg[i]=lg[i>>1]+1;
    n=read();m=read();//printf("%d %d\n",n,m);
    for (int i=1;i<n;i++)
    x=read(),y=read(),z=read(),T.addedge(x,y,z);
}
int main(){
    init();T.initrmq();sum=n;f[0]=n;
    rt=0;getroot(1,0);
    int LastOrder=rt;work(rt,0);rt=LastOrder;
    //for(int i=1;i<=20;i++)//printf("%d ",T.head[i]);puts("");
    for(int i=1;i<=m;i++){
        x=read();y=read();ins(x,y);
        printf("%lld\n",query(rt));
    }
    return 0;
}
```

---

## 作者：Su_Zipei (赞：32)

看了一上午的题解才勉强看懂，然后还没有按照我看的那篇题解的思路去写。。。。

首先考虑要干什么，不难发现这就是求一个带权重心，这一部分的推导大部分题解都说的很明白所以不再详细叙述。

有一个暴力的做法是以一个点为根，向儿子不断扩展，这样显然会TLE，考虑怎么优化，容易发现这样做时间复杂度是和最大深度有关系的，只要控制好最大深度那么就可以继续使用上述的暴力算法。

如果当前点不是带权重心，那么存在且仅存在一个儿子使得从当前点走向它会更优，而确定了这个儿子之后，带权重心一定在这个儿子的子树里边，所以可以使用点分治，由于有多组询问，考虑使用i点分树。

用点分树做一些事情就比较方便，首先点分树的最大深度是 $log$ 级别的，于是可以暴力往下走，其次可以通过暴力跳父亲来做到更新数组，但是缺点就是走向一个儿子的子树之后会丢失掉某些信息，大部分题解是通过将位于该点子树外的信息合并到那个儿子上最后在回溯时撤销，本质上是做了一个换根，由于wtcl了花了很长时间才理解并且发现实现略有困难所以想到了另外一个解法。

因为最优决策儿子如果存在那么只会存在一个，所以可以暴力算出每一个儿子作为根时的答案与当前点作为根时的答案做比较，点分树的深度是 $log$ 的所以暴力跳父亲做可行。

问题转化成已知一个点求树上所有点到这个点的带权距离，几乎就成了点分树的模板了。

时间复杂度$O(nlog^2n\times 20)$，可以通过，但是貌似常数有点大或者是我写丑了，由于使用了不少 $STL$ 所以不开 $O2$ 会 $T$ 飞。

```cpp


#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>
#include<unordered_map>
using namespace std;
const int N=1e5+10;
#define rint register int
#define rll register long long
typedef long long ll;
vector<int> vec[N];
unordered_map<int,ll> dis[N];
struct Edge{
	int to,nxt,val;
}e[N<<1];
int h[N],idx;
void Ins(rint a,rint b,rint c){
	e[++idx].to=b;e[idx].nxt=h[a];
	h[a]=idx;e[idx].val=c;
}
int Max[N],siz[N],Tsiz,rt;
bool vis[N];
void getrt(rint u,rint fa){
	siz[u]=1;Max[u]=0;
	for(rint i=h[u];i;i=e[i].nxt){
		rint v=e[i].to;
		if(v==fa||vis[v])continue;
		getrt(v,u);
		siz[u]+=siz[v];
		Max[u]=max(Max[u],siz[v]);
	}
	Max[u]=max(Max[u],Tsiz-siz[u]);
	if(Max[rt]>Max[u])rt=u;
}
void calc(rint u,rint fa,rint r){
	siz[u]=1;
	for(rint i=h[u];i;i=e[i].nxt){
		rint v=e[i].to;
		if(v==fa||vis[v])continue;
		dis[r][v]=dis[r][u]+e[i].val;
		calc(v,u,r);
		siz[u]+=siz[v];
	}
}
int pre[N],fa[N];
ll sd[N],s1[N],s2[N];
void dfs(rint x){
	vis[x]=1;dis[x][x]=0;
	calc(x,0,x);
	for(rint i=h[x];i;i=e[i].nxt){
		rint v=e[i].to;
		if(vis[v])continue;
		Tsiz=siz[v];rt=0;
		getrt(v,x);
		vec[x].push_back(rt);
		fa[rt]=x,pre[rt]=v;
		dfs(rt);
	}
}
// sd The sumd of subtree
// s1 The wsum to np
// s2 The wsum to fa-np
void update(rint x,rint v){
	for(rint i=x;i;i=fa[i]){
		sd[i]+=v;
		s1[i]+=dis[i][x]*v;
		if(fa[i])s2[i]+=dis[fa[i]][x]*v;
	}
}
ll get(rint x){
	rll res=s1[x];
	for(rint i=x;fa[i];i=fa[i])
		res+=s1[fa[i]]-s2[i]+dis[fa[i]][x]*(sd[fa[i]]-sd[i]);
	return res;
}
ll query(rint x){
	rll now=get(x);
	for(rint v:vec[x]){
		rll wv=get(pre[v]);
		if(wv<now)return query(v);
	}
	return now;
}
int main(){
//	freopen("data.in","r",stdin);
	rint n,m;
	scanf("%d%d",&n,&m);
	for(rint i=2;i<=n;i++){
		rint a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		Ins(a,b,c);Ins(b,a,c);
	}
	Max[0]=1e9;
	Tsiz=n;
	getrt(1,0);
	rint st=rt;
	dfs(rt);
	while(m--){
		rint x,e;
		scanf("%d%d",&x,&e);
		update(x,e);
		printf("%lld\n",query(st));
	}
	return 0;
}

```


---

## 作者：shadowice1984 (赞：21)

点分树上二分找带权重心……

写起来还是非常精神污染的

另外我觉得这个常数非常的魔幻，为什么$O(nlog^2n)$就跑了500ms啊……

___________________

# 本题题解

### 前置芝士:点分树

首先你得确保你了解点分树是什么以及如何在点分树上查找一个点到树上所有点的距离。另外你需要注意的是点分树唯二的性质是点分树上两点的lca一定在原树两点的路径上以及点分树的一个子树总是原树上的一个联通块，除此之外点分树和原树的联系相当的微小，基本可以看做没有联系，所以在做点分树的题的时候一定不要想当然

___________________________________

那么下面我们来讲解一下点分树上一个非常重要的技巧：点分树上二分寻找某种关键点

那么就以这道题为例吧

首先可以证明的是我们的补给点就是树上的带权重心，即删掉这个点之后各个子树的带权size至多为原树上总size的一半。

证明过程的话可以考虑这样一个有点贪心的证明方式

假如说我们选择的点不是带权重心而是另外一个其他的点，那么可以证明这个点一定有一个带权size过半的子树，此时我们将决策点挪到这个过半子树的根上我们会发现我们的代价变化量是$val×(tot-2size)$其中size是我们这个过半子树的size

发现这个变化量总是负的，只有带权重心不会存在这个可以挪过去的点

问题来了会不会有多个带权重心？答案是否定的，带权重心只有一个，因此我们贪心的证明了带权重心就是最优决策点

当然上述的证明我们也给出了一种暴力算法，随便找树上的一个点作为起始点，然后每次贪心的选取一条边移动，最终总是可以找到这个带权重心的

当然你的复杂度显然是单次$O(n)$的如果在链上的话你会发现他有点像线性搜索算法，因此我们考虑吧这个线性搜索算法改成二分算法

但是我们会发现我们之前的贪心算法失效了，因为我们不能考虑答案的改变量来决定我们向点分树的哪个子树去走，因为我们会发现一个非常难受的事实就是我们的点分树可能会长成这样(原树是一条链)

![](https://cdn.luogu.com.cn/upload/pic/20101.png)

图中绿色点是我们的最优决策点

但是我们从点分树的树根出发的时候将会经过红色的边，这一步的决策是非常劣的……，但是为了可以成功二分我们又不得不经过这个红色的边

因此我们先在点分树上二分出最优决策点然后最后使用点分树询问这个最优决策点到树上所有点的带权距离即可

那么假设我们从点分树的根出发然后寻找最优的决策点在哪一个子联通块当中，那么显然在根的时候决策十分trival，找size最大的子联通块进去就行了,对于每个子联通块的size我们可以每个节点暴力开一个vector记录

问题来了，我们在递归下去的时候我们不能简单的找size最大的子联通块进去，因为我们需要考虑这个子联通块外部点的带权size

解决方法是把外部的点强行缩成一个点，设这个外部联通块对这个子联通块的“接入点”为i，然后强行增加这个接入点的点权，注意，这个接入点有非常大的概率不是子重心，比如上边这个图，绿色点是根节点对于左儿子的接入点，但是绿色点不是左儿子的子重心

什么？怎么接入点权？点分树上暴力修改即可

那么问题又来的，我们怎么消除这个点的影响？你把二分函数写成递归的函数，然后在回溯的时候手动消掉即可了

那么我们接下来要做到就是询问决策到树上其他所有点的距离了，这个可以方便的使用点分树来暴力记录

代码其实还是非常好写的~

上代码~

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;const int N=1e5+10;typedef long long ll;
int v[2*N];int x[2*N];int val[2*N];int al[N];int ct;ll wtot;int rt;int itr[N];
bool book[N];bool cut[N];int siz[N];int dep[N];ll wsiz[N];int hv[N];ll rel[N];
struct ed{int v;ll dis;};vector <ed> fa[N];vector <ed> s[N];int n;int m;
inline void add(int u,int V,int va){v[++ct]=V;x[ct]=al[u];al[u]=ct;val[ct]=va;}
int dfs1(int u)//处理siz
{
    book[u]=true;
    for(int i=al[u];i;i=x[i])if(!book[v[i]]&&!cut[v[i]])siz[u]+=dfs1(v[i]);
    book[u]=false;return siz[u];
}
int findg(int u,const int& tot)//找中心
{
    book[u]=true;int ret=u;
    for(int i=al[u];i;i=x[i])
        if(!book[v[i]]&&!cut[v[i]]&&2*siz[v[i]]>=tot){ret=findg(v[i],tot);break;}
    book[u]=false;return ret;
}
void dfs2(int u,const int& g)//预处理树上距离
{
    book[u]=true;fa[u].push_back((ed){g,dep[u]});
    for(int i=al[u];i;i=x[i])
    {
        if(book[v[i]]||cut[v[i]]){continue;}
        dep[v[i]]=dep[u]+val[i];dfs2(v[i],g);
    }book[u]=false;siz[u]=1;return;
}
inline void solve(int u,const int& f)//点分治建点分树
{
    dfs1(u);int g=findg(u,siz[u]);cut[g]=true;itr[g]=u;
    s[f].push_back((ed){g,0});fa[g].push_back((ed){g,0});
    for(int i=al[g];i;i=x[i])
        if(!cut[v[i]]){dep[v[i]]=val[i];dfs2(v[i],g);solve(v[i],g);}rt=g;
}
inline void modify(int u,int e)//修改树上距离的信息以及father的信息
{
    wtot+=e;int p=u;rel[u]+=e;
    for(int i=fa[u].size()-1;i>=0;i--){wsiz[fa[u][i].v]+=e;}
    for(int i=fa[u].size()-1;i>=0;p=fa[u][i].v,i--)
    {
        for(int f=fa[u][i].v,j=0;j<s[f].size();j++)
        if(s[f][j].v==p){s[f][j].dis+=e*fa[u][i].dis;break;}
    }
}
inline void modi(int u,int e){for(int i=0;i<fa[u].size();i++){wsiz[fa[u][i].v]+=e;}}//暴力修改点权
inline int find(int u)//树上二分
{
    int ret=u;
    for(int i=0;i<s[u].size();i++)
    {
        if(wsiz[s[u][i].v]*2>=wtot)
        {
            int del=wsiz[u]-wsiz[s[u][i].v];//修改接入点的点权
            modi(itr[s[u][i].v],del);ret=find(s[u][i].v);modi(itr[s[u][i].v],-del);break;
        }
    }return ret;
}
inline ll query(int u)//暴力跳点分树询问树上距离
{
    ll ret=0;int p=u;
    for(int i=fa[u].size()-1;i>=0;p=fa[u][i].v,i--)
    {
        ret+=fa[u][i].dis*rel[fa[u][i].v];
        for(int f=fa[u][i].v,j=0;j<s[f].size();j++)
            if(s[f][j].v!=p){ret+=fa[u][i].dis*wsiz[s[f][j].v]+s[f][j].dis;}
    }return ret;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){siz[i]=1;}
    for(int i=1,u,v,va;i<n;i++){scanf("%d%d%d",&u,&v,&va);add(u,v,va);add(v,u,va);}
    solve(1,0);
    for(int i=1,u,e;i<=m;i++)
    {scanf("%d%d",&u,&e);modify(u,e);printf("%lld\n",query(find(rt)));}return 0;//拜拜程序~
}

```










---

## 作者：Ark_ (赞：20)

# 题意
树的结构不变,每个点有点权,每一条边有边权,有修改点权的操作,设$x$为树中一点.求$\sum_idist(x,i)*a[i]$的最小值
# 分析
我们把补给站叫做决策点,那么假设当前最优决策点为$u$.把$u$看作根节点,我们考虑将决策点从$u$转到儿子$v$,先假设$sum[i]$表示$i$子树内点权之和,那么减少的代价就是$sum[v]*len(u,v)$,增多的代价就为$(sum[u]-sum[v])*len(u,v)$

所以说$v$比$u$优,当且仅当

$sum[v]*len(u,v)>(sum[u]-sum[v])*len(u,v)$

也就是

$2*sum[v]>sum[u]$

不难发现,满足这个式子的儿子至多有一个.那么一个暴力的想法就是每次询问从根开始,往儿子下面走,如果不存在儿子比自己更优,那么自己就是决策点,否则就进入比自己优的儿子的子树.

这样每次询问的时间复杂度看似是$O(n)$的.但是实际上是$O(Maxdepth)$的.于是我们就有了想法,点分治不就是将深度减小为$O(logn)$了吗?我们把点分治中每一个重心的父亲设为上一层的重心,就在$O(nlogn)$的时间内构造了一棵点分树,这棵树的深度是$O(logn)$的,那么我们只需要在每个重心上维护子树信息,就可以在$O(logn)$的时间内求出把一个点当作决策点的答案,因为可以证明(但我不会)的是一对点在点分树中的$lca$一定存在于它们在原树上的路径,那么他们间的距离乘以点权只需要利用在$lca$上维护的子树信息来计算,具体方法就是一个点在点分树上往根节点跑,在路径上统计就能求出它作为决策点的答案(具体之后看代码).

我们将树的深度减小到了$O(logn)$,所以每次查询只需要从根节点(整棵树的重心)开始,看哪一个(原树中)儿子更优,如果优就往**儿子对应的子树的重心**上走.每一次查询时间复杂度是$O(20log^2n)$,一个$log$是要走的深度,一个$log$是求对应的答案,$20$是因为对于当前点$u$要计算所有儿子$v$作为决策点的值,题目中保证了一个点度数不超过$20$.而且因为是一旦搜到比自己优的儿子就去那一坨子树的重心,一般是跑不满$20$的.

再考虑修改,只用把自己在点分树中的祖先修改就行了,每一次时间复杂度$O(logn)$

实际上,每一次计算/修改都需要算两个点在原树上的距离,要求$lca$,可以用$dfs$序预处理$+O(1)RMQ$,从而整道题的时间复杂度为$O(20nlog^2n)$,而我比较懒,求$lca$用的树剖,严格来说是$O(20nlog^3n)$的,但是树剖大多数时候达不到$log$,而且$20$也跑不满,那么就能过了...

修改/计算具体看代码
# CODE
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long LL;
template<typename T>inline void read(T &num) {
	char ch; int flg = 1;
	while((ch=getchar())<'0'||ch>'9')if(ch=='-')flg=-flg;
	for(num=0;ch>='0'&&ch<='9';num=num*10+ch-'0',ch=getchar());
	num*=flg;
}
const int MAXN = 100005;
int n, q, fir[MAXN], cnt;
struct edge { int to, nxt, w; }e[MAXN<<1];
inline void add(int u, int v, int wt) {
	e[cnt] = (edge){ v, fir[u], wt }, fir[u] = cnt++;
	e[cnt] = (edge){ u, fir[v], wt }, fir[v] = cnt++;
}
int dis[MAXN], son[MAXN], sz[MAXN], top[MAXN], fa[MAXN], dep[MAXN];
void dfs(int u, int ff) {
	dep[u] = dep[fa[u]=ff] + (sz[u]=1);
	for(int i = fir[u], v; ~i; i = e[i].nxt)
		if((v=e[i].to) != ff) {
			dis[v] = dis[u] + e[i].w;
			dfs(v, u), sz[u] += sz[v];
			if(sz[v] > sz[son[u]]) son[u] = v;
		}
}
void dfs2(int u, int tp) {
	top[u] = tp;
	if(son[u]) dfs2(son[u], tp);
	for(int i = fir[u], v; ~i; i = e[i].nxt)
		if((v=e[i].to) != fa[u] && v != son[u])
			dfs2(v, v);
}
int lca(int u, int v) { //
	while(top[u] != top[v]) {
		if(dep[top[u]] < dep[top[v]]) swap(u, v);
		u = fa[top[u]];
	}
	return dep[u] < dep[v] ? u : v;
}
int dist(int u, int v) { return dis[u] + dis[v] - 2*dis[lca(u,v)]; }
int Fa[MAXN], size[MAXN], Size, Minr, root, info[MAXN], CNT;
struct EDGE { int to, nxt, rt; }E[MAXN];
inline void ADD(int u, int v, int rr) {
	E[CNT] = (EDGE){ v, info[u], rr }, info[u] = CNT++;
}
bool vis[MAXN];

void Getrt(int u, int ff) {
	size[u] = 1;
	int ret = 0;
	for(int i = fir[u], v; ~i; i = e[i].nxt)
		if((v=e[i].to) != ff && !vis[v]) {
			Getrt(v, u), size[u] += size[v];
			ret = max(ret, size[v]);
		}
	ret = max(ret, Size-size[u]);
	if(ret < Minr) Minr = ret, root = u;
}
void DFS(int u, int ff) {
	vis[u] = 1; Fa[u] = ff;
	for(int i = fir[u], v; ~i; i = e[i].nxt)
		if(!vis[v=e[i].to]) {
			Minr = n; Size = size[v];
			Getrt(v, u);
			ADD(u, v, root);
			DFS(root, u);
		}
}

LL sum[MAXN]; //子树点数之和
LL sumd[MAXN]; //子树内的距离之和
LL sumf[MAXN]; //子树对父亲的贡献

inline void Modify(int u, int val) {
	sum[u] += val;
	for(int i = u; Fa[i]; i = Fa[i]) {
		int len = dist(u, Fa[i]);
		sum[Fa[i]] += val;
		sumd[Fa[i]] += 1ll * val * len;
		sumf[i] += 1ll * val * len;
	}
}

inline LL Count(int u) { //多理解一会,画画图多YY下
	LL res = sumd[u]; //自己子树的距离之和
	for(int i = u; Fa[i]; i = Fa[i]) {
		int len = dist(u, Fa[i]);
		res += (sum[Fa[i]]-sum[i]) * len; //Fa[i]的其他子树额外的点数 * 这一条边
		res += (sumd[Fa[i]]-sumf[i]); //Fa[i]的其他子树的点到Fa[i]的距离之和
		//上面两个统计都必须要减去这个子树的贡献,否则算重了
	}
	return res;
}
LL Query(int u) {
	LL tmp = Count(u);
	for(int i = info[u]; ~i; i = E[i].nxt)
		if(Count(E[i].to) < tmp) return Query(E[i].rt); //儿子比自己优就去对应的重心
	return tmp;
}
int main () {
	memset(fir, -1, sizeof fir);
	memset(info, -1, sizeof info);
	read(n), read(q);
	for(int i = 1, x, y, z; i < n; ++i)
		read(x), read(y), read(z), add(x, y, z);
	dfs(1, 0), dfs2(1, 1);
	Size = Minr = n; Getrt(1, 0); //先求一次重心
	int RT = root; 				  //作为根
	DFS(root, 0);
	int x, y;
	while(q--) {
		read(x), read(y);
		Modify(x, y);
		printf("%lld\n", Query(RT));
	}
}
```

---

## 作者：kczno1 (赞：16)

树上点权修改，询问带权重心。


有一个贪心的想法，如果一个点儿子的某个子树的点权和大于他这一侧的子树的点权和，


也就是说这条边两边的子树那边更重，那么往那边走一定更优。


而且，从一个点出发这样走到不能走为止，就能找到最优点。


我们需要点分治形成的点分树来log实现这一过程，并在这个过程里维护答案。


初始答案可以只维护根节点的，这样我们只用考虑如何计算答案的变化量。


从点分树上的爸爸转移过来时，


爸爸那一侧的子树的距离增加了dis(爸爸，自己)，带权路径和的增加=dis\*点权和；


自己这一侧的子树的距离减少了dis(爸爸，自己)，带权路径和的减少=dis\*点权和；


自己和爸爸之间的子树的变化就不好算了。


所以点分树上每个点记录


自己这一子树的点权和sum，


到爸爸的距离dis，


和爸爸之间的子树上自己的带权路径和和爸爸带权路径和的差值del，


每个点在点分树上的原树中属于爸爸侧的儿子son。


需要注意，当从爸爸那里转移过来的时候，相当于爸爸指向它的那个点link那里接了一个外侧的子树。


可以当作link的权值增加。


完了再减回去就行了。


(但是这样每一个点我们都需要O(儿子)的时间找到最重儿子，如果树是菊花状时间就会炸；或许可以考虑用个堆维护最重儿子？)


我求两点距离用的树剖，所以时间nlog^3n。。


(树的深度log，所以一次查询需要log次点权修改,一次点权修改影响log个sum,del,计算对del的影响时求距离一个log)


upd: 还有一个方法:


考虑从1开始贪心走的过程，只有当一个点的子树点权和>=总点权/2的时候他才不会往上走，相反我们会从上面走向他，


而只有当一个点下面不存在这样的点的时候，他才不会往下走，也就是说他就是答案的点。


所以我们要求的就是deep最大的子树点权和>=总点权/2的点。


用以dfs序为下标,点权和为权值的线段树，我们可以直接在树上二分得到这个点，


因为满足条件的点一定是从1->答案的点的一条链，而他们的dfs序是递增的。


当修改点权的时候，我们可以通过树链剖分把他拆成log个区间维护线段树。O(log^2)


问题只剩下，如何知道其他点到这个点的带权距离和。


这也是可以用链剖维护的，我的想法比较麻烦，


大概就是线段树维护重链每个点去除重儿子影响后子树的带权距离和,点权和\*deep,查询时重链线段树，轻链暴力。


(其实我写的是定期重构:从下向上dp一遍，再从上向下dp一遍，


询问时暴力枚举新加入的点计算贡献，O(n根号n)然而被tle了)


2次upd:对带权距离和的查询，链剖确实可以方便的维护 见http://kczno1.blog.uoj.ac/blog/2794


---

## 作者：FlashHu (赞：8)

动态点分治小白，光是因为思路不清晰就耗费了不知道多少时间去gang这题，所以还是来理理思路吧。

一个树$T$里面$\sum\limits_{v\in T} D_vdist(u,v)$取到最小值的$u$我们可以称作带权重心。类似重心各种性质的证明过程，我们不难证出这样的点顶多只有两个。

如果$e$都是正数的话比较好做。类比重心性质，新带权重心一定在原带权重心和修改点之间的路径上，可以直接像首都（[蒟蒻题解](http://www.cnblogs.com/flashhu/p/8626003.html)）那样用LCT维护以带权重心为根的树，修改时提出链二分查找出新带权重心即可。

可是$e$会是负数啊！这时候，新带权重心一定会有远离修改点的趋势。但是子树太多了，我们根本不能快速知道往哪里移。我们只能暴力判断，如果当前决策点是$x$，$y$与$x$有边相连，那么假如把补给站移过去，显然答案会减去$y$一侧子树的$w×\sum\limits_{v\in Y} D_v$（$w$为当前边权），加上$x$一侧子树的$w×\sum\limits_{v\in X} D_v$。那么当$\sum\limits_{v\in Y} D_v\geq\sum\limits_{v\in X} D_v$也就是$2\sum\limits_{v\in Y} D_v\geq\sum\limits_{v\in T} D_v$时我们当然可以更改决策点，然后继续寻找更优的点，直到找不到为止。只可惜这样是$O(n^2)$的。

怎么快速找呢？我们可以想到动态点分治，点分树的高度是$\log$级别的，把它建好后，维护每个以$u$为根的点分子树的$D$之和$s_u$。根据上式判断，如果当前点的某一个有边相邻的点更优，我们直接把决策点改成该点所在的点分子树的根节点！由于每个点度数很小，我们甚至可以暴力`for`一遍判断。这也是像首都一样二分查找重心。

但是，具体实现起来又有不少问题。

首先，点分树保证了高度，却保证不了信息的完整性，每个节点只能维护该节点所在点分子树的信息。而上面那个式子需要维护原树的子树$\sum D$。试想一下当我们在点分树里从根向下跳了$k$层，那么当前的子树还会通过边连接上$O(k)$个外部子树。如果`for`每一条边的时候都要判断每一个外部子树在边的哪一侧，岂不是很费劲？

聪明的做法，可以理解为缩点，是在每次找到更优点之后，跳向点分子树$v$之前，把更优点的$D$临时加上$s_u-s_v$即外部子树的$\sum D$。当然，注意区分点分树和原树，更优点并不一定是当前点的子节点，所以更优点的点分树上的祖先的$s$也要更新。用递归实现，等到找出了带权重心，回溯了之后，再把它还原。稍稍脑补一下，是不是很轻松地消除了外部子树的影响？

其次，找出了重心，我们还要统计答案。仔细想想，这个答案实在不方便也没必要丢到别的数据结构（线段树，LCT什么的）动态维护了。把点分树建出来了，还不好好使用它？我们显然要维护每个以$x$为根点分子树中的$\sum\limits_{v\in X} D_vdist(x,v)$，记为$tot_x$。设统计$x$的答案，首先$tot_x$直接算进去了。但是如果加上$x$祖先的$tot$，就会有多余的，多余出$x$所在点分子树的贡献。这时候来一波树上差分，再记$tof_x$表示$\sum\limits_{v\in X} D_vdist(fa_x,v)$（$fa_x$为$x$点分树上的父亲），每加上$tot_{fa_x}$就减掉$tof_x$就好啦。

思路至此，点分树里的三个变量怎么维护也不是大问题了。当$D_x$加上$e$的时候，更新点分树上$x$及其祖先，设当前修改$y$，那么$s_y$加上$e$、$tot_{fa_y}$和$tof_y$都加上$e×dist(x,{fa_y})$就是显然的了。那么我们还要预处理出每个点到点分树上每个祖先的距离，这个可以离线，为什么没人写Tarjan求LCA呢？（话说蒟蒻也是第一次写）把询问丢进去，以$1$为根求每个点的带权深度$dep$，处理出LCA之后直接差分，$dist(x,y)=dep_x+dep_y-2dep_{LCA}$，这个大家都会吧。

思路实在不清晰就看看代码吧。话说动态点分治的代码都短不了吧。。。。。。不过Tarjan写起来方便不少，蒟蒻没~~过分~~压行也只有90多行。
```cpp
#include<cstdio>
#include<cstring>
#define LL long long
#define RG register
#define R RG int
#define G c=getchar()
const int N=1e5+9,M=2e5+9,L=2e6;
namespace E{int he[N],ne[M],to[M];}//原树
namespace T{int he[N],ne[N],to[N];}//点分树
namespace Q{int he[L],ne[L<<1],to[L<<1];}//LCA询问
using namespace E;//封了namespace确实清楚多了
int n,p,rt,w[M],s[N],mx[N],h[N],dep[N],fa[N],top[N],dis[N][20],*at[L<<1];
LL tot[N],tof[N];//该开longlong的别忘记
bool vis[N];
inline int in(){
    RG char G;RG bool f=0;
    while(c<'-')G;
    if(c=='-')f=1,G;
    R x=c&15;G;
    while(c>'-')x*=10,x+=c&15,G;
    return f?-x:x;
}
inline void max(R&x,R y){if(x<y)x=y;}
void getrt(R x){//建点分树求重心
    vis[x]=1;s[x]=1;mx[x]=0;
    for(R y,i=he[x];i;i=ne[i]){
        if(vis[y=to[i]])continue;
        getrt(y);
        s[x]+=s[y];max(mx[x],s[y]);
    }
    max(mx[x],n-s[x]);
    if(mx[rt]>mx[x])rt=x;
    vis[x]=0;
}
int div(R x){//递归建树
    getrt(x);vis[x=rt]=1;rt=0;
    for(R t=n,y,i=he[x];i;i=ne[i]){
        if(vis[y=to[i]])continue;
        n=s[x]>s[y]?s[y]:t-s[x];
        T::ne[++p]=T::he[x];T::he[x]=p;
        fa[T::to[T::he[x]]=div(top[p]=y)]=x;
    }//小心递归后p变了，写T::to[p]会出事
    return x;
}
int geth(R x){return x==h[x]?x:h[x]=geth(h[x]);}//路径压缩
void tarjan(R x){//预处理dist
    vis[x]=1;
    for(R y,i=he[x];i;i=ne[i]){
        if(vis[y=to[i]])continue;
        dep[y]=dep[x]+w[i];
        tarjan(y);h[y]=x;
    }
    for(R y,i=Q::he[x];i;i=Q::ne[i])
        if(vis[y=Q::to[i]])
            *at[i]=dep[x]+dep[y]-(dep[geth(y)]<<1);//差分
}
LL find(R x){
    R i;
    for(i=T::he[x];i&&s[T::to[i]]<<1<s[x];i=T::ne[i]);//找更优点
    if(!i)return x;//找不到的话当前点就是最优点
	R y,del=s[x]-s[T::to[i]];
	for(y=top[i];y!=x;y=fa[y])s[y]+=del;//缩点
    R ret=find(T::to[i]);
	for(y=top[i];y!=x;y=fa[y])s[y]-=del;//还原
    return ret;
}
int main(){
    mx[0]=1e9;//记得给初值
    R n=::n=in(),q=in(),x,y,v,i;
    for(i=1;i<n;++i){
        x=in();y=in();
        ne[++p]=he[x];to[he[x]=p]=y;
        ne[++p]=he[y];to[he[y]=p]=x;
        w[p]=w[p-1]=in();
    }
    p=0;rt=div(1);p=0;
    for(x=1;x<=n;++x)
        for(i=0,y=fa[h[x]=x];y;y=fa[y],++i){
            Q::ne[++p]=Q::he[x];Q::to[Q::he[x]=p]=y;
            Q::ne[++p]=Q::he[y];Q::to[Q::he[y]=p]=x;
            at[p]=at[p-1]=&dis[x][i];//搞个指针，Tarjan的时候直接把值放进去
        }
	memset(vis,0,n+1);memset(s,0,(n+1)<<2);//之前用过要清空
    tarjan(1);
    RG LL t;
    while(q--){
        x=y=in();s[rt]+=v=in();
		for(i=0;y!=rt;++i)//维护
			t=(LL)dis[x][i]*v,s[y]+=v,tof[y]+=t,tot[y=fa[y]]+=t;
		t=tot[x=y=find(rt)];
		for(i=0;y!=rt;++i)//算答案
			t+=(LL)dis[x][i]*(s[fa[y]]-s[y])+tot[fa[y]]-tof[y],y=fa[y];
		printf("%lld\n",t);
	}
	return 0;
}
```

---

## 作者：bztMinamoto (赞：7)

噩梦……真的噩梦……我快被幽香给玩死了……

　　用这道题来理解动态淀粉质点分治的（因为当初捉迷藏那题直接学岛娘的括号序列……就没去再打一遍……），然而题解大佬们都直接默认我们已经会动态点分然后直接上……结果我昨天看了一个晚上才弄懂……然后今天又花了一个早上码完，交上去竟然1A了不可思议

　　先说一下什么是动态点分治吧。对于一般的点分治，因为我们每一次都找出重心，所以每一次递归往左右子树找的时候深度不会超过$O(log n)$层。但是如果有了修改操作怎么办呢？每修改一次点分一次么？那怕是得T飞

　　我们来看一下这道题目，它的每一次修改，更改的只有点权，树的结构是没有变化的（如果有的话怕是只能上LCT了……），也就是说，每一次点分的时候找到的重心是不会改变的。那么，我们可不可以把点分治每一层的重心给连成一棵树呢？因为点分的递归层数只有$O(log n)$层，所以这棵点分树的深度也是$O(log n)$的

　　那么考虑一下在每一个点分树的节点维护什么东西，对于每一个节点，我们维护他的子树中的所有信息，也就是在原树中它被选为重心时的那个子树的所有信息。修改的时候，只要从一个点开始在点分树里往上跳，并不断更新信息即可。查询一个点的时候，点分树里跳，不断考虑与父亲之间的贡献就好了。

　　上面那一段看不懂也没关系，因为我只是在口胡，假装自己已经很懂动态点分的样子

　　那么我们具体来分析一下这道题目我们要维护什么

　　题目要求使$\sum d_v*dis(u,v)$最小，其中$d_v$为$v$点的点权，$dis(u,v)$为原树中$u,v$两点的距离。题目要求就是求带权重心。假设我们当前已经选定了点$v$为答案，那么考虑它的一个子节点$w$，如果把补给站从点$v$转移到$w$，那么$w$的所有子树内的点到补给站的距离少了$dis(v,w)$，而其他所有点到补给站的距离多了$dis(v,w)$。我们假设$sum_v[v]$为$v$的子树内的点权和，那么答案总共的变化量是$$dis(u,v)*(sum_v[v]-sum_v[w]-sum_v[w])$$

　　不难发现，当$sum_v[w]*2>sum_v[v]$的时候，答案的变化量是小于零的，也就是说代价减小，可以变得更优。而且，满足这样条件的点$w$最多只有一个

　　那么我们可以每一次选定一个点，然后看看往他的哪个子树走更优，如果没有说明他自己就已经是最优的了。这样不断下去肯定能找到答案。

　　但是由于原图可能是一条链，要怎么做才能保证复杂度呢？我们选择在点分树上走，每一次都跳到它下一层的重心，这样可以保证层数最多只有$O(log n)$

　　然后考虑如何维护答案。不难发现，对于点分树上一个点$v$，它的子树中的点就是在点分治时它被选为重心时的那棵树上的点。考虑点分树上的一对父子$u,v$，我们设$sum_a[v]$表示$v$的子树内的所有点到他的代价之和，$sum_b[v]$为$v$的子树内的所有点到$v$点父亲（也就是点$u$）的距离之和，$sum_v[v]$还是表示子树的点权之和。那么我们设答案已经选定为点$v$，加上$u$的不包括$v$的子树后答案就是$sum_a[v]-sum_b[v]+sum_a[u]+sum_v[u]*dis(u,v)$。于是只要在点分树上不断找父亲并合并，就可以知道答案了

　　然后我们只要能在修改时维护好这三个数组就可以了！！！

　　至于修改时如何维护呢？我们修改一个点之后，然后不断在点分树上往父节点跳，并不断更新即可。查询的时候也是，不断跳并合并答案
  
  然后又新学会了一招，用$RMQO(1)$查询$LCA$（只会倍增和树剖的我瑟瑟发抖）
  
```
//minamoto
#include<cstdio>
#include<iostream>
#include<cstring>
#define ll long long
#define N 100005
#define inf 0x3f3f3f3f
#define rint register int
using namespace std;
#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
inline int read(){
    #define num ch-'0'
    char ch;bool flag=0;int res;
    while(!isdigit(ch=getc()))
    (ch=='-')&&(flag=true);
    for(res=num;isdigit(ch=getc());res=res*10+num);
    (flag)&&(res=-res);
    #undef num
    return res;
}
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
inline void print(ll x){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
struct G{
	int head[N],Next[N<<1],edge[N<<1],ver[N<<1],tot;
	G(){tot=0;memset(head,0,sizeof(head));}
	inline void add(int u,int v,int e){
		ver[++tot]=v,Next[tot]=head[u],head[u]=tot,edge[tot]=e;
	}
}T1,T2;
int n,q,st[N<<1][18],logn[N<<1],bin[25],tp;
ll sum,ans,d[N],dis1[N],dis2[N],sumv[N];
int dfn[N],num;
void dfs1(int u,int fa){
	st[dfn[u]=++num][0]=d[u];
	for(int i=T1.head[u];i;i=T1.Next[i]){
		int v=T1.ver[i];
		if(v==fa) continue;
		d[v]=d[u]+T1.edge[i],dfs1(v,u),st[++num][0]=d[u];
	}
}
inline ll LCA(int a,int b){
	if(dfn[a]>dfn[b]) a^=b^=a^=b;
	int k=logn[dfn[b]-dfn[a]+1];
	return min(st[dfn[a]][k],st[dfn[b]-bin[k]+1][k])<<1;
}
inline ll dis(int a,int b){return d[a]+d[b]-LCA(a,b);}
int sz[N],son[N],size,rt,fa[N];bool vis[N];
void dfs2(int u,int fa){
	sz[u]=1,son[u]=0;
	for(int i=T1.head[u];i;i=T1.Next[i]){
		int v=T1.ver[i];
		if(vis[v]||v==fa) continue;
		dfs2(v,u),sz[u]+=sz[v],cmax(son[u],sz[v]);
	}
	cmax(son[u],size-sz[u]);
	if(son[u]<son[rt]) rt=u;
}
void dfs3(int u){
	vis[u]=true;
	for(int i=T1.head[u];i;i=T1.Next[i]){
		int v=T1.ver[i];
		if(vis[v]) continue;
		rt=0,size=sz[v],son[0]=n+1;
		dfs2(v,0),T2.add(u,rt,v),fa[rt]=u,dfs3(rt);
	}
}
inline void update(int u,int val){
	sumv[u]+=val;
	for(int p=u;fa[p];p=fa[p]){
		ll dist=dis(fa[p],u)*val;
		dis1[fa[p]]+=dist;
		dis2[p]+=dist;
		sumv[fa[p]]+=val;
	}
}
inline ll calc(int u){
	ll ans=dis1[u];
	for(int p=u;fa[p];p=fa[p]){
		ll dist=dis(fa[p],u);
		ans+=dis1[fa[p]]-dis2[p];
		ans+=dist*(sumv[fa[p]]-sumv[p]);
	}
	return ans;
}
ll query(int u){
	ll ans=calc(u);
	for(int i=T2.head[u];i;i=T2.Next[i]){
		ll tmp=calc(T2.edge[i]);
		if(tmp<ans) return query(T2.ver[i]);
	}
	return ans;
}
void init(){
	n=read(),q=read();
	bin[0]=1,logn[0]=-1;
	for(rint i=1;i<=20;++i) bin[i]=bin[i-1]<<1;
	while(bin[tp+1]<=(n<<1)) ++tp;
	for(rint i=1;i<=(n<<1);++i) logn[i]=logn[i>>1]+1;
	for(rint i=1;i<n;++i){
		rint u=read(),v=read(),e=read();
		T1.add(u,v,e),T1.add(v,u,e);
	}
	dfs1(1,0),rt=0,son[0]=n+1,size=n,dfs2(1,0);
	for(rint j=1;j<=tp;++j)
	for(rint i=1;i+bin[j]-1<=(n<<1);++i)
	st[i][j]=min(st[i][j-1],st[i+bin[j-1]][j-1]);
}
int main(){
	init();
	int LastOrder=rt;dfs3(rt);
	while(q--){
		int x=read(),y=read();update(x,y);
		print(query(LastOrder));
	}
	Ot();
	return 0;
}
```

---

## 作者：木xx木大 (赞：6)

[P3345 [ZJOI2015]幻想乡战略游戏](https://www.luogu.com.cn/problem/P3345)

按照找重心的普遍思路，我们从根节点开始 dfs。假设当前补给站为 $u$，$v$ 为 $u$ 的一个子节点，如果将补给站迁移到点 $v$ 更优，那么我们就往 $v$ 的方向继续 dfs。

我们用动态点分治优化这个过程：假设现在到了点 $u$ 的分治子树，并且发现最优解在 $v$ 的分治子树内（ $v$ 为 $u$ 在点分树上的一个子节点，原树上有边 $(u,w)$ 且 $w$ 在 $v$ 的分治子树内），则转移到 $v$ 的分治子树内求解。

那么剩下的问题就是当补给站的位置确定时，如何快速求出代价。借鉴换根 dp 的思想，我们考虑用父亲的代价+代价的变化量求出儿子的代价。具体地，设 $dis1_u$ 表示 $u$ 的分治子树内 $\sum d_v\times dis(u,v)$，$dis2_u$ 表示 $u$ 向其点分树上父亲的 $dis1$ 的贡献，即 $\sum d_v\times dis(fa_u,v)$。计算增量时，我们暴力跳点分树上的父亲，累加贡献即可，具体式子见代码。这部分单次计算的复杂度为 $O(\log n)$。

考虑这样做的复杂度：假设当前补给站为 $u$，$v$ 为 $u$ 的一个子节点，设 $sum$ 为子树内点权和，如果将补给站迁移到点 $v$，代价的**增量**为$w(u,v)\times(sum_u-sum_v-sum_v)$。得出性质：补给站在 $v$比 $u$ 优，当且仅当 $2\times sum_v>sum_u$。显然满足条件的 $v$ 最多只有一个。也就是说，递归找重心时，每次最多只会进入 $u$ 的一个子树内，因为点分树只有 $\log$ 层，所以总复杂度（需要 $O(1) $ LCA 或者预处理 LCA） 为 $O(n\log^2n)$。

```cpp
#include<bits/stdc++.h>
typedef long long ll;
using namespace std;
namespace FGF
{
	int n,m;
	const int N=1e5+5;
	struct edg{
		int to,nxt,w;
	}E[N<<1],e[N<<1];
	int fa[N],dep[N<<1],st[N<<2][25],head[N],cnt,cnt1,head1[N],dfn[N<<1],id[N<<1],num,lo[N<<2],mxson[N],sz,siz[N];
	ll dis[N],dis1[N],dis2[N],sum[N],ro;
	bool vis[N];
	void add(int u,int v,int w)
	{
		cnt++;
		e[cnt].to=v;
		e[cnt].nxt=head[u];
		head[u]=cnt;
		e[cnt].w=w;
	}
	void Add(int u,int v,int w)
	{
		cnt1++;
		E[cnt1].to=v;
		E[cnt1].nxt=head1[u];
		head1[u]=cnt1;
		E[cnt1].w=w;
	}
	void predfs(int u,int f,int d)
	{
		dfn[u]=++num,id[num]=u,dep[num]=d;
		for(int i=head[u];i;i=e[i].nxt)
			if(e[i].to!=f)dis[e[i].to]=dis[u]+e[i].w,predfs(e[i].to,u,d+1),id[++num]=u,dep[num]=d;
	}
	void init()
	{
		predfs(1,0,1);lo[0]=-1;
		for(int i=1;i<=num;i++)lo[i]=lo[i>>1]+1;
		for(int i=1;i<=num;i++)st[i][0]=i;
		for(int j=1;j<=lo[num];j++)
			for(int i=1;i+(1<<j)-1<=num;i++)
				st[i][j]=(dep[st[i][j-1]]<=dep[st[i+(1<<(j-1))][j-1]]? st[i][j-1]:st[i+(1<<(j-1))][j-1]);
	}
	int getlca(int x,int y)
	{
		int l=dfn[x],r=dfn[y];
		if(l>r)swap(l,r);
		int k=lo[r-l+1];
		return dep[st[l][k]]<=dep[st[r-(1<<k)+1][k]]? id[st[l][k]]:id[st[r-(1<<k)+1][k]];
	}
	ll getdis(int u,int v)
	{
		return dis[u]+dis[v]-2LL*dis[getlca(u,v)];
	}
	void getrt(int u,int f)
	{
		siz[u]=1;mxson[u]=0;
		for(int i=head[u];i;i=e[i].nxt)
		{
			int v=e[i].to;
			if(v==f||vis[v])continue;
			getrt(v,u);
			siz[u]+=siz[v],mxson[u]=max(mxson[u],siz[v]);
		}
		mxson[u]=max(mxson[u],sz-siz[u]);
		if(mxson[u]<mxson[ro])ro=u;
	}
	void build(int u)
	{
		vis[u]=1;
		for(int i=head[u];i;i=e[i].nxt)
		{
			int v=e[i].to;
			if(vis[v])continue;
			mxson[ro=0]=n,sz=siz[v];
			getrt(v,0);
			fa[ro]=u;Add(u,ro,v);
			build(ro);
		}
	}
	void updat(int u,int val)
	{
		sum[u]+=val;
		for(int i=u;fa[i];i=fa[i])
		{
			ll d=getdis(fa[i],u);
			dis1[fa[i]]+=d*val;
			dis2[i]+=d*val;
			sum[fa[i]]+=val;
		}
	}
	ll calc(int u)
	{
		ll ans=dis1[u];
		for(int i=u;fa[i];i=fa[i])
			ans+=dis1[fa[i]]-dis2[i]+getdis(fa[i],u)*(sum[fa[i]]-sum[i]);
		return ans;
	}
	ll query(int u)
	{
		ll ans=calc(u);
		for(int i=head1[u];i;i=E[i].nxt)
			if(calc(E[i].w)<ans)return query(E[i].to);
		return ans;
	}	
	void work()
	{
		scanf("%d%d",&n,&m);
		for(int i=1;i<n;i++)
		{
			int u,v,w;
			scanf("%d%d%d",&u,&v,&w);
			add(u,v,w),add(v,u,w);
		}
		init();
		mxson[0]=sz=n;getrt(1,0);
		int tmp=ro;build(ro); ro=tmp;
		while(m--)
		{
			int x,y;
			scanf("%d%d",&x,&y);
			updat(x,y);
			printf("%lld\n",query(ro));
		}
	}
}
int main()
{
	FGF::work();
	return 0;
}
```

---

## 作者：Erusel (赞：5)

**树的重心**

考虑一个点，以它为根的树中，最大的子树节点数最少，我们把这个点称为树的重心

举个例子，下图中重心为$1$和$2$

![2333](https://cdn.luogu.com.cn/upload/pic/62751.png)

**树形dp求重心**

求解树的重心的时候，我们通常会采用树形dp

我们用$s[i]$代表以$i$为根的子树节点数

$f[i]$代表以$i$为根的子树中最大的子树节点个数

显然，$f[u]=max(f[u],s[v])$

但是我们求重心的时候，**是以$u$为根**。

还是举上图的例子，当我们把2号点当成重心时，它就变成了这样

![2333](https://cdn.luogu.com.cn/upload/pic/62758.png)

这时候$2$号节点的~~父亲变成了儿子~~

所以最后统计$f[u]$的时候，还要记得统计$n-s[u]$(即以原来父亲为根的子树的节点数)

**code:**

```
void dfs(int u,int fa)
{
	s[u]=1,f[u]=0;
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==fa)continue;
		dfs(v,u);
		s[u]+=s[v];
		f[u]=max(f[u],s[v]); 
	}
	f[u]=max(f[u],n-s[u]);
}
```

如果题目让我们求多个重心的编号，在最后统计的时候注意一下即可

**code:**

```
#include<bits/stdc++.h>

#define rd(x) x=read()

#define N 20005

using namespace std;

int n,m;

struct E{
	int to,nxt;
}e[N];
int tot; 
int ans,pos;
int head[N];
int f[N],s[N];

void addEdge(int u,int v){e[++tot].nxt=head[u],e[tot].to=v,head[u]=tot;}

inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}

inline void write(int x)
{
    if(x<0){putchar('-');x=-x;}
    if(x>=10)write(x/10);
    putchar(x%10+'0');
}

void dfs(int u,int fa)
{
	s[u]=1,f[u]=0;
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==fa)continue;
		dfs(v,u);
		s[u]+=s[v];
		f[u]=max(f[u],s[v]); 
	}
	f[u]=max(f[u],n-s[u]);
}

int main()
{
	rd(n);
	for(int i=1;i<=n-1;i++)
	{
		int u,v;
		rd(u),rd(v);
		addEdge(u,v);
		addEdge(v,u);
	}
	dfs(1,-1);
	int minn=1e9;
	for(int i=1;i<=n;i++)minn=min(minn,f[i]);
	for(int i=1;i<=n;i++)if(f[i]==minn)printf("%d ",i);
	printf("\n");

    return 0;
}

```

---

**一些性质**

树的重心有一堆~~稀奇古怪~~好玩的性质

但是一堆终究还是一个

**第一个性质**

把它摆在第一个，也代表它是最重要的性质

考虑上图中的$2$号点

它的子树中节点个数最大的子树是以$1$号点为根的子树

我们考虑以$1$号点为根的子树的根节点，把它作为我们假想的重心，我们把它称为**伪重心**（为了方便说明，这个名词是我造的）

伪重心的子树显然是不平衡的

当我们取伪重心作为重心的时候

设以伪重心为根的子树的节点个数（即原重心最大子树的节点个数）为$x$,原重心其他子树的节点数之和为$y$

以伪重心为根，有两棵子树，一颗为$x-1$，一颗为$y+1$

我们要保证重心是最优的

所以$x-1<[(n-1)/2]$

$x<=[n/2]$

这就是第一个性质:

**以重心为根，所有的子树的大小都不超过整个树大小的一半。**

**树的重心最多有两个。**

当一棵树有两个重心时，为了保持尽量平衡，它的第二个重心肯定在以第一个重心为根的最大的子树根节点上。

根据性质1中的证明：当$x=[n/2]$时，这颗树就有两个重心。

**树的重心到其他节点的距离是最小的**

注：相邻两个节点距离为$1$.

每一次我们一格一格的从重心移动。

假设我们将重心向一棵子树移动，设那颗子树的节点数为$s$

每移动一格，树的根节点就变化一次。

对于每一次移动，设上一次重心为$u$

当前重心为$v$

设$v$的子树节点数为$s[v]$

$v$的子树的每个节点距离重心减少1

其他的所有节点距离重心增加1

设$ans[u]$表示$u$到其他节点的距离

则$ans[u]=ans[v]+n-s[v]-s[v]=ans[v]+n-2*s[v]$

因为对于重心的每一个节点$s[i]<=[n/2]$

所以重心到其他节点的距离是最小的。

用上面那个递推式还可以求出距离其他节点最远的节点

**把两个树通过一条边相连得到一个新的树，那么新的树的重心在连接原来两个树的重心的路径上。**

关于这一点的证明较为感性

我们考虑以两棵树的重心为根，即以重心把整棵树提起来。

当我们用一条边把两棵树$A,B$连接起来时，

我们先考虑树$A$

对于树$A$,我们可以理解为树$A$中的一个节点拥有了所有树$B$的节点

那么整体的中心肯定偏向那一侧

对于树$B$，我们也可以这么理解

所以在偏向的过程中，中心可能存在的位置一定在树$A$重心和树$B$重心的连线上


**把一个树添加或删除一个叶子，那么它的重心最多只移动一条边的距离。**

这个请读者利用以上性质自行证明

---

现在，题目要求我们维护广义中心的点权（加减一个值）

动态点分治（点分树）固然可做，这里提供一种树链剖分的方法.

**即使我们把重心的定义广义化了，**

**重心依旧不依赖于边权**

回顾一下重心的原定义：

> **考虑一个点，以它为根的树中，最大的子树节点数最少，我们把这个点称为树的重心**

这里，我们要把节点数改为节点权值总和

这里证明一下：

我们用类似证明性质**树的重心到其他节点的距离是最小的**的方法，考虑从重心移动一次

我们用$w(u,v)$表示$u->v$的距离,$e(u)$表示$u$的点权,$f(u)$表示总和

定义$f(u)=\sum e(v)*w(u,v)$

因为这是一颗无根树，所以我们以最大的子树节点权值总和最小的点$u$为根,$size_i$表示$u$节点的第$i$个子树的大小，$s_i$表示$size_i$表示$u$节点的第$i$个子树

移动一条边之后，设$u'$是$u$的第$k$个子树的根节点，

$f(u')=f(u)-\sum e(v)(v \in s_i)+\sum e(v)(v \notin s_i)$

因为保证了$\sum e(v)(v \in s_i)<=[\sum e(v)/2]$

所以$f(u')>=f(u)$

所以$f(u)$是最优的。

---

因为一条链上深度越大dfs序越大，

所以根据这个性质，我们只要找到一个点$u$,

使得$f(u)*2>=f(rt)$，且$u$节点最深

这个可以在线段树上利用二分快速找出。

我们用$cost$表示花费，$e(v),w(u,v)$的定义同上

$cost=\sum e(v)*w(u,v)$

对于$w(u,v)$我们可以用LCA维护：$w(u,v)=w(u,rt)+w(v,rt)-2*w(lca,rt)$

则原式可化为：$cost=\sum w(u,rt)*e(v)+\sum w(v,rt)*e(v)-2*w(lca,rt)*e(v)$

在更新的时候，记录一下$\sum \Delta e$和$\sum \Delta w(u,rt)*e$即可，时间复杂度$O(1)$

对于$w(lca,rt)*e(v)$每一次更新时，我们都从当前节点到根节点的大小$size$一路修改

查询时，即查询$\sum (w(u,rt)-w(fa[u],rt))*size(u)$

$w(u,rt)-w(fa[u],rt)$用线段树维护即可

时间复杂度$O(nlog^2n)$

---

## 作者：zhangyuxi (赞：5)

	首先想到dp，但是不能支持修改。~~听某些大佬说是动态点分治，然而本蒟蒻并不会。~~
	普通的点分治是静态的，可以nlogn的时间求解。动态点分治中先按各层分治的中心建一个点分树。可以证明，这棵树的深度不超过logn级别然后在这棵树上修改或求解即可。
	回到这道题，先建点分树。如果不加说明，所有操作都是在点分树上进行的。通过观察，发现最优的补给站是这棵树的带权重心，即如果现在节点的子树d的和*2大于总节点ｄ的和，那么向那个方向过去一定比原方案好。所以对于每个节点，记f[i]为以ｉ为根的子树d的和。先从根开始，如果f[s]*2>f[r]（ｓ是ｒ的儿子），则向ｓ搜索。然而有一个问题，f[s]只包含一部分的结点，所以要把剩余部分加到里面。因此在建树的时候要把根向原树每个块的第一个点记下来（记为u），然后找带权重心的时f[u]+=f[r]-f[s]，向上更新。
    另外还要对每个结点记：
   	h[i]表示以i为根的子树的d*dis的和。
    g[i]表示以i为根的子树到i的父亲的d*dis的和。
    每个点到每个祖先的dis。
   	向上更新时，自己YY。

---

## 作者：0xyz (赞：4)

### 提供一个 $O((n+q)\log n)$ 的在线做法。

题目详见 [P3345](https://www.luogu.com.cn/problem/P3345)。

### 一、全局平衡二叉树

全局平衡二叉树可以解决链修改、链查询的问题，复杂度为单次 $O(\log n)$。

以下是全局平衡二叉树的构建。对于一棵树，我们首先给它做轻重链剖分。将每条重链拎出来单独建一棵二叉树，这棵二叉树的每个点的权值是它的轻子树大小和加上它自己。然后我们每一层都取带权中心，这个中心的在重链上的祖先变成左子树，在重链上的后代变成右子树。这样，我们将每一条重链都建成了一棵平衡二叉树，其中序遍历恰好是这条重链从浅到深的节点序列。对于重链与重链之间的轻边，我们由较深的重链对应的二叉树的根节点连向它的重链顶端在原树上的父亲节点，但是子节点记录父亲，父亲节点不记录儿子。

从任意一个点开始，我们向上遍历，如前文所说，最多经过 $O(\log n)$ 条轻边，并且由于平衡二叉树节点权重由轻子树大小决定，从而每经过一条重边，其子树大小至少变为原来的两倍。因此，全局平衡二叉树的深度是 $O(\log n)$ 的。

对于修改和查询操作，我们直接从初始节点往上遍历，在每个节点维护一些值和标记即可。

由于全局平衡二叉树的修改和查询从下往上，所以标记永久化的常数显著小于懒标记下传的。

### 二、本题做法

全局平衡二叉树只能解决链上的问题，所以考虑把答案中的补给站固定在一条链上。

**结论 1：使得从树上的任意一点出发到树上所有点的距离乘上目标点的点权和最小的起点一定是树的带权重心。**

证明：假设使得答案最小的起点是 $u$，对于一条连接 $u$ 和 $v$ 的长度为 $c$ 的边，我们假设 $u$ 那一侧的点权和为 $s_u$，$v$ 的那一侧点权和为 $s_v$，那么如果有 $s_u<s_v$，那么我们将起点从 $u$ 移动到 $v$，可以减少 $(s_v-s_u)c$ 的带权距离，与 $u$ 使得答案最小的假设矛盾。
从而 $u$ 一定能保证它的每一个子树的权值和不超过总权值的一半，符合带权重心的定义。□

**结论 2：令任意一个节点为根，带权重心是带权 DFS 序的重心在树上所代表的节点的祖先。** 

证明：我们假设所有节点权值和是 $s$，令任意一个节点为根，在带权 DFS 序中：
- 重心出现的位置前面的节点权值和是其祖先节点权值和加上其祖先的所有排名在重心前面的节点的权值和，又注意到以重心为根节点时，这些节点同属于重心的原本的父亲的那一棵子树，由重心的性质知其权值和必定 $\le\frac{s}{2}$。
- 重心的所有子树结束的位置，由上面的推理同理可知，其后面的权值和也 $\le\frac{s}{2}$。

那么，带权 DFS 序重心在树的重心的子树内。□

**结论 3：令任意一个节点为根，带权重心子树权值和大于等于所有节点权值和的一半并且其任意一个子节点节点的子树权值和小等于所有节点权值和的一半。** 

利用上面这 $3$ 个性质，我们可以将 DFS 序预处理出来，动态维护其中位数。处理的时候，我们可以维护每个节点的子树权值和，修改就是将修改的节点到根的链上所有节点加上增加的点权，查询就是在中位数到根节点的链上二分总权值和的一半到了哪个节点。最后就是计算重心到所有节点的带权距离之和。

寻找重心的部分，动态维护中位数，可以用线段树二分；在链上加，可以用全局平衡二叉树做；在链上二分，也用全局平衡二叉树。

对于链上的二分，由于我们倾向于使用标记永久化的全局平衡二叉树，所以没有办法知道向上遍历的每个结点的真实值。于是，采用如下方法：每遍历到一棵平衡二叉树的根节点，我们就一直走向左儿子，累加懒标记。如果这棵平衡二叉树的最左边的节点的子树权值和大于等于所有节点权值和的一半，那就说明重心在这棵平衡二叉树内。接下来就是平衡树上的二分了，依然是 $O(\log n)$ 的。

计算距离的部分，我们可以将 $\sum\text{dis}(i,x)\times\text{val}(i)$ 拆成 $\text{dep}(x)\times\sum\text{val}(i)+\sum\text{dep}(i)\times\text{val}(i)-2\sum\text{dep}(\text{lca}(x,i))\times\text{val}(i)$，第一、二个部分可以 $O(1)$ 维护，第三个部分可以对于每个点，将其到根的链上所有边加上点权乘以边权，最后计算出 $x$ 到根的链上的所有数的和即可，同样用全局平衡二叉树维护。

总时间复杂度 $O((n+q)\log n)$，总空间复杂度 $O(n)$。即便这题没有卡树剖的数据，也拿到了目前的[最优解](https://www.luogu.com.cn/record/139671410)。

```cpp
#include<bits/stdc++.h>
using namespace std;
int plen,ptop,pstk[40];
char rdc[1<<14],wtc[1<<23],*rS,*rT;
#define gc() (rS==rT?rT=(rS=rdc)+fread(rdc,1,1<<14,stdin),(rS==rT?EOF:*rS++):*rS++)
#define pc(x) wtc[plen++]=(x)
#define flush() fwrite(wtc,1,plen,stdout),plen=0
template<class T=int>inline T read(){
    T x=0;char ch;bool f=0;
    while(!isdigit(ch=gc()))if(ch=='-')f=!f;
    do x=(x<<1)+(x<<3)+(ch^48);while(isdigit(ch=gc()));
    return f?-x:x;
}
inline int read(char*const s){
    char ch,*t=s;
    while(!isgraph(ch=gc()));
    do *t++=ch;while(isgraph(ch=gc()));
    return (*t)=0,t-s;
}
template<class T>inline void write(T x){
    if(plen>=8000000)flush();
    if(!x)return pc('0'),void();
    if(x<0)pc('-'),x=-x;
    for(;x;x/=10)pstk[ptop++]=x%10;
    while(ptop)pc(pstk[--ptop]^48);
}
inline void write(const char*s){
    if(plen>=8000000)flush();
    for(int i=0;*(s+i);pc(*(s+(i++))));
}
inline void write(char*const s){
    if(plen>=8000000)flush();
    for(int i=0;*(s+i);pc(*(s+(i++))));
}
const int _=11e4;
vector<pair<int,int> >e[_];
long long tot,s[_];
int n,q,m,c,val,h[_],sz[_],f[_],eu[_],in[_],si[_],de[_];
int v[_],d[_],p[_],ls[_],rs[_],o[_],w[_*2],t[_],sv[_],se[_];
void dfs(int x,int fa){
	sz[x]=1;eu[++c]=x;in[x]=c;f[x]=fa;
	for(auto y:e[x])
		if(y.first!=fa){
			de[y.first]=de[x]+(v[y.first]=y.second);
			dfs(y.first,x);
			sz[x]+=sz[y.first];
			if(sz[y.first]>sz[h[x]])h[x]=y.first;
		}
}
int build(int l,int r){
	int x=l,y=r;
	while(y-x>1){
		int mid=x+y>>1;
		if(2*(si[mid]-si[l])<=si[r]-si[l])x=mid;
		else y=mid;
	}
	y=d[x];se[y]=sv[r]-sv[l-1];
	if(l<x)p[ls[y]=build(l,x-1)]=y;
	if(x<r)p[rs[y]=build(x+1,r)]=y;
	return y;
}
int cat(int tp){
	int c=0;
	for(int x=tp;x;x=h[x])
		for(auto y:e[x])
			if(y.first!=f[x]&&y.first!=h[x])p[cat(y.first)]=x;
	for(int x=tp;x;x=h[x])d[++c]=x,si[c]=si[c-1]+sz[x]-sz[h[x]],sv[c]=sv[c-1]+v[x];
	return build(1,c);
}
int main(){
	n=read();q=read();
	for(int i=1,x,y,z;i<n;i++){
		x=read();y=read();z=read();
		e[x].push_back({y,z});
		e[y].push_back({x,z});
	}
	dfs(1,0);cat(1);
	for(m=1;m<n;m<<=1);
	for(int i=1,j,x,y,d,g,k;i<=q;i++){
		long long z=0;bool r=1;
		x=read();y=read();
		for(j=x;j;j=p[j]){
			s[j]+=z;
			if(r)t[j]+=y,t[rs[j]]-=y,z+=1ll*y*(v[j]+se[ls[j]]),s[j]-=1ll*y*se[rs[j]];
			if((r=j!=ls[p[j]])&&j!=rs[p[j]])z=0;
		}
		val+=y;k=val+1>>1;tot+=1ll*de[x]*y;
		for(j=in[x]+m-1;j;j>>=1)w[j]+=y;
		for(j=1;j<m;)w[j<<1]<k?(k-=w[j<<1],j=j<<1|1):j=j<<1;
		for(j=eu[j-m+1];j;j=p[j])
			if(j!=ls[p[j]]&&j!=rs[p[j]]){
				for(d=0,k=j;k;k=ls[k])d+=t[k];
				if(d*2>=val)break;
			}
		for(d=0;j;d*2>=val?(g=j,j=rs[j]):j=ls[j])d+=t[j];
		for(j=g,y=0,z=0,r=1;j;j=p[j]){
			if(r)z+=s[j]-s[rs[j]]-1ll*se[rs[j]]*t[rs[j]],y+=v[j]+se[ls[j]];
			z+=1ll*y*t[j];
			if((r=j!=ls[p[j]])&&j!=rs[p[j]])y=0;
		}
		write(1ll*de[g]*val+tot-2*z),pc('\n');
	}
	flush();
	return 0;
}
```

---

## 作者：xzyxzy (赞：4)

很久没有被题目恶心得欲仙欲死了

于是今天找了个虐

## 正文

整理好思路其实这题是要比捉迷藏、Qtree4好写的

### Step1

建好点分树以及打好树剖（用来求两点距离）

### Step2

维护三个东西就很好计算以指定的某个点为补给站的答案了
```
  d[x]表示点分树上以x为根的子树的兵队总数
  val[x]表示点分树上以x为根的子树的兵队到达x的代价和
  tofa[x]表示点分树上以x为根的子树的兵队到达x的父亲的代价和
```
于是具体操作在Calc函数中，有详细解释

### Step3

具体代码流程

1.建好点分树

2.修改某个点，暴跳点分树的父亲对应修改三个值

3.从点分树根开始查询，找到真正的带权重心后返回答案（Query函数有详细注释）

### 注意事项
1.要开long long （反正有6秒你开gedit就可以把int全部换成long long）

2.贪心跳带权重心，你此时在x点，点分树上x的儿子有y，你看x要不要跳到y，需要检查的是y的分治区域与x直接相连的那个点（near[y]）的答案是否比x的小，而不是检查y的

3.本人太菜在Getroot没有判断vis而TLE了一次

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<vector>
#define ll long long
using namespace std;
ll read()
{
	char ch=getchar();ll h=0,t=1;
	while((ch>'9'||ch<'0')&&ch!='-') ch=getchar();
	if(ch=='-') t=-1,ch=getchar();
	while(ch>='0'&&ch<='9') h=h*10+ch-'0',ch=getchar();
	return h*t;
}
const ll N=100100;
struct edge{ll next,to,w;}a[N<<1];
ll n,q,head[N],cnt,rt,mx[N],siz[N],fa[N],vis[N],sum;
ll d[N],val[N],tofa[N],Root,near[N];
vector<int> erz[N];
/*
  d[x]表示点分树上以x为根的子树的兵队总数
  val[x]表示点分树上以x为根的子树的兵队到达x的代价和
  tofa[x]表示点分树上以x为根的子树的兵队到达x的父亲的代价和
  erz[x]记录点分树上x的儿子
  near[x]表示x的分治区域与x点分树父亲的相邻结点
 */
void Max(ll &a,ll b) {if(b>a) a=b;}
void link(ll x,ll y,ll w)
{
	a[++cnt]=(edge){head[x],y,w};head[x]=cnt;
	a[++cnt]=(edge){head[y],x,w};head[y]=cnt;
}
namespace sp
{
	ll siz[N],dep[N],son[N],top[N],tot,dfn[N],fa[N];
	void dfs1(ll x)
	{
		for(ll i=head[x];i;i=a[i].next)
		{
			ll R=a[i].to;if(R==fa[x]) continue;
			fa[R]=x;siz[R]=1;dep[R]=dep[x]+a[i].w;
			dfs1(R);siz[x]+=siz[R];
			if(siz[R]>siz[son[x]]) son[x]=R;
		}
	}
	void dfs2(ll x)
	{
		top[x]=x;dfn[x]=++tot;
		if(son[fa[x]]==x) top[x]=top[fa[x]];
		if(son[x]) dfs2(son[x]);
		for(ll i=head[x];i;i=a[i].next)
			if(a[i].to!=son[x]&&a[i].to!=fa[x]) dfs2(a[i].to);
	}
	ll LCA(ll x,ll y)
	{
		while(top[x]^top[y])
		{
			if(dep[top[x]]<dep[top[y]]) swap(x,y);
			x=fa[top[x]];
		}
		return dep[x]<dep[y]?x:y;
	}
	ll Dis(ll x,ll y) {return dep[x]+dep[y]-2*dep[LCA(x,y)];}
}
void Getroot(ll x,ll f)
{
	siz[x]=1;mx[x]=0;
	for(ll i=head[x];i;i=a[i].next)
	{
		ll R=a[i].to;if(R==f||vis[R]) continue;
		Getroot(R,x);siz[x]+=siz[R];
		Max(mx[x],siz[R]);
	}
	Max(mx[x],sum-siz[x]);
	if(mx[x]<mx[rt]) rt=x;
}
void solve(ll x,ll f)
{
	vis[x]=1;
	for(ll i=head[x],tt=sum;i;i=a[i].next)
	{
		ll R=a[i].to;if(vis[R]) continue;
		rt=0;sum=siz[R]>siz[x]?tt-siz[x]:siz[R];
		Getroot(R,x);
		fa[rt]=x;near[rt]=R;
		erz[x].push_back(rt);
		solve(rt,x);
	}
}
void Update(ll x,ll e)
{
	ll st=x;d[x]+=e;
	while(x)
	{
		ll dis=sp::Dis(st,fa[x]);
		d[fa[x]]+=e;//加上兵队总数
		val[fa[x]]+=e*dis;//加上到达父亲的代价
		tofa[x]+=e*dis;//加上对父亲的贡献
		x=fa[x];
	}
}
ll Calc(ll x)//询问以x为补给站时的答案
{
	ll res=val[x],st=x;//初值为儿子到x的答案
	while(x)//暴跳点分树父亲
	{
		ll dis=sp::Dis(st,fa[x]);
		res+=(d[fa[x]]-d[x])*dis;//其他兄弟会多走一段路
		res+=val[fa[x]]-tofa[x];//加上其他兄弟对答案的贡献
		x=fa[x];
	}
	return res;
}
ll Query(ll x)
{
	ll tt=Calc(x);
	for(ll i=0,l=erz[x].size();i<l;i++)
		if(Calc(near[erz[x][i]])<tt) return Query(erz[x][i]);
	return tt;
}
int main()
{
	n=read();q=read();
	for(ll i=2;i<=n;i++)
	{
		ll x=read(),y=read(),w=read();
		link(x,y,w);
	}
	sp::dfs1(1);sp::dfs2(1);
	rt=0;sum=mx[0]=n;
	Getroot(1,0);
	Root=rt;
	solve(rt,0);
	for(ll i=1;i<=q;i++)
	{
		ll x=read(),w=read();
		Update(x,w);
		printf("%lld\n",Query(Root));
	}
	return 0;
}

```
写起来真的要比捉迷藏简单多了诶

你来看看咯 https://www.cnblogs.com/xzyxzy/p/9481496.html

~~欢迎给博主提供毒瘤题~~

---

## 作者：BruceW_07 (赞：3)

# [ZJOI2015]幻想乡战略游戏 解题报告 (动态点分治）

[[ZJOI2015]幻想乡战略游戏](https://www.luogu.com.cn/problem/P3345)



## 题意

有一棵大小为 $n$ 的带权树, 每个点有一个权值, 权值可以修改 $q$ 次, 

找出一个补给点 $x$ , 使得 $\sum_{u \in V} val[u] \times dis(x,u)$ 最小, 并求出这个最小值.

<br/>

一句话 : 求带权重心  (zsy说的)

</br>

附加条件 : 树中所有点的度数不超过 $20$.

## 思路

一道你以为复杂度过不了, 但其实是过得了的题.

<br/>

首先, 我们假定先选了一个点 $u$ 作为补给点, 我们可以算出它的所有子节点 $v$ 作为补给点时所需要的代价.

那么我们选取一个代价最小的点, 带权重心就一定在它的子树内;

假若点 $u$ 的代价最小, 那么点 $u$ 就是带权重心.

</br>

所以我们可以得到一个大致思路 : 

先从一个点开始, 每次决定要往哪个子节点走, 然后在这个子节点的子树内递归处理这个子任务.

</br>

那么为了减小递归次数, 我们可以用动态点分治, 沿着点分树一层一层往下处理, 最后经过 $\log n$ 层找到带权重心.

而我们在每次层中的操作就是 : 枚举当前点的每一个子节点, 找出最小的那个, 然后跳向它对应的重心.

</br>

那我们现在的问题就是 : 该如何计算一个点作为补给点时所需的代价.

首先, 有了动态点分治, 我们可以维护一个点作为补给点时, 它在 **点分树中的子树** 中的点到它的中代价, 设为 $v1$, 

那么, 设当前点为 $u$ ,根据 $ft[u]$ ( $u$  在点分树上的父亲) 的 $v1$, 再加上 **一些其他东西** , 我们就可以求出 $ft[u]$ 在点分树中的子树的点到点 $u$ 的总代价, 这样一层一层往上, 那我们就可以得到整棵树到点 $u$ 的代价.

那, 这些 **"其他东西"** 是什么呢?

我们可以把 $ft[u]$ 的子树分为两部分, (注 : 从这里开始, **"子树"** 均指 **点分树上的子树**.)

1. 在点 $u$ 的子树中的部分.
2. 不在点 $u$ 的子树中的部分.

第一部分所需的代价就是 $v1[u]$, 

为了计算第二部分的代价, 我们增添几个值,

1. $v2[u]$ : 表示点 $u$ 子树中的点到 $ft[u]$ 所需的代价.
2. $s2[u]$ : 表示点 $u$ 子树中的点的总权值.

那么第二部分的代价就为 $v1[ft[u]]-v2[u]+dis(u,ft[u])*(s2[fa]-s2[u])$.

可以这样理解 : 

$v1[ft[u]]-v2[u]$ 表示将点 $u$ 的子树的代价去除.

$+dis(u,ft[u])*(s2[fa]-s2[u])$ 表示将到 $ft[u]$ 的代价转为到 $u$ 的代价.

</br>

由上可得, 求一个点的代价的时间复杂度为 : 在点分树上逐层向上的 $\log n$ 乘上算 $dis$ 的 $\log n$, 总共为 $O(\log^2 n)$.

再乘上之前的复杂度, 得到一次询问的复杂度为 $O(20\log^3 n)$,

那么总复杂度为 $O(20n\log^3 n)$ (因为 $q$ 和 $n$ 是相同规模的), 大概有 $10^9$, 看起来就很不靠谱, 但是如果把用树剖求 $lca$, 这个复杂度就跑不满, 再加上 $6s$ 的时限, 还是可以过的, 并且洛谷上最优解总时间只有 $500$ 多毫秒....





## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int _=1e5+7;
const int __=2e5+7;
const int L=20;
const int inf=0x3f3f3f3f;
bool be;
int n,q,dep[_],sz[_],top[_],son[_],fat[_],rt,minx,ft[_],rtt[__];   // v1: to self  v2: to father
ll v1[_],v2[_],s2[_],dis[_];
int lst[_],nxt[__],to[__],tot;
ll len[__];
bool vis[_];
bool en;
void add(int x,int y,ll w){ nxt[++tot]=lst[x]; to[tot]=y; len[tot]=w; lst[x]=tot; }
void dfs1(int u,int fa){
  fat[u]=fa;
  dep[u]=dep[fa]+1;
  for(int i=lst[u];i;i=nxt[i]){
    int v=to[i];
    if(v==fa) continue;
    dis[v]=dis[u]+len[i];
    dfs1(v,u);
    sz[u]+=sz[v];
    if(sz[v]>sz[son[u]]) son[u]=v;
  }
}
void dfs2(int u){
  if(son[u]){
    top[son[u]]=top[u];
    dfs2(son[u]);
  }
  for(int i=lst[u];i;i=nxt[i])
    if(!top[to[i]]){
      top[to[i]]=to[i];
      dfs2(to[i]);
    }
}
int Lca(int x,int y){
  while(top[x]!=top[y]){
    if(dep[top[x]]<dep[top[y]]) swap(x,y);
    x=fat[top[x]];
  }
  return dep[x]<=dep[y] ?x :y;
}
ll dist(int x,int y){ return dis[x]+dis[y]-2*dis[Lca(x,y)]; }
void g_rt(int u,int fa,int sum){
  int maxn=0; sz[u]=1;
  for(int i=lst[u];i;i=nxt[i]){
    int v=to[i];
    if(vis[v]||v==fa) continue;
    g_rt(v,u,sum);
    sz[u]+=sz[v];
    maxn=max(maxn,sz[v]);
  }
  maxn=max(maxn,sum-sz[u]);
  if(maxn<minx){ minx=maxn; rt=u; }
}
void init(int u,int lrt,int sum){
  minx=inf;
  g_rt(u,0,sz[u]<sz[lrt] ?sz[u] :sum-sz[lrt]);
  sum=sz[u];
  ft[rt]=lrt; 
  vis[rt]=1; u=rt;
  for(int i=lst[u];i;i=nxt[i])
    if(!vis[to[i]]){
      init(to[i],u,sum);
      rtt[i]=rt;
    }
  rt=u;
  vis[rt]=0;
}
void modify(int x,ll w){
  int u=x,fa=ft[u];
  ll len;
  while(fa){
    len=dist(fa,x);
    //printf("u: %d fa: %d len: %d\n",u,fa,len);
    v1[fa]+=w*len;
    v2[u]+=w*len;
    s2[u]+=w;
    u=ft[u]; fa=ft[u];
  }
  s2[u]+=w;
}
ll cst(int x){
  int u=x,fa=ft[u];
  ll len,res=v1[x];
  while(fa){
    len=dist(x,fa);
    res+=v1[fa]-v2[u]+len*(s2[fa]-s2[u]);
    u=ft[u]; fa=ft[u];
  }
  return res;
}
ll query(){
  int u=rt;
  ll ans=1e17;
  while(u){
    ans=min(ans,cst(u));
    int x=0;
    ll minx=1e17;
    for(int i=lst[u];i;i=nxt[i]){
      if(!rtt[i]) continue;
      int v=to[i];
      ll tmp=cst(v);
      if(tmp<minx){ minx=tmp; x=rtt[i]; }
    }
    u=x;
  }
  return ans;
}
int main(){
  //freopen("x.in","r",stdin);
  //freopen("x.out","w",stdout);
  cin>>n>>q;
  int x,y; ll w;
  for(int i=1;i<n;i++){
    scanf("%d%d%lld",&x,&y,&w);
    add(x,y,w);
    add(y,x,w);
  }
  init(1,0,n);
  dfs1(1,0);
  top[1]=1;
  dfs2(1);
  for(int i=1;i<=q;i++){
    scanf("%d%lld",&x,&w);
    modify(x,w);
    printf("%lld\n",query());
  }
}
```



---

## 作者：nosta (赞：3)

树剖的做法：

令1为树根，T=Σd[i],sum[x]是子树x中的d之和，dis[x]是节点x的带权深度。

对于节点x的儿子y，边长为w，如果y比x更优，则(T-sum[y])\*w-sum[y]\*w<=0即sum[y]>=T/2。

换句话说，若存在sum[y]>T/2，显然y更优，且y只存在一个（对于x）；若存在sum[y]=T/2，(1个或2个)，因为y的子树内都不存在sum>T/2的点，所以y就是一个最优解，不必递归地做。

考虑一类暴力求出最优点：从根出发依次进入sum>T/2的儿子，最深的那个点即为带权重心。这可以树剖维护sum/区间最大值，如果右半区间(较深)存在>=T/2，即向右跳转。

设已经求出了最优点R，答案是Σ(d[i]\*dis[i]+d[i]\*dis[R]-2\*d[i]\*dis[lca(R,i)])，套路地维护就行了。


```cpp
#include <bits/stdc++.h>
#define ll long long 
#define trvl(x,i,y) for(int i=ehd[x],y; y=to[i],i; i=lst[i]) 
#define ls (x<<1)
#define rs (x<<1|1)
using namespace std;

const int N=1e5+10;

int n,m;
int ehd[N],to[N<<1],len[N<<1],lst[N<<1];
int fa[N],siz[N],son[N],top[N],id[N],dfn[N];
ll S,T,dis[N];

void insert(int x,int y,int w) {
	static int cnt=0;
	to[++cnt]=y,len[cnt]=w,lst[cnt]=ehd[x],ehd[x]=cnt;
	to[++cnt]=x,len[cnt]=w,lst[cnt]=ehd[y],ehd[y]=cnt;
}
void dfs1(int x,int p) {
	fa[x]=p; siz[x]=1;
	trvl(x,i,y) if(y!=p) {
		dis[y]=dis[x]+len[i];
		dfs1(y,x);siz[x]+=siz[y];
		if(siz[y]>siz[son[x]]) son[x]=y;
	}
}
void dfs2(int x,int t) {
	static int cnt=0;
	top[dfn[id[x]=++cnt]=x]=t;
	if(son[x]) dfs2(son[x],t);
	trvl(x,i,y) if(son[x]!=y&&fa[x]!=y) dfs2(y,y);
}

int tag[N<<2],mx[N<<2];
ll c[N<<2],s[N<<2];

void psd(int x) {
	if(!tag[x]) return;
	c[ls]+=s[ls]*tag[x],mx[ls]+=tag[x],tag[ls]+=tag[x];
	c[rs]+=s[rs]*tag[x],mx[rs]+=tag[x],tag[rs]+=tag[x];
	tag[x]=0;
}
void upd(int x) {
	mx[x]=max(mx[ls],mx[rs]);
	c[x]=c[ls]+c[rs];
}
void build(int x,int l,int r) {
	if(l==r) {
		s[x]=dis[dfn[l]]-dis[fa[dfn[l]]];
		return;
	}
	int mid=(l+r)>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	s[x]=s[ls]+s[rs];
}
int find(int x,int l,int r) {
	if(l==r) return dfn[l];
	int mid=(l+r)>>1; psd(x);
	if(mx[rs]*2>T) return find(rs,mid+1,r);
	return find(ls,l,mid);
}
void mdf(int x,int l,int r,int L,int R,ll w) {
	if(L<=l&&r<=R) {
		c[x]+=s[x]*w,mx[x]+=w,tag[x]+=w;
		return;
	}
	int mid=(l+r)>>1; psd(x);
	if(L<=mid) mdf(ls,l,mid,L,R,w);
	if(mid<R) mdf(rs,mid+1,r,L,R,w);
	upd(x);
}
ll qry(int x,int l,int r,int L,int R) {
	if(L<=l&&r<=R) return c[x];
	int mid=(l+r)>>1; ll c=0; psd(x);
	if(L<=mid) c+=qry(ls,l,mid,L,R);
	if(mid<R) c+=qry(rs,mid+1,r,L,R);
	return c;
}
void modify(int x,int w) {
	for(; x; x=fa[top[x]]) mdf(1,1,n,id[top[x]],id[x],w);
}
ll query(int x,ll w=0) {
	for(; x; x=fa[top[x]]) w+=qry(1,1,n,id[top[x]],id[x]);
	return w;
}

int main() {
	scanf("%d%d",&n,&m);
	for(int x,y,w,i=n; --i; ) {
		scanf("%d%d%d",&x,&y,&w);
		insert(x,y,w);
	}
	dfs1(1,0);
	dfs2(1,1);
	build(1,1,n);
	for(int x,w; m--; ) {
		scanf("%d%d",&x,&w);
		modify(x,w);
		S+=dis[x]*w;
		T+=w;
		x=find(1,1,n);
		printf("%lld\n",S+T*dis[x]-2*query(x));
	}
	return 0;
}

```

---

## 作者：wrpwrp (赞：1)

[一刀999，装备可回收](https://www.cnblogs.com/HN-wrp/p/12832861.html)  
发现题解里面对于信息维护的来由讲得似乎不是很清楚就来发了下题解。  
显然，一棵树的带权重心最多只有两个，最少会有一个，而且在这两个点的答案一定相等。（都是带权重心当然相等）鉴于点分治的写法貌似并不太需要这样的分析，就不说了。~~我不会~~  
首先建出一颗点分树，然后考虑在点分树上跳儿子来保证复杂度，于是我们就需要快速算出所有点到这个重心的带权距离和。~~由于这题是点分树~~，考虑在点分树上维护一些信息来快速计算这个东西。  
对于我们当前枚举到的这个点$x$，一部分答案贡献来自点分树上$x$的子树以内，这部分可以直接记录一个$dsum[x]$表示在点分树上$x$的子树内的所有点到$x$的距离和。另一部分来自子树外，我们先只考虑$x$在点分树上的父节点$fa[x]$的子树里的点对这里的贡献，至于$fa[fa[x]]$可以以此类推。那么这个贡献就又分为两部分，一部分是$fa[x]$的子树内根不为$x$的子树内的点到$fa[x]$的距离。这个时候显然如果直接使用$dsum[fa[x]]$会导致重复计算，所以要记录一个$fsum[x]$来表示$x$这个子树内的所有点到$fa[x]$的距离和。那么这一部分的答案贡献就是$dsum[fa[x]]-fsum[x]$。那么还有一部分的答案就是这些点都到了$fa[x]$之后再到$x$的距离和，那这部分的答案就是$dis(fa[x],x)\times(ssum[fa[x]]-ssum[x])$。这里的$ssum[x]$就是$x$子树内的$size$之和。$dis$的处理也需要树剖来维护。然后向上爬点分树的时候注意一下，哪些地方应该用原始的$x$，哪些地方应该用向上跳了的结点就可以了。具体的实现在代码里。时间复杂度是$O(nlogn^3)$，由于树剖常数小，可以跑过。  
然后我写的时候有一个想法，在于为什么不能直接维护一个点和根的关系呢？这样不就$O(1)$了吗？后来想想发现，我们的算法是基于外部的点要到$x$必须要经过$x$在点分树上的祖先才能够做到枚举的。这点要想通我个人认为还是很重要的。  
upd:一个要注意的一点是在求答案的时候要在原树上找儿子，在点分树上跳重心。
```cpp
#include <cstdio>
using namespace std;
#define R register
#define LL long long
const int MAXN=5e5+10;
inline int read() {
	int x=0,f=1; char a=getchar();
	for(;a>'9'||a<'0';a=getchar()) if(a=='-') f=-1;
	for(;a>='0'&&a<='9';a=getchar()) x=x*10+a-'0';
	return x*f;
}
inline int max(int x,int y) { return x > y ? x : y; }
inline int min(int x,int y) { return x < y ? x : y; }
int n,q;
namespace Graph {
	int cnt,head[MAXN];
	struct edge { int to,w,next; } e[MAXN<<1];
	inline void add(int x,int y,int w) {
		e[++cnt]={y,w,head[x]}; head[x]=cnt; 
	}
	int dep[MAXN],dis[MAXN],fa[MAXN],son[MAXN],siz[MAXN],top[MAXN];
	inline void dfs1(int x,int fx) {
		fa[x]=fx; dep[x]=dep[fx]+1; siz[x]=1;
		for(R int i=head[x];i;i=e[i].next) {
			int y=e[i].to; if(y==fx) continue;
			dis[y]=dis[x]+e[i].w; dfs1(y,x); siz[x]+=siz[y];
			if(siz[y]>siz[son[x]]) son[x]=y;
		}
	}
	inline void dfs2(int x,int topx) {
		top[x]=topx;
		if(son[x]) dfs2(son[x],topx);
		for(R int i=head[x];i;i=e[i].next) {
			int y=e[i].to; 
			if(y==fa[x]||y==son[x]) continue;
			dfs2(y,y);
		}
	}
	inline int Lca(int x,int y) {
		while(top[x]!=top[y]) 
			if(dep[top[x]]>dep[top[y]]) x=fa[top[x]];
			else y=fa[top[y]];
		return dep[x]<dep[y]?x:y;
	}
	inline int Dist(int x,int y) {
		return dis[x]+dis[y]-dis[Lca(x,y)]*2;
	}
	inline void Build() {
		dfs1(1,0); dfs2(1,1);
	}
}
namespace Tree {
	int Cnt,Head[MAXN];
	struct Edge { int to,rt,next; } E[MAXN<<1];
	inline void Add(int x,int y,int rt) {
		E[++Cnt]={ y, rt, Head[x] }; Head[x]=Cnt; 
	}
	int RT,Root,mx[MAXN],vis[MAXN],siz[MAXN],total,fa[MAXN];
	inline void findrt(int x,int fx) {
		mx[x]=0; siz[x]=1;
		for(R int i=Graph::head[x];i;i=Graph::e[i].next) {
			int y=Graph::e[i].to;
			if(y==fx||vis[y]) continue;
			findrt(y,x); siz[x]+=siz[y];
			mx[x]=max(mx[x],siz[y]);
		}
		mx[x]=max(mx[x],total-siz[x]);
		if(mx[x]<mx[Root]) Root=x;
	}
	inline void build(int x,int fx) {
		fa[x]=fx; vis[x]=1;
		for(R int i=Graph::head[x];i;i=Graph::e[i].next) {
			int y=Graph::e[i].to; if(vis[y]) continue;
			total=siz[y]; Root=0;
			findrt(y,0); Add(x,y,Root); 
			build(Root,x);
		}
	}
	inline void Build() {
		mx[0]=0x7f7f7f7f;
		Root=0; findrt(1,0);findrt(Root,0); RT=Root; build(Root,0);
	}
	LL sums[MAXN],sumd[MAXN],sumf[MAXN];
	inline void Modify(int x,int k) {
		sums[x]+=k;
		for(R int i=x;fa[i];i=fa[i]) {
			int len=Graph::Dist(x,fa[i]);
			sums[fa[i]]+=k;
			sumd[fa[i]]+=1LL*k*len;
			sumf[i]+=1LL*k*len;
		}
	}
	inline LL Count(int x) {
		LL res=sumd[x];
		for(R int i=x;fa[i];i=fa[i]) {
			int len=Graph::Dist(x,fa[i]);
			res+=(sums[fa[i]]-sums[i])*len;
			res+=sumd[fa[i]]-sumf[i];
		}
		return res;
	}
	inline LL Ask(int x) {
		LL res=Count(x);
		for(R int i=Head[x];i;i=E[i].next) {
			int y=E[i].to;
			if(Count(y)<res) return Ask(E[i].rt);
		}
		return res;
	}
	inline LL Ask() { return Ask(RT); }
}
int main() {
//	freopen("a.in","r",stdin);
//	freopen("a.out","w",stdout);
	n=read(); q=read();
	for(R int i=1;i<n;i++) {
		int x=read(),y=read(),z=read();
		Graph::add(x,y,z); Graph::add(y,x,z);
	}
	Graph::Build(); Tree::Build();
	while(q--) {
		int x=read(),y=read();
		Tree::Modify(x,y);
		printf("%lld\n",Tree::Ask());
	}
	return 0;
}
```

---

## 作者：Kinandra (赞：1)

标签: 动态点分治.

**之前代码点分治部分有点错误， 现已更正**

#### Part 1

先不考虑修改, 即求树的一个带权重心. 

将任意点设为根, 维护:

* $size_u$ 表示以 $u$ 为根的子树的权值 $d$ 和.

那么将关键点(即补给站)从 $u$ 移动到 $u$ 的某一个儿子 $v$ 的会使答案增加 $dis_{u,v}(size_{root}-size_v)-dis_{u,v}size_v=dis_{u,v}(size_{root}-2size_v)$, 当 $2size_v>size_{root}$ 时答案更优, 显然满足条件的 $v$ 至多只有一个, 容易证明带权重心一定会在子树 $v$ 内.

#### Part 2

考虑运用点分树来支持维护修改操作.

(对于点分树的一个描述性的定义)点分治的过程: 选取重心, 将树分割成若干棵子树, 递归地处理子树. 这个过程蕴含了一个树形结构:将**树的重心**与**分割后的若干子树重心**分别连接, **递归处理**分割后的子树, 可以得到一棵**有根树**, 我们称这棵树为**点分树**.

将**重心** $u$ 作为原树的根上, 对于 $u$ 在**点分树**上的一个儿子 $v$ , 设 $w$ 为 $u$ 到 $v$ 在**原树**路径上与 $u$ 相邻的点(可能与 $v$ 重合). 若有 $2size_w>size_{u}$ , 则**带权重心**在以 $w$ 为根的子树里, 否则**带权重心**即为 $u$ . 对于前一种情况, 考虑将所有**原树**上到 $w$ 需要经过 $u$ 的军队移动到 $w$ , 这样做显然带权重心不会改变, 并且我们可以忽略 $w$ 子树外的点(点上无军队)从而得到一个子问题, 显然这个子问题涉及的树就是 $v$ 在**点分树**上的子树, 递归处理子问题就好了. 注意到我们移动了我们将要经过 $u$ 的军队移动到了 $w$ , 我们要更新 $d_w$.

如上过程在操作上有两个不是很好做的地方:

1. 判断 $2size_w>size_{root}$.
2. 更新 $d_w$.

注意在递归子问题的时候树的形态会发生改变(包括**根节点的改变**和**结点的删除**), $size$ 是不能直接维护的, 考虑维护:

* $size'_v$ 表示在**点分树**上以点 $v$ 为根的子树 $d$ 值的和.

显然 $size_w=size'_v$ , 因为我们求子问题涉及的树的形态与**点分树**的形态是一致的, $size'$ 是可以维护的, 同时这样我们还解决了更新 $d_w$ 的问题, 由于**点分树**树高级别是 $\mathcal O(\log n)$ 的, 我们暴力地用 $\mathcal O(\log n)$ 的时间修改 $w$ 和其**祖先**的$size'$就好了.

这样我们就可以利用点分树找到**带权重心**了, 由于题目保证了 $deg\leqslant 20$ , 查询一次**带权重心**$\mathcal O((deg+\log n)\times\log n)$ 的时间是可以接受的.

#### Part 3

找到带权重心后, 考虑如何求答案(在此之前先撤销更新 $d$ 的影响). 本部分的所有操作和维护的信息都是在 **点分树** 上的, 下文不再强调.

简要来讲就是从**带权重心**暴力向上跳, 统计其所有祖先子树内的答案.

具体地说, 考虑维护:

* $f_u$ 表示将 $u$ 子树所有军队移动到 $u$ 上的花费, 即 $\sum dis_{u,v}*d_v$ , 其中 $v$ 在 $u$ 的子树内.
* $g_u$ 表示将 $u$ 子树所有军队移动到 $fa_u$ 上的花费, 即 $\sum dis_{fa_u,v}*d_v$ , 其中 $v$ 在 $u$ 的子树内, 根节点不需要维护 $g$.

由于一个点的祖先数是 $\mathcal O(\log n)$, 预处理出每个点到所有祖先的 $\mathcal O(\log n)$ 个 $dis$ , 进行修改操作时就可以暴力地维护啦.

统计答案时设两个点 $x, y$, 初始将 $x$ 设为**带权重心** $u$, $y$ 设为 $fa_x$,  $x$ 子树内的点对答案的贡献是 $f_x$. 每次加上 $y$ 子树除去 $x$ 子树的贡献, 这些点显然是要走到 $y$ , 再走到 $u$, 所以贡献是 $ dis_{u,y}(size'_y-size'_x)+f_y-g_x$ , 然后让 $x, y$ 一起向上跳就好了, 这个部分的复杂度是 $\mathcal O(log n)$ 的.

总复杂度 $\mathcal O(Q(deg+\log n)\times\log n)$.

代码稍微贴一下, 效率一般, 里头将**点分树**封装在 `PD_Tree` 里, **原树**封装在 `Tree` 里.

```cpp
#include <cstdio>
#include <iostream>
#include <vector>
using namespace std;
int read();

int n, Q;

int Dis(int, int);

struct PD_Tree {
    int fa[100005], root;
    int hd[100005], nx[100005], to[100005], link[100005], cnt;
    vector<int> dis[100005];
    long long f[100005], g[100005], sz[100005];
    void add(int f, int t) { nx[++cnt] = hd[f], hd[f] = cnt, to[cnt] = t; }
    void dfs(int u) {
        int x = fa[u];
        while (x) dis[u].push_back(Dis(x, u)), x = fa[x];
        for (int i = hd[u]; i; i = nx[i]) dfs(to[i]);
    }
    void init() {
        for (int i = 1; i <= n; ++i)
            if (fa[i])
                add(fa[i], i);
            else
                root = i;
        dfs(root);
    }
    void modi(int u, int d) {
        int x = fa[u], y = u, cnt = 0;
        sz[u] += d;
        while (x) {
            sz[x] += d;
            f[x] += 1ll * d * dis[u][cnt], g[y] += 1ll * d * dis[u][cnt++];
            x = fa[x], y = fa[y];
        }
    }
    void tmodi(int u, int d) {
        while (u) sz[u] += d, u = fa[u];
    }

    int stu[102], std[102], top;

    void calc(int u) {
        long long res = f[u];
        int x = u, y = fa[x], cnt = 0;
        while (fa[x]) {
            res += dis[u][cnt++] * (sz[y] - sz[x]) + f[y] - g[x];
            x = fa[x], y = fa[y];
        }
        printf("%lld\n", res);
    }

    void work() {
        int x = root, u, d;
        while (1) {
            u = 0;
            for (int i = hd[x]; i; i = nx[i]) {
                if (sz[to[i]] * 2 > sz[x]) {
                    u = to[i];
                    break;
                }
            }

            if (!u) {
                u = x;
                while (top) tmodi(stu[top], -std[top]), top--;
                return calc(u);
            }

            ++top, tmodi(stu[top] = link[u], std[top] = sz[x] - sz[u]), x = u;
        }
    }
} t2;

struct Tree {
    int hd[100005], nx[200005], to[200005], w[200005], cnt;
    void add(int f, int t, int wei) {
        nx[++cnt] = hd[f], hd[f] = cnt, to[cnt] = t, w[cnt] = wei;
    }
    int vis[100005], sz[100005], mx[100005], rt, tot;
    void dfs(int u, int fa) {
        sz[u] = 1, mx[u] = 0;
        for (int i = hd[u], v; i; i = nx[i]) {
            v = to[i];
            if (vis[v] || v == fa) continue;
            dfs(v, u), sz[u] += sz[v], mx[u] = max(mx[u], sz[v]);
        }
        if (rt == -1 || max(tot - sz[u], mx[u]) < max(tot - sz[rt], mx[rt]))
            rt = u;
    }

    void build(int u, int F) {
        rt = -1, dfs(u, 0), t2.fa[rt] = F, t2.link[rt] = u, vis[rt] = 1;
        if (sz[u] == 1) return;
        int trt = rt;
        for (int i = hd[rt], v; i; i = nx[i])
            if (!vis[v = to[i]]) {
                tot = (sz[v] > sz[trt] ? sz[u] - sz[trt] : sz[v]);
                build(v, trt);
            }
    }

    int fa[100005][20], dep[100005];
    long long dis[100005];
    void init(int u) {
        dep[u] = dep[fa[u][0]] + 1;
        for (int i = 1; i <= 17; ++i) fa[u][i] = fa[fa[u][i - 1]][i - 1];
        for (int i = hd[u], v; i; i = nx[i])
            if ((v = to[i]) != fa[u][0])
                fa[v][0] = u, dis[v] = dis[u] + w[i], init(v);
    }

    int lca(int u, int v) {
        if (dep[u] < dep[v]) swap(u, v);
        for (int i = 17; i >= 0; --i)
            if (dep[fa[u][i]] >= dep[v]) u = fa[u][i];
        if (u == v) return u;
        for (int i = 17; i >= 0; --i)
            if (fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];
        return fa[u][0];
    }
} t1;

int Dis(int u, int v) {
    return t1.dis[u] + t1.dis[v] - 2 * t1.dis[t1.lca(u, v)];
}

int main() {
    n = read(), Q = read();
    for (int i = 1, u, v, w; i < n; ++i)
        u = read(), v = read(), w = read(), t1.add(u, v, w), t1.add(v, u, w);
    t1.tot = n, t1.build(1, 0), t1.init(1), t2.init();
    for (int i = 1, u; i <= Q; ++i) u = read(), t2.modi(u, read()), t2.work();
    return 0;
}

int read() {
    int x = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9') f = (c == '-') ? -1 : f, c = getchar();
    while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * f;
}


```


---

## 作者：妩媚的ak萝莉 (赞：1)

洛谷上就有，但为防被封号，建议没把握先去loj上交（滑稽保命）

## 题解

当动态点分治模版打得，但是之前我对[树的带权重心](https://www.luogu.org/blogAdmin/article/edit/156026)一无所知，真的差点把命做没了。。（链接里有介绍，在文章的“树上的其他方法”里）

然后大家看完这题，最关注的一定是那个所有度数小于20（或者你已经了解带权重心马上想到那个性质？），一般都会先冒出这样的想法，这题应该一定是对节点枚举所有儿子再维护什么数据结构做。

一考虑果然性质奇好，当对一个节点枚举带权重心在一个儿子的子树时其他儿子的子树包括节点本身的有效信息只剩一个：除此儿子的子树外所有的点权和，问题即转移到此儿子的子树中，再结合树的带权重心的性质，不难看出是道动态点分治。

[动态点分治介绍](https://www.cnblogs.com/bztMinamoto/p/9489473.html)(贴大佬博客)

做法是对于点分树上每个节点维护两个数组Sd,Sdis,Sd表示此重心对应树的点权和，Sdis表示此重心对应树到其点分树上的父亲的dv*dis的和，修改时跳点分树$O(logn)$修改，重新计算一次答案需O(logn)复杂度（一直从点分树顶往下走直到达到带权重心性质中所有$\Delta W$都大于等于0时，最多走$O(logn)$层）

## 代码：
```cpp
#include <iostream>
#include <stdio.h>
#include <string.h>
using namespace std;
typedef long long ll; 
const int N=2e5+50;
int n,Q,cnt,Ecnt,RtG;
int head[N],pre[N],to[N],len[N],shan[N];
int Exu[N],xuE[N],Edep[N],Minn[N][20],Minp[N][20],dis[N],Log[N];
int szG[N],headG[N],preG[N],toG[N],Fa[N],Con[N],Sum[N],Sumd[N];
ll ans,Sumdis[N];

void addedge(int u,int v,int w){
    cnt++;
    pre[cnt]=head[u];
    head[u]=cnt;
    to[cnt]=v;
    len[cnt]=w;
}

void addedgeG(int u,int v,int id){
    cnt++;
    preG[cnt]=headG[u];
    headG[u]=cnt;
    toG[cnt]=v;
    Con[cnt]=id;
}

void dfsE(int now,int fa,int dep){
    Ecnt++,Exu[Ecnt]=now,Edep[Ecnt]=dep,xuE[now]=Ecnt;
    for(int i=head[now];i;i=pre[i]){
        int nex=to[i];
        if(nex==fa) continue;
        dis[nex]=dis[now]+len[i];
        dfsE(nex,now,dep+1);
        Ecnt++,Exu[Ecnt]=now,Edep[Ecnt]=dep;
    }
}

void InitE()
{
    dfsE(1,-1,1);
    int log_cnt=0;
    for(int i=1;i<2*n;i++)
    {
        if((1<<(log_cnt+1))>=i) Log[i]=log_cnt;
        else Log[i]=++log_cnt;
    }
    for(int i=1;i<2*n;i++)
        Minn[i][0]=Edep[i],Minp[i][0]=i;
    for(int a=1;(1<<a)<2*n;a++)
        for(int i=1;i+(1<<a)-1<2*n;i++)
        {
            if(Minn[i][a-1]<Minn[i+(1<<(a-1))][a-1]) Minn[i][a]=Minn[i][a-1],Minp[i][a]=Minp[i][a-1];
            else Minn[i][a]=Minn[i+(1<<(a-1))][a-1],Minp[i][a]=Minp[i+(1<<(a-1))][a-1];
        }
}

inline int lca(int u,int v){
    int l=min(xuE[u],xuE[v]),r=max(xuE[u],xuE[v]),a=Log[r-l+1];
    if(Minn[l][a]<Minn[r-(1<<a)+1][a]) return Exu[Minp[l][a]];
    return Exu[Minp[r-(1<<a)+1][a]];
}

inline ll Dis(int u,int v){
    return (ll)(dis[u]+dis[v]-2*dis[lca(u,v)]);
}

void dfsszG(int now,int fa){
    szG[now]=1;
    for(int i=head[now];i;i=pre[i])
    {
        int nex=to[i];
        if(nex==fa || shan[i]) continue;
        dfsszG(nex,now);
        szG[now]+=szG[nex];
    }
}

void findG(int now,int fa,int& maxv,int& maxp,int Asz){
    int Maxv=Asz-szG[now];
    for(int i=head[now];i;i=pre[i])
    {
        int nex=to[i];
        if(nex==fa || shan[i]) continue;
        findG(nex,now,maxv,maxp,Asz);
        Maxv=max(Maxv,szG[nex]);
    }
    if(Maxv && Maxv<maxv) maxv=Maxv,maxp=now;
}

void buildG(int u,int lG,int Id)
{
    int maxv=N,maxp=-1;
    dfsszG(u,-1);
    findG(u,-1,maxv,maxp,szG[u]);
    int G=(maxp==-1?u:maxp);
    if(lG!=-1){
        addedgeG(lG,G,Id);
        addedgeG(G,lG,Id);
        Fa[G]=lG;
    }
    else RtG=G;
    Sum[G]=szG[u];
    if(maxp==-1) return;
    for(int i=head[G];i;i=pre[i])
        shan[i]++,shan[(i&1)?(i+1):(i-1)]++;
    for(int i=head[G];i;i=pre[i])
        if(shan[i]==1)
            buildG(to[i],G,i);
    for(int i=head[G];i;i=pre[i])
        shan[i]--,shan[(i&1)?(i+1):(i-1)]--;
}

void InitG(){
    cnt=0;
    buildG(1,-1,946);
}

void update(int ui,ll ei)
{
    int now=ui;
    while(Fa[now]){
        Sumd[now]+=ei;
        Sumdis[now]+=ei*Dis(Fa[now],ui);
        now=Fa[now];
    }
    Sumd[RtG]+=ei;
    Sumdis[RtG]+=ei*Dis(RtG,ui);
}

void Solve(int now,ll Add)
{
    ll ret=Add;
    for(int i=headG[now];i;i=preG[i])
        if(toG[i]!=Fa[now])
            ret+=Sumdis[toG[i]];
    for(int i=headG[now];i;i=preG[i])
    {
        int nex=toG[i];
        if(nex==Fa[now]) continue;
        if(2*Sumd[nex]>Sumd[now]){
            ll osd=Sumd[now]-Sumd[nex],Dd=len[Con[i]],nAdd=ret-Sumdis[nex]+osd*Dd;
            update(to[Con[i]],osd);
            Solve(nex,nAdd);
            update(to[Con[i]],-osd);
            return;
        }
    }
    ans=ret;
}

int main()
{
    scanf("%d%d",&n,&Q);
    for(int i=1;i<n;i++){
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        addedge(u,v,w);
        addedge(v,u,w);
    }
    InitE();
    InitG();
    while(Q--)
    {
        int ui,ei;
        scanf("%d%d",&ui,&ei);
        update(ui,ei);
        Solve(RtG,0);
        printf("%lld\n",ans);
    }
    return 0;
}
```

---

## 作者：ButterflyDew (赞：1)

简单来说，这题就是一个修改点权询问带权重心的题。

首先我们考虑随便选择一个点作为答案，为了方便，暂且将这个点当做树的根。

考虑将答案移向相邻点（也相当于换根）的条件，令$sumd_i$代表$i$点的子树的带权大小也就是$\sum\limits_{v\in i}d_v$。若想从$now$移动到$v$，设$dis_{now,v}$代表从$now$到$v$的长度。

那么移动后的答案改变量就是$(sumd_{now}-sumd_v-sumd_v)\times dis_{now,v}$,于是当$sumd_{now}<sumd_v\times 2$时，我们进行移动，可以简单的证明，每个点最多只有一个儿子可以移动过去。

暴力移动并进行换根是行不通的，考虑构造点分树进行移动与换根。

---

点分树有几个显著特点

1. 树高$\log$，维护信息暴力跳就可以了
2. 点分树的子树是原树的一个联通快，这也是在点分树上进行换根操作的基础。

对这个题，我们先建好点分树，然后对每个点维护几个信息。

$d_i$表示自己点权，$sumd_i$表示$i$点点分树的子树$\sum d$，$sumf_i$表示点分树子树所有点到点分树父亲的答案（如果一个点没有父亲，可以简单的指向它自己）

修改操作比较简单，直接在点分树向上暴力修改即可。

查询的时候，先选定点分树的根，然后遍历点分树的儿子比较$sumd$，注意这里点分树的$sumd$和本身原树上儿子的$sumd$的值是一样的，所以更严谨的说其实找的还是原树的儿子。

如果可以移动，那么答案点一定在点$v$的子树中（点分树的），然后我们考虑把根换成$v$

如图，$now$是当前节点，$v$是应该移向的分治子树，$w$是在$v$的子树中与$now$在原树中直接相连的点。

![](https://i.loli.net/2018/12/05/5c07828214cd7.png)

然后我们直接把$now$及绿色子树的点权给$w$，并在外部加上$now$和绿色子树本身的答案。这样就把$v$子树外面的点等价到了内部并且统计了外部答案。注意更新了$w$之后还要把$w$父亲的信息同样更新。

![](https://i.loli.net/2018/12/05/5c0782826ec02.png)

然后递归进行这个过程直到找不到一个儿子可以去移动即可，递归回溯时要把$now$加在$w$的信息进行还原。

---

需要$RMQLCA$进行$O(1)$的查询两点间距离保证复杂度为$O(n\log^2n)$，事实上树剖好像也可以跑。

注意这个做法会被菊花树卡掉因为点分树儿子个数可能会很多但题目保证了度数就没关系了啦。

----

**Code:**

```cpp
#include <cstdio>
#include <vector>
#define ll long long
const int N=2e5+10;
int head[N],to[N],Next[N],edge[N],cnt;
void add(int u,int v,int w)
{
    to[++cnt]=v,edge[cnt]=w,Next[cnt]=head[u],head[u]=cnt;
}
namespace RMQLCA
{
    ll dis[N];int dep[N],st[N][20],dfn[N],Log[N],dfs_clock;
    void dfs(int now,int fa)
    {
        dep[now]=dep[fa]+1;
        st[dfn[now]=++dfs_clock][0]=now;
        for(int v,i=head[now];i;i=Next[i])
            if((v=to[i])!=fa)
                dis[v]=dis[now]+edge[i],dfs(v,now),st[++dfs_clock][0]=now;
    }
    void init()
    {
        dfs(1,0);
        for(int i=2;i<=dfs_clock;i++) Log[i]=Log[i>>1]+1;
        for(int j=1;j<=18;j++)
        {
            for(int x,y,i=1;i<=dfs_clock-(1<<j)+1;i++)
            {
                x=st[i][j-1],y=st[i+(1<<j-1)][j-1];
                st[i][j]=dep[x]<dep[y]?x:y;
            }
        }
    }
    ll getdis(int x,int y)
    {
        ll ret=dis[x]+dis[y];
        x=dfn[x],y=dfn[y];
        if(x>y) std::swap(x,y);
        int d=Log[y+1-x],a=st[x][d],b=st[y-(1<<d)+1][d];
        int lca=dep[a]<dep[b]?a:b;
        return ret-(dis[lca]<<1);
    }
}
struct node
{
    int v,w,len;
    node(){}
    node(int v,int w,int len){this->v=v,this->w=w,this->len=len;}
};
std::vector <node> Edge[N];
int siz[N],del[N],fa[N],si,rt,mi,root,n,m;
void dfs(int now,int fa)
{
    siz[now]=1;int mx=0;
    for(int v,i=head[now];i;i=Next[i])
    {
        if((v=to[i])!=fa&&!del[v])
            dfs(v,now),siz[now]+=siz[v],mx=mx>siz[v]?mx:siz[v];
    }
    mx=mx>si-siz[now]?mx:si-siz[now];
    if(mi>mx) mi=mx,rt=now;
}
int getroot(int now){mi=N+1;dfs(now,0);return rt;}
void divide(int now)
{
    del[now]=1;
    for(int v,w,i=head[now];i;i=Next[i])
    {
        if(!del[w=to[i]])
        {
            si=siz[w],fa[v=getroot(w)]=now;
            Edge[now].push_back(node(v,w,edge[i]));
            divide(v);
        }
    }
}
int d[N],sumd[N];ll sumf[N];
void change(int now,int To,int delta)
{
    d[now]+=delta;int las=now;
    while(now!=To)
    {
        sumd[now]+=delta;
        sumf[now]+=RMQLCA::getdis(las,fa[now]?fa[now]:now)*delta;
        now=fa[now];
    }
}
ll cal(int now,int oth,int len)
{
    ll ret=1ll*d[now]*len;
    for(int v,i=0;i<Edge[now].size();i++)
        if((v=Edge[now][i].v)!=oth)
        {
            ret+=sumf[v];
            ret+=1ll*sumd[v]*len;
        }
    return ret;
}
ll query(int now)
{
    ll ret,Ret=0;
    for(int v,w,i=0;i<Edge[now].size();i++)
    {
        if(sumd[v=Edge[now][i].v]<<1>sumd[now])
        {
            ret=cal(now,v,Edge[now][i].len);
            int delta=sumd[now]-sumd[v];
            change(w=Edge[now][i].w,now,delta);
            ret+=query(v);
            change(w,now,-delta);
            return ret;
        }
        Ret+=sumf[v];
    }
    return Ret;
}
int main()
{
    //freopen("data.in","r",stdin);
    //freopen("dew.out","w",stdout);
    scanf("%d%d",&n,&m);
    for(int u,v,w,i=1;i<n;i++)
    {
        scanf("%d%d%d",&u,&v,&w);
        add(u,v,w),add(v,u,w);
    }
    RMQLCA::init();
    mi=N,si=n,root=getroot(1);divide(root);
    for(int u,de,i=1;i<=m;i++)
    {
        scanf("%d%d",&u,&de);
        change(u,0,de);
        printf("%lld\n",query(root));
    }
    return 0;
}
```

---

## 作者：foreverlasting (赞：0)

[题面](https://www.luogu.org/problemnew/show/P3345)

动态点分治。

首先我们要找重心，关于有点权和边权的树，我们该如何找重心呢？

这里需要简证一下重心位置与边权无关。

![](https://cdn.luogu.com.cn/upload/pic/29602.png)

对于一个点$p$，考虑答案是$p$还是会在某个分支中

现在，我们考虑一件奇怪的事情

如果能把点选择在一条边的中间(如图中$p'$)

设$p'$距离左边距离为$x$，距离和为$f(x)$

我们有$f(x)$=$\sum_{q∈L}^n Vq*(dist(p,q)+x)$+$\sum_{q∈R}^n Vq*(dist(p,q)-x)$

然后我们对这条式子求一次导：

$f'(x)$=$\sum_{q∈L}^n Vq$-$\sum_{q∈R}^n Vq$

对于一条边，如果 $f'(0)$ < 0，那么答案一定在这条边的分支里

所以重心与边权无关。

所以大力建构点分树，然后统计答案就好了。

code:
```
//2018.8.20 by ljz
#include<bits/stdc++.h>
using namespace std;
#define res register LL
#define LL long long
#define inf 0x3f3f3f3f
#define eps 1e-15
inline LL read(){
    res s=0;
    bool w=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return w?-s:s;
}
inline void _swap(res &x,res &y){
    x^=y^=x^=y;
}
inline LL _abs(const res &x){
    return x>0?x:-x;
}
inline LL _max(const res &x,const res &y){
    return x>y?x:y;
}
inline LL _min(const res &x,const res &y){
    return x<y?x:y;
}
const LL N=1e5+10;
namespace MAIN{
	LL n,T,RT;
	namespace Tree{
		struct E{
			LL next,to,val;
			E() {}
			E(res next,res to,res val):next(next),to(to),val(val) {} 
		}edge[N<<1];
		LL head[N],cnt;
		inline void addedge(res u,res v,res w){
			edge[++cnt]=E(head[u],v,w),head[u]=cnt;
			edge[++cnt]=E(head[v],u,w),head[v]=cnt; 
		}
		LL dep[N],jump[N][21],dis[N];
		void dfs1(res x,res fax,res depx){
			dep[x]=depx,jump[x][0]=fax;
			for(res i=1;i<=20;i++)jump[x][i]=jump[jump[x][i-1]][i-1];
			for(res i=head[x];~i;i=edge[i].next){
				res tox=edge[i].to;
				if(tox==fax)continue;
				dis[tox]=dis[x]+edge[i].val;
				dfs1(tox,x,depx+1);
			}
		}
		inline LL get_lca(res x,res y){
			if(dep[x]<dep[y])_swap(x,y);
			res pos=dep[x]-dep[y];
			for(res i=20;~i;i--)if(pos&(1<<i))x=jump[x][i];
			if(x==y)return x;
			for(res i=20;~i;i--)if(jump[x][i]!=jump[y][i])x=jump[x][i],y=jump[y][i];
			return jump[y][0];
		}
		inline LL get_dis(res x,res y){
			return dis[x]+dis[y]-(dis[get_lca(x,y)]<<1);
		}
	}
	namespace Point{
		LL sum,w[N],rt,mf[N],siz[N];
		bool vis[N];
		struct E{
			LL next,to,root;
			E() {}
			E(res next,res to,res root):next(next),to(to),root(root) {} 
		}edge[N];
		LL head[N],cnt;
		inline void addedge(res u,res v,res root){
			edge[++cnt]=E(head[u],v,root),head[u]=cnt;
		}
		void getroot(res x,res fax){
			siz[x]=1,w[x]=0;
			for(res i=Tree::head[x];~i;i=Tree::edge[i].next){
				res tox=Tree::edge[i].to;
				if(tox==fax||vis[tox])continue;
				getroot(tox,x);
				siz[x]+=siz[tox],w[x]=_max(w[x],siz[tox]);
			}
			w[x]=_max(w[x],sum-siz[x]);
			if(w[rt]>w[x])rt=x;
		}
		void solve(res x,res fax){
			mf[x]=fax;
			vis[x]=1;
			for(res i=Tree::head[x];~i;i=Tree::edge[i].next){
				res tox=Tree::edge[i].to;
				if(vis[tox])continue;
				sum=siz[tox],rt=0;
				getroot(tox,0);
				addedge(x,tox,rt);
				solve(rt,x);
			}
		}
		inline void init(){
			sum=w[0]=n,rt=0;
			getroot(1,0);
			RT=rt;
			solve(rt,0);
		}
	}
	namespace Action{
		LL sum[N],po[N],ed[N];
		void modify(res x,res y){
			sum[x]+=y;
			for(res i=x;Point::mf[i];i=Point::mf[i]){
				res dist=Tree::get_dis(x,Point::mf[i]);
				sum[Point::mf[i]]+=y;
				po[Point::mf[i]]+=y*dist;
        		ed[i]+=y*dist;
			}
		}
		LL query(res x){
			res tmp=po[x];
			for(res i=x;Point::mf[i];i=Point::mf[i]){
				res dist=Tree::get_dis(x,Point::mf[i]);
				tmp+=dist*(sum[Point::mf[i]]-sum[i])+po[Point::mf[i]]-ed[i];
			}
			return tmp;
		}
		LL calc(res x){
			res tmp=query(x);
			for(res i=Point::head[x];~i;i=Point::edge[i].next){
				res tox=Point::edge[i].to;
				if(query(tox)<tmp)return calc(Point::edge[i].root);
			}
			return tmp;
		}
	}
	inline void MAIN(){
		memset(Tree::head,-1,sizeof(Tree::head));
		memset(Point::head,-1,sizeof(Point::head));
		n=read(),T=read();
		for(res i=1;i<n;i++){
			res u=read(),v=read(),w=read();
			Tree::addedge(u,v,w);
		}
		Tree::dfs1(1,-1,1);
		Point::init();
		while(T--){
			res x=read(),y=read();
			Action::modify(x,y);
			printf("%Ld\n",Action::calc(RT));
		}
	}
}
int main(){
	MAIN::MAIN();
	return 0;
} 
```

---


# [ZJOI2016] 旅行者

## 题目描述

小 Y 来到了一个新的城市旅行。她发现了这个城市的布局是网格状的，也就是有  $n$ 条从东到西的道路和  $m$ 条从南到北的道路，这些道路两两相交形成  $n\times m$ 个路口  $(i,j)$，  $(1\leq i\leq n,1\leq j\leq m)$  

她发现不同的道路路况不同，所以通过不同的路口需要不同的时间。通过调查发现，从路口  $(i,j)$ 到路口  $(i,j+1)$ 需要时间  $r(i,j)$ ，从路口  $(i,j)$ 到路口  $(i+1,j)$ 需要时间  $c(i,j)$ 。注意这里的道路是双向的。小 Y 有  $q$ 个询问，她想知道从路口  $(x1,y1)$ 到路口  $(x2,y2)$ 最少需要花多少时间。

## 说明/提示

### 数据规模与约定
- $n\times m \le 2\times 10^4$。
- $q \le 10^5$。
- $1 \le r(i,j),c(i,j) \le 10^4$。

## 样例 #1

### 输入

```
2 2
2
3
6 4
2
1 1 2 2
1 2 2 1```

### 输出

```
6
7```

# 题解

## 作者：Taduro (赞：14)

考虑分治，当前问题是在$x\in[1,n],y\in[1,m]$的矩形中解决编号在$[1,q]$的询问，可以考虑把矩形的长边切开，变成两个相对均匀的小矩形（类似KD-tree）。

假设直线$x=mid$竖直切开了当前矩形，那么我们要处理的是所有经过这条直线的询问，枚举这条直线上的点，对每个点做一遍单源最短路更新答案。对于不经过直线的询问把它分到两个子问题中。

之后复杂度证明也类似KD-tree，其中跟KD-tree最相似的地方就是我都不会证复杂度。

```c++
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
struct que{
	int x1,x2,y1,y2,h;
}q[100010],tmp[100010];
struct sbfa{
	int x,y,z;
};
priority_queue<sbfa> tm;
bool operator < (sbfa c,sbfa d){return c.z>d.z;}
int dx[4]={0,-1,0,1},dy[4]={-1,0,1,0},ans[100010];
int o[20010],dis[20010];
int n,m,s,w[20010][4],d[20010],c[20010];
inline int id(int x,int y){return (x-1)*m+y;}
inline void dij(int x,int y,int x1,int y1,int x2,int y2,int l,int r){
	sbfa u;
	u.x=x,u.y=y,u.z=0;
	tm.push(u);
	for (int i=x1; i<=x2; i++)
		for (int j=y1; j<=y2; j++)
			dis[id(i,j)]=2e9;
	dis[id(x,y)]=0;
	while (!tm.empty()){
		u=tm.top(); tm.pop();
		x=u.x,y=u.y;
		int a=id(x,y),b;
		if (dis[a]!=u.z) continue;
		for (int i=0; i<4; i++){
			if (x+dx[i]<x1||x+dx[i]>x2) continue;
			if (y+dy[i]<y1||y+dy[i]>y2) continue;
			b=id(x+dx[i],y+dy[i]);
			if (dis[b]>dis[a]+w[a][i]){
				dis[b]=dis[a]+w[a][i];
				u.x=x+dx[i],u.y=y+dy[i],u.z=dis[b];
				tm.push(u);
			}
		}
	}
	for (int i=l; i<=r; i++)
		ans[q[i].h]=min(ans[q[i].h],dis[id(q[i].x1,q[i].y1)]+dis[id(q[i].x2,q[i].y2)]);
}
void solve(int x1,int x2,int y1,int y2,int l,int r){
	if (x2-x1>=y2-y1){
		int mid=(x1+x2)>>1;
		for (int i=y1; i<=y2; i++)
			dij(mid,i,x1,y1,x2,y2,l,r);
		int lp=l-1,rp=r+1;
		for (int i=l; i<=r; i++) tmp[i]=q[i];
		for (int i=l; i<=r; i++){
			if (tmp[i].x1<mid&&tmp[i].x2<mid)
				q[++lp]=tmp[i];
			if (tmp[i].x1>mid&&tmp[i].x2>mid)
				q[--rp]=tmp[i];
		}
		if (lp>=l) solve(x1,mid-1,y1,y2,l,lp);
		if (r>=rp) solve(mid+1,x2,y1,y2,rp,r);
	}
	else{
		int mid=(y1+y2)>>1;
		for (int i=x1; i<=x2; i++) dij(i,mid,x1,y1,x2,y2,l,r);
		int lp=l-1,rp=r+1;
		for (int i=l; i<=r; i++) tmp[i]=q[i];
		for (int i=l; i<=r; i++){
			if (tmp[i].y1<mid&&tmp[i].y2<mid)
				q[++lp]=tmp[i];
			if (tmp[i].y1>mid&&tmp[i].y2>mid)
				q[--rp]=tmp[i];
		}
		if (lp>=l) solve(x1,x2,y1,mid-1,l,lp);
		if (r>=rp) solve(x1,x2,mid+1,y2,rp,r);
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for (int i=1; i<=n; i++)
		for (int j=1; j<m; j++)
			scanf("%d",&d[id(i,j)]);
	for (int i=1; i<n; i++)
		for (int j=1; j<=m; j++)
			scanf("%d",&c[id(i,j)]);
	for (int i=1; i<=n; i++)
		for (int j=1; j<=m; j++){
			int x=id(i,j);
			for (int k=0; k<4; k++){
				if (i+dx[k]<1||i+dx[k]>n) continue;
				if (j+dy[k]<1||j+dy[k]>m) continue;
				if (k==0) w[x][k]=d[id(i,j-1)];
				if (k==1) w[x][k]=c[id(i-1,j)];
				if (k==2) w[x][k]=d[id(i,j)];
				if (k==3) w[x][k]=c[id(i,j)];
			}
		}
	scanf("%d",&s);
	for (int i=1; i<=s; i++){
		scanf("%d%d%d%d",&q[i].x1,&q[i].y1,&q[i].x2,&q[i].y2);
		q[i].h=i;
	}
	memset(ans,10,sizeof(ans));
	solve(1,n,1,m,1,s);
	for (int i=1; i<=s; i++) printf("%d\n",ans[i]);
	return 0;
}
```



---

## 作者：Ameyax (赞：12)

分治。

在当前矩形内，按长边切开。

寻找两端都在当前矩形内部的点对经过中线且不超出矩形的最短路。

如果一个点对的两个点都在中线的同一边，就继续递归解决。

找最短路时从中线上的每一个点为起点分别做最短路会T。

有一个优化是把最短路的初始值赋为上次最短路的值加上一个起点到这个起点的距离。

数据没卡$spfa$，比$dijkstra$快不止一点。

复杂度O(能过)，[这篇博客](https://blog.csdn.net/neither_nor/article/details/51733997)证明是$O(S\sqrt{S}log{S})$

```cpp
#include <queue>
#include <cstdio>
#include <cctype>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
int read()
{
    int x = 0, f = 1; char ch = getchar();
    while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }
    while (isdigit(ch)) { x = x * 10 + ch - '0'; ch = getchar(); }
    return x * f;
}
const int MAX = 200033;
const int inf = 100000000;
#define id(i, j) ((i - 1) * m + (j))
int n, m, cnte, Q, cntid;
int invx[20033], invy[20033];
int fir[20033];
struct Query
{
    int x, y, xx, yy, id;
} q[100033], tmp[100033];
struct edge
{
    int to, nxt, w;
    edge() {}
    edge(int a, int b, int c)
    {
        to = a, nxt = b, w = c;
    }
} e[200033];
void addedge(int u, int v, int w)
{
    e[++cnte] = edge(v, fir[u], w), fir[u] = cnte;
    e[++cnte] = edge(u, fir[v], w), fir[v] = cnte;
}
int ans[100033], dis[20033];
int que[2000033];
bool inq[20033];
void dijkstra(int s, int xl, int xr, int yl, int yr, int h)
{
	int d = dis[s];
	for (int i = xl; i <= xr; i++)
        for (int j = yl; j <= yr; j++)
            dis[id(i, j)] = h ? dis[id(i, j)] + d : inf;
    dis[s] = 0;
    inq[s] = 1; 
	int l = 10000, r = 10000;
	que[r++] = s;
	while (l != r)
	{
		int u = que[l++];
		inq[u] = 0;
		for (int i = fir[u]; i; i = e[i].nxt)
		{
			int v = e[i].to;
			int vy = invy[v], vx = invx[v];
			if (vx >= xl && vx <= xr && vy >= yl && vy <= yr)
                if (dis[v] > dis[u] + e[i].w)
                {
                	dis[v] = dis[u] + e[i].w;
                	if (!inq[v])
                	{
                		if (dis[v] <= dis[que[l]])
                			que[--l] = v;
                		else que[r++] = v;
                		inq[v] = 1;
                	}
                }
		}
	}
}
void solve(int xl, int xr, int yl, int yr, int ql, int qr)
{
    if (ql > qr) return;
    if (xr - xl > yr - yl)
    {
        int mid = (xl + xr) >> 1;
        for (int i = yl; i <= yr; i++)
        {
            dijkstra(id(mid, i), xl, xr, yl, yr, i - yl);
            for (int j = ql; j <= qr; j++)
                ans[q[j].id] = min(ans[q[j].id], dis[id(q[j].x, q[j].y)] + dis[id(q[j].xx, q[j].yy)]);
        }
        int l = ql - 1, r = qr + 1;
        for (int i = ql; i <= qr; i++)
        {
            if (q[i].x < mid && q[i].xx < mid)
                tmp[++l] = q[i];
            else if (q[i].x > mid && q[i].xx > mid)
                tmp[--r] = q[i];
        }
        for (int i = ql; i <= l; i++)
            q[i] = tmp[i];
        for (int i = r; i <= qr; i++)
            q[i] = tmp[i];
        solve(xl, mid - 1, yl, yr, ql, l);
        solve(mid + 1, xr, yl, yr, r, qr);
    }
    else
    {
        int mid = (yl + yr) >> 1;
        for (int i = xl; i <= xr; i++)
        {
            dijkstra(id(i, mid), xl, xr, yl, yr, i - xl);
            for (int j = ql; j <= qr; j++)
                ans[q[j].id] = min(ans[q[j].id], dis[id(q[j].x, q[j].y)] + dis[id(q[j].xx, q[j].yy)]);
        }
        int l = ql - 1, r = qr + 1;
        for (int i = ql; i <= qr; i++)
        {
            if (q[i].y < mid && q[i].yy < mid)
                tmp[++l] = q[i];
            else if (q[i].y > mid && q[i].yy > mid)
                tmp[--r] = q[i];
        }
        for (int i = ql; i <= l; i++)
            q[i] = tmp[i];
        for (int i = r; i <= qr; i++)
            q[i] = tmp[i];
        solve(xl, xr, yl, mid - 1, ql, l);
        solve(xl, xr, mid + 1, yr, r, qr);
    }
}
int main()
{
    memset(ans, 63, sizeof ans);
    n = read(), m = read();
    for (int i = 1; i <= n; i++)
    	for (int j = 1; j <= m; j++)
    	{
    		cntid++;
    		invx[cntid] = i, invy[cntid] = j;
    	}
    for (int i = 1; i <= n; i++)
        for (int j = 1; j < m; j++)
            addedge(id(i, j), id(i, j + 1), read());
    for (int i = 1; i < n; i++)
        for (int j = 1; j <= m; j++)
            addedge(id(i, j), id(i + 1, j), read());
    Q = read();
    for (int i = 1; i <= Q; i++)
    {
        q[i].x = read(), q[i].y = read();
        q[i].xx = read(), q[i].yy = read();
        q[i].id = i;
    }
    solve(1, n, 1, m, 1, Q);
	for (int i = 1; i <= Q; i++)
        printf("%d\n", ans[i]);
    return 0;
}
```

---

## 作者：anda (赞：10)

本题考察了最短路和分治。

将询问离线下来，像整体二分一样处理。

将矩形沿着长边切开递归只需要传上下左右四个边界。
注意这里不需要旋转什么的，只需要二分一个中间值就好了。

对每次递归到达的状态，都在这个矩阵里中线上的每个点为起点求最短路，不用害怕算重，最短路数组在同一矩阵时无需清零，只需要将每个点的初始最短路定义为上一次的最短路加上上次起点到这次起点的最短路就好了，最优化减枝，同时也不用害怕爆整型，因为每个点都是一定可达的。

然后将最短路的数组归位，同时统计答案，答案为mid上的点到起点的距离加上中线上的点到终点的距离，再将起点和终点在同一侧的递归下去统计答案就好了。

本题需要卡常。
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<queue>
#include<algorithm>
#define inline  __inline__ __attribute__((always_inline)) 
using namespace std;
int n,m,p,a,b,c,d,ans,vis[20001],f[20001],head[20001],numedge,vis1[20001],q[20000001],qhead,qtail;
inline int read(){
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
	return x;
}
struct op{
	int a,b,c,d,id,ans;
}opt[200001],q1[200001],q2[200001],q3[200001];
inline bool cmp(const op &a,const op &b){return a.id<b.id;}
struct edge{int next,to,data;}ed[80001];
inline void addedge(register int x,register int y,register int z){ed[++numedge]=(edge){head[x],y,z};head[x]=numedge;}
inline void spfa(register int l1,register int l2,register int r1,register int r2,register int x){
	if(f[x]!=0){
		for(register int i=l1;i<=r1;i++){
			for(register int j=l2;j<=r2;j++){
				if((i-1)*m+j!=x)f[(i-1)*m+j]+=f[x];
				vis[(i-1)*m+j]=0;
			}
		}
	}
	else{
		 for(register int i=l1;i<=r1;i++){
		 	for(register int j=l2;j<=r2;j++){
		 		f[(i-1)*m+j]=0x3fffffff;
		 		vis[(i-1)*m+j]=0;
			 }
		 }
	}
	f[x]=0;qhead=qtail=0;q[qtail++]=x;
	while(qhead<qtail){
		register int x=q[qhead];qhead++;vis[x]=0;
		for(register int i=head[x];i;i=ed[i].next){
			if(f[x]+ed[i].data<f[ed[i].to]&&vis1[ed[i].to]){
				f[ed[i].to]=f[x]+ed[i].data;
				if(!vis[ed[i].to])vis[ed[i].to]=1,q[qtail++]=ed[i].to;
			}
		} 
	}
}
void dfs(register int l1,register int l2,register int r1,register int r2,register int l,register int r){
	if(l1==r1&&l2==r2||l>r)return;
	if(r1-l1>r2-l2){
		register int mid=(l1+r1)/2;
		for(register int i=l1;i<=r1;i++)for(register int j=l2;j<=r2;j++)vis1[(i-1)*m+j]=1; 
		for(register int i=l2;i<=r2;i++){
			spfa(l1,l2,r1,r2,(mid-1)*m+i);
			for(register int j=l;j<=r;j++){
				opt[j].ans=min(opt[j].ans,f[(opt[j].a-1)*m+opt[j].b]+f[(opt[j].c-1)*m+opt[j].d]);
			}
		}
		for(register int i=l1;i<=r1;i++)for(register int j=l2;j<=r2;j++)f[(i-1)*m+j]=vis1[(i-1)*m+j]=0;
		int q1top=0,q2top=0,q3top=0;
		for(register int i=l;i<=r;i++){
			if(opt[i].a<=mid&&opt[i].c<=mid)q1[++q1top]=opt[i];
			else if(opt[i].a>mid&&opt[i].c>mid)q2[++q2top]=opt[i];
			else q3[++q3top]=opt[i];
		}
		for(register int i=l;i<=l+q1top-1;i++)opt[i]=q1[i-l+1];
		for(register int i=l+q1top;i<=l+q1top+q2top-1;i++)opt[i]=q2[i-l-q1top+1];
		for(register int i=l+q1top+q2top;i<=r;i++)opt[i]=q3[i-l-q1top-q2top+1];
		dfs(l1,l2,mid,r2,l,l+q1top-1);
		dfs(mid+1,l2,r1,r2,l+q1top,l+q1top+q2top-1);
	}
	else{
		register int mid=(l2+r2)/2;
		for(register int i=l1;i<=r1;i++)for(register int j=l2;j<=r2;j++)vis1[(i-1)*m+j]=1;
		for(register int i=l1;i<=r1;i++){
			spfa(l1,l2,r1,r2,(i-1)*m+mid);
			for(register int j=l;j<=r;j++){
				opt[j].ans=min(opt[j].ans,f[(opt[j].a-1)*m+opt[j].b]+f[(opt[j].c-1)*m+opt[j].d]);
			}
		}
		for(register int i=l1;i<=r1;i++)for(register int j=l2;j<=r2;j++)f[(i-1)*m+j]=vis1[(i-1)*m+j]=0;
		register int q1top=0,q2top=0,q3top=0;
		for(register int i=l;i<=r;i++){
			if(opt[i].b<=mid&&opt[i].d<=mid)q1[++q1top]=opt[i];
			else if(opt[i].b>mid&&opt[i].d>mid)q2[++q2top]=opt[i];
			else q3[++q3top]=opt[i];
		}
		for(register int i=l;i<=l+q1top-1;i++)opt[i]=q1[i-l+1];
		for(register int i=l+q1top;i<=l+q1top+q2top-1;i++)opt[i]=q2[i-l-q1top+1];
		for(register int i=l+q1top+q2top;i<=r;i++)opt[i]=q3[i-l-q1top-q2top+1];
		dfs(l1,l2,r1,mid,l,l+q1top-1);dfs(l1,mid+1,r1,r2,l+q1top,l+q1top+q2top-1);
	}
}
int main(){
	n=read();m=read();
	for(register int i=1;i<=n;i++)
	  for(register int j=1;j<m;j++){
		register int x;x=read();
		addedge((i-1)*m+j,(i-1)*m+j+1,x);
	    addedge((i-1)*m+j+1,(i-1)*m+j,x);
	}
	for(register int i=1;i<n;i++)
	   for(register int j=1;j<=m;j++){
	   	register int x;x=read();
	   	addedge((i-1)*m+j,i*m+j,x);
	   	addedge(i*m+j,(i-1)*m+j,x);
	   }
	p=read();
	for(register int i=1;i<=p;i++)opt[i]=(op){read(),read(),read(),read(),i,0x7fffffff};
	dfs(1,1,n,m,1,p);
	sort(opt+1,opt+p+1,cmp);
	for(register int i=1;i<=p;i++){
		printf("%d\n",opt[i].ans);
	}
}
```

---

## 作者：pmt2018 (赞：9)

一道牛逼题

## 题目大意

给定一张$n*m$的网格图$(n*m\le 2\times10^4)$,$Q(Q\le2\times10^5)$次查询，询问两点之间的距离。

[传送门1](https://www.luogu.org/problem/P3350)

[传送门2](https://darkbzoj.tk/problem/4456)

[传送门3](https://loj.ac/problem/2090)

[传送门4](http://uoj.ac/problem/184)

## 题目解法

欢迎来我博客[pmt2018](https://www.cnblogs.com/pmt2018/p/11644666.html)查看

有老哥说看到网格图就想到分治，反正我是听了题解才会的。

做法是对每次对网格图的长边一切为二，考虑两种情况

1. 两点不跨过中线，这时两点的最短路有两种情况，要么不跨过中线，我们这时枚举中线上的点用最短路将其更新，要么跨过中线，这时我们将其分治下去继续做。

2. 两点跨过中线，这时分治下去也没啥用了。

所以我们把所有询问离线下来，像整体二分一样的处理就好了。

正确性显然，听说复杂度是$O(S\sqrt S\ log_2S)$的，但是我不会证明。

代码如下

```cpp
#include<bits/stdc++.h>
#define mp make_pair
#define pb push_back
#define fi first
#define se second

#define y0 pmt
#define y1 pmtpmt
#define x0 pmtQAQ
#define x1 pmtQwQ

using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef vector<int > vi;
typedef pair<int ,int > pii;
const int INF=0x3f3f3f3f, maxn=100007, MOD=1e9+7;
const ll LINF=0x3f3f3f3f3f3f3f3fLL;
const ll P=19260817;
int n,m;
int Q;
struct Point{
	int x,y;
	Point(){}
	Point(int _x,int _y){x=_x,y=_y;}
	friend bool operator < (const Point &x,const Point &y){
		if(x.x!=y.x)return x.x<y.x;
		return x.y<y.y;
	}
};
int id(Point x){return (x.x-1)*m+x.y;}
bool in(Point x,int lx,int rx,int ly,int ry){
	return lx<=x.x&&x.x<=rx&&ly<=x.y&&x.y<=ry;
}
struct edge{
	int nxt,w;
	Point to;
}e[maxn<<2];
int head[maxn],tot;
void addedge(Point u,Point v,int w){
	e[++tot].to=v;
	e[tot].w=w;
	e[tot].nxt=head[id(u)];
	head[id(u)]=tot;
}
struct query{
	Point x,y;
	int id;
}q[maxn<<2],q1[maxn<<1],q2[maxn<<1];
int ans[maxn];
priority_queue<pair<int ,Point >,vector<pair<int ,Point > >,greater<pair<int ,Point > > > pq;
int dis[maxn];
int vis[maxn];
void dij(int lx,int rx,int ly,int ry,int x,int y){//最短路，处理(x,y)到(lx~rx,ly~ry)矩形里的最短路
	for(int i=lx;i<=rx;i++)for(int j=ly;j<=ry;j++)dis[id(Point(i,j))]=INF,vis[id(Point(i,j))]=0;
	dis[id(Point(x,y))]=0;
	pq.push(mp(0,Point(x,y)));
	while(!pq.empty()){
		Point u=pq.top().se;int d=pq.top().fi;pq.pop();
		if(d!=dis[id(u)]||vis[id(u)])continue;
		vis[id(u)]=true;
		for(int i=head[id(u)];i;i=e[i].nxt){
			Point v=e[i].to;
			if(in(v,lx,rx,ly,ry)&&dis[id(u)]+e[i].w<dis[id(v)]){
				dis[id(v)]=dis[id(u)]+e[i].w;
				pq.push(mp(dis[id(v)],v));
			}
		}
	}
}
void solve(int lx,int rx,int ly,int ry,int l,int r){//(lx~rx,ly~ry)表示当前处理的矩形，x~y表示我们当前处理的询问的范围
	if(lx==rx&&ly==ry){
		for(int i=l;i<=r;i++)ans[q[i].id]=0;
		return ;
	}
	if(l>r)return;
	if(rx-lx>=ry-ly){//我们选择切矩形较长的一边
		int mid=(lx+rx)>>1;
		for(int i=ly;i<=ry;i++){//枚举中线上的点
			dij(lx,rx,ly,ry,mid,i);
			for(int j=l;j<=r;j++)ans[q[j].id]=min(ans[q[j].id],dis[id(q[j].x)]+dis[id(q[j].y)]);//更新答案
		}
		int top1=0,top2=0;
		for(int i=l;i<=r;i++){
            //将不跨过中线的点分治处理
			if(in(q[i].x,lx,mid,ly,ry)&&in(q[i].y,lx,mid,ly,ry))q1[++top1]=q[i];
			if(in(q[i].x,mid+1,rx,ly,ry)&&in(q[i].y,mid+1,rx,ly,ry))q2[++top2]=q[i];
		}
		for(int i=l;i<=l+top1-1;i++)q[i]=q1[i-l+1];
		for(int i=l+top1;i<=l+top1+top2-1;i++)q[i]=q2[i-l-top1+1];
        //分治切开的两个矩形
		solve(lx,mid,ly,ry,l,l+top1-1);solve(mid+1,rx,ly,ry,l+top1,l+top1+top2-1);
	}else{
        //与上面同理
		int mid=(ly+ry)>>1;
		for(int i=lx;i<=rx;i++){
			dij(lx,rx,ly,ry,i,mid);
			for(int j=l;j<=r;j++)ans[q[j].id]=min(ans[q[j].id],dis[id(q[j].x)]+dis[id(q[j].y)]);
		}
		int top1=0,top2=0;
		for(int i=l;i<=r;i++){
			if(in(q[i].x,lx,rx,ly,mid)&&in(q[i].y,lx,rx,ly,mid))q1[++top1]=q[i];
			if(in(q[i].x,lx,rx,mid+1,ry)&&in(q[i].y,lx,rx,mid+1,ry))q2[++top2]=q[i];
		}
		for(int i=l;i<=l+top1-1;i++)q[i]=q1[i-l+1];
		for(int i=l+top1;i<=l+top1+top2-1;i++)q[i]=q2[i-l-top1+1];
		solve(lx,rx,ly,mid,l,l+top1-1);solve(lx,rx,mid+1,ry,l+top1,l+top1+top2-1);
	}
}
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		for(int j=1;j<m;j++){
			int x;scanf("%d",&x);
			addedge(Point(i,j),Point(i,j+1),x);
			addedge(Point(i,j+1),Point(i,j),x);
			
		}
	}	
	for(int i=1;i<n;i++){
		for(int j=1;j<=m;j++){
			int x;scanf("%d",&x);
			addedge(Point(i,j),Point(i+1,j),x);
			addedge(Point(i+1,j),Point(i,j),x);
		}
	}	
	scanf("%d",&Q);
	for(int i=1;i<=Q;i++){
		Point x,y;
		scanf("%d%d%d%d",&x.x,&x.y,&y.x,&y.y);
		q[i].x=x,q[i].y=y,q[i].id=i;
	}
	memset(ans,0x3f,sizeof(ans));
	solve(1,n,1,m,1,Q);
	for(int i=1;i<=Q;i++)printf("%d\n",ans[i]);
	return 0;
}
```



---

## 作者：tzc_wk (赞：7)

[洛谷题面传送门](https://www.luogu.com.cn/problem/P3350)

肿么没有人证明复杂度，那我来证一个。

考虑分治，每次像猫树那样处理一个分治区间 $[l_x,r_x],[l_y,r_y]$ 表示当前处理 $x_1,x_2\in[l_x,r_x]$，$y_1,y_2\in[l_y,r_y]$ 范围内的所有询问。处理当前层的询问是好办的，考虑令 $mid=\lfloor\dfrac{l_x+r_x}{2}\rfloor$，那么我们对于 $y\in[l_y,r_y]$，我们一遍 dijkstra 求出 $(mid,y)$ 到所有 $(X,Y)$ 的最短距离（$X\in[l_x,r_x],Y\in[l_y,r_y]$），然后对于所有询问 $(x_1,y_1,x_2,y_2)$ 我们用 $dis_{x_1,y_1}+dis_{x_2,y_2}$ 更新答案。然后递归处理剩余询问——跨中线的询问就扔了不管了，全在左部的询问就扔到左边，全在右部的询问就扔到右边依次递归。

如果每次都劈 $[l_x,r_x]$ 的话复杂度显然是错误的，考虑一个浅显的优化：每次像 KDT 那样取区间长度较大的那一维劈开。如果你尝试实现这样的暴力你会发现你获得了 100 分的好成绩。这是为什么呢？首先正确性显然，跨中线的询问显然必须经过某个 $(mid,y)$，因此此轮更新已经包含了所有的情况，不用进一步递归。而全在左部的询问，我们已经求出了它到中间某个点然后折返的最小代价，此时如果它绕到右部，那么它必然经过中线，这种情况我们也已经计算过了，故该算法的正确性是没有问题的。

接下来考虑复杂度，注意到一轮更新的复杂度是 $nm\min(n,m)\log nm+\min(n,m)·Q$，由于这个 $\min$ 的存在，使复杂度达到最大值的图形形状肯定形如一个正方形（或者一个长宽比为 $1:\sqrt{2}$ 的矩形懒得管了，总之大概就这个量级的，不会长宽相差过于悬殊，下面分析就以正方形来推），而后面的 $\min(n,m)·Q$ 只与询问递归的深度有关，因此最劣情况肯定是询问递归到底，下面就用这种情况来分析复杂度。

设 $T(n,Q)$ 表示边长为 $n$ 的正方形有 $Q$ 个询问的复杂度，$T(n,m,Q)$ 表示 $n\times m$ 的矩形有 $Q$ 个询问的复杂度，那么有
$$
T(n,Q)=n^3\log(n^2)+nq+T(\dfrac{n}{2},n,Q)
$$

$$
T(n,Q)=n^3\log(n^2)+nq+((\dfrac{n}{2})^2·n·\log(n^2)+\dfrac{n}{2}·Q)\times 2+4T(\dfrac{n}{2},\dfrac{Q}{4})
$$

$$
T(n,Q)=\dfrac{3}{2}n^3\log(n^2)+2nQ+4T(\dfrac{n}{2},\dfrac{Q}{4})
$$

$$
T(n,Q)=\sum\limits_{i=0}^{\log(n^2)}\dfrac{3}{2}·(\dfrac{n}{2^i})^3·4^i\log(n^2)+2·\dfrac{n}{2^i}·\dfrac{Q}{4^i}·4^i
$$

$$
T(n,Q)=\sum\limits_{i=0}^{\log(n^2)}\dfrac{3}{2}·\dfrac{n^3}{2^i}·\log(n^2)+2·\dfrac{n}{2^i}·Q
$$

显然 $T(n,Q)=n^3\log(n^2)+nQ=A\sqrt{A}\log A+\sqrt{A}·Q$。

其中 $A=\max\{nm\}$。

```cpp
const int MAXV = 2e4;
const int MAXQ = 1e5;
const int INF = 0x3f3f3f3f;
int n, m, qu, res[MAXQ + 5]; pii rid[MAXV + 5];
struct qry {int x1, y1, x2, y2;} q[MAXQ + 5];
int hd[MAXV + 5], to[MAXV * 4 + 5], nxt[MAXV * 4 + 5], val[MAXV * 4 + 5], ec = 0;
int getid(int x, int y) {return (x - 1) * m + y;}
void adde(int u, int v, int w) {to[++ec] = v; val[ec] = w; nxt[ec] = hd[u]; hd[u] = ec;}
int dis[MAXV + 5];
void dijkstra(int l1, int r1, int l2, int r2, int X, int Y) {
	if (dis[getid(X, Y)] != INF) {
		for (int i = l1; i <= r1; i++) for (int j = l2; j <= r2; j++)
			if (i != X || j != Y) dis[getid(i, j)] += dis[getid(X, Y)];
	}
	dis[getid(X, Y)] = 0;
	priority_queue<pii, vector<pii>, greater<pii> > q;
	q.push(mp(0, getid(X, Y)));
	while (!q.empty()) {
		pii p = q.top(); q.pop(); int x = p.se;
		for (int e = hd[x]; e; e = nxt[e]) {
			int y = to[e], z = val[e];
			if (l1 <= rid[y].fi && rid[y].fi <= r1 && l2 <= rid[y].se && rid[y].se <= r2) {
				if (dis[y] > dis[x] + z) dis[y] = dis[x] + z, q.push(mp(dis[y], y));
			}
		}
	}
}
void solve(int l1, int r1, int l2, int r2, vector<int> cd) {
	if (l1 == r1 && l2 == r2) {
		for (int id : cd) res[id] = 0;
		return; 
	}
	if (r1 - l1 + 1 > r2 - l2 + 1) {
		int mid = l1 + r1 >> 1;
		for (int i = l1; i <= r1; i++) for (int j = l2; j <= r2; j++) dis[getid(i, j)] = INF;
		for (int i = l2; i <= r2; i++) {
			dijkstra(l1, r1, l2, r2, mid, i);
			for (int id : cd) chkmin(res[id], dis[getid(q[id].x1, q[id].y1)] + dis[getid(q[id].x2, q[id].y2)]);
		}
		vector<int> L, R;
		for (int id : cd) {
			if (max(q[id].x1, q[id].x2) <= mid) L.pb(id);
			if (min(q[id].x1, q[id].x2) > mid) R.pb(id);
		}
		solve(l1, mid, l2, r2, L); solve(mid + 1, r1, l2, r2, R);
	} else {
		int mid = l2 + r2 >> 1;
		for (int i = l1; i <= r1; i++) for (int j = l2; j <= r2; j++) dis[getid(i, j)] = INF;
		for (int i = l1; i <= r1; i++) {
			dijkstra(l1, r1, l2, r2, i, mid);
			for (int id : cd) chkmin(res[id], dis[getid(q[id].x1, q[id].y1)] + dis[getid(q[id].x2, q[id].y2)]);
		}
		vector<int> L, R;
		for (int id : cd) {
			if (max(q[id].y1, q[id].y2) <= mid) L.pb(id);
			if (min(q[id].y1, q[id].y2) > mid) R.pb(id);
		}
		solve(l1, r1, l2, mid, L); solve(l1, r1, mid + 1, r2, R);
	}
}
int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++)
		rid[getid(i, j)] = mp(i, j);
	for (int i = 1; i <= n; i++) for (int j = 1; j < m; j++) {
		int x; scanf("%d", &x);
		adde(getid(i, j), getid(i, j + 1), x);
		adde(getid(i, j + 1), getid(i, j), x);
	}
	for (int i = 1; i < n; i++) for (int j = 1; j <= m; j++) {
		int x; scanf("%d", &x);
		adde(getid(i, j), getid(i + 1, j), x);
		adde(getid(i + 1, j), getid(i, j), x);
	}
	scanf("%d", &qu); memset(res, 63, sizeof(res));
	for (int i = 1; i <= qu; i++) scanf("%d%d%d%d", &q[i].x1, &q[i].y1, &q[i].x2, &q[i].y2);
	vector<int> all; for (int i = 1; i <= qu; i++) all.pb(i);
	solve(1, n, 1, m, all);
	for (int i = 1; i <= qu; i++) printf("%d\n", res[i]);
	return 0;
}
```



---

## 作者：LightningUZ (赞：7)

**含复杂度证明的题解**

### 思路简述

如果只有一组询问：too simple

但是有 $Q$ 组询问，直接傻了。

瞪题意发现可以离线，并且图很规整... 考虑分治！

想到这里之后就很简单了。先把图从中间切开，然后递归处理左右两边的内部的。枚举中间的点，以它为源点跑最短路，两边一拼求出跨过中线的答案。

如何处理询问呢？我们保证每次递归的时候，手上拿的询问都是在整个区间内的，然后这样就可以判断它属于左半还是右半。

然后类似整体二分，我们把询问重排一下，把左半放到左边，右半放到右边，这样每次记一个询问中的区间 $[q_l,q_r]$ 就可以知道当前在我们递归到的子矩形里的询问是哪些了。

### 复杂度的证明

首先一个显然的结论，若 $a\times b=K$，那么 $min(a,b)\le \sqrt{K}$

然后我们的代码做一个小优化：对于每次递归到的矩形，切的那一刀切在长边上。这样中线的长度就不会超过面积的根号。

设 $T(n)$ 表示矩形面积为 $n$ 的求解复杂度

考虑最坏情况，每次切的那一刀的中线长度都卡在矩形的面积的根号那里。

$T(n)=2T(n/2)+\sqrt{n}\times n$

根据主定理它的复杂度就是 $n\times \sqrt{n} \times \log(n)$

然后考虑询问。每一个询问都一定会在某一层被考虑到，计算得最短路。类似上面的推导，复杂度应该是 $n\times \sqrt{n} \times log(q)$

于是复杂度是 $O(n\sqrt{n}(\log(n)+\log(q)))$

其中 $n$ 指的是矩形的面积，在题目中其实是 $n\times m$。

由于 $n\times m\le 2e4$，所以这个复杂度杠杠的能过。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Flandre_Scarlet
{
    #define N 114514
    #define int long long
    #define INF 0x3f3f3f3f3f3f3f3fll
    #define F(i,l,r) for(int i=l;i<=r;++i)
    #define D(i,r,l) for(int i=r;i>=l;--i)
    #define Fs(i,l,r,c) for(int i=l;i<=r;c)
    #define Ds(i,r,l,c) for(int i=r;i>=l;c)
    #define MEM(x,a) memset(x,a,sizeof(x))
    #define FK(x) MEM(x,0)
    #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))
    #define p_b push_back
    #define sz(a) ((int)a.size())
    #define all(a) a.begin(),a.end()
    #define iter(a,p) (a.begin()+p)
    int I() {char c=getchar(); int x=0; int f=1; while(c<'0' or c>'9') f=(c=='-')?-1:1,c=getchar(); while(c>='0' and c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar(); return ((f==1)?x:-x);}
    template <typename T> void Rd(T& arg){arg=I();}
    template <typename T,typename...Types> void Rd(T& arg,Types&...args){arg=I(); Rd(args...);}
    void RA(int *p,int n) {F(i,1,n) *p=I(),++p;}
    class Graph
    {
    public:
        int head[N];
        struct Edge{int v,w,nex;} E[N<<1]; int Ecnt=-1;
        void clear() {MEM(head,-1); MEM(E,-1); Ecnt=-1;}
        void AddEdge(int u,int v,int w=1) {E[++Ecnt]=(Edge){v,w,head[u]}; head[u]=Ecnt;}
        void Add2(int u,int v,int w=1) 
        {
            AddEdge(u,v,w); AddEdge(v,u,w);
        }
        void Read(int m,int t=2) {clear(); F(i,1,m) {int u=I(),v=I(),w=I(); (t==1)?AddEdge(u,v,w):Add2(u,v,w);}} 
        int  To(int i) {return E[i].v;} int Label(int i) {return E[i].w;} int Next(int i) {return E[i].nex;} int Start(int u){return head[u];}
    }G;
    int n,m,q;
    struct point // 一个点, 由于不好开数组, 我们把点编号, 然后信息存在一维数组里
    {
        int x,y;
        point() {x=y=0;}
        point(int val) {x=val/m+1; y=val%m; if (y==0) y=m,x--;}
        // 注意这个特判
        point(int xx,int yy) {x=xx; y=yy;}
    };
    int id(point x) {return (x.x-1)*m+x.y;}
    // 封装了从点到编号, 和编号到点
    struct query{point s,t; int id;} Q[N]; 
    void Input()
    {
        Rd(n,m); G.clear();
        F(i,1,n) F(j,1,m-1)
        {
            point cur=(point){i,j};
            int x=I();
            G.Add2(id(cur),id(cur)+1,x);
        }
        F(i,1,n-1) F(j,1,m)
        {
            point cur=(point){i,j};
            int x=I();
            G.Add2(id(cur),id(cur)+m,x);
        }
        // 读进来直接建图好了
        q=I();
        F(i,1,q) Q[i]=(query){(point){I(),I()},(point){I(),I()},i};
    }
    bool in(point x,int xl,int xr,int yl,int yr)
    {
        return (xl<=x.x and x.x<=xr) and (yl<=x.y and x.y<=yr);
    }
    namespace Min_Path // 控制子矩形区间的最短路
    {
        struct dnode{point v; int w;};
        bool operator<(dnode a,dnode b) {return a.w>b.w;}
        int dis[N]; bool vis[N]; priority_queue<dnode> Q;
        void Dijkstra(point s,int xl,int xr,int yl,int yr)
        {
            F(i,xl,xr) F(j,yl,yr) 
            {
                point cur=(point){i,j};
                dis[id(cur)]=INF; vis[id(cur)]=0;
            }
            while(!Q.empty()) Q.pop();
            Q.push((dnode){id(s),0}); dis[id(s)]=0;

            while(!Q.empty())
            {
                dnode Min=Q.top(); Q.pop();
                int u=id(Min.v);

                if (vis[u]) continue;
                vis[u]=1;
                Tra(i,u) 
                {
                    point tmp(v);
                    if (dis[u]+G.Label(i)<dis[v] and in(tmp,xl,xr,yl,yr) and !vis[v])
                    // 与常规最短路的唯一区别就是这里新进来的点要判一下是否在限定区间内
                    {
                        dis[v]=dis[u]+G.Label(i);
                        Q.push((dnode){tmp,dis[v]});
                    }
                }
            }
        }
    }
    using Min_Path::dis;

    int ans[N];
    query tmp[N];
    void calc(int xl,int xr,int yl,int yr,int ql,int qr)
    {
        if (ql>qr) return;
        if (xl==xr and yl==yr)
        {
            F(i,ql,qr) ans[Q[i].id]=0;
            return;
        }
        // 俩显然的边界
        if (xr-xl>yr-yl)
        {
            int mid=(xl+xr)>>1;
            F(i,yl,yr)
            {
                Min_Path::Dijkstra((point){mid,i},xl,xr,yl,yr);
                F(j,ql,qr) ans[Q[j].id]=min(ans[Q[j].id],dis[id(Q[j].s)]+dis[id(Q[j].t)]);
                // 跑最短路, 两边一拼更新答案
            }
            int pos=ql-1;
            F(i,ql,qr) if (in(Q[i].s,xl,mid,yl,yr) and in(Q[i].t,xl,mid,yl,yr)) tmp[++pos]=Q[i];
            int qmid=pos;
            F(i,ql,qr) if (in(Q[i].s,mid+1,xr,yl,yr) and in(Q[i].t,mid+1,xr,yl,yr)) tmp[++pos]=Q[i];
            F(i,ql,pos) Q[i]=tmp[i];
            // 重排一下询问区间

            calc(xl,mid,yl,yr,ql,qmid);
            calc(mid+1,xr,yl,yr,qmid+1,pos); 
        }
        else // 这俩同理
        {
            int mid=(yl+yr)>>1;
            F(i,xl,xr)
            {
                Min_Path::Dijkstra((point){i,mid},xl,xr,yl,yr);
                F(j,ql,qr) 
                {
                    ans[Q[j].id]=min(ans[Q[j].id],dis[id(Q[j].s)]+dis[id(Q[j].t)]);
                }
            }
            int pos=ql-1;
            F(i,ql,qr) if (in(Q[i].s,xl,xr,yl,mid) and in(Q[i].t,xl,xr,yl,mid)) tmp[++pos]=Q[i];
            int qmid=pos;
            F(i,ql,qr) if (in(Q[i].s,xl,xr,mid+1,yr) and in(Q[i].t,xl,xr,mid+1,yr)) tmp[++pos]=Q[i];
            F(i,ql,pos) Q[i]=tmp[i];
            calc(xl,xr,yl,mid,ql,qmid);
            calc(xl,xr,mid+1,yr,qmid+1,pos);
        }
    }
    void Soviet()
    {
        MEM(ans,INF);
        calc(1,n,1,m,1,q);
        F(i,1,q) printf("%lld\n",ans[i]);
    }
    void IsMyWife()
    {
        Input();
        Soviet();
    }
}
#undef int //long long
int main()
{
    Flandre_Scarlet::IsMyWife();
    getchar();
    return 0;
}
```

---

## 作者：zj余能 (赞：6)

-  对于前20%的做法：直接暴力最短路(⊙o⊙)。

	复杂度 Qnmlog(nm)

- 对于中间的30%：矩形的短边不超过4，可以在长边上用线段树维护一个高为4的矩形内的最短路，询问时同时把询问矩形两边也更新进去。有点像SHOI2008 traffic。

	复杂度 Qlog(n)

- 对于100%的做法：由于这是一个矩形，根据套路，考虑分治。假设分治到当前矩形(u,d,l,r)，并且有一些询问，满足这些询问的最短路径都不会超出当前矩形的范围。我们按短边将这个矩形分成两部分（即尽量方正）。在这些询问中，要么答案是经过这条分界线的，要么不是。很显然，如果询问的两个点在分界线两侧，那一定属于前者。我们对于分界线上的每一个点，以该点为起点都做一遍关于当前矩形中的点的最短路，以它到两点的距离和更新每一个询问的答案。对于两个点都在分界线的同一侧的询问，答案的路径可能不一定经过分界线，那么就分治下去。

	由于每一个询问最多存在于log(nm)个矩形中所以关于询问的复杂度是Qlog(nm)的，分治最多log(nm)层，每层nmlog(nm),所以最终复杂度是 Qlog(nm)+nmlog2(nm)

---

## 作者：Yahbim (赞：3)

玄学剪枝 KD-tree 式复杂度没看懂，但是这题其实有个复杂度正常的经典分治做法。

首先有个大概的思路，如果长小于宽就旋转一下这个图，然后平面图分治跑最短路。

然而仔细一想发现不行，如果一个询问只在跨越了的那一层处理，为了找最短路其实是需要考虑分治范围外的点的，然后复杂度就炸了。

但是有个观察：对于一个询问，总是存在一层分治，满足分治中心穿过最短路且分治范围能将整个最短路包括进去。

考虑反证法。取分治范围最小但是又能够将整个最短路包括进去的分治层，如果中线不穿过最短路，某一侧的子分治就会变成分治范围最小的且能包括整个最短路的，与定义矛盾。

所以只要在原本的错误做法上加一点小小的改动：最短路在分治范围内正常跑，每个询问都在每一个能将其包括进去的分治层查询一次就好了。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int INF=0x3f3f3f3f;
const int N=155,NM=2e4+5,Q=1e5+5;

template<class type> type read(type ret=0,int w=0,char ch=getchar()){
    while(!isdigit(ch)) w=ch=='-',ch=getchar();
    while(isdigit(ch)) ret=ret*10+ch-'0',ch=getchar();
    return w?-ret:ret;
}
template<class type> void write(type x){
    if(x<0) return putchar('-'),write(-x);
    if(x>9) write(x/10);
    putchar('0'+x%10);
}
template<class type> void write_n(type x){write(x),putchar('\n');}

int n,m,q,ans[Q],head[NM],cntedg=1;
struct query{struct{int x,y;}l,r;int id;};
struct edge{int to,nxt,w;}edg[NM<<3];
struct policy{
    int u,w;
    friend bool operator <(policy x,policy y){return x.w>y.w;}
};
vector<query> qry;

void add(int u,int v,int w){edg[++cntedg]={v,head[u],w},head[u]=cntedg;}

inline int id(int x,int y){return (x-1)*m+y;}

void dijsktra(int l,int r,int st,int dis[]){
    static bool vis[NM];static priority_queue<policy> q;
    for(int i=1;i<=n;++i)
	    for(int j=l,k=id(i,j);j<=r;++j,++k) dis[k]=INF,vis[k]=0;
    dis[st]=0,q.push({st,0});
    while(!q.empty()){
        int u=q.top().u;q.pop();
        if(vis[u]==1) continue;vis[u]=1;
        for(int i=head[u];i;i=edg[i].nxt){
            int v=edg[i].to,w=edg[i].w;
            if((v-1)%m+1>=l&&(v-1)%m+1<=r&&dis[v]>dis[u]+w) dis[v]=dis[u]+w,q.push({v,dis[v]});
        }
    }
}

void solve(int l,int r,vector<query> qry){
    if(l>r) return;
    int mid=(l+r)>>1;vector<query> lqry,rqry;
    static int dis[N][NM];
    for(int i=1;i<=n;++i) dijsktra(l,r,id(i,mid),dis[i]);
    for(query i:qry)
        for(int j=1;j<=n;++j)
            ans[i.id]=min(ans[i.id],dis[j][id(i.l.x,i.l.y)]+dis[j][id(i.r.x,i.r.y)]);
    for(query i:qry){
        if(i.r.y<mid) lqry.push_back(i);
        else if(i.l.y>mid) rqry.push_back(i);
    }    
    solve(l,mid-1,lqry),solve(mid+1,r,rqry);    
}

signed main(){
    n=read<int>(),m=read<int>();
    if(n<=m){
        for(int i=1;i<=n;++i)
            for(int j=1,w;j<m;++j)
                w=read<int>(),add(id(i,j),id(i,j+1),w),add(id(i,j+1),id(i,j),w);
        for(int i=1;i<n;++i)
            for(int j=1,w;j<=m;++j)	    
                w=read<int>(),add(id(i,j),id(i+1,j),w),add(id(i+1,j),id(i,j),w);
        q=read<int>();
        for(int i=1;i<=q;++i)
            qry.push_back({{read<int>(),read<int>()},{read<int>(),read<int>()},i}),ans[i]=INF;
        for(query &i:qry)
            if(i.l.y>i.r.y) swap(i.l,i.r);	
    }
    else{
        swap(n,m);
        for(int j=m;j;--j)
            for(int i=1,w;i<n;++i)
                w=read<int>(),add(id(i,j),id(i+1,j),w),add(id(i+1,j),id(i,j),w);
        for(int j=m-1;j;--j)
            for(int i=1,w;i<=n;++i)
                w=read<int>(),add(id(i,j),id(i,j+1),w),add(id(i,j+1),id(i,j),w);
        q=read<int>();
        for(int i=1;i<=q;++i)
            qry.push_back({{read<int>(),read<int>()},{read<int>(),read<int>()},i}),ans[i]=INF;
        for(int tmp;query &i:qry){
            tmp=i.l.x,i.l.x=i.l.y,i.l.y=m-tmp+1;
            tmp=i.r.x,i.r.x=i.r.y,i.r.y=m-tmp+1;
            if(i.l.y>i.r.y) swap(i.l,i.r);
        }
    }
    solve(1,m,qry);
    for(int i=1;i<=q;++i) write_n(ans[i]);
    return 0;
}

//~kawaii~
```

---

## 作者：极寒神冰 (赞：1)

先把询问离线。

与KDTree类似，每次将矩阵划分为两个部分，处理左上端点为$(lx,ly)$，右下端点为$(rx,ry)$的矩形且询问的点都在范围内的询问。然后将矩形从中间切开，对于当前矩形中所有的询问可以分为两种，经过中和不经过中线。

对于前者，我们暴力计算是否经过中线上点的答案比当前答案更优。对于后者继续递归分治。

需要注意的是每次将矩阵较长边切开，否则复杂度显然是错的。

以及由于是网格图，实际并不用真的将图建出来，每次上下左右跑就是了(

```cpp
struct ques
{
	int sx,sy,tx,ty,id;
}qs[M],qa[M],qb[M];
int n,m,k,e[N][4];
int ans[M],dis[N];
struct node
{
	int val,pos;
	inline bool operator <(const node a)const{
		return val>a.val;
	}
};
priority_queue<node>q;

inline int gkd(int x,int y){
	return (x-1)*m+y;
}
void dij(int sx,int sy,int tx,int ty,int s)
{
	R(i,sx,tx) R(j,sy,ty) dis[gkd(i,j)]=inf;
	dis[s]=0;
	q.push((node){0,s});
	while(q.size()>0)
	{
		node qwq=q.top();q.pop();
		if(dis[qwq.pos]!=qwq.val) continue;
		int ux=(qwq.pos-1)/m+1,uy=(qwq.pos-1)	%m+1;
		int vx=ux+1,vy=uy;
		if(sx<=vx&&vx<=tx&&sy<=vy&&vy<=ty)
		{
			if(dis[gkd(vx,vy)]>dis[gkd(ux,uy)]+e[gkd(ux,uy)][0]) 
				dis[gkd(vx,vy)]=dis[gkd(ux,uy)]+e[gkd(ux,uy)][0],q.push((node){dis[gkd(vx,vy)],gkd(vx,vy)});
		}
		vx=ux-1,vy=uy;
		if(sx<=vx&&vx<=tx&&sy<=vy&&vy<=ty)
		{
			if(dis[gkd(vx,vy)]>dis[gkd(ux,uy)]+e[gkd(ux,uy)][1]) 
				dis[gkd(vx,vy)]=dis[gkd(ux,uy)]+e[gkd(ux,uy)][1],q.push((node){dis[gkd(vx,vy)],gkd(vx,vy)});
		}
		vx=ux,vy=uy+1;
		if(sx<=vx&&vx<=tx&&sy<=vy&&vy<=ty)
		{
			if(dis[gkd(vx,vy)]>dis[gkd(ux,uy)]+e[gkd(ux,uy)][2]) 
				dis[gkd(vx,vy)]=dis[gkd(ux,uy)]+e[gkd(ux,uy)][2],q.push((node){dis[gkd(vx,vy)],gkd(vx,vy)});
		}
		vx=ux,vy=uy-1;
		if(sx<=vx&&vx<=tx&&sy<=vy&&vy<=ty)
		{
			if(dis[gkd(vx,vy)]>dis[gkd(ux,uy)]+e[gkd(ux,uy)][3]) 
				dis[gkd(vx,vy)]=dis[gkd(ux,uy)]+e[gkd(ux,uy)][3],q.push((node){dis[gkd(vx,vy)],gkd(vx,vy)});
		}
	}
} 
void solve(int lx,int ly,int rx,int ry,int l,int r)
{
	if(lx>rx||ly>ry||l>r) return ;
	if(l==r)
	{
		dij(lx,ly,rx,ry,gkd(qs[l].sx,qs[l].sy));
		ans[qs[l].id]=min(ans[qs[l].id],dis[gkd(qs[l].tx,qs[l].ty)]);
		return;
	}
	if(rx-lx<=ry-ly)
	{
		int mid=(ly+ry)>>1;
		R(i,lx,rx) {
			dij(lx,ly,rx,ry,gkd(i,mid));
			R(j,l,r) ans[qs[j].id]=min(ans[qs[j].id],dis[gkd(qs[j].sx,qs[j].sy)]+dis[gkd(qs[j].tx,qs[j].ty)]);
		}
		int tota=0,totb=0;
		R(i,l,r)
		{
			if(qs[i].sy<=mid&&qs[i].ty<=mid) qa[++tota]=qs[i];
			if(qs[i].sy>mid&&qs[i].ty>mid) qb[++totb]=qs[i];
		}
		R(i,1,tota) qs[i+l-1]=qa[i];
		R(i,1,totb) qs[r-i+1]=qb[i];		
		if(ly==ry) return;
		solve(lx,ly,rx,mid,l,l+tota-1),solve(lx,mid+1,rx,ry,r-totb+1,r);		
	}
	else
	{
		int mid=(lx+rx)>>1;
		R(i,ly,ry) {
			dij(lx,ly,rx,ry,gkd(mid,i));
			R(j,l,r) ans[qs[j].id]=min(ans[qs[j].id],dis[gkd(qs[j].sx,qs[j].sy)]+dis[gkd(qs[j].tx,qs[j].ty)]);
		}
		int tota=0,totb=0;
		R(i,l,r) {
			if(qs[i].sx<=mid&&qs[i].tx<=mid) qa[++tota]=qs[i];
			if(qs[i].sx>mid&&qs[i].tx>mid) qb[++totb]=qs[i];
		}
		R(i,1,tota) qs[i+l-1]=qa[i];
		R(i,1,totb) qs[r-i+1]=qb[i];
		if(lx==rx) return;		
		solve(lx,ly,mid,ry,l,l+tota-1),solve(mid+1,ly,rx,ry,r-totb+1,r);
	}
}
signed main()
{
	n=read(),m=read();
	R(i,1,n) R(j,1,m-1) e[gkd(i,j)][2]=e[gkd(i,j+1)][3]=read();
	R(i,1,n-1) R(j,1,m) e[gkd(i,j)][0]=e[gkd(i+1,j)][1]=read();
	k=read();
	R(i,1,k)
		ans[i]=inf,qs[i].sx=read(),qs[i].sy=read(),qs[i].tx=read(),qs[i].ty=read(),qs[i].id=i;
	solve(1,1,n,m,1,k);
	R(i,1,k) printf("%d\n",ans[i]);
}
```


---


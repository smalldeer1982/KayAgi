# 小清新数据结构题

## 题目背景

**本题时限2s，内存限制256M**


## 题目描述

在很久很久以前，有一棵n个点的树，每个点有一个点权。

现在有q次操作，每次操作是修改一个点的点权或指定一个点，询问以这个点为根时每棵子树点权和的平方和。

（题目不是很好懂，没看太懂的可以看看样例解释）


## 说明/提示

##### 样例解释

这是一个菊花图，2与1、3、4间有边。

一开始每个点点权分别为4、3、2、1。

第一个询问以2为根，1、3、4子树中都只有本身一个点，2子树中有所有点，那么1、3、4子树中的点权和就分别是自己的点权4、2、1，2子树中的点权和就是4+3+2+1=10，$4^2+2^2+1^1+10^2=121$。

接下来将第一个点点权修改为3，每个点点权分别为3、3、2、1。

第二个询问以3为根，1、4子树中只有自己，2子树中有1、2、4，3子树中有所有点，1、4子树点权和就是自己的点权3、1，2子树点权和就是3+3+1=7，3子树点权和为3+3+2+1=9，$3^2+1^2+7^2+9^2=140$。

接下来把第二个点点权修改为4，每个点点权分别为3、4、2、1。

第三个询问以4为根，1、3子树点权和就是3和2，2子树点权和就是3+4+2=9，4子树点权和为3+4+2+1=10，$3^2+2^2+9^2+10^2=194$。

##### 数据范围

对于10%的数据，$n,q \leq 2000$。

对于40%的数据，$n,q \leq 60000$。

对于另外30%的数据，保证每次询问的根都为1。

对于100%的数据，$1 \leq n,q \leq 200000$，$-10 \leq$输入的每个点权$\leq 10$。

建议使用输入优化~~，虽然标程没加读入优化也能过~~


## 样例 #1

### 输入

```
4 5
1 2
2 3
2 4
4 3 2 1
2 2
1 1 3
2 3
1 2 4
2 4```

### 输出

```
121
140
194```

# 题解

## 作者：_rqy (赞：69)

一共只有两个错误我竟然调了一个小时...~~（我才不会说我快读没判负数然后连WA四次）~~

呐，这题根本用不着动态点分治这种高大上的东西，点分治都用不到，只要树剖瞎搞一搞就可以了。

为了方便计算，我们维护每个点当前权值，那么修改点权就转化为了增加点权。

我们先考虑如果没有换根操作。

那么，修改某个点的权值只会影响它所有祖先的“子树点权和”。

先树剖把问题转化到序列上，问题就变成了区间加和维护区间平方和。我们只需要在线段树上维护区间和和区间平方和，那么如果有一个区间加标记$a$，区间和就变成了$\sum_i(s_i+a)=a\times len+\sum_is_i$，区间平方和变成了$\sum_i(s_i+a)^2=a^2\times len+2a\sum_is_i+\sum_is_i^2$，直接维护即可。

再来考虑换根。假设原来的根是$1$，现在的根是$u$，那么可以发现“子树点权和”改变的点只有从$1$到$u$的路径上的点。假设这条路径是$1=u_0-u_1-u_2-...-u_k=u$，对应每个点的子树点权和是（以$1$为根）$a_k$和（以$u$为根）$b_k$那么答案是$ans_u=ans_1-\sum_{i=0}^ka_i^2+\sum_{i=0}^kb_i^2$，其中$ans_1$是以$1$为根时的答案。

容易知道$a_{i+1}+b_i=a_0=b_k$（都等于所有点的点权总和），所以有

$$ans_u=ans_1-\sum_{i=0}^ka_i^2+\sum_{i=0}^kb_i^2=ans_1-a_0^2-\sum_{i=1}^ka_i^2+b_k^2+\sum_{i=0}^{k-1}(a_0-a_{i+1})^2$$

化简得

$$ans_u=ans_1+(k-1)a_0^2-2a_0\sum_{i=1}^ka_i$$

于是我们只需要统计出这条路径上的点的个数和子树点权和的和即可。于是在树剖上跑就可以了。时间复杂度$O(nlog^2n)$（如果你非要写$O(nlogn)$的LCT也没人拦着）

代码：

```cpp
#include <cctype>
#include <cstdio>
#include <cstring>
typedef long long LL;
const LL N = 200050;
LL n;

inline char readChar() {
  static char buf[10000000], *p = buf, *end = buf;
  if (p == end) end = buf + fread(p = buf, sizeof(char), 10000000, stdin);
  return *(p++);
}

inline int readInt() {
  int ans = 0, c, f = 1;
  while (!isdigit(c = readChar())) if (c == '-') f *= -1;
  do ans = ans * 10 + c - '0';
  while (isdigit(c = readChar()));
  return ans * f;
}

namespace TreeChain{
LL A[N];
LL s[N];
LL pre[N], nxt[N * 2], to[N * 2], cnt;
LL dep[N], node[N], pos[N], top[N], fa[N], siz[N], belong[N], cnt2, cnt3;

inline void addEdge(LL x, LL y) {
  nxt[cnt] = pre[x];
  to[pre[x] = cnt++] = y;
  nxt[cnt] = pre[y];
  to[pre[y] = cnt++] = x;
}

void dfs1(LL x) {
  dep[x] = dep[fa[x]] + 1;
  siz[x] = 1;
  s[x] = A[x];
  for (LL i = pre[x]; ~i; i = nxt[i])
    if (to[i] != fa[x]) {
      fa[to[i]] = x;
      dfs1(to[i]);
      siz[x] += siz[to[i]];
      s[x] += s[to[i]];
    }
}

void dfs2(LL x, bool n = false) {
  if (n) {
    ++cnt2;
    top[cnt2] = x;
  }
  node[pos[x] = cnt3++] = x;
  belong[x] = cnt2;
  if (siz[x] > 1) {
    LL l = 0;
    for (LL i = pre[x]; ~i; i = nxt[i])
      if (to[i] != fa[x] && siz[to[i]] > siz[l])
        l = to[i];
    dfs2(l);
    for (LL i = pre[x]; ~i; i = nxt[i])
      if (to[i] != fa[x] && to[i] != l)
        dfs2(to[i], true);
  }
}

inline void work() {
  memset(pre, -1, sizeof pre);
  for (LL i = 1; i < n; ++i)
    addEdge(readInt(), readInt());
  for (LL i = 1; i <= n; ++i)
    A[i] = readInt();
  dfs1(1);
  cnt3 = 1;
  dfs2(1, true);
}
};

namespace SegTree{
LL ss[N * 4], ss2[N * 4], addv[N * 4];
#define lch (o << 1)
#define rch (o << 1 | 1)

inline void maintain(LL o, LL l, LL r) {
  using TreeChain::s;
  using TreeChain::node;
  if (l == r) {
    ss[o] = addv[o] + s[node[l]];
    ss2[o] = ss[o] * ss[o];
  } else {
    ss[o] = ss[lch] + ss[rch] + addv[o] * (r - l + 1);
    ss2[o] = ss2[lch] + ss2[rch] +
      addv[o] * addv[o] * (r - l + 1) + 2 * addv[o] * (ss[lch] + ss[rch]);
  }
}

inline void pushdown(LL o, LL l, LL r) {
  using TreeChain::s;
  using TreeChain::node;
  if (l == r) s[node[l]] += addv[o];
  else {
    addv[lch] += addv[o];
    addv[rch] += addv[o];
  }
  addv[o] = 0;
}

void build(LL o, LL l, LL r) {
  if (l != r) {
    LL mid = (l + r) / 2;
    build(lch, l, mid);
    build(rch, mid + 1, r);
  }
  maintain(o, l, r);
}

void modify(LL o, LL l, LL r, LL L, LL R, LL add) {
  if (l > R || r < L) return;
  if (r <= R && l >= L)
    addv[o] += add;
  else {
    LL mid = (l + r) / 2;
    modify(lch, l, mid, L, R, add);
    modify(rch, mid + 1, r, L, R, add);
  }
  maintain(o, l, r);
}

void query(LL o, LL l, LL r, LL L, LL R, LL &ans2, LL &ans) {
  maintain(o, l, r);
  if (l > R || r < L) return;
  if (r <= R && l >= L) {
    ans2 += ss2[o];
    ans += ss[o];
  } else {
    LL mid = (l + r) / 2;
    pushdown(o, l, r);
    query(lch, l, mid, L, R, ans2, ans);
    query(rch, mid + 1, r, L, R, ans2, ans);
  }
}
};

using TreeChain::A;
LL sa = 0;
LL query(LL x) {
  using SegTree::query;
  using TreeChain::belong;
  using TreeChain::pos;
  LL ans = 0, ss = 0, tmp;
  query(1, 1, n, 1, n, ans, tmp);
  LL k = 0;
  while (belong[x] != belong[1]) {
    LL top = TreeChain::top[belong[x]];
    k += pos[x] - pos[top] + 1;
    query(1, 1, n, pos[top], pos[x], tmp, ss);
    x = TreeChain::fa[top];
  }
  k += pos[x] - pos[1];
  query(1, 1, n, pos[1] + 1, pos[x], tmp, ss);
  return ans + sa * (k * sa - 2 * ss);
}

void modify(LL x, LL y) {
  using SegTree::modify;
  using TreeChain::belong;
  using TreeChain::pos;
  y -= A[x];
  A[x] += y;
  sa += y;
  while (x) {
    LL top = TreeChain::top[belong[x]];
    modify(1, 1, n, pos[top], pos[x], y);
    x = TreeChain::fa[top];
  }
}

int main() {
  n = readInt();
  LL q = readInt();
  TreeChain::work();
  sa = TreeChain::s[1];
  SegTree::build(1, 1, n);
  while (q--) {
    if (readInt() == 1) {
      LL x = readInt();
      LL y = readInt();
      modify(x, y);
    } else {
      LL x = readInt();
      printf("%lld\n", query(x));
    }
  }
  return 0;
}
```

---

## 作者：fjzzq2002 (赞：42)

感觉最小清新的其实是这个数据结构题啊，~~链剖直接暴力讨论一波就艹过去了好气啊~~，下面来讲一种比较容易work~~全是板子~~的$O(nlogn)$做法。


首先我们发现有一个良心30分部分分，每次询问根都为1，这个要怎么搞呢？


我们的要求就是把一个点到根的路径上的子树和全部加上一个值，询问所有点子树平方和。


考虑对一个点x点权+y对答案的贡献，我们发现对于每个x的父亲f，假设原来点权和为p，现在就变成了p+y，那么对答案贡献就是$(p+y)^2-p^2=2py+y^2$，我们只要统计x到根的点权和即可。


那么我们只要支持将一个点到根的路径点权加上一个数和统计一个点到根的点权和，直接树链剖分就可以做到两个log，当然如果你追求理论复杂度那么用lct就可以做到一个log。


现在考虑满分，我们发现这个平方十分麻烦，不妨考虑如果没有平方怎么做，即要以点p为根考虑整棵树，求出每个点子树的点权和，直接加在一起。


考虑一个点s的点权$v_s$只有它及祖先才会计入，即计入了$dis(s,p)+1$次，那么没有平方的答案就是$\sum_{i=1}^n dis(p,i)v_i+\sum_{i=1}^n v_i$，这个东西显然是可以用动态点分治维护的，参见bzoj3924。


现在问题就是这个平方，我们设$s_x$为x子树的点权和，w为点权总和，那么我们可以发现$\sum_{i=1}^n s_i(w-s_i)$无论根是啥都是一个定值。


证明十分简单，考虑对于每对点(i,j)，在i到j的路径上每条边都加上$v_iv_j$的权值，那么i往父亲边权的就是$s_i(w-s_i)$，因为要在自己子树中选一个点权，外面选一个，显然加在一起值不会变。


那么我们在1为根的时候求出$\sum_{i=1}^n s_iw-s_i^2$，然后在p为根时求出$\sum_{i=1}^n s_i$，把$\sum_{i=1}^n s_i^2$解出来即可。


---

## 作者：Kelin (赞：29)

题意:求当u为根时,所有子树的点权和的平方和,带修改

考虑没有换根的操作(假设当前根是$1$)如何计算所求

考虑到修改一个点u的权值,只会影响到$path(1,u)$上的点的子树点权和

记$s_i$为$i$子树的点权和,把修改变成增加,那么其贡献就是

$\sum_{i\in path(1,u)}(s_i+a)^2-\sum_{i\in path(1,u)}s_i^2=a^2len+2a\sum_{i\in path(1,u)}s_i$

所以只要$dfs$预处理出$ans=\sum_{i=1}^ns_i^2$然后维护$\sum_{i\in path(1,u)}s_i$就$ok$了

注意修改完还要$ans+=a^2len+2a\sum_{i\in path(1,u)}s_i$

考虑有换根的操作怎么办?

其实子树点权和受到影响的还是path(1,u)上的点

设$path(1,u)$上的点为$v_1,v_2,\ldots,v_k$(连续的)

对应每个点$v_i$的子树点权和是$a_i$(以$1$为根)和$b_i$(以$u$为根)

注意到$a_{i+1}+b_i=a_1=b_k$($ans_u$表示当根是$u$时的答案)

$ans_u=ans_1-\sum_{i=1}^ka_i^2+\sum_{i=1}^kb_i^2$

$=ans_1-\sum_{i=1}^ka_i^2+\sum_{i=1}^{k-1}(a_1-a_{i+1})^2+b_k^2$

$=ans_1-\sum_{i=2}^ka_i^2+\sum_{i=2}^{k}(a_1-a_i)^2$

$=ans_1+(k-1)a_1^2-2a_1\sum_{i=2}^ka_i$

$=ans+s_1[(k-1)s_1-2(\sum_{i\in path(1,u)}^ks_i-s_1)]$

$=ans+s_1[(k+1)s_1-2\sum_{i\in path(1,u)}^ks_i]$

树上路径点权和显然可以用树剖或者LCT维护

树剖的话没必要写线段树,树状数组就好了

树剖+BIT
```
#include<bits/stdc++.h>
#define fp(i,a,b) for(int i=a,I=b;i<=I;++i)
#define fd(i,a,b) for(int i=a,I=b;i>=I;--i)
#define go(i,u) for(int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
using namespace std;
const int N=2e5+5;
typedef int arr[N];
typedef long long ll;
struct eg{int nx,to;}e[N<<1];
int n,m,ce,cnt;arr w,c,fi,fa,sz,id,pos,dep,son,top;ll ans,c1[N],c2[N];
void dfs(int u){
	dep[u]=dep[fa[u]]+(sz[u]=1);
	go(i,u)if(v^fa[u]){
		fa[v]=u,dfs(v),w[u]+=w[v],sz[u]+=sz[v];
		if(sz[v]>sz[son[u]])son[u]=v;
	}ans+=1ll*w[u]*w[u];
}
inline void Mdy(int x,ll w){for(int i=x;i<=n;i+=i&(-i))c1[i]+=w,c2[i]+=(ll)x*w;}
inline ll Qry(int x){ll w=0;for(int i=x;i;i-=i&(-i))w+=1ll*(x+1)*c1[i]-c2[i];return w;}
void dfs(int u,int t){
	top[u]=t;pos[id[u]=++cnt]=u;
	Mdy(id[u],w[u]-w[pos[cnt-1]]);
	if(son[u])dfs(son[u],t);
	go(i,u)if(v^fa[u]&&v^son[u])dfs(v,v);
}
inline ll qry(int u){
	int k=0,x=Qry(1);ll s=0;
	for(;u;u=fa[top[u]])
		k+=id[u]-id[top[u]]+1,
		s+=Qry(id[u])-Qry(id[top[u]]-1);
	return ans+x*((k+1)*x-(s<<1));
}
inline void mdy(int u,int x){
	int k=0;ll s=0;
	for(;u;u=fa[top[u]])
		k+=id[u]-id[top[u]]+1,
		s+=Qry(id[u])-Qry(id[top[u]]-1),
		Mdy(id[top[u]],x),Mdy(id[u]+1,-x);
	ans+=x*(x*k+(s<<1));
}
inline void add(int u,int v){e[++ce]=eg{fi[u],v};fi[u]=ce;}
int main(){
	scanf("%d%d",&n,&m);int u,v,o;
	fp(i,2,n)scanf("%d%d",&u,&v),add(u,v),add(v,u);
	fp(i,1,n)scanf("%d",c+i),w[i]=c[i];dfs(1);dfs(1,1);
	while(m--)
		scanf("%d%d",&o,&u),
		o==1?scanf("%d",&v),v-=c[u],c[u]+=v,mdy(u,v):(void)printf("%lld\n",qry(u));
return 0;
}
```

LCT
```
#include<bits/stdc++.h>
#define fp(i,a,b) for(int i=a,I=b;i<=I;++i)
#define fd(i,a,b) for(int i=a,I=b;i>=I;--i)
#define go(i,u) for(int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
using namespace std;
const int N=2e5+5;
typedef int arr[N];
typedef long long ll;
struct eg{int nx,to;}e[N<<1];
int n,m,ce;arr w,c,fi;ll ans;
int top,ch[N][2];arr S,rev,sz,fa,tg;ll s[N];
#define lc(u)(ch[u][0])
#define rc(u)(ch[u][1])
inline void down(int p){
	if(rev[p]){
		rev[lc(p)]^=1,rev[rc(p)]^=1;
		swap(lc(p),rc(p)),rev[p]=0;
	}w[p]+=tg[p];
	fp(i,0,1){
        int k=ch[p][i];
        tg[k]+=tg[p];
        s[k]+=tg[p]*sz[k];
    }tg[p]=0;
}
inline void up(int p){
	s[p]=w[p]+s[lc(p)]+s[rc(p)];
	sz[p]=sz[lc(p)]+sz[rc(p)]+1;
}
inline bool gf(int u){return rc(fa[u])==u;}
inline bool ir(int u){return lc(fa[u])!=u&&rc(fa[u])!=u;}
inline void rot(int u){
	int p=fa[u],k=gf(u);
	if(!ir(p))ch[fa[p]][gf(p)]=u;
	if(ch[u][!k])fa[ch[u][!k]]=p;
	ch[p][k]=ch[u][!k],ch[u][!k]=p;
	fa[u]=fa[p],fa[p]=u,up(p);
}
void splay(int u){
	S[top=1]=u;
	for(int i=u;!ir(i);i=fa[i])S[++top]=fa[i];
	fd(i,top,1)down(S[i]);
	for(int f=fa[u];!ir(u);rot(u),f=fa[u])
		if(!ir(f))rot(gf(u)==gf(f)?f:u);
	up(u);
}
inline void acc(int u){for(int v=0;u;u=fa[v=u])splay(u),ch[u][1]=v,up(u);}
inline void mkrt(int u){acc(u),splay(u),rev[u]=1;}
inline void close(int u,int v){mkrt(u),acc(v),splay(v);}
inline void link(int u,int v){mkrt(u),fa[u]=v;}
void dfs(int u){go(i,u)if(v^fa[u])fa[v]=u,dfs(v),w[u]+=w[v];ans+=1ll*w[u]*w[u];}
inline ll qry(int u){return close(u,1),ans+w[1]*(1ll*(sz[1]+1)*w[1]-(s[1]<<1));}
inline void mdy(int u,int x){close(u,1),ans+=x*(x*sz[1]+(s[1]<<1)),tg[1]+=x,s[1]+=sz[1]*x;}
inline void add(int u,int v){e[++ce]=eg{fi[u],v};fi[u]=ce;}
int main(){
	scanf("%d%d",&n,&m);int u,v,o;
	fp(i,2,n)scanf("%d%d",&u,&v),add(u,v),add(v,u);
	fp(i,1,n)scanf("%d",c+i),w[i]=c[i];dfs(1);
	while(m--)
		scanf("%d%d",&o,&u),
		o==1?scanf("%d",&v),v-=c[u],c[u]+=v,mdy(u,v):(void)printf("%lld\n",qry(u));
return 0;
}
```

虽说树剖复杂度是$O(n\log^2n)$,$LCT$复杂度是$O(n\log n)$,但是我不得不感叹$LCT$常数真大

---

## 作者：租酥雨 (赞：15)

[传送门][1]

#sol
我们设$s_i$表示以$p$为整棵树的根时，以$i$为根的子树的点权和。设$Sum$表示所有点的点权和，即$Sum=\sum_{i=1}^{n}val_i$。

所以这道题给出$p$，就是要你求$\sum_{i=1}^{n}s_i^2$。


我们先看$\sum_{i=1}^{n}s_i$怎么求。

考虑每个点的点权对$\sum_{i=1}^{n}s_i$的贡献，可以发现，每个点被计算了$dep_i+1$次，也就是说$\sum_{i=1}^{n}s_i=\sum_{i=1}^{n}val_i(dep_i+1)=\sum_{i=1}^{n}val_idep_i+Sum$。前面那一坨是不是有点熟悉？[【ZJOI2015】幻想乡战略游戏][2]。

下文中为了方便描述，令$calc(p)$表示以$p$为根时的$\sum_{i=1}^{n}val_idep_i$


接下来我们考虑一下这个东西

$$\sum_{i=1}^{n}\sum_{j=1}^{n}val_ival_jdis(i,j)$$

这个可以形象地理解为，在每一对点对$(i,j)$的路径上每一条边（刚好是$dis(i,j)$条边）上都加上$val_ival_j$，然后求整棵树上的边权之和。


现在我们考虑每一条边上的权值，它应该等于它两侧连接的两坨树的点权和的乘积。而连接的这两坨树中，不论取哪个$p$为根，都有有且仅有一坨树会是一棵子树。所以这个权值会等于$s_i(Sum-s_i)$。所以

$$\sum_{i=1}^{n}\sum_{j=1}^{n}val_ival_jdis(i,j)=\sum_{i=1}^{n}s_i(Sum-s_i)$$

这同时也证明了不论取哪个$p$作为根，$\sum_{i=1}^{n}s_i(Sum-s_i)$都不会变。


令$W=\sum_{i=1}^{n}s_i(Sum-s_i)$，可以先$O(n)$地$DP$出$W$的初值，然后就只要考虑一个点权修改对$W$的影响。

因为$W=\sum_{i=1}^{n}\sum_{j=1}^{n}val_ival_jdis(i,j)$，若节点$i$的点权的变化量为$\Delta v$，那么$\Delta W=\Delta v\sum_{j=1}^{n}val_jdis(i,j)$，相当于$\Delta v*calc(i)$，所以说一样地计算即可。

所以最终询问的答案就是：

$$\sum_{i=1}^{n}s_i^2=Sum*\sum_{i=1}^{n}s_i-W=Sum(calc(i)+Sum)-W$$

##code
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define ll long long
const int N = 200005;
int gi()
{
    int x=0,w=1;char ch=getchar();
    while ((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
    if (ch=='-') w=0,ch=getchar();
    while (ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return w?x:-x;
}
struct edge{int to,next;}a[N<<1];
int n,q,val[N],head[N],cnt,pa[N],dep[N],sz[N],son[N],top[N];
void dfs1(int u,int f)
{
    pa[u]=f;dep[u]=dep[f]+1;sz[u]=1;
    for (int e=head[u];e;e=a[e].next)
    {
        int v=a[e].to;if (v==f) continue;
        dfs1(v,u);
        sz[u]+=sz[v];if (sz[v]>sz[son[u]]) son[u]=v;
    }
}
void dfs2(int u,int f)
{
    top[u]=f;
    if (son[u]) dfs2(son[u],f);else return;
    for (int e=head[u];e;e=a[e].next)
        if (a[e].to!=pa[u]&&a[e].to!=son[u])
            dfs2(a[e].to,a[e].to);
}
int lca(int u,int v)
{
    while (top[u]^top[v])
    {
        if (dep[top[u]]<dep[top[v]]) swap(u,v);
        u=pa[top[u]];
    }
    return dep[u]<dep[v]?u:v;
}
int getdis(int u,int v){return dep[u]+dep[v]-(dep[lca(u,v)]<<1);}
int tot,root,vis[N],w[N],fa[N];
ll sum[N],gather[N],tofa[N],sigma,omega,ans;
void getroot(int u,int f)
{
    sz[u]=1;w[u]=0;
    for (int e=head[u];e;e=a[e].next)
    {
        int v=a[e].to;if (v==f||vis[v]) continue;
        getroot(v,u);
        sz[u]+=sz[v];w[u]=max(w[u],sz[v]);
    }
    w[u]=max(w[u],tot-sz[u]);
    if (w[u]<w[root]) root=u;
}
void solve(int u,int f)
{
    fa[u]=f;vis[u]=1;
    for (int e=head[u];e;e=a[e].next)
    {
        int v=a[e].to;if (vis[v]) continue;
        tot=sz[v];
        root=0;
        getroot(v,0);
        solve(root,u);
    }
}
void modify(int u,int v)
{
    sum[u]+=v;
    for (int i=u;fa[i];i=fa[i])
    {
        int dist=getdis(u,fa[i]);
        sum[fa[i]]+=v;
        gather[fa[i]]+=dist*v;
        tofa[i]+=dist*v;
    }
}
ll calc(int u)
{
    ll res=gather[u];
    for (int i=u;fa[i];i=fa[i])
    {
        int dist=getdis(u,fa[i]);
        res+=(ll)dist*(sum[fa[i]]-sum[i]);
        res+=gather[fa[i]]-tofa[i];
    }
    return res;
}
void DP(int u)
{
    sz[u]=val[u];
    for (int e=head[u];e;e=a[e].next)
    {
        int v=a[e].to;if (v==pa[u]) continue;
        DP(v);sz[u]+=sz[v];
    }
    omega+=1ll*sz[u]*(sigma-sz[u]);
}
int main()
{
    n=gi();q=gi();
    for (int i=1;i<n;i++)
    {
        int u=gi(),v=gi();
        a[++cnt]=(edge){v,head[u]};head[u]=cnt;
        a[++cnt]=(edge){u,head[v]};head[v]=cnt;
    }
    dfs1(1,0);dfs2(1,1);
    tot=w[0]=n;
    getroot(1,0);
    solve(root,0);
    for (int i=1;i<=n;i++)
        val[i]=gi(),modify(i,val[i]),sigma+=val[i];
    DP(1);
    while (q--)
    {
        int opt=gi(),x=gi();
        if (opt==1)
        {
            int y=gi();
            modify(x,y-val[x]);sigma+=y-val[x];
            omega+=(y-val[x])*calc(x);
            val[x]=y;
        }
        else printf("%lld\n",(calc(x)+sigma)*sigma-omega);
    }
    return 0;
}
```


  [1]: http://www.cnblogs.com/zhoushuyu/p/8309410.html

[2]: http://www.cnblogs.com/zhoushuyu/p/8277944.html


---

## 作者：Nemlit (赞：12)

首先我们要发现一个性质，对于每一棵树，我们换了一个根（把原本根的某个儿子$v_1$记成新的根）

我们记这个树的权值和为sum，每个子树的权值和为$S[i]$，对于每次换根，受影响的$S[i]$只有根本身和$v_1$，并且满足：$S[rt]->sum - S[v_1]$, $S[v_1] -> S[rt]$

于是我们能惊人的发现：$\sum (sum - S[i]) * S[i]$是一个定值！！！

把他拆开：$sum * \sum S[i] - \sum S[i] ^ 2$

而我们要求的正是$\sum S[i] ^ 2$，于是我们只要维护$sum * \sum S[i]$

因为我们会修改权值，发现$sum$值很好维护，于是我们只需要维护$\sum S[i]$即可

我们假设以x为根，那么$\sum S[i] = \sum (dep[i] + 1) * val[i] = sum + \sum dep[i] * val[i]$

若我们不用重新求$dep$，柿子即化为：$\sum S[i] = sum + \sum val[i] * dis(i, x) $

这个式子就是动态点分治的模板了，但是我们其实还有一个问题：就是我们的那个定值（$\sum (sum - S[i]) * S[i]$）要怎么求呢？

我们还是对每个点分开考虑：上述柿子的意义实际上是求出所有点的子树和 * (总的子树和 - 该点子树和)

我们分开考虑每一对点$(i, j)$的贡献，即两个点被分在不同集合的个数*权值之积

于是这个式子其实可以转化为$\sum_{i = 1}^n\sum_{j = i+ 1}^nval[i] * val[j] * dis(i, j)$

把$val[i]$提前，我们得到：$\sum_{i = 1} ^ n val[i] * \sum_{j = i + 1} ^ n val[j] * dis(i, j)$

所以每一次修改($a[x] \to y$)，变化量即为$(y - a[x]) *\sum val[j] * dis(j, i)$

这不就是$\sum S[i]$吗？？？

于是，我们就可以得到：
$$\sum (sum - S[i]) * S[i] = sum * \sum S[i] - \sum S[i] ^ 2$$

$$\sum S[i] ^ 2 = sum * \sum S[i] - \sum (sum - S[i]) * S[i]$$

$sum - 1$直接维护，$\sum S[i]$用动态点分治来维护，后面那一堆我们可以根据$\sum S[i]$来维护，于是我们就做完了。

终于把咕了一年多的代码补上了。
```cpp
/* This code is written by Nemlit */
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define rep(i, a, b) for(re int i = (a); i <= (b); ++ i)
#define Next(i, u) for(re int i = head[u]; i; i = e[i].next)
#define int long long
il int read() {
    re int x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
#define maxn 200005
int head[maxn], cnt, n, m, rt, N, A[maxn], vis[maxn], S, temp, R, a[maxn], w[maxn], f[maxn], Fa[maxn], g[maxn], dp[maxn];
int son[maxn], fa[maxn], dep[maxn], size[maxn], top[maxn];
struct edge { int v, next; }e[maxn << 1];
il void add(int u, int v) { e[++ cnt] = (edge){v, head[u]}, head[u] = cnt; }
il int LCA(int u, int v) {
	while(top[u] != top[v]) dep[top[u]] > dep[top[v]] ? u = fa[top[u]] : v = fa[top[v]];
	return dep[u] > dep[v] ? v : u;
}
il void dfs1(int u, int fr) {
	size[u] = 1, fa[u] = fr, dep[u] = dep[fr] + 1;
	Next(i, u) {
		int v = e[i].v;
		if(v == fr) continue;
		dfs1(v, u), size[u] += size[v];
		if(size[son[u]] < size[v]) son[u] = v;
	}
}
il void dfs2(int u, int fr) {
	top[u] = fr;
	if(son[u]) dfs2(son[u], fr);
	Next(i, u) {
		int v = e[i].v;
		if(v == fa[u] || v == son[u]) continue;
		dfs2(v, v);
	}
}
il int dist(int u, int v) {
	return dep[u] + dep[v] - 2 * dep[LCA(u, v)];
}
il void get_rt(int u, int fr) {
	dp[u] = 0, size[u] = 1;
	Next(i, u) {
		int v = e[i].v;
		if(vis[v] || v == fr) continue;
		get_rt(v, u), size[u] += size[v], dp[u] = max(dp[u], size[v]);
	}
	dp[u] = max(dp[u], N - size[u]);
	if(dp[u] < dp[rt]) rt = u;
}
il void build(int u) {
	vis[u] = 1;
	Next(i, u) if(!vis[e[i].v]) dp[rt = 0] = n, N = size[e[i].v], get_rt(e[i].v, u), Fa[rt] = u, build(rt);
}
il int query(int x) {
	int ans = f[x], now = x;
	while(now != R) ans += (f[Fa[now]] - g[now]) + (w[Fa[now]] - w[now]) * dist(x, Fa[now]), now = Fa[now];
	return ans;
}
il void insert(int x, int o) {
	int now = x, pax = o; o = A[x] - o, A[x] = pax;
	while(now != R) w[now] += o, f[now] += o * dist(x, now), g[now] += o * dist(x, Fa[now]), now = Fa[now]; 
	w[R] += o, f[R] += o * dist(x, R), temp += 2 * query(x) * o, S += o;
}
signed main() {
	n = read(), m = read();
	rep(i, 2, n) {
		int u = read(), v = read();
		add(u, v), add(v, u);
	}
	dfs1(1, 0), dfs2(1, 1), dp[rt = 0] = N = n, get_rt(1, 0), R = rt, build(rt);
	rep(i, 1, n) insert(i, read());
	rep(i, 1, m) {
		int opt = read(), x = read();
		if(opt == 1) insert(x, read());
		else printf("%lld\n", (S + query(x)) * S - temp / 2);
	}
	return 0;
}
```

---

## 作者：xyz32768 (赞：4)

- 先转化一下问题

- 每棵子树的权值和的平方和，相当于第一次选一个点 $x$ ，第二次再选一个点 $y$ ，贡献为 $a_x\times a_y\times dep[LCA(x,y)]$

- 其中 $a_x$ 为点 $x$ 的权， $dep[x]$ 为点 $x$ 的深度

- 同时，又有 $dist(x,y)=dep[x]+dep[y]-dep[LCA(x,y)]\times2$

- 于是 $dep[LCA(x,y)]=\frac{dep[x]+dep[y]-dist(x,y)}2$

- $dist(x,y)$ 为 $x$ 到 $y$ 的距离

- 于是每棵子树的权值和的平方和等于

- $$\frac 12\sum_x\sum_ya_x\times a_y\times(dep[x]+dep[y]-dist(x,y))$$

- $$=\frac 12(2(\sum_xa_x\times dep[x])(\sum_xa_x)-\sum_x\sum_ya_x\times a_y\times dist(x,y))$$

- 如果要询问以 $r$ 为根时每棵子树的权值和的平方和，那么 $dep[x]$ 实际上就是 $x$ 到 $r$ 的距离加一。修改时 $\sum_xa_x$ 很好维护，而我们的询问的关键也就是查询

- $$\sum_xa_x\times dist(x,r)$$

- 可以使用动态点分治，也可以使用和 [[LNOI2014]LCA](https://www.luogu.org/problemnew/show/P4211) 一样的做法

- 而至于 $\sum_x\sum_ya_x\times a_y\times dist(x,y)$ ，当 $a_u$ 加上 $v$ 之后这个式子的值会加上 $2v\sum_xa_x\times dist(x,u)$ ，也可以维护

- 复杂度 $O(n\log n)$ （动态点分治） $O(n\log^2n)$ （树剖）

- 代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define p2 p << 1
#define p3 p << 1 | 1

inline int read()
{
	int res = 0; bool bo = 0; char c;
	while (((c = getchar()) < '0' || c > '9') && c != '-');
	if (c == '-') bo = 1; else res = c - 48;
	while ((c = getchar()) >= '0' && c <= '9')
		res = (res << 3) + (res << 1) + (c - 48);
	return bo ? ~res + 1 : res;
}

template <class T>
inline void Swap(T &a, T &b) {T t = a; a = b; b = t;}

typedef long long ll;

const int N = 2e5 + 5, M = N << 1, L = M << 1;

int n, q, ecnt, nxt[M], adj[N], go[M], a[N], fa[N], dep[N], sze[N], son[N],
top[N], pos[N], ToT, suma;
ll sum[L], add[L], sumad, sumdis;

void down(int p)
{
	add[p2] += add[p]; add[p3] += add[p];
	add[p] = 0;
}

void upt(int l, int r, int p)
{
	int mid = l + r >> 1;
	sum[p] = sum[p2] + sum[p3] +
		add[p2] * (mid - l + 1) + add[p3] * (r - mid);
}

void change(int l, int r, int s, int e, int v, int p)
{
	if (l == s && r == e) return (void) (add[p] += v);
	int mid = l + r >> 1; down(p);
	if (e <= mid) change(l, mid, s, e, v, p2);
	else if (s > mid) change(mid + 1, r, s, e, v, p3);
	else change(l, mid, s, mid, v, p2),
		change(mid + 1, r, mid + 1, e, v, p3);
	upt(l, r, p);
}

void change(int u, int v, int w)
{
	while (top[u] != top[v])
	{
		if (dep[top[u]] < dep[top[v]]) Swap(u, v);
		change(1, n, pos[top[u]], pos[u], w, 1);
		u = fa[top[u]];
	}
	if (dep[u] > dep[v]) Swap(u, v);
	change(1, n, pos[u], pos[v], w, 1);
}

ll ask(int l, int r, int s, int  e, int p)
{
	if (l == s && r == e) return sum[p] + add[p] * (r - l + 1);
	int mid = l + r >> 1; down(p); ll res;
	if (e <= mid) res = ask(l, mid, s, e, p2);
	else if (s > mid) res = ask(mid + 1, r, s, e, p3);
	else res = ask(l, mid, s, mid, p2) + ask(mid + 1, r, mid + 1, e, p3);
	return upt(l, r, p), res;
}

ll ask(int u, int v)
{
	ll res = 0;
	while (top[u] != top[v])
	{
		if (dep[top[u]] < dep[top[v]]) Swap(u, v);
		res += ask(1, n, pos[top[u]], pos[u], 1);
		u = fa[top[u]];
	}
	if (dep[u] > dep[v]) Swap(u, v);
	return res + ask(1, n, pos[u], pos[v], 1);
}

void add_edge(int u, int v)
{
	nxt[++ecnt] = adj[u]; adj[u] = ecnt; go[ecnt] = v;
	nxt[++ecnt] = adj[v]; adj[v] = ecnt; go[ecnt] = u;
}

void dfs1(int u, int fu)
{
	dep[u] = dep[fa[u] = fu] + (sze[u] = 1);
	sumad += 1ll * a[u] * dep[u];
	for (int e = adj[u], v; e; e = nxt[e])
	{
		if ((v = go[e]) == fu) continue;
		dfs1(v, u); sze[u] += sze[v];
		if (sze[v] > sze[son[u]]) son[u] = v;
	}
}

void dfs2(int u, int fu)
{
	if (son[u])
	{
		top[son[u]] = top[u];
		pos[son[u]] = ++ToT;
		dfs2(son[u], u);
	}
	for (int e = adj[u], v; e; e = nxt[e])
		if ((v = go[e]) != fu && v != son[u])
			pos[top[v] = v] = ++ToT, dfs2(v, u);
}

ll weighted_dis(int rt)
{
	return sumad + 1ll * suma * dep[rt] - (ask(1, rt) << 1);
}

void init()
{
	pos[1] = top[1] = ToT = 1;
	dfs1(1, 0); dfs2(1, 0);
	for (int i = 1; i <= n; i++) change(1, i, a[i]);
	for (int i = 1; i <= n; i++)
		sumdis += weighted_dis(i) * a[i];
}

int main()
{
	int x, y, op;
	n = read(); q = read();
	for (int i = 1; i < n; i++)
		x = read(), y = read(), add_edge(x, y);
	for (int i = 1; i <= n; i++) suma += (a[i] = read());
	init();
	while (q--)
	{
		op = read(); x = read();
		if (op == 1)
		{
			y = read();
			change(1, x, y - a[x]);
			suma += y - a[x];
			sumad += 1ll * (y - a[x]) * dep[x];
			sumdis += 2ll * (y - a[x]) * weighted_dis(x);
			a[x] = y;
		}
		else printf("%lld\n", (2ll * suma * weighted_dis(x)
			- sumdis >> 1) + 1ll * suma * suma);
	}
	return 0;
}
```

---

## 作者：qwaszx (赞：3)

感觉难度虚高.

首先根全是$1$的情况很好做，直接预处理就好了.对于修改点权可以变成加，然后对于子树和相当于是一条链加，树剖，然后$(s[i]+a)^2=s[i]^2+2as[i]+a^2$，拿线段树维护一下区间和就好了.

现在考虑换根.这里借助树形dp的思想，换根之后的答案只有询问点到根这一条链上的子树大小有变化.记$S$是这条链上的点的集合，$son[u]$是$u$在这条链上的儿子，询问点为$x$，那么新的答案就是

$ans'=ans-\sum\limits_{u\in S}s[u]^2+\sum\limits_{u\in S,u\neq x}(s[1]-s[son[u]])^2+s[1]^2$

就是减掉原来的贡献加上新的贡献，新的子树点权和就是整棵树的点权和减去儿子的点权和.

然后可以简单地化一化式子.

$\begin{aligned}\text{原式}&=ans-\sum\limits_{u\in S}s[u]^2+\sum\limits_{u\in S,u\neq 1}s[u]^2+|S|s[1]^2-2s[1]\sum\limits_{u\in S,u\neq 1}s[u]\\&=(|S|-1)s[1]^2-2s[1]\sum\limits_{u\in S,u\neq 1}s[u]\end{aligned}$

于是只需要维护$s[1]$，区间和，顺便维护下$ans$即可.

不知道为什么开O2会负优化emm

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=2e6;
long long s1[N],s[N],ans=0;
int size[N],dep[N],son[N],w[N],f[N],id[N],tw[N],nxt[N],fst[N],to[N],n,q,tp[N],dfs_cnt,tag[N],mm;
void ade(int u,int v){to[++mm]=v;nxt[mm]=fst[u],fst[u]=mm;}
void dfs1(int u,int fa)
{
	f[u]=fa;dep[u]=dep[fa]+1;size[u]=1;s[u]=w[u];
	int mx=0;
	for(int i=fst[u];i;i=nxt[i])
	{
		int v=to[i];if(v==fa)continue;
		dfs1(v,u);size[u]+=size[v],s[u]+=s[v];
		if(size[v]>mx)mx=size[v],son[u]=v;
	}
	ans+=s[u]*s[u];
}
void dfs2(int u,int top)
{
	tp[u]=top;id[u]=++dfs_cnt;tw[dfs_cnt]=s[u];
	if(son[u])dfs2(son[u],top);
	for(int i=fst[u];i;i=nxt[i])
		if(to[i]!=f[u]&&to[i]!=son[u])
			dfs2(to[i],to[i]);
}
void pushup(int rot){s1[rot]=s1[rot<<1]+s1[rot<<1|1];}
void build(int rot,int lt,int rt)
{
	tag[rot]=0;
	if(lt==rt){s1[rot]=tw[lt];return;}
	int mid=(lt+rt)>>1;
	build(rot<<1,lt,mid),build(rot<<1|1,mid+1,rt);
	pushup(rot);
}
void upd(int rot,int lt,int rt,long long w)
{
	int len=rt-lt+1;s1[rot]+=len*w;tag[rot]+=w;
}
void pushdown(int rot,int lt,int rt)
{
	if(tag[rot])
	{
		int mid=(lt+rt)>>1;long long t=tag[rot];tag[rot]=0;
		upd(rot<<1,lt,mid,t),upd(rot<<1|1,mid+1,rt,t);
	}
}
void update(int rot,int lt,int rt,int lq,int rq,int w)
{
	if(lt>=lq&&rt<=rq){ans+=2*w*s1[rot]+(rt-lt+1)*w*w;upd(rot,lt,rt,w);return;}
	int mid=(lt+rt)>>1;pushdown(rot,lt,rt);
	if(lq<=mid)update(rot<<1,lt,mid,lq,rq,w);
	if(rq>mid)update(rot<<1|1,mid+1,rt,lq,rq,w);
	pushup(rot);
}
void update(int u,int w)
{
	while(tp[u]!=1)
	{
		update(1,1,n,id[tp[u]],id[u],w);
		u=f[tp[u]];
	}
	update(1,1,n,1,id[u],w);s[1]+=w;
}
long long query(int rot,int lt,int rt,int lq,int rq)
{
	if(lt>=lq&&rt<=rq)return s1[rot];
	int mid=(lt+rt)>>1;pushdown(rot,lt,rt);
	long long ans=0;
	if(lq<=mid)ans+=query(rot<<1,lt,mid,lq,rq);
	if(rq>mid)ans+=query(rot<<1|1,mid+1,rt,lq,rq);
	return ans;
}
long long query(int u)
{
	long long ans=0;
	while(tp[u]!=1)
	{
		ans+=query(1,1,n,id[tp[u]],id[u]);
		u=f[tp[u]];
	}
	if(u!=1)ans+=query(1,1,n,2,id[u]);
	return ans;
}
int main()
{
	scanf("%d%d",&n,&q);
	for(int i=1,u,v;i<n;i++){scanf("%d%d",&u,&v);ade(u,v),ade(v,u);}
	for(int i=1;i<=n;i++)scanf("%d",w+i);
	dfs1(1,0),dfs2(1,1);
	build(1,1,n);
	for(int i=1;i<=q;i++)
	{
		int opt,x,y;
		scanf("%d%d",&opt,&x);
		if(opt==1)
		{
			scanf("%d",&y);
			update(x,-w[x]),update(x,w[x]=y);
		}
		else
		{
			int len=dep[x];
			printf("%lld\n",ans+(len-1)*s[1]*s[1]-2*s[1]*query(x));
		}
	}
}
```

---

## 作者：Jμdge (赞：3)


一道数学公式化简题？

我们考虑树剖去维护每次更新和询问

那么我们考虑维护什么值：

~~既然题目要求维护子树和那当然是维护子树和啦~~


我们先来强行推一波（感觉推得很玄学 emmm... ）


# query


首先我们令$w_i$ 为点权， $s_i$ 为 $i$ 号点的子树和，$ans_i$ 为 $i$ 号点为根时候的答案，那么有：


$$ans_u=ans_1-\sum_{i=1}^{k-1} s_i ^{~ 2} +\sum_{i=1}^{k-1}(s_1-s_{i+1})^{~ 2} - s_k^{~ 2} + s_1^{~2}$$


也就是：

$$ans_u=ans_1-\sum_{i=2}^{k} s_i ^{~ 2} +\sum_{i=1}^{k-1}(s_1-s_{i+1})^{~ 2} $$

上面的 1~k 个节点为从 1 到 u 的简单路径上顺序的点

那么把这个式子化简一下：

$$ans_u=ans_1-\sum_{i=2}^{k} s_i ^{~ 2} +\sum_{i=2}^{k} s_i^{~ 2} + k ·s_1^{~ 2} - 2 ·s_1\sum_{i=2}^{k}s_i$$

（就只要展开就好啦~）
然后我们消掉 $s_i^{~2}$：

$$ans_u=ans_1 + s_{1}(k·s_1-2·\sum_{i=2}^ks_i) $$


继续变得更容易处理：

$$ans_u=ans_1 + s_{1}((k+1)·s_1-2·\sum_{i=1}^ks_i) $$


这样的话我们树剖维护一条链上的信息就能回答询问了，复杂度 $log^2~ n$

# update

然后我们考虑更新

那么更新的话首先 1~k 的节点的 $s_k$ 肯定要加上 $w_k$ 的增（加）量 x

然后我们考虑减去这些节点原来的贡献，让这些节点加上这些增量，然后再把贡献加回去

那么这些节点加上 x 后比原来多了多少贡献？

我们考虑：

$$\sum_{i=1}^{k}(s_i+x)^{~2}-\sum_{i=1}^{k}s_i^{~2}=x(k·x +  2 \sum_{i=1}^k s_i )$$

那么我们考虑去树剖处理后面那个链的信息就好了，然后在把贡献加到链上




# code



我们考虑不压行（个鬼），于是代码就长这样：



```cpp
//by Judge
#include<cstdio>
#include<iostream>
#define fp(i,a,b) for(int i=(a),I=(b)+1;i<I;++i)
#define go(G,u) for(int i=G.head[u],v=G.e[i].to;i;v=G.e[i=G.e[i].nxt].to)
#define ll long long
using namespace std;
const int M=2e5+3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline bool cmax(int& a,int b){return a<b?a=b,1:0;}
inline bool cmin(int& a,int b){return a>b?a=b,1:0;}
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
inline void print(ll x,char chr='\n'){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]=chr;
} int n,m,tim; ll ans;
arr w,c,fa,son,siz,dep,top,dfn,id;
struct Gr{ int pat,head[M];
	struct Edge{ int to,nxt; }e[M<<1];
	inline void add(int u,int v){
		e[++pat]={v,head[u]},head[u]=pat;
		e[++pat]={u,head[v]},head[v]=pat;
	}
}G;
namespace BIT{ ll f1[M],f2[M];
	#define lowbit(x) (x&-x)
	inline void add(int x,ll v){
		for(int i=x;i<=n;i+=lowbit(i))
			f1[i]+=v,f2[i]+=x*v;
	}
	inline int ask(int x,ll s=0){
		for(int i=x;i;i^=lowbit(i))
			s+=(x+1)*f1[i]-f2[i]; return s;
	}
} using namespace BIT;
void dfs(int u,int f){
	dep[u]=dep[f]+1,siz[u]=1;
	go(G,u) if(v^f){ fa[v]=u,dfs(v,u);
		w[u]+=w[v],siz[u]+=siz[v];
		if(siz[v]>siz[son[u]]) son[u]=v;
	} ans+=1ll*w[u]*w[u];
}
void dfs(int u){ if(!top[u]) top[u]=u;
	id[dfn[u]=++tim]=u,add(dfn[u],w[u]-w[id[tim-1]]);
	if(son[u]) top[son[u]]=top[u],dfs(son[u]);
	go(G,u) if(v^fa[u]&&v^son[u]) dfs(v);
}
inline ll query(int u){
	int k=0,x=ask(1); ll s=0;
	for(;u;u=fa[top[u]])
		k+=dfn[u]-dfn[top[u]]+1,
		s+=ask(dfn[u])-ask(dfn[top[u]]-1);
	return ans+x*(1ll*(k+1)*x-(s<<1));
}
inline void update(int u,int x){
	int k=0; ll s=0;
	for(;u;u=fa[top[u]])
		k+=dfn[u]-dfn[top[u]]+1,
		s+=ask(dfn[u])-ask(dfn[top[u]]-1),
		add(dfn[top[u]],x),add(dfn[u]+1,-x);
	ans+=x*(1ll*x*k+(s<<1));
}
int main(){ n=read(),m=read(); int op,x,y;
	fp(i,2,n) x=read(),y=read(),G.add(x,y);
	fp(i,1,n) w[i]=c[i]=read(); dfs(1,0),dfs(1);
	fp(T,1,m){ op=read(),x=read();
		if(op&1) y=read()-c[x],c[x]+=y,update(x,y);
		else print(query(x));
	} return Ot(),0;
}
```



---

## 作者：luoyue123 (赞：2)

思路就是楼下zzq大神的思路，然后这里是代码实现。

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
```cpp
    #include<bits/stdc++.h>
    using namespace std;
    #define ll long long
    const ll MAXN=4e5+5;
    ll n,q,w[MAXN];
    ll esum=0,ww[MAXN];
    struct edge{
        ll to,next,w;
    }e[MAXN<<1];
    ll head[MAXN],cnt=0;
    inline void add(ll u,ll v,ll w){    
        e[++cnt]=(edge){v,head[u],w},head[u]=cnt;
        e[++cnt]=(edge){u,head[v],w},head[v]=cnt;
    }
    ll fa[MAXN],size[MAXN],hson[MAXN],dep[MAXN],dis[MAXN];
    void dfs1(ll u,ll father){
        dep[u]=dep[father]+1;
        fa[u]=father;
        size[u]=1;
        for(ll i=head[u];i;i=e[i].next){
            ll v=e[i].to,w=e[i].w;
            if(v==father)continue;
            dis[v]=dis[u]+w;
            dfs1(v,u);
            size[u]+=size[v];
            if(size[v]>size[hson[u]]||!hson[u])hson[u]=v;
        }
    }
    ll top[MAXN];
    void dfs2(ll u,ll tp){
        top[u]=tp;
        if(hson[u])dfs2(hson[u],tp);
        for(ll i=head[u];i;i=e[i].next){
            ll v=e[i].to;
            if(v==fa[u]||v==hson[u])continue;
            dfs2(v,v);
        }
    }
    inline ll lca(ll x,ll y){
        ll tx=top[x],ty=top[y];
        while(tx!=ty){
            if(dep[tx]>dep[ty]) x=fa[tx];
            else y=fa[ty];
            tx=top[x],ty=top[y];
        }
        if(dep[x]>dep[y])swap(x,y);
        return x;
    }
    ll rsize[MAXN],f[MAXN],sum,rt,par[MAXN],sub[MAXN],subfa[MAXN];
    ll sumw[MAXN],sumwfa[MAXN];
    bool vis[MAXN];
    void getrt(ll u,ll fa){
        rsize[u]=1;
        f[u]=0;
        for(ll i=head[u];i;i=e[i].next){
            ll v=e[i].to,w=e[i].w;
            if(v==fa||vis[v])continue;
            getrt(v,u);
            rsize[u]+=rsize[v];
            f[u]=max(f[u],rsize[v]);
        }
        if(f[u]<sum-rsize[u])f[u]=sum-rsize[u];
        if(f[u]<f[rt])rt=u;
    }
    void getsz(ll u,ll fa){
        rsize[u]=1;
        for(ll i=head[u];i;i=e[i].next){
            ll v=e[i].to;
            if(v==fa||vis[v])continue;
            getrt(v,u);
            rsize[u]+=rsize[v];
        }
    }
    void solve(ll u,ll fa){
        vis[u]=1;par[u]=fa;
        for(ll i=head[u];i;i=e[i].next){
            ll v=e[i].to;
            if(v==fa||vis[v])continue;
            getsz(v,0);
            f[0]=sum=rsize[v];
            getrt(v,rt=0);
            solve(rt,u);
        }
    }
    inline ll getdis(ll x,ll y){
        return dis[x]+dis[y]-(dis[lca(x,y)]<<1);
    }
    void memfz(){//sub为cost 
        for(ll u=1;u<=n;u++){
            sumw[u]+=w[u]; 
            for(ll i=u;par[i];i=par[i]){
                ll dist=getdis(u,par[i]);
                sumw[par[i]]+=w[u];
                sumwfa[i]+=w[u];
                sub[par[i]]+=dist*w[u];
                subfa[i]+=dist*w[u];
            }
        }
    }
    ll calc(ll u){
        ll ans=sub[u];
        for(ll i=u;par[i];i=par[i]){
            ll dist=getdis(par[i],u);
            ans+=sub[par[i]]-subfa[i];
            ans+=dist*(sumw[par[i]]-sumwfa[i]);
        }
        return ans+esum;
    }
    struct rt1tree{
        #define lson (o<<1)
        #define rson (o<<1|1)
        ll size[MAXN],dep[MAXN],fa[MAXN],hson[MAXN];
        void dfs1(ll u,ll father){
            size[u]=1;
            dep[u]=dep[father]+1;
            fa[u]=father;
            for(ll i=head[u];i;i=e[i].next){
                ll v=e[i].to;
                if(v==father)continue;
                dfs1(v,u);
                ww[u]+=ww[v];
                size[u]+=size[v];
                if(!hson[u]||size[v]>size[hson[u]])hson[u]=v;
            } 
        }
        ll id[MAXN],top[MAXN],real1[MAXN];
        ll num;
        void dfs2(ll u,ll tp){
            top[u]=tp;
            id[u]=++num;
            real1[num]=u;
            if(hson[u])dfs2(hson[u],tp);
            for(ll i=head[u];i;i=e[i].next){
                ll v=e[i].to;
                if(v==fa[u]||v==hson[u])continue;
                dfs2(v,v);
            } 
        }
        ll sumv[MAXN<<2],lzt[MAXN<<2];
        inline void pushdown(ll o,ll l,ll r){
            if(lzt[o]){
                ll mid=(l+r)>>1;
                lzt[lson]+=lzt[o];sumv[lson]+=(mid-l+1)*lzt[o];
                lzt[rson]+=lzt[o];sumv[rson]+=(r-mid)*lzt[o];
                lzt[o]=0;
            }
        }
        inline void pushup(ll o){sumv[o]=sumv[lson]+sumv[rson];}
        void build(ll o,ll l,ll r){
            lzt[o]=0;
            if(l==r){sumv[o]=ww[real1[l]];return;}
            ll mid=(l+r)>>1;
            build(lson,l,mid);
            build(rson,mid+1,r);
            pushup(o);
        }
        void change(ll o,ll l,ll r,ll ql,ll qr,ll w){
            if(ql<=l&&qr>=r){sumv[o]+=(r-l+1)*w;lzt[o]+=w;return;}
            ll mid=(l+r)>>1;
            pushdown(o,l,r);
            if(ql<=mid)change(lson,l,mid,ql,qr,w);
            if(qr>mid)change(rson,mid+1,r,ql,qr,w);
            pushup(o);
        }
        ll query(ll o,ll l,ll r,ll ql,ll qr){
            if(ql<=l&&qr>=r){return sumv[o];}
            ll mid=(l+r)>>1,ans=0;
            pushdown(o,l,r);
            if(ql<=mid)ans+=query(lson,l,mid,ql,qr);
            if(qr>mid)ans+=query(rson,mid+1,r,ql,qr);
            return ans;
        }
        inline void chain_change(ll x,ll y,ll w){
            ll tx=top[x],ty=top[y];
            while(tx!=ty){
                if(dep[tx]>dep[ty]){
                    change(1,1,n,id[tx],id[x],w);
                    x=fa[tx];
                }
                else {
                    change(1,1,n,id[ty],id[y],w);
                    y=fa[ty];
                }
                tx=top[x],ty=top[y];
            }
            if(dep[x]<dep[y])swap(x,y);
            change(1,1,n,id[y],id[x],w);
        }
        inline ll chain_query(ll x,ll y){
            ll tx=top[x],ty=top[y];
            ll ans=0;
            while(tx!=ty){
                if(dep[tx]>dep[ty]){
                    ans+=query(1,1,n,id[tx],id[x]);
                    x=fa[tx];
                }
                else {
                    ans+=query(1,1,n,id[ty],id[y]);
                    y=fa[ty];
                }
                tx=top[x],ty=top[y];
            }
            if(dep[x]<dep[y])swap(x,y);
            ans+=query(1,1,n,id[y],id[x]);
            return ans;
        }
        inline ll querysub(ll p){
            return query(1,1,n,id[p],id[p]+size[p]-1);
        }
    }T;
    inline void dianfen_change(ll p,ll q){
        sumw[p]+=q;
        for(ll i=p;par[i];i=par[i]){
            ll dist=getdis(p,par[i]);
            ll cost=q*dist;
            sumw[par[i]]+=q;
            sumwfa[i]+=q;
            sub[par[i]]+=cost;
            subfa[i]+=cost;
        }
    }
    int main(){
        ll oldrt,wfang=0;
        T.num=0;
        memset(vis,0,sizeof(vis));
        scanf("%lld%lld",&n,&q);
        for(ll i=1;i<n;i++){
            ll tem1,tem2;
            scanf("%lld%lld",&tem1,&tem2);
            add(tem1,tem2,1);
        }
        for(ll i=1;i<=n;i++){
            scanf("%lld",&w[i]);
            ww[i]=w[i];
            esum+=w[i];
        }
        sum=f[0]=n;
        getrt(1,rt=0);
        oldrt=rt;
        solve(rt,0);
        dfs1(oldrt,oldrt);
        dfs2(oldrt,oldrt);    
        memfz();
        T.dfs1(1,1);
        T.dfs2(1,1);
        T.build(1,1,n);
        for(ll i=1;i<=n;i++)wfang+=T.chain_query(i,i)*T.chain_query(i,i);
        for(ll i=1;i<=q;i++){
            ll tem1,tem2,tem3;
            scanf("%lld%lld",&tem1,&tem2);
            if(tem1==1){
                scanf("%lld",&tem3);
                ll q=tem3-w[tem2];
                esum+=q;
                w[tem2]=tem3;
                ll p=T.chain_query(1,tem2);
                wfang+=((p*q)<<1)+(getdis(1,tem2)+1)*q*q;
                T.chain_change(1,tem2,q);
                dianfen_change(tem2,q);
            }
            else {
                ll g=calc(1);
                g*=esum;
                g-=wfang;
                ll ww=calc(tem2);
                ww*=esum;
                ww-=g;
                printf("%lld\n",ww);
            }
        }
        return 0;
    }

```

---

## 作者：Guitar_Jasmine (赞：1)

首先我们考虑如果题目要求的不是子树平方和而是子树和，也就是$\sum_{i=1}^{n}siz[i]$，那么每个点的贡献就是他到根的距离加一，所以答案也可以写成：
$\sum_{i=1}^{n}a[i] \times dis(i,p)+Sum$（其中$p$表示当前的根，$a[i]$表示点$i$的点权，$Sum=\sum a[i]$）。
我们发现这个东西其实就是[P3345 [ZJOI2015]幻想乡战略游戏](https://www.luogu.com.cn/problem/P3345)这个题，为了后文柿子的表达方便，我们记
$calc(p)=\sum_{i=1}^{n}a[i] \times dis(i,p)$

然后这个平方很不好处理。首先给出一个结论，无论根在哪里，$\sum_{i=1}^{n}siz[i] \times (Sum-siz[i])$的值恒定（记这个常量为$W$）。

怎么证明呢，发现任意两点$i,j$对上述式子的贡献是$a[i] \times a[j] \times dis(i,j)$，这个东西无论根在哪里都不会变的。

然后稍微变形一下就能推出$\sum siz[i]^2=Sum \times (calc(p)+Sum) - W$。所以我们可以在根为$1$的时候求出$W$然后动态点分治维护$calc(p)$就好了。

现在的问题就是如何维护。除了$W$以外其他都是非常好维护的，我们发现一个节点$k$对$W$的贡献为
$a[k] \times \sum_{i=1}^{n}a[i] \times dis(i,k)=a[k] \times calc(k)$，然后对于怎么维护$W$就不用多说了吧。。。

代码：

```
#pragma GCC optimize(2)
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#define rint int

using namespace std;

typedef long long LL;
const int N=1000009;
int n,Q,root,head[N],cnt,F[N],log[N],a[N];
LL dis1[N],dis2[N],sum[N],W,Sum;
struct Edge
{
	int nxt,to,w;
}g[N*2];
struct G
{
	int head[N],cnt,f[N][30],dep[N],del[N],siz[N],Euler[N],Fst[N],Index;
	struct Edge
	{
		int nxt,to;
	}g[N*2];
	
	void add(int from,int to)
	{
		g[++cnt].nxt=head[from];
		g[cnt].to=to;
		head[from]=cnt;
	}
	int LCA(int x,int y)
	{
		if(Fst[x]>Fst[y])
			swap(x,y);
		x=Fst[x],y=Fst[y];
		int k=log[y-x+1];
		return dep[f[x][k]]<dep[f[y-(1<<k)+1][k]]?f[x][k]:f[y-(1<<k)+1][k];
	}
	void dfs(int x,int fa)
	{
		Euler[++Index]=x,Fst[x]=Index,f[Index][0]=x;
		for (rint i=head[x];i;i=g[i].nxt)
		{
			int v=g[i].to;
			if(v==fa)
				continue;
			dep[v]=dep[x]+1;
			dfs(v,x);
			Euler[++Index]=x,f[Index][0]=x;
		}
	}
	int Get_dis(int x,int y)
	{
		return dep[x]+dep[y]-2*dep[LCA(x,y)];
	}
	void DFS(int x,int fa)
	{
		siz[x]=1;
		for (rint i=head[x];i;i=g[i].nxt)
		{
			int v=g[i].to;
			if(v==fa||del[v])
				continue;
			DFS(v,x);
			siz[x]+=siz[v];
		}
	}
	int Get_Weight(int x)
	{
		DFS(x,-1);
		int k=siz[x]/2,fa=-1;
		while(1)
		{
			int tmp=0;
			for (rint i=head[x];i;i=g[i].nxt)
			{
				int v=g[i].to;
				if(v==fa||del[v])
					continue;
				if(siz[v]>siz[tmp])
					tmp=v;
			}
			if(siz[tmp]<=k)
				return x;
			fa=x,x=tmp;
		}
	}
	void work()
	{
		dfs(1,-1);
		for (int j=1;1<<j<=Index;j++)
			for (int i=1;i+(1<<j)-1<=Index;i++)
				if(dep[f[i][j-1]]<dep[f[i+(1<<j-1)][j-1]])
					f[i][j]=f[i][j-1];
				else
					f[i][j]=f[i+(1<<j-1)][j-1];
	}
	void dfs_1(int x,int fa)
	{
		siz[x]=a[x];
		for (int i=head[x];i;i=g[i].nxt)
		{
			int v=g[i].to;
			if(v==fa)
				continue;
			dfs_1(v,x);
			siz[x]+=siz[v];
		}
	}
}T;

void add(int from,int to,int w)
{
	g[++cnt].nxt=head[from];
	g[cnt].to=to;
	g[cnt].w=w;
	head[from]=cnt;
}

int read()
{
	char c=getchar();
	int x=0,f=1;
	while(c<'0'||c>'9')
	{
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
		x=x*10+c-'0',c=getchar();
	return x*f;
}

void init()
{
	log[0]=-1;
	for (int i=1;i<=N-9;i++)
		log[i]=log[i>>1]+1;
	n=read(),Q=read();
	for (rint i=1;i<n;i++)
	{
		int x,y;
		x=read(),y=read();
		T.add(x,y),T.add(y,x);
	}
	T.work();
}

void build(int fa)
{
	T.del[fa]=1;
	for (rint i=T.head[fa];i;i=T.g[i].nxt)
	{
		int v=T.g[i].to;
		if(T.del[v]||v==fa)
			continue;
		int w=T.Get_Weight(v);
		F[w]=fa,add(fa,w,v),add(w,fa,v);
		build(w);
	}
}

void Modify(int x,int y)
{
	for (rint i=x;i;i=F[i])
	{
		sum[i]+=y;
		if(i!=root)
		{
			LL fuck=1LL*T.Get_dis(x,F[i])*y;
			dis1[F[i]]+=fuck,dis2[i]+=fuck;
		}
	}
}

LL calc(int x)
{
	LL ans=dis1[x];
	for (rint i=x;F[i];i=F[i])
	{
		ans+=dis1[F[i]]-dis2[i];
		ans+=(sum[F[i]]-sum[i])*T.Get_dis(x,F[i]);
	}
	return ans;
}

void work()
{
	root=T.Get_Weight(1);
	build(root);
	for (int i=1;i<=n;i++)
		scanf("%d",&a[i]),Modify(i,a[i]),Sum+=a[i];
	T.dfs_1(1,-1);
	for (int i=1;i<=n;i++)
		W+=(Sum-T.siz[i])*T.siz[i];
	for (rint _=1;_<=Q;_++)
	{
		int x,y,opt;
		opt=read();
		if(opt==1)
		{
			x=read(),y=read();
			int delx=y-a[x];
			W+=calc(x)*delx,Sum+=delx;
			Modify(x,delx);
			a[x]=y;
		}
		else
		{
			x=read();
			printf("%lld\n",Sum*(Sum+calc(x))-W);
		}
	}
}

int main()
{
	init();
	work();
	return 0;
}
```


---

## 作者：2018LZY (赞：1)

这是一道树剖题，我们只维护根为1的答案，然后考虑能不能用这个答案转换为根为其他值的答案。（其实只要特征值具有可加减性树剖就无惧换根）

设$s[x]$表示以1为根时，x的子树权值和.

有两个操作：

1. 修改x的值（设增加y)。那么只有x的祖宗的子树权值和(其实也包括自己)会变化。1~x的路径很明显只有$dep[x]$个点，那么

$ans'=ans+(\sum_{i\in path(1,x}(s[i]+y)^2)-(\sum_{i\in path(1,x)}s[i]^2)$

$~~~~~~~~~=ans+dep[x]*y^2+2y*(\sum_{i\in path(1,x)}s[i])$

$~~~~~~~~~=ans+y*(dep[x]*y+(\sum_{i\in path(1,x)}s[i])*2)$
1. 换根。（其实树剖的根一直为1）换根其实只对$path(1,x)$的点的s发生改变。
我们设$path(1,x)$中点的s分别为$a_1,a_2,……a_{dep[x]}$,换根后即为$b_1,b_2……b_{dep[x]}$
(注：$a_1$,为1号点的s,$b_1$为1号点换根后的s，下标与dep相等)
则有：$a_{i+1}+b_i=s_1$ 

$ans'=ans-\sum_{i\in path(1,x)}a_i^2+\sum_{i\in path(1,x)}b_i^2$

$~~~~~~~~~=ans-\sum_{i\in path(1,x)}a_i^2+\sum_{i=1}^{dep[x]-1}(s_1-a_{i+1})^2-b_{dep[x]}^2$

$~~~~~~~~~=ans-\sum_{i=2}^{dep[x]}a_i^2+\sum_{i=1}^{dep[x]-1}(s_1-a_{i+1})^2$

$~~~~~~~~~=ans-(dep[x]-1)*s_1^2-2*s_1*\sum_{i=2}^{dep[x]}a_i^2$

$~~~~~~~~~=ans-(dep[x]+1)*s_1-2*s_1*\sum_{i=1}^{dep[x]}a_i^2$

$~~~~~~~~~=ans-s1*((dep[x]+1)-2*\sum_{i=1}^{dep[x]} a_i^2)$

具体用[树状数组维护差分数组](https://blog.csdn.net/qq_42886072/article/details/96845636)，实现区间加，区间求和。~~（其实用线段树更好理解）~~

代码：
```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
#define g getchar()
using namespace std;
typedef long long ll;
const int N=2e5+10;
struct edge{int y,next;}a[N<<1];int len,last[N];
void ins(int x,int y){a[++len]=(edge){y,last[x]};last[x]=len;}
int n,m,fa[N],dep[N],son[N],tot[N],sum[N],d[N]; ll ans;
void dfs1(int x) {
	tot[x]=1;son[x]=0;
	for(int k=last[x];k;k=a[k].next) {
		int y=a[k].y;if(y==fa[x])continue;
		dep[y]=dep[x]+1;fa[y]=x;dfs1(y);sum[x]+=sum[y];
		tot[x]+=tot[y];if(tot[y]>tot[son[x]])son[x]=y;
	}
	ans+=1LL*sum[x]*sum[x];//2e6*2e6=爆int
}
ll c1[N],c2[N];//树状数组维护区间加、区间求和 
void up(int x,ll d){for(ll y=x*d;x<=n;x+=x&-x)c1[x]+=d,c2[x]+=y;}
ll down(int x){ll s=0;for(ll y=x+1;x;x-=x&-x)s+=y*c1[x]-c2[x];return s;}
int z,ys[N],yss[N],top[N];
void dfs2(int x,int tp) {
	yss[ys[x]=++z]=x;top[x]=tp;
	up(z,sum[x]-sum[yss[z-1]]);
	if(son[x])dfs2(son[x],tp);
	for(int k=last[x];k;k=a[k].next) {
		int y=a[k].y;
		if(y!=fa[x]&&y!=son[x])dfs2(y,y);
	}
}
void add(int x,int y) {
	int k=dep[x];ll s=0;
	for(int tx=top[x];x;tx=top[x=fa[tx]]) {
		s+=down(ys[x])-down(ys[tx]-1);
		up(ys[tx],y);up(ys[x]+1,-y);//维护差分
	}
	ans+=y*((s<<1)+k*y);
}
ll query(int x) {
	int k=dep[x]+1;ll w=down(1),s=0;
	for(int tx=top[x];x;tx=top[x=fa[tx]])
		s+=down(ys[x])-down(ys[tx]-1);
	return ans+w*(w*k-(s<<1));
}
void qr(int &x) {
	char c=g;int f=1;x=0;
	while(!isdigit(c)){if(c=='-')f=-1;c=g;}
	while(isdigit(c))x=x*10+c-48,c=g;
	x*=f;
}
void write(ll x) {
	if(x/10)write(x/10);
	putchar(x%10+'0');
}
void pri(ll x) {
	if(x<0)putchar('-'),x=-x;
	write(x);puts("");
}
int main() {
	qr(n);qr(m); int x,y,op;
	for(int i=1;i<n;i++)qr(x),qr(y),ins(x,y),ins(y,x);
	for(int i=1;i<=n;i++)qr(sum[i]),d[i]=sum[i];
	dep[1]=1;fa[1]=0;dfs1(1);
	z=0;dfs2(1,1);
	while(m--) {
		qr(op);qr(x);
		switch(op) {
			case 1:qr(y);add(x,y-d[x]);d[x]=y;break;
			case 2:pri(query(x));break;
		}
	}
	return 0;
}
```



---

## 作者：p_b_p_b (赞：1)

[$$\large \color{purple} My\; Blog$$](https://www.cnblogs.com/p-b-p-b/p/10498351.html)

----------------

## 思路

这思路好妙啊！

首先很多人都会想到推式子之后树链剖分+线段树，但这样不够优美，不喜欢。

脑洞大开想到这样一个式子：
$$
\sum_{x} sum_x(All-sum_x)
$$
其中$sum_x$表示$x$子树和，$All$表示所有点的权值和。

发现不管哪个点为根，只要每个点的权值不变，这个式子的值就不变。

证明：对于点对$(u,v)$，$w_u\times w_v$被算了$dis(u,v)$次，因为每个在路径上的$x$都会算一次。

于是就有

$$W=\sum_x sum_x(All-sum_x)=All\sum_x sum_x -\sum_x sum_x^2$$
$$\sum_{x} sum_x^2=All\sum_x sum_x-W$$

$W$怎么统计呢？$w_x+=\Delta w$时$W+=\Delta w\sum_u w_udis(u,x)$，后面的可以动态点分治。

以$root$为根时$\sum_x sum_x$等价于$\sum_x w_x(dis(x,root)+1)=All+\sum_x w_xdis(x,root)$，同样可以动态点分治。

点分治的具体做法参见[幻想乡战略游戏](https://www.cnblogs.com/p-b-p-b/p/10357577.html)，式子基本一样，但那里的代码很繁琐，建议代码看这里。

那么就做完啦！

-------------------------

## 代码

```cpp
#include<bits/stdc++.h>
clock_t t=clock();
namespace my_std{
    using namespace std;
    #define pil pair<int,ll>
    #define fir first
    #define sec second
    #define MP make_pair
    #define rep(i,x,y) for (int i=(x);i<=(y);i++)
    #define drep(i,x,y) for (int i=(x);i>=(y);i--)
    #define go(x) for (int i=head[x];i;i=edge[i].nxt)
    #define templ template<typename T>
    #define sz 202020
    typedef long long ll;
    typedef double db;
    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
    templ inline T rnd(T l,T r) {return uniform_int_distribution<T>(l,r)(rng);}
    templ inline bool chkmax(T &x,T y){return x<y?x=y,1:0;}
    templ inline bool chkmin(T &x,T y){return x>y?x=y,1:0;}
    templ inline void read(T& t)
    {
        t=0;char f=0,ch=getchar();double d=0.1;
        while(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();
        while(ch<='9'&&ch>='0') t=t*10+ch-48,ch=getchar();
        if(ch=='.'){ch=getchar();while(ch<='9'&&ch>='0') t+=d*(ch^48),d*=0.1,ch=getchar();}
        t=(f?-t:t);
    }
    template<typename T,typename... Args>inline void read(T& t,Args&... args){read(t); read(args...);}
    char sr[1<<21],z[20];int C=-1,Z=0;
    inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
    inline void print(register int x)
    {
    	if(C>1<<20)Ot();if(x<0)sr[++C]='-',x=-x;
    	while(z[++Z]=x%10+48,x/=10);
    	while(sr[++C]=z[Z],--Z);sr[++C]='\n';
    }
    void file()
    {
        #ifndef ONLINE_JUDGE
        freopen("a.txt","r",stdin);
        #endif
    }
    inline void chktime()
    {
        #ifndef ONLINE_JUDGE
        cout<<(clock()-t)/1000.0<<'\n';
        #endif
    }
    #ifdef mod
    ll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x%mod) if (y&1) ret=ret*x%mod;return ret;}
    ll inv(ll x){return ksm(x,mod-2);}
    #else
    ll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x) if (y&1) ret=ret*x;return ret;}
    #endif
//	inline ll mul(ll a,ll b){ll d=(ll)(a*(double)b/mod+0.5);ll ret=a*b-d*mod;if (ret<0) ret+=mod;return ret;}
}
using namespace my_std;

int n,m;
ll val[sz];
struct hh{int t,nxt;}edge[sz<<1];
int head[sz],ecnt;
void make_edge(int f,int t)
{
	edge[++ecnt]=(hh){t,head[f]};
	head[f]=ecnt;
	edge[++ecnt]=(hh){f,head[t]};
	head[t]=ecnt;
}

bool vis[sz];
int size[sz],mn,root,tot;
#define v edge[i].t 
void findroot(int x,int fa)
{
	int S=-1;
	size[x]=1;
	go(x) if (v!=fa&&!vis[v])
	{
		findroot(v,x);
		chkmax(S,size[v]);
		size[x]+=size[v];
	}
	chkmax(S,tot-size[x]);
	if (chkmin(mn,S)) root=x;
}
vector<int>fa[sz],disf[sz];
ll sum[sz]; // \sum val[v]
ll Sum[sz]; // \sum val[v]*dis(x,v)
ll sumF[sz]; // \sum val[v]*dis(fa[x],v)
void dfs(int x,int par,int u,int d)
{
	fa[x].push_back(u);disf[x].push_back(d);
	go(x) if (v!=par&&!vis[v]) dfs(v,x,u,d+1);
}
void build(int x)
{
	vis[x]=1;dfs(x,0,x,0);
	int all=tot;
	go(x) if (!vis[v])
	{
		tot=size[v];if (tot>size[x]) tot=all-size[x];mn=1e9;
		findroot(v,0);
		build(root);
	}
}
#undef v
void add(int x,ll w)
{
	drep(i,(int)fa[x].size()-1,1)
	{
		int u=fa[x][i];
		ll d=disf[x][i],dd=disf[x][i-1];
		sum[u]+=w;Sum[u]+=w*d;sumF[u]+=w*dd;
	}
	int u=fa[x][0],d=disf[x][0];
	sum[u]+=w;Sum[u]+=w*d;
}
ll query(int x)
{
	ll ret=Sum[x];
	drep(i,(int)fa[x].size()-2,0)
	{
		int u=fa[x][i],uu=fa[x][i+1];
		ll d=disf[x][i];
		ret+=Sum[u]-sumF[uu]+d*(sum[u]-sum[uu]);
	}
	return ret;
}

ll W,All;
void Add(int x,ll w)
{
	W+=w*query(x);All+=w;
	add(x,w);
	val[x]+=w;
}
ll Query(int x){return All*(query(x)+All)-W;}

int main()
{
	file();
	read(n,m);
	int x,y,z;
	rep(i,1,n-1) read(x,y),make_edge(x,y);
	tot=n;mn=1e9;findroot(1,0);build(root);
	rep(i,1,n) read(x),Add(i,x);
	while (m--)
	{
		read(z);
		if (z==1) read(x,y),Add(x,y-val[x]);
		else read(x),printf("%lld\n",Query(x));
	}
	return 0;
}
```



---

## 作者：Soulist (赞：1)


设 $m=\sum_{i=1}^n w_i$，接下来我们设 $A,S$ 两个变量，其中：

$$A=m\sum \textrm{size}(x)$$

$$S=\sum \textrm{size}(x)\cdot (m-\textrm{size}(x))$$

那么：$A-S$ 即为答案。

接下来，我们可以观察到，$S$ 是一个与根的选取无关的定值，不难注意到 $S$ 的计算可以拆开每条边并考虑贡献。

于是我们只需要：

1. 支持修改，并维护 $S$
2. 支持查询某个根的 $A$

第二问是一个经典问题了（换根并查询距离乘以权值和）

第一问我们发现组合意义之后，可以进一步考虑，不难注意到其为：

$$\sum \sum[u<v] w_u\times w_v\times \textrm{dist}(u,v)$$

枚举 $u$，发现统计的贡献又是第二问了，每次修改影响且仅影响一个点的贡献，计算方法同第二问。



```cpp
#include<bits/stdc++.h>
using namespace std ;
#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define re register
#define int long long
inline int gi() {
    char cc = getchar() ; int cn = 0, flus = 1 ; 
    while( cc > '9' || cc < '0' ) { if( cc == '-' ) flus = - flus ; cc = getchar() ; }
    while( cc <= '9' && cc >= '0' ) cn = cn * 10 + cc - '0', cc = getchar() ; 
    return cn * flus ; 
}
const int N = 2e5 + 5 ; 
int n, q, head[N], w[N], dp[N], vis[N], RS ; 
int d[N], f[N], g[N], fa[N], cnt, rt, root, sum, S ; 
int Fa[N], sz[N], Top[N], Son[N], dep[N], sw[N] ; 
struct E {
	int to, next ; 
} e[N * 2] ;
inline void add( int x, int y ) {
	e[++ cnt] = (E){ y, head[x] }, head[x] = cnt ,
	e[++ cnt] = (E){ x, head[y] }, head[y] = cnt ; 
}
inline void dfs1( int x, int ff ) {
	dep[x] = dep[ff] + 1, sz[x] = 1, Fa[x] = ff, sw[x] = w[x] ; 
	Next( i, x ) {
		int v = e[i].to ; if( v == ff ) continue ; 
		dfs1( v, x ), sz[x] += sz[v], sw[x] += sw[v], d[x] += d[v] ; 
		if( sz[v] > sz[Son[x]] ) Son[x] = v ;  
	}
	S += ( RS - sw[x] ) * sw[x] ; 
}
inline void dfs2( int x, int ff ) {
	Top[x] = ff ; 
	if( Son[x] ) dfs2( Son[x], ff ) ;
	Next( i, x ) {
		int v = e[i].to ; if( v == Fa[x] || v == Son[x] ) continue ;
		dfs2( v, v ) ;  
	} 
}
int LCA( int x, int y ) {
	while( Top[x] != Top[y] ) {
		if( dep[Top[x]] < dep[Top[y]] ) swap( x, y ) ;
		x = Fa[Top[x]] ; 
	}
	return ( dep[x] > dep[y] ) ? y : x ; 
}
inline void get_rt( int x, int ff ) {
	sz[x] = 1, dp[x] = 0 ; 
	Next( i, x ) {
		int v = e[i].to ; if( v == ff || vis[v] ) continue ; 
		get_rt( v, x ), sz[x] += sz[v] ;
		dp[x] = max( sz[v], dp[x] ) ;
	}
	dp[x] = max( dp[x], sum - sz[x] ) ;
	if( dp[x] <= dp[rt] ) rt = x ; 
}
inline void solve( int x ) {
	vis[x] = 1 ; 
	Next( i, x ) {
		int v = e[i].to ; if( vis[v] ) continue ; 
		rt = 0, dp[0] = sum = sz[v], get_rt( v, x ),
		fa[rt] = x, solve( rt ) ;
	}
}
inline int dist( int x, int y ) {
	return dep[x] + dep[y] - 2 * dep[LCA(x, y)] ; 
}
void Init( int x ) {
	rep( i, 1, n ) {
		int u = i, fr ; d[i] += w[i] ;
		while( fa[u] ) {
			fr = dist( i, fa[u] ), f[fa[u]] += fr * w[i], 
			d[fa[u]] += w[i], g[u] += fr * w[i], u = fa[u] ;
		}
	}
}
int Query( int x ) {
	int Ans = f[x], u = x ; 
	while( fa[u] ) {
		Ans += ( f[fa[u]] - g[u] ) ;
		Ans += ( d[fa[u]] - d[u] ) * dist( fa[u], x ) ;
		u = fa[u] ; 
	}
	return Ans ; 
}
void Update( int x, int p ) {
	int u = x, fr, y = p - w[x] ; 
	int ru = Query( x ) ;
	S += ru * y, d[x] += y, RS += y ; ;
	while( fa[u] ) {
		fr = dist( x, fa[u] ), f[fa[u]] += fr * y, 
		d[fa[u]] += y, g[u] += fr * y, u = fa[u] ;
	}
	w[x] = p ; 
}
signed main() {
    sum = n = gi(), q = gi(), rt = 0, dp[0] = n + 1 ; int opt, x, y ; 
    rep( i, 2, n ) x = gi(), y = gi(), add( x, y ) ;
    rep( i, 1, n ) w[i] = gi(), RS += w[i] ; 
    dfs1( 1, 1 ), dfs2( 1, 1 ), get_rt( 1, 1 ), 
	root = rt, solve( rt ), Init(root) ; 
	while( q-- ) {
		opt = gi(), x = gi() ;
		if( opt == 1 ) y = gi(), Update( x, y ) ; 
		else printf("%lld\n", ( Query( x ) + RS ) * RS - S ) ;
	}
	return 0 ; 
}
```

---

## 作者：KokiNiwa (赞：0)

# 小清新数据结构题

动态点分治！

## 题目叙述

有一棵$n$个点的树，每个点有一个点权。现在有$q$次操作，每次操作是修改一个点的点权或指定一个点，询问以这个点为根时每棵子树点权和的平方和。

## 想法

+ 这根本不是路径问题啊，这是子树的问题！点分治无法解决！所以，如何变成路径问题？

+ 这个其实相当于$\sum_{i=1}^n\sum_{j=1}^nv_iv_j\operatorname {dep}(\operatorname{lca}(i,j))$。

+ 那么，大概把一个点当成`LCA`计算低下的点的贡献和？这好像不太靠谱，因为无法带修改。

+ 考虑化简这个式子：

  + $$
    \begin{aligned}
    \sum_{i=1}^n\sum_{j=1}^nv_iv_j\operatorname {dep}(\operatorname{lca}(i,j)) &= \frac{1}{2}\sum_{i=1}^n\sum_{j=1}^nv_iv_j(\operatorname {dep}(i)+\operatorname {dep}(j)-2\operatorname {dis}(i,j))
    \end{aligned}
    $$

  + 可以把式子拆成两个部分：

    + $$
      2\sum_{i=1}^n\sum_{j=1}^nv_iv_j\operatorname{dep}(j)=2(\sum_{i=1}^nv_i)(\sum_{i=1}^nv_j\operatorname{dep}(j))
      $$

    + $$
      \sum_{i=1}^n\sum_{j=1}^n2v_iv_j\operatorname{dis}(i,j)
      $$

  + 对于第一个，可以把$\operatorname{dep}(i)$看作到根节点的距离。

  + 于是可以发现第二个和第一个都是类似于$\sum_{j=1}^n\operatorname{dis}(i,j)v_j$这样的式子。

  + 考虑动态点分治维护。

## 代码

```cpp
#include <cstdio>
#include <vector>
using namespace std;
const int maxNode = 2e5 + 5;
typedef long long ll;
int nbNode, nbQry, up[maxNode], size[maxNode], maxPart[maxNode], val[maxNode];
ll inDis[maxNode], faDis[maxNode], inSum[maxNode], sum, nodeSum;
bool vis[maxNode];
struct Graph {
	vector<int> G[maxNode];
	int st[maxNode * 2][20], Lg[maxNode * 2], oula[maxNode], dep[maxNode], tail;
	void Add(int u, int v) {
		G[u].push_back(v);
		G[v].push_back(u);
	}
	void Dfs(int now, int from) {
		dep[now] = dep[from] + 1;
		st[++tail][0] = dep[now];
		oula[now] = tail;
		for (int to : G[now]) {
			if (to == from)
				continue ;
			Dfs(to, now);
			st[++tail][0] = dep[now];
		}
	}
	void BuildSt() {
		for (int num = 2; num <= tail; ++num)
			Lg[num] = Lg[num / 2] + 1;
		for (int lift = 1; lift <= Lg[tail]; ++lift)
			for (int pos = 1; pos + (1 << lift) - 1 <= tail; ++pos)
				st[pos][lift] = min(st[pos][lift - 1], st[pos + (1 << (lift - 1))][lift - 1]);
	}
	int Dis(int uNd, int vNd) {
		if (oula[uNd] > oula[vNd])
			swap(uNd, vNd);
		int l = Lg[oula[vNd] - oula[uNd] + 1];
		int lca = min(st[oula[uNd]][l], st[oula[vNd] - (1 << l) + 1][l]);
		return dep[uNd] + dep[vNd] - lca * 2;
	}
} tree;
int GetRoot(int now, int from, int all) {
	size[now] = 1;
	maxPart[now] = 0;
	int ret = 0;
	for (int to : tree.G[now]) {
		if (to == from || vis[to])
			continue ;
		int sonRoot = GetRoot(to, now, all);
		size[now] += size[to];
		maxPart[now] = max(maxPart[now], size[to]);
		if (maxPart[ret] > maxPart[sonRoot])
			ret = sonRoot;
	}
	maxPart[now] = max(maxPart[now], all - size[now]);
	if (maxPart[ret] > maxPart[now])
		ret = now;
	return ret;
}
void Divide(int now, int all) {
	vis[now] = 1;
	for (int to : tree.G[now]) {
		if (vis[to])
			continue ;
		int sonSize = (size[to] < size[now]) ? (size[to]) : (all - size[now]);
		int rt = GetRoot(to, -1, sonSize);
		up[rt] = now;
		Divide(rt, sonSize);
	}
}
int Cal(int node) {
	ll ret = inDis[node];
	for (int now = node; up[now]; now = up[now]) {
		int dis = tree.Dis(node, up[now]);
		ret += inDis[up[now]] - faDis[now];
		ret += 1ll * dis * (inSum[up[now]] - inSum[now]);
	}
	return ret;
}
void Modify(int node, int val) {
	sum += 1ll * Cal(node) * val;
	inSum[node] += val;
	for (int now = node; up[now]; now = up[now]) {
		int dis = tree.Dis(node, up[now]);
		inSum[up[now]] += val;
		inDis[up[now]] += 1ll * dis * val;
		faDis[now] += 1ll * dis * val;
	}
}
int main() {
	scanf("%d%d", &nbNode, &nbQry);
	for (int edge = 1; edge < nbNode; ++edge) {
		int uNd, vNd;
		scanf("%d%d", &uNd, &vNd);
		tree.Add(uNd, vNd);
	}
	tree.Dfs(1, 0);
	tree.BuildSt();
	maxPart[0] = 0x3f3f3f3f;
	Divide(GetRoot(1, -1, nbNode), nbNode);
	for (int i = 1; i <= nbNode; ++i) {
		scanf("%d", &val[i]);
		nodeSum += val[i];
		Modify(i, val[i]);
	}
	while (nbQry--) {
		int opt;
		scanf("%d", &opt);
		if (opt == 1) {
			int node, newVal;
			scanf("%d%d", &node, &newVal);
			Modify(node, newVal - val[node]);
			nodeSum += newVal - val[node];
			val[node] = newVal;
		} else {
			int rt;
			scanf("%d", &rt);
			printf("%lld\n", 1ll * Cal(rt) * nodeSum - sum + 1ll * nodeSum * nodeSum);
		}
	}
	return 0;
}
```



## 知识点

+ 如何维护经典式子$\sum_{j=1}^n\operatorname{dis}(i,j)v_j$。
+ 注意推式子。
+ 考虑把子树的问题转化为路径上的问题，用动态点分治。

---

## 作者：muller (赞：0)

其实这道数据结构并不太难写

关键要想到做法

对于线段树的每个节点，记录这段区间的和，和*sum的个数，值为0的个数,

此外，还要维护两个懒惰标记

当然也可以直接树状数组

然后log2

其实并不是什么点分治

代码：

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define N 500005
#define ll long long
using namespace std;
struct Info{int nu,ne;}a[N];
ll w[N],c[N],c1[N],c2[N],ans;
int n,m,num,cnt,b[N],si[N],f[N],son[N],pos[N],top[N],dfn[N];
void jb(int x,int y){a[++num].nu=y;a[num].ne=b[x];b[x]=num;}
int lowbit(int x){return x&-x;}
void gai(int x,ll w){for(int i=x;i<=n;i+=lowbit(i))c1[i]+=w,c2[i]+=(ll)x*w;}
ll cha(int x){ll w=0;for(int i=x;i;i-=lowbit(i))w+=1ll*(x+1)*c1[i]-c2[i];return w;}
void dfs1(int x,int fa){
	si[x]=1;f[x]=fa;
	for (int y=b[x];y;y=a[y].ne){
		int v=a[y].nu;if (v==fa)continue;
		dfs1(v,x);w[x]+=w[v];si[x]+=si[v];
		if (si[v]>si[son[x]])son[x]=v;
	}
	ans+=1ll*w[x]*w[x];
}
void dfs2(int x,int t){
	top[x]=t;pos[dfn[x]=++cnt]=x;
	gai(dfn[x],w[x]-w[pos[cnt-1]]);
	if (son[x])dfs2(son[x],t);
	for (int y=b[x];y;y=a[y].ne)if (a[y].nu!=f[x]&&a[y].nu!=son[x])dfs2(a[y].nu,a[y].nu);
}
ll query(int x){
	int k=0;ll s=0,t=cha(1);
	for (;x;x=f[top[x]]){
		k+=dfn[x]-dfn[top[x]]+1;s+=cha(dfn[x])-cha(dfn[top[x]]-1);
	}
	return ans+t*(t*(k+1)-s*2);
}
void modify(int x,ll y){
	int k=0;ll s=0;
	for (;x;x=f[top[x]]){
		k+=dfn[x]-dfn[top[x]]+1;s+=cha(dfn[x])-cha(dfn[top[x]]-1);
		gai(dfn[top[x]],y);gai(dfn[x]+1,-y);
	}
	ans+=y*(y*k+s*2);
}
int main(){
	scanf("%d%d",&n,&m);
	for (int i=1;i<n;i++){
		int x,y;scanf("%d%d",&x,&y);
		jb(x,y);jb(y,x);
	}
	for (int i=1;i<=n;i++)scanf("%lld",&c[i]),w[i]=c[i];
	dfs1(1,0);dfs2(1,1);
	while (m--){
		int opt,x;ll y;
		scanf("%d%d",&opt,&x);
		if (opt==1){
			scanf("%lld",&y);y-=c[x];c[x]+=y;modify(x,y);
		}else printf("%lld\n",query(x));
	}
	return 0;
}

```


---


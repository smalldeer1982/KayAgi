# [BJOI2017] 喷式水战改

## 题目背景

拿到了飞机的驾照(?)，这样补给就不愁了

XXXX年XX月XX日

拿到了喷气机(??)的驾照，这样就飞得更快了

XXXX年XX月XX日

拿到了攻击机(???)的驾照（不存在的）

XXXX年XX月XX日

用铅版做夹层的话，机身可是会变重的呢

XXXX年XX月XX日

幸酱的特制快递，精确投递到了目标地点

-------------------------------------

又是核平的一天。

天音正在给喷气机做保养，并充填燃料。

这种喷气机是某姬(?????)特别制作的，发动机拥有三种工作状态

1、通常型（Original）：在高空平飞或隐蔽飞行时进行的低功耗高效率工作状态

2、后期型（Extended）：为在俯冲时最大化能量利用率而特别改造过的工作状态

3、增强型（Enhanced）：在俯冲攻击结束后为产生极限扭力抬高高度的工作状态

在一次攻击中，喷气机将会经历"通常-后期-增强-通常"的工作流程

不同工作状态中，燃料的利用效率是不同的

现在天音正在调整喷气机燃料装填序列

你需要做的就是求出燃料能产生的最大总能量

为什么是你？

和平还是核平，选一个吧


## 题目描述

初始燃料序列为空。每次操作会向序列中的 $p _ i$ 位置添加 $x _ i$ 单位的同种燃料，该燃料每一单位在三种工作状态下能产生的能量分别为 $a _ i, b _ i, c _ i$。

添加的位置 $p _ i$ 是指，在添加后，加入的第一个单位燃料前面有 $p _ i$ 个单位的原燃料。

全部的 $x _ i$ 单位燃料依次放置，然后原来在 $p _ i$ 位置的燃料（如果有的话）依次向后排列。

对于一个确定的燃料序列，其能产生的最大总能量为：将序列依次分成"通常-后期-增强-通常"四段（每段可以为空），每一段在对应工作状态下产生的能量之和的最大值。

对于每次添加操作，你需要给出该次操作使得最大总能量增加了多少。

如果对于这种计算方式没有直观的感受，可以查看样例说明。


## 说明/提示

第一次操作后，燃料序列为[1 1]，最大能量发生方式为[En1 En1]，共46+46=92。

第二次操作后，燃料序列为[1 2 2 2 1]，最大能量发生方式为[Or1 Or2 Or2 Or2 En1]，共25+32+32+32+46=167，增加了167-92=75。

第三次操作后，燃料序列为[1 2 2 3 3 3 2 1]，最大能量发生方式为[Or1 Or2 Or2 Or3 Or3 Or3 Or3 Or2 En1]，增加了99\*4=396。

第四次操作后，燃料序列为[1 2 4 4 4 4 4 2 3 3 3 2 1]

最大能量发生方式为[Or1 Or2 Ex4 Ex4 Ex4 Ex4 Ex4 Or2 Or3 Or3 Or3 Or3 Or2 Or1]。

第五次操作后，燃料序列为[1 2 4 4 4 4 4 2 3 3 3 2 1 5 5 5 5 5 5]

最大能量发生方式为[Or1 Or2 Ex4 Ex4 Ex4 Ex4 Ex4 Or2 Or3 Or3 Or3 Or3 Or2 Or1 Or5 Or5 Or5 Or5 Or5 Or5]。


对于 $100\%$ 的数据，$1 \leq n \leq 10^5$, $1 \leq a_i, b_i, c_i \leq 10^4$， $1 \leq x_i \leq 10^9$。

对于 $100\%$ 的数据，保证插入时序列中至少已有 $p _ i$ 单位的燃料。

后 $50\%$ 数据有梯度。


## 样例 #1

### 输入

```
5
0 25 37 46 2
1 32 14 16 3
3 99 77 88 4
2 43 68 57 5
14 72 36 18 6
```

### 输出

```
92
75
396
319
432```

# 题解

## 作者：devout (赞：4)

这题其实想清楚还是挺好写的，~~代码连100行都不到~~

首先考虑如果没有插入操作，就给定一个序列怎么做，那就是一个非常简单的一维（二维？）$dp$，我们用$f_{i,j}$表示第$i$个点当做第$j$个区间来使用（为了方便，我们把四个区间标记成$0,1,2,3$），其中$0$和$3$的价格是完全相同的。那么转移就是

$$f_{i,j}=\max\{f_{i-1,k}+val\},k\leq j$$

然后我们会到原题里面，有插入操作，显然想到平衡树

那么我们一个类似这样的$dp$搬到平衡树上就好了

我们用$f[u] _{i,j} $表示平衡树上编号为$u$的节点当他代表的是$[i,j]$这两个工作模式的时候的最大方法(两段可以不选)

那么我们就只需要改一下$update$的写法就可以，转移就是

$$f[u]_{i,k}=\max\{f[lc]_{i,j}+val[u]_j+f[rc]_{j,k}\}$$

~~貌似没有ClCN姐姐的那么麻烦？（~~

但是这题还有一个恶心的地方就是有$n$次操作，每次插入$x$个数，最差的时候会插入$10^{14}$个数，炸飞了

怎么呢？我们可以用ODT的思想把连续一段相同的合并到一个点上

每次插入的时候判断一下，如果插到了一个点的中间，就需要把这个点拆成两个

那么可以发现每次插入的时候最多多三个点，如果开空间回收只用开$3$倍空间就可以，不开$4$倍也够了，当然我为了保险开了$5$倍

那么我们最后的复杂度就是$O(64n\log n)$，时限三秒可以通过（因为$64$还比较大所以单独写出来了）

当然因为需要拆点还有一点点小细节

比如说我们怎么确定我们要插入的这个点位于哪个序列里面呢？我们split按什么split呢？

可以按照**平衡树上的节点数siz**进行split，也可以按照**实际上的燃料数sum**进行split，当然可以两次分别split一下，但是其实是没有必要的

我们应该选择按照第一种方法，平衡树上的节点数进行split

为什么呢？比如说我们把$p$所在的点按照sum拆出来了，那么从哪里把这个点劈成两半呢？我们不知道

但是如果按照siz拆出来，我们是可以利用siz表示出sum的，所以我们应该按照siz进行split

那么我们可以根据sum上的排名（已知）去找siz上的排名，然后根据排名split

然后特判插入的位置在末尾的情况，再还原就可以了

当然，开了longlong之后，~~记得输出%lld~~

本来写了个没啥用的空间回收，后来为了~~把代码卡进100行给删了~~

~~为啥删掉空间回收还变慢了500ms呢~~

最后卡到95行的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

typedef long long ll;

const int N=5e5+5;

template<typename T> void read(T &x){
   x=0;int f=1;
   char c=getchar();
   for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
   for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

int n;
int son[N][2],treap[N],val[N][4],len[N],siz[N];
ll sum[N],f[N][4][4];
ll ans;
int rt,tot;
int bin[N],top;

void update(int x){
    memset(f[x],0,sizeof(f[x]));
    Rep(i,0,3)
        Rep(j,i,3)
            Rep(k,j,3)
                f[x][i][k]=max(f[x][i][k],f[son[x][0]][i][j]+1ll*val[x][j]*len[x]+f[son[x][1]][j][k]);
    sum[x]=sum[son[x][0]]+sum[son[x][1]]+len[x];
    siz[x]=siz[son[x][0]]+siz[son[x][1]]+1;
}

void split(int o,int &u,int &v,int k){
    if(!o){u=v=0;return;}
    int rank=siz[son[o][0]]+1;
    if(rank<=k)split(son[u=o][1],son[o][1],v,k-rank);
    else split(son[v=o][0],u,son[o][0],k);
    update(o);
}   

int merge(int u,int v){
    if(!u||!v)return u|v;
    int rt;
    if(treap[u]<treap[v])son[rt=u][1]=merge(son[u][1],v);
    else son[rt=v][0]=merge(u,son[v][0]);
    return update(rt),rt;
}

int rnk(ll k){
    int u=rt,res=0;
    while(u){
        if(sum[son[u][0]]>=k)u=son[u][0];
        else if(sum[son[u][0]]+len[u]>=k)return res+siz[son[u][0]]+1;
        else k-=sum[son[u][0]]+len[u],res+=siz[son[u][0]]+1,u=son[u][1];
    }
    return res;
}

int main()
{
    srand(19260817);
    read(n);
    Rep(i,1,n){
        ll p,x;
        int u=++tot;
        read(p),read(val[u][0]),read(val[u][1]),read(val[u][2]),read(x),val[u][3]=val[u][0];
        int rank=rnk(p);
        int lef,mid,rht;
        split(rt,lef,rht,rank);
        split(lef,lef,mid,rank-1);
        siz[u]=1,sum[u]=len[u]=x;
        son[u][0]=son[u][1]=0;
        treap[u]=rand();
        update(u);
        if(sum[lef]+len[mid]==p)rt=merge(merge(lef,mid),merge(u,rht));
        else{
            int l=++tot,r=++tot;
            Rep(i,0,3)val[l][i]=val[r][i]=val[mid][i];
            siz[l]=siz[r]=mid;
            son[l][0]=son[r][0]=son[l][1]=son[r][1]=0;
            sum[l]=len[l]=p-sum[lef];
            sum[r]=len[r]=sum[lef]+sum[mid]-p;
            treap[l]=rand(),treap[r]=rand();
            update(l),update(r);
            rt=merge(merge(lef,merge(l,u)),merge(r,rht));
        }
        printf("%lld\n",f[rt][0][3]-ans);
        ans=f[rt][0][3];
    }
    return 0;
}
```


---

## 作者：feecle6418 (赞：4)

非常简单的动态 dp。

容易发现每一连续段都决策相同，可以合在一起处理。设 $f_{i,j} (0\le j\le 3)$ 表示前 $i$ 个连续段，第 $i$ 段在整体的 $1,2,3,4$ 部分，的最大收益。容易得到转移：

$$\large f_{i,j}=\max\limits_{k\le j} f_{i-1,k}+v_{i,j}$$

$v_{i,j}$ 为第 $i$ 段放在第 $j$ 部分的收益。

显然可以 ddp 优化，用 FHQ Treap 维护矩阵乘积即可。矩阵为，

$$\begin{bmatrix} v_{i,0} & v_{i,1} & v_{i,2} & v_{i,3} \\ -10^{18} & v_{i,1} & v_{i,2} & v_{i,3} \\-10^{18} & -10^{18} & v_{i,2} & v_{i,3} \\-10^{18} & -10^{18} & -10^{18} & v_{i,3} \\\end{bmatrix}
\quad$$

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> pr;
const ll inf=1e18;
struct Matrix{
	ll a[4][4];
	Matrix(){for(int i=0;i<4;i++)for(int j=0;j<4;j++)a[i][j]=-inf;}
	void Print(){
		for(int i=0;i<4;i++){
			for(int j=0;j<4;j++)if(a[i][j]!=-inf)printf("%lld ",a[i][j]);else printf("-inf ");
			puts("");
		}
	}
}t[300005],v[300005];
Matrix operator *(const Matrix& a,const Matrix& b){
	Matrix ret;
	for(int i=0;i<4;i++){
		for(int j=0;j<4;j++){
			for(int k=0;k<4;k++)ret.a[i][j]=max(ret.a[i][j],a.a[i][k]+b.a[k][j]);
		}
	}
	return ret;
}
int n,c[300005][2],rnk[300005],tot,root;
ll size[300005],sum[300005];
int New(int a,int b,int c,int x){
	int r=++tot;
	t[r].a[0][0]=1ll*x*a;
	t[r].a[0][1]=t[r].a[1][1]=1ll*x*b;
	t[r].a[0][2]=t[r].a[1][2]=t[r].a[2][2]=1ll*x*c;
	t[r].a[0][3]=t[r].a[1][3]=t[r].a[2][3]=t[r].a[3][3]=1ll*x*a;
	sum[r]=size[r]=x,rnk[r]=rand()*rand(),v[r]=t[r];
	return r;
}
int copy(int x,int sz){
	int r=++tot;
	for(int i=0;i<4;i++)for(int j=3;j>=i;j--)t[r].a[i][j]=v[x].a[i][j]/sum[x]*sz;
	sum[r]=size[r]=sz,rnk[r]=rand()*rand(),v[r]=t[r];
	return r;
}
void Pushup(int p){
	size[p]=size[c[p][0]]+size[c[p][1]]+sum[p],t[p]=v[p];
	if(c[p][0])t[p]=t[c[p][0]]*t[p];
	if(c[p][1])t[p]=t[p]*t[c[p][1]];
}
pr Split(int p,ll s){
	if(!p)return make_pair(0,0);
	if(size[c[p][0]]+sum[p]>s){
		pr t=Split(c[p][0],s);
		c[p][0]=t.second,Pushup(p);
		return make_pair(t.first,p);
	}
	pr t=Split(c[p][1],s-size[c[p][0]]-sum[p]);
	c[p][1]=t.first,Pushup(p);
	return make_pair(p,t.second);
}
int Merge(int p,int q){
	if(!p||!q)return p+q;
	if(rnk[p]>rnk[q])return c[p][1]=Merge(c[p][1],q),Pushup(p),p;
	else return c[q][0]=Merge(p,c[q][0]),Pushup(q),q;
}
int Mn(int rt){
	while(c[rt][0])rt=c[rt][0];
	return rt;
}
int main(){
	scanf("%d",&n);
	ll pre=0;
	for(int i=1,a,b,C,x;i<=n;i++){
		ll p;
		scanf("%lld%d%d%d%d",&p,&a,&b,&C,&x);
		pr tt=Split(root,p);
		if(size[tt.first]==p){
			int u=New(a,b,C,x);
			root=Merge(tt.first,Merge(u,tt.second));
		}
		else {
			p-=size[tt.first];
			int u=New(a,b,C,x),v=Mn(tt.second),y=sum[v];
			pr o=Split(tt.second,y);
			root=Merge(tt.first,Merge(Merge(Merge(copy(v,p),u),copy(v,y-p)),o.second));
		}
		ll ans=-1e18;
		for(int i=0;i<4;i++)for(int j=0;j<4;j++)ans=max(ans,t[root].a[i][j]);
		printf("%lld\n",ans-pre),pre=ans;
	}
}
```

---

## 作者：Elegia (赞：4)

考虑一种基于分治模式的DP方程。


$f(l, r, i, j)$ 表示在当前燃料 $[l,r]$ 部分只对应着型号 $[i,j]$ 部分能获得的最大能量。则能得到一种分治的DP方程：


$\forall l \le d \le r - 1, f(l, r, i, j) = \max_{i \le k \le j} f(l, d, i, k) + f(d + 1, r, k, j)$


这个单个状态的转移是 $\Theta(s)$ 的， $s$ 是等级层数，不过在本体中为定值4。


如果我们用平衡树来维护，则是每个节点额外维护一个该子树的DP 2维数组。在发生插入/旋转操作时，可以高效地进行 update 。


本题还需要将整段当做一个节点，而且燃料大小居然会爆 `long long` ，不加上就会全WA，可以说十分刁钻。


```cpp
#include <cstdio>
#include <cstring>
#include <cstdlib>

#include <algorithm>

#define LOG(FMT...) // fprintf(stderr, FMT)

using namespace std;

typedef long long ll;

struct data {
    ll dp[4][4];

    data()
    { memset(dp, 0, sizeof(dp)); }

    data(const data& x)
    { memcpy(dp, x.dp, sizeof(dp)); }

    data(int a, int b, int c, int x);

    data operator+(const data& x) const;
};

struct node {
    ll a, b, c, sz, cnt;
    int rnd;
    data d, sum;
    node *ls, *rs;
};

const int N = 100010;

int n;
node* root;

int fast_rand();
ll get_cnt(node* p);
node* create(int a, int b, int c, int x);
void update(node* p);
void insert(node*& p, node* q, ll x);
void zig(node*& p);
void zag(node*& p);
void order(node* p);

int main() {
    int a, b, c, x;
    ll p;
    ll lste = 0, cure;
    scanf("%d", &n);
    while (n--) {
        scanf("%lld%d%d%d%d", &p, &a, &b, &c, &x);
        insert(root, create(a, b, c, x), p);
        cure = root->sum.dp[0][3];
        printf("%lld\n", cure - lste);
        lste = cure;
        LOG("\n");
    }
    return 0;
}

void order(node* p) {
    if (!p)
        return;
    order(p->ls);
    LOG(" %d", p->sz);
    order(p->rs);
}

inline int fast_rand() {
    static int x = 19260817, y = x << 4, z = x >> 2, t;
    t = x ^ y ^ z;
    x ^= y << 2;
    x ^= z >> 4;
    z = y;
    y = x;
    x = t;
    return t;
}

inline ll get_cnt(node* p)
{ return p ? p->cnt : 0; }

inline void update(node* p) {
    p->cnt = p->sz + get_cnt(p->ls) + get_cnt(p->rs);
    p->sum = p->d;
    if (p->ls)
        p->sum = p->ls->sum + p->sum;
    if (p->rs)
        p->sum = p->sum + p->rs->sum;
}

inline node* create(int a, int b, int c, int x) {
    static node pool[N << 1];
    static node* p = pool;
    ++p;
    p->d = data(a, b, c, x);
    p->a = a;
    p->b = b;
    p->c = c;
    p->sz = x;
    p->sum = p->d;
    p->rnd = rand();
    p->cnt = x;
    return p;
}

inline void zig(node*& p) {
    node* son = p->ls;
    p->ls = son->rs;
    son->rs = p;
    update(p);
    p = son;
    update(p);
}

inline void zag(node*& p) {
    node* son = p->rs;
    p->rs = son->ls;
    son->ls = p;
    update(p);
    p = son;
    update(p);
}

void insert(node*& p, node* q, ll x) {
    if (!p) {
        LOG("%d\n", x);
        p = q;
        return;
    }
    if (x <= get_cnt(p->ls)) {
        insert(p->ls, q, x);
        update(p);
        if (p->rnd > p->ls->rnd)
            zig(p);
        return;
    }
    x -= get_cnt(p->ls);
    if (x >= p->sz) {
        insert(p->rs, q, x - p->sz);
        update(p);
        if (p->rnd > p->rs->rnd)
            zag(p);
        return;
    }
    p->d = data(p->a, p->b, p->c, p->sz - x);
    node* r = create(p->a, p->b, p->c, x);
    p->sz -= x;
    r->ls = p->ls;
    p->ls = r;
    r->rs = q;
    update(r);
    update(p);
}

data::data(int a, int b, int c, int x) {
    dp[0][0] = dp[3][3] = (ll)a * x;
    dp[1][1] = (ll)b * x;
    dp[2][2] = (ll)c * x;
    for (int i = 0; i < 4; ++i)
        for (int j = i + 1; j < 4; ++j)
            dp[i][j] = max(dp[i][j - 1], dp[j][j]);
}

data data::operator+(const data& x) const {
    data ret;
    for (int i = 0; i < 4; ++i)
        for (int j = i; j < 4; ++j)
            for (int k = i; k <= j; ++k)
                ret.dp[i][j] = max(ret.dp[i][j], dp[i][k] + x.dp[k][j]);
    return ret;
}
```

---

## 作者：zsplj_ (赞：3)

dp的维护别的题解已经讲得很清楚了，我发一篇非指针fhq的写法。

（蒟蒻不会splay

```cpp
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
using namespace std;

inline long long read() {
    long long x = 0, w = 1, ch = getchar();
    for (; ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') w = -1;
    for (; ch >= '0' && ch <= '9'; ch = getchar()) x = x * 10 + ch - 48;
    return w * x;
}

const int maxn = 400005;

struct node_dp {
    long long dp[4][4];
    node_dp() { memset(dp, 0, sizeof dp);}
    node_dp(int a, int b, int c, int x) {
        dp[0][0] = dp[3][3] = 1ll * a * x;
        dp[1][1] = 1ll * b * x, dp[2][2] = 1ll * c * x;
        for (int i = 0; i < 4; i++)
            for (int j = i + 1; j < 4; j++)
                dp[i][j] = max(dp[i][j-1], dp[j][j]);
    }
    node_dp operator + (const node_dp &rhs) const {
        node_dp res;
        for (int i = 0; i < 4; i++)
            for (int j = i; j < 4; j++)
                for (int k = i; k <= j; k++)
                    res.dp[i][j] = max(res.dp[i][j], dp[i][k] + rhs.dp[k][j]);
        return res;
    }
} val[maxn], sum[maxn];

int n, tot, root;
int ch[maxn][2], rnd[maxn], siz[maxn];
// all[x]储存子树x的燃料总长度, len[x]储存节点x的燃料长度。
long long all[maxn], a[maxn], b[maxn], c[maxn], len[maxn];

inline void maintain(int x) {
    siz[x] = siz[ch[x][0]] + siz[ch[x][1]] + 1;
    all[x] = all[ch[x][0]] + all[ch[x][1]] + len[x];
    sum[x] = val[x];
    if (ch[x][0]) sum[x] = sum[ch[x][0]] + sum[x];
    if (ch[x][1]) sum[x] = sum[x] + sum[ch[x][1]];
}

inline int newnode(int _a, int _b, int _c, int x) {
    rnd[++tot] = rand(), all[tot] = len[tot] = x, siz[tot] = 1;
    a[tot] = _a, b[tot] = _b, c[tot] = _c;
    val[tot] = sum[tot] = node_dp(_a, _b, _c, x);
    return tot;
}

int merge(int x, int y) {
    if (!x || !y) return x + y;
    if (rnd[x] < rnd[y]) { ch[x][1] = merge(ch[x][1], y); maintain(x); return x;}
    else { ch[y][0] = merge(x, ch[y][0]); maintain(y); return y;}
}

// 分裂出燃料长度<=k的前若干个节点
void split1(int now, long long k, int &x, int &y) {
    if (!now) { x = y = 0; return ;}
    if (all[now] - all[ch[now][1]] <= k)
        x = now, split1(ch[x][1], k - all[x] + all[ch[x][1]], ch[x][1], y);
    else y = now, split1(ch[y][0], k, x, ch[y][0]);
    maintain(now);
}

// 分裂出前k个节点
void split2(int now, int k, int &x, int &y) {
    if (!now) { x = y = 0; return ;}
    if (siz[ch[now][0]] < k)
        x = now, split2(ch[x][1], k - siz[ch[x][0]] - 1, ch[x][1], y);
    else y = now, split2(ch[y][0], k, x, ch[y][0]);
    maintain(now);
}

// 将x节点分裂为燃料长度分别为k和all[x]-k的两个节点，分别作为y的左儿子和右儿子
int insert(int x, int k, int y) {
    ch[y][0] = k == 0 ? 0 : newnode(a[x], b[x], c[x], k);
    ch[y][1] = k == all[x] ? 0 : newnode(a[x], b[x], c[x], all[x] - k);
    maintain(y); return y;
}

int main() {
    int A, B, C;
    long long p, a, b, c, x, lastans, ans;
    n = read() - 1;
    p = read(), a = read(), b = read(), c = read(), x = read();
    root = newnode(a, b, c, x);
    cout << (lastans = sum[root].dp[0][3]) << '\n';
    while (n--) {
        p = read(), a = read(), b = read(), c = read(), x = read();
        split1(root, p, A, B), split2(B, 1, B, C);
        root = merge(merge(A, insert(B, p - all[A], newnode(a, b, c, x))), C);
        ans = sum[root].dp[0][3];
        cout << ans - lastans << '\n';
        lastans = ans;
    }
}

```

---

## 作者：rehtorbegnaro (赞：3)

不难看出我们需要一棵平衡树。

不过因为一次插入的燃料数量很多，我们需要将这些燃料压成一个节点，如果说我们需要在这一段燃料的内部再插入一些燃料，把这个节点拆开就好了。

显然，对于连续的一段相同燃料，一定存在一种最优情况使得它们的工作状态是一样的。

于是我们每个节点维护两个二维数组。

`f[x][y]`表示这个节点的一个单位燃料在流程$x$和流程$y$之间的最大能量，这个数组主要是为了`pushUp`的时候方便。

`g[x][y]`表示这个节点子树内的所有燃料从流程$x$到流程$y$的最大总能量。

其中$0=3=\text{Or}$，$1=\text{Ex}$，$2=\text{En}$。

然后`pushUp`直接暴力$O(4^{3})$循环，反正时限$3\text{s}$不可能T的（

~~我是绝对不会说我忘开`long long`见了一次祖宗的（~~

~~写完一看题解感觉就自己写得最麻烦（~~

无论如何以下是代码：

```cpp
#include<cstdio>
#define re register
#define maxn 200000
#define max(a,b) ((a)>=(b)?(a):(b))

namespace cltstream{
	#define size 1048576
	char cltin[size+1],*ih=cltin,*it=cltin;
	inline char gc(){
		#ifdef ONLINE_JUDGE
			if(ih==it){
				it=(ih=cltin)+fread(cltin,1,size,stdin);
				if(ih==it)
					return EOF;
			}
			return *ih++;
		#else
			return getchar();
		#endif
	}

	char cltout[size+1],*oh=cltout,*ot=cltout+size;
	inline void pc(char c){
		if(oh==ot){
			fwrite(cltout,1,size,stdout);
			oh=cltout;
		}
		*oh++=c;
	}
	#define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout
	#undef size

	template <typename _tp>
	inline void read(_tp& x){
		int sn=1;
		char c=gc();
		for(;c!=45&&(c<48||c>57)&&c!=EOF;c=gc());
		if(c==45&&c!=EOF)
			sn=-1,c=gc();
		for(x=0;c>=48&&c<=57&&c!=EOF;x=(x<<3)+(x<<1)+(c^48),c=gc());
		x*=sn;
	}

	template <typename _tp>
	inline void write(_tp x,char text=-1){
		if(x<0)
			pc(45),x=-x;
		if(!x)
			pc(48);
		else{
			int digit[22];
			for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10);
			for(;digit[0];pc(digit[digit[0]--]^48));
		}
		if(text>=0)
			pc(text);
	}
}

namespace SplayTree{
	struct node{
		node* ftr;
		node* ch[2];
		long long val,sum,f[4][4],g[4][4];

		void pushUp();
	};
	long long h[4][4];
	#define getSide(a) (a->ftr->ch[1]==a)
	struct tree{
		private:
			node mempool[maxn+10];
			node* memtop;
			node* null;
			node* root;
			node* tmp;


			node* newNode(long long,long long,long long,long long);
			void connect(node*&,node*&,int);
			void rotate(node*&);
			void splay(node*&,node*&);
			node* findPos(long long);
			void print(node*&);

		public:
			long long insFuel();

			tree(){
				memtop=mempool;
				null=memtop;
				null->ftr=null->ch[0]=null->ch[1]=null;
				null->val=null->sum=0;
				for(re int i=0;i<4;++i)
					for(re int j=i;j<4;++j)
						null->f[i][j]=null->g[i][j]=0;
				connect(root=newNode(0,0,0,0),null,1);
			}
	};

	inline void node::pushUp(){
		sum=ch[0]->sum+ch[1]->sum+val;
		for(re int i=0;i<4;++i)
			for(re int j=i;j<4;++j){
				h[i][j]=0;
				for(re int k=i;k<=j;++k)
					h[i][j]=max(h[i][j],ch[0]->g[i][k]+val*f[k][j]);
			}
		for(re int i=0;i<4;++i)
			for(re int j=i;j<4;++j){
				g[i][j]=0;
				for(re int k=i;k<=j;++k)
					g[i][j]=max(g[i][j],h[i][k]+ch[1]->g[k][j]);
			}
	}

	inline node* tree::newNode(re long long x,re long long a,re long long b,re long long c){
		re node* p=++memtop;
		p->ftr=p->ch[0]=p->ch[1]=null;
		p->val=p->sum=x;
		p->f[0][0]=p->f[3][3]=a;
		p->f[1][1]=b;
		p->f[2][2]=c;
		p->f[0][1]=max(a,b);
		p->f[1][2]=max(b,c);
		p->f[2][3]=max(a,c);
		p->f[0][2]=p->f[0][3]=p->f[1][3]=max(max(a,b),c);
		for(re int i=0;i<4;++i)
			for(re int j=i;j<4;++j)
				p->g[i][j]=p->val*p->f[i][j];
		return p;
	}

	inline void tree::connect(re node*& x,re node*& y,re int sd){
		x->ftr=y;
		y->ch[sd]=x;
	}

	inline void tree::rotate(re node*& p){
		re node* ptr=p->ftr;
		re node* gtr=ptr->ftr;
		re int s1=getSide(p),s2=getSide(ptr);
		connect(p->ch[s1^1],ptr,s1);
		connect(ptr,p,s1^1);
		connect(p,gtr,s2);
		ptr->pushUp();
		p->pushUp();
	}

	inline void tree::splay(re node*& st,re node*& ed){
		for(re node* p=st->ftr;p!=ed;rotate(st),p=st->ftr)
			if(p->ftr!=ed)
				rotate(getSide(p)==getSide(st)?p:st);
	}

	inline node* tree::findPos(re long long x){
		for(re node* p=root;;){
			re long long ln=p->ch[0]->sum;
			if(x>ln&&x<=ln+p->val){
				splay(p,null);
				root=p;
				return p;
			}
			else
				if(x<=ln)
					p=p->ch[0];
				else{
					x-=ln+p->val;
					p=p->ch[1];
				}
		}
	}

	void tree::print(re node*& p){
		if(p!=null){
			print(p->ch[0]);
			if(p->val)
				printf("%I64d*(%I64d,%I64d,%I64d)\n",p->val,p->f[0][0],p->f[1][1],p->f[2][2]);
			print(p->ch[1]);
		}
	}

	inline long long tree::insFuel(){
		re long long pos,a,b,c,x;
		cltstream::read(pos);
		cltstream::read(a);
		cltstream::read(b);
		cltstream::read(c);
		cltstream::read(x);
		re node* p;
		if(pos){
			p=findPos(pos);
			re long long l=pos-p->ch[0]->sum,r=p->val-l;
			if(l){
				tmp=newNode(l,p->f[0][0],p->f[1][1],p->f[2][2]);
				connect(p->ch[0],tmp,0);
				connect(tmp,p,0);
				tmp->pushUp();
			}
			if(r){
				tmp=newNode(r,p->f[0][0],p->f[1][1],p->f[2][2]);
				connect(p->ch[1],tmp,1);
				connect(tmp,p,1);
				tmp->pushUp();
			}
		}
		else{
			p=root;
			for(;p->ch[0]!=null;p=p->ch[0]);
			if(p->val){
				connect(tmp=newNode(0,0,0,0),p,0);
				p=tmp;
			}
			splay(p,null);
			root=p;
		}
		p->val=x;
		p->f[0][0]=p->f[3][3]=a;
		p->f[1][1]=b;
		p->f[2][2]=c;
		p->f[0][1]=max(a,b);
		p->f[1][2]=max(b,c);
		p->f[2][3]=max(a,c);
		p->f[0][2]=p->f[0][3]=p->f[1][3]=max(max(a,b),c);
		p->pushUp();
		return p->g[0][3];
	}
}

int n;
long long lastAns,newAns;
SplayTree::tree st;

int main(){
	cltstream::read(n);
	for(;n;--n){
		newAns=st.insFuel();
		cltstream::write(newAns-lastAns,10);
		lastAns=newAns;
	}
	clop();
	return 0;
}
```

---

## 作者：KellyFrog (赞：2)

~~Splay 神教万岁！！！11~~

首先有个显然的结论，一段连续的燃料肯定只用于一个阶段。

对每个燃料的连续段维护一个 Splay 节点，对每个点维护 $f_{i,j}$ 表示该点为根的子树的第一个是 $i$ 阶段，最后一个是 $j$ 阶段的最大答案，那转移就是 $f_{i,j}=\max\limits_{i\le k\le j}\{f'_{i,k}+f''_{k,j}\}$，其中 $f',f''$ 分别表示合并成 $f_{i,j}$ 的两个节点的 $f$ 值

初始条件就是 $f_{i,j}=\max\limits_{i\le k\le j} \{val_k\cdot x\}$

套路性地找到插入的位置，Splay 到根，如果正好在一个节点内，就把节点拆裂开拆成两个，然后把新的点放进去就行了，需要一点点讨论

另外需要注意 `PushUp` 的写法

总的复杂度 $O(q\cdot \log n)$，带一个 64 倍常数，跑得不快但能过

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef long double ldb;
typedef vector<int> vi;
typedef pair<int, int> pii;
#define fi first
#define se second

#if __cplusplus < 201703L
#define rg register
#else
#define rg
#endif

#define mp make_pair
#define pb push_back
#define pf push_front

#define rep(i, s, t) for (rg int i = s; i <= t; i++)
#define per(i, s, t) for (rg int i = t; i >= s; i--)
#define OK cerr << "OK!\n"

namespace fastio {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;

inline char getchar() {
  return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin),
          (iS == iT ? EOF : *iS++) : *iS++);
}
inline void qread() {}
template <typename T1, typename... T2>
inline void qread(T1& x, T2&... ls) {
  x = 0;
  rg char ch = ' ';
  rg int ps = 1;
  while (!isdigit(ch) && ch != '-') ch = getchar();
  if (ch == '-') ps = -1, ch = getchar();
  while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();
  x *= ps;
  qread(ls...);
}

inline void flush() {
  fwrite(obuf, 1, oS - obuf, stdout);
  oS = obuf;
  return;
}
inline void putchar(char _x) {
  *oS++ = _x;
  if (oS == oT) flush();
}
template <typename T>
inline void qwrite(T x) {
  if (x < 0) putchar('-'), x = -x;
  if (x < 10) return putchar('0' + x), void();
  qwrite(x / 10), putchar('0' + (x % 10));
}

template <typename T>
inline void qwrite(T x, char ch) {
  qwrite(x), putchar(ch);
}
};  // namespace fastio

#ifndef ONLINE_JUDGE

void debug(const char* s) { cerr << s; }
template <typename T1, typename... T2>
void debug(const char* s, const T1 x, T2... ls) {
  int p = 0;
  while (*(s + p) != '\0') {
    if (*(s + p) == '{' && *(s + p + 1) == '}') {
      cerr << x;
      debug(s + p + 2, ls...);
      return;
    }
    cerr << *(s + p++);
  }
}

#else
#define debug(...) void(0)
#endif

const ll mod = 1e9 + 7;
// const ll mod = 1e9 + 9;
// const ll mod = 19260817;
// const ll mod = 998244353;
// const int mod =2017;

template <typename T>
inline void chkadd(T& x, T y) {
  x = x + y >= mod ? x + y - mod : x + y;
}
template <typename T>
inline void chkadd(T& x, T y, T z) {
  x = y + z >= mod ? y + z - mod : y + z;
}
template <typename T>
inline void chkmns(T& x, T y) {
  x = x - y < 0 ? x - y + mod : x - y;
}
template <typename T>
inline void chkmns(T& x, T y, T z) {
  x = y - z < 0 ? y - z + mod : y - z;
}
template <typename T>
inline void chkmax(T& x, T y) {
  x = x < y ? y : x;
}
template <typename T>
inline void chkmax(T& x, T y, T z) {
  x = y > z ? y : z;
}
template <typename T>
inline void chkmin(T& x, T y) {
  x = x < y ? x : y;
}
template <typename T>
inline void chkmin(T& x, T y, T z) {
  x = y < z ? y : z;
}

ll qpow(ll x, ll p) {
  rg ll base = x, res = 1;
  while (p) {
    if (p & 1) res = (res * base) % mod;
    base = (base * base) % mod;
    p >>= 1;
  }
  return res;
}

// fhq? 狗都不写（雾

const int N = 4e5 + 5;

struct SplayNode {
  int fat;
  ll same, siz;
  int son[2];
  ll val[5][5];
  ll oval[5];
  SplayNode(ll curval[], ll sam0 = 0, int fat0 = 0, int lson = 0, int rson = 0)
      : fat(fat0), siz(sam0), same(sam0) {
    son[0] = lson;
    son[1] = rson;
    memset(val, 0, sizeof val);
    rep(i, 1, 4) rep(j, i, 4) rep(k, i, j) chkmax(val[i][j], (k == 4 ? curval[1] : curval[k]) * sam0);
    rep(i, 1, 3) oval[i] = curval[i];
  }
  SplayNode() {}
  
  void renew() {
  	siz = same;
  	memset(val, 0, sizeof val);
    rep(i, 1, 4) rep(j, i, 4) rep(k, i, j) chkmax(val[i][j], (k == 4 ? oval[1] : oval[k]) * same);
  }
};

SplayNode tree[N];
int n;

#define fa(x) tree[x].fat
#define son(x, p) tree[x].son[p]
#define lson(x) son(x, 0)
#define rson(x) son(x, 1)
#define siz(x) tree[x].siz
#define val(x, i, j) tree[x].val[i][j]
#define pos(x) (rson(fa(x)) == x)
#define same(x) tree[x].same
#define oval(x) tree[x].oval

inline void Merge(SplayNode& tar, SplayNode a, SplayNode b) {
  memset(tar.val, 0, sizeof tar.val);
    
  rep(k, 1, 4) rep(i, 1, 4) rep(j, i, 4) if(i <= k && k <= j) chkmax(tar.val[i][j], a.val[i][k] + b.val[k][j]);
  tar.siz = a.siz + b.siz;
}

void Connect(int cur, int fa, int p) {
  son(fa, p) = cur;
  fa(cur) = fa;
}

inline void PushUp(int p) {
	tree[p].renew();
	Merge(tree[p], tree[lson(p)], tree[p]);
	Merge(tree[p], tree[p], tree[rson(p)]);
}

inline void Rotate(int cur) {
  int fa = fa(cur);
  int pos = pos(cur);
  Connect(cur, fa(fa), pos(fa));
  Connect(son(cur, pos ^ 1), fa, pos);
  Connect(fa, cur, pos ^ 1);
  PushUp(fa);
  PushUp(cur);
  PushUp(fa(cur));
}

inline void Splay(int from, int to) {
  to = fa(to);
  while (fa(from) != to) {
    int f = fa(from);
    if (fa(f) == to) {
      Rotate(from);
    } else if (pos(from) == pos(f)) {
      Rotate(f), Rotate(from);
    } else {
      Rotate(from), Rotate(from);
    }
  }
}

inline int kth(int cur, ll k) { //<= 的有k个
	if(k <= siz(lson(cur))) return kth(lson(cur), k);
	else if(siz(lson(cur)) <= k && k <= siz(lson(cur)) + same(cur)) return cur;
	else return kth(rson(cur), k - siz(lson(cur)) - same(cur));
}

#define rt lson(1)
#define sroot 1
int tot = 1;

inline int newnode(ll val[], ll same) {
	tot++;
	tree[tot] = SplayNode(val, same);
	return tot;
}

inline void Insert(ll p, ll val[], ll x) {
	if(rt == 0) {
		rt = newnode(val, x);
		Connect(rt, sroot, 0);
	} else {
		if(p == siz(rt)) {
			int cur = newnode(val, x);
			Connect(rt, cur, 0);
			Connect(cur, sroot, 0);
			PushUp(cur);
		} else {
			Splay(kth(rt, p), rt);
			if(siz(lson(rt)) == p) {
				int cur = newnode(val, x);
				Connect(lson(rt), cur, 0);
				Connect(cur, rt, 0);
				PushUp(cur);
				PushUp(rt);
			} else if(siz(lson(rt)) + same(rt) == p) {
				int cur = newnode(val, x);
				Connect(rson(rt), cur, 1);
				Connect(cur, rt, 1);
				PushUp(cur);
				PushUp(rt);
			} else {
				int sizl = p - siz(lson(rt));
				int sizr = same(rt) - sizl;
				int nd1 = newnode(oval(rt), sizl);
				int nd2 = newnode(oval(rt), sizr);
				int cur = newnode(val, x);
				Connect(nd2, nd1, 1);
				Connect(cur, nd2, 0);
				Connect(rson(rt), nd2, 1);
				Connect(lson(rt), nd1, 0);
				Connect(nd1, sroot, 0);
				PushUp(nd2);
				PushUp(nd1);
			}
		}
	}
}

int main() {
	fastio::qread(n);
	ll lastans = 0;
	rep(i, 1, n) {
		static ll val[4];
		ll p, x;
		fastio::qread(p, val[1], val[2], val[3], x);
		Insert(p, val, x);
		fastio::qwrite(val(rt, 1, 4) - lastans, '\n');
		lastans = val(rt, 1, 4);
	}
  fastio::flush();
  return 0;
}

```

---

## 作者：meizhuhe (赞：1)


我来一篇很麻烦的题解。

## 思路讲解
首先注意到题目要求某一段的和，于是不难想到用前缀和转化。由于所有权值非负，因此最后一种阶段的末端点一定取全部的末端点。设 $A$，$B$，$C$ 分别为三种状态的前缀和，仅需
$$
Ans=A_l-A_k+C_k-C_j+B_j-B_i+A_i \space \space \space (i\leq j\leq k)
$$
最大即可。考虑到 $A_l$ 为常数，仅需置变换
$$
\begin{cases}
C'_k=C_k-A_k\\
B'_j=B_j-C_j\\
A'_i=A_i-B_i\\
\end{cases}
$$
题目即要求序列中 $A_i'+B_j'+C_k'$ 最大即可。这是显然可以用线段树维护的。现在问题是点数量太多，于是我们将相同种类的点缩在一起。

这启示我们将询问离线下来，使用平衡树维护出每一段的编号，再用线段树插入、区间加即可。

这边需要注意的是，对于没有插入过点的线段树节点，我们本来无法直接将区间加的标记和它合并，于是我们对每个节点单独维护一个标记，等到这个点非空了在将这个标记和这个节点的答案合并。

```cpp
#include <bits/stdc++.h>
#define rep(i,s,t) for(int i=(s);i<=(t);i++)
#define MAXN 100009
#define MAXSPACE 2000009
#define int long long
using namespace std;
int n,s;
int a[MAXN],b[MAXN],c[MAXN],sum[MAXN];
vector<pair<int,int>> S[MAXN];
typedef long long ull;
struct Treap {
	int wtot;
	default_random_engine egg;
	struct Node {
		Node* ch[2];
		int pri;
		int val,rec,size1;
		ull size2;
	} T[MAXN<<2];
	Node *NULLPTR,*root;
	Treap():NULLPTR(&T[0]),root(NULLPTR){ }
	inline Node* createnode(){ ++wtot; T[wtot].ch[0]=NULLPTR; T[wtot].ch[1]=NULLPTR; return &T[wtot]; }
	inline void pushup(Node* x){
		x->size1=x->ch[0]->size1+x->ch[1]->size1+1;
		x->size2=x->ch[0]->size2+x->ch[1]->size2+x->rec;
	}	
	void split(Node* x,int k,Node* &a,Node* &b){
		if(x==NULLPTR){
			a=b=NULLPTR;
			return;
		}
		if(k<=x->ch[0]->size1){
			b=x;
			split(x->ch[0],k,a,x->ch[0]);
		}
		else {
			a=x;
			split(x->ch[1],k-x->ch[0]->size1-1,x->ch[1],b);
		}
		pushup(x);
	}
	Node* merge(Node* a,Node* b){
		if(a==NULLPTR) return b;
		if(b==NULLPTR) return a;
		if(a->pri>b->pri){
			a->ch[1]=merge(a->ch[1],b);
			pushup(a);
			return a;
		}
		else {
			b->ch[0]=merge(a,b->ch[0]);
			pushup(b);
			return b;
		}
	}
	int mpfd(Node* x,int pos,int& d){
		if(x->ch[0]->size2<pos&&pos<=x->ch[0]->size2+x->rec){
			d=pos-x->ch[0]->size2;
			return x->ch[0]->size1+1;
		}
		else if(pos<=x->ch[0]->size2)
			return mpfd(x->ch[0],pos,d);
		else return x->ch[0]->size1+1+mpfd(x->ch[1],pos-x->ch[0]->size2-x->rec,d);
	}
	void insert(int val,int rec,int pos){
		Node* a;
		a=createnode();
		a->val=val,a->size1=1,a->size2=a->rec=rec,a->pri=egg();
		if(root==NULLPTR){
			root=a;
			return;
		}
		int d;
		int k=mpfd(root,pos,d);
		Node* x,*y,*b,*c;
		split(root,k,x,y);
		split(x,k-1,x,b);
		if(d==b->rec)
			c=NULLPTR;
		else {
			c=createnode();
			c->size1=1,c->val=b->val,c->size2=c->rec=b->rec-d;
			c->pri=egg(),b->size2=b->rec=d;
		}
		root=merge(merge(x,merge(merge(b,a),c)),y);
	}
	void __dfs(Node* x,int t=0){
		if(x==NULLPTR)
			return;
		S[x->val].push_back(make_pair(x->ch[0]->size1+t+1,x->rec));
		__dfs(x->ch[0],t);
		__dfs(x->ch[1],t+x->ch[0]->size1+1);
	}
	void output(Node* x=0){
		if(x==0)
			x=root;
		if(x==NULLPTR)
			return;
		output(x->ch[0]);
		cerr<<x->val<<","<<x->rec<<endl;
		output(x->ch[1]);
	}
	void calc(){ __dfs(root); s=root->size1; }
} bst;

struct SGT {
	static const ull NOTEXIST=-1145149980;
	struct Node {
		ull ans1,ans2,ans3;
		ull mxv[3],dc[3];
		Node():mxv{NOTEXIST,NOTEXIST,NOTEXIST},dc{0,0,0} { }
		friend Node operator+(const Node& A,const Node& B){
			if(A.mxv[0]==NOTEXIST) return B;
			if(B.mxv[0]==NOTEXIST) return A;
			Node C;
			rep(i,0,2) C.mxv[i]=max(A.mxv[i],B.mxv[i]);
			C.ans1=max({A.ans1,B.ans1,A.mxv[0]+B.mxv[1]});
			C.ans2=max({A.ans2,B.ans2,A.mxv[1]+B.mxv[2]});
			C.ans3=max({A.ans3,B.ans3,A.ans1+B.mxv[2],A.mxv[0]+B.ans2});
			return C;
		}
		void flush(){
			if(mxv[0]==NOTEXIST)
				return;
			rep(i,0,2){
				ans3+=dc[i];
				if(i!=2) ans1+=dc[i];
				if(i!=0) ans2+=dc[i];
				mxv[i]+=dc[i];
				dc[i]=0;
			}
		}
	} T[MAXSPACE];
	ull tag[MAXSPACE][3];
	
	inline void pushup(int x){ T[x]=T[x<<1]+T[x<<1|1]; T[x].flush(); }
	inline void pushdown(int x){
		for(auto y:{x<<1,x<<1|1})
			rep(i,0,2){
				tag[y][i]+=tag[x][i];
				T[y].dc[i]+=tag[x][i];
				T[y].flush();
			}
		rep(i,0,2)
			tag[x][i]=0;
	}
	
	void __updata1(int x,int l,int r,int L,int R,ull det[3],int rec){
		if(L<=l&&r<=R){
			rep(i,0,2){
				tag[x][i]+=det[i]*rec;
				T[x].dc[i]+=det[i]*rec;
			}
			T[x].flush();
			return;
		}
		int mid=l+r>>1;
		pushdown(x);
		if(L<=mid) __updata1(x<<1,l,mid,L,R,det,rec);
		if(mid<R)  __updata1(x<<1|1,mid+1,r,L,R,det,rec);
		pushup(x);
	}
	void __updata2(int x,int l,int r,int pos,ull det[3],int rec){
		if(l==r){
			//cerr<<T[x].dc[0]<<" "<<T[x].dc[1]<<" "<<T[x].dc[2]<<endl;
			rep(i,0,2){
				if(det[i]>0)
					T[x].mxv[i]=det[i]*rec;
				else T[x].mxv[i]=det[i];
			}
			if(det[0]>0&&det[1]<0){
				if(det[0]+det[1]>0)
					T[x].ans1=(det[0]+det[1])*rec;
				else T[x].ans1=det[0]+det[1];
			}
			else T[x].ans1=T[x].mxv[0]+T[x].mxv[1];
			if(det[1]>0&&det[2]<0){
				if(det[1]+det[2]>0)
					T[x].ans2=(det[1]+det[2])*rec;
				else T[x].ans2=det[1]+det[2];
			}
			else T[x].ans2=T[x].mxv[1]+T[x].mxv[2];
			if(det[0]>0){
				// i must equal to j
				if(det[0]+det[1]>0){
					if(det[0]+det[1]+det[2]>0)
						T[x].ans3=(det[0]+det[1]+det[2])*rec;
					else T[x].ans3=det[0]+det[1]+det[2];
				}
				else T[x].ans3=det[0]+det[1]+T[x].mxv[2];
			}
			else T[x].ans3=det[0]+T[x].ans2;
			T[x].flush();
			return;
		}
		int mid=l+r>>1;
		pushdown(x);
		if(pos<=mid) __updata2(x<<1,l,mid,pos,det,rec);
		else __updata2(x<<1|1,mid+1,r,pos,det,rec);
		pushup(x);
	}
	void insert(int pos,int rec,int i){
		ull tmp[]={a[i]-b[i],b[i]-c[i],c[i]-a[i]};
		__updata1(1,1,s,pos+1,s,tmp,rec);
		__updata2(1,1,s,pos,tmp,rec);
	}	
	ull getans(){ return T[1].ans3; }
} sgt;
template<typename Integer>
inline void read(Integer& x){
	x=0;
	register char c=getchar();
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
}
signed main(){
	read(n);
	bst.insert(0,1,0);
	bst.insert(n+1,1,1);
	rep(i,1,n){
		ull pos,x;
		read(pos);
		read(a[i]),read(b[i]),read(c[i]);
		read(x);
		sum[i]=sum[i-1]+a[i]*x;
		
		bst.insert(i,x,pos+1);
	}
	bst.calc();
	sgt.insert(1,1,0);
	ull lastans=0,tmp;
	rep(i,1,n){
		for(auto x:S[i])
			sgt.insert(x.first,x.second,i);
		tmp=sgt.getans()+sum[i];
		printf("%lld\n",tmp-lastans);
		lastans=tmp;
	}
	return 0;
}
```


---

## 作者：dengyaotriangle (赞：1)

我们定义一种新的矩阵乘法以及对应的向量乘法。

对于向量 $a,c$ 矩阵 $b$：

$c=a\times b$ 对应着

$c_{i}=\max\limits_k \left\{a_{k}+b_{k,i}\right\} $

对于矩阵 $a,b,c$

$c=a\times b$ 对应着

$c_{i,j}=\max\limits_k \left\{a_{i,k}+b_{k,j}\right\}$

它满足结合律。

这样就可以用这种矩阵乘法来维护dp

若 $dp_{i,p}$ 代表到达第 $i$ 个燃料段，最后一个阶段是第 $j$ 个的最大收益。

我们有 $dp_{i,p}=\max\limits_{p'\leq p} \left\{dp_{i-1,p'}+f(i,p)\right\}$

其中 $f(i,p)$ 代表第 $i$ 个燃料段以第 $p$ 阶段使用的收益（ $=$ 燃料段长度 $\times$ 单位收益）

我们发现，如果我们预处理一个矩阵 $t_{x,y}=\begin{cases}f(i,y)& x\leq y\\-\infty & x>y\end{cases}$

那么转移就可以写成 $dp_i=dp_{i-1}\times t$ ，其中 $t$ 是 $i$ 对应的矩阵。

我们考虑一堆连续段，那么答案就是 全 $0$ 向量 $a$ 乘上所有的段对应的矩阵 $t$ 的乘积（因为 dp 初始值全是 0，之后每次乘上一个矩阵就等于进行了一次转移）

那么我们就可以使用平衡树维护这些连续的燃料段，并且维护区间对应矩阵乘积。

最后，0向量乘上根节点的乘积所得到的向量的各项的最大值就是答案。

注意，这样做是对的是因为这种新定义的运算有结合律。**但不满足交换律，请务必按顺序乘。**

我们发现，转移矩阵和对应向量都是 4 阶的，而众所周知矩阵乘法可以 $n^3$ 搞定。

所以复杂度 $O(4^3n\log n )$

另外还需注意，如果平衡树 split 到了一个节点的中间，那么我们需要把这个节点分裂成两半，其它部分和普通的维护区间乘积的平衡树无异。

还有 long long 要开足。

```cpp
#include<bits/stdc++.h>
using namespace std;
//dengyaotriangle!

struct mat{
    long long v[4][4];
    mat(){memset(v,0xc0,sizeof(v));}
    inline friend mat operator*(const mat&a,const mat&b){
        mat c;
        for(int i=0;i<4;i++){
            for(int j=i;j<4;j++){
                for(int k=i;k<=j;k++){
                    c.v[i][j]=max(c.v[i][j],a.v[i][k]+b.v[k][j]);
                }
            }
        }
        return c;
    }
};

struct node{
    mat vl,sm;
    long long sze,len;
    int rnd;
    int av,bv,cv;
    node* c[2];
};

const int maxn=100005;
node pool[maxn*2];
int ps;
inline void csct(node* rt){
    #define mt rt->vl.v
    rt->vl=mat();
    mt[0][0]=mt[0][3]=mt[1][3]=mt[2][3]=mt[3][3]=rt->len*rt->av;
    mt[1][1]=mt[0][1]=rt->len*rt->bv;
    mt[2][2]=mt[0][2]=mt[1][2]=rt->len*rt->cv;
}

inline node* nwnode(long long l,int a,int b,int c){
    node* nw=pool+ps++;
    nw->sze=nw->len=l;nw->rnd=rand();nw->av=a;nw->bv=b;nw->cv=c;
    csct(nw);
    nw->sm=nw->vl;
    return nw;
}

inline void pu(node* rt){
    rt->sze=rt->len+(rt->c[0]?rt->c[0]->sze:0ll)+(rt->c[1]?rt->c[1]->sze:0ll);
    if(!rt->c[0]&&!rt->c[1])rt->sm=rt->vl;
    else if(!rt->c[1])rt->sm=rt->c[0]->sm*rt->vl;
    else if(!rt->c[0])rt->sm=rt->vl*rt->c[1]->sm;
    else rt->sm=rt->c[0]->sm*rt->vl*rt->c[1]->sm;
}

void spk(node*rt,long long k,node*&l,node*&r){
    if(!rt){l=r=NULL;return;}
    long long ls=rt->c[0]?rt->c[0]->sze:0;
    if(k<=ls){
        r=rt;
        spk(rt->c[0],k,l,r->c[0]);pu(r);
    }else if(k>=ls+rt->len){
        l=rt;
        spk(rt->c[1],k-ls-rt->len,l->c[1],r);pu(l);
    }else{
        node* w=nwnode(rt->len-(k-ls),rt->av,rt->bv,rt->cv);
        rt->len=(k-ls);csct(rt);
        w->c[1]=rt->c[1];rt->c[1]=w;pu(w);pu(rt);
        l=rt;spk(rt->c[1],0,l->c[1],r);pu(l);
    }
}

node* mrg(node* a,node* b){
    if(!a)return b;
    if(!b)return a;
    else if(a->rnd<b->rnd){
        a->c[1]=mrg(a->c[1],b);
        pu(a);return a;
    }else{
        b->c[0]=mrg(a,b->c[0]);
        pu(b);return b;
    }
}

int main(){
    ios::sync_with_stdio(0);
    int q;cin>>q;
    node* rt=NULL;
    long long lst=0;
    while(q--){
        long long p;
        int a,b,c,x;
        cin>>p>>a>>b>>c>>x;
        node *ax,*bx;
        spk(rt,p,ax,bx);
        rt=mrg(mrg(ax,nwnode(x,a,b,c)),bx);
        long long ans=0;
        for(int i=0;i<4;i++)ans=max(ans,rt->sm.v[0][i]);
        cout<<ans-lst<<'\n';lst=ans;
    }
    return 0;
}
```

---

## 作者：RainAir (赞：1)

本文同步发表于[RainAir's Blog](https://blog.aor.sd.cn/archives/452)

[题目链接](https://www.luogu.org/problemnew/show/P3991)

题目大意是对于每种物品被划分到不同的组里会产生不同的贡献，求一种最大的划分（这里的划分是连续一段划分到一起），并且要动态维护这个东西。

我们首先考虑静态如何做这个东西，显然我们可以设出一个极为暴力的状态：$f(l,r,i,j)$ 表示燃料 $[l,r]$ 使用区间 $[i,j]$ 内的工作状态能得到的最大价值，直接 $O(4^3)$ 枚举中间点暴力转移一下就可以了。

但是我们还要支持插入呢，所以我们可以用平衡树来做这个东西，即用平衡树的节点表示一段区间 $[l,r]$ 的所有 dp 状态，这样就可以实现动态的修改和查询了。因为貌似并不是维护序列问题，所以我写了个替罪羊树，貌似也不是很慢（

代码：
```c++
#include <algorithm>
#include <iostream>
#include <cstring>
#include <climits>
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <cmath>
#include <queue>
#include <stack>
#include <map>
#include <set>

#define fi first
#define lc(x) (ch[x][0])
#define se second
#define U unsigned
#define rc(x) (ch[x][1])
#define Re register
#define LL long long
#define MP std::make_pair
#define CLR(i,a) memset(i,a,sizeof(i))
#define FOR(i,a,b) for(Re int i = a;i <= b;++i)
#define ROF(i,a,b) for(Re int i = a;i >= b;--i)
#define SFOR(i,a,b,c) for(Re int i = a;i <= b;i+=c)
#define SROF(i,a,b,c) for(Re int i = a;i >= b;i-=c)
#define DEBUG(x) std::cerr << #x << '=' << x << std::endl

const int MAXN = 500000+5;

inline char nc(){
    static char buf[MAXN],*p1 = buf+MAXN,*p2 = buf+MAXN;
    if(p1 == p2){
        p1 = buf;p2 = buf + fread(buf,1,MAXN,stdin);
        if(p1 == p2) return -1;
    }
    return *p1++;
}

inline void read(int &x){
    x = 0;char ch = nc();int flag = 0;
    while(!isdigit(ch)){
        if(ch == '-') flag = 1;
        ch = nc();
    }
    while(isdigit(ch)){
        x = (x<<3) + (x<<1) + (ch^'0');
        ch = nc();
    }
    if(flag) x = -x;
}

inline void read(LL &x){
    x = 0;char ch = nc();int flag = 0;
    while(!isdigit(ch)){
        if(ch == '-') flag = 1;
        ch = nc();
    }
    while(isdigit(ch)){
        x = (x<<3) + (x<<1) + (ch^'0');
        ch = nc();
    }
    if(flag) x = -x;
}

struct Data{
    LL f[4][4];
    Data(){}
    Data(LL a,LL b,LL c,LL l){
        CLR(f,0);a *= l;b *= l;c *= l;
        f[0][0] = f[3][3] = a;f[1][1] = b;f[2][2] = c;
        f[0][1] = std::max(a,b);f[1][2] = std::max(b,c);f[2][3] = std::max(a,c);
        f[0][2] = f[1][3] = f[0][3] = std::max(a,std::max(b,c));
    }

    Data operator + (const Data &t) const{
        Data res;CLR(res.f,0);
        FOR(l,1,4){
            FOR(i,0,4-l){
                int j = i+l-1;
                FOR(k,i,j) res.f[i][j] = std::max(res.f[i][j],f[i][k]+t.f[k][j]);
            }
        }
        return res;
    }
}val[MAXN];
int fa[MAXN],ch[MAXN][2],A[MAXN],L[MAXN],B[MAXN],C[MAXN],q[MAXN],size[MAXN];
int N,cnt,top,root,rebuilder;
LL len[MAXN],tot;

const double alpha = 0.8;

inline bool isbad(int x){
    return alpha*size[x] < std::max(size[lc(x)],size[rc(x)]);
}

inline void pushup(int x){
    val[x] = Data(A[x],B[x],C[x],L[x]);
    if(lc(x)) val[x] = val[lc(x)] + val[x];
    if(rc(x)) val[x] = val[x] + val[rc(x)];
    len[x] = len[lc(x)] + len[rc(x)] + L[x];
    size[x] = size[lc(x)] + size[rc(x)] + 1;
}

inline int find(int x,LL pos){
    if((len[lc(x)] < pos || (!lc(x) && !pos)) && len[lc(x)]+L[x] >= pos) return x;
    if(len[lc(x)] >= pos) return find(lc(x),pos);
    tot += len[lc(x)]+L[x];
    return find(rc(x),pos-len[lc(x)]-L[x]);
}

inline void insert(int &x,int a,int b,int c,LL pos,int l,int pre=0){
    if(!x){
        x = ++cnt;val[x] = Data(a,b,c,l);
        A[x] = a;B[x] = b;C[x] = c;L[x] = len[x] = l;size[x] = 1;fa[x] = pre;
        return;
    }
    if(pos < len[lc(x)]+L[x]) insert(lc(x),a,b,c,pos,l,x);
    else insert(rc(x),a,b,c,pos-len[lc(x)]-L[x],l,x);
    pushup(x);
    if(isbad(x)) rebuilder = x;
}

inline void update(int x,int k,LL pos,int l){
    if(x == k){
        L[x] = l;pushup(x);
        return;
    }
    if(pos <= len[lc(x)]) update(lc(x),k,pos,l);
    else update(rc(x),k,pos-len[lc(x)]-L[x],l);
    pushup(x);
}

inline void dfs(int x){
    if(lc(x)) dfs(lc(x));
    q[++top] = x;
    if(rc(x)) dfs(rc(x));
}

inline void build(int &x,int l,int r,int pre){
    if(l > r){
        x = 0;return;
    }
    int mid = (l + r) >> 1;//DEBUG(mid);
    x = q[mid];fa[x] = pre;
    build(lc(x),l,mid-1,x);build(rc(x),mid+1,r,x);
    pushup(x);
}

inline void rebuild(int x){
    rebuilder = top = 0;dfs(x);int y = fa[x];
    if(!y) build(root,1,top,0);
    else build(ch[y][rc(y)==x],1,top,y);
}

signed main(){
    int N;read(N);
    insert(root,0,0,0,0,0);
    LL lastans = 0;
    FOR(i,1,N){
        LL p;int a,b,c,d;
        read(p);read(a);read(b);read(c);read(d);
        tot = 0;int x = find(root,p);
        if(tot + len[lc(x)] + L[x] != p){
            LL left = tot + len[lc(x)] + L[x] - p;
            update(root,x,p,L[x]-left);
            insert(root,a,b,c,p,d);if(rebuilder) rebuild(rebuilder);
            insert(root,A[x],B[x],C[x],p+d,left);
        }
        else insert(root,a,b,c,p,d);
        printf("%lld\n",val[root].f[0][3]-lastans);
        lastans = val[root].f[0][3];if(rebuilder) rebuild(rebuilder);
    }
    return 0;
}
```

---

## 作者：zzw4257 (赞：1)

> 维护一个初始为空的集合
>
> 两个点相同定义为这个点被分为$0/1/2/3$类别时的代价相同
>
> 支持
>
> - 在某个位置后连续插入$x$个相同的点
>
> - 求从左到右类别编号不减的代价最大分类方法

考虑询问是全局性的，我们先做一个从$1$位置开始的$dp$

设$f_{x,k}$表示$x$位置选$k$类的最大方案则$f_{x,k}=\max_{j\leqslant k}{\{f_{x,j}+val_k\}}$

考虑起止端点与选择不定

改设$f_{[l,r],[L,R]}$表示对于$[l,r]$位置的点$l$选$L$,$r$选$R$的最优情况

有$\displaystyle f_{[l,r],[L,R]}=\max_{mid\in[L,R]}\{f_{[l,r'],[L,mid]}+val_{mid}+f_{[l',r],[mid,R]}\}$

因为要插入我们用任意平衡树维护位置关系并划分区间然后$pushup$时转移即可

注意到连续的相同的点分类必须一致，所以不如捆绑成一个点并改写一下贡献，最后插入时二分到无法完全放到两个整块中间就拆点即可

我用的FHQTreap

```cpp
inline void pushup(int x){
	int i,j,k;for(i=0;i<4;++i)for(j=0;j<4;++j)f[x][i][j]=0;
	for(i=0;i<4;++i)for(j=i;j<4;++j)for(k=j;k<4;++k)f[x][i][k]=max(f[x][i][k],f[*son[x]][i][j]+f[son[x][1]][j][k]+1ll*v[x][j]*cnt[x]);
	sum[x]=sum[*son[x]]+sum[son[x][1]]+cnt[x];
	size[x]=size[*son[x]]+size[son[x][1]]+1;
}
...
while(n--){
		p=read(),a=read(),b=read(),c=read(),sz=read();
		now=Newnode(a,b,c,a,sz),pos=Find_kth(p);
		Split(rt,pos,x,y),Split(x,pos-1,x,z);
		if(sum[x]+cnt[z]==p)rt=Merge(Merge(x,z),Merge(now,y));
		else{
			l=Newnode(v[z][0],v[z][1],v[z][2],v[z][3],p-sum[x]);
			r=Newnode(v[z][0],v[z][1],v[z][2],v[z][3],sum[x]+sum[z]-p);
			rt=Merge(Merge(x,Merge(l,now)),Merge(r,y));
		}printf("%lld\n",f[rt][0][3]-ans),ans=f[rt][0][3];
	}
```

---

## 作者：LCat90 (赞：0)

来一个新做法。不需要用 dp 和矩阵。（调了 1.5 天）

最终的答案是由连续的 $a,b,c,a$ 按顺序构成的。不妨先假设全部选择 $a$。

然后我们希望修改一些 $b,c$ 使答案更大，即增量 $b-a,c-a$ 的和最大。

根据这个特殊的结构可以得出：只需要在全选 $a$ 的基础上，选择加上一段：由一段 $b-a$ 和一段 $c-a$ 拼接而成的子段（以下称为 bc 段）。维护这个连续子段的最大值即可。（笔者使用 FHQ）

如何维护呢（较难）？首先这个最大值可以是左右两个子树的最大值。然后对于跨越两棵子树的方案，很容易想到 2 种方案：

1. 左子树选取后缀最大 bc 段（即在左子树最后一个点结尾），中间点选 $c-a$，右子树取前缀最大 $c-a$ 连续段。

2. 右子树选取前缀最大 bc 段，中间点选 $b-a$，右子树取后缀最大 $b-a$ 连续段。

核心思想便是这样，注意维护前后缀最大 bc 段的时候还要维护“由区间内所有点构成的最大 bc 段”。总之，需要维护：

所有点的 $b-a$ 和、$c-a$ 和、前缀最大 $c-a$ 连续段、后缀最大 $b-a$ 连续段、前缀最大 bc 段、后缀最大 bc 段、由区间内所有点构成的最大 bc 段、最大 bc 段。

还有一个问题，如何找到每个 $x_i$ 在当前位置对应的点？我们仿照查询 rank 的方式，维护 $val$ 表示子树内一共有多少个燃料，类似线段树二分向左右子树递归即可。

然后就把这个点分裂成 2 份，中间插入输入的新点，最后统一 ``merge``，将剩下的交给 ``pushup``。

时间复杂度为 $O(n\log n)$，除开某个人用我的代码在那乱刷最优以外排在最优解第二名。

```cpp
#include <bits/stdc++.h>
#define int long long
#define pii pair <int, int>
using namespace std;
const int N = 3e5 + 5; int read();
mt19937 myrand(time(NULL));

int sum, ans, lst, n;
namespace Fhq {
	int Root, cnt, ls[N], rs[N], rnk[N], siz[N];
	int a[N], b[N], c[N], maxn[N], add[N], sumb[N], sumc[N];
	int val[N], sumval[N], pb[N], pc[N], maxnpre[N], maxnnxt[N], maxnwanzheng[N];
	int New(int x, int y, int z, int sb) {
		siz[++cnt] = 1; rnk[cnt] = myrand(); sumval[cnt] = val[cnt] = sb;
		a[cnt] = x; sumb[cnt] = b[cnt] = y - x, sumc[cnt] = c[cnt] = z - x;
		maxn[cnt] = max({0ll, z - x, y - x}); 
		maxnnxt[cnt] = pb[cnt] = max(0ll, sumb[cnt]), maxnpre[cnt] = pc[cnt] = max(0ll, sumc[cnt]);
		maxnwanzheng[cnt] = max(b[cnt], c[cnt]);
		return ls[cnt] = rs[cnt] = 0, cnt;
	}	
	void pushup(int x) { 
		sumval[x] = val[x] + sumval[ls[x]] + sumval[rs[x]];
		siz[x] = siz[ls[x]] + siz[rs[x]] + 1; 
		
		sumb[x] = sumb[ls[x]] + sumb[rs[x]] + b[x];
		sumc[x] = sumc[ls[x]] + sumc[rs[x]] + c[x];
		pb[x] = max(pb[rs[x]], sumb[rs[x]] + b[x] + pb[ls[x]]); // b 的后綴 
		pc[x] = max(pc[ls[x]], sumc[ls[x]] + c[x] + pc[rs[x]]); // c 的前綴
		maxnwanzheng[x] = max({sumb[x], sumc[x], maxnwanzheng[ls[x]] + c[x] + sumc[rs[x]], maxnwanzheng[rs[x]] + b[x] + sumb[ls[x]]});
		
		maxnpre[x] = max({maxnpre[ls[x]], sumb[ls[x]] + b[x] + maxnpre[rs[x]], maxnwanzheng[ls[x]] + c[x] + pc[rs[x]]}); // 少考虑情况 
		maxnnxt[x] = max({maxnnxt[rs[x]], sumc[rs[x]] + c[x] + maxnnxt[ls[x]], maxnwanzheng[rs[x]] + b[x] + pb[ls[x]]}); 
		maxn[x] = max({pb[ls[x]] + pc[rs[x]] + max(b[x], c[x]), maxnnxt[ls[x]] + c[x] + pc[rs[x]], pb[ls[x]] + b[x] + maxnpre[rs[x]], maxn[ls[x]], maxn[rs[x]]});
	}
	int merge(int x1, int x2) { // 满足 x1 中的 ky 值都小于 x2 
		if(!x1 or !x2) return pushup(x1 + x2), x1 + x2; 
		if(rnk[x1] < rnk[x2]) return rs[x1] = merge(rs[x1], x2), pushup(x1), x1;
		return ls[x2] = merge(x1, ls[x2]), pushup(x2), x2;
	}
	pii split(int x, int y) { // 将 x 点分成 <= y 和 > y 
		pii ans = {0, 0};
		if(!x) return ans;
		if(siz[ls[x]] + 1 <= y) ans = split(rs[x], y - siz[ls[x]] - 1), rs[x] = ans.first, ans.first = x;
		else ans = split(ls[x], y), ls[x] = ans.second, ans.second = x;
		return pushup(x), ans;
	}
	pii find(int x, int y) {
		if(!x) return {0, 0}; 
		pii ans = {0, 0};
		if(sumval[ls[x]] >= y) ans = find(ls[x], y);
		else if(sumval[ls[x]] + val[x] >= y) ans = {x, siz[ls[x]] + 1};
		else ans = find(rs[x], y - sumval[ls[x]] - val[x]), ans.second += siz[ls[x]] + 1;		
		return ans;
	}
} 
using namespace Fhq;

signed main() {
	int T, lst = 0; cin >> T;
	for(int cs = 1;cs <= T; ++cs) {
		int x = read(), a1 = read(), a2 = read(), a3 = read(), y = read();
		a1 *= y, a2 *= y, a3 *= y; sum += a1;
		
		if(cs == 1) Root = New(a1, a2, a3, y);
		else {
			pii Sb = find(Root, x);
			int sb = Sb.first, num = Sb.second; 
			pii t1 = split(Root, num);
			pii t2 = split(t1.first, siz[t1.first] - 1);
//			if(sumval[t2.first] == x) {
//				Root = merge(merge(t2.first, merge(New(a1, a2, a3, x + 1, y), t2.second)), t1.second);
//			}
//			else { 
			int fk = t2.second; int tmp = x - sumval[t2.first]; // 表示前面插入需要一共的 
				
			int b1 = New(a[fk]/val[fk]*(val[fk] - tmp), (b[fk] +a[fk])/val[fk]*(val[fk] - tmp), (c[fk] + a[fk])/val[fk]*(val[fk] - tmp), val[fk]-tmp),
				b2 = New(a[fk] / val[fk] * tmp, (b[fk] +a[fk]) / val[fk] * tmp, (c[fk] + a[fk]) / val[fk] * tmp, tmp), b3 = New(a1, a2, a3, y);
				
			Root = merge( merge( merge( merge(t2.first, b2), b3) , b1), t1.second);
//			}
		}
//		check();
		ans = max(ans, sum + maxn[Root]); 
//		cout << Root << " " << maxn[Root] << " ";
		printf("%lld\n", ans - lst); lst = ans;
	}
	return 0;
}

int read() {
   char c; int f = 1, sum = 0;
   while(c < '0' or c > '9') {if(c == '-') f = -1;c = getchar();}
   while(c >= '0' and c <= '9') {sum = (sum << 3) + (sum << 1) + (c ^ 48);c = getchar();} 
   return sum * f;
}
```

---

## 作者：黑影洞人 (赞：0)

ddp 简单题，但是特别坑，特别难调。

首先考虑弱化版，就是不考虑插入，只用输出一次答案。

显然是一个 DP。

因为规定了顺序：通常-后期-增强-通常（每段为可空），所以对于每段燃料：

$a$：一单位燃料的通常值。

$b$：一单位燃料的后期值。

$c$：一单位燃料的增强值。

$x$：燃料数量。

因为每段燃料的 $a,b,c$ 不变，因此每段燃料决策相同。

我们有 dp 方程：

$$dp_{i,j}=\max_{k≤j}dp_{i-1,k}+a_i/b_i/c_i\times x_i$$

其中，$a$ 对应 $j=1$ 和 $4$，$b$ 对应 $2$，$c$ 对应 $3$。

然后我们发现题目是动态的，如果每次都暴力 DP，肯定会寄。

于是我们用广义矩阵乘法来进行 DP 操作，然后利用平衡树来维护矩阵乘法的变化。

值得注意点是，在插入燃料时，可能要分离整段，因此与正常的文艺平衡树不太一样。

正好 $100$ 行，不愧是我。
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#define N 414514
#define int long long
using namespace std;
int seed,md=19260817;
void _srand(int x){seed=x;}
int _rand(){seed=((seed*7%md)+13)%md;}
int n,rt;
struct matrix{
	int m[4][4];
	matrix(){memset(m,-0x3f,sizeof(m));}
	void set(int a,int b,int c,int x){
		memset(m,-0x3f,sizeof(m));
		m[0][0]=a*x;
		m[0][1]=m[1][1]=b*x;
		m[0][2]=m[1][2]=m[2][2]=c*x;
		m[0][3]=m[1][3]=m[2][3]=m[3][3]=a*x;
	}
	matrix operator*(const matrix &a)const{
		matrix res;
		for(int i=0;i<4;i++){
			for(int j=0;j<4;j++){
				for(int k=0;k<4;k++){
					res.m[i][j]=max(res.m[i][j],m[i][k]+a.m[k][j]);
				}
			}
		}
		return res;
	}
	int ans(){
		int res=-2147483647;
		for(int i=0;i<4;i++){
			for(int j=0;j<4;j++)res=max(res,m[i][j]);
		} 
		return res;
	}
}; 
struct fhqtreap{
	int ch[N][2],rnd[N],siz[N],len[N],tot;
	int a[N],b[N],c[N];
	matrix val[N],sum[N];
	#define lc ch[x][0]
	#define rc ch[x][1]
	int newnode(int aa,int bb,int cc,int xx){
		int x=++tot;
		a[x]=aa,b[x]=bb,c[x]=cc;
		rnd[x]=_rand();
		len[x]=siz[x]=xx;
		val[x].set(aa,bb,cc,xx);
		sum[x]=val[x];
		return x;
	}
	int pushup(int x){
		val[x].set(a[x],b[x],c[x],len[x]);
		siz[x]=siz[lc]+siz[rc]+len[x];
		sum[x]=val[x];
		if(lc)sum[x]=sum[lc]*sum[x];
		if(rc)sum[x]=sum[x]*sum[rc];
		return x;
	}
	int merge(int x,int y){
		if(!x||!y)return x+y;
		if(rnd[x]<rnd[y]){rc=merge(rc,y);return pushup(x);}
		else{ch[y][0]=merge(x,ch[y][0]);return pushup(y);}
	}
	int split_k(int x,int k){
		if(k>=len[x])return x;
		int nd=newnode(a[x],b[x],c[x],len[x]-k);
		len[x]=k;
		rc=merge(nd,rc);
		return pushup(x);
	}
	void split(int p,int k,int &x,int &y){
		if(!p)return void(x=y=0);
		if(siz[ch[p][0]]>=k)split(ch[y=p][0],k,x,ch[p][0]);
		else{
			split_k(p,k-siz[ch[p][0]]);
			split(ch[x=p][1],k-siz[ch[p][0]]-len[p],ch[p][1],y);
		}
		pushup(p);
	}
}t;
signed main(){
	_srand(114514);
	scanf("%lld",&n);
	int la=0;
	for(int i=1;i<=n;i++){
		int p,a,b,c,x;
		int o,h;
		scanf("%lld%lld%lld%lld%lld",&p,&a,&b,&c,&x);
		t.split(rt,p,o,h);
		rt=t.merge(o,t.merge(t.newnode(a,b,c,x),h));
		int ans=t.sum[rt].ans();
		printf("%lld\n",ans-la);
		la=ans;
	}
	return 0;
}
```

---


# 树上的毒瘤

## 题目背景

Salamander开心地把一大袋毒瘤带回了家，把他们染上了不同的颜色，并把他们挂在了院子里的树上。


## 题目描述

这棵树上有$n$个节点，由$n-1$条树枝相连。初始时树上都挂了一个毒瘤，颜色为$c_i$。接下来Salamander将会进行$q$个操作。


Salamander有时会修改树上某个点到另外一个点的简单路径上所有毒瘤的颜色。


对于给定的树上**某个点集$S$**，Salamander还定义了某个点的权值：

$$W_i=\sum_{j\in S}T(i,j)$$

其中$T(i,j)$表示$i$到$j$的路径上毒瘤颜色的**段数**，比如$i$到$j$的路径上毒瘤颜色为$1223312$时，颜色段数为$5$。

Salamander对树上的毒瘤们的状态很感兴趣，所以有时会指定树上$m$个节点作为点集，询问这$m$个节点的权值。


## 说明/提示

保证输入数据合法。


对于30%的数据，有$1\leq n,q\leq 1000$，$\sum m\leq 5000$。

对于60%的数据，有$1\leq n,q\leq 20000$，$\sum m\leq 100000$。

对于100%的数据，有$1\leq n,q\leq 100000$，$c_i,y\leq 10^9$，$\sum m\leq 200000$，$m\leq n$。


## 样例 #1

### 输入

```
10 10
708916891 100649777 100649777 544409200 100649777 47435517 47435517 708916891 644811607 544409200 
3 2
7 1
8 1
1 10
3 4
1 5
9 2
1 2
3 6
2 1
6 
2 6
8 10 9 3 2 4 
2 2
7 8 
2 1
5 
2 2
6 10 
2 3
6 1 4 
2 1
7 
1 9 8 100649777
1 7 9 544409200
2 4
10 9 1 2 ```

### 输出

```
1 
13 17 15 11 11 15 
3 3 
1 
5 5 
7 7 7 
1 
4 4 4 4 ```

# 题解

## 作者：Salamander (赞：17)

本来是想着好像可以在虚树上点分治来做一些不是很好计算的东西？

然后本来想出一道在虚树上点分治+FFT来求一下特定长度的路径？结果发现这东西套在虚树上复杂度不对。

然后就出点树形dp不好做的东西……然后由于套了虚树所以可以带修改……然后……

~~然后就变得非常码农~~

然后就有了这个题：树上多次询问，每次给定一些关键点，需要统计出每个关键点到其他关键点的所有路径上的颜色段数之和。

首先是询问的总点数和$n$同阶，马上就能看出是虚树。

然后就是在虚树上统计答案，上点分治。

考虑怎么统计经过当前分治中心的路径对答案的贡献。

对于分治中心的一棵子树，我们现在只统计经过中心的路径的贡献，那么我们可以求出从中心出发进入其他子树的路径的总贡献，然后我们$dfs$这棵子树，某个节点的答案只需要把中心那边的答案接上中心到当前点的那一段路径的贡献即可。这样就可以统计出所有点的答案。对于当前分治中心，它自己的答案要加上从它出发向它所在分治块内的路径的贡献。

在虚树上还要注意，只能统计询问点的答案，有一些询问点的lca也在虚树上但不能给其他询问点算贡献。然后由于虚树上的边带表原树上的一条链，所以虚树上的边权是原树上那条链上的颜色段数。

然后我们再写个树链剖分来求lca、链修改、链查询颜色段数。

然后就没有然后了，~~码吧~~。

复杂度$O((\sum m)\log^2n)$。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

#define lc x<<1
#define rc x<<1|1
#define For(i,_beg,_end) for(int i=(_beg),i##end=(_end);i<=i##end;++i)
#define Rep(i,_beg,_end) for(int i=(_beg),i##end=(_end);i>=i##end;--i)

template<typename T>T Max(const T &x,const T &y){return x<y?y:x;}
template<typename T>T Min(const T &x,const T &y){return x<y?x:y;}
template<typename T>int chkmax(T &x,const T &y){return x<y?(x=y,1):0;}
template<typename T>int chkmin(T &x,const T &y){return x>y?(x=y,1):0;}
template<typename T>void read(T &x){
    T f=1;char ch=getchar();
    for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
    for(x=0;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';
    x*=f;
}

typedef long long LL;
const int maxn=100010,inf=0x7fffffff;
struct edge{
    int to,nxt,len;
}e[maxn<<1];
struct Data{
    int cl,cr,sum;
    Data(){cl=cr=sum=0;}
    Data(int l,int r,int s){cl=l;cr=r;sum=s;}
    friend Data operator+(const Data &x,const Data &y){
        if(!x.cl)return y;
        if(!y.cl)return x;
        return Data(x.cl,y.cr,x.sum+y.sum-(x.cr==y.cl));
    }
}T[maxn<<2];
int n,m,q,num,head[maxn],sum,root,f[maxn],size[maxn];
int c[maxn],dfn[maxn],cnt,tp[maxn];
int anc[maxn],son[maxn],dep[maxn],rnk,pos[maxn],id[maxn];
int sta[maxn],top,h[maxn],sq[maxn],tag[maxn<<2];
LL ans[maxn],tot,all,path;
bool vis[maxn],is[maxn];

void addedge(int,int,int);
void Dfs1(int,int);
void Dfs2(int,int,int);
int Lca(int,int);
void Build(int,int,int);
void pushsame(int,int);
void pushdown(int);
Data Query(int,int,int,int,int);
void Modify(int,int,int,int,int,int);
int Query(int,int);
void Change(int,int,int);

bool comp(int,int);
void Build(void);

void get(int,int);
void get_sum(int,int);
void get_root(int,int);
void Dfs(int,int,int);
void Modify(int,int,int);
void Calc(int);
void Solve(int);

int main(){
    read(n);read(q);
    For(i,1,n) read(c[i]);
    For(i,1,n-1){
        int u,v;
        read(u);read(v);
        addedge(u,v,0);
    }
    Dfs1(1,0);Dfs2(1,0,1);
    Build(1,1,n);
    int op,u,v,col;
    while(q--){
        read(op);
        if(op==1){
            read(u);read(v);read(col);
            Change(u,v,col);
        }
        else{
            read(m);
            For(i,1,m){
                read(h[i]);
                is[h[i]]=true;
                sq[i]=h[i];
            }
            Build();Solve(1);
            For(i,1,m) is[sq[i]]=false;
            For(i,1,m) printf("%lld ",ans[sq[i]]),ans[sq[i]]=0;
            putchar(10);
        }
    }
    return 0;
}

void Calc(int x){
    get(x,0);path=size[x];
    Dfs(x,tot=0,1);all=tot;
    if(is[x]) ans[x]+=tot;
    for(int i=head[x];i;i=e[i].nxt) if(!vis[e[i].to]){
        tot=0;
        Dfs(e[i].to,x,e[i].len+1);
        all-=tot;path-=size[e[i].to];
        Modify(e[i].to,x,e[i].len);
        all+=tot;path+=size[e[i].to];
    }
    vis[x]=true;
}
void Solve(int x){
    Calc(x);
    for(int i=head[x];i;i=e[i].nxt) if(!vis[e[i].to]){
        f[sum=root=0]=inf;
        get_sum(e[i].to,0);
        get_root(e[i].to,0);
        Solve(root);
    }
    vis[x]=false;
}
void Modify(int x,int fa,int lst){
    if(is[x]) ans[x]+=all+1LL*lst*path;
    for(int i=head[x];i;i=e[i].nxt){
        if(e[i].to==fa||vis[e[i].to]) continue;
        Modify(e[i].to,x,lst+e[i].len);
    }
}
void Dfs(int x,int fa,int lst){
    if(is[x]) tot+=lst;
    for(int i=head[x];i;i=e[i].nxt){
        if(e[i].to==fa||vis[e[i].to]) continue;
        Dfs(e[i].to,x,lst+e[i].len);
    }
}
void get(int x,int fa){
    size[x]=is[x];
    for(int i=head[x];i;i=e[i].nxt){
        if(e[i].to==fa||vis[e[i].to]) continue;
        get(e[i].to,x);
        size[x]+=size[e[i].to];
    }
}
void get_sum(int x,int fa){
    sum++;
    for(int i=head[x];i;i=e[i].nxt){
        if(e[i].to==fa||vis[e[i].to]) continue;
        get_sum(e[i].to,x);
    }
}
void get_root(int x,int fa){
    f[x]=0;size[x]=1;
    for(int i=head[x];i;i=e[i].nxt){
        if(e[i].to==fa||vis[e[i].to]) continue;
        get_root(e[i].to,x);
        size[x]+=size[e[i].to];
        chkmax(f[x],size[e[i].to]);
    }
    chkmax(f[x],sum-size[x]);
    if(f[x]<f[root]) root=x;
}

void addedge(int u,int v,int w){
    e[++num].to=v;e[num].len=w;e[num].nxt=head[u];head[u]=num;
    e[++num].to=u;e[num].len=w;e[num].nxt=head[v];head[v]=num;
}
void Dfs1(int x,int fa){
    size[x]=1;dep[x]=dep[fa]+1;
    dfn[x]=++cnt;anc[x]=fa;
    for(int i=head[x];i;i=e[i].nxt) if(e[i].to!=fa){
        Dfs1(e[i].to,x);
        size[x]+=size[e[i].to];
        if(size[e[i].to]>size[son[x]]) son[x]=e[i].to;
    }
}
void Dfs2(int x,int fa,int up){
    tp[x]=up;id[++rnk]=x;pos[x]=rnk;
    if(son[x]) Dfs2(son[x],x,up);
    for(int i=head[x];i;i=e[i].nxt)
        if(e[i].to!=fa&&e[i].to!=son[x])
            Dfs2(e[i].to,x,e[i].to);
}
int Lca(int u,int v){
    int fx=tp[u],fy=tp[v];
    while(fx!=fy){
        if(dep[fx]>dep[fy]) fx=tp[u=anc[fx]];
        else fy=tp[v=anc[fy]];
    }
    return dep[u]<dep[v]?u:v;
}
void Build(int x,int l,int r){
    if(l==r)return T[x]=Data(c[id[l]],c[id[l]],1),void();
    int mid=(l+r)>>1;
    Build(lc,l,mid);Build(rc,mid+1,r);
    T[x]=T[lc]+T[rc];
}
void pushsame(int x,int col){
    tag[x]=col;
    T[x]=Data(col,col,1);
}
void pushdown(int x){
    if(tag[x]){
        pushsame(lc,tag[x]);
        pushsame(rc,tag[x]);
        tag[x]=0;
    }
}
Data Query(int x,int l,int r,int ql,int qr){
    if(l>=ql&&r<=qr)return T[x];
    int mid=(l+r)>>1;pushdown(x);
    if(ql<=mid&&qr>mid)return Query(lc,l,mid,ql,qr)+Query(rc,mid+1,r,ql,qr);
    else if(ql<=mid)return Query(lc,l,mid,ql,qr);
    else return Query(rc,mid+1,r,ql,qr);
}
void Modify(int x,int l,int r,int ql,int qr,int col){
    if(l>=ql&&r<=qr)return pushsame(x,col),void();
    int mid=(l+r)>>1;pushdown(x);
    if(ql<=mid) Modify(lc,l,mid,ql,qr,col);
    if(qr>mid) Modify(rc,mid+1,r,ql,qr,col);
    T[x]=T[lc]+T[rc];
}
int Query(int u,int v){
    Data res;
    int fx=tp[u],fy=tp[v];
    while(fx!=fy){
        res=Query(1,1,n,pos[fx],pos[u])+res;
        fx=tp[u=anc[fx]];
    }
    res=Query(1,1,n,pos[v],pos[u])+res;
    return res.sum-1;
}
void Change(int u,int v,int col){
    int fx=tp[u],fy=tp[v];
    while(fx!=fy){
        if(dep[fx]>dep[fy]){
            Modify(1,1,n,pos[fx],pos[u],col);
            fx=tp[u=anc[fx]];
        }
        else{
            Modify(1,1,n,pos[fy],pos[v],col);
            fy=tp[v=anc[fy]];
        }
    }
    if(dep[u]>dep[v]) swap(u,v);
    Modify(1,1,n,pos[u],pos[v],col);
}

bool comp(int x,int y){return dfn[x]<dfn[y];}
void Build(){
    sort(h+1,h+m+1,comp);
    num=head[sta[top=1]=1]=0;
    For(i,h[1]==1?2:1,m){
        int lca=Lca(h[i],sta[top]);
        if(lca!=sta[top]){
            while(dfn[sta[top-1]]>dfn[lca]){
                addedge(sta[top],sta[top-1],Query(sta[top],sta[top-1]));
                top--;
            }
            if(sta[top-1]!=lca){
                head[lca]=0;
                addedge(sta[top],lca,Query(sta[top],lca));
                sta[top]=lca;
            }
            else addedge(sta[top],lca,Query(sta[top],lca)),top--;
        }
        head[h[i]]=0;
        sta[++top]=h[i];
    }
    For(i,1,top-1) addedge(sta[i+1],sta[i],Query(sta[i+1],sta[i]));
}
```

---

## 作者：pitiless0514 (赞：8)

## 题目大意

一颗 $n$ 个节点的树，每个点都有自己的权值 $c$ 。进行 $q$ 次操作，操作有两种。

一种是改变两个节点路径之间节点的权值。

一种是查询给定点集中，所有点到其他点的颜色段数和。

$n , q \leq 10^5 $ , $\sum m \leq 2\times 10^5$


## 题解

[在博客园获得更佳阅读体验](https://www.cnblogs.com/orzpls/p/15170015.html)

又是超级难写题。

个人认为这道题的思路其实是很简单的。

首先你要会求颜色段数，这个很简单对吧，就直接树剖加上线段树就完事了，也就是 [这道题](https://www.luogu.com.cn/problem/P2486) 。

然后会了这个我们就可以快速求出树上任意两点之间的颜色段数。

首先这题还是老套路的虚树模式，直接先建出虚树来。

考虑怎么做题，我们考虑是肯定要设立一个 dp 。

但是现在没啥思路，我们就去看看建出来的虚树。

这个树你肯定要给他赋一个边权但是边权怎么赋值？

你考虑下图。

我们希望做到的是点 $1$ 到点 $2$ 的边权加上点 $2$ 到点 $3$ 的边权之间是有某种关系的，最好是能相等的。

但是因为可能父亲的颜色段与父亲的父亲产生冲突，这个是会有影响的。

那我们直接不管父亲的颜色段，将边权设为两点颜色段数减去 $1$ 。

最后需要用的时候我们在加上 $1$ 就好了。

然后这个东西就很对了。

那么一条路径的权值就是边权和加上 $1$ 。

然后你这个时候在统计路径就变成了一个经典的换根 dp 。

然后你考虑你一个点向 $m$ 个点找路径那你就加上 $m$ 就好了。

然后就用树剖加上换根 dp 写完了这道题。

![](https://z3.ax1x.com/2021/08/25/hZsmo4.png)

```cpp
const int N = 3e5;
int n, q, m, num, cnt, c[N], siz[N], dep[N], f[N], son[N], top[N];
int dfn[N], col[N], dfn2[N], tot, aske[N], mark[N], id[N];
vector<int> ver[N], p[N];
void dfs1(int x, int fa) {
  siz[x] = 1;
  dfn2[x] = ++tot;
  dep[x] = dep[fa] + 1;
  f[x] = fa;
  for (int i = 0; i < ver[x].size(); i++) {
    int to = ver[x][i];
    if (to == fa)
      continue;
    dfs1(to, x);
    siz[x] += siz[to];
    if (siz[to] > siz[son[x]])
      son[x] = to;
  }
}
void dfs2(int now, int x) {
  top[now] = x;
  dfn[now] = ++cnt;
  col[cnt] = c[now];
  if (son[now])
    dfs2(son[now], x);
  for (int i = 0; i < ver[now].size(); i++) {
    int to = ver[now][i];
    if (to == f[now] || to == son[now])
      continue;
    dfs2(to, to);
  }
}
int LCA(int x, int y) {
  while (top[x] != top[y]) {
    if (dep[top[x]] <= dep[top[y]])
      y = f[top[y]];
    else
      x = f[top[x]];
  }
  return dep[x] < dep[y] ? x : y;
}
int s[N], tag[N];
int ls(int p) { return p << 1; }
int rs(int p) { return p << 1 | 1; }
void push_up(int p, int mid) {
  s[p] = s[ls(p)] + s[rs(p)];
  if (col[mid] == col[mid + 1])
    s[p]--;
}
void pushdown(int p, int mid) {
  tag[ls(p)] = tag[rs(p)] = tag[p];
  col[mid] = col[mid + 1] = tag[p];
  s[ls(p)] = 1, s[rs(p)] = 1;
  tag[p] = 0;
}
void build(int p, int l, int r) {
  if (l == r) {
    s[p] = 1;
    return;
  }
  int mid = (l + r) >> 1;
  build(ls(p), l, mid), build(rs(p), mid + 1, r);
  push_up(p, mid);
}
void update(int p, int l, int r, int nx, int ny, int k) {
  if (nx <= l and r <= ny) {
    s[p] = 1;
    col[l] = col[r] = tag[p] = k;
    return;
  }
  int mid = (l + r) >> 1;
  if (tag[p])
    pushdown(p, mid);
  if (nx <= mid)
    update(ls(p), l, mid, nx, ny, k);
  if (ny > mid)
    update(rs(p), mid + 1, r, nx, ny, k);
  push_up(p, mid);
}
int ask(int p, int l, int r, int nx, int ny) {
  if (nx <= l && r <= ny)
    return s[p];
  int mid = (l + r) >> 1, ans = 0;
  if (tag[p])
    pushdown(p, mid);
  if (nx <= mid)
    ans = ask(ls(p), l, mid, nx, ny);
  if (ny > mid)
    ans += ask(rs(p), mid + 1, r, nx, ny);
  if (nx <= mid && ny > mid) {
    if (col[mid] == col[mid + 1])
      ans--;
  }
  return ans;
}
void addtree(int x, int y, int val) {
  while (top[x] != top[y]) {
    if (dep[top[x]] < dep[top[y]])
      swap(x, y);
    update(1, 1, n, dfn[top[x]], dfn[x], val);
    x = f[top[x]];
  }
  if (dep[x] > dep[y])
    swap(x, y);
  update(1, 1, n, dfn[x], dfn[y], val);
}
int asktree(int x, int y) {
  int ans = 0, u = x, v = y;
  while (top[x] != top[y]) {
    if (dep[top[x]] < dep[top[y]])
      swap(x, y);
    ans = (ans + ask(1, 1, n, dfn[top[x]], dfn[x]));
    x = f[top[x]];
  }
  if (dep[x] > dep[y])
    swap(x, y);
  ans = (ans + ask(1, 1, n, dfn[x], dfn[y]));
  while (top[u] != top[v]) {
    if (dep[top[u]] < dep[top[v]])
      swap(u, v);
    if (col[dfn[top[u]]] == col[dfn[f[top[u]]]])
      --ans;
    u = f[top[u]];
  }
  return ans;
}
int cmp(int x, int y) { return dfn2[x] < dfn2[y]; }
int dp[N], dp2[N], sz[N];
void get1(int x) {
  if (mark[x])
    sz[x] = 1;
  else
    sz[x] = 0;
  dp[x] = 0;
  for (int i = 0; i < p[x].size(); i++) {
    int to = p[x][i];
    int val = asktree(to, x) - 1;
    get1(to);
    sz[x] += sz[to];
    dp[x] += dp[to] + val * sz[to];
  }
}
void get2(int x) {
  for (int i = 0; i < p[x].size(); i++) {
    int to = p[x][i];
    int val = asktree(to, x) - 1;
    dp2[to] = dp2[x] + (m - 2 * sz[to]) * val;
    get2(to);
  }
}
signed main() {
  n = read(), q = read();
  for (int i = 1; i <= n; i++)
    c[i] = read();
  for (int i = 1; i < n; i++) {
    int a = read(), b = read();
    ver[a].push_back(b);
    ver[b].push_back(a);
  }
  dfs1(1, 0);
  dfs2(1, 1);
  build(1, 1, n);
  while (q--) {
    int op = read();
    if (op == 1) {
      int u = read(), v = read(), y = read();
      addtree(u, v, y);
    } else {
      m = read();
      for (int i = 1; i <= m; i++)
        aske[i] = read(), mark[aske[i]] = 1, id[i] = aske[i];
      sort(aske + 1, aske + m + 1, cmp);
      num = m;
      for (int i = 2; i <= m; i++) {
        int lca = LCA(aske[i], aske[i - 1]);
        if (lca != aske[i] && lca != aske[i - 1])
          aske[++num] = lca;
      }
      sort(aske + 1, aske + num + 1);
      num = unique(aske + 1, aske + num + 1) - (aske + 1);
      sort(aske + 1, aske + num + 1, cmp);
      for (int i = 2; i <= num; i++) {
        int lca = LCA(aske[i], aske[i - 1]);
        p[lca].push_back(aske[i]);
      }
      get1(aske[1]);
      dp2[aske[1]] = dp[aske[1]];
      get2(aske[1]);
      for (int i = 1; i <= m; i++)
        write(dp2[id[i]] + m), putc(' ');
      putc('\n');
      for (int i = 1; i <= num; i++)
        p[aske[i]].clear(), mark[aske[i]] = 0, dp2[aske[i]] = 0,
                            dp[aske[i]] = 0, sz[aske[i]] = 0, id[i] = 0;
    }
  }
  flush();
  return 0;
}

```


---

## 作者：洛苡hh (赞：6)

树上问题大礼包！没有技巧全是套路！虚树+树剖+点分治。

~~说服自己开始写代码的时间比想题时间还长……调到最后代码长度一度8k+……~~

相关题目：
- [点分治板子](https://www.luogu.com.cn/problem/P3806)
- [虚树板子](https://www.luogu.com.cn/problem/P2495)
- [树剖维护颜色段数](https://www.luogu.com.cn/problem/P2486)（比原题稍弱，原题是路径这题是链）

首先看到多组询问且数据总规模不大，直接建虚树。

虚树上的边权是原树上链的颜色段数，直接树剖求即可，线段树上维护区间内颜色段数和左右端点颜色，注意树剖的时候合并顺序别反了，边权是颜色段数-1，最后统计答案的时候我们再+1，因为要考虑边拼成路径时链接处会有重复贡献。

然后问题变成了树上统计点对之间的贡献，这种形式很明显的点分治。

具体而言，对于当前分治中心 $rt$ ，我们只统计跨分治中心的贡献，即对于每棵子树，计算子树内关键点数量和关键点到分治中心的边权和，于是我们可以得到分治中心内的总关键点数和总边权和，进而求出子树外的关键点数和边权和，再统计一遍答案，设 $x$ 为一个关键点，其答案为 $到分治中心边权和 \times 子树外关键点数量 + 子树外边权和$ 即 $x$ 这个点和子树外所有关键点的路径边权和。

至于修改操作，反正都有树剖了，直接维护即可。

复杂度 $O((\sum m) \log ^2 n)$，瓶颈在树剖上。

```cpp
#include<bits/stdc++.h>
#define MAXN 100005
#define mod 998244353
#define int long long
#define look_memory cerr<<abs(&M2-&M1)/1024.0/1024<<'\n'
#define look_time cerr<<(clock()-Time)*1.0/CLOCKS_PER_SEC<<'\n'
using namespace std;

inline int read(){
    int x=0;
    int f=1;
    char c=getchar();
    while(c<'0' || c>'9'){
    	if(c=='-') f=-1;
        c=getchar();
    }
    while(c>='0' && c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}

bool M1;
int n,m;
int c[MAXN];
vector<int> edge[MAXN];
int dep[MAXN],sz[MAXN],fa[MAXN],son[MAXN],top[MAXN],dfn[MAXN],ww[MAXN],wt[MAXN],tot;
int head[MAXN],nxt[MAXN*5],to[MAXN*5],val[MAXN*5],vcnt;
int q[MAXN],tq[MAXN],a[MAXN*2],k;
stack<int> st;
bool mark[MAXN],vis[MAXN];
int SZ,rt;
struct po{
	int sum,cnt;
};
vector<po> vec;
int ans[MAXN];

void dfs1(int x,int ff){
	dep[x]=dep[ff]+1;
	sz[x]=1;
	fa[x]=ff;
	for(auto y:edge[x]){
		if(y==ff) continue;
		dfs1(y,x);
		sz[x]+=sz[y];
		if(sz[y]>sz[son[x]]) son[x]=y;
	}
}

void dfs2(int x,int ff,int tp){
	top[x]=tp;
	dfn[x]=++tot;
	ww[tot]=c[x];
	if(son[x]) dfs2(son[x],x,tp);
	for(auto y:edge[x]){
		if(y==ff || y==son[x]) continue;
		dfs2(y,x,y);
	}
}

int LCA(int a,int b){
	while(top[a]!=top[b]){
		if(dep[top[a]]<dep[top[b]]) swap(a,b);
		a=fa[top[a]];
	}
	if(dep[a]>dep[b]) swap(a,b);
	return a;
}

struct node{
	int l,r;
	int val,cl,cr,tag;
	node(){
		val=cl=cr=tag=0;
	}
	friend node operator + (const node x,const node y){
		node res;
		res.l=x.l;res.r=y.r;
		res.cl=x.cl;res.cr=y.cr;
		res.val=x.val+y.val-(x.cr==y.cl);
		return res;
	}
}t[MAXN<<2];
struct segment_tree{
	#define ls k<<1
	#define rs k<<1|1
	void pushup(int k){
		t[k]=t[ls]+t[rs];
	}
	void pushtag(int k,int v){
		t[k].val=1;
		t[k].cl=t[k].cr=v;
		t[k].tag=v;
	}
	void pushdown(int k){
		if(t[k].tag){
			pushtag(ls,t[k].tag);
			pushtag(rs,t[k].tag);
			t[k].tag=0;
		}
	}
	void build(int k,int l,int r){
		t[k].l=l;t[k].r=r;
		if(l==r){
			t[k].val=1;
			t[k].cl=t[k].cr=ww[l];
			return;
		}
		int mid=(l+r)>>1;
		build(ls,l,mid);
		build(rs,mid+1,r); 
		pushup(k);
	}
	void update(int k,int l,int r,int v){
		if(t[k].l>=l && t[k].r<=r){
			pushtag(k,v);
			return;
		}
		pushdown(k);
		int mid=(t[k].l+t[k].r)>>1;
		if(mid>=l) update(ls,l,r,v);
		if(mid<r) update(rs,l,r,v);
		pushup(k);
	}
	node query(int k,int l,int r){
		if(t[k].l>=l && t[k].r<=r){
			return t[k];
		}
		pushdown(k);
		int mid=(t[k].l+t[k].r)>>1;
		if(mid>=r) return query(ls,l,r);
		else if(mid<l) return query(rs,l,r);
		else return query(ls,l,r)+query(rs,l,r);
	}
	#undef ls
	#undef rs
}ST;

void update(int a,int b,int v){
	while(top[a]!=top[b]){
		if(dep[top[a]]<dep[top[b]]) swap(a,b);
		ST.update(1,dfn[top[a]],dfn[a],v);
		a=fa[top[a]];
	}
	if(dep[a]>dep[b]) swap(a,b);
	ST.update(1,dfn[a],dfn[b],v);
}

int query(int a,int b){
	node res;
	while(top[a]!=top[b]){
		res=ST.query(1,dfn[top[a]],dfn[a])+res;
		a=fa[top[a]];
	}
	res=ST.query(1,dfn[b],dfn[a])+res;
	return res.val;
}

void add(int u,int v,int w){
	nxt[++vcnt]=head[u];
	head[u]=vcnt;
	to[vcnt]=v;
	val[vcnt]=w;
	st.push(u);
}

bool cmp(int aa,int bb){
	return dfn[aa]<dfn[bb];
}

int build(){
	sort(q+1,q+1+k,cmp);
	int cnt=0;
	for(int i=1;i<k;i++){
		a[++cnt]=q[i];
		a[++cnt]=LCA(q[i],q[i+1]);
	}
	a[++cnt]=q[k];
	sort(a+1,a+1+cnt,cmp);
	cnt=unique(a+1,a+1+cnt)-a-1;
	for(int i=1;i<cnt;i++){
		int lca=LCA(a[i],a[i+1]);
		int vl=query(a[i+1],lca)-1;//边权-1 
		add(lca,a[i+1],vl);
		add(a[i+1],lca,vl);
	}
	return cnt;
}

void get_rt(int x,int ff){
	sz[x]=1;
	wt[x]=0;
	for(int i=head[x];i;i=nxt[i]){
		int y=to[i];
		if(y==ff || vis[y]) continue;
		get_rt(y,x);
		sz[x]+=sz[y];
		wt[x]=max(wt[x],sz[y]); 
	}
	wt[x]=max(wt[x],SZ-sz[x]);
	if(wt[x]<wt[rt]) rt=x;
}

void dfs(int x,int ff,int dis,int &sm,int &ct){
	if(mark[x]){
		sm+=dis;
		ct++;
	}
	for(int i=head[x];i;i=nxt[i]){
		int y=to[i];
		int w=val[i];
		if(y==ff || vis[y]) continue;
		dfs(y,x,dis+w,sm,ct);
	}
}

void calc(int x,int ff,int dis,int sum,int cnt){
	if(mark[x]){
		ans[x]+=dis*cnt+sum;
	}
	for(int i=head[x];i;i=nxt[i]){
		int y=to[i];
		int w=val[i];
		if(y==ff || vis[y]) continue;
		calc(y,x,dis+w,sum,cnt);
	}
}

void solve(int x){
	int sum=0,cnt=0;
	vec.clear();
	for(int i=head[x];i;i=nxt[i]){
		int y=to[i];
		int w=val[i]; 
		if(vis[y]) continue;
		int sm=0,ct=0;
		dfs(y,x,w+1,sm,ct);//统计答案时+1 
		vec.push_back((po){sm,ct});
		sum+=sm;
		cnt+=ct;
	}
	if(mark[x]){ 
		cnt++;
		sum++;//记得要算自己和自己的贡献 
		ans[x]+=sum;
	}
	for(int i=head[x],j=0;i&&j<vec.size();i=nxt[i],j++){
		int y=to[i];
		int w=val[i];
		if(vis[y]){
			j--;
			continue;
		}
		sum-=vec[j].sum;
		cnt-=vec[j].cnt;
		calc(y,x,w,sum,cnt);
		sum+=vec[j].sum;
		cnt+=vec[j].cnt;
	}
}

void divide(int x){
	vis[x]=1;
	solve(x);
	int Sz=SZ;
	for(int i=head[x];i;i=nxt[i]){
		int y=to[i];
		if(vis[y]) continue;
		SZ=sz[x]>sz[y] ? sz[y] : Sz-sz[x];
		rt=0;
		get_rt(y,0);
		divide(y); 
	}
	vis[x]=0;
	head[x]=0;
	mark[x]=0;
}

void clear(){
	while(!st.empty()){
		int t=st.top();
		st.pop();
		head[t]=0;
	}
	vcnt=0;
	rt=0;
	for(int i=1;i<=k;i++){
		mark[q[i]]=0;
		ans[q[i]]=0;
	}
}

bool M2;

signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	int Time=clock();
	n=read();m=read();
	for(int i=1;i<=n;i++){
		int col=read();
		c[i]=col;
	}
	int u,v;
	for(int i=1;i<n;i++){
		u=read();v=read();
		edge[u].push_back(v);
		edge[v].push_back(u);
	}
	dfs1(1,0);
	dfs2(1,0,1);
	ST.build(1,1,n);
	wt[0]=n;
	int op,w;
	while(m--){
		op=read();
		if(op==1){
			u=read();v=read();w=read();
			update(u,v,w);
		}else{
			k=read();
			for(int i=1;i<=k;i++){
				tq[i]=q[i]=read();
				mark[q[i]]=1;
			}
			q[++k]=1;
			SZ=build();
			rt=0;
			get_rt(1,0);
			divide(rt);
			for(int i=1;i<k;i++){
				printf("%lld ",ans[tq[i]]);
			}puts("");
			clear();
		}
	}
	look_memory;
	look_time;
	return 0;
}
```

---

## 作者：5k_sync_closer (赞：5)

树上问题全家桶。

以给出的点集建出虚树，然后问题转化为对每个关键点，求其到其他关键点的虚树链上颜色段数之和。

注意虚树的一条边是原树的一条链，所以虚树某条链上的颜色段数并不是简单的虚树上这些点形成的颜色段数。

所以令虚树的边权为其在原树上对应的链上的颜色段数 $-1$，则此时虚树某条链上的颜色段数为其边权和 $+1$。

需要维护链推平，建虚树时需要查询链上颜色段数 $-1$ 作为边权，树剖套线段树维护之。

然后问题转化为对每个关键点，求其到其他关键点的虚树链边权和 $+1$ 之和，虚树上点分治维护之。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
struct H
{
    struct E
    {
        int v, w, t;
    } e[200050];
    int c, h[100050];
    void A(int u, int v, int w)
    {
        e[++c] = {v, w, h[u]};
        h[u] = c;
    }
} T, V;
bool e[100050], E[100050];
long long A, G[100050];
int n, m, p, o, r, l, w[100050], g[100050], h[100050], a[100050], z[100050], d[100050], f[100050],
    s[100050], t[100050], b[100050], k[100050], S[100050], P[100050], Z[100050], W[100050];
bool C(int x, int y) { return b[x] < b[y]; }
void X(int u)
{
    s[u] = 1;
    for (int i = T.h[u], v; i; i = T.e[i].t)
        if (!d[v = T.e[i].v])
        {
            d[v] = d[f[v] = u] + 1;
            X(v);
            s[u] += s[v];
            if (s[v] > s[z[u]])
                z[u] = v;
        }
}
void Y(int u, int g)
{
    t[k[b[u] = ++p] = u] = g;
    if (z[u])
        Y(z[u], g);
    for (int i = T.h[u],
             v;
         i; i = T.e[i].t)
        if ((v = T.e[i].v) != f[u] && v != z[u])
            Y(v, v);
}
int L(int x, int y)
{
    while (t[x] != t[y])
    {
        if (d[t[x]] < d[t[y]])
            swap(x, y);
        x = f[t[x]];
    }
    return d[x] < d[y] ? x : y;
}
struct N
{
    int p, q, v;
};
struct O
{
    N v;
    int z;
} R[100050 << 2];
N operator+(N a, N b) { return {a.p, b.q, a.v + b.v - (a.q == b.p)}; }
void U(int p) { R[p].v = R[p << 1].v + R[p << 1 | 1].v; }
void F(int p, int x)
{
    R[p].z = R[p].v.p = R[p].v.q = x;
    R[p].v.v = 1;
}
void D(int p)
{
    if (~R[p].z)
        F(p << 1, R[p].z), F(p << 1 | 1, R[p].z), R[p].z = -1;
}
void B(int s, int t, int p)
{
    R[p].z = -1;
    if (s == t)
        return (void)(R[p].v.p = R[p].v.q = a[k[s]], R[p].v.v = 1);
    int m = s + t >> 1;
    B(s, m, p << 1);
    B(m + 1, t, p << 1 | 1);
    U(p);
}
void M(int l, int r, int x, int s, int t, int p)
{
    if (l <= s && t <= r)
        return F(p, x);
    D(p);
    int m = s + t >> 1;
    if (l <= m)
        M(l, r, x, s, m, p << 1);
    if (r > m)
        M(l, r, x, m + 1, t, p << 1 | 1);
    U(p);
}
N Q(int l, int r, int s, int t, int p)
{
    if (l <= s && t <= r)
        return R[p].v;
    D(p);
    int m = s + t >> 1;
    if (l <= m && r > m)
        return Q(l, r, s, m, p << 1) + Q(l, r, m + 1, t, p << 1 | 1);
    if (l <= m)
        return Q(l, r, s, m, p << 1);
    if (r > m)
        return Q(l, r, m + 1, t, p << 1 | 1);
}
void M(int u, int v, int x)
{
    while (t[u] != t[v])
    {
        if (d[t[u]] < d[t[v]])
            swap(u, v);
        M(b[t[u]], b[u], x, 1, n, 1);
        u = f[t[u]];
    }
    if (d[u] > d[v])
        swap(u, v);
    M(b[u], b[v], x, 1, n, 1);
}
int Q(int u, int v)
{
    N p, q;
    bool U = 0, V = 0;
    while (t[u] != t[v])
        if (d[t[u]] > d[t[v]])
            p = U ? Q(b[t[u]], b[u], 1, n, 1) + p : (U = 1, Q(b[t[u]], b[u], 1, n, 1)), u = f[t[u]];
        else
            q = V ? Q(b[t[v]], b[v], 1, n, 1) + q : (V = 1, Q(b[t[v]], b[v], 1, n, 1)), v = f[t[v]];
    if (d[u] > d[v])
        p = U ? Q(b[v], b[u], 1, n, 1) + p : (U = 1, Q(b[v], b[u], 1, n, 1));
    else
        q = V ? Q(b[u], b[v], 1, n, 1) + q : (V = 1, Q(b[u], b[v], 1, n, 1));
    if (!U)
        return q.v;
    if (!V)
        return p.v;
    swap(p.p, p.q);
    return (p + q).v;
}
void X(int u, int k, int t)
{
    S[u] = 1;
    P[u] = 0;
    for (int i = V.h[u], v; i; i = V.e[i].t)
        if (!E[v = V.e[i].v] && v != k)
            X(v, u, t), S[u] += S[v], P[u] = max(P[u], S[v]);
    if (P[r] > (P[u] = max(P[u], t - S[u])))
        r = u;
}
void Y(int u, int k, int)
{
    if (e[u])
        Z[l++] = u;
    for (int i = V.h[u], v; i; i = V.e[i].t)
        if (!E[v = V.e[i].v] && v != k)
            W[v] = W[u] + V.e[i].w, Y(v, u, 0);
}
void Q(int u, int k, int)
{
    E[u] = 1;
    o = e[u];
    for (int i = V.h[u], v; i; i = V.e[i].t)
        if (!E[v = V.e[i].v] && v != k)
        {
            W[v = V.e[i].v] = V.e[i].w;
            Y(v, u, l = 0);
            o += l;
            for (int j = 0; j < l; ++j)
                A += W[Z[j]];
        }
    if (e[u])
        G[u] += A + o;
    for (int i = V.h[u], v; i; i = V.e[i].t)
        if (!E[v = V.e[i].v] && v != k)
        {
            W[v = V.e[i].v] = V.e[i].w;
            Y(v, u, l = 0);
            o -= l;
            for (int j = 0; j < l; ++j)
                A -= W[Z[j]];
            for (int j = 0; j < l; ++j)
                G[Z[j]] += A + o * (W[Z[j]] + 1ll);
            o += l;
            for (int j = 0; j < l; ++j)
                A += W[Z[j]];
        }
    A = o = 0;
    for (int i = V.h[u], v; i; i = V.e[i].t)
        if (!E[v = V.e[i].v] && v != k)
            r = 0, X(v, u, s[v]), Q(r, u, 0);
}
int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i)
        scanf("%d", a + i);
    for (int i = 1, u, v; i < n; ++i)
        scanf("%d%d", &u, &v), T.A(u, v, 1), T.A(v, u, 1);
    X(d[1] = 1);
    Y(1, 1);
    B(1, n, 1);
    for (int i = 0, o, k, c = 0, u, v, x; i < m; ++i)
    {
        scanf("%d", &o);
        if (o & 1)
            scanf("%d%d%d", &u, &v, &x), M(u, v, x);
        else
        {
            scanf("%d", &k);
            for (int j = 0; j < c; ++j)
                V.h[h[j]] = e[h[j]] = E[h[j]] = G[h[j]] = 0;
            for (int j = V.c = c = 0; j < k; ++j)
                scanf("%d", g + j), e[w[j] = g[j]] = 1;
            sort(g, g + k, C);
            h[c++] = g[0];
            for (int j = 1; j < k; ++j)
                h[c++] = L(g[j], g[j - 1]), h[c++] = g[j];
            sort(h, h + c, C);
            c = unique(h, h + c) - h;
            for (int j = 1, l; j < c; ++j)
                l = L(h[j], h[j - 1]), V.A(l, h[j], Q(l, h[j]) - 1), V.A(h[j], l, Q(l, h[j]) - 1);
            P[r = 0] = 1e9;
            X(h[0], 0, c);
            Q(r, 0, 0);
            for (int j = 0; j < k; ++j)
                printf("%lld ", G[w[j]]);
            puts("");
        }
    }
    return 0;
}
```


写 + 调全程花费 2h。

题如其名，码量约等于半个猪国杀。

![](https://cdn.luogu.com.cn/upload/image_hosting/fd9jgewy.png)


![](https://cdn.luogu.com.cn/upload/image_hosting/3ue86yzg.png)

---

## 作者：lingfunny (赞：3)

## description

给你一棵树，每个节点都有颜色，有两种操作：

1. 指定其中 $k$ 个节点，对于每个节点，计算它 **到每个给定的节点的路径上颜色的段数** 的和。
2. 修改一条路径上所有节点的颜色。

## solution

首先看描述就可以识算法了。

看到 $\sum k \le 2\times10^5$ 显然是建虚树出来。

看到修改路径上的颜色，显然可以用树剖维护。

建虚树时，刚好可以利用树剖得到两个点之间的所有颜色。

然后问题是建虚树出来之后考虑怎么做。

首先看到**路径上**这三个字，可以考虑点分治。

### 点分治做法

描述约定：

1. 对于题目中给出的 $k$ 个点，我们叫他关键点。
2. 对于虚树上的点，叫它虚树点。（显然关键点都是虚树点）

然后点分治步骤：

1. 找到树重心，将其作为根节点
2. 依次遍历根节点的每棵子树，计算子树中所有关键点到根节点的路径中颜色的段数，并 `sum += ColorCount, nodeCount += 1`。
3. 依次遍历根节点的每棵子树
	1. 删除这棵子树的贡献
    2. 计算每个关键点的答案（我们将经过根节点的答案拆分成两段，一段从根根节点到其它关键点，一段从当前点到根节点，答案显然应该是： $\text{子树外节点数} \times \text{当前关键点到根节点路径颜色的段数} + \text{sum}$
    3. 加回子树贡献
4. 依次递归每棵子树

除了点分治以外，还可以考虑**虚树题目的常用解法**：树形 dp。

### 树形 dp 做法

考虑下面这棵树（样例）：

![](https://cdn.luogu.com.cn/upload/image_hosting/gukp1l53.png)

首先考虑有根树的做法。

以节点 $u$ 为根，考虑虚树上这样一条边 $(u, v)$：

对于子树 $v$ 中的每个点，到 $u$ 的路径都必须经过 $v$，所以子树 $v$ 中的每个点到 $u$ 的贡献都会多上 $\operatorname{Count}(u, v) - 1$，其中 $\operatorname{Count}(u, v)$ 表示 $u$ 到 $v$ 的路径上（包含 $u,v$）颜色段数。

记 $f_u$ 为以 $u$ 为根的子树的答案，$c_u$ 为以 $u$ 为根的子树中关键点的个数，得到下面这个式子：

$$f_u=[\text{u 是关键点}] + \sum_{(u,v)\in E}f_v + c_v\times(\operatorname{Count}(u,v)-1)$$

对于之后的换根，同样按照这个式子再减去子树贡献就行（记 $p$ 为节点父亲）：

$$f_u = f_p - c_u\times(\operatorname{Count}(p,u)-1)+(k-c_u)\times(\operatorname{Count}(p,u)-1)$$

~~想展开就展开吧，总之我懒得展开~~ 不过不展开也有个好处，就是逻辑更加清晰。

这个做法贴个 Code：

```cpp
/*
1. 修改一条路径上所有节点的颜色
2. 计算所有节点到其他节点的颜色总数
*/
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;
#define rep(i, s, e) for(int i=s;i<=e;++i)
#define pb push_back
const int mxn = 1e5+10;

int n, q, c[mxn], dfn[mxn], ed[mxn], map[mxn];
vector <int> G[mxn];

struct node {
	int lC, rC, sum;
	inline node operator + (const node& rhs) const { 
		if(!rhs.sum) return *this; if(!sum) return rhs;
		return (node) {lC, rhs.rC, sum + rhs.sum - (rC == rhs.lC)};
	}
	inline node reverse() { swap(lC, rC); return *this; }
};
const node E0 = {0, 0, 0};
#define lc (o<<1)
#define rc (o<<1|1)
#define mid ((L+R)>>1)
struct Segtr {
	node s[mxn<<2]; int tag[mxn<<2];
	inline void cover(int o, int tg) { s[o] = {tg, tg, 1}; tag[o] = tg; }
	inline void psdn(int o) { if(tag[o]) { cover(lc, tag[o]), cover(rc, tag[o]); tag[o] = 0; } }
	inline void psup(int o) { s[o] = s[lc] + s[rc]; }
	void build(int o=1, int L=1, int R=n) {
		if(L == R) return (void)(s[o] = {c[map[L]], c[map[L]], 1});
		build(lc, L, mid); build(rc, mid+1, R); psup(o);
	}
	node query(int cl, int cr, int o=1, int L=1, int R=n) {
		if(cl <= L && R <= cr) return s[o]; psdn(o);
		node res = (cl <= mid ? query(cl, cr, lc, L, mid) : E0) + (cr > mid ? query(cl, cr, rc, mid+1, R) : E0);
		return res;
	}
	void set(int cl, int cr, int p, int o=1, int L=1, int R=n) {
		if(cl <= L && R <= cr) return cover(o, p); psdn(o);
		if(cl <= mid) set(cl, cr, p, lc, L, mid);
		if(cr > mid) set(cl, cr, p, rc, mid+1, R); psup(o);
	}
};
#undef lc
#undef rc
#undef mid

struct tr_cut {
	int sz[mxn], son[mxn], fa[mxn], dep[mxn], dfc, top[mxn];
	Segtr T;
	void dfs1(int u, int fat) {
		fa[u] = fat; dep[u] = dep[fat] + 1; sz[u] = 1;
		for(auto v: G[u]) if(v != fat) {
			dfs1(v, u); sz[u] += sz[v]; if(sz[v] > sz[son[u]]) son[u] = v;
		}
	}
	void dfs2(int u) {
		dfn[u] = ++dfc; map[dfc] = u;
		if(son[u]) { top[son[u]] = top[u]; dfs2(son[u]); }
		for(auto v: G[u]) if(v != fa[u] && v != son[u]) { top[v] = v; dfs2(v); }
		ed[u] = dfc;
	}
	inline int lca(int u, int v) {
		while(top[u] != top[v]) dep[top[u]] > dep[top[v]] ? u = fa[top[u]] : v = fa[top[v]];
		return dep[u] > dep[v] ? v : u;
	}
	inline void modify(int u, int v, int p) {
		while(top[u] != top[v]) {
			if(dep[top[u]] < dep[top[v]]) swap(u, v);
			T.set(dfn[top[u]], dfn[u], p);
			u = fa[top[u]];
		}
		if(dep[u] > dep[v]) swap(u, v);
		T.set(dfn[u], dfn[v], p);
	}
	inline node query(int u, int v) {
		// 从浅到深
		if(dep[u] > dep[v]) swap(u, v);
		node res = E0;
		while(top[v] != top[u]) {
			res = T.query(dfn[top[v]], dfn[v]) + res;
			v = fa[top[v]];
		}
		if(u != v) res = T.query(dfn[u]+1, dfn[v]) + res;
		return res;
	}
	inline void init() { dfs1(1, 0); top[1] = 1; dfs2(1); T.build(); }
} cut;
inline bool cmp(int x, int y) { return dfn[x] < dfn[y]; }
struct fake_tree {
	int pt[mxn<<1], m, M, tot, key[mxn], stk[mxn], top, sz[mxn], f[mxn], fa[mxn], ask[mxn];
	struct edge { int v; node w; };
	vector <edge> G[mxn]; node s[mxn];
	inline void init(int GETIN) {
		m = M = GETIN;
		rep(i, 1, m) { int x; scanf("%d", &x); pt[i] = ask[i] = x; key[x] = 2; }
		if(!key[1]) key[1] = 1, pt[++M] = 1;
		sort(pt + 1, pt + M + 1, cmp);
		tot = M;
		rep(i, 2, M) {
			int C = cut.lca(pt[i], pt[i-1]);
			if(!key[C]) key[C] = 1, pt[++tot] = C;
		}
		sort(pt + 1, pt + tot + 1, cmp);
		stk[top = 1] = 1;
		rep(i, 1, tot) c[pt[i]] = cut.T.query(dfn[pt[i]], dfn[pt[i]]).lC;
		#define T (stk[top]) 
		rep(i, 2, tot) {
			int cur = pt[i];
			while(dfn[cur] > ed[T]) --top; node w = cut.query(T, cut.fa[cur]);
			G[T].pb({cur, w}); stk[++top] = pt[i];
		}
		#undef T
	}
	void dfs1(int u, int fat) {
		s[u] = {c[u], c[u], 1}; fa[u] = fat; f[u] = sz[u] = (key[u] == 2);
		for(auto e: G[u]) {
			dfs1(e.v, u); sz[u] += sz[e.v];
			f[u] += f[e.v] + sz[e.v] * ( (s[u] + e.w + s[e.v]).sum - 1);
		}
	}
	void dfs2(int u, node from) {
		if(fa[u]) f[u] = f[fa[u]] - sz[u] * (from.sum - 1) + (m - sz[u]) * (from.sum - 1);
		for(auto e: G[u]) dfs2(e.v, s[u] + e.w + s[e.v]);
	}
	inline void solve() {
		dfs1(1, 0); dfs2(1, E0);
		rep(i, 1, m) printf("%d ", f[ask[i]]); puts("");
		rep(i, 1, tot) {
			int cur = pt[i]; G[cur].clear(); s[cur] = E0;
			key[cur] = f[cur] = fa[cur] = sz[cur] = ask[i] = pt[i] = 0;
		}
	}
} sol;

int main() {
	scanf("%d%d", &n, &q);
	rep(i, 1, n) scanf("%d", c+i);
	rep(i, 2, n) {
		int u, v; scanf("%d%d", &u, &v);
		G[u].pb(v); G[v].pb(u);
	}
	cut.init();
	while(q--) {
		int op; scanf("%d", &op);
		if(op&1) {
			int u, v, w; scanf("%d%d%d", &u, &v, &w);
			cut.modify(u, v, w);
		} else {
			int m; scanf("%d", &m); sol.init(m); sol.solve();
		}
	}
	return 0;
}
```

---

## 作者：Wolfycz (赞：2)

首先我们考虑如何把题目求的$T(i,j)$分段求出，假定在路径$<i,j>$上找到一些关键点$p_0,p_2,...p_k$，其中$p_0=i,p_k=j$，可以发现$\sum\limits_{i=1}^kT(p_{i-1},p_i)-k+1=T(i,j)$，于是我们把虚树建出来之后，对于边$<u,v>$，可以直接用$T(u,v)-1$作为其边权，然后在虚树上dp，记$f[i]$表示到其子树内所有特殊点的路径权值和（在虚树上），然后对于$f[i]$输出$f[i]+cnt$即可（$cnt$为特殊点个数）

二次换根即可$O(n)$求出所有特殊点的$f[i]$，然后由于有颜色修改，我们使用树链剖分即可（貌似这个写法跑得飞快）

~~码量有点小大~~

```cpp
/*program from Wolfycz*/
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define inf 0x7f7f7f7f
using namespace std;
typedef long long ll;
typedef unsigned int ui;
typedef unsigned long long ull;
inline char gc(){
	static char buf[1000000],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;
}
inline int frd(){
	int x=0,f=1; char ch=gc();
	for (;ch<'0'||ch>'9';ch=gc())	if (ch=='-')	f=-1;
	for (;ch>='0'&&ch<='9';ch=gc())	x=(x<<3)+(x<<1)+ch-'0';
	return x*f;
}
inline int read(){
	int x=0,f=1; char ch=getchar();
	for (;ch<'0'||ch>'9';ch=getchar())	if (ch=='-')	f=-1;
	for (;ch>='0'&&ch<='9';ch=getchar())	x=(x<<3)+(x<<1)+ch-'0';
	return x*f;
}
inline void print(int x){
	if (x<0)	putchar('-'),x=-x;
	if (x>9)	print(x/10);
	putchar(x%10+'0');
}
const int N=1e5;
int dfn[N+10],ID[N+10],V[N+10],n,q;
bool cmp(int x,int y){return ID[x]<ID[y];}
struct S1{
	#define ls (p<<1)
	#define rs (p<<1|1)
	struct node{
		int l,r,sum;
		node(){l=r=sum=0;}
		node(int _l,int _r,int _sum){l=_l,r=_r,sum=_sum;}
		void init(int v){l=r=v,sum=1;}
	}tree[(N<<2)+10];
	int cov[(N<<2)+10];
	friend node operator +(const node &x,const node &y){
		if (!x.sum)	return y;
		if (!y.sum)	return x;
		return node(x.l,y.r,x.sum+y.sum-(x.r==y.l));
	}
	void Add_cov(int p,int v){
		tree[p].init(v);
		cov[p]=v;
	}
	void pushdown(int p){
		if (!cov[p])	return;
		Add_cov(ls,cov[p]);
		Add_cov(rs,cov[p]);
		cov[p]=0;
	}
	void build(int p,int l,int r){
		if (l==r){
			tree[p].init(V[dfn[l]]);
			return;
		}
		int mid=(l+r)>>1;
		build(ls,l,mid);
		build(rs,mid+1,r);
		tree[p]=tree[ls]+tree[rs];
	}
	void Modify(int p,int l,int r,int x,int y,int v){
		if (x<=l&&r<=y){
			Add_cov(p,v);
			return;
		}
		pushdown(p);
		int mid=(l+r)>>1;
		if (x<=mid)	Modify(ls,l,mid,x,y,v);
		if (y>mid)	Modify(rs,mid+1,r,x,y,v);
		tree[p]=tree[ls]+tree[rs];
	}
	node Query(int p,int l,int r,int x,int y){
		if (x<=l&&r<=y)	return tree[p];
		pushdown(p);
		int mid=(l+r)>>1; node res;
		if (x<=mid)	res=res+Query(ls,l,mid,x,y);
		if (y>mid)	res=res+Query(rs,mid+1,r,x,y);
		return res;
	}
	#undef ls
	#undef rs
}ST;//Segment Tree
struct S2{
	int pre[(N<<1)+10],now[N+10],child[(N<<1)+10],tot,Time;
	int size[N+10],fa[N+10],deep[N+10],top[N+10],Rem[N+10];
	void join(int x,int y){pre[++tot]=now[x],now[x]=tot,child[tot]=y;}
	void insert(int x,int y){join(x,y),join(y,x);}
	void dfs(int x){
		deep[x]=deep[fa[x]]+1,size[x]=1;
		for (int p=now[x],son=child[p];p;p=pre[p],son=child[p]){
			if (son==fa[x])	continue;
			fa[son]=x,dfs(son);
			size[x]+=size[son];
			if (size[Rem[x]]<size[son])	Rem[x]=son;
		}
	}
	void build(int x){
		if (!x)	return;
		dfn[ID[x]=++Time]=x;
		top[x]=Rem[fa[x]]==x?top[fa[x]]:x;
		build(Rem[x]);
		for (int p=now[x],son=child[p];p;p=pre[p],son=child[p]){
			if (son==fa[x]||son==Rem[x])	continue;
			build(son);
		}
	}
	int LCA(int x,int y){
		while (top[x]!=top[y]){
			if (deep[top[x]]<deep[top[y]])	swap(x,y);
			x=fa[top[x]];
		}
		return deep[x]<deep[y]?x:y;
	}
	void Modify(int x,int y,int v){
		while (top[x]!=top[y]){
			if (deep[top[x]]<deep[top[y]])	swap(x,y);
			ST.Modify(1,1,n,ID[top[x]],ID[x],v);
			x=fa[top[x]];
		}
		if (deep[x]>deep[y])	swap(x,y);
		ST.Modify(1,1,n,ID[x],ID[y],v);
	}
	int Query(int x,int y){
		S1::node res;
		while (top[x]!=top[y]){
			if (deep[top[x]]<deep[top[y]])	swap(x,y);
			res=ST.Query(1,1,n,ID[top[x]],ID[x])+res;
			x=fa[top[x]];
		}
		if (deep[x]>deep[y])	swap(x,y);
		res=ST.Query(1,1,n,ID[x],ID[y])+res;
		return res.sum;
	}
}HLD;//Heavy Light Decomposition
struct S3{
	int pre[(N<<1)+10],now[N+10],child[(N<<1)+10],val[(N<<1)+10];
	int A[N+10],stack[N+10],size[N+10];
	int m,tot; ll f[N+10];
	bool mark[N+10];
	void join(int x,int y,int z){pre[++tot]=now[x],now[x]=tot,child[tot]=y,val[tot]=z;}
	void insert(int x,int y,int z=0){z=HLD.Query(x,y)-1,join(x,y,z),join(y,x,z);}
	void rebuild(){
		int top=0; tot=0;
		sort(A+1,A+1+m,cmp);
		stack[++top]=1;
		for (int i=1;i<=m;i++){
			int x=A[i],lca=HLD.LCA(x,stack[top]);
			if (x==1)	continue;
			if (lca==stack[top]){
				stack[++top]=x;
				continue;
			}
			while (true){
				int y=stack[top-1];
				if (ID[y]>=ID[lca])	insert(y,stack[top--]);
				else{
					if (lca==stack[top])	break;
					insert(stack[top],lca);
					stack[top]=lca; break;
				}
			}
			stack[++top]=x;
		}
		while (top>1){
			insert(stack[top],stack[top-1]);
			top--;
		}
	}
	void dfs1(int x,int fa){
		size[x]=mark[x],f[x]=0;
		for (int p=now[x],son=child[p];p;p=pre[p],son=child[p]){
			if (son==fa)	continue;
			dfs1(son,x),size[x]+=size[son];
			f[x]+=f[son]+1ll*val[p]*size[son];
		}
	}
	void dfs2(int x,int fa){//二次换根
		for (int p=now[x],son=child[p];p;p=pre[p],son=child[p]){
			if (son==fa)	continue;
			f[son]=f[x]+1ll*val[p]*(m-2ll*size[son]);
			dfs2(son,x);
		}
		now[x]=0;
	}
	void work(){
		static int list[N+10];
		m=read();
		for (int i=1;i<=m;i++)	mark[list[i]=A[i]=read()]=1;
		rebuild(),dfs1(1,0),dfs2(1,0);
		for (int i=1;i<=m;i++)	printf("%lld",f[list[i]]+m),putchar(i==m?'\n':' ');
		for (int i=1;i<=m;i++)	mark[A[i]]=0;
	}
}VT;//Virtual Tree
int main(){
	n=read(),q=read();
	for (int i=1;i<=n;i++)	V[i]=read();
	for (int i=1;i<n;i++){
		int x=read(),y=read();
		HLD.insert(x,y);
	}
	HLD.dfs(1),HLD.build(1),ST.build(1,1,n);
	for (int i=1;i<=q;i++){
		int type=read();
		if (type==1){
			int x=read(),y=read(),v=read();
			HLD.Modify(x,y,v);
		}
		if (type==2)	VT.work();
	}
	return 0;
}
```



---

## 作者：IkunTeddy (赞：1)

# 前言

被这个题折磨一下午，写个题解纪念一下。

# 题目分析

询问是一群关键点的答案，所以优先考虑建出**虚树**，两点间的边权就是他们之间的颜色段个数。

现在要需要能支持**链修改**，也可以求出**两点之间的颜色段个数**的数据结构，显然树剖或 LCT，我用的树剖实现。

最后的问题就是求解虚树上两点之间的距离，全局点对和，考虑**点分治求解**。设 $dis_x$ 表示现在 $x$ 到当前点分树根的颜色段数，显然两点之间颜色段 $T(x,y)=dis_x+dis_y-1$。直接记录 $\sum dis$ 再容斥一下即可。

用树剖的时间复杂度 $O((n+\sum m)\log^2{n})$。

用 LCT 的时间复杂度 $O((n+\sum m)\log{n})$。（不知道会不会快一点）

# Code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
//
const int maxn=1e5+10;
int n,q,rt,Tree;
int c[maxn],p[maxn],s[maxn<<1],tmp[maxn];
struct Edge{
	int v,next;
}edge[maxn<<1];
int head[maxn],tot;
void add_edge(int u,int v){
	edge[++tot].v=v;
	edge[tot].next=head[u];
	head[u]=tot;
}
struct Aux_Edge{
	int v,w;
};
vector<Aux_Edge>g[maxn];
int fa[maxn],sz[maxn],mxsz[maxn],st[maxn][20],Log[maxn],dep[maxn];
int dfn[maxn],son[maxn],top[maxn],cdfn[maxn],id[maxn];
int key[maxn],vis[maxn],k,idx;
int dis[maxn];
ll ans[maxn];
void dfs1(int u,int f){
	fa[u]=f;
	sz[u]=1;
	dep[u]=dep[fa[u]]+1;
	dfn[u]=++dfn[0];
	for(int i=head[u];i;i=edge[i].next){
		int v=edge[i].v;
		if(v==fa[u])continue ;
		dfs1(v,u);
		sz[u]+=sz[v];
		if(sz[v]>sz[son[u]])son[u]=v;
	}
}
void dfs2(int u,int topf){
	top[u]=topf;
	cdfn[u]=++cdfn[0];
	id[cdfn[0]]=u;
	if(son[u])dfs2(son[u],topf);
	for(int i=head[u];i;i=edge[i].next){
		int v=edge[i].v;
		if(v==fa[u]||v==son[u])continue ;
		dfs2(v,v);
	}
}
bool cmp(int x,int y){return dfn[x]<dfn[y];}
int get(int x,int y){return dfn[x]<dfn[y]?x:y;}
void init_ST(){
	Log[0]=-1;
	for(int i=1;i<=n;i++)Log[i]=Log[i>>1]+1;
	for(int i=1;i<=n;i++)st[dfn[i]][0]=fa[i];
	for(int j=1;j<=Log[n];j++){
		for(int i=1;i+(1<<j)-1<=n;i++){
			st[i][j]=get(st[i][j-1],st[i+(1<<j-1)][j-1]);
		}
	}
}
int LCA(int x,int y){
	if(x==y)return x;
	if(dfn[x]>dfn[y])swap(x,y);
	int l=dfn[x]+1,r=dfn[y],k=Log[r-l+1];
	return get(st[l][k],st[r-(1<<k)+1][k]);
}
//
struct node{ //正常线段树
	int ls,rs;
	int cnt,lcol,rcol;
	int tag;
	node(){tag=0;}
}tree[maxn*4];
int sgrt,nodecnt;
node pushup(node L,node R,int ls,int rs){
	node res;
	res.cnt=L.cnt+R.cnt-(L.rcol==R.lcol);
	res.lcol=L.lcol;
	res.rcol=R.rcol;
	res.ls=ls,res.rs=rs;
	return res;
}
void modify(int v,int c){
	tree[v].cnt=1;
	tree[v].lcol=tree[v].rcol=c;
	tree[v].tag=c;
}
void pushdown(int v){
	if(!tree[v].tag)return ;
	modify(tree[v].ls,tree[v].tag);
	modify(tree[v].rs,tree[v].tag);
	tree[v].tag=0;
}
int build(int l,int r){
	int v=++nodecnt;
	if(l==r){
		tree[v].cnt=1;
		tree[v].lcol=tree[v].rcol=c[id[l]];
		return v;
	}
	int mid=(l+r)>>1;
	tree[v].ls=build(l,mid);
	tree[v].rs=build(mid+1,r);
	tree[v]=pushup(tree[tree[v].ls],tree[tree[v].rs],tree[v].ls,tree[v].rs);
	return v;
}
void update(int v,int l,int r,int L,int R,int c){
	if(l>=L&&r<=R){
		modify(v,c);
		return ;
	}
	pushdown(v);
	int mid=(l+r)>>1;
	if(L<=mid)update(tree[v].ls,l,mid,L,R,c);
	if(R>mid)update(tree[v].rs,mid+1,r,L,R,c);
	tree[v]=pushup(tree[tree[v].ls],tree[tree[v].rs],tree[v].ls,tree[v].rs);
}
node ask(int v,int l,int r,int L,int R){
	if(l>=L&&r<=R)return tree[v];
	pushdown(v);
	int mid=(l+r)>>1;
	if(L<=mid&&R>mid)return pushup(ask(tree[v].ls,l,mid,L,R),ask(tree[v].rs,mid+1,r,L,R),0,0);
	else if(L<=mid)return ask(tree[v].ls,l,mid,L,R);
	else return ask(tree[v].rs,mid+1,r,L,R);
}
//
void update(int x,int y,int c){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		update(sgrt,1,n,cdfn[top[x]],cdfn[x],c);
		x=fa[top[x]];
	}
	if(cdfn[x]>cdfn[y])swap(x,y);
	update(sgrt,1,n,cdfn[x],cdfn[y],c);
}
int ask(int x,int y){ //祖先链查询颜色段数
	int cnt=0,lcol=0;
	node res;
	while(top[x]!=top[y]){
		res=ask(sgrt,1,n,cdfn[top[x]],cdfn[x]);
		cnt+=res.cnt-(res.rcol==lcol);
		lcol=res.lcol;
		x=fa[top[x]];
	}
	if(cdfn[x]>cdfn[y])swap(x,y);
	res=ask(sgrt,1,n,cdfn[x],cdfn[y]);
	cnt+=res.cnt-(res.rcol==lcol);
	return cnt;
}
//
int getsize(int u,int fa){
	int sz=1;
	for(int i=0;i<g[u].size();i++){
		int v=g[u][i].v;
		if(v==fa)continue ;
		sz+=getsize(v,u);
	}
	return sz;
}
void findrt(int u,int fa,int all){ //找重心
	sz[u]=1,mxsz[u]=0;
	for(int i=0;i<g[u].size();i++){
		int v=g[u][i].v;
		if(v==fa||vis[v])continue ;
		findrt(v,u,all);
		mxsz[u]=max(mxsz[u],sz[v]);
		sz[u]+=sz[v];
	}
	mxsz[u]=max(mxsz[u],all-sz[u]);
	if(mxsz[u]<mxsz[rt])rt=u;
}
int t[maxn],cnt;
ll sum;
void getdis(int u,int fa){
	if(key[u])t[++cnt]=u; 
	for(int i=0;i<g[u].size();i++){
		int v=g[u][i].v,w=g[u][i].w;
		if(v==fa||vis[v])continue ;
		dis[v]=dis[u]+w-1;
		getdis(v,u);
	}
}
void calc(int l,int r,int flg){
	sum=0;
	for(int i=l;i<=r;i++)sum+=dis[t[i]];
	for(int i=l;i<=r;i++)ans[t[i]]+=(sum-dis[t[i]]+(r-l)*dis[t[i]]-(r-l))*flg; //T(x,y)=dis[x]+dis[y]-1
}
void solve(int u){
	//dis是到根的颜色段数
	dis[u]=1;
	cnt=0;
	if(key[u])t[++cnt]=u;
	for(int i=0;i<g[u].size();i++){
		int v=g[u][i].v,w=g[u][i].w,lst=cnt+1;
		if(vis[v])continue ;
		dis[v]=dis[u]+w-1; //减去重复算的u
		getdis(v,u);
		calc(lst,cnt,-1); //容斥减贡献
	}
	calc(1,cnt,1);
}
void dfs(int u){ //点分治求解
	vis[u]=1;
	solve(u);
	for(int i=0;i<g[u].size();i++){
		int v=g[u][i].v,w=g[u][i].w;
		if(vis[v])continue ;
		rt=0;
		findrt(v,0,sz[v]);
		dfs(rt);
	}
	key[u]=vis[u]=0; //清空
	g[u].clear();
}
int main(){
	cin>>n>>q;
	for(int i=1;i<=n;i++)cin>>c[i];
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		add_edge(u,v);
		add_edge(v,u);
	}
	dfs1(1,0);
	dfs2(1,1);
	init_ST();
	sgrt=build(1,n);
	while(q--){
		int op,x,y;
		cin>>op;
		if(op==1){
			cin>>x>>y>>k;
			update(x,y,k);
		}else{ //建虚树
			cin>>k;
			for(int i=1;i<=k;i++)cin>>p[i],tmp[i]=p[i],key[p[i]]=1;
			p[++k]=1;
			sort(p+1,p+k+1,cmp);
			idx=0;
			for(int i=1;i<k;i++)s[++idx]=p[i],s[++idx]=LCA(p[i],p[i+1]);
			s[++idx]=p[k];
			sort(s+1,s+idx+1,cmp);
			idx=unique(s+1,s+idx+1)-s-1;
			for(int i=1;i<idx;i++){
				int w=ask(s[i+1],LCA(s[i],s[i+1]));
				g[LCA(s[i],s[i+1])].push_back({s[i+1],w});
				g[s[i+1]].push_back({LCA(s[i],s[i+1]),w});
			}
			Tree=getsize(1,0);
			mxsz[rt=0]=Tree+1;
			findrt(1,0,Tree);
			dfs(rt);
			for(int i=1;i<k;i++)cout<<ans[tmp[i]]+1<<' '; //加上自己
			cout<<'\n';
			for(int i=1;i<=k;i++)ans[p[i]]=0;
		}
	}
	
	return 0;
}
```

---

## 作者：gyyyyx (赞：1)

先不考虑修改操作。

对于查询可以换根 dp。

我们称给定的点集中的点为**关键点**。

设 $f_i$ 表示以 $1$ 节点为根时，$i$ 节点的子树内所有关键点到 $i$ 节点的路径颜色段数之和，$sum_i$ 表示以 $1$ 为根时 $i$ 子树内的关键点数量。

转移方程为：

$$f_u=\sum\limits_{v\in u's\ son}(f_v+sum_v\cdot val(u,v))+flg_u$$

其中 $val(u,v)$ 表示边 $(u,v)$ 的贡献，只有当 $u,v$ 颜色相同时为 $1$，否则为 $0$。

而最后的 $flg_u$ 表示 $u$ 是否为关键点，是则为 $1$，否则为 $0$。

之后进行换根。

设 $g_i$ 表示 $i$ 节点的权值，$fa_i$ 表示以 $1$ 为根时 $i$ 节点的父亲节点。

转移方程为：

$$g_u=g_{fa_u}-sum_u\cdot val(fa_u,u)+(m-sum_u)val(fa_u,u)=g_{fa_u}+(m-2sum_u)val(fa_u,u)$$

$m$ 表示关键点总数。

但这样时间是 $O(qn\log n)$，瓶颈在于每次查询都要 dp 一次，但这样肯定会爆。

观察到 $\sum m\leq 2\times 10^5$，考虑虚树。

注意到 $x,y$ 路径上的颜色段数可以分成 $x,z$ 路径颜色段数和 $z,y$ 路径颜色段数之和减一。

举个例子：

$x,y$ 之间颜色为 $114514$，颜色段数为 $5$。

分成 $x,z$ 和 $z,y$ ：$1145$ 和 $514$，颜色段数为 $3$ 和 $3$。

显然合并起来的颜色为 $1145514$，中间虽然多了一个 $5$ 但并不影响颜色段数。

则如果要将两个路径合并起来，中间必然会出现 $z$ 这一个共用点，因此 $x,z$ 的右端颜色必然和 $z,y$ 的左端颜色相同。

因此两段颜色段数加起来后必然需要减一才等于原来的颜色段数。

将关键点建成虚树，虚树中 $(u,v)$ 边权为原树中 $u,v$ 路径上的颜色段数。

此时转移方程只需要将原来的 $val(u,v)$ 变为边权减一就行了。

可以用树剖加线段树维护。

同时我们发现修改操作也可以树剖加线段树维护。

时间复杂度 $O((\sum m)\log n)$。

最后不要忘记查询完清空虚树。

代码：

```cpp
#include<bits/stdc++.h>
#define LL long long
#define N 100005
using namespace std;
int n,q,col[N];
struct Edge{
	int nxt,to,val;
	Edge(int a=0,int b=0,int c=0)
	:nxt(a),to(b),val(c){}
};
struct Edge e[N<<1];
int head[N],cnt;
int fa[N],dep[N],siz[N],son[N];
int dfs,dfn[N],rnk[N],top[N];
struct Node{
	int val,lc,rc;
	Node(int a=0,int b=0,int c=0)
	:val(a),lc(b),rc(c){}
} seg[N<<2];
inline Node operator + (const Node&x,const Node&y){
	if(!x.val) return y;
	if(!y.val) return x;
	Node res(x.val+y.val,x.lc,y.rc);
	if(x.rc==y.lc) --res.val;
	return res;
}
int tag[N<<2];
int p[N],id[N];
struct Edge e2[N];
int head2[N],cnt2;
int st[N],tp;
LL sum[N],dp[N];
inline void addEdge(int x,int y){
	e[++cnt]=Edge(head[x],y);head[x]=cnt;
}
void DFS1(int u,int f){
	dep[u]=dep[fa[u]=f]+1;siz[u]=1;
	for(int i(head[u]);i;i=e[i].nxt){
		int v(e[i].to);
		if(v^f){
			DFS1(v,u);siz[u]+=siz[v];
			if(siz[v]>siz[son[u]]) son[u]=v;
		}
	}
}
void DFS2(int u,int t){
	rnk[dfn[u]=++dfs]=u;top[u]=t;
	if(son[u]) DFS2(son[u],t);
	for(int i(head[u]);i;i=e[i].nxt){
		int v(e[i].to);
		if(v==fa[u]||v==son[u]) continue;
		DFS2(v,v);
	}
}
inline void pushup(int k){
	seg[k]=seg[k<<1]+seg[k<<1|1];
}
void Build(int k,int l,int r){
	if(l==r){
		seg[k]=Node(1,col[rnk[l]],col[rnk[r]]);
		return;
	}
	int ls(k<<1),rs(k<<1|1),mid(l+r>>1);
	Build(ls,l,mid);Build(rs,mid+1,r);
	pushup(k);
}
inline void pushdown(int k){
	int v(tag[k]);
	if(!v) return;
	tag[k]=0;
	int ls(k<<1),rs(k<<1|1);
	seg[ls]=seg[rs]=Node(1,v,v);
	tag[ls]=tag[rs]=v;
}
void Assign(int k,int l,int r,int s,int t,int v){
	if(l>t||r<s) return;
	if(s<=l&&r<=t){
		seg[k]=Node(1,v,v);
		tag[k]=v;
		return;
	}
	pushdown(k);
	int ls(k<<1),rs(k<<1|1),mid(l+r>>1);
	Assign(ls,l,mid,s,t,v);
	Assign(rs,mid+1,r,s,t,v);
	pushup(k);
}
Node Query(int k,int l,int r,int s,int t){
	if(l>t||r<s) return Node();
	if(s<=l&&r<=t) return seg[k];
	pushdown(k);
	int ls(k<<1),rs(k<<1|1),mid(l+r>>1);
	return Query(ls,l,mid,s,t)+Query(rs,mid+1,r,s,t);
} 
inline void Update(int x,int y,int v){
	while(top[x]^top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		Assign(1,1,n,dfn[top[x]],dfn[x],v);
		x=fa[top[x]];
	}
	if(dfn[x]>dfn[y]) swap(x,y);
	Assign(1,1,n,dfn[x],dfn[y],v);
}
inline int askEdge(int x,int y){
	Node res;
	if(dep[x]<dep[y]) swap(x,y);
	while(top[x]^top[y]){
		res=Query(1,1,n,dfn[top[x]],dfn[x])+res;
		x=fa[top[x]];
	}
	return (Query(1,1,n,dfn[y],dfn[x])+res).val;
}
inline int LCA(int x,int y){
	while(top[x]^top[y]){
		if(dep[top[x]]<=dep[top[y]]) y=fa[top[y]];
		else x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	return x;
}
inline bool cmp(int x,int y){
	return dfn[p[x]]<dfn[p[y]];
}
inline void addEdge2(int x,int y){
	e2[++cnt2]=Edge(head2[x],y,askEdge(x,y));head2[x]=cnt2;
}
void DFS3(int u){
	if(sum[u]) dp[u]=1;
	for(int i(head2[u]);i;i=e2[i].nxt){
		int v(e2[i].to);
		DFS3(v);
		sum[u]+=sum[v];
		dp[u]+=dp[v]+sum[v]*(e2[i].val-1);
	}
}
void DFS4(int m,int u){
	for(int i(head2[u]);i;i=e2[i].nxt){
		int v(e2[i].to),w(e2[i].val);
		dp[v]=dp[u]+(m-2*sum[v])*(w-1);
		DFS4(m,v);
	}
}
void Clear(int u){
	sum[u]=dp[u]=0;
	for(int i(head2[u]);i;i=e2[i].nxt) Clear(e2[i].to);
	head2[u]=0;
}
int main(){
	scanf("%d%d",&n,&q);
	for(int i(1);i<=n;++i) scanf("%d",&col[i]);
	for(int i(1);i<n;++i){
		int u,v;scanf("%d%d",&u,&v);
		addEdge(u,v);addEdge(v,u);
	}
	DFS1(1,0);DFS2(1,1);Build(1,1,n);
	while(q--){
		int op;scanf("%d",&op);
		if(op==1){
			int u,v,y;
			scanf("%d%d%d",&u,&v,&y);
			Update(u,v,y);
		}
		else{
			int m;scanf("%d",&m);
			for(int i(1);i<=m;++i) scanf("%d",&p[i]);
			for(int i(1);i<=m;++i) id[i]=i;
			sort(id+1,id+1+m,cmp);
			st[tp=1]=1;
			for(int i(1);i<=m;++i){
				if(p[id[i]]==1) continue;
				int lca(LCA(p[id[i]],st[tp]));
				if(st[tp]^lca){
					while(tp>1&&dfn[st[tp-1]]>dfn[lca])
						addEdge2(st[tp-1],st[tp]),--tp;
					addEdge2(lca,st[tp]);--tp;
					if(st[tp]^lca) st[++tp]=lca;
				}
				st[++tp]=p[id[i]];
			}
			while(--tp) addEdge2(st[tp],st[tp+1]);
			for(int i(1);i<=m;++i) sum[p[i]]=1;
			DFS3(1);DFS4(m,1);
			for(int i(1);i<=m;++i) printf("%lld ",dp[p[i]]);puts("");
			Clear(1);cnt2=0;
		}
	}
	return 0;
}
```

令人忍俊不禁的是我一开始清空虚树时写了 `fill(head2+1,head2+1+cnt2,0);`，然后调了半小时没调出来。

我一开始想的是虚树加点分治。

后来写到一半才发现其实不用，可怜我已经码了一百多行的代码。

---

## 作者：_fairytale_ (赞：1)

# 前言

数据结构题可爱。孩子吸氧跑了最优解，很激动，来写个题解。

其实本题思维难度并不高，只要掌握了前置知识就很好写。

# 修改

这是一个经典的树剖问题，查区间颜色段数用 [P2486 [SDOI2011] 染色](https://www.luogu.com.cn/problem/P2486) 的线段树维护，这个详见代码，应该很好懂。

# 查询

看到 $\sum m$ 和 $n$ 同阶，果断建立虚树，同时把 $u,v$ 两点间的颜色段数 $-1$ 作为虚树上的边权，这样就变成了一个经典换根 DP 问题：树上有一些关键点，边有边权，对每个关键点求所有关键点到它的距离之和。

为什么要用颜色段数 $-1$ 作为虚树边权呢？考虑这样一种情况：$a\to b\to c\to d$，箭头表示连边，其中 $a\to b,b\to c,c\to d$ 的颜色全部相同，如果不将颜色段数 $-1$，那答案将会是 $3$，但是如果 $-1$，答案是 $0$，我们还要在整体加上 $1$，这样答案就正确了。

怎么换根 DP 呢？

设 $sz[u]$ 表示 $u$ 子树中有多少个关键点， $dp1[u]$ 表示 $u$ 子树中所有关键点到 $u$ 的距离之和，这两个可以通过一遍 dfs 处理。

设 $dp2[u]$ 表示整棵树以 $u$ 为根时，所有关键点到 $u$ 的距离之和，也就是答案。

不妨考虑一条 $u\to v$，边权为 $dis$ 的边，其中 $dp2[u]$ 已经处理好了。

$v$ 子树中有 $sz[v]$ 个关键点，当根从 $u$ 换到 $v$ 时，这些点到根的距离会减少 $dis$，反之，$v$ 子树外有 $m-sz[v]$ 个关键点，这些点到根的距离会增加 $dis$。

所以转移方程为：
$$
dp2[v]=dp2[u]-dis\times sz[v]+dis\times(m-sz[v])
$$

最后记得把所有 $dp2$ 加上 $m$，补回之前每条边的 $-1$。

```cpp
#include<bits/stdc++.h>
#define re register
#define ls ((p)<<1)
#define rs (((p)<<1)|1)
#define mid ((l+r)>>1)
#define rep(x,a,b) for(re int (x)=(a);(x)<=(b);++(x))
using namespace std;
#define maxn 100010
int n,q,m;
int c[maxn];
int dep[maxn],siz[maxn],son[maxn],fa[maxn];
int dfn[maxn],top[maxn],w[maxn],tim;
int dp1[maxn],dp2[maxn],sz[maxn];
bool iskey[maxn];
struct tree{
	int pre,suf,sum,cov;
}t[maxn<<2];
inline void pushup(int p){
	t[p].sum=t[ls].sum+t[rs].sum-(t[ls].suf==t[rs].pre);
	t[p].pre=t[ls].pre,t[p].suf=t[rs].suf;
}
void build(int p,int l,int r){
	if(l==r)return t[p].pre=t[p].suf=w[l],t[p].sum=1,void();
	build(ls,l,mid),build(rs,mid+1,r);
	pushup(p);
}
inline void pushc(int p,int v){
	t[p].pre=t[p].suf=v;
	t[p].sum=1;
	t[p].cov=v;
}
inline void pushdown(int p){
	if(t[p].cov){
		pushc(ls,t[p].cov);
		pushc(rs,t[p].cov);
		t[p].cov=0;
	}
}
void update(int p,int l,int r,int L,int R,int v){
	if(L<=l&&r<=R)return pushc(p,v),void();
	pushdown(p);
	if(mid>=L)update(ls,l,mid,L,R,v);
	if(mid<R)update(rs,mid+1,r,L,R,v);
	pushup(p);
} 
inline tree merge(const tree &x,const tree &y){
	if(x.cov==-1)return y;
	if(y.cov==-1)return x;
	return {x.pre,y.suf,x.sum+y.sum-(x.suf==y.pre),0};
}
tree query(int p,int l,int r,int L,int R){
	if(L<=l&&r<=R)return {t[p].pre,t[p].suf,t[p].sum,0};
	pushdown(p);
	if(mid<L)return query(rs,mid+1,r,L,R);
	if(mid>=R)return query(ls,l,mid,L,R);
	tree lres=query(ls,l,mid,L,R),rres=query(rs,mid+1,r,L,R);
	return merge(lres,rres);
} 
inline void pathcov(int u1,int u2,int v){
	while(top[u1]!=top[u2]){
		if(dep[top[u1]]<dep[top[u2]])swap(u1,u2);
		update(1,1,n,dfn[top[u1]],dfn[u1],v);
		u1=fa[top[u1]];
	}
	if(dep[u1]>dep[u2])swap(u1,u2);
	update(1,1,n,dfn[u1],dfn[u2],v);
}
inline int pathquery(int u1,int u2){
	tree L={0,0,0,-1},R={0,0,0,-1};
	while(top[u1]!=top[u2]){
		if(dep[top[u1]]<dep[top[u2]]){
			R=merge(query(1,1,n,dfn[top[u2]],dfn[u2]),R);
			u2=fa[top[u2]];
		}
		else{
			L=merge(query(1,1,n,dfn[top[u1]],dfn[u1]),L);
			u1=fa[top[u1]];
		}
	}
	if(dep[u1]<dep[u2])R=merge(query(1,1,n,dfn[u1],dfn[u2]),R);
	else L=merge(query(1,1,n,dfn[u2],dfn[u1]),L);
	return L.sum+R.sum-(L.pre==R.pre);
}
struct Graph{
	int to[maxn<<1],nxt[maxn<<1],cnt;
	int hd[maxn];
	inline void addedge(int u,int v){
		to[++cnt]=v;
		nxt[cnt]=hd[u];
		hd[u]=cnt;
	}
	void dfs1(int u,int f){
		siz[u]=1;
	    fa[u]=f;
	    dep[u]=dep[f]+1;
	    for(re int i=hd[u];i;i=nxt[i]){
	    	int v=to[i];
	    	if(v==f)continue;
			dfs1(v,u);
			siz[u]+=siz[v];
			if(siz[v]>siz[son[u]])son[u]=v; 
		}
	}
	void dfs2(int u,int t){
		dfn[u]=++tim;
		top[u]=t;
		w[tim]=c[u];
		if(son[u])dfs2(son[u],t);
		for(re int i=hd[u];i;i=nxt[i]){
			int v=to[i];
			if(v==fa[u]||v==son[u])continue;
			dfs2(v,v);
		}
	}
	void Vdfs1(int u,int f){
		dp1[u]=0;
		if(iskey[u])sz[u]=1;
		else sz[u]=0;
		for(re int i=hd[u];i;i=nxt[i]){
			int v=to[i];
		    Vdfs1(v,u);
		    sz[u]+=sz[v];
			int dis=pathquery(u,v)-1;
			dp1[u]+=dp1[v]+sz[v]*dis;
		}
	}
	void Vdfs2(int u,int f){
		for(re int i=hd[u];i;i=nxt[i]){
			int v=to[i];
			int dis=pathquery(u,v)-1;
			dp2[v]=dp2[u]-sz[v]*dis+(m-sz[v])*dis;
			Vdfs2(v,u);
		}
	} 
}G[2];

inline int LCA(int u1,int u2){
	while(top[u1]!=top[u2]){
		if(dep[top[u1]]<dep[top[u2]])swap(u1,u2);
		u1=fa[top[u1]];
	}
	return dep[u1]<dep[u2]?u1:u2;
}
int a,b,v;
int op;
int keys[maxn];
int stac[maxn],tp;
inline void VTbuild(){
	G[1].hd[1]=0;
	G[1].cnt=0;
	stable_sort(keys+1,keys+m+1,[](const int &x,const int &y){return dfn[x]<dfn[y];});
	stac[tp=1]=1;
	rep(i,(keys[1]==1?2:1),m){
		int lca=LCA(keys[i],stac[tp]);
		if(lca!=stac[tp]){
			while(dfn[stac[tp-1]]>dfn[lca]){
				G[1].addedge(stac[tp-1],stac[tp]);
				--tp;
			}
			if(lca==stac[tp-1]){
				G[1].addedge(lca,stac[tp]);
				--tp;
			}
			else{
				G[1].hd[lca]=0;
				G[1].addedge(lca,stac[tp]);
				stac[tp]=lca;
			}
		}
		stac[++tp]=keys[i];
		G[1].hd[keys[i]]=0;
	}
	while(tp>1){
		G[1].addedge(stac[tp-1],stac[tp]);
		--tp;
	}
}
int tmp[maxn];
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
    cin>>n>>q;
    rep(i,1,n)cin>>c[i];
    rep(i,2,n){
    	cin>>a>>b;
    	G[0].addedge(a,b);
    	G[0].addedge(b,a);
	} 
	G[0].dfs1(1,0);
	G[0].dfs2(1,1);
	build(1,1,n);
	while(q--){
		cin>>op;
		if(op==1){
			cin>>a>>b>>v;
			pathcov(a,b,v);
		}
		else if(op==2){
			cin>>m;
			rep(i,1,m){
				cin>>keys[i];
				tmp[i]=keys[i];
				iskey[keys[i]]=true;
			}
			VTbuild();
			G[1].Vdfs1(1,0);
			dp2[1]=dp1[1];
			G[1].Vdfs2(1,0);
			rep(i,1,m)cout<<dp2[tmp[i]]+m<<" ";
			cout<<'\n'; 
			rep(i,1,m)iskey[keys[i]]=false;
		}
	} 
	return 0;
}
```


---

## 作者：TYxxj (赞：1)

树剖维护修改。

对于询问，很容易想到虚树。

对于虚树上的边，边权定义为去掉$dep$小的那个点所在的颜色块剩余的块的数量。

这样的话，一条路径的权值就是边权之和$+1$。

所以，建完虚树之后，直接二次换根$dp$就好了。

(当然你也可以点分治，但是那样代码大概会破$300$行。)

所以这玩意就是一模板大集合。真一道毒瘤题。

```cpp
#include<bits/stdc++.h>
using namespace std;
void read(int &x) {
	x=0;
	int f=1;
	char ch=getchar();
	for(; !isdigit(ch); ch=getchar()) if(ch=='-') f=-f;
	for(; isdigit(ch); ch=getchar()) x=x*10+ch-'0';
	x*=f;
}
void print(int x) {
	if(x<0) putchar('-'),x=-x;
	if(!x) return ;
	print(x/10),putchar(x%10+48);
}
void write(int x) {
	if(!x) putchar('0');
	else print(x);
	putchar('\n');
}
const int maxn = 2e5+10;
int n,col[maxn],m,sz[maxn],dfn[maxn],f[maxn],dep[maxn],re[maxn];
#define ls p<<1
#define rs p<<1|1
#define mid ((l+r)>>1)
struct data {
	int lcol,rcol,sum;
	data operator + (const data &rhs) const {
		if(!sum) return rhs;
		if(!rhs.sum) return *this;
		return (data) {
			lcol,rhs.rcol,sum+rhs.sum-(rcol==rhs.lcol)
		};
	}
};
struct Segment_Tree {
	int cov[maxn<<2];
	data t[maxn<<2];
	void push_tag(int p,int x) {
		t[p].sum=1,t[p].lcol=t[p].rcol=x,cov[p]=x;
	}
	void pushdown(int p) {
		if(!cov[p]) return ;
		push_tag(ls,cov[p]),push_tag(rs,cov[p]);
		cov[p]=0;
	}
	void modify(int p,int l,int r,int x,int y,int z) {
		if(x<=l&&r<=y) return push_tag(p,z),void();
		pushdown(p);
		if(x<=mid) modify(ls,l,mid,x,y,z);
		if(y>mid) modify(rs,mid+1,r,x,y,z);
		t[p]=t[ls]+t[rs];
	}
	data query(int p,int l,int r,int x,int y) {
		if(x<=l&&r<=y) return t[p];
		pushdown(p);
		if(y<=mid) return query(ls,l,mid,x,y);
		else if(x>mid) return query(rs,mid+1,r,x,y);
		else return query(ls,l,mid,x,y)+query(rs,mid+1,r,x,y);
	}
	void build(int p,int l,int r) {
		if(l==r) return t[p].sum=1,t[p].lcol=t[p].rcol=col[re[l]],void();
		build(ls,l,mid),build(rs,mid+1,r),t[p]=t[ls]+t[rs];
	}
} SGT;
struct Heavy_Light_Decomposation {
	int head[maxn],tot,hs[maxn],top[maxn],dfn_cnt;
	struct edge {
		int to,nxt;
	} e[maxn<<1];
	void add(int u,int v) {
		e[++tot]=(edge) {v,head[u]},head[u]=tot;
	}
	void ins(int u,int v) {
		add(u,v),add(v,u);
	}
	void dfs(int x,int fa) {
		sz[x]=1,f[x]=fa,dep[x]=dep[fa]+1;
		for(int i=head[x]; i; i=e[i].nxt)
			if(e[i].to!=fa) {
				dfs(e[i].to,x);
				sz[x]+=sz[e[i].to];
				if(sz[e[i].to]>sz[hs[x]]) hs[x]=e[i].to;
			}
	}
	void dfs2(int x) {
		if(hs[f[x]]==x) top[x]=top[f[x]];
		else top[x]=x;
		dfn[x]=++dfn_cnt;
		re[dfn_cnt]=x;
		if(hs[x]) dfs2(hs[x]);
		for(int i=head[x]; i; i=e[i].nxt)
			if(e[i].to!=f[x]&&e[i].to!=hs[x]) dfs2(e[i].to);
	}
	int lca(int x,int y) {
		while(top[x]!=top[y]) {
			if(dep[top[x]]<dep[top[y]]) swap(x,y);
			x=f[top[x]];
		}
		if(dep[x]>dep[y]) swap(x,y);
		return x;
	}
	void modify(int x,int y,int z) {
		while(top[x]!=top[y]) {
			if(dep[top[x]]<dep[top[y]]) swap(x,y);
			SGT.modify(1,1,n,dfn[top[x]],dfn[x],z);
			x=f[top[x]];
		}
		if(dep[x]>dep[y]) swap(x,y);
		SGT.modify(1,1,n,dfn[x],dfn[y],z);
	}
	void print(data x) {
		printf("Print :: %d %d %d\n",x.sum,x.lcol,x.rcol);
	}
	int query(int x,int t) {
		data ans;
		int bo=1;
		while(top[x]!=top[t]) {
			data res=SGT.query(1,1,n,dfn[top[x]],dfn[x]);
			if(bo) bo=0,ans=res;
			else ans=res+ans;
			x=f[top[x]];
		}
		data res=SGT.query(1,1,n,dfn[t],dfn[x]);
		if(bo) bo=0,ans=res;
		else ans=res+ans;
		return ans.sum;
	}
	void debug(int x,int fa) {
		for(int i=head[x]; i; i=e[i].nxt)
			if(e[i].to!=fa) debug(e[i].to,x);
	}
} HLD;
int cmp(int x,int y) {
	return dfn[x]<dfn[y];
}
int id[maxn];
int cmp2(int x,int y) {
	return id[x]<id[y];
}
struct Virtual_Tree {
	int head[maxn],tot,c[maxn],f[maxn],g[maxn],vis[maxn];
	struct edge {
		int to,nxt,w;
	} e[maxn<<1];
	void add(int u,int v,int w) {
		e[++tot]=(edge) {v,head[u],w},head[u]=tot;
	}
	void ins(int u,int v,int w){
		add(u,v,w),add(v,u,w);
	} 
	int in[maxn],k,use[maxn],used,sta[maxn],top;
	void build() {
		sta[++top]=1,use[++used]=1;
		for(int i=1; i<=k; i++) {
			if(in[i]==1) continue;
			int t=HLD.lca(in[i],sta[top]),pre=-1;
			while(dfn[sta[top]]>dfn[t]&&dfn[sta[top]]<dfn[t]+sz[t]) {
				if(pre!=-1) ins(sta[top],pre,HLD.query(pre,sta[top])-1);
				pre=sta[top],use[++used]=sta[top],top--;
			}
			if(pre!=-1) ins(t,pre,HLD.query(pre,t)-1);
			if(sta[top]!=t) sta[++top]=t;
			sta[++top]=in[i];
		}
		int pre=-1;
		while(top) {
			if(pre!=-1) ins(sta[top],pre,HLD.query(pre,sta[top])-1);
			pre=sta[top],use[++used]=sta[top],top--;
		}
	}
	void dfs(int x,int fa) {
		if(vis[x]) c[x]=1;
		else c[x]=0;
		for(int i=head[x]; i; i=e[i].nxt)
			if(e[i].to!=fa) {
				dfs(e[i].to,x);
				c[x]+=c[e[i].to];
				f[x]+=e[i].w*c[e[i].to]+f[e[i].to];
			}
	}
	void clear() {
		for(int i=1; i<=used; i++) {
			int t=use[i];
			head[t]=id[t]=vis[t]=f[t]=g[t]=c[t]=0;
		}
		tot=used=top=0;
	}
	void dfs2(int x,int fa) {
		for(int i=head[x]; i; i=e[i].nxt)
			if(e[i].to!=fa) {
				int v=e[i].to;
				g[v]=g[x]-e[i].w*c[v]+e[i].w*(k-c[v]);
				dfs2(e[i].to,x);
			}
	}
	void solve() {
		read(k);
		for(int i=1; i<=k; i++) read(in[i]),vis[in[i]]=1,id[in[i]]=i;
		sort(in+1,in+k+1,cmp);
		build();
		dfs(1,0);
		g[1]=f[1];
		dfs2(1,0);
		sort(in+1,in+k+1,cmp2);
		for(int i=1; i<=k; i++) printf("%d ",g[in[i]]+k);
		puts("");
		clear();
	}
} VT;
int main() {
	read(n),read(m);
	for(int i=1; i<=n; i++) read(col[i]);
	for(int i=1,x,y; i<n; i++) read(x),read(y),HLD.ins(x,y);
	HLD.dfs(1,0),HLD.dfs2(1),SGT.build(1,1,n);
	for(int i=1; i<=m; i++) {
		int op,u,v,y;
		read(op);
		if(op==1) read(u),read(v),read(y),HLD.modify(u,v,y);
		else VT.solve();
	}
	return 0;
}
```

---

## 作者：1234567s (赞：0)

关于题意：虚树上全局链上颜色段数总和。  
首先，先把虚树建出来，考虑维护全局链信息，那么你就可以选择点分树，但由于这道题边权较好统计，那么也可换根 DP 求解，至于虚树上的边权即两点间颜色段数，随便上个树上链结构即可。  
关于一些实践上的小细节：  
因为这道题是点权，那么相邻两条边的端点颜色一定相同，那么求出颜色段放心 $-1$ 即可。  
边权上如果你用的是点分树，那么由于边会重复遍历，在建时就放边权能降时间复杂度。  
这里是树剖 + 点分树容斥实现。  
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 100005
namespace lzz
{	
	int a[N];
	int n,m,Q;
	struct node
	{
		int to,next;
	}ed[N<<1];
	int head[N],cnt;
	void add(int x,int y)
	{
		cnt++;
		ed[cnt].to=y;
		ed[cnt].next=head[x];
		head[x]=cnt;
	}
	struct kkk
	{
		int tag;
		int lx,rx,ans;//左边是什么颜色,右边同理,不同颜色段数
	};
	struct segment_tree
	{
		kkk tree[N<<2];
		kkk merge(kkk ls,kkk rs)
		{
			if(!ls.ans)return rs; if(!rs.ans)return ls;
			kkk pup={0,0,0,0};
			pup.ans=ls.ans+rs.ans;
			pup.lx=ls.lx,pup.rx=rs.rx;
			if(ls.rx==rs.lx)pup.ans--;
			return pup;
		}
		void pushup(int p,int l,int r){if(l!=r)tree[p]=merge(tree[p<<1],tree[p<<1|1]);}
		void tag(int p,int val){tree[p].tag=val,tree[p].lx=tree[p].rx=val,tree[p].ans=1;}
		void pushdown(int p,int l,int r){if(tree[p].tag)tag(p<<1,tree[p].tag),tag(p<<1|1,tree[p].tag),tree[p].tag=0;}
		void modify(int p,int l,int r,int L,int R,int val)
		{
			if(l>R||r<L)return ; if(L<=l&&r<=R)return tag(p,val),void();
			int mid=(l+r)>>1; pushdown(p,l,r); modify(p<<1,l,mid,L,R,val),modify(p<<1|1,mid+1,r,L,R,val),pushup(p,l,r);
		}
		kkk query(int p,int l,int r,int L,int R)
		{
			if(l>R||r<L)return kkk({0,0,0,0}); 
			if(L<=l&&r<=R)return tree[p];
		 	int mid=(l+r)>>1; pushdown(p,l,r); return merge(query(p<<1,l,mid,L,R),query(p<<1|1,mid+1,r,L,R));
		}
	}T1; 
	int dis[N];//共用的 
	namespace lip
	{
		int hea_son[N];
		int fa[N],size[N];
		void dfs_1(int u)
		{
			size[u]=1;
			for(int i=head[u];i;i=ed[i].next)
			{
				int v=ed[i].to;
				if(v==fa[u])continue;
				fa[v]=u,dis[v]=dis[u]+1,dfs_1(v),size[u]+=size[v];
				if(size[v]>size[hea_son[u]])hea_son[u]=v;
			}
		}
		int top[N];
		int dfn[N],out[N];
		void dfs_2(int u,int hea_top)
		{
			top[u]=hea_top;
			dfn[++dfn[0]]=u,out[u]=dfn[0];
			if(hea_son[u])dfs_2(hea_son[u],hea_top);
			for(int i=head[u];i;i=ed[i].next)
			{
				int v=ed[i].to;
				if(v==fa[u]||v==hea_son[u])continue;
				dfs_2(v,v);
			}
		}
		void build(int p,int l,int r)
		{
			if(l==r)
			{
				T1.tree[p].ans=1,T1.tree[p].tag=0;
				T1.tree[p].lx=T1.tree[p].rx=a[dfn[l]];
				return ;
			}
			int mid=(l+r)>>1;
			build(p<<1,l,mid),build(p<<1|1,mid+1,r);
			T1.pushup(p,l,r);
		}
		int LCA(int u,int v)
		{
			while(top[u]!=top[v])
			{
				if(dis[top[u]]<dis[top[v]])swap(u,v);
				u=fa[top[u]]; 
			}
			if(dis[u]<dis[v])return u; else return v;
		}
		void modify(int u,int v,int val)
		{
			while(top[u]!=top[v])
			{
				if(dis[top[u]]<dis[top[v]])swap(u,v);
				T1.modify(1,1,n,out[top[u]],out[u],val),u=fa[top[u]];
			}if(dis[u]>dis[v])swap(u,v);
			T1.modify(1,1,n,out[u],out[v],val);
		}
		int query(int u,int v)
		{
			kkk ans1={0,0,0,0},ans2={0,0,0,0};
			while(top[u]!=top[v])
			{
				if(dis[top[u]]>dis[top[v]])
				{
					kkk now=T1.query(1,1,n,out[top[u]],out[u]);
					swap(now.lx,now.rx),ans1=T1.merge(ans1,now),u=fa[top[u]];
				}
				else
				{
					kkk now=T1.query(1,1,n,out[top[v]],out[v]);
					ans2=T1.merge(now,ans2),v=fa[top[v]];
				}
			}
			if(dis[u]<dis[v])
			{
				kkk now=T1.query(1,1,n,out[u],out[v]);
				ans1=T1.merge(ans1,now);
			}
			else
			{
				kkk now=T1.query(1,1,n,out[v],out[u]); swap(now.lx,now.rx);
				ans2=T1.merge(now,ans2);
			}return T1.merge(ans1,ans2).ans;
		}
	};
	int stk[N],top;
	int dfn[N],out[N];
	void dfs(int u,int fa)
	{
		dfn[++dfn[0]]=u,out[u]=dfn[0];//原树dfs序,建虚树 
		for(int i=head[u];i;i=ed[i].next)
		{
			int v=ed[i].to;
			if(v==fa)continue;
			dfs(v,u); 
		}
	}
	int go;
	int ans[N];
	struct sss{int to,w;};
	vector<sss>q[N];
	int hea[N],bj[N],yuan[N];
	bool cmp(int x,int y){return out[x]<out[y];}
	void build()
	{
		scanf("%d",&m),go=m;
		for(int i=1;i<=m;i++)scanf("%d",&hea[i]),bj[hea[i]]=1,ans[hea[i]]=0,yuan[i]=hea[i];//标记关键点 
		sort(hea+1,hea+m+1,cmp),stk[top=1]=hea[1];
		for(int i=2;i<=m;i++)
		{
			int now=hea[i],lca=lip::LCA(now,stk[top]);
			while(top>1&&dis[lca]<=dis[stk[top-1]])
			{
				int val=lip::query(stk[top-1],stk[top]);
				q[stk[top-1]].push_back({stk[top],val}),q[stk[top]].push_back({stk[top-1],val}),--top;
			}
			if(lca!=stk[top])
			{
				int val=lip::query(lca,stk[top]);
				q[lca].push_back({stk[top],val}),q[stk[top]].push_back({lca,val});
				if(lca!=stk[top-1])stk[top]=lca; else top--;
			}stk[++top]=now;
		}
		while(--top)
		{
			int val=lip::query(stk[top],stk[top+1]);
			q[stk[top]].push_back({stk[top+1],val}),q[stk[top+1]].push_back({stk[top],val});
		}
	} 
	int rt,dep[N];
	int sum,size[N];
	int vis[N],maxx[N];
	void get_rt(int u,int fa)
	{
		maxx[u]=0,size[u]=1;
		for(sss d:q[u])
		{
			int v=d.to;
			if(v==fa||vis[v])continue;
			get_rt(v,u),size[u]+=size[v],maxx[u]=max(maxx[u],size[v]);
		}maxx[u]=max(maxx[u],sum-size[u]); if(maxx[u]<maxx[rt])rt=u;
	}
	int ok[N];
	vector<int>del;
	int all,num,ls_all,ls_num;//前面的颜色段数,这里的总和 
	void get_dis(int u,int fa,int val)//上一次的颜色,权值 
	{
		dep[u]=val;
		if(bj[u])ok[++ok[0]]=u,ls_num++,ls_all+=val;//临时存一下 
		for(sss d:q[u])
		{
			int v=d.to,w=d.w;
			if(d.to==fa||vis[v])continue;
			get_dis(v,u,w+val-1);
		}
	}
	void query(int u)
	{
		ok[0]=0,dep[u]=1,all=0,num=0;//根节点放进去
		if(bj[u])ok[++ok[0]]=u,all+=dep[u],num++; 
		int pre=ok[0]+1;
		for(sss d:q[u])
		{
			int v=d.to,w=d.w;
			if(vis[v])continue;
			ls_all=ls_num=0,get_dis(v,u,w);
			for(int i=pre;i<=ok[0];i++)ans[ok[i]]-=dep[ok[i]]*(ls_num-1)+(ls_all-dep[ok[i]])-(ls_num-1);//减去子树内自身匹配的 
			all+=ls_all,num+=ls_num,pre=ok[0]+1;//这里与根节点匹配
		}for(int i=1;i<=ok[0];i++)ans[ok[i]]+=dep[ok[i]]*(num-1)+(all-dep[ok[i]])-(num-1);
	}
	void solve(int u)
	{
		vis[u]=1,query(u);
		for(sss d:q[u])
		{
			int v=d.to;
			if(vis[v])continue;
			maxx[rt=0]=sum=size[v],get_rt(v,0),solve(rt);
		}del.push_back(u);
	}
	void clear()
	{
		for(int u:del)bj[u]=vis[u]=0,q[u].clear();
		del.clear();
	}
	int main()
	{
		scanf("%d%d",&n,&Q);
		for(int i=1;i<=n;i++)scanf("%d",&a[i]);
		for(int i=1,x,y;i<=n-1;i++)scanf("%d%d",&x,&y),add(x,y),add(y,x);
		lip::dfs_1(1),lip::dfs_2(1,1),dfs(1,0),lip::build(1,1,n);
		for(int i=1;i<=Q;i++)
		{
			int op;
			scanf("%d",&op);
			if(op==1)
			{
				int u,v,val;
				scanf("%d%d%d",&u,&v,&val),lip::modify(u,v,val);
			}
			else
			{
				clear();
				build(),get_rt(hea[1],0),maxx[rt=0]=sum=size[hea[1]],get_rt(hea[1],0),solve(rt);
				for(int j=1;j<=m;j++)printf("%d ",ans[yuan[j]]+1);
				printf("\n");
			}
		}
		return 0;
	}
}
int main()
{
	return lzz::main();
}
```

---


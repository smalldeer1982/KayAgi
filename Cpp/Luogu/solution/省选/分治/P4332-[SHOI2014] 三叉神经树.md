# [SHOI2014] 三叉神经树

## 题目描述

计算神经学作为新兴的交叉学科近些年来一直是学术界的热点。一种叫做 SHOI 的神经组织因为其和近日发现的化合物 SHTSC 的密切联系引起了人们的极大关注。

SHOI 组织由若干个 SHOI 细胞构成，SHOI 细胞之间形成严密的树形结构。每个 SHOI 细胞都有且只有一个输出端,被称为轴突,除了一个特殊的、被称为根细胞的 SHOI 细胞的输出作为整个组织的输出以外,其余细胞的轴突均连向其上级 SHOI 细胞；并且有且只有三个接收端,被称为树突,从其下级细胞或者其它神经组织那里接收信息。SHOI 细胞的信号机制较为简单,仅有 $0$和 $1$ 两种。每个 SHOI 细胞根据三个输入端中 $0$和 $1$ 信号的多寡输出较多的那一种。

现在给出了一段 SHOI 组织的信息，以及外部神经组织的输入变化情况。请你模拟 SHOI 组织的输出结果。

## 说明/提示

- 对于 $10 \%$ 的数据，满足 $1\le n \leq 10^3$，$ 1\le q \leq 10^3$。
- 对于 $30 \%$ 的数据，满足 $1\le n \leq 10^5$，$ 1\le q \leq 10^5$。
- 对于 $100 \%$ 的数据，满足 $1\le n \leq 5\times 10^5$，$ 1\le q \leq 5\times 10^5$。

## 样例 #1

### 输入

```
3
2 3 4
5 6 7
8 9 10
0 0 0 0 1 1 1
5
4
4
5
6
8
```

### 输出

```
1
0
0
1
1
```

# 题解

## 作者：FlashHu (赞：55)

你谷无题解于是来补一发

随便百度题解，发现了不少诸如树剖$log^3$LCT$log^2$的可怕描述。。。。。。

于是来想想怎么利用题目的性质，把复杂度降下来。

首先，每个点的输出状态只有$0/1$，于是每个点的总状态也非常有限，可以根据权值为$1$的儿子数量$0-3$分为四种，记为该点的点权。

我们都会模拟暴力过程——先改叶子节点（先默认为$0$改为$1$），如果它的父亲此时权值为$1$的儿子数量从原来小于$0$的变成大于$0$的，那么父亲的权值也要改。以此类推，直到有一个节点输出状态没有变化，那么它的所有祖先肯定不会变。

通过模拟我们发现，每次修改的一定是一段自底向上的连续区间！

接着也就不难想到，只有当点权为$1$时，才能通过修改点权变成$2$，使输出由$0$变成$1$，从而继续引发祖先的变化。那么我们需要知道的就是，对于每一个叶子节点，它自底向上的连续一段点权为$1$的部分。

再讨论叶子节点$1$改$0$的情况，同理也可以发现我们还要维护自底向上的连续一段点权为$2$的部分。

这个可以树剖（有很多维护法，都是$log^2$的，跳链和链修改都有$log$）正在学树剖，先留个坑，到时候再补。。。

当然可以LCT，讲两个维护法。第一种是用bool值维护区间是否有权值不为$1/2$的点，每次Splay上二分查找最深的不为$1/2$的点，把它伸展上来，右子树做区间修改，这个点做单点修改。

因为写二分比较麻烦（~~其实就是几行的事~~），所以还不如直接维护最深的不为$1/2$点的编号，找都不用找。直接把它伸展上来。修改同上。容易发现这里的LCT连换根都不要。

两种写法都需要注意特判：如果整条从根到叶子的链没有一个不为$1/2$的点，直接做区间修改。

分享一个naive的错误——蒟蒻默认父节点的编号比子节点小，然后pushup直接取$\max$，竟然获得了95分？！调了半天本机对拍又是全AC（自己的数据生成器肯定是父节点的编号比子节点小啦。。。）

刚掉这题后还收获了一点小经验——不要给LCT永久化地贴上常数大的标签！因为少一个$log$，所以$n$越大越有优势（这题$5*10^5$），还不用reverse。看看统计，就知道什么叫LCT全方位（时间、空间、码量）完爆树剖的感觉了哈哈哈哈hhhh

https://www.luogu.org/recordnew/lists?uid=&pid=P4332&status=&sort=1

https://loj.ac/problem/2187/statistics/fastest

```cpp
#include<cstdio>
#include<algorithm>
#define RG register
#define I inline
#define R RG int
#define lc c[x][0]
#define rc c[x][1]
#define G if(++ip==ie)if(fread(ip=ibuf,1,L,stdin))
using namespace std;
const int N=5e5+9,M=1.5e6+9,L=1<<19;
char ibuf[L],*ie=ibuf+L,*ip=ie-1;
int n,f[M],c[N][2],t[N],n1[N],n2[N],v[M],q[M],d[N];
I int max(R x,R y){return x>y?x:y;}
I int in(){
    G;while(*ip<'-')G;
    R x=*ip&15;G;
    while(*ip>'-'){(x*=10)+=*ip&15;G;}
    return x;
}
I bool nrt(R x){
    return c[f[x]][0]==x||c[f[x]][1]==x;
}
I void up(R x){//先右儿子再自己最后左儿子
    if(!(n1[x]=n1[rc])&&!(n1[x]=x*(v[x]!=1)))n1[x]=n1[lc];
    if(!(n2[x]=n2[rc])&&!(n2[x]=x*(v[x]!=2)))n2[x]=n2[lc];
}
I void dn(R x,R tg){//被区间修改的要么都是1要么都是2，直接反转信息
    v[x]^=3;swap(n1[x],n2[x]);t[x]+=tg;
}
I void all(R x){
    if(nrt(x))all(f[x]);
    if(t[x])dn(lc,t[x]),dn(rc,t[x]),t[x]=0;
}
I void rot(R x){
    R y=f[x],z=f[y],k=c[y][1]==x,w=c[x][!k];
    if(nrt(y))c[z][c[z][1]==y]=x;
    f[f[f[c[c[x][!k]=y][k]=w]=y]=x]=z;up(y);
}
I void sp(R x){
    all(x);
    for(R y;nrt(x);rot(x))
        if(nrt(y=f[x]))rot((c[f[y]][0]==y)^(c[y][0]==x)?x:y);
    up(x);
}
I void ac(R x){
    for(R y=0;x;sp(x),rc=y,up(y=x),x=f[x]);
}
int main(){
    n=in();R he,tl=0,i,x,tp,nowrt;//nowrt全局记录根的输出，方便，减小常数
    for(i=1;i<=n;++i)d[f[in()]=f[in()]=f[in()]=i]=3;
    for(;i<=3*n+1;++i)v[q[++tl]=i]=in()<<1;
    for(he=1;he<=tl;++he){//懒得dfs了，直接从下往上拓扑排序预处理
        x=q[he];if(x<=n)up(x);
        v[f[x]]+=v[x]>>1;
        if(!--d[f[x]])q[++tl]=f[x];
    }
    nowrt=v[1]>>1;
    for(R q=in();q;--q){
        tp=(v[x=in()]^=2)-1;//记录当前变化类型
        ac(x=f[x]);sp(x);
        if((~tp?n1:n2)[x]){
            sp(x=(~tp?n1:n2)[x]);
            dn(rc,tp),up(rc);
            v[x]+=tp;up(x);
        }
        else dn(x,tp),up(x),nowrt^=1;//注意特判
        putchar(nowrt|'0');putchar('\n');
    }
    return 0;
}
```

---

## 作者：蒟蒻初音ミク (赞：44)

# 广告

[蒟蒻的blog](https://www.luogu.com.cn/blog/111990/)

# 正文

~~感觉这道题的考察重点是LCT里面的splay？？？~~

首先，蒟蒻在这里感谢[Mital](https://www.luogu.org/space/show?uid=30036)大佬和[FlashHu](https://www.luogu.org/space/show?uid=61325)大佬的提示，因为~~蒟蒻因为树剖标签在树剖上死磕了很久~~。

说一说一些细节~~和正解~~。

首先，每一次修改权值改变的点的集合一定是**某一条自上而下的链，并且不一定是从根开始的，但是一定以被修改点结尾的。**

所以就可以通过维护或者计算的方式通过$LCT$搞出这个链的起点（也就是最上面的点），然后通过$splay$区间修改的方式进行链修改。

问题是怎么求这个起点？？？或者怎么维护这个起点？？？

画一个图：

**PS：黑色表示$1$，白色表示$0$。**

![](https://cdn.luogu.com.cn/upload/image_hosting/rr41o9tz.png)

我们定义$sum_i$表示第$i$个点的儿子当中，颜色为$1$的点的个数。

然后我们可以~~非常惊奇地~~发现：

**1、若被修改点是从$1$修改成$0$，那么从被修改点开始向上，只有$sum=2$的点的颜色改变（从$1$变成$0$）。**

**2、若被修改点是从$0$修改成$1$，那么从被修改点开始向上，只有$sum=1$的点的颜色改变（从$0$变成$1$）。**

所以我们可以求出这个$sum$全部为$2$或者全部为$1$的从上到下的链的起点，然后在$splay$里面修改就行了。

**即：求出最深的$sum \neq 1$或者$sum \neq 2$的点。**

怎么求？？？可以二分，即对于每一个点，维护一个他下面的$sum \neq 2$和$sum \neq 1$的点的个数，然后在$splay$里面二分。

但是这个样子会多一个$log$，我们有更直接的办法：维护这个点。

### 在$splay$里面维护一个$id_1,id_2$，分别表示该子树内深度最深的$sum \neq 1$和$sum \neq 2$的点。

```cpp
struct node{
	int ch[2],id[3],fa,lazy_add,val,sum;
	/*sum表示儿子里面1的数量 
	id[1]表示以该节点为子树的最深的sum不为1的点
	id[2]表示以该节点为子树的最深的sum不为2的点
	lazy_add记录的是sum的加标记 */
}tree[N+10];

inline void up(int t)//向上更新父节点
{
	tree[t].id[1]=tree[tree[t].ch[1]].id[1];
	tree[t].id[2]=tree[tree[t].ch[1]].id[2];
	if(!tree[t].id[1])
	{
		if(tree[t].sum!=1)tree[t].id[1]=t;
		else tree[t].id[1]=tree[tree[t].ch[0]].id[1];
	}
	if(!tree[t].id[2])
	{
		if(tree[t].sum!=2)tree[t].id[2]=t;
		else tree[t].id[2]=tree[tree[t].ch[0]].id[2];
	}
}
```
最后对于主函数里面的修改，分两种情况：

1、如果路径上存在$id_1$或者$id_2$，我们可以把被修改的链上的点的$sum-1/+1$（因为只有这些点的$sum$会变），然后再$pushup$。

2、如果没有$id_1$或者$id_2$，说明这次修改会影响到从该节点到根的所有点，那么就直接整条链修改就行了，同时把$1$节点的颜色取反。

就是这样了，但是：

## 细节真的很多！！！

设当前被修改点为$x$。

1、在修改的时候，不能将被修改的叶子节点也放到$splay$当中（即$access$的时候一定要从$fa[x]$开始$access$），因为叶子节点的$sum$为$0$，那么这个$splay$里面的$id_1,id_2$都是这个叶子节点，那么我们维护的$id_1,id_2$就没有意义了。

2、在把$fa[x]$旋根之后，一定是修改右子树，而不是修改整个子树，因为左子树的信息并不会改变。

3、在修改了右子树之后，不要忘记对$fa[x]$进行单点修改。

~~就因为这些细节，蒟蒻在20分停滞不前了一个下午55555……~~

更多的细节就在代码里面，如果还有不懂的话可以私信哦~~~

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

#define re register
#define ll long long
#define N 1500000

inline int read()
{
	char ch=getchar();
	int x=0,f=1;
	for(;ch>'9'||ch<'0';ch=getchar())if(ch=='-')f=-1;
	for(;ch>='0'&&ch<='9';ch=getchar())x=(x<<1)+(x<<3)+ch-'0';
	return x*f;
}

int n,m;
struct node{
	int ch[2],id[3],fa,lazy_add,val,sum;
	/*sum表示儿子里面1的数量 
	id[1]表示以该节点为子树的最深的sum不为1的点
	id[2]表示以该节点为子树的最深的sum不为2的点
	lazy_add记录的是sum的加标记 */
}tree[N+10];

inline void up(int t)
{
	tree[t].id[1]=tree[tree[t].ch[1]].id[1];
	tree[t].id[2]=tree[tree[t].ch[1]].id[2];
	if(!tree[t].id[1])
	{
		if(tree[t].sum!=1)tree[t].id[1]=t;
		else tree[t].id[1]=tree[tree[t].ch[0]].id[1];
	}
	if(!tree[t].id[2])
	{
		if(tree[t].sum!=2)tree[t].id[2]=t;
		else tree[t].id[2]=tree[tree[t].ch[0]].id[2];
	}
}

inline void add(int t,int x)
{
	tree[t].sum+=x;tree[t].val=tree[t].sum>1; 
	swap(tree[t].id[1],tree[t].id[2]);
	/*这里直接swap就行了，因为进行加标记的子树一定是全部sum为1或者2的子树，这种子树修改之后id[1]和id[2]值会交换。 
    	update 2020.5.30
    	这里蒟蒻解释一下为什么swap就可以了。
        以将整个子树的点sum全部减一为例。
        首先，修改之后的id[2]为肯定就是这个子树里面最深的点了（因为原来他的sum是2，现在他的sum变成1了，所以现在的id[2]就是他了），然后这个最深的点肯定是原来的id[1]（因为他原来是sum=2的点，又是最深的点），所以id[2]=id[1]；
        其次，原来的id[2]在减一之后一定sum不等于1（因为如果减一之后他的sum变成1的话，他原来的sum就一定为2了，那么他就不是id[2]了），又因为这个id[2]下面的点在减一之后全部变成1了，所以他就变成id[1]了。
        综上，修改后的id[2]=原来的id[1]，修改后的id[1]=原来的id[2]，swap就行了。
    */
	tree[t].lazy_add+=x;
}

inline void down(int t)
{
	if(tree[t].lazy_add)
	{
		if(tree[t].ch[0])add(tree[t].ch[0],tree[t].lazy_add);
		if(tree[t].ch[1])add(tree[t].ch[1],tree[t].lazy_add);
		tree[t].lazy_add=0;
	}
}

inline bool nroot(int x)
{
	return tree[tree[x].fa].ch[0]==x||tree[tree[x].fa].ch[1]==x;
}

int st[N+10];

inline void rotate(int x)
{
	int y=tree[x].fa,z=tree[y].fa,k=tree[y].ch[1]==x,w=tree[x].ch[k^1];
	if(nroot(y))tree[z].ch[tree[z].ch[1]==y]=x;
	tree[x].ch[k^1]=y;tree[y].ch[k]=w;
	if(w)tree[w].fa=y;tree[y].fa=x;tree[x].fa=z;
	up(y);up(x);
}

inline void splay(int x)
{
	int top=0,y=x;st[++top]=x;
	while(nroot(y))
	{
		y=tree[y].fa;
		st[++top]=y;
	}
	while(top)down(st[top--]);
	int z;
	while(nroot(x))
	{
		y=tree[x].fa,z=tree[y].fa;
		if(nroot(y))(tree[z].ch[0]==y)^(tree[y].ch[0]==x)?rotate(x):rotate(y);
		rotate(x);
	}
	up(x);
}

inline void access(int x)
{
	for(re int y=0;x;y=x,x=tree[x].fa)
	{
		splay(x);
		tree[x].ch[1]=y;
		up(x);
	}
}

struct ed{
	int to;
	ed *next;
}*edge,*head[N+10];

inline void adde(int u,int v)
{
	edge=new ed;
	edge->to=v;
	edge->next=head[u];
	head[u]=edge;
}

inline void dfs(int x,int f)//第一遍要通过dfs计算出每一个点的val（叶子节点除外） 
{
	tree[x].sum=0;
	int v;
	for(re ed *i=head[x];i;i=i->next)
	{
		v=i->to;
		if(v==f)continue;
		dfs(v,x);
		tree[x].sum+=tree[v].val;
	}
	if(x<=n)tree[x].val=tree[x].sum>1;
}

int main()
{
	n=read();
	int x;
	for(re int i=1;i<=n;++i)
	{
		for(re int j=1;j<=3;++j)
		{
			x=read();tree[x].fa=i;
			adde(x,i);adde(i,x);
		}
	}
	for(re int i=n+1;i<=n*3+1;++i)tree[i].val=read();
	dfs(1,0);
	m=read();int last,w,addtag,ans=tree[1].val;
	while(m--)
	{
		last=read();x=tree[last].fa;
		addtag=tree[last].val?-1:1;
		access(x);splay(x);
		w=tree[x].id[(tree[last].val?2:1)];
		if(w)//中间有一个点会阻止修改的传递。 
		{
			splay(w);
			add(tree[w].ch[1],addtag);up(tree[w].ch[1]);
			tree[w].sum+=addtag;tree[w].val=tree[w].sum>1;up(w);
		}
		else ans^=1,add(x,addtag),up(x);//中间没有阻挡的点，直接更新到根节点。 
		tree[last].val^=1;
		printf("%d\n",ans);
	}
	return 0;
}
```


---

## 作者：liuzhangfeiabc (赞：19)

这么好的题居然luogu上题解这么少……

看到网上很多log^2甚至log^3的做法，这里放一个lct的一个log做法，可能是我的原创做法吧毕竟网上目前似乎没有找到类似思路的题解。

其实这题我的第一感觉是动态dp……说实话这确实像个动态dp模型，我们也可以用类似动态dp的做法来做。

首先，当一个点接收到>=2个1时，输出1，否则输出0。

我们可以在lct中维护一个si，表示它的虚儿子有多少个1传上来。

再维护一个b(i,0/1),表示：i所在的这条重链，如果从链底额外输入一个0/1，从链顶输出的会是什么值。

这是我的做法最大的特点：并非直接维护每个点具体会输出什么，而是维护一整段链的信息。（这里是不是很像动态dp?）

为什么要记一个0/1呢？为了方便合并重链的信息，只要考虑一个0/1的信息从右侧传进来，传到中点时会变成什么，再传到左侧去就行了。

access时只需要用当前点的b(i,0)值修改父亲的s值，修改和查询也都很好操作。

我们会发现这棵lct甚至不需要makeroot，所以无论是代码难度还是运行速度都完爆树剖！

```cpp
#include<bits/stdc++.h>
using namespace std;
#define gc getchar()
#define pc putchar
#define li long long
inline int read(){
	int x = 0,c = gc;
	while(!isdigit(c)) c = gc;
	while(isdigit(c)) x = (x << 1) + (x << 3) + (c ^ '0'),c = gc;
	return x;
}
inline void print(int q){
	if(q >= 10) print(q / 10);
	pc(q % 10 + '0');
}
int n,m,f[2000010],fsts[2000010],nxt[2000010],l[2000010],r[2000010],s[2000010];
bool a[2000010],b[2000010][2];
void dfs(int q){
	for(int i = fsts[q];i;i = nxt[i]){
		if(i <= n) dfs(i);
		s[q] += a[i];
	}
	a[q] = b[q][0] = (s[q] >= 2);
	b[q][1] = (s[q] >= 1);
}
inline bool is(int q){
	return l[f[q]] != q && r[f[q]] != q;
}
inline void ud(int q){
	b[q][0] = (s[q] >= 2);
	b[q][1] = (s[q] >= 1);
	if(r[q]){
		if(b[r[q]][0]) b[q][0] = b[q][1];
		else if(!b[r[q]][1]) b[q][1] = b[q][0];
	}
	if(l[q]){
		if(b[q][0]) b[q][0] = b[q][1] = b[l[q]][1];
		else if(!b[q][1]) b[q][0] = b[q][1] = b[l[q]][0];
		else b[q][0] = b[l[q]][0],b[q][1] = b[l[q]][1];
	}
}
inline void ro(int q){
	int p = f[q];
	if(l[f[p]] == p) l[f[p]] = q;
	else if(r[f[p]] == p) r[f[p]] = q;
	f[q] = f[p];f[p] = q;
	if(l[p] == q){
		l[p] = r[q];r[q] = p;
		if(l[p]) f[l[p]] = p;
	}
	else{
		r[p] = l[q];l[q] = p;
		if(r[p]) f[r[p]] = p;
	}
	b[q][0] = b[p][0];b[q][1] = b[p][1];ud(p);
}
inline void sp(int q){
	while(!is(q)){
		int p = f[q];
		if(!is(p)){
			if((l[f[p]] == p) ^ (l[p] == q)) ro(q);
			else ro(p);
		}
		ro(q);
	}
}
inline void ac(int q){
	int p = 0;
	while(q){
		sp(q);
		s[q] += b[r[q]][0];
		r[q] = p;
		s[q] -= b[p][0];
		ud(q);
		p = q;q = f[q];
	}
}
int main(){
	int i,u;
	n = read();
	for(i = 1;i <= n;++i){
		u = read();f[u] = i;nxt[u] = fsts[i];fsts[i] = u;
		u = read();f[u] = i;nxt[u] = fsts[i];fsts[i] = u;
		u = read();f[u] = i;nxt[u] = fsts[i];fsts[i] = u;
	}
	for(i = n + 1;i <= 3 * n + 1;++i) a[i] = read();
	dfs(1);
	m = read();
	for(i = 1;i <= m;++i){
		u = read();
		ac(f[u]);sp(f[u]);
		a[u] ^= 1;a[u] ? ++s[f[u]] : --s[f[u]];
		ud(u);
		ac(1);sp(1);print(b[1][0]);pc('\n');
	}
	return 0;
}
```

目前2411ms是luogu的rk1。

---

## 作者：Soulist (赞：12)

呐，一道神仙题 ~~（却被某大佬评价称评分过高）~~

首先要考虑什么时候才会导致颜色变化。

$10pts$ 暴力，每次修改暴算答案？

然而我们发现一个点的修改能且只能影响到它的父亲 $/$ 祖先。

如果我们对每个点维护它的三个儿子中 $1$ 的个数。

可以发现，若一个叶子节点由 $0$ 变成了 $1$，那么其会对答案造成什么样的影响呢？

如果其父亲已经有两个及以上$1$或有零个 $1$ ，我们可以发现其叶子节点尽管变成了$1$但并没有导致其父亲的颜色造成变化。

当且仅当其父亲有 $1$ 个 $1$ 的时候其才会导致颜色变化，类似的讨论，我们可以发现，当一个叶子节点由$0->1$后，有且只有其往上走连续的一段都是 $1$ 的数量$1$的点的颜色会发现变化，所以我们可以让其儿子$1$数量（下文称儿子$1$数量为点权）均$+1$，然后对于最后顶部$(top)$的父亲，若$top$是根$(1)$则改变答案(1号点的颜色)，否则将$top$的父亲的点权$+1$

对$1->0$讨论，我们发现也只有从叶子节点开始走连续的一段点权为$2$的点会发生改变，$-1$即可

那么接下来就是实现这个过程了。

$1.O(nlog^3n)$

我们可以用树剖，用线段树维护区间最小值和最大值，当前仅当某个区间的最大值和最小值均为$1/2$时才表示这一连续链的点权都是$1/2$

至于找最上面的位置则可以通过二分/倍增来找，复杂度$O(nlog^3n)$

$2.O(nlog^2n)$

刚刚的那个东西用$LCT$实现的话复杂度就是$O(nlog^2n)$，然而常数问题可能速度相差不大，但听说可以过这道题了。

当然实际上因为这棵树是静态的，所以我们甚至不需要$makeroot,link,split$这些函数。

在巧妙地利用一下这些性质之后我们可以轻易地得到一个较为简洁且常数相对小一些地代码，具体实现的细节：

首先是$link$，因为数据保证合法（总不至于不是一棵树吧）所以我们可以直接连边，只不过连的是$LCT$中的虚边$(t[x].fa = i)$

然后因为这道题的树是静态的，我们如果想得到一条链上的最大最小值怎么做？注意到每次询问的两个点$u,v$一定满足$u$是$v$的祖先，所以我们可以考虑先直接$access(v)$，然后$Splay(u)$，这个时候$u$的右子树就是深度比$u$大的所有点了。

$3.O(nlogn)$

我们其实可以不需要使用倍增，可以考虑用$LCT$维护深度最大的不为 $1/2$ 的点，然后直接将这个点到询问点这一条链$split$出来（注意是在$(2)$中讲的$split$），然后给他们$+1/-1$，然后给父亲$+1/-1$即可。

这样做就是$O(nlogn)$辣。

当然在代码实现上存在一点点细节问题$QAQ$

比如我做修改后会影响到深度最大的不为 $1/2$ 的点。

比如现在考虑$+1$操作$(0->1)$，我们可以发现，$+1$操作执行过程中，最小的不为$1$的点$Splay$了之后其右子树的点权全部都是$1$

我们给它打了一个$+1$标记之后，其子树内的所有点的$1$全部都变成了$2$，这个时候$1$不存在而$2$存在，可以发现我们其实只要$swap(t[x].1,t[x].2)$

类似的对$-1$讨论，我们也只需要 $swap(t[x].1,t[x].2)$

详见代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
    char cc = getchar(); int cn = 0, flus = 1;
    while(cc < '0' || cc > '9') cc = getchar();
    while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
    return cn * flus;
}
const int N = 500000 + 5 ;
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )
#define ls(x) t[x].son[0]
#define rs(x) t[x].son[1]
struct LCT {
    int son[2], fa, add, w[2], col, sum ;
} t[N * 3];

//w[0]表示深度最大的不为1的点，w[1]表示深度最大的不为2的点。
//sum表示点权-这个点的儿子中1的数量，如果sum>=2则这个点的颜色为1
//add是加法标记 
struct E {
    int to, next, w ;  
} e[N * 3]; 
int n, m, head[N * 3], cnt, Ans ;  
void add( int x, int y ) {
    e[++ cnt] = (E){ y, head[x] }, head[x] = cnt ; 
}
//LCT
bool isroot( int x ) { return ( rs(t[x].fa) != x ) && ( ls(t[x].fa) != x ) ; }
void modify( int x, int k ) {
    t[x].sum += k, swap( t[x].w[0], t[x].w[1] ), t[x].add += k ; //首先x本身要+k
	//发现我们只会在一棵本身全都是1/2的一颗树上打标记，最后其实只需要交换1/2标记。
	//然后给这个点的标记 + k 
}
void pushmark( int x ) {
    if( t[x].add )
        modify( ls(x), t[x].add ), modify( rs(x), t[x].add ), t[x].add = 0 ;
}
void pushup( int x ) {
    t[x].w[0] = t[rs(x)].w[0], t[x].w[1] = t[rs(x)].w[1] ; 
    if( t[x].sum != 1 && !t[x].w[0] ) t[x].w[0] = x ; 
    if( !t[x].w[0] ) t[x].w[0] = t[ls(x)].w[0] ; 
    if( t[x].sum != 2 && !t[x].w[1] ) t[x].w[1] = x ; 
    if( !t[x].w[1] ) t[x].w[1] = t[ls(x)].w[1] ; 
}
void rotate( int x ) {
    int f = t[x].fa, ff = t[f].fa, z = rs(f) == x, ch = t[x].son[z ^ 1] ; 
    t[x].fa = ff ; 
    if( !isroot(f) ) t[ff].son[rs(ff) == f] = x ; 
    t[x].son[z ^ 1] = f, t[f].fa = x, t[f].son[z] = ch, t[ch].fa = f ; 
    pushup(f), pushup(x) ; 
}
int st[N], top ;
void Splay( int x ) {
    int now = x; st[++ top] = now ; 
    while( !isroot(now) ) st[++ top] = now = t[now].fa ;
    while( top ) pushmark( st[top --] ) ;
    while( !isroot(x) ) {
        int f = t[x].fa, ff = t[f].fa ; 
        if( !isroot(f) ) ( ( rs(f) == x ) ^ ( rs(ff) == f ) ) ? rotate(x) : rotate(f) ;
        rotate(x) ; 
    }
} 
void access( int x ) {
    for( int y = 0; x; x = t[y = x].fa ) Splay(x), rs(x) = y, pushup(x) ;  
}
//end
inline void dfs( int x ) {
    Next( i, x ) dfs(e[i].to), t[x].sum += ( t[e[i].to].col == 1 ) ;
    if( t[x].sum >= 2 ) t[x].col = 1 ; 
}
void solve( int x, int c ) {
    int u = t[x].fa ; access(u), Splay(u) ;
    int k = t[u].w[c], ad = ( c == 0 ) ? 1 : -1 ; 
    if( k ) Splay(k), modify( rs(k), ad), pushup(rs(k)), t[k].sum += ad, pushup(k) ;
    else modify( u, ad ), Ans ^= 1, pushup(u);  //如果k根本不存在，那么需要修改当前1号点的颜色。 
    printf("%d\n", Ans ) ;
}
signed main()
{
    n = read(); int x1, x2, x3, fr = n + 1, ed = 3 * n + 1;
    
    rep( i, 1, n ) x1 = read(), x2 = read(), x3 = read(), t[x1].fa = i, t[x2].fa = i, 
		t[x3].fa = i, add( i, x1 ), add( i, x2 ), add( i, x3 ) ;
    
    rep( i, fr, ed ) t[i].col = read() ; 
    dfs(1), Ans = t[1].col, m = read() ;
    while( m -- ) x1 = read(), solve( x1, t[x1].col ), t[x1].col ^= 1;
    return 0;
}
```

---

## 作者：万万没想到 (赞：11)

原题传送门：[P4332 [SHOI2014]三叉神经树](https://www.luogu.com.cn/problem/P4332)

最近学了树剖，然后 $2h$ 调完了这道令人 神 清 气 爽 的题目。

题目简介：

给你一个 $3n+1$ 个结点的三叉树，除了叶子节点外的点都有三个儿子，给定叶子节点的值，只可能是 $0/1$ ，非叶子节点的值由三个儿子的值决定，三个儿子中 $1$ 的值多，此节点就是 $1$ ，否则就是 $0$ 。

共有 $m$ 次操作，每次将一个叶子节点的值取反，求取反后根节点的值是 $0$ 还是 $1$ 。

数据范围：

$n \leq 500000,q \leq 500000$

解题思路：

数据如此大，我们略加思索，先画出初始状态的图。

![例子1](https://cdn.luogu.com.cn/upload/image_hosting/nws0vmol.png)

黑色字体是节点的编号，绿色字体是节点的值，暂时找不出规律，继续模拟第一次操作。

![例子2](https://cdn.luogu.com.cn/upload/image_hosting/c3vgpoll.png)

此处的红色字体为非叶子节点儿子中 $1$ 的个数。

我们发现 $1$ 号节点的儿子中 $1$ 的个数由 $1$ 变成 $2$ ，值就由 $0$ 变成 $1$ ，再模拟样例的第二个操作，当儿子中 $1$ 的个数由 $2$ 变成 $1$ ，值就由 $1$ 变成 $0$ 。

模拟完样例我们会发现，对于一个非叶子节点，只有当它的儿子的 $1$ 个数是 $2$ ，且要 $-1$ 时，值才会由 $1$ 变 $0$ ，它的父亲同理，只有当它的儿子的 $1$ 个数是 $1$ ，且要 $+1$ 时，值才会由 $0$ 变 $1$ 。

于是我们求的就是从操作的叶子节点的父亲到根节点的这条路径上，靠近叶子节点的最长相同后缀及其儿子 $1$ 个数，即从根节点至叶子节点的父亲的最长后缀，我们考虑使用树链剖分，用线段树为区间后缀及最右边的儿子数，即颜色，当修改叶子节点时，即开始跳链和判断，统一修改，注意，除了要修改颜色相同的目标后缀，还要修改第一个靠后缀却颜色不一的结点。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1500005;
int n,q,a[maxn],col,cnt,tot,head[maxn],d[maxn],f[maxn],siz[maxn],son[maxn],top[maxn],id[maxn],rk[maxn];
struct node{
	int rmax,rcol,tag;
}tree[maxn<<2];
struct Node{
	int to,nex;
}e[maxn<<1];
inline int Min(register int a,register int b){
	return a<b?a:b;
}
void pushup(int o,int l,int r){
	int mid=(l+r)>>1;
	tree[o].rmax=tree[o<<1|1].rmax,tree[o].rcol=tree[o<<1|1].rcol;
	if(tree[o<<1].rcol==tree[o<<1|1].rcol&&tree[o<<1|1].rmax==r-mid)tree[o].rmax+=tree[o<<1].rmax;
}
void pushdown(int o){
	if(tree[o].tag){
		tree[o<<1].rcol+=tree[o].tag,tree[o<<1|1].rcol+=tree[o].tag;
		tree[o<<1].tag+=tree[o].tag,tree[o<<1|1].tag+=tree[o].tag;
		tree[o].tag=0;
	}
}
void build(int o,int l,int r){
	if(l==r){tree[o].rmax=1,tree[o].rcol=a[rk[l]];return;}
	int mid=(l+r)>>1;
	build(o<<1,l,mid);build(o<<1|1,mid+1,r);
	pushup(o,l,r);
}
int query(int o,int l,int r,int ql,int qr){
	if(r==qr)col=tree[o].rcol;
	if(ql<=l&&r<=qr)return tree[o].rmax;
	pushdown(o);
	int mid=(l+r)>>1,tmp=0;
	if(qr>mid){
		tmp=query(o<<1|1,mid+1,r,ql,qr);
		if(ql<=mid&&tmp==Min(r,qr)-mid&&tree[o<<1].rcol==col)tmp+=query(o<<1,l,mid,ql,qr);//注意！此处是min(r,qr)，因为处于递归中且不能超过递归右边界与目标右边界的最小值
	}
	else if(ql<=mid)tmp=query(o<<1,l,mid,ql,qr);
	return tmp;
}
void update(int o,int l,int r,int ql,int qr,int k){
	if(ql<=l&&r<=qr){tree[o].tag+=k,tree[o].rcol+=k;return;}
	pushdown(o);
	int mid=(l+r)>>1;
	if(ql<=mid)update(o<<1,l,mid,ql,qr,k);
	if(qr>mid)update(o<<1|1,mid+1,r,ql,qr,k);
	pushup(o,l,r);
}
void add(int u,int v){
	e[++cnt].to=v,e[cnt].nex=head[u],head[u]=cnt;
}
void dfs1(int u,int fa){
	d[u]=d[fa]+1,f[u]=fa,siz[u]=1;
	int tmp=0;
	for(int i=head[u];i;i=e[i].nex){
		int v=e[i].to;
		dfs1(v,u);
		siz[u]+=siz[v];
		if(a[v]>1||(v>n&&a[v]))tmp++;
		if(siz[v]>siz[son[u]])son[u]=v;
	}
	if(u<=n)a[u]=tmp;
}
void dfs2(int u,int t){
	id[u]=++tot,rk[tot]=u,top[u]=t;
	if(!son[u])return;
	dfs2(son[u],t);
	for(int i=head[u];i;i=e[i].nex){
		int v=e[i].to;
		if(v==son[u])continue;
		dfs2(v,v);
	}
}
void change(int x,int tmp){
	int res=0,addtmp=(tmp==1?1:-1);
	while(x){
		col=-1;
		res=query(1,1,n,id[top[x]],id[x]);
		if(col!=tmp){update(1,1,n,id[x],id[x],addtmp);return;}
		else if(res!=id[x]-id[top[x]]+1){update(1,1,n,id[x]-res,id[x],addtmp);return;}
		else update(1,1,n,id[top[x]],id[x],addtmp);
		x=f[top[x]];
	}
}
int main(){
	int opt,x,y,z;
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%d%d%d",&x,&y,&z);
		add(i,x),add(i,y),add(i,z);
	}
	for(int i=n+1;i<=3*n+1;++i)scanf("%d",&a[i]);
	dfs1(1,0);
	dfs2(1,1);
	n=3*n+1;
	build(1,1,n);
	scanf("%d",&q);
	for(int i=1;i<=q;++i){
		scanf("%d",&x);
		if(a[x])a[x]=0,change(f[x],2);
		else a[x]=1,change(f[x],1);
		col=-1;
		query(1,1,n,1,1);
		if(col<2)printf("0\n");
		else printf("1\n");
	}
	return 0;
}
```



---

## 作者：yyyyxh (赞：6)

一道 ddp 好题

首先假设节点 $u$ 的三个儿子 $a,b,c$

1 的权值占多数的充要条件为存在两个儿子的权值都为 1

那么可列出方程

$$
p_u=(p_a \land p_b) \lor (p_a \land p_c) \lor (p_b \land p_c)
$$
（感谢 wangrx 学长提供的思路）

一个广义矩阵乘法满足结合律的条件是内层运算有交换律，外层运算对内层运算有分配律

注意到 $\land,\lor$ 都有交换律，互成分配律

此处假设 $a$ 为重儿子，根据分配律逆算，可以提出一个 $p_a$ ，有：
$$
p_u=[p_a \land (p_b \lor p_c)]\lor (p_b \land p_c)
$$
写成矩阵形式，定义广义矩阵乘法为：
$$
a_{i,j}=\bigvee_{k=1}^n b_{i,k} \land c_{k,j}
$$
那么有:
$$
\begin{bmatrix}
p_b \lor p_c&p_b \land p_c\\
0&1
\end{bmatrix}
\begin{bmatrix}
p_a\\ 1
\end{bmatrix}
=
\begin{bmatrix}
p_u\\ 1
\end{bmatrix}
$$

注意当无儿子节点是应乘上单位阵
$$
I=\begin{bmatrix}
1&0\\
0&1
\end{bmatrix}
$$

接下来是 ddp 的套路，把每条重链的轻儿子的所有 dp 值求出来后得到整体的转移矩阵，再进行转移

为了复杂度不那么 naive ，我采用了全局平衡二叉树，将每条重链按深度重构成一颗 bst ，再按 LCT 的方式连接起来，注意重构时为了保证深度，每次以轻子树大小为权，二分链的带权重心作为根，递归建树，深度 $O(\log n)$

维护 bst 上一颗子树的矩阵连乘积 $sm$，修改时仅用修改当前节点到根的路径上的 $sm$ 矩阵和经过的重链链顶节点的 dp 值即可，总时间复杂度 $O(n \log n)$

就算有矩阵的大常数，也轻松跑进第一版

注意一点，链顶节点不一定是 bst 的根，因此需要开个数组记录

个人认为 ddp 相对 LCT 好想很多（而且我觉得可能比 LCT 容易写一些，因为代码虽然看起来长，实际上矩阵和快读占了多数）

## Code:
```cpp
#include <bits/stdc++.h>
#define getchar() (ipos==iend and (iend=(ipos=_ibuf)+fread(_ibuf,1,__bufsize,stdin),ipos==iend)?EOF:*ipos++)
#define putchar(ch) (opos==oend?fwrite(_obuf,1,__bufsize,stdout),opos=_obuf:0,*opos++=(ch))
#define __bufsize (1<<20)
using namespace std;
char _ibuf[__bufsize],_obuf[__bufsize],_stk[20];
char *ipos=_ibuf,*iend=_ibuf,*opos=_obuf,*oend=_obuf+__bufsize,*stkpos=_stk;
struct END{~END(){fwrite(_obuf,1,opos-_obuf,stdout);}}__;
inline int read(){
    int x=0,ch;
    for(;!isdigit(ch);ch=getchar());
    for(x=0;isdigit(ch);ch=getchar())x=(x<<3)+(x<<1)+(ch^48);
    return x;
}
struct mat{bool s[2][2];mat(){s[1][1]=s[0][0]=1;s[1][0]=s[0][1]=0;}};
mat operator *(const mat x,const mat y){
	mat t;
	t.s[0][0]=(x.s[0][0] and y.s[0][0]) or (x.s[0][1] and y.s[1][0]);
	t.s[0][1]=(x.s[0][0] and y.s[0][1]) or (x.s[0][1] and y.s[1][1]);
	t.s[1][0]=(x.s[1][0] and y.s[0][0]) or (x.s[1][1] and y.s[1][0]);
	t.s[1][1]=(x.s[1][0] and y.s[0][1]) or (x.s[1][1] and y.s[1][1]);
	return t;
}
void print(const mat x){
	printf("%d %d\n",x.s[0][0],x.s[0][1]);
	printf("%d %d\n",x.s[1][0],x.s[1][1]);
} 
const int _=3000003;
int pa[_],pb[_],pc[_],sz[_]; 
int fa[_],lc[_],rc[_],up[_];
bool pu[_]; 
mat vl[_],sm[_];
int n,q,rt;
void dfs(int u){
	sz[u]=1;
	if (u>n){
		vl[u].s[0][0]=pu[u];
		vl[u].s[0][1]=0;
		vl[u].s[1][0]=1;
		vl[u].s[1][1]=0; //叶子结点应存储初始矩阵
		return;
	}
	dfs(pa[u]); sz[u]+=sz[pa[u]];
	dfs(pb[u]); sz[u]+=sz[pb[u]];
	dfs(pc[u]); sz[u]+=sz[pc[u]];
	if (sz[pb[u]]>sz[pa[u]]) swap(pa[u],pb[u]);
	if (sz[pc[u]]>sz[pa[u]]) swap(pa[u],pc[u]); //注意 a 为重儿子，保证复杂度
	pu[u]=(pu[pa[u]]&&pu[pb[u]])||(pu[pa[u]]&&pu[pc[u]])||(pu[pb[u]]&&pu[pc[u]]);
	vl[u].s[0][0]=pu[pb[u]]||pu[pc[u]];
	vl[u].s[0][1]=pu[pb[u]]&&pu[pc[u]];
	vl[u].s[1][0]=0;
	vl[u].s[1][1]=1;
}
int stk[_],tp;
int tr(int L,int R){
	if (L>R) return 0;
	int l=L,r=R;
	while (l<r){
		int t=(l+r)>>1;
		if (2*sz[stk[t+1]]<=sz[stk[L]]+sz[stk[R+1]]) r=t;
		else l=t+1; //轻子树大小等于子树大小减去重子树大小，因此加减相消以后可以得到二分平衡条件
	}
	int k=stk[l];
	lc[k]=tr(L,l-1); rc[k]=tr(l+1,R);
	if (lc[k]) fa[lc[k]]=k;
	if (rc[k]) fa[rc[k]]=k;
	sm[k]=sm[lc[k]]*vl[k]*sm[rc[k]];
	return k;
}
int bld(int u){
	for (int i=u; i<=n; i=pa[i]){
		fa[bld(pb[i])]=i;
		fa[bld(pc[i])]=i;
	}
	for (int i=u; i; i=pa[i]) stk[++tp]=i,up[i]=u;
	int t=tr(1,tp);
	while (tp) stk[tp--]=0; //注意弹栈
	return t; 
}
void upd(int u){
	vl[u].s[0][0]^=1;
	while (u){
		sm[u]=sm[lc[u]]*vl[u]*sm[rc[u]];
		if (lc[fa[u]]!=u&&rc[fa[u]]!=u){
			pu[up[u]]=sm[u].s[0][0]; //修改链顶p值
			if (fa[u]){
				vl[fa[u]].s[0][0]=pu[pb[fa[u]]]||pu[pc[fa[u]]];
				vl[fa[u]].s[0][1]=pu[pb[fa[u]]]&&pu[pc[fa[u]]]; 
			}
		}
		u=fa[u];
	}
}
int main(){
	n=read();
	for (int i=1; i<=n; i++) pa[i]=read(),pb[i]=read(),pc[i]=read(); 
	for (int i=n+1; i<=3*n+1; i++) pu[i]=read();
	dfs(1); rt=bld(1);
	q=read();
	while (q--){
		int u=read();
		upd(u);
		if (sm[rt].s[0][0]) putchar('1');
		else putchar('0');
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：too_later (赞：4)

[这里看题面](https://www.luogu.com.cn/problem/P4332)

### 题意

维护一棵这样的树：

- 每个点有 $3$ 个端口，输入端和输出端。输出端（往树的深度更小的地方连接的）个数 $\le 1$。

- 如果一个点输入端权值为 $1$ 的个数 $\ge 2$，那么这个点的权值为 $1$，否则为 $0$。

- 支持动态修改叶子结点，修改后询问根节点的权值。

- $1\le n \le 5 \times 10^5$

### 思路：

模拟，每次更改一个子节点的信息，它的父亲能改变权值，当且仅当它的父亲还有 $1$ 或 $2$ 个点权值为 $1$。（这里的 $1$ 或 $2$ 个权值取决于叶子结点改变的权值）

那么再开一个 $val$ 数组记录其儿子权值为 $1$ 的个数。

那么我们维护这棵树中，叶子结点到根节点深度最大的 $val \ne 1$ 或者 $val \ne 2$ 的。

这个可以用 LCT ，每次维护的 splay 中右子树的深度大于他，左子树的深度小于他。那么直接在右子树中修改，这个点单调修改就行了。（连续修改的区间）

用一个 tag 来维护是否需要修改。每次 access(x),splay(x)，这个时候 x 到根节点是一个 splay，直接在 x 上做文章就行了。

要注意的细节：

1. 每次都是从 $fa_x$ 开始 splay 的，如果从叶子节点开始的话，那么维护的最大深度的 val 就没有任何意义了（叶子结点不应该维护 val ）

2. 这个 up 操作是跟 ls 和 rs 的顺序有关的，在 up 之前一定要 down(ls),down(rs),（或者懒标记用另一种传法）。

3. （仅个人）：三目运算符的根本原则是

```
if(x) then y
if(!x) then z
```
所以不能在 y 会改变 x 的情况下使用三目运算符。

### Code:

```cpp
#include <bits/stdc++.h>
using namespace std;
#define I inline
#define RI register int
#define CI const int
#define W while
#define ls ch[p][0]
#define rs ch[p][1]
#define N 5000005

int n, m, x, y, z, k, cnt, ans, to[N * 2], head[N * 2], nxt[N * 2], son[N][3];
int top, val[N * 3], ch[N][2], id[N][3], f[N], st[N], tag[N];

I void down(CI p) {
    if (!tag[p])
        return;
    swap(id[p][1], id[p][2]), tag[ls] ^= 1, tag[rs] ^= !(tag[p] = 0), val[p] ^= 3;
}
I void up(CI p) {
    down(ls), down(rs);
    id[p][1] = !id[rs][1] ? val[p] == 1 ? id[ls][1] : p : id[rs][1];
    id[p][2] = !id[rs][2] ? val[p] == 2 ? id[ls][2] : p : id[rs][2];
}
I bool get(CI p) { return p == ch[f[p]][1]; }
I bool isroot(CI p) { return p != ch[f[p]][0] && p != ch[f[p]][1]; }
I void rotate(CI x) {
    RI y = f[x], z = f[y], k = get(x);
    if (!isroot(y))
        ch[z][ch[z][1] == y] = x;
    f[ch[y][k] = ch[x][!k]] = y;
    f[f[ch[x][!k] = y] = x] = z, up(y), up(x);
}
I void splay(CI p) {
    RI i = p, fa;
    st[top = 1] = p;
    while (!isroot(i)) st[++top] = i = f[i];
    while (top) down(st[top--]);
    for (i = p; fa = f[i], !isroot(i); rotate(i))
        if (!isroot(fa))
            rotate(get(i) == get(fa) ? fa : i);
}
I void access(CI x) {
    RI q, p = x;
    for (q = 0; p; q = p, p = f[p]) splay(p), rs = q, up(p);
}

I void add(CI x, CI y) { to[++cnt] = y, nxt[cnt] = head[x], head[x] = cnt; }
I int dfs(CI u, CI fa) {
    if (u > n)
        return val[u];
    RI tot = 0, v;
    for (RI i = head[u]; i; i = nxt[i])
        if ((v = to[i]) != fa)
            val[u] += dfs(v, u);
    return up(u), val[u] > 1;
}

int main() {
    RI i;
    for (scanf("%d", &n), i = 1; i <= n; i++)
        scanf("%d%d%d", &x, &y, &z), add(i, x), add(x, i), 
        f[x] = f[y] = f[z] = i, add(y, i), add(i, y), add(i, z), add(z, i);
    for (i = n + 1; i <= 3 * n + 1; i++) scanf("%d", &val[i]);
    dfs(1, 0), ans = val[1] > 1, scanf("%d", &m);
    while (m--) {
        scanf("%d", &x), y = f[x], z = (val[x] ^= 1) ? 1 : -1;
        access(y), splay(y);
        if (k = id[y][z == 1 ? 1 : 2])
            splay(k), tag[ch[k][1]] ^= 1, val[k] += z, up(k);
        else
            ans ^= 1, tag[y] ^= 1;
        printf("%d\n", ans);
    }
    return 0;
}

```

---

## 作者：_ctz (赞：4)

历经一下午+一晚上+半个上午终于切掉。。。

一道LCT好题，重点是维护什么信息和各种细节的处理。

一开始是想用LCT维护一下三个儿子，用类似于虚子树的东西更新自己。不过这样会出现一个问题：

![](https://cdn.luogu.com.cn/upload/pic/51666.png)

比如说这是x、x所在的实链的splay、x的两个虚儿子，z是x的实儿子。注意在本题中，每个点必须**直接**由它的三个儿子更新。但是z的信息先经过了y才进一步更新了x，就会导致信息不准确。

换一种思路。先想一种暴力些的做法：

修改一个点，它的权值变了，它的父节点就有可能改变，那就向上走看一下它的父节点是否需要更新。如果父节点权值会变，那么它的祖父就有可能会变。如此一直走，直到走到根或某个祖先不会改变权值，停止。

不过，这种做法会被构造的树给卡掉（比如把非叶子节点排成一条链，复杂度就会退化成$O(mn)$）。它的瓶颈就在于向上走的过程，复杂度直接由树高决定。那么如果知道每个点走到哪会停就好了。

考虑走到哪里会停，即什么样的节点不会被修改。

首先容易想到三个儿子都是同样的颜色的节点不会被更新。于是~~愉快地~~去敲代码，然而写了对拍始终不过。

还少情况。上图直观来看：

![](https://cdn.luogu.com.cn/upload/pic/51668.png)

比如我要改点x，同样对k无影响。也就是说：

假设我要改一个本来为0的点，那么它的祖先中为1的点就不会被改（改0点只会让1更多，则为1的点就不可能被改了）

造个LCT，每个点维护一下深度最大的权值为0的点、为1的点、儿子是同一种权值的点，修改时打通到x的实链，根据x的权值取一下深度最大的点（假设为y），对x到y进行修改。

在维护第三种情况时我用的方法是：把0看作-1，dfs预处理好每个点权值之和（儿子为负就-1，为正就+1）。这样权值为3/-3的就是满足这个条件的点。修改链时用加法修改即可。

最后是注意细节，维护的东西比较神奇，注意好每个地方对这三个值的影响，及时修改。

时间复杂度：$O(nlog{n})*\text{LCT巨大的常数}$

（仅提供思路，就不放我~~丑陋无比、常数巨大、极其复杂、连我自己都看不懂~~的代码了）

---

## 作者：KokiNiwa (赞：2)

# [SHOI2014]三叉神经树

这是一个正常的```LCT```题。

## 题解

对于一次修改，无非就是修改一条链的某一部分。比如这次修改的是叶子节点```a```，那么首先```access(a)```。然后对于那个维护这个链的```splay```，要看哪些东西是被修改过的。那么我们看这次修改是把```0->1```还是把```1->0```。就以从$0$改成$1$为例。设一个点的权值为这个点儿子中有多少个$1$，那么如果从$0$到$1$，一定就是更改了自底向上的一段全都为$1$的部分。一个点维护一个点向上深度最深的非权值$1$的结点，和权值非$2$的结点，当然这在$splay$里面的就是用一个结点维护当前节点的子树中最深的不为```1```或者不为```2```的结点。这还需要区间加，因为每一次都需要把一个点的所有为$1$的祖先都要加$1$，所以我们需要用一个变量$tag$当作延迟标记。当然这么空口说没什么用。需要写代码使劲避免错误！

## 代码

[Link](https://paste.ubuntu.com/p/srTf4ZZGjz/)

---

## 作者：Piwry (赞：1)

推这题的性质（其实应该说是 lct/树剖 的性质？）的过程很有趣qwq

~~（虽然后面调代码差点要了我的命 \fad）~~

熟悉 lct/树剖 中的 splay/线段树 的作用应该会很有帮助；因为其实 lct/树剖 就是将树分治为链维护，而每个 splay/线段树 维护的就是一个序列问题

## 解析

先考虑改变某父亲为 $x$ 的外界输入时会发生什么事

可以发现，若树中有结点（细胞）的输出改变了，它们一定是从 $x$ 开始往上**连续的一段**，也就是说其是路径 $p(1, x)$ 的一个**后缀**

如果是将 “0” 的外界输入改为 “1”，那么该后缀中每个结点的儿子状态都应当为 $\{0, 0, 1\}$（无序）的 “临界状态”；如果是将 “1” 改为 “0”，那么儿子状态就为 $\{0, 1, 1\}$

考虑对每个结点统计儿子中 “1” 的数量，设为 `typ`。我们实际上就是要知道 $p(1, x)$ 最长的指定颜色（`typ` 为 $1$ 或 $2$）后缀中深度最浅的结点；设其为 $y$，当且仅当 $y$ 为根（$1$）时，根的输出才会改变。每次修改后，这整个后缀都会被染色，而该后缀的父亲（如果存在）的 `typ` 则会增减一（或者理解为后缀与后缀父亲的 `typ` 都增减一也行；而细胞输出我们并不需要显式地维护）

于是就可以想到用 树剖/lct 来维护这个链信息

对于维护，比较简单，只需在区间合并时按意义维护就行

对于修改，区间修改可以考虑打标记；但我们需要在修改后**不依赖儿子信息**地维护后缀中深度最浅的结点（否则就要把标记一直推到叶节点...打标记就没意义了）

如果该次操作是将 “0” 改为 “1”，那么修改后该区间一定就**不再含有** `typ` 为 $1$ 的结点，且全为`typ` 为 $2$ 的结点，因此 `typ` 为 $1$ 的后缀就为空，而 `typ` 为 $2$ 的后缀就是整段区间。若是将 “1” 改为 “0”，处理也类似

### Lct 维护区间信息

实际上就是要在 Lct 每个 Splay 上维护链的区间信息；这和线段树会有些不一样

具体实现只需考虑这么一张图：

![splay-seg](https://cdn.luogu.com.cn/upload/image_hosting/92h5icuc.png)

（每个结点下面的中括号表示其管辖的区间范围）

## CODE

这里的实现是 lct

代码实现得可能不是很优秀...例如那个区间赋值操作其实可以改为区间加/减 \kk

```cpp
#include <cstdio>

const int MAXN =5e5+20;

/*------------------------------Lct------------------------------*/

namespace Lct{
	int typ[MAXN];/*结点类型，0->{000}, 1->{001}, 2->{011}, 3->{111} ( "{.}" 指无序 )*/
	int suf_001_top[MAXN], suf_011_top[MAXN];/*后缀，深度最浅的 {001}, {011}*/
	int top_id[MAXN];/*当前 splay 子树中最浅的结点*/
	bool tag_0t1[MAXN], tag_1t0[MAXN];/*{001}->{011}, {011}->{001}*/
	
	namespace Splay{
		int ch[2][MAXN], fa[MAXN];
		
		inline void pushdown(const int &x){
			if(tag_0t1[x]){
				typ[x] =2;
				suf_001_top[x] =0, suf_011_top[x] =top_id[x];
				tag_0t1[ch[0][x]] =tag_0t1[ch[1][x]] =1;
				tag_1t0[ch[0][x]] =tag_1t0[ch[1][x]] =0;/*<- 注意清空另一标记*/
				tag_0t1[x] =0;
			}
			else if(tag_1t0[x]){
				typ[x] =1;
				suf_001_top[x] =top_id[x], suf_011_top[x] =0;
				tag_1t0[ch[0][x]] =tag_1t0[ch[1][x]] =1;
				tag_0t1[ch[0][x]] =tag_0t1[ch[1][x]] =0;
				tag_1t0[x] =0;
			}
		}
		
		inline void pushup(const int &x){
			if(ch[0][x])
				pushdown(ch[0][x]);
			if(ch[1][x])
				pushdown(ch[1][x]);
			suf_001_top[x] =0, suf_011_top[x] =0;
			if(ch[1][x]){/*先继承右儿子*/
				suf_001_top[x] =suf_001_top[ch[1][x]];
				suf_011_top[x] =suf_011_top[ch[1][x]];
			}
			if(!ch[1][x] || suf_001_top[ch[1][x]] == top_id[ch[1][x]])
				if(typ[x] == 1){/*处理当前结点*/
					suf_001_top[x] =x;
					if(ch[0][x] && suf_001_top[ch[0][x]] != 0)/*最后处理左儿子*/
						suf_001_top[x] =suf_001_top[ch[0][x]];
				}
			if(!ch[1][x] || suf_011_top[ch[1][x]] == top_id[ch[1][x]])
				if(typ[x] == 2){
					suf_011_top[x] =x;
					if(ch[0][x] && suf_011_top[ch[0][x]] != 0)
						suf_011_top[x] =suf_011_top[ch[0][x]];
				}
			
			if(ch[0][x])
				top_id[x] =top_id[ch[0][x]];
			else
				top_id[x] =x;
		}
		
		inline bool is_top(const int &x){ return (fa[x] == 0 || (ch[0][fa[x]] != x && ch[1][fa[x]] != x)); }
		
		inline bool get_type(const int &x){ return ch[1][fa[x]] == x; }
		
		inline void rotate(const int &x){
			bool typ_x =get_type(x);
			int y =fa[x], z =fa[y], a =ch[!typ_x][x];
			fa[x] =z; if(!is_top(y)) ch[get_type(y)][z] =x;
			fa[y] =x, ch[!typ_x][x] =y;
			fa[a] =y, ch[typ_x][y] =a;
			pushup(y);
		}
		
		void pushall(const int &x){
			if(!is_top(x))
				pushall(fa[x]);
			pushdown(x);
		}
		
		void splay(const int &x){
			pushall(x);
			for(; !is_top(x); rotate(x))
				if(!is_top(fa[x])){
					if(get_type(fa[x]) == get_type(x))
						rotate(fa[x]);
					else
						rotate(x);
				}
			pushup(x);
		}
	}
	using namespace Splay;
	
	void access(const int &x){
		for(int pre =0, top =x; top; pre =top, top =fa[top]){
			splay(top);
			ch[1][top] =pre;
			pushup(top);
		}
	}
	
	inline void link(const int &x, const int &y){
		fa[x] =y;
	}
	
	inline void query_pre(const int &x){
		access(x), splay(x);
	}
	
	inline void updata(const int &x, const bool &opt/*0->{001}t{110}, 1->{110}t{001}*/){
		splay(x);
		if(opt == 0){
			++typ[x];
			if(ch[1][x])
				tag_0t1[ch[1][x]] =1;
		}
		else{
			--typ[x];
			if(ch[1][x])
				tag_1t0[ch[1][x]] =1;
		}
		pushup(x);
	}
	
	inline void updata_all(const bool &opt){
		splay(1);
		if(opt == 0)
			tag_0t1[1] =1;
		else
			tag_1t0[1] =1;
	}
}
using Lct::link;
using Lct::query_pre;
using Lct::updata;
using Lct::updata_all;

/*------------------------------Array------------------------------*/

bool state[MAXN*3];/*细胞 / 外界输入 的状态*/
int fa[MAXN*3];/*细胞 / 外界输入 的父亲*/

/*------------------------------Dfs------------------------------*/

int son[3][MAXN];

/*V- 注意父亲下标不一定小于儿子，因此必须要 dfs 建图 ( 来自 debug 1h+ \kk )*/
void dfs(const int &u, const int &n){
	if(u != 1)
		link(u, fa[u]);
	for(int i =0; i < 3; ++i){
		if(son[i][u] <= n)
			dfs(son[i][u], n);
		else
			Lct::typ[u] +=state[son[i][u]];
	}
	state[u] =(Lct::typ[u] > 1);
	if(u != 1 && state[u])
		++Lct::typ[fa[u]];
}

/*------------------------------Main------------------------------*/

inline int read(){
	int x =0; char c =getchar();
	while(c < '0' || c > '9')c =getchar();
	while(c >= '0' && c <= '9') x =(x<<3)+(x<<1)+(48^c), c =getchar();
	return x;
}

int main(){
	int n =read();
	for(int i =1; i <= n; ++i)
		for(int j =0; j < 3; ++j){
			int x =read();
			fa[x] =i;
			son[j][i] =x;
		}
	for(int i =n+1; i <= 3*n+1; ++i)
		state[i] =read();
	
	dfs(1, n);
	bool state_root =state[1];/*事实上 state[1~n] 之后都没用了*/
	for(int i =1; i <= n; ++i)
		Lct::pushup(i);
	
	for(int i =0, q =read(); i < q; ++i){
		int x =read();
		query_pre(fa[x]);
		if(state[x] == 0){
			if(Lct::suf_001_top[fa[x]] == 1){
				state_root =1;
				updata_all(0);
			}
			else if(Lct::suf_001_top[fa[x]] != 0)
				updata(fa[Lct::suf_001_top[fa[x]]], 0);
			else
				updata(fa[x], 0);
		}
		else{
			if(Lct::suf_011_top[fa[x]] == 1){
				state_root =0;
				updata_all(1);
			}
			else if(Lct::suf_011_top[fa[x]] != 0)
				updata(fa[Lct::suf_011_top[fa[x]]], 1);
			else
				updata(fa[x], 1);
		}
		state[x] ^=1;
		putchar('0'+state_root);
		putchar('\n');
	}
}
```

---


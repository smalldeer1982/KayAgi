# [COCI 2017/2018 #2] ​​Garaža

## 题目描述

最近，Slavko 一直在研究自然数序列。他认为一个序列是有趣的，如果序列中所有元素的最大公约数大于 1。

昨天，他在车库里找到了一个由 N 个自然数组成的序列。由于他感到非常无聊，他决定通过提出简单的查询来打发时间。每个查询可以是以下两种类型之一：

1. 将序列中位置 X 的值更改为 V。

2. 确定序列中区间 [L, R] 内包含的有趣连续子数组的数量。

## 说明/提示

**第一个测试用例的说明：**

从第 $2$ 个位置到第 $5$ 个位置的区间由数字 (4, 3, 9, 1) 组成。在其中，有以下有趣的连续子数组（用方括号表示）：**[4]** 3 9 1, 4 **[3]** 9 1, 4 3 **[9]** 1, 4 **[3 9]** 1。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
5 1
8 4 3 9 1
2 2 5
```

### 输出

```
4```

## 样例 #2

### 输入

```
5 3
2 3 6 4 1
2 1 4
1 3 1
2 3 5
```

### 输出

```
6
1
```

## 样例 #3

### 输入

```
4 3
2 2 2 2
2 1 4
1 2 3
2 1 4
```

### 输出

```
10
5```

# 题解

## 作者：yhgalaxy (赞：6)

​	如果对整个序列询问一次，有一种常见的分治方法：对于区间 $[l,r]$，答案为 $[l,mid]$ 内的答案+ $[mid,r]$ 内的答案+跨过区间终点的答案。我们可以对 $[l,mid]$ 求后缀gcd记为a，对 $[mid,r]$ 求前缀gcd记为b，跨过终点的答案即满足 $\gcd (a_i,b_j) > 1$ 的i和j的对数，由于a和b数组都有单调性，可以使用双指针扫描求出答案，总时间复杂度 $O(n\log n)$。如果我们用线段树维护这个分治，可以支持修改操作，但是复杂度瓶颈在于每次合并信息是 $O(n)$ 的。注意到gcd有一个性质：每次加入一个数，gcd要么不变，要么至多变为原来的1/2，所以把gcd相同的段缩在一起，最多有log段，这样线段树每个节点可以记录前缀、后缀gcd缩完之后的数组，合并标记时暴力扫描合并，统计答案仍然用之前的方法，并且把相同段再次缩起来即可，合并复杂度 $O(\log a_i)$，询问时将相邻区间按照线段树上一样合并，总时间复杂度 $O(n\log n\log a_i)$。

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <algorithm>
#include <vector>
using namespace std;

#define Rep(i,l,r) for (int i = (l); i <= (r); ++ i)
#define RepD(i,r,l) for (int i = (r); i >= (l); -- i)
#define RepG(i,x) for (int i = hd[x]; i; i = e[i].nxt)
#define mkp make_pair
#define uu first
#define vv second
#define ls (o<<1)
#define rs (o<<1|1)

typedef long long ll;
typedef pair <int, int> pii;

const int N = 2e5+5;

int n, q, a[N];
struct node {
    vector <pii> pr, su; ll s;
    node () {pr.clear(), su.clear(), s = 0;}
} tr[N<<2];

int gcd (int x, int y) {return y? gcd (y, x%y): x;}

inline vector <pii> hb (vector <pii> x, vector <pii> y, int ty) {
    if (x.empty()) return y; if (y.empty()) return x;
    if (ty) reverse (x.begin(), x.end()), reverse (y.begin(), y.end());
    vector <pii> res; res.clear(); int szx = x.size()-1, szy = y.size()-1; pii t;
    Rep(i,0,szx) t = x[i], res.push_back(t);
    Rep(i,0,szy) {
        int gc = gcd (x[szx].uu, y[i].uu);
        if (gc==t.uu) t.vv = y[i].vv, res[res.size()-1].vv = t.vv+x[szx].vv;
        else t.uu = gc, t.vv = y[i].vv, res.push_back(mkp(t.uu,t.vv+x[szx].vv));
    }
    if (ty) reverse (res.begin(), res.end());
    return res;
}

inline node mg (node x, node y) {
    node res; res.s = x.s+y.s;
    res.pr = hb (x.pr, y.pr, 0), res.su = hb (y.su, x.su, 1);
    int szx = x.su.size()-1, szy = y.pr.size()-1;
    if (szx<0 || szy<0) return res;
    int j = 0;
    Rep(i,0,szx) {
        while (j<=szy && gcd (x.su[i].uu, y.pr[j].uu)>1) ++ j;
        ll t = x.su[i].vv; if (i<szx) t -= x.su[i+1].vv;
        if (j) res.s += t*y.pr[j-1].vv;
    }
    return res;
}

inline void fz (node &x, int v) {
    x.pr.clear (), x.su.clear ();
    x.pr.push_back(mkp(v,1)), x.su.push_back(mkp(v,1));
    x.s = (v>1);
}

inline void pushup (int o) {tr[o] = mg (tr[ls], tr[rs]);}

void build (int o, int l, int r) {
    if (l==r) {fz (tr[o], a[l]); return;}
    int mid = (l+r)>>1;
    build (ls, l, mid), build (rs, mid+1, r);
    pushup (o);
}

void modi (int o, int l, int r, int q, int v) {
    if (l==r) {fz (tr[o], v); return;}
    int mid = (l+r)>>1;
    if (q<=mid) modi (ls, l, mid, q, v);
    else modi (rs, mid+1, r, q, v);
    pushup (o);
}

node qans (int o, int l, int r, int ql, int qr) {
    if (ql<=l && qr>=r) return tr[o];
    int mid = (l+r)>>1; node res;
    if (ql<=mid && qr>mid) {
        res = mg (qans (ls, l, mid, ql, qr), qans (rs, mid+1, r, ql, qr));
        return res;
    }
    else if (ql<=mid) res = qans (ls, l, mid, ql, qr);
    else if (qr>mid) res = qans (rs, mid+1, r, ql, qr);
    return res;
}

inline int read () {
    int z = 0, f = 1; char c = getchar ();
    while (c<'0' || c>'9') {if (c=='-') f = -1; c = getchar ();}
    while (c>='0' && c<='9') z = z*10+c-'0', c = getchar ();
    return z*f;
}

int main () {
    int ty, l, r, x, v;
    n = read (), q = read ();
    Rep(i,1,n) a[i] = read ();
    build (1, 1, n);
    while (q --) {
        ty = read ();
        if (ty==1) x = read (), v = read (), modi (1, 1, n, x, v);
        else l = read (), r = read (), printf ("%lld\n", qans (1, 1, n, l, r).s);
    }
    return 0;
}
```

---

## 作者：nullqtr_pwp (赞：5)

题意：单点修改；给定区间，查询有多少子区间的 $\gcd>1$。

考虑只查询一次。这种子序列计数问题容易想到分治。

设当前递归到 $[l,r]$，设要找的是有多少满足条件的 $[L,R]\in[l,r]$。我们只需要计数跨区间的（因为 $L,R$ 都在一个区间的可以递归求解），即 $L\in [l,mid],R\in(mid,r]$ 的数量。

注意到 $\text{gcd}$ 是单调不增的。可以对左区间算后缀 $\gcd$ 和，右区间算前缀 $\gcd$ 和。注意到这两个的单调性，可以双指针求，具体就是右指针在 $mid+1$ 往右扫，左指针在 $l$ 往右扫。可以 $O(len)$ 求解，其中 $len$ 是区间的长度。结合分治的复杂度是 $O(n\log n)$。

考虑拓展到线段树上。因为线段树本身就是分治的结构，我们可以考虑对每个线段树的节点维护前缀 $\gcd$ 和与后缀 $\gcd$ 和以及该区间的答案，这样具有可合并性，这些左子的信息和右子的信息可以合并得到该节点的答案，符合线段树的信息可合并性。

但是直接莽会寄，因为直接维护前缀和，后缀和的时空复杂度都是爆的。注意到前缀和，后缀和的更新方式是 $\gcd$，注意到 $a\ne b$ 时有 $\gcd(a,b)\leq \lfloor\dfrac{a}{2}\rfloor$（不妨设 $a\ge b$），因此 $\gcd$ 和的种类数是 $\log A$ 的（$A$ 是值域，对这个结论的解释是每次至少减半），所以我们可以维护前缀后缀和的种类以及出现的位置，方便计算答案。

具体就是用若干个 ```pair<int,int>```，分别描述该位置上 $\gcd$ 和的值和第一次出现这个值的位置。而对于一个节点，最多会有 $\min(r-l+1,\log A)$ 个。

然后直接线段树维护这些前缀 $\gcd$ 和，后缀 $\gcd$ 和，区间答案即可。唯一的难点就是合并信息。这个的话就是先继承左子和右子的答案，然后使用双指针计算跨区间的 $[L,R]$。然后更新前缀 $\gcd$ 和，后缀 $\gcd$ 和就好了。

总时间复杂度 $O(n\log n\log A)$。

```cpp
// Problem: P4435 [COCI2017-2018#2] Garaža
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P4435
// Memory Limit: 500 MB
// Time Limit: 4000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
#define ll long long
#define pb push_back
#define fi first
#define se second
#define mx3(a,b,c) ((a>b?a:b)>c?(a>b?a:b):c)
#define mn3(a,b,c) ((a<b?a:b)<c?(a<b?a:b):c)
#define infll 1e16
#define inf 1e9
#define pii pair<int,int>
#define F(i,a,b) for(int i=a;i<=(b);i++)
#define dF(i,a,b) for(int i=a;i>=(b);i--)
#define wh(lzm) while(lzm--)
#define lowbit(x) (x&(-x))
#define HH printf("\n")
#define eb emplace_back
#define vi vector<int>
using namespace std;
int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*f;
}
const int mod=998244353,maxn=114514;
#define ls (o<<1)
#define rs (o<<1|1)
struct seg{
	vector<pii>pre,suf;
	int l,r;
	ll v;
}t[maxn<<2];
int n,k,lzm;
seg pushup(seg a,seg b){
	if(!a.pre.size()) return b;
	if(!b.pre.size()) return a;
	if(b.l<a.l) swap(a,b);
	seg rt;
	rt.l=a.l,rt.r=b.r;
	rt.v=a.v+b.v;
	int as=a.suf.size(),bp=b.pre.size();
	int ap=a.pre.size(),bs=b.suf.size();
	rt.pre=a.pre,rt.suf=b.suf;
	int now=a.pre[ap-1].fi;
	for(pii i:b.pre){
		int tt=__gcd(now,i.fi);
		if(tt<now) rt.pre.eb(tt,i.se);
		now=tt;
	}
	now=b.suf[bs-1].fi;
	for(pii i:a.suf){
		int tt=__gcd(now,i.fi);
		if(tt<now) rt.suf.eb(tt,i.se);
		now=tt;
	}
	int j=-1;
	dF(i,as-1,0){
		pii now=a.suf[i];
		int len;
		if(i==as-1) len=now.se-a.l+1;
		else len=now.se-a.suf[i+1].se;
		for(;j<bp-1&&__gcd(b.pre[j+1].fi,now.fi)>1;++j);	
		if(j==-1) continue;
		ll ad;
		if(j==bp-1) ad=1ll*len*(b.r-b.l+1);
		else ad=1ll*len*(b.pre[j+1].se-b.l);
		rt.v+=ad;
	}
	return rt;
}
void update(int o,int l,int r,int pos,int x){
	if(l==r){
		if(x>1) t[o].v=1;
		else t[o].v=0;
		t[o].suf.clear(),t[o].pre.clear();
		pii add=make_pair(x,pos);
		t[o].pre.pb(add);
		t[o].suf.pb(add);
		t[o].l=t[o].r=l;
		return;
	}
	int mid=(l+r)>>1;
	if(pos<=mid) update(ls,l,mid,pos,x);
	else update(rs,mid+1,r,pos,x);
	t[o]=pushup(t[ls],t[rs]);
}
seg query(int o,int l,int r,int ql,int qr){
	if(ql<=l&&qr>=r) return t[o];
	int mid=(l+r)>>1;
	if(qr<=mid) return query(ls,l,mid,ql,qr);
	if(ql>mid) return query(rs,mid+1,r,ql,qr);
	return pushup(query(ls,l,mid,ql,qr),query(rs,mid+1,r,ql,qr));
}
int a[maxn];
void build(int o,int l,int r){
	t[o].l=l,t[o].r=r;
	if(l==r){
		int x=a[l];
		if(x>1) t[o].v=1;
		else t[o].v=0;
		t[o].suf.clear(),t[o].pre.clear();
		pii add=make_pair(x,l);
		t[o].pre.pb(add);
		t[o].suf.pb(add);
		return;
	}
	int mid=(l+r)>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	t[o]=pushup(t[ls],t[rs]);
}
signed main(){
	n=read(),lzm=read();
	F(i,1,n) a[i]=read();
	build(1,1,n);
	wh(lzm){
		int op=read(),l=read(),r=read();
		if(op==1) update(1,1,n,l,r);
		else printf("%lld\n",query(1,1,n,l,r).v);
	}
}
```
附一句，这题双倍经验 [CF1004F](https://www.luogu.com.cn/problem/CF1004F)。

---

## 作者：zifanwang (赞：2)

~~这题的题号比较神奇，时隔这么久还是写一篇题解吧。~~

考虑用线段树进行维护，合并时加上当前区间内过 $mid$ 的区间个数。

对于每个线段树节点，维护这个节点的区间 $[L,R]$ 中所有以 $L$ 开头和以 $R$ 结尾的区间的 $\gcd$，不同的 $\gcd$ 的个数是 $\log$ 级别的，只需要记录每段的值和开始的位置，然后合并时两次扫描线统计个数即可。

时间复杂度：$O(n\log^2n)$。

代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define mxn 100003
#define md 1000000007
#define pb push_back
#define mkp make_pair
#define ld long double
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define rept(i,a,b) for(int i=a;i<b;++i)
#define drep(i,a,b) for(int i=a;i>=b;--i)
using namespace std;
struct node{
	ll x;
	int l,r; 
	int t1,p1[35],d1[35];
	int t2,p2[35],d2[35];
}t[mxn<<2];
int n,q,a[mxn];
inline int gcd(int x,int y){
	while(y^=x^=y^=x%=y);
	return x;
}
node operator+(node x,node y){
	node s;
	s.l=x.l,s.r=y.r;
	s.x=x.x+y.x;
	s.t1=x.t1;
	rep(i,1,x.t1)s.p1[i]=x.p1[i],s.d1[i]=x.d1[i];
	int d=x.d1[x.t1];
	rep(i,1,y.t1){
		int ls=d;d=gcd(d,y.d1[i]);
		if(d!=ls)s.p1[++s.t1]=y.p1[i],s.d1[s.t1]=d;
	}
	s.t2=y.t2;
	rep(i,1,y.t2)s.p2[i]=y.p2[i],s.d2[i]=y.d2[i];
	d=y.d2[y.t2];
	rep(i,1,x.t2){
		int ls=d;d=gcd(d,x.d2[i]);
		if(d!=ls)s.p2[++s.t2]=x.p2[i],s.d2[s.t2]=d;
	}
	int p=1;
	drep(i,y.t1,1){
		while(p<x.t2&&gcd(y.d1[i],x.d2[p+1])>1)p++;
		if(gcd(y.d1[i],x.d2[p])>1)s.x+=(ll)(x.r-(p==x.t2?x.l-1:x.p2[p+1]))*((i==y.t1?s.r+1:y.p1[i+1])-y.p1[i]);
	}
	return s;
} 
void build(int p,int l,int r){
	if(l==r){
		t[p].l=t[p].r=l;
		t[p].x=a[l]>1;
		t[p].t1=t[p].t2=1;
		t[p].p1[1]=t[p].p2[1]=l;
		t[p].d1[1]=t[p].d2[1]=a[l];
		return;
	}
	int mid=(l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	t[p]=t[p<<1]+t[p<<1|1];
}
void change(int p,int x,int l,int r){
	if(l==r){
		t[p].x=a[l]>1;
		t[p].d1[1]=t[p].d2[1]=a[l];
		return; 
	}
	int mid=(l+r)>>1;
	if(x<=mid)change(p<<1,x,l,mid);
	else change(p<<1|1,x,mid+1,r);
	t[p]=t[p<<1]+t[p<<1|1];
}
node ask(int p,int l,int r,int L,int R){
	if(l<=L&&R<=r)return t[p];
	int mid=(L+R)>>1;
	if(l<=mid&&r>mid)return ask(p<<1,l,r,L,mid)+ask(p<<1|1,l,r,mid+1,R);
	if(l<=mid)return ask(p<<1,l,r,L,mid);
	return ask(p<<1|1,l,r,mid+1,R);
}
signed main(){
	scanf("%d%d",&n,&q);
	rep(i,1,n)scanf("%d",&a[i]);
	build(1,1,n);
	int op,x,y;
	while(q--){
		scanf("%d%d%d",&op,&x,&y);
		if(op==1){
			a[x]=y;
			change(1,x,1,n);
		}else{
			printf("%lld\n",ask(1,x,y,1,n).x);
		}
	}
	return 0;
}
```

---

## 作者：first_fan (赞：2)

先分析下此题题意：

>需要我们实现的操作：

>单点修改序列元素

>查询某个区间内gcd非1的子串数目

我们考虑用线段树维护区间内答案个数。

那么一个区间的所求数目即由$\sf\large\text{三部分}$组成：

* 左区间内的数目

* 右区间内的数目

* 跨区间的数目

那么只要知道怎么求`跨区间`的就简单了。

首先跨区间的子串不是个个都有用，只有`gcd非1`的才有贡献

考虑怎么记录跨区间的、gcd非1的子串数目：
$\sf\color{red}\large\text{维护前缀gcd、后缀gcd。}$

可以用数组或pair记录gcd的值和数量，为了节约空间，此处用`vector套pair`记录。

 $\begin{cases}\small\sf\text{整区间内前缀gcd长度不超过左区间的部分直接引用}\\\small\sf\text{超过左区间长的部分就是L整段的gcd和右区间前缀的gcd}\end{cases}$ 

另建一个pair用于存储r区间前缀的gcd数即可。

后缀同理。

```
怎么用上述信息求跨区数量？

枚举左区间后缀以及右区间前缀

枚举过程中右移左区间后缀时右区间也会右移或不变（单调右移）。

接下来双指针完成即可。
```

本题唯一的难点就是向上更新的操作，其余的更改、查询操作都十分常规，另外如果看first或second不爽可以用两个数组代替pair。

```cpp
#include<bits/stdc++.h>
#define ri unsigned register ll
#define ll long long
#define ls(x) (x<<1)
#define rs(x) (x<<1|1)
#define leaf (l==r)
using namespace std;
const ll maxn=1e6+7;

ll read()
{
	ll x=0;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=x*10+c-'0';
		c=getchar();
	}
	return x;
}

ll a[maxn];

struct segment_tree
{
	ll l;
	ll r;
	ll val;
	vector<pair<int,int> > pre;//前缀
	vector<pair<int,int> > sub;//后缀
} seg[maxn];

segment_tree pushup(segment_tree l,segment_tree r)//向上更新
{
	segment_tree nd;
	nd.l=l.l;
	nd.r=nd.r;
	nd.pre.clear();
	nd.sub.clear();
	for(ri i=0; i<l.pre.size(); i++)
	{
		nd.pre.push_back(l.pre[i]);
	}
	for(ri i=l.pre.size(); i<l.pre.size()+r.pre.size(); i++)
	{
		ll res=__gcd(l.pre[l.pre.size()-1].first,r.pre[i-l.pre.size()].first);
		if(nd.pre[nd.pre.size()-1].first==res)
		{
			nd.pre[nd.pre.size()-1].second+=r.pre[i-l.pre.size()].second;
		}
		else
		{
			nd.pre.push_back(make_pair(res,r.pre[i-l.pre.size()].second));
		}
	}
	for(ri i=0; i<r.sub.size(); i++)
	{
		nd.sub.push_back(r.sub[i]);
	}
	for(ri i=r.sub.size(); i<l.sub.size()+r.sub.size(); i++)
	{
		ll res=__gcd(r.sub[r.sub.size()-1].first,l.sub[i-r.sub.size()].first);
		if(nd.sub[nd.sub.size()-1].first==res)
		{
			nd.sub[nd.sub.size()-1].second+=l.sub[i-r.sub.size()].second;
		}
		else
		{
			nd.sub.push_back(make_pair(res,l.sub[i-r.sub.size()].second));
		}
	}
	nd.val=l.val+r.val;
	ll cur1=l.sub.size()-1;
	ll cur2=0;//双指针
	ll len=l.sub[0].second;
	ll lw=0;
	bool flg=0;
	while(1)
	{
		int gcd=flg?cur2-1:cur2;
		while(cur1>=0&&__gcd(l.sub[cur1].first,r.pre[gcd].first)==1)
		{
			cur1--;
			flg=0;
		}
		if(cur1<0)
		{
			break;
		}
		if(flg)
		{
			cur1--;
		}
		len=l.sub[cur1].second;
		while((unsigned)cur2+1<=r.pre.size()&&__gcd(r.pre[cur2].first,l.sub[cur1].first)!=1)
		{
			lw+=r.pre[cur2].second;
			cur2++;
		}
		if(__gcd(l.sub[cur1].first,r.pre[cur2-1].first)!=1)
		{
			nd.val+=len*lw;
		}
		if(cur1<=0)
		{
			break;
		}
		flg=1;
	}
	return nd;
}//two pointer完成
void build(ll nd,ll l,ll r)//建树
{
	if(leaf)
	{
		seg[nd].pre.push_back(make_pair(a[l],1));
		seg[nd].sub.push_back(make_pair(a[l],1));
		seg[nd].val=a[l]==1?0:1;
		seg[nd].l=seg[nd].r=l;
		return;
	}
	ll mid=(l+r)>>1;
	build(ls(nd),l,mid);
	build(rs(nd),mid+1,r);
	seg[nd]=pushup(seg[ls(nd)],seg[rs(nd)]);
}
void modify(ll nd,ll l,ll r,ll pos,ll val)//单点修改
{
	if(leaf)
	{
		seg[nd].pre.clear();
		seg[nd].sub.clear();
		seg[nd].pre.push_back(make_pair(val,1));
		seg[nd].sub.push_back(make_pair(val,1));
		seg[nd].val=val==1?0:1;
		return;
	}
	ll mid=(l+r)>>1;
	if(pos<=mid)
	{
	modify(ls(nd),l,mid,pos,val);
	}
	else
	{
		modify(rs(nd),mid+1,r,pos,val);
	}
	seg[nd]=pushup(seg[ls(nd)],seg[rs(nd)]);
}
segment_tree query(ll nd,ll l,ll r,ll L,ll R)//区间统计，大写为所问区间，小写为当前区间
{
	if(L<=l&&R>=r)
	{
		return seg[nd];
	}
	ll mid=(l+r)>>1;
	segment_tree a,b;
	bool flgl=0;
	bool flgr=0;
	if(L<=mid)
	{
		a=query(ls(nd),l,mid,L,R);
		flgl=1;
	}
	if(R>mid)
	{
		b=query(rs(nd),mid+1,r,L,R);
		flgr=1;
	}
	if(flgl&&flgr)
	{
		return pushup(a,b);
	}
	return flgl?a:b;
}

unsigned ll n,m;
//代码中的这些有关unsigned的声明是因为消除warning，可以忽略。

int main()
{
	n=read();
	m=read();
	for(ri i=1; i<=n; i++)
	{
		a[i]=read();
	}
	build(1,1,n);
	for(ri i=1; i<=m; i++)
	{
		ll opt=read();
		ll l=read();
		ll r=read();
		if(opt==1)
		{
			modify(1,1,n,l,r);
		}
		else
		{
			printf("%lld\n",query(1,1,n,l,r).val);
		}
	}
}
```

调试调了很久，可能是由于递归调用频繁，并不能防止部分TLE，但是经过吸氧还是可以过的。

猜测一下：如果手写vector并使用数组代替pair，gcd函数也自己写的话，应当能省下很多的调用时间。$\sf\Huge OwO$

---

## 作者：未来姚班zyl (赞：1)

## 题目大意

给出长度为 $n$ 的序列 $A$，要求支持两个操作：单点修改，查询一个区间有多少个子区间的个数的 $\gcd$ 大于 $1$。

## 题目分析

考虑查询整个序列的方法。显然，我们可以采用分治的方法。一段区间的前/后缀 $\gcd$ 总是单调不增的，所以我们可以使用双指针记录每个左区间的点作为左端点时，右区间的点能作为右端点的个数。这样一次查询的复杂度为 $O(n\log n)$。使用线段树维护即可做到 $O(qn\log n)$ 的复杂度。

复杂度的瓶颈在于每次使用双指针需要 $O(len)$ 的复杂度。这时可以发现，一段区间的前后缀 $\gcd$ 的变化次数是 $O(\log V)$ 的，$V$ 表示值域。因为每次取 $\gcd$，要么不变，要么至少会缩小一半。所以我们把相同的段放在一起处理。

查询的线段树节点有 $O(\log n)$ 个，每次上传的复杂度为 $O(\log V)$，所以总复杂度 $O(q\log n\log V)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define L x<<1
#define R x<<1|1
#define mid (l+r>>1LL)
#define lc L,l,mid
#define rc R,mid+1,r
#define Root 1,1,n
#define OK l>=Ll&&r<=Rr
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define pb push_back
#define ull unsigned ll
#define e(x) for(int i=h[x],y=to[i];i;i=nxt[i],y=to[i])
#define E(x) for(auto y:p[x])
#define Pi pair<int,int>
#define ui unsigned ll
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57) s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(ll x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
const int N =1e5+5,M=2e6+5,inf=(1LL<<31)-1;
const ll llf=1e18,mod=1e9+7;
const ui base=13331;
using namespace std;
int n=read(),m=read(),a[N];
struct seg{
	ll w;
	vector<Pi >pr,su;
}xd[N<<2];
inline int gcd(int a,int b){
	return b?gcd(b,a%b):a;
}
inline seg get(seg a,seg b,int l,int Mid,int r){
	seg c;
	c.w=a.w+b.w;
	c.pr=a.pr,c.su=b.su;
	int siz=a.pr.size(),now=a.pr[siz-1].second;
	for(auto X:b.pr){
		int nw=gcd(now,X.second);
		if(nw^now)c.pr.pb({X.first,nw});
		now=nw;
	}
	siz=b.su.size(),now=b.su[siz-1].second;
	for(auto X:a.su){
		int nw=gcd(now,X.second);
		if(nw^now)c.su.pb({X.first,nw});
		now=nw;
	}
	int lsiz=a.su.size(),rsiz=b.pr.size();
	int Rr=rsiz-1;
	rep(Ll,0,lsiz-1){
		while(Rr>=0&&gcd(b.pr[Rr].second,a.su[Ll].second)==1)Rr--;
		if(Rr<0)break;
		ll w;
		if(Rr<rsiz-1)w=b.pr[Rr+1].first-Mid-1;
		else w=r-Mid;
		if(Ll<lsiz-1)w=w*(a.su[Ll].first-a.su[Ll+1].first);
		else w=w*(a.su[Ll].first-l+1);
		c.w+=w;
	}
	return c;
}
inline void build(int x,int l,int r){
	if(l==r){
		xd[x].pr.pb({l,a[l]}),xd[x].su.pb({l,a[l]});
		xd[x].w=a[l]>1;
		return;
	}
	build(lc),build(rc),xd[x]=get(xd[L],xd[R],l,mid,r);
}
inline void modify(int x,int l,int r,int p,int w){
	if(l==r)return xd[x].pr[0].second=xd[x].su[0].second=w,xd[x].w=w>1,void();
	if(p<=mid)modify(lc,p,w);
	else modify(rc,p,w);
	xd[x]=get(xd[L],xd[R],l,mid,r);
}
inline seg query(int x,int l,int r,int Ll,int Rr){
	if(OK)return xd[x];
	if(Rr<=mid)return query(lc,Ll,Rr);
	if(Ll>mid)return query(rc,Ll,Rr);
	return get(query(lc,Ll,Rr),query(rc,Ll,Rr),max(l,Ll),mid,min(Rr,r));
}
int main(){
	rep(i,1,n)a[i]=read();
	build(Root);
	for(int i=1,opt,l,r;i<=m;i++){
		opt=read(),l=read(),r=read();
		if(opt==1)modify(Root,l,r);
		else pf(query(Root,l,r).w),putchar('\n');
	}
	return 0;
}
```


---

## 作者：phigy (赞：1)

这里提供一个查询做到 $O(\log n)$ 的做法。（虽然没啥意义）

---------

我们设前驱 $p_i=\max_{\gcd_{k=j}^i\{a_k\}> 1,j\leq i}\{j\}$，就是指 $j$ 左边最大的 $i$ 使得  $i$ 到 $j$ 的 $\gcd$ 和不小于 $x$ 。

那么 $l$ 到 $r$ 的答案就是：$\sum_{i=l}^r \max\{p_i-l+1,0\}$。
  
我们发现这个 $\max$ 不好直接做，考虑先做一棵维护 $\gcd$ 的线段树，再从左端点线段树二分找一个 $\gcd$ 和大于 $1$ 连续段即为 $l$ 后驱就可以去掉 $\max$ 了。
  
当然我们也可以直接设后驱 $q_i=\max_{\gcd_{k=j}^i\{a_k\}> 1,j\ge i}\{j\}$。  
  
那么 $l$ 到 $r$ 的答案就是：$\sum_{i=q_l}^r p_i-l+1$。查询就是 $O(\log n)$ 的了。


  
然后怎么维护 $p,q$ 捏，我们发现一个点左右连续的 $\gcd$ 和各只有 $\log a$ 种，所以这东西我们还得用其它题解给的方法维护。

我们每次修改的时候，在 $[1,x]$ 的不同 $\gcd$ 后缀与 $[x,n]$ 的不同 $\gcd$ 前缀间做双指针再用线段树修改对应的 $p,q$ 连续段，修改总体是 $O(\log n\log a)$。

---

## 作者：hegm (赞：0)

### [[COCI2017-2018#2] Garaža](https://www.luogu.com.cn/problem/P4435)

小技巧：对于一个序列的前缀 $\text{gcd}$ 他的不相同段数不会超过 $\log n$。

证明：对于当前的前缀 $\text{gcd} :g$，我们添加一个数 $x$，情况有两种：

1. $g$ 因为 $x$ 的出现而改变，那么说明 $g$ 中至少有一个因子不存在与 $x$，那么我们把因子移除，因为因子最小为 $2$ 所以 $g$ 至少减少一半。

1. $g$ 不变。

证毕，可以看出 $g$ 要么不变要么减少至少一半，所以最多 $\log$ 段。

考虑普通的不带修改。

我们可以用普通的分治来做：

假如当前在 $l\sim mid\sim r$ 我们先算出 $l\sim mid$ 的后缀 $\gcd$ 和 $mid+1\sim r$ 的前缀 $\gcd$。

那么左右端点横跨 $mid$ 且合法的区间 $x,y$ 满足 $x\sim mid$ 的后缀 $\gcd$ 和 $mid+1\sim r$ 的前缀 $\gcd$ 拼接起来不是 $1$。

由于 $x,y$ 具有单调性（对于所有的 $x$，设最远的且合法的 $y$ 那么 $x$ 向右移动的时候 $y$ 一定会不变或者向右侧移动）

所以我们可以使用双指针，左端点在 $l$，右端点在 $r$。

但是现在我们带修改了，考虑使用线段树来维护这个分治，那么我们单次修改的复杂度是 $\log n$ 的，但是我们合并需要枚举左右以及求 $\gcd$ 所以复杂度是 $n\log n$ 的。

我们可以使用一开始说的性质，连续的不同 $\gcd$ 段数最多为 $\log a$ 个，所以我们的合并复杂度就可以变为 $\log n\times \log a$。

具体如何合并：

我们在线段树上维护两个 `vector`，对于一个点，我们看他的左孩子的末尾前缀 $\gcd$ 和右孩子的第一个前缀 $\gcd$ 是否相同，如果相同，我们就把两者合并，然后都塞入当前点的前缀 `vector`，每个 `vector` 的元素我们需要记录当前段的左右端点以及他的 $\gcd$ 值。后缀同理。

```cpp
#include<bits/stdc++.h>
#define N 1000005
#define ls (now<<1)
#define rs (now<<1|1)
#define gcd(x,y) __gcd(x,y)
#define int long long
using namespace std;
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n,q,a[N];
struct node
{
	int l,r,w;
};
node make(int l,int r,int w)
{
	node a;
	a.l=l;a.r=r;a.w=w;
	return a;
}
struct tree
{
	int ans;
	vector<node> f,t;
}tr[N];
void add(node &x,node y)
{
	x.l=min(x.l,y.l);
	x.r=max(x.r,y.r);
}
vector<node> merge(vector<node> x,vector<node> y)
{
	vector<node> ans;
	int lenx=x.size()-1,leny=y.size()-1;
	for(int i=0;i<=lenx;i++)ans.push_back(x[i]);
	for(int i=0,p,val;i<=leny;i++)
	{
		p=ans.size()-1;val=gcd(x[lenx].w,y[i].w);
		if(val==ans[p].w)add(ans[p],y[i]);
		else ans.push_back(make(y[i].l,y[i].r,val));
	}
	return ans;
}
int ln(node a){return a.r-a.l+1;}
tree hb(tree x,tree y)
{
	tree ans;ans.ans=0;
	ans.f=merge(x.f,y.f);
	ans.t=merge(y.t,x.t);
	int len=x.t.size()-1,lim=y.f.size()-1;
	for(int l=len,r=0;l>=0;l--)
	{
		while(r<=lim&&gcd(y.f[r].w,x.t[l].w)!=1)r++;r--;
		if(r>=0)ans.ans+=ln(x.t[l])*(y.f[r].r-y.f[0].l+1);
		else r++;
	}
	ans.ans+=x.ans+y.ans;
	return ans;
}
void build(int now,int l,int r)
{
	if(l==r)
	{
		tr[now].f.push_back(make(l,r,a[l]));
		tr[now].t.push_back(make(l,r,a[l]));
		if(a[l]!=1)tr[now].ans=1;
		else tr[now].ans=0;
		return ;
	}
	int mid=(l+r)>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	tr[now]=hb(tr[ls],tr[rs]);
}
void midy(int now,int l,int r,int x,int val)
{
	if(l==r)
	{
		vector<node> v;v.push_back(make(l,r,val));
		tr[now].f=v;tr[now].t=v;
		if(val!=1)tr[now].ans=1;
		else tr[now].ans=0;
		return;
	}
	int mid=(l+r)>>1;
	if(mid>=x)midy(ls,l,mid,x,val);
	else midy(rs,mid+1,r,x,val);
	tr[now]=hb(tr[ls],tr[rs]);
}
tree que(int now,int l,int r,int ql,int qr)
{
	if(l>=ql&&r<=qr)return tr[now];
	int mid=(l+r)>>1;
	if(mid>=ql&&mid<qr)return hb(que(ls,l,mid,ql,qr),que(rs,mid+1,r,ql,qr));
	if(mid>=ql)return que(ls,l,mid,ql,qr);
	if(mid<qr)return que(rs,mid+1,r,ql,qr);
}
signed main()
{
	n=read();q=read();
	for(int i=1;i<=n;i++)a[i]=read();
	build(1,1,n);
	int op,x,y;
	while(q--)
	{
		op=read();x=read();y=read();
		if(op==1)midy(1,1,n,x,y);
		else cout<<que(1,1,n,x,y).ans<<"\n";
	}
	return 0;
}
```

---


# [FJOI2015] 火星商店问题

## 题目描述

火星上的一条商业街里按照商店的编号 $1 \sim n$ ，依次排列着 $n$ 个商店。商店里出售的琳琅满目的商品中，每种商品都用一个非负整数 $\text{val}$ 来标价。每个商店每天都有可能进一些新商品，其标价可能与已有商品相同。
 
火星人在这条商业街购物时，通常会逛这条商业街某一段路上的所有商店，譬如说商店编号在区间 $[l,r]$ 中的商店，从中挑选一件自己最喜欢的商品。每个火星人对商品的喜好标准各不相同。  

通常每个火星人都有一个自己的喜好密码 $x$。对每种标价为 $\text{val}$ 的商品，喜好密码为 $x$ 的火星人对这种商品的喜好程度与 $\text{val}$ 异或 $x$ 的值成正比。也就是说，$\text{val xor }x$ 的值越大，他就越喜欢该商品。  

每个火星人的购物卡在所有商店中只能购买最近 $d$ 天内（含当天）进货的商品。另外，每个商店都有一种特殊商品不受进货日期限制，每位火星人在任何时刻都可以选择该特殊商品。每个商店中每种商品都能保证供应，不存在商品缺货的问题。 

对于给定的按时间顺序排列的事件，计算每个购物的火星人的在本次购物活动中最喜欢的商品，即输出 $\text{val xor }x$ 的最大值。这里所说的按时间顺序排列的事件是指以下两种事件： 

`0 s v`，表示编号为 $s$ 的商店在当日新进一种标价为 $v$ 的商品。 

`1 l r x d`，表示一位火星人当日在编号在 $[l,r]$ 的商店购买 $d$ 天内的商品，该火星人的喜好密码为 $x$。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，所有输入的整数在 $[0,10^5]$ 范围内。

## 样例 #1

### 输入

```
4 6
1 2 3 4
1 1 4 1 0
0 1 4
0 1 3
1 1 1 1 0
1 1 1 1 1
1 1 2 1 2```

### 输出

```
5
0
2
5```

# 题解

## 作者：Brioche (赞：34)

### [[FJOI2015]火星商店问题](https://www.luogu.org/problemnew/show/P4585)

### [Blog](https://www.cnblogs.com/terribleterrible/p/9872831.html)

前天考了到线段树分治模板题,全场都切了,就我不会QAQ

于是切题无数的Tyher巨巨就告诉我:"你可以去看看火星商店问题,看了你就会了."

第一道线段树分治题,看了yyb博客,学习了一波.

其实线段树分治就是对操作的时间分治.

对线段树每个节点开一个$vector$,把询问的区间(时间的区间)看成一段一段放到线段树的$vector$里面存着.

注意到修改会延续到最后一刻,所以修改只是左端点不一样而已,相当于一个后缀.

把修改按照位置排序(这个时候时间是乱序的),接着仿照线段树的形式按时间分治,在$mid$之前的修改,就扔到左边的数组里递归,否则就扔到右边的子树.这样就除掉了时间这一维的限制.

那么空间这一维,就用一个可持久化trie树来维护,$r$和$l-1$的对应的字典树前缀和相减就是区间的字典树.注意最开始修改要按照商店编号排序,这样按照时间分拣之后它的商店编号依然是有序的,你不妨把这些有修改的商店之间的其他商店都忽略掉,一个修改挨着一个修改地构建主席树,保证了时间复杂度.

还有一个值得注意的问题,就是当把点加到可持久化字典树里的时候,要重新从当前左端点构出字典树(相当于清空这棵可持久化字典树,假如这个询问对应的答案是当前区间之前的某次修改加入的值,那么这个询问也一定会被丢到对应的线段树节点上计算,所以不用担心之前的修改会影响询问的答案)这样可以避免撤销带来的常数.

再按照trie树找异或最大值的方法来找答案,一个询问会被放到线段树的多个节点上(会被分成很多段时间),所以答案要取$max$.

注意线段树上的是修改时间,字典树是按照空间构建的.这个很重要,总是写着写着就忘了...

时间复杂度$O(nlog^2n)$,线段树分治和trie树$nlogn$,字典树$logn$
```cpp
#include<bits/stdc++.h>
#define maxn 100005
#define mid ((l+r)>>1)
#define rc ((rt<<1)|1)
#define lc (rt<<1)
using namespace std;
int gi()
{
    char c;int x,sign=1;
    while((c=getchar())>'9'||c<'0')if(c=='-')sign=-1;
    x=c-'0';while((c=getchar())>='0'&&c<='9')x=(x<<1)+(x<<3)+c-'0';
    return x*sign;
}
int n,m,cnt1,cnt2,tot,top;
int rt[maxn],ans[maxn],st[maxn];
int ch[maxn*20][2],sz[maxn*20];
vector<int> a[maxn];
struct guest{int l,r,L,R,x;}p[maxn];
struct buy{int s,v,t;}q[maxn],t1[maxn],t2[maxn];
bool cmp(const buy x,const buy y){return x.s<y.s;}
void insert(int &x,int u,int w)
{
    int now;now=x=++tot;
    for(int i=17;i>=0;i--)
    {
        bool d=w&(1<<i);
        ch[now][d^1]=ch[u][d^1];ch[now][d]=++tot;
        now=ch[now][d];u=ch[u][d];
        sz[now]=sz[u]+1;
    }
}
int query(int l,int r,int w)
{
    int res=0;
    for(int i=17;i>=0;i--)
    {
        bool d=w&(1<<i);
        if(sz[ch[r][d^1]]-sz[ch[l][d^1]]>0)
            l=ch[l][d^1],r=ch[r][d^1],res+=(1<<i);
        else l=ch[l][d],r=ch[r][d];
    }
    return res;
}
void update(int rt,int l,int r,int L,int R,int x)
{
    if(L>R||r<L||l>R)return ;
    if(L<=l&&r<=R){a[rt].push_back(x);return;}
    update(lc,l,mid,L,R,x);update(rc,mid+1,r,L,R,x);
}
void calc(int x,int L,int R)
{
    top=tot=0;
    for(int i=L;i<=R;i++)
    {
        st[++top]=q[i].s;
        insert(rt[top],rt[top-1],q[i].v);
    }
    for(int i=0,sz=a[x].size();i<sz;i++)
    {
        int k=a[x][i],t;
        int l=upper_bound(st+1,st+1+top,p[k].l-1)-st-1;
        int r=upper_bound(st+1,st+1+top,p[k].r)-st-1;
        ans[k]=max(ans[k],t=query(rt[l],rt[r],p[k].x));
        //cout<<x<<" "<<k<<" "<<t<<endl;
    }
}
void divide(int rt,int l,int r,int L,int R)//按时间分治
{
    if(L>R)return;
    int cn1=0,cn2=0;
    calc(rt,L,R);
    if(l==r)return;
    for(int i=L;i<=R;i++)//修改的区间右端点都是cnt1,相当于影响到之后的时间
        if(q[i].t<=mid)t1[++cn1]=q[i];
        else t2[++cn2]=q[i];
    for(int i=1;i<=cn1;i++)q[i+L-1]=t1[i];//左端点在mid左边的放在左区间
    for(int i=1;i<=cn2;i++)q[i+L-1+cn1]=t2[i];//否则放右边
    divide(lc,l,mid,L,L+cn1-1);
    divide(rc,mid+1,r,L+cn1,R);
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)insert(rt[i],rt[i-1],gi());
    for(int i=1,ty,l,r,x,d,s,v;i<=m;i++)
    {
        ty=gi();
        if(!ty)s=gi(),v=gi(),q[++cnt1]=(buy){s,v,cnt1};//起点,价格,时间
        else
        {
            l=gi(),r=gi(),x=gi(),d=gi();
            ans[++cnt2]=query(rt[l-1],rt[r],x);
            p[cnt2]=(guest){l,r,max(1,cnt1-d+1),cnt1,x};
            //商店左端点,商店右端点,开始时间,结束时间,喜好密码
        }
    }
    for(int i=1;i<=cnt2;i++)update(1,1,cnt1,p[i].L,p[i].R,i);
    sort(q+1,q+1+cnt1,cmp);//按照商店编号排序
    divide(1,1,cnt1,1,cnt1);
    for(int i=1;i<=cnt2;i++)printf("%d\n",ans[i]);
    return 0;
}

```

---

## 作者：qwaszx (赞：22)

在 Trie 上走的过程相当于是每次询问一个值域区间内是否有值，那么可以用整体二分来做这个过程. 先不考虑一开始的那些东西，那么对于分治到的某一个区间需要求出位置在 $[l,r]$ 内时间在 $[L,R]$ 内是否有点，这是个经典二维数点问题，可以离线做到 $O(len\log len)$，$len$ 是点和询问的数量之和. 于是这部分的整体复杂度是 $O(n\log ^2 n)$. 对于一开始的东西再做一次整体二分，那么这次需要只求出位置在 $[l,r]$ 内是否有点. 可以做到 $O(n\log n)$，但为了简便还是用实现成 $O(n\log ^2n)$. 

该做法的时间复杂度是 $O(n\log ^2n)$，而空间复杂度达到了线性.

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=1e5+500;
int ans1[N],ans2[N],n,m,qn,cn;
struct BIT
{
    int a[N];
    void update(int x,int w){for(;x<=n;x+=x&-x)a[x]+=w;}
    int query(int x){int ans=0;for(;x;x-=x&-x)ans+=a[x];return ans;}
    int query(int l,int r){return query(r)-query(l-1);}
}s,sl,sr;
struct WNode{int l,L,w;}w[N],c[N],tmpwl[N],tmpwr[N];
struct QNode{int l,r,L,R,w,id,exi;}q[N],ql[N],qr[N],tmpq[N<<1];

void solve1(int wl,int wr,int l,int r,int L,int R,int dep)
{
    if(l>r||L>R)return;
    if(wl==wr)return;
    int mid=(wl+wr)>>1;int wnl=0,wnr=0,qnl=0,qnr=0;
    for(int i=l;i<=r;i++)
        if(w[i].w<=mid)
            tmpwl[++wnl]=w[i],sl.update(w[i].l,1);
        else tmpwr[++wnr]=w[i],sr.update(w[i].l,1);
    for(int i=L;i<=R;i++)
        if(q[i].w>>dep&1)
        {
            if(sl.query(q[i].l,q[i].r))ql[++qnl]=q[i],ans1[q[i].id]|=1<<dep;
            else qr[++qnr]=q[i];
        }
        else
        {
            if(sr.query(q[i].l,q[i].r))qr[++qnr]=q[i],ans1[q[i].id]|=1<<dep;
            else ql[++qnl]=q[i];
        }
    for(int i=l;i<=r;i++)
        if(w[i].w<=mid)sl.update(w[i].l,-1);
        else sr.update(w[i].l,-1);
    for(int i=1;i<=wnl;i++)w[l+i-1]=tmpwl[i];
    for(int i=1;i<=wnr;i++)w[l+wnl+i-1]=tmpwr[i];
    for(int i=1;i<=qnl;i++)q[L+i-1]=ql[i];
    for(int i=1;i<=qnr;i++)q[L+qnl+i-1]=qr[i];
    solve1(wl,mid,l,l+wnl-1,L,L+qnl-1,dep-1);
    solve1(mid+1,wr,l+wnl,r,L+qnl,R,dep-1);
}
int cmpq(const QNode &a,const QNode &b){return a.L<b.L;}
void calc(const WNode w[],int wn,QNode q[],int qn)
{
    int tn=0;
    for(int i=1;i<=qn;i++)
    {
        q[i].exi=0;
        tmpq[++tn]=q[i],tmpq[tn].L=q[i].L-1,tmpq[tn].w=-1,tmpq[tn].id=i;
        tmpq[++tn]=q[i],tmpq[tn].L=q[i].R,tmpq[tn].w=1,tmpq[tn].id=i;
    }
    sort(tmpq+1,tmpq+tn+1,cmpq);
    int j=1;
    for(int i=1;i<=tn;i++)
    {
        while(j<=wn&&w[j].L<=tmpq[i].L)s.update(w[j].l,1),++j;
        q[tmpq[i].id].exi+=tmpq[i].w*s.query(tmpq[i].l,tmpq[i].r);
    }
    for(int i=1;i<j;i++)s.update(w[i].l,-1);
}
void solve2(int wl,int wr,int l,int r,int L,int R,int dep)
{
    if(l>r||L>R)return;
    if(wl==wr)return;
    int mid=(wl+wr)>>1;int wnl=0,wnr=0,qnl=0,qnr=0;
    for(int i=l;i<=r;i++)
        if(c[i].w<=mid)tmpwl[++wnl]=c[i];
        else tmpwr[++wnr]=c[i];
    for(int i=L;i<=R;i++)
        if(q[i].w>>dep&1)ql[++qnl]=q[i];
        else qr[++qnr]=q[i];
    calc(tmpwl,wnl,ql,qnl),calc(tmpwr,wnr,qr,qnr);
    int nl=L,nr=R;
    for(int i=1;i<=qnl;i++)
        if(ql[i].exi)q[nl++]=ql[i],ans2[ql[i].id]|=1<<dep;
        else q[nr--]=ql[i];
    for(int i=1;i<=qnr;i++)
        if(qr[i].exi)q[nr--]=qr[i],ans2[qr[i].id]|=1<<dep;
        else q[nl++]=qr[i];
    for(int i=1;i<=wnl;i++)c[l+i-1]=tmpwl[i];
    for(int i=1;i<=wnr;i++)c[l+wnl+i-1]=tmpwr[i];
    solve2(wl,mid,l,l+wnl-1,L,nr,dep-1),solve2(mid+1,wr,l+wnl,r,nl,R,dep-1);
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&w[i].w),w[i].l=i;
    qn=0,cn=0;int tim=0;
    for(int i=1,opt=-1;i<=m;i++)
    {
        scanf("%d",&opt);
        if(opt==0)
        {
            ++tim;
            ++cn,scanf("%d%d",&c[cn].l,&c[cn].w),c[cn].L=tim;
        }
        else ++qn,scanf("%d%d%d%d",&q[qn].l,&q[qn].r,&q[qn].w,&q[qn].L),q[qn].R=tim,q[qn].L=tim-q[qn].L+1,q[qn].id=qn;
    }
    solve1(0,131071,1,n,1,qn,16);
//    for(int i=1;i<=qn;i++)cout<<q[i].id<<" ";puts("");
    solve2(0,131071,1,cn,1,qn,16);
//    for(int i=1;i<=qn;i++)cout<<ans1[i]<<" ";puts("");
//    for(int i=1;i<=qn;i++)cout<<ans2[i]<<" ";puts("");
    for(int i=1;i<=qn;i++)printf("%d\n",max(ans1[i],ans2[i]));
}
```

---

## 作者：lindongli2004 (赞：21)

标签：线段树 + $01-trie$

首先，看到与 $x$ 的异或值最大，我们应该立即想到 $01-tire$ 的贪心算法，即：

- 我们把已有的数字从第 $30$ 位到第 $1$ 位按照二进制，依次插入到 $tire$ 树中。

- 查询数字 $x$ 时，从第 $30$ 位到第 $1$ 位贪心：设当前二进制位为 $y$ ，那么数字 $x$ 的这个二进制位为 th=x>>y&1，那么如果当前 $trie$ 树上有 th^1 这个分支，说明 $x$ 在 $y$ 这个二进制位上可以取到值，所以 $ans+=(1<<y)$，递归到 th^1 这个分支，否则就递归到 th 这个分支，继续往下找。

现在我们就有了一个显然的暴力：每个商店维护一个 $01-trie$，查询时从 $l$ 枚举到 $r$, 把结果取 $max$，修改时，我们可以在每个 $01-trie$ 的结点上记录：该结点最晚的修改时间 $dmx$，这样查询时，如果要进入的结点的 $dmx$ 小于最早的合法时限，那就 $return$ 即可。

总结一下上述操作：单点修改，区间查询，可以用线段树维护，线段树的每个结点维护这个区间内的所有数的 $01-trie$ ，实现用到了标记永久化的技巧。

时空复杂度：$O(n \;log n \;log\;max\{val\} )$。

下面是参考代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int MX=4e7,INF=1e9;
int n,tot;
struct Tire_01{
	int c[MX][2],mx[MX]; // mx 记录的是该结点的最晚修改时间
	inline void add(int k,int x,int d){
		for(int i=20;i>=0;i--){
			int th=x>>i&1;
			k=c[k][th]?c[k][th]:(c[k][th]=++tot);
			mx[k]=max(mx[k],d);
		}
	}
	inline int ask(int k,int x,int d){
		int r=0;
		for(int i=20;i>=0;i--){
			int th=x>>i&1;
			if(c[k][th^1] && mx[c[k][th^1]]>=d)r|=(1<<i),k=c[k][th^1];
			else if(mx[c[k][th]]>=d)k=c[k][th];
			else return r;
		} return r;
	}
}tr;
int query(int k,int l,int r,int ql,int qr,int x,int d){
	if(ql<=l && qr>=r)return tr.ask(k,x,d);
	int mid=(l+r)>>1,ans=0;
	if(ql<=mid)ans=max(ans,query(k<<1,l,mid,ql,qr,x,d));
	if(qr>mid) ans=max(ans,query(k<<1|1,mid+1,r,ql,qr,x,d));
	return ans;
}
void change(int k,int l,int r,int x,int y,int d){
	tr.add(k,y,d);
	if(l==r)return;
	int mid=(l+r)>>1;
	if(x<=mid)change(k<<1,l,mid,x,y,d);
	else change(k<<1|1,mid+1,r,x,y,d);
}
inline int read(){
	int x=0,f=1; char ch=getchar();
	while(ch<'0' || ch>'9'){x=x*10+ch-'0';ch=getchar();}
	while(ch>='0' && ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int main()
{
	n=read(); int aq=read(); tot=n<<2;
	for(int i=1;i<=n;i++)
		change(1,1,n,i,read(),INF);
	int cnt=0;
	while(aq--){
		int op=read(),l=read(),r=read(),x,y;
		if(!op)++cnt,change(1,1,n,l,r,cnt);
		else x=read(),y=read(),printf("%d\n",query(1,1,n,l,r,x,max(0,cnt-y+1)));
	}
	return 0;
}
```
小结：遇到题目要理清思路，找到突破口，顺藤摸瓜找到解决方案。

---

## 作者：lyh0313 (赞：11)

## 分析：
首先，一看到**求val xor x最大**，我们就应该想到**可持久化Trie**,(详见[P4585](https://www.luogu.org/problemnew/show/P4735))，这样，当我们询问$L,R$之间的最大异或值时，就直接套用可持久化Trie就行了，这样空间这一维就可以处理了。如果全是特殊商品的话，这个问题就解决了，但还有时间这一维啊，怎么办？（~~把出题人吊起来打一顿，让他改数据~~）

#### 时间怎么办？

首先，每个火星人能够买的商品的进货时间应该是在一段时间**区间**内（对普通商品而言），那么只有在这个区间内的商品才能被该火星人买，即对该次询问做贡献，而如果我们把商品看成一个**点**，那么某次询问就是对一段**区间**上所有的点做一次询问，那么，我们会发现：**这个可以用线段树维护**

如果我们在线处理的话，就会重复运算很多次，就可能会$TLE$,~~其实我也没试过~~，于是，我们就要引出这题正解了：**线段树分治**

所谓**线段树分治**，就是把某一段区间用线段树的方法分成很多段子区间，再把修改和询问一起放在线段树上，然后再统一一起处理一遍，这样做的好处在于，可以省掉许多重复计算，提高效率。

好了，那么对于这题而言，只要用线段树的方法处理区间询问和单点修改就行了。也就是对于当前区间$[L,R]$，先把完全包含它的所有询问用这一区间内的**点**(商品)更新,再把在左/右区间的点和与左/右区间有交集且没有用该区间更新过的用的询问一起往下递归处理，直到没有询问传递下来为止。  
具体看代码吧

## Code
```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<string>
#include<iostream>
#include<queue>
#include<iomanip>
#include<algorithm>
using namespace std;
const int N=100010;

int n,m,day,ans[N];
struct node
{
	int time,val,pos;
}a[N*2];
int totm;
struct que
{
	int l,r,tl,tr,x;
}q[N*2];
int totq,id[N],cnt;
int ch[N<<5][2],root[N],sum[N<<5],totp;
node tmpl[N*2],tmpr[N*2];

bool cmp(const node &a,const node &b)
{
	return a.pos<b.pos;
}

void add(int x,int x1,int val)//可持久化trie
{
	int i,j;
	sum[x]=sum[x1]+1;
	for(i=16;i>=0;i--)
	{
		bool f=(val&(1<<i));
		ch[x][!f]=ch[x1][!f];
		x1=ch[x1][f];
		x=ch[x][f]=++cnt;
		sum[x]=sum[x1]+1;
	}
}

int quer(int x,int x1,int val)//可持久化trie
{
	int ans=0,i;
	for(i=16;i>=0;i--)
	{
		ans<<=1;
		bool f=(val&(1<<i));
		if(ch[x1][!f]>ch[x][!f]) ans++;
		else f=!f;
		x=ch[x][!f];x1=ch[x1][!f];
	}
	return ans;
}

int find(int l,int r,int x)
{
	int ml=l;
	if(a[l].pos>x) return 0;
	while(l<r)
	{
		int mid=l+r>>1;
		if(a[mid+1].pos<=x) l=mid+1;
		else r=mid;
	}
	return l-ml+1;
}

void work(int ml,int mr,int qr)//用可持久化trie更新询问
{
	totp=0;cnt=0;
	int i,j,k;
	for(i=ml;i<=mr;i++)
	{
		totp++;cnt++;
		root[totp]=cnt;
		add(root[totp],root[totp-1],a[i].val);
	}
	for(i=1;i<=qr;i++)
	{
		int l=find(ml,mr,q[id[i]].l-1);
		int r=find(ml,mr,q[id[i]].r);
		ans[id[i]]=max(ans[id[i]],quer(root[l],root[r],q[id[i]].x));
	}
}

void slove(int ml,int mr,int tl,int tr,int tp)
{
	if(ml>mr||tp==0) return;
	int tot=0,i,j;
	for(i=1;i<=tp;i++)
		if(q[id[i]].tl<=tl&&tr<=q[id[i]].tr)
			swap(id[i],id[++tot]);
	work(ml,mr,tot);
	if(tl==tr) return;
	int mid=tl+tr>>1,lt=0,rt=0;
	for(i=ml;i<=mr;i++)
	{
		if(a[i].time<=mid) tmpl[++lt]=a[i];
		else tmpr[++rt]=a[i];
	}
	for(i=1;i<=lt;i++) a[ml+i-1]=tmpl[i];
	for(i=1;i<=rt;i++) a[ml+lt+i-1]=tmpr[i];
	tot=0;
	for(i=1;i<=tp;i++) 
	{
		if(q[id[i]].tl<=tl&&tr<=q[id[i]].tr) continue;
		if(q[id[i]].tl<=mid) swap(id[i],id[++tot]);
	}
	slove(ml,ml+lt-1,tl,mid,tot);
	tot=0;
	for(i=1;i<=tp;i++) 
	{
		if(q[id[i]].tl<=tl&&tr<=q[id[i]].tr) continue;
		if(q[id[i]].tr>mid) swap(id[i],id[++tot]);
	}
	slove(ml+lt,mr,mid+1,tr,tot);
}

int main()
{
	int i,j,op,k,d;
	totq=day=0;
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;i++)
	{
		scanf("%d",&a[i].val);
		a[i].pos=i;a[i].time=0;
	}
	int spt;
	spt=totm=n;
	for(i=1;i<=m;i++)
	{
		scanf("%d",&op);
		if(op==0)
		{
			day++;a[++totm].time=day;
			scanf("%d%d",&a[totm].pos,&a[totm].val);
		}
		else
		{
			totq++;
			id[totq]=totq;
			scanf("%d%d%d%d",&q[totq].l,&q[totq].r,&q[totq].x,&d);
			q[totq].tr=day;q[totq].tl=max(day-d+1,1);
		}
	}
	sort(a+spt+1,a+totm+1,cmp);
	work(1,spt,totq);//特殊商品单独处理
	slove(spt+1,totm,1,day,totq);//线段树分治
	for(i=1;i<=totq;i++) printf("%d\n",ans[i]);
	return 0;
}
```


---

## 作者：Cgod (赞：10)

一些闲话：

最近被dalao们虐得对NOIP的难度产生了怀疑。。。

------------

步入正题吧。

很显然的xxx套可持久化Trie（xxx包括很多东西就不列举了）

没什么特别的东西的题我四不费写题解的，但毕竟这是我的第一道线段树分治。

通过一大堆废话我们发现这篇题解是线段树分治套可持久化trie。

可持久化Trie最开始以为很难，看了（orz yyb）yyb的代码后秒懂，把trie当做线段树，那么可持久化Trie就是主席树。（不会的出门右转可持久化线段树和trie）

接下来我们考虑分治，根据cdq的经验（不会cdq？？？去问度娘），我们增加时间这一维（这道题有。。。）按时间分治。每一个修改操作影响的是它后面的一段区间，所以可以线段树。把询问丢入线段树，拆成一段段区间，用vector存，然后线段树上二分，具体的操作和整体二分又有点像（分治什么的最讨厌了~(>_<)~)

每层线段树就calc算一下就好了，calc里套可持久化Trie，把vector里的询问都计算一遍，ans取max，还ans初值为val用那些总是存在的n个商品算出来的最大值。

然后就愉快的~~1A~~切掉了

没有注释的代码

```cpp
#include<vector>
#include<algorithm>
#include<cstdio>
#include<cctype>
#define gt getchar()
inline int in()
{
    int k=0;char ch=gt;
    while(!isdigit(ch))ch=gt;
    while(isdigit(ch))k=k*10+ch-'0',ch=gt;
    return k;
}
const int N=1e5+5;
struct Trie
{
    int siz[N*20],ch[N*20][2],cnt;
    inline void insert(int &u,int fr,int x,int now)
        {
            siz[u=++cnt]=siz[fr]+1;
            if(now==-1)return;
            bool c=(1<<now)&x;
            ch[u][c^1]=ch[fr][c^1];
            insert(ch[u][c],ch[fr][c],x,now-1);
        }
    inline int query(int L,int R,int x,int now)
        {
            if(now==-1)return 0;
            bool c=(1<<now)&x;
            if(siz[ch[R][c^1]]-siz[ch[L][c^1]])
                return query(ch[L][c^1],ch[R][c^1],x,now-1)+(1<<now);
            else
                return query(ch[L][c]  ,ch[R][c]  ,x,now-1);
        }
}cx;
struct peop{int L,R,x,tl,tr;}req[N];
struct shop{int s,v,t;}q[N<<2],q1[N<<2],q2[N<<2];
inline bool cmp(const shop &a,const shop &b){return a.s<b.s;}
std::vector<int>seg[N<<2];
#define lc k<<1
#define rc k<<1|1
void update(int l,int r,int L,int R,int k,int res)
{
    if(L>R)return;
    if(L<=l&&R>=r){seg[k].push_back(res);return;}
    int mid=l+r>>1;
    if(mid>=L) update(l,mid,L,R,lc,res);
    if(mid<R)update(mid+1,r,L,R,rc,res);
}
int rt[N],cnt,ans[N],tot,st[N],top;
#define low(s) std::upper_bound(st+1,st+top+1,s)-st-1
void calc(int k,int L,int R)
{
    top=cx.cnt=0;
    for(int i=L;i<=R;++i)
    {
        st[++top]=q[i].s;
        cx.insert(rt[top],rt[top-1],q[i].v,17);
    }
    for(int i=0,sz=seg[k].size();i<sz;++i)
    {
        int u=seg[k][i],l=low(req[u].L-1),r=low(req[u].R);
        ans[u]=std::max(ans[u],cx.query(rt[r],rt[l],req[u].x,17));
    }
}
void div(int k,int l,int r,int L,int R)
{
    if(L>R)return;
    calc(k,L,R);
    if(l==r)return;
    int mid=l+r>>1,t1=0,t2=0;
    for(int i=L;i<=R;++i)
        if(q[i].t<=mid)
            q1[++t1]=q[i];
        else
            q2[++t2]=q[i];
    for(int i=1;i<=t1;++i)q[L+i-1]=q1[i];
    for(int i=1;i<=t2;++i)q[L+t1+i-1]=q2[i];
    div(lc,l,mid,L,L+t1-1);
    div(rc,mid+1,r,L+t1,R);
}
int main()
{
    int n=in(),m=in();
    for(int i=1;i<=n;++i)cx.insert(rt[i],rt[i-1],in(),17);
    int opt,a,b,c,d;
    for(int i=1;i<=m;++i)
    {
        opt=in();
        if(opt)
        {
            a=in(),b=in(),c=in(),d=in();
            req[++tot]=(peop){a,b,c,std::max(1,cnt-d+1),cnt};
            ans[tot]=cx.query(rt[a-1],rt[b],c,17);
        }
        else
        {
            a=in(),b=in();++cnt;
            q[cnt]=(shop){a,b,cnt};
        }
    }
    for(int i=1;i<=tot;++i)update(1,cnt,req[i].tl,req[i].tr,1,i);
    std::sort(q+1,q+cnt+1,cmp);
    div(1,1,cnt,1,cnt);
    for(int i=1;i<=tot;++i)printf("%d\n",ans[i]);
    return 0;
}


```

求大佬推荐线段树分治的题O(∩_∩)O谢谢。

---

## 作者：Diaоsi (赞：8)

[[FJOI2015]火星商店问题](https://www.luogu.com.cn/problem/P4585)

提供一个线段树套 $\mathtt{01\ Trie}$ 的做法。

区间 $l \sim r$ 的限制很好解决，对于线段树的每一个节点都开一棵 $\mathtt{01\ Trie}$ ，查询的时候将 $l \sim r$ 划分成若干个线段树节点上的区间，然后在这些节点对应的 $\mathtt{01\ Trie}$ 上查询即可。

对于单点插入操作，由于每次修改都会在线段树的节点上产生一条从上到下的路径，将要插入的值直接插入路径上所经过的节点对应的 $\mathtt{01\ Trie}$ 。

但是题目还有一个时间限制，只能购买个固定时间段内的商品，不难想到使用可持久化数据结构，但是那东西调起来太麻烦了，于是可以使用下面这种方法：

题目要求的是一段时间的后缀，所以直接在普通 $\mathtt{01\ Trie}$ 上的节点打标记，标记这个节点最后被更新的时间是多少，每次查询的时候直接跳过不在给定时间范围内的节点，而对于特殊商品，设他们被更新的时间为 $\inf$ ，这样就可以保证每次查询时一定能与特殊商品进行最大异或匹配。

由于值域与 $n,m$ 同阶，所以总的时间复杂度是 $\mathcal{O(n\log ^2 n)}$ 。

既然你能找到这题，我相信你能瞬间做出来的。

$Code:$

```cpp
#include<bits/stdc++.h>
typedef long long LL;
typedef long double LD;
using namespace std;
const int N=100010,M=1000010,INF=0x3f3f3f3f;
inline int max(int x,int y){return x>y?x:y;}
inline int min(int x,int y){return x<y?x:y;}
inline void swap(int &x,int &y){x^=y^=x^=y;}
int n,m,d,cnt,a[N];
int tr[N<<9][2],tag[N<<9][2],root[N<<2];
struct SegmentTree{
	int l,r;
	#define l(x) tree[x].l
	#define r(x) tree[x].r
}tree[N<<2];
void insert(int p,int val,int t){
	for(int i=1<<18;i;i>>=1){
		bool ch=val&i;
		if(!tr[p][ch])tr[p][ch]=++cnt;
		tag[p][ch]=max(t,tag[p][ch]);
		p=tr[p][ch];
	}
}
int ask(int p,int val,int t){
	int res=0;
	for(int i=1<<18;i;i>>=1){
		bool ch=val&i;
		if(tr[p][ch^1]&&tag[p][ch^1]>=t)res|=i,p=tr[p][ch^1];
		else if(tr[p][ch]&&tag[p][ch]>=t)p=tr[p][ch];
	}
	return res;
}
void build(int x,int l,int r){
	l(x)=l,r(x)=r;
	root[x]=++cnt;
	for(int i=l;i<=r;i++)
		insert(root[x],a[i],INF);
	if(l==r)return;
	int mid=(l+r)>>1;
	build(x<<1,l,mid);
	build(x<<1|1,mid+1,r);
}
void change(int x,int pos,int val,int t){
	int l=l(x),r=r(x);
	insert(root[x],val,t);
	if(l==r)return;
	int mid=(l+r)>>1;
	if(pos<=mid)change(x<<1,pos,val,t);
	else change(x<<1|1,pos,val,t);
}
int query(int x,int L,int R,int val,int t){
	int l=l(x),r=r(x);
	if(L<=l&&r<=R)return ask(root[x],val,t);
	int mid=(l+r)>>1,res=0;
	if(L<=mid)res=max(res,query(x<<1,L,R,val,t));
	if(R>mid)res=max(res,query(x<<1|1,L,R,val,t));
	return res;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	build(1,1,n);
	while(m--){
		int op;
		scanf("%d",&op);
		if(!op){
			int pos,val;d++;
			scanf("%d%d",&pos,&val);
			change(1,pos,val,d);
		}
		else{
			int l,r,x,t;
			scanf("%d%d%d%d",&l,&r,&x,&t);
			printf("%d\n",query(1,l,r,x,d-t+1));
		}
	}
	return 0;
}
```


---

## 作者：juju527 (赞：4)

#### [更好的阅读体验](https://juju527.github.io/post/ti-jie-p4585-fjoi2015huo-xing-shang-dian-wen-ti/)

### 前置知识
1. 线段树

2. 可持久化01trie

---

>第一道线段树分治题

>线段树分治是一种按时间分治的方法

>由于其结构类似线段树，被称为线段树分治

---

### 题意坑点
下面这个讨论里叙述得很清楚了，这里不再赘述

[传送门](https://www.luogu.com.cn/discuss/show/87100)

---
### 核心思想

将询问与修改离线

可能有这几种情况

---

1.单点修改，单点查询
	
这个完全不需要线段树分治吧

2.单点修改，区间查询（例如本题）
    
我们可以将每一个修改记录在包含该点的线段树上的$log$个节点上
    
把查询分解成$log$个线段树上的区间记录在这$log$个节点上
    
由于查询的区间包括了我们记录下的每一个小区间
    
而在每一个线段树区间记录下的修改都会影响这个区间
    
正确性显然
    
那么我们遍历一边整棵线段树，在每个节点进行该结点所记录的修改，再进行该结点的询问即可
    
3.区间修改，单点查询
	
将每一个修改分解成$log$个区间记录在线段树这$log$个节点上
    
将每一个查询记录在包含该点的线段树上的$log$个节点上
    
遍历线段树类比情况2即可

4.区间修改，区间查询
	
结合情况2，3就是这个东西

---

我们还需注意在所有中，应该是进行完了修改就直接查询

情况2中应在未递归时便撤销所有修改

---

### 本题做法

我们把答案分两个部分来求

#### 第一部分

先用可持久化trie解决所有商店的特殊商品对询问的贡献

这一部分不清楚的可以去学习下最大异或和

#### 第二部分

由于每个询问只能买某一段时间内的商品

暴力的对所有区间做的时间复杂度可达$O(q\times n\times log T)$，$T$为值域

我们考虑刚刚学到的线段树分治

将所有修改和询问按照上述的做法记录在线段树上

进行线段树分治

```cpp
inline void solve(register int k,register int l,register int r){
	Insert(k);//将所有修改加进可持久化01trie中
	if(l==r){
		for(register int i=0;i<que[k].size();i++){
			register int id=que[k][i].id;
			register int x=que[k][i].l,y=que[k][i].r,val=que[k][i].x;
			ans[id]=max(ans[id],query(x,y,val));
		}
        	//处理询问
		Delete(k);//清空可持久化01trie
		return ;
	}
	register int mid=l+((r-l)>>1);
	for(register int i=0;i<que[k].size();i++){
		register int id=que[k][i].id;
		register int x=que[k][i].l,y=que[k][i].r,val=que[k][i].x;
		ans[id]=max(ans[id],query(x,y,val));
	}
	Delete(k);
    //一定要先清空，这样做的原因应该比较显然
	solve(k<<1,l,mid);
	solve(k<<1|1,mid+1,r);
	return ;
}
```
这里处理可持久化01trie时需要用到一些叫常用的技巧

由于$upd$的序列商店编号不连续，我们需要离散化

在query时需要二分一下

---
### 复杂度分析
根据上述的线段树分治需要记录的东西很容易看出空间复杂度$nlogn+nlogT$

由于我们会遍历所有记录的询问和查询共$nlogn$个

无论是可持久化01trie的插入还是询问时间复杂度均为$O(logn)$

故总复杂度$O(nlog^2n)$

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=1000005,maxm=100005;
struct Upd{
	int s,v;
	bool operator <(Upd i)const{
		return s<i.s;
	}
};
struct Que{
	int id,l,r,x;
};
int ans[maxm];
struct trie{
	int s[2];
	int b;
}t[20*maxm];
int tot=0;
int rt[maxn];
int lp[maxn],rp[maxn];
int W=0;
int shop[maxn];
bool vis[maxm];
vector<Upd>upd[maxm<<2];
vector<Que>que[maxm<<2];
inline int read(){
    register int x=0,y=1;
    register char ch=getchar();
    while(ch<48||ch>57){if(ch==45)y=-1;ch=getchar();}
    while(ch>=48&&ch<=57)x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
    return x*y;
}
inline void write(register int x){
	if(!x)return ;
	write(x/10);
	putchar(x%10+'0');
	return ;
}
inline void clear(register int k){
	t[k].s[0]=t[k].s[1]=t[k].b=0;
	return ;
}
inline int newnode(){
	clear(tot+1);
	return ++tot;
}
inline void ins(register int x,register int y,register int val){
	if(!rt[x])rt[x]=newnode();
	register int k=rt[x],l=rt[y];
	t[k].b=x;
	for(register int i=16;i>=0;i--){
		register bool to=((val&(1<<i))>>i);
		if(!t[k].s[to])t[k].s[to]=newnode();
		t[k].s[to^1]=t[l].s[to^1];
		k=t[k].s[to];
		t[k].b=x;
		l=t[l].s[to];
	}
	return ;
}
inline int search(register int x){
	register int l=0,r=W+1;
	while(l+1<r){
		register int mid=l+((r-l)>>1);
		if(shop[mid]<=x)
			l=mid;
		else
			r=mid;
	}
	return l;
}
inline int query(register int l,register int r,register int val){
	register int lft=l;
	l=search(l);
	r=search(r);
	if(shop[l]<lft)l++;
	l=lp[l];r=rp[r];
	register int k=rt[r],ans=0;
	for(register int i=16;i>=0;i--){
		register bool to=((((val&(1<<i)))>>i)^1);
		if(t[k].s[to]==0||t[t[k].s[to]].b<l)to^=1;
		else ans+=(1<<i);
		k=t[k].s[to];
	}
	return ans;
}
inline void modify1(register int k,register int l,register int r,register int x,register int p,register int val){
	if(l>x||r<x)return ;
	if(l==r){
		upd[k].push_back((Upd){p,val});
		return ;
	}
	register int mid=l+((r-l)>>1);
	modify1(k<<1,l,mid,x,p,val);
	modify1(k<<1|1,mid+1,r,x,p,val);
	upd[k].push_back((Upd){p,val});
	return ;
}
inline void modify2(register int k,register int l,register int r,register int x,register int y,register int id,register int p,register int q,register int val){
	if(y<x)return ;
	if(l>y||r<x)return ;
	if(l>=x&&r<=y){
		que[k].push_back((Que){id,p,q,val});
		return ;
	}
	register int mid=l+((r-l)>>1);
	modify2(k<<1,l,mid,x,y,id,p,q,val);
	modify2(k<<1|1,mid+1,r,x,y,id,p,q,val);
	return ;
}
inline void Insert(register int k){
	sort(upd[k].begin(),upd[k].end());
	if(upd[k].size()){
		ins(1,0,upd[k][0].v);
		W=1;
		shop[W]=upd[k][0].s;
		lp[W]=1;
	}
	for(register int i=1;i<upd[k].size();i++){
		register int p1=upd[k][i].s,p2=upd[k][i-1].s;
		ins(i+1,i,upd[k][i].v);
		if(p1>p2){
			W++;
			shop[W]=p1;
			rp[W-1]=i;lp[W]=i+1;
		}
	}
	rp[W]=upd[k].size();
	return ;
}
inline void Delete(register int k){
	for(register int i=1;i<=tot;i++)clear(i);
	for(register int i=1;i<=upd[k].size();i++)rt[i]=0;
	tot=0;
	return ;
}
inline void solve(register int k,register int l,register int r){
	Insert(k);
	if(l==r){
		for(register int i=0;i<que[k].size();i++){
			register int id=que[k][i].id;
			register int x=que[k][i].l,y=que[k][i].r,val=que[k][i].x;
			ans[id]=max(ans[id],query(x,y,val));
		}
		Delete(k);
		return ;
	}
	register int mid=l+((r-l)>>1);
	for(register int i=0;i<que[k].size();i++){
		register int id=que[k][i].id;
		register int x=que[k][i].l,y=que[k][i].r,val=que[k][i].x;
		ans[id]=max(ans[id],query(x,y,val));
	}
	Delete(k);
	solve(k<<1,l,mid);
	solve(k<<1|1,mid+1,r);
	return ;
}
int main(){
    freopen("[FJOI2015]火星商店问题.in","r",stdin);
    freopen("[FJOI2015]火星商店问题.out","w",stdout);
   	register int n,m;
	n=read();m=read();
	clear(0);
	for(register int i=1;i<=n;i++){
		W++;
		shop[W]=i;
		lp[W]=i;rp[W]=i;
		ins(i,i-1,read());
	}
	register int day=1;
	for(register int i=1;i<=m;i++){
		register int opt,l,r,x,d;
		opt=read();l=read();r=read();
		if(!opt){
			if(i>1)day++;
			modify1(1,1,m,day,l,r);
		}
		else{
			vis[i]=1;
			x=read();d=read();
			modify2(1,1,m,max(day-d+1,1),day,i,l,r,x);
			ans[i]=query(l,r,x);
		}
	}
	for(register int i=1;i<=tot;i++)clear(i);
	for(register int i=1;i<=n;i++)rt[i]=0;
	tot=0;
	solve(1,1,m);
	for(register int i=1;i<=m;i++)
		if(vis[i]){
			if(ans[i])write(ans[i]);
			else putchar('0');
			putchar('\n');
		}
    return 0;
}

```

---

## 作者：wcyQwQ (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P4585)

[可能更好的阅读体验](https://chenyu-w.github.io./2023/05/01/P4585%20%E7%81%AB%E6%98%9F%E5%95%86%E5%BA%97%E9%97%AE%E9%A2%98/)

本来想练线段树分治的，稍微想了一下发现了一个线段树套 01-Trie 的在线做法，好写一发过了。

## 分析

首先考虑没有时间限制怎么做，显然是对序列开一棵线段树，然后每个节点开一棵 01-Trie，存当前区间所有数，修改和查询都是 trivial 的。 

现在有一个时间的限制，我们考虑类似可持久化 01-Trie 的处理，对每一个 Trie 上的节点，维护一个 $last$ 值，来表示子树中最大的时间戳，在查询时，如果该节点的 $last$ 值小于我们的时间限制，就跳到另一棵子树。特别地，对于每一个特殊商品，我们把它的时间戳设为 $+\infty$，这样保证它能被考虑到，时间复杂度 $O(n\log^2 n)$。

注意空间开大！

## 代码

```c++
#include <bits/stdc++.h>
#define L(i, j, k) for (int i = (j); i <= (k); i++)
#define R(i, j, k) for (int i = (j); i >= (k); i--)
#define ll long long
#define ld long double
#define ull unsigned long long

using namespace std;
const int N = 1e5 + 10, M = 5e7 + 10, INF = 1 << 30;
int a[N], tr[M][2], last[M][2], tot, cnt;
struct Sgt {
    int l, r, root;
} t[N << 2];

template<class T = int> T read() {
    T x = 0, y = 1; char c = getchar();
    while (c < '0' || c > '9') {if (c == '-') y = -1; c = getchar();}
    while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * y;
}

inline void insert(int p, int x, int t) {
    R(i, 18, 0) {
        int c = x >> i & 1;
        if (!tr[p][c]) tr[p][c] = ++tot;
        last[p][c] = max(last[p][c], t), p = tr[p][c];
    }
}

inline int ask(int p, int x, int t) {
    int res = 0;
    R(i, 18, 0) {
        int c = x >> i & 1;
        if (tr[p][c ^ 1] && last[p][c ^ 1] >= t) res += 1 << i, p = tr[p][c ^ 1];
        else p = tr[p][c];
    }
    return res;
}

inline void build(int p, int l, int r) {
    t[p].l = l, t[p].r = r, t[p].root = ++tot;
    L(i, l, r) insert(t[p].root, a[i], INF);
    if (l == r) return;
    int mid = (l + r) >> 1;
    build(p << 1, l, mid), build(p << 1 | 1, mid + 1, r);
}

inline void modify(int p, int x, int v) {
    insert(t[p].root, v, cnt);
    if (t[p].l == t[p].r) return;
    int mid = (t[p].l + t[p].r) >> 1;
    if (x <= mid) modify(p << 1, x, v);
    else modify(p << 1 | 1, x, v);
}

inline int query(int p, int l, int r, int x, int d) {
    if (l <= t[p].l && t[p].r <= r) return ask(t[p].root, x, d);
    int mid = (t[p].l + t[p].r) >> 1, res = 0;
    if (l <= mid) res = max(res, query(p << 1, l, r, x, d));
    if (r > mid) res = max(res, query(p << 1 | 1, l, r, x, d));
    return res;
}

int main() {
    int n = read(), m = read();
    L(i, 1, n) a[i] = read();
    build(1, 1, n);
    while (m--) {
        int op = read();
        if (!op) {
            cnt++;
            int x = read(), v = read();
            modify(1, x, v);
        }
        else {
            int l = read(), r = read(), x = read(), d = read();
            printf("%d\n", query(1, l, r, x, cnt - d + 1));
        }
    }
    return 0;   
}
```



---

## 作者：ExplodingKonjac (赞：3)

### [原题链接](https://www.luogu.com.cn/problem/P4585)

好像很多题解都是线段树分治，那我就来弘扬一下线段树大力套 $\text{01-Trie}$。~~其实是我不会线段树分治~~

## 写在前面

以下内容是对~~毒瘤~~题面的一些解释，讨论区已经有大佬提醒了，但还是放在这里~~造福群众~~比较好。

### 题意  

求出在标号和时间的两维限制下的 $x\operatorname{xor} \text{(a big bunch of numbers)}$ 的最大值。

### 输入

根据样例推测，实际上**每天只会有一个 $0$ 操作**，也就是说，每次遇到 $0$ 操作就代表新的一天开始，而 $0$ 操作后面跟着的**所有 $1$ 操作都属于这一天**。

在题意这里卡了好久，看了讨论区里的提醒之后一遍过了（

~~感觉毒瘤题面完全没有提到，差评~~

## 解题思路

时间和下标但凡只有其中一维，这题都是可持久化 $\text{01-Trie}$ 的模板题。

但现在同时有两维，所以我们考虑使用线段树套 $\text{01-Trie}$。线段树处理下标，$\text{01-Trie}$ 处理时间。

具体地，在查询时在线段树里找到所有相关区间，接着在这些区间对应的 $\text{Trie}$ 里找 $\operatorname{xor} x$ 的最大值。每个 $\text{Trie}$ 节点要记录一个 $maxt$，表示该节点“管辖”的数的加入时间的最大值。一个节点必须要满足 $maxt\ge now-d+1$ 才可以走。

最后所有相关区间的答案取 $\max$ 即可。题解区里有线段树套可持久化 $\text{01-Trie}$ 的，但是本题的询问按照时间顺序排列，所以不用可持久化也可以。

## 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
inline int read()
{
	char ch;int x=0;
	for(ch=getchar();ch<'0' || ch>'9';ch=getchar());
	for(;ch>='0' && ch<='9';x=x*10+ch-'0',ch=getchar());
	return x;
}
struct TrieNode{ int maxt,ch[2]; }tr[40000005];
int cnt;
void insert(int x,int t,int &i,int dep=17) //内层Trie
{
	if(!i)	i=++cnt;
	tr[i].maxt=max(tr[i].maxt,t);
	if(!dep)	return;
	insert(x,t,tr[i].ch[(x>>dep-1)&1],dep-1);
}
int query(int x,int t,int i) //内层查询
{
	int dep=17,res=0;
	while(dep)
	{
		bool fl=!((x>>dep-1)&1);
		if(tr[i].ch[fl] && tr[tr[i].ch[fl]].maxt>=t)
			i=tr[i].ch[fl],res=res<<1|1;
		else
			i=tr[i].ch[!fl],res=res<<1;
		dep--;
	}
	return res;
}
struct TreeNode
{
	int val;
	TreeNode *lc,*rc;
	TreeNode(): val(0)
		{ lc=rc=nullptr; }
}*rt;
typedef TreeNode *pNode;
void build(int l,int r,pNode &i=rt)
{
	i=new TreeNode;
	if(l!=r)
	{
		int mid=(l+r)>>1;
		build(l,mid,i->lc),build(mid+1,r,i->rc);
	}
}
void modify(int p,int t,int x,int l=1,int r=n,pNode i=rt) //外层线段树
{
	insert(x,t,i->val);
	if(l!=r)
	{
		int mid=(l+r)>>1;
		if(mid>=p)	modify(p,t,x,l,mid,i->lc);
		else	modify(p,t,x,mid+1,r,i->rc);
	}
}
int query(int lq,int rq,int x,int t,int l=1,int r=n,pNode i=rt) //外层查询
{
	if(l>=lq && r<=rq)
		return query(x,t,i->val);
	int mid=(l+r)>>1,lans=0,rans=0;
	if(mid>=lq)	lans=query(lq,rq,x,t,l,mid,i->lc);
	if(mid<rq)	rans=query(lq,rq,x,t,mid+1,r,i->rc);
	return max(lans,rans);
}
int main()
{
	n=read(),m=read();
	build(1,n);
	for(int i=1;i<=n;i++)	modify(i,m+1,read());
	int i=0;
	while(m--)
	{
		int opt=read();
		if(opt==0)
		{
			int s=read(),v=read();
			modify(s,++i,v);
		}
		else
		{
			int l=read(),r=read(),x=read(),d=read();
			printf("%d\n",query(l,r,x,i-d+1));
		}
	}
	return 0;
}
```


---

## 作者：hl666 (赞：3)

颓文化课作业到很晚写篇博客清醒一下

首先我们仔细阅读并猜测了题意之后，就会想到一个暴力的**线段树套可持久化0/1Trie**的做法，但是它显然是过不去的

~~由于最近再做**线段树分治**的题~~，我们可以想到用线段树分治来解决这个问题

考虑对于每一次询问，我们都可以找出它连续询问的一段时间区间，然后把它扔进线段树的每个节点里

考虑怎么加点，如果暴力插入修改那就和暴力没什么区别了，我们还要考虑进一步优化

还是一个老套路，由于线段树分治是一种**离线**算法，因此插入修改的顺序完全可以由我们自己决定

那么再此利用分治的思想，每次插入点时一个区间一个区间的加入，查询的话就用**二分+可持久化0/1Trie**来资瓷就好了

这样总体复杂度就到了可以接受的$O(n\log^2 n)$，足以通过此题

```cpp
#include<cstdio>
#include<cctype>
#include<iostream>
#include<vector>
#include<algorithm>
#define RI register int
#define CI const int&
#define Tp template <typename T>
using namespace std;
const int N=100005,R=17;
struct event
{
	int s,v,t;
	friend inline bool operator < (const event& A,const event& B)
	{
		return A.s<B.s;
	}
}et[N]; int cnt_et;
struct ques
{
	int l,r,tl,tr,v;
}q[N]; int cnt_q;
int n,m,opt,x,ans[N];
class FileInputOutput
{
	private:
		static const int S=1<<21;
		#define tc() (A==B&&(B=(A=Fin)+fread(Fin,1,S,stdin),A==B)?EOF:*A++)
		#define pc(ch) (Ftop!=Fend?*Ftop++=ch:(fwrite(Fout,1,S,stdout),*(Ftop=0)++=ch))
		char Fin[S],Fout[S],*A,*B,*Ftop,*Fend; int pt[15];
	public:
		inline FileInputOutput(void) { Ftop=Fout; Fend=Fout+S; }
		Tp inline void read(T& x)
		{
			x=0; char ch; while (!isdigit(ch=tc()));
			while (x=(x<<3)+(x<<1)+(ch&15),isdigit(ch=tc()));
		}
		Tp inline void write(T x)
		{
			RI ptop=0; while (pt[++ptop]=x%10,x/=10);
			while (ptop) pc(pt[ptop--]+48); pc('\n');
		}
		inline void flush(void)
		{
			fwrite(Fout,1,Ftop-Fout,stdout);
		}
		#undef tc
		#undef pc
}F;
class Zero_One_Trie
{
	private:
		struct segment
		{
			int ch[2],sum;
			inline segment(CI Ls=0,CI Rs=0,CI Sum=0)
			{
				ch[0]=Ls; ch[1]=Rs; sum=Sum;
			}
		}node[N*R<<2]; int tot,num,rt[N];
		#define S(x) node[x].sum
		inline void _insert(CI lst,int& now,CI val,CI d=R)
		{
			now=++tot; node[now]=node[lst]; ++S(now); if (!~d) return;
			bool c=(val>>d)&1; _insert(node[lst].ch[c],node[now].ch[c],val,d-1);
		}
		inline int _query(CI lst,CI now,CI val,CI d=R)
		{
			if (!~d) return 0; bool c=(val>>d)&1; return S(node[now].ch[c^1])-S(node[lst].ch[c^1])?
			_query(node[lst].ch[c^1],node[now].ch[c^1],val,d-1)+(1<<d):_query(node[lst].ch[c],node[now].ch[c],val,d-1);
		}
		#undef S
	public:
		inline void insert(CI val)
		{
			++num; _insert(rt[num-1],rt[num],val);
		}
		inline int query(CI l,CI r,CI val)
		{
			if (l>r) return 0; _query(rt[l-1],rt[r],val);
		}
		inline void clear(void)
		{
			RI i; for (i=1;i<=tot;++i) node[i]=segment();
			for (i=1;i<=num;++i) rt[i]=0; tot=num=0;
		}
}T;
class Segment_Tree
{
	private:
		vector <int> pv[N<<2]; event ls[N],rs[N]; int stk[N],top;
		#define TN CI now=1,CI l=1,CI r=cnt_et
		#define LS now<<1,l,mid
		#define RS now<<1|1,mid+1,r
		inline void calc(CI now,CI l,CI r)
		{
			T.clear(); top=0; for (RI i=l;i<=r;++i) stk[++top]=et[i].s,T.insert(et[i].v);
			for (vector <int>::iterator it=pv[now].begin();it!=pv[now].end();++it)
			{
				int ql=upper_bound(stk+1,stk+top+1,q[*it].l-1)-stk;
				int qr=upper_bound(stk+1,stk+top+1,q[*it].r)-stk-1;
				ans[*it]=max(ans[*it],T.query(ql,qr,q[*it].v));
			}
		}
	public:
		inline void insert(CI beg,CI end,CI pos,TN)
		{
			if (beg>end) return; if (beg<=l&&r<=end) return (void)(pv[now].push_back(pos));
			int mid=l+r>>1;	if (beg<=mid) insert(beg,end,pos,LS); if (end>mid) insert(beg,end,pos,RS);
		}
		inline void solve(CI st=1,CI ed=cnt_et,TN)
		{
			if (st>ed) return; calc(now,st,ed); if (l==r) return; int mid=l+r>>1,lct=0,rct=0;
			RI i; for (i=st;i<=ed;++i) if (et[i].t<=mid) ls[++lct]=et[i]; else rs[++rct]=et[i];
			for (i=1;i<=lct;++i) et[st+i-1]=ls[i]; for (i=1;i<=rct;++i) et[st+lct+i-1]=rs[i];
			solve(st,st+lct-1,LS); solve(st+lct,ed,RS);
		}
		#undef TN
		#undef LS
		#undef RS
}SEG;
int main()
{
	//freopen("CODE.in","r",stdin); freopen("CODE.out","w",stdout);
	RI i; for (F.read(n),F.read(m),i=1;i<=n;++i) F.read(x),T.insert(x);
	for (i=1;i<=m;++i)
	{
		F.read(opt); if (!opt) F.read(et[++cnt_et].s),F.read(et[cnt_et].v),et[cnt_et].t=cnt_et;
		else F.read(q[++cnt_q].l),F.read(q[cnt_q].r),F.read(q[cnt_q].v),
		F.read(x),q[cnt_q].tl=max(1,cnt_et-x+1),q[cnt_q].tr=cnt_et;
	}
	for (i=1;i<=cnt_q;++i) ans[i]=T.query(q[i].l,q[i].r,q[i].v),SEG.insert(q[i].tl,q[i].tr,i);
	for (sort(et+1,et+cnt_et+1),SEG.solve(),i=1;i<=cnt_q;++i) F.write(ans[i]);
	return F.flush(),0;
}
```

---

## 作者：Infiltrator (赞：3)

[$\Large\color{#FFBBFF}\textit{Tian-Xing's blog}$](https://Tian-Xing.github.io)

------------

# Description

[传送门](https://www.luogu.com.cn/problem/P4585)

------------

# Solution

其实这题是没有必要使用可持久化$Trie$的。

首先建立一颗线段树，每个节点维护它所代表的那些商店的商品的标价所构成的$Trie$。

这样如果没有时间上的限制，我们可以将每次的询问拆成对于$log(n)$个线段树上的节点的询问，每次在$Trie$上花费$log(w)$的时间复杂度查询最大值，然后对所有答案取$max$即为所求答案。

注意这里时间的限制是一个后缀，也就是说是从某个历史节点延续的目前节点的，那么可以对于每个$Trie$上的点记录最后遍历到的时间，这样$d$时间以前的就是记录的时间$<$目前时间$- d + 1$的节点。这些节点实际上在$Trie$上式没有的，在查询的时候直接将它们忽略即可。

对于每个商店的特殊商品，将它们最后遍历到的时间赋值为$INF$即可，这些特殊商品的存在也保证了每哥询问一定有解。

综上，由于$n$和$w$同级，时间复杂度为$O(log^2n)$，空间复杂度为$O(log^2n)$。

------------

# Code

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

const int N = 100000;
const int INF = 0x7fffffff;

int n, m, root[(N << 2) + 50], num, tim[30000050], trie[30000050][2], cnt;

void Read(int &x)
{
    x = 0; int p = 0; char st = getchar();
    while (st < '0' || st > '9') p = (st == '-'), st = getchar();
    while (st >= '0' && st <= '9') x = (x << 1) + (x << 3) + st - '0', st = getchar();
    x = p ? -x : x;
    return;
}

void Insert(int &root, int val, int id)
{
    if (!root) root = ++num;
    int now = root;
    for (int i = 17; i >= 0; i--)
    {
        int c = ((val >> i) & 1);
        if (!trie[now][c]) trie[now][c] = ++num;
        now = trie[now][c]; tim[now] = max(tim[now], id);
    } 
    return;
}

int Ans(int root, int val, int id)
{
    int ans = 0, now = root;
    for (int i = 17; i >= 0; i--)
    {
        int c = ((val >> i) & 1);
        if (trie[now][c ^ 1] && tim[trie[now][c ^ 1]] >= cnt - id + 1) 
            now = trie[now][c ^ 1], ans = ans + (1 << i);
        else now = trie[now][c];
    }
    return ans;
}

void Change(int k, int l, int r, int pos, int val, int tim)
{
    Insert(root[k], val, tim);
    if (l == r) return; 
    int mid = (l + r) >> 1;
    if (pos <= mid) Change(k << 1, l, mid, pos, val, tim);
    else Change(k << 1 | 1, mid + 1, r, pos, val, tim);
    return;
}

int Query(int k, int l, int r, int x, int y, int val, int tim)
{
    if (x <= l && r <= y) return Ans(root[k], val, tim);
    int mid = (l + r) >> 1;
    if (y <= mid) return Query(k << 1, l, mid, x, y, val, tim);
    else if (x > mid) return Query(k << 1 | 1, mid + 1, r, x, y, val, tim);
    else return max(Query(k << 1, l, mid, x, y, val, tim), Query(k << 1 | 1, mid + 1, r, x, y, val, tim));
}

int main()
{
    Read(n); Read(m);
    for (int i = 1, x; i <= n; i++) Read(x), Change(1, 1, n, i, x, INF);
    int p, l, r, x, d, s, val;
    while (m--)
    {
        Read(p);
        if (p)
        {
            Read(l); Read(r); Read(x); Read(d);
            printf("%d\n", Query(1, 1, n, l, r, x, d));
        }
        else
        {
            cnt++;
            Read(s); Read(val);
            Change(1, 1, n, s, val, cnt);
        }
    }
    return 0;
}
```

---

## 作者：Octopus_Lady (赞：2)

可持久化  01Trie+  线段树分治。

首先用  Trie  算出所有询问对于特殊商品的答案。

然后我们给每一个进货的商品加上一个时间值，每个询问就会有相对应的时间区间。

我们开一棵时间的线段树，把每个询问加到线段树上，每个节点用一个  vector  储存这个节点的询问。

显然每个询问最多会在 $ \log $ 个节点上。

然后我们把所有进货按商店排序，由线段树自顶向下进行分治，分治的时候还记录一下进货的区间。

每次到线段树的某个节点时，先计算出当前节点的答案（因为所有进货是按商店排序的，所以依旧可以用  01Trie  算，算之前记得清空），然后把时间小于等于  mid  的放到左边，大于  mid  的放到右边，向下递归。

代码展示：

```cpp
#include<bits/stdc++.h>
#define pb push_back
#define ls p<<1
#define rs p<<1|1
#define mid ((l+r)>>1)
using namespace std;
const int N=100007;
int ch[N<<5][2],sum[N<<5],root[N],ans[N],stk[N],d[18],top,n,m,cnt;
vector<int>vec[N];
struct node{int l,r,L,R,x;}q[N];
struct Node{int s,v,t;}a[N],t1[N],t2[N];
int operator<(Node a,Node b){return a.s<b.s;}
int read(){int x=0;char c=getchar();while(!isdigit(c))c=getchar();while(isdigit(c))x=x*10+c-48,c=getchar();return x;}
int max(int a,int b){return a>b? a:b;}
void split(int x)
{
    memset(d,0,sizeof d);
    for(int i=0;i<=17;++i) d[i]=x>>i&1;
}
void insert(int &p,int pre)
{
    sum[p=++cnt]=sum[pre]+1;
    for(int i=17,t=p;~i;--i) ch[t][d[i]^1]=ch[pre][d[i]^1],pre=ch[pre][d[i]],sum[t=ch[t][d[i]]=++cnt]=sum[pre]+1;
}
int query(int l,int r)
{
    int ans=0,i;
    for(i=17;~i;--i)
    if(sum[ch[l][d[i]^1]]^sum[ch[r][d[i]^1]]) ans|=1<<i,l=ch[l][d[i]^1],r=ch[r][d[i]^1];
    else l=ch[l][d[i]],r=ch[r][d[i]];
    return ans;
}
void update(int p,int l,int r,int L,int R,int x)
{
    if(L>R||r<L||l>R) return ;
    if(L<=l&&r<=R) return (void)(vec[p].pb(x));
    update(ls,l,mid,L,R,x);update(rs,mid+1,r,L,R,x);
}
void cal(int p,int L,int R)
{
    cnt=0;
    int i,l,r,k,top=0;
    for(i=L;i<=R;++i) stk[++top]=a[i].s,split(a[i].v),insert(root[top],root[top-1]);
    for(i=0;i<vec[p].size();++i)
    k=vec[p][i],l=upper_bound(stk+1,stk+top+1,q[k].l-1)-(stk+1),r=upper_bound(stk+1,stk+top+1,q[k].r)-(stk+1),split(q[k].x),ans[k]=max(ans[k],query(root[l],root[r]));
}
void solve(int p,int l,int r,int L,int R)
{
    if(L>R) return;
    cal(p,L,R);
    if(l==r) return;
    int p1=0,p2=0,i;
    for(i=L;i<=R;++i) if(a[i].t<=mid) t1[++p1]=a[i]; else t2[++p2]=a[i];
    for(i=1;i<=p1;++i) a[i+L-1]=t1[i];
    for(i=1;i<=p2;++i) a[i+L+p1-1]=t2[i];
    solve(ls,l,mid,L,L+p1-1),solve(rs,mid+1,r,L+p1,R);
}
int main()
{
    n=read(),m=read();
    int i,tot=0,T=0,l,r,x,d;
    for(i=1;i<=n;++i) split(read()),insert(root[i],root[i-1]);
    while(m--)
    if(read()) l=read(),r=read(),x=read(),d=read(),split(x),ans[++tot]=query(root[l-1],root[r]),q[tot]=(node){l,r,max(1,T-d+1),T,x};
    else x=read(),d=read(),a[++T]=(Node){x,d,T};
    for(i=1;i<=tot;++i) update(1,1,T,q[i].L,q[i].R,i);
    sort(a+1,a+T+1),solve(1,1,T,1,T);
    for(i=1;i<=tot;++i) printf("%d\n",ans[i]);
}
```


---

## 作者：Y_B_X (赞：1)

[原题链接](https://www.luogu.com.cn/problem/P4585)

~~题面过长含糊不清差评~~

补一发树状数组套可持久化 $\text{01trie}$ 的题解。

思路还算简单，由于查询相当于是**时间**与**标号**两维限制下，求与某个数的异或最大值。

那就可以对时间限制用一个树状数组解决，同时在每个时间下对标号用一颗可持久化 $\text{01trie}$。

询问时要把树状数组对应时间上标号合法的 $\text{01trie}$ 的根拎出来，相当于在时间与标号上都用一次差分。

为了在 $\text{01trie}$ 上找合法标号的根，可以在每个时间上开一个 $\text{multiset}$，用 $\text{lowerbound}$ 以及 $\text{upperbound}$ 定位根。

还有所谓的特殊商品，直接无脑再写一个可持久化 $\text{01trie}$，与答案取最大值即可。  

时间复杂度是 $O((n+m)\log(n)^2)$ 的。  

代码：  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10,M=3.5e7+10,K=18;
int n,m,x,y,tt,tot,res,ans;
int a[N],rt[N];
struct inq{int opt,l,r,x,d,t;}q[N];
struct trie{int s[2],sz;}t[M];
void update(int &k,int kk,int x,int i){
	k=++tot;t[k]=t[kk];t[k].sz++;if(i<0)return;
	bool b=x&(1<<i);update(t[k].s[b],t[kk].s[b],x,i-1);
}
struct node{
	int i,x;mutable int rt; 
	node(int _i,int _x=0):i(_i),x(_x){};
	bool operator <(const node &x)const{return i<x.i;};
};
int lowbit(int x){return x&(-x);}
int p[N][2];multiset<node>s[N];
#define msit multiset<node>::iterator
#define f0 for(int i=1;i<=p[0][0];i++)
#define f1 for(int i=1;i<=p[0][1];i++)
void pre_update(int pos,int id,int x){
	for(int i=pos;i<=tt;i+=lowbit(i))s[i].insert(node(id,x));
}
void update(){
	for(int i=1;i<=tt;i++){
		int pre=0;
		s[i].insert(node(0,0));//不塞一个空的进去在lower_bound时会出问题 
		for(msit j=s[i].begin();j!=s[i].end();j++)
			update(j->rt,pre,j->x,K),pre=j->rt;
	}
}
void inquiry_pre(int l,int r,int pos,bool b){
	for(int i=pos;i;i-=lowbit(i)){
		msit l1=s[i].lower_bound(node(l));
		if(l1==s[i].end())continue;l1--;
		msit r1=s[i].upper_bound(node(r));r1--;
		p[++p[0][b]][b]=r1->rt,p[++p[0][b^1]][b^1]=l1->rt;
	}
}
void inquiry(int x,int k){
	if(k<0)return;int tmp=0;bool b=x&(1<<k);
	f1 tmp+=t[t[p[i][1]].s[b^1]].sz;f0 tmp-=t[t[p[i][0]].s[b^1]].sz;
	if(tmp){res+=1<<k;f0 p[i][0]=t[p[i][0]].s[b^1];f1 p[i][1]=t[p[i][1]].s[b^1];inquiry(x,k-1);}
	else {f0 p[i][0]=t[p[i][0]].s[b];f1 p[i][1]=t[p[i][1]].s[b];inquiry(x,k-1);}
}
void inquiry(int k1,int k2,int x,int k){
	if(k<0)return;bool b=x&(1<<k);
	int tmp=t[t[k2].s[b^1]].sz-t[t[k1].s[b^1]].sz;
	if(tmp)res+=1<<k,inquiry(t[k1].s[b^1],t[k2].s[b^1],x,k-1);
	else inquiry(t[k1].s[b],t[k2].s[b],x,k-1);
}
void inquiry_(int l,int r,int tl,int tr,int x){
	p[0][0]=p[0][1]=0;
	inquiry_pre(l,r,tr,1);
	inquiry_pre(l,r,tl-1,0);
	inquiry(x,K);
}
main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",&x),update(rt[i],rt[i-1],x,K);
	for(int i=1;i<=m;i++){
		scanf("%d",&q[i].opt);
		if(q[i].opt)scanf("%d%d%d%d",&q[i].l,&q[i].r,&q[i].x,&q[i].d);
		else scanf("%d%d",&q[i].l,&q[i].x),++tt;
		q[i].t=tt;
	}
	for(int i=1;i<=m;i++)if(!q[i].opt)pre_update(q[i].t,q[i].l,q[i].x);update();
	for(int i=1;i<=m;i++)if(q[i].opt){
		if(q[i].d&&q[i].t)inquiry_(q[i].l,q[i].r,max(q[i].t-q[i].d+1,1),q[i].t,q[i].x);
		ans=res,res=0;inquiry(rt[q[i].l-1],rt[q[i].r],q[i].x,K);ans=max(ans,res);
		printf("%d\n",ans);res=ans=0;
	}
}
```

---

## 作者：不知名用户 (赞：1)

前言：为什么好多题解用可持久化 Trie 或者离线下来处理。其实可以不用这么干啊。再喷一下出题人：每天以进货结束，差点以为天以任意事件结束。

如果只有一个商店怎么做？

如果没有购买时间限制，这就是一个 01trie 模板。

如果有，我们在遍历 trie 时顺便记录每个点所有子节点时间戳最大的是多少。

如果有商店，就对商店线段树分治即可。具体地，每个线段表示所有子节点商品价格的 trie。

所以为什么题解喜欢对时间分治（虽然线段树分治模板是时间分治）。这题时间和商品都是一个区间，都可以分治。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10, X = 20;

int rt[N*4], idx, mt[N*400], tr[N*400][2];

void ins(int p, int t, int x)
{
	int i;
	for(i=X;~i;i--)
	{
		mt[p] = max(mt[p],t);
		if(!tr[p][(x>>i)&1]) tr[p][(x>>i)&1] = ++idx;
		p = tr[p][(x>>i)&1];
	}
	mt[p] = max(mt[p],t);
}
int task(int p, int t, int x)
{
	int i, ans = 0;
	for(i=X;~i;i--)
	{
		int y = ((x >> i) & 1) ^ 1;
		if(tr[p][y]&&mt[tr[p][y]]>=t) ans += 1 << i, p = tr[p][y];
		else p = tr[p][1-y];
	}
	return ans;
}
void build(int p, int l, int r)
{
	rt[p] = ++idx;
	if(l==r) return;
	build(p*2,l,(l+r)>>1);build(p*2+1,((l+r)>>1)+1,r);
}
void add(int p, int L, int R, int x, int y, int z)
{
	ins(rt[p],y,z);
	if(L==R) return;
	int mid = L + R >> 1;
	if(x<=mid) add(p*2,L,mid,x,y,z);else add(p*2+1,mid+1,R,x,y,z);
}
int ask(int p, int l, int r, int t, int x, int L, int R)
{
	if(l<=L&&R<=r) return task(rt[p],t,x);
	int mid = L + R >> 1, ans = 0;
	if(l<=mid) ans = max(ans,ask(p*2,l,r,t,x,L,mid));
	if(mid<r) ans = max(ans,ask(p*2+1,l,r,t,x,mid+1,R));
	return ans;
}
int main()
{
	int n, m, day = 1, a, i;
	cin>>n>>m;
	build(1,1,n);
	for(i=1;i<=n;i++) cin>>a, add(1,1,n,i,114514,a);
	while(m--)
	{
		int op, l, r, x, d;
		cin>>op>>l>>r;
		if(op==0) add(1,1,n,l,++day,r);
		else cin>>x>>d, cout<<ask(1,l,r,day-d+1,x,1,n)<<'\n';
	}
	return 0;
}
```

---

## 作者：miaokehao (赞：1)

这道题很明显是要用到可持久化Trie的
如果不会请移步[P4585](https://www.luogu.org/problemnew/show/P4735)
我们可以用线段树分治对时间进行分治，在每一个节点用一个vector存储询问即可，可持久化Trie不要使用memset清空，只需要把节点数tot=0~~(否则将会获得TLE10个点的好成绩)~~
```
#include <bits/stdc++.h>
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#define res register int
#define ls (now<<1)
#define rs (now<<1|1)
#define N 1000005
using namespace std;
int n,m,base[32],tot1,tot2,ans[N];
char op[5];
inline int read()
{
  int X=0,w=0;
  char ch=0;
  while(!isdigit(ch))
  {
    w|=ch=='-';
    ch=getchar();
  }
  while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
  return w?-X:X;
}
struct papa{
    int id,w,day;
    inline bool operator<(const papa &b) const{
        return id<b.id;
    }
}thing[N<<2];
struct papa1{
    int sl,sr,tl,tr,sec;
    papa1():sl(0){};
    papa1(int sl0,int sr0,int tl0,int tr0,int sec0):sl(sl0),sr(sr0),tl(tl0),tr(tr0),sec(sec0){};
}Q[N];
struct Trie_con
{
  int root[N<<3],son[N<<3][2],tot,rtn,sum[N<<3];
  inline void clear(){
      tot=0;
  }
  inline void add(res &now,res last,res x)
  {
    now=tot+1;
    for(res i=17; ~i; i--)
    {
      sum[++tot]=sum[last]+1;
      bool b=x&base[i];
      son[tot][b]=tot+1,son[tot][!b]=son[last][!b];
      last=son[last][b];
    }
    sum[++tot]=sum[last]+1;
  }
  inline int query(res lt,res rt,res x)
  {
    if(lt>rt) return 0;
    res ans=0;
    for(res i=17; ~i; i--)
    {
      bool b=x&base[i];
      if(sum[son[rt][!b]]-sum[son[lt][!b]])
        ans+=base[i],lt=son[lt][!b],rt=son[rt][!b];
      else
        lt=son[lt][b],rt=son[rt][b];
    }
    return ans;
  }
} T;
struct Seg_div{
    vector<int> tr[N<<2];
    int top,st[N];
    papa st1[N],st2[N];
    inline void update(int now,int l,int r,int ql,int qr,int val){
        if(ql>qr) return;
        if(ql<=l&&r<=qr){
            tr[now].push_back(val);
            return ;
        }
        int mid=l+r>>1;
        if(mid>=ql) update(ls,l,mid,ql,qr,val);
        if(mid<qr)  update(rs,mid+1,r,ql,qr,val); 
    }
    inline int find(int num){
        res l=1,r=top,total=0;
        while(l<=r){
            int mid=l+r>>1;
            if(st[mid]>num) r=mid-1;
            else l=mid+1,total=mid;
        }
        return total;
    }
    inline void findans(int now,int ql,int qr){
        top=0;
        T.clear();
        for(res i=ql;i<=qr;i++){
            st[++top]=thing[i].id;
            T.add(T.root[top],T.root[top-1],thing[i].w);
        } 
        for(res i=0;i<tr[now].size();i++){
            res j=tr[now][i];
            res l=find(Q[j].sl-1),r=find(Q[j].sr);
            ans[j]=max(ans[j],T.query(T.root[l],T.root[r],Q[j].sec));
        }
    }
    inline void divide(int now,int l,int r,int ql,int qr){
        if(ql>qr) return ;
        int mid=l+r>>1,top1=0,top2=0;
        findans(now,ql,qr);
        if(l==r) return;
        for(res i=ql;i<=qr;i++){
            if(thing[i].day<=mid) st1[++top1]=thing[i];
            else st2[++top2]=thing[i];
        }
        for(res i=1;i<=top1;i++) thing[ql+i-1]=st1[i];
        for(res i=1;i<=top2;i++) thing[ql+i+top1-1]=st2[i];
        divide(ls,l,mid,ql,ql+top1-1);
        divide(rs,mid+1,r,ql+top1,qr);
    }
} S;
int main()
{
  n=read(),m=read();
  base[0]=1;
  for(res i=1; i<=17; i++)
    base[i]=base[i-1]<<1;
  for(res i=1; i<=n; i++)
    T.add(T.root[i],T.root[i-1],read());
  for(res i=1; i<=m; i++)
  {
    scanf("%s",op);
    if(op[0]=='0')
      thing[++tot1].id=read(),thing[tot1].w=read(),thing[tot1].day=tot1; 
    else
    {
      res L=read(),R=read(),y=read(),x=read();
      ans[++tot2]=T.query(T.root[L-1],T.root[R],y);
      Q[tot2]=papa1(L,R,max(1,tot1-x+1),tot1,y);
    }
  }
  for(res i=1;i<=tot2;i++)
    S.update(1,1,tot1,Q[i].tl,Q[i].tr,i); 
  sort(thing+1,thing+tot1+1);
  S.divide(1,1,tot1,1,tot1);
  for(res i=1;i<=tot2;i++)
    printf("%d\n",ans[i]);
  return 0;
}
```

---

## 作者：fanypcd (赞：0)

$$\color{#FFF}\texttt{先吐槽一下垃圾题面：每天的事件按照先事件 0，后事件 1 的顺序排列。正常人都以为每天的事件长这样：0 ...0 ...0 ...1 ...1 ...1 ...但是这样样例都不对。实际上每天只能有一个 0 事件。}$$

------

做法：线段树 + 可持久化 trie

前置芝士：

[线段树](https://www.luogu.com.cn/problem/P3372)

[可持久化 trie](https://www.luogu.com.cn/problem/P4735)

这道题有一个比较显然的时空均为 $O(n \log^2 n)$ 的做法，空间 300MB 左右，luogu 可以 AC。

枚举时间，用线段树维护商店序列，线段树上的每个节点开一个 trie 存储当前节点对应区间内商店的货物（需要记录货物的加入时间）。

询问就在线段树上查询，每个询问至多拆成 $\log n$ 个区间的询问，每个区间访问对应节点的 trie，也是 $\log n$，故时间复杂度 $O(n \log^2 n)$，但是线段树相当于每层都会开一个完整的商店序列的 trie，所以空间复杂度也是 $O(n \log^2 n)$。

------

校内 OJ 这道题空间限制只有 256M，需要空间复杂度更低的做法。

既然线段树维护序列不讨好，那考虑维护询问的时间。

即，对于每个询问的时间范围，在线段树上将其拆成不超过 $\log n$ 个范围，此时询问就会落在线段树的节点上。

同时线段树的每个节点再存下当前节点对应的时间区间出现过的所有 0 事件（按增加位置排序）。

最后遍历线段树统一处理询问。

递归处理左右儿子，然后处理当前节点的询问（记得清空可持久化 trie）。

对于当前节点，按 0 事件的位置依次添加进 trie 中（只有这些事件对答案有贡献，注意位置可能不连续），处理询问时二分出询问位置在事件中的真实位置，然后仿照 P4735 查询就好了。

总的事件数与 $n$  同阶，0 事件需要在路径上的每个节点都记录、排序并加入 trie 树，时间 $O(n \log^2 n)$，空间 $O(n \log n)$，1 事件会被拆成 $\log n$ 个节点上的询问，每个节点需要二分并查询 trie 树，时间 $O(n \log^2 n)$，空间 $O(n \log n)$。

所以我们就得到了一个时空复杂度分别为 $O(n \log^2 n)$，$O(n \log n)$ 的优秀做法。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
template <class T> inline void read(T &x)
{
	x = 0;
	int f = 0;
	char ch = getchar();
	while(ch < '0' || ch > '9')
	{
		f |= ch == '-';
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9')
	{
		x = x * 10 + (ch - 48);
		ch = getchar();
	}
	x = f ? -x : x;
	return;
}
#define N 100005
struct question
{
	int id, l, r, v;
};
vector<question> que[N << 2];
struct operation
{
	int pos, v;
};
bool operator < (const operation &a, const operation &b)
{
	return a.pos < b.pos;
}
vector<operation> opt[N << 2];
void updateque(int root, int l, int r, int L, int R, question v)
{
	if(L > R)
	{
		return;
	}
	if(L <= l && r <= R)
	{
		que[root].emplace_back(v);
		return;
	}
	int mid = (l + r) >> 1;
	if(L <= mid)
	{
		updateque(root << 1, l, mid, L, R, v);
	}
	if(mid < R)
	{
		updateque(root << 1 | 1, mid + 1, r, L, R, v);
	}
	return;
}
void updateopt(int root, int l, int r, int tim, operation v)
{
	opt[root].emplace_back(v);
	if(l == r)
	{
		return;
	}
	int mid = (l + r) >> 1;
	if(tim <= mid)
	{
		updateopt(root << 1, l, mid, tim, v);
	}
	else
	{
		updateopt(root << 1 | 1, mid + 1, r, tim, v);
	}
	return;
}
int ch[N * 20][2], cnt[N * 20], tot;
inline void clone(int &x)
{
	tot++;
	ch[tot][0] = ch[x][0], ch[tot][1] = ch[x][1];
	cnt[tot] = cnt[x] + 1;
	x = tot;
	return;
}
inline void update(int *x, int v)
{
	for(int i = 16; i >= 0; i--)
	{
		clone(*x);
		if((v >> i) & 1)
		{
			x = ch[*x] + 1;
		}
		else
		{
			x = ch[*x];
		}
	}
	clone(*x);
	return;
}
inline int query(int pl, int pr, int v)
{
	int ret = 0;
	for(int i = 16; i >= 0; i--)
	{
		int nowbit = (v >> i) & 1;
		if(cnt[ch[pr][nowbit ^ 1]] - cnt[ch[pl][nowbit ^ 1]])
		{
			ret += 1 << i;
			pl = ch[pl][nowbit ^ 1], pr = ch[pr][nowbit ^ 1];
		}
		else
		{
			pl = ch[pl][nowbit], pr = ch[pr][nowbit];
		}
	}
	return ret;
}
int rt[N], Ans[N];
void dfs(int root, int l, int r)
{
	sort(opt[root].begin(), opt[root].end());
	if(l != r)
	{
		int mid = (l + r) >> 1;
		dfs(root << 1, l, mid);
		tot = 0;
		dfs(root << 1 | 1, mid + 1, r);
		tot = 0;
	}
	int cnt = 0;
	for(auto x : opt[root])
	{
		cnt++, rt[cnt] = rt[cnt - 1];
		update(&rt[cnt], x.v);
	}
	for(auto x : que[root])
	{
		int nl = lower_bound(opt[root].begin(), opt[root].end(), (operation){x.l, 0}) - opt[root].begin() + 1;
		int nr = upper_bound(opt[root].begin(), opt[root].end(), (operation){x.r, 0}) - opt[root].begin();
		Ans[x.id] = max(Ans[x.id], query(rt[nl - 1], rt[nr], x.v));
	}
	return;
}
int n, m, T;
int a[N], op[N], l[N], r[N], x[N], d[N], t[N];
signed main()
{
	read(n), read(m);
	for(int i = 1; i <= n; i++)
	{
		read(a[i]);
	}
	for(int i = 1; i <= m; i++)
	{
		read(op[i]);
		if(!op[i])
		{
			T++;
			read(x[i]), read(d[i]);
		}
		else
		{
			read(l[i]), read(r[i]), read(x[i]), read(d[i]);
		}
		t[i] = T;
	}
	for(int i = 1; i <= n; i++)
	{
		rt[i] = rt[i - 1];
		update(&rt[i], a[i]);
	}
	for(int i = 1; i <= m; i++)
	{
		if(!op[i])
		{
			updateopt(1, 1, T, t[i], (operation){x[i], d[i]});
		}
		else
		{
			Ans[i] = query(rt[l[i] - 1], rt[r[i]], x[i]);
			updateque(1, 1, T, max(t[i] - d[i] + 1, 1), t[i], (question){i, l[i], r[i], x[i]});
		}
	}
	tot = 0;
	dfs(1, 1, T);
	for(int i = 1; i <= m; i++)
	{
		if(op[i])
		{
			printf("%d\n", Ans[i]);
		}
	}
	return 0;
}
```



---


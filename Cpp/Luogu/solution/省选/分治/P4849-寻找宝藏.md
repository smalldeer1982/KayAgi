# 寻找宝藏

## 题目背景

如果时光回到从前，或许，一切只是虚无……

小 W 坐着时光穿梭机到达了一个四维时空，在这里，开始了他的寻宝之旅。

## 题目描述

整个四维时空可以看做是一个四维的网格图，小 W 在 $(1,1,1,1)$ 这个位置，出口在 $(m,m,m,m)$。但由于小 W 毕竟是外来时空的人，他的行动在这里受到了一些限制。每次他只能使四个坐标中的一个加上 $1$。也就是说，他每次只能向右，向上，向前和向*（蒟蒻的出题人想不出来怎么形容了）走一步。

这个时空中有 $n$ 个宝藏，第 $i$ 个宝藏的坐标是 $(a_i,b_i,c_i,d_i)$，价值为 $v_i$。

小 W 想知道，他能够拿走宝藏的最大价值和是多少。由于小 W 也是一个喜欢未雨绸缪的人，他也希望能够找到多种不同的方案使它们都可以达到最大价值和的要求。不过这个数有可能很大，输出它对 $998244353$ 取模的结果即可。

注意！两个方案不同当且仅当两个方案中至少有一个宝藏选择的不同（一个位置有多个宝藏只算一种方案），如果仅仅路线不同而最终都选择了相同的宝藏不算不同的方案。

（小心两个宝藏待在相同的位置哦……）

## 说明/提示

对于样例 1，最好的办法是 $(1,1,1,1)$ 慢慢走到 $(3,1,3,1)$，再慢慢走到 $(5,5,5,5)$，获得 $16$ 的价值。最好的路径只有这 $1$ 条。

![Luogu](https://cdn.luogu.com.cn/upload/pic/26057.png)

对于所有数据，$1\le a_i,b_i,c_i,d_i\le m$，$1\le v_i\le 10^9$。

## 样例 #1

### 输入

```
5 5
1 1 1 1 5
2 2 2 2 4
1 1 2 2 3
3 1 3 1 10
5 5 5 5 1```

### 输出

```
16
1```

## 样例 #2

### 输入

```
20 1000000000
20204201 39958379 15138434 34289618 398078390
85600475 39563639 66410111 36702766 611878653
36702694 1628762 125746709 79172847 611878653
103077330 79188107 6711555 56295346 611878653
212677316 202221253 26717633 234187985 158044893
297040787 198938585 43827694 296390944 158044893
109256220 180224853 267561686 65767679 472347047
167183048 72650618 4390517 30073538 471045792
214834767 93996707 94416376 34549122 359059039
89445418 135311221 266840392 213735818 398078390
343357648 61588748 188180842 396968607 144378900
285457193 157755350 336368020 572049737 472347047
171728638 398663231 323772972 359470762 611878653
234684711 226541116 270561472 376433946 229386389
293174669 58119648 352134416 262971247 144378900
182250938 623413311 303663331 506122949 611878653
817319765 321076346 200801449 745136845 698518241
26356940 295529493 725103952 845588002 533478406
510252473 498314898 168621119 519205227 472347047
947274653 288133984 692904616 340022215 611878653
```

### 输出

```
1696104353
6```

# 题解

## 作者：huyufeifei (赞：10)

这是比赛题，附上[链接](https://www.luogu.org/contestnew/show/9354)，里面有官方题解。  

------------

CDQ套CDQ裸题...  
不会CDQ分治的请去陌上花开。

然后关于CDQ套CDQ，我觉得[stdcall的博客](https://www.cnblogs.com/mlystdcall/p/6232324.html)写的不错。

大概就是，在第一层CDQ分治的时候，对于左边和右边进行标记，然后不进行任何操作，按照第二维排序后进入第二层CDQ分治。  
在第二层里面也对左右进行标记，然后按照第三维排序，树状数组更新DP值即可。

这里要说一个CDQ分治刚学时极易写错的点：**排序一定要彻底！**  
按照第二维排序的时候，如果二，三，四维都相同，那么要按照第一维排序。同理，按照第三维排序的时候，如果三，四维都相同，就要再按照一，二维来排序。  
不这样做就会以奇怪的姿势挂掉...  
比如我有两个四元组：  
```text
2 2 2 3
1 2 2 3
```
显然第二个是可以更新第一个的，但是如果你在按照第三维排序的时候不小心把第二个放在后面(c++ sort是不稳定的)，就凉了。

然后要记得随时取模，就没啥问题了。

CDQ分治嵌套其实可以只用一个函数完成，参考标程的实现。

~~为什么我写的比标程慢2倍啊......~~  
上代码：
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

typedef long long LL;
const int N = 80010;
const LL MO = 998244353;

struct Node {
    int a, b, c, d, id;
    bool A, B; 　
    LL val, cnt, f;
    inline bool operator <(const Node &w) const {
        if(a != w.a) {
            return a < w.a;
        }
        if(b != w.b) {
            return b < w.b;
        }
        if(c != w.c) {
            return c < w.c;
        }
        return d < w.d;　
    }
    inline bool operator ==(const Node &w) const {
        return a == w.a && b == w.b && c == w.c && d == w.d;
    }
}node[N], t1[N], t2[N];

int n, X[N];
　
namespace ta {
    LL cnt[N], f[N];
    inline void add(int x, LL v, LL sum) {
        for(; x <= n; x += x & (-x)) {
            if(v > f[x]) {
                f[x] = v;
                cnt[x] = sum;
            }
            else if(v == f[x]) {
                cnt[x] += sum;
                cnt[x] %= MO;
            }
        }
        return;
    }　
    inline void ask(int x, LL &ff, LL &sum, LL val) {
        for(; x > 0; x -= x & (-x)) {
            if(f[x] + val > ff) {
                ff = f[x] + val;
                sum = cnt[x];
            }
            else if(f[x] + val == ff) {
                sum += cnt[x];
                sum %= MO;
            }
        }
        return;
    }
    inline void del(int x) {　
        for(; x <= n; x += x & (-x)) {
            cnt[x] = f[x] = 0;
        }
        return;
    }
}

inline bool cmp_c(const Node &x, const Node &y) {
    if(x.c != y.c) {
        return x.c < y.c;
    }
    if(x.d != y.d) {　
        return x.d < y.d;
    }
    if(x.a != y.a) {
        return x.a < y.a;
    }
    return x.b < y.b;
}

inline bool cmp_b(const Node &x, const Node &y) {
    if(x.b != y.b) {
        return x.b < y.b;
    }
    if(x.c != y.c) {
        return x.c < y.c;
    }　
    if(x.d != y.d) {
        return x.d < y.d;
    }
    return x.a < y.a;
}

void CDQ_2(int l, int r) {
    if(l == r) {
        return;
    }
    int mid = (l + r) >> 1;
    CDQ_2(l, mid);

    for(int i = l; i <= r; i++) {
        t1[i].B = (i > mid);
        t2[i] = t1[i];
        t2[i].id = i;
    }　
    std::sort(t2 + l, t2 + r + 1, cmp_c);

    for(int i = l; i <= r; i++) {
        if(t2[i].A && t2[i].B) {
            ta::ask(t2[i].d, t2[i].f, t2[i].cnt, t2[i].val);
            t1[t2[i].id].f = t2[i].f;
            t1[t2[i].id].cnt = t2[i].cnt;
        }
        if(!t2[i].A && !t2[i].B) {
            ta::add(t2[i].d, t2[i].f, t2[i].cnt);
        }
    }　

    for(int i = l; i <= mid; i++) {
        if(!t1[i].A) {
            ta::del(t1[i].d);
        }
    }
    CDQ_2(mid + 1, r);
    return;
}

void CDQ_1(int l, int r) {
    if(l == r) {
        return;
    }
　
    int mid = (l + r) >> 1;
    CDQ_1(l, mid);

    for(int i = l; i <= r; i++) {
        node[i].A = (i > mid);
        t1[i] = node[i];
        t1[i].id = i;
    }
    std::sort(t1 + l, t1 + r + 1, cmp_b);
    CDQ_2(l, r);
    for(int i = l; i <= r; i++) {
        node[t1[i].id].f = t1[i].f;　
        node[t1[i].id].cnt = t1[i].cnt;
    }

    CDQ_1(mid + 1, r);
    return;
}

int main() {

    int m;
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++) {
        scanf("%d%d%d%d%lld", &node[i].a, &node[i].b, &node[i].c, &node[i].d, &node[i].val);
    }
    std::sort(node + 1, node + n + 1);　
    int temp = 1;
    for(int i = 2; i <= n; i++) { /// unique
        if(node[i] == node[temp]) {
            node[temp].val += node[i].val;
        }
        else {
            node[++temp] = node[i];
        }
    }
    n = temp;

    for(int i = 1; i <= n; i++) {
        X[i] = node[i].a;
    }
    std::sort(X + 1, X + n + 1);
    temp = std::unique(X + 1, X + n + 1) - X - 1;
    for(int i = 1; i <= n; i++) {　
        node[i].a = std::lower_bound(X + 1, X + temp + 1, node[i].a) - X;
    }

    for(int i = 1; i <= n; i++) {
        X[i] = node[i].b;
    }
    std::sort(X + 1, X + n + 1);
    temp = std::unique(X + 1, X + n + 1) - X - 1;
    for(int i = 1; i <= n; i++) {
        node[i].b = std::lower_bound(X + 1, X + temp + 1, node[i].b) - X;
    }

    for(int i = 1; i <= n; i++) {
        X[i] = node[i].c;
    }　
    std::sort(X + 1, X + n + 1);
    temp = std::unique(X + 1, X + n + 1) - X - 1;
    for(int i = 1; i <= n; i++) {
        node[i].c = std::lower_bound(X + 1, X + temp + 1, node[i].c) - X;
    }

    for(int i = 1; i <= n; i++) {
        X[i] = node[i].d;
    }
    std::sort(X + 1, X + n + 1);
    temp = std::unique(X + 1, X + n + 1) - X - 1;
    for(int i = 1; i <= n; i++) {　
        node[i].d = std::lower_bound(X + 1, X + temp + 1, node[i].d) - X;
    }

    for(int i = 1; i <= n; i++) {
        node[i].f = node[i].val;
        node[i].cnt = 1;
        node[i].id = i;
    }

    // prework OVER

    CDQ_1(1, n);　

    LL sum = 0, ans = 0;
    for(int i = 1; i <= n; i++) {
        if(node[i].f > ans) {
            ans = node[i].f;
            sum = node[i].cnt;
        }
        else if(node[i].f == ans) {
            sum += node[i].cnt;
            sum %= MO;
        }
    }
    
    printf("%lld\n%lld\n", ans, sum);　

    return 0;
}
```

---

## 作者：command_block (赞：8)

昨天我还在做三维偏序……

```cpp
三维偏序题解区:

其实cdq分治可以一直嵌套下去，不一定需要数据结构维护。

还有大家写cdq的时候，要写归并排序，并先分治左右，再中间。
假如题目不允许（比如优化一些dp之类的，强制左中右的），
可以预处理每层归并的结果，来保证复杂度少一个log。

                                         ——Shadows巨佬
```

我就膜拜dalao代码然后学习了CDQ分治(~~同学们好像初一就会了~~)。

P.S:如果阅读的dalao不了解CDQ嵌套的话,建议食用Shadows的题解来入门。

然后我看到了这道题,看一眼体面:`WC?这不就是个裸的4维偏序么?`

码码码完了之后WA了一晚上,才发现事情没有那么简单……

这道题就是Shadows口中的`cdq优化dp`的题目,强制左中右转移。

所以我们要预处理排序结果,不然直接sort复杂度要多一个log。

值得注意的是如果最后一位采用树状数组的话,前两维直接sort不会增加复杂度,所以写起来十分方便,缺点就是要离散化。

要把同一个位置的宝物价值相加,视作一个,可以减少很多细节。

而且高维cdq要注意:我们可以视作在每一维里面插入了一个板子,只有都在三个板子左侧的东西,能向都在三个板子右侧的东西贡献(取交集,这里采用了位运算优化)

不过直接保存结果空间复杂度$O(nlogn)$因为巨大至15的常数MLE了,只好保存指针,代价就是代码基本不能看了。

CDQ空间居然比树状数组高?咕咕咕……

跑的比出题人稍微快了一点,这一大堆数组copy应该还有优化的空间吧。


```cpp
#include<algorithm>
#include<cstdio>
#include<map>
#define mod 998244353
#define MaxN 80500
using namespace std;
inline int read()
{
  register int X=0;
  register char ch=0;
  while(ch<48||ch>57)ch=getchar();
  while(ch>=48&&ch<=57)X=X*10+(ch^48),ch=getchar();
  return X;
}
int n,k;
struct Data
{
  int a,b,c,d,fl;
  long long x,*v,*sum;
  bool operator < (const Data B) const
  {return a<B.a||(a==B.a&&b<B.b)||(a==B.a&&b==B.b&&c<B.c)
          ||(a==B.a&&b==B.b&&c==B.c&&d<B.d);}
  bool operator == (const Data B) const
  {return a==B.a&&b==B.b&&c==B.c&&d==B.d;}
}a1[MaxN],*s1[18][MaxN],
 a2[MaxN],*s2[18][MaxN],
 a3[MaxN],*s3[18][MaxN],
 a4[MaxN],sav[MaxN];
int sf1[18][MaxN],sf2[18][MaxN],sf3[18][MaxN];
int tn;
long long v[MaxN],sum[MaxN];
void sort3(int l,int r,int lev)
{
  if (l==r)return ;
  int mid=(l+r)>>1;
  int pl=l,pr=mid+1;
  sort3(l,mid,lev+1);
  sort3(mid+1,r,lev+1);
  for (int i=l;i<=r;i++)
    if (pl<=mid&&(pr>r||a3[pl].d<=a3[pr].d))
      {a4[i]=a3[pl++];a4[i].fl&=6;}
    else {a4[i]=a3[pr++];a4[i].fl|=1;}
  for (int i=l;i<=r;i++){
    a3[i]=a4[i];
    s3[lev][i]=sav+(a3[i].v-v);
    sf3[lev][i]=a3[i].fl;
  }
}
void cdq3(int l,int r,int lev)
{
  if (l==r)return ;
  int mid=(l+r)>>1;
  cdq3(l,mid,lev+1);
  long long maxx=0,sum=0;
  for (int i=l;i<=r;i++){
    a4[i]=*s3[lev][i];
    a4[i].fl=sf3[lev][i];
  }
  for (int i=l;i<=r;i++){
    if (a4[i].fl==0){
      if (maxx<*a4[i].v+a4[i].x){
        maxx=*a4[i].v+a4[i].x;
        sum=*a4[i].sum;
      }else if (maxx==*a4[i].v+a4[i].x)
        sum=(sum+*a4[i].sum)%mod;
    }if (a4[i].fl==7){
      if (maxx>*a4[i].v){
        *a4[i].v=maxx;
        *a4[i].sum=sum;
      }else if (maxx==*a4[i].v)
        *a4[i].sum=(*a4[i].sum+sum)%mod;
    }
  }cdq3(mid+1,r,lev+1);
}
void sort2(int l,int r,int lev)
{
  if (l==r)return ;
  int mid=(l+r)>>1;
  int pl=l,pr=mid+1;
  sort2(l,mid,lev+1);
  sort2(mid+1,r,lev+1);
  for (int i=l;i<=r;i++)
    if (pl<=mid&&(pr>r||a2[pl].c<=a2[pr].c))
      {a3[i]=a2[pl++];a3[i].fl&=5;}
    else {a3[i]=a2[pr++];a3[i].fl|=2;}
  for (int i=l;i<=r;i++){
    a2[i]=a3[i];
    s2[lev][i]=sav+(a2[i].v-v);
    sf2[lev][i]=a2[i].fl;
  }
}
void cdq2(int l,int r,int lev)
{
  if (l==r)return ;
  int mid=(l+r)>>1;
  cdq2(l,mid,lev+1);
  for (int i=l;i<=r;i++){
    a3[i]=*s2[lev][i];
    a3[i].fl=sf2[lev][i];
  }
  sort3(l,r,lev);
  cdq3(l,r,lev);
  cdq2(mid+1,r,lev+1);
}
void sort1(int l,int r,int lev)
{
  if (l==r)return ;
  int mid=(l+r)>>1;
  int pl=l,pr=mid+1;
  sort1(l,mid,lev+1);
  sort1(mid+1,r,lev+1);
  for (int i=l;i<=r;i++)
    if (pl<=mid&&(pr>r||a1[pl].b<=a1[pr].b))
      {a2[i]=a1[pl++];a2[i].fl&=3;}
    else {a2[i]=a1[pr++];a2[i].fl|=4;}
  for (int i=l;i<=r;i++){
    a1[i]=a2[i];
    s1[lev][i]=sav+(a1[i].v-v);
    sf1[lev][i]=a1[i].fl;
  }
}
void cdq1(int l,int r,int lev)
{
  if (l==r)return ;
  int mid=(l+r)>>1;
  cdq1(l,mid,lev+1);
  for (int i=l;i<=r;i++){
    a2[i]=*s1[lev][i];
    a2[i].fl=sf1[lev][i];
  }
  sort2(l,r,lev);
  cdq2(l,r,lev);
  cdq1(mid+1,r,lev+1);
}
int main()
{
  n=read();k=read();
  for (int i=1;i<=n;i++){
    a1[i].a=read();a1[i].b=read();
    a1[i].c=read();a1[i].d=read();
    a1[i].x=read();
  }a1[tn=n+1]=(Data){k+1,k+1,k+1,k+1};
  sort(a1+1,a1+tn+1);
  tn=1;
  for (int i=2,pos=1;i<=n+1;i++)
    if (a1[i]==a1[pos])
      a1[pos].x+=a1[i].x;
    else a1[pos=++tn]=a1[i];
  for (int i=1;i<=tn;i++){
    a1[i].sum=sum+i;
    *a1[i].sum=1;
    a1[i].v=v+i;
    sav[i]=a1[i];
  }
  sort1(1,tn,0);
  cdq1(1,tn,0);
  printf("%lld\n%lld",*a1[tn].v+a1[tn].x,*a1[tn].sum);
  return 0;
}
```

---

## 作者：fzj2007 (赞：5)

首先对题目进行一些转化。

容易发现，我们实际上时要求出最大价值的四维上升序列。

看到偏序问题想到 cdq 分治。首先想到三维偏序问题我们可以使用排序使第一维有序，通过一次 cdq 分治使第二维有序，使用树状数组维护第三维。

现在多出了一维，可以使用 cdq 分治嵌套来解决。

具体的，首先将第一维排序，然后使用 cdq 分治维护第二维，将位置属于 $l\sim mid$ 的点打上标记 $0$ 并将位置属于 $mid+1\sim r$ 的点打上表示 $1$。

然后再使用一个 cdq 分治维护第 $3$ 维，这一维像三维偏序的第二维一样维护即可，但是要注意向树状数组插入数时需要检查这个数第二维是否在 $l\sim mid$，即标记是否为 $0$，查询时检查这个数第二维是否在 $mid+1\sim r$，即表示是否为 $1$，来确保转移正确。

第四维直接使用树状数组维护即可。

下面回到本题，本题本质是 cdq 分治维护动态规划。所以这里**需要考虑转移顺序**。

普通的 cdq 分治中，我们先递归左右两个子问题求解，而后再维护跨过左右的贡献。但是在动态规划中，如果我们不维护左边对右侧的贡献而直接维护右侧内部的贡献，会导致贡献不完全，从而使答案错误。

我们应时刻**保证左侧已经贡献完右侧**。可以采用先递归左子树，然后维护跨过左右的贡献，最后递归右子树的顺序来实现。

本题还需要维护一个方案数，可以在树状数组中维护当前最大值以及方案树，并在查询时贡献即可。

另外本题值域较大，需要对树状数组维护的一维，即第四位**离散化**。

时间复杂度 $\mathcal{O}(n \log^2 n)$。

```
#include<bits/stdc++.h>
using namespace std;
namespace IO{
	template<typename T>inline bool read(T &x){
		x=0;
		char ch=getchar();
		bool flag=0,ret=0;
		while(ch<'0'||ch>'9') flag=flag||(ch=='-'),ch=getchar();
		while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar(),ret=1;
		x=flag?-x:x;
        return ret;
	}
	template<typename T,typename ...Args>inline bool read(T& a,Args& ...args){
	    return read(a)&&read(args...);
	}
	template<typename T>void prt(T x){
		if(x>9) prt(x/10);
		putchar(x%10+'0');
	}
	template<typename T>inline void put(T x){
		if(x<0) putchar('-'),x=-x;
		prt(x);
	}
	template<typename T>inline void put(char ch,T x){
		if(x<0) putchar('-'),x=-x;
		prt(x);
		putchar(ch);
	}
	template<typename T,typename ...Args>inline void put(T a,Args ...args){
	    put(a);
		put(args...);
	}
	template<typename T,typename ...Args>inline void put(const char ch,T a,Args ...args){
	    put(ch,a);
		put(ch,args...);
	}
	inline void putstr(string s){
		for(int i=0,sz=s.length();i<sz;i++) putchar(s[i]);
	}
}
using namespace IO;
#define N 80005
#define mod 998244353
int n,m,cnt;
long long maxn[N],ans,res;
int tim[N];
struct node{
	int a,b,c,d,id,op;
	long long v;
	inline bool operator==(const node &y)const{
		return a==y.a&&b==y.b&&c==y.c&&d==y.d;
	}
}t[N],w[N];
inline bool cmp1(const node &x,const node &y){
	return x.a==y.a?(x.b==y.b?(x.c==y.c?x.d<y.d:x.c<y.c):x.b<y.b):x.a<y.a;
}//排序必须完全
inline bool cmp2(const node &x,const node &y){
	return x.b==y.b?(x.a==y.a?(x.c==y.c?x.d<y.d:x.c<y.c):x.a<y.a):x.b<y.b;
}//排序必须完全
inline bool cmp3(const node &x,const node &y){
	return x.c==y.c?(x.a==y.a?(x.b==y.b?x.d<y.d:x.b<y.b):x.a<y.a):x.c<y.c;
}//排序必须完全
inline int add(int x,int y){//需要取模
	return x+y>=mod?x+y-mod:x+y;
}
namespace BIT{
	#define lowbit(x) (x&-x)
	long long c[N];//同时维护最大值和达到最大值的方案
	int num[N];
	inline void update(int x,long long v,int t){
		for(;x<=m;x+=lowbit(x)){
			if(v>c[x]) c[x]=v,num[x]=t;
			else if(c[x]==v) num[x]=add(num[x],t);
		}
	}
	inline void query(int x,long long &Max,int &s,long long val){
		for(;x;x^=lowbit(x)){
			if(val+c[x]>Max) Max=val+c[x],s=num[x];
			else if(val+c[x]==Max) s=add(s,num[x]);
		}
	}
	inline void erase(int x){
		for(;x<=n;x+=lowbit(x)) num[x]=c[x]=0;
	}
	#undef lowbit
}
using BIT::update;
using BIT::query;
using BIT::erase;
void mergesort(int l,int r){//维护第三维的cdq分治
	if(l==r) return;
	int mid=l+r>>1;
	mergesort(l,mid);//按照正确的顺序
	sort(w+l,w+mid+1,cmp3),sort(w+mid+1,w+r+1,cmp3);//由于上面顺序的原因，右侧不一定有序，所以不能使用归并
	int i=l,j=mid+1,k=l;
	while(i<=mid&&j<=r)//左右贡献
		if(w[i].c<=w[j].c){
			if(!w[i].op) update(w[i].d,maxn[w[i].id],tim[w[i].id]);
			i++;
		}else{
			if(w[j].op) query(w[j].d,maxn[w[j].id],tim[w[j].id],w[j].v);
			j++;
		}
	while(i<=mid){
		if(!w[i].op) update(w[i].d,maxn[w[i].id],tim[w[i].id]);
		i++;
	}
	while(j<=r){
		if(w[j].op) query(w[j].d,maxn[w[j].id],tim[w[j].id],w[j].v);
		j++;
	}
	for(i=l;i<=mid;i++) erase(w[i].d);
	sort(w+l,w+r+1,cmp2);
	mergesort(mid+1,r);//最后处理右侧
}
inline void merge_sort(int l,int r){
	if(l==r) return;
	int mid=l+r>>1;
	merge_sort(l,mid);
	for(int i=l;i<=r;i++) w[i]=t[i],w[i].op=(i>mid);//对第二维打标记。为防止排序造成顺序影响，使用w数组进入下一维
	sort(w+l,w+r+1,cmp2);
	mergesort(l,r);
	merge_sort(mid+1,r);	//递归右侧
}
int p[N];
int main(){
	read(n,m),m=1;
	for(int i=1;i<=n;i++) read(t[i].a),read(t[i].b),read(t[i].c),read(t[i].d),read(t[i].v),p[i]=t[i].d;
	sort(p+1,p+n+1);
	cnt=unique(p+1,p+n+1)-p-1;
	for(int i=1;i<=n;i++) t[i].d=lower_bound(p+1,p+cnt+1,t[i].d)-p;//离散化
	for(int i=2;i<=n;i++)//去重
		if(t[i]==t[m]) t[m].v+=t[i].v;
		else t[++m]=t[i];
	swap(n,m);
	sort(t+1,t+n+1,cmp1);
	for(int i=1;i<=n;i++) maxn[i]=t[i].v,tim[i]=1,t[i].id=i;
	merge_sort(1,n);
	for(int i=1;i<=n;i++) 
		if(maxn[i]>ans) ans=maxn[i],res=tim[i];
		else if(maxn[i]==ans) res=add(res,tim[i]);//统计答案
	put('\n',ans,res);
	return 0;
}

```

---

## 作者：绝顶我为峰 (赞：5)

## Problem

四维空间，每次可以在每个维度向正半轴移动一个单位，可以获得途经的所有点的贡献。求从 $(1,1,1,1)$ 到 $(m,m,m,m)$ 的所有路径中的最大贡献，并求出方案数。

## Solution

首先有一个非常 naive 的 dp 做法，对于每个可以转移的点对连一条有向边，最后在 DAG 上 dp。

这种做法是 $O(n^2)$ 的，显然无法通过。

考虑优化这个 dp，我们注意到一个点对另一个点可以产生贡献，当且仅当二者满足偏序关系。

这是一个裸的四维偏序，用 CDQ 优化 dp 即可。

~~众所周知~~高维偏序每套一层 CDQ 就可以用一个 log 的复杂度降掉一维，于是我们有了一个 CDQ 套 CDQ 的做法，复杂度 $O(nlog^3n)$，可以通过本题。

默认大家已经会了 CDQ。三维偏序大家都会，这里讲一下怎样实现四维偏序（这个做法也适用于更高维的偏序）。

我们考虑一个序列，第一维有序，那么对于一个区间 $[l,r]$，考虑计算 $[l,mid]$ 对 $[mid+1,r]$ 的贡献。

由于第一维有序，$[l,mid]$ 第一维一定小于 $[mid+1,r]$ 第一维，那么我们直接给两段序列打上标记（我把左半段标记为 1，右半段标记为 0），删去这一维即可。

接下来就是普通的三维偏序了，唯一的区别在于扫描区间时只有左指针指向标记是 1 的点时才加入数据结构，右指针指向标记是 0 的点时才计算贡献。

数据结构需要维护最大值和对应的方案数，类似[[SDOI2011]拦截导弹](https://www.luogu.com.cn/problem/P2487)，最后统计所有答案等于最大值的点的方案数只和即可。

注意一个点可能有多个贡献，要先去重。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const long long mod=998244353;
long long n,m,p[80001],cnt,ans[80001],val[80001],sum,tot;
pair<long long,long long> dp[80001];
struct element
{
    long long x,y,z,w,id,val,cnt;
    bool tag;
    bool operator ==(const element &other) const
    {
        return x==other.x&&y==other.y&&z==other.z&&w==other.w;
    }
}a[80001],b[80001],c[80001];
inline bool cmp1(element x,element y)
{
    return x.x^y.x? x.x<y.x:x.y^y.y? x.y<y.y:x.z^y.z? x.z<y.z:x.w<y.w;
}
inline bool cmp2(element x,element y)
{
    return x.y^y.y? x.y<y.y:x.z^y.z? x.z<y.z:x.w^y.w? x.w<y.w:x.x<y.x;
}
inline bool cmp3(element x,element y)
{
    return x.z^y.z? x.z<y.z:x.w^y.w? x.w<y.w:x.x^y.x? x.x<y.x:x.y<y.y;
}
inline long long read()
{
    long long x=0;
    char c=getchar();
    while(c<'0'||c>'9')
        c=getchar();
    while(c>='0'&&c<='9')
    {
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x;
}
inline int lowbit(int x)
{
    return x&-x;
}
inline void update(int k,long long p,long long v)
{
    v%=mod;
    for(;k<=cnt;k+=lowbit(k))
    {
        if(ans[k]==p)
            val[k]=(val[k]+v)%mod;
        if(p>ans[k])
        {
            ans[k]=p;
            val[k]=v;
        }
    }
}
inline pair<long long,long long> query(int k)
{
    pair<long long,long long> res=make_pair(0,0);
    for(;k;k-=lowbit(k))
    {
        if(ans[k]==res.first)
            res.second=(res.second+val[k])%mod;
        if(ans[k]>res.first)
        {
            res.first=ans[k];
            res.second=val[k];
        }
    }
    return res;
}
inline void clear(int k)
{
    for(;k<=cnt;k+=lowbit(k))
        ans[k]=val[k]=0;
}
void cdq2(int l,int r)
{
    if(l==r)
        return;
    int mid=(l+r)>>1;
    cdq2(l,mid);
    for(register int i=l;i<=r;++i)
        c[i]=b[i];
    sort(c+l,c+mid+1,cmp3);
    sort(c+mid+1,c+r+1,cmp3);
    int i=l,j=mid+1;
    while(j<=r)
    {
        if(c[j].tag)
        {
            ++j;
            continue;
        }
        while(i<=mid&&c[i].z<=c[j].z)
        {
            if(c[i].tag)
                update(c[i].w,dp[c[i].id].first,dp[c[i].id].second);
            ++i;
        }
        pair<long long,long long> tmp=query(c[j].w);
        tmp.first+=c[j].val;
        if(tmp.first==dp[c[j].id].first)
            dp[c[j].id].second=(dp[c[j].id].second+tmp.second)%mod;
        if(tmp.first>dp[c[j].id].first)
            dp[c[j].id]=tmp;
        sum=max(sum,dp[c[j].id].first);
        ++j;
    }
    for(register int t=l;t<i;++t)
        if(c[t].tag)
            clear(c[t].w);
    cdq2(mid+1,r);
}
void cdq1(int l,int r)
{
    if(l==r)
        return;
    int mid=(l+r)>>1;
    cdq1(l,mid);
    for(register int i=l;i<=r;++i)
        b[i]=a[i];
    for(register int i=l;i<=mid;++i)
        b[i].tag=1;
    sort(b+l,b+r+1,cmp2);
    cdq2(l,r);
    cdq1(mid+1,r);
}
int main()
{
    n=read(),m=read();
    for(register int i=1;i<=n;++i)
    {
        a[i].x=read(),a[i].y=read(),a[i].z=read(),a[i].w=read(),a[i].val=read();
        p[i]=a[i].w;
    }
    sort(p+1,p+n+1);
    cnt=unique(p+1,p+n+1)-p-1;
    for(register int i=1;i<=n;++i)
        a[i].w=lower_bound(p+1,p+cnt+1,a[i].w)-p;
    sort(a+1,a+n+1,cmp1);
    tot=1;
    for(register int i=2;i<=n;++i)
        if(a[i]==a[tot])
            a[tot].val+=a[i].val;
        else
            a[++tot]=a[i];
    n=tot;
    tot=0;
    for(register int i=1;i<=n;++i)
    {
        a[i].id=i;
        dp[i].first=a[i].val;
        dp[i].second=1;
    }
    cdq1(1,n);
    printf("%lld\n",sum);
    for(register int i=1;i<=n;++i)
        if(dp[i].first==sum)
            tot=(tot+dp[i].second)%mod;
    printf("%lld\n",tot);
    return 0;
}
```


---

## 作者：Marser (赞：5)

### 题意
给出 $n$ 个四维空间上的点，每个点有点权，求最大权不降子点列的权值和方案数。  
$n \le 80000$
### 题解
可以看出这是个裸的四维偏序优化 dp，按照套路，我们可以用 cdq 套 cdq 解决。  
但是我是个菜鸡，连普通cdq都写不清楚，套在一起就更不会写了。而且，这样做的时间复杂度是 $O(n\log^3n)$ ，常数还很大，我们可以想想更暴力的做法。

考虑在 $k$ 维空间上建立 k-d tree，这样的话，插入节点复杂度为 $O(\log n)$，$k$ 维超立方体查询复杂度为 $O(n^{\frac{k-1}{k}})$。  
但是，如果直接建立 $4$ 维 k-d tree，算上常数，复杂度也没有比暴力优秀到哪里去。我们考虑先对所有点按第一维排序，利用后 $3$ 维建立 $3$ 维 k-d tree，这样，我们就把询问的复杂度降低到了 $O(n^{\frac{2}{3}})$。  
考虑插入时以类似替罪羊树的方法，对不平衡节点拍扁重构，我们就能维持树形态的基本平衡，从而保证了总复杂度为 $O(n^{\frac{5}{3}})$。

这种方法的实际运行速度相当快，目前排在所有提交的第 $2$ 名。
### 代码
```cpp
#include<bits/stdc++.h>
#define reg register
typedef long long ll;
using namespace std;
const int mod=998244353;
const int MN=80005;
const double alpha=.75;
struct point{int x[3],cnt;ll f;}b[MN];
int sgn,n,root;
inline bool operator<(point a,point b){return a.x[sgn]<b.x[sgn];}
struct data{
	int mx[3],mn[3],ls,rs,siz,cnt;
	ll val;point p;
}tr[MN];
int tot,dtop,dust[MN];
inline int newnode(){return dtop?dust[dtop--]:++tot;}
inline void pushup(int t){
	reg int l=tr[t].ls,r=tr[t].rs;
	tr[t].siz=tr[l].siz+tr[r].siz+1;
	tr[t].val=max(tr[t].p.f,max(tr[l].val,tr[r].val));
	tr[t].cnt=0;
	if(tr[t].val==tr[l].val)tr[t].cnt+=tr[l].cnt;
	if(tr[t].val==tr[r].val)tr[t].cnt+=tr[r].cnt;
	tr[t].cnt%=mod;
	if(tr[t].val==tr[t].p.f)tr[t].cnt+=tr[t].p.cnt;
	tr[t].cnt%=mod;
	for(reg int i=0;i<3;i++){
		tr[t].mx[i]=tr[t].mn[i]=tr[t].p.x[i];
		if(l){
			tr[t].mx[i]=max(tr[t].mx[i],tr[l].mx[i]);
			tr[t].mn[i]=min(tr[t].mn[i],tr[l].mn[i]);
		}
		if(r){
			tr[t].mx[i]=max(tr[t].mx[i],tr[r].mx[i]);
			tr[t].mn[i]=min(tr[t].mn[i],tr[r].mn[i]);
		}
	}
}
inline bool check(int t){
	return max(tr[tr[t].ls].siz,tr[tr[t].rs].siz)>tr[t].siz*alpha;
}
int Top,N;
void pia(int t){
	if(tr[t].ls)pia(tr[t].ls);
	b[++N]=tr[t].p;dust[++dtop]=t;
	if(tr[t].rs)pia(tr[t].rs);
}
#define mid (l+r>>1)
int rebuild(int l,int r,int f){
	if(l>r)return 0;
	reg int t=newnode();sgn=f;
	nth_element(b+l,b+mid,b+r+1);
	tr[t].p=b[mid];
	tr[t].ls=rebuild(l,mid-1,(f+1)%3);
	tr[t].rs=rebuild(mid+1,r,(f+1)%3);
	pushup(t);return t;
}
void insert(int& t,point v,int f){
	if(!t){
		t=newnode();
		for(reg int i=0;i<3;i++)
			tr[t].mx[i]=tr[t].mn[i]=v.x[i];
		tr[t].val=v.f;tr[t].cnt=v.cnt;tr[t].ls=tr[t].rs=0;
		tr[t].siz=1;tr[t].p=v;return;
	}
	if(v.x[f]<=tr[t].p.x[f])insert(tr[t].ls,v,(f+1)%3);
	else insert(tr[t].rs,v,(f+1)%3);
	pushup(t);
	if(!check(t)){
		if(Top){
			N=0;pia(Top);
			if(Top==tr[t].ls)tr[t].ls=rebuild(1,N,(f+1)%3);
			else tr[t].rs=rebuild(1,N,(f+1)%3);
			Top=0;
		}
	}
	else Top=t;
}
int Res;
ll Ans;
inline bool hstar(point a,point b){
	for(reg int i=0;i<3;i++)
		if(a.x[i]<b.x[i])return 0;
	return 1;
}
void query(int t,point v){
	if(!t||Ans>tr[t].val)return;
	if(v.x[0]<tr[t].mn[0]||v.x[1]<tr[t].mn[1]||v.x[2]<tr[t].mn[2])return;
	if(hstar(v,(point){tr[t].mx[0],tr[t].mx[1],tr[t].mx[2]})){
		if(Ans<tr[t].val)Ans=tr[t].val,Res=tr[t].cnt;
		else if(Ans==tr[t].val)Res=(Res+tr[t].cnt)%mod;
		return;
	}
	if(hstar(v,tr[t].p)){
		if(Ans<tr[t].p.f)Ans=tr[t].p.f,Res=tr[t].p.cnt;
		else if(Ans==tr[t].p.f)Res=(Res+tr[t].p.cnt)%mod;
	}
	query(tr[t].ls,v);
	query(tr[t].rs,v);
}
int X[MN][4],Val[MN],id[MN];
int main(){
	scanf("%d%*d",&n);
	for(reg int i=1,pos;i<=n;i++)
		scanf("%d%d%d%d%lld",&X[i][0],&X[i][1],&X[i][2],&X[i][3],&Val[i]),id[i]=i;
	sort(id+1,id+1+n,[](int x,int y){
		for(reg int i=0;i<4;i++)
			if(X[x][i]!=X[y][i])return X[x][i]<X[y][i];
		return false;
	});
	reg ll ans=0;reg int cans=1;
	for(reg int t=1,i=id[1];t<=n;i=id[++t]){
		reg point p=(point){X[i][1],X[i][2],X[i][3],0,0};
		Ans=0;Res=1;query(root,p);
		p.f=Ans+Val[i];p.cnt=Res;
		Top=0;insert(root,p,0);
		if(Top)N=0,pia(root),root=rebuild(1,N,0);
		if(ans<p.f)ans=p.f,cans=p.cnt;
		else if(ans==p.f)cans=(cans+p.cnt)%mod;
	}
	printf("%lld\n%d\n",ans,cans);
	return 0;
}
```

---

## 作者：_Wind_Leaves_ShaDow_ (赞：3)

经过了一个下午的辛酸使这题成为蒟蒻第一篇不看题解 A 掉的黑。但是感觉有可能会掉，什么时候掉紫了踢我一下。

[前情回顾](https://www.luogu.com.cn/problem/P5621)，双倍经验，没做过可以顺便 A 了。

在上面的题目中我们成功解决了四维偏序求最大值的问题，那么这道题仅仅只是在上面的题上新增了一个计数。

显然此时我们需要开两个数组，$f_i$ 存储最大值，$g_i$ 计数。

同时在其他佬的代码基础上我们会有一些简单的码量优化。

判重、离散这些不说了。

---

首先我们看增加计数后我们会有哪些东西需要改变。

第一个想到的应该是 dp 数组的更新。

- 对于 $i$，如果 $f_j+v_i>f_i$，那么不需要管 $g$，直接用 $j$ 更新 $i$；

- 如果 $f_j+v_i=f_i$，那么代表我们既可以从之前的那条路到 $i$，也可以从新路 $j$ 转到 $i$。所以我们的计数数组 $g_i\leftarrow g_i+g_j$。

然后就能想到答案也是这么更新的，因为你最后经过的一个点也不确定。

比较难想到（或者只是对我而言？）的是树状数组的更新和求值也要这么更新。具体地原因应该很容易想到，留给读者思考。

我们发现上面的东西更改是类似甚至一样的，所以我们可以定义一个函数来降低我们的码量，并配合我们可爱的 STL `pair` 来简洁码风。

---

闲话：调到最后发现是离散化写挂了。

```cpp
#include <bits/stdc++.h>
#define int long long
#define lowbit(x) ((x)&(-x))
#define fi first
#define se second

using namespace std;
typedef pair<int,int> pii;//把两个 dp 数组合成 pair 类型，第一位是最大值，第二位是计数
const int N=8e4,mod=998244353;

inline int read(){
	int x=0,f=1;char ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
	for(;ch>='0'&&ch<='9';ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
	return x*f;
}

inline void write(int x){
	if(x<0){putchar('-');x=-x;}
	if(x>9)write(x/10);
	putchar(x%10+'0');
	return;
}

int cdqn,n=0,tMp,lsh[N+5],m=0;
pii dp[N+5],gs[N+5],ans={0,0};//最大值，计数 
struct Node{
	int a,b,c,d,v,id;
	bool lf;
}a[N+5],b[N+5],c1[N+5],c2[N+5];

inline void Max(pii &x,pii y){//用 y 更新 x 
	if(y.fi>x.fi)x=y;
	else if(y.fi==x.fi)x.se=(x.se+y.se)%mod;
	return;
}

inline void cmx(int p,pii x){
	for(;p<=m;p+=lowbit(p))Max(gs[p],x);
	return;
}

inline pii gmx(int p){
	pii ret={0,0};
	for(;p;p-=lowbit(p))Max(ret,gs[p]);
	return ret;
}

inline void cgs(int p){
	for(;p<=m;p+=lowbit(p))gs[p]={0,0};
	return;
}

inline bool cmp1(Node x,Node y){
	return (x.a^y.a?x.a<y.a:(x.b^y.b?x.b<y.b:(x.c^y.c?x.c<y.c:(x.d^y.d?x.d<y.d:x.v>y.v))));
}

inline bool cmp2(Node x,Node y){
	return (x.b^y.b?x.b<y.b:(x.c^y.c?x.c<y.c:(x.d^y.d?x.d<y.d:x.a<y.a)));
}

inline bool cmp3(Node x,Node y){
	return (x.c^y.c?x.c<y.c:(x.d^y.d?x.d<y.d:(x.a^y.a?x.a<y.a:x.b<y.b)));
}

inline void Disc(){
	for(int i=1;i<=n;i++)lsh[++m]=b[i].d;
	sort(lsh+1,lsh+m+1);
	m=unique(lsh+1,lsh+m+1)-lsh-1;
	for(int i=1;i<=n;i++)b[i].d=lower_bound(lsh+1,lsh+m+1,b[i].d)-lsh;
	return;
}

inline void cdq2(int l,int r){
	if(l==r)return;
	int mid=(l+r)>>1,pl=l,pr=mid+1;
	cdq2(l,mid);
	for(int i=l;i<=r;i++)c1[i]=c2[i];
	sort(c1+pl,c1+mid+1,cmp3);
	sort(c1+pr,c1+r+1,cmp3);
	while(pl<=mid&&pr<=r){
		if(c1[pl].c<=c1[pr].c){
			if(c1[pl].lf)cmx(c1[pl].d,dp[c1[pl].id]);
			pl++;
		}else{
			if(!c1[pr].lf){
				pii mx=gmx(c1[pr].d);
				mx.fi+=c1[pr].v;
				Max(dp[c1[pr].id],mx);
			}
			pr++;
		}
	}
	for(;pr<=r;pr++){
		if(c1[pr].lf)continue;
		pii mx=gmx(c1[pr].d);
		mx.fi+=c1[pr].v;
		Max(dp[c1[pr].id],mx);
	}
	for(int i=l;i<pl;i++)if(c1[i].lf)cgs(c1[i].d);
	cdq2(mid+1,r);
	return;
}

inline void cdq1(int l,int r){
	if(l==r)return;
	int mid=(l+r)>>1;
	cdq1(l,mid);
	for(int i=l;i<=r;i++){
		c2[i]=b[i];
		c2[i].lf=(i<=mid);
	}
	sort(c2+l,c2+r+1,cmp2);
	cdq2(l,r);
	cdq1(mid+1,r);
	return;
}

signed main(){
	cdqn=read();tMp=read();
	for(int i=1;i<=cdqn;i++)a[i]={read(),read(),read(),read(),read(),0,0};
	sort(a+1,a+cdqn+1,cmp1);
	for(int i=1;i<=cdqn;i++){
		if((a[i].a^b[n].a)||(a[i].b^b[n].b)||(a[i].c^b[n].c)||(a[i].d^b[n].d))b[++n]=a[i];
		else if(a[i].v>0)b[n].v+=a[i].v;
	}
	Disc();
	for(int i=1;i<=n;i++){
		b[i].id=i;
		dp[i]={b[i].v,1};
	}
	cdq1(1,n);
	for(int i=1;i<=n;i++)Max(ans,dp[i]);
	write(ans.fi);
	puts("");
	write(ans.se);
	return 0;
}
```

~~个人认为代码还是很简洁的？~~

其实还有 [另一个双倍经验](https://www.luogu.com.cn/problem/P3769)。

---

## 作者：Le0Chan (赞：3)

题解区的 kdt 怎么是替罪羊式重构啊。

考虑简单 dp。设 $dp_i$ 表示走到第 $i$ 个宝藏处的最大权值，顺便记个 $dp2_{i}$ 为方案数。

则有转移 $dp_{i}=\max\{dp_j\}+val_i$。把 $dp_j$ 最大且相等的 $dp2_j$ 求个和就是 $dp_{i}$。转移前提是四个维度上 $j$ 均小于等于 $i$，显然是个四维偏序问题。做法相当多，cdq 套 cdq，kd-tree 等等。

我选择后者，考虑先排序搞掉第一维，下面每次找转移点相当于查询立方体内的最大值，以及方案数求和。复杂度是 $O(n^{\frac{2}{3}})$。

题解说要进行插入，还用了替罪羊式重构。首先替罪羊式重构的插入虽然总体是 $O(n\log^2 n)$ 的。但是一次查询却不是 $O(\sqrt n)$ 的（二维情况下），具体可见[command_block 的博客](https://www.luogu.com.cn/blog/command-block/kdt-xiao-ji)，博客里只提到了二维的上界证明，三维的我不会证，但是应当不优于 $O(n^{\frac{2}{3}})$。

就算非要插入点，也建议写二进制分组，查询复杂度不变，插入复杂度均摊 $O(n\log^2n)$。还有一种根号重构，为了平衡复杂度经常要带个根号下的 $\log$ 什么的，复杂度也不够优秀。

然而本题可以不用插入点，因为 kdt 的树形结构是由点与点之间的空间坐标的相对大小决定的，本题中每个宝藏的空间坐标都没有变化，所以可以提前建好树，不再破坏其结构。求出每个点的 $dp,dp2$ 后在 kdt 上单点修改即可。由于 kdt 的树高为 $\log n$，所以修改是 $O(n\log n)$。

总的时间复杂度 $O(n^{\frac{5}{3}}+n\log n)$。理论复杂度与 cdq 套 cdq 差不多，但是常数略大，需要卡常，加了些减少取模的东西喜提最劣解。但是 kdt 牛就牛在可以剪枝，乱搞能力极强，所以借鉴了题解老哥的最优性剪枝后跑到最优解第三。

---

## 作者：Flanksy (赞：2)

### 分治、树状数组
------------
做完这道题，分治水平没啥提升，对树状数组的理解反而更深刻了。

这篇题解主要讨论树状数组的使用方法，对清楚树状数组在这道题中怎么使用的读者价值并不大。

看到题面，发现是四维偏序。先把所有的宝藏点以维度为关键字排序，排序从哪个维度开始并不重要，其目的是把相同位置的宝藏合并，保证答案正确统计。离散一个维度，在最后一层分治时用树状数组统计这个离散后的维度。

接下来使用两层分治，由于先前的排序，已经有一个维度被无效化。在第二层分治中加入树状数组。对于动态规划，类似于树状数组求 LIS，在第四维查询某个位置之前存在的最大值和相应的方案数量，更新这个数的方案数量，然后将这个位置的最大值、方案数量挂载在树状数组中。

然后写出这样一个树状数组。

```cpp
pair<long long,long long> c[80001];
void add(const Yuan &x){//Yuan是记录宝藏信息的结构体
	for(int i=x.k;i<=cnt;i+=i&-i)//dp为抵达该点最大可以获得的宝藏价值
		if(x.dp<c[i].first) break;
		else if(x.dp>c[i].first) c[i]=make_pair(x.dp,x.ans);
		else (c[i].second+=x.ans)%=mod;//ans为dp对应的方案数量
}
void del(const Yuan &x){
	for(int i=x.k;i<=cnt;i+=i&-i)
		if(c[i]==emp) break;//emp=make_pair(0ll,0ll)
		else c[i]=emp;
}
void update(Yuan &x){
	auto ret=emp;
	for(int i=x.k;i;i-=i&-i) ret=max(ret,c[i]);
	if(x.w+ret.first>x.dp) x.dp=x.w+ret.first,x.ans=ret.second;
	else if(x.w+ret.first==x.dp) (x.ans+=ret.second)%=mod;
}
```

[评测记录](https://www.luogu.com.cn/record/100359307)

大致分析错误原因，应该是 `update` 出现了问题，这里涉及树状数组本身的性质，使笔者对此题印象深刻。

树状数组是维护前缀信息的数据结构，将整个序列的前缀信息二进制拆分，能够做到快速修改和快速统计。题中用树状数组维护前缀最小值和对应的方案数量，但在 `update` 过程中，**只拿出了询问区间某一段的最值和其相应方案数，虽然取得的最值是正确的，但并没有获得区间内部的所有合法方案数。**

解决方法是对正在统计的区间最值分类讨论，若大于当前最值则替换答案；若等于当前最值则累加到答案中。或者使用线段树解决，合并区间时判断左右区间最值的大小关系，相等则累加二者方案数，不等则继承较大值和其方案数。

```cpp
void add(const Yuan &x){
	for(int i=x.k;i<=cnt;i+=i&-i)
		if(x.dp<c[i].first) break;
		else if(x.dp>c[i].first) c[i]=make_pair(x.dp,x.ans);
		else (c[i].second+=x.ans)%=mod;
}
void del(const Yuan &x){
	for(int i=x.k;i<=cnt;i+=i&-i)
		if(c[i]==emp) break;
		else c[i]=emp;
}
void update(Yuan &x){
	for(int i=x.k;i;i-=i&-i) 
		if(c[i].first+x.w>x.dp) x.dp=c[i].first+x.w,x.ans=c[i].second;
		else if(c[i].first+x.w==x.dp) (x.ans+=c[i].second)%=mod;
}
```
以上的树状数组代码搭配一个正确的分治套分治就可以通过本题了。

[AC Code](https://www.luogu.com.cn/paste/pf2c840a)

---

## 作者：lemondinosaur (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P4849)

---
# 题目大意
在一个四维坐标系中，给定 $n$ 个点，问有多少种选择点的方案，

使得这些点排序后任意坐标单调不降，并且选择的点权和最大，同时输出最大值

---
# 分析
设 $f[i]$ 表示最后一个点为$i$时的最大点权和，

则 $f[i]=\max\{f[j]\}+a[i],p[j]\leq p[i]$， $p$ 为四维坐标

设 $dp[i]$ 表示在取到最大点权和时的方案数，

则 $dp[i]=\begin{cases}\sum dp[j'],f[j']=\max\{f[j]\}\\ 1,otherwise\end{cases}$

这是 $O(n^2)$ 的做法，考虑用KD-Tree维护偏序关系，

需要记录子树内最大值以及出现次数，考虑以下几个方面。

- 建树：第一维可以排序后省掉，其实就剩下三维，然后重构这里用替罪羊树的方法
- 剪枝1：维护子树内每个坐标的最小值和最大值，如果子树内存在一个最小值大于当前坐标，那么无须遍历该子树
- 剪枝2：如果当前答案比子树内的答案大那么这棵子树不用遍历
- 剪枝3：如果子树内所有最大值都不小于当前坐标，那么这棵子树的答案可以直接用

---
# 代码
```cpp
#include <cstdio>
#include <cctype>
#include <cstring>
#include <algorithm>
#define rr register
using namespace std;
const int N=80011; const double alp=0.75;
typedef long long lll; lll Ans,ans[N]; int AC,root,n,ran;
inline signed iut(){
	rr int ans=0,f=1; rr char c=getchar();
	while (!isdigit(c)) f=(c=='-')?-f:f,c=getchar();
	while (isdigit(c)) ans=(ans<<3)+(ans<<1)+(c^48),c=getchar();
	return ans*f;
}
struct rec{
	int X,p[3]; lll w,c;
	inline bool operator <(const rec &t)const{
	    return p[ran]<t.p[ran];
	}
}a[N];
inline lll min(lll a,lll b){return a<b?a:b;}
inline lll max(lll a,lll b){return a>b?a:b;}
inline signed mo(int x,int y){return (x+y)%998244353;}
struct KD_Tree{
	int mn[N][3],mx[N][3],son[N][2],siz[N],stac[N],TOP,tot;
	lll w[N],wc[N]; rec pt[N],p[N];
	inline void pup(int now){//上传pushup
		for (rr int i=0;i<3;++i){
			mn[now][i]=mx[now][i]=p[now].p[i];
			if (son[now][0]){
				mn[now][i]=min(mn[now][i],mn[son[now][0]][i]);
				mx[now][i]=max(mx[now][i],mx[son[now][0]][i]);
			}
			if (son[now][1]){
				mn[now][i]=min(mn[now][i],mn[son[now][1]][i]);
				mx[now][i]=max(mx[now][i],mx[son[now][1]][i]);
			}
		}
		w[now]=max(p[now].w,max(w[son[now][0]],w[son[now][1]])),wc[now]=0;//最大值只有三种情况
		if (w[now]==p[now].w) wc[now]=p[now].c;
		if (w[now]==w[son[now][0]]) wc[now]+=wc[son[now][0]];
		if (w[now]==w[son[now][1]]) wc[now]+=wc[son[now][1]];
		siz[now]=siz[son[now][0]]+siz[son[now][1]]+1;
	}
	inline bool balance(int now){return alp*siz[now]>=(max(siz[son[now][0]],siz[son[now][1]]));}//替罪羊树判定平衡
	inline void recycle(int now){//回收
		if (son[now][0]) recycle(son[now][0]);
		stac[++TOP]=now,pt[TOP]=p[now];
		if (son[now][1]) recycle(son[now][1]);
	}
	inline signed build(int l,int r,int Ran){//建树
		if (l>r) return 0;
		rr int mid=(l+r)>>1,now=stac[mid];
		ran=Ran,nth_element(pt+l,pt+mid,pt+1+r),p[now]=pt[mid];
		son[now][0]=build(l,mid-1,(Ran+1)%3);
		son[now][1]=build(mid+1,r,(Ran+1)%3);
		pup(now);
		return now;
	}
	inline void rebuild(int &now,int Ran){//重构
		TOP=0,recycle(now);
		now=build(1,TOP,Ran);
	}
	inline void Insert(int &now,rec W,int Ran){//插入
		if (!now) now=++tot,p[now]=W;
		else{
			if (W.p[Ran]<=p[now].p[Ran]) Insert(son[now][0],W,(Ran+1)%3);
			    else Insert(son[now][1],W,(Ran+1)%3);
		}
		pup(now);
		if (!balance(now)) rebuild(now,Ran);
	}
	inline bool check0(int j,int i){
		for (rr int o=0;o<3;++o)
		    if (p[j].p[o]>p[i].p[o]) return 0;
		return 1;
	}
	inline bool check1(int j,int i){
		for (rr int o=0;o<3;++o)
		    if (mn[j][o]>p[i].p[o]) return 1;
		return 0;
	}
	inline bool check2(int j,int i){
		for (rr int o=0;o<3;++o)
		    if (mx[j][o]>p[i].p[o]) return 0;
		return 1;
	}
	inline signed query(int now,lll &ans,int x){
		rr int f=0;
		if (check0(now,x)){
			if (ans<p[now].w) f=p[now].c,ans=p[now].w;
			    else if (ans==p[now].w) f=mo(f,p[now].c);
		}
	    while (son[now][0]){
			rr int t=son[now][0];
			if (check1(t,x)||ans>w[t]) break;//剪枝1、2，下同
			if (check2(t,x)){//剪枝3
				if (ans<w[t]) f=wc[t],ans=w[t];
				    else if (ans==w[t]) f=mo(f,wc[t]);
			}else{
				rr lll o=ans,NOW=query(t,ans,x);
				if (o<ans) o=ans,f=NOW;
				    else if (o==ans) f=mo(f,NOW);
			}
			break;
		}
	    while (son[now][1]){
			rr int t=son[now][1];
			if (check1(t,x)||ans>w[t]) break;
			if (check2(t,x)){
				if (ans<w[t]) f=wc[t],ans=w[t];
				    else if (ans==w[t]) f=mo(f,wc[t]);
			}else{
				rr lll o=ans,NOW=query(t,ans,x);
				if (o<ans) o=ans,f=NOW;
				    else if (o==ans) f=mo(f,NOW);
			}
			break;
		}
		return f;
	}
}Tre;
bool cmp(rec x,rec y){
	if (x.X!=y.X) return x.X<y.X;//在KD-Tree中省略第一维
	for (rr int i=0;i<3;++i)
	if (x.p[i]!=y.p[i]) return x.p[i]<y.p[i];
	return 0;
}
signed main(){
	n=iut(),iut();
	for (rr int i=1;i<=n;++i) a[i]=(rec){iut(),iut(),iut(),iut(),iut(),0};
	sort(a+1,a+1+n,cmp);
	for (rr int i=1;i<=n;++i){
		Tre.p[i]=a[i],a[i].c=Tre.query(root,ans[i],i); 
		if (!a[i].c) a[i].c=1;//如果之前没有答案那么方案数为1
		a[i].w+=ans[i],Tre.Insert(root,a[i],0);
	}
	for (rr int i=1;i<=n;++i)
	if (Ans<a[i].w) Ans=a[i].w,AC=a[i].c;
	    else if (Ans==a[i].w) AC=mo(AC,a[i].c);
	return !printf("%lld\n%d",Ans,AC);
}
```

---

## 作者：木棉絮123 (赞：0)

### UPD
2024/10/9：修复了数学公式。
## 题意简述：
求点权和最大的四维偏序的点权和，以及其方案数。
## 前置知识:
[CDQ](https://www.luogu.com.cn/problem/P3810)

树状数组（相信大家都会）
## 简要思路：
如果你会思路但是细节不会可以直接跳到下一节。~~不保证教会~~
### 1.朴素方法
容易写出转移方程：
$$ dp_{i}=\max([a_{j}\le a_{i}][b_{j}\le b_{i}][c_{j}\le c_{i}][d_{j}\le d_{i}]dp_{j})+w_{i}$$
记 $cnt_{i}$ 为到第 $i$ 个点最大的方案数。

不难想出一种 $O(n^{2})$ 的朴素暴力：
```
sort(node)
for i,1 to n
  for j,1 to i
    if(点对(i,j)满足条件)
      转移 dp 和 cnt 的值
```
因为坐标值大的点只能从坐标值小的点转移过来，正确性显然。

考虑优化 dp 过程，发现瓶颈在于我们枚举了每一个点对。这时我们考虑使用数据结构来优化（KDT 我不会），便考虑CDQ分治。
### 2.CDQ
CDQ 解决三维偏序，本质是将点划分为 $(0,a,b)$ 和 $(1,a,b)$ 两部分再按第二维排序，然后用树状数组来维护第三维上的信息（这就是为什么仅需且必需离散化最后一维，这影响树状数组的复杂度）。

解决四维偏序需要 CDQ 套 CDQ。

外层 CDQ 划分点，使之变成 $(0/1,b,c,d)$ 的形式（即分为左右两部分），再按照  $b$ 排序并传给内层，内层 CDQ 再一次划分点，使之变成 $(0/1,0/1,c,d)$ 的形式（再分为上下两部分)，接下来按照 $c$ 排序。

不难发现，只有 $(0,0,c_{i},d_{i})$ 的点一定会对 $(1,1,c_{j},d{j})$ 的点产生贡献（当 $c_{j}\le c_{i}$ 且 $d_{j}\le d_{i}$ 时），而别的形式的点对，会在 CDQ 中别的时候计算到。

**一定要注意，CDQ的访问顺序是中序的。**

### 3.转移的设计

假设现在（在内层 CDQ 中）已经按 $c$ 拍好序了，我们要怎么去转移 $dp$ 和 $cnt$ 的值呢？

我们使用一个树状数组，对于左下部分的点，按 $d$ 值插入树状数组中，对于右上的点，则在树状数组中查询小于 $d$ 的点，因为已经按 $c$ 排好序了，所以某一次的查询可以找到所有符合要求的点。

## 代码细节：
### 1.树状数组
这道题目的树状数组形式比较奇妙，我是这么写的：
```cpp
ll ff[MAX],cnt[MAX];
//一定要想明白，这里的下标对应的是 d 值。
//其含义是在坐标小于 d 时，最大的 dp 值及其对应的方案数。
void update(int x,ll v,ll sum){
	while(x<=n){
		if(ff[x]<v){
			cnt[x]=sum;ff[x]=v;
		}
		else if(ff[x]==v){
			cnt[x]+=sum;cnt[x]%=P;
		}
		x+=lowbit(x);
	}
}
void query(int x,ll &f,ll &sum,ll v){
//对于查询，使用引用来简化代码
	while(x){
		if(ff[x]+v>f){
			f=ff[x]+v;sum=cnt[x];
		}
		else if(ff[x]+v==f){
			sum+=cnt[x];sum%=P;
		}
		x-=lowbit(x);
	}
}
```
请结合 CDQ 的过程和注释思考其含义。
### 排序
快排是不稳定的，所以请使用 `stable_sort()` 或着比较时把四个关键字都比一遍。
### 预处理
把同一位置的宝藏合为一个会方便处理。记得离散化，要不然树状数组会挂。

[完整代码](https://www.luogu.com.cn/paste/37099azc)

~~为什么这题降紫了还我水黑。~~

---

## 作者：IkunTeddy (赞：0)

# 题意
求四维 LIS 及其方案数。

# 题目分析

多维 LIS 偏序问题优先考虑 cdq 优化 dp。

设 $f_i$ 表示以 $i$ 结尾的 LIS 长度，$g_i$ 表示以 $i$ 结尾的 LIS 方案数。

在递归时，先遍历左边，再用左边的 dp 数组更新右边，继续递归右边。最底层用树状数组求解即可。

$$ans=\max\limits_{i=1}^{n}f_i$$

$$cnt=\sum\limits_{i=1}^{n}g_i\left [  f_i=ans\right ] $$

这道题就做完了。

# Code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
//
const int maxn=1e6+10;
const int mod=998244353;
int n,N,INF;
int disc[maxn];
ll f[maxn],g[maxn],ans,tot;
//
ll ft1[maxn],ft2[maxn];
int lowbit(int x){return -x&x;}
void update(int x,ll k1,ll k2){
	for(int i=x;i<=N;i+=lowbit(i)){
		if(k1>ft1[i]){
			ft1[i]=k1;
			ft2[i]=k2;
		}else if(k1==ft1[i]){
			ft2[i]=(ft2[i]+k2)%mod;
		}
	}
}
void clear(int x){
	for(int i=x;i<=N;i+=lowbit(i)){
		ft1[i]=ft2[i]=0;
	}
}
ll ask_max(int x){
	ll res=0;
	for(int i=x;i>=1;i-=lowbit(i)){
		res=max(res,ft1[i]);
	}
	return res;
}
ll ask_sum(int x){
	ll mx=0,res=0;
	for(int i=x;i>=1;i-=lowbit(i)){
		if(ft1[i]>mx){
			mx=ft1[i];
			res=ft2[i];
		}else if(ft1[i]==mx){
			res=(res+ft2[i])%mod;
		}
	}
	return res;
}
//
struct node{
	int p[5];
	ll val;
	int id;
	int op[5];
}s[5][maxn];
int now;
bool cmp(node x,node y){
	int k=now;
	for(int i=1;i<=4;i++){
		if(x.p[k]!=y.p[k])return x.p[k]<y.p[k];
		k=((k+1>4)?1:(k+1));
	}
	if(x.op[1]!=y.op[1])return x.op[1]<y.op[1];
	else return x.op[2]<y.op[2];
}
int check(int k,int x,int val){
	return s[k][x].op[1]==val&&s[k][x].op[2]==val;
}
void cdq(int l,int r,int k){
	if(l==r)return ;
	int mid=(l+r)>>1;
	cdq(l,mid,k);
	for(int i=l;i<=r;i++)s[k][i]=s[k-1][i];
	if(k!=3){
		for(int i=l;i<=r;i++)s[k][i].op[k-1]=(i>mid); 
		now=k;
		sort(s[k]+l,s[k]+r+1,cmp);
		cdq(l,r,k+1);
	}else{
		for(int i=l;i<=r;i++)s[k][i].op[k-1]=(i>mid);
		now=k;
		sort(s[k]+l,s[k]+r+1,cmp);
		for(int i=l;i<=r;i++){
			if(check(k,i,0))update(s[k][i].p[k+1],f[s[k][i].id],g[s[k][i].id]);
			if(check(k,i,1)){
				if(ask_max(s[k][i].p[k+1])+s[k][i].val>f[s[k][i].id]){
					f[s[k][i].id]=ask_max(s[k][i].p[k+1])+s[k][i].val;
					g[s[k][i].id]=ask_sum(s[k][i].p[k+1]);
				}else if(ask_max(s[k][i].p[k+1])+s[k][i].val==f[s[k][i].id]){
					g[s[k][i].id]=(g[s[k][i].id]+ask_sum(s[k][i].p[k+1]))%mod;
				}
				
			}
		}
		for(int i=l;i<=r;i++)if(check(k,i,0))clear(s[k][i].p[k+1]); 
	}
	cdq(mid+1,r,k);
}
int main(){
	cin>>n>>INF;
	disc[++N]=INF;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=4;j++){
			cin>>s[1][i].p[j];
			disc[++N]=s[1][i].p[j];
		}
		cin>>s[1][i].val;
		s[1][i].id=i;
		f[i]=s[1][i].val;
		g[i]=1;
	}
	sort(disc+1,disc+N+1);
	N=unique(disc+1,disc+N+1)-disc-1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=4;j++){
			s[1][i].p[j]=lower_bound(disc+1,disc+N+1,s[1][i].p[j])-disc;
		}
	}
	now=1;
	sort(s[1]+1,s[1]+n+1,cmp);
	cdq(1,n,2);
	for(int i=1;i<=n;i++)ans=max(ans,f[i]);
	cout<<ans<<'\n';
	for(int i=1;i<=n;i++)if(f[i]==ans)tot=(tot+g[i])%mod;
	cout<<tot<<'\n';

	return 0;
}
```

---

## 作者：Purslane (赞：0)

# Solution

你说得对，但是我不会 CDQ 分治。

看到这道题第一眼是 CDQ + 前后缀优化建图之后再 DAG 上动态规划。~~可惜的是这样空间也变成了 $O(n \log^3 n)$ 的了。~~

所以我们为什么一定要把“建图”这件事搞出来？容易发现如果把 CDQ 分治当做一棵树形结构，那么我们进行 CDQ 分治实际上相当于后序遍历。而由于状态转移特有的性质，我们应当使用中序遍历：先计算 $[l,mid+1)$ 的答案，然后贡献到 $[mid+1,r+1)$ 中，最后计算 $[mid+1,r+1)$ 的答案。

其实这是简单的，我们先预处理每次进行 CDQ 套 CDQ 的过程中，两边按照前第二维排序后的结果（注意只需要记录外层 CDQ）。然后再进行一次 CDQ 套 CDQ（不过并不需要真正的排序了），每次按照预处理的结果进行里层 CDQ 转移即可。

注意在排序的时候，尽可能选择多关键字排序，这样保证贡献能被加上去。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=80000+10,MOD=998244353;
int n,m;
struct Node {int a,b,c,d,v,id,op;}t[MAXN];
vector<Node> st[MAXN<<2];
int comp(Node A,Node B) {
	if(A.b!=B.b) return A.b<B.b;
	if(A.c!=B.c) return A.c<B.c;
	if(A.d!=B.d) return A.d<B.d;
	return 1;
}
void cdq_init(int k,int l,int r) {
	if(l==r) return st[k].push_back(t[l]),void();
	int mid=l+r>>1,lson=k<<1,rson=k<<1|1;
	cdq_init(k<<1,l,mid),cdq_init(k<<1|1,mid+1,r);
	int pos1=0,pos2=0;
	while(pos1<st[lson].size()&&pos2<st[rson].size()) {
		if(comp(st[lson][pos1],st[rson][pos2])) st[k].push_back(st[lson][pos1++]),st[k][st[k].size()-1].op=1;
		else st[k].push_back(st[rson][pos2++]),st[k][st[k].size()-1].op=0;
	}
	while(pos1<st[lson].size()) st[k].push_back(st[lson][pos1++]),st[k][st[k].size()-1].op=1;
	while(pos2<st[rson].size()) st[k].push_back(st[rson][pos2++]),st[k][st[k].size()-1].op=0;
	return ;
}
int lsh[MAXN],tot; Node tt[MAXN],tmp[MAXN];
struct INFO {ll mx,cnt;}bt[MAXN],ans[MAXN];
INFO operator +(INFO A,int B) {return {A.mx+B,A.cnt};}
INFO operator +(INFO A,INFO B) {return {max(A.mx,B.mx),((A.mx>=B.mx)*A.cnt+(A.mx<=B.mx)*B.cnt)%MOD};}
void update(int pos,INFO ix) {while(pos<=m) bt[pos]=bt[pos]+ix,pos=pos+(pos&-pos);return ;}
INFO query(int pos) {INFO ans={0,0}; while(pos) ans=ans+bt[pos],pos=pos-(pos&-pos);return ans;}
void clr(int pos) {while(pos<=m) bt[pos]={0,0},pos=pos+(pos&-pos);return ;}
void cdq(int l,int r) {
	if(l==r) return ;
	int mid=l+r>>1;
	cdq(l,mid),cdq(mid+1,r);
	int pos1=l,pos2=mid+1,tpos=l-1;
	while(pos1<=mid&&pos2<=r) {
		if(tt[pos1].c<=tt[pos2].c) {
			if(tt[pos1].op) update(tt[pos1].d,ans[tt[pos1].id]);
			tmp[++tpos]=tt[pos1],pos1++;
		}
		else {
			if(!tt[pos2].op) ans[tt[pos2].id]=ans[tt[pos2].id]+(query(tt[pos2].d)+tt[pos2].v);
			tmp[++tpos]=tt[pos2],pos2++;
		}
	}
	while(pos1<=mid) {
		if(tt[pos1].op) update(tt[pos1].d,ans[tt[pos1].id]);
		tmp[++tpos]=tt[pos1],pos1++;
	}
	while(pos2<=r) {
		if(!tt[pos2].op) ans[tt[pos2].id]=ans[tt[pos2].id]+(query(tt[pos2].d)+tt[pos2].v);
		tmp[++tpos]=tt[pos2],pos2++;
	}
	ffor(i,l,r) clr(tt[i].d);
	ffor(i,l,r) tt[i]=tmp[i];
	return ;
}
void solve(vector<Node> vc) {
	tot=0; for(auto id:vc) tt[++tot]=id;
	cdq(1,tot);
	return ;
}
void dfs(int k,int l,int r) {
	if(l==r) return ;
	int mid=l+r>>1;
	dfs(k<<1,l,mid),solve(st[k]),dfs(k<<1|1,mid+1,r);
	return ;
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n;
	ffor(i,1,n) cin>>t[i].a>>t[i].b>>t[i].c>>t[i].d>>t[i].v,t[i].id=i,ans[i]={t[i].v,1},lsh[++tot]=t[i].d;
	sort(lsh+1,lsh+tot+1),tot=unique(lsh+1,lsh+tot+1)-lsh-1;
	ffor(i,1,n) t[i].d=lower_bound(lsh+1,lsh+tot+1,t[i].d)-lsh;
	m=tot;
	sort(t+1,t+n+1,[](Node A,Node B) {
		if(A.a!=B.a) return A.a<B.a;
		if(A.b!=B.b) return A.b<B.b;
		if(A.c!=B.c) return A.c<B.c;
		if(A.d!=B.d) return A.d<B.d;	
		return false;
	});
	cdq_init(1,1,n),dfs(1,1,n);
	INFO res={0,0};
	ffor(i,1,n) res=res+ans[i];
	cout<<res.mx;
	return 0;
}
//菊花殘 滿地傷 你的笑容剪不斷 徒留我孤單在湖面成雙 
```

---

## 作者：Genius_Star (赞：0)

### 思路：

首先 $dp_i$ 表示以第 $i$ 个点结尾的最长长度，则状态转移方程为：

$$dp_i=\max([a_j \le a_i][b_j \le b_i][c_j \le c_i][d_j \le d_i] dp_j + w_i)$$

然后定义 $s_i$ 表示以第 $i$ 点结尾且长度最长的方案数，则状态转移方程为：

$$s_i=\sum\limits [a_j \le a_i][b_j \le b_i][c_j \le c_i][d_j \le d_i][dp_j + w_i = dp_i] s_j$$

朴素转移是 $O(N^2)$ 的，一般情况下会超时。

因为这题本质是一个四维偏序问题，可以先将第一维 $a$ 进行排序后，变成了三维空间内求一个长方体内最大点值。

考虑使用数据结构进行维护，开一个三层的树套树，外层是树状数组，中层和下层是动态开点线段树。

这样时间和空间复杂度是 $O(N \log^3 N)$ 的，空间上貌似不允许，考虑 cdq 分治算法。

对于三维偏序问题，先将第一维排序，然后设当前分治区间为 $[l,r]$，将左右两区间按照第二维排序，现在要计算 $[l,mid]$ 对 $[mid+1,r]$ 的贡献。

明显可以走指针，对于第三维使用树状数组维护即可，时间复杂度为 $O(N \log^3 N)$，但是空间复杂度基本是 $O(N)$。

其实 cdq 分治本质上是将左右两区间变成 $(a_1,0,c_1)$ 和 $(a_2,1,c_2)$ 的形式，使得左区间的第二维对于右区间都满足条件。

而四维偏序也是同理，考虑将左右两区间变为 $(a_1,0/1,0/1,d_1)$ 和 $(a_2,0/1,0/1,d_2)$ 的形式。

考虑用 cdq 套 cdq 解决，先变为 $(a_1,0,c_1,d_1)$ 和 $(a_2,1,c_2,d_2)$ 的形式，然后将这个区间的第三维进行 cdq 分治。

时间复杂度为 $O(N \log^3 N)$。

**注意第四维要先离散化。**

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define lowbit(x) x&(-x)
using namespace std;
typedef long long ll;
const ll N=80080,mod=998244353; 
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,cnt,ans,sum;
ll b[N];
struct Node{
	ll a,b,c,d;	
	ll w,ans,t;
	bool f;
}a[N];
class BIT{
public:
	ll a[N],b[N];
	void add(ll x,ll v,ll t){
		for(ll i=x;i<=cnt;i+=lowbit(i)){
			if(a[i]==v)
			  b[i]=(b[i]+t)%mod;
			else if(a[i]<v){
				a[i]=v;
				b[i]=t;
			}
		}
	}
	void clear(ll x){
		for(int i=x;i<=cnt;i+=lowbit(i))
		  a[i]=b[i]=0;
	}
	ll qurey(ll x){
		ll ans=0;
		for(int i=x;i;i-=lowbit(i))
		  ans=max(ans,a[i]);
		return ans;
	}
	ll qurey(ll x,ll y){
		ll ans=0;
		for(int i=x;i;i-=lowbit(i))
		  if(a[i]==y)
		    ans=(ans+b[i])%mod;
		return ans;
	}	
}T;
bool cmp1(const Node&x,const Node&y){
	if(x.a!=y.a)
	  return x.a<y.a;
	if(x.b!=y.b)
	  return x.b<y.b;
	if(x.c!=y.c)
	  return x.c<y.c;
	return x.d<y.d;
}
bool cmp2(const Node&x,const Node&y){
	if(x.b!=y.b)
	  return x.b<y.b;
	if(x.c!=y.c)
	  return x.c<y.c;
	return x.d<y.d;
}
bool cmp3(const Node&x,const Node&y){
	if(x.c!=y.c)
	  return x.c<y.c;
	return x.d<y.d;
}
void cdq2(ll l,ll r){
	if(l==r)
	  return;
	ll mid=(l+r)>>1;
	cdq2(l,mid);
	stable_sort(a+l,a+mid+1,cmp3);
	stable_sort(a+mid+1,a+r+1,cmp3);
	ll i=l,j=mid+1;
	for(;j<=r;j++){
		while(i<=mid&&a[i].c<=a[j].c){
			if(!a[i].f)
			  T.add(a[i].d,a[i].ans,a[i].t);
			i++;
		}
		if(a[j].f){
			ll w=T.qurey(a[j].d);
//			cerr<<T.qurey(a[j].d,w)<<'\n';
			if(a[j].ans==w+a[j].w)
			  a[j].t=(a[j].t+T.qurey(a[j].d,w))%mod;
			else if(a[j].ans<w+a[j].w){
				a[j].ans=w+a[j].w;
				a[j].t=T.qurey(a[j].d,w);
			}
		}
	}	
	for(int j=l;j<i;j++)
	  if(!a[j].f)
	    T.clear(a[j].d);
	stable_sort(a+l,a+r+1,cmp2);
	cdq2(mid+1,r);
}
void cdq1(ll l,ll r){
	if(l==r)
	  return;
	ll mid=(l+r)>>1;
	cdq1(l,mid);
	for(int i=l;i<=mid;i++)
	  a[i].f=0;
	for(int i=mid+1;i<=r;i++)
	  a[i].f=1;
	stable_sort(a+l,a+r+1,cmp2);
	cdq2(l,r);
	stable_sort(a+l,a+r+1,cmp1);
	cdq1(mid+1,r);
}
int main(){
	n=read(),read();
	for(int i=1;i<=n;i++){
		a[i]={read(),read(),read(),read(),read(),0,1,0};
		b[++cnt]=a[i].d;
		a[i].ans=a[i].w;
	}
	stable_sort(b+1,b+cnt+1);
	cnt=unique(b+1,b+cnt+1)-(b+1);
	for(int i=1;i<=n;i++)
	  a[i].d=lower_bound(b+1,b+cnt+1,a[i].d)-b;
	stable_sort(a+1,a+n+1,cmp1);
	cdq1(1,n);
	for(int i=1;i<=n;i++)
	  ans=max(ans,a[i].ans);
	for(int i=1;i<=n;i++)
	  if(a[i].ans==ans)
	    sum=(sum+a[i].t)%mod;
//	    	cerr<<a[i].t<<'\n';
	write(ans);
	putchar('\n');
	write(sum);
	return 0;
}
```

---

## 作者：AAA404 (赞：0)

很有借鉴意义的题。

# 题意简化

大概就是给定四维空间内的几个点，每个点有点权，然后要求选一些点，满足点的每一维坐标都单调不降，求最后能获得的**最大价值**和取得最大价值时的**方案数**。

# 思路简析

显然有一个 $O(n^2)$ 的朴素 dp，~~轻微~~究极卡常后靠评测机波动可以冲进去，放一下大佬的[记录](https://www.luogu.com.cn/record/136848457)，反正我没去卡。

（不会吧不会吧，不会有人来写这题连这个暴力都不会吧。）

建议您自行想想暴力怎么做，实在不会再看下面的做法（如果会了请跳至分割线下）。

---

将点按第一维排序，然后暴力枚举每一个点对，如果满足条件就转移更新最大值和方案数。

对没想到的同学的建议：菜，就多练。

---

首先容易发现这是一个四维偏序，考虑使用 cdq 分治优化 dp，但是显然一个 cdq 分治只能解决三维偏序，所以我们需要两个。

具体来说，每套上一个 cdq 分治就能多解决一维的偏序关系，于是我们只需要**对第一维排序**，然后**第一层 cdq 解决第二维的偏序关系，第二层 cdq 解决第三维偏序关系，里面再套个树状数组维护最后一维并统计答案**。

但是，很有可能您一直当板子来写的 cdq 分治在本题中假了，您需要进行**彻底**的排序。

如果您的排序函数没有像下面一样，对四个维度都考虑，那么大概率会被卡掉。

```cpp
bool cmp1(const node &a,const node &b)
{
	if(a.a!=b.a)return a.a<b.a;
	if(a.b!=b.b)return a.b<b.b;
	if(a.c!=b.c)return a.c<b.c;
	return a.d<b.d;
}
bool cmp2(const node &a,const node &b)
{
	if(a.b!=b.b)return a.b<b.b;
	if(a.c!=b.c)return a.c<b.c;
	if(a.d!=b.d)return a.d<b.d;
	return a.a<b.a;
}
bool cmp3(const node &a,const node &b)
{
	if(a.c!=b.c)return a.c<b.c;
	if(a.d!=b.d)return a.d<b.d;
	if(a.a!=b.a)return a.a<b.a;
	return a.b<b.b;
}
```

究其原因，本题中只要求坐标**单调不降**，而如果不考虑**除了当前维度之外的其它维度**，则有可能因**当前维度相等**而忽略了**其它维度的偏序关系**。

同时，写过 cdq 分治优化 dp 的同学都知道，本题处理顺序必须是**左中右**（因为 dp 转移依赖前继决策），这也是一个细节。

所以，回应开头那句话，本题是一个：

- cdq 套 cdq 的模板；

- cdq 分治优化 dp 的练手题；

- 有着一车细节对调试能力要求较高的好题。

我觉得很有借鉴意义。

时间复杂度：$O(n \log ^3 n)$。

这里说明一下，每套一层 cdq 需要在时间复杂度增加一只 $\log n$，实测在五维偏序时与 $O(n^2)$ 暴力几乎无差别，在更高维可能实际效率不如暴力。

至于 KD-Tree，四维偏序不加一车剪枝的话已经和暴力差不多了。

# Code

部分 dp 转移的处理和 cdq 分治的一些标记为了简洁借鉴了一些题解的写法。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=8e4+5,mod=998244353;
int n,m,c1[N],c2[N];
long long res,ans;
pair<long long,long long>f[N];
vector<long long>v;
struct node{
	int a,b,c,d,cnt,id,tag;
	bool operator==(const node&x)const{
		return a==x.a&&b==x.b&&c==x.c&&d==x.d;
	}
}a[N],b[N],c[N];
bool cmp1(const node &a,const node &b)
{
	if(a.a!=b.a)return a.a<b.a;
	if(a.b!=b.b)return a.b<b.b;
	if(a.c!=b.c)return a.c<b.c;
	return a.d<b.d;
}
bool cmp2(const node &a,const node &b)
{
	if(a.b!=b.b)return a.b<b.b;
	if(a.c!=b.c)return a.c<b.c;
	if(a.d!=b.d)return a.d<b.d;
	return a.a<b.a;
}
bool cmp3(const node &a,const node &b)
{
	if(a.c!=b.c)return a.c<b.c;
	if(a.d!=b.d)return a.d<b.d;
	if(a.a!=b.a)return a.a<b.a;
	return a.b<b.b;
}
#define lowbit(x) (x&-x)
void update(int x,int a,int b)
{
	for(;x<=n;x+=lowbit(x))
	{
		if(c1[x]==a)
			(c2[x]+=b)%=mod;
		else if(c1[x]<a)
		{
			c1[x]=a,c2[x]=b;
		}
	}
	return;
}
pair<long long,long long> query(int x)
{
	pair<long long,long long>ans;
	for(;x;x-=lowbit(x))
	{
		if(ans.first==c1[x])
		ans.second+=c2[x];
		else if(ans.first<c1[x])
		ans.first=c1[x],ans.second=c2[x];
	}
	return ans;
}
void del(int x)
{
	for(;x<=n;x+=lowbit(x))c1[x]=c2[x]=0;
	return;
}
void cdq2(int l,int r)
{
	if(l==r)return;
	int mid=l+r>>1;
	cdq2(l,mid);
	for(int i=l;i<=r;i++)
	c[i]=b[i];
	sort(c+l,c+mid+1,cmp3);
	sort(c+mid+1,c+r+1,cmp3);
	int i=l,j=mid+1;
	for(;j<=r;j++)
	{
		if(c[j].tag)continue;
		while(i<=mid&&c[i].c<=c[j].c)
		{
			if(c[i].tag)
			update(c[i].d,f[c[i].id].first,f[c[i].id].second);
			i++;
		}
		pair<long long,long long> tmp=query(c[j].d);
		tmp.first+=c[j].cnt;
		if(tmp.first==f[c[j].id].first)
		(f[c[j].id].second+=tmp.second)%=mod;
		if(tmp.first>f[c[j].id].first)
		f[c[j].id]=tmp;
		ans=max(ans,f[c[j].id].first);
	}
	for(int p=l;p<=i;p++)if(c[p].tag)del(c[p].d);
	cdq2(mid+1,r);
	return;
}
void cdq1(int l,int r)
{
	if(l==r)return;
	int mid=l+r>>1;
	cdq1(l,mid);
	for(int i=l;i<=r;i++)
	b[i]=a[i];
	for(int i=l;i<=mid;i++)
	b[i].tag=1;
	sort(b+l,b+r+1,cmp2);
	cdq2(l,r);
	cdq1(mid+1,r);
	return;
}
signed main()
{
	clock_t c1=clock();
#ifdef LOCAL
 	freopen("1.in","r",stdin);
 	freopen("1.out","w",stdout);
#endif
    ios::sync_with_stdio(0);
 	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].a>>a[i].b>>a[i].c>>a[i].d>>a[i].cnt;
		v.push_back(a[i].d);
	}
	sort(v.begin(),v.end());
	v.erase(unique(v.begin(),v.end()),v.end());
	sort(a+1,a+n+1,cmp1);
	int cnt=1;
	for(int i=2;i<=n;i++)
	{
		if(a[i]==a[cnt])
		a[cnt].cnt+=a[i].cnt;
		else a[++cnt]=a[i];
	}
	n=cnt;
	for(int i=1;i<=cnt;i++)
	{
		a[i].d=lower_bound(v.begin(),v.end(),a[i].d)-v.begin()+1;
		a[i].id=i;
		f[i].first=a[i].cnt;
		f[i].second=1;
	}
	cnt=v.size();
	cdq1(1,n);
	for(int i=1;i<=n;i++)
	if(ans==f[i].first)
	{
		(res+=f[i].second)%=mod;
	}
	cout<<ans<<endl<<res;
#ifdef LOCAL
	cerr<<"Time used:"<<clock()-c1<<"ms";
#endif
 	return 0;
}
```

---


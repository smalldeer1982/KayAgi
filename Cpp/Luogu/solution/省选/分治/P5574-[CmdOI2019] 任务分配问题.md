# [CmdOI2019] 任务分配问题

## 题目背景

挖矿的时候踢断电源线是一种怎样的体验?

## 题目描述

在某台有 $k$ 个 CPU 的计算机中，有 $n$ 个计算任务等待执行。

$a_i$ 为第 $i$ 个任务的优先级，方便起见， $a$ 为一个排列。

现在，要将这些任务分配给 CPU 去解决。

由于内存等原因，一个 CPU 只能负责连续一段的任务，并且要按 (从左到右的) 顺序执行。

**在某个 CPU 内**，无序度定义为：前者先执行，而后者优先级高的任务对的个数。

请最小化每个 CPU 的无序度之和。

## 说明/提示

### 样例说明

- **样例 #1**

  此时只能把所有任务交给单独的一个 CPU。

  第一个任务和其他所有任务都形成无序任务对；最后两个任务也形成无序任务对，共 $5$ 个。

- **样例 #2**

  第一个 CPU 单独处理任务 $1$ ，无序度为 $0$；
  
  第二个 CPU 处理 $\{5,4,2,3\}$ 无序度为 $1$。
  
### 限制与约定

对于所有测试数据，保证 $1\leq n\leq 2.5\times 10^4$，$1\leq k\leq 25$，$k\leq n$。

| 测试点编号 | $n$ | $k$ |
| :--: | :--: | :--: |
| $1\sim 2$ | $2.5\times 10^4$ | $1$ |
| $3$ | $2.5\times 10^4$ | $2$ |
| $4\sim 5$ | $1000$ | $10$ |
| $6\sim 10$ | $2.5\times 10^4$ | $25$ |

## 样例 #1

### 输入

```
5 1
1 5 4 2 3```

### 输出

```
5```

## 样例 #2

### 输入

```
5 2
1 5 4 2 3```

### 输出

```
1```

## 样例 #3

### 输入

```
8 3
1 3 5 2 7 4 8 6```

### 输出

```
4```

# 题解

## 作者：command_block (赞：10)

# 官方题解:任务分配问题

**人话题面:**  给一个序列分成$k$段,让每段内顺序对总和最小。

一道十分套路的DP题。

## #1~#2

只有一个CPU,写一个树状数组求顺序对就好了,不再赘述。

## #3

只有两个CPU,枚举分割线取min,树状数组维护两边顺序对即可,不再赘述。

## #4~#5

不难想到一个dp : 

设$f[j][i]$表示把前$i$个数分成$j$段所需的最小代价。

转移 : 设$c(i,j)$为$(i,j]$之间的顺序对数,可得:

$f[j][i]=\min\limits_{t=1}^{i-1}f[j-1][t]+c(t,i)$

如何计算$c(t,i)$?

注意到,类似莫队,我们能从$c(l,r)$使用树状数组$O(log)$推到相邻的区间。

那么我们就倒着来转移,不断加入数字,再更新逆序对数,就能做到转移$O(nlogn)$了。

总的复杂度是$O(n^2klogn)$

下面的这份代码可以拿到50pts:

```cpp
#include<algorithm>
#include<cstdio>
#define lowbit(x) ((x)&-(x))
#define MaxN 40500
using namespace std;
int n,k,a[MaxN],c[MaxN];
void clear(){for (int i=1;i<=n;i++)c[i]=0;}
void add(int pos)
{
  while(pos<=n)
    {c[pos]++;pos+=lowbit(pos);}
}
int query(int pos)
{
  int sum=0;
  while(pos)
    {sum+=c[pos];pos^=lowbit(pos);}
  return sum;
}
long long f[45][MaxN];
int main()
{
  scanf("%d%d",&n,&k);
  for (int i=1;i<=n;i++)scanf("%d",&a[i]);
  long long sav=0;
  for (int i=1;i<=n;i++){
    sav+=query(a[i]);
    f[1][i]=sav;
    add(a[i]);
  }if (k==1){printf("%lld",f[1][n]);return 0;}
  for (int j=2;j<k;j++){
    for (int i=j;i<=n;i++){
      clear();sav=0;f[j][i]=1ll<<60;
      add(a[i]);
      for (int t=i-1;t>=j-1;t--){
        f[j][i]=min(f[j][i],f[j-1][t]+sav);
        sav+=i-t-query(a[t]);
        add(a[t]);
      }
    }
  }
  clear();sav=0;f[k][n]=1ll<<60;
  add(a[n]);
  for (int t=n-1;t>=k-1;t--){
    f[k][n]=min(f[k][n],f[k-1][t]+sav);
    sav+=n-t-query(a[t]);
    add(a[t]);
  }printf("%lld",f[k][n]);
  return 0;
}

```

## #6~#10

首先你要知道决策单调性是个什么东西,可以看看[DP的决策单调性优化总结](https://www.luogu.org/blog/command-block/dp-di-jue-ce-dan-diao-xing-you-hua-zong-jie),或者上网自行百度。

使用50分的暴力把决策点输出一下,你会发现这东西有决策单调性。

感性理解就是 : $n$个东西逆序对期望$O(n^{2-e})$个,既然是平方那么肯定要分的尽量平均。

**证明**:

![](https://cdn.luogu.org/upload/image_hosting/993s23m7.png)

那么弄一个单调性分治就好了。

至于,$c()$的求法可以参照[CF868F Yet Another Minimization Problem](https://www.luogu.org/problem/CF868F)

就是类似于莫队那样暴力跳,复杂度是对的。

总复杂度$O(nklog^2n)$

```cpp
#include<algorithm>
#include<cstdio>
#define lowbit(x) ((x)&-(x))
#define MaxN 40500
using namespace std;
int n,k,a[MaxN],c[MaxN];
inline void _del(int pos)
{
  while(pos<=n)
    {--c[pos];pos+=lowbit(pos);}
}
inline void _add(int pos)
{
  while(pos<=n)
    {++c[pos];pos+=lowbit(pos);}
}
inline int _query(int pos)
{
  int sum=0;
  while(pos)
    {sum+=c[pos];pos^=lowbit(pos);}
  return sum;
}
int l=1,r;long long ans;
long long query(int tl,int tr)
{
  while(tl<l){
    ans+=r-l+1;
    ans-=_query(a[--l]);
    _add(a[l]);
  }
  while(r<tr){
    ans+=_query(a[++r]);
    _add(a[r]);
  }
  while(l<tl){
    _del(a[l]);
    ans+=_query(a[l++]);
    ans-=r-l+1;
  }
  while(tr<r){
    _del(a[r]);
    ans-=_query(a[r--]);
  }return ans;
}
int p[27][MaxN];
void solve(long long *f,long long *g,int *sp,int l,int r,int tl,int tr)
{
  int mid=(l+r)>>1,p;
  long long sav;
  f[mid]=1ll<<60;
  for (int i=tl;i<=min(tr,mid-1);i++){
  	sav=g[i]+query(i+1,mid);
  	if (sav<f[mid])
      { f[mid]=sav; p=i; }
  }sp[mid]=p;
  if (l<mid)solve(f,g,sp,l,mid-1,tl,p);
  if (mid<r)solve(f,g,sp,mid+1,r,p,tr);
}
long long f[27][MaxN];
int main()
{
  scanf("%d%d",&n,&k);
  for (int i=1;i<=n;i++)scanf("%d",&a[i]);
  for (int i=1;i<=n;i++){
    f[1][i]=f[1][i-1]+_query(a[i]);
    _add(a[i]);
  }for (int i=1;i<=n;i++)c[i]=0;
  for (int j=2;j<=k;j++)
    solve(f[j],f[j-1],p[j],j,n,j-1,n);
  printf("%lld",f[k][n]);
  return 0;
}

```

---

## 作者：qwaszx (赞：9)

好的套路题.学了一发分治决策单调性.

方程非常显然就是$f[i][j]=\min\limits_{0\leq k<j}\{f[i-1][k]+w(k+1,j)\}$，其中$f[i][j]$表示前$i$个$CPU$做前$j$个任务的最小答案，$w(i,j)$表示$[i,j]$的顺序对数.

直接做是$O(kn^2)$的.观察到$w$满足$w(i,j+1)+w(i+1,j)=w(i,j)+w(i+1,j+1)$，满足四边形不等式，从而这个东西可以决策单调性优化.但是这个$w$无法快速计算，所以考虑分治.

$solve(l,r,L,R)$表示用$[L,R]$转移$[l,r]$，然后设$mid=(l+r)/2$，找到它在$[L,R]$中最优的转移点$p$，那么根据决策单调性，$[mid+1,r]$这一段应该用$[p,R]$转移，$[l,mid-1]$这一段应该用$[L,p]$转移.于是就可以分治.对于$w$的计算，每次只扩展一个位置，树状数组即可.类似整体二分，一层的复杂度是$O(n\log n)$，一共分治$\log $层，一共需要求解$k$次，总复杂度$O(kn\log ^2 n)$

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=5e5;
int n,k,w[N],f[N],a[N],s,tl,tr,ff[N];
void ins(int x,int w){for(;x<=n;x+=x&-x)a[x]+=w;}
int query(int x){int ans=0;for(;x;x-=x&-x)ans+=a[x];return ans;}
void addl(int x){s+=query(w[x]);ins(w[x],1);}
void addr(int x){s+=tr-tl-query(w[x]);ins(w[x],1);}
void delr(int x){ins(w[x],-1);s-=tr-tl+1-query(w[x]);}
void dell(int x){ins(w[x],-1);s-=query(w[x]);}
void split(int l,int r)
{
    while(tr<r)addr(++tr);
    while(tl>l)addl(--tl);
    while(tr>r)delr(tr--);
    while(tl<l)dell(tl++);
}
void solve(int l,int r,int L,int R)
{
    int mid=(l+r)>>1;
    int p=mid;
    for(int i=min(mid-1,R);i>=L;i--)
    {
        split(i+1,mid);                                    
        if(ff[i]+s<=f[mid])f[mid]=ff[i]+s,p=i;
    }
    if(r>mid)solve(mid+1,r,p,R);
    if(l<mid)solve(l,mid-1,L,p);
}
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)scanf("%d",w+i),w[i]=n-w[i]+1,ff[i]=f[i]=1e9;
    tl=1,tr=0;for(int i=1;i<=k;i++){solve(1,n,0,n-1);for(int j=1;j<=n;j++)ff[j]=f[j];}
    printf("%d\n",f[n]);
}
```

---

## 作者：Neutralized (赞：6)

## $\text{Links}$
[$\text{Problem}$](https://www.luogu.com.cn/problem/P5574)  
[$\text{Record}$](https://www.luogu.com.cn/record/76907232)  
[$\text{Read This on Cnblogs}$](https://www.cnblogs.com/suitlie/p/16343661.html)
## $\text{Analysis}$

有一个朴素dp，语焉不详：  
$$f_{i,k}=min_{j=1}^{i}(f_{j-1,k-1}+calc(j,i))$$

大力转移， $O(n^4k)$ （大概），期望得分 $0$ .（  

考虑用 $\text{BIT}$ 维护值域求顺序对，再加上用莫队转移的方式求解区间答案，根据不会证明的性质均摊总复杂度是 $O(n^2k \log n)$ ，期望得分 $50$ .  

套上 $\text{wqs}$ 二分可以做到 $O(n^2 \log n \log k)$ ，但是没证过凸性，而且对于 $k \le 25$ 并无太大帮助。就当期望得分 $60$ 吧。  

转移方面好像比较优秀了，换个方向优化：  
这个式子比较斜率优化或者决策单调性，但是斜优感觉完全不可做，所以如果有决策单调性就可以解决了。
![](https://cdn.luogu.com.cn/upload/image_hosting/bjodamnb.png)  
如果 $k \gt j$ 且对于 $i$ ， $k$ 转移优于 $j$ ：  
由于 $f_{a,b}$ 第二维的 $b$ 对局面没有影响，暂时忽略；则
$$f_{k-1}+calc(k,i) \le f_{j-1}+calc(j,i)$$  
若转移目标右移到 $i+1$ ，则由于 $[k,i] \subseteq [j,i]$ ，有  
$$\Delta calc_k \le \Delta calc_j$$  
这就是说，增量同时也满足 $\le$ ，所以右移后 $k$ 依然不劣于 $j$ .  
这样就有决策单调性了，由于单个 $f_{i,k}$ 可以在 $O(n \log n)$ 时间通过上一层转移过来，所以考虑分治结构，每次计算 $f_{mid,k}$ 并记录最优决策点 $d_{mid}$ ，则 $[l,mid-1]$ 部分的决策区间为 $[d_l,d_{mid}]$ ， $[mid+1,r]$ 的决策区间为 $[d_{mid},d_r]$ .（这里的 $d_l$ 和 $d_r$ 为事先确定的决策点左右边界）分别递归进去即可。  
可以证明递归总层数为 $O(\log n)$ ，所以总复杂度 $O(nk \log^2 n)$ ，可以通过。  

## $\text{More}$

- 同样利用决策单调性进行分治的题目还有：  
1.[Yet Another Minimization Problem](https://www.luogu.com.cn/problem/CF868F)，直接开桶，转移和这题类似；  
2.[[IOI2014]holiday 假期](https://www.luogu.com.cn/problem/P5892)，用主席树进行转移，比较巧妙，可以一写.  

- 事实上这几道题的决策单调性证明比较类似，都是通过区间包含来获得增量的大小关系.  
如果证不出来，可以直接用暴力和决策单调性对拍验证. ~~虽然一般是感性理解~~  

- 可以尝试把 $\text{BIT}$ 换成单层 $\text{cdq}$ （没试过

## $\text{Code}$  

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <cmath>
using namespace std;

#define ri register int
#define ll long long

#define Neutral Shimokitazawa

#define Tp template<class T>
#ifdef Neutral
    const int End=1e6;
    char buf[End],*p1=buf,*p2=buf;
    #define g() (p1==p2&&(p2=(p1=buf)+fread(buf,1,End,stdin),p1==p2)?EOF:*p1++)
#else
    #define g() getchar()
#endif
#define pc(x) putchar(x)
#define isd(x) (x>=48&&x<=57)
namespace SlowIO{
    Tp inline void rd(T &x) {
        x=0; char i=g(); bool f=1;
        while(!isd(i)) f&=(i!='-'),i=g();
        while(isd(i)) x=(x<<3)+(x<<1)+(i^48),i=g();
        x*=((f<<1)-1);
    }
    const int OUT=1e6;
    static char outp[OUT]; int out;
    Tp inline void op(T x){
        out=0; x<0&&(x=-x,pc('-'));
        if(!x){ pc(48); return; }
        while(x) outp[++out]=x%10+48,x/=10;
        while(out) pc(outp[out--]);
    }
    Tp inline void writeln(T x){ op(x);pc('\n'); }
    Tp inline void writesp(T x){ op(x); pc(' '); }
    Tp inline void write(T x,char c=0){ op(x); c&&pc(c); }
}; using namespace SlowIO;

#define N 25001
int n,K,a[N],Mx;
struct BIT{
    ll tr[N]; int lim;
    #define lowbit(x) ((x)&(-x))
    inline void change(int x,int d){while(x<=lim)tr[x]+=d,x+=lowbit(x);}
    inline ll query(int x,ll ret=0){while(x)ret+=tr[x],x-=lowbit(x); return ret;}
}tr; //BIT ...
ll f[26][N];
int cl=1,cr=0; ll tmp;
inline void move(int l,int r){
    while(cl<l){tmp-=tr.query(tr.lim)-tr.query(a[cl]),tr.change(a[cl],-1),++cl;}
    while(cl>l){--cl,tmp+=tr.query(tr.lim)-tr.query(a[cl]),tr.change(a[cl],1);}
    while(cr>r){tmp-=tr.query(a[cr]-1),tr.change(a[cr],-1),--cr;}
    while(cr<r){++cr,tmp+=tr.query(a[cr]-1),tr.change(a[cr],1);}
} //移动两端点计算区间[l,r]答案
inline void solve(int k,int l,int r,int dl,int dr){
    if(l>r) return;
    ri mid=l+r>>1,upd=min(dr,mid),dm=dl;
    move(upd,mid); //移动到待求区间
    for(ri i=upd;i>=dl;--i){
        ll t=tmp+f[k-1][i-1]; //注意move到[i,mid]则从f[i-1]转移
        if(t<f[k][mid]) f[k][mid]=t,dm=i; //记录最优决策点
        if(i==dl) break; //do ...
        --cl,tmp+=tr.query(tr.lim)-tr.query(a[cl]),tr.change(a[cl],1); //把下一位扩进来
    } solve(k,l,mid-1,dl,dm),solve(k,mid+1,r,dm,dr);
}

int main()
{
    rd(n),rd(K);
    for(ri i=1;i<=n;++i)
        rd(a[i]),Mx=max(Mx,a[i]);
    tr.lim=Mx;
    for(ri i=2;i<=K;++i)
        for(ri j=1;j<=n;++j)
            f[i][j]=2147483600;
    for(ri i=1;i<=n;++i)
        f[1][i]=f[1][i-1]+tr.query(a[i]-1),
        tr.change(a[i],1);
    for(ri i=1;i<=n;++i) tr.change(a[i],-1); //记得清空第一层使用的BIT
    for(ri i=2;i<=K;++i) solve(i,1,n,1,n); //对每个k求一遍f[k][i]用于下次转移
    write(f[K][n]);
    return 0;
}
```

---

## 作者：yyandy (赞：5)

提供一个不一样的解法，这个解法没有用到 $k\le 25$ 的限制。

~~主要还是学 WQS 二分学魔怔了。~~

观察到区间顺序对数量满足

$w_{i,j+1}+w_{i+1,j} \le w_{i,j}+w_{i+1,j+1}$。

也就是满足四边形不等式。

根据这篇[博客](https://www.cnblogs.com/Itst/p/12805678.html)的证明可以知道这个答案是有凸性的。

故可以使用 WQS 二分进行优化。

WQS 二分之后，$k$ 的限制就已经被解除了。

我们要求的就是任意分段，但每分一段的贡献 $w'_{i,j}$ 是 $w_{i,j}$ 减去固定值的一个问题。

显然 $w'_{i,j}$ 仍然满足四边形不等式，于是这个 DP 就有决策单调性。

但是区间顺序对非常难以计算，所以考虑分治加上莫队再套上一个树状数组维护顺序对，来进行转移。

这个过程，其他题解都写得比较清楚了，我就不再赘述了。

这样，我们就能够从一个区间 $[l,r]$ 转移到另外一个区间 $[x,y]$。

为了让数列内所有可能进行转移的位置对都进行转移，需要在外层再套上一层 CDQ 分治。

首先解决左半边内部的转移，然后从左半边向右半边转移，最后初一右半边内部的转移，这样一直分治下去，可以发现所有可能转移的位置对都被转移了。

时间复杂度为 $O(n \log^4 n)$，但常数较小，卡常之后可以通过。

如果用分块预处理，可以做到 $O(n\sqrt{n}+n\log^3 n)$。

~~也许有更优秀的做法，但是既然能跑过，我就懒得想了~~。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
static struct node{
	int w,c;
	inline void operator += (const int T){
		w+=T;c++;
	}
	inline bool operator < (const node T)const{
		return w==T.w?c>T.c:w<T.w; 
	}
}F[25005];
int n,k,a[25005],Sum[25005],nowval;
int tot=0;
inline void add(int x){
	for(;x<=n;x+=x&-x)
		Sum[x]++;
}
inline void del(int x){
	for(;x<=n;x+=x&-x)
		Sum[x]--;
}
inline int query(int x){
	int ans=0;
	for(;x;x-=x&-x)
		ans+=Sum[x];
	return ans;
}
int v[25005][256];
int l=1,r=0,ans;
inline int rangeq(int x,int y){
	while(l>x)add(a[--l]),ans+=r-l+1-query(a[l]);
	while(r<y)add(a[++r]),ans+=query(a[r])-1;
	while(l<x)ans-=r-l+1-query(a[l]),del(a[l++]);
	while(r>y)ans-=query(a[r])-1,del(a[r--]);
	return ans;	
}
inline int calc(int x,int y){
	return (y-x<256)?(v[y][y-x]):(rangeq(x,y)); 
}
inline void Merge(int x,int y,int L,int R){
	if(x>y)return;
	int mid=L+R>>1,mi=x;
	node val=F[x];val+=(calc(x+1,mid)-nowval);
	for(int i=x+1;i<=y;++i){
		node tmp=F[i];tmp+=(calc(i+1,mid)-nowval);
		if(tmp<val)
			val=tmp,mi=i;
	}
	F[mid]=min(F[mid],val);
	if(L==R)return;
	Merge(x,mi,L,mid);
	Merge(mi,y,mid+1,R);
}
inline void CDQ(int x,int y){
	if(x==y)return;int mid=x+y>>1;
	CDQ(x,mid),Merge(x,mid,mid+1,y),CDQ(mid+1,y);
}
inline pair<int,int> check(int x){
	nowval=x;
	for(int i=1;i<=n;++i)
		F[i]=(node){1000000000,1};
	CDQ(0,n);
	return make_pair(F[n].w,F[n].c);
} 
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;++i)
		cin>>a[i];
	for(int i=1;i<=n;++i){
		for(int j=0;j<256&&i+j<=n;++j)
			v[j+i][j]=rangeq(i,i+j);
	}
	int L=-calc(1,n)-1,R=(k==1)?L:0,mn=1;
	pair<int,int> ans;
	while(L<=R){
		int mid=L+R>>1;
		auto C=check(mid);
		if(C.second==k){
			cout<<C.first+mid*k<<'\n';
			return 0;
		}
		if(C.second>=k){
			R=mid-1;
			if(mid<mn){
				mn=mid;
				ans=C;
			}
		}
		else L=mid+1;
	}
	cout<<ans.first+mn*k<<'\n';
}
```

---

## 作者：是个妹子啦 (赞：4)

将长度为$n$的排列划分成$K$段，每段顺序对个数和最小

方程类似于[邮局](https://www.luogu.com.cn/problem/P4767)的式子

$f[i][j]$表示前$i$个数分$j$段最小值，$w(i,j)$表示区间$[i,j]$的顺序对个数
$$
f[i][j]=\min_{0\le k<i}\{f[k][j-1]+w(k+1,j)\}
$$
不同的是邮局那道题可以直接预处理出$w$，而这题不太好搞

树状数组暴力跳的话，可以用莫队思想将答案推至相邻区间

$O(n^2k\log n)$   $50\%$ 好成绩

因为有$w(i,j+1)+w(i+1,j)< w(i,j)+w(i+1,j+1)$ 

(画个图可知,扔到数轴上，发现无论如何都是严格单调的，并且可以和暴力拍上)

$w$满足四边形不等式具有决策单调性

然后枚举$j$，设$g[i]$为$f[i][j]$的最优决策点，$f[i][j]=f[g[i]][j-1]+w[g[i]+1][i]$

同样有$g[i-1]\le g[i]$

根据单调性，并且$w$无法快速求得，考虑分治维护

$solve(l,r,L,R)$表示从$[L,R]$转移到$[l,r]$，令$mid=(l+r)/2$

暴力找到$mid$在$[L,R]$的决策点$x$，根据单调性，$[l,mid-1]$用$[L,x]$转移，$[mid+1,r]$这段区间用$[x,R]$转移，暴力跳树状数组均摊复杂度$n\log n$，一共分治$\log$层，求解$k$次，$O(nk\log^2n)$ 可过

```cpp
int f[N][26],a[N],c[N],n,K,sum,L,R,now;
inline int min(int a,int b){return a < b ? a : b;} 
void add(int k,int x){for(;k <= n;k += k&-k) c[k] += x;}
int query(int x){
	int res = 0;
	for(;x;x-=x&-x) res += c[x];
	return res;
}
void change(int l,int r){//暴力反复纵跳 
	while(L < l) sum -= query(a[L]-1),add(a[L++],-1);
	while(L > l) sum += query(a[L-1]-1),add(a[--L],1);
    while(R < r) sum += R-L+1 - query(a[R+1]),add(a[++R],1);
    while(R > r) sum -= R-L+1 - query(a[R]),add(a[R--],-1);
}
void solve(int l,int r,int L,int R){
	if(l > r)return;
    int mid = l + r >> 1,x = L;
    for(int i = L;i <= min(mid-1,R);i++){
        change(i+1,mid);
        int ans = f[i][now-1]+sum;
        if(ans < f[mid][now])
            f[mid][now] = ans,x = i;//寻找最优决策点
    }
    solve(l,mid-1,L,x); solve(mid+1,r,x,R);
} 
int main(){
	scanf("%d%d",&n,&K);
	for(int i = 1;i <= n;++i) scanf("%d",&a[i]),a[i] = n-a[i]+1;
	L = 1; /*左指针*/memset(f,0x3f,sizeof(f)); 
	for(int i = 1;i <= n;++i)
		change(1,i),f[i][1] = sum;
	for(now = 2;now <= K;++now)
		solve(1,n,1,n);
	printf("%d",f[n][K]);
}
```



---

## 作者：1saunoya (赞：4)

这不是 BZOJ 原题么，怎么就被搬过来出题了。

原题是 BZOJ 5125: [Lydsy1712月赛]小Q的书架,令 $a_i = n - a_i + 1$ 就可以通过此题。

[推销](https://www.cnblogs.com/Isaunoya/p/12625825.html)


显而易见的转移 $f_{i,j} = f_{i-1,k} + calc(k+1,j)$

$calc(i-1,j+1)+calc(i,j) \geq calc(i-1,j)+calc(i,j+1)$

所以具有决策单调性，然后随便搞搞就好了。

```cpp
// powered by c++11
// by Isaunoya
#include <bits/stdc++.h>

#define rep(i, x, y) for (register int i = (x); i <= (y); ++i)
#define Rep(i, x, y) for (register int i = (x); i >= (y); --i)

using namespace std;
using db = double;
using ll = long long;
using uint = unsigned int;
using ull = unsigned long long;

#define pii pair<int, int>
#define fir first
#define sec second

template <class T>

void cmax(T& x, const T& y) {
  if (x < y) x = y;
}

template <class T>

void cmin(T& x, const T& y) {
  if (x > y) x = y;
}

#define all(v) v.begin(), v.end()
#define sz(v) ((int)v.size())
#define pb emplace_back

template <class T>

void sort(vector<T>& v) {
  sort(all(v));
}

template <class T>

void reverse(vector<T>& v) {
  reverse(all(v));
}

template <class T>

void unique(vector<T>& v) {
  sort(all(v)), v.erase(unique(all(v)), v.end());
}

void reverse(string& s) { reverse(s.begin(), s.end()); }

const int io_size = 1 << 23 | 233;
const int io_limit = 1 << 22;
struct io_in {
  char ch;
#ifndef __WIN64
  char getchar() {
    static char buf[io_size], *p1 = buf, *p2 = buf;

    return (p1 == p2) && (p2 = (p1 = buf) + fread(buf, 1, io_size, stdin), p1 == p2) ? EOF : *p1++;
  }
#endif
  io_in& operator>>(char& c) {
    for (c = getchar(); isspace(c); c = getchar())
      ;

    return *this;
  }
  io_in& operator>>(string& s) {
    for (s.clear(); isspace(ch = getchar());)
      ;

    if (!~ch) return *this;

    for (s = ch; !isspace(ch = getchar()) && ~ch; s += ch)
      ;

    return *this;
  }

  io_in& operator>>(char* str) {
    char* cur = str;
    while (*cur) *cur++ = 0;

    for (cur = str; isspace(ch = getchar());)
      ;
    if (!~ch) return *this;

    for (*cur = ch; !isspace(ch = getchar()) && ~ch; *++cur = ch)
      ;

    return *++cur = 0, *this;
  }

  template <class T>

  void read(T& x) {
    bool f = 0;
    while ((ch = getchar()) < 48 && ~ch) f ^= (ch == 45);

    x = ~ch ? (ch ^ 48) : 0;
    while ((ch = getchar()) > 47) x = x * 10 + (ch ^ 48);
    x = f ? -x : x;
  }

  io_in& operator>>(int& x) { return read(x), *this; }

  io_in& operator>>(ll& x) { return read(x), *this; }

  io_in& operator>>(uint& x) { return read(x), *this; }

  io_in& operator>>(ull& x) { return read(x), *this; }

  io_in& operator>>(db& x) {
    read(x);
    bool f = x < 0;
    x = f ? -x : x;
    if (ch ^ '.') return *this;

    double d = 0.1;
    while ((ch = getchar()) > 47) x += d * (ch ^ 48), d *= .1;
    return x = f ? -x : x, *this;
  }
} in;

struct io_out {
  char buf[io_size], *s = buf;
  int pw[233], st[233];

  io_out() {
    set(7);
    rep(i, pw[0] = 1, 9) pw[i] = pw[i - 1] * 10;
  }

  ~io_out() { flush(); }

  void io_chk() {
    if (s - buf > io_limit) flush();
  }

  void flush() { fwrite(buf, 1, s - buf, stdout), fflush(stdout), s = buf; }

  io_out& operator<<(char c) { return *s++ = c, *this; }

  io_out& operator<<(string str) {
    for (char c : str) *s++ = c;
    return io_chk(), *this;
  }

  io_out& operator<<(char* str) {
    char* cur = str;
    while (*cur) *s++ = *cur++;
    return io_chk(), *this;
  }

  template <class T>

  void write(T x) {
    if (x < 0) *s++ = '-', x = -x;

    do {
      st[++st[0]] = x % 10, x /= 10;
    } while (x);

    while (st[0]) *s++ = st[st[0]--] ^ 48;
  }

  io_out& operator<<(int x) { return write(x), io_chk(), *this; }

  io_out& operator<<(ll x) { return write(x), io_chk(), *this; }

  io_out& operator<<(uint x) { return write(x), io_chk(), *this; }

  io_out& operator<<(ull x) { return write(x), io_chk(), *this; }

  int len, lft, rig;

  void set(int _length) { len = _length; }

  io_out& operator<<(db x) {
    bool f = x < 0;
    x = f ? -x : x, lft = x, rig = 1. * (x - lft) * pw[len];
    return write(f ? -lft : lft), *s++ = '.', write(rig), io_chk(), *this;
  }
} out;
#define int long long

template <int sz, int mod>

struct math_t {
  math_t() {
    fac.resize(sz + 1), ifac.resize(sz + 1);
    rep(i, fac[0] = 1, sz) fac[i] = fac[i - 1] * i % mod;

    ifac[sz] = inv(fac[sz]);
    Rep(i, sz - 1, 0) ifac[i] = ifac[i + 1] * (i + 1) % mod;
  }

  vector<int> fac, ifac;

  int qpow(int x, int y) {
    int ans = 1;
    for (; y; y >>= 1, x = x * x % mod)
      if (y & 1) ans = ans * x % mod;
    return ans;
  }

  int inv(int x) { return qpow(x, mod - 2); }

  int C(int n, int m) {
    if (n < 0 || m < 0 || n < m) return 0;
    return fac[n] * ifac[m] % mod * ifac[n - m] % mod;
  }
};

int gcd(int x, int y) { return !y ? x : gcd(y, x % y); }
int lcm(int x, int y) { return x * y / gcd(x, y); }

template <int maxn>
struct BIT {
  int c[maxn];
  int low(int x) { return x & -x; }
  void add(int x, int y) {
    for (; x < maxn; x += low(x)) c[x] += y;
  }
  int qry(int x) {
    int ans = 0;
    for (; x; x ^= low(x)) ans += c[x];
    return ans;
  }
};

int n, k;
const int maxn = 4e4 + 44;
BIT<maxn> bit;
int a[maxn], f[maxn], g[maxn];

int l, r, ans = 0;
void modify(int ql, int qr) {
  while (l < ql) {
    bit.add(a[l], -1);
    ans -= bit.qry(a[l++] - 1);
  }
  while (l > ql) {
    bit.add(a[--l], 1);
    ans += bit.qry(a[l] - 1);
  }
  while (r < qr) {
    bit.add(a[++r], 1);
    ans += bit.qry(n) - bit.qry(a[r]);
  }
  while (r > qr) {
    bit.add(a[r], -1);
    ans -= bit.qry(n) - bit.qry(a[r--]);
  }
}

void solve(int l, int r, int L, int R) {
  if (l > r) return;
  int mid = l + r >> 1, p = mid;
  for (int i = min(mid - 1, R); i >= L; --i) {
    modify(i + 1, mid);
    if (g[i] + ans < f[mid]) f[mid] = g[i] + ans, p = i;
  }
  solve(l, mid - 1, L, p);
  solve(mid + 1, r, p, R);
}

signed main() {
  in >> n >> k;
  rep(i, 1, n) in >> a[i];
  rep(i, 1, n) a[i] = n - a[i] + 1;
  l = 1, r = 0;
  rep(i, 1, n) { modify(1, i), f[i] = ans; }
  rep(i, 2, k) {
    rep(j , 1 , n) g[j] = f[j];
    rep(j , 1 , n) f[j] = 1e18;
    solve(1, n, 1, n);
  }
  out << f[n] << '\n';
  return 0;
}
```

---

## 作者：forest114514 (赞：3)

首先大家都知道了 $O(nk\log^2 n)$ 的做法吧，就是决策单调性分治+类莫队移动指针计算贡献，这是一个很优秀的做法，但是在 $k$ 很大的时候这个做法就寄了。然后 $k$ 很大的时候众所周知的是这个东西可以 wqs 二分优化，但是此时形如 $f_{i}=\min \limits_{j<i}f_{j}+w(j,i)$ 的 DP 又不能直接决策单调性做，除非套个 cdq 多个 $\log n$，二分队列的话又不能快速计算 $w(j,i)$，区间顺序对只能 $O(\sqrt n)$ 单次询问，这样太慢了。

但是在阅读完 APIO2021 Itst 大神的课件之后我们有一种可以由冷门科技 Wilber 算法改造的小清新做法。~~（其实就是把 SMAWK 换成了小清新决策单调性分治）~~

具体地，首先用 $[c,r]$ 一段作为决策点估计 $[r+1,\min(n,r+(r+c-1))]$ 的答案，得到的数组记为 $g$，显然所有满足决策点在 $[r,c]$ 之间的位置 $g$ 就是最优解了。然后再用 $[r+1,\min(n,r+(r+c-1))]$ 一段的 $g$ 去估计这一段的答案，得到的数组 $h$。然后将 $h$ 和 $g$ 对应位置两两比对得到第一个 $h$ 比 $g$ 优的位置 $t$，显然 $[r+1,t-1]$ 位置的 $g$ 数组是最优解，这里得到的 $h_{t}$ 也是最优解，这样可以得到 $t$ 是第一个决策点 $>r$ 的点，显然此时已经算完 $[r+1,t]$ 的答案，直接把 $[c,r]$ 点对改为 $[r+1,t]$ 继续做下去即可。（特殊的，如果 $t$ 不存在就直接把 $r$ 改成 $\min(n,r+(r+c-1))$ 即可）。

放一下本题这个部分的代码 ~~（是不是非常小清新）~~：

```cpp
void divide(int l,int r,int L,int R,const int &_mid){//决策单调性分治
	if(l>r) return;
	int mid=l+r>>1,p=L;
	F[mid]=(NODE){G[L].val+w(L+1,mid)+_mid,G[L].ch+1};
	rep(i,L+1,min(mid-1,R)){
		delL(cl++);//卡常
		NODE tmp=(NODE){G[i].val+val+_mid,G[i].ch+1};
		if(tmp<F[mid]) F[mid]=tmp,p=i;
	}
	divide(l,mid-1,L,p,_mid);
	divide(mid+1,r,p,R,_mid);
}
int Wilber(int mid){
	int r=0,c=0;
	cl=1,cr=0,TR.tt=0,memset(TR.c,0,sizeof TR.c);
	while(r<n){
		int ri=min(n,r+r-c+1);
		F=g,G=f,divide(r+1,ri,c,r,mid);//第一部分：用f估计得到g
		F=h,G=g,divide(r+2,ri,r+1,ri,mid);//第二部分：用g估计得到h
		int t=r+2;f[r+1]=g[r+1];
		while(t<=ri&&g[t]<h[t]) f[t]=g[t],++t;//找到第一个h比j优的t
		if(t>ri) r=ri;//t不存在，[c,r]->[c,ri]
		else f[t]=h[t],c=r+1,r=t;//t存在，[c,r]->[r+1,t]
	}
	return f[n].ch;
}
```

注意到花费了 $O(1)$ 的次数要么让 $r$ 和 $r-c+1$ 都增大了 $O(1)$，要么让 $r-c+1$ 减少 $O(1)$，所以总长均摊是 $O(n)$的，所以一轮的时间就是 $O(n\log nP)$ （$P$ 是莫队指针移动的复杂度）的，本题一轮就是 $O(n\log^2 n)$ 的。

然后就直接套上 wqs 二分，时间复杂度 $O(n\log^2 n\log V)$，但是 Wilber 因为每次要做两次决策单调性分治的原因常数大到爆炸，卡了卡常才勉强卡进 1s。

提一句这里可以用序列分块套值域分块做到 $O(n\sqrt n)$ 的预处理，$O(1)$ 回答区间有几个数 $>/<$ 自己，然后做到 $O(n\sqrt n+n\log n\log V)$，但是常数过大而且空间 $O(n\sqrt n)$ 估计表现不是很良好。

code（注意值域上界不是 $10^8$，这里只是卡常才开这么多）：

```cpp
const int N=25500;
int n,k,a[N];
struct BIT{
	int c[N],tt;
	#define lowbit(x) (x&(-x))
	void update(int u,int x){tt+=x;for(;u<=n;u+=lowbit(u)) c[u]+=x;}
	int query(int u){int res=0;for(;u;u-=lowbit(u)) res+=c[u];return res;}
}TR;
int cl,cr;
LL val;
void delR(int i){val-=TR.query(a[i]-1),TR.update(a[i],-1);}
void addR(int i){val+=TR.query(a[i]-1),TR.update(a[i],1);}
void delL(int i){val-=TR.tt-TR.query(a[i]),TR.update(a[i],-1);}
void addL(int i){val+=TR.tt-TR.query(a[i]),TR.update(a[i],1);}
LL w(int l,int r){	
	while(cr>r) delR(cr--);
	while(cl<l) delL(cl++);
	while(cr<r) addR(++cr);
	while(cl>l) addL(--cl);
	return val;
}
struct NODE{
	LL val;int ch;
	bool operator <(const NODE &T)const{
		return val==T.val?ch>T.ch:val<T.val;
	}
}f[N],g[N],h[N],*F,*G;
void divide(int l,int r,int L,int R,const int &_mid){
	if(l>r) return;
	int mid=l+r>>1,p=L;
	F[mid]=(NODE){G[L].val+w(L+1,mid)+_mid,G[L].ch+1};
	rep(i,L+1,min(mid-1,R)){
		delL(cl++);
		NODE tmp=(NODE){G[i].val+val+_mid,G[i].ch+1};
		if(tmp<F[mid]) F[mid]=tmp,p=i;
	}
	divide(l,mid-1,L,p,_mid);
	divide(mid+1,r,p,R,_mid);
}
int Wilber(int mid){
	int r=0,c=0;
	cl=1,cr=0,TR.tt=0,memset(TR.c,0,sizeof TR.c);
	while(r<n){
		int ri=min(n,r+r-c+1);
		F=g,G=f,divide(r+1,ri,c,r,mid);
		F=h,G=g,divide(r+2,ri,r+1,ri,mid);
		int t=r+2;f[r+1]=g[r+1];
		while(t<=ri&&g[t]<h[t]) f[t]=g[t],++t;
		if(t>ri) r=ri;
		else f[t]=h[t],c=r+1,r=t;
	}
	return f[n].ch;
}
LL wqs(){
	int l=0,r=1e8,ans;
	while(l<=r){
		int mid=l+r>>1;
		if(Wilber(mid)>=k) ans=mid,l=mid+1;
		else r=mid-1;
	}
	Wilber(ans);
	return f[n].val-1ll*ans*k;
}
```

---

## 作者：MortisM (赞：1)

[P5574 [CmdOI2019]任务分配问题](https://www.luogu.com.cn/problem/P5574)

一道非常不错的套路 DP 题。前置知识：[**决策单调性优化 DP**](https://www.luogu.com.cn/blog/Jerry-Jiang/jue-ce-dan-diao-xing-you-hua-dp-xue-xi-bi-ji)

**简明题意**：给定一个长度为 $n$ 的序列 $\{a_n\}$，要将其划分成 $k$ 段，每段必须连续，最小化每段顺序对之和。

$1\le n\le 25000,1\le k\le 25$。

前三个点都是送的。第 1、2 个点直接用树状数组求顺序对即可，时间复杂度 $\mathcal{O}(n\log n)$。第 3 个点暴力枚举分割线然后发现需要先预处理出前后缀的顺序对个数，时间复杂度 $\mathcal{O}(n\log n)$。期望得 $30$ 分。

设 $f_{i,j}$ 表示前 $i$ 个数划分成 $j$ 段的最小答案。容易列出转移方程：

$$
f_{i,j}=\min_{l=1}^{i-1}f_{l,j-1}+w(l+1,i)
$$

其中 $w(l,r)$ 表示 $a[l\sim r]$ 的顺序对个数。先预处理出 $w$，这个用树状数组可以做到 $\mathcal{O}(n^2\log n)$。总时间复杂度 $\mathcal{O}(n^2k+n^2\log n)$。期望得 $50$ 分。

这个式子长得一脸 **决策单调性优化** 的样子，我们尝试证明 $w$ 满足 **四边形不等式**。

考虑证明 $w(a,b)+w(a+1,b+1)\leq w(a+1,b)+w(a,b+1)$。发现四项都包含 $w(a,b)$ 就把四项都减去 $w(a,b)$。得到 $-w(a\to a+1\sim b)+w(a\sim b\to b+1)$ 和 $-w(a\to a+1\sim b)+w(a\sim b\to b+1)$。其中 $w(x\to y)$ 表示 $x$ 在前 $y$ 在后能组成多少个顺序对。发现竟然一模一样，那么我们就证明了 $w(a+b)+w(a+1,b+1)=w(a+1,b)+w(a,b+1)$。也就是说对于 $a\leq b\leq c\leq d$，都有 $w(a,d)+w(b,c)=w(a,c)+w(b,d)$。

然后有了这个就可以 **分治** 解决了，后面都是板子，不再赘述了。

还有一个问题是如何求出 $w(l,r)$。正确的解法是像莫队一样跳，并用树状数组像之前一样维护值域。下面来说明这个算法时间复杂度的正确性。

首先，对于一次分治 $[l,r,L,R]$，枚举所有 $l\sim \min(m-1,R)$ 是 $\mathcal{O}(n\log n)$ 的，共分治 $\mathcal{O}(\log n)$ 层。

于是我们得到了一个 $\mathcal{O}(nk\log^2 n)$ 的正确做法。

[代码](https://www.luogu.com.cn/paste/1dq74stl)。[评测记录](https://www.luogu.com.cn/record/95025903)。

---

## 作者：QQ82272760 (赞：1)

很容易想到动态规划。

令 $f[k][i]$ 表示已经放了 $k$ 个 CPU，且最后一个 CPU 负责的任务右端点为 $i$ 的最小无序度。

那么有转移

$$
f[k][i]=\min_{j\le i}\left\{f[k-1][j]+w(j+1,i)\right\}
$$

其中 $w(l,r)$ 表示闭区间内的无序度。

假设有 $q<p\le j<i$，并且 $f[k][j]=f[k-1][p]+w(p+1,j)$，即 $f[k][i]$ 由 $f[k-1][p]$ 转移过来，那么

$$
\begin{aligned}
f[k-1][p]+w(p+1,j)&\le f[k-1][q]+w(q+1,j)\\
w(p+1,j)-w(q+1,j)&\le f[k-1][q]-f[k-1][p]
\end{aligned}
$$

考虑在右边新增若干个数的贡献，不难发现 $w(p+1,j)-w(q+1,j)\ge w(p+1,i)-w(q+1,i)$，因此

$$
\begin{aligned}
w(p+1,i)-w(q+1,i)&\le f[k-1][q]-f[k-1][p]\\
f[k-1][p]+w(p+1,i)&\le f[k-1][q]+w(q+1,i)
\end{aligned}
$$

也就是说，**转移具有决策单调性**。

然后就可以每次用分治的方法转移了。用类似莫队的方法维护 $w(l,r)$ 。

问题变为值域前缀（后缀同理）和。显然可以用树状数组维护，这样子的复杂度是 $\mathcal O(kn\log^2 n)$ 的，看起来就很慢。

其实可以用**可持久化块状数组**的方法做到 $\mathcal O(n\sqrt n)$ 预处理，然后 $\mathcal O(1)$ 查询区间内小于等于某个数的个数。

预处理时，考虑加入一个数，只要对当前块的一个后缀以及后面所有块进行修改。可持久化的方式和主席树不太一样，需要对当前修改的散块建立一个真实存在的整块，它指向若干散块，其它整块指向最后真实存在的整块。

具体细节请看代码（其实我维护的是后缀和，而且这是我第一次打这玩意，打得比较难看）。

最后的复杂度是 $\mathcal O(n\sqrt n+kn\log n)$。

看起来快了不少，但真正打出来的跑得很慢……

```cpp
#include<iostream>
#include<cstdio>
#define inf 1145141919
using namespace std;
const int N=25000,B=160,M=8000000;
int n;
int a[N+5];
int f[26][N+5];
int id[N+5],L[N/B+5],R[N/B+5];
int lf1[M+5],v1[M+5],to1[M+5];
int cnt1,lst1[B+5],num1[N+5][N/B+5];
int pl=1,pr,res;
void insert1(int k,int x){
	int now;
	for(int i=1;i<=id[n];i+=1){
		num1[k][i]=++cnt1;
		if(R[i]<=x){
			v1[cnt1]=v1[lst1[i]]+1;
			to1[cnt1]=to1[lst1[i]];
			lst1[i]=cnt1;
		}
		if(L[i]<=x&&x<R[i]){
			v1[cnt1]=v1[lst1[i]];
			lf1[now=cnt1]=cnt1+1;
			for(int j=L[i];j<=R[i];j+=1){
				if(to1[lst1[i]]) v1[++cnt1]=v1[lf1[to1[lst1[i]]]+j-L[i]];
				else v1[++cnt1]=0;
				if(j<=x) v1[cnt1]+=1;
			}
			lst1[i]=now; to1[now]=now;
		}
		if(x<L[i]){
			v1[cnt1]=v1[lst1[i]];
			to1[cnt1]=to1[lst1[i]];
			lst1[i]=cnt1;
		}
	}
	return;
}
int query1(int k,int x){
	k=num1[k][id[x]];
	int res=v1[k];
	k=to1[k];
	if(k) res+=v1[lf1[k]+x-L[id[x]]];
	return res;
}
void init(){
	for(int i=1;i<=n;i+=1){
		id[i]=(i-1)/B+1;
		if(i%B==1) L[id[i]]=i;
		R[id[i]]=max(R[id[i]],i);
	}
	for(int i=1;i<=n;i+=1) insert1(i,a[i]);
	return;
}
int calc1(int x,int l,int r){
	if(l>r) return 0;
	return query1(r,x)-query1(l-1,x);
}
int calc2(int x,int l,int r){
	if(l>r) return 0;
	return (query1(r,1)-query1(l-1,1))-(query1(r,x+1)-query1(l-1,x+1));
}
void move(int l,int r){
	while(pr<r) res+=calc2(a[pr+1],pl,pr),pr+=1;
	while(pr>r) pr-=1,res-=calc2(a[pr+1],pl,pr);
	while(pl>l) res+=calc1(a[pl-1],pl,pr),pl-=1;
	while(pl<l) pl+=1,res-=calc1(a[pl-1],pl,pr);
	return;
}
void solve(int k,int l,int r,int L,int R){
	if(l>r) return;
	int mid=l+r>>1,ans=inf,id=0;
	for(int i=min(mid-1,R);i>=L;i-=1){
		move(i+1,mid);
		if(res+f[k-1][i]<ans) ans=res+f[k-1][i],id=i;
	}
	f[k][mid]=ans;
	solve(k,l,mid-1,L,id); solve(k,mid+1,r,id,R);
	return;
}
int main(){
	int k;
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i+=1) scanf("%d",&a[i]);
	init();
	for(int i=1;i<=n;i+=1) f[0][i]=inf;
	for(int i=1;i<=k;i+=1) solve(i,1,n,0,n);
	printf("%d\n",f[k][n]);
	return 0;
}
```

Thanks~

---

## 作者：LCuter (赞：1)

### 题目大意

给定一个长度为 $n$ 的排列 $p$，将 $p$ 按照原顺序划分成 $k$ 段，使每一段的顺序对个数和最小。$n\le 25000,k\le 25$

### 动态转移方程

转移方程

$$F_{i,j}=\min_{0\le k<i}\{F_{k,j-1}+w(k+1,i)\}$$

其中，$F_{i,j}$ 表示将前 $i$ 个数分为 $j$ 段时每一段顺序对个数和的最小值，$w(i,j)$ 表示区间 $[i,j]$ 内的顺序对个数。这么做是 $O(n^2k)$ 的。

### 优化

我们发现，$w(i,j)$ 是满足四边形不等式的，所以该转移方程满足决策单调性。但是 $w(i,j)$ 不是很好算，而且 $n$ 是比较大的，这么一来就不能使用常规做法。

不过我们发现 $k$ 比较小，而且 $j$ 只会从 $j-1$ 转移而来，所以我们可以考虑做相同的转移 $k$ 次。现在我们将问题转换为了，用上一次的结果 $[0,n-1]$ 去转移这一次的 $[1,n]$。

这边我们要介绍一个全新的东西，它叫做决策单调性分治。由于决策单调性，当前所求的一段连续的区间(就是状态转移方程中 $i$ 那一维的下标)一定是从上一次所求的一段连续的区间转移而来的。我们记 $Solve(l,r,L,R)$ 表示用 $[L,R]$ 这一段上一次所求的连续的区间可以转移至 $[l,r]$ 这一段当前所求的的连续的区间。我们取 $[l,r]$ 的中点 $mid$，然后找到 $mid$ 的最优决策点 $p$(这里当然就算出了动态转移方程中 $mid$ 处的取值)，那么 $[l,mid-1]$ 只可能从 $[L,p]$ 转移而来，$[mid+1,r]$ 只可能从 $[p,R]$ 转移而来，这一步可以由决策单调性得出。于是如此递归分治下去，显然边界就是 $l=r$，不过这里不用特判，因为找 $mid$ 的最优决策点时已经算出动态转移方程 $mid$ 处的取值，而此时 $l=mid$。

注意到算法过程中计算 $w(i,j)$ 都是扩展一格左边界，那么计算 $w(i,j)$ 可以使用类似莫队的思想，用树状数组维护即可。每一层分治的时间复杂度为 $O(n\log n)$，一共分治 $O(\log n)$ 层，这样的分治进行 $k$ 次，故总时间复杂度为 $O(nk\log^2 n)$。

### Code

```cpp
// lst[]=>上一次求出的答案，now[]=>当前求的
void Solve(int l,int r,int L,int R){//如上文所述
    int mid=(l+r)>>1,p=mid;
    for(REG int i=L;i<=Min(mid-1,R);++i){
        int ans=w(i+1,mid);
        if(lst[i]+ans<=now[mid]) now[mid]=lst[i]+ans,p=i;
    }
    if(l<mid) Solve(l,mid-1,L,p);
    if(r>mid) Solve(mid+1,r,p,R);
}

int Work(){
    for(REG int i=1;i<=n;++i) lst[i]=now[i]=0x7f7f7f7f;
    for(REG int i=1;i<=k;++i){
        Sovle(1,n,0,n-1);//从[0,n-1]转移至[1,n]
        for(REG int j=1;j<=n;++j) lst[j]=now[j];
    }
    return now[n];
}
```



---

## 作者：hegm (赞：0)

### [[CmdOI2019]任务分配问题](https://www.luogu.com.cn/problem/P5574)

dp 式子应该很好想。

$f_{i,j}$ 表示前 $i$ 个任务，分配给了 $j$ 个 CPU 的最小无序度之和。

容易发现 $f_{i,j}$ 只和 $f_{1\sim i,j}$ 有关系，也就是说第二维相同的互不影响，同时题目又具有决策单调性。

所以考虑使用分治法来优化转移。

每次将 $j$ 相同的 $dp$ 同时进行转移，对于当前的 $l\sim r$ 考虑将 $mid$ 位置的决策点暴力找出来，那么同层复杂度共为 $O(n)$，然后将 $l\sim r$ 分为 $l\sim mid,mid+1\sim r$ 决策点改为 $pl\sim p,p\sim pr$。

利用指针的特殊性质，在这个过程中跑指针会移动 $O(n)$（单层）。维护顺序对直接用树状数组就好。

### $\text{CDOE}$
```cpp
#include<bits/stdc++.h>
#define N 135000
#define int long long
using namespace std;
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n,m,a[N],num,dp[N][61],L,R,tot,tr[N];
int lowbit(int x){return x&(-x);}
void insert(int x,int w)
{
	while(x<=n)
	{
		tr[x]+=w;
		x+=lowbit(x);
	}
}
int que(int x)
{
	int ans=0;
	while(x)
	{
		ans+=tr[x];
		x-=lowbit(x);
	}
	return ans;
}
void addl(int x)
{
	x=a[x];
	insert(x,1);
	tot+=que(n)-que(x);
}
void dell(int x)
{
	x=a[x];
	insert(x,-1);
	tot-=que(n)-que(x);
}
void addr(int x)
{
	x=a[x];
	insert(x,1);
	tot+=que(x-1);
}
void delr(int x)
{
	x=a[x];
	insert(x,-1);
	tot-=que(x-1);
}
int calc(int l,int r)
{
	while(L>l)addl(--L);
	while(R<r)addr(++R);
	while(L<l)dell(L++);
	while(R>r)delr(R--);
	return tot;
}
void solve(int pl,int pr,int l,int r)
{
	if(pl>pr||l>r)return ;
	int mid=(l+r)>>1,ans=1e18,d=0;
	for(int i=pl,res,con=min(mid-1,pr);i<=con;i++)
	{
		res=calc(i+1,mid);
		if(ans>dp[i][num-1]+res)ans=dp[i][num-1]+res,d=i;
	}
	dp[mid][num]=ans;
	solve(pl,d,l,mid-1);solve(d,pr,mid+1,r);
}
signed main()
{
	memset(dp,0x3f,sizeof(dp));
	dp[0][0]=0;
	n=read();m=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=m;i++)
	{
		num=i;L=R=1;tot=0;
		memset(tr,0,sizeof(tr));
		insert(a[1],1);
		solve(0,n-1,1,n);
	}
	cout<<dp[n][m]<<"\n";
	return 0;
}
```

---

## 作者：_lxy_ (赞：0)

[博客食用效果更佳](https://www.cnblogs.com/lxy-2022/p/P5574-Solution.html)
#### 分析

发现题目中的无序度相当于是区间内的逆序对数，设 $cal(l,r)$ 为 $[l,r]$ 的代价，$dp_i$ 为最后一段末端为 $i$ 时最小的总代价，转移方程就呼之欲出了：
$$
dp_i=\min\limits_{j=1}^{i-1}\{f_j+cal(i,j)\}
$$
，其中 $f_j$ 表示上一层 $j$ 的 dp 值。容易猜出它满足决策单调性，于是可以用分治优化。而 $cal$ 函数也可以快速从相邻的推出，用树状数组维护每个值出现的次数，支持单点加、区间求和操作，就可以方便的加入一个新数，并求逆序对个数。dp $m-1$ 次，每次从上一次的结果转移即可。

#### 核心代码

```cpp
int n,m,a[MAXN],tr[MAXN],res,L=1,R,dp[MAXN],f[MAXN];
inline int lowbit(int x){return x&(-x);}
void add(int x,int c){for(;x<=n;x+=lowbit(x)) tr[x]+=c;}
int que(int x){int res=0;for(;x>0;x-=lowbit(x)) res+=tr[x];return res;}
int cal(int l,int r){
    while(l<L) L--,res+=que(n)-que(a[L]),add(a[L],1);
    while(r>R) R++,res+=que(a[R]-1),add(a[R],1);
    while(l>L) res-=que(n)-que(a[L]),add(a[L],-1),L++;
    while(r<R) res-=que(a[R]-1),add(a[R],-1),R--;return res;
}
void solve(int l,int r,int pl,int pr){
    if(l>r) return;
    int p=0,mid=(l+r)>>1;dp[mid]=inf;
    for(int i=pl;i<=qmin(pr,mid-1);i++)
        if(f[i]+cal(i+1,mid)<dp[mid]) dp[mid]=f[i]+cal(i+1,mid),p=i;
    solve(l,mid-1,pl,p);solve(mid+1,r,p,pr);
}
signed main(){
    qread(n,m);int i,j;for(i=1;i<=n;i++) qread(a[i]);
    for(i=1;i<=n;i++) dp[i]=f[i]=cal(1,i);m--;
    while(m--){
        solve(1,n,0,n-1);
        for(i=1;i<=n;i++) f[i]=dp[i];
    }printf("%lld\n",dp[n]);
    return 0;
}
```


---


# 好吃的题目

## 题目背景

这是一道好吃的题目。

## 题目描述

有一条小吃街，从左到右依次排列着 $n$ 个商店，从 $1$ 开始标号。

第 $i$ 个商店会只出售一种小吃，热量为 $h_i$，美味度为 $w_i$。

现在有 $m$ 个吃货要来逛街，第 $i$ 个吃货会在 $[l_i,r_i]$ 的商店内寻找小吃，而且为了防止太胖，最多能摄入 $t_i$ 的热量。

小吃吃多了会腻，所以同一个商店的小吃只能吃一次。

现在每个吃货想知道自己最多能得到多少美味度。

## 说明/提示

#### 【样例输入输出解释】

**样例 1 解释**

对于第一组数据的第一个吃货，可以选择第 $3$ 个商店和第 $5$ 个商店。

摄入的热量为 $36+36=72\leq 81$，获得美味度为 $284+282=566$。

**样例 2 解释**

对于第二组数据的第一个吃货，可以选择第 $10$，第 $13$，第 $15$ 个商店。

摄入的热量为 $15+9+6=30\leq 31$，获得美味度为 $34+21+11=66$。

---

#### 【数据规模与约定】

- 对于 $30\%$ 的数据，满足 $n,m\leq 500$。
- 对于 $60\%$ 的数据，满足 $n\leq 4\times 10^4$，$m\leq 5000$。
- 对于 $100\%$ 的数据，满足 $1 \leq n\leq 4\times 10^4$，$1 \leq m\leq 2\times 10^5$，$1\leq l_i\leq r_i\leq n$，$1\leq h_i,t_i\leq 200$，$1\leq w_i\leq 10^7$。






## 样例 #1

### 输入

```
8 5
10 31 36 30 36 24 29 29
59 152 284 202 282 156 277 212
3 5 81
4 5 75
7 8 71
1 3 92
4 4 95
```

### 输出

```
566
484
489
495
202```

## 样例 #2

### 输入

```
15 10
5 15 18 15 18 12 14 14 10 15 17 18 9 7 6 
11 31 26 34 19 17 15 25 11 34 18 26 21 8 11 
7 15 31
2 9 67
8 15 77
3 13 43
6 7 98
2 2 110
3 13 26
11 11 84
7 14 25
4 6 90```

### 输出

```
66
118
128
89
32
31
55
18
55
70```

# 题解

## 作者：command_block (赞：22)

鉴于写博客的时候,没有简单的例题,于是就给你谷造了个这样的水题。

**题意** : 区间01背包问题

更多信息可见 [一些常用的数据结构维护手法](https://www.luogu.com.cn/blog/command-block/yi-suo-chang-yong-di-shuo-ju-jie-gou-wei-hu-shou-fa)

## 一些背包基础知识

这题的背包是**最优化**01背包。设$F[i]$表示容量为$i$时的最大总收益。

设背包大小为$t$,每次加入一个物品,复杂度是$O(t)$的。合并两个背包,复杂度是$O(t^2)$的。

假如已有两个背包$F1[],F2[]$,查询**合并后**容量$s$所对应的收益,我们不必真的合并这两个背包。

计算 $\max\limits_{i=0}^sF1[i]+F2[s-i]$ 即可。这样仅需$O(t)$.

注意到背包实质上是$\{\max,+\}$卷积就很容易(bushi)理解了。

综上,由于本题$t\leq 200$,我们要避免$O(t^2)$的合并背包才行。

## 猫树分治·引入

考虑某种奇怪的**静态序列**问题,我们并不会做。

但是,如果所有询问的**区间有交集**,那么我们就能通过下列算法得出答案。

选取所有询问都包含的某个位置,分别向左向右预处理某些东西。

对于询问的回答,只需要在左端点取信息,在右端点取信息,再组合即可。这要求(答案/状态)能够合并。

然后我们套用猫树分治,就能够处理更一般的情况了。

此外,将分治树存下来,往往就能够做到强制在线。

- **算法流程**

考虑一堆询问区间和对应的状态区间$[L,R]$。

我们取状态区间的中点$mid=\lfloor\frac{L+R}{2}\rfloor$,从$mid$分别向左右预处理某些信息。

遍历所有询问,如果跨过$(mid,mid+1)$,则合并左右端点信息来回答。

如果在$[L,mid]$中,则下放到左儿子。

如果在$[mid+1,R]$中,则下放到右儿子。

继续分治。

(不难发现其实就是序列上的点/边分治,所以上猫树的题目可能可以上点/边分树)

## 本题题解

考虑猫树分治,我们得到左右两侧背包,只需要合并求一个值,那么就可以使用上文$O(t)$的方法。

这些背包需要分治并建立,需要$O(nt)$的空间和$O(nt\log n)$的时间。

总复杂度$O(nt\log n+qt)$,实现细节请查看代码。

```cpp
#include<algorithm>
#include<cstdio>
#define MaxM 200500
#define MaxN 40500
using namespace std;
inline int read(){
  register int X=0;
  register char ch=0;
  while(ch<48||ch>57)ch=getchar();
  while(ch>=48&&ch<=57)X=X*10+(ch^48),ch=getchar();
  return X;
}
int n,m,h[MaxN],w[MaxN],f[MaxN][205];
struct Data
{int l,r,t;}b[MaxM];
int p[MaxM],s[MaxM],ans[MaxM],tn;
void solve(int l,int r,int tl,int tr)
{
  if (tl>tr)return ;
  int mid=(l+r)>>1,tmid=tl-1;
  for (int j=0;j<=200;j++)f[mid][j]=0;
  for (int i=mid+1;i<=r;i++){
    for (int j=0;j<h[i];j++)f[i][j]=f[i-1][j];
    for (int j=h[i];j<=200;j++)
      f[i][j]=max(f[i-1][j],f[i-1][j-h[i]]+w[i]);
  }
  for (int j=h[mid];j<=200;j++)f[mid][j]=w[mid];
  for (int i=mid-1;i>=l;i--){
    for (int j=0;j<h[i];j++)f[i][j]=f[i+1][j];
    for (int j=h[i];j<=200;j++)
      f[i][j]=max(f[i+1][j],f[i+1][j-h[i]]+w[i]);
  }tn=0;
  for (int i=tl,u;i<=tr;i++){
    u=p[i];
    if (b[u].r<=mid)p[++tmid]=u;
    else if (mid<b[u].l)s[++tn]=u;
    else {
      int ret=0;
      for (int i=0;i<=b[u].t;i++)
        ret=max(ret,f[b[u].l][i]+f[b[u].r][b[u].t-i]);
      ans[u]=ret;
    }
  }for (int i=1;i<=tn;i++)p[tmid+i]=s[i];
  tr=tn+tmid;
  solve(l,mid,tl,tmid);
  solve(mid+1,r,tmid+1,tr);
}
int main()
{
  n=read();m=read();
  for (int i=1;i<=n;i++)h[i]=read();
  for (int i=1;i<=n;i++)w[i]=read();
  for (int i=1;i<=m;i++){
    b[i].l=read();b[i].r=read();
    b[i].t=read();
    if (b[i].l==b[i].r){
      if (b[i].t>=h[b[i].l])ans[i]=w[b[i].l];
    }else p[++tn]=i;
  }solve(1,n,1,tn);
  for (int i=1;i<=m;i++)
    printf("%d\n",ans[i]);
  return 0;
}
```


---

## 作者：Reunite (赞：6)

简单的分治题。

## 一
---

看题，发现单次询问是背包问题，但是多组询问，容积很小。我们尝试从这两个特殊点入手。

首先考虑线段树，每次暴力 $O(t^2)$ 合并两个区间，复杂度达到了 $O(nt^2+q\log_2t^2)$，无法通过。但是发现线段树做法是在线的，题目却允许离线，这肯定没有把信息熵用满，因为我们如此直接的做法舍弃了询问之间的联系和性质。

这时候就可以考虑分治了，对于分治区间 $[l,r]$，记 $mid=\frac{l+r}{2}$，对于询问完全在 $[l,mid]$ 或 $[mid+1,r]$ 内的询问，继续递归分治解决，接下来只需考虑处理跨过 $mid$ 的询问即可。

从分治中点 $mid$ 开始向左，记 $f_{i,j}$ 表示考虑 $[i,mid]$ 之间的物品，占用空间为 $j$ 的最大权值，这部分是 $O(\sum len\cdot t)=O(tn\log_2n )$ 的。类似地处理出 $g_{i,j}$ 为 $[mid+1,i]$ 的最大权值。此时对于任意一个询问 $(ql,qr)$，只需要在 $f,g$ 中对应查询合并即可。

注意这里的合并并不是 $O(t^2)$ 的，因为我们只需要获得合并后背包的前缀点值的最大值，显然可以分别算出 $f,g$ 的第二维上的前缀 $\max$，然后就可以 $O(t)$ 获得答案了。

## 二
---

总时间复杂度 $O(tn\log_2n+qt)$，空间为 $O(nt)$。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;

int n,m;
int a[40005];
int b[40005];
int ans[200005];
int f[40005][205];
struct node{int l,r,x,id;};

inline void in(int &n){
	n=0;
	char c=getchar();
	while(c<'0' || c>'9') c=getchar();
	while(c>='0'&&c<='9') n=n*10+c-'0',c=getchar();
	return ;
}

inline void solve(int l,int r,vector <node> g){
	if(l==r){
		for(auto tmp:g) ans[tmp.id]=(tmp.x>=a[l]?b[l]:0);
		return ;
	}
	int mid=(l+r)>>1;
	vector <node> g1,g2,gg;
	for(auto tmp:g){
		if(tmp.r<=mid) g1.emplace_back(tmp);
		else if(tmp.l>mid) g2.emplace_back(tmp);
		else gg.emplace_back(tmp);
	}
	solve(l,mid,g1);
	solve(mid+1,r,g2);
	sort(gg.begin(),gg.end(),[](node p,node q){return p.r<q.r;});
	memset(f[mid+1],0,sizeof(f[mid+1]));
	for(int i=mid;i>=l;i--){
		for(int j=1;j<=200;j++) f[i][j]=f[i+1][j];
		for(int j=200-a[i];j>=0;j--) f[i][j+a[i]]=max(f[i][j+a[i]],f[i][j]+b[i]);
	}
	int h[205]={0},pos=mid+1,x[205]={0},y[205]={0};
	for(auto tmp:gg){
		while(pos<=tmp.r){
			for(int j=200-a[pos];j>=0;j--) h[j+a[pos]]=max(h[j+a[pos]],h[j]+b[pos]);
			pos++;
		}
		for(int i=1;i<=200;i++) x[i]=max(x[i-1],f[tmp.l][i]);
		for(int i=1;i<=200;i++) y[i]=max(y[i-1],h[i]);
		int mx=0;
		for(int i=0;i<=tmp.x;i++) mx=max(mx,x[i]+y[tmp.x-i]);
		ans[tmp.id]=mx;
	}
}

int main(){
	in(n),in(m);
	for(int i=1;i<=n;i++) in(a[i]);
	for(int i=1;i<=n;i++) in(b[i]);
	vector <node> g;
	for(int i=1;i<=m;i++){
		int l,r,x,id;
		in(l),in(r),in(x),id=i;
		g.push_back({l,r,x,id});
	}
	solve(1,n,g);
	for(int i=1;i<=m;i++) printf("%d\n",ans[i]);

	return 0;
}
```

---

## 作者：樱雪喵 (赞：5)


猫树分治能解决的问题通常有以下条件：

- 静态区间，多组询问；
- 我们不会快速求处理询问，但如果知道区间中一点 $mid$ 分别到区间左右端点的答案，可以快速地合并这两部分得到完整区间的答案。 

对于本题，假设我们已经知道了 $[l,mid]$ 和 $[mid+1,r]$ 的背包 $L,R$，直接合并这两部分是 $O(t^2)$ 的。  
但是因为这道题给定了询问的 $t_i$，我们并不需要真的把两个背包合并起来，直接求 $\max \{L_j+R_{t_i-j}\}$ 就好了，这样时间复杂度只有 $O(t)$。

接下来考虑如何充分利用已知区间中一点的条件，求出答案。

分治，设 $\text{solve}(l,r)$ 表示当前仅考虑被 $[l,r]$ 包含的询问区间。令 $mid$ 为 $l,r$ 的中点。  
那么这些区间分为两种，不跨越 $mid$ 的区间直接分到两边递归处理；只考虑求出所有跨过 $mid$ 的区间的答案。  
这时候上面所说的就能用到了：我们以 $O(t(r-l))$ 的复杂度处理出所有 $[i,mid](l\le i\le mid)$ 和 $[mid+1,i](mid<i\le r)$ 的背包，则可以以 $O(t)$ 的时间复杂度处理一个跨过隔板的询问。

实现上，把未处理的询问塞进两边递归的过程和整体二分类似。
```cpp
const int N=4e4+5,M=205,Q=2e5+5;
int n,m,t=200,w[N],c[N];
int L[N][M],R[N][M];
struct node{int l,r,t,id;} q[Q],b[Q];
int ans[Q];
void solve(int l,int r,int ql,int qr)
{
    if(ql>qr) return;
    int mid=(l+r)>>1;
    memset(L[mid+1],0,sizeof(L[mid+1])),memset(R[mid],0,sizeof(R[mid]));
    for(int i=mid;i>=l;i--) 
        for(int j=0;j<=t;j++) 
        {
            L[i][j]=max(j?L[i][j-1]:0,L[i+1][j]);
            if(j>=w[i]) L[i][j]=max(L[i][j],L[i+1][j-w[i]]+c[i]);
        }
    for(int i=mid+1;i<=r;i++) 
        for(int j=0;j<=t;j++) 
        {
            R[i][j]=max(j?R[i][j-1]:0,R[i-1][j]);
            if(j>=w[i]) R[i][j]=max(R[i][j],R[i-1][j-w[i]]+c[i]);
        }
    int nql=ql,nqr=qr;
    for(int i=ql;i<=qr;i++) b[i]=q[i];
    for(int i=ql;i<=qr;i++)
    {
        if(b[i].r<mid) q[nql++]=b[i];
        else if(b[i].l>mid) q[nqr--]=b[i];
        else 
        {
            int res=0;
            for(int j=0;j<=b[i].t;j++) res=max(res,L[b[i].l][j]+R[b[i].r][b[i].t-j]);
            ans[b[i].id]=res;
        }
    }
    solve(l,mid,ql,nql-1),solve(mid+1,r,nqr+1,qr);
}
int main()
{
    n=read(),m=read();
    for(int i=1;i<=n;i++) w[i]=read();
    for(int i=1;i<=n;i++) c[i]=read();
    for(int i=1;i<=m;i++) q[i].l=read(),q[i].r=read(),q[i].t=read(),q[i].id=i;
    solve(1,n,1,m);
    for(int i=1;i<=m;i++) printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：xuyuansu (赞：5)

## 简要题意
有 $n$ 种小吃，每个都有热量和美味度，给你 $m$ 个询问，问在一个区间内每种小吃最多吃一次在总热量不超过给定值的情况下的最大美味度和。

## 题解
这种问题没有强制在线，可以考虑分治，这里用的是猫树分治。

猫树是一种以区间中点为起点向两边预处理信息合并起来回答询问的一种线段树变形，我们可以利用这种方式来完成分治。

我们将所有问题离线下来，用类似整体二分的方式，找出当前序列范围的中点  $mid$，然后从 $mid$ 和 $mid+1$ 开始向左右做背包，记录下拓展到每个点时的背包信息。

把询问分情况处理，每一层只处理跨过中点的询问，其他的分别下放到左右的分治递归里，在无法继续分治是特殊处理一下。利用左右询问边界对应的背包按动规的方式计算答案。

总复杂度是 $O(nt\log n+mt)$。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=4e4+5,M=2e5+5;
typedef long long ll;
int n,m,h[N],w[N];ll ans[M];
struct node
{
    int l,r,t,id;
}q[M],w1[M],w2[M];
ll f[N][205];
void solve(int l,int r,int L,int R)
{
    if(L>R) return;
    if(l==r)
    {
        for(int i=L;i<=R;i++)
            if(q[i].t>=h[l]) ans[q[i].id]=w[l];
        return;
    }
    int mid=(l+r)>>1;
    memset(f[mid],0,sizeof(f[mid]));
    for(int i=h[mid];i<=200;i++) f[mid][i]=w[mid];
    for(int i=mid-1;i>=l;i--)
    {
        for(int j=0;j<=200;j++) f[i][j]=f[i+1][j];
        for(int j=200;j>=h[i];j--)
            f[i][j]=max(f[i][j],f[i][j-h[i]]+w[i]);
    }
    memset(f[mid+1],0,sizeof(f[mid+1]));
    for(int i=h[mid+1];i<=200;i++) f[mid+1][i]=w[mid+1];
    for(int i=mid+2;i<=r;i++)
    {
        for(int j=0;j<=200;j++) f[i][j]=f[i-1][j];
        for(int j=200;j>=h[i];j--)
            f[i][j]=max(f[i][j],f[i][j-h[i]]+w[i]);
    }
    int cnt1=0,cnt2=0;
    for(int i=L;i<=R;i++)
    {
        if(q[i].l<=mid && q[i].r<=mid) w1[++cnt1]=q[i];
        else if(q[i].l>mid && q[i].r>=mid) w2[++cnt2]=q[i];
        else{
            for(int j=0;j<=min(q[i].t,200);j++)
                ans[q[i].id]=max(ans[q[i].id],f[q[i].l][j]+f[q[i].r][q[i].t-j]);
        }
    }
    for(int i=1;i<=cnt1;i++) q[L+i-1]=w1[i];
    for(int i=1;i<=cnt2;i++) q[L+cnt1+i-1]=w2[i];
    solve(l,mid,L,L+cnt1-1);
    solve(mid+1,r,L+cnt1,L+cnt1+cnt2-1);
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&h[i]);
    for(int i=1;i<=n;i++) scanf("%d",&w[i]);
    for(int i=1;i<=m;i++)
    {
        int l,r,t;scanf("%d%d%d",&l,&r,&t);
        q[i]={l,r,t,i};
    }
    solve(1,n,1,m);
    for(int i=1;i<=m;i++) printf("%lld\n",ans[i]);
    return 0;
}
```


---

## 作者：Prean (赞：5)

# 题解
我们可以发现，背包有结合律。

也就是先加入元素 $ a $ 再加入元素 $ b $ 和 $ c $，与先加入元素 $ a $ 后再与只有元素 $ b $ 和元素 $ c $ 的背包合并，得到的背包数组是不会发生改变的。

所以我们很容易想到用线段树来做这道题。

但是线段树太慢了，于是我们就理所当然地写了一个猫树。

[然后](https://www.luogu.com.cn/record/50015512)

我们算了算，发现这个代码的空间有 $ 500 $ 多 MB（

于是我们就得把猫树的空间给优化一下。

我们发现在执行 Build 的时候，在递归结束后该子树的信息就不会再发生改变了。我们可以在此时进行查询，然后删掉这个子树的信息。

通俗点儿说就是把子树给滚掉。

要在建树时进行查询只需要离线存下询问就行了。

我们就成功地优化掉了一个 $ O(\log n) $，空间复杂度能够接受。

code:
```cpp
#include<cstdio>
#include<vector>
const int M=4e4+5;
int n,m,c[M],v[M],ans[200005];
int back[M][205];
std::vector<int>l[M<<2],r[M<<2],t[M<<2],id[M<<2];
inline int max(const int&a,const int&b){
	return a>b?a:b;
}
inline void trans(int*tar,int*ori,const int&c,const int&v){
	for(register int i=0;i<=200;++i)tar[i]=ori[i];
	for(register int i=200;i>=c;--i)tar[i]=max(tar[i],tar[i-c]+v);
}
inline int Q(const int&L,const int&R,const int&m){
	register int i,ans=0;
	if(L==R)for(i=0;i<=m;++i)ans=max(ans,back[L][i]);
	else for(i=0;i<=m;++i)ans=max(ans,back[L][i]+back[R][m-i]);
	return ans;
}
void Solve(int u,int L=1,int R=n){
	register int i;
	if(L==R)trans(back[L],*back,c[L],v[L]);
	else{
		register int mid=L+R>>1;
		Solve(u<<1,L,mid);Solve(u<<1|1,mid+1,R);
		trans(back[mid],*back,c[mid],v[mid]);trans(back[mid+1],*back,c[mid+1],v[mid+1]);
		for(i=mid-1;i>=L;--i)trans(back[i],back[i+1],c[i],v[i]);
		for(i=mid+2;i<=R;++i)trans(back[i],back[i-1],c[i],v[i]);
	}
	for(i=0;i<t[u].size();++i)ans[id[u][i]]=Q(l[u][i],r[u][i],t[u][i]);
}
inline void Insert(int u,int ql,int qr,int qt,int qd,int L=1,int R=n){
	if(L==R){
		l[u].push_back(ql);r[u].push_back(qr);t[u].push_back(qt);id[u].push_back(qd);
		return;
	}
	int mid=L+R>>1;
	if(qr<=mid)return Insert(u<<1,ql,qr,qt,qd,L,mid);
	if(ql>mid)return Insert(u<<1|1,ql,qr,qt,qd,mid+1,R);
	l[u].push_back(ql);r[u].push_back(qr);t[u].push_back(qt);id[u].push_back(qd);
}
signed main(){
	register int i,L,R,t;
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;++i)scanf("%d",c+i);
	for(i=1;i<=n;++i)scanf("%d",v+i);
	for(i=1;i<=m;++i){
		scanf("%d%d%d",&L,&R,&t);
		Insert(1,L,R,t,i);
	}
	Solve(1);
	for(i=1;i<=m;++i)printf("%d\n",ans[i]);
}
```

---

## 作者：Time_tears (赞：4)

# 好吃的题目
- 鉴于本人昨天刚学了猫树分治，今天来写一道猫树分治的题目。

## 猫树
- 猫树的基本思想就是在线段树的基础上快速维护这个区间从中点开始的前后缀信息，查询时找到一个使查询区间 $x,y$ 分居于递归区间 $l,r$ 的 $mid$ 两边，并合并这个区间中的信息查询 $x,y$ ，预处理 $O(n\log n)$ ，而这个查询操作的单次复杂度是 $O(1)$ 的，所以我们可以用猫树来快速维护许多东西。

## 猫树分治

- 因为猫树的时空复杂度都是 $O(n\log n)$ 的，所以在有些题目卡空间的时候，我们就要用到猫树分治了

## 本题思路

- 我们看到 $h,w$ 两个数组时就应该发现这是一个背包，但是我们要做的是$l,r$ 区间上的背包，$DDP$？显然不是，我们运用猫树的思路，在递归到 $l,r$ 区间时，计算这个区间的从 $mid$ 开始的背包，然后计算在这个区间中的答案（代码神似整体二分），具体的背包大家肯定没有问题吧。

~~本人rank1代码~~

```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#include<cstdio>
#include<iomanip>
#define N 205
#define M 200005
using namespace std;
const int Mxdt=1<<22;
char *Pi,bif[Mxdt],*po,bof[Mxdt];
#define Rd()\
	res=0;while(*Pi<'0')++Pi;\
	while(*Pi>='0')res=(res<<3)+(res<<1)+(*Pi++^48);
void print(int x) {
	if(x>9)print(x/10);
	*++po=x%10^48;
}
int n,m,h[M],w[M],f[N*N][N];
int ans[M],id[M],tmp1[M],tmp2[M];
struct node {
	int x,y,t,id;
} q[M];
inline int read() {
	int s=0,f=0;
	char ch=getchar();
	while(ch<48)f=(ch=='-'),ch=getchar();
	while(ch>47)s=(s<<1)+(s<<3)+(ch^48),ch=getchar();
	return f?-s:s;
}
void Solve(int l,int r,int ql,int qr) {
	if(ql>qr)return;
	if(l==r) {
		for(int i=ql; i<=qr; ++i)ans[q[id[i]].id]=q[id[i]].t<h[l]?0:w[l];
		return;
	}
	int mid=l+r>>1;
	for(int i=0; i<h[mid]; ++i)f[mid][i]=0;
	for(int i=h[mid]; i<=200; ++i)f[mid][i]=w[mid];
	for(int i=mid-1; i>=l; --i) {
		for(int j=0; j<h[i]; ++j)f[i][j]=f[i+1][j];
		for(int j=h[i]; j<=200; ++j)f[i][j]=max(f[i+1][j],f[i+1][j-h[i]]+w[i]);
	}
	for(int i=0; i<h[mid+1]; ++i)f[mid+1][i]=0;
	for(int i=h[mid+1]; i<=200; ++i)f[mid+1][i]=w[mid+1];
	for(int i=mid+2; i<=r; ++i) {
		for(int j=0; j<h[i]; ++j)f[i][j]=f[i-1][j];
		for(int j=h[i]; j<=200; ++j)f[i][j]=max(f[i-1][j],f[i-1][j-h[i]]+w[i]);
	}
	int cnt1=0,cnt2=0;
	for(int i=ql; i<=qr; ++i) {
		int x=q[id[i]].x,y=q[id[i]].y,t=q[id[i]].t,Id=q[id[i]].id;
		if(l<=x&&x<=mid&&mid<y&&y<=r)for(int j=0; j<=t; ++j)ans[Id]=max(ans[Id],f[x][j]+f[y][t-j]);
		else if(x>mid&&y>mid)tmp2[++cnt2]=id[i];
		else tmp1[++cnt1]=id[i];
	}
	for(int i=1; i<=cnt1; ++i)id[i+ql-1]=tmp1[i];
	for(int i=1; i<=cnt2; ++i)id[i+ql+cnt1-1]=tmp2[i];
	Solve(l,mid,ql,ql+cnt1-1),Solve(mid+1,r,ql+cnt1,ql+cnt1+cnt2-1);
}
int main() {
	fread(Pi=bif,Mxdt,1,stdin),po=bof-1;
	int res;
	Rd()n=res;
	Rd()m=res;
	for(int i=1; i<=n; ++i) {
		Rd()h[i]=res;
	}
	for(int i=1; i<=n; ++i) {
		Rd()w[i]=res;
	}
	for(int i=1; i<=m; ++i) {
		Rd()q[i].x=res;
		Rd()q[i].y=res;
		Rd()q[i].t=res;
		id[q[i].id=i]=i;
	}
	Solve(1,n,1,m);
	for(int i=1; i<=m; ++i)print(ans[i]),*++po='\n';
	return fwrite(bof,po-bof+1,1,stdout),0;
	return 0;
}
```


---

## 作者：thh_loser (赞：3)

# P6240 好吃的题目

[题目链接](https://www.luogu.com.cn/problem/P6240)

## 前置芝士：猫树分治

猫树分治，也叫二区间合并。于是显然的，使用猫树的前提是查询信息具有区间可并性。 

实际上猫树就是将猫树分治的分治树存下来，以空间增加一只 $log$ 的代价达到在线回答问题的效果。

### 实现

猫树分治的思想很简单，我们考虑查询所在的序列区间 $\left[l,r\right]$，设序列区间的中点为 $mid$，先进行预处理，得到每一个 $i\in\left[l,mid\right)$ 到 $mid$ 的**后缀**区间信息数组 $\operatorname{pre}$，以及 $mid$ 到每一个  $i\in\left(mid,r\right]$ 的**前缀**区间信息数组 $\operatorname{suf}$。具体合并方法就是从 $mid$ 开始，向两侧一个一个合并。

然后考虑一个属于当前序列区间的查询区间$\left[ql,qr\right]$，假如区间完全位于 $mid$ 的左或右端，将其递归下去交给序列区间 $\left[l,mid\right]$ 或 $\left[mid+1,r\right]$ 解决。而当查询区间的两端分居 $mid$ 两侧，则答案即为 $\operatorname{pre}[ql]+\operatorname{suf}[qr]$。

如图：

![图片加载中···][cat]

每一层将第三种计算得到答案，前两种向下递归解决。最多递归 $\log n$ 层，每层进行 $O(n)$ 的预处理，时间复杂度 $O(n \log{n})$，从预处理可以看出空间复杂度是 $O(n)$ 的。

如果要求在线，我们可以预先将每一层的所有 $mid$ 的信息全部储存，再结合一点小技巧，就可以达到  $O(n\log n)$ 预处理、$O(1)$的在线查询，但由于需要 $\log n$ 层的预处理数组，空间复杂度也变成了 $O(n\log n)$，这样就得到了  猫树。

### 例题

### [好吃的题目](https://www.luogu.com.cn/problem/P6240)

题目内容：$n$ 个物品，$m$ 次询问，求区间 $01$ 背包。

数据范围： $1 \leq n\leq 4\times 10^4$，$1 \leq m\leq 2\times 10^5$，$1\leq l_i\leq r_i\leq n$，$1\leq h_i,t_i\leq 200$，$1\leq w_i\leq 10^7$。



一道算是模板的题目，题目没有要求在线，于是我们使用猫树分治。

唯一需要注意的是两个背包的合并，直接合并是 $O(t^2)$ 的，会爆掉。但事实上我们不需要真的合并，对于两个已经处理好的背包，选择满容量一定不会更劣，因此一旦一个背包选择的容量确定了另一个也就确定了，即 $ans=\max_{j=0}^{t}\left(f\left[l\right]\left[j\right]+f\left[r\right]\left[t-j\right]\right)$，可以做到 $O(t)$ 合并。

时间复杂度 $O(n~t \log n)$，空间复杂度 $O\left(n~t\right)$。



#### C++ code

```c++
#include<bits/stdc++.h>
#define N 40010
#define M 200010
#define int long long
using namespace std;
int t(1),n,m,h[N],w[N],tot;
int pre[M],suf[M];
int f[N][205];
int re[M];
struct ask{
	int l,r,v;
}eater[M];
void solve(int nl,int nr,int ql,int qr){//猫树分治
	if(ql>qr)return;
	int qmid=ql-1;//qmid最后即为分治的分界线 
	int mid=(nl+nr)>>1;
	for(int i=0;i<=200;++i)f[mid][i]=0;
	for(int i=0;i<=200;++i)f[mid+1][i]=0;//记得初始化清0 
	for(int i=h[mid];i<=200;++i)f[mid][i]=w[mid];
	for(int i=mid-1;i>=nl;--i){
		for(int j=0;j<h[i];++j)f[i][j]=f[i+1][j];
		for(int j=200;j>=h[i];--j){
			f[i][j]=max(f[i+1][j],f[i+1][j-h[i]]+w[i]);//01背包 
		}
	}//前半部分 
	for(int i=h[mid+1];i<=200;++i)f[mid+1][i]=w[mid+1];
	for(int i=mid+2;i<=nr;++i){
		for(int j=0;j<h[i];++j)f[i][j]=f[i-1][j];
		for(int j=200;j>=h[i];--j){
			f[i][j]=max(f[i-1][j],f[i-1][j-h[i]]+w[i]);
		}
	}//后半部分 
	int all=0;
	for(int i=ql;i<=qr;++i){
		int x=pre[i];
		if(eater[x].r<=mid)pre[++qmid]=x;//全部在右边 
		else if(eater[x].l>mid)suf[++all]=x;//全部在左边 
		else{
			for(int j=0;j<=eater[x].v;++j){
				re[x]=max(re[x],f[eater[x].l][j]+f[eater[x].r][eater[x].v-j]);
			}//O(t)合并 
		}
	}
	for(int i=1;i<=all;++i){
		pre[qmid+i]=suf[i];
	}
	solve(nl,mid,ql,qmid);
	solve(mid+1,nr,qmid+1,qmid+all);//递归分治处理 
}
signed main(){
	//cin>>t;
	while(t--){
		scanf("%lld%lld",&n,&m);
		for(int i=1;i<=n;++i)scanf("%lld",&h[i]);
		for(int i=1;i<=n;++i)scanf("%lld",&w[i]);
		for(int i=1,x,y,z;i<=m;++i){
			scanf("%lld%lld%lld",&x,&y,&z);
			eater[i]={x,y,z};
			if(x==y){
				re[i]=(z>=h[x]?w[x]:0); 
			} 
			else{
				pre[++tot]=i;
			}
		}
		solve(1,n,1,tot);
		for(int i=1;i<=m;++i)cout<<re[i]<<"\n";
	}
	return 0;
}
```











[cat]:data:image/png;base64,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FL/B4Dfb6MTZ4HwAgAMQwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwAAAACoRwACA//33P/93Z4kGAHyLAAYA7y5FrN0SzQB4nAAGAO8u5avdEs14tnRcNko0AF6AAAYA7y4N1ndLNOOp0kHZLdEMeDYBDADeXRqp75ZoxlOlg7JbohnwbAIYALy7NFLfLdGMp0oHZbdEM+DZBDAAeHdppL5bohlPlQ7KbolmwLMJYADw7tJIfbdEM54qHZTdEs2AZxPAAODdpZH6bolmPFU6KLslmgHPJoABwLtLI/XdEs14qnRQdks0A55NAAOAd5dG6rslmvFU6aDslmgGPJsABgDvLo3Ud0s046nSQdkt0Qx4NgEMAN5dGqnvlmjGU6WDsluiGfBsAhgAvLs0Ut8t0YynSgdlt0Qz4NkEMAB4d2mkvluiGU+VDspuiWbAswlgAPDu0kh9t0Qzniod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BzSdtslrPBPqHm7FHeVrfNSVs1JMnk/sGrT/189tt6ebmowPs122xyWAcRYGEhyDM/X7lvfdlJeWU9Q49bb5VKmZ1n8WaP6XxM5+jJyNHNB02jYn7ks9/RqMz5hb7R+Av82Fzb2m+5vwayvczN7elraD19havkMA4ywMJDgGZ+r3Le+7HwSw2UhuMo3pzn6MnI0c0M1pOz1lun2kBC9JAOMsDCQ4Bmfq9y3vu58EsMZ9P01xUs5GDmjptBXBOBYBjLMwkOAo2g+6deI9L+BtD0lsuLOR41j+514E40gEMM5iuiM39+Rk+MvzAMChrfz31nIUIILx4gQwzqK89WaeiQHAKawEMBGMAxHAOAsBDABObzWAzT6HKILxygQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACASgQwAACAKv73v/8HO5ATWho0y5EAAAAASUVORK5CYII=

---

## 作者：lfxxx (赞：2)

应该算猫树分治的模板题目。

先讲一下猫树分治的大概步骤：

# 离线

考虑先分治，对于 $l \leq mid$ 的询问，划分到左边处理，对于 $r > mid$ 的询问，划分到右边处理。

那么对于横跨 $mid$ 的询问呢？

考虑从 $mid$ 开始依次向左/右遍历，遇到一个询问端点就把当前答案记下来，最后再合并。

# 复杂度

考虑用一个队列存储所有询问，通过传递指针的方式让询问至多在一个队列中出现，便利时用到的结构可以清空，假设用某种数据结构维护的空间是 $O(a)$，那么空间复杂度是 $O(n + q + a)$ 的。

每个询问最多被分治 $\log n$ 遍，每个区间最多被递归 $\log n$ 层，假设用某种数据结构维护答案合并是 $O(a)$，那么询问复杂度是 $O(q \log n + n \log n \times a + q \times a)$（线段树 $O(q \log n \times a + n)$）。

# 回到本题

这一题我们要合并的信息是一个背包，直接 $O(t)$合并即可。

```cpp
#include<bits/stdc++.h>
#define int long long
const int mod = 1e9+7;
using namespace std;
const int maxn = 4e4+4;
const int maxt = 204;
const int maxm = 2e5+114;
int dp[maxn][maxt];
int ans[maxm],w[maxn],v[maxn];
struct query{
    int l,r,id,t;
};
void solve(int l,int r,queue<query> &s){
    if(s.size()==0||l>r) return ;
    if(l==r){
        while(s.size()>0){
        	if(s.front().t>=w[l])
            	ans[s.front().id]=v[l];
            else
            	ans[s.front().id]=0;
            s.pop();
        }
        return ;
    }
    int mid=(l+r)/2;
    queue<query> L,R,M;
    while(s.size()>0){
        int lt=s.front().l,rt=s.front().r;
        if(rt<=mid){
            L.push(s.front());
        }
        else if(lt>mid){
            R.push(s.front());
        }
        else{
            M.push(s.front());
        }
        s.pop();
    }
    solve(l,mid,L);
    solve(mid+1,r,R);
    for(int i=l;i<=r;i++)
    	for(int j=0;j<maxt;j++) dp[i][j]=0;
    for(int i=mid;i>=l;i--){
    	for(int j=0;j<maxt;j++){
    	    if(i!=mid)
    	        dp[i][j]=dp[i+1][j];
    		if(j>=w[i]){
    			if(i!=mid)
    				dp[i][j]=max(dp[i+1][j],dp[i+1][j-w[i]]+v[i]);
    			else
    				dp[i][j]=v[i];
			}
		}    
    }
	for(int i=mid+1;i<=r;i++){
		for(int j=0;j<maxt;j++){
		    if(i!=mid+1)
		        dp[i][j]=dp[i-1][j];
			if(j>=w[i]){
				if(i!=mid+1)
    				dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]);
    			else
    				dp[i][j]=v[i];
			}
		}
	}
    while(M.size()>0){
        int lt=M.front().l,rt=M.front().r,t=M.front().t;
        for(int j=0;j<=t;j++){
			ans[M.front().id]=max(ans[M.front().id],dp[lt][j]+dp[rt][t-j]); 
		} 
        M.pop();
    }
}
int n,m;
queue<query> S;
signed main(){
ios::sync_with_stdio(0);
cin.tie(0);
cout.tie(0);
cin>>n>>m;
for(int i=1;i<=n;i++) cin>>w[i];
for(int i=1;i<=n;i++) cin>>v[i];
for(int i=1;i<=m;i++){
    query Q;
    cin>>Q.l>>Q.r>>Q.t;
    Q.id=i;
    S.push(Q);
}
solve(1,n,S);
for(int i=1;i<=m;i++){
    cout<<ans[i]<<'\n';
}
return 0;
}
```

时间复杂度 $O(n \log n \times t + m \log n + m \times t)$ 空间复杂度 $O(n + m + n \times t)$。

---

## 作者：tder (赞：1)

> You can view the [English version](https://www.luogu.com/article/1dp37kj5/) of this solution.

> 图片托管于 Github，若加载失败请使用加速器。

猫树板子题。

考虑已知 $f_i$ 表示区间 $[l,\text{mid}]$ 中容量为 $i$ 的答案，以及 $g_i$ 表示区间 $[\text{mid}+1,r]$ 中容量为 $i$ 的答案，如何计算出区间 $[l,r]$ 中容量为 $v$ 的答案。不难有直接计算 $\text{merge}(f,g)=\max\{f_i+g_{v-i}\}$ 即可。复杂度 $\mathcal{O}(n)$。

令询问区间为 $[a,b]$。若区间 $[l,r]$ 满足 $l\le a\le\text{mid}\le b\le r$，则答案即为 $\text{merge}(f,g)$。于是问题转化为如何找到这样满足条件的区间。

对于满足 $l\le a\le b\le r$ 的区间 $[l,r]$，我们讨论以下三种情况：

1. 当 $a\le\text{mid}<b$ 时，直接计算答案即可；
2. 当 $a\le b\le\text{mid}$ 时，向下递归区间 $[l,\text{mid}]$；
3. 当 $\text{mid}<a\le b$ 时，向下递归区间 $[\text{mid}+1,r]$。

![type 1](https://raw.githubusercontent.com/tder6/Img/refs/heads/main/Sol/P6240/type%201.png)

![type 2](https://raw.githubusercontent.com/tder6/Img/refs/heads/main/Sol/P6240/type%202.png)

![type 3](https://raw.githubusercontent.com/tder6/Img/refs/heads/main/Sol/P6240/type%203.png)

由于是离线，可以将所有递归到同一个区间的询问一起考虑，需要用的时候再计算 $f,g$ 即可，可以节省空间。复杂度 $\mathcal{O}(v\cdot n\log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
// #define int long long
#define endl '\n'
const int N = 4e4 + 5, M = 2e2 + 5, Q = 2e5 + 5, V = 2e2;
int n, q, v[N], w[N], ans[Q], f[N][M], g[N][M]; 
struct Node {
	int l, r, t, i;
};
void solve(vector<Node> &p, int l, int r) {
	int m = (l + r) / 2;
	vector<Node> nl, nm, nr;
	for(auto [xl, xr, t, i] : p) 
		if(xl <= m && xr <= m) nl.push_back({xl, xr, t, i}); 
		else if(xl <= m && xr > m) nm.push_back({xl, xr, t, i});
		else if(xl > m && xr > m) nr.push_back({xl, xr, t, i});
		else assert(0);
	if(!nl.empty()) solve(nl, l, m);
	if(!nr.empty()) solve(nr, m + 1, r);
	if(!nm.empty()) {
		for(int j = 0; j <= V; j++) f[m + 1][j] = 0;
		for(int i = m; i >= l; i--) for(int j = 0; j <= V; j++)
			if(j >= v[i]) f[i][j] = max(f[i + 1][j], f[i + 1][j - v[i]] + w[i]);
			else f[i][j] = f[i + 1][j];
		for(int j = 0; j <= V; j++) g[m][j] = 0;
		for(int i = m + 1; i <= r; i++) for(int j = 0; j <= V; j++)
			if(j >= v[i]) g[i][j] = max(g[i - 1][j], g[i - 1][j - v[i]] + w[i]);
			else g[i][j] = g[i - 1][j];
		for(auto [xl, xr, t, i] : nm)
			for(int a = 0, b = t; a <= t; a++, b--)
				ans[i] = max(ans[i], f[xl][a] + g[xr][b]);
	}
}
signed main() {
	cin>>n>>q;
	for(int i = 1; i <= n; i++) cin>>v[i];
	for(int i = 1; i <= n; i++) cin>>w[i];
	vector<Node> p;
	for(int i = 1; i <= q; i++) {
		int l, r, t; cin>>l>>r>>t;
		if(l == r) ans[i] = (t >= v[l] ? w[l] : 0);
		else p.push_back({l, r, t, i});
	}
	solve(p, 1, n);
	for(int i = 1; i <= q; i++) cout<<ans[i]<<endl;
}
```

---

## 作者：Usada_Pekora (赞：1)

由于两个背包合并实际上是单调序列做 Max-Add Convolution，复杂度一般是 $O(v^2)$，虽然也有 $O(v^{\frac{3}{2}})$ 的做法，但我们把区间的背包询问出来然后单点查的计划肯定是泡汤了。

枚举左端点，然后一直往右做背包不行，但是从一个点向两头分别扩展背包，然后询问跨越这个点的背包的单点值，这是可行的。

自然地，考虑分治，每次从终点开始往两头做背包，处理 $l'\in [l,mid],r'\in(mid,r]$ 的询问，复杂度 $O(nv\log n+q(v+\log n))$。

这个东西实际上支持做满足以下性质的问题：满足从一个点开始往两头扩展，以及支持查询分开来的两部分合起来的贡献。

由于和猫树很像所以很多人叫他猫树分治，其实我感觉猫树才是从这个里面来的，和点分治网格图分治本质相同。

代码如下，写的和大家不太一样。

```cpp
#include <bits/stdc++.h>
#define pb emplace_back
#define mkp make_pair
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
template<typename T> inline bool chkmin(T &x, const T &y) {
	return (y < x) && (x = y, true);
}
template<typename T> inline bool chkmax(T &x, const T &y) {
	return (x < y) && (x = y, true);
}
constexpr int N = 4e4 + 5, Q = 2e5 + 5;
int n, q, h[N], w[N], f[N][201], ans[Q];
vector<tuple<int, int, int>> qry[N];
inline void solve(int l, int r) {
	if (l == r) {
		for (auto [x, t, id] : qry[r]) {
			if (x == l)
				ans[id] = t >= h[x] ? w[x] : 0;
		}	
		return;
	}
	int mid = (l + r) >> 1;
	memset(f[mid], 0, sizeof f[mid]), memset(f[mid + 1], 0, sizeof f[mid + 1]);
	f[mid][h[mid]] = w[mid], f[mid + 1][h[mid + 1]] = w[mid + 1];
	for (int i = mid - 1; i >= l; i--) {
		memcpy(f[i], f[i + 1], 201 * sizeof(int));
		for (int j = h[i]; j <= 200; j++)
			chkmax(f[i][j], f[i + 1][j - h[i]] + w[i]);
	}
	for (int i = mid + 2; i <= r; i++) {
		memcpy(f[i], f[i - 1], 201 * sizeof(int));
		for (int j = h[i]; j <= 200; j++)
			chkmax(f[i][j], f[i - 1][j - h[i]] + w[i]);
	}
	for (int i = l; i <= r; i++) 
		for (int j = 1; j <= 200; j++)
			chkmax(f[i][j], f[i][j - 1]);
	for (int i = mid + 1; i <= r; i++) {
		for (auto [j, t, id] : qry[i]) {
			if (j >= l && j <= mid) {
				for (int k = 0; k <= t; k++)
					chkmax(ans[id], f[i][k] + f[j][t - k]);
			}
		}
	}
	solve(l, mid), solve(mid + 1, r);
}
signed main() {
	cin.tie(nullptr)->sync_with_stdio(false);
	cin >> n >> q;
	for (int i = 1; i <= n; i++)
		cin >> h[i];
	for (int i = 1; i <= n; i++)
		cin >> w[i];
	for (int i = 1; i <= q; i++) {
		int l, r, t;
		cin >> l >> r >> t;
		qry[r].pb(l, t, i);
	}
	solve(1, n);
	for (int i = 1; i <= q; i++)
		cout << ans[i] << '\n';
	return 0;
}
```

---

## 作者：Loser_Syx (赞：0)

如果直接对于每个询问做一遍 $O(nt)$ 的背包，那么复杂度是 $O(nmt)$ 的，会超时。

那有没有更强势的方法推荐一下呢？有的兄弟有的，发现询问显然可以离线，现在需要一些技巧巧妙地解决这种区间问题。

这个时候就需要引入猫树分治了，猫树分治的核心思想是，将区间 $[l,r]$ 分成 $[l,mid]$ 和 $[mid+1,r]$，直至 $l=r$。而将每个询问就会恰好变成一个跨越 $[l,r]$ 的 $mid$ 的询问 $L,R$。

那么我们以 $mid$ 开始往 $l$ 做背包，$mid+1$ 开始往 $r$ 做背包，那么跨过 $mid$ 的答案就可以是这两段拼接起来的答案。

处理好拼接就做完了。不难发现只有 $\log$ 层递归下去，那么复杂度就是 $O(nt \log n)$。

```cpp
const int N = 4e4 + 19, M = 2e5 + 19, L = 219;
int f[N][L], n, m, h[N], w[N], ans[M];
struct Query {
	int L, R, t, id;
} Q[M], tmp[M];
void solve(int l,int r,int pl,int pr) {
	if (pl>pr) return ;
	if (l==r) {
		for (int x=pl;x<=pr;++x) ans[Q[x].id]=Q[x].t<h[r]?0:w[r];
		return ;
	}
	int mid=(l+r)>>1;
	for (int i=mid;i>=l;--i) {
		for (int j=L-1;j>=0;--j) f[i][j]=(i==mid?0:f[i+1][j]);
		for (int j=L-1;j>=h[i];--j) smax(f[i][j],(i==mid?0:f[i+1][j-h[i]])+w[i]);
	}
	for (int i=mid+1;i<=r;++i) {
		for (int j=L-1;j>=0;--j) f[i][j]=(i==mid+1?0:f[i-1][j]);
		for (int j=L-1;j>=h[i];--j) smax(f[i][j],(i==mid+1?0:f[i-1][j-h[i]])+w[i]);
	}
	int ql=pl-1,qr=pr+1;
	for (int x=pl;x<=pr;++x) tmp[x]=Q[x];
	for (int x=pl;x<=pr;++x) {
		if (tmp[x].L>mid) Q[--qr]=tmp[x];
		else if (tmp[x].R<=mid) Q[++ql]=tmp[x];
		else {
			for (int j=0;j<=tmp[x].t;++j) smax(ans[tmp[x].id],f[tmp[x].L][j]+f[tmp[x].R][tmp[x].t-j]);
		}
	} solve(l,mid,pl,ql); solve(mid+1,r,qr,pr);
}
signed main() {
	read(n, m);
	for (int i=1;i<=n;++i) read(h[i]);
	for (int i=1;i<=n;++i) read(w[i]);
	for (int i=1;i<=m;++i) {
		read(Q[i].L,Q[i].R,Q[i].t); Q[i].id=i;
	} solve(1,n,1,m);
	for (int i=1;i<=m;++i) write(ans[i]);
	return 0;
}
```

---

## 作者：Fa_Nanf1204 (赞：0)

### 分析：
考虑运用猫树的思想，通过分治的方法解决这道题。

观察到 $t$ 很小，所以考虑用背包来转移答案。

将所有询问离线下来，运用整体二分那样的方式，对所有询问整体求解。那么每次分治的时候，考虑跨过 $mid$ 的区间如何处理答案，设 $dp_{i,j}$ 表示当容量为 $j$ 时这一层中编号为 $mid$ 到 $i$ 这个区间的物品所产生的最大贡献，这个处理是 $O(n \log n t)$ 的。

之后考虑如何计算答案，考虑对于每一个跨过当前 $mid$ 的询问区间枚举 $mid$ 左半部分的容量，记为 $x$，则另一半容量为 $t-x$，每次计算答案取最大值即可，记录答案是 $O(mt)$ 的。
### Code:

```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 40005
#define M 200005
using namespace std;
int n,q;
int h[N],w[N],k=1;
int dp[N][205],ans[M];
struct node{
	int l,r,t,id;
}e[M],b[M];
void solve(int l,int r,int L,int R){
	if(l==r){
		for(int j=L;j<=R;j++){
			if(e[j].t>=h[l]) ans[e[j].id]=w[l];
			else ans[e[j].id]=0;
		} 
		return ;
	}
	int mid=l+r>>1;
	for(int i=0;i<h[mid];i++) dp[mid][i]=0; 
	for(int i=h[mid];i<=200;i++){
		dp[mid][i]=w[mid];
	}
	for(int i=mid-1;i>=l;i--){
		for(int t=0;t<=200;t++){
			dp[i][t]=dp[i+1][t];
		}
		for(int t=200;t>=h[i];t--){
			dp[i][t]=max(dp[i][t-h[i]]+w[i],dp[i][t]);
		}
	}
	for(int i=0;i<h[mid+1];i++) dp[mid+1][i]=0; 
	for(int i=h[mid+1];i<=200;i++){
		dp[mid+1][i]=w[mid+1];
	}
	for(int i=mid+2;i<=r;i++){
		for(int t=0;t<=200;t++){
			dp[i][t]=dp[i-1][t];
		}
		for(int t=200;t>=h[i];t--){
			dp[i][t]=max(dp[i][t-h[i]]+w[i],dp[i][t]);
		}
	}
	int cnt1=0,cnt2=0;
	for(int i=L;i<=R;i++){
		if(e[i].r<=mid){
			b[++cnt1]=e[i];
		}
	}
	for(int i=L;i<=R;i++){
		if(e[i].l>mid){
			b[++cnt2+cnt1]=e[i];
		}
	}
	for(int i=L;i<=R;i++){
		if(e[i].l<=mid and e[i].r>mid){
			for(int x=0;x<=e[i].t;x++){
				ans[e[i].id]=max(ans[e[i].id],dp[e[i].l][x]+dp[e[i].r][e[i].t-x]);
			}
		}
	}
	int MID=L+cnt1-1;
	for(int i=L;i<=MID;i++){
		e[i]=b[i-L+1];
	}
	for(int i=MID+1;i<=L+cnt1+cnt2-1;i++){
		e[i]=b[i-L+1];
	}
	solve(l,mid,L,MID);
	solve(mid+1,r,MID+1,L+cnt1+cnt2-1); 
}
int main(){
	cin.tie(),cout.tie(),ios::sync_with_stdio(0);
	cin>>n>>q;
	for(int i=1;i<=n;i++){
		cin>>h[i];
	}
	for(int i=1;i<=n;i++){
		cin>>w[i];
	}
	for(int i=1;i<=q;i++){
		cin>>e[i].l>>e[i].r>>e[i].t;
		e[i].id=i;
	}
	solve(1,n,1,q);
	for(int i=1;i<=q;i++){
		cout<<ans[i]<<'\n';
	}
	return 0;
} 
```

---

## 作者：可爱的小棉羊 (赞：0)

好写的题目。

题意：区间 $01$ 背包。

好的，我们有一个显然的线段树上的暴力。

维护一个在线段树上维护背包，每个节点记录 $[l,r]$ 中体积为 $i$ 时最大价值，那么恭喜你，你得到了一个时间 $O(nt^2+m\log nt^2)$，空间 $O(nt)$ 的做法，复杂度究极螺旋起飞爆炸。

我们是靠为啥炸的那么逆天，不就是合并两个背包（$O(t^2)$）嘛。

意思就是说我们要规避这种~~究极螺旋起飞爆炸~~的合并。

可是你不合并，暴力做啊？！我们又发现一个这样的事实：我们要是询问的区间 $[l,r]$ 合并过程只用两个区间，那么我们设这两个区间维护的上述的信息为 $A_i,B_i$，那么我们只需要知道合并后的一个信息这次询问的体积 $t$ 的最大价值是不是等于 $\max_{i=0}^tA_iB_{t-i}$，$O(t)$ 解决。

那么我们每次就要保证他只由两个区间合并，然后我们就有一个科技可以维护（也不是很科技）：猫树。

我们来看我们的线段树架构：

![](https://cdn.luogu.com.cn/upload/image_hosting/ysncna1l.png)

绿色是端点，红色是 $mid$，线段树告诉我们，一个区间至多分为图上的 $O(\log n)$ 个区间。这个性质多么美好啊，但是 $O(t^2)$ 的合并复杂度把我们打回了现实。

而猫树干了些什么呢？我们考虑这个东西：对于每个节点我们考虑不记录一个节点的信息，而是记录以 $mid$ 开始的前后缀，那么我们查询的时候，这样做：

若左右端点在 $mid$ 两边合并 $O(t)$，否则递归到左右子树上。

还没完，存在一个方法可以 $O(1)$ 查出这个查询会在哪里被计算，也就是说去掉了递归的过程，我们可以 $O(t)$ 解决一个询问。由于之后还有点小优化，使得本题做法与这完全无关，所以不讲 ~~（其实就是不会）~~，可以查询 oi-wiki 自己了解。

我们发现我们把上面那个树要是存下来你就有 $O(nt\log n)$ 的空间啦，直接去世。

别急，又没有强制在线慌啥。

考虑离线，考虑解决所有在 $[l,r]$ 区间的问题，定个 $mid$，然后处理出前后缀，然后在左右两边的递归，否则前后缀合并出答案，空间复用一下就过啦。

这种离线后采用类似猫树的分治树解决静态查询问题的方法称为猫树分治。

我的代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int id,l,r;
	int t;
}Q[200005],b[200005];
int ans[200005],L[40005][205],R[40005][205];
int n,m,h[40005],w[40006];
void solve(int l,int r,int ql,int qr){
	if(l>r)return ;
	
//	for(int i=ql;i<=qr;i++)cout<<Q[i].id<<" ";
//	cout<<"\n";
	int mid=(l+r)>>1,nqr=qr+1,nql=ql-1;
//	cout<<l<<" "<<r<<" "<<mid<<" "<<ql<<" "<<qr<<"\n";
	for(int i=l;i<=r;i++)for(int j=0;j<=200;j++)L[i][j]=R[i][j]=0; 
	for(int i=mid;i>=l;i--){
		for(int j=0;j<=200;j++){
			if(j>=h[i])L[i][j]=max(L[i+1][j-h[i]]+w[i],L[i+1][j]);
			else L[i][j]=L[i+1][j]; 
		}
	} 
	for(int i=mid+1;i<=r;i++)for(int j=0;j<=200;j++){
		if(j>=h[i])R[i][j]=max(R[i-1][j-h[i]]+w[i],R[i-1][j]);
		else R[i][j]=R[i-1][j];
	}
	if(l==r){
		for(int i=ql;i<=qr;i++){
			ans[Q[i].id]=L[Q[i].l][Q[i].t];
		}
		return ;
	}
	for(int i=ql;i<=qr;i++)b[i]=Q[i];
	for(int i=ql;i<=qr;i++){
//		cout<<b[i].id<<" "<<b[i].l<<" "<<b[i].r<<"\n";
		if(b[i].r<=mid){
			Q[++nql]=b[i];
			continue;
		}
		if(b[i].l>=mid+1){
			Q[--nqr]=b[i];
			continue;
		}
//		cout<<b[i].id<<" ";
		int sum=0;
		for(int j=0;j<=b[i].t;j++){
//			cout<<L[Q[i].l][j]+R[Q[i].r][Q[i].t-j]<<"\n";
			sum=max(sum,L[b[i].l][j]+R[b[i].r][b[i].t-j]);
		}
		
		ans[b[i].id]=sum;
	}
//	cout<<"\n";

	
	solve(l,mid,ql,nql);
	solve(mid+1,r,nqr,qr);
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>h[i];
	for(int i=1;i<=n;i++)cin>>w[i];
	for(int i=1;i<=m;i++){
		Q[i].id=i;
		cin>>Q[i].l>>Q[i].r>>Q[i].t;
	}
	solve(1,n,1,m);
	for(int i=1;i<=m;i++)cout<<ans[i]<<"\n";
}

```

---


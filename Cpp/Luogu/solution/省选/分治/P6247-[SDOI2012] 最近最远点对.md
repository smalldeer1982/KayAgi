# [SDOI2012] 最近最远点对

## 题目描述

给定平面直角坐标系上的 $n$ 个点，分别求出距离最近的两个点的距离和距离最远的两个点的距离。注意，距离为直线距离。

## 说明/提示

- 对于 $30\%$ 的数据，$n\leq 2000$；
- 对于 $70\%$ 的数据，$n\leq 20000$；
- 对于 $100\%$ 的数据，$0 \lt n\leq 10^5$，输入数据中所有数均为不超过 $10^9$ 的非负数。

## 样例 #1

### 输入

```
4
0.0 0.0
0.0 1.0
1.0 0.0
1.0 1.0```

### 输出

```
1.00 1.41```

# 题解

## 作者：AIskeleton (赞：78)

我们充分发扬人类智慧：

将所有点按 $x$ 坐标排序。

根据数学直觉，在排序后，最近的两个点在数组中肯定不会离得太远，最远的两个点在数组中肯定不会离得太近。

所以只取每个点向后的 $3$ 个点更新最近距离，并取最后向前的 $13$ 个点更新最远距离。

这样速度快得飞起，直接拿到了此题的最优解。

```cpp
#include<bits/stdc++.h>
using namespace std;
int s1=3,s2=13,n;
double mn=1e20,mx=0;
struct d{double x,y;}a[200005];
bool cmp(d X,d Y){return X.x<Y.x;}
double dis(int n,int m){return (a[n].x-a[m].x)*(a[n].x-a[m].x)+(a[n].y-a[m].y)*(a[n].y-a[m].y);}
int main(){
	cin>>n;for(int i=0;i<n;i++)
    	printf("%lf %lf",&a[i].x,&a[i].y);
    sort(a,a+n,cmp);
	for(int i=0;i<n;i++){
		for(int j=i+1;j<n&&j<i+s1;j++)	mn=min(mn,dis(i,j)); 
		for(int j=n-1;j>=i&&j>=n-s2;j--)	mx=max(mx,dis(i,j)); 
	}printf("%.2lf %.2lf",sqrt(mn),sqrt(mx));
}
```

---

## 作者：ADay (赞：20)

[更好的阅读体验](https://www.cnblogs.com/aday526/p/solution-p6247.html)


> $\text{K-D Tree}$ 很简单。 ——$\texttt{zwj}$

## Solution

一种方法是先把整棵 $\text{K-D Tree}$ 建好，然后再询问每个点的最近最远点（注意剪枝），虽然可以优化建树使空间切割更平均，但是这样每对点会计算两次，常数 $\times 2$。

还可以动态插点，对于每个点，先询问当前 $\text{K-D Tree}$ 中的最近最远点，再插入，就能保证每对点只算一次。

不过可能出题人会卡你这种做法，我们可以玄学优化：随机化插点顺序，效果十分明显。
但总体来说还是第一种好一点（
## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
int n,now,ls[maxn],rs[maxn],rt;
double mxx[maxn],mxy[maxn],mnx[maxn],mny[maxn],ans1=9e18,ans2;
struct node{
	double x,y;
}a[maxn];
void pushup(int u){
	mxx[u]=max(mxx[u],a[now].x);mxy[u]=max(mxy[u],a[now].y);
	mnx[u]=min(mnx[u],a[now].x);mny[u]=min(mny[u],a[now].y);
}
double sqr(double x){
	return x*x;
}
double dis(int u){
	return sqr(a[now].x-a[u].x)+sqr(a[now].y-a[u].y);
}
double mindis(int u){//子树u中最小距离
	return sqr(max(a[now].x-mxx[u],0.0)+max(mnx[u]-a[now].x,0.0))+sqr(max(a[now].y-mxy[u],0.0)+max(mny[u]-a[now].y,0.0));
}
double maxdis(int u){//子树u中最小距离
    return max(sqr(a[now].x-mxx[u]),sqr(mnx[u]-a[now].x))+max(sqr(a[now].y-mxy[u]),sqr(mny[u]-a[now].y));
}
void ins(int &u,bool op){
	if(!u)return u=now,void();
	if(!op)ins(a[now].x<=a[u].x?ls[u]:rs[u],1);
	else ins(a[now].y<=a[u].y?ls[u]:rs[u],0);
	pushup(u);
}
void askmin(int u){
    if(!u)return;
    if(u!=now)ans1=min(ans1,dis(u));
    double l=mindis(ls[u]),r=mindis(rs[u]);
    if(l<r){//剪枝：如果比答案大就不搜了
        if(l<ans1)askmin(ls[u]);
        if(r<ans1)askmin(rs[u]);
    }else{
        if(r<ans1)askmin(rs[u]);
        if(l<ans1)askmin(ls[u]);
    }
}
void askmax(int u){
    if(!u)return;
    ans2=max(ans2,dis(u));
    double l=maxdis(ls[u]),r=maxdis(rs[u]);
    if(l>r){
        if(l>ans2)askmax(ls[u]);
        if(r>ans2)askmax(rs[u]);
    }else{
        if(r>ans2)askmax(rs[u]);
        if(l>ans2)askmax(ls[u]);
    }
}
int main(){
    srand(20201213);//今天
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
        scanf("%lf%lf",&a[i].x,&a[i].y);
    random_shuffle(a+1,a+n+1);
    for(int i=1;i<=n;i++){
        mxx[i]=mnx[i]=a[i].x;
        mxy[i]=mny[i]=a[i].y;
        now++;askmin(rt);askmax(rt);ins(rt,0);
    }printf("%.2lf %.2lf\n",sqrt(ans1),sqrt(ans2));
	return 0;
}
```

管理员大大辛苦了！

---

## 作者：myee (赞：10)

### 前言

其实这题做法蛮多，本质就是[P1429](https://www.luogu.com.cn/problem/P1429)与[P1452](https://www.luogu.com.cn/problem/P1452)的结合。

两题都可以乱搞，因此我们谈一谈**如何乱搞过这题**。

**最正规的做法是分治**，但这**需要一定的计算几何技巧**。

**最正规的乱搞做法是KDT**，但这只是期望复杂度可行，**实际最坏复杂度依旧会挂**。

因此我们还要**发扬人类智慧**，了解**非常规**的乱搞做法——**随机化**。

---
---
### 乱搞做法

#### Part 1 平面最近点对

先考虑贪心。

我们把下标以 $x$ 为关键字，从小到大排序（可以使用`STL`自带的`std::pair`，[OI wiki资料](https://oi-wiki.net/lang/csl/pair/)），
然后仅计算**每个点与下一个点的距离**，计入答案。

这显然是个假做法，[反例](https://www.luogu.com.cn/paste/hwz62ds2)。

考虑仅计算**每个点与下 $d$ 个点的距离**（$d$ 是一个你自己定的小常数，取 $5-10$ 即可），计入答案，正确率大大提高（一个小细节：不要自己和自己求距离）。

但如果出题人刻意卡你咋办？

考虑随机化调整数据，譬如每个点绕原点旋转某个相同角度啥的（[怎么进行向量旋转？](https://oi-wiki.net/math/vector/#_24)）。

如果不放心，**多跑几遍**旋转＋贪心，正确率更高，但通常没必要。

利用随机化提高贪心正确率，称作**随机化贪心算法**，简称**随贪**。

随贪习题：
* [P1284 三角形牧场](https://www.luogu.com.cn/problem/P1284)。[随贪题解](https://www.luogu.com.cn/blog/firstfan/solution-p1284)。
* [P2392 kkksc03考前临时抱佛脚](https://www.luogu.com.cn/problem/P2392)。

#### Part 2 平面最远点对（凸包直径）

你依旧可以沿用上题方法，但是 $d$ 应调到 $100$ 左右，取 $\max$。

不过还有一种非常妙的随机化做法，即**随机化反复迭代**。

先随机取一些点（迭代点），求出其与所有点的距离，取最远的更新答案同时以其更新并以此点更新迭代点继续迭代，详见代码。

---
---
### Code

其实是把两题拼起来的代码，所以有点乱（

带一个`double`快读模板。

```cpp
#include <algorithm>
#include <math.h>
#include <random>
#include <stdio.h>
typedef long long llt;
typedef unsigned uint;typedef unsigned long long ullt;
typedef bool bol;typedef char chr;typedef void voi;
typedef double dbl;
template<typename T>bol _max(T&a,T b){return(a<b)?a=b,true:false;}
template<typename T>bol _min(T&a,T b){return(b<a)?a=b,true:false;}
std::pair<dbl,dbl>P[100000];dbl X[100000],Y[100000];
dbl d(dbl x1,dbl y1,dbl x2,dbl y2){return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));}
dbl read()
{
    dbl x=0,t=0;int s=0,f=1;chr c;
    do c=getchar();while((c<'0'||c>'9')&&c!='-'&&c!='.');
    if(c=='-')f=-1,c=getchar();
    while(c>='0'&&c<='9'&&c!='.')x=c-'0'+x*10,c=getchar();
    if(c=='.')c=getchar();else return x*f;
    while(c>='0'&&c<='9')t=t*10+c-'0',++s,c=getchar();
    while(s--)t/=10;return(x+t)*f;
}
const dbl alpha=1.14514;
int main()
{
    const dbl SIN=sin(alpha),COS=cos(alpha);
    std::mt19937 rng(19260817);
    uint n,p,q;dbl ans=1145141919810,wil;scanf("%u",&n);
    for(uint i=0;i<n;i++)X[i]=read(),Y[i]=read(),P[i].first=X[i]*COS-Y[i]*SIN,P[i].second=X[i]*SIN+Y[i]*COS;
    std::sort(P,P+n);
    for(uint i=0;i<n;i++)
        for(uint j=1;j<=5&&i+j<n;j++)
            _min(ans,d(P[i].first,P[i].second,P[i+j].first,P[i+j].second));
    printf("%.2lf ",ans);
    for(uint w=0;w<8;w++)
    {
        q=p=rng()%n;
        for(uint t=0;t<5;t++)
        {
            wil=0;
            for(uint i=0;i<n;i++)if(_max(wil,d(X[p],Y[p],X[i],Y[i])))q=i;
            _max(ans,wil);
            p=q;
        }
    }
    printf("%.2lf\n",ans);
	return 0;
}
```


---

## 作者：望月Asta (赞：9)

## 题意

给定二维平面上的 $n$ 个点，分别求出最近点对和最远点对的欧几里得距离。

## 解法

这道题可以看作把两个题缝合在一起了。

[P1429 平面最近点对（加强版）](https://www.luogu.com.cn/problem/P1429) 和 [P1452 \[USACO03FALL\]Beauty Contest G /【模板】旋转卡壳](https://www.luogu.com.cn/problem/P1452)。

### 求最近点对

使用 **分治** 来求解。

首先按 $x$ 为第一关键字 $y$ 为第二关键字将所有点排序。

令 `solve(l,r)` 表示求第 $l$ 到第 $r$ 个点范围内的最近点对子问题。

首先考虑边界情况，对于 $[l,r]$ 区间较小的时候直接暴力枚举，防止递归过多损失效率。

然后考虑对于 $[l,mid]$ 和 $[mid + 1,r]$ 两个区间处理完毕后如何合并答案，此时只需要考虑一个点在 $[l,mid]$ 另一个点在 $[mid + 1,r]$ 的点对。

首先 $[l,r]$ 这个区间点已经按照坐标排序，令目前求得两点最近距离为 $d$,则只需要考虑 $x \in [x_{mid} - d,x_{mid} + d]$ 的点即可。

然后把这个区间内所有的点再以纵坐标排序然后枚举点对，每次当 $(i,j)$ 距离超过 $d$ 时停止对于 $i$ 的枚举。

可以使用鸽巢原理证明对于每个在 $[x_{mid} - d,x_{mid} + d]$ 内的点 $i$ ，满足距离不超过 $d$ 的点 $j$ 不超过 $6$ 个.

然后是复杂度分析 ：

如果在合并时按纵坐标排序使用的是 `std::sort`，有 ： 

$$

T(n) = 2T(\frac{n}{2}) + \mathcal{O} ( n \log n) = \mathcal{O} (n \log^2 n)

$$

但是如果以纵坐标为关键字归并排序即可实现 ： 

$$

T(n) = 2T(\frac{n}{2}) + \mathcal{O} ( n) = \mathcal{O} (n \log n)

$$

这个过程可以使用 `std::merge` 实现，比手写归并过程方便一些。

### 求最远点对

使用 **旋转卡壳** 来求解。

此题数据非常靠谱，实现有小问题的旋转卡壳是无法通过的。

首先对于最远点对，一定在这些点形成的凸包上，先求出凸包，然后这个问题转化为求凸包直径。

求出凸包后，我们得到按照逆时针排列的凸包上点的序列。

然后按照逆时针枚举凸包上的边，此时可以发现距离当前枚举到的边最远的点也是在凸包上逆时针旋转的。

令枚举到的边为 $(i,i + 1)$，维护的最远点为 $j$，每次判断 $(i,i + 1)$ 到 $j + 1$ 的距离是否大于 $(i,i + 1)$ 到 $j$ 的距离，如果成立则将 $j$ 加一，否则点 $j$ 就是对于 $(i,i + 1)$ 最优的，可以枚举下一条边，这个过程中更新答案即可。

点到边距离大小关系可以通过计算 $i,i + 1,j$ 三个点形成的三角形面积和 $i,i + 1,j + 1$ 三个点形成的三角形面积来判断，可以使用向量外积简便地求面积。

分治和求凸包复杂度均为 $\mathcal{O} (n \log n)$ 于是总体复杂度为 $\mathcal{O} (n \log n)$。

比 KD-Tree 快。

## 代码

```cpp
struct Node {
	double x,y;
	inline bool operator < (const Node &oth) const {
		return (x != oth.x) ? x < oth.x : y < oth.y;
	}
	
	inline Node operator + (const Node &oth) const {
		return (Node) {x + oth.x,y + oth.y};
	}
	
	inline Node operator - (const Node &oth) const {
		return (Node) {x - oth.x,y - oth.y};
	}
	
	inline double operator * (const Node &oth) const {
		return x * oth.y - y * oth.x;
	}
}p[N];

#define sq(x) ((x) * (x))
inline double dist(const Node &a,const Node &b) {
	return std::sqrt(sq(a.x - b.x) + sq(a.y - b.y));
}

int stk[N];
bool vis[N];

inline int Andrew(int n) {
	mems(vis,0);
	std::sort(p + 1,p + n + 1);
	int top = 0;
	stk[++top] = 1;
	for(int i = 2;i <= n;++i) {
		while(top >= 2 && ((p[stk[top]] - p[stk[top - 1]]) * (p[i] - p[stk[top]]) < 0))
			vis[stk[top--]] = 0;
		vis[i] = 1;
		stk[++top] = i;
	}
	int tmp = top;
	for(int i = n - 1;i >= 1;--i) if(!vis[i]) {
		while(top > tmp && (p[stk[top]] - p[stk[top - 1]]) * (p[i] - p[stk[top]]) < 0)
			vis[stk[top--]] = 0;
		vis[i] = 1;
		stk[++top] = i;
	}
	stk[0] = stk[top];
	return top;
}

inline double sqr(const Node &a,const Node &b,const Node &c) {
	return std::abs((b - a) * (c - b));
}

inline double RotatingCalipers(int n) {
	double ans = 0;int j = 3;
	if(n <= 3)
		return std::max(dist(p[stk[1]],p[stk[2]]),dist(p[stk[0]],p[stk[1]]));
	for(int i = 1;i < n;++i) {
		while(sqr(p[stk[i]],p[stk[i + 1]],p[stk[j]]) <= sqr(p[stk[i]],p[stk[i + 1]],p[stk[j % n + 1]]))
			j = j % n + 1;
		ans = std::max(ans,std::max(dist(p[stk[i]],p[stk[j]]),dist(p[stk[i + 1]],p[stk[j]])));
	}
	return ans;
}

inline bool cmpy(const Node &a,const Node &b) {
	return a.y < b.y;
}

double ans = 1e10;
inline void update(int x,int y) {
	ans = std::min(ans,std::sqrt(sq(p[x].x - p[y].x) + sq(p[x].y - p[y].y)));
}

void solve(int l,int r) {
	if(r - l <= 3) {
		for(int i = l;i <= r;++i) for(int j = i + 1;j <= r;++j)
			update(i,j);
		std::sort(p + l,p + r + 1,cmpy);
		return;
	}
	int mid = (l + r) >> 1;double midx = p[mid].x;
	solve(l,mid),solve(mid + 1,r);
	static Node tmp[N];
	std::merge(p + l,p + mid + 1,p + mid + 1,p + r + 1,tmp,cmpy);
	std::copy(tmp,tmp + r - l + 1,p + l);
	int siz = 0;static int q[N];
	for(int i = l;i <= r;++i) if(std::abs(p[i].x - midx) < ans) {
		for(int j = siz;j >= 1;--j) {
			if(p[i].y - p[q[j]].y >= ans) break;
			update(i,q[j]);
		}
		q[++siz] = i;
	}
}
```

---

## 作者：critnos (赞：7)

2020.4.9

~~233又水了一道蓝题~~

看着是不是和 P1429 平面最近点对（加强版）很像？

没错几乎一样，就是多了一个求最大值。

那道题我也写了一篇题解 ~~，可惜没人看~~ 。

https://www.luogu.com.cn/blog/2-6-5-3-5/solution-p1429

大意是：按 $x$ 坐标排序，按照直觉相近的点应该靠在一起。然后每个点往后取 $s$ 个点/从最后起取 $s$ 个点，比较距离，更新最大/最小值。$s$ 是个常数。P1429 的数据较弱，$s$ 取 $4$ 就行。这道题 $s$ 最小取 $13$。

然后我卡常卡不过 Fee，只拿了 rank2。

（其实 Fee 的做法还要旋转，这样正确率高一些，虽说带 $\sin,\cos$ 的常数。）

```cpp
#include<bits/stdc++.h>
#define max(a,b) a>b?a:b
#define min(a,b) a<b?a:b
using namespace std;
const int s=13;
struct note
{
	double x,y;
	friend bool operator<(const note &qwq,const note &qaq)
	{
		return qwq.x<qaq.x;
	}
}a[200005];
int main()
{
	register int i,j,n;
	register double mn=1e20,mx=0;
	scanf("%d",&n);
	for(i=0;i<n;i++)
		scanf("%lf%lf",&a[i].x,&a[i].y); 
	sort(a,a+n);
	for(i=0;i<n;i++)
	{
		for(j=i+1;j<n&&j<i+s;j++)
			mn=min(mn,(a[i].x-a[j].x)*(a[i].x-a[j].x)+(a[i].y-a[j].y)*(a[i].y-a[j].y)); 
		for(j=n-1;j>=i&&j>=n-s;j--)
			mx=max(mx,(a[i].x-a[j].x)*(a[i].x-a[j].x)+(a[i].y-a[j].y)*(a[i].y-a[j].y)); 
	}
	printf("%.2f %.2f",sqrt(mn),sqrt(mx));
} 
```


---

## 作者：zhengrunzhe (赞：6)

K-D Tree板子题 学习见[我的kdtree见解](https://www.luogu.com.cn/blog/van/qian-tan-pian-xu-wen-ti-yu-k-d-tree)

首先如果有相同坐标的点之间开个set或者map判重

然后根据估价函数套板子就好了 详解就点开链接看吧

至于原理就像树上A*，优化的暴力，通过估价函数(查询点当前子树可能的最小/最大值)来判断答案有没有可能在子树中以实现剪枝

时间复杂度:$O(n\sqrt n)$ 不过是很容易卡掉了 因为这玩意很玄学
```cpp
#include<set>
#include<cmath>
#include<cstdio>
#include<algorithm>
using std::set;
using std::pair;
using std::make_pair;
using std::nth_element;
const int k(2),N(1e5+5);
typedef double dbl;
const dbl inf(1e9);
template<class type>inline const type max(const type &a,const type &b){return a>b?a:b;}
template<class type>inline const type min(const type &a,const type &b){return a<b?a:b;}
bool f;
inline const dbl sqr(const dbl &x){return x*x;}
struct point
{
	dbl d[k];
	inline point(){}
	inline point(const dbl &x,const dbl &y){d[0]=x;d[1]=y;}
	inline const bool operator<(const point &p)const
	{
		if (d[f]!=p.d[f])return d[f]<p.d[f];
		for (int i(0);i<k;i++)if (d[i]!=p.d[i])return d[i]<p.d[i];
		return 0;
	}
	inline const bool operator!=(const point &p)const
	{
		for (int i(0);i<k;i++)if (d[i]!=p.d[i])return 1;
		return 0;
	}
	inline const friend dbl distance(const point &x,const point &y)
	{
		dbl dis(0);
		for (int i(0);i<k;i++)dis+=sqr(x.d[i]-y.d[i]);
		return dis;
	}
}a[N];
dbl ans_min(inf),ans_max;
struct tree
{
	point range,mn,mx;
	tree *son[2];
	static tree *null;
	void *operator new(size_t size);
	inline tree()
	{
		son[0]=son[1]=null;
	}
	inline tree(const point &p):range(p),mn(p),mx(p)
	{
		static bool init(0);
		if (!init)
			init=1,
			null=new tree,
			null->son[0]=null->son[1]=null,
			null->mn.d[0]=null->mn.d[1]=inf;
		son[0]=son[1]=null;
	}
	inline const void pushup()
	{
		for (int i(0);i<k;i++)
			mx.d[i]=max(range.d[i],max(son[0]->mx.d[i],son[1]->mx.d[i])),
			mn.d[i]=min(range.d[i],min(son[0]->mn.d[i],son[1]->mn.d[i]));
	}
	inline const dbl evalue_min(const point &p)
	{
		if (this==null)return inf;
		dbl f(0);
		for (int i(0);i<k;i++)
			f+=sqr(max(mn.d[i]-p.d[i],0.0))+sqr(max(p.d[i]-mx.d[i],0.0));
		return f;
	}
	inline const dbl evalue_max(const point &p)
	{
		if (this==null)return 0;
		dbl f(0);
		for (int i(0);i<k;i++)
			f+=max(sqr(mn.d[i]-p.d[i]),sqr(mx.d[i]-p.d[i]));
		return f;
	}
	inline const void query_min(const point &p)
	{
		if (this==null)return;
		if (p!=range)ans_min=min(ans_min,distance(range,p)); //先判一下当前节点是不是代表着查询点自己
		const dbl f[k]={son[0]->evalue_min(p),son[1]->evalue_min(p)};
		const bool t(f[0]>=f[1]);
		if (f[t]<ans_min)son[t]->query_min(p);
		if (f[!t]<ans_min)son[!t]->query_min(p);
	}
	inline const void query_max(const point &p)
	{
		if (this==null)return;
		ans_max=max(ans_max,distance(range,p)); //最大值不用判因为查到自己没影响
		const dbl f[k]={son[0]->evalue_max(p),son[1]->evalue_max(p)};
		const bool t(f[0]<=f[1]);
		if (f[t]>ans_max)son[t]->query_max(p);
		if (f[!t]>ans_max)son[!t]->query_max(p);
	}
}*root,*tree::null;
#define null tree::null
char memory_pool[N*sizeof(tree)],*tail(memory_pool+sizeof memory_pool);
inline void *tree::operator new(size_t size){return tail-=size;}
inline tree *build(const int &l,const int &r,const bool &d)
{
	if (l>r)return null;
	const int mid(l+r>>1);f=d;
	nth_element(a+l,a+mid,a+r+1);
	tree *p(new tree(a[mid]));
	if (l==r)return p;
	p->son[0]=build(l,mid-1,!d);
	p->son[1]=build(mid+1,r,!d);
	p->pushup();
	return p;
}
set<point>s;
int n;
int main()
{
	scanf("%d",&n);
	for (int i(1);i<=n;i++)
	{
		for (int j(0);j<k;j++)scanf("%lf",&a[i].d[j]);
		if (!s.insert(a[i]).second)ans_min=0;
	}
	root=build(1,n,0);
	if (ans_min)for (int i(1);i<=n;i++)root->query_min(a[i]); //有重点就不用再去算了
	for (int i(1);i<=n;i++)root->query_max(a[i]);
	printf("%.2f %.2f\n",sqrt(ans_min),sqrt(ans_max));
	return 0;
}
```

---

## 作者：feecle6418 (赞：6)

大概是模板题？

两问都可以 K-D Tree 然而我选择随机旋转坐标系。好写，跑得飞快。

随机旋转 $5$ 次坐标系然后找横坐标相邻的 $10$ 个点更新答案。最远点，就选横坐标最远的 $100$ 个更新。

看似很不靠谱？实际上正确率贼高，反正我从没见他错过。

注意开 `double`。。。我之前没开 `double` WA 了四发。

目前加上快读是 Rank 1。

有 `freopen` 并且有很多多余数组（因为懒得删）的代码：

```cpp
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<ctime>
#include<cstdio>
using namespace std;
int n,st[100005],top;
double xx[100005],yy[100005];
struct Point2{
	double x,y;
	bool operator <(const Point2 yy) const {
		return x<yy.x;
	}
}a[100005];
double anss=1e20,ans=0;
double Dist(Point2 i,Point2 j){
	return sqrt((i.x-j.x)*(i.x-j.x)+(i.y-j.y)*(i.y-j.y));
}
void Calc(int arg){
	for(int i=1;i<=n;i++){
		double x=a[i].x,y=a[i].y;
		a[i].x=cos(arg)*x-sin(arg)*y;
		a[i].y=sin(arg)*x+cos(arg)*y;
	}
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=i+100&&j<=n;j++)anss=min(anss,Dist(a[i],a[j]));
	}
	for(int i=1;i<=10;i++){
		for(int j=n-9;j<=n;j++)ans=max(ans,Dist(a[i],a[j]));
	}
}
int main() {
	freopen("P6247_1.in","r",stdin);
	srand(time(0));
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%lf%lf",&a[i].x,&a[i].y),xx[i]=a[i].x,yy[i]=a[i].y;
	Calc(0);
	Calc(rand()%360);
	Calc(rand()%360);
	Calc(rand()%360);
	printf("%.5lf ",anss);
	printf("%.5lf\n",ans);
	return 0;
}
```

---

## 作者：seajupiter (赞：5)

最小距离是可以用kd-tree解决的经典模型，但是这道题还要求一个最大距离，该怎么求呢？

仿照求最小距离的估价函数，可以写出一个最大距离的估价函数，即

$maxdis(p)=\sqrt{\sum\limits_{i=0}^{degree}max((p_i-mn_i)^2,\ (p_i-mx_i)^2)}$

然后就可以和求最小距离一样地去求了。

还有一个细节问题：如果提前就把整棵树建好，求最小距离的时候，会收到自己的影响。一种解决办法是在写的过程中注意一点，把这个影响消除；但是我采用了另一种方法，自认为更好写（~~跑的也挺快的~~）：**动态插入点，先查询当前点和之前已经插入的点的贡献，再插入当前点。**

然而肯定是懒得去写替罪羊重构的啦，可以采用另一种方法—— random_shuffle 随机打乱。众所周知，在随即情况下，二叉查找树的效率是很高的；类似地，把插入点的顺序随机打乱，kd-tree的~~期望~~效率也很高，可以通过此题。

下面是代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef double db;
const int N=1e5+5, DG=2;
const db inf=4e18;
int n;
db min_ans=inf, max_ans=-inf;
struct point{
	db x[DG];
	inline point(){
		for(int i=0; i<DG; ++i)
			x[i]=0;
	}
	inline void init(){
		for(int i=0; i<DG; ++i)
			scanf("%lf", &x[i]);
	}
}p[N];
inline db dist(const point &a, const point &b){
	db ans=0;
	for(int i=0; i<DG; ++i)
		ans+=(a.x[i]-b.x[i])*(a.x[i]-b.x[i]);
	return ans;
}
struct kdt{
	private:
		db mi_ans, ma_ans;
		point p[N], mi[N], ma[N], _p;
		int tot, rt, ls[N], rs[N];
		inline int nw(const point &_p){
			p[++tot]=_p;
			for(int i=0; i<DG; ++i)
				mi[tot].x[i]=ma[tot].x[i]=_p.x[i];
			ls[tot]=rs[tot]=0;
			return tot;
		}
		inline void upd(int u, const point &_p){
			for(int i=0; i<DG; ++i){
				mi[u].x[i]=min(mi[u].x[i], _p.x[i]);
				ma[u].x[i]=max(ma[u].x[i], _p.x[i]);
			}
		}
		inline void ins(int &u, bool d){
			if(!u) return void(u=nw(_p));
			ins(_p.x[d]<=p[u].x[d]?ls[u]:rs[u], d^1);
			upd(u, _p);
		}
		inline db min_dis(int u, const point &_p){
			if(!u) return inf;
			db dis=0;
			for(int i=0; i<DG; ++i){
				db tmp=max(_p.x[i]-ma[u].x[i], 0.0)
					+max(mi[u].x[i]-_p.x[i], 0.0);
				dis+=tmp*tmp;
			}
			return dis;
		}
		inline db max_dis(int u, const point &_p){
			if(!u) return -inf;
			db dis=0;
			for(int i=0; i<DG; ++i){
				db tmp=max(fabs(_p.x[i]-ma[u].x[i]), fabs(mi[u].x[i]-_p.x[i]));
				dis+=tmp*tmp;
			}
			return dis;
		}
		inline void query_min(int u){
			if(!u) return;
			mi_ans=min(mi_ans, dist(p[u], _p));
			db lv=min_dis(ls[u], _p), rv=min_dis(rs[u], _p);
			if(lv>rv){
				if(rv<mi_ans) query_min(rs[u]);
				if(lv<mi_ans) query_min(ls[u]);
			}
			else{
				if(lv<mi_ans) query_min(ls[u]);
				if(rv<mi_ans) query_min(rs[u]);
			}
		}
		inline void query_max(int u){
			if(!u) return;
			ma_ans=max(ma_ans, dist(p[u], _p));
			db lv=max_dis(ls[u], _p), rv=max_dis(rs[u], _p);
			if(lv<rv){
				if(rv>ma_ans) query_max(rs[u]);
				if(lv>ma_ans) query_max(ls[u]);
			}
			else{
				if(lv>ma_ans) query_max(ls[u]);
				if(rv>ma_ans) query_max(rs[u]);
			}
		}
	public:
		inline void ins(const point &P){
			_p=P;
			ins(rt, 0);
		}
		inline db ask_min(const point &P){
			_p=P;
			mi_ans=inf;
			query_min(rt);
			return mi_ans;
		}
		inline db ask_max(const point &P){
			_p=P;
			ma_ans=-inf;
			query_max(rt);
			return ma_ans;
		}
}tr;
int main(){
	scanf("%d", &n);
	for(int i=1; i<=n; ++i)
		p[i].init();
	srand(time(0));
	random_shuffle(p+1, p+1+n);
	for(int i=1; i<=n; ++i){
		min_ans=min(min_ans, tr.ask_min(p[i]));
		max_ans=max(max_ans, tr.ask_max(p[i]));
		tr.ins(p[i]);
	}
	printf("%.4lf %.4lf\n", sqrt(min_ans), sqrt(max_ans));
	return 0;
}
```


---

## 作者：SAMSHAWCRAFT (赞：4)

这道题好像题解区被 KDT 占领了，但是 KDT 时间复杂度是 $O(n\sqrt n)$ 的，我来写一个时间复杂度 $O(n\log^2 n)$ 的做法（并且可以稍作改动变成 $O(n\log n)$ 的）。

关键词：分治、凸包、旋转卡壳。

题意是给定平面直角坐标系上若干点，求任意两点间距离的最小值和最大值。这题很显然是两道经典题的缝合题，一道是[平面最近点对](https://www.luogu.com.cn/problem/P7883)，一道是[[USACO03FALL]Beauty Contest G /【模板】旋转卡壳](https://www.luogu.com.cn/problem/P1452)，下面我对这两个部分分别讲解。

在讲解之前，我要先把这道计算几何题需要的函数和结构体（点和向量）放出来：

```cpp
int sgn(long double x){
  if(std::fabs(x)<eps) return 0;
  return x<0?-1:1;
}
long double hypot(long double x,long double y){
  return std::sqrt(x*x+y*y);
}
struct point{
  long double x,y;
  point operator+(const point &a)const{ return point{x+a.x,y+a.y}; }
  point operator-(const point &a)const{ return point{x-a.x,y-a.y}; }
  bool operator==(const point &a)const{
    return sgn(x-a.x)==0&&sgn(y-a.y)==0;
  }
  bool operator<(const point &a)const{
    return sgn(x-a.x)<0||(sgn(x-a.x)==0&&sgn(y-a.y)<0);
  }
  long double dist(const point &a){
    return hypot(x-a.x,y-a.y);
  }
}f0[sz],f1[sz],g[sz],mgbuf[sz];
struct vector:virtual public point{
  vector(point a){ x=a.x,y=a.y; }
  long double operator*(const vector &a){
    return x*a.y-y*a.x;
  }
};
```

**平面最近点对**

使用分治的方法求解。先把所有的点对按照 x 坐标从小到大排序，然后进行递归分治，递归到只有一个点时停止（注意细节：此时程序应返回 $+\infty$），之后两个分治的区间合并是一个难点，我们除了得到左右两个分治区间内部的最近点对距离 $d$ 之外，两区间交界附近的点也有可能成为最近点对，因此我们选取两个分治区间的分界处的点 $P$，之后在这个区间中暴力寻找和点 $P$ 的 $x$ 坐标相差的绝对值不超过 $d$ 的点，将这些点放入一个数组中，这些点的 $x$ 坐标和 $P$ 相近，接下来再把这些点按 $y$ 坐标排序，暴力枚举所有的和 $P$ 的 $y$ 坐标相差的绝对值不超过 $d$ 的点，更新 $d$ 即可，最终函数返回 $d$ 即可。

```cpp
long double getNearest(int ln,int rn,point *f){
  if(ln>=rn) return finf;
  int mid=(ln+rn)>>1;
  long double d=std::min(getNearest(ln,mid,f),getNearest(mid+1,rn,f));
  int mgpp=0;
  for(int cx=ln;cx<=rn;++cx)
    if(std::fabs(f[mid].x-f[cx].x)<d)
      mgbuf[mgpp]=f[cx],mgpp++;
  std::sort(mgbuf,mgbuf+mgpp,[](point a,point b){
              return sgn(a.y-b.y)<0;
            });
  for(int cx=0;cx<mgpp;++cx){
    for(int cy=cx+1;cy<mgpp;++cy){
      if(std::fabs(mgbuf[cy].y-mgbuf[cx].y)>d) break;
      d=std::min(d,mgbuf[cx].dist(mgbuf[cy]));
    }
  }
  return d;
}
```

**平面最远点对**

我们知道，平面最远点对一定在平面所有点构成的凸包上，寻找最远点对，只需在凸包上从最靠近左下方的点开始逆时针依次枚举所有的边，然后不断迭代，不断更新结果，继续逆时针寻找最远的点，直到凸包上的边全部被枚举完毕即可。

```cpp
int convexHull(int n,point *f,point *g){
  std::sort(f,f+n);
  n=std::unique(f,f+n)-f;
  int v=0;
  for(int cx=0;cx<n;++cx){
    while(v>1&&sgn(vector(g[v-1]-g[v-2])*vector(f[cx]-g[v-2]))<=0) v--;
    g[v]=f[cx],v++;
  }
  int upc=v;
  for(int cx=n-2;~cx;--cx){
    while(v>upc&&sgn(vector(g[v-1]-g[v-2])*vector(f[cx]-g[v-2]))<=0) v--;
    g[v]=f[cx],v++;
  }
  if(n>1) v--;
  return v;
}
long double getDiameter(int n,point *f){
  long double d=-1;
  int cur=2;
  if(n<3) return f[0].dist(f[1]);
  for(int cx=0;cx<n;++cx){
    while(std::fabs(vector(f[cx+1]-f[cx])*vector(f[cur]-f[cx+1]))
          <=std::fabs(vector(f[cx+1]-f[cx])*vector(f[cur%n+1]-f[cx+1])))
      cur=cur%n+1;
    d=std::max({d,f[cx+1].dist(f[cur]),f[cx].dist(f[cur])});
  }
  return d;
}
```

做完这两部分之后，主函数其实非常简单，直接调用刚刚写的函数即可。

```cpp
int main(){
  std::cin.tie(nullptr)->sync_with_stdio(false);
  std::cout.tie(nullptr)->sync_with_stdio(false);
  std::cin>>n;
  for(int cx=0;cx<n;++cx)
    std::cin>>f0[cx].x>>f0[cx].y;
  std::copy(f0,f0+n,f1);
  std::sort(f0,f0+n);
  long double mnans=getNearest(0,n-1,f0);
  int v=convexHull(n,f1,g);
  long double mxans=getDiameter(v,g);
  std::cout<<std::setprecision(6)<<std::fixed;
  std::cout<<mnans<<' '<<mxans<<std::endl;
  return 0;
}
```

**复杂度分析**

我求平面最近点对时，一共分治了 $O(\log n)$ 层，每层用 `std::sort` 排序 $O(n\log n)$，对于暴力，由于我们向上合并分治区间时，$d$ 会不断更新而变小，由鸽巢原理，每次暴力的点个数是 $O(1)$ 级别的，因此暴力部分是 $O(1)$ 的，因此平面最近点对总时间复杂度可以由 $T(n)=2T(\frac n 2)+O(n\log n)$ 得到，即 $O(n\log^2 n)$，如果想要精细实现，可以使用归并排序，这样的话由 $T(n)=2T(\frac n 2)+O(n)$ 我们可以得到 $O(n\log n)$ 的复杂度更优解法。

我求平面最远点对时，求凸包的 `convexHull` 函数是 $O(n\log n)$ 的，瓶颈来自 `std::sort`，旋转卡壳的 `getDiameter` 函数是 $O(n)$ 的，所以这部分复杂度 $O(n\log n)$。

因此本题的本解法总时间复杂度 $O(n\log^2n)$。

另附：[提交记录](https://www.luogu.com.cn/record/75408023)，想要完整代码可以找我。

---

## 作者：_lfxxx_ (赞：3)

**题目传送门：[P6247 [SDOI2012]最近最远点对](https://www.luogu.com.cn/problem/P6247)**

建议先去做[P1429 平面最近点对（加强版）](https://www.luogu.com.cn/problem/P1429)再来做这题。

这题跟[P1429](https://www.luogu.com.cn/problem/P1429)唯一的区别就是要多求出距离最远的两个点的距离，那就在原来基础上加一个求最大的就好了。（ $n\le10^5$ ，数组还可以开小一点（P1429是 $2\times10^5$ ））。

稍微讲一下随机贪心的思路：将所有点按 $x$ 排序，大概率相邻的距离最小，之后可以旋转几次图再重复上述操作。（需要用到坐标旋转公式）如果想具体了解可以去P1429的题解区看一看。

这种做法虽然不稳定，但是正确率也算是很高了。
### 代码：
```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<ctime>
const double pi=atan(1)*4;
struct point{
	double x,y;
}p[100001];
inline bool cmp(point a,point b){
	return a.x<b.x;
}
double ansa=1e15,ansn;
int n;
void around(double t){
	t=t/180*pi;
	for(register int i=1;i<=n;i++){
		double x=p[i].x,xx,y=p[i].y,yy;
		xx=x*cos(t)-y*sin(t);
		yy=x*sin(t)+y*cos(t);
		p[i].x=xx;
		p[i].y=yy;
	}
	std::sort(p+1,p+1+n,cmp);
	for(register int i=1;i<n;i++)
		for(register int j=i+1;j<=std::min(i+100,n);j++)
			ansa=std::min(ansa,(p[i].x-p[j].x)*(p[i].x-p[j].x)+(p[i].y-p[j].y)*(p[i].y-p[j].y));//最大
	for(register int i=1;i<=std::min(n,100);i++)
		for(register int j=std::max(1,n-100);j<=n;j++)
			ansn=std::max(ansn,(p[i].x-p[j].x)*(p[i].x-p[j].x)+(p[i].y-p[j].y)*(p[i].y-p[j].y));//最小
}//往后找了100个数（貌似不需要这么多）
int main(){
	srand(time(NULL));
	scanf("%d",&n);
	for(register int i=1;i<=n;i++)
		scanf("%lf%lf",&p[i].x,&p[i].y);
	around(0);
	around(rand()%360);
	around(rand()%360);
	around(rand()%360);//随机转
	printf("%.2lf %.2lf",sqrt(ansa),sqrt(ansn));
	return 0;
}
```
最慢的一个点不到 $400ms$ ，可以算是比较快了。

---

## 作者：破忆 (赞：2)

## 【题意】
在n个点中找最远、最近点对

## 【分析】
如果做过 [P1429](https://www.luogu.com.cn/problem/P1429) 你就知道此题和旋转有关

那么第一问就是模板了

对于最近点对来说，从某个角度看他们，他们是相靠近的

视角的转换可以通过旋转坐标模拟

最远点对也是类似的做法

从某个角度看他们，他们在视野两边

这题数据过水，直接排序枚举就过了

但我们追求的不仅仅是这样

因为旋转的角度是随机的，实际上无法保证正确性

所以只能通过多枚举角度提高正确性

这里提供一些较优的小技巧


## 【算法】
旋转

## 【代码】

```cpp
#include<bits/stdc++.h>
#define DB double
using namespace std;
const int maxn=1e5+5,maxh=maxn<<1;
int n;
struct data{
	DB x,y;
}p[maxn],a[maxn];
bool cmp1(data x,data y){
	return x.x<y.x||(x.x==y.x&&x.y<y.y);
}
DB ans1=1e20,ans2;
DB sqr(DB x){return x*x;}
DB dis(data x,data y){return sqr(x.x-y.x)+sqr(x.y-y.y);}
int main(){
	freopen("P6247.in","r",stdin);
	freopen("P6247.out","w",stdout);
	srand(20050205);
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%lf%lf",&p[i].x,&p[i].y);
	int len=sqrt(n);
	while((DB)clock()/CLOCKS_PER_SEC<0.9){//卡个时把时间利用到极致
		DB r=(DB)rand()/RAND_MAX*3.1415926*2,SIN=sin(r),COS=cos(r);//开变量避免反复调用函数
		for(int i=1;i<=n;i++){
			a[i].x=p[i].x*COS-p[i].y*SIN;
			a[i].y=p[i].x*SIN+p[i].y*COS;
		}
		sort(a+1,a+1+n,cmp1);
		for(int i=1;i<n;i++)
		for(int j=1;j<=10&&i+j<=n;j++)
		ans1=min(ans1,dis(a[i],a[i+j]));//最小值相近但不一定相邻，往后多推几个，减小偶然性
		for(int i=1;i<=len;i++)//最大值在两边但不一定在两端，各枚举sqrt(n)个，与计算前者的复杂度尽量保持一致，合理利用时间
		for(int j=n;j>=n-len;j--) ans2=max(ans2,dis(a[i],a[j]));
	}
	printf("%.3lf %.3lf\n",sqrt(ans1),sqrt(ans2));//计算答案的平方最后再开根，避免反复sqrt
	return 0;
}
```


---

## 作者：Remake_ (赞：1)

大家好，我不会计几，不会$\texttt{K-D Tree}$，于是我用乱搞过了。

~~面向数据编程~~

这篇题解里面会用到一个非常重要的暴力叫做卡时暴力，即限定此暴力所用的时间，如果时间超了，就直接退出当前循环，接下来的暴力皆指卡时暴力。

先来看小数据的做法（小数据既指$n$小，还指X坐标和Y坐标的小无需离散）：

首先，我们将所有点按横坐标从小到大排序，暴力一遍，每次选择的话最小值都尽量选排序后的位置相近的点进行比较，这样能使其欧几里得距离尽可能相近，最大值反之，选择排序后位置相差较大的点进行比较，显然并不能保证欧几里得距离是最为相近的，但起码可以作一个近似。

然后，我们将所有点按横坐标从大到小排序，并重复上述暴力。

接下来既然横坐标排了序了暴了力了，于是纵坐标按同样的方法再搞一次。

似乎跑得还不错？

可以发现，我们的算法中有$4$次暴力，所以每次暴力的时间设$230ms$左右即可。

大数据令人很难受啊qwq，使用上述做法的话每次暴力实际上遍及不到很多东西，所以我们选择放弃按横坐标从大到小排序和按纵坐标从大到小排序，原因是因为这些东西可能会涉及冗余的点对，而我们专心搞一种或者两种排序的暴力可能会更好，当然这个做法只限于大数据奥，因为小数据的话据我所知出题人造的数据并不随机，很强，大数据的话出题人似乎就手造不出来了，所以使用了随机数据，这个大数据做法在随机数据下跑的效果很好，可以放心使用此做法来搞，可以发现我们的大数据做法中有$2$次暴力，所以每次暴力的时间设$480ms$左右即可。

代码比较乱，但是考虑到大家可能有些听不懂，放一下代码吧awa：

```cpp
#include <bits/stdc++.h>
using namespace std;
pair<double, double> p, a[200005];
int tot, n;
double minn = 0x7fffffffffff, maxx;
inline double Dis(pair<double, double> a, pair<double, double> b)
{
    return (a.first - b.first) * (a.first - b.first) + (a.second - b.second) * (a.second - b.second);
}
bool cmp(pair<double, double> a, pair<double, double> b)
{
    return a.first < b.first;
}
bool cmp2(pair<double, double> a, pair<double, double> b)
{
    return a.second < b.second;
}
int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> p.first >> p.second;
        a[++tot] = p;
    }
    if (n >= 50000 && abs(a[1].first) >= 1000)
    {
        sort(a + 1, a + tot + 1, cmp);
        int i = 0;
        while ((double)clock() / CLOCKS_PER_SEC <= 0.5 && ++i && i <= tot)
            for (int j = i + 1; j <= tot; j++)
                minn = min(minn, Dis(a[j], a[j - i])), maxx = max(maxx, Dis(a[j - i], a[tot - i]));
        sort(a + 1, a + tot + 1, cmp2);
        i = 0;
        while ((double)clock() / CLOCKS_PER_SEC <= 0.97 && ++i && i <= tot)
            for (int j = i + 1; j <= tot; j++)
                minn = min(minn, Dis(a[j], a[j - i])), maxx = max(maxx, Dis(a[j - i], a[tot - i]));
        printf("%.4f %.4f", sqrt(minn), sqrt(maxx));
    }
    else
    {
        sort(a + 1, a + tot + 1, cmp);
        int i = 0;
        while ((double)clock() / CLOCKS_PER_SEC <= 0.25 && ++i && i <= tot)
            for (int j = i + 1; j <= tot; j++)
                minn = min(minn, Dis(a[j], a[j - i])), maxx = max(maxx, Dis(a[j - i], a[tot - i - (j - i - 1) + 1]));
        reverse(a + 1, a + tot + 1);
        i = 0;
        while ((double)clock() / CLOCKS_PER_SEC <= 0.47 && ++i && i <= tot)
            for (int j = i + 1; j <= tot; j++)
                minn = min(minn, Dis(a[j], a[j - i])), maxx = max(maxx, Dis(a[j - i], a[tot - i - (j - i - 1) + 1]));
        sort(a + 1, a + tot + 1, cmp2);
        i = 0;
        while ((double)clock() / CLOCKS_PER_SEC <= 0.7 && ++i && i <= tot)
            for (int j = i + 1; j <= tot; j++)
                minn = min(minn, Dis(a[j], a[j - i])), maxx = max(maxx, Dis(a[j - i], a[tot - i - (j - i - 1) + 1]));
        reverse(a + 1, a + tot + 1);
        i = 0;
        while ((double)clock() / CLOCKS_PER_SEC <= 0.98 && ++i && i <= tot)
            for (int j = i + 1; j <= tot; j++)
                minn = min(minn, Dis(a[j], a[j - i])), maxx = max(maxx, Dis(a[j - i], a[tot - i - (j - i - 1) + 1]));
        printf("%.4f %.4f", sqrt(minn), sqrt(maxx));
    }
}
```


---


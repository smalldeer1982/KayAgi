# [COCI 2014/2015 #2] Norma

## 题目描述

给定一个正整数序列 $a_1,a_2,\cdots,a_n$ ，求

$$\sum_{i=1}^{n}\sum_{j=i}^{n}(j-i+1)\min(a_i,a_{i+1},\cdots,a_j)\max(a_i,a_{i+1},\cdots,a_j)$$

## 说明/提示

对于 $100\%$ 的数据，$1 \le n \leq 5\times 10^5$，$1 \le a_i \le 10^8$。

## 样例 #1

### 输入

```
4
2
4
1
4```

### 输出

```
109```

# 题解

## 作者：辰星凌 (赞：19)

# **【题解】Norma [COCI2014] [SP22343]**


**传送门：[$\text{Norma [COCI2014] [P5899]}$](https://www.luogu.com.cn/problem/P5899) [$\text{[SP22343]}$](https://www.luogu.com.cn/problem/SP22343)**

## **【题目描述】**

给定一个整数 $n$ 和一个长度为 $n$ 的序列 $a$，子序列是指原序列中一段连续的序列。子序列的价值定义为它们中的**最小值**乘以**最大值**再乘以**该子序列长度** 。现要计算所有子序列的价值之和，答案对 $1e9$ 取模。

-------

## **【分析】**

询问过于奇葩，万能的线段树都没法搞，单调队列也许可做，但太复杂了。

可以用类似 $\text{CDQ}$ 的思想递归分治：将一段区间分为左右两半，计算其中一半对另一半的贡献，得到另一半的答案。

对于一个区间 $[L,R]$，求出其中穿过了 $a[mid]$ 的所有子序列价值总和，然后再递归求解 $[L,mid]$ 以及 $[mid\!+\!1,R]$，可以保证子序列的计算一定不重不漏。

考虑处理一个区间 $[L,R]$ ，先枚举 $i \in [L,mid]$ 固定左端点，求出以每个 $i$ 作为左端点的所有子序列贡献和。

对于每个 $i$：

用 $mi,mx$ 分别表示 $min \{ a[i] \cdots a[mid] \}$ 和 $max \{ a[i] \cdots a[mid] \}$

设两个指针 $j,k$，    
$j$ 表示满足 $mi \leqslant min \{ a[mid\!+\!1] \cdots a[j] \}$ 的最大的 $j$ 的位置，  
$k$ 表示满足 $mx \geqslant max \{ a[mid\!+\!1] \cdots a[k] \}$ 的最大的 $k$ 的位置。

设 $w_{1}=min\{j,k\},w_{2}=max\{j,k\}$，此时右半部分被分成了三个部分，分别对其求解。

$(1).$ **完全满足** $mi,mx$ **的部分：** $[mid\!+\!1,w_{1}]$  

可知这一整段的元素数值范围都在 $[mi,mx]$ 以内，因此右端点在取 $[mid\!+\!1,w_{1}]$ 中的任意一个位置时，子序列最小值都始终为 $mi$，最大值也始终为 $mx$，至于区间长度，直接套等差数列公式就好了，小学数学不再赘述（这玩意儿有个很高大上的名字：[高斯求和](https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E6%B1%82%E5%92%8C/7487795?fr=aladdin)）。

**第** $1$ **部分对左端点** $i$ **的总贡献可表示为：** $ans_{1}[i]=mi*mx*\frac{(((mid\!+\!1)\!-i\!+\!1)+(w1\!-\!i\!+\!1))*(w1\!-\!(mid\!+\!1)\!+\!1)}{2}$ 。

$(2).$ **满足** $mi,mx$ **其一的部分：** $[w_{1}\!+\!1,w_{2}]$

这部分比较难想，在草稿纸上比划了好久才搞出来，而且还不太好描述。

分为 $j<k$ $($ 即 $w_{1}\!<\!k\!=\!w_{2})$ 和 $j>k$ $($ 即 $w_{1}\!<\!j\!=\!w_{2})$ 两种情况讨论。

以 $j<k$ 为例，此时要计算右端点 $[w_{1}\!+\!1,w_{2}]$ 对 $i$ 的贡献可以直接用 $mx$，但 $mi$ 不行，要用两个前缀和数组预处理一下这个东西。

由于子序列长度在不断的变化，但 $mid+1$ 是始终不变的，可以轻松处理出左端点为 $mid+1$ 的子序列贡献和，记为 $S_{1}$ 。再看左边部分没有计算的部分长度，对于每一个 $i$，它也是固定的 $(mid-i+1)$，于是还要用一个数组 $S’_{1}$ 记录每个前缀最小值的前缀和。

这个东西不太好描述，见下面的式子：

$S_{1}[x]$ $(mid\!+\!1\!\leqslant\!x\!\leqslant\!R)$ $=$ $\sum_{i=mid+1}^{x} ((i\!-\!(mid\!+\!1)\!+\!1)*max\{a[mid\!+\!1] \cdots a[i]\})$ 

$S'_{1}[x]$ $(mid\!+\!1\!\leqslant\!x\!\leqslant\!R)$ $=$ $\sum_{i=mid+1}^{x} max\{a[mid\!+\!1] \cdots a[i]\}$ 

该做法的正确性来自于：随着右端点的递增，$mid\!+\!1$ 到**右端点**的**前缀最大值单调不下降**，**最小值单调不上升**，所以可以直接用前缀和数组中的两个位置相减**得到一段的贡献**。

$j>k$ 的情况同理，预处理两个数组 $S_{2},S'_{2}$即可。

**第** $2$ **部分对左端点** $i$ **的总贡献可表示为：**  $ans_{2}[i]=\begin{cases}
mx*((S_{1}[k]\!-\!S_{1}[w1])+(mid\!-\!i\!+\!1)*(S'_{1}[k]\!-\!S'_{1}[w1]))&(j<k)\\
 mi*((S_{2}[j]\!-\!S_{2}[w1])+(mid\!-\!i\!+\!1)*(S'_{2}[j]\!-\!S'_{2}[w1]))&(k<j)
 \end{cases}$ 。


$(3).$ **完全不满足** $mi,mx$ **的部分：** $[w_{2}\!+\!1,R]$

其实只要 $(2)$ 搞了出来，$(3)$ 就没啥难度了，一样的处理方法，维护两个前缀和数组 $S_{3},S'_{3}$。

**第** $3$ **部分对左端点** $i$ **的总贡献可表示为：** $ans_{3}[i]=(S_{3}[R]\!-\!S_{3}[w2])+(mid\!-\!i\!+\!1)*(S'_{3}[R]\!-\!S'_{3}[w2])$ 。

**最后，注意取膜！！！开** $long$ $long$ **防止中间乘爆。**

时间复杂度为： $O(nlogn)$ 。

## **【Code】**

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#define LL long long
#define Re register LL
using namespace std;
const LL N=5e5+3,logN=19,P=1e9;
LL n,ans,a[N],S1[N],S2[N],S3[N],S1_[N],S2_[N],S3_[N];
inline void in(Re &x){
    int f=0;x=0;char c=getchar();
    while(c<'0'||c>'9')f|=c=='-',c=getchar();
    while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
    x=f?-x:x;
}
inline void sakura(Re L,Re R){
    if(L==R){(ans+=a[L]*a[L]%P)%=P;return;}//这个特判必须要加
    if(L+1==R){(ans+=(a[L]*a[L]%P+a[R]*a[R]%P+a[L]*a[R]%P*2%P)%P)%=P;return;}//这里好像不用特判也可以QAQ
    Re mid=L+R>>1,mi=a[mid],mx=a[mid],i=mid,j=mid,k=mid;//注意j,k预处理为mid而不是mid+1
    Re MI=a[mid+1],MX=a[mid+1];//这里MI,MX和上面的mi,mx取inf,-inf也可以
    S1[mid]=S2[mid]=S3[mid]=S1_[mid]=S2_[mid]=S3_[mid]=0;//重置前缀和
    for(Re i=mid+1;i<=R;++i){
        MI=min(MI,a[i]),MX=max(MX,a[i]);//更新前缀最大值
        (S1[i]=S1[i-1]+MI*(i-(mid+1)+1)%P)%=P,(S1_[i]=S1_[i-1]+MI)%=P;//递推更新S1
        (S2[i]=S2[i-1]+MX*(i-(mid+1)+1)%P)%=P,(S2_[i]=S2_[i-1]+MX)%=P;//递推更新S2
        (S3[i]=S3[i-1]+MI*MX%P*(i-(mid+1)+1)%P)%=P,(S3_[i]=S3_[i-1]+MI*MX%P)%=P;//递推更新S3
    }
    while(i>=L){
        mi=min(mi,a[i]),mx=max(mx,a[i]);
        while(j<R&&a[j+1]>mi)++j;//移动MI指针j
        while(k<R&&a[k+1]<mx)++k;//移动MX指针k
        Re w1=min(j,k),w2=max(j,k);//获取三部分的两个分界点
        if(w1>mid)(ans+=mi*mx%P*((mid+1-i+1+w1-i+1)*(w1-(mid+1)+1)/2%P)%P)%=P;//完全满足的部分
        if(j>w1)//满足mi但不满足mx
            (ans+=mi*((S2[j]-S2[w1]+P)%P+(mid-i+1)*(S2_[j]-S2_[w1]+P)%P)%P)%=P;
        if(k>w1)//满足mx但不满足mi
            (ans+=mx*((S1[k]-S1[w1]+P)%P+(mid-i+1)*(S1_[k]-S1_[w1]+P)%P)%P)%=P;
        (ans+=((S3[R]-S3[w2]+P)%P+(mid-i+1)*(S3_[R]-S3_[w2]+P)%P)%P)%=P;//完全不满足的部分
        --i;//移动左指针
    }
    sakura(L,mid),sakura(mid+1,R);//递归搞下面
}
int main(){
//  freopen("norma.in","r",stdin);
//  freopen("norma.out","w",stdout);
    in(n);
    for(Re i=1;i<=n;++i)in(a[i]);
    sakura(1,n);
    printf("%lld\n",ans%P);
//  fclose(stdin);
//  fclose(stdout);
    return 0;
}
```

---

## 作者：yzy1 (赞：10)

注释：博客编辑页和管理员题解审核页使用的 $\KaTeX$ 版本较低，不支持 `\def` 指令，可能会导致本题解中的部分公式渲染异常．而在题目对应的题解展示页面和个人博客渲染页面使用的 $\KaTeX$ 为高版本，则无此问题．

---

介绍一个非常无脑的做法．

考虑对序列分治．假设当前分治区间为 $[l,r]$，区间中点为 $\mathit{mid}$，已经处理了 $[l,\mathit{mid}]$ 和 $[\mathit{mid}+1, r]$ 的所有区间．此时我们需要计算的是所有左端点在 $[l,\mathit{mid}]$，右端点在 $[\mathit{mid}+1, r]$ 的子区间的贡献．

枚举原式中的 $\min$ 和 $\max$ 在左半边还是右半边取到，共有四种情况：

- A. $\min$ 取右半，$\max$ 取左半．
- B. $\min$ 取左半，$\max$ 取左半．
- C. $\min$ 取左半，$\max$ 取右半．
- D. $\min$ 取右半，$\max$ 取右半．

事实上，若以子区间所有数的 $\min$ 为 $x$-轴，子区间所有数的 $\max$ 为 $y$-轴，则可以把每个形如 $[i,\mathit{mid}]$ 或 $[\mathit{mid},j]$ 的半区间都看作二维平面上的点．若以一个右半区间对应的点作为原点，则在第一、二、三、四象限中的左半区间对应的点的符合对应上述的 A、B、C、D 四种情况．

考虑计算每种情况的 $i$ 对右端点 $j$ 的贡献，下面设 $N_i,X_i$ 分别表示 $i$ 所在的半区间所有数的 $\min$ 或 $\max$ 值：

$$
\def\ans{\mathit{ans}}
\def\mid{\mathit{mid}}
\def\mn{\mathit{N}}
\def\mx{\mathit{X}}
\begin{aligned}
\ans_A &= \sum_i [\mn_i \le \mn_j \land \mx_i > \mx_j] (j-i+1) \mx_i \mn_j\\
&={\color{red}(\sum_i[\mn_i \le \mn_j \land \mx_i > \mx_j] (\mid-i+1) \mx_i)} \mn_j\\
&\quad {} + {\color{blue}(\sum_i[\mn_i \le \mn_j \land \mx_i > \mx_j] \mx_i )} (r-\mid) \mn_j\\
\ans_B &= \sum_i [\mn_i > \mn_j \land \mx_i > \mx_j] (j-i+1) \mx_i \mn_i\\
&={\color{red}(\sum_i[\mn_i > \mn_j \land \mx_i > \mx_j] (\mid-i+1) \mx_i \mn_i)}\\
&\quad {} + {\color{blue}(\sum_i[\mn_i > \mn_j \land \mx_i > \mx_i] \mx_i \mn_i)}(r-\mid)\\
\cdots&{}
\end{aligned}
$$

类似的，$\mathit{ans}_C$ 和 $\mathit{ans}_D$ 也可以拆成类似的东西．观察到式子的形式都是两个二维矩形内所包含点的点权和（即上述公式中的红、蓝色部分）再乘以一些常数．不难想到用扫描线 + 树状数组维护二维数点．

由于四个式子中的每个都会拆出两个互不相同的矩形和的形式．故需要八个树状数组，分别维护矩形 $1$、$\mathit{len}$、$N$、$X$、$\mathit{len}\cdot N$、$\mathit{len}\cdot X$、$N\cdot X$、$\mathit{len}\cdot N\cdot X$ 的和即可．

本做法的时间复杂度为 $O(n(\log n)^2)$，空间复杂度为 $O(n)$，可以通过此题．

```cpp
struct Bit {
  // 省略树状数组
} bit1, bitx, bitw, bitxw;


/*
    max
  B  |  A
-----O------> min
  C  |  D
*/
inline void Divide(int l, int r) {
  if (l == r) return ans += 1ll * vec[a[l] - 1] * vec[a[l] - 1] % mo, void();
  int mid = (l + r) >> 1;
  Divide(l, mid), Divide(mid + 1, r);
  mx[mid] = mn[mid] = a[mid];
  per (i, mid - 1, l) mn[i] = min(mn[i + 1], a[i]), mx[i] = max(mx[i + 1], a[i]);
  mx[mid + 1] = mn[mid + 1] = a[mid + 1];
  rep (i, mid + 2, r) mn[i] = min(mn[i - 1], a[i]), mx[i] = max(mx[i - 1], a[i]);
  sort(rnk + l, rnk + r + 1, [](int x, int y) { return mn[x] < mn[y]; });
  int sumx = 0, sumxw = 0;
  rep (i, l, r)
    if (rnk[i] <= mid) {
      int tmp, mxv = vec[mx[rnk[i]] - 1], mnv = vec[mn[rnk[i]] - 1];
      bit1.Add(mx[rnk[i]], mnv);
      bitx.Add(mx[rnk[i]], tmp = 1ll * mxv * mnv % mo);
      sumx += tmp, umod(sumx);
      bitw.Add(mx[rnk[i]], 1ll * (mid - rnk[i] + 1) * mnv % mo);
      bitxw.Add(mx[rnk[i]], tmp = 1ll * (mid - rnk[i] + 1) * mxv % mo * mnv % mo);
      sumxw += tmp, umod(sumxw);
    } else {
      int res1 = bit1.Ask(mx[rnk[i]]), resx = bitx.Ask(mx[rnk[i]]), resw = bitw.Ask(mx[rnk[i]]),
          resxw = bitxw.Ask(mx[rnk[i]]), mxv = vec[mx[rnk[i]] - 1];
      // B: (w1+w2)*mx_i*mn_i
      ans += (1ll * sumxw - resxw + mo) % mo, umod(ans);
      ans += 1ll * (rnk[i] - mid) % mo * (sumx - resx + mo) % mo, umod(ans);
      // C: (w1+w2)*mx_j*mn_i
      ans += 1ll * resw * mxv % mo, umod(ans);
      ans += 1ll * res1 * (rnk[i] - mid) % mo * mxv % mo, umod(ans);
    }
  rep (i, l, r)
    if (rnk[i] <= mid) {
      int mxv = vec[mx[rnk[i]] - 1], mnv = vec[mn[rnk[i]] - 1];
      bit1.Add(mx[rnk[i]], mo - mnv);
      bitx.Add(mx[rnk[i]], mo - 1ll * mxv * mnv % mo);
      bitw.Add(mx[rnk[i]], mo - 1ll * (mid - rnk[i] + 1) * mnv % mo);
      bitxw.Add(mx[rnk[i]], mo - 1ll * (mid - rnk[i] + 1) * mxv % mo * mnv % mo);
    }
  sumx = 0, sumxw = 0;
  per (i, r, l)
    if (rnk[i] <= mid) {
      int tmp, mxv = vec[mx[rnk[i]] - 1];
      bit1.Add(mx[rnk[i]], 1);
      bitx.Add(mx[rnk[i]], tmp = mxv);
      sumx += tmp, umod(sumx);
      bitw.Add(mx[rnk[i]], 1ll * (mid - rnk[i] + 1) % mo);
      bitxw.Add(mx[rnk[i]], tmp = 1ll * (mid - rnk[i] + 1) * mxv % mo);
      sumxw += tmp, umod(sumxw);
    } else {
      int res1 = bit1.Ask(mx[rnk[i]]), resx = bitx.Ask(mx[rnk[i]]), resw = bitw.Ask(mx[rnk[i]]),
          resxw = bitxw.Ask(mx[rnk[i]]), mxv = vec[mx[rnk[i]] - 1], mnv = vec[mn[rnk[i]] - 1];
      // A: (w1+w2)*mx_i*mn_j
      ans += (1ll * sumxw - resxw + mo) % mo * mnv % mo, umod(ans);
      ans += 1ll * (rnk[i] - mid) % mo * (sumx - resx + mo) % mo * mnv % mo, umod(ans);
      // D: (w1+w2)*mx_j*mn_j
      ans += 1ll * resw * mxv % mo * mnv % mo, umod(ans);
      ans += 1ll * res1 * (rnk[i] - mid) % mo * mxv % mo * mnv % mo, umod(ans);
    }
  rep (i, l, r)
    if (rnk[i] <= mid) {
      int mxv = vec[mx[rnk[i]] - 1];
      bit1.Add(mx[rnk[i]], mo - 1);
      bitx.Add(mx[rnk[i]], mo - mxv);
      bitw.Add(mx[rnk[i]], mo - 1ll * (mid - rnk[i] + 1) % mo);
      bitxw.Add(mx[rnk[i]], mo - 1ll * (mid - rnk[i] + 1) * mxv % mo);
    }
}
```

---

## 作者：guosoun (赞：10)

[博客](https://gzy-blog.pages.dev/solution-P6406/)

提供一种线段树解法。

设 $\min(l,r)$ 表示 $a_l$ 至 $a_r$ 的最小值，$\max(l,r)$ 表示 $a_l$ 至 $a_r$ 的最大值。

题目要求：
$$
\sum_{l=1}^n \sum_{r=l}^n (r-l+1)\min(l,r)\max(l,r)
$$


考虑将其分成：
$$
\sum_{l=1}^n \sum_{r=l}^n (r+1)\times\min(l,r)\max(l,r)-l\times\min(l,r)\max(l,r)
$$
即，对于每个 $r$ 求出：
$$
(r+1)\times\sum _{l=1}^r \min(l,r)\max(l,r)
$$
对于每个 $l$ 求出：
$$
l\times\sum _{r=l}^n \min(l,r)\max(l,r)
$$
这两个求法类似，以 $r$ 为例：

假设现在的右端点为 $r$，

考虑维护数组 $mn$ 和 $mx$，$mn_i=\min(i,r),mx_i=\max(i,r)$，

那么 $r$ 作为右端点的答案就是 $\sum_{i=1}^r mn_i\times mx_i$。

考虑将右端点向后移变为 $r+1$ 的答案，

可以发现只有部分的 $mn$ 和 $mx$ 发生了变化，

具体的，设 $p$ 为 $r+1$ 左边第一个比 $a_{r+1}$ 小的数，设 $q$ 为 $r+1$ 左边第一个比 $a_{r+1}$ 大的数。

（$p$ 和 $q$ 可以用单调栈求出）。

容易发现，$mn$ 数组从 $p+1$ 到 $r+1$ 都应变为 $a_{r+1}$，$mx$ 数组从 $q+1$ 到 $r+1$ 都应变为 $a_{r+1}$。

考虑用线段树维护这一过程，即需要支持：

- 区间覆盖 $mn$
- 区间覆盖 $mx$
- 区间查询 $\sum_{i=1}^r mn_i \times mx_i$

$l$ 的贡献同理。

提示：该题卡空间

代码（部分变量名和题解不同）：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mid ((l+r)>>1)
using namespace std;
const int N=5e5+3,p=1e9;
struct Val{
    int sa,sb,sm;
    Val(){sa=sb=sm=0;}
};
Val operator+(Val x,Val y){
    Val z;
    z.sa=(x.sa+y.sa)%p;
    z.sb=(x.sb+y.sb)%p;
    z.sm=(x.sm+y.sm)%p;
    return z;
}
struct node{
    int tga=-1,tgb=-1;
    Val v;
    void val(int ta,int tb,int l,int r){
        if(~ta){
            tga=ta;
            v.sa=(ta*1LL*(r-l+1))%p;
            v.sm=(ta*1LL*v.sb)%p;
        }
        if(~tb){
            tgb=tb;
            v.sb=(tb*1LL*(r-l+1))%p;
            v.sm=(tb*1LL*v.sa)%p;
        }
    }
}tr[(N<<2)];
void push_down(int x,int l,int r){
    tr[x<<1].val(tr[x].tga,tr[x].tgb,l,mid);
    tr[x<<1|1].val(tr[x].tga,tr[x].tgb,mid+1,r);
    tr[x].tga=tr[x].tgb=-1;
}
void push_up(int x)
    {tr[x].v=tr[x<<1].v+tr[x<<1|1].v;}
void change(int x,int l,int r,int ql,int qr,int ta,int tb){
    if(l>=ql&&r<=qr){tr[x].val(ta,tb,l,r);return;}
    if(l>qr||r<ql) return;
    push_down(x,l,r);
    change(x<<1,l,mid,ql,qr,ta,tb),
    change(x<<1|1,mid+1,r,ql,qr,ta,tb);
    push_up(x);
}
Val ask(int x,int l,int r,int ql,int qr){
    if(l>=ql&&r<=qr) return tr[x].v;
    if(l>qr||r<ql) return Val();
    push_down(x,l,r);
    return ask(x<<1,l,mid,l,r)+ask(x<<1|1,mid+1,r,l,r);
}
int a[N],n;
ll ans=0;
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    stack<int>mn,mx;
    for(int i=1;i<=n;i++){
        while(mx.size()&&a[mx.top()]<a[i]) mx.pop();
        if(mx.size()) change(1,1,n,mx.top()+1,i,a[i],-1);
        else change(1,1,n,1,i,a[i],-1);
        mx.push(i);
        while(mn.size()&&a[mn.top()]>a[i]) mn.pop();
        if(mn.size()) change(1,1,n,mn.top()+1,i,-1,a[i]);
        else change(1,1,n,1,i,-1,a[i]);
        mn.push(i);
        auto v=ask(1,1,n,1,i);
        ans=(ans+(v.sm*1LL*(i+1))%p)%p;
    }
    while(mn.size()) mn.pop();
    while(mx.size()) mx.pop();
    change(1,1,n,1,n,0,0);
    for(int i=n;i>=1;i--){
        while(mx.size()&&a[mx.top()]<a[i]) mx.pop();
        if(mx.size()) change(1,1,n,i,mx.top()-1,a[i],-1);
        else change(1,1,n,i,n,a[i],-1);
        mx.push(i);
        while(mn.size()&&a[mn.top()]>a[i]) mn.pop();
        if(mn.size()) change(1,1,n,i,mn.top()-1,-1,a[i]);
        else change(1,1,n,i,n,-1,a[i]);
        mn.push(i);
        auto v=ask(1,1,n,i,n);
        ans=(ans-(v.sm*1LL*i)%p)%p;
    }
    cout<<(ans%p+p)%p;

}
```



---

## 作者：Luciylove (赞：8)

乐，题解区交一堆分治，还是给个正常的套路解法。

对 $\max$ 和 $\min$ 直接上单调栈。

那么就是对于右端点 $r$ 已经维护了左端点为 $i$ 时的最大值最小值 $a_i$ 和 $b_i$。

那么就是对 $r$ 求 $\sum a_ib_i(r - i + 1)$ 考虑拆柿子。

$(r + 1)\sum a_ib_i  -\sum ia_ib_i$

这个直接线段树维护点积和、线段树维护点积 $\times i$ 就好了。

丢个很丑的实现。

```cpp
#include <bits/stdc++.h>
#define rep(i, l, r) for (int i = l; i <= r; i ++)
#define per(i, r, l) for (int i = r; i >= l; i --)
#define lc x << 1
#define rc x << 1 | 1

using namespace std;
typedef long long ll;

const int _ = 5e5 + 5, mod = 1e9;

int power (int x, int y) {
	int ret = 1;
	for ( ; y; y >>= 1, x = 1ll * x * x % mod)
		if (y & 1) ret = 1ll * ret * x % mod;
	return ret;
}
void add (int & x, int y) { 
	x += y;
	x -= x >= mod ? mod : 0;
}
int mul (int x, int y) { return 1ll * x * y % mod; }
int su (int l, int r) { return (1ll * (r - l + 1) * (l + r) / 2) % mod; }

struct Info {
	int s[2], si[2], ans[2];
	Info () { rep(i, 0, 1) s[i] = si[i] = ans[i] = 0; }
} tr[_ << 2];
int tag[_ << 2][2];
Info operator + (Info x, Info y) {
	Info z;
	rep(i, 0, 1) {
		z.s[i] = (x.s[i] + y.s[i]) % mod;
		z.si[i] = (x.si[i] + y.si[i]) % mod;
		z.ans[i] = (x.ans[i] + y.ans[i]) % mod;
	}
	return z;
}
void apply (int x, int l, int r, int k, int op) {
	add(tr[x].s[op], 1ll * (r - l + 1) * k % mod);
	add(tr[x].si[op], 1ll * su(l, r) * k % mod);
	add(tr[x].ans[0], 1ll * k * tr[x].s[op ^ 1] % mod);
	add(tr[x].ans[1], 1ll * k * tr[x].si[op ^ 1] % mod);
	add(tag[x][op], k);
}
void pushdown (int x, int l, int mid, int r) {
	rep(i, 0, 1) {
		if (!tag[x][i]) continue ;
		apply(lc, l, mid, tag[x][i], i),
		apply(rc, mid + 1, r, tag[x][i], i);
		tag[x][i] = 0;
	}
}
void modify (int x, int l, int r, int ql, int qr, int k, int op) {
	if (ql <= l && r <= qr) return apply(x, l, r, k, op);
	int mid = (l + r) >> 1; pushdown(x, l, mid, r);
	if (ql <= mid) modify(lc, l, mid, ql, qr, k, op);
	if (qr > mid) modify(rc, mid + 1, r, ql, qr, k, op);
	tr[x] = tr[lc] + tr[rc];
}

int n, a[_];
int stk1[_], stk2[_];
int top1, top2;
ll ret;
signed main() {
	
	/*freopen(".out", "w", stdout);
	黛拉可玛莉·岗德森布莱德，一亿年一遇美少女。
	*/
	cin >> n;
	rep(i, 1, n) scanf("%d", & a[i]);
	rep(i, 1, n) {
		while(top1 && a[stk1[top1]] <= a[i])
			modify(1, 1, n, stk1[top1 - 1] + 1, stk1[top1], (a[i] - a[stk1[top1]]) % mod, 0), 
			top1 --;
		while(top2 && a[stk2[top2]] >= a[i])
			modify(1, 1, n, stk2[top2 - 1] + 1, stk2[top2], ((a[i] - a[stk2[top2]]) % mod + mod) % mod, 1), 
			top2 --;
		modify(1, 1, n, i, i, a[i], 0), modify(1, 1, n, i, i, a[i], 1);
		stk1[++ top1] = i, stk2[++ top2] = i;
		(ret += ((1ll * (i + 1) * tr[1].ans[0]) % mod - tr[1].ans[1] % mod + mod) % mod) %= mod;
		// cout << ret << endl;
	}
	cout << ret;
	return 0;
}
```




---

## 作者：nullqtr_pwp (赞：7)

2023.11.7 upd：有一处手误。

不是大模拟，胜似大模拟。
#### 【题目描述】
给定一个正整数序列 $a_1,a_2,\cdots,a_n$ ，求

$$\sum_{i=1}^{n}\sum_{j=i}^{n}(j-i+1)\min(a_i,a_{i+1},\cdots,a_j)\max(a_i,a_{i+1},\cdots,a_j)$$

$1 \le n \leq 5\times 10^5$，$1 \le a_i \le 10^8$。

#### 【题目做法】
看到形如 $\sum_{l}\sum_{r}f(l,r)$ 很容易想到分治。

分治区间 $[l,r]$ 时，我们只需要考虑 $L\in [l,mid],R\in (mid,R]$ 的所有区间 $[L,R]$ 对答案的贡献。而 $[L,R]$ 是由左半部分后缀拼接右半部分前缀得到的。

我们**固定左端点** $L$，考虑所有 $R$ 对答案的贡献。

我们考虑最大值，最小值出现的位置，可以分为以下四种：

- A. 最大值在左半区间，最小值在左半区间

- B. 最大值在左半区间，最小值在右半区间

- C. 最大值在右半区间，最小值在左半区间

- D. 最大值在右半区间，最小值在右半区间

记录 $s_{i,0}=\min_{i\le j\le mid}a_j,s_{i,1}=\max_{i\le j\le mid}a_j$。即左半部分的后缀最小和最大值。而任意要统计的区间都需要经过这些。

我们考虑 $[L,mid]$ 的最小值管辖到 $x$，最大值管辖到 $y$，即满足以下柿子的最大的 $x,y$。 
$$\min_{mid<j<x} a_j\ge s_{L,0},\max_{mid<j<y} a_j\le s_{L,1}$$


容易发现：

- 第一种情况是 $R\leq\min(x,y)$。

- 第二种情况是 $x<R\le y$。

- 第三种情况是 $y<R\le x$。

- 第四种情况是 $R>\max(x,y)$。


而分治能优化的点，就是不用一个个的统计。可以一起统计答案。对于这四种情况一个个讨论就好了。下面记 $lmn=s_{L,0},lmx=s_{L,1}$，记录 $g_{i,0}=\min_{mid<j\leq i}a_j,g_{i,1}=\max_{mid<j\le i}a_j$。

第一种情况：

$$\sum_{R=mid+1}^{\min(x,y)} (R-L+1)\times lmn\times lmx$$

可以等差数列快速求。

第二种和第三种类似，这里只写第二种了。

$$\sum_{R=x+1}^{y} (R-L+1)\times g_{R,1}\times lmx$$

不是很好求，可以换一种形式，提取出来 $mid-L+1$ 的常量，剩下部分可以支持任意 $L$ 快速求解。


$$\sum_{R=x+1}^{y} ((mid-L+1)+(R-mid))\times g_{R,1}\times lmx$$

分治中，常常要关注中点 $mid$ 的作用，分离常数项也是很重要的技巧。显然我们可以用前缀和优化快速求解：

$$\left (  \sum_{R=x+1}^{y} (R-mid)\times g_{R,1}+(mid-L+1)\times\sum_{R=x+1}^y g_{R,1}\right ) $$

第三种同理，这里略过，请读者自行推导。

第四种情况：

$$\sum_{R=\max(x,y)+1}^{r} g_{R,0}\times g_{R,1}\times(R-L+1)$$

类似的，拆成：

$$\left (  \sum_{R=\max(x,y)+1}^{r} (R-mid)\times g_{R,0}\times g_{R,1}+(mid-L+1)\times g_{R,0}\times  g_{R,1}\right ) $$

同样可以用前缀和优化。

因此，我们只需要维护以下 $10$ 个值。

左半部分后缀最大最小值 $s_{i,0/1}$；

右半部分前缀最大最小值 $g_{i,0/1}$；

右半部分 $g_{i,0/1}$ 的前缀和；

右半部分 $(g_{i,0}\times g_{i,1}) $ 的前缀和；

右半部分 $g_{i,0}\times (i-mid)$ 的前缀和；

右半部分 $g_{i,1}\times (i-mid)$ 的前缀和。

#### 【参考代码】
```cpp
// Problem: P6406 [COCI2014-2015#2] Norma
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P6406
// Memory Limit: 64 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
#define ll long long
#define pb push_back
#define pii pair<int,int>
#define F(i,a,b) for(int i=a;i<=(b);i++)
#define dF(i,a,b) for(int i=a;i>=(b);i--)
#define HH printf("\n")
using namespace std;
int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*f;
}
const int mod=1e9,maxn=500005;
const int inf=2e8;
int n;
ll pre[maxn][8],suf[maxn][2],a[maxn],ans=0;
void add(ll &x,ll y){
	if(y>=mod) y%=mod;
	x+=y,x%=mod;
	if(x<0) x+=mod;
}
void mul(ll &x,ll y){
	if(y>=mod) y%=mod;
	x*=y,x%=mod;
	if(x<0) x+=mod;
}
ll sum(int l,int r){
	return 1ll*(l+r)*(r-l+1)/2;
}
ll calc(int l,int r,int i,int x){
	int mid=(l+r)>>1;
	ll tot=pre[r][3]-pre[x][3];
	ll T=pre[r][2]-pre[x][2];
	if(tot<0) tot+=mod;
	if(T<0) T+=mod;
	mul(T,mid-i+1);
	if(T>=mod) T%=mod;
	add(T,tot);
	if(T>=mod) T-=mod;
	return T;
}
void solve(int l,int r){
	if(l==r) return add(ans,1ll*a[l]*a[l]),void();
	int mid=(l+r)>>1;
	pre[mid][0]=suf[mid+1][0]=inf;
	pre[mid][1]=suf[mid+1][1]=0;
	dF(i,mid,l) suf[i][0]=min(suf[i+1][0],a[i]);
	dF(i,mid,l) suf[i][1]=max(suf[i+1][1],a[i]);
	F(i,mid+1,r) pre[i][0]=min(pre[i-1][0],a[i]);
	F(i,mid+1,r) pre[i][1]=max(pre[i-1][1],a[i]);
	pre[mid][2]=pre[mid][3]=pre[mid][4]=pre[mid][5]=pre[mid][6]=pre[mid][7]=0;
	F(i,mid+1,r){
		ll x=pre[i][0]*pre[i][1];
		F(j,2,7) pre[i][j]=pre[i-1][j];
		add(pre[i][2],x);
		add(pre[i][3],x*(i-mid));
		add(pre[i][4],pre[i][0]*(i-mid));
		add(pre[i][5],pre[i][0]);
		add(pre[i][6],pre[i][1]*(i-mid));
		add(pre[i][7],pre[i][1]);
	}
	int x=mid,y=mid;
	dF(i,mid,l){
		ll mnl=suf[i][0],mxl=suf[i][1];
		for(;x+1<=r&&pre[x+1][0]>=mnl;x++);
		for(;y+1<=r&&pre[y+1][1]<=mxl;y++);
		if(x<=y){
			ans+=calc(l,r,i,y);
			ll len=sum(mid-i+2,x-i+1)%mod;
			mul(len,mnl),mul(len,mxl);
			add(ans,len);
			ll tot=(mid-i+1);
			mul(tot,pre[y][5]-pre[x][5]);
			add(tot,pre[y][4]-pre[x][4]);
			mul(tot,mxl);
			add(ans,tot);
		}
		else{
			ans+=calc(l,r,i,x);
			ll len=sum(mid-i+2,y-i+1)%mod;
			mul(len,mnl),mul(len,mxl);
			add(ans,len);
			ll tot=(mid-i+1);
			mul(tot,pre[x][7]-pre[y][7]);
			add(tot,pre[x][6]-pre[y][6]);
			mul(tot,mnl);
			add(ans,tot);
		}
	}
	solve(l,mid),solve(mid+1,r);
}
signed main(){
	n=read();
	F(i,1,n) a[i]=read();
	solve(1,n);
	printf("%lld",ans);
}
```


---

## 作者：_Robin_ (赞：6)

### [链接](https://www.luogu.com.cn/problem/P6406)

#### SHABER！

一个地方没取模调了 $1.5$ 个小时 ！！！

可以维护两个双指针，$\operatorname{p_1}$ 和 $\operatorname{p_2}$，把右区间分成 $3$ 部分，而我们要做的是，在右半部分维护一些东西，然后从 $\operatorname{mid}$ 往左扫一遍，能够 $O(1)$ 算出某一点为左端点，以右区间所有点为右端点的总贡献。

- 第一部分：左边贡献最大值和最小值；
	
    答案为：
    
    $$\begin{aligned}ans &= \sum_{i = \operatorname{mid} + 1} ^ {\operatorname{p_1}} \left(\operatorname{Len} + i -\operatorname{mid} \right) L_{\max}L_{\min}\\
    &= \operatorname{Len}\left(\operatorname{p_1} - \operatorname{mid} \right)\operatorname{Mul} + \dfrac{\operatorname{p_1}(\operatorname{p_1} + 1)}{2} \operatorname{Mul}
    \end{aligned}$$
	
    注意，$\dfrac{\operatorname{p_1}(\operatorname{p_1} + 1)}{2} \operatorname{Mul}$ 需要取模！！！

    这一部分是平凡的。  

- 第三部分：最大值最小值均在右边贡献；

    答案为：

    $$\begin{aligned}ans &= \sum_{i = \operatorname{p_2} + 1} ^ {\operatorname{r}} \left(\operatorname{Len} + i -\operatorname{mid} \right) R_{\max}R_{\min}\\
    &= \operatorname{Len}\left[\sum_{}R_{\max} R_{\min} \right] + \left[ \sum_{} i'R_{\max} R_{\min} \right]
    \end{aligned}$$

- 第二部分：左右各贡献一个：

    - 最大值在右：

    $$\begin{aligned}ans &= 

    \sum_{i = \operatorname{p_1} + 1} ^ {\operatorname{p_2}} \left(\operatorname{Len} + i -\operatorname{mid} \right) R_{\max}L_{\min}\\
    &= \operatorname{Len}L_{\min}\left[\sum_{} R_{\min} \right] + L_{\min} \left[ \sum_{} i'R_{\max} \right]

    \end{aligned}$$

    - 最大值在左：

    $$\begin{aligned}ans &= 

    \sum_{i = \operatorname{p_1} + 1} ^ {\operatorname{p_2}} \left(\operatorname{Len} + i -\operatorname{mid} \right) L_{\max}R_{\min}\\
    &= \operatorname{Len}R_{\min}\left[\sum_{} L_{\min} \right] + R_{\min} \left[ \sum_{} i'L_{\max} \right]

    \end{aligned}$$

其中，这六个括起来的东西是一定要维护的。  
（注释：$i' = i - mid$）

然后就能 $O(1)$ 的计算了。

总时间复杂度 $O\left(n \log n \right)$。

这玩意细节还是很多的，但是多码几遍就行了；  
我就码了 $45$ 分钟就基本码完了，就是那个地方没有取模；

具体细节见代码；

```cpp
#include <bits/stdc++.h>
#define _ 500520

using namespace std;

namespace RE{

const long long Mod = 1e9;

template<typename T>
inline void read(T &x) {
    x = 0;
    char c(getchar());
    bool f(true);
    for (; !isdigit(c); c = getchar())
        if (c == '-') f = false;
    for (; isdigit(c); c = getchar())
        x = (x << 3) + (x << 1) + (c ^ 48);
    return x *= f ? 1 : -1, void();
}

template<typename T1, typename T2, typename T3 = long long>
inline T1 vadd(T1 x, T2 y, T3 mod = Mod) {
    T1 tmp = x + y;
    return tmp >= mod ? tmp - mod : tmp;
}

template<typename T1, typename T2, typename T3 = long long>
inline void cadd(T1 &x, T2 y, T3 mod = Mod) {
    return x = vadd(x, y, mod), void();
}

template<typename T1, typename T2, typename T3 = long long>
inline T1 vmul(T1 x, T2 y, T3 mod = Mod) {
    T3 tmp = 1ll * x * y;
    return tmp < mod ? tmp : tmp - tmp / mod * mod;
}

template<typename T1, typename T2>
inline void cmul(T1 &x, T2 y) {
    x = vmul(x, y);
}

}
using namespace RE;

int n, ans;

int a[_];

int Mn[_], Mx[_];// 可有可无
int sMn[_], sMx[_];
int isMn[_], isMx[_];
int smul[_], ismul[_];

void CDQ(int l, int r) {
    if (l == r)
        return cadd(ans, vmul(a[l], a[r])), void();

    const int mid = (l + r) >> 1;
    
    CDQ(l, mid); CDQ(mid + 1, r);

    for (register int i = mid; i <= r; ++i)
        Mn[i] = Mx[i] = sMn[i] = sMx[i] = isMx[i] = isMn[i] = smul[i] = ismul[i] = 0;

    Mn[mid] = Mod, Mx[mid] = -Mod;

    for (register int i = mid + 1; i <= r; ++i) {
        Mn[i] = min(Mn[i - 1], a[i]);
        Mx[i] = max(Mx[i - 1], a[i]);
        sMn[i] = vadd(sMn[i - 1], Mn[i]);
        sMx[i] = vadd(sMx[i - 1], Mx[i]);
        isMx[i] = vadd(isMx[i - 1], vmul(i - mid, Mx[i]));
        isMn[i] = vadd(isMn[i - 1], vmul(i - mid, Mn[i]));
        smul[i] = vadd(smul[i - 1], vmul(Mx[i], Mn[i]));
        ismul[i] = vadd(ismul[i - 1], vmul(i - mid, vmul(Mx[i], Mn[i])));
    }

    int p1 = mid, p2 = mid;
    int Max = -1e9, Min = 1e9, Mul;

    for (register int i = mid ; i >= l; --i) {

        int Last = ans;
        Max = max(Max, a[i]);
        Min = min(Min, a[i]);
        Mul = vmul(Max, Min);
        while (Mx[p1 + 1] < Max && Mn[p1 + 1] > Min && p1 < r) ++p1;
        while ((Mx[p2 + 1] < Max || Mn[p2 + 1] > Min) && p2 < r) ++p2; 
        int L = mid - i + 1;

        cadd(ans, vmul(vmul(p1 - mid, L), Mul));
        cadd(ans, vmul((1ll * (p1 - mid) * (p1 - mid + 1)) / 2 % Mod, Mul));//取模！！！！！！！！！！！！！！！！！！！

        cadd(ans, vmul(L, vadd(smul[r], Mod - smul[p2])));
        cadd(ans, vadd(ismul[r], Mod - ismul[p2]));

        if(Max > Mx[p1 + 1]) {
            cadd(ans, vmul(L, vmul(Max, vadd(sMn[p2], Mod - sMn[p1]))));
            cadd(ans, vmul(Max, vadd(isMn[p2], Mod - isMn[p1])));
        }

        else {
            cadd(ans, vmul(L, vmul(Min, vadd(sMx[p2], Mod - sMx[p1]))));
            cadd(ans, vmul(Min, vadd(isMx[p2], Mod - isMx[p1])));
        }

    }
}

main() {

    read(n);

    for (register int i = 1; i <= n; ++i) {
        read(a[i]);
    }

    CDQ(1, n);

    cout << ans << endl;

}
```

---

## 作者：Melting_Pot (赞：6)

写在前面：序列分治是一种比较常见的技巧，将问题划分中点，每次只考虑计算跨区间中点算贡献，然后递归左右区间分开统计答案即可。

## Analysis

本题不同的区间均能对答案产生贡献，我们考虑如何跨中点算贡献。与常见跨中点算贡献的套路相同，我们将跨中点右区间划分为三段：最值靠左，最值左右各异，最值靠右。再根据 $cost_{i,j}$ 的定义来看，答案显然与区间长度有关，因此我们分类进行讨论。

### 最值都在左区间：

每段区间的最值都在左区间，直接乘起来就好。但是右区间的长度同样会造成贡献，怎么办？观察到此时的右区间长度产生贡献是一个等差数列，直接“高斯求和”可解。

### 最值左右区间各一个：

此时的最值不确定究竟是谁在左（或在右），因此分讨：

1. 最大值在左区间：
   
   此时右区间的最小值不确定，因此预处理出右区间最小值前缀和，这样实现了维护最大值乘最小值，但还短一个关键的系数：长度。长度不方便预处理，因为在中点靠左仍有长度会产生贡献，于是我们考虑拆开原式，具体来说：

    $$\begin{aligned}
        cost_{i,j}&=\sum maxn_l\times minn_r\times len_{i\sim j}\\
        &=maxn_l\times\sum  minn_r\times (len_{i\sim mid}+len_{mid+1\sim j})\\
        &=maxn_l\times(\sum  minn_r\times len_{i\sim mid}+\sum minn_r\times len_{mid+1\sim j})\\
        &=maxn_l\times(len_{i\sim mid}\times \sum  minn_r+\sum minn_r\times len_{mid+1\sim j})\\
    \end{aligned}
    $$

    我们将 $\sum minn_r$ 与 $\sum minn_r\times len_{mid+1\sim j}$ 分别前缀和维护，$\Theta(1)$ 可求。

1. 最大值在右区间：

    与第一种情况大同小异，不再赘述。

### 最值都在右区间：

此时最值全部在右区间，长度这个系数仍然不好维护，我们采取与2中相同的思路：

$$\begin{aligned}
    cost_{i,j}&=\sum maxn_r\times minn_r\times len_{i\sim j}\\
    &=\sum maxn_r\times minn_r\times (len_{i\sim mid}+len_{mid+1\sim j})\\
    &=len_{i\sim mid} \times \sum maxn_r\times minn_r+\sum maxn_r\times minn_r\times len_{mid+1\sim j}
\end{aligned}$$

此时我们同样维护 $\sum maxn_r\times minn_r$ 与 $\sum maxn_r\times minn_r\times len_{mid+1\sim j}$ 的前缀和，$\Theta(1)$ 求解。

## Code

总体来说维护6种不同的系数前缀和，每次递归算跨中点贡献，双指针扫描跨中点区间即可。

```cpp
 #include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e5+10,p=1e9;
int n,ans(0),inv2;
int a[N];
int sum1[N],sum2[N],pre1[N],pre2[N],sum3[N],pre3[N];
void solve(int l,int r){
    if(l==r) return ans=(ans+a[l]*a[l]%p)%p,void();
    int mid((l+r)>>1);
    int maxr=0,minr=1e9;
    pre1[mid]=pre2[mid]=pre3[mid]=sum1[mid]=sum2[mid]=sum3[mid]=0; 
    for(int i=mid+1;i<=r;++i){
        maxr=max(maxr,a[i]);
        minr=min(minr,a[i]);
        sum1[i]=(sum1[i-1]+minr)%p;
        sum2[i]=(sum2[i-1]+maxr)%p;
        sum3[i]=(sum3[i-1]+minr*maxr%p)%p;
        pre1[i]=(pre1[i-1]+minr*(i-mid)%p)%p;
        pre2[i]=(pre2[i-1]+maxr*(i-mid)%p)%p;
        pre3[i]=(pre3[i-1]+maxr*minr%p*(i-mid)%p)%p;
    }
    int pos1(mid+1),pos2(mid+1);
    int maxnl(0),minnl(1e9);
    for(int i=mid;i>=l;--i){
        maxnl=max(maxnl,a[i]);
        minnl=min(minnl,a[i]);
        while(pos1<=r&&a[pos1]<=maxnl) pos1++;pos1--;
        while(pos2<=r&&a[pos2]>=minnl) pos2++;pos2--;
        int w1(min(pos1,pos2)),w2(max(pos1,pos2));
        ans=(ans+maxnl*minnl%p*((w1+mid-2*i+3)*(w1-mid)/2%p)%p)%p;
        if(pos1<pos2) ans=(ans+minnl*((pre2[w2]-pre2[w1]+p)%p+(mid-i+1)*(sum2[w2]-sum2[w1]+p)%p)%p)%p;
        if(pos2<pos1) ans=(ans+maxnl*((pre1[w2]-pre1[w1]+p)%p+(mid-i+1)*(sum1[w2]-sum1[w1]+p)%p)%p)%p;
        ans=(ans+(pre3[r]-pre3[w2]+p)%p+(mid-i+1)*(sum3[r]-sum3[w2]+p)%p)%p;
    }
    solve(l,mid),solve(mid+1,r);
}
signed main(){
    scanf("%lld",&n);
    for(int i=1;i<=n;++i) scanf("%lld",a+i);
    solve(1,n);
    printf("%lld",ans);
}
```

---

## 作者：chenzida (赞：6)

由于这题的题意十分清晰易懂，所以就不过多解释了，直接开始分析。

我们考虑将每一个区间 $[l,r]$ 分成两段，分别是 $[l,mid]$ 和 $[mid+1,r]$，然后我们思考如何求出 $\sum_{i=l}^r \sum_{j=l}^r (j-i+1)\max(a_i...a_j)\min(a_i...a_j)$。首先我们可以使用类似归并排序的递归分别求出在 $[l,mid]$ 和 $[mid+1,r]$ 内部的值，然后我们主要就是要求跨了两个区间的问题。

我们枚举 $[l,mid]$ 中每一个数，我们考虑将 $[mid+1,r]$ 分为三个部分，分别是 $\min,\max$ 都是用左区间的，其中一个用左区间的，和全都用右区间的。对于这三种情况我们依次讨论并用前缀和优化成 $O(1)$ 即可。

于是对于每一个 $[l,r]$ 都是 $O(r-l+1)$ 的，所以总的复杂度为 $O(n\log n)$。

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int NR=1e6+10;
const long long mod=1e9;
int n;
int a[NR];
int p[NR],q[NR];
ll sum[NR],num[NR];
ll sum1[NR],num1[NR];
ll sum2[NR],num2[NR];
ll ans;

void solve(int l,int r)
{
	if(l==r){ans=(ans+1ll*a[l]*a[l])%mod;return;}
	int mid=(l+r>>1);
	solve(l,mid),solve(mid+1,r);
	p[mid]=0,q[mid]=0x3f3f3f3f;
	sum[mid]=sum1[mid]=sum2[mid]=0;
	num[mid]=num1[mid]=num2[mid]=0;
	for(int i=mid+1;i<=r;i++) p[i]=max(p[i-1],a[i]);
	for(int i=mid+1;i<=r;i++) q[i]=min(q[i-1],a[i]);
	for(int i=mid+1;i<=r;i++) sum[i]=(sum[i-1]+1ll*p[i]*q[i]%mod*(i-mid+1))%mod;
	for(int i=mid+1;i<=r;i++) num[i]=(num[i-1]+1ll*p[i]*q[i])%mod;	
	for(int i=mid+1;i<=r;i++) sum1[i]=(sum1[i-1]+1ll*p[i]*(i-mid+1))%mod;
	for(int i=mid+1;i<=r;i++) num1[i]=(num1[i-1]+p[i])%mod;
	for(int i=mid+1;i<=r;i++) sum2[i]=(sum2[i-1]+1ll*q[i]*(i-mid+1))%mod;
	for(int i=mid+1;i<=r;i++) num2[i]=(num2[i-1]+q[i])%mod;
	int minn=0x3f3f3f3f,maxn=0;
	int mins=mid+1,maxs=mid+1;
	for(int i=mid;i>=l;i--)
	{
		minn=min(minn,a[i]),maxn=max(maxn,a[i]);
		while(q[mins]>=minn&&mins<=r) mins++;
		while(p[maxs]<=maxn&&maxs<=r) maxs++;
		if(mins<=maxs)
		{
			
			ans=(0ll+ans+1ll*minn*maxn%mod*((1ll*(mid+1-i+1+mins-1-i+1)*(mins-1-(mid+1)+1)/2)%mod))%mod;
			ans=(0ll+ans+1ll*maxn*((sum2[maxs-1]-sum2[mins-1]+1ll*(num2[maxs-1]-num2[mins-1])*(mid-i)%mod)%mod))%mod;
			ans=(0ll+ans+sum[r]-sum[maxs-1]+1ll*(num[r]-num[maxs-1])*(mid-i)%mod)%mod;
		}
		else
		{
			ans=(0ll+ans+1ll*minn*maxn%mod*((1ll*(mid+1-i+1+maxs-1-i+1)*(maxs-1-(mid+1)+1)/2)%mod))%mod;
			ans=(0ll+ans+1ll*minn*((sum1[mins-1]-sum1[maxs-1]+1ll*(num1[mins-1]-num1[maxs-1])*(mid-i)%mod)%mod))%mod;
			ans=(0ll+ans+sum[r]-sum[mins-1]+1ll*(num[r]-num[mins-1])*(mid-i)%mod)%mod;
		}
	}
}
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
int main()
{
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	n=read();
	for(int i=1;i<=n;i++) a[i]=read();
	solve(1,n);
	printf("%lld",(ans%mod+mod)%mod);
	return 0;
}
//珂学万岁！
//珂朵莉最可爱！
//我永远喜欢珂朵莉~
```

---

## 作者：封禁用户 (赞：4)

前话：最近老师信息课上讲了这道题，如果老师不讲我肯定不会做……肯定是应为我太弱了……但确实挺难想到的……

----

这道题的标签是分治与递归，我们就可以想一想怎么去做这道题。正常的分治方法：递归左右区间统计答案，再加上左区间对右区间的贡献。可是在这个题目中，怎么求一段左区间对于右区间的贡献呢？

假设我们要处理区间 $[l, r]$，中点为 $mid$ , 考虑这么一个事情：让 $i$ 从 $mid$ 往 $l$ 枚举，每次统计 $i$ 对 $[mid + 1, r]$ 的贡献。设置 $p$ 和 $q$ ，分别表示 $[i, mid]$ 中的最小值大于 $a_p$ 的首个 $p$ ，$[i,mid]$ 中的最大值小于 $a_q$ 的首个 $q$ 。

这样设立有什么好处呢？我们就可以分三段统计贡献（不妨设 $p \leq q$ ，反之亦然），分别是:

1.$[mid, p-1]$ 

2.$[p, q - 1]$ 

3.$[q, mid]$ 。

我们设 $mn$ 为 $[i,mid]$ 中的最小值， $mx$ 为 $[i, mid]$ 中的最大值，$calc(l,r)$ 为 $\frac{(l + r) (r - l + 1)}{2}$ （小学的高斯求和，还记得吗）

----

对于情况 1 就很好讨论，因为 $mn$ 和 $mx$ 都相等，所以贡献就为：

$mn \times mx \times calc(mid + 1,p - 1)$

对于情况 2, 3 复杂一点，$mn$ 相等，$mx$ 可以用前缀和维护（可以自行理解？）

------

你会了吗！

由于情况 2, 3 不太好描述，我把这一块的前缀和代码和情况 2, 3 的关键代码贴到这里。

前缀和维护：

~~~
sum[i][0] = (sum[i - 1][0] + mn) % mod;
sum[i][1] = (sum[i - 1][1] + mn * i) % mod;
sum[i][2] = (sum[i - 1][2] + mx) % mod;
sum[i][3] = (sum[i - 1][3] + mx * i) % mod;
sum[i][4] = (sum[i - 1][4] + mn * mx) % mod;
sum[i][5] = (sum[i - 1][5] + mn * mx % mod * i) % mod;
~~~

情况2：

~~~
ans = (ans + mx * (sum[q - 1][1] - sum[p - 1][1]) % mod) % mod;
ans = (ans - (i - 1) * (sum[q - 1][0] - sum[p - 1][0]) % mod * mx % mod + mod) % mod;
~~~

情况3：

~~~
ans = (ans + (sum[r][5] - sum[q - 1][5])) % mod;
ans = (ans - (sum[r][4] - sum[q - 1][4]) * (i - 1) % mod + mod) % mod;
~~~
以上代码均已 $p \leq q$ 为前提，反之亦然。

上面的代码还是很有思维难度的，如果没有完全理解一定要多看几遍，确保理解了计算贡献的过程。

这道题还有很多小细节需要注意，什么取模啦，预处理啊之类的，千万不要大意。

这里就把代码贴出来：

```
#include<bits/stdc++.h>
#define int long long
using namespace std;

int n, ans, mod = 1e9, a[5000005];
int sum[5000005][6];
int calc(int l, int r) {
	return (l + r) * (r - l + 1) / 2 % mod;
}
void solve(int l, int r) {
	if (l == r) {
		ans = (ans + a[l] * a[l] % mod) % mod;
		return ;
	}
	int mid = (l + r) >> 1;
	solve(l, mid), solve(mid + 1, r);
	memset(sum[mid], 0, sizeof sum[mid]);
	int mn, mx, p, q;
	mn = mx = a[mid + 1], p = q = mid + 1;
	for (int i = mid + 1; i <= r; i++) {
		mn = min(mn, a[i]);
		mx = max(mx, a[i]);
		sum[i][0] = (sum[i - 1][0] + mn) % mod;
		sum[i][1] = (sum[i - 1][1] + mn * i) % mod;
		sum[i][2] = (sum[i - 1][2] + mx) % mod;
		sum[i][3] = (sum[i - 1][3] + mx * i) % mod;
		sum[i][4] = (sum[i - 1][4] + mn * mx) % mod;
		sum[i][5] = (sum[i - 1][5] + mn * mx % mod * i) % mod;
	}
	mn = mx = a[mid];
	for (int i = mid; i >= l; i--) {
		mn = min(mn, a[i]);
		mx = max(mx, a[i]);
		while (p <= r && a[p] > mn) p++;
		while (q <= r && a[q] < mx) q++;
		if (p < q) {
			ans = (ans + calc(mid + 1 - i + 1, p - 1 - i + 1) * mn % mod * mx) % mod;
			ans = (ans + mx * (sum[q - 1][1] - sum[p - 1][1]) % mod) % mod;
			ans = (ans - (i - 1) * (sum[q - 1][0] - sum[p - 1][0]) % mod * mx % mod + mod) % mod;
			ans = (ans + (sum[r][5] - sum[q - 1][5])) % mod;
			ans = (ans - (sum[r][4] - sum[q - 1][4]) * (i - 1) % mod + mod) % mod;
		}
		else {
			ans = (ans + calc(mid + 1 - i + 1, q - 1 - i + 1) * mx % mod * mn) % mod;
			ans = (ans + mn * (sum[p - 1][3] - sum[q - 1][3]) % mod) % mod;
			ans = (ans - (i - 1) * (sum[p - 1][2] - sum[q - 1][2]) % mod * mn % mod + mod) % mod;
			ans = (ans + (sum[r][5] - sum[p - 1][5])) % mod;
			ans = (ans - (sum[r][4] - sum[p - 1][4]) * (i - 1) % mod + mod) % mod;
		}
	}
}

signed main() {
	scanf("%lld", &n);
	for (int i = 1; i <= n; i++) {
		scanf("%lld", &a[i]);
	}
	solve(1, n);
	printf("%lld", ans); 
    return 0;
}
```

我太弱了……

---

## 作者：Fido_Puppy (赞：3)

$$\texttt{Preface}$$

学数据结构学坏脑子，只会无脑线段树了。

$$\texttt{Description}$$

[P6406 [COCI2014-2015#2] Norma](https://www.luogu.com.cn/problem/P6406)

$$\texttt{Solution}$$

设 $\max(l, r) = \max\{a_l, a_{l+1},\cdots, a_r\},\min(l,r)=\min\{a_l,a_{l+1},\cdots,a_r\}$。

看到这种对于所有区间求一个式子的和，我们可以套路地转换成枚举 $r$，求出：

$$\sum_{l = 1}^r \max(l,r)\times \min(l,r) \times(r-l+1)$$

我们可以用两个单调栈，这样求 $\max(l,r)$ 和 $\min(l,r)$ 就变成了区间加或者区间覆盖了。

然后考虑 $(r-l+1)$，我们可以把它拆成 $r+1$ 和 $-l$，这样我们只需要分别维护：

$$\sum_{i = 1}^r \max(i, r)\times \min(i,l)$$

$$\sum_{i = 1}^r \max(i, r)\times \min(i,l) \times i$$

用线段树维护即可，后面那个式子下传懒标记时需要用到等差数列求和公式。

$$\texttt{Code}$$

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int mod = 1e9;
int n, a[500005], ans = 0;
struct node {
	int l, r, sa1, sb1, sa2, sb2, ans1, ans2;
} tr[2000005];
struct tag {
	int a1, a2;
} lazy[2000005];
#define ls (p * 2)
#define rs (p * 2 + 1)
void pushup(int p) {
	tr[p].sa1 = (tr[ls].sa1 + tr[rs].sa1) % mod;
	tr[p].sb1 = (tr[ls].sb1 + tr[rs].sb1) % mod;
	tr[p].sa2 = (tr[ls].sa2 + tr[rs].sa2) % mod;
	tr[p].sb2 = (tr[ls].sb2 + tr[rs].sb2) % mod;
	tr[p].ans1 = (tr[ls].ans1 + tr[rs].ans1) % mod;
	tr[p].ans2 = (tr[ls].ans2 + tr[rs].ans2) % mod; 
}
void build(int p, int l, int r) {
	tr[p].l = l, tr[p].r = r;
	tr[p].sa1 = tr[p].sb1 = tr[p].sa2 = tr[p].sb2 = 0;
	tr[p].ans1 = tr[p].ans2 = 0;
	if (l == r) return ;
	int mid = (l + r) / 2;
	build(ls, l, mid), build(rs, mid + 1, r);
}
void add(int &x, int y) {
	x += y;
	if (x >= mod) x -= mod;
}
void add_tag(int p, tag t) {
	if (t.a1) {
		add(lazy[p].a1, t.a1);
		add(tr[p].ans1, 1ll * tr[p].sb1 * t.a1 % mod);
		add(tr[p].ans2, 1ll * tr[p].sb2 * t.a1 % mod);
		add(tr[p].sa1, 1ll * (tr[p].r - tr[p].l + 1) * t.a1 % mod);
		add(tr[p].sa2, 1ll * (tr[p].l + tr[p].r) * (tr[p].r - tr[p].l + 1) / 2 % mod * t.a1 % mod);
	}
	if (t.a2) {
		add(lazy[p].a2, t.a2);
		add(tr[p].ans1, 1ll * tr[p].sa1 * t.a2 % mod);
		add(tr[p].ans2, 1ll * tr[p].sa2 * t.a2 % mod);
		add(tr[p].sb1, 1ll * (tr[p].r - tr[p].l + 1) * t.a2 % mod);
		add(tr[p].sb2, 1ll * (tr[p].l + tr[p].r) * (tr[p].r - tr[p].l + 1) / 2 % mod * t.a2 % mod);
	}
}
void pushdown(int p) {
	if (lazy[p].a1 or lazy[p].a2) {
		add_tag(ls, lazy[p]);
		add_tag(rs, lazy[p]);
		lazy[p] = (tag){0, 0};
	}
}
void update(int p, int x, int y, tag t) {
	if (tr[p].l >= x && tr[p].r <= y) {
		return add_tag(p, t), void();
	}
	pushdown(p);
	int mid = (tr[p].l + tr[p].r) / 2;
	if (x <= mid) update(ls, x, y, t);
	if (mid < y) update(rs, x, y, t);
	pushup(p);
}
#undef ls
#undef rs
int main() {
	ios :: sync_with_stdio(0), cin.tie(0);
	cin >> n;
	for (int i = 1; i <= n; ++i) {
		cin >> a[i];
	}
	build(1, 1, n);
	stack <int> sta1, sta2;
	sta1.push(0), sta2.push(0);
	for (int i = 1; i <= n; ++i) {
		while (sta1.top() && a[ sta1.top() ] <= a[i]) {
			int x = sta1.top(), val = a[ sta1.top() ]; sta1.pop();
			update(1, sta1.top() + 1, x, (tag){a[i] - val, 0});
		}
		sta1.push(i), update(1, i, i, (tag){a[i], 0});
		while (sta2.top() && a[ sta2.top() ] >= a[i]) {
			int x = sta2.top(), val = a[ sta2.top() ]; sta2.pop();
			update(1, sta2.top() + 1, x, (tag){0, a[i] - val + mod});
		}
		sta2.push(i), update(1, i, i, (tag){0, a[i]});
		(ans += (1ll * tr[1].ans1 * (i + 1) % mod - tr[1].ans2 + mod) % mod) %= mod;
	}
	cout << ans << '\n';
	return 0;
}
```

$$\texttt{Thanks for watching!}$$

---

## 作者：lyhqwq (赞：2)

一眼丁真：鉴定为码量+推式子题
## 思路
### 40pts
预处理一下 ST 表， $O(n^2)$ 枚举左右端点，ST 表 $O(1)$ 查一下最值，总的复杂度是 $O(n^2)$ 的。

### 100pts

考虑暴力分治。

每次将区间 $[l,r]$ 分成 $[l,mid]$ 和 $[mid+1,r]$，递归计算贡献。

所以问题转化成为了如何求 $L \in [l,mid]$ 且 $R \in [mid+1,r]$ 的区间的贡献。

我们发现，对于固定的右端点，随着左端点的变小，区间的最小值单调不增，区间的最大值单调不降。

所以我们可以考虑枚举右端点计算贡献。

假设我们分治到 $[l,r]$ ，目前要计算贡献的区间是 $[L,R]$ ，这个区间的最小值和最大值由两部分组成： $[L,mid]$ 和 $[mid+1,R]$。

我们把区间分为三段
1. 区间最大值和最小值都由 $[mid+1,R]$ 决定
1. 区间最大值和最小值其中一个由 $[L,mid]$ 决定
1. 区间最大值和最小值都由 $[L,mid]$ 决定

因为最值是单调的，所以每段一定是连续的，所以可以分开计算贡献。

我们在枚举右端点的过程中记录 $[mid+1,R]$ 的最大值 $Max$ 和最小值 $Min$。

令：

$lmin_i$ 表示 $\min_{j=i}^{mid}a_j$

${lmax}_i$ 表示 $\max_{j=i}^{mid}a_j$

第一类的贡献为 $\sum_{i=p1}^{mid}(R-i+1)\times Min \times Max$

第二类的贡献分为两种：

$\sum_{i=p2}^{p1}(R-i+1)\times lmin_i \times Max$

$\sum_{i=p2}^{p1-1}(R-i+1)\times {lmax}_i \times Min$

第三类的贡献为 $\sum_{i=l}^{p2-1}(R-i+1)\times lmin_i \times {lmax}_i$

其中 $p1,p2$ 分别为第一类区间和第二类区间、第二类区间和第三类区间的分界点。

对于每次 $R\gets R+1$ 时，用类似双指针的思想，暴力移动 $p1,p2$。

但这样无法做到计算贡献时 $O(1)$。

我们考虑拆开式子用前缀和维护。

对于第一类

$Min\times Max \times((R+1)\times(mid-p1+1)-\sum_{i=p1}^{mid}i)$

维护 $i$ 的前缀和即可。

对于第二类

$Min \times ((R+1)\sum_{i=p2}^{p1-1}lmax_i-\sum_{i=p2}^{p1-1}i\times {lmax}_i)$

维护 ${lmax}_i$ 和 $i\times {lmax}_i$ 的前缀和即可，另一种同理。

对于第三类

$(R+1)\sum_{i=l}^{p2-1}lmin_i\times {lmax}_i-\sum_{i=l}^{p2-1}i\times lmin_i \times {lmax}_i$

维护 $lmin_i \times {lmax}_i$ 和 $i\times lmin_i \times {lmax}_i$ 的前缀和即可。

这样就做到了每层复杂度 $O(n)$ ，总复杂度 $O(n\log n)$ 了。

## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=500005;
const int Mod=1e9;
int n,ans;
int a[N],s[N],lmin[N],slmin[N],lmax[N],slmax[N];
int f[N];//l*Min
int g[N];//l*Max
int h[N];//l*Min*Max;
int sx[N],sy[N];
void solve(int l,int r){
    if(l==r){
        ans=(ans+a[l]*a[l]%Mod)%Mod;
        return;
    }
    int mid=(l+r)>>1;
    solve(l,mid);
    solve(mid+1,r);
    lmin[mid+2]=0x7f7f7f7f;
    lmax[mid+2]=slmax[mid+2]=slmin[mid+2]=0; 
    f[l-1]=g[l-1]=h[l-1]=sx[l-1]=0;
    for(int i=mid+1;i>=l;i--){
        lmin[i]=min(lmin[i+1],a[i]);
        lmax[i]=max(lmax[i+1],a[i]);
        slmin[i]=(i!=mid+1?slmin[i+1]:0)+lmin[i];
        slmax[i]=slmax[i+1]+lmax[i];
    }
    for(int i=l;i<=mid+1;i++){
        f[i]=(f[i-1]+i*lmin[i]%Mod)%Mod;
        g[i]=(g[i-1]+i*lmax[i]%Mod)%Mod;
        h[i]=(h[i-1]+i*lmin[i]%Mod*lmax[i]%Mod)%Mod;
        sx[i]=(sx[i-1]+lmin[i]*lmax[i]%Mod)%Mod;
    }
    int Min=a[mid+1],Max=a[mid+1];
    int p1=mid;
    while(lmin[p1]>=Min&&lmax[p1]<=Max&&p1>=l) p1--;
    p1++;
    int p2=p1-1;
    while(!(lmin[p2]<Min&&lmax[p2]>Max)&&p2>=l) p2--;
    p2++;
	for(int R=mid+1;R<=r;R++){
        Min=min(Min,a[R]);
        Max=max(Max,a[R]);
        if(R!=mid+1){
            while(lmin[p1]>=Min&&lmax[p1]<=Max&&p1>=l) p1--;
            p1++;
            while(!(lmin[p2]<Min&&lmax[p2]>Max)&&p2>=l) p2--;
            p2++;
        }
        if(p1!=mid+1) ans=(ans+((R+1)*(mid-p1+1)%Mod*Min%Mod*Max%Mod-((s[mid]-s[p1-1]+Mod)%Mod)*Min%Mod*Max%Mod+Mod)%Mod)%Mod;
        if(lmin[p2]<Min) ans=(ans+((R+1)*((slmin[p2]-slmin[p1]+Mod)%Mod)%Mod-(f[p1-1]-f[p2-1]+Mod)%Mod+Mod)%Mod*Max%Mod)%Mod;
        else if(lmax[p2]>Max) ans=(ans+((R+1)*((slmax[p2]-slmax[p1]+Mod)%Mod)%Mod-(g[p1-1]-g[p2-1]+Mod)%Mod+Mod)%Mod*Min%Mod)%Mod;
        ans=(ans+((R+1)*((sx[p2-1]-sx[l-1]+Mod)%Mod)%Mod-(h[p2-1]-h[l-1]+Mod)%Mod+Mod)%Mod)%Mod;
    }
}
signed main(){
    scanf("%lld",&n);
    for(int i=1;i<=n;i++){
        scanf("%lld",&a[i]);
        s[i]=(s[i-1]+i)%Mod;
    }
    solve(1,n);
    printf("%lld\n",ans);
    return 0;
}

```


---

## 作者：Phrvth (赞：0)

$\mathcal{Update}\ at\ 2023.10.12$

## Question

给出一个序列 $A$，定义 $f(l,r)$ 为

$$
f_{l,r}=(r-l+1)\times \max(l,r) \times \min(l,r)
$$
其中 $\max(a,b)$ 表示 $A_a \sim A_b$ 的最大值，$\min$ 同理。

求
$$
\sum_{l=1}^n \sum_{r=l}^n f(l,r)
$$

## Solution

对于这种给一个序列求每个二元组的值，一般考虑分治。

那我们考虑当前要处理的区间为 $[L,R]$，$mid$ 为其中点，我们递归求解 $[L,mid]$ 和 $[mid + 1,R]$，现在我们只需要处理 $l\in[L,mid],r\in(mid,R]$ 的二元组即可。

考虑枚举每一个 $l$，计算这个 $l$ 对答案产生的贡献。

容易想到，这个贡献分为三类。

+ 右区间被左区间的最大最小值完全包裹着
+ 右区间有一个最值被左区间包裹着
+ 右区间与左区间没关系

我们形式化这些情况，设 $\min(l, mid)$ 对右边产生的最远的影响为 $a$，$\max(l,mid)$ 对右边产生的最远的影响为 $b$。

然后因为好处理，我们考虑设 $w1$ 为 $\min(a,b)$，$w2$ 为 $\max(a,b)$，然后分情况考虑。

+ $r\in [min,w1]$

这个区间的最大值分明就是 $\max(l,mid)$ 和 $\min(l,mid)$，所以这个区间对答案产生的贡献为：
$$
\sum_{i=mid+1}^{w1} f(l,i)=\max(l,mid) \times \min(l,mid) \times \sum_{i=mid+1}^{w1} (i-l+1)
$$
然后右边的求和符号明显是等差数列，我们使用小学知识把他拆掉最后化简，得到：
$$
\sum_{i=mid+1}^{w1} f(l,i)=\max(l,mid) \times \min(l,mid) \times \frac{w_1+mid-2l+3}{2}
$$

+ $r\in (w1,w2]$

然后又分成两种情况。

1. $a<b$

这种情况呢，可以使用最大值，但是最小值使用不了。

这里有个重点，**在分治问题中，mid 是极其重要的**。

比如这里，我们考虑把答案拆成两部分，即为 $[l,mid]$ 和 $(mid,w2]$ 去求解。

答案即为：

$$
\sum_{r=w_1+1}^{w_2} f(l,i)=(\sum_{w1+1}^{w2}(mid-l+1)\times \min(mid+1,i) \times \max(l,mid)) + (\sum_{w1+1}^{w2}(i-(mid+1)-1) \times \min(mid+1,w2) \times max(l,mid))
$$

看起来很长，但是很简单，第一个大括号是求 $[l,mid]$ 的贡献，因为右边的最小值才是整个区间的最小值，所以乘的是右区间的最小值和左区间的最大值。

最后通过乘法分配律把两个区间拼在一起得到答案。

我们对这个式子进行化简。

$$
\sum_{r=w1+1}^{w2} f(l,i)=(mid-l+1) \times \max(l,mid)  \times \sum_{i=w1+1}^{w2} \min(mid+1,i)+\max(l,mid) \times \sum_{w1+1}^{w2}(i-mid) \times \min(mid+1,i)
$$

然后对里面的求和符号我们可以使用**前缀和**拆开。

我们令 $S1_{i,0}$ 表示前面那一段的前缀和，$S1_{i,1}$ 表示后面的那段的前缀和，即

$$
\begin{aligned}
S1_{i,0} &= \sum_{j=mid+1}^i \min(mid+1,j)\\
S2_{i,0} &= \sum_{j=mid+1}^i \min(mid_1,j) \times (j-mid)
\end{aligned}
$$

然后这一段的贡献可以化简为：

$$
\sum_{r=w1+1}^{w2} f(l,i)=\max(l,mid)\times ((mid-l+1)\times (S1_{w2,0} - S1_{w1,0})+(S1_{w2,1} - S1_{w1,1}))
$$

2. a>b

同理的，可以推出贡献为：
$$
\sum_{r=w1+1}^{w2} f(l,i)=\min(l,mid)\times ((mid-l+1)\times (S2_{w2,0} - S2_{w1,0})+(S2_{w2,1} - S2_{w1,1}))
$$
+ $r\in(w2,R]$

这段区间完全和上面的处理方法一样，只是前缀和的数组需要变一下，我觉得读者们应该都懂吧。

$$
\sum_{r=w2+1}^{R} f(l,i)=(S3_{R,1}-S3_{w2,1}) + ((mid-l+1)+(S3_{R,0}-S3_{w2,0}))
$$

至此，我们的全部情况都讨论清楚了，接下来有几个问题放在后面说一下。

+ 时间复杂度证明

做以上操作是 $\mathcal{O}(n)$ 的，至于求 $w1,w2$ 使用双指针就可以了

所以应用主定理应该可以知道复杂度为 $\mathcal{O}(n\log n)$ 的，相当优秀。

+ 可行性证明

辰星凌老师在他的题解上说是因为前缀最大值或最小值有单调性，但是我认为，这就是普通的前缀和啊？不是很懂，如果错了能不能踢踢我，我也想知道

感谢大佬帮我解决了这个问题，这里给出解答：

**双指针** 的前提是有单调性，所以需要前缀最大值或最小值有单调性才可以双指针

最后是代码了，但是我觉得这道题应该不是很难调，所以我就不放了QWQ

错了踢踢我

完结撒花✿✿ヽ(°▽°)ノ✿


---

## 作者：Eltaos_xingyu (赞：0)

双倍经验：[**SP22343**](http://www.luogu.com.cn/problem/SP22343)

## 题目描述

给定一个序列 $ a_i,\cdots,a_n $，求：

$$\sum_{i=1}^{n}\sum_{j=i}^{n}(j-i+1)\min(a_i,a_{i+1},\cdots,a_j)\max(a_i,a_{i+1},\cdots,a_j)$$

## 分析

根据 $ n \leq 5\times10^5 $，$O(n^3)$ 的暴力肯定要炸，于是考虑分治，即把序列分成左区间与右区间，分别计算以下三种情况：

1. 区间左右端点均落在左区间。

2. 区间左右端点均落在右区间。

3. 区间左端点落在左区间，区间右端点落在右区间。

其中第 $1$，$2$ 种情况用分治递归解决就行了，于是来着重解决如何求第 $3$ 种情况的问题。

首先，暴力枚举求第 $3$ 种情况的时间复杂度显然是 $O(n^2)$，总时间复杂度是 $O(n^2 \log n)$，肯定是过不了的。于是可以想一些关于区间的优化：

线段树？好吧，这个蒟蒻作者不会线段树维护区间最大最小值。

单调队列？虽然使用单调队列可以不用分治，但是由于区间长度是不定的，这也需要 $O(n^2)$ 的时间复杂度，还是过不了。

前缀和？前缀最小最大值的前缀和？这能算吗......好像真可以......

于是用分治+前缀和预处理，$O(n \log n)$ 的时间复杂度就能过掉此题。

## 具体实现

~~（为什么要推这种式子啊）~~

如果在左区间内定一个下标 $ i $，对于每一个 $ i $，记 $ mi $ 为在 $ a_i,\cdots ,a_{mid} $ 内的最小值下标，$ mx $ 为该区间内最大值下标。显而易见，当 $ i=mid,mid-1,\cdots,1 $ 时，$ mi $ 与 $ mx $ 是严格单调递减的。

同样的，记 $ mi_{to} $ 为右区间内最后一个大于 $ a[mi] $ 的下标，$ mx_{to} $ 为右区间内最后一个小于 $ a[mx] $ 的下标。同样显而易见的是，当 $ i=mid,mid-1,\cdots,1 $ 时，$ mi_{to} $ 与 $ mx_{to} $ 是严格单调递增的。

所以，我们可以将第三种情况对于每一个 $ i $ 分 $ 3 $ 个部分来求：

### 第一个部分：$ [mid+1,\min(mi_{to},mx_{to})] $

这一部分最大值为 $ mx $，最小值为 $ mi $，直接等差数列求和就行了，这里就不赘述了。

### 第二个部分：$ [\min(mi_{to},mx_{to}),\max(mi_{to},mx_{to})] $

这一部分 $ mi_{to} $ 与 $ mx_{to} $ 只有一个可用，这个时候就要用前缀和了。假定 $ mi_{to} > mx_{to} $，最小值可用 $ mi_{to} $，最大值就只能用右区间的前缀最大值的前缀和。但是由于 $ i $ 不定，又不能针对于每一个 $ i $ 都算一遍（不然时间复杂度就爆炸了），所以前缀和要算两次，具体如下：

设 $ sum1_k $ 是 $ \max(a_{mid},\cdots,a_k) $ 的前缀和，$ sum2_k $ 是 $ (k + 1) \times \max(a_{mid},\cdots,a_k) $ 的前缀和。

由于区间长度为 $ k-i+1 $，所以可知，这一部分的贡献是 $ sum2[\max(mi_{to},mx_{to})]-sum2[\min(mi_{to},mx_{to})]-i\times(sum1[\max(mi_{to},mx_{to})]-sum1[\min(mi_{to},mx_{to})]) $。

~~（作者推式子好累，但打式子更累）~~

$ mi_{to} < mx_{to} $ 是一样的。

### 第三个部分：$ [\max(mi_{to},mx_{to}),r] $

只要第二部分搞出来了那这一部分就没什么问题了，不过是求 $ \max(a_{mid},\cdots,a_k) \times \min(a_{mid},\cdots,a_k) $ 和 $ (k+1)\times\max(a_{mid},\cdots,a_k) \times \min(a_{mid},\cdots,a_k)  $ 的前缀和就行了。

这样这道题就搞出来了。

什么？你说取模爆炸了？来试试 \_\_int128 吧！（见代码）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=5e5+5;
const __int128 mod=1e9;
long long a[MAXN];
__int128 summin1[MAXN],summin2[MAXN],summax1[MAXN],summax2[MAXN],summul1[MAXN],summul2[MAXN];
__int128 fz(int l,int r){
	if(l==r)return a[l]*a[l];
	if(l+1==r)return (a[l]*a[l]+a[r]*a[r]+2*min(a[l],a[r])*max(a[l],a[r]));
	__int128 mid=(l+r)/2;
	__int128 ans=(fz(l,mid)+fz(mid+1,r));
	__int128 nowmin=a[mid+1],nowmax=a[mid+1];
	summin1[mid]=summin2[mid]=summax1[mid]=summax2[mid]=summul1[mid]=summul2[mid]=0;
	summin1[mid+1]=a[mid+1];
	summin2[mid+1]=a[mid+1]*(mid+2);
	for(int i=mid+2;i<=r;i++){
		if(a[i]<nowmin)nowmin=a[i];
		summin1[i]=summin1[i-1]+nowmin;
		summin2[i]=(i+1)*nowmin+summin2[i-1];
	}
	summax1[mid+1]=a[mid+1];
	summax2[mid+1]=a[mid+1]*(mid+2);
	for(int i=mid+2;i<=r;i++){
		if(a[i]>nowmax)nowmax=a[i];
		summax1[i]=summax1[i-1]+nowmax;
		summax2[i]=(i+1)*nowmax+summax2[i-1];
	}
	nowmin=a[mid+1],nowmax=a[mid+1];
	summul1[mid+1]=a[mid+1]*a[mid+1];
	summul2[mid+1]=a[mid+1]*a[mid+1]*(mid+2);
	for(int i=mid+2;i<=r;i++){
		if(a[i]<nowmin)nowmin=a[i];
		if(a[i]>nowmax)nowmax=a[i];
		summul1[i]=summul1[i-1]+nowmax*nowmin;
		summul2[i]=(i+1)*nowmax*nowmin+summul2[i-1];
	}
	int mi=mid,mx=mid,mi_to=mid,mx_to=mid;
	for(int k=mid;k>=l;k--){
		if(a[k]<a[mi])mi=k;
		if(a[k]>a[mx])mx=k;	
		while(a[mi_to]>=a[mi]&&mi_to<=r)mi_to++;
		if(mi_to>mid)mi_to--;
		while(a[mx_to]<=a[mx]&&mx_to<=r)mx_to++;
		if(mx_to>mid)mx_to--;
		ans+=(((min(mi_to,mx_to)-k+1+mid-k+2)*(min(mi_to,mx_to)-mid))*a[mi]*a[mx])/2;
		if(mi_to>mx_to)ans+=(summax2[mi_to]-summax2[mx_to]-k*(summax1[mi_to]-summax1[mx_to]))*a[mi];
		else ans+=(summin2[mx_to]-summin2[mi_to]-k*(summin1[mx_to]-summin1[mi_to]))*a[mx];
		ans+=(summul2[r]-summul2[max(mx_to,mi_to)]-k*(summul1[r]-summul1[max(mx_to,mi_to)]));
	}
	return ans;
}
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	cout<<(long long)((fz(1,n))%mod);
}
```


---

## 作者：柠檬熟了 (赞：0)

**紫题买一赠一**  **[SP22343 Norma](https://www.luogu.com.cn/problem/SP22343)**

##

## 题意翻译

在给定的序列 $T$ 中**任取两点**，记两点区间内 **最大值，最小值，区间长度** 的 **积** 为 $S$，求**所有**可能的 $S$ 的 **和**。

## 题目分析

先来分析要求的**时间复杂度**，本题中 $N= 5\times 10^5$，可以推断时间复杂度应当在 $O(N\log N)$ 以内。

于是我们充分发扬人类智慧，在这个时间复杂度基础上，可以想到分治的算法。

采用**二分**处理完两点**均在** 左半 或 右半 的情况，**剩余的情况**中必然一点选在左半区间，一点选在右半区间，**单次复杂度**在 $O(N)$ 级别。

仅需考虑剩余情况，

若是暴力选取，即**分别在左右区间枚举**选点，则**单次复杂度**为 $O(N^2)$，不合要求。

故想到须**预处理**右半内容，使得在**左半区间**内枚举时可以 $O(1)$ 得到**右半区间**的**贡献**。

（~~主要是我写的预处理右边，实际上处理左边似乎也行...？~~

## 具体实现

（~~万恶的表达式推导！~~

给定序列 $T[N]$，在左区间选点 $Lp$，右区间选点 $Rp$。

($S=\min \{ T_{Lp} \cdots T_{Rp} \}\times \max \{ T_{Lp} \cdots  T_{Rp} \}\times (Rp-Lp+1)$

定义**当前区间** 左边界 $L$，右边界 $R$，中项 $M=(L+R)/2$。

在左区间 $[L, M]$ 内**倒序**枚举 $Lp$，同时更新 $[T_{Lp}, T_{M}]$ 内最小值 $Mi$，最大值 $Mx$。

在右区间 $[M+1, R]$ 中找到**最小的** $k$ 使得 $T_{k}<Mi$，同时找到**最小的** $l$ 使得 $T_{l}>Mx$。

易证随着 $Lp$ **递减**，$k, l$ 均成**单调递增**趋势，故**一次完整枚举**时间复杂度为 $O(N)$。


------------


**不妨设** $k \ge l$，于是显然**右区间**被分成 $[M+1, l), [l, k), [k, R]$ **三段**：

- 当 $Rp$ 落在 $[M+1, l)$ 中时，$[T_{Lp},T_{Rp}]$ 区间内**极值**即是 $Mi, Mx$。

  $$
  \because  \min \{ T_{Lp}\cdots T_{Rp} \}=Mi，\max \{ T_{Lp} \cdots T_{Rp} \}=Mx \\
  $$
  $$
  \therefore S=Mi\cdot Mx\cdot (Rp-Lp+1)\\
  $$
  $$
  \text 又\because Rp\in[M+1,l)\\
  $$
  $$
  \therefore \sum S=(Mi\cdot Mx)\cdot(\sum_{i=M+1}^{l-1}i-Lp+1)\\\\
  $$
  $$
  =(Mi\cdot Mx)\cdot [(M+1-Lp+1)+(l-1-Lp+1)]*(l-1-M-1+1) /2\\
  $$
  $$
  =(Mi\cdot Mx)\cdot (M+l-2\cdot Lp+2)\cdot (l-M-1)/2\\
  $$
  对于每次枚举，$M，Lp，l$ 均为定值，故可 $O(1)$ 求解贡献。

- 当 $Rp$ 落在 $[l, k)$ 中时，$[T_{Lp},T_{Rp}]$ 区间内最小值为 $Mi$，最大值在 $[l, Rp]$ 中。
  $$
  \because \min \{ T_{Lp}\cdots T_{Rp} \}=Mi，\max \{ T_{Lp}\cdots  T_{Rp} \}\in[l, Rp] \\
  $$
  $$
  \therefore S=Mi\cdot \max \{T_{l} \cdots  T_{Rp} \}\cdot (Rp-Lp+1)\\
  $$
  $$
  \text 记 \max \{T_{l} \cdots  T_{Rp} \}=MAX_{Rp}\\
  $$
  $$
  \because Rp\in[l, k)\\
  $$
  $$
  \therefore \sum S=Mi\cdot\sum_{i=l}^{k-1} [MAX_{i}\cdot (i-Lp+1)]\\
  $$
  $$
  =Mi\cdot\{\sum_{i=l}^{k-1} [MAX_{i}\cdot (i+1)]-\sum_{i=l}^{k-1} (MAX_{i}\cdot Lp)\}\\
  $$
  对于每次枚举，$Lp，l，k$ 为定值，且 $l，k\in[M+1, R]$

  故只需在枚举前维护两个前缀和，$\sum MAX_{i}$，$\sum MAX_{i}\cdot(i+1)$ 

  $i\in [M+1,R]$

  枚举时对应项代入式子即可 $O(1)$ 求解贡献。

  (当 $k \le l$ 时，上述 $\max$ 与 $\min$ 取反即可，并还需维护两个 $MIN$ 前缀和)

  

- 当 $Rp$ 落在 $[k, R]$ 中时，$[T_{Lp},T_{Rp}]$ 区间内最小值在 $[k, Rp]$ 中，最大值在 $[l, Rp]$ 中。

  $$
  \because \min \{ T_{Lp}\cdots  T_{Rp} \}\in[k, Rp]， max \{ T_{Lp} \cdots T_{Rp} \}\in[l, Rp] \\
  $$
  $$
  \therefore S=\min \{T_{k} \cdots  T_{Rp}\}\cdot \max \{T_{l} \cdots  T_{Rp} \}\cdot (Rp-Lp+1)\\
  $$
  $$
  \text 记 \max \{T_{l} \cdots  T_{Rp} \}=MAX_{Rp}，\min \{ T_{k} \cdots  T_{Rp} \}=MIN_{Rp}\\
  $$
  $$
  \because Rp\in[k, R]\\
  $$
  $$
  \therefore \sum S=\sum_{i=k}^{R} [MAX_{i}\cdot MIN_{i}\cdot(i-Lp+1)]\\
  $$
  $$
  =\sum_{i=k}^{R} [MAX_{i}\cdot MIN_{i}\cdot(i+1)]-\sum_{i=k}^{R} (MAX_{i}\cdot MIN_{i}\cdot Lp)\\
  $$
  对于每次枚举，$Lp，k，R$ 为定值，且 $k\in [M+1, R]$

  同理维护前缀和，$\sum MAX_{i}\cdot MIN_{i}\cdot (i+1)$，$\sum MAX_{i}\cdot MIN_{i}$

  枚举时对应项代入式子即可 $O(1)$ 求解贡献。


------------

将三段所得贡献**累加**，即得到确定 $Lp$ 且 $Rp \in [M+1, R]$ 时的贡献和，时间复杂度 $O(1)$。

枚举 $Lp \in [L, M]$ 并累加贡献即得答案。



## 玄学优化

- 递归到段长 $R-L \le 2$ 时可直接返回此段贡献。

  ```c++
  if (R==L) return T[L]*T[L];
  if (R==L+1) return T[L]*T[L]+T[R]*T[R]+T[L]*T[R]*2;
  ```


- 取模爆炸？难以调试？来试试 ```__int128``` 吧！

  将代码中**所有**使用的**计算数组**改为 ```__int128``` 类型，只需最后**输出答案**时取模即可！

    （空间可过，需要自己写输入输出函数。

## 代码

```cpp
#include <bits/stdc++.h>
#define MOD 1000000000
using namespace std;
__int128 a[500005];
__int128 sum1[500005], sum2[500005], sum3[500005], sum4[500005];
__int128 sum5[500005], sum6[500005];
__int128 ans=0;
int N;

inline __int128 read(){
    __int128 x = 0, f = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9'){
        if(ch == '-')
            f = -1;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9'){
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
inline void print(__int128 x){
    if(x < 0){
        putchar('-');
        x = -x;
    }
    if(x > 9)
        print(x / 10);
    putchar(x % 10 + '0');
}
//使用__int128减少不必要的取模
__int128 TF (int L, int R) {
	__int128 temp=0;
	__int128 M, mi=1<<30, mx=0, k, l, w1, w2; 
	//mi -> min[a[L]...a[M]], mx -> max[a[L]...a[M]]
	//w1 -> min(k, l), w2 -> max(k, l)
	if (L==R) return a[L]*a[L]; //段长小于等于 2 时直接返回
	if (L+1==R) return (a[L]*a[R]*2+a[L]*a[L]+a[R]*a[R])%MOD;
	else M=(L+R)>>1, temp+=TF(L, M), temp+=TF(M+1, R); 
   //否则二分求解两点都取在左半、右半的贡献
	temp=temp%MOD, k=M+1, l=M+1;
   //预处理前缀和 MIN[i]，(M+1 <= i <= R)
	sum1[M+1]=a[M+1], sum1[M]=0;
	for (int p=M+2; p<=R; ++p)
		sum1[p]=min(sum1[p-1]-sum1[p-2], a[p])+sum1[p-1];
   //预处理前缀和 MIN[i]*(i+1)，(M+1 <= i <= R)
	sum2[M+1]=sum1[M+1]*(M+2), sum2[M]=0;
	for (int p=M+2; p<=R; ++p)
		sum2[p]=(sum1[p]-sum1[p-1])*(p+1)+sum2[p-1];
	//预处理前缀和 MAX[i]，(M+1 <= i <= R)
   sum3[M+1]=a[M+1], sum3[M]=0;
	for (int p=M+2; p<=R; ++p)
		sum3[p]=max(sum3[p-1]-sum3[p-2], a[p])+sum3[p-1];
   //预处理前缀和 MAX[i]*(i+1)，(M+1 <= i <= R)
   sum4[M+1]=sum3[M+1]*(M+2), sum4[M]=0;
	for (int p=M+2; p<=R; ++p)
		sum4[p]=(sum3[p]-sum3[p-1])*(p+1)+sum4[p-1];
   //预处理前缀和 MIN[i]*MAX[i]，(M+1 <= i <= R)
   sum5[M+1]=sum1[M+1]*sum3[M+1], sum5[M]=0;
	for (int p=M+2; p<=R; ++p)
		sum5[p]=(sum1[p]-sum1[p-1])*(sum3[p]-sum3[p-1])+sum5[p-1];
   //预处理前缀和 MIN[i]*MAX[i]*(i+1)，(M+1 <= i <= R)
   sum6[M+1]=sum1[M+1]*sum3[M+1]*(M+2), sum6[M]=0;
	for (int p=M+2; p<=R; ++p)
		sum6[p]=(sum1[p]-sum1[p-1])*(sum3[p]-sum3[p-1])*(p+1)+sum6[p-1];
	//开始枚举 Lp（下文中使用 p）
	for (int p=M; p>=L; --p) {
		//更新 Mi，Mx
		mi=min(mi, a[p]), mx=max(mx, a[p]);
		//递增查找 k，l
		while (k<=R&&a[k]>=mi) ++k;
		while (l<=R&&a[l]<=mx) ++l;
		w1=min(k, l), w2=max(k, l);
		//M+1 <= Rp < l 时的贡献
		temp+=((M-p+2)+(w1-p))*(w1-M-1)*mi*mx/2, temp=temp%MOD;
		//l <= Rp < k 或 k <= Rp < l 时的贡献
		if (k<l) temp+=((sum2[w2-1]-sum2[w1-1])-(sum1[w2-1]-sum1[w1-1])*p)*mx, temp=temp%MOD;
		else temp+=((sum4[w2-1]-sum4[w1-1])-(sum3[w2-1]-sum3[w1-1])*p)*mi, temp=temp%MOD;
		//k <= Rp <= R 时的贡献
		temp+=(sum6[R]-sum6[w2-1])-(sum5[R]-sum5[w2-1])*p, temp=temp%MOD;

	}
	return temp;
}
int main () {
	N=read();
	for (int i=1; i<=N; ++i)
		a[i]=read();
	print(TF(1, N))%MOD;
}
```



---


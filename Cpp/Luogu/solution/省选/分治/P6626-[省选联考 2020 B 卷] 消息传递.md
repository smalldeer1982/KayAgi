# [省选联考 2020 B 卷] 消息传递

## 题目描述

给定一个包含 $n$ 个人（从 $1$ 到 $n$ 编号）的树形社交网络。如果一个人在某天收到了一条消息，则下一天他会将消息传递给所有与他有直接社交关系的人。

现在有 $m$ 次询问，每次询问假定第 $0$ 天 $x$ 号人收到了一条消息，请你计算第 $k$ 天时新收到此条消息的人数（即第 $k$ 天前收到过此条消息的人不计入其中）。不同询问间互不影响。

## 说明/提示

**样例解释**

第一个询问，第一天新收到消息的人只有 $2$ 号。
第二个询问，第一天新收到消息的人有 $1$、$3$ 号，第二天新收到消息的人有 $4$ 号。

**数据范围与约定**

对于测试点 $1$：$1\le n, m\le 10$。  
对于测试点 $2$：$1\le n, m\le 100$。  
对于测试点 $3$：$1\le n, m\le 1000$。  
对于测试点 $4\sim6$：$1\le n, m\le 10^5, k\le 20$。  
对于测试点 $7\sim10$：$1\le n, m\le 10^5$。  
对于所有测试点：$1\le T\le 5, 1\le x\le n, 0\le k < n$。

## 样例 #1

### 输入

```
1
4 2
1 2
2 3
3 4
1 1
2 2```

### 输出

```
1
1```

# 题解

## 作者：xuyuansu (赞：21)

## 简要题意
给你一个 $ n $ 个点的树，有 $ m $ 次询问，问和一个点距离为 $ k $ 的点的数量。

## 本题解法：点分治
首先我们需要把询问挂上树，离线处理，给每个点开个 vector 存下来。

由于是求点的个数，所以分两种情况讨论：在没有将这个询问所在的点作为当前点分治的中心时，我们要将所有询问中 $ k $ 大于当前深度的询问存下，其实就是求经过当前中心的长 $ k-dep[x] $ 的路径有多少条；当这个询问是分治中心时，直接加上答案就可以了，最后减掉不合法的情况。

实际情况中我们是不分类的，那样会增大码量，统一使用桶记录该距离有多少个点解决。
## 代码
```c
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int T,n,m,ver[N*2],ne[N*2],head[N],tot,root,siz[N],son[N],ma,s,ans[N],dep[N],t[N];
bool vis[N];
void add(int x,int y)
{
    ver[++tot]=y;ne[tot]=head[x];head[x]=tot;
}
vector<pair<int,int> > v[N],q;
void getroot(int x,int fa)
{
    siz[x]=1;son[x]=0;
    for(int i=head[x];i;i=ne[i])
    {
        int y=ver[i];
        if(y==fa || vis[y]) continue;
        getroot(y,x);
        siz[x]+=siz[y];
        son[x]=max(son[x],siz[y]);
    }
    son[x]=max(son[x],s-siz[x]);
    if(son[x]<ma) ma=son[x],root=x;
}
int md;
void getdis(int x,int fa)
{
    t[dep[x]]++;md=max(md,dep[x]);
    for(auto i : v[x])
    {
        if(i.first+1<dep[x]) continue;
        q.push_back(make_pair(i.first-dep[x]+2,i.second));
    }
    for(int i=head[x];i;i=ne[i])
    {
        int y=ver[i];
        if(y==fa || vis[y]) continue;
        dep[y]=dep[x]+1;
        getdis(y,x);
    }
}
void consolate(int x)
{
    q.clear();md=0;
    dep[x]=1;getdis(x,0);
    for(auto i : q)
    {
        ans[i.second]+=t[i.first];
    }
    for(int i=1;i<=md;i++) t[i]=0;
    for(int i=head[x];i;i=ne[i])
    {
        int y=ver[i];
        if(vis[y]) continue;
        md=0;q.clear();
        dep[y]=2;getdis(y,x);
        for(auto j : q)
        {
            ans[j.second]-=t[j.first];
        }
        for(int j=1;j<=md;j++) t[j]=0;
    }
}
void divide(int rt)
{
    consolate(rt);
    vis[rt]=1;
    for(int i=head[rt];i;i=ne[i])
    {
        int y=ver[i];
        if(vis[y]) continue;
        ma=0x3f3f3f3f;s=siz[y];root=0;
        getroot(y,0);
        divide(root);
    }
}
int main()
{
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d%d",&n,&m);
        memset(head,0,sizeof(head));
        memset(ans,0,sizeof(ans));
        memset(vis,0,sizeof(vis));tot=0;
        for(int i=1;i<=n;i++) v[i].clear();
        for(int i=1;i<n;i++)
        {
            int x,y;scanf("%d%d",&x,&y);
            add(x,y);add(y,x);
        }
        for(int i=1;i<=m;i++)
        {
            int x,y;scanf("%d%d",&x,&y);
            v[x].push_back(make_pair(y,i));
        }
        ma=0x3f3f3f3f,s=n;
        getroot(1,0);
        divide(root);
        for(int i=1;i<=m;i++) printf("%d\n",ans[i]);
    }
    return 0;
}
```


---

## 作者：Flan (赞：17)

> 给你一棵大小为 $n$ 的树和 $m$ 组询问 $(x_i, k_i)$，回答与 $x_i$ 距离为 $k_i$ 的点个数。

这是一道点分治题。  
指定一个点（重心）为根，那么对于任意一个非根的节点 $x$，与它距离为 $k$ 的点无非会有两种情况：子树内或子树外。  
对于在子树外的节点，用一个桶 $\text {give[]}$ 来记录各个节点与根的关系。即 $\text {give[i]}$ 表示与根距离为 $i$ 的点的个数。  
如果一个子树外的点 $y$ 与 $x$ 的距离为 $k$，那么它们一定满足 $\text {dep[x]} + \text {dep[y]} = k$。所以可以直接把对应的桶 $\text {give[} k - \text{dep[x]]}$ 计入答案。  
而子树内的结点，分治处理即可。时间复杂度 $O(n \log n)$。
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>

inline int read(void){
	int res = 0;
	char ch = std::getchar();
	while(ch < '0' || ch > '9')
		ch = std::getchar();
	while(ch >= '0' && ch <= '9')
		res = res * 10 + ch - 48, ch = std::getchar();
	return res;
}

const int MAXN = 1e5 + 19;


namespace message{
	struct Edge{
		int to, next;
	}edge[MAXN << 1];
	
	int head[MAXN], cnt;
	bool vist[MAXN];
	
	inline void add(int from, int to){
		edge[++cnt].to = to;
		edge[cnt].next = head[from];
		head[from] = cnt;
	}
	
	namespace gravity{
		int n, size[MAXN], root, max_size;
		
		void dfs0(int node, int f){
			size[node] = 1;
			for(int i = head[node]; i; i = edge[i].next)
				if(edge[i].to != f && !vist[edge[i].to]){
					dfs0(edge[i].to, node);
					size[node] += size[edge[i].to];
				}
		}
		
		void dfs1(int node, int f){
			int g = n - size[node];
			for(int i = head[node]; i; i = edge[i].next)
				if(edge[i].to != f && !vist[edge[i].to]){
					dfs1(edge[i].to, node);
					g = std::max(g, size[edge[i].to]);
				}
			if(g < max_size)
				max_size = g, root = node;
		}
		
		int getroot(int node){
			max_size = 0x3f3f3f3f;
			dfs0(node, -1);
			n = size[node];
			dfs1(node, -1);
			return root;
		}
	}
	
	using gravity::getroot;
	
	int n, m;
	int dep[MAXN], size[MAXN];
	int give[MAXN];
	
	std::vector<int> query[MAXN], ans[MAXN];
	
	int stack[MAXN], top;
	int begin[MAXN], end[MAXN];
	
	void dfs(int node, int f){
		dep[node] = dep[f] + 1;
		stack[++top] = node;
		for(int i = 0; i < query[node].size(); ++i)
			if(dep[node] == query[node][i])
				++ans[node][i];
		for(int i = head[node]; i; i = edge[i].next)
			if(edge[i].to != f && !vist[edge[i].to])
				dfs(edge[i].to, node);
	}
	
	void solve(int node){
		node = getroot(node);
		vist[node] = 1;
		dep[node] = 0;
		for(int i = head[node]; i; i = edge[i].next)
			if(!vist[edge[i].to]){
				begin[edge[i].to] = top + 1;
				dfs(edge[i].to, node);
				end[edge[i].to] = top + 1;
				for(int j = begin[edge[i].to]; j != end[edge[i].to]; ++j)
					++give[dep[stack[j]]];
			}
		for(int i = 0; i < query[node].size(); ++i)
			ans[node][i] += give[query[node][i]];
		for(int i = head[node]; i; i = edge[i].next)
			if(!vist[edge[i].to]){
				for(int j = begin[edge[i].to]; j != end[edge[i].to]; ++j)
					--give[dep[stack[j]]];
				for(int j = begin[edge[i].to]; j != end[edge[i].to]; ++j)
					for(int k = 0; k < query[stack[j]].size(); ++k)
						if(query[stack[j]][k] > dep[stack[j]])
							ans[stack[j]][k] += give[query[stack[j]][k] - dep[stack[j]]];
				for(int j = begin[edge[i].to]; j != end[edge[i].to]; ++j)
					++give[dep[stack[j]]];
			}
		while(top)
			--give[dep[stack[top--]]];
		for(int i = head[node]; i; i = edge[i].next)
			if(!vist[edge[i].to])
				solve(edge[i].to);
	}
	
	int x[MAXN], y[MAXN], k[MAXN];
	
	int main(){
		std::memset(vist, 0, sizeof vist);
		std::memset(head, 0, sizeof head), cnt = 0;
		n = read(), m = read();
		for(int i = 2; i <= n; ++i){
			int u = read(), v = read();
			add(u, v), add(v, u);
		}
		for(int i = 1; i <= m; ++i)
			x[i] = read(), k[i] = read();
		for(int i = 1; i <= m; ++i)
			query[x[i]].clear(), ans[x[i]].clear();
		for(int i = 1; i <= m; ++i){
			query[x[i]].push_back(k[i]);
			ans[x[i]].push_back(0);
			y[i] = ans[x[i]].size() - 1;
		}
		solve(1);
		for(int i = 1; i <= m; ++i)
			std::printf("%d\n", k[i] == 0 ? 1 : ans[x[i]][y[i]]);
		return 0;
	}
}

int main(){
	for(int T = read(), i = 1; i <= T; ++i)
		message::main();
	return 0;
}
```

---

## 作者：loveJY (赞：9)

经典点分治?

拿到题,首先的想法就是离线一下,把每个询问挂到每个点上去处理,其次就是发现和[P6329 【模板】点分树 | 震波](https://www.luogu.com.cn/problem/P6329)
很像,而且好像还是个弱化版?

那么顺理成章的想到点分治,那么就考虑怎么分别贡献

设目前我们选定的分治中心y,他子树中的某个点x,计算他对于**跨过分治中心**的答案

首先我们要用掉$dep[x]$天的时间把信息传输到根,然后再用目前剩下的询问天数$k-dep[x]$天把根传输给其他的子树中的点

那么也就是说其他子树中深度为$k-dep[x]$的点的个数就是对于这个询问目前的贡献,其他的贡献递归下去还能计算,因为如果存在一些子树内的合法点是答案,您发现这个就是一子树内某个点做分治中心的子问题了

那么我们可以考虑求出一个rev数组表示深度为i的点有多少个,这个复杂度是$O(n)$的,在要处理一个子树的答案时,我们率先递归进这个子树把这个子树的信息从rev数组里去掉(防止计算多了),然后在算完这个子树答案之后再加回来就好了

最后还有一点细节,比如注意不要访问vis为1的点,以及对于分治中心统计答案要单独提出

~~还有不太懂这个vector怎么清掉数据的同时释放内存啊..~~

代码中都有所体现

code:


```cpp

#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<vector>
#define fi first
#define se second
#define mkp(x,y) (make_pair(x,y))
using namespace std;
const int MAXN = 4e5 + 7;
namespace fastIO {
#define BUF_SIZE (1<<19)
	static char buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = buf + BUF_SIZE;
	inline char nc() {
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, 1, BUF_SIZE, stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x = 0;
		char s = nc();
		for(; !isdigit(s); s = nc());
		for(; isdigit(s); s = nc())x = (x << 1) + (x << 3) + s - '0';
		return x;
	}
}
using namespace fastIO;
int T, n, m;
int home[MAXN], nxt[MAXN], to[MAXN], ccnt, ans[MAXN], vis[MAXN];
inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}
int siz[MAXN], dp[MAXN], rt, SUM;
inline void getroot(int u, int F) {
	//点分治经典
	siz[u] = dp[u] = 1;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F || vis[v])continue;
		getroot(v, u);
		siz[u] += siz[v];
		if(siz[v] > dp[u])dp[u] = siz[v];
	}
	if(SUM - siz[u] > dp[u])dp[u] = SUM - siz[u];
	if(dp[u] < dp[rt])rt = u;
	return ;
}
vector<pair<int, int> > a[MAXN];
int rev[MAXN], dep[MAXN];
inline void getdis(int u, int F) {
	//第一遍,计算深度
	rev[dep[u]]++;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F || vis[v])continue;
		dep[v] = dep[u] + 1;
		getdis(v, u);
	}
}

inline void getans(int u, int F) {
	//计算一个子树的答案
	int S = a[u].size();
	for(int i = 0; i < S; ++i) {
		int k = a[u][i].fi - dep[u];
		if(k < 0)continue;
		ans[a[u][i].se] += rev[k];
	}
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F || vis[v])continue;
		getans(v, u);
	}
}

inline void remove(int u, int F, int V) {
	//移除/加回 影响
	rev[dep[u]] += V;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F || vis[v])continue;
		remove(v, u, V);
	}
	return ;
}

inline void doit(int u) {
	int maxdep = 0;
	dep[u] = 0;
	getdis(u, 0);
	//单独算
	int S = a[u].size();
	for(int i = 0; i < S; ++i) {
		int k = a[u][i].fi - dep[u];
		if(k < 0)continue;
		ans[a[u][i].se] += rev[k];
	}
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(vis[v])continue;
		remove(v, u, -1);
		getans(v, u);
		remove(v, u, 1);
	}
	remove(u, 0, -1);
	return ;

}

inline void solve(int u) {
	vis[u] = 1;
	doit(u);
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(vis[v])continue;
		SUM = siz[u];
		rt = 0;
		dp[rt] = 1e9;
		getroot(v, u);
		solve(rt);
	}
	return ;
}

inline void init() {
	memset(home, 0, sizeof(home));
	ccnt = 0;
	rt = 0;
	dp[rt] = 1e9;
	memset(ans, 0, sizeof(ans));
	memset(vis, 0, sizeof(vis));
	//这个清空erase更好吗?
	for(int i = 1; i <= n; ++i) {
		a[i].clear();
	}
}

int main() {
	T = read();
	while(T-- > 0) {
		init();
		n = read();
		m = read();
		for(int i = 1, x, y; i < n; ++i) {
			x = read();
			y = read();
			ct(x, y);
			ct(y, x);
		}
		for(int i = 1, x, y; i <= m; ++i) {
			x = read();
			y = read();
			a[x].push_back(mkp(y, i));
		}
		SUM = n;
		getroot(1, 0);
		solve(rt);
		for(int i = 1; i <= m; ++i)printf("%d\n", ans[i]);
	}
	return 0;
}



```



---

## 作者：Sin_Watt (赞：7)

[在我的blog，获得更好的碗以食用。](https://sine-tea.com/article/4cd9b5e7)

---
**省流：**

~~长剖做法，全网首发，最优拿下，把某点分治吊杀。~~

实际上卡满的话没有点分治快。

---

长链剖分属于树链剖分的一种。不过重儿子是**子树深度**最大的那个儿子（称为长儿子）。

长剖性质有：
 - 长链的长度之和为 $O(n)$。
 - 对于树上的任何一个点跳长链到根，需要经过不超过 $O(\sqrt{n})$ 条长链。长链的长度依次为 $1,2,3,\cdots,\sqrt{n}$ 时卡满。

由于第二条性质，使得长剖的发挥空间比重剖小。不过由于长剖独特的定义，使得其可以在与距离相关的部分问题中，给出线性且低常数神奇做法。比如长剖优化 DP。

---

我们用 $son[u]$ 表示非叶子节点 $u$ 的长儿子。

定义 $f[u][i]$ 为以 $u$ 为根的子树中，与 $u$ 距离为 $i$ 的点的个数。我们每个节点的状态直接继承其长儿子的节点状态（$f[u][i]\gets f[son[u]][i-1]$），同时将短儿子的 DP 状态暴力合并。

有意思的是，由于继承的过程可以视为 DP 数组**整体后移一位**，所以可以利用指针 $O(1)$ 的实现这个过程。而每个长链只会被暴力合并一次，所以时间总复杂度是 $O(n)$ 的。同时，每个叶子节点需要 $O(1)$ 的空间，每个非叶子节点由于继承了长儿子，只需要 $O(1)$ 的额外空间，所以空间总复杂度也是 $O(n)$ 的。

为什么不能用重剖实现呢？重剖不同与长剖，无法保证重儿子的子树深度不小于轻儿子的子树深度。这会使得合并时没有对应的空间存储 DP 状态。

注意，由于长儿子的 DP 数组会被继承走，所以询问要挂在点上，不能在线。虽然短儿子的 DP 数组不会受到影响。

做到这里，我们已经把子树内的贡献解决了。然后发现子树外的不是很好做。如果定义 $g[u][i]$ 为以 $u$ 为根的子树外，与 $u$ 距离为 $i$ 的点的个数，时空复杂度完全无法承受。我为此困惑了很久（~~试图长剖换根 DP~~）。回顾 $f$ 的过程，发现**状态数由链长限制**，这启发我们把 $g[u][i]$ 限制到长链以内。即重新定义 $g[u][i]$ 为 **以 $u$ 所在长链的链顶**为根的子树内，以 $u$ 为根的子树外，与 $u$ 距离为 $i$ 的点的个数。此时状态数被控制在了二倍链长以内（从长链的底端的叶子到另一个叶子，而另一个叶子的深度不大于长链的底端的叶子）。

明确了 $g$ 之后，转移不难。如果自己是长儿子，就继承父亲。然后再暴力合并上短儿子的 $f$。这里是 $f$ 哦，看清！

注意，$f$ 是自下而上的，$g$ 是自上而下的，继承方向相反，注意实现（看注释）。

长链内的信息，我们可以用 $f[u]$ 和 $g[u]$ 保证。但可能有长链外的信息遗失。跳长链即可。这里不好讲解，看注释。

但时间复杂度也无奈的来到了 $O(n+q\sqrt{n})$。~~但是常数就是小啊，你来打我呀～~~

代码较短，不过细节较多。

```cpp
const int N = 1e5 + 7;

int n, m;

struct E {
    int to, ne;
} e[N << 1];
int h[N];
int idx;

inline void add(int x, int y) {
    e[ ++ idx] = (E){y, h[x]};
    h[x] = idx;
}

vector<pair<int, int>> Q[N];
int ans[N];

int hei[N];  // 子树深度
int son[N];  // 长儿子
int far[N];  // 父亲
int top[N];  // 链顶
int dfn[N];  // 长剖后的 dfs 序
int dnt;
int fff[N];  // f 的空间池

int zero = 0;  // 无奈之举

/*
 ! ! ! !   马蜂警告   ! ! ! !

对于一个数组 shuzu[]
一般下标为 i 的元素由 shuzu[i] 表达
如果你看到 i[shuzu] 的写法，请不要惊惶，这与上面等价
注释里我尽可能避免下面这个写法

 - - - -   一些规定   - - - -

注释里，
top直接表示长链链顶节点
btm直接表示长链链底节点

有 dfn[btm] = dfn[top] + hei[top] - 1

*/

// 第一遍dfs 长剖
void dfs1(int u, int fa) {
    for (int i = h[u]; i; i = e[i].ne) {
        int v = e[i].to;
        if (v == fa) continue;
        dfs1(v, u);
        if (u[son][hei] < v[hei]) {
            u[son] = v;
        }
    }
    u[far] = fa;
    u[hei] = u[son][hei] + 1;
}

/*
由于本人不喜指针，故利用 dfs 序实现O(1)继承
我们把 f[u][0] 放在 fff[dfn[u]] 处
这样 f[u][1] 从 f[son[u]]][0] 继承时，
fff[dfn[son[u]]] <=> fff[dfn[u]]

一段长链的空间范围为 【 dfn[top] ， dfn[btm] 】
*/

inline int &f(int i, int j) {
    if (j >= hei[i] || j < 0) return zero;  //  询问里的 k 可能超过当前链长
    else return fff[i[dfn] + j];
}

// 第二遍 dfs 求 f
void dfs2(int u, int tp) {
    u[top] = tp;
    u[dfn] = ++ dnt;
    if (u[son]) {
        dfs2(u[son], tp);
    }
    for (int i = h[u]; i; i = e[i].ne) {
        int v = e[i].to;
        if (v == u[far] || v == u[son]) {
            continue;
        }
        dfs2(v, v);
    }
    /*
    注意，这里并没有合并短儿子
    f 仅包含长儿子内的信息
    */
    
    for (auto i : Q[u]) {
        int x = u;
        int y = i.second;
        while (x && y >= 0) {
            ans[i.first] += f(x, y);
            // 跳长链
            y -= x[top][hei] - x[hei] + 1;
            x = x[top][far];
        }
    }
    
    // 合并信息
    f(u, 0) = 1;
    for (int i = h[u]; i; i = e[i].ne) {
        int v = e[i].to;
        if (v == u[far] || v == u[son]) {
            continue;
        }
        for (int j = 0; j < v[hei]; ++ j) {
            f(u, j + 1) += f(v, j);
        }
    }
}

int ggg[N * 2];

/*

构造 g 的空间有点麻烦

先确认左极限 g[top][hei[top] - 1]
  确认右极限 g[btm][0]
  需要 2 * hei[top] - 1 的空间
  确认大致空间范围 【 2*(dfn[top]) ， 2*(dfn[btm]) 】

链长为 4，dfn[top] = 6 时，
dfn[btm] = 9;

在空间池里状态：
下标  10  11  12  13  14  15  16  17  18  19  20 
     ——— ——— ——— ——— ——— ——— ——— ——— ——— ——— ——— 
    |   |   | + | + | + | + | + | + | + |   |   |
     ——— ——— ——— ——— ——— ——— ——— ——— ——— ——— ——— 
              ^           ^       ^   ^
              |     g[top][0]     |  g[btm][0]
    g[top][hei[top] - 1]     g[btm][1]

于是可以构造 g[u][0] 为 ggg[dfn[btm]*2 - (hei[u] - 1)]
                    => ggg[dfn[btm] + dfn[u]]
            g[u][i] 为 ggg[dfn[btm] + dfn[u] - i]
                    => ggg[dfn[top] + hei[top] - 1 + dfn[u] - i]
*/

inline int &g(int i, int j) {
    if (i[top][hei] + i[top][hei] - i[hei] <= j) return zero;
    return ggg[i[dfn] + i[top][dfn] + i[top][hei] - j - 1];
}

// 第三遍 dfs 求 g
void dfs3(int u) {
    /*
    此时 g 为 u 子树以外的信息
    */
    g(u, 0) = 1;
    for (int i = h[u]; i; i = e[i].ne) {
        int v = e[i].to;
        if (v == u[far] || v == u[son]) continue;
        for (int j = 0; j < v[hei]; ++ j) {
            g(u, j + 1) += f(v, j);
            /*
            因为短儿子的 DP 数组不会被继承
            所以 f(v, j) 是可用的
            */
        }
    }
    /*
    此时 g 为长儿子以外的信息
    */
    for (auto i : Q[u]) {
        // 本长链内，长儿子外的信息
        ans[i.first] += g(u, i.second);
        
        int x = u[top];
        int y = i.second - x[hei] + u[hei];
        while (x > 1 && y > 0) {
            /*
            注意这里脑抽的跳长链方式
            因为上一层里统计了这一层的信息（相当于走出长链又立刻走回来了
            所以我们要减去一个 f
            由于我们要同时访问两条链的信息，所以只能停在长链顶
            */
            ans[i.first] += g(x[far], y - 1) - f(x, y - 2);
            x = x[far];
            y -= x[top][hei] - x[hei] + 1;
            x = x[top];
        }
    }
    /*
    此时 g 为长儿子以外的信息，它还要处理短儿子内的询问
    */
    for (int i = h[u]; i; i = e[i].ne) {
        int v = e[i].to;
        if (v == u[far] || v == u[son]) continue;
        dfs3(v);
    }
    /*
    g[u] 使命结束，传给 g[son[u]]
    */
    if (u[son]) {
        dfs3(u[son]);
    }
}

inline void INIT() { }

inline void WORK() {
    rd(n, m);
    for (int i = 2; i <= n; ++ i) {
        int x, y;
        rd(x, y);
        add(x, y);
        add(y, x);
    }
    for (int i = 1; i <= m; ++ i) {
        int x, k;
        rd(x, k);
        Q[x].push_back({i, k});
        ans[i] = 0;
    }
    dfs1(1, 0);
    dfs2(1, 1);
    dfs3(1);
    
    for (int i = 1; i <= m; ++ i) {
        wr(ans[i], '\n');
        ans[i] = 0;
    }
    
    idx = 0;
    dnt = 0;
    for (int i = 1; i <= n; ++ i) {
        h[i] = 0;
        hei[i] = 0;
        son[i] = 0;
        fff[i] = 0;
        ggg[i * 2] = 0;
        ggg[i * 2 + 1] = 0;
        Q[i].clear();
    }
}
```

---

## 作者：David24 (赞：6)

分治做法，但不是点分治。

考虑与 x 距离为 k 的点，贡献分为两个部分：在 x 子树内与在 x 子树外。

对于 x 子树内的部分，问题等价于查询 x 子树内深度为 ``dep[x] + d`` 的点的个数，也就是区间某数出现次数。

由于作者画功不好，只能通过定义阐述内容。

假设树为以 1 为根的有根树，将 x 到 1 的最短路径上除 x 外的所有点称为树杈。

将该最短路径上所有边去除后，将每个树杈 y 位于的联通块称为 y 的树链。

对于一个树链，将其树杈 y 及 y 所直接连接的所有边去除后，剩余的若干联通块统称为 y 的树枝，称其中直径最大的联通块的直径为该树链的最大深度。

对于每个树杈，我们称与其直接连接的树杈中深度较大的树杈为其前驱。（对于与 x 直接连接的树杈特别定义其前驱为 x）。

对于 x 子树外的部分，答案为所有树杈 y 的树链内深度为 ``d - (dep[x] - dep[y]) + dep[y]`` 的点的个数的和。

容易发现，y 的树链其实就是 y 的子树去除 y 的前驱的子树，所以对于每个树杈 y，其贡献为 y 的子树内深度为 ``d - (dep[x] - dep[y]) + dep[y]`` 的点的个数减去 y 的前驱的子树内深度为 ``d - (dep[x] - dep[y]) + dep[y]`` 的点的个数，也就是区间某数出现次数。

已知区间某数出现次数存在 $O(n\sqrt{n}) - O(1)$ 的可持久化块状树做法，即将线段树分为 $\sqrt{n}$ 叉后可持久化。

显然，此时复杂度的全部瓶颈在于枚举树杈，最劣复杂度为 $O(n\sqrt{n} + nq)$

对k进行根号分治，当 $k \le B$ 时，有贡献的树杈个数只有最多B个，直接暴力枚举即可，复杂度为 $O(qB)$。

当 $k > B$ 时，继续进行分治：树链的最大深度 $\le T$ 的树杈和 $> T$ 的树杈。

容易发现，最大深度 $\le T$ 的树杈中对答案有贡献的树杈只有 $\le T$ 个，也就是深度在 ``[dep_x - d, dep_x - (d - T)]`` 中的树杈。

显然，这些树杈我们可以 $O(T)$ 枚举，这一部分的复杂度为 $O(qT)$。

对于最大深度 $ > T$ 的树杈，个数只有 $\le \dfrac{n}{T}$ 个。

对于每个树杈 y 记录一个 z，表示为深度最大的满足 $siz_z - siz_y > T$ 的树杈。查询时只需要从 x 出发，不停前往 z 并记录贡献即可。

显然，枚举到的 z 一定覆盖了所有最大深度 $> T$ 的树杈。

这一部分复杂度也是 $O(\dfrac{qn}T)$。

然后就得到了一个 $O(n\sqrt{n} + qB + qT + \dfrac{qn}{T})$ 时间复杂度和 $O(n\sqrt{n})$ 空间复杂度的算法（可持久化块状树空间复杂度为 $O(n \sqrt{n})$.然而，这道题对空间比较严苛，实现不好的 $O(n\sqrt{n})$ 空间复杂度不能通过。

于是我们考虑用 $O(n) - O(\log n)$ 且线性空间的 vector 代替可持久化块状树。这是在不采用 $O(n\sqrt{n})$ 空间复杂度时查询较快的一种方法，因为二分的常数通常非常小。

由于分界点两侧都用到了这个查询，所以没有办法平衡复杂度。

容易发现，当 $T = B = \sqrt{n}$ 时 $O(n\sqrt{n} \log n)$ 的复杂度很难通过 $n = 10^5$。

作者在多次提交后发现，将 T 和 B 调到非常小时程序效率有显著提高。

这是因为，由于数据中树的形态比较集中，大部分树链都非常大，向上跳的次数远小于 $\dfrac{n}{T}$。

经过测试，T = 30 效率最佳。 

注意到第一次根号分治本质上没有多少用处，但是可以有效帮助我们处理边界情况，降低思维难度。

## 代码：

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>
#include <cstdlib>
#include <cmath>
#include <deque>
using namespace std;
const int N = 1e5 + 10;
#define mp make_pair
#define pii pair<int, int>
int read()
{
    int x = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9')
    {
        if (c == '-')
            f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9')
    {
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
int T, tot, n, m, t, cnt;
int head[N], ver[N * 2], last[N * 2], f[N][30], siz[N], pre[N], l[N], r[N], dep[N];
int a[N], ans[N], vis[N], bac[N];
vector<int> v[N];
int g[N];
void add(int x, int y)
{
    ver[++tot] = y;
    last[tot] = head[x];
    head[x] = tot;
}
int find(int x)
{
    int S = siz[x];
    for (int j = 20; j >= 0; j--)
        if (f[x][j] && siz[f[x][j]] - S < t)
            x = f[x][j];
    return x;
}
int find2(int x, int y)
{
    int D = dep[x];
    for (int j = 20; j >= 0; j--)
        if (f[x][j] && D - dep[f[x][j]] < y)
            x = f[x][j];
    return x;
}
void dfs(int x, int fa)
{
    siz[x] = 1;
    l[x] = ++cnt;
    bac[cnt] = x;
    dep[x] = dep[fa] + 1;
    for (int i = head[x]; i; i = last[i])
    {
        int y = ver[i];
        if (y == fa)
            continue;
        f[y][0] = x;
        for (int j = 1; j <= 20; j++)
            f[y][j] = f[f[y][j - 1]][j - 1];
        dfs(y, x);
        siz[x] += siz[y];
    }
    r[x] = l[x] + siz[x] - 1;
}
void init()
{
    tot = cnt = 0;
    for (int i = 1; i <= n; i++)
        head[i] = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 0; j <= 20; j++)
            f[i][j] = 0;
    for (int i = 1; i <= n; i++)
        a[i] = 0, ans[i] = 0, bac[i] = 0;
    for (int i = 1; i <= n; i++)
        v[i].clear();
}
int query(int num, int l, int r, int d, int xs)
{
    int L = lower_bound(v[d].begin(), v[d].end(), l) - v[d].begin(), R = upper_bound(v[d].begin(), v[d].end(), r) - v[d].begin() - 1;
    return R - L + 1;
}
int ask(int x, int y, int z, int d, int num)
{
    int cha = dep[y] - dep[x], res = 0;
    res += query(num, l[x], r[x], d - cha + dep[x], 1);
    if (z)
        res -= query(num, l[z], r[z], d - cha + dep[x], -1);
    return res;
}
int main()
{
    T = read();
    while (T--)
    {
        n = read(), m = read();
        init();
        t = 30;
        for (int i = 1; i < n; i++)
        {
            int u = read(), v = read();
            add(u, v);
            add(v, u);
        }
        dfs(1, 0);
        for (int i = 1; i <= n; i++)
            pre[i] = find(i);
        for (int i = 1; i <= n; i++)
            v[dep[bac[i]]].push_back(i);
        for (int i = 1; i <= m; i++)
        {
            int x = read(), d = read(), res = 0;
            res += ask(x, x, 0, d, i);
            if (d <= t)
            {
                int cur = x;
                for (int j = 1; j <= t; j++)
                {
                    if (cur == 1)
                        break;
                    res += ask(f[cur][0], x, cur, d, i);
                    cur = f[cur][0];
                }
            }
            else
            {
                int cur = find2(x, d - t), cntt = 0;
                while (cur != 1 && dep[x] - dep[cur] <= d)
                {
                    vis[f[cur][0]] = 1;
                    g[++cntt] = f[cur][0];
                    res += ask(f[cur][0], x, cur, d, i);
                    cur = f[cur][0];
                }
                cur = x;
                while (cur != 1)
                {
                    cur = pre[cur];
                    if (cur == 1)
                        break;
                    if (vis[f[cur][0]])
                    {
                        cur = f[cur][0];
                        continue;
                    }
                    res += ask(f[cur][0], x, cur, d, i);
                    cur = f[cur][0];
                }
                for (int i = 1; i <= cntt; i++)
                    vis[g[i]] = 0;
            }
            printf("%d\n", res);
        }
    }
    return 0;
}
```





---

## 作者：2018LZY (赞：5)

~~看完题目就想到60分的做法,暴力分真足~~

然后可以盲猜一个复杂度$O(n\log n)$或者$O(n\log^2 n)$.

~~无脑的我竟然想到倍增和换根,但是一点用都没有,除非你的权值树资瓷快速相减以及权值的整体加减~~

于是不难想到点分治+离线.

这样的话,我们就可以$O((n+m)\log n)$解决.

具体的,我们现在处理过$x$的贡献,暴力扫描所有子树并用一个桶$c$记录每个深度出现了几次.

当我们需要查询一个子树的每个点的答案的时候,先暴力撤销整颗子树的影响,查询完以后再暴力修改即可.

~~这真是一道优秀的模板题~~

```cpp
#include<bits/stdc++.h>
#define gc getchar()//(p1==p2&&(p2=(p1=buf)+fread(buf,1,size,stdin),p1==p2)?EOF:*p1++)
#define mk make_pair
#define pi pair<int,int>
#define pb push_back
#define fi first
#define se second
#define vi vector
using namespace std;
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
const int N=1e5+10,size=1<<20,mod=998244353;

//char buf[size],*p1=buf,*p2=buf;
template<class o> void qr(o &x) {
	char c=gc; x=0; int f=1;
	while(!isdigit(c)){if(c=='-')f=-1; c=gc;}
	while(isdigit(c)) x=x*10+c-'0',c=gc;
	x*=f;
}
template<class o> void qw(o x) {
	if(x/10) qw(x/10);
	putchar(x%10+'0');
}
template<class o> void pr1(o x) {
	if(x<0)x=-x,putchar('-');
	qw(x); putchar(' ');
}
template<class o> void pr2(o x) {
	if(x<0)x=-x,putchar('-');
	qw(x); puts("");
}

int T,n,m,ans[N];
vi<pi> q[N];
struct edge{int y,next;}a[N*2]; int len,last[N];
void ins(int x,int y) {a[++len]=(edge){y,last[x]}; last[x]=len;}

//点分治 
int pos,tmp,sz[N],dep[N],c[N];
bool w[N],v[N]; 

void Find(int x,int S) {
	sz[x]=v[x]=1;
	int mx=0;
	for(int k=last[x],y;k;k=a[k].next) {
		y=a[k].y;
		if(!v[y]&&!w[y]) {
			Find(y,S);
			sz[x]+=sz[y];
			mx=max(mx,sz[y]);
		}
	}
	v[x]=0; mx=max(mx,S-sz[x]);
	if(mx<tmp) pos=x,tmp=mx;
}

void dfs(int x,int d) {//从重心二次扫描
	v[x]=1;c[dep[x]]+=d;
	for(int k=last[x],y;k;k=a[k].next) {
		y=a[k].y;
		if(!v[y]&&!w[y]) {
			dep[y]=dep[x]+1;
			dfs(y,d);
		}
	}
	v[x]=0;
}

void Dfs(int x,int S) {//查询
	v[x]=sz[x]=1;
	for(auto it:q[x]) {
		int id=it.fi,d=it.se;
		if(d>=dep[x]&&d-dep[x]<S) ans[id]+=c[d-dep[x]];
	}
	for(int k=last[x],y;k;k=a[k].next) {
		y=a[k].y;
		if(!v[y]&&!w[y]) {
			Dfs(y,S);
			sz[x]+=sz[y];
		}
	}
	v[x]=0;
}

void solve(int x,int S) {
	pos=x; tmp=S; Find(x,S); 
	x=pos; w[x]=v[x]=1;
	memset(c,0,sizeof(int[S])); 
	dep[x]=0; dfs(x,1);
	for(auto it:q[x]) if(it.se<S) ans[it.fi]+=c[it.se];
	for(int k=last[x],y;k;k=a[k].next) {
		y=a[k].y; 
		if(w[y]) continue;
		dfs(y,-1);
		Dfs(y,S);
		dfs(y,1);
	}
	for(int k=last[x],y;k;k=a[k].next)
		if(!w[a[k].y]) solve(a[k].y,sz[a[k].y]);
}

int main() {
	qr(T); while(T--) {
		qr(n); qr(m); len=0;
		for(int i=1;i<=n;i++) last[i]=w[i]=v[i]=0,q[i].clear();
		for(int i=1,x,y;i<n;i++) qr(x),qr(y),ins(x,y),ins(y,x);
		for(int i=1,x,y;i<=m;i++) {
			qr(x); qr(y); ans[i]=0;
			q[x].pb(mk(i,y));
		}
		solve(1,n); 
		for(int i=1;i<=m;i++) pr2(ans[i]);
	}
	return 0;
}



```



---

## 作者：_LiWenX_ (赞：4)

没有边分治题解，我来一发。

感觉是比较板子的边分治（第一次写这东西）。

首先要发现询问 `x k` 就是找有多少距离 $x$ 长度为 $k$ 的点。

边分治先重新建图，使每个节点的儿子最多只有两个，设虚边的权值为 $0$，其他为 $1$。

考虑一次分治对答案的贡献，这条边把子树分为了两个部分。

设这条边的权值为 $val$（因为是边分治，会建虚点和虚边，所以你要考虑边权的问题），连接了点 $u,v$，那么假如在第一的部分走过的权值为 $dis1$，第二部分为 $dis2$，那么这条路径的长度为 $dis1+dis2+val$。

于是我们对于一个第一部分的点 $x$，假如它上面有一次询问 $k$。则本次分治中的路径对答案的贡献为 $dis2_{k-dis1-val}$。其中 $dis2_x$ 为右侧中以 $v$ 开头长度为 $x$ 的链的个数，$dis1$ 为 $u$ 到 $x$ 的距离。

你发现 $dis2_x$ 和每个 $dis$ 都是可以一次 `dfs` 中预处理出来的。计算第二部分点上的答案做法同理，那么你把询问挂在点上，继续分治下去就做完了。

但直接按这种思路写下去会挂，因为你把最后走到了一个虚点上的路径也计入了答案，但是对于虚点，这是你自己建出的东西，它并不存在于原树，相当于计重了，所以在预处理 $dis2_x$ 的时候，若最后端点是虚点，你不要把它记上去就好了。

时间复杂度 $O(n\log n+m\log n)$，但常数略大qwq。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int tt;
vector<int> E[200001];
struct edge{
	int from,to,val,vis;
}e[200001<<1];int head[200001],S;
void addedge(int x,int y,int z){
	e[++S].to=y,e[S].val=z;
	e[S].from=head[x],head[x]=S;
}
int n,m;
void buildtree(int now,int fa){
	int las=0;
	for(int u:E[now]){
		if(u==fa) continue;
		if(!las) las=now;
		else{
			addedge(las,++n,0);
			addedge(n,las,0);
			las=n;
		}
		addedge(las,u,1);
		addedge(u,las,1);
		buildtree(u,now);
	}
}
struct node{
	int len,id;
};vector<node> q[200001];
int ans[200001],du[200001];
int X,Y,Val,pos,minnsize,size[200001],all;
void find(int now,int fa){
	size[now]=1;
	for(int i=head[now];i;i=e[i].from){
		int u=e[i].to;
		if(u==fa||e[i].vis) continue;
		find(u,now);
		size[now]+=size[u];
		if(max(size[u],all-size[u])<minnsize){
			minnsize=max(size[u],all-size[u]);
			X=now,Y=u;
			Val=e[i].val;pos=i;
		}
	}
}
int dis1[200001],dis2[200001];
int size1,size2;
void dfs(int now,int fa,int sum,bool op,bool can){
	if(can){
		if(op==1) dis1[sum]++,size1++;
		else dis2[sum]++,size2++;
	}
	for(int i=head[now];i;i=e[i].from){
		int u=e[i].to;
		if(u==fa||e[i].vis) continue;
		dfs(u,now,sum+e[i].val,op,e[i].val);
	}
}
void dfs2(int now,int fa,int sum,bool op){
	for(auto u:q[now]){
		if(u.len-sum-Val<0) continue;
		if(op==1){
			ans[u.id]+=dis2[u.len-sum-Val];
		}
		else{
			ans[u.id]+=dis1[u.len-sum-Val];
		}
	}
	for(int i=head[now];i;i=e[i].from){
		int u=e[i].to;
		if(u==fa||e[i].vis) continue;
		dfs2(u,now,sum+e[i].val,op);
	}
}
void solve(int root){
	find(root,root);
	e[pos].vis=e[pos^1].vis=1;
	if(size[root]==1) return ;
	size1=size2=0;
	dfs(X,Y,0,1,e[pos].val);
	dfs(Y,X,0,0,e[pos].val);
	dfs2(X,X,0,1);
	dfs2(Y,Y,0,0);
	for(int i=0;i<=max(size1,size2);i++) dis1[i]=dis2[i]=0;
	int S1=size1,S2=size2,X_=X,Y_=Y;
	minnsize=1e9;
	all=S1;
	solve(X_);
	minnsize=1e9;
	all=S2;
	solve(Y_);
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>tt;
	while(tt--){
		S=1;
		cin>>n>>m;
		for(int i=1;i<n;i++){
			int x,y;cin>>x>>y;
			du[x]++,du[y]++;
			E[x].push_back(y);
			E[y].push_back(x);
		}
		buildtree(1,1);
		for(int i=1;i<=m;i++){
			int x,k;cin>>x>>k;
			if(k==1) ans[i]=du[x];
			else if(k) q[x].push_back((node){k,i});
			else ans[i]=1;
		}
		minnsize=1e9,all=n;
		solve(1);
		for(int i=1;i<=m;i++){
			cout<<ans[i]<<'\n';
		}
		memset(e,0,sizeof(e));
		memset(head,0,sizeof(head));
		for(int i=1;i<=n;i++){
			E[i].clear(),q[i].clear();
			ans[i]=0;
			du[i]=0;
		}
	}
}
```

---

## 作者：7KByte (赞：3)

分块信仰。

一个比较``naive``的思路是查询时对点$X$进行``DFS``，深度为$K$的点的个数即为答案，显然时间复杂度是$O(N^2)$，可以拿到30分。

考虑优化，我们可以将询问离线，然后用二次扫描换根法进行处理。

![](https://cdn.luogu.com.cn/upload/image_hosting/ywhiwqav.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

我们将根从$X$换为$Y$，$Y$子树中所有节点深度减一，其余的点深度都加一，所以我们用桶来记录深度。发现线段树等数据结构无法直接维护桶，所以直接用分块即可，分块时对每个块记录一个$Add$标记即可。


一定注意不要访问数组的负数下标。考场上没注意结果和暴力老哥同分。

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define N 100500
#define M 355
using namespace std;
char buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline int read(){
    int x=0;char ch=getchar();
    while(!isdigit(ch))ch=getchar();
    while(isdigit(ch))x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x;
}
int h[N],tot;
struct edge{
	int to,nxt;
}e[N<<1];
void add(int x,int y){
	e[++tot].nxt=h[x];h[x]=tot;e[tot].to=y;
	}
int n,d[N],c[M][N],m,len,sz[N],ad[M],dfn[N],idx,cnt,u[N];
struct node{
	int k,op,nxt;
	}a[N];
int top=0,hh[N];
void insert(int x,int k,int op){
	a[++top].k=k;a[top].op=op;a[top].nxt=hh[x];hh[x]=top;
}
void dfs(int x,int fa){
	d[x]=d[fa]+1;sz[x]=1;dfn[x]=++idx;u[idx]=d[x];
	for(int i=h[x];i;i=e[i].nxt)if(e[i].to!=fa)
		dfs(e[i].to,x),sz[x]+=sz[e[i].to];
}
int pos(int x){return (x-1)/len+1;}
int L(int x){return (x-1)*len+1;}
int R(int x){return min(x*len,n);}
void change(int l,int r,int val){
	int ll=pos(l),rr=pos(r);
	if(ll==rr){
		rep(i,L(ll),R(ll))c[ll][u[i]]--,u[i]+=ad[ll];
		ad[ll]=0;
		rep(i,l,r)u[i]+=val;
		rep(i,L(ll),R(ll))c[ll][u[i]]++;
		return ;
	}
	rep(i,ll+1,rr-1)ad[i]+=val;
	rep(i,L(ll),R(ll))c[ll][u[i]]--,u[i]+=ad[ll];
	rep(i,L(rr),R(rr))c[rr][u[i]]--,u[i]+=ad[rr];
	ad[ll]=ad[rr]=0;
	rep(i,l,R(ll))u[i]+=val;
	rep(i,L(rr),r)u[i]+=val;
	rep(i,L(ll),R(ll))c[ll][u[i]]++;
	rep(i,L(rr),R(rr))c[rr][u[i]]++;
}
int ans[N];
void dfs1(int x,int fa){
	for(int i=hh[x];i;i=a[i].nxt){
		//cout<<x<<" "<<a[i].k<<" "<<a[i].op<<endl;
		rep(j,1,cnt)if(a[i].k+1-ad[j]>=0)ans[a[i].op]+=c[j][a[i].k+1-ad[j]];
	}
	for(int i=h[x];i;i=e[i].nxt)if(e[i].to!=fa){
		rep(j,1,cnt)ad[j]+=1;
		change(dfn[e[i].to],dfn[e[i].to]+sz[e[i].to]-1,-2);
		dfs1(e[i].to,x);
		rep(j,1,cnt)ad[j]-=1;
		change(dfn[e[i].to],dfn[e[i].to]+sz[e[i].to]-1,2);
	}
}
void work(){
	memset(h,0,sizeof(h));tot=0;
	memset(hh,0,sizeof(hh));top=0;idx=0;
	n=read();m=read();
	rep(i,1,n-1){
		int x,y;x=read();y=read();
		add(x,y);add(y,x);
	}
	dfs(1,0);
	rep(i,1,m){
		int x,k;x=read();k=read();
		insert(x,k,i);
	}
	len=sqrt(n);
	memset(ad,0,sizeof(ad));
	memset(ans,0,sizeof(ans));
	cnt=pos(n);
	rep(i,1,cnt){
		ad[i]=0;
		rep(j,L(i),R(i))c[i][u[j]]++;
	}
	dfs1(1,0);
	rep(i,1,m)printf("%d\n",ans[i]);
	rep(i,1,cnt)rep(j,L(i),R(i))c[i][u[j]]=0;
}
int main(){
	int T=read();
	while(T--)work();
	return 0;
}
```

---

## 作者：5k_sync_closer (赞：2)

一眼点分治。

设当前分治中心为 $u$，正在考虑子树 $V$ 的贡献。

则 $\forall v\in V$，此次分治对询问 $v,k$ 的贡献为 $\sum\limits_{i\notin V}[d_i=k-d_v]$。

用桶维护。具体地，先把 $u$ 子树内所有点的深度装进桶里，

考虑 $V$ 的贡献时把 $V$ 内所有点的深度拿出来，统计 $\forall v\in V$ 询问 $v,k$ 的贡献，再把 $V$ 内所有点的深度装回去。

询问 $u,k$ 的贡献单独计算，为 $\sum[d_i=k]$。

```cpp
#include <cstdio>
#include <vector>
using namespace std;
struct E
{
    int v, t;
} e[200050];
bool b[100050];
vector<pair<int, int>> q[100050];
int n, m, c, R, T, r[100050], d[100050], s[100050], p[100050], h[100050], C[100050], D[100050], G[100050];
void A(int u, int v)
{
    e[++c] = {v, h[u]};
    h[u] = c;
}
void X(int u, int k, int t)
{
    s[u] = 1;
    p[u] = 0;
    for (int i = h[u], v; i; i = e[i].t)
        if (!b[v = e[i].v] && v != k)
            X(v, u, t), s[u] += s[v], p[u] = max(p[u], s[v]);
    if (p[R] > (p[u] = max(p[u], t - s[u])))
        R = u;
}
void Y(int u, int k, bool t)
{
    t ? !C[d[u]]++ && (G[++G[0]] = d[u]) : D[++D[0]] = u;
    for (int i = h[u], v; i; i = e[i].t)
        if (!b[v = e[i].v] && v != k)
            d[v] = d[u] + 1, Y(v, u, t);
}
void Q(int u, int k)
{
    b[u] = 1;
    d[u] = 0;
    Y(u, k, 1);
    for (auto i : q[u])
        r[i.second] += C[i.first];
    for (int i = h[u], v; i; i = e[i].t)
        if (!b[v = e[i].v] && v != k)
        {
            d[v] = 1;
            Y(v, u, 0);
            for (int j = 1; j <= D[0]; ++j)
                --C[d[D[j]]];
            for (int j = 1; j <= D[0]; ++j)
                for (auto k : q[D[j]])
                    if (k.first >= d[D[j]])
                        r[k.second] += C[k.first - d[D[j]]];
            for (int j = 1; j <= D[0]; ++j)
                ++C[d[D[j]]];
            D[0] = 0;
        }
    for (int i = 1; i <= G[0]; ++i)
        C[G[i]] = 0;
    G[0] = 0;
    for (int i = h[u], v; i; i = e[i].t)
        if (!b[v = e[i].v] && v != k)
            p[R = 0] = 1e9, X(v, u, s[v]), X(R, 0, s[v]), Q(R, u);
}
int main()
{
    scanf("%d", &T);
    while (T--)
    {
        c = 0;
        scanf("%d%d", &n, &m);
        for (int i = 1; i <= n; ++i)
            b[i] = h[i] = 0, q[i].clear();
        for (int i = 1, u, v; i < n; ++i)
            scanf("%d%d", &u, &v), A(u, v), A(v, u);
        for (int i = 0, x, k; i < m; ++i)
            scanf("%d%d", &x, &k), q[x].push_back({k, i}), r[i] = 0;
        p[R = 0] = 1e9;
        X(1, 0, n);
        X(R, 0, n);
        Q(R, 0);
        for (int i = 0; i < m; ++i)
            printf("%d\n", r[i]);
    }
    return 0;
}
```


---

## 作者：_LPF_ (赞：2)

[消息传递](https://www.luogu.com.cn/problem/P6626)

简化一下题意：

> 多次询问一棵树上同节点 $x$ 距离为 $k$ 的点的个数。  

看到大部分人都是 $O(n\log n)$ 离线的静态点分治，

但是我这么蒟蒻就只能想到非常 native 的在线 $O(n\log^2 n)$ 点分树。~~（反正都能过对吧）~~

显然这道题比[模板题](https://www.luogu.com.cn/problem/P6329)还要模板题，甚至没有修改操作，但是还是简单介绍一下。

与静态点分治不同的是，点分树将每次得到的重心保存了下来，并且重新构造出一棵新树。（但一般不用重新建树）

然后根据重心的性质，**这棵点分树的深度为 $\log n$**。

那么利用这个优美的性质，很多看似奇奇怪怪的暴力都有了正确的复杂度。

我们来看这道题，首先不难建出点分树。（和点分治几乎一模一样）

对于统计答案，我们先约定几个信息： 

1. $sub(i)$ 表示点 $i$ 在虚树上的子树集合。
2. $fat(i)$ 表示点 $i$ 在虚树上的祖先集合。
3. $dis(i,j)$ 表示**原树上**点 $i,j$ 之间的距离。
4. $sum(p)$ 表示符合条件 $p$ 的点的个数。
5. $fa_i$ 表示虚树上节点 $i$ 的父亲节点。

那么，设：

$f_1(i,k)=sum(x\in sub(i),dis(x,i)=k)$ 即 虚树上 $i$ 的子树中 距离 $i$ 的距离为 $k$ 的节点个数。

$f_2(i,k)=sum(x\in sub(i),dis(x,fa_i)=k)$ 即 虚树上 $i$ 的子树中 距离 $fa_i$ 的距离为 $k$ 的节点个数。

那么根据简单容斥，对于查询 $(x,k)$ 来说，对于一对节点 $(i,fa_i)$，$sub(fa_i)-sub(i)$ 的贡献为：

$C(i,fa_i)=f_1(fa_i,k-dis(x,fa_i))-f_2(i,k-dis(x,fa_i))$

答案即为：（注意 $f_1(x,k)$ 单独算）

$ans(x,k)=f_1(x,k)+\sum_{i\in fat(x),fa_i\neq 0} C(i,fa_i)$

同时再注意一下细节（看注释），这道题就结束了。~~话说这不就是弱化版的板子题吗~~

奇丑无比的代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#define N 100010
using namespace std;

int n,m;
int head[N],cnt=0;
vector<int>C[N][2];
struct Edge{int nxt,to;}ed[N<<1];

int read(){
    int x=0,f=1;char c=getchar();
    while(c<'0' || c>'9') f=(c=='-')?-1:1,c=getchar();
    while(c>='0' && c<='9') x=x*10+c-48,c=getchar();
    return x*f;
}
void add(int u,int v){ed[++cnt]=(Edge){head[u],v};head[u]=cnt;}
//---------------------------------------
int dep[N],Fa[N],son[N],top[N],Sz[N];
void dfs1(int u,int f){
	Fa[u]=f;dep[u]=dep[f]+1;Sz[u]=1;
	for(int i=head[u];i;i=ed[i].nxt){
		int v=ed[i].to;if(v==f) continue;
		dfs1(v,u);Sz[u]+=Sz[v];
		if(Sz[v]>Sz[son[u]]) son[u]=v;
	}
}
void dfs2(int u,int Top){
	top[u]=Top;if(!son[u]) return;
	dfs2(son[u],Top);
	for(int i=head[u];i;i=ed[i].nxt){
        int v=ed[i].to;
        if(v==son[u] || v==Fa[u]) continue;dfs2(v,v);
    }
}
int Lca(int x,int y){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		x=Fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	return x;
}
int Dis(int x,int y){return dep[x]+dep[y]-2*dep[Lca(x,y)];}
void build(){dfs1(1,0);dfs2(1,1);}
//----------------------------------------以上为树剖求dis(x,y)的板子
int sz[N],mxp[N],fa[N],rt;
bool vis[N];
void get_sz(int u,int fa){
	sz[u]=1;for(int i=head[u],v;i;i=ed[i].nxt) 
	if(!vis[v=ed[i].to] && v!=fa) get_sz(v,u),sz[u]+=sz[v];
}
void get_root(int u,int fa,int Top){
	mxp[u]=sz[Top]-sz[u];
	for(int i=head[u],v;i;i=ed[i].nxt) if(!vis[v=ed[i].to] && v!=fa) 
		get_root(v,u,Top),mxp[u]=max(mxp[u],sz[v]);
	if(!rt || mxp[u]<mxp[rt]) rt=u;
}
void dfs(int u,int last){
	get_sz(u,0);rt=0;get_root(u,0,u);//预先找到根。
	u=rt;fa[u]=last;vis[u]=true;
	get_sz(u,0);//为了标记vector大小，再以 rt 为根找一遍 sz。
	C[u][0].resize(sz[u]+2);//根据重心性质，应该可以换为 sz[u]/2+2
	C[u][1].resize(sz[u]+2);//+2 是为了防止出错，上同。
	for(int i=head[u],v;i;i=ed[i].nxt) if(!vis[v=ed[i].to]) dfs(v,u);
}

void push_up(int u){
    C[u][0][0]++;
    for(int i=u;fa[i];i=fa[i]){
        int tmp=Dis(fa[i],u);
        C[i][1][tmp]++;
        C[fa[i]][0][tmp]++;
    }
}

int query(int u,int k){
    int ans=0;
    if(sz[u]>=k) ans=C[u][0][k];//注意边界情况，防止 RE。
    for(int i=u;fa[i];i=fa[i]){
        int tmp=Dis(fa[i],u);if(tmp>k || (k-tmp)>sz[fa[i]]) continue;
        ans+=C[fa[i]][0][k-tmp];
        if(sz[i]>=k-tmp) ans-=C[i][1][k-tmp];
    }
    return ans;
}

void work(){
    n=read(),m=read();
    for(int i=1;i<n;i++){int u=read(),v=read();add(u,v),add(v,u);}
    build();dfs(1,0);for(int i=1;i<=n;i++) push_up(i);//先预处理记录一下。
    while(m--){
        int u=read(),k=read();
        printf("%d\n",query(u,k));
    }
}
void init(){//多组数据记得清空，貌似可以少些几个 memset，不过还是懒得动脑全写了。
    cnt=0;memset(head,0,sizeof(head));
    for(int i=1;i<=100000;i++) C[i][0].clear(),C[i][1].clear();
    memset(dep,0,sizeof(dep));memset(Fa,0,sizeof(Fa));
    memset(son,0,sizeof(son));memset(top,0,sizeof(top));
    memset(Sz,0,sizeof(Sz));memset(sz,0,sizeof(sz));
    memset(vis,false,sizeof(vis));memset(mxp,0,sizeof(mxp));
    memset(fa,0,sizeof(fa));rt=0;
}
int main(){
    int T=read();
    while(T--) init(),work();
}
```

引用资料[树论—点分树（动态点分治）](https://www.cnblogs.com/Xing-Ling/p/12976848.html)。

完结撒花。

---

## 作者：小木虫 (赞：1)

### Preface  
这题没要求在线又有多测，所以千万不要在线搞点分树，会因为常数而 TLE 的！（我因为这个刷了两页提交）  
### Problem  
给定一棵有 $n$ 个点的树，有 $m$ 次询问，每次询问输入两个参数：$x,k$。  
对于每次询问输出与 $x$ 的距离为 $k$ 的点的个数。  
### Solution  
很显然，这种要求 $O(n \log n)$ 级别复杂度的树上路径统计问题就是点分治，由于不要求在线，考虑把询问挂在点上。  
在每层循环的时候维护一个桶 $bucket$，里面存放离目前中心每个距离的点数。  
那么在对这层递归遍历树的时候，显然如果一个点离当前重心距离为 $w$，挂在上面的询问为 $k$，那么它这层的答案就是 $bucket_{k-w}$。需要注意的一点是与这个点对于重心来说处于同一子树的节点不可以被统计，因为它的路径不满足从当前点到重心再到那个点，路径有重复，这部分答案我们交给下一层递归。这个我们用一个 remove 函数就可以实现，具体是清空一个子树的 $bucket$ 值，之后在加回去。  
其它部分就跟普通点分治一样了，通过维护已经作为重心过的点不断将树分成若干段，保证层数是 $\log n$ 的。  
code：  
```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
const int N=2e5+10;
const int B=1e5;
struct node{int id,dis;};
struct query{int y,id;};
vector <query> Q[N];
int edge[N];int ans[N];
int head[N];int edgecnt;
int Next[N];
int max(int x,int y){
	if(x>y)return x;
	else return y;
}
void add(int u,int v){
	Next[++edgecnt]=head[u];
	edge[edgecnt]=v;
	head[u]=edgecnt;
}
vector <node> son[N];
bool cmp(node a,node b){return a.id<b.id;}
int n,m,u,v,w;int root;int bucket[B];
int s[N];int x,y;
bool vis[N];int nowmin=-1;int value[N];
int rt;int now;
int Root[N];
void init(int u,int fa){
	s[u]=1;
	for(int i=head[u];i;i=Next[i]){
		int v=edge[i];
		if(v==fa||vis[v])continue;
		init(v,u);s[u]+=s[v];
	}
}
void find(int u,int fa){
	if(fa==0)nowmin=1e9,rt=u;
	int MAX=-1;
	for(int i=head[u];i;i=Next[i]){
		int v=edge[i];
		if(v==fa||vis[v])continue;
		find(v,u);MAX=max(MAX,s[v]);
	}
	MAX=max(MAX,s[rt]-s[u]);
	if(nowmin>MAX){
		nowmin=MAX;
		root=u;
	}
}
int deep[N];
void getdeep(int u,int fa){
	bucket[now]++;deep[u]=now;
	for(int i=head[u];i;i=Next[i]){
		int v=edge[i];
		if(v==fa||vis[v])continue;
		now+=1;getdeep(v,u);now-=1;
	}
}
void calc(int u,int fa){
	for(int i=0;i<Q[u].size();i++){
		int y=Q[u][i].y;int id=Q[u][i].id;
		y-=deep[u];if(y<0)continue;
		ans[id]+=bucket[y];
	}
	for(int i=head[u];i;i=Next[i]){
		int v=edge[i];
		if(v==fa||vis[v])continue;
		calc(v,u);
	}
}
void remove(int u,int fa,int p){
	bucket[deep[u]]+=p;
	for(int i=head[u];i;i=Next[i]){
		int v=edge[i];
		if(v==fa||vis[v])continue;
		remove(v,u,p);
	}
}
void solve(int u){
	vis[u]=true;
	now=0;getdeep(u,0);
	for(int i=0;i<Q[u].size();i++){
		int y=Q[u][i].y;int id=Q[u][i].id;
		y-=deep[u];if(y<0)continue;
		ans[id]+=bucket[y];
	}
	for(int i=head[u];i;i=Next[i]){
		int v=edge[i];
		if(vis[v])continue;
		remove(v,0,-1);calc(v,0);remove(v,0,1);
	}
	remove(u,0,-1);
	for(int i=head[u];i;i=Next[i]){
		int v=edge[i];
		if(vis[v])continue;
		init(v,0);
		find(v,0);
		solve(root);
	}
}
int T; 
int main(){
	T=read();
	while(T--){
		n=read();m=read();
		for(int i=1;i<=n;i++)Q[i].clear();
		rt=0;now=0;nowmin=-1;root=0;edgecnt=0;
		memset(Next,0,sizeof(Next));
		memset(edge,0,sizeof(edge));
		memset(head,0,sizeof(head));
		memset(vis,false,sizeof(vis));
		memset(ans,0,sizeof(ans));
		memset(bucket,0,sizeof(bucket));
		for(int i=1;i<n;i++){
			u=read();v=read();
			add(u,v);add(v,u);
		}
		for(int i=1;i<=m;i++){
			x=read();y=read();
			Q[x].push_back((query){y,i});
		}
		init(1,0);
		find(1,0);
		solve(root);
		for(int i=1;i<=m;i++){
			printf("%d\n",ans[i]);
		}
	}
	return 0;
}
```


---

## 作者：LinkyChristian (赞：1)

模板题。

询问形如对一个点求距离它为 $k$ 的点有多少个，典型的与树形态无关的问题，考虑点分治。

将询问挂到点上，每次对于分支中心 dfs，记录下距离分治中心为 $dis$ 的点的总数，再记录下距离分治中心为 $dis$，且在分治中心的儿子 $i$ 子树里的点的总数。答案为与询问点在不同子树中，且距离分治中心为询问距离减去询问点到分治中心距离的点。设询问点到分治中心的距离为 $d$ ，考虑容斥，总答案为距离询问中心距离为 $d$ 的点的总数减去与询问点在同一子树内且距离分治中心为 $d$ 的点的总数，用 map 统计即可。

```cpp
#include<bits/stdc++.h>
#define N 100010
#define pb push_back
#define mp make_pair
#define fi first
#define se second
using namespace std;
int T,n,m;
typedef pair<int,int> pii;
int read() {
	int res=0,f=1;char ch=getchar();
	while(!isdigit(ch)) f=ch=='-'?-1:1,ch=getchar();
	while(isdigit(ch)) res=res*10+ch-'0',ch=getchar();
	return f*res;
}
int cnt,head[N],to[N<<1],nxt[N<<1];
vector<pii> qu[N]; 
int vis[N],siz[N],son[N],rt,S,ans[N];
void insert(int u,int v){
	cnt++;
	to[cnt]=v;
	nxt[cnt]=head[u];
	head[u]=cnt;
} 
void gtrt(int now,int fa) {
//	cout<<now<<endl;
	siz[now]=1,son[now]=0;
	for(int i=head[now]; i; i=nxt[i]) 
	    if(!vis[to[i]]&&to[i]!=fa) {
	    	gtrt(to[i],now);
	    	siz[now]+=siz[to[i]];
	    	son[now]=max(son[now],siz[to[i]]);
		}
	son[now]=max(son[now],S-siz[now]);
	if(son[now]<son[rt]) rt=now;
}
struct node{
	int dis,id,fr;
	bool operator <(const node o) const{return dis==o.dis?fr<o.fr:dis<o.dis;}
}sk[N],q[N];
int tp,qn,bac[N];
map<pii,int> cot;
void dfs(int now,int fa,int dis,int fr) {
	cot[mp(fr,dis)]++,bac[dis]++;
	for(int i=0,sz=qu[now].size(); i<sz; i++) q[++qn]=node{qu[now][i].fi-dis,qu[now][i].se,fr};
	for(int i=head[now]; i; i=nxt[i])
	    if(!vis[to[i]]&&to[i]!=fa) dfs(to[i],now,dis+1,(fr==0)?to[i]:fr);
}
void clean(int now,int fa,int dis) {
	bac[dis]--;
	for(int i=head[now]; i; i=nxt[i])
	    if(!vis[to[i]]&&to[i]!=fa) clean(to[i],now,dis+1);
}
void solve(int now) {
	vis[now]=1;
	tp=qn=0,cot.clear(),dfs(now,0,0,0);
	for(int i=1; i<=qn; i++) if(q[i].dis>=0) 
		ans[q[i].id]+=bac[q[i].dis]-cot[mp(q[i].fr,q[i].dis)];
  	clean(now,0,0);
	int tmp=S;
	for(int i=head[now]; i; i=nxt[i]) if(!vis[to[i]]) {
		S=siz[to[i]]<siz[now]?siz[to[i]]:tmp-siz[now];
		rt=0,gtrt(to[i],now),solve(rt);
	} 
}
int main()
{
	T=read();
	while(T--) {
		cnt=0;
		for(int i=1; i<=n; i++) qu[i].clear();
		memset(vis,0,sizeof(vis));
		memset(ans,0,sizeof(ans));
		memset(head,0,sizeof(head));
		n=read(),m=read();
		for(int i=1; i<n; i++) {
			int u=read(),v=read();
			insert(u,v);
			insert(v,u);
		}
		for(int i=1; i<=m; i++) {
			int x=read(),k=read();
			if(!k) ans[i]=1;
			else qu[x].pb(mp(k,i));
		}
		son[0]=S=n,rt=0,gtrt(1,0),solve(rt);
		for(int i=1; i<=m; i++) cout<<ans[i]<<endl;
	}
 } 
```


---

## 作者：Vanilla_chan (赞：1)

## Problem

[原题传送门](https://www.luogu.com.cn/problem/P6626)

给一棵有$n$个节点的树。有$m$个询问，每次给出一对$x,k$表示查询到点$x$的距离为$k$的点有多少个。

$T$组数据。

$1\sim3:1\le n,m\le10^3\\$

$4\sim6:1\le n,m\le 10^5,k\le 20\\$

$7\sim10:1\le n,m\le 10^5\\$

$\forall:1\le T\le5,1\le x\le n,0\le k\le n$.

## Solution

暴力不必多说，写个$dfs/bfs$就有$30pts$，时间复杂度是$O(n^2)$。

### 优化

对点分治还不熟练，所以先来学个另类做法。

将询问离线，然后用换根法进行处理。

将根从$x$换为$y$时，$y$的子树中所有节点深度减一，其他点的深度都加一。用桶来记录深度。

先用树链剖分将树变为序列方便区间操作。

每一次换根，我们都需要做两次区间修改，同时还要维护一个桶。所以不能用线段树，但是可以用分块。对每个块开一个桶即可。

当换根到有询问的点时，暴力拿出对应块的桶进行计数即可。

时间复杂度$O(Tn\sqrt n)$，空间复杂度$O(n\sqrt n)$。

理论可以通过，实际需要开$O2$.

## Code

```c++
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<map>
#include<set>
#include<queue>
#include<vector>
#include<limits.h>
#define IL inline
#define re register
#define LL long long
#define ULL unsigned long long
#define debug printf("Now is %d\n",__LINE__);
using namespace std;

template<class T>inline void read(T& x)
{
	char ch=getchar();
	int fu;
	while(!isdigit(ch)&&ch!='-') ch=getchar();
	if(ch=='-') fu=-1,ch=getchar();
	x=ch-'0'; ch=getchar();
	while(isdigit(ch)) { x=x*10+ch-'0'; ch=getchar(); }
	x*=fu;
}
inline int read()
{
	int x=0,fu=1;
	char ch=getchar();
	while(!isdigit(ch)&&ch!='-') ch=getchar();
	if(ch=='-') fu=-1,ch=getchar();
	x=ch-'0'; ch=getchar();
	while(isdigit(ch)) { x=x*10+ch-'0'; ch=getchar(); }
	return x*fu;
}
int G[55];
template<class T>inline void write(T x)
{
	int g=0;
	if(x<0) x=-x,putchar('-');
	do { G[++g]=x%10; x/=10; } while(x);
	for(int i=g; i>=1; --i)putchar('0'+G[i]); putchar('\n');
}
int T;
#define N 100010
#define M 400
//graph
int head[N],ver[N<<1],nxt[N<<1],cnt;
IL void insert(int x,int y)
{
	nxt[++cnt]=head[x];
	head[x]=cnt;
	ver[cnt]=y;

	nxt[++cnt]=head[y];
	head[y]=cnt;
	ver[cnt]=x;
}
//ask
struct node
{
	int k,op,nxt;
}a[N];
int top;
int hh[N];
IL void insert(int x,int k,int op)
{
	a[++top].k=k;
	a[top].op=op;
	a[top].nxt=hh[x];
	hh[x]=top;
}
//pre
int dis[N],sze[N],dfn[N],dfncnt,m,n;
int b[N];
void dfs(int x,int f)
{
	dis[x]=dis[f]+1;
	sze[x]=1;
	dfn[x]=++dfncnt;
	b[dfncnt]=dis[x];
	for(int i=head[x];i;i=nxt[i])
	{
		if(ver[i]==f) continue;
		dfs(ver[i],x);
		sze[x]+=sze[ver[i]];
	}
}
//block
int len,s;
int L[M],R[M],belong[N];
int lazy[M],c[M][N];
void change(int x,int y,int v)
{
	re int xx=belong[x],yy=belong[y],i,j;
	if(xx==yy)
	{
		for(i=L[xx];i<=R[xx];i++)
		{
			c[xx][b[i]]--;
			b[i]+=lazy[xx];
		}
		lazy[xx]=0;
		for(i=x;i<=y;i++)
		{
			b[i]+=v;
		}
		for(i=L[xx];i<=R[xx];i++)
		{
			c[xx][b[i]]++;
		}
	}
	else
	{
		for(i=xx+1;i<=yy-1;i++)
		{
			lazy[i]+=v;
		}
		for(i=L[xx];i<=R[xx];i++)
		{
			c[xx][b[i]]--;
			b[i]+=lazy[xx];
		}
		for(i=L[yy];i<=R[yy];i++)
		{
			c[yy][b[i]]--;
			b[i]+=lazy[yy];
		}
		lazy[xx]=lazy[yy]=0;
		for(i=x;i<=R[xx];i++)
		{
			b[i]+=v;
		}
		for(i=L[yy];i<=y;i++)
		{
			b[i]+=v;
		}
		for(i=L[xx];i<=R[xx];i++)
		{
			c[xx][b[i]]++;
		}
		for(i=L[yy];i<=R[yy];i++)
		{
			c[yy][b[i]]++;
		}
	}
}
int ans[N];
void dfs1(int x,int f)
{
	re int i,j;
	for(i=hh[x];i;i=a[i].nxt)
	{
		for(j=1;j<=s;j++)
		{
			if(a[i].k+1-lazy[j]>=0) ans[a[i].op]+=c[j][a[i].k+1-lazy[j]];
		}
	}
	for(i=head[x];i;i=nxt[i])
	{
		if(ver[i]==f) continue;
		for(j=1;j<=s;j++) lazy[j]++;
		change(dfn[ver[i]],dfn[ver[i]]+sze[ver[i]]-1,-2);
		dfs1(ver[i],x);
		for(j=1;j<=s;j++) lazy[j]--;
		change(dfn[ver[i]],dfn[ver[i]]+sze[ver[i]]-1,2);
	}
}
int main()
{
	T=read();
	int i,j,x,k;
	while(T--)
	{
		//init
		memset(head,0,sizeof(head));cnt=0;
		memset(hh,0,sizeof(hh));top=0;
		dfncnt=0;
		memset(lazy,0,sizeof(lazy));
		memset(ans,0,sizeof(ans));
		//work
		n=read();
		m=read();
		for(i=1;i<n;i++) insert(read(),read());
		dfs(1,0);
		for(i=1;i<=m;i++)
		{
			x=read();
			k=read();
			insert(x,k,i);
		}
		len=sqrt(n);
		s=n/len;
		for(i=1;i<=s;i++)
		{
			L[i]=n/s*(i-1)+1;
			R[i]=n/s*i;
		}
		R[s]=n;
		for(i=1;i<=s;i++)
		{
			for(int j=L[i];j<=R[i];j++)
			{
				belong[j]=i;
			}
		}
		for(i=1;i<=s;i++)
		{
			lazy[i]=0;
			for(int j=L[i];j<=R[i];j++)
			{
				c[i][b[j]]++;
			}
		}
		dfs1(1,0);
		for(i=1;i<=m;i++) cout<<ans[i]<<endl;
		for(i=1;i<=s;i++)
		{
			lazy[i]=0;
			for(j=L[i];j<=R[i];j++)
			{
				c[i][b[j]]=0;
			}
		}
	}

	return 0;
}
```

***若有格式编排错误，恳请管理员斧正。***

---

## 作者：Genius_Star (赞：0)

### 思路：

考虑根据原树建立出**点分树**。

对于每个点 $u$，维护一个 $rt_{u,0/1,d}$ 表示在原树上以 $u$ 为根的子树内达到 $u$ 或 $fa_u$ 距离为 $d$ 的点的个数。

注意到，查询是单点查询，那么可以不用线段树（用了也可能会爆空间或超时）；对于每个点的 $rt_{u,0/1}$，开一个 `vector`，大小为 $siz_u+1$。

根据点分树的性质，总空间为 $O(N \log N)$。

建树时可以预处理出一个点到其 $k$ 级点分树祖先在原树上的距离，需要树剖求最近公共祖先，时间复杂度为 $O(N \log^2 N)$。

查询的话可以暴力跳点分树，容斥计算贡献，时间复杂度为 $O(Q \log N)$。

总时间复杂度为 $O(N \log^2 N + Q \log N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define Full(a) memset(a,0,sizeof(a))
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
using namespace std;
typedef double db;
typedef long long ll;
mt19937 R(time(0));
const ll N=100100,M=17; 
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
int t,n,m,x,y;
vector<int> E[N];
inline void add(int u,int v){
	E[u].push_back(v);
	E[v].push_back(u);
}
namespace LCA{
	int siz[N],z[N],t[N],fa[N],d[N];
	inline void dfs1(int u,int f){
		siz[u]=1;
		for(auto v:E[u]){
			if(v==f)
			  continue;
			fa[v]=u;
			d[v]=d[u]+1;
			dfs1(v,u);
			siz[u]+=siz[v];
			if(siz[v]>siz[z[u]])
			  z[u]=v;
		}
	}
	inline void dfs2(int u,int k){
		t[u]=k;
		if(!z[u])
		  return ;
		dfs2(z[u],k);
		for(auto v:E[u]){
			if(v==fa[u]||v==z[u])
			  continue;
			dfs2(v,v);
		}
	}
	inline int Lca(int u,int v){
		while(t[u]!=t[v]){
			if(d[t[u]]<d[t[v]])
			  swap(u,v);
			u=fa[t[u]];
		}
		return d[u]<d[v]?u:v;
	}
	inline int dis(int u,int v){
		return d[u]+d[v]-2ll*d[Lca(u,v)];
	}
	inline void tidy(int n){
		for(int i=1;i<=n;i++)
		  siz[i]=z[i]=t[i]=d[i]=fa[i]=0;
	}
	inline void init(int n=0){
		tidy(n);
		dfs1(1,1);
		dfs2(1,1);
	}
};
namespace Tree{
	int Max,sum,root;
	int fa[N],siz[N],dep[N];
	int dis[N][M];
	bool del[N];
	vector<int> rt[N][2];
	inline void getroot(int u,int fa){
		int s=0;
		siz[u]=1;
		for(auto v:E[u]){
			if(v==fa||del[v])
			  continue;
			getroot(v,u);
			siz[u]+=siz[v];
			s=max(s,siz[v]);
		}
		s=max(s,sum-siz[u]);
		if(s<Max){
			Max=s;
			root=u;
		}
	}
	inline void Get(int u,int siz){
		root=0;
		sum=Max=siz;
		getroot(u,0);
		getroot(root,0);
	}
	inline void build(int u,int fa,int from,int d,bool f){
		rt[from][f][d]++;
		for(auto v:E[u]){
			if(v==fa||del[v])
			  continue;
			build(v,u,from,d+1,f);
		}
	}
	inline void solve(int u){
		rt[u][0].resize(siz[u]+2);
		del[u]=1;
		build(u,0,u,0,0);
		for(auto v:E[u]){
			if(del[v])
			  continue;
			Get(v,siz[v]);
			rt[root][1].resize(siz[root]+2);
			build(v,0,root,1,1);
			fa[root]=u;
			dep[root]=dep[u]+1;
			solve(root);
		}
	}
	inline void tidy(int n){
		Max=log(n)/log2(2);
		for(int i=1;i<=n;i++){
			rt[i][0].clear();
			rt[i][1].clear();
			fa[i]=siz[i]=dep[i]=del[i]=0;
			for(int j=0;j<M;j++)
			  dis[i][j]=0;
		}
		Max=sum=root=0;
	}
	inline void init(int n=0){
		LCA::init(n);
		tidy(n);
		Get(1,n);
		solve(root);
		for(int i=1;i<=n;i++)
		  for(int j=i;j;j=fa[j])
		    dis[i][dep[i]-dep[j]]=LCA::dis(i,j);
	}
	inline int query(int x,int k){
		int ans=0;
		if(rt[x][0].size()>k)
		  ans=rt[x][0][k];
		for(int i=x;fa[i];i=fa[i]){
			int d=dis[x][dep[x]-dep[fa[i]]];
			if(k<d)
			  continue;
			if(rt[fa[i]][0].size()>k-d)
			  ans+=rt[fa[i]][0][k-d];
			if(rt[i][1].size()>k-d)
			  ans-=rt[i][1][k-d];
		}
		return ans;
	}
};
void solve(){
	n=read(),m=read();
	for(int i=1;i<=n;i++)
	  E[i].clear();
	for(int u,v,i=1;i<n;i++){
		u=read(),v=read();
		add(u,v);
	}
	Tree::init(n);
	while(m--){
		x=read(),y=read();
		write(Tree::query(x,y));
		putchar('\n');
	}
}
int main(){
	t=read();
	while(t--)
	  solve();
	return 0;
}
```

---

## 作者：Na2PtCl6 (赞：0)

我们发现，在用 dfs 遍历整棵树的过程中，当前点到所有点的距离 $d_i$ 变化的情况无非就是下面两种：

- 属于当前点子树的点，$d_i\leftarrow d_i-1$

- 不属于当前点子树的点，$d_i\leftarrow d_i+1$

于是问题就转化为了区间加，区间数 $k$ 的个数点分块裸题裸。

然后只是简单规避了一下会产生大常数点写法，把块长调小了一点就过了。

```cpp
#include<bits/stdc++.h>
#define blk(x) (x-1)/T+1
using namespace std;
const int maxn=100004,T=220;
int n,m,u,v,x,k,t,cnt,res[maxn],d[maxn],sz[maxn],dfn[maxn];
int tag[maxn],blkl[maxn],blkr[maxn],blkcnt[maxn][550];
vector< int > g[maxn];
struct item{ int id,val;};
vector< item > q[maxn];

inline void read(int &x){
	char c=getchar();x=0;
	for(;c<'0'||c>'9';c=getchar());
	for(;c>='0'&&c<='9';c=getchar()) x=x*10+(c^48);
}

void write(int x){
	if(x>9)
		write(x/10);
	putchar(x%10+48);
}

void build(){
	for(int i=1;i<=n;i++){
		int b=blk(i);
		blkcnt[d[i]][b]++;
		if((i-1)%T==0)
			blkl[b]=i;
		blkr[b]=i;
	}
}

void add(int l,int r,int v){
	int bl=blk(l),br=blk(r),lside=blkl[br],rside=blkr[bl];
	if(bl==br){
		for(int i=l;i<=r;i++)
			blkcnt[d[i]][bl]--;
		for(int i=l;i<=r;i++){
			d[i]+=v;
			blkcnt[d[i]][bl]++;
		}
		return ;
	}
	for(int i=l;i<=rside;i++)
		blkcnt[d[i]][bl]--;
	for(int i=l;i<=rside;i++){
		d[i]+=v;
		blkcnt[d[i]][bl]++;
	}
	for(int i=lside;i<=r;i++)
		blkcnt[d[i]][br]--;
	for(int i=lside;i<=r;i++){
		d[i]+=v;
		blkcnt[d[i]][br]++;
	}
	for(int i=bl+1;i<br;i++)
		tag[i]+=v;
}

int query(int l,int r,int k){
	int br=blk(r),lside=blkl[br],ret=0;
	for(int i=1;i<br;i++)
		if(k-tag[i]>=0)
			ret+=blkcnt[k-tag[i]][i];
	for(int i=lside;i<=r;i++)
		ret+=(d[i]==k?1:0); 
	return ret;
}

void dfs1(int ver,int fa,int dep){
	sz[ver]=1;
	dfn[ver]=++cnt;
	d[cnt]=dep;
	for(int i:g[ver]){
		if(i==fa)
			continue;
		dfs1(i,ver,dep+1);
		sz[ver]+=sz[i];
	}
}

void dfs2(int ver,int fa){
	for(item i:q[ver])
		res[i.id]=query(1,n,i.val);
//	debug();
	for(int i:g[ver]){
		if(i==fa)
			continue;
		add(dfn[i],dfn[i]+sz[i]-1,-1);
		add(1,dfn[i]-1,1);
		add(dfn[i]+sz[i],n,1);
		dfs2(i,ver);
		add(dfn[i],dfn[i]+sz[i]-1,1);
		add(1,dfn[i]-1,-1);
		add(dfn[i]+sz[i],n,-1);
	}
}

void clear(){
	cnt=0;
	memset(res,0,sizeof(res));
	memset(sz,0,sizeof(sz));
	memset(tag,0,sizeof(tag));
	memset(dfn,0,sizeof(dfn));
	for(int i=1;i<=n;i++){
		g[i].clear();
		q[i].clear();
	}
	for(int i=1;i<=n;i++){
		int b=blk(i);
		blkcnt[d[i]+tag[b]][b]=0;
	}
}



int main(){
//	freopen("dat.txt","r",stdin);
//	freopen("my_answer.txt","w",stdout);
	read(t);
	while(t--){
		read(n),read(m);
		for(int i=1;i<n;i++){
			read(u),read(v);
			g[u].push_back(v);
			g[v].push_back(u);
		}
		for(int i=1;i<=m;i++){
			read(x),read(k);
			q[x].push_back((item){i,k});
		}
		dfs1(1,0,0);
		build();
		dfs2(1,0);
		for(int i=1;i<=m;i++){
			write(res[i]);
			puts("");
		}
		clear();
	}
	return 0;
}
```
后话：本来这篇题解的标题行有一个一级标题写的“大家好，我非常喜欢...”的，然后因为这个没过审，致敬经典失败。

---

## 作者：lfxxx (赞：0)

有一个很暴力的解法，就是以询问点为根 DFS。

考虑优化，我们考虑优化换根。

当根节点从父亲移动到它的某个孩子时，孩子的子树内所有点深度减 $1$ 其余点深度加 $1$。

同理，当根节点从某个节点移动到它的父亲时，它的子树内所有点深度加 $1$ 其余点深度减 $1$。

那么考虑把询问挂在点上，然后处理出以 $1$ 为根的深度，然后从 $1$ 开始 DFS 并按照上面的方法修改所有节点的深度。

不难发现我们需要一个数据结构支持区间加和区间查询某一个数出现次数。

考虑分块，块内维护一个桶和加法标记即可维护所有信息与修改查询，将分块离线逐块处理即可做到 $O(n)$ 空间，$O(Tn \sqrt n)$ 时间。

由于常数很逆天，所以目前只在 LOJ 上通过，这里放一个评测链接。

[评测链接及代码](https://loj.ac/s/1854477)

---

## 作者：GIFBMP (赞：0)

看见这种和树上距离有关的询问，想到使用点分治。

先把询问离线下来，挂在节点上。对于一个分治中心 $x$，我们求出它子树中所有节点的深度，用桶记录。我们发现，两棵不同子树间的距离对这两棵子树内部的询问都有贡献，于是可以把一个询问 $(y,k)$ 转化成 $(x,k-dep_y)$。但是还有折回去的情况，在子树中统计，容斥掉即可。

多测记得清空，时间复杂度 $\Theta(n\log n)$。

Code:

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std ;
const int MAXN = 1e5 + 10 , INF = 0x3f3f3f3f ;
typedef pair <int , int> P ;
#define mp make_pair
#define fi first
#define se second
vector <P> p[MAXN] , tmp ;
int T , n , m , fir[MAXN] , tot , rt , cnt ;
int vis[MAXN] , sz[MAXN] , ans[MAXN] , mx[MAXN] , t[MAXN] , dep[MAXN] , mxd ;
struct edge {int to , nxt ;} e[MAXN << 1] ;
void add (int u , int v) {e[++tot].to = v ; e[tot].nxt = fir[u] ; fir[u] = tot ;}
void findrt (int x , int fa) {
	sz[x] = 1 , mx[x] = 0 ;
	for (int i = fir[x] ; i ; i = e[i].nxt) {
		int v = e[i].to ;
		if (v == fa || vis[v]) continue ;
		findrt (v , x) , sz[x] += sz[v] , mx[x] = max (mx[x] , sz[v]) ;
	}
	mx[x] = max (mx[x] , cnt - sz[x]) ;
	if (mx[x] < mx[rt]) rt = x ;
}
void gdis (int x , int fa) {
	mxd = max (mxd , dep[x]) , t[dep[x]]++ ;
	for (auto k : p[x])
		if (k.fi >= dep[x]) tmp.push_back (mp (k.fi - dep[x] , k.se)) ;
	for (int i = fir[x] ; i ; i = e[i].nxt) {
		int v = e[i].to ;
		if (v == fa || vis[v]) continue ;
		dep[v] = dep[x] + 1 , gdis (v , x) ; 
	} 
}
void calc (int x) {
	tmp.clear () , mxd = 0 ; dep[x] = 0 , gdis (x , 0) ;
	for (auto k : tmp) ans[k.se] += t[k.fi] ;
	for (int i = 0 ; i <= mxd ; i++) t[i] = 0 ;
	for (int i = fir[x] ; i ; i = e[i].nxt) {
		int v = e[i].to ;
		if (vis[v]) continue ;
		dep[v] = 1 , tmp.clear () , mxd = 0 , gdis (v , x) ;
		for (auto k : tmp) ans[k.se] -= t[k.fi] ;
		for (int i = 0 ; i <= mxd ; i++) t[i] = 0 ;
	}
}
void solve (int x) {
	calc (x) ; vis[x] = 1 ;
	for (int i = fir[x] ; i ; i = e[i].nxt) {
		int v = e[i].to ;
		if (vis[v]) continue ;
		cnt = sz[v] , rt = 0 , findrt (v , x) ; solve (rt) ;
	}
}
int main () {
	scanf ("%d" , &T) ;
	while (T--) {
		scanf ("%d%d" , &n , &m) ; tot = 0 ;
		for (int i = 1 ; i <= n ; i++) fir[i] = vis[i] = 0 , p[i].clear () ;
		for (int i = 1 ; i <= m ; i++) ans[i] = 0 ;
		for (int i = 1 , u , v ; i < n ; i++)
			scanf ("%d%d" , &u , &v) , add (u , v) , add (v , u) ;
		for (int i = 1 , x , k ; i <= m ; i++)
			scanf ("%d%d" , &x , &k) , p[x].push_back (mp (k , i)) ;
		cnt = n , rt = 0 , mx[0] = INF , findrt (1 , 0) , solve (rt) ;
		for (int i = 1 ; i <= m ; i++) printf ("%d\n" , ans[i]) ; 
	}
	return 0 ;
}
```

---


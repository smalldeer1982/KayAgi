# [THUPC 2022 初赛] 搬砖

## 题目背景

张华考上了北京大学；李萍进了中等技术学校；小 E 在工地搬砖：他们都有光明的前途。

## 题目描述

**温馨提示：请不要模仿小 E 的搬砖方式，那样很累。**

为了能够快乐地搬砖，小 E 有一种特殊的搬砖方式。

假设他的面前有 $n$ 摞砖，他会在一个小时内搬走每一摞砖最上面的 $d$ 块。其中 $d$ 是小 E 当前的精力值。如果一摞砖不够 $d$ 块，小 E 会把这一摞砖剩下的所有砖搬走。

当小 E 工作完一个小时后发现自己搬完了至少一摞砖，那么他会觉得很快乐，并且继续工作一个小时；但是由于完成了一部分工作，小 E 可能会产生懈怠的心理，导致精力值有所下降。具体地，对于每一摞砖都有一个属性 $b$，当小 E 搬完这一摞砖后，精力值就会下降 $b$。

如果没有任何一摞砖被搬完，小 E 就会停止工作。如果精力值下降到 $0$ 或以下，小 E 也会停止工作。如果小 E 发现自己需要工作但是所有的砖已被搬完，他会用别的方式来度过这一小时，但这一小时仍算作小 E 的工作时间。

工地的砖在不停增加，问如果小 E 初始的精力值为 $d$，那么他可以连续工作几个小时？

## 说明/提示

【样例解释】

第一组询问：

初始有 $3$ 摞砖，数量分别为 $(6,3,9)$，小 E 的初始精力是 $3$。

第一个小时，小 E 在每一摞砖中各搬了 $3$ 块，数量变成 $(3,0,6)$。其中第二摞砖被搬完，小 E 的精力因此下降 $0$ 并且继续工作一个小时。

第二个小时，小 E 在每一摞砖中各搬了 $3$ 块，数量变成 $(0,0,3)$。其中第一摞砖被搬完，小 E 的精力因此下降 $1$ 并且继续工作一个小时。

第三个小时，小 E 在每一摞砖中各搬了 $2$ 块，数量变成 $(0,0,1)$。由于没有新的砖摞被搬完，小 E 停止工作。

第二组询问：

初始有 $3$ 摞砖，数量分别为 $(6,3,9)$，小 E 的初始精力是 $4$。

第一个小时，小 E 在每一摞砖中各搬了 $4$ 块（第二摞砖由于只有 $3$ 块就只搬了 $3$ 块，以下省略），数量变成 $(2,0,5)$。其中第二摞砖被搬完，小 E 的精力因此下降 $0$ 并且继续工作一个小时。

第二个小时，小 E 在每一摞砖中各搬了 $4$ 块，数量变成 $(0,0,1)$。其中第一摞砖被搬完，小 E 的精力因此下降 $1$ 并且继续工作一个小时。

第三个小时，小 E 在每一摞砖中各搬了 $3$ 块，数量变成 $(0,0,0)$。其中第三摞砖被搬完，小 E 的精力因此下降 $2$ 并且继续工作一个小时。

第四个小时，小 E 在每一摞砖中各搬了 $1$ 块，但其实此时已经没有砖了，不过这一小时仍然算进小 E 的工作时间。由于没有新的砖摞被搬完，小 E 停止工作。

【样例解释 2】

第一组询问：

初始有 $1$ 摞砖，数量为 $2$，小 E 的初始精力是 $2$。

第一个小时，小 E 在每一摞砖中各搬了 $2$ 块，数量变成 $0$。这一摞砖被搬完，小 E 的精力因此下降 $1$ 并且继续工作一个小时。

第二个小时，小 E 在每一摞砖中各搬了 $1$ 块，但其实此时已经没有砖了，不过这一小时仍然算进小 E 的工作时间。由于没有新的砖摞被搬完，小 E 停止工作。

第二组询问：

初始有 $2$ 摞砖，数量为 $(2,2)$，小 E 的初始精力是 $2$。

第一个小时，小 E 在每一摞砖中各搬了 $2$ 块， 数量变成 $(0,0)$。两摞砖都被搬完，小 E 的精力因此下降 $1+1=2$。由于小 E 的精力下降到 $0$，他停止工作。

【数据范围】

保证 $T\le 351493,1\le op\le 2,1\le a\le 100000,0\le b\le 100000,1\le d \le 100000$。

## 样例 #1

### 输入

```
5
1 6 1
1 3 0
1 9 2
2 3
2 4```

### 输出

```
3
4
```

## 样例 #2

### 输入

```
4
1 2 1
2 2
1 2 1
2 2```

### 输出

```
2
1```

# 题解

## 作者：Alex_Wei (赞：6)

> *E. [P8211 [THUPC2022 初赛] 搬砖](https://www.luogu.com.cn/problem/P8211)*

不那么套路的根号分治。

当 $d \geq B$ 时，最多只需要经过 $\dfrac V B$ 个小时就可以使 $d$ 降为小于 $B$ 或者没有砖搬。后者是因为在每一堆累积搬的砖的个数不小于 $\dfrac V B \times B = V$，也就是砖都被搬空了。

这部分可以直接模拟，查询即查找砖块个数在 $[acc + 1, acc + d]$ 之间的堆数，以及将下降的精力值之和。因为只有线性次单点修改，线性根号次查询，所以使用分块平衡复杂度，时间复杂度线性根号。

对于 $d < B$ 的情况，我们尝试每一次使 $d$ 减少至少 $1$。如果没有精力为 $0$ 的堆，那么这是容易的，和上面一样模拟即可。

但可能有减小精力为 $0$ 的堆，但问题不大。我们考虑对每个 $d < B$ 维护每个 $acc$ 最终能到达哪个 $acc + kd$。就是说，如果有一堆砖 $(a, 0)$，那么对于一个 $d < B$，它能使所有在 $[a - d, a - 1]$ 之间的 $acc$ 跳到 $acc + d$，因为当 $acc\in [a - d, a - 1]$ 时，查询 $[acc + 1, acc + d]$ 之间的堆数 $> 0$（有 $a$ 存在啊），说明小 E 此时能搬空至少一堆转。

因此考虑并查集维护。如果遇到 $(a, 0)$ 那么枚举 $d < B$ 和 $[a - d, a - 1]$ 的所有位置 $p$，然后将并查集 $T_d$ 的位置 $p$ 连向 $p + d$。但这样复杂度爆炸了。

我们注意到有很多边是根本没有必要连的，就是如果本来 $p$ 已经和 $p + d$ 连起来了，那么没有必要再连一遍。这样一来复杂度均摊就是 $VB$ 的，因为只有 $VB$ 条边要连。

究竟有哪些边要连呢？考虑在所有精力为 $0$ 的堆当中 $a$ 关于砖块数的前驱 $pre$ 和后继 $suf$，因为 $[pre - d, pre - 1]$ 和 $[suf - d, suf - 1]$ 都连起来了（指连向 $+d$ 的位置），所以只要连 $[\max(pre, a - d), \min(a - 1, suf - d - 1)]$ 即可。

有了这个信息我们就可以快速跳过精力值为 $0$ 的段。注意在跳的时候最终的位置要和能取到下一个精力非零的堆的砖块数的 $acc$ 值取 $\min$，也就是查精力非零的堆当中 $acc$ 关于砖块数的 **严格** 后继 $suf$，则 $acc$ 跳到的位置即在当前 $d$ 对应的并查集中 $acc$ 的祖先节点，和 $acc + d\left\lfloor\dfrac {suf - acc - 1}{d}\right\rfloor$ 取较小值，然后将答案加上跳的步长除以 $d$，因为显然经过了这么多小时。

时间复杂度 $\mathcal{O}(T\sqrt V\log V)$，复杂度瓶颈在于每次查询 $acc$ 在非零的堆中关于砖块数的后继，但因为卡不满，所以跑得很快。甚至比绝大部分根号还要快。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int B = 320;
const int N = 1e5 + 5;
set <int> s, t;
int T, lb[B], rb[B], blk[N];
struct blocker {
	long long laz[B], val[N];
	void add(int x, int v) {
		for(int i = x; i <= rb[blk[x]]; i++) val[i] += v;
		for(int i = blk[x] + 1; i < B; i++) laz[i] += v;
	}
	long long query(int l, int r) {return l > r ? 0 : val[r] - val[l - 1] + laz[blk[r]] - laz[blk[l - 1]];}
} num, sum;
struct dsu {
	int fa[N + B]; // N -> N + B
	void init() {for(int i = 1; i < N + B; i++) fa[i] = i;}
	int find(int x) {return fa[x] == x ? x : fa[x] = find(fa[x]);}
	void connect(int x, int y) {fa[find(x)] = find(y);}
} f[B];
int main() {
	for(int i = 1; i < B; i++) f[i].init();
	for(int i = 1; i <= 1e5; i++) blk[i] = i / B;
	for(int i = 0; i <= blk[N - 5]; i++) lb[i] = max(1, i * B), rb[i] = min(N - 5, (i + 1) * B - 1);
	cin >> T, s.insert(-1e9), s.insert(1e9), t.insert(1e9);
	while(T--) {
		int op;
		scanf("%d", &op);
		if(op == 1) {
			int a, b;
			scanf("%d %d", &a, &b);
			num.add(a, 1), sum.add(a, b);
			if(!b) {
				auto it = s.lower_bound(a);
				int suf = *it, pre = *--it;
				for(int i = 1; i < B; i++) {
					int L = max(0, max(pre, a - i)), R = min(a - 1, suf - i - 1);
					for(int j = L; j <= R; j++) f[i].connect(j, j + i);
				}
				s.insert(a);
			}
			else t.insert(a);
		} else {
			int d, acc = 0, ans = 0;
			scanf("%d", &d);
			while(1) {
				if(d < B) {
					auto it = t.upper_bound(acc);
					int rlim = min(f[d].find(acc), acc + (*it - acc - 1) / d * d);
					ans += (rlim - acc) / d, acc = rlim;
				}
				ans++;
				int tot = num.query(acc + 1, min(N - 5, acc + d));
				if(!tot) break;
				long long dec = sum.query(acc + 1, min(N - 5, acc + d));
				if(d <= dec) break;
				acc += d, d -= dec;
			}
			printf("%d\n", ans);
		}
	}
	return 0;
}
```

---

## 作者：letitdown (赞：6)

题目大意：

~~问蓝龙亵渎几刀~~

当前场上有若干个怪，现在有一把攻击力 $d$ 的刀,每次去用这把刀去砍全场没有被砍死的怪，每个怪有血量 $a$ 和一个属性值 $b$，表示砍死这个怪之后 $d$ 会减少 $b$，当一个怪都没有砍死或者 $d\leq0$ 时停止砍怪，否则一直砍下去，问一共能砍几刀。如果最后把所有怪都砍死了，算上最后的空刀。

有 $n\leq 3.5*10^5$ 次操作，每次支持加一个血量为 $a$,属性为 $b$ 的怪，或者询问 $d$ 能砍几刀。值域 $m\leq 10^5$

下面的 $n$ 指代询问次数，$m$ 指代值域。

首先我们可以进行根号分治。

如果当前的精力值 $d$ 大于 $\sqrt m$，那么我们最多砍 $\sqrt m$ 刀就能把所有怪都砍死，可以直接暴力砍。

否则 $d\leq \sqrt m$，如果所有 $b>0$ 就好办了，$d$ 每次至少扣 1，还是最多砍 $\sqrt m$ 刀，暴力就好了，可是有可恶的 0。

~~你聪明的，告诉我，该怎么办呢？~~

我们考虑用分块维护值域内每个点后面的第一个能够对自己造成伤害的值并支持 $O(\sqrt m)$ 修改，$O(1)$ 查询，并作为辅助在求答案的时候记录下之前一共造成了多少伤害 $now$，和当前的 $d$,这样的话每次查询一下下一个这样的值，顺便更新一下 $now,d$ 就可以沿用上面的套路了,其中 $now,d$ 依然可以分块用同样的复杂度维护。

那么问题又来了，我怎么知道每次砍 $d$，能不能砍到这个值呢？

我们可以并查集！

对每个 $\leq \sqrt m$ 的 $d$ 维护建立在值域上的并查集，其中 $i$ 点 $find$ 到的值就是如果每次砍 $d$，最多能够砍到哪里，每次询问的时候对每个 $d$ 更新一下就好了。

这样的话流程就出来了：

1. 对于修改，先用分块维护一下区间点个数和区间 $b$ 的和，以及每个点后面第一个能造成伤害的点。然后再用并查集维护一下每个点能砍到哪里。
2. 对于询问，进行根号分治，如果当前 $d$ 小于 $\sqrt m$ 就比较最远能砍到的点和下一个能造成伤害的点并更新答案，否则直接暴力计算答案。

最后让我们算一下复杂度 ~~(不严谨轻喷)~~。

修改的分块复杂度一共是 $O(n\sqrt m)$,并查集由于每个点只会被更新到一次并且路径压缩复杂度看成常数所以一共是 $O(m\sqrt m)$ 的。
询问由于求值都是 $O(1)$ 的，那么根据上面的根号分治可知最多砍 $O(\sqrt m)$ 次，所以是 $O(n\sqrt m)$ 的。

那么整个下来总复杂度就是常数不大不小的 $O((n+m)\sqrt m)$，实测跑得飞快，每个点不超过 2s。

最后放个代码吧：

```cpp
#include<cstring>
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
namespace EMT{
	typedef long long ll;typedef double db;
	#define pf printf
	#define F(i,a,b) for(int i=a;i<=b;i++)
	#define D(i,a,b) for(int i=a;i>=b;i--)
	inline int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
	inline void file(){freopen("21.in","r",stdin);freopen("my.out","w",stdout);}
	inline int max(int a,int b){return a>b?a:b;}inline int min(int a,int b){return a<b?a:b;}
	inline void pi(int x){pf("%d ",x);}inline void pn(){pf("\n");}
	const int N=1e5+162,T=160,S=N/T+1;
	struct block1{
		int s1[N],s2[S];
		inline void add(int x,int v){int k=x/T;for(int i=x;i<(k+1)*T&&i<N;i++)s1[i]+=v;for(int i=k+1;i<S;i++)s2[i]+=v;}
		inline int ask(int x){x=min(x,1e5);return s1[x]+s2[x/T];}
		inline int ask(int l,int r){return ask(r)-ask(l);}
	}b1;
	struct block2{
		ll s1[N],s2[S];
		inline void add(int x,int v){int k=x/T;for(int i=x;i<(k+1)*T&&i<N;i++)s1[i]+=v;for(int i=k+1;i<S;i++)s2[i]+=v;}
		inline ll ask(int x){x=min(x,1e5);return s1[x]+s2[x/T];}
		inline ll ask(int l,int r){return ask(r)-ask(l);}
	}b2;
	struct block3{
		int v1[N],v2[S];
		block3(){memset(v1,0x3f,sizeof(v1));memset(v2,0x3f,sizeof(v2));}
		inline void add(int x,int v){int k=x/T;for(int i=k*T;i<=x&&i<N;i++)v1[i]=min(v1[i],v);for(int i=0;i<k;i++)v2[i]=min(v2[i],v);}
		inline int ask(int x){x=min(x,1e5);return min(v1[x],v2[x/T]);}
	}b3;
	struct dsu{int fa[N];inline int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}}d[T];
	inline short main(){
		int m=read();
		for(int i=1;i<T;i++)for(int j=0;j<N;j++)d[i].fa[j]=j;
		while(m--){
			int opt=read();
			if(opt==1){
				int x=read(),v=read();
				b1.add(x,1);
				b2.add(x,v);
				if(v)b3.add(x,x);
				int k=x;
				while(k<x+T&&!b1.ask(k,k+1))k++;
				for(int i=1;i<T;i++)
					for(int j=min(x-1,k-i);j>=0&&j>=x-i&&d[i].fa[j]==j;j--)
						d[i].fa[j]=j+i;
			}else{
				int x=read(),now=0,ans=0;
				while(x>0){
					ans++;
					if(!b1.ask(now,now+x))break;
					if(x<T){
						int v=min(b3.ask(now+1),d[x].find(now));
						int k=(v-1-now)/x;
						ans+=k;now+=k*x;
					}now+=x;x-=b2.ask(now-x,now);
				}pi(ans);pn();
			}
		}
		return 0;
	}
}
signed main(){return EMT::main();}
```

---

## 作者：zac2010 (赞：5)

以下设 $B$ 为一个阈值，同时也表示值域分块的块长。

先考虑**所有 $b$ 都不为 $0$** 的情况。对于一组询问，我们设一个 $x$ 表示：当前已搬完所有 $a\leq x$ 的砖。那么每次只可能是以下两种情况之一：

1. 有至少一摞砖在当前这个单位时间内被搬完

   拿 $x$ 加上 $d$，之后拿 $d$ 减去 $\sum_{a_i\in[x+1,x+d+1]}b_i$。

   $\sum_{a_i\in[x+1,x+d+1]}b_i$ 的计算可以采用**值域分块**做到**修改 $O(\sqrt n)$，询问 $O(1)$**。 

2. 没有砖搬完

   结束此过程。

对于单组询问，我们尝试分析其时间复杂度：

* $d > B$

  显然上述 $1$ 操作最多执行 $\frac{V}{B}$ 次。

* $d\leq B$

  因为我们不关心 $d=0$ 的情况，所以每个小时 $d$ 都会减少。即 $1$ 操作执行不超过 $B$ 次。

修改只需要维护一下上述值域分块即可。总时间复杂度 $O(T(B+\frac{T}{B})+V(B+\frac{V}{B}))$。

但是，原命题中**实际存在 $b=0$** 的情况，也就是上述方法可能会在一些数据下变成 $O(n)$ 的，那我们又该如何应对？

易发现，复杂度退化只会在 $d\leq\sqrt V$ 的情况下产生。故而考虑维护**一个 $O(\sqrt n)$ 修改**、**$O(1)$ 查询 $\geq i$ 的第一个非零位置**的**值域分块**。同时对于**每种 $\leq\sqrt V$ 的 $d$** 维护一个并查集，以求解 $d$ 取当前值、$x$ 为起点，最多能加到达哪里（具体操作见上述操作 $1$，可以认为这个维护是在只考虑“如果没有任何一摞砖被搬完，小E就会停止工作”这一条件下进行的）。

于是询问中 $d\leq B$ 的部分，就可以用这两个数据结构去维护 $x,d$ 了。

时间复杂度多个 $\log$，为并查集的复杂度（注意这里不能用按秩合并）。

```cpp
#include <bits/stdc++.h>
#define FL(i, a, b) for(int i = (a); i <= (b); i++)
#define FR(i, a, b) for(int i = (a); i >= (b); i--)
using namespace std;
const int N = 1e5 + 170, C = 650;
int n, L, S;
inline char gc(){
    static char buf[100000], *p1 = buf, *p2 = buf;
    return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2)? EOF : *p1++;
}
inline int read(){
    register char ch = gc(); register int sum = 0;
    while(!(ch >= '0' && ch <= '9')) ch = gc();
    while(ch >= '0' && ch <= '9') sum = sum * 10 + ch - 48, ch = gc();
    return sum;
}
inline void write(int x){
	if(x < 10){putchar('0' + x); return;}
	write(x / 10), putchar('0' + x % 10);
}
struct B1{
	int a[N + 10], t[C];
	void Upd(int x, int v){
		int b = x / L;
		FL(i, x, b * L + L - 1) a[i] += v;
		FL(i, b + 1, N / L) t[i] += v;
	}
	int Qry(int l, int r){
		l = min(l, N), r = min(r, N); 
		return a[r] + t[r / L] - a[l - 1] - t[(l - 1) / L];
	}
} b1, b2;
struct B3{
	int a[N + 10], t[C];
	B3(){fill(a, a + N + 1, 1e9), fill(t, t + C, 1e9);}
	void Upd(int x, int v){
		int b = x / L;
		FL(i, b * L, x) a[i] = min(a[i], v);
		FL(i, 0, b - 1) t[i] = min(t[i], v);
	}
	int Qry(int x){
		x = min(x, N); return min(a[x], t[x / L]);
	}
} b3;
struct DSU{
	int fa[N + 10];
	DSU(){FL(i, 0, N) fa[i] = i;}
	int F(int x){return fa[x] == x? x : fa[x] = F(fa[x]);}
} u[163];
int main(){
	n = read(), L = 160, S = N / L + 1;
	FL(id, 1, n){
		int op = read(), a, b, d, x = 0, ans = 0;
		if(op == 1){
			a = read(), b = read();
			b1.Upd(a, 1), b2.Upd(a, b);
			if(b) b3.Upd(a, a); int r = a;
			while(r < min(N, a + L) && !b1.Qry(r + 1, r + 1)) r++;
			FL(i, 1, L) FR(j, min(a - 1, r - i), a - i){
				if(j + i > N || j < 0 || u[i].fa[j] != j) break;
				u[i].fa[j] = j + i;
			}
		}
		else{
			d = read();
			while(d > 0){
				ans++; if(!b1.Qry(x + 1, x + d)) break;
				if(d <= L){
					int y = min(b3.Qry(x + 1), u[d].F(x));
					ans += (y - x - 1) / d, x += (y - x - 1) / d * d;
				}
				x += d, d -= b2.Qry(x - d + 1, x);
			}
			write(ans), putchar('\n');
		}
	}
	return 0;
}
```

---

## 作者：Sol1 (赞：5)

首先转化一下问题的形式：数轴上有若干个点，每一个点有属性 $b$，每一次修改可以加入一个点。对于每一次询问，你有一个属性 $d$，初始位于 $0$，每一步可以向前推进 $d$。如果一步之内没有跨过任何点，结束；否则将 $d$ 减去跨过的点的 $b$ 的和，如果 $d\le 0$，结束。问会推进几次。

猜测推进步数不会很多。事实上，如果所有 $b$ 都是正的，那么这个结论就是对的：当 $d>\sqrt n$ 的时候，推进 $\sqrt n$ 次会爆出数轴上所有点坐标的上限并结束推进；$d\leq \sqrt n$ 的时候，推进 $d$ 次 $d$ 就一定没了，所以在 $b$ 全正的时候最多推进 $\sqrt n$ 次。

但是很恶心的事情就是这个 $b$ 会是 $0$，这时对于比较小的一部分复杂度就是假的。很自然的想法是把 $d$ 一样的推进放到一起维护。具体来说，我们二分连续的推进次数，检查这一段区间中的 $b$ 是否都是 $0$。

用分块维护 $b$，设阈值 $B=\sqrt{\dfrac{n}{\log n}}$ 做到总复杂度 $O(T\sqrt{n\log n})$，做完了！

等等，我们漏掉了什么。在 $d$ 一样的推进的过程中，可能会因为下一步不会跨过任何点而结束推进。具体来说，我们需要对每一个 $d$，维护所有长度为 $d$ 的子段里面是否已经有点。

如果使用二分条件来满足这个限制，我们需要支持加入一个点和 $O(1)$ 区间查询。这个看起来就很难，所以考虑用二分边界卡住这个东西。注意到现在我们需要的操作是加入一个点以及**对于一个点，向后求一个最近的子段使得这个子段里面没有任何点**。同时注意到我们只有 $O(nB)$ 个子段，而且在加入一个点的时候，我们可以通过维护数轴上的上一个和下一个点从而快速无冗余地遍历所有状态改变了的子段，只要左端点不超过上一个点，右端点不超过下一个点，而且区间包含新点就可以了。

那么我们考虑用一个并查集来维护后继，每次修改的时候暴力合并，这样均摊一下是 $O(nB\alpha(n))$ 的，非常优秀。

于是我们利用这个结构，再套用上面的做法，不改变阈值就可以做到总复杂度 $O((n+T)\sqrt{n\log n})$，实测阈值取 $60$ 在 luogu 上只需要 5s 多一点。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

inline int qread() {
	register char c = getchar();
	register int x = 0, f = 1;
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + c - 48;
		c = getchar();
	}
	return x * f;
}

const int S = 317, N = 120005, T = 70;
struct Decomp {
	int pres[N / S + 5][S + 5], pos[N], blks[N / S + 5], bl[N / S + 5], br[N / S + 5];
	inline void Init() {
		for (int i = 1;i <= 114514;i++) pos[i] = (i - 1) / S + 1;
		for (int i = 1;i <= pos[114514];i++) {
			bl[i] = (i - 1) * S + 1;
			br[i] = i * S;
		}
	}
	inline void Modify(int idx, int val) {
		for (int j = idx;j <= br[pos[idx]];j++) pres[pos[idx]][j - bl[pos[idx]] + 1] += val;
		for (int j = pos[idx];j <= pos[114514];j++) blks[j] += val;
	}
	inline int Query(int l, int r) {
		r = min(r, 114514);
		if (pos[l] == pos[r]) return pres[pos[l]][r - bl[pos[l]] + 1] - pres[pos[l]][l - bl[pos[l]]];
		return pres[pos[l]][br[pos[l]] - bl[pos[l]] + 1] - pres[pos[l]][l - bl[pos[l]]] + pres[pos[r]][r - bl[pos[r]] + 1] + blks[pos[r] - 1] - blks[pos[l]];
	}
};
Decomp asq, bsq;

struct Dsu {
	int f[N];
	Dsu() {
		for (int i = 1;i <= 114514;i++) f[i] = i;
	}
	inline int GetRoot(int v) {
		if (f[v] == v) return v;
		return f[v] = GetRoot(f[v]);
	}
	inline void Merge(int x, int y) {
		int u = GetRoot(x), v = GetRoot(y);
		if (u != v) f[u] = v;
	}
};
Dsu sm[T + 5];

set <int> st;

inline int Go(int x, int d) {
	if (d <= 0) return 0;
	if (x > 100000) return 1;
	if (d > T) {
		if (asq.Query(x + 1, x + d)) return Go(x + d, d - bsq.Query(x + 1, x + d)) + 1;
		else return 1;
	}
	else {
		int l = 0, r = (sm[d].GetRoot(x + 1) - x - 1) / d + 1;
		while (l < r - 1) {
			int mid = l + r >> 1;
			if (bsq.Query(x + 1, x + mid * d) > 0) r = mid;
			else l = mid;
		}
		int pd = l, bdt = bsq.Query(x + 1, x + (l + 1) * d);
		x += d * pd;
		if (asq.Query(x + 1, x + d)) return Go(x + d, d - bdt) + pd + 1;
		else return pd + 1;
	}
}

inline void Solve() {
	asq.Init(); bsq.Init();
	int t = qread();
	st.insert(0); st.insert(100001);
	for (int i = 1;i <= t;i++) {
		int opt = qread();
		if (opt == 1) {
			int a = qread(), b = qread();
			asq.Modify(a, 1);
			bsq.Modify(a, b);
			int l = *(--(st.upper_bound(a))), r = *(st.lower_bound(a));
			for (int i = 1;i <= T;i++) {
				for (int j = max(l + 1, a - i + 1);j + i - 1 < r && j <= a;j++) sm[i].Merge(j, j + i);
			}
		} else {
			int d = qread();
			cout << Go(0, d) << '\n';
		}
	}
}

int main() {
	std::ios::sync_with_stdio(0);
	Solve();
	return 0;
}
```

---

## 作者：do_while_true (赞：5)

抽象一下问题，设一个变量 $x$，初始为 $0$，每次令 $x\gets x+d$，并同时将 $d$ 减去砖数在 $(x,x+d]$ 内的砖的代价，如果没有砖就停止，询问一共可以跳几步。

定义："零砖" 为代价为 $0$ 的砖，"非零砖" 为代价 $>0$ 的砖。

若 $d>\sqrt n$，则最多跳 $\sqrt n$ 步，所以可以这一部分可以暴力跳，每次要查询一个区间和，用 $\mathcal{O}(\sqrt n)$ 单点修改，$\mathcal{O}(1)$ 区间查询的分块维护即可，这一部分总复杂度就被平衡到了 $\mathcal{O}(n\sqrt n)$。

若 $d\leq \sqrt n$，则 $d$ 最多减少 $\sqrt n$ 次，若每次能 $\mathcal{O}(x)$ 定位 $d$ 在哪里减少了（或者跳了一个空的区间导致结束），然后在那里暴力跳，这一部分复杂度就是 $\mathcal{O}(x\sqrt n)$．　

假设我们现在以 $d$ 为块长，与 $(x+1)$ 模 $d$ 意义下同余的位置作为块起始端点，进行分块。

定位到 $d$ 在哪里减少了，相当于查询当前位置后面第一个非零砖的位置，然后算出他所在的块即可。这一部分相当于 01 序列，单点置 1，查询一个位置后面第一个 1，由于修改有 $\mathcal{O}(n)$ 次，查询有 $\mathcal{O}(n\sqrt n)$ 次，可以用分块来平衡复杂度做到 $\mathcal{O}(\sqrt n)$ 修改 $\mathcal{O}(1)$ 查询。

看是否会跳一个空区间导致结束，相当于看当前这种分块方案下后面第一个不合法的块（合法定义为块里面有砖）是哪一个。注意到是按照块的端点模 $d$ 的余数分类的，所以所有分块方案的总块数是 $\sum d\times \frac{n}{d}=\mathcal{O}(n\sqrt n)$．

那么在每一次加入砖的时候，设 $t$ 为新变成合法块的块数，若能在 $\mathcal{O}(t)$ 的复杂度内找到遍历所有的新合法块，那么要解决的问题就是 01 序列，单点置 1，查询一个位置后面第一个 0（也就是一个块新变成合法，或者查询一个位置后面第一个不合法块），这个可以并查集维护。

如何 $\mathcal{O}(t)$ 找到所有新合法块？在每次新加入一个砖的时候，找到它前面第一个砖，后面第一个砖，然后枚举块长 $d$，就很容易枚举出来了。

综上所述，总复杂度为 $\mathcal{O}(n\sqrt n\alpha(n))$，采用[线性树上并查集](https://www.cnblogs.com/bzy-blog/p/14353073.html)即可做到时间复杂度 $\mathcal{O}(n\sqrt n)$．

代码能力太弱了，我的常数有点大，好像跑得不是很快...

```cpp
//O(n sqrtn a(n))
#include<cstdio>
#include<vector>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<set>
#define pb emplace_back
#define mp std::make_pair
#define fi first
#define se second
#define int long long
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int>pii;
typedef pair<ll,int>pli;
typedef pair<ll,ll>pll;
typedef vector<int>vi;
typedef vector<ll>vll;
typedef vector<pii>vpii;
template<typename T>T cmax(T &x, T y){return x=x>y?x:y;}
template<typename T>T cmin(T &x, T y){return x=x<y?x:y;}
template<typename T>
T &read(T &r){
	r=0;bool w=0;char ch=getchar();
	while(ch<'0'||ch>'9')w=ch=='-'?1:0,ch=getchar();
	while(ch>='0'&&ch<='9')r=r*10+(ch^48),ch=getchar();
	return r=w?-r:r;
}
template<typename T1,typename... T2>
void read(T1 &x, T2& ...y){ read(x); read(y...); }
const int N=100010;
const int K=100000;
const int B=500;
const int M=510;
inline int lowbit(int x){return x&(-x);}
struct Block{
	ll sum[N],suf[N];
	void modify(int x,int v){
		int b=(x-1)/B;
		for(int i=b;i<=(K-1)/B;i++)sum[i]+=v;
		for(int i=x;i>b*B;i--)suf[i]+=v;
	}
	ll sumq(int x){
		return x<=0 ? 0 : sum[(x-1)/B]-(x%B==0?0:suf[x+1]);
	}
	ll query(int x,int y){
		cmin(y,K);
		if(x>y)return 0;
		return sumq(y)-sumq(x-1);
	}
}tr1,tr2;
int one[N],zero[N];
int tag[N],va[N];
void ins(int x){
	int b=(x-1)/B;
	for(int i=b-1;~i;--i)cmin(tag[i],x);
	for(int i=x;i>b*B;i--)cmin(va[i],x);
}
int que(int x){
	return min(va[x],tag[(x-1)/B]);
}
set<int>zs,rzs;
vi f[M][M];
int find(int p,int q,int x){
	return f[p][q][x]!=x?f[p][q][x]=find(p,q,f[p][q][x]):x;
}
void merge(int p,int q,int x,int y){
	int fx=find(p,q,x),fy=find(p,q,y);
	f[p][q][fx]=fy;
}
int calc(int x,int y){
	int len;
	if(!y)len=K-(x-1);
	else len=K-(y-1);
	return (len+x-1)/x;
}
int calc2(int pos,int x,int y){
	if(!y)pos-=x-1;
	else pos-=y-1;
	return (pos-1)/x+1;
}
int solve(int d){
	int x=0;
	int ans=1;
	while(d>B&&x<=K){
		if(!tr2.query(x+1,x+d))return ans;
		ll tmp=tr1.query(x+1,x+d);
		x+=d;
		++ans;
		if(d<=tmp)return ans-1;
		d-=tmp;
	}
	if(x>K)return ans;
	while(x<=K){
		int pos1=que(x+1);
		int xd=(x+1)%d;
		int now=calc2(x+1,d,xd);
		int nex=find(d,xd,now);
		nex=min(nex,calc2(pos1,d,xd));
		ans+=nex-now;
		x+=(nex-now)*d;
		//
		if(!tr2.query(x+1,x+d))return ans;
		ll tmp=tr1.query(x+1,x+d);
		x+=d;
		++ans;
		if(d<=tmp)return ans-1;
		d-=tmp;
	}
	return ans;
}
signed main(){
	for(int i=0;i<=K+1;i++)tag[i]=va[i]=K+1;
	zs.insert(K+1);
	rzs.insert(K+1);
	for(int i=1;i<=B;i++){
		for(int j=0;j<i;j++){
			int len=calc(i,j);
			f[i][j].resize(len+2);
			for(int k=1;k<=len+1;k++)
				f[i][j][k]=k;
		}
	}
	int T;read(T);while(T--){
		int op;read(op);
		if(op==1){
			int x,y;read(x,y);
			if(!one[x]&&y){
				one[x]=1;
				ins(x);
			}
			tr1.modify(x,y);
			tr2.modify(x,1);
			if(!y){
				if(zero[x])continue;
				zero[x]=1;
				int ne=*zs.lower_bound(x);
				int la=K-(*rzs.lower_bound(K-x));
				if(la<0)la=0;
				zs.insert(x);
				rzs.insert(K-x);
				for(int d=1;d<=B;d++){
					int p=max(la+1,x-d+1);
					for(int i=p;i<=x&&i+d<=ne;i++){
						int tmp=calc2(i,d,i%d);
						merge(d,i%d,tmp,tmp+1);
					}
				}
			}
		}
		else{
			int d;read(d);
			cout << solve(d) << '\n';
		}
	}
	return 0;
}
```

---

## 作者：myee (赞：4)

### 前言

赛时打了个迷惑复杂度的做法，把我自己迷惑了。

胡一个做法。

---
### 思路

看到时限 $10s$，数据范围 $10^5$ 级别，直接考虑根号做法。

设阈值为 $T$。

首先，$d>T$ 的次数为 $O({n\over T})$ 次，直接暴力往后跳就好了。

再者，$d\le T$ 的，如果每次都保证精力有减少，则次数为 $O(T)$ 次。

可以考虑 binary search 找到下一次精力减少的位置。

似乎是对的？

> 如果没有任何一摞砖被搬完，小 E 就会停止工作。

这个东西并查集维护一下就好了。

为了平衡复杂度你可以考虑值域分块，块长 $\sqrt n$。

$O(T^2+\sqrt n)$ 修改，$O({n\over T}+T\log n)$ 查询。

取 $T=n^{\frac13}$，单次复杂度即为 $O(n^{\frac23})$。

这样就可以过题了。

---

似乎可以做到 $O(n\sqrt{n\alpha(n)})$。

就是利用并查集特性，一共 $O(nT)$ 个元素，再开一组并查集就好了，可以把单次修改操作复杂度均摊成 $O(T\alpha(n)+\sqrt n)$。

然后查询也可以优化，即 binary search 的部分也可以平衡掉，查询复杂度 $O({n\over T}+T\alpha(n))$。

于是取 $T=\sqrt{n\over\alpha(n)}$ 即可。

实际跑起来未见得更快很多。

感觉应该有更好想复杂度也更优的做法。


---


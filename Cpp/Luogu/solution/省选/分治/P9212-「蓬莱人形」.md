# 「蓬莱人形」

## 题目背景

不老不死的妹红，还能称之为「人类」吗？

超脱了生死的人类，本来就是不可思议的啊。


## 题目描述

为了证明人类的可能性，你需要解决一个问题。

给定序列 $a=[a_1,a_2,\cdots,a_n]$。现在有 $q$ 次询问：

- 每次给定二元组 $(x,y)$、模数 $m$，以及一个区间 $[l,r]$。求出有多少 $i\in [l,r]$ 满足 $(a_i+x)\bmod m<(a_i+y)\bmod m$。

## 说明/提示

### 样例解释

- 对于第一组询问，符合条件的元素的下标为 $1, 2, 7, 8$；
- 对于第二组询问，没有符合条件的元素；
- 对于第三组询问，符合条件的元素的下标为 $2, 3, 4, 5, 6, 7$；
- 对于第四组询问，符合条件的元素的下标为 $5, 6, 9$；
- 对于第五组询问，符合条件的元素的下标为 $1, 2$。

### 数据范围及约定

对于全部数据，$1\le n\le 10^5$，$1\le q\le 5\times 10^5$，$1\le a_i,x_i,y_i,m_i\le 10^5$，$1\le l_i\le r_i\le n$。

## 样例 #1

### 输入

```
10 5
4 3 2 5 8 5 3 3 1 2
1 10 3 7 6
4 10 5 5 4
2 7 1 2 9
5 9 3 4 7
1 3 5 1 8```

### 输出

```
4
0
6
3
2
```

# 题解

## 作者：InoueTakina (赞：5)

一眼丁真，鉴定为签到题。

半年前扣扣莉 noip 后和我说了这题，但是当时已经退役回去文化课了，所以没细想，口胡了一个 $\mathcal{O}(n\sqrt n\log n)$ 的在线做法。在这里留作参考：

简单数据结构题。下记 $w$ 为值域，$q$ 为询问次数

**在模 $m$ 的环上考察一次询问，注意到合法的 $a_i$ 是一段区间。**

原问题即转化为求一段区间在 $\bmod m$ 意义下 $<x$ 的数的个数。

考虑根号分治，对于 $<L$ 的模数，暴力处理出序列并分别建主席树。这部分的复杂度瓶颈主要在于建主席树，复杂度 $\mathcal{O}(Ln\log n)$。

否则考虑直接对原序列建主席树，并枚举 $\lfloor \frac{a_i}{m}\rfloor$ 的大小，这部分的复杂度瓶颈在于查询，为 $\mathcal{O}(q\frac{w}{L}\log n)$。

注意到 $n,q,w$ 同阶，不妨统一记作 $m$，不难确定 $\frac{m^2}{L}\log m=Lm\log m$，$L=\sqrt m$，时间复杂度 $\mathcal{O}(m\sqrt m \log m)$。


事实上，似乎可以做到 $\mathcal{O}(m\sqrt{m\log m})$。

---
考虑离线下来怎么做，仍然将原问题转化为求一段区间在 $\bmod m$ 意义下 $<x$ 的数的个数。

进一步的，将询问差分为 $[1,r]-[1,l-1]$。

考虑平衡规划，记阈值为 $L$，对于小于 $L$ 的模数，对序列 $a$ 做扫描线，开一个 $L\times L$ 的数组维护当前形如 $\bmod m=i$ 的数的个数。询问时暴力查询即可，时间复杂度 $\mathcal{O}(nL+qL)$。

对于大于 $L$ 的模数，枚举商，即 $\lfloor \frac{a_i}{m}\rfloor$，这部分要求我们建立一个基于值域的数据结构：单点修，前缀查。使用树状数组容易做到 $\mathcal{O}(n\log w+qL\log w)$，注意到这个东西实际上两边很不平衡，经典的，用根号修，$\mathcal{O}(1)$ 查的数据结构再平衡一次，复杂度 $\mathcal{O}(n\sqrt n + qL)$。

容易的上述 $L=\sqrt n$ 时复杂度最优，为 $\mathcal{O}(n\sqrt n+q\sqrt n)$。

自己口胡的，不如贴一个 @Tony2 的代码吧！

```
const int N = 1e5 + 5, Q = 5e5 + 5, lim = 1e5, S = 316;
int n, q, a[N];
int block[N], sl[N], sr[N];
int cnt1[N], cnt2[N], tag2[N];
struct node{
	int mod, x, l, r, id, k;
	friend bool operator < (const node &a, const node &b){
		return a.mod < b.mod;
	}
};
struct node2{
	int l, r, id, k;
};
vector<node> ques, ques3[N];
vector<node2> ques2[N];
int ans[Q];
void add(int x, int k){
	for (int i = block[x]; i <= block[lim]; i++)
		tag2[i] += k;
	for (int i = x; i <= sr[block[x]]; i++)
		cnt2[i] += k;
}
int ask(int x){
	return cnt2[x] + (block[x] ? tag2[block[x] - 1] : 0);
}
int ask(int l, int r){
	l = max(0, l);
	r = min(lim, r);
	return ask(r) - (l ? ask(l - 1) : 0);
}
int main(){
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	for (int i = 0; i <= lim; i++)
		block[i] = i / S;
	for (int i = 0; i <= lim; i++)
		sr[block[i]] = i;
	for (int i = lim; i >= 0; i--)
		sl[block[i]] = i;
	cin >> n >> q;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	for (int i = 1; i <= q; i++){
		int l, r, x, y, m;
		cin >> l >> r >> x >> y >> m;
		x %= m, y %= m;
		if (m < S){
			if (x < y){
				ques.push_back(node{m, l - 1, 0, m - y - 1, i, -1});
				ques.push_back(node{m, r, 0, m - y - 1, i, 1});
				if (x){
					ques.push_back(node{m, l - 1, m - x, m - 1, i, -1});
					ques.push_back(node{m, r, m - x, m - 1, i, 1});
				}
			}else if (x > y){
				ques.push_back(node{m, l - 1, m - x, m - y - 1, i, -1});
				ques.push_back(node{m, r, m - x, m - y - 1, i, 1});
			}
		}else{
			if (x < y){
				ques.push_back(node{m, l - 1, -x, m - y - 1, i, -1});
				ques.push_back(node{m, r, -x, m - y - 1, i, 1});
			}else{
				ques.push_back(node{m, l - 1, m - x, m - y - 1, i, -1});
				ques.push_back(node{m, r, m - x, m - y - 1, i, 1});
			}
		}
	}
	sort(ques.begin(), ques.end());
	vector<node>::iterator it = ques.begin();
	for (int i = 1; i < S; i++){
		for (int j = 1; j <= n; j++)
			ques2[j].clear();
		for (; it != ques.end() && it -> mod == i; it++)
			ques2[it -> x].push_back(node2{it -> l, it -> r, it -> id, it -> k});
		for (int j = 0; j < i; j++)
			cnt1[j] = 0;
		for (int j = 1; j <= n; j++){
			cnt1[a[j] % i]++;
			for (node2 nd : ques2[j])
				for (int k = nd.l; k <= nd.r; k++)
					ans[nd.id] += nd.k * cnt1[k];
		}
	}
	for (; it != ques.end(); it++)
		ques3[it -> x].push_back(*it);
	for (int i = 1; i <= n; i++){
		add(a[i], 1);
		for (node nd : ques3[i])
			for (int l = nd.l, r = nd.r; l <= lim; l += nd.mod, r += nd.mod)
				ans[nd.id] += nd.k * ask(l, r);
	}
	for (int i = 1; i <= q; i++)
		cout << ans[i] << endl;
	return 0;
}
```

---

## 作者：Pengzt (赞：4)

[P9212](https://www.luogu.com.cn/problem/P9212)

看到除法相关容易想到根号分治。

先对 $x,y$ 进行讨论，不妨令 $0\le x,y<m$。

$x<y$ 时，当满足 $a_i+y < m$ 或 $a_i+x\ge m$ 时，即当 $a_i<m-y$ 或 $a_i\ge m-x$ 满足 $(a_i+x)\bmod m<(a_i+y)\bmod m$，即 $a_i \bmod m\in [0,m-y-1]\bigcup[m-x,m-1]$。

$x=y$ 时，无解。

$x>y$ 时，满足 $a_i+x\ge m$ 且 $a_i+y<m$ 时成立，即 $a_i\bmod m\in[0,m-y-1]\bigcap[m-x,m-1]$。也可以交换  $x,y$ 后按照方案一计算，然后用总方案数减去它即可。

这时候问题可以转化为每次求当前区间模 $m$ 小于 $x$ 的数的个数，先将区间容斥一下，$w(l,r,u,d,m)=w(1,r,u,d,m)-w(1,l-1,u,d,m)$。

设定阈值 $B$。

当 $m\le B$ 时，由于 $m$ 的取值只有 $B$ 个。可将 $w$ 看作一个询问，按 $w$ 的第二维排序，变为插入一个数 ，查询小于 $x$ 的数的个数，共有 $\mathcal{O}(nB)$ 次插入，$\mathcal{O}(q)$ 次查询,若直接使用树状数组维护，复杂度为 $\mathcal{O}(m\log B+nB\log B)$。但这样显然是不可以接受的。发现两边差异较大，可以使用分块来平衡。

当 $m>B$ 时，先按 $w$ 的第二维排序。每次插入一个数或查询一段区间的和。但是查询是通过枚举商，即会查询 $\dfrac{qm}{B}$ 次。同理可以使用分块维护块内及块间的前缀和，即可做到修改 $\mathcal{O}(\sqrt{n})$，查询 $\mathcal{O}(1)$ 了。

第一个块长取 $20$，第二个块长取 $320$，$B$ 取 $500$ 可过。

时间复杂度：$\mathcal{O}(nB+n\sqrt{n}+\dfrac{qm}{B})$。

[评测记录](https://www.luogu.com.cn/record/123368221)

---

## 作者：未来姚班zyl (赞：3)

## 题目大意

给定一个序列 $a_n$，$q$ 次查询 $[l,r]$ 中有多少 $a_i$ 满足 $a_i+x\mod m<a_i+y\mod m$。

## 题目分析

首先 $x,y$ 对 $m$ 取模。考虑合法的 $a_i$ 在模 $m$ 意义下的范围。

- 当 $x=y$ 时，无解。

- 当 $x<y$ 时，要么都没取模，要么都取模，则合法的 $a_i\in [0,m-1-y]\cup[m-x,m-1]$。

- 当 $x>y$ 时，只有当 $+x$ 时取模，$+y$ 时不取模才合法，此时 $a_i\in[m-x,m-1-y]$。

所以查询相当于对值域上的 $O(\frac{V}{m})$ 个区间查询，$V$ 为值域。分析时间复杂度时将会更替为 $n$。

很容易考虑到将询问差分成两个前缀，然后扫描线，操作变为插入一个数与查询若干区间。

观察到 $m$ 较小时不如直接大力维护模 $m$ 意义下的取值数量，考虑根号分治，设块长为 $B$。

- 对于 $m\le B$ 的查询，直接暴力维护并暴力查询模 $m$ 意义下的取值数量，复杂度 $O(nB+qB)$。

- 对于 $m>B$ 的查询，考虑直接在值域上暴力修改与查询，树状数组即可，复杂度 $O(n\log n+\frac{n}{B}q\log n)$。

根据基本不懂式，$B$ 取 $O(\sqrt{n\log n})$ 时有理论最优复杂度 $O(q\sqrt{n\log n})$，[无法通过此题](https://www.luogu.com.cn/record/141844599)。所以预测常数更大的在线主席树算法也无法通过此题。

观察到第二部分的查询复杂度太高了，而修改复杂度却小到可以忽略。所以我们使用分块维护第二类的修改和查询，第二类复杂度就能变为 $O(n\sqrt n+\frac{n}{B}q)$，当 $B$ 取 $O(\sqrt n)$ 时有理论最优复杂度 $O(q\sqrt n)$，足以通过此题。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define repn(x) rep(x,1,n)
#define repm(x) rep(x,1,m)
#define pb push_back
#define E(x) for(auto y:p[x])
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57)s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(ll x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
const int N =1e5+5,M=5e5+5;
using namespace std;
int n=read(),m=read(),a[N],out[M],siz;
int ct[510][510];
struct node{
    int x,y,m,k,id;
};
vector<node>p[N];
#define L(x) (x-1)*340+1
#define R(x) min(x*340,100000)
#define bel(x) (x-1)/340+1
int t[1500],val[N];
inline void add(int x){
    int id=bel(x);
    rep(i,id+1,bel(100000))t[i]++;
    rep(i,x,R(id))val[i]++;
}
inline int query(int x){
    x=min(x,100000);
    if(x<=0)return 0;
    return val[x]+t[bel(x)];
}
signed main(){
    siz=330;
    repn(i)a[i]=read();
    repm(i){
        int l=read(),r=read(),x=read(),y=read(),md=read();
        x%=md,y%=md;
        if(x^y)p[r].pb({x,y,md,1,i}),p[l-1].pb({x,y,md,-1,i});
    }
    repn(i){
        rep(j,1,siz)ct[j][a[i]%j]++;
        add(a[i]);
        E(i)if(y.m<=siz){
            rep(j,0,y.m-1)if((j+y.x)%y.m<(j+y.y)%y.m)out[y.id]+=y.k*ct[y.m][j];
        }
        else {
            int l=0;
            while(l<=100000){
                if(y.x<y.y)out[y.id]+=y.k*(query(l+y.m-1-y.y)+query(l+y.m-1)-query(l-1)-query(l+y.m-y.x-1));
                else out[y.id]+=y.k*(query(l+y.m-1-y.y)-query(l+y.m-y.x-1));
                l+=y.m;
            }
        }
        
    }
    repm(i)pf(out[i]),putchar('\n');
    return 0;
}
```


---

## 作者：lfxxx (赞：3)

显然，我们维护的答案具有 **可差分** 性，所以转换为 $[1,r]$ 上的查询。

首先，对于 $x,y,a_i$ 先对 $m$ 取模不影响结果。

下面为了方便令 $v = a_i$。

如果 $x>y$。

则一定是 $x+v-m<y+v$。

有 $m \leq x+v$ 且 $y+v < m$。

转化为 $m-x \leq v$ 且 $x<m-y$。

得到 $v \in[m-x,m-y-1]$。

如果 $x<y$。

答案为所有情况减去 $x>y$ 的情况。

然后维护 $[1,r]$ 上的答案可以离线扫描一遍。

至此问题转化成维护一个集合，支持插入一个数以及查询 $\bmod m$ 意义下 $\in[m-x,m-y-1]$ 的数的数量。

考虑根号分治。

那么对于 $m \leq \sqrt n$，我们记录所有 $\bmod M = k$($M \leq \sqrt n$) 的数的出现次数，询问就直接回答。插入 $O(\sqrt n)$，查询 $O(\sqrt n)$。

$m > \sqrt n$ 的情况下满足条件的数构成桶上不多于 $\sqrt n$ 个区间，用 $O(1)$ 查询 $O(\sqrt n)$ 修改的值域分块即可。插入 $O(\sqrt n)$，查询 $O(\sqrt n)$。

[如何写值域分块可以参考往期博客讲解](https://www.luogu.com.cn/blog/520748/zhi-yu-fen-kuai-ru-men)

那么就 $O( (n+q) \sqrt n)$ 的做完了。

参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 5e5+114;
struct Node{
	int x,y,M,id,f;//anser[id]+=f*v f = 1 or -1 
};
const int top = 100000;
const int B = 556;
vector<Node> A[maxn];//储存离线询问 
int a[maxn];
int anser[maxn];//输出答案 
struct block{
	int pre[1000];
}cnt[1000];
int cnt_pre[1001];
int ans[1001][1001];
int n,q;
inline void change(int x,int val){
	int sum = x/B;
	x%=B;
	if(x==0) sum--,x+=B;
	for(int i=x;i<=B;i++) {
		cnt[sum].pre[i]+=val;
	}
	for(int i=sum;i<=B;i++) cnt_pre[i]+=val;
}
inline int query(int l,int r){
	if(l>r) return 0;
	int lc=l/B;
	l%=B;
	int rc=r/B;
	r%=B;
	if(l==0) lc--,l+=B;
	if(r==0) rc--,r+=B;
	if(lc==rc) return cnt[lc].pre[r]-cnt[rc].pre[l-1];
	int res=0;
	res+=cnt[lc].pre[B]-cnt[lc].pre[l-1];
	res+=cnt[rc].pre[r];
	res+=cnt_pre[rc-1]-cnt_pre[lc];
	return res;
}
void set_add(int x){//向集合中插入 x 
	change(x,1);
	for(int j=1;j<B;j++){
		ans[j][x%j]++;
	}
}
inline int set_pre(int m,int k){//mod m 意义下小于等于 k 的数的数量 
	if(k<0) return 0;
	if(m<B)
	{
		int sum=0;
		for(int j=0;j<=k;j++){
			sum+=ans[m][j];
		}
		return sum;
	}
	else{
		int l=m,r=m+k,res=query(1,k);
		while(r<top){
			res+=query(l,r);
			l+=m;
			r+=m;
		}
		if(l<=top)
			res+=query(l,top);
		return res;
	}
}
inline int set_query(int m,int l,int r){//mod m \in [l,r]
	if(l>r||l<0||r<0) return 0;
	return set_pre(m,r)-set_pre(m,l-1);
}
void scan(){
	for(int i=1;i<=n;i++){
		set_add(a[i]);
		for(int j=0;j<A[i].size();j++){
			Node now = A[i][j];
			//处理询问 now
			if(now.x%now.M==now.y%now.M){
				anser[now.id]+=now.f*0;
			}
			else if(now.x%now.M>now.y%now.M){
				int l=now.M-now.x%now.M,r=now.M-now.y%now.M-1;
				anser[now.id]+=now.f*set_query(now.M,l,r);
			}
			else{
				int l=now.M-now.y%now.M,r=now.M-now.x%now.M-1;
				anser[now.id]+=now.f*(i-set_query(now.M,l,r));
			}
			
		}
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>q;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=q;i++){
		int l,r,x,y,m;
		cin>>l>>r>>x>>y>>m;
		Node R,L;
		R.f=1;
		R.id=i;
		R.M=m;
		R.x=x;
		R.y=y;
		A[r].push_back(R);
		L.f=-1;
		L.id=i;
		L.M=m;
		L.x=x;
		L.y=y;
		A[l-1].push_back(L);
	}//询问离线
	scan();
	for(int i=1;i<=q;i++) cout<<anser[i]<<'\n';
}
```


---

## 作者：wangzhiyuan123 (赞：3)

考虑扫描线，把每个询问分成 $[1,r]$ 和 $[1,l-1]$ 两个区间查询。   
对于每个查询考虑根号分治。    
对于 $m \le \sqrt n$ 的情况，维护 $\sqrt n$ 个桶，第 $i$ 个桶的第 $j$ 个表示有多少个数 $k$ 满足 $k \equiv j \pmod i$，对于每个查询直接暴力统计，每个修改直接枚举 每个桶修改即可。    
对于 $m>\sqrt n$ 的情况，枚举 $\lceil\dfrac{n}{m}\rceil$，显然不同的 $\lceil\dfrac{n}{m}\rceil$ 不会超过 $\sqrt n$ 个，对于每个 $\lceil\dfrac{n}{m}\rceil$ 可能产生贡献的显然是一段区间。我们维护一个 $O(\sqrt n)$ 修改，$O(1)$ 查询的分块前缀和。
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    int w=0;char ch=getchar();
    while(!isdigit(ch)) ch=getchar();
    while(isdigit(ch)) w=w*10+ch-'0',ch=getchar();
    return w;
}
int n,q;
vector<int> qid[100005],qs[100005];
int a[100005];
int qx[500005],qy[500005],qm[500005];
int ans[500005];
int sz,zs=320;
int fk[505][505];
int qzhb[505],qzhd[505][505];
void add(int x){
    int bl=x/zs+1,tl=x%zs;
    for(int i=tl;i<zs;i++) qzhd[bl][i]++;
    for(int i=bl;i<=(100000)/zs+1;i++) qzhb[i]++; 
}
int query(int x){
    int bl=x/zs+1,tl=x%zs;
    return qzhb[bl-1]+qzhd[bl][tl];
}
//分块维护前缀和
int solve(int x,int y,int m){
    int l=m-x,r=m-y-1,as=0;
    if(m<sz){
        for(int i=l;i<=r;i++) as+=fk[m][i];//小于根号暴力统计
        return as;
    }
    for(int i=1,nl=l,nr=r;nl<=100000;nl+=m,nr=min(nr+m,100000)){
        as+=query(nr)-query(nl-1);
        //枚举n/m
    }
    return as;
}
main(){
    n=read(),q=read();sz=sqrt(n);
    for(int i=1;i<=n;i++) a[i]=read();
    for(int i=1,l,r;i<=q;i++){
        l=read(),r=read(),qx[i]=read(),qy[i]=read(),qm[i]=read();
        qx[i]%=qm[i],qy[i]%=qm[i];
        if(qx[i]==qy[i]) continue;
        qid[l-1].push_back(i);qs[l-1].push_back(-1);
        qid[r].push_back(i);qs[r].push_back(1);
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<sz;j++) fk[j][a[i]%j]++;//暴力修改小于根号的桶
        add(a[i]);
        for(int j=0;j<qid[i].size();j++){
            int uid=qid[i][j],op=qs[i][j];
            int as=solve(max(qx[uid],qy[uid]),min(qx[uid],qy[uid]),qm[uid]);
            if(qx[uid]<qy[uid]) as=i-as;
            ans[uid]+=as*op;
        }
    }
    for(int i=1;i<=q;i++){
        if(qx[i]==qy[i]) puts("0");
        else printf("%d\n",ans[i]);
    }
}
```


---

## 作者：honglan0301 (赞：2)

## 题目分析

很不错，题意非常的简洁。

记值域为 $V$。首先容易想到暴力枚举 $m$，只需要离线下来对模 $m$ 的余数开桶即可做到 $O(nV+qV)$，这虽然不足以通过 $10^5$ 的值域，但它提示我们本题可能可以根号分治。于是先对 $m\leq B$ 做以上暴力，时间复杂度 $O((n+q)B)$，下面考虑 $m>B$ 的情况。

我们转化 $(a_i+x)\bmod m<(a_i+y)\bmod m$ 这个东西。在模 $m$ 的剩余系中考虑，发现这等价于当 $x\geq y$ 时，要求 $a_i∈[m-x,m-y)$，否则要求 $a_i∈[0,m-y) \cup [m-x,m)$，即 $a_i \bmod m$ 的取值范围只有一或两个区间。

于是又因为 $m>B$，我们暴力枚举 $\lfloor {a_i\over m} \rfloor$，发现只需要进行至多 $qV\over B$ 次询问 $a_{l\dots r}$ 里值位于 $[u,v]$ 的数的个数即可。而这样一次询问的答案 $ans(l,r,u,v)=ans(1,r,u,v)-ans(1,l-1,u,v)=ans(1,r,1,v)-ans(1,r,1,u-1)-(ans(1,l-1,1,v)-ans(1,l-1,1,u-1))$。那么离线下来，转化为 $O(n)$ 次插入，$O({qV\over B})$ 次查询前缀和，想到使用分块平衡时间复杂度，记录块间的前缀和与块内的前缀和，块长为 $B'$，单次插入 $O(B'+{V\over B'})$，单次查询 $O(1)$，于是这部分的时间复杂度 $O(nB'+{nV\over B'}+{qV\over B})$。

那么就做完了，取 $B=B'=\sqrt V$，总时间复杂度 $O((n+q)\sqrt V)$，常数不大，代码好写，可以通过本题。

## 代码

```cpp
/*
  author: PEKKA_l  
*/
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>
#include <vector>
using namespace std;

#define B 365

int n,q,a[100005],u[500005],v[500005],x[500005],y[500005],mod[500005],ans[500005],cnt[375];
vector <pair<int,pair<int,int>>> cz[375];
bool cmp1(pair<int,pair<int,int>> xx,pair<int,pair<int,int>> yy) {return xx.second.first<yy.second.first;}

#define BB 325
#define K(x) ((x-1)/BB+1)

int sumk[355],sum[100005];
vector <pair<int,int>> cz2[100005];

void insert(int x) {for(int j=K(x);j<=BB;j++) sumk[j]++; for(int j=x;j<=min(100000,BB*K(x));j++) sum[j]++;}
int ask(int x) {x=max(x,0); x=min(x,100000); return sumk[K(x)-1]+sum[x];}

signed main()
{
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin>>n>>q; for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=q;i++)//根号分治
	{
		cin>>u[i]>>v[i]>>x[i]>>y[i]>>mod[i]; x[i]%=mod[i]; y[i]%=mod[i];
		if(mod[i]>B) {cz2[u[i]-1].push_back(make_pair(i,-1)); cz2[v[i]].push_back(make_pair(i,1));}
		else {cz[mod[i]].push_back(make_pair(i,make_pair(u[i]-1,-1))); cz[mod[i]].push_back(make_pair(i,make_pair(v[i],1)));}
	}
	for(int i=1;i<=B;i++)//暴力1：枚举m
	{
		memset(cnt,0,sizeof(cnt)); sort(cz[i].begin(),cz[i].end(),cmp1); int nit=0;
		for(int j=1;j<=n;j++)
		{
			cnt[a[j]%i]++; while(nit<cz[i].size()&&cz[i][nit].second.first<j) nit++;
			while(nit<cz[i].size()&&cz[i][nit].second.first==j)
			{
				int nans=0; for(int k=0;k<i;k++) if((k+x[cz[i][nit].first])%i<(k+y[cz[i][nit].first])%i) nans+=cnt[k];
				ans[cz[i][nit].first]+=cz[i][nit].second.second*nans; nit++;
			}
		}
	}
	for(int i=1;i<=n;i++)//暴力2：询问前缀和
	{
		insert(a[i]); for(auto j:cz2[i])
		{
			int nans=0;
			for(int k=0;k<=100000;k+=mod[j.first])
			{
				if(x[j.first]<y[j.first]) {nans+=ask(k+mod[j.first]-y[j.first]-1)-ask(k-1); nans+=ask(k+mod[j.first]-1)-ask(k+mod[j.first]-x[j.first]-1);}
				else if(x[j.first]>y[j.first]) nans+=ask(k+mod[j.first]-y[j.first]-1)-ask(k+mod[j.first]-x[j.first]-1);
			}
			ans[j.first]+=j.second*nans;
		}
	}
	for(int i=1;i<=q;i++) cout<<ans[i]<<"\n";
}
```


---

## 作者：Nagisa_Tomoya (赞：2)

一个挺典的根号分治题。

首先考虑将询问关于 $m$ 分治，不妨设值域为 $A$。

首先若 $m$ 小于等于 $B$ 的话直接把相同的 $m$ 归一起，然后直接扫描线即可，复杂度 $O(nB +qB)$。

若 $m$ 大于 $B$ 的话不难发现，满足条件的值域区间个数最多只有 $\frac{A}{B}$ 个，那么我们先扫描线一下，然后就把问题转化为每次操作单点加，多次区间求和了。

然后我们发现可以先对值域分块，那么每次询问总共跨过的块是很少的。然后可以平衡一下复杂度，在单点加的时候维护块内前缀和，然后查询的时候直接查即可。

设值域分块块长为 $\sqrt{A}$，那么时间复杂度为 $O(nB + qB + n\sqrt{A} + q\sqrt{A} + q\frac{A}{B})$。

因为 $q$ 比较大，所以 B 直接取 $\sqrt{A}$ 即可。

常数不大，随便过。

```cpp
/*
60 + 0 + 100 + 64 = 224.
*/

//#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native")
#include <bits/stdc++.h>
using namespace std;
//#define int long long
inline int read()
{
	int sum = 0, nega = 1;
	char ch = getchar();
	while (ch > '9'||ch < '0')
	{
	    if (ch == '-') nega = -1;
		ch = getchar();
	}
	while (ch <= '9' && ch >= '0') sum = sum * 10 + ch - '0', ch = getchar();
	return sum * nega;
}
const int N = 5e5 + 9, M = 1e3 + 9; 
int n, Q, B, mxa;
struct Query
{
	int l, r, x, y, m, id;
};
inline bool cmp(Query x, Query y) {return x.l < y.l;}
vector<Query> q[N], G;
int ans[N], a[N], sum[N];
int tag[N], L[N], R[N], su[N]; 
inline void build() 
{
	for (int i = 1; i <= mxa; i++) tag[i] = (i - 1) / B + 1; 
	for (int l = 1, r; l <= mxa; l = r + 1) r = min(mxa, l + B - 1), L[tag[l]] = l, R[tag[r]] = r;
	return ; 
}
inline void update(int x) 
{
	for (int i = x; i <= R[tag[x]]; i++) su[i]++; 
	return ;
}
inline int query(int l, int r) 
{
	if(tag[l] == tag[r]) 
	{
		if(l == L[tag[l]]) return su[r]; 
		else return su[r] - su[l - 1]; 
	}
	int res = 0;
	if(l != L[tag[l]]) res -= su[l - 1];
	res += su[R[tag[l]]]; res += su[r]; 
//	if(l == 1 && r == 6) cout << res << "qwq" << endl;
	for (int i = tag[l] + 1; i < tag[r]; i++) res += su[R[i]];
	return res;
}
inline void work1(int x) 
{
	G.clear(); 
	for (int i = 0; i < x; i++) sum[i] = 0;
	for (auto v : q[x]) 
	{
		G.push_back(Query{v.l - 1, -1, v.x, v.y, v.m, v.id});
		G.push_back(Query{v.r, 1, v.x, v.y, v.m, v.id});
	}
	sort(G.begin(), G.end(), cmp); int lst = 0;
	for (auto v : G) 
	{
		for (int i = lst + 1; i <= v.l; i++) sum[a[i] % x]++; 
		for (int i = 0; i < x; i++) 
			if((i + v.x) % x < (i + v.y) % x) ans[v.id] += v.r * sum[i];
		lst = v.l;
	} return ;
} 
inline void work2(int x) 
{
	G.clear(); build();
	for (auto v : q[x]) 
	{
		G.push_back(Query{v.l - 1, -1, v.x, v.y, v.m, v.id});
		G.push_back(Query{v.r, 1, v.x, v.y, v.m, v.id});
	}
	sort(G.begin(), G.end(), cmp); int lst = 0;
	for (auto v : G) 
	{
		for (int i = lst + 1; i <= v.l; i++) update(a[i]);
		int le = (v.m - v.x) % v.m; 
		int len = (v.m * 2 - le - v.y) % v.m; 
		for (int i = le - v.m; i <= mxa; i += v.m) 
		{
			int l = max(i, 1), r = min(mxa, i + len - 1);
			if(l > r) continue;
			ans[v.id] += v.r * query(l, r); 
		//	cout << l << " " << r << " " << endl;
		} 
		lst = v.l;
	//	cout << lst << " " << query(1, 2) << " " << query(3, 4) << " " << query(5, 6) << "qwq" << endl;
	}
	return ;
}
signed main()
{
	n = read(), Q = read(), B = n; 
	for (int i = 1; i <= n; i++) a[i] = read(), mxa = max(mxa, a[i]);
	B = sqrt(mxa);
	for (int i = 1; i <= Q; i++) 
	{ 
		int l = read(), r = read(), x = read(), y = read(), tt = read(); x %= tt, y %= tt;
		if(x != y) q[min(tt, B + 1)].push_back(Query{l, r, x, y, tt, i});
	}
	for (int i = 1; i <= B; i++) work1(i);
	work2(B + 1);
	for (int i = 1; i <= Q; i++) printf("%d\n", ans[i]);
	return 0;
}

 
```


---

## 作者：DeepSeaSpray (赞：0)

# LGP9212 「蓬莱人形」

对于每一个询问，先对 $x$，$y$，$a_i$ 取模。

然后对 $x$，$y$ 分类讨论：

- $x = y$ 答案为 $0$。
- $x > y$ 即，$a_i+x$ 取模，$a_i+y$ 不取模。等价于 $a_i \in [m-x,m-y-1]$。
- $x < y$ 等价于 $x > y$ 的反面，像上一种情况计算，然后用总个数减去答案即可。

然后由于答案的可差分性，$[l,r]$ 可以拆分成 $[1,l-1]$ 和 $[1,r]$ 两个区间的询问。

现在我们考虑从前往后扫 $a$，维护每一个询问。

我们考虑对 $m$ 根号分治。

## 当 $m \leq \sqrt n$ 时：

需要对于每一个 $m \leq \sqrt n$ 支持单点修改，对于每一个询问支持区间查询。

共 $O(n \sqrt n)$ 次修改，$O(n)$ 次查询。

平衡时间复杂度，可以使用数组做到 $O(1)$ 修改，$O(\sqrt n)$ 查询。

## 当 $m > \sqrt n$ 时：

难点在于 $a_i$ 的取模。

我们可以 $a_i$ 不变，区间同时不断增大 $m$，这样统计是等价的。

需要支持单点修改，区间查询。

同时我们发现这样查询的次数时是 $O(n \sqrt n)$ 的，修改的次数是 $O(n)$。

平衡时间复杂度，使用一个 $O(\sqrt n)$ 修改，$O(1)$ 查询的值域分块即可。

### 细说分块：

我们维护所有块的前缀和与块内的前缀和即可。

块长 $\sqrt n$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5;
const int maxm=5e5;
const int B=320;
struct Node{
	int l,r,p,id;
	Node(int il,int ir,int ip,int iid){
		l=il,r=ir,p=ip,id=iid;
	}
	Node(){}
};
int n,q;
int a[maxn+5];
int ans[maxm+5];
int len[maxm+5];
vector<Node> V[maxn+5];
int f[B+5][B+5];
int id[maxn+5];
int L[B+5],R[B+5];
int c[maxn+5];
int s[B+5];
inline void Build(){
	for(int i=1;i<=maxn;i++){
		id[i]=i/B;
		if(!L[id[i]]) L[id[i]]=i;
		R[id[i]]=i;
	}
}
inline void Modify(int x){
	for(int i=id[x];i<=B;i++) s[i]++;
	for(int i=x;i<=R[id[x]];i++) c[i]++;
}
inline int Query(int x){
	return (id[x]?s[id[x]-1]:0)+c[x];
}
signed main(){
	int l,r,x,y,p;
	int tmp;
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=q;i++){
		scanf("%d%d%d%d%d",&l,&r,&x,&y,&p);
		x%=p,y%=p;
		if(x==y) continue;
		if(x<y) len[i]=r-l+1,swap(x,y);
		V[l-1].push_back(Node(p-x,p-y-1,p,-i));
		V[r].push_back(Node(p-x,p-y-1,p,i));
	}
	Build();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=B;j++) f[j][a[i]%j]++;
		Modify(a[i]);
		for(Node j:V[i]){
			tmp=0;
			if(j.p<=B) for(int k=j.l;k<=j.r;k++) tmp+=f[j.p][k];
			else for(int k=0;k+j.l<=maxn;k+=j.p)
				tmp+=Query(min(k+j.r,maxn))-Query(k+j.l-1);
			if(j.id<0) ans[-j.id]-=tmp;
			else ans[j.id]+=tmp;
		}
	}
	for(int i=1;i<=q;i++){
		if(len[i]) printf("%d\n",len[i]-ans[i]);
		else printf("%d\n",ans[i]);
	}
	return 0;
}
```

---

## 作者：DengDuck (赞：0)

以后要记得根号分治题要调小阈值看另外一种方法跑的对不对。

这题想法挺简单的。

不难想到离线，把问题变成 $[1,R]$ 中询问形式，然后我们从左往右做，每次加入一个数字。

我们求出 $x\gets x\bmod M$，$y\gets y\bmod M$，然后考虑 $A_i$ 满足题目中的条件需要满足什么条件，不妨设 $x<y$（反过来你就整体减空白，交换 $x,y$ 就行）：

$$
[A_i+x,A_i+y]\subset [kM,kM+M)\ (k\in \Z)\\
\Rightarrow A_i\in [kM-x,kM+M-y)\ (k\in \Z)
$$

那么我们自然的想法是查询这样的一块值域中有多少数字，用值域分块单次插入可以做到 $\mathcal O(\sqrt n)$，单次查询可以做到 $\mathcal O(1)$，那么有多少个区间呢？大约是 $\dfrac N M$ 个，这个经典的形式让我们想到根号分治。

- $M>B$，直接查询所有区间的区间和，时间复杂度 $\mathcal  O(\dfrac N B)$。
- $M\leq B$，这个做法不太行了。
  - 容易想到 $A_i\bmod M$ 的取值只有 $M$ 个这么多，所以我们直接对于每一种取值统计答案。
  - 我们处理出当前的所有数字在所有 $M\leq B$ 的模数中所有余数的出现数量。
  - 时间复杂度是 $\mathcal O(B)$ 的。

$B=\sqrt n$，则时间复杂度是 $\mathcal O((n+q)\sqrt n)$ 的。

细节可以看看代码。

```cpp
#include<bits/stdc++.h>
#define pb push_back
using namespace std;
const int B=400;
const int N=1e5+5;
struct Query{int x,y,m,Id,k;};
vector<Query>Qr[N];
int n,m,A[N],S[B+5][B+5],Sum[B+5],Hav[B+5][B+5],Ans[N*5];
inline void Ins(int x)
{
	for(int i=x%B;i<B;i++)S[x/B][i]++;
	for(int i=x/B;i<=n/B;i++)Sum[i]++;
	for(int i=1;i<=B;i++)Hav[i][x%i]++;
}
inline int Qry(int x)
{
	if(x<=0)return 0;
	if(x>N-5)x=N-5;
	int Ans=0;
	if(x/B>0)Ans+=Sum[x/B-1];
	Ans+=S[x/B][x%B];
	return Ans;
}
inline int Qry(int L,int R){return Qry(R)-Qry(L-1);}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",&A[i]);
	for(int i=1,l,r,x,y,M;i<=m;i++)
	{
		scanf("%d%d%d%d%d",&l,&r,&x,&y,&M);
		Qr[r].pb({x,y,M,i,1});
		Qr[l-1].pb({x,y,M,i,-1});
	}
	for(int i=1;i<=n;i++)
	{
		Ins(A[i]);
		for(Query t:Qr[i])
		{
			int M=t.m,x=t.x,y=t.y,Cnt=0;
			x%=M,y%=M;
			if(x==y)continue;
			if(M<=B)
			{
				for(int j=0;j<M;j++)
					if((j+x)%M<(j+y)%M)Cnt+=Hav[M][j];
			}
			else
			{
				int Flg=0;
				if(x>y)swap(x,y),Flg=1;
				for(int k=0;k*M-x<=N-5;k++)
					Cnt+=Qry(k*M-x,(k+1)*M-y-1);
				if(Flg)Cnt=i-Cnt;
			}
			Ans[t.Id]+=t.k*Cnt;
		}
	}
	for(int i=1;i<=m;i++)printf("%d\n",Ans[i]);
}
```

---


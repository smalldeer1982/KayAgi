# 【MX-J8-T4】2048

## 题目背景

原题链接：<https://oier.team/problems/J8D>。

---

[《2048》](https://2048game.com/)是一款非常好玩，火爆全球的小游戏。

## 题目描述

现在，小 Y 把《2048》稍做修改，得到如下的一维变种（其中部分规则可能与你对《2048》的印象相悖，请以下文为准）：

- 游戏在一行 $n$ 个格子组成的网格中进行。每个格子要么为空，要么包含一个带有正整数权值的方块。
- 游戏开始时，会在一个任意的格子上生成一个权值为 $2$ 的方块，其他格子为空。
- 玩家通过向左（或右，下同）滑动进行操作。每次操作：
  1. 所有方块将全部靠左（或右）堆叠放置，彼此紧贴，不留空位。
  2. 如果堆叠完毕后，存在相邻的两个方块权值相等，设其权值均为 $k$，则消除这两个方块，并在原先其中一个方块的位置生成一个权值为 $2k$ 的方块（这称作一次合并）（**可以证明，在该游戏过程中不会存在连续 $\bm 3$ 个相邻方块权值相等，因此不需要考虑合并顺序的问题**），随后所有方块继续向左（或右）堆叠，直到不存在能合并的情况为止。
  3. 最后，在最右（或左）端，即滑动方向的相反方向，生成一个权值为 $2$ 的新方块。

下图展示了一次向左滑动操作的示例。

![](https://cdn.luogu.com.cn/upload/image_hosting/d7qp6f1i.png)

- 如下定义一个方块的**出现时间**：
  - 设它被生成时，游戏进行的轮数（即玩家进行滑动操作的次数）为 $i$（包括当前操作）。
  - 如果该方块是被合并生成的，令它的出现时间为 $2 i$；
  - 否则该方块是新生成的，令它的出现时间为 $2 i + 1$；
  - 如果该方块是游戏最开始时生成的权值为 $2$ 的方块，令它的出现时间为 $1$。
  - 可以证明，按如上定义的出现时间满足：在游戏进行的任意时刻下，任意两个不同方块的出现时间均不同。
- 游戏的目标是生成 $2^x$，因此在游戏的任何过程中，一旦出现了 $2^x$，游戏立刻结束，且游戏胜利。
- 如果一次滑动操作的步骤 2 结束时，所有 $n$ 个格子全都包含方块（事实上，这次滑动操作是滑不动的，但仍然认为是一次滑动操作），则步骤 3 中无法正常生成新方块，不会进行步骤 3，且游戏失败。

小 Y 正在研究这个新 2048 游戏的所有失败状态的个数。具体地，在游戏失败时，两个失败状态 A 和 
B 被认为**本质相同**，当且仅当以下条件同时成立：

- 对每个 $1 \leq i \leq n$，A 中方块 $i$ 和 B 中方块 $i$ 的权值均相同；
- 对每对 $1 \le i < j \le n$，A 中的方块 $i$ 与方块 $j$ 的出现时间的大小关系，与 B 中的方块 $i$ 与方块 $j$ 的出现时间的大小关系相同。

小 Y 想要知道，总共有多少种**本质不同**的失败状态。答案对给定模数 $p$ 取模（$p$ 未必为素数）。

## 说明/提示

**【样例解释 \#1】**

对于第一组数据，$n = 3$，$x = 4$：
- 仅从网格状态上看，共有 $6$ 种失败的可能性：$[8, 4, 2], [2, 4, 8], [2, 8, 4], [4, 8, 2], [2, 8, 2],[2, 4, 2]$。
  - 但考虑 $[2, 8, 2]$，其可以对应两种本质不同的失败状态：
    - 中间的 $8$ 先被生成，随后左边的 $2$ 生成，随后右边的 $2$ 生成；
    - 中间的 $8$ 先被生成，随后右边的 $2$ 生成，随后左边的 $2$ 生成。
  - 对于 $[2, 4, 2]$ 也是同理。
- 对于其它的可能性，可以证明其只能对应一种本质不同的失败状态。
- 所以，答案为 $1 + 1 + 1 + 1 + 2 + 2 = 8$，在模 $71$ 意义下为 $8$。

对于第二组数据，$n = 4$，$x = 3$：
- 可以证明，无论如何，游戏都将胜利，因此不存在任何失败状态，答案为 $0$。

对于第三组数据，$n = 4$，$x = 4$：
- 仅从网格状态上看，共有 $4$ 种失败的可能性：$[2, 8, 4, 2], [2, 4, 8, 2], [4, 8, 4, 2],[2, 4, 8, 4]$。
- 其中，$[2, 8, 4, 2]$ 和 $[2, 4, 8, 2]$ 分别对应 $4$ 种本质不同的失败情况，$[4, 8, 4, 2]$ 和 $[2, 4, 8, 4]$ 分别对应 $2$ 种本质不同的失败情况。
  - 以 $[2, 8, 4, 2]$ 为例，下面列举该局面对应的 $4$ 种本质不同的失败情况（操作方式不唯一，数字上面的小数字表示出现时间）：
    $$ \begin{aligned} & [\overset{\hspace{15.385mu}}{}, \overset{\hspace{3.84625mu}1\hspace{3.84625mu}}{2}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{15.385mu}}{}] & & [\overset{\hspace{15.385mu}}{}, \overset{\hspace{3.84625mu}1\hspace{3.84625mu}}{2}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{15.385mu}}{}] & & [\overset{\hspace{15.385mu}}{}, \overset{\hspace{3.84625mu}1\hspace{3.84625mu}}{2}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{15.385mu}}{}] & & [\overset{\hspace{15.385mu}}{}, \overset{\hspace{3.84625mu}1\hspace{3.84625mu}}{2}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{15.385mu}}{}] \\ \stackrel{\text{L}}\to& [\overset{\hspace{3.84625mu}1\hspace{3.84625mu}}{2}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{3.84625mu}3\hspace{3.84625mu}}{2}] & \stackrel{\text{L}}\to& [\overset{\hspace{3.84625mu}1\hspace{3.84625mu}}{2}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{3.84625mu}3\hspace{3.84625mu}}{2}] & \stackrel{\text{L}}\to& [\overset{\hspace{3.84625mu}1\hspace{3.84625mu}}{2}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{3.84625mu}3\hspace{3.84625mu}}{2}] & \stackrel{\text{L}}\to& [\overset{\hspace{3.84625mu}1\hspace{3.84625mu}}{2}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{3.84625mu}3\hspace{3.84625mu}}{2}] \\ \stackrel{\text{L}}\to& [\overset{\hspace{3.84625mu}4\hspace{3.84625mu}}{4}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{3.84625mu}5\hspace{3.84625mu}}{2}] & \stackrel{\text{L}}\to& [\overset{\hspace{3.84625mu}4\hspace{3.84625mu}}{4}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{3.84625mu}5\hspace{3.84625mu}}{2}] & \stackrel{\text{L}}\to& [\overset{\hspace{3.84625mu}4\hspace{3.84625mu}}{4}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{3.84625mu}5\hspace{3.84625mu}}{2}] & \stackrel{\text{R}}\to& [\overset{\hspace{3.84625mu}5\hspace{3.84625mu}}{2}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{3.84625mu}4\hspace{3.84625mu}}{4}] \\ \stackrel{\text{L}}\to& [\overset{\hspace{3.84625mu}4\hspace{3.84625mu}}{4}, \overset{\hspace{3.84625mu}5\hspace{3.84625mu}}{2}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{3.84625mu}7\hspace{3.84625mu}}{2}] & \stackrel{\text{L}}\to& [\overset{\hspace{3.84625mu}4\hspace{3.84625mu}}{4}, \overset{\hspace{3.84625mu}5\hspace{3.84625mu}}{2}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{3.84625mu}7\hspace{3.84625mu}}{2}] & \stackrel{\text{L}}\to& [\overset{\hspace{3.84625mu}4\hspace{3.84625mu}}{4}, \overset{\hspace{3.84625mu}5\hspace{3.84625mu}}{2}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{3.84625mu}7\hspace{3.84625mu}}{2}] & \stackrel{\text{L}}\to& [\overset{\hspace{3.84625mu}5\hspace{3.84625mu}}{2}, \overset{\hspace{3.84625mu}4\hspace{3.84625mu}}{4}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{3.84625mu}7\hspace{3.84625mu}}{2}] \\ \stackrel{\text{L}}\to& [\overset{\hspace{3.84625mu}8\hspace{3.84625mu}}{8}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{3.84625mu}9\hspace{3.84625mu}}{2}] & \stackrel{\text{L}}\to& [\overset{\hspace{3.84625mu}8\hspace{3.84625mu}}{8}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{3.84625mu}9\hspace{3.84625mu}}{2}] & \stackrel{\text{R}}\to& [\overset{\hspace{3.84625mu}9\hspace{3.84625mu}}{2}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{3.84625mu}8\hspace{3.84625mu}}{8}] & \stackrel{\text{L}}\to& [\overset{\hspace{3.84625mu}5\hspace{3.84625mu}}{2}, \overset{\hspace{3.84625mu}4\hspace{3.84625mu}}{4}, \overset{\hspace{3.84625mu}7\hspace{3.84625mu}}{2}, \overset{\hspace{3.84625mu}9\hspace{3.84625mu}}{2}] \\ \stackrel{\text{L}}\to& [\overset{\hspace{3.84625mu}8\hspace{3.84625mu}}{8}, \overset{\hspace{3.84625mu}9\hspace{3.84625mu}}{2}, \overset{\hspace{15.385mu}}{}, \overset{11}{2}] & \stackrel{\text{L}}\to& [\overset{\hspace{3.84625mu}8\hspace{3.84625mu}}{8}, \overset{\hspace{3.84625mu}9\hspace{3.84625mu}}{2}, \overset{\hspace{15.385mu}}{}, \overset{11}{2}] & \stackrel{\text{L}}\to& [\overset{\hspace{3.84625mu}9\hspace{3.84625mu}}{2}, \overset{\hspace{3.84625mu}8\hspace{3.84625mu}}{8}, \overset{\hspace{15.385mu}}{}, \overset{11}{2}] & \stackrel{\text{L}}\to& [\overset{\hspace{3.84625mu}5\hspace{3.84625mu}}{2}, \overset{10}{8}, \overset{\hspace{15.385mu}}{}, \overset{11}{2}] \\ \stackrel{\text{L}}\to& [\overset{\hspace{3.84625mu}8\hspace{3.84625mu}}{8}, \overset{12}{4}, \overset{\hspace{15.385mu}}{}, \overset{13}{2}] & \stackrel{\text{R}}\to& [\overset{13}{2}, \overset{\hspace{15.385mu}}{}, \overset{\hspace{3.84625mu}8\hspace{3.84625mu}}{8}, \overset{12}{4}] & \stackrel{\text{L}}\to& [\overset{\hspace{3.84625mu}9\hspace{3.84625mu}}{2}, \overset{\hspace{3.84625mu}8\hspace{3.84625mu}}{8}, \overset{11}{2}, \overset{13}{2}] & \stackrel{\text{L}}\to& [\overset{\hspace{3.84625mu}5\hspace{3.84625mu}}{2}, \overset{10}{8}, \overset{11}{2}, \overset{13}{2}] \\ \stackrel{\text{R}}\to& [\overset{15}{2}, \overset{\hspace{3.84625mu}8\hspace{3.84625mu}}{8}, \overset{12}{4}, \overset{13}{2}] & \stackrel{\text{L}}\to& [\overset{13}{2}, \overset{\hspace{3.84625mu}8\hspace{3.84625mu}}{8}, \overset{12}{4}, \overset{15}{2}] & \stackrel{\text{L}}\to& [\overset{\hspace{3.84625mu}9\hspace{3.84625mu}}{2}, \overset{\hspace{3.84625mu}8\hspace{3.84625mu}}{8}, \overset{14}{4}, \overset{15}{2}] & \stackrel{\text{L}}\to& [\overset{\hspace{3.84625mu}5\hspace{3.84625mu}}{2}, \overset{10}{8}, \overset{14}{4}, \overset{15}{2}] \end{aligned} $$
    对这 $4$ 种情况，出现时间的大小关系（离散化后）分别为 $[4, 1, 2, 3]$、$[3, 1, 2, 4]$、$[2, 1, 3, 4]$、$[1, 2, 3, 4]$。
- 所以，答案为 $4 + 4 + 2 + 2 = 12$，在模 $71$ 意义下为 $12$。

对于第四组数据，$n = 4$，$x = 5$：
- 可以证明答案为 $34$，在模 $71$ 意义下为 $34$。

对于第五组数据，$n = 5$，$x = 6$：
- 可以证明答案为 $162$，在模 $71$ 意义下为 $20$。

**【样例 \#2】**

见附件中的 `game/game2.in` 与 `game/game2.ans`。

该组样例满足测试点 $3 \sim 5$ 的约束条件。

**【样例 \#3】**

见附件中的 `game/game3.in` 与 `game/game3.ans`。

该组样例满足测试点 $6 \sim 10$ 的约束条件。

**【样例 \#4】**

见附件中的 `game/game4.in` 与 `game/game4.ans`。

该组样例满足测试点 $14 \sim 17$ 的约束条件。

**【样例 \#5】**

见附件中的 `game/game5.in` 与 `game/game5.ans`。

该组样例满足测试点 $22 \sim 25$ 的约束条件。

**【数据范围】**

本题共 $25$ 个测试点，每个 $4$ 分。

|测试点编号|$T \le$|$n,x \le$|特殊性质|
| :-----------: | :-------------:|:-----------:|:-----------: |
|$1\sim2$|$10$|$4$|无
|$3\sim5$|$10$|$10$|无
|$6\sim10$|$10$|$22$|无
|$11\sim13$|$1$|$80$|无
|$14\sim17$|$1000$|$80$|无
|$18\sim20$|$1$|$300$|无
|$21$|$10^5$|$300$| $p = 2$ |
|$22\sim25$|$10^5$|$300$|无


对于全部数据，保证：$1\le T\le 10^5$，$1\le n,x\le 300$，$2\le p\le10^9$。

## 样例 #1

### 输入

```
5 71
3 4
4 3
4 4
4 5
5 6
```

### 输出

```
8
0
12
34
20
```

# 题解

## 作者：ddh123 (赞：11)

~~这是本蒟蒻的第一篇正式题解。~~

本题重点在于找到无解序列的充要条件，首先记 $a_i$ 为游戏结束时第 $i$ 个数取 $2$ 的对数，$t_i$ 为第 $i$ 个数出现时间离散化后的值，显然 $a$ 相邻两项不同，$t$ 是一个排列，如果一个位置比它相邻位置大且出现时间小，直接按照顺序合成即可，如果一个元素比它相邻位置小且出现时间小呢？我们可以先合成较大数的一半再合成较小数，最后合成较大数，具体参考样例解释中 $[2,8,4,2]$ 的第四种情况。

### 一些性质 ###

1. $a$ 是单峰的，$t$ 是单谷的，归纳易证。

2. $a_i+t_i-1 \le n$，这是因为已经有 $t_i-1$ 个位置被占，且第$i$个数至少需要 $a_i$ 个位置才能合成。

3. 若 $t_i<t_{i+1}$，那么 $a_i+1\ne a_{i+1}$，这是因为如果 $a_i+1=a_{i+1}$，那么 $a_{i+1}$ 的合成会影响到 $a_i$ 的合成。同理，若 $t_i<t_{i-1}$，那么 $a_i+1\ne a_{i-1}$。

4. 若 $t_{i-1}<t_i<t_{i+1}$，那么不可能会有 $a_{i-1}<a_i<a_{i+1}$，这是因为如果 $a_{i-1}<a_i<a_{i+1}$，那么首先要合成 $a_{i+1}-1$，然后合成 $a_i-1$，最后合成 $a_{i-1}$，这会使 $a_i-1$ 无法进一步合成出 $a_i$。同理，若 $t_{i-1}>t_i>t_{i+1}$，那么不可能会有 $a_{i-1}>a_i>a_{i+1}$。

我们容易发现，这些性质已经充要，我们来考虑如何 dp。

### DP ###

考虑到性质 1 和性质 4，可以发现出现时间最小的位置只能是 $a$ 中最大的位置或这个位置的相邻两个位置，也就是下图中红框框住的点。也就是说出现时间最小的位置的两边元素大小分别是单增和单减，因此我们可以按照出现时间从大到小进行转移。

![](https://cdn.luogu.com.cn/upload/image_hosting/sk1ytubd.png)

设 $F_{i,L,R}$ 表示已经有 $i$ 个数确定，其中左块最右边的数是 $L$，右块最左边的数是 $R$，首先考虑 $L$ 与 $R$ 的范围。假设格子总数是 $m$，第 $j$ 个转移的数大小为 $x$，根据性质 2 有：$x+m-j\le m $，也就是 $x\le j$，因此有 $L\le i$，$R\le i$。转移方程为：$F_{i,L,R}=(\sum_{[tl\lt L]}F_{i-1,tl,R} )+(\sum_{[tr\lt R]}F_{i-1,L,tr} )$，这个东西可以用前缀和优化，贡献答案时差分即可，时间复杂度 $O(300^3+T)$。




### AC Code ###
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,mod,n,x,dp[305][305][305],f[305][305][305],g[305][305][305],sum[305][305];
void add(int &x,int y){
	(x+=y)%=mod;
}
void fun(int n,int lx,int rx,int res){//计算贡献
	add(sum[n][lx],res),add(sum[n][rx+1],mod-res);
}
int main(){
	scanf("%d%d",&T,&mod);
	dp[0][0][0]=g[0][0][0]=f[0][0][0]=1,fun(1,1,1,1);
	for(int i=1;i<300;i++)
		for(int j=0;j<=i;j++)
			for(int k=0;k<=i;k++)if(j+k){
				if(j)add(dp[i][j][k],f[i-1][j-1][k]);
				if(k)add(dp[i][j][k],g[i-1][j][k-1]);
				f[i][j][k]=g[i][j][k]=dp[i][j][k],fun(i+1,max(j,k)+1,i+1,dp[i][j][k]);
				if(j+1<=k-2)fun(i+1,k,k,dp[i][j][k]*2LL*((k-2)-(j+1)+1)%mod);   //考虑到对称性直接*2即可
				if(j)add(f[i][j][k],f[i][j-1][k]);
				if(k)add(g[i][j][k],g[i][j][k-1]);
			}
	for(int i=1;i<=300;i++)for(int j=1;j<=300;j++)add(sum[i][j],sum[i][j-1]);
	for(int i=1;i<=300;i++)for(int j=1;j<=300;j++)add(sum[i][j],sum[i][j-1]);
	while(T--)scanf("%d%d",&n,&x),printf("%d\n",sum[n][x-1]);
	return 0;
}
```
如有表达不清可以在评论区里交流讨论。

---

## 作者：RainWetPeopleStart (赞：5)

好玩的题目。

不妨设当前局面的第 $i$ 个数为 $2^{a_i}$，是第 $t_i$ 个出现的。

此时 $a$ 一定是单峰的，由定义知对于峰值的任一侧而言不存在等值点。

证明：考虑归纳，发现操作不改变单峰的性质。

下记 $pa$ 表示 $a$ 的最大值的位置。

考虑 $t$ 的性质，先考虑最小值所在位置 $pt$，发现能取的值很少。

首先 $pa=pt$ 时，可以发现（归纳）此时 $t$ 是单谷的。

否则，就只能通过不断往一侧加数来刷新 $t_{pa}$，可知此时 $|pa-pt|=1$ 且 $t$ 单谷，由于是刷新 $t_{pa}$，故还要求 $a_{pt}+1<a_{pa}$。

同时，要考虑当前的空格是否够我们合成出 $a$，可得 $n+1-t_i\ge a_i$。

现在我们已经推出了 $a$ 和 $t$ 的性质，考虑计数，对于这个题而言，DP 无疑是更好的选择。

单峰的序列一般有如下的刻画方式：

1.拆成两个递增序列。

2.区间 DP，按值的从大（小）到小（大）。

第一种不好处理 $t_i$ 和 $a_i$ 的关系，考虑第二种，把峰值去掉，按 $t$ 从大到小做。

记 $f_{n,a1,a2}$ 表示已经确定了 $n$ 个数，左边极值为 $a1$，右边极值为 $a2$ 的方案数。

初始 $f_{0,0,0}=0$，转移是 $f_{i,j,k}=\sum\limits_{a=0}^{j-1}f_{i-1,a,k}+\sum\limits_{a=0}^{k-1}f_{i-1,j,a}$，前缀和优化一下就是 $O(n^3)$。（为满足 $a$，$t$ 的关系要求 $j,k\le i$）

考虑算答案，设 $g_{i,j}$ 表示 $n=i$，最大值恰为 $j$ 的答案。

- $j>i$ 时显然 $g$ 值为 $0$。

- 否则，先考虑 $pa=pt$，枚举峰值两边的取值，得这一部分的贡献为 $\sum\limits_{a,b\le j-1}f_{i-1,a,b}$，再考虑 $|pa-pt|=1$ 的贡献，枚举（$t$ 的）峰值大小（$[1,j-2]$），得贡献为 $\sum\limits_{k=1}^{j-2}\sum\limits_{a\le k-1}(f_{i,a,j}+f_{i,j,a})$，也可以前缀和优化为 $O(n^3)$。

最后对 $g$ 求前缀和就可以 $O(1)$ 回答了。

总复杂度 $O(nx^2+T)$。

代码：


```cpp
#include <bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define se second
#define mk make_pair
#define ll long long
#define ull unsigned long long
#define uint unsigned int
#define bi __int128_t
#define lb(x) ((x)&(-(x)))
#define gp(i,j) (((i)>>(j-1))&1)
#define ppc __builtin_popcount
using namespace std;
const int N=305;//mod=1e9+7;
const ll inf=1e18+10;
int mod,n,k,LM=303;
void Add(int &a,int b){a+=b;if(a>=mod) a-=mod;}
void Sub(int &a,int b){a-=b;if(a<0) a+=mod;}
void Mul(int &a,int b){a=1ll*a*b%mod;}
int qp(int a,int b){
    int x=1;
    while(b){
        if(b&1) Mul(x,a);
        Mul(a,a);b>>=1;
    }return x;
}
int f[N][N][N],sum1[N][N][N],sum2[N][N][N],ans[N][N];
void slv(){
    cin>>n>>k;
    int o=n/2+1;
    cout<<ans[n][k-1]<<endl;
}
int main(){
    int t=1;cin>>t>>mod;
    f[0][0][0]=1;
    for(int i=0;i<=LM;i++) sum1[0][i][0]=1,sum2[0][0][i]=1;
    for(int i=1;i<=LM;i++){
        for(int j=0;j<=i;j++){
            for(int k=0;k<=i;k++){
                if(j!=0) Add(f[i][j][k],sum1[i-1][j-1][k]);
                if(k!=0) Add(f[i][j][k],sum2[i-1][j][k-1]);
                sum1[i][j][k]=f[i][j][k];
                sum2[i][j][k]=f[i][j][k];
                //if(i<=5) cout<<i<<' '<<j<<' '<<k<<' '<<f[i][j][k]<<endl;
            }
        }for(int j=0;j<=i;j++){
            for(int k=1;k<=i;k++){
                Add(sum1[i][k][j],sum1[i][k-1][j]);
                Add(sum2[i][j][k],sum2[i][j][k-1]);
            }
        }
    }for(int i=1;i<=LM;i++){
        for(int j=1;j<=LM;j++){
            ans[i][j]=ans[i][j-1];
            if(j<=i){
                for(int k=0;k<=j-1;k++){
                    Add(ans[i][j],sum2[i-1][k][j-1]);
                }
                for(int k=1;k<=j-2;k++){
                    Add(ans[i][j],sum1[i-1][k-1][j]);
                    Add(ans[i][j],sum2[i-1][j][k-1]);
                }
            }
            //if(i==1) cout<<i<<' '<<j<<' '<<ans[i][j]<<endl;
        }
    }
    while(t--) slv();
    return 0;
}
```

---


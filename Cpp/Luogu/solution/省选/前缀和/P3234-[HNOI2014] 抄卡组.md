# [HNOI2014] 抄卡组

## 题目描述

一天闲着无聊的小L找来了当前正火爆的游戏《炉石传说》来玩，但是怎么打怎么输，于是他大喊一声”我要抄卡组！“就找来了游戏传说组第一名的游戏高手小H的直播来看。

但是小L家的网络技术还停留在拨号，看着直播画面又是卡顿又是花屏，他不给力的网络让他完全无法记录小H展示的给力的卡组。小L周围都是学霸没有人玩游戏想去帮他这个忙，但是学霸们热衷于讨论各种信息学问题。

于是他想到了一个方法：由于每次花屏的屏幕位置不一样，于是小H每次总能记录下卡组的一些部分，如果这样记录多次，不就有可能还原出小L想要的一个卡组么？

但是存在的一个问题是，小H每次展示的卡组有可能不一样，所以他想知道他每次看直播抄下来几次的卡组碎片是否一致。

这样一来小H将他遇到的游戏问题抽象成这样一个学术问题让学霸（你）解决：'\*'可以匹配任意长度个的字符 （包含0个），问所有字符串是否两两匹配。


## 说明/提示

对于100%的数据，满足N<= 100000，T= 10，输入文件不超过10M，N\*最长字符串长度不超过2x10^8

目前有且仅有 hack 数据中 $T = 1$。

## 样例 #1

### 输入

```
10
2
1234567890*1234567890
1234567890a1234567890
2
1234567890*1234567890
1234567890*1234567890
2
1234*67890a1234567890
1234567890*1234567890
2
1234567890*1234567890
1234567890a12345*7890
2
1234567890*1234567890
*12345
2
12345*67890
1234567890*1234567890
2
1234567890*1234567890
12345*
2
1234567890*1234567890
*67890
2
67890*
1234567890*1234567890
2
1234567890*a*1234567890
1234567890*1234567890```

### 输出

```
Y
Y
Y
Y
N
Y
Y
Y
N
Y```

# 题解

## 作者：斯德哥尔摩 (赞：6)

[P3234 [HNOI2014]抄卡组](https://www.luogu.org/problemnew/show/P3234)

趁没有题解赶紧抢一血。。。

题目已经解释得很清楚了，一个带通用字符的字符转匹配。

一开始看到多模式串，不由自主地想起了$AC$自动机/$SAM$。

然而看了下数据范围：$N\times \max_{i=1}^n\{ Length(str_i) \}<=10^8$

这还怎么$AC$自动机啊。。。

不知道怎么做，开始$YY$~~（其实就是翻题解。。。）~~

我是啃这位巨佬的题解看懂的：[链接](https://blog.csdn.net/jiangyuze831/article/details/42294833)

好神啊，$KMP$都不用，直接$hash$。。。

首先，对于那个坑爹的数据范围，我们使用$vector$来~~搞事~~解决。

然后我们计算出每个字符串的$hash$值。

（据说单$hash$会被卡，这里由于数据不卡，我们自行忽略。。。如果实在想写也可以。）

然后分类讨论：

1. 所有的字符串中都不含通配符。

	这种情况好办，直接比较我们算出来的$hash$值即可。
    
    怎么比？当然排个序然后相邻两位比较啊。。。
    
2. 所有字符串都含有通配符。
	
    注意到通配符可以代替任意字符串。
    
    那么我们就可以不管中间的通配符了，只需要看前缀和后缀。
    
    前缀是从开头到第一个通配符，后缀同理。
    
    按照前缀从短到长排序，然后逐个判断前缀是否相等，后缀同理。
    
    中间的通配符肯定有一种方案搞成匹配的。

3. 部分字符串都含有通配符。

	首先，把不含有通配符的字符串比较一下。
    
    然后让所有含有通配符的字符串变成不含有通配符的字符串。
    
    怎么变呢？
    
    我们按照上一种情况的想法，先把前缀和后缀去掉。
    
    然后让含有通配符的那个的中间部分匹配上不含有通配符的中间部分的字符串即可。
    
    上面已经说了，中间的通配符肯定有一种方案搞成匹配的。
    
    所以是可行的。
    
    怎么搞呢？
    
    直接暴力就行辣！反正怎么弄都是$O(n)$。。。
    
    利用通配符分割含有通配符的中间部分，然后用一个指针去扫不含有通配符的字符串。
    
    于是这个问题也被愉快地解决了！
    
到此，我们对这个问题的分析结束。

但是$STL$常数较大怎么办？我们的$vector,string$是肯定不能动的。。。

只剩下常数巨大的$O(n)$的暴力与读入，并且常数巨大的暴力好像也没有什么优化的余地。。。

那就只剩读入了。。。

读入优化？可以。

但是我们同样可以关闭流的同步。

也就是在$main$函数开头添加一句：
```cpp
ios::sync_with_stdio(false);
```

然后就可以了！

附上代码（缩进好丑。。。）：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<vector>
#include<string>
#define MAXN 100010
#define MAXM 10000010
#define base 2333//hash
using namespace std;
int n;
unsigned long long val[MAXM];//使用unsigned long long的自动溢出
bool flag;
string ch;
struct String{//自定义字符串
	int len,num;
	vector<unsigned long long> hash;//记录hash值
	vector<int> word;//记录每个通配符的出现位置
	friend bool operator <(const String p,const String q){
		return (flag?(p.word[1]<q.word[1]):(p.len-p.word[p.num]<q.len-q.word[q.num]));
	}
	inline void init(){//清空
		len=num=0;
		hash.clear();hash.push_back(0);
		word.clear();word.push_back(0);
	}
	void build(string s){//计算hash值
		for(string::iterator it=s.begin();it!=s.end();it++){
			hash.push_back(hash.back()*base+*it);
			len++;
			if(*it=='*'){
				num++;
				word.push_back(len);
			}
		}
	}
	unsigned long long get_hash(int l,int r)const{return hash[r]-hash[l-1]*val[r-l+1];}
	int get_suffix()const{return len-word[num];}
	bool match(const String &s){//暴力匹配
		int suffix=get_suffix();
		if(s.len<suffix+word[1]-1)return false;
		if(get_hash(1,word[1]-1)!=s.get_hash(1,word[1]-1))return false;
		if(get_hash(word[num]+1,len)!=s.get_hash(s.len-suffix+1,s.len))return false;
		int l=word[1],r=s.len-suffix;//两个指针扫
		for(int i=1;i<num;i++){
			int length=word[i+1]-word[i]-1;
			unsigned long long t=get_hash(word[i]+1,word[i+1]-1);
			while(1){//变成一样的字符串
				if(l+length-1>r)return false;
				if(s.get_hash(l,l+length-1)==t){l+=length;break;}
				l++;
			}
		}
		return true;
	}
}str[MAXN];
inline void make(){//预处理hash
	val[0]=1;
	for(int i=1;i<=MAXM-10;i++)val[i]=val[i-1]*base;//当初把MAXM打成了MAXN，然后WA了无数次。。。吃枣药丸。。。
}
bool check(){//分类讨论
	int pos=0;
	unsigned long long hash_val=0;
	for(int i=1;i<=n;i++){
		if(str[i].num)continue;
		if(!pos){
			hash_val=str[i].hash[str[i].len];
			pos=i;
		}
		else if(hash_val!=str[i].hash[str[i].len])return false;
	}
	if(pos){
		for(int i=1;i<=n;i++)if(str[i].num&&(!str[i].match(str[pos])))return false;
	}
	else{
		flag=true;
		sort(str+1,str+n+1);
		for(int i=1;i<n;i++)
			if(str[i].get_hash(1,str[i].word[1]-1)!=str[i+1].get_hash(1,str[i].word[1]-1))
				return false;
		flag=false;
		sort(str+1,str+n+1);
		for(int i=1;i<n;i++)
			if(str[i].get_hash(str[i].word[str[i].num]+1,str[i].len)!=str[i+1].get_hash(str[i+1].len-str[i].get_suffix()+1,str[i+1].len))
				return false;
	}
	return true;
}
void work(){
	if(check())putchar('Y');
	else putchar('N');
	putchar('\n');
}
void init(){//读入
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>ch;
		str[i].init();
		str[i].build(ch);
	}
}
int main(){//主函数So easy!
	ios::sync_with_stdio(false);
	int t;
	cin>>t;
	make();
	while(t--){
		init();
		work();
	}
    return 0;
}

```


---

## 作者：Lates (赞：2)

- 所有串都有通配符。 注意到可以只考虑每个串前后缀是否匹配。具体是把每个串第一个通配符的前缀拿出来，按长度排序后，两两可以匹配上。后缀类似。
- 存在串没有通配符。 那么这些串必须相等，且作为答案串。考虑判断一个存在通配符的可不可以变成这个串。含通配符的长成 $s_0*s_1*s_2*...*s_n$ 其中 $s$ 可以是空串。直接把这些串拿出来，放到答案串上暴力匹配，具体是找到第一个大于前一个匹配位置的匹配位置。**特别的**，最后一个后缀，如果不是 $*$ 结尾，那么要从后往前找到最大的那个匹配位置。或者说有多个 $*$ 连续出现，得直接跳过了。

否则会被 

```
a****a
aaaa
```
这样的卡掉。

还有一个特殊考虑是，如果答案串长度还没有待匹配串中非通配符数目多，直接寄了。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <cmath>
typedef long long ll;
typedef double db;
using namespace std;
#define PII pair<int,int>
#define mp make_pair
#define fir first
#define sec second
#define fin(haha) freopen(#haha".in","r",stdin);
inline int read(){
	register int x=0,f=0,ch=getchar();
	while('0'>ch||ch>'9')f^=ch=='-',ch=getchar();
	while('0'<=ch&&ch<='9')x=x*10+(ch^'0'),ch=getchar();
	return f?-x:x;
}
const int base = 233,P = 998244353;
const int MAX = 1e5+5;
int T;
int n;
string s[MAX]; 
int L[MAX],R[MAX],le[MAX];
vector<int>em; // 不含通配符的字符串编号 
vector<int>po;
vector<int>ha[MAX];

inline int gh(int id,int l,int r){
	return (P + ha[id][r] - 1ll * ha[id][l-1] * po[r-l+1] % P ) % P;
}
inline int reallen(int id){
	int ret = 0;
	for(register int i=1;i<=le[id];++i) if(s[id][i] != '*') ++ ret;
	return ret;
}
inline int checkl(int il,int in){
	for(register int i=1;i<L[il];++i)
		if(s[il][i] ^ s[in][i]) return 0;
	return 1;
}
inline int checkr(int il,int in){
	for(register int i=le[il],j=le[in];i>R[il];--i,--j)
		if(s[il][i] ^ s[in][j]) return 0;
	return 1;
}
inline int solve(int id,int go){ // 含通配符的 s[id] 是否可以变成无统配符的 s[go]  
	if(reallen(id) > reallen(go)) return 0; 
	int j = 1;
	vector<int> pos;pos.clear();
	for(register int i=1;i<=le[id];++i) if(s[id][i] == '*') pos.push_back(i);
//	1 ~ pos[0] - 1
	
	if(pos[0] ^ 1) {
		int len = pos[0] - 1,haha = gh(id,1,pos[0]-1);
		while(gh(go,j,j+len-1) != haha && j + len - 1 <= le[go]) ++ j;
		if(j + len - 1 == le[go] + 1) return 0;
		if(j != 1)return 0;
		j = j + len + 1;
	}
	for(register int i=1;i<pos.size();++i) {
		if(pos[i] == pos[i-1] + 1) continue;
		int len = pos[i] - 1 - (pos[i-1] + 1) + 1 , haha = gh(id,pos[i-1] + 1,pos[i] - 1);
		while(gh(go,j,j+len-1) != haha && j + len - 1 <= le[go]) ++ j;
		if(j + len - 1 == le[go] + 1) return 0;
		j = j + len + 1;
	}
	return checkr(id,go) ;
	return 1;
}

int ID[MAX];
inline bool solve(){
	if(em.size() >= 1){
		for(register int i=1;i<em.size();++i) 
			if(gh(em[i-1],1,le[em[i-1]]) != gh(em[i],1,le[em[i]])) return 0;
		for(register int i=1;i<=n;++i) {
			if(L[i] == -1 && R[i] == -1)continue;
//			printf("%d %d\n",i,em[0]);
			if(!solve(i,em[0])) return 0;
		}
		return 1;
	}else {
		for(register int i=1;i<=n;++i) ID[i] = i;
		sort(ID+1,ID+1+n,[&](int x,int y){return L[x] < L[y];});
		for(register int i=2;i<=n;++i) 
			if(!checkl(ID[i-1],ID[i])) return 0;
		sort(ID+1,ID+1+n,[&](int x,int y){return le[x] - R[x] < le[y] - R[y];});
		for(register int i=2;i<=n;++i)
			if(!checkr(ID[i-1],ID[i])) return 0;
		return 1;
	}
}
signed main(){
//	fin(in); 
	T=read();
	while(T--){
		vector<int>().swap(em);
		int mx = 0,mex = 0;
		n=read();
		for(register int i=1;i<=n;++i) {
			vector<int>().swap(ha[i]);
			cin >> s[i]; 
			le[i] = s[i].length(); 
			mex = max(mex,le[i]);
			s[i] = ' ' + s[i];
			
			L[i] = R[i] = -1;
			ha[i].push_back(0);
			for(register int j=1;j<=le[i];++j) {
				ha[i].push_back( (1ll * ha[i][j-1] * base % P + s[i][j]) % P );
				if(s[i][j] == '*') {
					if(L[i] == -1) 
						L[i] = R[i] = j;
					else 
						L[i] = min(L[i],j),R[i] = max(R[i],j);
				}
			}
			if(L[i] == -1 && R[i] == -1) em.push_back(i);
		}
		vector<int>().swap(po);
		po.push_back(1);
		for(register int i=1;i<=mex;++i) po.push_back(1ll * po[i-1] * base % P);
		
//		printf("%d\n",le[1]);
		puts(solve() ? "Y" : "N"); 
	}
	return 0;
}

```

---


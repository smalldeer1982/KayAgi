# [TJOI2017] 异或和

## 题目描述

在加里敦中学的小明最近爱上了数学竞赛，很多数学竞赛的题都是与序列的连续和相关的。  所以对于一个序列，求出它们所有的连续和来说，小明觉得十分的简单。  

但今天小明遇到了一个序列和的难题，这个题目不仅要求你快速的求出所有的连续和（即子串和），还要快速的求出这些连续和的异或值。  

小明很快的就求出了所有的连续和，但是小明要考考你，在不告诉连续和的情况下，让你快速求是序列所有连续和的异或值。


## 说明/提示

【样例解释】

序列 $[1,2,3]$ 有 $6$ 个连续和，它们分别是 $1,2,3,3,5,6$，而 $1 \text{ xor } 2 \text{ xor } 3 \text{ xor } 3 \text{ xor } 5 \text{ xor } 6 = 0$。

【数据范围】

- 对于 $20\%$ 的数据，$1\le n \le 100$；
- 对于 $100\%$ 的数据，$1\le n \le 10^5$，$\sum a_i \le 10^6$。


## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
0```

# 题解

## 作者：金爷爷哈哈 (赞：37)

为啥有没题解。。。。蒟蒻来水一水吧。。。



一般这种位运算的题都要把每一位拆开来看，因为位运算每个位的结果这和这一位的数有关。

这样我们用s[i]表示a的前缀和，即a[1]+a[2]+....a[i]，然后我们从这些数二进制最右位（2^0）开始，按照每一位对答案的贡献来计算。


假设我们现在算到最右位（2^0）,并且位于第i个数，我们想要知道以i结尾的连续和对答案的贡献，只需要知道有多少s[i]-s[j]（0<=j<i）的2^0位是1。 （设s[0]=0）

如果这个数是奇数，就说明异或了1奇数次，也就相当于异或了1，我们只需要把记录这一位总的异或贡献的变量cnt异或1即可；

如果是偶数就不用管了，对答案没有贡献。


对于数的每一位如果最后cnt=1的话，就说明在这一位所有连续和的异或和为1，我们就需要把答案加上(1<<(这个位数））。


那如何快速计算有多少个s[i]-s[j]的二进制第k位是否为1呢？？

答案是利用权值树状数组。


考虑到Σa 最大才有1000000，我们构造两棵权值树状数组，一棵记录当前位为1的，另一棵记录为0的。

如果当前扫描到的s[i]的二进制第k位为1，那么对这一位的答案有贡献的只有那些第k位为1且第k位向右的数比s[i]第k位向右的数大的或者第k位为0且第k位向右的数不比s[i]第k位向右的数大的。（可能有点拗口，，都怪我语文学的不好）

为什么呢？

因为如果第k位都为1的话，那么只有后面那些位的和大于s[i]的数，s[i]减去它之后第k位才能出现1（因为s[i]比它小的话需要向更高位借数，就和小学学的横式减法差不多），从而对答案作出贡献；

如果第k位为0的话，如果后面再比s[i]大的话，s[i]第k位的1就需要借给低一位的了，所以后面必须不比s[i]大。



这样就很好用权值树状数组维护了。。。。


code:










































```cpp
#include<bits/stdc++.h>
#define ll long long
#define max(a,b) (a)>(b)?(a):(b)
using namespace std;
ll s[100005],a[100005];
ll f[2][1000005],n,m,ans=0,now,cnt=0,tmp;
bool flag;
ll maxn;
inline void read(ll&x){
  x=0; char ch=getchar();
  while(!isdigit(ch)) ch=getchar();
  for(;isdigit(ch);ch=getchar())  x=x*10+ch-'0';
}
inline void update(ll x,ll y){
   for(;x<=1000000;x+=x&-x) f[y][x]++;
}
inline ll query(ll x,ll y){
   ll ansd=0;
   for(;x;x-=x&-x) ansd+=f[y][x];
   return ansd;
}
int main(){
  read(n);
  for(ll i=1;i<=n;i++) read(s[i]),s[i]+=s[i-1],maxn=max(maxn,s[i]);
  for(ll i=0;i<=20;i++){
     if((1<<i)>maxn) break;
     memset(f,0,sizeof(f));
     flag=0,cnt=0;
     update(1,0);
     for(ll j=1;j<=n;j++){
        tmp=s[j]&(1<<i);
        if(tmp) now=query(a[j]+1,0)+query(1000000,1)-query(a[j]+1,1);
        else now=query(a[j]+1,1)+query(1000000,0)-query(a[j]+1,0);
        if(now%2) cnt^=1;
        update(a[j]+1,(tmp>0?1:0));
        a[j]|=tmp;
     }
     if(cnt) ans+=(1<<i);
  }
  cout<<ans;
  return 0;
}
```

---

## 作者：shadowice1984 (赞：28)

相信你的信仰……

都是logN，各种logN的常数可是千差万别的

再次重申一边，O(NlogN)的**渐进**复杂度是指，随着输入的增长，耗时的**增长**和NlogN同阶。因此和实际耗时完全没联系啊……(只是大部分时候常数差不多才有了那个把数据范围代进去，算出来不超过5\*10^8/3\*10^8/10^9就能过的说法的)

# 要开longlong

首先我们发现这道题让我们求异或和，对于这种位运算的东西我们没有任何办法，只有两条路可走，1，拆位2，找规律

首先题目中让我们求所有的子区间和，因此我们可以考虑做个前缀和什么的就可以O(1)求出,令sum(i)表示i为结尾的前缀和

那么题目中其实是让我们求

# $⊕\sum_{i=1}^{n}\sum_{j=0}^{i-1}sum(i)-sum(j)$

一个非常直白的想法就是枚举i，之后再枚举j，然后如果我们nc再拆一下位我们就有了一个O(N^2logM)的优秀做法

但是我们想一下啊，既然我们都拆位了，此时的减法运算和异或运算都会变的非常简单我们要好好研究下有什么性质

因为我们拆了位，所以sum(i)-sum(j)的第k位不是0就是1，而且我们发现，异或运算在只有一位的情况下等价于%2下的运算，因此我们对于这第k位来讲，我们统计出这一位到底有多少个1就好了，最后%2再乘上一个(1<<k)就好了，所以现在答案被我们折腾成了这个式子

#### $\sum_{k=0}^{(1<<k)<sum(n)}(1<<k)(\sum_{i=1}^{n}\sum_{j=0}^{i-1}((sum(i)-sum(j))>>k\&1)mod2$

尽管这个式子很鬼畜吧但是我们总算不用见到异或了

我们发现外层的k肯定是省不了的，内层的i其实也不是很能省，所以我们的精力主要放在如何处理j的循环上

我们发现不就是给定了sum(i)和k，求有**多少个sum(j)**和sum(i)做个差之后第k位值为1吗……

那么我们发现此时如果sum(i)第k位是1，那么我们希望减了sum(j)之后还是1

那么只有两种可能

1.没有发生借位，并且sum(j)的第k位是0，这样才可以保证sum(i)的1不会被减掉

2.发生了借位，并且sum(j)的第k位是1，这样我们会发现sum(i)被减了1之后，这一位会变成0，我们借一下位0就变成1了

若sum(i)第k位是0呢？必须发生且仅发生了1次借位才可以变成1

1.这个借位来源于sum(j)的第k位是1，导致的借位，并且此时不可以再发生第二次借位

2.这个借位来源于sum(j)的前k-1位，所以此时sum(j)第k位必须是0

如何判定会不会发生借位呢？我们可以这样想，如果sum(j)的前k-1位的值大于sum(i)前k-1位的值，就会发生借位，否则不发生

那么我们发现好像sum(i)和sum(j)的值不会太大，而且吧，这是个值的大于小于问题，我们自然就想到了用区间求和的形式来处理这个问题，我们把大于和小于的限制**变成值域的限制**(讲道理就算大了我们也可以离散化)

另外，我们要求在j必须小于i,此时我们需要按顺序将这些值插入数据结构之中，这样就满足了i>j的限制关系

这个数据结构支持单点修改区间求和，所以我们选择树状数组，开两个，位置就代表值，一个树状数组记录当前位为0的，另一个记录1

然后我们就可以大力算了~，如果每部%2可以不开longlong，但是如果像我一样的话……还是开longlong吧

这个算法的复杂度是 O(NlogM^2)如果有离散化的话复杂度会降到O(NlogNlogM)但是很不推荐(离散化常数大……)

代码超级短~

上代码~

```c
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long ll;//不每次膜的话就要开longlong 
const int N=1e5+10;const int M=1e6+10;
int n;int lim;int sum[N];ll res;
struct treearray//这里注意一个坑，我们对于第0个前缀和也要处理，这里树状数组整体右移1 
{
	ll ta[2*M];
	inline void c(int x,ll t){x+=1;for(;x<=lim+1;x+=x&(-x)){ta[x]+=t;}}
	inline ll q(int x){x+=1;ll r=0;for(;x>0;x-=x&(-x)){r+=ta[x];}return r;}
	inline ll s(int l,int r){return q(r)-q(l);}
	inline void clear(){for(int i=0;i<=lim+1;i++){ta[i]=0;}}
}ta1,ta0;
int main()
{
	scanf("%d",&n);for(int i=1;i<=n;i++){scanf("%d",&sum[i]);sum[i]+=sum[i-1];}
	for(int k=0;(1<<k)<=sum[n];k++)
	{
		lim=(1<<k)-1;ll ret=0;
		for(int i=0;i<=n;i++)//计算个数并统计 
		{
			int nb=(sum[i]>>k)&1;int lst=sum[i]&lim;
			if(nb){ret+=ta0.s(-1,lst)+ta1.s(lst,lim);ta1.c(lst,1);}//如果是1 
			else {ret+=ta1.s(-1,lst)+ta0.s(lst,lim);ta0.c(lst,1);}//如果是0 
		}res+=(1<<k)*(ret%2);ta1.clear();ta0.clear();
	}printf("%lld",res);return 0;//拜拜程序~ 
}

```


---

## 作者：Flandre_495 (赞：20)

连续和，一眼想到前缀和；异或，一眼想到二进制按每一位来算。~~虽然我看到题后一直在想一些奇奇怪怪的分治。。。~~

如果这题的连续和改为连续异或，这就是个普及难度了，然而是和，这说明不同二进制位之间相互有影响。但也不要害怕~，我们想一想它们相互的影响是什么。

考虑每一位的贡献，由于前缀和$sum[n]\le 1e6$，二进制位不超过$20$位。先枚举第 $k$ 位，让 $i$ 从左到右扫一遍，计算 $i$ 前面有多少 $j$ 满足：$sum[i]-sum[j]$ 的第 $k$ 位为 $1$，把所有满足的情况异或起来，如果是 $1$，最终答案的第 $k$ 位也就是 $1$ 了。

然后考虑哪些情况使得 $sum[i]-sum[j]$ 的第 $k$ 位为 $1$。显然对于二进制的加减法来说，高位不会影响低位，就是下图黑的部分，对结果造不成影响，而第 $k$ 位，目前来看数字相同减完之后即为 $0$，不同即为 $1$。因为就算是 $0-1$，$sum[i]$ 的高位肯定比 $sum[j]$ 的高位要大（保证输入是正整数），肯定出不来负数。

![](https://t1.picb.cc/uploads/2020/02/28/kvkydD.png)

而低位造成的影响，其实也很简单，如果 $sum[i]$ 的低位比 $sum[j]$ 的大，那么不用借第 $k$ 位，反之则借第 $k$ 位，如果第 $k$ 位被借的话，答案就会颠倒。

所以我们只需用树状数组记录所有的 $sum[j]$：第 $k$ 位为 $0$ 且蓝色部分大小为多少的有几个，第 $k$ 位为 $1$ 且蓝色部分大小为多少的有几个。计算答案，如果第 $k$ 位相同，算所有低位比它大的，第 $k$ 位不同，算所有比它小的。

由于只需计算第 $k$ 位是否为 $1$ ，我们把所有看似需要加减的计算改为异或即可。

附上鄙人的Code：

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#define QWQ cout<<"QwQ"<<endl;
#define ll long long
#include <vector>
#include <queue>
#include <stack>
#include <map>
using namespace std;
const int N=2010101;
const int qwq=303030;
const int inf=0x3f3f3f3f;

int n,m;
int a[N],sum[N];
int tree[N][2];
int ans;

inline int read() {
	int sum1 = 0, f = 1; char c = getchar();
	while(c<'0' || c>'9') { if(c=='-') f = -1; c = getchar(); }
	while(c>='0'&&c<='9') { sum1 = sum1 * 10 + c - '0'; c = getchar(); }
	return sum1 * f;
}

//两行树状数组，因为下标可能为0，我把所有的位置加了1。
inline void add(int we,int cl) { we++; for(int i=we;i<=m;i+=(i&-i)) tree[i][cl]^=1; }
inline int  ask(int we,int cl) { we++; int rs=0; for(int i=we;i;i-=(i&-i)) rs^=tree[i][cl]; return rs; }

int main() {
	n = read(); m = N-10;
	for(int i=1;i<=n;i++) a[i] = read(), sum[i] = sum[i-1] + a[i];
	for(int k=0;k<=20;k++) {
		memset(tree,0,sizeof(tree));
		int res = 0;
		add(0,0);
		for(int i=1;i<=n;i++) {
			int u = (sum[i]>>k) & 1;      //第k位
			int v = sum[i] % (1<<k);      //低位
			res ^= ask(v,u^1);            //k位不同
			res ^= ask(m-1,u) ^ ask(v,u); //k位相同
			add(v,u);
		}
		ans |= (res<<k);
	}
	cout<<ans;
	return 0;
}
```

说的有点啰嗦了。。。~~主要是因为自己太菜怕以后忘了怎么做了。。。~~

---

## 作者：NaCly_Fish (赞：20)

oscar 神仙的题解有些简略了，，这里详细解释一下吧。

首先题目要求所有子段和的 $\text{xor}$ 和，可以先把原序列做一遍前缀和，这样就转化为了两两相减的 $\text{xor}$ 和。

考虑计算每一种数的出现次数，对于每个出现奇数次的数异或起来就是答案。  
记 $i$ 的出现次数为 $f_i$，原序列的前缀和中 $i$ 的 **出现次数** 为 $s_i$，那么有：  

$$f_i=\sum\limits_{j=0}^{m-i}s_j\times s_{j+i}$$ 
其中 $m$ 为所有数之和的上界，在此题中为 $10^6$。

然后你发现这个式子非常像一个卷积，，  
通过翻转序列，可以把它变成一个标准的卷积式：  

$$f_{m-i}=\sum\limits_{j=0}^{i}s_j\times s_{m-i+j}$$
也就是把 $s$ 翻转后和原来的 $s$ 卷积，再翻转就可以得到 $f$ 数组了。  
使用 $\text{FFT}$ 来优化，时间复杂度为 $\Theta(m\log m)$。

参考代码：  
```cpp
#pragma GCC optimize (2)
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<cmath>
#define N 2097159
#define M 1000000
#define LIM 2097152
#define reg register
#define pi 3.141592653589793
using namespace std;

inline void read(int &x){
	x = 0;
	char c = getchar();
	while(c<'0'||c>'9') c = getchar();
	while(c>='0'&&c<='9'){
		x = (x<<3)+(x<<1)+(c^48);
		c = getchar();
	}
}

struct complex{
	double r,i;
	inline complex(double r=0,double i=0):r(r),i(i){}
	inline complex operator + (const complex& x) const{
		return complex(r+x.r,i+x.i);
	}
	inline complex operator - (const complex& x) const{
		return complex(r-x.r,i-x.i);
	}
	inline complex operator * (const complex& x) const{
		return complex(r*x.r-i*x.i,r*x.i+i*x.r);
	}
	inline complex operator / (const int& x) const{
		return complex(r/x,i/x);
	}
	inline complex operator ~ () const{
		return complex(r,-i);
	}
};

int rev[N];

inline void pre(int lim){
	int l = 1;
	while((1<<(l+1))<lim) ++l;
	for(reg int i=1;i!=lim;++i)
		rev[i] = (rev[i>>1]>>1)|((i&1)<<l);
}

inline void FFT(complex *a,int type,int lim){
	for(reg int i=1;i!=lim;++i)
		if(i<rev[i]) swap(a[i],a[rev[i]]);
	complex w,x,y,rt;
	for(reg int mid=1;mid!=lim;mid<<=1){
		rt = complex(cos(pi/mid),type*sin(pi/mid)); //预处理单位根反而会慢 很神奇
		for(reg int j=0;j!=lim;j+=(mid<<1)){
			w = complex(1,0);
			for(reg int k=0;k!=mid;++k){
				y = w*a[j|k|mid];
				a[j|k|mid] = a[j|k]-y;
				a[j|k] = a[j|k]+y;
				w = w*rt;
			}
		}
	}	
	if(type==1) return;
	for(reg int i=0;i!=lim;++i) a[i].i = a[i].i/lim;
}

int a[N],s[N];
int n,ans;
complex F[N];

int main(){
	pre(LIM);
	read(n);
	F[0].r = 1;
	for(reg int i=1;i<=n;++i){
		read(a[i]);
		s[i] = s[i-1]+a[i];
		F[s[i]].r += 1;
	}
	for(reg int i=0;i<=M;++i) F[M-i].i = F[i].r; //这里用了三次变两次优化
	FFT(F,1,LIM);
	for(reg int i=0;i!=LIM;++i) F[i] = F[i]*F[i];
	FFT(F,-1,LIM);
	for(reg int i=0;i<=M;++i)
		a[M-i] = F[i].i/2+0.5;
	for(reg int i=1;i<=M;++i)
		if(a[i]&1) ans ^= i;
	printf("%d",ans);	
	return 0;
}
```

---

## 作者：critnos (赞：16)

原本准备投的月赛，发现原题，故公开解法。

给出了目前题解中时间复杂度最优秀的解法。

很明显就前缀和（设为 $s$，$s_0=0$），然后按位考虑。

把这一位拆出来作为 $01$ 序列 $t$。

对于 $i,j$，如果 $s_j-s_i$ 在当前位没有发生退位，那么就要求 $t_i\ne t_j$；否则 $t_i =t_j$。

考虑退位是什么，其实就是对于在这一位之前的所有位产生的数（设为 $b$）,$b_j<b_i$。

明了了。

即求

$$\sum_{i=0}^{n-1} \sum_{j=i+1}^n [t_i =t_j \land b_i >b_j \lor t_i\ne t_j \land b_i\le b_j] $$

树状数组可以做到 $O(nw\log n)$。

我们不妨拆开上面的式子，然后分别加起来。

$$\sum_{i=0}^{n-1} \sum_{j=i+1}^n [t_i =t_j \land b_i >b_j ] $$

如果我们把 $t$ 按 $01$ 分类，就相当于逆序对问题。

这个是难以做到线性的。

但是题目有一个很好的性质，就是我们只用求逆序对的奇偶性。

存在线性算法，见下。

第二个东西是：

$$\sum_{i=0}^{n-1} \sum_{j=i+1}^n [t_i\ne t_j \land b_i\le b_j] $$

不妨不考虑 $t_i \ne t_j$ 的限制，直接算。这个用逆序对容斥一下即可。

然后再减去 $t_i=t_j$ 的部分。这个上面已经几乎算过了，也用逆序对容斥即可。

接下来我们考虑，如何求逆序对的奇偶性。

首先，我们可以在线性时间内将 $b$ 转为排列。

考虑从低到高加入每一位。每加入一位，相当于把某些数的最高位变成 $1$。

那么维护排序数组，把这些数提到最后即可。

考虑求排列逆序对奇偶性。

### 引理：对于一个排列，若任意交换 $x$ 次相邻项后，该排列有序，那么 $x$ 和该排列的逆序对奇偶性相同。

证明：

一个排列的逆序对数等于交换相邻项的次数，这是众所周知的。

但这里的相邻项要满足前项大于后项。若前项小于后项，那么使用了一次操作将逆序对数量增加了一。这显然是不改变 $x$ 的奇偶性的。

### 推论：一个排列的逆序对的奇偶性与 $n$ 减去该排列的环数的奇偶性相同。

考虑 $n$ 减去该排列的环数是什么，是任意交换两项，得到有序排列的最小次数。因为有序排列 $p_i=i$。

而这个和任意交换的奇偶性是相同的。

为什么呢？考虑使用相邻项交换模拟任意两项交换。显然任意交换两项都可以通过若干次相邻项交换得到，

又因为任意交换的奇偶性和逆序对的奇偶性相同，所以推论得证。

环数容易线性求出，所以本题的每一位的处理可以做到线性。

时间复杂度 $O(nw)$。

---

## 作者：oscar (赞：10)

我的FFT一个log被两个log的树状数组按位查询碾压啊qwq


原理大概是前缀和+差分可以得到所有区间的和，统计出每个和出现过多少次，把出现过奇数次的所有和异或起来就可以得到答案


做法大概是先做一遍前缀和，存到权值数组里，正着存一遍反着存一遍再卷积起来（套路）




//不开O2暂时卡不过QAQ

//加了“三次变两次”优化也卡不过QAQ

代码（仅供参考，欢迎帮忙卡常（雾））：


```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
const double pi=3.1415926535897932384626433832795;
const int MAXV=1000000;
struct c
{
    double r,i;
    inline c(){r=i=0.0;}
    inline c(const double a,const double b){r=a,i=b;}
    inline c operator+(const c &x)const{return c(r+x.r,i+x.i);}
    inline c operator+=(const c &x){return *this=*this+x;}
    inline c operator-(const c &x)const{return c(r-x.r,i-x.i);}
    inline c operator-=(const c &x){return *this=*this-x;}
    inline c operator*(const c &x)const{return c(r*x.r-i*x.i,r*x.i+i*x.r);}
    inline c operator*=(const c &x){return *this=*this*x;}
    inline c operator/=(const int x){r/=x,i/=x;return *this;}
    inline c conj(){return c(r,-i);}
}A[2333333];
int r[2333333],l=1;
int n;
inline void fft(c *a,int ty)
{
    for(int i=0;i<l;i++)i<r[i]?(void)(0):swap(a[i],a[r[i]]);
    for(int i=1;i<l;i<<=1)
    {
        c w(cos(pi/i),ty*sin(pi/i));
        for(int j=0;j<l;j+=i<<1)
        {
            c wn(1.0,0.0);
            for(int k=j;k<i+j;k++)
            {
                c t=a[i+k]*wn;
                a[i+k]=a[k]-t;
                a[k]+=t;
                wn*=w;
            }
        }
    }
}
int a[233333],s[233333];
int tmp[2333333],ans;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        s[i]=s[i-1]+a[i];
        A[s[i]].r+=1;
    }
    A[0].r+=1;
    for(int i=0;i<MAXV;i++)A[i].i=A[MAXV-i-1].r;
    while(l<=MAXV*2)l<<=1;
    for(int i=1;i<l;i<<=1)
        for(int j=0;j<i;j++)
            r[i+j]=r[j]+l/(i<<1);
    fft(A,1);
    A[l]=A[0];
    for(int i=0;i<=l-i;i++)
    {
        c t=(A[i]+A[l-i].conj())*c(0.0,1.0)*(A[i]-A[l-i].conj());t/=4;
        c t2=(A[l-i]+A[i].conj())*c(0.0,1.0)*(A[l-i]-A[i].conj());t2/=4;
        A[i]=t;A[l-i]=t2;
    }
    fft(A,-1);
    for(int i=0;i<MAXV;i++)tmp[MAXV-i-1]=-A[i].r/l+0.5;
    for(int i=0;i<MAXV;i++)ans^=i*(tmp[i]&1);
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：big_news (赞：7)

01-Trie 果题.......

提供一种使用 01-Trie 的解法。

[link](https://big-news.cn/2020/08/17/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8D%E5%BC%82%E6%88%96%E5%92%8C/)

考虑固定左端点 $l$ ，$O(n)$ 枚举右端点 $r$ ，则可以求出一些左端点固定的区间 $[l,r]$ 权值和异或和。

考虑优化这个过程：对于一个左端点 $l$ ，如何快速求出其能对应的所有区间 $[l,r]$ 的异或和。由于数列是静态的，那么我们考虑 $l\to l-1$ 时贡献的变化，它应该是这个样子：

$$\begin{aligned} & (s[n]-s[l])\oplus (s[n-1]-s[l])\oplus ... \oplus (s[l+1]-s[l]) \\ \to &(s[n]-s[l]+a[l-1])\oplus (s[n-1]-s[l]+a[l-1])\oplus ...\oplus a[l-1] \end{aligned}$$

其中 $s[]$ 代表 $a[]$ 的前缀和。容易发现这个变化是对每一项同时加了一个值之后再查询异或和，显然可以通过 01-Tire 来维护，总复杂度 $O((n+\sum a_i)\log a_i)$；由于 $\sum a_i \le 10^6$，所以可以通过。

代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
using namespace std;

const int CN = 1e5 + 5;

int read(){
    int s = 0,ne = 1; char c = getchar();
    while(c < '0' || c > '9') ne = c == '-' ? -1 : 1, c = getchar();
    while(c >= '0' && c <= '9') s = (s << 1) + (s << 3) + c - '0', c = getchar();
    return s * ne;
}

class TRIE {
  public: int ch[CN * 30][2], d[CN * 30], w[CN * 30], idx, rt, MAXH;
    #define lc ch[u][0]
    #define rc ch[u][1]
    TRIE() {rt = idx = 0, MAXH = 30;}
    int make() {return ++idx;}
    void mt(int u){
        d[u] = 0, w[u] = w[lc] + w[rc];
        if(rc) d[u] ^= (d[rc] << 1) | (w[rc] & 1);
        if(lc) d[u] ^= d[lc] << 1;
        w[u] &= 1;
    }
    void ins(int &u, int x, int dep){
        if(!u) u = make();
        if(dep == MAXH) return (void)(w[u] ^= 1);
        if(x & 1) ins(rc, x >> 1, dep + 1);
        else ins(lc, x >> 1, dep + 1);
        mt(u);
    }
    void add(int u) {if(rc) add(rc); swap(lc, rc), mt(u);}
} D;

int n, a[CN];

int main()
{
    freopen("_in.in", "r", stdin);

    n = read(); for(int i = 1; i <= n; i++) a[i] = read();

    int ans = 0;
    for(int i = n - 1; i + 1; i--){
        int s = a[i + 1];
        while(s--) D.add( D.rt );
        D.ins(D.rt, a[i + 1], 1);
        ans ^= D.d[ D.rt ];
    }

    printf("%d", ans);
}
```

---

## 作者：rhineofts (赞：6)

一个简单的 $O((n+V)\log V)$ 做法。

推荐一个类似题：gym 102538E，处理技巧一致。

区间和问题，在前缀和上考虑。异或问题，每一位分开考虑。

对于前缀和 $s_i$，考虑哪些前缀和会和它在第 $bit$ 位产生贡献：可以发现，所有满足 $0\le j < i$ 且 $s_i - s_j$ 第 $bit$ 位为 $1$ 的 $j$ 都有贡献。而这样的 $s_j$ 很有规律！它是一堆交替的区间组成的（这里的区间是值域意义上的），如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/r7uxqjzf.png)

因此，只需要在处理每一位时，都求出这样的交替区间的前缀和，查询时就能 $O(1)$ 了。

具体来说，设 $cnt_x$ 表示有多少个 $s_i = x$。在我们考虑第 $i$ 位时，区间长度 $t=2^i$，$f_v$ 表示 $(v - 2t, v - t], (v - 4t, v - 3t], (v-6t,v-5t]\cdots$ 这些区间的 $cnt$ 的和。

最后还有一点：我们需要去掉 $0\le j < i$ 的限制，方法也很简单：把前缀桶换成全局桶，把有贡献的数对算两次，现在我们既要查询小于 $s_i$ 的又要查询大于 $s_i$ 的，维护一个前缀和，一个后缀和即可。这个地方可以看下面的暴力代码理解。

总复杂度 $O((n+V)\log V)$。

暴力代码（不加前缀和优化）：

```c++
    int n; cin >> n;
    vi a(n + 1), s(n + 1);
    F (i, 1, n) cin >> a[i];
    partial_sum(all(a), s.begin());
    F (i, 1, n) cnt[s[i]]++;
    int ans = 0;
    F (j, 0, 19) {
        int mx = s[n];
        int res = 0;
        F (i, 1, n)
        F (v, 0, mx) {
            if (abs(s[i] - v) & (1 << j)) {
                res += cnt[v];
            }
        }
        res /= 2;
        ans += (res & 1) << j;
    }
    F (i, 1, n) ans ^= s[i];
    cout << ans << '\n';

```

用前缀和优化后：

```c++
constexpr int maxn = 1e5 + 10, maxv = 1e6 + 10; 
int cnt[maxv], scnt[maxv];
int f[maxv], g[maxv];

#define val(p, t) ((t) >= 0 ? p[(t)] : 0)
#define val2(p, t) ((t) <= mx ? p[(t)] : p[mx])
#define val3(p, t) ((t) <= mx ? p[(t)] : 0)
// 处理边界

void OoO_main() {
    int n; cin >> n;
    vi a(n + 1), s(n + 1);

    F (i, 1, n) cin >> a[i];
    partial_sum(a.begin(), a.end(), s.begin());

    const int mx = s[n];
    
    F (i, 1, n) cnt[s[i]]++;
    partial_sum(cnt, cnt + mx + 1, scnt);
    
    int ans = 0;
    F (j, 0, 19) {
        int res = 0;
        fill(f, f + mx + 1); // 滚动数组节省空间
        F (i, 0, mx) {
            f[i] = val(f, i - (1 << (j + 1))) + val(scnt, i - (1 << j)) - val(scnt, i - (1 << (j + 1)));
        }
        DF (i, mx, 0) {
            g[i] = val3(g, i + (1 << (j + 1))) + val2(scnt, i + (1 << (j + 1)) - 1) - val2(scnt, i + (1 << j) - 1);
        }
        F (i, 1, n) {
            res += g[s[i]] + f[s[i]];
        }
        res /= 2;
        ans += (res & 1) << j;
    }

    F (i, 1, n) ans ^= s[i]; // 可能需要特殊处理一下区间和是 s[i] - s[0] 的情况
    cout << ans << '\n';
}
```

update on 2025.4.26：感谢管理员 Little_Cart 指出错误，并增加了一些补充说明。

---

## 作者：Nemlit (赞：4)

对于这种异或类的题目，我们可以考虑从异或运算性质下手

我们记$sum[i] = \sum_{j = 1} ^ {i}a[j]$

不难发现，如果我们对每一位分开考虑，若我们在求第x为的答案，记所有区间的连续的和有K个该位为1，那么跟据异或的运算法则，这一位对答案有贡献当且仅当K为奇数，且对答案的贡献为$K\ \%\ 2 * 2 ^ x$

说得更具体点，我们要求的式子变成了：

$$\sum_{k = 0} ^ {2 ^ k <= sum[n]}\ *\ ((\sum_{i = 1}^{n}\sum_{j = 1}^i(sum[i] - sum[j - 1]) >> k\ \&\ 1)\ \%\ 2)\ *\ 2 ^ k$$

我们单独看里面的柿子：
$$\sum_{i = 1}^{n}\sum_{j = 1}^i(sum[i] - sum[j - 1]) >> k\ \&\ 1$$

其实问题已经转化为：给定$sum[i]$，求有多少个$j(j\in[0,\ i - 1])$，满足$sum[i] - sum[j]$的第K位为1

这个问题看上去很好处理，貌似是只要求出有多少个$sum[i]$与$sum[j]$的第K位不同即可，我们只需要记录$sum[i] >> k$的一个前缀和即可。

但是这道题目十分弟弟，因为异或的减法是可以进位的，所以我们并不能直接向刚刚那么算。

为了方便，我们定义$sum[i]_k$表示$sum[i]$的第K位，$sum[i]_{1\ -\ k}$表示sum的1~k位 ~~（原谅我'~'打不出来）~~ 的和

我们先进行分类讨论：

一、如果$sum[i]_k = 1$，那么能对答案产生贡献只有两种情况：


$1.sum[j]_k = 0\ \&\&\ sum[j]_{1\  - \ k - 1} <= sum[i]_{1 - k - 1}$


$2.sum[j]_k = 1\ \&\&\ sum[j]_{1\ -\ k - 1} > sum[i]_{1\ -\ k - 1}$

二、如果$sum[i]_k = 0$，那么能对答案产生贡献也只有两种情况：

$1.sum[j]_k = 1\ \&\&\ sum[j]_{1\  - \ k - 1} <= sum[i]_{1 - k - 1}$


$2.sum[j]_k = 0\ \&\&\ sum[j]_{1\ -\ k - 1} > sum[i]_{1\ -\ k - 1}$

那么现在问题来了，我们怎么判断进位呢？

注意到$\sum a[i]$不会太大

我们可以把$sum[i]_{1\ -\ k - 1}$扔到两颗权值树状数组内，一棵存0的，另一颗存1的

注意：树状数组的下标可能为0，所以我们要把所有下标+1

# $Code:$
```
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<cstdlib>
using namespace std;
#define il inline
#define re register
#define int long long
il int read() {
    re int x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
#define rep(i, s, t) for(re int i = s; i <= t; ++ i)
#define mem(k, p) memset(k, p, sizeof(k))
#define lb(x) (x)&(-(x))
#define maxn 1000005
int n, m, a[maxn], sum[maxn], ma, Ans, ans;
struct Tree {
	int t[maxn];
	il void add(int u, int v, int x) {
		while(u <= x) t[u] += v, u += lb(u);
	}
	il void Add(int u, int v, int x) {
		add(u + 1, v, x + 1);
	}
	il int query(int u) {
		int ans = 0;
		while(u) ans += t[u], u -= lb(u);
		return ans;
	}
	il int query(int l, int r) {
		return query(r + 1) - query(l);
	}
}A, B;//A表示0的树状数组，B表示1的 
signed main() {
	n = read();
	rep(i, 1, n) a[i] = read(), sum[i] = sum[i - 1] + a[i], ma = max(ma, sum[i]);
	for(re int k = 0; (1 << k) <= ma; ++ k) {
		memset(A.t, 0, sizeof(A.t)), memset(B.t, 0, sizeof(B.t)), Ans = 0;
		int pax = (1 << k) - 1;//我们只考虑1~k位 
		rep(i, 0, n) {
			int temp = sum[i] & pax;//求出sum[i]_{1-k}
			//cout << k << ' ' << temp << endl;
			if((sum[i] >> k) & 1) {
				Ans += A.query(0, temp) + B.query(temp + 1, pax), B.Add(temp, 1, pax);
			}
			else {
				Ans += B.query(0, temp) + A.query(temp + 1, pax), A.Add(temp, 1, pax);
			}
		}
		//cout << Ans << ' ' << ans << endl;
 		ans += (Ans % 2) * (1 << k);
	}
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：lemondinosaur (赞：3)

# 题目
给定$n$个数，求它们所有区间的连续和的异或值

---
# 分析
一定要把异或拆开，可以得到答案是
$$\sum_{k=0}^{2^k\leq s_n}2^k\times ((\sum_{i=1}^n\sum_{j=0}^{i-1}((s[i]-s[j])>>k)\bmod 2)\bmod 2)$$
恭喜得到了一个比$O(n^2)$还要慢的算法，所以
$k$和$i$想要优化可能很困难，那么考虑优化$j$
当$s[i]$的第$k$位为1时，能产生影响的情况：

 1. 第$k$位不是1且前$k-1$位$\leq s[k]$的前$k-1$位
 2. 第$k$位是1且前$k-1$位$>s[k]$的前$k-1$位

当$s[i]$的第$k$位为0时，能产生影响的情况：

 1. 第$k$位不是1且前$k-1$位$>s[k]$的前$k-1$位
 2. 第$k$位是1且前$k-1$位$\leq s[k]$的前$k-1$位
 
那么这可以用树状数组记录$s$中二进制位上0或1的个数，从而把时间优化到$O(nlog^2s[n])$
但是要注意树状数组记录的可能是0，所以要整体右移一位，而且貌似不用long long，而且树状数组要注意清空

---
# 代码
```cpp
#include <cstdio>
#include <cctype>
#include <cstring>
#define rr register
using namespace std;
inline signed iut(){
    rr int ans=0; rr char c=getchar();
    while (!isdigit(c)) c=getchar();
    while (isdigit(c)) ans=(ans<<3)+(ans<<1)+(c^48),c=getchar();
    return ans; 
}
int n,s[100001],lim,ans;
struct szsz{
    int c[1000101];
    inline void add(int x,int y){for (++x;x<=lim+1;x+=-x&x) c[x]+=y;}
    inline signed answ(int x){rr int ans=0; for (++x;x;x-=-x&x) ans+=c[x]; return ans;}
    inline signed aasw(int l,int r){return answ(r)-answ(l);}
}c0,c1;
signed main(){
    n=iut();
    for (rr int i=1;i<=n;++i) s[i]=s[i-1]+iut();
    for (rr int k=0;(1<<k)<=s[n];++k){
        lim=(1<<k)-1; rr int sum=0;
        for (rr int i=0;i<=n;++i){
            rr int now=s[i]&lim;
            if ((s[i]>>k)&1) sum+=c0.aasw(-1,now)+c1.aasw(now,lim),c1.add(now,1);
                else sum+=c1.aasw(-1,now)+c0.aasw(now,lim),c0.add(now,1);
        }
        ans+=(1<<k)*(sum&1),memset(c0.c,0,sizeof(c0.c)),memset(c1.c,0,sizeof(c1.c));
    }
    return !printf("%d",ans);
}
```
       

---

## 作者：小塘空明 (赞：2)

统计异或和，很容易知道应该从按位贪心上考虑。

假设连续和在该位异或出1的对数是奇数，那么就将它统计入答案里。

考虑在该位异或出1的对数

首先计算前缀异或数组s，讨论每一位k。

对于每一个s[i]，我们统计0<=j<i且s[j]^s[i]在k位为一的个数。

假设是s[i]第k位为一，那么只有当s[j]第k位为0且s[j]的前k-1位比它小或s[j]第k位为1且前k-1位比它大（即第k-1位向第k位借位）。

s[i]第k位位0则刚好相反。

对前k位的数的大小的比较取s[i]&(1<<k)-1的值即可。

我们可以用一个权值树状数组维护整个过程。

注意s[i]为0也能产生贡献，在树状数组内可以加上一个数来处理。


---

## 作者：Polarisx (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P3760)。

## 思路

问题就是求所有区间和的异或和，这种统计区间贡献问题不难想到分治，假设当前的分治区间为 $[l,r]$，区间中点为 $mid$，对 $[l,mid]$ 的 $a_i$ 做一遍后缀和得到 $sml$，对 $[mid+1,r]$ 的 $a_i$ 做一遍前缀和得到 $smr$，那么问题就转换成了求 $\oplus_{i\in [l,mid]} \oplus_{j\in[mid+1,r]}(sml_i+smr_j)$。

首先容易想到按位拆贡献，只需对每个位 $i$ 求出有多少个 $sml_j+smr_k(j\le k)$ 使得其和的第 $i$ 位上为 $1$。

不妨舍去 $i$ 位以后的位，那么 $sml_j+smr_k$ 的范围就在 $[0,2^i),[2^i,2^{i+1}),[2^{i+1},2^{i+1}+2^i),[2^{i+1}+2^i,2^{i+2})$ 其中之一，显然只有第 $2,4$ 个区间有贡献，剩下的问题就是对于一个已知的 $u$ 如何快速求出有多少个 $j,k(j\le k)$ 使得 $sml_j+smr_k\ge u$ 了，这是个经典的问题，排序双指针即可。

归并排序即可做到 $\mathcal O(n\log V)$。

总时间复杂度就是 $\mathcal O(n\log n\log V)$。


```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int Maxn=1e5+6;
int n;
int a[Maxn];
int b[Maxn],c[Maxn];
int sm[Maxn];

inline void mergesort(int t[],int l,int r,int i){
	int tot1=0,tot2=0;
	for(int j=l;j<=r;j++) 
		if(t[j]>>(i+1)&1) b[++tot1]=t[j]-(1<<(i+1)); 
		else c[++tot2]=t[j];
	merge(b+1,b+tot1+1,c+1,c+tot2+1,t+l);
}
inline int calc(int u,int L,int mid,int R){
    int r=R+1;int ret=0;
    for(int l=L;l<=mid;l++){
		while(sm[r-1]+sm[l]>=u and r-1>mid) --r;
		ret=ret^((R-r+1)&1);
	}
    return ret&1;
}

int solve(int l,int r){
	if(l>r) return 0;
	if(l==r) return a[l];
	int mid=l+r>>1,ret=0;
	sm[mid]=a[mid],sm[mid+1]=a[mid+1];
	for(int i=mid-1;i>=l;i--) sm[i]=sm[i+1]+a[i];
	for(int i=mid+2;i<=r;i++) sm[i]=sm[i-1]+a[i];

	sort(sm+l,sm+mid+1),sort(sm+mid+1,sm+r);
	for(int i=20;~i;i--){
		mergesort(sm,l,mid,i);
		mergesort(sm,mid+1,r,i);
        int u=1<<i;
        if((calc(u,l,mid,r)-calc(u*2,l,mid,r)+calc(u*3,l,mid,r))&1) ret^=(1<<i);
    }
	
	return solve(l,mid)^solve(mid+1,r)^ret;
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	printf("%d",solve(1,n));

	return 0;
}
```

---

## 作者：crashed (赞：1)

# 题目
&emsp;&emsp;[点这里](https://www.cnblogs.com/crashed/)看题目。   
# 分析  
&emsp;&emsp;显然要先计算前缀和$s$。    
&emsp;&emsp;同样地考虑按位计算贡献。假设当前枚举到了第$k$位，正在枚举第$i$个前缀和，设$x$的第$k$位为$b(x)$，后$k-1$位为$l(x)$。由于子区间和就是前缀和做差，我们就考虑什么情况下，前缀和$i$做差后在$k$位上为 1 。   
&emsp;&emsp;若$b(s_i)=0$，那么减数$t$需要满足：若$b(t)=1$，则$l(t)<l(x)$，得到差的 1 ；若$b(t)=0$，则$l(t)>l(x)$，得到退位的 1 。   
&emsp;&emsp;若$b(s_i)=1$，那么减数$t$需要满足：若$b(t)=1$，则$l(t)>l(x)$，得到退位的 1 ；若$b(t)$，则$l(t)<l(x)$，得到差的 1 。    
&emsp;&emsp;发现有贡献的情况对应了值域上的一段区间，因此我们可以用 BIT 维护区间和。时间$O(n\log_2n\log_2\sum a)$。  
# 代码
```cpp
#include <cstdio>
#include <cstring>

const int MAXN = 1e5 + 5, MAXA = 1e6 + 5;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MAX( const _T a, const _T b )
{
	return a > b ? a : b;
}

template<typename _T>
void swapp( _T &x, _T &y )
{
	_T t( x ); x = y, y = t;
}

int a[MAXN], s[MAXN];
int N, all;

struct PreSum
{
	int BIT[MAXA];
	
	PreSum() { memset( BIT, 0, sizeof BIT ); }
	void up( int &x ) const { x += x & ( -x ); }
	void down( int &x ) const { x -= x & ( -x ); }
	void update( int x, const int v ) { for( ; x <= all ; up( x ) ) BIT[x] += v; }
	int getSum( int x ) const { int ret = 0; for( ; x ; down( x ) ) ret += BIT[x]; return ret; }
	
	int operator () ( const int l, const int r ) const 
	{ 
		if( l > r ) return 0;
		int tr = getSum( r ), tl = getSum( l - 1 );
		return tr - tl;
	}
}One, Zero;

int main()
{
	read( N );
	int ans = 0, cnt, bit, low;
	for( int i = 1 ; i <= N ; i ++ ) read( a[i] ), all += a[i];
	for( int i = 1 ; i <= N ; i ++ ) s[i] = s[i - 1] + a[i];
	Zero.update( 1, 1 );
	for( int k = 1 ; k <= all ; k <<= 1 )
	{
		cnt = 0;
		for( int i = 1 ; i <= N ; i ++ )
		{
			bit = bool( s[i] & k ), low = s[i] & ( k - 1 );
			if( bit ) cnt += Zero( 1, low + 1 ), cnt += One( low + 2, k );
			else cnt += Zero( low + 2, k ), cnt += One( 1, low + 1 );
			if( bit ) One.update( low + 1, 1 );
			else Zero.update( low + 1, 1 );
			cnt &= 1;
		}
		if( cnt ) ans |= k;
		for( int i = 1 ; i <= N ; i ++ )
		{
			bit = bool( s[i] & k ), low = s[i] & ( k - 1 );
			if( bit ) One.update( low + 1, -1 );
			else Zero.update( low + 1, -1 );
		}
	}
	write( ans ), putchar( '\n' );
	return 0;
}
```


---

## 作者：周梅森 (赞：1)

我们可以从二进制角度，一位一位地考虑。

可以发现若有奇数个连续和的第k位为1，那么答案的第k位为1，否则为0。


因此可以想到用前缀和，当s[i]与s[j] (0<j<i) 的差的第k位为1时，这段连续和对答案的第k位有贡献。考虑第i个前缀和s[i]的第k位：


若这一位为1，那么s[j]需要满足第k位为0 **且前k-1位比s[i]前k-1位小** 或者 第k位为1 **且前k-1位比s[i]前k-1位大（错位相减）**。

若这一位为0，同理。


所以我们可以用两个树状数组分别维护1...maxn的数中第k位为1和0的个数，然后就可以求出答案的每一位了。



### 代码


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define lowbit(x) (x&(-x))
using namespace std;

int n,ans=0,a[100010],b[1000100][2],rest[100010];

void insert(int pos,int o){
    for(;pos<=1000010;pos+=lowbit(pos))b[pos][o]++;
}
int query(int pos,int o){
    int ret=0;
    for(;pos>0;pos-=lowbit(pos))ret+=b[pos][o];
    return ret;
}

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]),a[i]+=a[i-1];
    for(int i=0;i<=20;i++){
        if((1<<i)>a[n])break;
        memset(b,0,sizeof(b));
        int t,count=0;
        insert(1,0);
        for(int j=1;j<=n;j++){
            bool o=a[j]&(1<<i);
            t+=query(rest[j]+1,o^1);
            t+=query(1000010,o)-query(rest[j]+1,o);
            insert(rest[j]+1,o);
            if(o)rest[j]|=(1<<i);
            if(t&1)count^=1;
        }
        if(count)ans|=(1<<i);
    }
    printf("%d",ans);
    return 0;
}
```

---


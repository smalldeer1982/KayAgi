# [CTSC2017] 密钥

## 题目描述

一个密钥是一个长度为 n = 2k + 1 的字符串，它包含 1 个字母 X、k 个字母 A 和k 个字母 B。例如 k = 3 时，BAXABAB 就是一个密钥。

如下图所示，可以按顺时针顺序把这 2k+1 个字母排成一个圈：

 ![](https://cdn.luogu.com.cn/upload/pic/5481.png) 

在 k 个字母 A 中，有一部分可以定义为 “强的’’。具体来说，从 X 出发顺时针走到某个 A 时，如果途中 A 的数目**严格多于**B的数目，则称此字母 A 为强的。

对于上面的例子来说，顺时针方向从字母 X 数起第 1 个和第 2 个字母 A 是强的，而第 3 个字母 A 不是强的。

一个密钥的**特征值**就是其中包含的强的字母 A 的个数。

天才小朋友 KT 给出了一个结论：

假设 k 个字母 A 所在的位置已经固定，但是剩下的 k 个 B 和 1 个 X 的位置是未知的。（注意，满足这样要求的密钥一共有 k + 1 个，因为字母 X 还剩下 k + 1 个可能的位置。）

可以证明：所有这 k + 1 个可能的密钥的特征值是各不相同的，它们恰好为0, 1, 2, …, k。

下面的图是一个具体的示例，从左到右的四个子图中分别有 3 个，2 个，1 个，0个字母 A 是强的。

 ![](https://cdn.luogu.com.cn/upload/pic/5482.png) 

类似地，如果固定 k 个字母 B 的位置，那满足条件的所有 k + 1 个密钥的特征值也各不相同，恰好为 0, 1, …, k。

现在你需要解决以下三个问题：

1. 给定密钥中所有 A 的位置，当密钥的特征值为 0 时，请问 X 在哪个位置。

2. 给定密钥中所有 A 的位置，当密钥的特征值为 S 时，请问 X 在哪个位置。

3. 给定密钥中所有 B 的位置，当密钥的特征值为 S 时，请问 X 在哪个位置。

注意：字符串的 2k + 1 个字母的位置由 1 到 2k + 1 编号。


【例子 1】

假定 k = 3, S = 2。那么：

当 A 的位置是 {2,4,6} 且特征值为 0 时，X 的位置在 7；

当 A 的位置是 {2,4,6} 且特征值为 2 时，X 的位置在 3；

当 B 的位置是 {2,4,6} 且特征值为 2 时，X 的位置在 5。

【例子 2】

假定 k=9。S=7。那么：

当 A 的位置是 {3,4,5,9,10,12,13,16,19} 且特征值为 0 时，X 的位置在 14；

当 A 的位置是 {3,4,5,9,10,12,13,16,19} 且特征值为 7 时，X 的位置在 18；

当 B 的位置是 {3,4,5,9,10,12,13,16,19} 且特征值为 7 时，X 的位置在 17。


## 说明/提示

【样例解释】

第一个样例中, P 数组为 1 的元素的下标分别为 5, 6, 7, 8, 9。


【数据范围与约定】

对于 30% 的数据，k ≤ 10^3。

对于 50% 的数据，k ≤ 10^5。

对于 100% 的数据，k ≤ 10^7。

对于每个测试点, 得分为以下三部分得分之和：

1. 如果第一问回答正确，你将获得 3 分。

2. 如果第二问回答正确，你将获得 4 分。

3. 如果第三问回答正确，你将获得 3 分。

**如果你仅仅知道部分答案，请也务必按此格式要求输出三个数。否则你可能会因格式错误无法得分。**


## 样例 #1

### 输入

```
5
3344
2```

### 输出

```
10
1
2```

## 样例 #2

### 输入

```
500000
4545
234567```

### 输出

```
999992
246922
753067```

# 题解

## 作者：asuldb (赞：9)

[题目](https://www.luogu.org/problem/P3770)

一个显然的暴力就是枚举$\rm X$的位置，把$\rm A$视为$1$，$\rm B$视为$-1$，从这个位置开始求一遍前缀和，特征值即为所有前缀和大于$0$的$A$

我们对第一个空位置做一遍这个暴力，考虑一下$\rm X$移动会对其他位置的前缀和产生什么样的影响

如果移动到的位置原来是一个$\rm B$，相当于把这个$-1$放到了最后处理，于是前缀和数组整体$+1$

移动到的位置是一个$A$，那么除了这个$A$以外的前缀和少了最初的一个$+1$，整体$-1$，而$A$位置的前缀和再处理下一个位置的时候就变成了$pre_n-pre_i+pre_i-1$，又因为$pre_n=0$，所以变成了$-1$

于是我们维护一个桶，开一个指针表示当前$0$的位置，整体$+1,-1$可以直接移动指针，特殊修改直接结合当前指针的值在桶里修改即可

这样第一二问就做完了，第三问显然可以在用上述的方法模拟一遍，但是有这样一个结论，**一个$k$个$1$，$k$个$-1$组成序列，$k$个$1$中前缀和大于$0$的个数加上$k$个$-1$中前缀和小于$0$的个数等于$k$**

证明非常简单，当一个前缀和从$0$变大再变成$0$的过程中，$1$和$-1$的个数显然是相等的，等于这次前缀和“回归0”过程中的数的个数一半，其中所有$1$的前缀和必然是大于$0$的；前缀和从$0$变小再变成$0$同理，所以这个结论是正确的

于是对于第三问，我们只需要判断一下当前前缀和大于$0$（在第三问中对应了所有$B$的前缀和小于$0$的个数）是否等于$k-S$即可

代码

```cpp
#include<bits/stdc++.h>
#define re register
#define LL long long
const int maxn=2e7+5;
int p[maxn],pre[maxn],tax[maxn],np[maxn],id[maxn];
int seed,n,k,S,tot,now,ans1,ans2,beg,ans3;
inline int getrand() {
	seed=((seed*12321)^9999)%32768;
	return seed;
}
void generateData() {
	scanf("%d%d%d",&k,&seed,&S);
	int t=0;n=k*2+1;
	for( int i = 1; i <= n; ++i ) 
		p[i]=(getrand()/128)%2,t+=p[i];
	int i=1;
	while(t>k) {
		while(p[i]==0) ++i;
		p[i]=0;--t;
	}
	while(t<k) {
		while(p[i]==1) ++i;
		p[i]=1;++t;
	}
}
inline void calc(int pos) {
	if(tot==0) ans1=id[pos];
	if(tot==S) ans2=id[pos];
	if(tot==k-S) ans3=id[pos];
	if(ans1&&ans2&&ans3) {
		printf("%d\n%d\n%d\n",ans1,ans2,ans3);
		exit(0);
	}
}
int main() {
	generateData();
	for(re int i=1;i<=n;i++) if(!p[i]) {beg=i;break;}
	for(re int i=1;i<=n;i++) {
		id[i]=beg;np[i]=p[beg++];if(beg>n) beg=1;
	}
	for(re int i=2;i<=n;i++) pre[i]=(pre[i-1])+(np[i]?1:-1);
	for(re int i=2;i<=n;i++) if(np[i]) tax[pre[i]+k]++;
	for(re int i=k+1;i<=k+k;++i) tot+=tax[i];
	calc(1);now=k;
	for(re int i=2;i<=n;i++) 
		if(np[i]) ++now,tot-=tax[now],
			tax[pre[i]+k]--,tax[pre[i]+k-1]++;
		else tot+=tax[now],--now,calc(i);
	return 0;
}
```


---

## 作者：AC_Evil (赞：3)

题意：有一个起点X，求该起点的位置，满足从X顺时针走到每一个A时，走过的序列中A的数量比B的数量多的总数分别为0，S，k-S（三个问）。

为什么是k-S？因为第三问是B的特征值为S，则剩下的就是A，即A的特征值为k-S。

理解了这一题时，第一反应是求出一个序列S，该序列的S[i]表示从第1到第i位，A比B多的数量，以便判断A是不是“强的”。在求这个序列的时候，先假设所有空位都是B。

然后呢？枚举X的位置？

但在前面我们把X也假设成了B，如果枚举X的位置的话S序列的值是需要维护更新的。

画一个图也许能更好解释规律。

假设一个序列{0，0，1，1，1，0，0，1，0}，0表示未知的位置，1表示该位置是A。此时可以求出S={-1，-2，-1，0，1，0，-1，0，-1}，最后一位一定是-1。我们将S中的每一个元素按顺序点在坐标系中（数值表示纵坐标，为区分类型，将0（B）用红点，1（A）用蓝点）

![](https://cdn.luogu.com.cn/upload/pic/27377.png)

简单的观察发现，貌似能求出“强的”点A的数量，就是高于某条水平直线的蓝点个数。

但是要考虑X的位置。因为原数列S可以看作是第0个点为X（假设存在第0个点）的计算结果，如果是正常的情况，就要对S进行适当的修改。若其中第x个点是红点且为X，则在他之后的S'[x+i]（i>0）应该为S[x+i] - S[x]，如果S'[x+i]>0且x+i为蓝点，则说明第x+i位是满足“强的”一个A。将上式移项，即为S[x+i]>S[x]，此时右半边的特征值即为高于射线y=S[x]的蓝点个数。而x左边的S'[x-i]（i>0）应该为(S[n] - S[x]) + S[x-i]，改写该式得S'[x-i] = S[x-i] - S[x] - 1，同上，移项后，即为S[x-i] > S[x] + 1，此时左半边的总数即为高于射线y=S[x] + 1的蓝点个数。

取第7个点，这个点是红点，如果X在这里，则它的总数就是如图所示的一条折线上蓝点的个数。

![](https://cdn.luogu.com.cn/upload/pic/27378.png)

为了方便，在对待第X个点时，我们将X左边的每一个点降一个单位的高度（即满足i<x的Si减一）。此时折线就变成了如下的一条直线。

![](https://cdn.luogu.com.cn/upload/pic/27381.png)

然后统计>S[x]的蓝色点数即可。

直接求一个位置X为O(n)，总复杂度为O(n^2)，效率低下。可以利用前缀和优化至O(1)的复杂度。

先预处理每个y=i的蓝点数目，记作G[i]，再处理G[i]的前缀和，即H[i] = H[i+1] + G[i]，此时H[i]为>=S[i]的蓝点数量。在不修改点高度时，解即为H[S[x]+1]（去掉正好等于S[x]的解）。如果修改高度，从左往右处理每一个点，如果这个点是B，直接求答案。如果是A，S[i]将会减一，所以H[i]会减一。而其他的H将不会受到影响（想想看）。

并且题目说对于不同位置的X，一定有不同的总数（具体原因不再赘述）。

所以，这题就可以解决了。

主要代码（伪代码）：
```
for i = 1 -> n
	if (p[i] = 1) H[s[i]]--; //修改H即可，不必要修改s
	else if (H[s[i] + 1] = S) ans = i, break; //找到唯一解，退出程序
//大家都是dalao，就不放原代码了
```
预处理前面说的很详细，不放代码了。

此时总时间复杂度可以降到O(n)。

---

## 作者：居然有个高手 (赞：2)

考虑先解决第一个问题：我们先钦定第一个空位置为 X（记 X 的位置为 $p$），并算出前缀和（记作 $sum_i$）。那么当我们交换 X 与一个空位置上的 B 时（记 B 的位置为 $q$），会分段产生以下贡献：

$ \begin {cases}  sum_i=sum_i-(sum_q) & i \in [q,n]\cup[1,p) \\ sum_i=sum_i-(sum_q+1) & i\in[p,q) \end{cases}$

容易发现，最优的位置 $q$ 必然满足 $sum_q$ 最大的同时 $q$ 最大（让第二种情况的区间尽量大，减少的值就更多）。这样就解决了第一个问题。

考虑第二个问题，容易发现他其实就是要找出第 $S+1$ 优的 $q$，可以桶排解决。（最优的 $q$ 会使得特殊值为 $0$，那么第 $S+1$ 优的就会使得特殊值为 $S$）。

第三个问题事实上就是第二个问题的对偶问题，我们可以重新讨论交换 X 与 A 产生的分段贡献为：

$ \begin {cases}  sum_i=sum_i-(sum_q) & i \in [q,n]\cup[1,p) \\ sum_i=sum_i-(sum_q-1) & i\in[p,q) \end{cases}$

此时我们定义较大的 $q$ 为让特殊值尽量大的 $q$，则我们只要寻找第 $S+1$ 小的 $q$ 即可，同样桶排解决。

贴一份代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e7+5;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*f;
}
int p[20000005],sum[N<<1],cnt[N<<1];
int seed, n, k, S;
int getrand() {
	seed = ((seed * 12321) ^ 9999) % 32768;
	return seed;
}
void generateData() {
	scanf( "%d%d%d", &k, &seed, &S );
	int t = 0;
	n = k * 2 + 1;
	memset(p, 0, sizeof(p));
	for( int i = 1; i <= n; ++i ) {
		p[i] = (getrand() / 128) % 2;
		t += p[i];
	}
	int i = 1;
	while( t > k ) {
		while ( p[i] == 0 ) ++i;
		p[i] = 0;
		--t;
	}
	while( t < k ) {
		while( p[i] == 1 ) ++i;
		p[i] = 1;
		++t;
	}
}
int main(){
	generateData();
	int id=0;
	for(int i = 1;i<=n;i++){
		if(!p[i]){
			id=i;
			break;
		}
	}
	for(int i = id+1;i!=id;i=i%n+1){
		if(p[i])sum[i]=sum[i-1]+1;
		else sum[i]=sum[i-1]-1;
	}
	int maxn=0,now=id;
	for(int i = id;i<=n;i++){
		if(!p[i]){
			cnt[sum[i]+k]++;
			if(sum[i]>=maxn)maxn=sum[i],now=i;
		}
	}
	printf("%d\n",now);now=S+1;
	for(int i = n;i>=0;i--){
		if(now>cnt[i])now-=cnt[i];
		else {
			maxn=i-k;
			break;
		}
	}
	for(int i = n;i>=0;i--){
		if(!p[i]&&maxn==sum[i]){
			if(!(--now)){
				now=i;
				break;
			}
		}
	}
	printf("%d\n",now);
	memset(cnt,0,sizeof cnt);assert(sum[id]==0);
	for(int i = id+1;i!=id;i=i%n+1){
		if(p[i])sum[i]=sum[i-1]-1;
		else {
			sum[i]=sum[i-1]+1;
		}
	}
	for(int i = id;i<=n;i++){
		if(!p[i]){
			cnt[k-sum[i]]++;
		}
	}
	now=S+1;
	for(int i = 0;i<=n;i++){
		if(now>cnt[i])now-=cnt[i];
		else {
			maxn=k-i;
			break;
		}
	}
	for(int i = 1;i<=n;i++){
		if(!p[i]&&maxn==sum[i]){
			if(!(--now)){
				now=i;
				break;
			}
		}
	}
	printf("%d\n",now);
	return 0;
}

```

---

## 作者：_yi_ (赞：1)

# [CTSC2017] 密钥 题解
## 题目描述
本题要求解决关于一个特定排列的字符串（密钥）的三个问题。密钥是一个长度为 $ n = 2k + 1 $ 的字符串，包含 1 个字母 X、k 个字母 A 和 k 个字母 B。密钥可以按顺时针排成一个圈。题目定义了“强的”字母 A 的概念，并提出了密钥的“特征值”定义。基于这些定义，需要解决三个问题：给定 A 或 B 的位置，求特定特征值时的 X 位置。
## 题目分析

将 $A$ 记为 $1$，$B$ 记为 $-1$，则特征值转化为从 $X$ 开始前缀和大于 $0$ 的 $A$ 的个数。

若直接枚举 $X$ ，暴力地去统计前缀和大于 $0$ 的 $A$ 的个数，时间复杂度为 $O(n^2)$。

不难想到 $O(1)$ 维护当 $X$ 移动到下一位时，特征值的变化。

先以原序列顺序处理一遍前缀和。

每次$X$移动到下一位时，由于对整个序列加减是不优的，所以不难想到只需改变比较的基准值就可以。

维护前缀和大于 $X$ 的前缀和的 $A$ 的个数。只需开个桶就可以 $O(1)$ 维护当 $X$ 移动到下一位时，特征值的变化。

那么当特征值为 $1$ 和 $S$ 时标记一下当前的位置。

思考询问3，发现在这种情况下，特征值恰好等于 $\text{k-now}$ 。 (其中 $\text{now}$ 为现在的特征值)

同样标记一下即可。

时间复杂度 $O(n)$。

### 时间复杂度
整个算法的时间复杂度为 $ O(n) $，因为每个位置只需遍历一次。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int p[20000005];
int seed, n, k, S;
int getrand() {
	seed = ((seed * 12321) ^ 9999) & 32767;
	return seed;
}
void generateData() {
	cin>>k>>seed>>S;
	int t = 0;
	n = k * 2 + 1;
	memset(p, 0, sizeof(p));
	for( int i = 1; i <= n; ++i ) {
		p[i] = (getrand() >> 7) & 1;
		t += p[i];
	}
	int i = 1;
	while( t > k ) {
		while ( p[i] == 0 ) ++i;
		p[i] = 0;
		--t;
	}
	while( t < k ) {
		while( p[i] == 1 ) ++i;
		p[i] = 1;
		++t;
	}
}
int sum[40000005];
// bool flag[20000005];
int ans1,ans2,ans3;
int main() {
    cin.tie(0),cout.tie(0),ios::sync_with_stdio(0);
    // freopen("data.in","r",stdin);
    // cin>>k>>S;
    // n=k*2+1;
    // for(int i=1;i<=n;i++){
    //     cin>>p[i];
    // }
	generateData();
    // for(int i=1;i<=k;i++){
    //     flag[p[i]]=1;
    // }
    int now=0;
    for(int i=1;i<=n;i++){
        if(p[i]){
            now++;
        }
        else{
            now--;
        }
        sum[n+now]+=p[i];
    }
    int cnt=0;
    for(int i=1;i<=n;i++){
        cnt+=sum[i+n];
    }
    int last=1;
    // cout<<cnt<<endl;
    for(int i=1;i<=n;i++){
        if(p[i]){
            now++;
        }
        else{
            now--;
        }
        if(last>now+2){
            cnt+=sum[n+now+2];
        }
        else if(last<now+2){
            cnt-=sum[n+last];
        }
        if(cnt==0&&!p[i]){
            ans1=i;
        }
        if(cnt==S&&!p[i]){
            ans2=i;
        }
        if(cnt==k-S&&!p[i]){
            ans3=i;
        }
        if(ans1&&ans2&&ans3){
            break;
        }
        // cout<<cnt<<endl;
        sum[n+now+1]-=p[i];
        sum[n+now]+=p[i];
        last=now+2;
    }
    cout<<ans1<<endl<<ans2<<endl<<ans3<<endl;
	return 0;
}
```

---


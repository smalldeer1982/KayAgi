# 旅行规划

## 题目描述

OIVillage 是一个风景秀美的乡村，为了更好的利用当地的旅游资源，吸引游客，推动经济发展，xkszltl 决定修建了一条铁路将当地 $n$ 个最著名的景点连接起来，让游客可以通过火车从铁路起点（1 号景点）出发，依次游览每个景区。为了更好的评价这条铁路，xkszltl 为每一个景区都赋予了一个美观度，而一条旅行路径的价值就是它所经过的景区的美观度之和。不过，随着天气与季节的变化，某些景点的美观度也会发生变化。

xkszltl 希望为每位旅客提供最佳的旅行指导，但是由于游客的时间有限，不一定能游览全部景区，然而他们也不希望旅途过于短暂，所以每个游客都希望能在某一个区间内的车站结束旅程，而 xkszltl 的任务就是为他们选择一个终点使得旅行线路的价值最大。可是当地的景点与前来观光的旅客实在是太多了，xkszltl 无法及时完成任务，于是找到了准备虐杀 NOI2011 的你，希望你能帮助他完成这个艰巨的任务。


## 说明/提示

$n,m \leq 100000$。

## 样例 #1

### 输入

```
5
1 8 -8 3 -7
3
1 1 5
0 1 3 6
1 2 4```

### 输出

```
9
22```

# 题解

## 作者：hzoi_liuchang (赞：10)

## 分析
转化一下题意

区间加等差数列，查询区间最大值

如果是单点查询的话，可以在线段树上打一个标记，边查询边下放

但是区间查询的话需要整棵树下放标记，复杂度太高

考虑万能的分块做法

因为等差数列加等差数列还是还是一个等差数列

所以对每一个块维护等差数列的首项 $beg$ 以及公差 $d$

这样，一个块内所有点的值都可以写成与下标相关的一次函数的形式

即 $ans[i]=i \times d+sum[i]$

$sum[i]=ans[i]-i \times d$

其中 $sum[i]$ 为上一次重构后 $i$ 处前缀和的值

对于整个块的首项，我们先不去考虑，最后把它加上即可

这样，我们就可以把下标 $i$ 看成横坐标，把 $sum[i]$ 看成纵坐标，把 $-d$ 看成斜率

如果是对整个块进行修改，那么横纵坐标都是不变的

变化的只是斜率 

因此可以维护一个上凸壳

在上凸壳中二分查找使截距 $ans[i]$ 最大的点

如果是对块的一部分进行修改或查询，我们就把这个块进行暴力重构，重新建一个凸包

如果块长是 $\sqrt{n}$ 的话

复杂度就是 $m\sqrt{n}log\sqrt{n}$
## 代码
``` cpp
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<vector>
#define rg register
inline int read(){
	rg int x=0,fh=1;
	rg char ch=getchar();
	while(ch<'0' || ch>'9'){
		if(ch=='-') fh=-1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9'){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*fh;
}
const int maxn=1e5+5;
typedef double db;
const db eps=1e-18;
struct Node{
	int x;
	long long y;
	Node(){}
	Node(rg int aa,rg long long bb){
		x=aa,y=bb;
	}
	friend bool operator < (const Node& A,const Node& B){
		if(A.x==B.x) return A.y<B.y;
		else return A.x<B.x;
	}
};
int shuyu[maxn],blo,n,m,l[maxn],r[maxn],tp,tail;
std::vector<Node> ans[maxn];
Node sta[maxn],que[maxn];
long long beg[maxn],sum[maxn],d[maxn];
inline double xl(rg Node aa,rg Node bb){
	if(std::fabs((double)bb.x-(double)aa.x)<eps){
		if(std::fabs((double)bb.y-(double)aa.y)<eps) return 0;
		else if(bb.y>aa.y) return 1e18;
		else return -1e18;
	}
	return ((double)bb.y-(double)aa.y)/((double)bb.x-(double)aa.x);
}
void build(rg int id){
	if(d[id]){
		for(rg int i=l[id];i<=r[id];i++) sum[i]+=1LL*d[id]*(i-l[id]+1);
		d[id]=0;
	}
	if(beg[id]){
		for(rg int i=l[id];i<=r[id];i++) sum[i]+=beg[id];
		beg[id]=0;
	}
	tp=tail=0;
	ans[id].clear();
	for(rg int i=l[id];i<=r[id];i++) sta[++tp]=Node(i-l[id]+1,sum[i]);
	std::sort(sta+1,sta+tp+1);
	for(rg int i=1;i<=tp;i++){
		while(tail>1 && xl(que[tail],sta[i])>=xl(que[tail-1],que[tail])) tail--;
		que[++tail]=sta[i];
	}
	for(rg int i=1;i<=tail;i++) ans[id].push_back(que[i]);
}
void xg(rg int nl,rg int nr,rg int val){
	for(rg int i=nl;i<=std::min(r[shuyu[nl]],nr);i++){
		sum[i]+=1LL*val*(i-nl+1);	
	}
	for(rg int i=nr+1;i<=r[shuyu[nr]];i++){
		sum[i]+=1LL*val*(nr-nl+1);
	}
	for(rg int i=shuyu[nr]+1;i<=shuyu[n];i++){
		beg[i]+=1LL*val*(nr-nl+1);
	}
	build(shuyu[nl]);
	if(shuyu[nl]==shuyu[nr]) return;
	for(rg int i=l[shuyu[nr]];i<=nr;i++){
		sum[i]+=1LL*val*(i-nl+1);
	}
	build(shuyu[nr]);
	for(rg int i=shuyu[nl]+1;i<=shuyu[nr]-1;i++){
		beg[i]+=1LL*(l[i]-nl)*val;
		d[i]+=val;
	}
}
long long qjcx(rg int id){
	rg int nl=1,nr=ans[id].size(),mids;
	rg double nans=-1.0*d[id];
	while(nl<nr){
		mids=(nl+nr)>>1;
		if(xl(ans[id][mids-1],ans[id][mids])<=nans) nr=mids;
		else nl=mids+1;
	}
	nl--;
	return (long long)ans[id][nl].y+(long long)d[id]*ans[id][nl].x+(long long)beg[id];
}
long long cx(rg int nl,rg int nr){
	build(shuyu[nl]);
	rg long long nans=-0x3f3f3f3f3f3f3f3f;
	for(rg int i=nl;i<=std::min(r[shuyu[nl]],nr);i++) nans=std::max(nans,sum[i]);
	if(shuyu[nl]==shuyu[nr]) return nans;
	build(shuyu[nr]);
	for(rg int i=l[shuyu[nr]];i<=nr;i++) nans=std::max(nans,sum[i]);
	for(rg int i=shuyu[nl]+1;i<=shuyu[nr]-1;i++){
		nans=std::max(nans,qjcx(i));
	}
	return nans;
}
int main(){
	memset(l,0x3f,sizeof(l));
	n=read();
	blo=sqrt(n);
	for(rg int i=1;i<=n;i++) shuyu[i]=(i-1)/blo+1;
	for(rg int i=1;i<=n;i++) sum[i]=read();
	for(rg int i=1;i<=n;i++) sum[i]+=sum[i-1];
	for(rg int i=1;i<=n;i++){
		l[shuyu[i]]=std::min(l[shuyu[i]],i);
		r[shuyu[i]]=std::max(r[shuyu[i]],i);
	}
	for(rg int i=1;i<=shuyu[n];i++) build(i);
	m=read();
	rg int aa,bb,cc,dd;
	for(rg int i=1;i<=m;i++){
		aa=read(),bb=read(),cc=read();
		if(aa==0){
			dd=read();
			xg(bb,cc,dd);
		} else {
			printf("%lld\n",cx(bb,cc));
		}
	}
	return 0;
}
```

---

## 作者：ddwqwq (赞：4)

难得遇见一道没看题解AC的题，又恰好没有题解，赶紧自己写一个纪念一下。前置知识：分块、半平面交。不会的同学可以自行查找资料。  
一句话题意：有一个长度为$n$的序列和$m$个操作，分别是区间加法和查询区间内最大前缀和。数据范围$1e5$。  
如果是单点修改，直接线段树即可对付。但是对于区间修改，线段树就无法胜任了。甚至这道题未必有$nlogn$级的算法。  
于是我们考虑分块。显然，我们只要有办法处理全局加法，就可以轻松设计一个根号级的分块算法。令$S_{i}$表示初始时第$i$个位置的前缀和。我们可以发现，在全局加x的情况下，第$i$个位置的前缀和为$ix+S_{i}$，是一个一次函数。于是，我们可以用半平面交维护一个凸壳，查询时直接在凸壳上二分就可以了。由于$i$单调递增，我们只要把这些直线依次加入单调栈即可。  
有了上面的思路，对于本题要求的区间加法，我们也很容易解决了。用一个树状数组维护每个位置的值，并且把序列分成根号个块，每个块内对于本块内的数据按照上一段的方法维护一个凸壳。查询时只要加上前面块的前缀和就是本区间的答案。不完整的块直接暴力扫一遍树状数组。  
对于修改操作，完整的块打一个标记表示当前加了多少，不完整的块直接查询树状数组重建并且把标记清零。  
时间复杂度：  
修改：整块$O(1)$,不完整的块$O(\sqrt{n}logn)$  
查询：整块和不完整的块都是$O(\sqrt{n}logn)$  
所以总的时间复杂度是$O(m\sqrt{n}logn)$。~~没想到开了O2最大的点也才用了不到一秒~~  
其实这一道题可以看作著名的[ P4680 [Ynoi2018]末日时在做什么?有没有空?可以来拯救吗?](https://www.luogu.org/problemnew/show/P4680)的大幅削弱版。  
下面是代码，对了，记得开long long和注意四舍五入
```
#include <cstdlib>
#include <iostream>
#include <cstdio>
#include <math.h>
#include <cstring>
#include <time.h>
#include <utility>

#pragma warning(disable:4996)
#define INF 200000000000005//2 * 10^9
#define lowbit(a) ((a)&-(a))
inline long long max(long long a, long long b)
{
    return a > b ? a : b;
}
inline long long min(long long a, long long b)
{
    return a < b ? a : b;
}

const long long MAXN = 100005;
const long long B = 300;

struct line {
    double k;
    double b;
    line(double K = 0, double B = 0)
    {
        k = K;
        b = B;
    }
    double calc(double x)
    {
        return k*x + b;
    }
    double inter(line t)
    {
        return (t.b - b) / (k - t.k);
    }
};

struct BLOCK {
    line q[B];
    long long l, r;
    void clear()
    {
        l = r = 0;
    }
    void init(long long *a, int L, int R)
    {
        clear();
        for (int i = L + 1; i <= R; i++)
            a[i] += a[i - 1];
        for (int i = L; i <= R; i++)
        {
            line t(i - L + 1, a[i]);
            while (r - l > 1 && q[r - 2].inter(q[r - 1]) > t.inter(q[r - 2]))
                r--;
            q[r++] = t;
        }
    }
    double query(long long k)
    {
        if (q[0].inter(q[1]) > k)
            return q[0].calc(k);
        if (q[r - 2].inter(q[r - 1]) < k)
            return q[r - 1].calc(k);

        long long a = l, b = r - 2;
        while (b - a > 1)
        {
            int mid = (a + b) / 2;
            if (q[mid].inter(q[mid + 1]) > k)
                b = mid;
            else
                a = mid;
        }
        return q[b].calc(k);
    }
};

struct tree {
private:
    long long e[MAXN];
    void update(long long id, long long k)
    {
        while (id < MAXN)
        {
            e[id] += k;
            id += lowbit(id);
        }
    }
public:
    void update(long long l, long long r, long long k)
    {
        update(l, k);
        update(r + 1, -k);
    }
    long long query(long long id)
    {
        long long ans = 0;
        while (id > 0)
        {
            ans += e[id];
            id -= lowbit(id);
        }
        return ans;
    }
};

long long N, M;
tree T;
long long a[MAXN], b[MAXN];
long long L[500], R[500], add[500], sum[500], cnt;
BLOCK block[500];

void init()
{
    scanf("%lld", &N);
    for (cnt = 1; ; cnt++)
    {
        L[cnt] = R[cnt - 1] + 1;
        R[cnt] = R[cnt - 1] + B;
        if (R[cnt] > N)
            R[cnt] = N;
        for (long long i = L[cnt]; i <= R[cnt]; i++)
            b[i] = cnt;
        if (R[cnt] == N)
            break;
    }

    for (long long i = 1; i <= N; i++)
    {
        scanf("%lld", a + i);
        sum[b[i]] += a[i];
        T.update(i, i, a[i]);
    }
    scanf("%lld", &M);

    for (long long i = 1; i <= cnt; i++)
    {
        block[i].init(a, L[i], R[i]);
        sum[i] += sum[i - 1];
    }
}

void update(long long l, long long r, long long k)
{
    T.update(l, r, k);
    for (long long i = b[l]; i <= cnt; i++)
        sum[i] += (min(R[i], r) - l + 1)*k;
    for (long long i = b[l] + 1; i < b[r]; i++)
        add[i] += k;

    for (long long i = L[b[l]]; i <= R[b[l]]; i++)
        a[i] = T.query(i);
    add[b[l]] = 0;
    block[b[l]].init(a, L[b[l]], R[b[l]]);

    if (b[l] == b[r])
        return;

    for (long long i = L[b[r]]; i <= R[b[r]]; i++)
        a[i] = T.query(i);
    add[b[r]] = 0;
    block[b[r]].init(a, L[b[r]], R[b[r]]);
}

long long F(double x)
{
    return (long long)(x > 0 ? x + 0.5 : x - 0.5);
}

long long query(long long l, long long r)
{
    long long ans = -INF, t;
    long long i;

    for (i = b[l] + 1; i < b[r]; i++)
        ans = (long long)max(ans, F(block[i].query(add[i]) + sum[i - 1]));
    t = 0;
    for (i = L[b[l]]; i <= min(R[b[l]], r); i++)
    {
        t += T.query(i);
        if (i >= l)
            ans = (long long)max(ans, t + sum[b[l] - 1]);
    }

    if (b[l] == b[r])
        return ans;

    t = 0;
    for (i = L[b[r]]; i <= r; i++)
    {
        t += T.query(i);
        ans = (long long)max(ans, t + sum[b[r] - 1]);
    }

    return ans;
}

int main()
{
    long long i;
    long long op, x, y, k;

    init();

    for (i = 0; i < M; i++)
    {
        scanf("%lld %lld %lld", &op, &x, &y);
        if (op)
            printf("%lld\n", query(x, y));
        else
        {
            scanf("%lld", &k);
            update(x, y, k);
        }
    }

//	system("pause");
    return 0;
}
```

---

## 作者：Thosaka_Forest (赞：3)

文章同时发表于我的CSDN上：[传送门](https://blog.csdn.net/g21glf/article/details/86629448)

常数巨大警告qwq。

这道题其实题意很简单，维护一个序列，支持区间加，区间查询最大前缀和。

因为是查询前缀和所以直接维护一个区间和，区间加就变成了区间加首项为k、公差为k的等差数列。

因为一个等差数列+一个等差数列还是一个等差数列，所以这样做是正确的。

所以就有两个选择：线段树和分块，但考虑到线段树最后合并效率低下，所以选分块（结果不知道为啥我的写法常数贼大）

所以就开3个数组，分别维护每个块的等差数列首项、公差以及一个add标记。

区间加的时候遇上整块直接加在首项和公差上，查询时直接返回（当前值+块首项+公差*（当前位置-块左端位置）+add）即可。

那么怎么查询一个整块的前缀和最大值？

如果将区间内所有点放在平面上，坐标为（下标，前缀和），那么可以发现，最大的前缀和所对应的点一定是在凸包上且一定是最高点，可以直接二分。

所以直接对每个块暴力维护其凸包。

然后就是一些小细节。

注意每次update完后要在belong[y]+1~num的块的add数组打标记，因为前面的区间加对前缀和有(y-x+1)*k的影响。

同时，要在将y+1~r[belong[y]]更新完后再维护凸包。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int MAXN=1e5+10;
const int MAXM=350;
const LL INF=1e18;

int n,q;
LL a[MAXN];
int num,siz;
int belong[MAXN],l[MAXM],r[MAXM];
LL sx[MAXM],gc[MAXM],add[MAXM];
int sta[MAXM],top;
int cov[MAXM][MAXM];
int cnt[MAXM];

LL Read(){
	LL i=0,f=1;
	char c;
	for(c=getchar();(c>'9'||c<'0')&&c!='-';c=getchar());
	if(c=='-')
	  f=-1,c=getchar();
	for(;c>='0'&&c<='9';c=getchar())
	  i=(i<<3)+(i<<1)+c-'0';
	return i*f;
}

double xl(int x,int y){                //求斜率 
	return (double)((a[x]-a[y])/(x-y));
}

void build(int x){                     //暴力维护凸包 
	top=0;
	sta[++top]=l[x];
	for(int i=l[x]+1;i<=r[x];++i){
		while(top>=2&&xl(sta[top-1],sta[top])<xl(sta[top-1],i))
		  top--;
		sta[++top]=i;
	}
	sta[0]=0,sta[top+1]=n+1;           //将凸包中的点记录下，二分用 
	cnt[x]=top;
	for(int i=0;i<=top+1;++i)
	  cov[x][i]=sta[i];
}

void fk(){                            //分块 
	siz=sqrt(n);
	num=n/siz;
	if(n%siz)
	  num++;
	for(int i=1;i<=n;++i)
	  belong[i]=(i-1)/siz+1;
	for(int i=1;i<num;++i){
		l[i]=(i-1)*siz+1;
		r[i]=i*siz;
	}
	l[num]=r[num-1]+1;
	r[num]=n;
	for(int i=1;i<=num;++i){
		build(i);                     //将每个块的凸包求出来 
	}
}

void push_now(LL x){
	LL t=sx[x];
	for(int i=l[x];i<=r[x];++i){
		a[i]+=t;
		t+=gc[x];
		a[i]+=add[x];
	}
	sx[x]=gc[x]=add[x]=0;
}

void update(int x,int y,LL k){
	LL sum;
	if(belong[x]==belong[y]){         //属于同一个块 
		push_now(belong[x]);          //先把标记下放 
		sum=k;
		for(int i=x;i<=y;++i){
			a[i]+=sum,sum+=k;         //暴力加等差数列 
		}
		sum=k*(y-x+1);
		for(int i=y+1;i<=r[belong[y]];++i)//先将当前块更新完 
		  a[i]+=sum;
		build(belong[x]);
		for(int i=belong[x]+1;i<=num;++i)//记得打标记 
		  add[i]+=sum;
		return ;
	}
	sum=k*(l[belong[x]+1]-x+1);
	for(int i=belong[x]+1;i<belong[y];++i){//整块打标记 
		sx[i]+=sum,gc[i]+=k;
		sum+=siz*k;
	}
	push_now(belong[x]);
	sum=k;
	for(int i=x;i<=r[belong[x]];++i){
		a[i]+=sum;
		sum+=k;
	}
	build(belong[x]);
	push_now(belong[y]);
	sum=k*(l[belong[y]]-x+1);
	for(int i=l[belong[y]];i<=y;++i){
		a[i]+=sum;
		sum+=k;
	}
	sum=k*(y-x+1);
	for(int i=y+1;i<=r[belong[y]];++i)
	  a[i]+=sum;
	build(belong[y]);
	for(int i=belong[y]+1;i<=num;++i)
	  add[i]+=sum;
}

LL calc(int x){
	if(x==0||x==n+1)
	  return -INF;
	return a[x]+sx[belong[x]]+gc[belong[x]]*(x-l[belong[x]])+add[belong[x]];
}

LL query(int x){
	int head=1,tail=cnt[x],mid;
	while(head<=tail){                //二分 
		mid=head+tail>>1;
		LL a1=calc(cov[x][mid-1]),a2=calc(cov[x][mid]),a3=calc(cov[x][mid+1]);
		if(a1<a2&&a2<a3)
		  head=mid+1;
		else{
			if(a1>a2&&a2>a3)
			  tail=mid-1;
			else
			  return a2;
		}
	}
}

int main(){
	n=Read();
	for(int i=1;i<=n;++i){
		a[i]=Read();
		a[i]+=a[i-1];
	}
	a[0]=a[n+1]=-INF;
	fk();
	q=Read();
	while(q--){
		int cz=Read(),x=Read(),y=Read();
		if(cz==0){
			LL k=Read();
		  	update(x,y,k);
		}
		else{
			LL ans=-INF;
			if(belong[x]==belong[y]){
				for(int i=x;i<=y;++i)
				  ans=max(ans,calc(i));
				cout<<ans<<'\n';
				continue;
			}
			for(int i=belong[x]+1;i<belong[y];++i)
			  ans=max(ans,query(i));
			for(int i=x;i<=r[belong[x]];++i)
			  ans=max(ans,calc(i));
			for(int i=l[belong[y]];i<=y;++i)
			  ans=max(ans,calc(i));
			cout<<ans<<'\n';
		}
	}
}
```

---

## 作者：LEMON_dasiy (赞：1)

### 题意：
维护一个队列，支持区间加、查询最大前缀和操作。
### 思路：
看了数据范围和区间加操作后就直接想到两个算法：线段树/分块。但是线段树合并太费时间了（虽然我也没试过），所以考虑分块。  
然后可以把区间加上的 $x$ 想成区间加上一个形似 $x,x,x\cdots $ 的序列，同时这也是一个等差数列，有结论：一个等差数列加上另一个等差数列还是一个等差数列。  
然后整个数列都可以表示出来：
$$ans_i=i\times k+sum_i$$
解释：$ans_i$ 为要查找的点，$k$ 为公差，$sum_i$ 为为上一次重构后 $i$ 处前缀和的值。  
可得：
$$sum_i=ans_i-i\times k$$
这样，我们就可以把下标 $i$ 看成横坐标，把 $sum_i$ 看成纵坐标，把 $−d$ 看成斜率，如果是对整个块进行修改，那么横纵坐标都是不变的，变化的只是斜率，因此可以维护一个上凸壳，在上凸壳中二分查找使截距 $ans_i$ 最大的点。  
这样就是单步查询，然后每一次查询都暴力重构就可以了。  
时间复杂度为 $O(m\sqrt n \log\sqrt n)=O(m\sqrt n \log n)$（块的大小为 $\sqrt n$）。  
然后就结束了。  
### 代码：
@[yuruilin2026](https://www.luogu.com.cn/user/1294410) 和 @[Hootime](https://www.luogu.com.cn/user/1275540) l两个神犇认为紫题非常简单不需要代码。

---

## 作者：AbioAg (赞：1)

这里是一篇摒弃了把题意转化成区间加等差数列解法的题解。

题意：区间加，区间最大前缀和。

首先容易想到对于询问 $(l,r)$，$(1,l-1)$ 的部分显然无关紧要，只需要求出来这部分的值即可，考虑直接数据结构维护求出来，笔者这里写的是常数比较小的树状数组。

接下来就转化成给定询问 $(l,r)$，求 $(l,r)$ 部分最大前缀和，这里数据结构就不太好维护了。

考虑到前缀和的形式是契合分块的，对修改可以散块暴力，整块打标记，对于查询散块暴力，整块直接带着标记加就好了。

但是对于选择在某些块内部为终止点的情况是不太好处理的，但此种情况下我们取值一定是终止块内的最大前缀和。

考虑维护 $Sum$ 数组，表示某数从其所属块内算起的前缀和的值，同时我们还具有 $tg$ 数组，表示整块的标记，那么不难得出对应位置的数值 $Ans_i=Sum_i+tg_i\times a$，其中 $a$ 为 $i$ 在对应块中的 $rk$，发现这恰好符合凸包的形式，那么我们对于每个块维护其凸包，需要取出整块内最大值时二分得出答案即可。

为了维护凸包我们还要在修改散块的时候暴力重构一下凸包。

同时此种做法的标记不需要下放，很优雅，很好写。

复杂度 $O(n\sqrt n\log n)$。

[code](https://www.luogu.com.cn/paste/izpmhgf0)

---

## 作者：Aaronwrq (赞：0)

做法来源： [P4118 [Ynoi2018] 末日时在做什么？有没有空？可以来拯救吗？](https://www.luogu.com.cn/problem/P4118)

本题存在时间复杂度 $O(n\sqrt{n})$ 的解法。

下面假设 $n$ 与 $m$ 同阶。

思路和 $O(n\sqrt n\log n)$ 的做法相同：先分块，然后对每块维护凸包，询问时在凸包上二分。
发现对于 $k$ 单调递增的询问，其在凸包上的决策点单调不降。如果所有询问的 $k$ 单调递增，我们就可以用一个指针从左往右扫描凸包，去掉二分的 $\log$。

发现一个修改和询问可以拆到每一块上分别完成，于是可以先枚举块，然后一次性处理涉及到这个块的所有操作。

考虑所有可能的操作：

整块修改：对块维护整块 $k$ 与 $b$ 的偏移量，整块修改直接在偏移量上加。

散块查询：直接暴力扫描区间。

整块查询：用数组或 vector 存一下现在尚未处理的整块查询。每次查询时，把询问编号、询问时整块 $k$ 与 $b$ 的偏移量的信息记录进去。

计算存下来的整块查询的答案：把查询按照 $k$ 排序，然后用指针在凸包上扫，求出答案。

散块修改：先暴力修改区间，再重构块的凸包。

我们发现一个问题：散块查询时，凸包会直接重构，凸包重构前后的询问必须分开来处理。

于是在散块修改时，我们必须把存下来的询问处理掉，才能做修改和重构。

分析一下时间复杂度。如果没有散块修改，对 $O(\sqrt n)$ 个块维护 $O(n)$ 次整块查询的总复杂度是 $O(n\sqrt n)$ 。

散块修改的影响可以看成把指针推回起点，一个块凸包的大小是 $O(\sqrt n)$ 的，推一次最多需要  $O(\sqrt n)$ 的时间。由于散块修改只有 $O(n)$ 次，总复杂度是 $O(n\sqrt n)$ 。

还有一个问题。我们要对 $O(n\sqrt n)$ 个数排序。可以用基数排序做到线性。

关于排序的实现方式：

先预处理出顺序。把一个块的所有整块查询拉出来，做基数排序，然后按散块修改的位置分段，再塞回去。

然后正常做，就能直接知道排序后的询问了。

代码比较难写。常数很大，本题需要跑 4.49 秒，不如绝大多数 $O(n\sqrt n\log n)$ 的写法。

如果哪里挂了，请告诉我。

```cpp
#include <bits/stdc++.h>
#define MAXN 100010
#define MAXB 350
#define RADB 2048
using namespace std;

int n, m, B, Btot, Qtot;
long long a[MAXN], ans[MAXN];
int lpos[MAXB], rpos[MAXB], bid[MAXN];

int top;
int idt[MAXN];
long long kt[MAXN], bt[MAXN];
long long val[MAXN], tmp[MAXN];
long long nowb, nowk;
int spos[MAXN], whi[MAXN], Dtot, las;

int cnt[RADB];

struct Operation{bool op; int l, r; long long val;};
vector<Operation> inq;
struct Point{long long x, y;} h[MAXN];
int Ptot;

Point operator-(Point a, Point b) {a.x -= b.x, a.y -= b.y; return a;}

long long Cprod(Point a, Point b) {return a.x * b.y - a.y * b.x;}

void Construct(const int p) {
	Ptot = 0;
	for (int i = lpos[p]; i <= rpos[p]; ++i) {
		a[i] += nowk * i + nowb;
		while (Ptot > 1 && Cprod(h[Ptot] - h[Ptot - 1], Point{i, a[i]} - h[Ptot]) >= 0) --Ptot;
		h[++Ptot] = Point{i, a[i]};
	}
	nowk = nowb = 0;
	return;
}

void radix_sort() {
	int lim = (1 << 11) - 1;
	memset(cnt, 0, sizeof(cnt));
	for (int i = 1; i <= top; ++i) ++cnt[(val[i] & lim) + 1];
	for (int i = 1; i < 2048; ++i) cnt[i] += cnt[i - 1];
	for (int i = 1; i <= top; ++i) tmp[++cnt[val[i] & lim]] = val[i] >> 11;
	for (int i = 1; i <= top; ++i) val[i] = tmp[i];
	memset(cnt, 0, sizeof(cnt));
	for (int i = 1; i <= top; ++i) ++cnt[(val[i] & lim) + 1];
	for (int i = 1; i < 2048; ++i) cnt[i] += cnt[i - 1];
	for (int i = 1; i <= top; ++i) tmp[++cnt[val[i] & lim]] = val[i] >> 11;
	for (int i = 1; i <= top; ++i) val[i] = tmp[i];
	memset(cnt, 0, sizeof(cnt));
	for (int i = 1; i <= top; ++i) ++cnt[(val[i] & lim) + 1];
	for (int i = 1; i < 2048; ++i) cnt[i] += cnt[i - 1];
	for (int i = 1; i <= top; ++i) tmp[++cnt[val[i] & lim]] = val[i] >> 11;
	for (int i = 1; i <= top; ++i) val[i] = tmp[i];
	return;
}

long long Getval(int p, long long k) {return h[p].x * k + h[p].y;}

void Solve(const int l, const int r) {
	int nowp = 1;
	long long nowval, lasval;
	// if (l <= r) {
	// 	cout << Ptot << "\n";
	// 	for (int i = 1; i <= Ptot; ++i) cout << h[i].x << " " << h[i].y << "\n";
	// }
	for (int i = tmp[l], j = l; j <= r; ++j, i = tmp[j]) {
		lasval = Getval(nowp, kt[i]);
		while (nowp < Ptot) {
			nowval = Getval(nowp + 1, kt[i]);
			if (nowval <= lasval) break;
			++nowp, lasval = nowval;
		}
		ans[idt[i]] = max(ans[idt[i]], lasval + bt[i]);
	}
	// for (int i = l; i <= r; ++i) for (int j = 1; j <= Ptot; ++j) ans[idt[i]] = max(ans[idt[i]], Getval(j, kt[i]) + bt[i]);
	return;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> n;
	B = 1.5 * sqrt(n);
	for (int l = 1, r = B; l <= n; l += B, r += B) ++Btot, lpos[Btot] = l, rpos[Btot] = r;
	rpos[Btot] = n;
	for (int i = 1; i <= Btot; ++i) for (int j = lpos[i]; j <= rpos[i]; ++j) bid[j] = i;
	for (int i = 1; i <= n; ++i) cin >> a[i], a[i] += a[i - 1];
	cin >> m;
	for (int i = 1; i <= m; ++i) {
		bool op; cin >> op;
		int l, r; cin >> l >> r;
		long long val = 0;
		if (op) inq.push_back(Operation{op, l, r, ++Qtot}), ans[Qtot] = -0x3f3f3f3f3f3f3f3fll;
		else cin >> val, inq.push_back(Operation{op, l, r, val});
	}
	for (int i = 1; i <= Btot; ++i) {
		nowk = nowb = 0;
		top = 0, Dtot = 0;
		spos[0] = 0;
		for (Operation oper : inq) {
			int l = oper.l, r = oper.r;
			int lb = bid[l], rb = bid[r];
			if (oper.op) {if (lb < i && rb > i) ++top, val[top] = nowk + (1ll << 32) + (1ll << 35) * top;}
			else {
				long long val = oper.val;
				if ((lb == i || rb == i) && spos[Dtot] < top) spos[++Dtot] = top;
				else if (lb < i && rb > i) nowk += val;
			}
		}
		radix_sort();
		if (spos[Dtot] < top) spos[++Dtot] = top;
		for (int i = 1; i <= Dtot; ++i) for (int j = spos[i - 1] + 1; j <= spos[i]; ++j) whi[j] = i;
		for (int i = 1; i <= top; ++i) {
			long long nowid = val[i] >> 2;
			tmp[++spos[whi[nowid] - 1]] = nowid;
		}
		top = 0, las = 0;
		nowk = nowb = 0;
		Construct(i);
		for (Operation oper : inq) {
			int l = oper.l, r = oper.r;
			int lb = bid[l], rb = bid[r];
			if (oper.op) {
				int id = oper.val;
				if (lb == i || rb == i) for (int j = max(l, lpos[i]); j <= min(r, rpos[i]); ++j) ans[id] = max(ans[id], a[j] + nowk * j + nowb);
				else if (lb < i && rb > i) ++top, idt[top] = id, kt[top] = nowk, bt[top] = nowb;
			}
			else {
				long long val = oper.val;
				if (lb == i || rb == i) {
					if (las < top) Solve(las + 1, top), las = top;
					for (int j = max(l, lpos[i]); j <= min(r, rpos[i]); ++j) a[j] += (j - l + 1) * val;
					for (int j = r + 1; j <= rpos[i]; ++j) a[j] += (r - l + 1) * val;
					Construct(i);
				}
				else if (lb < i && rb > i) nowk += val, nowb += (1 - l) * val;
				else if (rb < i) nowb += (r - l + 1) * val;
			}
		}
		if (las < top) Solve(las + 1, top);
	}
	for (int i = 1; i <= Qtot; ++i) cout << ans[i] << "\n";
	return 0;
}
```

---

## 作者：win114514 (赞：0)

### 思路

可以说是模板题了，非常好。

首先转化问题。

每个点的贡献相当与一段前缀和。

那么我们直接对整个序列做前缀和。

那么所有修改操作也变成了区间加等差序列。

考虑如何维护。

发现这个东西使用基本的数据结构不太好维护。

使用分块。

我们将每个点的贡献记为 $a_i$。

那么对于所有在块 $p$ 内的点，可以维护 $k_p,b_p$。

每个点实际的贡献即为，$sum_i=a_i+k_p\times i+b_p$。

这个式子是什么意思呢。

由于等差数列可以看作一条一次函数，那么我们可以对于整块的修改转化成修改这两个标记。

修改现在已经比较优秀了。

如何查询？

发现这个每个点的贡献是一个形如一次函数的东西。

想到了什么。

斜率优化!

我们可以尝试将其与斜率优化进行一些联系。

考虑点 $i$ 什么时候比点 $j$ 优。

$$a_i+k_p\times i+b_p>a_j+k_p\times j+b_p$$

$$a_i+k_p\times i>a_j+k_p\times j$$

$$k_p\times (i-j)>a_j-a_i$$

$$k_p>\frac{a_j-a_i}{i-j}$$

$$-k_p<\frac{a_i-a_j}{i-j}$$

发现我们得到了一个与斜率优化很像的式子。

那么依据套路，我们只需要维护斜率单调下降的图像就可以了。

实际就是一个上凸壳。

所以查询的时候，因为上面的式子有斜率的单调性。

我们可以在凸包上二分斜率。

这样就从斜率优化的角度得到了和其他题解类似的方法。

所以感觉分块来维护凸包的本质还是与斜率优化有关，或者两者本来就出自同源，没有本质的区别。

这样复杂度就被优化到了 $O(\sqrt{n}\log n)$

当然三分也可以做，凸壳上每个点的贡献都不同，并且呈单峰函数。

不过二分常数更小。

### Code

目前（2023-12-29）是最优解。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define x first
#define y second
#define int long long
#define mp(x, y) make_pair(x, y)
#define eb(...) emplace_back(__VA_ARGS__)
#define fro(i, x, y) for(int i = (x); i <= (y); i++)
#define pre(i, x, y) for(int i = (x); i >= (y); i--)
inline void JYFILE19();

typedef int64_t i64;
typedef pair<int, int> PII;

bool ST;
const int N = 1e5 + 10;
const int B = 300;

int n, m, a[N], top[N], stk[N];
int b[N], k[N], L[N], R[N], pos[N];

inline void push(int p)
{
	fro(i, L[p], R[p])
		a[i] = a[i] + b[p] + i * k[p];
	b[p] = k[p] = 0;
}
inline int get(int i)
	{ return a[i] + k[pos[i]] * i + b[pos[i]]; }
inline int mul(int x1, int y1, int x2, int y2)
	{ return (x1 * y2 - x2 * y1); }
inline int mul(int x, int y, int z)
{
	int x1 = y - z, y1 = a[y] - a[z];
	int x2 = x - z, y2 = a[x] - a[z];
	return mul(x1, y1, x2, y2);
}
inline void rebuild(int p)
{
	top[p] = L[p];
	fro(i, L[p], R[p])
	{
		while(top[p] >= L[p] + 2 && mul(stk[top[p] - 1], stk[top[p] - 2], i) >= 0)
			top[p]--;
		stk[top[p]++] = i;
	}
}
inline void upd(int l, int r, int y)
{
	push(pos[l]);
	fro(i, l, R[pos[l]])
		a[i] += min(r - l + 1, i - l + 1) * y;
	fro(i, pos[l] + 1, pos[n])
		b[i] += (r - l + 1) * y;
	rebuild(pos[l]);
}
inline void change(int l, int r, int y)
{
	if(pos[l] == pos[r])
		return upd(l, r, y);
	upd(l, R[pos[l]], y); int len = 0;
	fro(i, pos[l] + 1, pos[r] - 1)
		k[i] += y, b[i] -= y * R[pos[l]], len += (R[i] - L[i] + 1);
	fro(i, pos[r], pos[n]) b[i] += len * y;
	upd(L[pos[r]], r, y);
}
inline int get(int l, int r)
{
	int res = -1e17;
	fro(i, l, r) res = max(res, get(i));
	return res;
}
inline int ask(int l, int r)
{
	if(pos[l] == pos[r]) return get(l, r);
	int res = max(get(l, R[pos[l]]), get(L[pos[r]], r));
	fro(i, pos[l] + 1, pos[r] - 1)
	{
		int r = top[i], cur = L[i];
		pre(j, 7, 0) if(cur + (1<<j) < r)
		{
			int nxt = cur + (1<<j);
			if(-k[i] * (stk[nxt] - stk[nxt - 1]) < a[stk[nxt]] - a[stk[nxt - 1]])
				cur = nxt;
		}
		res = max(res, get(stk[cur]));
	}
	return res;
}
signed main()
{
	JYFILE19();
	cin >> n;
	fro(i, 1, n) cin >> a[i];
	fro(i, 1, n) a[i] = a[i] + a[i - 1];
	fro(i, 1, n) pos[i] = (i - 1) / B + 1;
	fro(i, 1, n) R[pos[i]] = i;
	pre(i, n, 1) L[pos[i]] = i;
	fro(i, 1, pos[n]) rebuild(i);
	cin >> m;
	fro(i, 1, m)
	{
		int op, x, y, k;
		cin >> op >> x >> y;
		if(op == 0)
		{
			cin >> k;
			change(x, y, k);
		}
		if(op == 1)
		{
			cout << ask(x, y) << "\n";
		}
	}
	return 0;
}
bool ED;
inline void JYFILE19()
{
	// freopen("", "r", stdin);
	// freopen("", "w", stdout);
	ios::sync_with_stdio(0), cin.tie(0);
	double MIB = fabs((&ED-&ST)/1048576.), LIM = 125;
	cerr << "MEMORY: " << MIB << endl, assert(MIB<=LIM);
}
```

---

## 作者：CEFqwq (赞：0)

讲一个比较清晰的思路。

一眼丁真，鉴定为神仙题。

看到区间，想到了线段树，可以轻松打懒惰标记，但是区间最大前缀和只能暴力。行不通。

线段树不行，想到万能分块，美观度加 $k$ 没什么问题，但是这个查询……似乎并不支持。

至此你似乎只能心灰意冷，去打暴力。但是你会想起有个东西叫做前缀和，然后你发现一块里面加的是等差数列，于是你就想到了一个很重要的结论：若干个等差数列对应项相加，所得结果还是等差数列。

至于游离的几个怎么办？你突然想到有个东西叫初始值。

然后继续想整块的答案。

记 $a_i$ 为初始值，贡献 $ans_i = a_i + i \times d$。

这个 $i \times d$ 是叠加的。

我们最终要求 $\max\{ans_i\}$。

然后我们会发现 $a_i$ 和 $i$ 不会变。$d$ 会变。所以把式子变个形：$a_i = ans_i - d \times i$。

再移个项：$a_i = - d \times i + ans_i$。

于是这就变成了一条直线。你又想了一下，发现是这样一个东西：也就是说，斜率在变，但点的坐标不变，要求截距大。

于是只有上凸壳可以成为答案。

所以分治维护上凸壳，分块+前缀和。做完了。

代码有点毒瘤，等后续补上。

---


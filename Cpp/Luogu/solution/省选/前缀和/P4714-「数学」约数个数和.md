# 「数学」约数个数和

## 题目描述

小 F 在数学课上与同学闲聊。

> 给你一个正整数，计算他的约数个数。

「你们竞赛就学这个啊？太简单了吧。」

「……」

> 给你一个正整数，计算他的所有约数的约数个数和。

「我想想……嗯，还是不难的。诶，你们竞赛还能报名吗？」

「……」

> 给你一个正整数，计算他的所有约数的所有约数的约数个数和。

「哎呀反正你们电脑总是能爆算出来的嘛，快给我说在哪报名。」

「……」

> 给你一个正整数，计算他的所有约数的所有约数的所有约数的约数个数和。

「有完没完了？」

「……」


被嘲讽的小 F 将这个问题交给了你，请展示你的爆算实力。

给你一个正整数 $N$，请计算 $N$ 的 $($所有约数的$)\times K$ 约数个数和。

答案可能很大，请输出对 $998244353$ 取模的结果。


## 说明/提示

### 样例 1, 2, 3 解释

$4,\ 0:$ $4$ 的约数 $\ 1\ 2\ 4$

$4,\ 1:$ $4$ 的所有约数的约数 $\ (1)\ (1\ 2)\ (1\ 2\ 4)$

$4,\ 2:$ $4$ 的所有约数的所有约数的约数 $((1))\ ((1)\ (1\ 2))\ ((1)\ (1\ 2)\ (1\ 2\ 4))$

### 子任务

子任务 $1(11 \mathrm{pts}) : N, K \leq 10 ^ 4$

子任务 $2(31 \mathrm{pts}) : N \leq 10 ^ 4$

子任务 $3(41 \mathrm{pts}) : N \leq 10 ^ 9$

子任务 $4(67 \mathrm{pts}) : 1 \leq N \leq 10 ^ {18}, 0 \leq K \leq 10^{18} $。

## 样例 #1

### 输入

```
4 0```

### 输出

```
3```

## 样例 #2

### 输入

```
4 1```

### 输出

```
6```

## 样例 #3

### 输入

```
4 2```

### 输出

```
10```

# 题解

## 作者：WinXP (赞：38)

这是一篇 ~~其实我不怎么敢提交的~~ 画风优良，言之成理，语义清晰，老少咸宜，不涉及到数学名词 ~~和高难算法！~~，并且不掺杂大量公式 ~~是个人就能看懂~~ 的题解

~~本题解的目的在于让该题目成为浅蓝题~~ 我会尽量最清晰的解释自己的思路，如果还是不懂，可能你现在不适合这样的题目(~~绝对不是我说不明白~~)，可以考虑加任务计划以后做。看不懂中文看式子，看不懂式子读中文，~~都看不懂出门左转~~

(用$\prod_{i=1}^n$表示从$1$到$n$乘在一起，用$\sum_{i=1}^n$表示加在一起)

~~如果你已经知道怎么做并且只是好奇这个奇怪标题的原因倒着看就好了~~

首先，通过 ~~不是数竞生所以可以随便大力猜结论的暴力打表~~ 严谨的证明，我们发现这是一个积性函数。

~~至于证明看其他人的就好了(虽然我觉得没有什么用反正你也会不证作为oier要用好自己的工具就是计算机乖乖打表啊对吧~~

你不会积性函数？

![](https://cdn.luogu.com.cn/upload/pic/21438.png )

(两者有区别，要仔细区分)

也就是说，$n$ 的答案 等于 $n$ 质因数分解之后，每一个 质数的次幂 的答案 的乘积。因为它们都是质数所以自然两两互质。

用数学来表示，即把一个任意的积性函数的值记为 $G_a$ ，把 $a$ 表示为$p_1^{q_1}p_2^{q_2}p_3^{q_3}...p_m^{q_m}$ (我,或者说大家习惯用p表示质数），有

$$G_a=G_{p_1^{q_1}}G_{p_2^{q_2}}G_{p_3^{q_3}}...G_{p_m^{q_m}}$$

我们把这道题的答案计为 $f_k^a$ , 对a质因数分解可以得到

$$a=\prod_{i=1}^m p_i^{qi}$$

就有了

$$f_k^a=\prod_{i=1}^mf_k^{(p_i^{qi})}$$

为什么要变成这样的形式呢？

因为 考虑对于$f_k^{(p_i^{qi})}$怎么搞。

~~如果你真的读题了就能~~写出这样的式子

$$f_k^a=\sum_{x|a}f_{k-1}^x$$

$x|a$ 意义即为 $x$ 是 $a$ 的约数，$a$ 的 $k$ 次约数和等于 $a$ 的所有约数的 $k-1$ 次的约数和。

当这个式子中的 $a=p_i^{qi}$ 时，就变成了

$$f_k^{(p_i^{qi})}=\sum_{t=1}^{qi}f_{k-1}^{(p_i^{t})}$$

因为显然对于一个质数的 $q$ 次幂，是他的约数的只有这个质数的 大于等于 $0$ 小于等于$p$ 的次幂。

注意到这个时候其实 $pi$ 已经没有用了，只要它是一个质数就可以，无论是$2$或者$5$~~或者19260817~~值都是一样的。那我们干脆把 $pi$ 删掉来表示。

$$F_k^{n}=\sum_{t=1}^{n}F_{k-1}^{t}$$

这个就是把开始化成这个形式的原因。(我说的有点墨迹，一般想到是积性函数就能想到这里吧 $QAQ$ )

看起来感觉好多了。可以非常明晰的看出来，每一维的 $k$ 都是在求 $k-1$ 维的前缀和。所以现在~~如果不是大常选手~~我们就已经有了 $11$ 分。

这个转移这么蠢，它一定是有规律的。~~(要不然怎么A)~~

我们来反着考虑这个问题。

假如把 $k$ 这个下标规定为最小值为$-2$ , 且当 $k=-2$ 时只有一个$F_{-2}^1$的值等于$1$，$F_{-2}^x (x!=1)$的值全部为 $0$ 。 那么根据定义我们就有 $F_{-1}^x=1$，$F_0^x=x$。考虑 $F_{-2}^1$ 对答案会贡献多少次，或者说考虑自低往上的转移，进而考虑最终的答案。

换句话说，把每一个状态看做一个矩阵上的点对，把每一层的转移都想象成 一条有向边 连向转移目标点 的话，（即从 $(x,t)$ 连向（$(x,t+1)$ 到 $(n,t+1)$) 的所有的点) , 我们就是在考虑一个开始的点$(1,-2)$能有多少种方式走到最后的目标点 $n$ 。

emmmmm

大概像这样

![](https://cdn.luogu.com.cn/upload/pic/21440.png )

我们可以~~通过惊人的眼力~~发现路径数目为 $6$（用的是画图 见谅。。)

(其实引入图论只是帮助理解，不是正解非得从图论上考虑，~~话说这其实是小学奥数题啊~~)

我们发现一共转移了 $k+2$ 次 。每一次转移都由*当前状态转移到相等或更大的值*。如果把每一次转移考虑为在*当前状态上加上一个非负整数*，它就变成了一个人尽皆知通俗易懂的问题：

有

$$1+x_1+x_2+...+x_{k+2}=n,(xi>=0)$$

求方案数。

即可运用插板法解决得到 $C_{n+k}^{k+1}$ 。

(什么是插板法？......）

首先考虑在每一个x上加1，就变成了

$$x_1+x_2+...+x_{k+2}=n-1+(k+2),(xi>=1)$$

这个问题等价于把长度为 $(n+k+1)$ 的区间 分成 $(k+2)$ 份 > 等价于在 $(n+k)$ 个点中选取 $(k+1)$ 个来分割这个区间。

来整理一下答案。

总的答案：
$$f_k^a=\prod_{i=1}^mf_k^{(p_i^{qi})}$$
答案的每一项：
$$f_k^{(p_i^{qi})}=\sum_{t=1}^{qi}f_{k-1}^{(p_i^{t})}$$
进行两次问题转化，变为求组合数：
$$f_k^{(p_i^{qi})}=F_k^{qi}=\sum_{t=1}^{qi}F_{k-1}^{t}=C_{qi+k}^{k+1}$$

$$f_k^a=\prod_{i=1}^m C_{qi+k}^{k+1}$$

等等，有一个问题。这个组合数怎么求？$qi$ 是一个数的指数，再大也不会很大，当 $pi=2$ 的时候 $qi$ 的最大值才为 $60$ 左右。不过 $k$ 可是异常的大啊。肯定不能求出 $(qi+k)$ 的阶乘。

随便举个例子。设想求 $C_8^6=C_8^2=\frac{8!}{2!6!}=\frac{7*8}{1*2}$ 。我们并不需要求 $(qi+k)$ 的阶乘，只需要求 $(qi+k)$ 中的后 $(qi-1)$ 项除去前 $(qi-1)$ 项就好了。 所以为了处理除，我们需要一个逆元。不行，我实在写不动了，逆元不会自行百度吧....

逆元随便怎么求都可以。我们发现求组合数的复杂度其实是相当小的，而复杂度关键在于哪里呢？

分解质因数。标准的分解质因数是枚举质数，如果发现 $n$ 是这个质数的倍数，就除干净，计n不是这个质数的倍数除了几次即为这一项的次数。优化一下，枚举质数的时候可以枚举到 $\sqrt n$ 的大小。因为大于这个数的质数，如果是 $n$ 的约数，一定是一次，因为它的平方就已经比 $n$ 大了。同理大于 $\sqrt n$ 的质数也一定只有一个。

但是当 $n$ 为 $1e18$ 的时候我们发现 $1e9$ 的范围是不可过的

所以我们需要Miller-Rabin或Pollad-rho算法 吗？

~~no no no 想想出题人要是卡会怎么卡你？ 肯定放几个筛不出来的大质数的乘积对吧 因为1s线筛大概能筛1e7 所以这几个质数显然都是1e8 1e9 的量级 这个量级的质数常用的有几个 你还不明白吗~~

```cpp
#include <bits/stdc++.h>
#define rap(i,s,n) for(int i=s;i<=n;i++)
#define drap(i,s,n) for(int i=s;i>=n;i--)
#define N 111111
#define P 998244353
#define ll long long
#define m(s,k) memset(s,k,sizeof s)
using namespace std;
ll n,k;
int prime[N],cnt;
bool isnt[N];
void Prime(int n){
    rap(i,2,n){
        if(!isnt[i]) prime[++cnt]=i;
        rap(j,1,cnt){
            if(prime[j]*i>cnt) break;
            isnt[i*prime[j]]=1;
            if(i%prime[j]==0) break;
        }
    }
}
ll ans=1,inv[N];
ll C(int x){ll res=1; rap(i,1,x) res=res*inv[i]%P*((x+k%P+2-i)%P)%P; return res;}
int main(){
    cin>>n>>k; inv[1]=1; rap(i,2,100000) inv[i]=inv[P%i]*(P-P/i)%P;
    Prime(100000); prime[++cnt]=998244353; prime[++cnt]=1000000007; prime[++cnt]=1000000009;
    rap(j,1,cnt){
        int v=prime[j]; if(v*v>n) break;
        if(n%v==0){
            int t=0;
            while(n%v==0) n/=v,t++;
            ans=ans*C(t)%P;
        }
    }
    if(n>1) ans=ans*C(1)%P;
    printf("%lld\n",ans);
    return 0;
}

```

~~sans:像你这样的孩子应该在地狱里燃烧~~

---

## 作者：小粉兔 (赞：21)

**用另一种方式去推这个式子：**

用 $f_{i}(x)$ 表示当 $N=x,\;K=i$ 时的答案。

首先有 $f_{0}(x)=\sum_{d}[d|x]=\sigma(x)$ ，这是一个积性函数。

根据定义，有 $f_{i+1}(x)=\sum_{d|x}f_{i}(d)$ 。

即 $x$ 的每个约数自身的降一次约数个数和。

发现这是一个狄利克雷卷积的形式。

即 $f_{i+1}(x)=\sum_{d|x}1\cdot f_{i}(d)\Leftrightarrow f_{i+1}(x)=(I\ast f_{i})(x)$ 。

这里定义 $I(x)=1$ 。

根据狄利克雷卷积的性质，两个积性函数的卷积也是一个积性函数。

于是有 $f_{i}(x)$ 是积性函数对任意的 $i$ 均成立。

以上证明了 $f_{K}$ 是积性函数。

那么考虑计算 $f_{K}(N)$ 。

令 $N$ 的标准分解式为 $N=\prod p_i^{q_i}$ 。

这里 $p_i$ 均为素数。

那么根据积性函数的性质，有 $f_{K}(N)=\prod f_{K}(p_i^{q_i})$ 。

考虑计算 $f_{K}(p^q)$ 。

根据函数的定义，有 $f_{K}(p^q)=\sum_{i=0}^{q}f_{K-1}(p^i)$ 。

而 $f_{0}(p^q)=q+1$ 。

这可以抽象成一个组合问题：在 $q+1$ 个空位中插 $K+1$ 个板，板可重叠。

根据组合数的公式，强制在每两个板中加一个物品，得到公式： $f_{K}(p^q)=\binom{q+K+1}{K+1}$ 。

再根据组合数的性质得到 $f_{K}(p^q)=\binom{q+K+1}{q}$ 。

故答案为 $\prod \binom{q_i+K+1}{q_i}$ 。

------

这题的公式就推到这里，接下来看如何计算。

质因数分解交给 Pollad-rho 算法。

组合数部分，考虑到 $q_i\le 59$ ，可以直接 $\binom{n}{m}=\frac{n(n-1)\cdots(n-m+1)}{1\times 2\times\cdots\times m}$ 。

因为模数 $998244353$ 为素数，除法部分使用逆元计算。

---

## 作者：ViXbob (赞：10)

怎么说呢，感觉题解里的两篇还是有点没说清楚

所以我打算再来解释一下

首先一个数:$n$ $=$ $\prod P^{a_i}$，这个数的因子的个数则等于$\prod a_i$, 这是是$k = 0$时的答案， 那么我们现在来考虑 $k = 1$， 这个就相当于在每个$a_i$中再重新选择然后累乘，我们现在要求的就是这个重新选择的方案是多少

举个栗子：
* $n = 900 = 2 ^ 2 * 3 ^ 2 * 5 ^ 2, k = 0$时， $ans = 3 * 3 * 3$

* $n = 900, k = 1$时， $ans = (1 + 2 + 3) * (1 + 2 +3) * (1+ 2 +3)$

我们现在来探讨一下这个是怎么算出来的对于每个素因子,$k = 0$时我们进行选择可以选出来$a_i ^ 0, a_i ^ 1, a_i ^ 2$，而$k = 1$时再选择就相当于对$a_i ^ 0, a_i ^ 1, a_i ^ 2$
再次拆分变成$(a_i^0,),(a_i^0, a_i^1), (a_i^0, a_i^1, a_i^2)$,方案数由$(3) -> (1 + 2 + 3)$

然后我们可以再归纳一下当$k = 2$时，对于每个素因子的方案数应该变为$(1) + (1 +2) + (1 +2 + 3)$

其实最后对于每个素因子的方案数就是将$a_i$拆分$k$次的和，关键的来了，对于拆分$k$次的和我们应该怎么求呢，答案其实前面发题解的两位聚聚已经告诉我们了，就是$C_{a_i + k + 1}^{k + 1}$现在我来推导一下(以下推导针对上面举的栗子)

* $k = 0$, $ans = 3 = C_3^1$

* $k = 1$,  $ans = (1 + 2) + 3 = C_4^2$

$C_4^2 = C_3^1 + C_3^2$ , 而 $C_3^2 = C_2^1 +  C^2_2$

$2 = C_2^1, 1 = C_2^2 =  \frac{2}{2} C_1^1 = C^1_1, 1 + 2 = C_2^1 + C_2^2 = C_3^2$

所以$C_4^2 = C_3^1 + C_3^2 = 3 + 2 + 1$

* $k = 2$, $ans = (1) + (1 + 2) + (1 + 2 + 3) = C_5^3$

$1 = C_3^3, (1 + 2) = C_3^2, (1 + 2 + 3) = C_4^2$

所以$(1) + (1 + 2) + (1 + 2 + 3) = C_5^3$

大概推导就是这些了，随着$k$增大可以依次类推，最后推广一下就是$C_{a_i + k + 1}^{k + 1}$

答案就是$\prod_i C_{a_i + k + 1}^{k + 1}$, 关于式子的推导就讲完了，关于Miller-Rabin算法大家可以去[Miskcoo的博客](http://blog.miskcoo.com/2014/07/miller-rabin-primality-test)学一下


最后推广一下[我的博客](http://www.vixbob-lwc.pw)

---

## 作者：NaCly_Fish (赞：9)

经过仔细阅读了三遍题面，可以发现题目让我们求这个：  

$$[n^{-s}]\zeta(s)^{k+1}$$  
其中 $\zeta(s)$ 为 Riemann-Zeta 函数。  

根据数论的基础知识，我们知道积性函数的 Dirichlet 卷积还是积性函数，所以要计算答案，只需要对于所有质数幂的答案求积即可。  
（以下定义 $p$ 为质数）

设 $f(n,k)$ 为答案，那么不难得到：
$$f(p^t,k)=\sum_{i=0}^tf(p^i,k-1)$$
然后你发现这个不就是普通的前缀和嘛，，   

$$f(p^t,k)=[x^t]\left( \frac{1}{1-x}\right)^{k+1}=\binom{t+k}{k}$$
暴力线性筛一下，同时预处理一下这个组合数，就能 $\text O(\sqrt n)$ 计算了。
$$\binom{t+k}{k}=\binom{t-1+k}{k}\frac{t+k}{t}$$
然而正解是应该用 $\text{pollard-rho}$ 算法，，真正比赛估计没几个人愿意写，所以这里直接特判质数水过了（  
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#define p 998244353
#define ll long long
#define reg register
#define N 10000003
using namespace std;

ll n,k;
int c[65],inv[65],pr[N];
bool vis[N];
int ans = 1,cnt,lim,pc;

void solve(int i){
    cnt = 0;
    while(n%i==0) n /= i,++cnt;
    ans = (ll)ans*c[cnt]%p;
}

int main(){
    scanf("%lld%lld",&n,&k);
    k = (k+1)%p;
    c[0] = inv[1] = 1;
    for(reg int i=2;i<=64;++i) inv[i] = (ll)(p-p/i)*inv[p%i]%p;
    for(reg int i=1;i<=64;++i) c[i] = c[i-1]*(i+k)%p*inv[i]%p;
    lim = min((int)sqrt(n)+3,N-2);
    for(reg int i=2;i<=lim;++i){
        if(!vis[i]) pr[++pc] = i,solve(i);
        for(reg int j=1;j<=pc&&i*pr[j]<=lim;++j){
            vis[i*pr[j]] = true;
            if(i%pr[j]==0) break;
        }
    }
    solve(p); //有一个点数据 998244353|n ,直接判一下
    if(n>1) ans = (ll)ans*(k+1)%p;
    printf("%d\n",ans);
	return 0;	
}
```

---

## 作者：Iowa_BattleShip (赞：4)

这里给出矩阵快速幂的做法，个人认为矩乘比组合数好理解一些。  
我们先考虑对于$p^m(p\text{为质数})$进行题目所描述的操作，我们可以先列出一个初始状态（第一行并不属于矩阵，只是表示第几列）：  

$\qquad\qquad\qquad\qquad\begin{pmatrix}0&1&2&3&\cdots&m-1&m\\0&0&0&0&\cdots&0&1\end{pmatrix}$  

表示对于每一个$p^k(k\in[0,m])$，它的贡献是多少，起始只有一个数$p^m$，它的贡献即为$1$，其它均为$0$。  
然后我们进行一次求约数的操作，因为$p^m$的约数为$p^0,p^1,p^2,\dots,p^m$，所以矩阵就变成这样：  

$\qquad\qquad\qquad\qquad\begin{pmatrix}0&1&2&3&\cdots&m-1&m\\1&1&1&1&\cdots&1&1\end{pmatrix}$  

再进行一次求约数操作，因为对于之前产生的约数$p^k$，它产生的约数为$p^0,p^1,p^2,\dots,p^k$，所以矩阵就变成这样：  

$\qquad\qquad\qquad\begin{pmatrix}0&1&2&3&\cdots&m-1&m\\m&m-1&m-2&m-3&\cdots&2&1\end{pmatrix}$  

于是我们就找到了递推的公式：  
设矩阵为$f[i][j]$，$i$表示进行了几次求约数操作，$j$则表示$p^j$的贡献，初始状态为$f[0][0\to m]=1$，因为第$0$次即为进行过一次操作，对于每一层$i(i>0)$，有递推式$f[i][j]=\sum\limits_{k=j}^mf[i-1][k]$，最后递推至$K$层时，显然$\sum\limits_{i=0}^mf[K][i]$即为$p^m$这个数的贡献。  
而根据算术基本定理，$N=\prod\limits_{i=1}^mp_i^{c_i}$，我们就可以对于每一个$p_i^{c_i}$用上述方法计算出它的贡献，而整个数$N$的总贡献即为$\prod\limits_{i=1}^m\sum\limits_{j=0}^mf[K][j]$。  
然后我们考虑用矩阵快速幂去加速这个递推，因为原矩阵为$1\times (m+1)$大小，要使得乘完后仍为$1\times (m+1)$，显然我们需要一个$(m+1)\times (m+1)$的递推矩阵：  
$\qquad\qquad\qquad\quad\begin{pmatrix}&0&1&2&\cdots&m-1&m\\0&1&0&0&\cdots&0&0\\1&1&1&0&\cdots&0&0\\2&1&1&1&\cdots&0&0\\\vdots&\vdots&\vdots&\vdots&\ddots&\vdots&\vdots\\m-1&1&1&1&\cdots&1&0\\m&1&1&1&\cdots&1&1\end{pmatrix}$  
而因为$2^{60}=1,152,921,504,606,846,976>10^{18}$，所以$m<60$，跑的还是挺快的，于是剩下的时间就是将$N$分解质因数的时间了，如果使用朴素的$\sqrt{N}$算法显然会$T$，所以我们需要用$Miller-Rabin$算法和$Pollard-Rho$算法去分解，这里推荐个讲这两个算法的博客[$Miller-Rabin$算法](https://blog.csdn.net/sunshine_cfbsl/article/details/52425798)、[$Pollard-Rho$算法](https://blog.csdn.net/sunshine_cfbsl/article/details/52512706)。  
在上述推导中其实我们发现这个矩阵只与这个次数$c_i$有关，这样我们可以稍微优化下，记录一个最大的$c_i$，然后用矩阵快速幂推出这个矩阵，再将其前缀和一下，这样就可以直接查找每个$c_i$下的贡献，同时在预处理时，我们也可以把相同的$c_i$合并，计算贡献时直接一个次方上去即可。  
```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<ctime>
#include<algorithm>
using namespace std;
typedef long long ll;
const int N=65;
const int mod=998244353;
int a[N],b[N],l,L,ma;
//a记录不同的次方，b记录相同的次方个数,l为pr数组长度，L为b数组长度，ma为最大次方
ll pr[N<<4];
//pr为N分解出来的所以质因数
struct dd{//(m+1)*(m+1)的矩阵
	ll T[N][N];
	dd()
	{
		memset(T,0,sizeof(T));
	}
	dd operator * (const dd& B)//自乘
	{
		dd C;
		int i,j,k;
		for(i=0;i<=ma;i++)
			for(j=0;j<=ma;j++)
				for(k=0;k<=ma;k++)
					(C.T[i][j]+=T[i][k]*B.T[k][j]%mod)%=mod;
		return C;
	}
};
struct jc{//1*(m+1)的矩阵
	ll S[N];
	jc()
	{
		memset(S,0,sizeof(S));
	}
	jc operator * (const dd& B)//乘上(m+1)*(m+1)的矩阵
	{
		jc C;
		int i,j;
		for(i=0;i<=ma;i++)
			for(j=0;j<=ma;j++)
				(C.S[i]+=S[j]*B.T[j][i]%mod)%=mod;
		return C;
	}
};
jc an;//储存答案
dd tf;//递推矩阵
ll re()//快读
{
	ll x=0;
	char c=getchar();
	for(;c<'0'||c>'9';c=getchar());
	for(;c>='0'&&c<='9';c=getchar())
		x=x*10+(c-'0');
	return x;
}
void jc_ksm(ll y)//矩阵快速幂
{
	int i,j;
	memset(tf.T,0,sizeof(tf.T));
	for(i=0;i<=ma;i++)//初始化为1
		an.S[i]=1;
	for(i=0;i<=ma;i++)//初始化为一个形如三角形的1
		for(j=0;j<=i;j++)
			tf.T[i][j]=1;
	for(;y;y>>=1,tf=tf*tf)//快速幂
		if(y&1)
			an=an*tf;
}
ll n_ksm(ll x,int y)//一个普通的快速幂
{
	ll s=1;
	for(;y;y>>=1,x=x*x%mod)
		if(y&1)
			s=s*x%mod;
	return s;
}
void su()//对答案矩阵进行前缀和处理
{
	int i;
	for(i=ma;i;i--)
		(an.S[i-1]+=an.S[i])%=mod;
}
//以下为Miller和Porllard
ll mu(ll x,ll y,ll M)
{
	ll s=0;
	for(;y;y>>=1,x=(x+x)%M)
		if(y&1)
			s=(s+x)%M;
	return s;
}
ll ksm(ll x,ll y,ll M)
{
	ll s=1;
	for(;y;y>>=1,x=mu(x,x,M))
		if(y&1)
			s=mu(s,x,M);
	return s;
}
bool miller(ll x)
{
	int i,j,t=0;
	ll y=x-1,X,Y;
	if(x==2)
		return true;
	for(;!(y&1);t++,y>>=1);
	for(j=1;j<=20;j++)
	{
		X=ksm(2+rand()%(x-2),y,x);
		for(i=1;i<=t;i++,X=Y)
		{
			Y=mu(X,X,x);
			if(Y==1&&X!=1&&X!=x-1)
				return false;
		}
		if(X!=1)
			return false;
	}
	return true;
}
ll gcd(ll x,ll y)
{
	if(!y)
		return x;
	return gcd(y,x%y);
}
ll poll(ll x,ll c)
{
	ll i,k=2,X=1+rand()%(x-1),Y=X,G;
	for(i=1;;i++)
	{
		X=(mu(X,X,x)+c)%x;
		G=gcd((Y-X+x)%x,x);
		if(G!=1&&G!=x)
			return G;
		if(X==Y)
			return x;
		if(i==k)
		{
			Y=X;
			k<<=1;
		}
	}
}
void sch(ll x,ll c)
{
	ll k=c,p=x;
	if(x==1)
		return;
	if(miller(x))
	{
		pr[++l]=x;
		return;
	}
	while(p>=x)
		p=poll(p,k--);
	sch(p,c);
	sch(x/p,c);
}
//以上为Miller和Porllard
void ud(int k)//记录次方
{
	if(!b[k])//若没有出现
	{
		a[++L]=k;
		b[k]=1;
		ma=ma>k?ma:k;
	}
	else//若出现过
		b[k]++;
}
int main()
{
	int i,k=0;
	ll n,m,s=1;
	n=re();
	m=re();
	sch(n,113);//分解质因数
	sort(pr+1,pr+l+1);//排序
	for(i=1;i<=l;i++)//记录
	{
		if(i==1||pr[i]==pr[i-1])
			k++;
		else
		{
			ud(k);
			k=1;
		}
	}
	if(k)
		ud(k);
	jc_ksm(m);//矩阵快速幂
	su();//前缀和
	for(i=1;i<=L;i++)//按上述进行累乘出答案
		(s*=n_ksm(an.S[ma-a[i]],b[a[i]]))%=mod;
	printf("%lld",s);
	return 0;
}
```

---

## 作者：Graphcity (赞：3)

首先我们发现这道题目要求的是形如这类式子的方案数：

$$
a_1\times a_2\times \cdots \times a_k=n
$$

其中 $n,k$ 给定。（ 本题中 $k\leftarrow k+2$ ）

我们将 $n$ 分解质因数，设 $n=p_1^{r_1}\times p_2^{r_2}\times \cdots \times p_m^{r_m}$，$s=\sum_{i=1}^mr_i$ 。

考虑它的组合意义：总共有 $s$ 个小球，$m$ 种颜色，第 $i$ 种颜色的小球共有 $r_i$ 个，求把这些小球放进 $k$ 个互不相同的可以为空的盒子的方案数。

不妨先枚举共有几个非空的盒子。设 $ans_i$ 表示有 $i$ 个非空盒子的方案数，则答案等于 $\sum_{i=1}^{\min(k,s)}\binom{k}{i}ans_i$ 。

由于 $10^{18}$ 范围内 $s$ 不会超过 64，非空的盒子也不会超过 $s$ 个，所以上式中 $i$ 的上限也不会超过 64。

对于 $ans_i$，可以用乘法原理来解决：

将 $r_t$ 个相同颜色的小球放入 $i$ 个不同的盒子中，盒子可以为空的方案数可以用插板法求出来： $\binom{r_t+i-1}{i-1}$ 。

设 $cur_i=\prod_{t=1}^i\binom{r_t+i-1}{i-1}$，则 $cur_i$ 表示把所有小球放入 $i$ 个盒子里，盒子可以为空的方案数。还是一样的，枚举非空的盒子，有

$$
cur_n=\sum_{i=1}^n\binom{n}{i}ans_i
$$

根据二项式反演，

$$
ans_n=\sum_{i=1}^n(-1)^{n-i}\binom{n}{i}cur_i
$$

至此大功告成。

分解质因数可以利用 Pollard-Rho 算法，组合数的计算可以利用下降幂。

```
#include<bits/stdc++.h>
#define For(i,a,b) for(int i=(a);i<=(b);++i)
#define Rof(i,a,b) for(int i=(a);i>=(b);--i)
#define int long long
#define ll __int128
using namespace std;
typedef pair<int,int> Pair;
const int Mod=998244353;

inline int gcd(int a,int b) {return b==0?a:gcd(b,a%b);}
inline int f(int x,int c,int n) {return ((ll)x*x+c)%n;}
inline int Pow(int x,int y,int z)
{
    int res=1;
    while(y)
    {
        if(y&1) res=(ll)res*x%z;
        x=(ll)x*x%z,y>>=1;
    }
    return res;
}
inline int Pol(int n)
{
    int s=0,t=0,c=rand()%(n-1)+1,val=1;
    int tim=0,len=1;
    for(len=1;;len<<=1,s=t,val=1)
    {
        for(tim=1;tim<=len;++tim)
        {
            t=f(t,c,n),val=(ll)val*abs(t-s)%n;
            if(tim%127==0)
            {
                int d=gcd(val,n);
                if(d>1) return d;
            }
        }
        int d=gcd(val,n);
        if(d>1) return d;
    }
}
inline int Mil(int x)
{
    if(x<2) return 0;
    if(x==2 || x==3) return 1;
    if(x!=2 && x%2==0) return 0;
    int a=x-1,b=0,j=0;
    while(a%2==0) a>>=1,++b;
    for(int i=1;i<=10;++i)
    {
        int p=rand()%(x-2)+2,q=Pow(p,a,x);
        if(q==1 || q==x-1) continue;
        for(j=0;j<b-1;++j)
        {
            q=(ll)q*q%x;
            if(q==x-1) break;
        }
        if(q!=x-1) return 0;
    }
    return 1;
}
vector<Pair> Merge(vector<Pair> s1,vector<Pair> s2,int cnt)
{
    for(auto &i:s1) i.second*=cnt;
    int l1=s1.size(),l2=s2.size(),it=0;
    For(i,0,l1-1)
    {
        while(it<l2 && s2[it].first<s1[i].first) it++;
        if(it<l2 && s2[it].first==s1[i].first) s1[i].second+=s2[it].second,s2[it].second=0;
    }
    for(auto i:s2) if(i.second) s1.push_back(i);
    sort(s1.begin(),s1.end());
    return s1;
}
vector<Pair> dfs(int x) // 分解质因数
{
    vector<Pair> v; v.clear();
    if(x<2) return v;
    if(Mil(x)) {v.push_back(Pair(x,1ll)); return v;}
    int res=x,cnt=0;
    while(res>=x) res=Pol(x);
    while(x%res==0) x/=res,cnt++;
    vector<Pair> s1,s2,s3;
    s1=dfs(res),s2=dfs(x);
    return Merge(s1,s2,cnt);
}

int all,kazuha[105],fac[105],inv[105];
vector<Pair> vec;

inline void GetInv()
{
    fac[0]=inv[0]=1;
    For(i,1,100) fac[i]=fac[i-1]*i%Mod;
    inv[100]=Pow(fac[100],Mod-2,Mod);
    Rof(i,99,1) inv[i]=inv[i+1]*(i+1)%Mod;
}
inline int C(int x,int y)
{
    int s1=1;
    For(i,1,y) s1=(ll)s1*(x-i+1)%Mod;
    return s1*inv[y]%Mod;
}
inline int Count(int x) // 计算 cur 数组的值
{
    int s1=1;
    for(auto i:vec) s1=s1*C(x+i.second-1,x-1)%Mod;
    return s1;
}

signed main()
{
    int n,k,ans=0;
    scanf("%lld%lld",&n,&k);
    if(n==1) {printf("1\n"); return 0;}
    vec=dfs(n);
    for(auto i:vec) all+=i.second;
    GetInv();
    For(i,1,min(k+2,all)) kazuha[i]=Count(i);
    For(i,1,min(k+2,all))
        For(j,1,i-1) kazuha[i]=(kazuha[i]-C(i,j)*kazuha[j]%Mod+Mod)%Mod;
    For(i,1,min(k+2,all)) // 统计答案
    {
        int res=kazuha[i]*C(k+2,i)%Mod;
        ans=(ans+res)%Mod;
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：Soulist (赞：3)


约数个数函数本身就是 $I^2$，我们等价于计算 $I^{k+2}(n)$

注意到其是积性函数，只需要对于每个质因数考虑其贡献，考虑形如 $I^{k}(p^r)$ 的答案，通过 dp 统计可以写为 $f_{i,j}=\sum_{k\le j} f_{i-1,k}$，那么转移是一个前缀和函数，所以我们计算的是 $\frac{1}{(1-x)^k}[x^r]$，于是答案就是 $\binom{k+r-1}{r}$，直接当作下降幂处理，计算的 $r$ 至多到 $\log$，考虑通过 PR 处理因数分解所以复杂度是 $\mathcal O(p^{\frac{1}{4}}\log+\log)$ 的

tips：大概如果不用 int128 你要记得写过龟速乘，而且到处都应该调用它，否则你会挂得很惨。

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )
#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )
#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )
#define re register
#define int long long
int gi() {
	char cc = getchar() ; int cn = 0, flus = 1 ;
	while( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }
	while( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;
	return cn * flus ;
}
const int N = 100 + 5 ; 
const int P = 998244353 ; 
int n, k, st[N], top, w[N], cnt ; 
int mul( int a, int b, int p ) {
	int ans = 0, base = a ; 
	while(b) {
		if( b & 1 ) ans = ( ans + base ) % p ;
		base = ( base + base ) % p, b >>= 1 ; 
	} return ans ; 
}
int fpow( int x, int k, int p ) {
	int ans = 1, base = x ; 
	while(k) {
		if( k & 1 ) ans = mul( ans, base, p ) ;
		base = mul( base, base, p ), k >>= 1 ; 
	} return ans ; 
}
int Rand( int x ) {
	return ( ( 1ll * rand() << 16ll ) | rand() ) % x + 1 ; 
}
int Miller( int p ) {
	if( p == 2 || p == 3 ) return 1 ; 
	if( p == 1 || p % 2 == 0 ) return 0 ; 
	int d = p - 1, s = 0 ; while( !( d & 1 ) ) ++ s, d >>= 1 ; 
	rep( i, 0, 7 ) {
		re int a = rand() % ( p - 3 ) + 2 ; 
		int x = fpow( a, d, p ), y = 0 ;
		for( re int j = 0; j < s; ++ j ) {
			y = mul( x, x, p ) ; if( y == 1 && ( x != 1 ) && ( x != p - 1 ) ) return 0 ; 
			x = y ; 
		} if( y != 1 ) return 0 ; 
	} return 1 ; 
}
int gcd( int x, int y ) {
	return ( x == 0 ) ? y : gcd( y % x, x ) ;
}
int solve(int p) {
	int k = 2, x = Rand(p - 1) + 1, y = x, d = 1, c = Rand(1097) + 992 ; 
	for( re int i = 1; d == 1; ++ i ) {
		x = ( mul( x, x, p ) + c ) % p ; 
		d = gcd( (x > y) ? x - y : y - x, p ) ;
		if( i == k ) k <<= 1, y = x ;
	} return d ; 
}
void PR( int p ) {
	if( p == 1 ) return ; 
	if( Miller(p) ) { st[++ top] = p ; return ; }
	int x = p ; while( x == p ) x = solve(x) ;
	PR(x), PR(p / x) ; 
}
int C( int x, int y ) {
	int ans1 = 1, ans2 = 1 ; 
	for( re int i = 0; i < y; ++ i ) ans1 = mul( ans1, ( x - i ), P ), ans2 = mul( ans2, ( i + 1 ), P ) ; 
	return mul( ans1, fpow( ans2, P - 2, P ), P ) ;
}
signed main()
{
	srand(time(NULL)) ; 
	n = gi(), k = gi() + 2 ; 
	PR(n) ; 
	sort( st + 1, st + top + 1 ) ;
	rep( i, 1, top ) {
		if( st[i] == st[i - 1] ) ++ w[cnt] ;
		else w[++ cnt] = 1 ; 
	}
	int Ans = 1 ; 
	rep( i, 1, cnt ) Ans = Ans * C( w[i] + k - 1, w[i] ) % P ;
	printf("%lld\n", (long long)Ans ) ;
	return 0 ;
} 
```

---

## 作者：Treeloveswater (赞：3)

Emmm关于那个式子的证明我来说一种不是数学归纳法的证明  

我们考虑最终结果的某个数x，他的某个质数p的幂是t

对于n来说这个质数p的幂是b

那么也就是经过这k次变换后，这个质数p的幂从b降到了t

相当于我们要把k划分成(b-t+1)个区间，每个区间代表着这个质数的幂是什么

那么回过头来看，相当于是我们要把k划分成 ai+1 个区间 ，每个区间可以为空

那就是经典的组合数插板法了。这样就能证明那个式子的正确性了。

---

## 作者：BLUE_EYE (赞：2)

看到有人问这个式子怎么推出来来的，我来回答一下，不知道是不是正解，由于我不会Miller-Rabin和Pollard-Rho算法，所以暂时只有83分，还没A掉QAQ，昨天卧床想到的。  
对于一个整数N，可以分解为$P1^{a1}*P2^{a2}*……Pm^{am}$。对于K=0的情况，由排列组合可以得到a1有取0-a1的情况，a2有取0-a2的情况……  
答案为$(a1+1)*(a2+1)*……*(am+1)$。  
讨论对K=1的情况，每个分解出来的数字都可以表示为$P1^{b1}*P2^{b2}*……Pm^{bm}$,其中$b1∈[0,a1]$举个例子，以30为例子
30=$2*3*5$,所以K=0时答案为$2*2*2=8$。K=1时，其中b1可以取0，也可以取1，由K=0的情况来看，最终答案应当是$((0+1)+(1+1)*answer(b2,b3)$,这样递推，得到K=1时，最终答案为$(1+2)*(1+2)*(1+2)=27$,那么，如果是60，答案就是$(1+2+3)*(1+2)*(1+2)=54$,经过简单的数学推导，当N=60时最终答案即为$C^2_4*C^2_3*C^2_3=54$,而K=0的情况即为$C^1_3*C^1_2*C^1_2=12$，再推广到一般来说的K=1，最终答案即为$\prod_{i=1}^mC_{a_i+2}^2$ ,再进行推广,对于一般的K，即最后的推导式就是$\prod_{i=1}^mC_{a_i+K+1}^{K+1}$,由于这个式子比较难算，我们给他换一下，就是$\prod_{i=1}^mC_{a_i+K+1}^{a_i}$。到这里证明就结束啦。至于后面的质因数处理和代码，大家可以看其他人的代码理解。

---

## 作者：物灵 (赞：1)

（关于 $f(p^r,k)=\sum\limits_{i=0}^rf(p^i,k-1)$ 请参考其他题解）

贾宪三角：

    1
    1  1
    1  2  1
    1  3  3  1
    1  4  6  4  1
    1  5  10 10 5  1
    1  6  15 20 15 6  1

如果竖着看（行列均按照从 0 开始）：

       行数：1  2  3  4  5  6
    第 1 列：1  2  3  4  5  6
    第 2 列：   1  3  6  10 15……（第 1 列前缀和）
    第 3 列：      1  4  10 20……（第 2 列前缀和）
    ……

刚好是高维前缀和！

再祭出原函数表（行为 $n$，列为 $k$）：

       0    1    2    3
    1  1    1    1    1
    2  2    3    4    5
    4  3    6    10   15
    8  4    10   20   35

上下比对，即可看到对应关系：$f(p^r,k)=\mathrm C_{r+k+1}^{k+1}$。

因式分解用 [某某质数检验](https://www.luogu.org/blog/lingchi/miller-rabin)，大组合数用逆元，julao 之述备矣。

根据贾宪三角递推方式，容易给出具体证明。


---


# 排队

## 题目背景

$CYJian$班的这个队形...是梯形么??

$\color{white}\text{信息竞赛班的女生能有多少??}$

## 题目描述

教官觉得$CYJian$班上的队形~~不是很美观~~很不美观..所以教官决定要重排一下队形..

教官先让所有同学按照学号排好序站成一列,然后每一次把当前队列第1,2,3,5,8,13...(差不多就是斐波那契数列了..)个人拉出来,直到没有人能拉出来为止..然后这些人组成一行,排到上一行的后面..

举个栗子,如果一共有10个人,大概就是这样子的:(加粗表示当前选到的人)

1: **1** **2** **3** 4 **5** 6 7 **8** 9 10

取走后: 4 6 7 9 10

2: **4** **6** **7** 9 **10**

取走后: 9

3: **9**

最后的队形长这样:

第一行: 1 2 3 5 8

第二行: 4 6 7 10

第三行: 9

(教官排的队形当然得说好看了..)

我们现在定义一行的美观度: 这一行所有人学号的乘积能分解的质因子的个数..(~~特别的~~,1分解质因子不能得到任何质因子,所以个数为0)

比如第二行,$4 \times 6 \times 7 \times 10=1680=2 \times 2 \times 2 \times 2 \times 3 \times 5 \times 7 \rightarrow 7$

年级一共有$T$个班级,每一个班级都要排一次队形..

现在给出第$i$个班级人数$N_i$和一个正整数$K_i$,需要你求出第$i$个班级排队形后第$K_i$行的队伍的美观度..

特别的,如果排的队形中没有第$K_i$行则输出-1..

## 说明/提示

$Subtask$ $1$($30$ $pts$): $ K_i = 1, 1 \leqslant N_i, T \leqslant 1000 $

$Subtask$ $2$($30$ $pts$): $ 1 \leqslant K_i \leqslant 100 \ \ \ \  1 \leqslant N_i \leqslant 10000  \ \ \ \  1 \leqslant T \leqslant 5000  $

$Subtask$ $3$($40$ $pts$): $ 1 \leqslant K_i \leqslant 10000 \ \ \ \ \  1 \leqslant N_i \leqslant 5*10^6 \ \ \ \ \  1 \leqslant T \leqslant 10^6 $

数据不保证存在全是-1的测试点..

注意:**本题捆绑测试**

## 样例 #1

### 输入

```
3
10 2
12 2
1 2
```

### 输出

```
7
7
-1
```

# 题解

## 作者：动物世界 (赞：6)

%%%……这道题蒟蒻想了好久啊…

写个题解纪念下，同时也为~~和我一样~~看不懂出题人题解的oier们指点一条新的道路

肯定还是要先预处理出每个数质因数的个数，这个用线性筛可以解决，因为它是一个“和性函数”。此外，还要预处理出斐波那契数列，大概40个吧。

我们可以建立一个数组$a$，如果这个数$x$还没有被选过，$a[x]$就为$1$，反之$a[x]$则为$0$,建立一个树状数组$c$记$a$的前缀和。

假设$Ni$是$maxn$，$num[w][j]$表示第$w$行第$j$个编号为多少，$sum[w][j]$表示第$w$行前$j$个数的质因数个数的前缀和，那么询问的时候答案就是$sum[ki][r]$，$r$就是在$num[w]$中小于等于$Ni$的最大值的下标。（即$upper\_bound(Ni)-1$）

那么$sum$怎么预处理呢？

我们可以知道，第$w$行的第$1$个数即为选完$w-1$行后剩下来的第$1$个数，第$2$个即为选完$w-1$行后剩下来的第$2$个数，第$j$个即为剩下来的第$j$个预处理出的斐波那契数。而处理完第$j-1$个数之后，那个位置上的$a[x]$会变成$0$，那我们要找到第$j$个数是什么，只要找到一个$p$，使得$p$在$a$的前缀和恰好等于$fib[j]-j+1$即可（这里理解一下啊），然后我们就可以预处理出$sum$以及$num$数组了。

但是问题又来了：怎么找呢？

笔者一开始想到的是$\log^2{n}$的树状数组+二分，但是感觉会T，于是冥思苦想+学习了树状数组加倍增的精妙写法……主要代码在下面，相信学过倍增和树状数组的oier们都能看懂…
```cpp
int t=(1<<22),pos=0;
    int tot=0;
    for(;t;t>>=1){
    	if(tot+c[t+pos]<x){
    		pos+=t;
    		tot+=c[pos];
		} 
	}
    return pos+1;
```
这是一种非常实用的方法，在许多题目里都可以用来减少一个$\log{n}$的复杂度

大家一定都明白了吧！

时间复杂度：$O(n\log{n}+T\log{n})$

最后吐槽一点，按照我随性的代码风格，卡空间这种操作令我痛不欲生啊……

下面是完整代码（部分变量名可能与题解里的不同，大家看懂就好）
```cpp
#include<bits/stdc++.h>
using namespace std;
template<typename T>void Read(T &x){
    x=0;int f=1;char s=getchar();
    while(!isdigit(s)){if(s=='-') f=-1;s=getchar();}
    while(isdigit(s)){x=x*10+s-'0';s=getchar();}
    x*=f;
}
const int maxn=5*1e6,maxk=1e4,fbnq_size=45;
int c[maxn+10],p[100];
inline int lowbit(int x){
    return x&-x;
}
void add(int x,int y){
    for(;x<=maxn;x+=lowbit(x)) c[x]+=y;
}
int pri[maxn/10];
bitset<maxn+10> fac;
short d[maxn+10];
int siz=0;
void do_d(){
    for(int i=2;i<=maxn;i++){
        if(fac[i]==0){
            pri[++siz]=i;
            d[i]=1;
        }
        for(int j=1;j<=siz;j++){
            if(i*pri[j]>maxn) break;
            fac[i*pri[j]]=1;
            d[i*pri[j]]=d[i]+1;
            if(i%pri[j]==0) break;
        }
    }
}
vector<int> sum[maxk+10];
vector<int> num[maxk+10];
int find_num(int x){
    int t=(1<<22),pos=0;
    int tot=0;
    for(;t;t>>=1){
    	if(tot+c[t+pos]<x){
    		pos+=t;
    		tot+=c[pos];
		} 
	}
    return pos+1;
}
void pre_process(){
    do_d();
    p[1]=1;p[2]=2;
    for(int i=3;i<=fbnq_size;i++) p[i]=p[i-1]+p[i-2];
    for(int i=1;i<=maxn;i++){
        add(i,1);
    } 
    int tot=maxn;
    for(int i=1;i<=maxk;i++){
        for(int j=1;tot>=p[j]-j+1;j++){
            int pos=find_num(p[j]-j+1);
            add(pos,-1);tot--;
            if(j==1) sum[i].push_back(d[pos]);
            else{
                int x=sum[i][j-2]+d[pos];
                sum[i].push_back(x); 
            } 
            num[i].push_back(pos); 
        }
    }
}
int main(){
    pre_process();
    int T;
    Read(T);
    for(int t=1;t<=T;t++){
        int n,k;
        Read(n);Read(k);
        if(num[k][0]>n) printf("%d\n",-1);
        else{
            int pos=upper_bound(num[k].begin() ,num[k].end() ,n)-num[k].begin() -1;
            printf("%d\n",sum[k][pos]);
        }
    } 
    return 0;
}

```

---

## 作者：CYJian (赞：5)

比赛前三天蒟蒻打了一个暴力想要看看数据强度的时候,发现正解挂了!!!

然后调了出题人一个下午终于肝出来了..

~~(蒟蒻出题人再也不出毒瘤数据结构题了..)~~

首先我们可以预处理出$1$~$10^7$所有的数能分解的质因子个数..

这个可以用欧拉线性筛筛出来..虽然这个并不是积性函数..

我们可以预处理出斐波那契数列的前$40$项..这么多已经够用了..

然后我们把第$i$项改成原来的第$i$项减去第$i-1$项..

这样子就变成了与上一个隔多少个就再取一个数了..

比如说原来的斐波那契数列是:1, 2, 3, 5, 8...

然后我们把它魔改成:1, 1, 1, 2, 3...(实际上是右移了两下..)

对于第一行来说,上面五个数就表示: 第一个要选的是上一个(没有为$0$)的后一位: $1$

第二个要选的就是上一个($1$)的后一位: $2$

第三个要选的就是上一个($2$)的后一位: $3$

第四个要选的就是上一个($3$)的后两位: $5$

第五个要选的就是上一个($5$)的后三位: $8$

...

然而还是斐波那契数列..

~~这个有个$\pi$(pi)用啊!!!~~

当然有用啊..

~~改成了这样后我们就可以搞$60$的暴力辣!!!~~

首先我们发现前10的分组是这样的:

|1| 2| 3| 4| 5| 6| 7| 8| 9| 10|...|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|1| 1| 1| 2| 1| 2| 2| 1| 3| 2|...|

没有发现什么吗??

然后让我们把之前的候选的东西放进去:


|数字|1| 2| 3| 4| 5| 6| 7| 8| 9| 10|...|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|**归属**|1|1|1|2|1|2|2|1|3|2|...|
|**第$1$行的候选**|1|1|1|2|1|3|2|1|5|4|...|
|**第$2$行的候选**|(1)-|(1)-|(1)-|1|(1)-|1|1|(1)-|2|1|...|
|**第$3$行的候选**|(1)-|(1)-|(1)-|(1)-|(1)-|(1)-|(1)-|(1)-|1|(1)-|...|

当然,这里面打'-'的表示不可能选到的..括号表示没有改变(或者说是无关的)候选..

然后一个很显然的一点: 一个数字如果属于前面的行是不可能影响到后面的行的候选的..

#### 而且从数字为10的时候我们可以看出:如果当前候选的有多个为1的(第$2$行和第$3$行),优先选择行数小的(第$2$行),并且行数大的(第$3$行)候选不改变(虽然这里貌似看不出来,但是可以自己多写写就可以看出来了)..并且不是可选行且比当前选择行(第$2$行)小的(第$1$行)候选也要减..

不信可以自己试试..~~Markdown的表格真难写..~~

然后这个就可以离线询问然后$O(NK)$模拟了..

至于正解..

我们发现这个就是一个区间最小值,区间减法,这个直接用线段树搞就好了..

附上一个小优化:如果当前$10^4$的行内候选都大于$1$(假设是$x$),那么后面$x-1$的数都肯定不是这$10^4$行内的东西..所以可以直接在枚举$N$的时候加上$x-1$,然后$1$~$10^4$区间减去$x-1$就好了..

附上丑陋而异常臃肿的代码..

```cpp
#include <bits/stdc++.h>

using namespace std;

#define reg register
#define enter putchar('\n')
#define ls (Node << 1)
#define rs ((Node << 1) | 1)
#define MAXN 5000000
#define MAXT 1000000
#define MAXK 10000

const char FI[] = "queue.in";
const char FO[] = "queue.out";

typedef short sh;

inline int Min(reg int a, reg int b) { return a < b ? a : b; }

inline int read() {
    reg int s = 0, t = 1; reg char ch = getchar();
    while(ch > '9' || ch < '0') t *= ch == '-' ? -1 : 1, ch = getchar();
    while(ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();
    return s * t;
}

struct Node {
    sh k;
    int n;
    int id;
}Ask[MAXT + 1];

bool operator < (Node a, Node b) {
    return a.n < b.n;
}

int T;
sh s[MAXN + 1];
int res[MAXT + 1];
int fib[50] = {1, 1};
int prime[40 * MAXK];
bitset<MAXN + 1>Check;

int Id[MAXK << 5];
int pos[MAXK << 5];
int tag[MAXK << 5];
int Tree[MAXK << 5];

inline void init() {
    reg int tot = 0;
    for(reg int i = 2; i <= MAXN; i++) {
        if(!Check[i]) prime[++tot] = i, s[i] = 1;
        for(reg int j = 1; j <= tot && i * prime[j] <= MAXN; j++) {
            Check[i * prime[j]] = 1, s[i * prime[j]] = s[i] + 1;
            if(i % prime[j] == 0) break;
        }
    }
    for(reg int i = 2; i < 50; i++) fib[i] = fib[i - 1] + fib[i - 2];
    for(reg int i = 49; i > 1; i--) fib[i] -= fib[i - 1];
    T = read();
    for(reg int i = 1; i <= T; i++)
        Ask[i].n = read(), Ask[i].k = read(), Ask[i].id = i;
    sort(Ask + 1, Ask + T + 1);
}

inline void build(reg int Node, reg int L, reg int R) {
    Tree[Node] = 1;
    if(L == R) {
        Id[Node] = L, pos[Node] = Node;
        return ;
    }
    reg int mid = (L + R) >> 1;
    build(ls, L, mid), build(rs, mid + 1, R);
    pos[Node] = pos[ls];
}

inline void Add(reg int Node, reg int L, reg int R, reg int l, reg int r, reg int k) {
    if(l <= L && R <= r) {
        Tree[Node] += k, tag[Node] += k;
        return ;
    }
    Tree[ls] += tag[Node]; tag[ls] += tag[Node];
    Tree[rs] += tag[Node]; tag[rs] += tag[Node];
    tag[Node] = 0;
    reg int mid = (L + R) >> 1;
    if(l <= mid) Add(ls, L, mid, l, r, k);
    if(r > mid) Add(rs, mid + 1, R, l, r, k);
    Tree[Node] = min(Tree[ls], Tree[rs]);
    pos[Node] = (Tree[Node] == Tree[ls] ? pos[ls] : pos[rs]);
}

int main() {
    init();
    reg int M = Ask[T].n;
    reg int id = 1;
    reg int g[MAXK + 1];
    reg int ans[MAXK + 1]; memset(ans, -1, sizeof(ans));
    for(reg int i = 1; i <= 10000; i++) g[i] = 1;
    build(1, 1, 10000);
    for(reg int i = 1, Mi, add, ID; id <= T && i <= M; i++) {
        Mi = pos[1], ID = Id[Mi];
        Add(1, 1, 10000, ID, ID, 0);
        add = Tree[Mi];
        Add(1, 1, 10000, 1, ID, -add);
        if(add > 1 && ID < 10000)
            Add(1, 1, 10000, ID + 1, 10000, 1 - add);
        Add(1, 1, 10000, ID, ID, fib[++g[ID]]);
        while(id <= T && Ask[id].n < i + add - 1) res[Ask[id].id] = ans[Ask[id].k], id++;
        i += add - 1;
        if(i > M || id > T) break;
        ans[ID] += s[i] + (ans[ID] < 0);
        while(id <= T && Ask[id].n <= i) res[Ask[id].id] = ans[Ask[id].k], id++;
    }
    for(reg int i = 1; i <= T; i++) printf("%d", res[i]), enter;
    return 0;
}
```

---

## 作者：Redshift_Shine (赞：0)

## 闲话

~~众所周知~~，前有 [P3684](/problem/P3684)=前缀和+二分+最小生成树+并查集+启发式合并，后有 [P4901](/problem/P4901)=素数线性筛+询问离线+线段树+斐波那契数列。

两题共同点在于，都是普及算法的大杂烩。讽刺的是，它们竟然都是紫题。

## 题解

本题可以被拆分成两个**互不关联**的子问题：

1. 对 $[1,\max N_i]$ 区间中的每个整数求出其质因子个数。注意，此处是质因子**个数**而不是**种数**，后者需要去重，而本题不需要。该部分可以在 $O(\max N_i)$ 时间复杂度内完成。
2. 对于 $[1,\max N_i]$ 区间中的每个整数求出其从属的队伍编号。目前作者仍没有发现该部分不带 $\log$ 的做法，所以该部分可以在 $O(\max N_i \log \max K_i)$ 的时间复杂度内完成。

### Part $1$

该部分非常简单。注意到若将素数线性筛的标记 `vis` 数组过程看作建树，那么 $x$ 的父亲是 $x$ 除以 $x$ 的最小质因子。也就是说，$x$ 的质因子个数恰好比其父亲多一个。由此，可以通过对素数线性筛的代码进行极其细微的修改达到这个目的。

以下代码中，$\text{ds}_x$ 为 $x$ 的质因子个数。

```c++
for (int i = 2; i <= mxp; i++)
{
    if (!vis[i])
        pr[++idx] = i, ds[i] = 1;
    for (int j = 1; i * pr[j] <= mxp; j++)
    {
        vis[i * pr[j]] = true;
        ds[i * pr[j]] = ds[i] + 1;
        if (i % pr[j] == 0)
            break;
    }
}
```

### Part $2$

本题的难点为这个部分。将题面进行一些转换，考虑加入一个数后每一个小队“选人”的策略会发生如何的改变。

首先，每个小队会选择目前队伍中第 $1,2,3,5,8,\dots$ 个人。如果认为他们会在选中每个人之后选择接下来的第 $1,1,2,3,5,8,\dots$ 个人，那么会变得更好处理。

具体来说，我们使用一个线段树，每个节点中维护区间内等待人数最小值以及其位置。显然，这个人将会加入目前编号最小的不需要额外跳过人的小队。我们按照斐波那契数列的值更新对应小队接下来选择的人的位置。

然而这样讲会有点抽象。还可以这样理解：

这个将要被加进来的人会被按编号顺序依次拉到每个小队进行检查。如果某个小队决定收入接下来遇到的第一个人，那么将他拉进来。否则，将决定从“收入接下来遇到的第 $x$ 个人”改为“收入接下来遇到的第 $(x-1)$ 个人，然后将他送到下一个小队检查。

这种方法可以方便地在线段树上维护。

### Part Ex

对于任何高 I/O 量的题目（比如这题），加快读快写都会给程序带来巨大的运行效率提升。

同时在低数据范围下，有一些不需要做的计算不要做，否则会浪费时间。

至此，本题解决。

## 代码

```c++
#include <algorithm>
#include <bitset>
#include <cctype>
#include <cstdio>
#include <tuple>
#include <utility>
using namespace std;
const int N = 5e6 + 10, K = 1e4 + 10, M = 1e2 + 10, T = 1e6 + 10;
using pii = pair<int, int>;
using t3i = tuple<int, int, int>;
int n, res[T], pr[N], ds[N], cur[K], mxp, k, buc[M], idx, tidx = 1;
bitset<N> vis;
t3i qry[T];
template <typename _Tp> void read(_Tp &x)
{
    char ch;
    while (ch = getchar(), !isdigit(ch))
        ;
    x = ch ^ 48;
    while (ch = getchar(), isdigit(ch))
    {
        x = (x << 3) + (x << 1) + (ch ^ 48);
    }
}
template <typename _Tp, typename... _Args> void read(_Tp &x, _Args &...args)
{
    read(x);
    read(args...);
}
template <typename _Tp> void print(_Tp x)
{
    if (x < 0)
        return (putchar('-'), print(-x));
    if (x > 9)
        print(x / 10);
    putchar((x % 10) ^ 48);
}
struct st
{
    int mnv, mnp, tag;
    short lvl;
    st operator+(const st &x) const
    {
        return {min(mnv, x.mnv), mnv != x.mnv ? (mnv < x.mnv ? mnp : x.mnp) : (mnp < x.mnp ? mnp : x.mnp), 0, 0};
    }
} tr[K << 2];
void build(int x, int l, int r)
{
    if (l == r)
    {
        tr[x] = {0, l, 0, 0};
        return;
    }
    int mid = (l + r) >> 1;
    build(x << 1, l, mid);
    build(x << 1 | 1, mid + 1, r);
    tr[x] = tr[x << 1] + tr[x << 1 | 1];
}
void psh(int x)
{
    tr[x << 1].mnv += tr[x].tag;
    tr[x << 1 | 1].mnv += tr[x].tag;
    tr[x << 1].tag += tr[x].tag;
    tr[x << 1 | 1].tag += tr[x].tag;
    tr[x].tag = 0;
}
void update(int x, int l, int r, int lb, int rb, int v)
{
    if (l >= lb and r <= rb)
    {
        tr[x].tag += v;
        tr[x].mnv += v;
        return;
    }
    if (tr[x].tag)
        psh(x);
    int mid = (l + r) >> 1;
    if (lb <= mid)
        update(x << 1, l, mid, lb, rb, v);
    if (rb > mid)
        update(x << 1 | 1, mid + 1, r, lb, rb, v);
    tr[x] = tr[x << 1] + tr[x << 1 | 1];
}
void updatesg(int x, int l, int r, int tar)
{
    if (l == r)
    {
        tr[x] = {buc[tr[x].lvl], l, 0, static_cast<short>(tr[x].lvl + 1)};
        return;
    }
    if (tr[x].tag)
        psh(x);
    int mid = (l + r) >> 1;
    if (tar <= mid)
        updatesg(x << 1, l, mid, tar);
    else
        updatesg(x << 1 | 1, mid + 1, r, tar);
    tr[x] = tr[x << 1] + tr[x << 1 | 1];
}
int main()
{
    read(n);
    for (int i = 1, x, y; i <= n; i++)
    {
        read(x, y);
        mxp = max(mxp, x);
        qry[i] = {x, y, i};
    }
    sort(qry + 1, qry + n + 1);
    buc[0] = buc[1] = 1;
    for (int i = 2; buc[i - 1] + buc[i - 2] <= mxp; i++)
    {
        buc[i] = buc[i - 1] + buc[i - 2];
    }
    k = min(mxp, K - 10);
    build(1, 1, k);
    for (int i = 2; i <= mxp; i++)
    {
        if (!vis[i])
            pr[++idx] = i, ds[i] = 1;
        for (int j = 1; i * pr[j] <= mxp; j++)
        {
            vis[i * pr[j]] = true;
            ds[i * pr[j]] = ds[i] + 1;
            if (i % pr[j] == 0)
                break;
        }
    }
    while (tidx <= n and get<0>(qry[tidx]) == 1)
    {
        res[get<2>(qry[tidx])] = (get<1>(qry[tidx]) == 1 ? 0 : -1);
        tidx++;
    }
    for (int i = 1, tps; i <= mxp; i++)
    {
        tps = tr[1].mnp;
        if (tr[1].mnv)
        {
            update(1, 1, k, 1, k, -1);
        }
        else
        {
            updatesg(1, 1, k, tps);
            update(1, 1, k, 1, tps, -1);
            cur[tps] += ds[i];
        }
        while (tidx <= n and get<0>(qry[tidx]) == i)
        {
            auto &[tx, ty, tz] = qry[tidx];
            res[tz] = cur[ty];
            if (!res[tz])
                res[tz] = -1;
            tidx++;
        }
    }
    for (int i = 1; i <= n; i++)
    {
        print(res[i]);
        putchar('\n');
    }
}
```

---


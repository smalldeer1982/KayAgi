# 「StOI-2」简单的树

## 题目描述

给定一棵以 $1$ 为根，由 $n$ 个点组成的有根树，每个点有点权 $c_{i}$ 。

定义每个点的 $val$ 值为：以它为根的子树内所有 $c_{i}$ 的最大值。

定义函数 $f(x,y)$ 表示将 $c_{x}$ 改为 $y$ 后整棵树的 $val$ 值之和。

现在请您回答 $q$ 组询问，每次询问给定 $3$ 个量 $(l,r,a)$ ，请求出 $\sum\limits_{i=l}^{r}{f(a,i)}$ 对 $998,244,353$ 取模的结果。

## 说明/提示

## 样例解释

真实的 $(l,r,a)$ 为：

- $(2,4,1)$
- $(3,5,2)$
- $(2,4,5)$

---

## 数据范围

对于 $10\%$ 的数据：$1 \leq n,q \leq 100 $ 。   
对于 $20\%$ 的数据：$1 \leq n,q \leq 3000 $ 。   
对于另 $20\%$ 的数据：$1 \leq l',r',c_{i} \leq 2 $ 。   
对于另 $20\%$ 的数据：$l'=r'$ 。   
对于前 $80\%$ 的数据：$opt=0$ 。   
对于 $100\%$ 的数据：$1 \leq n,q \leq 5 \times 10^{5} ，1 \leq c_{i} , a' , l' , r' \leq n$ 。

## 样例 #1

### 输入

```
5 3 0
5 3 4 2 1
1 2
1 3
2 4
2 5
1 3 5
2 4 1
1 3 4```

### 输出

```
42
48
52```

# 题解

## 作者：hellolin (赞：3)

注：下文下标统一从 $0$ 开始，根节点是 $0$，区间采用左闭右开记法，一条链包含它的两个端点。

首先我们观察到以下性质：

1. 题目所求 $\sum\limits^{r}_{i=l}f(a,i)$ 可以转为 $\sum\limits^{r}_{i=0}f(a,i)-\sum\limits^{l-1}_{i=0}f(a,i)$，所以修改操作可以只考虑 $[0, r)$ 的情况。
2. 如果对点 $x$ 做修改，答案受影响的节点一定都在 $0\to x$ 的链上。
3. 每个节点的答案一定不小于它的任何一个儿子，也就是说从下至上是单调不降的。
4. 如果我们事先知道某个子树内删除 $x$ 之外的答案，那么我们就可以在 $x$ 更改权值之后知道子树新的答案。

我们先考虑只对于一棵子树，修改一次的情况。根据性质四，我们可以维护子树内最大值和次大值，这样可以快速知道更新后的答案。

再考虑修改多次的情况，我们已经知道了除 $x$ 之外的答案 $v$，值在区间 $[0, r)$ 中取，怎么知道答案之和呢？

如果 $v\geq r-1$，那么无论怎么修改，答案都是 $v$ 不变。修改 $r$ 次的总贡献为 $v\times r$。

如果 $v < r-1$，那么前 $v$ 次修改时答案都是 $v$，后面 $r-v$ 次答案为 $v,v+1,v+2,\dots,r-1$。修改 $r$ 次的总贡献为：

$$
\begin{aligned}
&v^2+v+(v+1)+(v+2)+\dots+(r-1)\\
=\ &v^2+\frac{(r+v-1)(r-v)}{2}\\
=\ &v^2+\frac{r^2-v^2-r+v}{2}\\
=\ &\frac{v^2+v}{2}+\frac{r^2-r}{2}
\end{aligned}
$$

最后我们考虑影响多棵子树怎么做。还是设修改 $x$ 节点，值在区间 $[0, r)$ 取。

根据性质二、性质三，最大值（和次大值）自下而上单调不降，也就是在某一个节点之前，删除 $x$ 之外的答案是子树次大值，在之后是子树最大值。这个分界点我们倍增找就行了。

不难发现这个分界点以下以及以上的区间，又分成了 $v < r-1$ 和 $v \geq r-1$ 的区间，一共四个小区间。我们还是倍增找到这两个分界点。

![](https://cdn.luogu.com.cn/upload/image_hosting/s83r18tb.png)

对于 $v\geq r-1$ 的区间，它们都是链上连续的一段，对于次大值与最大值记录 $v\times r$ 前缀和即可。

对于 $v<r-1$ 的区间，总贡献为（$\mathrm{len}$ 为区间长度）：

$$
\begin{aligned}
&\sum(\frac{v^2+v}{2}+\frac{r^2-r}{2})\\
=\ &\frac{\sum v^2+\sum v}{2}+\frac{\mathrm{len}\times (r^2-r)}{2}
\end{aligned}
$$

维护一下子树内答案和、答案平方和，树剖查询即可。

树剖和倍增初始化 $O(n\log n)$，查询 $O(\log n)$，前缀和初始化 $O(n)$，查询 $O(1)$。总时间复杂度 $O(n\log n)$，写得优秀一点是可以跑进 2s 的。

``` cpp
#include "hellolin/common.hpp"
#include "hellolin/utils.hpp"
#include "hellolin/io.hpp"

namespace hellolin {
static constexpr i64 Mod = 998244353, Inv2 = 499122177;

struct SubTree {
  i64 fir = 0, sec = 0;
  friend SubTree operator+(const auto &l, const auto &r) {
    if (l.fir == r.fir) {
      return {l.fir, r.fir};
    } else if (l.fir > r.fir) {
      return {l.fir, max(l.sec, r.fir)};
    } else {
      return {r.fir, max(r.sec, l.fir)};
    }
  }
  SubTree &operator+=(const auto &r) {
    return *this = *this + r;
  }
};

struct Node {
  struct {
    i64 sum = 0, squ = 0;
  } fir, sec;
  Node operator-() const {
    return { {-fir.sum, -fir.squ}, {-sec.sum, -sec.squ} };
  }
  friend Node operator+(const auto &l, const auto &r) {
    return { {l.fir.sum + r.fir.sum, l.fir.squ + r.fir.squ}, {l.sec.sum + r.sec.sum, l.sec.squ + r.sec.squ} };
  }
  friend Node operator-(const auto &l, const auto &r) {
    return l + -r;
  }
  Node &operator+=(const auto &r) {
    return *this = *this + r;
  }
  Node &operator-=(const auto &r) {
    return *this = *this - r;
  }
};

void main() {
  int n, q, opt;
  io.read(n, q, opt);

  std::vector<int> val(n);
  io.read(val);

  std::vector<std::vector<int>> g(n);
  for (int i = 1, u, v; i < n; ++i) {
    io.read(u, v);
    --u, --v;
    g[u].push_back(v);
    g[v].push_back(u);
  }

  std::vector<int> son(n, -1), dfn(n), idx(n), siz(n), dep(n), top(n);
  std::vector<std::vector<int>> anc(20, std::vector<int> (n));
  std::vector<SubTree> tree(n);
  std::vector<Node> presum(n);
  int tot = 0;

  auto dfs1 = [&](auto &&f, int x, int fa) -> void {
    siz[x] = 1;
    dep[x] = (fa == -1 ? -1 : dep[fa]) + 1;
    anc[0][x] = fa;
    tree[x] = {val[x], 0};

    for (const int &y : g[x]) {
      if (y == fa) continue;
      f(f, y, x);
      siz[x] += siz[y];
      if (son[x] == -1 or siz[y] > siz[son[x]]) son[x] = y;
      tree[x] += tree[y];
    }
  };
  auto dfs2 = [&](auto &&f, int x, int tp) -> void {
    idx[dfn[x] = tot++] = x;
    top[x] = tp;
    if (son[x] != -1) f(f, son[x], tp);
    for (const int &y : g[x]) {
      if (y == anc[0][x] or y == son[x]) continue;
      f(f, y, y);
    }
  };
  dfs1(dfs1, 0, -1);
  dfs2(dfs2, 0, 0);
  for (int i = 1; i <= 19; ++i) {
    anc[i][0] = -1;
    for (int j = 1; j < n; ++j) {
      if (anc[i - 1][j] != -1)
        anc[i][j] = anc[i - 1][anc[i - 1][j]];
      else
        anc[i][j] = -1;
    }
  }

  presum[0] = {
      {tree[0].fir, tree[0].fir * tree[0].fir},
      {tree[0].sec, tree[0].sec * tree[0].sec}
  };
  for (int i = 1; i < n; ++i) {
    int cur = idx[i];
    presum[i] = presum[i - 1] + Node({
      {tree[cur].fir, tree[cur].fir * tree[cur].fir},
      {tree[cur].sec, tree[cur].sec * tree[cur].sec}
    });
  }

  auto query = [&](int l, int r) {
    if (l == 0) return presum[r - 1];
    return presum[r - 1] - presum[l - 1];
  };

  auto queryLink = [&](int x, int y) {
    Node result;
    while (top[x] != top[y]) {
      if (dep[top[x]] < dep[top[y]]) swap(x, y);
      result += query(dfn[top[x]], dfn[x] + 1);
      x = anc[0][top[x]];
    }
    if (dep[x] > dep[y]) swap(x, y);
    result += query(dfn[x], dfn[y] + 1);
    return result;
  };

  auto solve = [&](int a, i64 r) -> i64 {
    if (r <= 0) return 0;
    i64 result = 0;

    int b = a;
    for (int i = 19; i >= 0; --i) {
      if (anc[i][b] == -1) continue;
      if (tree[anc[i][b]].fir <= val[a]) b = anc[i][b];
    }

    if (tree[b].fir <= val[a]) {
      int c = a;
      for (int i = 19; i >= 0; --i) {
        if (anc[i][c] == -1 or dep[b] > dep[anc[i][c]]) continue;
        if (tree[anc[i][c]].sec < r - 1) c = anc[i][c];
      }

      if (tree[c].sec < r - 1) {
        Node link = queryLink(a, c);
        i64 count = dep[a] - dep[c] + 1;
        i64 delta = (count * (r * (r - 1) % Mod) % Mod + link.sec.squ + link.sec.sum) % Mod * Inv2 % Mod;
        result = (result + delta % Mod) % Mod;
        c = anc[0][c];
      }
      if (c != -1 and dep[c] >= dep[b]) {
        Node link = queryLink(c, b);
        result = (result + link.sec.sum * r % Mod) % Mod;
      }
      b = anc[0][b];
    }
    if (b == -1) return result;

    int d = b;
    for (int i = 19; i >= 0; --i) {
      if (anc[i][d] == -1) continue;
      if (tree[anc[i][d]].fir < r - 1) d = anc[i][d];
    }

    if (tree[d].fir < r - 1) {
      Node link = queryLink(b, d);
      i64 count = dep[b] - dep[d] + 1;
      i64 delta = (count * (r * (r - 1) % Mod) % Mod + link.fir.squ + link.fir.sum) % Mod * Inv2 % Mod;
      result = (result + delta % Mod) % Mod;
      d = anc[0][d];
    }
    if (d != -1) {
      Node link = queryLink(d, 0);
      result = (result + link.fir.sum * r % Mod) % Mod;
    }

    return result;
  };

  i64 answer = 0, origin = query(0, n).fir.sum;
  for (int i = 0, l, r, a; i < q; ++i) {
    io.read(l, r, a);
    l = (answer * opt + (i64) l) % n + 1;
    r = (answer * opt + (i64) r) % n + 1;
    a = (answer * opt + (i64) a) % n + 1;
    if (l > r) swap(l, r);
    ++r, --a;

    Node link = queryLink(a, 0);
    answer = ((origin - link.fir.sum) * (r - l) % Mod + solve(a, r) - solve(a, l)) % Mod;
    answer = (answer + Mod) % Mod;
    io.writeln(answer);
  }
}
} // namespace hellolin

int main() { hellolin::main(); }
```

---

## 作者：littleKtian (赞：2)

upd on 2021.1.18：更新了更快的树上二分，现在程序复杂度为 $O(n\log n)$（顺带调整了一部分内容）。~~所以这题有什么开 3s 的必要吗？~~

------------

**简 单**的树

------------

注意到以下比较明显的性质：

+ 修改一个点的点权 $c$ 时，只有自己以及其祖先的 $val$ 值可能发生变化。
+ 如果点 $u$ 的子树内某个点 $v$ 的 $c_v$ 被修改，点 $u$ 的 $val$ 值为子树内除 $v$ 外所有点中最大的 $c$ 和 $v$ 修改后的 $c_v$ 中最大值。

根据第一条，所有不是 $a$ 到根路径上所有点的 $val$ 值可以做到 预处理 $O(n)$+单次询问 $O(1)$ 求出。

根据第二条，容易想到求出每个点子树内最大和次大的 $c$，因为这两个在不断向上的过程中具有单调性，所以可以 树剖+二分 做到 预处理 $O(n)$+单次询问 $O(\log n)$ 求出所有以 $u$（$u$ 是 $a$ 到根路径上的点）为根的子树中除 $a$ 以外所有点中最大的 $c$。

假设我们已经求出了以 $u$ 为根的子树中除 $a$ 以外所有点中最大的 $c$，记作 $x$。

+ $x\leqslant l$

![](https://i.loli.net/2020/08/30/XKLgEwhNGD1rzQo.png)

此时最大值始终取修改后的 $c_a$，直接统计满足的点的个数即可。

+ $x\geqslant r$

![](https://i.loli.net/2020/08/30/D8VGW5vUZ37HuqM.png)

此时最大值始终取 $x$，同样直接求出所有满足的点的 $x$ 之和即可。

+ $l<x<r$

![](https://i.loli.net/2020/08/30/D3bcIQT6Lq1Mw7O.png)

此时贡献为 $(x-l)x+\dfrac{(x+r)(r-x+1)}{2}=\dfrac{x^2}{2}+(\dfrac{1}{2}-l)x+\dfrac{r^2+r}{2}$ 只需要再预存一个子树内最大和次大的 $c$ 的平方就能解决了。

注意到这三部分在 $a$ 到根路径上都是连续的一段，并且按一定顺序，所以 树剖+二分+前缀和 就能解决，同样是 预处理 $O(n)$+单次询问 $O(\log n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int p=998244353;
const int n2=499122177;
int lans,totc,lc[500005];
int qj[500005][2],qjf[500005][2];
int lst[500005],lsw[500005],bi[1000005][2],bs;
int c[500005],f[500005][2];
int fa[500005],so[500005],de[500005],si[500005],to[500005],xh[500005],dy[500005],dfn;
int n,q,opt;
ll dr()
{
    ll xx=0;char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')xx=(xx<<1)+(xx<<3)+ch-'0',ch=getchar();
    return xx;
}
void tj(int u,int v)
{
    ++bs;
    if(lst[u])bi[lsw[u]][0]=bs;
    else lst[u]=bs;
    bi[bs][1]=v,lsw[u]=bs;
}
void dfs(int w,int ff)
{
    f[w][0]=c[w];
    int o_o=lst[w];
    while(o_o)
    {
        int v=bi[o_o][1];
        if(v!=ff)
        {
            dfs(v,w);
            if(f[v][0]>=f[w][0])
            {
                f[w][1]=f[w][0],f[w][0]=f[v][0];
                if(f[v][1]>=f[w][1])f[w][1]=f[v][1];
            }
            else if(f[v][0]>=f[w][1])f[w][1]=f[v][0];
        }
        o_o=bi[o_o][0];
    }
}
void dfs1(int w,int ff,int d)
{
    fa[w]=ff,de[w]=d,si[w]=1,totc=(totc+f[w][0])%p,lc[w]=(lc[ff]+f[w][0])%p;
    int o_o=lst[w];
    while(o_o)
    {
        int v=bi[o_o][1];
        if(v!=ff)
        {
            dfs1(v,w,d+1);
            if(si[v]>si[so[w]])so[w]=v;
        }
        o_o=bi[o_o][0];
    }
}
void dfs2(int w,int t)
{
    to[w]=t,xh[w]=++dfn,dy[dfn]=w;
    qj[dfn][0]=(qj[dfn-1][0]+f[w][0])%p,qj[dfn][1]=(qj[dfn-1][1]+f[w][1])%p;
    qjf[dfn][0]=(qjf[dfn-1][0]+1ll*f[w][0]*f[w][0])%p,qjf[dfn][1]=(qjf[dfn-1][1]+1ll*f[w][1]*f[w][1])%p;
    if(so[w])dfs2(so[w],t);
    int o_o=lst[w];
    while(o_o)
    {
        int v=bi[o_o][1];
        if(v!=fa[w]&&v!=so[w])dfs2(v,v);
        o_o=bi[o_o][0];
    }
}
int jum(int x,int d)
{
    if(d==0)return 0;
    int fx=to[x];
    while(de[fx]>d)x=fa[fx],fx=to[x];
    return dy[xh[fx]+d-de[fx]];
}
int fin1(int w)//二分，fin2和fin3类似
{
	int x=w,fx=to[x];
	while(fx)
	{
		if(f[fx][0]>c[w])break;
		x=fa[fx],fx=to[x];
	}
	int lef=de[fx],rig=de[x]+1,mid;
	while(lef+1<rig)
	{
		mid=(lef+rig)>>1;
		if(f[dy[xh[fx]+mid-de[fx]]][0]==c[w])rig=mid;else lef=mid;
	}
	return rig;
}
int fin2(int w,int fw,int l)
{
	int x=w,fx=to[x];
	while(fx)
	{
		if(f[fx][de[fx]<fw?0:1]>l)break;
		x=fa[fx],fx=to[x];
	}
	int lef=de[fx],rig=de[x]+1,mid;
	while(lef+1<rig)
	{
		mid=(lef+rig)>>1;
		if(f[dy[xh[fx]+mid-de[fx]]][mid<fw?0:1]<=l)rig=mid;else lef=mid;
	}
	return rig;
}
int fin3(int w,int fw,int r)
{
	int x=w,fx=to[x];
	while(fx)
	{
		if(f[fx][de[fx]<fw?0:1]>=r)break;
		x=fa[fx],fx=to[x];
	}
	int lef=de[fx],rig=de[x]+1,mid;
	while(lef+1<rig)
	{
		mid=(lef+rig)>>1;
		if(f[dy[xh[fx]+mid-de[fx]]][mid<fw?0:1]<r)rig=mid;else lef=mid;
	}
	return lef;
}
int cx(int w,int op)
{
    if(w==0)return 0;
    int fw=to[w],x=0;
    while(fw)x=(1ll*x+qj[xh[w]][op]-qj[xh[fw]-1][op]+p)%p,w=fa[fw],fw=to[w];
    return x;
}
int cxf(int w,int op)
{
    if(w==0)return 0;
    int fw=to[w],x=0;
    while(fw)x=(1ll*x+qjf[xh[w]][op]-qjf[xh[fw]-1][op]+p)%p,w=fa[fw],fw=to[w];
    return x;
}
int main()
{
    n=dr(),q=dr(),opt=dr();
    for(int i=1;i<=n;i++)c[i]=dr();
    for(int i=1;i<n;i++)
    {
        int u=dr(),v=dr();
        tj(u,v),tj(v,u);
    }
    dfs(1,0),dfs1(1,0,1),dfs2(1,1);
    while(q--)
    {
        int l=(dr()+opt*lans)%n+1,r=(dr()+opt*lans)%n+1,a=(dr()+opt*lans)%n+1;
        if(l>r)swap(l,r);
        lans=1ll*(totc-lc[a])*(r-l+1)%p;//非a及其祖先部分答案
        int w1=fin1(a),w2=fin2(a,w1,l),w3=fin3(a,w1,r);
        //w1,w2,w3都是用来分段的，结合前文及后面代码可以确认其定义
        int ww1=jum(a,w1-1),ww2=jum(a,w2-1),ww3=jum(a,w3);
        lans=(lans+1ll*(de[a]-w2+1)*(l+r)%p*(r-l+1)%p*n2)%p;//x<=l部分答案
        if(w1<=w3)lans=(lans+1ll*(cx(ww3,1)-cx(ww1,1)+cx(ww1,0)+p)*(r-l+1))%p;
        else lans=(lans+1ll*cx(ww3,0)*(r-l+1))%p;//x>=r部分答案
        int qwq=0,wqw=0;//依次对应区间平方和跟区间和
        if(w1<=w3)qwq=(cxf(ww2,1)-cxf(ww3,1)+p)%p,wqw=(cx(ww2,1)-cx(ww3,1)+p)%p;
        else if(w1<w2)qwq=(1ll*cxf(ww2,1)-cxf(ww1,1)+cxf(ww1,0)-cxf(ww3,0)+2*p)%p,wqw=(1ll*cx(ww2,1)-cx(ww1,1)+cx(ww1,0)-cx(ww3,0)+2*p)%p;
        else qwq=(cxf(ww2,0)-cxf(ww3,0)+p)%p,wqw=(cx(ww2,0)-cx(ww3,0)+p)%p;
        lans=(lans+1ll*qwq*n2+1ll*(n2-l+p)*wqw+(1ll*r*r%p+r)*n2%p*(w2-w3-1))%p;//l<x<r部分答案
        printf("%d\n",lans);
    }
}
```


---


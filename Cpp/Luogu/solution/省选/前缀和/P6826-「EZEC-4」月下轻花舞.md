# 「EZEC-4」月下轻花舞

## 题目背景

>月下的轻花，随轻风飘舞，勾起了你我的记忆......

![](http://p1.music.126.net/mi-oogxsSXkHwPACQRsxgw==/109951163115816964.jpg?param=557y315)

## 题目描述

在轻花林中，有从 $l$ 到 $r$ 编号的轻花树，编号为 $i$ 的树有 $i-1$ 棵，轻花林很美，所以每棵树上都有编号为 $1\sim n$ 的 $n$ 朵轻花，编号为 $i$ 的树上编号为 $j$ 的轻花落下会产生大小为 $\left\lceil\log_ij\right\rceil$ 的魅力值。  

夜幕降临，所有树上的所有轻花全部落下，花痴（雾）tlx 想知道总共有多大的魅力值，但是只算一次太简单了，所以他会设置不同情境询问你 $T$ 次，不过由于答案很大，你只需要告诉他魅力值总和对 $998244353$ 取模的结果。    

**一句话题意**： $T$ 组询问，每次给定三个整数 $l,r,n$，求出下式的值： 

$$\sum_{i=l}^r(i-1)\sum_{j=1}^n \left\lceil\log_ij\right\rceil\;\;\bmod998244353$$

## 说明/提示

**【数据范围与约束】**   

**本题采用捆绑测试，具体约束如下：**  

- Subtask 1 $(1\text{ pts})$：$T=1$，$n=1$；   
- Subtask 2 $(9\text{ pts})$：$l=r=2$；   
- Subtask 3 $(10\text{ pts})$：$T=1$，$n\leq 10^3$，$r\leq 10^3$；   
- Subtask 4 $(10\text{ pts})$：$l=r\not=2$；      
- Subtask 5 $(20\text{ pts})$：$T=1$，$n\leq 10^6$；
- Subtask 6 $(20\text{ pts})$：$T=1$，$r\leq 10^6$；
- Subtask 7 $(20\text{ pts})$：$T\leq 3000$；
- Subtask 8 $(10\text{ pts})$：无特殊限制，时间限制 $1.5\;\text{s}$。

对于所有数据，满足：  

$1\leq T\leq 10^5$，$1\leq n\leq 10^{18}$，$2\leq l\leq r\leq 10^{18}$。  

**注意：在具体约束中没有提到的数据范围均为极限数据范围。**



------------


**【样例解释 #1】**   

$$\left\lceil\log_21\right\rceil+\left\lceil\log_22\right\rceil+\left\lceil\log_23\right\rceil+\left\lceil\log_24\right\rceil+\left\lceil\log_25\right\rceil=8$$

$$\left\lceil\log_31\right\rceil+\left\lceil\log_32\right\rceil+\left\lceil\log_33\right\rceil+\left\lceil\log_34\right\rceil+\left\lceil\log_35\right\rceil=6$$   

故：

$$ans=8×(2-1)+6×(3-1)=20$$   

对于样例 #2，我相信您聪明的大脑可以分分钟得到答案的。



------------

**【其他提示】**  

如果你不了解对数（$\log$）运算,可以查看[这里](https://baike.baidu.com/item/对数公式/5557846?fr=aladdin)。

## 样例 #1

### 输入

```
1
2 3 5```

### 输出

```
20```

## 样例 #2

### 输入

```
2
23333 23333 233233
114514 19260817 1919810   ```

### 输出

```
356712294
125194507```

# 题解

## 作者：longfei (赞：4)

# 题解 P6826 【「EZEC-4」月下轻花舞】
@我谔谔 大佬的分$k$大小和前缀和优化思路对我很有启发。但我推式子的过程和大佬有所不同。
## 推式子思路

注意到 $\left \lceil \log_{i}j  \right \rceil \in Z$，所以将 $\left \lceil \log_{i}j  \right \rceil$ 以求和号的形式写出来，然后通过交换求和号改变求和顺序，达到去掉大循环的目的。  
$$\sum_{i=l}^{r}(i-1)\sum_{j=1}^{n}\left \lceil \log_{i}j \right\rceil = \sum_{i=l}^{r}(i-1)\sum_{j=1}^{n}\sum_{k\geqslant 1}^{}\sum_{i^{k-1}<j}^{}1$$  
式子的核心在于 $i^{k-1}<j$ 。最内层循环为 $i,k$ 时仍需要遍历计算。当最内层循环 $j$ 时，有  
$$\sum_{j=1}^{n}\sum_{i^{k-1}<j}^{}1=max(n-i^{k-1},0)$$  
于是要求的式子转化为  
$$\sum_{i=l}^{r}(i-1)\sum_{k\geqslant 1}max(n-i^{k-1},0)$$  
让 $(i-1)max(n-i^{k-1},0)$ 有意义时，$i^{k-1}\leqslant n$，即 $k\leqslant log_{i}n+1$ 。记$t=log_{i}n+1$，有  
$$\sum_{i=l}^{r}(i-1)\sum_{k\geqslant 1}max(n-i^{k-1},0)=\sum_{i=l}^{r}\sum_{k\leqslant t}(i-1)(n-i^{k-1})$$  
$$=\sum_{i=l}^{r}\sum_{k\leqslant t}(i-1)n -\sum_{i=l}^{r}\sum_{k\leqslant t}(i^{k}- i^{k-1})=\sum_{i=l}^{r}(i-1)nt-\sum_{i=l}^{r}(i^{t}-1)$$  
$$=\sum_{i=l}^{r}(i-1)nt-\sum_{i=l}^{r}i^{t}+(r-l+1)$$  
枚举 $k$ 的值，$k=1,2,3,4$时手算求和公式，$k\geqslant5$时用前缀和数组。处理的区间为$(n,r]$,$(\sqrt[]{n},n]$,$(\sqrt[3]{n},\sqrt[]{n}]$,$(\sqrt[4]{n},\sqrt[3]{n}]$... 最终处理到 $l$ 。

下面附上代码。需要注意诸多细节，在文中说明。
## 代码
```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MAXN (1<<16)+5//开到2*10^18的四次根 
#define MAXK 62
#define MAXT 100005//离线，其实可以不用 
#define MOD 998244353
#define re register long long
ll s[MAXN][MAXK];//前缀和数组 
ll l1[MAXT],r1[MAXT],n1[MAXT];//离线取最大的n，其实没必要 
ll base[MAXN];//辅助预处理，记录下标的幂次 
ll fj[MAXK];//记录n^(1/下标) 
ll t,l,r,n,k,maxn;
ll gsc(ll a,ll b){//取模乘法 
	a%=MOD;b%=MOD;
	return (a*b)%MOD;
}
ll dev(ll a,ll b){//取模除法 
	while(a%b!=0)a+=MOD;
	return a/b;
}
void solve(ll l,ll r,ll n){ 
	ll ans=r-l+1;
	memset(fj,0,sizeof(fj));
	for(re i=1;i<=n;i++){
		fj[i]=pow(n,1.00/i);
		if(fj[i]==1)break;//太小的用不到 
	}
	ll inf=l;
	if(r>fj[4]){//手算公式的需要 
		if(r>fj[3]){
			if(r>fj[2]){
				if(r>n){
					inf=n+1;
					inf=max(l,inf);
					if(l<=r){//处理下界 
						ll tmp=dev(gsc(r+inf,r-inf+1),2);
						ans=(ans+dev(gsc(n,gsc(r+inf-2,r-inf+1)),2)-tmp)%MOD;
						while(ans<0)ans+=MOD;
						r=n;//改变上标，大于n的已处理完毕 
					}
				}
				inf=fj[2]+1;
				inf=max(l,inf);
				if(l<=r){
					ll tmp=(dev(gsc(gsc(r,r+1),2*r+1),6)-dev(gsc(gsc(inf-1,inf),2*inf-1),6))%MOD;
					ans=(ans+gsc(n,gsc(r+inf-2,r-inf+1))-tmp)%MOD;
					while(ans<0)ans+=MOD;
					r=fj[2];
				}
			}
			inf=fj[3]+1;
			inf=max(l,inf);
			if(l<=r){
				ll tmp=(dev(gsc(r,gsc(r,gsc(r+1,r+1))),4)-dev(gsc(inf,gsc(inf,gsc(inf-1,inf-1))),4))%MOD;
				ans=(ans+(dev(gsc(n,gsc(r+inf-2,r-inf+1)),2)*3)%MOD-tmp)%MOD;
				while(ans<0)ans+=MOD;
				r=fj[3];
			}
		}
		inf=fj[4]+1;
		inf=max(l,inf);
		if(l<=r){
			ll tmp=dev(gsc(dev(gsc(gsc(r,r+1),2*r+1),6),gsc(gsc(r,r),3)+gsc(3,r)-1),5)-dev(gsc(dev(gsc(gsc(inf-1,inf),2*inf-1),6),gsc(gsc(inf-1,inf-1),3)+gsc(3,inf-1)-1),5);
			ans=(ans+(dev(gsc(n,gsc(r+inf-2,r-inf+1)),2)*4)%MOD-tmp)%MOD;
			while(ans<0)ans+=MOD;
			r=fj[4];
		}
	}
	for(re t=5;t<=log(n)/log(2)+1;t++){
		inf=fj[t]+1;
		inf=max(l,inf);
		if(l>r)break;//处理下界，当当前处理区间下界>=l的时候就退出 
		if(r>fj[t]){
			ll tmp=(s[r][t]-s[inf-1][t]+MOD)%MOD;
			ans=ans+gsc(dev(gsc(n,gsc(r+inf-2,r-inf+1)),2),t)-tmp;
			while(ans<0)ans+=MOD;
			r=fj[t];
		}
	}
	while(ans<0)ans+=MOD;
	printf("%lld\n",ans%MOD);
}
int main(){
	scanf("%lld",&t);
	for(re i=1;i<=t;i++)scanf("%lld%lld%lld",&l1[i],&r1[i],&n1[i]),maxn=max(maxn,n1[i]);
	for(re i=1;i<=(1<<16);i++){
		base[i]=(i*i)%MOD;
		base[i]=(base[i]*base[i])%MOD;
		base[i]*=i;base[i]%=MOD;
	}
	for(re j=5;j<=log(maxn)/log(2)+1;j++){
		for(re i=1;i<=(1<<16);i++){
			s[i][j]=(s[i-1][j]+base[i])%MOD;
			base[i]=(base[i]*i)%MOD;
		}
	}//预处理 
	for(re q=1;q<=t;q++)solve(l1[q],r1[q],n1[q]);
}
```


---

## 作者：Graphcity (赞：2)

首先通过前缀和把 $i\ge l$ 的限制去掉。看到 $\lceil \log_ij\rceil$ 不太大，考虑贡献转化：

$$
\begin{aligned}
&\sum_{i=1}^r(i-1)\sum_{j=1}^n\lceil \log_ij\rceil \\
=& \sum_{i=1}^r(i-1)\sum_{j=1}^n\sum_{k=1}^{60}k[\lceil \log_ij\rceil=k]\\
=& \sum_{i=1}^r(i-1)\sum_{j=1}^n\sum_{k=1}^{60}[\lceil \log_ij\rceil\ge k]\\
=& \sum_{i=1}^r(i-1)\sum_{j=1}^n\sum_{k=1}^{60}[j>i^{k-1}]\\
=& \sum_{k=1}^{60}\sum_{i=1}^r(i-1)\sum_{j=1}^n[j>i^{k-1}]\\
=& \sum_{k=1}^{60}\sum_{i=1}^r(i-1)\max(0,n-i^{k-1})\\
=& \sum_{k=1}^{60}\sum_{i=1}^{\min(r,n^{\frac{1}{k-1}})}(i-1)(n-i^{k-1})\\
=& \sum_{k=1}^{60}\sum_{i=1}^{\min(r,n^{\frac{1}{k-1}})}ni-n+i^{k-1}-i^k\\
\end{aligned}
$$

现在的问题就是 $\sum_{i=1}^t i^k$ 怎么求。首先它是个 $(k+1)$ 次多项式，可以拉格朗日插值 $O(T\log^2n)$。但这样太麻烦了，注意到当 $k\ge 4$ 时 $t\le 10^6$，完全可以预处理。至于 $k\le 3$ 的情况已经有成熟的公式。

注意 $n,l,r\le 10^{18}$，注意开 long long 和取模。时间复杂度 $O(T\log n)$。代码很好写。

```cpp
#include<bits/stdc++.h>
#define int long long
#define For(i,a,b) for(int i=(a);i<=(b);++i)
#define Rof(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
const int Maxn=1e6+10,inf=1e18,Mod=998244353;
const int i2=(Mod+1)/2,i6=(Mod+1)/6;

int T,pw[Maxn+5];
vector<int> v[65];

inline int Get(int x,int id)
{
    x%=Mod;
    if(id==0) return x;
    if(id==1) return x*(x+1)%Mod*i2%Mod;
    if(id==2) return x*(x+1)%Mod*(x*2+1)%Mod*i6%Mod;
    if(id==3) return Get(x,1)*Get(x,1)%Mod;
    return v[id][x];
}
inline int Check(int x,int y)
{
    int res=1;
    For(i,1,y)
    {
        if(res>inf/x) return inf+5;
        res*=x;
    }
    return res;
}
inline int Count(int r,int n)
{
    int ans=0;
    For(k,1,61)
    {
        int t=(k==1?r:pow(n,1.0/(k-1))); t=min(t,r);
        while(t<r && Check(t+1,k-1)<=n) t++;
        while(Check(t,k-1)>n) t--;
        ans=(ans+n%Mod*(Get(t,1)-Get(t,0))%Mod+Get(t,k-1)-Get(t,k))%Mod;
        ans=(ans+Mod)%Mod;
    }
    return ans;
}
inline void Init()
{
    For(i,1,Maxn) pw[i]=i*i*i%Mod;
    For(i,4,61)
    {
        int res=pow(inf,1.0/(i-1));
        while(Check(res+1,i-1)<=inf) res++;
        v[i].resize(res+1);
        For(j,1,res) pw[j]=pw[j]*j%Mod;
        For(j,1,res) v[i][j]=(v[i][j-1]+pw[j])%Mod;
    }
}

signed main()
{
    ios::sync_with_stdio(false);
    cin>>T; Init();
    while(T--)
    {
        int l,r,n; cin>>l>>r>>n;
        cout<<(Count(r,n)-Count(l-1,n)+Mod)%Mod<<endl;
    }
    return 0;
}
```

---

## 作者：OldVagrant (赞：1)

## 题意
[题面给的已经足够简洁了（](https://www.luogu.com.cn/problem/P6826)
## Solution
首先，我们可以注意到一个非常特殊的性质：在 $i>1$ 时，$\lceil \log _i j\rceil$ 的取值最大是 $60$。  
这使得我们可以枚举每一种取值  $k\in [1,60]$，再算出一共有多少对 $(i,j)$ 满足 $\lceil \log _i j\rceil=k$，将这个总数与 $k$ 相乘，最后再把每一种 $k$ 的贡献加起来，就是答案了。   
  
然后，$i\ge l$ 的这个限制有点奇怪，我们可以通过求前缀和再作差的方式去掉它，即 $ans(l,r,n)=ans(1,r,n)-ans(1,l-1,n)$。这样的话算起来更方便一些。

接下来，要对题目里给的那个式子进行一些变形。 
记 $k_i=\lceil \log _i n\rceil$，则有    
$\begin{aligned} ans(1,r,n) & =\sum_{i=1}^r (i-1) \sum_{j=1}^n \lceil \log _i j\rceil \\ & = \sum_{i=1}^r (i-1) \sum_{j=1}^{k_i-1} j(i^j-i^{j-1}) +\sum_{i=1}^r (i-1)k_i(n-i^{k_i-1}) \\ & = \sum_{j=1}^{maxk-1}  j\sum_{i=1}^{k_i>j} i^{j+1}-2i^j+i^{j-1}  +\sum_{j=1}^{maxk}j\sum_{i=1}^r[k_i=j]n(i-1)-i^j+i^{j-1} \end{aligned}$   
（$[k_i=j]$ 就是只有当 $k_i=j$ 的时候这一项才为 $1$，其他时候均为 $0$）   

可以看到，答案由两部分组成，分别计算之后加到一起即可。  
在展开计算之前，要先确定求和的边界。      

对于第一部分，左边界显然是 $1$，右边界就是最大的那个 $k_i>j$  的数 $w$，也就是说  $k_w>j$ 且 $k_{w+1}\le j$，这意味着  $(w+1)^{j}\ge n$ 且 $w^j<n$，那么 $w$ 就是小于 $n^{1/j}$ 的最大整数。    
对于第二部分，左右边界都要算一下。$k_i=j$，相当于 $i^{j-1}<n \le i^j$。左边界是较容易想到的，就是 $n^{1/j}$，再小的话 $k_i$ 就比 $j$ 大了。而右边界也并不难，因为 $k_i=j-1$ 的左边界是 $n^{1/(j-1)}$，再减 $1$ 就是 $k_i=j$ 的右边界了。    

下一个要解决的问题是如何给 $n$ 开 $k$ 次方根，用 ```pow(n,1.0/k)``` 的话精度似乎并不够，一种可行的办法是手写二分，另一种就是像我一样用换底公式，即 ```exp(log(n)/k))```，但是在 $k=1$ 的时候误差会很大，我造了一组 $n=7\times 10^{17}$ 的数据，然后开出来的值和真实值差了 $640$，所以要特判一下。 		

此后便可以开始计算了。  
还是先看第一部分，在边界 $R$ 已经确定的情况下，这个部分要求的就是 $\sum_{i=1}^R i^k$，对于能熟练使用拉格朗日插值的同学来说应该可以一眼秒，但是**可能会被卡常**（我自己的大常数写法就是最后一个子任务全 ``TLE``）。我们再仔细看看 $R$ 的范围以及对应的  $k$ 的范围，又可以发现一个性质：当 $k\ge 5$ 时，$R$ 的最大值大概是在 $31623$ 左右，这就是可以预处理的了，而对于 $k<5$ 的那些，就直接套用求和公式吧（其实对于任意的 $k$ 都是有公式的，但是  $k$ 越大越复杂，[感兴趣可以看看](https://zhuanlan.zhihu.com/p/344394689)）。下面仅给出 $k\in [0,4]$ 的公式：      
$\begin{aligned} \sum_{i=1}^n i^0 & =n\\  \sum_{i=1}^n i^1 & =n(n+1)/2 \\ \sum_{i=1}^n i^2 & =n(n+1)(2n+1)/6 \\ \sum_{i=1}^n i^3 & =n^2(n+1)^2/4 \\ \sum_{i=1}^n i^4 & =n(n+1)(2n+1)(3n^2+3n-1)/30 \end{aligned}$  

公式里面会用到除法，所以我们需要提前预处理出 $2,6,4,30$ 的逆元，算的时候乘上去即可。     
有了公式之后，第一部分就算解决了，再来看第二部分。这一部分实际上相当于是给定一个 $L,R,k,n$，求 $\sum_{i=L}^R n(i-1)-\sum_{i=L}^R i^k +\sum_{i=L}^R i^{k-1}$。对于后面两个求和号，将 $\sum_{i=L}^R$ 转化成 $\sum_{i=1}^R -\sum_{i=1}^{L-1}$，而后直接套用第一部分的方法即可。至于第一个求和号，把 $n$ 提出来，把 $(i-1)$ 看成 $(i-1)^1$，再用刚刚的套路。

最后，计算过程中注意取模，如果你的 $n>2^{32}$ 并且你还在套 $k=1$ 的那个求和公式，那么一定要写成 ```n%mod*((n+1)%mod)%mod*inv2```（最后乘的那一项是 $2$ 的逆元）。 
## Code
```
#include <bits/stdc++.h>
#define ll long long
#define gc getchar
#define pc putchar
using namespace std;
const int mod=998244353;
ll num[64],x[100001],y[100001],z[100001];
int inv2,inv6,inv4,inv30,sum[64][32768],maxn,w[100001];
ll read(){
	ll x=0;
	char ch=gc();
	while(ch<48||ch>57) ch=gc();
	while(ch>47&&ch<58) x=x*10+ch-48,ch=gc();
	return x;
}
void write(int x){
    if(x>9) write(x/10);
    pc(x%10+48);
}
int qpow(int a,int b){
	int ans=1;
	while(b){
		if(b&1) ans=(ll)ans*a%mod;
		a=(ll)a*a%mod,b>>=1;
	}return ans;
}
int query(ll n,int k){
	if(k>4) return sum[k][n];
	if(k==0) return n%mod;
	if(k==1) return n%mod*((n+1)%mod)%mod*inv2%mod;
	if(k==2) return n%mod*((n+1)%mod)%mod*((n+n+1)%mod)%mod*inv6%mod;
	if(k==3) return n*n%mod*(n+1)%mod*(n+1)%mod*inv4%mod;
	return n*(n+1)*(n+n+1)%mod*((3*n*n+3*n-1)%mod)%mod*inv30%mod;//这里可以少取模几次，因为当k=4的时候n最大是10^6，k=3的时候n最大是10^9。
}
#define get(l,r,k) ((query(r,k)-query(l-1,k)+mod)%mod)
int getsum(ll r,ll n,int k){
	int ans=0;
	for(int i=2;i<=k;i++) num[i]=ceil(exp((long double)log(n)/i));//num数组即为每次计算的边界，num[0]设成n和r的最大值即可。这里一定要上取整，读者不妨自行思考一下下取整会在什么样的情况下出错。
	num[1]=n,num[0]=max(n+1,r+1);
	for(int i=1;i<k;i++){
		ll R=min(num[i]-1,r);
		int a=query(R,i+1),b=2*query(R,i)%mod,c=query(R,i-1),d=a-b+c;
		if(d<0) d+=mod;
        ans=(ans+(ll)i*d%mod)%mod;
	}for(int i=1;i<=k;i++){
		ll le=num[i],ri=min(num[i-1]-1,r);
		if(ri<le) continue;
		int sum=n%mod*get(le-1,ri-1,1)%mod,sum1=mod-get(le,ri,i),sum2=get(le,ri,i-1);
		sum=((sum+sum1)%mod+sum2)%mod,ans=(ans+(ll)i*sum%mod)%mod;
	}return ans;
}
signed main(){
	int T=read();
	ll ma=0;
	for(int i=1;i<=T;i++) x[i]=read(),y[i]=read(),z[i]=read(),w[i]=ceil(log2(z[i])),ma=max(ma,z[i]);
	maxn=ceil(log2(ma)),inv2=qpow(2,mod-2),inv6=qpow(6,mod-2),inv4=qpow(4,mod-2),inv30=qpow(30,mod-2);
	for(int i=5;i<=maxn+1;i++){
		int R=ceil(exp(log(ma)/(i-1)))-1;
		for(int j=1;j<=R;j++) sum[i][j]=(sum[i][j-1]+qpow(j,i))%mod;
	}for(int i=1;i<=T;i++){
		int Ans=getsum(y[i],z[i],w[i])-getsum(x[i]-1,z[i],w[i]);
		if(Ans<0) Ans+=mod;
		write(Ans),pc('\n');
	}return 0;
}
/*
1
4746618897201866
730145302395680600
688185792369278860
*/
```

---

## 作者：hanzhongtlx (赞：1)

## 「月下花轻舞」官方题解

${\text{writer}:\color{Gray}\text{hanzhongtlx}}$ （这么屑的题解也就她能写出来了）

![](https://cdn.luogu.com.cn/upload/image_hosting/s6ozu5pj.png)

我们先不看第一个求和，先来求一下：  

$$\sum_{i=1}^n\left\lceil\log_mi\right\rceil$$  

由于这个不好直接化简，我们先来直观看一下这个序列（以 $m=2$ 为例）：   

$$0 \;1 \;2 \;2 \;3\; 3 \;3 \;3......$$   

我们设：$k=\left\lfloor\log_2n\right\rfloor$ 。 

于是：  
$$\begin{aligned}\sum_{i=1}^n\left\lceil\log_2i\right\rceil&=\sum_{i=1}^k2^{i-1}i+(n-2^k)(k+1)\end{aligned}$$   

当然化简到这里前面那些可能还是较难向下进行,我们考虑一层一层地加：  

举个栗子  

$$0 +1 +2 +2 +3+3+3 +3......$$  
可以想象为：  

先加 $7$ 个 $1$，然后此时 $2$ 只剩下 $1$，$3$ 只剩下 $2$ 了，然后类推 加 $6$ 个 $1$，$4$ 个  $1$。  

也就是：

$$\begin{aligned}\sum_{i=1}^n\left\lceil\log_2i\right\rceil&=\sum_{i=1}^k2^{i-1}i+(n-2^k)(k+1)\\&=\sum_{i=1}^k(2^k-2^{i-1})+nk+n-(k+1)2^k\\&=k2^k-\sum_{i=0}^{k-1}2^i+nk+n-(k+1)2^k\\&=(k-1)2^k-(k+1)2^k+nk+n+1\\&=-2^{k+1}+nk+n+1\end{aligned}$$    

然后 $m$ 取任意值可以同理推导,设 $k=\left\lfloor\log_mn\right\rfloor$：  

$$\begin{aligned}\sum_{i=1}^n\left\lceil\log_mi\right\rceil&=\sum_{i=1}^k(m^{k}-m^{i-1})+(n-m^k)(k+1)\\&=km^k-\sum_{i=0}^{k-1}m^i+nk+n-(k+1)m^k\\&=-m^k-\dfrac{m^k-1}{m-1}+nk+n\end{aligned}$$   

然后就开始推导总式子：  

然后我们发现这个可以差分一下，所以只需要计算 $2\sim l-1$ 和 $2\sim r$ 的就好了（当然你直接算也不是不行吧）。  

$$\begin{aligned}\sum_{i=2}^r(i-1)\sum_{j=1}^n\left\lceil\log_ij\right\rceil&=\sum_{i=2}^r(-i^{k+1}+1+(i-1)nk+(i-1)n)\end{aligned}$$  

你发现这个随便一拆不就行了吗？  

不是的，因为 $k$ 是变的，我们先考虑把没有 $k$ 的搞出去。  

$$\begin{aligned}\sum_{i=2}^r(i-1)\sum_{j=1}^n\left\lceil\log_ij\right\rceil&=\sum_{i=2}^r(-i^{k+1}+1+(i-1)nk+(i-1)n)\\&=r-1+\dfrac{nr(r-1)}{2}+n\sum_{i=2}^r(i-1)k-\sum_{i=2}^ri^{k+1}\end{aligned}$$    

然后我们考虑**假设 $k$ 为定值怎么算** 。  
好了，你如果知道**拉格朗日插值法或者伯努利数**就会轻松切掉了。（相关操作请查看 [CF622F](https://www.luogu.com.cn/problem/CF622F)）  

我们再来考虑 $k$ 的实际意义。  

$$k=\left\lfloor\log_in\right\rfloor$$   

然后这个东西可以类似整除分块即可，需要二分判断边界。  

其实有一种比较无脑的做法就是暴力枚举每一个 $k$，因为 $k$ 只有 $\log n$ 级别，复杂度甚至更优秀。  

如何确认边界？用 `pow(n,1.00/k)` 即可。  

精度？在出题人的实验中得到结果，只有当 $k=1$ 时才会有精度问题，然而 $k=1$ 时根本用不到 `pow(n,1.00)` ，所以特判一下就好了>_<。 

时间复杂度是 $\mathcal O(T\log^2n)\sim \mathcal O(T\log^4n)$，理论上最坏情况卡卡也能过，至少 $\mathcal O(T\log^3n)$ 是稳过的 。 

是不是很简单呢？    



------------

还是被金勾爷吊打了/kk。 

考虑到 $k$ 真的很小，能否预处理 $\sum\limits_{i=2}^ri^{k+1}$ 呢？  
当 $k$ 较小的时候需要预处理的数真心很多。  

但我们是知道低次幂求和公式的，所以我们只需要从 $k=4,5$ 这一块开始预处理，这部分复杂度也很小，总的复杂度就能降到 $\mathcal O(T\log n)$，也避免了使用拉格朗日差值或伯努利数。

---

## 作者：DengDuck (赞：0)

喜欢推式子题吗？

$$
\sum_{i=l}^r(i-1)\sum_{j=1}^n \left\lceil\log_ij\right\rceil\pmod{998244353}\\
$$

显然可以前缀和作差。

主要的思考方向是：思考 $\lceil\log_i j\rceil$ 在哪个区间，或者直接拆二进制位每一位的贡献，但是后者应该更优秀一点。

$$
\begin{aligned}
&\sum_{i=1}^r(i-1)\sum_{j=1}^n \left\lceil\log_ij\right\rceil\pmod{998244353}\\
=&\sum_{i=1}^r(i-1)\sum_{j=1}^n  \sum_{k=1}^{60} k[\left\lceil\log_ij\right\rceil=k]\\
=&\sum_{i=1}^r(i-1)\sum_{j=1}^n  \sum_{k=1}^{60} [\left\lceil\log_ij\right\rceil\geq k]\\
=&\sum_{i=1}^r(i-1)\sum_{j=1}^n  \sum_{k=1}^{60} [j> i^{k-1}]\\
=&\sum_{k=1}^{60}\sum_{i=1}^{\min(r,\lfloor n^{\frac 1 {k-1}}\rfloor)}(i-1)(n-i^{k-1})
\end{aligned}
$$

然后我们发现这玩意已经可以快速计算了，主要是计算幂和，对于 $k\leq 3$，可以直接套公式，对于 $k>3$，我们发现 $\min(r,\lfloor n^{\frac 1 {k-1}}\rfloor)$ 不会太大，所以考虑预处理就行了。

---


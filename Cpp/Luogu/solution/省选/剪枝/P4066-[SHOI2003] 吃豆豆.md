# [SHOI2003] 吃豆豆

## 题目描述

两个 PACMAN 吃豆豆。一开始的时候，PACMAN 都在坐标原点的左下方，豆豆都在右上方。PACMAN 走到豆豆处就会吃掉它。  
PACMAN 行走的路线很奇怪，只能向右走或者向上走，他们行走的路线可以有交点但不能互相穿过。  
请你帮这两个 PACMAN 计算一下，他们俩加起来最多能吃掉多少豆豆。


## 说明/提示

对于 $100\%$ 的数据，$N \leq 2000$。

## 样例 #1

### 输入

```
8 
8 1 
1 5
5 7 
2 2 
7 8 
4 6 
3 3 
6 4```

### 输出

```
7```

# 题解

## 作者：wjyyy (赞：16)

## 前言：

[欢迎到博客欣赏](http://www.wjyyy.top/754.html)

一开始费用流建模比较顺利，到最后发现RE了几个点以为是前向星边开小了，到最后开到MLE也跑不出来。造了个2000个点的数据才发现是SPFA写挂了，然后同样的代码，别人的程序跑4,000,000次循环只用200ms，而我用了50s，卡到90分。。。在检查一下午之后发现是连边的问题，我建的模型有2×2000个点，稠密图下最多可能有8,000,000+(8e6)条边，参考了别人的代码才发现有很多边是不用连的。（连了既增加**遍历的**时间复杂度，又增加前向星的空间复杂度）2018.7.6目前为止提交记录里有一半都是我交的了![](http://www.wjyyy.top/wp-content/uploads/2018/07/QQ图片20180706170929.png)



## 题解：

   这个题和[**传纸条**](https://www.luogu.org/problemnew/show/P1006)有点像，不过传纸条是可以交叉，而这个题不能交叉。也就是每一个点只能有一个PACMAN通过，由于这个限制，我们可以联想到**网络流的流量上限**，豆豆作为费用，跑最大费用最大流。

   如何控制每个点只被一个PACMAN吃掉，是我们要解决的一大问题。我们可以试着把一个点拆成一条边，使得这条边的流量为1，边权为1。也就是**当且仅当这条边的两端都在最大流上时，费用才能算上**，这就是建模的思路。 _也可以当一条边指向一个豆豆时，它的流量是1，不过这样会影响下面的优化，这种做法就是前面90分的做法。_ 

   我们回到题目，题目说PACMAN从原点出发，只能向右或向上，所以当两个点的斜率大于等于零或不存在时$((x1-x2)(y1-y2)\ge 0)$，两个点会连上一条边。如果这样做的话，那么当所有点之间的斜率都大于等于0，就成了一个稠密图，边数超过4e6，双向边加起来就有8e6了，我们就要想办法**剪枝**（这么多的边SPFA枚举都要花很长时间了），把有些点之间的联系用其他点当桥梁连接起来。

   对于坐标系中一个点，**它可以由横坐标非严格小于它，且纵坐标非严格小于它的点**（在可行域中）转移。我们为了控制边数，只用连接与它最近的点。我们在可行域中首先找到横坐标最大（同等条件下纵坐标最大）的点，**接着屏蔽掉以原点与这个点的连线为对角线的矩形，因为矩形中的点都可以或直接或间接地转移到这个右上角点来**：

![](http://www.wjyyy.top/wp-content/uploads/2018/07/QQ截图20180706183659.png)

   我们依次这样做下去，就会得到这两个蓝色点和红色点，从蓝点指向红点是一条边权为∞，费用为0的**承接边**。

![](http://www.wjyyy.top/wp-content/uploads/2018/07/QQ截图20180706183941.png)![](http://www.wjyyy.top/wp-content/uploads/2018/07/QQ截图20180706183903.png)

   不过，在某些情况下，下面剩的两个黑点直接走到红点是更优的解，这样我们只需要把之前**拆的点**之间重新建一条边，边权为∞，费用为0的**承接边**，表示**不经过这个点的两点**连线通过这个点连接到一起，与这个点无关。这样一来，与上面的**拆点**一起，每个点有了两条**自环边**，实则分成了两个点，它们之间有两条连线，一条是承接边，一条是**费用边，即对费用增加有贡献的边**。



   我们在这样的图上跑最大费用最大流，最终的流量大多数情况为2，答案为最大费用；当为1时说明一个PACMAN可以解决所有豆豆，此时答案为n。这样一来，所连接的边就约为2×2×2×n即8×n条，双向边最终前向星开100000就足够了。



**需要注意一点，我们为了控制只有2个PACMAN，需要从源点1引出一条边指向一个源点2，边权为2，控制最大流不超过2。这样一来，就算有m个PACMAN，也可以通过控制这条边的边权来完成。**

## Code：
```cpp
//源点1为0，源点2为4002，汇点为4001，点i的入口为i，出口为2000+i。
#include<cstdio>
#include<cstring>
#include<algorithm>
struct edge
{
    int n,v,w;
    int nxt;
    edge(int n,int v,int w,int nxt)
    {
        this->n=n;
        this->v=v;
        this->w=w;
        this->nxt=nxt;
    }
    edge()
    {
        nxt=-1;
    }
}e[405000];
int head[4100],cnt=-1;
void add(int from,int to,int v,int w)
{
    e[++cnt].n=to;
    e[cnt].v=v;
    e[cnt].w=w;
    e[cnt].nxt=head[from];
    head[from]=cnt;
    e[++cnt].n=from;
    e[cnt].v=0;
    e[cnt].w=-w;
    e[cnt].nxt=head[to];
    head[to]=cnt;
}
struct pnt
{
    int x,y;
    friend bool operator <(pnt a,pnt b)//把点排序
    {
        if(a.x!=b.x)
            return a.x<b.x;
        return a.y<b.y;
    }
}p[2222];
int pre[4222];
int dis[4222];
int q[4000000],l,r;
bool spfa()
{
    bool used[4122];//是否在队列中
    memset(used,0,sizeof(used));
    memset(dis,-0x3f,sizeof(dis));
    l=r=0;
    q[++r]=0;
    dis[0]=0;
    used[0]=true;
    while(l<r)
    {
        int k=q[++l];
        for(int i=head[k];~i;i=e[i].nxt)
        {
            int u=e[i].n;
            if(e[i].v&&dis[u]<dis[k]+e[i].w)
            {
                dis[u]=dis[k]+e[i].w;
                pre[u]=i;
                if(!used[u])
                {
                    used[u]=true;
                    q[++r]=u;
                }
            }
        }
        used[k]=false;
    }
    return dis[4001]>0;
}
int main()
{
    int n;
    scanf("%d",&n);
    memset(head,-1,sizeof(head));
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&p[i].x,&p[i].y);
        add(i,2000+i,1,1);
        add(i,2000+i,2,0);
        add(2000+i,4001,0x3fffffff,0);
        add(4002,i,0x3fffffff,0);
    }
    std::sort(p+1,p+1+n);
    add(0,4002,2,0);
    for(int i=1;i<=n;i++)
    {
        int limy=0;
        for(int j=i-1;j>=1;j--)
        {
            if(p[j].y>p[i].y||p[j].y<limy)
                continue;
            limy=std::max(limy,p[j].y);
            add(2000+j,i,0x3fffffff,0);
        }
    }
    pre[0]=-1;
    int sum=0;
    while(spfa())
    {
        int t=pre[4001];
        sum+=dis[4001];
        while(~t)//增广
        {
            e[t].v--;
            e[t^1].v++;
            t=pre[e[t^1].n];
        }
    }
    printf("%d\n",sum);
    return 0;
}
```

---

## 作者：无意识躺枪人 (赞：15)

个人觉得@wjyyy 的题解有一些复杂了……

这题难度虚高，稍微学过一点网络流的蒟蒻（比如我）都能很好地~~水过去~~AC

## Q1:如何处理不交叉路径？

很显然的是，题目中的“路径不能交叉”**并没有任何作用**

此结论是显然的，举个例子：（若图片失效请前往你谷图库60682和60683）

![图一](https://cdn.luogu.com.cn/upload/pic/60682.png)

![图二](https://cdn.luogu.com.cn/upload/pic/60683.png)

图一中两人的路线似乎有交叉，然而你可以把路线看成一个走上面，一个走下面

显然，无论是什么情况都可以这样处理

## Q2：如何建图？

很容易想到把每个可以互相达到的边都连起来跑……时间爆炸

于是我们有一个优化：**如果i→j且j→k，则不需要连i→k这条路径**

于是我们连一下边，打一下费用流板子，~~AC！~~

**~~并不，你会发现你并没有AC~~**![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1560333447595&di=2931fa917f9da44867fe7f1f58f0a0e2&imgtype=0&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201707%2F04%2F20170704080419_G2FWJ.thumb.224_0.jpeg)

## Q3：为什么会错？

我们手搓一个数据模拟一下，答案总是比标答小一些？？？

**这是因为有些点会经过多次**

那怎么解决呢？

**每个点从入点向出点再连一条流量为1，费用为0的边**

**先按x和y递增排序，对于每个点，扫描时维护现在的最小值，如果有更小的才连边。**

搞清楚这些，这题就是一个简单的板子题了

于是代码如下：
```cpp
#include<bits/stdc++.h>
#define INF 1000000000
#define N 2005
using namespace std;

int n,dis[N<<1],from[N<<1],p[N<<1];
bool exist[N<<1];

struct Edge
{
	int next,to,flow,dis;
}edge[4100000];
int head[N<<1],cnt=1;

struct Node
{
	int x,y;
}a[N];

bool cmp(Node a,Node b)
{
	if(a.x<b.x)return 1;
	else if(a.x>b.x)return 0;
	else return a.y<b.y?1:0;
}

void add_edge(int from,int to,int flow,int dis)
{
	edge[++cnt].next=head[from];
	edge[cnt].to=to;
	edge[cnt].flow=flow;
	edge[cnt].dis=dis;
	head[from]=cnt;
}

void add(int u,int v,int w,int c)
{
	add_edge(u,v,w,c);
	add_edge(v,u,0,-c);
	//连正反向边
}

bool spfa(int S,int T,int &cost)
{
	memset(dis,0x3f,sizeof(dis));
	queue<int> q;
	q.push(S);
	dis[S]=0;
	while(!q.empty())
	{
		int u=q.front();q.pop();exist[u]=0;
		for(int i=head[u];i;i=edge[i].next)
		{
			int v=edge[i].to;
			if(edge[i].flow&&dis[v]>dis[u]+edge[i].dis)
			{
				dis[v]=dis[u]+edge[i].dis;
				from[v]=u;
				p[v]=i;
				if(!exist[v])
				{
					exist[v]=1;
					q.push(v);
				}
			}
		}
	}
	if(dis[T]>=INF)return 0;
	int x=INF;
	for(int i=T;i!=S;i=from[i]) x=min(x,edge[p[i]].flow);
	for(int i=T;i!=S;i=from[i])
	{
		edge[p[i]].flow-=x;
		edge[p[i]^1].flow+=x;
		cost+=x*edge[p[i]].dis;
	}
	return true;
}

int mcmf(int S,int T)
{
	int res=0;
	while(spfa(S,T,res));
	return res;
}

template<class T>inline void read(T &res)
{
	static char ch;T flag=1;
	while((ch=getchar())<'0'||ch>'9')if(ch=='-')flag=-1;res=ch-48;
	while((ch=getchar())>='0'&&ch<='9')res=(res<<3)+(res<<1)+ch-48;res*=flag;
}

int main()
{
	read(n);
	int S=n+n+1,T=S+1,T1=T+1;
	for(register int i=1;i<=n;i++)
	{
		read(a[i].x);
		read(a[i].y);
	}
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=n;i++)
	{
		add(S,i,1,0);
		add(i,i+n,1,-1);
		add(i,i+n,1,0);
		add(i+n,T,1,0);
	}
	add(0,S,2,0);
	add(T,T1,2,0);
	for(int i=1;i<=n;i++)
	{
		int now_min=INF;
		for(int j=i+1;j<=n;j++)
		{
			if(a[j].y<now_min&&a[j].y>=a[i].y) add(i+n,j,2,0);
			if(a[j].y>=a[i].y) now_min=min(now_min,a[j].y);
		}
	}
	printf("%d",-mcmf(0,T1));
	return 0;
}
```

---

## 作者：清风霁月 (赞：10)

## 第一篇DP题解——

### 题意：
两个peachman吃peach，你可以决定两个peachman开始的位置，peachman走到peach的地方就会吃掉它，peachman只会向左或向上走，路线不可相交，问最多能吃多少peach。


### 暴力


------------

其实也是个dp（记忆化搜索？），但思维难度明显少了很多。
很明显我们可以开一个四维数组表示第一个peachman和第二个peachman的位置。然后照传纸条跑就行了。


注意到题目上说路径不可以相交。


其实没有必要去管它。路径如果相交的话，换一下peachman就行了。

![](https://cdn.luogu.com.cn/upload/image_hosting/bzcr2u4g.png)

### 正解


------------

拓扑排序+dp


因为一个点只能从它的右下角转移过来，所以我们可以将其看做一个DAG，然后拓排。


我们dp的顺序就是这个图的拓扑序。

Dp的连边不像网络流那么复杂，好像直接暴力连也能过，但很容易超时。

优化的方法是假如i，j连边，如果有一条边（i，k），满足x[j]<=x[k]&&y[j]<=y[k]，那么（i，k）就没有存在的必要了。

Dp方程很有意思，我们用f[i][j]表示a吃到了i点，b吃到了j点的最大值，转移的时候转移拓扑序小的那一维，并保证f[i][j]中，要么i的拓扑序始终大于j，要么j始终大于i。
同时，我们需要一个超级原点和终点来连上所有的点，最终的答案就是dp[超级终点][超级终点]-1。

```cpp
inline void dp(int x,int y)//x,y是在主函数里枚举的x:超级原点-->终点   y:i-->终点
{
	int i,a,b;
	for(i=head[x];i;i=way[i].next)
	{
		a=way[i].to,b=y;
		if(id[a]>id[y]) swap(a,b);//注意这里
		if(a!=b) f[a][b]=max(f[a][b],f[x][y]+1);
		else f[a][b]=max(f[a][b],f[x][y]);
	}
}

```

为什么要减一呢？

我们注意一下dp方程，在统计的过程中，我们其实并不会将超级原点统计下来，但会加上一个超级终点的peach。减掉就好了。

为什么j要从i开始枚举呢？

因为这里转移的是i的出边，而不是i。

### 代码


------------

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

const int N=1e5+7,M=2005;

struct node { int x,y; }g[N];
struct edge { int to,next; }way[N*300];int tot,head[N];
int n,cnt,ed,rd[N],id[N],ID[N],q[N*2];
int f[M][M];

inline void add(int x,int y)
{
	way[++tot].to=y;
	way[tot].next=head[x];
	head[x]=tot;
}

inline void tsort()
{
	int i,h=0,t=1,x;
	q[1]=0;
	while(h!=t)
	{
		x=q[++h];
		id[x]=++cnt;
		ID[cnt]=x;
		for(i=head[x];i;i=way[i].next)
		{
			if(--rd[way[i].to]==0)
			{
				q[++t]=way[i].to;
			}
		}
	}
}

inline void dp(int x,int y)
{
	int i,a,b;
	for(i=head[x];i;i=way[i].next)
	{
		a=way[i].to,b=y;
		if(id[a]>id[y]) swap(a,b);
		if(a!=b) f[a][b]=max(f[a][b],f[x][y]+1);
		else f[a][b]=max(f[a][b],f[x][y]);
	}
}

bool cmp(node x,node y)
{
	if(x.x!=y.x) return x.x<y.x;
	return x.y<y.y;
}

int main()
{
	int i,j,t;
	scanf("%d",&n);
	for(i=1;i<=n;i++) scanf("%d%d",&g[i].x,&g[i].y);
	sort(g+1,g+1+n,cmp);
	for(i=1;i<=n;i++)
	{
		t=1e9;
		for(j=i+1;j<=n;j++)
		{
			if(g[i].y<=g[j].y&&g[j].y<t)
			{
				t=g[j].y;
				rd[j]++;
				add(i,j);
			}
		}
	}
	ed=n+1;
	for(i=1;i<=n;i++)
	{
		add(0,i);  rd[i]++;
		add(i,ed); rd[ed]++;
	}
	tsort();
	for(i=1;i<=cnt;i++)
	{
		for(j=i;j<=cnt;j++)
		{
			dp(ID[i],ID[j]);
		}
	}
	printf("%d",f[ed][ed]-1);
	return 0;
}
```


---

## 作者：lingfunny (赞：9)

## 前言
在模拟赛的时候做到了这题，这题的题解可以说是一个很新颖的思路，没用到最大流，SPFA之类的算法，单纯只用了一个~~简单的~~贪心。

## 题解
首先先按豆豆的 $x$ 排序，若 $x$ 相等则按 $y$ 排序，这样就保证了 PACMAN 从左往右，从下往上吃豆豆。如果把样例扣过来可以画出一个这样的图：

![](https://cdn.luogu.com.cn/upload/image_hosting/99jgt7tp.png)

然后，我们将两个 PACMAN 分别编号为 0 和 1，对于每个排好序的豆子，**都让编号为 0 的 PACMAN 先吃**，如果这颗豆子能从吃掉的前一个豆子到达（如果是第一颗豆子就直接吃），就直接吃掉。如果不能，就一直往回走，把以前吃掉的豆子吐出来给编号为 1 的吃（但是存在 0 号里，只是给一个标记到 1 号中），直到自己能从最后吃掉的这个豆子到达当前这个豆子并吃掉，这样能保证吃掉最多的豆子。

```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
const int maxn=2001;
struct Point{
	int x,y;
	friend bool operator <(Point a,Point b){
		if(a.x==b.x)return a.y<b.y;
		return a.x<b.x;
	}
};
vector<int> a[2];
Point p[maxn];
int N;
void add(int row,int v){//row表示编号0,1。v表示豆豆高度 
    if(row>1)return;//若没有这一号虫子，则放弃 
	if(!a[row].size())a[row].push_back(v);//如果这个PACMAN没有吃过一个豆豆，就没有限制，直接吃掉 
	else{
		if(v>=a[row][a[row].size()-1])a[row].push_back(v);//如果PACMAN吃过的豆豆都比这个豆豆低，直接吃掉 
		else{
			int pos=a[row].size()-1; 
			while(pos>=0&&v<a[row][pos])pos--;//找到第一个比这个豆豆低的豆豆
			add(row+1,a[row][pos+1]);//并将比它高的所有豆豆给下一号虫子吃（但是存在数组里,只是给一个标记到下一号）
			a[row][pos+1]=v;//将这个豆豆吃掉 
		}
	}
}
void init(){
	scanf("%d",&N);
	for(int i=1;i<=N;i++)scanf("%d%d",&p[i].x,&p[i].y);
	sort(p+1,p+N+1);//按照豆豆从左到右排序 
}
void work(){
	for(int i=1;i<=N;i++)add(0,p[i].y);//加入每个豆豆
    printf("%d\n", a[0].size() + a[1].size());
}
int main(){
	init(); work();
	return 0;
}
```

---

## 作者：kkksx (赞：5)

题目有以下要求：

1：一个豆子只能吃一次（废话）

2：只能吃右上角的豆子

3：两条路径不交叉

首先第3个要求并没有什么用，因为交叉路径可以转换为不交叉路径，这种思路存在于[这道题](https://www.luogu.org/problemnew/show/P1007)
~~（普及-）~~，即对调交叉点之后的路径

所以题目变成了求两条路径使得吃到的豆子最多，~~通过思考得出~~可以用费用流来做

先考虑**建图**

1.首先s连0号点，容量为2，表示只有两条路径

2.点与点之间，我们很容易想到，如果j在i的右上角，那么i连向j，容量为2

3.每个点连t，表示都可以作为结束点

但是有个问题，**费用**怎么得到？

由于一个豆子只能被吃一次，所以在之前的边上直接加费用1是不正确的。我们可以将一个点x拆成x1和x2，x的入边连给x1，出边连给x2，x1和x2之间连两条容量为1的边，费用分别为0和1，即可实现每个点只被统计一次

解决了建图问题之后，跑最大费用最大流即可

~~看起来好像是这样的~~

但是点与点之间可能有很多边，比如点（x,y）依次递增，最大就有$n^2$条边。通过观察可以发现，有些边是没有必要的，比如x->y,x->z,y->z这三条边中，x->z就没有意义，x，z之间可以间接连接，于是便有了下面这个连边方法

先将所有点按x升序排列，for(1~n)，对于一个点i，如果它连向了后面的某个点j，那么对于（j+1~n）中的点，如果它的纵坐标大于j，就没有必要直接连接它，因为之后j会连接它，i可以间接连接。也就是说，从i出发直接相连的点，它们的纵坐标一定是**降序排列**的

Q：如果像上面那样做，万一i后面的点全是降序呢，那还不是要炸

A：由i出发的直接相连的边确实变成了很多条，但是对于i+1，之后的所有点的纵坐标都比它小，就不会产生连边了，所以这种情况平均下来边还是比较少

Code：

```cpp
#include<bits/stdc++.h>
#define N 6010
#define INF 100000005
using namespace std;
int n,m,s,t,num;
int dis[N],flow[N],preedge[N],pre[N];
int maxflow,maxcost;
bool exist[N];
struct Node {int x,y;} node[N];

struct Edge
{
	int next,to,flow,dis;
}edge[N*100];int head[N],cnt=1;
void add_edge(int from,int to,int flow,int dis)
{
	edge[++cnt].next=head[from];
	edge[cnt].to=to;
	edge[cnt].flow=flow;
	edge[cnt].dis=dis;
	head[from]=cnt;
}
void ad(int from,int to,int flow,int dis)
{
	add_edge(from,to,flow,dis);
	add_edge(to,from,0,-dis);
}

template <class T>
void read(T &x)
{
	char c;int sign=1;
	while((c=getchar())>'9'||c<'0') if(c=='-') sign=-1; x=c-48;
	while((c=getchar())>='0'&&c<='9') x=(x<<1)+(x<<3)+c-48; x*=sign; 
}
bool Spfa(int s,int t)
{
	memset(dis,-100,sizeof(dis));
	memset(flow,100,sizeof(flow));
	memset(exist,0,sizeof(exist));
	queue<int> q;
	pre[t]=-1; exist[s]=1; dis[s]=0; q.push(s);
	while(!q.empty())
	{ 
		int u=q.front();q.pop();exist[u]=0;
		for(int i=head[u];i;i=edge[i].next)
		{
			int v=edge[i].to;
			if(edge[i].flow>0&&dis[v]<dis[u]+edge[i].dis)
			{
				dis[v]=dis[u]+edge[i].dis;
				flow[v]=min(edge[i].flow,flow[u]);
				pre[v]=u;
				preedge[v]=i;
				if(!exist[v])
				{
					exist[v]=1;
					q.push(v);
				}
			}
		}
	}
	return pre[t]!=-1;
}
void MCMF()
{
	while(Spfa(s,t))
	{
		maxflow+=flow[t];
		maxcost+=flow[t]*dis[t];
		int now=t;
		while(now!=s)
		{
			edge[preedge[now]].flow-=flow[t];
			edge[preedge[now]^1].flow+=flow[t];
			now=pre[now];
		}
	}
}
bool cmp(Node a,Node b) {return a.x!=b.x ? a.x<b.x : a.y<b.y;}
int main()
{
	read(n);
	s=n+1;t=n+2;m=n*2;
	node[0].x=node[0].y=0;
	for(int i=1;i<=n;++i) read(node[i].x),read(node[i].y);
	sort(node+1,node+n+1,cmp);//按x排序 
	for(int i=0;i<=n;++i)
	{
		int minn=0;
		for(int j=i+1;j<=n;++j)//保证xj>=xi 
		{
			if(node[j].y<node[i].y) continue;//无法到达 
			if((!minn)||node[j].y<minn)//更低则必须加边 
			{
				minn=node[j].y;
				ad(i+m,j,2,0);
			}
		}
	}
	ad(s,0,2,0);
	ad(0,m,2,0);
	for(int i=1;i<=n;++i) ad(i,i+m,1,1),ad(i,i+m,1,0),ad(i+m,t,2,0);
	MCMF();
	cout<<maxcost<<endl;
	return 0;
}
```



---

## 作者：yinianxingkong (赞：4)

# [[SHOI2003] 吃豆豆](https://www.luogu.com.cn/problem/P4066)

# 前言

太水了就直接跳了。

# 解法分析

求两条不交最长不降子序列长度和的最大值。

首先不交是假的，因为只能往右或往上，走到一个点时两条路径后面就等价了，可以把相交部分交换成不交。

然后就是两条最长不降子序列长度和最大，这需要您较为充分的理解 `LIS` 的 $O(n\log n)$ 做法。

考虑那个辅助数组 $f_i$，含义是**长度为 $i$ 的最长不降子序列的最小结尾**，这样可以使后面替换最优，本质上是一种贪心。

那如果再加入第二条呢？我们保证第一条最优，将第一条替换下来的点加入第二条的 $f$ 数组。注意两个 $f$ 数组本质上是维护最优和次优解，因为把更次的解放进序列里一定不会更优，所以我们只需要在最优与次优里面考虑。还要注意 $f$ 数组并不代表两个最长不降子序列的长度，我们相当于用最优与次优的数拼成两个序列，而这显然能拼上。

# 实现

没什么好说的。

# 代码

~~比费用流短不少。~~

```cpp
#include<bits/stdc++.h>
#define N 2005
int n,p1,p2,b1[N],b2[N],vis[N];std::pair<int,int> s[N];
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d%d",&s[i].first,&s[i].second);
	sort(s+1,s+1+n);
	for(int i=1;i<=n;i++){
		if(s[i].second>=b1[p1]) b1[++p1]=s[i].second;
		else{
			int pos=std::upper_bound(b1+1,b1+p1+1,s[i].second)-b1;
			if(b1[pos]>=b2[p2]) b2[++p2]=b1[pos];
			else *std::upper_bound(b2+1,b2+p2+1,b1[pos])=b1[pos];
			b1[pos]=s[i].second;
		}
	}
	printf("%d",p1+p2);
	return 0;
}
```

# 后记

降黄！

欢迎 `hack`！

---

## 作者：Pentiment (赞：3)

今天老师讲了这题，感觉非常神奇。为什么都用费用流做？明明贪心就可以啊。

首先，把所有点按照 $x$ 坐标第一关键字、$y$ 坐标第二关键字排序。维护两个单调栈，存储点的 $y$ 坐标与其下标（实际上代码中用的是 `vector`，因为不需要真的删除）。

对于每个点，如果能直接给第一个人吃就直接插入第一个单调栈，否则，二分找出第一个大于等于该点 $y$ 坐标的点，考虑将其插入到第二个单调栈中。

同样，如果能直接给第二个人吃就直接插入第二个单调栈，否则，在第二个单调栈中二分，找出第一个大于等于该点 $y$ 坐标的点，直接插入即可。

注意不能先求一个 LIS，再去掉再求一次，因为第一次 LIS 可能会把某些位置的最优选择用掉，导致第二个 LIS 无法增长。

实现有些细节，$y$ 坐标有可能相同，需要用下标（$x$ 坐标）作为第二关键字二分。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define eb emplace_back
#define mp make_pair
typedef pair<int, int> node;
#define x first
#define y second
const int N = 2005;
int n;
node a[N];
vector<node> s[2];
int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d%d", &a[i].x, &a[i].y);
	sort(a + 1, a + 1 + n);
	for (int i = 1; i <= n; i++) {
		if (s[0].empty() || a[i].y >= s[0].back().x) s[0].eb(mp(a[i].y, i));
		else {
			auto it0 = lower_bound(s[0].begin(), s[0].end(), mp(a[i].y, i));
			if (s[1].empty() || (*it0).x >= s[1].back().x) s[1].eb(*it0);
			else {
				auto it1 = lower_bound(s[1].begin(), s[1].end(), *it0);
				*it1 = *it0;
			}
			*it0 = mp(a[i].y, i);
		}
	}
	printf("%d", s[0].size() + s[1].size());
}
```

---

## 作者：IkunTeddy (赞：2)

# 题目分析

两条线段不相交不好求，但是我们发现如果两条线段相交时交换相交后的路径那么就是合法的，如下图。

![pic](https://cdn.luogu.com.cn/upload/image_hosting/xcw64jdh.png)

所以我们就可以把相交这个条件去掉了。

线段只能往上和右走，这是个二维限制，所以我们考虑对排序 $x$ 维度排序降一维限制。

现在问题又转化为，在序列上求**两个不含有共同元素的不下降子序列的最长长度和**。

这个可以考虑贪心，我们依旧考虑用求一条 LIS 的思路。

我们依旧维护两条 LIS 的某一长度以哪个元素结尾的数组 $f_1$ 和 $f_2$。

当新加一个元素时：

1. 若能增加 $f_1$ 的长度直接增加 $f_1$ 长度即可。

2. 如果替换了 $f_1$，就考虑把被替换的元素去更新 $f_2$ 即可。

这样我们就用 $O(n\log n)$ 的复杂度完成双 LIS 的求解。

思路还是比较好想，复杂度也十分优秀，$n$ 完全可以给到 $10^6$。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2000+10;
int n;
struct node{
	int x,y;
	bool operator < (const node &it){
		if(x==it.x)return y<it.y;
		else return x<it.x;
	}
}s[maxn];
int ans1,ans2;
int f1[maxn],f2[maxn];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>s[i].x>>s[i].y;
	sort(s+1,s+1+n);
	for(int i=1;i<=n;i++){
		if(s[i].y>=f1[ans1]){
			f1[++ans1]=s[i].y;
			continue ;
		}
		int x=upper_bound(f1+1,f1+1+ans1,s[i].y)-f1;
		int val=f1[x];
		f1[x]=s[i].y;
		if(val>=f2[ans2]){
			f2[++ans2]=val;
			continue ;
		}
		x=upper_bound(f2+1,f2+1+ans2,val)-f2;
		f2[x]=val;
	}
	cout<<ans1+ans2<<'\n';
	
	return 0;
}
```

---

## 作者：zzxLLL (赞：2)


正常的费用流被卡了啊。。。

那就祭出 cdq 分治优化建图吧

---

路径不能相交看起来很难做。

考虑如果两条路径在 $A \to B$ 与 $C \to D$ 处相交，那么可以将这个方案改成 $A \to D$ 和 $C \to B$，这样就解决了相交的问题。

然后只有每个点只能走一次的限制了。

考虑费用流，对于每个点建边 $(u, u + n)$，费用为 $1$，容量为 $1$，于是就完成了只能走一次的限制。

源点 $S$ 连上另一个源点 $S'$，费用为 $0$，容量为 $2$，限制了只有 $2$ 个 PACMAN。

对于所有点连边 $(S', u), (u + n, T)$，费用为 $0$，容量为 $+ \infin$。

然后就是枚举点对 $(u, v)$，如果 $v$ 在 $u$ 的右上角，那么建边 $(u + n, v)$，费用为 $0$，容量为 $+ \infin$。

然后图就建完了。但是 $O(n^2)$ 的边数，会喜提 TLE。

边数太多所以考虑优化建图。

先将所有坐标以 $x, y$ 为第一，二关键字排序，这样就保证编号小的点连向编号大的点。

然后 cdq 分治，然后对于编号 $a \in [l, mid]$，应该连向所有 $b \in [mid + 1, r]$ 且 $y_b \ge y_a$ 的点。所以 $[mid + 1, r]$ 的点按照 $y$ 排序一下，就变成了 $a$ 向一段后缀区间连边，直接前后缀优化即可。

边数只有 $O(n \log n)$，于是就不 T 了。跑的飞快，最后一个点 $1.2s \to 50ms$。

```cpp
#include<queue>
#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>
const int M=5e5+10;
const int inf=1e9+7;

int n;

int head[M],cnte=1;
struct Edge{
    int to,nxt,cap,flow,cost;
}e[M];
void add(int u,int v,int w,int c){
    e[++cnte]=(Edge){v,head[u],w,0,c};
    head[u]=cnte;
}
void Add(int u,int v,int w,int c){
    // printf("Add(%d, %d, %d, %d)\n",u,v,w,c);
    add(u,v,w,c),add(v,u,0,-c);
}

int tot,s,t,s0;
int dis[M],infl[M],pre[M];
bool vis[M];

std::deque<int>q;
inline bool SPFA(){
    for(int i=0;i<=tot;i++) dis[i]=-inf,infl[i]=inf;
    q.push_back(s),dis[s]=0;
    while(!q.empty()){
        int u=q.front();
        vis[u]=false,q.pop_front();
        for(int i=head[u];i;i=e[i].nxt){
            int v=e[i].to;
            if(e[i].cap>e[i].flow&&dis[v]<dis[u]+e[i].cost){
                dis[v]=dis[u]+e[i].cost,pre[v]=i;
                infl[v]=std::min(infl[u],e[i].cap-e[i].flow);
                if(!vis[v]){
                    if(q.empty()||dis[v]>dis[q.front()]) q.push_front(v);
                    else q.push_back(v);
                }
            }
        }
    }
    return dis[t]!=-inf;
}

int cost;
inline int dfs(int u,int in){
    if(u==t) return in;
    vis[u]=true;
    int out=0;
    for(int i=head[u];i;i=e[i].nxt){
        int v=e[i].to;
        if(vis[v]||e[i].cap<=e[i].flow) continue;
        if(dis[v]==dis[u]+e[i].cost){
            int res=dfs(v,std::min(in,e[i].cap-e[i].flow));
            e[i].flow+=res,e[i^1].flow-=res;
            cost+=res*e[i].cost,in-=res,out+=res;
            if(!in) break;
        }
    }
    if(!out) dis[u]=-23333;
    vis[u]=false;
    return out;
}

struct Position{
    int x,y;
    bool operator<(const Position &o)const{
        return x<o.x||(x==o.x&&y<o.y);
    }
}ps[M];
int lsh[M],len;

int id[M],tmp[M],y[M];
bool cmp(int A,int B){
    return ps[A].y<ps[B].y;
}
void cdq(int l,int r){
    if(l==r) return;
    int mid=(l+r)>>1;
    
    for(int i=mid+1;i<=r;i++) y[i]=ps[i].y;
    std::sort(y+mid+1,y+r+1);
    int len=std::unique(y+mid+1,y+r+1)-y-1;
    for(int i=mid+1;i<=len;i++) id[i]=++tot;
    for(int i=mid+1;i<=r;i++){
        int pos=std::lower_bound(y+mid+1,y+len+1,ps[i].y)-y;
        Add(id[pos],i,inf,0);
    }
    for(int i=mid+1;i<len;i++) Add(id[i],id[i+1],inf,0);
    for(int i=l;i<=mid;i++){
        int pos=std::lower_bound(y+mid+1,y+len+1,ps[i].y)-y;
        if(pos>len) continue;
        Add(i+n,id[pos],inf,0);
    }
    cdq(l,mid),cdq(mid+1,r);
}

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&ps[i].x,&ps[i].y);
    std::sort(ps+1,ps+1+n);
    s=0,s0=2*n+1,t=tot=2*n+2;
    Add(s,s0,2,0);
    for(int i=1;i<=n;i++)
        Add(s0,i,1,0),Add(i+n,t,1,0),Add(i,i+n,1,1);
    cdq(1,n);

    while(SPFA()) dfs(s,inf);
    printf("%d",cost);
    return 0;
}
```

---

## 作者：sangshang (赞：0)

# Description

两个 PACMAN 吃豆，每只 PACMAN 都只能向上走，或向右走。路径可以有交点但不能互相穿过。有 $n$ 个豆子，给出坐标，求最多一共吃多少豆子。

# Solution

“*路径可以交点但不能互相穿过*”这个条件明显是没用的。因为，任意一个有交叉的路径，都能转化为有交点但不交叉的路径。只要让一个 PACMAN 始终走在另一个 PACMAN 上方即可，而两种路径对求出答案没有影响。

现在问题就简单很多了。因为 PACMAN 只能向上或向右走，也就是说，若现在位置是 $(x_i,y_i)$，下一步的位置 $(x_i',y_i')$ 必须满足 $x_i'\ge x_i,y_i'\ge y_i$。

考虑费用流模型。以吃到一颗豆子为标准，建出 $n$ 组点，每组点分为入点和出点。从入点向出点连两条边，一条边费用为 $-1$，容量为 $1$，表示将豆子吃掉，费用为负主要是为了方便的实现最大费用最大流，最后答案取相数时即可。另一条边容量为 $+\infty$，费用为 $0$，表示经过这个豆子，这是因为路径可以有交点。

然后就一个套路了。将豆子按坐标排序，将每个豆子枚举一边,对于每个豆子，枚举它下一个可到的豆子，从他的出点向可到达豆子的入点连一条容量为 $+\infty$ 费用为 $0$ 的边，表示到达下一个豆子。注意因为起点和终点都可任选，所以要多建两个点用以限制流量，源点和汇点只和这两个点相连一条容量为 $2$ 费用为 $0$ 的边。而这两个点与每个豆子的入点或出点对应都要连一条容量为 $+\infty$ 的边。

但这样暴力建图明显会超时。考虑优化，如果从 $A$ 能到 $B$，从 $B$ 能到 $C$。那完全没必要连一条从 $A$ 到 $C$ 的边，因为跳过 $B$ 直接去吃 $C$ 一定不是更优的。具体的，对于每个豆子 $i$，从 $x_i$ 开始，优先按 $x$ 小的枚举，如果这个豆子纵坐标大于等于上个豆子纵坐标，即这个豆子上一个豆子可以到达，就跳过；否则，记录这个豆子纵坐标，并连边。

# C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

class Dinic {
	public:
		typedef int TYPE;
		static const int maxn = 2005 * 4, inf = 0x7f7f7f7f, maxm = inf;
		class edge {
			public:
				int to, rev;
				TYPE flow, cost;
				edge(int to, TYPE flow, TYPE cost, int rev): to(to), flow(flow), cost(cost), rev(rev) {}
				edge() {}
		};
		std::vector<edge>vec[maxn];
		TYPE dist[maxn], MinCost, MaxFlow;
		int cur[maxn], n, m, s, t;
		bool vis[maxn];
		Dinic(int n, int m, int s, int t): n(n), m(m), s(s), t(t),
			cur({0}), dist({0}), vis({false}), MinCost(0), MaxFlow(0) {}
		Dinic() {}
		inline void Add_Edge(int from, int to, TYPE flow, TYPE cost) {
			vec[from].push_back(edge(to, flow, cost, vec[to].size()));
			vec[to].push_back(edge(from, 0, -cost, vec[from].size() - 1));
		}
		inline bool SPFA() {
			int back = -1, front = 0;
			queue<int>que;
			std::memset(vis, false, sizeof(vis));
			std::memset(dist, inf, sizeof(dist));
			dist[t] = 0;
			std::memset(cur, 0, sizeof(cur));
			for (que.push(t), vis[t] = true; !que.empty();) {
				int u = que.front();
				que.pop();
				vis[u] = false;
				for (edge &e : vec[u]) {
					int v = e.to;
					if (vec[v][e.rev].flow && dist[v] > dist[u] + vec[v][e.rev].cost) {
						dist[v] = dist[u] + vec[v][e.rev].cost;
						if (!vis[v]) {
							que.push(v);
							vis[v] = true;
						}
					}
				}
			}
			return dist[s] != inf;
		}
		inline TYPE dfs(int u, TYPE flow) {
			if (u == t || !flow) {
				return flow;
			}
			vis[u] = true;
			int sz = vec[u].size();
			TYPE res = 0;
			for (int &i = cur[u]; i < sz && flow; ++i) {
				edge &e = vec[u][i];
				int v = e.to;
				if (e.flow && dist[v] + e.cost == dist[u] && !vis[v]) {
					TYPE Preflow = dfs(v, std::min(flow, e.flow));
					res += Preflow, flow -= Preflow, MinCost += (Preflow * e.cost);
					e.flow -= Preflow, vec[v][e.rev].flow += Preflow;
				}
			}
			return res;
		}
		inline TYPE Get_MCMF() {
			MaxFlow = 0;
			while (SPFA()) {
				TYPE res = 0;
				while ((res = dfs(s, inf))) {
					MaxFlow += res;
				}
			}
			return MaxFlow;
		}
		std::pair<TYPE, TYPE>Node[2005];
		inline void Solve() {
#define id(a,CLASS) (a+(CLASS*N))
			int N;
			scanf("%d", &N);
			this[0] = Dinic((N << 1) + 5, inf, 0, (N << 1) + 1);
			for (int i = 1; i <= N; ++i) {
				scanf("%d%d", &Node[i].first, &Node[i].second);
			}
			std::sort(Node + 1, Node + N + 1);
			int LimS = (N << 1) + 2, LimT = (N << 1) + 3;
			Add_Edge(s, LimS, 2, 0);
			Add_Edge(LimT, t, 2, 0);
			for (int i = 1; i <= N; ++i) {
				TYPE y = inf;
				for (int j = i + 1; j <= N; ++j) {
					if (Node[j].second >= y || Node[j].second < Node[i].second) {
						continue;
					}
					y = Node[j].second;
					Add_Edge(id(i, 1), id(j, 0), 2, 0);
				}
				Add_Edge(id(i, 0), id(i, 1), 1, -1);
				Add_Edge(id(i, 0), id(i, 1), 2, 0);
				Add_Edge(LimS, id(i, 0), 2, 0);
				Add_Edge(id(i, 1), LimT, 2, 0);
			}
			Get_MCMF();
			printf("%d\n", -MinCost);
		}
};
Dinic Main;

int main() {
	Main.Solve();
	return 0;
}
```


---

## 作者：封禁用户 (赞：0)

# 题目的要求 :)：

1. 一个豆子只能吃一次

2. 只能吃右上角的豆子

3. 两条路径不交叉

# 思路

首先第 $3$ 个要求并没有什么用，因为交叉路径可以转换为不交叉路径，即对调交叉点之后的路径。

所以题目变成了求两条路径使得吃到的豆子最多，通过思考得出可以用**费用流**来做。

先考虑**建图**

1. 首先 $s$ 连 $0$ 号点，容量为 $2$，表示只有两条路径。

2. 点与点之间，我们很容易想到，如果 $j$ 在 $i$ 的右上角，那么 $i$ 连向 $j$，容量为 $2$。

3. 每个点连 $t$，表示都可以作为结束点。

但是有个问题，费用怎么得到？

由于一个豆子只能被吃一次，所以在之前的边上直接加费用1是不正确的。我们可以将一个点 $x$ 拆成 $x1$ 和 $x2$，$x$ 的入边连给 $x1$，出边连给 $x2$，$x1$ 和 $x2$ 之间连两条容量为1的边，费用分别为 $0$ 和 $1$，即可实现每个点只被统计一次。

解决了建图问题之后，跑最大费用**最大流**即可。

看起来好像是这样的。

但是点与点之间可能有很多边，比如点 $(x,y)$ 依次递增，最大就有 $n^2$ 条边。

通过观察可以发现，有些边是没有必要的，比如 $x \to y$ , $x \to z$ , $y \to z$ 这三条边中，$x \to z$ 就没有意义， $x \to z$ 之间可以间接连接，于是便有了下面这个连边方法：

先将所有点按 $x$ 升序排列，$\text{for } i=1 \to n$，对于一个点 $i$，如果它连向了后面的某个点 $j$，那么对于 $(j+1) \sim n$ 中的点，如果它的纵坐标大于 $j$，就没有必要直接连接它，因为之后 $j$ 会连接它，$i$ 可以间接连接。也就是说，从 $i$ 出发直接相连的点，它们的纵坐标一定是降序排列的。

代码的话我就放在[云剪切板](https://www.luogu.com.cn/paste/75x1b163)里了，毕竟有点长。

---


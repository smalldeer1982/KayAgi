# [NOI2005] 智慧珠游戏

## 题目描述

智慧珠游戏拼盘由一个三角形盘件和 12 个形态各异的零件组成。拼盘的盘 件如图 1 所示
![](https://cdn.luogu.com.cn/upload/pic/13767.png)
![](https://cdn.luogu.com.cn/upload/pic/13768.png)
![](https://cdn.luogu.com.cn/upload/pic/13769.png)
对 于 由珠子构成的零件，可以放到盘件的任一位置，条件是能有地方放，且 尺寸合适，所有的零件都允许旋转(0º、90º、180º、270º)和翻转(水平、竖直)。
 
 
现给出一个盘件的初始布局，求一种可行的智慧珠摆放方案，使所有的零件 都能放进盘件中。 

## 样例 #1

### 输入

```
.
..
...
....
.....
.....C
...CCC.
EEEHH...
E.HHH....
E.........```

### 输出

```
B
BK
BKK
BJKK
JJJDD
GJGDDC
GGGCCCI
EEEHHIIA
ELHHHIAAF
ELLLLIFFFF```

# 题解

## 作者：Fellyhosn (赞：156)

# 题解 P4205 [NOI2005]智慧珠游戏 

![](https://cdn.luogu.com.cn/upload/pic/38300.png)

### 先给大家简述一下题意：（不会玩智慧珠游戏的自己去百度一下）

写一个程序解决骨灰级智慧珠问题（只给出$1$~$3$个块，你需要自己填完剩下的$9$~$11$块）

数据保证至多有一组解。

### 假装分析一下：这是所有块的形状

![](https://cdn.luogu.com.cn/upload/pic/13768.png)

由于图形可以旋转、翻折、~~跳跃~~，所以要先把12个零件的所有形状枚举出来：

- A：4种  
- B：2种
- C：8种
- D：1种
- E：4种
- F：8种
- G：4种
- H：8种
- I：8种
- J：1种
- K：4种
- L：8种

### 总共只有60种情况，如果你觉得多的话请跳过此题解。

### 如果你不想用搜索做，请跳过此题解。

每次从上到下，从做到右找出第一个没有被放零件的格子。56种情况一一枚举就行了（**剪枝想怎么搞怎么搞只要是对的就OK了**）注意回溯。

听说有个点会卡顺序搜，那么就可以换个方向就行了（**或者卡个搜索次数**）

** 代码不长，刚过千行。没有猪国杀的变态，没有mayan游戏的玄学，没有A+B问题的变幻无常，没有任何超纲。阻挡你向前的只是你的懒惰，是你的习得性无助。学OI的意义是什么？成为dalao的意义是什么？只有成为真正的码农，才无愧于你的内心。**

~~~
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>

using namespace std;

char id(int x){
    return (char)(x+'A'-1);
}

int gi(){
    char x=getchar();
    while(x!='.'&&(x>'Z'||x<'A')) x=getchar();
    return x=='.'?0:(int)(x-'A'+1);
}

int a[16][16],ti;
bool in[15];

int get(){
    for(int i=1;i<=10;i++){
        for(int j=1;j<=i;j++)
             if(a[j][i]==0){
     	return j*100+i;
        }
    }
}

bool ok(){
     for(int o=1;o<=12;o++)
     if(in[o]==false)
     return false;
     return true;
}

void init(){
    memset(a,-1,sizeof(a));
    memset(in,0,sizeof(in));
    for(int i=1;i<=10;i++){
        for(int j=1;j<=i;j++){
            a[j][i]=gi();
            in[a[j][i]]=true;
        }
    }
    for(int i=1;i<=10;i++){
    	for(int j=1;j<=i;j++){
    		if(a[j][i]==-1) {
    			a[j][i]=0;
            }
        }
    }
}

void print(){
    for(int i=1;i<=10;i++){
        for(int j=1;j<=i;j++){
            cout<<id(a[j][i]);  
        }
        cout<<endl;
    }
}

void dfs(){
    ti++;
    
    if(ti>=3000000){
        printf("No solution");
        exit(0);
    }//卡搜索次数
    //可以玄学证明：如果有解那么深搜的最大次数不会超过3e6
    
    if(ok()) {
      print();
      exit(0);  
    }
      
    int zt=get();
    int px=zt/100;
    int py=zt%10;
    if(py==0) py=10;
    
    //A:4cases
    if(!in[1]){
        
        if(a[px+1][py]==0&&a[px][py+1]==0){
            a[px][py]=1;
            a[px+1][py]=1;
            a[px][py+1]=1;
            in[1]=true;
             dfs();
            a[px][py]=0;
            a[px+1][py]=0;
            a[px][py+1]=0;
            in[1]=false;
        } 
        
        if(a[px][py+1]==0&&a[px+1][py+1]==0){
        	a[px][py]=1;
            a[px][py+1]=1;
            a[px+1][py+1]=1;
            in[1]=true;
            dfs();
        	a[px][py]=0;
            a[px][py+1]=0;
            a[px+1][py+1]=0;
            in[1]=false;
        } 
        
        if(a[px][py+1]==0&&a[px-1][py+1]==0){
        	a[px][py]=1;
            a[px][py+1]=1;
            a[px-1][py+1]=1;
            in[1]=true;
            dfs();
        	a[px][py]=0;
            a[px][py+1]=0;
            a[px-1][py+1]=0;
            in[1]=false;
        } 
        
        if(a[px+1][py]==0&&a[px+1][py+1]==0){
        	a[px][py]=1;
            a[px+1][py]=1;
            a[px+1][py+1]=1;
            in[1]=true;
            dfs();
            a[px][py]=0;
            a[px+1][py]=0;
            a[px+1][py+1]=0;
            in[1]=false;
        } 
        
    }
    
    //B:2cases
    if(!in[2]){
        
       if(a[px+1][py]==0&&a[px+2][py]==0&&a[px+3][py]==0){
          a[px][py]=2;
          a[px+1][py]=2;
          a[px+2][py]=2;
          a[px+3][py]=2;
          in[2]=true;
          dfs();
          a[px][py]=0;
          a[px+1][py]=0;
          a[px+2][py]=0;
          a[px+3][py]=0;
          in[2]=false;
       }
       
       if(a[px][py+1]==0&&a[px][py+2]==0&&a[px][py+3]==0){
       	  a[px][py]=2;
          a[px][py+1]=2;
          a[px][py+2]=2;
          a[px][py+3]=2;
          in[2]=true;
          dfs();
       	  a[px][py]=0;
          a[px][py+1]=0;
          a[px][py+2]=0;
          a[px][py+3]=0;
          in[2]=false;
       }
       
    }
    
    //C:8cases
    if(!in[3]){
        
       if(a[px+1][py]==0&&a[px+2][py]==0&&a[px][py+1]==0){
       	   a[px][py]=3;
           a[px+1][py]=3;
           a[px+2][py]=3;
           a[px][py+1]=3;
           in[3]=true;
           dfs();
       	   a[px][py]=0;
           a[px+1][py]=0;
           a[px+2][py]=0;
           a[px][py+1]=0;
           in[3]=false;
       }
       
       if(a[px+1][py]==0&&a[px+1][py+1]==0&&a[px+1][py+2]==0){
       	   a[px][py]=3;
           a[px+1][py]=3;
           a[px+1][py+1]=3;
           a[px+1][py+2]=3;
           in[3]=true;
           dfs();
           a[px][py]=0;
           a[px+1][py]=0;
           a[px+1][py+1]=0;
           a[px+1][py+2]=0;
           in[3]=false;
       }
       
       if(a[px+1][py]==0&&a[px][py+1]==0&&a[px][py+2]==0) {
       	   a[px][py]=3;
           a[px+1][py]=3;
           a[px][py+1]=3;
           a[px][py+2]=3;
           in[3]=true;
           dfs();
           a[px][py]=0;
           a[px+1][py]=0;
           a[px][py+1]=0;
           a[px][py+2]=0;
           in[3]=false;
       }
       
       if(a[px+1][py]==0&&a[px+2][py]==0&&a[px+2][py+1]==0){
       	   a[px][py]=3;
           a[px+2][py]=3;
           a[px+2][py+1]=3;
           a[px+1][py]=3;
           in[3]=true;
           dfs();
           a[px][py]=0;
           a[px+2][py]=0;
           a[px+2][py+1]=0;
           a[px+1][py]=0;
           in[3]=false;
       }  
       
       if(a[px+1][py+2]==0&&a[px][py+2]==0&&a[px][py+1]==0){
       	   a[px][py]=3;
           a[px+1][py+2]=3;
           a[px][py+2]=3;
           a[px][py+1]=3;
           in[3]=true;
           dfs();
           a[px][py]=0;
           a[px+1][py+2]=0;
           a[px][py+2]=0;
           a[px][py+1]=0;
           in[3]=false;
       }
       
       if(a[px-1][py+2]==0&&a[px][py+1]==0&&a[px][py+2]==0) {
       	   a[px][py]=3;
           a[px-1][py+2]=3;
           a[px][py+1]=3;
           a[px][py+2]=3;
           in[3]=true;
           dfs();
           a[px][py]=0;
           a[px-1][py+2]=0;
           a[px][py+1]=0;
           a[px][py+2]=0;
           in[3]=false;
       }
       
       if(a[px][py+1]==0&&a[px+1][py+1]==0&&a[px+2][py+1]==0){
       	   a[px][py]=3;
           a[px][py+1]=3;
           a[px+1][py+1]=3;
           a[px+2][py+1]=3;
           in[3]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px+1][py+1]=0;
           a[px+2][py+1]=0;
           in[3]=false;
       }
       
       if(a[px][py+1]==0&&a[px-1][py+1]==0&&a[px-2][py+1]==0){
       	   a[px][py]=3;
           a[px][py+1]=3;
           a[px-1][py+1]=3;
           a[px-2][py+1]=3;
           in[3]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px-1][py+1]=0;
           a[px-2][py+1]=0;
           in[3]=false;
       }
       
    }
    
    //D:1case
    if(!in[4]){
        
        if(a[px][py+1]==0&&a[px+1][py+1]==0&&a[px+1][py]==0){
           a[px][py]=4;
           a[px][py+1]=4;
           a[px+1][py+1]=4;
           a[px+1][py]=4;
           in[4]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px+1][py+1]=0;
           a[px+1][py]=0;
           in[4]=false;
        } 
        
    }
    
    //E:4cases
    if(!in[5]){
        
      if(a[px+1][py]==0&&a[px+2][py]==0&&a[px][py+1]==0&&a[px][py+2]==0) {
      	   a[px][py]=5;
           a[px+1][py]=5;
           a[px+2][py]=5;
           a[px][py+1]=5;
           a[px][py+2]=5;
           in[5]=true;
           dfs();
           a[px][py]=0;
           a[px+1][py]=0;
           a[px+2][py]=0;
           a[px][py+1]=0;
           a[px][py+2]=0;
           in[5]=false;
      }
      
      if(a[px+1][py]==0&&a[px+2][py]==0&&a[px][py-1]==0&&a[px][py-2]==0) {
      	   a[px][py]=5;
           a[px+1][py]=5;
           a[px+2][py]=5;
           a[px][py-1]=5;
           a[px][py-2]=5;
           in[5]=true;
           dfs();
           a[px][py]=0;
           a[px+1][py]=0;
           a[px+2][py]=0;
           a[px][py-1]=0;
           a[px][py-2]=0;
           in[5]=false;
      }
      
      if(a[px][py+1]==0&&a[px][py+2]==0&&a[px+1][py+2]==0&&a[px+2][py+2]==0){
      	   a[px][py]=5;
           a[px][py+1]=5;
           a[px][py+2]=5;
           a[px+1][py+2]=5;
           a[px+2][py+2]=5;
           in[5]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px][py+2]=0;
           a[px+1][py+2]=0;
           a[px+2][py+2]=0;
           in[5]=false;
      }
      
      if(a[px][py+1]==0&&a[px][py+2]==0&&a[px-1][py+2]==0&&a[px-2][py+2]==0){
      	   a[px][py]=5;
           a[px][py+1]=5;
           a[px][py+2]=5;
           a[px-1][py+2]=5;
           a[px-2][py+2]=5;
           in[5]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px][py+2]=0;
           a[px-1][py+2]=0;
           a[px-2][py+2]=0;
           in[5]=false;
      }
      
    }
    
    //F:8cases
    if(!in[6]){
        
       if(a[px-1][py+1]==0&&a[px][py+1]==0&&a[px+1][py+1]==0&&a[px+2][py+1]==0){
           a[px][py]=6;
           a[px-1][py+1]=6;
           a[px][py+1]=6;
           a[px+1][py+1]=6;
           a[px+2][py+1]=6;
           in[6]=true;
           dfs();
           a[px][py]=0;
           a[px-1][py+1]=0;
           a[px][py+1]=0;
           a[px+1][py+1]=0;
           a[px+2][py+1]=0;
           in[6]=false;
    } 
    
       if(a[px-1][py+1]==0&&a[px][py+1]==0&&a[px+1][py+1]==0&&a[px-2][py+1]==0) {
    	   a[px][py]=6;
           a[px-1][py+1]=6;
           a[px][py+1]=6;
           a[px+1][py+1]=6;
           a[px-2][py+1]=6;
           in[6]=true;
           dfs();
           a[px][py]=0;
           a[px-1][py+1]=0;
           a[px][py+1]=0;
           a[px+1][py+1]=0;
           a[px-2][py+1]=0;
           in[6]=false;
    }
    
       if(a[px+1][py+1]==0&&a[px+1][py]==0&&a[px+2][py]==0&&a[px+3][py]==0) {
    	   a[px][py]=6;
           a[px+1][py+1]=6;
           a[px+1][py]=6;
           a[px+2][py]=6;
           a[px+3][py]=6;
           in[6]=true;
           dfs();
           a[px][py]=0;
           a[px+1][py+1]=0;
           a[px+1][py]=0;
           a[px+2][py]=0;
           a[px+3][py]=0;
           in[6]=false;
    }
    
       if(a[px+1][py]==0&&a[px+2][py+1]==0&&a[px+2][py]==0&&a[px+3][py]==0) {
    	   a[px][py]=6;
           a[px+1][py]=6;
           a[px+2][py+1]=6;
           a[px+2][py]=6;
           a[px+3][py]=6;
           in[6]=true;
           dfs();
           a[px][py]=0;
           a[px+1][py]=0;
           a[px+2][py+1]=0;
           a[px+2][py]=0;
           a[px+3][py]=0;
           in[6]=false;
    }
    
       if(a[px][py+1]==0&&a[px][py+2]==0&&a[px][py+3]==0&&a[px+1][py+1]==0){
    	   a[px][py]=6;
           a[px][py+1]=6;
           a[px][py+2]=6;
           a[px][py+3]=6;
           a[px+1][py+1]=6;
           in[6]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px][py+2]=0;
           a[px][py+3]=0;
           a[px+1][py+1]=0;
           in[6]=false;
    } 
    
       if(a[px][py+1]==0&&a[px][py+2]==0&&a[px][py+3]==0&&a[px-1][py+1]==0) {
    	   a[px][py]=6;
           a[px][py+1]=6;
           a[px][py+2]=6;
           a[px][py+3]=6;
           a[px-1][py+1]=6;
           in[6]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px][py+2]=0;
           a[px][py+3]=0;
           a[px-1][py+1]=0;
           in[6]=false;
    }
    
       if(a[px][py+1]==0&&a[px][py+2]==0&&a[px][py+3]==0&&a[px+1][py+2]==0) {
    	   a[px][py]=6;
           a[px][py+1]=6;
           a[px][py+2]=6;
           a[px][py+3]=6;
           a[px+1][py+2]=6;
           in[6]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px][py+2]=0;
           a[px][py+3]=0;
           a[px+1][py+2]=0;
           in[6]=false;
    }
    
       if(a[px][py+1]==0&&a[px][py+2]==0&&a[px][py+3]==0&&a[px-1][py+2]==0) {
    	   a[px][py]=6;
           a[px][py+1]=6;
           a[px][py+2]=6;
           a[px][py+3]=6;
           a[px-1][py+2]=6;
           in[6]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px][py+2]=0;
           a[px][py+3]=0;
           a[px-1][py+2]=0;
           in[6]=false;
       }
    }
    
    //G:4cases
    if(!in[7]){
        
       if(a[px][py+1]==0&&a[px+1][py]==0&&a[px+2][py+1]==0&&a[px+2][py]==0) {
       	   a[px][py]=7;
           a[px][py+1]=7;
           a[px+1][py]=7;
           a[px+2][py+1]=7;
           a[px+2][py]=7;
           in[7]=true;
           dfs();
       	   a[px][py]=0;
           a[px][py+1]=0;
           a[px+1][py]=0;
           a[px+2][py+1]=0;
           a[px+2][py]=0;
           in[7]=false;
       }
       
       if(a[px][py+1]==0&&a[px+1][py+1]==0&&a[px+2][py+1]==0&&a[px+2][py]==0) {
       	   a[px][py]=7;
           a[px][py+1]=7;
           a[px+1][py+1]=7;
           a[px+2][py+1]=7;
           a[px+2][py]=7;
           in[7]=true;
           dfs();
       	   a[px][py]=0;
           a[px][py+1]=0;
           a[px+1][py+1]=0;
           a[px+2][py+1]=0;
           a[px+2][py]=0;
           in[7]=false;
       }
       
       if(a[px][py+1]==0&&a[px][py+2]==0&&a[px+1][py+2]==0&&a[px+1][py]==0) {
       	   a[px][py]=7;
           a[px][py+1]=7;
           a[px][py+2]=7;
           a[px+1][py+2]=7;
           a[px+1][py]=7;
           in[7]=true;
           dfs();
       	   a[px][py]=0;
           a[px][py+1]=0;
           a[px][py+2]=0;
           a[px+1][py+2]=0;
           a[px+1][py]=0;
           in[7]=false;
       }
       
       if(a[px+1][py]==0&&a[px+1][py+1]==0&&a[px+1][py+2]==0&&a[px][py+2]==0) {
       	   a[px][py]=7;
           a[px+1][py]=7;
           a[px+1][py+1]=7;
           a[px+1][py+2]=7;
           a[px][py+2]=7;
           in[7]=true;
           dfs();
       	   a[px][py]=0;
           a[px+1][py]=0;
           a[px+1][py+1]=0;
           a[px+1][py+2]=0;
           a[px][py+2]=0;
           in[7]=false;
       }
       
    }
    
    //H:8cases
    if(!in[8]){
        
    if(a[px+1][py]==0&&a[px+1][py+1]==0&&a[px+2][py]==0&&a[px+2][py+1]==0) {
           a[px][py]=8;
           a[px+1][py]=8;
           a[px+1][py+1]=8;
           a[px+2][py]=8;
           a[px+2][py+1]=8;
           in[8]=true;
           dfs();
           a[px][py]=0;
           a[px+1][py]=0;
           a[px+1][py+1]=0;
           a[px+2][py]=0;
           a[px+2][py+1]=0;
           in[8]=false;
    }
    
      if(a[px-1][py+1]==0&&a[px][py+1]==0&&a[px+1][py+1]==0&&a[px+1][py]==0) {
    	   a[px][py]=8;
           a[px-1][py+1]=8;
           a[px][py+1]=8;
           a[px+1][py+1]=8;
           a[px+1][py]=8;
           in[8]=true;
           dfs();
           a[px][py]=0;
           a[px-1][py+1]=0;
           a[px][py+1]=0;
           a[px+1][py+1]=0;
           a[px+1][py]=0;
           in[8]=false;
    }
    
      if(a[px][py+1]==0&&a[px+1][py]==0&&a[px+1][py+1]==0&&a[px+2][py+1]==0) {
    	   a[px][py]=8;
           a[px+1][py]=8;
           a[px][py+1]=8;
           a[px+1][py+1]=8;
           a[px+2][py+1]=8;
           in[8]=true;
           dfs();
           a[px][py]=0;
           a[px+1][py]=0;
           a[px][py+1]=0;
           a[px+1][py+1]=0;
           a[px+2][py+1]=0;
           in[8]=false;
    }
    
      if(a[px+1][py]==0&&a[px+2][py]==0&&a[px][py+1]==0&&a[px+1][py+1]==0){
    	   a[px][py]=8;
           a[px+1][py]=8;
           a[px+2][py]=8;
           a[px][py+1]=8;
           a[px+1][py+1]=8;
           in[8]=true;
           dfs();
           a[px][py]=0;
           a[px+1][py]=0;
           a[px+2][py]=0;
           a[px][py+1]=0;
           a[px+1][py+1]=0;
           in[8]=false;
    } 
    
      if(a[px][py+1]==0&&a[px][py+2]==0&&a[px+1][py+1]==0&&a[px+1][py+2]==0) {
    	   a[px][py]=8;
           a[px][py+1]=8;
           a[px][py+2]=8;
           a[px+1][py+1]=8;
           a[px+1][py+2]=8;
           in[8]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px][py+2]=0;
           a[px+1][py+1]=0;
           a[px+1][py+2]=0;
           in[8]=false;
    }
 	
      if(a[px][py+1]==0&&a[px][py+2]==0&&a[px-1][py+1]==0&&a[px-1][py+2]==0){
    	   a[px][py]=8;
           a[px][py+1]=8;
           a[px][py+2]=8;
           a[px-1][py+1]=8;
           a[px-1][py+2]=8;
           in[8]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px][py+2]=0;
           a[px-1][py+1]=0;
           a[px-1][py+2]=0;
           in[8]=false;
    }
    
      if(a[px][py+1]==0&&a[px][py+2]==0&&a[px+1][py]==0&&a[px+1][py+1]==0) {
    	   a[px][py]=8;
           a[px][py+1]=8;
           a[px][py+2]=8;
           a[px+1][py]=8;
           a[px+1][py+1]=8;
           in[8]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px][py+2]=0;
           a[px+1][py]=0;
           a[px+1][py+1]=0;
           in[8]=false;
    }
    
      if(a[px][py+1]==0&&a[px+1][py+2]==0&&a[px+1][py+1]==0&&a[px+1][py]==0){
    	   a[px][py]=8;
           a[px][py+1]=8;
           a[px+1][py+2]=8;
           a[px+1][py+1]=8;
           a[px+1][py]=8;
           in[8]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px+1][py+2]=0;
           a[px+1][py+1]=0;
           a[px+1][py]=0;
           in[8]=false;
       } 
    }
    
    //I:8cases
    if(!in[9]){
        
      if(a[px+1][py]==0&&a[px+2][py]==0&&a[px+2][py+1]==0&&a[px+3][py+1]==0){
           a[px][py]=9;
           a[px+1][py]=9;
           a[px+2][py]=9;
           a[px+2][py+1]=9;
           a[px+3][py+1]=9;
           in[9]=true;
           dfs();
           a[px][py]=0;
           a[px+1][py]=0;
           a[px+2][py]=0;
           a[px+2][py+1]=0;
           a[px+3][py+1]=0;
           in[9]=false;
    }
    
      if(a[px-2][py+1]==0&&a[px-1][py+1]==0&&a[px][py+1]==0&&a[px+1][py]==0) {
    	   a[px][py]=9;
           a[px-2][py+1]=9;
           a[px-1][py+1]=9;
           a[px][py+1]=9;
           a[px+1][py]=9;
           in[9]=true;
           dfs();
           a[px][py]=0;
           a[px-2][py+1]=0;
           a[px-1][py+1]=0;
           a[px][py+1]=0;
           a[px+1][py]=0;
           in[9]=false;
    }
    
      if(a[px+1][py]==0&&a[px+1][py+1]==0&&a[px+2][py+1]==0&&a[px+3][py+1]==0){
    	   a[px][py]=9;
           a[px+1][py]=9;
           a[px+1][py+1]=9;
           a[px+2][py+1]=9;
           a[px+3][py+1]=9;
           in[9]=true;
           dfs();
           a[px][py]=0;
           a[px+1][py]=0;
           a[px+1][py+1]=0;
           a[px+2][py+1]=0;
           a[px+3][py+1]=0;
           in[9]=false;
    } 
    
      if(a[px][py+1]==0&&a[px-1][py+1]==0&&a[px-2][py+1]==0&&a[px+1][py]==0){
    	   a[px][py]=9;
           a[px][py+1]=9;
           a[px-1][py+1]=9;
           a[px-2][py+1]=9;
           a[px+1][py]=9;
           in[9]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px-1][py+1]=0;
           a[px-2][py+1]=0;
           a[px+1][py]=0;
           in[9]=false;
    } 
    
      if(a[px][py+1]==0&&a[px+1][py+1]==0&&a[px+1][py+3]==0&&a[px+1][py+2]==0){
    	   a[px][py]=9;
           a[px][py+1]=9;
           a[px+1][py+1]=9;
           a[px+1][py+3]=9;
           a[px+1][py+2]=9;
           in[9]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px+1][py+1]=0;
           a[px+1][py+3]=0;
           a[px+1][py+2]=0;
           in[9]=false;
    }
    
      if(a[px][py+1]==0&&a[px-1][py+1]==0&&a[px-1][py+3]==0&&a[px-1][py+2]==0){
    	   a[px][py]=9;
           a[px][py+1]=9;
           a[px-1][py+1]=9;
           a[px-1][py+3]=9;
           a[px-1][py+2]=9;
           in[9]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px-1][py+1]=0;
           a[px-1][py+3]=0;
           a[px-1][py+2]=0;
           in[9]=false;
    }
    
      if(a[px][py+1]==0&&a[px][py+2]==0&&a[px+1][py+2]==0&&a[px+1][py+3]==0) {
    	   a[px][py]=9;
           a[px][py+1]=9;
           a[px][py+2]=9;
           a[px+1][py+2]=9;
           a[px+1][py+3]=9;
           in[9]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px][py+2]=0;
           a[px+1][py+2]=0;
           a[px+1][py+3]=0;
           in[9]=false;
    }
    
      if(a[px][py+1]==0&&a[px][py+2]==0&&a[px-1][py+2]==0&&a[px-1][py+3]==0) {
    	   a[px][py]=9;
           a[px][py+1]=9;
           a[px][py+2]=9;
           a[px-1][py+2]=9;
           a[px-1][py+3]=9;
           in[9]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px][py+2]=0;
           a[px-1][py+2]=0;
           a[px-1][py+3]=0;
           in[9]=false;
       }
       
    }
    
    //J:1case
    if(!in[10]){
        
      if(a[px][py+1]==0&&a[px][py+2]==0&&a[px-1][py+1]==0&&a[px+1][py+1]==0) {
           a[px][py]=10;
           a[px][py+1]=10;
           a[px][py+2]=10;
           a[px-1][py+1]=10;
           a[px+1][py+1]=10;
           in[10]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px][py+2]=0;
           a[px-1][py+1]=0;
           a[px+1][py+1]=0;
           in[10]=false;
      }
      
    }
    
    //K:4cases
    if(!in[11]){
        
      if(a[px][py+1]==0&&a[px+1][py+1]==0&&a[px+1][py+2]==0&&a[px+2][py+2]==0) {
           a[px][py]=11;
           a[px][py+1]=11;
           a[px+1][py+1]=11;
           a[px+1][py+2]=11;
           a[px+2][py+2]=11;
           in[11]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px+1][py+1]=0;
           a[px+1][py+2]=0;
           a[px+2][py+2]=0;
           in[11]=false;
    }
    
      if(a[px][py+1]==0&&a[px-1][py+1]==0&&a[px-1][py+2]==0&&a[px-2][py+2]==0) {
           a[px][py]=11;
           a[px][py+1]=11;
           a[px-1][py+1]=11;
           a[px-1][py+2]=11;
           a[px-2][py+2]=11;
           in[11]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px-1][py+1]=0;
           a[px-1][py+2]=0;
           a[px-2][py+2]=0;
           in[11]=false;
    }
    
      if(a[px+1][py]==0&&a[px+1][py+1]==0&&a[px+2][py+1]==0&&a[px+2][py+2]==0){
    	   a[px][py]=11;
           a[px+1][py]=11;
           a[px+1][py+1]=11;
           a[px+2][py+1]=11;
           a[px+2][py+2]=11;
           in[11]=true;
           dfs();
           a[px][py]=0;
           a[px+1][py]=0;
           a[px+1][py+1]=0;
           a[px+2][py+1]=0;
           a[px+2][py+2]=0;
           in[11]=false;
    }
    
      if(a[px+1][py]==0&&a[px][py+1]==0&&a[px-1][py+1]==0&&a[px-1][py+2]==0){
    	   a[px][py]=11;
           a[px][py+1]=11;
           a[px+1][py]=11;
           a[px-1][py+1]=11;
           a[px-1][py+2]=11;
           in[11]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px+1][py]=0;
           a[px-1][py+1]=0;
           a[px-1][py+2]=0;
           in[11]=false;
       }
       
    }
    
    //L:8cases
    if(!in[12]){
        
      if(a[px][py+1]==0&&a[px+1][py]==0&&a[px+2][py]==0&&a[px+3][py]==0) {
           a[px][py]=12;
           a[px][py+1]=12;
           a[px+1][py]=12;
           a[px+2][py]=12;
           a[px+3][py]=12;
           in[12]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px+1][py]=0;
           a[px+2][py]=0;
           a[px+3][py]=0;
           in[12]=false;
    }
    
      if(a[px+3][py+1]==0&&a[px+1][py]==0&&a[px+2][py]==0&&a[px+3][py]==0){
    	   a[px][py]=12;
           a[px+3][py+1]=12;
           a[px+1][py]=12;
           a[px+2][py]=12;
           a[px+3][py]=12;
           in[12]=true;
           dfs();
           a[px][py]=0;
           a[px+3][py+1]=0;
           a[px+1][py]=0;
           a[px+2][py]=0;
           a[px+3][py]=0;
           in[12]=false;
    } 
    
      if(a[px][py+1]==0&&a[px+1][py+1]==0&&a[px+2][py+1]==0&&a[px+3][py+1]==0){
    	   a[px][py]=12;
           a[px][py+1]=12;
           a[px+1][py+1]=12;
           a[px+2][py+1]=12;
           a[px+3][py+1]=12;
           in[12]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px+1][py+1]=0;
           a[px+2][py+1]=0;
           a[px+3][py+1]=0;
           in[12]=false;
    } 
    
      if(a[px][py+1]==0&&a[px-1][py+1]==0&&a[px-2][py+1]==0&&a[px-3][py+1]==0){
    	   a[px][py]=12;
           a[px][py+1]=12;
           a[px-1][py+1]=12;
           a[px-2][py+1]=12;
           a[px-3][py+1]=12;
           in[12]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px-1][py+1]=0;
           a[px-2][py+1]=0;
           a[px-3][py+1]=0;
           in[12]=false;
    }
    
      if(a[px+1][py]==0&&a[px+1][py+1]==0&&a[px+1][py+2]==0&&a[px+1][py+3]==0) {
    	   a[px][py]=12;
           a[px+1][py]=12;
           a[px+1][py+1]=12;
           a[px+1][py+2]=12;
           a[px+1][py+3]=12;
           in[12]=true;
           dfs();
           a[px][py]=0;
           a[px+1][py]=0;
           a[px+1][py+1]=0;
           a[px+1][py+2]=0;
           a[px+1][py+3]=0;
           in[12]=false;
    }
    
      if(a[px+1][py]==0&&a[px][py+1]==0&&a[px][py+2]==0&&a[px][py+3]==0){
    	   a[px][py]=12;
           a[px][py+1]=12;
           a[px+1][py]=12;
           a[px][py+2]=12;
           a[px][py+3]=12;
           in[12]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px+1][py]=0;
           a[px][py+2]=0;
           a[px][py+3]=0;
           in[12]=false;
    } 
    
      if(a[px][py+1]==0&&a[px][py+2]==0&&a[px][py+3]==0&&a[px+1][py+3]==0) {
    	   a[px][py]=12;
           a[px][py+1]=12;
           a[px][py+2]=12;
           a[px][py+3]=12;
           a[px+1][py+3]=12;
           in[12]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px][py+2]=0;
           a[px][py+3]=0;
           a[px+1][py+3]=0;
           in[12]=false;
    }
    
      if(a[px][py+1]==0&&a[px][py+2]==0&&a[px][py+3]==0&&a[px-1][py+3]==0) {
    	   a[px][py]=12;
           a[px][py+1]=12;
           a[px][py+2]=12;
           a[px][py+3]=12;
           a[px-1][py+3]=12;
           in[12]=true;
           dfs();
           a[px][py]=0;
           a[px][py+1]=0;
           a[px][py+2]=0;
           a[px][py+3]=0;
           a[px-1][py+3]=0;
           in[12]=false;
       }
       
    }
    
}

void openfile(){
    freopen("game.in","r",stdin);
    freopen("game.out","w",stdout);
}

int main(){
    //openfile();
    init();
    dfs();
    printf("No solution");
    return 0;
}
~~~

恭喜你彻底农烂

---

## 作者：hl666 (赞：96)

国内少有的可以练习神仙算法——**DLX**的好题怎么可以被爆搜埋没呢？

看到这题没有DLX的题解所以写一篇，不过貌似我实现的太弱（构图太慢）所以速度上不是很快。

下面开始讲题，但请保证你要先学会DLX。（[dalao写的超详细DLX](https://www.cnblogs.com/grenet/p/3145800.html)）

首先仔细阅读一遍题目，我们可以大致整理出题意：**用$12$块拼图填满一个$10$行的三角形图案**

稍微分析下性质发现我们其实只要满足：**每个位置都有拼图**和**每种拼图都出现了$1$次**即可。

所以类似于数独我们可以把它转化为一个**精确覆盖问题**：

行表示任意一种颜色的珠子**不同**放置（任意一个位置不同都算作不同）

有$55+12=67$列。前$55$列表示每一个位置都要有珠子，后$12$列要求每种颜色的珠子都要有。

考虑建图，由于数据范围实在很小，我们可以直接暴力搞。

对于每一种颜色，先**手动**打表求出每一个珠子关于一个珠子的**相对坐标**差值。

然后直接枚举位置？但是这样并没有包括**旋转**和**翻转**的情况，难道还要打一个$8$倍的表？

没必要，我们可以直接枚举坐标优先加到横坐标还是纵坐标，同时枚举一下每次的正负号即可（这个具体看代码吧，很好理解的）

所以这个问题就被我们转化为了一个$2730$行，$67$列，$1$的个数为$15084$的精确覆盖问题了。直接上DLX即可。

值得一提的是作为正解的DLX码量远远小于爆搜。（我写了加上注释$106$行，而且大括号都换行了）

CODE

```cpp
#include<cstdio>
#include<cstring>
#define RI register int
#define CI const int&
#define Ms(f,x) memset(f,x,sizeof(f))
using namespace std;
const int N=15,multag[2]={-1,1};
const int length[12]={3,4,4,4,5,5,5,5,5,5,5,5}; //length of shapes
const int table[12][5][2]= //direction of shapes
{
    {{0,0},{1,0},{0,1}}, //A
    {{0,0},{0,1},{0,2},{0,3}}, //B
    {{0,0},{1,0},{0,1},{0,2}}, //C
    {{0,0},{1,0},{0,1},{1,1}}, //D
    {{0,0},{1,0},{2,0},{2,1},{2,2}}, //E
    {{0,0},{0,1},{1,1},{0,2},{0,3}}, //F
    {{0,0},{1,0},{0,1},{0,2},{1,2}}, //G
    {{0,0},{1,0},{0,1},{1,1},{0,2}}, //H
    {{0,0},{0,1},{0,2},{1,2},{1,3}}, //I
    {{0,0},{-1,1},{0,1},{1,1},{0,2}}, //J
    {{0,0},{1,0},{1,1},{2,1},{2,2}}, //K
    {{0,0},{1,0},{0,1},{0,2},{0,3}}, //L
};
const int numx[56]={0,1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10};
const int numy[56]={0,1,1,2,1,2,3,1,2,3,4,1,2,3,4,5,1,2,3,4,5,6,1,2,3,4,5,6,7,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,10};
int tx[2],nx[2],num[N][N],id[2750],numrow,numcol; char puzzle[N][N]; bool vis[N];
class Dancing_Links_AlgorithmX
{
    private:
        static const int N=2750,M=80,ALL=15100;
        int n,m,tot,L[ALL],R[ALL],U[ALL],D[ALL],Row[ALL],Col[ALL],H[N],S[M];
        #define Dance(i,A,s) for (i=A[s];i!=s;i=A[i])
        inline void remove(CI c)
        {
            L[R[c]]=L[c]; R[L[c]]=R[c]; RI i,j;
            Dance(i,D,c) Dance(j,R,i)
            U[D[j]]=U[j],D[U[j]]=D[j],--S[Col[j]];
        }
        inline void resume(CI c)
        {
            RI i,j; Dance(i,U,c) Dance(j,L,i)
            ++S[Col[U[D[j]]=D[U[j]]=j]];
            L[R[c]]=R[L[c]]=c;
        }
    public:
        inline void init(CI N,CI M)
        {
            n=N; m=M; for (RI i=0;i<=m;++i)
            S[i]=0,U[i]=D[i]=i,L[i]=i-1,R[i]=i+1;
            R[m]=0; L[0]=m; tot=m; Ms(H,0);
        }
        inline void link(CI r,CI c)
        {
            ++S[Col[++tot]=c]; Row[tot]=r;
            D[tot]=D[c]; U[D[c]]=tot; U[tot]=c; D[c]=tot;
            if (!H[r]) H[r]=L[tot]=R[tot]=tot; else
            R[tot]=R[H[r]],L[R[H[r]]]=tot,L[tot]=H[r],R[H[r]]=tot;
        }
        inline bool DFS(void)
        {
            if (!R[0]) return 1; RI i,j; int now=R[0];
            Dance(i,R,0) if (S[i]<S[now]) now=i;
            remove(now); Dance(i,D,now)
            {
                if (Col[i]<=55) puzzle[numx[Col[i]]][numy[Col[i]]]=id[Row[i]]+'A';
                Dance(j,R,i) remove(Col[j]),(Col[j]<=55)&&(puzzle[numx[Col[j]]][numy[Col[j]]]=id[Row[j]]+'A');
                if (DFS()) return 1; Dance(j,L,i) resume(Col[j]);
            }
            resume(now); return 0;
        }
        #undef Dance
}DLX;
inline void init(void)
{
    RI i,j; for (i=1;i<=10;++i) for (j=1;j<=i;++j) if (puzzle[i][j]!='.') vis[puzzle[i][j]-'A']=1;
    for (i=1;i<=10;++i) for (j=1;j<=i;++j) num[i][j]=++numcol; DLX.init(2730,numcol+12);
}
int main()
{
    //freopen("CODE.in","r",stdin); freopen("CODE.out","w",stdout);
    RI i; for (i=1;i<=10;++i) scanf("%s",puzzle[i]+1);
    //build excat cover model
    init(); for (RI cases=0,mx;cases<12;++cases)
    for (++numcol,mx=0;mx<2;++mx) for (RI dx=0;dx<2;++dx) for (RI dy=0;dy<2;++dy)
    for (tx[0]=1;tx[0]<=10;++tx[0]) for (tx[1]=1;tx[1]<=tx[0];++tx[1])
    {
        RI k; bool flag=1; for (k=0;k<length[cases];++k)
        {
            nx[mx]=tx[mx]+multag[dx]*table[cases][k][0];
            nx[mx^1]=tx[mx^1]+multag[dy]*table[cases][k][1];
            if (vis[cases]) { if (puzzle[nx[0]][nx[1]]!=cases+'A') { flag=0; break; } }
            else if (puzzle[nx[0]][nx[1]]!='.') { flag=0; break; }
        }
        if (!flag) continue; id[++numrow]=cases; DLX.link(numrow,numcol);
        for (k=0;k<length[cases];++k)
        {
            nx[mx]=tx[mx]+multag[dx]*table[cases][k][0];
            nx[mx^1]=tx[mx^1]+multag[dy]*table[cases][k][1];
            DLX.link(numrow,num[nx[0]][nx[1]]);
        }
    }
    //use Dancing Links to find solution
    if (!DLX.DFS()) return puts("No solution"),0;
    for (i=1;i<=10;++i,putchar('\n')) for (RI j=1;j<=i;++j)
    putchar(puzzle[i][j]); return 0;
}
```



---

## 作者：囧仙 (赞：24)

## 题目大意

用$12$种智慧珠组成的零件，填充$10\times 10$的三角形空白。

## 题解

楼上的代码都好长呀……这里提供一个非常简短的做法。既可大大减少码量，又可减少因为写错代码而导致的巨大的时间浪费。

虽然智慧珠形态迥异，但我们能够发现，每一个零件都是联通的（废话）。因而，假如我们随便取了零件的某个珠子，可以通过这个珠子**上下左右移动**，来还原出整个零件。

比如$\textbf{零件H}$：
  
$$\begin{matrix}\bigcirc-\kern{-12pt}&\bigcirc-\kern{-12pt}&\bigcirc \cr|&|\cr\bigcirc-\kern{-12pt}&\bigcirc \cr\end{matrix}$$

假如我们取左上角的点作为起始点，用$\tt "URDL"$分别表示上、右、下、左，那么这个零件就可以非常简单地表示为$\tt"DRUR"$。特别地，我们可以**任取**起始点，因为无论取哪个点，最终都能还原出整个零件，结果相同。

但我们可能遇到类似$\textbf{零件J}$的困难：

$$\begin{matrix}&\bigcirc \cr&|\cr\bigcirc-\kern{-12pt}&\bigcirc-\kern{-12pt}&\bigcirc \cr&|\cr&\bigcirc\end{matrix}$$

我们无法避免经过重复的格子。这使得我们需要进行去重操作。事实上，可以引入一个新的指令$\verb!'<'!$，表示**回到上一个位置**。那么，如果我们取左侧的点作为起始点，$\textbf{零件J}$就能够表示为$\verb!"RU<D<R"!$。不重复之前经过的点，就可以避免去重这个问题了。

通过这种方式处理十二个零件，就可以大大减少码量。我们设起始点坐标为$(0,0)$，根据上述描述的指令进行遍历，就能求出每个零件。选取**左上角**，计算出剩余部分的**相对坐标**。

接着我们还需要处理一个棘手的问题：零件可以**旋转**，**翻转**。

事实上，这个问题可以很容易地解决。假如，我们将**上看成右**，**右看成下**，**下看成左**，**左看成上**，重新进行构造，就相当于进行了$90\degree$旋转，同理可以旋转$180\degree,270\degree$；翻转只要将上下颠倒就行了，即将上看成下，下看成上。有些零件并不需要处理过多的旋转、翻转操作。我们可以用常量数组存储需要进行哪些操作。

处理完存储$12$个零件的问题，剩下来的事情就是暴力搜索了。我们从上到下，从左到右考虑每个格子。枚举这个格子选择哪个零件，并进行深搜。之所以上文要以左上角作为参考点，就是为了防止填充的零件影响到之前搜索的点。如果需要影响到前面的点，那么前面的点就需要考虑**不填充零件**这一种特殊情况，无疑大大增加了枚举的复杂度。

此外，使用指针等方式，还可以进一步缩小码量。最终，这一道码农题就成功被我们用$2\rm kB$左右的代码写完了。

## 参考代码

```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define up(l,r,i) for(int i=l;i<=r;i++)
#define dn(l,r,i) for(int i=l;i>=r;i--)
#define mkp(x,y) make_pair(x,y)
using namespace std;
typedef unsigned long long u64;
const int INF =2147483647;
const int N =10+3,S=8+3,M=64+3;
const char P[][S]={"","AB","BBB","ABB","ABC","CCBB","BC<BB",
                     "ABBC","CBAB","BBCB","BA<C<B","CBCB","ABBB"};
const int Q[]={0,3,1,7,0,3,7,3,7,7,0,3,7};
const int dir[4][2]={{-1,0},{0,1},{1,0},{0,-1}};
int X[M],Y[M],tot,B[N][N]; bool flg,V[N];
int W[N][N][S][2],num,T[N][S];
void iit(){
    int x,y,tx,ty,(*w)[2],d,t,o,ox,oy;
    up(1,12,i) up(0,Q[i],j){
        x=y=tx=ty=0,w=W[i][j],t=1,o=(j>3?-1:1);
        for(const char *p=P[i];*p;++p){
            if(*p=='<') x=ox,y=oy; else
            d=(*p+j)&3,ox=x,oy=y,x+=dir[d][0]*o,y+=dir[d][1];
            w[++t][0]=x,w[t][1]=y;
            if(x<=tx) ty=(x<tx?y:min(y,ty)),tx=x;
        }
        up(1,t,k) w[k][0]-=tx,w[k][1]-=ty; T[i][j]=t;
    }
}
int _;
void dfs(int u){
    if((++_)>5e6){puts("No solution"),exit(0);}
    int x=X[u],y=Y[u];  if(B[x][y]) dfs(u+1); else
    up(1,12,i) if(!V[i]) up(0,Q[i],j){
        bool flg=1; int (*w)[2]=W[i][j],t=T[i][j];
        up(1,t,k){
            int nx=x+w[k][0],ny=y+w[k][1];
            if(nx>9||ny<0||ny>nx||B[nx][ny]){flg=0;break;}
        }
        if(!flg) continue;
        up(1,t,k) B[w[k][0]+x][w[k][1]+y]=i;
        ++num,V[i]=true; if(num==12){
            up(0,9,a) up(0,a+1,b) putchar(b==a+1?'\n':'A'+B[a][b]-1);
            exit(0);
        } else dfs(u+1),--num,V[i]=false;
        up(1,t,k) B[w[k][0]+x][w[k][1]+y]=0;
    }
}
char readc(){
    char c; while(!isalpha(c=getchar())&&c!='.'); return c;
}
int main(){
    iit(); up(0,9,i) up(0,i,j){
        char t=readc(); if(t!='.') B[i][j]=t-'A'+1,V[t-'A'+1]=true;
        X[++tot]=i,Y[tot]=j;
    }
    up(1,12,i) if(V[i]) ++num; dfs(1); puts("No solution");
    return 0;
}
```

---

## 作者：λᴉʍ (赞：19)

难度普及。  
暴力枚举所有情况（huaji  
强行安利 http://www.cnblogs.com/xzz_233/p/bzoj1501.html

```cpp
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<cstring>
using namespace std;
#define rep(a,b,c) for(rg int a=b;a<=c;a++)
#define drep(a,b,c) for(rg int a=b;a>=c;a--)
#define erep(a,b) for(rg int a=fir[b];a;a=nxt[a])
#define il inline
#define rg register
#define vd void
#define ok =='.'
#define st =ch
#define fr ='.'
#define can(a) (yes[a])
#define disable(a) yes[a]=0
#define able(a) yes[a]=1
#define nxt x,y+1
typedef long long ll;
il int gi(){
    rg int x=0;bool flg=0;rg char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')flg=1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return flg?-x:x;
}
const int n=10,m=12;
char s[233][233];
bool yes[233];
bool vis[20][20];
il int dfs(int x,int y){
    if(vis[x][y])return 0;
    vis[x][y]=1;
    if(s[x][y]!='.')return 0;
    return 1+dfs(x+1,y)+dfs(x-1,y)+dfs(x,y+1)+dfs(x,y-1);
}
il vd Init(){
    memset(s,'X',sizeof s);
    rep(i,1,n)scanf("%s",s[i]+1);
    rep(i,0,n+1)s[i][0]='X';
    rep(i,0,n+1)s[i][i+1]='X';
    rep(i,0,n+1)s[n+1][i]='X';
    rep(i,'A','L')yes[i]=1;
    rep(i,1,n)rep(j,1,i)if(!(s[i][j]ok))yes[s[i][j]]=0;
    rep(i,1,n)rep(j,1,i)if(s[i][j]ok&&!vis[i][j]&&dfs(i,j)<3){puts("No solution");exit(0);}
}
il vd Dfs(int x,int y){
    if(x==n+1){
        rep(i,1,n){
            rep(j,1,i)putchar(s[i][j]);
            puts("");
        }exit(0);
    }
    if(y==x+1){Dfs(x+1,1);return;}
    if(!(s[x][y]ok)){Dfs(nxt);return;}
    char ch;
    ch='B';
    if(can(ch)){
        disable(ch);s[x][y]st;
        if(s[x+1][y]ok&&s[x+2][y]ok&&s[x+3][y]ok){
            s[x+1][y]st,s[x+2][y]st,s[x+3][y]st,Dfs(nxt);
            s[x+1][y]fr,s[x+2][y]fr,s[x+3][y]fr;
        }
        if(s[x][y+1]ok&&s[x][y+2]ok&&s[x][y+3]ok){
            s[x][y+1]st,s[x][y+2]st,s[x][y+3]st,Dfs(nxt);
            s[x][y+1]fr,s[x][y+2]fr,s[x][y+3]fr;
        }
        s[x][y]fr;able(ch);
    }
    ch='C';
    if(can(ch)){
        disable(ch);s[x][y]st;
        if(s[x+1][y]ok&&s[x+2][y]ok&&s[x][y+1]ok){
            s[x+1][y]st,s[x+2][y]st,s[x][y+1]st,Dfs(nxt);
            s[x+1][y]fr,s[x+2][y]fr,s[x][y+1]fr;
        }
        if(s[x+1][y]ok&&s[x+2][y]ok&&s[x+2][y+1]ok){
            s[x+1][y]st,s[x+2][y]st,s[x+2][y+1]st,Dfs(nxt);
            s[x+1][y]fr,s[x+2][y]fr,s[x+2][y+1]fr;
        }
        if(s[x][y+1]ok&&s[x][y+2]ok&&s[x+1][y]ok){
            s[x][y+1]st,s[x][y+2]st,s[x+1][y]st,Dfs(nxt);
            s[x][y+1]fr,s[x][y+2]fr,s[x+1][y]fr;
        }
        if(s[x][y+1]ok&&s[x][y+2]ok&&s[x+1][y+2]ok){
            s[x][y+1]st,s[x][y+2]st,s[x+1][y+2]st,Dfs(nxt);
            s[x][y+1]fr,s[x][y+2]fr,s[x+1][y+2]fr;
        }
        if(s[x][y+1]ok&&s[x+1][y+1]ok&&s[x+2][y+1]ok){
            s[x][y+1]st,s[x+1][y+1]st,s[x+2][y+1]st,Dfs(nxt);
            s[x][y+1]fr,s[x+1][y+1]fr,s[x+2][y+1]fr;
        }
        if(s[x+1][y]ok&&s[x+2][y]ok&&s[x+2][y-1]ok){
            s[x+1][y]st,s[x+2][y]st,s[x+2][y-1]st,Dfs(nxt);
            s[x+1][y]fr,s[x+2][y]fr,s[x+2][y-1]fr;
        }
        if(y>2&&s[x+1][y]ok&&s[x+1][y-1]ok&&s[x+1][y-2]ok){
            s[x+1][y]st,s[x+1][y-1]st,s[x+1][y-2]st,Dfs(nxt);
            s[x+1][y]fr,s[x+1][y-1]fr,s[x+1][y-2]fr;
        }
        s[x][y]fr;able(ch);
    }
    ch='D';
    if(can(ch)){
        disable(ch);s[x][y]st;
        if(s[x+1][y]ok&&s[x+1][y+1]ok&&s[x][y+1]ok){
            s[x+1][y]st,s[x+1][y+1]st,s[x][y+1]st,Dfs(nxt);
            s[x+1][y]fr,s[x+1][y+1]fr,s[x][y+1]fr;
        }
        s[x][y]fr;able(ch);
    }
    ch='E';
    if(can(ch)){
        disable(ch);s[x][y]st;
        if(s[x+1][y]ok&&s[x+2][y]ok&&s[x][y+1]ok&&s[x][y+2]ok){
            s[x+1][y]st,s[x+2][y]st,s[x][y+1]st,s[x][y+2]st,Dfs(nxt);
            s[x+1][y]fr,s[x+2][y]fr,s[x][y+1]fr,s[x][y+2]fr;
        }
        if(s[x+1][y]ok&&s[x+2][y]ok&&s[x+2][y+1]ok&&s[x+2][y+2]ok){
            s[x+1][y]st,s[x+2][y]st,s[x+2][y+1]st,s[x+2][y+2]st,Dfs(nxt);
            s[x+1][y]fr,s[x+2][y]fr,s[x+2][y+1]fr,s[x+2][y+2]fr;
        }
        if(s[x+1][y+2]ok&&s[x+2][y+2]ok&&s[x][y+1]ok&&s[x][y+2]ok){
            s[x+1][y+2]st,s[x+2][y+2]st,s[x][y+1]st,s[x][y+2]st,Dfs(nxt);
            s[x+1][y+2]fr,s[x+2][y+2]fr,s[x][y+1]fr,s[x][y+2]fr;
        }
        if(s[x+1][y]ok&&s[x+2][y]ok&&s[x+2][y-1]ok&&s[x+2][y-2]ok){
            s[x+1][y]st,s[x+2][y]st,s[x+2][y-1]st,s[x+2][y-2]st,Dfs(nxt);
            s[x+1][y]fr,s[x+2][y]fr,s[x+2][y-1]fr,s[x+2][y-2]fr;
        }
        s[x][y]fr;able(ch);
    }
    ch='G';
    if(can(ch)){
        disable(ch);s[x][y]st;
        if(s[x+1][y]ok&&s[x][y+1]ok&&s[x][y+2]ok&&s[x+1][y+2]ok){
            s[x+1][y]st,s[x][y+1]st,s[x][y+2]st,s[x+1][y+2]st,Dfs(nxt);
            s[x+1][y]fr,s[x][y+1]fr,s[x][y+2]fr,s[x+1][y+2]fr;
        }
        if(s[x+1][y]ok&&s[x+1][y+1]ok&&s[x][y+2]ok&&s[x+1][y+2]ok){
            s[x+1][y]st,s[x+1][y+1]st,s[x][y+2]st,s[x+1][y+2]st,Dfs(nxt);
            s[x+1][y]fr,s[x+1][y+1]fr,s[x][y+2]fr,s[x+1][y+2]fr;
        }
        if(s[x][y+1]ok&&s[x+1][y+1]ok&&s[x+2][y+1]ok&&s[x+2][y]ok){
            s[x][y+1]st,s[x+1][y+1]st,s[x+2][y+1]st,s[x+2][y]st,Dfs(nxt);
            s[x][y+1]fr,s[x+1][y+1]fr,s[x+2][y+1]fr,s[x+2][y]fr;
        }
        if(s[x][y+1]ok&&s[x+1][y]ok&&s[x+2][y+1]ok&&s[x+2][y]ok){
            s[x][y+1]st,s[x+1][y]st,s[x+2][y+1]st,s[x+2][y]st,Dfs(nxt);
            s[x][y+1]fr,s[x+1][y]fr,s[x+2][y+1]fr,s[x+2][y]fr;
        }
        s[x][y]fr;able(ch);
    }
    ch='H';
    if(can(ch)){
        disable(ch);s[x][y]st;
        if(s[x+1][y]ok&&s[x+1][y+1]ok&&s[x][y+1]ok&&s[x][y+2]ok){
            s[x+1][y]st,s[x+1][y+1]st,s[x][y+1]st,s[x][y+2]st,Dfs(nxt);
            s[x+1][y]fr,s[x+1][y+1]fr,s[x][y+1]fr,s[x][y+2]fr;
        }
        if(s[x+1][y]ok&&s[x+1][y+1]ok&&s[x][y+1]ok&&s[x+1][y+2]ok){
            s[x+1][y]st,s[x+1][y+1]st,s[x][y+1]st,s[x+1][y+2]st,Dfs(nxt);
            s[x+1][y]fr,s[x+1][y+1]fr,s[x][y+1]fr,s[x+1][y+2]fr;
        }
        if(s[x+1][y]ok&&s[x+1][y+1]ok&&s[x][y+1]ok&&s[x+2][y]ok){
            s[x+1][y]st,s[x+1][y+1]st,s[x][y+1]st,s[x+2][y]st,Dfs(nxt);
            s[x+1][y]fr,s[x+1][y+1]fr,s[x][y+1]fr,s[x+2][y]fr;
        }
        if(s[x+1][y]ok&&s[x+1][y+1]ok&&s[x][y+1]ok&&s[x+2][y+1]ok){
            s[x+1][y]st,s[x+1][y+1]st,s[x][y+1]st,s[x+2][y+1]st,Dfs(nxt);
            s[x+1][y]fr,s[x+1][y+1]fr,s[x][y+1]fr,s[x+2][y+1]fr;
        }
        if(s[x+1][y]ok&&s[x+1][y+1]ok&&s[x][y+1]ok&&s[x+1][y-1]ok){
            s[x+1][y]st,s[x+1][y+1]st,s[x][y+1]st,s[x+1][y-1]st,Dfs(nxt);
            s[x+1][y]fr,s[x+1][y+1]fr,s[x][y+1]fr,s[x+1][y-1]fr;
        }
        if(s[x+1][y]ok&&s[x+2][y]ok&&s[x+1][y+1]ok&&s[x+2][y+1]ok){
            s[x+1][y]st,s[x+2][y]st,s[x+1][y+1]st,s[x+2][y+1]st,Dfs(nxt);
            s[x+1][y]fr,s[x+2][y]fr,s[x+1][y+1]fr,s[x+2][y+1]fr;
        }
        if(s[x+1][y]ok&&s[x+2][y]ok&&s[x+1][y-1]ok&&s[x+2][y-1]ok){
            s[x+1][y]st,s[x+2][y]st,s[x+1][y-1]st,s[x+2][y-1]st,Dfs(nxt);
            s[x+1][y]fr,s[x+2][y]fr,s[x+1][y-1]fr,s[x+2][y-1]fr;
        }
        if(s[x][y+1]ok&&s[x+1][y+1]ok&&s[x][y+2]ok&&s[x+1][y+2]ok){
            s[x][y+1]st,s[x+1][y+1]st,s[x][y+2]st,s[x+1][y+2]st,Dfs(nxt);
            s[x][y+1]fr,s[x+1][y+1]fr,s[x][y+2]fr,s[x+1][y+2]fr;
        }
        s[x][y]fr;able(ch);
    }
    ch='A';
    if(can(ch)){
        disable(ch);s[x][y]st;
        if(s[x+1][y]ok&&s[x][y+1]ok){
            s[x+1][y]st,s[x][y+1]st,Dfs(nxt);
            s[x+1][y]fr,s[x][y+1]fr;
        }
        if(s[x+1][y+1]ok&&s[x][y+1]ok){
            s[x+1][y+1]st,s[x][y+1]st,Dfs(nxt);
            s[x+1][y+1]fr,s[x][y+1]fr;
        }
        if(s[x+1][y]ok&&s[x+1][y+1]ok){
            s[x+1][y]st,s[x+1][y+1]st,Dfs(nxt);
            s[x+1][y]fr,s[x+1][y+1]fr;
        }
        if(s[x+1][y]ok&&s[x+1][y-1]ok){
            s[x+1][y]st,s[x+1][y-1]st,Dfs(nxt);
            s[x+1][y]fr,s[x+1][y-1]fr;
        }
        s[x][y]fr;able(ch);
    }
    ch='L';
    if(can(ch)){
        disable(ch);s[x][y]st;
        if(s[x][y+1]ok&&s[x+1][y+1]ok&&s[x+2][y+1]ok&&s[x+3][y+1]ok){
            s[x][y+1]st,s[x+1][y+1]st,s[x+2][y+1]st,s[x+3][y+1]st,Dfs(nxt);
            s[x][y+1]fr,s[x+1][y+1]fr,s[x+2][y+1]fr,s[x+3][y+1]fr;
        }
        if(s[x][y+1]ok&&s[x][y+2]ok&&s[x][y+3]ok&&s[x+1][y+3]ok){
            s[x][y+1]st,s[x][y+2]st,s[x][y+3]st,s[x+1][y+3]st,Dfs(nxt);
            s[x][y+1]fr,s[x][y+2]fr,s[x][y+3]fr,s[x+1][y+3]fr;
        }
        if(s[x+1][y]ok&&s[x+2][y]ok&&s[x+3][y]ok&&s[x+3][y-1]ok){
            s[x+1][y]st,s[x+2][y]st,s[x+3][y]st,s[x+3][y-1]st,Dfs(nxt);
            s[x+1][y]fr,s[x+2][y]fr,s[x+3][y]fr,s[x+3][y-1]fr;
        }
        if(s[x+1][y]ok&&s[x+2][y]ok&&s[x+3][y]ok&&s[x+3][y+1]ok){
            s[x+1][y]st,s[x+2][y]st,s[x+3][y]st,s[x+3][y+1]st,Dfs(nxt);
            s[x+1][y]fr,s[x+2][y]fr,s[x+3][y]fr,s[x+3][y+1]fr;
        }
        if(s[x+1][y]ok&&s[x+1][y+1]ok&&s[x+1][y+2]ok&&s[x+1][y+3]ok){
            s[x+1][y]st,s[x+1][y+1]st,s[x+1][y+2]st,s[x+1][y+3]st,Dfs(nxt);
            s[x+1][y]fr,s[x+1][y+1]fr,s[x+1][y+2]fr,s[x+1][y+3]fr;
        }
        if(s[x+1][y]ok&&s[x+1][y-1]ok&&s[x+1][y-2]ok&&s[x+1][y-3]ok){
            s[x+1][y]st,s[x+1][y-1]st,s[x+1][y-2]st,s[x+1][y-3]st,Dfs(nxt);
            s[x+1][y]fr,s[x+1][y-1]fr,s[x+1][y-2]fr,s[x+1][y-3]fr;
        }
        if(s[x+1][y]ok&&s[x+2][y]ok&&s[x+3][y]ok&&s[x][y+1]ok){
            s[x+1][y]st,s[x+2][y]st,s[x+3][y]st,s[x][y+1]st,Dfs(nxt);
            s[x+1][y]fr,s[x+2][y]fr,s[x+3][y]fr,s[x][y+1]fr;
        }
        if(s[x+1][y]ok&&s[x][y+1]ok&&s[x][y+2]ok&&s[x][y+3]ok){
            s[x+1][y]st,s[x][y+1]st,s[x][y+2]st,s[x][y+3]st,Dfs(nxt);
            s[x+1][y]fr,s[x][y+1]fr,s[x][y+2]fr,s[x][y+3]fr;
        }
        s[x][y]fr;able(ch);
    }
    ch='I';
    if(can(ch)){
        disable(ch);s[x][y]st;
        if(s[x][y+1]ok&&s[x][y+2]ok&&s[x+1][y+2]ok&&s[x+1][y+3]ok){
            s[x][y+1]st,s[x][y+2]st,s[x+1][y+2]st,s[x+1][y+3]st,Dfs(nxt);
            s[x][y+1]fr,s[x][y+2]fr,s[x+1][y+2]fr,s[x+1][y+3]fr;
        }
        if(s[x][y+1]ok&&s[x+1][y+1]ok&&s[x+1][y+2]ok&&s[x+1][y+3]ok){
            s[x][y+1]st,s[x+1][y+1]st,s[x+1][y+2]st,s[x+1][y+3]st,Dfs(nxt);
            s[x][y+1]fr,s[x+1][y+1]fr,s[x+1][y+2]fr,s[x+1][y+3]fr;
        }
        if(s[x+1][y]ok&&s[x+1][y-1]ok&&s[x+2][y-1]ok&&s[x+3][y-1]ok){
            s[x+1][y]st,s[x+1][y-1]st,s[x+2][y-1]st,s[x+3][y-1]st,Dfs(nxt);
            s[x+1][y]fr,s[x+1][y-1]fr,s[x+2][y-1]fr,s[x+3][y-1]fr;
        }
        if(s[x+1][y]ok&&s[x+2][y]ok&&s[x+2][y-1]ok&&s[x+3][y-1]ok){
            s[x+1][y]st,s[x+2][y]st,s[x+2][y-1]st,s[x+3][y-1]st,Dfs(nxt);
            s[x+1][y]fr,s[x+2][y]fr,s[x+2][y-1]fr,s[x+3][y-1]fr;
        }
        if(s[x+1][y]ok&&s[x+1][y+1]ok&&s[x+2][y+1]ok&&s[x+3][y+1]ok){
            s[x+1][y]st,s[x+1][y+1]st,s[x+2][y+1]st,s[x+3][y+1]st,Dfs(nxt);
            s[x+1][y]fr,s[x+1][y+1]fr,s[x+2][y+1]fr,s[x+3][y+1]fr;
        }
        if(s[x+1][y]ok&&s[x+2][y]ok&&s[x+2][y+1]ok&&s[x+3][y+1]ok){
            s[x+1][y]st,s[x+2][y]st,s[x+2][y+1]st,s[x+3][y+1]st,Dfs(nxt);
            s[x+1][y]fr,s[x+2][y]fr,s[x+2][y+1]fr,s[x+3][y+1]fr;
        }
        if(y>1&&s[x][y+1]ok&&s[x+1][y]ok&&s[x+1][y-1]ok&&s[x+1][y-2]ok){
            s[x][y+1]st,s[x+1][y]st,s[x+1][y-1]st,s[x+1][y-2]st,Dfs(nxt);
            s[x][y+1]fr,s[x+1][y]fr,s[x+1][y-1]fr,s[x+1][y-2]fr;
        }
        if(y>1&&s[x][y+1]ok&&s[x][y+2]ok&&s[x+1][y]ok&&s[x+1][y-1]ok){
            s[x][y+1]st,s[x][y+2]st,s[x+1][y]st,s[x+1][y-1]st,Dfs(nxt);
            s[x][y+1]fr,s[x][y+2]fr,s[x+1][y]fr,s[x+1][y-1]fr;
        }
        s[x][y]fr;able(ch);
    }
    ch='J';
    if(can(ch)){
        disable(ch);s[x][y]st;
        if(s[x+1][y]ok&&s[x+1][y+1]ok&&s[x+2][y]ok&&s[x+1][y-1]ok){
            s[x+1][y]st,s[x+1][y+1]st,s[x+2][y]st,s[x+1][y-1]st,Dfs(nxt);
            s[x+1][y]fr,s[x+1][y+1]fr,s[x+2][y]fr,s[x+1][y-1]fr;
        }
        s[x][y]fr;able(ch);
    }
    ch='F';
    if(can(ch)){
        disable(ch);s[x][y]st;
        if(s[x+1][y]ok&&s[x+1][y-1]ok&&s[x+1][y+1]ok&&s[x+1][y+2]ok){
            s[x+1][y]st,s[x+1][y-1]st,s[x+1][y+1]st,s[x+1][y+2]st,Dfs(nxt);
            s[x+1][y]fr,s[x+1][y-1]fr,s[x+1][y+1]fr,s[x+1][y+2]fr;
        }
        if(y>1&&s[x+1][y]ok&&s[x+1][y-1]ok&&s[x+1][y+1]ok&&s[x+1][y-2]ok){
            s[x+1][y]st,s[x+1][y-1]st,s[x+1][y+1]st,s[x+1][y-2]st,Dfs(nxt);
            s[x+1][y]fr,s[x+1][y-1]fr,s[x+1][y+1]fr,s[x+1][y-2]fr;
        }
        if(s[x+1][y]ok&&s[x+1][y+1]ok&&s[x+2][y]ok&&s[x+3][y]ok){
            s[x+1][y]st,s[x+1][y+1]st,s[x+2][y]st,s[x+3][y]st,Dfs(nxt);
            s[x+1][y]fr,s[x+1][y+1]fr,s[x+2][y]fr,s[x+3][y]fr;
        }
        if(s[x+1][y]ok&&s[x+1][y-1]ok&&s[x+2][y]ok&&s[x+3][y]ok){
            s[x+1][y]st,s[x+1][y-1]st,s[x+2][y]st,s[x+3][y]st,Dfs(nxt);
            s[x+1][y]fr,s[x+1][y-1]fr,s[x+2][y]fr,s[x+3][y]fr;
        }
        if(s[x][y+1]ok&&s[x+1][y+1]ok&&s[x][y+2]ok&&s[x][y+3]ok){
            s[x][y+1]st,s[x+1][y+1]st,s[x][y+2]st,s[x][y+3]st,Dfs(nxt);
            s[x][y+1]fr,s[x+1][y+1]fr,s[x][y+2]fr,s[x][y+3]fr;
        }
        if(s[x][y+1]ok&&s[x+1][y+2]ok&&s[x][y+2]ok&&s[x][y+3]ok){
            s[x][y+1]st,s[x+1][y+2]st,s[x][y+2]st,s[x][y+3]st,Dfs(nxt);
            s[x][y+1]fr,s[x+1][y+2]fr,s[x][y+2]fr,s[x][y+3]fr;
        }
        if(s[x+1][y]ok&&s[x+2][y+1]ok&&s[x+2][y]ok&&s[x+3][y]ok){
            s[x+1][y]st,s[x+2][y+1]st,s[x+2][y]st,s[x+3][y]st,Dfs(nxt);
            s[x+1][y]fr,s[x+2][y+1]fr,s[x+2][y]fr,s[x+3][y]fr;
        }
        if(s[x+1][y]ok&&s[x+2][y-1]ok&&s[x+2][y]ok&&s[x+3][y]ok){
            s[x+1][y]st,s[x+2][y-1]st,s[x+2][y]st,s[x+3][y]st,Dfs(nxt);
            s[x+1][y]fr,s[x+2][y-1]fr,s[x+2][y]fr,s[x+3][y]fr;
        }
        s[x][y]fr;able(ch);
    }
    ch='K';
    if(can(ch)){
        disable(ch);s[x][y]st;
        if(s[x+1][y]ok&&s[x+1][y+1]ok&&s[x+2][y+1]ok&&s[x+2][y+2]ok){
            s[x+1][y]st,s[x+1][y+1]st,s[x+2][y+1]st,s[x+2][y+2]st,Dfs(nxt);
            s[x+1][y]fr,s[x+1][y+1]fr,s[x+2][y+1]fr,s[x+2][y+2]fr;
        }
        if(s[x][y+1]ok&&s[x+1][y+1]ok&&s[x+1][y+2]ok&&s[x+2][y+2]ok){
            s[x][y+1]st,s[x+1][y+1]st,s[x+1][y+2]st,s[x+2][y+2]st,Dfs(nxt);
            s[x][y+1]fr,s[x+1][y+1]fr,s[x+1][y+2]fr,s[x+2][y+2]fr;
        }
        if(y>1&&s[x+1][y]ok&&s[x+1][y-1]ok&&s[x+2][y-1]ok&&s[x+2][y-2]ok){
            s[x+1][y]st,s[x+1][y-1]st,s[x+2][y-1]st,s[x+2][y-2]st,Dfs(nxt);
            s[x+1][y]fr,s[x+1][y-1]fr,s[x+2][y-1]fr,s[x+2][y-2]fr;
        }
        if(s[x][y+1]ok&&s[x+1][y]ok&&s[x+1][y-1]ok&&s[x+2][y-1]ok){
            s[x][y+1]st,s[x+1][y]st,s[x+1][y-1]st,s[x+2][y-1]st,Dfs(nxt);
            s[x][y+1]fr,s[x+1][y]fr,s[x+1][y-1]fr,s[x+2][y-1]fr;
        }
        s[x][y]fr;able(ch);
    }
}
int main(){
    Init();
    Dfs(1,1);
    puts("No solution");
    return 0;
}
```

---

## 作者：colemak (赞：10)

先%%%一波巨佬**U62267 BJpers2** 这题是我们一道考试题，考试时候没做出来，以下是巨佬教本蒟蒻的做法，只有180行不到，不需太高码力就可敲出一道货真价实的黑题，黑题啊！！！（人生中第一道黑题）

巨佬的洛谷号https://www.luogu.org/space/show?uid=62267

题目大家应该都能看懂，就是搜索。

首先比较麻烦的就是各种零件可以翻转，旋转，这里我们可以考虑先打表表示出原来的图形，再用函数算出各种变换，注意有些图形可以转不转都一样，要特判处理搜索时节约时间，最后用图的形式存起来完成预处理。

然后就是搜索，讲一下剪枝的小技巧：玩过这种游戏的人大概都体会到那些形状奇奇怪怪的零件最难放进去，所以我们可以规定一个搜索顺序，将难的先搜了剪枝越早越节约时间嘛。然后并查集判联通块，我们发现没有小于3的零件，因此联通块小于3剪掉，没有两个联通块可以拼成6的大小，所以6也剪掉；

最后第8个点还是T了。。因为无解的情况需要全搜一遍最慢。。于是毫无意外地爆炸了。。然后另一位巨佬**U109236 Fuyuki**提出了~~WCX剪枝~~，开一个时间变量，如果时间大于950ms直接输出“No solution”；终于AC;

另一位巨佬的洛谷号https://www.luogu.org/space/show?uid=109236

以下放代码：
```
#include<iostream>
#include<cstdio>
#include<ctime>
#include<cstring>
#include<cstdlib>
#define FOR(i,a,b) for(register int i=a;i<=b;i++)
#define ROF(i,a,b) for(register int i=a;i>=b;i--)
#define TU(x) for(register int k=head[x],v=e[k].to;k;k=e[k].from,v=e[k].to)
using namespace std;
const int N=100,S=5,M=400;
clock_t start,end;
struct Edge
{
	int from,to;
}e[M];//前向星存图
char a[N][S][S]=//打表大法好
{
	{"AA",
	 "A."//0
	},{"BBBB"},//1
	{"CCC",
	 "C.."//2
	},
	{"DD",
	 "DD"//3
	},
	{"E..",
	 "E..",
	 "EEE"//4
	},
	{"FFFF",
	 ".F.."//5
	},
	{"GGG",
	 "G.G"//6
	},
	{"HHH",
	 "HH."	//7
	},
	{"III.",
	 "..II"//8
	},
	{".J.",
	 "JJJ",//9
	 ".J."
	},
	{"K..",
	 "KK.",//10
	 ".KK"
	},
	{"LLLL",
	 "L..."//11
	}
},Map[15][15];
int vis[N],cnt,head[N],f[N],sz[N],cc=12;
int dx[4]={-1,+0,+1,+0},dy[4]={+0,+1,+0,-1};
int r[N]={2,1,2,2,3,2,2,2,2,3,3,2};//每个零件的宽度
int c[N]={2,4,3,2,3,4,3,3,4,3,3,4};//每个零件的长度
int df[12]={9,8,10,6,5,11,7,4,2,0,1,3};//规定搜索顺序，先把难填的填进去，方便剪枝 
void add(int x,int y)//存边
{
	e[++cnt].from=head[x];
	e[cnt].to=y;
	head[x]=cnt;
}
void zhuan(char p[S][S],int x,int y,char q[S][S]){
FOR(i,0,x-1)FOR(j,0,y-1)q[y-j-1][i]=p[i][j];}
//旋转
void fan(char p[S][S],int x,int y,char q[S][S]){
FOR(i,0,x-1)FOR(j,0,y-1)q[i][y-j-1]=p[i][j];}
//对称
inline int g(int x,int y){return (x-1)*10+y;}//二维变一维
int getf(int q){return f[q]==q?q:f[q]=getf(f[q]);}//并查集
void Merge(int x,int y)
{
	int fa=getf(x),fb=getf(y);
	if(fa!=fb)f[fa]=fb,sz[fb]+=sz[fa];//sz数组存联通块大小
}//合并
void dfs(int num)
{
	if(num>=9)
	{
		end=clock();//WeiChenxuan剪枝
		if(double(end-start)/double(CLOCKS_PER_SEC)>=0.9)
		{
			cout<<"No solution"<<endl;
			exit(0);
		}
	}
	int x=df[num];
	if(vis[x])
	{
		dfs(num+1);
		return;
	}
	if(num>11)
	{
		FOR(i,1,10)
		{
			FOR(j,1,i)cout<<Map[i][j];//找到结果，输出
			cout<<endl;
		}
		exit(0);
	}
	FOR(i,1,10)FOR(j,1,i){f[g(i,j)]=g(i,j);sz[g(i,j)]=1;}//并查集初始化
	FOR(i,1,10)FOR(j,1,i)
	if(Map[i][j]=='.')FOR(k,0,3)
	{
		int nx=i+dx[k],ny=j+dy[k];//判联通块
		if(Map[nx][ny]=='.')Merge(g(i,j),g(nx,ny));
	}
	FOR(i,1,10)FOR(j,1,i)if(Map[i][j]=='.')
	{
		int ss=sz[getf(g(i,j))];//利用联通块大小剪枝
		if(ss<3 || ss==6)return;
	}
	TU(x)
	{
		FOR(i,1,10)FOR(j,1,i)
		{
			bool ok=1;
			FOR(p,0,r[v]-1)
			{
				FOR(q,0,c[v]-1)
					if(a[v][p][q]>='A' && a[v][p][q]<='L' && Map[i+p][j+q]!='.')
					{ok=0;break;}//判断能否放入
				if(!ok)break;
			}
			if(ok)
			{
				FOR(p,0,r[v]-1)FOR(q,0,c[v]-1)
				if(a[v][p][q]!='.')Map[i+p][j+q]=a[v][p][q];
				dfs(num+1);
				FOR(p,0,r[v]-1)FOR(q,0,c[v]-1)
				if(a[v][p][q]!='.')Map[i+p][j+q]='.';
			}
		}
	}
}
int main()
{
	FOR(i,0,11)
	{
		zhuan(a[i],r[i],c[i],a[++cc]);//左转90°
		r[cc]=c[i];c[cc]=r[i];
		zhuan(a[cc],r[cc],c[cc],a[cc+1]);//左转180°
		r[++cc]=r[i];c[cc]=c[i];
		zhuan(a[cc],r[cc],c[cc],a[cc+1]);//左转270°=右转90°
		r[++cc]=c[i];c[cc]=r[i];
		add(i,i);
		if(i==3 || i==9)continue;
		add(i,cc-2);
		if(i==1)continue;
		add(i,cc-1);add(i,cc);
		if(i==0 || i==4 || i==10 || i==6)continue;
		int t0=i,t1=cc,t2=cc-2,t3=cc-1;
		fan(a[t0],r[t0],c[t0],a[++cc]);//原图对称
		r[cc]=r[t0];c[cc]=c[t0];
		fan(a[t1],r[t1],c[t1],a[++cc]);//左转后对称
		r[cc]=r[t1];c[cc]=c[t1];
		fan(a[t2],r[t2],c[t2],a[++cc]);//180后对称
		r[cc]=r[t2];c[cc]=c[t2];
		fan(a[t3],r[t3],c[t3],a[++cc]);//右转后对称
		r[cc]=r[t3];c[cc]=c[t3];
		add(i,cc);add(i,cc-1);add(i,cc-2);add(i,cc-3);
	}char ch;
	FOR(i,1,15)FOR(j,1,15)Map[i][j]='#';
	FOR(i,1,10)
	FOR(j,1,i)
	{
		ch=getchar();while(ch!='.' && (ch<'A' || ch>'L'))ch=getchar();//强行快读
		Map[i][j]=ch;
		if(ch!='.')vis[ch-'A']=1;
	}
	start=clock();
	dfs(0);
	cout<<"No solution"<<endl;
	return 0;
}
```

---

## 作者：ljc1301 (赞：6)

这题可以考虑一下DLX（请确保您了解[DLX](https://www.luogu.org/problemnew/show/P4929)，会写或者~~像我一样~~了解思想并且能照着~~抄~~打一遍）

我们知道，DLX是用来解决精准覆盖问题的，然后这题似乎很容易转换为一个精准覆盖问题。

我们要达成的目标就是把55个格子填满，且不重复，于是有55列，分别表示55个格子，然后还有许多行，每一行表示一个零件的一种可能的摆放。

还有个问题，我们还要保证每一个零件只用一次，考虑再加12个列，表示12个零件，然后每一行在对应的列上再加一个1即可。

而对于已经确定摆放的零件，我们这个零件就只加一行；然后注意其他零件是不能放在这些已经确定的零件上，有接触到就不能加进去（理论上加进去也没事，不过这样可以卡一点点的常数）。

对于一些零件，转180度和原来一样，或者转90度和原来一样；还有翻转后和原来的旋转后一样的。这最好是不要重复地加进去。

最后根据选了那些行填出答案。

这样，用DLX不加其他任何东西就能过。

具体实现细节参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxr=55*12*8;
const int maxn=68;
const int maxnode=maxr*6;
// DLX板子
struct DLX
{
	int n,sz,S[maxn],row[maxnode],col[maxnode];
	int L[maxnode],R[maxnode],U[maxnode],D[maxnode];
	int ansd,ans[maxr];
	void init(int n)
	{
		this->n=n;
		for(int i=0;i<=n;i++)
		{
			U[i]=i; D[i]=i; L[i]=i-1; R[i]=i+1;
		}
		R[n]=0; L[0]=n;
		sz=n+1;
		memset(S,0,sizeof(S));
	}
	void addRow(int r,const vector<int> &columns)
	{
		int first=sz,c;
		for(int i=0;i<columns.size();i++)
		{
			c=columns[i];
			L[sz]=sz-1; R[sz]=sz+1; D[sz]=c; U[sz]=U[c];
			D[U[c]]=sz; U[c]=sz;
			row[sz]=r; col[sz]=c;
			S[c]++; sz++; 
		}
		R[sz-1]=first; L[first]=sz-1; 
	}
	#define FOR(i,A,s) for(int i=A[s];i!=s;i=A[i])
	void remove(int c)
	{
		L[R[c]]=L[c]; R[L[c]]=R[c];
		FOR(i,D,c) FOR(j,R,i) { U[D[j]]=U[j]; D[U[j]]=D[j]; S[col[j]]--; } 
	}
	void restore(int c)
	{
		FOR(i,U,c) FOR(j,L,i) { S[col[j]]++; U[D[j]]=j; D[U[j]]=j; }
		L[R[c]]=c; R[L[c]]=c;
	}
	bool dfs(int d)
	{
		if(R[0]==0)
		{
			ansd=d;
			return true;
		}
		int c=R[0];
		FOR(i,R,0) if(S[i]<S[c]) c=i;
		remove(c);
		FOR(i,D,c)
		{
			ans[d]=row[i];
			FOR(j,R,i) remove(col[j]);
			if(dfs(d+1)) return true;
			FOR(j,L,i) restore(col[j]);
		}
		restore(c);
		return false;
	}
	bool solve(vector<int>& v)
	{
		v.clear();
		if(!dfs(0)) return false;
		for(int i=0;i<ansd;i++) v.push_back(ans[i]);
		return true; 
	}
}solver;
char ma[maxr][10][11]; // 记录在DLX中每一行对应的形状
char ans[10][11]; // 填充答案用的
int ha[10][10]; // 每一个格子代表在DLX中的第几列
bool vis[12]; // 记录哪些零件被用过
const int lr[12]={0,0,1,0,0,1,0,1,1,0,0,1}; // 左右翻转后是否跟旋转后相同，相同是1，不相同是0
const int t[12]={4,2,4,1,4,4,4,4,4,1,4,4}; // 4代表旋转180度和原先不同，2代表旋转180度和原先相同但旋转90度不同，1代表旋转90度相同
const int x[12][6]={ // 每个零件在一个平面直角坐标里对应哪些点，这个记录x坐标，-1结束。这个千万别打错。
    {0,0,1,-1},
    {0,1,2,3,-1},
    {0,0,1,2,-1},
    {0,0,1,1,-1},
    {0,0,0,1,2,-1},
    {0,1,1,2,3,-1},
    {0,0,1,2,2,-1},
    {0,0,1,1,2,-1},
    {0,1,2,2,3,-1},
    {0,1,1,1,2,-1},
    {0,0,1,1,2,-1},
    {0,0,1,2,3,-1},
};
const int y[12][6]={ // 这个记录y坐标，-1结束
    {0,1,0,-1},
    {0,0,0,0,-1},
    {0,1,0,0,-1},
    {0,1,0,1,-1},
    {0,1,2,0,0,-1},
    {0,0,1,0,0,-1},
    {0,1,0,0,1,-1},
    {0,1,0,1,0,-1},
    {0,0,0,1,1,-1},
    {1,0,1,2,1,-1},
    {0,1,1,2,2,-1},
    {0,1,0,0,0,-1},
};
inline void clear(int id) // 清空当前的形状
{
    register int i,j;
    for(i=0;i<10;i++)
        for(j=0;j<=i;j++)
            ma[id][i][j]='.';
}
int main()
{
    register int i,j,k,l,tot,cx,cy,tx,ty;
    vector<int> vec;
    solver.init(67); // 67列
    for(i=0;i<10;i++)
        scanf("%s",ans[i]);
    for(i=0;i<12;i++) vis[i]=0;
    for(i=0;i<10;i++)
        for(j=0;j<=i;j++)
            if(ans[i][j]!='.')
                vis[ans[i][j]-'A']=1;
    for(i=0,tot=0;i<10;i++)
    {
        for(j=0;j<=i;j++)
            ha[i][j]=++tot;
        for(;j<10;j++)
            ha[i][j]=-1;
    }
    for(i=0,tot=1;i<12;i++) // 第几个零件
    {
        for(j=-1;j<=lr[i];j+=2) // x的变化量是否乘以-1或1代表是否翻转，而lr[i]=0时只取一个
            for(k=0;k<t[i];k++) // k=0表示不旋转，k=1时表示旋转90度（我不太清楚时顺时针还是逆时针，但不重要），k=2时表示旋转180度，k=3时表示旋转270度；t[i]=1时不旋转，t[i]=2时旋转不超过180度，t[i]=4时四种旋转都表示得到
                for(cx=-5;cx<=15;cx++)
                    for(cy=-5;cy<=cx+5;cy++) // 枚举零件一角
                    {
                        clear(tot);
                        for(l=0;x[i][l]>=0;l++)
                        {
                            if(k&1) // 旋转
                            {
                                tx=cx+((k&2)?x[i][l]:-x[i][l])*j;
                                ty=cy+((k&2)?y[i][l]:-y[i][l]);
                            }
                            else
                            {
                                tx=cx+((k&2)?y[i][l]:-y[i][l])*j;
                                ty=cy+((k&2)?-x[i][l]:x[i][l]);
                            }
                            if(!(0<=ty && ty<=tx && tx<10)) break;
                            if(vis[i] && ans[tx][ty]!=i+'A') break; // 已经确定的零件必须和图对应
                            if(!vis[i] && ans[tx][ty]!='.') break; // 没确定的零件要摆在空位上
                            ma[tot][tx][ty]=i+'A'; // 先记录下来
                        }
                        if(x[i][l]<0)
                        {
                            vec.clear();
                            for(l=0;x[i][l]>=0;l++)
                            {
                                if(k&1)
                                {
                                    tx=cx+((k&2)?x[i][l]:-x[i][l])*j;
                                    ty=cy+((k&2)?y[i][l]:-y[i][l]);
                                }
                                else
                                {
                                    tx=cx+((k&2)?y[i][l]:-y[i][l])*j;
                                    ty=cy+((k&2)?-x[i][l]:x[i][l]);
                                }
                                vec.push_back(ha[tx][ty]); // 填了那些就把列设为1
                            }
                            vec.push_back(i+56); // 还有每个零件对应的列
                            solver.addRow(tot++,vec);
                        }
                    }
    }
    if(!solver.solve(vec)) printf("No solution\n");
    else // 填充答案
    {
        for(i=0;i<vec.size();i++)
            for(j=0;j<10;j++)
                for(k=0;k<=j;k++)
                    if(ma[vec[i]][j][k]!='.')
                        ans[j][k]=ma[vec[i]][j][k];
        for(i=0;i<10;i++)
            printf("%s\n",ans[i]);
    }
    return 0;
}
```

---

## 作者：Uranus (赞：6)

[更好的阅读体验](https://www.cnblogs.com/coder-Uranus/p/9805366.html)

### 暴力枚举+搜索剪枝

----

# 思路

> 其他三道题都没做，这道题$AC$了，不也不错吗？  --Mercury

搜索模拟测试考黑题，简直毒瘤。考场上用了两个多小时敲这道题，还差一个小剪枝才能$AC$。

首先我们枚举每一种零件的放置方法，然后暴力枚举逐个判断每个位置上应该放哪个零件。为了提高枚举效率，我们规定放入的零件对上一行没有影响，也就是说，我们枚举每个位置放置的零件，也就是枚举该零件的左上角放置在该位置时是否有可行方案。

然而最后被这样的一组数据卡掉了：

```text
.
..
...
....
.....
......
.......
.......J
......JJJ
.......J..
```

显然，右下角什么都放不进去，而我的搜索是顺序搜索，所以一直要到快搜索完才会判断到右下角，我的程序也因此被卡到了$8$秒 ~~（明明DLX才是正解好吧，神tm暴搜被卡）~~ 。于是有这样的一个优化：对于当前局面如果最小联通块的大小$\leq 2$，那么就是不可行的方案，直接回溯。这样就可以很快地跑完了。

# AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
char G[15][15];
bool vis[26],hjj[15][15];
inline char readc()
{
    char ch=getchar();
    while(ch!='.'&&!isalpha(ch)) ch=getchar();
    return ch;
}
inline void print()
{
    for(int i=1;i<=10;i++)
    {
        for(int j=1;j<=i;j++) putchar(G[i][j]);
        putchar('\n');
    }
}
bool judge(int x,int y,char z,int w)
{
    if(z=='A')
    {
        if(w==0&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x+1][y]=='.') return true;
        else if(w==1&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x+1][y+1]=='.') return true;
        else if(w==2&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+1][y-1]=='.') return true;
        else if(w==3&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+1][y+1]=='.') return true;
        return false;
    }
    else if(z=='B')
    {
        if(w==0&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x][y+3]=='.') return true;
        else if(w==1&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+2][y]=='.'&&G[x+3][y]=='.') return true;
        return false;
    }
    else if(z=='C')
    {
        if(w==0&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x+1][y]=='.') return true;
        else if(w==1&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x+1][y+1]=='.'&&G[x+2][y+1]=='.') return true;
        else if(w==2&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+1][y-1]=='.'&&G[x+1][y-2]=='.') return true;
        else if(w==3&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+2][y]=='.'&&G[x+2][y+1]=='.') return true;
        else if(w==4&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+1][y+1]=='.'&&G[x+1][y+2]=='.') return true;
        else if(w==5&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x+1][y+2]=='.') return true;
        else if(w==6&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x+1][y]=='.'&&G[x+2][y]=='.') return true;
        else if(w==7&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+2][y]=='.'&&G[x+2][y-1]=='.') return true;
        return false;
    }
    else if(z=='D')
    {
        if(w==0&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x+1][y]=='.'&&G[x+1][y+1]=='.') return true;
        return false;
    }
    else if(z=='E')
    {
        if(w==0&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+2][y]=='.'&&G[x+2][y+1]=='.'&&G[x+2][y+2]=='.') return true;
        else if(w==1&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x+1][y]=='.'&&G[x+2][y]=='.') return true;
        else if(w==2&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x+1][y+2]=='.'&&G[x+2][y+2]=='.') return true;
        else if(w==3&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+2][y]=='.'&&G[x+2][y-1]=='.'&&G[x+2][y-2]=='.') return true;
        return false;
    }
    else if(z=='F')
    {
        if(w==0&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x][y+3]=='.'&&G[x+1][y+1]=='.') return true;
        else if(w==1&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+2][y]=='.'&&G[x+3][y]=='.'&&G[x+1][y-1]=='.') return true;
        else if(w==2&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+1][y+1]=='.'&&G[x+1][y-1]=='.'&&G[x+1][y-2]=='.') return true;
        else if(w==3&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+2][y]=='.'&&G[x+2][y+1]=='.'&&G[x+3][y]=='.') return true;
        else if(w==4&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+1][y-1]=='.'&&G[x+1][y+1]=='.'&&G[x+1][y+2]=='.') return true;
        else if(w==5&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x][y+3]=='.'&&G[x+1][y+2]=='.') return true;
        else if(w==6&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+1][y+1]=='.'&&G[x+2][y]=='.'&&G[x+3][y]=='.') return true;
        else if(w==7&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+2][y]=='.'&&G[x+2][y-1]=='.'&&G[x+3][y]=='.') return true;
        return false;
    }
    else if(z=='G')
    {
        if(w==0&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x+1][y]=='.'&&G[x+1][y+2]=='.') return true;
        else if(w==1&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x+1][y+1]=='.'&&G[x+2][y]=='.'&&G[x+2][y+1]=='.') return true;
        else if(w==2&&G[x][y]=='.'&&G[x][y+2]=='.'&&G[x+1][y]=='.'&&G[x+1][y+1]=='.'&&G[x+1][y+2]=='.') return true;
        else if(w==3&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x+1][y]=='.'&&G[x+2][y]=='.'&&G[x+2][y+1]=='.') return true;
        return false;
    }
    else if(z=='H')
    {
        if(w==0&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x+1][y]=='.'&&G[x+1][y+1]=='.') return true;
        else if(w==1&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x+1][y]=='.'&&G[x+1][y+1]=='.'&&G[x+2][y+1]=='.') return true;
        else if(w==2&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x+1][y]=='.'&&G[x+1][y-1]=='.'&&G[x+1][y+1]=='.') return true;
        else if(w==3&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+1][y+1]=='.'&&G[x+2][y]=='.'&&G[x+2][y+1]=='.') return true;
        else if(w==4&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x+1][y]=='.'&&G[x+1][y+1]=='.'&&G[x+1][y+2]=='.') return true;
        else if(w==5&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x+1][y]=='.'&&G[x+1][y+1]=='.'&&G[x+2][y]=='.') return true;
        else if(w==6&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x+1][y+1]=='.'&&G[x+1][y+2]=='.') return true;
        else if(w==7&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+1][y-1]=='.'&&G[x+2][y]=='.'&&G[x+2][y-1]=='.') return true;
        return false;
    }
    else if(z=='I')
    {
        if(w==0&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x+1][y+2]=='.'&&G[x+1][y+3]=='.') return true;
        else if(w==1&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+2][y]=='.'&&G[x+2][y-1]=='.'&&G[x+3][y-1]=='.') return true;
        else if(w==2&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x+1][y+1]=='.'&&G[x+1][y+2]=='.'&&G[x+1][y+3]=='.') return true;
        else if(w==3&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+1][y-1]=='.'&&G[x+2][y-1]=='.'&&G[x+3][y-1]=='.') return true;
        else if(w==4&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x+1][y]=='.'&&G[x+1][y-1]=='.') return true;
        else if(w==5&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+2][y]=='.'&&G[x+2][y+1]=='.'&&G[x+3][y+1]=='.') return true;
        else if(w==6&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x+1][y]=='.'&&G[x+1][y-1]=='.'&&G[x+1][y-2]=='.') return true;
        else if(w==7&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+1][y+1]=='.'&&G[x+2][y+1]=='.'&&G[x+3][y+1]=='.') return true;
        return false;
    }
    else if(z=='J')
    {
        if(w==0&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+1][y-1]=='.'&&G[x+1][y+1]=='.'&&G[x+2][y]=='.') return true;
        return false;
    }
    else if(z=='K')
    {
        if(w==0&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+1][y+1]=='.'&&G[x+2][y+1]=='.'&&G[x+2][y+2]=='.') return true;
        else if(w==1&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x+1][y]=='.'&&G[x+1][y-1]=='.'&&G[x+2][y-1]=='.') return true;
        else if(w==2&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x+1][y+1]=='.'&&G[x+1][y+2]=='.'&&G[x+2][y+2]=='.') return true;
        else if(w==3&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+1][y-1]=='.'&&G[x+2][y-1]=='.'&&G[x+2][y-2]=='.') return true;
        return false;
    }
    else if(z=='L')
    {
        if(w==0&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x][y+3]=='.'&&G[x+1][y]=='.') return true;
        else if(w==1&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x+1][y+1]=='.'&&G[x+2][y+1]=='.'&&G[x+3][y+1]=='.') return true;
        else if(w==2&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+1][y-1]=='.'&&G[x+1][y-2]=='.'&&G[x+1][y-3]=='.') return true;
        else if(w==3&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+2][y]=='.'&&G[x+3][y]=='.'&&G[x+3][y+1]=='.') return true;
        else if(w==4&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+1][y+1]=='.'&&G[x+1][y+2]=='.'&&G[x+1][y+3]=='.') return true;
        else if(w==5&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x+1][y]=='.'&&G[x+2][y]=='.'&&G[x+3][y]=='.') return true;
        else if(w==6&&G[x][y]=='.'&&G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x][y+3]=='.'&&G[x+1][y+3]=='.') return true;
        else if(w==7&&G[x][y]=='.'&&G[x+1][y]=='.'&&G[x+2][y]=='.'&&G[x+3][y]=='.'&&G[x+3][y-1]=='.') return true;
        return false;
    }
    return false;
}
void fill(int x,int y,char z,int w)
{
    if(z=='A')
    {
        if(w==0) G[x][y]=G[x][y+1]=G[x+1][y]='A';
        else if(w==1) G[x][y]=G[x][y+1]=G[x+1][y+1]='A';
        else if(w==2) G[x][y]=G[x+1][y]=G[x+1][y-1]='A';
        else if(w==3) G[x][y]=G[x+1][y]=G[x+1][y+1]='A';
    }
    else if(z=='B')
    {
        if(w==0) G[x][y]=G[x][y+1]=G[x][y+2]=G[x][y+3]='B';
        else if(w==1) G[x][y]=G[x+1][y]=G[x+2][y]=G[x+3][y]='B';
    }
    else if(z=='C')
    {
        if(w==0) G[x][y]=G[x][y+1]=G[x][y+2]=G[x+1][y]='C';
        else if(w==1) G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x+2][y+1]='C';
        else if(w==2) G[x][y]=G[x+1][y]=G[x+1][y-1]=G[x+1][y-2]='C';
        else if(w==3) G[x][y]=G[x+1][y]=G[x+2][y]=G[x+2][y+1]='C';
        else if(w==4) G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+1][y+2]='C';
        else if(w==5) G[x][y]=G[x][y+1]=G[x][y+2]=G[x+1][y+2]='C';
        else if(w==6) G[x][y]=G[x][y+1]=G[x+1][y]=G[x+2][y]='C';
        else if(w==7) G[x][y]=G[x+1][y]=G[x+2][y]=G[x+2][y-1]='C';
    }
    else if(z=='D') G[x][y]=G[x][y+1]=G[x+1][y]=G[x+1][y+1]='D';
    else if(z=='E')
    {
        if(w==0) G[x][y]=G[x+1][y]=G[x+2][y]=G[x+2][y+1]=G[x+2][y+2]='E';
        else if(w==1) G[x][y]=G[x][y+1]=G[x][y+2]=G[x+1][y]=G[x+2][y]='E';
        else if(w==2) G[x][y]=G[x][y+1]=G[x][y+2]=G[x+1][y+2]=G[x+2][y+2]='E';
        else if(w==3) G[x][y]=G[x+1][y]=G[x+2][y]=G[x+2][y-1]=G[x+2][y-2]='E';
    }
    else if(z=='F')
    {
        if(w==0) G[x][y]=G[x][y+1]=G[x][y+2]=G[x][y+3]=G[x+1][y+1]='F';
        else if(w==1) G[x][y]=G[x+1][y]=G[x+2][y]=G[x+3][y]=G[x+1][y-1]='F';
        else if(w==2) G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+1][y-1]=G[x+1][y-2]='F';
        else if(w==3) G[x][y]=G[x+1][y]=G[x+2][y]=G[x+2][y+1]=G[x+3][y]='F';
        else if(w==4) G[x][y]=G[x+1][y]=G[x+1][y-1]=G[x+1][y+1]=G[x+1][y+2]='F';
        else if(w==5) G[x][y]=G[x][y+1]=G[x][y+2]=G[x][y+3]=G[x+1][y+2]='F';
        else if(w==6) G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+2][y]=G[x+3][y]='F';
        else if(w==7) G[x][y]=G[x+1][y]=G[x+2][y]=G[x+2][y-1]=G[x+3][y]='F';
    }
    else if(z=='G')
    {
        if(w==0) G[x][y]=G[x][y+1]=G[x][y+2]=G[x+1][y]=G[x+1][y+2]='G';
        else if(w==1) G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x+2][y]=G[x+2][y+1]='G';
        else if(w==2) G[x][y]=G[x][y+2]=G[x+1][y]=G[x+1][y+1]=G[x+1][y+2]='G';
        else if(w==3) G[x][y]=G[x][y+1]=G[x+1][y]=G[x+2][y]=G[x+2][y+1]='G';
    }
    else if(z=='H')
    {
        if(w==0) G[x][y]=G[x][y+1]=G[x][y+2]=G[x+1][y]=G[x+1][y+1]='H';
        else if(w==1) G[x][y]=G[x][y+1]=G[x+1][y]=G[x+1][y+1]=G[x+2][y+1]='H';
        else if(w==2) G[x][y]=G[x][y+1]=G[x+1][y]=G[x+1][y-1]=G[x+1][y+1]='H';
        else if(w==3) G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+2][y]=G[x+2][y+1]='H';
        else if(w==4) G[x][y]=G[x][y+1]=G[x+1][y]=G[x+1][y+1]=G[x+1][y+2]='H';
        else if(w==5) G[x][y]=G[x][y+1]=G[x+1][y]=G[x+1][y+1]=G[x+2][y]='H';
        else if(w==6) G[x][y]=G[x][y+1]=G[x][y+2]=G[x+1][y+1]=G[x+1][y+2]='H';
        else if(w==7) G[x][y]=G[x+1][y]=G[x+1][y-1]=G[x+2][y]=G[x+2][y-1]='H';
    }
    else if(z=='I')
    {
        if(w==0) G[x][y]=G[x][y+1]=G[x][y+2]=G[x+1][y+2]=G[x+1][y+3]='I';
        else if(w==1) G[x][y]=G[x+1][y]=G[x+2][y]=G[x+2][y-1]=G[x+3][y-1]='I';
        else if(w==2) G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x+1][y+2]=G[x+1][y+3]='I';
        else if(w==3) G[x][y]=G[x+1][y]=G[x+1][y-1]=G[x+2][y-1]=G[x+3][y-1]='I';
        else if(w==4) G[x][y]=G[x][y+1]=G[x][y+2]=G[x+1][y]=G[x+1][y-1]='I';
        else if(w==5) G[x][y]=G[x+1][y]=G[x+2][y]=G[x+2][y+1]=G[x+3][y+1]='I';
        else if(w==6) G[x][y]=G[x][y+1]=G[x+1][y]=G[x+1][y-1]=G[x+1][y-2]='I';
        else if(w==7) G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+2][y+1]=G[x+3][y+1]='I';
    }
    else if(z=='J') G[x][y]=G[x+1][y]=G[x+1][y-1]=G[x+1][y+1]=G[x+2][y]='J';
    else if(z=='K')
    {
        if(w==0) G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+2][y+1]=G[x+2][y+2]='K';
        else if(w==1) G[x][y]=G[x][y+1]=G[x+1][y]=G[x+1][y-1]=G[x+2][y-1]='K';
        else if(w==2) G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x+1][y+2]=G[x+2][y+2]='K';
        else if(w==3) G[x][y]=G[x+1][y]=G[x+1][y-1]=G[x+2][y-1]=G[x+2][y-2]='K';
    }
    else if(z=='L')
    {
        if(w==0) G[x][y]=G[x][y+1]=G[x][y+2]=G[x][y+3]=G[x+1][y]='L';
        else if(w==1) G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x+2][y+1]=G[x+3][y+1]='L';
        else if(w==2) G[x][y]=G[x+1][y]=G[x+1][y-1]=G[x+1][y-2]=G[x+1][y-3]='L';
        else if(w==3) G[x][y]=G[x+1][y]=G[x+2][y]=G[x+3][y]=G[x+3][y+1]='L';
        else if(w==4) G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+1][y+2]=G[x+1][y+3]='L';
        else if(w==5) G[x][y]=G[x][y+1]=G[x+1][y]=G[x+2][y]=G[x+3][y]='L';
        else if(w==6) G[x][y]=G[x][y+1]=G[x][y+2]=G[x][y+3]=G[x+1][y+3]='L';
        else if(w==7) G[x][y]=G[x+1][y]=G[x+2][y]=G[x+3][y]=G[x+3][y-1]='L';
    }
}
void unfill(int x,int y,char z,int w)
{
    if(z=='A')
    {
        if(w==0) G[x][y]=G[x][y+1]=G[x+1][y]='.';
        else if(w==1) G[x][y]=G[x][y+1]=G[x+1][y+1]='.';
        else if(w==2) G[x][y]=G[x+1][y]=G[x+1][y-1]='.';
        else if(w==3) G[x][y]=G[x+1][y]=G[x+1][y+1]='.';
    }
    else if(z=='B')
    {
        if(w==0) G[x][y]=G[x][y+1]=G[x][y+2]=G[x][y+3]='.';
        else if(w==1) G[x][y]=G[x+1][y]=G[x+2][y]=G[x+3][y]='.';
    }
    else if(z=='C')
    {
        if(w==0) G[x][y]=G[x][y+1]=G[x][y+2]=G[x+1][y]='.';
        else if(w==1) G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x+2][y+1]='.';
        else if(w==2) G[x][y]=G[x+1][y]=G[x+1][y-1]=G[x+1][y-2]='.';
        else if(w==3) G[x][y]=G[x+1][y]=G[x+2][y]=G[x+2][y+1]='.';
        else if(w==4) G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+1][y+2]='.';
        else if(w==5) G[x][y]=G[x][y+1]=G[x][y+2]=G[x+1][y+2]='.';
        else if(w==6) G[x][y]=G[x][y+1]=G[x+1][y]=G[x+2][y]='.';
        else if(w==7) G[x][y]=G[x+1][y]=G[x+2][y]=G[x+2][y-1]='.';
    }
    else if(z=='D') G[x][y]=G[x][y+1]=G[x+1][y]=G[x+1][y+1]='.';
    else if(z=='E')
    {
        if(w==0) G[x][y]=G[x+1][y]=G[x+2][y]=G[x+2][y+1]=G[x+2][y+2]='.';
        else if(w==1) G[x][y]=G[x][y+1]=G[x][y+2]=G[x+1][y]=G[x+2][y]='.';
        else if(w==2) G[x][y]=G[x][y+1]=G[x][y+2]=G[x+1][y+2]=G[x+2][y+2]='.';
        else if(w==3) G[x][y]=G[x+1][y]=G[x+2][y]=G[x+2][y-1]=G[x+2][y-2]='.';
    }
    else if(z=='F')
    {
        if(w==0) G[x][y]=G[x][y+1]=G[x][y+2]=G[x][y+3]=G[x+1][y+1]='.';
        else if(w==1) G[x][y]=G[x+1][y]=G[x+2][y]=G[x+3][y]=G[x+1][y-1]='.';
        else if(w==2) G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+1][y-1]=G[x+1][y-2]='.';
        else if(w==3) G[x][y]=G[x+1][y]=G[x+2][y]=G[x+2][y+1]=G[x+3][y]='.';
        else if(w==4) G[x][y]=G[x+1][y]=G[x+1][y-1]=G[x+1][y+1]=G[x+1][y+2]='.';
        else if(w==5) G[x][y]=G[x][y+1]=G[x][y+2]=G[x][y+3]=G[x+1][y+2]='.';
        else if(w==6) G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+2][y]=G[x+3][y]='.';
        else if(w==7) G[x][y]=G[x+1][y]=G[x+2][y]=G[x+2][y-1]=G[x+3][y]='.';
    }
    else if(z=='G')
    {
        if(w==0) G[x][y]=G[x][y+1]=G[x][y+2]=G[x+1][y]=G[x+1][y+2]='.';
        else if(w==1) G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x+2][y]=G[x+2][y+1]='.';
        else if(w==2) G[x][y]=G[x][y+2]=G[x+1][y]=G[x+1][y+1]=G[x+1][y+2]='.';
        else if(w==3) G[x][y]=G[x][y+1]=G[x+1][y]=G[x+2][y]=G[x+2][y+1]='.';
    }
    else if(z=='H')
    {
        if(w==0) G[x][y]=G[x][y+1]=G[x][y+2]=G[x+1][y]=G[x+1][y+1]='.';
        else if(w==1) G[x][y]=G[x][y+1]=G[x+1][y]=G[x+1][y+1]=G[x+2][y+1]='.';
        else if(w==2) G[x][y]=G[x][y+1]=G[x+1][y]=G[x+1][y-1]=G[x+1][y+1]='.';
        else if(w==3) G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+2][y]=G[x+2][y+1]='.';
        else if(w==4) G[x][y]=G[x][y+1]=G[x+1][y]=G[x+1][y+1]=G[x+1][y+2]='.';
        else if(w==5) G[x][y]=G[x][y+1]=G[x+1][y]=G[x+1][y+1]=G[x+2][y]='.';
        else if(w==6) G[x][y]=G[x][y+1]=G[x][y+2]=G[x+1][y+1]=G[x+1][y+2]='.';
        else if(w==7) G[x][y]=G[x+1][y]=G[x+1][y-1]=G[x+2][y]=G[x+2][y-1]='.';
    }
    else if(z=='I')
    {
        if(w==0) G[x][y]=G[x][y+1]=G[x][y+2]=G[x+1][y+2]=G[x+1][y+3]='.';
        else if(w==1) G[x][y]=G[x+1][y]=G[x+2][y]=G[x+2][y-1]=G[x+3][y-1]='.';
        else if(w==2) G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x+1][y+2]=G[x+1][y+3]='.';
        else if(w==3) G[x][y]=G[x+1][y]=G[x+1][y-1]=G[x+2][y-1]=G[x+3][y-1]='.';
        else if(w==4) G[x][y]=G[x][y+1]=G[x][y+2]=G[x+1][y]=G[x+1][y-1]='.';
        else if(w==5) G[x][y]=G[x+1][y]=G[x+2][y]=G[x+2][y+1]=G[x+3][y+1]='.';
        else if(w==6) G[x][y]=G[x][y+1]=G[x+1][y]=G[x+1][y-1]=G[x+1][y-2]='.';
        else if(w==7) G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+2][y+1]=G[x+3][y+1]='.';
    }
    else if(z=='J') G[x][y]=G[x+1][y]=G[x+1][y-1]=G[x+1][y+1]=G[x+2][y]='.';
    else if(z=='K')
    {
        if(w==0) G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+2][y+1]=G[x+2][y+2]='.';
        else if(w==1) G[x][y]=G[x][y+1]=G[x+1][y]=G[x+1][y-1]=G[x+2][y-1]='.';
        else if(w==2) G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x+1][y+2]=G[x+2][y+2]='.';
        else if(w==3) G[x][y]=G[x+1][y]=G[x+1][y-1]=G[x+2][y-1]=G[x+2][y-2]='.';
    }
    else if(z=='L')
    {
        if(w==0) G[x][y]=G[x][y+1]=G[x][y+2]=G[x][y+3]=G[x+1][y]='.';
        else if(w==1) G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x+2][y+1]=G[x+3][y+1]='.';
        else if(w==2) G[x][y]=G[x+1][y]=G[x+1][y-1]=G[x+1][y-2]=G[x+1][y-3]='.';
        else if(w==3) G[x][y]=G[x+1][y]=G[x+2][y]=G[x+3][y]=G[x+3][y+1]='.';
        else if(w==4) G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+1][y+2]=G[x+1][y+3]='.';
        else if(w==5) G[x][y]=G[x][y+1]=G[x+1][y]=G[x+2][y]=G[x+3][y]='.';
        else if(w==6) G[x][y]=G[x][y+1]=G[x][y+2]=G[x][y+3]=G[x+1][y+3]='.';
        else if(w==7) G[x][y]=G[x+1][y]=G[x+2][y]=G[x+3][y]=G[x+3][y-1]='.';
    }
}
int ltk(int x,int y)
{
    hjj[x][y]=true;int re=1;
    if(G[x-1][y]=='.'&&!hjj[x-1][y]) re+=ltk(x-1,y);
    if(G[x][y-1]=='.'&&!hjj[x][y-1]) re+=ltk(x,y-1);
    if(G[x+1][y]=='.'&&!hjj[x+1][y]) re+=ltk(x+1,y);
    if(G[x][y+1]=='.'&&!hjj[x][y+1]) re+=ltk(x,y+1);
    return re;
}
bool dfs(int x,int y)
{
    memset(hjj,false,sizeof hjj);
    for(int i=1;i<=10;i++)
        for(int j=1;j<=i;j++)
            if(G[i][j]=='.'&&!hjj[i][j])
                if(ltk(i,j)<=2) return false;
    for(char i='A';i<='L';i++)
    {
        if(vis[i-'A']) continue;
        for(int w=0;w<8;w++)
            if(judge(x,y,i,w))
            {
                vis[i-'A']=true;
                fill(x,y,i,w);
                bool flag=false;
                for(int j=1;j<=10;j++)
                {
                    for(int k=1;k<=j;k++)
                        if(G[j][k]=='.')
                        {
                            flag=true;
                            if(dfs(j,k)) return true;
                            break;
                        }
                    if(flag) break;
                }
                if(!flag) return true;
                vis[i-'A']=false;
                unfill(x,y,i,w);
            }
    }
    return false;
}
int main()
{
    for(int i=1;i<=10;i++)
    {
        for(int j=1;j<=i;j++)
        {
            G[i][j]=readc();
            if(isalpha(G[i][j])) vis[G[i][j]-'A']=true;
        }
        for(int j=i+1;j<=10;j++)
            G[i][j]='$';
    }
    for(int i=0;i<=11;i++) G[i][0]=G[i][11]=G[0][i]=G[11][i]='$';
    for(int i=1;i<=10;i++)
        for(int j=1;j<=i;j++)
            if(G[i][j]=='.')
            {
                if(dfs(i,j)) print();
                else printf("No solution");
                return 0;
            }
}
```

---

## 作者：Yurchiu (赞：5)

本题解使用 dfs 做法。

# 约定

## 文中出现的词语定义

- 零件：指题目中 $\lceil$ $12$个形态各异的零件 $\rfloor$ 中的零件。
- 零件形态：指一个零件能通过旋转和翻转所能形成的图案。
- 珠子：指零件中的珠子。

## 变量

```cpp
int num[]={0,4,2,8,1,4,8,4,8,8,1,4,8};
//各零件形态数
char a[10+5][10+5];
//存图案
bool v[20];
//零件是否使用过
int tal=0;
//阈值，意义后文有
```

## 宏

```cpp
#define a(q,w,e) if(a[px+q][py+w]!='.')return 0/*指这个地方有零件放入*/;
//检验这个零件是否能放下(参数e是用不到的，无影响)
#define a(q,w,e) a[px+q][py+w]=e
//打标记
#define a(q,w,e) a[px+q][py+w]='.'
//回溯(参数e是用不到的，无影响)

//与后面的“函数”一一对应
```

## 函数

```cpp
//3个宏+打表部分(见后文)=3个函数：
bool check(int type,int round,int px,int py)//最后要 return 1，即既然前面没有 return 0，则这个位置是合法的
//检验这个零件是否能放下
void seter(int type,int round,int px,int py)
//打标记
void clean(int type,int round,int px,int py)
//回溯
```

参数意义：

- `type` 零件
- `round` 零件形态
- `px,py` 坐标

# 打表

![](https://cdn.luogu.com.cn/upload/pic/13768.png)

先手动打表，把所有零件的零件形态记录下来。

零件有$12$种，且**所有的零件都允许旋转和翻转**，所以需打表$60$种情况：

| 零件         | A    | B    | C    | D    | E    | F    | G    | H    | I    | J    | K    | L    | 合计 |
| :------------: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: |
| 零件形态总数 | 4    | 2    | 8    | 1    | 4    | 8    | 4    | 8    | 8    | 1    | 4    | 8    | 60   |

打表各零件中各珠子的相对坐标。以下是打表代码：

```cpp
	switch(type)
	{
		case 1:
			switch(round)
			{
				case 1:a(0,0,'A'),a(0,1,'A'),a(1,0,'A');break;
				case 2:a(1,1,'A'),a(0,1,'A'),a(0,0,'A');break;
				case 3:a(1,0,'A'),a(0,0,'A'),a(1,-1,'A');break;
				case 4:a(1,1,'A'),a(0,0,'A'),a(1,0,'A');break;
			}break;
		case 2:
			switch(round)
			{
				case 1:a(0,0,'B'),a(0,1,'B'),a(0,2,'B'),a(0,3,'B');break;
				case 2:a(0,0,'B'),a(1,0,'B'),a(2,0,'B'),a(3,0,'B');break;
			}break;
		case 3:
			switch(round)
			{
				case 1:a(0,0,'C'),a(0,1,'C'),a(1,0,'C'),a(0,2,'C');break;
				case 2:a(0,0,'C'),a(1,0,'C'),a(2,0,'C'),a(2,1,'C');break;
				case 3:a(0,0,'C'),a(1,0,'C'),a(1,-1,'C'),a(1,-2,'C');break;
				case 4:a(0,0,'C'),a(0,1,'C'),a(1,1,'C'),a(2,1,'C');break;
				case 5:a(0,0,'C'),a(1,0,'C'),a(1,1,'C'),a(1,2,'C');break;
				case 6:a(0,0,'C'),a(0,1,'C'),a(1,0,'C'),a(2,0,'C');break;
				case 7:a(0,0,'C'),a(0,1,'C'),a(0,2,'C'),a(1,2,'C');break;
				case 8:a(0,0,'C'),a(1,0,'C'),a(2,0,'C'),a(2,-1,'C');break;
			}break;
		case 4:
			switch(round)
			{
				case 1:a(0,0,'D'),a(0,1,'D'),a(1,0,'D'),a(1,1,'D');break;
			}break;
		case 5:
			switch(round)
			{
				case 1:a(0,0,'E'),a(0,1,'E'),a(0,2,'E'),a(1,0,'E'),a(2,0,'E');break;
				case 2:a(0,0,'E'),a(1,0,'E'),a(2,0,'E'),a(2,-1,'E'),a(2,-2,'E');break;
				case 3:a(0,0,'E'),a(0,1,'E'),a(0,2,'E'),a(1,2,'E'),a(2,2,'E');break;
				case 4:a(0,0,'E'),a(2,1,'E'),a(2,2,'E'),a(1,0,'E'),a(2,0,'E');break;
			}break;
		case 6:
			switch(round)
			{
				case 1:a(0,0,'F'),a(0,1,'F'),a(0,2,'F'),a(0,3,'F'),a(1,1,'F');break;
				case 2:a(0,0,'F'),a(0,1,'F'),a(0,2,'F'),a(0,3,'F'),a(1,2,'F');break;
				case 3:a(1,-1,'F'),a(1,0,'F'),a(1,1,'F'),a(1,2,'F'),a(0,0,'F');break;
				case 4:a(0,0,'F'),a(1,0,'F'),a(1,1,'F'),a(1,-1,'F'),a(1,-2,'F');break;
				case 5:a(0,0,'F'),a(1,0,'F'),a(2,0,'F'),a(3,0,'F'),a(1,1,'F');break;
				case 6:a(0,0,'F'),a(1,0,'F'),a(2,0,'F'),a(3,0,'F'),a(2,1,'F');break;
				case 7:a(0,0,'F'),a(1,0,'F'),a(2,0,'F'),a(3,0,'F'),a(1,-1,'F');break;
				case 8:a(0,0,'F'),a(1,0,'F'),a(2,0,'F'),a(3,0,'F'),a(2,-1,'F');break;
			}break;
		case 7:
			switch(round)
			{
				case 1:a(0,0,'G'),a(0,1,'G'),a(0,2,'G'),a(1,0,'G'),a(1,2,'G');break;
				case 2:a(1,0,'G'),a(1,1,'G'),a(1,2,'G'),a(0,0,'G'),a(0,2,'G');break;
				case 3:a(0,1,'G'),a(1,1,'G'),a(2,1,'G'),a(0,0,'G'),a(2,0,'G');break;
				case 4:a(0,0,'G'),a(1,0,'G'),a(2,0,'G'),a(0,1,'G'),a(2,1,'G');break;
			}break;
		case 8:
			switch(round)
			{
				case 1:a(0,0,'H'),a(0,1,'H'),a(0,2,'H'),a(1,0,'H'),a(1,1,'H');break;
				case 2:a(0,0,'H'),a(0,1,'H'),a(0,2,'H'),a(1,1,'H'),a(1,2,'H');break;
				case 3:a(0,0,'H'),a(0,1,'H'),a(1,0,'H'),a(1,1,'H'),a(1,-1,'H');break;
				case 4:a(1,0,'H'),a(1,1,'H'),a(0,0,'H'),a(2,1,'H'),a(0,1,'H');break;
				case 5:a(0,0,'H'),a(1,0,'H'),a(2,0,'H'),a(2,1,'H'),a(1,1,'H');break;
				case 6:a(0,0,'H'),a(1,-1,'H'),a(2,-1,'H'),a(1,0,'H'),a(2,0,'H');break;
				case 7:a(0,1,'H'),a(1,1,'H'),a(1,2,'H'),a(0,0,'H'),a(1,0,'H');break;
				case 8:a(0,1,'H'),a(1,1,'H'),a(2,0,'H'),a(0,0,'H'),a(1,0,'H');break;
			}break;
		case 9:
			switch(round)
			{
				case 1:a(0,0,'I'),a(0,1,'I'),a(0,2,'I'),a(1,2,'I'),a(1,3,'I');break;
				case 2:a(1,-1,'I'),a(0,0,'I'),a(1,0,'I'),a(2,-1,'I'),a(3,-1,'I');break;
				case 3:a(0,0,'I'),a(1,1,'I'),a(1,2,'I'),a(1,3,'I'),a(0,1,'I');break;
				case 4:a(0,0,'I'),a(0,1,'I'),a(1,0,'I'),a(1,-1,'I'),a(1,-2,'I');break;
				case 5:a(0,0,'I'),a(1,0,'I'),a(2,0,'I'),a(2,-1,'I'),a(3,-1,'I');break;
				case 6:a(0,0,'I'),a(1,0,'I'),a(2,0,'I'),a(2,1,'I'),a(3,1,'I');break;
				case 7:a(0,0,'I'),a(0,1,'I'),a(0,2,'I'),a(1,0,'I'),a(1,-1,'I');break;
				case 8:a(0,0,'I'),a(1,0,'I'),a(1,1,'I'),a(2,1,'I'),a(3,1,'I');break;
			}break;
		case 10:
			switch(round)
			{
				case 1:a(0,0,'J'),a(1,0,'J'),a(2,0,'J'),a(1,-1,'J'),a(1,1,'J');break;
			}break;
		case 11:
			switch(round)
			{
				case 1:a(0,0,'K'),a(1,0,'K'),a(1,1,'K'),a(2,1,'K'),a(2,2,'K');break;
				case 2:a(0,0,'K'),a(1,0,'K'),a(1,-1,'K'),a(2,-1,'K'),a(2,-2,'K');break;
				case 3:a(0,0,'K'),a(1,0,'K'),a(1,-1,'K'),a(2,-1,'K'),a(0,1,'K');break;
				case 4:a(0,0,'K'),a(0,1,'K'),a(1,1,'K'),a(1,2,'K'),a(2,2,'K');break;
			}break;
		case 12:
			switch(round)
			{
				case 1:a(0,0,'L'),a(0,1,'L'),a(0,2,'L'),a(0,3,'L'),a(1,0,'L');break;
				case 2:a(0,0,'L'),a(1,0,'L'),a(2,0,'L'),a(3,0,'L'),a(3,1,'L');break;
				case 3:a(0,0,'L'),a(1,0,'L'),a(1,-1,'L'),a(1,-2,'L'),a(1,-3,'L');break;
				case 4:a(0,0,'L'),a(0,1,'L'),a(1,1,'L'),a(2,1,'L'),a(3,1,'L');break;
				case 5:a(1,0,'L'),a(1,1,'L'),a(1,2,'L'),a(1,3,'L'),a(0,0,'L');break;
				case 6:a(0,0,'L'),a(1,0,'L'),a(2,0,'L'),a(3,0,'L'),a(0,1,'L');break;
				case 7:a(0,1,'L'),a(0,0,'L'),a(1,3,'L'),a(0,2,'L'),a(0,3,'L');break;
				case 8:a(0,0,'L'),a(1,0,'L'),a(2,0,'L'),a(3,0,'L'),a(3,-1,'L');break;
			}break;
	}
```

打表两点注意事项（我踩过的坑）：

- 打表部分中**必须**有坐标为$(0,0)$的点。

- 确保零件的放置不会对前面已放上的零件造成影响——打表部分中坐标为$(0,0)$的点的左面与上面没有点。例子（形状都为`:.`形）：
  - 合法：$(0,0),(1,0),(1,1)$。
  - 不合法：$(0,0),(-1,0),(0,1)$。

# 暴力 dfs

```cpp
void dfs(int step)
{
    //********************解的判断
	bool flag=1;
	for(int i=1;i<=12;i++)
		if(v[i]==0)
			flag=0;
	if(flag)//零件都用了
	{
		for(int i=1;i<=10;i++)
		{
			for(int j=1;j<=i;j++)
				cout<<a[i][j];
			cout<<endl;
		}
		exit(0);//输出并立刻结束程序
	}
    //********************递归数阈值
	tal++;
	if(tal>2500000)//马上要TLE了，赶紧结束程序。这个地方别的题解有所提及
		printf("No solution"),exit(0);
    //********************从上至下寻找还未填的地方
	int x,y;
	for(x=1;x<=10;x++)
		for(y=1;y<=x;y++)
			if(a[x][y]=='.')
				goto end;//用break麻烦
	end:
    //********************枚举算符（若打表部分没满足前文的两点要求，会WA）
	for(int i=1;i<=12;i++)//枚举各零件
		if(v[i]==0)
		{
			v[i]=1;
			for(int j=1;j<=num[i];j++)//枚举各零件的各零件形态
				if(check(i,j,x,y))//三个函数意义前文已有解释
				{
					seter(i,j,x,y);
					dfs(step+1);
					clean(i,j,x,y);
				}
			v[i]=0;
		}
}
```

纯暴力+防 TLE 剪枝= AC 。

注：dfs 好像无需参数。

---

## 作者：邱江坤 (赞：5)

你们写的都太长了，发一个比较短的代码，时间为800ms

思路大概是，暴力枚举，还有一些剪枝。

用了一些奇技淫巧。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 11;
const int n = 10;
const char *mmm[] =
{
    "AA",
    "A ",
    "",
    "BBBB",
    "",
    "CCC",
    "C  ",
    "",
    "DD",
    "DD",
    "",
    "E  ",
    "E  ",
    "EEE",
    "",
    "FFFF",
    " F  ",
    "",
    "GGG",
    "G G",
    "",
    "HHH",
    "HH ",
    "",
    "III ",
    "  II",
    "",
    " J ",
    "JJJ",
    " J ",
    "",
    "K  ",
    "KK ",
    " KK",
    "",
    "LLLL",
    "L   ",
    "",
    0
};

struct node
{
    char state[5][5];
    int fx;
	int height;
	int width;
    node():fx(9999), height(0), width(0) {memset(state, 0, sizeof state);}
    int fix()
    {
        if(fx != 9999) return fx;
        for(int i = 0; i < width; ++i)
        {
            if(isalpha(state[0][i]))
                return fx = i;
        }
        return -9999;
    }
    char *operator[](size_t i)
    {
        return state[i];
    }
    const char *operator[](size_t i) const
    {
        return state[i];
    }
    int ID()
    {
        return state[0][fix()];
    }
    node rotate() const
    {
        node nd;
		nd.height = width;
		nd.width = height;
        for(int i = 0; i < width; ++i)
        {
            for(int j = 0; j < height; ++j)
                nd[i][j] = state[j][width - 1 - i];
        }

        return nd;
    }
    node reverse() const
    {
        node nd;
		nd.height = height;
		nd.width = width;
        for(int i = 0; i < height; ++i)
            memcpy(nd[i], state[height - 1 -i], width + 1);
        return nd;
    }
    void show()
    {
        for(int i = 0; i < height; ++i)
        {
			for (int j = 0; j < width; j++) {
				cerr << state[i][j];
			}
            cerr << endl;
        }
        cerr << endl;
    }

};
bool operator<(node &lhs, node &rhs)
{
    if(lhs.ID() != rhs.ID()) return lhs.ID() < rhs.ID();
    if(lhs.height != rhs.height) return lhs.height < rhs.height;
    if(lhs.width != rhs.width) return lhs.width < rhs.width;
    for(int i = 0; i < lhs.height; ++i)
        if(strcmp(lhs[i], rhs[i]) != 0)
            return strcmp(lhs[i], rhs[i]) < 0;
    return false;
}
bool operator==(node &lhs, node &rhs)
{
    return !(lhs < rhs) && !(rhs < lhs);
}
node mmp[12 * 8];
int len;
void init()
{
    const char **p = mmm;
    while(*p)
    {
        node nd;
        while(*p && **p)
        {
            strcpy(nd[nd.height++], *p);
            ++p;
        }
        nd.width = strlen(nd[0]);
        mmp[len++] = (nd);
        mmp[len++] = (nd.rotate());
        mmp[len++] = (nd.rotate().rotate());
        mmp[len++] = (nd.rotate().rotate().rotate());
        mmp[len++] = (nd.reverse());
        mmp[len++] = (nd.rotate().reverse());
        mmp[len++] = (nd.rotate().rotate().reverse());
        mmp[len++] = (nd.rotate().rotate().rotate().reverse());
        ++p;
    }
    sort(mmp, mmp + len);
    len = unique(mmp, mmp + len) - mmp;
    random_shuffle(mmp, mmp + len);
}
int used[255];
char mp[N][N];
void show_map()
{
    for(int i = 1; i <= n; ++i)
    {
        for(int j = 1; j <= i; ++j)
            cout << mp[i][j];
        cout << endl;
    }
    cout << endl;
}
bool check(int x, int y, int id)
{
    const node &nd = mmp[id];
    if(x + nd.height - 1 > n) return false;
    if(y + nd.width - 1 > n) return false;
    for(int i = 0; i < nd.height; ++i)
    {
        for(int j = 0; j < nd.width; ++j)
        {
            if(isalpha(nd[i][j]) && mp[x+i][y+j] != '.')
                return false;
        }
    }
    return true;
}
bool put(int x, int y, int id, bool unput)
{
    const node &nd = mmp[id];
    for(int i = 0; i < nd.height; ++i)
    {
        for(int j = 0; j < nd.width; ++j)
        {
            if(isalpha(nd[i][j]))
            {
                if(unput)
                    mp[x + i][y + j] = '.';
                else
                    mp[x + i][y + j] = nd[i][j];
            }
        }
    }
    return true;
}

int pre[N*N];
int find(int i)
{
    if(pre[i] > 0)
        return pre[i] = find(pre[i]);
    else return i;
}
void merge(int a, int b)
{
    int ra = find(a), rb = find(b);
    if(ra == rb) return;
    pre[ra] -= -pre[rb] + 1;
    pre[rb] = ra;
}
bool checkcn()
{
    memset(pre, 0, sizeof pre);
    for(int i = 1; i <= n; ++i)
    {
        for(int j = 1; j <= i; ++j)
        {
            if(mp[i][j] == '.')
            {
                if(mp[i][j-1] == '.')
                    merge(i*n + j, i * n + j - 1);
                if(mp[i-1][j] == '.')
                    merge(i*n + j, (i - 1) * n + j);
            }
        }
    }
//    for(int i = 1; i <= n; ++i)
//    {
//        for(int j = 1; j <= i; ++j)
//        {
//            cerr << -pre[find(i * n + j)] + 1 << " ";
//        }
//        cerr << endl;
//    }
    for(int i = 1; i <= n; ++i)
    {
        for(int j = 1; j <= i; ++j)
        {
            if(mp[i][j] == '.' && -pre[find(i * n + j)] + 1 < 3)
                return false;
        }
    }
    return true;
}
clock_t b ;
void dfs(int x, int y)
{
    if(!checkcn())
    {
        return;
    }
    while(x <= n && isalpha(mp[x][y]))
    {
        ++y;
        if(y > x)
            y = 1, x += 1;
    }
    if(x == n + 1)
    {
        show_map();
        cerr << 1.0 * (clock() - b) / CLOCKS_PER_SEC << endl;
        exit(0);
    }
//    show_map();
    for(int i = 0; i < len; ++i)
    {
        int ny = y - mmp[i].fix();
        if(!used[mmp[i].ID()] && check(x, ny, i))
        {
            put(x, ny, i, false);
            used[mmp[i].ID()] = 1;
            dfs(x, y + 1);
            used[mmp[i].ID()] = 0;
            put(x, ny, i, true);
        }
    }
}


#define IO(file) freopen(#file".in", "r", stdin), freopen(#file".out", "w", stdout)
int main()
{
    IO(game);
//	freopen("game.out", "w", stdout);
    memset(mp, 'X', sizeof mp);
    init();
//	for(int i = 0; i < len; ++i) {
//        cout << mmp[i].ID() << endl;
//		mmp[i].show();
//	}

    for(int i = 1; i <= n; ++i)
    {
        for(int j = 1; j <= i; ++j)
        {
            cin >> mp[i][j];
            if(isalpha(mp[i][j]))
            {
                used[mp[i][j]] = 1;
            }
        }
    }

    b = clock();
    dfs(1, 1);
    cout << "No solution" << endl;
}

```

---

## 作者：zhenglier (赞：4)

## ~~论如何优雅的写大搜索~~

代码不长，一百多行。

首先先把所有形状记录在$dx,dy$数组中，然后用$ok$函数判断是否可以放置，用$fill$函数放置，回溯时调整$fill$函数的参数撤销放置就可以很方便的写了。

这里我在$ok$函数和$fill$函数里写了$cl$函数，用途是找到当前这个形状（翻转或旋转完后）右下角那个块的位置，然后在接下来的运算中就以那个块为中心放置，这就可以避免一些麻烦的if语句。

然后我用了一些玄学减枝才过：
- 从$(10,10)$开始搜。
- 从$B$开始尝试放置。
- 判断当前图像中有没有联通块大小小于2，如果有直接退出。
- ~~手动Ofast。~~

不过也有可能是数据比较水，这么写刚好能卡过去

[(1000ms惨案)](https://www.luogu.org/record/show?rid=14948223)

然后是135行的代码。

$\color{white}\text{当你复制下来发现代码有136行是就应该发现有问题}$

```cpp
#pragma optimize("Ofast")//玄学
#include<bits/stdc++.h>
#define res register int
using namespace std;
const int dx[12][6]={{3,0,1,0},{4,1,2,3,0},{4,0,0,0,1},{4,0,0,1,1},{5,0,0,0,1,2},{5,0,0,0,0,1},{5,0,0,1,1,1},{5,0,0,0,1,1},{5,0,0,1,1,1},{5,0,1,1,1,2},{5,0,1,1,2,2},{5,0,0,0,0,1}};
const int dy[12][6]={{3,0,0,1},{4,0,0,0,0},{4,0,1,2,0},{4,1,0,1,0},{5,0,1,2,0,0},{5,0,1,2,3,2},{5,0,2,0,1,2},{5,0,1,2,0,1},{5,0,1,1,2,3},{5,1,0,1,2,1},{5,0,0,1,1,2},{5,0,1,2,3,0}};
int mp[11][11],v[20];
void cl(int &mx,int &my,int w,int k){
    int len=dx[w][0];
    if(k&4){
        for(res i=1;i<=len;++i){
            int nx=((k&1)?1:-1)*dx[w][i],ny=((k&2)?1:-1)*dy[w][i];
            if(nx>mx||(nx==mx&&ny>my))mx=nx,my=ny;
        }
    }else{
        for(res i=1;i<=len;++i){
            int nx=((k&1)?1:-1)*dy[w][i],ny=((k&2)?1:-1)*dx[w][i];
            if(nx>mx||(nx==mx&&ny>my))mx=nx,my=ny;
        }
    }
}
bool ok(int x,int y,int w,int k){
    int len=dx[w][0],mx=0,my=0;
	cl(mx,my,w,k);
    if(k&4){
        for(res i=1;i<=len;++i){
            int nx=x+((k&1)?1:-1)*dx[w][i]-mx,ny=y+((k&2)?1:-1)*dy[w][i]-my;
            if(nx<1||nx>10||ny<1||ny>10||ny>nx)return 0;
            if(~mp[nx][ny])return 0;
        }
    }else{
        for(res i=1;i<=len;++i){
            int nx=x+((k&1)?1:-1)*dy[w][i]-mx,ny=y+((k&2)?1:-1)*dx[w][i]-my;
            if(nx<1||nx>10||ny<1||ny>10||ny>nx)return 0;
            if(~mp[nx][ny])return 0;
        }
    }
    return 1;
}
void fill(int x,int y,int w,int k,int bo=1){
    int len=dx[w][0],mx=0,my=0;
	cl(mx,my,w,k);
    if(k&4){
        for(res i=1;i<=len;++i){
            int nx=x+((k&1)?1:-1)*dx[w][i]-mx,ny=y+((k&2)?1:-1)*dy[w][i]-my;
            mp[nx][ny]=bo?w:-1;
        }
    }else{
        for(res i=1;i<=len;++i){
            int nx=x+((k&1)?1:-1)*dy[w][i]-mx,ny=y+((k&2)?1:-1)*dx[w][i]-my;
            mp[nx][ny]=bo?w:-1;
        }
    }
}
void pt(){
    for(res i=1;i<=10;++i){
        for(res j=1;j<=i;++j){
        	if(mp[i][j]==-1)putchar('.');
            else putchar(mp[i][j]+'A');
        }puts("");
    }
}
const int ddx[]={0,1,0,-1};
const int ddy[]={1,0,-1,0};
int vis[11][11];
int dfs1(int x,int y){
    if(vis[x][y]||~mp[x][y])return 0;
    vis[x][y]=1;
    for(res i=0;i<4;++i){
        int nx=x+ddx[i],ny=y+ddy[i];
        if(nx<1||nx>10||ny<1||ny>10||ny>nx)continue;
        vis[x][y]+=dfs1(nx,ny);
    }
    return vis[x][y];
}
bool cut1(){
    memset(vis,0,sizeof vis);
    for(res i=1;i<=10;++i){
        for(res j=1;j<=i;++j){
            if(vis[i][j]||~mp[i][j])continue;
            int ot=dfs1(i,j);
            if(ot<=2||(ot<=3&&v[0]))return 0;
        }
    }
    return 1;
}
void dfs(int x,int y){
    if(!cut1())return;
    for(res ii=1;ii<=12;++ii){
    	int i=ii%12;
        if(v[i])continue;
        for(res j=0;j<8;++j){
            if(ok(x,y,i,j)){
            	int flag=0;
            	v[i]=1;
                fill(x,y,i,j);
                for(int xx=10;xx;--xx){
                    for(int yy=xx;yy;--yy){
                        if(mp[xx][yy]==-1){
                            dfs(xx,yy);
                            flag=1;
                            break;
                        }
                    }
                    if(flag)break;
                }
                if(!flag){
                	pt();
                    exit(0);
                }
                fill(x,y,i,j,0);
                v[i]=0;
            }
        }
    }
}
int main(){    
    for(res i=1;i<=10;++i){
        for(res j=1;j<=i;++j){
            char c=getchar();
            while(c!='.'&&(c<'A'||c>'Z'))c=getchar();
            if(c=='.')mp[i][j]=-1;
            else mp[i][j]=c-'A',v[c-'A']=1;
        }
    }
    while(1);
    for(res i=10;i;--i){
    	for(res j=i;j;--j){
    		if(!~mp[i][j]){
    			dfs(i,j);
                puts("No solution");
                return 0;
			}
		}
	}
}
```

---

## 作者：Sooke (赞：3)

### 解题思路

其实也没什么解题思路，暴力模拟搜索直接上就行了。每次填充靠前的空位。

这里有个看起来非常整齐的写法，也有利于调试，其他题解里没看见过这种写法。

设 $len$ 是当前零件的大小，我们用长宽都为 $2 \times len - 1$ 的字符矩阵来储存各种零件。其中最中心的是当前搜到的位置。

例如：

```
g[0] = "...";
g[1] = ".AA";
g[2] = ".A.";
```

需要注意的是，因为我们是从第一行，第二行……这样顺次摆下来的，所以矩阵的最中心首先要被占用，其次最中心位置前面的，必须不能用占用，下面两个就不合法：

```
g[0] = "...";
g[1] = "..A";
g[2] = ".AA";
```


```
g[0] = ".A.";
g[1] = "AA.";
g[2] = "...";
```

应该这么表示：


```
g[0] = "..";
g[1] = ".A.";
g[2] = "AA.";
```

硬生生地去描绘所有零件、所有方向的字符矩阵就好。

然后呢，写个函数，有两种模式。第一种：判断给定的字符矩阵表示的零件是否能在给定的位置放，如果能则放并修改解，返回 true，否则返回 false。为了实现回溯，所以有第二种：扔掉之前放的零件。

最后加一个剪枝（当然正式比赛是不能使用的），用 clock 计时，如果要超时了，则无解（~~很玄学是不是~~）。

交上去，发现 90 分，WA 了个点，哈？

原来是把有解判成无解了，说明程序还不够高效。

怎么办？随机是击败出题人最大的利器，考虑给每种零件的枚举顺序随机一下（~~我因为懒就只把 H 和 C 提前了~~），而不是 ABCDE... 这样死板地枚举，然后就可以过了。

---

### 代码实现

~~超长代码预警！！！（写起来和看起来都好爽的呢）~~

```cpp
#include <ctime>
#include <cstdlib>
#include <iostream>

char f[25][25];
bool used[255];
clock_t st;

inline bool modify(int x, int y, int len, std::string g[7], bool mode) {
    bool flag = true;
    if (mode) {
        for (int i = 1 - len; i < len; i++) {
            for (int j = 1 - len; j < len; j++) {
                if (g[i + len - 1][j + len - 1] != '.' && ((x + i <= 0 && y + j <= 0) || f[x + i][y + j] != '.')) { flag = false; }
            }
        }
        if (flag) {
            for (int i = 1 - len; i < len; i++) {
                for (int j = 1 - len; j < len; j++) {
                    if (g[i + len - 1][j + len - 1] != '.') { f[x + i][y + j] = g[i + len - 1][j + len - 1]; }
                }
            }
        }
    } else {
        for (int i = 1 - len; i < len; i++) {
            for (int j = 1 - len; j < len; j++) {
                if (g[i + len - 1][j + len - 1] != '.') { f[x + i][y + j] = '.'; }
            }
        }
    }
    return flag;
}

void dfs() {
    int x = 0, y, len; std::string g[7];
    for (int i = 1; i <= 10; i++) {
        for (int j = 1; j <= i; j++) {
            if (f[i][j] == '.') { x = i; y = j; break; }
        }
        if (x) { break; }
    }
    // 找到最靠前空位的位置。
    if (!x) {
    	// 没有空位，说明填满了，输出解。
        for (int i = 1; i <= 10; i++) {
            for (int j = 1; j <= i; j++) { std::cout << f[i][j]; }
            std::cout << std::endl;
        }
        exit(0);
    }
    if (clock() - st >= 950000) {
        std::cout << "No solution" << std::endl;
        exit(0);
    }
    if (!used['H']) {
        used['H'] = true; len = 3;
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..HHH";
        g[3] = "..HH.";
        g[4] = ".....";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..HH.";
        g[3] = "..HHH";
        g[4] = ".....";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..HHH";
        g[3] = "...HH";
        g[4] = ".....";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..HH.";
        g[3] = ".HHH.";
        g[4] = ".....";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..H..";
        g[3] = "..HH.";
        g[4] = "..HH.";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..H..";
        g[3] = ".HH..";
        g[4] = ".HH..";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..HH.";
        g[3] = "..HH.";
        g[4] = "..H..";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..HH.";
        g[3] = "..HH.";
        g[4] = "...H.";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        used['H'] = false;
    }
    if (!used['C']) {
        used['C'] = true; len = 3;
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..CCC";
        g[3] = "..C..";
        g[4] = ".....";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..CCC";
        g[3] = "....C";
        g[4] = ".....";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..CC.";
        g[3] = "..C..";
        g[4] = "..C..";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..C..";
        g[3] = "..C..";
        g[4] = "..CC.";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..C..";
        g[3] = "..CCC";
        g[4] = ".....";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..CC.";
        g[3] = "...C.";
        g[4] = "...C.";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..C..";
        g[3] = "..C..";
        g[4] = ".CC..";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..C..";
        g[3] = "CCC..";
        g[4] = ".....";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        used['C'] = false;
    }
    if (!used['A']) {
        used['A'] = true; len = 2;
        g[0] = "...";
        g[1] = ".AA";
        g[2] = ".A.";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = "...";
        g[1] = ".AA";
        g[2] = "..A";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = "...";
        g[1] = ".A.";
        g[2] = "AA.";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = "...";
        g[1] = ".A.";
        g[2] = ".AA";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        used['A'] = false;
    }
    if (!used['B']) {
        used['B'] = true; len = 4;
        g[0] = ".......";
        g[1] = ".......";
        g[2] = ".......";
        g[3] = "...BBBB";
        g[4] = ".......";
        g[5] = ".......";
        g[6] = ".......";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".......";
        g[1] = ".......";
        g[2] = ".......";
        g[3] = "...B...";
        g[4] = "...B...";
        g[5] = "...B...";
        g[6] = "...B...";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        used['B'] = false;
    }
    if (!used['D']) {
        used['D'] = true; len = 2;
        g[0] = "...";
        g[1] = ".DD";
        g[2] = ".DD";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        used['D'] = false;
    }
    if (!used['E']) {
        used['E'] = true; len = 3;
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..E..";
        g[3] = "..E..";
        g[4] = "..EEE";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..EEE";
        g[3] = "..E..";
        g[4] = "..E..";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..EEE";
        g[3] = "....E";
        g[4] = "....E";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..E..";
        g[3] = "..E..";
        g[4] = "EEE..";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        used['E'] = false;
    }
    if (!used['F']) {
        used['F'] = true; len = 4;
        g[0] = ".......";
        g[1] = ".......";
        g[2] = ".......";
        g[3] = "...FFFF";
        g[4] = "....F..";
        g[5] = ".......";
        g[6] = ".......";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".......";
        g[1] = ".......";
        g[2] = ".......";
        g[3] = "...FFFF";
        g[4] = ".....F.";
        g[5] = ".......";
        g[6] = ".......";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".......";
        g[1] = ".......";
        g[2] = ".......";
        g[3] = "...F...";
        g[4] = "..FFFF.";
        g[5] = ".......";
        g[6] = ".......";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".......";
        g[1] = ".......";
        g[2] = ".......";
        g[3] = "...F...";
        g[4] = ".FFFF..";
        g[5] = ".......";
        g[6] = ".......";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".......";
        g[1] = ".......";
        g[2] = ".......";
        g[3] = "...F...";
        g[4] = "..FF...";
        g[5] = "...F...";
        g[6] = "...F...";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".......";
        g[1] = ".......";
        g[2] = ".......";
        g[3] = "...F...";
        g[4] = "...F...";
        g[5] = "..FF...";
        g[6] = "...F...";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".......";
        g[1] = ".......";
        g[2] = ".......";
        g[3] = "...F...";
        g[4] = "...FF..";
        g[5] = "...F...";
        g[6] = "...F...";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".......";
        g[1] = ".......";
        g[2] = ".......";
        g[3] = "...F...";
        g[4] = "...F...";
        g[5] = "...FF..";
        g[6] = "...F...";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        used['F'] = false;
    }
    if (!used['G']) {
        used['G'] = true; len = 3;
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..GGG";
        g[3] = "..G.G";
        g[4] = ".....";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..G.G";
        g[3] = "..GGG";
        g[4] = ".....";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..GG.";
        g[3] = "...G.";
        g[4] = "..GG.";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..GG.";
        g[3] = "..G..";
        g[4] = "..GG.";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        used['G'] = false;
    }
    if (!used['I']) {
        used['I'] = true; len = 4;
        g[0] = ".......";
        g[1] = ".......";
        g[2] = ".......";
        g[3] = "...III.";
        g[4] = ".....II";
        g[5] = ".......";
        g[6] = ".......";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".......";
        g[1] = ".......";
        g[2] = ".......";
        g[3] = "...II..";
        g[4] = "....III";
        g[5] = ".......";
        g[6] = ".......";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".......";
        g[1] = ".......";
        g[2] = ".......";
        g[3] = "...III.";
        g[4] = "..II...";
        g[5] = ".......";
        g[6] = ".......";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".......";
        g[1] = ".......";
        g[2] = ".......";
        g[3] = "...II..";
        g[4] = ".III...";
        g[5] = ".......";
        g[6] = ".......";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".......";
        g[1] = ".......";
        g[2] = ".......";
        g[3] = "...I...";
        g[4] = "...I...";
        g[5] = "...II..";
        g[6] = "....I..";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".......";
        g[1] = ".......";
        g[2] = ".......";
        g[3] = "...I...";
        g[4] = "...I...";
        g[5] = "..II...";
        g[6] = "..I....";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".......";
        g[1] = ".......";
        g[2] = ".......";
        g[3] = "...I...";
        g[4] = "...II..";
        g[5] = "....I..";
        g[6] = "....I..";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".......";
        g[1] = ".......";
        g[2] = ".......";
        g[3] = "...I...";
        g[4] = "..II...";
        g[5] = "..I....";
        g[6] = "..I....";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        used['I'] = false;
    }
    if (!used['J']) {
        used['J'] = true; len = 3;
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..J..";
        g[3] = ".JJJ.";
        g[4] = "..J..";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        used['J'] = false;
    }
    if (!used['K']) {
        used['K'] = true; len = 3;
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..K..";
        g[3] = "..KK.";
        g[4] = "...KK";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..KK.";
        g[3] = "...KK";
        g[4] = "....K";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".....";
        g[1] = ".....";
        g[2] = "..K..";
        g[3] = ".KK..";
        g[4] = "KK...";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".....";
        g[1] = ".....";
        g[2] = ".KK..";
        g[3] = "KK...";
        g[4] = "K....";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        used['K'] = false;
    }
    if (!used['L']) {
        used['L'] = true; len = 4;
        g[0] = ".......";
        g[1] = ".......";
        g[2] = ".......";
        g[3] = "...LLLL";
        g[4] = "...L...";
        g[5] = ".......";
        g[6] = ".......";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".......";
        g[1] = ".......";
        g[2] = ".......";
        g[3] = "...LLLL";
        g[4] = "......L";
        g[5] = ".......";
        g[6] = ".......";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".......";
        g[1] = ".......";
        g[2] = ".......";
        g[3] = "...L...";
        g[4] = "...LLLL";
        g[5] = ".......";
        g[6] = ".......";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".......";
        g[1] = ".......";
        g[2] = ".......";
        g[3] = "...L...";
        g[4] = "LLLL...";
        g[5] = ".......";
        g[6] = ".......";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".......";
        g[1] = ".......";
        g[2] = ".......";
        g[3] = "...L...";
        g[4] = "...L...";
        g[5] = "...L...";
        g[6] = "..LL...";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".......";
        g[1] = ".......";
        g[2] = ".......";
        g[3] = "...L...";
        g[4] = "...L...";
        g[5] = "...L...";
        g[6] = "...LL..";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".......";
        g[1] = ".......";
        g[2] = ".......";
        g[3] = "...LL..";
        g[4] = "...L...";
        g[5] = "...L...";
        g[6] = "...L...";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        g[0] = ".......";
        g[1] = ".......";
        g[2] = ".......";
        g[3] = "...LL..";
        g[4] = "....L..";
        g[5] = "....L..";
        g[6] = "....L..";
        if (modify(x, y, len, g, true)) { dfs(); modify(x, y, len, g, false); }
        used['L'] = false;
    }
}

int main() {
    for (int i = 1; i <= 10; i++) {
        for (int j = 1; j <= i; j++) {
            std::cin >> f[i][j];
            used[f[i][j]] = true;
        }
    }
    st = clock(); dfs();
    return 0;
}
```

---

## 作者：OIer_hsy (赞：3)

我的第一道黑题，写篇题解纪念一下。

…………~~这个题目其实并不是太难~~…………（蒟蒻我都能AC的黑题）

算法应该很好想到，就是暴力的搜索（好像时间复杂度不是太高，我的程序321ms过）不过要注意的一点是存图时要把整个三角形沿斜边的高翻折交换一波（~~我不会告诉你这其实是我们老师说的~~）

剩下的就是暴力的深度搜索啦，码量贼大，但没什么技巧，认真点把所有情况都打完就行，千万别打错，三百多行的程序真心不好改

打完长舒一口气，我有些地方错了，但居然能有九十分，不知是数据太水还是怎么地，大家最好别复制代码，自己写一下也是极大的提升，磨炼耐心与毅力。

下面是完整代码

```cpp
#include<bits/stdc++.h>
#define FOR(i,a,b) for (register int i=a;i<=b;i++)
using namespace std;
const int n=10;
int tu[15][15];
bool used[15];
void print() {
	for (int i=1,k=1; i<=n; i++) {
		FOR(j,1,k)
			swap(tu[i][j],tu[11-j][11-i]);
		if (i<=4)  k++;
		else  k--;
	}
	FOR(i,1,n) {
		FOR(j,1,i)
			printf("%c",tu[i][j]+'A'-1);
		printf("\n");
	}
	exit(0);
}
void dfs(int x,int y) {
	while(tu[x][y]) {
		y++;
		if (x<y) x++,y=1;
		if (x>n) {
			print();
			return;
		}
	}
	if ((!used[12])&&(!tu[x][y+1])&&(!tu[x][y+2])&&(!tu[x][y+3])&&(!tu[x+1][y])) {
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x][y+3]=tu[x+1][y]=12,used[12]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x][y+3]=tu[x+1][y]=0,used[12]=0;
	}
	if ((!used[12])&&(!tu[x+1][y])&&(!tu[x+1][y+1])&&(!tu[x+1][y+2])&&(!tu[x+1][y+3])) {
		tu[x][y]=tu[x+1][y]=tu[x+1][y+1]=tu[x+1][y+2]=tu[x+1][y+3]=12,used[12]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y]=tu[x+1][y+1]=tu[x+1][y+2]=tu[x+1][y+3]=0,used[12]=0;
	}
	if ((!used[12])&&(!tu[x+1][y])&&(!tu[x+2][y])&&(!tu[x+3][y])&&(!tu[x+3][y+1])) {
		tu[x][y]=tu[x+1][y]=tu[x+2][y]=tu[x+3][y]=tu[x+3][y+1]=12,used[12]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y]=tu[x+2][y]=tu[x+3][y]=tu[x+3][y+1]=0,used[12]=0;
	}
	if ((!used[12])&&(!tu[x+1][y])&&(!tu[x+2][y])&&(!tu[x+3][y-1])&&(!tu[x+3][y])) {
		tu[x][y]=tu[x+1][y]=tu[x+2][y]=tu[x+3][y-1]=tu[x+3][y]=12,used[12]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y]=tu[x+2][y]=tu[x+3][y-1]=tu[x+3][y]=0,used[12]=0;
	}
	if ((!used[12])&&(!tu[x+1][y-3])&&(!tu[x+1][y-2])&&(!tu[x+1][y-1])&&(!tu[x+1][y])) {
		tu[x][y]=tu[x+1][y-3]=tu[x+1][y-2]=tu[x+1][y-1]=tu[x+1][y]=12,used[12]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y-3]=tu[x+1][y-2]=tu[x+1][y-1]=tu[x+1][y]=0,used[12]=0;
	}
	if ((!used[12])&&(!tu[x][y+1])&&(!tu[x][y+2])&&(!tu[x][y+3])&&(!tu[x+1][y+3])) {
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x][y+3]=tu[x+1][y+3]=12,used[12]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x][y+3]=tu[x+1][y+3]=0,used[12]=0;
	}
	if ((!used[12])&&(!tu[x][y+1])&&(!tu[x+1][y+1])&&(!tu[x+2][y+1])&&(!tu[x+3][y+1])) {
		tu[x][y]=tu[x][y+1]=tu[x+1][y+1]=tu[x+2][y+1]=tu[x+3][y+1]=12,used[12]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x+1][y+1]=tu[x+2][y+1]=tu[x+3][y+1]=0,used[12]=0;
	}
	if ((!used[12])&&(!tu[x][y+1])&&(!tu[x+1][y])&&(!tu[x+2][y])&&(!tu[x+3][y])) {
		tu[x][y]=tu[x][y+1]=tu[x+1][y]=tu[x+2][y]=tu[x+3][y]=12,used[12]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x+1][y]=tu[x+2][y]=tu[x+3][y]=0,used[12]=0;
	}
	if ((!used[11])&&(!tu[x+1][y])&&(!tu[x+1][y+1])&&(!tu[x+2][y+1])&&(!tu[x+2][y+2])) {
		tu[x][y]=tu[x+1][y]=tu[x+1][y+1]=tu[x+2][y+1]=tu[x+2][y+2]=11,used[11]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y]=tu[x+1][y+1]=tu[x+2][y+1]=tu[x+2][y+2]=0,used[11]=0;
	}
	if ((!used[11])&&(!tu[x+1][y])&&(!tu[x+1][y-1])&&(!tu[x+2][y-1])&&(!tu[x+2][y-2])) {
		tu[x][y]=tu[x+1][y]=tu[x+1][y-1]=tu[x+2][y-1]=tu[x+2][y-2]=11,used[11]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y]=tu[x+1][y-1]=tu[x+2][y-1]=tu[x+2][y-2]=0,used[11]=0;
	}
	if ((!used[11])&&(!tu[x][y-1])&&(!tu[x+1][y-1])&&(!tu[x+1][y-2])&&(!tu[x+2][y-2])) {
		tu[x][y]=tu[x][y-1]=tu[x+1][y-1]=tu[x+1][y-2]=tu[x+2][y-2]=11,used[11]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y-1]=tu[x+1][y-1]=tu[x+1][y-2]=tu[x+2][y-2]=0,used[11]=0;
	}
	if ((!used[11])&&(!tu[x][y+1])&&(!tu[x+1][y+1])&&(!tu[x+1][y+2])&&(!tu[x+2][y+2])) {
		tu[x][y]=tu[x][y+1]=tu[x+1][y+1]=tu[x+1][y+2]=tu[x+2][y+2]=11,used[11]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x+1][y+1]=tu[x+1][y+2]=tu[x+2][y+2]=0,used[11]=0;
	}
	if (!(used[10])&&(!tu[x+1][y-1])&&(!tu[x+1][y])&&(!tu[x+1][y+1])&&(!tu[x+2][y])) {
		tu[x][y]=tu[x+1][y-1]=tu[x+1][y]=tu[x+1][y+1]=tu[x+2][y]=10,used[10]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y-1]=tu[x+1][y]=tu[x+1][y+1]=tu[x+2][y]=0,used[10]=0;
	}
	if ((!used[9])&&(!tu[x][y+1])&&(!tu[x][y+2])&&(!tu[x+1][y+2])&&(!tu[x+1][y+3])) {
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x+1][y+2]=tu[x+1][y+3]=9,used[9]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x+1][y+2]=tu[x+1][y+3]=0,used[9]=0;
	}
	if ((!used[9])&&(!tu[x][y+1])&&(!tu[x+1][y-2])&&(!tu[x+1][y-1])&&(!tu[x+1][y])) {
		tu[x][y]=tu[x][y+1]=tu[x+1][y-2]=tu[x+1][y-1]=tu[x+1][y]=9,used[9]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x+1][y-2]=tu[x+1][y-1]=tu[x+1][y]=0,used[9]=0;
	}
	if ((!used[9])&&(!tu[x+1][y-1])&&(!tu[x+1][y])&&(!tu[x+2][y-1])&&(!tu[x+3][y-1])) {
		tu[x][y]=tu[x+1][y-1]=tu[x+1][y]=tu[x+2][y-1]=tu[x+3][y-1]=9,used[9]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y-1]=tu[x+1][y]=tu[x+2][y-1]=tu[x+3][y-1]=0,used[9]=0;
	}
	if ((!used[9])&&(!tu[x+1][y])&&(!tu[x+1][y+1])&&(!tu[x+2][y+1])&&(!tu[x+3][y+1])) {
		tu[x][y]=tu[x+1][y]=tu[x+1][y+1]=tu[x+2][y+1]=tu[x+3][y+1]=9,used[9]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y]=tu[x+1][y+1]=tu[x+2][y+1]=tu[x+3][y+1]=0,used[9]=0;
	}
	if ((!used[9])&&(!tu[x][y+1])&&(!tu[x+1][y+1])&&(!tu[x+1][y+2])&&(!tu[x+1][y+3])) {
		tu[x][y]=tu[x][y+1]=tu[x+1][y+1]=tu[x+1][y+2]=tu[x+1][y+3]=9,used[9]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x+1][y+1]=tu[x+1][y+2]=tu[x+1][y+3]=0,used[9]=0;
	}
	if ((!used[9])&&(!tu[x][y+1])&&(!tu[x][y+2])&&(!tu[x+1][y-1])&&(!tu[x+1][y])) {
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x+1][y-1]=tu[x+1][y]=9,used[9]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x+1][y-1]=tu[x+1][y]=0,used[9]=0;
	}
	if ((!used[9])&&(!tu[x+1][y])&&(!tu[x+2][y-1])&&(!tu[x+2][y])&&(!tu[x+3][y-1])) {
		tu[x][y]=tu[x+1][y]=tu[x+2][y-1]=tu[x+2][y]=tu[x+3][y-1]=9,used[9]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y]=tu[x+2][y-1]=tu[x+2][y]=tu[x+3][y-1]=0,used[9]=0;
	}
	if ((!used[9])&&(!tu[x+1][y])&&(!tu[x+2][y])&&(!tu[x+2][y+1])&&(!tu[x+3][y+1])) {
		tu[x][y]=tu[x+1][y]=tu[x+2][y]=tu[x+2][y+1]=tu[x+3][y+1]=9,used[9]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y]=tu[x+2][y]=tu[x+2][y+1]=tu[x+3][y+1]=0,used[9]=0;
	}
	if ((!used[8])&&(!tu[x][y+1])&&(!tu[x][y+2])&&(!tu[x+1][y])&&(!tu[x+1][y+1])) {
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x+1][y]=tu[x+1][y+1]=8,used[8]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x+1][y]=tu[x+1][y+1]=0,used[8]=0;
	}
	if ((!used[8])&&(!tu[x][y+1])&&(!tu[x+1][y])&&(!tu[x+1][y+1])&&(!tu[x+1][y+2])) {
		tu[x][y]=tu[x][y+1]=tu[x+1][y]=tu[x+1][y+1]=tu[x+1][y+2]=8,used[8]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x+1][y]=tu[x+1][y+1]=tu[x+1][y+2]=0,used[8]=0;
	}
	if ((!used[8])&&(!tu[x+1][y])&&(!tu[x+1][y+1])&&(!tu[x+2][y])&&(!tu[x+2][y+1])) {
		tu[x][y]=tu[x+1][y]=tu[x+1][y+1]=tu[x+2][y]=tu[x+2][y+1]=8,used[8]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y]=tu[x+1][y+1]=tu[x+2][y]=tu[x+2][y+1]=0,used[8]=0;
	}
	if ((!used[8])&&(!tu[x+1][y-1])&&(!tu[x+1][y])&&(!tu[x+2][y-1])&&(!tu[x+2][y])) {
		tu[x][y]=tu[x+1][y-1]=tu[x+1][y]=tu[x+2][y-1]=tu[x+2][y]=8,used[8]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y-1]=tu[x+1][y]=tu[x+2][y-1]=tu[x+2][y]=0,used[8]=0;
	}
	if ((!used[8])&&(!tu[x][y+1])&&(!tu[x+1][y-1])&&(!tu[x+1][y])&&(!tu[x+1][y+1])) {
		tu[x][y]=tu[x][y+1]=tu[x+1][y-1]=tu[x+1][y]=tu[x+1][y+1]=8,used[8]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x+1][y-1]=tu[x+1][y]=tu[x+1][y+1]=0,used[8]=0;
	}
	if ((!used[8])&&(!tu[x][y+1])&&(!tu[x][y+2])&&(!tu[x+1][y+1])&&(!tu[x+1][y+2])) {
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x+1][y+1]=tu[x+1][y+2]=8,used[8]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x+1][y+1]=tu[x+1][y+2]=0,used[8]=0;
	}
	if ((!used[8])&&(!tu[x][y+1])&&(!tu[x+1][y])&&(!tu[x+1][y+1])&&(!tu[x+2][y+1])) {
		tu[x][y]=tu[x][y+1]=tu[x+1][y]=tu[x+1][y+1]=tu[x+2][y+1]=8,used[8]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x+1][y]=tu[x+1][y+1]=tu[x+2][y+1]=0,used[8]=0;
	}
	if ((!used[8])&&(!tu[x][y+1])&&(!tu[x+1][y])&&(!tu[x+1][y+1])&&(!tu[x+2][y])) {
		tu[x][y]=tu[x][y+1]=tu[x+1][y]=tu[x+1][y+1]=tu[x+2][y]=8,used[8]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x+1][y]=tu[x+1][y+1]=tu[x+2][y]=0,used[8]=0;
	}
	if ((!used[7])&&(!tu[x][y+1])&&(!tu[x][y+2])&&(!tu[x+1][y])&&(!tu[x+1][y+2])) {
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x+1][y]=tu[x+1][y+2]=7,used[7]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x+1][y]=tu[x+1][y+2]=0,used[7]=0;
	}
	if ((!used[7])&&(!tu[x][y+1])&&(!tu[x+1][y])&&(!tu[x+2][y])&&(!tu[x+2][y+1])) {
		tu[x][y]=tu[x][y+1]=tu[x+1][y]=tu[x+2][y]=tu[x+2][y+1]=7,used[7]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x+1][y]=tu[x+2][y]=tu[x+2][y+1]=0,used[7]=0;
	}
	if ((!used[7])&&(!tu[x][y+2])&&(!tu[x+1][y])&&(!tu[x+1][y+1])&&(!tu[x+1][y+2])) {
		tu[x][y]=tu[x][y+2]=tu[x+1][y]=tu[x+1][y+1]=tu[x+1][y+2]=7,used[7]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+2]=tu[x+1][y]=tu[x+1][y+1]=tu[x+1][y+2]=0,used[7]=0;
	}
	if ((!used[7])&&(!tu[x][y+1])&&(!tu[x+1][y+1])&&(!tu[x+2][y])&&(!tu[x+2][y+1])) {
		tu[x][y]=tu[x][y+1]=tu[x+1][y+1]=tu[x+2][y]=tu[x+2][y+1]=7,used[7]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x+1][y+1]=tu[x+2][y]=tu[x+2][y+1]=0,used[7]=0;
	}
	if ((!used[6])&&(!tu[x][y+1])&&(!tu[x][y+2])&&(!tu[x][y+3])&&(!tu[x+1][y+1])) {
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x][y+3]=tu[x+1][y+1]=6,used[6]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x][y+3]=tu[x+1][y+1]=0,used[6]=0;
	}
	if ((!used[6])&&(!tu[x+1][y-1])&&(!tu[x+1][y])&&(!tu[x+1][y+1])&&(!tu[x+1][y+2])) {
		tu[x][y]=tu[x+1][y-1]=tu[x+1][y]=tu[x+1][y+1]=tu[x+1][y+2]=6,used[6]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y-1]=tu[x+1][y]=tu[x+1][y+1]=tu[x+1][y+2]=0,used[6]=0;
	}
	if ((!used[6])&&(!tu[x][y+1])&&(!tu[x][y+2])&&(!tu[x][y+3])&&(!tu[x+1][y+2])) {
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x][y+3]=tu[x+1][y+2]=6,used[6]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x][y+3]=tu[x+1][y+2]=0,used[6]=0;
	}
	if ((!used[6])&&(!tu[x+1][y-2])&&(!tu[x+1][y-1])&&(!tu[x+1][y])&&(!tu[x+1][y+1])) {
		tu[x][y]=tu[x+1][y-2]=tu[x+1][y-1]=tu[x+1][y]=tu[x+1][y+1]=6,used[6]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y-2]=tu[x+1][y-1]=tu[x+1][y]=tu[x+1][y+1]=0,used[6]=0;
	}
	if ((!used[6])&&(!tu[x+1][y])&&(!tu[x+1][y+1])&&(!tu[x+2][y])&&(!tu[x+3][y])) {
		tu[x][y]=tu[x+1][y]=tu[x+1][y+1]=tu[x+2][y]=tu[x+3][y]=6,used[6]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y]=tu[x+1][y+1]=tu[x+2][y]=tu[x+3][y]=0,used[6]=0;
	}
	if ((!used[6])&&(!tu[x+1][y-1])&&(!tu[x+1][y])&&(!tu[x+2][y])&&(!tu[x+3][y])) {
		tu[x][y]=tu[x+1][y-1]=tu[x+1][y]=tu[x+2][y]=tu[x+3][y]=6,used[6]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y-1]=tu[x+1][y]=tu[x+2][y]=tu[x+3][y]=0,used[6]=0;
	}
	if ((!used[6])&&(!tu[x+1][y])&&(!tu[x+2][y])&&(!tu[x+2][y+1])&&(!tu[x+3][y])) {
		tu[x][y]=tu[x+1][y]=tu[x+2][y]=tu[x+2][y+1]=tu[x+3][y]=6,used[6]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y]=tu[x+2][y]=tu[x+2][y+1]=tu[x+3][y]=0,used[6]=0;
	}
	if ((!used[6])&&(!tu[x+1][y])&&(!tu[x+2][y-1])&&(!tu[x+2][y])&&(!tu[x+3][y])) {
		tu[x][y]=tu[x+1][y]=tu[x+2][y-1]=tu[x+2][y]=tu[x+3][y]=6,used[6]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y]=tu[x+2][y-1]=tu[x+2][y]=tu[x+3][y]=0,used[6]=0;
	}
	if ((!used[5])&&(!tu[x][y+1])&&(!tu[x][y+2])&&(!tu[x+1][y])&&(!tu[x+2][y])) {
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x+1][y]=tu[x+2][y]=5,used[5]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x+1][y]=tu[x+2][y]=0,used[5]=0;
	}
	if ((!used[5])&&(!tu[x][y+1])&&(!tu[x][y+2])&&(!tu[x+1][y+2])&&(!tu[x+2][y+2])) {
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x+1][y+2]=tu[x+2][y+2]=5,used[5]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x+1][y+2]=tu[x+2][y+2]=0,used[5]=0;
	}
	if ((!used[5])&&(!tu[x+1][y])&&(!tu[x+2][y])&&(!tu[x+2][y+1])&&(!tu[x+2][y+2])) {
		tu[x][y]=tu[x+1][y]=tu[x+2][y]=tu[x+2][y+1]=tu[x+2][y+2]=5,used[5]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y]=tu[x+2][y]=tu[x+2][y+1]=tu[x+2][y+2]=0,used[5]=0;
	}
	if ((!used[5])&&(!tu[x+1][y])&&(!tu[x+2][y-2])&&(!tu[x+2][y-1])&&(!tu[x+2][y])) {
		tu[x][y]=tu[x+1][y]=tu[x+2][y-2]=tu[x+2][y-1]=tu[x+2][y]=5,used[5]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y]=tu[x+2][y-2]=tu[x+2][y-1]=tu[x+2][y]=0,used[5]=0;
	}
	if ((!used[4])&&(!tu[x][y+1])&&(!tu[x+1][y])&&(!tu[x+1][y+1])) {
		tu[x][y]=tu[x][y+1]=tu[x+1][y]=tu[x+1][y+1]=4,used[4]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x+1][y]=tu[x+1][y+1]=0,used[4]=0;
	}
	if ((!used[3])&&(!tu[x][y+1])&&(!tu[x][y+2])&&(!tu[x+1][y])) {
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x+1][y]=3,used[3]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x+1][y]=0,used[3]=0;
	}
	if ((!used[3])&&(!tu[x+1][y])&&(!tu[x+1][y+1])&&(!tu[x+1][y+2])) {
		tu[x][y]=tu[x+1][y]=tu[x+1][y+1]=tu[x+1][y+2]=3,used[3]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y]=tu[x+1][y+1]=tu[x+1][y+2]=0,used[3]=0;
	}
	if ((!used[3])&&(!tu[x+1][y])&&(!tu[x+2][y])&&(!tu[x+2][y+1])) {
		tu[x][y]=tu[x+1][y]=tu[x+2][y]=tu[x+2][y+1]=3,used[3]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y]=tu[x+2][y]=tu[x+2][y+1]=0,used[3]=0;
	}
	if ((!used[3])&&(!tu[x+1][y])&&(!tu[x+2][y-1])&&(!tu[x+2][y])) {
		tu[x][y]=tu[x+1][y]=tu[x+2][y-1]=tu[x+2][y]=3,used[3]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y]=tu[x+2][y-1]=tu[x+2][y]=0,used[3]=0;
	}
	if ((!used[3])&&(!tu[x+1][y-2])&&(!tu[x+1][y-1])&&(!tu[x+1][y])) {
		tu[x][y]=tu[x+1][y-2]=tu[x+1][y-1]=tu[x+1][y]=3,used[3]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y-2]=tu[x+1][y-1]=tu[x+1][y]=0,used[3]=0;
	}
	if ((!used[3])&&(!tu[x][y+1])&&(!tu[x][y+2])&&(!tu[x+1][y+2])) {
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x+1][y+2]=3,used[3]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x+1][y+2]=0,used[3]=0;
	}
	if ((!used[3])&&(!tu[x][y+1])&&(!tu[x+1][y+1])&&(!tu[x+2][y+1])) {
		tu[x][y]=tu[x][y+1]=tu[x+1][y+1]=tu[x+2][y+1]=3,used[3]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x+1][y+1]=tu[x+2][y+1]=0,used[3]=0;
	}
	if ((!used[3])&&(!tu[x][y+1])&&(!tu[x+1][y])&&(!tu[x+2][y])) {
		tu[x][y]=tu[x][y+1]=tu[x+1][y]=tu[x+2][y]=3,used[3]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x+1][y]=tu[x+2][y]=0,used[3]=0;
	}
	if ((!used[2])&&(!tu[x][y+1])&&(!tu[x][y+2])&&(!tu[x][y+3])) {
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x][y+3]=2,used[2]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x][y+2]=tu[x][y+3]=0,used[2]=0;
	}
	if ((!used[2])&&(!tu[x+1][y])&&(!tu[x+2][y])&&(!tu[x+3][y])) {
		tu[x][y]=tu[x+1][y]=tu[x+2][y]=tu[x+3][y]=2,used[2]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y]=tu[x+2][y]=tu[x+3][y]=0,used[2]=0;
	}
	if ((!used[1])&&(!tu[x+1][y])&&(!tu[x][y+1])) {
		tu[x][y]=tu[x+1][y]=tu[x][y+1]=1,used[1]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y]=tu[x][y+1]=0,used[1]=0;
	}
	if ((!used[1])&&(!tu[x][y+1])&&(!tu[x+1][y+1])) {
		tu[x][y]=tu[x][y+1]=tu[x+1][y+1]=1,used[1]=1;
		dfs(x,y);
		tu[x][y]=tu[x][y+1]=tu[x+1][y+1]=0,used[1]=0;
	}
	if ((!used[1])&&(!tu[x+1][y])&&(!tu[x+1][y+1])) {
		tu[x][y]=tu[x+1][y]=tu[x+1][y+1]=1,used[1]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y]=tu[x+1][y+1]=0,used[1]=0;
	}
	if ((!used[1])&&(!tu[x+1][y-1])&&(!tu[x+1][y])) {
		tu[x][y]=tu[x+1][y-1]=tu[x+1][y]=1,used[1]=1;
		dfs(x,y);
		tu[x][y]=tu[x+1][y-1]=tu[x+1][y]=0,used[1]=0;
	}
}
int main() {
	char ch;
	memset(tu,127,sizeof(tu));
	FOR(i,1,n)FOR(j,1,i) {
		ch=getchar();
		while ((ch!='.')&&((ch<'A')||(ch>'L')))  ch=getchar();
		if (ch=='.')  tu[i][j]=0;
		else  tu[i][j]=ch-'A'+1,used[tu[i][j]]=1;
	}
	for (int i=1,k=1; i<=n; i++) {
		for (int j=1; j<=k; j++)
			swap(tu[i][j],tu[11-j][11-i]);
		if (i<=4)k++;
		else k--;
	}
	dfs(1,1);
	printf("No solution");
	return 0;
}
```

---

## 作者：2021CHD (赞：2)

**本题解没有使用搜索算法（包括 DLX）。**

这是[题目链接](https://www.luogu.com.cn/problem/P4205)。

# 题目大意

有一个“智慧珠游戏”，有 $12$ 种珠子和一个三角形的棋盘，如下图。

![插图 1](https://cdn.luogu.com.cn/upload/image_hosting/rgy3adbi.png)

每种珠子都可以任意旋转和翻转，游戏目标是用珠子将棋盘填满。（每种珠子只能用一次）

给出一个填了一半的棋盘，保证棋盘合法，并且保证用珠子将棋盘填满的方案不超过一种，如果有解，复原出这个解，如果无解，输出 `No solution`。

# 解法

## 部分一

其实一开始没有想着做这道题的，只不过在翻洛谷的时候看到了这道题。由于我在小时候也玩过“智慧珠游戏”，所以我当时产生了一个疑问：“智慧珠游戏”合法的棋盘填充方案一共有几种呢？经过一番思考，我感觉可能很多，并且只得出答案是偶数的结论。（一个解沿棋盘斜边上的高线对称可以得到另一个解）

由于我很好奇，于是我想了一上午，得出了一个一定可以在我能接受的时间内求出答案的解法，以下是我的做法：（**和本题我的做法强相关，不要跳过**）

设计递推 $f_{x,y,S,T}$，表示当前填到 $x$ 行 $y$ 列的这个格子（这个格子是空的），剩余的珠子状态为 $S$，当前棋盘的状态为 $T$ 的方案数。

关于“棋盘状态”，我是这样考虑的：在第 $x$ 行上面以及在第 $x$ 行中第 $y$ 列左边的部分一定被填满了，第 $x$ 行第 $y$ 列这个格子一定是空的，所以不用记，剩下的部分有可能被填了，也有可能是空的，所以 $T$ 表示剩下部分的棋盘按行从小到大、列从小到大的顺序排列依次是否被填上。

但是 $T$ 最多会有多少位呢？

最坏情况就是下面这张图：（`*` 表示当前 DP 的位置，有颜色的格子表示已经填放的珠子，`G` 珠子未填放）

![插图 2](https://cdn.luogu.com.cn/upload/image_hosting/udtpz63j.png)

容易看出，$T<2^{24}=16777216$，于是可以用 `int` 类型存储，由于不知道实际状态数（我当时猜的可能是会过亿），所以我使用了 `unordered_map` 进行存储，转移时只枚举有用状态。（顺带一提，上面这个例子有唯一解）

那么如何转移呢？

由于每次转移（也就是填放珠子）的时候，这一格左边和上面的所有格子都被填满了，所以填的时候只能将一个状态的珠子最上最左的格子对准这个格子尝试填进去，我们称一个状态的珠子的这个位置为**关键位置**。

那每种珠子的旋转与翻转的情况就是自己动手打个表就可以完成的事情了，这里已经把表画好了，可以看一下：（箭头指向的就是这个状态的珠子的**关键位置**）

![插图 3.1](https://cdn.luogu.com.cn/upload/image_hosting/0p0pvy49.png)

![插图 3.2](https://cdn.luogu.com.cn/upload/image_hosting/44f81e3f.png)

![插图 3.3](https://cdn.luogu.com.cn/upload/image_hosting/k1wkvsl5.png)

然后就可以打出表：

```C++
const int rr=12,//珠子的种类数
num[20]={2,3,3,3,4,4,4,4,4,4,4,4},//珠子非关键位置覆盖的格子数
lim[20]={4,2,8,1,4,8,4,8,8,1,4,8},//珠子的状态数
//下面是珠子的状态的非关键位置相对关键位置的 x 坐标（正方向向下）
vx[20][20][20]={{{0,1},{0,1},{1,1},{1,1}},{{0,0,0},{1,2,3}},{{0,0,1},{0,1,2},{1,1,1},{1,2,2},{1,1,1},{0,1,2},{0,0,1},{1,2,2}},{{0,1,1}},{{1,2,2,2},{0,0,1,2},{1,2,2,2},{0,0,1,2}},{{0,0,0,1},{0,0,0,1},{1,1,1,1},{1,1,1,1},{1,1,2,3},{1,1,2,3},{1,2,2,3},{1,2,2,3}},{{0,0,1,1},{0,1,2,2},{0,1,1,1},{0,1,2,2}},{{0,0,1,1},{0,1,1,1},{0,0,1,1},{0,1,1,1},{1,1,2,2},{1,1,2,2},{0,1,1,2},{0,1,1,2}},{{0,0,1,1},{0,1,1,1},{0,1,1,1},{0,0,1,1},{1,2,2,3},{1,1,2,3},{1,2,2,3},{1,1,2,3}},{{1,1,1,2}},{{1,1,2,2},{0,1,1,2},{1,1,2,2},{0,1,1,2}},{{0,0,0,1},{0,0,0,1},{1,1,1,1},{1,1,1,1},{0,1,2,3},{0,1,2,3},{1,2,3,3},{1,2,3,3}}},
//下面是珠子的状态的非关键位置相对关键位置的 y 坐标（正方向向右）
vy[20][20][20]={{{1,0},{1,1},{0,1},{-1,0}},{{1,2,3},{0,0,0}},{{1,2,0},{1,1,1},{-2,-1,0},{0,0,1},{0,1,2},{1,0,0},{1,2,2},{0,-1,0}},{{1,0,1}},{{0,0,1,2},{1,2,0,0},{0,-2,-1,0},{1,2,2,2}},{{1,2,3,1},{1,2,3,2},{-1,0,1,2},{-2,-1,0,1},{-1,0,0,0},{0,1,0,0},{0,-1,0,0},{0,0,1,0}},{{1,2,0,2},{1,1,0,1},{2,0,1,2},{1,0,0,1}},{{1,2,0,1},{1,0,1,2},{1,2,1,2},{1,-1,0,1},{0,1,0,1},{-1,0,-1,0},{1,0,1,0},{1,0,1,1}},{{1,2,2,3},{1,1,2,3},{1,-2,-1,0},{1,2,-1,0},{0,0,1,1},{0,1,1,1},{0,-1,0,-1},{-1,0,-1,-1}},{{-1,0,1,0}},{{0,1,1,2},{1,1,2,2},{-1,0,-2,-1},{1,-1,0,-1}},{{1,2,3,0},{1,2,3,3},{0,1,2,3},{-3,-2,-1,0},{1,1,1,1},{1,0,0,0},{0,0,-1,0},{0,0,0,1}}};
```

然后只需要枚举一种剩下的珠子然后尝试把它以各种状态填进去就可以转移了，不过要注意由于相对 y 坐标可能是负的，所以可能需要把整个棋盘向右移动几个单位存放。

这是我当时写出来的[代码](https://www.luogu.com.cn/paste/0vt1nxij)。

出人意料的是，有用状态只有八百多万种，我也只等了十秒它就运行完了。

答案也只有 $32288$ 而不是当时预计的可能会超过 `int` 的表示范围。

## 部分二

那么此时，我发现了这道题其实就是求唯一解（或无解），而我已经写出了一个可以计算空棋盘方案数的做法，于是我想着：水一道紫题岂不是美事？于是计划先把我的代码修改成能输入一个棋盘并求出这个棋盘对应的方案数。

修改其实是不难的，只需要把输入的棋盘里已经填好的部分打上永久标记，然后在记录状态 $T$ 的时候不记录这些格子就可以了。

不过要注意这次 DP 不一定从左上角的第一格开始了，因为这一格可能已经被填满了，所以要找到第一个没有被填的格子，从那个格子开始 DP。（可能还需要特判一下初始时棋盘已放满的情况）

然后发现这样跑得比较慢，于是考虑加一个剪枝：由于最小的珠子都要占据 $3$ 个格子，所以如果一个状态形成了大小小于 $3$ 的连通块，那就可以不对这个状态进行下一步的转移。在实际操作的时候，我只判断了完全在状态 $T$ 表示范围内的部分的棋盘。

然后发现这样跑得不够快，就比如这两组数据：（显然无解）

![插图 4](https://cdn.luogu.com.cn/upload/image_hosting/5vdq8eah.png)

由于棋盘左上半边是空的，所以状态数就比较大，所以考虑当棋盘左上半边都是空的时候将棋盘转置后再求解，就像这样：（涂灰的部分就是棋盘左上半边）

![插图 5](https://cdn.luogu.com.cn/upload/image_hosting/xtm8dqgw.png)

（顺带一提，上面这个例子有唯一解）

于是这一步改进就愉快地完成了，[这里](https://www.luogu.com.cn/paste/bgxtk7cy)存放了这一份代码，并且我对这份代码的速度进行了一定量的检测，测试的结果存放在[这里](https://www.luogu.com.cn/paste/yptdvj5x)。

## 部分三

最后，就是要把这份代码改造成这道题的正解。

思路很简洁，只需要在转移的时候存储转移的来源，最后如果有解就从结束状态倒着推回去就可以了。

由于多写一遍转移会使得代码很长，所以可以不止记录转移的来源，还可以记录转移的方式，这样倒着推回去的时候就可以方便很多了。

到这里就做完了？

有这样一组毒瘤数据：（显然无解）

![插图 6](https://cdn.luogu.com.cn/upload/image_hosting/7ig9qx9k.png)

因为左上半边不是空的，所以棋盘不会转置，而左上角的 `K` 珠子对状态数的剪枝也是少的，右下角的 `D` 珠子对状态数的剪枝也是少的，最后导致了这种结果。

那还有什么办法呢？

其实到现在这道题还有一个特殊限制没用上：**保证最多只有一组解**。

那也就是说，如果一个状态被转移到了多次，就可以直接将这个状态舍去，因为它不可能转移到最后的答案处。当然这样做不能筛除所有存在多解的状态，但是可以筛除相当一部分，要修改的东西也很少。

这样，就可以跑过上面那一组毒瘤数据了。

这里放出 [AC 记录](https://www.luogu.com.cn/record/197669347)以及完整的代码，其实这个代码也不难写，只要把表打好，剩下的部分很自然地就写出来了，甚至都没怎么调就过了。我对这个代码进行了上百组测试，结果放在[这里](https://www.luogu.com.cn/paste/ux8wc1q1)，没有一组数据的运行时间或空间超过或逼近这题的限制。

```C++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<unordered_map>
using namespace std;
const int rr=12,num[20]={2,3,3,3,4,4,4,4,4,4,4,4},lim[20]={4,2,8,1,4,8,4,8,8,1,4,8},vx[20][20][20]={{{0,1},{0,1},{1,1},{1,1}},{{0,0,0},{1,2,3}},{{0,0,1},{0,1,2},{1,1,1},{1,2,2},{1,1,1},{0,1,2},{0,0,1},{1,2,2}},{{0,1,1}},{{1,2,2,2},{0,0,1,2},{1,2,2,2},{0,0,1,2}},{{0,0,0,1},{0,0,0,1},{1,1,1,1},{1,1,1,1},{1,1,2,3},{1,1,2,3},{1,2,2,3},{1,2,2,3}},{{0,0,1,1},{0,1,2,2},{0,1,1,1},{0,1,2,2}},{{0,0,1,1},{0,1,1,1},{0,0,1,1},{0,1,1,1},{1,1,2,2},{1,1,2,2},{0,1,1,2},{0,1,1,2}},{{0,0,1,1},{0,1,1,1},{0,1,1,1},{0,0,1,1},{1,2,2,3},{1,1,2,3},{1,2,2,3},{1,1,2,3}},{{1,1,1,2}},{{1,1,2,2},{0,1,1,2},{1,1,2,2},{0,1,1,2}},{{0,0,0,1},{0,0,0,1},{1,1,1,1},{1,1,1,1},{0,1,2,3},{0,1,2,3},{1,2,3,3},{1,2,3,3}}},vy[20][20][20]={{{1,0},{1,1},{0,1},{-1,0}},{{1,2,3},{0,0,0}},{{1,2,0},{1,1,1},{-2,-1,0},{0,0,1},{0,1,2},{1,0,0},{1,2,2},{0,-1,0}},{{1,0,1}},{{0,0,1,2},{1,2,0,0},{0,-2,-1,0},{1,2,2,2}},{{1,2,3,1},{1,2,3,2},{-1,0,1,2},{-2,-1,0,1},{-1,0,0,0},{0,1,0,0},{0,-1,0,0},{0,0,1,0}},{{1,2,0,2},{1,1,0,1},{2,0,1,2},{1,0,0,1}},{{1,2,0,1},{1,0,1,2},{1,2,1,2},{1,-1,0,1},{0,1,0,1},{-1,0,-1,0},{1,0,1,0},{1,0,1,1}},{{1,2,2,3},{1,1,2,3},{1,-2,-1,0},{1,2,-1,0},{0,0,1,1},{0,1,1,1},{0,-1,0,-1},{-1,0,-1,-1}},{{-1,0,1,0}},{{0,1,1,2},{1,1,2,2},{-1,0,-2,-1},{1,-1,0,-1}},{{1,2,3,0},{1,2,3,3},{0,1,2,3},{-3,-2,-1,0},{1,1,1,1},{1,0,0,0},{0,0,-1,0},{0,0,0,1}}};
unordered_map<int,long long> a[12][12][4100];
int i,j,k,l,m,n,o,p,r,t,u,q[20][20],z[20][20],s,ns,nnum,full=(1<<rr)-1,fl,zz;
long long v;
char in[20][20],tt;
void fill(int s1,int s2,int s3,int s4)
{
	long long i;
	int w1,w2,w3,w4,t1,t2;
	i=a[s1][s2][s3][s4];
	if(i<0)
	return;
	w1=i/100000000000000000;
	w2=i/1000000000000000%100;
	w3=i/100000000000%10000;
	w4=i/1000%100000000;
	t1=i/10%100;
	t2=i%10;
	in[w1][w2]=t1+'A';
	for(i=0;i<num[t1];i++)
	in[w1+vx[t1][t2][i]][w2+vy[t1][t2][i]]=t1+'A';
	fill(w1,w2,w3,w4);
}
main()
{
	for(i=1;i<=10;i++)
	scanf("%s\n",in[i]+1);
	for(i=0;i<=15;i++)
	for(j=0;j<=15;j++)
	q[i][j]=-1;
	for(i=1;i<=10;i++)
	for(j=1;j<=i;j++)
	q[i][j+3]=0;
	for(i=1;i<=10;i++)
	{
		for(j=1;j<=i;j++)
		if(i+j<=10&&in[i][j]!='.')
		break;
		if(j<=i)
		break;
	}
	if(i>10)
	{
		fl=1;
		for(i=1;i<=10;i++)
		for(j=1;j<=i;j++)
		if(i+j<=10)
		{
			tt=in[i][j];
			in[i][j]=in[11-j][11-i];
			in[11-j][11-i]=tt;
		}
	}
	for(i=1;i<=10;i++)
	for(j=1;j<=i;j++)
	if(in[i][j]!='.')
	{
		if(full&1<<in[i][j]-'A')
		full=full^1<<in[i][j]-'A';
		q[i][j+3]=2;
	}
	for(i=1;i<=10;i++)
	{
		for(j=1;j<=i;j++)
		if(in[i][j]=='.')
		break;
		if(j<=i)
		break;
	}
	if(i>10)
	{
		for(i=1;i<=10;i++)
		printf("%s\n",in[i]+1);
		return 0;
	}
	a[i][j][full][0]=-1;
	for(i=1;i<=10;i++)
	for(j=1;j<=i;j++)
	for(k=0;k<1<<rr;k++)
	for(auto pr:a[i][j][k])
	{
		s=pr.first;
		v=pr.second;
		if(v==-2)
		continue;
		zz=s;
		l=i;
		m=j;
		while(s)
		{
			m++;
			if(m>l)
			{
				l++;
				m=1;
			}
			if(q[l][m+3]<2)
			q[l][m+3]=s&1;
			s=s>>1;
		}
		s=zz;
		p=l;
		r=m;
		for(;l<=10;l++)
		{
			for(m++;m<=l;m++)
			{
				if(q[l][m+3]==1)
				q[l][m+3]=0;
				z[l][m]=0;
			}
			m=0;
		}
		q[i][j+3]=0;
		while(p>i||r>j)
		{
			if(q[p][r+3]==0)
			z[p][r]=(q[p-1][r+3]!=0)+(q[p+1][r+3]!=0)+(q[p][r-1+3]!=0)+(q[p][r+1+3]!=0);
			else
			z[p][r]=0;
			if(z[p][r]==4||z[p][r]+z[p+1][r]==6||z[p][r]+z[p][r+1]==6)
			break;
			r--;
			if(r==0)
			{
				p--;
				r=p;
			}
		}
		q[i][j+3]=1;
		if(p>i||r>j)
		continue;
		for(l=0;l<rr;l++)
		if(k&1<<l)
		for(n=0;n<lim[l];n++)
		{
			for(o=0;o<num[l];o++)
			if(q[i+vx[l][n][o]][j+3+vy[l][n][o]]!=0)
			break;
			if(o>=num[l])
			{
				for(o=0;o<num[l];o++)
				q[i+vx[l][n][o]][j+3+vy[l][n][o]]=1;
				p=i;
				r=j;
				while(q[p][r+3]>0)
				{
					r++;
					if(r>p)
					{
						p++;
						r=1;
					}
				}
				t=p;
				u=r;
				nnum=0;
				ns=0;
				while(nnum<24)
				{
					u++;
					if(u>t)
					{
						t++;
						u=1;
					}
					if(t>10)
					break;
					if(q[t][u+3]<2)
					ns=ns|q[t][u+3]<<nnum;
					nnum++;
				}
				if(a[p][r][k^1<<l][ns]==0)
				a[p][r][k^1<<l][ns]=i*100000000000000000ll+j*1000000000000000ll+k*100000000000ll+s*1000ll+l*10ll+n;
				else
				a[p][r][k^1<<l][ns]=-2;
				for(o=0;o<num[l];o++)
				q[i+vx[l][n][o]][j+3+vy[l][n][o]]=0;
			}
		}
	}
	if(a[11][1][0][0]==0)
	{
		printf("No solution");
		return 0;
	}
	fill(11,1,0,0);
	if(fl==1)
	for(i=1;i<=10;i++)
	for(j=1;j<=i;j++)
	if(i+j<=10)
	{
		tt=in[i][j];
		in[i][j]=in[11-j][11-i];
		in[11-j][11-i]=tt;
	}
	for(i=1;i<=10;i++)
	printf("%s\n",in[i]+1);
}
```

---

## 作者：Mr_cold (赞：1)

没什么说的，枚举所有情况即可，每种情况在代码中有标出，然后在卡个时间不要超时即可
~~~
#include<bits/stdc++.h>
#define pts putchar('\n');
#define ptc putchar(' ');
using namespace std;
typedef long long ll;
const int maxm=2e6+9;
const int maxn=2e5+9;
const int N=50+9;
const int mod=1e9+7;
const int inf=0x3f3f3f3f;
const double eps=1e-4;
char  G[N][N];
int in[maxn];
int timee=0;
char read(){
    char x=getchar();
    while(x!='.'&&(x>'Z'||x<'A')) x=getchar();
    return x;
}
int gett(){
    for(int i=1;i<=10;++i){
        for(int j=1;j<=i;++j){
            if(G[j][i]=='.') return 100*j+i;
        }
    }
}
int ok(){
    for(int i='A';i<='L';++i) if(in[i]==0) return 0;
    return 1;
}
void out(){
    for(int i=1;i<=10;++i){
        for(int j=1;j<=i;++j){
            putchar(G[j][i]);
        }pts;
    }
}
void dfs(){
    timee++;
    if(timee>5e6){puts("No solution");exit(0);}
    if(ok()) {out();exit(0);}
    int now=gett();
    int x=now/100,y=now%10;
    if(y==0) y=10;
	
    if(!in['A'])//4
    {
        if(G[x+1][y]=='.'&&G[x][y+1]=='.')// 下右 
        /*
            1 1 
            1 0     
        */
        {
            G[x][y]=G[x+1][y]=G[x][y+1]='A';in['A']=1; 
            dfs();
            G[x][y]=G[x+1][y]=G[x][y+1]='.';in['A']=0;
        }
        if(G[x+1][y+1]=='.'&&G[x][y+1]=='.')// 下左 
        /*
            1 1  
            0 1     
        */
        {
            G[x][y]=G[x+1][y+1]=G[x][y+1]='A';in['A']=1; 
            dfs();
            G[x][y]=G[x+1][y+1]=G[x][y+1]='.';in['A']=0;
        }
        if(G[x+1][y]=='.'&&G[x+1][y+1]=='.')//上右
        /*
            1 0
            1 1     
        */
        {
            G[x][y]=G[x+1][y]=G[x+1][y+1]='A';in['A']=1; 
            dfs();
            G[x][y]=G[x+1][y]=G[x+1][y+1]='.';in['A']=0;
        }
        if(G[x][y+1]=='.'&&G[x-1][y+1]=='.')// 上左
        /*
            0 1
            1 1     
        */
        {
            G[x][y]=G[x][y+1]=G[x-1][y+1]='A';in['A']=1; 
            dfs();
            G[x][y]=G[x][y+1]=G[x-1][y+1]='.';in['A']=0;
        }
    }
	if(!in['B'])//2
    {
        if(G[x+1][y]=='.'&&G[x+2][y]=='.'&&G[x+3][y]=='.')//垂直 
        /*
            1
            1
            1
            1
        */
        {
            G[x][y]=G[x+1][y]=G[x+2][y]=G[x+3][y]='B';in['B']=1;
            dfs();
            G[x][y]=G[x+1][y]=G[x+2][y]=G[x+3][y]='.';in['B']=0;
        }

        if(G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x][y+3]=='.')//水平 
        /*
            1 1 1 1
        */
        {
            G[x][y]=G[x][y+1]=G[x][y+2]=G[x][y+3]='B';in['B']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x][y+2]=G[x][y+3]='.';in['B']=0;
        }
    } 

    
    if(!in['C'])//8
    {
        if(G[x+1][y]=='.'&&G[x][y+1]=='.'&&G[x][y+2]=='.')//1
        {
            /*
                1 1 1
                1           
            */
            G[x][y]=G[x+1][y]=G[x][y+1]=G[x][y+2]='C';in['C']=1;
            dfs();
            G[x][y]=G[x+1][y]=G[x][y+1]=G[x][y+2]='.';in['C']=0;
        }   
        if(G[x][y+1]=='.'&&G[x+1][y+1]=='.'&&G[x+2][y+1]=='.')//2
        {
            /*
                1 1
                  1
                  1         
            */
            G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x+2][y+1]='C';in['C']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x+2][y+1]='.';in['C']=0;
        }
        if(G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x-1][y+2]=='.')//3
        {
            /*
                    1
                1 1 1
            */
            G[x][y]=G[x][y+1]=G[x][y+2]=G[x-1][y+2]='C';in['C']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x][y+2]=G[x-1][y+2]='.';in['C']=0;
        }
        if(G[x+1][y]=='.'&&G[x+2][y]=='.'&&G[x+2][y+1]=='.')//4
        {
            /*
                1
                1
                1 1
            */
            G[x][y]=G[x+1][y]=G[x+2][y]=G[x+2][y+1]='C';in['C']=1;
            dfs();
            G[x][y]=G[x+1][y]=G[x+2][y]=G[x+2][y+1]='.';in['C']=0;
        }
        if(G[x+1][y]=='.'&&G[x+1][y+1]=='.'&&G[x+1][y+2]=='.')//5
        {
            /*
                1
                1 1 1           
            */
            G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+1][y+2]='C';in['C']=1;
            dfs();
            G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+1][y+2]='.';in['C']=0;
        }
        if(G[x][y+1]=='.'&&G[x+1][y]=='.'&&G[x+2][y]=='.')//6
        {
            /*
                1 1
                1
                1           
            */
            G[x][y]=G[x][y+1]=G[x+1][y]=G[x+2][y]='C';in['C']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x+1][y]=G[x+2][y]='.';in['C']=0;
        }
        if(G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x+1][y+2]=='.')//7
        {
            /*
                1 1 1
                    1           
            */
            G[x][y]=G[x][y+1]=G[x][y+2]=G[x+1][y+2]='C';in['C']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x][y+2]=G[x+1][y+2]='.';in['C']=0;
        }
        if(G[x][y+1]=='.'&&G[x-1][y+1]=='.'&&G[x-2][y+1]=='.')//8
        {
            /*
                  1
                  1
                1 1
            */
            G[x][y]=G[x][y+1]=G[x-1][y+1]=G[x-2][y+1]='C';in['C']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x-1][y+1]=G[x-2][y+1]='.';in['C']=0;
        }
    } 

    if(!in['D'])//1
    {
        if(G[x+1][y]=='.'&&G[x][y+1]=='.'&&G[x+1][y+1]=='.')
        {
            /*
                1 1
                1 1         
            */
            G[x][y]=G[x+1][y]=G[x][y+1]=G[x+1][y+1]='D';in['D']=1;
            dfs();
            G[x][y]=G[x+1][y]=G[x][y+1]=G[x+1][y+1]='.';in['D']=0;
        }
    }

    if(!in['E'])//4
    {
        if(G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x-1][y+2]=='.'&&G[x-2][y+2]=='.')//1
        {
            /*
                    1
                    1
                1 1 1           
            */
            G[x][y]=G[x][y+1]=G[x][y+2]=G[x-1][y+2]=G[x-2][y+2]='E';in['E']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x][y+2]=G[x-1][y+2]=G[x-2][y+2]='.';in['E']=0;
        }
        if(G[x+1][y]=='.'&&G[x+2][y]=='.'&&G[x+2][y+1]=='.'&&G[x+2][y+2]=='.')//2
        {
            /*
                1
                1
                1 1 1

            */
            G[x][y]=G[x+1][y]=G[x+2][y]=G[x+2][y+1]=G[x+2][y+2]='E';in['E']=1;
            dfs();
            G[x][y]=G[x+1][y]=G[x+2][y]=G[x+2][y+1]=G[x+2][y+2]='.';in['E']=0;
        }
        if(G[x+1][y]=='.'&&G[x+2][y]=='.'&&G[x][y+1]=='.'&&G[x][y+2]=='.')//3
        {
            /*
                1 1 1
                1
                1
            */
            G[x][y]=G[x+1][y]=G[x+2][y]=G[x][y+1]=G[x][y+2]='E';in['E']=1;
            dfs();
            G[x][y]=G[x+1][y]=G[x+2][y]=G[x][y+1]=G[x][y+2]='.';in['E']=0;
        }
        if(G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x+1][y+2]=='.'&&G[x+2][y+2]=='.')//4
        {
            /*
                1 1 1
                    1
                    1           
            */
            G[x][y]=G[x][y+1]=G[x][y+2]=G[x+1][y+2]=G[x+2][y+2]='E';in['E']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x][y+2]=G[x+1][y+2]=G[x+2][y+2]='.';in['E']=0;
        }
    }

    if(!in['F'])//8
    {
        if(G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x][y+3]=='.'&&G[x+1][y+1]=='.')//1
        {
            /*
                1 1 1 1
                  1             
            */
            G[x][y]=G[x][y+1]=G[x][y+2]=G[x][y+3]=G[x+1][y+1]='F';in['F']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x][y+2]=G[x][y+3]=G[x+1][y+1]='.';in['F']=0;
        }
        if(G[x][y+1]=='.'&&G[x+1][y+1]=='.'&&G[x-1][y+1]=='.'&&G[x+2][y+1]=='.')//2
        {
            /*
                  1
                1 1
                  1
                  1
            */
            G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x-1][y+1]=G[x+2][y+1]='F';in['F']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x-1][y+1]=G[x+2][y+1]='.';in['F']=0;
        }
        if(G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x-1][y+2]=='.'&&G[x][y+3]=='.')//3
        {
            /*  
                       1
                   1 1 1 1
            */
            G[x][y]=G[x][y+1]=G[x][y+2]=G[x][y+3]=G[x-1][y+2]='F';in['F']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x][y+2]=G[x][y+3]=G[x-1][y+2]='.';in['F']=0;
        }
        if(G[x+1][y]=='.'&&G[x+2][y]=='.'&&G[x+2][y+1]=='.'&&G[x+3][y]=='.')//4
        {
            /*
                1
                1
                1 1
                1
            */
            G[x][y]=G[x+1][y]=G[x+2][y]=G[x+2][y+1]=G[x+3][y]='F';in['F']=1;
            dfs();
            G[x][y]=G[x+1][y]=G[x+2][y]=G[x+2][y+1]=G[x+3][y]='.';in['F']=0;
        }
        if(G[x][y+1]=='.'&&G[x-1][y+1]=='.'&&G[x][y+2]=='.'&&G[x][y+3]=='.')//5
        {
            /* 
                  1
                1 1 1 1
            */
            G[x][y]=G[x][y+1]=G[x-1][y+1]=G[x][y+2]=G[x][y+3]='F';in['F']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x-1][y+1]=G[x][y+2]=G[x][y+3]='.';in['F']=0;
        }
        if(G[x+1][y]=='.'&&G[x+1][y+1]=='.'&&G[x+2][y]=='.'&&G[x+3][y]=='.')//6
        {
            /*
                1 
                1 1 
                1 
                1
            */
            G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+2][y]=G[x+3][y]='F';in['F']=1;
            dfs();
            G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+2][y]=G[x+3][y]='.';in['F']=0;
        }
        if(G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x+1][y+2]=='.'&&G[x][y+3]=='.')//7
        {
            /*
                1 1 1 1 
                    1
            */
            G[x][y]=G[x][y+1]=G[x][y+2]=G[x+1][y+2]=G[x][y+3]='F';in['F']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x][y+2]=G[x+1][y+2]=G[x][y+3]='.';in['F']=0;
        }
        if(G[x][y+1]=='.'&&G[x+1][y+1]=='.'&&G[x-1][y+1]=='.'&&G[x-2][y+1]=='.')//4
        {
            /*
                1 
                1
              1 1 
                1
            */
            G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x-1][y+1]=G[x-2][y+1]='F';in['F']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x-1][y+1]=G[x-2][y+1]='.';in['F']=0;
        }
    }

    if(!in['G'])//4
    {
        if(G[x+1][y]=='.'&&G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x+1][y+2]=='.')//1
        {
            /*
                1 1 1 
                1   1
            */
            G[x][y]=G[x+1][y]=G[x][y+1]=G[x][y+2]=G[x+1][y+2]='G';in['G']=1;
            dfs();
            G[x][y]=G[x+1][y]=G[x][y+1]=G[x][y+2]=G[x+1][y+2]='.';in['G']=0;
        }
        if(G[x][y+1]=='.'&&G[x+1][y+1]=='.'&&G[x+2][y+1]=='.'&&G[x+2][y]=='.')//2
        {
            /*
                1 1
                  1
                1 1
            */
            G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x+2][y+1]=G[x+2][y]='G';in['G']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x+2][y+1]=G[x+2][y]='.';in['G']=0;
        }
        if(G[x+1][y]=='.'&&G[x+1][y+1]=='.'&&G[x+1][y+2]=='.'&&G[x][y+2]=='.')//3
        {
            /*
                1   1
                1 1 1
            */
            G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+1][y+2]=G[x][y+2]='G';in['G']=1;
            dfs();
            G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+1][y+2]=G[x][y+2]='.';in['G']=0;
        }
        if(G[x][y+1]=='.'&&G[x+1][y]=='.'&&G[x+2][y]=='.'&&G[x+2][y+1]=='.')//4
        {
            /*
                1 1 
                1  
                1 1
            */
            G[x][y]=G[x][y+1]=G[x+1][y]=G[x+2][y]=G[x+2][y+1]='G';in['G']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x+1][y]=G[x+2][y]=G[x+2][y+1]='.';in['G']=0;
        }
    }

    if(!in['H'])//8
    {
        if(G[x+1][y]=='.'&&G[x][y+1]=='.'&&G[x+1][y+1]=='.'&&G[x][y+2]=='.')//1
        {
            /*
                1 1 1
                1 1
            */
            G[x][y]=G[x+1][y]=G[x][y+1]=G[x+1][y+1]=G[x][y+2]='H';in['H']=1;
            dfs();
            G[x][y]=G[x+1][y]=G[x][y+1]=G[x+1][y+1]=G[x][y+2]='.';in['H']=0;
        }

        if(G[x+1][y]=='.'&&G[x][y+1]=='.'&&G[x+1][y+1]=='.'&&G[x+2][y+1]=='.')//2       
        {
            /*
                1 1
                1 1
                  1
            */
            G[x][y]=G[x+1][y]=G[x][y+1]=G[x+1][y+1]=G[x+2][y+1]='H';in['H']=1;
            dfs();
            G[x][y]=G[x+1][y]=G[x][y+1]=G[x+1][y+1]=G[x+2][y+1]='.';in['H']=0;
        }   
        if(G[x][y+1]=='.'&&G[x-1][y+1]=='.'&&G[x-1][y+2]=='.'&&G[x][y+2]=='.')//3
        {
            /*
                   1 1
                 1 1 1

            */
            G[x][y]=G[x][y+1]=G[x-1][y+1]=G[x-1][y+2]=G[x][y+2]='H';in['H']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x-1][y+1]=G[x-1][y+2]=G[x][y+2]='.';in['H']=0;
        }
        if(G[x+1][y]=='.'&&G[x+1][y+1]=='.'&&G[x+2][y]=='.'&&G[x+2][y+1]=='.')//4
        {
            /*
                1
                1 1
                1 1
            */
            G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+2][y]=G[x+2][y+1]='H';in['H']=1;
            dfs();
            G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+2][y]=G[x+2][y+1]='.';in['H']=0;
        }
        if(G[x+1][y]=='.'&&G[x][y+1]=='.'&&G[x+1][y+1]=='.'&&G[x+1][y+2]=='.')//5
        {
            /*
                1 1
                1 1 1
            */
            G[x][y]=G[x+1][y]=G[x][y+1]=G[x+1][y+1]=G[x+1][y+2]='H';in['H']=1;
            dfs();
            G[x][y]=G[x+1][y]=G[x][y+1]=G[x+1][y+1]=G[x+1][y+2]='.';in['H']=0;
        }
        if(G[x+1][y]=='.'&&G[x][y+1]=='.'&&G[x+1][y+1]=='.'&&G[x+2][y]=='.')//6
        {
            /*
                1 1
                1 1 
                1
            */
            G[x][y]=G[x+1][y]=G[x][y+1]=G[x+1][y+1]=G[x+2][y]='H';in['H']=1;
            dfs();
            G[x][y]=G[x+1][y]=G[x][y+1]=G[x+1][y+1]=G[x+2][y]='.';in['H']=0;
        }
        if(G[x][y+1]=='.'&&G[x+1][y+1]=='.'&&G[x][y+2]=='.'&&G[x+1][y+2]=='.')//7
        {
            /*
                1 1 1
                  1 1           
            */
            G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x][y+2]=G[x+1][y+2]='H';in['H']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x][y+2]=G[x+1][y+2]='.';in['H']=0;
        }
        if(G[x][y+1]=='.'&&G[x+1][y+1]=='.'&&G[x+1][y]=='.'&&G[x-1][y+1]=='.')//8
        {
            /*     
                    1
                  1 1
                  1 1           
            */
            G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x+1][y]=G[x-1][y+1]='H';in['H']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x+1][y]=G[x-1][y+1]='.';in['H']=0;
        }
    }

    if(!in['I'])//8
    {
        if(G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x+1][y+2]=='.'&&G[x+1][y+3]=='.')//1
        {
            /*     
                1 1 1
                    1 1         
            */
            G[x][y]=G[x][y+1]=G[x][y+2]=G[x+1][y+2]=G[x+1][y+3]='I';in['I']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x][y+2]=G[x+1][y+2]=G[x+1][y+3]='.';in['I']=0;
        }
        if(G[x+1][y]=='.'&&G[x][y+1]=='.'&&G[x-1][y+1]=='.'&&G[x-2][y+1]=='.')//2
        {
            /*     
                    1
                    1
                  1 1
                  1     
            */
            G[x][y]=G[x+1][y]=G[x][y+1]=G[x-1][y+1]=G[x-2][y+1]='I';in['I']=1;
            dfs();
            G[x][y]=G[x+1][y]=G[x][y+1]=G[x-1][y+1]=G[x-2][y+1]='.';in['I']=0;
        }
        if(G[x][y+1]=='.'&&G[x+1][y+1]=='.'&&G[x+1][y+2]=='.'&&G[x+1][y+3]=='.')//3
        {
            /*     
                    1 1
                      1 1 1 
            */
            G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x+1][y+2]=G[x+1][y+3]='I';in['I']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x+1][y+2]=G[x+1][y+3]='.';in['I']=0;
        }
        if(G[x][y+1]=='.'&&G[x-1][y+1]=='.'&&G[x+1][y]=='.'&&G[x+2][y]=='.')//4
        {
            /*     
                      1
                    1 1
                    1
                    1   
            */
            G[x][y]=G[x][y+1]=G[x-1][y+1]=G[x+1][y]=G[x+2][y]='I';in['I']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x-1][y+1]=G[x+1][y]=G[x+2][y]='.';in['I']=0;
        }
        if(G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x-1][y+2]=='.'&&G[x-1][y+3]=='.')//5
        {
            /*     
                    1 1
                1 1 1       
            */
            G[x][y]=G[x][y+1]=G[x][y+2]=G[x-1][y+2]=G[x-1][y+3]='I';in['I']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x][y+2]=G[x-1][y+2]=G[x-1][y+3]='.';in['I']=0;
        }
        if(G[x+1][y]=='.'&&G[x+2][y]=='.'&&G[x+2][y+1]=='.'&&G[x+3][y+1]=='.')//6
        {
            /*     
                1
                1
                1 1
                  1     
            */
            G[x][y]=G[x+1][y]=G[x+2][y]=G[x+2][y+1]=G[x+3][y+1]='I';in['I']=1;
            dfs();
            G[x][y]=G[x+1][y]=G[x+2][y]=G[x+2][y+1]=G[x+3][y+1]='.';in['I']=0;
        }
        if(G[x][y+1]=='.'&&G[x-1][y+1]=='.'&&G[x-1][y+2]=='.'&&G[x-1][y+3]=='.')//7
        {
            /*     
                  1 1 1
                1 1     
            */
            G[x][y]=G[x][y+1]=G[x-1][y+1]=G[x-1][y+2]=G[x-1][y+3]='I';in['I']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x-1][y+1]=G[x-1][y+2]=G[x-1][y+3]='.';in['I']=0;
        }
        if(G[x+1][y]=='.'&&G[x+1][y+1]=='.'&&G[x+2][y+1]=='.'&&G[x+3][y+1]=='.')//8
        {
            /*     
                  1
                  1 1
                    1
                    1   
            */
            G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+2][y+1]=G[x+3][y+1]='I';in['I']=1;
            dfs();
            G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+2][y+1]=G[x+3][y+1]='.';in['I']=0;
        }
    }

    if(!in['J'])//1
    {
        if(G[x][y+1]=='.'&&G[x+1][y+1]=='.'&&G[x-1][y+1]=='.'&&G[x][y+2]=='.')//1
        {
            /*     
                    1
                  1 1 1
                    1   
            */
            G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x-1][y+1]=G[x][y+2]='J';in['J']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x-1][y+1]=G[x][y+2]='.';in['J']=0;
        }
    }

    if(!in['K'])//4
    {
        if(G[x+1][y]=='.'&&G[x+1][y+1]=='.'&&G[x+2][y+1]=='.'&&G[x+2][y+2]=='.')//1
        {
            /*     
                   1
                   1 1
                     1 1
            */
            G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+2][y+1]=G[x+2][y+2]='K';in['K']=1;
            dfs();
            G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+2][y+1]=G[x+2][y+2]='.';in['K']=0;
        }
        if(G[x+1][y]=='.'&&G[x][y+1]=='.'&&G[x-1][y+1]=='.'&&G[x-1][y+2]=='.')//2
        {
            /*     
                    1 1
                  1 1
                  1
            */
            G[x][y]=G[x+1][y]=G[x][y+1]=G[x-1][y+1]=G[x-1][y+2]='K';in['K']=1;
            dfs();
            G[x][y]=G[x+1][y]=G[x][y+1]=G[x-1][y+1]=G[x-1][y+2]='.';in['K']=0;
        }
        if(G[x][y+1]=='.'&&G[x+1][y+1]=='.'&&G[x+1][y+2]=='.'&&G[x+2][y+2]=='.')//3
        {
            /*     
                  1 1
                    1 1
                      1
            */
            G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x+1][y+2]=G[x+2][y+2]='K';in['K']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x+1][y+2]=G[x+2][y+2]='.';in['K']=0;
        }
        if(G[x][y+1]=='.'&&G[x-1][y+1]=='.'&&G[x-1][y+2]=='.'&&G[x-2][y+2]=='.')//4
        {
            /*     
                      1 
                    1 1
                  1 1
            */
            G[x][y]=G[x][y+1]=G[x-1][y+1]=G[x-1][y+2]=G[x-2][y+2]='K';in['K']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x-1][y+1]=G[x-1][y+2]=G[x-2][y+2]='.';in['K']=0;
        }
    }

    if(!in['L'])//8
    {
        if(G[x+1][y]=='.'&&G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x][y+3]=='.')//1
        {
            /*     
                  1 1 1 1 
                  1
            */
            G[x][y]=G[x+1][y]=G[x][y+1]=G[x][y+2]=G[x][y+3]='L';in['L']=1;
            dfs();
            G[x][y]=G[x+1][y]=G[x][y+1]=G[x][y+2]=G[x][y+3]='.';in['L']=0;
        }
        if(G[x][y+1]=='.'&&G[x+1][y+1]=='.'&&G[x+2][y+1]=='.'&&G[x+3][y+1]=='.')//2
        {
            /*     
                  1 1
                    1
                    1
                    1 
            */
            G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x+2][y+1]=G[x+3][y+1]='L';in['L']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x+1][y+1]=G[x+2][y+1]=G[x+3][y+1]='.';in['L']=0;
        }
        if(G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x][y+3]=='.'&&G[x-1][y+3]=='.')//3
        {
            /*     
                        1
                  1 1 1 1
            */
            G[x][y]=G[x][y+1]=G[x][y+2]=G[x][y+3]=G[x-1][y+3]='L';in['L']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x][y+2]=G[x][y+3]=G[x-1][y+3]='.';in['L']=0;
        }
        if(G[x+1][y]=='.'&&G[x+2][y]=='.'&&G[x+3][y]=='.'&&G[x+3][y+1]=='.')//4
        {
            /*     
                    1
                    1
                    1
                    1 1
            */
            G[x][y]=G[x+1][y]=G[x+2][y]=G[x+3][y]=G[x+3][y+1]='L';in['L']=1;
            dfs();
            G[x][y]=G[x+1][y]=G[x+2][y]=G[x+3][y]=G[x+3][y+1]='.';in['L']=0;
        }
        if(G[x+1][y]=='.'&&G[x+1][y+1]=='.'&&G[x+1][y+2]=='.'&&G[x+1][y+3]=='.')//5
        {
            /*     
                   1
                   1 1 1 1 
            */
            G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+1][y+2]=G[x+1][y+3]='L';in['L']=1;
            dfs();
            G[x][y]=G[x+1][y]=G[x+1][y+1]=G[x+1][y+2]=G[x+1][y+3]='.';in['L']=0;
        }
        if(G[x][y+1]=='.'&&G[x+1][y]=='.'&&G[x+2][y]=='.'&&G[x+3][y]=='.')//6
        {
            /*     
                    1 1
                    1
                    1
                    1
            */
            G[x][y]=G[x][y+1]=G[x+1][y]=G[x+2][y]=G[x+3][y]='L';in['L']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x+1][y]=G[x+2][y]=G[x+3][y]='.';in['L']=0;
        }
        if(G[x][y+1]=='.'&&G[x][y+2]=='.'&&G[x][y+3]=='.'&&G[x+1][y+3]=='.')//7
        {
            /*     
                    1 1 1 1
                          1
            */
            G[x][y]=G[x][y+1]=G[x][y+2]=G[x][y+3]=G[x+1][y+3]='L';in['L']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x][y+2]=G[x][y+3]=G[x+1][y+3]='.';in['L']=0;
        }
        if(G[x][y+1]=='.'&&G[x-1][y+1]=='.'&&G[x-2][y+1]=='.'&&G[x-3][y+1]=='.')//8
        {
            /*     
                    1
                    1
                    1
                  1 1
            */
            G[x][y]=G[x][y+1]=G[x-1][y+1]=G[x-2][y+1]=G[x-3][y+1]='L';in['L']=1;
            dfs();
            G[x][y]=G[x][y+1]=G[x-1][y+1]=G[x-2][y+1]=G[x-3][y+1]='.';in['L']=0;
        }
    }
}
int main(){
//	freopen("123.txt","w",stdout);
    memset(in,0,sizeof(in));
    for(int i=1;i<=10;++i){
        for(int j=1;j<=i;++j){
            G[j][i]=read();
            if(G[j][i]!='.') in[G[j][i]]=1;
    	}
    }
    dfs();
    puts("No solution");
    return 0;
} 
~~~

---


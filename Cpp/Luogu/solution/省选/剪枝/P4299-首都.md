# 首都

## 题目描述

在 X 星球上有 $n$ 个国家，每个国家占据着 X 星球的一座城市，城市从 $1$ 至 $n$ 编号。由于国家之间是敌对关系，所以不同国家的两个城市是不会有公路相连的。

X 星球上战乱频发，如果 A 国打败了 B 国，那么 B 国将永远从这个星球消失，而 B 国的国土也将归 A 国管辖。A 国国王为了加强统治，会在 A 国和 B 国之间修建一条公路，即选择原 A 国的某个城市和 B 国某个城市，修建一条连接这两座城市的公路。

同样为了便于统治自己的国家，国家的首都会选在某个使得其他城市到它距离之和最小的城市，这里的距离是指需要经过公路的条数，如果有多个这样的城市，编号最小的将成为首都。

现在告诉你发生在 X 星球的战事，需要你处理一些关于国家首都的信息，具体地，有如下3种信息需要处理：

- `A x y`：表示某两个国家发生战乱，战胜国选择了 $x$ 城市和 $y$ 城市，在它们之间修建公路（保证其中城市一个在战胜国另一个在战败国）。
- `Q x`：询问当前编号为 $x$ 的城市所在国家的首都。
- `Xor`：询问当前所有国家首都编号的异或和。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 10^5$，$1 \leq m \leq 2 \times 10^5$，$1 \leq x, y \leq n$。

## 样例 #1

### 输入

```
10 10 
Xor 
Q 1 
A 10 1 
A 1 4 
Q 4 
Q 10 
A 7 6 
Xor 
Q 7 
Xor```

### 输出

```
11 
1 
1 
1 
2 
6 
2 
```

# 题解

## 作者：FlashHu (赞：26)

Update:原来的洛谷U21715已成坑qwq

已经被某位管理员巨佬放进公共题库啦！又可以多一个AC记录啦！

说不定用的是蒟蒻的数据呢，看看[P4299的](https://www.luogu.org/record/show?rid=7150888)和[U21715的](https://www.luogu.org/record/show?rid=7151024)两个记录，像是没什么区别。

那就直接从[博客题解](http://www.cnblogs.com/flashhu/p/8626003.html)（扌汇）过来吧qwq（这个字居然乱码？！）

## 思路分析

动态维护树的重心

题目中说到国家的首都会选在某个使得其他城市到它距离之和最小的城市，那不就是树的重心了嘛。树的重心性质真的很好，看看[wuhulala巨佬的这篇博客](http://blog.csdn.net/u013076044/article/details/45915745)。

维护子树信息是不会少的。在此基础上，网上大多数解法都是启发式合并。利用了以重心为根的子树大小不超过原树的一半，每次合并两颗树的时候，小的往大的上面合并，而且是一个点一个点地link上去，每次link完检查一下这个子树如果超过了当前整个树大小的一半，就把重心向当前点移动一下。这样做，合并次数上限$O(N\log N)$，每次更新重心也需要$O(\log N)$的复杂度，所以复杂度极限是$O(N\log^2N)$，还不够优秀。

因此我就想再优化一下算法。复杂度瓶颈就在于一个一个link，能不能考虑直接连接两颗树对重心的影响呢？

答案是肯定的。又要用到一个性质——连接两颗树后，新的重心一定在原来的两个重心的路径上。这个证明不难，反证一下就好了。

那就可以直接link然后把链提出来去找了。我们当然不能把整条链全找遍了，毕竟重心的性质那么多，也要好好利用嘛。

(下面s和si的定义和[蒟蒻的LCT总结](http://www.cnblogs.com/flashhu/p/8324551.html)中是一样的）

具体找法：类似树上二分，我们需要不断逼近树的重心的位置。记下lsum表示当前链中搜索区间左端点以左的子树大小，rsum表示右端点以右的。x的整个子树就表示了当前搜索区间，在中序遍历中x把搜索区间分成了左右两块（在Splay中对应x的左子树和右子树）。

如果x左子树的s加上lsum和x右子树的s加上rsum都不超过新树总大小的一半，那么x当然就是重心啦！当然，如果总大小是奇数，重心只会有一个，那就找到了。否则，因为必须编号最小，所以还要继续找下去。

当我们没有确定答案时，还要继续找下去，那么就要跳儿子了。x把整个链分成了左右两个部分，而重心显然会在大小更大的一部分中，这个也应该好证明。如果x左子树的s加上lsum小于x右子树的s加上rsum，那就跳右儿子继续找。这时候当前搜索区间减小了，搜索区间以外的部分增大了，lsum应该加上si[x]+1。反之亦然。如果跳进了空儿子，那肯定所有情况都考虑完了，直接结束查找。

当然，重心找到了就还是要伸展一下，保证复杂度。（蒟蒻造数据的时候懒得去卡了qwq）

这一部分套用Splay的复杂度，是均摊$O(\log N)$的，总复杂度也就降到了$O(N\log N)$。

findroot实在很慢，于是可以写个并查集来维护每个点所在树的重心。

```cpp
#include<cstdio>
#include<cstdlib>
#define R register int
#define I inline void
const int N=100009,INF=2147483647;
int f[N],c[N][2],si[N],s[N],h[N];
bool r[N];
#define lc c[x][0]
#define rc c[x][1]
inline bool nroot(R x){return c[f[x]][0]==x||c[f[x]][1]==x;}
I pushup(R x){
    s[x]=s[lc]+s[rc]+si[x]+1;
}
I pushdown(R x){
    if(r[x]){
        R t=lc;lc=rc;rc=t;
        r[lc]^=1;r[rc]^=1;r[x]=0;
    }
}
I pushall(R x){
    if(nroot(x))pushall(f[x]);
    pushdown(x);
}
I rotate(R x){
    R y=f[x],z=f[y],k=c[y][1]==x,w=c[x][!k];
    if(nroot(y))c[z][c[z][1]==y]=x;
    f[f[f[c[c[x][!k]=y][k]=w]=y]=x]=z;pushup(y);//为三行rotate打call
}
I splay(R x){
    pushall(x);
    R y;
    while(nroot(x)){
    	if(nroot(y=f[x]))rotate((c[f[y]][0]==y)^(c[y][0]==x)?x:y);
    	rotate(x);
    }
    pushup(x);
}
I access(R x){
    for(R y=0;x;x=f[y=x]){
        splay(x);
        si[x]+=s[rc];
        si[x]-=s[rc=y];
        pushup(x);
    }
}
I makeroot(R x){
    access(x);splay(x);
    r[x]^=1;
}
I split(R x,R y){
    makeroot(x);
    access(y);splay(y);
}
I link(R x,R y){
    split(x,y);
    si[f[x]=y]+=s[x];
    pushup(y);
}
int geth(R x){
    if(h[x]==x)return x;
    return h[x]=geth(h[x]);
}
inline int update(R x){
    R l,r,ji=s[x]&1,sum=s[x]>>1,lsum=0,rsum=0,newp=INF,nowl,nowr;
    while(x){
        pushdown(x);//注意pushdown
        nowl=s[l=lc]+lsum;nowr=s[r=rc]+rsum;
        if(nowl<=sum&&nowr<=sum){
            if(ji){newp=x;break;}//剪枝，确定已经直接找到
            else if(newp>x)newp=x;//选编号最小的
        }
        if(nowl<nowr)lsum+=s[l]+si[x]+1,x=r;
        else         rsum+=s[r]+si[x]+1,x=l;//缩小搜索区间
    }
    splay(newp);//保证复杂度
    return newp;
}
#define G ch=getchar()
#define gc G;while(ch<'-')G
#define in(z) gc;z=ch&15;G;while(ch>'-')z*=10,z+=ch&15,G;
int main(){
    register char ch;
    R n,m,x,y,z,Xor=0;
    in(n);in(m);
    for(R i=1;i<=n;++i)s[i]=1,h[i]=i,Xor^=i;
    while(m--){
    	gc;
    	switch(ch){
    		case 'A':in(x);in(y);link(x,y);
    			split(x=geth(x),y=geth(y));//提出原重心路径
    			z=update(y);
    			Xor=Xor^x^y^z;
    			h[x]=h[y]=h[z]=z;//并查集维护好
    			break;
    		case 'Q':in(x);printf("%d\n",geth(x));break;
    		case 'X':gc;gc;printf("%d\n",Xor);
    	}
    }
    return 0;
}
```

---

## 作者：jerry3128 (赞：12)

- 介绍一种不利用“新的重心在链接路径上的解法”，即支持自由 link cut 的维护重心方式。
- 首先直接拿重心的性质下手，最大的子树大小最小。
- 我们考虑在实链上二分的过程，那么它找出来的节点就是在这条带权树链上的“重心”。但是考虑到，有可能树的重心并不在当前的这条树链上面，那么我们就需要跳跃虚儿子转移边到达一个虚儿子进行搜索。
- 因为我们首先就在当前实链上面找到了最大子树最小的点，那么容易得到树的重心就在二分出节点的最大子树当中。
- 然后又是重复在那个虚儿子的实链再一次二分。
- 可以发现这就是一个递归的过程，比较好实现，大概就是这个样子。

```
int ask(int x,long long g,long long &value){
		if(!x)return 0;
		int res=0;
		long long lsz=g-v[x].sz,rsz=0,Vl=1e16,sum=1e16;
		while(x){
			if(get_value(x,lsz,rsz)<sum||(get_value(x,lsz,rsz)==sum&&x<res))res=x,sum=get_value(x,lsz,rsz);
			if(!v[x].ch[0]&&!v[x].ch[1])break;
			int lval=lsz+v[v[x].ch[0]].sz,rval=rsz+v[v[x].ch[1]].sz;
			if(lval<rval)lsz=lsz+v[v[x].ch[0]].sz+v[x].val+v[x].csz,x=v[x].ch[1];
			if(rval<lval)rsz=rsz+v[v[x].ch[1]].sz+v[x].val+v[x].csz,x=v[x].ch[0];
			if((v[x].ch[0]||v[x].ch[1])&&lval==rval)break;
		}
		x=ask(v[res].s.mxid(),g,Vl);
		if(Vl<sum||(Vl==sum&&x<res))res=x,sum=Vl;
		return value=sum,res;
	}
```

- 然后因为要维护虚儿子，我们第一时间想到的就是 multiset 维护，那显然这样做的复杂度就会平平变为 $\mathcal O(n\log^{2} n)$ 不优。
- 如果使用平衡树对虚儿子维护虽然能够降到 $\mathcal O(n\log n)$ 但是码量巨大，得不偿失。
- 返回来依着题目考虑：本题只有 link 操作，也就是说，一个节点的虚儿子减少的地方就发生在 access 过程中，将虚儿子掏出来变成实儿子的过程。
- 那么我们从信息维护的正确性出发：我们要维护最大的虚儿子，而我们又要求在时时刻刻维护的虚儿子取出来的信息与我们用 set 维护的信息是一样的。
- 那么可以发现，只维护虚儿子当中第一大和第二大就行了，不足的值可以直接不维护：

```
struct my_set{
	long long mx[B];
	my_set(){for(int i=0;i<B;i++)mx[i]=0;}
	void ins(long long val){for(int i=0;i<B;i++)if(mx[i]<val)swap(mx[i],val);}
	void del(long long val){
		for(int i=0;i<B;i++)
			if(val==mx[i]){	
				for(int j=i;j<B-1;j++)mx[j]=mx[j+1];	
				return mx[B-1]=0,void();	
		}
	}
	long long max(){return mx[0];}
	long long mxsz(){return mx[0]>>20;}
	int mxid(){return mx[0]&base;}
};
```

- 那么虚儿子信息的维护即可视为常数，时间复杂度 $\mathcal O(n\log n)$
- 简单的对查找的复杂度做出一个解释：
	- 可以将查找的过程看做一个 access 的逆过程：我们从上至下，每次不断的走过实虚转移边，最终抵达重心，中间不存在返回父亲等状况，且其中所有运算为 $\mathcal O(1)$ 的。
   - 所以每次求了答案以后要 access 重心。

---

## 作者：Refined_heart (赞：3)

题目大意：动态维护树重心。

$\text{Solution:}$

首先有一个关于重心的性质：

> 合并两棵树，新的重心必然在两个重心的连线上。

那么我们更新新的重心的范围就可以确定到这条链上了，处理的时候直接把路径提出来即可。

然后我们注意到，```Splay``` 的中序遍历组成了一个自上而下，也就是深度从小到大的原树的链。而重心需要满足最大子树的大小最小，所以我们就可以利用深度这一点去二分查找了。

这里需要知道：

> 树的重心的最大子树 $siz\leq $ 总大小的一半。

考虑当前 ```Splay``` 上走到的节点是 $x,$ 那么 $x$ 的子树就对应着一个区间，这个区间是重心所在的**深度区间**。

那么，如果 $x$ 就是重心，那么它就需要满足：这个点的左侧区间和右侧区间的 $siz$ 都需要小于等于总大小的一半。

考虑如何确定搜索区间：如果所有深度大于 $x$ 的节点数要大于左侧的，那么重心显然在右侧；否则显然在左侧。

而我们每次跳孩子都是一个舍弃一部分区间的过程。根显然把一个 ```Splay``` 分成了两部分，每一部分都是一个区间。

同时我们注意到，我们维护的 $siz$ 是指原树上 $x$ 的 $siz$ 大小，二分的时候不能只用 $siz[x]$ 来判断。

注意每次跳孩子的时候，舍弃的节点的 $siz$ 是没有重合的。每次舍弃的一定是整个的子树并且以后不会再走到它里面，所以每次舍弃的时候可以直接记录其 $siz$

那么考虑如何判断跳哪个孩子。对于当前 $x,$ 如果右侧点的 $siz$ 和要大于左侧的，那么重心就显然在右侧；否则一定在左侧。

对于 $x,$ 它的左子树就是 $x$ 子树对应区间 $x$ 左侧区间的点的 $siz$ 和。跳出 $x$ 的时候，由于只保留其右子树，所以还要把其虚子树的 $siz$ 加上。

于是就可以在类似线段树上二分查找一样 $O(\log n)$ 完成了。

总复杂度是 $O(n\log n)$

还有一种做法是，利用到每次加一个点只会使得重心最多偏移一条边的性质。这样我们把小的树启发式合并到大的树上，每次 $link$ 一个点，然后判断是否偏移即可。复杂度 $O(n\log^2 n)$

代码是 ```Splay``` 上二分查找，复杂度 $O(n\log n)$

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef double db;
//#define int long long
#define fi first
#define se second
#define mk make_pair
#define pb emplace_back
#define poly vector<int>
#define Bt(a) bitset<a>
#define bc __builtin_popcount
#define pc putchar
#define ci const int&
const int mod = 998244353;
const db eps = 1e-10;
const int inf = (1 << 30);
inline int Max(ci x, ci y) {return x > y ? x : y;}
inline int Min(ci x, ci y) {return x < y ? x : y;}
inline db Max(db x, db y) {return x - y > eps ? x : y;}
inline db Min(db x, db y) {return x - y < eps ? x : y;}
inline int Add(ci x, ci y, ci M = mod) {return (x + y) % M;}
inline int Mul(ci x, ci y, ci M = mod) {return x*y%M;}
inline int Dec(ci x, ci y, ci M = mod) {return (x - y + M) % M;}
typedef pair<int, int> pii;
inline int Abs(int x) {return x < 0 ? -x : x;}
//char buf[1<<21],*p1=buf,*p2=buf;
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char Obuf[105000],*O=Obuf;//Siz shoule be the size of Out File
int pst[30],ptop;
inline void Fprint(){fwrite(Obuf,1,O-Obuf,stdout);}
inline void Fwrite(int x){
  if(x==0){*O++='0';return;}
  if(x<0)*O++='-',x=-x;ptop=0;
  while(x)pst[++ptop]=x%10,x/=10;
  while(ptop)*O++=pst[ptop--]+'0';
  if(O-Obuf>100000)Fprint(),O=Obuf;
}
inline int read() {
    int s = 0, w = 1;
    char ch = getchar();
    while (!isdigit(ch)) {if (ch == '-') w = -1;ch = getchar();}
    while (isdigit(ch)) {s = s * 10 + ch - '0';ch = getchar();}
    return s * w;
}
inline void write(int x) {
    if (x < 0)putchar('-'), x = -x;
    if (x > 9)write(x / 10);
	pc(x % 10 + '0');
}
inline int qpow(int x, int y) {
    int res = 1;
    while (y) {if (y & 1)res = Mul(res, x);x = Mul(x, x);y >>= 1;}
    return res;
}
inline void cadd(int &x, int y) {x += y;}
inline void cmul(int &x, int y) {x *= y;}
inline void cmax(int &x, int y) {x = Max(x, y);}
inline void cmin(int &x, int y) {x = Min(x, y);}
const int N = (1<<20)+10;
namespace Refined_heart{
	struct LCT{
		int ch[N][2],f[N],rev[N],siz[N],si[N];
		
		inline void pushup(int x){
			siz[x]=siz[ch[x][0]]+siz[ch[x][1]]+si[x]+1;
		}
		inline void pushr(int x){
			if(!x)return;
			swap(ch[x][0],ch[x][1]);
			rev[x]^=1;
		}
		inline void pushdown(int x){
			if(rev[x]){
				pushr(ch[x][1]),pushr(ch[x][0]);
				rev[x]^=1;
			}
		}
		inline int nroot(int x){return ch[f[x]][0]==x||ch[f[x]][1]==x;}
		void pushall(int x){
			if(nroot(x))pushall(f[x]);
			pushdown(x);
		}
		inline void rotate(int x){
			int y=f[x],z=f[y],k=(ch[y][1]==x),w=ch[x][k^1];
			if(nroot(y))ch[z][ch[z][1]==y]=x;ch[x][k^1]=y;ch[y][k]=w;
			if(w)f[w]=y;f[y]=x;f[x]=z;pushup(y);pushup(x);
		}
		void splay(int x){
			int y=0,z=0;
			pushall(x);
			while(nroot(x)){
				y=f[x],z=f[y];
				if(nroot(y))rotate((ch[y][0]==x)^(ch[z][0]==y)?x:y);
				rotate(x);
			}
			pushup(x);
		}
		void access(int x){
			for(int y=0;x;y=x,x=f[x]){
				splay(x);
				si[x]+=siz[ch[x][1]];
				si[x]-=siz[ch[x][1]=y];
				pushup(x);
			}
		}
		void makeroot(int x){
			access(x);
			splay(x);
			pushr(x);
		}
		int findroot(int x){
			access(x);splay(x);
			while(ch[x][0])pushdown(x),x=ch[x][0];
			splay(x);return x;
		}
		void split(int x,int y){
			makeroot(x);
			access(y);
			splay(y);
		}
		void link(int x,int y){
			makeroot(x);
			if(findroot(y)!=x){
				f[x]=y;
				si[y]+=siz[x];
				pushup(y);
			}
		}
		void cut(int x,int y){
			makeroot(x);
			if(findroot(y)==x&&f[y]==x&&!ch[y][0]){
				f[y]=ch[x][1]=0;
				pushup(x);
			}
		}
	}T; 
	int n,m,xorans;
	int ff[N];
	char opt[4];
	inline int find(int x){return x==ff[x]?x:ff[x]=find(ff[x]);}
	int Getit(int root,int S){
		int lsum=0,rsum=0;
		int now=root;
		int rt=inf;
		S>>=1;
		while(now){
			T.pushdown(now);
			int x=now;
			int R=rsum+T.siz[T.ch[x][1]];
			int L=lsum+T.siz[T.ch[x][0]];
			if(L<=S&&R<=S)cmin(rt,now);
			if(R>L)lsum+=T.siz[T.ch[now][0]],lsum+=T.si[x],lsum++,now=T.ch[now][1];
			else rsum+=T.siz[T.ch[now][1]],rsum+=T.si[x],rsum++,now=T.ch[now][0];
		}
		return rt;
	}
	void solve(){
		n=read();m=read();
		for(int i=1;i<=n;++i)ff[i]=i,xorans^=i;
		for(int i=1;i<=m;++i){
			cin>>opt;
			if(opt[0]=='A'){
				int x=read(),y=read();
				T.link(x,y);
				int fx=find(x);
				int fy=find(y);
				T.split(fx,fy);
				xorans^=fx;
				xorans^=fy;
				int S=T.siz[fy];
				int root=Getit(fy,S);
				xorans^=root;
				T.splay(root);
				ff[fx]=ff[fy]=ff[root]=root;
				continue; 
			}
			if(opt[0]=='Q'){
				int x=read();
				write(find(x));
				pc('\n');
				continue;
			}
			if(opt[0]=='X'){
				write(xorans);
				pc('\n');
				continue;
			}
		}
//		Fprint();
	}
}
signed main(){
  	freopen("in.txt","r",stdin);
//  	freopen("My.out","w",stdout);
	Refined_heart::solve();
	return 0;
}


```


---

## 作者：mzgwty (赞：3)

这里提供一种实用性比较广的做法，该做法支持动态 Link，Cut，查询某个连通块的重心

做法基于如下性质：

如果一个点存在某个儿子的 size 大于等于点数的一半，那么重心在这个儿子的子树中

于是我们可以用 LCT 维护子树 size，查询某个点所在连通块的重心时，我们先找到连通块的一个点，将它作为根进行分治

分治时对于 $x$ 的左右儿子和虚儿子逐一判断，如果 size 都小于等于点数的一半，那么 $x$ 就是树的一个重心。

如果存在一个点 size 大于等于点数的一半，那么向这个儿子递归

注意向某个儿子移动时原树上的节点不会在该儿子的内部被计算，我们需要维护当前这条链的两端外面分别还有的点数

放一下查询的代码

```cpp
inline void query(int x) {
	int tot,t=0;makeroot(x),tot=sz[x];
	int l=0,r=0;
	while(pushdown(x),x) {
		int y=c[x].empty()?0:(*(c[x].rbegin())).id;
		if(y) splay(y);
		if(sz[rc]+r<=tot/2&&sz[lc]+l<=tot/2&&sz[y]<=tot/2) res[++t]=x;
		if(sz[rc]+r>=tot/2) l+=sz[x]-sz[rc],x=rc;
		else if(sz[lc]+l>=tot/2) r+=sz[x]-sz[lc],x=lc;
		else if(sz[y]>=tot/2) l+=r+sz[x]-sz[y],r=0,x=y;
		else break ;
	}
	sort(res+1,res+t+1);
	access(res[1]),splay(res[1]);
}
```

不清楚精细实现能不能做到一个 $\log$




---

## 作者：Good_Day_ (赞：2)

- 介绍一种不用 LCT，但空间复杂度为 $O(n \log n)$，时间复杂度为 $O(m \log^2 n)$ 的**离线**做法。

题目要求支持的操作有 $3$ 种：

1. 加边合并两棵树
2. 查询一棵树的重心编号
3. 查询所有树重心编号的异或和

- 发现每次加边操作会让原本两棵树的重心编号失去贡献，添加一个重心编号产生贡献，所以在进行操作 $3$ 的时候我们只需要先查出原本两棵树的重心，再查出合并后树的重心就可以维护所有树重心编号的异或和。

- 这样问题就转化成了动态维护多棵树的重心。
- 在树上找到一个点 $x$，满足 $size_{root} \leq size_x \times 2 $，且 $x$ 最深， $x$ 即为树的重心。（所有符合条件的点都在同一条从叶子到根的路径上）

- 因为所有满足 $size_{root} \leq size_x \times 2 $ 的点都在同一条链上，所以对于任意满足 $dfn_x \leq dfn_y$ 的 $x,y$，都有 $dep_x \leq dep_y $。

- 所以对于每一棵树，我们开一个动态开点线段树进行维护，每个节点维护区间  $[l,r]$，维护了所有满足 $l \leq dfn_x \leq r$ 的 $x$ 的 $size_x$ 的最大值，这样可以进行线段树二分，求出这棵树的重心。

- 这个题不要求强制在线，而且操作只有加边没有删边，所以可以考虑先离线把森林建出来，后续加边操作便可以看做是一棵树的根成为了另一棵树的一个叶子节点的儿子。（这里和 P4219 [BJOI2014]大融合 很像）

- 再考虑连边操作所造成的影响。假设一条边的两个端点为 $u$ 和 $v$，且 $dep_u<dep_v$，那么在我们预先建出的森林上来看，一定有节点 $v$ 的父亲是节点 $u$。这条边连好以后，从节点 $u$ 到包含节点 $u$ 的树的根的 $size$ 都会增加 $size_v$，且用来维护两棵树重心的线段树需要合并。这样我们可以把连边操作看作是进行一次链加和一次线段树合并。为了实现链加操作，我们需要在一开始的时候把森林进行重链剖分。然后就做完了。
- 谢谢 Alan_Zhao 对做法的一些建议。

[代码云剪贴板](https://www.luogu.com.cn/paste/j1z7nidz) 

实现细节：
- 我写的时候没用标记永久化，所以 `down` 操作写的比较玄学，没有在下放的时候新建节点，但是正确性也能保证： 
每次对于一棵树的链加操作，我们一定是在给存在于这棵树上的一些节点加 $x$，而这些节点一定在线段树上有其对应的叶子。所以对于一次有效的 `down` （$x \neq 0$）来说，不可能会给一些不存在于这棵树上的节点对应的位置加 $x$，也就不可能在下放的时候访问原本没有的节点。

- 线段树合并的时候也要 `down`。

- 一棵树可能会有 $2$ 个重心，需要取编号较小的那个，当你找到的重心 $g$ 满足 $size_g \times 2 = size_{root}$ 时，意味着 $g$ 的父亲也是重心，需要特判一下。





---

## 作者：Terac (赞：2)

[$\text{Link}$](https://www.luogu.com.cn/problem/P4299)  

一个 LCT + 二分查找重心的做法。

## 题意  

给定一个森林，支持以下操作：

+ `A x y`：连接 $x,y$。  
+ `Q x`：查询点 $x$ 所在树的重心。  
+ `Xor`：查询所有树的重心编号的异或和。  

简化版题意：动态维护树重心。  

## 题解 

对于节点 $x$，维护 $siz_x$ 和 $tot_x$，分别表示 $x$ 总子树大小（包括虚边所连的节点）和 $x$ 的虚儿子个数（认父不认子）。  

对于连边操作，直接调用 LCT 的 $link$ 操作即可，但为了维护上面两个量，可以先 $split$ 后再更新。  

维护重心需要两个性质：

1. 以重心为根的最大的子树节点数小于总节点数的一半。

2. 连接两棵树后，新的重心必定在两棵树原重心的路径上。  
  
  
两个性质都可用反证法证，令 $csiz_u$ 表示点 $u$ 最大子树的大小。

对于性质 1，若 $csiz_u$ 大于所有节点数的一半，则存在这颗子树中的一点 $v$，$csiz_v<cisz_u$，所以重心必不是 $u$，假设不成立，性质 1 得证（这个很好理解，画图就看得出来）。  

对于性质 2，设点 $u,v$ 为原两棵树的重心，两棵树的大小分别为 $sum_u,sum_v$， 若点 $x$ 在 $u$ 所在的树上且不在 $u$ 到 $v$ 的路径上，那么新增了一棵子树，必会让 $csiz_x$ 增加 $sum_v$，又因为性质 1，原先 $csiz_x>\frac{sum_u}{2}$，所以连接另一棵树后 $csiz_x>\frac{sum_u+sum_v}{2}$，由性质 1 知 $x$ 不是新树的重心，假设不成立，性质 2 得证。
![](https://cdn.luogu.com.cn/upload/image_hosting/7hoccgov.png?x-oss-process=image/resize,m_lfit,h_1500,w_1500)  

如图，两棵树重心分别是 $1$ 和 $2$。  
![](https://cdn.luogu.com.cn/upload/image_hosting/6e5arn9p.png?x-oss-process=image/resize,m_lfit,h_1500,w_1500)  

连接 $6,7$ 后，对于不在两树重心上的 $5$ 和 $3$，他们最大子树节点数必定增加，便不可能是重心。  

为了方便处理，用重心来代表一棵树，再用并查集维护，每个点的并查集存所在树的重心，连边后就把原来两棵树重心 $split$ 成一条链。对于链上的点 $u$，会把链分为两部分，用 $lsum,rsum$ 维护 $u$ 左右两边的子树和。然后根据比较左右儿子 $lsum$ 和 $rsum$ 的大小，选择子树较大的儿子，直到满足性质 1，再 $splay(u)$ 保证复杂度。  

需要注意，当树的大小为奇数时，只有一个重心，树的大小为偶数时可能会有多个重心，要找序号最小的。  

具体细节看代码叭。  

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
struct Link_Cut_Tree {
	struct node {
		int fa, ch[2], siz, tot;
		bool tag;
	} t[N];
	bool nroot(int x) { return t[t[x].fa].ch[0] == x || t[t[x].fa].ch[1] == x; }
	void pushup(int x) { t[x].siz = t[t[x].ch[0]].siz + t[t[x].ch[1]].siz + 1 + t[x].tot; }
	void pushr(int x) {
		swap(t[x].ch[0], t[x].ch[1]);
		t[x].tag ^= 1;
	}
	void pushdown(int x) {
		if(!t[x].tag) return;
		if(t[x].ch[0]) pushr(t[x].ch[0]);
		if(t[x].ch[1]) pushr(t[x].ch[1]);
		t[x].tag = 0;
	}
	void pushdown_path(int x) {
		if(nroot(x))
			pushdown_path(t[x].fa);
		pushdown(x);
	}
	void rotate(int x) {
		int y = t[x].fa, z = t[y].fa, ych = t[y].ch[1] == x, w = t[x].ch[!ych];
		if(nroot(y)) t[z].ch[t[z].ch[1] == y] = x;
		t[x].ch[!ych] = y, t[y].ch[ych] = w;
		if(w) t[w].fa = y;
		t[y].fa = x, t[x].fa = z;
		pushup(y);
	}
	void splay(int x) {
		pushdown_path(x);
		int y;
		while(nroot(x)) {
			y = t[x].fa;
			if(nroot(y))
				rotate(t[y].ch[1] == x ^ t[t[y].fa].ch[1] == y ? x : y);
			rotate(x);
		}
		pushup(x);
	}
	void access(int x) {
		for(int y = 0; x; x = t[y = x].fa)
			splay(x), t[x].tot += t[t[x].ch[1]].siz - t[y].siz, t[x].ch[1] = y, pushup(x);
	}
	void makeroot(int x) {
		access(x);
		splay(x);
		pushr(x);
	}
	int findroot(int x) {
		access(x);
		splay(x);
		while(t[x].ch[0]) pushdown(x), x = t[x].ch[0];
		splay(x);
		return x;
	}
	void split(int x, int y) {
		makeroot(x);
		access(y);
		splay(y);
	}
	void link(int x, int y) {
		split(x, y);
		t[t[x].fa = y].tot += t[x].siz;
		pushup(y);
	}
	int dfs(int x) {
		int lsum = 0, rsum = 0, sum = t[x].siz >> 1, bre = t[x].siz & 1, u = 1e9, curl, curr;
		for(;x;) {
			pushdown(x);
			curl = lsum + t[t[x].ch[0]].siz;
			curr = rsum + t[t[x].ch[1]].siz;
			if(curl <= sum && curr <= sum) {
				if(bre) {
					u = x;
					break;
				}
				u = min(u, x);
			}
			if(curl < curr) {
				lsum += t[t[x].ch[0]].siz + t[x].tot + 1;
				x = t[x].ch[1];
			}
			else {
				rsum += t[t[x].ch[1]].siz + t[x].tot + 1;
				x = t[x].ch[0];
			}
		}
		splay(u);
		return u;
	}
} LCT;
int n, m;
int fa[N], ans;
int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
int main() {
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++)
		fa[i] = i, ans ^= i;
	char op[3];
	int x, y;
	while(m--) {
		scanf("%s", op);
		if(op[0] == 'A') {
			scanf("%d%d", &x, &y);
			LCT.link(x, y);
			x = find(x), y = find(y);
			LCT.split(x, y);
			int g = LCT.dfs(y);
			ans ^= x ^ y ^ g;
			fa[x] = fa[y] = fa[g] = g;
		}
		else if(op[0] == 'Q') {
			scanf("%d", &x);
			printf("%d\n", find(x));
		}
		else printf("%d\n", ans);
	}
	return 0;
}
```

这道题挺难理解的，最好是自己可以画画图。

---

## 作者：chen_qian (赞：2)

动态维护重心模板。

题面要求重心作为答案，不妨把每一个联通块用并查集来维护，代表结点就是重心。

那么现在考虑如何维护重心。

这里有一个性质，如果两棵树合并在了一起，那么新的重心一定在这两棵树的重心的路径上。

那么我们不妨就把两个重心 $x$ 和 $y$ 之间的路径给分离出来。放到一颗 splay 然后用类似树上二分的思路来解决。

这里又要用到重心的一个性质，那就是重心的各个子树大小都小于整棵树大小的一半，即最大的一部分小于整棵树大小的一半。

如下图

![](https://cdn.luogu.com.cn/upload/image_hosting/3xjsqohq.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

$A$,$B$ 是要合并的两颗树，$a$ 和 $b$ 分别是重心，我们现在查找到的是 $x$ 节点。

显然，$x$ 最大的子树部分一定是 $x$ 到 $a$ 路径上的所有节点及其子树或是 $x$ 到 $b$ 路径上的所有节点及其子树，因为 $a$ 除过 路径上的点，子树大小大于 $\frac{size(A)}{2}$，同理 $b$。$x$ 必然是在 $A$,$B$ 其中一颗的。所以其本身的子树一定没有两边的大。

所以维护 $suml$ 与 $sumr$ 表示左右各有多少。所以还要维护子树信息，具体怎么维护，建议做一下[这个题](https://www.luogu.com.cn/problem/P4219)。然后剩下的就比较简单了。

```
#include<bits/stdc++.h>
#define N 100005
using namespace std;
int fa[N],ch[N][2],xr,size[N],size2[N],rev[N];
int f[N];
int n,m;
int find(int x){
	if(x==f[x]) return x;
	return f[x]=find(f[x]);
}
void push_up(int x){
	size[x]=size[ch[x][1]]+size[ch[x][0]]+1+size2[x];
}
void push_down(int x){
	if(rev[x]){
		rev[x]=0;
		swap(ch[x][0],ch[x][1]);
		rev[ch[x][0]]^=1;
		rev[ch[x][1]]^=1;
	}
}
bool get(int x){
	return x==ch[fa[x]][1];
}
bool isroot(int x){
	return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x;
}
void rotate(int x){
	int y=fa[x],z=fa[y],chk=get(x);
	if(!isroot(y)) ch[z][ch[z][1]==y]=x;
	ch[y][chk]=ch[x][chk^1];
	fa[ch[x][chk^1]]=y;
	ch[x][chk^1]=y;
	fa[y]=x;
	fa[x]=z;
	push_up(y);
	push_up(x);
}
void update(int x){
	if(!isroot(x)) update(fa[x]);
	push_down(x);
}
void splay(int x){
	update(x);
	for(int f;f=fa[x],!isroot(x);rotate(x)){
		if(!isroot(f)) rotate(get(x)==get(f)?f:x); 
	}
	push_up(x);
}
void access(int x){
	int p;
	for(p=0;x;p=x,x=fa[x]){
		splay(x);
		size2[x]+=size[ch[x][1]]-size[p];
		ch[x][1]=p;
		push_up(x);
	}
}
int findroot(int x){
	access(x);
	splay(x);
	while(ch[x][0]){
		push_down(x);
		x=ch[x][0];
	}
	return x;
}
void makeroot(int x){
	access(x);
	splay(x);
	rev[x]^=1;
}
void split(int x,int y){
	makeroot(x);
	access(y);
	splay(y);
}
void link(int x,int y){
	makeroot(x);
	splay(x);
	makeroot(y);
	splay(y);
	fa[x]=y;
	size2[y]+=size[x]; 
}
int search(int x){
	int suml=0,sumr=0,sum=size[x]>>1,isodd=size[x]&1,now=2e9,xx,yy; 
    while(x){
        push_down(x);
        xx=suml+size[ch[x][0]];yy=sumr+size[ch[x][1]];
        if(xx<=sum&&yy<=sum){
            if(isodd){now=x;break;}
            else if(x<now) now=x;
        }
        if(xx<yy)suml+=size[ch[x][0]]+size2[x]+1,x=ch[x][1];
        else sumr+=size[ch[x][1]]+size2[x]+1,x=ch[x][0];
    }
    return now;
} 
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) f[i]=i,xr^=i;
	while(m--){
		string op;
		cin>>op;
		int x,y;
		if(op=="Q"){
			scanf("%d",&x);
			int ans=find(x);
			printf("%d\n",ans);
		}
		else if(op=="A"){
			scanf("%d%d",&x,&y);
			link(x,y);
			x=find(x),y=find(y);
			split(x,y);
			int z=search(y);
			//cout<<z<<endl;
			xr=xr^x^y^z;
			f[x]=f[y]=f[z]=z;
		}
		else printf("%d\n",xr); 
	}
	return 0;
}
```


---

## 作者：KiDDOwithTopTree (赞：2)

题目在这：[传送门](https://www.luogu.com.cn/problem/P4299)。

~~话说这题为什么题解那么少…~~

### 做法：LCT+启发式合并。

%%%[FlashHu](https://www.luogu.com.cn/user/61325) 大佬。

这位大佬已经讲清楚 $O(nlogn)$ 的算法了，那么我就来补一发 $O(nlog^2n)$ 的启发式合并算法。

这一个题目是要动态求重心。重心有一个性质是：一棵树添加或者删除一个节点，树的重心最多只移动一条边的位置。那么我们可以把一个国家一个个点来拆分出来，一个个合并到另一个国家上。

### 注意：这里的合并必须要按照原来的点的顺序来合并，即合并顺序不能乱。

但是这样很容易被卡。有什么可以优化合并呢？**启发式合并**，你值得拥有！

启发式合并是指每一次把个数小集合的合并到个数大集合的上。这样可以证明，总时间复杂度为 $O(nlogn)$，均摊为 $O(logn)$。~~我有一个绝妙的证明方法，可惜这里位置太小，写不下~~。

那么我们可以通过**两次** **dfs** 来实现：第一次把原来个数小的 LCT 上的边断掉，第二次把这些点都一个个合并到另一个 LCT 上。

那么问题来了：怎么把边给找到并且在 LCT 上断掉呢？

~~我真笨，我因为这个问题从2020想到了2021…~~

害，当时沉迷 LCT，我居然忘了普通的存图方法。这里我用的是**链式前向星**。

有了链式前向星不就舒服了吗？

因为只是在指定点连边，那么说明其他边是不会更改的，那么就只需要在指定点连一条边，**其他边不需要变动**。这是与 LCT 不同的一点。

那么 dfs1 就可以很容易地写出来了。

放上 dfs1 的代码：

```cpp
void dfs1(int u,int fa){
	for(int i=last[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v!=fa){
			cut(u,v);//LCT上断边
			dfs1(v,u);
		}
	}
}
```

dfs2 算是一个难点。看上去就只用连边加判断，却让我想了半天…

对于每一个点，我们要先求出有可能成为新的首都的那个点。

可以证明，可能的新首都肯定会在旧首都靠近新点的位置。具体证明可以用反证法。

那么我们可以把这一条路径分离出来，再找新首都。

怎么找呢？

假设分出来后旧首都是 LCT 的根，那么我们要找的就是比旧首都深度多1的点，即为旧首都的后继。

放上找后继的代码：

```cpp
int get_suc(int pos){
	splaying(pos);
	pushdown(pos);
	pos=spl[pos].son[1];
	pushdown(pos);
	while(spl[pos].son[0]){
		pos=spl[pos].son[0];
		pushdown(pos);//记得要pushdown
	}
	splaying(pos);//保证复杂度
	return pos;
}
```

怎么找一个点的首都呢？

因为我们是每加一个点，就对首都进行更新，很明显直接通过一次 $fa$ 就找到首都显然是不可能的。所以我们要跳多次 $fa$ 来找首都。这很明显就是**并查集**。我们可以用并查集来找。

判断首都就是看新首都和旧首都的大小。主要都在函数注释里有了。

那么这样，就可以写出 dfs2 的代码了。

放上 dfs2 的代码：

```cpp
void dfs2(int u,int fa){
	link(u,fa);//LCT上连边
	int rf=find(fa);//找到首都
	split(rf,u);//分出来首都到当前点的路径，注意顺序不能反
	int rt=get_suc(rf);//因为新的首都只可能移动一个点，所以在以rf为根的splay上找到rf的后继节点就是可能的新首都了
	split(rt,rf);//分离路径，消除其他影响
	if(spl[rt].size*2>spl[rf].size||spl[rt].size*2==spl[rf].size&&rt<rf)//rt满足要求
		f[u]=f[rf]=f[rt]=rt;//u、rf的fa换成rt，而rt成为根，也要把fa变为rt
	else
		f[u]=rf;//只有u的fa才需要变
	for(int i=last[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v!=fa)
			dfs2(v,u);
	}
}
```

最后就是 merge 函数了：

```cpp
void merge(int x,int y){
	make_root(x);
	make_root(y);
//成根后才可以判断大小关系
	int fx=find(x),fy=find(y);//找首都
	ans^=fx^fy;//消除之前的首都
	if(spl[x].size<spl[y].size)
		swap(x,y);//启发式合并
	dfs1(y,0);
	dfs2(y,x);
//2次dfs
	add(x,y);
	add(y,x);
//链式前向星加边
	ans^=find(x);//加上新首都
}
```

这一题要维护的是虚儿子的子树大小，所以需要加上亿些东西。可以去康康 [FlashHu](https://www.luogu.com.cn/user/61325) 大佬的 [LCT 总结](https://www.cnblogs.com/flashhu/p/9498517.html)。

这是全部的代码：

```cpp
#include<iostream>
#include<cstring>
using namespace std;
const int N=1e6+10;
struct edge{
	int from,to;
	int nxt;
};
struct splay{
	int size,i_size;
	int fa,son[2];
	int rev;
};
edge e[N];
splay spl[N];
string s;
int last[N],f[N];
int tot,ans;
inline void add(int from,int to){
	tot++;
	e[tot].from=from;
	e[tot].to=to;
	e[tot].nxt=last[from];
	last[from]=tot;
}
inline int find(int x){
	return f[x]==x?x:f[x]=find(f[x]);
}
inline bool check_root(int pos){
	return spl[spl[pos].fa].son[0]!=pos&&spl[spl[pos].fa].son[1]!=pos;
}
inline int relation(int pos,int fa){
	return spl[fa].son[1]==pos;
}
inline void connect(int pos,int fa,int son){
	spl[pos].fa=fa;
	spl[fa].son[son]=pos;
}
inline void pushup(int pos){
	int lson=spl[pos].son[0],rson=spl[pos].son[1];
	spl[pos].size=spl[lson].size+spl[rson].size+spl[pos].i_size+1;
}
inline void pushdown(int pos){
	if(!spl[pos].rev)
		return ;
	swap(spl[pos].son[0],spl[pos].son[1]);
	spl[spl[pos].son[0]].rev^=1;
	spl[spl[pos].son[1]].rev^=1;
	spl[pos].rev=0;
}
inline void pushall(int pos){
	if(!check_root(pos))
		pushall(spl[pos].fa);
	pushdown(pos);
}
void rotate(int pos){
	int fa=spl[pos].fa,gf=spl[fa].fa;
	int t1=relation(pos,fa),t2=relation(fa,gf);
	connect(spl[pos].son[t1^1],fa,t1);
	connect(fa,pos,t1^1);
	spl[pos].fa=gf;
	if(spl[gf].son[t2]==fa)
		spl[gf].son[t2]=pos;
	pushup(fa);
	pushup(pos);
}
void splaying(int pos){
	pushall(pos);
	while(!check_root(pos)){
		int fa=spl[pos].fa,gf=spl[fa].fa;
		if(!check_root(fa))
			relation(pos,fa)^relation(fa,gf)?rotate(pos):rotate(fa);
		rotate(pos);
	}
}
void access(int pos){
	int son=0;
	while(pos){
		splaying(pos);
		spl[pos].i_size+=spl[spl[pos].son[1]].size-spl[son].size;
		spl[pos].son[1]=son;
		pushup(pos);
		son=pos;
		pos=spl[pos].fa;
	}
}
void make_root(int pos){
	access(pos);
	splaying(pos);
	spl[pos].rev^=1;
}
int get_suc(int pos){
	splaying(pos);
	pushdown(pos);
	pos=spl[pos].son[1];
	pushdown(pos);
	while(spl[pos].son[0]){
		pos=spl[pos].son[0];
		pushdown(pos);
	}
	splaying(pos);
	return pos;
}
void link(int x,int y){
	make_root(x);
	access(y);
	splaying(y);
	spl[x].fa=y;
	spl[y].i_size+=spl[x].size;
	pushup(y);
}
void cut(int x,int y){
	make_root(x);
	access(y);
	splaying(y);
	spl[x].fa=spl[y].son[0]=0;
	pushup(y);
}
void split(int x,int y){
	make_root(x);
	access(y);
	splaying(y);
}
void dfs1(int u,int fa){
	for(int i=last[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v!=fa){
			cut(u,v);
			dfs1(v,u);
		}
	}
}
void dfs2(int u,int fa){
	link(u,fa);
	int rf=find(fa);
	split(rf,u);
	int rt=get_suc(rf);
	split(rt,rf);
	if(spl[rt].size*2>spl[rf].size||spl[rt].size*2==spl[rf].size&&rt<rf)
		f[u]=f[rf]=f[rt]=rt;
	else
		f[u]=rf;
	for(int i=last[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v!=fa)
			dfs2(v,u);
	}
}
void merge(int x,int y){
	make_root(x);
	make_root(y);
	int fx=find(x),fy=find(y);
	ans^=fx^fy;
	if(spl[x].size<spl[y].size)
		swap(x,y);
	dfs1(y,0);
	dfs2(y,x);
	add(x,y);
	add(y,x);
	ans^=find(x);
}
int main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		ans^=i;
		f[i]=i;
		spl[i].size=1;
	}
	int x,y;
	for(int i=1;i<=m;i++){
		cin>>s;
		switch(s[0]){
			case 'A':
				cin>>x>>y;
				merge(x,y);
				break;
			case 'Q':
				cin>>x;
				cout<<find(x)<<'\n';
				break;
			case 'X':
				cout<<ans<<'\n';
				break;
		}
	}
}
```

---

## 作者：执着之幻 (赞：0)

## 题目大意：

初始时给出包含 $n$ 个互不联通的点所组成的森林，然后给出一些操作：

操作一：在两个点连一条边；

操作二：询问当前点所在的树的重心，若这棵树存在两个重心，则编号较小的一个为此树的重心；

操作三：询问整片森林每棵树的重心的异或和。

## 题目分析：

根据本题的标签可以看到，此题将需要采用 LCT 来动态维护树的重心。所以建议先把 LCT 的基本操作弄明白，再来做此题。

把 LCT 的一些基本操作弄明白后，再回来看到这题，可以发现，操作一便是 LCT 的最基本的操作：连边；所以此题求解的关键即在如何用 LCT 来维护树的重心。

我们需要用到一些有关树的重心的一些性质：首先树的重心的定义为：在一棵树中，若当前节点的所有儿子中，最大的儿子节点数是当前这棵树中其他节点的最大儿子节点数中最小的，那么这个节点就为这颗树的重心。根据这个定义，我们可以推出一棵树的重心可能为一个，但最多仅有两个。根据题目的要求，如果存在两个重心的情况，就要找出编号更小的那个节点；解决这道题目还有一个关于树的重心的性质：连接两颗树后，新树的重心一定在原来两棵树的重心的链上。

根据上面的性质，我们就可以利用 LCT 的基本操作来解决这道题了。操作一：我们先把两个点连接上，然后维护新树的重心，把原来两个点所在的树的重心找出来，然后把这两个点接在一个 splay 上，然后我们就通过类似二分的方法在这条链上查找新的重心，设当前访问的节点为 $x$ ，如果左子树的节点和右子树的节点均小于等于整颗树的节点的一半，那么我们就可以知道当前节点为重心，否则如果左子树节点小于右子树，则往右递归查找，否则往左查找。因为树的重心和子树大小有关系，所以我们需要用到在 LCT 上维护当前节点的整个子树大小的操作，由于 LCT 可以直接进行子树大小相加减操作，所以我们只需要在 access 的时候，记录一下当前节点虚边子树的大小总和，最后加在当前节点中即为当前节点所有节点的大小。操作二：直接查找当前节点所在的树的重心即可；操作三：每次进行操作一，我们可以发现原来的两个重心被剔除，加入了新的重心，再利用异或和中两个相同的数异或为 $0$，所以在总答案上一起异或上那三个重心即为新的答案。

## Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,f[110000],ans;
struct ll
{
	int ls,rs,fa,sz,tg,sz2;
}tr[110000];
char ch[10];
int find(int x)
{
	if(f[x]==x)return x;
	else return f[x]=find(f[x]);
}
void ud(int x)
{
	if(!x)return;
	tr[x].sz=tr[tr[x].ls].sz+tr[tr[x].rs].sz+tr[x].sz2+1;
}
void pd(int x)
{
	if(!x)return;
	if(tr[x].tg)
	{
		swap(tr[x].ls,tr[x].rs);
		tr[tr[x].ls].tg^=1;
		tr[tr[x].rs].tg^=1;
		tr[x].tg=0;
	}
}
bool irt(int x)
{
	if(tr[tr[x].fa].ls==x||tr[tr[x].fa].rs==x)return 0;
	else return 1;
}
void work(int x)
{
	if(!irt(x))work(tr[x].fa);
	pd(x);
}
void zuo(int x)
{
	int y=tr[x].fa;
	int z=tr[y].fa;
	if(!irt(y))
	{
		if(tr[z].ls==y)tr[z].ls=x;
		else tr[z].rs=x;
	}
	tr[x].fa=z;
	tr[y].rs=tr[x].ls;
	if(tr[x].ls)tr[tr[x].ls].fa=y;
	tr[x].ls=y;
	tr[y].fa=x;
	ud(y);
	ud(x);
}
void you(int x)
{
	int y=tr[x].fa;
	int z=tr[y].fa;
	if(!irt(y))
	{
		if(tr[z].ls==y)tr[z].ls=x;
		else tr[z].rs=x;
	}
	tr[x].fa=z;
	tr[y].ls=tr[x].rs;
	if(tr[x].rs)tr[tr[x].rs].fa=y;
	tr[x].rs=y;
	tr[y].fa=x;
	ud(y);
	ud(x);
}
void sy(int x)
{
	work(x);
	while(!irt(x))
	{
		int y=tr[x].fa;
		if(irt(y))
		{
			if(tr[y].ls==x)you(x);
			else zuo(x);
		}
		else
		{
			int z=tr[y].fa;
			if(tr[z].ls==y&&tr[y].ls==x)you(y),you(x);
			else if(tr[z].ls==y&&tr[y].rs==x)zuo(x),you(x);
			else if(tr[z].rs==y&&tr[y].rs==x)zuo(y),zuo(x);
			else you(x),zuo(x);
		}
	}
}
void acs(int x)
{
	int y=0;
	while(x)
	{
		sy(x);
		tr[x].sz2=tr[x].sz2-tr[y].sz+tr[tr[x].rs].sz;
		tr[x].rs=y;
		ud(x);
		y=x;
		x=tr[x].fa;
	}
}
int frt(int x)
{
	acs(x);
	sy(x);
	pd(x);
	while(tr[x].ls)x=tr[x].ls,pd(x);
	return x;
}
void mrt(int x)
{
	acs(x);
	sy(x);
	tr[x].tg^=1;
}
void lk(int x,int y)
{
	if(frt(x)==frt(y))return;
	mrt(x);
	tr[x].fa=y;
	tr[y].sz2+=tr[x].sz;
}
int gg(int x)
{
	int fl=tr[x].sz%2;
	int k=tr[x].sz>>1,l,r,lm=0,rm=0,sl,sr,np=1e9;
	while(x)
	{
		pd(x);
		l=tr[x].ls;
		r=tr[x].rs;
		sl=tr[l].sz+lm;
		sr=tr[r].sz+rm;
		if(sl<=k&&sr<=k)
		{
			if(fl)
			{
				np=x;
				break;
			}
			else if(np>x)np=x;
		}
		if(sl<sr)lm+=tr[l].sz+tr[x].sz2+1,x=r;
		else rm+=tr[r].sz+tr[x].sz2+1,x=l;
	}
	sy(np);
	return np;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)ans^=i,f[i]=i,tr[i].sz=1;
	while(m--)
	{
		int x,y;
		scanf("%s",ch);
		if(ch[0]=='A')
		{
			scanf("%d%d",&x,&y);
			lk(x,y);
			x=find(x);
			y=find(y);
			mrt(x);
			acs(y);
			sy(y);
			int nw=gg(y);
			ans=ans^x^y^nw;
			f[x]=f[y]=f[nw]=nw;
		}
		if(ch[0]=='Q')
		{
			scanf("%d",&x);
			printf("%d\n",find(x));
		}
		if(ch[0]=='X')printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：SrsgPrince_ (赞：0)

# Luogu P4299 首都 Solution

题目传送门：[Luogu P4299 首都](https://www.luogu.com.cn/problem/P4299)。

推荐在我的 [博客](https://www.luogu.com.cn/blog/fy123333/LuoguP4299Solution) 中查看。

## 题目分析 Hint

先放上题目：

题目如下：

在 X 星球上有 $n$ 个国家，每个国家占据着 X 星球的一座城市，城市从 $1$ 至 $n$ 编号。开始时国家之间不会相连。

如果两国合并，A 国国王为了加强统治会修建一条连接这两座城市的公路。国家的首都会选在某个使得其他城市到它距离之和最小的城市。

有三种操作：

- `A x y`：表示某两个国家发生战乱，战胜国选择了 $x$ 城市和 $y$ 城市，在它们之间修建公路（保证其中城市一个在战胜国另一个在战败国）。
- `Q x`：询问当前编号为 $x$ 的城市所在国家的首都。
- `Xor`：询问当前所有国家首都编号的异或和。

数据方面：$1 \leq n \leq 1 \times 10^5, 1 \leq m \leq 2 \times 10^5$

首先看到“国家的首都会选在某个使得其他城市到它距离之和最小的城市”就可以知道这道题要维护树的重心。那么形式化来说，这道题第一个操作是加边合并树，第二个是查找树的重心编号，第三个是重心编号的异或和。那么需要支持动态的加边，考虑使用 LCT 来维护。

## 思路 Solution

维护子树不必多说，维护每个节点的子树大小和节点的虚儿子个数。接下来更新重心，在连接树之后，我们可以启发式合并，每 link 一次去看上次的重心是否还符合性质，不符合往前偏，但是复杂度略高。这里有一个性质很重要，合并树的时候，新的重心必定在之前两棵树重心的路径上，根据这个性质，我们可以在这条链上的去二分查找它的重心。根据重心性质——以重心为根的最大的子树节点数小于总结点数的一半，我们去统计这条链左端点的左子树大小和右端点的右子树大小，统计出来后和性质一比就能找到了，如果还是没有找到，接下去去跳儿子，统计出来那边偏大就往哪里跳。最后 $\operatorname{splay()}$ 一次保证复杂度，注意当树节点个数为偶数时可能用多个重心，这时候要找序号最小的。查找重心的复杂度就是 $O(\log n)$。刚才说到的启发式合并是 $O(\log^2 n)$。那么总复杂度，一个 $O(n \log n)$，一个 $O(n \log^2 n)$。都能过这道题，这里放上前者做法的代码，为了找根好找，用并查集维护重心。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 10, inf = INT_MAX;
int n, m, x, y, z, xr = 0;
int fa[maxn], chd[2][maxn], siz[maxn], sum[maxn], h[maxn];
bool rev[maxn];
char ch;
inline void pushUp(int x) {
    sum[x] = sum[chd[0][x]] + sum[chd[1][x]] + siz[x] + 1; // 子树大小加上虚儿子个数
}
inline void pushDown(int x) {
    if (rev[x]) {
        swap(chd[0][x], chd[1][x]);
        rev[chd[0][x]] ^= 1;
        rev[chd[1][x]] ^= 1;
        rev[x] = 0;
    }
}
inline bool nRoot(int x) {
    return chd[0][fa[x]] == x || chd[1][fa[x]] == x;
}
inline void pushAll(int x) {
    if (nRoot(x))
        pushAll(fa[x]);
    pushDown(x);
}
inline void rotate(int x) {
    int y = fa[x], z = fa[y], k = chd[1][y] == x, w = chd[!k][x];
    if (nRoot(y))
        chd[chd[1][z] == y][z] = x;
    chd[!k][x] = y;
    chd[k][y] = w;
    fa[w] = y;
    fa[y] = x;
    fa[x] = z;
    pushUp(y);
}
inline void splay(int x) {
    pushAll(x);
    while (nRoot(x)) {
        int y = fa[x];
        if (nRoot(y))
            rotate((chd[0][fa[y]] == y) ^ (chd[0][y] == x) ? x : y);
        rotate(x);
    }
    pushUp(x);
}
inline void access(int x) {
    for (int y = 0; x; x = fa[y = x]) {
        splay(x);
        siz[x] += sum[chd[1][x]];
        siz[x] -= sum[chd[1][x] = y];
        pushUp(x);
    }
}
inline void makeRoot(int x) {
    access(x);
    splay(x);
    rev[x] ^= 1;
}
inline void split(int x, int y) {
    makeRoot(x);
    access(y);
    splay(y);
}
inline void link(int x, int y) {
    split(x, y);
    siz[fa[x] = y] += sum[x];
    pushUp(y);
}
inline int find(int x) { // 并查集维护重心
    return (h[x] == x) ? x : h[x] = find(h[x]);
}
inline int update(int x) {
    int lft, rgt, j = sum[x] & 1, s = sum[x] >> 1, lsum = 0, rsum = 0, newp = inf, nowl, nowr; // lsum 是链左端点的左子树大小，rsum 同理
    while (x) {
        pushDown(x);
        nowl = sum[lft = chd[x][0]] + lsum;
        nowr = sum[rgt = chd[x][1]] + rsum;
        // 上面是统计大小
        if (nowl <= s && nowr <= s) {
            if (j) {
                newp = x;
                break;
            } else if (newp > x)
                newp = x; // 编号最小的
        }
        if (nowl < nowr) 
            lsum += sum[lft] + siz[x] + 1, x = rgt;
        else 
            rsum += sum[rgt] + siz[x] + 1, x = lft;
    }
    splay(newp);
    return newp;
}
signed main() {
    cin >> n >> m;
    for (int i = 1; i <= n; ++i)
        sum[i] = 1, h[i] = i, xr ^= i;
    while (m--) {
        ch = getchar();
        while (ch < '-') ch = getchar();
        switch(ch) {
            case 'A': {
                cin >> x >> y;
                link(x, y);
                split(x = find(x), y = find(y)); // 重心
                z = update(y);
                xr = xr ^ x ^ y ^ z;
                h[x] = h[y] = h[z] = z;
                break;
            }
            case 'Q': {
                cin >> x;
                cout << find(x) << "\n";
                break;
            }
            case 'X': {
                ch = getchar();
                while (ch < '-') ch = getchar();
                ch = getchar();
                while (ch < '-') ch = getchar();
                cout << xr << "\n";
                break;
            }
        }
    }
    return 0;
}
```


---


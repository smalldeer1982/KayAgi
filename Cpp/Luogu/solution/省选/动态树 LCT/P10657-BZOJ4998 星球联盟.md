# BZOJ4998 星球联盟

## 题目描述

在遥远的 S 星系中一共有 $n$ 个星球，编号为 $1\sim n$。其中的一些星球决定组成联盟，以方便相互间的交流。但是，组成联盟的首要条件就是交通条件。

初始时，在这 $n$ 个星球间有 $m$ 条太空隧道。每条太空隧道连接两个星球，使得它们能够相互到达。若两个星球属于同一个联盟，则必须存在一条环形线路经过这两个星球，即两个星球间存在两条没有公共隧道的路径。为了壮大联盟的队伍，这些星球将建设 $p$ 条新的太空隧道。这 $p$ 条新隧道将按顺序依次建成。一条新轨道建成后，可能会使一些星球属于同一个联盟。

你的任务是计算出，在一条新隧道建设完毕后，判断这条新轨道连接的两个星球是否属于同一个联盟，如果属于同一个联盟就计算出这个联盟中有多少个星球。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/qo7hp42y.png)

数据保证，$1\leq n,m,p \leq 2\times 10^5$。

## 样例 #1

### 输入

```
5 3 4
1 2
4 3
4 5
2 3
1 3
4 5
2 4```

### 输出

```
No
3
2
5```

# 题解

## 作者：AN6M (赞：4)

我的做法不同于清一色的 LCT，只需要用到最小生成树和并查集。

考虑把每条边赋一个权值 $t$ 表示加入图的时间，从这张图上扯出一个最小生成树森林。

考虑依次在树上加边，对于一条要加入的边可以暴力往上加边，对于每一条树边第一次加入的必然是它本身。在第二次加边的时候就形成了环，可以用并查集合并两个节点。由于每条边最多加两次，所以总复杂度可以做到 $O(n\alpha(n))$。

这里偷懒写了一个 $O(n\log n)$ 的写法。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define N 200010
int n,m,q,tot,fa[N],dep[N],siz[N],trfa[N],s[N],sum[N];
bool vis[N];
struct stu{
    int u,v,tim;
    friend bool operator<(stu a,stu b){
        return a.tim<b.tim;
    }
}e[N<<1],ask[N],g[N];
vector<int>to[N];
int find(int x){
    return fa[x]==x?x:fa[x]=find(fa[x]);
}
void merge(int x,int y){
    x=find(x);
    y=find(y);
    if(x==y){
        return;
    }
    if(siz[x]<siz[y]){
        swap(x,y);
    }
    fa[y]=x;
    siz[x]+=siz[y];
    sum[x]+=sum[y];
}
void mergetofa(int x,int y){
    x=find(x);
    y=find(y);
    if(x==y){
        return;
    }
    fa[y]=x;
    sum[x]+=sum[y];
}
void dfs(int x,int fa){
    vis[x]=1;
    trfa[x]=fa;
    dep[x]=dep[fa]+1;
    for(int i=0;i<to[x].size();i++){
        int y=to[x][i];
        if(y==fa){
            continue;
        }
        dfs(y,x);
    }
}
void MERGE(int x,int y){
    if(find(x)==find(y)){
        return;
    }
    x=find(x);
    y=find(y);
    while(find(y)!=find(x)){
        if(dep[find(x)]>dep[find(y)]){
            swap(x, y);
        }
        if(!s[y]){
            s[y]++;
        }
        else{
            mergetofa(find(trfa[y]),y);
        }
        y=find(trfa[y]);
    }
}
signed main(){
    cin>>n>>m>>q;
    for(int i=1;i<=n;i++){
        fa[i]=i;
        siz[i]=1;
    }
    for(int i=1;i<=m;i++){
        tot++;
        cin>>e[tot].u>>e[tot].v;
        e[tot].tim=0;
        // cout<<e[tot].u<<' '<<e[tot].v<<' '<<e[tot].tim<<'\n';
        g[i]=e[tot];
    }
    for(int i=1;i<=q;i++){
        cin>>ask[i].u>>ask[i].v;
        ask[i].tim=i;
        e[++tot]=ask[i];
        // cout<<e[tot].u<<' '<<e[tot].v<<' '<<e[tot].tim<<'\n';
    }
    int added=0;
    sort(e+1,e+tot+1);
    for(int i=1;i<=tot;i++){
        if(added==n-1){
            break;
        }
        int x=find(e[i].u),y=find(e[i].v);
        if(x==y){
            continue;
        }
        merge(x,y);
        added++;
        to[e[i].u].push_back(e[i].v);
        to[e[i].v].push_back(e[i].u);
        // cout<<e[i].u<<' '<<e[i].v<<' '<<e[i].tim<<'\n';
    }
    for(int i=1;i<=n;i++){
        fa[i]=i;
        siz[i]=1;
        sum[i]=1;
    }
    for(int i=1;i<=n;i++){
        if(!vis[i]){
            dfs(i,0);
        }
    }
    // for(int i=1;i<=n;i++){
    //     cout<<trfa[i]<<' ';
    // }
    // cout<<'\n';
    for(int i=1;i<=m;i++){
        int x=find(g[i].u),y=find(g[i].v);
        MERGE(x,y);
    }
    for(int i=1;i<=q;i++){
        int x=find(ask[i].u),y=find(ask[i].v);
        if(x==y){
            cout<<sum[x]<<'\n';
            continue;
        }
        MERGE(x,y);
        x=find(ask[i].u),y=find(ask[i].v);
        if(x==y){
            cout<<sum[x]<<'\n';
        }
        else{
            cout<<"No\n";
        }
    }
    return 0;
}
```

练习：https://www.luogu.com.cn/problem/P6351

---

## 作者：IkunTeddy (赞：3)

# 题目分析

LCT 维护边双模板。

因为需要环路经过，而 LCT 又不能维护图的信息，所以只有考虑缩环后用 LCT 维护边双即可。

加边时，如果两个点联通，就将这条链上的点用并查集缩起来，因为每个点只被缩一次，复杂度可以保证。

时间复杂度 $O((m+p)\log n)$。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
//
const int maxn=2e5+10;
int n,m,q;
int fa[maxn],sz[maxn]; //记录边双的大小
int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
void merge(int x,int y){
	x=find(x),y=find(y);
	if(x==y)return ;
	fa[y]=x;
	sz[x]+=sz[y];
}
//
struct LCT{
	int fa,son[2];
	int sz;
	int tag;
}tree[maxn];
void newnode(int v){
	tree[v].fa=tree[v].son[0]=tree[v].son[1]=0;
	tree[v].tag=0;
	tree[v].sz=1;
}
int isroot(int v){return v!=tree[tree[v].fa].son[0]&&v!=tree[tree[v].fa].son[1];}
int get(int v){return v==tree[tree[v].fa].son[1];}
void pushup(int v){
	tree[v].sz=tree[tree[v].son[0]].sz+tree[tree[v].son[1]].sz+1;
}
void reverse(int v){
	tree[v].tag^=1;
	swap(tree[v].son[0],tree[v].son[1]);
}
void pushdown(int v){
	if(!tree[v].tag)return ;
	reverse(tree[v].son[0]);
	reverse(tree[v].son[1]);
	tree[v].tag=0;
}
void pushtag(int v){
	if(!isroot(v))pushtag(tree[v].fa);
	pushdown(v);
}
void rotate(int v){
	int f=tree[v].fa,g=tree[f].fa,chk=get(v);
	if(!isroot(f))tree[g].son[get(f)]=v;
	tree[v].fa=g;
	tree[f].son[chk]=tree[v].son[chk^1];
	if(tree[v].son[chk^1])tree[tree[v].son[chk^1]].fa=f;
	tree[v].son[chk^1]=f;
	tree[f].fa=v;
	pushup(f);
	pushup(v);
}
void splay(int v){
	pushtag(v);
	while(!isroot(v)){
		int f=tree[v].fa;
		if(!isroot(f))rotate(get(f)==get(v)?f:v);
		rotate(v);
	}
}
void access(int v){
	int p=0;
	while(v){
		splay(v);
		tree[v].son[1]=p;
		pushup(v);
		p=v,v=tree[v].fa=find(tree[v].fa);
	}
}
void mkroot(int v){
	access(v);
	splay(v);
	reverse(v);
}
int findroot(int v){
	access(v);
	splay(v);
	while(tree[v].son[0])v=tree[v].son[0];
	splay(v);
	return v;
}
void split(int x,int y){
	mkroot(x);
	access(y);
	splay(y);
}
void link(int x,int y){
	mkroot(x),mkroot(y);
	tree[x].fa=y;
}
void dfs(int v,int rt){
	if(!v)return ;
	merge(rt,v);
	dfs(tree[v].son[0],rt);
	dfs(tree[v].son[1],rt);
	tree[v].son[0]=tree[v].son[1]=0;
	pushup(v);
}
void add(int x,int y){
	x=find(x),y=find(y);
	if(x==y)return ;
	if(findroot(x)!=findroot(y)){
		link(x,y);
	}else{
		split(x,y);
		dfs(y,y);
	}
}
int ask(int x,int y){
	x=find(x),y=find(y);
	if(x!=y)return -1;
	else return sz[x];
}
//
void init(){
	for(int i=1;i<=n;i++){
		newnode(i);
		fa[i]=i;
		sz[i]=1;
	}
}
int main(){
	cin>>n>>m>>q;
	init();
	for(int i=1;i<=m;i++){
		int x,y;
		cin>>x>>y;
		add(x,y);
	}
	for(int i=1;i<=q;i++){
		int x,y;
		cin>>x>>y;
		add(x,y);
		int res=ask(x,y);
		if(res==-1)cout<<"No\n";
		else cout<<res<<'\n';
	}
	
	return 0;
}
```

---

## 作者：huta0 (赞：2)

看到题目，看到动态加边，然后就想到图之类的东西。

然后看到环，就想到割点，然后就想到 LCT 和圆方树。

每次加边的时候，如果形成了一个环，那么环上所有点就可以连到一个新的方点上来，然后方点权值为环上的点数，然后把这个方点和环上所有点合并，作为环上所有点的代表。这样一来，如果一次要查询 $(a, b)$ 之间，且两点已连通，那么我们就可以选择抽出 $a$ 的代表和 $b$ 的代表这一条树链，然后同上，合并，答案就是最后合并成的方点权值。如果不连通的话，那么就直接连。

这样做，时间复杂度也是可以接受的。类似于动态割点的做法，这样也是均摊的，所以可以放心。

---

## 作者：Hoks (赞：1)

## 前言
洛谷居然搬了一车的 LCT 题，有点开心的。

其实是可以不用 LCT 的但是我还要写长跑，并且我只会 LCT 搞搞了，所以就 LCT 冲了。

广告：[『从入门到入土』树链剖分学习笔记](https://www.luogu.com.cn/article/56o68hfu)。
## 思路分析
题目就是求连了这条边后，边两端点是否在同一个边双里。

如果在输出边双里有几个点，如果不在输出 `No`。

动态连边，直接无脑上 LCT 搞定。

接着考虑边双的问题。

边双，考虑连边的时候，如果发现左右两端点已经连通。

就把路径上所有点拿出来，缩点。

因为缩点可能进行多次，所以并查集维护一下。

还是挺容易挂的，记得给 LCT 中所有调用到 fa 的换成并查集的 fa。
## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+10,V=1e6,INF=0x3f3f3f3f3f3f3f3f,mod=1e9+7;
int n,m,q;
namespace Fast_IO
{
    static char buf[1000000],*paa=buf,*pd=buf,out[10000000];int length=0;
    #define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
    inline int read()
    {
        int x(0),t(1);char fc(getchar());
        while(!isdigit(fc)){if(fc=='-') t=-1;fc=getchar();}
        while(isdigit(fc)) x=(x<<1)+(x<<3)+(fc^48),fc=getchar();
        return x*t;
    }
    inline void flush(){fwrite(out,1,length,stdout);length=0;}
    inline void put(char c){if(length==9999999) flush();out[length++]=c;}
    inline void put(string s){for(char c:s) put(c);}
    inline void print(int x)
    {
        if(x<0) put('-'),x=-x;
        if(x>9) print(x/10);
        put(x%10+'0');
    }
    inline bool chk(char c) { return !(c>='a'&&c<='z'||c>='A'&&c<='Z'||c>='0'&&c<='9'||c=='.'||c=='$'||c=='#'); }
    inline bool ck(char c) { return c!='\n'&&c!='\r'&&c!=-1&&c!=' '; }
    inline void rd(char s[],int&n)
    {
        s[++n]=getchar();
        while(chk(s[n])) s[n]=getchar();
        while(ck(s[n])) s[++n]=getchar();
        n--;
    }
}
using namespace Fast_IO;
struct DSU
{
    vector<int> h;
    void init(int n){h=vector<int>(n+10);for(int i=1;i<=n;i++) h[i]=i;}
    int find(int x){return h[x]==x?x:h[x]=find(h[x]);}
    int merge(int x,int y){x=find(x),y=find(y);h[x]=y;}
}ff,h;
struct LCT
{
	#define ls son[x][0]
	#define rs son[x][1]
	int f[N],son[N][2],st[N],w[N],r[N];
	bool ntrt(int x){return son[ff.find(f[x])][1]==x||son[ff.find(f[x])][0]==x;}
	void pushson(int x){swap(ls,rs),r[x]^=1;}
	void pushdown(int x)
	{
		if(r[x])
		{
			if(ls) pushson(ls);
			if(rs) pushson(rs);
			r[x]=0;
		}
	}
	void rotate(int x)
	{
		int y=ff.find(f[x]),z=ff.find(f[y]),k=(son[y][1]==x),w=son[x][!k];
		if(ntrt(y)) son[z][son[z][1]==y]=x;son[x][!k]=y;son[y][k]=w;
		if(w) f[w]=y;f[y]=x;f[x]=z;
	}
	void Splay(int x)
	{
		int y=x,tot=0;st[++tot]=y;
		while(ntrt(y)) st[++tot]=y=ff.find(f[y]);
		while(tot) pushdown(st[tot--]);
		while(ntrt(x))
		{
			y=ff.find(f[x]);int z=ff.find(f[y]);
			if(ntrt(y)) rotate((son[y][0]==x)^(son[z][0]==y)?x:y);
			rotate(x);
		}
	}
	void access(int x){for(int y=0;x;x=ff.find(f[y=x])) Splay(x),rs=y;}
	void makert(int x){access(x);Splay(x);pushson(x);}
	void split(int x,int y){makert(x);access(y);Splay(y);}
	void link(int x,int y){makert(x);f[x]=y,h.h[h.find(x)]=h.find(y);}
	void dfs(int x,int y)
	{
		if(!x) return;ff.h[x]=y,w[y]+=w[x];
		dfs(ls,y),dfs(rs,y);
	}
	int add(int x,int y)
	{
		x=ff.find(x),y=ff.find(y);if(x==y) return w[x];
		if(h.find(x)!=h.find(y)) return link(x,y),-1;
		makert(x),access(y),Splay(y);dfs(son[y][0],y);return w[y];
	}
	#undef ls
	#undef rs
}lct;
inline void solve()
{
    n=read(),m=read(),q=read();ff.init(n);h.init(n);for(int i=1;i<=n;i++) lct.w[i]=1;
	for(int i=1,x,y;i<=m;i++) x=read(),y=read(),lct.add(x,y);
    for(int i=1,x,y,ans;i<=q;i++) x=read(),y=read(),ans=lct.add(x,y),(~ans)?print(ans):put("No"),put('\n');
}
signed main()
{
    int T=1;while(T--) solve();
    genshin:;flush();return 0;
}
```

---

## 作者：D0000 (赞：1)

首先，如果连接的两个点 $x,y$ 不在同一连通块不能形成便双；本来就在同一个便双内不会对答案造成影响。因此考虑如何处理在同一连通块，但不在同一边双：

直接维护每个点缩在哪个边双连通分量。

一个朴素的想法是，把 $x$ 到 $y$ 路径上每个点所在边双内的点合在一起形成一个新的边双，$O(n^2)$。

考虑边双中两点的任意路径上的点都属于这个边双，因此只需要将 $x$ 到 $y$ 路径上的边双合在一起即可。用并查集维护，时间复杂度 $O(n)$。（因为每个边双会被合并一次，每次操作最多产生一个边双）

代码：

```cpp
#include<cstdio>
#include<vector>
#define N 400005
int n,m,P,u[N],v[N],p[N],dis[N],rp[N],min[N],size[N];
std::vector<int>g[N];
bool ans[N];
int qu(int o){
    if(o-p[o])p[o]=qu(p[o]);
    return p[o];
}
void dfs(int now=1,int pp=0){
    dis[now]=dis[pp]+1;p[now]=now;rp[now]=pp;
    for(int i:g[now])if(i-pp)dfs(i,now);
}
int main(){
    scanf("%d%d%d",&n,&m,&P);
    for(int i=1;i<=n;i++)p[i]=min[i]=i,size[i]=1;
    for(int i=1;i<=m+P;i++){
        scanf("%d%d",&u[i],&v[i]);
        int uu=qu(u[i]),vv=qu(v[i]);
        if(uu-vv)g[u[i]].push_back(v[i]),g[v[i]].push_back(u[i]),p[uu]=vv,ans[i]=1;
    }
    for(int i=1;i<=n;i++)if(!rp[i])dfs(i);
    for(int i=1;i<=m+P;i++){
        if(ans[i]&&i>m)puts("No");
        else if(!ans[i]){
            int uu=qu(u[i]),vv=qu(v[i]),xx=min[uu],yy=min[vv];
            if(uu==vv){if(i>m)printf("%d\n",size[uu]);continue;}
            while(vv-uu){
                p[vv]=uu,size[uu]+=size[vv],min[uu]=dis[xx]<dis[min[uu]]?xx:min[uu];
                min[uu]=dis[yy]<dis[min[uu]]?yy:min[uu];
                if(dis[xx]>dis[yy])vv=qu(rp[xx]),xx=min[vv],p[vv]=uu;
                else vv=qu(rp[yy]),yy=min[vv],p[vv]=uu;
            }
            if(i>m)printf("%d\n",size[uu]);
        }
    }
}
```

---

## 作者：Deamer (赞：0)

考虑用 LCT 维护。

主要看第二个操作。

发现第二个操作其实就是求边双点的个数。

然后维护缩边双是 LCT 的经典操作。

我们并不是把边双真的缩起来，而是用并查集维护，一个点双的点的祖先指向这个点双的代表节点。

发现我们出现点双时，这个点双的所有点构成一个 Splay。所以为了方便采用根节点为代表节点。然后断掉根节点与子树的边，并把子树内的所有点的父亲指向根节点。

然后实现：

```cpp
void Del(int x,int y){
	if(!x) return ;
	h[x]=y;
	val[y]+=val[x];
	Del(lc,y); Del(rc,y);
}

void Link(int x,int y){
	if(x==y) return ;
	Makeroot(x);
	if(Findroot(y)!=x){
		f[x]=y;
		return ;
	}
	Del(rc,x); rc=0;
	Push_up(x);
}
```

然后有个细节需要注意，就是在操作时，不要用原点，而是用它的代表节点。

所以 Access 函数需要改成这样：

```cpp
void Access(int x){
	for(int y=0;x;y=x,x=f[y]=find(f[x])) { Splay(x); rc=y; Push_up(x); }
}
```

然后再维护一下 size 就做完了。

###  _Code:_ 

```cpp
#include<bits/stdc++.h>
using namespace std;
#define lc c[x][0]
#define rc c[x][1]
const int N=3e5+10;
int n,m,C;
int a[N],b[N];
int c[N][2],f[N],V[N],tag[N],st[N];
int siz[N];
struct E {
	int u,v;
	bool operator < (const E &a) const {
		if(u!=a.u) return u<a.u;
		return v<a.v;
	}
}G[N];
int vis[N],h[N],ans[N],op[N];

int find(int x) { return h[x]==x ? x : h[x]=find(h[x]) ; }

bool nroot(int x) { return c[f[x]][0]==x || c[f[x]][1]==x ; }

void Push_up(int x) { V[x]=V[lc]+V[rc]+1; }

void Push_r(int x) { int t=lc;lc=rc;rc=t;tag[x]^=1; }

void Push_down(int x){
	if(tag[x]){
		if(lc) Push_r(lc);
		if(rc) Push_r(rc);
		tag[x]=0;
	}
}

void Rotate(int x){
	int y=f[x],z=f[y],cur=c[y][1]==x,t=c[x][!cur];
	if(nroot(y)) c[z][c[z][1]==y]=x; c[x][!cur]=y; c[y][cur]=t;
	if(t) f[t]=y;
	f[y]=x; f[x]=z;
	Push_up(y);
}

void Splay(int x){
	int y=x,z=0,top=0;
	st[++top]=y;
	while(nroot(y)) st[++top]=y=f[y];
	while(top) Push_down(st[top--]);
	while(nroot(x)){
		y=f[x]; z=f[y];
		if(nroot(y)) Rotate((c[y][0]==x)^(c[z][0]==y) ? x : y);
		Rotate(x); 
	}
	Push_up(x);
}

void Access(int x){
	for(int y=0;x;y=x,x=f[y]=find(f[x])) { Splay(x); rc=y; Push_up(x); }
}

void Makeroot(int x) { Access(x); Splay(x); Push_r(x); }

int Findroot(int x){
	Access(x); Splay(x);
	Push_down(x);
	while(lc) { Push_down(x=lc);  }
	Splay(x);
	return x;
}

void Split(int x,int y){ Makeroot(x); Access(y); Splay(y); }

void Del(int x,int y){
	if(!x) return ;
	h[x]=y;
	siz[y]+=siz[x];
	Del(lc,y); Del(rc,y);
}

void Link(int x,int y){
	if(x==y) return ;
	Makeroot(x);
	if(Findroot(y)!=x){
		f[x]=y;
		return ;
	}
	Del(rc,x); rc=0;
	Push_up(x);
}

int main(){
	scanf("%d%d%d",&n,&m,&C);
	for(int i=1;i<=n;i++) { h[i]=i; V[i]=siz[i]=1; }
	int u,v;
	for(int i=1;i<=m;i++){
		scanf("%d%d",&u,&v);
		Link(find(u),find(v));
	}
	for(int i=1;i<=C;i++){
		scanf("%d%d",&u,&v);
		Link(find(u),find(v));
		int x=find(u),y=find(v);
		if(x!=y){
			printf("No\n");
			continue;
		}
		printf("%d\n",siz[x]);
	}
	return 0;
}
```

然后这个推荐两个可以用 LCT 缩边双的题：

[P2542 [AHOI2005] 航线规划](https://www.luogu.com.cn/problem/P2542)

[P10658 BZOJ2959 长跑](https://www.luogu.com.cn/problem/P10658)

---


# BZOJ2959 长跑

## 题目背景

某校开展了同学们喜闻乐见的阳光长跑活动。为了能“为祖国健康工作五十年”，同学们纷纷离开寝室，离开教室，离开实验室，到操场参加 $3000$ 米长跑运动。一时间操场上熙熙攘攘，摩肩接踵，盛况空前。

## 题目描述

为了让同学们更好地监督自己，学校推行了刷卡机制。学校中有 $n$ 个地点，用 $1\sim n$ 的整数表示，每个地点设有若干个刷卡机。

有以下三类事件：
1. 修建了一条连接 $A$ 地点和 $B$ 地点的跑道；
2. $A$ 地点的刷卡机台数变为了 $B$；
3. 进行了一次长跑。问一个同学从 $A$ 地点出发，最后到达 $B$ 地点最多可以刷卡多少次。具体的要求如下：
   - 当同学到达一个地点时，他可以在这里的每一台刷卡机上都刷卡。但每台刷卡机只能刷卡一次，即使多次到达同一地点也不能多次刷卡。为了安全起见，每条跑道都需要设定一个方向，这条跑道只能按照这个方向单向通行。最多的刷卡次数即为在任意设定跑道方向，按照任意路径从 $A$ 地点到 $B$ 地点能刷卡的最多次数。

## 说明/提示

对于所有数据，$1\leq m\leq 5n$，$1\leq n\leq 1.5\times 10^5$。

保证最初所有地点之间都没有跑道。

每行相邻的两个数之间均用一个空格隔开。

表示地点编号的数均在 $1$ 到 $n$ 之间，每个地点的刷卡机台数始终不超过 $10^4$，$P \in \{1,2,3\}$。

## 样例 #1

### 输入

```
9 31
10 20 30 40 50 60 70 80 90
3 1 2
1 1 3
1 1 2
1 8 9
1 2 4
1 2 5
1 4 6
1 4 7
3 1 8
3 8 8
1 8 9
3 8 8
3 7 5
3 7 3
1 4 1
3 7 5
3 7 3
1 5 7
3 6 5
3 3 6
1 2 4
1 5 5
3 3 6
2 8 180
3 8 8
2 9 190
3 9 9
2 5 150
3 3 6
2 1 210
3 3 6```

### 输出

```
-1
-1
80
170
180
170
190
170
250
280
280
270
370
380
580```

# 题解

## 作者：chenly8128 (赞：3)

### 预备知识

- 动态树 LCT
- 并查集

### 思路

由于一个点可以多次经过，但是每一条边方向必须是固定的，所以可以自然的想到**边双连通分量**。

每到达一个边双连通分量，可以在这个边双连通分量中转圈。这样同一个边双连通分量之中的所有点一定都可以到达。

因此我们可以直接缩点，缩点后的权值为所有点本来值的总和。缩完点的无向图是森林。

然后这就变成了一道用动态树维护双连通分量的题目。缩点我们可以使用并查集。

### 具体实现

由于我们使用了并查集，所以在标准动态树的基础上，还需要进行略微改动。

具体来说：

1. 在 `access`
 函数中改动一下。每次向上移动前，将父亲节点设为父亲节点所在并查集的根。

2. 新增函数 `dfs` 来实现对于整条实链缩点这一功能。

然后再来说题目的三种询问操作：

1. 对于操作 1：先用 `find_root` 函数判断 A 和 B 是否连通。如果不连通直接将它们连起来；否则将这两个点之间的实链分离出来，整条实链缩点。

2. 对于操作 2：先令 C 为 A 节点所在的并查集的根，把这个 C `make_root(C)` 成整棵树的根，最后更新 C 的权值。为了更新 C 的权值，需要记录每个节点目前的权值，通过变化的差值进行更新。

3. 对于操作 3：先判断是否连通，如果连通就分离 A 和 B 之间的实链，输出实链权值和。否则输出 -1。

如果将并查集复杂度当作常数，那么总复杂度为 $O(q \log_2 n)$。

### 代码

```cpp

// Author: chenly8128
// Created: 2025-03-21 20:57:47

#include <bits/stdc++.h>
using namespace std;
inline int read (void) {
	int res = 0;bool flag = true;char c = getchar();
	while (c < '0' || c > '9') {flag ^= (c == '-');c = getchar();}
	while (c >= '0' && c <= '9') {res = (res << 3) + (res << 1) + (c ^ 48);c = getchar();}
	return flag ? res : -res;
}
const int MAXN = 2e5+10;
int fa[MAXN],cnt[MAXN];
int find (int x) {
	return fa[x] = fa[x] == x ? x : find(fa[x]);
}
void merge (int a,int b) {
	a = find(a);b = find(b);
	if (a == b) return;
	fa[a] = b;
	cnt[b] += cnt[a];
}
struct LCT {
	int sum[MAXN],ch[MAXN][2],fa[MAXN],tot;
	bool lazy[MAXN];
#define ls(x) ch[x][0]
#define rs(x) ch[x][1]
	inline int dir (int fa,int x) {return ls(fa) == x ? 0 : 1;}
	inline bool isroot (int x) {return ls(fa[x]) != x && rs(fa[x]) != x;}
	inline void push_up (int x) {sum[x] = sum[ls(x)] + sum[rs(x)] + cnt[x];}
	inline void reverse (int x) {if (x) {swap(ls(x),rs(x));lazy[x] ^= true;}}
	inline void push_down (int x) {
		if (lazy[x]) {
			reverse(ls(x));
			reverse(rs(x));
			lazy[x] = false;
		}
	}
	void push (int x) {
		if (!isroot(x)) push(find(fa[x]));
		push_down(x);
	}
	void rotate (int x) {
		if (isroot(x)) return;
		int y = fa[x]; int z = fa[y],r = dir(y,x);
		ch[y][r] = ch[x][r^1];
		ch[x][r^1] = y;
		if (!isroot(y)) ch[z][dir(z,y)] = x;
		if (ch[y][r]) fa[ch[y][r]] = y;
		fa[x] = z;
		fa[y] = x;
		push_up(y);
		push_up(x);
	}
	void splay (int x) {
		push(x);
		int y,z;
		while (!isroot(x)) {
			y = fa[x];z = fa[y];
			if (!isroot(y)) rotate(dir(z,y) == dir(y,x) ? y : x);
			rotate(x);
		}
		push_up(x);
	}
	void access (int y) {
		for (int x = 0;y;x = y,y = fa[x] = find(fa[x])) {
			splay(y);
			rs(y) = x;
			push_up(y);
		}
	}
	void make_root (int x) {
		access(x);splay(x);reverse(x);
	}
	int find_root (int x) {
		access(x);splay(x);
		while (ls(x)) {
			push_down(x);
			x = ls(x);
		}
		splay(x);
		return x;
	}
	void split(int x,int y) {
		make_root(x);
		access(y);
		splay(y);
	}
	void link (int x,int y) {
		make_root(x);make_root(y);
		fa[x] = y;
	}
	void dfs (int x,int rt) {
		merge(x,rt);
		if (ls(x)) dfs(ls(x),rt);
		if (rs(x)) dfs(rs(x),rt);
		ls(x) = rs(x) = 0;
	}
} a;

int n,m,tmp[MAXN];
int op,x,y;
int main (void) {
	n = read(); m = read();
	for (int i = 1;i <= n;i++) {
		tmp[i] = cnt[i] = read();
		fa[i] = i;
	}
	while (m--) {
		op = read(); x = read(); y = read();
		if (op == 2) {
			int p = find(x);
			a.make_root(p);
			cnt[p] += y-tmp[x];
			tmp[x] = y;
			a.push_up(p);
		}
		else {
			x = find(x); y = find(y);
			if (op == 1) {
				if (a.find_root(x) != a.find_root(y)) a.link(x,y);
				else {
					a.split(x,y);
					a.dfs(y,y);
					a.push_up(y);
				}
			}
			else {
				if (a.find_root(x) != a.find_root(y)) printf ("-1\n");
				else {
					a.split(x,y);
					printf ("%d\n",a.sum[y]);
				}
			}
		}
	}
	return 0;
}
```

---

## 作者：Deamer (赞：1)

由于加边，修改操作，考虑用 LCT 维护。

前两个操作都比较常规，主要看第三个操作。

发现第三个操作其实就是缩边双后两点间路径长度。

然后维护缩边双是 LCT 的经典操作。

我们并不是把边双真的缩起来，而是用并查集维护，一个点双的点的祖先指向这个点双的代表节点。

发现我们出现点双时，这个点双的所有点构成一个 Splay。所以为了方便采用根节点为代表节点。然后断掉根节点与子树的边，并把子树内的所有点的父亲指向根节点。

然后实现：

```cpp
void Del(int x,int y){
	if(!x) return ;
	h[x]=y;
	val[y]+=val[x];
	Del(lc,y); Del(rc,y);
}

void Link(int x,int y){
	if(x==y) return ;
	Makeroot(x);
	if(Findroot(y)!=x){
		f[x]=y;
		return ;
	}
	Del(rc,x); rc=0;
	Push_up(x);
}
```

然后有个细节需要注意，就是在操作时，不要用原点，而是用它的代表节点。

所以 Access 函数需要改成这样：

```cpp
void Access(int x){
	for(int y=0;x;y=x,x=f[y]=find(f[x])) { Splay(x); rc=y; Push_up(x); }
}
```

然后我们在维护点双时维护一下点双内点权和，这个题就做完了。

请注意一下改点权的时候，要先 Makeroot，不然它的父亲的值没有及时更新，就会挂掉，我写错过这个。

###  Code: 

```cpp
#include<bits/stdc++.h>
using namespace std;
#define lc c[x][0]
#define rc c[x][1]
const int N=3e5+10;
int n,m,C;
int a[N],b[N];
int c[N][2],f[N],V[N],tag[N],st[N],val[N];
int siz[N];
struct E {
	int u,v;
	bool operator < (const E &a) const {
		if(u!=a.u) return u<a.u;
		return v<a.v;
	}
}G[N];
int vis[N],h[N],ans[N],op[N];

int find(int x) { return h[x]==x ? x : h[x]=find(h[x]) ; }

bool nroot(int x) { return c[f[x]][0]==x || c[f[x]][1]==x ; }

void Push_up(int x) { V[x]=V[lc]+V[rc]+val[x]; }

void Push_r(int x) { int t=lc;lc=rc;rc=t;tag[x]^=1; }

void Push_down(int x){
	if(tag[x]){
		if(lc) Push_r(lc);
		if(rc) Push_r(rc);
		tag[x]=0;
	}
}

void Rotate(int x){
	int y=f[x],z=f[y],cur=c[y][1]==x,t=c[x][!cur];
	if(nroot(y)) c[z][c[z][1]==y]=x; c[x][!cur]=y; c[y][cur]=t;
	if(t) f[t]=y;
	f[y]=x; f[x]=z;
	Push_up(y);
}

void Splay(int x){
	int y=x,z=0,top=0;
	st[++top]=y;
	while(nroot(y)) st[++top]=y=f[y];
	while(top) Push_down(st[top--]);
	while(nroot(x)){
		y=f[x]; z=f[y];
		if(nroot(y)) Rotate((c[y][0]==x)^(c[z][0]==y) ? x : y);
		Rotate(x); 
	}
	Push_up(x);
}

void Access(int x){
	for(int y=0;x;y=x,x=f[y]=find(f[x])) { Splay(x); rc=y; Push_up(x); }
}

void Makeroot(int x) { Access(x); Splay(x); Push_r(x); }

int Findroot(int x){
	Access(x); Splay(x);
	Push_down(x);
	while(lc) { Push_down(x=lc);  }
	Splay(x);
	return x;
}

void Split(int x,int y){ Makeroot(x); Access(y); Splay(y); }

void Del(int x,int y){
	if(!x) return ;
	h[x]=y;
	val[y]+=val[x];
	Del(lc,y); Del(rc,y);
}

void Link(int x,int y){
	if(x==y) return ;
	Makeroot(x);
	if(Findroot(y)!=x){
		f[x]=y;
		return ;
	}
	Del(rc,x); rc=0;
	Push_up(x);
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		val[i]=V[i]=a[i];
		h[i]=i;
	}
	int op,u,v;
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&op,&u,&v);
		if(op==1){
			Link(find(u),find(v));			
		}
		else if(op==2){
			Makeroot(find(u)); 
			val[find(u)]-=a[u]-v;
			a[u]=v; 
		}
		else {
			int x=find(u),y=find(v);
			Makeroot(x);
			if(Findroot(y)!=x){
				printf("-1\n");
				continue;
			}
			Split(x,y);
			printf("%d\n",V[y]);
		}
	}
	return 0;
} 
```

然后这个推荐两个可以用 LCT 缩边双的题：

[P2542 [AHOI2005] 航线规划](https://www.luogu.com.cn/problem/P2542)

[P10657 BZOJ4998 星球联盟](https://www.luogu.com.cn/problem/P10657)

---

## 作者：Hoks (赞：0)

## 前言
前置题目：[P10657 BZOJ4998 星球联盟](https://www.luogu.com.cn/problem/P10657)，其实两个题没有太大的区别。

广告：[『从入门到入土』树链剖分学习笔记](https://www.luogu.com.cn/article/56o68hfu)。
## 思路分析
首先题意不要看错了，题意其实是：**$u$ 到 $v$ 所有路径上覆盖到的点权之和**。

因为有加边，单点修改，所以考虑使用 LCT 来维护。

但是 LCT 是动态树，这个题却可能连出环来，怎么办呢？

缩点嘛，碰到环就缩成一个点，权值也带着改一下。

如果把一坨点缩成一个点 $i$ 了记得记录下原本 $i$ 这个点的权值，不然会挂飞。

并查集记录下合并成啥了就做完了。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10,V=1e6,INF=0x3f3f3f3f3f3f3f3f,mod=1e9+7;
int n,m,q;
namespace Fast_IO
{
    static char buf[1000000],*paa=buf,*pd=buf,out[10000000];int length=0;
    #define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
    inline int read()
    {
        int x(0),t(1);char fc(getchar());
        while(!isdigit(fc)){if(fc=='-') t=-1;fc=getchar();}
        while(isdigit(fc)) x=(x<<1)+(x<<3)+(fc^48),fc=getchar();
        return x*t;
    }
    inline void flush(){fwrite(out,1,length,stdout);length=0;}
    inline void put(char c){if(length==9999999) flush();out[length++]=c;}
    inline void put(string s){for(char c:s) put(c);}
    inline void print(int x)
    {
        if(x<0) put('-'),x=-x;
        if(x>9) print(x/10);
        put(x%10+'0');
    }
    inline bool chk(char c) { return !(c>='a'&&c<='z'||c>='A'&&c<='Z'||c>='0'&&c<='9'); }
    inline bool ck(char c) { return c!='\n'&&c!='\r'&&c!=-1&&c!=' '; }
    inline void rd(char s[],int&n)
    {
        s[++n]=getchar();
        while(chk(s[n])) s[n]=getchar();
        while(ck(s[n])) s[++n]=getchar();
        n--;
    }
}
using namespace Fast_IO;
struct DSU
{
    vector<int> h;
    void init(int n){h=vector<int>(n+10);for(int i=1;i<=n;i++) h[i]=i;}
    int find(int x){return h[x]==x?x:h[x]=find(h[x]);}
    int merge(int x,int y){x=find(x),y=find(y);h[x]=y;}
}ff,h;
struct LCT
{
	#define ls son[x][0]
	#define rs son[x][1]
	int f[N],son[N][2],st[N],w[N],r[N],s[N],a[N];
	bool ntrt(int x){return son[ff.find(f[x])][1]==x||son[ff.find(f[x])][0]==x;}
	void pushup(int x){s[x]=s[ls]+s[rs]+w[x];}
	void pushson(int x){swap(ls,rs),r[x]^=1;}
	void pushdown(int x)
	{
		if(r[x])
		{
			if(ls) pushson(ls);
			if(rs) pushson(rs);
			r[x]=0;
		}
	}
	void rotate(int x)
	{
		int y=ff.find(f[x]),z=ff.find(f[y]),k=(son[y][1]==x),w=son[x][!k];
		if(ntrt(y)) son[z][son[z][1]==y]=x;son[x][!k]=y;son[y][k]=w;
		if(w) f[w]=y;f[y]=x;f[x]=z;pushup(y);pushup(x);
	}
	void Splay(int x)
	{
		int y=x,tot=0;st[++tot]=y;
		while(ntrt(y)) st[++tot]=y=ff.find(f[y]);
		while(tot) pushdown(st[tot--]);
		while(ntrt(x))
		{
			y=ff.find(f[x]);int z=ff.find(f[y]);
			if(ntrt(y)) rotate((son[y][0]==x)^(son[z][0]==y)?x:y);
			rotate(x);
		}
	}
	void access(int x){for(int y=0;x;x=ff.find(f[y=x])) Splay(x),rs=y,pushup(x);}
	void makert(int x){access(x);Splay(x);pushson(x);}
	void split(int x,int y){makert(x);access(y);Splay(y);}
	void link(int x,int y){f[x]=y,h.h[h.find(x)]=h.find(y);}
	void dfs(int x,int y)
	{
		if(!x) return;ff.h[x]=y,pushdown(x);
		dfs(ls,y),dfs(rs,y);
	}
	#undef ls
	#undef rs
}lct;
inline void solve()
{
    n=read(),m=read();for(int i=1;i<=n;i++) lct.s[i]=lct.w[i]=lct.a[i]=read();ff.init(n);h.init(n);
	for(int i=1,op,x,y,u;i<=m;i++)
	{
		op=read(),x=read(),y=read();
		if(op==1)
		{
			x=ff.find(x),y=ff.find(y);if(x==y) continue;
			lct.makert(x),lct.access(y),lct.Splay(y);
			if(h.find(x)!=h.find(y)) lct.link(x,y);
			else lct.w[y]=lct.s[y],lct.dfs(y,y),lct.son[y][0]=lct.son[y][1]=0;
		}
		if(op==2)  u=x,x=ff.find(x),lct.Splay(x),lct.w[x]+=y-lct.a[u],lct.a[u]=y,lct.pushup(x);
		if(op==3)
		{
			x=ff.find(x),y=ff.find(y);
			if(h.find(x)!=h.find(y)) put("-1\n");
			else  lct.split(x,y),print(lct.s[y]),put('\n');
		}
	}
}
signed main()
{
    int T=1;while(T--) solve();
    genshin:;flush();return 0;
}
```

---


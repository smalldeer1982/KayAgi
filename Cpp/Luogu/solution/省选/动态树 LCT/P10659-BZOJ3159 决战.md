# BZOJ3159 决战

## 题目描述

Katharon 国有 $n$ 个城市，编号为 $1\sim n$。出于勤俭节约，不铺张浪费的考虑，城市间只连有 $n-1$ 条道路，使得可以从一个城市出发沿着道路走到另一座城市。

现在 X 国的飞船降落在了某个城市，并把它改造成了自己的据点。X 国占领其他国家的一贯做法是，在据点里造一堆工厂生产战斗机器人，然后沿着被侵略国的道路运送到其他城市。X 国的司令向来不走回头路，而且崇尚团结与绝对的公平，因此运送战斗机器人时，会先选择一个终点，再在从据点到终点的路径上选择一个起点，然后把机器人均匀分配到起点到终点路径上的每个城市。同时，为了重新分配机器人，X 国的司令还会下令，按照与运送机器人相同的方法选择起点和终点，然后翻转这条路径上城市的机器人的数量。比如，选定的路径上的城市的机器人数依次为 $1,2,3,4,5$，翻转之后就变成了 $5,4,3,2,1$。

Kanari 国王手中的圆盘上浮现出了 Katharon 国的地图。不仅如此,上面还标出了 X 国据点在 $r$ 号城市，并显示出了 X 国司令刚刚下达的指令。“太好了！”国王欢呼，“我们能第一时间掌握敌人的布局，就一定能击退 X 国的侵略者！”

但是还有一个问题没有解决。圆盘上只显示了指令，却没有标出每个城市的机器人数量，这让国王很是头疼。于是他找到了你，想让你帮忙设计一个程序来回答国王的询问。国王只关心某两个点之间路径上的城市的机器人和、最大值以及最小值，以便确定兵力部署、攻击要点和敌方的薄弱点。

X 国司令的指令和 Kanari 国王的询问如下：

1. `Increase x y w` 运送一批机器人到从 $x$ 到 $y$ 的路径上的城市，并分配给每个城市 $w$ 个机器人；
2. `Sum x y` 询问从 $x$ 到 $y$ 的路径上的城市的机器人数量之和。
3. `Major x y` 询问从 $x$ 到 $y$ 的路径上的城市的机器人数量的最大值。
4. `Minor x y` 询问从 $x$ 到 $y$ 的路径上的城市的机器人数量的最小值。
5. `Invert x y` 翻转从 $x$ 到 $y$ 的路径上的城市的机器人数量。

对于 X 国司令的指令，保证给定的 $x,y$ 满足上文所述的要求。对于 Kanari 国王的询问，**不**保证给定的 $x,y$ 满足上述要求。

## 说明/提示

数据保证，$1\leq n,m\leq 5\times 10^4$，且对于运送操作 $1\leq w\leq 10^3$。

## 样例 #1

### 输入

```
5 8 1
1 2
2 3
3 4
4 5
Sum 2 4
Increase 3 5 3
Minor 1 4
Sum 4 5
Invert 1 3
Major 1 2
Increase 1 5 2
Sum 1 5```

### 输出

```
0
0
6
3
19```

# 题解

## 作者：lizexuanaibiancheng (赞：5)

## Problem

对于一棵树，执行以下操作：

+ 路径加
+ 查询路径和
+ 查询路径最大值
+ 查询路径最小值
+ 路径翻转

其中，路径加与路径翻转的路径一定是从祖先到后代（或从后代到祖先）。

## Solution

首先考虑树链剖分。

对于路径加与查询操作，应该都很简单，主要讲路径翻转。

因为题目的特殊性，所以我们只需要考虑一边的翻转。首先先找出这条链上的所有区间，把这些区间按照顺序合并起来，翻转后，再填回去。这里用 fhq-treap 维护。

举个例子：

```
     1
    / \
   2   3
  / \   \
 4  5   6
 / \
 7 8
/   \
9   10
```

重链有 $\{1,2,4,7,9\},\{3,6\},\{5\},\{8,10\}$，那么平衡树中维护的 dfn 序为 $[1,2,4,7,9,8,10,5,3,6]$。

假设要翻转 $1,2,4,8,10$ 这条路径，我们把链上的重链子链拆出来，对于这条路径，应该为 $1,2,4$ 与 $8,10$，拆出来后，平衡树变成了 $[7,9,5,3,6]$。把区间合并再翻转，得到了 $10,8,4,2,1$ 这个新的链，在依次把它放进原来的位置。变成 $[10,8,4,7,9,2,1,5,3,6]$，发现正确了。

如果还不理解，可以看 ```reverse_list``` 函数与注释。

## code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5+10,INF = 0x3f3f3f3f3f3f3f3f;
int n,m,r,deep[N],fa[N],son[N],first[N],dfn[N],rnk[N],tot,siz[N];
vector<int>g[N];
struct FHQ{ // 自己写一棵 fhq
	int siz[N],ch[N][2],fa[N],sum[N],val[N],Max[N],Min[N],tag[N],poi[N],tot,rt;
	bool rev[N];
	inline void pushup(int u){
		sum[u] = Max[u] = Min[u] = val[u];siz[u] = 1;
		if(ch[u][0]) sum[u] += sum[ch[u][0]],Max[u] = max(Max[u],Max[ch[u][0]]),Min[u] = min(Min[u],Min[ch[u][0]]),siz[u] += siz[ch[u][0]];
		if(ch[u][1]) sum[u] += sum[ch[u][1]],Max[u] = max(Max[u],Max[ch[u][1]]),Min[u] = min(Min[u],Min[ch[u][1]]),siz[u] += siz[ch[u][1]];
	}inline void pushdown(int u){
		if(rev[u]){
			if(ch[u][0]) swap(ch[ch[u][0]][0],ch[ch[u][0]][1]),rev[ch[u][0]] ^= 1;
			if(ch[u][1]) swap(ch[ch[u][1]][0],ch[ch[u][1]][1]),rev[ch[u][1]] ^= 1;
			rev[u] = 0;
		}if(ch[u][0]) sum[ch[u][0]] += tag[u]*siz[ch[u][0]],Max[ch[u][0]] += tag[u],Min[ch[u][0]] += tag[u],val[ch[u][0]] += tag[u],tag[ch[u][0]] += tag[u];
		if(ch[u][1]) sum[ch[u][1]] += tag[u]*siz[ch[u][1]],Max[ch[u][1]] += tag[u],Min[ch[u][1]] += tag[u],val[ch[u][1]] += tag[u],tag[ch[u][1]] += tag[u];
		tag[u] = 0;
	}inline int newnode(int num){
		siz[++tot] = 1;
		poi[tot] = (rand()<<15)|rand();
		fa[tot] = ch[tot][0] = ch[tot][1] = tag[tot] = 0;
		sum[tot] = Max[tot] = Min[tot] = num;
		return tot;
	}inline void reserve(int u){
		rev[u] ^= 1;
		swap(ch[u][0],ch[u][1]);
	}inline void add(int u,int num){
		val[u] += num;sum[u] += num*siz[u];Max[u] += num;Min[u] += num;tag[u] += num;
	}inline int merge(int u,int v){ // 合并
		if(!u || !v) return u|v;
		if(poi[u] > poi[v]){
			pushdown(u);
			ch[u][1] = merge(ch[u][1],v);
			pushup(u);
			return u;
		}pushdown(v);
		ch[v][0] = merge(u,ch[v][0]);
		pushup(v);
		return v;
	}inline void split(int u,int k,int &L,int &R){ // 分裂
		if(!u){
			L = R = 0;
			return;
		}pushdown(u);
		if(siz[ch[u][0]]+1 <= k){
			L = u;
			split(ch[u][1],k-siz[ch[u][0]]-1,ch[u][1],R);
		}else{
			R = u;
			split(ch[u][0],k,L,ch[u][0]);
		}pushup(u);
	}inline void modify(int l,int r,int num){ // 区间修改
		int A,B,C;split(rt,r,A,C);split(A,l-1,A,B);
		add(B,num);
		rt = merge(merge(A,B),C);
	}inline int query_sum(int l,int r){ // 查询区间和
		int A,B,C;split(rt,r,A,C);split(A,l-1,A,B);
		int ans = sum[B];
		rt = merge(merge(A,B),C);
		return ans;
	}inline int query_max(int l,int r){ // 查询区间最大值
		int A,B,C;split(rt,r,A,C);split(A,l-1,A,B);
		int ans = Max[B];
		rt = merge(merge(A,B),C);
		return ans;
	}inline int query_min(int l,int r){ // 查询区间最小值
		int A,B,C;split(rt,r,A,C);split(A,l-1,A,B);
		int ans = Min[B];
		rt = merge(merge(A,B),C);
		return ans;
	}inline void build(){
		for(int i = 1;i <= n;++i){
			rt = merge(rt,newnode(0));
		}
	}
}Furina;
inline void dfs1(int u = r,int f = 0){
	deep[u] = deep[f]+1;
	fa[u] = f;
	siz[u] = 1;
	for(int v : g[u]){
		if(v == f) continue;
		dfs1(v,u);
		siz[u] += siz[v];
		if(!son[u] || siz[son[u]] < siz[v]){
			son[u] = v;
		}
	}
}inline void dfs2(int u = r,int f = 0){
	rnk[++tot] = u;dfn[u] = tot;
	if(son[u]){
		first[son[u]] = first[u];
		dfs2(son[u],u);
	}for(int v : g[u]){
		if(v == f || v == son[u]) continue;
		first[v] = v;
		dfs2(v,u);
	}
}inline void modify_list(int u,int v,int val){
	if(deep[u] < deep[v]) swap(u,v);
	for(;first[u] != first[v];){
		Furina.modify(dfn[first[u]],dfn[u],val);
		u = fa[first[u]];
	}Furina.modify(dfn[v],dfn[u],val);
}inline void reverse_list(int u,int v){ // 最重要的部分，以下注释会细讲
	if(deep[u] < deep[v]) swap(u,v); // 保证跳 u
	int tmp = 0;vector<pair<int,int>>id; // tmp 代表新区间合并后的平衡树，id 代表所有区间的位置
	for(;first[u] != first[v];){
		id.emplace_back(make_pair(dfn[first[u]],dfn[u])); // 存储位置，现在先不能把区间取出来，否则查询的位置就不对了
		u = fa[first[u]];
	}id.emplace_back(make_pair(dfn[v],dfn[u])); // 别忘了这里还有一段
	int siz = id.size(),del = 0;
	for(int i = siz-1;i >= 0;--i){ // 从前往后枚举区间，这里因为是从底下跳，所以要倒序
		int l = id[i].first,r = id[i].second;
		int A,B,C;Furina.split(Furina.rt,r-del,A,C);Furina.split(A,l-1-del,A,B);// 把区间按顺序拆成 A,B,C 三份，这里要注意处理之间的删除，导致的下标往前
		del += Furina.siz[B];
		tmp = Furina.merge(tmp,B); // 把 B 加入到新的平衡树
		Furina.rt = Furina.merge(A,C); // 重新把 A,C 两段合并
	}Furina.reserve(tmp); // 把新的平衡树翻转
	for(int i = siz-1;i >= 0;--i){
		int l = id[i].first,r = id[i].second;
		int A,B,C;Furina.split(Furina.rt,l-1,A,C);
		Furina.split(tmp,r-l+1,B,tmp); // 把区间拆成 A,B,C 三段，只不过 B 段是新的平衡树拆出来的
		Furina.rt = Furina.merge(Furina.merge(A,B),C); // 按照 A,B,C 的顺序合并
	}
}inline int query_sum(int u,int v){
	if(deep[u] < deep[v]) swap(u,v);
	int ans = 0;
	for(;first[u] != first[v];){
		if(deep[first[u]] < deep[first[v]]) swap(u,v);
		ans += Furina.query_sum(dfn[first[u]],dfn[u]);
		u = fa[first[u]];
	}if(dfn[u] > dfn[v]) swap(u,v);
	ans += Furina.query_sum(dfn[u],dfn[v]);
	return ans;
}inline int query_max(int u,int v){
	if(deep[u] < deep[v]) swap(u,v);
	int ans = -INF;
	for(;first[u] != first[v];){
		if(deep[first[u]] < deep[first[v]]) swap(u,v);
		ans = max(ans,Furina.query_max(dfn[first[u]],dfn[u]));
		u = fa[first[u]];
	}if(dfn[u] > dfn[v]) swap(u,v);
	ans = max(ans,Furina.query_max(dfn[u],dfn[v]));
	return ans;
}inline int query_min(int u,int v){
	if(deep[u] < deep[v]) swap(u,v);
	int ans = INF;
	for(;first[u] != first[v];){
		if(deep[first[u]] < deep[first[v]]) swap(u,v);
		ans = min(ans,Furina.query_min(dfn[first[u]],dfn[u]));
		u = fa[first[u]];
	}if(dfn[u] > dfn[v]) swap(u,v);
	ans = min(ans,Furina.query_min(dfn[u],dfn[v]));
	return ans;
}signed main(){
	ios_base::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin >> n >> m >> r;
	for(int i = 1,u,v;i < n;++i){
		cin >> u >> v;
		g[u].emplace_back(v);
		g[v].emplace_back(u);
	}dfs1();first[r] = r;dfs2();
	Furina.build();
	for(int i = 1,x,y,w;i <= m;++i){
		char op[11];cin >> op >> x >> y;
		if(strcmp(op,"Increase") == 0){
			cin >> w;
			modify_list(x,y,w);
		}else if(strcmp(op,"Sum") == 0){
			cout << query_sum(x,y) << "\n";
		}else if(strcmp(op,"Major") == 0){
			cout << query_max(x,y) << "\n";
		}else if(strcmp(op,"Minor") == 0){
			cout << query_min(x,y) << "\n";
		}else if(strcmp(op,"Invert") == 0){
			reverse_list(x,y);
		}
	}
	return 0;
}
```

---

## 作者：xzz_cat6 (赞：4)

# P10659 BZOJ3159 决战
## Problem
给定一棵树，要求实现：
- 对某条路径上的所有节点点权加上 $w$。
- 求某条路径上的点权和。
- 求某条路径上的点权最大值。
- 求某条路径上的点权最小值。
- 翻转某条路径上的点权。
## Solution
这道题用 LCT 的通用性更强，不需要用到路径的性质。如果没有路径翻转，那么这道题就是 LCT 的模板题。下面只考虑翻转操作。

假设翻转路径的两端为 $x$ 和 $y$。则先按照套路将 $x$ 和 $y$ 进行 split 操作，此时这条路径构成一个 splay 树。且位于整棵树的树根部，$x$ 为这颗大树的根。

之后我们不能直接翻转这颗 splay，这意味着将这颗大树的根换成 $y$，没有实质作用。我们希望的是在不改变树的形态的情况下翻转权值，那么我们不妨将权值单开一个数据结构维护。

此时可以对于大树上的每一颗 splay 树开一个 dfs 序对应的权值 splay。这样子翻转操作就只用在 split 后翻转 $x$ 所在的 splay 对应的权值 splay 即可。对于 access 操作，可以给每个点维护它所在的 splay 对应的权值 splay 的根，两棵树同步维护，断开右儿子的时候按照对应的排名断开权值树的右儿子。对于 makeroot 中的翻转操作，只需将对应的权值树翻转，保证 dfs 序相同。对于其他操作，都是基于 access 和 makeroot 操作的，无需改变权值树形态。查询操作直接查对应的权值树即可得到答案。

只是 access 操作变了一点，代码基本套模板，就是维护的东西多了一些。
## Code
```cpp
#include<bits/stdc++.h>
#define N 50005
#define int long long 
using namespace std;
int n,m,rt;
vector<int> e[N];
#define ls(u) (ch[u][0])
#define rs(u) (ch[u][1])
namespace T1{
	int ch[N][2],fa[N],tag[N],tag2[N];
	int mn[N],mx[N],val[N],sum[N],siz[N];
	bool get(int u){
		return rs(fa[u])==u;
	}
	bool isroot(int u){
		return ls(fa[u])!=u&&rs(fa[u])!=u;
	}
	void pushup(int u){
		mn[u]=val[u],mx[u]=val[u];
		if(ls(u)){
			mn[u]=min(mn[u],mn[ls(u)]);
			mx[u]=max(mx[u],mx[ls(u)]);
		}
		if(rs(u)){
			mn[u]=min(mn[u],mn[rs(u)]);
			mx[u]=max(mx[u],mx[rs(u)]);
		}
		siz[u]=siz[ls(u)]+siz[rs(u)]+1;
		sum[u]=sum[ls(u)]+sum[rs(u)]+val[u];
	}
	void pushrev(int u){
		swap(ls(u),rs(u));
		tag[u]^=1;
	}
	void pushrev(int u,int x){
		mx[u]+=x,mn[u]+=x,val[u]+=x,sum[u]+=siz[u]*x,tag2[u]+=x;
	}
	void pushdown(int u){
		if(tag[u]){
			if(ls(u))	pushrev(ls(u));
			if(rs(u))	pushrev(rs(u));
			tag[u]^=1;
		}
		if(tag2[u]){
			if(ls(u))	pushrev(ls(u),tag2[u]);
			if(rs(u))	pushrev(rs(u),tag2[u]);
			tag2[u]=0;
		}
	}
	void update(int u){
		if(!isroot(u))	update(fa[u]);
		pushdown(u);
	}
	void rotate(int x){
		int y=fa[x],z=fa[y],f=get(x);
		if(!isroot(y))	ch[z][get(y)]=x;
		ch[y][f]=ch[x][f^1];
		if(ch[x][f^1])	fa[ch[x][f^1]]=y;
		ch[x][f^1]=y,fa[y]=x,fa[x]=z;
		pushup(y),pushup(x);
	}
	void splay(int x){
		update(x);
		for(int f=fa[x];!isroot(x);rotate(x),f=fa[x]){
			if(!isroot(f))	rotate(get(x)==get(f)?f:x);
		}
	}
	int kth(int x,int k){
		while(1){
			pushdown(x);
			if(siz[ls(x)]+1==k){
				splay(x);
				return x;
			}
			if(siz[ls(x)]>=k)	x=ls(x);
			else	k-=siz[ls(x)]+1,x=rs(x);
		}
	}
	
	void print(){
		for(int i=1;i<=n;i++){
			cout<<ls(i)<<' '<<rs(i)<<' '<<fa[i]<<' '<<siz[i]<<' '<<mn[i]<<' '<<mx[i]<<' '<<val[i]<<' '<<sum[i]<<' '<<tag[i]<<' '<<tag2[i]<<'\n';
		} 
	}
}
namespace T2{
	int ch[N][2],fa[N],tag[N],siz[N],pos[N],tag2[N];
	void print(){
		for(int i=1;i<=n;i++){
			cout<<ls(i)<<' '<<rs(i)<<' '<<fa[i]<<' '<<siz[i]<<' '<<pos[i]<<' '<<tag[i]<<' '<<tag2[i]<<'\n';
		} 
	}
	bool get(int u){
		return rs(fa[u])==u;
	}
	bool isroot(int u){
		return ls(fa[u])!=u&&rs(fa[u])!=u;
	}
	void pushup(int u){
		siz[u]=siz[ls(u)]+siz[rs(u)]+1; 
	}
	void pushrev(int u){
		swap(ls(u),rs(u));
		tag[u]^=1;
	}
	void pushrev(int u,int x){
		if(!u)	return;
		pos[u]=tag2[u]=x;
	}
	void pushdown(int u){
		if(tag[u]){
			if(ls(u))	pushrev(ls(u));
			if(rs(u))	pushrev(rs(u));
			tag[u]^=1;
		}
		if(tag2[u]){
			if(ls(u))	pushrev(ls(u),tag2[u]);
			if(rs(u))	pushrev(rs(u),tag2[u]);
			tag2[u]=0;
		}
	}
	void update(int u){
		if(!isroot(u))	update(fa[u]);
		pushdown(u);
	}
	void rotate(int x){
		int y=fa[x],z=fa[y],f=get(x);
		if(!isroot(y))	ch[z][get(y)]=x;
		ch[y][f]=ch[x][f^1];
		if(ch[x][f^1])	fa[ch[x][f^1]]=y;
		ch[x][f^1]=y,fa[y]=x,fa[x]=z;
		pushup(y),pushup(x);
	}
	void splay(int x){
		update(x);
		for(int f=fa[x];!isroot(x);rotate(x),f=fa[x]){
			if(!isroot(f))	rotate(get(x)==get(f)?f:x);
		}
	}
	void access(int x1){
		splay(x1);
		int u1=0,x2,u2=0;
		while(x1){
			splay(x1),T1::splay(pos[x1]),x2=T1::kth(pos[x1],siz[ls(x1)]+1);
			if(rs(x1))	pushrev(rs(x1),T1::ch[x2][1]);
			rs(x1)=u1,T1::ch[x2][1]=u2;
			if(u2)	T1::fa[u2]=x2;
			pushrev(x1,x2);
			pushup(x1),u1=x1,x1=fa[x1];
			T1::pushup(x2),u2=x2;
		}
	}
	void makeroot(int x){
		access(x),splay(x);
		pushrev(x),T1::pushrev(pos[x]);
	}
	void split(int x,int y){
		makeroot(x),access(y),splay(y);
	}
	void add(int x,int y,int z){
		split(x,y),T1::pushrev(pos[y],z);
	}
	void modify(int x,int y){
		split(x,y),T1::pushrev(pos[y]);
	}
	int qmin(int x,int y){
		return split(x,y),T1::mn[pos[y]];
	}
	int qmax(int x,int y){
		return split(x,y),T1::mx[pos[y]];
	}
	int query(int x,int y){
		return split(x,y),T1::sum[pos[y]];
	}
}
void dfs(int u,int f){
	T2::pos[u]=u,T2::siz[u]=1,T1::siz[u]=1;
	if(f)	T1::fa[u]=f,T2::fa[u]=f;
	for(auto v:e[u]){
		if(v==f)	continue;
		dfs(v,u);
	}
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m>>rt;
	for(int i=1,x,y;i<n;i++){
		cin>>x>>y;
		e[x].push_back(y);
		e[y].push_back(x);
	}dfs(rt,0);
	for(int i=1;i<=m;i++){
		string s;
		int x,y,z;
		cin>>s>>x>>y;
		switch(s[2]){
			case 'm':{
				cout<<T2::query(x,y)<<'\n';
				break;
			}
			case 'c':{
				cin>>z,T2::add(x,y,z);
				break;
			}
			case 'n':{
				cout<<T2::qmin(x,y)<<'\n';
				break;
			}
			case 'j':{
				cout<<T2::qmax(x,y)<<'\n';
				break;
			}
			case 'v':{
				T2::modify(x,y);
				break;
			}
		}
	}
	return 0;
}
```

---

## 作者：Genius_Star (赞：3)

### 思路：

对于路径加、路径和、路径最大值、路径最小值可以用树剖简单维护，该题主要难点是路径翻转。

因为对于一条重链，其的搜索序是连续且单增的，考虑维护一个搜索序的平衡树，本题解使用 fhq。

翻转时，有一个重要性质：

- 绝对是翻转一条到根的路径。

- 即搜索序从上到下是绝对单调的。

即要先将每条重链需要翻转的区间提取出来，因为是从较深的点往上跳的，所以搜索序应该是从大到小的，则需要倒着处理，即由根往下处理。

将所有要翻转的区间放入一个新的平衡树种，然后将新平衡树整体翻转。

之后找到之前重链上需要填补的部分，从根往下依次插入新平衡树的前 $len$ 个元素，$len$ 需要填补的长度，然后将新平衡树的前 $len$ 个元素删去。

时间复杂度为 $O(N \log^2 N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define Full(a) memset(a,0,sizeof(a))
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
using namespace std;
typedef double db;
typedef long long ll;
mt19937 R(time(0));
const ll N=5e4+10,M=15,INF=1e18;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
char op[M];
ll n,m,x,y,w,cnt,top,rt,sum,root,root_;
ll d[N],z[N],p[N],t[N],fa[N],dfn[N];
vector<ll> E[N];
struct Node{
	ll L,R;
	ll siz;
	ll key;
	ll sum;
	ll data;
	ll Max,Min;
	ll tag1;
	bool tag2;
}X[N];
struct Segment{
	ll begin;
	ll len;
}S[N];
class Tree{
public:
	ll cnt=0; 
	inline ll newnode(ll v,ll h=0){
		++cnt;
		X[cnt].L=X[cnt].R=0;
		X[cnt].siz=1;
		X[cnt].data=X[cnt].sum=X[cnt].Max=X[cnt].Min=v;
		X[cnt].tag1=X[cnt].tag2=0;
		X[cnt].key=h+R()%500+1;
		return cnt;
	}	
	inline void pushup(ll k){
		X[k].siz=X[X[k].L].siz+1ll+X[X[k].R].siz;
		X[k].sum=X[X[k].L].sum+X[k].data+X[X[k].R].sum;
		X[k].Max=X[k].Min=X[k].data;
		if(X[k].L){
			X[k].Max=max(X[k].Max,X[X[k].L].Max);
			X[k].Min=min(X[k].Min,X[X[k].L].Min);
		}
		if(X[k].R){
			X[k].Max=max(X[k].Max,X[X[k].R].Max);
			X[k].Min=min(X[k].Min,X[X[k].R].Min);
		}
	}
	inline void add(ll k,ll v){
		if(!k)
		  return ;
		X[k].data+=v;
		X[k].Max+=v;
		X[k].Min+=v;
		X[k].tag1+=v;
		X[k].sum+=X[k].siz*v;
	}
	inline void reverse(ll k){
		if(!k)
		  return ;
		swap(X[k].L,X[k].R);
		X[k].tag2^=1ll;
	}
	inline void push_down(ll k){
		if(X[k].tag1){
			add(X[k].L,X[k].tag1);
			add(X[k].R,X[k].tag1);
			X[k].tag1=0;
		}
		if(X[k].tag2){
			reverse(X[k].L);
			reverse(X[k].R);
			X[k].tag2=0;
		}
	}
	inline void split(ll k,ll v,ll &x,ll &y){
		if(!k){
			x=y=0;
			return ;
		}
		push_down(k);
		if(X[X[k].L].siz<v){
			x=k;
			split(X[k].R,v-X[X[k].L].siz-1,X[x].R,y);
		}
		else{
			y=k;
			split(X[k].L,v,x,X[y].L);
		}
		pushup(k);
	}
	inline ll merge(ll x,ll y){
		if(!x||!y)
		  return x|y;
		if(X[x].key<X[y].key){
			push_down(x);
			X[x].R=merge(X[x].R,y);
			pushup(x);
			return x;
		}
		else{
			push_down(y);
			X[y].L=merge(x,X[y].L);
			pushup(y);
			return y;
		}
	}
	inline void build(ll &k,ll l,ll r,ll pre){
		if(l>r)
		  return ;
		ll mid=(l+r)>>1;
		k=newnode(0,pre);
		build(X[k].L,l,mid-1,X[k].key);
		build(X[k].R,mid+1,r,X[k].key);
		pushup(k);
	}
}T;
inline void add(ll u,ll v){
	E[u].push_back(v);
	E[v].push_back(u);
}
inline void dfs1(ll u,ll f){
	p[u]=1;
	for(auto v:E[u]){
		if(v==f)
		  continue;
		fa[v]=u;
		d[v]=d[u]+1;
		dfs1(v,u);
		p[u]+=p[v];
		if(p[v]>p[z[u]])
		  z[u]=v;
	}
}
inline void dfs2(ll u,ll k){
	dfn[u]=++cnt;
	t[u]=k;
	if(!z[u])
	  return ;
	dfs2(z[u],k);
	for(auto v:E[u]){
		if(v==fa[u]||v==z[u])
		  continue;
		dfs2(v,v); 
	}
}
inline void update(ll u,ll v,ll w){
	ll l,r,x,y,z;
	while(t[u]!=t[v]){
		if(d[t[u]]<d[t[v]])
		  swap(u,v);
		l=dfn[t[u]],r=dfn[u];
		T.split(root,r,x,z);
		T.split(x,l-1,x,y);
		T.add(y,w);
		root=T.merge(T.merge(x,y),z);
		u=fa[t[u]];
	}
	if(d[u]>d[v])
	  swap(u,v);
	l=dfn[u],r=dfn[v];
	T.split(root,r,x,z);
	T.split(x,l-1,x,y);
	T.add(y,w);
	root=T.merge(T.merge(x,y),z);	
}
inline ll querySum(ll u,ll v){
	ll l,r,x,y,z,ans=0;
	while(t[u]!=t[v]){
		if(d[t[u]]<d[t[v]])
		  swap(u,v);
		l=dfn[t[u]],r=dfn[u];
		T.split(root,r,x,z);
		T.split(x,l-1,x,y);
		ans+=X[y].sum;
		root=T.merge(T.merge(x,y),z);
		u=fa[t[u]];
	}
	if(d[u]>d[v])
	  swap(u,v);
	l=dfn[u],r=dfn[v];
	T.split(root,r,x,z);
	T.split(x,l-1,x,y);
	ans+=X[y].sum;
	root=T.merge(T.merge(x,y),z);
	return ans;
}
inline ll queryMax(ll u,ll v){
	ll l,r,x,y,z,ans=0;
	while(t[u]!=t[v]){
		if(d[t[u]]<d[t[v]])
		  swap(u,v);
		l=dfn[t[u]],r=dfn[u];
		T.split(root,r,x,z);
		T.split(x,l-1,x,y);
		ans=max(ans,X[y].Max);
		root=T.merge(T.merge(x,y),z);
		u=fa[t[u]];
	}
	if(d[u]>d[v])
	  swap(u,v);
	l=dfn[u],r=dfn[v];
	T.split(root,r,x,z);
	T.split(x,l-1,x,y);
	ans=max(ans,X[y].Max);
	root=T.merge(T.merge(x,y),z);
	return ans;
}
inline ll queryMin(ll u,ll v){
	ll l,r,x,y,z,ans=INF;
	while(t[u]!=t[v]){
		if(d[t[u]]<d[t[v]])
		  swap(u,v);
		l=dfn[t[u]],r=dfn[u];
		T.split(root,r,x,z);
		T.split(x,l-1,x,y);
		ans=min(ans,X[y].Min);
		root=T.merge(T.merge(x,y),z);
		u=fa[t[u]];
	}
	if(d[u]>d[v])
	  swap(u,v);
	l=dfn[u],r=dfn[v];
	T.split(root,r,x,z);
	T.split(x,l-1,x,y);
	ans=min(ans,X[y].Min);
	root=T.merge(T.merge(x,y),z);
	return ans;
}
inline void reverse(ll u,ll v){
	ll x,y,z,h;
	top=root_=sum=0;
	if(d[u]>d[v])
	  swap(u,v);
	while(t[u]!=t[v]){
		S[++top]={dfn[t[v]],dfn[v]-dfn[t[v]]+1};
		v=fa[t[v]];
	}
	S[++top]={dfn[u],dfn[v]-dfn[u]+1};
	for(int i=top;i>=1;i--){
		T.split(root,S[i].begin+S[i].len-1-sum,x,z);
		T.split(x,S[i].begin-1-sum,x,y);
		root=T.merge(x,z);
		root_=T.merge(root_,y);
		sum+=S[i].len;
	}
	T.reverse(root_);
	for(int i=top;i>=1;i--){
		T.split(root,S[i].begin-1,x,z);
		T.split(root_,S[i].len,y,h);
		root=T.merge(T.merge(x,y),z);
		root_=h;
	}
}
int main(){
	n=read(),m=read(),rt=read();
	for(int u,v,i=1;i<n;i++){
		u=read(),v=read();
		add(u,v);
	}
	T.build(root,1,n,0);
	dfs1(rt,rt);
	dfs2(rt,rt);
	while(m--){
		scanf("%s",op+1);
		x=read(),y=read();
		if(op[3]=='c'){
			w=read();
			update(x,y,w);
		}
		else if(op[1]=='S'){
			write(querySum(x,y));
			putchar('\n');
		}
		else if(op[2]=='a'){
			write(queryMax(x,y));
			putchar('\n');
		}
		else if(op[2]=='i'){
			write(queryMin(x,y));
			putchar('\n');
		}
		else
		  reverse(x,y);
	}
	return 0;
}
```

---

## 作者：huangrenheluogu (赞：2)

前四个操作可以简单使用线段树加重链剖分简单维护。第五个操作可以用平衡树维护。于是就是树剖 + 平衡树即可。

对于序列反转，可以把 $x\to y$ 的路径在 dfn 序上找出来，然后拼接起来，翻转之后再插回去。这些操作是平衡树的简单操作，我用 fhq-Treap 维护。

由于题目中保证了 $x\to y$ 是祖先到孩子的路径，所以顺序是一样的。如果不是这样的路径，感觉需要把两边路径取出来把一边翻转，会让代码更加复杂一些。

```cpp
#include<bits/stdc++.h>
#define pii pair<int, int>
#define fi first
#define se second
#define ll long long
using namespace std;
const int N = 5e4 + 5, inf = 0x3f3f3f3f;
int n, m, Rt, rt, u, v, x, y, z, fa[N];
int dfn[N], hs[N], sz[N], idx, rdfn[N], top[N];
char opt[15];
int dep[N], rt1, rt2, rt3, lst, nrt, lca;
ll ans;
vector<int> G[N], rts;
vector<pii> vc;
inline void dfs(int x, int ff = 0){
    fa[x] = ff, sz[x] = 1;
    dep[x] = dep[ff] + 1;
    for(int y : G[x]){
        if(y == ff) continue ;
        dfs(y, x);
        sz[x] += sz[y];
        if(sz[hs[x]] < sz[y]) hs[x] = y;
    }
}
inline void dfs2(int x, int tp = -1){
    if(!(~tp)) tp = x;
    top[x] = tp;
    rdfn[dfn[x] = ++idx] = x;
    if(!hs[x]) return ;
    dfs2(hs[x], tp);
    for(int y : G[x]) if((y ^ fa[x]) && (y ^ hs[x])){
        dfs2(y);
    }
}
#define ls t[p].lc
#define rs t[p].rc
struct tree{
    int lc, rc, mx, mn, tag, pri, sz, rot, val;
    ll sum;
    inline void rotate(){
        swap(lc, rc);
        rot ^= 1;
    }
    inline void upd(int v){
        mx += v;
        mn += v;
        sum += 1ll * v * sz;
        tag += v;
        val += v;
    }
}t[N];
inline void push_down(int p){
    if(t[p].rot){
        if(ls) t[ls].rotate();
        if(rs) t[rs].rotate();
        t[p].rot = 0;
    }
    if(t[p].tag){
        if(ls) t[ls].upd(t[p].tag);
        if(rs) t[rs].upd(t[p].tag);
        t[p].tag = 0;
    }
}
inline void push_up(int p){
    t[p].sz = t[ls].sz + t[rs].sz + 1;
    t[p].mn = min({t[ls].mn, t[rs].mn, t[p].val});
    t[p].mx = max({t[ls].mx, t[rs].mx, t[p].val});
    t[p].sum = t[ls].sum + t[rs].sum + t[p].val;
}
inline void split(int p, int &x, int &y, int v){
    if(!p){
        x = y = 0;
        return ;
    }
    push_down(p);
    if(t[ls].sz >= v){
        y = p;
        split(ls, x, t[y].lc, v);
        push_up(y);
    }
    else{
        x = p;
        split(rs, t[x].rc, y, v - t[ls].sz - 1);
        push_up(x);
    }
}
inline int Merge(int p, int q){
    if(!p || !q){
        return p | q;
    }
    push_down(p), push_down(q);
    if(t[p].pri < t[q].pri){
        t[p].rc = Merge(t[p].rc, q);
        push_up(p);
        return p;
    }
    else{
        t[q].lc = Merge(p, t[q].lc);
        push_up(q);
        return q;
    }
    return -1;
}
inline void get(int x, int y){
    vc.clear();
    if(dep[x] < dep[y]) swap(x, y);
    while(top[x] ^ top[y]){
        vc.push_back({dfn[top[x]], dfn[x]});
        x = fa[top[x]];
    }
    vc.push_back({dfn[y], dfn[x]});
}
inline int getlca(int x, int y){
    while(top[x] ^ top[y]){
        if(dep[top[x]] > dep[top[y]]) x = fa[top[x]];
        else y = fa[top[y]];
    }
    return dep[x] < dep[y] ? x : y;
}
inline void chkmax(ll &x, int y){
    if(x < y) x = y;
}
inline void chkmin(ll &x, int y){
    if(x > y) x = y;
}
int main(){
    // freopen("data.in", "r", stdin);
    // freopen("code.out", "w", stdout);
    scanf("%d%d%d", &n, &m, &Rt);
    for(int i = 1; i < n; i++){
        scanf("%d%d", &u, &v);
        G[u].push_back(v), G[v].push_back(u);
    }
    t[0].mn = inf;
    dfs(Rt);
    dfs2(Rt);
    for(int i = 1; i <= n; i++){
        t[rdfn[i]].pri = rand();
        t[rdfn[i]].sz = 1;
        rt = Merge(rt, rdfn[i]);
        // printf("dfn[%d] = %d\n", i, dfn[i]);
    }
    while(m--){
        scanf("%s", opt);
        if(opt[2] == 'c'){
            scanf("%d%d%d", &x, &y, &z);
            get(x, y);
            for(pii e : vc){
                split(rt, rt1, rt2, e.se);
                split(rt1, rt1, rt3, e.fi - 1);
                t[rt3].upd(z);
                rt = Merge(Merge(rt1, rt3), rt2);
            }
            // printf("rt = %d\n", rt);
            // for(int i = 1; i <= n; i++){
            //     printf("%d : %d %d %lld %d\n", i, t[i].lc, t[i].rc, t[i].sum, t[i].tag);
            // }
        }
        if(opt[2] == 'm'){
            scanf("%d%d", &x, &y);
            ans = 0ll;
            lca = getlca(x, y);
            get(x, lca);
            for(pii e : vc){
                split(rt, rt1, rt2, e.se);
                split(rt1, rt1, rt3, e.fi - 1);
                ans += t[rt3].sum;
                // cerr << e.fi << ' ' << e.se << ' ' << t[rt3].sum << endl;
                rt = Merge(Merge(rt1, rt3), rt2);
            }
            get(y, lca);
            for(pii e : vc){
                split(rt, rt1, rt2, e.se);
                split(rt1, rt1, rt3, e.fi - 1);
                // cerr << e.fi << ' ' << e.se << ' ' << t[rt3].sum << endl;
                ans += t[rt3].sum;
                rt = Merge(Merge(rt1, rt3), rt2);
            }
            get(lca, lca);
            for(pii e : vc){
                split(rt, rt1, rt2, e.se);
                split(rt1, rt1, rt3, e.fi - 1);
                ans -= t[rt3].sum;
                // cerr << e.fi << ' ' << e.se << ' ' << -t[rt3].sum << endl;
                rt = Merge(Merge(rt1, rt3), rt2);
            }
            printf("%lld\n", ans);
        }
        if(opt[2] == 'j'){
            scanf("%d%d", &x, &y);
            ans = 0ll;
            lca = getlca(x, y);
            get(x, lca);
            for(pii e : vc){
                split(rt, rt1, rt2, e.se);
                split(rt1, rt1, rt3, e.fi - 1);
                chkmax(ans, t[rt3].mx);
                rt = Merge(Merge(rt1, rt3), rt2);
            }
            get(y, lca);
            for(pii e : vc){
                split(rt, rt1, rt2, e.se);
                split(rt1, rt1, rt3, e.fi - 1);
                chkmax(ans, t[rt3].mx);
                rt = Merge(Merge(rt1, rt3), rt2);
            }
            printf("%lld\n", ans);
        }
        if(opt[2] == 'n'){
            scanf("%d%d", &x, &y);
            ans = inf;
            lca = getlca(x, y);
            get(x, lca);
            for(pii e : vc){
                split(rt, rt1, rt2, e.se);
                split(rt1, rt1, rt3, e.fi - 1);
                chkmin(ans, t[rt3].mn);
                rt = Merge(Merge(rt1, rt3), rt2);
            }
            get(y, lca);
            for(pii e : vc){
                split(rt, rt1, rt2, e.se);
                split(rt1, rt1, rt3, e.fi - 1);
                chkmin(ans, t[rt3].mn);
                rt = Merge(Merge(rt1, rt3), rt2);
            }
            printf("%lld\n", ans);
        }
        if(opt[2] == 'v'){
            scanf("%d%d", &x, &y);
            get(x, y);
            reverse(vc.begin(), vc.end());
            nrt = 0;
            lst = 0;
            rts.clear();
            int sz = vc.size();
            assert(sz <= 20);
            for(pii x : vc){
                split(rt, rt1, rt2, x.fi - 1 - lst);
                split(rt2, rt3, rt, x.se - x.fi + 1);
                rts.push_back(rt1);
                nrt = Merge(nrt, rt3);
                lst = x.se;
            }
            rts.push_back(rt);
            // assert(rts.size() == sz + 1);
            t[nrt].rotate();
            rt = rts[0];
            for(int i = 1; i <= sz; i++){
                split(nrt, rt1, nrt, vc[i - 1].se - vc[i - 1].fi + 1);
                rt = Merge(rt, rt1);
                rt = Merge(rt, rts[i]);
            }
        }
    }
    return 0;
}
```

---

## 作者：KarmaticEnding (赞：1)

考虑如果只有前 $4$ 个操作，我们应该怎么做。

显然，如果只有前 $4$ 个操作，我们直接对整棵树树链剖分，对于每条链维护线段树，对于每个线段树上的结点维护 `mx` 表示区间最大值，`mn` 表示区间最小值，`sum` 表示区间和，`addtag` 表示加的懒标记即可。

但是现在来了个 $5$ 号操作，这怎么办呢？

我们想想，什么数据结构能够维护区间翻转？就是平衡树了。我们把维护每条链的线段树换成平衡树，多加一个 `val` 表示当前结点的权值，再多维护一个 `revtag` 表示区间翻转标记即可。

但是我们不仅要维护一条链上的翻转操作，还要把多条链一起翻转，这怎么办呢？

我们考虑把多条链上的平衡树合在一起，合成一棵“大”平衡树，然后翻转这棵“大”平衡树，最后拆分。“合”平衡树和“拆”平衡树让我们想到 FHQ Treap 这种平衡树。于是树链剖分 + FHQ Treap，本题就做完了。

---

还是剖一下代码吧。数据结构不讲代码讲什么。

我们先要考虑清楚，每个平衡树结点要维护的信息。每个平衡树结点要维护以下信息：

-	`siz` 表示结点的子树大小。这是为了合树拆树而维护的。我们拆树的时候，会按照每条链的长度把原来的平衡树一棵一棵拆出来。

-	`ch` 表示结点的左右儿子。

-	`val` 表示结点的权值。注意这是平衡树而不是线段树，每个结点都对应区间上的一个点，所以每个结点都有权值。

-	`mx` 和 `mn` 分别表示区间的最大值和最小值。

-	`dat` 表示一个随机生成的数，用于维护平衡树的堆性质。

-	`sum` 表示区间和。

-	`addtag` 表示区间加标记，`revtag` 表示区间翻转标记。

先明确我们的平衡树要维护好这些，自然就可以写出平衡树部分的代码。注意，下面平衡树拆树的部分是把平衡树的前 `val` 个树拆出来，而不是按照权值拆分。

```cpp
std::mt19937 rnd(std::random_device{}());
namespace FHQTreap{
	struct TreapNode{
		int siz,ch[2];
		long long val,mx,mn,dat;
		long long sum;
		long long addtag;
		bool revtag;
	}tr[MAXN];
	int tot=0;
	#define ls(u) tr[u].ch[0]
	#define rs(u) tr[u].ch[1]
	void New(){
		tr[++tot].siz=1;
		tr[tot].dat=rnd();
	}
	inline void pushup(int &u){
		tr[u].siz=tr[ls(u)].siz+tr[rs(u)].siz+1;
		tr[u].sum=tr[ls(u)].sum+tr[rs(u)].sum+tr[u].val;
		tr[u].mx=tr[u].mn=tr[u].val;
		if(ls(u)){
			tr[u].mx=std::max(tr[u].mx,tr[ls(u)].mx);
			tr[u].mn=std::min(tr[u].mn,tr[ls(u)].mn);
		}
		if(rs(u)){
			tr[u].mx=std::max(tr[u].mx,tr[rs(u)].mx);
			tr[u].mn=std::min(tr[u].mn,tr[rs(u)].mn);
		}
	}
	inline void add_addtag(int u,long long k){
		if(!u){
			return;
		}
		tr[u].mx+=k;tr[u].mn+=k;tr[u].val+=k;
		tr[u].sum+=tr[u].siz*k;tr[u].addtag+=k;
	}
	inline void add_revtag(int u){
		if(!u){
			return;
		}
		std::swap(ls(u),rs(u));
		tr[u].revtag=!tr[u].revtag;
	}
	inline void pushdown(int u){
		if(tr[u].addtag){
			add_addtag(ls(u),tr[u].addtag);
			add_addtag(rs(u),tr[u].addtag);
			tr[u].addtag=0;
		}
		if(tr[u].revtag){
			add_revtag(ls(u));
			add_revtag(rs(u));
			tr[u].revtag=false;
		}
	}
	void Split(int u,int val,int &L,int &R){
		if(u==0){
			L=R=0;
			return;
		}
		pushdown(u);
		if(tr[ls(u)].siz<val){
			L=u;
			Split(rs(u),val-tr[ls(u)].siz-1,rs(u),R);
		}
		else{
			R=u;
			Split(ls(u),val,L,ls(u));
		}
		pushup(u);
	}
	int Merge(int L,int R){
		if(L==0||R==0){
			return L|R;
		}
		if(tr[L].dat<tr[R].dat){
			pushdown(L);
			rs(L)=Merge(rs(L),R);
			pushup(L);
			return L;
		}
		else{
			pushdown(R);
			ls(R)=Merge(L,ls(R));
			pushup(R);
			return R;
		}
	}
}
```

如果一会不知道哪里错了，查看是不是写漏了 `pushdown` 或 `pushup`。实在不行，也可以多加几个 `pushdown` 和 `pushup` 在代码里。

接下来我们要放细节最多的部分，就是合树和拆树。前面提到，翻转一条 $u$ 到 $v$ 的路径的时候，我们要把路径所涉及的所有链上的平衡树都合起来。但在 $u$ 和 $v$ 不断往上跳的过程中，它们迟早会跳到同一条链上，这个时候就要单独把 $u$ 到 $v$ 这部分所对应的区间拆出来。

我们先来看拆树。

```cpp
void Split(int u,int v){
	Rt=t1=t2=0;
	rever=false;
	int rt1=0,rt2=0,tmp;
	while(tr[u].topnode^tr[v].topnode){
		if(tr[tr[u].topnode].depth>tr[tr[v].topnode].depth){
			a[++t1][0]=tr[u].topnode;//a表示u这边的信息，a[i][0]表示u这边每条链的链顶，a[i][1]表示每条链被拆出的长度
			FHQTreap::Split(root[tr[u].topnode],a[t1][1]=tr[u].depth-tr[tr[u].topnode].depth+1,tmp,root[tr[u].topnode]);
			rt1=FHQTreap::Merge(tmp,rt1);//两棵“大”树都是从上（深度浅的地方）往下（深度深的地方）记录序列
			u=tr[tr[u].topnode].fathernode;
		}
		else{
			b[++t2][0]=tr[v].topnode//b表示v这边的信息
			FHQTreap::Split(root[tr[v].topnode],b[t2][1]=tr[v].depth-tr[tr[v].topnode].depth+1,tmp,root[tr[v].topnode]);
			rt2=FHQTreap::Merge(tmp,rt2);
			v=tr[tr[v].topnode].fathernode;
		}
	}
	if(tr[u].depth>tr[v].depth){
		std::swap(u,v);
		rever=true;
	}
	TTTTTTT=tr[u].topnode,lllllll=tr[v].depth-tr[u].depth+1;//变量名逐渐失控
	FHQTreap::Split(root[tr[v].topnode],tr[v].depth-tr[tr[v].topnode].depth+1,root[tr[v].topnode],D);
	FHQTreap::Split(root[tr[u].topnode],tr[u].depth-tr[tr[u].topnode].depth,U,root[tr[u].topnode]);
	FHQTreap::add_revtag(rt1);//执行了这一步之后，整个序列才能合起来，正确的序列应该是u从深往浅，v从浅往深
	if(rever){
		FHQTreap::add_revtag(root[tr[u].topnode]);
	}
	Rt=FHQTreap::Merge(FHQTreap::Merge(rt1,root[tr[u].topnode]),rt2);//最后合成的“大”树是u-中-v的，这个后面有用
}
```

接下来考虑合树。合树就是把每棵树被拆掉的部分合并回去。这就是我们要记录每棵树被拆掉部分的 `siz` 的原因。

```cpp
void Merge(){//把乱序的Treap全部Merge回来
	int tmp;
	for(int i=1;i<=t1;++i){//处理u这边被拆掉的树
		FHQTreap::Split(Rt,a[i][1],tmp,Rt);
		FHQTreap::add_revtag(tmp);//由于前面有一步FHQTreap::add_revtag(rt1)，所以现在要反转回来
		root[a[i][0]]=FHQTreap::Merge(tmp,root[a[i][0]]);
	}
	FHQTreap::Split(Rt,lllllll,tmp,Rt);//由于大树顺序是u-中-v，所以中在v前面被处理
	if(rever){
		FHQTreap::add_revtag(tmp);
	}
	root[TTTTTTT]=FHQTreap::Merge(FHQTreap::Merge(U,tmp),D);
	for(int i=t2;i>=1;--i){
		FHQTreap::Split(Rt,b[i][1],tmp,Rt);
		root[b[i][0]]=FHQTreap::Merge(tmp,root[b[i][0]]);
	}
}
```

至于树链剖分和主函数就不讲了，应该都会。

对于每一条链，有 $O(\log n)$ 条链，这说明有 $O(\log n)$ 棵平衡树，合和拆平衡树的复杂度是 $O(\log n)$，所以总复杂度是 $O(n\log^2 n)$。

本来还想提醒一下常数，看了眼数据范围，算了，大家爱咋写咋写吧。

---

## 作者：pig1121 (赞：1)

由~~标签~~维护链信息想到 LCT。

操作 1/2/3/4 看起来都非常正常，所以正常维护。

关键在于操作 5：

第一眼看见操作 5 显然会想到直接 `access` 然后在 splay 树上打翻转标记。

接着你开心地测了样例，结果输出：
```
0 
0
6
0
19
```
为什么？因为 LCT 中 splay 树的节点不仅维护了权值，还维护了树的形态，如果直接翻转将会改变节点的深度。

然后你又想：下推标记时只换权值不就行了吗？

但是这样连翻转都无法完成，因为子树没有被交换。

不过你已经离正解不远了：

注意到如果交换儿子会影响深度，但只交换权值无法正常翻转。

尝试将树的形态和权值分开维护：

将两颗树的每一个 splay 一一对应，则一个点的权值就是它在对应的那一棵权值树里排名相同的点的权值。

对权值树维护标记，然后 `access` 时利用形态树找父亲即可。

具体地，对于位置树的每个**节点**维护一个 `pos[]` 数组，表示**当这个节点是 splay 的根节点**时，它所在的形态 splay 对应的权值 splay 中的**任意一个节点**，其目的是找到对应的权值 splay。

可以在 `rotate` 函数中像这样维护：
```cpp
void rotate(int p){
	int f=lct[p].fa,ff=lct[f].fa;
	int l=(lct[f].ch[1]==p),r=!l;
	if(!isroot(f))lct[ff].ch[(lct[ff].ch[1]==f)]=p;
	else pos[p]=pos[f];//只需要保证根节点的pos正确
	lct[p].fa=ff;
	lct[f].fa=p;
	lct[lct[p].ch[r]].fa=f;
	lct[f].ch[l]=lct[p].ch[r];
	lct[p].ch[r]=f;
	update(f);
	update(p);
}
```

而要找到一个节点在权值树中的对应点，就将它先 `splay` 到根，然后通过 `pos[]` 数组找到对应树，在找到同样深度的点，就是它的对应点，实现如下：
```cpp
void setpos(int p){
	splay(p);
	splay(pos[p]);
	pos[p]=find(pos[p],lct[lct[p].ch[0]].size+1);
	splay(pos[p]);
}
```

现在我们就能在 `access` 中同时操作两颗树了,由于权值树已经丢失了路径信息，只保留了实链信息，它本质上其实是一个森林，故权值树的虚边是无意义的，在往上跳到下一条链时只能通过形态树，然后再找到下一条链中节点在形态树上的父亲的对应点，再将其儿子设为当前点的对应点，将对应点的父亲设为父亲的对应点：
```cpp
void access(int p){
	setpos(p);
	int rs=lct[p].ch[1],rss=lct[pos[p]].ch[1];
	pos[rs]=rss;
	lct[rss].fa=0;
	lct[p].ch[1]=lct[pos[p]].ch[1]=0;
	update(p);
	update(pos[p]);
	while(lct[p].fa){
		setpos(p);
		int fp=lct[p].fa;
		if(!fp)break;
		setpos(fp);
		int sp=lct[fp].ch[1],sm=lct[pos[fp]].ch[1];
		pos[sp]=sm;
		lct[fp].ch[1]=p;
		lct[lct[pos[fp]].ch[1]].fa=0;
		lct[pos[fp]].ch[1]=pos[p];//接上儿子
		lct[pos[p]].fa=pos[fp];//重新认父亲
		update(fp);
		update(pos[fp]);
		p=lct[p].fa;
    }
}
```

另外，对于形态树**所有可能改变树形态**的操作，权值树都必须再做一次，比如 `makeroot` 中的反转深度，会改变树的形态，所以权值树也要打翻转标记：
```cpp
void makeroot(int p){
	access(p);
	setpos(p);
	pushr(p);
	pushr(pos[p]);
}
```

剩下的就是正常的 LCT 操作，注意 `split` 时要返回的是权值树即可。

~~不会有人和我一样因为 $ 0 $ 号点的 `min` 没有赋值成 INF 调三天吧~~。

完整代码：
```cpp
#include<iostream>
#include<string>
#define int long long
#define endl '\n'

using namespace std;

struct node{
	int fa,ch[2],sum,mn,mx,rev,add,key,size;
};

node lct[100005];
int q[100005],top;
int pos[100005];

void update(int p){
	int l=lct[p].ch[0],r=lct[p].ch[1];
	lct[p].size=lct[l].size+lct[r].size+1;
	lct[p].sum=lct[l].sum+lct[r].sum+lct[p].key;
	lct[p].mn=min(min(lct[l].mn,lct[r].mn),lct[p].key);
	lct[p].mx=max(max(lct[l].mx,lct[r].mx),lct[p].key);
}

void pushr(int p){
	if(!p)return;
	lct[p].rev^=1;
	swap(lct[p].ch[0],lct[p].ch[1]);
}

void pusha(int p,int k){
	if(!p)return;
	lct[p].add+=k;
	lct[p].sum+=lct[p].size*k;
	lct[p].mn+=k;
	lct[p].mx+=k;
	lct[p].key+=k;
}

void pushdown(int p){
	int l=lct[p].ch[0],r=lct[p].ch[1];
	if(lct[p].rev){
		pushr(l);
		pushr(r);
		lct[p].rev=0;
	}
	if(lct[p].add){
		pusha(l,lct[p].add);
		pusha(r,lct[p].add);
		lct[p].add=0;
	}
}

bool isroot(int p){
	return lct[lct[p].fa].ch[0]!=p&&lct[lct[p].fa].ch[1]!=p;
}

void rotate(int p){
	int f=lct[p].fa,ff=lct[f].fa;
	int l=(lct[f].ch[1]==p),r=!l;
	if(!isroot(f))lct[ff].ch[(lct[ff].ch[1]==f)]=p;
    else pos[p]=pos[f];
	lct[p].fa=ff;
	lct[f].fa=p;
	lct[lct[p].ch[r]].fa=f;
	lct[f].ch[l]=lct[p].ch[r];
	lct[p].ch[r]=f;
	update(f);
	update(p);
}

int find(int p,int k){
//	cout<<p<<' '<<k<<endl;;
	pushdown(p);
	int l=lct[p].ch[0],r=lct[p].ch[1];
	if(lct[l].size+1==k)return p;
	if(lct[l].size>=k)return find(l,k);
	return find(r,k-lct[l].size-1);
}

void splay(int p){
	top=1;
	q[top]=p;
	for(int i=p;!isroot(i);i=lct[i].fa)q[++top]=lct[i].fa;
	for(int i=top;i;i--)pushdown(q[i]);
	while(!isroot(p)){
		int f=lct[p].fa,ff=lct[f].fa;
		if(!isroot(f)){
			if((lct[f].ch[1]==p)^(lct[ff].ch[1]==f))rotate(p);
			else rotate(f);
		}
		rotate(p);
	}
}

void setpos(int p){
	splay(p);
	splay(pos[p]);
	pos[p]=find(pos[p],lct[lct[p].ch[0]].size+1);
	splay(pos[p]);
}

int flag[100005];
void print(int p,int k){
	if(isroot(p)&&k)return;
	pushdown(p);
	flag[p]=1;
	int l=lct[p].ch[0],r=lct[p].ch[1];
	if(l)print(l,1);
//	cout<<lct[p].key<<' ';
	if(r)print(r,1);
}

void access(int p){
	setpos(p);
	int rs=lct[p].ch[1],rss=lct[pos[p]].ch[1];
	pos[rs]=rss;
	lct[rss].fa=0;
	lct[p].ch[1]=lct[pos[p]].ch[1]=0;
	update(p);
	update(pos[p]);
	for(int i=0;lct[p].fa;p=lct[p].fa){
		setpos(p);
		int fp=lct[p].fa;
		if(!fp)break;
		setpos(fp);
		int sp=lct[fp].ch[1],sm=lct[pos[fp]].ch[1];
		pos[sp]=sm;
		lct[fp].ch[1]=p;
		lct[lct[pos[fp]].ch[1]].fa=0;
		lct[pos[fp]].ch[1]=pos[p];
		lct[pos[p]].fa=pos[fp];
		update(fp);
		update(pos[fp]);
//		lct[p].ch[1]=i;
//		update(p);
//		i=p;
	}
}

void makeroot(int p){
	access(p);
///	print(pos[p],0);
//	cout<<endl;
	setpos(p);
	pushr(p);
	pushr(pos[p]);
}

int split(int x,int y){
	makeroot(x);
	access(y);
	setpos(y);
	return pos[y];
}

void link(int x,int y){
	makeroot(x);
	setpos(y);
	lct[x].fa=y;
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
    lct[0].mn=1e9;
	int n,m,r;
	cin>>n>>m>>r;
	for(int i=1;i<=n;i++)pos[i]=i+n,pos[i+n]=i;
	for(int i=1;i<=n*2;i++)lct[i].size=1;
	for(int i=1;i<n;i++){
		int x,y;
		cin>>x>>y;
		link(x,y);
	}
//	for(int i=1;i<=n;i++)cout<<lct[i].rev<<' ';
//	cout<<endl;
	while(m--){
		string opt;
		int x,y,k;
		cin>>opt>>x>>y;
		if(opt=="Increase"){
			cin>>k;
			pusha(split(x,y),k);
		}
		if(opt=="Sum")cout<<lct[split(x,y)].sum<<endl;
		if(opt=="Major")cout<<lct[split(x,y)].mx<<endl;
		if(opt=="Minor")cout<<lct[split(x,y)].mn<<endl;
		if(opt=="Invert")pushr(split(x,y));
//		print(pos[y],0);
//		cout<<endl;
//		for(int i=1;i<=n;i++)flag[i]=0;
//		for(int i=1;i<=n;i++){
//			if(flag[i]||!isroot(i))continue;
//			cout<<lct[i].rev<<endl;
//			print(i,0);
//			cout<<endl;
//			cout<<lct[pos[i]].rev<<endl;
//			print(pos[i],0);
//			cout<<endl;
//		}
	}
	return 0;
}
```

---


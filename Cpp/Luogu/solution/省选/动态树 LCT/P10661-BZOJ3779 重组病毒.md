# BZOJ3779 重组病毒

## 题目背景

黑客们通过对已有的病毒反编译，将许多不同的病毒重组，并重新编译出了新型的重组病毒。这种病毒的繁殖和变异能力极强。为了阻止这种病毒传播，某安全机构策划了一次实验，来研究这种病毒。

## 题目描述

实验在一个封闭的局域网内进行。局域网内有 $n$ 台计算机，编号为 $1\sim n$。一些计算机之间通过网线直接相连，形成树形的结构。局域网中有一台特殊的计算机，称之为核心计算机。根据一些初步的研究，研究员们拟定了一个一共 $m$ 步的实验。实验开始之前，核心计算机的编号为 $1$，每台计算机中都有病毒的一个变种，而且每台计算机中的变种都不相同。实验中的每一步会是下面中的一种操作：

- `RELEASE x`。在编号为 $x$ 的计算机中植入病毒的一个新变种。这个变种在植入之前不存在于局域网中。
- `RECENTER x`。将核心计算机改为编号为 $x$ 的计算机。但是这个操作会导致原来核心计算机中的病毒产生新变种，并感染过来。换言之，假设操作前的核心计算机编号为 $y$，相当于在操作后附加了一次 `RELEASE y` 的操作。

根据研究的结论，在植入一个新变种时，病毒会在局域网中搜索核心计算机的位置，并沿着网络中最短的路径感染过去。

而第一轮实验揭露了一个惊人的真相：病毒的不同变种是互斥的。新变种在感染一台已经被旧变种感染的电脑时，会把旧变种完全销毁之后再感染。但研究员发现了实现过程中的漏洞。如果新变种在感染过程中尚未销毁过这类旧变种，需要先花费 $1$ 单位时间分析旧变种，才能销毁。如果之前销毁过这类旧变种，就可以认为销毁不花费时间。病毒在两台计算机之间的传播亦可认为不花费时间。

研究员对整个感染过程的耗时特别感兴趣，因为这是消灭病毒的最好时机。于是在 $m$ 步步实验之中，研究员有时还会做出如下的询问：

- `REQUEST x`。询问如果在编号为 $x$ 的计算机的关键集合中的计算机中植入一个新变种，平均感染时间为多长。编号为 $y$ 的计算机在编号为 $x$ 的计算机的关键集合中，当且仅当从 $y$ 沿网络中的最短路径感染到核心计算机必须经过 $x$。由于有 `RECENTER` 操作的存在，这个集合并不一定是始终不变的。

至此，安全机构认为已经不需要实际的实验了，于是他们拜托你编写一个程序，模拟实验的结果，并回答所有的询问。

## 说明/提示

对于 $100\%$ 的数据，$1\leq n\leq 10^5$，$1\leq m\leq 10^5$。

## 样例 #1

### 输入

```
8 6
1 2
1 3
2 8
3 4
3 5
3 6
4 7
REQUEST 7
RELEASE 3
REQUEST 3
RECENTER 5
RELEASE 2
REQUEST 1```

### 输出

```
4.0000000000
2.0000000000
1.3333333333```

# 题解

## 作者：Purslane (赞：0)

# Solution

LCT 复习就写两题吧，感觉 NOI 不会考。

-----

由于染色操作十分特殊，不难发现：同一类型的病毒，在所有时刻都是连续的。那么一个点所花费的时间，就是它到根路径上颜色连续段的个数。

对于一条边，如果它相连的两个点颜色不同，权值为 $1$，否则为 $0$。则颜色连续段个数就是该节点到根路径权值和加 $1$。

而染色就非常像 $\rm Access$ 操作。因此你可以快速维护权值变化。

-----

唉但是你发现统计答案比较困难 /ll

假设当前的根是 $r$，我们查询了 $u$。

- 如果 $u$ 在**以 $1$ 为根的树上不是 $r$ 的祖先**

此时 $u$ 的子树和以 $1$ 为根的子树是一样的。

![](https://s21.ax1x.com/2024/07/06/pkWCOds.png)

如图。黑色子树内的每条边，它的贡献都是**边权 $\times$ 儿子节点的子树大小**，而红色树链上的每条边的贡献是**边权 $\times$ 黑色子树大小**。

求出 LCA 后，可以用树状数组等数据结构维护。

- 如果 $u$ 在**以 $1$ 为根的树上是 $r$ 的祖先**

我们将所有边分为三类：紫色表示 $u$ 到 $1$ 的路径上的点，红色表示包含 $r$ 的一个 $u$ 儿子的子树内的边，黑色表示其他边。

![不是，哥们](https://s21.ax1x.com/2024/07/06/pkWCzWV.png)

黑色的边对答案的贡献仍然为**边权 $\times$ 儿子节点的子树大小**，紫色边对答案的贡献变为**边权 $\times$ $(n-$ 儿子节点的子树大小 $)$**，红色边只有在 $u$ 到 $r$ 的路径上才会有贡献。

这还是可以用树状数组维护。

捋一捋树状数组维护什么（首先要拍成 DFS 序）

1. 每个点到 $1$ 的权值和与边权 $\times$ 儿子子树大小之和。这样每个边进行修改的时候顺带区间修改即可。

注意整棵树最开始我们认为所有边的边权都是 $1$。可以通过自底向上不断 $\rm Access$ 得到。

2. 子树内边权 $\times$ 儿子子树大小之和。这个可以随手单点修改。

复杂度 $O(n \log n)$，完全没必要树链剖分，但是可能要开 $3$ 个树状数组。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e5+10;
int n,m,rt=1,tp[MAXN],fa[MAXN][20],dep[MAXN],tot,dfn[MAXN],sze[MAXN];
vector<int> G[MAXN];
struct Node {
	int s[2],fa,flp,l,r;
}t[MAXN];
void flip(int u) {
	return swap(t[u].s[0],t[u].s[1]),t[u].flp^=1,swap(t[u].l,t[u].r),void();
}
void push_down(int u) {
	if(t[u].flp) flip(t[u].s[0]),flip(t[u].s[1]);
	return t[u].flp=0,void();	
}
void push_up(int u) {
	if(t[u].s[0]) t[u].l=t[t[u].s[0]].l; else t[u].l=u;
	if(t[u].s[1]) t[u].r=t[t[u].s[1]].r; else t[u].r=u;
	return ;	
}
int is_root(int u) {
	return u!=t[t[u].fa].s[0]&&u!=t[t[u].fa].s[1];	
}
int get(int u) {
	return u==t[t[u].fa].s[1];	
}
void rotate(int u) {
	int fa=t[u].fa,s=get(u),op=get(fa);
	if(!is_root(fa)) t[t[fa].fa].s[op]=u;t[u].fa=t[fa].fa;
	t[fa].s[s]=t[u].s[s^1],t[t[u].s[s^1]].fa=fa;
	t[u].s[s^1]=fa,t[fa].fa=u;
	return push_up(fa),push_up(u),void();	
}
void PUSH_DOWN(int u) {
	if(!is_root(u)) PUSH_DOWN(t[u].fa);
	return push_down(u),void();	
}
void splay(int u) {
	PUSH_DOWN(u);
	for(int f;f=t[u].fa,!is_root(u);rotate(u)) if(!is_root(f)) rotate(get(u)==get(f)?f:u);
	return ;
}
pair<int,vector<pair<int,int>>> access(int u) {
	int lst=0; vector<pair<int,int>> ans;
	while(u) {
		splay(u);
		if(lst) ans.push_back({t[lst].l,u});
		if(t[u].s[1]) ans.push_back({u,t[t[u].s[1]].l});
		t[u].s[1]=lst,push_up(u),lst=u,u=t[u].fa;
	}
	return {lst,ans};
}
void dfs(int u,int f) {
	t[u].fa=f,dep[u]=dep[f]+1,dfn[u]=++tot,sze[u]=1,fa[u][0]=f;
	ffor(i,1,19) fa[u][i]=fa[fa[u][i-1]][i-1];
	for(auto v:G[u]) if(v!=f) dfs(v,u),sze[u]+=sze[v];
	return ;
}
int jump(int u,int dt) {
	ffor(i,0,19) if(dt&(1<<i)) u=fa[u][i];
	return u;
}
int lca(int u,int v) {
	if(dep[u]<dep[v]) swap(u,v);
	u=jump(u,dep[u]-dep[v]);
	if(u==v) return u;
	roff(i,19,0) if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i];
	return fa[u][0];
}
struct BIT {
	vector<int> vc;
	void build(int n) {return vc.resize(n+10),void();}
	void update(int pos,int v) {
		while(pos<=n) vc[pos]+=v,pos+=pos&-pos;
		return ;
	}
	int query(int pos) {
		int ans=0;
		while(pos) ans+=vc[pos],pos-=pos&-pos;
		return ans;	
	}
	int query(int l,int r) {
		return query(r)-query(l-1);	
	}
}s1,s2,s3;
void change(int i) {
	if(!tp[i]) {
		tp[i]=1;
		s1.update(dfn[i],1),s1.update(dfn[i]+sze[i],-1);
		s2.update(dfn[i],sze[i]),s2.update(dfn[i]+sze[i],-sze[i]);
		s3.update(dfn[i],sze[i]);
	}
	else {
		tp[i]=0;
		s1.update(dfn[i],-1),s1.update(dfn[i]+sze[i],1);
		s2.update(dfn[i],-sze[i]),s2.update(dfn[i]+sze[i],sze[i]);
		s3.update(dfn[i],-sze[i]);	
	}
	return ;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	ffor(i,1,n) t[i].l=t[i].r=i;
	ffor(i,1,n-1) {
		int u,v;
		cin>>u>>v,G[u].push_back(v),G[v].push_back(u);	
	}
	dfs(1,0),s1.build(n),s2.build(n),s3.build(n);
	ffor(i,2,n) {
		tp[i]=1;
		s1.update(dfn[i],1),s1.update(dfn[i]+sze[i],-1);
		s2.update(dfn[i],sze[i]),s2.update(dfn[i]+sze[i],-sze[i]);
		s3.update(dfn[i],sze[i]);
	}
	ffor(i,1,m) {
		string S;
		int x;
		cin>>S>>x;
		if(S=="RELEASE") {
			auto vc=access(x).second;
			for(auto pr:vc) {
				int u=pr.first,v=pr.second;
				if(fa[u][0]==v) change(u);
				else change(v);
			}
		}
		else if(S=="RECENTER") {
			auto pr=access(x);
			auto vc=pr.second;
			auto id=pr.first;
			flip(id);
			for(auto pr:vc) {
				int u=pr.first,v=pr.second;
				if(fa[u][0]==v) change(u);
				else change(v);
			}
			rt=x;
		}
		else {
			int ans=0,u=x,r=rt,l=lca(u,r);
			if(l!=u) {
				int cnt_ot=s1.query(dfn[u])+s1.query(dfn[r])-2*s1.query(dfn[l]);
				ans=s3.query(dfn[u]+1,dfn[u]+sze[u]-1)+sze[x]*cnt_ot;
				cout<<fixed<<setprecision(10)<<1.0*ans/sze[u]+1<<'\n';
			}
			else if(r!=u) {
				int kel=jump(r,dep[r]-dep[u]-1);
				int purple=n*s1.query(dfn[u])-2*s2.query(dfn[u]),black=s3.query(n)-s3.query(dfn[kel],dfn[kel]+sze[kel]-1);
				cout<<fixed<<setprecision(10)<<1.0*(purple+black)/(n-sze[jump(r,dep[r]-dep[u]-1)])+1+s1.query(dfn[r])-s1.query(dfn[u])<<'\n';
			}
			else {
				int purple=n*s1.query(dfn[u])-2*s2.query(dfn[u]),black=s3.query(n);
				cout<<fixed<<setprecision(10)<<1.0*(purple+black)/n+1<<'\n';	
			}
		}
	}
	return 0;
}
```

---


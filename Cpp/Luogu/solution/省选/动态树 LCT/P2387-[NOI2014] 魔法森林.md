# [NOI2014] 魔法森林

## 题目背景

[hack数据的提交link](https://www.luogu.com.cn/problem/U163126)

## 题目描述

为了得到书法大家的真传，小 E 同学下定决心去拜访住在魔法森林中的隐士。魔法森林可以被看成一个包含 $n$ 个节点 $m$ 条边的无向图，节点标号为 $1,2,3,…,n$，边标号为 $1,2,3,…,m$。初始时小 E 同学在 $1$ 号节点，隐士则住在 $n$ 号节点。小 E 需要通过这一片魔法森林，才能够拜访到隐士。

魔法森林中居住了一些妖怪。每当有人经过一条边的时候，这条边上的妖怪 就会对其发起攻击。幸运的是，在 $1$ 号节点住着两种守护精灵：A 型守护精灵与 B 型守护精灵。小 E 可以借助它们的力量，达到自己的目的。

只要小 E 带上足够多的守护精灵，妖怪们就不会发起攻击了。具体来说，无向图中的每一条边 $e_i$ 包含两个权值 $a_i$ 与 $b_i$ 。若身上携带的 A 型守护精灵个数不少于 $a_i$ ，且 B 型守护精灵个数不少于 $b_i$ ，这条边上的妖怪就不会对通过这条边的人发起攻击。当且仅当通过这片魔法森林的过程中没有任意一条边的妖怪向 小 E 发起攻击，他才能成功找到隐士。

由于携带守护精灵是一件非常麻烦的事，小 E 想要知道，要能够成功拜访到 隐士，最少需要携带守护精灵的总个数。守护精灵的总个数为 A 型守护精灵的个数与 B 型守护精灵的个数之和。


## 说明/提示

\* 解释1

如果小 E 走路径 $1\to 2\to 4$，需要携带 $19+15=34$ 个守护精灵； 如果小 E 走路径 $1\to 3\to 4$，需要携带 $17+17=34$ 个守护精灵； 如果小 E 走路径 $1\to 2\to 3\to 4$，需要携带 $19+17=36$ 个守护精灵； 如果小 E 走路径  $1\to 3\to 2\to 4$，需要携带 $17+15=32$ 个守护精灵。 综上所述，小 E 最少需要携带 $32$ 个守护精灵。

\* 解释2

小 E 无法从 $1$ 号节点到达 $3$ 号节点，故输出 `-1`。

![](https://cdn.luogu.com.cn/upload/pic/2593.png)


## 样例 #1

### 输入

```
4 5 
1 2 19 1 
2 3 8 12 
2 4 12 15 
1 3 17 8 
3 4 1 17 ```

### 输出

```
32
```

## 样例 #2

### 输入

```
3 1 
1 2 1 1 ```

### 输出

```
-1```

# 题解

## 作者：Soulist (赞：52)

感觉最近做的一些$LCT$的题目其实都是不断加边，判环，取较优者。

比如这道题，一句话题解就是按照边权$A$排序后用$LCT$维护边权$B$的最小生成树

比如[最小生成树](https://www.luogu.org/blog/Soulist/solution-p3366)，它用$LCT$实现的话主要就是遇到一条边后，若其联通了两个已经联通的点，那么其为返祖边，会形成环，那么我们就把环上最大的边断掉即可。

简单写就是$split(u,v)$，然后把$cut(max, u), cut(max,v)$

这道题也类似的，我们可以离线，将边按照边权$A$排序

然后不断的加边，如果一条边连接了两个联通块，那么这条路径是必需的。

这个时候我们保证了边权$A$单调递增，我们用$LCT$维护图中的边权$B$

然后对于一条路径，如果其沟通了两个已经联通的联通块，我们可以这样考虑：

当前路径的$A$比之前存在的任意路径的$A$都大，如果其$B$比这环上边$B$的最大值还要大，那么加入这条边只会让答案变得更不优。

如果当前路径的$B$比环上最大的$B$要小，那么加入这条路径后，显然有：

$(1):$假如当前$1-n$未联通，那么对于后续的边，若其加入后可以使$1-n$联通，不难想到：其$A$显然仍然大于当前边，所以我们需要最小化链上的$B$，也就是断掉环上最大$B$的边，然后加入这条边

$(2):$假如当前$1-n$已经联通，我们实际上已经求得了最大 A 比此边小的时候的答案，我们可以先加入此边，求出最大 A 稍微大一点的答案，取$min$，然后类似$(1)$的分析，可以发现这条边加入后会使得后续边算得的答案更优。

当然前提是这条边的$B$大于环上最大$B$

注意细节

```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
	char cc = getchar(); int cn = 0, flus = 1;
	while(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }
	while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
	return cn * flus;
}
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define ls(x) t[x].son[0]
#define rs(x) t[x].son[1]
const int N =  150000 + 5; 
const int inf = 1234567890;
struct E {
	int from, to, a, b;
} e[N];
struct LCT {
	int son[2], fa, mx, id;
	bool mark;
} t[N];
int n, m, Idnum, ans, w[N], st[N];
bool cmp( E x, E y ) {
	return ( x.a == y.a ) ? x.b < y.b : x.a < y.a ;
}
bool isroot( int x ) {
	return ( ls(t[x].fa) != x ) && ( rs(t[x].fa) != x );
}
void pushup( int x ) {
	t[x].mx = w[x], t[x].id = x;
	if( ls(x) && t[ls(x)].mx > t[x].mx ) t[x].mx = t[ls(x)].mx, t[x].id = t[ls(x)].id;
	if( rs(x) && t[rs(x)].mx > t[x].mx ) t[x].mx = t[rs(x)].mx, t[x].id = t[rs(x)].id;
}
void rotate( int x ) {
	int f = t[x].fa, ff = t[f].fa, qwq = ( rs(f) == x );
	t[x].fa = ff;
	if( !isroot(f) ) t[ff].son[rs(ff) == f] = x;
	t[f].son[qwq] = t[x].son[qwq ^ 1], t[t[x].son[qwq ^ 1]].fa = f;
	t[x].son[qwq ^ 1] = f, t[f].fa = x;
	pushup(f), pushup(x);
}
void pushmark( int x ) {
	if( t[x].mark ) {
		t[x].mark = 0, t[ls(x)].mark ^= 1, t[rs(x)].mark ^= 1,
		swap( ls(x), rs(x) );
	}
} 
void Splay( int x ) {
	int top = 0, now = x; st[++top] = now;
	while( !isroot(now) ) st[++top] = ( now = t[now].fa );
	while( top ) pushmark( st[top--] );
	while( !isroot(x) ) {
		int f = t[x].fa, ff = t[f].fa;
		if( !isroot(f) ) ( ( rs(ff) == f ) ^ ( rs(f) == x ) ) ? rotate(x) : rotate(f) ;
		rotate(x);
	}
}
void access( int x ) {
	for( int y = 0; x; y = x, x = t[y].fa )
		Splay(x), t[x].son[1] = y, pushup(x);
}
void makeroot( int x ) {
	access(x), Splay(x), t[x].mark ^= 1, pushmark(x);
}
int findroot( int x ) {
	access(x), Splay(x), pushmark(x);
	while( ls(x) ) pushmark( x = ls(x) );
	return x;
}
void split( int x, int y ) {
	makeroot(x), access(y), Splay(y);
}
void link( int x, int y ) {
	makeroot(x);
	if( findroot(y) != x ) t[x].fa = y;
}
bool check( int x, int y ) {
	makeroot(x);
	return findroot(y) != x;
}
signed main()
{
	n = read(), m = read(), ans = inf;
	rep( i, 1, m ) e[i].from = read(), e[i].to = read(), e[i].a = read(), e[i].b = read();
	sort( e + 1, e + m + 1, cmp );
	rep( i, 1, m ) {
		w[i + n] = e[i].b;
		if( e[i].from == e[i].to ) continue;
		if( check( e[i].from, e[i].to ) ) link( e[i].from, i + n ), link( i + n, e[i].to );
		else {
			split( e[i].from, e[i].to );
			int now = t[e[i].to].id, maxb = t[e[i].to].mx;
			if( maxb <= e[i].b ) continue;
			Splay( now ), t[ls(now)].fa = t[rs(now)].fa = 0;
			link( e[i].from, i + n ), link( i + n, e[i].to );
		} 
		if( !check( 1, n ) ) {
			split( 1, n ); ans = min( ans, t[n].mx + e[i].a );
		}
	}
	if( ans == inf ) puts("-1");
	else printf("%d\n", ans);
	return 0;
}
```

---

## 作者：xyz32768 (赞：42)

直接求解比较麻烦。考虑先按照$A_i$为关键字将每条边排序，然后按顺序动态加入每一条边。以下定一条路径的代价为一条路径经过的所有边的$B$的最大值。可以知道，加入第$i$条边之后的最小代价，就是$A_i$加上从$1$到$n$的所有路径中，代价最小的路径的代价。

看到动态加边，可以想到使用LCT来完成。由于要维护边权，所以要把边在LCT中理解成点。

但是现在的一个问题是出现环时应该怎样处理。假设现在要连边$(u,v)$，但$u$和$v$之间已经存在一条路径。这样就必须在$u$到$v$的路径中选一条边断开。由于操作后要求得最小代价，因此，应该在$u$到$v$的路径中，选择一条边权最大的边断开后再连边$(u,v)$。当然，如果$u$和$v$在连边之前不连通，就不必要做这个步骤了。

连边之后，即可询问$1$到$n$的路径代价，加上$A_i$并更新答案。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 2e5 + 5;
int n, m, fa[N], lc[N], rc[N], rev[N], que[N], len, val[N], sm[N],
f[N];
struct cyx {int a, b, x, y;} ask[N];
int cx(int x) {
    if (f[x] != x) f[x] = cx(f[x]);
    return f[x];
}
void zm(int x, int y) {
    int ix = cx(x), iy = cx(y);
    if (ix != iy) f[iy] = ix;
}
bool comp(cyx a, cyx b) {return a.y < b.y;}
int which(int x) {return rc[fa[x]] == x;}
bool is_root(int x) {
    return !fa[x] || (lc[fa[x]] != x && rc[fa[x]] != x);
}
void upt(int x) {
    sm[x] = x;
    if (lc[x] && val[sm[lc[x]]] > val[sm[x]]) sm[x] = sm[lc[x]];
    if (rc[x] && val[sm[rc[x]]] > val[sm[x]]) sm[x] = sm[rc[x]];
}
void down(int x) {
    if (rev[x]) {
        swap(lc[x], rc[x]);
        if (lc[x]) rev[lc[x]] ^= 1;
        if (rc[x]) rev[rc[x]] ^= 1;
        rev[x] = 0;
    }
} 
void rotate(int x) {
    int y = fa[x], z = fa[y], b = lc[y] == x ? rc[x] : lc[x];
    if (z && !is_root(y)) (lc[z] == y ? lc[z] : rc[z]) = x;
    fa[x] = z; fa[y] = x; b ? fa[b] = y : 0;
    if (lc[y] == x) rc[x] = y, lc[y] = b;
    else lc[x] = y, rc[y] = b; upt(y); upt(x);
}
void splay(int x) {
    int i, y; que[len = 1] = x;
    for (y = x; !is_root(y); y = fa[y]) que[++len] = fa[y];
    for (i = len; i >= 1; i--) down(que[i]);
    while (!is_root(x)) {
        if (!is_root(fa[x])) {
            if (which(x) == which(fa[x])) rotate(fa[x]);
            else rotate(x);
        }
        rotate(x);
    }
    upt(x);
}
void Access(int x) {
    int y;
    for (y = 0; x; y = x, x = fa[x]) {
        splay(x); rc[x] = y;
        if (y) fa[y] = x; upt(x);
    }
}
int Find_Root(int x) {
    Access(x); splay(x);
    while (down(x), lc[x]) x = lc[x];
    splay(x); return x;
}
void Make_Root(int x) {
    Access(x); splay(x);
    rev[x] ^= 1;
}
void Link(int x, int y) {
    Make_Root(x); fa[x] = y;
}
void Cut(int x, int y) {
    Make_Root(x); Access(y); splay(y);
    lc[y] = 0; fa[x] = 0; upt(y);
}
int Select(int x, int y) {
    Make_Root(x); Access(y); splay(y);
    return sm[y];
}
int main() {
    int i, ans = 2e9; n = read(); m = read();
    for (i = 1; i <= m; i++)
        ask[i].a = read(), ask[i].b = read(),
        ask[i].x = read(), ask[i].y = read();
    sort(ask + 1, ask + m + 1, comp);
    for (i = 1; i <= n + m; i++) f[i] = sm[i] = i;
    for (i = n + 1; i <= n + m; i++) val[i] = ask[i - n].x;
    for (i = 1; i <= m; i++) {
        int u = ask[i].a, v = ask[i].b; bool flag = 1;
        if (cx(u) == cx(v)) {
            int w = Select(u, v);
            if (val[w] > ask[i].x)
                Cut(ask[w - n].a, w), Cut(w, ask[w - n].b);
            else flag = 0;
        }
        else zm(u, v); if (flag) Link(u, i + n), Link(i + n, v);
        if (cx(1) == cx(n))
            ans = min(ans, ask[i].y + val[Select(1, n)]);
    }
    if (ans < 2e9) printf("%d\n", ans);
    else printf("-1\n");
    return 0;
}
```

---

## 作者：panda_2134 (赞：36)

感觉其他题解并不是很详细。。。所以写一篇比较详细地讲解了思路的题解。顺便贴下自己的Blog:[Panda\_2134's Blog](https://blog.panda2134.site/2018/01/18/MagicForest)


## 题意


给出一个$n$个点，$m$条边的无向图，每条边都有权值$a_i,b_i$，求一条从点$1$到点$n$的路径，使得这条路径上边的$a_i,b_i$最大值之和最小。$2 \leq n \leq 5 \times 10^4, 0 \leq m \leq 1 \times 10^5$。



## 思路


### 二分？


看到\*最大值最小\*，想到二分。怎么二分呢？如果是只有一种权值的情况，可以二分+BFS，不过我们有更好的方法，也就是瓶颈生成树。也就是说这里要求出2个参数的瓶颈生成树。对于有2种权值的情况，是否也可以类似地直接贪心呢？比如说，按照$a_i+b_i$排序？听上去就不靠谱。或者说先二分$a_i$，对每个$a_i$的值去二分$b_i$？ 这也不符合“和的最大值最小”这个要求。


### 生成树！


不过，这个做法倒是提供了一些思路。我们也许可以枚举$\max\{a_i\}$，对每个枚举出来的$\max\{a_i\}$去判断如何加边。 暴力枚举复杂度太高。考虑效仿Kruskal算法，把边按照$a_i$排序，然后再枚举当前考虑第几条边。这样的话每次判断是否加入当前边即可。判断的依据是什么？是否成环，环中最大边是哪条。根据生成树的回路性质，某个回路中的权值最大边恰好有一条不在最小生成树中。于是每次加边（相当于枚举了$a_i$），同时对$b_i$做动态加边最小生成树，再用$a_i$与当前的$1 \rightarrow n$路径上的$\max\{b_i\}$之和更新答案。显然对于每个给定的$a_i$，$b_i$满足最小生成树性质时一定最优。而我们枚举了$a_i$的取值，这样一定可以遍历所有的可能情况。


### 细节的处理


上面的方法似乎很正确，不过好像有点问题：加入的边一定在$1 \rightarrow n$的路径上吗？


稍微想想就会发现，就算加的边和这条路径无关，也没有关系：由于这时$a_i$大于$1 \rightarrow n$的路径上$a_i$最大值，而$1 \rightarrow n$的路径上$b_i$最大值又不变，于是在考虑$1 \rightarrow n$的路径上$a_i$最大值时，答案已经松弛过了，此时不能再松弛答案！如果当前边与$1 \rightarrow n$的路径上某个边构成环，那么这次松弛也是有用的，因为对于不同的$\max\{a_i\}$，$b_i$取值也相应不同。


## 实现


考虑下求出“生成树路径边权最大值”怎么做到：用Link-Cut Tree即可。通过一次$\text{MakeRoot}$和一次$\text{Access}$，就可以把路径弄到一条$\text{Preferred Path}$上。然后在Splay里面打标记就好了。注意边权的处理：给每条边单独建一个点就好了。


代码如下：


```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 5e4, MAXM = 1e5;

//----------------LCT--------------------
struct Node *null, *nd[MAXN+10];
struct Node {
    int v, s, maxv; bool flip;
    Node *fa, *ch[2];
    Node() { v = maxv = 0; s = 1; flip = false; fa = ch[0] = ch[1] = null; }
    Node(int v_) { v = maxv = v_; s = 1; flip = false; fa = ch[0] = ch[1] = null; }
    bool splayrt() { return fa->ch[0]!=this && fa->ch[1]!=this; }
    int rel() { return splayrt() ? -1 : (fa->ch[0]==this ? 0 : 1); }
    void rev() { flip^=1; }
    int cmp(int k) { return k == ch[0]->s + 1 ? -1 : (k > ch[0]->s + 1 ? 1 : 0); }
    void pushdown() {
        if(flip) {
            flip^=1; ch[0]->flip^=1; ch[1]->flip^=1;
            swap(ch[0], ch[1]);
        }
    }
    void maintain() {
        maxv = max(max(ch[0]->maxv, ch[1]->maxv), v);
        s = ch[0]->s + ch[1]->s + 1;
    }
};

void init_null() {
    null = new Node(0); null->s = 0;
}

void rotate(Node* o) {
    Node *x, *y, *k; int d, d2;
    if(o->splayrt()) return;
    x = o->fa; y = x->fa;
    d = o->rel(); d2 = x->rel();
    k = o->ch[d^1];
    if(!x->splayrt()) y->ch[d2] = o;
    o->fa = y;
    o->ch[d^1] = x; x->fa = o;
    x->ch[d] = k; k->fa = x;
    x->maintain(); o->maintain();
}

void Splay(Node* o) {
    static Node *x, *S[(MAXN<<1)+10]; int p, d, d2;
    for(p=1, S[p] = o; !S[p]->splayrt(); p++)
        S[p+1] = S[p]->fa;
    for(; p; p--) S[p]->pushdown();
    while(!o->splayrt()) {
        x = o->fa; 
        d = o->rel(); d2 = x->rel();
        if(!x->splayrt()) {
            if(d == d2) rotate(x);
            else rotate(o);
        }
        rotate(o);
    }
}

Node* FindMax(Node* o) {
    if(o->v == o->maxv) //!!
        return o;
    else return o->ch[0]->maxv == o->maxv ? 
        FindMax(o->ch[0]) : FindMax(o->ch[1]);
}

Node* Kth(Node* o, int k) {
    if(o == null) return o;
    int d = o->cmp(k);
    if(d==-1) return o;
    return Kth(o->ch[d], k - d*(o->ch[0]->s + 1));
}

void Access(Node* o) {
    for(Node *t=null; o!=null; t=o, o=o->fa) {
        Splay(o); o->ch[1] = t; o->maintain();
    }
}

void MakeRoot(Node* o) {
    Access(o); Splay(o); o->rev();
}

Node* GetRoot(Node* o) {
    Access(o); Splay(o);
    while(o->ch[0] != null) o = o->ch[0];
    return o;
}

void Link(Node* u, Node* v) {
    if(GetRoot(u) == GetRoot(v)) return;
    MakeRoot(u); Splay(u); u->fa = v;
}

void Cut(Node* u, Node* v) {
    if(GetRoot(u) != GetRoot(v)) return;
    MakeRoot(u); Access(v); Splay(u);
    if(u->ch[1] == v) {
        u->ch[1] = null; v->fa = null;
        u->maintain();
    }
}

//-----------------------------------------

struct Edge {
    int u, v, a, b;
    Edge() {}
    Edge(int u_, int v_, int a_, int b_):
        u(u_), v(v_), a(a_), b(b_) {}
    inline bool operator<(const Edge& rhs) const
    { return a < rhs.a; }
} E[MAXM+10];
int N, M, Ans, fa[MAXN+10];

int GetFather(int x) { return fa[x] == x ? x : fa[x] = GetFather(fa[x]); }
inline void Union(int x, int y) { fa[GetFather(x)] = GetFather(y); }

template<typename T>
inline void readint(T& x) {
    T f=1, r=0; char c=getchar();
    while(!isdigit(c)){ if(c=='-')f=-1; c=getchar(); }
    while(isdigit(c)){ r=r*10+c-'0'; c=getchar(); }
    x = f*r;
}

void Init() {
    int u, v, a, b;
    init_null(); 
    readint(N); readint(M);
    for(int i=1; i<=N; i++) {
        nd[i] = new Node(0);
        fa[i] = i;
    }
    for(int i=1; i<=M; i++) {
        readint(u); readint(v);
        readint(a); readint(b);
        E[i] = Edge(u, v, a, b);
    }
    sort(E+1, E+M+1);
}

inline void AddTreeEdge(int u, int v, int b) {
    Node* w = new Node(b);
    Link(nd[u], w); Link(nd[v], w);
    if(GetFather(u) != GetFather(v)) 
        Union(u, v);
}

inline Node* GetMaxEdge(int u, int v) {
    Node* w;
    MakeRoot(nd[u]); Access(nd[v]); Splay(nd[u]);
    w = FindMax(nd[u]); 
    Splay(w);
    return w;
}

inline void CutMaxEdge(int u, int v) {
    Node *w, *x, *y; int k;
    w = GetMaxEdge(u, v); k = w->ch[0]->s + 1;
    x = Kth(w, k-1); y = Kth(w, k+1);
    if(x == null || y == null) return;
    Cut(w, x); Cut(w, y);
}

void Work() {
    int u, v, a, b; bool add = false;
    Ans = INT_MAX;
    for(int t=1; t<=M; t++) {
        u = E[t].u, v = E[t].v, a = E[t].a, b = E[t].b;
        add = false;
        if(GetFather(u) != GetFather(v)) 
            add = true, AddTreeEdge(u, v, b);
        else if(b < GetMaxEdge(u, v)->v) {
            add = true;
            CutMaxEdge(u, v);
            AddTreeEdge(u, v, b);
        }
        //更新答案
        if(add && GetFather(1) == GetFather(N)) 
            Ans = min(Ans, a + GetMaxEdge(1, N)->v);
    }
    if(Ans < INT_MAX)
        printf("%d", Ans);
    else puts("-1");
}

int main() {
    Init(); Work();
    return 0;
}
```

---

## 作者：沧海映繁星 (赞：27)

如果我告诉你们，这个题不需要用LCT也能过你们信吗？

我也不知道是数据水，还是我人品好

反正呢，我用一种错误的算法，过掉了这个题

由于觉得比较有纪念意义，所以还是决定写出来

算是一种骗分的小技巧
~~（顺带提醒管理员改漏洞）~~

下面进入正题：

本题要求是这样的：求出所需的A种精灵和B种精灵数量和的最小值

如果将这个题目改一下，将怪物和精灵都改得只剩A种，那么很显然，这题可以用二分答案来做
~~（但显然这是不可能的）~~

既然，一项数据可以这么做，那么两项呢？多套一个二分部就是的了，反正O（n log²n）也能过不是吗？
（看到这里，请大佬别喷，本蒟蒻当时还真就是这么想的）

然后，我就这这么干了？

我写的代码是这样的：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 100005
#define int long long
struct node{
    int l,r,a,b;
}t[maxn];
int n,m,maxa,maxb,ans = 99999999;
int f[maxn];
int find(int k){
    if(f[k] != k) f[k] = find(f[k]);
    return f[k];
}
bool check(int x,int y){
    for(int i = 1; i <= n; i++) f[i] = i;
    for(int i = 1; i <= m; i++){
        if(x >= t[i].a && y >= t[i].b){
            f[find(t[i].l)] = f[find(t[i].r)];
        }
    }
    if(f[find(1)] == f[find(n)]){
        ans = min(ans,x + y);
        return 1;
    }
    else return 0;
}
bool find_a(int k){
    int l = 0,r = maxa + 1,mid;
    while(l + 5 <= r){
        mid = (l + r) >> 1;
        bool p = check(mid,k);
        if(p) r = mid;
        else l = mid;
    }
    for(int i = l; i <= r; i++){
        if(check(i,k)) return 1;
    }
    return 0;
}
void find_b(){
    int l = 0,r = maxb + 1,mid;
    while(l + 5 <= r){
        mid = (l + r) >> 1;
        bool p = find_a(mid);
        if(p) r = mid;
        else l = mid;
    }
    for(int i = l; i <= r; i++) find_a(i);
}
signed main(){
    scanf("%lld%lld",&n,&m);
    for(int i = 1; i <= m; i++){
        scanf("%lld%lld%lld%lld",&t[i].l,&t[i].r,&t[i].a,&t[i].b);
        maxa = max(t[i].a,maxa);
        maxb = max(t[i].b,maxb);
    }
    find_b();
    if(ans == 99999999) printf("-1");
    else printf("%lld",ans);
}
}
```
先枚举 b 的值，再在已知 b 值的情况下，尽可能的让 a 值小

不过很显然这是错的，因为在这样枚举的过程中，其实 b 值不一定是合法情况下的最小值，稍稍大一点的话，可能让原来过不了的边过掉，而这条边所需的 a 值较小
（这里可能不太好理解，但总之这种算法是错的）

虽说是错的，但使用这样一份代码也可以拿到80分

然后再转念一想，这样的误差是很小的

如果我们在求出结果后，将“最佳”的 b 值，在保证不超时的情况下，再往大了枚举一点点的话，就有可能找出真正的最佳答案

然后我就这么干了，算了一下，再算出结果后，大概还能把 b 再往后枚举 20 （也可能更多吧，极限是多少没试过，反正 20 就能过）

然后，居然就AC了

更改后的代码是这样

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 100005
struct node{
    int l,r,a,b;
}t[maxn];
int n,m,maxa,maxb,ans = 99999999;
int f[maxn];
int read(){
    int x = 0,f = 1;
    char s;
    s = getchar();
    while(s < '0' || s > '9'){
        if(s == '-') f = -1;
        s = getchar();
    }
    while('0' <= s && s <= '9'){
        x = (x << 1) + (x << 3) + s - '0';
        s = getchar();
    }
    return x * f;
}
int find(int k){
    if(f[k] != k) f[k] = find(f[k]);
    return f[k];
}
bool check(int x,int y){
    for(int i = 1; i <= n; i++) f[i] = i;
    for(int i = 1; i <= m; i++){
        if(x >= t[i].a && y >= t[i].b){
            f[find(t[i].l)] = f[find(t[i].r)];
        }
    }
    if(f[find(1)] == f[find(n)]){
        ans = min(ans,x + y);
        return 1;
    }
    else return 0;
}
bool find_a(int k){
    int l = 0,r = maxa << 1,mid;
    while(l + 5 <= r){
        mid = (l + r) >> 1;
        bool p = check(mid,k);
        if(p) r = mid;
        else l = mid;
    }
    for(int i = l; i <= r; i++){
        if(check(i,k)) return 1;
    }
    return 0;
}
void find_b(){
    int l = 0,r = maxb << 1,mid;
    while(l + 5 <= r){
        mid = (l + r) >> 1;
        bool p = find_a(mid);
        if(p) r = mid;
        else l = mid;
    }
    for(int i = l; i <= r + 20; i++) find_a(i);
}
signed main(){
    //freopen("a.in","r",stdin);
    //freopen("a.out","w",stdout);
    n = read();
    m = read();
    // printf("%d %d",n,m);
    for(int i = 1; i <= m; i++){
        t[i].l = read();
        t[i].r = read();
        t[i].a = read();
        t[i].b = read();
        maxa = max(t[i].a,maxa);
        maxb = max(t[i].b,maxb);
    }
    find_b();
    if(ans == 99999999) printf("-1");
    else printf("%d",ans);
}
```

虽然我也没指望能过审核，但还是说一句吧：

这种方法并非正解，甚至可以说是歪门邪道；联赛时，可以用类似的方法来追求高分；但平时练习时，还是不建议使用这类方法；以本题为例，想要真正的提升还是得去学习LCT算法

---

## 作者：λᴉʍ (赞：21)

LCT练手好题啊。

SPFA的做♂FA是把边按照a排序，然后加一条权值为b的边跑SPFA，不断更新答案。很好的做♂FA，但复杂度无♂FA保证。

LCT的做♂FA类似，也是把边按照a排序，然后也是加一条权值为b的边，动态维护最小生成树。

然后赋边权的方♂FA是新建一个点表示边，原来点的权值为0，边的权值还是边的权值，剩下的都一样辣。

```cpp
// It is made by XZZ
#include<cstdio>
#include<algorithm>
#define il inline
#define rg register
#define vd void
#define sta static
typedef int mainint;
#define int long long
il int gi(){
    rg int x=0,f=1;rg char ch=getchar();
    while(ch<'0'||ch>'9')f=ch=='-'?-1:f,ch=getchar();
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return x*f;
}
const int maxn=100001,maxm=100001;
namespace LCT{
    int ch[maxn][2],fa[maxn],w[maxn],mx[maxn],A[maxn],B[maxn];bool rev[maxn];
    int index;
    il vd down(const int&x){if(rev[x])std::swap(ch[x][0],ch[x][1]),rev[ch[x][0]]^=1,rev[ch[x][1]]^=1,rev[x]=0;}
    il vd upd(const int&x){
        mx[x]=x;
        if(w[mx[x]]<w[mx[ch[x][0]]])mx[x]=mx[ch[x][0]];
        if(w[mx[x]]<w[mx[ch[x][1]]])mx[x]=mx[ch[x][1]];
    }
    il bool isrt(const int&x){return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x;}
    il vd rotate(const int&x){
        sta int y,z,o;y=fa[x],z=fa[y],o=x==ch[y][1];
        if(!isrt(y))ch[z][y==ch[z][1]]=x;fa[x]=z;
        ch[y][o]=ch[x][!o];fa[ch[x][!o]]=y;
        fa[y]=x;ch[x][!o]=y;
        upd(y);
    }
    il vd splay(const int&x){
        sta int stk[maxn],top;stk[top=1]=x;
        for(rg int i=x;!isrt(i);i=fa[i])stk[++top]=fa[i];
        while(top)down(stk[top--]);
        for(rg int y=fa[x],z=fa[y];!isrt(x);rotate(x),y=fa[x],z=fa[y])
            if(!isrt(y))rotate(((x==ch[y][1])==(y==ch[z][1]))?y:x);
        upd(x);
    }
    il vd access(int x){for(rg int y=0;x;x=fa[y=x])splay(x),ch[x][1]=y,upd(x);}
    il vd makert(const int&x){access(x),splay(x);rev[x]^=1;}
    il int find(int x){access(x),splay(x);while(ch[x][0])x=ch[x][0];return x;}
    il vd split(const int&x,const int&y){makert(x);access(y),splay(y);}
    il vd _link(const int&x,const int&y){makert(x),fa[x]=y;}
    il vd cut(const int&x,const int&y){split(x,y);fa[x]=ch[y][0]=0;}
    il vd link(const int&x,const int&y,const int&k){
        if(find(x)^find(y)){w[++index]=k,_link(A[index]=x,index),_link(B[index]=y,index);return;}
        split(x,y);
        sta int s;s=mx[y];
        if(w[s]<=k)return;
        cut(s,A[s]),cut(s,B[s]);
        w[s]=k,_link(A[s]=x,s),_link(B[s]=y,s);
    }
    il int query(int x,int y){
        if(find(x)^find(y))return 1e18;
        split(x,y);return w[mx[y]];
    }
}
struct edge{int x,y,a,b;}E[maxm];
bool operator <(const edge&a,const edge&b){return a.a<b.a;}
mainint main(){
    freopen("magicalforest.in","r",stdin);
    freopen("magicalforest.out","w",stdout);
    int n=gi(),m=gi();
    for(rg int i=1;i<=m;++i)E[i].x=gi(),E[i].y=gi(),E[i].a=gi(),E[i].b=gi();
    std::sort(E+1,E+m+1);
    int ans=1e18;
    LCT::index=n;
    for(rg int i=1;i<=m;++i)LCT::link(E[i].x,E[i].y,E[i].b),ans=std::min(ans,E[i].a+LCT::query(1,n));
    if(ans==1e18)ans=-1;printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：FlashHu (赞：20)

在XZY&XZZ巨佬的引领下，一枚蒟蒻终于啃动了这道题。。。。。。

这次还是第一次写LCT维护边权，还要化边为点，思路乱七八糟的，写起来也不顺手，还好调了许久终于AC啦。

贪心排序按一个关键字从小到大枚举边，维护另一个关键字的最小生成树，这样的思路真是太巧妙啦。（然而没有题解的滋养我什么也干不了）

只是关于写法上面，我又有些和Dalao们不一样的地方（因为是自己乱写的）。

link和cut好像脱离了传统意义，本蒟蒻用了link(x)表示将编号为x的边加入用LCT维护的最小生成树，cut(x)反之。

link其实是要连两次，因为要严格深度递增（[LCT总结](http://www.cnblogs.com/flashhu/p/8324551.html)中的性质1），就让边的一个端点的父亲指向这个代表边的点（轻边），再让代表边的点的父亲指向边的另一个端点（还是轻边）。当然啦，深度大的那个点要先makeroot，不然会影响正确性。

cut就是断两次了，把代表边的点下面那个点（深度大的）access，splay（代表边的点），此时两个端点一个深度小，在左边，一个深度大，在右边，左右儿子全断掉就OK。
其实常规link，cut没问题啊，我也不知道什么时候脑袋短路搞出这种不成熟的写法，不过稍微算算，实际操作量少了些，比起两遍link或cut常数会小一点。

不过说到常数又留下一个败笔——这一题较特殊，维护连通性可以用并查集，避免了大量findroot（虽然不会T而已）。~~只是我没有写。~~findroot真慢呀！以后还是要记住这个小细节。

代码还是放一下
```cpp
#include<cstdio>
#include<cstdlib>
#include<algorithm>
using namespace std;
#define R register int
#define I inline void
#define lc c[x][0]
#define rc c[x][1]
#define G ch=getchar()
#define min2(x,y) if(x>y)x=y;
const int N=200000,P=131072;
//P是用来区分点和边的，边的编号在LCT中不变，点的编号全部加上P(为压常用了这样一个数，加上位或运算)
int f[N],c[N][2],mx[N];
bool r[N];
I in(R&z){
	register char G;
	while(ch<'-')G;
	z=ch&15;G;
	while(ch>'-')z*=10,z+=ch&15,G;
}
struct EDGE{
	int u,v,a,b;
	inline bool operator<(EDGE x)const{
		return a<x.a;
	}
	I read(){
		in(u);in(v);in(a);in(b);
		u|=P;v|=P;//编号变化
	}
}e[N];//边放进结构体
inline bool nroot(R x){
	return c[f[x]][0]==x||c[f[x]][1]==x;
}
I pushup(R x){
	mx[x]=x;
	if(e[mx[x]].b<e[mx[lc]].b)mx[x]=mx[lc];
	if(e[mx[x]].b<e[mx[rc]].b)mx[x]=mx[rc];//三种情况都要看
}
I pushdown(R x){
	if(r[x]){
		R t=lc;lc=rc;rc=t;
		r[lc]^=1;r[rc]^=1;r[x]=0;
	}
}
I pushall(R x){//懒得手写栈，直接用函数堆栈（逃
	if(nroot(x))pushall(f[x]);
	pushdown(x);
}
I rotate(R x){
	R y=f[x],z=f[y],k=c[y][1]==x,w=c[x][!k];
	if(nroot(y))c[z][c[z][1]==y]=x;c[x][!k]=y;c[y][k]=w;
	f[w]=y;f[y]=x;f[x]=z;
	pushup(y);
}
I splay(R x){
	R y=x;
	pushall(x);
	while(nroot(x)){
		if(nroot(y=f[x]))
			rotate((c[y][0]==x)^(c[f[y]][0]==y)?x:y);
		rotate(x);
	}
	pushup(x);
}
I access(R x){
	for(R y=0;x;x=f[y=x])
		splay(x),rc=y,pushup(x);
}
I mroot(R x){
	access(x);splay(x);
	r[x]^=1;
}
inline int froot(R x){
	access(x);splay(x);
	while(lc)x=lc;
	return x;
}
I link(R x){
	R y=e[x].u,z=e[x].v;
	mroot(z);
	f[f[z]=x]=y;
}//非正常link与cut
I cut(R x){
	access(e[x].v);splay(x);
	lc=rc=f[lc]=f[rc]=0;
	pushup(x);
}
int main(){
	R n,m,i,y,z,ans=999999;//ans给极大值
	in(n);in(m);
	for(i=1;i<=m;++i)e[i].read();
	sort(e+1,e+m+1);
	for(i=1;i<=m;++i)
	{
		if((y=e[i].u)==(z=e[i].v))continue;
		mroot(y);
		if(y!=froot(z))link(i);//不联通，直接连
		else if(e[i].b<e[mx[z]].b)cut(mx[z]),link(i);//联通，但有更小的边替换
		mroot(1|P);
		if((1|P)==froot(n|P))min2(ans,e[i].a+e[mx[n|P]].b);//1与n联通就更新答案
	}
	printf("%d\n",ans==999999?-1:ans);
	return 0;
}
```

---

## 作者：clamee (赞：14)

做的时候被那个 5e4 整晕了。

所以直接就用分块做这个题了。

题目要求从 $s$ 到 $t$ 找到一条路径 $S$，使得 $\max_{i\in S}a_i+\max_{i\in S}b_i$ 最小。

考虑枚举最小的 $a_i$，不难发现这个时候最小的 $b_i$ 随 $a_i$ 的增大单调不增，所以是可以双指针的。

考虑使用并查集来判断当前答案的合法性，既考虑将所有满足条件的边连完后 $s$ 和 $t$ 是否连通，不难想到用分块优化复杂度。

即每次将零散块部分暴力插入并查集再撤销。

复杂度为 $O(m\sqrt{n\log_2n})$。

实际上由于数据较水所以跑得很快。

```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define rg register
//#define int long long
il int read()
{
   int re=0,k=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')k=-1;ch=getchar();}
    while(ch<='9'&&ch>='0'){re=re*10+ch-48;ch=getchar();}
    return re*k;
}
il void write(int x)
{
    if(x<0)return putchar('-'),write(-x),void();
    if(x<10)return putchar(x+'0'),void();
    return write(x/10),putchar(x%10+'0'),void();
}
const int B=800;
int n,m,ans;
struct ss{
	int u,v,a,b;
	bool operator <(const ss ot)const{
		return a<ot.a;
	}
}e[10000005];
struct st{
	int u,v,b;
	bool operator <(const st ot)const{
		return b<ot.b;
	}
}now[10000005];
int fa[10000005],sz[10000005],s[10000005],ls,lnow,las;
bool vis[10000005];
void merge(int u,int v)
{
	if(u==v)return;
	if(sz[u]>sz[v])swap(u,v);
	fa[u]=v;
	sz[v]+=sz[u];
	s[++ls]=u;
}
int find(int x)
{
	if(x==fa[x])return x;
	return find(fa[x]);
}
void redo()
{
	sz[fa[s[ls]]]-=sz[s[ls]];
	fa[s[ls]]=s[ls];
	ls--;
}
bool pd(int x)
{
	redo();
	lnow--;
	int t=ls;
	for(rg int i=las;i<=x;i++)
	{
		if(e[i].b>now[lnow].b)continue;
		merge(find(e[i].u),find(e[i].v));
	}
	if(find(n)==find(1)){while(ls>t)redo();return 1;}
	while(ls>t)redo();
	lnow++;
	merge(find(now[lnow].u),find(now[lnow].v));
	return 0;
}
void init()
{
	for(rg int i=1;i<=n;i++)
		fa[i]=i,sz[i]=1;
}
void build()
{
	init();
	for(rg int i=1;i<=lnow;i++)
	{
		if(find(now[i].u)!=find(now[i].v))vis[i]=1;
		else vis[i]=0;
		merge(find(now[i].u),find(now[i].v));
	}
}
signed main()
{
	n=read();m=read();
	for(rg int i=1;i<=m;i++)
	{
		e[i].u=read();e[i].v=read();
		e[i].a=read();e[i].b=read();
	}
	sort(e+1,e+m+1);
	init();
	ans=0x3f3f3f3f;
	int st=1;
	init();
	while(find(1)!=find(n)&&st<=m)
	{
		now[++lnow].u=e[st].u;
		now[lnow].v=e[st].v;
		now[lnow].b=e[st].b;
		merge(find(e[st].u),find(e[st].v));
		st++;
	}
	sort(now+1,now+lnow+1);
	build();
	las=st;
	do
	{
		while(!vis[lnow]&&lnow)
			lnow--;
	}
	while(pd(st-1));
	if(find(1)==find(n))
	{
		ans=e[st-1].a+now[lnow].b;
	}
	for(rg int i=st;i<=m&&lnow>0;i++)
	{
		do
		{
			while(!vis[lnow]&&lnow)
				lnow--;
		}
		while(pd(i));
		if(lnow>0)
			ans=min(ans,e[i].a+now[lnow].b);
		if(i-las+1==B)
		{
			int t=lnow;
			for(rg int j=las;j<=i;j++)
			{
				if(e[j].b>now[t].b)continue;
				now[++lnow].u=e[j].u;
				now[lnow].v=e[j].v;
				now[lnow].b=e[j].b;
			}
			las=i+1;
			sort(now+1,now+lnow+1);
			build();
		}
	}
	if(ans==0x3f3f3f3f)
		ans=-1;
	write(ans);
}
```

---

## 作者：UnyieldingTrilobite (赞：11)

大概是一道三年前十二月做的题，当时 LCT 还没玩 6，但是在 UOJ 上找到了一份不使用 LCT 的代码，故学习之；2023 年 7 月，重新看到了这个题，感觉很好玩，于是决定把它记录下来。

首先这个约束是俩最大值加起来的最小值，我们肯定没法很方便地处理。但我们有一种相对简单的处理这种叠起来的最值：二分答案。那么我们二分答案后问题就被转化为 $a$ 与 $b$ 的最大值之和不到给定值 $x$，判定是否可行。

我们考虑记录每条边的 $c=x-b$ 代替 $b$，那么原来的 $a_{\max}+b_{\max}\le x$ 就可以变形为 $a_{\max}\le c_{\min}$。换而言之，我们实际上需要找到一条路径，使得路径上所有的 $[a,c]$ 存在非空的并集（很显然，如果这个东西对于一条边不构成闭区间，那么它一定是不合法的）。进一步，我们需要找到一条路径和一个数 $z$，使得对于每一条路径都满足 $a\le z\le c$。

那么我们考虑我们实际上已经不关心最后的路径是什么了，我们换一个视角去考虑，对于每条边，对于所有 $a\le z\le c$ 的 $z$ 令其两个端点连通，问是否存在一个 $z$ 使得起点与终点连通。而这是可以使用线段树分治+可撤销并查集轻松解决的。

由于并查集的结构（在这里）远远没有 LCT 灵活，所以需要这样绕很大一个圈子，生生是用三个 $\log$ 的复杂度冲过了 LCT 的单 $\log$ 题（虽然好像 $10^5$ 本来也不是冲不动）——但这又何尝不是一种门槛更低的思路呢？

最后挂个代码吧，三年前写的了，现在感觉有点丑，懒得改了。

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
const int N = 1e5 + 9;
int n, m;
struct __edge__ {
  int u, v;
  __edge__(int u = 0, int v = 0) : u(u), v(v) {}
};
struct edge : __edge__ {
  int nxt;
  edge(int u = 0, int v = 0, int nxt = 0) : __edge__(u, v), nxt(nxt) {}
} es[N * 20];
int hd[N << 2], tot, M;
struct Edge : __edge__ {
  int a, b;
  Edge(int u = 0, int v = 0, int a = 0, int b = 0)
      : __edge__(u, v), a(a), b(b) {}
} eg[N];
int p[N], rk[N];
bool ept[N << 2];
int findf(int x) { return p[x] == x ? x : findf(p[x]); }
void update(int pos, int u, int v) {
  es[++tot] = edge(u, v, hd[pos]);
  hd[pos] = tot;
}
void update(int l, int r, int u, int v) {
  if (l > r) return;
  for (l += M - 1, r += M + 1; l ^ r ^ 1; l >>= 1, r >>= 1) {
    if (~l & 1) update(l ^ 1, u, v);
    if (r & 1) update(r ^ 1, u, v);
  }
}
bool dfs(int pos, int epos) {
  if (findf(1) == findf(n)) return true;
  if (ept[pos]) return false;
  if (!epos) {
    if (pos >= M) return false;
    return dfs(pos << 1, hd[pos << 1]) || dfs(pos << 1 | 1, hd[pos << 1 | 1]);
  }
  int px = findf(es[epos].u), py = findf(es[epos].v);
  if (rk[px] > rk[py]) std::swap(px, py);
  p[px] = py;
  bool tag = false;
  if (rk[px] == rk[py]) ++rk[py], tag = true;
  if (dfs(pos, es[epos].nxt)) return true;
  if (tag) --rk[py];
  p[px] = px;
  return false;
}
bool ok(int mid) {
  for (M = 1; M <= mid; ++M)
    ;
  memset(hd, tot = 0, sizeof hd);
  for (int i = 1; i <= n; ++i) {
    p[i] = i;
    rk[i] = 0;
  }
  for (int i = 1; i <= m; ++i) {
    update(eg[i].a, mid - eg[i].b, eg[i].u, eg[i].v);
  }
  for (int i = M; i < (M << 1); ++i) ept[i] = !hd[i];
  for (int i = M - 1; i; --i) ept[i] = !hd[i] && ept[i << 1] && ept[i << 1 | 1];
  return dfs(1, hd[1]);
}
int main() {
  scanf("%d%d", &n, &m);
  for (int i = 1; i <= m; ++i) {
    scanf("%d%d%d%d", &eg[i].u, &eg[i].v, &eg[i].a, &eg[i].b);
  }
  int l = 1, r = 1e5, ans = -1;
  while (l <= r) {
    int mid = (l + r) >> 1;
    if (ok(mid)) {
      r = mid - 1;
      ans = mid;
    } else
      l = mid + 1;
  }
  printf("%d\n", ans);
  return 0;
}
```

---

## 作者：Refun (赞：8)

第一个lct做法第二个spfa做法 


------------

这个基本算是lct裸题

但也学到了一点套路

如果要维护边权的话就将边看做一个点然后连接相应的两个点

至于这个点的编号？和输入的编号对应起来就好了，方便我们查找这个点对应的边的信息

这个题只需要每次将a相同的边的b权值加入树中，当前的答案就是a[i]+min(1~n路径上的最大值)

若连边连出环了怎么办？先将点x和y中最长的边cut掉再加入就好了 


------------

smg啊……一开始的想法是二分a和b……

后来又口胡了一种算法只有15分…… 

最后发现我还是too young too simple

第一次听说到SPFA动态加边（点）这种操作orz

因为边权有两个，求起来是十分麻烦的

而正解好像是LCT，然而可能很多人并不会

所以那我们就把边a排序，然后将边按a从小到大加入，再按b为权值跑SPFA

每次加一条边的时候，将边两边的端点入队再SPFA。

而且因为边是按a从小到大加入的，所以后面dis情况会包含前面的情况，dis数组就不用每次memset每次重新求了 

[代码](http://www.cnblogs.com/refun/p/8682241.html)

---

## 作者：五更琉璃 (赞：5)

这一题其实不好想到用LCT来写，一开始一直在想是不是二分答案，但是怎么都检验不了。

收到高人指点，由于 1 到 n 的所有路径一定存在一条最优路径，所以我们可以用 LCT 动态维护这一条最优路径，将边按照 a 作为关键字排序，然后从小到大加边，这样 $max(a_i)$ 是单调递增的，然后用 LCT 维护路径上的 $max(b_i)$ 。对于一条边的两个点如果不连通就直接连上，不然就是看看替换掉当前这两个点的路径上最大的那一条会不会有更优的答案。

由于边不好处理，所以把边转成点，这样就可以一起放进 LCT 维护了。有一个细节：LCT 在传递信息的时候传递最大的 $b_i$ 所在边的编号，这样就可以直接查询路径上最大边是哪一条，不用再扫过去。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long lint;

const int MAXN = 200005;

inline int read() {
	int x = 0, f = 0; char c = getchar();
	for (; c < '0' || c > '9'; c = getchar()) if (c == '-') f = 1;
	for (; c >= '0' && c <= '9'; c = getchar()) x = (x << 3) + (x << 1) + (c ^ 48);
	return f ? -x : x;
}

int n, m, ans;
struct Edge {
	int u, v, a, b;
	bool operator < (const Edge& x) {
		return a < x.a;
	}
} e[MAXN];

int fath[MAXN];

int findf(int x) {
	return fath[x] == x ? x : fath[x] = findf(fath[x]);
}

int top;
int val[MAXN]; // 边权，以 sort 之后的 i + n 为准
int fa[MAXN];
int ch[MAXN][2];
int maxi[MAXN];
int tag[MAXN];

int sta[MAXN];

int id(int u) {
	return ch[fa[u]][1] == u;
}

int isroot(int u) {
	return ch[fa[u]][0] != u && ch[fa[u]][1] != u;
}

void update(int u) {
	maxi[u] = u;
	if (val[maxi[u]] < val[maxi[ch[u][0]]])
		maxi[u] = maxi[ch[u][0]];
	if (val[maxi[u]] < val[maxi[ch[u][1]]])
		maxi[u] = maxi[ch[u][1]];
}

void fall(int u) {
	if (!tag[u]) return ;
	swap(ch[u][0], ch[u][1]);
	tag[u] ^= 1;
	tag[ch[u][0]] ^= 1;
	tag[ch[u][1]] ^= 1;
}

void rotate(int u) {
	int v = fa[u], w = fa[v], s = id(u);
	if (!isroot(v))
		ch[w][id(v)] = u;
	fa[u] = w;
	ch[v][s] = ch[u][s ^ 1];
	fa[ch[u][s ^ 1]] = v;
	ch[u][s ^ 1] = v;
	fa[v] = u;
	update(v);
	update(u);
}

void splay(int u) {
	sta[top = 1] = u;
	for (int i = u; !isroot(i); i = fa[i])
		sta[++top] = fa[i];
	while (top) 
		fall(sta[top--]);
	for (int v; !isroot(u); rotate(u))
		if (!isroot(v = fa[u])) 
			rotate(id(u) ^ id(v) ? u : v);
}

void access(int u) {
	for (int t = 0; u; t = u, u = fa[u]) {
		splay(u);
		ch[u][1] = t;
		update(u);
	}
}

void evert(int u) {
	access(u);
	splay(u);
	tag[u] ^= 1;
}

int find(int u) {
	access(u);
	splay(u);
	while (ch[u][0])
		u = ch[u][0];
	splay(u);
	return u;
}

void link(int u, int v) {
	evert(u);
	fa[u] = v;
}

void cut(int u, int v) {
	evert(u);
	if (find(v) != u || fa[v] != u || ch[v][0])
		return ;
	ch[u][1] = fa[v] = 0;
	update(u);
}

int query(int u, int v) {
	evert(u);
	access(v);
	splay(v);
	return maxi[v];
}

void split(int u, int v) {
	evert(u); access(v); 
}


int main() {
	ans = 0x7fffffff;
	n = read(); m = read();
	for (int i = 1; i <= n + m; ++i) fath[i] = i;
	for (int i = 1; i <= m; ++i) {
		e[i].u = read(); e[i].v = read();
		e[i].a = read(); e[i].b = read();
	}
	sort(e + 1, e + 1 + m);
	for (int i = 1; i <= m; ++i) {
		int fu = findf(e[i].u);
		int fv = findf(e[i].v);
		if (fu == fv) {
			int t = query(e[i].u, e[i].v);
			if (val[t] > e[i].b) {
				cut(e[t - n].u, t);
				cut(t, e[t - n].v);
			}
			else 
				continue;
		}
		fath[fv] = fu;
		val[i + n] = e[i].b;
		maxi[i + n] = i + n;
		link(e[i].u, i + n);
		link(i + n, e[i].v);
		if (findf(1) == findf(n)) {
			ans = min(ans, val[query(1, n)] + e[i].a);
		}
	}
	if (findf(1) != findf(n)) puts("-1");
	else printf("%d\n", ans);
	return 0;
}
```

---

## 作者：大菜鸡fks (赞：4)


维护动态最小生成树，维护边的最大权的编号。用环切性质，断掉环上最大权的边，加入当前边。


pascal代码如下：


```cpp
type pp=record
     u,v,v1,v2:longint;
end;
type pp1=record
     son:array[0..1]of longint;
     fa,rev:longint;
end;
var ans,t,p1,p2,u,v,v1,v2,i,n,m:longint;
    stack,mx,p,val:array[0..200005]of longint;
    e:array[0..200005]of pp;
    a:array[0..200005]of pp1;
procedure swap1(var x,y:pp);
var z:pp;
begin
  z:=x; x:=y; y:=z;
end;
procedure swap(var x,y:longint);
var z:longint;
begin
  z:=x; x:=y; y:=z;
end;
function min(x,y:longint):longint;
begin
  if x>y then exit(y) else exit(x);
end;
function find(x:longint):longint;
begin
  if p[x]=x then exit(x) else p[x]:=find(p[x]);
  exit(p[x]);
end;
procedure sort(l,r:longint);
var i,j,x:longint;
begin
  i:=l;
  j:=r;
  x:=e[(l+r) div 2].v1;
  while i<=j do
     begin
     while e[i].v1<x do inc(i);
     while x<e[j].v1 do dec(j);
     if i<=j then
          begin
       swap1(e[i],e[j]);
        inc(i); dec(j);
        end;
     end;
  if l<j then sort(l,j);
  if i<r then sort(i,r);
end;
function isroot(x:longint):boolean;
begin
  if (a[a[x].fa].son[0]<>x)and(a[a[x].fa].son[1]<>x) then exit(true) else exit(false);
end;
procedure pushup(x:longint);
begin
  mx[x]:=x;
  if val[mx[a[x].son[0]]]>val[mx[x]] then mx[x]:=mx[a[x].son[0]];
  if val[mx[a[x].son[1]]]>val[mx[x]] then mx[x]:=mx[a[x].son[1]];
end;
procedure pushdown(x:longint);
begin
  if a[x].rev=0 then exit;
  a[x].rev:=0;
  swap(a[x].son[1],a[x].son[0]);
  a[a[x].son[0]].rev:=a[a[x].son[0]].rev xor 1; a[a[x].son[1]].rev:=a[a[x].son[1]].rev xor 1;
end;
procedure sett(x,y,f:longint);
begin
  a[y].fa:=x; a[x].son[f]:=y;
end;
procedure rotate(x,w:longint);
var y:longint;
begin
  y:=a[x].fa; a[x].fa:=a[y].fa;
  if not isroot(y) then
     if y=a[a[y].fa].son[0] then a[a[y].fa].son[0]:=x else a[a[y].fa].son[1]:=x;
  a[y].son[w xor 1]:=a[x].son[w];
  if a[x].son[w]<>0 then a[a[x].son[w]].fa:=y;
  sett(x,y,w); pushup(y);
end;
procedure splay(x:longint);
var i,now,top,y:longint;
begin
  top:=1; now:=x; stack[top]:=x;
  while not isroot(now) do begin now:=a[now].fa; inc(top); stack[top]:=now; end;
  for i:=top downto 1 do pushdown(stack[i]);
  while not isroot(x) do
     begin
     y:=a[x].fa;
     if isroot(y)
        then if x=a[y].son[0] then rotate(x,1) else rotate(x,0)
        else
    if y=a[a[y].fa].son[0]
       then if x=a[y].son[0] then begin rotate(y,1); rotate(x,1); end else begin rotate(x,0); rotate(x,1); end
       else if x=a[y].son[0] then begin rotate(x,1); rotate(x,0); end else begin rotate(y,0); rotate(x,0); end;
     end;
  pushup(x);
end;
procedure access(x:longint);
var pre:longint;
begin
  pre:=0;
  while x<>0 do
    begin
    splay(x);
    a[x].son[1]:=pre; pre:=x; x:=a[x].fa;
    end;
end;
procedure makeroot(x:longint);
begin
  access(x); splay(x); a[x].rev:=a[x].rev xor 1;
end;
procedure link(x,y:longint);
begin
  makeroot(x); a[x].fa:=y;
end;
procedure cut(x,y:longint);
begin
  makeroot(x); access(y); splay(y);
  a[y].son[0]:=0; a[x].fa:=0; pushup(y);
end;
function query(x,y:longint):longint;
begin
  makeroot(x); access(y); splay(y);
  exit(mx[y]);
end;
begin
  readln(n,m);
  for i:=1 to n do p[i]:=i;
  for i:=1 to m do readln(e[i].u,e[i].v,e[i].v1,e[i].v2);
  sort(1,m);
  ans:=maxlongint;
  for i:=1 to m do
    begin
    u:=e[i].u; v:=e[i].v; p1:=find(u); p2:=find(v);
    if p1=p2 then
      begin
      t:=query(u,v);
      if val[t]>e[i].v2 then begin cut(t,e[t-n].u); cut(t,e[t-n].v); end
          else begin if find(1)=find(n) then ans:=min(ans,e[i].v1+val[query(1,n)]); continue; end;
      end
      else p[p1]:=p2;
    val[n+i]:=e[i].v2; mx[n+i]:=n+i;
    link(u,n+i); link(v,n+i);
    if find(1)=find(n) then ans:=min(ans,e[i].v1+val[query(1,n)]);
    end;
  if ans=maxlongint then writeln(-1) else writeln(ans);
end.
```
c++代码如下：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
const int maxm=1e5+5,maxn=5e4+5;
int n,m,stack[maxn+maxm];
struct pp{
    int x,y,a,b;
}e[maxm];
struct pp1{
    int rev,val,fa,son[2],mx;
}a[maxn+maxm];
void sett(int f,int x,int flag){a[f].son[flag]=x; a[x].fa=f;}
bool isroot(int x){return (a[a[x].fa].son[0]!=x&&a[a[x].fa].son[1]!=x);}
void pushup(int x)
{
    a[x].mx=x;
    if (a[a[x].mx].val<a[a[a[x].son[0]].mx].val) a[x].mx=a[a[x].son[0]].mx;
    if (a[a[x].mx].val<a[a[a[x].son[1]].mx].val) a[x].mx=a[a[x].son[1]].mx;    
}
void rotate(int x,int w)
{
    int y=a[x].fa; a[x].fa=a[y].fa; a[y].son[w^1]=a[x].son[w];
    if (!isroot(y))
        if (y==a[a[y].fa].son[0]) a[a[y].fa].son[0]=x; else a[a[y].fa].son[1]=x;
    if (a[x].son[w]) a[a[x].son[w]].fa=y;
    sett(x,y,w); pushup(y); 
}
void pushdown(int x){if (a[x].rev) a[x].rev=0,swap(a[x].son[0],a[x].son[1]),a[a[x].son[0]].rev^=1,a[a[x].son[1]].rev^=1;}
void splay(int x)
{
    int top=1; stack[top]=x; int now=x;
    while (!isroot(now)) now=a[now].fa,stack[++top]=now;
    for (int i=top;i;i--) pushdown(stack[i]);
    while (!isroot(x)){
        int y=a[x].fa;
        if (isroot(y))
            if (x==a[y].son[0]) rotate(x,1); else rotate(x,0);
            else if (y==a[a[y].fa].son[0]) 
                if (x==a[y].son[0]) rotate(y,1),rotate(x,1); else rotate(x,0),rotate(x,1);
                else if (x==a[y].son[0]) rotate(x,1),rotate(x,0); else rotate(y,0),rotate(x,0);
    }
    pushup(x);
}
void access(int x){int pre=0; for (;x;a[x].son[1]=pre,pre=x,x=a[x].fa) splay(x);}
void makeroot(int x){access(x); splay(x); a[x].rev^=1;}
void link(int x,int y){makeroot(x); a[x].fa=y;}
void split(int x,int y){makeroot(x); access(y); splay(y);}
void cut(int x,int y){split(x,y); a[x].fa=a[y].son[0]=0;}
int find(int x)
{
    access(x); splay(x);
    while (a[x].son[0]) x=a[x].son[0];
    return x;
}
bool judge(int x,int y){return find(x)==find(y);}
int query(int x,int y){split(x,y); return a[y].mx;}
bool cmp(pp x,pp y){return x.a<y.a||(x.a==y.a&&x.b<y.b);}
int main()
{
    scanf("%d%d",&n,&m); int ans=0x3f3f3f3f;
    for (int i=1;i<=m;i++) scanf("%d%d%d%d",&e[i].x,&e[i].y,&e[i].a,&e[i].b);
    sort(e+1,e+m+1,cmp);
    for (int i=1;i<=m;i++) a[i+n].val=e[i].b;
    for (int i=1;i<=m;i++){
        if (!judge(e[i].x,e[i].y))link(e[i].x,i+n),link(e[i].y,i+n);
            else {
                int t=query(e[i].x,e[i].y);
                if (a[t].val>e[i].b){cut(e[t-n].x,t); cut(e[t-n].y,t); link(e[i].x,n+i); link(e[i].y,n+i);}
            }
        if (judge(1,n)) ans=min(ans,e[i].a+a[query(1,n)].val);
    }
    ans!=0x3f3f3f3f?printf("%d\n",ans):puts("-1");
}
```

---

## 作者：我没有名称 (赞：4)

来一种比较扯的算法 三分+SPFA

有一种暴力的算法 就是枚举a然后求出b的最小值 然后a+b的最小值就是答案
复杂度为O(A)* O(SPFA) 可以得到大约50分

我们发现在a增大时b在减小 于是我们考虑用三分法做这道题 至于正确性  ~~反正猜错了不扣分 我也不知道为什么能过~~ 于是复杂度就变成O(logA)* O(SPFA) 然后就可以过了 代码很短还很好写

``` cpp
#include<iostream>
#include<cstring>
#include<vector>
#include<queue>
using namespace std;
struct bian
{
    int ed,a,b;
}; 
vector<bian> tu[50010];
int n,m,f[50010],p[50010];
deque<int> q;
void check(int x) //SPFA
{
     int t1,t2,t3,t4,t5=0,i;
     memset(f,1,sizeof(f));
     memset(p,0,sizeof(p));
     f[1]=0;
     p[1]=1;
     q.push_front(1);
     do
     {
     t1=q.front();
     p[t1]=0;
     q.pop_front();
     for(i=0;i<tu[t1].size();i++)
     {
         t2=tu[t1][i].ed;
         t3=tu[t1][i].a;
         t4=tu[t1][i].b;
         if(t3<=x&&max(f[t1],t4)<f[t2]) 
         {
             f[t2]=max(f[t1],t4);
             if(p[t2]==0)
             {
                 if(t5==0) q.push_back(t2); else q.push_front(t2);
                 t5=1-t5;//直接插队头会超时 一个插队头一个插队尾就过了
                 p[t2]=1;
             }
         }
     }
     }
     while(!q.empty());
}             
int main()
{
    int i,t1,t2;
    bian t0;
    cin>>n>>m;
    for(i=1;i<=m;i++)
    {
        cin>>t1>>t2>>t0.a>>t0.b;
        t0.ed=t2;
        tu[t1].push_back(t0);
        t0.ed=t1;
        tu[t2].push_back(t0);
    }
    int l=0,r=50000,m0,ans=9999999,a1,a2;
    while(l<r-4)//三分
    {
        t1=l*2/3+r/3;
        t2=l/3+r*2/3;
        check(t1);
        a1=f[n]+t1;
        if(f[n]+t1<ans) ans=f[n]+t1;
        check(t2);
        a2=f[n]+t2;
        if(f[n]+t2<ans) ans=f[n]+t2;//感觉不稳 能记一次答案就记一次
        if(a1<=100000&&a2<=100000)//如果走不到 说明a猜小了
         if(a1>a2) l=t1;
         else r=t2;
        else 
         l=t1;
    }
    if(ans<=100000) cout<<ans; else cout<<-1;
    return 0;
}
```


---

## 作者：AFO_WR_Eternity (赞：3)

# 题目大意：
一个有$n$个点，$m$条边的无向图，每条边都另有两个权值$a_i$和$b_i$，一开始有两个指数，$A$，$B$，如果你的$A>=a_i,B>=b_i$那么你就可以通过这条边，求$A+B$的最小值。
# 大体思路：
$LCT$裸题。

注意到有两个指数，那我们肯定要先通过各种方法搞掉一个指数，再去维护另一个指数，比如用$CDQ$分治，当然这题只要用个$sort$，再维护一棵最小生成树，即可。

把边按$a_i$排序，然后一条一条地加入$LCT$，如果目前这条边的两端以在同一连通块中，那么加入这条边之后肯定就会变成一个环，那么如果原连通块中$b_i$最大的一条边比该边的$b_i$小，那么就把最大的那条边删了，让该边加入即可。

一个边权转点权的无脑方法：

- 两点之间在加入另一个点，只有中间新加入的这个点有点权，点权就是这条边的权值。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=200005,inf=1e6+7;
int w[N],val[N],fa[N],rev[N],ch[N][2],Max[N],p[N];
int n,m,opt,x,y,ans,t;
struct edge{
	int u,v,a,b;
} e[N];
bool cmp(edge a,edge b){return a.a<b.a;}
int find(int x){return p[x]==x?x:p[x]=find(p[x]);}
int wh(int x){return ch[fa[x]][1]==x;}
bool isrt(int x){return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x;}
void rever(int x){rev[x]^=1,swap(ch[x][0],ch[x][1]);}
void update(int x){
	Max[x]=x;
	if (ch[x][0]&&val[Max[ch[x][0]]]>val[Max[x]]) Max[x]=Max[ch[x][0]];
	if (ch[x][1]&&val[Max[ch[x][1]]]>val[Max[x]]) Max[x]=Max[ch[x][1]];
}
void pushdown(int x){
	if (rev[x]){
		if (ch[x][0]) rever(ch[x][0]);
		if (ch[x][1]) rever(ch[x][1]);
		rev[x]=0;
	}
}
void Allpushdown(int x){
	if (!isrt(x)) Allpushdown(fa[x]);
	pushdown(x);
}
void rotate(int x){
	int y=fa[x],z=fa[y],c=wh(x);
	if (!isrt(y)) ch[z][wh(y)]=x;
	fa[x]=z;
	ch[y][c]=ch[x][c^1];
	fa[ch[y][c]]=y;
	ch[x][c^1]=y;
	fa[y]=x;
	update(y),update(x);
}
void splay(int x){
	Allpushdown(x);
	for (;!isrt(x);rotate(x))
		if (!isrt(fa[x])) rotate(wh(fa[x])==wh(x)?fa[x]:x);
}
void access(int x){
	for (int y=0;x;y=x,x=fa[x]) splay(x),ch[x][1]=y,update(x);
}
void makert(int x){
	access(x),splay(x),rever(x);
}
void link(int x,int y){
	makert(x),fa[x]=y;
}
void cut(int x,int y){
	makert(x),access(y),splay(y);
	fa[x]=ch[y][0]=0,update(y);
}
int query(int x,int y){
	makert(x),access(y),splay(y);
	return Max[y];
}
int main(){
	scanf("%d%d",&n,&m);
	for (int i=1;i<=m;i++) scanf("%d%d%d%d",&e[i].u,&e[i].v,&e[i].a,&e[i].b);
	sort(e+1,e+1+m,cmp);
	for (int i=1;i<=n;i++) p[i]=i; 
	ans=inf;
	for (int i=1;i<=m;i++){
		int u=e[i].u,v=e[i].v;
		if (find(u)==find(v)){
			t=query(u,v);
			if (e[i].b<val[t]){
				cut(t,e[t-n].u);
				cut(t,e[t-n].v);
			}
			else{
				if (find(1)==find(n)) ans=min(ans,e[i].a+val[query(1,n)]);
				continue;
			}
		} else p[find(u)]=find(v);
		val[i+n]=e[i].b,Max[i+n]=i+n;
		link(u,i+n),link(i+n,v);
		if (find(1)==find(n)) ans=min(ans,e[i].a+val[query(1,n)]);
	}
	if (ans==inf) puts("-1"); else printf("%d\n",ans);
	return 0;
}
```


---

## 作者：crashed (赞：2)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P2387)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看见$a$很小，我们考虑枚举不同的$a$，计算每种情况的最小值再求出答案。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑将边按照$a$从小到大排序，之后每次将$a$相同的边加入到图上来。这样可以保证当前加入的$a$总是最大的，也就相当于确定了$A$种小精灵应该带多少只。于是我们只需要考虑$B$种小精灵最少需要带多少只。不难发现，此时$B$种小精灵的需求就是原图的最小生成树上，$1-n$的路径上的$b$的最大值。可以在最小生成树上使用反证法证明这一点。    
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，我们需要动态维护一个图的最小生成树，这恰巧就是$LCT$可以完成的。所以我们用$LCT$维护就可以了，时间是$O(m\log_2^2n)$。  
# 代码
```cpp
#include <cstdio>

const int INF = 0x3f3f3f3f;
const int MAXN = 2e5 + 5, MAXM = 2e5 + 5, MAXSIZ = MAXN + MAXM, MAXLOG = 20;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
void swapp( _T &x, _T &y )
{
	_T t = x; x = y, y = t;
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

struct segmentTreeNode
{
	int cnt, lch, rch;
	#define cnt( x ) ( segTree[x].cnt )
	#define lch( x ) ( segTree[x].lch )
	#define rch( x ) ( segTree[x].rch )
}segTree[MAXM * MAXLOG];

struct edge
{
	int u, v;
}E[MAXM];

int f[MAXN], del[MAXM], rt[MAXM];
int ch[MAXSIZ][2], fa[MAXSIZ], val[MAXSIZ], mn[MAXSIZ];
int N, M, siz;
bool rev[MAXSIZ];

bool chk( const int x ) { return ch[fa[x]][1] == x; }
bool isRt( const int x ) { return ch[fa[x]][0] ^ x && ch[fa[x]][1] ^ x; }
bool nrt( const int x ) { return ! isRt( x ); }
void reverse( const int x ) { if( x ) swapp( ch[x][0], ch[x][1] ), rev[x] ^= 1; }
void normalize( const int x ) { if( x && rev[x] ) reverse( ch[x][0] ), reverse( ch[x][1] ), rev[x] = false; }
void tagClean( const int x ) { if( nrt( x ) ) tagClean( fa[x] ); normalize( x ); }
void upt( const int x ) { mn[x] = MIN( val[x], MIN( mn[ch[x][0]], mn[ch[x][1]] ) ); }

void rotate( const int x )
{
	if( ! x || isRt( x ) ) return ;
	int y = fa[x], z = fa[y], side = chk( x ), son = ch[x][! side];
	if( z && nrt( y ) ) ch[z][chk( y )] = x; ch[x][! side] = y, ch[y][side] = son;
	if( son ) fa[son] = y; fa[y] = x, fa[x] = z;
	upt( y ), upt( x ), upt( z );
}

void splay( const int x )
{
	tagClean( x );
	for( int y ; nrt( x ) ; rotate( x ) )
		if( nrt( y = fa[x] ) ) rotate( chk( y ) == chk( x ) ? y : x );
}

void access( int x ) { for( int y = 0 ; x ; x = fa[y = x] ) splay( x ), ch[x][1] = y, upt( x ); }
void makeRt( const int x ) { access( x ), splay( x ), reverse( x ); }
int findRt( int x ) { access( x ), splay( x ); while( ch[x][0] ) normalize( x ), x = ch[x][0]; splay( x ); return x; }
bool link( const int x, const int y ) { makeRt( x ); if( findRt( y ) == x ) return false; fa[x] = y; return true; }
void cut( const int x, const int y ) { makeRt( x ), access( y ), splay( x ); fa[y] = ch[x][1] = 0, upt( x ); }
int split( const int x, const int y ) { makeRt( x ), access( y ), splay( y ); return y; }

int findSet( const int u ) { return f[u] = ( f[u] == u ? f[u] : findSet( f[u] ) ); }

bool unionSet( const int u, const int v )
{
	int r1 = findSet( u ), r2 = findSet( v );
	f[r1] = r2; return r1 ^ r2;
}

int change( const int id )
{
	int u = E[id].u, v = E[id].v, ID;
	if( u == v ) return M;
	if( unionSet( u, v ) ) { link( u, id + N ), link( v, id + N ); return 0; }
	ID = mn[split( u, v )];
	cut( E[ID].u, ID + N ), cut( E[ID].v, ID + N );
	link( u, id + N ), link( v, id + N );
	return ID;
}

void _upt( const int x ) { cnt( x ) = cnt( lch( x ) ) + cnt( rch( x ) ); }

int update( const int u, const int l, const int r, const int pos )
{
	int cur = ++ siz, mid = l + r >> 1; segTree[cur] = segTree[u];
	#ifdef _DEBUG
	segmentTreeNode &node1 = segTree[u], &node2 = segTree[cur];
	#endif
	if( pos <= l && r <= pos ) { cnt( cur ) ++; return cur; }
	if( pos <= mid ) lch( cur ) = update( lch( u ), l, mid, pos );
	else rch( cur ) = update( rch( u ), mid + 1, r, pos );
	_upt( cur ); 
	return cur; 
}
 
int query( const int lr, const int rr, const int l, const int r, const int segL, const int segR )
{
	#ifdef _DEBUG
	segmentTreeNode &nodel = segTree[lr], &noder = segTree[rr];
	#endif
	if( segL <= l && r <= segR ) return cnt( rr ) - cnt( lr );
	int mid = l + r >> 1, ret = 0;
	if( segL <= mid ) ret += query( lch( lr ), lch( rr ), l, mid, segL, segR );
	if( segR > mid ) ret += query( rch( lr ), rch( rr ), mid + 1, r, segL, segR );
	return ret;
}

int main()
{
	int K, type, L, R, las = 0, tmp;
	read( N ), read( M ), read( K ), read( type );
	for( int i = 0 ; i <= N ; i ++ ) val[i] = mn[i] = M + 1, f[i] = i;
	for( int i = 1 ; i <= M ; i ++ ) read( E[i].u ), read( E[i].v ), val[i + N] = mn[i + N] = i; 
	for( int i = 1 ; i <= M ; i ++ ) del[i] = change( i );
	for( int i = 1 ; i <= M ; i ++ ) 
		rt[i] = update( rt[i - 1], 0, M, del[i] );
	while( K -- )
	{
		read( L ), read( R );
		L ^= las, R ^= las;
		tmp = query( rt[L - 1], rt[R], 0, M, 0, L - 1 );
		write( las = ( N - query( rt[L - 1], rt[R], 0, M, 0, L - 1 ) ) ), putchar( '\n' );
		las *= type;
	}
	return 0;
}
```

---

## 作者：Beau_Kang (赞：2)

本思路仅供参考,数据强一点应该该会被卡。

本蒟蒻没有打 $link$ - $cut$ - $tree$ .
而是用暴力水了过去。

具体思路很简单，先二分最少的 $a_i$ , 再在 $judge$ 的时候再二分 $b_i$.
然后使用并查集来判断是否联通，复杂度 $n(logn)^3$

但是第一遍只有 $75$ 分 , 于是我写了两遍二分套二分,即先是以 $a_i$ 为第一个二分的，然后再以 $b_i$ 为第一个二分的，最后两者取较小的答案。

然后... 就 $AC$ 了。 

~~暴力真的是个美妙的东西。~~

**Code :**

```cpp
#include<bits/stdc++.h>
#define in(x) x=read()
#define N 50008
#define M 100008

using namespace std;
struct sj{int y,x,a,b;}a[M*2];
int n,m,ans_A=M*2,ans_B=M*2,fa[N];
int Ans_A=M*2,Ans_B=M*2,Fa[N];

int read()
{
	char ch=getchar(); int f=1,w=0;
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){w=w*10+ch-'0';ch=getchar();}
	return f*w;
}

int find(int x){
	if(x==fa[x])return x;
	return fa[x]=find(fa[x]);
}

void join(int x,int y){
	x=find(x); y=find(y);
	if(x!=y)fa[x]=y;
}

bool jud(int A,int B)
{
	for(int i=1;i<=n;i++) fa[i]=i;
	for(int i=1;i<=m;i++)
	if(a[i].a<=A&&a[i].b<=B)
	join(a[i].x,a[i].y);
	if(find(1)==find(n))return 1;
	return 0;
}

bool solve(int A)
{
	int L=0,R=N*2,ans=-1;
	while(L<=R)
	{
		int B=L+R>>1;
		if(jud(A,B))
			ans=B,R=B-1;
		else L=B+1;
	}
	if(ans==-1)return 0;
	if(ans_A+ans_B>A+ans)
	ans_A=A,ans_B=ans;
	return 1;
}

bool Jud(int A,int B)
{
	for(int i=1;i<=n;i++) fa[i]=i;
	for(int i=1;i<=m;i++)
	if(a[i].b<=A&&a[i].a<=B)
	join(a[i].x,a[i].y);
	if(find(1)==find(n))return 1;
	return 0;
}

bool Solve(int A)
{
	int L=0,R=N*2,ans=-1;
	while(L<=R)
	{
		int B=L+R>>1;
		if(Jud(A,B))
			ans=B,R=B-1;
		else L=B+1;
	}
	if(ans==-1)return 0;
	if(Ans_A+Ans_B>A+ans)
	Ans_A=A,Ans_B=ans;
	return 1;
}


int main()
{
	//freopen("disanti.in","r",stdin);
	//freopen("disanti.out","w",stdout);
	in(n); in(m);
	for(int i=1;i<=m;i++)
		in(a[i].x),in(a[i].y),
		in(a[i].a),in(a[i].b);
	int l=0,r=N*2;
	while(l<=r)
	{
		int mid=l+r>>1;
		if(solve(mid))r=mid-1;
		else l=mid+1;	
	}
	
	l=0,r=N*2;
	while(l<=r)
	{
		int mid=l+r>>1;
		if(Solve(mid))r=mid-1;
		else l=mid+1;	
	}
	
	if(ans_A==M*2&&ans_B==M*2)puts("-1");
	else cout<<min(Ans_A+Ans_B,ans_A+ans_B)<<endl;
	return 0;
}

```

---

## 作者：Regimes (赞：1)

我好菜啊！！！又被机房所有人包菜，感觉自己颓废了。。。。

首先题目大意大概为一幅图上有多条边，每条边有两个边权，每次走

的路径为你走的路径分别的两个权值的max求和，使这个max最小，

首先，说说我最开始的思路吧，因为有两个权值，我们不可以直接用

LCT在pushup中取max,于是我们考虑固定一个数，来进行维护。

那么是否可以用二分呢？二分边权a，每次走小于边权a的边，然
后LCT跑最小生成树（或者克鲁斯卡尔？） 似乎复杂度 n*log^2nn∗log 
2
 n

的，再加上 LCTLCT 的大常数，臣妾做不到啊。。

那么我可以尝试先按权值a进行排序（从小到大），那么我们每一
次就只需要维护链上b的最大值，当出现环时，割去b的边权最大的

边。（为什么应该割它，因为其中的a权是递增的，a到后面只会更

大，割bmax会使b减小，可以使它们的最大值尽量小）当1和n连接时，

看能否更新答案。

蒟蒻代码在下，又被巨佬包菜了
```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
#define ls ch[x][0]
#define rs ch[x][1]
#define inf 0x7fffffff
#define N 700007
int fa[N] , ch[N][3] , turn[N] , val[3*N] , M[2*N] ;
int n , m ;
struct node{
    int u , v , x , y ;
}e[2*N] ;
inline int read()
{
    int x = 0, f = 1; char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
int Get(int x)
{
    return ch[fa[x]][1] == x ;
}
int nroot(int x)
{
    return ch[fa[x]][1] == x || ch[fa[x]][0] == x ;
}
void pushr(int x)
{
    swap(ls , rs) ;
    turn[x] ^= 1 ;
}
void pushdown(int x)
{
    if( turn[x] )
    {
        if(ls) pushr(ls) ;
        if(rs) pushr(rs) ;
        turn[x] = 0 ;
    }
    return ;
}
void pushall(int x)
{
    if( fa[x] ) pushall(fa[x]) ;
    pushdown(x) ;
}
void pushup(int x)
{
    M[x] = x ;
    if( ls && val[M[x]] < val[M[ls]] ) M[x] = M[ls] ;
    if( rs && val[M[x]] < val[M[rs]] ) M[x] = M[rs] ;
    return ;
}
void rotate(int x)
{
    int y = fa[x] , z = fa[y] , w = Get(x) ;
    if( nroot(y) ) ch[z][ch[z][1] == y] = x ;
    ch[y][w] = ch[x][w^1] ; ch[x][w^1] = y ;
    if( ch[y][w] ) fa[ch[y][w]] = y ;
    fa[x] = z ; fa[y] = x ; pushup(y) ;
    return ;
}
void splay(int x)
{
    pushall(x) ;
    while( nroot(x) ){
        int y = fa[x] ;
        if( nroot(y) ){
            if( Get(y) == Get(x) ) rotate(y) ;
            else rotate(x) ;
        }
        rotate(x) ;
    } pushup(x) ;
}
void access(int x){
    for(int y = 0 ; x ; x = fa[y=x] ){
        splay(x) ; ch[x][1] = y ; pushup(x) ;
    }
}
bool cmp(node a , node b){
    return a.x < b.x ;
}
void makeroot(int x)
{
    access(x) ; splay(x) ; 
    pushr(x) ; return ;
}
int findroot(int x)
{
    access(x) ; splay(x) ;
    while( ls ) pushdown(x) , x = ls ;
    splay(x) ; return x ;
}
void split(int x , int y){
    makeroot(x) ; access(y) ;
    splay(y) ; return ;
}
void link(int x , int y){
    makeroot(x) ;
    if( findroot(y) != x ) fa[x] = y ;
    return ;
}
void cut(int x , int y)
{
    makeroot(x) ;
    if( findroot(y) == x && fa[y] == x && !ch[y][0] ) fa[y] = ch[x][1] = 0 , pushup(x) ;
    return ;
}
int insame(int x , int y){
    makeroot(x) ;
    if( findroot(y) == x ) return 1 ;
    else return 0 ;
}
int main()
{
    n = read() ; m = read() ;
    for(int i = 1 ; i <= n ; i++ ) val[i] = 0 ;
    for(int i = 1 ; i <= m ; i++ ){
        e[i].u = read() ; e[i].v = read() ;
        e[i].x = read() ; e[i].y = read() ;
    }
    int ans = inf ;
    sort( e + 1 , e + m + 1 , cmp ) ;
    for(int i = 1 ; i <= m ; i++ ){
       // cout<<"in it "<<i<<endl;
        if( e[i].u == e[i].v ) continue ;
        val[ i + n ] = e[i].y ;
        if( !insame( e[i].u , e[i].v ) ){
            link( e[i].u , i + n ) ;
            link( e[i].v , i + n ) ;
        }
        else{
            split( e[i].u , e[i].v ) ;
            int t = M[e[i].v] ;
            if( val[t] <= e[i].y ) continue ;
            cut( t , e[t - n].u ) ;
            cut( t , e[t - n].v ) ;
            link( i + n , e[i].u ) ;
            link( i + n , e[i].v ) ;
        }
        if( insame( 1 , n ) ){
             split( 1 , n ) ;
             ans = min( ans , e[i].x + val[M[n]] ) ;
        }
    }
    if( ans == inf ) printf("-1\n") ;
    else printf("%d" ,ans ) ;
    return 0 ;
}
```


---

## 作者：GoldenPotato137 (赞：1)


蒟蒻博客：[QAQ](https://www.cnblogs.com/GoldenPotato/p/10249306.html)

## Solution


------------

这题的思想挺好的。

 
.

对于这种最大值最小类的问题，很自然的可以想到二分答案。很不幸的是，这题是双关键字排序的，我们怎么二分呢？

先二分a再二分b？怎么看都布星啊。

那a+b作为关键字二分？也布星啊。

.
 

那咋搞啊？

不如，我们换个想法，**我们把其中一个关键字枚举，再看在这个关键字的限制下，另外一个尽可能小**。

仔细想想，应该是能覆盖到所有的情况的。

所以说，我们可考虑这样做：**我们先枚举a的大小（即所选的边的a必须小于这个值），在满足前者的条件下，使得从出发先到终点的路上的最大的b尽可能小。**

对于第二个问题，是不是很眼熟？没错，这个问题就是著名的原题货车运输：**我们要使得路径上经过的b值的最大值最小，这条路径一定是在以b为关键字的最小生成树上的**（具体证明请移步货车运输那道题的题解）。

 .

所以说，我们现在研究的问题就变为了如何快速的维护一个变化的最小生成树。

**快速维护变化的树，我们可以很自然地想到使用LCT来维护。**

再结合我们之前维护动态最小生存树的知识：**每加入一条边，它必定会连接两个点而形成一个环，我们要判断这条边是否会在新的生成树上，只需要看一下环上的最大的边权和这条边的关系就好了，**如果这条边的边权比环上的最大值还要小，我们就可以把环上的那条最大的边断开，接上我们这条新的边。否则的话，这条边一定不会成为新的最小生成树的一部分。

所以说，我们的LCT只需要在每新加入一条边时，检查其连接的两端是否是联通的。如果不联通的话，加入这条边一定是没有问题的。如果联通的话，就把所连两端的链split出来，找到最大值，比较一下大小关系就好。

至于如何用LCT维护边，我的方法是**用点来代替边，即一条边以一个有连向它的两个端点的边的点来替代**。具体写法可以参照一下代码。

 
.

时间复杂度为$O(n*logn*logn)$


------------
## Code
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int M=100000+100;
const int N=50000+100;
const int T=N+M;
struct road
{
    int s,t,a,b;
}e[M];
int n,m;
bool cmp(road x,road y)
{
    return x.a<y.a;
}
struct LCT
{
    int son[T][2],fa[T],lazy[T],MAX[T],num[T],mstack[T],top;
    inline void Update(int x)
    {
        MAX[x]=0;
        if(num[MAX[son[x][0]]]>=num[x] and num[MAX[son[x][0]]]>=num[MAX[son[x][1]]])
            MAX[x]=MAX[son[x][0]];
        if(num[MAX[son[x][1]]]>=num[x] and num[MAX[son[x][1]]]>=num[MAX[son[x][0]]])
            MAX[x]=MAX[son[x][1]];
        if(num[x]>=num[MAX[son[x][0]]] and num[x]>=num[MAX[son[x][1]]])
            MAX[x]=x;
    }
    inline void Mirror(int x)
    {
        lazy[x]=!lazy[x],swap(son[x][0],son[x][1]);
    }
    inline void PushDown(int x)
    {
        if(lazy[x]==0) return;
        lazy[x]=0;
        Mirror(son[x][0]),Mirror(son[x][1]);
    }
    inline bool IsRoot(int x)
    {
        return x!=son[fa[x]][0] and x!=son[fa[x]][1];
    }
    inline void Rotate(int x,int type)
    {
        int y=fa[x],z=fa[y];
        if(IsRoot(y)==false)    son[z][y==son[z][1]]=x;
        fa[x]=z;
        son[y][!type]=son[x][type],fa[son[x][type]]=y;
        son[x][type]=y,fa[y]=x;
        Update(y),Update(x);
    }
    inline void Splay(int x)
    {
        mstack[top=1]=x;
        for(int i=x;i!=0;i=fa[i])
            mstack[++top]=fa[i];
        for(int i=top;i>=1;i--)
            PushDown(mstack[i]);
        while(IsRoot(x)==false)
        {
            if(x==son[fa[x]][fa[x]==son[fa[fa[x]]][1]] and IsRoot(fa[x])==false)
                Rotate(fa[x],x==son[fa[x]][0]),
                Rotate(x,x==son[fa[x]][0]);
            else
                Rotate(x,x==son[fa[x]][0]);
        }
    }
    void Access(int x)
    {
        for(int t=0;x!=0;t=x,x=fa[x])
            Splay(x),son[x][1]=t,fa[t]=x,Update(x);
    }
    inline void MakeRoot(int x)
    {
        Access(x),Splay(x);
        Mirror(x);
    }
    inline int FindRoot(int x)
    {
        Access(x),Splay(x);
        while(son[x][0]!=0)
            PushDown(x),x=son[x][0];
        Splay(x);
        return x;
    }
    inline void Link(int x,int y)//x->y
    {
        if(FindRoot(x)==FindRoot(y)) return;
        MakeRoot(x);
        fa[x]=y;
    }
    inline void Split(int x,int y)//root:y
    {
        MakeRoot(x);
        Access(y),Splay(y);
    }
    inline void Cut(int x,int y)
    {
        Split(x,y);
        if(x==son[y][0] and fa[x]==y)
        {
            son[y][0]=fa[x]=0;
            Update(y);
        }    
    }
    inline int Query(int x,int y)
    {
        MakeRoot(x);
        Access(y),Splay(y);
        return MAX[y];
    }
    inline void AddLine(int x)
    {
        if(e[x].s==e[x].t) return;//自环
        num[n+x]=e[x].b,MAX[n+x]=n+x;
        if(FindRoot(e[x].s)!=FindRoot(e[x].t))
        {
            Link(n+x,e[x].s),Link(n+x,e[x].t);
            return ;
        }
        int t=Query(e[x].s,e[x].t);
        if(num[n+x]<num[t])
        {
            Cut(e[t-n].s,t);
            Cut(e[t-n].t,t);
            Link(e[x].s,n+x);
            Link(e[x].t,n+x);
        }
    }
    inline int Query2()
    {
        if(FindRoot(n)!=FindRoot(1)) return 0x3f3f3f3f;
        return num[Query(1,n)];
    }
}lct;
int main()
{
    n=read(),m=read();
    for(int i=1;i<=m;i++)
        e[i].s=read(),e[i].t=read(),e[i].a=read(),e[i].b=read();
    
    sort(e+1,e+1+m,cmp);
    int ans=0x3f3f3f3f;
    for(int i=1;i<=m;i++)
    {
        lct.AddLine(i);
        ans=min(ans,e[i].a+lct.Query2());
    }
    
    if(ans==0x3f3f3f3f)
        printf("-1"); 
    else
        printf("%d",ans);
    return 0;
}
 ```

---

## 作者：xzyxzy (赞：1)

#### 流程

把边读入按照A为关键字从小到大排序，并每次加边维护关于B的最小生成树，用当前的A和1到n最小的B更新最小答案

#### 正确性

如果当前加的边在1到n的路径上，那么显然正确；当前的边不在路径上则显然在之前已经算过了这条路径的答案

#### 启发

LCT维护最小生成树的好题

#### 注意

化边为点，那么点的splay编号和边的编号要联系清楚

#### PS

这篇题解只是把自己看题解时不理解的地方梳理一下，代码就不贴了

如果对你有帮助，点个赞吧


---

## 作者：dengyixuan (赞：1)

LCT裸题，不会的可以来[这里](http://www.cnblogs.com/dengyixuan/p/8001563.html)看看。

步入正题，现将边按a排序，依次加入每一条边，同时维护路径上的最小生成树上的最大边权，如果两点不连通，就直接连通。

如果两点已经连通，就将该边与路径上较小的一条比较，选择小的那一条即可

统计答案时，如果1与n连通就求出路径上最大值与当前的a值相加，取最小的一个。

但边权不好处理，于是我们把X—>Y路径拆成X->Z->Y,将边权放在Z的点权上即可

下面是代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int sign;
typedef long long ll;
#define For(i,a,b) for(register sign i=(sign)a;i<=(sign)b;++i)
#define Fordown(i,a,b) for(register sign i=(sign)a;i>=(sign)b;--i)
const int N=5e4+5,M=1e5+5;
bool cmax(sign &a,sign b){return (a<b)?a=b,1:0;}
bool cmin(sign &a,sign b){return (a>b)?a=b,1:0;}
template<typename T>T read()
{
    T ans=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)&&ch!='-')ch=getchar();
    if(ch=='-')f=-1,ch=getchar();
    while(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();
    return ans*f;
}
void file()
{
    #ifndef ONLINE_JUDGE
        freopen("LCT.in","r",stdin);
        freopen("LCT.out","w",stdout);
    #endif
}
int n,m;
int ch[N+M][2],fa[N+M],rev[N+M],edge[N+M],bl[N+M];
struct node
{
    int u,v,a,b;
    inline void init(){u=v=a=b=0;}
    bool operator < (const node &x)const
    {return a<x.a;}
}e[M];
inline void push_up(int x)
{
    if(e[bl[x]].b>=e[edge[ch[x][0]]].b&&e[bl[x]].b>=e[edge[ch[x][1]]].b)edge[x]=bl[x];
    else if(e[edge[ch[x][0]]].b>=e[edge[ch[x][1]]].b)edge[x]=edge[ch[x][0]];
    else edge[x]=edge[ch[x][1]];
}
inline void push_down(int x)
{
    if(rev[x])
    {
        rev[ch[x][0]]^=1;
        rev[ch[x][1]]^=1;
        swap(ch[x][0],ch[x][1]);
        rev[x]=0;
    }
}
inline bool isroot(int x){return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x;}
inline bool get(int x){return x==ch[fa[x]][1];}
inline void rotate(int x)
{
    int old=fa[x],oldfa=fa[old],o=get(x);
    if(!isroot(old))ch[oldfa][get(old)]=x;
    fa[x]=oldfa;fa[ch[x][o^1]]=old;fa[old]=x;
    ch[old][o]=ch[x][o^1];ch[x][o^1]=old;
    push_up(old);push_up(x);
}
const int inf=0x3f3f3f3f;
int l[N+M],ans=inf;
inline void splay(int x)
{
    l[0]=0;
    int y=x;
    while(1)
    {
        l[++l[0]]=y;
        if(isroot(y))break;
        y=fa[y];
    }
    Fordown(i,l[0],1)push_down(l[i]);
    while(!isroot(x))
    {
        if(!isroot(fa[x]))rotate(get(x)^get(fa[x])?x:fa[x]);
        rotate(x);
    }
}
inline void access(int x)
{
    for(register int y=0;x;y=x,x=fa[x])
    {
        splay(x);ch[x][1]=y;push_up(x);
    }
}
inline void makeroot(int x)
{
    access(x);splay(x);rev[x]^=1;
}
inline int find(int x)
{
    access(x);splay(x);
    while(ch[x][0])x=ch[x][0];
    return x;
}
inline void cut(int x,int y)
{
    makeroot(x);
    access(y);splay(y);
    if(ch[y][0]==x)ch[y][0]=fa[x]=0;
}
inline void link(int x,int y)
{
    makeroot(x);fa[x]=y;
}
inline void deal(int i)
{
    int x=e[i].u,y=e[i].v;
    if(find(x)^find(y))link(x,i+n),link(i+n,y);
    else
    {
        makeroot(x);
        access(y);splay(y);
        if(e[edge[y]].b>e[i].b)
        {
            int t=edge[y];
            cut(t+n,e[t].u);
            cut(t+n,e[t].v);
            link(i+n,e[i].u);
            link(i+n,e[i].v);
        }
    }
}
inline void input()
{
    n=read<int>();m=read<int>();
    For(i,1,m)
    {
        e[i].u=read<int>();
        e[i].v=read<int>();
        e[i].a=read<int>();
        e[i].b=read<int>();
    }
}
inline int cal()
{
    if(find(1)^find(n))return inf;
    makeroot(1);
    access(n);splay(n);
    return e[edge[n]].b;
}
inline void work()
{
    sort(e+1,e+m+1);
    e[0].init();
    For(i,1,m)edge[i+n]=bl[i+n]=i;
    For(i,1,m)
    {
        deal(i);
        while(e[i].a==e[i+1].a)++i,deal(i);
        cmin(ans,cal()+e[i].a);
    }
    printf("%d\n",ans==inf?-1:ans);
}
int main()
{
    file();
    input();
    work();
    return 0;
}
```

---

## 作者：magolor (赞：1)

楼下SPFA好，不过正解是LCT：


动态树题目：枚举Ai，这样当Ai固定后，Bi的最小生成树就是答案。

但是每次最小生成树显然TLE，我们考虑引入动态树。


动态树支持加边和删边，所以可以用来维护最小生成树，

类似于次小生成树的方式（但并不一样）：

用并查集（甚至直接LCT也可以）维护连通性，

如果两个点不连通，那么很好，加边，然后连通了；

如果两个点连通，那么比较环（假设加入这条边所产生的）上最大边和当前边：

如果当前边比最大边小，那么显然可以得到更优的答案，加入次边，删去最大边；

否则什么也不做。


统计答案如果把1认为是根，就是统计n到根路径的权值最大值，LCT也能做。

但是怎么维护边权呢？把边拆成点：A---X----B，令所有树上点权值为0，拆出来的M个X点权值为对应边权。

每次Cut不要忘了切掉X的两条边。



    
    
    
    
    
    
    
    
    
    

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 300000
#define mx(x) t[x].mx
#define w(x) t[x].w
#define lz(x) t[x].lz
#define lc(x) t[x].c[0]
#define rc(x) t[x].c[1]
#define c(x,y) t[x].c[y]
#define fa(x) t[x].fa
#define rtf(x) t[x].rtf 
#define gc() getchar()
inline int read(int ans = 0, int sgn = ' ', int ch = gc())
{
    for(;ch < '0' || ch > '9'; sgn=ch,ch=gc());
    for(;ch >='0' && ch <='9'; (ans*=10)+=ch-'0',ch=gc());
    return sgn-'-' ? ans : -ans;
}
struct Node{int mx,w,lz,c[2],fa,rtf;}t[MAXN+5];
struct Edge{int u,v,a,b,k;Edge(int _u = 0, int _v = 0, int _a = 0, int _b = 0){u=_u,v=_v,a=_a,b=_b;}}e[MAXN+5];
inline bool cmpa(Edge a, Edge b)
{
    return a.a < b.a;
}
int n, m, tot = 1, ans = 0x3f3f3f3f;
inline int New(int v, int p)
{
    mx(tot) = tot, w(tot) = v, fa(tot) = p, rtf(tot) = lc(tot) = rc(tot) = lz(tot) = 0;
    return tot++;
}
struct Splay_Tree
{
    inline void Push(int p)
    {
        if(p)
        {
            int v = (w(mx(rc(p))) > w(mx(lc(p))) ? mx(rc(p)) : mx(lc(p)));
            mx(p) = (w(v) > w(p) ? v : p);
        }
        return;
    }
    inline void Lazy(int p)
    {
        if(lz(p))
            lz(lc(p)) ^= 1, lz(rc(p)) ^= 1, swap(lc(p),rc(p)), lz(p) = 0;
        return;
    }
    inline void Rotate(int x, bool w)
    {
        int y = fa(x), z = fa(y), b = c(x,!w);
        if(b)
            fa(b) = y;
        c(y,w) = b, c(x,!w) = y, fa(y) = x, fa(x) = z, rtf(x) = rtf(y), rtf(y) = 0, Push(y), Push(x);
        if(z)
            c(z,(y==rc(z))) = x;
        return;
    }
    inline void Splay(int x, int goal, int y = 0, int z = 0, int xy = 0, int yz = 0)
    {
        for(y = fa(x), z = fa(y), Lazy(z), Lazy(y), Lazy(x); y != goal; Rotate(x,xy), y = fa(x), z = fa(y), Lazy(z), Lazy(y), Lazy(x))
            if((xy=(x==rc(y))) == (yz=(y==rc(z))) && z != goal)
                Rotate(y,yz);
        return;
    }
};
struct LCT
{
    Splay_Tree T;
    inline void Access(int p)
    {
        for(int w; T.Splay(p,0), w=rtf(p); rc(w) = p, fa(p) = w, rtf(p) = 0, T.Push(w))
        { 
            if(rc(p))
                fa(rc(p)) = 0, rtf(rc(p)) = p, rc(p) = 0, T.Push(p);
            T.Splay(w,0);
            if(rc(w))
                fa(rc(w)) = 0, rtf(rc(w)) = w;
        }
        if(rc(p))
            fa(rc(p)) = 0, rtf(rc(p)) = p, rc(p) = 0, T.Push(p);
        return; 
    }
    inline void Root(int p)
    {
        Access(p), lz(p) = 1;
        return; 
    }
    inline void Link(int v, int w)
    {
        Root(v), Access(w), lc(v) = w, fa(w) = v, rtf(w) = 0, T.Push(v);
        return;
    }
    inline void Cut(int v)
    {
        Access(v), fa(lc(v)) = 0, lc(v) = 0, T.Push(v);
        return;
    }
    inline int Query(int p)
    {
        Access(p);
        return mx(p);
    }
}lct;
struct Find_Union
{
    int fa[MAXN+5];    
    inline void Init(int len)
    {
        for(register int i = 0; i <= len; fa[i] = i, i++);
        return;
    }
    inline int getf(int x)
    {
        if(x != fa[x])
            fa[x] = getf(fa[x]);
        return fa[x];
    }
    inline bool Union(int x, int y)
    {
        if((x=getf(x)) == (y=getf(y)))
            return false;
        fa[x] = y;
        return true;
    }
    inline bool Connective(int x, int y)
    {
        return ((x=getf(x)) == (y=getf(y)));
    }
}s;
int main()
{
    n = read(), m = read();
    for(register int i = 1; i <= n; New(0,0), i++);
    for(register int i = 1, u, v, a, b; i <= m; i++)
        u = read(), v = read(), a = read(), b = read(), e[i] = Edge(u,v,a,b), e[i].k = New(b,0);
    s.Init(n), sort(e+1,e+m+1,cmpa);
    for(register int i = 1, w; i <= m; i++)
    {
        if(!s.Union(e[i].u,e[i].v))
        {
            lct.Root(e[i].v), w = lct.Query(e[i].u);
            if(w(w) > w(e[i].k))
                lct.Cut(w), lct.Root(e[i].u), lct.Cut(w), lct.Link(e[i].k,e[i].u), lct.Link(e[i].k,e[i].v);
        }
        else
            lct.Link(e[i].k,e[i].u), lct.Link(e[i].k,e[i].v);
        if(s.Connective(1,n))
            lct.Root(1), ans = min(ans,e[i].a+w(lct.Query(n)));
    }
    printf("%d",(ans-0x3f3f3f3f ? ans : -1));
     return 0;
}
```

---

## 作者：温栀槿 (赞：0)


2019.01.05

---

前天写了一下午+晚上运输计划结果到最后还是95，最后换种写法才A掉
然后昨天下午到今天上午一直在肝**魔法森林**，真的~~现在看到LCT就头大~~
这道一年前我觉得这辈子都不可能写的题终于被干掉了|>_<|

- 我的做法是按照a为第一关键字排序，之后按顺序加边。
每次我们判断边w的端点(x,y)是否连通
1.如果不连通，直接连接，
2.否则在x->y的路径上找到**b值最大**的边f，
此时判断，
**A.** f.b小于w.b，跳过
**B.** f.b大于w.b，把f删去，在生成树中加入w。

- 上述操作进行完后**都要判断** 1，n是否连通。如果连通我们就更新ans
其中ans=min(ans,a+val[sa(1,n)])。
(a为w.a，val[sa(1,n)]为1到n路径上最大的b值)

- 还有一点就是边权怎么办？LCT不好处理边信息啊！
所以我们把边变成点，例如边w的端点为x,y，加边时我们就把w的编号变为w+n，val[w+n]=w.b。然后**Link(x,w+n),Link(y,w+n);Cut同理**
然后我们**开一个数组id记录子树中最大val值**，每次pushup更新即可

结合[Bei-S's 博客](https://www.zybuluo.com/Bei-S/note/1383114)食用更佳哦~

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=5e5+20;
const int INF=0x7ffffff;

int head[N],cnt,fa[N],p[N],son[N][2],id[N],mx[N],rev[N],val[N],siz[N],n,m,ans=INF;

struct ii{
    int x,y,a,b;
}e[N*2];

inline bool isroot(int x){return son[fa[x]][0]!=x&&son[fa[x]][1]!=x;}

inline void pushdown(int x){
    if(!rev[x]) return ;
    rev[x]=0;rev[son[x][0]]^=1;rev[son[x][1]]^=1;
    swap(son[x][0],son[x][1]);
}

inline void pushup(int x){//更新最大边编号 
    if(val[x]>val[id[son[x][0]]]&&val[x]>val[id[son[x][1]]]) id[x]=x;//如果当前点(边化的点)比儿子的边权都大，直接赋为x 
    else id[x]=val[id[son[x][0]]]>val[id[son[x][1]]]?id[son[x][0]]:id[son[x][1]];//否则谁大赋谁的 
}

inline void rotate(int x){
    pushdown(fa[x]);pushdown(x);
    int y=fa[x],z=fa[y],t=son[y][0]==x;
    if(!isroot(y)) son[z][y==son[z][1]]=x;
    fa[x]=z;
    son[y][!t]=son[x][t];fa[son[x][t]]=y;
    son[x][t]=y;fa[y]=x;
    pushup(y);pushup(x);
}

inline void splay(int x){
    pushdown(x);
    while(!isroot(x)){
        int y=fa[x],z=fa[y];
        if(!isroot(y)) (son[y][0]==x)^(son[z][0]==y)?rotate(x):rotate(y);
        rotate(x);
    }
}


inline void Access(int x){
    for(int y=0;x;y=x,x=fa[x]){
        splay(x);
        son[x][1]=y;
        pushup(x);
    }
}

inline void Makeroot(int x){
    Access(x);
    splay(x);
    rev[x]^=1;
}

inline void Split(int x,int y){
    Makeroot(x);
    Access(y);
    splay(x);
}

inline void Link(int x,int y){
    Makeroot(x);
    fa[x]=y;
}

inline void Cut(int x,int y){
    Split(x,y);
    splay(x);
    fa[y]=son[x][1]=0;
}

inline int Find(int x){
    Access(x);
    splay(x);
    while(son[x][0]) x=son[x][0];
    return x;
}

inline int sa(int x,int y){//查询x，y路径中b值最大的边的编号 
    Makeroot(x);
    Access(y);
    splay(y);//把x，y放入一颗splay中，把y splay到根，更新后id[y]即为所求 
    return id[y];
}

bool cmp(ii l,ii r) {return l.a<r.a;}

int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++) scanf("%d%d%d%d",&e[i].x,&e[i].y,&e[i].a,&e[i].b);
    sort(e+1,e+1+m,cmp);//按照a排序 
    for(int i=1;i<=m;i++){
        int u=e[i].x,v=e[i].y,a=e[i].a,b=e[i].b;
        if(Find(u)==Find(v)){//如果边的端点已经连通，他们之间最大b值 
            int f=sa(u,v);//f为U,V间最大(b值)边的编号 
            if(val[f]<=b) {//如果val[f]<=b 直接查询即可 
                if(Find(1)==Find(n))
                    ans=min(ans,a+val[sa(1,n)]);
                continue;
            }
            Cut(f,e[f-n].x);Cut(f,e[f-n].y);//否则我们需要删去这条边，注意删去后记得连边，我写在下面了 
        }
        val[i+n]=b;//如果 端点不连通 或者 新加入边的b值比边的端点间最大的b值小 ，我们都要连上这条边 
        id[i+n]=i+n;//把边化点，val记为b，id记作i+n 
        Link(u,i+n);Link(v,i+n);
        if(Find(1)==Find(n))//更新答案 
            ans=min(ans,a+val[sa(1,n)]);
    }
    cerr<<ans;
    if(ans==INF) printf("-1");
    else printf("%d",ans);
}
```








---


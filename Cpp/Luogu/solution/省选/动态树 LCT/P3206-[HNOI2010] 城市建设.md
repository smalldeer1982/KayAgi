# [HNOI2010] 城市建设

## 题目描述

PS 国是一个拥有诸多城市的大国。国王 Louis 为城市的交通建设可谓绞尽脑汁。Louis 可以在某些城市之间修建道路，在不同的城市之间修建道路需要不同的花费。

Louis 希望建造最少的道路使得国内所有的城市连通。但是由于某些因素，城市之间修建道路需要的花费会随着时间而改变。Louis 会不断得到某道路的修建代价改变的消息。他希望每得到一条消息后能立即知道使城市连通的最小花费总和。Louis 决定求助于你来完成这个任务。


## 说明/提示

### 数据规模与约定
- 对于 $20\%$ 的数据，$n\le 10^3$，$m,q\le 6\times 10^3$。
- 对于另外 $20\%$ 的数据，$n\le 10^3$，$m\le 5\times 10^4$，$q\le 8\times 10^3$。修改后的代价不会比之前的代价低。
- 对于 $100\%$ 的数据，$1\le n\le 2\times 10^4$，$1\le m,q\le 5\times 10^4$，$1\le x_i,y_i\le n$，$0\le z_i\le 5\times 10^7$。

## 样例 #1

### 输入

```
5 5 3
1 2 1
2 3 2
3 4 3
4 5 4
5 1 5
1 6
1 1
5 3```

### 输出

```
14
10
9```

# 题解

## 作者：shadowice1984 (赞：57)

嗯~ o(\*￣▽￣\*)o，做完这到题想必会对CDQ分治有一个全新的理解吧

其实CDQ分治的本质是：

最大化各个询问间的重复操作从而将复杂度的增加控制在一个log内

而利用的原理就是分治原理:

只要保证任意两个操作和询问间的**相对时序**不变我们就可以任意处理这个操作-询问序列

那么对于这道题题目是十分粗暴的动态MST

考虑对时间进行分治，也就是说，我们要寻找两个操作序列间的**公共部分**

为此我们把这张图划分为两个部分，**动态边**和**静态边**

如果你CDQ正在考虑(l,r)这一段操作序列

那么L,r内操作涉及的边就称为**动态边**，这张图其余的边被称为**静态边**

对于一个动态边，显然是无法处理（因为CDQ就是动态转静态的工具）

所以先放着不动，那么我们考虑**简化**静态边集合

肯定会有一些静态边是一定会被其他静态边PK掉的，这些边完全没有下传的必要

动态边可能无法联通整张图，那么肯定会有一些静态边充当**沟通**这些**动态边**的“桥梁”

这些静态边早晚要被加到MST里的，不如现在就加上

\*请务必仔细阅读以上两句话\*

那么就可以将不会出现的边从**静态边集**中**删去**，将一定会出现的边在**静态边集**中**缩点**

从而简化了静态边集

然后这里有一个证明，每次如此操作之后剩余的静态边和动态边大致相等，略

下面考虑如何将（l,r）这段区间拆分为(l,mid)(mid,r)这两个区间

那么我们发现，会有一些动态边变为静态边

这才是这个划分的玄妙之处，动态边会不断的变成静态边，最后变成了一个纯静态的kruskal

显然如果向(l,mid)走的话，只在(mid,r)而不在(l,mid)的**动态边**会变成**静态边**

同理如果向(mid,r)走的话，只在(l,mid)而不在(mid,r)的**动态边**会变成**静态边**

那么直接在静态边集中插入跑个缩边就行了对吧

终止状态

如果插入的是最后一条动态边，**更改这个动态边所对应的权值**，并且更新这个动态边对应的查询的答案

为什么要更改呢，因为动转静的过程，边的权值是**当前时刻的权值**

而如果插入的动态边是最后一条了，证明这个动态边**从此以后在也不会被用到**

所以就要把它对应的修改做了（不明白自己画一个分治树）

剩下的就是代码实现

这里有两点要讲

1.每一层CDQ开两个vector一个存静态边一个存动态边

2.要删的边可以通过对静态边集跑一个kruskal找出来

3.要缩的边可以通过先把动态边union起来，再跑一个kruskal找出来

4.可以用并查集维护缩点关系

突然发现一个问题，我们的kruskal需要并查集，我们缩点的维护需要并查集

哪里有那么多的内存！

然而那是一次性的路径压缩式并查集，我们的按秩合并并查集，是资瓷**撤销**的

//应该知道可撤销不是可持久化吧。。。

只要维护一个栈存储操作就可以了，而且资瓷倒流到一个确定的时间点，这样的话我们只需开两个并查集就行了

上代码~（102行，较短）



```cpp
    #include<cstdio>
    #include<algorithm>
    #include<vector>
    #include<stack>
    using namespace std;
    typedef long long ll;
    int n;int m;int ask;
    struct bcj
    {
        int fa[20010];int size[20010];
        struct opt{int u;int v;};stack <opt> st;
        inline void ih(){for(int i=1;i<=n;i++)fa[i]=i,size[i]=1;}
        inline int f(int x){return (fa[x]==x)?x:f(fa[x]);}
        inline void u(int x,int y)//带撤回
        {
            int u=f(x);int v=f(y);if(u==v)return;if(size[u]<size[v])swap(u,v);
            size[u]+=size[v];fa[v]=u;opt o;o.u=u;o.v=v;st.push(o);   
        }
        inline void undo(){opt o=st.top();st.pop();fa[o.v]=o.v;size[o.u]-=size[o.v];}
        inline void clear(int tim){while(st.size()>tim){undo();}}
    }s,s1;
    struct edge//静态边
    {
        int u;int v;ll val;int mrk;
        friend bool operator <(edge a,edge b){return a.val<b.val;}
    }e[50010];
    struct moved{int u;int v;};//动态边
    struct query{int num;ll val;ll ans;}q[50010];bool book[50010];//询问
    vector <edge> ve[30];vector <moved> vq;vector <edge> tr;ll res[30];int tim[30];
    inline void pushdown(int dep)//缩边
    {
        tr.clear();//这里要复制一份，以免无法回撤操作
        for(int i=0;i<ve[dep].size();i++){tr.push_back(ve[dep][i]);}
        sort(tr.begin(),tr.end());
        for(int i=0;i<tr.size();i++)//无用边
        {
            if(s1.f(tr[i].u)==s1.f(tr[i].v)){tr[i].mrk=-1;continue;}s1.u(tr[i].u,tr[i].v);
        }s1.clear(0);res[dep+1]=res[dep];
        for(int i=0;i<vq.size();i++){s1.u(vq[i].u,vq[i].v);}vq.clear();
        for(int i=0;i<tr.size();i++)//必须边
        {
            if(tr[i].mrk==-1||s1.f(tr[i].u)==s1.f(tr[i].v))continue;tr[i].mrk=1;
            s1.u(tr[i].u,tr[i].v);s.u(tr[i].u,tr[i].v);res[dep+1]+=tr[i].val;
        }s1.clear(0);ve[dep+1].clear();
        for(int i=0;i<tr.size();i++)//缩边
        {
            if(tr[i].mrk!=0)continue;
            edge p;p.u=s.f(tr[i].u);p.v=s.f(tr[i].v);if(p.u==p.v)continue;
            p.val=tr[i].val;p.mrk=0;ve[dep+1].push_back(p);
        }return;
    }
    inline void solve(int l,int r,int dep)
    {
        tim[dep]=s.st.size();int mid=(l+r)/2;
        if(r-l==1)//终止条件
        {
            edge p;p.u=s.f(e[q[r].num].u);p.v=s.f(e[q[r].num].v);p.val=q[r].val;
            e[q[r].num].val=q[r].val;p.mrk=0;ve[dep].push_back(p);pushdown(dep);
            q[r].ans=res[dep+1];s.clear(tim[dep-1]);return;
        }
        for(int i=l+1;i<=mid;i++){book[q[i].num]=true;}
        for(int i=mid+1;i<=r;i++)//动转静
        {
            if(book[q[i].num])continue;
            edge p;p.u=s.f(e[q[i].num].u);p.v=s.f(e[q[i].num].v);
            p.val=e[q[i].num].val;p.mrk=0;ve[dep].push_back(p);
        }
        for(int i=l+1;i<=mid;i++)//询问转动态
        {
            moved p;p.u=s.f(e[q[i].num].u);p.v=s.f(e[q[i].num].v);vq.push_back(p);
        }pushdown(dep);//下面的是回撤
        for(int i=mid+1;i<=r;i++){if(book[q[i].num])continue;ve[dep].pop_back();}
        for(int i=l+1;i<=mid;i++){book[q[i].num]=false;}solve(l,mid,dep+1);
        for(int i=0;i<ve[dep].size();i++){ve[dep][i].mrk=0;}
        for(int i=mid+1;i<=r;i++){book[q[i].num]=true;}
        for(int i=l+1;i<=mid;i++)//动转静
        {
            if(book[q[i].num])continue;
            edge p;p.u=s.f(e[q[i].num].u);p.v=s.f(e[q[i].num].v);
            p.val=e[q[i].num].val;p.mrk=0;ve[dep].push_back(p);
        }
        for(int i=mid+1;i<=r;i++)//询问转动
        {
            book[q[i].num]=false;
            moved p;p.u=s.f(e[q[i].num].u);p.v=s.f(e[q[i].num].v);vq.push_back(p);
        }pushdown(dep);solve(mid,r,dep+1);
        s.clear(tim[dep-1]);return;//时间倒流至上一层
    }
    int main()
    {
        scanf("%d%d%d",&n,&m,&ask);s.ih();s1.ih();
        for(int i=1;i<=m;i++){scanf("%d%d%lld",&e[i].u,&e[i].v,&e[i].val);}
        for(int i=1;i<=ask;i++){scanf("%d%lld",&q[i].num,&q[i].val);}
        for(int i=1;i<=ask;i++)//初始动态边
        {
            book[q[i].num]=true;moved p;p.u=e[q[i].num].u;
            p.v=e[q[i].num].v;vq.push_back(p);
        }
        for(int i=1;i<=m;i++){if(book[i])continue;ve[1].push_back(e[i]);}//初始静态
        for(int i=1;i<=ask;i++){book[q[i].num]=false;}solve(0,ask,1);
        for(int i=1;i<=ask;i++){printf("%lld\n",q[i].ans);}return 0;//拜拜程序~
    }

```

---

## 作者：MikukuOvO (赞：39)

神仙题。。。

首先考虑线段树分治，按照时间建出线段树，然后我们考虑对于分治终点$l=r$暴力修改，但是这样每次的边集都是$m$，显然无法通过，不过这道题有两个小$trick$：

$1.$如果我们将区间$[l,r]$的边权都设为$-INF$，跑一遍$MST$，这时仍然在$MST$中的边权不为$-INF$的边在接下来的子区间也一定在生成树中，因此我们可以直接将其统计贡献并将这些边所连接的连通块缩点。

$2.$如果我们将区间$[l,r]$的边权都设为$INF$，跑一遍$MST$，这时不在$MST$中的边就可以直接删去了。

有了这两个小$trick$，不难证明对于区间$[l,r]$，点和边的规模都是$r-l$的。

还是证明一下吧：

考虑到第一个操作，最多会有$r-l$个点不能被缩，因此点的规模是$r-l$的，第二个操作保证了边的规模与点同阶。

总复杂度$nlog^2n$。


---

## 作者：kczno1 (赞：26)

动态最小生成树。

cdq分治。当处理一个区间的修改时，其他边都是已知的。

设区间大小为s。

如果把区间内的边全部修改为-oo，做mst，树上的其他边就是必须选的。

所以就可以缩点，这样使得点数<=n+1。

如果把区间内的边全部修改为oo，做mst，非树上的其他边就是必定不选的。

所以就可以删边，这样使得其他的边数<=点数-1。

所以规模就缩小到了O(s)。

所以时间复杂度f(n)=2f(n/2)+mst(n)=nlog^2(n)

具体的，我们用一个队列记录所有其他边。

当进入左区间时，我们新开一个队列记录左区间的其他边，用并查集记录每个点所属联通块。

记录所有联通块的代表，将边的端点变成代表，在做完左区间回来时，只用把代表的爸爸变回自己即可。

边界就是s=1时，此时点数<=2,边数<=1，特判。

```cpp
#include<bits/stdc++.h>
using std::min;
using std::sort;

void chmin(int &x,int y)
{
    if (x>y) x=y;
}
#define ll long long
#define N 40010
#define M 100010
bool in[M];//是否在区间中 
int SZ[20][N];
int f[N],*sz,sz0[N];
int Q[20][N],*q;//que:队列，记录所有代表 
int i;

int find(int x) { return f[x]==x?x:find(f[x]); }
struct edge
{
    int x,y,w;
    void upd()
    {
        find(x);find(y);
    }
    bool merge()
    {
        int fx=find(x),fy=find(y);
        if (fx==fy) return 0;
        if (sz[fx]<sz[fy]) { f[fx]=fy;sz[fy]+=sz[fx]; }
        else {f[fy]=fx;sz[fx]+=sz[fy]; } 
        return 1;
    }
}e[M<<1];int A[20][M<<1],*a;
struct query
{
    int id,w;
}l[M];

void back(int x)
{
    sz[x]=sz0[x];f[x]=x;
}
int top,x,Dep;
bool xiao(int x,int y)
{
    return e[x].w<e[y].w;
}
void solve(int dep,int L,int R,int n,int *q,int m,int *a,ll ans)
{
    sz=SZ[dep];
    for (i=1;i<=n;++i) sz0[q[i]]=sz[q[i]];
    //区间内的边=-oo，强制选 
    for (i=L;i<=R;++i) e[l[i].id].merge();
    for (i=1;i<=m;++i) 
    if (e[a[i]].merge())  
    {
        ans+=e[a[i]].w;a[i]=-a[i];
    }
    for (i=1;i<=n;++i) back(q[i]);
    int top=0;
    for (i=1;i<=m;++i) 
    if (a[i]<0) e[-a[i]].merge();
    else a[++top]=a[i];
    m=top;top=0;
    for (i=1;i<=n;++i) 
    {
      int x=q[i];
      if (f[x]==x) {q[++top]=x;sz0[x]=sz[x]; }
    }
    n=top;
    for (i=L;i<=R;++i) in[l[i].id]=1; 
    //区间内的边=oo，强制不选 
    top=0;
    for (i=1;i<=m;++i) 
    { 
      if (!in[a[i]]&&!e[a[i]].merge()) continue; 
      a[++top]=a[i];
    }
    m=top;
    for (i=L;i<=R;++i) in[l[i].id]=0; 
    for (i=1;i<=n;++i) back(q[i]);
    
    if (n==1)
    {
        for (i=L;i<=R;++i) 
        {
         e[l[i].id].w=l[i].w;
         printf("%lld\n",ans);
        }
        return ;
    }
    if (L==R)
    {
        int w=e[l[L].id].w=l[L].w;
        for (i=1;i<=m;++i) chmin(w,e[a[i]].w);
        printf("%lld\n",ans+w);
        return ;
    }
    
    for (i=1;i<=m;++i) e[a[i]].upd();
    
    int mid=L+R>>1;
    ++dep;
    for (i=1;i<=n;++i) SZ[dep][Q[dep][i]=q[i]]=sz[q[i]];
    for (i=1;i<=m;++i) A[dep][i]=a[i];
    solve(dep,L,mid,n,Q[dep],m,A[dep],ans);
    --dep;
    for (i=1;i<=n;++i) f[q[i]]=q[i];
    sort(a+1,a+m+1,xiao);
    solve(dep,mid+1,R,n,q,m,a,ans);
}

int main()
{ freopen("1.in","r",stdin);freopen("1.out","w",stdout);
    int n,m,q;
    scanf("%d%d%d",&n,&m,&q);
    for (i=1;i<=m;++i) scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].w);
    for (i=1;i<=q;++i) scanf("%d%d",&l[i].id,&l[i].w); 
    for (i=1;i<=n;++i) { f[i]=Q[1][i]=i;SZ[1][i]=1;}
    for (i=1;i<=m;++i) A[1][i]=i;
    sort(A[1]+1,A[1]+m+1,xiao);
    solve(1,1,q,n,Q[1],m,A[1],0); 
}
```

---

## 作者：zhiyangfan (赞：16)

### 题意简述
给出一个 $n$ 个点 $m$ 条边的无向图和 $q$ 次修改，每次修改一个边的边权，问每次修改后图的最小生成树边权和是多少。($1\le n\le2\times10^4,1\le m,q\le5\times 10^4$)
### 题解
正好我最近在学 $\rm LCT$ ，看到修改边权一眼 $\rm LCT$ 。刚开始想歪了，以为就是一个裸的 $\rm LCT$ 动态维护 $\rm MST$ 的题，但发现这样不能保证 `cut` 后新 `link` 的边存在（就是加不上去）就挂掉了。而这题的 $\rm LCT$ 正解应该是 **线段树分治+$\rm LCT$**

类似 $\rm CDQ$ 分治，线段树分治可以维护一个时间区间，但不同于 $\rm CDQ$ 分治，线段树分治支持撤销操作，也就是当一个操作过时的时候可以撤销掉。如果我们把一段操作对应的时间区间 $[L,R]$ 打散为 $\log$ 级别的影响区间放到线段树上，这样我们递归到叶子结点时其实已经处理完对这个时间有贡献的所有操作了，可以直接输出整体计算的答案。而离开这个结点的时候因为这个操作已经过时了，回撤即可，这样整体记录的答案就一直是满足当前时间区间的答案。

具体来看，这道题修改边权可以看做删掉原来的边，加入一条新边，所以我们可以求出一个边的作用区间，并把每条边的作用区间扔到线段树上。递归到线段树的某个结点时，把里面所有的边加入维护的动态 $\rm MST$ ，如果是叶子结点就直接输出答案（因为我们遍历是有顺序的，所以不用先记录再输出），否则往下递归。最后递归回溯时撤销之前加边操作就可以了，具体实现见代码，时间复杂度 $\mathcal{O}(n\log ^2m)$ ，常数奇大，必须吸氧才能过。
### 代码
```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
#define Fa(x) (node[x].fa)
#define Ls(x) (node[x].ch[0])
#define Rs(x) (node[x].ch[1])
inline void read(int& x)
{
	x = 0; char ch; int f = 1;
	while ((ch = getchar()) < '0' || ch > '9')
		f = (ch ^ '-' ? 1 : -1);
	while (x = (x << 1) + (x << 3) + ch - '0',
	(ch = getchar()) >= '0' && ch <= '9') ;
	x *= f;
}
const int N = 1e6 + 10; typedef long long ll; ll ans;
struct Splay{ int fa, ch[2], mx, revFlag; }node[N]; int w[N];
inline void pushup(int x)
{
	node[x].mx = x;
	if (Ls(x) && w[node[Ls(x)].mx] > w[node[x].mx]) node[x].mx = node[Ls(x)].mx;
	if (Rs(x) && w[node[Rs(x)].mx] > w[node[x].mx]) node[x].mx = node[Rs(x)].mx;
}
inline void reverse(int x) { std::swap(Ls(x), Rs(x)); node[x].revFlag ^= 1; }
inline void pushdown(int x)
{
	if (!node[x].revFlag) return ;
	if (Ls(x)) reverse(Ls(x));
	if (Rs(x)) reverse(Rs(x));
	node[x].revFlag = 0;
}
inline int nRoot(int x) { return Rs(Fa(x)) == x || Ls(Fa(x)) == x; }
inline int get(int x) { return Rs(Fa(x)) == x; }
inline void rotate(int x)
{
	int fa = Fa(x), gf = Fa(fa), d = get(x), dd = get(fa);
	if (nRoot(fa)) node[gf].ch[dd] = x;
	node[fa].ch[d] = node[x].ch[d ^ 1]; Fa(node[x].ch[d ^ 1]) = fa;
	node[x].ch[d ^ 1] = fa; Fa(x) = gf; Fa(fa) = x;
	pushup(fa); pushup(x);
}
int st[N], tp;
inline void splay(int x)
{
	int y = st[tp = 1] = x;
	while (nRoot(y)) st[++tp] = y = Fa(y);
	while (tp) pushdown(st[tp--]);
	for (; nRoot(x); rotate(x)) if (nRoot(Fa(x)))
		rotate(get(Fa(x)) == get(x) ? Fa(x) : x);
	pushup(x);
}
inline void access(int x)
{
	int y = 0;
	while (x)
	{
		splay(x); Rs(x) = y;
		pushup(x); x = Fa(y = x);
	}
}
inline void makeroot(int x) { access(x); splay(x); reverse(x); }
inline void split(int x, int y) { makeroot(x); access(y); splay(y); }
inline void link(int x, int y) { split(x, y); Fa(x) = y; }
inline void cut(int x, int y) { split(x, y); Fa(x) = Ls(y) = 0; }
inline int findroot(int x)
{
	access(x); splay(x);
	while (Ls(x)) x = Ls(x), pushdown(x);
	splay(x); return x;
}
std::vector<int> vec[N]; int s1[N], s2[N], las[N], top, n;
struct edge{ int u, v, w; }E[N]; int cnt, qr[N];
void insert(int k, int l, int r, int x, int y, int id)
{
	if (x <= l && r <= y) return vec[k].push_back(id), void();
	//^边 id 在当前区间有效，要记录一下^
	int mid = (l + r) >> 1;
	if (x <= mid) insert(k << 1, l, mid, x, y, id);
	if (mid < y) insert(k << 1 | 1, mid + 1, r, x, y, id);
}
void solve(int k, int l, int r)
{
	int last = top, x, y, d, t, w;
	for (int i = 0; i < vec[k].size(); ++i)
	{
		t = vec[k][i]; x = E[t].u;
		w = E[t].w; y = E[t].v; 
		//尝试加入这条边，并用s1,s2两个栈记录删加边情况方便回撤
		if (findroot(x) == findroot(y))
		{
			split(x, y); d = node[y].mx - n; if (E[d].w <= w) continue;
			cut(E[d].u, d + n); cut(d + n, E[d].v);
			s1[++top] = d; s2[top] = -1; ans -= E[d].w;
		}
		link(x, t + n); link(t + n, y);
		s1[++top] = t; s2[top] = 1; ans += E[t].w;
	}
	int mid = (l + r) >> 1;
	if (l == r) printf("%lld\n", ans); //因为我们的递归顺序，所以可以直接输出
	else solve(k << 1, l, mid), solve(k << 1 | 1, mid + 1, r);
	while (top > last)
	{
		d = s1[top]; x = E[d].u; y = E[d].v; w = E[d].w;
		if (s2[top--] == -1) link(x, d + n), link(d + n, y), ans += w;
		else cut(x, d + n), cut(d + n, y), ans -= w;
	}
}
int main()
{
	int m, q; read(n); read(m); read(q);
	for (int i = 1, x, y, z; i <= m; ++i)
	{
		read(x); read(y); read(z); w[n + (++cnt)] = z;
		E[cnt].u = x; E[cnt].v = y; E[cnt].w = z;
	}
	for (int i = 1, k, d; i <= q; ++i)
	{
		read(k); read(d); qr[i] = k; w[n + (++cnt)] = d;
		E[cnt].u = E[k].u; E[cnt].v = E[k].v; E[cnt].w = d;
	}
	for (int i = 1; i <= m; ++i) las[i] = q + 1; //处理边作用的区间
	for (int i = q; i >= 1; --i)
	{
		insert(1, 1, q, i, las[qr[i]] - 1, m + i);
		las[qr[i]] = i; 
	}
	for (int i = 1; i <= m; ++i) 
		if (las[i] > 1) insert(1, 1, q, 1, las[i] - 1, i);
	solve(1, 1, q); return 0; 
}
```
### 写在后面
关于 $\rm LCT$ 动态维护 $\rm MST$ 的例题：[P2387 [NOI2014] 魔法森林](https://www.luogu.com.cn/problem/P2387) ，其实就是每次加边如果形成环就割掉环上最大的边就好，维护路径边权最大值所在位置就行，就是边权转点权会麻烦。

关于更多的线段树分治+$\rm LCT$ 动态维护 $\rm MST$ 的例题：[P4319 变化的道路](https://www.luogu.com.cn/problem/P4319) ，这题的一般版本，开的时间比较长，应该是放常数奇大的正解过。

---

## 作者：_171829 (赞：8)

[题目传送门](https://www.luogu.com.cn/problem/P3206)

## 题意：
给定一张图支持动态的修改边权，要求在每次修改边权之后输出这张图的最小生成树的最小代价和

## 分析：
事实上有一个线段树分治套 lct 的做法可以解决这个问题，但是这个实现方式常数过大可能需要精妙的卡常技巧才可以通过本题，因此我们不妨考虑 cdq 分治来解决这个问题

和一般的 cdq 分治解决的问题不同，我们此时 cdq 分治的时候并没有修改和询问的关系来让我们进行分治，因为我们是没有办法单独的考虑修改一个边对整张图的最小生成树有什么贡献，因此似乎传统的 cdq 分治思路似乎不是很好使

那么我们通过刚才的例题可以发现一般的 cdq 分治和线段树有着特殊的联系，我们在 cdq 分治的过程中其实隐式的建了一颗线段树出来（因为 cdq 分治的递归树就是一颗线段树）

通常的 cdq 是考虑线段树左右儿子之间的联系

而对于这道题来讲我们需要考虑的是父亲和孩子之间的关系

换句话来讲，我们在 `slove(l,r)` 这段区间的时候如果我们可以想办法使图的规模变成和区间长度相关的一个变量的话我们就可以解决这个问题了

那么具体来讲如何设计算法呢？

假设我们正在构造 `(l,r)` 这段区间的最小生成树边集，并且我们已知它父亲最小生成树的边集

我们将在 `(l,r)` 这段区间中发生变化的边分别将边权赋成 $+∞$ 和 $ -∞$分别各跑一边 `kruskal` 求出那些边在最小生成树当中

对于一条边来讲，如果他没有出现在了所有被修改的边权都被赋成了$+∞$  的最小生成树当中证明它不可能出现在 `(l,r)` 这些询问的最小生成树当中，所以我们仅仅在  的边集中加入最小生成树的树边

对于一条边来讲，如果它出现在了所有被修改的边权都被赋成了-∞  的最小生成树当中，就证明它一定会出现 `(l,r)` 这段的区间的最小生成树当中，这样的话我们就可以使用并查集将这些边对应的点缩起来，并且将答案加上这些边的边权

如此这般我们就将 `(l,r)` 这段区间的边集构造出来了，用这些边求出来的最小生成树和直接求原图的最小生成树等价

那么为什么我们的复杂度是对的呢？

首先被修改的边一定会加入到我们的边集当中去，这些边的数目是 $ O(len)$  级别的

接下来我们需要证明的是边集当中不会有过多的未被修改的边

注意到我们只会加入所有边权取$ +∞$ 最小生成树的树边，因此我们加入的边数目是不会超过当前图的点数的

接下来我们只需证明每递归一层图的点数是 $O(len)$  级别的就可以说明图的边数是 $O(len)$ 级别的了

证明点数是$ O(len) $几倍就变的十分简单了，我们每次向下递归的时侯缩掉的边是在$-∞$  生成树中出现的未被修改边，那么反过来想就是我们割掉了出现在 $-∞$ 生成树当中的所有的被修改边，显然我们最多割掉 $len$ 条边，整张图最多分裂成 $O(len)$ 个连通块，这样的话新图点数就是 $O(len)$ 级别的了

所以我们就证明了每次我们用来跑 `kruskal` 的图都是 $ O(len) $ 级别的了

从而每一层的时间复杂度都是 $ O(n \ log  \ n)$  了

因此我们的时间复杂度就是$T(n) = T( \left\lfloor\frac{n}{2}\right\rfloor)+(\left\lceil\frac{n}{2}\right\rceil) + O(n \log\ n) = O(n \log^2 n) $ 了




代码实现上可能会有一些难度，需要注意的是并查集不能使用路径压缩，否则就不支持回退操作了，执行缩点操作的时候也没有必要真的执行，而是每一层的  `kruskal` 都在上一层的并查集里直接做就可以了

## 代码：

```cpp
#include <algorithm>
#include <cstdio>
#include <stack>
#include <vector>
using namespace std;
typedef long long ll;
int n;
int m;
int ask;
struct bcj {
  int fa[20010];
  int size[20010];
  struct opt {
    int u;
    int v;
  };
  stack<opt> st;
  inline void ih() {
    for (int i = 1; i <= n; i++) fa[i] = i, size[i] = 1;
  }
  inline int f(int x) { return (fa[x] == x) ? x : f(fa[x]); }
  inline void u(int x, int y) {  // 带撤回
    int u = f(x);
    int v = f(y);
    if (u == v) return;
    if (size[u] < size[v]) swap(u, v);
    size[u] += size[v];
    fa[v] = u;
    opt o;
    o.u = u;
    o.v = v;
    st.push(o);
  }
  inline void undo() {
    opt o = st.top();
    st.pop();
    fa[o.v] = o.v;
    size[o.u] -= size[o.v];
  }
  inline void clear(int tim) {
    while (st.size() > tim) {
      undo();
    }
  }
} s, s1;
struct edge  // 静态边
{
  int u;
  int v;
  ll val;
  int mrk;
  friend bool operator<(edge a, edge b) { return a.val < b.val; }
} e[50010];
struct moved {
  int u;
  int v;
};  // 动态边
struct query {
  int num;
  ll val;
  ll ans;
} q[50010];
bool book[50010];  // 询问
vector<edge> ve[30];
vector<moved> vq;
vector<edge> tr;
ll res[30];
int tim[30];
inline void pushdown(int dep)  // 缩边
{
  tr.clear();  // 这里要复制一份，以免无法回撤操作
  for (int i = 0; i < ve[dep].size(); i++) {
    tr.push_back(ve[dep][i]);
  }
  sort(tr.begin(), tr.end());
  for (int i = 0; i < tr.size(); i++) {  // 无用边
    if (s1.f(tr[i].u) == s1.f(tr[i].v)) {
      tr[i].mrk = -1;
      continue;
    }
    s1.u(tr[i].u, tr[i].v);
  }
  s1.clear(0);
  res[dep + 1] = res[dep];
  for (int i = 0; i < vq.size(); i++) {
    s1.u(vq[i].u, vq[i].v);
  }
  vq.clear();
  for (int i = 0; i < tr.size(); i++) {  // 必须边
    if (tr[i].mrk == -1 || s1.f(tr[i].u) == s1.f(tr[i].v)) continue;
    tr[i].mrk = 1;
    s1.u(tr[i].u, tr[i].v);
    s.u(tr[i].u, tr[i].v);
    res[dep + 1] += tr[i].val;
  }
  s1.clear(0);
  ve[dep + 1].clear();
  for (int i = 0; i < tr.size(); i++) {  // 缩边
    if (tr[i].mrk != 0) continue;
    edge p;
    p.u = s.f(tr[i].u);
    p.v = s.f(tr[i].v);
    if (p.u == p.v) continue;
    p.val = tr[i].val;
    p.mrk = 0;
    ve[dep + 1].push_back(p);
  }
  return;
}
inline void solve(int l, int r, int dep) {
  tim[dep] = s.st.size();
  int mid = (l + r) / 2;
  if (r - l == 1) {  // 终止条件
    edge p;
    p.u = s.f(e[q[r].num].u);
    p.v = s.f(e[q[r].num].v);
    p.val = q[r].val;
    e[q[r].num].val = q[r].val;
    p.mrk = 0;
    ve[dep].push_back(p);
    pushdown(dep);
    q[r].ans = res[dep + 1];
    s.clear(tim[dep - 1]);
    return;
  }
  for (int i = l + 1; i <= mid; i++) {
    book[q[i].num] = true;
  }
  for (int i = mid + 1; i <= r; i++) {  // 动转静
    if (book[q[i].num]) continue;
    edge p;
    p.u = s.f(e[q[i].num].u);
    p.v = s.f(e[q[i].num].v);
    p.val = e[q[i].num].val;
    p.mrk = 0;
    ve[dep].push_back(p);
  }
  for (int i = l + 1; i <= mid; i++) {  // 询问转动态
    moved p;
    p.u = s.f(e[q[i].num].u);
    p.v = s.f(e[q[i].num].v);
    vq.push_back(p);
  }
  pushdown(dep);  // 下面的是回撤
  for (int i = mid + 1; i <= r; i++) {
    if (book[q[i].num]) continue;
    ve[dep].pop_back();
  }
  for (int i = l + 1; i <= mid; i++) {
    book[q[i].num] = false;
  }
  solve(l, mid, dep + 1);
  for (int i = 0; i < ve[dep].size(); i++) {
    ve[dep][i].mrk = 0;
  }
  for (int i = mid + 1; i <= r; i++) {
    book[q[i].num] = true;
  }
  for (int i = l + 1; i <= mid; i++) {  // 动转静
    if (book[q[i].num]) continue;
    edge p;
    p.u = s.f(e[q[i].num].u);
    p.v = s.f(e[q[i].num].v);
    p.val = e[q[i].num].val;
    p.mrk = 0;
    ve[dep].push_back(p);
  }
  for (int i = mid + 1; i <= r; i++) {  // 询问转动
    book[q[i].num] = false;
    moved p;
    p.u = s.f(e[q[i].num].u);
    p.v = s.f(e[q[i].num].v);
    vq.push_back(p);
  }
  pushdown(dep);
  solve(mid, r, dep + 1);
  s.clear(tim[dep - 1]);
  return;  // 时间倒流至上一层
}
int main() {
  scanf("%d%d%d", &n, &m, &ask);
  s.ih();
  s1.ih();
  for (int i = 1; i <= m; i++) {
    scanf("%d%d%lld", &e[i].u, &e[i].v, &e[i].val);
  }
  for (int i = 1; i <= ask; i++) {
    scanf("%d%lld", &q[i].num, &q[i].val);
  }
  for (int i = 1; i <= ask; i++) {  // 初始动态边
    book[q[i].num] = true;
    moved p;
    p.u = e[q[i].num].u;
    p.v = e[q[i].num].v;
    vq.push_back(p);
  }
  for (int i = 1; i <= m; i++) {
    if (book[i]) continue;
    ve[1].push_back(e[i]);
  }  // 初始静态
  for (int i = 1; i <= ask; i++) {
    book[q[i].num] = false;
  }
  solve(0, ask, 1);
  for (int i = 1; i <= ask; i++) {
    printf("%lld\n", q[i].ans);
  }
  return 0;  // 拜拜程序~
}
```


---

## 作者：yybyyb (赞：8)

正解别人都讲的很详细了，懒得写了。  
这里补充一个复杂度也是$O(nlog^2m)$，但是常数巨大的方法，所以只能过$80$分：线段树分治+$LCT$动态维护$MST$。

线段树分治很好理解，我们把修改的边全部看成加入了一条新边，然后把原来的边删去。不难发现每条边出现的时间是区间，每次的询问则是单点。那么把每条边打到它所出现的时间区间的线段树上。然后线段树分治，直接用$LCT$动态维护$MST$即可。

$LCT$动态维护$MST$的做法可以看看[NOI2014]魔法森林那题，这里懒得写了。

从上面的分析也不难看出这种方法似乎可以解决更多的问题，可以支持随时动态修改边集，也就是可以任意删边任意加边。

代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
using namespace std;
#define ll long long
#define MAX 50050
#define ls (t[x].ch[0])
#define rs (t[x].ch[1])
#define lson (now<<1)
#define rson (now<<1|1)
inline int read()
{
	int x=0;bool t=false;char ch=getchar();
	while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
	if(ch=='-')t=true,ch=getchar();
	while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
	return t?-x:x;
}
struct Line{int u,v,w;}E[MAX<<2];
int n,m,Q,L[MAX];
vector<int> t[MAX<<2];
struct LCT
{
	struct Node{int ch[2],ff,rev,v,mx;}t[MAX<<2];
	int S[MAX<<2],top;
	bool isroot(int x){return t[t[x].ff].ch[0]!=x&&t[t[x].ff].ch[1]!=x;}
	void pushdown(int x){if(t[x].rev)t[ls].rev^=1,t[rs].rev^=1,t[x].rev=0,swap(ls,rs);}
	void pushup(int x)
		{
			t[x].mx=x;
			if(ls&&t[t[ls].mx].v>t[t[x].mx].v)t[x].mx=t[ls].mx;
			if(rs&&t[t[rs].mx].v>t[t[x].mx].v)t[x].mx=t[rs].mx;
		}
	void rotate(int x)
		{
			int y=t[x].ff,z=t[y].ff;
			int k=t[y].ch[1]==x;
			if(!isroot(y))t[z].ch[t[z].ch[1]==y]=x;t[x].ff=z;
			t[y].ch[k]=t[x].ch[k^1];t[t[x].ch[k^1]].ff=y;
			t[x].ch[k^1]=y;t[y].ff=x;
			pushup(y);pushup(x);
		}
	void Splay(int x)
		{
			S[top=1]=x;
			for(int i=x;!isroot(i);i=t[i].ff)S[++top]=t[i].ff;
			while(top)pushdown(S[top--]);
			while(!isroot(x))
			{
				int y=t[x].ff,z=t[y].ff;
				if(!isroot(y))
					(t[y].ch[0]==x)^(t[z].ch[0]==y)?rotate(x):rotate(y);
				rotate(x);
			}
		}
	int getroot(int x){access(x);Splay(x);while(ls)x=ls;return x;}
	void access(int x){for(int y=0;x;y=x,x=t[x].ff)Splay(x),rs=y,pushup(x);}
	void makeroot(int x){access(x);Splay(x);t[x].rev^=1;}
	void split(int x,int y){makeroot(x);access(y);Splay(y);}
	void cut(int x,int y){split(x,y);t[x].ff=t[y].ch[0]=0;pushup(y);}
	void link(int x,int y){makeroot(x);t[x].ff=y;}
	int Query(int x,int y){split(x,y);return t[y].mx;}
}T;
void Modify(int now,int l,int r,int L,int R,int x)
{
	if(L>R)return;
	if(L<=l&&r<=R){t[now].push_back(x);return;}
	int mid=(l+r)>>1;
	if(L<=mid)Modify(lson,l,mid,L,R,x);
	if(R>mid)Modify(rson,mid+1,r,L,R,x);
}
int SS[MAX<<2],st[MAX<<2];
ll Ans,ans[MAX];int Stop;
void Query(int now,int l,int r)
{
	//Add edge
	int ltop=Stop,mid=(l+r)>>1;
	for(int i=0,l=t[now].size();i<l;++i)
	{
		int p=t[now][i],u=E[p].u,v=E[p].v,w=E[p].w;
		if(T.getroot(u)==T.getroot(v))
		{
			int mx=T.Query(u,v);
			if(T.t[mx].v>w)
			{
				T.cut(E[mx-n].u,mx),T.cut(E[mx-n].v,mx),Ans-=E[mx-n].w;
				SS[++Stop]=mx-n;st[Stop]=1;
			}
			else continue;
		}
		T.link(p+n,u);T.link(p+n,v);Ans+=w;
		SS[++Stop]=p;st[Stop]=-1;
	}
	if(l==r)ans[l]=Ans;
	else Query(lson,l,mid),Query(rson,mid+1,r);
	for(int i=Stop;i>ltop;--i)
		if(st[i]<0)T.cut(SS[i]+n,E[SS[i]].u),T.cut(SS[i]+n,E[SS[i]].v),Ans-=E[SS[i]].w;
		else T.link(SS[i]+n,E[SS[i]].u),T.link(SS[i]+n,E[SS[i]].v),Ans+=E[SS[i]].w;
	Stop=ltop;
}
int pos[MAX],cnt;
int main()
{
	n=read();m=read();Q=read();cnt=m;
	for(int i=1;i<=m;++i)pos[i]=i;
	for(int i=1;i<=m;++i)E[i].u=read(),E[i].v=read(),E[i].w=read(),L[i]=1;
	for(int i=1;i<=Q;++i)
	{
		int k=read(),d=read(),x=pos[k];
		Modify(1,1,Q,L[k],i-1,x);L[k]=i;
		E[++cnt]=E[x];E[cnt].w=d;pos[k]=cnt;
	}
	for(int i=1;i<=cnt;++i)T.t[i+n].v=E[i].w;
	for(int i=1;i<=m;++i)Modify(1,1,Q,L[i],Q,pos[i]);
	Query(1,1,Q);
	for(int i=1;i<=Q;++i)printf("%lld\n",ans[i]);
	return 0;
}

```

---

## 作者：cirnovsky (赞：8)

讲清楚点。

修改边权的 MST，考虑对时间分治。设我们当前操作的操作区间是 $[l,r]$，直接暴力找 MST 是不行的。

考虑找出必要的边和必不要的边。

- 若把 $[l,r]$ 操作中的边边权改成 $+\infty$，拿原图点集和不包含 $[l,r]$ 中边的边集和 $[l,r]$ 中边权修改为 $+\infty$ 后的边的集合的并集作为边集跑 MST，此时如果不在 MST 上的边一定不在最终的 MST 边集中。

- 同理，改成 $-\infty$，此时在 MST 边集里的边一定在最终的 MST 边集中。

这样暴力跑 Kruskal 的规模保证在了 $O(r-l+1)$。

复杂度 $O(n\log_{2}^{2}n)$。

---

## 作者：rainygame (赞：5)

真的很妙的 CDQ 分治，真的是 CDQ 分治入门必刷题！

传统的 CDQ 分治大致的思路是把操作和询问看作一个点对，这样共有 $O(n^2)$ 个点对，然后再用分治去高效地处理点对关系。但是本题并没有这种类似的关系，即**无法单独考虑“一条边的修改对整张图的 MST 的关系”**，这样就比较难做了。

考虑 CDQ 分治的本质是什么，可以发现 CDQ 分治的递归树很像一颗线段树。传统的 CDQ 分治考虑的是线段树左右儿子之间的关系，但这道题可以试着考虑父子之间的关系。设儿子区间的长度为 $k$，**如果在父亲结点的时候将儿子结点处理的信息复杂度变成 $O(k)$ 或 $O(k\log k)$ 的**，就圆满解决问题了。

以下称“静态边”为在分治区间内没有修改的边，这些边权在分治是已经是常量，“动态边”则是在分治区间内修改了的边。那么对于动态边，显然是不好处理的，所以可以考虑简化静态边。观察到以下两种边在儿子都是可以不处理的：

- 对于已经被确定不优的边，即不在静态边集构成的子图的最小生成森林中的边，这些边是一定不可能被选入最小生成树中的，可以提前删掉。
- 对于已经确定会加入的边，如果将动态边边权全部赋为 $-\infin$ 后求一遍最小生成树，发现它们仍在树中，就说明它们是一定在最小生成树中的，可以提前加入，将确定为同一连通块的点缩为一个点。

因为有 $O(k)$ 条动态边，所以此时点数也是 $O(k)$ 的（动态边是用来连通这些点的），和动态边“竞争”的静态边显然也是 $O(k)$ 的，这时跑一遍 kruskal 的复杂度是 $O(k \log n)$ 的，总的复杂度就是 $O(n\log^2 n)$。

这道题的思路建议好好理顺再写代码（可以画一下程序流程图），代码难度也比较高。下面是一些实现的问题：

- 要开两个并查集，一个是维护目前缩点情况的，一个是用于 kruskal 的，两个要注意分开，不要写混了。
- 注意边权以及加入的边回退的问题。
- 记得处理开始时的静态边。
- 分治的思路大概是：先将右儿子的边当作静态边加入，然后处理左儿子，回溯好之后将左儿子的边加入，**并修改相关边权信息**，处理右儿子。
- 分治完毕之后记得回溯，这需要使用可撤销并查集。
- 对于最后 $l=r$ 的区间，**先判断已加入的边是否连通**，如果不连通再将自己修改的边权和可能的一条静态边去 $\min$ 加入答案。

代码（有点乱，可以格式化之后看）：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define MAXN 20005
#define MAXM 50005

int n, m, q, tp, res; int ans[MAXM], fa[MAXN], siz[MAXN], fa2[MAXN], st[MAXN];
struct Edge{int u, v, w;}egs[MAXM], egs2[MAXM]; struct Que{int x, d;}que[MAXM]; set<int> ps, es;

int find(int x){return fa[x] == x ? x : find(fa[x]);}
void merge(int x, int y){
    int fx(find(x)), fy(find(y)); if (fx == fy) return;
    if (siz[fx] > siz[fy]) swap(fx, fy); fa[fx] = fy; siz[fy] += siz[fx]; ps.erase(st[++tp]=fx);
}
void del(int x){for (; tp^x; --tp) siz[fa[st[tp]]]-=siz[st[tp]], fa[st[tp]]=st[tp], ps.insert(st[tp]);}
int find2(int x){return fa2[x] == x ? x : fa2[x] = find2(fa2[x]);}

set<int> kruskal(set<int> es){
    vector<int> vec; for (auto i: es) vec.push_back(i); set<int> res; for (auto i: ps) fa2[i] = i;
    sort(vec.begin(), vec.end(), [](int x, int y){return egs[x].w<egs[y].w;});
    for (auto i: vec){
        int fu(find(egs[i].u)), fv(find(egs[i].v)), w(egs[i].w);
        if (find2(fu) == find2(fv)) continue; fa2[find2(fu)] = find2(fv); res.insert(i);
    }
    return res;
}

void cdq(int l, int r){
    if (l == r){ans[l] = res; if (siz[find(1)] ^ n) ans[l] += min(que[l].d, es.size() ? egs[*es.begin()].w : INT_MAX); return;}
    int mid((l+r)>>1), las(tp), nw(res); set<int> etp(es), yyx, qyy;
    for (int i(l); i<=mid; ++i) yyx.insert(que[i].x); for (int i(mid+1); i<=r; ++i) qyy.insert(que[i].x);
    for (auto i: qyy) if (!yyx.count(i)) es.insert(i); es = kruskal(es);
    set<int> tmp(es); for (auto i: yyx) egs[i].w = INT_MIN, tmp.insert(i); tmp = kruskal(tmp);
    for (auto i: yyx) egs[i].w = egs2[i].w; for (auto i: tmp) if (es.count(i)) es.erase(i), merge(egs[i].u, egs[i].v), res += egs2[i].w;
    cdq(l, mid); del(las); es = etp; res = nw; for (int i(l); i<=mid; ++i) egs[que[i].x].w = egs2[que[i].x].w = que[i].d;
    for (auto i: yyx) if (!qyy.count(i)) es.insert(i); es = kruskal(es);
    tmp = es; for (auto i: qyy) egs[i].w = INT_MIN, tmp.insert(i); tmp = kruskal(tmp);
    for (auto i: qyy) egs[i].w = egs2[i].w; for (auto i: tmp) if (es.count(i)) es.erase(i), merge(egs[i].u, egs[i].v), res += egs2[i].w;
    cdq(mid+1, r); del(las); res = nw;
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);

    cin >> n >> m >> q; for (int i(1); i<=n; ++i) ps.insert(i), fa[i] = i, siz[i] = 1;
    for (int i(1); i<=m; ++i) cin >> egs[i].u >> egs[i].v >> egs[i].w, es.insert(i); memcpy(egs2, egs, sizeof(egs));
    for (int i(1); i<=q; ++i) cin >> que[i].x >> que[i].d, es.erase(que[i].x);
    es = kruskal(es); for (int i(1); i<=q; ++i) egs[que[i].x].w = INT_MIN;
    set<int> tmp(es); for (int i(1); i<=q; ++i) tmp.insert(que[i].x); tmp = kruskal(tmp);
    for (auto i: tmp) if (es.count(i)) es.erase(i), merge(egs[i].u, egs[i].v), res += egs2[i].w;
    for (int i(1); i<=q; ++i) egs[que[i].x].w = egs2[que[i].x].w; cdq(1, q); for (int i(1); i<=q; ++i) cout << ans[i] << '\n';

    return 0;
}
```

---

## 作者：Deep_Kevin (赞：3)

直接写了一发线段树分治+LCT,~~随随便便就~~可以过去.开O2没有输入输出优化跑了2.8s.

具体做法就是将修改边看作是删除原来的边,插入一条新的边,那么一条边在时间上就有一个管理区间,对时间这一维线段树分治,就可以将问题转化为加入一条边到集合内和删除一条边,用LCT来维护最小生成树即可,为了方便我们在LCT上把边看成一个点来计算权值即可.删除一条边相当于撤销操作,怎么加入的就怎么删除.由于对时间线段树分治,所以线段树上的挂着的边数实际上是$4(n+q)\log q$,线段树的常数最大是4,一条边总共进行6遍LCT上的取路径(插入4遍,删除2遍).考虑到LCT的常数大概是树状数组的100倍,所以总的时间复杂度就是:$2400(n+q)\log q\log (n+m)$,~~显然~~可过.
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=20010,M=50010;
struct node{
	int fa,son[2],swp;
	pair<int,int> mmax,val;//pos,value
}s[N+M];
int tf[M],d[M];
pair<int,int> V[M],e[M];//V:time,value e:x,y
vector<pair<int,int> > P[200010];//i,value
int n,m,q;
long long ans=0;

#define ls s[now].son[0]
#define rs s[now].son[1]
void upd(int now){
	s[now].mmax=s[now].val;
	if(s[ls].mmax.second>s[now].mmax.second) s[now].mmax=s[ls].mmax;
	if(s[rs].mmax.second>s[now].mmax.second) s[now].mmax=s[rs].mmax;
}
bool isrt(int now){return s[s[now].fa].son[0]!=now && s[s[now].fa].son[1]!=now;}
void psd(int now){
	if(s[now].swp){
		s[now].swp^=1;s[ls].swp^=1;s[rs].swp^=1;
		swap(s[ls].son[0],s[ls].son[1]);
		swap(s[rs].son[0],s[rs].son[1]);
	}
}
void dfs(int now){if(!isrt(now)) dfs(s[now].fa);psd(now);}

void rotate(int now){
	int f=s[now].fa,ff=s[f].fa;
	int w=s[f].son[1]==now;
	if(!isrt(f)) s[ff].son[s[ff].son[1]==f]=now;s[now].fa=ff;
	s[f].son[w]=s[now].son[1-w];s[s[now].son[1-w]].fa=f;
	s[f].fa=now;s[now].son[1-w]=f;
	upd(f);upd(now);
}

void splay(int now){
	dfs(now);
	while(!isrt(now)){
		int f=s[now].fa,ff=s[f].fa;
		if(!isrt(f)) s[ff].son[1]==f^s[f].son[1]==now?rotate(now):rotate(f);
		rotate(now);
	}
}
void acs(int now){for(int las=0;now;las=now,now=s[now].fa) splay(now),s[now].son[1]=las,upd(now);}
void makert(int now){acs(now);splay(now);s[now].swp^=1;swap(ls,rs);}
void split(int x,int y){makert(x);acs(y);splay(y);}
void link(int x,int y){split(x,y);s[x].fa=y;}
void cut(int x,int y){split(x,y);s[x].fa=s[y].son[0]=0;upd(y);}
int findrt(int x){while(s[x].son[0]) psd(x),x=s[x].son[0];splay(x);return x;}
pair<int,int> gm(int x,int y){
	split(x,y);
	return findrt(y)!=x?make_pair(-1,99999999):(splay(y),s[y].mmax);
}

void ins(int now,pair<int,int> t,int x,int y,int l=1,int r=q){
	if(x==l && y==r){
		P[now].push_back(t);
		return ;
	}
	int mid=(l+r)/2;
	if(y<=mid) ins(now<<1,t,x,y,l,mid);
	else if(mid<x) ins(now<<1|1,t,x,y,mid+1,r);
	else ins(now<<1,t,x,mid,l,mid),ins(now<<1|1,t,mid+1,y,mid+1,r);
}

void del(int k){ans-=d[k];cut(e[k].first,n+k);cut(e[k].second,n+k);}
void add(int k){
	ans+=d[k];s[n+k].mmax=s[n+k].val=make_pair(k,d[k]);
	link(e[k].first,n+k);link(e[k].second,n+k);
}
void erase(int k){
	if(tf[k]){
		del(k);
		if(tf[k]!=-1) add(tf[k]);
		tf[k]=0;
	}
}
void insert(int k){
	pair<int,int> mmax=gm(e[k].first,e[k].second);
	if(mmax.second>d[k]){
		if(mmax.first!=-1) del(mmax.first);
		tf[k]=mmax.first,add(k);
	}
}

void ga(int now,int l=1,int r=q){
	for(int i=0;i<P[now].size();i++) d[P[now][i].first]=P[now][i].second,insert(P[now][i].first);
	if(l==r) printf("%lld\n",ans);
	else{
		int mid=(l+r)/2;
		ga(now<<1,l,mid),ga(now<<1|1,mid+1,r);
	}
	for(int i=P[now].size()-1;i>=0;i--) erase(P[now][i].first);
}

int main(){
	scanf("%d %d %d",&n,&m,&q);
	for(int i=1;i<=n;i++) s[i].mmax=s[i].val=make_pair(0,-1);
	int k,d;
	for(int i=1;i<=m;i++) {
		scanf("%d %d %d",&e[i].first,&e[i].second,&d);
		V[i]=make_pair(1,d);
	}
	for(int i=1;i<=q;i++) {
		scanf("%d %d",&k,&d);
		if(V[k].first<i) ins(1,make_pair(k,V[k].second),V[k].first,i-1);
		V[k]=make_pair(i,d);
	}
	for(int i=1;i<=m;i++) ins(1,make_pair(i,V[i].second),V[i].first,q);
	ga(1);
}
```


---

## 作者：KiDDOwithTopTree (赞：2)

题目在这：[传送门](https://www.luogu.com.cn/problem/P3206)。

根据题意，我们可以知道其实是要求出一个最小生成树。

因为有了边权的修改，其实这是一个动态最小生成树。

因为边权修改不好看，我们可以想想怎么转换：

假设我们有一条从 $x$ 到 $y$ 边权为 $val$ 的边，然后把边权改为 $val^\prime$。那么我们可以把它看成是把从 $x$ 到 $y$ 边权为 $val$ 的边**删去**，再**加入**一条从 $x$ 到 $y$ 边权为 $val^\prime$ 的边。这样我们就把修改边权转为了加边和删边。

如果是只加边的话其实就是 $\text{LCT}$ 求最小生成树的模板，但是多了一个删边的操作就不能这样求最小生成树了。

怎么办呢？线段树分治，你值得拥有。

注意到此题可以离线，那么就可以考虑线段树分治。我们建立一棵线段树来维护时间轴，然后把边从加入到删除这一段时间当做边**存在的时间**，接着把这段存在的时间插入进线段树里，最后遍历一遍线段树计算答案即可。

时复为 $O(m \log q \log n)$，需要晚上吸氧。~~本人用这份代码跑了最劣解。~~

放上代码，一些易错点和计算答案方法都记录在代码注释里了。

```cpp
#include<iostream>
#include<vector>
using namespace std;
const int N=2e4+10,M=5e4+10;
struct node{
	int x,y,z;
	int pos;
	int t;
	node(){
		t=1;
	}
};
struct node1{
	int x,y,z;
	int pos;
};
struct node2{
	int x,y,z;
	int val;
};
struct segment_tree{
	vector<node1> v;
};
struct splay{
	int fa,son[2];
	int maxn,val;
	int pos;
	int rev;
	int x,y;
};
node a[M];//边数
segment_tree smt[4*M];//四倍空间
splay spl[N+2*M];//空间为点数加边数加修改次数
node2 sta[N+2*M];//这个空间我不知道…反正写了这个能对
int top;
long long ans=0;
inline bool check_root(int pos){
	return spl[spl[pos].fa].son[0]!=pos&&spl[spl[pos].fa].son[1]!=pos;
}
inline int relation(int pos,int fa){
	return spl[fa].son[1]==pos;
}
inline void connect(int pos,int fa,int son){
	spl[pos].fa=fa,spl[fa].son[son]=pos;
}
inline void pushup(int pos){
	int ls=spl[pos].son[0],rs=spl[pos].son[1];
	spl[pos].pos=pos,spl[pos].maxn=spl[pos].val;
	if(spl[ls].maxn>spl[pos].maxn){
		spl[pos].maxn=spl[ls].maxn;
		spl[pos].pos=spl[ls].pos;
	}
	if(spl[rs].maxn>spl[pos].maxn){
		spl[pos].maxn=spl[rs].maxn;
		spl[pos].pos=spl[rs].pos;
	}
}
inline void pushdown(int pos){
	if(!spl[pos].rev) return ;
	int ls=spl[pos].son[0],rs=spl[pos].son[1];
	swap(spl[pos].son[0],spl[pos].son[1]);
	spl[ls].rev^=1,spl[rs].rev^=1,spl[pos].rev=0;
}
inline void pushall(int pos){
	if(!check_root(pos)) pushall(spl[pos].fa);
	pushdown(pos);
}
void rotate(int pos){
	int fa=spl[pos].fa,gf=spl[fa].fa;
	int t1=relation(pos,fa),t2=relation(fa,gf);
	connect(spl[pos].son[t1^1],fa,t1);
	connect(fa,pos,t1^1);
	spl[pos].fa=gf;
	if(spl[gf].son[t2]==fa)
		spl[gf].son[t2]=pos;
	pushup(fa),pushup(pos);
}
void splaying(int pos){
	pushall(pos);
	while(!check_root(pos)){
		int fa=spl[pos].fa,gf=spl[fa].fa;
		if(!check_root(fa))
			relation(pos,fa)^relation(fa,gf)?rotate(pos):rotate(fa);
		rotate(pos);
	}
}
void access(int pos){
	int son=0;
	while(pos){
		splaying(pos);
		spl[pos].son[1]=son;
		pushup(pos);
		son=pos,pos=spl[pos].fa;
	}
}
void make_root(int pos){
	access(pos);
	splaying(pos);
	spl[pos].rev^=1;
}
int find_root(int pos){
	access(pos);
	splaying(pos);
	pushdown(pos);
	while(spl[pos].son[0]){
		pos=spl[pos].son[0];
		pushdown(pos);
	}
	splaying(pos);
	return pos;
}
void split(int x,int y){
	make_root(x);
	access(y);
	splaying(y);
}
void link(int x,int y){
	make_root(x);
	spl[x].fa=y;
}
void cut(int x,int y){
	make_root(x);
	access(y);
	splaying(y);
	spl[y].son[0]=spl[x].fa=0;
	pushup(y);
}
bool check(int x,int y){
	make_root(x);
	return find_root(y)==x;
}
//以上为LCT
void ins(int pos,node1 val,int vl,int vr,int l,int r){
	if(vl<=l&&vr>=r){
		smt[pos].v.push_back(val);
		return ;
	}
	int mid=l+r>>1;
	if(vl<=mid) ins(pos<<1,val,vl,vr,l,mid);
	if(vr>mid) ins(pos<<1|1,val,vl,vr,mid+1,r);
}
void solve(int pos,int l,int r){
	int last=top;
	node1 val;
	node2 tmp;
	int len=smt[pos].v.size();
	int x,y,z,p;
	int xx,yy,q;
	for(int i=0;i<len;i++){
		val=smt[pos].v[i];
		x=val.x,y=val.y,z=val.z,p=val.pos;
		if(check(x,y)){//判断是否联通
			splaying(y);
			if(spl[y].maxn<z) continue;//既不link又不cut
			q=spl[y].pos;
			xx=spl[q].x,yy=spl[q].y;
			cut(xx,q),cut(yy,q);//断边
			tmp.x=xx,tmp.y=yy,tmp.z=q,tmp.val=spl[q].val;//记录操作
			sta[++top]=tmp;
			ans-=tmp.val;//把边的贡献删除
		}
		link(x,p),link(p,y);//连边
		tmp.x=x,tmp.y=y,tmp.z=p,tmp.val=-z;//记录操作
		sta[++top]=tmp;
		ans-=tmp.val;//负负得正，加上贡献
	}
	if(l==r){
		if(l!=0)//注意判断，l=0时即为初始状态，此时不用输出
			cout<<ans<<'\n';
	}
	else{//左右分治
		int mid=l+r>>1;
		solve(pos<<1,l,mid);
		solve(pos<<1|1,mid+1,r);
	}
	while(last<top){//撤销操作
		tmp=sta[top--];
		if(tmp.val<0) cut(tmp.x,tmp.z),cut(tmp.y,tmp.z);
		else link(tmp.x,tmp.z),link(tmp.z,tmp.y);
		ans+=tmp.val;
	}
}
//以上为线段树分治部分
int main(){
	int n,m,k;//k为题目的q
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++) spl[i].pos=i;
	int t=n;
//a[i].t初始为0
	for(int i=1;i<=m;i++){
		a[i].pos=++t;
		cin>>a[i].x>>a[i].y>>a[i].z;
		spl[t].x=a[i].x,spl[t].y=a[i].y;//记录下这条边连接的两个点
		spl[t].pos=t,spl[t].maxn=spl[t].val=a[i].z;
	}
	node1 val;
	for(int i=1;i<=k;i++){
		int x,y;
		cin>>x>>y;
		val.pos=a[x].pos;
		a[x].pos=++t;
		val.x=a[x].x,val.y=a[x].y,val.z=a[x].z;
		ins(1,val,a[x].t,i-1,0,k);//上一条边存在的时间没有到i
		a[x].t=i,a[x].z=y;
		spl[t].x=a[x].x,spl[t].y=a[x].y;//记录下这条边连接的两个点
		spl[t].pos=t,spl[t].maxn=spl[t].val=a[x].z;
	}
	for(int i=1;i<=m;i++){//边最后没有删除，那么就算到k时结束
		val.x=a[i].x,val.y=a[i].y,val.z=a[i].z;
		val.pos=a[i].pos;
		ins(1,val,a[i].t,k,0,k);
	}
	solve(1,0,k);//计算结果
}
```

---


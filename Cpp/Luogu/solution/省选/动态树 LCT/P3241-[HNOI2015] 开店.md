# [HNOI2015] 开店

## 题目描述

风见幽香有一个好朋友叫八云紫，她们经常一起看星星看月亮从诗词歌赋谈到人生哲学。最近她们灵机一动，打算在幻想乡开一家小店来做生意赚点钱。

这样的想法当然非常好啦，但是她们也发现她们面临着一个问题，那就是店开在哪里，面向什么样的人群。很神奇的是，幻想乡的地图是一个树形结构，幻想乡一共有 $n$ 个地方，编号为 $1$ 到 $n$，被 $n-1$ 条带权的边连接起来。每个地方都住着一个妖怪，其中第 $i$ 个地方的妖怪年龄是 $x_i$。

妖怪都是些比较喜欢安静的家伙，所以它们并不希望和很多妖怪相邻。所以这个树所有顶点的度数都小于或等于 $3$。妖怪和人一样，兴趣点随着年龄的变化自然就会变化，比如我们的 $18$ 岁少女幽香和八云紫就比较喜欢可爱的东西。幽香通过研究发现，基本上妖怪的兴趣只跟年龄有关，所以幽香打算选择一个地方 $u$（$u$ 为编号），然后在 $u$ 开一家面向年龄在 $L$ 到 $R$ 之间（即年龄大于等于 $L$ 小于等于 $R$）的妖怪的店。

也有可能 $u$ 这个地方离这些妖怪比较远，于是幽香就想要知道所有年龄在 $L$ 到 $R$ 之间的妖怪，到点 $u$ 的距离的和是多少（妖怪到 $u$ 的距离是该妖怪所在地方到 $u$ 的路径上的边的权之和），幽香把这个称为这个开店方案的方便值。

幽香她们还没有决定要把店开在哪里，八云紫倒是准备了很多方案，于是幽香想要知道，对于每个方案，方便值是多少呢。


## 说明/提示

满足 $n\le1.5 \times 10^5,Q\le2 \times 10^5$。对于所有数据，满足 $A\le 10^9$。 

## 样例 #1

### 输入

```
10 10 10
0 0 7 2 1 4 7 7 7 9
1 2 270
2 3 217
1 4 326
2 5 361
4 6 116
3 7 38
1 8 800
6 9 210
7 10 278
8 9 8
2 8 0
9 3 1
8 0 8
4 2 7
9 7 3
4 7 0
2 2 7
3 2 1
2 3 4```

### 输出

```
1603 
957 
7161 
9466 
3232 
5223 
1879 
1669 
1282 
0```

# 题解

## 作者：shadowice1984 (赞：69)

这里是常数极大的动态点分治题解

由于自己主席树不会压缩版本导致了尴尬的mle，然后就滚过去写点分树了

## 前置芝士：动态点分治(点分树)

所谓动态点分治，实际上是一个静态的不能再静态的数据结构——点分树，甚至连数据结构都算不上，只能说是一个log级别的高级暴力，为了避免误会，以下称“动态点分治”这个算法为“点分树”

在学习动态点分治之前，请先出门左转你站模板区AC点分治的模板

你会发现所谓点分治不过是控制了下O(nlogn)暴力的次数而已，我们做了log次O(nlogn)的暴力，于是就得到了O(nlog^2n)的点分治，而点分树其实和点分治的关系不是特别密切了，二者唯一的联系就是点分树通过点分治的函数来建树而已……

点分树的想法是这样的，有的问题我们不是非常关心树的形态特点，比如路径问题，联通块问题，寻找关键点问题等等，以路径问题为例，我们不一定非得查到p,q的lca才可以处理p，q的路径信息，相反，我们可以随便从这个路径上寻找一个分割点G,只要我们可以快速的处理p到G和q到G的信息，我们有些时候就可以处理p到q的信息

所以点分树事实上是对原树做了一种扭曲的映射，使得映射之后满足下列条件

1.原树上任意两点p,q在点分树上的lca一定在p到q的路径上

2.点分树的树高是O(logn)的

因此点分树允许我们进行下面两个在一般树上根本不可能做到的暴力

1.暴力跳father获得某一个点到根节点的路径

2.在每一个点里开一个vector，存储它的孩子的所有信息，空间复杂度是

## $O(\sum size)=O(\sum dep)=O(nlogn)$

然后我们就可以在点分树上开心的使用暴力了~

## 点分树的构建

首先我们根据点分治的过程：找到当前连通块的重心，删去重心，对每个连通块递归子过程这个经典算法来对整棵树做剖分，我们删去重心g之后，从g向各个子联通的重心连边，这样就构成了一颗点分树

可以证明的是，两个点在点分树上的lca一定在原树上这两个点的路径上，但是，点分树除此之外和原树的关系十分的小，尤其是点分树具有这样一条性质，
一个点到它点分树的各个祖先的距离很可能没有任何性质，也就是说我们并不能通过跳点分树上的father的形式来访问一个点到点分树根的信息，因为我们是无法通过累加各个边上边权的方式来计算点到它的点分树祖先的距离的

因此我们存储一个点分树的方式是在一个点开一个vector上存储他到每个祖先的距离以及祖先的编号，这样我们在访问这个节点的所有祖先的时候只需要暴力的扫一遍整个vector就可以获得整个路径上的信息了

另外除了自底向上的访问过程，我们有些时候还需要处理一个点和其他子连通块之间的关系，此时我们可能需要对于每个重心暴力开一个vector处理他的所有子连通块的信息了

总之，点分树的算法思想就是因为反正我是$O(logn)$的树高，因此我可以很多时候使用一些十分暴力的手段，每个点暴力记祖先和孩子，总复杂度还是$O(nlogn)$的

## 所以，点分树事实上是一个精心设计过的暴力

## 本题题解

那么对于这道题来讲我们还是先想一个暴力然后把它放到点分树上去做就可以了

我们仿照一般树上询问一个点到其他所有点距离的方式(当然会有一个非常优美的树剖算法，这个暂且不谈)，我们对整棵树建一个点分树，然后每个节点使用vector记录他到各个祖先节点的距离，那么现在我们要求这个和其他点的距离了

我们想一下一般情况下lca法求树上距离的方案，事实上我们是通过lca这个“分割点”将树上的路径分成了两个我们可以快速处理的部分，即树上深度，但是事实上lca除了这个用途之外它的意义不是很大

换句话来讲，我们可以不使用lca作为分割点，而是使用一些别的点作为分割点，前提是我们必须保证分成的两部分路径我们可以快速处理，那么我们想到了两个点分数上的lca，点分树上的lca一定在这两个点的路径上，而两个点到点分树祖先的距离又可以快速处理，因此我们认为点分树上的lca是一个优秀的分割点

那么仿照一般情况下我们在树上求点p到所有点的距离的算法:枚举lca然后依次算贡献，这需要一个一个的跳链，最坏复杂度$O(n)$，然后我们如果把枚举lca换成枚举点分树的lca，复杂度就成了$O(logn)$的了

那么我们考虑我们需要预处理什么信息呢？，首先每个点开一个vector存储这个点的所有祖先和到所有祖先的距离，因为前面说过点分树上距离并不具有递推性质，所以只能暴力的存，然后每个点开另外一个vector存储所有的子联通块以及子联通块中的点到这个点的距离之和，这样的话我们就处理出了过这个点的两边路径信息了

好了我们现在要询问点p到树上所有点的距离之和了，让我们来简单的描述下算法流程

1.使用点分治算法处理出点分树，然后使用vector存储下刚才的信息

2.暴力的扫一遍点p的祖先vector，对于每一个祖先g，答案+=p到g的距离+p到g的距离×g的不包含p的子联通块siz和+g的不包含p的子联通块中的点到g的距离之和
如果不理解的话可以自己画个图了解一下

好了我们发现刚才算法的关键在于如何求出“g的不包含p的子联通块siz和”以及“g的不包含p的子联通块中的点到g的距离之和”这两个信息

方法1，可以存储和，然后减去p的信息，(这里务必注意不能用g的和减去p的和，仔细回想一下会发现点分树的父子关系其实很弱，所以这两个信息根本没有关系也不能减，必须在g下单独存储每一个子联通块到g的信息)

方法2，如果点度数很小，我们可以暴力扫一遍g的孩子vector，然后跳过含p的子联通块即可，注意如果点的度数在20左右，你的算法复杂度很可能和两个log没啥区别
_____________________

好了我们现在唯一要做的就是给刚才的做法加上点权限制，每个点暴力记录到祖先的距离当然是省不了的，但是我们该如何处理g的子联通块信息呢？

当然你可以把vector换成权值线段树，配合动态开点，空间复杂度应该还是可以控制在一个log上，但是又没有修改干嘛开线段树呢？不嫌烦吗？

所以我们采取一些更加暴力的手段，我们每个点上开3个vector，每个vector存储这个子联通块里的所有点的点权和深度，冷静分析一波会发现这个看似暴力的做法空间复杂度只有$O(nlogn)$

然后把每个vector按点权排序之后处理siz的后缀和和dep的后缀和，在执行刚才算法的时候每枚举一个祖先g就处理一下它的3个vector，不算p的那个vector，然后我们在这个vector上二分出所有合法的点的区间，然后两个后缀和直接相减就可以得出不含p且值域符合要求的点的siz以及不含p且值域符合要求的点的dep之和了

另外为什么是后缀和而不是前缀和？，你会发现前缀和支持的是左开右闭区间，但是我们使用upper\_bound和lower\_bound二分出这左开右闭的区间是十分困难的(需要加一减一之类的还得小心迭代器失效)，相比之下我们二分出左闭右开的区间会容易许多，因此我们就使用后缀和了

说了这么多，其实点分治还是相当小清新的数据结构，代码难度相对树剖+主席树的做法也会小很多……比如这题我大概才写了70行

上代码~

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;const int N=15*1e4+10;typedef long long ll;
int v[2*N];int x[2*N];int ct;int al[N];int val[2*N];bool book[N];bool cut[N];
int siz[N];int w[N];ll dep[N];int tot;int nrt;int miv;ll res;int n;int m;ll A;
struct data//存储节点信息的vector
{
    int val;ll ss;ll sv;
    friend bool operator <(data a,data b){return a.val<b.val;}
};vector <data> ans[N][3];
struct ed{int f;ll dis;int tp;};vector <ed> fa[N];//存储到祖先距离的vector
inline void add(int u,int V,int va){v[++ct]=V;x[ct]=al[u];al[u]=ct;val[ct]=va;}
void dfs1(int u)//寻找siz
{
    book[u]=true;siz[u]=1;
    for(int i=al[u];i;i=x[i]){if(!book[v[i]]&&!cut[v[i]]){dfs1(v[i]);siz[u]+=siz[v[i]];}}
    book[u]=false;
}
void dfs2(int u)//寻找中心
{
    book[u]=true;int mav=tot-siz[u];
    for(int i=al[u];i;i=x[i]){if(!book[v[i]]&&!cut[v[i]]){dfs2(v[i]);mav=max(mav,siz[v[i]]);}}
    book[u]=false;if(miv>mav){miv=mav;nrt=u;}
}
void dfs3(int u,const int& g,const int& t)//处理深度
{
    book[u]=true;fa[u].push_back((ed){g,dep[u],t});
    ans[g][t].push_back((data){w[u],1,dep[u]});
    for(int i=al[u];i;i=x[i]){if(!book[v[i]]&&!cut[v[i]]){dep[v[i]]=dep[u]+val[i];dfs3(v[i],g,t);}}
    book[u]=false;
}
void solve(int u)//点分治构建点分树
{
    dfs1(u);if(siz[u]==1){cut[u]=true;fa[u].push_back((ed){u,0,-1});return;}//边界条件
    tot=siz[u];miv=0x3f3f3f3f;dfs2(u);cut[nrt]=true;fa[nrt].push_back((ed){nrt,0,-1});
    for(int i=al[nrt],t=0;i;i=x[i])
    {
        if(cut[v[i]]){continue;}
        dep[v[i]]=val[i];dfs3(v[i],nrt,t);//预处理vector
        ans[nrt][t].push_back((data){0x3f3f3f3f,0,0});
        sort(ans[nrt][t].begin(),ans[nrt][t].end());//按点权sort
        for(int j=ans[nrt][t].size()-2;j>=0;j--)
        {
            ans[nrt][t][j].ss+=ans[nrt][t][j+1].ss;//处理后缀和
            ans[nrt][t][j].sv+=ans[nrt][t][j+1].sv;
        }t++;
    }for(int i=al[nrt];i;i=x[i]){if(!cut[v[i]]){solve(v[i]);}}//递归点分治
}
inline void query(int l,int r,int u)//暴力跳链，二分出答案
{
    res=0;vector <data>:: iterator L;vector <data>:: iterator R;
    for(int i=fa[u].size()-1;i>=0;i--)
    {
        int f=fa[u][i].f;
        for(int tp=0;tp<=2;tp++)
        {
            if(tp==fa[u][i].tp||ans[f][tp].empty()){continue;}
            L=lower_bound(ans[f][tp].begin(),ans[f][tp].end(),(data){l,0,0});//使用upper和lower_bound可以轻易的二分出一个左闭右开的边界
            R=upper_bound(ans[f][tp].begin(),ans[f][tp].end(),(data){r,0,0});
            res+=fa[u][i].dis*(L->ss-R->ss)+L->sv-R->sv;//处理这个重心的贡献
        }if(l<=w[f]&&w[f]<=r){res+=fa[u][i].dis;}//特判一下这个点到中心的距离
    }
}
int main()
{
    scanf("%d%d%lld",&n,&m,&A);
    for(int i=1;i<=n;i++){scanf("%d",&w[i]);}
    for(int i=1,u,v,c;i<n;i++){scanf("%d%d%d",&u,&v,&c);add(u,v,c);add(v,u,c);}
    solve(1);//点分治
    for(int i=1;i<=m;i++)
    {
        int u;ll l;ll r;scanf("%d%lld%lld",&u,&l,&r);
        (l+=res)%=A;(r+=res)%=A;if(l>r)swap(l,r);
        query(l,r,u);printf("%lld\n",res);//处理答案
    }return 0;//拜拜程序~
}

```




---

## 作者：Ameyax (赞：31)

据说正解是动态点分治，但是树剖+主席树跑的更快？？

考虑一个简化的问题：每次询问树上所有点到点$u$的距离之和。

记点$i$到根节点的距离是$dis_i$

通过画图可以发现$ans=\sum_{i=1}^ndis_i+n\times dis_u-2\times\sum_{i=1}^ndis_{lca(i,u)}$

前两项很好解决，关键是快速计算$\sum_{i=1}^ndis_{lca(i,u)}$

可以用树链剖分，对于每个点，都向上走到根，记录每条路经过的次数，询问时从$u$向上跳，每次加边权$\times$覆盖次数即可。

现在要计算点权在$[L,R]$内的点到点$u$的距离，用可持久化线段树即可。

把点权排序，离散化，按点权从小到大插入，询问时和序列的处理一样$[1,R]-[1,L]$。

另外主席树的区间修改要打永久标记，否则会有新建很多节点，空间可能开不下。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX_N = 150010;
const int MAX_M = 300010;
const int MAX_T = 10000010;
const int inf = INT_MAX;
#define LL long long
#define rep(i, u) for (int i = fir[u]; i; i = e[i].nxt)
int read()
{
    int x = 0, f = 1; char ch = getchar();
    while (ch > '9' || ch < '0') { if (ch == '-') f = -1; ch = getchar(); }
    while (ch <= '9' && ch >= '0') { x = x * 10 + ch - '0'; ch = getchar(); }
    return x * f;
}
struct Edge
{
    int to, nxt, w;
} e[MAX_M];
struct Monster
{
    int age, id;
    friend bool operator < (Monster x, Monster y)
    {
        return x.age != y.age ? x.age < y.age : x.id < y.id;
    }
} mon[MAX_N];
int n, m, mod, cnt, cnt2, root[MAX_M], _, fir[MAX_N], last[MAX_N];
int siz[MAX_N], pos[MAX_N], top[MAX_N], fa[MAX_N];
LL ans, dis[MAX_N], sumdis[MAX_N], sumE[MAX_N];
void add(int u, int v, int w)
{
    e[++cnt] = (Edge) { v, fir[u], w }; fir[u] = cnt;
    e[++cnt] = (Edge) { u, fir[v], w }; fir[v] = cnt;
}
class SGT
{
private:
    int cnt;
    LL sum[MAX_T];
    int ls[MAX_T], rs[MAX_T], tim[MAX_T];
public:
    int update(int pre, int l, int r, int L, int R)
    {
        int root_ = ++cnt, mid = (l + r) >> 1;
        ls[root_] = ls[pre]; rs[root_] = rs[pre];
        sum[root_] = sum[pre]; tim[root_] = tim[pre];
        if (l == L && R == r) { tim[root_] ++; return root_; }
        sum[root_] += (sumE[R] - sumE[L - 1]);
        if (R <= mid) ls[root_] = update(ls[root_], l, mid, L, R);
        else if (L > mid) rs[root_] = update(rs[root_], mid + 1, r, L, R);
        else ls[root_] = update(ls[root_], l, mid, L, mid),
             rs[root_] = update(rs[root_], mid + 1, r, mid + 1, R);
        return root_;
    }
    LL query(int root_, int l, int r, int L, int R)
    {
        LL re = 1LL * (sumE[R] - sumE[L - 1]) * tim[root_];
        if (l == L && R == r) { return re + sum[root_]; }
        int mid = (l + r) >> 1;
        if (R <= mid) return re + query(ls[root_], l, mid, L, R);
        else if (L > mid) return re + query(rs[root_], mid + 1, r, L, R);
        else return re + query(ls[root_], l, mid, L, mid) + query(rs[root_], mid + 1, r, mid + 1, R);
    }
} T;
void dfs1(int u)
{
    siz[u] = 1;
    rep(i, u)
    {
        int v = e[i].to;
        if (v == fa[u]) continue;
        fa[v] = u; dis[v] = dis[u] + e[i].w;
        last[v] = e[i].w;
        dfs1(v); siz[u] += siz[v];
    }
}
void dfs2(int u, int top_)
{
    top[u] = top_; pos[u] = ++cnt2;
    sumE[pos[u]] = last[u];
    int big = 0;
    rep(i, u) if (siz[e[i].to] > siz[big] && e[i].to != fa[u]) big = e[i].to;
    if (!big) return ;
    dfs2(big, top_);
    rep(i, u) if (e[i].to != fa[u] && e[i].to != big) dfs2(e[i].to, e[i].to);
}
int modify(int x)
{
    while (top[x] != 1)
    {
        _ = T.update(_, 1, n, pos[top[x]], pos[x]);
        x = fa[top[x]];
    }
    return _ = T.update(_, 1, n, 1, pos[x]);
}
LL query(int root_, int x)
{
    LL re = 0;
    while (top[x] != 1)
    {
        re += T.query(root_, 1, n, pos[top[x]], pos[x]);
        x = fa[top[x]];
    }
    return re + T.query(root_, 1, n, 1, pos[x]);
}
int main()
{
    n = read(); m = read(); mod = read();
    for (int i = 1; i <= n; i++)
        mon[i].age = read(), mon[i].id = i;
    sort(mon + 1, mon + n + 1);
    for (int i = 1; i < n; i++)
    {
        int u = read(), v = read(), w = read();
        add(u, v, w);
    }
    dfs1(1); dfs2(1, 1);
    for (int i = 1; i <= n; i++)
        sumE[i] += sumE[i - 1], sumdis[i] = sumdis[i - 1] + dis[mon[i].id];
    for (int i = 1; i <= n; i++) root[i] = modify(mon[i].id);
    for (int i = 1; i <= m; i++)
    {
        int u = read(), a = read(), b = read();
        a = (1LL * a + ans) % mod;
        b = (1LL * b + ans) % mod;
        if (a > b) swap(a, b);
        a = lower_bound(mon + 1, mon + n + 1, (Monster) { a, 0 }) - mon;
        b = upper_bound(mon + 1, mon + n + 1, (Monster) { b, 1e9 }) - mon - 1;
        ans = 1LL * (b - a + 1) * dis[u] + sumdis[b] - sumdis[a - 1]
              - 2LL * (query(root[b], u) - query(root[a - 1], u));
        printf("%lld\n", ans);
    }
    return 0;
}
```

---

## 作者：liuzhaoxu (赞：29)

### 点分树小结

点分树的题其实就是把点分治的询问点换成某几个点，询问换成多组，有时还会带修改，那么我们会发现，每次如果做点分治，找重心的过程都是一样的，所以我们先处理出所有的重心，将其分成不同的层数，将所有重心逐层连起来，避免重复找重心，从而进行修改信息或回答多组询问

两个关键的性质：

+ 点分树最大深度是$log$级别的

+ 点分树上两点的$lca$在原树上两点之间的路径上

因此我们可以利用这两个强力的性质，在点分树上用比较暴力的方法解决路径统计问题。

### 对于这道题

+ 首先假设没有$l,r$的限制，询问某个点到其他所有点的距离之和，我们用点分树去做该如何做。

便于理解，设三个数组

$sum[0][x]$表示点分树上$x$子树的所有点到**x**的距离和

$sum[1][x]$表示点分树上$x$子树的所有点到**x点分树上父亲**的距离和

$siz[x]$表示点分树上$x$子树大小

显然对于询问的点$x$，我们跳点分树上的父亲即可，初始时$ans$设为$sum[0][x]$，也就是点分树$x$子树下方的贡献和

跳点分树父亲时，当前跳到点$now$（点$now$要有父亲），$ans += sum[0][fa[now]] - sum[1][now] + (siz[fa[now]] - siz[now]) * Dis(x, fa[now])$

这是在跳的过程中加上$x$上方的贡献。

$sum[0][fa[now]] - sum[1][now]$是$fa$的除掉$now$的子树的点到$fa$的距离和，然而这些贡献还少一段，就是$fa$到$x$之间的一段，所以要加上后面的那部分。

解释一下那两个减法，其实都是除掉已经处理过的子树，$siz$可以做减法减去重复计算的，比较简单，注意$sum$需要开两个数组，$sum[0][fa[now]] - sum[1][now]$不能写成$sum[0][fa[now]] - sum[0][now]$，其实挺显然的，因为这两个数组的对象不同，第一种写法的两个数组全是到$fa$的距离和，而第二种写法是到$fa$和到$now$的距离和，所以不能用第二种方法去重

+ 现在有了$l,r$的限制

其实就是再加一维（存成$vector$），存上子树中各点的信息就好了，按照年龄排序，距离做个前缀和，然后询问$l,r$也就相当于$[0,r] - [0,l-1]$，二分出$vector$中$l-1,r$的位置即可。因为点分树每层节点的$vector$元素总和是$n$，共$log$层，所以空间$nlogn$，可以接受

然后还有个小优化，$siz$其实不用单独存个$vector$，用二分后$sum$的$vector$的下标之差就能算出$siz$，另外我点分树一直写树剖$lca$，感觉比$ST$表预处理要快一点

+ 总结：其实最主要的就是那个式子，初始$ans = sum[0][x]$, 点分树跳父亲时，$ans += sum[0][fa[now]] - sum[1][now] + (siz[fa[now]] - siz[now]) * Dis(x, fa[now])$，其他的都是套路了

### 代码

```cpp
#include <cmath>
#include <ctime>
#include <vector>
#include <cctype>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define rint register int
using namespace std;
typedef long long ll;

const int maxn = 1.5e5 + 10;
const int inf = 0x3f3f3f3f;
int n, q, A, maxsiz, tsiz, rt, cnt, head[maxn], v[maxn], Fa[maxn];
int dep[maxn], dis[maxn], siz[maxn], son[maxn], top[maxn], fa[maxn];
bool vis[maxn];
ll lastans;

struct Edge {
	int to, nxt, val;
}e[maxn << 1];

struct Node {
	int v; ll sum;
	bool operator < (const Node &B) const {
		return v < B.v;
	}
};
vector < Node > vec[2][maxn];

template <typename T> T read(register T x = 0, register bool f = 0, register char ch = getchar()) {
	for(;!isdigit(ch);ch = getchar()) f = ch == '-';
	for(; isdigit(ch);ch = getchar()) x = (x << 3) + (x << 1) + (ch & 15);
	return f ? -x : x ;
}

void add(rint x, rint y, rint z) {
	e[++cnt] = (Edge){y, head[x], z}, head[x] = cnt;
}

void dfs1(rint x, rint prt) {
	fa[x] = prt, dep[x] = dep[prt] + 1, siz[x] = 1;
	for(rint i = head[x], y;i;i = e[i].nxt) {
		if((y = e[i].to) == prt) continue;
		dis[y] = dis[x] + e[i].val;
		dfs1(y, x);
		siz[x] += siz[y];
		if(!son[x] || siz[y] > siz[son[x]]) son[x] = y;
	}
}

void dfs2(rint x, rint tp) {
	top[x] = tp;
	if(son[x]) dfs2(son[x], tp);
	for(rint i = head[x], y;i;i = e[i].nxt) {
		if((y = e[i].to) != fa[x] && y != son[x]) dfs2(y, y);
	}
}

int Dis(rint a, rint b) {
	rint x = a, y = b;
	while(top[x] != top[y]) {
		if(dep[top[x]] < dep[top[y]]) swap(x, y);
		x = fa[top[x]];
	}
	x = dep[x] < dep[y] ? x : y;
	return dis[a] + dis[b] - dis[x] * 2;
}

void getrt(rint x, rint prt) {
	siz[x] = 1;
	rint maxs = 0;
	for(rint i = head[x], y;i;i = e[i].nxt) {
		if(vis[y = e[i].to] || y == prt) continue;
		getrt(y, x);
		siz[x] += siz[y];
		maxs = max(maxs, siz[y]);
	}
	maxs = max(maxs, tsiz - siz[x]);
	if(maxs < maxsiz) maxsiz = maxs, rt = x;
}

void dfs(rint x, rint prt, rint sum) {
	siz[x] = 1;
	vec[0][rt].push_back((Node){v[x], sum});
	if(Fa[rt]) vec[1][rt].push_back((Node){v[x], Dis(x, Fa[rt])});
	for(rint i = head[x], y;i;i = e[i].nxt) {
		if(vis[y = e[i].to] || y == prt) continue;
		dfs(y, x, sum + e[i].val);
		siz[x] += siz[y];
	}
}

void solve(rint x) {
	vis[x] = 1, dfs(x, 0, 0);
	for(rint i = head[x], y;i;i = e[i].nxt) {
		if(vis[y = e[i].to]) continue;
		tsiz = siz[y], maxsiz = inf, getrt(y, x);
		Fa[rt] = x;
		solve(rt);
	}
}

ll query(rint opt, rint x, rint l, rint r, ll &ss) {
	rint lef = lower_bound(vec[opt][x].begin(), vec[opt][x].end(), (Node){l, 0}) - vec[opt][x].begin() - 1;
	rint rig = upper_bound(vec[opt][x].begin(), vec[opt][x].end(), (Node){r, 0}) - vec[opt][x].begin() - 1;
	ss = rig - lef;
	ll ans = 0;
	if(rig >= 0 && rig < (int) vec[opt][x].size()) ans += vec[opt][x][rig].sum;
	if(lef >= 0 && lef < (int) vec[opt][x].size()) ans -= vec[opt][x][lef].sum;
	return ans;
}

int main() {
	n = read<int>(), q = read<int>(), A = read<int>();
	for(rint i = 1;i <= n; ++i) v[i] = read<int>();
	for(rint i = 1, x, y, z;i < n; ++i) {
		x = read<int>(), y = read<int>(), z = read<int>();
		add(x, y, z), add(y, x, z);
	}
	dfs1(1, 0), dfs2(1, 1);
	tsiz = n, maxsiz = inf, getrt(1, 0), solve(rt);
	for(rint i = 1;i <= n; ++i) {
		sort(vec[0][i].begin(), vec[0][i].end());
		sort(vec[1][i].begin(), vec[1][i].end());
		for(rint j = 1;j < (int)vec[0][i].size(); ++j) vec[0][i][j].sum += vec[0][i][j - 1].sum;
		for(rint j = 1;j < (int)vec[1][i].size(); ++j) vec[1][i][j].sum += vec[1][i][j - 1].sum;
	}
	for(rint i = 1, x, l, r;i <= q; ++i) {
		x = read<int>(), l = (read<ll>() + lastans) % A, r = (read<ll>() + lastans) % A;
		l > r ? swap(l, r) : void();
		ll s1, s2;
		lastans = query(0, x, l, r, s1);
		for(rint now = x;Fa[now];now = Fa[now]) {
			lastans += query(0, Fa[now], l, r, s2) - query(1, now, l, r, s1);
			lastans += (s2 - s1) * Dis(x, Fa[now]);
		}
		printf("%lld\n", lastans);
	}
	return 0;
}
```

---

## 作者：hychyc (赞：12)

## 题目描述
题目大意：给定一颗$n(n\leq150000)$个点的树，每个点有点权，边有边权（表示两个点之间的距离）。$q(q\leq200000)$次询问，每次询问点权在$[L, R]$之间的所有点到某个点的距离之和。强制在线。

## 分析
首先考虑一个简化的版本，询问所有点到点$u$的距离和。尝试进行公式推导。
令$dep[i], size[i]$分别表示以$1$为根时第$i$个点的深度和子树大小。观察$1$为根和$u$为根会发生哪些变化。

$u$的子树中某节点$v$的深度会从$dep[v]$变成$dep[v]-dep[u]$，相当于都减少了$dep[u]$，且有$size[u]个点发生了此变化$；$fa[u]$的子树，且不是$u$的子树中的某节点$v$，深度会从$dep[v]$变成$dep[v]-dep[fa[u]]+dep[u]-dep[fa[u]]$，相当于减少了$2dep[fa[u]]-dep[u]$，且有$size[fa[u]]-size[u]$个点发生了此变化，以此类推。

更具体的描述，定义$a_{i}$为$1$至$u$的链上的第$i$个点，$1$至$u$的链上共有$k$个点，那么所有点到$u$的距离之和可以用如下式子表示：
$\sum_{i=1}^{n}dep[i] - \sum_{i=1}^{k-1}(size[a_{i}]-size[a_{i+1}])*(2*dep[a_{i}]-dep[u])-size[u]*dep[u]$

展开可得：
$\sum_{i=1}^{n}dep[i]- size[u]*dep[u]-$
$(2*\sum_{i=1}^{k-1}size[a_{i}]*dep[a_{i}]-$ $2*\sum_{i=1}^{k-1}size[a_{i+1}]*dep[a_{i}]-$ $\sum_{i=1}^{k-1}size[a_{i}]*dep[u]+$  $\sum_{i=1}^{k-1}size[a_{i+1}]*dep[u])$

$=\sum_{i=1}^{n}dep[i]- size[u]*dep[u]-$
$2*\sum_{i=1}^{k-1}size[a_{i}]*dep[a_{i}]+$ $2*\sum_{i=1}^{k-1}size[a_{i+1}]*dep[a_{i}]+$ $\sum_{i=1}^{k-1}size[a_{i}]*dep[u]$ $\sum_{i=1}^{k-1}size[a_{i+1}]*dep[u])$

其中 
$\sum_{i=1}^{k-1}size[a_{i}]*dep[u]-\sum_{i=1}^{k-1}size[a_{i+1}]*dep[u] $
$= \sum_{i=1}^{k-1}size[a_{i}]*dep[u]-\sum_{i=2}^{k}size[a_{i}]*dep[u]$
$ = size[a_{1}]*dep[u] -size[a_{k}]*dep[u]= n*dep[u]-size[u]*dep[u]$

于是原式变为
$\sum_{i=1}^{n}dep[i] +n*dep[u]-2*size[u]*dep[u] $
$- 2*\sum_{i=1}^{k-1}size[a_{i}]*dep[a_{i}]+2*\sum_{i=1}^{k-1}size[a_{i+1}]*dep[a_{i}]$

现在观察
$- 2*\sum_{i=1}^{k-1}size[a_{i}]*dep[a_{i}]+2*\sum_{i=1}^{k-1}size[a_{i+1}]*dep[a_{i}] $
$= 2*\sum_{i=1}^{k-1}size[a_{i+1}]*dep[a_{i}]- 2*\sum_{i=1}^{k-1}size[a_{i}]*dep[a_{i}]$

直接相减出现的$size[a_{i}]-size[a_{i+1}]$难以处理，我们考虑进行一次错位

原式$=2*\sum_{i=2}^{k}size[a_{i}]*dep[a_{i-1}]- 2*\sum_{i=1}^{k-1}size[a_{i}]*dep[a_{i}]$
$=2*\sum_{i=2}^{k}size[a_{i}]*dep[a_{i-1}]- 2*\sum_{i=2}^{k-1}size[a_{i}]*dep[a_{i}] (dep[a_{1}]=dep[1]=0)$
$=2*size[a_{k}]*dep[a_{k-1}] + 2*\sum_{i=2}^{k-1}size[a_{i}]*(dep[a_{i-1}]-dep[a_{i}])$

将原式中的$-2*size[u]*dep[u]$并入上式中，得到：
$2*size[a_{k}]*dep[a_{k-1}] -2*size[a_{k}]*dep[a_k]$
$+ 2*\sum_{i=2}^{k-1}size[a_{i}]*(dep[a_{i-1}]-dep[a_{i}])$
$=2*\sum_{i=2}^{k}size[a_{i}]*(dep[a_{i-1}]-dep[a_{i}])$

注意到$dep[a_i]-dep[a_{i-1}]$是点 $i$ 到其父节点的边权，定义为$fv[i]$
故原式等于
$\sum_{i=1}^{n}dep[i] +n*dep[u]-2*\sum_{i=2}^{k}size[a_{i}]*fv[a_i]$
可以进行维护

现在考虑如何加入$[L, R]$的限制。直接通过子树查询的方式进行，单次复杂度与树高约为线性关系，不可以接受。这时便要体会主席树的版本作用。
将点按照点权排序，一个一个加入，最终答案便是$R$对应版本的主席树的答案减去$L$个对应版本的前一个版本的主席树的答案。

每次加入一个点的时候，树的形态不发生变化，$fv[i]$不发生变化，只有$size[i]$发生变化。只需把加入的这个点到根的路径上的所有点的$size$进行$+1$即可，查询时从当前指定的点出发，向上统计$\sum size[i]*fv[i]$。这是可以通过树链剖分维护的。由于空间限制，标记永久化是一个不错的选择。

## 思路总结
对主席树的认识不要僵化，体会其有关版本的作用。例如对于区间$[l, r]$统计在$[L, R]$之间的数的个数问题，其实也可以按照数值排序后一个个插入点，统计第$R$个版本的树中位置是$[l, r]$的有多少，减去第$L-1$颗树的答案。不同版本不一定是按照位置，也不一定是按照权值（虽然我目前就见过这俩），思路要灵活。

## 代码

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <bits/stdc++.h>
#define MAXN 200050
#define ri register int
#define il inline
using namespace std;
typedef long long LL;
int n, q, A, ecnt, numcnt, root[MAXN], rtcnt, num[MAXN];
int tcnt, top[MAXN], id[MAXN], fa[MAXN], fv[MAXN], son[MAXN], size[MAXN];
LL lastans, dsum[MAXN], dep[MAXN];
struct Node {
    int id, ag;
    bool operator < (const Node &x) const {
        if(ag == x.ag) return id < x.id;
        return ag < x.ag;
    }
}mon[MAXN];
struct node {
    int v, w;
    node *next;
}pool[MAXN<<2], *h[MAXN];
struct NODE {
    int ls, rs, lazy;
    LL sum, esum;
    void init() {
        ls = rs = lazy = 0, esum = sum = 0;
    }
}t[MAXN<<7];
il void adde(int u, int v, int w) {
    node *p = &pool[ecnt++], *q = &pool[ecnt++];
    *p = node {v, w, h[u]}, h[u] = p;
    *q = node {u, w, h[v]}, h[v] = q;
}
void dfs1(int u) {
    size[u] = 1;
    for(node *p = h[u]; p; p = p->next) {
        if(p->v == fa[u]) continue;
        dep[p->v] = dep[u]+p->w, fa[p->v] = u, fv[p->v] = p->w, dfs1(p->v), size[u] += size[p->v];
        if(size[p->v] > size[son[u]]) son[u] = p->v;
    }
}
void dfs2(int u, int t) {
    id[u] = ++tcnt, top[u] = t, num[tcnt] = fv[u];
    if(!son[u]) return ;
    dfs2(son[u], t);
    for(node *p = h[u]; p; p = p->next) 
        if(!id[p->v]) dfs2(p->v, p->v);
}
void build(int &u, int l, int r) {
    int tmp = u; u = ++rtcnt, t[u] = t[tmp];
    if(l == r) return (void)(t[u].esum = num[l]);
    int mid = (l+r)>>1;
    build(t[u].ls, l, mid);
    build(t[u].rs, mid+1, r);
    t[u].esum = t[t[u].ls].esum + t[t[u].rs].esum;
}
void change(int &u, int l, int r, int tl, int tr) {
    int tmp = u; u = ++rtcnt, t[u] = t[tmp];
    if(tl <= l && r <= tr) {
        ++t[u].lazy;
        t[u].sum += t[u].esum;
        return ;
    }
    int mid = (l+r)>>1;
    if(tl <= mid) change(t[u].ls, l, mid, tl, tr);
    if(mid < tr) change(t[u].rs, mid+1, r, tl, tr);
    t[u].sum = t[t[u].ls].sum + t[t[u].rs].sum + t[u].esum*t[u].lazy;
}
void Change(int u, int ver) {
    while(top[u] != 1) {
        change(root[ver], 1, n, id[top[u]], id[u]);
        u = fa[top[u]];
    }
    change(root[ver], 1, n, 1, id[u]);
}
LL query(int u, int l, int r, int tl, int tr, int add) {
    if(tl <= l && r <= tr) return t[u].sum + t[u].esum*add;
    int mid = (l+r)>>1; LL ret = 0;
    add += t[u].lazy;
    if(tl <= mid) ret += query(t[u].ls, l, mid, tl, tr, add);
    if(mid < tr) ret += query(t[u].rs, mid+1, r, tl, tr, add);
    return ret;
}
LL Query(int u, int ver) {
    LL ret = 0;
    while(top[u] != 1) {
        ret += query(root[ver], 1, n, id[top[u]], id[u], 0);
        u = fa[top[u]];
    }
    ret += query(root[ver], 1, n, 1, id[u], 0);
    return ret;
}
il LL calc(int u, int ver) {
    return dsum[ver] + ver*dep[u] - 2*Query(u, ver);
}
int main() {
    int u, v, c;
    scanf("%d%d%d", &n, &q, &A);
    for(ri i = 1; i <= n; ++i) scanf("%d", &mon[i].ag), mon[i].id = i;
    for(ri i = 1; i < n; ++i) scanf("%d%d%d", &u, &v, &c), adde(u, v, c);
    dfs1(1), dfs2(1, 1);
    sort(mon+1, mon+n+1);
    build(root[0], 1, n);
    for(ri i = 1; i <= n; ++i) 
        dsum[i] = dsum[i-1] + dep[mon[i].id], 
        root[i] = root[i-1], Change(mon[i].id, i);
    while(q--) {
        LL l, r; int L, R;
        scanf("%d%lld%lld", &u, &l, &r);
        l += lastans, r += lastans;
        L = min(l%A, r%A), R = max(l%A, r%A);
        L = lower_bound(mon+1, mon+n+1, Node{0, L})-mon, R = upper_bound(mon+1, mon+n+1, Node{MAXN, R})-mon-1;
        printf("%lld\n", lastans = calc(u, R)-calc(u, L-1));
    }
    return 0;
}
```

---

## 作者：Max_QAQ (赞：6)

先贴个传送门[P3241](https://www.luogu.com.cn/problem/P3241)。

点分树好题。

有大量的询问同时每次询问的树都一样，题目还强制在线，所以可以考虑用**点分树**。

先转化一下问题，对于每一次询问,

相当与问所有年龄在 $[L,R]$ 之间的点到 $u$ 这个点的距离之和。

若考虑单次的询问可以用点分治，

而又因为每次询问的树都一样，所以每次选择的重心都一样，

这样就可以考虑用点分树来做了。

可以通过一次预处理，将每次选择的重心都处理出来。

再看单次询问，对于 $u$ 这个点，

其他所有对他有贡献的点 ，

会在同一重心其他子树中，

或者在同一重心的和 $u$ 这个点相同的子树。

对于第一部分，我们可以归并的去做。

其他子树里的点到 $u$ 这个点的距离可以分成两种，

一种是从子树到重心，另一种是从重心到 $u$，

要处理这两种情况我们需要将每个子树里所有点的信息都存到每个重心里。

根据题目的性质最多 $3$ 颗子树，所以在记录儿子子树的信息时要开个 $3$ 。

**然后根据年龄来排个序**。

对于第一种情况，

可以用**前缀和**来统计到重心的长度，

然后每次问的就是一个区间和，

可以考虑**二分**寻找边界然后 $O(1)$ 计算，

所以每次计算就是 $O(log\ n)$ 的复杂度。

另一种情况就是重心到 $u$ 这个点的距离乘上所有年龄为 $[L,R]$ 的点的数量。

然后再**二分**查找两个边界 相减求得数量，

也是 $O(log\ n)$ 的复杂度，

这样每次询问就是 $O(log\ n)$ 的复杂度。

对于第二种部分，我们可以递归的去处理，

每递归一层就再次分类，分成两部分，

直到 $u$ 为重心为止。

分析一下时间复杂度，最多有$O(log\ n)$ 层，

每层都会进行一次排序，所以总的**复杂度**为$O(nlog^2\ n)$。

然后就完了，剩下的贴个代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
int n,m,A;
long long ans;
int age[150010];
int head[150010],ver[300010],to[300010],edge[300010],tot;
bool vis[150010];
struct Father{int u,num;long long dis;};
vector<Father> fa[150010];//记录当前点Father的信息
struct Son{int age;long long dis;inline bool operator<(const Son& a)const{return age<a.age;}};
vector<Son> son[150010][3];//最多三颗子树所以第二维为3
                           //记录子树信息
inline void add(int x,int y,int z){
	ver[++tot]=y;
	edge[tot]=z;
	to[tot]=head[x];
	head[x]=tot;
}
inline int getsiz(int x,int fa){//求子树的大小 返回值就是大小
	if(vis[x]) return 0;int res=1;
	for(int i=head[x];i;i=to[i]){
		int y=ver[i];
		if(y==fa||vis[y]) continue;
		res+=getsiz(y,x);
	}
	return res;
}
inline int getrt(int x,int fa,int tot,int &rt){//求重心 返回值也是子树大小
	if(vis[x]) return 0;                   //tot为总点数 重心为rt
	int S=1,mx=0;                          //S为当前子树大小 mx为剩余联通块最大值
	for(int i=head[x];i;i=to[i]){
		int y=ver[i];
		if(y==fa||vis[y]) continue;
		int t=getrt(y,x,tot,rt);//子树大小
		mx=max(mx,t);
		S+=t;
	}
	mx=max(mx,tot-S);
	if(mx<=tot/2) rt=x;//这里只要保证<=tot/2就行
	return S;          //因为我们主要保证时间复杂度就行 不一定一定是重心
}
inline void getdis(int x,int fath,long long dis,int rt,int k,vector<Son>& p){
//遍历子树求距离
//x为目前的点 fath为父亲 dis为目前的距离 rt 和 k 表示 他是rt的第k个子树 我们要把信息存到p这个vector里
	if(vis[x]) return;
	fa[x].push_back({rt,k,dis,});//存入信息
	p.push_back({age[x],dis});   //存入信息
	for(int i=head[x];i;i=to[i]){
		int y=ver[i];
		if(y==fath||vis[y]) continue;
		getdis(y,x,dis+edge[i],rt,k,p);
	}
}
inline void build(int x){
	if(vis[x]) return ;
	getrt(x,0,getsiz(x,0),x);
	vis[x]=1;
	for(int i=head[x],k=0;i;i=to[i],k++){
		int y=ver[i];
		if(vis[y]) continue;
		auto& p=son[x][k];
		p.push_back({-1,0});p.push_back({A+1,0});//插入哨兵方便求值
		getdis(y,0,edge[i],x,k,p);
		sort(p.begin(),p.end());
		for(int i=1;i<p.size();i++) p[i].dis+=p[i-1].dis;
	}
	for(int i=head[x];i;i=to[i]) build(ver[i]);
}
inline long long query(int x,int l,int r){//查询每次询问
	long long res=0;
	for(auto& t: fa[x]){     //枚举x的每个父节点
		int Age=age[t.u];//特判重心的值
		if(Age>=l&&Age<=r) res+=t.dis;
		for(int i=0;i<3;i++){
			if(i==t.num) continue;//如果枚举到了同子树的就跳过
			auto& p=son[t.u][i];
			if(p.empty()) continue;//为空也跳过
			int a=lower_bound(p.begin(),p.end(),Son({l,-1}))-p.begin();
			int b=lower_bound(p.begin(),p.end(),Son({r+1,-1}))-p.begin();
			res+=t.dis*(b-a)+p[b-1].dis-p[a-1].dis;//一共两部分上面提到了
		}
	}
	for(int i=0;i<3;i++){//找x为重心时和儿子节点之间的距离
		 auto& p=son[x][i];
		if(p.empty()) continue;
		int a=lower_bound(p.begin(),p.end(),Son({l,-1}))-p.begin();
		int b=lower_bound(p.begin(),p.end(),Son({r+1,-1}))-p.begin();
		res+=p[b-1].dis-p[a-1].dis;//下面的只用管第二部分
	}
	return res;
}
int main(){
	n=read(),m=read(),A=read();
	for(int i=1;i<=n;i++) age[i]=read();
	for(int i=1,x,y,z;i<=n-1;i++){
		x=read(),y=read(),z=read();
		add(x,y,z);add(y,x,z);
	}build(1);
	for(int i=1,u,a,b,l,r;i<=m;i++){
		u=read(),a=read(),b=read();
		l=(a+ans)%A,r=(b+ans)%A;
		if(l>r) swap(l,r);
		ans=query(u,l,r);
		printf("%lld\n",ans);
	}
	return 0;//再见~~~
}
```

---

## 作者：bztMinamoto (赞：6)

打广告：[blog](https://www.cnblogs.com/bztMinamoto/p/9480501.html)

关于点分是什么楼下讲的听清楚了~~（主要是我根本讲不来）~~，还是讲一下本题的思路吧

这题正解是动态点分治（不过据说主席树+树链剖分跑得更快？）

　　如果不知道什么是动态点分的可以去看看幻想乡的战略游戏->[蒟蒻的题解](https://minamoto.blog.luogu.org/solution-p3345)

　　这一道题，我们考虑对于每一个点分树上的点维护什么。我们记录三个值，$sz_0$表示子树内的点数之和，$sz_1$表示子树内所有点到其的距离之和，$sz_2$表示子树内所有点到其父亲的距离之和。那么考虑我们在跳点分树的时候要如何维护答案呢？很明显$sz_1[u]+\sum sz_1[fa]-sz_2[p]+(sz_0[fa]-sz_0[p])*dist(fa,u)$就是在点分树上与$u$的$LCA$是$fa$的所有点的距离之和，其中$fa$为$p$的父亲，$p$为从$u$不断跳父亲直到根，那么只要不断枚举$fa$，并不断往上跳并维护答案就可以了。

　　然而上面只是为了方便理解，因为具体的计算不是这样的。我们对于$u$点内部的贡献可以直接计算，然后考虑往上跳。在上述的式子中如果一个点$p$有$fa$，那么答案就要减去$sz_0[p]*dist(fa,u)+sz_2[p]$，如果一个点不是$u$那么答案就要加上$sz_0[p]+dist(p,u)$，然后每一个点都要加上自己的$sz_1$。按这个规律在跳点分树的时候不断加就好了

　　然后考虑怎么在$[l,r]$之内，很明显可以搞一个差分，把每一个节点在点分树上的子树内的所有年龄的距离之和加起来，在做前缀和，那么在年龄$[l,r]$的人数就是$[1,r]-[1,l-1]$
```
//minamoto
#include<cstdio>
#include<iostream>
#include<cstring>
#include<vector>
#include<algorithm>
#define ll long long
#define N 150005
using namespace std;
#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
inline int read(){
    #define num ch-'0'
    char ch;bool flag=0;int res;
    while(!isdigit(ch=getc()))
    (ch=='-')&&(flag=true);
    for(res=num;isdigit(ch=getc());res=res*10+num);
    (flag)&&(res=-res);
    #undef num
    return res;
}
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
inline void print(ll x){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
int head[N],Next[N<<1],ver[N<<1],edge[N<<1];
int n,tot,val[N],q,maxn;
int st[N<<1][19],d[N],dfn[N],num,bin[25],tp,logn[N<<1];
inline void add(int u,int v,int e){
	ver[++tot]=v,Next[tot]=head[u],head[u]=tot,edge[tot]=e;
	ver[++tot]=u,Next[tot]=head[v],head[v]=tot,edge[tot]=e;
}
inline void ST(){
	for(int j=1;j<=tp;++j)
	for(int i=1;i+bin[j]-1<=(n<<1);++i)
	st[i][j]=min(st[i][j-1],st[i+bin[j-1]][j-1]);
}
void dfs1(int u,int fa){
	st[dfn[u]=++num][0]=d[u];
	for(int i=head[u];i;i=Next[i]){
		int v=ver[i];
		if(v==fa) continue;
		d[v]=d[u]+edge[i],dfs1(v,u),st[++num][0]=d[u];
	}
}
int fa[N],sz[N],son[N],size,rt;bool vis[N];
void dfs2(int u,int fa){
	sz[u]=1,son[u]=0;
	for(int i=head[u];i;i=Next[i]){
		int v=ver[i];
		if(vis[v]||v==fa) continue;
		dfs2(v,u),sz[u]+=sz[v],cmax(son[u],sz[v]);
	}
	cmax(son[u],size-sz[u]);
	if(son[u]<son[rt]) rt=u;
}
inline ll dis(int a,int b){
	if(dfn[a]>dfn[b]) a^=b^=a^=b;
	int k=logn[dfn[b]-dfn[a]+1];
	return d[a]+d[b]-(min(st[dfn[a]][k],st[dfn[b]-bin[k]+1][k])<<1);
}
struct node{
	int val;ll sz[3];
	node(int a=0,ll b=0,ll c=0,ll d=0){val=a,sz[0]=b,sz[1]=c,sz[2]=d;}
	inline bool operator <(const node &b)const
	{return val<b.val;}
};
vector<node> sta[N];
void dfs3(int u,int f,int rt){
	sta[rt].push_back(node(val[u],1,dis(u,rt),fa[rt]?dis(u,fa[rt]):0));
	for(int i=head[u];i;i=Next[i]){
		int v=ver[i];
		if(v==f||vis[v]) continue;
		dfs3(v,u,rt);
	}
}
void dfs4(int u){
	vis[u]=true;
	dfs3(u,0,u);sta[u].push_back(node(-1,0,0,0));
	sort(sta[u].begin(),sta[u].end());
	for(int i=0,j=sta[u].size();i<j-1;++i)
	sta[u][i+1].sz[0]+=sta[u][i].sz[0],
	sta[u][i+1].sz[1]+=sta[u][i].sz[1],
	sta[u][i+1].sz[2]+=sta[u][i].sz[2];
	for(int i=head[u];i;i=Next[i]){
		int v=ver[i];
		if(vis[v]) continue;
		rt=0,size=sz[v];
		dfs2(v,0),fa[rt]=u,dfs4(rt);
	}
}
inline node query(int id,int l,int r){
	if(id==0) return node();
	vector<node>::iterator it1=upper_bound(sta[id].begin(),sta[id].end(),node(r,0,0,0));--it1;
	vector<node>::iterator it2=upper_bound(sta[id].begin(),sta[id].end(),node(l-1,0,0,0));--it2;
	return node(0,it1->sz[0]-it2->sz[0],it1->sz[1]-it2->sz[1],it1->sz[2]-it2->sz[2]);
}
inline ll calc(int u,int l,int r){
	ll res=0;
	for(int p=u;p;p=fa[p]){
		node a=query(p,l,r);
		res+=a.sz[1];
		if(p!=u) res+=a.sz[0]*dis(p,u);
		if(fa[p]) res-=a.sz[2]+a.sz[0]*dis(fa[p],u);
	}
	return res;
}
int main(){
	ll ans=0;
	n=read(),q=read(),maxn=read();
	bin[0]=1,logn[0]=-1;
	for(int i=1;i<=20;++i) bin[i]=bin[i-1]<<1;
	while(bin[tp+1]<=(n<<1)) ++tp;
	for(int i=1;i<=(n<<1);++i) logn[i]=logn[i>>1]+1;
	for(int i=1;i<=n;++i) val[i]=read();
	for(int i=1;i<n;++i){
		int u=read(),v=read(),e=read();
		add(u,v,e);
	}
	dfs1(1,0),ST();
	rt=0,son[0]=n+1,size=n,dfs2(1,0);
	dfs4(rt);
	while(q--){
		int a=read(),b=read(),c=read();
		b=(b+ans)%maxn,c=(c+ans)%maxn;
		if(b>c) b^=c^=b^=c;
		print(ans=calc(a,b,c));
	}
	Ot();
	return 0;
}
```

---

## 作者：nosta (赞：5)

~~「前言」为防止在某巨巨的毒瘤idea 紫荆花之“店" 面前一脸懵，特滚来补此题。~~  ~~我还是太naive了。~~

「题义」给出一棵单点度数很小的无根带边权、点权的树，每次询问在所有点权在\[l,r\]的点到c的距离之和。

「分析」考虑建立点分树，分治结构每个点都储存对应分治范围（简称范围）内的信息，询问时从c向后跳分治链，并逐级将信息合并得到整棵树的答案。

对于链上某一点x，设前一个点为px，显然我们需要用到的，x范围中（除去px范围）的所有合法的点（即点权在\[l,r\]内的点）到c的距离之和，拆开为这些点到x的距离和+这些点的个数乘以x到c的距离。对于第一部分我们将它看作x范围内所有点到x的距离和-px范围内所有点到x的距离和，第二部分同理。

这样，我们只需要对每个节点x储存范围内所有点点权age、到x的距离dis以及到上一级分治中心fa\[x\]的距离ldis（放在集合d\[x\]）。然后将d\[x\]按照age排序，那么x的分治范围对于查询中心c的产生贡的点献处于d\[x\]的一段区间上。利用前（后）缀和+二分就能地很好处理了。

```cpp
#include <bits/stdc++.h>
#define IL inline 
#define LL long long 
using namespace std;

const int N=150010;
const int inf=0x3f3f3f3f;

int n,Q,A,age[N];
int head[N],to[N<<1],last[N<<1],len[N<<1];

IL void addEdge(int x,int y,int w) {
	static int cnt=0;
	to[++cnt]=y,len[cnt]=w,last[cnt]=head[x],head[x]=cnt;
	to[++cnt]=x,len[cnt]=w,last[cnt]=head[y],head[y]=cnt;
}
namespace dbl {
	int fa[N][20],dep[N];
	LL ds[N][20];
	void prDfs(int x,int d) {
		dep[x]=dep[fa[x][0]=d]+1;
		for(int i=1; (1<<i)<=dep[x]; ++i) {
			fa[x][i]=fa[fa[x][i-1]][i-1];
			ds[x][i]=ds[fa[x][i-1]][i-1]+ds[x][i-1];
		}
		for(int i=head[x]; i; i=last[i]) {
			if(to[i]!=d) ds[to[i]][0]=len[i],prDfs(to[i],x);
		}
	}
	IL LL gtDis(int x,int y) {
		if(dep[x]<dep[y]) swap(x,y);
		LL ret=0; int dif=dep[x]-dep[y];
		for(int i=19; ~i; --i) if((dif>>i)&1) 
			ret+=ds[x][i],x=fa[x][i];
		if(x==y) return ret;
		for(int i=19; ~i; --i) if(fa[x][i]!=fa[y][i]) 
			ret+=ds[x][i],x=fa[x][i],ret+=ds[y][i],y=fa[y][i];
		return ret+ds[x][0]+ds[y][0];
	}
}
namespace dpd {
	struct node {
		LL dis,ldis; int age;
		IL node(LL d=0,LL ld=0,int a=0):dis(d),ldis(ld),age(a){}	
		IL bool operator<(const node&d) const {
			return age<d.age;
		}
	};
	vector<node> d[N];
	int root,siz[N],fa[N];
	bool ban[N];
	void prSiz(int x,int d) {
		siz[x]=1; 
		for(int i=head[x]; i; i=last[i]) if(!ban[to[i]]&&to[i]!=d) 
			prSiz(to[i],x),siz[x]+=siz[to[i]];
	}
	void gtRoot(int x,int d,int t) {
		static int f[N]={inf}; f[x]=siz[t]-siz[x];
		for(int i=head[x]; i; i=last[i]) if(!ban[to[i]]&&to[i]!=d) 
			gtRoot(to[i],x,t),f[x]=max(f[x],siz[to[i]]);
		if(f[x]<f[root]) root=x;
	}
	void prNode(int x,int d,LL dis) {
		dpd::d[root].push_back(node(dis,dbl::gtDis(x,fa[root]),age[x]));
		for(int i=head[x]; i; i=last[i]) {
			if(!ban[to[i]]&&to[i]!=d) prNode(to[i],x,dis+len[i]);
		}
	}
	void build(int x,int lrt) {
		root=0; prSiz(x,0); gtRoot(x,0,x); 
		x=root; fa[x]=lrt; ban[x]=1; prNode(x,0,0);
		sort(d[x].begin(),d[x].end());
		d[x].push_back(node(0,0,A));
		for(unsigned i=d[x].size()-2; ~i; --i) {
			d[x][i].dis+=d[x][i+1].dis;
			d[x][i].ldis+=d[x][i+1].ldis;
		}
		for(int i=head[x]; i; i=last[i]) {
			if(!ban[to[i]]) build(to[i],x);
		}
	}
	IL LL query(int c,int l,int r) {
		vector<node>::iterator L,R; LL ans=0;
		for(int x=c; x; x=fa[x]) {
			L=lower_bound(d[x].begin(),d[x].end(),node(0,0,l));
			R=upper_bound(d[x].begin(),d[x].end(),node(0,0,r));
			ans+=dbl::gtDis(x,c)*(R-L)+(L->dis-R->dis);
			if(fa[x]) ans-=dbl::gtDis(fa[x],c)*(R-L)+(L->ldis-R->ldis);
		}
		return ans;
	}
}

int main() {
	scanf("%d%d%d",&n,&Q,&A);
	for(int i=1; i<=n; ++i) scanf("%d",&age[i]);
	for(int x,y,w,i=n; --i; ) {
		scanf("%d%d%d",&x,&y,&w);
		addEdge(x,y,w);
	}
	dbl::prDfs(1,0);
	dpd::build(1,0); 
	LL lans=0;
	for(int u,a,b; Q--; ) {
		scanf("%d%d%d",&u,&a,&b);
		a=(lans+a)%A, b=(lans+b)%A; if(a>b) swap(a,b); 
		printf("%lld\n",lans=dpd::query(u,a,b));
	}
	return 0;
} // 代码O2需要

```
~~好了，滚去看 紫荆花之恋 了~~



---

## 作者：EternalEpic (赞：5)

建议先做一下：[P4211 [LNOI2014]LCA](https://www.luogu.com.cn/problem/P4211)

如果你做了上面那题，你会发现此题为强制在线版，而且添加了边权。

其实不要紧，那个询问差分的思路仍然可以继续使用，只不过要用可持久化线段树实现。

我们可以先把 $age$ 排序，然后先树剖，按 $age$ 顺序建主席树。

我们发现，有边权之后有些难处理。

首先是主席树要标记永久化，因为每次修改是标记翻倍，所以可以维护 $tim$ 数组，表示覆盖几次，可以乘上边权和来计算贡献。

其次就是要利用距离公式来计算答案，如询问$l$ $r$ $x$那么答案应为： $dis[x] * (r - l + 1) + (sumd[r] - sumd[l - 1]) - Query(root[r], root[l - 1], x) * 2)$ 

code:

```cpp
// Program written by Liu Zhaozhou ~~~

const int Maxn = 15e4 + 1;
const int Maxm = 3e5 + 1;
const int Maxt = Maxn * 49;

int n, q, ages, cnt = 0, head[Maxn], ver[Maxm], edge[Maxm], nxt[Maxm];
inline void AddEdge(int u, int v, int w) {
	ver[++cnt] = v, edge[cnt] = w, nxt[cnt] = head[u], head[u] = cnt;
	ver[++cnt] = u, edge[cnt] = w, nxt[cnt] = head[v], head[v] = cnt;
}

struct state {
	int age, idx;
	state(void) { age = idx = 0; }
	state(int a, int i) : age(a), idx(i) {}
	inline bool operator < (const state&rhs) const { return age == rhs.age ? idx < rhs.idx : age < rhs.age; } 
} a[Maxn];

ll dis[Maxn], sume[Maxn], sumd[Maxn];
int sze[Maxn], son[Maxn], fat[Maxn];
int top[Maxn], dfn[Maxn], timer = 0;
inline void DfsFir(int u) {
	sze[u] = 1;
	for (int i = head[u]; i; i = nxt[i]) {
		if (ver[i] == fat[u]) continue;
		dis[ver[i]] = dis[u] + edge[i];
		fat[ver[i]] = u; DfsFir(ver[i]);
		sze[u] += sze[ver[i]];
		if (sze[son[u]] < sze[ver[i]]) son[u] = ver[i];
	}
}

inline void DfsSec(int u, int t) {
	top[u] = t, dfn[u] = ++timer;
	sume[timer] = dis[u] - dis[fat[u]];
	if (son[u]) DfsSec(son[u], t);
	for (int i = head[u]; i; i = nxt[i]) {
		if (ver[i] == fat[u] || ver[i] == son[u]) continue;
		DfsSec(ver[i], ver[i]);
	}
}

int lson[Maxt], rson[Maxt], tim[Maxt], root[Maxn], tot = 0; ll sum[Maxt];
inline void inherit(int p, int q) { lson[p] = lson[q], rson[p] = rson[q], sum[p] = sum[q], tim[p] = tim[q]; }
inline void insert(int &pos, int l, int r, int L, int R) {
	inherit(++tot, pos); pos = tot; 
	if (L <= l && R >= r) { sum[pos] += sume[r] - sume[l - 1]; ++tim[pos]; return; }
	int mid = l + r >> 1;
	if (L <= mid) insert(lson[pos], l, mid, L, R);
	if (R > mid) insert(rson[pos], mid + 1, r, L, R);
	sum[pos] = sum[lson[pos]] + sum[rson[pos]] + (sume[r] - sume[l - 1]) * tim[pos];
}

inline void Modify(int &rt, int pos) { while (pos) insert(rt, 1, n, dfn[top[pos]], dfn[pos]), pos = fat[top[pos]]; }
inline ll query(int p, int q, int l, int r, int L, int R) {
	if (!p) return 0;
	if (L <= l && R >= r) return sum[p] - sum[q];
	int mid = l + r >> 1; ll ret = (sume[min(R, r)] - sume[max(L, l) - 1]) * (tim[p] - tim[q]);
	if (L <= mid) ret += query(lson[p], lson[q], l, mid, L, R);
	if (R > mid) ret += query(rson[p], rson[q], mid + 1, r, L, R);
	return ret;
}

inline ll Query(int p, int q, int x) { ll ret = 0ll; while (x) ret += query(p, q, 1, n, dfn[top[x]], dfn[x]), x = fat[top[x]]; return ret; }

signed main(void) {
//	file("");
	read(n), read(q), read(ages);
	for (int i = 1; i <= n; i++) read(a[i].age), a[i].idx = i;
	sort(a + 1, a + n + 1);
	for (int i = 1, u, v, w; i < n; i++) read(u), read(v), read(w), AddEdge(u, v, w);
	DfsFir(1), DfsSec(1, 1);
	for (int i = 1; i <= n; i++) sume[i] += sume[i - 1], sumd[i] = sumd[i - 1] + dis[a[i].idx];
	for (int i = 1; i <= n; i++) Modify(root[i] = root[i - 1], a[i].idx);
	ll lastans = 0; int l, r, x;
	while (q--) {
		read(x), read(l), read(r);
		l = (l + lastans) % ages;
		r = (r + lastans) % ages;
		if (l > r) swap(l, r);
		l = lower_bound(a + 1, a + n + 1, state(l, 0)) - a;
		r = upper_bound(a + 1, a + n + 1, state(r, n)) - (a + 1);
		writeln(lastans = (dis[x] * (r - l + 1) + (sumd[r] - sumd[l - 1]) - Query(root[r], root[l - 1], x) * 2));
	}
//	fwrite(pf, 1, o1 - pf, stdout);
	return 0;
}

/**/



```


---

## 作者：EnofTaiPeople (赞：4)

树链剖分与线段树配合可以维护树上路径和子树修改查询。

设节点 $y$ 的重儿子 $wson(y)$ 为诸多儿子中大小 $size$ 最大的儿子，他们之间的边称为重边，相连的重边组成重链，不是重边的边就是轻边。

原理在于将一棵树进行树链剖分之后，任意节点到根节点的轻边条数不超过 $\log_2n$ 因为 $\forall x\in son(y),x\neq wson(y)$ 有 $size(y)>2size(x)$，由重儿子的定义可以得知。

树剖需要记录的数据如下：
```cpp
int tlpf[N][8];
#define f(x) tlpf[x][0]
#define d(x) tlpf[x][1]
#define t(x) tlpf[x][2]
#define w(x) tlpf[x][3]
#define s(x) tlpf[x][4]
#define g(x) tlpf[x][5]
#define p(x) tlpf[x][6]
#define r(x) tlpf[x][7]
```
其中 `f(x)` 表示 $x$ 的父亲，`d(x)` 是默认边权为一时的深度，`t(x)` 是链顶，轻儿子的链顶是自己，重儿子的链顶是父亲的链顶，`w(x)` 是重儿子，`s(x)` 是子树大小，`g(x)` 表示优先走重边的时间戳，这样一条重链的时间戳是连续的，`p(x)` 是父边权值，`r(x)` 满足 $r(g(x))=x$。

通过两次深搜来进行树链剖分：
```cpp
void dfs1(int x=1){
	int y;s(x)=1;
	for(int i:lk[x])
		if((y=ed[i])!=f(x)){
			f(y)=x,d(y)=d(x)+1;
			p(y)=w[i],d[y]=d[x]+p(y);
			dfs1(y),s(x)+=s(y);
			if(s(y)>s(w(x)))w(x)=y;
		}
}
void dfs2(int x=1){
	int y;r(g(x)=++dlt)=x;
	if(w(x)){
		t(w(x))=t(x),dfs2(w(x));
		for(int i:lk[x])
			if((y=ed[i])!=w(x)&&y!=f(x))
				t(y)=y,dfs2(y);
	}
}
```
上面说到，重链上时间戳连续，这样修改一条链可以划分成 $O(\log_2n)$ 条重链，用线段树维护区间修改查询，时间复杂度都是 $O(\log_2^2n)$。

本题中，我们需要将节点按 $x_i$ 排序，这样每一次查询得到的是一个区间的节点，这时，我们有（注意这里的 $d$ 是带边权的深度）：$$\sum\limits_{y=L}^Rdis(x,y)=\sum\limits_{y=L}^R(d(x)+d(y)-2d(lca(x,y))=(R-L+1)d(x)+\sum\limits_{y=L}^Rd(y)-2\sum\limits_{y=L}^Rd(lca(x,y))$$ 第二部分可以预处理前缀和 $O(1)$ 求，第三部分可以这样考虑：如果将 $y$ 到根节点的链上整体加上边权，再查询从 $x$ 到根节点的和，这样得到的就是 $d(lca(x,y))$。

由于强制在线，我们可以按 $x_i$ 从小到大修改这些节点到根节点的路径，需要可持久化，在查询时对两棵线段树进行差分即可。
```cpp
int build(int l=1,int r=n){
	int md=l+r>>1,x=++cnt;
	if(l==r){bs[x]=p(r(l));return x;}
	ls=build(l,md),rs=build(md+1,r);
	bs[x]=bs[ls]+bs[rs];return x;
}
inline void x_new(int &x){
	t[++cnt][0]=ls,t[cnt][1]=rs;
	ad[cnt]=ad[x],sm[cnt]=sm[x];
	bs[cnt]=bs[x],x=cnt;
}
inline void add(int &x,int p){
	x_new(x);ad[x]+=p,sm[x]+=bs[x]*p;
}
inline void pd(int x){
	if(ad[x]){
		if(ls)add(ls,ad[x]);
		if(rs)add(rs,ad[x]);ad[x]=0;
	}
}
void Add(int &x,int l,int r,int L,int R){
	if(l>=L&&r<=R)return add(x,1);pd(x);
	int md=l+r>>1;x_new(x);
	if(L<=md)Add(ls,l,md,L,R);
	if(md<R)Add(rs,md+1,r,L,R);
	sm[x]=sm[ls]+sm[rs];
}
void qry(int &x,int l,int r,int L,int R,int addd=0){
	if(l>=L&&r<=R){ans+=sm[x]+bs[x]*addd;return;}
	int md=l+r>>1;addd+=ad[x];
	if(L<=md)qry(ls,l,md,L,R,addd);
	if(md<R)qry(rs,md+1,r,L,R,addd);
}
```
[LOJ 上的 AC 记录](https://loj.ac/s/1542617)

---

## 作者：81179332_ (赞：4)

动态点分治

建立点分树，使用 `vector` 记录每个点在点分树上的所有祖先以及它到祖先的距离

对于一个点 $u$，设 $u$ 的子树中的点到 $u$ 的距离和为 $sum_u$，子树大小为 $num_u$

对于 $u$ 的一个祖先 $v$，它对答案的贡献为：$dis_{u,v}+dis_{u,v}\times(num_v-num_u)+sum_v-sum_u$

注意！此处不是减法，点分树中的信息不能相减，此处的减号表示不包含

发现每个点的度数不超过 $3$，所以我们可以每个点开三个 `vector` 记录子树中所有点的点权、到 $u$ 的距离

这样我们把三个 `vector` 分别按照点权排序，维护一个后缀和，查询的时候二分查找即可

为什么是后缀和呢？设我们要找的区间为 $[l,r]$，如果是前缀和，我们需要得到 $l-1$ 和 $r$，而这个东西需要 `lower_bound` 再减 $1$、`upper_bound` 再减 $1$，还需要判边界。而如果是后缀和，我们需要得到 $l$ 和 $r+1$，这个直接 `lower_bound`、`upper_bound` 即可

```cpp
const int N = 150010,M = N;
int n,q,A;ll ans;
EE(1);int x[N];

int siz[N],S,root,mxr;bool vis[N];
void get_siz(int u,int fa)
{
	siz[u] = 1;
	for(int i = head[u],v;i;i = e[i].nxt) if((v = e[i].to) != fa && !vis[v])
		get_siz(v,u),siz[u] += siz[v];
}
void get_root(int u,int fa)
{
	int maxx = S - siz[u];
	for(int i = head[u],v;i;i = e[i].nxt) if((v = e[i].to) != fa && !vis[v])
		get_root(v,u),maxx = max(maxx,siz[v]);
	if(maxx < mxr) mxr = maxx,root = u;
}
struct anc { int to;ll dis;int ty; };vector<anc> v[N];
struct data
{
	int w;ll num,sum;
	friend bool operator < (data a,data b) { return a.w < b.w; }
};vector<data> s[N][3];
int dep[N];
void dfs(int u,int fa,int fr,int w)
{
	v[u].push_back({fr,dep[u],w});
	s[fr][w].push_back({x[u],1,dep[u]});
	for(int i = head[u],v;i;i = e[i].nxt) if((v = e[i].to) != fa && !vis[v])
		dep[v] = dep[u] + e[i].w,dfs(v,u,fr,w);
}
void solve(int u)
{
	get_siz(u,0),S = siz[u],mxr = INF,get_root(u,0);
	vis[root] = 1,v[root].push_back({root,0,-1});
	if(siz[u] == 1) return;
	int cnt = 0;
	for(int i = head[root],v;i;i = e[i].nxt) if(!vis[v = e[i].to])
	{
		dep[v] = e[i].w,dfs(v,root,root,cnt);
		auto& now = s[root][cnt];
		now.push_back({INF,0,0});
		sort(now.begin(),now.end());
		for(int j = now.size() - 2;~j;j--)
			now[j].num += now[j + 1].num,now[j].sum += now[j + 1].sum;
		cnt++;
	}for(int i = head[root],v;i;i = e[i].nxt) if(!vis[v = e[i].to]) solve(v);
}
ll query(int l,int r,int u)
{
	ll ans = 0;
	for(int i = v[u].size() - 1;~i;i--)
	{
		int fa = v[u][i].to;
		for(int j = 0;j < 3;j++)
		{
			auto& now = s[fa][j];
			if(j == v[u][i].ty || now.empty()) continue;
			auto L = lower_bound(now.begin(),now.end(),(data){l,0,0});
			auto R = upper_bound(now.begin(),now.end(),(data){r,0,0});
			ans += v[u][i].dis * (L->num - R->num) + L->sum - R->sum;
		}if(l <= x[fa] && r >= x[fa]) ans += v[u][i].dis;
	}return ans;
}
int main()
{
	n = read(),q = read(),A = read();
	for(int i = 1;i <= n;i++) x[i] = read();
	for(int i = 1;i < n;i++) { int x = read(),y = read();add_edge(x,y,read()); }
	solve(1);
	for(int i = 1;i <= q;i++)
	{
		ll u = read(),l = read(),r = read();
		l = (l + ans) % A,r = (r + ans) % A;if(l > r) swap(l,r);
		fprint(ans = query(l,r,u));
	}
}
```

---

## 作者：partychicken (赞：4)

总觉得各位神仙点分树的构建有些重复赘余，这里提供一种个人认为比较好的写法。。。

具体做法是每次用递归上一层的总大小tot减去上一层的点的重儿子大小，得到的就是这一层的总大小。这样求中心就只需一次dfs了

有些说不明白呢。。。看代码吧

不喜勿喷。


```
#include<bits/stdc++.h>

using namespace std;

typedef vector<int>::iterator IT;

struct Edge
{
    int to,nxt,val;

    Edge(){}
    Edge(int to,int nxt,int val):to(to),nxt(nxt),val(val){}
}e[300010];
int head[150010],cnt;

void addedge(int u,int v,int val)
{
    e[++cnt]=Edge(v,head[u],val);
    head[u]=cnt;
}

int siz[150010],son[150010];
bool vis[150010];

int tot,lasttot;
int maxp,root;

void getG(int now,int fa)
{
    siz[now]=1;
    son[now]=0;
    for(int i=head[now];i;i=e[i].nxt)
    {
        int vs=e[i].to;
        if(vs==fa||vis[vs]) continue;
        getG(vs,now);
        siz[now]+=siz[vs];
        son[now]=max(son[now],siz[vs]);
    }
    son[now]=max(son[now],tot-siz[now]);
    if(son[now]<maxp)
    {
        maxp=son[now];
        root=now;
    }
}

struct Node
{
    int fa;
    vector<int>anc;
    vector<int>child,allchild;
}nd[150010];

int age[150010];
int build(int now,int ntot)
{
    tot=ntot;
    maxp=0x7f7f7f7f;
    getG(now,0);
    int g=root;
    cout<<g<<'\n';
    vis[g]=1;
    for(int i=head[g];i;i=e[i].nxt)
    {
        int vs=e[i].to;
        if(vis[vs]) continue;
        int tmp=build(vs,ntot-son[vs]);
        nd[tmp].fa=now;
        nd[now].child.push_back(tmp);
    }
    return g;
}

int virtroot;

int main()
{
    int n,Q,A;
    cin>>n>>Q>>A;
    for(int i=1;i<=n;i++)
    {
        cin>>age[i];
    }
    for(int i=1;i<n;i++)
    {
        int u,v,val;
        cin>>u>>v>>val;
        addedge(u,v,val);
        addedge(v,u,val);
    }
    virtroot=build(1,n);
}

```

---

## 作者：Jμdge (赞：2)

这题原来是套路题？ （结果代码调了一个下午）


我们考虑套个动态点分，每层的点分中心暴力vector 存下管辖子树的各种信息（如点数、距离、用来容斥的信息），然后按 a[i] 排序，处理前缀和

然后询问的时候二分 l r ，接着就是套路处理答案了


这里用了树剖求lca

然后我们还发现真实的点分代码比较短？

```
//by Judge
#include<bits/stdc++.h>
#define ll long long
#define fp(i,a,b) for(int i=(a),I=(b)+1;i<I;++i)
#define go(G,u) for(int i=G.head[u],v=G.e[i].to;i;v=G.e[i=G.e[i].nxt].to)
#define Vt Vater[u]
#define Vr Vater[root]
#define P pair<int,int>
#define se second
#define fi first
using namespace std;
const int M=15e5+3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline void cmax(int& a,int b){if(a<b)a=b;}
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} inline int cread(){ char c=getchar();
	for(;!isupper(c);c=getchar()); return c=='C';
}char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
inline void print(ll x,char chr='\n'){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]=chr;
} int n,m,A,root,tot; ll ans,dis[M];
arr a,f,son,siz,dep,top,mx,vis,Vater;
struct node{ int val; ll size[3];
	node(int a=0,ll b=0,ll c=0,ll d=0){
		val=a,size[0]=b,size[1]=c,size[2]=d; }
	bool operator <(node b)const{ return val<b.val;}
}; vector<node> vec[M];
struct Gr{ int pat,head[M];
	struct Edge{ int to,val,nxt; }e[M<<1];
	inline void add(int u,int v,int w){
		e[++pat]=(Edge){v,w,head[u]},head[u]=pat;
		e[++pat]=(Edge){u,w,head[v]},head[v]=pat;
	}
}G;
void dfs(int u,int fa){
	dep[u]=dep[fa]+1,siz[u]=1;
	go(G,u) if(v^fa){
		dis[v]=dis[u]+G.e[i].val;
		f[v]=u,dfs(v,u),siz[u]+=siz[v];
		if(siz[v]>siz[son[u]]) son[u]=v;
	}
}
void dfs(int u){ if(!top[u]) top[u]=u;
	if(son[u]) top[son[u]]=top[u],dfs(son[u]);
	go(G,u) if(v^f[u]&&v^son[u]) dfs(v);
}
inline int lca(int u,int v){
	for(;top[u]^top[v];u=f[top[u]])
		if(dep[top[u]]<dep[top[v]]) swap(u,v);
	return dep[u]<dep[v]?u:v;
}
inline ll Dis(int u,int v){
	return dis[u]+dis[v]-(dis[lca(u,v)]<<1);
}
/////////////////////////////////////////////////////////
void get_root(int u,int fa){ siz[u]=1,mx[u]=0;
	go(G,u) if(!vis[v]&&v^fa) get_root(v,u),
		siz[u]+=siz[v],cmax(mx[u],siz[v]);
	cmax(mx[u],tot-siz[u]); if(mx[u]<mx[root]) root=u;
}
void DFS(int u,int fa,ll DIS){
	vec[root].push_back(node(a[u],1,DIS,Vr?Dis(Vr,u):0));
	go(G,u) if(!vis[v]&&v^fa) DFS(v,u,DIS+G.e[i].val);
}
void solv(int u,int fa){
	get_root(u,fa),u=root,vis[u]=1,Vt=fa;
	DFS(u,0,0),vec[u].push_back(node(-1));
	sort(vec[u].begin(),vec[u].end());
	fp(i,0,vec[u].size()-2)
		vec[u][i+1].size[0]+=vec[u][i].size[0],
		vec[u][i+1].size[1]+=vec[u][i].size[1],
		vec[u][i+1].size[2]+=vec[u][i].size[2];
	go(G,u) if(!vis[v]) tot=siz[v],root=0,solv(v,u);
}
inline node query(int x,int l,int r){ if(!x) return node();
	vector<node>::iterator itl=upper_bound(vec[x].begin(),vec[x].end(),node(l-1)); --itl;
	vector<node>::iterator itr=upper_bound(vec[x].begin(),vec[x].end(),node(r)); --itr;
	return node(0,itr->size[0]-itl->size[0],itr->size[1]-itl->size[1],itr->size[2]-itl->size[2]);
}
inline ll calc(int x,int l,int r){ ll s=0;
	for(int u=x;u;u=Vt){ node a=query(u,l,r);
		s+=a.size[1]+a.size[0]*Dis(u,x);
		if(Vt) s-=a.size[2]+a.size[0]*Dis(Vt,x);
	} return s;
}
int main(){ int x,y,z;
	n=read(),m=read(),A=read(); fp(i,1,n) a[i]=read();
	fp(i,1,n-1) x=read(),y=read(),z=read(),G.add(x,y,z);
	dfs(1,0),dfs(1),root=0,mx[0]=tot=n,solv(1,0);
	fp(T,1,m){ z=read(),x=(read()+ans)%A,y=(read()+ans)%A;
		if(x>y) swap(x,y); print(ans=calc(z,x,y)); } return Ot(),0;
} /*Cardi B*/
```



---

## 作者：Diwanul (赞：1)

# 题意

给定一颗大小为 $N$ 的无根二叉树，边带权点带权。$Q$ 次询问，每次询问给出 $l,r,u$，求所有点权处于 $[l,r]$ 区间的点到点 $u$ 的距离和。$N\le1.5\times10^5$，$Q\le2\times10^5$，强制在线。

# 思路

考虑单次询问怎么做。从 $u$ 开始做一遍 DFS？这个做法如果要推广到多次询问需要换根 DP，但强制在线。考虑树分治，从点或边分树的树根开始向 $u$ 走，每次计算和 $u$ 不在同一子树中的点的贡献。每次询问要查询 $O(logn)$ 个点的答案，每次查询都是区间和问题，动态开点线段树或者排序前缀和加上二分即可。总复杂度 $O(nlog^2n)$。

考虑能不能优化掉一只 $log$。一个很有价值且可推广到其他题的想法：前缀和的复杂度瓶颈在于二分，而二分的必要在于时间空间不够在每个点上都开 $O(n)$ 前缀和。能不能用什么办法使得可以 $O(n)$ 前缀和却不爆空间？发现当前缀和在存有所有的不同点权时，利用率最大，那么就考虑把这个前缀和给提到外面来。那么在外面的前缀和，里面又套了别的数据结构，这是什么？可持久化维护第二维有可减性的信息。

# 实现

考虑具体怎么实现。

首先，选择点分树还是边分树？题目中说树已经三度化，所以使用边分树来简化修改和查询操作。

注意到点权最大值很大，需要离散化。先一遍边分治确定好边分树的形态，然后把点按照点权排序，依次加入可持久化边分树里。

这里确定边分树形态，按点每层分治处于分治中心的哪一侧来构建一个 01 串。所以最后的边分树就很像是一颗 01 Trie。边分树中，每个点记录当前点所代表的连通块的信息，如联通块中点的个数以及联通块中所有点到上一层分治中心的距离和。那么每次查询就计算在分治中心另一侧的点对点 $u$ 的贡献即可。

代码去掉了无关紧要的部分。

```cpp
int n,m;
LL lst;
int v[N+10],lsh[N+10],tl,aa;
vector<int> vtn[N+10];

int lrt,rt[N+10];
int zx,mx;
int sz[N+10];
int bh[N+10];
int dis[LGN+10][N+10];
int de[N+10];

void GetAns(int u,int fa,int d,int dep){
	dis[dep][u]=d;
	for(int i=head[u],v=e[i].t;i;i=e[i].n,v=e[i].t)
		if(v!=fa&&!used[i>>1])
			GetAns(v,u,d+e[i].w,dep);
}

void GetRoot(int u,int fa,int tsz){
	sz[u]=1;
	for(int i=head[u],v=e[i].t;i;i=e[i].n,v=e[i].t)
		if(!used[i>>1]&&v!=fa){
			GetRoot(v,u,tsz);
			sz[u]+=sz[v];
			if(Max(tsz-sz[v],sz[v])<mx)
				mx=Max(tsz-sz[v],sz[v]),zx=i;
		}
}

void Divide(int u,int tsz,int bit,int dep){
	if(tsz==1)
		return bh[u]=bit,de[u]=dep,void();
	zx=0,mx=tsz;
	GetRoot(u,0,tsz);
	int dq=zx;
	used[dq>>1]=1;
	GetAns(e[dq].t,0,e[dq].w,dep);
	GetAns(e[dq^1].t,0,0,dep);
	int szz=sz[e[dq].t];
	Divide(e[dq].t,szz,bit,dep+1);
	Divide(e[dq^1].t,tsz-szz,bit|(1<<dep),dep+1);
}

namespace EDT{
#define SM(u) tr[u].sm
#define SL(u) tr[u].sl
#define S(u,x) tr[u].s[x]
#define LS(u) tr[u].s[0]
#define RS(u) tr[u].s[1]

	int tn;

	struct NODE{
		LL sm;
		int sl;
		int s[2];
	}tr[N*LGN+10];

	int Add(int old,int x,int dep){
		int u=++tn;
		bool tmp=(bh[x]>>dep)&1;
		SM(u)=SM(old);
		SL(u)=SL(old);
		if(dep==de[x])
			return u;
		S(u,tmp^1)=S(old,tmp^1);
		S(u,tmp)=Add(S(old,tmp),x,dep+1);
		SM(S(u,tmp))+=dis[dep][x];
		++SL(S(u,tmp));
		return u;
	}

	LL Query(int u,int x,int dep){
		if(dep==de[x])
			return 0;
		int tmp=(bh[x]>>dep)&1;
		return Query(S(u,tmp),x,dep+1)+SM(S(u,tmp^1))+1ll*SL(S(u,tmp^1))*dis[dep][x];
	}
}

int main(){
	n=Read(),m=Read()+1,aa=Read();
	for(int i=1;i<=n;++i)
		lsh[++tl]=v[i]=Read();
	sort(lsh+1,lsh+tl+1);
	tl=unique(lsh+1,lsh+tl+1)-lsh-1;
	for(int i=1;i<=n;++i)
		vtn[v[i]=lower_bound(lsh+1,lsh+1+tl,v[i])-lsh].push_back(i);
	for(int i=1;i<n;++i)
		Adde(Read(),Read(),Read());
	Divide(1,n,0,0);
	for(int i=1;i<=tl;++i){
		for(auto x:vtn[i])
			lrt=EDT::Add(lrt,x,0);
		rt[i]=lrt;
	}
	while(--m){
		int u=Read(),a=Read(),b=Read();
		a=(a+lst)%aa,b=(b+lst)%aa;
		if(a>b)
			swap(a,b);
		a=lower_bound(lsh+1,lsh+1+tl,a)-lsh-1,b=upper_bound(lsh+1,lsh+1+tl,b)-lsh-1;
		printf("%lld\n",lst=EDT::Query(rt[b],u,0)-EDT::Query(rt[a],u,0));
	}
	return 0;
}
```



---

## 作者：peterwuyihong (赞：1)

牛逼题。

题意：给定一棵树，点有点权，边有边权 $\in[0,A)$，要求在线维护一个询问 $u,a,b$，求点权在 $[a,b]$ 的点到 $u$ 的距离之和。

考虑一个集合 $S$ 中的所有点到 $u$ 的距离怎么做，是 $\sum_{v\in S}dis_v+dis_u-2dis_{lca(v,u)}$。

这个询问可以差分掉，变成求点权 $[1,b]-[1,a)$ 的形式，然后可以整一个可持久化线段树把状态记录下来

基本理清了思路，考虑这么一个流程。

先按照点权排序，枚举 $i\in[0,A)$，每次找到最靠右的点权严格大于 $i$ 的，然后维护这前面的点，记录一个 $sumdis_i$ 表示上述所维护的 $dis$ 之和，$totdis_i$ 表示上述维护的点有几个，然后用可持久化线段树维护，加入一个点，就结合树剖把这个点到根节点的所有 $app_i$ 加一。

对于询问，拆成 $[1,v]\to$ 后就是 $sumdis_v+totdis_v\times dis_u$，然后减去可持久化线段树上询问 $u$ 到根节点上的 $dis_x\times app_x$ 之和乘 $2$ 就行了。

现在是 $11:07$，我看我什么时候写完。

现在是 $14:07$，我终于写完了。

```cpp
#define maxn 150010
using i64 = long long;
int n,Q,A;
int a[maxn];
//tree
int head[maxn],Next[maxn<<1],ver[maxn<<1],edge[maxn<<1],tot;
void add(int x,int y,int z){
  ver[++tot]=y,edge[tot]=z;
  Next[tot]=head[x],head[x]=tot;
}
int dep[maxn],siz[maxn],fa[maxn],dis[maxn],rk[maxn],W[maxn];
int son[maxn],top[maxn],dfn[maxn],id;
void dfs1(int x){
  siz[x]=1;
  rg(i,x){
    int y=ver[i];
    if(dep[y])continue;
    dis[y]=dis[x]+edge[i];
    W[y]=edge[i];
    dep[y]=dep[x]+1;
    fa[y]=x;
    dfs1(y);
    siz[x]+=siz[y];
    if(siz[son[x]]<siz[y])son[x]=y;
  }
}
void dfs2(int x,int t){
  dfn[x]=++id;top[x]=t;rk[id]=x;
  if(!son[x])return;
  dfs2(son[x],t);
  rg(i,x)if(ver[i]!=fa[x]&&ver[i]!=son[x])dfs2(ver[i],ver[i]);
}
//decrease
int o[maxn],cnt;
//product
pair<int,int>g[maxn];
i64 sumdis[maxn];
int totdis[maxn];
struct prpr{
  int lc,rc;
  i64 sm,ex;
  int app;
}tree[maxn<<6];
int nod,rt[maxn];
int build(int l,int r){
  int x=++nod;
  if(l==r)return tree[x].ex=W[rk[l]],x;
  int mid=(l+r)>>1;
  tree[x].lc=build(l,mid);
  tree[x].rc=build(mid+1,r);
  tree[x].ex=tree[tree[x].lc].ex+tree[tree[x].rc].ex;
  return x;
}
int insert(int now,int l,int r,int L=1,int R=n){
  int x=++nod;
  tree[x]=tree[now];
  if(L>=l&&R<=r){
    tree[x].app++;
    tree[x].sm+=tree[x].ex;
    return x;
  }
  int mid=(L+R)>>1;
  if(l<=mid)tree[x].lc=insert(tree[now].lc,l,r,L,mid);
  if(r>mid)tree[x].rc=insert(tree[now].rc,l,r,mid+1,R);
  tree[x].sm=tree[tree[x].lc].sm+tree[tree[x].rc].sm+tree[x].ex*tree[x].app;
  return x;
}
//ans
i64 ans;
i64 qry(int x,int l,int r,int L=1,int R=n,int add=0){
  if(l<=L&&R<=r)return tree[x].sm+tree[x].ex*add;
  int mid=(L+R)>>1;
  i64 ans=0;
  add+=tree[x].app;
  if(l<=mid)ans+=qry(tree[x].lc,l,r,L,mid,add);
  if(r>mid)ans+=qry(tree[x].rc,l,r,mid+1,R,add);
  return ans;
}
i64 QQ(int u,int v){
  i64 ans=0;
  while(top[u]!=1){
    ans+=qry(rt[v],dfn[top[u]],dfn[u]);
    u=fa[top[u]];
  }
  ans+=qry(rt[v],dfn[1],dfn[u]);
  return ans;
}
i64 ask(int u,int L){
  return sumdis[L]+totdis[L]*1ll*dis[u]-2*QQ(u,L);
}
signed main(){
  cin>>n>>Q>>A;
  rep(i,1,n)cin>>a[i],g[i]={a[i],i};
  rep(i,1,n-1){
    int x,y,z;
    cin>>x>>y>>z;
    add(x,y,z);
    add(y,x,z);
  }
  dep[1]=1;
  dfs1(1),dfs2(1,1);
  sort(g+1,g+n+1);
  rt[0]=build(1,n);
  rep(i,1,n){
    sumdis[i]=sumdis[i-1]+dis[g[i].second];
    totdis[i]=totdis[i-1]+1;
    rt[i]=rt[i-1];
    int x=g[i].second;
    while(top[x]!=1){
      rt[i]=insert(rt[i],dfn[top[x]],dfn[x]);
      x=fa[top[x]];
    }
    rt[i]=insert(rt[i],dfn[1],dfn[x]);
  }
  while(Q--){
    int u,a,b;
    cin>>u>>a>>b;
    a=(a+ans%A)%A;
    b=(b+ans%A)%A;
    if(a>b)swap(a,b);
    a=lower_bound(g+1,g+n+1,make_pair(a,0))-g; 
    b=upper_bound(g+1,g+n+1,make_pair(b,INT_MAX))-g-1;
    cout<<(ans=ask(u,b)-ask(u,a-1))<<endl;
  }
}
```

---

## 作者：Diaоsi (赞：1)

[[HNOI2015]开店](https://www.luogu.com.cn/problem/P3241)

动态点分治 + ```std::vector``` 

题意可以转化为求所有的点权在 $l\sim r$ 之间的节点到当前询问点的距离和。

根据一般动态点分治的套路，我们需要记录下当前分治块中各个节点对分治中心的贡献，通常为了方便容斥，还要记录当前分治块中各个节点对上层分治中心的贡献，而上层分治中心就是当前分治中心在点分树上的父亲。

在此题中，节点对分治中心的贡献就是当前节点到分治中心的距离，而为了处理点权大小这一维的限制，可以采用一些数据结构进行维护。

观察到点权可能很大，用以点权为下标的数据结构很难维护（需要动态开点），但是由于题目不带修改，考虑用 ```std::vector``` 维护。

具体做法是在每层分治中心建立一个 ```std::vector``` 并挂在分治中心上，扫描分治块，对于分治块中的每个点将二元组 $(x,dis)$ 插入 ```std::vector``` ，$x$ 表示点权，$dis$ 表示该点到分治中心的距离。

将当前分治块扫描完之后，把 ```std::vector``` 按照 $x$ 排序并求出排序后 $dis$ 的**后缀和**。

查询时在 $x$ 对应的那一维上二分出第一个小于等于 $l$ 的元素对应下标 $l^\prime$ 和第一个大于 $r$ 元素对应的下标 $r^\prime$。

此时就体现出维护后缀和的优势了，只需要计算 $dis_{l^\prime}-dis_{r^\prime}$ 即可，而维护前缀和需要判断较多的边界条件，为了方便维护，可以插入二元组 $(\inf,0)$。

按照同样的方法，在当前分治块上再开一个 ```std::vector``` ，维护 $(x,dis^\prime)$ ，这里的 $dis^\prime$ 表示的是当前节点到**上一层**分治中心的距离。

根据点分治时间复杂度的证明，$\sum size(x)=\mathcal{O(n \log n)}$，这里的 $size(x)$ 指的是分治块的大小，等于对应的 ```std::vector``` 的大小，所以空间复杂度不会爆炸。

接下来处理询问，根据点分树树高为 $\log n$ 级别的性质，我们从询问点开始逐个向上跳父亲，每到一个分治中心就按照之前的做法计算出当前分治块中满足点权在 $l \sim r$ 之间的点到当前分治中心的距离和，并算出节点数（二分出的下标相减），将距离和加上节点数乘以当前分治中心到询问点的距离就是它们对答案的贡献。

但是这样发现有一些答案被算重了，需要容斥掉询问节点所在的子树对当前分治块的贡献，用先前处理好的点对上层分治中心的贡献对应的 ```std::vector``` 进行计算（注意要加上点数乘距离），方法与处理当前分治块对分治中心的贡献差不多。

但是这样写交上去发现**超时了**。

题目中有一个性质为每个点的度数不超过 3，得将这个性质利用起来。

考虑只维护节点对上层分治中心的贡献，在跳到一个分治中心时暴力扫描并计算每个子树的答案（最多只有三个，注意计算距离的贡献），单独计算分治中心的贡献，累加起来就是答案。

由于只维护了一个 ```std::vector```，所以在点分治预处理时常数会减小一半，在实际测评中有显著提速。

同时建议求距离时使用 $\mathcal{O(1)}$ 的 ST 表求 $\text{lca}$。

分析一下时间复杂度：点分树高为 $\log n$ 级别，每次跳父亲需要 $\log n$ 的时间计算贡献，点分治预处理的时间复杂度为 $\mathcal{O(n \log n)}$ 级别，总的时间复杂度为 $\mathcal{O(n \log^2 n)}$。

既然你能找到这题，我相信你能瞬间做出来的。

```Code:```

```cpp
#include<bits/stdc++.h>
typedef long long LL;
typedef long double LD;
using namespace std;
const LL N=200010,M=2000010,INF=0x3f3f3f3f;
inline LL max(LL x,LL y){return x>y?x:y;}
inline LL min(LL x,LL y){return x<y?x:y;}
inline void swap(LL &x,LL &y){x^=y^=x^=y;}
LL head[N],ver[M],edge[M],Next[M],tot;
LL n,m,t,rt,lastans,d[N],f[N],val[N],vis[N],dist[N],size[N];
LL in[N],out[N],st[N<<2][20],lg[N<<2],ts;
struct node{LL pos,sum;};
bool operator <(node a,node b){
	return a.pos<b.pos;
}
vector<node> v[N];
vector<LL> h[N];
void upd(LL u,LL pos,LL dis){
	v[u].push_back((node){pos,dis});
}
LL ask(LL u,LL l,LL r,LL &fi,LL &se){
	fi=lower_bound(v[u].begin(),v[u].end(),(node){l,0})-v[u].begin();
	se=upper_bound(v[u].begin(),v[u].end(),(node){r,0})-v[u].begin();
	return v[u][fi].sum-v[u][se].sum;
}
void add(LL x,LL y,LL z){
	ver[++tot]=y,edge[tot]=z,Next[tot]=head[x],head[x]=tot;
}
void dfs(LL x,LL fa){
	d[x]=d[fa]+1;
	in[x]=++ts,st[ts][0]=x;
	for(LL i=head[x];i;i=Next[i]){
		LL y=ver[i],z=edge[i];
		if(y==fa)continue;
		dist[y]=dist[x]+z;
		dfs(y,x);
	}
	out[x]=++ts;
	if(fa)st[ts][0]=fa;
}
void init(){
	for(LL i=2;i<=N<<1;i++)lg[i]=lg[i>>1]+1;
	for(LL j=1;(1<<j)<=ts;j++)
		for(LL i=1;i+(1<<j)-1<=ts;i++){
			LL x=st[i][j-1],y=st[i+(1<<(j-1))][j-1];
			st[i][j]=(d[x]<d[y])?x:y;
		}
}
LL lca(LL x,LL y){
	LL l=in[x],r=in[y];
	if(l>r)swap(l,r);LL Lg=lg[r-l+1];
	return d[st[l][Lg]]<d[st[r-(1<<Lg)+1][Lg]]?st[l][Lg]:st[r-(1<<Lg)+1][Lg];
}
LL get(LL x,LL y){
	return dist[x]+dist[y]-2*dist[lca(x,y)];
}
void get_size(LL x,LL fa){
	size[x]=1;
	for(LL i=head[x];i;i=Next[i]){
		LL y=ver[i];
		if(y==fa||vis[y])continue;
		get_size(y,x);
		size[x]+=size[y];
	}
}
void get_rt(LL x,LL fa,LL sum){
	size[x]=1;
	LL flag=1;
	for(LL i=head[x];i;i=Next[i]){
		LL y=ver[i];
		if(y==fa||vis[y])continue;
		get_rt(y,x,sum);
		size[x]+=size[y];
		if(size[y]>sum/2)flag=0;
	}
	if(flag&&sum-size[x]<=sum/2)rt=x;
}
void get_dis(LL x,LL fa,LL dis){
	upd(rt,val[x],dis);
	for(LL i=head[x];i;i=Next[i]){
		LL y=ver[i],z=edge[i];
		if(y==fa||vis[y])continue;
		get_dis(y,x,dis+z);
	}
}
void solve(LL x){
	vis[x]=1;
	for(LL i=head[x];i;i=Next[i]){
		LL y=ver[i],z=edge[i];
		if(vis[y])continue;
		get_size(y,x);
		get_rt(y,x,size[y]);
		f[rt]=x;
		h[x].push_back(rt);
		get_dis(y,x,z);
		solve(rt);
	}
	upd(x,INF,0);
	sort(v[x].begin(),v[x].end());
	for(LL i=v[x].size();i;i--)
		v[x][i-1].sum+=v[x][i].sum;
}
int main(){
	scanf("%lld%lld%lld",&n,&m,&t); 
	for(LL i=1;i<=n;i++)
		scanf("%lld",&val[i]);
	for(LL i=1;i<n;i++){
		LL x,y,z;
		scanf("%lld%lld%lld",&x,&y,&z);
		add(x,y,z),add(y,x,z);
	}
	dfs(1,0);
	init();
	get_rt(1,0,n);
	solve(rt);
	while(m--){
		LL x,a,b,l,r,fi,se;
		scanf("%lld%lld%lld",&x,&a,&b);
		l=(a+lastans)%t;
		r=(b+lastans)%t;
		if(l>r)swap(l,r);
		lastans=0;
		for(LL i=0;i<(LL)h[x].size();i++)
			lastans+=ask(h[x][i],l,r,fi,se);
		for(LL i=x;f[i];i=f[i]){
			LL len=get(x,f[i]);
			for(LL j=0;j<(LL)h[f[i]].size();j++)
				if(h[f[i]][j]!=i)lastans+=ask(h[f[i]][j],l,r,fi,se),lastans+=len*(se-fi);
			if(l<=val[f[i]]&&val[f[i]]<=r)lastans+=len;
		}
		printf("%lld\n",lastans);
	}
	return 0;
}
```



---

## 作者：劉子颺 (赞：1)

一个代码实现毒瘤与别的题解大大的解法

没有使用性质（度数不大于3）

我也不知道这个性质有啥用 边分治复杂度就对了但我又不知道边分治对这种题有啥用

明显建立点分树再建立线段树 按照权值下标建立即可

但是空间复杂度n^logn 有毒

考虑一个$\sum$子树是log级别的

权值许多为空

直接用vector 存下来即可

暴力离散化

查询沿着树向上跳即可

你需要特殊的卡常技巧（以下代码只供参考只保证正确性）

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<vector>
#include<ctime>
using namespace std;
typedef long long LL;
const int N=2e5+100;
const int INF=1e9+7;
inline void read(int &x){
    x=0;
    int f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    x*=f;
}
int n,A,Q;
struct Front_Star{
    int u,v,w,nxt;
}e[N<<2];
int cnt=0;
int first[N];
void add(int u,int v,int w){
    ++cnt;
    e[cnt].u=u;
    e[cnt].v=v;
    e[cnt].w=w;
    e[cnt].nxt=first[u];
    first[u]=cnt;
}
//
int val[N];
int dep[N];
int dis[N];
int dfn[N];
int st[N<<1][21];
int Log2[N<<1];
int dfn_cnt;
void Pre_DFS(int u,int fat,int depth){
    dep[u]=depth;
    dfn[u]=++dfn_cnt;
    st[dfn_cnt][0]=u;
    for(int i=first[u];i;i=e[i].nxt){
        int v=e[i].v;
        if(v==fat)continue;
        dis[v]=dis[u]+e[i].w;
        Pre_DFS(v,u,depth+1);
        st[++dfn_cnt][0]=u;
    }
}
int CheckMin(int x,int y){
    return dep[x]<dep[y]?x:y;
}
void Pre(){
    for(int j=1;j<=20;++j){
        for(int i=1;i+(1<<j)-1<=dfn_cnt;++i){
            st[i][j]=CheckMin(st[i][j-1],st[i+(1<<(j-1))][j-1]);
        }
    }
    for(int i=1;i<=dfn_cnt;++i)Log2[i]=log2(i);
}
int LCA(int x,int y){
    x=dfn[x];
    y=dfn[y];
    if(x>y)swap(x,y);
    int len=Log2[y-x+1];
    return CheckMin(st[x][len],st[y-(1<<len)+1][len]);
}
int Dis(int x,int y){
    return dis[x]+dis[y]-2*dis[LCA(x,y)];
}
//
int root;
int AllNode;
int F[N];
int siz[N];
bool vis[N];
void Get_Root(int x,int fat){
    siz[x]=1;
    int tmp=0;
    for(int i=first[x];i;i=e[i].nxt){
        int v=e[i].v;
        if(v==fat)continue;
        if(vis[v])continue;
        Get_Root(v,x);
        siz[x]+=siz[v];
        tmp=max(tmp,siz[v]);
    }
    tmp=max(tmp,AllNode-siz[x]);
    if(F[root]>tmp)root=x;
    F[x]=tmp;
}
int Par[N];
int rootS[N];
int rootT[N];
int lson[9350344];
int rson[9350344];
LL sum[9350344];
LL Cnt[9350344];
int tot=0;
inline void PushUp(int p){
    sum[p]=0,Cnt[p]=0;
    if(lson[p]){
        sum[p]=sum[p]+sum[lson[p]];
        Cnt[p]=Cnt[p]+Cnt[lson[p]];
    }
    if(rson[p]){
        sum[p]=sum[p]+sum[rson[p]];
        Cnt[p]=Cnt[p]+Cnt[rson[p]];	
    }
}
inline void Update(int &p,int l,int r,int pos,int v){
    if(!p)p=++tot;
    if(l==r){sum[p]+=v;Cnt[p]+=1;return;}
    int mid=(l+r)>>1;
    if(pos<=mid)Update(lson[p],l,mid,pos,v);
    else Update(rson[p],mid+1,r,pos,v);
    PushUp(p);
}
inline pair<LL,LL> Query(int p,int l,int r,int dl,int dr){
    if(!p)return make_pair(0,0);
    if(l>r)return make_pair(0,0); 
    if(dl<=l&&r<=dr){
        return make_pair(sum[p],Cnt[p]);
    }
    int mid=(l+r)>>1;
    pair<LL,LL>ret;
    ret.first=ret.second=0;
    if(dl<=mid){
        pair<LL,LL> now=Query(lson[p],l,mid,dl,dr);
        ret.first=ret.first+now.first;
        ret.second=ret.second+now.second;
    }
    if(mid< dr){
        pair<LL,LL> now=Query(rson[p],mid+1,r,dl,dr);
        ret.first=ret.first+now.first;
        ret.second=ret.second+now.second;		
    }
    return ret;
}
struct Node{
	int pos;
	LL v;
	Node(int _pos=0,LL _v=0):pos(_pos),v(_v){}
	friend bool operator < (Node A,Node B){
		return A.pos<B.pos;
	}
};
vector<Node>S[N],T[N];
vector<int>mmpS[N],mmpT[N];
void GetDep(int x,int fat,int P){
	S[P].push_back(Node(val[x],Dis(x,P)));
	T[P].push_back(Node(val[x],Dis(x,Par[P])));
    for(int i=first[x];i;i=e[i].nxt){
        int v=e[i].v;
        if(v==fat)continue;
        if(vis[v])continue;
        GetDep(v,x,P);
    }
}
void Divide(int x,int fat){
    vis[x]=1;
    Par[x]=fat;
    GetDep(x,0,x);
    for(int i=first[x];i;i=e[i].nxt){
        int v=e[i].v;
        if(v==fat)continue;
        if(vis[v])continue;
        root=0;
        AllNode=siz[v];
        Get_Root(v,0);
        Divide(root,x);
    }	
}

long long TIME=0;

LL GetAns(int u,int L,int R){
    LL ret=0;
    for(int i=u;i;i=Par[i]){
    	int l=lower_bound(mmpS[i].begin()+1,mmpS[i].begin()+1+mmpS[i][0],L)-mmpS[i].begin();
    	int r=upper_bound(mmpS[i].begin()+1,mmpS[i].begin()+1+mmpS[i][0],R)-mmpS[i].begin()-1;
		pair<LL,LL> now=Query(rootS[i],1,mmpS[i][0],l,r);
        ret=ret+now.second*Dis(i,u)+now.first;
    }
    for(int i=u;Par[i];i=Par[i]){
    	int l=lower_bound(mmpT[i].begin()+1,mmpT[i].begin()+1+mmpT[i][0],L)-mmpT[i].begin();
    	int r=upper_bound(mmpT[i].begin()+1,mmpT[i].begin()+1+mmpT[i][0],R)-mmpT[i].begin()-1;
		pair<LL,LL> now=Query(rootT[i],1,mmpT[i][0],l,r);
        ret=ret-now.second*Dis(Par[i],u)-now.first;
    }
    return ret;
}
int main(){
	freopen("P3241.in","r",stdin);
	freopen("P3241.out","w",stdout);
    read(n);
    read(Q);
    read(A);
    for(int i=1;i<=n;++i)read(val[i]);
    for(int i=1;i<n;++i){
        int u,v,w;
        read(u);read(v);read(w);
        add(u,v,w);
        add(v,u,w);
    }
    Pre_DFS(1,0,1);
    Pre();
    AllNode=n;
    F[0]=INF;
    Get_Root(1,0);
    Divide(root,0);
    for(int i=1;i<=n;++i){
    	mmpS[i].resize(S[i].size()+3);
    	mmpS[i][0]=0;
    	for(int j=0;j<S[i].size();++j)mmpS[i][++mmpS[i][0]]=S[i][j].pos;
		mmpS[i][++mmpS[i][0]]=INF;
		mmpS[i][++mmpS[i][0]]=0;		
		sort(mmpS[i].begin()+1,mmpS[i].begin()+mmpS[i][0]+1);
		mmpS[i][0]=unique(mmpS[i].begin()+1,mmpS[i].begin()+mmpS[i][0]+1)-mmpS[i].begin()-1;
		for(int j=0;j<S[i].size();++j){
			Node now=S[i][j];
			now.pos=lower_bound(mmpS[i].begin()+1,mmpS[i].begin()+mmpS[i][0]+1,now.pos)-mmpS[i].begin();
			Update(rootS[i],1,mmpS[i][0],now.pos,now.v);
		}
    	if(Par[i]){
    		mmpT[i].resize(T[i].size()+3);
			mmpT[i][0]=0;
			for(int j=0;j<T[i].size();++j)mmpT[i][++mmpT[i][0]]=T[i][j].pos;
			mmpT[i][++mmpT[i][0]]=INF;
			mmpT[i][++mmpT[i][0]]=0;
			sort(mmpT[i].begin()+1,mmpT[i].begin()+mmpT[i][0]+1);
			mmpT[i][0]=unique(mmpT[i].begin()+1,mmpT[i].begin()+mmpT[i][0]+1)-mmpT[i].begin()-1;		
			for(int j=0;j<T[i].size();++j){
				Node now=T[i][j];
				now.pos=lower_bound(mmpT[i].begin()+1,mmpT[i].begin()+mmpT[i][0]+1,now.pos)-mmpT[i].begin();
				Update(rootT[i],1,mmpT[i][0],now.pos,now.v);
			}
		}
	}
    LL lastans=0;
    while(Q--){
        int u,a,b;
        read(u);
        read(a);
        read(b);
        int L=min((a+lastans)%A,(b+lastans)%A);
        int R=max((a+lastans)%A,(b+lastans)%A);
        cout<<(lastans=GetAns(u,L,R))<<'\n';
    }
    return 0;
}
```


---


# 【模板】动态树（LCT）

## 题目描述

给定 $n$ 个点以及每个点的权值，要你处理接下来的 $m$ 个操作。  
操作有四种，操作从 $0$ 到 $3$ 编号。点从 $1$ 到 $n$ 编号。


- `0 x y` 代表询问从 $x$ 到 $y$ 的路径上的点的权值的 $\text{xor}$ 和。保证 $x$ 到 $y$ 是联通的。
- `1 x y` 代表连接 $x$ 到 $y$，若 $x$ 到 $y$ 已经联通则无需连接。
- `2 x y` 代表删除边 $(x,y)$，不保证边 $(x,y)$ 存在。
- `3 x y` 代表将点 $x$ 上的权值变成 $y$。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证：
- $1 \leq n \leq 10^5$，$1 \leq m \leq 3 \times 10^5$，$1 \leq a_i \leq 10^9$。
- 对于操作 $0, 1, 2$，保证 $1 \leq x, y \leq n$。
- 对于操作 $3$，保证 $1 \leq x \leq n$，$1 \leq y \leq 10^9$。


## 样例 #1

### 输入

```
3 3 
1
2
3
1 1 2
0 1 2 
0 1 1```

### 输出

```
3
1
```

## 样例 #2

### 输入

```
5 14
114
514
19
19
810
1 1 2
0 1 2
2 1 2
1 1 2
1 2 3
2 1 3
1 1 3
1 4 5
1 2 5
0 3 5
0 3 4
3 5 233333
0 1 5
0 2 5
```

### 输出

```
624
315
296
232709
232823
```

# 题解

## 作者：FlashHu (赞：421)

博客太长啦！于是将重要的部分留在题解中，LCT的概念、三个基本性质等更多内容可以参考[我的博客LCT总结](http://www.cnblogs.com/flashhu/p/8324551.html)

## $access(x)$
LCT核心操作，也是最难理解的操作。其它所有的操作都是在此基础上完成的。

因为性质3，我们不能总是保证两个点之间的路径是直接连通的（在一个Splay上）。

access即定义为打通根节点到指定节点的实链，使得一条中序遍历以根开始、以指定点结束的Splay出现。

~~蒟蒻深知没图的痛苦qwq~~

所以还是来几张图吧。

下面的图片参考[YangZhe的论文](https://wenku.baidu.com/view/75906f160b4e767f5acfcedb)

有一棵树，假设一开始实边和虚边是这样划分的（虚线为虚边）

![](http://images2017.cnblogs.com/blog/1309909/201801/1309909-20180123095924037-1618037447.png)

那么所构成的LCT可能会长这样（绿框中为一个Splay，可能不会长这样，但只要满足中序遍历按深度递增（性质1）就对结果无影响）

![](http://images2017.cnblogs.com/blog/1309909/201801/1309909-20180123095955350-1680422636.png)

现在我们要$access(N)$，把$A-N$的路径拉起来变成一条Splay。

因为性质2，该路径上其它链都要给这条链让路，也就是把每个点到该路径以外的实边变虚。

所以我们希望虚实边重新划分成这样。

![](http://images2017.cnblogs.com/blog/1309909/201801/1309909-20180123101901740-2118178734.png)

然后怎么实现呢？

我们要一步步往上拉。

首先把$splay(N)$，使之成为当前Splay中的根。

为了满足性质2，原来$N-O$的重边要变轻。

因为按深度$O$在$N$的下面，在Splay中$O$在$N$的右子树中，所以直接单方面将$N$的右儿子置为$0$（认父不认子）

然后就变成了这样——

![](http://images2017.cnblogs.com/blog/1309909/201801/1309909-20180123110136115-1112016464.png)

我们接着把$N$所属Splay的虚边指向的$I$（在原树上是$L$的父亲）也转到它所属Splay的根，$splay(I)$。

原来在$I$下方的重边$I-K$要变轻（同样是将右儿子去掉）。

这时候$I-L$就可以变重了。因为$L$肯定是在$I$下方的（刚才$L$所属Splay指向了$I$），所以I的右儿子置为$N$，满足性质1。

然后就变成了这样——

![](http://images2017.cnblogs.com/blog/1309909/201801/1309909-20180123110156272-1242463729.png)

$I$指向$H$，接着$splay(H)$，$H$的右儿子置为$I$。

![](http://images2017.cnblogs.com/blog/1309909/201801/1309909-20180123110209772-2057141058.png)

$H$指向$A$，接着$splay(A)$，$A$的右儿子置为$H$。

![](http://images2017.cnblogs.com/blog/1309909/201801/1309909-20180123110213709-49169640.png)

$A-N$的路径已经在一个Splay中了，大功告成！

代码其实很简单。。。。。。循环处理，只有四步——
1. 转到根；
2. 换儿子；
3. 更新信息；
4. 当前操作点切换为轻边所指的父亲，转1

```cpp
inline void access(int x){
	for(int y=0;x;y=x,x=f[x])
		splay(x),c[x][1]=y,pushup(x);//儿子变了，需要及时上传信息
}
```
## $makeroot(x)$
只是把根到某个节点的路径拉起来并不能满足我们的需要。更多时候，我们要获取指定两个节点之间的路径信息。

然而一定会出现路径不能满足按深度严格递增的要求的情况。根据性质1，这样的路径不能在一个Splay中。

Then what can we do?

$makeroot$定义为换根，让指定点成为原树的根。

这时候就利用到$access(x)$和Splay的翻转操作。

$access(x)$后$x$在Splay中一定是深度最大的点对吧。

$splay(x)$后，$x$在Splay中将没有右子树（性质1）。于是翻转整个Splay，使得所有点的深度都倒过来了，$x$没了左子树，反倒成了深度最小的点（根节点），达到了我们的目的。

代码
```cpp
inline void pushr(int x){//Splay区间翻转操作
    swap(c[x][0],c[x][1]);
    r[x]^=1;//r为区间翻转懒标记数组
}
inline void makeroot(int x){
    access(x);splay(x);
    pushr(x);
}
```
关于pushdown和makeroot的一个相关的小问题详见下方update（关于pushdown的说明）

## $findroot(x)$
找$x$所在原树的树根，主要用来判断两点之间的连通性（findroot(x)==findroot(y)表明$x,y$在同一棵树中）

代码：
```cpp
inline int findroot(R x){
    access(x); splay(x);
    while(c[x][0])pushdown(x),x=c[x][0];
//如要获得正确的原树树根，一定pushdown！详见下方update（关于findroot中pushdown的说明）
    splay(x);//保证复杂度
    return x;
}
```
同样利用性质1，不停找左儿子，因为其深度一定比当前点深度小。

## $split(x,y)$

神奇的$makeroot$已经出现，我们终于可以访问指定的一条在原树中的链啦！

split(x,y)定义为拉出$x-y$的路径成为一个Splay（本蒟蒻以$y$作为该Splay的根）

代码
```cpp
inline void split(int x,int y){
    makeroot(x);
    access(y);splay(y);
}
```
x成为了根，那么x到y的路径就可以用$access(y)$直接拉出来了，将y转到Splay根后，我们就可以直接通过访问$y$来获取该路径的有关信息

## $link(x,y)$

连一条$x-y$的边（本蒟蒻使$x$的父亲指向$y$，连一条轻边）

代码
```cpp
inline bool link(int x,int y){
    makeroot(x);
    if(findroot(y)==x)return 0;//两点已经在同一子树中，再连边不合法
    f[x]=y;
    return 1;
}
```
如果题目保证连边合法，代码就可以更简单
```cpp
inline void link(int x,int y){
    makeroot(x);
    f[x]=y;
}
```
## $cut(x,y)$

将$x-y$的边断开。

如果题目保证断边合法，倒是很方便。

使$x$为根后，$y$的父亲一定指向$x$，深度相差一定是$1$。当$access(y),splay(y)$以后，$x$一定是$y$的左儿子，直接双向断开连接
```cpp
inline void cut(int x,int y){
    split(x,y);
    f[x]=c[y][0]=0;
    pushup(y);//少了个儿子，也要上传一下
}
```
那如果不一定存在该边呢？

充分利用好Splay和LCT的各种基本性质吧！

正确姿势——先判一下连通性（注意$findroot(y)$以后$x$成了根），再看看$x,y$是否有父子关系，还要看$y$是否有左儿子。

因为$access(y)$以后，假如y与x在同一Splay中而没有直接连边，那么这条路径上就一定会有其它点，在中序遍历序列中的位置会介于$x$与$y$之间。

那么可能$y$的父亲就不是$x$了。

也可能$y$的父亲还是$x$，那么其它的点就在$y$的左子树中

```cpp
inline bool cut(int x,int y){
	makeroot(x);
	if(findroot(y)!=x||f[y]!=x||c[y][0])return 0;
	f[y]=c[x][1]=0;//x在findroot(y)后被转到了根
	pushup(x);
	return 1;
}
```
如果维护了$size$，还可以换一种判断
```cpp
inline bool cut(int x,int y){
    makeroot(x);
    if(findroot(y)!=x||sz[x]>2)return 0;
    f[y]=c[x][1]=0;
    pushup(x);
    return 1;
}
```
解释一下，如果他们有直接连边的话，$access(y)$以后，为了满足性质1，该Splay只会剩下$x,y$两个点了。

反过来说，如果有其它的点，$size$不就大于$2$了么？

 ---

其实，还有一些LCT中的Splay的操作，跟我们以往学习的纯Splay的某些操作细节不甚相同。

包括$splay(x),rotate(x),nroot(x)$（看到许多版本LCT写的是$isroot(x)$，但我觉得反过来会方便些）

这些区别之处详见下面的模板题注释。

### update（关于findroot中pushdown的说明）
蒟蒻真的一时没注意这个问题。。。。。。Splay根本没学好

找根的时候，当然不能保证Splay中到根的路径上的翻转标记全放掉。

所以最好把pushdown写上。

[Candy巨佬的总结](https://www.cnblogs.com/candy99/p/6271344.html)对pushdown问题有详细的分析

只不过蒟蒻后来经常习惯这样判连通性（~~我也不知道怎么养成的~~）
```cpp
makeroot(x);
if(findroot(y)==x)//后续省略
```
这样好像没出过问题，那应该可以证明是没问题的（makeroot保证了x在LCT的顶端，access(y)+splay(y)以后，假如x,y在一个Splay里，那x到y的路径一定全部放完了标记）

导致很久没有发现错误。。。。。。

另外提一下，假如LCT题目在维护连通性的情况中只可能出现合并而不会出现分离的话，其实可以用并查集哦！（实践证明findroot很慢）

这样的例子有不少，比如“维护链上的边权信息”部分的两道题都是的。

甚至听到Julao们说有少量题目还专门卡这个常数。。。。。。[XZY巨佬的博客](https://www.zybuluo.com/xzyxzy/note/1027479)就提到了

### update（关于pushdown的说明）
我pushdown和makeroot有时候会这样写，常数小一点
```cpp
void pushdown(int x){
    if(r[x]){
        r[x]=0;
        int t=c[x][0];
        r[c[x][0]=c[x][1]]^=1;
        r[c[x][1]=t]^=1;
    }
}
void makeroot(int x){
    access(x);splay(x);
    r[x]^=1;
}
```
这种写法等于说当x有懒标记时，x的左右儿子还是反的

~~那么如果findroot里实在要写pushdown，那么这种pushdown就会出现问题~~（参考cnblogs评论区@ zjp_shadow巨佬的指正）

**再次update，蒟蒻发现这种问题还是可以避免的，若用这种pushdown，findroot可以写，这样写就好啦**

```cpp
inline int findroot(int x){
    access(x);splay(x);
    pushdown(x);
    while(lc)pushdown(x=lc);
    splay(x);
    return x;
}
```
所以此总结以及下面模板里的pushdown，常数大了一点点，却是更稳妥、严谨的写法
```cpp
//pushr同上方makeroot部分
void pushdown(int x){
    if(r[x]){
        if(c[x][0])pushr(c[x][0]);//copy自模板，然后发现if可以不写
        if(c[x][1])pushr(c[x][1]);
        r[x]=0;
    }
}
void makeroot(int x){
    access(x);splay(x);
    pushr(x);//可以看到两种写法造成makeroot都是不一样的
}
```
这种写法等于说当x有懒标记时，x的左右儿子已经放到正确的位置了，只是儿子的儿子还是反的

那么这样就不会出问题啦

两种写法差别还确实有点大呢

当题目中维护的信息与左右儿子顺序有关的时候，pushdown如果用这种不严谨写法会是错的

比如[NOI2005]维护数列（这是Splay题）和洛谷P3613 睡觉困难综合征

## 代码
最基本的LCT操作都在这里，也没有更多额外的复杂操作了，确实很模板。
```cpp
#include<bits/stdc++.h>
#define R register int
#define I inline void
#define G if(++ip==ie)if(fread(ip=buf,1,SZ,stdin))
#define lc c[x][0]
#define rc c[x][1]
using namespace std;
const int SZ=1<<19,N=3e5+9;
char buf[SZ],*ie=buf+SZ,*ip=ie-1;
inline int in(){
	G;while(*ip<'-')G;
	R x=*ip&15;G;
	while(*ip>'-'){x*=10;x+=*ip&15;G;}
	return x;
}
int f[N],c[N][2],v[N],s[N],st[N];
bool r[N];
inline bool nroot(R x){//判断节点是否为一个Splay的根（与普通Splay的区别1）
	return c[f[x]][0]==x||c[f[x]][1]==x;
}//原理很简单，如果连的是轻边，他的父亲的儿子里没有它
I pushup(R x){//上传信息
	s[x]=s[lc]^s[rc]^v[x];
}
I pushr(R x){R t=lc;lc=rc;rc=t;r[x]^=1;}//翻转操作
I pushdown(R x){//判断并释放懒标记
	if(r[x]){
		if(lc)pushr(lc);
		if(rc)pushr(rc);
		r[x]=0;
	}
}
I rotate(R x){//一次旋转
	R y=f[x],z=f[y],k=c[y][1]==x,w=c[x][!k];
	if(nroot(y))c[z][c[z][1]==y]=x;c[x][!k]=y;c[y][k]=w;//额外注意if(nroot(y))语句，此处不判断会引起致命错误（与普通Splay的区别2）
	if(w)f[w]=y;f[y]=x;f[x]=z;
	pushup(y);
}
I splay(R x){//只传了一个参数，因为所有操作的目标都是该Splay的根（与普通Splay的区别3）
	R y=x,z=0;
	st[++z]=y;//st为栈，暂存当前点到根的整条路径，pushdown时一定要从上往下放标记（与普通Splay的区别4）
	while(nroot(y))st[++z]=y=f[y];
	while(z)pushdown(st[z--]);
	while(nroot(x)){
		y=f[x];z=f[y];
		if(nroot(y))
			rotate((c[y][0]==x)^(c[z][0]==y)?x:y);
		rotate(x);
	}
	pushup(x);
}
/*当然了，其实利用函数堆栈也很方便，代替上面的手工栈，就像这样
I pushall(R x){
	if(nroot(x))pushall(f[x]);
	pushdown(x);
}*/
I access(R x){//访问
	for(R y=0;x;x=f[y=x])
		splay(x),rc=y,pushup(x);
}
I makeroot(R x){//换根
	access(x);splay(x);
	pushr(x);
}
int findroot(R x){//找根（在真实的树中的）
	access(x);splay(x);
	while(lc)pushdown(x),x=lc;
	splay(x);
	return x;
}
I split(R x,R y){//提取路径
	makeroot(x);
	access(y);splay(y);
}
I link(R x,R y){//连边
	makeroot(x);
	if(findroot(y)!=x)f[x]=y;
}
I cut(R x,R y){//断边
	makeroot(x);
	if(findroot(y)==x&&f[y]==x&&!c[y][0]){
		f[y]=c[x][1]=0;
		pushup(x);
	}
}
int main()
{
	R n=in(),m=in();
	for(R i=1;i<=n;++i)v[i]=in();
	while(m--){
		R type=in(),x=in(),y=in();
		switch(type){
		case 0:split(x,y);printf("%d\n",s[y]);break;
		case 1:link(x,y);break;
		case 2:cut(x,y);break;
		case 3:splay(x);v[x]=y;//先把x转上去再改，不然会影响Splay信息的正确性
		}
	}
	return 0;
}
```

---

## 作者：tzc_wk (赞：49)

> P3690 动态树模板

> 有 $n$ 个点，有点权。初始没有边，需要维护以下几个操作：

> - 询问路径权值异或
> - 在两点间连边，如果在一个联通块中则不连
> - 删边，如果没有边则不删
> - 改变一个点的权值

> $1 \leq n \leq 10^5$，$1 \leq m \leq 3 \times 10^5$

动态树，又称 LCT，全称 Link-Cut-Tree

前芝知识：

1. Splay
2. 重链剖分
3. 并查集

## LCT 能干吗？

LCT 可以维护一个有根树森林，支持对树的分割（cut），合并（link）等操作的问题。

通俗地来讲：它支持以下操作：

- 查询两点之间路径上的信息（如和、异或和等）
- 连边
- 删边
- 动态维护连通性

## LCT 怎么实现？

首先，学过重链剖分的应该知道，链剖分分为三类：重链剖分、实链剖分和长链剖分。它们的共同思想是把一棵树划分成若干条不相交的链，满足

1. 每一个点恰好属于一条链
2. 在同一条链中不存在深度相同的点

这样我们就可以把两点之间的路径转化为若干条链上的区间，可以大大减小操作次数。

关于重链剖分，实际上是根据子树的大小将每条边划分为“重边”和“轻边”，进而实现链剖分的。

关于长链剖分，由于没学过，我们也不敢乱说。

关于实链剖分，实际上是把每条边划分为“实边”和“虚边”。即你可以指定每个点一个“实儿子”，其它儿子为“虚儿子”，如果将每个点与它的实儿子连起来就可以形成实边，除实边之外的边是虚边，将实边连起来可以得到若干条实链。

区别于重链剖分的是每条边的虚实是可以动态变化的，而重链剖分，一旦遇到树的形态发生变化，就彻底萎了。

是不是听起来非常简单？不过，实链剖分最坏情况下还是 $\mathcal O(n)$ 的，这样算上查询复杂度，就会变成 $\mathcal O(n^2)$！！！

不过，如果用强大的 $\texttt{splay}$ 维护实链剖分，就可以得到均摊 $\mathcal O(logn)$ 的 LCT。

我们对于每一个实链，建一棵 $\texttt{splay}$ 里面包含所有这条链里的节点。这颗 $\texttt{splay}$ 的中序遍历恰好按照这个链中每个节点的深度排序。即链顶（深度最小的点）位于中序遍历的第一位，链底（深度最大的点）位于中序遍历的最后一位。

当然，由于这棵树的完整性，我们只需建出一棵 $\texttt{splay}$ 出来，具体见下方说明。

例如有一棵树如下图，根为 $1$：

![](https://cdn.luogu.com.cn/upload/image_hosting/b27e3vhn.png)

那么我们就可以将它分成如下的链：（绿色表示实边，红色表示虚边）：

![](https://cdn.luogu.com.cn/upload/image_hosting/to8yymmx.png)

这棵树中 $6$ 条链分别是

- $\{1,2\}$

- $\{3,6,8\}$

- $\{4\}$

- $\{5\}$

- $\{7,9\}$

- $\{10\}$

那么我们考虑这样建 $\texttt{splay}$。

以路径 $\{3,6,8\}$ 为例，节点 $3$ 认一个父亲 $1$，但是 $1$ 却不认这个儿子。他只有一个儿子 $2$。当然，$2$ 也认这个父亲。

从此我们可以看出**虚边只有儿子认父亲，父亲不认儿子。而实边儿子认父亲，父亲也认儿子。**

上述图建成 $\texttt{splay}$ 就是下图（一个手滑涂反了，绿色表示虚边，红色表示实边）：

![](https://cdn.luogu.com.cn/upload/image_hosting/tebepivc.png)

简单来说就是：**一棵实子树表示一条链上的信息**。例如 $6$ 的实子树就表示了 $3 \leftrightarrow 6 \leftrightarrow 8$ 这条链上的信息。

当然，除了实子树还有虚子树。通过观察我们可以发现 $\texttt{splay}$ 中一个节点 $x$ 的子树（不论虚实）包含了三个部分：

- 左子树，在原树中是 $x$ 的父亲及其祖先。

- 右子树，在原树中是 $x$ 所在的链中，$x$ 下方的节点

- 虚子树，包含了 $x$ 的虚儿子及其子树中的节点。

掌握了 $\texttt{splay}$ 的构造，就要讲讲 LCT 的代码实现：

首先是节点信息与 $pushup$，学过 $\texttt{splay}$ 的应该都不是太难理解：

```cpp
struct node{
	int f,ls,rs,val,sum;
} s[100005];
inline void pushup(int k){
	s[k].sum=s[s[k].ls].sum^s[s[k].rs].sum^s[k].val;//维护子树异或和
}
```

$f$ 表示节点 $i$ 的父亲，$ls,rs$ 表示左右儿子，$val$ 表示节点上的值，$sum$ 表示异或和。

接下来是 $identify$ 与 $connect$，$identify(x)$ 表示 $x$ 是 $x$ 的父亲的左儿子还是右儿子。与普通的 $\texttt{splay}$ 不同的一点是如果 $x$ 是当前所在 $\texttt{splay}$ 的根那么返回 $-1$。

```cpp
inline int identify(int k){
	if(s[s[k].f].ls==k)	return 0;
	if(s[s[k].f].rs==k)	return 1;
	return -1;
}
inline void connect(int k,int f,int op){
	s[k].f=f;
	if(op==1)	s[f].rs=k;
	if(op==0)	s[f].ls=k;
}
```

$rotate$ 与 $splay$ 函数，也有些不同：

```cpp
inline void rotate(int x){
	int y=s[x].f;
	int z=s[y].f;
	int opy=identify(y);
	int opx=identify(x);
	int u=0;
	if(opx==1)		u=s[x].ls;
	if(opx==0)		u=s[x].rs;
	connect(u,y,opx);
	connect(y,x,opx^1);
	connect(x,z,opy);
	pushup(y);
	pushup(x);
}
inline void splay(int k){
	while(identify(k)!=-1){
		register int up=s[k].f;
		if(identify(up)==-1)				rotate(k);
		else if(identify(k)==identify(up))	rotate(up),rotate(k);
		else								rotate(k),rotate(k);
	}
}
```

常规操作讲完了，接下来是 LCT 的重头戏：

$access(x)$：打通 $x$ 到整棵树的根节点（注意：不是 $x$ 所在的 $\texttt{splay}$ 的根节点）的路径并把它们打包成一个 $\texttt{splay}$，并自动把其他边设为虚边。

例如如果我们想打通 $10$ 到根的路径，那么这张图就变成了这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/aako07vc.png)

这时候我们想到了 $\texttt{splay}$ 的基础操作 $splay$，将一个点转到他所在的 $\texttt{splay}$ 的根节点（不要搞混淆，是**所在 $\texttt{splay}$ 的根节点**，跟之前那个不同）

我们从下往上跳（在这个例子中就是 $9 \rightarrow 7 \rightarrow 6 \rightarrow 3 \rightarrow 1$），我们先把 $9$ 旋转到所在 $\texttt{splay}$ 的根节点，然后把它的右儿子设为 $0$。由于我们把 $9$ 到根打包成一个 $\texttt{splay}$，所以原来 $9$ 的实儿子就变成了虚儿子。

同理，把 $7$ 旋转到它所在的 $\texttt{splay}$ 的根节点，然后将它的右儿子设为下一层节点 $9$。同理，把 $6$ 旋转到它所在的 $\texttt{splay}$ 的根节点，然后将它的右儿子设为下一层节点 $7$。以此类推就行了。

简单来说只有以下几步：

1. 转到 $\texttt{splay}$ 根节点
2. 改变右儿子的值，换为下一层节点
3. 更新信息
4. 往上跳

代码：
```cpp
inline void access(int k){
	int l=0;
	while(k){
		splay(k);
		s[k].rs=l;
		pushup(k);
		l=k;
		k=s[k].f;
	}
}
```

有了强大的 $access$ 操作，就可以引申出许多其它类型的操作了：

$makeroot(x)$：将 $x$ 号节点设为所在联通块的根。

首先打通 $x$ 到当前所在根节点的路径，那么此时 $x$ 一定是这个 $\texttt{splay}$ 中深度最大的，位于中序遍历的最后一位。

但是因为我们把它设为根节点（深度为 $0$），所以它就变为了这个 $\texttt{splay}$ 中深度最小的点。

同理，原本 $x$ 号节点的父亲应该是 $\texttt{splay}$ 中深度第二大的节点，即排在中序遍历的倒数第二位。现在经你这么一 $makeroot$，变成了 $x$ 的儿子，深度为 $1$，处于中序遍历的第二位。

想到了什么？

翻转。维护翻转的懒标记，记为 $lz$。

具体来说，就是打通 $x$ 到根的路径，把 $x$ 转到根节点，给 $x$ 打标记。

```cpp
struct node{
	int f,ls,rs,val,sum,lz;
} s[100005];
inline void pushdown(int k){
	if(s[k].lz){
		swap(s[k].ls,s[k].rs);
		if(s[k].ls)	s[s[k].ls].lz^=1;
		if(s[k].rs)	s[s[k].rs].lz^=1;
		s[k].lz=0;
	}
}
inline void makeroot(int k){
	access(k);
	splay(k);
	swap(s[k].ls,s[k].rs);//打标记
	if(s[k].ls)	s[s[k].ls].lz^=1;
	if(s[k].rs)	s[s[k].rs].lz^=1;
}
```

另外，在将一个节点旋转到根的时候，需要将根到 $x$ 的路径上所有点依次 $pushdown$，即下面的 $pushall$ 函数：

```cpp
inline void pushall(int x){
	if(identify(x)!=-1)	pushall(s[x].f);
	pushdown(x);
}
```

并在 $splay$ 函数第一行加上

```cpp
pushall(k);
```

$split(x,y)$：把 $x - y$ 的路径拉成一个 $\texttt{splay}$。

有了 $makeroot$ 和 $access$，这个操作就显得轻而易举了。分别执行 $makeroot(x)$，$access(y)$，$splay(y)$ 三步就可以搞定了。

```cpp
inline void split(int x,int y){
	makeroot(x);
	access(y);splay(y);
}
```

$findroot(x)$：查找 $x$ 所在联通块的根

先打通 $x$ 到根节点的路径并把 $x$ 旋到 $\texttt{splay}$ 的根，由于根节点是这个 $\texttt{splay}$ 中深度最小的，所以我们就不停的往它的左儿子方向跳。注意每跳一步就 $pushdown$。

```cpp
inline int findroot(int k){
	access(k);
	splay(k);
	while(s[k].ls)	pushdown(k),k=s[k].ls;
	splay(k);
	return k;
}
```

$link(x,y)$：在 $x$ 与 $y$ 之间连边

类似并查集，判断是否在一个联通块。如果不在，就指定其中一个点的父亲为另一个点，即连一条虚边。

```cpp
inline void link(int x,int y){
	makeroot(x);
	if(findroot(y)==x)	return;
	s[x].f=y;
}
```

$cut(x,y)$：将 $(x,y)$ 边断开

这应该是比较难理解的操作了。

首先，需要判断 $x,y$ 是否在一个联通块。如果 $findroot(x) \neq findroot(y)$，那么直接跳出去。

否则，先把 $x-y$ 拉成一个 $\texttt{splay}$。由于在 $split$ 的代码中我们指定 $x$ 为联通块的根，$y$ 为 $\texttt{splay}$ 的根，因此 $x,y$ 之间有边当且仅当它们深度差为 $1$，即在 $\texttt{splay}$ 的中序遍历中相邻。这需要满足两个条件：

1. $x$ 的父亲为 $y$，因为一定是先访问 $y$ 的左儿子紧接着访问 $y$。
2. $x$ 不能有右子树。不然访问完 $x$ 之后一定会访问 $x$ 的右子树。

```cpp
inline bool cut(int x,int y){
	if(findroot(x)!=findroot(y))	return 0;
	split(x,y);
	if(s[x].f!=y||s[x].rs)		return 0;
	s[x].f=s[y].ls=0;
	pushup(x);
	return 1;
}
```

查询操作：首先把 $x-y$ 拉成一个 $\texttt{splay}$，由于 LCT 中一个 $\texttt{splay}$ 的子树维护一条链上的信息，因此我们只需返回这个 $\texttt{splay}$ 的根节点，即 $y$ 号节点的 $sum$ 值就是结果。

模板题完整代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fi			first
#define se			second
#define fz(i,a,b)	for(int i=a;i<=b;i++)
#define fd(i,a,b)	for(int i=a;i>=b;i--)
#define foreach(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)
#define all(a)		a.begin(),a.end()
#define giveup(...) return printf(__VA_ARGS__),0;
#define fill0(a)	memset(a,0,sizeof(a))
#define fill1(a)	memset(a,-1,sizeof(a))
#define fillbig(a)	memset(a,0x3f,sizeof(a))
#define fillsmall(a) memset(a,0xcf,sizeof(a))
#define mask(a)		(1ll<<(a))
#define maskx(a,x)	((a)<<(x))
#define _bit(a,x)	(((a)>>(x))&1)
#define _sz(a)		((int)(a).size())
#define filei(a)	freopen(a,"r",stdin);
#define fileo(a)	freopen(a,"w",stdout);
#define fileio(a) 	freopen(a".in","r",stdin);freopen(a".out","w",stdout)
#define eprintf(...) fprintf(stderr,__VA_ARGS__)
#define put(x)		putchar(x)
#define eoln        put('\n')
#define space		put(' ')
#define y1			y_chenxiaoyan_1
#define y0			y_chenxiaoyan_0
typedef pair<int,int> pii;
inline int read(){
	int x=0,neg=1;char c=getchar();
	while(!isdigit(c)){
		if(c=='-')	neg=-1;
		c=getchar();
	}
	while(isdigit(c))	x=x*10+c-'0',c=getchar();
	return x*neg;
}
inline void print(int x){
	if(x<0){
		putchar('-');
		print(abs(x));
		return;
	}
	if(x<=9)	putchar(x+'0');
	else{
		print(x/10);
		putchar(x%10+'0');
	}
}
inline int qpow(int x,int e,int _MOD){
	int ans=1;
	while(e){
		if(e&1)	ans=ans*x%_MOD;
		x=x*x%_MOD;
		e>>=1;
	}
	return ans;
}
struct LCT{
	struct node{
		int f,ls,rs,val,sum,lz;
	} s[100005];
	inline void pushup(int k){
		s[k].sum=s[s[k].ls].sum^s[s[k].rs].sum^s[k].val;
	}
	inline void pushdown(int k){
		if(s[k].lz){
			swap(s[k].ls,s[k].rs);
			if(s[k].ls)	s[s[k].ls].lz^=1;
			if(s[k].rs)	s[s[k].rs].lz^=1;
			s[k].lz=0;
		}
	}
	inline int identify(int k){
		if(s[s[k].f].ls==k)	return 0;
		if(s[s[k].f].rs==k)	return 1;
		return -1;
	}
	inline void connect(int k,int f,int op){
		s[k].f=f;
		if(op==1)	s[f].rs=k;
		if(op==0)	s[f].ls=k;
	}
	inline void rotate(int x){
		int y=s[x].f;
		int z=s[y].f;
		int opy=identify(y);
		int opx=identify(x);
		int u=0;
		if(opx==1)		u=s[x].ls;
		if(opx==0)		u=s[x].rs;
		connect(u,y,opx);
		connect(y,x,opx^1);
		connect(x,z,opy);
		pushup(y);
		pushup(x);
	}
	inline void pushall(int x){
		if(identify(x)!=-1)	pushall(s[x].f);
		pushdown(x);
	}
	inline void splay(int k){
		pushall(k);
		while(identify(k)!=-1){
			register int up=s[k].f;
//			cout<<k<<" "<<up<<endl;
			if(identify(up)==-1)				rotate(k);
			else if(identify(k)==identify(up))	rotate(up),rotate(k);
			else								rotate(k),rotate(k);
		}
	}
	inline void access(int k){
		int l=0;
		while(k){
			splay(k);
			s[k].rs=l;
			pushup(k);
			l=k;
			k=s[k].f;
		}
	}
	inline void makeroot(int k){
		access(k);
//		puts("-1");
		splay(k);
//		puts("-1");
		swap(s[k].ls,s[k].rs);
		if(s[k].ls)	s[s[k].ls].lz^=1;
		if(s[k].rs)	s[s[k].rs].lz^=1;
	}
	inline int findroot(int k){
		access(k);
		splay(k);
		while(s[k].ls)	pushdown(k),k=s[k].ls;
		splay(k);
		return k;
	}
	inline void split(int x,int y){
		makeroot(x);
		access(y);splay(y);
	}
	inline bool link(int x,int y){
		makeroot(x);
		if(findroot(y)==x)	return 0;
		s[x].f=y;
		return 1;
	}
	inline bool cut(int x,int y){
		if(findroot(x)!=findroot(y))	return 0;
		split(x,y);
		if(s[x].f!=y||s[x].rs)		return 0;
		s[x].f=s[y].ls=0;
		pushup(x);
		return 1;
	}
} lct;
int n=read(),m=read();
signed main(){
	fz(i,1,n)	lct.s[i].val=read(),lct.s[i].sum=lct.s[i].val;
	fz(i,1,m){
		int opt=read(),x=read(),y=read();
		if(opt==0)		lct.split(x,y),cout<<lct.s[y].sum<<endl;
		if(opt==1)		lct.link(x,y);
		if(opt==2)		lct.cut(x,y);
		if(opt==3)		lct.splay(x),lct.s[x].val=y;
	}
	return 0;
}
```

创作声明：

部分内容借鉴了 FlashHu 的题解

~~写题解不容易，快快点个赞呗~~

---

## 作者：TheLostWeak (赞：24)

#### 前言

$LCT$，真的是一个无比神奇的数据结构。

它可以**动态**维护**链信息**、**连通性**、**边权**、**子树信息**等各种神奇的东西。

而且，它其实并不难理解。

~~就算理解不了，它简短的代码也很好背。~~

------

#### $LCT$与实边的定义

$LCT$，全称$Link\ Cut\ Tree$，中文名**动态树**。

它的实现有点类似于[**树链剖分**](https://www.cnblogs.com/chenxiaoran666/p/TreeChainDissection.html)，但树链剖分维护的是**重边**和**轻边**（故又称**重链剖分**），而$LCT$维护的则是**实边**和**虚边**。

什么是实边？

我们选择一个节点与其一个儿子的连边为实边，与其他儿子的连边为虚边，这里的实边是可以随时变化的。

而实链剖分与树链剖分最大的区别在于，树链剖分是静态的，所以可以用**线段树**维护，而实链剖分则是动态的，因此就需要用一个更为神奇的数据结构——[$Splay$](https://www.cnblogs.com/chenxiaoran666/p/Splay.html)来进行维护。

于是，就有了$LCT$这个奥秘重重的数据结构。

------

#### $LCT$的简单性质

从上面的内容我们可以知道，$LCT$将一棵树的边分成了**实边**和**虚边**。

而连续的若干条实边构成了**实链**。

而我们**对每条实链分别对每个$Splay$进行维护**，可以保证，每个$Splay$中维护的节点按**中序遍历得到的顺序**在原树中**深度依次增加$1$**（证明：因为我们维护的是一条连续的链啊）。

而虚边的作用则是将这些$Splay$给链接起来，大体连接方式如下：

- 找到该$Splay$中在原树中深度最小的节点，记其为$k$。（具体代码实现时是无需求出这个$k$的，这里只是方便理解）
- 如果$k$是原树中的根节点，则无需连边。
- 否则，我们找到$fa_k$，将该$Splay$的根节点与$fa_k$之间连一条边。

这样一来，就把所有$Splay$连在了一起。

注意到一个节点可能有多个儿子，但实际上它只存储一个儿子，某大佬用一句很精辟的话对其进行了总结：**认父不认子**。

------

#### $LCT$的基本操作

下面，我们来介绍几个$LCT$的基本操作。

- $IsRoot(x)$

  $IsRoot(x)$的作用是判断一个节点$x$是否是当前**实树**的根。

  由于我们知道$LCT$是认父不认子的，所以只需要判断当前节点的父亲节点的两个子节点是否为当前节点即可。

  代码如下：

```cpp
inline bool IsRoot(int x)//判断一个节点x是否是当前实树的根
{
  	return node[node[x].Father].Son[0]^x&&node[node[x].Father].Son[1]^x;//判断fa[x]的两个子节点是否为x
}
```


- $Rotate(x)\&\&Splay(x)$

  关于这个可以自行参考[简析平衡树（三）——浅谈Splay](https://www.cnblogs.com/chenxiaoran666/p/Splay.html)。

  然而$Splay$和$LCT$中这两个操作其实还是有一定区别的。

  比如说，$LCT$每次固定将节点旋到根，因此只需要一个参数（虽然我博客中$Splay$的第一个模板也是只传一个参的）。

  再比如，$LCT$在$Splay$前需要先将当前节点到根节点的路径上所有节点从上往下$PushDown()$一遍。这可以函数递归，也可以直接栈模拟。

  具体代码如下：

```cpp
#define Which(x) (node[node[x].Father].Son[1]==x)
#define Connect(x,y,d) (node[node[x].Father=y].Son[d]=x)
inline void Rotate(int x)
{
  	register int fa=node[x].Father,pa=node[fa].Father,d=Which(x);
  	!IsRoot(fa)&&(node[pa].Son[Which(fa)]=x),node[x].Father=pa,Connect(node[x].Son[d^1],fa,d),Connect(fa,x,d^1),PushUp(fa),PushUp(x);
}
inline void Splay(int x)
{
  	register int fa=x,Top=0;
  	while(Stack[++Top]=fa,!IsRoot(fa)) fa=node[fa].Father;//存入栈中
  	while(Top) PushDown(Stack[Top]),--Top;//依次PushDown
  	while(!IsRoot(x)) fa=node[x].Father,!IsRoot(fa)&&(Rotate(Which(x)^Which(fa)?x:fa),0),Rotate(x);
}
```


- $Access(x)$

  $Access(x)$的作用是**把根节点到$x$的路径上的边全部变为实边**。

  则我们首先考虑在当前$Splay$中将$x$旋到根，然后将$x$与$fa_x$间的连边更新为实边，即更新$fa_x$的右儿子为$x$；再将$fa_x$在其所在$Splay$中旋到根，同理更新$fa_{fa_x}$的右儿子为$fa_x$... ...

  以此类推，直到处理到根节点所在的$Splay$为止。

  这样就打通了一条从根节点到$x$的路径。

  $Access(x)$可谓是$LCT$最核心的操作，也是后面许多操作的基础。

  具体实现可以详见代码：

```cpp
inline void Access(int x)//把根节点到x的路径上的边全部变为实边
{
  	for(register int son=0;x;x=node[son=x].Father)
  		Splay(x),node[x].Son[1]=son,PushUp(x);//注意Access过程中要PushUp
}
```

- $FindRoot(x)$

  $FindRoot(x)$的作用是**找到$x$所在的原树中的根节点**，可以用来判断连通性，实现**可撤销并查集**。

  我们首先$Access(x)$打通一条从根到$x$的路径，此时$x$就与根节点在同一个$Splay$内了。

  然后$Splay(x)$将$x$旋到根。

  记住前面提到的$LCT$的性质：每个$Splay$中维护的节点按**中序遍历得到的顺序**在原树中**深度依次增加$1$**。

  所以根节点必然是$Splay$中**中序遍历顺序为$1$的节点**。

  而这其实就是$x$尽量向左儿子拓展最后得到的节点。

  代码如下：

```cpp
inline int FindRoot(int x) 
{
  	Access(x),Splay(x);//一波操作，将x转到根节点所在Splay的根
  	while(node[x].Son[0]) PushDown(x),x=node[x].Son[0];//尽量向左儿子拓展，注意每次拓展前先PushDown
  	return Splay(x),x;//最后不忘Splay的优良传统：每执行完一个操作就Splay一下，防被卡
}
```

- $MakeRoot(x)$

  $MakeRoot(x)$的作用是**将$x$作为原树中的新的根节点**。

  首先，依然是先$Access(x)$打通一条从根到$x$的路径，然后$Splay(x)$将$x$旋到根。

  由前面的操作可知，根节点是$Splay$中**中序遍历顺序为$1$的节点**。

  而此时，$x$必然是$Splay$中中序遍历最后得到的点。

  因此我们只要翻转该$Splay$，$x$就变成中序遍历顺序为$1$的节点了。

  代码如下：

```cpp
inline void Rever(int x)//翻转子树
{
  	swap(node[x].Son[0],node[x].Son[1]),node[x].Rev^=1;//交换左右儿子，然后更新标记
}
inline void MakeRoot(int x)//将x作为原树中的新的根节点
{
  	Access(x),Splay(x),Rever(x);//将x转到根节点所在Splay的根，然后翻转Splay
}
```

- $Link(x,y)$

  $Link(x,y)$的作用是**在$x$和$y$两个节点间连一条边**。

  首先，我们将$x$作为它所在树的根，即$MakeRoot(x)$。

  然后，我们需要判断$x$与$y$是否联通。由于$x$是其所在子树的根节点，因此只要判断$FindRoot(y)$是否为$x$即可。

  连接只需要更新$x$的父亲为$y$即可。

  代码如下：

```cpp
inline void Link(int x,int y)//在x和y两个节点间连一条边
{
  	MakeRoot(x),FindRoot(y)^x&&(node[x].Father=y);//判断x和y的连通性，然后连接
}
```

- $Cut(x,y)$

  $Cut(x,y)$的作用是**删除$x$和$y$之间的边**。

  首先，我们依然将$x$作为它所在树的根。

  则可以保证，若$x$和$y$有边相连，一定满足一下三个条件：

  1. $y$所在树的根为$x$，即$FindRoot(y)==x$。
  2. $y$的父亲节点为$x$，即$fa_y==x$。
  3. $y$没有左儿子。因为如果$y$有左儿子，由于$LCT$的性质，可得$Depth_x<Depth_{leftson_y}<Depth_y$，则$x$和$y$必然不相连。

  代码如下：

```cpp
inline void Cut(int x,int y)//删除x和y之间的边
{
  	MakeRoot(x),!(FindRoot(y)^x)&&!(node[y].Father^x)&&!node[y].Son[0]&&(node[y].Father=node[x].Son[1]=0,PushUp(x));//判断x和y的连通性，然后删边
}
```

- $Split(x,y)$

  $Split(x,y)$的作用是**从$LCT$中抠出$x$与$y$之间的路径**。

  这样一来，就方便我们查询了。

  这个操作第一步便是将$x$作为根，然后打通$x$到$y$的路径。

  可以保证，此时$x$与$y$所在的$Splay$内**只包含$x$与$y$路径上的节点**。

  然后我们将$Splay(y)$将$y$旋至$Splay$的根，这样一来就可以通过查询$y$的信息来进行询问了。

  代码如下：

```cpp
inline void Split(int x,int y)//从LCT中抠出x与y之间的路径
{
  	MakeRoot(x),Access(y),Splay(y);//将x作为根，打通x与y的路径并将y旋到根
}
```

------

#### 模板（[板子题](https://www.luogu.org/problemnew/show/P3690)）

```cpp
#include<bits/stdc++.h>
#define N 300000
#define swap(x,y) (x^=y^=x^=y)
using namespace std;
int n,a[N+5];
class Class_FIO
{
    private:
        #define Fsize 100000
        #define tc() (A==B&&(B=(A=Fin)+fread(Fin,1,Fsize,stdin),A==B)?EOF:*A++)
        #define pc(ch) (FoutSize<Fsize?Fout[FoutSize++]=ch:(fwrite(Fout,1,Fsize,stdout),Fout[(FoutSize=0)++]=ch))
        int Top,FoutSize;char ch,*A,*B,Fin[Fsize],Fout[Fsize],Stack[Fsize];
    public:
        Class_FIO() {A=B=Fin;}
        inline void read(int &x) {x=0;while(!isdigit(ch=tc()));while(x=(x<<3)+(x<<1)+(ch&15),isdigit(ch=tc()));}
        inline void writeln(int x) {while(Stack[++Top]=x%10+48,x/=10);while(Top) pc(Stack[Top--]);pc('\n');}
        inline void clear() {fwrite(Fout,1,FoutSize,stdout),FoutSize=0;}
}F;
class Class_LCT
{
    private:
        #define LCT_SIZE N
        #define PushUp(x) (node[x].Sum=node[x].Val^node[node[x].Son[0]].Sum^node[node[x].Son[1]].Sum)
        #define Rever(x) (swap(node[x].Son[0],node[x].Son[1]),node[x].Rev^=1)
        #define PushDown(x) (node[x].Rev&&(Rever(node[x].Son[0]),Rever(node[x].Son[1]),node[x].Rev=0))
        #define Which(x) (node[node[x].Father].Son[1]==x)
        #define Connect(x,y,d) (node[node[x].Father=y].Son[d]=x)
        #define IsRoot(x) (node[node[x].Father].Son[0]^x&&node[node[x].Father].Son[1]^x)
        #define MakeRoot(x) (Access(x),Splay(x),Rever(x))
        #define Split(x,y) (MakeRoot(x),Access(y),Splay(y)) 
        int Stack[LCT_SIZE+5];
        struct Tree
        {
            int Val,Sum,Father,Rev,Son[2];
        }node[LCT_SIZE+5];
        inline void Rotate(int x)
        {
            register int fa=node[x].Father,pa=node[fa].Father,d=Which(x);
            !IsRoot(fa)&&(node[pa].Son[Which(fa)]=x),node[x].Father=pa,Connect(node[x].Son[d^1],fa,d),Connect(fa,x,d^1),PushUp(fa),PushUp(x);
        }
        inline void Splay(int x)
        {
            register int fa=x,Top=0;
            while(Stack[++Top]=fa,!IsRoot(fa)) fa=node[fa].Father;
            while(Top) PushDown(Stack[Top]),--Top;
            while(!IsRoot(x)) fa=node[x].Father,!IsRoot(fa)&&(Rotate(Which(x)^Which(fa)?x:fa),0),Rotate(x);
        }
        inline void Access(int x) {for(register int son=0;x;x=node[son=x].Father) Splay(x),node[x].Son[1]=son,PushUp(x);}
        inline int FindRoot(int x) {Access(x),Splay(x);while(node[x].Son[0]) PushDown(x),x=node[x].Son[0];return Splay(x),x;}
    public:
        inline void Init(int len,int *data) {for(register int i=1;i<=len;++i) node[i].Val=data[i];}
        inline void Link(int x,int y) {MakeRoot(x),FindRoot(y)^x&&(node[x].Father=y);}
        inline void Cut(int x,int y) {MakeRoot(x),!(FindRoot(y)^x)&&!(node[y].Father^x)&&!node[y].Son[0]&&(node[y].Father=node[x].Son[1]=0,PushUp(x));}
        inline void Update(int x,int v) {Splay(x),node[x].Val=v;}
        inline int Query(int x,int y) {return Split(x,y),node[y].Sum;}
}LCT;
int main()
{
    register int query_tot,i,op,x,y;
    for(F.read(n),F.read(query_tot),i=1;i<=n;++i) F.read(a[i]);
    for(LCT.Init(n,a);query_tot;--query_tot)
    {
        F.read(op),F.read(x),F.read(y);
        switch(op)
        {
            case 0:F.writeln(LCT.Query(x,y));break;
            case 1:LCT.Link(x,y);break;
            case 2:LCT.Cut(x,y);break;
            case 3:LCT.Update(x,y);break;
        }
    }
    return F.clear(),0;
} 
```

---

## 作者：yinianxingkong (赞：13)

SATT 题解。

许多人将 SATT 冠上“难理解”“代码量大”等标签。事实上，学习 LCT 以后可以无痛学习 SATT。

SATT 的优势主要是可以支持更多的子树操作，譬如臭名昭著的重工业 [Sone1](https://www.luogu.com.cn/problem/P5649) 如果使用 SATT 就非常容易实现。

学习 SATT 前需要了解 TopTree 理论。这一部分比较杂，这里推荐一下[这篇文章](https://www.cnblogs.com/ExplodingKonjac/p/17890636.html)。或者也可以看[我的学习笔记](https://www.cnblogs.com/yinianxingkong/p/18845071/hazuki)。

接下来的图源也来自上面那篇文章，侵删。

下面部分是一些简述。若要了解完整准确的 TopTree 还请翻看上面的文章或是看看[论文哥写的](https://negiizhao.blog.uoj.ac/blog/4912)。

# 算法介绍

## TopTree 理论

序列上有区间这一概念，基于区间的合并我们可以提出各种算法。于是我们对于树上也提出一个用于合并的概念。

**簇**：树上的一个基于边划分的连通块，满足与外界有交的点至多有两个，称为**界点**，界点间的路径称为**簇路径**。

簇的基本单位就是一条树边。

不难发现簇可以看作一个点，这样收缩以后还会是一棵树，这就是一种合并方式。接下来我们也会用点相关的描述来描述簇。

树上的合并操作不如区间上的简单，我们有两种合并方式。

**rake**：将度为一的簇并入兄弟的簇。

**compress**：将度为二的簇并入两边的簇。

![](https://pic.imgdb.cn/item/6573d3dac458853aef16099a.png)

这样合并以后显然还会是一棵树，簇的性质也没有消失。

类比一下线段树，将合并的过程记录下来，就可以得到一棵树，称之为 TopTree。

![](https://pic.imgdb.cn/item/6573d3dac458853aef160a1a.png)

于是我们速通了 TopTree 理论。

## 实链剖分

**实链剖分**：由每个节点指定一个实儿子或者不指定，实儿子的父亲边称为实边，其余则称虚儿子和虚边，则连续的实边组成实链，一棵树就被划分成了不同的链。

TopTree 与实链剖分有很多不解之缘。

将每条边看出一个簇，那么所有实链上的合并都可以看作 compress 操作的结果，而虚儿子的合并可以看作 rake 操作的结果。

如果你写过动态 dp，尤其是写过全局平衡二叉树，就会发现轻子树的影响就是 rake，重链的合并就是 compress。

对于 TopTree 而言，我们可以通过自由划分实链、改变合并顺序来动态维护树结构。试问，如果可以将某个簇最后才并入整棵树的结构里，那修改还有什么困难呢？

动态维护 TopTree 的方法就是 SATT。

## SATT

这一部分主要参考了 [OI Wiki](http://oi-wiki.com/ds/top-tree/)。

SATT 是一种基于均摊的动态 TopTree。

她是一棵三叉树，节点按照操作分为 rake 节点和 compress 节点，她们的中儿子分别挂的是 compress 节点和 rake 节点。

如果去掉中儿子，每个由 compress 节点组成的二叉树（称为 compress 树）都对应实链剖分的一条实链，中序遍历对应原实链自上而下的顺序，中儿子则表示那个节点挂的通过 rake 操作并入的虚子树。

而去掉 rake 节点的中儿子，每个 rake 节点组成的二叉树（称为 rake 树）都对应原树节点的所有虚儿子的并入操作。

然后用类似 LCT 的方式来实现这棵三叉树的操作，用类似 splay 的方式维护每棵 rake 树和 compress 树。如果您学过 LCT 可以看每个操作的省流部分。

# 正确性证明

这一部分过于困难了。

关于 TopTree 理论参见[论文哥写的](https://negiizhao.blog.uoj.ac/blog/4912)。

关于 SATT 理论请翻看 Tarjan 的[原论文](https://renatowerneck.wordpress.com/wp-content/uploads/2016/06/tw05-self-adjusting-top-tree.pdf)。

# 代码实现

接下来的代码示例取自 Sone1。

## 代码的宏定义

```cpp
#define il inline
#define bl bool
#define vd void
#define ll long long
#define ull unsigned ll
#define db double
#define ldb long db
#define pii pair<int,int>
#define fi first
#define se second
#define MP make_pair
#define pb push_back
#define N 100005
#define INF 0x3f3f3f3f
#define DEBUG cerr<<"\tfurina begin:\n"
#define END cerr<<"\tyanami end.\n"
```

## 一些记号

```cpp
//0:compress 1:rake
int st[N*5],top,Node;
struct node{
  int fa,son[3],lp,rp,v;bl reved;
  Dat sum[2];Tag tag[2];
  node(){fa=son[0]=son[1]=son[2]=lp=rp=v=reved=0,sum[0]=sum[1]=Dat(),tag[0]=tag[1]=Tag();}
}t[N*5];
#define isroot(x) (t[t[x].fa].son[0]^x&&t[t[x].fa].son[1]^x)
#define get(x) (t[t[x].fa].son[0]==x?0:t[t[x].fa].son[1]==x?1:2)
#define connect(x,y,w) (t[x].son[w]=y,y&&(t[y].fa=x))
il int neww(){int x=top?st[top--]:++Node;t[x]=node();return x;}
```
`Dat` 和 `Tag` 是封装了的，分别表示维护的信息并和标记，并重载了运算符。不影响阅读。

`lp` 和 `rp` 表示链的左右端点。

`st` 用于垃圾回收。

其余操作应该不难理解。

## pushup

维护信息时需要分讨节点类型。

compress 节点：分别维护簇路径信息和其余节点信息。这样可以方便子树修改。

rake 节点：维护所有中儿子信息并即可。

```cpp
il vd pushup(int x,bl o){
  t[x].lp=t[x].son[0]?t[t[x].son[0]].lp:x,t[x].rp=t[x].son[1]?t[t[x].son[1]].rp:x;
  if(o){//rake
    t[x].sum[1]=t[t[x].son[0]].sum[1]+(t[t[x].son[2]].sum[0]+t[t[x].son[2]].sum[1])+t[t[x].son[1]].sum[1];
    //rake tree 的 pushup 是所有点的 compress 中儿子的合并。 
  }else{//compress
    t[x].sum[0]=t[t[x].son[0]].sum[0]+Dat(1,t[x].v,t[x].v,t[x].v)+t[t[x].son[1]].sum[0];
    //compress tree 信息，直白的说就是簇路径信息。 
    t[x].sum[1]=t[t[x].son[0]].sum[1]+t[t[x].son[2]].sum[1]+t[t[x].son[1]].sum[1];
    //其余信息。 
  }
}
```

## pushdown

与 pushup 相同，如果是 compress 节点，分讨是链修改还是子树修改下传标记。

```cpp
il vd rever(int x){if(x)swap(t[x].son[0],t[x].son[1]),swap(t[x].lp,t[x].rp),t[x].reved^=1;}
il vd tager(int x,Tag tag,bl o){if(x)t[x].sum[o]=t[x].sum[o]*tag,t[x].tag[o]=t[x].tag[o]+tag,!o&&(t[x].v=tag[t[x].v]);}
il vd pushdown(int x,bl o){
  if(o){
    if(!t[x].tag[1].empty())tager(t[x].son[0],t[x].tag[1],1),tager(t[x].son[1],t[x].tag[1],1),tager(t[x].son[2],t[x].tag[1],1),tager(t[x].son[2],t[x].tag[1],0),t[x].tag[1]=Tag();
  }else{
    if(t[x].reved)rever(t[x].son[0]),rever(t[x].son[1]),t[x].reved=0;
    if(!t[x].tag[0].empty())tager(t[x].son[0],t[x].tag[0],0),tager(t[x].son[1],t[x].tag[0],0),t[x].tag[0]=Tag();
    if(!t[x].tag[1].empty())tager(t[x].son[0],t[x].tag[1],1),tager(t[x].son[1],t[x].tag[1],1),tager(t[x].son[2],t[x].tag[1],1),t[x].tag[1]=Tag();
  }
}
//链信息修改只有 compree tree 才需要下传。
//更多的标记下传参见 Sone1
il vd update(int x,bl o){if(!isroot(x))update(t[x].fa,o);pushdown(x,o);}
```

## rotate

就是 splay 的旋转操作，判断自己是左儿子还是右儿子，再重新接到父亲上。记得特判父亲是否存在。

**LCT 省流**：原先的判断爷节点是否是当前 splay 的根改为是否存在。

```cpp
il vd rotate(int x,bl o){
  int y=t[x].fa,z=t[y].fa;bl w=get(x);
  if(z)t[z].son[get(y)]=x;//注意判断条件的变换 
  t[x].fa=z,connect(y,t[x].son[w^1],w),connect(x,y,w^1);
  pushup(y,o),pushup(x,o);
}
```

## splay

将节点旋转到当前 rake 树或 compress 树的根。

记得要双旋，若是同方向需要先旋转父亲。

为了方便后面删除需要实现旋转到指定节点下的操作。

**LCT 省流**：需要实现旋转到指定节点下的操作。

```cpp
il vd splay(int x,bl o,int y=0){//为了方便删除，需要新添加旋转到 y 子树的功能。
  for(update(x,o);!isroot(x)&&t[x].fa^y;rotate(x,o))
  if(!isroot(t[x].fa)&&t[t[x].fa].fa^y)rotate(get(t[x].fa)^get(x)?x:t[x].fa,o);
} 
```

## strike

~~这是我自己取的名，意为罢工，很形象吧。~~

删除~~罢工~~一个 rake 节点。

如果两个儿子都有就实现经典的删除操作即可。否则直接接上。

具体可以看代码。

```cpp
il vd strike(int x){//rake 节点，此时 x 无中儿子，罢工 x。 
  if(t[x].son[0]){
    int y=t[t[x].son[0]].rp;splay(y,1,x),connect(y,t[x].son[1],1);
    connect(t[x].fa,y,2),pushup(y,1);
    //经典的删除操作，把最右边的点旋上来，再把右儿子接进去。 
  }else connect(t[x].fa,t[x].son[1],2);
  //没有左儿子就不需要合并了。 
  pushup(t[x].fa,0),st[++top]=x;
}
```

## splice

核心操作，意为将一个 rake 节点的中儿子跨越她的 rake 树，即把中儿子接到自己父亲的 compress 树上。

体现在原树上，就是改变簇路径。

实现需要两步：

local splay：将中儿子的父节点和爷节点都旋转到其所在二叉树的根。

splice：跨越 rake 树。如果爷节点有右儿子直接交换就可以了，否则就会出现无意义的 rake 节点，需要删除~~罢工~~。

```cpp
il vd splice(int x){//rake 结点，将中儿子跨越 rake tree 
  //local splay：将自己的父节点和爷节点都转到指定树的根。 
  splay(x,1);int y=t[x].fa;splay(y,0),pushdown(x,1);
  //splice：将 x 的中儿子跨越它的 rake tree 
  if(t[y].son[1])swap(t[t[x].son[2]].fa,t[t[y].son[1]].fa),swap(t[x].son[2],t[y].son[1]),pushup(x,1),pushup(y,0);
  //有右儿子就直接交换，对应更改簇路径。
  else connect(y,t[x].son[2],1),strike(x),pushup(y,0);
  //没有就删除 x 这个 wyy 结点 
}
```

## access

打通根到指定点的实链作为簇路径。

首先将节点变成界点，然后不断跨越 rake 树即可。

**LCT 省流**：只需增加将节点变为界点操作即可。

```cpp
il vd access(int x){//compress 结点，打通其到根的链作为根簇路径
  splay(x,0);
  if(t[x].son[1]){//x 不是簇的端点，将右儿子掰下来，变成 rake tree。 
    int y=neww();connect(y,t[x].son[2],0),connect(y,t[x].son[1],2);
    t[x].son[1]=0,connect(x,y,2),pushup(y,1),pushup(x,0);
  }
  for(;t[x].fa;splay(x,0))splice(t[x].fa);
  //不断跨越 rake tree 即可。
  //一个性质是 access 完后 x 已经是 compress tree 的根了。 
}
```

## 零散操作

都不难理解，不多赘述。

mkroot：定根。

split：打通路径作为簇。

fdroot：找根。

```cpp
il vd mkroot(int x){access(x),rever(x);}
il vd split(int x,int y){mkroot(x),access(y);}
il int fdroot(int x){return access(x),t[x].lp;}
```

## 子树操作

这里单独记一下。打通指定节点到根的路径以后，她的右儿子应该是空的，她的中儿子和她本身就是她的子树。

# 本题代码

本题的操作都比较基础，自己实现不难。这里给出一份封装的 SATT 代码。

```cpp
namespace SATT{
  //0:compress 1:rake
  int st[N*3],top,Node;
  struct node{
    int fa,son[3],lp,rp,v,sum[2];bl reved;
    node(){fa=son[0]=son[1]=son[2]=lp=rp=v=sum[0]=sum[1]=reved=0;}
  }t[N*3];
  #define isroot(x) (t[t[x].fa].son[0]^x&&t[t[x].fa].son[1]^x)
  #define get(x) (t[t[x].fa].son[0]==x?0:t[t[x].fa].son[1]==x?1:2)
  #define connect(x,y,w) (t[x].son[w]=y,y&&(t[y].fa=x))
  il int neww(){int x=top?st[top--]:++Node;t[x]=node();return x;}
  il vd pushup(int x,bl o){
    t[x].lp=t[x].son[0]?t[t[x].son[0]].lp:x,t[x].rp=t[x].son[1]?t[t[x].son[1]].rp:x;
    if(o){//rake
      t[x].sum[1]=t[t[x].son[0]].sum[1]^t[t[x].son[2]].sum[1]^t[t[x].son[1]].sum[1];
      //rake tree 的 pushup 是所有点的 compress 中儿子的合并。 
    }else{//compress
      t[x].sum[0]=t[t[x].son[0]].sum[0]^t[x].v^t[t[x].son[1]].sum[0];
      //compress tree 信息，直白的说就是簇路径信息。 
      t[x].sum[1]=t[t[x].son[0]].sum[1]^(t[t[x].son[2]].sum[1]^t[x].v)^t[t[x].son[1]].sum[1];
      //簇信息，中间的一部分表示 t[t[x].son[2]].sum[1] 作用在 t[x].v 上的更新。 
    }
  }
  il vd rever(int x){if(x)swap(t[x].son[0],t[x].son[1]),swap(t[x].lp,t[x].rp),t[x].reved^=1;}
  il vd pushdown(int x,bl o){if(!o&&t[x].reved)rever(t[x].son[0]),rever(t[x].son[1]),t[x].reved=0;}
  //链信息修改只有 compree tree 才需要下传。
  //更多的标记下传参见 Sone1 
  il vd update(int x,bl o){if(!isroot(x))update(t[x].fa,o);pushdown(x,o);}
  il vd rotate(int x,bl o){
    int y=t[x].fa,z=t[y].fa;bl w=get(x);
    if(z)t[z].son[get(y)]=x;//注意判断条件的变换 
    t[x].fa=z,connect(y,t[x].son[w^1],w),connect(x,y,w^1);
    pushup(y,o),pushup(x,o);
  } 
  il vd splay(int x,bl o,int y=0){//为了方便删除，需要新添加旋转到 y 子树的功能。
    for(update(x,o);!isroot(x)&&t[x].fa^y;rotate(x,o))
    if(!isroot(t[x].fa)&&t[t[x].fa].fa^y)rotate(get(t[x].fa)^get(x)?x:t[x].fa,o);
  } 
  il vd strike(int x){//rake 结点，此时 x 无中儿子，罢工 x。 
    if(t[x].son[0]){
      int y=t[t[x].son[0]].rp;splay(y,1,x),connect(y,t[x].son[1],1);
      connect(t[x].fa,y,2),pushup(y,1);
      //经典的删除操作，把最右边的点旋上来，再把右儿子接进去。 
    }else connect(t[x].fa,t[x].son[1],2);
    //没有左儿子就不需要合并了。 
    pushup(t[x].fa,0),st[++top]=x;
  }
  il vd splice(int x){//rake 结点，将中儿子跨越 rake tree 
    //local splay：将自己的父节点和爷节点都转到指定树的根。 
    splay(x,1);int y=t[x].fa;splay(y,0),pushdown(x,1);
    //splice：将 x 的中儿子跨越它的 rake tree 
    if(t[y].son[1])swap(t[t[x].son[2]].fa,t[t[y].son[1]].fa),swap(t[x].son[2],t[y].son[1]),pushup(x,1),pushup(y,0);
    //有右儿子就直接交换，对应更改簇路径。
    else connect(y,t[x].son[2],1),strike(x),pushup(y,0);
    //没有就删除 x 这个 wyy 结点 
  }
  il vd access(int x){//compress 结点，打通其到根的链作为根簇路径
    splay(x,0);
    if(t[x].son[1]){//x 不是簇的端点，将右儿子掰下来，变成 rake tree。 
      int y=neww();connect(y,t[x].son[2],0),connect(y,t[x].son[1],2);
      t[x].son[1]=0,connect(x,y,2),pushup(y,1),pushup(x,0);
    }
    for(;t[x].fa;splay(x,0))splice(t[x].fa);
    //不断跨越 rake tree 即可。
    //一个性质是 access 完后 x 已经是 compress tree 的根了。 
  }
  il vd mkroot(int x){access(x),rever(x);}
  il vd split(int x,int y){mkroot(x),access(y);}
  il int fdroot(int x){return access(x),t[x].lp;}
  il vd link(int x,int y){if(fdroot(x)==fdroot(y))return;access(x),mkroot(y),connect(x,y,1),pushup(y,0),pushup(x,0);}
  il vd cut(int x,int y){split(x,y);if(t[y].son[0]^x||t[x].son[1])return;t[x].fa=t[y].son[0]=0,pushup(y,0);}
}using namespace SATT;
```
# 总结

只要记住了几个关键函数，SATT 不难实现。

一定时刻注意分讨 rake 节点和 compress 节点。

# 题外话

其实总体来看，SATT 并不算一个特别难理解的结构，代码实现难度和 LCT 差不多。

但人心中的成见是一座大山，仅因为她是 TopTree 便长期被人诟病。

故普及 SATT 是有必要的，所以有了这篇题解。

如果有兴趣的话可以继续了解静态 TopTree 理论，也是简单又强势的数据结构。[推荐同学的文章](https://www.luogu.com.cn/article/42ajqoux)，主要是有完整代码和资料目录。

板子题一定不能出问题，如果有问题请指出，感激不尽！

---

## 作者：Sai0511 (赞：11)

阅读前请确保你会$\text{splay}$。     
$\text{LinkCutTree}$模板，简称$\text{lct}$。  
首先我们把一棵树里所有节点都全部划分在一些$\text{splay}$里,每一个$\text{splay}$维护的东西都是一条在原树上从上到下按深度递增的一条链。      
然后我们定义每条边有两种类型：实或者虚。     
其中实边代表的是在某个$\text{splay}$内部的边，而虚边则是某一个$\text{splay}$所指向另一个节点所对应的边。      
然后这就是所谓的“实链剖分”了。而我们大家所熟知的树剖则是“重链剖分”。          
然后我们再来看一看各种操作。       
$\text{access}$操作    
这个操作代表的是打通一条根节点到现在节点的实链。  
我们可以选择的方法是从下往上拉。     
每次让要操作的节点成为当前$\text{splay}$的根，然后将它的右子树变成$\text{0}$，接着在根据虚边往上拉。   
你们可以画一棵树出来，更熟悉的理解一下。           
**$\text{access}$操作是$\text{lct}$的基础，其他操作全是在$\text{access}$的基础上完成的。**     
$\text{makeroot}$操作。            
这个操作就是换根操作。   
我们先要知道一点，那就是我们$\text{access}$后这个节点一定是当前$\text{splay}$中深度最大的节点。（应该容易理解，可以自行思考一下）。     
此时我们再让此节点成为当前$\text{splay}$的根，那么这个节点一定是没有右子树的。   
这个时候我们有一个神奇的思路:     
直接把这个节点的左右子树交换，不就成了根了吗？      
事实证明这种思路是可行的。               
$\text{findroot}$操作     
找$\text{x}$所在的树中的根。
我们先$\text{access}$一次，然后再$\text{splay}$一次。        
此时的所有点都在当前节点的左子树里，毫无疑问，原来的树根就是目前为止一直左子树到最后一个的点。     
$\text{split}$操作        
这个操作的含义定义为拉出一条从$\text{x}$到$\text{y}$的链。            
我们先$\text{makeroot(x)}$，然后$\text{access(y)}$，此时由于$\text{x}$是根节点，所以$\text{x}$和$\text{y}$就处在了同一个$\text{splay}$中。      
这时我们再将$\text{y}$变成现在$\text{splay}$里的根就好了。        
$\text{link}$
操作            
定义含义为连接某一条边。        
我们发现$\text{makeroot}$之后由于是根节点，这个节点是没有父亲的，我们直接将这个节点的父亲赋为$\text{y}$就好了。         
$\text{cut}$操作       
定义为删掉$\text{x}$到$\text{y}$的边
我们首先拉出一条从$\text{x}$到$\text{y}$的链。   
一般来说$\text{cut}$的时候一定是存在$\text{x}$到$\text{y}$的边的，但是为了以防万一，这种特殊情况也要处理一下。      
有几种情况：       
1:$\text{y}$不仅有$\text{x}$一个儿子。       
2:$\text{x}$的父亲不是$\text{y}$       
3:$\text{x}$有右孩子。       
然后你就可以写出$\text{lct}$了。     
上代码:         
```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
#define il inline
const int maxn = 3e5 + 10; 
using namespace std;
template<class T> il void rd(T& res) {
    res = 0;char c;bool sign = 0;
    for(c = getchar();!isdigit(c);c = getchar()) sign |= c == '-';
    for(;isdigit(c);c = getchar()) res = (res << 1) + (res << 3) + (c ^ 48);    
    (sign) && (res = -res);
    return; 
} 
int n,m,i,j,k,root;     
int ch[maxn][2],size[maxn],fa[maxn],val[maxn],sum[maxn];         
bool tag[maxn],dbg;       
il bool isroot(int o) {
    return ch[fa[o]][0] != o && ch[fa[o]][1] != o;
}  
il void push_up(int o) {
    size[o] = size[ch[o][0]] + size[ch[o][1]] + 1;
    sum[o] = sum[ch[o][0]] ^ sum[ch[o][1]] ^ val[o];
    return;
}
il void _swap(int& x,int& y) {
    x ^= y ^= x ^= y;
    return; 
}
il void push_down(int o) {
    if(tag[o]) {
        _swap(ch[o][0],ch[o][1]); 
        tag[ch[o][0]] ^= 1;
        tag[ch[o][1]] ^= 1;
        tag[o] = 0;
    }
    return;
}
il int which(int o) {
    return ch[fa[o]][1] == o;
}
il void rotate(int o) {
    int f = fa[o],gf = fa[f],whi = which(o);    
    if(!isroot(f)) ch[gf][which(f)] = o;      
    ch[f][whi] = ch[o][whi ^ 1];
    fa[ch[o][whi ^ 1]] = f;         
    ch[o][whi ^ 1] = f;        
    fa[f] = o;fa[o] = gf;       
 	push_up(f);push_up(o);
    return;	
}            
il void splay(int o) {
    stack<int> sta;
    while(!sta.empty()) sta.pop();sta.push(o);            
    for(int i = o;!isroot(i);i = fa[i]) sta.push(fa[i]);             
    while(!sta.empty()) push_down(sta.top()),sta.pop();
    for(int f = fa[o];!isroot(o);rotate(o),f = fa[o]) {   
        if(!isroot(f)) rotate(which(f) == which(o) ? f : o);     
    //	if(!dbg) printf("%d\n",o); 
    }    
    push_up(o);
    return;
}                                 
il void access(int o) {        
    for(int y = 0;o;o = fa[y = o]) {           
        splay(o);      
        ch[o][1] = y;          
        push_up(o);
    }
}    
il int get_root(int o) {    
    access(o);splay(o);
    while(ch[o][0]) push_down(o),o = ch[o][0];    
    return o;
}
il void make_root(int o) {
    access(o);
    splay(o);          
    tag[o] ^= 1;
    return; 	
} 
il void link(int x,int y) {
    make_root(x);    
    fa[x] = y;
}
il void split(int x,int y) {
    make_root(x);
    access(y);
    splay(y);        
}
il void cut(int x,int y) {
    split(x,y);
    if(ch[y][which(x) ^ 1] || fa[x] != y || ch[x][1]) return;
    fa[x] = ch[y][0] = 0;
    push_up(y);
    return;
}
int main() {
    rd(n);rd(m);   
    for(int i = 1;i <= n;i++) rd(val[i]),sum[i] = val[i];
    for(int i = 1,op,x,y;i <= m;i++) {
        rd(op);rd(x);rd(y);     
        switch(op) {
            case 0: {
                split(x,y);   
                printf("%d\n",sum[y]);
                break;
            }
            case 1: {            
                if(get_root(x) != get_root(y)) link(x,y);
                break;
            }
            case 2: {
                if(get_root(x) == get_root(y)) cut(x,y);
                break;
            }
            case 3: {
                val[x] = y;
                access(x);
                splay(x);
                push_up(x);
                break;
            }
        }
    }
    return 0;
}




```


---


# [WC2005] 双面棋盘

## 题目描述

佳佳有一个 $n$ 行 $n$ 列的黑白棋盘，每个格子都有两面，一面白色，一面黑色。佳佳把棋盘平放在桌子上，因此每个格子恰好一面朝上，如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/rcejbuct.png)

我们把每行从上到下编号为 $1$，$2$，$3$，……，$n$，各列从左到右编号为 $1$，$2$，$3$，……，$n$，则每个格子可以用棋盘坐标$(x, y)$表示。在上图中，有 $8$ 个格子黑色朝上，另外 $17$ 个格子白色朝上。

如果两个同色格子有一条公共边，我们称这两个同色格子属于同一个连通块。上图共有 $5$ 个黑色连通块和 $3$ 个白色连通块。

佳佳可以每分钟将一个格子翻转（即白色变成黑色，黑色变成白色），然后计算当前有多少个黑色连通块和白色连通块，你能算得更快吗？


## 说明/提示

【样例说明】

翻转 $(3, 2)$ 之后，棋盘变为：

![](https://cdn.luogu.com.cn/upload/image_hosting/9oqt0zsv.png)

有 $4$ 个黑色区域和 $3$ 个白色区域

翻转 $(2, 3)$ 之后，棋盘变为：

![](https://cdn.luogu.com.cn/upload/image_hosting/f335hulm.png)

有 $5$ 个黑色区域和 $2$ 个白色区域

【数据范围】   
对于 $100\%$ 的数据，$1\le n \le 200$，$1\le m \le 10^4$。


## 样例 #1

### 输入

```
5
0 1 0 0 0
0 1 1 1 0
1 0 0 0 1
0 0 1 0 0
1 0 0 0 0
2
3 2
2 3```

### 输出

```
4 3
5 2```

# 题解

## 作者：iyaang (赞：23)

# 【WC2005】双面棋盘

[题目链接](https://www.luogu.com.cn/problem/P4121)

这天做双面棋盘这道题，发现题解里面大多都是 LCT ，对于线段树套并查集的写法思路讲评很少而且不大清晰，因此有了这一篇题解。

维护联通块的数量，很容易联想到使用并查集，考虑暴力，用并查集记录每个点的连通性，最后统计块数即可。但是如果每次进行格子翻转的操作都暴力重构并查集，时间复杂度达到 $O(N^2M)$ ，无法忍受。

不考虑翻转操作，思考从小一点的数据入手，假设这个棋盘只有一行，如：
```
0 0 1 1 0 0 
```
容易得出这一行有两个白色联通块，一个黑色联通块。

将棋盘情况扩展到两行，如：
```
0 0 1 1 0 0
0 1 1 1 0 0
```
对于第二行，也是两个白色联通块，一个黑色联通块，但是当上下两行连起来时，总数依旧为两个白色联通块，一个黑色联通块。先假设上下两行的联通块个数不互相影响，即总共有四个白色联通块，两个黑色联通块。当第一列相接时，颜色相同，会减少一个白色联通块；当第三列相接时，颜色相同，会减少一个黑色联通块；当第四列相接时，由于 $(1,3)$ 和 $(1,4)$ 联通， $(2,3)$ 和 $(2,4)$ 联通， 刚刚第三列相接标记了 $(1,3)$ 和 $(2,3)$ 联通，所以在并查集中 $(1,4)$ 和 $(2,4)$ 也是联通的，因此块数并不会减少。以此类推。
 
这时我们可以得出结论：每一行的联通块个数在拼接时并不会改变，多行的联通块个数由**相邻的两行的联通块个数和每一列上相邻两格的颜色**决定。

因此我们可以以行为单位，维护好区间联通块个数以及最上面一行和最下面一行的连通性信息（叶子节点二者都是它本身）。因为在相接时只有这两行会对最终联通块个数产生影响。

考虑线段树，在叶子节点维护每一行的联通块个数，然后合并每一行，类推到大的区间，最后直接取出线段树结构体中 $1$ 号节点（即整个棋盘）的联通块个数即可。

行与行合并时进行 pushup 操作，直接暴力合并，遍历一遍每一列是否是同一颜色即可。

对于翻转操作，相当于单点修改，我们直接重构这一行的并查集和叶子节点信息，然后同样向上 pushup ，与建树的操作是类似的，因此写代码的时候可以直接对称着写。

时间复杂度 $O(N^2+MN \log^2 N)$。

因为维护的是行的信息，所以代码中的“左”表示“上”，“右”表示“下”。

代码中有更为详细的解释。

~~个人感觉码风很好？~~

```cpp
#include<bits/stdc++.h>
#define MAX 210
using namespace std;

inline int read()
{
    int s=0,w=1;
    char c=getchar();
    while(!isdigit(c)) {if(c=='-') w=-1; c=getchar();}
    while(isdigit(c)) s=(s<<1)+(s<<3)+(c^48),c=getchar();
    return s*w;
}

int n,m,x,y;
int g[MAX][MAX];  //存棋盘

//并查集，二维压成一维
int fa[MAX*MAX];    
inline int get(int i,int j)   //计算在并查集中的编号 
{
	return (i-1)*n+j;
} 
inline int find(int x)
{
	if(x==fa[x]) return x;
	return fa[x]=find(fa[x]);
} 

//线段树  0为白色   1为黑色
struct Segment_tree
{
	int white,black;   //维护当前这几行的黑白联通块数量
	int l,r;        //维护当前这几行的最上边和最下边的行是什么 
	int ls[MAX],rs[MAX];   //维护当前这几行的最上面一行和最下面一行的连通性（即父节点） 
}t[MAX*4];
inline void pushup(int i)   //暴力合并、父节点更新 
{
	for(int j=1;j<=n;j++)
	{
		//父亲节点的最上行是他左（上）儿子的最上行，父亲节点的最下行是他右（下）儿子的最下行 
		t[i].ls[j]=t[i<<1].ls[j];
		t[i].rs[j]=t[i<<1|1].rs[j];
		//重新计算联通块信息，初始化已经记录下了编号所以不用再get 
		fa[t[i<<1].ls[j]]=t[i<<1].ls[j];
		fa[t[i<<1].rs[j]]=t[i<<1].rs[j];
		fa[t[i<<1|1].ls[j]]=t[i<<1|1].ls[j];
		fa[t[i<<1|1].rs[j]]=t[i<<1|1].rs[j];
	}
	//先假设没有合并，然后再一点点减去 
	t[i].black=t[i<<1].black+t[i<<1|1].black;
	t[i].white=t[i<<1].white+t[i<<1|1].white;
	int mid=(t[i].l+t[i].r)>>1;  //寻找交界的部分 
	for(int j=1;j<=n;j++)
		if(g[mid][j]==g[mid+1][j])   //如果是同一种颜色就要进行合并操作
		{
		//相交的部分为左（上）儿子的最下端和右（下）儿子的最上端 
			int l=find(t[i<<1].rs[j]);   
			int r=find(t[i<<1|1].ls[j]);   
			if(l!=r)
			{
				fa[l]=r;
				if(g[mid][j]==0&&g[mid+1][j]==0) t[i].white--;
				if(g[mid][j]==1&&g[mid+1][j]==1) t[i].black--;
			}
		}
	//更新根节点的信息，一定要让边上为根节点 
	for(int j=1;j<=n;j++)
		t[i].ls[j]=find(t[i].ls[j]),t[i].rs[j]=find(t[i].rs[j]);
}
inline void build(int i,int l,int r)   //建树 
{
	t[i].l=l,t[i].r=r;
	if(l==r)   
	{
		for(int j=1;j<=n;j++)    //初始每一行的每一个点的父亲都是他自己，假设每一个格子都是单独的联通块 
		{
			t[i].ls[j]=t[i].rs[j]=fa[get(l,j)]=get(l,j);
			if(g[l][j]==0) t[i].white++;
			else t[i].black++;
		}
		for(int j=2;j<=n;j++)  //统计这一行的黑白联通块个数，去掉重复计算的联通块 
			if(g[l][j]==g[l][j-1])
			{
				t[i].ls[j]=t[i].rs[j]=fa[get(l,j)]=fa[get(l,j-1)];   //注意是连接到父亲！！！ 
				if(g[l][j]==0) t[i].white--;
				else t[i].black--;
			}
		return;
	}
	int mid=(l+r)>>1;
	build(i<<1,l,mid);
	build(i<<1|1,mid+1,r);
	pushup(i);
	return;
}
inline void change(int i,int to)    //单行修改
{
	if(t[i].l==t[i].r)
	{
		t[i].white=t[i].black=0;   //暴力重新计算，注意清零，剩下的操作与建树是一样的 
		for(int j=1;j<=n;j++)  
		{
			t[i].ls[j]=t[i].rs[j]=fa[get(to,j)]=get(to,j);
			if(g[t[i].l][j]==0) t[i].white++;
			else t[i].black++;
		}
		for(int j=2;j<=n;j++)
			if(g[t[i].l][j]==g[t[i].l][j-1])
			{
				t[i].ls[j]=t[i].rs[j]=fa[get(to,j)]=fa[get(to,j-1)];
				if(g[t[i].l][j]==0) t[i].white--;
				else t[i].black--;
			}
		return;
	}
	if(t[i<<1].r>=to) change(i<<1,to); 
	if(t[i<<1|1].l<=to) change(i<<1|1,to);
	pushup(i);
	return;
}

int main()
{
	n=read();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			g[i][j]=read();
	build(1,1,n);
	m=read();
	for(int i=1;i<=m;i++)
	{
		x=read(),y=read();
		g[x][y]=(g[x][y]==0)?1:0;
		change(1,x);
		printf("%d %d\n",t[1].black,t[1].white);
	}
	return 0;
}
```

updata 2022.8.5  感谢@老子是北瓜，修改了错误的时间复杂度。

---

## 作者：斯德哥尔摩 (赞：9)

[P4121 [WC2005]双面棋盘](https://www.luogu.org/problemnew/show/P4121)

趁没有线段树套并查集的题解赶紧抢一发一血。。。

用线段树维护每行的同色块，每个节点套并查集。

记录最上方和最下方的联通性，暴力合并+暴力修改并查集，并记录答案。

并查集的合并比较恶心。。。

我是看这位巨佬的博客弄懂的：[链接](https://blog.csdn.net/iamzky/article/details/42084993)

用并查集中的$[1,n]$表示上方，$[n+1,2n]$表示下方。

合并时$[2n+1,4n]$用于右侧的上下方并查集。

话说我的线段树常数炒鸡大，卡了好久才卡过去的。。。

[有空到本蒟蒻的博客里坐坐嘛！](https://www.cnblogs.com/Yangrui-Blog/p/9550759.html)

附代码：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<vector>
#include<cstring>
#define LSON rt<<1
#define RSON rt<<1|1
#define DATA(x) a[x].data
#define WHITE(x) a[x].white
#define BLACK(x) a[x].black
#define LSIDE(x) a[x].l
#define RSIDE(x) a[x].r
#define MAXN 210
using namespace std;
int n,m;
int chess[MAXN][MAXN],map[MAXN<<2];
struct Set{
	int father[MAXN<<2];
	inline void init(){for(int i=0;i<=(n<<2);i++)father[i]=i;}
	int find(int x){return father[x]==x?x:father[x]=find(father[x]);}
	inline void uniun(int x,int y){father[find(x)]=find(y);}
	inline bool check(int x,int y){return (find(x)==find(y));}
};
struct Segment_Tree{
	Set data;
	int white,black,l,r;
}a[MAXN<<2];
inline int read(){
	int date=0,w=1;char c=0;
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
void pushup(int rt){
	int mid=LSIDE(rt)+RSIDE(rt)>>1;
	WHITE(rt)=WHITE(LSON)+WHITE(RSON);
	BLACK(rt)=BLACK(LSON)+BLACK(RSON);
	DATA(rt).init();
	for(int i=1;i<=(n<<1);i++){
		DATA(rt).uniun(i,DATA(LSON).find(i));
		DATA(rt).uniun(i+(n<<1),DATA(RSON).find(i)+(n<<1));
	}
	for(int i=1;i<=n;i++)
	if(chess[mid][i]==chess[mid+1][i]){
		if(DATA(rt).check(i+n,i+(n<<1)))continue;
		DATA(rt).uniun(i+n,i+(n<<1));
		WHITE(rt)-=chess[mid][i]^1;
		BLACK(rt)-=chess[mid][i];
	}
	for(int i=1;i<=(n<<2);i++){
		DATA(rt).find(i);
		map[i]=0;
	}
	for(int i=1;i<=n;i++){
		if(!map[DATA(rt).father[i]]){
			map[DATA(rt).father[i]]=i;
			DATA(rt).father[i]=i;
		}
		else DATA(rt).father[i]=map[DATA(rt).father[i]];
	}
	for(int i=n*3+1;i<=(n<<2);i++){
		if(!map[DATA(rt).father[i]]){
			map[DATA(rt).father[i]]=i-(n<<1);
			DATA(rt).father[i]=i-(n<<1);
		}
		else DATA(rt).father[i]=map[DATA(rt).father[i]];
	}
	for(int i=1;i<=n;i++)DATA(rt).father[i+n]=DATA(rt).father[i+n*3];
	for(int i=(n<<1)+1;i<=(n<<2);i++)DATA(rt).father[i]=i;
}
void buildtree(int l,int r,int rt){
	LSIDE(rt)=l;RSIDE(rt)=r;
	if(l==r){
		WHITE(rt)=chess[l][1]^1;
		BLACK(rt)=chess[l][1];
		DATA(rt).init();
		DATA(rt).uniun(1+n,1);
		for(int i=2;i<=n;i++){
			DATA(rt).uniun(i+n,i);
			if(chess[l][i-1]==chess[l][i])DATA(rt).uniun(i,i-1);
			else{
				WHITE(rt)+=chess[l][i]^1;
				BLACK(rt)+=chess[l][i];
			}
		}
		return;
	}
	int mid=l+r>>1;
	buildtree(l,mid,LSON);
	buildtree(mid+1,r,RSON);
	pushup(rt);
}
void update(int k,int rt){
	if(LSIDE(rt)==RSIDE(rt)){
		WHITE(rt)=chess[k][1]^1;
		BLACK(rt)=chess[k][1];
		DATA(rt).init();
		DATA(rt).uniun(1+n,1);
		for(int i=2;i<=n;i++){
			DATA(rt).uniun(i+n,i);
			if(chess[k][i-1]==chess[k][i])DATA(rt).uniun(i,i-1);
			else{
				WHITE(rt)+=chess[k][i]^1;
				BLACK(rt)+=chess[k][i];
			}
		}
		return;
	}
	int mid=LSIDE(rt)+RSIDE(rt)>>1;
	if(k<=mid)update(k,LSON);
	else update(k,RSON);
	pushup(rt);
}
int main(){
	int x,y;
	n=read();
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	chess[i][j]=read();
	buildtree(1,n,1);
	m=read();
	while(m--){
		x=read();y=read();
		chess[x][y]^=1;
		update(x,1);
		printf("%d %d\n",BLACK(1),WHITE(1));
	}
    return 0;
}

```

---

## 作者：NaCly_Fish (赞：6)

其实这题思路不难，本质上就是维护动态图的连通块个数。  
下面先讨论一个更简单的情况：[动态图连通块](https://www.luogu.org/problemnew/show/U94348) 

直接在线维护很麻烦，可以考虑离线，记录每条边出现的时间段，把它们标记在线段树上。  

然后在线段树上分治，用可撤销的并查集维护：在分治中加入一条边时，就直接合并，同时把连通块数量 $-1$；回溯的时候，就撤销掉刚才合并的操作，再把连通块数量加回来。  

这样就简单的解决了问题，时间复杂度 $\text O(q \log q \log n)$。
****
但是这题就需要注意一些细节，，

在这题中也是类似的做法，用两个并查集，分别记录黑白块的连通状况。对于相同颜色块，两点间要连一条边。然后基本按照上面的做法写就可以了。  

但是你写完之后一测样例，发现答案大了很多，是因为维护一种颜色的答案时，会多加上另一种颜色数量。所以记录一下每个时刻黑、白块数就好了（  

ps：也可以用 Link-Cut Tree 来维护，时间复杂度是一样的，但常数显而易见地大；而这里只用维护连通性，所以没有必要。

参考代码：  
```cpp
#include<cstdio> 
#include<iostream>
#include<cstring>
#include<algorithm>
#include<vector>
#include<cmath>
#include<map>
#define reg register
#define ll long long
#define N 40003
#define mid ((l+r)>>1)
using namespace std;

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

void print(int x){
    if(x>9) print(x/10);
    putchar(x%10+'0');
}

struct edge{
	int u,v;
	inline edge(int u=0,int v=0):u(u),v(v){}
	inline bool operator < (const edge& x) const{
		return u==x.u?v<x.v:u<x.u;
	}
};

const int dx[4] = {1,-1,0,0};
const int dy[4] = {0,0,1,-1};
int n,m,q;
int blk[N]; //只记录黑块数量就够了

struct solver{ //对于黑白分别计算
	int fa[N],size[N],stk[N],ans[N];
	vector<edge> adj[N<<1];
	map<edge,int> mp;
	int top,cnt,qwq;
	
	void init(){
		cnt = n;
		for(reg int i=1;i<=n;++i)
			fa[i] = i,size[i] = 1;	
	}
	
	inline int find(int x){
		while(x!=fa[x]) x = fa[x];
		return x;	
	}
	
	inline void merge(int u,int v){ //按秩合并
		int fu = find(u),fv = find(v);
		if(fu==fv) return;
		--cnt;
		if(size[fu]<size[fv]) swap(fu,fv);
		fa[fv] = fu;
		size[fu] += size[fv];	
		stk[++top] = fv;
	}
	
	inline void cancel(){ //撤销
		++cnt;
		int u = stk[top--];
		size[fa[u]] -= size[u];
		fa[u] = u;
	}	
	
	void insert(int nl,int nr,int l,int r,int u,edge k){
		if(nl<=l&&r<=nr) return adj[u].push_back(k);
		if(nl<=mid) insert(nl,nr,l,mid,u<<1,k);
		if(nr>mid) insert(nl,nr,mid+1,r,u<<1|1,k);
	}
	 
	void solve(int l,int r,int k){
		int lst = top,ln = adj[k].size();
		for(reg int i=0;i!=ln;++i) merge(adj[k][i].u,adj[k][i].v);	//加入边
		if(l==r) ans[++qwq] = cnt;
		else{
			solve(l,mid,k<<1);
			solve(mid+1,r,k<<1|1);	
		}
		while(top>lst) cancel(); //回溯
	}
};

solver G[2];
int a[N],tr[203][203];

int main(){ 
	int x = 0,y,nx,ny,u,v,tim,k;
    read(n);
    m = n,n *= n;
    G[0].init();
    G[1].init();
    for(reg int i=1;i<=m;++i)
    for(reg int j=1;j<=m;++j){
    	tr[i][j] = ++x;
    	read(a[x]);
    	if(a[x]==1) ++blk[0];
    }
    for(reg int i=1;i<=m;++i)
    for(reg int j=1;j<=m;++j){
    	for(reg int k=0;k<4;++k){
			nx = i+dx[k],ny = j+dy[k];
			if(nx<1||nx>m||ny<1||ny>m) continue;
			u = tr[i][j];
			v = tr[nx][ny];
			if(u>v) swap(u,v);
			if(a[u]==a[v]) G[a[u]].mp[edge(u,v)] = 1; //同色,连边
		}
    }
    read(q);
    for(reg int i=1;i<=q;++i){
    	read(x),read(y);
		u = tr[x][y];
		blk[i] = blk[i-1]+(a[u]==1?-1:1);
		a[u] ^= 1;
		for(reg int j=0;j<4;++j){
			nx = x+dx[j],ny = y+dy[j];
			if(nx<1||nx>m||ny<1||ny>m) continue;
			u = tr[x][y];
			v = tr[nx][ny];
			k = a[v];
			if(u>v) swap(u,v);
			if(a[u]==a[v]) G[a[u]].mp[edge(u,v)] = i;
			else{ //不同色,断开并在线段树上标记
				if(!G[k].mp.count(edge(u,v))) continue;
				tim = G[k].mp[edge(u,v)];
				if(i>tim) G[k].insert(tim,i-1,1,q,1,edge(u,v));
				G[k].mp.erase(edge(u,v));
			}
		}
    }
    for(reg int k=0;k!=2;++k){ //最后剩的边再加到线段树上
    	map<edge,int>::iterator it = G[k].mp.begin(),ed = G[k].mp.end();
		for(;it!=ed;++it){
			G[k].insert(it->second,q,1,q,1,it->first);	
		}
    }
    G[0].solve(1,q,1);
	G[1].solve(1,q,1);
    for(reg int i=1;i<=q;++i){
    	x = G[1].ans[i],y = G[0].ans[i];
		x = x-(n-blk[i]);
		y = y-blk[i];
		printf("%d %d\n",x,y);	
    }
    return 0;
}
```

---

## 作者：Cyhlnj (赞：6)

直接线段树分治 $+$ 带撤销的并查集就好了

按照时间分治即可

非常的模板啊。。。

```cpp
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;

namespace IO {
    const int maxn(1 << 21 | 1);

    char ibuf[maxn], *iS, *iT, c;
    int f;

    inline char Getc() {
        return iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, maxn, stdin), (iS == iT ? EOF : *iS++)) : *iS++;
    }

    template <class Int> inline void In(Int &x) {
        for (f = 1, c = Getc(); c < '0' || c > '9'; c = Getc()) f = c == '-' ? -1 : 1;
        for (x = 0; c >= '0' && c <= '9'; c = Getc()) x = x * 10 + (c ^ 48);
        x *= f;
    }
}

using IO :: In;

const int maxn(1e5 + 5);

int n, m, nn, tot, col[205][205], id[2][205][205], lst[maxn * 10], fr[maxn * 10], to[maxn * 10], cntw[maxn];
map < pair <int, int>, int> pid;

struct Info {
	int c, u, v;
};

vector <Info> mdy[maxn << 1];

struct DSU {
	int fa[maxn], deep[maxn], top, cnt;

	struct Stack {
		int fx, dy;
	} sta[maxn];

	inline void Init(int num) {
		for (int i = 1; i <= num; ++i) fa[i] = i;
	}

	int Find(int x) {
		return fa[x] == x ? x : Find(fa[x]);
	}

	inline void Merge(int u, int v) {
		int fx = Find(u), fy = Find(v);
		if (fx == fy) return;
		if (deep[fx] > deep[fy]) swap(fx, fy);
		sta[++top] = (Stack){fx, deep[fy]};
		fa[fx] = fy, ++cnt;
		if (deep[fx] == deep[fy]) ++deep[fy];
	}

	inline void Undo(int tp) {
		while (top > tp) {
			deep[fa[sta[top].fx]] = sta[top].dy;
			fa[sta[top].fx] = sta[top].fx;
			--cnt, --top;
		}
	}
} blk, wht;

void Modify(int x, int l, int r, int ql, int qr, Info v) {
	if (ql <= l && qr >= r) mdy[x].push_back(v);
	else {
		int mid = (l + r) >> 1;
		if (ql <= mid) Modify(x << 1, l, mid, ql, qr, v);
		if (qr > mid) Modify(x << 1 | 1, mid + 1, r, ql, qr, v);
	}
}

# define mr make_pair

inline void Add(int u, int v) {
	pid[mr(u, v)] = ++tot, fr[tot] = u, to[tot] = v;
}

inline void Cut(int c, int u, int v, int tim) {
	if (u > v) swap(u, v);
	Modify(1, 0, m, lst[pid[mr(u, v)]], tim - 1, (Info){c, u, v});
	lst[pid[mr(u, v)]] = -1;
}

inline void Link(int u, int v, int tim) {
	if (u > v) swap(u, v);
	lst[pid[mr(u, v)]] = tim;
}

void Solve(int x, int l, int r) {
	int top1 = blk.top, top2 = wht.top;
	for (int i = 0, s = mdy[x].size(); i < s; ++i) {
		int c = mdy[x][i].c, u = mdy[x][i].u, v = mdy[x][i].v;
		c ? blk.Merge(u - nn, v - nn) : wht.Merge(u, v);
	}
	if (l == r) {
		if (l) printf("%d %d\n", nn - cntw[l] - blk.cnt, cntw[l] - wht.cnt);
		blk.Undo(top1), wht.Undo(top2);
		return;
	}
	int mid = (l + r) >> 1;
	Solve(x << 1, l, mid), Solve(x << 1 | 1, mid + 1, r);
	blk.Undo(top1), wht.Undo(top2);
}

int main() {
	memset(lst, -1, sizeof(lst)), memset(col, -1, sizeof(col));
	In(n), nn = n * n, blk.Init(nn), wht.Init(nn);
	for (int i = 1, t = 0; i <= n; ++i)
		for (int j = 1; j <= n; ++j) In(col[i][j]), id[0][i][j] = ++t;
	for (int i = 1, t = nn; i <= n; ++i)
		for (int j = 1; j <= n; ++j) id[1][i][j] = ++t;
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= n; ++j) {
			if (i != n) Add(id[0][i][j], id[0][i + 1][j]), Add(id[1][i][j], id[1][i + 1][j]);
			if (j != n) Add(id[0][i][j], id[0][i][j + 1]), Add(id[1][i][j], id[1][i][j + 1]);
			cntw[0] += col[i][j] == 0;
		}
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= n; ++j) {
			int c = col[i][j];
			if (i != n && c == col[i + 1][j]) Link(id[c][i][j], id[c][i + 1][j], 0);
			if (j != n && c == col[i][j + 1]) Link(id[c][i][j], id[c][i][j + 1], 0);
		}
	In(m);
	for (int i = 1, x, y, c; i <= m; ++i) {
		In(x), In(y), c = col[x][y], cntw[i] = cntw[i - 1];
		if (col[x - 1][y] == c) Cut(c, id[c][x][y], id[c][x - 1][y], i);
		if (col[x + 1][y] == c) Cut(c, id[c][x][y], id[c][x + 1][y], i);
		if (col[x][y - 1] == c) Cut(c, id[c][x][y], id[c][x][y - 1], i);
		if (col[x][y + 1] == c) Cut(c, id[c][x][y], id[c][x][y + 1], i);
		if (!col[x][y]) --cntw[i];
		c ^= 1, col[x][y] ^= 1;
		if (!col[x][y]) ++cntw[i];
		if (col[x - 1][y] == c) Link(id[c][x][y], id[c][x - 1][y], i);
		if (col[x + 1][y] == c) Link(id[c][x][y], id[c][x + 1][y], i);
		if (col[x][y - 1] == c) Link(id[c][x][y], id[c][x][y - 1], i);
		if (col[x][y + 1] == c) Link(id[c][x][y], id[c][x][y + 1], i);
	}
	for (int i = 1; i <= tot; ++i) if (lst[i] != -1) Cut(fr[i] > nn, fr[i], to[i], m + 1);
	Solve(1, 0, m);
    return 0;
}
```

---

## 作者：1234567s (赞：5)

求动态连通块个数。  
无法直接做，考虑使用时间分治使影响个数可控。  
具体地，对时间开线段树，将每种连边影响的时间范围用永久化标记的形式挂到树上，用回滚的方式加入所有影响。    
内部判断连通性，使用回滚并查集或动态树维护。  
```cpp
//依旧是时间分治
//找出会和周围点连边的范围,进行修改 
//两个并查集分别维护不同颜色的连通块数量 
#include<bits/stdc++.h>
using namespace std;
#define N 205
#define M 10005
namespace lzz
{
	int n,m,q;
	struct kkk
	{
		int u,v,l,r,c;//加一维颜色 
	}t[M<<4];//边 
	struct node
	{
		vector<kkk>mq;//存储所有修改询问 
	}tree[M<<2];
	int col[N][N];
	void modify(int p,int l,int r,kkk val)
	{
		if(l>val.r||r<val.l)return ;
		if(val.l<=l&&r<=val.r)//这里注意,时间被修改完全覆盖再加入 
		{
			tree[p].mq.push_back(val);
			return ;
		}
		int mid=(l+r)>>1;
		modify(p<<1,l,mid,val),modify(p<<1|1,mid+1,r,val);
	}
	map<pair<int,int> ,int>bj;
	int init(int u,int v)
	{
		if(bj[{u,v}])return bj[{u,v}];
		bj[{u,v}]=++m;
		t[m].u=u,t[m].v=v;
		return m;
	}
	int dx[5]={0,0,1,-1},dy[5]={1,-1,0,0};
	int get(int x,int y){return (x-1)*n+y;}
	void change(int x,int y,int tm)//改单点 
	{
		if(tm!=0)col[x][y]^=1;
		for(int i=0;i<4;i++)
		{
			int ex=x+dx[i],ey=y+dy[i];
			if(ex>n||ey>n||ex<1||ey<1)continue;
			int u=get(x,y),v=get(ex,ey);
			if(u>v)swap(u,v);
			if(col[x][y]==col[ex][ey])
			{
				int now=init(u,v);
				t[now].l=tm,t[now].c=col[x][y];//从此刻开始连接
			}
			else //之前一定是连过的 
			{
				if(tm==0)continue;
				t[bj[{u,v}]].r=tm;//生效区间趋势
				bj[{u,v}]=0;
			} 
		}
	}
	//记录每条边存在的时间 
	struct huisu
	{
		int x,fa_x,size_x;
		int y,fa_y,size_y;
	};
	struct DSU
	{
		int ans;
		int fa[N*N],size[N*N];
		huisu stk[M<<2]; int top;
		int find(int x){return x==fa[x]?x:find(fa[x]);}
		void init(){for(int i=1;i<=n*n;i++)fa[i]=i,size[i]=1;}
		void merge(int u,int v)//每次栈中都会使其少一个连通块 
		{
			u=find(u),v=find(v);
			if(u==v)return ; ans++;
			if(size[u]<size[v])swap(u,v);
			stk[++top]={u,fa[u],size[u],v,fa[v],size[v]};
			size[u]+=size[v],fa[v]=u;//合并 
		}
		void del(int now)
		{
			while(top>now)//改掉 
			{
				ans--;
				int x=stk[top].x,fax=stk[top].fa_x,sizex=stk[top].size_x;
				int y=stk[top].y,fay=stk[top].fa_y,sizey=stk[top].size_y;
				fa[x]=fax,size[x]=sizex;
				fa[y]=fay,size[y]=sizey;
				top--;
			}
		}
	}T[2]; 
	int ans1[M],ans2[M];
	void query(int p,int l,int r)
	{
		int mid=(l+r)>>1;
		int now1=T[0].top,now2=T[1].top;//滚回还没有执行这些操作的时候 
		for(int i=0;i<tree[p].mq.size();i++)
		{
			int u=tree[p].mq[i].u,v=tree[p].mq[i].v,c=tree[p].mq[i].c;
			T[c].merge(u,v);
		}
		if(l==r)ans1[l]=T[0].ans,ans2[l]=T[1].ans;
		else query(p<<1,l,mid),query(p<<1|1,mid+1,r);
		T[0].del(now1),T[1].del(now2);
	}
	int blk[M];
	int main()
	{
		cin>>n;
		for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)cin>>col[i][j],blk[0]+=col[i][j];
		for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)change(i,j,0);//时间
		cin>>q;
		for(int i=1;i<=q;i++)
		{
			int x,y;
			cin>>x>>y,blk[i]-=col[x][y],change(x,y,i);
			blk[i]+=blk[i-1]+col[x][y];
		} 
		for(int i=1;i<=m;i++)
		{
			if(t[i].r==0)t[i].r=q+1; t[i].r--;
			modify(1,1,q,t[i]);
		}
		T[0].init(),T[1].init(),query(1,1,q);
		for(int i=1;i<=q;i++)cout<<blk[i]-ans2[i]<<' '<<(n*n-blk[i])-ans1[i]<<'\n';
		return 0;
	}
}
int main()
{
	return lzz::main();
}
```

---

## 作者：XiaoQuQu (赞：5)

给一个比较好懂的线段树套并查集的解法。

考虑让每一个线段树的叶子节点维护一整行，然后其他非叶子节点维护他所在区间的行的连通性，对于每一个线段树节点用两个并查集分别维护最上一行、最下一行的连通情况。

注意，我们这里说“连通情况”，是针对每一个节点所维护的行的区间的内部来说的，如下图的这种情况，虽然块 1 与块 2 在全图是连通的，但是对于我们当前考虑的范围他们却是分属于不同的连通块。

![image.png](https://zshfoj.com/file/2/4KtVRaHGP6DkMZ2.png)

对于一次 `pushup` 操作，整个大的区间连通情况，其实只用考虑上下两个小区间的合并的情况。

![image.png](https://zshfoj.com/file/2/qCwvytUNYPLbhjK.png)

如上图，我们挨个遍历**上区间的最后一行**与**下区间的第一行**，如果发现相邻的两个颜色相同，说明他们俩在最终的图里应该是一个连通块，就将他们两个合并。

对于修改操作，我们从线段树的根节点出发，一直遍历到修改的行的节点，然后暴力地更新路径上的每一个线段树的节点即可，由于我们最多遍历 $\log n$ 层，所以复杂度不会超过 $O(n\log n \alpha(n))$。

最终总时间复杂度 $O(mn\log n\cdot\alpha (n))$，其中 $\alpha (n)$ 是并查集单次修改的复杂度，为了代码简便可换用 $O(\log n)$ 的路径压缩实现。

```cpp
const int MAXN = 205;
struct _node {
	int bl, wh, ls, rs;
	int fu[MAXN], fd[MAXN];
} tr[MAXN << 2];
int a[MAXN][MAXN], n, fa[MAXN * MAXN], m;

int nod(int x, int y) {
	return (x - 1) * n + y;
}

void merge(int x, int y) {
	if (rand() & 1) fa[x] = y;
	else fa[y] = x;
}

int find(int x) {
	if (fa[x] == x) return x;
	else return fa[x] = find(fa[x]);
}

void pushup(int p) {
	int bl = 0, wh = 0, u = tr[lson].rs, d = tr[rson].ls;
	for (int i = 1; i <= n; ++i) tr[p].fu[i] = tr[lson].fu[i], tr[p].fd[i] = tr[rson].fd[i];
	for (int i = 1; i <= n; ++i) fa[tr[lson].fu[i]] = tr[lson].fu[i], fa[tr[lson].fd[i]] = tr[lson].fd[i];
	for (int i = 1; i <= n; ++i) fa[tr[rson].fu[i]] = tr[rson].fu[i], fa[tr[rson].fd[i]] = tr[rson].fd[i];
	for (int i = 1; i <= n; ++i) {
		if (a[u][i] == a[d][i]) {
			int x = find(tr[lson].fd[i]), y = find(tr[rson].fu[i]);
			if (x == y) continue;
			merge(x, y);
			if (a[u][i] == 0) ++wh;
			else ++bl;
		}
	}
	tr[p].bl = tr[lson].bl + tr[rson].bl - bl;
	tr[p].wh = tr[lson].wh + tr[rson].wh - wh;
	for (int i = 1; i <= n; ++i) tr[p].fu[i] = find(tr[p].fu[i]), tr[p].fd[i] = find(tr[p].fd[i]);
}

void build(int p, int l, int r) {
	tr[p].ls = l, tr[p].rs = r;
	if (l == r) {
		a[l][0] = -1;
		for (int i = 1; i <= n; ++i) tr[p].fu[i] = tr[p].fd[i] = fa[nod(l, i)] = nod(l, i);
		for (int i = 1; i <= n; ++i) {
			if (a[l][i] == 0) {
				if (a[l][i] == a[l][i - 1]) tr[p].fu[i] = tr[p].fd[i] = fa[nod(l, i)] = fa[nod(l, i - 1)];
				else ++tr[p].wh;
			}
			else {
				if (a[l][i] == a[l][i - 1]) tr[p].fu[i] = tr[p].fd[i] = fa[nod(l, i)] = fa[nod(l, i - 1)];
				else ++tr[p].bl;
			}
		}
		return;
	}
	build(lson, l, mid); build(rson, mid + 1, r);
	pushup(p);
}

void update(int p, int l, int r, int x) {
	if (l == r) {
		a[l][0] = -1; tr[p].wh = tr[p].bl = 0;
		for (int i = 1; i <= n; ++i) tr[p].fu[i] = tr[p].fd[i] = fa[nod(l, i)] = nod(l, i);
		for (int i = 1; i <= n; ++i) {
			if (a[l][i] == 0) {
				if (a[l][i] == a[l][i - 1]) tr[p].fu[i] = tr[p].fd[i] = fa[nod(l, i)] = fa[nod(l, i - 1)];
				else ++tr[p].wh;
			}
			else {
				if (a[l][i] == a[l][i - 1]) tr[p].fu[i] = tr[p].fd[i] = fa[nod(l, i)] = fa[nod(l, i - 1)];
				else ++tr[p].bl;
			}
		}
		return;
	}
	if (x <= mid) update(lson, l, mid, x);
	else update(rson, mid + 1, r, x);
	pushup(p);
}

void work() {
	cin >> n;
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= n; ++j) cin >> a[i][j];
	}
	build(1, 1, n);
	cin >> m;
	while (m--) {
		int x, y; cin >> x >> y;
		a[x][y] = !a[x][y]; // 暴力修改
		update(1, 1, n, x); // 重新计算路径上的连通性
		cout << tr[1].bl << ' ' << tr[1].wh << endl;
	}
}
```


---

## 作者：TheLostWeak (赞：4)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/BZOJ1453.html)

**大致题意：** 给你一个$n*n$的黑白棋盘，每次将一个格子翻转，分别求黑色连通块和白色连通块的个数。

------

#### $LCT$动态维护图连通性

关于这一部分内容，可以参考这道例题：[【BZOJ4025】二分图](https://www.cnblogs.com/chenxiaoran666/p/BZOJ4025.html)。

------

#### 大致思路

我们可以将同种颜色的相邻格子之间连边，这样就可以把问题搬到图上。

然后考虑先离线，把每两个格子间边的加入与删除的时间（同一条边可能被加入和删除多次）记录下来。

这样就可以用$LCT$动态维护图连通性了。

但注意这道题比较恶心，需要你每次求出两种颜色的连通块个数。

我一开始的想法是对于每个询问暴力枚举$LCT$的每一个根节点，判断其为黑色还是白色（我们可以给每条边也记录下对应的颜色），从而统计答案，但是毫无悬念地$TLE$了。

看来，只能在删边与加边的同时动态维护了。

在加边时，若连接的两个节点在不同的树中，就说明要合并两个连通块，因此将该颜色连通块个数减$1$。

在删边时，若连接的两个节点依靠这条边连通，即这条边原先并没有在$LCT$中被删掉过，就说明会使一个连通块分成两个，因此将该颜色连通块个数加$1$。

要注意的是，当你翻转一个格子时，要将原先颜色的连通块个数减$1$，并将新颜色的连通块个数加$1$，不然在加边删边的过程中会出现重复计算的问题。

具体实现可见代码。

------

#### 代码

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define N 200
#define M 10000
#define E ((N*N<<2)+(M<<3))
#define P(x,y) (((x)-1)*n+(y))
#define swap(x,y) (x^=y^=x^=y)
#define mp make_pair
#define INF 1e9
using namespace std;
const int dx[4]={1,-1,0,0},dy[4]={0,0,1,-1};
int n,m,ans[2],a[N*N+5],s[N*N+5],qx[M+5],qy[M+5],tx[N*N+E+5],ty[N*N+E+5],lst[N*N+E+5];map<pair<int,int>,int> t;
struct Operate//存储下每一个操作
{
    int x,y,c,t,f,p,d;
    I Operate(CI a=0,CI b=0,CI co=0,CI ti=0,CI fl=0):x(a),y(b),c(co),t(ti),f(fl){}
}o[E+5];
class FastIO
{
    private:
        #define FS 100000
        #define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)
        #define pc(c) (C^FS?FO[C++]=c:(fwrite(FO,1,C,stdout),FO[(C=0)++]=c))
        #define tn(x) (x<<3)+(x<<1)
        #define D isdigit(c=tc())
        int T,C;char c,*A,*B,FI[FS],FO[FS],S[FS];
    public:
        I FastIO() {A=B=FI;}
        Tp I void read(Ty& x) {x=0;W(!D);W(x=tn(x)+(c&15),D);}
        Tp I void write(Ty x) {W(S[++T]=x%10+48,x/=10);W(T) pc(S[T--]);}
        Ts I void read(Ty& x,Ar&... y) {read(x),read(y...);}
        Tp I void writeln(Con Ty& x) {write(x),pc('\n');}
        I void write_space() {pc(' ');}
        I void clear() {fwrite(FO,1,C,stdout),C=0;}
}F;
class LinkCutTree//LCT
{
    private:
        #define GVmin(x,y) (V[O[x].Min]>V[O[y].Min]&&(O[x].Min=O[y].Min))
        #define PU(x) (O[x].Min=x,GVmin(x,O[x].S[0]),GVmin(x,O[x].S[1]))//上传子树信息
        #define Re(x) (swap(O[x].S[0],O[x].S[1]),O[x].R^=1)
        #define PD(x) (O[x].R&&(Re(O[x].S[0]),Re(O[x].S[1]),O[x].R=0))
        #define Wh(x) (O[O[x].F].S[1]==x)
        #define Co(x,y,d) (O[O[x].F=y].S[d]=x)
        #define IR(x) (O[O[x].F].S[0]^x&&O[O[x].F].S[1]^x)
        #define MR(x) (Ac(x),S(x),Re(x))
        #define Sp(x,y) (MR(x),Ac(y),S(y)) 
        static const int SZ=N*N+E;int St[SZ+5];struct node {int Min,R,F,S[2];}O[SZ+5];
        I void Ro(CI x) {RI f=O[x].F,p=O[f].F,d=Wh(x);!IR(f)&&(O[p].S[Wh(f)]=x),O[x].F=p,Co(O[x].S[d^1],f,d),Co(f,x,d^1),PU(f),PU(x);}
        I void S(CI x) {RI f=x,T=0;W(St[++T]=f,!IR(f)) f=O[f].F;W(T) PD(St[T]),--T;W(!IR(x)) f=O[x].F,!IR(f)&&(Ro(Wh(x)^Wh(f)?x:f),0),Ro(x);}
        I void Ac(RI x) {for(RI s=0;x;x=O[s=x].F) S(x),O[x].S[1]=s,PU(x);}
    public:
        int C[SZ+5],V[SZ+5],T[SZ+5];I LinkCutTree() {V[0]=INF+1;}
        I void Init(CI n) {for(RI i=1,s=n*n;i<=s;++i) V[O[i].Min=i]=INF+1,C[i]=a[i],T[i]=1;}//初始化每个点被删除时间为INF+1，记录其颜色，标记其在树中
        I void Link(CI x,CI y) {MR(x),O[x].F=y;}I void Cut(CI x,CI y) {MR(x),Ac(y),S(x),O[y].F=O[x].S[1]=0,PU(x);}
        I int FR(RI x) {Ac(x),S(x);W(O[x].S[0]) PD(x),x=O[x].S[0];return S(x),x;}
        I int QMin(CI x,CI y) {return Sp(x,y),O[y].Min;}//查询子树中最早被删掉的边
        I int Query(CI tot,CI op) {RI i,res=0;for(i=1;i<=tot;++i) T[i]&&!O[i].F&&!(C[i]^op)&&++res;return res;}//询问颜色为op的连通块个数（用于初始化ans）
        I void RC(CI x) {C[x]^=1;}//翻转某个点的颜色
}T;
I void Add(CI pos)//加入一条边
{
    RI x=o[pos].x,y=o[pos].y,z=o[pos].p;
    if(T.C[z]=o[pos].c,T.V[z]=o[pos].d,T.FR(x)^T.FR(y)) return --ans[T.C[z]],T.T[z]=1,T.Link(x,z),T.Link(z,y);//合并两个连通块，则将该颜色连通块个数减1
    RI p=T.QMin(x,y);if(T.V[z]<T.V[p]) return;
    T.T[p]=0,T.Cut(tx[p],p),T.Cut(p,ty[p]),T.T[z]=1,T.Link(x,z),T.Link(z,y);
}
I void Del(CI pos)//删除一条边
{
    RI x=o[pos].x,y=o[pos].y,z=o[pos].p;
    !(T.FR(x)^T.FR(z))&&!(T.FR(y)^T.FR(z))&&(++ans[T.C[z]],T.T[z]=0,T.Cut(x,z),T.Cut(z,y),0);//分裂一个连通块，则将该颜色连通块个数加1
}
int main()
{
    RI i,j,k=1,tot,cnt=0,p,nx,ny,p1,p2;Reg pair<int,int> w;
    for(F.read(n),i=1;i<=n;++i) for(j=1;j<=n;++j) F.read(a[P(i,j)]),s[P(i,j)]=a[P(i,j)];//读入，用s数组复制一遍a数组
    for(T.Init(n),i=1;i<=n;++i) for(j=1;j<=n;++j)//初始化出原图的边
    {
        i^n&&!(a[P(i,j)]^a[P(i+1,j)])&&(o[++cnt]=Operate(P(i,j),P(i+1,j),a[P(i,j)],0,1),0),//向下
        j^n&&!(a[P(i,j)]^a[P(i,j+1)])&&(o[++cnt]=Operate(P(i,j),P(i,j+1),a[P(i,j)],0,1),0);//向右
    }
    for(F.read(m),i=1;i<=m;++i)//离线处理出每个加边和删边操作
    {
        for(F.read(qx[i],qy[i]),a[p=P(qx[i],qy[i])]^=1,j=0;j^4;++j)
        {
            if((nx=qx[i]+dx[j])<1||nx>n||(ny=qy[i]+dy[j])<1||ny>n) continue;
            p1=p,p2=P(nx,ny),p1>p2&&swap(p1,p2),o[++cnt]=Operate(p1,p2,a[p1]^a[p2]?-1:a[p1],i,a[p1]^a[p2]?-1:1);
        }
    }
    for(tot=n*n,i=1;i<=cnt;++i) !t[w=mp(o[i].x,o[i].y)]&&(t[w]=++tot,tx[t[w]]=o[i].x,ty[t[w]]=o[i].y),o[i].p=t[w];//给边标号，这样便于将边看作一个节点
    for(i=cnt;i;--i) ~o[i].f?(o[i].d=lst[o[i].p]?lst[o[i].p]:INF):(lst[o[i].p]=o[i].t);//倒序枚举，求出每条边的出现和删除时间
    W(k<=cnt&&!o[k].t) Add(k++);//先将原图的边加到图上
	for(ans[0]=T.Query(tot,0),ans[1]=T.Query(tot,1),i=1;i<=m;++i)//初始化ans，然后处理操作 
    {
        p=P(qx[i],qy[i]),--ans[s[p]],++ans[s[p]^=1],T.RC(p);W(k<=cnt&&!(o[k].t^i)) ~o[k].f?Add(k++):Del(k++);//更新信息
        F.write(ans[1]),F.write_space(),F.writeln(ans[0]);//输出答案
    }
    return F.clear(),0;
}
```

---

## 作者：RedLycoris (赞：2)

赛后写题解补教训 ![](http://啧.tk/tuu)


场上数组开小本机AC但开了O2就会RE=爆零 ![](http://啧.tk/tuu)

洛谷上测由于数组开小导致访问不到死递归MLE我还以为还是开大了![](http://啧.tk/tuu)

小心，小心，再小心 ![](http://啧.tk/tuu)

---

我们尝试建立一棵线段树。

线段树的每一个叶子节点是一行，每一个节点是一段行。

每一个节点存上两个东西：

+ 两个并查集，记录这个节点所对应的行区间的最上面一行和最下面一行的状态（后面会讲到）

+ 这个区间内部两种颜色的连通块的个数

对于单独的每一行，我们搞一个并查集：如果在这一行中，$i\dots j$ 的颜色相同，那么我们把 $i\dots j$ 都放到同一个集合中。用最小表示法，这个集合的代表就是最小的元素 $i$。

我们考虑合并两个行区间。

显然，新的行区间的上并查集就是左儿子的上并查集，新区间的下并查集就是右儿子的下并查集。

考虑左儿子的下并查集与右儿子的上并查集结合所带来的贡献。

首先令新节点的颜色 $c$ 的连通块数等于其两个儿子的该颜色的连通块数之和。

然后枚举，对于第 $i$ 列，如果 $gird_{md,i} = gird_{md+1,i}$，那么显然这两个在同一个连通块中，要将该颜色的数量-1。

然后写个标准的线段树就完事了~

总时间复杂度 ~~O(能过)~~  $O(n^2+mnlogn)$

Code:

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mp make_pair
#define int short
using namespace std;
const int mxn=808;
int gird[mxn][mxn],n,m,q;
	struct dsu{
		int fa[mxn<<1];
		inline int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
		inline void uni(int x,int y){
			x=find(x),y=find(y);
			fa[x]=y;
		}
		inline void init(){for(int i=1;i<(mxn<<1);++i)fa[i]=i;}
	}f;
	int stand[mxn];
	struct node{
		dsu d;
		int son[2],ans[2];
		inline void init(){
			ans[0]=0,ans[1]=0;d.init();
			son[0]=0,son[1]=0;
		}
	}t[mxn<<1];
	inline void ForceUpdate(int id,int x){
		t[id].init();
		t[id].ans[gird[x][1]]=1;
		t[id].ans[1-gird[x][1]]=0;
		int pre=1;
		for(int i=1;i<=m;++i){
			if(gird[x][i]!=gird[x][pre]){
				++t[id].ans[gird[x][i]];
				pre=i;
			}
			t[id].d.uni(i,pre),t[id].d.uni(i+n,pre);
		}
	}
	inline void pushup(int id,int md,int l,int r){
		f.init();
		for(int i=0;i<2;++i)t[id].ans[i]=t[l].ans[i]+t[r].ans[i];
		for(int i=1;i<=m*2;++i)f.fa[i]=t[l].d.fa[i],f.fa[i+m*2]=t[r].d.fa[i]+m*2;
		for(int i=1;i<=m;++i){
			int fx=f.find(i+m),fy=f.find(i+2*m);
			if(gird[md][i]==gird[md+1][i] and fx!=fy){
				--t[id].ans[gird[md][i]];
				f.uni(fx,fy);
			}
		}
		memset(stand,0,sizeof(stand));     // stand 数组的用处是最小表示
		for(int i=m;i;--i){
			f.fa[i]=f.find(i);
			stand[f.fa[i]]=i;
		}
		for(int i=m*2;i>m;--i){
			f.fa[i+m*2]=f.find(i+m*2);
			stand[f.fa[i+m*2]]=i;
		}
		for(int i=1;i<=m;++i){
			t[id].d.fa[i]=stand[f.fa[i]];
			t[id].d.fa[i+m]=stand[f.fa[i+m*3]];
		}
	}
	int cntnode=0,root;
	inline void build(int&id,int l,int r){
		id=++cntnode;
		if(l==r){
			ForceUpdate(id,l);
			return;
		}
		int md=l+r>>1;
		build(t[id].son[0],l,md);
		build(t[id].son[1],md+1,r);
		pushup(id,md,t[id].son[0],t[id].son[1]);
	}
	inline void upd(int id,int l,int r,int x){
		if(l==r){
			ForceUpdate(id,x);
			return;
		}
		int md=l+r>>1;
		if(x<=md)upd(t[id].son[0],l,md,x);
		else upd(t[id].son[1],md+1,r,x);
		pushup(id,md,t[id].son[0],t[id].son[1]);
	}
	inline void glhf(){
		build(root,1,n);
		for(;q--;){
			int x,y;
			cin>>x>>y;
			gird[x][y]^=1;
			upd(root,1,n,x);
			cout<<t[root].ans[1]<<' '<<t[root].ans[0]<<'\n';
		}
	}
inline void solve(){
	cin>>n;m=n;
	for(int i=1;i<=n;++i)for(int j=1;j<=m;++j)cin>>gird[i][j];
	cin>>q;
	glhf();
}
signed main(){
	ios_base::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int T;T=1;
//	cin>>T;
	for(;T--;)solve();
	return 0;
}
```

---

## 作者：sodalyghat (赞：1)

### 分析
把这个网格当作一个无向图，每次修改点的颜色的时候枚举它周围的四个点，在对应的时间区间建边。如果现在颜色相同，那么就给这个边打上时间戳，否则就用上一次的时间戳到现在的前一个时间点在树上加入这个边的贡献。然后就可以操作序列分治了。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int, int> pii;
namespace Luo_ty{
	const int MAXN = 40005;
	int ls[MAXN << 2], rs[MAXN << 2];
	struct edge{
		int u, v, op;
	};
	vector<edge> e[MAXN << 2];
	int cnt;
	void Build(int &x, int l, int r){
		x = ++cnt;
		if(l == r) return ;
		int mid = l + r >> 1;
		Build(ls[x], l, mid);
		Build(rs[x], mid + 1, r);
	}
	void change(int x, int l, int r, int L, int R, edge ed){
		if(L <= l && r <= R){
			e[x].push_back(ed);
			return ;
		}
		if(l > R || r < L) return ;
		int mid = l + r >> 1;
		change(ls[x], l, mid, L, R, ed);
		change(rs[x], mid + 1, r, L, R, ed);
	}
	int fa[MAXN], sz[MAXN];
	struct His{
		int x, y, op;
	}his[MAXN << 2];
	int top, n;
	int id(int x, int y){
		return (x - 1) * n + y;
	}
	int belong(int x){
		while(x != fa[x]) x = fa[x];
		return x;
	}
	int numb, numw;
	void Union(int u, int v, int op){
		int x = belong(u), y = belong(v);
		if(x == y) return ;
		if(op) numb++;
		else numw++;
		if(sz[x] < sz[y]) swap(x, y);
		his[++top] = (His){x, y, op};
		fa[y] = x;
		sz[x] += sz[y];
	}
	void roll(){
		int x = his[top].x, y = his[top].y;
		fa[y] = y;
		sz[x] -= sz[y];
		if(his[top].op) numb--;
		else numw--;
		top--;
	}
	int blk[MAXN];
	void dfs(int x, int l, int r){
		int tmp = top;
		for(edge i : e[x]) Union(i.u, i.v, i.op);
		if(l == r){
			printf("%d %d\n", blk[l] - numb, n * n - blk[l] - numw);
		}
		else{
			int mid = l + r >> 1;
			dfs(ls[x], l, mid);
			dfs(rs[x], mid + 1, r);
		}
		while(top != tmp) roll();
	}
	int c[205][205];
	map<pii, int> t;
	int dx[4] = {0, 1, 0, -1};
	int dy[4] = {1, 0, -1, 0};
	int main(){
		scanf("%d", &n);
		for(int i = 1;i <= n;i++){
			for(int j = 1;j <= n;j++){
				scanf("%d", &c[i][j]);
				blk[0] += c[i][j];
				fa[id(i, j)] = id(i, j);
				sz[id(i, j)] = 1;
			}
		}
		int q, rt;
		scanf("%d", &q);
		for(int i = 1;i <= n;i++){
			for(int j = 1;j <= n;j++){
				for(int k = 0, x, y;k < 4;k++){
					x = i + dx[k], y = j + dy[k];
					if(1 <= x && x <= n && 1 <= y && y <= n){
						if(c[i][j] == c[x][y]){
							int a = id(i, j), b = id(x, y);
							if(a > b) swap(a, b);
							t[make_pair(a, b)] = 1;
						}
					}
				} 
			}
		}
		Build(rt, 1, q);
		for(int i = 1, x, y;i <= q;i++){
			scanf("%d%d", &x, &y);
			c[x][y] ^= 1;
			if(c[x][y]) blk[i] = blk[i - 1] + 1;
			else blk[i] = blk[i - 1] - 1;
			for(int ii = 0;ii < 4;ii++){
				int X = x + dx[ii], Y = y + dy[ii];
				if(1 <= X && X <= n && 1 <= Y && Y <= n){
					int a = id(x, y), b = id(X, Y);
					if(a > b) swap(a, b);
					pii I = make_pair(a, b);
					if(c[X][Y] ^ c[x][y]){
						if(t[I] <= i - 1 && t[I]){
							change(1, 1, q, t[I], i - 1, (edge){a, b, c[X][Y]});
						}
						t[I] = 0;
					}
					else{
						t[I] = i;
					}
				}
			}
		}
		for(int i = 1;i <= n;i++){
			for(int j = 1;j <= n;j++){
				for(int k = 0, x, y;k < 4;k++){
					x = i + dx[k], y = j + dy[k];
					if(1 <= x && x <= n && 1 <= y && y <= n){
						int a = id(i, j), b = id(x, y);
						if(a > b) swap(a, b);
						pii I = make_pair(a, b);
						if(t[I]){
							change(1, 1, q, t[I], q, (edge){a, b, c[i][j]});
							t[I] = 0;
						}
					}
				} 
			}
		}
		numb = numw = 0;
		dfs(1, 1, q);
		return 0;
	}
}
int main(){
	return Luo_ty::main();
}
```

---

## 作者：Seauy (赞：1)

题意：动态维护棋盘上连通块个数，单点修改全局查询。

一种在线的做法是线段树套并查集，本质上是动态维护左右儿子的连通性

各种优化全加上的话复杂度貌似是……

时间 $O(mn\alpha(n)\log n)$，空间 $O(n^2)$。

不过并查集其实是多余的，因为儿子合并的时候是个静态问题，而并查集却是动态的。

我们可以记录每个区间左右两边所在连通块的编号（最小表示法），然后在中间部分连通的编号在无向图里连边就行了，在一个块里随便选个代表元，最后统计无向图连通块个数。

设无向图连通块个数为 $x$，原来中间部分的连通块个数为 $y$，那么 $y-x$ 则为左右儿子共有的连通块个数，$Lson+Rson-y+x$ 则为父亲的答案。

这样的话 pushup 操作就是 $O(n)$ 的了 ~~虽然常数会很大~~，总复杂度就为 $O(mn\log n)$。

```cpp
#include<bits/stdc++.h>
#define Lson (now<<1)
#define Rson (now<<1|1)
using namespace std;

const int MAXN=200;
const int MAXM=1e4;

int n,m;

struct SegNode
{
	int Lset[MAXN],Rset[MAXN];
	int sum;
	void Print()
	{
		for(int i=0;i<n;i++) printf("%d ",Lset[i]);printf("\n");
		for(int i=0;i<n;i++) printf("%d ",Rset[i]);printf("\n");
		printf("%d\n",sum);
	}
};

int nxt[4*MAXN][MAXN],Tail[4*MAXN];
int Chief[4*MAXN];bool visit[4*MAXN];
bool mapn[MAXN][MAXN];

void Link(int a,int b)
{
	nxt[a][Tail[a]++]=b;
	nxt[b][Tail[b]++]=a;
}

void DFS(int now,int v)
{
	if(Chief[now]) return;
	Chief[now]=v;
	for(int i=0;i<Tail[now];i++) DFS(nxt[now][i],v);
}

struct SegTree
{
	SegNode node[600];
	void PushUp(int now)
	{
		for(int i=0;i<4*n;i++) Tail[i]=Chief[i]=visit[i]=0;
		for(int i=0;i<n;i++)
			if(node[Lson].Rset[i] && node[Rson].Lset[i])
				Link(node[Lson].Rset[i]-1,node[Rson].Lset[i]-1+2*n);
		node[now].sum=node[Lson].sum+node[Rson].sum;
		for(int i=0;i<n;i++)
		{
			if(node[Lson].Rset[i])
			{
				if(!Chief[node[Lson].Rset[i]-1])
				{
					DFS(node[Lson].Rset[i]-1,node[Lson].Rset[i]);
					++node[now].sum;
				}
				if(!visit[node[Lson].Rset[i]-1]) --node[now].sum;
				visit[node[Lson].Rset[i]-1]=1;
			}
			if(node[Rson].Lset[i])
			{
				if(!Chief[node[Rson].Lset[i]-1+2*n])
				{
					DFS(node[Rson].Lset[i]-1+2*n,node[Rson].Lset[i]+2*n);
					++node[now].sum;
				}
				if(!visit[node[Rson].Lset[i]-1+2*n]) --node[now].sum;
				visit[node[Rson].Lset[i]-1+2*n]=1;
			}
		}
		for(int i=0;i<n;i++)
		{
			if(node[Lson].Lset[i])
			{
				node[now].Lset[i]=Chief[node[Lson].Lset[i]-1];
				if(!node[now].Lset[i]) node[now].Lset[i]=node[Lson].Lset[i];
			}
			else node[now].Lset[i]=0;
			if(node[Rson].Rset[i]) 
			{
				node[now].Rset[i]=Chief[node[Rson].Rset[i]-1+2*n];
				if(!node[now].Rset[i]) node[now].Rset[i]=node[Rson].Rset[i]+2*n;
			}
			else node[now].Rset[i]=0;
		}
		for(int i=0;i<4*n;i++) Chief[i]=0;
		for(int i=0,j=0;i<n;i++)
		{
			if(node[now].Lset[i])
			{
				if(!Chief[node[now].Lset[i]-1]) Chief[node[now].Lset[i]-1]=++j;
				node[now].Lset[i]=Chief[node[now].Lset[i]-1];
			}
			if(node[now].Rset[i])
			{
				if(!Chief[node[now].Rset[i]-1]) Chief[node[now].Rset[i]-1]=++j;
				node[now].Rset[i]=Chief[node[now].Rset[i]-1];
			}
		}
	}
	void Build(int now,int L,int R,bool t)
	{
		if(L==R)
		{
			node[now].sum=0;
			for(int i=0;i<n;i++)
				if(mapn[i][L]==t)
				{
					if(!i) node[now].Lset[0]=++node[now].sum;
					else
					{
						if(mapn[i-1][L]==t) node[now].Lset[i]=node[now].sum;
						else node[now].Lset[i]=++node[now].sum;
					}
				}
				else node[now].Lset[i]=0;
			for(int i=0;i<n;i++) node[now].Rset[i]=node[now].Lset[i];
			return;
		}
		int mid=(L+R)>>1;
		Build(Lson,L    ,mid,t);
		Build(Rson,mid+1,R  ,t);
		PushUp(now);
	}
	void Change(int now,int L,int R,int x,bool t)
	{
		if(L==R)
		{
			node[now].sum=0;
			for(int i=0;i<n;i++)
				if(mapn[i][L]==t)
				{
					if(!i) node[now].Lset[0]=++node[now].sum;
					else
					{
						if(mapn[i-1][L]==t) node[now].Lset[i]=node[now].sum;
						else node[now].Lset[i]=++node[now].sum;
					}
				}
				else node[now].Lset[i]=0;
			for(int i=0;i<n;i++) node[now].Rset[i]=node[now].Lset[i];
			return;
		}
		int mid=(L+R)>>1;
		if(x<=mid) Change(Lson,L,mid,x,t);
		else Change(Rson,mid+1,R,x,t);
		PushUp(now);
	}
	int Ask() {return node[1].sum;}
}White,Black;

int main()
{
	scanf("%d",&n);
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
			cin>>mapn[i][j];
	White.Build(1,0,n-1,0);
	Black.Build(1,0,n-1,1);
	scanf("%d",&m);
	for(int x,y;m--;)
	{
		scanf("%d %d",&y,&x);
		--y,--x;
		mapn[y][x]^=1;
		White.Change(1,0,n-1,x,0);
		Black.Change(1,0,n-1,x,1);
		printf("%d %d\n",Black.Ask(),White.Ask());
	}
	return 0;
}
```


---

## 作者：试试事实上吗 (赞：1)

线段树分治模板题。

### Part.1

Q：如果没有修改，我们怎么做？

A：用并查集维护连通性。

直接扫一遍，我们加进来一个数，就先令答案++，看一下四个方向，如果某个方向与当前点不在同一个连通块中，那么就合并并查集，令答案--。

### Part.2

有修改？并查集不支持删除？怎么办？~~乱搞~~

这里我们可以请出我们解决这类问题的神器，**线段树分治**。（没有学过的请左转[【模板】线段树分治](https://www.luogu.com.cn/problem/P5787)）

我们知道每个位置在时间轴上有时是0，有时是1，那么对应的就是一段一段的区间，由线段树的性质，每个区间都可以拆成log个小区间，我们只用先在那些位置挂上修改操作，再跑一遍dfs，走到对应点时修改，回退时再撤销即可，走到叶节点时再输出答案即可。

总时间复杂度$O(mlog(n^2+m))$

具体实现可以看代码。

```cpp
#define Id(x,y) ((x-1)*n+y)
using namespace std;
typedef pair<int,int> pii;
const int maxn=205;
const int dx[]={1,0,-1,0};
const int dy[]={0,1,0,-1};

int mp[maxn][maxn],fa[maxn*maxn],dep[maxn*maxn],n,m,ans[2],pre[maxn][maxn],cnt;
struct Query
{
    int l,r,val,x,y;
}q[maxn*maxn*2];

stack<pii> st;
vector<int> wife[maxn*maxn*4];

template<typename T>
inline void read(T &x)
{
    char c;int f=1;
    while(!isdigit(c=getchar())) (c=='-')&&(f=-1);
    x=c^48;
    while(isdigit(c=getchar())) x=x*10+(c^48);
    x*=f;
}

void modify(int u,int l,int r,int x,int y,int id)
{
    if(x<=l&&r<=y) return void(wife[u].push_back(id));
    int mid=(l+r)>>1;
    if(x<=mid) modify(u<<1,l,mid,x,y,id);
    if(y>mid) modify(u<<1|1,mid+1,r,x,y,id);
}

inline int findf(int x)
{
    while(fa[x]!=x) x=fa[x];
    return x;
}

void merge(int u,int v)
{
    if(u==v) return;
    if(dep[u]>dep[v]) swap(u,v);
    st.push(make_pair(u,dep[u]==dep[v]));
    fa[u]=v;dep[v]+=(dep[u]==dep[v]);
}

void solve(int u,int l,int r)
{
    int siz=st.size(),ans0=ans[0],ans1=ans[1];
    for(const auto &i:wife[u])
    {
        ans[q[i].val]++;
        mp[q[i].x][q[i].y]=q[i].val;
        for(int j=0,pref=0;j<4;++j)
        {
            int tx=q[i].x+dx[j],ty=q[i].y+dy[j];
            if(tx<=0||ty<=0||tx>n||ty>n) continue;
            if(mp[q[i].x][q[i].y]==mp[tx][ty])
            {
                int x=findf(Id(q[i].x,q[i].y)),y=findf(Id(tx,ty));
                if(x==y) continue;
                --ans[q[i].val];merge(x,y);
            }
        }
    }
    if(l==r) printf("%d %d\n",ans[1],ans[0]);
    else
    {
        int mid=(l+r)>>1;
        solve(u<<1,l,mid);solve(u<<1|1,mid+1,r);
    }
    for(const auto &i:wife[u])
        mp[q[i].x][q[i].y]=-1;
    ans[0]=ans0;ans[1]=ans1;
    while(st.size()>siz)
    {
        int x=st.top().first;
        dep[fa[x]]-=st.top().second;
        fa[x]=x;st.pop();
    }
}

int main()
{
    int x,y;
    read(n);
    for(int i=1;i<=n;++i)
        for(int j=1;j<=n;++j)
            read(mp[i][j]);
    read(m);
    for(int i=1;i<=n;++i)
        for(int j=1;j<=n;++j)
            q[Id(i,j)]=(Query){1,m,mp[i][j],i,j},pre[i][j]=Id(i,j);
    for(int i=1;i<=n*n;++i) fa[i]=i;
    cnt=n*n;
    for(int i=1;i<=m;++i)
    {
        read(x);read(y);
        q[pre[x][y]].r=i-1;
        q[++cnt]=(Query){i,m,mp[x][y]^=1,x,y};
        pre[x][y]=cnt;
    }
    for(int i=1;i<=cnt;++i)
        if(q[i].l<=q[i].r) modify(1,1,m,q[i].l,q[i].r,i);
    memset(mp,-1,sizeof(mp));
    solve(1,1,m);
    return 0,qwq;
}
```



---

## 作者：LPA20020220 (赞：1)

如果还不会LCT维护图连通性的同学， 可以参考我的这篇博客:**[戳这里](https://blog.csdn.net/lpa20020220/article/details/80161103)**（这道题算是LCT维护图联通性的板题了....）

相比较，这道题显然变得毒瘤了很多。我们可以将每个格子看做一个点， 与旁边格子有四条边相连。 处理的过程中显然会遇到环的情况， 怎么处理呢？ 同样， 我们维护有关删除时间的最大生成树， 在加入边的时候判断是否为环。 如果成为环， 则与原路径中删除时间最早的边比较， 若新加入边的删除时间更晚则删除之前的那条边。

至于更新色块的个数， 我们考虑格子四个方向的连边：如果原来颜色相同则删边， 颜色不同则连边。 因为我们保证没有环且保证路径上点删除时间尽量大， 所以我们可以用LCT维护联通信息， 只需判断是否在一棵树内即可。

不过此题离线实在恶心（蒟蒻并不会强制在线的做法…听说是线段树合并？）… 想想我们需要离线什么？ 首先， 我们要预处理一开始边的连通性及初始答案； 其次， 我们要离线所有的修改操作， 分为四个方向考虑； 然后我们还要处理每条边删除的时间， 并以此为权值在LCT中连边（注意还会有多次加入的情况）……细节可以参考蒟蒻的代码（不忍直视）

```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cctype>
#include <cstdlib>
#include <algorithm>
#define R register
#define IN inline
#define W while
#define gc getchar()
#define ls tree[now].son[0]
#define rs tree[now].son[1]
#define dad tree[now].fat
#define MX 205
#define MQ 10005
#define UB 40005
template <class T>
IN void in(T &x)
{
    x = 0; R char c = gc;
    W (!isdigit(c)) c = gc;
    W (isdigit(c))
    x = (x << 1) + (x << 3) + c - 48, c = gc;
}
namespace Off_Line
{
    const short dx[5] = {0, -1, 0, 0, 1};
    const short dy[5] = {0, 0, -1, 1, 0};
    int dot, col[MX][MX], ans[2], cpy[MX][MX], cnt, q, opx[MQ], opy[MQ], out[MX * MX << 3];
    struct Event
    {
        int x, y, tim, dis, id, col;
        //tim表示当前边进行操作的时间
        //dis表示当前边删除的时间
        //id表示边的编号，col表示格子当前的颜色
        bool typ;
    }eve[MX * MX << 3];
    IN bool operator < (const Event &x, const Event &y)
    {return x.tim == y.tim ? x.typ < y.typ : x.tim < y.tim;}
    IN int get_edge_id(R int a, R int b, R int c, R int d)
    {
        if(a == c)//横向边
        {
            if(b > d) std::swap(b, d);
            return (a - 1) * (dot - 1) + b;
        }
        else//纵向边， 编号都大于横向边
        {
            if(a > c) std::swap(a, c);
            return (dot - 1) * dot + (a - 1) * dot + b;
        }
    }
    IN int get_dot_id(const int &x, const int &y) {return (x - 1) * dot + y;}//点编号
}
namespace LCT
{
    using namespace Off_Line;
    struct Node
    {
        int son[2], fat, mn, val, pos;
        bool rev, ex;
        //ex 表示是否存在（即是否已经被割）
        IN void clear()
        {
            this -> son[0] = this -> son[1] = this -> fat = this ->pos = this ->rev = this -> ex = 0;
            this ->val = this -> mn = 0x7f7f7f7f;
        }
    }tree[MX * MX << 4];
    int st[MX * MX << 3], top, lef[MX * MX << 3], rig[MX * MX << 3];
    IN bool get(const int &now) {return tree[dad].son[1] == now;}
    IN void pushrev(const int &now) {std::swap(ls, rs), tree[now].rev ^= 1;}
    IN bool nroot(const int &now) {return tree[dad].son[1] == now || tree[dad].son[0] == now;}
    IN void pushup(const int &now)
    {
        tree[now].mn = tree[now].val, tree[now].pos = now;
        if(ls) if(tree[ls].mn < tree[now].mn) tree[now].mn = tree[ls].mn, tree[now].pos = tree[ls].pos;
        if(rs) if(tree[rs].mn < tree[now].mn) tree[now].mn = tree[rs].mn, tree[now].pos = tree[rs].pos;
    }
    IN void pushdown(const int &now) 
    {
        if(tree[now].rev)
        {
            if(ls) pushrev(ls);
            if(rs) pushrev(rs);
            tree[now].rev = false;
        }
    }
    IN void rotate(const int &now)
    {
        R bool dir = get(now);
        R int fa = dad, grand = tree[fa].fat;
        tree[fa].son[dir] = tree[now].son[dir ^ 1];
        tree[tree[now].son[dir ^ 1]].fat = fa;
        if(nroot(fa)) tree[grand].son[get(fa)] = now;
        tree[now].fat = grand;
        tree[now].son[dir ^ 1] = fa;
        tree[fa].fat = now;
        pushup(fa);
    }
    IN void splay(int now)
    {
        top = 0; R int x = now, fa, grand;
        st[++top] = x;
        W (nroot(x)) x = tree[x].fat, st[++top] = x;
        W (top) pushdown(st[top--]);
        W (nroot(now))
        {
            fa = dad, grand = tree[fa].fat;
            if(nroot(fa)) rotate(get(fa) == get(now) ? fa : now);
            rotate(now);
        }
        pushup(now);
    }
    IN void access(int now)
    {
        for (R int y = 0; now; y = now, now = tree[now].fat)
        splay(now), tree[now].son[1] = y, pushup(now);
    }
    IN void make_root(const int &now)
    {
        access(now), splay(now), pushrev(now);
    }
    IN int find_root(int now)
    {
        access(now), splay(now);
        W (ls) pushdown(now), now = ls;
        return now;
    }
    IN void split(const int &x, const int &y)
    {make_root(x), access(y), splay(y);}
    IN void link(const int &x, const int &y)
    {
        make_root(x);
        if(find_root(y) != x)
        tree[x].fat = y;
    }
    IN void cut(const int &x, const int &y)
    {
        split(x, y); 
        tree[x].fat = tree[y].son[0] = 0;
        pushup(y);
    }
//----------------------以上是正常的LCT模板-------------------------
    IN void add(const int &now, const int &cl)
    {
        int x = eve[now].x, y = eve[now].y, dis = eve[now].dis, id = eve[now].id;
        if(find_root(y) == find_root(x))
        {
            split(x, y);
            if(tree[y].mn > dis) return;
            int tar = tree[y].pos;
            cut(tar, lef[tar]);
            cut(tar, rig[tar]);
            tree[tar].clear();
        }
        else ans[cl]--; int nx = id + UB;
        tree[nx].val = dis;
        tree[nx].ex = true;
        tree[nx].pos = nx;
        lef[nx] = x, rig[nx] = y;//记录两边的点是哪两个， 方便cut的时候O(1)找到
        link(nx, x), link(nx, y);
        pushup(nx);
    }
    IN void del(const int &now)
    {
        int x = eve[now].x, y = eve[now].y, id = eve[now].id;
        cut(id + UB, x), cut(id + UB, y);
        tree[id + UB].ex = false;
    }
}
using namespace Off_Line;
using namespace LCT;
int main(void)
{
    int a, b, nx, ny, nn;
    R int i, j;
    in(dot);
    memset(out, -1, sizeof(out));
    for (i = 1; i <= dot; ++i)
    for (j = 1; j <= dot; ++j)
    in(col[i][j]), cpy[i][j] = col[i][j], ans[col[i][j]]++;//cpy里面装的是复制的方格， 第一次离线操作用
    for (i = 1; i <= dot; ++i)//这一步是离线所有点两两之间的连通性
    for (j = 1; j <= dot; ++j)
    {
        a = get_dot_id(i, j), b = col[i][j];
        if(j != dot && col[i][j + 1] == col[i][j])
        eve[++cnt].x = a, eve[cnt].y = a + 1, eve[cnt].tim = 0, 
        eve[cnt].id = get_edge_id(i, j, i, j + 1), eve[cnt].typ = 1, eve[cnt].col = b;
        if(i != dot && col[i + 1][j] == col[i][j])
        eve[++cnt].x = a, eve[cnt].y = a + dot, eve[cnt].tim = 0,
        eve[cnt].id = get_edge_id(i, j, i + 1, j), eve[cnt].typ = 1, eve[cnt].col = b;
    }
    in(q);
    for (i = 1; i <= q; ++i)
    {
        in(opx[i]), in(opy[i]);
        a = get_dot_id(opx[i], opy[i]);
        for (j = 1; j <= 4; ++j)//四个方向 删边或连边操作
        {
            nx = opx[i] + dx[j], ny = opy[i] + dy[j], nn = get_dot_id(nx, ny);
            if(nx <= 0 || nx > dot || ny <= 0 || ny > dot) continue;
            if(cpy[opx[i]][opy[i]] == cpy[nx][ny])
            eve[++cnt].x = a, eve[cnt].y = nn, eve[cnt].tim = i,
            eve[cnt].id = get_edge_id(opx[i], opy[i], nx, ny), eve[cnt].typ = 0;
            else
            eve[++cnt].x = a, eve[cnt].y = nn, eve[cnt].tim = i,
            eve[cnt].id = get_edge_id(opx[i], opy[i], nx, ny), eve[cnt].typ = 1; 
        }
        cpy[opx[i]][opy[i]] ^= 1;//在复制的图上修改
    }
    std::sort(eve + 1, eve + 1 + cnt);
    for (i = 1; i <= cnt; ++i) eve[i].dis = q + 1;
    for (i = cnt; i >= 1; --i)
    {
        if(~out[eve[i].id]) eve[i].dis = out[eve[i].id];//从后往前处理边删除时间
        out[eve[i].id] = eve[i].tim;
    }
    for (i = 1; i <= UB; ++i) tree[i].val = 0x7f7f7f7f;//将所有实际存在的点的删除时间赋为正无穷（反正不能删）
    for (i = 1; i <= cnt && !eve[i].tim; ++i)
    add(i, eve[i].col);//加边操作
    for (j = 1; j <= q; ++j)
    {
        a = col[opx[j]][opy[j]];
        for (; i <= cnt && eve[i].tim <= j; ++i)
            if(!eve[i].typ)
            {
                if(!tree[eve[i].id + UB].ex) continue;
                del(i);
                ++ans[a];
            }
            else add(i, a ^ 1);
            --ans[a];//delete的时候会多计算一次， 所以要删掉
            ++ans[a ^ 1];//同上， 可以自己画图理解
            col[opx[j]][opy[j]] ^= 1;
        printf("%d %d\n", ans[1], ans[0]);
    }

}
```

---

## 作者：cike_bilibili (赞：0)

黑白网格单点反转，求动态黑色和白色连通块个数，考虑分开求解，将一个网格的生效区间在对应的时间线段树上永久化标记，最后在线段树上 dfs，叶子处处理询问即可，需要用到回滚并查集。
```cpp
#include <bits/stdc++.h>
#define ls (i<<1)
#define rs (i<<1|1)
using namespace std;
inline int read(){
	int ans=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		ans=(ans<<1)+(ans<<3)+ch-'0';
		ch=getchar();
	}
	return w*ans;
}
int n,m;
int u[10005],v[10005];
int t[505][505];
int ch[505][505];
int now[505][505];
inline int get(int x,int y){
	return (x-1)*n+y;
}
struct Stack{
	int u,v;
}stk[200005];
int top;
struct dsu{
	int fa[40005],sz[40005];
	inline void init(){
		for(int i=1;i<=n*n;i++)fa[i]=i,sz[i]=1;
	}
	inline int find(int x){
		while(fa[x]!=x)x=fa[x];
		return x;
	}
	inline void Union(int x,int y,int &ans){
		int rt_x=find(x),rt_y=find(y);
		if(rt_x==rt_y)return;
		if(sz[rt_x]<sz[rt_y])swap(rt_x,rt_y);
		stk[++top]={rt_x,rt_y};
		fa[rt_y]=rt_x;
		sz[rt_x]+=sz[rt_y];
		--ans;
	}
	inline void back(int now){
		fa[stk[now].v]=stk[now].v;
		sz[stk[now].u]-=sz[stk[now].v];
	}
}d;
int sum[10005][2];
struct tree{
	int l,r;
	vector<pair<int,int> >ed;
}tree[200005];
void build(int i,int l,int r){
	tree[i].l=l,tree[i].r=r;
	tree[i].ed.clear();
	if(l==r)return;
	int mid=l+r>>1;
	build(ls,l,mid),build(rs,mid+1,r);
}
void add(int i,int l,int r,int x,int y){
	if(tree[i].l>r||tree[i].r<l)return;
	if(tree[i].l>=l&&tree[i].r<=r){
		tree[i].ed.push_back({x,y});
		return;
	}
	add(ls,l,r,x,y),add(rs,l,r,x,y);
}
void dfs(int i,int ans,int opt){
	int nowtop=top;
	for(pair<int,int> j:tree[i].ed){
		int u=j.first,v=j.second;
		now[u][v]=1;
		++ans;
		if(now[u-1][v])d.Union(get(u-1,v),get(u,v),ans);
		if(now[u+1][v])d.Union(get(u+1,v),get(u,v),ans);
		if(now[u][v-1])d.Union(get(u,v-1),get(u,v),ans);
		if(now[u][v+1])d.Union(get(u,v+1),get(u,v),ans);
	}
	if(tree[i].l==tree[i].r){
		sum[tree[i].l][opt]=ans;
	}else{
		dfs(ls,ans,opt),dfs(rs,ans,opt);
	}
	for(pair<int,int> j:tree[i].ed){
		int u=j.first,v=j.second;
		now[u][v]=0;
	}
	while(top!=nowtop)d.back(top--);
}
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)ch[i][j]=read();
	}
	m=read();
	for(int i=1;i<=m;i++)u[i]=read(),v[i]=read();
	build(1,1,m);
	//black
	d.init();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(ch[i][j]==1)t[i][j]=1;
		}
	}
	for(int i=1;i<=m;i++){
		int x=u[i],y=v[i];
		if(t[x][y]){
			add(1,t[x][y],i-1,x,y);
			t[x][y]=0;
		}else{
			t[x][y]=i;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(t[i][j])add(1,t[i][j],m,i,j),t[i][j]=0;
		}
	}
	dfs(1,0,0);

	//white
	build(1,1,m);
	d.init();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(ch[i][j]==0)t[i][j]=1;
		}
	}
	for(int i=1;i<=m;i++){
		int x=u[i],y=v[i];
		if(t[x][y]){
			add(1,t[x][y],i-1,x,y);
			t[x][y]=0;
		}else{
			t[x][y]=i;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(t[i][j])add(1,t[i][j],m,i,j),t[i][j]=0;
		}
	}
	dfs(1,0,1);
	for(int i=1;i<=m;i++){
		cout<<sum[i][0]<<' '<<sum[i][1]<<'\n';
	}
} 
```

---

## 作者：SrsgPrince_ (赞：0)

# Luogu P4121 [WC2005] 双面棋盘 Solution

题面传送门：[P4121 [WC2005] 双面棋盘](https://www.luogu.com.cn/problem/P4121)。

建议在我的 [博客](https://www.luogu.com.cn/blog/fy123333/LuoguP4121Solution) 中查看。

## 题目分析 Hint

题目：

有一个 $n \times n$ 的一个棋盘，初始给定上面的黑与白，每次操作将 $(x,y)$ 的格子颜色翻转，对于操作后的状态，计算黑白连通块个数。$1 \leq n \leq 200, 1 \leq m \leq 1 \times 10^4$。

这个题目要动态维护连通性，每次操作都有单点修改和全局查。

## 思路 Solution

看到动态维护图连通，容易想到 Link-Cut Tree，如果不会的话可以做做 [BZOJ4025](https://www.lydsy.com/JudgeOnline/problem.php?id=4025)，题目是给一张图以及每条边的出现时间和消失时间，让你求每个时间段这张图是否是二分图。

对于每两个相邻的格子，我们都连上边，再根据每条边加入和删除的时候离线下来，然后 LCT 维护就行了。先说说修改，我们拆成四种，对于这个格子附近的 $4$ 个相邻的格子，相同颜色 $\operatorname{cut()}$，不同颜色 $\operatorname{link()}$，然后每次修改完之后把颜色翻过来，再加一个查询。维护肯定不能暴力判断，即使这题的数据范围小，考虑在每次进行一次修改的时候维护，在 $\operatorname{link()}$ 的时候，如果连边的两个节点在不同的块里，那么合并后连通块个数要 $-1$，在 $\operatorname{cut()}$ 的时候，如果这条边的两个节点仅靠这一条边连通，那么在断边的时候会使得连通块数量 $+1$，在操作完之后，要再减掉一个原先颜色的连通块个数，然后再加上翻转过后颜色的连通块个数。

【代码】：

```cpp
#include<bits/stdc++.h>
constexpr int maxn=210,maxt=maxn*maxn<<4,maxr=maxn*maxn<<3;
constexpr int maxq=1e4+10,maxb=maxq<<2,inf=__INT_MAX__;
constexpr int dx[]={0,-1,0,0,1},dy[]={0,0,-1,1,0};
int n,q,a,b,nx,ny,totn,cnt,col[maxn][maxn],cpy[maxn][maxn];
int opt1[maxq],opt2[maxq],res[2],ans[maxr];
// 快读快写板子
struct Query{
    int x,y,tme,dist,idx,col;
    bool opt; // 这里 opt 是 false 的就是同色的 cut 操作，true 即不同色的 link 操作
    inline friend bool operator<(register const Query&lhs,register const Query&rhs)_GLIBCXX_NOEXCEPT{
        return lhs.tme==rhs.tme?lhs.opt<rhs.opt:lhs.tme<rhs.tme;
    }
}qry[maxr];
inline int getEdge(register int b,register int e,register int u,register int v);
inline int getVertex(register int x,register int y);
namespace LinkCutTree{
    int chd[2][maxt],fa[maxt],mn[maxt],val[maxt],pos[maxt];
    int top,stk[maxr],blft[maxr],brgt[maxr];
    bool rev[maxt],exs[maxt];
    inline void clear(register int x){
        chd[0][x]=chd[1][x]=0;
        fa[x]=0;
        pos[x]=0;
        val[x]=mn[x]=inf;
        rev[x]=exs[x]=false;
    }
    inline bool nRoot(register int x){
        return chd[0][fa[x]]==x||chd[1][fa[x]]==x;
    }
    inline bool check(register int x){
        return chd[1][fa[x]]==x;
    }
    inline void reverse(register int x){
        std::swap(chd[0][x],chd[1][x]);
        rev[x]^=1;
    }
    inline void pushUp(register int x){
        mn[x]=val[x];
        pos[x]=x;
        if(chd[0][x])
            if(mn[chd[0][x]]<mn[x]){
                mn[x]=mn[chd[0][x]];
                pos[x]=pos[chd[0][x]];
            }
        if(chd[1][x])
            if(mn[chd[1][x]]<mn[x]){
                mn[x]=mn[chd[1][x]];
                pos[x]=pos[chd[1][x]];
            }
    }
    inline void pushDown(register int x){
        if(rev[x]){
            if(chd[0][x])
                reverse(chd[0][x]);
            if(chd[1][x])
                reverse(chd[1][x]);
            rev[x]=false;
        }
    }
    inline void rotate(register int x){
        register int y=fa[x],z=fa[y];
        register bool k=check(x);
        chd[k][y]=chd[!k][x];
        fa[chd[!k][x]]=y;
        if(nRoot(y))
            chd[check(y)][z]=x;
        fa[x]=z;
        chd[!k][x]=y;
        fa[y]=x;
        pushUp(y);
    }
    inline void pushTag(register int x){
        top=0;
        stk[++top]=x;
        while(nRoot(x)){
            x=fa[x];
            stk[++top]=x;
        }
        while(top)
            pushDown(stk[top--]);
    }
    inline void splay(register int x){
        register int y,z;
        pushTag(x);
        while(nRoot(x)){
            y=fa[x];
            z=fa[y];
            if(nRoot(y))
                rotate((check(x)==check(y))?y:x);
            rotate(x);
        }
        pushUp(x);
    }
    inline void access(register int x){
        for(register int y=0;x;x=fa[y=x]){
            splay(x);
            chd[1][x]=y;
            pushUp(x);
        }
    }
    inline void makeRoot(register int x){
        access(x);
        splay(x);
        reverse(x);
    }
    inline int findRoot(register int x){
        access(x);
        splay(x);
        while(chd[0][x]){
            pushDown(x);
            x=chd[0][x];
        }
        return x;
    }
    inline void split(register int x,register int y){
        makeRoot(x);
        access(y);
        splay(y);
    }
    inline void link(register int x,register int y){
        makeRoot(x);
        if(findRoot(y)!=x)
            fa[x]=y;
    }
    inline void cut(register int x,register int y){
        split(x,y);
        fa[x]=chd[0][y]=0;
        pushUp(y);
    }
    inline void updateVertex(register int p,register int clr){
        register int x=qry[p].x,y=qry[p].y,dist=qry[p].dist,idx=qry[p].idx;
        if(findRoot(y)==findRoot(x)){
            split(x,y);
            if(mn[y]>dist)
                return void();
            register int tmp=pos[y];
            cut(tmp,blft[tmp]);
            cut(tmp,brgt[tmp]);
            clear(tmp);
        }
        else
            res[clr]--;
        register int nx=idx+maxb;
        val[nx]=dist;
        exs[nx]=true;
        pos[nx]=nx;
        blft[nx]=x;
        brgt[nx]=y;
        link(nx,x);
        link(nx,y);
        pushUp(nx);
    }
    inline void deleteVertex(register int p){
        register int x=qry[p].x,y=qry[p].y,idx=qry[p].idx;
        cut(idx+maxb,x);
        cut(idx+maxb,y);
        exs[idx+maxb]=false;
    }
}
inline int getEdge(register int b,register int e,register int u,register int v){
    if(b==u){
        if(e>v)
            std::swap(e,v);
        return (b-1)*(n-1)+e;
    }
    else{
        if(b>u)
            std::swap(b,u);
        return (n-1)*n+(b-1)*n+e;
    }
}
inline int getVertex(register int x,register int y){
    return (x-1)*n+y;
}
signed main(){
    register int i,j;
    quickRead<int>(n);
    std::memset(ans,-1,sizeof(ans));
    for(i=1;i<=n;++i)
        for(j=1;j<=n;++j){
            quickRead<int>(col[i][j]);
            cpy[i][j]=col[i][j];
            res[col[i][j]]++;
        }
    for(i=1;i<=n;++i)
        for(j=1;j<=n;++j){
            a=getVertex(i,j);
            b=col[i][j];
            if(j!=n&&col[i][j+1]==col[i][j]){
                qry[++cnt].x=a;
                qry[cnt].y=a+1;
                qry[cnt].tme=0;
                qry[cnt].idx=getEdge(i,j,i,j+1);
                qry[cnt].opt=1;
                qry[cnt].col=b;
            }
            if(i!=n&&col[i+1][j]==col[i][j]){
                qry[++cnt].x=a;
                qry[cnt].y=a+n;
                qry[cnt].tme=0;
                qry[cnt].idx=getEdge(i,j,i+1,j);
                qry[cnt].opt=1;
                qry[cnt].col=b;
            }
        }
    quickRead<int>(q);
    for(i=1;i<=q;++i){
        quickRead<int,int>(opt1[i],opt2[i]);
        a=getVertex(opt1[i],opt2[i]);
        for(j=1;j<=4;++j){
            nx=opt1[i]+dx[j];
            ny=opt2[i]+dy[j];
            totn=getVertex(nx,ny);
            if(nx<=0||nx>n||ny<=0||ny>n)
                continue;
            if(cpy[opt1[i]][opt2[i]]==cpy[nx][ny]){
                qry[++cnt].x=a;
                qry[cnt].y=totn;
                qry[cnt].tme=i;
                qry[cnt].idx=getEdge(opt1[i],opt2[i],nx,ny);
                qry[cnt].opt=0;
            }
            else{
                qry[++cnt].x=a;
                qry[cnt].y=totn;
                qry[cnt].tme=i;
                qry[cnt].idx=getEdge(opt1[i],opt2[i],nx,ny);
                qry[cnt].opt=1;
            }
        }
        cpy[opt1[i]][opt2[i]]^=1;
    }
    std::sort(qry+1,qry+cnt+1);
    for(i=1;i<=cnt;++i)
        qry[i].dist=q+1;
    for(i=cnt;i>=1;--i){
        if(~ans[qry[i].idx])
            qry[i].dist=ans[qry[i].idx];
        ans[qry[i].idx]=qry[i].tme;
    }
    for(i=1;i<=maxb;++i)
        LinkCutTree::val[i]=inf;
    for(i=1;i<=cnt&&!qry[i].tme;++i)
        LinkCutTree::updateVertex(i,qry[i].col);
    for(j=1;j<=q;++j){
        a=col[opt1[j]][opt2[j]];
        for(;i<=cnt&&qry[i].tme<=j;++i)
            if(!qry[i].opt){
                if(!LinkCutTree::exs[qry[i].idx+maxb])
                    continue;
                LinkCutTree::deleteVertex(i);
                ++res[a];
            }
            else
                LinkCutTree::updateVertex(i,!a);
        --res[a];
        ++res[!a];
        col[opt1[j]][opt2[j]]^=1;
        quickWrite<int,char,int,char>(res[1],' ',res[0],'\n');
    }
    return 0;
}
```

复杂度是 $O(nm \log n)$，有 LCT 的常数。此外还有一个做法是线段树分治+可撤销并查集，不优化是 $\log^2n$ 的，代码比 LCT 短多了，而且很有可能能跑过 LCT。


---

## 作者：Genius_Z (赞：0)

**[BLOG](https://www.luogu.org/blog/zi-o/#)**

动态维护图的连通性，这东西本身不难，离线做法主要有两种。一个是$LCT$维护以删除时间为权值的最大生成树，另一个是线段树分治加按秩合并并查集（后者的码量和常数都巨小，然鹅复杂度是$log^2$的），不会的可以看一下[这题](https://www.luogu.org/problemnew/show/P5227)。

我们考虑把每次修改拆成4个操作，上下左右，同色的$cut$，异色的$link$，代码中用$op$为0和为1来表示，然后每次修改完了加入一个查询操作，并把当前点的颜色改变，异色的要同时在$map$和存边的数组里同时加上这条边，同色的要在$map$里删掉这条边。

考虑这题最主要的地方就是处理连通块的个数，我把答案一开始设置为初始每种颜色的个数，每次成功的$link$操作（改变连通性）和成功的$cut$操作就对答案进行更改，$link$答案减一，$cut$答案加一，但是这样是错误的，因为没有考虑到每次换颜色会改变初始颜色数，所以在输出答案的时候再相应的加一减一就可以了。

CODE:

```cpp
#include <set>
#include <map>
#include <cmath>
#include <queue>
#include <stack>
#include <bitset>
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <algorithm>
#include <unordered_map>
#define inl inline
#define re register int
#define fa(x) t[x].fa
#define ls(x) t[x].child[0]
#define rs(x) t[x].child[1]
#define ll long long
const int inf = 0x3f3f3f3f;
#define lowbit(x) ((x) & (-x))
using namespace std;
#ifndef _DEBUG
#define getchar() (*(IOB.in.p++))
#define putchar(c) (*(IOB.out.p++)=(c))
#define io_eof() (IOB.in.p>=IOB.in.pend)
struct IOBUF { struct { char buff[1 << 26], *p, *pend; }in; struct { char buff[1 << 26], *p; }out; IOBUF() { in.p = in.buff; out.p = out.buff; in.pend = in.buff + fread(in.buff, 1, 1 << 26, stdin); }~IOBUF() { fwrite(out.buff, 1, out.p - out.buff, stdout); } }IOB;
#endif
template<typename IO>
inl void write(IO x) {
	if (x == 0) return (void)putchar('0');
	if (x < 0)putchar('-'), x = -x;
	static char buf[30];
	char* p = buf;
	while (x) {
		*(p++) = x % 10 + '0';
		x /= 10;
	}
	while (p > buf)putchar(*(--p));
}
inl void writestr(const char *s) { while (*s != 0)putchar(*(s++)); }
template<typename IO>inl void writeln(IO x) { write(x), putchar('\n'); }
template<typename IO>inl void writesp(IO x) { write(x), putchar(' '); }
inl int readstr(char *s) {
	char *begin = s, c = getchar();
	while (c < 33 || c>127) {
		c = getchar();
	}
	while (c >= 33 && c <= 127) {
		*(s++) = c;
		c = getchar();
	}
	*s = 0;
	return s - begin;
}
template<typename IO>
inl IO read() {
	IO x = 0;
	register bool w = 0;
	register char c = getchar();
	while (c > '9' || c < '0') {
		if (c == '-') w = 1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + (c ^ 48);
		c = getchar();
	}
	return w ? -x : x;
}
#define id(x,y) (((x)-1)*n+(y))
int ans[2], n, m, all, dx[] = { 0,1,0,-1 }, dy[] = { 1,0,-1,0 }, tot, num;
bool col[201][201], vis[201][201];
struct edge {
	int u, v, w;
	short col;
}e[1000001];
struct quiz {
	bool flag, op, col;
	int id, tim;
}q[1000001];
map<pair<int, int>, int>mp;
inl void dfs(int x, int y) {
	vis[x][y] = 1;
	re u, v, nx, ny;
	map<pair<int, int>, int>::iterator it;
	for (re i = 0; i < 4; i++) {
		nx = x + dx[i], ny = y + dy[i];
		if (col[nx][ny] == col[x][y] && nx > 0 && ny > 0 && nx <= n && ny <= n) {
			u = id(x, y), v = id(nx, ny);
			if (u > v)swap(u, v);
			if ((it = mp.find(make_pair(u, v))) == mp.end()) {
				e[++tot] = edge{ u,v,0,col[x][y] };
				q[++num] = quiz{ 0,1,(bool)e[tot].col,tot,0 };
				mp[make_pair(u, v)] = tot;
			}
			if (!vis[nx][ny])dfs(nx, ny);
		}
	}
}
class lct_base {
public:
	struct node {
		int fa, child[2], w, min;
		bool filp;
	}t[1000001];
	inl void maintain(int x) {
		t[x].min = 0;
		if (x > all)t[x].min = x;
		if (t[t[ls(x)].min].w < t[x].w)t[x].min = t[ls(x)].min;
		if (t[t[rs(x)].min].w < t[t[x].min].w)t[x].min = t[rs(x)].min;
	}
	inl bool poi(int x) { return rs(fa(x)) == x; }
	inl bool nroot(int x) { return ls(fa(x)) == x || rs(fa(x)) == x; }
	inl void rotate(int x) {
		re f = fa(x), gf = fa(f), fs = poi(x), gfs = poi(f), s = t[x].child[fs ^ 1];
		if (nroot(f))t[gf].child[gfs] = x;
		t[f].child[fs] = s, t[x].child[fs ^ 1] = f;
		if (s)fa(s) = f;
		fa(x) = gf, fa(f) = x, maintain(f);
	}
	inl void reverse(int x) { swap(ls(x), rs(x)), t[x].filp ^= 1; }
	inl void pushdown(int x) {
		if (t[x].filp) {
			if (ls(x))reverse(ls(x));
			if (rs(x))reverse(rs(x));
			t[x].filp ^= 1;
		}
	}
	inl void push(int x) { if (nroot(x))push(fa(x)); pushdown(x); }
	inl void splay(int x) {
		push(x);
		while (nroot(x)) {
			if (nroot(fa(x)))poi(fa(x)) == poi(x) ? rotate(fa(x)) : rotate(x);
			rotate(x);
		}
		maintain(x);
	}
	inl void access(int x) {
		for (re i = 0; x; x = fa(i = x)) {
			splay(x), rs(x) = i, maintain(x);
		}
	}
	inl void makeroot(int x) { access(x), splay(x), reverse(x); }
	inl void split(int x, int y) { makeroot(y), access(x), splay(x); }
	inl int findroot(int x) { access(x), splay(x), pushdown(x); while (ls(x))pushdown(x = ls(x)); splay(x); return x; }
	inl void link(int x, int y) { split(x, y), fa(y) = x; }
	inl void cut(int x, int y) { split(x, y), fa(y) = ls(x) = 0, maintain(x); }
}lct[2];
signed main() {
	n = read<int>(), all = n * n;
	for (re i = 1; i <= n; i++) {
		for (re j = 1; j <= n; j++) {
			col[i][j] = read<int>(), ans[col[i][j]]++;
		}
	}
	for (re i = 1; i <= n; i++) {
		for (re j = 1; j <= n; j++) {
			if (!vis[i][j])dfs(i, j);
		}
	}
	for (re i = 0; i <= all; i++)lct[0].t[i].w = lct[1].t[i].w = inf;
	m = read<int>();
	for (re i = 1; i <= m; i++) {
		re x = read<int>(), y = read<int>(), k = id(x, y), now;
		register map<pair<int, int>, int>::iterator it;
		if (x > 1) {
			if ((it = mp.find(make_pair(id(x - 1, y), k))) != mp.end()) {
				now = it->second;
				e[now].w = i, lct[e[now].col].t[now + all].w = i;
				q[++num] = quiz{ 0,0,col[x][y],now,i };
				mp.erase(it);
			}
			else {
				e[++tot] = edge{ id(x - 1, y), k,0,col[x][y] ^ 1 };
				mp[make_pair(id(x - 1, y), k)] = tot;
				q[++num] = quiz{ 0,1,!col[x][y],tot,i };
			}
		}
		if (y > 1) {
			if ((it = mp.find(make_pair(id(x, y - 1), k))) != mp.end()) {
				now = it->second;
				e[now].w = i, lct[e[now].col].t[now + all].w = i;
				q[++num] = quiz{ 0,0,col[x][y],now,i };
				mp.erase(it);
			}
			else {
				e[++tot] = edge{ id(x,y - 1),k,0,col[x][y] ^ 1 };
				mp[make_pair(id(x, y - 1), k)] = tot;
				q[++num] = quiz{ 0,1,!col[x][y],tot,i };
			}
		}
		if (x < n) {
			if ((it = mp.find(make_pair(k, id(x + 1, y)))) != mp.end()) {
				now = it->second;
				e[now].w = i, lct[e[now].col].t[now + all].w = i;
				q[++num] = quiz{ 0,0,col[x][y],now,i };
				mp.erase(it);
			}
			else {
				e[++tot] = edge{ k,id(x + 1, y), 0,col[x][y] ^ 1 };
				mp[make_pair(k, id(x + 1, y))] = tot;
				q[++num] = quiz{ 0,1,!col[x][y],tot,i };
			}
		}
		if (y < n) {
			if ((it = mp.find(make_pair(k, id(x, y + 1)))) != mp.end()) {
				now = it->second;
				e[now].w = i, lct[e[now].col].t[now + all].w = i;
				q[++num] = quiz{ 0,0,col[x][y],now,i };
				mp.erase(it);
			}
			else {
				e[++tot] = edge{ k,id(x, y + 1), 0,col[x][y] ^ 1 };
				mp[make_pair(k, id(x, y + 1))] = tot;
				q[++num] = quiz{ 0,1,!col[x][y],tot,i };
			}
		}
		col[x][y] ^= 1;
		q[++num].flag = 1, q[num].col = col[x][y];
	}
	for (re i = 1; i <= tot; i++) {
		if (!e[i].w)e[i].w = m + 1, lct[e[i].col].t[i + all].w = m + 1;
	}
	for (re i = 1; i <= num; i++) {
		if (q[i].flag) {
			ans[q[i].col]++, ans[q[i].col ^ 1]--;
			writesp(ans[1]), writeln(ans[0]);
		}
		else {
			re c = q[i].col, j = q[i].id, u = e[j].u, v = e[j].v, w = e[j].w;
			lct[c].makeroot(u);
			if (q[i].op) {
				if (lct[c].findroot(v) == u) {
					lct[c].maintain(u);
					re minn = lct[c].t[u].min, d = lct[c].t[minn].w;
					if (d >= w)continue;
					lct[c].cut(e[minn - all].u, minn), lct[c].cut(e[minn - all].v, minn);
					lct[c].link(u, j + all), lct[c].link(v, j + all);
				}
				else {
					lct[c].link(u, j + all), lct[c].link(v, j + all), ans[c]--;
				}
			}
			else {
				if (lct[c].findroot(v) == u) {
					re minn = lct[c].t[u].min, d = lct[c].t[minn].w;
					if (d > q[i].tim)continue;
					lct[c].cut(e[minn - all].u, minn), lct[c].cut(e[minn - all].v, minn), ans[c]++;
				}
			}
		}
	}
}
```



---

## 作者：NBest (赞：0)

## 简化题意：
给你一个 $n\times n$ 的只有黑白两种颜色的棋盘，每次修改把某格的黑白互换，求每次修改后黑白各自的连通块个数。

## 解法
将棋盘转化成 $n$ 行，每行单独处理，处理出黑色和白色分别的连通块个数(可用并查集)。

开一个 $n$ 的线段树，每个叶子节点表示一行。

合并过程中，先将黑白的连通块数量相加作为合并后的连通块数量，再用并查集将颜色相同但是非同一个指向的并查集合并并减去一个连通块个数。

每次修改都重新修改对应行的并查集数组。

修改行和合并行复杂度都是 $O(n\log n)$。

单次修改复杂度 $O(n\log^2n)$。

总复杂度 $O(nm\log ^2 n)$，$n\leq 200$，$m \leq 10000$，可过。

## Code
```cpp
int n,m;
int fa[40004];
inline int gl(int x,int y){
    return n*(x-1)+y;
}
inline int find(int x){
    if(x==fa[x])return x;
    return fa[x]=find(fa[x]);
}
struct line{
    int up[205],down[205],bl,wh,hup,hdown;//h 针对单行位置
    int ls[205],rs[205];
    void recreate(){ //单行暴力修改
        bl=wh=0;
        for(int i=1;i<=n;i++){
            ls[i]=rs[i]=fa[gl(hup,i)]=gl(hup,i);
            bl+=up[i];
            wh+=up[i]^1;
        }
        for(int i=2;i<=n;i++){
            if(up[i]==up[i-1]){
                ls[i]=rs[i]=fa[find(gl(hup,i))]=find(gl(hup,i-1));
                bl-=up[i];
                wh-=up[i]^1;
            }
        }
    }
}tr[806];
inline void pushup(int root){
    tr[root].bl=tr[root<<1].bl+tr[root<<1|1].bl;
    tr[root].wh=tr[root<<1].wh+tr[root<<1|1].wh;
    for(int i=1;i<=n;i++){
        tr[root].ls[i]=tr[root<<1].ls[i];
        tr[root].rs[i]=tr[root<<1|1].rs[i];
        fa[tr[root<<1].ls[i]]=tr[root<<1].ls[i];
        fa[tr[root<<1].rs[i]]=tr[root<<1].rs[i];
        fa[tr[root<<1|1].ls[i]]=tr[root<<1|1].ls[i];
        fa[tr[root<<1|1].rs[i]]=tr[root<<1|1].rs[i];
        tr[root].up[i]=tr[root<<1].up[i];
        tr[root].down[i]=tr[root<<1|1].down[i];
    }
    tr[root].hup=tr[root<<1].hup;
    tr[root].hdown=tr[root<<1|1].hdown;
    for(int i=1;i<=n;i++){
        int upfa=find(tr[root<<1].rs[i]),downfa=find(tr[root<<1|1].ls[i]);
        if(tr[root<<1].down[i]==tr[root<<1|1].up[i]&&upfa!=downfa){
            fa[upfa]=downfa;
            tr[root].bl-=tr[root<<1].down[i];
            tr[root].wh-=tr[root<<1].down[i]^1;
        }
    }
    for(int i=1;i<=n;i++){
        tr[root].ls[i]=find(tr[root].ls[i]),tr[root].rs[i]=find(tr[root].rs[i]);
    }
}
void build(int root,int l,int r){
    if(l==r){
        for(int i=1;i<=n;i++){
            tr[root].up[i]=tr[root].down[i]=read();
        }
        tr[root].hup=tr[root].hdown=l;
        tr[root].recreate();
        //printf("line %d: bl:%d wh:%d\n",l,tr[root].bl,tr[root].wh);
        return;
    }
    build(root<<1,l,mid),build(root<<1|1,mid+1,r);
    pushup(root);
    //printf("line %d-%d: bl:%d wh:%d\n",l,r,tr[root].bl,tr[root].wh);
}
void update(int root,int l,int r,int x,int y){
    if(l==r){
        tr[root].up[y]^=1;
        tr[root].down[y]^=1;
        tr[root].recreate();
        //printf("line %d: bl:%d wh:%d\n",l,tr[root].bl,tr[root].wh);
        return;
    }
    if(mid>=x)update(root<<1,l,mid,x,y);
    else update(root<<1|1,mid+1,r,x,y);
    pushup(root);
    //printf("line %d-%d: bl:%d wh:%d\n",l,r,tr[root].bl,tr[root].wh);
}
int main(){
    n=read();
    build(1,1,n);
    m=read();
    while(m--){
        int x=read(),y=read();
        update(1,1,n,x,y);
        printf("%d %d\n",tr[1].bl,tr[1].wh);
    }
}
```

---


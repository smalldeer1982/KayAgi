# [WC2006] 水管局长

## 题目背景

SC 省 MY 市有着庞大的地下水管网络，嘟嘟是 MY 市的水管局长（就是管水管的啦）。

## 题目描述

每天供水公司可能要将一定量的水从 $u$ 处送往 $v$ 处，嘟嘟需要为供水公司找到一条从 $u$ 至 $v$ 的水管的路径，接着通过信息化的控制中心通知路径上的水管进入准备送水状态，等到路径上每一条水管都准备好了，供水公司就可以开始送水了。嘟嘟一次只能处理一项送水任务，等到当前的送水任务完成了，才能处理下一项。

在处理每项送水任务之前，路径上的水管都要进行一系列的准备操作，如清洗、消毒等等。嘟嘟在控制中心一声令下，这些水管的准备操作同时开始，但由于各条管道的长度、内径不同，进行准备操作需要的时间可能不同。

供水公司总是希望嘟嘟能找到这样一条送水路径，路径上的所有管道全都准备就绪所需要的时间尽量短。嘟嘟希望你能帮助他完成这样的一个选择路径的系统，以满足供水公司的要求。另外，由于 MY 市的水管年代久远，一些水管会不时出现故障导致不能使用，你的程序必须考虑到这一点。

不妨将 MY 市的水管网络看作一幅简单无向图（即没有自环或重边）：水管是图中的边，水管的连接处为图中的结点。整张图共有 $n$ 个节点和 $m$ 条边，节点从 $1$ 至 $n$ 编号。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证：

- $1 \leq n \leq 10^3$，$1 \leq m, q \leq 10^5$。
- $1 \leq k \leq 2$，$1 \leq u, v \leq n$，$1 \leq t \leq 10^9$。
- 给出的图无重边无自环，保证在宣布一条水管报废之前，该水管一定存在于图上且没有报废，
- 宣布报废的水管不超过 $5 \times 10^3$ 条，且在任意时刻，图一定是联通的。




## 样例 #1

### 输入

```
4 4 3
1 2 2
2 3 3
3 4 2
1 4 2
1 1 4
2 1 4
1 1 4
```

### 输出

```
2
3```

# 题解

## 作者：fy0123 (赞：138)

人生第一道深蓝题~~当然要写一下题解辣！



## 题意：

给一个n个点m条边的图，支持以下操作：

1. 询问x到y所有路径中，路径上最大边权的最小值
2. 删去一条边



## 做法：

link-cut-tree通常用来解决树上一些动态加边、删边的问题。

如果不会lct可以先自己去学习一下，打几道模板~~（bzoj上全是~~。这里讲一下大致内容。（不过建议还是自己去好好理解消化一下，本人初学lct的时候也是理解了好久的qwq



> 称一个点被访问过, 如果刚刚执行了对这个点的 ACCESS 操作.


> 如果结点 v 的子树中, 最后被访问的结点在子树 w 中, 这里 w 是 v 的儿子, 那么就称 w 是 v 的 Preferred Child. 如果最后被访问过的结点就是 v 本身, 那么它没有 Preferred Child. 每个点到它的 Preferred Child 的边称作 Preferred Edge. 由 Preferred Edge 连接成的不可再延伸的路径称为 Preferred Path.


> 这样, 整棵树就被划分成了若干条 Preferred Path. 对每条 Preferred Path, 用这条路上的点的深度作为关键字, 用一棵平衡树来维护它(在这棵平衡树中, 每个点的左子树中的点, 都在 Preferred Path 中这个点的上方; 右子树中的点, 都在 Preferred Path 中这个点的下方). 需要注意的是, 这种平衡树必须支持分离与合并. 这里, 我们选择 Splay Tree 作为这个平衡树的数据结构. 我们把这棵平衡树称为一棵 Auxiliary Tree.


> 知道了树 T 分解成的这若干条 Preferred Path, 我们只需要再知道这些路径之间的连接关系, 就可以表示出这棵树 T . 用 Path Parent 来记录每棵 Auxiliary Tree 对应的 Preferred Path 中的最高点的父亲结点,如果这个 Preferred Path 的最高点就是根结点, 那么令这棵 Auxiliary Tree 的 Path Parent 为 null.


> Link-Cut Trees 就是将要维护的森林中的每棵树 T 表示为若干个 Auxiliary Tree, 并通过 Path Parent 将这些 Auxiliary Tree 连接起来的数据结构. 

lct的主要操作基于ACCESS操作，来看一下ACCESS操作的流程：

> ACCESS 操作是 Link-Cut Trees 的所有操作的基础. 假设调用了过程 ACCESS(v), 那么从点 v 到根结点的路径就成为一条新的 Preferred Path. 如果路径上经过的某个结点 u 并不是它的父亲 parent(u) 的 Preferred Child, 那么由于 parent(u) 的 Preferred Child 会变为 u , 原本包含 parent(u) 的 Preferred Path 将不再包含结点 parent(u) 及其之上的部分. 


> 首先, 由于访问了点 v, 那么它的 Preferred Child 应当消失. 先将点 v 旋转到它所属的 Auxiliary Tree 的根, 如果 v 在 v 所属的 Auxiliary Tree 中有右儿子(也就是 v 原来的 Preferred Child), 那么应该将 v 在 v 所属的 Auxiliary Tree 中的右子树(对应着它的原来的 Preferred Child 之下的 Preferred Path)从 v 所属的 Auxiliary Tree 中分离, 并设置这个新的 Auxiliary Tree 的 Path Parent 为 v.然后, 如果点 v 所属的 Preferred Path 并不包含根结点, 设它的 Path Parent 为 u, 那么需要将 u 旋转到 u 所属的 Auxiliary Tree 的根, 并用点 v 所属的 Auxiliary Tree 替换到点 u 所属的 Auxiliary Tree 中点 u 的右子树, 再将原来点 u 所属的 Auxiliary Tree 中点 u 的右子树的 Path Parent 设置为 u. 如此操作,直到到达包含根结点的 Preferred Path. 

——以上所有引用部分来源于`yang zhe`的《QTREE 解法的一些研究》论文。



于是各种连边、删边、换根操作就可以执行了，具体见代码。



------



然后我们来考虑这道题。



我们发现删边特别难处理，那么怎样转化一下呢？倒着处理所有询问，于是删边变成了加边。然后查询所有路径上最大值的最小值，不难发现就是要维护这个图的最小生成树，然后就可以直接查询树路径上的最大值了，也可以用lct做到。那么问题转化为了**动态维护最小生成树**。

我们此时已经将询问倒过来处理了，那么假设我们已经维护好了一棵mst，每加一条边u-v，肯定会形成一个**环**。因为是最小生成树，所以我们肯定要在环上去掉一条最大的边。于是处理加边操作流程如下：

> 1. 查询u-v链上最大边权mx
> 2. 比较新加的边权w和mx的大小关系，如果 $w>mx$ ，则不做任何操作；否则删去边权为mx的边(cut)，加上u-v这条边(link)。

那么查询就直接查链上最大值即可。



------



至此，此题大致流程已经结束。

不过还有一些小问题：

1. 在保存mx的时候需要存的是边的编号，因为到时加边的时候需要用到。
2. 你发现lct似乎只能处理链上最大点权而无法保存边权。怎么办呢？我们可以考虑 **把边看成点** ，加一条边u-v，编号为id，则 `link(u, id); link(v, id);` ；删边同理。
3. 在处理询问的时候需要找到某条边的编号，可以开一个map记录边的编号。



## 代码：

好辣好辣泥萌是不是已经急着想看代码辣qwqwq

那接下来就是看~~膜~~代码时间~

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<iostream>
#include<cmath>
#include<cstdlib>
#include<cctype>
#include<map>
#define mp make_pair
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
inline ll read() {
	char ch = getchar(); ll x = 0; int op = 1;
	for(; !isdigit(ch); ch = getchar()) if(ch == '-') op = -1;
	for(; isdigit(ch); ch = getchar()) x = x*10+ch-'0';
	return x*op;
}
inline void write(ll a) {
	if(a < 0) putchar('-'), a = -a;
	if(a >= 10) write(a/10); putchar('0'+a%10);
}
const int N = 100010, M = 1000010;
int n, m, que;
int ans[N];
bool vis[M];
map<pii, int> id;
struct edge { int x, y, z; } e[M];
struct questions { int opt, x, y, flag; } q[N];
const bool cmp(const edge &a, const edge &b) { return a.z < b.z; }
const int S = N+M;
int rev[S], fa[S], c[S][2], mx[S], val[S];
inline bool isroot(int x) { return c[fa[x]][0] != x && c[fa[x]][1] != x; }
inline void pushup(int x) {
	mx[x] = val[x];
	if(e[mx[c[x][0]]].z > e[mx[x]].z) mx[x] = mx[c[x][0]];
	if(e[mx[c[x][1]]].z > e[mx[x]].z) mx[x] = mx[c[x][1]];
}
inline void rot(int x) {
	if(isroot(x)) return;
	int y = fa[x], z = fa[y], f = c[y][1] == x;
	c[y][f] = c[x][f^1]; if(c[x][f^1]) fa[c[x][f^1]] = y;
	fa[x] = z; if(!isroot(y)) c[z][c[z][1] == y] = x;
	fa[y] = x; c[x][f^1] = y;
	pushup(y); pushup(x);
}
inline void pushdown(int x) {
	if(!rev[x]) return;
	rev[c[x][0]] ^= 1; rev[c[x][1]] ^= 1; swap(c[x][0], c[x][1]);
	rev[x] = 0;
}
int st[N], top;
inline void pushtag(int x) {
	top = 0;
	while(x) { st[++ top] = x; x = fa[x]; }
	while(top) pushdown(st[top --]);
}
inline void splay(int x) {
	pushtag(x);
	while(!isroot(x)) {
		int y = fa[x], z = fa[y];
		if(!isroot(y)) rot(((c[z][0] == y) == (c[y][0] == x))?y:x);
		rot(x);
	}
}
inline void access(int x) {
	int t = 0;
	while(x) {
		splay(x); c[x][1] = t; pushup(x);
		t = x; x = fa[x];
	}
}
inline void rever(int x) { access(x); splay(x); rev[x] ^= 1; }
inline void link(int x, int y) { rever(x); fa[x] = y; }
inline void split(int x, int y) { rever(x); access(y); splay(y); }
inline void cut(int x, int y) { split(x, y); fa[x] = c[y][0] = 0; }
inline int find(int x) {
	access(x); splay(x); pushdown(x);
	while(c[x][0]) { x = c[x][0]; pushdown(x); }
	return x;
}
inline void init(int x, int y) {
	fa[x] = c[x][0] = c[x][1] = rev[x] = 0;
	mx[x] = val[x] = y;
}
int main() {
	/*freopen("tube.in", "r", stdin);
	freopen("tube.out", "w", stdout);*/
	n = read(), m = read(), que = read();
	for(int i = 1; i <= m; i ++) {
		e[i].x = read(); e[i].y = read(); e[i].z = read();
		if(e[i].x > e[i].y) swap(e[i].x, e[i].y);
	}
	sort(e+1, e+1+m, cmp);
	for(int i = 1; i <= m; i ++) id[mp(e[i].x, e[i].y)] = i;
	for(int i = 1; i <= que; i ++) {
		q[i].opt = read(); q[i].x = read(); q[i].y = read();
		if(q[i].x > q[i].y) swap(q[i].x, q[i].y);
		if(q[i].opt == 2) {
			int d = id[mp(q[i].x, q[i].y)];
			q[i].flag = d;//flag表示q[i]这条边在e中的编号 
			vis[d] = 1;
		}
	}
	int all = n+m, sum = 0; e[0].z = 0;
	for(int i = 1; i <= all; i ++) init(i, i<=n?0:(i-n));
	for(int i = 1, x, y; i <= m; i ++) if(!vis[i]) {
		if(sum == n-1) break;
		x = e[i].x; y = e[i].y;
		if(find(x) == find(y)) continue;
		link(x, i+n); link(y, i+n);
		sum ++;
	}
	for(int i = que, x, y; i >= 1; i --) {
		x = q[i].x; y = q[i].y;
		if(q[i].opt == 1) {
			split(x, y); ans[i] = e[mx[y]].z;
		} else {
			split(x, y);
			int d = q[i].flag, t = mx[y];
			if(e[d].z < e[mx[y]].z) {
				cut(e[t].x, t+n); cut(e[t].y, t+n);
				link(x, d+n); link(y, d+n);
			}
		}
	}
	for(int i = 1; i <= que; i ++) if(q[i].opt == 1) write(ans[i]), puts("");
	return 0;
}
```



**后话：**

emmm我写了这么多也是挺累的，泥萌觉得好的话一定要兹瓷一下嗷！赞一下很快的嗷~qwqwqwq

也鼓励我一下以后能继续写好的题解！

有什么缺点也尽管提出来~欢迎的嗷~


---

## 作者：wjyyy (赞：21)

**我的博客：[传送门](https://www.wjyyy.top/2956.html)**

## 题解：

这个题要维护的是一个图而不是一棵树，看似不能用LCT写。但是这是LCT的一个用法——维护生成树。

---

因为本题要求出**路径上的最大值**，可能会想到[货车运输](https://www.luogu.org/problemnew/show/P1967)的一个贪心，并维护生成树。然而还需要动态删边，万一删掉了生成树上的边，总不能再做一遍生成树吧？

但是这个题只有删边，因此过程是**单调的**，因此把它倒过来就是加边。加边理论上就好做一些了。

因为保证了“任何时候我们考虑的水管网络都是连通的”，所以先把图删到最后，不做任何查询操作，这一点又有点像[航线规划](https://www.luogu.org/problemnew/show/P2542)一题了（这题以前是用[树剖水过去的](https://www.wjyyy.top/895.html)，也是先把边删完）。

此时我们求出残余图上的最小生成树，那么任意两点之间只要沿着这棵MST上走，就是最优的，这是一个贪心。

拿LCT维护这棵生成树，splay上的点维护的是区间最大值，本质上是一条链的最大权值。

之后考虑加边，也就是动态的MST了，顺着上面贪心的思路想，如果在树上加入一条边，就会形成一个环。此时从任意一点进入环，从另一点出环，可以从环上两个方向走，那么最优解总可以避开最长的一条边。

![](http://www.wjyyy.top/wp-content/uploads/2019/01/201901031739.png)

比如说从$E$到$D$，最优的路径是$E-C-A-B-D$，路径最大值为$7$，而$E-F-D$最大值为$8$。那么$D-F$这条边可以删掉，原因是最优解总不必经过这条边。

那么假设$E-F$这条边是新加进来的，原来的图是这样（“环”上的点还连接有其他的边，但保证是一棵树）

![](http://www.wjyyy.top/wp-content/uploads/2019/01/201901031745.png)

我们现在只关注这个“环”，先用`split(E,F)`把$E-F$这条**链**的信息提取出来。此时可以查询出链上的最大权值$8$，与即将加入的$3$进行比较。发现$3<8$。说明这个环上可以删掉权值最大的边来保证最优，那么在平衡树上“二分”出这条边，来删除它。如果即将加入的边权比整条链上的最大值还大，那么直接忽略这个操作。

上面提到的“二分”实际上是在平衡树上查找。如果发现根节点的值就是所要的值，就返回根节点，否则哪棵子树中有这个最大值，就进哪棵子树，这一步复杂度均摊$O(\log n)$。

查询的时候直接`split()`然后查询链的信息就好了。

还有一个重要的是如何维护边，这时不能像树剖那样维护到父亲的边了。因为LCT比较灵活，所以考虑用一个点来代表一条边。比如说我要连接原图上的$1,2$两点，把这条边命名为$A$（$A$在程序中还是会用数字来表示的），权值为$4$。

![](http://www.wjyyy.top/wp-content/uploads/2019/01/201901031856.png)

就把$1,2$与$A$分别连接起来。$A$在整张图中始终只与$1,2$这两个点相连，边权在LCT上表示为点权。原图上的点点权为$0$（如果要求最小值原图上的点应该设为$+\infty$）。

然后倒序**加边**，再把答案倒过来输出就可以了。

## Code：

代码并没有什么注释，希望dalao们把思想理解后做题

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ls ch[0][k]
#define rs ch[1][k]
#define which(k) (ch[1][fa[k]]==k)
#define isroot(k) (ch[0][fa[k]]!=k&&ch[1][fa[k]]!=k)
using std::max;
int ch[2][120000],fa[120000];
int key[120000],sum[120000],lazy[120000];
void maintain(int k)
{
    sum[k]=max(max(sum[ls],key[k]),sum[rs]);
}
void pushdown(int k)
{
    if(lazy[k])
    {
        int tmp=ls;
        ls=rs;
        rs=tmp;
        lazy[k]=0;
        lazy[ls]^=1;
        lazy[rs]^=1;
    }
}
void Rotate(int k)
{
    int y=fa[k];
    if(!isroot(y))
        ch[which(y)][fa[y]]=k;
    bool d=which(k);
    fa[k]=fa[y];
    fa[y]=k;
    ch[d][y]=ch[!d][k];
    fa[ch[d][y]]=y;
    ch[!d][k]=y;
    maintain(y);
    maintain(k);
}
int stk[120000],tp=0;
void splay(int k)
{
    int x=k;
    while(!isroot(x))
    {
        stk[++tp]=x;
        x=fa[x];
    }
    stk[++tp]=x;
    while(tp)
        pushdown(stk[tp--]);

    while(!isroot(k))
    {
        int y=fa[k];
        if(!isroot(y))
            Rotate(which(k)^which(y)?k:y);
        Rotate(k);
    }
}
void access(int k)
{
    for(int x=k,y=0;x;y=x,x=fa[x])
    {
        splay(x);
        ch[1][x]=y;
        maintain(x);
    }
}
void makeroot(int k)
{
    access(k);
    splay(k);
    lazy[k]^=1;
}
void split(int x,int y)
{
    makeroot(x);
    access(y);
    splay(y);
}
void link(int x,int y)
{
    makeroot(x);
    fa[x]=y;
}
void cut(int x,int y)
{
    makeroot(x);
    access(y);
    splay(y);
    fa[x]=ch[0][y]=0;
}
int Find(int k,int x)
{
    if(key[k]==x)
        return k;
    if(sum[ls]==x)
        return Find(ls,x);
    return Find(rs,x);
}
int f[1010][1010],U[101000],V[101000],op[101000];
int n,m,q;
struct edge
{
    int x,y,v,ava;
    edge(){ava=1;}
    friend bool operator <(edge a,edge b)
    {
        return a.v<b.v;
    }
}e[101000];
int s[1010];
int Find(int x)
{
    if(s[x]!=x)
        return s[x]=Find(s[x]);
    return x;
}
void Union(int x,int y)
{
    s[Find(x)]=Find(y);
}
void mst()
{
    for(int i=1;i<=n;++i)
        s[i]=i;
    for(int i=1;i<=m;++i)
        if(e[i].ava&&Find(e[i].x)!=Find(e[i].y))
        {
            Union(e[i].x,e[i].y);
            link(e[i].x,n+i);
            link(e[i].y,n+i);
        }
}
int ans[101000];
int main()
{
    scanf("%d%d%d",&n,&m,&q);
    for(int i=1;i<=m;++i)
        scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].v);
    std::sort(e+1,e+1+m);
    for(int i=1;i<=m;++i)
    {
        f[e[i].x][e[i].y]=f[e[i].y][e[i].x]=i;
        key[n+i]=e[i].v;
    }
    for(int i=1;i<=q;++i)
    {
        scanf("%d%d%d",&op[i],&U[i],&V[i]);
        if(op[i]==2)
            e[f[U[i]][V[i]]].ava=0;
    }
    mst();
    int cnt=0;
    for(int i=q;i>=1;--i)
    {
        split(U[i],V[i]);//V[i]是根
        if(op[i]==1)
            ans[++cnt]=sum[V[i]];
        else
        {
            int t=Find(V[i],sum[V[i]]);
            if(key[f[U[i]][V[i]]+n]<sum[V[i]])
            {
                cut(e[t-n].x,t);
                cut(e[t-n].y,t);
                link(U[i],f[U[i]][V[i]]+n);
                link(V[i],f[U[i]][V[i]]+n);
            }
        }
    }
    for(int i=cnt;i>=1;--i)
        printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：MloVtry (赞：17)

首先这是要求一个树链上最大值最小。


考虑Kruskal算法流程，发现最小生成树上的路径一定是最优的。


那么就要维护一颗最小生成树。


正序删边可以离线反向操作，变成加边。


那么在一个最小生成树上加入一条边，就会形成一个环，断开换上最大的边，就会得到一颗新的最小生成树，用LCT维护。


代码

```cpp
#include<algorithm>
#include<iostream>
#define N 1500000
#include<cstdio>
using namespace std;
int re[N],c[N][2],mx[N],val[N],fa[N];
int s[N],top;

bool isroot(int now)
{
    return !fa[now]||(c[fa[now]][0]!=now&&c[fa[now]][1]!=now);
}
void down(int now)
{
    if(re[now])
    {
        re[now]^=1;
        re[c[now][0]]^=1;
        re[c[now][1]]^=1;
        swap(c[now][0],c[now][1]);
    }
}
void update(int now)
{
    mx[now]=now;
    if(val[ mx[c[now][0]] ]>val[mx[now]]) mx[now]=mx[c[now][0]];
    if(val[ mx[c[now][1]] ]>val[mx[now]]) mx[now]=mx[c[now][1]];
}
void rotate(int now)
{
    int F=fa[now],Y=fa[F];
    int r=c[F][0]==now,l=r^1;
    
    if(!isroot(F)) if(c[Y][0]==F) c[Y][0]=now;else c[Y][1]=now;
    
    fa[now]=Y;fa[F]=now;
    c[F][l]=c[now][r];
    fa[c[now][r]]=F;
    c[now][r]=F;
    update(F); 
    update(now);
}
void splay(int now)
{
    s[top=1]=now;
    for(int i=now;!isroot(i);i=fa[i]) s[++top]=fa[i];
    while(top) down(s[top--]);
    while(!isroot(now))
    {
        int F=fa[now],Y=fa[F];
        if(!isroot(F))
        {
            if((c[Y][0]==F)^(c[F][0]==now)) rotate(now);
            else rotate(F);
        }
        rotate(now);
    }
}
void access(int now)
{
    int last=0;
    while(now) splay(now),c[now][1]=last,update(now),last=now,now=fa[now];
}

void makeroot(int x)
{
    access(x);splay(x);re[x]^=1;
}
void link(int x,int y)
{
    makeroot(x);fa[x]=y;
}
void cut(int x,int y)
{
    makeroot(x);access(y);splay(y);fa[x]=c[y][0]=0;
}
int query(int x,int y)
{
    makeroot(x);access(y);splay(y);return mx[y];
}


struct eage
{
    int u,v,l,id;
    bool po;
}e[N];
struct node
{
    int x,y,ans,id,fl; 
}q[N];
int n,m,Q;

bool comp1(eage aa,eage bb)
{
    return aa.u==bb.u?aa.v<bb.v:aa.u<bb.u;
}
bool comp2(eage aa,eage bb)
{
    return aa.l<bb.l;
}
bool comp3(eage aa,eage bb)
{
    return aa.id<bb.id;
}
int findit(int u,int v)
{
    int l=1,r=m;
    while(l<=r)
    {
        int mid=(l+r)>>1;
        if(e[mid].u<u||(e[mid].u==u&&e[mid].v<v))l=mid+1;
        else if(e[mid].u==u&&e[mid].v==v)return mid;
        else r=mid-1;
    }
}
int f[N];
int get_f(int now)
{
    return now==f[now]?f[now]:f[now]=get_f(f[now]);
}
void KU()
{
    for(int i=1;i<=n;++i) f[i]=i;
    sort(e+1,e+m+1,comp3);
    int tot=0;
    for(int i=1;i<=m;++i)
    {
        if(e[i].po) continue; 
        int x=get_f(e[i].u),y=get_f(e[i].v);
        if(x==y) continue;
        tot++;
        f[x]=y;
        link(e[i].u,i+n);
        link(e[i].v,i+n);
        if(tot==n-1) return;
    }
}
int main()
{
    scanf("%d%d%d",&n,&m,&Q);
    for(int i=1;i<=m;++i)
    {
        scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].l);
        if(e[i].u>e[i].v) swap(e[i].u,e[i].v);
    }
    //buid
    sort(e+1,e+m+1,comp2);
    for(int i=1;i<=m;++i)
    {
        e[i].id=i;
        val[n+i]=e[i].l;
        mx[n+i]=n+i;
    }
    //in
    sort(e+1,e+m+1,comp1);
    for(int i=1;i<=Q;++i)
    {
        scanf("%d%d%d",&q[i].fl,&q[i].x,&q[i].y);
        if(q[i].fl==2)
        {
            if(q[i].x>q[i].y) swap(q[i].x,q[i].y);
            int id=findit(q[i].x,q[i].y);
            q[i].id=e[id].id;
            e[id].po=1;
        }
    }
    
    KU();
    for(int i=Q;i;--i) 
    {
        if(q[i].fl==1) q[i].ans=val[query(q[i].x,q[i].y)];
        else//join
        {
            int bi=query(q[i].x,q[i].y);
            if(val[bi]>val[q[i].id+n])
            {
                cut(e[bi-n].u,bi);
                cut(e[bi-n].v,bi);
                link(q[i].x,q[i].id+n);
                link(q[i].y,q[i].id+n);
            }
        }
    }
    for(int i=1;i<=Q;++i) if(q[i].fl==1) printf("%d\n",q[i].ans);
    return 0;
}
```

---

## 作者：FlashHu (赞：14)

## 思路分析

在一个图中，要求路径上最大边边权最小，就不难想到最小生成树。而题目中有删边的操作，那肯定是要动态维护啦。直接上LCT维护边权最小值（可以参考一下[蒟蒻的Blog](http://www.cnblogs.com/flashhu/p/8324551.html)）

这时候令人头疼的问题又冒出来了。。。。。。删掉一条边以后，又不好从树断开后的两边选出最小的边在连上。这是根本维护不了的。

于是蒟蒻又get到了一个新套路——顺序解决不了的问题，可以离线询问，反过来处理。原来的删边变成了加边，就很方便了。直接split找出环上的最大边，当前要加的边比它小就替换掉。

一个做法的问题：在反过来初始化最后时刻的最小生成树的时候，kruskal加边时还不是很好判断当前枚举到的边有没有在中途断掉。如果要搞一个set或者map之类的东西，不会很麻烦？

然后看到N居然只有1000？！于是直接开邻接矩阵标记一下就好啦。

卡常+O2 600+ms水到榜上来
```
#include<cstdio>
#include<algorithm>
using namespace std;
#define R register int
#define I inline void
#define lc c[x][0]
#define rc c[x][1]
const int N=1009,M=2009,L=100009;
int f[M],c[M][2],v[M],mx[M],ex[M];
//ex存放LCT中代表边的点的子节点，为卡常cut帮忙
int ff[N],l[N][N],k[L],a[L],b[L],ans[L];
bool r[M],g[N][N];//暴力搞邻接矩阵
struct EDGE{
    int u,v,l;
    inline bool operator<(EDGE x)const{
        return l<x.l;
    }
}e[L];
char ch;int z;
inline int in(){
    while((ch=getchar())<'-');
    z=ch&15;
    while((ch=getchar())>'-')z*=10,z+=ch&15;
    return z;
}
inline bool nroot(R x){return c[f[x]][0]==x||c[f[x]][1]==x;}
inline int get(R x,R y){return v[x]>v[y]?x:y;}
I pushup(R x){
    mx[x]=get(x,get(mx[lc],mx[rc]));
}
I pushdown(R x){
    if(r[x]){
        R t=lc;
        r[lc=rc]^=1;r[rc=t]^=1;r[x]=0;
    }
}
I pushall(R x){
    if(nroot(x))pushall(f[x]);
    pushdown(x);
}
I rotate(R x){
    R y=f[x],z=f[y],k=c[y][1]==x,w=c[x][!k];
    if(nroot(y))c[z][c[z][1]==y]=x;c[x][!k]=y;c[y][k]=w;
    f[w]=y;f[y]=x;f[x]=z;
    pushup(y);
}
I splay(R x){
    R y=x;
    pushall(x);
    while(nroot(x)){
        if(nroot(y=f[x]))
            rotate((c[y][0]==x)^(c[f[y]][0]==y)?x:y);
        rotate(x);
    }
    pushup(x);
}
I access(R x){
    for(R y=0;x;x=f[y=x])
        splay(x),rc=y,pushup(x);
}
I mroot(R x){
    access(x);splay(x);
    r[x]^=1;
}
#define link(E)\
    mroot(x);f[f[ex[E]=x]=E]=y;\
    v[E]=l[x][y];pushup(E)
//不正常的link和cut（也总结在blog里）
I cut(R x){
    access(ex[x]);splay(x);
    lc=rc=f[lc]=f[rc]=0;
}
int getf(R x){
    if(x==ff[x])return x;
    return ff[x]=getf(ff[x]);
}
int main(){
    R n,m,Q,i,x,y,tmp,cnt;
    n=in();m=in();Q=in();
    for(i=1;i<=m;++i){
        x=e[i].u=in();y=e[i].v=in();
        l[x][y]=l[y][x]=e[i].l=in();
    }
    for(i=1;i<=Q;++i){
        k[i]=in();a[i]=in();b[i]=in();
        if(k[i]&2)g[a[i]][b[i]]=g[b[i]][a[i]]=1;
    }
    for(i=0;i<=n;++i)
        ff[i]=i;
    //接下来还是走一遍kruskal
    sort(e+1,e+m+1);
    for(cnt=n*2-1,i=1;cnt>n;++i){
        x=e[i].u;y=e[i].v;
        if(!g[x][y]&&getf(x)!=getf(y)){
            link(cnt);--cnt;
            ff[ff[x]]=ff[y];
        }
    }
    for(cnt=0,i=Q;i;--i){
        mroot(x=a[i]);
        access(y=b[i]);splay(y);
        if(k[i]&1)ans[++cnt]=v[mx[y]];//答案压到栈里面，最后反过来弹
        else if(v[mx[y]]>l[x][y]){
            cut(tmp=mx[y]);link(tmp);
        }
    }
    while(cnt)printf("%d\n",ans[cnt--]);
    return 0;
}
```

---

## 作者：Nemlit (赞：10)

## [原文地址](https://www.cnblogs.com/bcoier/p/10576550.html)

### 题目大意：

给定一张图，支持删边，求两点的路径中所有权值的最大值的最小值，~~貌似很绕的样子~~

由于有删边，不难想到$LCT$，又因为$LCT$不支持维护图，而且只有删边操作，于是我们考虑时间回溯。

把这道题变成模板有几个问题：

（思路为个人$YY$，可能非常麻烦）

### $1.$我们怎么确定最后的状态呢？

首先我们先用$map$存每一条边，在询问操作时，每删一条边，就把他在$map$上去掉，最后剩下的边即为最终状态

### $2.$加边的时候会出现环该怎么办呢？

要让答案更优，我们显然要动态维护[最小生成树](https://www.luogu.org/blog/Hakuryu/solution-p3366)，然后维护了最小生成树后就只要找最小生成树树上两点的最大值了

附上常数极大又十分丑陋的代码：

```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define file(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
il int read() {
    re int x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
#define rep(i, s, t) for(re int i = s; i <= t; ++ i)
#define drep(i, s, t) for(re int i = t; i >= s; -- i)
#define updown(x) swap(ch[1][x], ch[0][x]), tag[x] ^= 1
#define get_fa(x) ch[1][fa[x]] == x
#define isroot(x) ch[1][fa[x]] == x || ch[0][fa[x]] == x
#define _ 150006
int n, m, Q, ans[_], Top, st[_], top, fa[_], tag[_], ch[2][_], val[_], ma[_], id[_];
struct node {int opt, u, v, w;}e[_];
pair<int, int> a[_];
map<pair<int, int>, int> q, Id;
il void pushdown(int x) {
	if(!tag[x]) return;
	if(ch[1][x]) updown(ch[1][x]);
	if(ch[0][x]) updown(ch[0][x]);
	tag[x] = 0;
}
il void pushup(int x) {
	ma[x] = val[x], id[x] = x;
	if(ch[1][x] && ma[x] < ma[ch[1][x]]) ma[x] = ma[ch[1][x]], id[x] = id[ch[1][x]];
	if(ch[0][x] && ma[x] < ma[ch[0][x]]) ma[x] = ma[ch[0][x]], id[x] = id[ch[0][x]];
}
il void rotate(int x) {
	int y = fa[x], z = fa[y], w = get_fa(x), k = get_fa(y);
	ch[w][y] = ch[w ^ 1][x], fa[ch[w ^ 1][x]] = y;
	if(isroot(y)) ch[k][z] = x; fa[x] = z;
	ch[w ^ 1][x] = y, fa[y] = x;
	pushup(y), pushup(x);
}
il void Splay(int x) {
	int y = x;
	st[++ top] = x;
	while(isroot(y)) st[++ top] = y = fa[y];
	while(top) pushdown(st[top --]);
	while(isroot(x)) {
		int y = fa[x];
		if(isroot(y)) rotate(get_fa(x) == get_fa(y) ? y : x);
		rotate(x);
	}
}
il void access(int x) {for(int y = 0; x; x = fa[y = x]) Splay(x), ch[1][x] = y, pushup(x);}
il void makeroot(int x) {access(x), Splay(x), updown(x);}
il int findroot(int x) {
	access(x), Splay(x);
	while(ch[0][x]) x = ch[0][x];
	Splay(x);
	return x;
}
il void spilt(int x, int y) {makeroot(x), access(y), Splay(y);}
il void link(int x, int y) {
	makeroot(x);
	if(findroot(y) != x) fa[x] = y;
}
int main() {
	file(a);
	n = read(), m = read(), Q = read();
	rep(i, 1, m) {
		int u = read(), v = read();
		a[i] = make_pair(u, v), q[make_pair(v, u)] = q[a[i]] = read(), val[i + n] = q[a[i]];
		Id[a[i]] = Id[make_pair(v, u)] = i;
	}
	rep(i, 1, Q) {
		int opt = read(), u = read(), v = read();
		e[i] = (node){opt, u, v, q[make_pair(u, v)]};
	}
	rep(i, 1, Q) 
		if(e[i].opt == 2) q[make_pair(e[i].u, e[i].v)] = q[make_pair(e[i].v, e[i].u)] = 0;
    rep(i, 1, m) {
        if(q[a[i]] == 0) continue;
        if(findroot(a[i].first) == findroot(a[i].second)) {
            spilt(a[i].first, a[i].second); int now = id[a[i].second];
            if(val[i + n] >= val[now]) continue;
            Splay(now), fa[ch[1][now]] = fa[ch[0][now]] = 0;
        }
        link(a[i].first, i + n), link(i + n, a[i].second);
    }
	drep(i, 1, Q) {
		int u = e[i].u, v = e[i].v;
		if(e[i].opt == 2) {
            if(findroot(u) == findroot(v)) {
                spilt(u, v); int now = id[v];
                if(e[i].w >= val[now]) continue;
                Splay(now), fa[ch[1][now]] = fa[ch[0][now]] = 0;
            }
            link(u, Id[make_pair(u, v)] + n), link(Id[make_pair(u, v)] + n, v);
        }
		else spilt(u, v), ans[++ Top] = val[id[v]];
	}
	drep(i, 1, Top) printf("%d\n", ans[i]);
	return 0;
}
```

---

## 作者：Refun (赞：7)

一开始的确是用最小生成树搞的，只不过想法有点错误没想出来

直到交上去RE了才发现QAQ

其实这个题离线就很好做。倒序，然后把删边看成加边 

先把所有不会被拆除的边kruskal一下（不一定要求出最小生成树，森林也行，毕竟后面还会有加边

然后倒序看询问，如果为1就输出，如果为2就先判断一下当前图中(x,y)的简单路径情况

若xy不联通，直接连接

若xy联通，且xy路径上的最长边小于要加的边，则不处理

否则就将最大边删掉，然后link要加的边即可
维护边权则是套路方法

不过学到一个新套路QAQ

将所有边的x,y按小的再前面

然后x第一关键字，y第二关键字sort一下
第i条边的编号为i+n，找的时候在边里二分一下就找到了QAQ 

我的[代码](http://www.cnblogs.com/refun/p/8685633.html)能过加强版的数据

---

## 作者：学哥 (赞：5)

## 前言

搞不懂为什么要写LCT，搞不懂为什么要加强数据。06年哪来的这么多LCT？~~我不会告诉你我是不会LCT的~~ 像这道题是用父亲表示法来搞的。虽然复杂度不是log，但是现在下面这份代码却是无论从空间，还是代码量，还是时间都是优秀不止一点。
~~而且这样还能出在noip这样的考试~~

## sol

一个烂大街的套路就是离线搞。这也是这道题的唯一难点。估计大佬们都已经讲透了。

但是为了照顾我这样的不会LCT的蒟蒻，这里有一个更好的办法，那就是直接用fa[]数组来维系这棵树。比如说，要把u,v相连，首先把u向上用fa数组跑，然后一路将fa数组反向。

然后就可以直接赋值fa[u]=v。

但是写的时候还是心虚，所以写的十分小心，应该把常数弄到最小了。**代码一定不能写丑**

## code

```c++
#include<bits/stdc++.h>
using namespace std;
const int _=1e6+22;
int fa[1001],g[1001][1001],n,m,Q,anss[_/10],mm,par[1001],sign[1001],cnt;
int rec[1001];
struct Edge{
	int u,v,w;
}e[_],e1[_];
struct MO{
	int u,v,k;
}mo[_];
inline char gc(){
	static char buf[1<<6],*p1=buf,*p2=buf;
	return (p1==p2)&&(p2=(p1=buf)+fread(buf,1,1<<6,stdin),p1==p2)?EOF:*p1++;
}
template <class T>
inline void read(T&data){
	data=0;
	register char ch=0;
	while(ch<'0'||ch>'9')ch=gc();
	while(ch<='9'&&ch>='0'){
		data=(data<<1)+(data<<3)+(ch^48);
		ch=gc();
	}
}
template <class R>
inline void write(R data){
	if(data>9)write(data/10);
	putchar('0'+data%10);
}
bool cmp(register Edge a,register Edge b){return a.w<b.w;}
int fi(register int x){return x==par[x]?x:par[x]=fi(par[x]);}
int main(){
	read(n),read(m),read(Q);
	register int i,u,v,fu,fv,ff,qq,now,LCA,ans,ANS;
	for(i=1;i<=m;++i){
		register Edge & fff=e1[i];
		read(fff.u),read(fff.v),read(fff.w);
	}
	for(i=1;i<=Q;++i){
		register MO& IOI=mo[i]; 
		read(IOI.k),read(IOI.u),read(IOI.v);
		if(IOI.k==2)g[IOI.v][IOI.u]=1,g[IOI.u][IOI.v]=1;
	}
	for(i=1;i<=m;++i){
		register int &IOI=g[e1[i].u][e1[i].v];
		if(!IOI)e[++mm]=e1[i];
		IOI=g[e1[i].v][e1[i].u]=e1[i].w;
	}
	sort(e+1,e+mm+1,cmp);
	for(i=1;i<=n;++i)par[i]=i;
	for(i=1;i<=mm;++i){
		u=e[i].u,v=e[i].v,fu=fi(u),fv=fi(v);
		if(fu==fv)continue;
		par[fu]=fv,ff=fa[u],qq=u;
		while(ff)
			swap(fa[ff],qq),swap(ff,qq);			
		fa[u]=v;
	}
	for(i=Q;i;--i){
		u = mo[i].u,v=mo[i].v,now=u,rec[now]=0;
		while(now){sign[now]=i,rec[fa[now]]=max(rec[now],g[now][fa[now]]),now=fa[now];}
		LCA=v,ans=0,ANS=0;
		while(LCA&&sign[LCA]!=i){ans=max(ans,g[LCA][fa[LCA]]),LCA=fa[LCA];}
		ANS=max(ans,rec[LCA]);
		if(mo[i].k==1){anss[++cnt]=ANS;}
		else {
			if(ANS<=g[u][v])continue;
			if(ans>rec[LCA])swap(u,v);
			ff=fa[u],qq=u;
			while(g[qq][ff]!=ANS){
				swap(fa[ff],qq),swap(ff,qq);
			}
			fa[u]=v;
		}
				
	}
	for(i=cnt;i;--i)write(anss[i]),puts("");
	return 0;	
}

```





---

## 作者：devout (赞：3)

[博客内食用更佳](https://blog.csdn.net/devout_/article/details/104539669)

**14:30 开始写题**

思路：首先这道题我们肯定要倒序操作，因为只有删边，倒序变成加边更好处理，其实这题跟[航线规划](https://www.luogu.com.cn/problem/P2542)挺像的。

我们发现，他让走过的道路的最大准备时间最短，那么他走的路径一定是在他的最小生成树上的！所以问题就转化成了lct维护最小生成树

因为这题要维护的是边权，所以我们把边权看成点，比如说一个连接$x$,$y$的编号为$i$的边我们要连接起来就是

```cpp
link(x,i+n),link(i+n,y);
```

维护最小生成树的方法，我们考虑如果我们新加进来一条边，那么一定会形成一个环，我们就需要把这个环上的最大的一条边给删掉，所以我们只需要lct维护一下最大值就可以了，注意这里维护的是**边权最大的边的编号**

如果新加进来的$x\ to \ y$的边比之前$x$,$y$之间路径上的最大边权还要大，就不管他，否则把最大的$cut$掉，然后把这条边$link$上

为了记录编号我们可以先排序然后lower_bound一下

而且这道题有个条件，就是保证任何时刻所有点联通，也就是说最后剩下的至少是一棵树了，考虑的情况就少一些

**15:00 码完**

一测样例，死了qwq

然后发现是我的vis标记打反了

**15:15 第一次提交**

交上去发现只有10分

代码：

```cpp
# include <bits/stdc++.h>
using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)
# define debug puts("QAQ");

typedef long long ll;
const int N=2e5+5;
const int mod=1e9+7;
const double eps=1e-7;

template <typename T> void read(T &x){
	x=0;int f=1;
	char c=getchar();
	for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
	x*=f;
}

int n,m,q;
int fa[N],son[N][2],_max[N],val[N],st[N];
int out[N],cnt;
int sum;
bool vis[N],tag[N];

struct Edge{
	int x,y,c;
	bool operator < (const Edge &cmp)const{
		if(x==cmp.x)return y<cmp.y;
		return x<cmp.x;
	}
}e[N];

struct querys{
	int x,y,id,opt;
}qr[N];

bool isroot(int x){
	return son[fa[x]][0]!=x&&son[fa[x]][1]!=x;
}

bool locate(int x){
	return son[fa[x]][1]==x;	
}

void reverse(int x){
	swap(son[x][0],son[x][1]);
	tag[x]^=1;	
}

void update(int x){
	_max[x]=val[x];
	if(e[_max[son[x][0]]].c>e[_max[x]].c)_max[x]=_max[son[x][0]];
	if(e[_max[son[x][1]]].c>e[_max[x]].c)_max[x]=_max[son[x][1]];	
}

void pushdown(int x){
	if(tag[x]){
		if(son[x][0])reverse(son[x][0]);
		if(son[x][1])reverse(son[x][1]);
		tag[x]=0;
	}
}

void rotate(int x){
	int y=fa[x],z=fa[y],side=locate(x);
	fa[x]=z;
	if(!isroot(y))son[z][son[z][1]==y]=x;
	son[y][side]=son[x][side^1];
	if(son[x][side^1])fa[son[y][side]]=y;
	son[x][side^1]=y,fa[y]=x;
	update(y),update(x);	
}

void splay(int x){
	int y=x,top=0;
	st[++top]=y;
	while(!isroot(y))y=fa[y],st[++top]=y;
	while(top)pushdown(st[top--]);
	while(!isroot(x)){
		int y=fa[x];
		if(!isroot(y))rotate(locate(x)==locate(y)?y:x);
		rotate(x);	
	}
	update(x);
}	

void access(int x){
	for(int y=0;x;y=x,x=fa[x])
		splay(x),son[x][1]=y,update(x);	
}

void makeroot(int x){
	access(x),splay(x);
	reverse(x);	
}

int findroot(int x){
	access(x),splay(x);
	while(son[x][0])pushdown(x),x=son[x][0];
	splay(x);
	return x;
}

void split(int x,int y){
	makeroot(x);
	access(y),splay(y);	
}

void link(int x,int y){
	makeroot(x);
	fa[x]=y;	
}

void cut(int x,int y){
	split(x,y);
	fa[x]=son[y][0]=0;	
}

int main()
{
	read(n),read(m),read(q);
	Rep(i,1,m){
		read(e[i].x),read(e[i].y),read(e[i].c);
		if(e[i].x>e[i].y)swap(e[i].x,e[i].y);
	}	
	sort(e+1,e+m+1);
	Rep(i,1,q){
		read(qr[i].opt),read(qr[i].x),read(qr[i].y);
		if(qr[i].x>qr[i].y)swap(qr[i].x,qr[i].y);
		if(qr[i].opt==2){
			int _id=lower_bound(e+1,e+m+1,(Edge){qr[i].x,qr[i].y,0})-e;
			qr[i].id=_id;
			vis[_id]=true;
		}
	}
	Rep(i,1,n+m)_max[i]=val[i]=(i<=n?0:(i-n));
	Rep(i,1,m){
		if(sum==n-1)break;
		int x=e[i].x,y=e[i].y;
		if(vis[i])continue;
		if(findroot(x)==findroot(y))continue;
		link(x,i+n),link(i+n,y);
		sum++;		
	}
	_Rep(i,q,1){
		int x=qr[i].x,y=qr[i].y;
		if(qr[i].opt==1)split(x,y),out[++cnt]=e[_max[y]].c;
		else{
			split(x,y);
			int _id=_max[y];
			if(e[qr[i].id].c>e[_id].c)continue;
			cut(e[_id].x,_id+n),cut(_id+n,e[_id].y);
			link(x,qr[i].id+n),link(y,qr[i].id+n);
		}
	}
	_Rep(i,cnt,1)printf("%d\n",out[i]);
	return 0;
}
```
为什么呢？

**16:15 恍然大悟**

~~别问我中间干啥去了~~

我们考虑我们正常我们的$kruskal$是怎么做的

我们要按**边权**排序，而不是x，y

原来错在这里了啊，那么我们改一下排序方式就好了吧

别急，这样的话lower_bound就不好做了

手写二分又死循环了

最后只好用到map大法

**16:35 AC**

我们用map来映射一下就好啦

AC code：

```cpp
# include <bits/stdc++.h>
using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)
# define debug puts("QAQ");

typedef long long ll;
const int N=2e5+5;
const int mod=1e9+7;
const double eps=1e-7;

template <typename T> void read(T &x){
	x=0;int f=1;
	char c=getchar();
	for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
	x*=f;
}

int n,m,q;
int fa[N],son[N][2],_max[N],val[N],st[N];
int out[N],cnt;
int sum;
bool vis[N],tag[N];

struct Edge{
	int x,y,c;
	bool operator < (const Edge &cmp)const{
		return c<cmp.c;	
	}
}e[N];

map<pair<int,int>,int> mp;

struct querys{
	int x,y,id,opt;
}qr[N];

bool isroot(int x){
	return son[fa[x]][0]!=x&&son[fa[x]][1]!=x;
}

bool locate(int x){
	return son[fa[x]][1]==x;	
}

void reverse(int x){
	swap(son[x][0],son[x][1]);
	tag[x]^=1;	
}

void update(int x){
	_max[x]=val[x];
	if(e[_max[son[x][0]]].c>e[_max[x]].c)_max[x]=_max[son[x][0]];
	if(e[_max[son[x][1]]].c>e[_max[x]].c)_max[x]=_max[son[x][1]];	
}

void pushdown(int x){
	if(tag[x]){
		if(son[x][0])reverse(son[x][0]);
		if(son[x][1])reverse(son[x][1]);
		tag[x]=0;
	}
}

void rotate(int x){
	int y=fa[x],z=fa[y],side=locate(x);
	fa[x]=z;
	if(!isroot(y))son[z][son[z][1]==y]=x;
	son[y][side]=son[x][side^1];
	if(son[x][side^1])fa[son[y][side]]=y;
	son[x][side^1]=y,fa[y]=x;
	update(y),update(x);	
}

void splay(int x){
	int y=x,top=0;
	st[++top]=y;
	while(!isroot(y))y=fa[y],st[++top]=y;
	while(top)pushdown(st[top--]);
	while(!isroot(x)){
		int y=fa[x];
		if(!isroot(y))rotate(locate(x)==locate(y)?y:x);
		rotate(x);	
	}
	update(x);
}	

void access(int x){
	for(int y=0;x;y=x,x=fa[x])
		splay(x),son[x][1]=y,update(x);	
}

void makeroot(int x){
	access(x),splay(x);
	reverse(x);	
}

int findroot(int x){
	access(x),splay(x);
	while(son[x][0])pushdown(x),x=son[x][0];
	splay(x);
	return x;
}

void split(int x,int y){
	makeroot(x);
	access(y),splay(y);	
}

void link(int x,int y){
	makeroot(x);
	fa[x]=y;	
}

void cut(int x,int y){
	split(x,y);
	fa[x]=son[y][0]=0;	
}

int main()
{
	read(n),read(m),read(q);
	Rep(i,1,m){
		read(e[i].x),read(e[i].y),read(e[i].c);
		if(e[i].x>e[i].y)swap(e[i].x,e[i].y);
	}	
	sort(e+1,e+m+1);
	Rep(i,1,m)mp[make_pair(e[i].x,e[i].y)]=i;
	Rep(i,1,q){
		read(qr[i].opt),read(qr[i].x),read(qr[i].y);
		if(qr[i].x>qr[i].y)swap(qr[i].x,qr[i].y);
		if(qr[i].opt==2){
			int _id=mp[make_pair(qr[i].x,qr[i].y)];//map映射
			qr[i].id=_id;
			vis[_id]=true;
		}
	}
	Rep(i,1,n+m)_max[i]=val[i]=(i<=n?0:(i-n));
	Rep(i,1,m){
		if(sum==n-1)break;
		int x=e[i].x,y=e[i].y;
		if(vis[i])continue;
		if(findroot(x)==findroot(y))continue;
		link(x,i+n),link(i+n,y);
		sum++;		
	}
	_Rep(i,q,1){
		int x=qr[i].x,y=qr[i].y;
		if(qr[i].opt==1)split(x,y),out[++cnt]=e[_max[y]].c;
		else{
			split(x,y);
			int _id=_max[y];
			if(e[qr[i].id].c>e[_id].c)continue;
			cut(e[_id].x,_id+n),cut(_id+n,e[_id].y);
			link(x,qr[i].id+n),link(y,qr[i].id+n);
		}
	}
	_Rep(i,cnt,1)printf("%d\n",out[i]);
	return 0;
}
```


---

## 作者：Adam_Ng (赞：2)

[P4172 [WC2006]水管局长](https://www.luogu.org/problemnew/show/P4172)

### Problem Abstract：
一张无向图中，求连接两点的一条路径使其中最大边权最小，支持动态删边。

### Ideas Outline：
1. MST（最小生成树）
2. 正难则反
3. 化边为点

### Process Details:
1.路径上最小的最大边权，因为MST是连通的，且Kruskal过程中加入的边都尽量小，所以显然它在当前的MST上。
所以我们只需要用LCT维护当前MST即可知道答案。

2.如果考虑删边，删掉当前MST内的边要去找MST外的可以构成连通的一条边，需要维护连接被断开的两部分的直接边，**我不会**。有没有这样的神仙算法，还请奆人们指点。

若反着来，考虑加边，则情况简单很多：若当前加入的这条边，比原来连接这两点的最大边权小，则cut掉该边，link当前加入的边。我们只需要在LCT上维护最大边的编号（用map之类的）。

3.在LCT上维护边权有几种方法，这里我们使用化边为点。这是维护边权的一种经典思路。

把一条边看成一个点加两条边，分别连着原先连着的两点。如下。

原来这个样

![](https://i.loli.net/2019/07/05/5d1f18407739d90717.jpg)

然后长这样

![](https://i.loli.net/2019/07/05/5d1f183eaf23861123.jpg)

这样我们就可以把边当成点来维护了，只需把点集开大m个即可。

代码如下

```cpp
#include<bits/stdc++.h>
#define mp make_pair
#define lc t[x][0]
#define rc t[x][1]
using namespace std;
const int N = 1005, M = 100005, Q = 100005, S = N + M;

int n, m, q, k;

struct Operation {
    int k, a, b, num;
}tmp;
vector<Operation> op; //储存输入数据
bool disconnected[M]; //操作2中是否被删除，用于建立初始MST

struct Edge {
    int s, t, dis;
}e[M];
inline bool cmp(Edge const& a, Edge const& b) {return a.dis < b.dis;} 
map<pair<int, int>, int> Map;
/////////////////////////////////////////
int val[S], fa[S], tag[S], t[S][2], ans[S];
inline bool nroot(int const& x) {return t[fa[x]][0] == x || t[fa[x]][1] == x;}
inline void pushup(int const& x) {
    ans[x] = val[x];
    if(e[ans[lc]].dis > e[ans[x]].dis) ans[x] = ans[lc];
    if(e[ans[rc]].dis > e[ans[x]].dis) ans[x] = ans[rc];
}
inline void pushdown(int const& x) {
    if(tag[x]) {
        if(lc) swap(t[lc][0], t[lc][1]), tag[lc] ^= 1;
        if(rc) swap(t[rc][0], t[rc][1]), tag[rc] ^= 1;
        tag[x] = 0;
    } return;
}
inline void rotate(int const& x) {
    int y = fa[x], z = fa[y], k = t[y][1] == x, c = t[x][!k];
    if(nroot(y))t[z][t[z][1] == y] = x;
    t[x][!k] = y; t[y][k] = c;
    if(c) fa[c] = y;
    fa[y] = x; fa[x] = z; 
    pushup(y), pushup(x);
    return;
}
void pushall(int const& x) {if(nroot(x)) pushall(fa[x]); pushdown(x);}
inline void splay(int const& x) {
    int y, z;
    pushall(x);
    while(nroot(x)) {
        y = fa[x], z = fa[y];
        if(nroot(y)) rotate((t[y][0] == x) ^ (t[z][0] == y) ? x : y);
        rotate(x);
    }
    pushup(x);
}
inline void access(int x) {for(int y = 0; x; x = fa[y = x]) splay(x), rc = y, pushup(x);}
inline void makeroot(int const& x) {access(x); splay(x); swap(lc, rc); tag[x] ^= 1;}
inline int findroot(int x) {access(x); splay(x); pushdown(x); while(lc) pushdown(x), x = lc; splay(x); return x;}
inline void split(int const& x, int const& y){makeroot(x); access(y); splay(y);}
inline void link(int const& x, int const& y) {makeroot(x); fa[x] = y;}
inline void cut(int const& x, int const& y) {split(x, y); fa[x] = t[y][0] = 0;}
void init(int const& x, int const& y) {
    fa[x] = lc = rc = tag[x] = 0;
    val[x] = ans[x] = y;
}
/////////////////////////////////////////
void Kruskal() {
    int cnt = 0;
    for(int i = 1; i <= m; ++i)
        if(!disconnected[i]) {
            if(cnt == n-1) break;
            if(findroot(e[i].s) == findroot(e[i].t)) continue;
            link(e[i].s, i + n), link(e[i].t, i + n);
            ++cnt;
        }
}

int main() {
    scanf("%d%d%d", &n, &m, &q);
    for(int i = 1; i <= m; ++i) {
        scanf("%d%d%d", &e[i].s, &e[i].t, &e[i].dis);
        if(e[i].s > e[i].t) swap(e[i].s, e[i].t);
    }
    sort(e + 1, e + 1 + m, cmp);
    for(int i = 1; i <= m; ++i) Map[mp(e[i].s, e[i].t)] = i;
    for(int i = 1; i <= q; ++i) {
        scanf("%d%d%d", &tmp.k, &tmp.a, &tmp.b);
        if(tmp.a > tmp.b) swap(tmp.a, tmp.b);
        if(tmp.k == 2) {
            tmp.num = Map[mp(tmp.a, tmp.b)]; disconnected[tmp.num] = 1;
        }
        else tmp.num = 0;
        op.push_back(tmp);
    }
    
    e[0].dis = 0;
    for(int i = 1; i <= n; ++i) init(i, 0);
    for(int i = n + 1; i <= n + m; ++i) init(i, i - n);
    //从n+1到n+m号的点就是从边转化过来的
    Kruskal();
    
    stack<int> prt;
    for(int i = q - 1, x, y; i >= 0; --i) {
        x = op[i].a, y = op[i].b; split(x, y);
        if(op[i].k == 1) prt.push(e[ans[y]].dis);
        else { 
            int num = op[i].num, replace = ans[y];
            if(e[num].dis < e[replace].dis) {
                cut(e[replace].s, replace + n); cut(replace + n, e[replace].t);
                link(x, num + n); link(num + n, y); //注意边化成点之后要断开两条边
            }
        }
    }
    while(!prt.empty()) printf("%d\n", prt.top()), prt.pop();
}
```



---

## 作者：Newuser (赞：2)

（貌似要省选了？似乎不关我这个蒟蒻的事，还是给OIers们加油吧！）
第一次学到了边转换为点的神奇操作。
由于要找路径上的最小的最长度（很绕自理解），还是很容易就想到最小生成树的。再由于想到维护最小生成树的时候删边还是很复杂的就想到这道题的删边离线倒着来做，将删边转换成加边来做就吼了。

但是权值全是在边上的，怎么来搞（只会点上的LCT）。。于是翻了题解，发现了神奇的操作—》将边转换成点来操作，边转成的点权值便是边权值，点编号为n+边编号。因此这样就搞定了存储问题。

考虑维护最小生成树，由于是倒着来考虑，因此在结尾是可以用kruskal或者prim来搞出一张最小生成树的图的，这里就直接link一下起点与边点然后link一下边点和终点就可以了。询问时也很简单，setroot(x),access(y),splay(y),return dat[mx[y]]就找到了路径上的最大路。

相对较复杂的是加边操作。不过由于这是一个最小生成树，所以加边（x,y）之后肯定会出现一个环的。而我们先找到这条路径(x,y)上的最大路，判断加的边权是否小于这个最大路，小于就先cut掉最大路，然后link(x,y)进去，否则就不管这个加边，就这样就始终用LCT维护好了一棵最小生成树。
```cpp
#include<bits/stdc++.h>
#define zig(x) zigzag(x,1)
#define zag(x) zigzag(x,2)
using namespace std;
int bingchafa[1005];
int gf(int x) { return bingchafa[x]==x?x:bingchafa[x]=gf(bingchafa[x]); }
struct edge
{
    int a,b,c;
} bian[200005];
int n,m,q; int bianid[1005][1005],bianxx[200005],bianyy[200005];
int bbian[1005][1005];
struct cz
{
    int k,a,b;
}caozuo[200005];
bool operator<(const edge &aa,const edge &bb)
{
    return aa.c<bb.c;
}
int rev[210005],ls[200005],rs[200005],fa[200005],dat[200005],mx[200005];
int ans[200005];
bool isroot(int x) { return rs[fa[x]]!=x&&ls[fa[x]]!=x; }
void putdowm(int x)
{
    if(!rev[x]) return ;
    swap(ls[x],rs[x]); rev[ls[x]]^=1; rev[rs[x]]^=1; rev[x]=0;
}
void putup(int x)
{
	mx[x]=x;
	if(dat[mx[ls[x]]]>dat[mx[x]]) mx[x]=mx[ls[x]];
	if(dat[mx[rs[x]]]>dat[mx[x]]) mx[x]=mx[rs[x]];
}
void zigzag(int x,int knd)
{
    int y=fa[x],z=fa[y];
    if(!isroot(y))
    {
        if(ls[z]==y) ls[z]=x;
        else rs[z]=x;
    }
    fa[x]=z; fa[y]=x;
    if(knd==1)
    {
        ls[y]=rs[x];
        fa[ls[y]]=y;
        rs[x]=y;
    }
    else 
    {
        rs[y]=ls[x];
        fa[rs[y]]=y;
        ls[x]=y;
    }
    putup(y); putup(x);
}
void putdowmall(int x)
{
    if(!isroot(x)) putdowmall(fa[x]);
    putdowm(x);
}
void splay(int x)
{
    int y,z; putdowmall(x);
    while(!isroot(x))
    {
        y=fa[x],z=fa[y];
        if(isroot(y))
        {
            if(ls[y]==x) zig(x);
            else zag(x);
        }
        else
        {
            if(ls[z]==y)
            {
                if(ls[y]==x) { zig(y); zig(x); }
                else { zag(x); zig(x); }
            }
            else
            {
                if(rs[y]==x) { zag(y); zag(x); }
                else { zig(x); zag(x); }
            }
        }
    }
}
void acc(int x)
{
    for(int y=0;x;y=x,x=fa[x])
    {
        splay(x);
        rs[x]=y;
        putup(x);
    }
}
void setroot(int x)
{
    acc(x); splay(x); rev[x]^=1;
}
void link(int x,int y)
{
    setroot(x); fa[x]=y;
}
void cut(int x,int y)
{
    setroot(x); acc(y); splay(y);
    ls[y]=fa[x]=0; putup(x); putup(y);
}
int main()
{
    scanf("%d%d%d",&n,&m,&q);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&bian[i].a,&bian[i].b,&bian[i].c); dat[i+n]=bian[i].c;
		bianid[bian[i].a][bian[i].b]=bianid[bian[i].b][bian[i].a]=i+n;
		dat[i+n]=bian[i].c; bianxx[i+n]=bian[i].a; bianyy[i+n]=bian[i].b;
    }
    for(int i=1;i<=q;i++)
    {
        scanf("%d%d%d",&caozuo[i].k,&caozuo[i].a,&caozuo[i].b);
        if(caozuo[i].k==2) { bbian[caozuo[i].a][caozuo[i].b]=bbian[caozuo[i].b][caozuo[i].a]=1; }
    }
    sort(bian+1,bian+1+m);
    int dian=n-1;
    int x,y;
    for(int i=1;i<=n;i++) bingchafa[i]=i;
    for(int i=1;i<=m;i++)
    {
        if(bbian[bian[i].a][bian[i].b]) continue;
        x=gf(bian[i].a); y=gf(bian[i].b);
        if(x==y) continue;
        bingchafa[x]=y;
        link(bian[i].a,bianid[bian[i].a][bian[i].b]); link(bian[i].b,bianid[bian[i].a][bian[i].b]);
        dian--;
        if(!dian) break;
    }
    for(int i=q;i>=1;i--)
    {
    	    x=caozuo[i].a;
			y=caozuo[i].b;
        if(caozuo[i].k==1)
        {
        	setroot(x); acc(y); splay(y);
        	ans[i]=dat[mx[y]];
        }
        else
        {
        	setroot(x); acc(y); splay(y);
        	int  idd=bianid[x][y];
        	if(dat[mx[y]]>dat[idd])
        	{
        		int z=mx[y];
        		cut(bianyy[z],z); cut(bianxx[z],z);
        		link(idd,x); link(idd,y);
        	}
        }
    }
    for(int  i=1;i<=q;i++)
    {
    	if(caozuo[i].k==1) printf("%d\n",ans[i]);
    }
} 
```
欢迎来[Newuser小站](https://www.newuser.top)逛逛！

---

## 作者：cirnovsky (赞：1)

SC 省 MY 市有着庞大的地下水管网络，嘟嘟是 MY 市的水管局长（就是管水管的啦），嘟嘟作为水管局长的工作就是：每天供水公司可能要将一定量的水从 $x$ 处送往 $y$ 处，嘟嘟需要为供水公司找到一条从 $A$ 至 $B$ 的水管的路径，接着通过信息化的控制中心通知路径上的水管进入准备送水状态，等到路径上每一条水管都准备好了，供水公司就可以开始送水了。嘟嘟一次只能处理一项送水任务，等到当前的送水任务完成了，才能处理下一项。

在处理每项送水任务之前，路径上的水管都要进行一系列的准备操作，如清洗、消毒等等。嘟嘟在控制中心一声令下，这些水管的准备操作同时开始，但由于各条管道的长度、内径不同，进行准备操作需要的时间可能不同。供水公司总是希望嘟嘟能找到这样一条送水路径，路径上的所有管道全都准备就绪所需要的时间尽量短。嘟嘟希望你能帮助他完成这样的一个选择路径的系统，以满足供水公司的要求。另外，由于 MY 市的水管年代久远，一些水管会不时出现故障导致不能使用，你的程序必须考虑到这一点。

不妨将 MY 市的水管网络看作一幅简单无向图（即没有自环或重边）：水管是图中的边，水管的连接处为图中的结点。

------

这道题只有删边操作，我们可以把这个过程看做是加边操作，这样好处理一点。

题目保证了图无论怎么删边都保证联通，所以我们可以先把图删完。删完后我们呢求出图的MST, 那么任意两点在这颗MST上走都是最优的~~别问我怎么证贪心是用来证的吗~~。我们可以用LCT来维护这颗MST，Splay维护区间最大值(也就是链上的最大值)

考虑加边操作。上面我提到了一个贪心：任意两点在这颗MST上走都是最优的。如果此时我们在MST上任意加一条边都会形成一个环。我们可以从任意一点入环，任意一点出环，方向随意。可以发现我们的最优解始终能避开最长的一条边！

考察这个环，用lct的split操作提出`链`的信息，查出最大的权值。发现我们可以通过删除权值最大的边来保证`环`上的最优。

怎么求出这条边呢？显然我们可以二分来找

再来考虑一个问题：如何维护边呢？

考虑用一个点来表示一条边。

最后`逆序`加边，把答案`逆序`输出即可

(~~良心题解~~)

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>
#include <stack>
#define mid ((l + r) >> 1)
#define mp make_pair
#define fir first
#define sec second
#define pub push_back
#define pob pop_back

using namespace std;
typedef long long LL;

#define io_e '\0'
#define io_s ' '
#define io_l '\n'
 #define _DEBUG_ 1 // debug toggle
namespace Fast_IO {
#ifndef _DEBUG_
	#define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++)
#else
	#define gc() getchar()
#endif
	const int SIZ = 1 << 21 | 1;
	char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c;
	int fr;
	inline void ioout() {
	    fwrite(obuff, 1, oS - obuff, stdout);
	    oS = obuff;
	}
	template <class Type>
	inline void read(Type& x) {
	    x = 0;
	    Type y = 1;
	    for (c = gc(); (c > '9' || c < '0') && c ^ '-'; c = gc())
	        ;
	    c == '-' ? y = -1 : x = (c & 15);
	    for (c = gc(); c >= '0' && c <= '9'; c = gc()) x = x * 10 + (c & 15);
	    x *= y;
	}
	inline bool blank(char ch) { return ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t'; }
	inline void read(char* s) {
	    register char ch = gc();
	    for (; blank(ch); ch = gc())
	        ;
	    for (; !blank(ch); ch = gc()) *s++ = ch;
	    *s = 0;
	}
	inline void read(char& c) {
	    for (c = gc(); blank(c); c = gc())
	        ;
	}
	template <typename Type, typename... Args>
	inline void read(Type& t, Args&... args) {
	    read(t), read(args...);
	}
	template <typename... Args>
	inline void read(char* t, Args&... args) {
	    read(t), read(args...);
	}
	template <typename... Args>
	inline void read(char& t, Args&... args) {
	    read(t), read(args...);
	}
	template <class Type>
	inline void write(char lastChar, Type x) {
	    if (x < 0)
	        *oS++ = '-', x = -x;
	    if (x == 0)
	        *oS++ = '0';
	    while (x) fu[++fr] = x % 10 + '0', x /= 10;
	    while (fr) *oS++ = fu[fr--];
	    *oS++ = lastChar;
	    ioout();
	}
	inline void write(char lastChar, char x[]) {
	    for (register int i = 0; x[i]; ++i) *oS++ = x[i];
	    *oS++ = lastChar;
	    ioout();
	}
	inline void write(char lastChar, char x) {
	    *oS++ = x;
	    *oS++ = lastChar;
	    ioout();
	}
	template <typename Type, typename... Args>
	inline void write(char midChar, Type t, Args... args) {
	    write(midChar, t), write(midChar, args...);
	}
}  // namespace Fast_IO

using Fast_IO::read;
using Fast_IO::write;

namespace LinkCutTree {
	const int SIZE = 12e4 + 5;
	struct SPLAY {
		int ch[2];
		int fa;
		int key;
		int maxValue;
		int lazyTag;
	} T[SIZE];
	stack < int > MemoryWaste; 
	#define ls T[x].ch[0]
	#define rs T[x].ch[1]
	#define WhichSon(x) (T[T[x].fa].ch[1] == x)
	#define IsRoot(x) (T[T[x].fa].ch[0] ^ x && T[T[x].fa].ch[1] ^ x)
	
	void UpdateMessage(int x) {
		T[x].maxValue = max(max(T[ls].maxValue, T[x].key), T[rs].maxValue);
	}
	
	void UpdateSons(int x) {
		if (T[x].lazyTag) {
			ls ^= rs ^= ls ^= rs;
			T[x].lazyTag = 0;
			T[ls].lazyTag ^= 1;
			T[rs].lazyTag ^= 1;
		}
	}
	
	void RotateNode(int x) {
		int y = T[x].fa;
		if (!IsRoot(y)) T[T[y].fa].ch[WhichSon(y)] = x;
		bool k = WhichSon(x);
		T[x].fa = T[y].fa;
		T[y].fa = x;
		T[y].ch[k] = T[x].ch[k ^ 1];
		T[T[y].ch[k]].fa = y;
		T[x].ch[k ^ 1] = y;
		UpdateMessage(y);
		UpdateMessage(x);
	}
	
	void LinkSplay(int x) {
		int u = x;
		while (!IsRoot(u)) MemoryWaste.push(u), u = T[u].fa;
		MemoryWaste.push(u);
		while (MemoryWaste.size()) UpdateSons(MemoryWaste.top()), MemoryWaste.pop();
		for (; !IsRoot(x); RotateNode(x)) {
			int y = T[x].fa;
			if (!IsRoot(y))
				RotateNode(WhichSon(x) ^ WhichSon(y) ? x : y);
		}
	}
	void AccessEdge(int x) {
		for (int u = x, y = 0; u; y = u, u = T[u].fa) {
			LinkSplay(u);
			T[u].ch[1] = y;
			UpdateMessage(u);
		}
	}
	
	void MakeRoot(int x) {
		AccessEdge(x);
		LinkSplay(x);
		T[x].lazyTag ^= 1;
	}
	
	void SplitTree(int x, int y) {
		MakeRoot(x);
		AccessEdge(y);
		LinkSplay(y);
	}
	
	void LinkTree(int x, int y) {
		MakeRoot(x);
		T[x].fa = y;
	}
	
	void CutTree(int x, int y) {
		MakeRoot(x);
		AccessEdge(y);
		LinkSplay(y);
		T[x].fa = T[y].ch[0] = 0;
	}
	
	int FindByKey(int x, int u) {
		if (T[x].key == u) return x;
		else if (T[ls].maxValue == u) return FindByKey(ls, u);
		else return FindByKey(rs, u);
	}
} // namespace LinkCutTree

using namespace LinkCutTree;

int F[1005][1005], U[101000], V[101000];
int OP[101000], ans[101000], n, m, QueryNumber;
struct EdgeNode {
	int x, y;
	int val, key;
	EdgeNode() { key = 1; }
	friend bool operator < (EdgeNode X, EdgeNode Y) {
		return X.val < Y.val;
	}
} e[101000];
struct UnionFindSet {
	int fa[1010];
	
	int find(int x) {
		if (x ^ fa[x]) fa[x] = find(fa[x]);
		return fa[x];
	}
	
	void merge(int x, int y) {
		int u = find(x), v = find(y);
		if (u ^ v) fa[u] = v;
	}
	
	void init(int n, int m) {
		for (int i = 1; i <= n; ++i)
			fa[i] = i;
		for (int i = 1; i <= m; ++i) {
			if (e[i].key && find(e[i].x) ^ find(e[i].y)) {
				merge(e[i].x, e[i].y);
				LinkTree(e[i].x, n + i);
				LinkTree(e[i].y, n + i);
			}
		}
	}
} ufs;

signed main() {
	read(n, m, QueryNumber);
	for (int i = 1; i <= m; ++i)
		read(e[i].x, e[i].y, e[i].val);
	sort(e + 1, e + 1 + m);
	for (int i = 1; i <= m; ++i) {
		F[e[i].x][e[i].y] = i;
		F[e[i].y][e[i].x] = i;
		T[n + i].key = e[i].val;
	}
	for (int i = 1; i <= QueryNumber; ++i) {
		read(OP[i], U[i], V[i]);
		if (OP[i] == 2) e[F[U[i]][V[i]]].key = 0;
	}
	ufs.init(n, m);
	int EdgeCount = 0;
	for (int i = QueryNumber; i >= 1; --i) {
		SplitTree(U[i], V[i]);
		if (OP[i] == 1) ans[++EdgeCount] = T[V[i]].maxValue;
		else {
			int Temporary = FindByKey(V[i], T[V[i]].maxValue);
			if (T[F[U[i]][V[i]] + n].key < T[V[i]].maxValue) {
				CutTree(e[Temporary - n].x, Temporary);
				CutTree(e[Temporary - n].y, Temporary);
				LinkTree(U[i], F[U[i]][V[i]] + n);
				LinkTree(V[i], F[U[i]][V[i]] + n);
			}	
		}
	}
	for (int i = EdgeCount; i >= 1; --i)
		write(io_l, ans[i]);
	return 0;
}
```

---

## 作者：C20203030 (赞：1)

## 一、题目
[点此看题](https://www.luogu.com.cn/problem/P4172)
## 二、解法
简述一下题意吧，本题就是给你$n$个点$m$条边，支持下面两种操作：
- 1、询问$(x,y)$所有路径上最大值的最小值。

- 2、去掉边$(x,y)$，保证边在给定的$m$条边中，并且图任何时候联通。

考虑询问，如果我们能维护一棵最小生成树，那么$(x,y)$在最小生成树上路径的最大值即是答案，但是本题需要删边，我们可以把删边逆序，就变成了加边，我们要做的就是动态维护这颗最小生成树。

这里我们使用$lct$，我们重新写一个最小生成树加边函数，如果边的两端不连通，直接加入；否则找到这条边构成的环上的最大值，和新加的这一条边作比较，如果新加的这条边大则不操作，否则我们删除环上的最大边之后再加上这条边，$lct$中维护最大边权和最大边权的编号即可。

还有一个问题，就是$lct$处理不了边，我们可以把边看成点，连接$(x,y)$就代表连接$(x,id),(id,y)$，$id$是边的编号，我们把边权放在这个点上。

据说本题还有一个数据加强版，蒟蒻的代码写的太丑了，过不了，代码仅供参考。
```cpp
#include <cstdio>
#include <iostream>
#include <map>
using namespace std;
const int Q = 100005;
const int M = 110005;
int read()
{
	int x=0,flag=1;char c;
	while((c=getchar())<'0' || c>'9') if(c=='-') flag=-1;
	while(c>='0' && c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*flag;
}
int n,m,q,a[M],b[M],c[M],op[Q],x[Q],y[Q],ans[Q];
int par[M],ch[M][2],val[M],Max[M],pos[M],fl[M],st[M];
map<int,int> mp,id;
int nrt(int x)
{
	return ch[par[x]][0]==x || ch[par[x]][1]==x;
}
int Hash(int a,int b)
{
    if(a>=b) swap(a,b);
    return 1ll*a*n+b;
}
int chk(int x)
{
	return ch[par[x]][1]==x;
}
void push_up(int x)
{
	if(!x) return ;
	Max[x]=max(val[x],max(Max[ch[x][0]],Max[ch[x][1]]));
	if(Max[x]==val[x]) pos[x]=x;
	else if(Max[x]==Max[ch[x][0]]) pos[x]=pos[ch[x][0]];
	else if(Max[x]==Max[ch[x][1]]) pos[x]=pos[ch[x][1]];
}
void flip(int x)
{
	if(!x) return ;
	swap(ch[x][0],ch[x][1]);
	fl[x]^=1;
}
void push_down(int x)
{
	if(!x) return ;
	if(fl[x])
	{
		flip(ch[x][0]);flip(ch[x][1]);
		fl[x]=0;
	}
}
void rotate(int x)
{
	int y=par[x],z=par[y],k=chk(x),w=ch[x][k^1];
	ch[y][k]=w;par[w]=y;
	if(nrt(y)) ch[z][chk(y)]=x;par[x]=z;
	ch[x][k^1]=y;par[y]=x;
	push_up(y);push_up(x);
}
void splay(int x)
{
	int y=x,z=0;
	st[++z]=y;
	while(nrt(y)) st[++z]=y=par[y];
	while(z) push_down(st[z--]);
	while(nrt(x))
	{
		int y=par[x],z=par[y];
		if(nrt(y))
		{
			if(chk(y)==chk(x)) rotate(y);
			else rotate(x);
		}
		rotate(x);
	}
}
void access(int x)
{
	for(int y=0;x;x=par[y=x])
		splay(x),ch[x][1]=y,push_up(x);
}
void makeroot(int x)
{
	access(x);splay(x);
	flip(x);
}
int findroot(int x)
{
	access(x);splay(x);
	while(ch[x][0]) push_down(x),x=ch[x][0];
	splay(x);
	return x;
}
void split(int x,int y)
{
	makeroot(x);
	access(y);splay(y);
}
void link(int x,int y)
{
	makeroot(x);
	if(findroot(y)!=x) par[x]=y;
}
void cut(int x,int y)
{
	makeroot(x);
	if(findroot(y)==x && par[y]==x && !ch[y][0])
	{
		par[y]=ch[x][1]=0;
		push_up(x);
	}
}
void add(int i)
{
    val[i+n]=c[i];push_up(i+n);
    if(findroot(a[i])^findroot(b[i]))
    {
        link(a[i],i+n);link(i+n,b[i]);
        return ;
    }
    split(a[i],b[i]);
    if(Max[b[i]]<=c[i]) return ;
    int t=pos[b[i]];
    cut(a[t-n],pos[t]);cut(pos[t],b[t-n]);
    link(a[i],i+n);link(i+n,b[i]);
}
int main()
{
    Max[0]=-(1<<30);
    n=read();m=read();q=read();
    for(int i=1;i<=m;i++)
    {
        a[i]=read();b[i]=read();c[i]=read();
        id[Hash(a[i],b[i])]=i;
    }
    for(int i=1;i<=q;i++)
    {
        op[i]=read();x[i]=read();y[i]=read();
        if(op[i]==2)
            mp[Hash(x[i],y[i])]=1;
    }
    for(int i=1;i<=m;i++)
        if(!mp[Hash(a[i],b[i])])
            add(i);
    for(int i=q;i>0;i--)
    {
        if(op[i]==1)
        {
            split(x[i],y[i]);
            ans[i]=Max[y[i]];
        }
        else
            add(id[Hash(x[i],y[i])]);
    }
    for(int i=1;i<=q;i++)
        if(op[i]==1)
            printf("%d\n",ans[i]);
}

```


---

## 作者：水库中的水库 (赞：1)

[博客食用更佳哦](http://ljf-cnyali.cn/2019/08/19/WC2006%E6%B0%B4%E7%AE%A1%E5%B1%80%E9%95%BF-LCT/)

题目要求询问从$u$到$v$的一条路径使得该路径上的最大值最小，同时会进行删边操作

考虑询问，这道题跟[NOIP2013货车运输](https://www.luogu.org/problem/P1967)特别像，显然答案是在这个图的最小生成树上的，答案就是最小生成树上$u$到$v$的路径最大值

考虑如何维护这个图的最小生成树，删边操作不好进行可以把询问反过来进行加边操作

LCT维护最大值和最大值的边的编号，对于一次加边$u,v,w$

-   如果$u,v$不连通，加上这条边
-   加上这条边会形成一个环，先$Split(u,v)$，如果$w>Tree[v].max$那么这条边一定不在最小生成树上，否则就把$Tree[v].max\_pos$删去，加上$u,v$这条边

```cpp
/***************************************************************
	File name: P4172.cpp
	Author: ljfcnyali
	Create time: 2019年08月19日 星期一 14时09分28秒
***************************************************************/
#include<bits/stdc++.h>

using namespace std;

#define REP(i, a, b) for ( int i = (a), _end_ = (b); i <= _end_; ++ i ) 
#define mem(a) memset ( (a), 0, sizeof ( a ) ) 
#define str(a) strlen ( a ) 
#define ls(x) Tree[x].son[0]
#define rs(x) Tree[x].son[1]
#define fa(x) Tree[x].fa
typedef long long LL;

const int maxn = 5000010;

struct node
{
    int son[2], lazy, fa, Max, id;
} Tree[maxn];

struct Node
{
    int u, v, w, opt;
} a[maxn];

int n, m, q, w[maxn], id[maxn], ans[maxn], cnt;
map<int, bool> Map;

inline bool IsRoot(int x) { return (ls(fa(x)) == x || rs(fa(x)) == x) ? false : true; }

inline void Update(int x) { Tree[x].lazy ^= 1; swap(ls(x), rs(x)); }

inline void PushUp(int x)
{
    Tree[x].Max = w[x]; Tree[x].id = x;
    if ( ls(x) && Tree[ls(x)].Max > Tree[x].Max ) Tree[x].Max = Tree[ls(x)].Max, Tree[x].id = Tree[ls(x)].id;
    if ( rs(x) && Tree[rs(x)].Max > Tree[x].Max ) Tree[x].Max = Tree[rs(x)].Max, Tree[x].id = Tree[rs(x)].id;
}

inline void PushDown(int x)
{
    if ( !Tree[x].lazy ) return ;
    Tree[x].lazy ^= 1;
    if ( ls(x) ) Update(ls(x)); if ( rs(x) ) Update(rs(x));
}

inline void Rotate(int x)
{
    int y = fa(x), z = fa(y), k = rs(y) == x, w = Tree[x].son[!k];
    if ( !IsRoot(y) ) Tree[z].son[rs(z) == y] = x;
    fa(x) = z; fa(y) = x; if ( w ) fa(w) = y;
    Tree[x].son[!k] = y; Tree[y].son[k] = w;
    PushUp(y);
}

inline void Splay(int x)
{
    stack<int> Stack; int y = x, z; Stack.push(y);
    while ( !IsRoot(y) ) Stack.push(y = fa(y));
    while ( !Stack.empty() ) { PushDown(Stack.top()); Stack.pop(); }
    while ( !IsRoot(x) ) 
    {
        y = fa(x); z = fa(y);
        if ( !IsRoot(y) ) Rotate((ls(y) == x) ^ (ls(z) == y) ? x : y);
        Rotate(x);
    }
    PushUp(x);
}

inline void Access(int root) { for ( int x = 0; root; x = root, root = fa(root) ) { Splay(root); rs(root) = x; PushUp(root); } }

inline void MakeRoot(int x) { Access(x); Splay(x); Update(x); }

inline int FindRoot(int x) { Access(x); Splay(x); while ( ls(x) ) x = ls(x); Splay(x); return x; }

inline void Link(int u, int v) { MakeRoot(u); if ( FindRoot(v) != u ) fa(u) = v; }

inline void Split(int u, int v) { MakeRoot(u); Access(v); Splay(v); }

inline bool Check(int u, int v) { MakeRoot(u); return FindRoot(v) == u; }

int main()
{
#ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif
    scanf("%d%d%d", &n, &m, &q);
    REP(i, 1, m) 
    {
        scanf("%d%d%d", &a[i].u, &a[i].v, &a[i].w);
        if ( a[i].u > a[i].v ) swap(a[i].u, a[i].v);
        id[a[i].u * n + a[i].v] = i;
        w[i + n] = a[i].w;
    }
    REP(i, m + 1, m + q) 
    {
        scanf("%d%d%d", &a[i].opt, &a[i].u, &a[i].v);
        if ( a[i].u > a[i].v ) swap(a[i].u, a[i].v);
        if ( a[i].opt == 2 ) Map[a[i].u * n + a[i].v] = true;
    }
    REP(i, 1, m)
    {
        if ( Map[a[i].u * n + a[i].v] == true ) continue ;
        if ( !Check(a[i].u, a[i].v) ) 
        {
            Link(a[i].u, i + n); 
            Link(i + n, a[i].v);
        }
        else
        {
            Split(a[i].u, a[i].v);
            if ( Tree[a[i].v].Max <= a[i].w ) continue ;
            int x = Tree[a[i].v].id; Splay(x); fa(ls(x)) = fa(rs(x)) = 0;
            Link(a[i].u, i + n); Link(i + n, a[i].v);
        }
    }
    for ( int i = q + m; i >= m + 1; -- i )
    {
        if ( a[i].opt == 1 ) 
        {
            Split(a[i].u, a[i].v);
            ans[++ cnt] = Tree[a[i].v].Max;
            continue ;
        }
        if ( !Check(a[i].u, a[i].v) ) { Link(a[i].u, i + n); Link(i + n, a[i].v); continue ; }
        int x = id[a[i].u * n + a[i].v];
        Split(a[i].u, a[i].v); if ( Tree[a[i].v].Max <= a[x].w ) continue ;
        int y = Tree[a[i].v].id; Splay(y); fa(ls(y)) = fa(rs(y)) = 0;
        Link(a[i].u, n + x); Link(n + x, a[i].v);
    }
    for ( int i = cnt; i >= 1; -- i ) printf("%d\n", ans[i]);
    return 0;
}
```



---

## 作者：撤云 (赞：1)

点击食用效果更加:[戳我](https://www.cnblogs.com/hbxblog/p/10728771.html)
### 题目链接

[戳我](https://www.luogu.org/recordnew/show/18312783)

### $Solution$

这道题实际上是维护一个最小生成树,因为正的搞不好搞，所以反着搞会比较好,现将没有没删掉的边留下来生成一颗最小生成树,再加边就好了，现在$LCT$

来看看怎么维护

对于一个最小生成树，加一条边后会是一个环，在环上删掉一个最大的边，还是一个最小生成树。所以我们对于加边只要判断这条边和最小生成树上最大边的大小，如果小于，则将这条边加入，原最小生成树上最大的边删除，如果大于不需要管他。

但是$LCT$只能维护点权，不能维护边权，不妨将这个边看成点即可

加入$(x,y)的边$就是$link(x,id),link(y,id),id$为这条边的编号
$cut$同理

### $Code$

``` cpp
#include<bits/stdc++.h>
#define rg register
#define file(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
using namespace std;
inline int read(){
    int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();
    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
    return f*x;
}
struct node {
    int fa,v,lazy,ch[2];
}a[1100001];
int v[1100001],pre[100001];
map<int,int> f[100001];
int vis[1000001];
inline bool nroot(int x){
    return a[a[x].fa].ch[0]==x||a[a[x].fa].ch[1]==x;
}
inline int max(int x,int y){
    return v[x]>v[y]?x:y;
}
inline void pushup(int x){
    a[x].v=max(a[a[x].ch[0]].v,max(a[a[x].ch[1]].v,x));
}
inline void work(int x){
    int t=a[x].ch[0];
    a[x].ch[0]=a[x].ch[1],a[x].ch[1]=t,a[x].lazy^=1;
}
inline void pushdown(int x){
    if(a[x].lazy)
        work(x),a[a[x].ch[0]].lazy^=1,a[a[x].ch[1]].lazy^=1;
}
inline void rotate(int x){
    int y=a[x].fa,z=a[y].fa,k=(a[y].ch[1]==x);
    if(nroot(y)) a[z].ch[a[z].ch[1]==y]=x;
    a[x].fa=z,a[y].ch[k]=a[x].ch[k^1],a[a[x].ch[k^1]].fa=y;
    a[x].ch[k^1]=y,a[y].fa=x;
    pushup(x),pushup(y);
}
inline void down(int x){
    if(nroot(x)) down(a[x].fa);
    pushdown(x);
}
inline void splay(int x){
    down(x);
    while(nroot(x)){
        int y=a[x].fa,z=a[y].fa;
        if(nroot(y))
            (a[y].ch[1]==x)^(a[z].ch[1]==y)?rotate(x):rotate(y);
        rotate(x);
    }
    pushup(x);
}
inline void access(int x){
    int y=0;
    while(x) splay(x),a[x].ch[1]=y,pushup(y=x),x=a[x].fa;
}
inline void makeroot(int x){
    access(x),splay(x),a[x].lazy^=1;
}
inline void splix(int x,int y){
    makeroot(x),access(y),splay(y);
}
inline int findroot(int x){
    access(x),splay(x);
    while(a[x].ch[0]) pushdown(x),x=a[x].ch[0];
    splay(x);
    return x;
}
inline void link(int x,int y){
    makeroot(x);
    if(findroot(y)!=x)
        a[x].fa=y;
}
inline void cut(int x,int y){
    makeroot(x);
    if(findroot(y)!=x||a[y].fa!=x||a[y].ch[0]) return ;
    a[y].fa=a[x].ch[1]=0,pushup(x);
}
struct node1{
    int x,y,z;
}b[1000001];
inline bool cmp(const node1 & a , const node1 & b ){
    return a.z<b.z;
}
inline int find(int x){
    return pre[x]==x?x:pre[x]=find(pre[x]);
}
int X[100001],Y[100001],opt[100001],n,m,q,ans[100001],tot;
inline void MST(){
    for(int i=1;i<=n;i++)
        pre[i]=i;
    for(int i=1;i<=m;i++){
        int fx=find(b[i].x),fy=find(b[i].y);
        if(!vis[i]&&fx!=fy)
            link(b[i].x,i+n),link(b[i].y,i+n),pre[fx]=fy;
    }
}
int main(){
    n=read(),m=read(),q=read();
    for(rg int i=1;i<=m;i++)
        b[i].x=read(),b[i].y=read(),b[i].z=read();
    sort(b+1,b+1+m,cmp);
    for(rg int i=1;i<=m;i++)
        f[b[i].x][b[i].y]=f[b[i].y][b[i].x]=i+n,v[i+n]=b[i].z;
    for(rg int i=1;i<=q;i++){
        opt[i]=read(),X[i]=read(),Y[i]=read();
        if(opt[i]==2) vis[f[X[i]][Y[i]]-n]=1;
    }
    MST();
    for(rg int i=q;i>=1;i--){
        splix(X[i],Y[i]);
        if(opt[i]==1)
            ans[++tot]=v[a[Y[i]].v];
        else{
            if(v[a[Y[i]].v]>v[f[X[i]][Y[i]]]){
                int x=a[Y[i]].v;
                cut(b[x-n].x,x),cut(b[x-n].y,x),link(X[i],f[X[i]][Y[i]]),link(Y[i],f[X[i]][Y[i]]);
            }
        }
    }
    for(rg int i=tot;i>=1;i--)
        printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：Ark_ (赞：1)

离线做,把删边转化为加边,用LCT维护最小生成树.那么如果加边的两个点不连通,直接连就行了.如果联通就找他们之间的瓶颈边,判断一下当前边是否更优,如果更优就cut掉瓶颈边,加上当前边.

那怎么维护瓶颈边呢?把边也看做点,向两个点分别连边,那么只用维护最大值就行了.维护的只维护编号,比较的时候就比较编号对应的边权,这样方便询问时删边.

~~虽然可能没有人像我这么zz错了这个地方,不过我还是想说一说: 注意储存 **边(u,v)或者断边(u,v)** 的时候,要把较小值设为u,较大值设为v.如果不这样的话在BZOJ上能A,但是在洛谷上会WA,因为BZOJ上的数据保证前面给出的边(u,v),在断边的时候给出的顺序仍然是(u,v).而洛谷上的官方数据给出的顺序可能是(v,u).~~

下面这个代码是加强版数据的范围,如果是洛谷的数据,只用N开1000,MAXN开2000,MAXM去掉一个0就行了.

# CODE
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long LL;
template<typename T>inline void read(T &num) {
	char ch; int flg = 1;
	while((ch=getchar())<'0'||ch>'9')if(ch=='-')flg=-flg;
	for(num=0;ch>='0'&&ch<='9';num=num*10+ch-'0',ch=getchar());
	num*=flg;
}
const int N = 100005;
const int MAXN = 200005;
const int MAXM = 1000005;
const int MAXQ = 100005;
int n, m, Q;
struct edge { int u, v, len, id; bool po; }E[MAXM];
struct Query { int op, x, y, id; }q[MAXQ];
namespace LCT {
	#define ls ch[x][0]
	#define rs ch[x][1]
	int ch[MAXN][2], fa[MAXN], mx[MAXN], w[MAXN], ID[MAXN];
	bool rev[MAXN];
	inline bool isr(int x) { return ch[fa[x]][0] != x && ch[fa[x]][1] != x; }
	inline bool get(int x) { return x == ch[fa[x]][1]; }
	inline void upd(int x) {
		mx[x] = x;
		if(ls && w[mx[ls]] > w[mx[x]]) mx[x] = mx[ls];
		if(rs && w[mx[rs]] > w[mx[x]]) mx[x] = mx[rs];
	}
	inline void rot(int x) {
		int y = fa[x], z = fa[y], l = get(x), r = l^1;
		if(!isr(y)) ch[z][get(y)] = x;
		fa[ch[x][r]] = y; fa[y] = x; fa[x] = z;
		ch[y][l] = ch[x][r]; ch[x][r] = y;
		upd(y), upd(x);
	}
	inline void mt(int x) { if(rev[x]) rev[x] ^= 1, rev[ls] ^= 1, rev[rs] ^= 1, swap(ls, rs); }
	void mtpath(int x) { if(!isr(x)) mtpath(fa[x]); mt(x); }
	inline void splay(int x) {
		mtpath(x);
		for(; !isr(x); rot(x))
			if(!isr(fa[x])) rot(get(x)==get(fa[x])?fa[x]:x);
	}
	inline int access(int x) { int y=0;
		for(; x; x=fa[y=x]) splay(x), ch[x][1]=y, upd(x);
		return y;
	}
	inline void bert(int x) { access(x), splay(x), rev[x] ^= 1; }
	inline int sert(int x) {
		access(x), splay(x);
		for(; ch[x][0]; x=ch[x][0]);
		return x;
	}
	inline void link(int x, int y) {
		bert(x);
		if(sert(y) == x) return;
		fa[x] = y;
	}
	inline void cut(int x, int y) {
		bert(x), access(y), splay(y);
		if(sert(y) != x || fa[x] != y || ch[x][1] != 0) return;
		fa[x] = ch[y][0] = 0; upd(y);
	}
	inline int split(int x, int y) {
		bert(x), access(y), splay(y);
		return y;
	}
	inline int query(int x, int y) {
		split(x, y);
		if(sert(y) != x) return -1;
		return mx[y];
	}
}
using namespace LCT;
inline bool cmp1(const edge &i, const edge &j) { return i.len < j.len; }
inline bool cmp2(const edge &i, const edge &j) { return i.u == j.u ? i.v < j.v : i.u < j.u; }
inline bool cmp3(const edge &i, const edge &j) { return i.id < j.id; }
int f[N], tot;
int find(int x) { return f[x] == x ? x : f[x] = find(f[x]); }
inline void Kruskal() {
	for(int i = 1; i <= n; ++i) f[i] = i;
	sort(E + 1, E + m + 1, cmp3);
	tot = 0;
	for(int i = 1; i <= m; ++i)
		if(!E[i].po) {
			int x = find(E[i].u), y = find(E[i].v);
			if(x != y) {
				f[x] = y, ++tot;
				mx[tot+n] = tot+n;
				w[tot+n] = E[i].len;
				ID[tot+n] = i;
				link(E[i].u, n+tot);
				link(E[i].v, n+tot);
				if(tot == n-1) return;
			}
		}
}
inline int pos(int U, int V) { //二分找编号
	int l = 1, r = m, mid;
	while(l < r) {
		mid = (l + r) >> 1;
		if(E[mid].u < U || (E[mid].u == U && E[mid].v < V)) l = mid + 1;
		else r = mid;
	}
	return l;
}
int ans[MAXQ];
int main () {
	read(n), read(m), read(Q);
	for(int i = 1; i <= m; ++i) {
		read(E[i].u), read(E[i].v), read(E[i].len);
		if(E[i].u > E[i].v) swap(E[i].u, E[i].v);
	}
	sort(E + 1, E + m + 1, cmp1);
	for(int i = 1; i <= m; ++i) E[i].id = i;
	sort(E + 1, E + m + 1, cmp2);
	for(int i = 1; i <= Q; ++i) {
		read(q[i].op), read(q[i].x), read(q[i].y);
		if(q[i].x > q[i].y) swap(q[i].x, q[i].y);
		if(q[i].op == 2) {
			int k = pos(q[i].x, q[i].y);
			q[i].id = E[k].id; E[k].po = 1; //po表示被破坏掉
		}
	}
	Kruskal();
	for(int i = Q; i >= 1; --i)
		if(q[i].op == 1) ans[i] = w[query(q[i].x, q[i].y)];
		else {
			int t = query(q[i].x, q[i].y);
			if(t == -1) { //不连通
				++tot;
				mx[n+tot] = n+tot; ID[n+tot] = q[i].id, w[n+tot] = E[q[i].id].len;
				link(q[i].x, n+tot), link(q[i].y, n+tot);
			}
			else if(w[t] > E[q[i].id].len) {
				cut(E[ID[t]].u, t), cut(E[ID[t]].v, t);
				mx[t] = t; ID[t] = q[i].id; w[t] = E[q[i].id].len; //回收使用t这个编号,这样LCT的点数可以只开2*n
				link(q[i].x, t), link(q[i].y, t);
			}
		}
	for(int i = 1; i <= Q; ++i)
		if(q[i].op == 1) printf("%d\n", ans[i]);
}
```

---

## 作者：bztMinamoto (赞：1)

更好的阅读体验请移步[我的blog](https://www.cnblogs.com/bztMinamoto/p/9339609.html)

学完这题才发现原来LCT还有这么多讲究orz……对着代码看了一下午才明白是怎么回事……

首先，这题在线显然不可做（在线A了的大佬请收下我的膝盖）

于是我们可以考虑离线做法，然后倒叙考虑，就可以把删边改为加边了

其次，我们考虑一下题目

使两点之间最大的边权最小

我们可以发现这就是一个最小生成树

于是先对着最后的图一通kruskal

然后倒序处理加边和询问即可

对于询问，直接在LCT上查询

加边就有点麻烦了，得分为三种情况

1.x和y不在同一联通块，直接加边

2.若在同一联通块但加的边的边权大于x到y的路径上的最大边权，跳过

3.否则删去x到y路径上的最大边，再加上这一条边

用并查集维护（或者直接LCT上findroot，但这样没并查集跑得快）

但是LCT只能维护点，怎么考虑边权呢？

我们把边转化为点考虑就好了。给每条边一个编号，要连边时将x和y分别与它所代表的的点相连

（ps：学到了一个很厉害的技巧，将边升序排序，找的时候就可以直接二分了）

```
//minamoto
#include<cstdio>
#include<algorithm>
#include<cctype>
#define N 1200100
using namespace std;
#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<15,stdin),p1==p2)?EOF:*p1++)
char buf[1<<15],*p1=buf,*p2=buf;
inline int read(){
    #define num ch-'0'
    char ch;bool flag=0;int res;
    while(!isdigit(ch=getc()))
    (ch=='-')&&(flag=true);
    for(res=num;isdigit(ch=getc());res=res*10+num);
    (flag)&&(res=-res);
    #undef num
    return res;
}
struct node{
    int from,to,len;
} e[N],E[N];
struct node1{
    int opt,x,y,ans;
}Q[N];
int n,m,k,now,cnt;
bool cmp1(node a,node b){return a.from<b.from||a.from==b.from&&a.to<b.to;}
bool cmp2(node a,node b){return a.len<b.len;}
int top,s[N],ch[N][2],fa[N],v[N],mxnum[N],f[N];bool rev[N],dam[N];
int ff(int x){return f[x]==x?x:(f[x]=ff(f[x]));}
void unite(int x,int y){x=ff(x),y=ff(y);f[x]=y;}
bool isroot(int x){return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x;}
void pushup(int x){
    if(v[x]>v[mxnum[ch[x][0]]]&&v[x]>v[mxnum[ch[x][1]]]) mxnum[x]=x;
    else if(v[mxnum[ch[x][0]]]>v[mxnum[ch[x][1]]]) mxnum[x]=mxnum[ch[x][0]];
    else mxnum[x]=mxnum[ch[x][1]];
}
void pushdown(int x){if(rev[x]&&x)swap(ch[x][0],ch[x][1]),rev[ch[x][0]]^=1,rev[ch[x][1]]^=1,rev[x]^=1;}
void rotate(int x){
    int y=fa[x],z=fa[y],d=(ch[y][1]==x);if(!isroot(y)) ch[z][ch[z][1]==y]=x;
    fa[x]=z,fa[y]=x;fa[ch[x][d^1]]=y,ch[y][d]=ch[x][d^1],ch[x][d^1]=y;pushup(y),pushup(x);
}
void splay(int x){
    s[top=1]=x;for(int i=x;!isroot(i);i=fa[i]) s[++top]=fa[i];for(int i=top;i>=1;--i) pushdown(s[i]);
    for(int y=fa[x],z=fa[y];!isroot(x);y=fa[x],z=fa[y]){
        if(!isroot(y)) ((ch[z][1]==y)^(ch[y][1]==x))?rotate(x):rotate(y);rotate(x);
    }
}
void access(int x){int t=0;while(x){splay(x),ch[x][1]=t,pushup(x),t=x,x=fa[x];}}
void makeroot(int x){access(x),splay(x),rev[x]^=1;}
int findroot(int x){access(x);splay(x);pushdown(x);while(ch[x][0]) pushdown(x=ch[x][0]);return x;}
int query(int x,int y){makeroot(x),access(y),splay(y);return v[mxnum[y]];}
void link(int x,int y){makeroot(x),access(y),splay(y);fa[x]=y;}
void cut(int x,int y){makeroot(x),access(y),splay(y);fa[x]=ch[y][0]=0;}
int getid(int u,int v){
    int l=1,r=m;
    while(l<=r){
        int mid=(l+r)>>1;
        if(e[mid].from==u&&e[mid].to==v) return mid+n;
        if(e[mid].from<u||e[mid].from==u&&e[mid].to<v) l=mid+1;
        else r=mid-1;
    }
}
void kruskal(){
    for(int i=1;i<=m;++i){
        int line=getid(E[i].from,E[i].to);
        if(!dam[line]&&ff(E[i].from)!=ff(E[i].to)){
            link(E[i].from,line),link(E[i].to,line);
            unite(E[i].from,E[i].to);
            if(++cnt==n-1) break;
        }
    }
}
void addline(int x,int y){
    if(ff(x)!=ff(y)){
        int line=getid(x,y);
        link(x,line),link(line,y);
        unite(x,y);
        return;
    }
    makeroot(x),access(y),splay(y);
    int cutline=mxnum[y],cutx=e[cutline-n].from,cuty=e[cutline-n].to;
    int line=getid(x,y);
    if(v[cutline]<v[line]) return;
    cut(cutx,cutline),cut(cutline,cuty);
    link(x,line),link(line,y);
}
int main(){
    //freopen("testdata.in","r",stdin);
    n=read(),m=read(),k=read();
    for(int i=1;i<=n;++i) f[i]=i;
    for(int i=1;i<=m;++i){
        e[i].from=read(),e[i].to=read(),e[i].len=read();
        if(e[i].from>e[i].to) swap(e[i].from,e[i].to);
        E[i]=e[i];
    }
    sort(e+1,e+m+1,cmp1);
    sort(E+1,E+m+1,cmp2);
    for(int i=1;i<=m;++i){
        v[e[i].from]=v[e[i].to]=-1;
        v[n+i]=e[i].len;
    }
    for(int i=1;i<=k;++i){
        Q[i].opt=read(),Q[i].x=read(),Q[i].y=read();
        if(Q[i].x>Q[i].y) swap(Q[i].x,Q[i].y);
        if(Q[i].opt==2) dam[getid(Q[i].x,Q[i].y)]=true;
    }
    kruskal();
    for(int i=k;i>=1;--i){
        if(Q[i].opt==1) Q[i].ans=query(Q[i].x,Q[i].y);
        else addline(Q[i].x,Q[i].y);
    }
    for(int i=1;i<=k;++i)
    if(Q[i].opt==1)
    printf("%d\n",Q[i].ans);
}
```

---

## 作者：wzj423 (赞：1)

于是各种连边、删边、换根操作就可以执行了，具体见代码。

然后我们来考虑这道题。

我们发现删边特别难处理，那么怎样转化一下呢？倒着处理所有询问，于是删边变成了加边。然后查询所有路径上最大值的最小值，不难发现就是要维护这个图的最小生成树，然后就可以直接查询树路径上的最大值了，也可以用lct做到。那么问题转化为了动态维护最小生成树。

我们此时已经将询问倒过来处理了，那么假设我们已经维护好了一棵mst，每加一条边u-v，肯定会形成一个环。因为是最小生成树，所以我们肯定要在环上去掉一条最大的边。于是处理加边操作流程如下：

查询u-v链上最大边权mx
比较新加的边权w和mx的大小关系，如果 w>mxw>mx ，则不做任何操作；否则删去边权为mx的边(cut)，加上u-v这条边(link)。
那么查询就直接查链上最大值即可。

至此，此题大致流程已经结束。

不过还有一些小问题：

在保存mx的时候需要存的是边的编号，因为到时加边的时候需要用到。
你发现lct似乎只能处理链上最大点权而无法保存边权。怎么办呢？我们可以考虑 把边看成点 ，加一条边u-v，编号为id，则 link(u, id); link(v, id); ；删边同理。
在处理询问的时候需要找到某条边的编号，可以开一个map记录边的编号。

```cpp
#include <bits/stdc++.h>
#define lc c[x][0]
#define rc c[x][1]
#define R register int
#define ll long long
#define Iter set<edge>::iterator
using namespace std;
const int MAXN=1e6+10;
struct LinkCutTree {
    int top,q[MAXN];
    int c[MAXN][2],fa[MAXN],rev[MAXN];
    int vv[MAXN],mx[MAXN];///最大点编号

    void pushup(R x) {
        mx[x]=x;
        if(vv[ mx[lc] ]>vv[ mx[x] ])    mx[x]=mx[lc];
        if(vv[ mx[rc] ]>vv[ mx[x] ])    mx[x]=mx[rc];
    }
    void pushdown(R x) {
        if(rev[x]) {
            rev[x]^=1,rev[lc]^=1,rev[rc]^=1;
            swap(lc,rc);
        }
    }
    bool isroot(R x) {
        return c[ fa[x] ][0]!=x && c[ fa[x] ][1]!=x;
    }
    void rotate(R x) {
        int y=fa[x],z=fa[y],l=c[y][1]==x,r=l^1;
        if(!isroot(y))
            c[z][ c[z][1]==y ] =x;
        fa[x]=z,fa[y]=x;

        fa[ c[x][r] ]=y;
        c[y][l]=c[x][r];

        c[x][r]=y;
        pushup(y),pushup(x);
    }
    void splay(R x) {
        top=1,q[top]=x;
        for(R i=x;!isroot(i);i=fa[i]) q[++top]=fa[i];
        for(R i=top;i;--i)    pushdown(q[i]);
        while(!isroot(x)) {
            R y=fa[x],z=fa[y];
            if(!isroot(y)) {
                if( (c[y][1]==x) == (c[z][1]==y) )  rotate(x);
                else    rotate(y);
            }
            rotate(x);
        }
    }
    void access(R x) {
        for(int t=0;x;t=x,x=fa[x])
                splay(x),c[x][1]=t,pushup(x);
    }
    void makeroot(R x) {
        access(x);
        splay(x);
        rev[x]^=1;
    }
    int find(R x) {
        access(x);
        splay(x);
        while(lc) x=lc;
        return x;
    }
    void link(R x,R y) {
        makeroot(x);
        fa[x]=y;
    }
    void split(R x,R y) {
        makeroot(x);
        access(y);
        splay(y);
    }
    void cut(R x,R y) {
        makeroot(x);
        if( find(y)!=x || fa[x]!=y || c[x][1] ) return;
        fa[x]=c[y][0]=0;
        pushup(y);
    }
    int query(R x,R y) {
        split(x,y);
        return mx[y];
    }
}T;
/// data================================================
int N,M,Q;
struct edge {
    int x,y,t;
    int id;
    bool disabled;
}E[MAXN];
bool operator < (edge a,edge b) {
    return make_pair(a.x,a.y)<make_pair(b.x,b.y);
}
bool cmp (edge a,edge b) {
    return a.t<b.t;
}
bool cmp_id(edge a,edge b) {
    return a.id<b.id;
}
struct query{
    int opt,x,y;
    edge e;
    int ans;
}ask[MAXN];
set<edge> S,rela;
///main ================================================
int main() {
    //freopen("tube.in","r",stdin);
    //freopen("tube.out","w",stdout);
    scanf("%d%d%d",&N,&M,&Q);
    for(int i=1;i<=M;++i) {
        scanf("%d%d%d",&E[i].x,&E[i].y,&E[i].t);
        E[i].id=i;
        T.vv[i+N]=E[i].t;
        if(E[i].x>E[i].y)   swap(E[i].x,E[i].y);
        S.insert(E[i]);
    }
    for(int i=1;i<=Q;++i) {
        scanf("%d%d%d",&ask[i].opt,&ask[i].x,&ask[i].y);
        if(ask[i].x>ask[i].y)   swap(ask[i].x,ask[i].y);
        if(ask[i].opt==2) {
            Iter it=S.find(edge{ask[i].x,ask[i].y,0,0,0});
            ask[i].e=*it;
            E[it->id].disabled=true;
        }
    }
    ///do the kruskal
    sort(E+1,E+M+1,cmp);
    for(int i=1;i<=M;++i) {
        int x=E[i].x,y=E[i].y,id=E[i].id;
        if(E[i].disabled) continue;
        if(T.find(x)!=T.find(y)) {
            T.link(x,id+N),T.link(id+N,y);
        }
    }
    ///cope query
    sort(E+1,E+M+1,cmp_id);
    for(int i=Q;i;--i) {
        if(ask[i].opt==1) {
            int pos=T.query(ask[i].x,ask[i].y);
            ask[i].ans=T.vv[pos];
        }
        else {
            int x=ask[i].e.x,y=ask[i].e.y,tm=ask[i].e.t,id=ask[i].e.id;
            int pos=T.query(ask[i].x,ask[i].y);
            if(tm<T.vv[pos]) {
                T.cut(pos,E[pos-N].x),T.cut(E[pos-N].y,pos);
                T.link(id+N,x),T.link(id+N,y);
            }
        }
    }
    for(int i=1;i<=Q;++i)
        if(ask[i].opt==1)
            printf("%d\n",ask[i].ans);
    return 0;
}

```

---


# 连环病原体

## 题目背景

###（一）洞穴

顺着狭窄倾斜的溶洞向下走，这里，真有一番地心探险的感觉呢。

告诉你啊，地底有一片广阔的大世界，叫做旧地狱。

那里居住着被地面上的人厌恶的妖怪们。

虽然听着比较吓人，但实际上在地狱废弃后，一切都是井井有条的。

前方有一片开阔的空间啊，好像有人。

"地面上的来客吗,你好啊"

终于遇到地底的居民了。

眼前的两只妖怪是黑谷山女和琪斯美。

琪斯美呆在一个小桶里，悬挂在空中，和山女讨论着什么。

"哇，你们在讨论什么啊"

"嗯，有关病毒的问题，你们不懂的"

忘记说了，山女可以操纵疾病，所以谈论这样的话题自然也就很平常了。

不过好奇心很难抵挡啊，那就假装自己能帮上忙，然后接着问下去吧。

"好吧，你们要是能帮上忙的话就再好不过了"

"嗯，主要是，想知道病原体之间的相互作用，会对疾病产生什么影响呢。你看啊，把不同种的病原体看做点，相互作用看成连接这些点的线，如果产生了环，那么病毒的威力就会大幅加强，我把它叫做加强环。"

"病原体之间的相互作用也有很多种呢，我想研究的是，每种相互作用在产生加强环的过程中有多么重要。"

啊，听起来好复杂，不过如果帮了她的忙，地底的妖怪们大概会对我们友善一些吧。

而且，点，边，环？这些名词似乎见过呢，说不定我真的能帮上忙？

那么，继续详细地询问吧。

嗯，问出来的信息已经记录在这张纸上了。


## 题目描述

问题摘要:

有n 种病原体，它们之间会产生$m$种无方向性的影响，第$i$种影响发生在$u_i$,$v_i$ **两种**病原体之间。

我们把所有的**影响**按编号顺序排成一个序列，如果某一个区间包含有环，那么这个区间被称作加强区间。

求每种影响分别在多少个加强区间中出现过。

那么，到底怎样做才能高效的得出结果呢？

(后续剧情见本题题解，接下来请看T2)

## 说明/提示

###样例解释：

第一种影响在[1,4]和[1,5]两个加强区间内出现

第二种影响在[1,4]、[1,5]和[2,5]三个加强区间内出现

第三种影响在[1,5]、[1,4]和[2,5]三个加强区间内出现

第四种影响在[1,4]、[2,5]和[1,5]三个加强区间内出现

第五种影响在[2,5]和[1,5]两个加强区间内出现

注意：加强区间是由“影响”构成的，而不是由“病原体”构成的

$n\leqslant2m\leqslant400000$

测试点1~2总分10分，$m\leqslant5$

测试点3~6总分20分，$m\leqslant200$

测试点7~12总分30分，$m\leqslant5000$

测试点13~15总分15分，$m\leqslant50000$

测试点16~18总分15分，$m\leqslant50000$，捆绑测试

测试点19~22总分10分，$m\leqslant200000$，捆绑测试

by oscar

## 样例 #1

### 输入

```
5
1 2
2 3
3 4
1 4
4 2
```

### 输出

```
2 3 3 3 2```

# 题解

## 作者：oscar (赞：35)

官方题解有剧情哦~

剧情版题解见最下面

可读题面：

一张n点m边无向图，每条边有编号

若一个区间内的边能连成一个环(cycle)，则称这个区间为好区间

求每条边分别在多少个好区间内

解法0：

我不会做！输出一堆0试试看

期望得分0分，实际得分5分

这个测试点是用来安慰正解写挂的同学们的

解法1：

我会DFS/并查集！

枚举每个区间，DFS判断有没有环，再更新区间内的边的答案

时间复杂度$O(n^2)$或$O(n^2 \alpha(n))$，期望得分60分，实际得分60分

解法2：

我会LCT！

固定区间的左端点，将区间的右端点向右移动，用LCT维护区间内是否有环，如果有环就把左端点向右移动直到没有环为止

用两次前缀和维护一下答案

时间复杂度$O(nlogn)$，期望得分100分，实际得分75~100分

FAQ：为什么我写了LCT却只得了75分/90分

A：因为findroot后要splay才能保证复杂度，不splay的都被我卡到$O(n^2)$啦！

-----------------------------------下面是剧情---------------------------------------

（二）连环病原体

其实，这个问题并不复杂呢。

我们把病原体看做点，影响看做边。

这些边按照编号排序，就形成了一个序列。

一个区间，就是这个序列中的某一段。

那么，对于所有的区间，我们把这些点和边画出来，看看有没有环就可以了，有环的话，说明区间内的每一条边的重要程度都要增加1。

把这个想法告诉山女吧。

"对哦，这样就可以了呢"，山女说道。

"不过先别急着走"

"你看，我这里有几万个病毒，它们之间的影响甚至有20 万种，那么区间的数量可能达到20 万的平方！这太多了吧！"

对哦，想一想，区间的左端点有m 种选择，右端点的选择数量也是m 这个级别的，那么区间的数量确实是m 的平方级别的，20 万的平方太可怕了。

哇，她居然懂这些，地底的妖怪果然不可小看呢。

不过，她没有意识到一点哦，我还得解释一下。

"其实，也没有这么多吧？"我说道。

"你看，如果我让左端点为1，右端点和左端点重合，然后右端点不断向右边推进，扩大这个区间。"

"每次遇到一条边，都加进这幅图里，直到产生了一个环为止。"

山女:"那又怎样呢？没看出少了哪啊"

"不，产生一个环之后，右端点就不需要再往右推进了，因为后面的区间肯定都是有环的。在只增加边的情况下，环是不会消失的！"

山女:"对哦，这样就省了很多功夫，但区间的数量还是平方级别的啊，有可能一直没遇到环，推到最后了呢。"

我:"然后，这里就是重点了。在遇到第一个环时，区间的右端点就不用继续推进了，只要记录下结果，然后左端点+1 就行。"

......

山女:"然后右端点回到左端点，继续加边，重复刚才的动作？"

我:"右端点不用回到左端点！只要继续推进就可以。因为左端点+1 后，少了一个边啊，

刚才没少边时，右端点之前的那一段边全加进去都没有出现环，少了一条边就更不可能有环了。"

......

山女:"嗯....妙啊，这样的话，左端点和右端点都只向右推进，而不回头，我要处理的区间数量就不再是m 平方级别，而是m 级别的了，是一个大的进步啊。"

......

山女:"但是，还有个问题"

"什么？"

山女:"怎样统计？这似乎是一个给很多段区间的值都+1 的问题，可以看成给一段区间增加一个每次递减1 的等差数列"

意料之外的事情出现了。

我的脑子突然一片空白，好像确实忽略了这个问题。

"哇，这个我也不会诶",我只好这么说。

山女:"好吧好吧，不会就算了，今天你帮我了一个大忙呢，你们先继续旅行吧，我请桥姬给你们带路"。

......

就这样，旅行还要继续下去。

水桥帕露西作为带路人加入了我们的旅行，她会把我们带到旧地狱的街市。

帕露西:"真嫉妒啊，你们说的话我完全听不懂"

我:"我也没想到呢，地底的妖怪的理解力这么强。"

帕露西:"她为了更好地研究疾病，去红魔馆的大图书馆借了各种方面的书，所以会懂那么多的吧。"

我:"可能吧"

帕露西:"对了，这些我听不懂的东西是关于哪个方面的"

我:"计算机程序，算法，数据结构"。

帕露西:"计算机？？？ 我在妖怪之山的河童那里听到过，不是只能记录东西，算算数学，玩玩游戏吗？"

我:"计算机很深奥的啦"

帕露西:"真是嫉妒，我一点都不懂"

（接t2）

---

## 作者：GKxx (赞：5)

题意大概是这样，有m条无向边按输入顺序标号，如果一段区间$[l,r]$上的无向边包含环就称区间$[l,r]$是“加强区间”，求每条边分别在多少个“加强区间”内。

设$ans[i]$表示第$i$条边在多少个加强区间内。我们可以换个视角：如果我们能找出所有“加强区间”，那么就只要给每个加强区间上的$ans$值都增加$1$就好了。

那么如何找出所有“加强区间”？我们有个老套路：枚举左端点，查询右端点。

然而当左端点固定的时候 右端点不止一个，真要把所有加强区间都找出来应该是不现实的（而且应该是$O(n^2)$的）

但是可以发现一个很好的性质：如果$[l,r]$是加强区间，那么对于所有$r\leq r'\leq m$，区间$[l,r']$都是加强区间。

于是可以考虑枚举左端点$l$，查找最小的右端点$r$，然后记录答案（一会再讲怎么记录）

但是很显然这个右端点没法很快地找出来，似乎还需要一个性质

我们发现：随着$l$的递增，最小的右端点$r$单调不减。

有了这个性质，我们就可以双指针辣！用lct来加边删边，时间复杂度$O(mlogn)$。

然后来说一说怎么得到答案。每次找到一个加强区间$[l,r]$的时候，意味着$[l,r], [l,r+1], [l,r+2], ..., [l,m]$都是加强区间，因此我们需要给$ans[l],ans[l+1],...,ans[r]$都加上$m-r+1$（即首项为$m-r+1$，公差为$0$的等差数列），然后给$[r+1,m]$加上一个首项为$m-r$，公差为$-1$的等差数列。

如果把等差数列差分，就会发现区间加等差的操作变成了区间加。线段树？当然不需要。因为如果把差分数列再差分（二阶差分），区间加就变成了单点加。（这里可以自己推一下）最终统计答案的时候可以先求出一阶差分再求出原数列，比较方便了。

~~（感觉话有点多）~~

```cpp
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>

template <typename T> inline void read(T& t) {
    int f = 0, c = getchar(); t = 0;
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) t = t * 10 + c - 48, c = getchar();
    if (f) t = -t;
}
template <typename T, typename... Args>
inline void read(T& t, Args&... args) {
    read(t); read(args...);
}

#ifdef WIN32
#define LLIO "%I64d"
#else
#define LLIO "%lld"
#endif	// WIN32 long long
#define rep(I, A, B) for (int I = (A); I <= (B); ++I)
#define rrep(I, A, B) for (int I = (A); I >= (B); --I)
#define erep(I, X) for (int I = head[X]; I; I = next[I])

const int maxn = 4e5 + 207;
int fa[maxn], ch[maxn][2];
bool rev[maxn];
int m;

inline int iden(int x) {
    if (ch[fa[x]][0] == x) return 0;
    if (ch[fa[x]][1] == x) return 1;
    return -1;
}
inline void rotate(int x) {
    if (!x) return;
    int d = iden(x), y = fa[x];
    if (~iden(y)) ch[fa[y]][iden(y)] = x;
    fa[x] = fa[y];
    if ((ch[y][d] = ch[x][d ^ 1]))
        fa[ch[x][d ^ 1]] = y;
    fa[ch[x][d ^ 1] = y] = x;
}
inline void pushdown(int x) {
    if (rev[x]) {
        rev[ch[x][0]] ^= 1;
        rev[ch[x][1]] ^= 1;
        rev[x] = 0; std::swap(ch[x][0], ch[x][1]);
    }
}
int s[maxn];
inline void splay(int x) {
    int t = 0;
    for (int i = x; ; i = fa[i]) {
        s[++t] = i;
        if (!~iden(i)) break;
    }
    while (t) pushdown(s[t--]);
    while (~iden(x)) {
        int y = fa[x];
        if (~iden(y)) rotate(iden(y) ^ iden(x) ? x : y);
        rotate(x);
    }
}
inline void access(int x) {
    for (int y = 0; x; x = fa[y = x])
        splay(x), ch[x][1] = y;
}
inline void makeroot(int x) {
    access(x); splay(x); rev[x] ^= 1;
}
inline void link(int x, int y) {
    makeroot(x); fa[x] = y;
}
inline void cut(int x, int y) {
    makeroot(x); access(y); splay(y);
    fa[x] = ch[y][0] = 0;
}
inline int findroot(int x) {
    access(x); splay(x);
    while (pushdown(x), ch[x][0]) x = ch[x][0];
    splay(x);
    return x;
}
inline bool connected(int x, int y) {
    return findroot(x) == findroot(y);
}

struct Edge {
    int x, y;
};
Edge e[maxn];
template <> inline void read<Edge>(Edge& ee) {
    read(ee.x, ee.y);
}

long long d2[maxn], d1[maxn], ans[maxn];
inline void add(int l, int r, int a1, int d) {
    if (l > r) return;
    d2[l] += a1;
    d2[l + 1] += d - a1;
    d2[r + 1] -= a1 + 1ll * (r - l + 1) * d;
    d2[r + 2] += a1 + 1ll * (r - l) * d;
}

int main() {
    read(m);
    rep(i, 1, m) read(e[i]);
    for (int l = 1, r = 0; l <= m; ++l) {
        bool found = 0;
        while (r < m) {
            ++r;
            if (connected(e[r].x, e[r].y)) {
                found = 1;
                break;
            }
            link(e[r].x, e[r].y);
        }
        if (found) {
            add(l, r, m - r + 1, 0);
            add(r + 1, m, m - r, -1);
            --r;
        } else break;
        cut(e[l].x, e[l].y);
    }
    rep(i, 1, m) d1[i] = d1[i - 1] + d2[i];
    rep(i, 1, m) ans[i] = ans[i - 1] + d1[i];
    rep(i, 1, m) printf(LLIO " ", ans[i]);
    puts("");
    return 0;
}
```

---

## 作者：Genius_Star (赞：5)

### 思路：

首先可以发现一个很明显的结论，如果 $[l,r]$ 是加强区间，则 $[l,r+1],[l,r+2],\cdots,[l,m]$ 都是加强区间。

那么考虑固定左端点 $l$，找到 $>l$ 的第一个 $r$ 满足 $[l,r]$ 是加强区间即可，因为 $r$ 肯定是单调不递减的，考虑走指针算法；如果当前没有环，则一直往右跳，这样至多走 $m$ 次。

对于判环问题，且支持动态加边减边，可以使用 LCT 维护。

但是题目要求的是每条边在加强区间出现的次数，所以考虑对于找到的 $[l,r]$ 区间是加强区间，且 $[l,r+1],[l,r+2],\cdots,[l,m]$ 都是加强区间，则 $[l,r]$ 范围内的边都会被覆盖 $m-r+1$ 次；

然后第 $r+1$ 条边被覆盖 $m-r$ 次，第 $r+2$ 条边被覆盖 $m-r-1$ 次，$\cdots$，第 $m$ 条边被覆盖一次，则区间 $[r+1,n]$ 相当于加上了一个首项为 $n-r$，公差为 $-1$ 的都等差序列。

上述等差序列加可以用二重差分 $O(1)$ 解决，具体实现看代码。

时间复杂度为 $O(M \log M)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
const ll N=200200;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,ans=0,l=1,r=0;
ll a[N],b[N],d1[N],d2[N];
void add(ll l,ll r,ll v,ll d){
	if(l>r)
	  return ;
    d2[l]+=v;
    d2[l+1]+=d-v;
    d2[r+1]-=v+(r-l+1)*d;
    d2[r+2]+=v+(r-l)*d;
}
struct Node{
	ll son[2];
	ll fa;
	ll tag;
}X[N];
class LCT{
public:
	ll notroot(ll k){
		return X[X[k].fa].son[0]==k||X[X[k].fa].son[1]==k;
	}
	void push_down(ll k){
		if(X[k].tag){
			swap(X[k].son[0],X[k].son[1]);
			X[X[k].son[0]].tag^=1ll;
			X[X[k].son[1]].tag^=1ll;
			X[k].tag=0;
		}
	}
	void push_all(ll k){
		if(notroot(k))
		  push_all(X[k].fa);
		push_down(k);
	}
	void rotate(ll x){
		ll y=X[x].fa,z=X[y].fa;
		bool f=X[y].son[1]==x;
		if(notroot(y))
		  X[z].son[X[z].son[1]==y]=x;
		X[x].fa=z;
		X[y].son[f]=X[x].son[f^1ll];
		X[X[x].son[f^1ll]].fa=y;
		X[x].son[f^1ll]=y;
		X[y].fa=x;
	}
	void splay(ll x){
		push_all(x);
		while(notroot(x)){
			ll y=X[x].fa,z=X[y].fa;
			if(notroot(y)){
				if((X[y].son[0]==x)^(X[z].son[0]==y))
				  rotate(x);
				else
				  rotate(y);
			}
			rotate(x);
		}
	}
	void access(ll x){
		ll y=0;
		while(x){
			splay(x);
			X[x].son[1]=y;
			y=x;
			x=X[x].fa;
		}
	}
	void makeroot(ll x){
		access(x);
		splay(x);
		X[x].tag^=1ll;
	}
	void split(ll x,ll y){
		makeroot(x);
		access(y);
		splay(y);
	}
	ll findroot(ll x){
		access(x);
		splay(x);
		while(X[x].son[0]){
			push_down(x);
			x=X[x].son[0];
		}
		splay(x);
		return x;
	}
	void link(ll x,ll y){
		makeroot(x);
		X[x].fa=y;
	}
	void cut(ll x,ll y){
		split(x,y);
		X[x].fa=X[y].son[0]=0;
	}
}T;
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
		b[i]=read();
	}
	for(int l=1;l<=n;l++){
		bool f=0;
		while(r<n){
			r++;
			if(T.findroot(a[r])==T.findroot(b[r])){
				f=1;
				break;
			}
			T.link(a[r],b[r]);
		}
		if(f){
            add(l,r,n-r+1,0);
            add(r+1,n,n-r,-1);
            --r;
		}
		else
		  break;
		T.cut(a[l],b[l]);
	}
	for(int i=1;i<=n;i++)
	  d1[i]=d1[i-1]+d2[i];
	for(int i=1;i<=n;i++){
		ans=ans+d1[i];
		write(ans);
		putchar(' ');
	}
	return 0;
}
```


---

## 作者：louhao088 (赞：3)

LCT 好题


------------

我们很容易发现如果一个区间 $[l,r]$  中有环，那么 $[l,r+1],[l,r+2]...[l,n]$ 必然有环。这样我们只要对于每个 $l$  ，只需找到最小的 $r$ 满足有环即可。

我们又发现这个 $r$ 对于每个 $l$ ，单调不减。这样我们可以直接用双指针维护。

这样问题就转换为，我们要支持的操作：加边，删边，判断是否有环，这个很显然可以用 LCT 维护。

考虑每个区间对答案产生的贡献，对于每个 $l$ 我们有 $[l,r],[l,r+1]...[l,n]$ 这么多区间对会答案有贡献。转化一下即为，对 $[l,r]$ 中每个点的贡献 $n-r+1$ ，对 $[r+1,n]$ 的贡献为一个公差为的等差数列。

对于 $[l,r]$  ，直接差分即可。对于 $[r+1,n]$ ，考虑这个等差数列比较特殊，因为如果某个位置 $x$ 要加的数必然是 $n-x+1$ ，所以也只要维护一个差分数组即可。 

时间复杂度 $O(n\log n)$ 



------------


注意 : findroot 函数用完一定要 Splay ，不然会被卡到 $n^2$ 。



------------

代码如下

```cpp
// Problem: P4230 连环病原体
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P4230
// Memory Limit: 125 MB
// Time Limit: 1000 ms
// 2022-03-25 20:47:12
// Author : louhao088
// 
// Powered by CP Editor (https://cpeditor.org)
#include<bits/stdc++.h>
using namespace std;
//static char buf[1000000],*p1=buf,*p2=buf;
//#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++
#define pi pair<int,int>
#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define ls c[x][0]
#define rs c[x][1]
#define mid (l+r>>1)
#define lowbit(x) (x&-x)
#define get(x) (c[fa[x]][1]==x)
#define isrt(x) (c[fa[x]][0]!=x&&c[fa[x]][1]!=x)
const int maxn=3e5+5,M=34005;
inline int read()
{
	char ch=getchar();bool f=0;int x=0;
	for(;!isdigit(ch);ch=getchar())if(ch=='-')f=1;
	for(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
	if(f==1)x=-x;return x;
}
inline void print(int x)
{
    static int a[55];int top=0;
    if(x<0) putchar('-'),x=-x;
    do{a[top++]=x%10,x/=10;}while(x);
    while(top) putchar(a[--top]+48);
}
int n,m,a[maxn],b[maxn],ans=1e9,f[maxn],u[maxn],v[maxn],s2[maxn];
long long sum[maxn];
int s[maxn],c[maxn][2],fa[maxn],r[maxn],st[maxn];
void pushup(int x){}
void pushx(int x){if(!x)return;r[x]^=1;swap(ls,rs);}
void push(int x){if(r[x]){pushx(ls),pushx(rs);r[x]=0;}}
void rotate(int x)
{
	int f1=fa[x],f2=fa[f1];int s1=get(x),s2=get(f1);int p=c[x][!s1];
	if(!isrt(f1))c[f2][s2]=x;fa[x]=f2;
	c[x][!s1]=f1;fa[f1]=x;
	c[f1][s1]=p;if(p)fa[p]=f1;pushup(f1);pushup(x);
}
void splay(int x)
{
	int y=x,top=0;st[++top]=x;
	while(!isrt(y))y=fa[y],st[++top]=y;
	while(top)push(st[top]),top--;
	while(!isrt(x))
	{
		if(!isrt(fa[x]))
			rotate((get(x)!=get(fa[x]))?x:fa[x]);
		rotate(x);
	}
}
void access(int x){for(int y=0;x;y=x,x=fa[x])splay(x),rs=y,pushup(x);}
void makert(int x){access(x);splay(x);pushx(x);}
int findrt(int x){access(x);splay(x);while(ls)push(x),x=ls;splay(x);return x;}
void split(int x,int y){makert(x);access(y);splay(y);}
void link(int x,int y){makert(x);fa[x]=y;}
void cut(int x,int y){split(x,y);c[y][get(x)]=0;fa[x]=0;pushup(y);}
bool check(int x,int y){makert(x);if(findrt(y)==x)return 1;return 0;}
void add(int l,int r){sum[l]+=(n-r+1);sum[r+1]-=(n-r+1);s2[r+1]++;}
signed main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	n=read();int l=1;
	for(int i=1;i<=n;i++)
	{
		u[i]=read(),v[i]=read();
		while(check(u[i],v[i]))add(l,i),cut(u[l],v[l]),l++;
		link(u[i],v[i]);
	}
	for(int i=1;i<=n;i++)
	{
		sum[i]=sum[i-1]+sum[i];s2[i]=s2[i-1]+s2[i];
		printf("%lld ",sum[i]+1ll*(n-i+1)*s2[i]);
	}
 	return 0;
}
```


---

## 作者：H_Kaguya (赞：1)

来点不用 LCT 的 $O(n \log^2 n)$ 做法。  
完整的思维链可以 [看这里](https://www.cnblogs.com/-Houraisan-Kaguya/p/18326161)。  

---
### baka's trick

（好像是叫这个，不知道为什么）  

第一步处理略过，我们现在需要对于每个左端点 $l$ 求一个最小的右端点 $r$ 使得 $[l, r]$ 成环。  
维护连通性可以考虑并查集。  
由于需要加边、删边，那就考虑可撤销并查集。  

现在的问题在于，可撤销并查集类似于栈（只能删除最后加入的边），而我们需要维护的结构类似队列（每次删除最先加入的边）  
也即，我们需要某种用栈来维护队列的算法。  

我们来考虑在序列上建立线段树，树上每个节点存储其管辖区间内的所有的边。  
对于一个区间 $[l, r]$，将其在线段树上划分为 $O(\log n)$ 个节点，然后按照深度**从浅到深**的顺序依次加入到并查集中。  
每当 $r$ 变大或者 $l$ 变小的时候，对发生变化的节点进行暴力维护。  
接下来我们来证明这个算法的复杂度。  

先只考虑插入的部分，由于线段树上的每个节点至多被 `push` 进来一次（$r$ 刚好与该节点的右端点重合） `pop` 出去一次（使用了这个节点的祖先节点）。  
删除部分同理。因此整个过程每个节点至多被操作 $O(1)$ 次。  
我们知道线段树上所有子树大小之和为 $O(n \log n)$，所以总时间 $O(n \log^2 n)$。  

不难发现这个算法与二进制分组等价。  
直接维护两套二进制分组 $A, B$，$A$ 删除 $B$ 插入，当 $A$ 为空时取 $B$ 中最大的段放入 $A$。  
常数比 LCT 小很多，所以跑得很快。  

贴代码~

```cpp
#include <vector>
#include <stdio.h>
#include <algorithm>
using namespace std;
const int B = 1 << 20;
char buf[B], *st, *ed;
inline char gc()
{
	if (st == ed)
	{
		ed = buf + fread(buf, 1, B, stdin);
		st = buf;
	}
	return *(st++);
}
namespace mset
{
	const int sz1 = 400005, sz2 = 200005;
	int fa[sz1], siz[sz1];
	int sta[sz2];

	void init(int n)
	{
		for (int i = 1; i <= n; ++i)
			fa[i] = i;
		for (int i = 1; i <= n; ++i)
			siz[i] = 1;
	}
	
	int find(int a)
	{
		while (a != fa[a])
			a = fa[fa[a]];
		return a;
	}

	void net(int a, int b)
	{
		a = find(a); b = find(b);
		if (siz[a] < siz[b])
			swap(a, b);
		sta[++sta[0]] = b;
		fa[b] = a; siz[a] += siz[b];
	}

	void bak(int a)
	{
		while (a --> 0)
		{
			int x = sta[sta[0]--];
			siz[fa[x]] -= siz[x];
			fa[x] = x;
		}
	}
}

namespace quegraph
{
	const int B = 19;
	const int sz = 200005;
	struct node
	{
		int a, b;
	};
	int now, ano;
	node tmp[sz];
	node *rt = tmp, *lf = rt - 1;

	void init(int n)
	{
		mset::init(n);
	}

	void reinsertr(int i)
	{
		for (int j = now & ~((1 << i + 1) - 1), k = j ^ 1 << i; j < k; ++j)
			mset::net(rt[j].a, rt[j].b);
	}

	void reinsertl(int i)
	{
		for (int j = ano & ~((1 << i + 1) - 1), k = j ^ 1 << i; j < k; ++j)
			mset::net(lf[-j].a, lf[-j].b);
	}

	void insert(int a, int b)
	{
		int x = __builtin_ctz(now + 1);
		int sum = (1 << x) - 1 + (ano & (1 << x) - 1);
		mset::bak(sum);
		rt[now].a = a; rt[now].b = b; ++now;
		reinsertr(x);
		for (int i = x - 1; i >= 0; --i)
			if (ano & 1 << i)
				reinsertl(i);
	}

	void del()
	{
		if (ano == 0)
		{
			int x = __lg(now), y = 1 << x;
			now ^= y; ano = y;
			rt += y; lf += y;
		}
		int sum = 0, x = __builtin_ctz(ano);
		sum = (1 << x) + (now & (1 << x + 1) - 1);
		mset::bak(sum); --ano;
		if (now & 1 << x)
			reinsertr(x);
		for (int i = x - 1; i >= 0; --i)
		{
			reinsertl(i);
			if (now & 1 << i)
				reinsertr(i);
		}
	}
}

const int sz = 200005;
struct edg
{
	int a, b;
};
edg num[sz];
int m;
long long ans[sz], ano[sz];
int read();
int main()
{
	m = read();
	quegraph::init(m * 2);
	for (int i = 1; i <= m; ++i)
	{
		num[i].a = read();
		num[i].b = read();
	}
	for (int l = 1, r = 1; l <= m; ++l)
	{
		while (r <= m && mset::find(num[r].a) != mset::find(num[r].b))
		{
			quegraph::insert(num[r].a, num[r].b);
			++r;
		}
		if (r > m)
			break;
		++ano[m]; --ano[r];
		long long tmp = (m - r + 1ll);
		ans[l] += tmp; ans[r + 1] -= tmp;
		quegraph::del();
	}
	for (int i = m; i; --i)
		ano[i] += ano[i + 1];
	for (int i = 1; i <= m; ++i)
	{
		ans[i] += ans[i - 1];
		printf ("%lld ", ans[i] + ano[i] * (m - i + 1));
	}
	return 0;
}

int read()
{
	int x = 0;
	char c = gc();
	while (c < '0') c = gc();
	do {
		x = x * 10 + (c & 15);
		c = gc();
	}while (c >= '0');
	return x;
}
```

---

## 作者：lhm_ (赞：0)

用双指针扫描来找环，加入 $r$ 位置的边后，若形成了环，就删去 $l$ 位置的边，直到环断掉，加边删边和判定连通性用 $LCT$ 维护即可。

考虑如何计算环的贡献，对于区间 $[l,r]$，若其形成了环，则区间 $[l,r+1],[l,r+2] \dots [l,m]$ 都形成了环。得最终的贡献为区间 $[l,r]$ 都加上 $m-r+1$，区间 $[r+1,m]$ 加上一个首项为 $m-r$，公差为 $-1$ 的等差数列。用线段树维护差分数列即可。

```cpp
#include<bits/stdc++.h>
#define maxn 200010
#define maxm 800010
#define ls (cur<<1)
#define rs (cur<<1|1)
#define mid ((l+r)>>1)
using namespace std;
typedef long long ll;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int m,root=1,pos=1;
int fa[maxn],ch[maxn][2],rev[maxn];
ll sum[maxm],add[maxm],ans[maxn];
struct edge
{
    int x,y;
}e[maxn];
void pushadd(int cur,int l,int r,ll v)
{
    sum[cur]+=v*(r-l+1),add[cur]+=v;
}
void pushdown(int cur,int l,int r)
{
    if(!add[cur]) return;
    pushadd(ls,l,mid,add[cur]),pushadd(rs,mid+1,r,add[cur]),add[cur]=0;
}
void modify(int L,int R,int l,int r,ll v,int cur)
{
    if(L>R) return;
    if(L<=l&&R>=r)
    {
        pushadd(cur,l,r,v);
        return;
    }
    pushdown(cur,l,r);
    if(L<=mid) modify(L,R,l,mid,v,ls);
    if(R>mid) modify(L,R,mid+1,r,v,rs);
    sum[cur]=sum[ls]+sum[rs];
}
void dfs(int l,int r,int cur)
{
    if(l==r)
    {
        ans[l]=sum[cur];
        return;
    }
    pushdown(cur,l,r);
    dfs(l,mid,ls),dfs(mid+1,r,rs);
}
bool check(int x)
{
    return ch[fa[x]][1]==x;
}
bool notroot(int x)
{
    return ch[fa[x]][0]==x||ch[fa[x]][1]==x;
}
void pushrev(int x)
{
    rev[x]^=1,swap(ch[x][0],ch[x][1]);
}
void spread(int x)
{
    if(!rev[x]) return;
    pushrev(ch[x][0]),pushrev(ch[x][1]),rev[x]=0;
}
void rotate(int x)
{
    int y=fa[x],z=fa[y],k=check(x),w=ch[x][k^1];
    if(notroot(y)) ch[z][check(y)]=x;
    ch[x][k^1]=y,ch[y][k]=w;
    if(w) fa[w]=y;
    fa[x]=z,fa[y]=x;
}
void all(int x)
{
    if(notroot(x)) all(fa[x]);
    spread(x);
}
void splay(int x)
{
    all(x);
    for(int y;notroot(x);rotate(x))
        if(notroot(y=fa[x]))
            rotate(check(x)^check(y)?x:y);
}
void access(int x)
{
    for(int y=0;x;y=x,x=fa[x]) splay(x),ch[x][1]=y;
}
void makeroot(int x)
{
    access(x),splay(x),pushrev(x);
}
void split(int x,int y)
{
    makeroot(x),access(y),splay(y);
}
int findroot(int x)
{
    access(x),splay(x);
    while(ch[x][0]) x=ch[x][0];
    splay(x);
    return x;
}
void link(int x,int y)
{
    split(x,y),fa[x]=y;
}
void cut(int x,int y)
{
    split(x,y),fa[x]=ch[y][0]=0;
}
int main()
{
    read(m);
    for(int i=1;i<=m;++i) read(e[i].x),read(e[i].y);
    for(int i=1;i<=m;++i)
    {
        int x=e[i].x,y=e[i].y;
        while(findroot(x)==findroot(y))
        {
            modify(pos,pos,1,m,m-i+1,root);
            modify(i+1,m,1,m,-1,root);
            cut(e[pos].x,e[pos].y),pos++;
        }
        link(x,y);
    }
    dfs(1,m,root);
    for(int i=1;i<=m;++i)
        ans[i]+=ans[i-1],printf("%lld ",ans[i]);
    return 0;
}
```

---

## 作者：AFO_WR_Eternity (赞：0)

# 题目大意
$n$个点，$m$条边，对每条边进行编号，若编号为$[l,r]$的区间内出现了环，则给每一条边的$val$加$1$，最后输出每条边的$val$。

# 大体思路
注意到：若$[l,r]$之间存在环，则区间$[l,r]$到区间$[l,m]$都包含有环。

再整理一下得到：

- 给区间$[l,r]$中的边，每条边的$val$都加上"$m-r+1$"

- 给区间$[r+1,m]$中的边，加上一个首相为"$m-r$"，公差为"$-1$"的等差数列。

这个显然可以用二维差分得到。

那么现在的问题就是：如何找到又环的区间？

很简单，我们可以用双指针，因为随着 $l$ 的增大，$r$ 必然不会减小。

# 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=400005;
struct edge{
	int u,v;
} e[N];
ll delta1[N],delta2[N];
int val[N],fa[N],rev[N],ch[N][2];
int m,q,opt;
int wh(int x){return ch[fa[x]][1]==x;}
bool isrt(int x){return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x;}
void rever(int x){rev[x]^=1,swap(ch[x][0],ch[x][1]);}
void pushdown(int x){
	if (rev[x]){
		if (ch[x][0]) rever(ch[x][0]);
		if (ch[x][1]) rever(ch[x][1]);
		rev[x]=0;
	}
}
void Allpushdown(int x){
	if (!isrt(x)) Allpushdown(fa[x]);
	pushdown(x);
}
void rotate(int x){
	int y=fa[x],z=fa[y],c=wh(x);
	if (!isrt(y)) ch[z][wh(y)]=x;
	fa[x]=z;
	ch[y][c]=ch[x][c^1];
	fa[ch[y][c]]=y;
	ch[x][c^1]=y;
	fa[y]=x;
}
void splay(int x){
	Allpushdown(x);
	for (;!isrt(x);rotate(x))
		if (!isrt(fa[x])) rotate(wh(fa[x])==wh(x)?fa[x]:x);
}
void access(int x){
	for (int y=0;x;y=x,x=fa[x]) splay(x),ch[x][1]=y;
}
void makert(int x){
	access(x),splay(x),rever(x);
}
int findrt(int x){
	access(x),splay(x);
	while (ch[x][0]) pushdown(x),x=ch[x][0]; 
	splay(x);
	return x;
}
void link(int x,int y){
	makert(x),fa[x]=y;
}
void cut(int x,int y){
	makert(x),access(y),splay(y);
	if (ch[y][0]!=x&&!ch[ch[y][0]][1]) return;
	fa[x]=ch[y][0]=0;
}
void query(int x,int y){
	makert(x),access(y),splay(y);
}
void solve(int l,int r,ll head,ll delta){
	if (l>r) return;
	delta1[l]+=head;
	delta1[r+1]+=-head;
	delta2[l+1]+=delta;
	delta2[r+1]+=-delta;
}
int main(){
	scanf("%d",&m);
	for (int i=1;i<=m;i++) scanf("%d%d",&e[i].u,&e[i].v);
	int r=1;
	for (int l=1;l<=m;l++){
		while (r<=m){
			int u=e[r].u,v=e[r].v;
			if (findrt(u)==findrt(v)){
				solve(l,r,m-r+1,0);
				solve(r+1,m,m-r,-1);
				break;
			} else link(u,v);
			++r;
		}
		cut(e[l].u,e[l].v);
	}
	ll x=0,y=0;
	for (int i=1;i<=m;i++){
		x+=delta1[i],y+=delta2[i],x+=y;
		printf("%lld ",x);
	}
	puts("");
	return 0;
}
```


---


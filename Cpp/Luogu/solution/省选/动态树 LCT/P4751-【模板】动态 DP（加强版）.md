# 【模板】动态 DP（加强版）

## 题目背景

树剖常数小！跑不满！

shadowice1984 为了向你证明他能卡树剖并且会卡树剖从而出了这道毒瘤题。

保证答案均在 `int` 范围内。

然后就被离线算法针对了……

因此这道题变成了强制在线。


## 题目描述

同 [P4719](https://www.luogu.com.cn/problem/P4719)。

给定一个 $n$ 个点的带点权树，进行 $m$ 次修改点权的操作。

你需要在每次修改之后输出树上最大带权独立集的权值之和。

## 说明/提示

数据范围 $n \leq 1 \times 10^6$，$m \leq 3 \times 10^6$。保证任意时刻各点点权的绝对值 $\leq 100$。

时限为标程的二倍，如果卡常数的话请使用 `int` 类型。

## 样例 #1

### 输入

```
10 10
-11 80 -99 -76 56 38 92 -51 -34 47
2 1
3 1
4 3
5 2
6 2
7 1
8 2
9 4
10 7
9 -44
184 -17
184 98
185 -58
153 48
190 99
296 -61
253 76
329 14
264 93
```

### 输出

```
186
186
190
145
189
288
244
320
258
304```

# 题解

## 作者：Wuyanru (赞：76)

前置芝士：[P4719](https://www.luogu.com.cn/problem/P4719)

~~众所周知，出题人为了卡离线算法和 $ O(n\log^2n) $ 的树剖出了这题。~~

看到现在的题解里面没有一个是树剖的 $ O(2^3\times n\log^2n) $ 做法，那么我就来写一篇题解教大家如何卡常吧。

首先我把我的 P4719 代码贴上来。

```
#include<cstdio>
namespace something_useful
{
	inline int max(int a,int b){ return a>b?a:b;}
	inline int read()
	{
		int s=0,w=1;char ch;
		while((ch=getchar())>'9'||ch<'0') if(ch=='-') w=-1;
		while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
		return s*w;
	}
	struct line
	{
		int nx;
		int to;
	};
	struct graph
	{
		int head[100001];
		line a[200001];
		int tot;
		void ad(int u,int v)
		{
			tot++;
			a[tot].to=v;
			a[tot].nx=head[u];
			head[u]=tot;
		}
		void add(int u,int v){ ad(u,v),ad(v,u);}
		int st(int num){ return head[num];}
		int to(int num){ return a[num].to;}
		int nx(int num){ return a[num].nx;}
	};
	struct mat
	{
		int a[3][3];
		int m,n;
		mat (){ a[1][1]=a[1][2]=a[2][1]=a[2][2]=0;}
		mat (int mm,int nn){ m=mm,n=nn,mat();}
		mat operator * (mat b)
		{
			mat ans;
			for(int i=1;i<=2;i++)
				for(int k=1;k<=2;k++)
				{
					int s=a[i][k];
					for(int j=1;j<=2;j++)
						ans.a[i][j]=max(ans.a[i][j],s+b.a[k][j]);
				}
			return ans;
		}
		void operator = (mat b)
		{
			for(int i=1;i<=2;i++)
				for(int j=1;j<=2;j++)
					a[i][j]=b.a[i][j];
		}
	};
}
using namespace something_useful;
int f[100001][2];
int hson[100001];
int siz[100001];
int dfn[100001];
int top[100001];
int end[100001];
int rk[100001];
int fa[100001];
mat t[400001];
mat g[100001];
int a[100001];
graph in;
int tot;
int n,m;
void read_all()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<n;i++) in.add(read(),read());
}
void dfs(int num)
{
	siz[num]=1;f[num][1]=a[num];
	for(int i=in.st(num);i;i=in.nx(i))
	{
		int p=in.to(i);
		if(p==fa[num]) continue;
		fa[p]=num;dfs(p);
		siz[num]+=siz[p];
		if(siz[p]>siz[hson[num]]) hson[num]=p;
		f[num][1]+=f[p][0],f[num][0]+=max(f[p][1],f[p][0]);
	}
}
void dfs(int num,int t)
{
	top[num]=t;
	dfn[num]=++tot;
	rk[tot]=num;
	end[t]=tot;
	if(hson[num]) dfs(hson[num],t);
	g[num].a[2][2]=-0x3f3f3f3f;g[num].a[2][1]=a[num];
	for(int i=in.st(num);i;i=in.nx(i))
	{
		int p=in.to(i);
		if(p==fa[num]||p==hson[num]) continue;
		dfs(p,p);
		g[num].a[1][1]+=max(f[p][0],f[p][1]);
		g[num].a[2][1]+=f[p][0];
	}
	g[num].a[1][2]=g[num].a[1][1];
}
void push_up(int p){ t[p]=t[p*2]*t[p*2|1];}
void build(int p,int pl,int pr)
{
	if(pl==pr)
	{
		t[p]=g[rk[pl]];
		return ;
	}
	int mid=(pl+pr)>>1;
	build(p*2,pl,mid);
	build(p*2|1,mid+1,pr);
	push_up(p);
}
void init()
{
	dfs(1);dfs(1,1);
	build(1,1,n);
}
mat get(int p,int pl,int pr,int l,int r)
{
	if(l<=pl&&pr<=r) return t[p];
	int mid=(pl+pr)>>1;
	if(mid<l) return get(p*2|1,mid+1,pr,l,r);
	if(r<=mid) return get(p*2,pl,mid,l,r);
	return get(p*2,pl,mid,l,r)*get(p*2|1,mid+1,pr,l,r);
}
void change(int p,int pl,int pr,int x)
{
	if(pl==pr){ t[p]=g[rk[x]];return ;}
	int mid=(pl+pr)>>1;
	if(x<=mid) change(p*2,pl,mid,x);
	else change(p*2|1,mid+1,pr,x);
	push_up(p);
}
void update(int pos,int val)
{
	g[pos].a[2][1]+=val-a[pos];
	a[pos]=val;
	while(pos)
	{
		mat last=get(1,1,n,dfn[top[pos]],end[top[pos]]);
		change(1,1,n,dfn[pos]);
		mat now=get(1,1,n,dfn[top[pos]],end[top[pos]]);
		pos=fa[top[pos]];
		g[pos].a[1][1]+=max(now.a[1][1],now.a[2][1])-max(last.a[1][1],last.a[2][1]);
		g[pos].a[1][2]=g[pos].a[1][1];
		g[pos].a[2][1]+=now.a[1][1]-last.a[1][1];
	}
}
void run()
{
	int pos=read(),val=read();
	update(pos,val);
	mat ans=get(1,1,n,1,end[1]);
	printf("%d\n",max(ans.a[1][1],ans.a[2][1]));
}
int main()
{
	read_all();
	init();
	for(int i=1;i<=m;i++) run();
	return 0;
}
```

前面的那个 namespace 是我的链式前向星模板和快读，大家可以不用管它。

下面我们来看哪里需要更改。

第一步：数组大小

原题的数据范围是 $ n\le 10^5 $，现在被改成了 $ n\le 10^6 $，对应的，我们的数组大小也要开大十倍。

注意：不要忘了线段树的大小要开到 $ 4\times 10^6 $。

第二步：强制在线

注意到这一题是强制在线的，所以我们在读入节点编号的时候要异或上一次的答案。

注意：
1.  只有节点编号要异或，修改的值是不用的；

2.  别忘了给 $ lastans $ 赋初值以及每次算完答案要赋值。

至此，我们的修改部分完成了。

提交之后，你有可能会发现 TLE 了（我挂了一个点）或者是 MLE。

当然，到这里大家可以选择第十个点暴力直接 A 题，但是本着学习新技巧而不是 A 题的态度，我们开始卡常。

因为比较简单，所以先讲一下 MLE 的解决方案。

第一步：矩阵数组

本题的矩阵是 $ 2\times2 $ 的，所以我们只需要把数组大小改成类似于 `a[2][2]` 就可以了，这样子与原来的 `a[3][3]` 对比，矩阵的空间会小到原来的一半。

第二步：存图

不知道有多少小伙伴用的是 vector，如果还是 MLE，可以考虑改成链式前向星，节省空间。

注意：如果你算过了你的空间确实不会炸，而且基本没有点 AC，那么**大概率**是写挂了，建议看一眼有没有无限递归。

先来我们来讲 TLE 解决方案。

第一步：读入

使用快读可以减少时间复杂度，大家应该都会，这里不细说。

第二步：矩阵乘法

本题的矩阵是 $ 2\times2 $ 的，所以我们可以不使用循环，直接将矩阵乘法展开，代码放到下面：

```
mat operator * (mat b)
{
	mat ans;
	ans.a[0][0]=max(a[0][0]+b.a[0][0],a[0][1]+b.a[1][0]);
	ans.a[1][0]=max(a[1][0]+b.a[0][0],a[1][1]+b.a[1][0]);
	ans.a[0][1]=max(a[0][0]+b.a[0][1],a[0][1]+b.a[1][1]);
	ans.a[1][1]=max(a[1][0]+b.a[0][1],a[1][1]+b.a[1][1]);
	return ans;
}
```

第三步：线段树

这是卡常卡的最多的一部分。

使用树剖的时候，时间复杂度的瓶颈在于对某个点权值修改的部分，现在我们对这部分进行卡常。

可以发现，我们在查询线段树的时候每次只会查找一个重链的矩阵之积，考虑对每一个重链单独开一个线段树，以减少常数。

有人可能会问：你这不就是一个水到极致，基本没用的常数优化吗，给你一条链不就相当于啥都没有。

真的是这样吗？我们来看一眼变化。

原来的代码：

```
void update(int pos,int val)
{
	g[pos].a[2][1]+=val-a[pos];
	a[pos]=val;
	while(pos)
	{
		mat last=get(1,1,n,dfn[top[pos]],end[top[pos]]);
		change(1,1,n,dfn[pos]);
		mat now=get(1,1,n,dfn[top[pos]],end[top[pos]]);
		pos=fa[top[pos]];
		g[pos].a[1][1]+=max(now.a[1][1],now.a[2][1])-max(last.a[1][1],last.a[2][1]);
		g[pos].a[1][2]=g[pos].a[1][1];
		g[pos].a[2][1]+=now.a[1][1]-last.a[1][1];
	}
}
```

更改过后的代码：

```
void update(int pos,int val)
{
	g[pos].a[1][0]+=val-a[pos];
	a[pos]=val;
	while(pos)
	{
		mat last=t[root[top[pos]]];
		change(root[top[pos]],dfn[top[pos]],end[top[pos]],dfn[pos]);
		mat now=t[root[top[pos]]];
		pos=fa[top[pos]];
		g[pos].a[0][0]+=max(now.a[0][0],now.a[1][0])-max(last.a[0][0],last.a[1][0]);
		g[pos].a[0][1]=g[pos].a[0][0];
		g[pos].a[1][0]+=now.a[0][0]-last.a[0][0];
	}
}
```

注意一下：你可能会发现修改的时候矩阵的位置不一样，这是因为我原来 MLE 过，然后把矩阵从 $ 3\times 3 $ 改成 $ 2\times 2 $ 了。

有什么变化呢？

没错！循环中少了两次函数的调用！

至此，我们的树剖已经可以通过这道题。

最后，给大家放上完整代码：

```
#include<cstdio>
namespace something_useful
{
	inline int max(int a,int b){ return a>b?a:b;}
	inline int read()
	{
		int s=0,w=1;char ch;
		while((ch=getchar())>'9'||ch<'0') if(ch=='-') w=-1;
		while(ch>='0'&&ch<='9') s=s*10+(ch^48),ch=getchar();
		return s*w;
	}
	struct line
	{
		int nx;
		int to;
	};
	struct graph
	{
		int head[1000001];
		line a[2000000];
		int tot;
		void ad(int u,int v)
		{
			tot++;
			a[tot].to=v;
			a[tot].nx=head[u];
			head[u]=tot;
		}
		void add(int u,int v){ ad(u,v),ad(v,u);}
		int st(int num){ return head[num];}
		int to(int num){ return a[num].to;}
		int nx(int num){ return a[num].nx;}
	};
	struct mat
	{
		int a[2][2];
		mat operator * (mat b)
		{
			mat ans;
			ans.a[0][0]=max(a[0][0]+b.a[0][0],a[0][1]+b.a[1][0]);
			ans.a[1][0]=max(a[1][0]+b.a[0][0],a[1][1]+b.a[1][0]);
			ans.a[0][1]=max(a[0][0]+b.a[0][1],a[0][1]+b.a[1][1]);
			ans.a[1][1]=max(a[1][0]+b.a[0][1],a[1][1]+b.a[1][1]);
			return ans;
		}
	};
}
using namespace something_useful;
int f[1000001][2];
int hson[1000001];
int root[1000001];
int siz[1000001];
int dfn[1000001];
int top[1000001];
int end[1000001];
int rk[1000001];
int fa[1000001];
int ls[4000001];
int rs[4000001];
mat t[4000001];
mat g[1000001];
int a[1000001];
graph in;
int last;
int tot;
int n,m;
int nod;
void read_all()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<n;i++) in.add(read(),read());
}
void dfs(int num)
{
	siz[num]=1;f[num][1]=a[num];
	for(int i=in.st(num);i;i=in.nx(i))
	{
		int p=in.to(i);
        if(p==fa[num]) continue;
    	fa[p]=num;dfs(p);
    	siz[num]+=siz[p];
    	if(siz[p]>siz[hson[num]]) hson[num]=p;
    	f[num][1]+=f[p][0],f[num][0]+=max(f[p][1],f[p][0]);
	}
}
void dfs(int num,int t)
{
	top[num]=t;
	dfn[num]=++tot;
	rk[tot]=num;
	end[t]=tot;
	if(hson[num]) dfs(hson[num],t);
	g[num].a[1][1]=-0x3f3f3f3f;g[num].a[1][0]=a[num];
	for(int i=in.st(num);i;i=in.nx(i))
	{
		int p=in.to(i);
        if(p==fa[num]||p==hson[num]) continue;
    	dfs(p,p);
    	g[num].a[0][0]+=max(f[p][0],f[p][1]);
    	g[num].a[1][0]+=f[p][0];
	}
	g[num].a[0][1]=g[num].a[0][0];
}
void push_up(int p){ t[p]=t[ls[p]]*t[rs[p]];}
void build(int &p,int pl,int pr)
{
	p=++nod;
	if(pl==pr)
	{
		t[p]=g[rk[pl]];
		return ;
	}
	int mid=(pl+pr)>>1;
	build(ls[p],pl,mid);
	build(rs[p],mid+1,pr);
	push_up(p);
}
void init()
{
	dfs(1);dfs(1,1);
	for(int i=1;i<=n;i++) if(top[i]==i) build(root[i],dfn[i],end[i]);
}
mat get(int p,int pl,int pr,int l,int r)
{
	if(l<=pl&&pr<=r) return t[p];
	int mid=(pl+pr)>>1;
	if(mid<l) return get(rs[p],mid+1,pr,l,r);
	if(r<=mid) return get(ls[p],pl,mid,l,r);
	return get(ls[p],pl,mid,l,r)*get(rs[p],mid+1,pr,l,r);
}
void change(int p,int pl,int pr,int x)
{
	if(pl==pr){ t[p]=g[rk[x]];return ;}
	int mid=(pl+pr)>>1;
	if(x<=mid) change(ls[p],pl,mid,x);
	else change(rs[p],mid+1,pr,x);
	push_up(p);
}
void update(int pos,int val)
{
	g[pos].a[1][0]+=val-a[pos];
	a[pos]=val;
	while(pos)
	{
		mat last=t[root[top[pos]]];
		change(root[top[pos]],dfn[top[pos]],end[top[pos]],dfn[pos]);
		mat now=t[root[top[pos]]];
		pos=fa[top[pos]];
		g[pos].a[0][0]+=max(now.a[0][0],now.a[1][0])-max(last.a[0][0],last.a[1][0]);
		g[pos].a[0][1]=g[pos].a[0][0];
		g[pos].a[1][0]+=now.a[0][0]-last.a[0][0];
	}
}
void run()
{
	int pos=read()^last,val=read();
	update(pos,val);
	mat ans=t[root[1]];
	printf("%d\n",last=max(ans.a[0][0],ans.a[1][0]));
}
int main()
{
	read_all();
	init();
	for(int i=1;i<=m;i++) run();
	return 0;
}
```

感谢观看！

---

## 作者：lingfunny (赞：19)

## 动态 dp 入门

给道入门题。

题目：DTOJ #4579. Hello 2019

一个串是好的，当且仅当其包含子序列 $9102$ 且不包含子序列 $8102$. (子序列不一定连续)

有个数字串 $S$，每次询问一个区间 $(l,r)$，求至少从串中删掉多少个字符，方能使子串 $S(l,r)$ 是好的。

$|S| \le 2\times 10^5$ | $q\le 2\times 10^5$。

题解：首先 reverse，然后记一个 $f_{i,0/1/2/3/4}$，表示恰好匹配 $0/1/2/3/4$ 个要删几个字符，然后用 $5\times 5$ 的矩阵转移，每次把 $[l,r]$ 内的矩阵乘起来。详细的建议自己推。

## 动态树分治入门

题目：洛谷 P4719 【模板】"动态 DP"&动态树分治

先写出一般最大权独立集式子：
$$
\begin{aligned}
f_{u,0} =& \sum_{v}\max(f_{v,0}, f_{v,1})\\
f_{u,1} =& w_u+\sum_{v} f_{v,0}
\end{aligned}
$$
其中 $f_{u,0/1}$ 表示 $u$ 不选/选的答案。

然后对于整棵树进行树剖，分开记重儿子和轻儿子的答案。

$g_{u,0}$：$u$ 的所有轻儿子全不选的总和加上 $w_u$。

$g_{u,1}$：$u$ 的所有轻儿子选或不选的最大值总和。

$f_{u,0}$：$u$ 不选的答案。

$f_{u,1}$：$u$ 选或不选的答案。

记 $v$ 为重儿子，有：
$$
\begin{aligned}
f_{u,0} =& f_{v,1} + g_{u, 1}\\
f_{u,1} =& \max(f_{v,1} + g_{u, 1}, f_{v,0} + g_{u,0})
\end{aligned}
$$
然后可以把 $f_u$、$g_u$ 和 $f_v$ 写成矩阵，要点是 $f_u$ 和 $f_v$ 长得一样，$g_u$ 只和 $u$ 有关：
$$
\begin{bmatrix}
f_{u, 0} & f_{u, 1}
\end{bmatrix}
=
\begin{bmatrix}
f_{v, 0} & f_{v,1}
\end{bmatrix}
\times
\begin{bmatrix}
-\infty & g_{u,0}\\
g_{u, 1} & g_{u,1}
\end{bmatrix}
$$
当然这里矩阵乘法的定义是 $(+, \max)$。

这样一个**节点**到**重链顶端**的答案就是 $\begin{bmatrix}0 & 0\end{bmatrix}$ 和这条链的叶结点从底到顶的一堆矩阵相乘。

此时如果修改一个节点，只需改的它的 $g_u$ 矩阵。

然后跑到重链顶端，求出新矩阵，对链顶父亲的 $g_u$ 修改一下，然后继续跑。

实现上需要注意矩阵是从链底端乘到链顶端，倒序。

似乎只需要线段树上 $\texttt{query}$ 的时候是右子树乘左子树即可。

几个要点：

1. 扩展 $f_{u,1}$ 的定义：$u$ 选的答案 $\to$ $u$ 选或不选的答案。
2. 把除重儿子外的东西打包到 $g_u$ 考虑。
3. 来自[P4719 最高赞题解](https://www.luogu.com.cn/blog/Tweetuzki/solution-p4179)：每条重链的链尾都是叶子节点，且只有叶子节点没有重儿子。这为动态规划的初始状态和转移方式做了保障。

[提交记录](https://www.luogu.com.cn/record/76042967)

## 全局平衡二叉树

全局平衡二叉树

lxl：**G**lobal **B**iased **T**ree（**GBT**）

Yang Zhe：**G**lobal **B**alanced **BST**（**GBBST**）

[洛谷 P4751 【模板】"动态DP"&动态树分治（加强版）](https://www.luogu.com.cn/problem/P4751)

数据范围已经不允许 $O(\log^2 n)$ 的做法了。

注意到上面那个做法的劣势在于：每次树剖查询的是若干条重链，而就算一条链的长度 $l=1$，单次查询重链复杂度都是 $O(\log n)$，因为是开一棵线段树维护所有节点的矩阵。总的合并复杂度就是 $O(\log^2 n)$。

考虑修改一下，对每条重链单独用一个形态不变的二叉树维护，网络上大部分博客都是非 leafy 结构，类似平衡树。但写成 leafy 的线段树也不会错。

> leafy 两倍常数 —— rsy

问题在于如果还是按照一般的线段树建树，每次找中点，$O(\log n)\sum O(\log l)$ 仍可以卡到 $O(\log^2 n)$。

考虑记：
$$
\mathrm{Lsize}(u)=1+\sum_{v\in \mathrm{LightSon}(u)} \mathrm{size}_v
$$
即所有轻儿子 $\mathrm{size}$ 之和加上自己。

这时候，如果在重链上按照 $\mathrm{Lsize}$ 为权值，找到带权中点，然后递归到左右建（平衡/线段）树来维护信息，均摊下来修改的复杂度就是 $O(\log n)$ 的。

为什么？不知道。难道你知道为什么 Splay 均摊是 $O(q\log n )$ 的吗？

详细证明可见 [Yang Zhe - QTREE 解法的一些研究](https://wenku.baidu.com/view/75906f160b4e767f5acfcedb)

[提交记录](https://www.luogu.com.cn/record/76069612)（无 IO 优化）

关于步骤：

1. 树链剖分。
2. 找出连接根节点的重链，对**这条重链**建立二叉搜索树，然后对连接这条重链的其他重链**递归**建立。
3. 一棵二叉搜索树根节点要维护这棵二叉树的**所有矩阵乘积**。
4. 修改 $a_u \gets x$：
   1. 找到 $u$ 所对应的平衡/线段树节点。
   2. 修改 $a_u$ 对应的矩阵。
   3. 暴力往上跳，每次都 push_up。
   4. 到根了，查看这棵平衡/线段树**所对应的重链**，找到链头的父亲，记作新的 $u$，没父亲就可以退出了。
   5. 回到步骤 4.2。

关于实现：

1. 上文有说是对每条重链依照带权中点二分建立一棵平衡树，**这样是对的**，但是有一些其他的实现方式。比如大部分博客会把轻儿子向父亲的平衡/线段树节点连一条**虚边**。
2. 所谓**虚边**：因为它父亲所在的重链自己构成了一棵二叉树，其父亲无法变成多叉树，指向轻儿子，但是轻儿子可以指向父亲。即**虚边**，有**认父不认子**的特点。推荐这样的实现方式，这样在修改的时候就可以从 $u$ 节点跳直接到顶，省去不少麻烦。详细见代码。

### Code

```cpp
// Problem: P4751 【模板】"动态DP"&动态树分治（加强版）
// From: Luogu
// URL: https://www.luogu.com.cn/problem/P4751
// Time: 2022-05-19 21:21
// Author: lingfunny

#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int mxn = 1e6+10, inf = 1e9;

int n, m, lst, a[mxn], rt, f[mxn][2], g[mxn][2];
vector <int> G[mxn];

struct mat {
	static const int V = 2;
	int a[V][V];
	mat(int a00 = 0, int a01 = -inf, int a10 = -inf, int a11 = 0) { a[0][0] = a00, a[0][1] = a01, a[1][0] = a10, a[1][1] = a11; }
	inline mat operator * (const mat &rhs) const {
		mat res;
		for(int i = 0; i < V; ++i) for(int j = 0; j < V; ++j) {
			res.a[i][j] = -inf;
			for(int k = 0; k < V; ++k) res.a[i][j] = max(res.a[i][j], a[i][k] + rhs.a[k][j]);
		}
		return res;
	}
	inline void show() {
		for(int i = 0; i < V; ++i) for(int j = 0; j < V; ++j) printf("%d%c", a[i][j], " \n"[j==V-1]);
	}
} gm[mxn];

struct node { int lc, rc, anc; mat u, s; } nd[mxn];
inline void psup(int u) {
	node &o = nd[u];
	o.s = nd[o.rc].s * o.u * nd[o.lc].s;	// 反着乘，原因见上文 P4719
}

int sz[mxn], lsz[mxn], dep[mxn], fa[mxn], son[mxn], top[mxn], End[mxn], dfn[mxn], mp[mxn], dfc;
// lsz[u]: Lsize[u]
// top/End: 重链顶/底
// mp: mp[dfn[u]] = u

void dfs(int u, int f) {
	lsz[u] = sz[u] = 1, dep[u] = dep[f] + 1, fa[u] = f;
	for(int v: G[u]) if(v != f) {
		dfs(v, u), sz[u] += sz[v];
		if(sz[v] > sz[son[u]]) son[u] = v;
	}
	lsz[u] = sz[u] - sz[son[u]];
}
void dfs2(int u) {
	End[u] = mp[dfn[u] = ++dfc] = u; g[u][0] = a[u];
	if(son[u]) top[son[u]] = top[u], dfs2(son[u]), End[u] = End[son[u]];
	for(int v: G[u]) if(v != fa[u] && v != son[u]) top[v] = v, dfs2(v), g[u][0] += f[v][0], g[u][1] += f[v][1];
	f[u][0] = f[son[u]][1] + g[u][1];
	f[u][1] = max(f[u][0], f[son[u]][0] + g[u][0]);
	gm[u] = mat(-inf, g[u][0], g[u][1], g[u][1]);
}

int sbuild(int L, int R) {
	if(L > R) return 0;
	LL sum = 0, qsum = 0;
	for(int i = L; i <= R; ++i) sum += lsz[mp[i]];
	for(int i = L, o; i <= R; ++i) {
		qsum += lsz[mp[i]];
		if(qsum * 2 > sum) {
			o = mp[i];
			node &u = nd[o];
			u.u = gm[o];
			u.lc = sbuild(L, i-1), nd[u.lc].anc = o;
			u.rc = sbuild(i+1, R), nd[u.rc].anc = o;
			psup(o);
			return o;
		}
	}
	return -114514;
}

int build(int Tp) {
	int Ed = End[Tp], X = sbuild(dfn[Tp], dfn[Ed]);
	for(int i = dfn[Tp]; i <= dfn[Ed]; ++i) {
		const int &u = mp[i];
		for(int v: G[u]) if(v != son[u] && v != fa[u]) nd[build(v)].anc = u;
	}
	return X;
}

inline void modify(int u, int x) {
	gm[u].a[0][1] += x - a[u]; a[u] = x;
	nd[u].u = gm[u];
	while(u) {
		int F = nd[u].anc;
		if(nd[F].lc != u && nd[F].rc != u && F) { // 如果当前节点到父亲的边是虚边
			mat bef = nd[u].s;
			psup(u);
			mat aft = nd[u].s;
			int _f0 = max(bef.a[0][0], bef.a[1][0]), _f1 = max(bef.a[0][1], bef.a[1][1]),
			f0 = max(aft.a[0][0], aft.a[1][0]), f1 = max(aft.a[0][1], aft.a[1][1]);
			mat &r = nd[F].u;
			r.a[0][1] += f0 - _f0;
			r.a[1][0] += f1 - _f1, r.a[1][1] += f1 - _f1;
			gm[F] = r;
		} else psup(u);
		u = F;
	}
}

signed main() {
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; ++i) scanf("%d", a+i);
	for(int i = 1, u, v; i < n; ++i) scanf("%d%d", &u, &v), G[u].push_back(v), G[v].push_back(u);
	dfs(1, 0), top[1] = 1, dfs2(1), rt  = build(1);
	while(m--) {
		int x, y; scanf("%d%d", &x, &y); x ^= lst;
		modify(x, y);
		printf("%d\n", lst=max(nd[rt].s.a[0][1], nd[rt].s.a[1][1]));
	}
	return 0;
}
```

~~我能水一篇题解吗~~

---

## 作者：2022tysc0776 (赞：13)

最近开始学习 **动态 DP**，如果有不对的地方请在讨论区指出，我当感激不尽。（如果已经会动态 DP 请去下面直接从 **全局平衡二叉树维护动态 DP** 开始看起）。

# 进入正题

本题需要一个科技 **动态 DP**，如果还不会的话，这里大概讲一下。

$f_{u,0/1}$ 表示第 $u$ 个点选与不选的 **子树最大权独立集**，转移方程如下。

$f_{u,0} = \sum \max(f_{v,0},f_{v,1})$

$f_{u,1} = \sum f_{v,0} + a_u $

然后我们考虑修改怎么做，你会发现其实他只会修改一条从修改点到根节点的 $f$ 值，但是如果暴力修改的话肯定会超时，时间复杂度 $O(nm)$。

然后，我们引入 **动态 DP**：

```
动态 DP 问题是猫锟在 WC2018 讲的黑科技，一般用来
解决树上的带有点权（边权）修改操作的 DP 问题。--- oiwiki
```

具体的，我们考虑将原树 **重链剖分**，计算出不含有 **重儿子** 的 $f$ 值为 $g$。

状态转移方程如下，

$f_{x,0}=g_{x,0}+\max(f_{son_x,1},f_{son_x,0})$

$f_{x,1}=g_{x,1}+f_{son_x,0}$

然后把这个方程用矩阵写出来，就是：


$$
\begin{bmatrix}f_{x,0}&f_{x,1}
\end{bmatrix}=
\begin{bmatrix}f_{son_x,0}&f_{son_x,1}
\end{bmatrix}
\begin{bmatrix}
g_{x,0} & g_{x,1} \\
g_{x,0} & -\infty \\
\end{bmatrix}
$$

额，怎么感觉这个矩阵乘法不太一样呢？哦，这是 **广义矩阵乘法**。

其实就是在原先的矩阵乘法上把计算符号组合从 $(+,\times)$ 改为了 $(\max,+)$。

代码如下：

```cpp
mat operator * (const mat &A)const{
		mat res=mat();
		for(int i=0;i<2;i++){
			for(int j=0;j<2;j++){
				for(int k=0;k<2;k++){
					res.a[i][j]=max(res.a[i][j],a[i][k]+A.a[k][j]);
				}
			}
		}
		return res;
	}
```

题外话：并不是所有的运算都能 **广义矩阵乘法** 运算，具体见 [此](https://www.cnblogs.com/luckyblock/p/14430820.html)。

然后你就能理解上面的矩阵乘法了，实际上就是转移式子。

这样的话，我们就可以在每一个点上面放一个含 $g$ 值的转移矩阵，特别的，我们需要特判叶子节点，在叶子上放一个初始矩阵（但是本题并不需要，因为你可以在叶子上 $g$ 和 $f$ 数组是一样的）。

修改的时候我们，相当于只需要修改每一个链头的父亲的 g 数组即可（因为只有那些点的 g 值受到了影响）。因为重链只有 $O(\log n)$，所以一次修改最多只会修改 $\log n$ 个点的矩阵。

然后如果想求一个点的 f 值，只需要求当前点到重链深度最高的点的矩阵乘积，取出对应位置的值即可。对于矩阵乘积，我们可以用 **树剖+线段树** 维护。

但是我们发现我们的初始矩阵在叶子上，所以相乘的时候顺序应该是从下到上的，但是当前的我们刚才推的矩阵顺序是初始矩阵在左，转移矩阵在右的，而矩阵乘法不具有交换律，正常线段树都是从左往右的算的，而 $dfs$ 序会导致是上面的数算的时候在左边，会出错，解决办法有两个：

1.最常见的是改变矩阵的位置，变成，

$$
\begin{bmatrix}
f_{x,0}
\\f_{x,1}
\end{bmatrix}=
\begin{bmatrix}
g_{x,0} & g_{x,0} \\
g_{x,1} & -\infty \\
\end{bmatrix}
\begin{bmatrix} f_{son_x,0}
\\f_{son_x,1}
\end{bmatrix}
$$

这样从左往右乘就是对的了，我用的就是这种办法。

2.直接在线段树中改变乘法的顺序，从右往左乘。（不过这个方法好像没什么人提到过，不确定行不行，所以 ~~狗头保命~~。

到这里其实就可以 AC [P4719](https://www.luogu.com.cn/problem/P4719) 了。

代码和其他人差不多，在这里不过多赘述。（不过如果是第一次接触这个内容的最好先做完上面的那道题再来看下面的东西。

时间复杂度 $O(2^3 n \log n^2)$。

但是这个时间复杂度过不了本题，所以我们考虑优化。但是矩阵这个 trick 好像扔不掉，那我们考虑有没有什么更快的方法处理矩阵的乘积。

## 正题：全局平衡二叉树维护动态 DP

首先我们要知道全局平衡二叉树（下面简称平衡树）是什么。

```
全局平衡二叉树实际上是一颗二叉树森林，
其中的每颗二叉树维护一条重链。
但是这个森林里的二叉树又互有联系，
其中每个二叉树的根连向这个重链链头的父亲，
就像 LCT 中一样。但全局平衡二叉树是
静态树，区别于 LCT，建成后树的形态不变。--oiwiki
```

平衡树将每一条重链转化成二叉树，由多条轻边相连，组成一个树高为 $O(\log n)$ 的树。这样就不用二叉树维护，直接求子树内乘积即可。

首先考虑如何建树，首先从一个点到根的轻链条数一定是 $\log n$ 级别的，所以我们只需要考虑如何构造重链的形态即可。

所以我们的构造方法就是把树链构造成一棵二叉树，具体操作过程就是把每一条重链剖出来，然后求加权中点（下面简称中点），以中点为根，继续处理左右两边，具体看代码：


```cpp
int cbuild(int ql,int qr){
	int l=ql,r=qr;
	while(l+1!=r){
		int mid=(l+r)>>1;
		if(((pre[mid]-pre[ql])<<1)<=pre[qr]-pre[ql]) l=mid;
		else r=mid;
	}//求中点
	int rt=b[l];tree[rt]=val[rt];
	if(l>ql) ls[rt]=cbuild(ql,l),fa[ls[rt]]=rt;
	if(l+1<qr) rs[rt]=cbuild(l+1,qr),fa[rs[rt]]=rt;//递归处理左右子树
	return rt;
}
int build(int x){
	int y=x;
	do{
		val[y].a[0][0]=val[y].a[0][1]=g[y][0];
		val[y].a[1][0]=g[y][1];val[y].a[1][1]=-INF;
		for(auto v:ed[y]){
			if(v==son[y]||v==fat[y]) continue;
			fa[build(v)]=y;//这里注意一下，不要写成 fa[v]=y;
		}
	}while(y=son[y]);//先处理重链旁的链
	do{
		b[y++]=x;pre[y]=pre[y-1]+siz[x]-siz[son[x]];
	}while(x=son[x]);把重链打出来
	return cbuild(0,y);
}
```

这里小证明一下，因为是求了中点，所以每往上面跳一次都会子树大小都会加倍，所以最多跳 $\log n$ 次就会子树大小都会变成 $n$。**所以总树高就是 $O(\log n)$ 的**。

然后剩下的就很简单了，每一个点维护子树矩阵乘积即可。

完整代码：（注释在下方）。

小拓展：平衡树的中序遍历就是原树链的序列。所以其实也可以求具体某一个点的值，只需要从当前点出发一直走到所在二叉树的根节点，乘上原树链在当前点的下面的点的矩阵（这个画个图就好理解了），可以尝试做一下 [洪水](https://www.luogu.com.cn/problem/P6021)。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int INF=1e9,N=1e6+10;
int n,m,a[N],fat[N],son[N],siz[N],fa[N],b[N],pre[N],ls[N],rs[N],f[N][2],g[N][2],lans;
vector<int> ed[N];
struct mat{
	int a[2][2];
	mat(){for(int i=0;i<2;i++) for(int j=0;j<2;j++) a[i][j]=-INF;}
	mat operator * (const mat &A)const{
		mat res=mat();
		for(int i=0;i<2;i++){
			for(int j=0;j<2;j++){
				for(int k=0;k<2;k++){
					res.a[i][j]=max(res.a[i][j],a[i][k]+A.a[k][j]);
				}
			}
		}
		return res;
	}
}val[N],tree[N];//tree[x] 表示子树的矩阵乘积
void dfs(int x,int fa){
	f[x][1]=g[x][1]=a[x];
	fat[x]=fa;siz[x]=1;
	for(auto v:ed[x]){
		if(v==fa) continue;
		dfs(v,x);
		siz[x]+=siz[v];
		if(siz[v]>siz[son[x]]){
			g[x][1]+=f[son[x]][0];
			g[x][0]+=max(f[son[x]][1],f[son[x]][0]);
			son[x]=v;
		}else{
			g[x][1]+=f[v][0];
			g[x][0]+=max(f[v][1],f[v][0]);
		}
		f[x][1]+=f[v][0];
		f[x][0]+=max(f[v][1],f[v][0]);
	}
}
int cbuild(int ql,int qr){
	int l=ql,r=qr;
	while(l+1!=r){
		int mid=(l+r)>>1;
		if(((pre[mid]-pre[ql])<<1)<=pre[qr]-pre[ql]) l=mid;
		else r=mid;
	}
	int rt=b[l];tree[rt]=val[rt];
	if(l>ql) ls[rt]=cbuild(ql,l),fa[ls[rt]]=rt,tree[rt]=tree[ls[rt]]*tree[rt];//注意顺序，应该是先左子树到根最后右子树
	if(l+1<qr) rs[rt]=cbuild(l+1,qr),fa[rs[rt]]=rt,tree[rt]=tree[rt]*tree[rs[rt]];//因为在链上是从深度低的点往深度高的点
	return rt;
}
int build(int x){
	int y=x;
	do{
		val[y].a[0][0]=val[y].a[0][1]=g[y][0];
		val[y].a[1][0]=g[y][1];val[y].a[1][1]=-INF;
		for(auto v:ed[y]){
			if(v==son[y]||v==fat[y]) continue;
			fa[build(v)]=y;
		}
	}while(y=son[y]);
	do{
		b[y++]=x;pre[y]=pre[y-1]+siz[x]-siz[son[x]];
	}while(x=son[x]);
	return cbuild(0,y);
}
void change(int x,int y){
	g[x][1]+=y-a[x];
	a[x]=y;
	val[x].a[1][0]=g[x][1];
	while(x){
		mat pre=tree[x];
		tree[x]=val[x];
		if(ls[x]) tree[x]=tree[ls[x]]*tree[x];
		if(rs[x]) tree[x]=tree[x]*tree[rs[x]];
		if(ls[fa[x]]!=x&&rs[fa[x]]!=x){
			g[fa[x]][0]+=max(tree[x].a[0][0],tree[x].a[1][0])-max(pre.a[0][0],pre.a[1][0]);
			g[fa[x]][1]+=tree[x].a[0][0]-pre.a[0][0];
			val[fa[x]].a[0][0]=val[fa[x]].a[0][1]=g[fa[x]][0];
			val[fa[x]].a[1][0]=g[fa[x]][1];
		}
		x=fa[x];
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<n;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		ed[x].push_back(y);
		ed[y].push_back(x);
	}
	dfs(1,0);
	int Root=build(1);
	while(m--){
		int x,y;
		scanf("%d%d",&x,&y);
		x^=lans;
		change(x,y);
		lans=max(tree[Root].a[0][0],tree[Root].a[1][0]);
		printf("%d\n",lans);
	}
	return 0;
}
```

---

## 作者：流水行船CCD (赞：12)

不知道为什么现在很多人觉得 Top Tree 很恶心？其实静态版本的它是很有优势的（动态的 SATT 常数太大了，不实用），尤其是在于维护信息不可减的时候。

## 静态 Top Tree 的优势

- 单 $\log$ 复杂度。
- 不需要额外用数据结构维护一个点轻儿子（虚儿子）的信息，以支持快速修改。
- 码量和全局平衡二叉树相当。
- 面对边权问题比其他做法更得心应手。

## 树收缩操作 & 树簇

Top Tree 的核心是两种树收缩操作：`Rake` 和 `Compess`。其中 `Compess` 将一个度数为 $2$ 的点的两条边合并，`Rake` 将一个度数为 $1$ 的点的边和另一条相邻边合并。给一张陈年老图：

![](https://img.uoj.ac/user/negiizhao/basic.png)

这两种操作每次可以把两条边合成一条边，考虑进行若干次操作后一条边在原树中对应了什么：不难发现这一条边一定由原树中的一个边联通块合并而来，而且这个边连通块只有两个点与联通块外的点联通，我们称这一个连通块为一个**簇**，而两个与外界联通的端点为这个簇的上/下界点，这两个端点的路径构成了该簇的**簇路径**。下图给出了一个簇的形态，这个簇的端点是 $u,z$。

![](https://img.uoj.ac/user/negiizhao/sample0.png)

下图则给出了合并过程中的一条边 $(A,D)$ 所对应的簇形态：

![](https://cdn.luogu.com.cn/upload/image_hosting/vflxv32o.png)

类似的，我们发现原树中的每一条边就是一个两点一边的簇，我们称这 $n-1$ 个簇为**基簇**。

## Top Tree

注意：不同“品种”的 Top Tree 在结构上略有差异，如 SATT 是一颗三叉树，拥有左中右三个儿子，但底层思想都是用树去描述树收缩过程。

发现每次 `Compess/Rake` 都会合并两个拥有一个公共点的簇（`Rake` 为上界点公共，`Compess` 为一个簇上界点与另一个簇的下界点公共），我们考虑将这个合并过程用一颗二叉树来表示，这个树的每一个叶子代表一个基簇，一个结点的两个儿子就表示这个当且结点对应的簇是由这两个儿子对应的簇合并而来，而当前点的类型（`Compess/Rake`）就表示这两个儿子是通过哪种树收缩操作合并而来。

![](https://cdn.luogu.com.cn/upload/image_hosting/pvpx7u5s.png)

注意：由于簇的端点会同时位于多个簇中，一般我们只维护簇中边和非上界点的信息，体现在后面维护动态 DP 的代码上，就是记录上界点状态而不计算上界点贡献。

不难发现，一颗 $n$ 个叶子的二叉树（每个结点两个儿子），共有 $2n-1$ 个结点，结点总数可以接受。

这样子，更新一条边的信息，只需要从它的基簇开始跳 Top Tree 的父亲，每次二叉合并更新信息即可。这启示我们，如果我们可以找到一种收缩树的方式使其 Top Tree 的树高可以接受就可以快速维护信息了！

## 基于重量平衡的静态 Top Tree

对原树进行重链剖分。此时会发现 `Compess` 操作相当于重链上线段树的 `pushup`，而 `Rake` 就相当于将轻儿子信息合并入重链。

那么我们就有一个思路了，对于一个原树中的点和它的若干轻儿子，我们可以建立一棵 leafy 的类线段树结构（Rake Tree），去分治的将相邻两个结点用 `Rake` 操作合并，如将下图中的簇 $A,B,C,D$ 合并到 $(u,v)$ 这条边上。

![](https://cdn.luogu.com.cn/upload/image_hosting/u3ge1wi4.png)

等我们将一条重链的所有轻儿子 `Rake` 到重链上后，此时我们再用一个 leafy 的类线段树结构（Compess Tree）将这些簇用 `Compess` 操作分治合并起来。至此，一条重链就被我们缩成了一个簇。

考虑这种算法的单次修改的复杂度：每条重链用一个 $\mathcal{O}(\log n)$ 去 `pushup`，共有 $\mathcal{O}(\log n)$ 条重链需要 `pushup`，总共 $\mathcal{O}(\log^2 n)$。

考虑优化，我们沿用全局平衡二叉树的思想，用每一个结点的簇大小作为分治区间的中点，此时每一个结点向上跳一或两次，其对应的簇大小至少翻倍，因此树高为 $\mathcal{O}(\log n)$，具体分析同全局平衡二叉树。

此时每一条原树上的边对应的基簇一定是这个 leafy 结构的叶子结点，从而修改边权就变得十分简单：直接 `Compess/Rake` 到根即可，而不需要在轻重儿子切换时做很多分讨。

## 常见可维护信息

显然，我们需要维护 `Compess` 和 `Rake` 两种 `pushup` 方式。

`Rake(x,y)` 默认是把 $y$ 往 $x$ 上合并。

- 簇大小：
  - `Compess(x,y)`：$sz=sz_x+sz_y$。
  - `Rake(x,y)`：$sz=sz_x+sz_y$。
- 簇路径长度：
  - `Compess(x,y)`：$len=len_x+len_y$。
  - `Rake(x,y)`：$len=len_x$。

通过这两个信息，相必你对 Top Tree 的合并操作有了更深入的理解。

## 维护动态 DP

明晰 Top Tree 只能维护边信息，如果像本题需要维护点信息，则需要将一个点的权值存到它的父亲边上，对于无父亲边的根，则新建虚根，使根存在父亲边（即点权上升为边权）。

通常，Top Tree 维护的 DDP 需要维护 $f_{x,0/1,0/1}$ 来记录上/下界点的状态，这是因为在合并两个簇的时候，这两个簇的公共点需要保证状态相同，而且需要统计跨越这两个簇的信息。

对于本题，设  $f_{x,0/1,0/1}$ 表示上下界点是否被选入独立集，此时簇内最大独立集大小即可解决问题。注意一个坑点：

- 我们只是记录上界点状态，而不计算上界点贡献，因为它会在当前簇的上面那个簇计算。

## Code

代码有注释。

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace fast_IO{
#define ld cin
#define jyt cout
} using namespace fast_IO;
#define ll long long
#define ull unsigned long long
#define REP(i, l, r) for (int i = l; i <= r; ++i)
#define PER(i, l, r) for (int i = l; i >= r; --i)
#define bitcount(x) __builtin_popcount(x)
#define albit(x) ((1 << (x)) - 1)
#define mkbit(x) (1 << (x - 1))
#define gtbit(x, id) (((x) >> (id - 1)) & 1)
// #define ld cin
// #define jyt cout
// #define int long long
const int N = 2e6 + 7;
const int inf = 1e9 + 7;
namespace TopTree {
    struct Mat {ll o[2][2]; Mat() {memset(o, 0, sizeof(o));}};
    int a[N], fa[N], sz[N], son[N], dep[N], Cluster[N];
    vector<int> G[N];
    struct Data {int sz; Mat lxl; Data() {sz = 0, lxl = Mat();}}; // 维护的信息
    struct Node {
        int lc, rc, fa; char op; Data v;
#define ls(x) tr[x].lc
#define rs(x) tr[x].rc
#define fa(x) tr[x].fa
    } tr[N]; int Trc = 0;  
    inline Data Compess(Data &a, Data &b) {
        Data c;
        c.sz = a.sz + b.sz;
        c.lxl.o[0][0] = max(b.lxl.o[0][0] + a.lxl.o[0][0], b.lxl.o[0][1] + a.lxl.o[1][0]);
        c.lxl.o[1][0] = max(b.lxl.o[1][0] + a.lxl.o[0][0], b.lxl.o[1][1] + a.lxl.o[1][0]);
        c.lxl.o[0][1] = max(b.lxl.o[0][0] + a.lxl.o[0][1], b.lxl.o[0][1] + a.lxl.o[1][1]);
        c.lxl.o[1][1] = max(b.lxl.o[1][0] + a.lxl.o[0][1], b.lxl.o[1][1] + a.lxl.o[1][1]);
        return c;
    }
    inline Data Rake(Data &a, Data &b) {
        Data c;
        c.sz = a.sz + b.sz;
        c.lxl.o[0][0] = a.lxl.o[0][0] + max(b.lxl.o[0][0], b.lxl.o[1][0]);
        c.lxl.o[1][0] = a.lxl.o[1][0] + max(b.lxl.o[0][0], b.lxl.o[1][0]);
        c.lxl.o[0][1] = a.lxl.o[0][1] + max(b.lxl.o[0][1], b.lxl.o[1][1]);
        c.lxl.o[1][1] = a.lxl.o[1][1] + max(b.lxl.o[0][1], b.lxl.o[1][1]);
        return c;
    }
    inline Data init(int w) { // 初始化一个边权为 w 的基簇
        Data c; 
        c.sz = 1;
        c.lxl.o[0][0] = 0, c.lxl.o[0][1] = 0, c.lxl.o[1][0] = w, c.lxl.o[1][1] = -inf;
        return c;
    }
    inline int BaseCluster(int w) {return ++Trc, tr[Trc].op = 'B', tr[Trc].v = init(w), Trc;} // 创建一个基簇
    inline void pushup(int x) {tr[x].v = (tr[x].op == 'R' ? Rake : Compess)(tr[ls(x)].v, tr[rs(x)].v);}
    inline int Merge(int x, int y, char op) {return ++Trc, fa(tr[Trc].lc = x) = fa(tr[Trc].rc = y) = Trc, tr[Trc].op = op, pushup(Trc), Trc;} // 创立一个 op 类型的结点用于合并两个簇 x,y
    inline void Prework(int x, int p) {
        fa[x] = p, sz[x] = 1, dep[x] = dep[p] + 1; 
        for (int v : G[x]) if (v ^ p) Cluster[v] = BaseCluster(a[v]), Prework(v, x), son[x] = (sz[v] > sz[son[x]] ? v : son[x]), sz[x] += sz[v];
    }
    inline int build(vector<int> &node, int l, int r, char op) { // 分治的用 op 操作把 node 中的簇合成一个。
        if (l == r) return node[l];
        int mid = r - 1, psz = 0, allsz = 0;
        REP(i, l, r) allsz += tr[node[i]].v.sz;
        REP(i, l, r - 1) if ((psz += tr[node[i]].v.sz) * 2 >= allsz) {mid = i; break;}
        return Merge(build(node, l, mid, op), build(node, mid + 1, r, op), op);
    }
    inline int Build(int x) {
        vector<int> compess;
        if (Cluster[x]) compess.emplace_back(Cluster[x]);
        for (; son[x]; x = son[x]) {
            vector<int> rake;
            for (int v : G[x]) if (v ^ fa[x] && v ^ son[x]) rake.emplace_back(Build(v));
            if (!rake.size()) compess.emplace_back(Cluster[son[x]]);
            else compess.emplace_back(Merge(Cluster[son[x]], build(rake, 0, (int)rake.size() - 1, 'R'), 'R')); // 把合并完的轻儿子合到 (x,son[x]) 这条重边上
        }
        return build(compess, 0, (int)compess.size() - 1, 'C');
    }
    inline void Modify(int x, int y) { // 如你所见，修改非常简单。
        tr[Cluster[x]].v = init(a[x] = y);
        for (x = tr[Cluster[x]].fa; x; x = tr[x].fa) pushup(x);
    }
}
namespace JoKing {
    int n, q, TopRt = 0;
    signed main() { int u, v, LA = 0;
        ld >> n >> q, TopTree::G[n + 1].emplace_back(1), TopTree::G[1].emplace_back(n + 1);
        REP(i, 1, n) ld >> TopTree::a[i];
        REP(i, 2, n) ld >> u >> v, TopTree::G[u].emplace_back(v), TopTree::G[v].emplace_back(u);
        TopTree::Prework(n + 1, 0), TopRt = TopTree::Build(n + 1);
        REP(i, 1, q) ld >> u >> v, TopTree::Modify(u ^= LA, v), jyt << (LA = max(TopTree::tr[TopRt].v.lxl.o[0][0], TopTree::tr[TopRt].v.lxl.o[1][0])) << '\n';
        return 0; 
    }
}
signed main() {
#ifndef WYY
//	freopen("std.in", "r", stdin);
//	freopen("user.out", "w", stdout);
#endif
//	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    JoKing::main(); return 0;
}
```

## 拓展例题

建议去做 [[SDOI2017] 切树游戏](https://www.luogu.com.cn/problem/P3781)，这题把 Top Tree 不用支持删除轻儿子信息的优势发挥的很明显。

## 参考资料

~~Top Tree 学的人少可能就是因为资料太杂了吧~~。

- 图很清晰：[Top tree 相关东西的理论、用法和实现 negiizhao](https://negiizhao.blog.uoj.ac/blog/4912)。

- 代码实现清晰：[简单萌萌哒 Top Tree（上）Laijinyi](https://www.cnblogs.com/laijinyi/p/18373391/Top-Tree-1)。

- 侧重动态 Top Tree：[Top Tree OI Wiki](https://oi.wiki/ds/top-tree/)。

- 代码实现清晰：[Top Tree & Top Cluster 分块 Richardwhr](https://www.cnblogs.com/Richardwhr/p/18834468)。

- 适合初学：[浅谈 Top Tree jerry3128](https://www.luogu.com/article/rnzh9gqy)。

- 适合初学：[Top Tree 相关理论扯淡 ExplodingKonjac](https://www.cnblogs.com/ExplodingKonjac/p/17890636.html)（这篇不知道为什么会一直卡在加载界面，要 F12 把加载界面删掉才看得到）。

推荐一个 Top Tree 可视化：[link](https://maomao9-0.github.io/static-top-tree-visualisation/)。

---

## 作者：Purslane (赞：10)

# 全局平衡二叉树优化动态 DP

感觉到现在我都不会动态 DP。来补习一下。

如果没有点权修改，这道题就是绿色的《没有上司的舞会》。设 $f_{u,0}$ 为 $u$ 节点不选择时 $u$ 子树内的最大独立集大小，$f_{u,1}$ 为 $u$ 节点选择时 $u$ 子树内的最大独立集大小。那么有：

$$
\begin{aligned}
f_{u,0} &= \sum_{v \in son_u} \max\{f_{v,0},f_{v,1}\} \\
f_{u,1} &= w_u+\sum_{v \in son_u} f_{v,0}
\end{aligned}
$$

和大多的动态 DP 一样，使用 $(+,\max)$ 的矩阵乘法（也许我的记号不准确，记得纠正我），记

$$
M_{u}=\left[
\begin{matrix}
f_{u,0} \\
f_{u,1}
\end{matrix}
\right]
$$

但是树形 DP 和普通的序列 DP 不一样，涉及了多个矩阵的合并。如果能像序列 DP 一样每次只在一个状态上修改就好了！那么每个节点要继承某个儿子的信息。很自然的，我们选择继承其重儿子的信息。

那么上面两个递推式中，我们把轻儿子都给装进另外一个数组，得到：（$lson$ 表示轻儿子，$hson$ 表示重儿子）

$$
\begin{aligned}
g_{u,0} &= \sum_{v \in lson_u} \max\{f_{v,0},f_{v,1}\} \\
g_{u,1} &= w_u + \sum_{v \in lson_u} f_{v,0}
\end{aligned}
$$

于是有：

$$
\begin{aligned}
f_{u,0} &= g_{u,0} + \max\{f_{hson,0},f_{hson,1}\} \\
f_{u,1} &= g_{u,1}+f_{hson,0}
\end{aligned}
$$

得到矩阵的形式：

$$
M_u = \left[ 
\begin{matrix}
g_{u,0} & g_{u,0} \\
g_{u,1} & -\infty
\end{matrix}
\right]
M_{hson}
$$

首先考虑在静态形式用这种方法求出 $M_{root}$，并且得到答案。

大家都会 DSU-ON-TREE 的技巧。我们使用类似的方法：对于每个点，先递归求出它的所有轻儿子的 $M$，并且通过合并得到上面那个 $2 \times 2$ 的矩阵。然后求出其重儿子的 $M_{hson}$，乘上去就得到 $M_u$。

我们很容易使用树链剖分的手段做到两个 $\log$ 的解法。预处理之后对于每个重链求出自顶向下的 $\left[ 
\begin{matrix}
g_{u,0} & g_{u,0} \\
g_{u,1} & -\infty
\end{matrix}
\right]$ 的乘积。（链底节点的 $M$ 是确定的，所以没必要记录。注意每条链必定伸到一个叶子节点）。单点修改的时候，相当于对于修改了中间的某个矩阵。这一部分可以用线段树维护。

不过他会修改到链顶节点的 $M_{top_{u}}$，同时会修改 $fa_{top_u}$ 的 $g$。那么相当于新的单点修改操作。如此反复得到了 $O(\log^2 n)$ 的单点修改。

而全局平衡二叉树可以做到 $O(\log n)$ 的单点修改。

考虑我们复杂度的瓶颈在哪里。使用线段树的时候，无论从哪个点对整条链进行修改，都得花 $O(\log n)$ 更新线段树信息。这个是很不公平的！

权值线段树就很好的处理了这种问题。它的形态有点类似 LCT（这句话也可能不那么正确啊，我从来就没会过 LCT，这是根据我对它非常浅显的了解做出的判断）

对于每个重链，记每个点的权值为它的子树的大小减去它的重儿子的子树的大小。然后建立一个 BST，每次都在当前区间找到其加权中位数然后分成两半（为了保证复杂度，我们不选用线段树这种 Leafy Tree 的结构，而是类似 Treap 或者 Splay 的结构）。并且，为了让你更容易写，我们给这棵 BST 的根节点的**父亲通过一条虚边指向原本这条链链顶的父节点**。每次在修改的时候，暴力往上跳。如果是实边就 push_up，如果是虚边就更新矩阵之后再 push_up。

考虑复杂度。很容易发现，往上跳一个父亲，如果是实边目前区间（就是当前节点的所有儿子）的权值总数翻一倍；如果是虚边，权值总数至少不减。所以你最多跳 $O(\log n)$ 次实边。而根据轻重边的性质，你也最多跳 $O(\log n)$ 次虚边。所以复杂度为 $O(\log n)$。

代码真的很好写 ![](https://pic3.zhimg.com/v2-4ab7bced1665776a957c81cc46fc6ffe_b.webp)

```cpp
#include<bits/stdc++.h> 
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e6+10,INF=-1000000000;
int n,m,lstans,sze[MAXN],w[MAXN],son[MAXN],dfn[MAXN],dp[MAXN][2],g[MAXN][2],FA[MAXN];
int top[MAXN],rev[MAXN],pre[MAXN],lson[MAXN],rson[MAXN],fa[MAXN],tot,mxdfn[MAXN];
struct Matrix {int v[2][2];}M[MAXN],mul[MAXN];
Matrix operator*(Matrix A,Matrix B) {
	Matrix res;
	res.v[0][0]=max(A.v[0][0]+B.v[0][0],A.v[0][1]+B.v[1][0]);
	res.v[0][1]=max(A.v[0][0]+B.v[0][1],A.v[0][1]+B.v[1][1]);
	res.v[1][0]=max(A.v[1][0]+B.v[0][0],A.v[1][1]+B.v[1][0]);
	res.v[1][1]=max(A.v[1][0]+B.v[0][1],A.v[1][1]+B.v[1][1]);
	return res;	
}
vector<int> G[MAXN];
void dfs1(int u,int f) {
	sze[u]=1,dp[u][1]=w[u];
	for(auto v:G[u]) if(v!=f) {
		FA[v]=u,dfs1(v,u),sze[u]+=sze[v]; if(sze[v]>sze[son[u]]) son[u]=v;
		dp[u][0]+=max(dp[v][0],dp[v][1]),dp[u][1]+=dp[v][0];
	}
	return ;
}
void dfs2(int u,int f) {
	dfn[u]=++tot,pre[tot]=sze[u]-sze[son[u]],rev[tot]=u;	
	dp[u][0]-=max(dp[son[u]][0],dp[son[u]][1]),dp[u][1]-=dp[son[u]][0];
	M[u].v[0][0]=dp[u][0],M[u].v[0][1]=dp[u][0],M[u].v[1][0]=dp[u][1],M[u].v[1][1]=INF;
	dp[u][0]+=max(dp[son[u]][0],dp[son[u]][1]),dp[u][1]+=dp[son[u]][0];
	if(son[u]) top[son[u]]=top[u],dfs2(son[u],u);
	for(auto v:G[u]) if(v!=f&&v!=son[u]) top[v]=v,dfs2(v,u);
	return ;
}
void push_up(int u) {return mul[u]=mul[lson[u]]*M[u]*mul[rson[u]],void();}
int build(int l,int r) {
	if(l>r) return 0;
	if(l==r) return mul[rev[l]]=M[rev[l]],rev[l];
	int u=lower_bound(pre+l,pre+r+1,(pre[l-1]+pre[r])/2+(pre[l-1]+pre[r])%2)-pre;
	lson[rev[u]]=build(l,u-1),rson[rev[u]]=build(u+1,r);
	fa[lson[rev[u]]]=rev[u],fa[rson[rev[u]]]=rev[u];
	return push_up(rev[u]),rev[u];
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m; ffor(i,1,n) cin>>w[i];
	mul[0].v[0][0]=mul[0].v[1][1]=0,mul[0].v[0][1]=mul[0].v[1][0]=INF;
	ffor(i,1,n-1) {int u,v; cin>>u>>v,G[u].push_back(v),G[v].push_back(u);}
	dfs1(1,0),top[1]=1,dfs2(1,0);
	ffor(i,1,n) pre[i]+=pre[i-1];
	ffor(i,1,n) mxdfn[top[i]]=max(mxdfn[top[i]],dfn[i]);
	ffor(i,1,n) if(top[i]==i) {
		int rt=build(dfn[i],mxdfn[i]);
		fa[rt]=FA[i];
	}	
	ffor(i,1,m) {
		int x,y; cin>>x>>y,x^=lstans; //cout<<x<<' '<<y<<'&';
		M[x].v[1][0]=M[x].v[1][0]-w[x]+y,w[x]=y,push_up(x);
		while(fa[x]!=0) {
			if(x==lson[fa[x]]||x==rson[fa[x]]) x=fa[x],push_up(x);	
			else {
				int _0=M[fa[x]].v[0][0]-max(dp[top[x]][0],dp[top[x]][1]),_1=M[fa[x]].v[1][0]-dp[top[x]][0];
				dp[top[x]][0]=max(mul[x].v[0][0],mul[x].v[0][1]),dp[top[x]][1]=max(mul[x].v[1][0],mul[x].v[1][1]);
				_0+=max(dp[top[x]][0],dp[top[x]][1]),_1+=dp[top[x]][0];
				M[fa[x]].v[0][0]=M[fa[x]].v[0][1]=_0,M[fa[x]].v[1][0]=_1;
				x=fa[x],push_up(x);
			}
		}
		cout<<(lstans=max({mul[x].v[0][0],mul[x].v[0][1],mul[x].v[1][0],mul[x].v[1][1]}))<<'\n';
	}
	return 0;
}
```

---


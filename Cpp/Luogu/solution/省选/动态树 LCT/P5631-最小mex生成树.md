# 最小mex生成树

## 题目背景

这是一道经典题。

## 题目描述

给定 $n$ 个点 $m$ 条边的无向连通图，边有边权。  

设一个自然数集合 $S$ 的 $\text{mex}$ 为：最小的、没有出现在 $S$ 中的自然数。  

现在你要求出一个这个图的生成树，使得其边权集合的 $\text{mex}$ 尽可能小。

## 说明/提示

【数据范围】   
- 对于 $20\%$ 的数据，$1\le n \le 100$，$1\le m \le 200$。
- 对于 $50\%$ 的数据，$1\le n \le 2000$，$1\le m \le 3000$。
- 对于 $80\%$ 的数据，$1\le n \le 10^5$，$1\le m \le 2\times 10^5$。
- 对于 $100\%$ 的数据，$1\le n \le 10^6$，$1\le m \le 2\times 10^6,0\le w \le 10^5$。

输入数据规模较大，建议使用高效的读入方式。

## 样例 #1

### 输入

```
3 3
1 2 0
2 3 1
3 2 2
```

### 输出

```
1```

# 题解

## 作者：djh123 (赞：22)

因为$\text{mex}$是不在生成树内的最小的自然数，那我们可以考虑枚举答案是$x$，$\text{check}$的时候，如果一条边的边权是$x$，那么这条边就不应该出现在生成树里，否则一定非法。

那么就有一个比较显然的做法：枚举答案$x$，把边权为$x$的所有边删掉，看剩下的边能不能求出一棵生成树。

这样直接暴力去做的复杂度是$O(mw\log m)$的，对于这种删掉一部分边的问题，我们可以考虑用分治去优化这个过程，那么我们就用$solve(l,r)$就表示权值范围在$[l,r]$的边没有加进去，每次添加$[l,mid]$到$[mid+1, r]$，添加$[mid+1, r]$到$[l, mid]$，用可撤销并查集维护连通性即可，复杂度$O(m\log m \log w)$，实现的稍微好一点就能通过了。

```cpp

#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;
const int N = 1e6 + 50, M = 4e6 + 50;
int head[N], to[M], nxt[M], val[M], tot;
bool vis[N];

int fa[N], siz[N], cnt, n, m, ans = 0x3f3f3f3f;
struct node {
	int u, v, w;
}e[M];
bool operator < (const node &a, const node &b) {
	return a.w < b.w;
}

int find(int x) { return x == fa[x] ? x : find(fa[x]); }

int unit(int x, int y) {
	int fx = find(x), fy = find(y);
	if(fx == fy) return 0;
	if(siz[fx] > siz[fy]) { fa[fy] = fx; siz[fx] += siz[fy]; return fy; }
	else { fa[fx] = fy; siz[fy] += siz[fx]; return fx; }
}

void del(int x) {
	siz[fa[x]] -= siz[x];
	fa[x] = x;
}

void solve(int l, int r, int pos) {
	if(l == r) { if(siz[find(1)] == n) { cout << l; exit(0);} return ; }
	int mid = (l + r) >> 1;
	int tmp = pos, lsbl = 0;
	vector <int> v;
	for(; e[pos].w <= r && pos <= m; ++ pos) if((e[pos].w > mid) && (lsbl = unit(e[pos].u, e[pos].v))) v.push_back(lsbl);
	solve(l, mid, tmp);
	for(int i = v.size() - 1; i >= 0; -- i) del(v[i]); v.clear();
	pos = tmp, lsbl = 0;
	for(; e[pos].w <= mid && pos <= m; ++ pos) if(lsbl = unit(e[pos].u, e[pos].v)) v.push_back(lsbl);
	solve(mid + 1, r, pos);
	for(int i = v.size() - 1; i >= 0; -- i) del(v[i]); v.clear();
}

int main() {
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; ++ i) fa[i] = i, siz[i] = 1;
	for(int i = 1; i <= m; ++ i) scanf("%d%d%d", &e[i].u, &e[i].v, &e[i].w);
	sort(e + 1, e + 1 + m);
	solve(0, e[m].w + 1, 1);
	return 0;
}


```

---

## 作者：Rorschachindark (赞：15)

# 最小mex生成树
[题目传送门](https://www.luogu.com.cn/problem/P5631)
## 题目描述
给定一个$n$个点$m$条边的无向图，求出其最小$\text{mex}$生成树。
## 思路
### $\text{80 pts}$
我们直接贪心，求出最大生成树。

很明显，这个贪心错得一塌糊涂，但是能够成功地骗到$80 pts$。

代码这里就不给出。
### 线段树分治
不难看出可以用线段树分治。

我们对于权值建一棵线段树，然后对于插入$(u,v,w)$的一次操作，在线段树上就对应着：

1. 在$[0,w-1]$插入$(u,v)$

2. 在$[w+1,\text {maxw}]$插入$(u,v)$

$\text {maxw}$就是指的最大权值$+1$（因为是求$\text {mex}$所以要加1）.

然后递归到某一权值时，加入的所有边就是$m$条边中除了这个权值的所有边，只需要判断这时其他边是否可以组成一棵树就好了。

如何维护当前可不可以构成一棵树呢？我们可以直接用并查集维护联通数，当联通数为1的时候显然就可以。

具体见代码吧，也不是很难，一次就$A$了。

时间复杂度为$\Theta(w\log w\log n)$。$w$为最大权值。然而时间还是被一堆巨佬吊打。
### $\text {Code}$
```cpp
#include <bits/stdc++.h>
using namespace std;

#define Int register int
#define pr pair<int,int>//一条边 
#define MAXN 2000005
#define MAXX 100005

int read ()
{
	int x = 0;char c = getchar();int f = 1;
	while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}
	while (c >= '0' && c <= '9'){x = (x << 3) + (x << 1) + c - '0';c = getchar();}
	return x * f;
}

void write (int x)
{
	if (x < 0){x = -x;putchar ('-');}
	if (x > 9) write (x / 10);
	putchar (x % 10 + '0');
}

int n,m,Ans,Maxm;//Ans表示目前的连通数,Maxn是边权上限 

int fa[MAXN],size[MAXN];

stack <int> S;

int findSet (int x)
{
	while (x ^ fa[x]) x = fa[x];
	return x;
}

void unionSet (int x,int y)
{
	if (x == y) return ;
	if (size[x] > size[y]) swap (x,y);
	Ans --,size[y] += size[x],fa[x] = y,S.push (x);
}

void Init ()
{
	for (Int i = 1;i <= n;++ i) fa[i] = i,size[i] = 1;
}

vector <pr> tree[MAXX << 2];

void Delete (int tag)
{
	while (S.size () > tag)
	{
		int x = S.top();S.pop ();
		Ans ++,size[fa[x]] -= size[x],fa[x] = x;
	}
}

void update (int k,int l,int r,int tl,int tr,pr Edge)
{
	if (l > tr || tl > r) return ;
	if (l >= tl && r <= tr) return tree[k].push_back (Edge);
	int mid = (l + r) >> 1;
	update (k << 1,l,mid,tl,tr,Edge);
	update (k << 1 | 1,mid + 1,r,tl,tr,Edge);
}

void Divide (int k,int l,int r)
{
	int tag = S.size();
	for (Int i = 0;i < tree[k].size();++ i)
	{
		int u = tree[k][i].first,v = tree[k][i].second;
		u = findSet (u),v = findSet (v);
		unionSet (u,v);
	}
	if (l == r)
	{
		if (Ans == 1)
		{
			write (l),putchar ('\n');
			exit (0);
		}
		return Delete (tag);
	}
	int mid = (l + r) >> 1;
	Divide (k << 1,l,mid);
	Divide (k << 1 | 1,mid + 1,r);
	return Delete (tag);
}

int from[MAXN],tooo[MAXN],w[MAXN]; 

signed main()
{	
	Ans = n = read (),m = read ();
	Init ();
	for (Int i = 1;i <= m;++ i)
	{
		from[i] = read (),tooo[i] = read (),w[i] = read ();
		Maxm = max (Maxm,w[i] + 1);
	}
	for (Int i = 1;i <= m;++ i)
		update (1,0,Maxm,0,w[i] - 1,make_pair (from[i],tooo[i])),
		update (1,0,Maxm,w[i] + 1,Maxm,make_pair (from[i],tooo[i]));
	Divide (1,0,Maxm);
	return 0;
}
```


---

## 作者：s_r_f (赞：5)

提供一个空间$O(n+m)$的做法$.$

这道题需要线段树分治$,$首先我们可以求出最大生成树用来缩小一下答案范围以减小常数$.$

然后因为$N=1e6,M=2e6$看起来有点大$,$所以最好不要用$O(NlogN)$的空间$.$

在线段树分治的过程中$,$如果一个节点$x$ $($ 代表的区间为 $[L,R]$ $)$ 上有边需要$insert$ $,$只有以下两种可能$:$

$1.$ $x$是线段树的根 $,$ 且边权 $w ∉ [L,R]$

$2.$ $x$是线段树非根节点 $,$ 且边权 $w ∉ [L,R],w ∈ [L_{fa_x},R_{fa_x}].$

用可撤销并查集维护即可$.$

然后就可以$O(n+m)$空间了$.$

时间复杂度$O(mlognlogw)$

代码 $:$

```cpp
#include <bits/stdc++.h>
using namespace std;
template <typename T> void read(T &x){
	static char ch; x = 0,ch = getchar();
	while (!isdigit(ch)) ch = getchar();
	while (isdigit(ch)) x = x * 10 + ch - '0',ch = getchar();
}
const int N = 1000005,M = 2000005,W = 100005;
int n,m;
struct Union_Find_Set{
	int o[N<<1],ofa[N<<1],ork[N<<1],osiz[N<<1],top; int fa[N],rk[N],siz;
	inline void init(int n){ siz = n,top = 0; for (register int i = 1; i <= n; ++i) fa[i] = i,rk[i] = 1; }
	inline int Find(int x){ return x == fa[x] ? x : Find(fa[x]); }
	inline void rework(int k){ ++k; while (--k) fa[o[top]] = ofa[top],rk[o[top]] = ork[top],siz += osiz[top],--top;  }
	inline int check(){ return siz == 1; }
	inline int Merge(int x,int y){
		x = Find(x),y = Find(y); if (x == y) return 0;
		if (rk[x] > rk[y]) swap(x,y);
		++top,o[top] = x,ofa[top] = fa[x],ork[top] = rk[x],osiz[top] = 1;
		++top,o[top] = y,ofa[top] = fa[y],ork[top] = rk[y],osiz[top] = 0;
		fa[x] = y,--siz; if (rk[x] == rk[y]) ++rk[y]; 
		return 2;
	}
	inline int Find2(int x){ return x == fa[x] ? x : (fa[x] = Find2(fa[x])); }
	inline bool Merge2(int x,int y){ x = Find2(x),y = Find2(y); if (x^y) fa[x] = y,--siz; return x^y; }
}S;
struct Edge{ int x,y,w; bool operator < (Edge ww) const{ return w < ww.w; } }e[M],tmp[M];
int Ne[M],He[W],_k;
inline void Sort(){
	register int pos = 0,p;
	for (register int i = 1; i <= m; ++i) ++_k,tmp[_k] = e[i],Ne[_k] = He[e[i].w],He[e[i].w] = _k;
	for (register int i = 0; i < W; ++i) for (p = He[i]; p ; p = Ne[p]) e[++pos] = tmp[p];
}
int tl[W],tr[W],mxw; bool cnt[W];
inline int solve1(){
	register int i;
	for (S.init(n),i = m; i && !S.check(); --i) if (S.Merge2(e[i].x,e[i].y)) cnt[e[i].w] = 1;
	for (i = 0; ; ++i) if (!cnt[i]) return i;
}
inline void solve(int L,int R,int l,int r){
	int kk = 0;
	if (l == L) for (register int i = tr[r]+1; i <= tr[R]; ++i) kk += S.Merge(e[i].x,e[i].y);
	else for (register int i = tl[L]; i < tl[l]; ++i) kk += S.Merge(e[i].x,e[i].y);
	if (S.check()){ cout << l << '\n'; exit(0); }
	if (l < r) solve(l,r,l,l+r>>1),solve(l,r,(l+r>>1)+1,r);
	S.rework(kk);
}
int main(){
	register int i;
	read(n),read(m);
	for (i = 1; i <= m; ++i) read(e[i].x),read(e[i].y),read(e[i].w);
	for (i = 1; i < m; ++i) if (e[i].w > e[i+1].w){ Sort(); break; }
	mxw = solve1(); e[m+1].w = -1;
	for (i = 0; i <= mxw; ++i){ tl[i] = i?(tr[i-1]+1):1,tr[i] = tr[i-1]; while (e[tr[i]+1].w == i) ++tr[i]; }
	S.init(n); for (i = tr[mxw]+1; i <= m; ++i) S.Merge(e[i].x,e[i].y); solve(0,mxw,0,mxw);
	return 0;
}
```

---

## 作者：FutaRimeWoawaSete (赞：2)

mex 生成树。

其实本质思想都是一样的。                 

但是见过的 trick 没想到还是挺丢脸的。               

我们考虑一种极其暴力的做法，即枚举每个权值是否可以作为答案。那么相对应的就是询问排好序后不要一个区间的边是否可以让原图联通，也可以是询问序列前缀边和序列后缀边是否能使得原图联通。             

如果每次枚举都跑一遍的话我们可以做到 $\Theta(nw \times a(n))$ 的优秀复杂度，不过这并不能通过此题。                     

考虑到我们其实在其中重复处理了许多信息，想到要重复利用这些信息。      

发现值域很小，对于值域建立线段树，对于线段树节点 $[l , r]$ 我们尝试求出值域在 $[l , r]$ 间的边未连时的图的状态。这个可以用并查集维护。这时候我们如果再递归下去直到叶子节点，就可以 $O(1)$ 判断每个权值作为答案是否可行了。（虽然值域大也可以做，但是这也是个提示方向）                

考虑到上述说的重复利用信息，我们考虑用可撤销并查集，对线段树进行先序遍历，如果有边不用了就直接撤销。由于边先进后出所以开栈维护即可，可以证明每条边贡献 $O(\log w)$ 次，最后总的时间复杂度是 $O(n \log n \log w)$ 。            

由于 $w$ 较小，并且可撤销并查集的常数比较小所以可以通过此题。       
```cpp
#include "bits/stdc++.h"
using namespace std;
const int Len = 1e6 + 5;
int n,m,top,maxw;
struct ee
{
	int u,v,w;
}Edge[Len << 1];
bool cmp(ee x , ee y){return x.w < y.w;}
/*
询问区间前后缀边是否可以联通原图
用双指针扫不知道能不能过 
可以过，排序后倒序插边即可执行倒删 
错了
看了题解，使用建立线段树的方式可以做到利用前置信息且以栈的形式删边加边 
*/
struct Node
{
	int u,v,siz;
	Node(){u = 0 , v = 0 , siz = 0;}
	Node(int U,int V,int SIZ){u = U , v = V , siz = SIZ;}
}stk[Len << 1];
struct UnionF
{
	int fa[Len],siz[Len];
	void makeSet(int x){for(int i = 1 ; i <= x ; i ++) fa[i] = i , siz[i] = 1;}
	int findSet(int x){return fa[x] == x ? fa[x] : findSet(fa[x]);}
	void unionSet(int x,int y)
	{
		int u = findSet(fa[x]) , v = findSet(fa[y]);
		if(u == v) return;
		if(siz[u] < siz[v]) swap(u , v);
		stk[++ top] = Node(u , v , siz[u]);
		fa[v] = u , siz[u] += siz[v];
	}
	void del(int ID)
	{
		int u = stk[ID].u , v = stk[ID].v;
		fa[v] = v , siz[u] = stk[ID].siz;
	}
}S1;
void Solve(int l,int r,int pos)
{
	if(l == r){if(S1.siz[S1.findSet(1)] == n){printf("%d\n",l);exit(0);}return;}
	int mid = (l + r) >> 1;
	int idx = pos , now = top;
	for(; Edge[idx].w <= r && idx <= m ; idx ++) if(Edge[idx].w > mid) S1.unionSet(Edge[idx].u , Edge[idx].v);
	Solve(l , mid , pos);
	while(top > 0 && top > now) S1.del(top --);
	idx = pos;
	for(; Edge[idx].w <= mid && idx <= m ; idx ++) S1.unionSet(Edge[idx].u , Edge[idx].v);
	Solve(mid + 1 , r , idx);
	while(top > 0 && top > now) S1.del(top --);
}
int main()
{
	scanf("%d %d",&n,&m);
	for(int i = 1 ; i <= m ; i ++){scanf("%d %d %d",&Edge[i].u,&Edge[i].v,&Edge[i].w);maxw = max(maxw , Edge[i].w);}
	sort(Edge + 1 , Edge + 1 + m , cmp);
	S1.makeSet(n);
	Solve(0 , maxw + 1 , 1);
	return 0;
}
```

---

## 作者：Genius_Z (赞：2)

退役选手因自习课太多到机房水篇题解（

这题一眼看上去就有一个$\Theta(nwlogn)$的暴力，即枚举$mex$值为$i$时图能否联通，答案最大为$maxw +1$

我们考虑优化这个暴力，那么这显然就转换成了一个加边删边的图连通性问题，直接线段树分治加可撤销并查集即可，复杂度是$\Theta(mlogw+wlogmlogn)$而且跑不满，因为在分治过程中求出答案直接就$return$了。

$\large Code:$

```cpp
struct edge {
	int u, v, w;
}e[2000001];
int ans, n = read<int>(), m = read<int>(), siz = 0;
vector<int>ve[400005];
inl void insert(int k, int l, int r, int x, int y, int i) {
	if (x > y)return;
	if (l >= x && r <= y)return ve[k].push_back(i);
	re mid = l + r >> 1;
	if (x <= mid)insert(k << 1, l, mid, x, y, i);
	if (y > mid)insert(k << 1 | 1, mid + 1, r, x, y, i);
}
int fa[1000001], st[2000001], top, si[2000001];
inl int find(int x) { return fa[x] ? find(fa[x]) : x; }
inl void del(int x) { while (top > x)si[fa[st[top]]] -= si[st[top]], fa[st[top--]] = 0; }
inl void divide(int k, int l, int r) {
	re mid = l + r >> 1, rtop = top;
	for (auto i : ve[k]) {
		re u = find(e[i].u), v = find(e[i].v);
		if (u != v) {
			if (si[u] < si[v])swap(u, v);
			fa[v] = u, si[u] += si[v], st[++top] = v;
		}
	}
	if (l == r) {
		if (si[find(1)] == n)ans = l, writeln(ans), exit(0);
	}
	else divide(k << 1, l, mid), divide(k << 1 | 1, mid + 1, r);
	del(rtop);
}
signed main() {
	for (re i = 1; i <= m; i++) e[i].u = read<int>(), e[i].v = read<int>(), e[i].w = read<int>(), siz = max(e[i].w, siz);
	for (re i = 1; i <= m; i++) insert(1, 0, siz, 0, e[i].w - 1, i), insert(1, 0, siz, e[i].w + 1, siz, i);
	for (re i = 1; i <= n; i++)si[i] = 1;
	ans = siz + 1;
	divide(1, 0, siz), writeln(ans);
}
```



---

## 作者：Register (赞：1)

- 首先先把正解放出来：

如果能不选一个权值的边，也能成为一棵生成树，那么最小的这个权值就是问题的解

不过直接这样算是 $O(NW\alpha(N))$ （用路径压缩并查集）

考虑分治，先把权值 $[l,mid]$ 的边给撤销，分治后加上来再把 $[mid,r]$ 的边撤销，分治后再加上来

当 $l=r$ 时，就判断并查集森林的根的大小是否为 $N$ ，因此并查集是按秩合并，同时还要维护一个 $\text{size}$

时间复杂度显然是 $O(N\log N\log W)$

- 接着提供一个假算法（建议加强数据，能过）：

首先求出所有的割边，这些割边是必选的，然后你貌似觉得其它边都可以被替换，不过你错了

确实可以被替换，但是这并不代表他能替换成权值不同的边

楼下的题解是判是不是一组边可以被这个 $\text{hack}$ ：

	5 5
	1 2 0
	2 3 1
	3 4 1
	4 5 1
	5 2 1

而我是判权值是否相等的，可以被这个 $\text{hack}$ ：

	5 5
	1 2 0
	2 3 1
	3 4 2
	4 5 1
	5 2 1

再提供一下假算法的代码（和楼下的判重边方式略有不同~~反正都是假的~~）：

```cpp
#include <cstdio>
#include <utility>
#include <vector>
using namespace std;
int n,m,sum,dfn[1000001],low[1000001];
bool ans[100002];
vector<pair<int,int> > e[1000001];
inline int read(){
    char ch=getchar();int res=0,w=1;
    while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') {res=res*10+ch-'0';ch=getchar();}
    return res*w;
}
inline int Min(int x,int y) {return x<y?x:y;}
void tarjan(int x,int fa){
	dfn[x]=low[x]=++sum;
	for(register int i=0;i<e[x].size();i++)
		if(!dfn[e[x][i].first])
		{
			tarjan(e[x][i].first,e[x][i].second);low[x]=Min(low[x],low[e[x][i].first]);
			if(low[e[x][i].first]>dfn[x]) ans[e[x][i].second]=true;
		}
		else if(e[x][i].second!=fa) low[x]=Min(low[x],dfn[e[x][i].first]);
}
signed main(){
	n=read();m=read();
	while(m--) {int u=read(),v=read(),c=read();e[u].push_back(make_pair(v,c));e[v].push_back(make_pair(u,c));}
	tarjan(1,114514);
	for(register int i=0;;i++)
		if(!ans[i]) {printf("%d\n",i);return 0;}
    return 0;
}
```

---

## 作者：Walrus (赞：0)

一般来说看到 mex 首先不会想到线段树分治，正常人都会去想怎么模拟怎么贪心，但 mex 也可以用到线段树分治上。

我们将 mex 转化为**边的出现时间**，然后建权值线段树。

具体地，mex 指的是集合内最小没有出现过的自然数，自然可以想到，如果一个集合 $S$ 的 mex 为 $x$，则其对应的出现时间即可转化为在 $[0, x-1]$ 和 $[x+1,\max(w_i)+1]$ 之间。$w_i$ 为边权。注意在求 mex 时最大边权要加一。

故做法显然可以枚举 $x$，把所有权值为 $x$ 的边删掉，看剩下的边能否构成原图的生成树。

如何判断是否是生成树？自然想到启发式合并的可撤销并查集，维护每一个集合的 $size$ 大小，若某个集合的大小为 $n$，则说明所有的点都被包括在内，也就是说只有一个连通块。故此连通块为原图的生成树。

时间复杂度为正常的线段树分治复杂度 $O(M \log^2 N)$。

```cpp
#include <bits/stdc++.h>
#define rep(i, j, k) for(int i = j; i <= k; ++i)
#define pb push_back
#define PII pair<int, int>

using namespace std;
const int N = 2e6 + 5;
int n, m, u[N], v[N], w[N];
vector<PII> e[N * 2];

struct Union {
	int fa[N], siz[N];
	stack<PII> st;
	
	void init() {
		rep(i, 1, n) fa[i] = i, siz[i] = 1;
	}
	
	int get(int x) {
		return x == fa[x] ? x : get(fa[x]);
	}
	
	void merge(int x, int y) {
		x = get(x), y = get(y);
		if(x == y) return;
		if(siz[x] > siz[y]) swap(x, y);
		st.push({x, y});
		fa[x] = y, siz[y] += siz[x];
	}
	
	void undo(int last) {
		while(st.size() > last) {
			int x = st.top().first, y = st.top().second;
			st.pop();
			fa[x] = x, siz[y] -= siz[x];
		}
	}
	
} DSU;

stack<PII> T;

struct SegmentTree {
	#define ls (p << 1)
	#define rs (p << 1 | 1)
	#define mid (l + r >> 1)
	
	void upd(int p, int l, int r, int L, int R, int u, int v) {
		if(L > r || l > R) return;
		if(L <= l && r <= R) 
			return e[p].pb({u, v}), void();
		upd(ls, l, mid, L, R, u, v), upd(rs, mid + 1, r, L, R, u, v);
	}
	
	int ask(int p, int l, int r) {
		int S = DSU.st.size();
		for(auto ed : e[p]) {
			int x = ed.first, y = ed.second;
			DSU.merge(x, y);
		}
		if(l == r) {
			if(DSU.siz[DSU.get(1)] == n) return l;
		}
		else {
			int tmp = ask(ls, l, mid);
			if(tmp) return tmp;
			tmp = ask(rs, mid + 1, r);
			if(tmp) return tmp;
		}
		DSU.undo(S);
		return 0;
	}
} SGT;

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(nullptr), cout.tie(nullptr);
	
	
	cin >> n >> m; DSU.init();
	int mx = 0;
	rep(i, 1, m) cin >> u[i] >> v[i] >> w[i], mx = max(mx, w[i]);
	
	++mx;//*
	
	rep(i, 1, m) SGT.upd(1, 0, mx, 0, w[i] - 1, u[i], v[i]), SGT.upd(1, 0, mx, w[i] + 1, mx, u[i], v[i]);
	cout << SGT.ask(1, 0, mx);
	
	
}
```

---

## 作者：gyyyyx (赞：0)

前置知识：线段树分治，并查集

和[这题](https://www.luogu.com.cn/problem/P5227)的做法完全一致。

我们称边权为 $x$ 的边为 $x$ 类边。

考虑一个数 $x$ 如何才能成为答案。

如果将 $x$ 类边全部删除后存在生成树（图联通），则答案一定不大于 $x$。

容易得出答案为这些 $x$ 中的最小值。

即我们现在要询问若干次删除若干边后图是否联通。

线段树分治加可撤销并查集即可。

具体可以看我的这篇[题解](https://www.luogu.com.cn/article/7klplxvx)。

代码：

```cpp
#include<bits/stdc++.h>
#define N 1000005
#define M 2000005
#define W 100005
using namespace std;
int n,m;
struct Edge{int u,v;};
struct Edge E[M];
vector <int> id[W];
int mx;
vector <int> Node[W<<2];
int fa[N],dep[N],cnt;
stack <int> st1,st2;
void Update(int k,int l,int r,int s,int t,int e){
	if(s<=l&&r<=t){
		Node[k].push_back(e);
		return;
	}
	int ls(k<<1),rs(k<<1|1),mid(l+r>>1);
	if(s<=mid) Update(ls,l,mid,s,t,e);
	if(t>mid) Update(rs,mid+1,r,s,t,e);
}
int Find(int x){
	if(fa[x]==x) return x;
	return Find(fa[x]);
}
inline void Merge(int x,int y){
	x=Find(x);y=Find(y);
	if(x^y){
		if(dep[x]>dep[y]) swap(x,y);
		st1.push(x);st2.push(dep[y]);
		fa[x]=y;dep[y]=max(dep[x]+1,dep[y]);
		++cnt;
	}
}
inline void Delete(){
	int x(st1.top());st1.pop();
	int d(st2.top());st2.pop();
	dep[fa[x]]=d;fa[x]=x;--cnt;
}
int Solve(int k,int l,int r){
	int tim(cnt);
	for(int i(0);i<Node[k].size();++i){
		int e(Node[k][i]);
		Merge(E[e].u,E[e].v);
	} tim=cnt-tim;
	int res(-1);
	if(l^r){
		int ls(k<<1),rs(k<<1|1),mid(l+r>>1);
		int tmp(Solve(ls,l,mid));
		if(~tmp) res=tmp;
		else res=Solve(rs,mid+1,r);
	}
	else if(cnt>=n-1) res=l;
	for(int i(1);i<=tim;++i) Delete();
	return res;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i(1);i<=m;++i){
		int w;scanf("%d%d%d",&E[i].u,&E[i].v,&w);
		id[w].push_back(i);mx=max(mx,w);
	}
	for(int i(0);i<=mx;++i)
		for(int j(0);j<id[i].size();++j){
			if(i) Update(1,0,mx,0,i-1,id[i][j]);
			if(i^mx) Update(1,0,mx,i+1,mx,id[i][j]);
		}
	for(int i(1);i<=n;++i) fa[i]=i,dep[i]=1;
	printf("%d\n",Solve(1,0,mx));
	return 0;
}
```

---

## 作者：Arghariza (赞：0)

考虑如何判断能否让 $x$ 成为答案，把所有权值为 $x$ 的边删掉后，若图联通则有生成树，这样的生成树的边中一定不包含权值 $x$。所以这个删掉了所有 $w_e=x$ 的 $e$ 边后图联通是 $x$ 可以为答案的**必要条件**。

显然只要 $1\to x-1$ 都不能成为答案，那么满足上述必要条件即为最小的 $\text{mex}$ 值，这是充要的。

于是可以考虑线段树分治，当前分治区间 $[l,r]$ 表示权值在 $[l,r]$ 之间的边都不加进图里。每次递归就相当于加上权值在 $[l,mid]$ 或者 $[mid+1,r]$ 的边，使用可撤销并查集维护，优先跑左区间即可。

为了方便可以在递归的时候传一个区间 $L,R$，表示将边从小到大排序后最大的 $L$ 使得 $w_{e_L}< l$ 和最小的 $R$ 使得 $w_{e_R} > r$，递归的同时加边和撤销即可。

```cpp
#include <bits/stdc++.h>
namespace mystd {
	inline int read() {
	    char c = getchar();
	    int x = 0, f = 1;
	    while (c < '0' || c > '9') f = (c == '-') ? -1 : f, c = getchar();
	    while (c >= '0' && c <= '9') x = (x << 1) + (x << 3) + c - '0', c = getchar();
	    return x * f;
	}
	inline void write(int x) {
	    if (x < 0) x = ~(x - 1), putchar('-');
	    if (x > 9) write(x / 10);
	    putchar(x % 10 + '0');
	}
}
using namespace std;
using namespace mystd;

const int maxn = 2e6 + 200;
struct edge { int u, v, w; } e[maxn];
int n, m, fa[maxn], sz[maxn];
stack<int> op;

int getf(int x) { return x == fa[x] ? x : getf(fa[x]); }
void merge(int x, int y) {
	x = getf(x), y = getf(y);
	if (x == y) return;
	if (sz[x] > sz[y]) swap(x, y);
	fa[x] = y, sz[y] += sz[x], op.push(x);
}

void del(int tp) {
	while (op.size() > tp) {
		int x = op.top(); op.pop();
		sz[fa[x]] -= sz[x], fa[x] = x;
	}
}

#define mid ((l + r) >> 1)
void conquer(int l, int r, int lp, int rp) {
	if (l == r) {
		if (sz[getf(1)] == n) write(l), exit(0);
		return;
	}
	int tp = op.size(), pos = rp + 1;
	while (pos > 1 && e[pos - 1].w > mid) pos--, merge(e[pos].u, e[pos].v);
	conquer(l, mid, lp, pos - 1), del(tp), pos = lp - 1;
	while (pos < m && e[pos + 1].w <= mid) pos++, merge(e[pos].u, e[pos].v);
	conquer(mid + 1, r, pos + 1, rp), del(tp);
}

int main() {
	n = read(), m = read();
	for (int i = 1; i <= n; i++) fa[i] = i, sz[i] = 1;
	for (int i = 1; i <= m; i++) e[i] = (edge) { read(), read(), read() };
	sort(e + 1, e + m + 1, [](const edge &x, const edge &y) { return x.w < y.w; });
	conquer(0, e[m].w + 1, 1, m);
	return 0;
}

```

---


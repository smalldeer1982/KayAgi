# 「FAOI-R2」霜雪千年

## 题目背景

> 在这老街回眸 烟云中追溯我是谁  
只消暮雨点滴 便足以粉饰这是非  
待这月色涌起 谁人轻叩这门扉  
苔绿青石板街 斑驳了流水般岁月  
小酌三盏两杯 理不清缠绕的情结  
在你淡漠眉间 瞥见离人的喜悲霜雪

洛天依看到了一颗雪中的梨树，梨树的根中有有限的能量，它可以向上需要传递热量到其他节点。但风雪很大，每时每刻每个节点能量都会增加会增加或减少，热量过低的节点会掉落。

## 题目描述

具体来说，这棵梨树可以被抽象为一颗以 $1$ 号结点为根的树，初始时每个点都是白色。每个点有能量 $a_i$，初始时 $1$ 以外所有点的能量都为 $0$，$a_1=k$。我们设一个累计能量 $b$。

我们通过如下操作定义一个序列 $\{v_t\}$ 的权值：
- 从小到大度过 $1,2,3,\dots,t$ 这 $t$ 个时刻。
- 在第 $x$ 个时刻，执行 $b\gets b+v_x$。
- 对于树上的一条边 $(u,v)$，设 $u$ 为父亲，可以选定整数 $h\in[0,a_u]$ 执行操作 $a_u\gets a_u-h$，$a_v\gets a_v+h$，之后该时刻内形如 $(v,w)$ 且 $v$ 为父亲的边不能操作。
- 若一个点 $i$ 满足 $a_i+b<0$，将 $i$ 以及 $i$ 的子树中的点染成黑色。
- 执行最优操作以最大化第 $t$ 时刻后的白点个数，该序列权值即为最大白点个数。

定义一个序列 $\{v_t\}$ 合法当且仅当 $\forall i\in[1,t]$，$\lvert v_i\rvert\in[0,m]$。给定 $t$，求出所有合法序列 $\{v_t\}$ 的权值之和对 $998244353$ 取模后的值。

## 说明/提示

**【样例解释】**

样例 $3$ 解释：

对于一种 $\{v_3\}=\{1,0,-2\}$ 的情况，一种最优操作如下：
- 第一个时刻，$1$ 号结点传递 $4$ 能量给 $2$ 号结点，操作完毕后 $a=\{1,4,0,0,0\}$，$b=1$。
- 第二个时刻，$2$ 号结点传递 $2$ 能量给 $4$ 号结点，操作完毕后 $a=\{1,2,0,2,0\}$，$b=1$。
- 第三个时刻，$2$ 号结点传递 $1$ 能量给 $3$ 号结点，$4$ 号结点传递 $1$ 能量给 $5$ 号结点，操作完毕后 $a=\{1,1,1,1,1\}$，$b=-1$。
- 所有时刻结束，因为始终没有 $a_i+b<0$ 的点，所以所有结点为白色。

样例 $4$ 解释：

对于一种 $\{v_{6}\}=\{1,2,1,2,1,2\}$ 的情况，一种最优操作如下：
- 第 $1\sim 6$ 个时刻，不进行操作。
- 所有时刻结束，因为始终没有 $a_i+b<0$ 的点，所以所有结点为白色。

**【数据范围】**

**本题采用捆绑测试。**

| Subtask 编号 | $n \le$ | $m \le$ | $t \le$ | $k \le$ | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $4$ | $4$ | $4$ | $40$ | $20$ | × |
| $1$ | $2 \times 10^5$ | $20$ | $20$ | $1 \times 10^5$ | $10$ | $\checkmark$ |
| $2$ | $2 \times 10^5$ | $20$ | $20$ | $3 \times 10^5$ | $20$ | × |
| $3$ | $2 \times 10^5$ | $50$ | $100$ | $3 \times 10^5$ | $10$ | × |
| $4$ | $2 \times 10^5$ | $50$ | $500$ | $3 \times 10^5$ | $40$ | × |

特殊性质：保证树的形态是菊花。

对于 $100\%$ 的数据，$1\leq n\leq 2\times 10^5$，$1\leq k\leq 3\times 10^5$，$1\leq m\leq 50$，$1\leq t\leq 500$，保证输入构成一棵树。

**【其他】**

本题原名梨花开，介于赛时题面有误，且原题面可读性较低，于 2024 年 3 月重写题面并改名。改标题不便赛时选手重新找到该题，但出题人意识到时修改已久，不便改回。在此致歉。

与 2025 年 8 月将题面中的“热量”改为“能量”。

## 样例 #1

### 输入

```
1 1 1 1```

### 输出

```
3```

## 样例 #2

### 输入

```
3 1 2 2
1 2
1 3```

### 输出

```
22```

## 样例 #3

### 输入

```
5 2 3 5
1 2
2 3
2 4
4 5```

### 输出

```
407```

## 样例 #4

### 输入

```
10 5 6 44
1 2
1 3
2 5
2 6
3 4
6 7
6 8
4 9
9 10```

### 输出

```
10465095```

# 题解

## 作者：喵仔牛奶 (赞：5)

复杂度较劣，需要卡常才能通过的 NTT 题解。

# Solution

由于树的节点数没有什么用，下文将题面中的 $n,t$ 对调。

## Part I

记前缀和 $s_i=\sum_{j=1}^{i}v_i$。

观察发现可以选定一些点，将所有热量供给给它们，不管其他点。

需要养活这些点，就要在第一个 $s_p<0$ 的时刻点 $p$ 给它们 $-\min_{j=1}^{n}\{s_j\}$ 的热量（每个时刻可以传递无限热量，最优情况就是一次传递所有需要的热量）。

那么定义根节点深度为 $0$，$siz_i$ 为深度 $\leq i$ 的点数，一种方案的答案即为 $\min\{-k/\min_{j=1}^{n}\{s_j\},siz_p\}$（其中 $p$ 为第一个 $s_p<0$ 的时刻）。

暴力枚举 $\{v_n\}$ 即可。时间复杂度 $\mathcal{O}((2m+1)^n)$，期望得分 $20$。

## Part II

考虑把它变成式子的形式。

先做一些预处理：
- $f_{i,j}$ 表示长度为 $i$ 的，所有数 $\in[-m,m]$，任意前缀和非负，所有数和为 $j$ 的序列数。
- $g_{i,j}$ 表示长度为 $i$ 的，所有数 $\in[-m,m]$，任意前缀和为正，所有数和为 $j$ 的序列数。
- $pre_{i,j}=\sum_{k=0}^{j}f_{i,k}$。
- $s_{a,v}=\sum_{b=a+1}^{n}g_{b-a,v}\times pre_{n-b,nm}$。

记前缀和 $s_i=\sum_{j=1}^{i}v_i$。

枚举 $a$ 为前缀和中第一个负数的位置，$b$ 为前缀和中全局最小的位置，$c$ 为 $s_a$，$d$ 为 $s_b$。

- 为了避免算重，多个最小值在第一个最小值处算贡献。
- 对于 $a=b$ 和前缀和不存在负数的情况要特判算贡献。

则答案为：
$$
\begin{aligned}
&t\times\left(\sum_{i=0}^{nm}f_{n,i}\right)+\sum_{a=1}^{n}\sum_{c=-m}^{-1}\left(\sum_{i=0}^{c+m}f_{a-1,i}\right)\times\left(\min\{-k/c,siz_a\}\times \left(\sum_{i=0}^{nm}f_{n-a,i}\right)+\sum_{b=a+1}^{n}\sum_{d=-nm}^{c-1}\min\{-k/d,siz_a\}\times g_{b-a,c-d}\times\left(\sum_{i=0}^{nm}f_{n-b,i}\right)\right)\\
=&t\times pre_{n,nm}+\sum_{a=1}^{n}\sum_{c=-m}^{-1}pre_{a-1,c+m}\times\left(\min\{-k/c,siz_a\}\times pre_{n-a,nm}+\sum_{d=-nm}^{c-1}\min\{-k/d,siz_a\}\times s_{a,c-d}\right)
\end{aligned}
$$

直接暴力算就能做到 $\mathcal{O}(n^2m^2)$，获得 $50$ 分。

## Part III

然后是优化这个式子。

- 考虑贡献中的 $\min\{-k/d,siz_a\}$，可以除法分块，预处理 $\{s_{a}\}$ 的前缀和即可做到 $\mathcal{O}(nm\sqrt{k})$。
- 然后是预处理 $s_{a,v}=\sum_{b=a+1}^{n}g_{b-a,v}\times pre_{n-b,nm}=\sum_{b=1}^{n-a}g_{b,v}\times pre_{n-a-b,nm}$，这是多项式乘法的形式，可以 NTT 做到 $\mathcal{O}(n^2m\log n)$。
- 预处理 $f,g$ 的话，可以前缀和优化做到 $\mathcal{O}(n^2m)$。

时间复杂度 $\mathcal{O}(nm(n\log n+\sqrt{k}))$，使用极限卡常手段之后开上 O2 可过。

---

## 作者：_lbw_ (赞：4)

我们考虑在 $v$ 确定后如何得到答案.

为了方便,将题目中的 $v$ 取相反数,$M_i$ 表示 $v$ 的前缀和前 $i$ 项最小值.

容易发现,若我们选取了一定的节点,则我们想要尽可能把热量传递到这些点.

如果点 $u$ 满足 $M_{dep_u}\leq0$ 则这个点是有可能被传到的,否则热量还没传到这个点已经冷死了.

另一个限制是 $k$ 的热量的分配,每个点必须被分配到 $M_t$ 热量.

于是写出如下暴力:

```cpp
IV calc(){
	F(i,1,t)M[i]=M[i-1]+v[i];
	F(i,1,t)M[i]=max(M[i],M[i-1]);i64 cnt=1;
	F(i,2,n)if(M[min(dep[i]-1,t)]==0)cnt++;
	i64 v;if(!M[t])v=n;else v=min(k/M[t],n);ans+=min(cnt,v);
}
IV dfs(i64 u){
	if(u==t+1)return calc();
	F(i,-m,m)v[u]=i,dfs(u+1);
}
```

现在考虑如何优化,记 $\sum\limits_{dep_i-1\leq k}1$ 为 $\textsf{sum}_k$.

我们关心两个数的值: $M_t$ 和 $M$ 首次大于 $0$ 的位置.

根据经验,前缀和的最小值如果倒着 dp 会很好做,每次让 $M\to\max(M+v,0)$ 即可,但这跟 $M$ 首次大于 $0$ 的限制冲突.

于是设 $f_{i,j}$ 表示在 $i$ 时刻前缀和第一次大于 $0$,前缀和等于 $j$ 的方案数$(j\leq m)$,$g_{i,j}$ 表示倒着做 $i$ 次,$M=j$ 的方案数.

$f,g$ 可以用前缀和优化 dp 在 $\mathcal{O}(mt^2)$ 内计算.

特判掉 $M_t=0$ 的情况,答案即为:

$$\sum\limits_{p=0}^{t-1}\sum\limits_{x=1}^{m}\sum\limits_{i=0}^{mt}\min(\dfrac{k}{i+x},\textsf{sum}_p)f_{p,x}g_{n-p-1,i}$$

这时,枚举 $p$,对后两维做卷积,可以做到 $\mathcal{O}(mt^2\log m)$ 的复杂度.

但我们可以注意到 $k$ 这个**几乎**没用的数较小,于是对 $\dfrac{k}{i+x}$ 整除分块.

枚举前两维,整除分块后对 $i$ 的限制转为了上下界限制,前缀和优化即可.

时间复杂度 $\mathcal{O}(mt(\sqrt{k}+t))$.

```cpp
#include "assert.h"
mt19937_64 rnd(her1);
using i64 = long long;
IV cadd(i64&x,i64 val){x=(x+val)%cht;}
const int maxn = 3e5+5;vector<i64>G[maxn];
i64 n,m,t,k,dep[maxn],v[maxn],mn[maxn],ans,sum[maxn];
IV dfs(i64 u,i64 F){
	for(i64 v:G[u])if(v^F)dep[v]=dep[u]+1,dfs(v,u);
	dep[u]=max(dep[u]-1,0ll);sum[min(dep[u],t)]++;
}
const i64 MAX = 500*50;
i64 f[505][MAX+5],g[505][MAX+5],s2[MAX+5],coef[505][505],pre[505][MAX+5];
IV init(){
	f[0][MAX]=1;
	F(i,1,t){
		s2[0]=f[i-1][0];
		F(j,1,MAX)s2[j]=f[i-1][j],cadd(s2[j],s2[j-1]);
		F(j,0,MAX){
			i64 l=max(j-m,0ll),r=min(j+m,MAX);
			f[i][j]=(s2[r]-(l?s2[l-1]:0)+cht)%cht;
		}
		F(ed,1,m)F(j,MAX-ed+1,MAX)cadd(coef[i-1][ed+j-MAX],f[i-1][j]);
	}
	g[0][0]=1;
	F(i,1,t){
		F(j,0,MAX)if(g[i-1][j]){
			i64 l=j-m,r=j+m;
			if(l<=0)cadd(g[i][0],g[i-1][j]*(1-l));
			l=max(l,1ll);cadd(g[i][r],g[i-1][j]),cadd(g[i][l-1],-g[i-1][j]);
		}
		D(j,MAX,1)cadd(g[i][j-1],g[i][j]);
	}
	F(i,0,t){
		pre[i][0]=g[i][0];
		F(j,1,MAX)pre[i][j]=(pre[i][j-1]+g[i][j])%cht;
	}
}
i64 L[maxn],R[maxn],V[maxn];
int main(){
	// freopen("1.in","r",stdin);
	// freopen("1.out","w",stdout);
	n=read();m=read();t=read();k=read();
	F(i,1,n-1){
		i64 u=read(),v=read();
		G[u].push_back(v);G[v].push_back(u);
	}
	
	dfs(1,0);F(i,1,t)sum[i]+=sum[i-1];init();
	i64 ans=0,tot=0;F(i,0,MAX)cadd(ans,f[t][i]*n);
	for(int l=1,r;l<=k;l=r+1)r=k/(k/l),L[++tot]=l,R[tot]=r,V[tot]=k/l;
	F(p,0,t-1)F(x,1,m)F(i,1,tot){
		i64 nl=L[i]-x,nr=R[i]-x;nl=max(nl,0ll);nr=min(nr,MAX);
		if(nl<=nr)cadd(ans,coef[p][x]*(pre[t-p-1][nr]-(nl?pre[t-p-1][nl-1]:0))%cht*min(sum[p],V[i]));
	}
	return cout<<(ans+cht)%cht,0;
}
```







---

## 作者：win114514 (赞：3)

比较有意思的 dp 题。

### 思路

考虑答案至少为 $p$ 的条件是什么。

1. 我们显然会把根节点的热量平均分配到深度前 $p$ 小的点上，那么要求 $\min_{j=1}^n \sum_{i=1}^j v_i+ \frac{k}{p}\ge 0$。
2. 其次，在热量到达前 $k$ 小的点前，$\sum_{i=1} v_i$ 不可以小于 $0$。

只要满足了这两个条件，我们的答案就至少为 $p$，假设这样的方案数为 $f_p$。

那么答案为：

$$\sum f_p$$

如何求解。

设 $dp_{i,j}$ 为第 $i$ 步后 $\sum_{k=1}^{i}v_k=j$ 的方案数。

在转移时可以判断一下是否合法即可。

转移可以用前缀和优化。

复杂度：$O(nmt^2)$。

可以获得 $20$ 分。

发现我们的限制只和 $dep_i$ 与 $\frac{k}{p}$ 有关。

因为操作只有 $t$ 次，所以要求 $dep_i\le t$。

而根据整除分块，$\frac{k}{p}$ 只有根号项，所以记忆化一下，可以优化复杂度。

复杂度：$O((t+\sqrt n)mt^2)$。

视常数可以获得 $50\sim 60$ 分。

容易发现我们满足前缀和不小于 $0$ 的 dp 都是一样的操作。

那么我们可以进行预处理。

设 $f_{i,j}$ 表示在 $i$ 轮后满足前缀和一直不小于 $0$，且 $\sum_{k=1}^i v_k=j$ 的方案数。

转移同样枚举下一位然后前缀和优化。

同样，我们想要仿造的求出 $g_{i,j}$ 表示 $i$ 轮后满足前缀和一直不小于 $j$ 的方案数。

这是我们直接 dp 的后半段。

这个怎么求呢？

这类问题好像有一个比较常见的 trick。

就是在维护前缀和的最小值时，我们正着不好做，但是反过来是很好求的。

考虑反过来怎么求前缀和的最小值：

$$
sum\rightarrow min(0,sum+v)
$$

这个式子我们就可以 dp 了。

求出了 $g_{i,j}$ 以后，就可以轻松搭配 $f_{i,j}$ 求出这个询问的答案了。

时间复杂度：$O((\sqrt k+t)mt+mt^2)$。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

#define eb(...) emplace_back(__VA_ARGS__)
#define fro(i, x, y) for (int i = (x); i <= (y); i++)
#define pre(i, x, y) for (int i = (x); i >= (y); i--)

const int N = 1e6 + 10;
const int mod = 998244353;

int n, m, t, k, ans, d[N], R[N], sm[N];
int dp1[510][30000];
int dp2[510][30000];
vector<int> to[N];

inline void dfs(int x, int f) {
  d[x] = d[f] + 1;
  for (auto i : to[x])
    if (i != f) dfs(i, x);
}
inline void add(int&x, int y) {
  x = (x + y >= mod ? x + y - mod : x + y);
}

signed main() {
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> n >> m >> t >> k;
  fro(i, 1, n - 1) {
    int u, v;
    cin >> u >> v;
    to[u].eb(v);
    to[v].eb(u);
  }
  dfs(1, 0);
  sort(d + 1, d + n + 1);
  dp1[0][R[0] = 0] = dp2[0][R[0] = 0] = 1;
  fro(i, 1, t) {
    fro(j, 0, R[i - 1]) {
      add(dp1[i][max(0, j - m)], dp1[i - 1][j]);
      add(dp1[i][j + m + 1], mod - dp1[i - 1][j]);
      add(dp2[i][max(0, j - m)], dp2[i - 1][j]);
      add(dp2[i][j + m + 1], mod - dp2[i - 1][j]);
    }
    R[i] = R[i - 1] + m;
    fro(j, 1, R[i] + 1) add(dp1[i][j], dp1[i][j - 1]);
    fro(j, 1, R[i] + 1) add(dp2[i][j], dp2[i][j - 1]);
    fro(j, 0, R[i - 1]) if (m - j > 0) add(dp2[i][0], 1ll * (m - j) * dp2[i - 1][j] % mod);
  }
  fro(i, 1, t) fro(j, 1, R[i]) add(dp2[i][j], dp2[i][j - 1]);
  fro(i, 1, n) {
    int v = k / i, p = min(t + 2, d[i]);
    if (i == 1) {
      sm[i] = dp2[t][min(v, R[t])];
    } else if (v != k / (i - 1) || p != min(t + 2, d[i - 1])) {
      int l = p - 2;
      int r = t - p + 2;
      fro(j, 0, R[l]) add(sm[i], 1ll * dp1[l][j] * dp2[r][min(v + j, R[r])] % mod);
    } else sm[i] = sm[i - 1];
    add(ans, sm[i]);
  }
  cout << ans << "\n";
  return 0;
}
```

---

## 作者：zyn_ (赞：0)

## 题目大意

为了更好地理解题意，稍微改写一下题面。

有一棵以 $1$ 为根的 $n$ 个结点的梨树。初始根结点有 $k$ 点热量，其余结点的热量为 $0$。环境有一个「严寒值」 $\color{red}-b$。记结点 $i$ 的热量为 $a_i$。另有一个长为 $t$ 的整数序列 $\{v_i\}$，满足对任意 $i$，$v_i\in[-m,m]$。

接下来的 $t$ 个时刻，以下三个事件依次发生：

1. 所有结点可以同时向自己的任意个子结点分别传递任意正整数点热量，但是需保证传递热量后自己的热量非负。「同时」意味着一个时刻从 $u\to v$ 的热量，不能再从 $v\to w$。
2. 「严寒值」发生变化，$-b\gets -b-v_i$。
3. 对于每个结点 $p$，若此结点的热量小于「严寒值」，即 $a_i<-b$，则以此结点为根的子树从树上脱落。

序列 $\{v_i\}$ 的权值为最优策略下 $t$ 个时刻过去后树的剩余结点个数。求所有可能的序列的权值和。

$n\le 2\times 10^5$，$m\le 50$，$t\le 500$，$k\le 3\times 10^5$。

~~话说热量不是过程量吗，为什么每个结点可以有热量？~~

## 策略

考虑固定 $\{v_i\}$ 怎么求权值。

首先要注意到热量只能**自上而下**流，并且热量过低会导致**整棵子树**脱落。

当「严寒值」第一次来到正数（即 $b$ 第一次 $<0$）时，所有热量为 $0$ 的结点都会脱落。设这个时刻是 $x_0$，在这之前只能传 $x_0$ 次热，那么最终存留的结点的深度一定 $\le x_0+1$。（我们规定根节点的深度为 $1$。）

这里有一个特殊情况：若 $x_0$ 不存在，则「严寒值」始终非正，那么所有结点不可能脱落，于是权值为 $n$。接下来设 $x_0$ 存在。

考虑环境最恶劣的时候——设在时刻 $x$，环境的「严寒值」达到最大值 $y$。由定义知 $x\ge x_0$。为了熬过这个时刻，未脱落的结点都需要至少 $y$ 点热量。并且，所有结点全程不刚需超过 $y$ 点热量以保持不脱落。

因此可以贪心：时刻 $1$，根节点向所有子结点传热，只给自己留 $y$ 点热量，之后不再传热；时刻 $i$，所有深度为 $i$ 的结点向深度为 $i+1$ 的结点传热，只给自己留 $y$ 点热量，之后不再传热。

这样，由于总热量守恒，恒为 $k$，因此至多有 $\lfloor\frac{k}{y}\rfloor$ 个结点最终不脱落，且只有深度 $\le x_0+1$ 的结点不脱落。

记深度 $\le d$ 的结点有 $cnt_d$ 个，则权值为

$$
\min\{\lfloor\frac{k}{y}\rfloor,cnt_{x_0+1}\}
$$

## 计数 DP

权值只和 $x_0,y$ 有关。需要求出 $c_{x,y}$ 表示「严寒值」在时刻 $x$ 第一次成为正数，且「严寒值」的最大值为 $y$，这样的序列 $\{v_i\}$ 的个数。由于共有 $t$ 个时刻，每个时刻「严寒值」的变化量 $-v_i\in [-m,m]$，因此 $x\in [1,t]$，$y\in [1,mt]$。状态数是 $O(mt^2)$ 的。

考虑将「严寒值」的变化分成 $x$ 时刻及以前与 $x$ 时刻后两个阶段。需要枚举 $x$ 时刻的「严寒值」。设 $f_{i,j}$ 为 $i$ 时刻「严寒值」第一次成为正数，且这个正数为 $j$，这样的序列 $\{v_i\}$ 的个数。这里 $i\in [1,t]$，$j\in [1,m]$，因此状态数是 $O(mt)$ 的。

$i$ 时刻后，对 $\{v_i\}$ 的限制是，不能使「严寒值」升到 $y$ 以上，但又必须有一个时刻「严寒值」为 $y$。这很麻烦，于是我们**重定义** $c_{x,y}$ 为表示「严寒值」在时刻 $x$ 第一次成为正数，且「严寒值」全程 $\le y$ 时，序列 $\{v_i\}$ 的个数。

这时，设 $g_{i,j}$ 表示每个时刻「严寒值」的变化量 $\in [-m,m]$，经过 $i$ 个时刻后「严寒值」从不超过初始值 $+j$ 的方案数。（当然，如果 $j<0$，则 $g_{i,j}=0$。）有效状态满足 $i\in [1,t]$，$j\in [1,mt]$，有 $O(mt^2)$ 个。于是

$$
c_{x,y}=\sum_{i=1}^m f_{x,i}g_{t-x,y-i}
$$

现在计算 $f_{i,j}$ 与 $g_{i,j}$。

### $f$

考虑 DP，设 $dp_{i,j}$ 表示初始「严寒值」为 $0$，经过 $i$ 个时刻后「严寒值」为 $-j$，且全程「严寒值」非正的方案数。于是 $dp_{0,0}=1$，$dp_{0,i}=0$（$i\neq 0$），$dp_{i,j}=0$（$j<0$）。这里 $i\in [1,t]$，$j\in [1,mt]$，故状态数为 $O(mt^2)$。有转移：

$$
dp_{i,j}=\sum_{j_0=j-m}^{j+m}dp_{i-1,j_0}
$$

显然可以前缀和优化至 $O(mt^2)$。

第 $i$ 个时刻后「严寒值」为 $j$，意味着第 $i-1$ 个时刻的「严寒值」$\ge j-m$。于是

$$
f_{i,j}=\sum_{j_0=0}^{m-j}dp_{i-1,j_0}
$$

也可以前缀和优化至 $O(mt)$。

### $g$

直接对 $g$ DP。$g_{0,j}=[j\ge 0]$，$g_{i,j}=0$（$j<0$），转移为

$$
g_{i,j}=\sum_{j_0=j-m}^{j+m}g_{i-1,j_0}
$$

前缀和优化至 $O(mt^2)$。

## 统计答案

现在我们用 $O(mt^2)$ 的时间复杂度求出了 $f_{i,j},g_{i,j}$。

$$
c_{x,y}=\sum_{i=1}^m f_{x,i}g_{t-x,y-i}
$$

$c_{x,y}$ 有 $O(mt^2)$ 个，因此可以在 $O(m^2t^2)$ 的时间内计算出所有 $c_{x,y}$。并且，根据修改的定义，「严寒值」在时刻 $x$ 第一次成为正数，且「严寒值」的最大值为 $y$，这样的序列 $\{v_i\}$ 的个数为 $c_{x,y}-c_{x,y-1}$。还记得吗？每个这样的序列的权值为

$$
\min\{\lfloor\frac{k}{y}\rfloor,cnt_{x+1}\}
$$

因此答案为

$$
\sum_{x=1}^t\sum_{y=1}^{mt}\min\{\lfloor\frac{k}{y}\rfloor,cnt_{x+1}\}(c_{x,y}-c_{x,y-1})
$$

时间复杂度 $O(n+m^2t^2)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 200009
#define M 52
#define T 502
#define S 25002
#define pb push_back
#define ll long long
#define mod 998244353
int n,m,t,k,a,b,dep[N],cnt[N],dp[T][S*2],s[T][S*2],l,r,c[T][S],f[T][S],ans;
vector<int> v[N];
void dfs(int p,int f){
    ++cnt[dep[p]=dep[f]+1];
    for(int i:v[p])if(i!=f)dfs(i,p);
}
int main(){
    scanf("%d%d%d%d",&n,&m,&t,&k);
    for(int i=1;i<n;++i)scanf("%d%d",&a,&b),v[a].pb(b),v[b].pb(a);
    dfs(1,0);for(int i=1;i<=max(n,t+1);++i)cnt[i]+=cnt[i-1];
    dp[0][0]=1;for(int j=0;j<=m*t*2;++j)s[0][j]=1;
    for(int i=1;i<=t;++i){
        for(int j=0;j<=m*t*2;++j){
            l=max(j-m,0);r=min(j+m,m*t*2);
            dp[i][j]=s[i-1][r]-(l?s[i-1][l-1]:0);
            if(dp[i][j]<0)dp[i][j]+=mod;
            s[i][j]=(j?s[i][j-1]:0)+dp[i][j];
            if(s[i][j]>=mod)s[i][j]-=mod;
        }
        for(int j=1;j<=m;++j)f[i][j]=s[i-1][m-j];
    }
    for(int j=0;j<=m*t*2;++j)dp[0][j]=1,s[0][j]=j+1;
    for(int i=1;i<=t;++i)for(int j=0;j<=m*t*2;++j){
        l=max(j-m,0);r=min(j+m,m*t*2);
        dp[i][j]=s[i-1][r]-(l?s[i-1][l-1]:0);
        if(dp[i][j]<0)dp[i][j]+=mod;
        s[i][j]=(j?s[i][j-1]:0)+dp[i][j];
        if(s[i][j]>=mod)s[i][j]-=mod;
    }
    for(int x=1;x<=t;++x)for(int y=1;y<=m*t;++y)
        for(int i=1;i<=min(m,y);++i)
            c[x][y]=(c[x][y]+f[x][i]*(ll)dp[t-x][y-i])%mod;
    ans=((ll)dp[t][0])*n%mod;
    for(int x=1;x<=t;++x)for(int y=1;y<=m*t;++y)
        ans=(ans+min(cnt[x+1],k/y)*((ll)c[x][y]-c[x][y-1]+mod))%mod;
    printf("%d\n",ans);
    return 0;
}
```

稍微一算，$m^2t^2\le 50^2\times 500^2=6.25\times 10^8$。既然本题的时间限制为 $2$ 秒，那么常数较小或许可以通过……？但是瓶颈在计算 $c_{x,y}$ 上：

```cpp
for(int x=1;x<=t;++x)for(int y=1;y<=m*t;++y)
    for(int i=1;i<=min(m,y);++i)
        c[x][y]=(c[x][y]+f[x][i]*(ll)dp[t-x][y-i])%mod;
```

怎么这里必须要取模呀？！不妙不妙。不管了，先交一发试试。

[于是……](https://www.luogu.com.cn/record/223130160)

$$
\texttt{\color{darkblue}2.08s TLE}
$$

犹记得上次荣获 $1.04$ 倍时间限制还是[上次](https://www.luogu.com.cn/article/6m99bq62)，那么稍微卡卡不就过了？

可惜这次……快读没用了。怎么办呢？

$m^2t^2$ 次取模实在是太多，哪怕砍掉一半都可以使程序加速不少。

注意到每次 `c[x][y]` 的增量 `f[x][i]*(ll)dp[t-x][y-i]` 至多是 $(p-1)^2$（这里 $p=998244353$ 为模数），这样不取模地加 $8$ 次，再取一次模，`c[x][y]` 全程不超过 $p+8(p-1)^2=7971934291397443585<9223372036854775807=2^{63}-1$，没有溢出风险。这时，一个大幅优化常数的方法已经呼之欲出……

## 循环展开

举个例子：

```cpp
int calc(int n,int *x){
    int sum=0;
    for(int i=0;i<n;++i)sum+=x[i];
    return sum;
}
```

可以展开成这样：

```cpp
int calc(int n,int *x){
    int sum[4]={0,0,0,0},i;
    for(i=0;i<n-4;i+=4){
        sum[0]+=x[i];
        sum[1]+=x[i+1];
        sum[2]+=x[i+2];
        sum[3]+=x[i+3];
    }
    if(i<n)sum[0]+=x[i];
    if(i+1<n)sum[1]+=x[i+1];
    if(i+2<n)sum[2]+=x[i+2];
    if(i+3<n)sum[3]+=x[i+3];
    return sum[0]+sum[1]+sum[2]+sum[3];
}
```

为什么这样写会加速呢？因为这样 `sum[0...3]` 的计算是独立的，可以更好地激化 **CPU 并发**。更详细的解释可以参见 [[WC2017] 挑战](https://www.luogu.com.cn/problem/P4604) 的题解，以及 [OI-wiki](https://oi-wiki.org/lang/optimizations) 的一些讲解。

于是本题中我们可以类似地展开这段代码：

```cpp
for(int x=1;x<=t;++x)for(int y=1;y<=m*t;++y)
    for(int i=1;i<=min(m,y);++i)
        c[x][y]=(c[x][y]+f[x][i]*(ll)dp[t-x][y-i])%mod;
```

我们记 `sum[0...7]`，将 $i\bmod 8=j$ 的 $f_{x,i}g_{t-x,y-i}$ 记录在 `sum[j]` 里。（这里为了卡空间 `dp[i][j]` 即为 $g_{i,j}$。）

注意到 $m\le 50$，因此每个 `sum[j]` 至多被加 $\lceil\frac{m}{8}\rceil=7<8$ 次，因此累加 `sum[j]` 时**不用取模**。最后把 `sum[j]` 加在一起时，再对每个 `sum[j]` 取模即可。这样，不仅激化了 CPU 并发，并且总取模次数大大减少，于是可以[稳定通过](https://www.luogu.com.cn/record/223137543)。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 200009
#define M 52
#define T 502
#define S 25002
#define pb push_back
#define ll long long
#define mod 998244353
int n,m,t,k,p,a,b,dep[N],cnt[N],dp[T][S*2],s[T][S*2],l,r,c[T][S],f[T][S],ans;
vector<int> v[N];
void dfs(int p,int f){
    ++cnt[dep[p]=dep[f]+1];
    for(int i:v[p])if(i!=f)dfs(i,p);
}
int main(){
    scanf("%d%d%d%d",&n,&m,&t,&k);p=m*t;
    for(int i=1;i<n;++i)scanf("%d%d",&a,&b),v[a].pb(b),v[b].pb(a);
    dfs(1,0);for(int i=1;i<=max(n,t+1);++i)cnt[i]+=cnt[i-1];
    dp[0][0]=1;for(int j=0;j<=p;++j)s[0][j]=1;
    for(int i=1;i<=t;++i){
        for(int j=0;j<=p;++j){
            l=max(j-m,0);r=min(j+m,p);
            dp[i][j]=s[i-1][r]-(l?s[i-1][l-1]:0);
            if(dp[i][j]<0)dp[i][j]+=mod;
            s[i][j]=(j?s[i][j-1]:0)+dp[i][j];
            if(s[i][j]>=mod)s[i][j]-=mod;
        }
        for(int j=1;j<=m;++j)f[i][j]=s[i-1][m-j];
    }
    for(int j=0;j<=(p<<1);++j)dp[0][j]=1,s[0][j]=j+1;
    for(int i=1;i<=t;++i)for(int j=0;j<=(p<<1);++j){
        l=max(j-m,0);r=min(j+m,p<<1);
        dp[i][j]=s[i-1][r]-(l?s[i-1][l-1]:0);
        if(dp[i][j]<0)dp[i][j]+=mod;
        s[i][j]=(j?s[i][j-1]:0)+dp[i][j];
        if(s[i][j]>=mod)s[i][j]-=mod;
    }
    for(int x=1;x<=t;++x)for(int y=1;y<=p;++y){
        r=min(m,y);static ll sum[8];
        sum[0]=sum[1]=sum[2]=sum[3]=sum[4]=sum[5]=sum[6]=sum[7]=0;
        for(int i=0;i<(r>>3);++i){
            sum[0]=sum[0]+f[x][i<<3|1]*(ll)dp[t-x][y-(i<<3|1)];
            sum[1]=sum[1]+f[x][i<<3|2]*(ll)dp[t-x][y-(i<<3|2)];
            sum[2]=sum[2]+f[x][i<<3|3]*(ll)dp[t-x][y-(i<<3|3)];
            sum[3]=sum[3]+f[x][i<<3|4]*(ll)dp[t-x][y-(i<<3|4)];
            sum[4]=sum[4]+f[x][i<<3|5]*(ll)dp[t-x][y-(i<<3|5)];
            sum[5]=sum[5]+f[x][i<<3|6]*(ll)dp[t-x][y-(i<<3|6)];
            sum[6]=sum[6]+f[x][i<<3|7]*(ll)dp[t-x][y-(i<<3|7)];
            sum[7]=sum[7]+f[x][(i+1)<<3]*(ll)dp[t-x][y-((i+1)<<3)];
        }
        for(int i=(r>>3<<3)+1;i<=r;++i)
            c[x][y]=(c[x][y]+f[x][i]*(ll)dp[t-x][y-i])%mod;
        for(int i=0;i<8;++i)c[x][y]=(c[x][y]+sum[i])%mod;
    }
    ans=((ll)dp[t][0])*n%mod;
    for(int x=1;x<=t;++x)for(int y=1;y<=p;++y)
        ans=(ans+min(cnt[x+1],k/y)*((ll)c[x][y]-c[x][y-1]+mod))%mod;
    printf("%d\n",ans);
    return 0;
}
```

## 卷积

$$
c_{x,y}=\sum_{i=1}^m f_{x,i}g_{t-x,y-i}
$$

这是一个卷积形式，可以写成

$$
c_{x,y}=\sum_{y=i+j} f_{x,i}g_{t-x,j}
$$

就是 $f_x$ 与 $g_{t-x}$ 的卷积了。使用 FFT 或 NTT 即可做到 $O(mt^2\log(mt))$。

虽然理论复杂度更优，但是由于 $m\le 50$，$t\le 500$，这个做法完全没有优势，不仅繁琐，而且常数大，还不易卡常，能不能过都成问题，配不上优美的题目名称。

## 整除分块

答案为

$$
\sum_{x=1}^t\sum_{y=1}^{mt}\min\{\lfloor\frac{k}{y}\rfloor,cnt_{x+1}\}(c_{x,y}-c_{x,y-1})
$$

突然注意到了 $\lfloor\frac{k}{y}\rfloor$ 并发现它至多只有 $O(\sqrt k)$ 种取值。又发现 $k\le 3\times 10^5$ 但是前面的推导中这个范围形同虚设（为什么不开到 $\ge 10^7$ 呢？），还发现 $mt\sqrt k$ 的复杂度应该挺对，看来整除分块的做法太真了。

但是直接整除分块好像不太行……

考虑代入 $c_{x,y}$。这个 $c_{x,y}-c_{x,y-1}$ 比较麻烦，我们只算前半：

$$
\sum_{x=1}^t\sum_{y=1}^{mt}\min\{\lfloor\frac{k}{y}\rfloor,cnt_{x+1}\}\sum_{i=1}^m f_{x,i}g_{t-x,y-i}
$$

交换和号：

$$
\sum_{i=1}^m\sum_{x=1}^t\sum_{y=1}^{mt}\min\{\lfloor\frac{k}{y}\rfloor,cnt_{x+1}\} f_{x,i}g_{t-x,y-i}
$$

现在令 $y-i=z$。

$$
\sum_{i=1}^m\sum_{x=1}^t\sum_{z=1-i}^{mt-i}\min\{\lfloor\frac{k}{z+i}\rfloor,cnt_{x+1}\} f_{x,i}g_{t-x,z}
$$

枚举 $i,x,\lfloor\frac{k}{z+i}\rfloor$。现在 $z$ 有两个区间限制，一个是自身的求和号，一个是 $\lfloor\frac{k}{z+i}\rfloor$ 的整除分块。前面的 $\min\{\lfloor\frac{k}{z+i}\rfloor,cnt_{x+1}\} f_{x,i}$ 全是定值，而 $\sum g_{t-x,z}$ 可以前缀和优化。

于是时间复杂度来到了 $O(n+mt^2+mt\sqrt k)$。

> 在这亭台回眸 千年后忆起你是谁  
> 只消月色隐约 便足以勾勒这是非  
> 待这回忆涌起 恍惚之间已下泪  
> 枫红十里长街 红帘后谁人蹙着眉  
> 遥梦桑竹桃源 轮回中曾道别的地点  
> 愿今生再相见 消融你眉间悲戚霜雪

---


# [DTCPC 2024] 戈布

## 题目描述

对于 $01$ 序列 $\{a_n\}$，找到最小的 $k$ 满足存在一组 $\{(l_k,r_k)\}$使得以下条件成立。

- $\forall i\in[1,n]$，$a_i=1$ 当且仅当 $\exist  j\in[1,k]$，$i\in[l_j,r_j]$。

可以证明满足条件的 $\{(l_k,r_k)\}$ 仅有一个。

一个 $01$ 序列 $\{a_n\}$ 是好的当且仅当 $\forall i\in[1,k)$，$r_i-l_i<r_{i+1}-l_{i+1}$。

简单来说，一个 $01$ 序列是好的当且仅当从左到右形成的极长 $1$ 段长度严格递增。

给定序列 $\{a_n\}$，你可以进行如下操作若干次（或不进行操作）：

- 选择 $i,j(i\ne j)$，交换 $a_i,a_j$。

试求最小的操作次数使得 $\{a_n\}$ 变成一个好的序列。

## 样例 #1

### 输入

```
01101```

### 输出

```
1```

## 样例 #2

### 输入

```
01011```

### 输出

```
0```

# 题解

## 作者：TernaryTree (赞：3)

类似的题在 CF 好像叫做 Balanced String 来着。$01$ 序列任意交换都要典成土了。

首先考虑一个 $01$ 序列 $s$ 通过任意交换变成 $t$ 的最小次数是多少。显然我们一次可以将一对 $s$ 中的子序列 $01$ 与 $t$ 中对应位置的一个 $10$（或相反，$s$ 中的 $10$ 与 $t$ 中的 $01$）交换，这样一下子减少了 $2$ 个不同的位置。所以最小次数是 $\dfrac12\operatorname{popcount}(s\operatorname{xor} t)$。

问题转换为，找一个 $01$ 序列满足题目的条件，并且与 $s$ 不同的位置最少。

直接考虑 dp。$f_{i,j,k,0/1}$ 表示前 $i$ 位，填了 $j$ 个 $1$，最后一个极长 $1$ 连续段长为 $k$，第 $i$ 位填的 $0/1$ 的最少不同位置数。

则有转移：

$$
\begin{aligned}
f_{i,j,k,0}&=[s_{i}\neq 0]+\min(f_{i-1,j,k,0},f_{i-1,j,k,1})+\\
f_{i,j,k,1}&=\left(\sum_{p=i-k+1}^i [s_i\neq1]\right)+\min_{l=0}^{k-1}f_{i-k,j-k,l,0}
\end{aligned}
$$

第一个式子 $\Theta(1)$ 转移，第二个式子前面一项前缀和即可，后面一项维护 dp 数组前缀 $\min$ 即可。

然后可以对第三维滚动数组。空间降为 $\Theta(n^2)$。

时间复杂度 $\Theta(n^3)$。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 810;

int n, m, ans;
char s[maxn];
int t[maxn];
int f[maxn][maxn][2];
int tmpf[maxn][maxn][2];
int g[maxn][maxn];
int tmpg[maxn][maxn];

signed main() {
    cin >> s + 1, n = strlen(s + 1);
    for (int i = 1; i <= n; i++) m += s[i] - '0', t[i] = t[i - 1] + s[i] - '0';
    memset(f, 0x3f, sizeof(f));
    memset(g, 0x3f, sizeof(g));
    memset(tmpf, 0x3f, sizeof(tmpf));
    memset(tmpg, 0x3f, sizeof(tmpg));
    ans = f[0][0][0];
    f[0][0][0] = 0;
    g[0][0] = 0;
    for (int k = 0; k <= m; k++) {
    	for (int i = 1; i <= n; i++) {
	        for (int j = 0; j <= m; j++) {
                f[i][j][0] = min(f[i - 1][j][0], f[i - 1][j][1]) + (s[i] == '1');
                if (k && k <= i && k <= j) f[i][j][1] = tmpg[i - k][j - k] + k - t[i] + t[i - k];
           		if (k) g[i][j] = tmpg[i][j];
                g[i][j] = min(g[i][j], f[i][j][0]);
	        }
	    }
	    for (int i = 0; i <= n; i++) {
	        for (int j = 0; j <= m; j++) {
                tmpf[i][j][0] = f[i][j][0];
                tmpf[i][j][1] = f[i][j][1];
                tmpg[i][j] = g[i][j];
	        }
	    }
	    ans = min(ans, f[n][m][0]);
        ans = min(ans, f[n][m][1]);
	}
    cout << ans / 2 << endl;
    return 0;
}
```

---

## 作者：dAniel_lele (赞：1)

考虑 $dp_{i,j,k}$ 表示看到 $i$ 位，目前填了 $j$ 个 $1$，上一次填了长度为 $k$ 的 $1$ 连续段。

考虑转移，不难发现只可以转移到 $i'\geq i+k'+1,k'>k$ 的所有 $(i',j+k',k')$ 位置。

考虑用前缀和去刻画这个转移。先转移到 $dp_{i+k+2,j+(k+1),k+1}$，然后要么同时增加 $i',j+k',k'$，要么单独增加 $i'$。

预处理出 $pre_{i,k}$ 表示 $i-k+1\sim i$ 位置这样就可以 $O(n^3)$ 时间/空间解决了。

注意到在以上前缀和优化的转移中，最后一维一直只会有 $k\to k+1$，故一维可以使用滚动数组将空间优化到 $O(n^2)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
int pre[805][805],dp[2][805][805];
int pos[805],tot;
signed main(){
	string s; cin>>s; int n=s.size(); s=" "+s;
	for(int i=1;i<=n;i++) if(s[i]=='1') pos[++tot]=i;
	for(int i=1;i<=n;i++){
		pre[i][1]=(s[i]=='0');
		for(int j=2;j<=tot&&i+j-1<=n;j++){
			pre[i][j]=pre[i][j-1]+(s[i+j-1]=='0');
		}
	}
	memset(dp,0x3f,sizeof(dp));
	dp[1][1][0]=0;
	dp[1][1][1]=0;
	int ans=1e9;
	for(int k=1;k<=tot;k++){
		memset(dp[(k&1)^1],0x3f,sizeof(dp[(k&1)^1]));
		for(int i=1;i<=n;i++){
			for(int j=k;j<=min(i,tot);j++){
				dp[k&1][i+1][j]=min(dp[k&1][i+1][j],dp[k&1][i][j]);
				dp[(k&1)^1][i+1][j+1]=min(dp[(k&1)^1][i+1][j+1],dp[k&1][i][j]);
				dp[k&1][i][j]+=pre[i-k+1][k];
				if(i+k+2<=n) dp[(k&1)^1][i+k+2][j+(k+1)]=min(dp[(k&1)^1][i+k+2][j+(k+1)],dp[k&1][i][j]);
			}
		}
		for(int i=1;i<=n;i++){
			ans=min(ans,dp[k&1][i][tot]);
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：yimuhua (赞：1)

考虑怎么用最少的次数将 $s$ 变为 $t$，一次交换可以消除两个不同的位置，设不同位置数为 $x$，那么操作次数为 $\dfrac{x}{2}$。

于是问题变为求一个长为 $n$ 的极长 $1$ 段长度严格递增、$1$ 的个数与 $a$ 相同的序列 $t$，最小化 $a$ 与 $t$ 不同的位置数。

设 $dp_{i,j,k,0/1}$ 表示考虑前 $i$ 位，放了 $j$ 个 $1$，最后一个极长 $1$ 段长为 $k$，$i$ 放 $0/1$ 的极长 $1$ 段长度严格递增的序列与 $a$ 不同的位置数最小值。

那么设 $s_i$ 表示 $a$ 的前 $i$ 位中 $1$ 的个数：

$dp_{i,j,k,0}=\min(dp_{i-1,j,k,0},dp_{i-1,j,k,1})+[a_i=1]$

$dp_{i,j,k,1}=s_i-s_{i-k}+\min_{l=0}^{k-1}dp_{i-k,j-k,l}$

于是维护 $dp$ 数组前缀 $\min$ 为 $f_{i,j}$，第三维滚动一下就可以做到 $O(n^3)$ 时间，$O(n^2)$ 空间。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
string a;
int n, ans = 1e9, s[805], dp[805][805][2], f[805][805];
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> a, n = a.size(), a = ' ' + a, memset(dp, 0x3f, sizeof(dp)), memset(f, 0x3f, sizeof(f)), dp[0][0][0] = f[0][0] = 0;
	for(int i = 1; i <= n; i++)
		s[i] = s[i - 1] + a[i] - '0';
	for(int k = 0; k <= s[n]; k++) {
		for(int i = 1; i <= n; i++)
			for(int j = 0; j <= s[n]; j++) {
				dp[i][j][0] = min(dp[i - 1][j][0], dp[i - 1][j][1]) + a[i] - '0';
				if(k && k <= min(i, j))
					dp[i][j][1] = f[i - k][j - k] + k - s[i] + s[i - k];
			}
		for(int i = 1; i <= n; i++)
			for(int j = 0; j <= s[n]; j++)
				f[i][j] = min(f[i][j], dp[i][j][0]);
		ans = min({ans, dp[n][s[n]][0], dp[n][s[n]][1]});
	}
	cout << ans / 2;
	return 0;
}
```

---


# 口吃

## 题目背景

在题目描述末尾有形式化题意。

## 题目描述

因为练习说唱，ZHY 变成了一个口吃。

ZHY 的口吃十分特别，具体的，假设 ZHY 要读一段有 $n$ 个字的话，那么他会将第一个字读一遍，第二个字读两遍，第三个字读三遍……第 $n$ 个字读 $n$ 遍。例如，“原神启动”ZHY 会读成“原神神启启启动动动动”。

YHZ 手上有 $n$ 个字，每个字都有 YHZ 为其设定的悦耳值 $a_i$，且 $a_{1\sim n}$ 会形成一个 $1\sim n$ 的排列。现在，他要把这 $n$ 个字重新排列成一段话给 ZHY 读。因为 YHZ 喜欢玩原神，所以他要求重新排列后序列 $a$ 的逆序对个数恰好为 $k$。不过 YHZ 还没定好每个字的顺序，所以请你求出对于所有可能的排列，ZHY 按顺序将这段话读出后，YHZ 将听到的所有字的悦耳值之和的和。显然，如果 YHZ 听到了一个字多次，其悦耳值也应算进总和多次。

**形式化题意**

称一个 $1\sim n$ 的排列 $a_1,a_2,\cdots,a_n$ 是合法的，当且仅当其逆序对数**恰好**为 $k$。同时，对于一个排列 $a_1,a_2,\cdots,a_n$，其权值是 $\sum_{i=1}^n i\times a_i$。

给定 $n$ 和 $k$，请你求出所有 $1\sim n$ 的合法排列的权值之和，答案对 $998244353$ 取模。

一个排列的逆序对数定义为 $\sum_{i=1}^n\sum_{j=i+1}^n [a_i>a_j]$。

## 说明/提示

**样例 $1$ 解释**

合法的排列只有两种：$2\ 3\ 1$ 和 $3\ 1\ 2$，它们的权值都是 $11$，故答案为 $22$。

---

对于 $10\%$ 的数据，$n \le 10$。

对于 $25\%$ 的数据，$n \le 100$。

对于另外 $20\%$ 的数据，$k \le 300$。

对于 $100\%$ 的数据，$1 \le n \le 300$，$0\le k \le \frac{n(n-1)}{2}$。

## 样例 #1

### 输入

```
3 2```

### 输出

```
22```

## 样例 #2

### 输入

```
7 5```

### 输出

```
22066```

# 题解

## 作者：NaCly_Fish (赞：16)

首先，一个排列 $a$ 的权值是：

$$\frac{n(n+1)(2n+1)}{6}+\sum_{i=1}^n\sum_{j=1}^{i-1}[a_i < a_j](a_i-a_j)$$
这个在官方题解中就有证明，大致方法是从权值最大的排列（顺序排列）开始，考察交换两个顺序项时产生的权值变化即可证明。

现在考虑对后面一部分计数，首先设生成函数 $F_1(x,y)$，用 $x$ 这一维计量逆序对数，$y$ 这一维计量上式中的 $a_j$ 之和，则：

$$F_1(x,y)=\prod_{i=1}^n \left( \sum_{j=0}^{i-1}x^j y^{ij}\right)=\prod_{i=1}^n \frac{1-(x y^i)^i}{1-xy^i}$$
解释一下这个式子：从小到大插入 $i$，这时 $i$ 是当前序列中的最大值。若插入的位置会产生 $j$ 个逆序对，则会对总和贡献 $ij$。

类似地设 $F_2(x,y)$，不过 $y$ 计量的是 $a_i$：
$$F_2(x,y)=\prod_{i=1}^n \left( \sum_{j=0}^{n-i}x^j y^{ij}\right)=\prod_{i=1}^n \frac{1-(x y^i)^{n-i+1}}{1-xy^i}$$
这时是从大到小插入 $i$，含义是一样的。所以最终答案就是

$$\frac{n(n+1)(2n+1)}{6}f_{n,k}+[x^k]\left( \frac{\partial (F_2(x,y)-F_1(x,y))}{\partial y} \right)\bigg|_{y=1}$$
其中 $f_{n,k}$ 表示有 $k$ 个逆序对的 $n$ 阶排列数。前面一项容易计算，只用考虑后面这一部分。求导后展开就得到：

$$[x^k]\left(\prod_{i=0}^n \frac{1-x^i}{1-x} \right)\sum_{i=1}^n \frac{x + x^i (i (x - 1) - x)}{1-x^i}(n-2i+1)$$
前面这部分连乘可以 $\Theta(k \log k)$ 求系数，后面这个和式暴力即可。因为 $k$ 次以内的 $1/(1-x^i)$ 只有 $\lfloor k /i \rfloor$ 项系数非零，直接计算的时间复杂度就是 $\Theta(k \log n)$。

这样就可以做到 $\Theta(k \log k)$ 的时间复杂度解决此题。

---

## 作者：唐一文 (赞：9)

这题真的只有紫吗？？？

这题所求的是与 逆序对恰好为某个数的所有排列 有关的东西。首先要会算这样的排列数量，详见 [P1521](https://www.luogu.com.cn/problem/P1521)。

考虑对一个排列 $p$ 进行冒泡排序：若 $p_i>p_{i+1}$，则交换 $p_i$ 与 $p_{i+1}$。那么一次交换会让这个排列的权值增加 $p_i-p_{i+1}$。

一个排好序的排列权值为 $\sum i^2$。由于冒泡排序会把所有逆序对都交换恰好一次，那么排列 $p$ 的权值实际上是

$$
\sum_{i}i^2-\sum_{i<j}[p_i>p_j](p_i-p_j)
$$

将式子拆开，那么要算 $\sum_{i<j} [p_i>p_j]p_i$。$-p_j$ 的部分同理。

设 $f(i,j)$ 为长度为 $i$ 的排列，恰好有 $j$ 个逆序对的排列数量。$g(i,j)$ 表示长度为 $i$ 的排列，$\sum_{i<j}[p_i>p_j]p_i$ 之和。

枚举 $i+1$ 放在第 $v$ 位（$1\leq v\leq i+1$），那么它前面有 $(v-1)$ 个小于它的数，产生的逆序对数量为 $(v-1)$，设 $t=j+(v-1)$，容易转移：
$$
f(i+1,t)\leftarrow f(i+1,t)+f(i,j)
$$
$$
g(i+1,t)\leftarrow g(i+1,t)+g(i,j)
$$
$$
g(i+1,t)\leftarrow g(i+1,t)+f(i,j)\times i\times(v-1)
$$

直接做是 $O(n^2k)$ 的，用前缀和优化可做到 $O(nk)$。[code](https://www.luogu.com.cn/paste/7gb9l6fq)

---

## 作者：masterhuang (赞：8)

推销[博客](https://www.cnblogs.com/HaHeHyt/p/17773631.html)！第 $16$ 篇。

只有写了题解才能明白每一步的原委。

考虑拆 $i$：

$\begin{aligned}
\sum\limits_{i=1}^n ia_i&=\sum\limits_{i=1}^n a_i\left(\sum\limits_{j<i}[a_i>a_j]+[a_i<a_j]+1\right)\\
&=\sum\limits_{i=1}^n a_i\left(a_i-\sum\limits_{j>i}[a_i>a_j]+\sum\limits_{j<i}[a_i<a_j]\right)\\
&=\sum\limits_{i=1}^n i^2+\sum\limits_{i=1}^n a_i\left(\sum\limits_{j<i}[a_i<a_j]-\sum\limits_{j>i}[a_i>a_j]\right)\\
&=\sum\limits_{i=1}^n i^2+\sum\limits_{i=1}^n a_i\sum\limits_{j<i}[a_i<a_j]-\sum\limits_{i=1}^n a_i\sum\limits_{j>i}[a_i>a_j]
\end{aligned}$

对最后两部分 **dp** 即可。

---

首先套路性地记 $f_{i,j}$ 表示填到 $i$，逆序对数为 $j$ 的方案数。

则 $f_{i,j}=\sum\limits_{0\le k<i} f_{i-1,j-k}$，记下 $f$ 的前缀和进行前缀和优化即可。

则前半部分的总贡献为 $f_{n,k}\times \sum\limits_{i=1}^n i^2$。

记 $g_{i,j}$ 表示填到 $i$，逆序对数为 $j$ 的方案中当前所有 $\sum\limits_{i=1}^n a_i\sum\limits_{j>i}[a_i>a_j]$ 的和。

则 $g_{i,j}=\sum\limits_{0\le k<i}g_{i-1,j-k}+i\times k\times f_{i-1,j-k}$。

类似记 $h_{i,j}$ 表示填到 $i$，逆序对数为 $j$ 的方案中当前所有 $\sum\limits_{i=1}^n a_i\sum\limits_{j<i}[a_i<a_j]$ 的和。

考虑倒着做，令 $t=n-i+1$，$h_{i,j}=\sum\limits_{0\le k<t}h_{i+1,j-k}+i\times k\times f_{i+1,j-k}$。

此时若正着做，则有：$h_{i,j}=\sum\limits_{0\le k<i}h_{i-1,j-k}+(n-i+1)\times k\times f_{i-1,j-k}$。

考虑 $U=h-g$，则 $U_{i,j}=\sum\limits_{0\le k<i}U_{i-1,j-k}+(n-2i+1)\times k\times f_{i-1,j-k}$。

答案为 $f_{n,k}\times \sum\limits_{i=1}^n i^2+U_{n,k}$。

记下 $U$ 的前缀和和 $jf_{i,j}$ 的前缀和，优化 **dp** 即可。具体细节看代码。

复杂度 $O(nk)$，空间复杂度经过优化后为 $O(k)$。

代码：

```cpp
//洛谷 P10254
//https://www.luogu.com.cn/problem/P10254
#include<bits/stdc++.h>
#define LL long long
#define fr(x) freopen(#x".in","r",stdin);freopen(#x".out","w",stdout);
using namespace std;
const int N=305,M=N*(N-1)/2+5,mod=998244353;
int n,k,f[M],F[M],s[M],g[M],G[M];
inline int md(int x){return x>=mod?x-mod:x;}
int main()
{
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);cin>>n>>k;
	f[0]=1;for(int i=0;i<=k;i++) F[i]=1;
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=k;j++) f[j]=md(F[j]-((j>=i)?F[j-i]:0)+mod),
			g[j]=md((1ll*(G[j]-((j>=i)?G[j-i]:0))+1ll*(n-2*i+1)*j*f[j]-1ll*(n-2*i+1)*(s[j]-((j>=i)?s[j-i]:0)))%mod+mod);
		F[0]=f[0],G[0]=g[0];
		for(int j=1;j<=k;j++) F[j]=md(F[j-1]+f[j]),G[j]=md(G[j-1]+g[j]),s[j]=(s[j-1]+1ll*j*f[j])%mod;
	}
	return cout<<(1ll*n*(n+1)*(n*2+1)/6%mod*f[k]+g[k])%mod,0;
}
```

---

## 作者：smallpeter (赞：4)

直接计算所有情况下 $\sum_{i=1}^n i\times a_i$ 并不是很好计算，我们考虑将其转化一下。

- 结论 ：$\sum_{i=1}^n i\times a_i=\sum_{i=1}^ni^2+\sum_{x<y\land a_x>ay} a_y-a_x$

- 证明 ：假设对于 1 到 $i-1$ 此结论成立。设 $a_x=i$ ，依次交换 $(x,x+1),(x+1,x+2)\dots(i-1,i)$，则权值增加了 $\sum_{j=x+1}^{i}{a_j}-a_x$，故成立。

首先考虑计算出逆序对数为 $k$ 的排列数，设 $f_{i,j}$ 表示只考虑前 $i$ 个数的相对位置，已经确定前 $i-1$ 个数的相对位置，且逆序对数为 $j$ 的方案数。枚举 $i$ 在前 $i-1$ 个数中插入的位置，则可以得到
$$

f_{i,j}=\sum_{k=0}^{i-1} f_{i-1,j-k}
$$

用前缀和优化可以做到 $O(n^3)$。

现在把答案拆成 $f_{n,k}\times \sum_{i=1}^n i^2 +\sum_{x<y\land a_x>ay} a_y-\sum_{x<y\land a_x>ay} a_x$，考虑分别计算 $\sum_{x<y\land a_x>ay} a_y$ 与 $\sum_{x<y\land a_x>ay} a_x$。设 $g_{i,j}$ 表示只考虑前 $i$ 个数的相对位置，已经确定前 $i-1$ 个数的相对位置，且逆序对数为 $j$ 的权值总和。同样是枚举 $i$ 在前 $i-1$ 个数中插入的位置，则可以得到 

$$
g_{i,j}=\sum_{k=0}^{i-1} g_{i-1,j-k}+i\times k\times f_{i-1,j-k}
$$


这个式子我们不能利用前缀和快速计算，于是我们考虑继续改写式子。 

$$
g_{i,j}=\sum_{k=0}^{i-1} g_{i-1,j-k}+i\times (j-(j-k))\times f_{i-1,j-k}
$$

$$
g_{i,j}=\sum_{k=0}^{i-1} g_{i-1,j-k}+i\times j\times \sum_{k=0}^{i-1}f_{i-1,j-k}-i\times \sum_{k=0}^{i-1}(j-k)\times f_{i-1,j-k}
$$

这个形式就好看多了，可以直接上前缀和优化了。

求另一部分也同理，就不再赘述。

总复杂度 $O(n^3)$，需要滚动数组来优化空间。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define LL long long
#define LD long double
#define fi first
#define se second
#define pb push_back
#define pii pair<LL,LL>
#define mem(a,x) memset((a),(x),sizeof(a))

//#define long long int
#define LLL __int128

template<typename type>
inline void read(type &x)
{
	x=0;bool flag(0);char ch=getchar();
	while(!isdigit(ch)) flag=ch=='-',ch=getchar();
	while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	flag?x=-x:0;
}

template<typename type>
inline void write(type x,bool mode=1)//0为空格，1为换行
{
	x<0?x=-x,putchar('-'):0;static short Stack[50],top(0);
	do Stack[++top]=x%10,x/=10; while(x);
	while(top) putchar(Stack[top--]|48);
	mode?putchar('\n'):putchar(' ');
}

LL qsm(LL a,LL b,LL mod){
	LL ans=1,sum=a;
	while(b){
		if(b&1) ans=ans*sum%mod;
		sum=sum*sum%mod;
		b>>=1;
	}
	return ans;
}

const LL N=3e2+10,M=5e4+10,mod=998244353;

LL n,k,f[2][M],g1[2][M],g2[2][M],sum[2][M][4];

LL calc(LL i,LL l,LL r,LL op){
	return (sum[i][r][op]-(l>0?sum[i][l-1][op]:0)+mod)%mod;
}

void solve(){
	read(n),read(k);
	f[0][0]=1;
	LL op=1;
	for(LL i=1;i<=n;i++,op^=1){
		sum[op^1][0][0]=f[op^1][0];
		for(LL j=1;j<=k;j++) sum[op^1][j][0]=(sum[op^1][j-1][0]+f[op^1][j])%mod;
		for(LL j=1;j<=k;j++) sum[op^1][j][1]=(sum[op^1][j-1][1]+f[op^1][j]*j%mod)%mod;
		sum[op^1][0][2]=g1[op^1][0];
		for(LL j=1;j<=k;j++) sum[op^1][j][2]=(sum[op^1][j-1][2]+g1[op^1][j])%mod;
		sum[op^1][0][3]=g2[op^1][0];
		for(LL j=1;j<=k;j++) sum[op^1][j][3]=(sum[op^1][j-1][3]+g2[op^1][j])%mod;
		for(LL j=0;j<=k;j++){
			f[op][j]=calc(op^1,max((LL)0,j-i+1),j,0);
			g1[op][j]=(calc(op^1,max((LL)0,j-i+1),j,2)+i*j%mod*calc(op^1,max((LL)0,j-i+1),j,0)%mod-i*calc(op^1,max((LL)0,j-i+1),j,1)%mod+mod)%mod;
			g2[op][j]=(calc(op^1,max((LL)0,j-i+1),j,3)+(n-i+1)*j%mod*calc(op^1,max((LL)0,j-i+1),j,0)%mod-(n-i+1)*calc(op^1,max((LL)0,j-i+1),j,1)%mod+mod)%mod;
		}
	}
	LL sum=n*(n+1)*(2*n+1)/6;
	LL ans=sum*f[n&1][k]%mod;
	ans=(ans-g1[n&1][k]+g2[n&1][k]+mod)%mod;
	write(ans);
}

int main(){
	LL T=1;
//	read(T);
	while(T--){
		solve();
	}
}
```

---

## 作者：Missa (赞：3)

拜谢出题人。

首先我们需要把逆序对数和 $\sum ia_i$ 扯上关系。

如果你做过 [arc154e](https://www.luogu.com.cn/problem/AT_arc154_e)，你就会知道 $\sum_{i < j,a_i>a_j} (j-i) = \sum i(i-a_i)$，于是可以做一个 dp，从小到大插入每一个数来处理逆序对数，记录额外信息以求答案。具体而言，对每个下标求贡献，每个满足 $j<i \cap a_j>a_i$ 的 $j$ 为 $i$ 带来 $1$ 的贡献，反过来 $i$ 为 $j$ 带来 $-1$ 的贡献，则枚举第 $i+1$ 位的数在前 $i+1$ 数中的相对顺序，同时维护逆序对数转移答案。

$f_{i, j} + g_{i, j} \cdot k \cdot (i+1) \to f_{i+1, j+k}$，其中 $g_{i, j}$ 是长度为 $i$ 逆序对数为 $j$ 的排列的数量，$k+1$ 是新数的相对排名。用前缀和优化可以做到 $O(n^3)$。注意这个 dp 只考虑了 $j$ 对 $i \in [j+1, n]$ 的贡献，需要再做一遍考虑 $i$ 对 $j$ 的贡献。

如果你没有做过 arc154e，考虑到逆序对的定义，考虑交换相邻两项，这会对答案贡献 $a_i-a_{i+1}$，即交换两数的差。不妨钦定初始序列的相对大小顺序，以确定 $a_i-a_{i+1}$ 的符号一致，这样连续交换只用考虑第一个数和最后一个数的差。钦定原序列升序，每多一组逆序对，答案减小它们的和。因此 $\sum i^2- \sum i a_i=\sum_{i<j,a_i>a_j} (a_i-a_j)$，即所有逆序对的差的和。这与文初的式子本质相同，取逆排列即可完成转化。

代码大家都会写。

---

## 作者：Creeper_l (赞：3)

> 题意：一个长度为 $n$ 的排列合法当且仅当逆序对数为 $k$，且一个排列的价值定义为 $\sum a_i \times i$。给定 $n$ 和 $k$，求出所有合法排列的价值和。

容易想到 $\text{dp}$。

会发现如果直接 $\text{dp}$ 的话，每一个位置的数的贡献是有后效性的（因为后面会不断加入数，这个数的下标 $i$ 也会发生变化，于是价值 $i \times a_i$ 也会跟着变化）。所以我们考虑把贡献拆开计算。具体地，对于每一个 $i$，我们可以把 $a_i \times i$ 拆成 $sum0 \times a_i + sum1 \times a_i$，其中 $sum0/1$ 分别表示在 $1$ 到 $i$ 中大于等于 / 小于 $a_i$ 的数的个数。我们可以分别求出这两个的答案，最终相加即可。（其实这两种贡献本质完全一样）

先考虑 $sum0$ 的贡献。假设我们从 $n$ 开始降序选数，设 $f_{i,j}$ 表示选完了 $i$ 个数，逆序对数为 $j$ 的方案数，$g_{i,j}$ 表示选完了 $i$ 个数，逆序对数为 $j$ 的总价值和，$P$ 表示前 $i-1$ 个数的逆序对数最少是多少，那么有：

$$P=\max(0,j-(i-1))$$
$$f_{i,j}=\sum_{p=P}^{j} f_{i-1,p}$$
$$g_{i,j}=\sum_{p=P}^{j} g_{i-1,p} +f_{i-1,p} \times (n-i+1) \times (j - p + 1)$$

前两个式子比较好理解。第三个转移方程中的 $(n-i+1)$ 表示当前选到第 $i$ 个数的值是多少，$(j-p+1)$ 表示当前这个数在序列中是第几个数。因为后面的数加进来的数一定比第 $i$ 个数小了，且之前加进来的数一定比第 $i$ 个数大（降序选），所以 $sum0=j-p+1$。（这就体现出了拆贡献的好处，如果不拆开算的话后面加进来的数不好处理），$sum2$ 的贡献同理。

这个 $\text{dp}$ 的复杂度是 $O(n^2 k)$ 的，但是每一个 $\sum$ 其实都可以用前缀和优化掉，所以时间复杂度 $O(nk)$。另外 $\text{dp}$ 数组的第一维可以滚掉，空间复杂度 $O(k)$。

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define now (i & 1)
#define p max(0ll,j - (i - 1))
const int mod = 998244353;
const int MAXN = 3e2 + 10;
const int MAXK = 1e5 + 10;
int n,k,f[3][MAXK],g[3][MAXK],sumf[MAXK],sumg[MAXK];
int h[3][MAXK],sumh[MAXK],sumF[MAXK];
signed main() {
	cin >> n >> k;
	for(int i = 0;i <= k;i++) sumf[i] = 1;
	for(int i = 1;i <= n;i++) {
		for(int j = 0;j <= k;j++)
			f[now][j] = (sumf[j] - (p ? sumf[p - 1] : 0) + mod) % mod,
			g[now][j] = (sumg[j] - (p ? sumg[p - 1] : 0) + mod) % mod,
			g[now][j] = (g[now][j] + ((n - i + 1) * (j + 1) % mod * f[now][j] % mod)) % mod,
			g[now][j] = (g[now][j] - (n - i + 1) * ((sumF[j] - (p ? sumF[p - 1] : 0) + mod) % mod) % mod + mod) % mod,
			h[now][j] = (sumh[j] - (p ? sumh[p - 1] : 0) + mod) % mod,
			h[now][j] = (h[now][j] + (i * (i - j - 1) % mod * f[now][j] % mod) + mod) % mod,
			h[now][j] = (h[now][j] + i * ((sumF[j] - (p ? sumF[p - 1] : 0) + mod) % mod) % mod + mod) % mod;
		for(int j = 0;j <= k;j++)
			sumf[j] = ((j ? sumf[j - 1] : 0) + f[now][j]) % mod,
			sumg[j] = ((j ? sumg[j - 1] : 0) + g[now][j]) % mod,
			sumh[j] = ((j ? sumh[j - 1] : 0) + h[now][j]) % mod,
			sumF[j] = ((j ? sumF[j - 1] : 0) + f[now][j] * j % mod) % mod;
	}
	cout << (g[n & 1][k] + h[n & 1][k]) % mod;
	return 0;
} 
```

---

## 作者：Erine (赞：1)

太难了。拼尽全力无法战胜。

拆式子。

$$\sum_i ia_i=\sum_i a_i(1+\sum_{j<i}[a_j<a_i]+\sum_{j<i}[a_j>a_i])=\dfrac12n(n+1)+\sum_i a_i\sum_{j<i} [a_j<a_i]+\sum_i a_i\sum_{j<i} [a_j>a_i]$$

算所有逆序对数为 $k$ 的排列的 $\sum_i a_i\sum_{j<i} [a_j<a_i]$：

$f_{i,j}$ 表示 $1\sim i$ 插入完毕，有 $j$ 个逆序对，这个式子的值。有

$$f_{i,j}=\sum_{k=1}^i (k-1)i \times cnt_{i-1,j-(i-k)}+f_{i-1,j-(i-k)}$$

$cnt_{i,j}$ 表示长度为 $i$ 的排列有多少逆序对数为 $j$ 的，可以 dp 出来。

$g_{i,j}$ 同理。前缀和优化一下做完了，三次方。

---


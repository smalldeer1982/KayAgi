# [ROI 2017] 前往大都会 (Day 1)

## 题目描述

ROI 国有 $n$ 个城市，以及 $m$ 条铁路，每条铁路都是**单向**运行的，第 $i$ 条铁路依次经过 $v_{i,1},v_{i,2},\dots,v_{i,l_i+1}$ 号城市并停靠，其中 $v_{i,j} \to v_{i,j+1}$ 的铁路长度是 $t_{i,j}$。

如果多条铁路经过 $u$ 号城市，那么你可以在 $u$ 号城市换乘其他铁路。（每条铁路都可以在停靠点任意上车/下车）

你需要找到一条从 $1$ 号城市到 $n$ 号城市的路径，这条路径需要满足其总长度最小，并且在此条件上路径上相邻两个**换乘点**间**火车上**距离的平方和最大。

注：起点和终点都是换乘点，题目保证有解。

## 说明/提示

#### 【样例解释】

对于样例组 #2：

从 $1$ 号城市乘坐 $1$ 号线直达 $5$ 号城市并非最佳方案（无法达到最短时间）。最佳方案：

>从 $1$ 号城市乘坐 $1$ 号线到 $2$ 号城市；
>
> 换乘 $2$ 号线，坐到 $3$ 号城市；
>
> 再换乘 $1$ 号线，坐到 $5$ 号城市。

此时，平方和为 $3^2 + 1^2 + 5^2 = 35$。

对于样例组 #3：

无论是在中途哪一站转 $2$ 号线，结果都一样。平方和为 $1^2+9^2=82$。

#### 【数据范围】

注：本题只放部分数据，完整数据请左转 [LOJ P2769](https://loj.ac/p/2769) 评测。

对于所有数据：$1 \le m \le 10^6$，$1 \le v_{i,j} \le n$，$1 \le t_{i,j} \le 1000$，设 $sum=\sum l_i$。

| 子任务编号 | 分值 | $1 \le n \le $ | $1 \le sum \le $ |特殊性质|
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $10$ | $10$ | $20$ |$l_i=1$|
| $2$ | $10$ | $10^3$ | $10^3$ |$l_i=1$|
| $3$ | $17$ | $10^3$ | $10^3$ |无|
| $4$ | $17$ | $10^3$ | $10^5$ |无|
| $5$ | $19$ | $10^4$ | $2 \times 10^5$ |无|
| $6$ | $19$ | $2 \times 10^5$ | $2 \times 10^5$ |无|
| $7$ | $8$ | $10^6$ | $10^6$ |无|

## 样例 #1

### 输入

```
2 1
1 1 3 2```

### 输出

```
3 9```

## 样例 #2

### 输入

```
5 2
4 1 3 2 3 3 5 5 10 4
3 4 2 2 1 3 4 1```

### 输出

```
9 35```

## 样例 #3

### 输入

```
5 2
3 1 1 2 2 3 3 4
3 2 2 3 3 4 4 5```

### 输出

```
10 82```

# 题解

## 作者：Aurora_Borealis_ (赞：8)

第一问可以直接最短路，考虑只有最短路上的点能对第二问有影响，所以重构出最短路图，具体地，一条边 $(x,y,w)$ 在最短路图上的充分条件是 $dis_x+w=dis_y$。

考虑原图上的一条链在新图内会被分割成不相干扰的几条路径，所以直接将这些路径看作不同路径重新编号，然后可以 $\text{DP}$，设 $f_i$ 表示 $i$ 的答案，则 $i$ 能从所有经过 $i$ 的路径上的不与 $i$ 重合的，且 $dis_j < dis_i$ 的点 $j$ 转移而来，方程为 $f_i=\min(f_j+(dis_i-dis_j)^2)$。这个形式一眼斜率优化，考虑对于每个路径维护凸包，对于每个点记录经过它的路径，从这些凸包转移，考虑一个点会转移经过他的路径条数次，这个次数等于它出度的一半，总转移次数就是 $m$ 级别的，所以 DP 部分的均摊复杂度 $O(n)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
namespace Aurora{ void Main(); }
int main(){ return Aurora::Main(),0; }
namespace Aurora{
    #define int long long
    #define ll long long
    #define debug printf("debug\n")
    const int N=1e6+5;
    int n,m,l[N],Road_Cnt=0,id[N];
    ll dis[N];
    struct EDGE{ int to;ll c; };
    struct Road{ int u,v;ll c; };
    vector<Road>r[N],nr[N];
    vector<int>cov[N];
    namespace Dij{
        bool vis[N];
        struct node{
            int x; ll dis;
            friend bool operator < (node A,node B){
                return A.dis>B.dis;
            } 
        };
        vector<EDGE>G[N];
        void Dijkstra(){
            priority_queue<node>Q; Q.push({1,0});
            memset(dis,0x3f,sizeof(dis)); dis[1]=0;
            while(!Q.empty()){
                int now=Q.top().x; Q.pop();
                if(vis[now]) continue;
                vis[now]=1;
                for(auto tx:G[now]){
                    int to=tx.to;
                    if(dis[to]>dis[now]+tx.c){
                        dis[to]=dis[now]+tx.c;
                        if(!vis[to]) Q.push((node){to,dis[to]});
                    }
                }
            }
        }
    }
    namespace CalcDP{
        ll f[N];
        int top[N];
        vector<int>st[N];
        #define X(i) (dis[i])
        #define Y(i) (f[i]+dis[i]*dis[i])
        #define K(i) (2*dis[i])
        #define Exval(i) (dis[i]*dis[i])
        double slope(int i,int j){
            return 1.0*(Y(i)-Y(j))/(X(i)-X(j));
        }
        void DP(){
            for(int i=1;i<=n;i++){
                int now=id[i];
                for(auto pos:cov[now]){
                    // printf("ID:%d POS:%d\n",i,pos);
                    while(st[pos].size()>1&&slope(st[pos][st[pos].size()-2],st[pos][st[pos].size()-1])<=1.0*K(now)) st[pos].pop_back();
                    if(st[pos].size()){
                        int j=st[pos][st[pos].size()-1];
                        f[now]=max(f[now],Y(j)-K(now)*X(j)+Exval(now));
                    }
                }
                for(auto pos:cov[now]){
                    while(st[pos].size()>1&&slope(st[pos][st[pos].size()-2],st[pos][st[pos].size()-1])<=slope(st[pos][st[pos].size()-1],now)) st[pos].pop_back();
                    st[pos].push_back(now);
                }
            }
        }
    }
    bool cmp(int A,int B){
        return dis[A]<dis[B];
    }
    void Main(){
        // freopen("tower_sample4.in","r",stdin);
        scanf("%lld%lld",&n,&m);
        for(int i=1,lst;i<=m;i++){
            scanf("%lld%lld",&l[i],&lst);
            for(int j=1;j<=l[i];j++){
                int x;ll w;scanf("%lld%lld",&w,&x);
                Dij::G[lst].push_back((EDGE){x,w});
                r[i].push_back((Road){lst,x,w});
                lst=x;
            }
        }
        Dij::Dijkstra();
        printf("%lld ",dis[n]);
        for(int i=1;i<=m;i++){
            for(auto now:r[i]){
                if(dis[now.u]+now.c==dis[now.v]) nr[i].push_back(now);
            }
            r[i].clear();
        }
        // for(int i=1;i<=m;i++){
        //     cout<<"ID:"<<i<<"\n"<<"NUM:"<<nr[i].size()<<"\n";
        //     for(auto now:nr[i]) printf("%d %d %lld\n",now.u,now.v,now.c);
        // }
        for(int i=1;i<=m;i++){
            // cout<<nr[i].size()<<endl;
            int lst=0;
            for(int j=1;j<nr[i].size();j++){
                if(nr[i][j-1].v!=nr[i][j].u){
                    Road_Cnt++;
                    for(int k=lst;k<=j-1;k++){
                        r[Road_Cnt].push_back(nr[i][k]);
                        cov[nr[i][k].u].push_back(Road_Cnt);
                    }
                    cov[nr[i][j-1].v].push_back(Road_Cnt);
                    lst=j;
                }
            }
            if(nr[i].size()){
                Road_Cnt++;
                for(int k=lst;k<nr[i].size();k++){
                    r[Road_Cnt].push_back(nr[i][k]);
                    cov[nr[i][k].u].push_back(Road_Cnt);
                }
                cov[nr[i][nr[i].size()-1].v].push_back(Road_Cnt);
            }
        }
        // cout<<"RC:"<<cov[1][0]<<" "<<cov[2][0]<<endl;
        // for(int i=1;i<=n;i++){
        //     printf("dis[%d]:%lld\n",i,dis[i]);
        // }
        for(int i=1;i<=n;i++) id[i]=i;
        sort(id+1,id+n+1,cmp);
        CalcDP::DP();
        printf("%lld\n",CalcDP::f[n]);
    }
}
```

---

## 作者：masterhuang (赞：7)

首先 $\text{dij}$，建出最短路图，数组为 `d`，边 $(u,v,w)$ 在最短路图上当且仅当 $d_u+w=d_v$。

考虑重构，一条铁路在最短路图上的「段」一定是能形成若干连续段，考虑把这些连续段重新构成若干条新的铁路，忽略原来完整的铁路。下面铁路指的是新铁路。

考虑 $\texttt{dp}$，令 $f_i$ 表示到 $i$ 点的平方和 $\max$，则若 $i,j$ 在同一条铁路上，则 $f_i\gets f_j+(d_j-d_i)^2$，平方考虑斜率优化。

若 $A$ 处转移优于 $B$，$f_A+d_A^2+d_i^2-2d_Ad_i-f_B-d_B^2-d_i^2+2d_Bd_i\ge 0$。

于是 $\dfrac{(f_A+d_A^2)-(f_B+d_B^2)}{d_A-d_B}\ge 2d_i$。朴素斜率优化，对每条铁路开单调栈，决策时二分即可。由于这样要求 $d_i$ 单调递增，于是我们可以把点按 $d$ 排序，枚举时按排序后的顺序枚举即可。对每条铁路开单调栈即可。单调栈用 $\texttt{vector}$ 实现即可。

大概是

```cpp
inline bool cmp(int x,int y){return d[x]<d[y];}
for(int i=1;i<=n;i++) p[i]=i;sort(p+1,p+1+n,cmp);
for(int i=1,t;i<=n;i++) if(d[t=p[i]]^d[N-1])
{
	...
}
```

复杂度 $O(n\log n)$。

**注意**：一定要先把某个 $f_x$ 转移完之后在单调栈里 $\texttt{popback}$，**不能转移某条铁路的时候顺便修改这条铁路的单调栈**，这样时不满足条件的。

---
下面说下 $O(n)$ 做法，就是尝试优化掉二分的 $\log$，考虑四边形不等式/决策单调性相关。

$w(i,j)=(d_i-d_j)^2$，$w(i,j)+w(i+1,j+1)-w(i+1,j)-w(i,j+1)=-2(d_id_j+d_{i+1}d_{j+1}-d_id_{j+1}-d_{i+1}d_j)=-2(d_{i+1}-d_i)(d_{j+1}-d_j)\le 0$，这是由于按枚举顺序 $d$ 单调不减。

考虑 $\min\to \max$，四边形不等式又成立，于是决策单调性应该反过来，即决策点应该单调递减，对于每个单调栈决策时从尾部删点即可。


$\texttt{code}$：
  
```cpp
#include<bits/stdc++.h>
#define LL long long
#define LD long double
#define int LL
#define P pair<int,int>
#define fi first
#define se second
#define fr(x) freopen(#x".in","r",stdin);freopen(#x".out","w",stdout);
using namespace std;
const int N=1e6+5;
int n,m,d[N],p[N],f[N],cnt;bool v[N];
struct node{int u,v,w;};
vector<P>g[N];
vector<int>bl[N],Q[N];
vector<node>tr[N],TR[N];
struct Node{int x,dis;inline bool operator<(const Node&X)const{return dis>X.dis;};};
priority_queue<Node>q;
inline void dij(int s)
{
	memset(d,0x3f,sizeof(d));d[s]=0;q.push({s,0});
	while(!q.empty())
	{
		Node t=q.top();q.pop();
		if(v[t.x]) continue;v[t.x]=1;
		for(P i:g[t.x]) if(d[i.fi]>t.dis+i.se)
			d[i.fi]=t.dis+i.se,(!v[i.fi])&&(q.push({i.fi,d[i.fi]}),1);
	}
}
inline bool cmp(int x,int y){return d[x]<d[y];}
#define p2(x) ((x)*(x))
#define Y(i) (f[i]+p2(d[i]))
#define X(i) (d[i])
inline LD sp(int x,int y){return (LD)(Y(x)-Y(y))/(X(x)-X(y));}
#define sz Q[w].size()
inline int que(int w,int x)
{
	if(sz==1) return 0;
	for(int i=0;i<sz-1;i++) if(sp(Q[w][i],Q[w][i+1])<x) return i;return sz-1;
	int l=2,r=sz,mid,ans=1;
	while(l<=r) mid=(l+r)>>1,(sp(Q[w][mid-2],Q[w][mid-1])>=x)?ans=mid,l=mid+1:r=mid-1;return ans-1;
}
signed main()
{
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int x,L,w,y;cin>>x>>L;
		for(int j=1;j<=x;j++) cin>>w>>y,tr[i].push_back({L,y,w}),g[L].push_back({y,w}),L=y;
	}dij(1);cout<<d[n]<<" ";
	for(int i=1;i<=m;i++){for(node j:tr[i]) if(d[j.u]+j.w==d[j.v]) TR[i].push_back(j);tr[i].clear();}
	for(int i=1,las=0;i<=m;i++,las=0)
	{
		for(int j=1;j<TR[i].size();j++) if(TR[i][j].u^TR[i][j-1].v)
		{
			cnt++;for(int k=las;k<j;k++) tr[cnt].push_back(TR[i][k]);
			las=j;
		}
		cnt++;for(int j=las;j<TR[i].size();j++) tr[cnt].push_back(TR[i][j]);
	}
	for(int i=1;i<=cnt;i++) if(tr[i].size())
	{
		bl[tr[i][0].u].push_back(i);bl[tr[i][0].v].push_back(i);
		for(int j=1;j<tr[i].size();j++) bl[tr[i][j].v].push_back(i);
	}
	for(int i=1;i<=n;i++) p[i]=i;sort(p+1,p+1+n,cmp);
	for(int i=1,t;i<=n;i++) if(d[t=p[i]]^d[N-1])
	{
		for(int w:bl[t])
		{
			while(sz>1&&sp(Q[w][sz-2],Q[w].back())<2*d[t]) Q[w].pop_back();
			if(sz){int W=Q[w].back();f[t]=max(f[t],f[W]+p2(d[t]-d[W]));}
		}
		for(int w:bl[t])
		{
			while(sz>1&&sp(Q[w][sz-2],Q[w].back())<sp(Q[w].back(),t)) Q[w].pop_back();
			Q[w].push_back(t);
		}
	}cout<<f[n];
	return 0;
}
```

---

## 作者：phigy (赞：4)

一个乱搞。

---

考虑一个暴力就是对于每条铁路任意两点建边，然后跑最短路建出最短路径 DAG，然后直接拓扑排序 DP。

这样的复杂度是 $O(n^2)$ 原因是我们建了过多的边。

你可以选择斜率优化 DP，但是这里我们发扬人类智慧，对于一条铁路的第 $i$ 个点，我们只连其后面 $\dfrac{s}{i}+B$ 个点，当 $B$ 取到 $300$ 时就可以通过。


```cpp
/*
st::
ed::
                            _/                                        _/                                     
                           _/                                        _/                                                             
                          _/                                        _/                                                         
                         _/                                        _/                      
                        _/            _/                          _/                        
                       _/_/_/_/                        _/        _/_/_/_/                    _/                
          _/_/_/_/    _/      _/    _/    _/ _/_/ _/_/_/_/_/    _/     _/     _/_/_/    _/_/_/_/_/    _/_/_/              
         _/     _/   _/      _/    _/    _/_/        _/        _/      _/   _/    _/       _/       _/     _/
        _/     _/   _/      _/    _/    _/          _/        _/      _/  _/_/_/_/_/      _/       _/     _/          
       _/     _/   _/      _/    _/    _/          _/  _/    _/      _/   _/      _/     _/  _/   _/     _/          
      _/_/_/_/    _/      _/    _/    _/          _/_/_/    _/      _/    _/_/_/_/      _/_/_/    _/_/_/ _/     
     _/
    _/
   _/
  _/
 _/
_/
*/
#include <bits/stdc++.h>

#define REN (1000000)
#define MAXN (REN+5)
#define i64 long long

const i64 inf=0x3f3f3f3f3f3f3f3f;

using namespace std;

int n,m;
struct edge {int to,next,dis;} E[MAXN*50],G[MAXN*50];
int cntE,headE[MAXN],cntG,headG[MAXN];
void addE(int x,int y,int z) {E[++cntE]={y,headE[x],z};headE[x]=cntE;}
void addG(int x,int y,int z) {G[++cntG]={y,headG[x],z};headG[x]=cntG;}
int d[MAXN],vis[MAXN];
void dijkstra()
{
    memset(d,0x3f,sizeof d);d[1]=0;
    priority_queue<pair<int,int>>Q;Q.push({0,1});
    while(!Q.empty())
    {
        int x=Q.top().second;Q.pop();
        if(vis[x]) {continue;}
        vis[x]=1;
        for(int i=headE[x];i;i=E[i].next)
        {
            int v=E[i].to,w=E[i].dis;
            if(d[v]>d[x]+w)
            {
                d[v]=d[x]+w;
                Q.push({-d[v],v});
            }
        }
    }
}
long long f[MAXN];
int deg[MAXN];
void topo()
{
    for(int x=1;x<=n;x++)
    {
        for(int i=headE[x];i;i=E[i].next)
        {
            int v=E[i].to,w=E[i].dis;
            if(d[x]+w==d[v])
            {
                addG(x,v,w);
                deg[v]++;
            }
        }
    }
    queue<int>Q;for(int i=1;i<=n;i++) {if(!deg[i]) {Q.push(i);} f[i]=-inf;}
    f[1]=0;
    while(!Q.empty())
    {
        int x=Q.front();Q.pop();
        for(int i=headG[x];i;i=G[i].next)
        {
            int v=G[i].to,w=G[i].dis;
            deg[v]--;
            f[v]=max(f[v],f[x]+1ll*w*w);
            if(!deg[v]) {Q.push(v);}
        }
    }
}

signed main()
{
    int i,j,k;
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin>>n>>m;
    for(i=1;i<=m;i++)
    {
        vector<int>v,t;
        int s,x;
        cin>>s>>x;
        v.push_back(x);
        for(j=1;j<=s;j++)
        {
            cin>>x;t.push_back(x);
            cin>>x;v.push_back(x);
        }
        for(j=1;j<=s;j++)
        {
            int res=0;
            for(k=j;k<=min(s,s/i+300);k++)
            {
                res+=t[k-1];
                addE(v[j-1],v[k],res);
            }
        }
    }
    dijkstra();
    topo();
    cout<<d[n]<<' '<<f[n];
    return 0;
}
/*
              _/                                             _/                                     
              _/                                             _/                                                             
              _/                                             _/                                                         
              _/                                             _/                      
              _/              _/                             _/                        
              _/ _/_/_/                           _/        _/ _/_/_/                     _/                
_/_/_/_/_/    _/_/     _/    _/    _/ _/_/_/  _/_/_/_/_/    _/_/     _/     _/_/_/    _/_/_/_/_/     _/_/_/              
_/       _/   _/       _/    _/    _/_/           _/        _/       _/    _/    _/       _/        _/     _/
_/       _/   _/       _/    _/    _/             _/        _/       _/   _/_/_/_/_/      _/        _/     _/          
_/       _/   _/       _/    _/    _/             _/  _/    _/       _/    _/      _/     _/  _/    _/     _/          
_/_/_/_/_/    _/       _/    _/    _/             _/_/_/    _/       _/     _/_/_/_/      _/_/_/     _/_/_/ _/     
_/
_/
_/
_/
_/
_/
*/
```

---

## 作者：ChickyHas (赞：2)

第一个很好求，用 dij 跑一边即可。

考虑第二个。首先注意到这个最大化平方和要保证在最短路的基础上，那么我们可以只保留原图中 $d_{to}=d_{now}+w$ 的边，考虑那个代价是 $(dis_i-dis_j)^2$ 因此我们肯定要选得尽量长，不会出现拆成一段段的情况。

我们设 $f_i$ 表示从 $1\rightarrow i$ 的最大答案，那么我们只要枚举这一次坐车的起点 $j$ 然后转移就是 $f_i=max\{f_j+(dis_i-dis_j)^2\}$

考虑平方这个东西，我们把它拆开，变成 $f_i=f_j+dis_i^2+dis_j^2-2dis_idis_j$ 把 $dis_i^2$ 移过去，就变成了 $f_i-dis_i^2=f_j+dis_j^2-2dis_idis_j$ 也即 $b=y-kx$ 的形式，其中 $k=dis_i$ 那么斜率优化就很明了了，相当于有一些点 $(2dis_j,f_j+dis_j^2)$ 然后你拿斜率 $dis_i$ 去过它作直线，求最大截距。

那么我们肯定希望这是一个上凸壳，由于我们每次的 $dis_i$ 肯定是递增的（一开始按dis排序保证它的前驱要比它先访问到），那么直接斜率优化，用栈维护即可。

---

## 作者：Monomial (赞：2)

题意不太好叙述，[原题链接](https://www.luogu.com.cn/problem/P10652)。

第一问就是求 $1$ 到 $n$ 的最短路，跑一下 dij 就可以了，这里时间复杂度 $\mathcal{O}(sum \log sum)$。然后我们来考虑第二问。

为了满足第一问的条件，那么第二问的平方和最大值必定在某一条最短路上，这启示我们建出最短路图来求解，这题是有向边，那么建出来的最短路图必然是一个 DAG，便可以拓扑排序，无须再去考虑求解顺序。

发现到一个点的最大平方和并不会受拓扑序大于它的点的影响，所以我们设 $dp_{i}$ 表示以第 $i$ 个点为终点的最大平方和，转移方程就是 $dp_{i}=\max \{ dp_{j}+(dis_{i}-dis_{j})^2 \}$，其中 $j$ 和 $i$ 在一条铁路上，且 $j$ 的拓扑序小于 $i$，这样才可以转移。

直接这样做是 $\mathcal{O}(sum^2)$ 的，不足以通过，我们尝试用斜率优化去优化转移过程，于是可以对同一条铁路中，每条在最短路图中的极长路径，维护一个相邻两者 $dp_{i}+dis_{i}^2-2dis_{i}x$ 的交点单调递减的单调栈，每次去掉较劣的栈顶后进行转移，这部分时间复杂度是 $\mathcal{O}(sum)$。

总的时间复杂度是 $\mathcal{O}(sum \log sum)$，瓶颈在于最短路。同时注意转移时的单调栈不能用 stl 内的 stack，需要用 vector 或者手写。

---

## 作者：tkdqmx (赞：1)

写起来挺麻烦的一道题目。

首先因为第一问要求最短路，先跑一边 Dijkstra，又因为第二问依赖于最短路，所以再建出最短路图。

对于 $u$ 连向 $v$ 的边，如果在最短路图上，设 $dis_i$ 表示 $1$ 到 $i$ 最短路长，则 $dis_u+w=dis_v$。

建出最短路图后，发现对于每条铁路，一定是一段一段出现在最短路图上的。

考虑设 $dp_i$ 表示终点为 $i$ 时的答案。

对于出现在最短路图上的一段铁路，设它的路径长前缀和数组为 $sum$。

考虑铁路子段 $[l,r]$，可以转移 $dp_r=\max(dp_r,dp_l+(sum_r-sum_l)^2)$。

考虑转移后效性，发现一定是 $dis$ 小的向大的转移，所以按 $dis$ 考虑从小到大枚举点并通过已有数据转移。

现在的复杂度为 $O(m \log m + n^2)$，分别是最短路和转移部分的代价，考虑优化。

发现转移式是经典斜率优化的式子，所以可以用李超线段树优化。

具体地，将每条铁路上的每段连续铁路拆开成不同的铁路，然后记录每个点属于哪些铁路，并对于每段新铁路开李超线段树。

枚举到每个点时，就先在自己可能被更新的李超线段树取值更新，再对这些李超线段树去进行更新。

现在复杂度为 $O(m \log m + n \log V)$，可以通过，代码如下：

~~~cpp
#include<bits/stdc++.h>
using namespace std;
#define N 2000005
#define int long long
#define INF 0x3f3f3f3f3f3f3f3f
bool vis[N];
queue<int> que;
vector<int> num[N],w[N];
vector<pair<int,int>> v[N],in[N];
int n,m,cnt,s[N],d[N],dp[N],rt[N];
priority_queue<pair<int,int>,vector<pair<int,int>>,greater<>> q;
struct Lichao_segment_tree{
	struct line{int k,b;}l[N];
	int cnt=0,lcnt=0,tr[N<<5],ls[N<<5],rs[N<<5];
	void init(){
		fill(tr+1,tr+cnt+1,0),fill(ls+1,ls+cnt+1,0);
		fill(rs+1,rs+cnt+1,0),cnt=lcnt=0,l[0]={0,-INF};
	}
	int calc(int num,int x){return l[num].k*x+l[num].b;}
	void upd(int num,int l,int r,int &p){
		if(!p)  p=++cnt;
		int mid=(l+r)>>1;
		if(calc(num,mid)>calc(tr[p],mid))  swap(num,tr[p]);
		if(calc(num,l)>calc(tr[p],l))  upd(num,l,mid,ls[p]);
		if(calc(num,r)>calc(tr[p],r))  upd(num,mid+1,r,rs[p]);
	}
	void insert(int k,int b,int i){l[++lcnt]={k,b},upd(lcnt,0,1000000000,rt[i]);}
    int query(int x,int p,int l=0,int r=1000000000){
        if(x<l||r<x||!p)  return -INF;
        int mid=(l+r)>>1,sum=calc(tr[p],x);
        if(l==r)  return sum;
        return max({sum,query(x,ls[p],l,mid),query(x,rs[p],mid+1,r)});
    }
}LCT;
void dijkstra(int s){
    memset(d,0x3f,sizeof d),q.emplace(d[s]=0,s);
    while(!q.empty()){
        auto [sum,num]=q.top();q.pop();
        if(vis[num])  continue;
        vis[num]=1,que.push(num);
        for(auto [x,w]:v[num])
            if(d[x]>sum+w)
                q.emplace(d[x]=sum+w,x);
    }
}
signed main(){
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=m;i++){
        scanf("%lld",&s[i]);
        auto &num=::num[i],&w=::w[i];
        num.resize(s[i]+2,0),w.resize(s[i]+1,0);
        for(int j=1;j<=s[i]+1;j++){
            scanf("%lld",&num[j]);
            if(j!=s[i]+1)  scanf("%lld",&w[j]);
        }
        for(int j=1;j<=s[i];j++)
            v[num[j]].emplace_back(num[j+1],w[j]);
    }
    dijkstra(1),LCT.init();
    for(int i=1;i<=m;i++){
        int now=0,dis=0;
        auto &num=::num[i],&w=::w[i];
        for(int j=1;j<=s[i];j++){
            if(d[num[j]]+w[j]!=d[num[j+1]]){now=dis=0;continue;}
            if(!now)  now=++cnt,in[num[j]].emplace_back(cnt,0);
            dis+=w[j],in[num[j+1]].emplace_back(cnt,dis);
        }
    }
    while(!que.empty()){
        int x=que.front();que.pop();
        for(auto [num,dis]:in[x])
            dp[x]=max(dp[x],LCT.query(dis,rt[num])+dis*dis);
        for(auto [num,dis]:in[x])
            LCT.insert(-2*dis,dp[x]+dis*dis,num);
    }
    printf("%lld %lld\n",d[n],dp[n]);
}
~~~

---

## 作者：Kingna (赞：1)

首先满足总长度最小的情况下，求出路径上相邻两个换乘点间火车上距离的平方和最大。那么先将最短路图建出来，我们在最短路图上求第二问答案。

最短路图上，定义 $f_i$ 表示 $1\sim i$ 的最大值。转移有 $f_i=f_j+(d_j-d_i)^2$，其中 $d_i$ 表示 $1\sim i$ 的最短路长度，且 $i,j$ 在同一轨道上。

具体的，我们在最短路图上对轨道进行重新编号。如何操作？因为题目给我们的是一条完整的路径，因为有些边不在最短路图上则会被删掉，则完整的路径会分散成小块。对这些小块进行重新编号即可。

然后对于每一种编号维护一个李超树进行 dp 即可。需要动态开点。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define PII pair<int, int>
#define _for(i, a, b) for (int i = (a); i <= (b); i++)
#define _pfor(i, a, b) for (int i = (a); i >= (b); i--)
#define int long long

const int N = 2e6 + 5;

int n, m, re[N], dist[N], st[N], din[N], f[N], idx;
vector<int> path;
vector<PII> G[N], nG[N];

struct node {
  int u, v, w;
};
vector<node> tr[N], TR[N];

void dijstra(int s) {
  memset(dist, 0x3f, sizeof dist); dist[1] = 0;
  memset(st, 0, sizeof st);
  priority_queue<PII, vector<PII>, greater<PII>> q;
  q.push({0, s});
  while (q.size()) {
    int u = q.top().second; q.pop();
    if (st[u]) continue;
    st[u] = 1;
    for (auto e : G[u]) {
      int v = e.first, w = e.second;
      if (dist[v] > dist[u] + w) {
        dist[v] = dist[u] + w;
        q.push({dist[v], v});
      }
    }
  }
}

int root[N];

struct lc {
  struct edge {
    int k, b;
  }ed[N];
  int cnt = 0, lcnt = 0, tr[N << 3], ls[N << 3], rs[N << 3];
  void init() {
    fill(tr + 1, tr + cnt + 1, 0); fill(ls + 1, ls + cnt + 1, 0);
    fill(rs + 1, rs + cnt + 1, 0); cnt = lcnt = 0;
  }
  int calc(int num, int x) {
    if (num == 0) return -2e18;
    return 1ll * ed[num].k * x + ed[num].b;
  } 
  void modify(int num, int l, int r, int &p) {
    if (!p) p = ++cnt;
    int mid = (l + r) >> 1;
    if (calc(num, mid) > calc(tr[p], mid)) swap(num, tr[p]);
    if (calc(num, l) > calc(tr[p], l)) modify(num, l, mid, ls[p]);
    if (calc(num, r) > calc(tr[p], r)) modify(num, mid + 1, r, rs[p]);
  }
  void insert(int k, int b, int c) { 
    ed[++lcnt] = {k, b};
    modify(lcnt, 0, 1e9, root[c]);
  }
  long long query(int x, int l, int r, int p) {
    if (x < l || r < x || !p) return -2e18;
    long long mid = (l + r) >> 1, sum = calc(tr[p], x);
    if (l == r) return sum;
    return max({sum, query(x, l, mid, ls[p]), query(x, mid + 1, r, rs[p])});
  }
}t;

vector<int> color[N];

signed main() {
  cin >> n >> m;
  _for(i, 1, m) {
    int x;
    cin >> x;
    _for(j, 1, 2 * x + 1) cin >> re[j];
    _for(j, 1, 2 * x - 1) {
      if (j % 2 == 1) {
        tr[i].push_back({re[j], re[j + 2], re[j + 1]});
        G[re[j]].push_back({re[j + 2], re[j + 1]});
      }
    }
  }
  dijstra(1);
  _for(i, 1, m) {
    for (auto e : tr[i]) {
      int u = e.u, v = e.v, w = e.w;
      if (dist[v] == dist[u] + w) TR[i].push_back({u, v, w}), nG[u].push_back({v, w}), din[v]++;
    }
    tr[i].clear();
  }
  _for(i, 1, m) {
    int sz = TR[i].size();
    if (sz == 0) continue;
    idx++;
    tr[idx].push_back(TR[i][0]);
    color[TR[i][0].u].push_back(idx);
    color[TR[i][0].v].push_back(idx);
    _for(j, 1, sz - 1) {
      if (TR[i][j - 1].v != TR[i][j].u) {
        idx++;
        tr[idx].push_back(TR[i][j]);
        color[TR[i][j].u].push_back(idx);
        color[TR[i][j].v].push_back(idx);
      }
      else {
        tr[idx].push_back(TR[i][j]);
        color[TR[i][j].u].push_back(idx);
        color[TR[i][j].v].push_back(idx);
      }
    }
  }
  cout << dist[n] << ' ';
  _for(i, 1, n) {
    sort(color[i].begin(), color[i].end());
    color[i].erase(unique(color[i].begin(), color[i].end()), color[i].end());
  }
  queue<int> q;
  _for(i, 1, n) if (!din[i]) q.push(i);
  while (q.size()) {
    int u = q.front(); q.pop();
    path.push_back(u);
    for (auto v : nG[u]) {
      if (--din[v.first] == 0) q.push(v.first);
    }
  } 
//  cout << color[1][0] << ' ' << color[2][0] << endl;
  f[1] = 0;
  for (auto c : color[1]) {
    t.insert(-2 * dist[1], f[1] * f[1] + dist[1] * dist[1], c);
  }
  for (auto u : path) {
    if (u == 1 || dist[u] > 1e12) continue;
    for (auto c : color[u]) {
      f[u] = max(f[u], t.query(dist[u], 0, 1e9, root[c]) + dist[u] * dist[u]);
    }
    for (auto c : color[u]) {
      t.insert(-2 * dist[u], f[u] + dist[u] * dist[u], c);
    }
  }
  cout << f[n] << endl;
}
```

---

## 作者：ZXZ_ (赞：1)

# P10652 [ROI 2017]题解

## 题意

本题中，我们需要找到一条从 $1$ 号城市到 $n$ 号城市的路径，这条路径需要满足其总长度最小，并且在此条件上路径上相邻两个**换乘点**间**火车上**距离的平方和最大，并输出最短路长度和最大平方和。

## 题解

对于最短路我们直接 dij 就好了。在跑最短路的时候我们记录下前驱，随后建出最短路图，可以发现这是个有向无环图，接着我们考虑如何计算最大平方和。考虑 DP 计算，我们设 $f_{i}$ 表示走到 $i$ 点的最大平方和。那么我们先对我们建出来的最短路图做一个拓扑排序，按照拓扑序来转移。

我们先考虑暴力 DP 怎么做。在最短路图上，我们发现原本完整的一条铁路被分成了很多段，我们把每段作为一条新的铁路。那么每个点 $i$ 可以从和他在同一条铁路上的点 $j$ 转移过来，满足 $j$ 的拓扑序小于 $i$ 就可以转移。转移方程很显然是 $f_{i}=\max(f_{i},f_{j}+(dis_{i}-dis{j})^2)$。

我们考虑怎么优化它。可以想到要用斜率优化，我们将式子拆开得到 $f_{i}=f_{j}+dis_{i}^2-2dis_{i}dis_{j}+dis_{j}^2$。

那么我们可以得到点 $i$ 的斜率为 $2dis_{i}$。接着我们给每一段铁路维护一个凸包，用单调队列实现即可完成转移。

```cpp
#include<bits/stdc++.h>
#define N 2000006
#define int long long
#define pii pair<int,int> 
#define X(i) (dis[i])
#define Y(i) (f[i]+dis[i]*dis[i])
#define K(i) (2*dis[i])
#define Exval(i) (dis[i]*dis[i])
using namespace std;
int n,m,head[N],tot,dis[N],f[N];
vector<int>mn[N],newrw[N];
vector<pii>rw[N];
struct node{int id,pos,w;};
vector<node>pos[N];
struct edge{int nxt,to,w,id;}e[N<<1];
void add(int u,int v,int w,int id){
    e[++tot].nxt=head[u];
    e[tot].to=v;
    e[tot].w=w;
    e[tot].id=id;
    head[u]=tot;
}
double calc(int i,int j){return 1.0*(Y(i)-Y(j))/(X(i)-X(j));}
void debug(){
    puts("asd");
    for(int i=1;i<=m;i++){
        for(auto x:rw[i])
            printf("%lld ",x);
        printf("\n");
    }
    puts("asda");
    for(int i=1;i<=n;i++){
        for(auto x:pos[i])
            printf("{%lld,%lld,%lld}  ",x.id,x.pos,x.w);
        printf("\n");
    }
    puts("asdasd");
}
bool vis[N];
priority_queue<pii,vector<pii>,greater<pii> >q;
void dij(){
    for(int i=1;i<=n;i++)
        dis[i]=1e9;
    dis[1]=0;
    q.push({0,1});
    while(!q.empty()){
        int x=q.top().second;
        q.pop();
        if(vis[x])continue;
        vis[x]=1;
        for(int i=head[x];i;i=e[i].nxt)
            if(dis[e[i].to]>dis[x]+e[i].w){
                dis[e[i].to]=dis[x]+e[i].w;
                mn[e[i].to].clear();
                mn[e[i].to].push_back(x);
                q.push({dis[e[i].to],e[i].to});
            }else if(dis[e[i].to]==dis[x]+e[i].w)mn[e[i].to].push_back(x);
    }
    for(int i=1;i<=n;i++)
        head[i]=0;
    tot=0;
}
int topn[N],cnttop,rd[N];
queue<int>q1;
void topo(){
    q1.push(1);
    while(!q1.empty()){
        int x=q1.front();
        q1.pop();
        topn[++cnttop]=x;
        for(int i=head[x];i;i=e[i].nxt)
            if(rd[e[i].to]){
                rd[e[i].to]--;
                if(rd[e[i].to]==0)q1.push(e[i].to);
            }
    }
}
vector<int>sta[N];
int cntsta;
signed main(){
    // freopen("x.in","r",stdin);
    // freopen("x.out","w",stdout);
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=m;i++){
        int val,x,y,lst;
        scanf("%lld%lld",&val,&x);
        rw[i].push_back({x,0});
        lst=x;
        for(int j=1;j<=val;j++){
            scanf("%lld%lld",&y,&x);
            add(lst,x,y,i);
            rw[i].push_back({x,y});
            // pos[x].push_back({i,j,y});
            lst=x;
        }
    }
    dij();
    for(int i=2;i<=n;i++)
        for(auto x:mn[i])
            add(x,i,dis[i]-dis[x],-1),rd[i]++;
    topo();
        // puts("asdasdddddddddd");
    for(int i=1;i<=m;i++)
        for(int j=0;j<rw[i].size();j++){
            // printf("%lld %lld %lld\n",rw[i][j].first,rw[i][j].second,cntsta);
            if(j==0){
                ++cntsta;
                newrw[cntsta].push_back(rw[i][j].first);
                pos[rw[i][j].first].push_back({cntsta,(int)(newrw[cntsta].size()-1),0});
            }else{
                if(dis[rw[i][j].first]==dis[rw[i][j-1].first]+rw[i][j].second){
                    newrw[cntsta].push_back(rw[i][j].first);
                    pos[rw[i][j].first].push_back({cntsta,(int)(newrw[cntsta].size()-1),0});
                }else{
                    ++cntsta;
                    newrw[cntsta].push_back(rw[i][j].first);
                    pos[rw[i][j].first].push_back({cntsta,(int)(newrw[cntsta].size()-1),0});
                }
            }
        }
    // for(int i=1;i<=n;i++){
    //     puts("---");
    //     for(auto x:pos[i])printf("{%lld,%lld}  ",x.id,x.pos);
    //     puts("\n");
    // }
    for(int i=1;i<=cnttop;i++){
        int x=topn[i];
        for(auto y:pos[x]){
            if(y.pos){
                // printf("\noooop   %lld %lld %lld\n",x,y.id,sta[y.id].size());
                while(sta[y.id].size()>1&&calc(sta[y.id][sta[y.id].size()-2],sta[y.id][sta[y.id].size()-1])<=(double)K(x))
                    sta[y.id].pop_back();
                if(!sta[y.id].empty()){
                    int j=sta[y.id].back();
                    f[x]=max(f[x],f[j]+(dis[x]-dis[j])*(dis[x]-dis[j]));
                    // printf("??? %lld %lld %lld %lld %lld %lld\n",x,j,f[j],f[x],dis[x],dis[j]);
                }
                // sta[y.id].push_back(x);
            }
                // printf("zxz %lld %lld %lld %lld\n",x,y.id,sta[y.id].size(),y.pos);
            
        }
        for(auto y:pos[x]){
            while(sta[y.id].size()>1&&calc(sta[y.id][sta[y.id].size()-2],sta[y.id][sta[y.id].size()-1])<=calc(sta[y.id][sta[y.id].size()-1],x))
                sta[y.id].pop_back();
            sta[y.id].push_back(x);
        }
        // puts("-----------------------");
    }
    printf("%lld %lld\n",dis[n],f[n]);
}
```

---

## 作者：zyn0309 (赞：1)

## 思路
定义 $dis_u$ 为起点到 $u$ 的最短路。

第一问就是 $dis_n$，直接最短路即可。

然后第二问，容易发现只有最短路树上的边才有贡献。（即对于一条从 $u$ 到 $v$ 的长度为 $c$ 的边，若 $dis_u + c=dis_v$ 才会保留这条边。）

设 $dp_u$ 为最短路树到 $u$ 的路径上相邻两个**换乘点**间**火车上**距离的平方和最大值。

建出最短路树后，对于在同一条于铁路的两点 $u$ 和 $v$，若 $dis_u>dis_v$，且该铁路在最短树上仍然连通 $u$ 和 $v$，则有 $dp_v=\max(dp_u+(dis_v-dis_u)^2)$。看到这个自然想到斜率优化。

具体而言，我们可以把原来的铁路根据在最短路树上是否连通来对原来的铁路重新标号，对于每一条重新标号后的铁路分别维护李超线段树，由于最短路树是一个 DAG，直接拓扑排序转移即可。
## Code
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e6+10;
const ll inf=1e18,L=0,R=1e9;
int n,m,p[N],cnt,tot,root[N],d[N],cnt2;
ll dis[N],dp[N];
#define mk make_pair
#define pii  pair<ll,ll> 
#define pb push_back
vector<pair<pii,int> >e[N],e2[N];
vector<int>f[N];
map<int,int>top[N];
inline void dij(int s){
	priority_queue<pii,vector<pii>,greater<pii> >q;
	for(int i=1;i<=n;++i)dis[i]=inf;
	dis[s]=0;
	q.push(mk(0,s));
	while(!q.empty()){
	  int u=q.top().second;
	  ll c=q.top().first;
	  q.pop();
	  if(dis[u]!=c)continue;
	  for(auto p:e[u]){
		int v=p.first.first;
		ll c=p.first.second;
		if(dis[u]+c<dis[v]){
		  dis[v]=dis[u]+c;
		  q.push(mk(dis[v],v));
		}
	  }
	}
}
struct segment{
	ll k,b;
}s[N];
struct LiChao_tree{
	int lson,rson,id;
}t[50*N];
inline ll getval(ll x,int id){return s[id].k*x+s[id].b;}
inline void update(int &u,ll l,ll r,int id){
	if(!u)u=++tot;
	if(!t[u].id){
	  t[u].id=id;
	  return;
	}
	if(getval(l,id)<=getval(l,t[u].id)&&getval(r,id)<=getval(r,t[u].id))return;
	if(getval(l,id)>=getval(l,t[u].id)&&getval(r,id)>=getval(r,t[u].id)){
	  t[u].id=id;
	  return;
	}
	ll mid=(l+r)>>1;
	update(t[u].lson,l,mid,id);
	update(t[u].rson,mid+1,r,id);
}
inline ll query(int u,ll l,ll r,ll x){
	if(!u)return -inf;
	ll mid=(l+r)>>1;
	if(x<=mid)return max(query(t[u].lson,l,mid,x),getval(x,t[u].id));
	else return max(query(t[u].rson,mid+1,r,x),getval(x,t[u].id));
}
inline void topusort(){
	queue<int>q;
	for(int i=1;i<=n;++i)if(!d[i])q.push(i);
	while(!q.empty()){
	  int u=q.front();
	  q.pop();
	  for(int id:f[u])dp[u]=max(dp[u],dis[u]*dis[u]+query(root[id],L,R,dis[u]));
	  ++cnt;
	  s[cnt].k=-2ll*dis[u];
	  s[cnt].b=dis[u]*dis[u]+dp[u];
	  for(int id:f[u])update(root[id],L,R,cnt);
	  for(auto p:e2[u]){
		int v=p.first.first;
		--d[v];
		if(!d[v])q.push(v);
	  }
	}
}
inline bool cmp(int a,int b){return dis[a]<dis[b];}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	s[0].b=-inf;
	int s,u,v,c;
	for(int i=1;i<=m;++i){
	  cin>>s;
	  u=v=0;
	  for(int j=1;j<=(2*s+1);++j){
		if(j&1){
		  v=u;
		  cin>>u;
		  if(v)e[v].pb(mk(mk(u,c),i));
		}
		else cin>>c;
	  }
	}
	dij(1);
	for(int i=1;i<=n;++i)p[i]=i;
	sort(p+1,p+1+n,cmp);
	for(int i=1;i<=n;++i){
	  int u=p[i];
	  for(auto p:e[u]){
		int v=p.first.first,id=p.second;
		if(!top[u][id]){
		  top[u][id]=++cnt2;
		  f[u].pb(top[u][id]);
		}
		ll c=p.first.second;
		if(dis[u]+c==dis[v]){
		  top[v][id]=top[u][id];
		  e2[u].pb(mk(mk(v,c),top[u][id]));
		  ++d[v];
		  f[v].pb(top[u][id]);
		}
	  }
	}
	topusort();
	cout<<dis[n]<<" "<<dp[n]<<"\n";
	return 0;
}
```

---

## 作者：xie_lzh (赞：1)

#### 题意简述

给你一个带权有向图，图上有一些铁路，你可以走一条铁路上的边，或者从当前站点换乘同样经过该站的另一条铁路。要求在使从起点到终点最短路最小的前提下，所有在同一条铁路上行进的连续段长度的平方和最大。


容易发现可以先跑最短路，求得原图的最短路图，只有在最短路图上的边可能有贡献，所以现在我们只需要使得平方和最大。

故所有原本的铁路可能在最短路图上被拆分为了若干个连续段。我们可以发现位于同一铁路上不同连续段的两点不能产生贡献。

所以我们可以重新划分铁路，将每条铁路的不同连续段视作一条独立的铁路，则我们只会在铁路内部转移。


设 $f_x$ 表示最大平方和，转移可以由所有和 $x$ 在同一条新划分铁路上的距离终点比自己更近的点转移。按到终点距离从小到大地枚举点转移即可。这样直接做是 $\Theta(n^2)$ 的。

考虑决策单调性，我们发现平方和这种贡献方式有着反向的决策单调性，即随着距离的增大，本来比较靠近终点的点有更优秀的贡献，即包含大于相交。我们可以用二分栈维护决策点贡献的区间，具体而言，每条铁路开个栈直接维护就行。这样做是 $\Theta(n\log n)$ 的。

这里插一句，有人认为包含大于相交这种不能叫做决策单调性，因为这个的决策点确实是不单调的。但是个人认为他们具有相似的性质，将其称为反向决策单调性更便于理解。

既然都能决策单调性了，那我们可以想想，能不能再优化一点呢？

考虑斜率优化。

定义 $dis_i$ 表示从起点到 $i$ 的距离。

对于在同一新划分铁路上的两点 $i$ $j$，当他们要贡献到 $k$ 时。我们钦定 $i$ 更优秀，则可以列出如下式子。

$$f_i +(dis_i-dis_k)^2>f_j+(dis_j-dis_i)^2$$

$$f_i +{dis_i}^2-2dis_idis_k>f_j+{dis_j}^2-2dis_jdis_k$$

$$\frac{(f_i+{dis_i}^2)-(f_j+{dis_j}^2)}{dis_i-dis_j}>2dis_k$$

由于我们的枚举顺序使得 $dis_k$ 单调不升，所以直接有单调栈维护以下即可。

复杂度 $\Theta(n+sum)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
#define pii pair<int,int>
int n,m,k[N],dis[N],tot,hd[N],id[N];
#define ll long long 
ll f[N];
bool vis[N],visl[N];
vector<int> vec[N],vl[N],bel[N];
vector<pii> pre[N];
int head[N],to[N],nxt[N],val[N],cnt;
void add(int u,int v,int w) { to[++cnt]=v; nxt[cnt]=head[u]; head[u]=cnt; val[cnt]=w; }
double calc(int x,int y) { return 1.0*(f[x]+1.0*dis[x]*dis[x]-f[y]-1.0*dis[y]*dis[y])/2.0/(dis[x]-dis[y]); }
void dij()
{
    priority_queue<pii,vector<pii>,greater<pii>> q;
    q.push({0,1}); memset(dis,0x3f,sizeof dis); dis[1]=0;
    while(!q.empty())
    {
        int u=q.top().second; q.pop();
        if(vis[u]) continue; vis[u]=1;
        for(int i=head[u];i;i=nxt[i])
        {
            int v=to[i],w=val[i];
            if(dis[v]<dis[u]+w) continue;
            if(dis[v]==dis[u]+w) pre[v].push_back({u,i});
            else
            {
                // while(pre[v].size()) visl[pre[v].back()]=1,pre[v].pop_back();
                pre[v].clear(); pre[v].push_back({u,i});
                dis[v]=dis[u]+w; q.push({dis[v],v});
            }
        }
    }
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        cin>>k[i]; int x,y,w;cin>>x; vec[i].push_back(x);
        for(int j=1;j<=k[i];j++)
        {
            cin>>w>>y,add(x,y,w),vl[i].push_back(cnt);
            x=y; vec[i].push_back(x);
        }
    }
    dij(); memset(vis,0,sizeof vis); memset(visl,1,sizeof visl);
    queue<int> q; q.push(n); vis[n]=1;
    while(!q.empty())
    {
        int u=q.front(); q.pop();
        for(auto [v,i]:pre[u])
        {
            visl[i]=0;
            if(!vis[v]) q.push(v),vis[v]=1;
        }
    }
    for(int i=1;i<=m;i++)
    {
        for(int j=0;j<vl[i].size();j++)
        {
            if(!visl[vl[i][j]])
            {
                if(j==0||visl[vl[i][j-1]])
                    ++tot,bel[vec[i][j]].push_back(tot);
                bel[vec[i][j+1]].push_back(tot);
            }
        }
        vec[i].clear();
    }
    iota(id+1,id+1+n,1); sort(id+1,id+1+n,[](int x,int y){return dis[x]>dis[y];});
    for(int i=1;i<=n;i++)
    {
        int x=id[i];
        f[x]=0;
        for(int p:bel[x])
        {
            if(vec[p].empty()) continue;
            while(vec[p].size()>1&&calc(vec[p][vec[p].size()-2],vec[p].back())>dis[x])
                vec[p].pop_back();
            int j=vec[p].back();
            f[x]=max(f[x],f[j]+1ll*(dis[j]-dis[x])*(dis[j]-dis[x]));
        }
        for(int p:bel[x])
        {
            while(vec[p].size()>1&&calc(vec[p][vec[p].size()-2],vec[p].back())>calc(vec[p].back(),x))
                vec[p].pop_back();
            vec[p].push_back(x);
        }
    }
    cout<<dis[n]<<' ';
    cout<<f[1]<<'\n';
}
```

---

## 作者：cqbzlzm (赞：0)

### Description

ROI 国有 $n$ 个城市，以及 $m$ 条铁路，每条铁路都是**单向**运行的，第 $i$ 条铁路依次经过 $v_{i,1},v_{i,2},\dots,v_{i,l_i+1}$ 号城市并停靠，其中 $v_{i,j} \to v_{i,j+1}$ 的铁路长度是 $t_{i,j}$。

你需要找到一条从 $1$ 号城市到 $n$ 号城市的路径，这条路径需要满足其总长度最小，并且在此条件上路径上相邻两个**换乘点**距离的平方和最大。

### Solution

首先容易想到把最短路图建出来，然后拓扑排序。

和一般的 DAG 上的 dp 不同，这里只要求 DAG 上的偏序关系。

然后 $dp_i=dp_j+(d_i-d_j)^2$，要满足两个条件：

1. $j$ 在 $i$ 之前（拓扑）
2. $j$ 和 $i$ 在**同一条铁路上**

建最短路图会删掉一些边，会把原来的铁路分成几段，这个**在同一条铁路**指的是删边后在同一段。

这里就可以 $O(n^2)$ 做了，优化可以给每个**新铁路**开一个李超线段树。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int MAXN = 2e6, MAXM = 2e6, inf = 1e18;
int n, m;
vector<pair<int, int> > G[MAXN + 5];
vector<pair<int, int> > T[MAXN + 5];

struct node {
	int u, d;
	friend bool operator <(node a, node b) {
		return a.d > b.d;
	}
} ;
bool vis[MAXN + 5];
int dist[MAXN + 5];
void Dijkstra(int s) {
	memset(dist, 0x3f3f3f3f, sizeof(dist));
	dist[s] = 0;
	priority_queue<node> q; q.push({s, 0});
	while (!q.empty()) {
		int u = q.top().u; q.pop();
		if (vis[u]) continue; vis[u] = 1;
		for (auto e : G[u]) {
			int v = e.first, w = e.second;
			if (dist[v] > dist[u] + w) {
				dist[v] = dist[u] + w;
				q.push({v, dist[v]});
			}
		}
	}
	return ;
}
bool ex[MAXM + 5];
struct edge {
	int u, v, w;
} E[MAXM + 5], E2[MAXM + 5];
int M, MM;
int L[MAXN + 5], R[MAXN + 5], id[MAXM + 5];

int in[MAXN + 5];
int ord[MAXN + 5];



namespace fhz {
	int root[MAXN + 5];
	struct line {
		int k, b;
		line(){k = 0, b = -inf;}
		line(int kk, int bb){k = kk, b = bb;}
	} Line[MAXM + 5];
	int lineCnt, nodeCnt, lc[MAXN + 5], rc[MAXN + 5], val[MAXN + 5];
	int newLine(int k, int b) {
		Line[++ lineCnt] = {k, b};
		return lineCnt;
	}
	int calc(int i, int x) {
		return Line[i].k * x + Line[i].b;
	}
	void insert(int &id, int l, int r, int x) {
		if (x == 0) return ;
		if (id == 0) {
			id = ++ nodeCnt;
			val[id] = x;
			return ;
		}
		int mid = (l + r) >> 1;
		if (calc(x, mid) > calc(val[id], mid)) swap(x, val[id]);
		if (l == r) return ;

		if (calc(x, l) > calc(val[id], l)) insert(lc[id], l, mid, x);
		if (calc(x, r) > calc(val[id], r)) insert(rc[id], mid + 1, r, x);
		return ;
	}
	int query(int id, int l, int r, int x) {
		if (id == 0) return -inf;
		if (l == r) return calc(val[id], x);
		int mid = (l + r) >> 1, res = calc(val[id], x);
		if (x <= mid) res = max(res, query(lc[id], l, mid, x));
		else res = max(res, query(rc[id], mid + 1, r, x));
		return res;
	}
}
int dp[MAXN + 5];
vector<int> vec[MAXN + 5];
signed main() {
	scanf("%lld%lld", &n, &m);
	for (int i = 1; i <= m; i ++) {
		int s, u; scanf("%lld%lld", &s, &u);
		L[i] = M + 1;
		for (int j = 1; j <= s; j ++) {
			int w, v; scanf("%lld%lld", &w, &v);
			G[u].push_back({v, w});
			E[++ M] = {u, v, w};
			u = v;
		}
		R[i] = M;
	}
	Dijkstra(1);
	for (int i = 1; i <= M; i ++) {
		int u = E[i].u, v = E[i].v, w = E[i].w;
		if (dist[u] + w == dist[v]) {
			ex[i] = 1;
			T[u].push_back({v, w});
			in[v] ++;
		}
	}
	for (int i = 1; i <= m; i ++) {
		for (int j = L[i]; j <= R[i]; j ++) {
			if (ex[j]) {
				if (j != L[i] && ex[j - 1]) id[j] = id[j - 1];
				else id[j] = ++ MM;
			}
		}
	}
	int ccc = 0;
	for (int i = 1; i <= M; i ++) {
		if (ex[i]) {
			vec[E[i].u].push_back(id[i]);
			vec[E[i].v].push_back(id[i]);
			ccc += 2;
		}
	}
	for (int i = 1; i <= n; i ++) {
		sort(vec[i].begin(), vec[i].end());
		vec[i].erase(unique(vec[i].begin(), vec[i].end()), vec[i].end());
	}

	queue<int> q; 
	for (int i = 1; i <= n; i ++) {
		if (!in[i]) q.push(i);
	}
	int OO = 0;
	while (!q.empty()) {
		int u = q.front(); q.pop();
		ord[++ OO] = u;
		for (auto e : T[u]) {
			int v = e.first;
			if (!(-- in[v])) q.push(v);
		}
	}



	for (int i = 1; i <= n; i ++) {
		int u = ord[i];
		for (int j : vec[u]) {
			dp[u] = max(dp[u], fhz::query(fhz::root[j], 0, dist[n], dist[u]) + dist[u] * dist[u]);
		}
		for (int j : vec[u]) {
			fhz::insert(fhz::root[j], 0, dist[n], fhz::newLine(-2 * dist[u], dp[u] + dist[u] * dist[u]));
		}
	}
	cout<<dist[n]<<' '<<dp[n];
	return 0;
}
```

---

## 作者：MornStar (赞：0)

### [P10652 [ROI 2017] 前往大都会 (Day 1)](https://www.luogu.com.cn/problem/P10652)

第一问是平凡的最短路。

第二问明示要把最短路图建出来，所以先建最短路图。

将 $dis_{to}=dis_u+w$ 的边保留下来即可。

然后是一条线路会被断开，这个时候需要将其拆成多条线路重新编号，因为这些断开的线路在之后已经没有关联了。

由于最短路图是 DAG，所以按 dis（或者拓扑序）排序可以去除后效性，对于在与 $i$ 同一线路上且 $dis_j<dis_i$ 的 $j$ 有转移方程 $dp_i=dp_j+(dis_i-dis_j)^2$，然后就是很套路的斜优了。

时间复杂度 $O(n\log n)$。

最后调了半个小时是因为没按 dis 排序，寄。

### code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define PII pair<int,int>
#define PLI pair<ll,int>
#define PIL pair<int,ll>
#define PLL pair<ll,ll>
#define fi first
#define se second
#define YES() cout<<"YES\n",0
#define NO() cout<<"NO\n",0
#define Yes() cout<<"Yes\n",0
#define No() cout<<"No\n",0
using ll=long long;
using uint=unsigned int;
using ull=unsigned long long;
using lb=long double;
const ll N=1e6+5,INF=0x3f3f3f3f3f3f3f3f;
struct edge{ll to,w,c;};
vector<edge>e[N];
vector<ll>dis;
vector<bool>vis;
struct node{
	ll now,dis;
	friend bool operator<(node x,node y){return x.dis>y.dis;}
};
priority_queue<node>q;
template<typename T>
void Dijkstra(int nc,int st,vector<edge>* g,vector<T>& dis){	
	dis.assign(nc+1,INF);
	vis.assign(nc+1,0);
	dis[st]=0;q.push({st,0});
	while(!q.empty()){
		int now=q.top().now;q.pop();
		if(vis[now])	continue;
		vis[now]=1;
		for(auto it:g[now]){
			if(dis[it.to]>dis[now]+it.w){
				dis[it.to]=dis[now]+it.w;
				q.push({it.to,dis[it.to]});
			}
		}
	}
}
struct LC_segment_tree{
	struct line{
		ll k,b;
		ll calc(ll x){return k*x+b;}
	}li[N];
	int cnt=0,siz=0,rt[N];
	struct segment_tree_node{int ls,rs,lazy;}t[N<<1];
	bool cmp(line a,line b,ll x){return a.calc(x)>b.calc(x);}
	void clear(){cnt=siz=0;}
	inline int new_node(){t[++siz]={0,0,0};	return siz;}
#define ls(p) t[p].ls
#define rs(p) t[p].rs
#define mid ((l+r)>>1)
	void change(int& p,int l,int r,int num){
		if(!p)	p=new_node();
		if(cmp(li[num],li[t[p].lazy],mid))	swap(num,t[p].lazy);
		if(cmp(li[num],li[t[p].lazy],l))	change(ls(p),l,mid,num);
		if(cmp(li[num],li[t[p].lazy],r))	change(rs(p),mid+1,r,num);
	}
	ll query(int p,int l,int r,int pos){
		if(!p)	return -INF;
		ll ret=li[t[p].lazy].calc(pos);
		if(l==r)	return ret;
		else{
			if(pos<=mid)	return max(ret,query(ls(p),l,mid,pos));
			else	return max(ret,query(rs(p),mid+1,r,pos));
		}
	}
	void add(ll k,ll b,vector<int>v){
		li[++cnt]={k,b};
		for(auto it:v)	change(rt[it],0,1e9,cnt);
	}
}T;
bool cmp(int x,int y){return dis[x]<dis[y];}
ll n,m,p[N],dp[N],c;
vector<int>in[N],num[N];
map<PII,bool>mp[N];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	cin>>n>>m;T.li[0]={0,-INF};
	for(int i=1,k,lst;i<=m;i++){
		cin>>k>>lst;num[i].push_back(lst);
		for(int j=1,t,to;j<=k;j++)	cin>>t>>to,e[lst].push_back({to,t,i}),num[i].push_back(to),lst=to;
	}
	Dijkstra(n,1,e,dis);
	for(int i=1;i<=n;i++){
		for(auto it:e[i]){
			if(dis[i]+it.w==dis[it.to])	mp[it.c][{i,it.to}]=1;
		}
	}
	for(int i=1;i<=m;i++){
		for(int j=0,lst=-1;j<num[i].size();j++){
			if((j+1==(int)num[i].size()||!mp[i][{num[i][j],num[i][j+1]}])&&lst!=-1){
				c++;
				for(int k=lst;k<=j;k++)		in[num[i][k]].push_back(c);
				lst=-1;
			}else if(mp[i][{num[i][j],num[i][j+1]}]){
				if(lst==-1)	lst=j;
			}
		}
	}
	for(int i=1;i<=n;i++)	sort(in[i].begin(),in[i].end()),in[i].resize(unique(in[i].begin(),in[i].end())-in[i].begin());
	for(int i=1;i<=n;i++)	p[i]=i;sort(p+1,p+n+1,cmp);
	for(int i=1;i<=n;i++){
		for(auto it:in[p[i]])	dp[p[i]]=max(dp[p[i]],T.query(T.rt[it],0,1e9,dis[p[i]])+dis[p[i]]*dis[p[i]]);
		T.add(-2*dis[p[i]],dp[p[i]]+dis[p[i]]*dis[p[i]],in[p[i]]);
	}
	cout<<dis[n]<<" "<<dp[n]<<"\n";
}
```

---

## 作者：LastKismet (赞：0)

# Sol
最短路部分就省略了。

考虑第二个怎么求，首先我们先建出最短路图，判断每条边是否在最短路内即可，若 $dis_v=dis_u+edgeval$ 则在最短路图中。

对于每条铁路线，他必然被分成了几段连续的在最短路图之中的段，这很显然。那么就可以考虑对每一段内分别动态规划，易得 $f_j=\max_{i<j}f_i+(\sum_{k=i}^{j-1}t_k)^2$，后面那一坨显然可以前缀和优化。

不难想到斜率优化，对新的每一段分别斜优即可。可以按 $dis$ 升序处理每个点。

这里采用李超树实现。

# Code
```cpp
const int N=1e6+5,S=2e6+5;

int n,m,sm,mm;
int l[N],r[N];
ll dis[N];
int hd[N],to[N],ne[N];ll ed[N];
int ecnt;
inline void adde(int a,int b,ll c){
    ++ecnt;
    to[ecnt]=b;
    ne[ecnt]=hd[a];
    ed[ecnt]=c;
    hd[a]=ecnt;
}
int k[N];
int v[S];ll t[S];
int lm[S],rm[S];
ll sum[S];

lrheap<pli> pq;
inline void dij(){
    rep(i,1,n)dis[i]=INF;
    dis[1]=0;pq.push({dis[1],1});
    while(pq.size()){
        auto tp=pq.top();pq.pop();
        if(tp.fir>dis[tp.sec])continue;
        int x=tp.sec;
        for(int e=hd[x];e;e=ne[e])if(dis[to[e]]>dis[x]+ed[e]){
            dis[to[e]]=dis[x]+ed[e];
            pq.push({dis[to[e]],to[e]});
        }
    }
}

int lcnt;
struct line{
    ll k,b;
    ll y(ll x){return k*sum[x]+b;}
}ls[S];
struct lsegment{
    int dat[S<<2];
    #define cmp(a,b,x) (ls[a].y(x)>ls[b].y(x))
    void insert(int lq,int rq,int id,int x=1,int l=1,int r=sm){
        if(lq<=l&&r<=rq){
            if(!dat[x]){
                dat[x]=id;
                return;
            }
            int m=l+r>>1;
            if(cmp(id,dat[x],m))swap(dat[x],id);
            if(cmp(id,dat[x],l))insert(lq,rq,id,x<<1,l,m);
            if(cmp(id,dat[x],r))insert(lq,rq,id,x<<1|1,m+1,r);
            return;
        }
        int m=l+r>>1;
        if(lq<=m)insert(lq,rq,id,x<<1,l,m);
        if(m<rq)insert(lq,rq,id,x<<1|1,m+1,r);
    }
    int query(int k,int x=1,int l=1,int r=sm){
        if(l==r)return dat[x];
        int m=l+r>>1,res=0;
        if(k<=m)res=query(k,x<<1,l,m);
        else res=query(k,x<<1|1,m+1,r);
        if(!res||dat[x]&&cmp(dat[x],res,k))res=dat[x];
        return res;
    }
}lseg;

vec<pii> vc[N];
int rk[N];
ll dat[N];

int kkk;

inline void Main(){
    cin>>n>>m;
    rep(i,1,m){
        cin>>k[i];
        l[i]=sm+1;r[i]=(sm+=k[i]+1);
        repl(j,l[i],r[i])cin>>v[j]>>t[j];
        cin>>v[r[i]];
        repl(j,l[i],r[i])adde(v[j],v[j+1],t[j]),++kkk;
    }
    dij();
    cout<<dis[n]<<" ";
    rep(i,1,m){
        int lst=l[i];
        repl(j,l[i],r[i]){
            if(dis[v[j+1]]!=dis[v[j]]+t[j]){
                if(lst!=j){
                    ++mm;
                    lm[mm]=lst,rm[mm]=j;
                    rep(i,lm[mm],rm[mm])vc[v[i]].pub({mm,i});
                }
                lst=j+1;
            }
        }
        if(lst!=r[i]){
            ++mm;
            lm[mm]=lst,rm[mm]=r[i];
            rep(i,lm[mm],rm[mm])vc[v[i]].pub({mm,i});
        }
    }
    rep(i,1,sm)sum[i]=sum[i-1]+t[i-1];
    rep(i,1,n)rk[i]=i;
    sort(rk+1,rk+1+n,[&](int a,int b){return dis[a]<dis[b];});
    rep(i,1,n){
        int x=rk[i];
        for(auto i:vc[x]){
            int q=i.fir,j=i.sec;
            if(lm[q]<j)chmax(dat[x],ls[lseg.query(j)].y(j)+sum[j]*sum[j]);
        }
        for(auto i:vc[x]){
            int q=i.fir,j=i.sec;
            if(j<rm[q])ls[++lcnt]={-2*sum[j],dat[x]+sum[j]*sum[j]},lseg.insert(j+1,rm[q],lcnt);
        }
    }
    put(dat[n]);
}
```

---


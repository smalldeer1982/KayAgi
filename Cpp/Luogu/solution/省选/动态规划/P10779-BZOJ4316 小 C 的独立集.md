# BZOJ4316 小 C 的独立集

## 题目描述

给定简单无向图 $G = (V, E)$，保证每条边属于且仅属于一个简单环，求 $G$ 的最大独立集大小。

## 说明/提示

对于 $100\%$ 的数据，$1\leq n\leq 5\times 10^4$，$1\leq m\leq 6\times 10^4$。

## 样例 #1

### 输入

```
5 6
1 2
2 3
3 1
3 4
4 5
3 5```

### 输出

```
2```

# 题解

## 作者：Elaina_0 (赞：5)

# P10779 BZOJ4316 小 C 的独立集

感谢管理大大的审核

虽然在圆方树专题中，但我们没有必要把圆方树建出来...


AD：[$\large 博客喵$~](https://www.cnblogs.com/Elaina-0/p/18320483)

## 题意

给出一个仙人掌图，求[最大独立集](https://oi-wiki.org/graph/concept/#%E7%8B%AC%E7%AB%8B%E9%9B%86)

就像是[没有上司的舞会](https://www.luogu.com.cn/problem/P1352)超级加倍

没有做过的可以先去康康~

## 分析

显然树形DP，但是是在仙人掌图上。

至于啥是仙人掌图嘛~

感性的李姐一下就是一棵树塞几个基环且强连通。

引用某dalao的一张图就是：

![](https://cdn.luogu.com.cn/upload/image_hosting/032c2d6a.png)

由于有环，不难想到 Tarjan，所以我们考虑在 Tarjan 的过程中求解。

我们设 $f[i][1/0]$ 为 $i$ 节点 $选/不选$ 的最优答案，

当一条边是树边的时候，正常DP。

否则暂时不转移。

当我们做完当前点，发现它是一个环的最顶端的时候，我们需要重新对这个环计算一遍答案。

从这个环的最底端开始往上跳，每次合并一次答案。

维护两个变量 $f0,f1$，表示当前点选或者不选的答案。

考虑分讨：

- 若最顶端不选

  显然最底端选或者不选是没有影响的。然后正常转移，最后把算出来的 $f0$直接加给顶点。

- 若顶端选

  那么最底下的那个点就一定不能选，直接令 $f1$ 初值为 $-inf$，然后正常转移就好了。

没了。

## Code

```cpp
#include<bits/stdc++.h>
#define 我永远喜欢 return
#define 伊蕾娜 0;
using namespace std;
#define int long long
#define rd read()
#define pii pair<int,int>
#define mkp make_pair
#define psb push_back
inline int read(){
	int f=1,x=0;
	char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) f=(ch=='-'?-1:1);
	for(;isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';
	return f*x;
}
const int N=1e5+100;
const int inf=0x7fffffff7fffffff;

int n,m,cnt,f[N][2],fa[N];
vector<int> G[N],T[N*2];
int dfn[N],low[N],num;

void dp(int x,int y){
	int g0=0,g1=0,f0=0,f1=0;
	for(int i=y;i!=x;i=fa[i]){
		g0=f0+f[i][0],g1=f1+f[i][1];
		f0=max(g0,g1),f1=g0;
	}
	f[x][0]+=f0;

	f0=0,f1=-inf;
	for(int i=y;i!=x;i=fa[i]){
		g0=f0+f[i][0],g1=f1+f[i][1];
		f0=max(g0,g1),f1=g0;
	}
	f[x][1]+=f1;
}

void tarjan(int x,int ff){
	fa[x]=ff;
	low[x]=dfn[x]=++num;
	f[x][1]=1,f[x][0]=0;
	for(auto to:G[x]){
		if(!dfn[to]){
			tarjan(to,x);
			low[x]=min(low[x],low[to]);
		}else if(to!=ff){
			low[x]=min(low[x],dfn[to]);
		}
		if(low[to]>dfn[x]){
			f[x][1]+=f[to][0],f[x][0]+=max(f[to][0],f[to][1]);
		}
	}
	for(auto to:G[x]){
		if(fa[to]!=x&&dfn[x]<dfn[to]){
			dp(x,to);
		}
	}
}

signed main(){
	n=rd,m=rd;
	for(int i=1;i<=m;i++){
		int x=rd,y=rd;
		G[x].psb(y);
		G[y].psb(x);
	}
	tarjan(1,0);
	printf("%lld",max(f[1][0],f[1][1]));
	我永远喜欢 伊蕾娜
}
```

---

## 作者：XZhuRen (赞：1)

仙人掌最大独立集板子，感觉应该降蓝。

状态同没有上司的舞会，考虑类似 Tarjan 的 dfs 方式。

由于仙人掌图的特性，由 $u$ 遍历到一个遍历过的点 $v$ 就说明两点在一个环上，且两点之间的所有点恰好构成了这个环。

不需要真的像 Tarjan 那样缩点找出点双，直接在遇到一个环的时候，强制钦定当前点 $u$，**选**或**不选**（不选不用钦定），从环底 $v$ 开始重新 DP 就好。

每个环被访问一次，最多有约 $2n$ 次访问，时间复杂度线性。

Code：


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
//仙人掌最大独立集
//考虑树上DP
//环顶端强制钦定分讨
//其他正常DP
//没了
//最多 2n 次访问，时间线性
struct edge{
	int u,v,nxt;
}E[N*2];
int head[N],tote=0;
void ae(int u,int v){
	E[++tote]=(edge){u,v,head[u]};
	head[u]=tote;
}
int n,m;
namespace tarjan{
	int fa[N];
	int dfn[N],low[N],tdfn=0;
	int f[N][2];
	bool vis[N];
	int g[N][2];//tmp
	int solve(int top,int bot){
		int u=fa[bot];
		int lst=bot;
		while(lst!=top){
			g[u][0]=f[u][0]-max(f[lst][0],f[lst][1]);
			g[u][1]=f[u][1]-f[lst][0];
			lst=u,u=fa[u];
		}
		g[bot][0]=f[bot][0];
		g[bot][1]=-N;
		lst=bot,u=fa[bot];
		while(lst!=top){
			g[u][0]+=max(g[lst][0],g[lst][1]);
			g[u][1]+=g[lst][0];
			lst=u,u=fa[u];
		}
		return g[top][1];
	}//返回f[u][1]的值
	void Tarjan(int u,int Fa){
		fa[u]=Fa;
		dfn[u]=low[u]=++tdfn;
		vis[u]=1;
		f[u][0]=0,f[u][1]=1;
		for(int e=head[u],v;e;e=E[e].nxt){
			v=E[e].v;if(v==Fa)continue;
			if(!vis[v]){
				Tarjan(v,u);
				low[u]=min(low[u],low[v]);
				f[u][0]+=max(f[v][0],f[v][1]);
				f[u][1]+=f[v][0];
			}else{
				low[u]=min(low[u],dfn[v]);
				if(dfn[v]>dfn[u])//返祖边
					f[u][1]=solve(u,v);
			}
		}
	}
}
void init(){
	int u,v;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&u,&v);
		ae(u,v);ae(v,u);
	}
}
void work(){
	tarjan::Tarjan(1,0);
	printf("%d\n",max(tarjan::f[1][0],tarjan::f[1][1]));
}
int main(){
	init();
	work();
	return 0;
}
```

---

## 作者：qzmoot (赞：1)

# 题解：P10779 BZOJ4316 小 C 的独立集
## 题目大意
要做这道题，我们必须要知道什么是独立集。独立集就是一个集合 $A$，$\forall a\in A$ 保证 $a$ 不是互相相邻的。所以我们就可以很快地知道，如果这道题目在树上该怎么做。
## 拆分问题-树上
我们设状态 $f[i][0]$ 表示 $i$ 号节点不在集合内，则 $f[i][1]$ 表示在集合内。于是我们很快就能写出转移了。

钦定 $v$ 为 $i$ 能直接到达的点。

1. $f[i][0]=\sum_v \max(f[v][0],f[v][1]);$
2. $f[i][1]=\sum_v f[v][0];$

注意 $f[i][0]$ 初始化为 $0$，$f[i][1]$ 初始化为 $1$。
## 主问题-仙人掌上
一个图是否是仙人掌得满足题目里的条件：**保证每条边属于且仅属于一个简单环**。

于是仙人掌就有一个很好的性质，我们可以通过缩点，将环变成点后就可以形成一个树了，我们把这个树称作圆方树，但不需要细讲，因为这道题目不需要。

建圆方树只需要 tarjan 缩点，并且恰好我们在 dp 转移的时候，也只是遍历 dfs 序，于是我们可以在一边 tarjan 一边转移。

钦定当前节点为 $u$，与 $v$ 直接相连。于是我们又要分成两种情况讨论：

1. $u$ 为一个环的顶端，因为有两条连向底部的路径，我们便需要重新统计一遍即可。
2. 如果不是第一种，我们只需要按照转移式转移就行了。

最后答案就是 $\max(f[1][0],f[1][1])$ 了。

搞清楚之后，代码就不难写了，也是为了~~折磨你们~~考验你们的马力，我就不放代码了。
__谢谢观看__

---

## 作者：ケロシ (赞：0)

不想写 tarjan，考虑广义串并联图（悲

第一想法是设 $f_{e,0/1,0/1}$ 表示一条边两个端点不同选择情况下的最大独立集大小。

但是删 $1$ 度点的时候贡献不是很好统计。

所以考虑把这种贡献挂到点上，那么现在的状态是 $a_{u,0/1}$ 表示点 $u$ 选或不选的最大独立集大小，以及 $f_{e,0/1,0/1}$ 表示在不记录两端点的贡献的情况下，一条边两个端点不同选择情况下的最大独立集大小。

这下就很好转移了，初始值为 $a_{u,0}=0,a_{u,1}=1$，对于一条边有 $f_{e,0,0}=f_{e,1,0}=f_{e,0,1}=0,f_{e,1,1}=-\infty$。

删一度点 $u$，假设与之连边的是 $v$，那么有 $a_{v,i}$ 加上 $\max \{ a_{u,j}+f_{e,j,i} \}$。

叠重边就是 $f_{e,i,j}=f_{e_1,i,j}+f_{e_2,i,j}$。

缩二度点 $u$ 就随便枚举一下这个点选择的状态：$f_{e,i,j}=\max \{ f_{e_1,k,i}+f_{e_2,k,j}+a_{u,k} \}$。

设最后剩的点为 $u$，那么答案即为 $\max(a_{u,0},a_{u,1})$。

```cpp
const int N = 5e4 + 5;
const int INF = 1e9 + 7;
int n, m, a[N][2];
struct Node { int a[2][2]; };
map<int, Node> mp[N];
Node rev(Node x) {
	Node y;
	REP(i, 2) REP(j, 2)
		y.a[i][j] = x.a[j][i];
	return y;
}
Node mul1(int u, Node A, Node B) {
	Node h;
	REP(i, 2) REP(j, 2) {
		int res = 0;
		REP(k, 2) chmax(res, A.a[k][i] + B.a[k][j] + a[u][k]);
		h.a[i][j] = res;
	}
	return h;
}
Node mul2(Node A, Node B) {
	Node h;
	REP(i, 2) REP(j, 2)
		h.a[i][j] = A.a[i][j] + B.a[i][j];
	return h;
}
void add_edge(int u, int v, Node x) {
	if(mp[u].count(v)) {
		mp[u][v] = mul2(mp[u][v], x);
		mp[v][u] = mul2(mp[v][u], rev(x));
	}
	else {
		mp[u][v] = x;
		mp[v][u] = rev(x);
	}
}
void solve() {
	cin >> n >> m;
	REP(_, m) {
		int u, v;
		cin >> u >> v;
		Node h;
		REP(i, 2) REP(j, 2) h.a[i][j] = 0;
		h.a[1][1] = - INF;
		add_edge(u, v, h);
	}
	FOR(i, 1, n) a[i][1] = 1;
	queue<int> q;
	FOR(i, 1, n) if(SZ(mp[i]) <= 2) q.push(i);
	int rt = 1;
	while(! q.empty()) {
		int u = q.front(); q.pop();
		if(SZ(mp[u]) == 1) {
			int v; Node h;
			tie(v, h) = * mp[u].begin();
			REP(i, 2) {
				int res = 0;
				REP(j, 2) chmax(res, h.a[j][i] + a[u][j]);
				a[v][i] += res;
			}
			rt = v;
		}
		if(SZ(mp[u]) == 2) {
			int l, r; Node L, R;
			tie(l, L) = * mp[u].begin();
			tie(r, R) = * prev(mp[u].end());
			add_edge(l, r, mul1(u, L, R));
		}
		for(auto h : mp[u]) {
			int v = FI(h);
			mp[v].erase(u);
			if(SZ(mp[v]) <= 2) q.push(v);
		}
		mp[u].clear();
	}
	cout << max(a[rt][0], a[rt][1]) << endl;
}
```

---

## 作者：Chenyichen0420 (赞：0)

## 思路分析

仙人掌 DP 的一个比较板子的题目。第一次做，写一篇题解。

面对仙人掌的题，我们最基本的思路就是转化成树上问题求解。而很显然仙人掌本质上就是一棵树上面挂了一些边不相交的基环。

先看第一道题：[没有上司的舞会](https://www.luogu.com.cn/problem/P1352)。没错，这就是同一道题，只不过仙人掌上没有环而已。

为什么思考这个问题呢？因为这就是在推最基础的 DP 式子。显然：

$dp_{i,0}=\sum_{s\texttt{ is son of }i}\max(dp_{s,0},dp_{s,1}),dp_{i,1}=1+\sum_{s\texttt{ is son of }i}dp_{s,0}$。

再看第二道题：[城市环路](https://www.luogu.com.cn/problem/P1453)，不过请自己弱化一下，每一个点的人流量都是 $1$。没错，这就是同一道题，只不过仙人掌上有且仅有一个环而已。

那我们想一下面对基环树时的套路呢？先随便选择两个相邻的点，指定他们的状态，然后进行 DP。

现在看回这一道题。现在“树”上有一堆子基环了，我们怎么办？

仙人掌的典型套路：把每一个环拆出来，逐个击破。剩下的非环边正常处理就完了。

所以面对基环树 DP，思考大抵是有点套路的：思考树上怎么做，思考怎么处理基环，套仙人掌找环处理环的板子。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node {
	int p, id;
	node(int pi = 0, int vi = 0) :p(pi), id(vi) {};
};
int n, m, dp[50005][2], cnt, dfn[50005], low[50005]; vector<node>son[50005];
int f[50005], v[50005], fe[50005];
inline void tmin(int& l, int r) { (l > r) && (l = r); }
inline void mkdp(int fp, int p) {
	int v0 = 0, v1 = 0, t0, t1;
	for (int i = p;i != fp;i = f[i])
		t0 = v0 + dp[i][0], t1 = v1 + dp[i][1],
		v0 = max(t0, t1), v1 = t0;
	//选自己就选不了前一个，不选自己就任意选
	dp[fp][0] += v0; v0 = 0; v1 = -1e9;
	//只要选上一个贡献够小，就一定没人会选上一个
	for (int i = p;i != fp;i = f[i])
		t0 = v0 + dp[i][0], t1 = v1 + dp[i][1],
		v0 = max(t0, t1), v1 = t0;
	dp[fp][1] += v1;
}
inline void tarjan(int p, int id) {
	dfn[p] = low[p] = ++cnt; dp[p][1] = 1;
	for (const node& sp : son[p])
		if (!dfn[sp.p]) {
			f[sp.p] = p; fe[sp.p] = sp.id;
			tarjan(sp.p, sp.id), tmin(low[p], low[sp.p]);
			if (low[sp.p] > dfn[p])
				dp[p][0] += max(dp[sp.p][0], dp[sp.p][1]),
				dp[p][1] += dp[sp.p][0]; //非环边正常处理
		}
		else if (id != sp.id) tmin(low[p], dfn[sp.p]); //严禁当场返祖
	for (const node& sp : son[p])
		if (dfn[p] < dfn[sp.p] && fe[sp.p] != sp.id)
			mkdp(p, sp.p); //找到一个底下的环
}
signed main() {
	ios::sync_with_stdio(0);
	cin >> n >> m;
	for (int i = 1, l, r;i <= m;++i)
		cin >> l >> r,
		son[l].emplace_back(r, i),
		son[r].emplace_back(l, i);
	tarjan(1, 0); cout << max(dp[1][0], dp[1][1]) << endl;
}
```

---

## 作者：huhangqi (赞：0)

首先需要知道独立集是什么。

简单来讲独立集就是一个没有相邻的点的集合。

我们已经处理过比较多的独立集问题了。

比如常见的线性独立集。

代码：

```cpp
for(int i=1;i<=n;i++){
	dp[i][0]=max(dp[i-1][1],dp[i-1][0]);
	dp[i][1]=dp[i-1][0]+a[i];
}
``````

如果是一个环呢？

此时如果我们第一位选择了，那么最后一位就不能选择。

于是我们可以分第一位可以选和第一位不可以选两种情况。

代码：
```cpp
dp[1][0]=0,dp[1][1]=a[1];
for(int i=2;i<n;i++){
	dp[i][0]=max(dp[i-1][1],dp[i-1][0]);
	dp[i][1]=dp[i-1][0]+a[i];
}
dp[n][0]=max(dp[n-1][1],dp[n-1][0]);
dp[1][0]=0,dp[1][1]=0;
for(int i=2;i<n;i++){
	dp[i][0]=max(dp[i-1][1],dp[i-1][0]);
	dp[i][1]=dp[i-1][0]+a[i];
}
dp[n][1]=dp[n-1][0]+a[n];
``````

那么树上怎么处理？

代码：

```cpp
void dfs(int p,int f){
	dp[p][1]=a[p];
	for(int i:e[p]){
		if(i==f)continue;
		dfs(i,p);
		dp[p][0]+=max(dp[i][0],dp[i][1]);
		dp[p][1]+=dp[i][0];
	}
}

``````

而这道题目是一个仙人掌，仙人掌的一个性质就是只有环和链，不存在两个环有公有部分的情况。

那么我们直接在图中找到环，得到这部分的最大独立集，然后继续向上处理答案即可。

那么我们此时只需要找到环就可以了。

无向图中环是一个点双连通分量，我们直接按照点双连通分量的规则去判定是否有环即可。

我们将环得到了单点的值以后再向上进行转移即可。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,dfn[50005],low[50005],cnt,id,st[50005],top,f[50005][2],tmp[50005],k;
vector<int> e[50005];
void tarjan(int p){
	f[p][1]=1;
	dfn[p]=low[p]=++cnt;
	st[++top]=p;
	for(int i:e[p]){
		if(!dfn[i]){
			tarjan(i);
			low[p]=min(low[p],low[i]);
			if(low[i]>=dfn[p]){
				k=0;
				do{
					tmp[++k]=st[top];
					top--;
				}while(st[top+1]!=i);
				int f1=f[tmp[1]][1],f0=f[tmp[1]][0],g1,g0;
				for(int i=2;i<=k;i++){
					g1=f1,g0=f0;
					f1=g0+f[tmp[i]][1],f0=max(g0,g1)+f[tmp[i]][0];
				}
				f[p][0]=max(f0,f1)+f[p][0];
				f1=0,f0=f[tmp[1]][0],g1,g0;
				for(int i=2;i<=k;i++){
					g1=f1,g0=f0;
					f1=g0+f[tmp[i]][1],f0=max(g0,g1)+f[tmp[i]][0];
				}
				f[p][1]=f0+f[p][1];
			}
		}
		else low[p]=min(low[p],dfn[i]);
	}
}
signed main(){
	cin>>n>>m;
	for(int i=1,x,y;i<=m;i++){
		cin>>x>>y;
		e[x].push_back(y);
		e[y].push_back(x);
	}
	tarjan(1);
	cout<<max(f[1][0],f[1][1]);
	return 0;   
}
``````

---

## 作者：qwer6 (赞：0)

这张无向图显然是一棵仙人掌，所以我们直接考虑建出圆方树后再在圆方树上求解。

但是我们发现在圆方树上直接进行 DP 似乎并不可行，所以我们首先记录一个 $val_{0/1,u}$ 表示圆方树上的节点 $u$ 必不选或者必选的权值，然后考虑如何在 dfs 的过程中维护 $val_{0/1,u}$。

不妨先特判一些特殊情况，对于圆方树上的叶子结点 $v$（注意这里一定是圆点），显然 $val_{0.v}=0,val_{1,v}=1$。

而我们知道圆方树上的一条边一定连接一个方点和圆点，接下来我们考虑如何从圆点转移到方点和如何从方点转移到圆点。

这里先讨论方点 $u$ 如何转移到这个方点的父亲 $fa$。

根据圆方树的定义，方点对应了一个点双，在这道题显然对应了一个简单环，由于要转移到 $fa$，所以我们可以钦定 $fa$ 是选还是不选，然后做一次环上的最大独立集的 DP 即可。注意这里拆环成链，并且不包含 $fa$ 这个点，当我们钦定 $fa$ 不选的时候，链的开头和链的结尾是可以一起选的，因为 $fa$ 隔开了链的开头和链的结尾，当我们钦定 $fa$ 必选的时候，链的开头和结尾是必须不选的。

那么这道题就写完了，注意做环上最大独立集的时候需要特判环长为 $2$ 的情况。

```c++
/*略去快读快写和缺省源*/
const int N=5e4+5,M=6e4+5,inf=0x3f3f3f3f;
int n,m,cnt_dcc,cnt_dfn,top,ans;
int dfn[N],low[N],st[N];
bool vis[N],flag[N];
struct Chain_forward_star{
	struct Edge{
		int v,nxt;
	}e[M<<1];
	int n,cnt_edge;
	int head[N];
	void AddEdge(int u,int v){
		e[++cnt_edge]={v,head[u]};
		head[u]=cnt_edge;
	}
}G;
struct Tree{
	int a[N],dp[2][N<<1],val[2][N<<1],pre[N]; 
	vector<int>e[N<<1];
	void AddEdge(int u,int v){
		e[u].push_back(v);
	}
	void solve(int idx,int Locked){
		int cnt=0,now=e[idx][0];
		while(now!=Locked){
			a[++cnt]=now;
			now=pre[now];
		}
		if(cnt==1){//环上只有两个点 
			val[1][Locked]+=val[0][a[1]];
			val[0][Locked]+=max(val[0][a[1]],val[1][a[1]]);
			return ;
		}
		if(cnt==2){
			val[1][Locked]+=val[0][a[1]]+val[0][a[2]];
			val[0][Locked]+=max({val[0][a[1]]+val[1][a[2]],val[1][a[1]]+val[0][a[2]],val[0][a[1]]+val[0][a[2]]});
			return ;
		}
		//如果要选割点，那么第一个点和最后一个点都不能选 
		dp[0][1]=val[0][a[1]];//不选第一个点的情况 
		dp[1][1]=-inf;//选第一个点的情况 
		for(int i=2;i<=cnt;i++){
			dp[0][i]=max(dp[0][i-1],dp[1][i-1])+val[0][a[i]];
			dp[1][i]=dp[0][i-1]+val[1][a[i]];
		} 
		val[1][Locked]+=dp[0][cnt];//最后一个点也不能选 
		//如果不选割点，那么就是一个正常的序列最大独立集问题 
		dp[0][1]=val[0][a[1]];
		dp[1][1]=val[1][a[1]]; 
		for(int i=2;i<=cnt;i++){
			dp[0][i]=max(dp[0][i-1],dp[1][i-1])+val[0][a[i]];
			dp[1][i]=dp[0][i-1]+val[1][a[i]];
		} 
		val[0][Locked]+=max(dp[0][cnt],dp[1][cnt]);
	}
	void dfs(int u,int fa){
		val[0][u]=0,val[1][u]=1;
		for(int v:e[u])
			dfs(v,u);
		if(u>n)solve(u,fa);
	}
}tree;
void Tarjan(int u){
	vis[u]=1;
	dfn[u]=low[u]=++cnt_dfn;
	st[++top]=u;
	for(int i=G.head[u],v;i;i=G.e[i].nxt){
		v=G.e[i].v;
		if(!vis[v]){
			tree.pre[v]=u;
			Tarjan(v);
			tomin(low[u],low[v]);
			if(low[v]>=dfn[u]){
				cnt_dcc++;
				do{
					tree.AddEdge(cnt_dcc+n,st[top]);					
				}while(st[top--]!=v);
				tree.AddEdge(u,cnt_dcc+n);
			}
		}else tomin(low[u],dfn[v]);
	}
}
signed main(){
	read(n),read(m);
	for(int i=1,u,v;i<=m;i++){
		read(u),read(v);
		G.AddEdge(u,v);
		G.AddEdge(v,u);
	}
	for(int i=1;i<=n;i++){
		if(vis[i])continue;
		top=0;
		Tarjan(i);
		tree.dfs(i,0);
		ans+=max(tree.val[0][i],tree.val[1][i]);
	}
	write(ans);
}
```

---


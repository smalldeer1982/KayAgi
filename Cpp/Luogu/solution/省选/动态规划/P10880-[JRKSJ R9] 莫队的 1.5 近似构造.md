# [JRKSJ R9] 莫队的 1.5 近似构造

## 题目背景

二维莫队构造可以看作 $i,j$ 之间有权值为 $|l_i-l_j|+|r_i-r_j|$ 的完全图上的 TSP 问题。显然，任何莫队的边权都满足三角不等式。

求出最小生成树，然后把所有度数为奇数的点拿出来，对这个导出子图跑最小权匹配得到 $E$，将 $E$ 加到最小生成树上，然后跑欧拉路径即可。

 注意到 $\text{MST}(S)\le \text{TSP}(S)$，$2E\le \text{TSP}(S)$（$E$ 的 $\text{TSP}$ 方案可以给出两组匹配，考虑其中的较小值）且欧拉路径的边权和不小于欧拉路径给出的方案的权值，就给出了 $\le 1.5\text{TSP}(S)$ 的结果。

## 题目描述

给你一个 $1\sim n$ 的排列 $a$ 和 $m$ 个该排列上的区间 $[l_i,r_i]$。

对于一个值域区间 $[L,R]$：
- 称「选取 $i$ 时该值域区间的价值」为 $a_{l_i},a_{l_i+1},\dots,a_{r_i}$ 中有多少个数属于值域区间 $[L,R]$；
- 定义值域区间 $[L,R]$ 的价值为 $\forall i\in[1,m]$，「选取 $i$ 时该值域区间的价值」的最大值。

即，值域区间 $[L,R]$ 的价值为 $\displaystyle\max_{i=1}^m \sum_{j=l_i}^{r_i} [L\le a_j\le R]$。

定义两个区间相交当且仅当至少有一个整数被这两个区间共同包含。请你选出若干个**互不相交**的值域区间，使得它们的价值的乘积最大。将该答案对 $998244353$ 取模后输出。

## 说明/提示

### 样例解释 1

选择值域区间 $[1,3]$。

### 样例解释 2

可以选择值域区间 $[1,3],[4,5],[8,10]$。

### 样例解释 3

样例 3 满足特殊性质。

### 数据规模与约定
**本题采用捆绑测试。**

| $\mathrm{Subtask}$ | $n,m\le$ | 特殊性质 | 分数 |
| :-----: | :-----: | :-----: | :-----: |
| $1$ | $20$ |  | $10$ |
| $2$ | $5\times 10^3$ |  | $15$ |
| $3$ | $3\times 10^5$ | $\checkmark$ | $10$ |
| $4$ | $5\times 10^4$ |  | $25$ |
| $5$ | $3\times 10^5$ |  | $40$ |

特殊性质：保证 $\forall i\in[1,n],a_i=i$。

对于所有数据，保证 $1\le n,m\le 3\times 10^5$，$1\le l_i\le r_i\le n$，$a$ 是一个 $1\sim n$ 的排列。

## 样例 #1

### 输入

```
3 3
1 2 3
1 2
1 3
2 3```

### 输出

```
3```

## 样例 #2

### 输入

```
10 10
7 9 4 5 8 3 2 1 6 10 
3 7
2 6
1 2
3 4
8 9
1 2
2 6
5 8
6 9
4 5```

### 输出

```
12```

## 样例 #3

### 输入

```
60 30
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 
34 57
2 17
3 16
18 50
18 54
8 45
8 56
14 39
22 33
12 33
27 49
33 33
9 11
12 52
11 17
23 31
14 39
19 57
25 32
15 22
2 48
14 21
51 59
28 48
26 31
31 60
41 58
36 46
49 53
44 48```

### 输出

```
328034228```

# 题解

## 作者：critnos (赞：11)

若一个区间的权值 $\ge 4$，取出任意一个对这个值域区间贡献达到 $\max$ 的区间，对着里面的值域分裂成两个区间，显然不比原先劣。所以存在答案使得该答案中每个区间的价值为 $2$ 或 $3$。

并且在给出的区间中，被包含的区间可以直接去掉。所以把剩余的区间按照左端点（或者右端点）排序，维护在某个区间中相邻或相隔一个数的数对。具体来说大概就是用个 set 维护当前区间里面的数，移动到下一个区间的时候就先把要删的删了，然后逐个加入新的数，插进 set 的时候找到增加的对子。

这样只会得到 $O(n)$ 个数对。然后取对数（精度有 $\log n$ 位就够了）dp 即可。

时间复杂度 $O(n\log n+m)$。

---

## 作者：Eraine (赞：7)

来源：JRKSJ Round 9 &「KDOI」Round 7

编号：P10880

tag：动态规划

> 显然，任何莫队的边权都满足三角不等式。

这句话是否提示了正解？

为这题写题解的原因主要是在这题中我见到了几个比较有趣的 trick，于是想和大家分享一下。本题质量真的很高，强烈推荐大家完成此题。

假设代价函数 $w(l,r)$ 表示值域区间 $[l,r]$ 的价值。显然有 $w(l,r)\le w(l,mid)+w(mid+1,r)$。即一段价值为 $k$ 的区间可以拆分成若干段由 $[l,r]$ 拆分而得的价值之和 $\ge k$ 的子段。由于 $w(i,i)\le1$，根据上述结论可以得出 $w(l,r)-w(l,r-1)\le 1,w(l,r)-w(l-1,r)\le 1$。可以由这个结论推出在一个价值为 $x$ 的子段中，总是可以找到价值 $\forall i\in[1,x]$ 的前/后缀子段。

> 结论：最优答案一定可以为一堆价值为 $2$ 和价值为 $3$ 的子段拼接起来而得的答案。

很容易证明。首先对于任意价值 $x\ge4$ 的子段，都可以找到一个价值为 $x_1=2$ 的前缀子段，对应的后缀子段价值 $x_2$ 必然 $\ge x-2$。由于 $x\ge4$，显然有 $x_1x_2\ge 2(x-2)\ge x$。所以将 $x\ge 4$ 拆分成价值更小的子段一定不劣。

设 $f_i$ 表示值域并集为 $[1,i]$ 区间的最大价值总和。那么转移就只需从 $i-1$ 转移 $1$；右端点为 $i$，价值为 $2$ 的极小区间左端点转移 $2$；右端点为 $i$，价值为 $3$ 的极小区间左端点转移 $3$。第一个直接做，现在问题变成了快速求出右端点为 $i$，价值为 $2$ 的极小区间左端点和右端点为 $i$，价值为 $3$ 的极小区间左端点。

考虑双指针维护值域对应的 $pos$ 集合，然后需要做的是快速判断这个集合是否存在二/三元组在一个集合里。这里仅解释三元组，二元组由于是弱化版本相信大家能在理解三元组做法后想出二元组做法。如果给定一个三元组 $(u,v,w)(u\lt v\lt w)$，很显然可以通过右端点最靠右的包含 $u$ 的区间右端点与 $w$ 的大小关系快速判断出一个三元组是否合法。如果要枚举一个集合所有三元组显然时间会炸。但是观察这个三元组的定义，发现其满足区间包含单调性。设三元组 $(u,v,w)(u\lt v\lt w)$ 的 **拓展区间** 为 $[u,w]$，那么若存在 **拓展区间** 为 $[l_1,r_1]$ 和 $[l_2,r_2]$ 三元组 $tripe_1,tripe_2$ 且满足 $l_1\le l_2\lt r_2\le l_2$，当三元组 $tripe_1$ 合法，那么三元组 $tripe_2$ 同样合法。即我们只需要找到极小 **拓展区间** 即可。极小 **拓展区间** 对应三元组一定在集合中是相邻的三个数。换句话而言，我们只需要求出集合中相邻三个数是合法三元组的个数即可。具体地，考虑 $\text{add}(x)$ 函数。设 $a_{1\dots 5}$ 是 $x$ 加入集合后集合中从小到大排序相邻的五个数且 $a_3=x$。那么只会对 $(a_1,a_2,a_4),(a_2,a_3,a_5),(a_1,a_2,a_3),(a_2,a_3,a_4),(a_3,a_4,a_5)$ 这五组数产生影响。具体符号及其系数大家可以自己推导。记得特判 $a$ 中某元素为空的情况。集合元素用 $\text{set}$ 维护。

还有一个问题是答案可能很大，$\text{\_\_int128}$ 也不一定能存下。由于这题转移只有乘法操作，那么可以将乘法值转成对应 $\log$ 值，从而将乘法转成加法，值域就变成 $n\log$ 量级了。

实现有些史，可以通过参考别人的题解借鉴。

$\Theta(n\log n)$。

[submission](https://www.luogu.com.cn/record/172870877)

若有疑问和错误请指出，虚心接受您的意见。

---

## 作者：晴空一鹤 (赞：5)

写篇题解纪念第一次场切 Div.2 T4。

每个值域显然越大越好，所以我们最后的所有值域一定可以完整覆盖 $[1,n]$。

所以我们要把值域从 $1$ 到 $n$ 拉成序列，第 $i$ 位记录值 $i$ 在原数组中的位置。问题变成每个位置可以给所有包含他的 $[l,r]$ 加 $1$，找若干个断点，求每一段内最大区间权值的乘积的最大值。

看起来非常不可做，这时我们就要去找性质了。

首先发现求的是最大值对一个数取模，这仿佛给我们 dp 添加了难度，因为这要求我们维护每一个质因子的次数。

但是我们惊奇的发现，只有 $2$ 和 $3$ 可能是答案的质因子。如果出现大于 $3$ 的质因子，考虑得到该质因子的区间，我们一定能把其切成若干个 $2$ 和 $3$，而且切了不会更劣。

进一步，任何大于 $2$ 和 $3$ 的都能这么切，因此每一段的最大区间权值要么是 $2$，要么是 $3$。

初步思路诞生：对每一个位置，维护向前最少多少个可以使最大区间权值达到 $2$ 和 $3$，dp 转移只有可能从这两个地方过来。

dp 是容易 $O(n)$ 做的，前面暴力模拟配合双指针可以做到 $n^2$，显然不够。

发现若存在某 $[l,r]$ 包含 $[l',r']$，$[l',r']$ 显然无用。删掉这些区间，剩下的按左端点排序，此时右端点也会严格递增。

根据经典结论，每个点影响的区间是连续的一段。我们现在需要的操作是区间加与全局 $\max$，写棵线段树即可。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ls (x<<1)
#define rs ((x<<1)+1)
#define mid ((l+r)/2)
#define midd ((tr[x].l+tr[x].r)/2)
int n,m,a[300005],p[300005],nr,cnt,l[300005],r[300005],dd[300005],pp[300005],tz1[300005],tz2[300005];
long long ans=1;
const long long mod=998244353;
double x=log2(3),dp[300005];
struct no{
  int l,r;
  friend bool operator<(no a,no b){return (a.l==b.l)?a.r>b.r:a.l<b.l;}
}t[300005];
struct nod{
   int l,r,ma,laz;
}tr[1200005];
void inline build(int x,int l,int r){
    tr[x].l=l,tr[x].r=r;tr[x].ma=tr[x].laz=0;
    if(l==r)return ;
    build(ls,l,mid);
    build(rs,mid+1,r);
}
void inline push_down(int x){
  if(tr[x].laz==0)return ;
  tr[ls].laz+=tr[x].laz;
  tr[rs].laz+=tr[x].laz;
  tr[ls].ma+=tr[x].laz;
  tr[rs].ma+=tr[x].laz;
  tr[x].laz=0;
}
void inline add(int x,int l,int r,int z){
     if(tr[x].l>=l&&tr[x].r<=r){
     tr[x].laz+=z;
     tr[x].ma+=z;
     return ;
     }
     push_down(x);
     if(l<=midd)add(ls,l,r,z);
     if(r>midd)add(rs,l,r,z);
     tr[x].ma=max(tr[ls].ma,tr[rs].ma);
}
int main(){
  cin>>n>>m;
  for(int i=1;i<=n;i++)cin>>a[i];
  for(int i=1;i<=m;i++)cin>>t[i].l>>t[i].r;
  sort(t+1,t+m+1);
  for(int i=1;i<=m;i++){if(t[i].r>nr){cnt++;l[cnt]=t[i].l,r[cnt]=t[i].r;nr=t[i].r;}}
  for(int i=1;i<=n;i++)p[a[i]]=i;
  for(int i=1;i<=n;i++)a[i]=p[i];
  build(1,1,n);
  
  
  for(int i=n,j=n;i>=1;i--){
  while(tr[1].ma<2&&j>=0)
  {
  int rr=upper_bound(l+1,l+cnt+1,a[j])-l-1;
  int ll=lower_bound(r+1,r+cnt+1,a[j])-r;
  j--;
  if(ll>rr||ll==cnt+1||rr==cnt+1)continue;
  add(1,ll,rr,1);
  }
  tz1[i]=j;//cong j zhuan yi
  int rr=upper_bound(l+1,l+cnt+1,a[i])-l-1;
  int ll=lower_bound(r+1,r+cnt+1,a[i])-r;
  if(ll>rr||ll==cnt+1||rr==cnt+1)continue;
  add(1,ll,rr,-1);
  }
  build(1,1,n);
  
  
  for(int i=n,j=n;i>=1;i--){
  while(tr[1].ma<3&&j>=0)
  {
  int rr=upper_bound(l+1,l+cnt+1,a[j])-l-1;
  int ll=lower_bound(r+1,r+cnt+1,a[j])-r;
  j--;
  if(ll>rr||ll==cnt+1||rr==cnt+1)continue;
  add(1,ll,rr,1);
  }
  tz2[i]=j;//cong j zhuanyi
  int rr=upper_bound(l+1,l+cnt+1,a[i])-l-1;
  int ll=lower_bound(r+1,r+cnt+1,a[i])-r;
  if(ll>rr||ll==cnt+1||rr==cnt+1)continue;
  add(1,ll,rr,-1);
  }
  
  for(int i=1;i<=n;i++){
  if(tz1[i]==-1&&tz2[i]==-1)continue;
  if(tz1[i]==-1||(tz2[i]!=-1&&dp[tz2[i]]+x>dp[tz1[i]]+1)){dp[i]=dp[tz2[i]]+x;dd[i]=dd[tz2[i]],pp[i]=pp[tz2[i]]+1;}
  else{dp[i]=dp[tz1[i]]+1;dd[i]=dd[tz1[i]]+1,pp[i]=pp[tz1[i]];}
  }
  for(int i=1;i<=dd[n];i++)ans=(ans*(long long)2)%mod;
  for(int i=1;i<=pp[n];i++)ans=(ans*(long long)3)%mod;
  cout<<ans<<"\n";
}
```

~~我不会告诉你我把 lower_bound 记成了小于等于的最后一个数然后调了不知道多久。~~

---

## 作者：JWRuixi (赞：2)

## P10880 [JRKSJ R9] 莫队的 1.5 近似构造

### 题意

给定 $1, \dots n$ 的排列 $p$ 和 $m$ 个区间 $[l_i, r_i]$。定义区间 $[L, R]$ 的权值为 $\max\limits_{i = 1}^m \sum\limits_{k = l_i}^{r_i}[L \le a_k \le R]$，求将 $[1, n]$ 划分为若干不交的区间以最大化权值之积。

$n \le 3 \times 10^5$ 。

### 分析

手玩一些小数据，发现 $4 = 2 \times 2, 5 < 2 \times 3,6 < 3 \times 3, \dots$，所以一定不会出现超过 $3$！考虑设 $dp_i$ 表示 $i$ 这个前缀的答案，显然这是不降的，所以只有两个有用的转移点（以及继承 $i - 1$）：分别表示上一段的权值是 $2$ 还是 $3$。

我们发现随着某一个端点的单向移动，一个区间的权值是单调变化的，于是自然的考虑用双指针维护，我们只用考虑插入和删除。先对问题弱化，如果只有插入：由于我们的权值不大于 $3$，所以可以枚举对应到排列上的连续的三个点，查询其是否被某个给定区间包含，这是简单的。又插入的时候，所以我们只考虑插入的这个点造成的影响，要求枚举的区间包含插入的点，复杂度降为 $\mathcal O(S(n))$。其中 $S(n)$ 表示维护点集所需的复杂度。

删除操作实际上是同质的，我们将维护最大值，改为维护所有长度为 $3$ 的合法三元组，以及所有长度为 $2$ 的合法二元组，我们只需要删除所有包含现在删除的这个点的二/三元组即可，判断当前最大值是简单的。

比较对话可以取对数，精度是够的。

总复杂度 $\mathcal O(n\log n)$，用 `set` 实现，常数上可能不甚优秀，但是个人感觉思路挺有趣？

### Code

<https://pastebin.com/PEr1Y4NP>。

---

## 作者：XuYueming (赞：1)

## 前言

题目链接：[洛谷](https://www.luogu.com.cn/problem/P10880)。

感觉 T4 比 T3 水，~~虽然我都没做出来~~。

[更 good 的 reading experience](https://www.cnblogs.com/XuYueming/p/18370812)。

## 题意简述

给定 $1 \sim n$ 的排列 $a$ 和 $m$ 个区间 $[l_i, r_i]$。定义值域区间 $[L, R]$ 的价值为 $\operatorname{val}([L, R]) \operatorname{:=} \max \limits_{i = 1}^m \sum\limits_{k = l_i}^{r_i}[L \le a_k \le R]$。求将 $[1, n]$ 划分为若干不交的区间的价值之积的最大值，对 $998244353$ 取模。

## 题目分析


划分值域，其实一个序列上的问题，不妨考虑 DP。设 $f_i$ 表示 $[1, i]$ 的值域区间已经被划分成若干值域区间的价值的最大积。特别地，不妨令 $f_0 = 1$。

接下来考虑转移。考虑求 $f_i$，可以不进行任何操作，直接继承 $i - 1$。也可以进行一次划分，那么令新划分的值域区间为 $[j, i]$，则有转移：

$$
f_i = \max _ {j=1} ^ {i} \Big \lbrace f_{j - 1} \cdot \operatorname{val}([j, i]) \Big \rbrace
$$

具体地，我们让 $j$ 从 $i$ 开始向左扫，同时维护 $m$ 个区间的桶，对于当前 $[j, i]$ 扩展出的新的一个值 $j$，我们找到 $a_p = j$ 的位置 $p$，让 $l_i \leq p \leq r_i$ 的区间的桶计数加一，转移就很简单了。

另外，由于同时要最大值和取模后的值，套路化地，记真实值为 $x$，我们只用维护 $(\log x, x \bmod M)$ 的二元组，由对数性质，比较最值是取前者，答案则是后者。易知 `double` 精度足够。

这样做的时间复杂度是 $\Theta(n^2m)$，怎么优化呢？不妨输出一下最优决策时的相关信息，发现 $\operatorname{val}([j, i]) \in \lbrace 2, 3 \rbrace$，这是为什么呢？理解起来很简单，因为我们在价值 $>3$ 的时候，总是能够把 $[j, i]$ 划分成两个区间，使得它们价值之积在之前价值取到 $\max$ 的区间中，取到一个不劣于之前的价值的价值。读者自证不难。

于是，DP 只能决策一个价值为 $2$ 或 $3$ 的区间。现在的问题就是对于每一个 $i$，找到最后一个 $j$，使 $\operatorname{val}([j, i]) = 2$，再用相同算法求得 $\operatorname{val}([j, i]) = 3$ 的 $j$，最后就能 $\Theta(n)$ DP 了。

发现，区间越大，其价值越大，要维护区间价值为 $2 / 3$，类似于滑动窗口，可以用双指针预处理。时间复杂度降为了 $\Theta(nm)$，瓶颈在于预处理。还有没有更好的处理方式呢？我们发现，双指针已经无法优化了，现在迫切需要一个能维护这 $m$ 个桶的数据结构，支持查询全局最值、给能够包含某一个点的区间对应的桶做加法。

这并不套路。全局最值通常很好维护，难点在做一些毫无规律的单点加。注意到区间对我们来说是没有先后顺序之分的，不妨排个序。至于关键字，为了服务我们的目的，不妨按照左端点先排一次序。现在，我们已经能够通过二分快速缩小我们想要做单点加的范围了。我们只需要在这些左端点 $l_i \leq p$ 的区间中，找到右端点 $r_i \geq p$ 的区间，对这些区间做单点加。

可是，右端点不是单调的，我们还是无法便捷地操作。有没有什么方法使得在左端点单增的同时，右端点也单增呢？即，不存在一个区间包含另一个区间的情况。这似乎意味着我们必须要删除一些区间。发现，对于 $a$ 包含 $b$ 的情况，我们完全可以删除被包含的 $b$ 而不影响答案，应为如果某一个值域区间 $[L, R]$ 的 $\operatorname{val}$ 在 $b$ 取到了 $\max$，在 $a$ 一定不劣。预处理删除是 naive 的。于是，我们就能做到左右端点分别单增。

这就意味着，我们能够迅速地定位一段区间，并对这段区间的每一个桶做单点加。等等！这不就退化到区间加了吗，结合所求的最值，直接上一棵线段树就行了。

当然，有些常数优化，例如排序值域很小，直接用桶；对于每个点，我们可以双指针处理出要区间加的范围。于是乎，卡脖子的瓶颈就在于线段树了。具体请看代码。

至此，我们通过了这道题，时间复杂度：$\Theta(n \log m + m)$。

不知道有没有神奇的数据结构能更快地维护区间加减 $1$，查询全局最大值。

## 代码

[$\Theta(n^2m)$](https://www.luogu.com.cn/paste/fcabm0ll)。

[$\Theta(nm)$](https://www.luogu.com.cn/paste/ed920td7)。

以及正解，妥妥地跑到了（~~除了出题人之前交的~~） [Rank 1](https://www.luogu.com.cn/record/174042139)。

```cpp
#include <cstdio>
using namespace std;

const int MAX = 1 << 26;
char buf[MAX], *p = buf;
#define getchar() *p++
#define isdigit(ch) (ch >= '0' && ch <= '9')
inline void read(int &x) {
    x = 0; char ch = getchar();
    for (; !isdigit(ch); ch = getchar());
    for (;  isdigit(ch); x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar());
}

constexpr const double lg2 = 0.693147180559945286226763982995180413126945495605468750000000000736520;
constexpr const double lg3 = 1.098612288668109782108217586937826126813888549804687500000000000736520;
constexpr inline int max(int a, int b) { return a > b ? a : b; }

const int N = 300010;
const int mod = 998244353;

int n, m, mxR[N];
int val[N], whr[N];

struct Segment {
    int L, R;
} line[N];

int two[N], san[N];

struct node {
    double sum;
    int val;
    constexpr node(double s = 0, int v = 0) : sum(s), val(v) {}
    inline friend bool operator < (const node & a, const node & b) {
        return a.sum < b.sum;
    }
    inline friend node operator + (const node & a, const node & b) {
        return node(a.sum + b.sum, 1ll * a.val * b.val % mod);
    }
    inline friend node max(const node & a, const node & b) {
        return a < b ? b : a;
    }
} dp[N];

constexpr node TWO(lg2, 2), SAN(lg3, 3);

struct Segment_Tree {
    #define lson (idx << 1    )
    #define rson (idx << 1 | 1)
    
    struct node {
        int l, r, lazy, mx;
    } tree[N << 2];
    
    void build(int idx, int l, int r) {
        tree[idx] = {l, r, 0, 0};
        if (l == r) return;
        int mid = (l + r) >> 1;
        build(lson, l, mid), build(rson, mid + 1, r);
    }
    
    inline void pushtag(int idx, int v) {
        tree[idx].mx += v;
        tree[idx].lazy += v;
    }
    
    inline void pushdown(int idx) {
        if (!tree[idx].lazy) return;
        pushtag(lson, tree[idx].lazy);
        pushtag(rson, tree[idx].lazy);
        tree[idx].lazy = 0;
    }
    
    void modify(int idx, int l, int r, int v) {
        if (l <= tree[idx].l && tree[idx].r <= r) return pushtag(idx, v);
        pushdown(idx);
        if (l <= tree[lson].r) modify(lson, l, r, v);
        if (r >= tree[rson].l) modify(rson, l, r, v);
        tree[idx].mx = max(tree[lson].mx, tree[rson].mx);
    }
    
    #undef lson
    #undef rson
} yzh;  // yzh i love you!

inline int getmx() {
    return yzh.tree[1].mx;
}

int LEFT[N], RIGHT[N];
// 第一个右端点不小于 whr[i] 的位置
// 最后一个左端点不大于 whr[i] 的位置

inline void add(int i, int v) {
    i = whr[i];
    if (LEFT[i] <= RIGHT[i]) yzh.modify(1, LEFT[i], RIGHT[i], v);
}

signed main() {
    fread(buf, 1, MAX, stdin);
    read(n), read(m);
    for (int i = 1; i <= n; ++i) read(val[i]), whr[val[i]] = i;
    for (int i = 1, L, R; i <= m; ++i) read(L), read(R), mxR[L] = max(mxR[L], R);
    m = 0;
    for (int i = 1, curR = 0; i <= n; ++i)
        if (mxR[i] > curR) {
            line[++m] = {i, mxR[i]};
            curR = mxR[i];
        }
    
    for (int i = 1; i <= n; ++i) {
        LEFT[i] = LEFT[i - 1];
        while (line[LEFT[i]].R < i) ++LEFT[i];
    }
    RIGHT[n + 1] = m;
    for (int i = n; i >= 1; --i) {
        RIGHT[i] = RIGHT[i + 1];
        while (line[RIGHT[i]].L > i) --RIGHT[i];
    }
    
    yzh.build(1, 1, m);
    for (int i = 1; i <= n; ++i) {
        add(i, 1);
        if (getmx() < 2) continue;
        two[i] = two[i - 1];
        if (!two[i]) two[i] = 1;
        while (true) {
            add(two[i]++, -1);
            if (getmx() < 2) {
                add(--two[i], 1);
                break;
            }
        }
    }
    
    yzh.build(1, 1, m);
    for (int i = 1; i <= n; ++i) {
        add(i, 1);
        if (getmx() < 3) continue;
        san[i] = san[i - 1];
        if (!san[i]) san[i] = 1;
        while (true) {
            add(san[i]++, -1);
            if (getmx() < 3) {
                add(--san[i], 1);
                break;
            }
        }
    }
    
    dp[0].val = 1;
    for (int i = 1; i <= n; ++i) {
        dp[i] = dp[i - 1];
        if (two[i]) dp[i] = max(dp[i], dp[two[i] - 1] + TWO);
        if (san[i]) dp[i] = max(dp[i], dp[san[i] - 1] + SAN);
    }
    printf("%d", dp[n].val);
    return 0;
}
```

## 后记

遇到最值取模，不一定是存在一种构造的方法，能够保证算出最值，然后在算法过程中取模，也可能是取对数后 DP 等决策类算法。

若干区间，每次给出一个点，对包含这个点的所有区间操作，可以尝试去掉包含的区间，这样就能二分出连续的一段，就能区间操作了。

---

## 作者：STARSczy (赞：0)

首先，若一个区间的贡献大于等于 $4$，则一定可以被拆成两个贡献大于等于 $2$ 的区间，且一定不劣。所以我们可以处理出两个数组，代表对于每个 $R$，贡献分别为二或三的最大的 $L$，然后 dp 即可。

在预处理的过程中，我们可以使用双指针去处理 $l_i$ 和 $r_i$，里面套一个 set，用来存储当前区间的值。若当前右端点小于 $l_i$，则直接清空，否则把小于 $l_i$ 的元素直接删除，把小于 $r_i$ 但不在 set 内的元素加入。对于每个元素，我们判断是否有小于它的数，和是否有小于小于它的数。当加入一个元素时，其所影响的数是 $\Theta(1)$ 级别的，可直接处理。预处理时间复杂度 $\Theta(n \log n)$

在 dp 的过程中，我们会发现模意义下无法比较大小，但是不模数字会很大。发现质因数只会有 $2$ 和 $3$，可存储这两个数的指数即可。

时间复杂度 $\Theta(n \log n)$。


```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
#include<ext/rope>
#define rep(i,l,r) for(int i=(l),i##end=(r);i<=i##end;++i)
#define per(i,r,l) for(int i=(r),i##end=(l);i>=i##end;--i)
// #define int long long
#define double long double
#define pii pair<int,int>
#define fi first
#define se second
#define pb push_back
#define rbtree(way) tree<way,null_type,less<way>,rb_tree_tag,tree_order_statistics_node_update>
using namespace std;
using namespace __gnu_cxx;
using namespace __gnu_pbds;
const int maxn=1e6+10,maxm=1e6+10,mod=998244353,inf=1e9;
inline int ksm(int x,int k,int mod=mod){
	int ans=1;
	for(;k;k>>=1,x=1ll*x*x%mod) if(k&1) ans=1ll*ans*x%mod;
	return ans;
}

int n,m,lq=1,rq,a[maxn],p2[maxn],p3[maxn];
pii rp[maxn],f[maxn];
set<int> t;
pii pmax(pii a,pii b){return a.fi+1.58496250072*a.se<b.fi+1.58496250072*b.se?b:a;}
pii add2(pii &a){return {a.fi+1,a.se};}
pii add3(pii &a){return {a.fi,a.se+1};}

signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	rep(i,1,n) cin>>a[i],p2[i]=p3[i]=-1;
	rep(i,1,m) cin>>rp[i].fi>>rp[i].se;
	sort(rp+1,rp+n+1,[&](pii a,pii b){return a<b;});
	rep(i,1,n) if(rp[i].se>rq){
		if(rq<rp[i].fi) t.clear(),lq=rp[i].fi,rq=lq-1;
		else for(;lq<rp[i].fi;t.erase(a[lq]),++lq);
		for(;rq<rp[i].se;){
			++rq,t.insert(a[rq]);
			auto it=t.find(a[rq]);
			if(it!=t.begin()){
				p2[a[rq]]=max(*prev(it)-1,p2[a[rq]]);
				if(prev(it)!=t.begin()) p3[a[rq]]=max(*prev(prev(it))-1,p3[a[rq]]);
			}
			if(next(it)!=t.end()){
				p2[*next(it)]=max(a[rq]-1,p2[*next(it)]);
				if(it!=t.begin()) p3[*next(it)]=max(*prev(it)-1,p3[*next(it)]);
				if(next(next(it))!=t.end()) p3[*next(next(it))]=max(a[rq]-1,p3[*next(next(it))]);
			}
		}
	}
	rep(i,1,n) f[i]=pmax(f[i-1],pmax(~p2[i]?add2(f[p2[i]]):f[0],~p3[i]?add3(f[p3[i]]):f[0]));
	cout<<1ll*ksm(2,f[n].fi)*ksm(3,f[n].se)%mod;
	return 0;
}
```

---

## 作者：SegTree (赞：0)

赛时写了个向前枚举 $150$ 个点做 dp 得到 50pts（，可以感觉出来区间的价值不会很大。下面证明存在最优解区间价值不超过 $3$。

如果把区间（价值为 $s$）拆成两部分（价值分别为 $a$ 和 $b$，不妨设 $a\le b$），则有 $a+b\ge s$。当 $ab\ge s$，说明能划开就划开。当且仅当 $a\le 1$。

所以对于 $s\ge 4$，一定会把它划成两部分。只需要考虑 $s=2$ 或 $s=3$ 产生的转移。对于一个左端点，有意义的向后的转移只有 $2$ 个。只需要找到最小的右端点使得 $s=2,3$。

因为如果两个区间满足第二个区间将第一个区间包含，可以删除第一个区间。所以有 $l$ 递增 $r$ 也递增，每次新插入一个数产生的增量是一个区间，用线段树平凡维护区间加全局 $\max$ 即可。

视 $n,m$ 同阶，时间复杂度 $\mathcal{O}(n\log n)$。

---

## 作者：nullqtr_pwp (赞：0)

这种搞笑东西也能被扔到公开赛里的？？？？

将值域区间 $[L,R]$ 的价值记作 $w(L,R)$。

首先 $[l_i,r_i]$ 是乱序给出的，我们可以强制钦定 $l_i$ 从小到大，容易发现对于某个区间 $[l_j,r_j]$，如果存在另一个 $j\ne k$ 使得 $[l_j,r_j]\subseteq[l_k,r_k]$，那么可以不考虑 $j$ 对所有 $w(L,R)$ 的贡献，因为 $w(L,R)$ 是对所有的 $1\sim m$ 取最大值。所以我们可以**忽略所有被其他区间包含的区间**。

考虑找一下 $w(L,R)$ 的性质。那么发现如果 $w(L,R)\ge 4$，因为 $a_i$ 是互不相同的，那么每个单点最多贡献 $1$，我们可以令 $w(L,R)=t$，在 $t\ge 4$ 时找到一个分界线 $k\in[L,R)$，使得 $|w(L,k)-w(k+1,R)|\leq 1$，此时一定有 $w(L,k)w(k+1,R)\ge w(L,R)=t\ge 4$。（$w\in\Z$，且 $w(L,k)$ 连续）

注意到 $w(L,R)=1$ 对答案没有贡献，所以可以找出来 $w(L,R)\in\lbrace2,3\rbrace$ 的所有区间。我们可以要求这些值域区间 $[L,R]$ 都只在某个区间 $[l_i,r_i]$ 中的点上取，这样做一定不会漏过最优解，并且不会比最优答案得出更优的错解。具体的维护方法就是将所有区间排序，$l$ 有序时，由于没有包含所以 $r$ 一定有序。扫描线序列维，```std::set``` 维护所有的数，新加入点时加入所有 $w(L,R)=2,3$ 且与这个点有关的区间。由于每个点贡献 $O(1)$ 个区间所以总区间个数是 $O(n)$ 的。

然后再扫描线值域维进行 dp，经典套路，由于乘积很大所以可以转化为取 $\log$ 求和。令 $w=2$ 的权值为 $1$，$w=3$ 的权值为 $\log_23$，最大化不交区间的权值和即可，真实乘积作为 dp 转移过程中的属性维护即可。

时间复杂度 $O(n\log n)$。


```cpp
int n,____,m,a[maxn];
const double A=1;
const double B=1.5849625007211563;
double f[maxn];
int g[maxn];
vector<int>g2[maxn],g3[maxn];
void solve(){
	n=read(),____=read();
	F(i,1,n)a[i]=read();
	vector<pii>Readin,vec;
	F(_,1,____){
		int l=read(),r=read();
		Readin.push_back(mkp(l,r));
	}
	sort(Readin.begin(),Readin.end(),[&](pii x,pii y){
		return x.fi==y.fi?x.se>y.se:x.fi<y.fi;
	});
	int mxr=0;
	for(auto [l,r]:Readin)if(r>mxr)mxr=r,vec.push_back(mkp(l,r));
	set<int>st;
	vector<pii>V2,V3;
	int lstl=n+2,lstr=0;
	for(auto [l,r]:vec){
		F(i,lstl,min(l-1,lstr))st.erase(a[i]);
		F(i,max(l,lstr+1),r){
			st.insert(a[i]);
			auto it=st.find(a[i]);
			int x=0,y=0;
			if(it!=st.begin())x=*prev(it);
			if(next(it)!=st.end())y=*next(it);
			if(x)V2.push_back(mkp(x,a[i]));
			if(y)V2.push_back(mkp(a[i],y));
			if(x&&y)V3.push_back(mkp(x,y));
			if(x){
				auto it1=prev(it);
				if(it1!=st.begin())V3.push_back(mkp(*prev(it1),a[i]));
			}
			if(y){
				auto it2=next(it);
				if(next(it2)!=st.end())V3.push_back(mkp(a[i],*next(it2)));
			}
		}
		lstl=l,lstr=r;
	}
	for(auto [l,r]:V2)g2[r].push_back(l);
	for(auto [l,r]:V3)g3[r].push_back(l);
	f[0]=0,g[0]=1;
	F(i,1,n){
		f[i]=f[i-1],g[i]=g[i-1];
		for(int j:g2[i]){
			const double val=f[j-1]+A;
			if(val>f[i])f[i]=val,g[i]=2ll*g[j-1]%mod;
		}
		for(int j:g3[i]){
			const double val=f[j-1]+B;
			if(val>f[i])f[i]=val,g[i]=3ll*g[j-1]%mod;
		}
	}
	printf("%d",g[n]);
}
```

---


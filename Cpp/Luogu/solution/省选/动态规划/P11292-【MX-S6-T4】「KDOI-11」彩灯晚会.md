# 【MX-S6-T4】「KDOI-11」彩灯晚会

## 题目背景

原题链接：<https://oier.team/problems/S6D>。

## 题目描述

小 K 家的房子还蛮大的，所以他举办了彩灯晚会。

彩灯晚会显然有彩灯。于是小 K 找来了 $n$ 盏彩灯。

小 K 不希望彩灯散在地上，于是他用 $m$ 条**有向边**连接了这些彩灯，使得他们连在一起。也就是说，在将有向边看成无向边的情况下，这些彩灯是连通的。保证该图为**有向无环图**。

小 K 的彩灯很厉害，每个都可以独立地发出 $k$ 种颜色中的任意一种。小 K 作为世界顶尖 Light Glowing Master（简称 LGM），决定将所有方案（共 $k^n$ 种）都尝试一下。

小 K 不喜欢很多的颜色，于是他给定了一个正整数 $l$，并定义一个方案的美丽度为每种颜色长度为 $l$ 的链数量的平方之和。形式化地讲，设第 $i$ 种颜色的长度为 $l$ 的链的数量为 $cnt_i$，则一个方案的美丽度为 $\sum_{i=1}^kcnt_i^2$。

现在小 K 想知道所有 $k^n$ 种方案的美丽度之和，对 $998244353$ 取模。

两种方案是不同的当且仅当存在某个彩灯在两种方案中发出不同的颜色。

一条长度为 $l$ 的链是一个 $2l-1$ 元组 $(v_1,e_1,v_2,e_2,\dots,e_{l-1},v_l)$，使得对于任意 $1\leq i<l$，第 $e_i$ 条有向边是由 $v_i$ 连向 $v_{i+1}$ 的。两条长度为 $l$ 的链 $(v_1,e_1,v_2,e_2,\dots,e_{l-1},v_l)$ 和 $(v'_1,e'_1,v'_2,e'_2,\dots,e'_{l-1},v'_l)$ 不同当且仅当存在 $1\leq i<l$ 满足 $e_i\neq e'_i$ 或存在 $1\leq i\leq l$ 满足 $v_i\neq v'_i$。

一种颜色 $x$ 的长度为 $l$ 的链是一条长度为 $l$ 的链 $(v_1,e_1,v_2,e_2,\dots,e_{l-1},v_l)$ 使得对于任意 $1\leq i\leq l$，$v_i$ 编号的彩灯发出颜色为 $x$。

## 说明/提示

**【样例解释 #1】**

共有 $2^3=8$ 种不同的彩灯显示颜色的方案，如下表所示（不妨假设颜色为黑和白）：

| 编号 | $1$ 号彩灯颜色 | $2$ 号彩灯颜色 | $3$ 号彩灯颜色 | 美丽度 |
|:--:|:--:|:--:|:--:|:--:|
| $1$ | 黑 | 黑 | 黑 | $4$ |
| $2$ | 黑 | 黑 | 白 | $0$ |
| $3$ | 黑 | 白 | 黑 | $1$ |
| $4$ | 黑 | 白 | 白 | $1$ |
| $5$ | 白 | 黑 | 黑 | $1$ |
| $6$ | 白 | 黑 | 白 | $1$ |
| $7$ | 白 | 白 | 黑 | $0$ |
| $8$ | 白 | 白 | 白 | $4$ |

美丽度之和为 $4+0+1+1+1+1+0+4=12$。

**【样例 #3】**

见附件中的 `party/party3.in` 与 `party/party3.ans`。

该组样例满足测试点 $1$ 的约束条件。

**【样例 #4】**

见附件中的 `party/party4.in` 与 `party/party4.ans`。

该组样例满足测试点 $2\sim3$ 的约束条件。

**【样例 #5】**

见附件中的 `party/party5.in` 与 `party/party5.ans`。

该组样例满足测试点 $4\sim5$ 的约束条件。

**【样例 #6】**

见附件中的 `party/party6.in` 与 `party/party6.ans`。

该组样例满足测试点 $6\sim9$ 的约束条件。

**【样例 #7】**

见附件中的 `party/party7.in` 与 `party/party7.ans`。

该组样例满足测试点 $10\sim12$ 的约束条件。

**【样例 #8】**

见附件中的 `party/party8.in` 与 `party/party8.ans`。

该组样例满足测试点 $13\sim15$ 的约束条件。

**【样例 #9】**

见附件中的 `party/party9.in` 与 `party/party9.ans`。

该组样例满足测试点 $20\sim21$ 的约束条件。

**【数据范围】**

记 $P=998244353$，对于所有测试数据，保证：$1\leq n\leq300$，$1\leq M\leq\frac{n(n-1)}{2}$，$1\leq k<P$，$1\leq l\leq 20$，$1\leq c_i<P$，$(u_i,v_i)$ 互不相同，给定图为有向无环图，在将有向边看成无向边的情况下，彩灯是连通的。

| 测试点编号 | $n\leq$ | $k\leq$ | $l\leq$ | 特殊性质 |
|:--:|:--:|:--:|:--:|:--:|
| $1$ | $6$ | $6$ | $6$ | $m\leq10$，$c_i=1$ |
| $2\sim3$ | $300$ | $P-1$ | $1$ | 无 |
| $4\sim5$ | $300$ | $P-1$ | $2$ | 无 |
| $6\sim9$ | $300$ | $P-1$ | $3$ | 无 |
| $10\sim12$ | $300$ | $P-1$ | $20$ | $M=n-1$ 且有且仅有一个点入度为 $0$ |
| $13\sim15$ | $30$ | $P-1$ | $10$ | 无 |
| $16$ | $150$ | $P-1$ | $7$ | 无 |
| $17$ | $150$ | $P-1$ | $10$ | 无 |
| $18\sim19$ | $150$ | $P-1$ | $13$ | 无 |
| $20\sim21$ | $300$ | $P-1$ | $9$ | 无 |
| $22$ | $300$ | $P-1$ | $13$ | 无 |
| $23$ | $300$ | $P-1$ | $16$ | 无 |
| $24\sim25$ | $300$ | $P-1$ | $20$ | 无 |

## 样例 #1

### 输入

```
0 3 2 2 2
1 3 1
3 2 1```

### 输出

```
12```

## 样例 #2

### 输入

```
0 5 4 3 7
1 4 4
1 5 2
4 3 1
5 3 2
3 2 3
4 5 1
5 2 2```

### 输出

```
16096```

# 题解

## 作者：Petit_Souris (赞：19)

验题人题解，大概做了 1.5h 不到过了。

首先这个 $\sum cnt_i^2$ 典的不能再典了，用组合意义转化为「选出两条长度为 $l$ 的同色链的方案数」。

把贡献拆开，枚举两条链，计算这两条链同色的方案数。假设他们重合了 $c$ 个点，那么方案数为 $k^{n-2l+c+1}$。现在问题转化为，给定 $c$，计算选出两条长度为 $l$ 的链，恰好重合 $c$ 个点的方案数。

考虑容斥（二项式反演）。计算 $g_c$ 表示钦定了 $c$ 个点重合的方案数，二项式反演得到 $f_c$ 表示恰好 $c$ 个点重合的方案数。

如何计算 $g$？由于图是 DAG，我们可以在拓扑序上做 DP。具体来说，设 $dp_{u,i,l_1,l_2}$ 表示目前钦定两条链重合于 $u$，已经钦定了 $i$ 个重合点，两条链的目前长度分别为 $l_1,l_2$。转移枚举下一个重合点 $v$ 和两条链在 $u\to v$ 这段的长度 $t_1,t_2$，转移到 $dp_{v,i+1,l_1+t_1,l_2+t_2}$。这个转移形式意味着我们得预处理出 $h_{u,v,i}$ 表示 $u\to v$ 的长度为 $i$ 的路径数量，还需要预处理出 $s_{u,i}$ 和 $t_{u,i}$ 表示从 $u$ 开始 / 结束于 $u$ 的，长度为 $i$ 的路径数量。

这个做法的时间复杂度为 $\mathcal O(n^2l^5+n^3l)$，得到 76~84 分。

考虑优化。首先这个转移同时枚举 $t_1,t_2$ 是不优的，因为转移系数没有同时和 $t_1,t_2$ 有关的项，所以可以做分步转移，先转移 $t_1$ 再转移 $t_2$。时间复杂度 $\mathcal O(n^2l^4+n^3l)$，得到 84~92 分。

还能再给力点吗？发现我们最后其实并不关心每个 $c$ 对应的方案数，我们只要算出对应的 $k^c$ 就行了。这启发我们把所有的系数直接在转移过程中均摊掉。然而由于有二项式反演的存在，每转移一步就乘上 $k$ 是错的。

正确的打开方式是考虑二项式反演中 $i\to c$ 的贡献，把 $k^c$ 乘进去之后是个二项式定理的形式，可以归纳得到正确的系数为 $(k-1)^c$。于是我们 DP 时不需要记录 $i$ 这一位，直接每走一步乘上一个 $(k-1)$ 就行了。时间复杂度 $\mathcal O(n^2l^3+n^3l)$，可以获得 100 分。

稍微卡卡常数就不大了。

```cpp
#include<bits/stdc++.h>
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
#define pii pair<ll,ll>
#define rep(i,a,b) for(ll i=(a);i<=(b);++i)
#define per(i,a,b) for(ll i=(a);i>=(b);--i)
using namespace std;
bool Mbe;
ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void write(ll x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
const ll N=309,Mod=998244353;
ll typ,n,k,L,M;
ll f[N][N][22],ed[N][22],st[N][22],g[N][22][22],h[N][22][22],C[22][22];
ll ord[N],deg[N];
vector<pii>to[N];
ll pw(ll x,ll p){
    ll res=1;
    while(p){
        if(p&1)res=res*x%Mod;
        x=x*x%Mod,p>>=1;
    }
    return res;
}
bool Med;
int main(){
    freopen("party.in","r",stdin);
    freopen("party.out","w",stdout);
    cerr<<fabs(&Med-&Mbe)/1048576.0<<"MB\n";
    typ=read(),n=read(),k=read(),L=read(),M=read();
    rep(i,1,M){
        ll x=read(),y=read(),z=read();
        to[x].push_back({y,z}),deg[y]++;
    }
    rep(i,0,L){
        C[i][0]=1;
        rep(j,1,i)C[i][j]=(C[i-1][j]+C[i-1][j-1])%Mod;
    }
    queue<ll>q;
    rep(i,1,n){
        if(!deg[i])q.push(i);
    }
    while(!q.empty()){
        ll u=q.front();q.pop();
        ord[++ord[0]]=u;
        for(pii e:to[u]){
            ll v=e.first;
            deg[v]--;
            if(!deg[v])q.push(v);
        }
    }
    ord[0]=0;
    rep(i,1,n){
        ll u=ord[i];
        f[u][u][1]=1;
        rep(j,i,n){
            ll v=ord[j];
            rep(k,1,L-1){
                if(!f[u][v][k])continue;
                for(pii e:to[v]){
                    ll w=e.first,ww=e.second;
                    f[u][w][k+1]=(f[u][w][k+1]+f[u][v][k]*ww)%Mod;
                }
            }
        }
    }
    rep(i,1,n){
        rep(j,1,n){
            rep(k,1,L){
                st[i][k]=(st[i][k]+f[i][j][k])%Mod;
                ed[j][k]=(ed[j][k]+f[i][j][k])%Mod;
            }
        }
    }
    cerr<<"\n"<<clock()*1.0/CLOCKS_PER_SEC*1000<<"ms\n";
    ll ans=0;
    rep(i,1,n){
        rep(j,1,n)ans=(ans+f[i][j][L])%Mod;
    }
    ans=ans*ans%Mod;
    rep(i,1,n){
        ll u=ord[i];
        rep(l1,1,L){
            rep(l2,1,L)g[u][l1][l2]=(g[u][l1][l2]+ed[u][l1]*ed[u][l2]%Mod*(k-1))%Mod;
        }
        memset(h,0,sizeof(h));
        rep(j,i+1,n){
            ll v=ord[j];
            rep(l1,1,L){
                rep(l2,1,L){
                    if(!g[u][l1][l2])continue;
                    rep(t1,1,L-l1){
                        if(!f[u][v][t1+1])continue;
                        h[v][l1+t1][l2]=(h[v][l1+t1][l2]+g[u][l1][l2]*f[u][v][t1+1])%Mod;
                    }
                }
            }
        }
        rep(j,i+1,n){
            ll v=ord[j];
            rep(l1,1,L){
                rep(l2,1,L){
                    if(!h[v][l1][l2])continue;
                    rep(t2,1,L-l2){
                        if(!f[u][v][t2+1])continue;
                        g[v][l1][l2+t2]=(g[v][l1][l2+t2]+h[v][l1][l2]*f[u][v][t2+1]%Mod*(k-1))%Mod;
                    }
                }
            }
        }
    }
    rep(i,1,n){
        ll u=ord[i];
        rep(l1,1,L){
            rep(l2,1,L){
                if(!g[u][l1][l2])continue;
                ans=(ans+g[u][l1][l2]*st[u][L-l1+1]%Mod*st[u][L-l2+1])%Mod;
            }
        }
    }
    if(n-2*L+1<0)ans=ans*pw(pw(k,Mod-2),-(n-2*L+1))%Mod;
    else ans=ans*pw(k,n-2*L+1)%Mod;
    write(ans),putchar('\n');
    cerr<<"\n"<<clock()*1.0/CLOCKS_PER_SEC*1000<<"ms\n";
    return 0;
}
```

---

## 作者：vegetable_king (赞：17)

[可能更好的阅读体验](https://yjh965.github.io/post/p11292-kdoi-11-cai-deng-wan-hui-ti-jie/)

好题。碍于场上策略原因没有场切这个题，但也算是单杀了，来写篇题解。

首先这个平方和就很可以拆，直接变成选两条长度为 $l$ 的链，在任意一条链上的点颜色均相同，其它点颜色任意的方案数。

这个东西就可以直接 DP 了，可以直接导出一个 $O(n^3l^2)$ 的做法，具体地，设 $f_{u, v, x, y}$ 表示两条链走到 $u, v$，长度分别为 $x, y$ 的方案数，每次转移拓扑序更小的点并处理 $u = v$ 的情况即可。

但是这个做法并没有什么优化空间，又因为题目中 $n$ 比 $l$ 更大，所以我们更倾向于一个 $O(n^2poly(l))$ 的做法。发现记录两个点是没有必要的，只需要记录它们重合的位置。即，设 $f_{u, x, y}$ 表示两条链最后一次重合在 $u$，长度分别为 $x, y$ 的方案数，每次转移时枚举下一个重合的位置。但是这样转移的系数是不好算的。

那么我们放弃钦定它们在途中不重合，改为钦定它们重合的次数，最后用二项式反演得出恰好重合这么多次的答案。具体来说，设 $f_{u, x, y, i}$ 表示两条链最后一次重合在 $u$，长度分别为 $x, y$，钦定重合了 $i$ 次的方案数，$g_{u, v, i}$ 表示 $u$ 走到 $v$ 恰好走 $i$ 条边的方案数，那么有转移方程：
$$
f_{u, x, y, i} \times g_{u, v, p} \times g_{u, v, q} \to f_{v, x + p, y + q, i + 1}
$$
然后设 $h1_i$ 为钦定重合了 $i$ 次的总方案数，$h2_i$ 为恰好重合了 $i$ 次的总方案数，有：
$$
h2_i = h1_i - \sum_{j = i + 1}^l \binom ji h2_j\\
ans = \sum_{i = 0}^l k^{n - 2l + i + 1} h2_i
$$
直接转移即可做到 $O(n^2l^5)$。发现转移是一个二维卷积，但可以变成两次一维卷积，可以优化到 $O(n^2l^4)$，然后就可以获得 $84$ 了。考虑那个 $i$ 维与转移无关，尝试优化。

我们考虑另一种二项式反演：
$$
h2_i = \sum_{j = i}^l \binom ji (-1)^{j - i} h1_j\\
\begin{aligned}
ans &= \sum_{i = 0}^l k^{n - 2l + i + 1} h2_i\\
ans &= \sum_{i = 0}^l k^{n - 2l + i + 1} \sum_{j = i}^l \binom ji (-1)^{j - i} h1_j\\
&= k^{n - 2l + 1} \sum_{j = 0}^l h1_j \sum_{i = 0}^j k^i (-1)^{j - i}\binom ji\\
&= k^{n - 2l + 1} \sum_{j = 0}^l h1_j (k - 1)^j\\
\end{aligned}
$$
那么我们在转移过程中将系数乘上去即可，这样就省掉了 $i$ 维。时间复杂度为 $O(n^3l + n^2l^3)$。

---

## 作者：NagasakiNoSoyo (赞：2)

> *迷い星のうた……*

看到平方肯定拆贡献啊，变成算两条长度为 $l$ 的链，设这两条链的并集为 $S$，那么贡献为 $k^{n-|S|}$。

并集这个限制太难处理了，容斥搞成交集。发现你这个贡献跟集合的大小有关，所以需要搞一个二项式反演。

先搞个预处理 $g_{u,v,i}$ 表示从 $u$ 走到 $v$ 走 $i$ 步的方案数。再搞个 DAG 拓扑序 DP 设 $f_{u,x,y,k}$ 表示当前在 $u$ 且钦定了这个点，第一条链长度为 $x$，第二条长度为 $y$，一共钦定了 $k$ 个点。转移枚举一个点 $v$，对 $x,y$ 这两维是一个卷积。直接转移复杂度 $O(n^2l^5)$

注意这两维卷积卷的是同一个多项式，所以可以分开来卷，优化到 $O(l^3)$（其实就算不是一个多项式也可以在不用 FFT 的情况下做到 $O(l^3)$）。考虑再优化，注意到我们只关心所有方案的 $k^{|S|}$ 之和，并不用必须求出每个长度的具体是多少。先推推式子，设 $f_i$ 表示最终钦定 $i$ 个点的方案数，根据二项式反演，答案为：

$$
\begin{aligned}
&\quad\sum_{i=0}^nk^{n-2l+i+1}\sum_{j=i}^n(-1)^{j-i}\binom{j}{i}f_j\\
&=k^{n-2l+1}\sum_{i=0}^n(-k)^{i}\sum_{j=i}^n(-1)^j\binom{j}{i}f_j\\
&=k^n\sum_{j=0}^nf_j(-1)^j\sum_{i=0}^j\binom{j}{i}(-k)^{i}\\
&=k^n\sum_{j=0}^nf_j(-1)^j(1-k)^j\\
&=k^n\sum_{j=0}^nf_j(k-1)^j
\end{aligned}
$$

于是可以把贡献拆到每次转移上，乘上一个 $(k-1)$，这样就省掉了最后一维。

复杂度 $O(n^2l^3)$。

代码实现时注意常数。可以调换循环顺序和特判。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int,int> pii;
#define fi first
#define se second
#define pb push_back
#define mp make_pair
const int N=310,L=22,mod=998244353;
int id,n,k,l,m;
vector<pii> G[N];
int f[N][L][L],t[L][L],g[N][N][L],st[N][L],ed[N][L];
int tops[N],deg[N];
int qpow(ll a,int k=mod-2){
	ll res=1;
	while(k){
		if(k&1)res=res*a%mod;
		a=a*a%mod;
		k>>=1;
	}
	return res;
}
signed main(){
//	freopen("party7.in","r",stdin);
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>id>>n>>k>>l>>m;
	for(int i=1;i<=m;i++){
		int u,v,c;
		cin>>u>>v>>c;
		G[u].pb(mp(v,c));
		deg[v]++;
	}
	queue<int> q;
	for(int i=1;i<=n;i++)
		if(!deg[i])q.push(i);
	int tp=0;
	while(q.size()){
		int u=q.front();q.pop();
		tops[++tp]=u;
		for(pii p:G[u]){
			int v=p.fi;
			deg[v]--;
			if(!deg[v])q.push(v);
		}
	}
	for(int si=1;si<=n;si++){
		int s=tops[si];
		g[s][s][1]=1;
		for(int ui=si;ui<=n;ui++){
			int u=tops[ui];
			for(pii p:G[u]){
				int v=p.fi,w=p.se;
				for(int i=1;i<=l;i++){
					g[s][v][i]=(g[s][v][i]+1ll*g[s][u][i-1]*w%mod)%mod;
				}
			}
		}
	}
	for(int i=1;i<=l;i++)
		for(int u=1;u<=n;u++)
			for(int v=1;v<=n;v++)
				ed[v][i]=(ed[v][i]+g[u][v][i])%mod,
				st[u][i]=(st[u][i]+g[u][v][i])%mod;
	for(int ui=n;ui>=1;ui--){
		int u=tops[ui];
		for(int vi=ui;vi<=n;vi++){
			int v=tops[vi];
			memset(t,0,sizeof(t));
			for(int x=1;x<=l;x++){
				if(!g[u][v][x+1])continue;
				for(int i=x+1;i<=l;i++)
					for(int j=1;j<=l;j++)
						t[i][j]=(t[i][j]+1ll*f[v][i-x][j]*g[u][v][x+1]%mod)%mod;
			}
			for(int x=1;x<=n;x++){
				if(!g[u][v][x+1])continue;
				for(int i=1;i<=l;i++)
					for(int j=x+1;j<=l;j++)
						f[u][i][j]=(f[u][i][j]+1ll*t[i][j-x]*g[u][v][x+1]%mod)%mod;
			}
		}
		for(int i=1;i<=l;i++)
			for(int j=1;j<=l;j++)
				f[u][i][j]=(1ll*f[u][i][j]*(k-1)%mod+1ll*st[u][i]*st[u][j]%mod*(k-1)%mod)%mod;
	}
	ll ans=0;
	for(int u=1;u<=n;u++)
		ans=(ans+ed[u][l])%mod;
	ans=ans*ans%mod;
	for(int u=1;u<=n;u++)
		for(int i=1;i<=l;i++)
			for(int j=1;j<=l;j++)
				ans=(ans+1ll*f[u][i][j]*ed[u][l-i+1]%mod*ed[u][l-j+1]%mod)%mod;
	if(n-2*l+1<0)ans=ans*qpow(qpow(k),2*l-n-1)%mod;
	else ans=ans*qpow(k,n-2*l+1)%mod;
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Corzica (赞：2)

我们可以先把平方拆开，转化为求两条同色的链的对数。

考虑一对的同色链的贡献，显然它的贡献为 $k^{\text{未被任意一条链的点数}}$。直接状压，复杂度 $O(n^3l2^n)$。

可以考虑按照拓扑序转移，每一次转移拓扑序小的，可以方便的计算未被选过的点个数，复杂度 $O(n^3l^2)$。

考虑二项式反演，我们设 $h_{i,p,q,k}$ 表示最后一次钦定的重合在 $i$，两条链长度分别为 $p$、$q$，重合次数为 $k$ 的方案数。转移可以枚举下一个点和两个长度进行转移。

需要额外预处理出 $f_{i,j,k}$ 表示从 $i$ 到 $j$ 长度为 $k$ 的路径的个数。还有 $beg_{i,j}$ 和 $end_{i,j}$ 分别表示以 $i$ 为开头的链的个数和以 $j$ 为结尾的链的个数。

直接转移复杂度 $O(n^2l^5+n^3l)$，但是可以分步转移 $p$ 和 $q$，优化到 $O(n^2l^4+^3l)$。

我们设 $g_{i,p,q,k}$ 表示恰好为 $k$ 次时的答案，$G_k$ 表示所有 $g_{*,*,*,k}$ 的和，类似的定义 $H_k$。有：
$$
   G_k=\sum_{i\geq k} H_i \times C_{i}^{k}\times (-1)^{i-k}
$$
$$
   ans=\sum_{i} G_i \times k^{n-2l+i+1}
$$

把式 1 带入式 2，得：
$$
   ans=\sum_{i}k^{n-2l+i+1}\sum_{j\geq i} H_j \times C_{j}^{i}\times (-1)^{j-i} 
$$
$$
   ans=k^{n-2l+1}\sum_{i}\sum_{j\geq i} H_j \times C_{j}^{i}\times (-1)^{j-i}\times k^i
$$
调换枚举顺序：
$$
   ans=k^{n-2l+1}\sum_{j} H_j \sum_{i\leq j} C_{j}^{i}\times (-1)^{j-i}\times k^i
$$
发现最后面的形式是一个二项式定理，得到：
$$
   ans=k^{n-2l+1}\sum_{j} H_j(k-1)^j
$$

于是便去掉了 $k$ 那一维，复杂度 $O(n^3l+n^2l^3)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int id, n, K, l, m;
int f[21][305][305], beg[305][21], ed[305][21];
int g[305][21][21], h[305][21][21], tab[305], d[305], cnt, name[305];
vector<pair<int, int>> to[305];
queue<int> que;
const int mod = 998244353;
inline int ksm(int p, int q = mod - 2) {
	int base = 1;
	while (q) {
		if (q & 1)base = base * 1ll * p % mod;
		q >>= 1;
		p = p * 1ll * p % mod;
	}
	return base;
}
inline int read() {
	int x = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9') ch = getchar();
	if (ch == '-') f = -1, ch = getchar();
	while (ch >= '0' && ch <= '9') {
		x = x * 10 + ch - '0';
		ch = getchar();
	}
	return x * f;
}
inline void add(int &p, int q) {
	(p += q) >= mod ? p -= mod : 0;
}
signed main() {
//	ios::sync_with_stdio(0);
//	cin.tie(0);
//	cout.tie(0);
	int u, v;
	id = read(), n = read(), K = read(), l = read(), m = read();
	l--;
	int p, q, w;
	for (int i = 1; i <= m; i++) {
		p = read(), q = read(), w = read();
		d[q]++;
		to[p].push_back(make_pair(q, w));
	}
	for (int i = 1; i <= n; i++) {
		if (!d[i]) que.push(i);
	}
	while (que.size()) {
		int u = que.front();
		que.pop();
		tab[++cnt] = u;
		name[u] = cnt;
		for (pair<int, int> i : to[u]) {
			if (!(--d[i.first])) {
				que.push(i.first);
			}
		}
	}
	for (int i = 1; i <= n; i++) {
		int u = tab[i];
		for (pair<int, int>j : to[u]) {
			add(	f[1][i][name[j.first]], j.second);
		}
	}
	for (int i = 2; i <= l; i++) {
		for (int j = 1; j <= n; j++) {
			for (int k = j + 1; k <= n; k++) {
				if (! f[i - 1][j][k] ) continue;
				for (int p = k + 1; p <= n; p++) {
					if (!f[1][k][p]) continue;
					f[i][j][p] = (f[i][j][p] + f[i - 1][j][k] * 1ll * f[1][k][p]) % mod;
				}
			}
		}
	}
	for (int i = 1; i <= n; i++) {
		beg[i][0] = ed[i][0] = 1;
		for (int j = 1; j <= l; j++) {
			for (int k = 1; k < i; k++) {
				add(ed[i][j], f[j][k][i]);
			}
			for (int k = i + 1; k <= n; k++) {
				add(beg[i][j], f[j][i][k]);
			}
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j <= l	; j++) {
			if (!ed[i][j]) continue;
			for (int k = 0; k <= l; k++) {
				if (!ed[i][k] ) continue;
				g[i][j][k] = ed[i][j] * 1ll * ed[i][k] % mod * (K - 1) % mod;
			}
		}
	}

	for (int i = 1; i <= n; i++) {
		memset(h, 0, sizeof(h));
		for (int p = i + 1; p <= n; p++) {
			for (int j = 0; j <= l; j++) {
				for (int k = 0; k <= l; k++) {
					if (!g[i][j][k]) continue;
					for (int jj = j; jj <= l; jj++) {
						if (!f[jj - j][i][p]) continue;
						h[p][jj][k] = (h[p][jj][k] + g[i][j][k] * 1ll * f[jj - j][i][p]) % mod;
					}
				}
			}
		}
		for (int p = i + 1; p <= n; p++) {
			for (int j = 0; j <= l; j++) {
				for (int k = 0; k <= l; k++) {
					if (!h[p][j][k]) continue;
					for (int kk = k; kk <= l; kk++) {
						if (! f[kk - k][i][p]) continue;
						g[p][j][kk] = (g[p][j][kk] + h[p][j][k] * 1ll * f[kk - k][i][p] % mod * (K - 1) % mod) % mod;
					}
				}
			}
		}
	}
	int ans = 0;
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j <= l; j++) {
			for (int k = 0; k <= l; k++) {
				if (! g[i][j][k]) continue;
				ans = (ans + g[i][j][k] * 1ll * beg[i][l - j] % mod * beg[i][l - k]) % mod;
			}
		}
	}
	int all = 0;
	for (int i = 1; i <= n; i++) {
		add(all, beg[i][l]);
	}
	ans = (ans + all * 1ll * all) % mod;
	l++;
	if (n - 2 * l + 1 < 0) {
		ans = ans * 1ll * ksm(ksm(K, 2 * l - n - 1)) % mod;
	} else {
		ans = ans * 1ll * ksm(K, n - 2 * l + 1) % mod;
	}
	cout << ans << "\n";
}
```

---

## 作者：Erine (赞：1)

加训 counting 第一期。

首先把所有点重标号使得 $1\sim n$ 是一个拓扑序，使用拓扑排序完成。

平方的组合意义太典了啊，那就等价于你选定两条长为 $l$ 的路径，钦定它们颜色相同。假设一个路径的点集为 $X$ 另一个为 $Y$。产生的贡献是

$$k^{n-|X\cup Y|+1}W(X)W(Y)$$

其中

$$W(S)=\prod_{i=2}^{|S|}w(S_{i-1},S_i)$$

观察最难处理的限制：并集的大小。我一开始对并集做容斥，得到了并非有前途的做法。既然“并非”有前途，不妨尝试对交集做容斥。我们有 $|X\cup Y|=2l-|X\cap Y|$。不妨枚举 $S=X\cap Y$，并容斥钦定 $S\subseteq T$ 使得 $T$ 成为 $|X\cap Y|$ 的子集。

$$
\begin{aligned}
&\sum_{S} k^{n-2l+1+|S|}\sum_{S\subseteq T}(-1)^{|T|-|S|}\left(\sum_{T\subseteq X,|X|=l} W(X)\right)^2 \\
=&k^{n-2l+1}\sum_{T}(-1)^{|T|}\left(\sum_{T\subseteq X,|X|=l} W(X)\right)^2 \sum_{S\subseteq T} (-k)^{|S|}\\
=&k^{n-2l+1}\sum_{T}(k-1)^{|T|}\left(\sum_{T\subseteq X,|X|=l} W(X)\right)^2 \\
\end{aligned}
$$

其实这个时候看起来就好做了，为什么呢？考虑确定一个 $T$，那么 $X,Y$ 的元素事实上会被 $T$ 分成若干个区间；那么我们对一个区间处理出 $f_{l,r,i}$ 表示选定 $l, r$，中间额外选了 $i$ 个元素的所有合法 $S$ 的 $W(S)$ 之和，这个可以 $\Theta(n^3l)$ 处理出来；再进行 dp，即 $g_{i,x,y}$ 表示考虑了 $1\sim i$ 并钦定 $i\in T$，此时 $|X|\cap [1,i]=x,|Y|\cap [1,i]=y$ 的贡献之和。

暴力转移需要枚举 $j$ 表示 $i$ 在 $T$ 中的前驱，以及 $[j,i]$ 段 $X$ 和 $Y$ 选了几个，做形如二维卷积的转移。复杂度 $\Theta(n^2l^4)$，可以获得随机分数，总之无法获得满分。

考虑直接分步卷积，先卷第一维再卷第二维即可，因为贡献系数是可拆的。复杂度 $\Theta(n^2l^3)$，可以获得 $[88,100]$ 分，因为卡常大概率没办法获得满分。。

---

卡常技巧：感觉上 $20$ 个 $\Theta(\text{mod})$ 的数对乘积和应该卡不爆 `unsigned long long` 吧。。。虽然理论爆了，但是卡不掉吧（笑）。所以你就全加上也啥都不取模，最后再一起取模一遍就行了，然后就跑过去了。。

多卡卡常完全可以跑进 400ms，最大点 304ms，目前最优解第一。

---


# [NHSPC 2023] C. 与自动辅助驾驶畅游世界

## 题目描述

知名汽车公司 EWM 在自家的汽车上安装了最新的自动驾驶辅助 (auto co-pilot) 技术，让汽车在驾驶员没有给出明确指令的情况下，也能依据 AI 做出的决策前进。身为车主的小明，自然开始计划使用这款具备自动驾驶辅助技术的汽车以畅游世界。

这个世界可以看作一张有向图 (directed graph) $G$，其中 $G$ 上的点 $s$ 为小明目前的位置，点 $t$ 为小明欲到达的终点。为了兼顾行车安全，EWM 的汽车在 $G$ 上的行进期间，必须遵循有向边 (directed edge) 的方向前进，不能逆向行驶；在此前提下，无论所在的位置为何，AI 都会从所有可以前进的方向中，均匀随机地 (uniformly random) 选择一个方向前进。举例来说，若汽车目前在点 $a$，而点 $a$ 有三条向外的边，分别连到点 $b, c, d$，此时 AI 辅助驾驶会从点 $b, c, d$ 中，以概率各为 $1/3$ 的方式选出一个前进。

为了使驾驶员能控制汽车往他/她希望的方向前进，EWM 公司提供了以下的机制：在 AI 做出决策前，驾驶员可以支付 $1$ 枚 EWM 公司发行的代币，让 AI 选择驾驶员希望的方向。以上一个例子为例，若小明在点 $a$ 时不希望 AI 做随机选择，而是直接选择某个点（例如点 $b$）前进，那么他可以支付 $1$ 枚代币，控制 AI 直接选择走向点 $b$。请注意一次代币支付仅限使用于一次选择，亦即若汽车重新回到了同一个支付过代币的点，AI 并不会直接往上一次支付代币时指定的方向前进，而是会重新均匀随机地做出选择；如果驾驶员仍想指定汽车的前进方向，必须再次支付 $1$ 枚代币。

小明想要知道，他最少需要准备多少枚代币，才能保证在抵达终点 $t$ 前的任何时刻都存在一条从他的所在地抵达终点 $t$ 的路径。

## 说明/提示

### 测试数据限制

* $1 \le n \le 3000$。
* $1 \le m \le 30000$。
* $1 \le u_i \le n$。
* $1 \le v_i \le n$。
* $1 \le s \le n$。
* $1 \le t \le n$。
* 对任意 $i, j \in \{1, 2, \ldots, m\}$，若 $i \ne j$，则 $(u_i, v_i) \ne (u_j, v_j)$。
* 输入的数皆为整数。

### 评分说明

本题共有四组子任务，条件限制如下所示。
每一组可有一或多个测试数据，该组所有测试数据皆需答对才可获得该组分数。

|  子任务  |  分数  | 额外输入限制 |
| :------: | :----: | ------------ |
| 1 | $4$ | $m = n-1$，且存在某个点 $r$ 满足从 $r$ 出发可以到达 $G$ 上的其他点 |
| 2 | $24$ | $G$ 不包含任何环 (cycle) |
| 3 | $31$ | $n \le 100, m \le 1000$ |
| 4 | $41$ | 无额外限制 |

## 样例 #1

### 输入

```
5 5
1 2
2 3
3 1
2 4
3 5
1 5```

### 输出

```
2```

## 样例 #2

### 输入

```
5 6
1 2
2 3
3 1
4 2
4 5
5 4
1 5```

### 输出

```
-1```

## 样例 #3

### 输入

```
8 11
1 2
2 1
2 3
3 4
3 8
4 1
4 5
5 6
5 7
6 7
6 8
1 8```

### 输出

```
1```

# 题解

## 作者：ケロシ (赞：6)

哥们来写唐诗做法了！！1111

首先注意到转移肯定是：

$$f_u=\min(\min f_v+1,\max f_v)$$

初始 $f_{ed}=0$，终点走反边不可达的点为无穷大，那么答案就是满足方程的最小的 $f_{st}$。

这里有一种优质做法，就是先把所有的值设为 $0$，然后不断跑转移方程使得某个点暂时满足方程，迭代 $O(n)$ 次后所有方程都满足，直接输出即可，复杂度 $O(nm)$。

但是本人太菜了，不会这一种做法，于是想出了一种唐诗做法。

考虑先跑一次 bfs，跑出转移的前半部分 $f_u=\min f_v+1$。

接下来考虑 $\max f_v$ 的限制可能会形成一个类似环状的东西，这样就可以集体 $f_u$ 减一（参考样例三）。

接下来考虑具体什么时候可以集体减一，不难发现若 $f_u \le \max f_v$ 且 $f_u=f_v$，那么点 $v$ 就支配了点 $u$，那么点 $u$ 就向点 $v$ 连一条边。

那么不难发现，将图的强连通分量缩掉之后，若一个点没有出边，也就是没有被支配，那么就可以集体减一了。

接下来重复这个过程即可，每次跑 bfs，然后找能集体减一的块。

接下来口胡一下复杂度，注意到每次集体减一的块的 $f_u$ 都是路径上最大的，且每次减一后块的大小会增大，所以只会迭代 $O(n)$ 次。

时间复杂度 $O(nm)$。

```cpp
const int N = 3e3 + 5;
const int M = 1e5 + 5;
const int INF = 1e9 + 7;
int n, m, st, ed;
vector<int> e[N], g[N];
int f[N], vis[N];
int fi[N], ne[M], to[M], ecnt;
int dfn[N], low[N], cnt;
int stk[N], tp;
int scc[N], sc;
int ru[N], b[N];
void add(int u, int v) {
	ne[++ ecnt] = fi[u];
	to[ecnt] = v;
	fi[u] = ecnt;
}
void bfs() {
	FOR(i, 1, n) vis[i] = 0;
	deque<int> q;
	q.push_back(ed);
	while(! q.empty()) {
		int u = q.front();
		q.pop_front();
		if(vis[u]) continue;
		vis[u] = 1;
		for(int v : e[u]) {
			if(f[v] == f[u]) {
				q.push_front(v);
			}
			if(f[v] >= f[u] + 1) {
				f[v] = f[u] + 1;
				q.push_back(v);
			}
		}
	}
}
void clear() {
	FOR(i, 1, n) fi[i] = dfn[i] = low[i] = vis[i] = 0;
	ecnt = cnt = sc = tp = 0;
}
void tarjan(int u) {
	dfn[u] = low[u] = ++ cnt;
	stk[++ tp] = u;
	vis[u] = 1;
	for(int i = fi[u]; i; i = ne[i]) {
		int v = to[i];
		if(! dfn[v]) {
			tarjan(v);
			chmin(low[u], low[v]);
		}
		else if(vis[v]) {
			chmin(low[u], dfn[v]);
		}
	}
	if(dfn[u] == low[u]) {
		sc ++;
		while(1) {
			scc[stk[tp]] = sc;
			vis[stk[tp]] = 0;
			tp --;
			if(stk[tp + 1] == u) break;
		}
	}
}
void solve() {
	cin >> n >> m;
	REP(_, m) {
		int u, v;
		cin >> u >> v;
		e[v].push_back(u);
		g[u].push_back(v);
	}
	cin >> st >> ed;
	FOR(i, 1, n) f[i] = INF;
	f[ed] = 0;
	while(1) {
		bfs();
		clear();
		FOR(u, 1, n) {
			int mx = 0; b[u] = 0;
			for(int v : g[u]) chmax(mx, f[v]);
			if(mx <= f[u]) {
				for(int v : g[u]) 
					if(f[v] == f[u]) add(u, v);
			}
			else {
				b[u] = 1;
			}
		}
		bool ok = 0;
		FOR(u, 1, n) if(! dfn[u]) tarjan(u);
		FOR(i, 1, sc) ru[i] = 0;
		FOR(u, 1, n) for(int i = fi[u]; i; i = ne[i]) {
			int v = to[i];
			if(scc[u] != scc[v]) ru[scc[u]] ++;
		}
		FOR(u, 1, n) if(f[u] != INF && scc[u] != scc[ed] && ! ru[scc[u]] && ! b[u]) f[u] --, ok = 1;
		if(! ok) break;
	}
	cout << (f[st] == INF ? - 1 : f[st]);
}
```

---

## 作者：fangzichang (赞：5)

和我做法一样的题解虽然写的很好但是我还是读了好一会，所以久违地写一个。  

### 简化题意  
题意太复杂了。  
简化一下就是，$n$ 点 $m$ 边有向图，目标是从起点 $s$ 到达终点 $t$，每次移动时，可选择以下两种操作之一：
1. 从当前点所有出边中随机选择一条，并沿这条边移动，代价为 $0$；
2. 从当前点所有出边中选定一条，并沿这条边移动，代价为 $1$。

求：最坏情况下，最少需要消耗多少代价才能抵达 $t$？或者说，最少需要准备多少代价，才能保证在抵达 $t$ 前的任何时刻都存在一条从当前点抵达 $t$ 的路径？  

### 初步思考
手玩发现，可以预处理哪些点不能到达终点，然后避免走到这些点上。也就是说，如果当前在点 $u$，$u$ 的某个出边指向的点 $v$ 不能到达终点，则我必须耗费 $1$ 的代价，不然随机游走到 $v$ 上就输了。  
更一般地，设 $f_u$ 表示从 $u$ 走到 $t$ 需要消耗的最小代价，则容易得到有以下两种转移：  
1. 在 $u$ 处耗费一个代价，则 $f_u=1+\min_{(u,v)\in E} f_v$；
2. 在 $u$ 处随机选择出边，则 $f_u=\max_{(u,v)\in E} f_v$。

然后两者取 $\min$，不能到的点赋值 $+\infin$，$f_t$ 赋值成 $0$。  
容易发现，会随机选择出边，当且仅当所有出边到达的点的 $f$ 值全部相同，这个性质可以减少一些思考难度。  
这个做法明显有后效性，倒着拓扑排序可以通过 Subtask 2。  

### 正解  
这个 DP 看起来很棘手，因为后效性太严重难以确定 DP 顺序。  
很容易想到强连通分量缩点来去掉后效性，参见其他题解。  
注意到数据范围不大，甚至于支持 $O(nm)$ 级别。  
追忆一下学过的技巧，考虑直接按照 DP 值划分阶段。  
具体地，从小到大枚举 $w$，假设已经有了 $f_v<w$ 的每个点 $v$ 的 $f_v$，尝试每轮用 $O(m)$ 的复杂度找出所有满足 $f_u=w$ 的点 $u$。  

根据使用了哪种转移，将试图去找的点分成两类：  

第一类是能够一步到达某个 $v$ 满足 $f_v=w-1$ 的点。  
这也就相当于使用了转移 $f_u=1+\min_{(u,v)\in E} f_v$。  
很容易 $O(m)$ 找出所有这样的点，比如枚举所有满足 $f_v=w-1$ 的点 $v$ 遍历它的所有前驱。  

> 先定义一下随机游走：从一个点出发，每次都使用代价为 $0$ 的决策，随机选择出边不断游走，可以经过重复点/边，直到到达一个 DP 值已经确定好的点 $v$（满足 $f_v=+\infin$ 或从之前的转移已经确定 $f_v\le w$）的过程。所有可能的点 $v$ 组成的集合称为这个点出发随机游走的终点集合。

那么第二类点满足，从它出发随机游走的终点集合中，没有不能到达 $t$ 的点，或者说集合中没有点 $v$ 满足 $f_v=+\infin$。  
我断言第二类点是所有使用了转移 $f_u=\max_{(u,v)\in E} f_v$ 得到 $f_u=w$ 的点 $u$。  
定义可能比较抽象，而且本题难点在此，需要仔细体会。  
不过这个体会完之后似乎正确性显然：如果一个点的 DP 值未确定（即 $f_u\ge w$），在这个随机游走过程中还可能到达 $f_v=+\infin$ 的点，那它就不能使用转移 $f_u=\max_{(u,v)\in E} f_v$ 得到 $f_u=w$。  

> 必要性证明：考虑一个二类点 $u$ 的所有后继 $v$ 都满足 $f_v\le w$（根据性质其实都是 $f_v=w$），从这些点出发继续外推，它们要么自己是一类点，要么仍旧所有后继都是二类点或一类点，不可能有某次直接从二类点到某个 $f_v=+\infin$ 的点的情况。必须要有某个一类点挡着。  
> 充分性证明不比这个难，留作习题。  

### 实现  
预处理不能到达 $t$ 的所有点。  
从小到大枚举 $w$，枚举所有满足 $f_v=w-1$ 的点 $v$ 遍历它的所有前驱，这些是一类点。  
枚举所有不能到达 $t$ 的点，从这些点出发在反图上 BFS，标记它们不经过已经确定 DP 值的点就能到达的所有点。  
或者说，这些点随机游走时，在到达一类点之前就会进入到不了终点的点。  
那么没被标记且 DP 值未确定的点就是所有二类点。  
总共要枚举 $O(n)$ 轮，每轮的复杂度是 $O(m)$，总复杂度 $O(nm)$ 解决此题。  
代码非常好写（感觉比缩点写法好写），不过很容易写的很怪。以下为省略缺省源的代码，仅供参考。  

```cpp
int n,m,s,t,go[N],f[N];
//MyGo!!!
//I am playing <Haruhikage> now.
basic_string<int>g[N],no,q0,q1;
void bfs(const basic_string<int>&st,int*w,int w0,int w1){
	queue<int>q;
	for(int u:st)q.push(u),w[u]=w1;
	for(int u;!q.empty();q.pop()){
		u=q.front();
		for(int v:g[u])
			if(w[v]==w0)w[v]=w1,q.push(v);
	}
}
signed main(){
	cin(n,m);
	for(int i=1,u,v;i<=m;i++)
		cin(u,v),g[v]+=u;
	cin(s,t);
	for(int u=1;u<=n;u++)
		g[u].resize(remove(all(g[u]),t)-g[u].begin());
	fill(go+1,go+n+1,0),bfs({t},go,0,1);
	for(int u=1;u<=n;u++)if(!go[u])no+=u;
	fill(f+1,f+n+1,n+1),
	bfs({t},f,n+1,0),bfs(no,f,0,n+1);
	for(int u=1;u<=n;u++)
		if(!f[u])q1+=u;
	if(find(all(q1),s)!=q1.end())
		return puts("0"),0;
	for(int w=1;w<n;w++){
		for(int u:q1)for(int v:g[u])
			if(f[v]==n+1)f[v]=-1;
		replace(f+1,f+n+1,n+1,n+2),bfs(no,f,n+2,n+1);
		for(int u=1;u<=n;u++)
			if(f[u]==-1||f[u]==n+2)f[u]=w,q0+=u;
		swap(q0,q1),q0.clear();
		if(find(all(q1),s)!=q1.end())
			return print(w),pc(endl),0;
	}
	puts("-1");
	return 0;
}
```

---

## 作者：anotherobject (赞：1)

### 题意
在有向图上随机游走，直到达到终点。每次可以消耗 $1$ 的代价选择一条出边走。问最小代价使得到终点前不会走到死路。

题意需要深刻理解，样例需要深刻手摸，做题需要看 Subtask。

### Subtask 1

特殊性质是图是外向树。

所在位置需要一直是 $t$ 的祖先。

每次遇到岔路消耗 $1$ 代价，即统计 $s,t$ 路径上所有出度 $>1$ 的点数和（不包括 $t$）。若 $s$ 不是 $t$ 祖先，输出 `-1`。

### Subtask 2

特殊性质是图是有向无环图。

计算拓扑序后 dp。

$f_u$ 代表以 $u$ 为起点的答案。$f_t =0$。

每个点可以消耗 $1$ 代价强制选择出边，则一定选择 $f$ 最小的出边。$f_u = \min f_v+1$。

每个点可以随机游走，此时需要考虑最劣情况。$f_u=\max f_v$。

综上 $f_u=\min(\min f_v+1,\max f_v)$。

### Subtask 3

$n\le 100,m\le 1000$。

没有拓扑序后，需要找到动态规划的顺序。

可以按照 $f$ 值从小到大进行动态规划。

当 $f_u=x$ 时，有两种情况，$u$ 强制选择了出边，以及未强制选择出边，进行随机游走（$x=0$ 时只有随机游走，和 $u=t$）。

当我们计算好了所有 $\lt x$ 的 $f$ 后，如何寻找 $f_u=x$ 的 $u$？

考虑那些强制选择出边的 $u$，则如果存在出边使得 $f_v=x-1$，则 $f_u=x$。这代表今后图内最小的 $f$ 是 $x$（总能找到这样的点）。

进行上述操作后，考虑那些随机游走的 $u$，若 $u$ 和所有无法到达 $t$ 的点不连通，则 $f_u=x$（此时图内最小的 $f$ 是 $x$）。

复杂度瓶颈在于判断 $u$ 和无法到达 $t$ 的点的连通性，因为答案最大值和 $n$ 同阶，故总复杂度 $O(n^2(n+m))$。

### Subtask 4

$n\le 3000,m\le 30000$。

尝试优化复杂度瓶颈：在反图上，从所有到达不了 $t$ 的点开始搜索，禁止经过 $f$ 有值的点，所有未遍历到且 $f$ 没有值的点均为随机游走的 $u$。

总复杂度 $O(n(n+m))$。

---

## 作者：blue_ice26 (赞：0)

一道很有意思的图论 or dp 题。

### 题目大意：
在每个点上，我们有两种选择：向所有方向走，或花费 $1$ 代价朝一个方向走。最少花费多少代价能在所有的路径上到达终点。  
注意，如果存在环，理论上可以在环上一直绕圈。但这道题只考虑经过有限步到达点 $t$ 的情况即可。

### 思路分析：
1. 先从终点 $t$ 倒着 dfs，求出哪些点可以到达点 $t$。如果 $s$ 无法到达这时就可以输出 $-1$ 了。

2. 设点 $v$ 是点 $u$ 连接到的所有点，则到点 $u$ 到点 $t$ 所花费的最小代价（下文直接称为最小代价） $cost_u$ 为 $\min(\max(cost_v),\min(cost_v)+1)$。但是这个图是可能存在环的，所以直接递推一定求不出来某些点的最小代价。

3. 考虑缩点，对于已经求出来最小代价和无法到达点 $t$ 的点就**不再缩**了。如果一个**缩点后的点** $u$ 所连接到的所有点的最小代价 $cost_{min}$ 已经求出，且这些代价全部相等，则点 $u$ 所对应的所有缩点前的点的最小代价也一定是 $cost_{min}$。

4. 如果不存在这样一个点 $u$，那么就从**缩点前的图**上找到一个未求出最小代价的点 $u'$，点 $u'$ 满足其连接到的且已经求出最小代价的点 $v$ 中的代价最小值 $\min(cost_v)$ 是所有点中最小的。则点 $u'$ 的最小代价一定为 $\min(cost_v)+1$。  
证明：如果点 $u'$ 的代价可能更小，因为所有未求出最小代价的点所连接的点的最小代价必然大于等于 $\min(cost_v)$，所以它更小的代价只可能是 $\min(cost_v)$。  
这样，考虑点 $u'$ 所在的**缩点后的点**连接到的所有未求出最小代价的缩点前的点，只有这些点的最小代价为 $\min(cost_v)$ 时点 $u'$ 的最小代价才可能是 $\min(cost_v)$。  
同理，如果这些点所在的缩点后的点所连接到的所有点的最小代价都已求出且全部相等，为 $\min(cost_v)$，那么这个图上就存在一个符合上述条件的点 $u$，矛盾。否则继续递推。  
也就是说，除非存在一个符合上述条件的点 $u$，否则点 $u'$ 的最小代价不可能为 $\min(cost_v)$。而这与前提矛盾，所以 $u'$ 的最小代价一定为 $\min(cost_v)+1$。

5. 也就是说，每求出一个点的最小代价就重新缩点，继续求最小代价直到求出 $s$ 的最小代价即可通过本题。

### 复杂度：
缩点用到 tarjan 求强联通分量，缩点后只需遍历每个点和每条边即可。最多重复 $n$ 次，复杂度 $O(nm)$。

### 代码：
```cpp
#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>
constexpr int N=3e3,INF=0x3f3f3f3f;
std::vector<int>e[N+5],re[N+5],node[N+5];
int dfn[N+5],low[N+5],ans[N+5],stack[N+5],id[N+5],head,cnt,pt,s,t;
bool in[N+5],ar[N+5],used[N+5];
void tarjan(int from)
{
	dfn[from]=(++cnt);
	low[from]=cnt;
	stack[++head]=from;
	in[from]=1;
	for(int to:e[from])
	{
		if(ar[to]==0||used[to])
			continue;
		if(dfn[to])
		{
			if(in[to])
				low[from]=std::min(low[from],low[to]);
		}
		else
		{
			tarjan(to);
			low[from]=std::min(low[from],low[to]);
		}
	}
	if(low[from]==dfn[from])
	{
		pt++;
		while(stack[head]!=from)
		{
			in[stack[head]]=0;
			id[stack[head]]=pt;
			node[pt].push_back(stack[head]);
			head--;
		}
		in[stack[head]]=0;
		id[stack[head]]=pt;
		node[pt].push_back(stack[head]);
		head--;
	}
	return;
}
void dfs(int from)
{
	ar[from]=1;
	for(int to:re[from])
	{
		if(ar[to]==0)
			dfs(to);
	}
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		e[u].push_back(v);
		re[v].push_back(u);
	}
	scanf("%d%d",&s,&t);
	if(t==s)
	{
		printf("0");
		return 0;
	}
	dfs(t);
	if(ar[s]==0)
	{
		printf("-1");
		return 0;
	}
	used[t]=1;
	for(;;)
	{
		tarjan(s);
		bool f=1;
		for(int i=1;i<=pt;i++)
		{
			int min=INF;
			for(int from:node[i])
			{
				for(int to:e[from])
				{
					if(id[from]==id[to])
						continue;
					else if(used[to])
					{
						if(min==INF)
							min=ans[to];
						else if(min!=ans[to])
							goto out;
						continue;
					}
					else
						goto out;
				}
			}
			for(int from:node[i])
			{
				used[from]=1;
				ans[from]=min;
			}
			f=0;
			break;
			out:;
		}
		if(f)
		{
			int amin=INF,aminn=0;
			for(int i=1;i<=pt;i++)
			{
				int min=INF,minn=0;
				for(int from:node[i])
				{
					for(int to:e[from])
					{
						if(id[from]==id[to])
							continue;
						if(used[to])
						{
							if(min>ans[to]+1)
							{
								min=ans[to]+1;
								minn=from;
							}
						}
					}
				}
				if(amin>min)
				{
					amin=min;
					aminn=minn;
				}
			}
			ans[aminn]=amin;
			used[aminn]=1;
		}
		if(used[s])
		{
			printf("%d",ans[s]);
			return 0;
		}
		for(int i=1;i<=pt;i++)
		{
			node[i].clear();
		}
		cnt=pt=0;
		memset(dfn+1,0,n<<2);
		memset(low+1,0,n<<2);
		memset(id+1,0,n<<2);
	}
}
``````

---


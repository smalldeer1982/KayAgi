# 血缘关系

## 题目描述

我们正在研究妖怪家族的血缘关系。每个妖怪都有相同数量的基因，但是不同的妖怪的基因可能是不同的。我们希望知道任意给定的两个妖怪之间究竟有多少相同的基因。由于基因数量相当庞大，直接检测是行不通的。但是，我们知道妖怪家族的家谱，所以我们可以根据家谱来估算两个妖怪之间相同基因的数量。

妖怪之间的基因继承关系相当简单：如果妖怪 $C$ 是妖怪 $A$ 和 $B$ 的孩子，则 $C$ 的任意一个基因只能是继承 $A$ 或 $B$ 的基因，继承 $A$ 或 $B$ 的概率各占 $50\%$。所有基因可认为是相互独立的，每个基因的继承关系不受别的基因影响。

现在，我们来定义两个妖怪 $X$ 和 $Y$ 的基因相似程度。例如，有一个家族，这个家族中有两个毫无关系（没有相同基因）的妖怪 $A$ 和 $B$，及它们的孩子 $C$ 和 $D$。那么 $C$ 和 $D$ 相似程度是多少呢？因为 $C$ 和 $D$ 的基因都来自 $A$ 和 $B$，从概率来说，各占 $50\%$。所以，依概率计算 $C$ 和 $D$ 平均有 $50\%$ 的相同基因，$C$ 和 $D$ 的基因相似程度为 $50\%$。需要注意的是，如果 $A$ 和 $B$ 之间存在相同基因的话，$C$ 和 $D$ 的基因相似程度就不再是 $50\%$ 了。

你的任务是写一个程序，对于给定的家谱以及成对出现的妖怪，计算它们之间的基因相似程度。

## 样例 #1

### 输入

```
7 4                                                    
4 1 2                                          
5 2 3                                          
6 4 5                                          
7 5 6
4
1 2
2 6
7 5
3 3
```

### 输出

```
0%
50%
81.25%
100%
```

# 题解

## 作者：jiangyougogogo (赞：17)

难得成为此题第一个吃螃蟹的蒟蒻……

这道题的思维难度不是太大，但实现难度稍大，有一定综合性。

#基本递推

首先，我们记F[a][b]表示a和b的基因相似度。

不难发现，F[a][b]=F[b][a]，自身没有祖先的那些点之间F[a][b]=0，自身和自身F[a][a]=1。

归纳证明可得到F[a][b]=(F[f[a][0]][b]+F[f[a][1]][b])/2，其中f[a][0],f[a][1]是a的父母，且a的辈分比b低或相同。如果不是很容易理解可以手动计算一下样例。

所以我们已经找到了递推公式。实现的时候可以先确定所有点的辈分（用类似拓扑的方法），然后记忆化搜索（直接递推比较难确定先后顺序，不提倡）。

#高精度小数

到这里我们已经明确了答案的计算方式，但是此题有一个很大的坑点——高精度小数。

如果要手写浮点数（科学计数法）或高精分数肯定是能实现的，可惜本蒟蒻并不会。注意到F[a][b]只能是0,1或纯小数，可以用定点数存放。

#时空分析

总时间复杂度O(n²（就是最大的m）×n（高精度的转移代价）)=O(n³)，空间复杂度也是O(n³)。

为什么高精度的存储转移代价是O(n)呢？其实此题只涉及加法和除2，O(n)计算转移操作是可以实现的。出一组数据：3是1,2的孩子，4是1,3的孩子，5是1,4的孩子，以此类推直到300是1,299的孩子，这样查询1和300的相似度的答案是1-2^(-298)，需要298位小数才能存放，所以存储代价也是O(n)。

时间上1s多半是资辞的，但是空间上直接开300³的int好像会MLE。C++选手可以用vector来存放小数来防止MLE。也可以用short类型。

虽然写得又长又难看，但还是贴一下代码吧。相信大家都是诚实的好孩子不会抄题解。

```cpp
/*luoguP1235 AC code, Copyright © JSSY(i.e. jiangyougogogo)*/
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<ctime>
#include<cctype>
#include<algorithm>
#include<iostream>
#include<string>
#include<vector>
#define hk 310
using namespace std;
struct DB{short N[hk];};//正序存储定点小数，N[0]代表位数，N[1]是整数部分，N[2]到N[N[0]]是小数部分
DB div(DB x,int y){//高精度除法
    int rem,flg=0;DB z;if(!x.N[1]&&x.N[0]==1)return x;
    for(memset(z.N,0,sizeof z.N),z.N[z.N[0]=1]=x.N[1]/y,rem=x.N[1]%y;(rem||!flg)||z.N[0]<x.N[0];z.N[0]++){
        z.N[z.N[0]+1]=(rem*10+x.N[z.N[0]+1])/y;
        rem=(rem*10+x.N[z.N[0]+1])%y;if(z.N[z.N[0]+1])flg=1;
    }return z;
}DB plu(DB x,DB y){//高精度加法
    int i=max(x.N[0],y.N[0]);DB z;for(memset(z.N,0,sizeof z.N);i;i--){
        z.N[i-1]+=(z.N[i]+x.N[i]+y.N[i])/10;
        z.N[i]=(z.N[i]+x.N[i]+y.N[i])%10;
    }for(z.N[0]=max(x.N[0],y.N[0]);z.N[0]>1&&!z.N[z.N[0]];z.N[0]--);
    return z;
}void wri(DB x){//输出，先输出百分数的整数部分，再输出小数部分
    int i,t=0;for(i=1;i<4;i++)t=t*10+x.N[i];
    printf("%d",t);if(x.N[0]<4){puts("%");return;}
    for(putchar('.'),i=4;i<=x.N[0];i++)printf("%d",x.N[i]);puts("%");return;
}
vector<int>eg[hk];int n,k,i,j,x,y,z,f[hk][2],m,q[hk],la[hk],to[hk],hd,tl,tt;
bool iss[hk],lab[hk][hk],inq[hk];DB F[hk][hk];
DB C(int x,int y){//记忆化搜索
    if(lab[x][y])return F[x][y];//计算过就直接把答案拿来
    if(la[x]>la[y]||!iss[y])F[x][y]=F[y][x]=div(plu(C(f[x][0],y),C(f[x][1],y)),2);
    else F[x][y]=F[y][x]=div(plu(C(x,f[y][0]),C(x,f[y][1])),2);//选辈分低的向祖先方向继续搜
    lab[x][y]=lab[y][x]=1;return F[x][y];
}int main(){
for(scanf("%d%d",&n,&k),i=0;i<k;i++)
scanf("%d%d%d",&x,&y,&z),f[x][0]=y,f[x][1]=z,iss[x]=1,eg[y].push_back(x),eg[z].push_back(x),to[x]+=2;
    for(i=1;i<=n;i++)if(!iss[i])q[++tl]=i,la[i]=inq[i]=1;//类似拓扑的方法处理辈分，先把没有父母（即iss[i]==0）的那些点记作第一层，计算la[]表示层数，分层
    for(hd=0;hd^tl;){
        for(hd++,i=eg[q[hd]].size()-1;i+1;i--)if(!(--to[tt=eg[q[hd]][i]])&&!inq[tt])
            q[++tl]=tt,inq[tt]=1,la[tt]=la[q[hd]]+1;
}//BFS拓扑
for(i=1;i<=n;i++)for(j=1;j<=n;j++){
        if(!iss[i]&&!iss[j])F[i][j].N[1]=0,F[i][j].N[0]=1,lab[i][j]=1;
        if(i==j)F[i][j].N[1]=1,F[i][j].N[0]=1,lab[i][j]=1;
}//赋初值，其中lab[i][j]表示当前位置有没有被计算过
for(scanf("%d",&m);m;m--){
        scanf("%d%d",&x,&y);
        wri(C(x,y));//计算即输出
    }return 0;
}
```

---

## 作者：Salamander (赞：9)

本题较为麻烦。

首先用f[i][j]表示i与j之间的相似度，fa[i]表示i的父亲，ma[i]表示i的母亲。

有递推式：（这个我想了好久）f[i][j]=(f[fa[i]][j]+f[ma[i]][j])/2,或者是f[i][j]=(f[i][fa[j]]+f[i][ma[j]])/2

至于具体取哪一个下面会讲。


首先初始化各个祖先之间相似度为0。

发现根本不知道按什么顺序推。所以记忆化搜索。b[i][j]记录i和j的关系是否已经得出。


但是这时候问题来了：

如果我们一直取i的父母与j比较，即用递推式f[i][j]=(f[fa[i]][j]+f[ma[i]][j])/2，

有可能出现一个情况：j是i的子辈，那么此时i的父母会离j越来越“远”，这样记忆化搜索永远结束不了。

所以还要用拓扑排序，记录下各个怪物在拓扑序列中的位置，用来比较辈分，每次要取辈分靠后的怪物的父母分别与另一个进行比较。


至于高精度，还是要自己慢慢打了。


详见代码：





```cpp
#include<bits/stdc++.h>
using namespace std;
#define file(x) freopen(#x".in","r",stdin),freopen(#x".out",stdout)
struct num //高精度运算符重载
{
    int a[302],len;
    num()
    {
        len=1;
        memset(a,0,sizeof a);
    }
    num operator=(num x)
    {
        for(int i=1;i<=x.len;i++)
            a[i]=x.a[i];
        len=x.len;
        return *this;
    }
    void div2()
    {
        for(int i=1;i<=len;i++)
        {
            if(a[i+1]&1)a[i]+=10;
            a[i]/=2;
        }
        while(a[len]==0&&len>1)len--;
    }
    num operator+(num b)
    {
        num a=*this,c;
        int x=0;
        c.len=max(a.len,b.len)+1;
        for(int i=1;i<=c.len;i++)
        {
            c.a[i]=a.a[i]+b.a[i]+x;
            x=c.a[i]/10;
            c.a[i]%=10;
        }
        while(c.a[c.len]==0&&c.len>1)c.len--;
        return c;
    }
};
typedef num number;
ostream& operator<<(ostream &cout,num x)
{
    int a[301],len=x.len,beg=1;
    for(int i=1;i<=x.len;i++)
        a[i]=x.a[i];
    while(len<298)a[++len]=0;
    while(a[beg]==0&&beg<298)beg++;
    for(int i=len;i>=beg;i--)
    {
        if(i==297)printf(".");
        printf("%d",a[i]);
    }
    return cout;
```
}//输出自己想办法



    
```cpp
number f[301][301];
int fa[301][2],n,m,k,anc[301],dep[301],son[301][301],num[301],sta[301],top=0,fat[301];
//dep是在拓扑序列中的位置，fat是父母数量，anc记录所有的祖先，son是各个节点的儿子们，num是儿子数量
bool b[301][301];//记录关系是否已经得出
number dfs(int x,int y)//记忆化搜索
{
    if(b[x][y])return f[x][y];
    if(dep[x]<dep[y])swap(x,y);//如果x的备份较高，即在拓扑序列中的dep较小，就要交换
    number p;
    b[x][y]=b[y][x]=1;
    p=dfs(fa[x][0],y)+dfs(fa[x][1],y);//取x的父母与y比较
    p.div2();
    return f[y][x]=f[x][y]=p;
}
int main()
{
    //file(family);
    scanf("%d%d",&n,&k);
    for(int i=1,aa,bb,cc;i<=k;i++)
    {
        scanf("%d%d%d",&aa,&bb,&cc);
        son[bb][++num[bb]]=aa;
        son[cc][++num[cc]]=aa;
        fa[aa][0]=bb;
        fa[aa][1]=cc;
        fat[aa]=2;
```
}//输入
    
    
    
```cpp
    for(int i=1;i<=n;i++)
    {
        f[i][i].len=300;
        f[i][i].a[300]=1;//初始化高精度
        b[i][i]=1;
        if(!fa[i][0]&&!fa[i][1])anc[++anc[0]]=i;
    }
    for(int i=1;i<anc[0];i++)
        for(int j=i+1;j<=anc[0];j++)
            b[anc[i]][anc[j]]=b[anc[j]][anc[i]]=1;//祖先之间关系已经得出
    int deep=0;
    for(int i=1;i<=anc[0];i++)
        sta[++top]=anc[i];//拓扑排序，祖先入栈
    while(top>0)//拓扑排序
    {
        int k=sta[top--];
        dep[k]=++deep;//记录深度
        for(int i=1;i<=num[k];i++)
        {
            fat[son[k][i]]--;
            if(!fat[son[k][i]])sta[++top]=son[k][i];
        }
    }
    scanf("%d",&m);
    for(int i=1,u,v;i<=m;i++)
    {
        scanf("%d%d",&u,&v);
        dfs(u,v);
        cout<<f[u][v]<<'%'<<endl;
    }
    return 0;
}
```

---

## 作者：SunsetSamsara (赞：3)

蒟蒻第一次写紫题题解，请多多包涵。

这道题其实不算特别难，难的是细心与 Debug 的耐心...(~~我不会告诉你我交了20多次才过的！~~)

首先，发现 $n \le 300$ ,说明最多有 $300$ 位,又因为题目说`有多少精度就输出多少`，所以需要高精度。这里因为都在 0 与 1 之间，所以可以用定点数存放。

我们用 dp 处理相似程度。

那么 $i$ 与 $j$ 的相似程度其实就是 $i$ 与 $j$ 的双亲相似程度除以 $2$，
因为 $j$ 的基因就是双亲每人贡献$\dfrac1 2$的基因

所以，令 $dp[i][j]$ 表示 $i$ 与 $j$ 的基因相似程度，则有$dp[i][j]=(dp[i][par[j][0]]+dp[i][par[j][1]])/2$,

其中 $par[i][0]$ 表示 $i$ 的父亲，$par[i][1]$表示 $i$ 的母亲。

所以其实这里只需要支持高精加，高精除单精($2$)。下面是高精方面的代码

```cpp
struct High{char A[301];int len;};
High operator+(High a,High b){
	for(int i=a.len+1;i<=300;++i)a.A[i]=0;
	for(int i=b.len+1;i<=300;++i)b.A[i]=0;
	int n=(a.len<b.len)?(b.len):(a.len);//位数多的 
	for(int i=n;i>=0;--i){
		a.A[i]+=b.A[i];
		if(a.A[i]>=10&&i)a.A[i-1]+=a.A[i]/10,a.A[i]%=10;//进位 
	}
	a.len=n;//位数取多的 
	while(a.len&&!a.A[a.len])--a.len;
	return a;
}
High Div2(High a){
	int c=0,t;//退下来的数 
	for(int i=a.len+1;i<=300;++i)a.A[i]=0;
	a.A[++a.len]=0;//不管怎样位数先加1 
	for(int i=0;i<=a.len;++i){
		t=c;
		if(a.A[i]&1)c=1;//奇数落下1 
		else c=0;
		a.A[i]=(a.A[i]+t*10)/2;
	}
	while(a.len&&!a.A[a.len])--a.len;//最后一位是零 
	return a;
}
void Print(High a){
	printf("%d",(a.A[0]*10+a.A[1])*10+a.A[2]);
	if(a.len>=3){//还有要输出的 
		putchar('.');//小数点 
		for(int i=3;i<=a.len;++i)
			putchar('0'+a.A[i]);
	}
	putchar('%');//一定要有'%' 
	putchar('\n'); 
}
```

然后再通过拓扑排序处理 $i$ 的深度(辈分?),直接 BFS 即可。

```cpp
/*算辈分*/
queue<int> q;
bool vis[301];
for(int i=1;i<=N;++i)
	if(!isSon[i])
		q.push(i),dept[i]=1,vis[i]=true;
while(q.size()){
	for(int i=0;i<sons[q.front()].size();++i)
		if((--deg[sons[q.front()][i]])&&!vis[sons[q.front()][i]]){
			q.push(sons[q.front()][i]);
			dept[sons[q.front()][i]]=dept[q.front()]+1;
			vis[sons[q.front()][i]]=true;
		}
	q.pop();
}
```

既然是 dp，自然就要赋初值了。
题面中写了，如果没有双亲的妖精，相似度为 $0\%$。
而一个妖精与自己的相似程度自然就是 $100\%$ 了。

代码:
```cpp
/*赋初值*/
int i,j;
for(i=1;i<=N;++i)
	for(j=1;j<=N;++j){
		if(i==j){//就是一个妖精 
			dp[i][j].len=1;
			dp[i][j].A[0]=1;
			cc[i][j]=1;
		}else if(!isSon[i]&&!isSon[j]){//两者互不相关 
			dp[i][j].len=1;
			dp[i][j].A[0]=0;
			cc[i][j]=1;
		}
	}
```

最后，使用 DFS 处理 dp 就结束了。不过我这里用的是记忆化搜索，直接 dp 也可以了。
```cpp
High Dfs(int u,int v){//开始记忆化搜索 
	if(cc[u][v])return dp[u][v]; //算过了
	if(dept[u]>dept[v]){int t=v;v=u;u=t;}//交换u,v
	if(isSon[v])dp[u][v]=dp[v][u]=Div2(Dfs(u,par[v][0])+Dfs(u,par[v][1])); //把深的往上拉 
	else dp[u][v]=dp[v][u]=Div2(Dfs(par[u][0],v)+Dfs(par[u][1],v)); //把深的往上拉 
	cc[u][v]=cc[v][u]=true;
	return dp[u][v];
}//PS:怎么写着有点暴力LCA的感觉了? 
```

接下来，在询问中一个个 DFS 就可以处理出答案。

---

## 作者：封禁用户 (赞：3)

f[i][j]表示i、j的亲缘关系。             
f[i][j]=(f[i][fa[j]]+f[i][mo[j]])/2或f[i][j]=(f[fa[i]][j]+f[mo[i]][j])/2              
按拓扑序推一遍就好了。         
听说有高精度小数。            
下面是代码(很奇葩)
```

#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
#define rep(i,j,k) for(i=j;i<=k;++i)
#define per(i,j,k) for(i=j;i>=k;--i)
#define sqr(x) ((x)*(x))
#define G getchar()
#define LL long long
#define pll pair<LL,LL>
#define mkp make_pair
#define X first
#define Y second
#define N 305
int n,m,fa[N],mo[N];
int he[N],ne[N<<1],to[N<<1],tot;
int q[N],in[N];
struct DATA{short dat[N];int ln;}f[N][N];
DATA operator +(DATA x,DATA y){
    x.ln=max(x.ln,y.ln);
    int i;per(i,x.ln,1)
        if((x.dat[i]+=y.dat[i])>9)++x.dat[i-1],x.dat[i]-=10;
    x.dat[0]+=y.dat[0];
    while(x.ln&&!x.dat[x.ln])--x.ln;
    return x;
}
DATA div2(DATA x){
    int i;
    rep(i,0,x.ln){
        if(x.dat[i]&1)x.dat[i+1]+=10;
        x.dat[i]>>=1;
    }
    if(x.dat[x.ln+1])x.dat[++x.ln]=5;
    return x;
}
void add(int x,int y){
    to[++tot]=y;ne[tot]=he[x];he[x]=tot;
}
int read(){
    int x=0;char ch=G;
    while(ch<48||ch>57)ch=G;
    for(;ch>47&&ch<58;ch=G)x=x*10+ch-48;
    return x;
}
void BFS(){
    int Ft=1,Rr=1,u,v,i;
    rep(i,1,n){
        if(!in[i])q[Rr++]=i;f[i][i].dat[0]=1;
    }
    while(Ft<Rr){
        u=q[Ft++];
        per(i,Ft-2,1){
            v=q[i];f[u][v]=f[v][u]=div2(f[v][fa[u]]+f[v][mo[u]]);
        }
        for(i=he[u];i;i=ne[i])if(--in[v=to[i]]==0)q[Rr++]=v;
    }
}
void write(DATA x){
    printf("%d",x.dat[0]*100+x.dat[1]*10+x.dat[2]);int i;
    if(x.ln>2){
        putchar('.');
        rep(i,3,x.ln)printf("%d",x.dat[i]);
    }
    puts("%");
}
int main(){
    int i,x,Q,y;
    n=read();m=read();
    while(m--){
        in[x=read()]=2;fa[x]=read();mo[x]=read();
        add(fa[x],x);add(mo[x],x);
    }
    BFS();
    for(Q=read();Q--;){
        x=read();y=read();write(f[x][y]);
    }
    return 0;
}

```


---

## 作者：时间圣使·凡 (赞：1)

### 关于此题题面:
洛谷中这道题的题面有些问题，这里给出一个供参考的[较为正确的题面](https://www.luogu.com.cn/blog/obatm1/p1235-xie-yuan-guan-ji-jiao-wei-qing-chu-di-ti-mian)。

洛谷题面中主要问题是没有正确表达 $a$ 是 $b$ 与 $c$ 的孩子。

### 解法:
首先我们打开标签，发现是一道动态规划加高精度的题目，再仔细一看，发现是高精度除法。

根据题目描述，我们不需要关心这个妖怪是否自己后代中出现了自己，还是不止一对父母，甚至不需要关心他们的是公还是母。
##### 动态转移方程:
那么现在剩下的事情很明确，我们首先要搞清楚妖怪的基因相似程度到底怎么计算，观察数据以及推断（凑数）之下，可以发现两只妖怪的基因相似程度是其中一只妖怪与另一只妖怪的两只亲本的基因相似程度之和除以 $2$，而一只妖怪与自己的相似度自然是 $100\%$。

再加上之前得到的此题为动态规划题目的信息，如果用 $F_{i,j}$ 表示 $i$ 与 $j$ 的基因相似程度，用 $fa_{j,0\setminus 1}$ 表示 $j$ 的两个亲本，不难推断出 $F_{i,j} = F_{j,i} = (F_{i,fa_{j,0}} + F_{i,fa_{j,1}}) / 2$。而后面由于高精度的原因，$F$ 数组存储的数据改为对应数据在存数据的数组的位置下标。
##### 妖怪计算的顺序:
但是问题并没有这么简单，因为再计算 $i$ 和 $j$ 的基因相似程度的时候，我们可能不知道 $j$ 亲本与 $i$ 的基因相似程度。

为了解决这个问题，我们需要一个合理的计算顺序。

根据题意，会发现这些妖怪中至少有两个是没有亲本的，我称这些妖怪为妖怪先祖。因为妖怪先祖没有亲本，所以我们率先从妖怪先祖入手，这些妖怪先祖相互之间基因相似度为 $0\%$，只要一只妖怪的亲本全为妖怪先祖，那么这只妖怪与各个妖怪先祖以及每一个亲本为全为妖怪的基因相似度我们就可以求出来。因为这些妖怪的基因已经明显可以得出，则我们可以将其作为下一代妖怪先祖，虽然这一代的妖怪先祖之间的基因相似度不一定为 $0\%$，但是这并不妨害我们继续计算下一代亲本均为妖怪先祖的妖怪的基因相似度。于是这样就可以计算出一代又一代的妖怪先祖，从而得出正确的计算顺序，即一代代妖怪先祖出现的先后顺序。总的来说，就是我们先将第一代妖怪先祖加入队列，然后从队头开始向后扫描，在第 $i$ 个先祖的时候，我们将其所有孩子的亲本数量 $-1$，然后扫描一遍所有妖怪，如果出现了没有加入队列的妖怪，而且此时它的亲本数量为 $0$，则其成为下一代妖怪先祖，加入队列，直到队列扫描结束。此时队列即为我们的计算先后顺序。
##### 高精度:
由于题目要求有多少精度就输出多少精度，所有需要打高进度除法（带小数）。
总体来说与正常高精度相比较为简单，因为此处除数只有 $2$，按照正常的竖式计算除法的方式运用到程序中即可。

**代码中有注释，没理解的同学可以看程序并结合注释食用。**
### 代码：
```cpp
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<map>
using namespace std;
int n,m,k;
int fa[400][10],son[400][400],ans1[400],ans2[400],fl[400];
//  亲本        子代          亲本数量   子代数量 亲本数量复制体，用于妖怪先祖的计算。 
int f[400][400];//记录i，j两个妖怪的基因相似程度的数据存在js的几号位置。 
bool ff[400];//该妖怪是否已经进入队列。 
struct zwh{
	int zs;//zs整数部分。 
	int xs[305],ans;//xs小数部分以及ans小数部分的长度。 
}js[100000];
vector<int> num;//记录计算顺序的vector。 
void clac(int x,int y,int s1,int s2){//高精度。 
	zwh now;
	int lm=max(js[s1].ans,js[s2].ans);//两个数据的小数部分最长长度需要记录，用于解决函数内now数据不为0而为随机生成的问题。 
	now.ans=0;
	for(int i=1;i<=lm+2;i++) now.xs[i]=0;//这里清零，因为函数内now的数据为随机生成 lm+2是为了防止小数位数变长后计算了随机数据。
	//至于为什么是lm+2,虽然最多增加一位，但是我害怕不对所以多一位。 
	now.zs=js[s1].zs+js[s2].zs;
	for(int i=1;i<=lm;i++)
		now.xs[i]=js[s1].xs[i]+js[s2].xs[i];//前期直接全部相加。 
	for(int i=lm;i>1;i--)
		if(now.xs[i]>=10){
			now.xs[i-1]+=now.xs[i]/10;
			now.xs[i]%=10;
		}
	if(now.xs[1]>=10){
		now.zs+=(now.xs[1]/10);
		now.xs[1]%=10;
	}//解决进位问题。 
	if(now.zs%2)
		now.xs[1]+=10;
	now.zs/=2;//开始除以2，整数部分出现奇数则留到下一位去计算。 
	int jk=1;
	while(jk<=lm+2){//可能出现小数中间出现0的情况，所以全体扫描一遍。 
		if(now.xs[jk]>0){//如果这一位存在需要计算的数值（即不为0），开始除以2操作。 
			if(now.xs[jk]%2) now.xs[jk+1]+=10;//如果为奇数，留到下一位处理。 
			now.xs[jk]/=2;//除以2。 
			now.ans=jk;//记录长度。 
		}
		jk++;
	}
	//以上为计算(f[i][fa[i][0]]+f[i][fa[i][1]])/2 。 
	js[x].zs=js[y].zs=now.zs;
	js[x].ans=js[y].ans=now.ans;
	for(int i=1;i<=now.ans;i++){
		js[x].xs[i]=js[y].xs[i]=now.xs[i];
	}//进行f[i][j]=f[j][i]=(f[i][fa[i][0]]+f[i][fa[i][1]])/2赋值操作。 
	//即动态规划。 
	return;
}
void writeit(int x){
	cout<<js[x].zs;
	if(js[x].ans>0) cout<<".";
	for(int i=1;i<=js[x].ans;i++)
		cout<<js[x].xs[i];
	cout<<"%"<<endl;
}//输出高进度数据。 
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int x,y,z;cin>>x>>y>>z;
		fa[x][++ans1[x]]=y;
		fa[x][++ans1[x]]=z;//记录亲本。 
		son[y][++ans2[y]]=x;
		son[z][++ans2[z]]=x;//记录子代。 
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			f[i][j]=(i-1)*n+j;//赋给每一个数据存放的地址。 
	for(int i=1;i<=n;i++){
		fl[i]=ans1[i],js[f[i][i]].zs=100;//复制亲本数组，并将自己和自己相似度标记为100% 。 
		if(!ans1[i]) num.push_back(i),ff[i]=1;//记录第一代妖怪先祖。 
	}
	int o=0;
	while(o<num.size()){//计算计算顺序。 
		int p=num[o];
		for(int i=1;i<=ans2[p];i++)
			fl[son[p][i]]--;//i号亲本可以用于计算，进行减去操作。 
		for(int i=1;i<=n;i++)
			if(!ff[i]&&!fl[i]) num.push_back(i),ff[i]=1;//符合成为妖怪先祖条件，成为下一代妖怪先祖。 
		o++;
	}
	for(int i=0;i<num.size();i++)
		if(ans1[num[i]])//有亲本才能计算相似度。 
			for(int j=0;j<i;j++)
				clac(f[num[i]][num[j]],f[num[j]][num[i]],f[num[j]][fa[num[i]][1]],f[num[j]][fa[num[i]][2]]);//计算。
				//即动态规划，因为需要高精度除法，所以放在函数中进行。
	cin>>k;
	while(k--){
		int x,y;cin>>x>>y;
		writeit(f[x][y]);//输出。 
	} 
	return 0;
}
```





---

## 作者：Comentropy (赞：0)

## 分析

- 实际上这道题的难点并不在动态规划上，而是各种复杂的处理。

我们可以把血缘关系看成是一个有拓扑序的有向图。只需要一点点简单的思考就可以分析本题。

### 动态规划部分

这一部分实际上非常简单。

- 初始化：若 C 和 D 没有任何关系，那么他们的相似度为 $0\%$；并且一个妖精和他自己的相似度是 $100\%$。
- 我们记 $fa[u][0,1]$ 为这个妖精 $u$ 的两个父亲。那么显然根据题意 $f[u][v]=f[v][u]=(f[fa[u][0]][v]+f[fa[u][1]][v])\div 2$。那么为了使得最后一定能够处理出来，即回溯到两者已计算的且有关联的祖先，我们需要保证两者深度有一定的关系，这里可以转到拓扑排序部分。
- 只需要保证 $dep[u]>dep[v]$（$u$ 的辈分比 $v$ 小）就可以用，如果顺序反了只要调换一下就行。
- 代码中展示的是记忆化搜索。

### 拓扑排序

其实就是拓扑排序模板，并没有多少值得注意的点，但是在加边的时候注意入度加二而不是加一，并且需要注意先初始化再拓扑排序（初始化需要读入度）。
```cpp
vector<int> e[N];
queue<int> q;
int in[N],dep[N];
bool vis[N];
  
void topo(){
    for(int i=1;i<=n;i++)
        if(!in[i])
            q.push(i),vis[i]=true,dep[i]=1;
    while(!q.empty()){
        int u=q.front();
        q.pop();
        for(int v:e[u]){
            in[v]--;
            if(!vis[v]&&!in[v]){
                vis[v]=true,dep[v]=dep[u]+1;
                q.push(v);
            }
        }
    }
    return ;
}
```

### 高精度

其实还是有蛮多处理细节的，说一下最重要的几点。

- 因为本题是定点小数计算，所以把 $a[1]$ 作为高位来处理更加方便。
- 不能够直接初始化，会被卡掉，会出现全部 ```RE``` 或直接 ```CE```。所以在计算的时候处理这一问题（即代码中 ```attention``` 位置）会让复杂度小很多。
- 注意处理 ```0``` 的问题。

```cpp
struct huge{
    int a[N];
    int len;  // 1 为最高位
}f[N][N];
huge operator+(huge x,huge y){
    for(int i=x.len+1;i<=300;i++)
        x.a[i]=0;
    for(int i=y.len+1;i<=300;i++)
        y.a[i]=0;	// attention
    huge tmp;
    tmp.len=std::max(x.len,y.len);tmp.a[tmp.len+1]=0;
    for(int i=tmp.len;i>=0;i--){
        tmp.a[i]=x.a[i]+y.a[i]+(tmp.a[i+1]/10);
        tmp.a[i+1]%=10;
    }
    while(!tmp.a[tmp.len]&&tmp.len)
        tmp.len--;
    return tmp;
}
huge div_equal(huge x){
    for(int i=x.len+1;i<=300;++i)
        x.a[i]=0;	// attention
    x.len++;
    for(int i=0;i<=x.len;i++){
        if(x.a[i]%2==1)
            x.a[i+1]+=10;
        x.a[i]>>=1;
    }
    while(x.a[x.len]==0&&x.len)
        x.len--;
    return x;
}
void print(huge x){
    printf("%d",x.a[0]*100+x.a[1]*10+x.a[2]);
    // 先输出整数部分
    if(x.len>=3){
        putchar('.');
        for(int i=3;i<=x.len;i++)
            printf("%d",x.a[i]);
    }
    putchar('%');
    putchar('\n');
    return ;
}
```

### 总结
主要来说这道题如果没有高精可能也就绿题水平，加上高精会让整个题处理的难度提高很多，比较考验码力。

## Code
就给一下主函数和搜索部分吧，其他部分见上文。
```cpp
void init(){
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++){
            if(i==j)
                f[i][j].len=1,f[i][j].a[0]=1,flag[i][j]=true;
            else if(!in[i]&&!in[j])
                f[i][j].len=1,f[i][j].a[0]=0,flag[i][j]=true;
        }
    return ;
}
huge dfs(int u,int v){
    if(flag[u][v])
        return f[u][v];
    if(dep[u]<dep[v])
        swap(u,v);
    flag[u][v]=flag[v][u]=true;
    return f[u][v]=f[v][u]=div_equal(dfs(fa[u][0],v)+dfs(fa[u][1],v));
}
int main(){
    int T;
    scanf("%d%d",&n,&k);
    for(int i=1;i<=k;i++){
        int u,x,y;
        scanf("%d%d%d",&u,&x,&y);
        e[x].push_back(u);
        e[y].push_back(u);
        fa[u][0]=x,fa[u][1]=y;
        in[u]+=2;
    }
    init();
    topo();
    scanf("%d",&T);
    while(T--){
        int u,v;
        scanf("%d%d",&u,&v);
        print(dfs(u,v));
    }
    return 0;
}
```


---


# [KOI 2021 Round 2] 美食推荐

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

KOI 国有 $N$ 个城市。每个城市编号从 1 到 $N$。

KOI 国的结构很特别，把城市看作图的顶点、道路看作无向边，则这个国家的结构可以表示为一个包含 $N$ 个顶点的**树**。树是一个无环的连通图。

KOI 国共有 $M$ 家美食餐厅，每家餐厅编号从 1 到 $M$。某些城市可能没有餐厅，也可能有两个以上的餐厅，请特别注意这一点。

第 $i$ 家餐厅（$1 \leq i \leq M$）位于城市 $c_i$，配送范围为距离不超过 $d_i$ 的城市，且其客户偏好度为 $g_i$。

第 $i$ 家餐厅可以向从城市 $c_i$ 出发，经过至多 $d_i$ 条道路所能到达的所有城市配送。即，第 $i$ 家餐厅的配送范围为：

$$
R_i = \{ j \mid d(c_i, j) \leq d_i \}
$$

其中，$d(a, b)$ 表示从城市 $a$ 到城市 $b$ 之间的最短路径长度（即需要经过的最少道路数）。

你是一名外卖推荐平台的运营者。为了避免服务重叠，你希望从 $M$ 家餐厅中选出一个子集 $S$，满足以下条件：

- 对于任意城市 $p$，它不能同时被 $S$ 中的两个或多个餐厅包含在其配送范围内。也就是说，对于 $S$ 中任意不同的两家餐厅 $i$ 和 $j$，都有 $R_i \cap R_j = \emptyset$。

请从所有满足上述条件的子集 $S$ 中，选出客户偏好度总和最大的一个，并输出该最大值。


## 说明/提示

**约束条件**

- 所有输入数据均为整数。
- $1 \leq N \leq 10^5$
- $1 \leq M \leq 10^5$
- 对于所有 $i$（$1 \leq i \leq M$），满足 $0 \leq d_i \leq N - 1$，$1 \leq g_i \leq 10^9$

**子任务**

1. （9 分）对于 $1 \leq i \leq N - 1$，城市 $i$ 与城市 $i+1$ 之间有一条道路相连。
2. （11 分）$N, M \leq 20$
3. （17 分）$N, M \leq 2\,000$
4. （10 分）$N \leq 2\,000$
5. （8 分）对于 $2 \leq i \leq N$，城市 $\lfloor i/2 \rfloor$ 与城市 $i$ 之间有一条道路相连。
6. （12 分）图中度数大于等于 3 的顶点最多只有一个。
7. （33 分）无额外约束条件。

## 样例 #1

### 输入

```
8 5
1 2
2 3
3 4
4 5
5 6
4 7
4 8
3 2 40
6 0 5
8 0 5
2 1 16
5 1 32```

### 输出

```
53```

# 题解

## 作者：gdf_yhm (赞：0)

[P12730](https://www.luogu.com.cn/problem/P12730)

### 思路

物品 $i$、$j$ 能同时选要求 $dis(p_i,p_j)\ge d_i+d_j+1$。设 $dp_u$ 表示所选物品只覆盖到 $u$ 子树内的最大价值。将物品挂在 $p$ 的 $d$ 级祖先上。若没有物品覆盖 $u$，$dp_u=\sum dp_v$；否则枚举 $u$ 上的物品，挖去其覆盖的连通块后形成若干森林，从这些森林的根 $x$ 的 $\sum dp_x$ 处转移。

这些 $x$ 满足 $dis(p,x)=d+1$。如果是完全二叉树的特殊性质，直接枚举 $p$ 的祖先作为 $lca(p,x)$ 并记录 $f_{u,d}$ 表示 $u$ 子树内 $dis(u,x)=d$ 的 $dp_x$ 之和。发现只需要能跳祖先的性质，可以点分树。枚举 $p$ 点分树的祖先 $tp$，将 $dis(p,x)$ 拆为 $dis(p,tp)+dis(x,tp)$。记录 $f_{u,d}$ 表示点分树上 $u$ 子树内到 $u$ 在原树距离为 $d$ 的 $\sum dp_x$，$g_{u,d}$ 为到原树上 $fa_u$ 的距离为 $d$ 的 $\sum dp_x$。这些有值的 $f,g$ 只有 $O(n\log n)$ 个。

复杂度 $O(n\log n)$。

### code

```cpp
int n,m;
int head[maxn],tot;
struct nd{
	int nxt,to;
}e[maxn<<1];
void add(int u,int v){e[++tot]={head[u],v};head[u]=tot;}
int to[maxn][17],dep[maxn];
int st[17][maxn],dfn[maxn],idx;
void dfs(int u,int fa){
	st[0][dfn[u]=++idx]=fa;
	to[u][0]=fa;dep[u]=dep[fa]+1;
	for(int i=1;i<=16;i++)to[u][i]=to[to[u][i-1]][i-1];
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;if(v==fa)continue;
		dfs(v,u);
	}
}
int mmax(int u,int v){return dfn[u]<dfn[v]?u:v;}
int lca(int u,int v){
	if(u==v)return u;
	u=dfn[u],v=dfn[v];
	if(u>v)swap(u,v);u++;
	int k=__lg(v-u+1);
	return mmax(st[k][u],st[k][v-(1<<k)+1]);
}
int dis(int u,int v){return dep[u]+dep[v]-2*dep[lca(u,v)];}
int kth(int u,int k){
	for(int i=16;~i;i--)if(k&(1<<i))u=to[u][i];
	return !u?1:u;
}
bool vis[maxn];
int siz[maxn],w[maxn],sum,rt;
void getrt(int u,int fa){
	siz[u]=1,w[u]=0;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;if(v==fa||vis[v])continue;
		getrt(v,u);siz[u]+=siz[v];w[u]=max(w[u],siz[v]);
	}
	w[u]=max(w[u],sum-siz[u]);
	if(w[u]<=sum/2)rt=u;
}
int fa[maxn];
void sovle(int u){
	vis[u]=1;getrt(u,0);
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;if(vis[v])continue;
		sum=siz[v];getrt(v,u);fa[rt]=u;sovle(rt);
	}
}
unordered_map<int,ll> f[maxn],g[maxn];
vector<tuple<int,int,int>> ask[maxn];
ll dp[maxn];
void dfs(int u){
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;if(v==to[u][0])continue;
		dfs(v);dp[u]+=dp[v];
	}
	for(auto[p,d,w]:ask[u]){
		ll sum=0;int x=p;while(x){
			if(f[x].find(d+1-dis(x,p))!=f[x].end())sum+=f[x][d+1-dis(x,p)];
			x=fa[x];
		}
		x=p;while(fa[x]){
			if(g[x].find(d+1-dis(fa[x],p))!=g[x].end())sum-=g[x][d+1-dis(fa[x],p)];
			x=fa[x];
		}
		dp[u]=max(dp[u],sum+w);
	}
	int x=u;while(x)f[x][dis(x,u)]+=dp[u],x=fa[x];
	x=u;while(fa[x])g[x][dis(fa[x],u)]+=dp[u],x=fa[x];
}
void work(){
	n=read();m=read();
	for(int i=1;i<n;i++){
		int u=read(),v=read();
		add(u,v),add(v,u);
	}
	dfs(1,0);
	for(int j=1;j<=16;j++){
		for(int i=1;i+(1<<j)-1<=n;i++)st[j][i]=mmax(st[j-1][i],st[j-1][i+(1<<j-1)]);
	}
	for(int i=1;i<=m;i++){
		int p=read(),d=read(),w=read();
		ask[kth(p,d)].pb({p,d,w});
	}
	sum=n;getrt(1,0);sovle(rt);
	dfs(1);
	printf("%lld\n",dp[1]);
}
```

---


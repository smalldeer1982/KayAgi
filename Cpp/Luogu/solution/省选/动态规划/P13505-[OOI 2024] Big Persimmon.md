# [OOI 2024] Big Persimmon

## 题目描述

Alice 和 Bob 买了一个大柿子，把它切成了 $n$ 块，每块的大小分别为 $w_1, \dots, w_n$，他们立刻开始吃起来。两个孩子会**同时**吃柿子，每个人的吃法如下：

每当某人吃完上一块（或刚开始时），他就会选择下一块开始吃。如果某块的大小为 $w$，那么吃掉它需要恰好 $w$ 秒，吃完后就可以选择新的一块。若两人同时吃完（或刚开始），则 Alice 先选第一块，但两人会同时开始吃。选择新的一块不需要时间。

由于 Alice 和 Bob 都是完美主义者，每次选块时，他们都只会从剩下的所有块中选**最小的**或**最大的**（即 $w_i$ 最小或最大的）。

吃的过程会一直持续到最后一人吃完且没有剩下的块为止。

Alice 和 Bob 都希望自己吃到的总量尽量多。请你求出，如果两人都采取最优策略，Alice 吃到的柿子总量和 Bob 吃到的柿子总量分别是多少。

## 说明/提示

### 说明

在第一个样例中，Alice 应该先选一块大小为 $1$ 的柿子，然后 Bob 也选一块大小为 $1$ 的柿子。一秒后，Alice 选 $3$，Bob 选 $6$。三秒后，Alice 选 $4$。又三秒后，Bob 吃完，Alice 再过一秒吃完。此时，Alice 吃的总量为 $1+3+4=8$，Bob 吃的总量为 $1+6=7$。

在第三个样例中，Alice 先选 $1$，Bob 选 $7$。一秒后，Alice 选 $9$，再过 $6$ 秒，Bob 选 $7$。

### 计分方式

本题共四组测试。只有通过该组及其所有依赖组全部测试，才能获得该组分数。部分组不要求通过样例测试。**Offline-evaluation** 表示该组结果仅在赛后可见。


| 子任务 | 分数 | 额外约束 | <|子任务依赖 | 特殊性质 |
|:-----:|:------:|:----------------------:|:--:|:---------------:|:-------:|
|       |        | $n$ | $w_i$ | | |
| 0 | 0 | -- | -- | -- | 样例 |
| 1 | 10 | $n = 3$ | -- | -- | -- |
| 2 | 12 | -- | $w_i \le 2$ | -- | -- |
| 3 | 19 | $n \le 200$ | $w_i \le 500$ | 0 | -- |
| 4 | 15 | $n \le 500$ | $W \le 5000$ | -- | 对于 $1 \le i \le n - 1$，有 $w_{i+1} \le 2 \cdot w_i$ |
| 5 | 13 | -- | -- | 2, 4 |对于 $1 \le i \le n - 1$，有 $w_{i+1} \le 2 \cdot w_i$  |
| 6 | 31 | -- | -- | 0 -- 5 | **Offline-evaluation.** |

翻译由 ChatGPT-4.1 完成。

## 样例 #1

### 输入

```
5
1 1 3 4 6```

### 输出

```
8 7```

## 样例 #2

### 输入

```
4
1 1 2 2```

### 输出

```
3 3```

## 样例 #3

### 输入

```
4
1 7 7 9```

### 输出

```
10 14
```

# 题解

## 作者：chen_zhe (赞：0)

**这是官方题解的 AI 中文翻译。**

首先，我们注意到两个有用的事实：
- 最大化所取元素之和，等价于最大化你与对手所取元素之差。
- 只要桌上还剩至少一块，两个人已经吃掉的总量总是相同，因此此时双方的差值为 $0$。

为了解决本题，我们可以采用 $O(n^2 \cdot \max\limits_i(w_i))$ 的动态规划：

设 $dp[l][r][dif]$ 表示当前在区间 $[l, r]$ 上进行游戏，且当前你比对手晚 $dif$ 秒开始吃（$dif$ 可以为负），此时你与对手所取总量的差值。

动态规划的初始状态为：$dp[i][i-1][dif] = 0$，最终答案为 $dp[0][n-1][0]$。

$dif$ 的正负决定了当前由谁来选择先取哪一块。转移方式如下：

- 当 $dif \leq 0$ 时：
 $$dp[l][r][dif] = \max \left\{dp[l + 1][r][dif + w[l]] + w[l],\ dp[l][r - 1][dif + w[r]] + w[r]\right\}$$

- 当 $dif > 0$ 时：
 $$dp[l][r][dif] = \min \left\{dp[l + 1][r][dif - w[l]] - w[l],\ dp[l][r - 1][dif - w[r]] - w[r] \right\}$$

在这个动态规划中，$|dif| \leq \max\limits_i(w_i)$，因此状态总数为 $O(n^2 \cdot \max\limits_i(w_i))$，每个状态有两种转移。

对于满足 $w_{i+1} \leq 2 \cdot w_i$ 的子任务，我们证明如下性质：在这样的限制下，对于任意可达状态 $(l, r, dif)$，都有 $|dif| \leq w_{r+1}$（特例：若 $r = n - 1$，则 $|dif| \leq w_{n-2}$）。

证明思路如下：在任意一次转移中，$dif$ 总是向 $0$ 靠近，因此其绝对值要么减少，要么不会超过最后取走的那块 $w_i$。因此，对于 $[l, r] \to [l+1, r]$ 的转移，关系始终成立；对于 $[l, r] \to [l, r-1]$ 的转移，由于 $w_{r+1} \leq 2 \cdot w_r$，关系同样成立。

由此可知，对于每个 $l$，可达的 $(r, dif)$ 对不超过 $O(\sum\limits_{i=0}^{n-1} w_i) = O(W)$，总状态数为 $O(n \cdot W)$，每个状态仍有两种转移。

接下来，为了解决完整问题，我们需要调整动态规划的转移方式，使其始终满足 $|dif| \leq w_{r+1}$。

具体来说，如果某个人在轮到对手之前连续取了多块，他总可以先取小的再取大的。因此，我们保留 $[l, r] \to [l+1, r]$ 的转移（该转移保持不变量），而对于 $[l, r] \to [l, r-1]$，我们用 $[l, r, dif] \to [l, r', dif']$ 替代，表示当前玩家连续取最大的若干块，直到轮到对手或游戏结束。

这些转移同样保证 $|dif| \leq w_{r+1}$，因此总状态数为 $O(n \cdot W)$，每个状态有两种转移。

还需注意，$r'$ 的取值仅与 $r$ 和 $dif$ 有关，与 $l$ 无关，因此可以在 $O(W \cdot \log n)$ 的时间内预处理。

最终算法的总复杂度为 $O(n \cdot W)$，足以通过所有测试点。

---


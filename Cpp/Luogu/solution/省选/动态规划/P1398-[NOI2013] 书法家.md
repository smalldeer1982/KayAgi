# [NOI2013] 书法家

## 题目描述

小 E 同学非常喜欢书法，他听说 NOI2013 已经开始了，想题一幅 “NOI” 的字送给大家。

小 E 有一张非常神奇的纸，纸可以用一个 $n$ 行 $m$ 列的二维方格矩阵来表示，为了描述方便，我们定义矩阵左下角方格坐标为 $(1,1)$，右上角方格坐标为 $(m, n)$。

矩阵的每个方格有一个整数的幸运值。在格子上面写字可以增加大家的幸运度，幸运度的大小恰好是所有被笔写到的方格的幸运值之和。现在你要在上面写
上 `N`，`O`，`I` 三个字母。

下面给出 $3$ 个书法字的定义:
- `N` 由若干（$\ge 3$）个边平行于坐标轴的矩形组成，设由 $K$ 个矩形组成（标号 $1 \ldots K$），第 $i$ 个矩形的左下角方格坐标设为 $(L_i, B_i)$，右上角坐标设为 $(R_i, T_i )$，要求满足：
  1. $L_i \le R_i, B_i \le T_i$；
  2. 对任意 $1 < i \le K$，有 $L_i = R_{i-1} + 1$；
  3. 对任意 $3 \le i < K$，有 $B_{i−1} − 1 \le T_i \le T_{i-1}$，$B_i \le B_{i-1}$；
  4. $B_2 > B_1$，$T_2 = T_1$，$B_{K-1} = B_K$，$T_{K-1} < T_K$；
- `O` 由一个大矩形 $A$，挖去一个小矩形 $B$ 得到，这两个矩形的边都平行于坐标轴。设大矩形 $A$ 左下角的方格坐标为 $(u, v)$，长为 $W$，宽为 $H$，则小矩形 $B$ 满足左下角方格坐标为 $(u + 1, v + 1)$，长 $W - 2$，宽 $H - 2$。要求满足：
  1. $W \ge 3$，$H \ge 3$；
  2. $u > R_K + 1$；
- `I` 为 $3$ 个边平行于坐标轴的从下到上的实心矩形组成，从下到上依次标号为 $1,2,3$，第 $i$ 个矩形的左下角格子坐标设为 $(P_i , Q_i )$，右上角格子坐标设为 $(G_i , H_i )$，要求满足：
  1. $P_i \le G_i , Q_i \le H_i$；
  2. $P_1 = P_3 > u + W$，$G_1 = G_3$；
  3. $Q_1 = H_1 = Q_2 - 1, H_2 + 1 = Q_3 = H_3$；
  4. $P_1 < P_2 \le G_2 < G_1$。

下图是一个 `N`,`O`,`I` 的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/g7t4tquv.png)

另外，所有画的图形均不允许超过纸张的边界。现在小 E 想要知道,他能画出的最大幸运度是多少。

## 说明/提示

### 样例解释 1

![](https://cdn.luogu.com.cn/upload/image_hosting/vq7asar5.png)

### 样例解释 2

![](https://cdn.luogu.com.cn/upload/image_hosting/1ojygumc.png)

### 数据范围

| 测试点编号 |   $n$   |   $m$    | 幸运值范围 |
| :--------: | :------: | :------: | :--------: |
|     1      |   $=3$   |  $=12$   | $[-50,50]$ |
|     2      |   $=3$   |  $=12$   | $[-50,50]$ |
|     3      |   $=3$   |  $=12$   | $[-50,50]$ |
|     4      |   $=3$   |  $=12$   | $[-50,50]$ |
|     5      | $\le10$  | $\le20$  | $[-50,50]$ |
|     6      | $\le10$  | $\le20$  | $[-50,50]$ |
|     7      | $\le10$  | $\le20$  | $[-50,50]$ |
|     8      | $\le10$  | $\le20$  | $[-50,50]$ |
|     9      | $\le150$ | $\le500$ |    $=1$    |
|     10     | $\le150$ | $\le500$ |    $=1$    |
|     11     | $\le80$  | $\le80$  |    $[-200,200]$    |
|     12     | $\le80$  | $\le80$  |    $[-200,200]$    |
|     13     | $\le80$  | $\le80$  |    $[-200,200]$    |
|     14     | $\le80$  | $\le80$  |    $[-200,200]$    |
|     15     | $\le150$  | $\le500$  |    $[-200,200]$    |
|     16     | $\le150$  | $\le500$  |    $[-200,200]$    |
|     17     | $\le150$  | $\le500$  |    $[-200,200]$    |
|     18     | $\le150$  | $\le500$  |    $[-200,200]$    |
|     19     | $\le150$  | $\le500$  |    $[-200,200]$    |
|     20     | $\le150$  | $\le500$  |    $[-200,200]$    |

对于所有的测试数据，保证 $n \ge 3,m \ge 12$。

## 样例 #1

### 输入

```
3 13 
1 1 -1 -1 1 -1 1 1 1 -1 1 1 1 
1 -1 1 -1 1 -1 1 -1 1 -1 -1 1 -1 
1 -1 -1 1 1 -1 1 1 1 -1 1 1 1 
```

### 输出

```
24```

## 样例 #2

### 输入

```
3 13
-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1

```

### 输出

```
-20```

# 题解

## 作者：SimonGreenall (赞：23)

这是一道DP题（不要问我为什么），我们应该如何考虑呢？

根据房学长的原话讲：

此题属于根据数据范围猜做法系列

首先感受一下题意，像个DP

然后观察数据范围，感觉因该是个三次方的DP

然后发现n比m小不少，应该是O(n^2 \* m)的。。。

（此处省略一万句吐槽）

言归正传，观察一下这个题的图：


然后我们可以发现一个非常奇妙的性质，


我们可以把这个图分成十一部分，按列枚举，可以发现，第十一部分可以由第十部分转移而来，也可以由自己转移而来（因为第十一部分的长度不限），第十部分同理，其他同理，注意第七部分只能由第六部分转移而来（第七部分只能有一列），第五部分只能由第四部分转移而来（同理），这样我们就可以尝试写DP了：

用fi表示第i块，枚举列进行转移，大概有以下转移：

empty->1,1->1,1->2,2->2,2->3,3->3,3->4,4->4,4->5,5->6,6->6,6->7,7->8,8->8,8->9,9

->9,9->10,10->10,10->11,11->11,11

最后还是房学长的话：大力DP就好啦！

附上代码：


    
```cpp
#include <iostream>    
#include <cstdio>    
#include <cstring>    
#define clear(x) memset(x,-63,sizeof(x))    
using namespace std;    
const int maxn=155;    
const int maxm=505;    
int n,m,f4,f8,ans,INF;    
int a[maxm][maxn],s[maxn];    
```
int f1[maxn][maxn],f2[maxn][maxn],f3[maxn][maxn],
f5[maxn][maxn],f6[maxn][maxn],f7[maxn][maxn],

f9[maxn][maxn],f10[maxn][maxn],f11[maxn][maxn],

    
    

```cpp
    s1[maxn][maxn],s2[maxn][maxn];    
inline int read(void){    
    int x=0,f=1; char ch=getchar();    
    for(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') f=-1;    
    for(;ch>='0'&&ch<='9';x=(x<<3)+(x<<1)+(ch^48),ch=getchar());    
    return x*f;     
}    
int main(int argc, char const *argv[]){    
    //初始化    
    n=read(),m=read();    
    for(int i=1;i<=n;i++)    
        for(int j=1;j<=m;j++)    
            a[j][n-i+1]=read();    
    clear(f1); clear(f2); clear(f3); clear(f5);    
    clear(f6); clear(f7); clear(f9); clear(f10);    
    clear(f11); clear(s1); clear(s2);    
    INF=-f1[0][0]; f4=f8=ans=-INF;    
    //DP    
    for(int j=1;j<=m;j++){    
        //前缀和    
        for(int i=1;i<=n;i++) s[i]=s[i-1]+a[j][i];    
        //第十一部分    
        for(int l=1;l<=n;l++)    
            for(int r=l+2;r<=n;r++)    
                ans=max(ans,f11[l][r]=max(f11[l][r],f10[l][r])+a[j][l]+a[j][r]);    
        //第十部分    
        for(int l=1;l<=n;l++)    
            for(int r=l+2;r<=n;r++)    
                f10[l][r]=max(f10[l][r],f9[l][r])+s[r]-s[l-1];    
        //第九部分    
        for(int l=1;l<=n;l++)    
            for(int r=l+2;r<=n;r++)    
                f9[l][r]=max(f9[l][r],f8)+a[j][l]+a[j][r];    
        //第八部分    
        for(int l=1;l<=n;l++)    
            for(int r=l+2;r<=n;r++)    
                f8=max(f8,f7[l][r]);    
        //第七部分    
        for(int l=1;l<=n;l++)    
            for(int r=l+2;r<=n;r++)    
                f7[l][r]=f6[l][r]+s[r]-s[l-1];    
        //第六部分    
        for(int l=1;l<=n;l++)    
            for(int r=l+2;r<=n;r++)    
                f6[l][r]=max(f6[l][r],f5[l][r])+a[j][l]+a[j][r];    
        //第五部分    
        for(int l=1;l<=n;l++)    
            for(int r=l+2;r<=n;r++)    
                f5[l][r]=f4+s[r]-s[l-1];    
        //第四部分    
        for(int l=1;l<=n;l++)    
            for(int r=l+1;r<=n;r++)    
                f4=max(f4,f3[l][r]);    
        //这里有点不一样，自行体会    
        for(int l=1;l<=n;l++){    
            int tmp=-INF;    
            for(int r=l+1;r<=n;r++)    
                tmp=max(tmp,f2[l][r-1]),f3[l][r]=max(f3[l][r],tmp)+s[r]-s[l-1];    
        }    
        //同理,但要反过来处理    
        for(int r=1;r<=n;r++){    
            int tmp=s2[r+1][r];    
            for(int l=r;l;l--)    
                tmp=max(tmp,s2[l][r]),f2[l][r]=max(s1[l-1][r],tmp)+s[r]-s[l-1];    
        }    
        //第一部分    
        for(int l=1;l<=n;l++)    
            for(int r=l;r<=n;r++)    
                f1[l][r]=max(0,f1[l][r])+s[r]-s[l-1];    
        //处理前缀和    
        for(int l=1;l<=n;l++)    
            for(int r=n;r;r--)    
                s2[l][r]=max(f2[l][r],s2[l][r+1]);    
        for(int r=1;r<=n;r++)    
            for(int l=1;l<=n;l++)    
                s1[l][r]=max(f1[l][r],s1[l-1][r]);    
    }    
    cout<<ans<<endl;    
    return 0;    
}    

```

---

## 作者：myee (赞：11)

### Update

于 2024.1.11 修改了这篇题解的代码。

---
### 思路

什么毒瘤细节题。

考虑如何解决。

考虑对这些条件做出进一步的**抽象**。

于是我们做出细致的观察。

方便起见，我们横、纵坐标自左往右、自上往下标号。

---
#### 字母之间的关系

`O` 的条件 $2$ 与 `I` 的条件 $2$ 指出，`N`，`O` 之间有至少一个空列，`O`，`I` 之间有至少一个空列，三个字母是依次排布的。

而且这些限制关系都是在横坐标上的，纵坐标上不做限制。

这启示我们只用算出**前缀若干列的最优 `N`、中间若干列的最优 `O`、后缀若干列的最优 `I`**，即可算出答案。

于是考虑对三者分别进行动态规划，最后合并答案。

**（注意：事实证明这是一条错误的道路，但对后面的正解富有启发意义，且推导也是类似的）**

方便起见，我们设 $(c,r)$ 元素幸运值为 $w(r,c)$。

---
#### 字母 `N` 的部分

先不管第一个、最后一个矩形，中间的矩形必然形如滑动窗口的形式，并且依次相接。

注意到拼接时，中间的矩形宽度（即横坐标跨度）若 $>1$，则可以拆成若干个宽度 $=1$ 的矩形，则条件依旧成立。因此我们只用考虑中间矩形宽度均为 $1$ 的情况。

然后考虑第一个矩形、最后一个矩形。我们不妨把他们也拆成上下端点保持不变的若干宽度为 $1$ 的矩形。

我们称第一个矩形是第一类，中间的矩形是第二类，最后的矩形是第三类。

设计 dp 状态 $f(col,l,r,op)$，其中 $col\in[1,m],1\le l\le r\le n,op\in\{1,2,3\}$，表示当前考虑到第几列、目前矩形在当前列上上下端点、当前矩形种类都已确定的情况下，目前前缀矩形最大可行权。

考虑转移。

$$f(col,l,r,1)=\max\{f(col-1,l,r,1),0\}+\sum_{y=l}^rw(y,col)$$

$$f(col,l,r,2)=\max\{\max\{f(col-1,l,y,1)|y>r\},\max\{f(col-1,y_1,y_2,2)|y_1\le l,l-1\le y_2\le r\}\}+\sum_{y=l}^rw(y,col)$$

$$f(col,l,r,3)=\max\{\max\{f(col-1,y,r,2)|l<y\le r\},f(col-1,l,r,3)\}+\sum_{y=l}^rw(y,col)$$

然后直接做就好了。

这个东西可以通过简单的转移顺序与前后缀和做到复杂度与状态数同阶。

---
#### 字母 `I` 的部分

~~对，先跳过 `O`。~~

主要是 `O` 的左右端点都要枚举，因此我们放在后面考虑。

`I` 是上下对齐的，考虑怎么做。

……

感觉好像不好做啊。

但是我们有 $Q_1=H_1,Q_3=Q_3$，即最上面、最下面的矩形高度都为 $1$。

我们试图重新考虑，把 `I` 视作**一个整体**，从右往左扫描。

我们发现，问题被分为三个“阶段”。

阶段 $1$：仅最上、最下格子被填充。

阶段 $2$：整段区间被填充。

阶段 $3$：仅最上、最下格子被填充。

设计 dp 状态 $g(col,l,r,op)$，表示当前考虑到第几列、`I` 的上下端点、当前阶段种类都已确定的情况下，目前后缀状态最大可行权。

考虑转移。

$$g(col,l,r,1)=\max\{g(col+1,l,r,1),0\}+w(l,col)+w(r,col)$$

$$g(col,l,r,2)=\max\{g(col+1,l,r,1),g(col+1,l,r,2)\}+\sum_{y=l}^rw(y,col)$$

$$g(col,l,r,3)=\max\{g(col+1,l,r,2),g(col+1,l,r,3)\}+w(l,col)+w(r,col)$$

然后直接做就好了。

---
#### 字母 `O` 的部分

这个左右端点枚举似乎无法避免，考虑怎么优化。

似乎没法优化。

因为枚举端点已经带来了 $\Theta(m^2)$ 级别的枚举了，无法承受甚至再来一个 $n$。

我们发现这个东西，如果硬枚举左右端点，然后按类似 `I` 的方式确定三个阶段 dp 的话，复杂度是 $O(m^2n^2)$ 的。

**换言之，我们的做法，在时间复杂度上假了！**

---
#### 重新合并三个字母 `NOI`

考虑挽救刚刚的做法。

不能分开处理，主要是因为 `O` 要枚举两个端点啊。

那么唯一的方法，就是**联合处理**了。

设 $f(col,l,r,op)$ 定义同上，我们考虑如何继续维护 `O`。

设 $h(col,l,r,op)$ 表示已经考虑了 `N`，当前考虑到第几列、`O` 的上下端点、当前阶段种类都已确定的情况下，目前前缀状态的最大可行权。

重新设 $g(col,l,r,op)$ 表示已经考虑了 `N` 与 `O`，当前考虑到第几列、`I` 的上下端点、当前阶段种类都已确定的情况下，目前前缀状态最大可行权。

考虑转移。

我们列出如下 $9$ 个转移方程。

$$f(col,l,r,1)=\max\{f(col-1,l,r,1),0\}+\sum_{y=l}^rw(y,col)$$

$$f(col,l,r,2)=\max\{\max\{f(col-1,l,y,1)|y>r\},\max\{f(col-1,y_1,y_2,2)|y_1\le l,l-1\le y_2\le r\}\}+\sum_{y=l}^rw(y,col)$$

$$f(col,l,r,3)=\max\{\max\{f(col-1,y,r,2)|l<y\le r\},f(col-1,l,r,3)\}+\sum_{y=l}^rw(y,col)$$

$$h(col,l,r,1)=\max\{f(c,y_1,y_2,3)|c\le col-2,y_1<y_2\}+\sum_{y=l}^rw(y,col)$$

$$h(col,l,r,2)=\max\{h(col-1,l,r,1),h(col-1,l,r,2)\}+w(l,col)+w(r,col)$$

$$h(col,l,r,3)=h(col-1,l,r,2)+\sum_{y=l}^rw(y,col)$$

$$g(col,l,r,1)=\max\{\max\{h(c,y_1,y_2,3)|c\le col-2,y_1<y_2\},g(col-1,l,r,1)\}+w(l,col)+w(r,col)$$

$$g(col,l,r,2)=\max\{g(col-1,l,r,1),g(col-1,l,r,2)\}+\sum_{y=l}^rw(y,col)$$

$$g(col,l,r,3)=\max\{g(col-1,l,r,2),g(col-1,l,r,3)\}+w(l,col)+w(r,col)$$

然后最大的 $g(col,l,r,3)$ 就是答案。

---
#### 如何 $O(1)$ 转移

状态数是 $\Theta(n^2m)$ 的，我们需要的复杂度也只能是这个级别，但并不方便直接解决这一点。

显然，这个东西的转移如何做到 $O(1)$ 并不是显然的。

我们先确认以下事实：$\max$ 旁边所加的项均为 $\sum_{y=l}^rw(y,col)$ 或 $w(l,col)+w(r,col)$。

于是设 $A(col,l,r)=\sum_{y=l}^rw(y,col),B(col,l,r)=w(l,col)+w(r,col)$。

$A,B$ 容易在 $\Theta(n^2m)$ 的时间内预处理完。

而之前的 dp 状态，其拓扑序显然。

接下来，我们依次处理每部分如何做到 $O(1)$ 转移。

---
$$f(col,l,r,1)=\max\{f(col-1,l,r,1),0\}+A(col,l,r)$$

直接按 $col$ 升序转移即可。

---
$$f(col,l,r,2)=\max\{\max\{f(col-1,l,y,1)|y>r\},\max\{f(col-1,y_1,y_2,2)|y_1\le l,l-1\le y_2\le r\}\}+A(col,l,r)$$

设 $p(col,l,r)=\max\{f(col,l,y,1)|y>r\}$，则 $p(col,l,r)=\max\{p(col,l,r+1),f(col,l,r+1,1)\}$，边界稍微特判一下。

则

$$f(col,l,r,2)=\max\{p(col-1,l,r),\max\{f(col-1,y_1,y_2,2)|y_1\le l,l-1\le y_2\le r\}\}+A(col,l,r)$$

设 $q(col,l,r)=\max\{f(col,y_1,y_2,2)|y_1\le l,l-1\le y_2\le r\}$。

则 $q(col,l,r)=\max\{\max\{f(col,y,r,2)|y\le l\},q(col,l,r-1)\}$，边界要特殊处理。

设 $d(col,l,r)=\max\{f(col,y,r,2)|y\le l\}$。

则 $d(col,l,r)=\max\{f(col,l,r,2),d(col,l-1,r)\}$，边界要特殊处理。

则 $q(col,l,r)=\max\{d(col,l,r),q(col,l,r-1)\}$。

则

$$f(col,l,r,2)=\max\{p(col-1,l,r),q(col-1,l,r)\}+A(col,l,r)$$

直接按 $col$ 升序转移即可。

---
$$f(col,l,r,3)=\max\{\max\{f(col-1,y,r,2)|l<y\le r\},f(col-1,l,r,3)\}+A(col,l,r)$$

设 $p(col,l,r)=\max\{f(col,y,r,2)|l<y\le r\}$。

则 $p(col,l,r)=\max\{f(col,l+1,r,2),p(col,l+1,r)\}$，边界要特殊处理。

$$f(col,l,r,3)=\max\{p(col-1,l,r),f(col-1,l,r,3)\}+A(col,l,r)$$

直接按 $col$ 升序转移即可。

---
$$h(col,l,r,1)=\max\{f(c,y_1,y_2,3)|c\le col-2,y_1<y_2\}+A(col,l,r)$$

设 $p(col)=\max\{f(c,y_1,y_2,3)|c<col,y_1<y_2\}$。

则 $p(col)=\max\{p(col-1),\max\{f(col-1,y_1,y_2,3)|y_1<y_2\}\}$，这个直接暴力合并即可。

$$h(col,l,r,1)=p(col-1)+A(col,l,r)$$

直接按 $col$ 升序转移即可。

---
$$h(col,l,r,2)=\max\{h(col-1,l,r,1),h(col-1,l,r,2)\}+B(col,l,r)$$

直接按 $col$ 升序转移即可。

---
$$h(col,l,r,3)=h(col-1,l,r,2)+A(col,l,r)$$

直接按 $col$ 升序转移即可。

---
$$g(col,l,r,1)=\max\{\max\{h(c,y_1,y_2,3)|c\le col-2,y_1<y_2\},g(col-1,l,r,1)\}+B(col,l,r)$$

设 $p(col)=\max\{h(c,y_1,y_2,3)|c<col,y_1<y_2\}$。

则 $p(col)=\max\{p(col-1),\max\{h(col-1,y_1,y_2,3)|y_1<y_2\}\}$，这个直接暴力合并即可。

$$g(col,l,r,1)=\max\{p(col-1),g(col-1,l,r,1)\}+B(col,l,r)$$

直接按 $col$ 升序转移即可。

---
$$g(col,l,r,2)=\max\{g(col-1,l,r,1),g(col-1,l,r,2)\}+A(col,l,r)$$

直接按 $col$ 升序转移即可。

---
$$g(col,l,r,3)=\max\{g(col-1,l,r,2),g(col-1,l,r,3)\}+B(col,l,r)$$

直接按 $col$ 升序转移即可。

---
### Code

按刚刚说的，硬写，然后就完了。

NOI2013D2T2 果然是绝世\*\*题。

然后这题还卡空间，记得滚动数组。

以下是核心代码。

```cpp
typedef long long llt;
typedef unsigned uint;typedef unsigned long long ullt;
typedef bool bol;typedef char chr;typedef void voi;
typedef double dbl;
template<typename T>bol _max(T&a,T b){return(a<b)?a=b,true:false;}
template<typename T>bol _min(T&a,T b){return(b<a)?a=b,true:false;}
template<typename T>T lowbit(T n){return n&-n;}
template<typename T>T gcd(T a,T b){return b?gcd(b,a%b):a;}
template<typename T>T lcm(T a,T b){return(a!=0||b!=0)?a/gcd(a,b)*b:(T)0;}
template<typename T>T exgcd(T a,T b,T&x,T&y){if(b!=0){T ans=exgcd(b,a%b,y,x);y-=a/b*x;return ans;}else return y=0,x=1,a;}
template<typename T>T power(T base,T index,T mod)
{
    T ans=1%mod;
    while(index)
    {
        if(index&1)ans=ans*base%mod;
        base=base*base%mod,index>>=1;
    }
    return ans;
}
const int inf=1e8;
int W[155][505],A[155][155],B[155][155],F[155][155][4],G[155][155][4],H[155][155][4];
voi solve()
{
    uint n,m;scanf("%u%u",&n,&m);
    for(uint i=1;i<=n;i++)for(uint j=1;j<=m;j++)scanf("%d",W[i]+j);
    for(uint i=0;i<=n+1;i++)for(uint j=0;j<=n+1;j++)for(uint op=1;op<=3;op++)F[i][j][op]=-inf;
    for(uint i=0;i<=n+1;i++)for(uint j=0;j<=n+1;j++)for(uint op=1;op<=3;op++)H[i][j][op]=-inf;
    for(uint i=0;i<=n+1;i++)for(uint j=0;j<=n+1;j++)for(uint op=1;op<=3;op++)G[i][j][op]=-inf;
    int ans=-inf;
    for(uint col=1;col<=m;col++){
        static int NO=-inf,OI=-inf,User[155][155];
#define W(c,r) W[r][c]
#define A(l,r) A[l][r]
#define B(l,r) B[l][r]
#define F(l,r,op) F[l][r][op]
#define H(l,r,op) H[l][r][op]
#define G(l,r,op) G[l][r][op]
#define p(l,r) User[l][r]
        for(uint l=1;l<=n;l++)for(uint r=l;r<=n;r++)A(l,r)=A(l,r-1)+W(col,r),B(l,r)=W(col,l)+W(col,r);
        for(uint l=1;l<=n;l++)for(uint r=l+2;r<=n;r++)_max(G(l,r,3),G(l,r,2)),_max(ans,G(l,r,3)+=B(l,r));
        for(uint l=1;l<=n;l++)for(uint r=l+2;r<=n;r++)_max(G(l,r,2),G(l,r,1)),G(l,r,2)+=A(l,r);
        for(uint l=1;l<=n;l++)for(uint r=l+2;r<=n;r++)_max(G(l,r,1),OI),G(l,r,1)+=B(l,r);
        for(uint l=1;l<=n;l++)for(uint r=l+2;r<=n;r++)_max(OI,H(l,r,3)),H(l,r,3)=H(l,r,2)+A(l,r);
        for(uint l=1;l<=n;l++)for(uint r=l+2;r<=n;r++)_max(H(l,r,2),H(l,r,1)),H(l,r,2)+=B(l,r);
        for(uint l=1;l<=n;l++)for(uint r=l+2;r<=n;r++)H(l,r,1)=NO+A(l,r);
        for(uint l=1;l<=n;l++)for(uint r=l+1;r<=n;r++)_max(NO,F(l,r,3));
        for(uint l=0;l<=n+1;l++)for(uint r=0;r<=n+1;r++)p(l,r)=-inf;
        for(uint l=n;l;l--)for(uint r=l+1;r<=n;r++)p(l,r)=std::max(p(l+1,r),F(l+1,r,2));
        for(uint l=1;l<=n;l++)for(uint r=l+1;r<=n;r++)_max(F(l,r,3),p(l,r)),F(l,r,3)+=A(l,r);
        for(uint l=0;l<=n+1;l++)for(uint r=0;r<=n+1;r++)p(l,r)=-inf;
        for(uint l=1;l<=n;l++)for(uint r=l-1;r<=n;r++)p(l,r)=std::max(p(l-1,r),F(l,r,2));
        for(uint l=1;l<=n;l++)for(uint r=l;r<=n;r++)_max(p(l,r),p(l,r-1));
        for(uint l=1;l<=n;l++)for(uint r=l;r<=n;r++)F(l,r,2)=p(l,r);
        for(uint l=0;l<=n+1;l++)for(uint r=0;r<=n+1;r++)p(l,r)=-inf;
        for(uint l=1;l<=n;l++)for(uint r=n;r>=l;r--)p(l,r)=std::max(p(l,r+1),F(l,r+1,1));
        for(uint l=1;l<=n;l++)for(uint r=l;r<=n;r++)_max(F(l,r,2),p(l,r)),F(l,r,2)+=A(l,r);
        for(uint l=1;l<=n;l++)for(uint r=l+1;r<=n;r++)_max(F(l,r,1),0),F(l,r,1)+=A(l,r);
#undef p
#undef G
#undef H
#undef F
#undef B
#undef A
#undef W
    }
    printf("%d\n",ans);
}
```


---

## 作者：不存在之人 (赞：9)

很自然地分成9个部分进行动态规划，即把NOI3个字母，每个字母分别从左到右分为3部分，然后逐列进行转移。 

除了N的第二部分其余的都很好转移，具体怎么转移的呢？其实也就是按照他的规则进行模拟，看代码就能理解了。
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
#define MAXN 150
#define MAXM 500
#define INF 0x3fffffff
int a[MAXN+10][MAXM+10],n,m,blk[MAXM+10][2],f[2][10][MAXN+10][MAXN+10],s[MAXN+10][MAXM+10],tmp[MAXN+10][MAXN+10],ans=-INF;
void Read(int &x){
    static char c;
    bool f(0);
    while(c=getchar(),c!=EOF){
        if(c=='-')
            f=1;
        else if(c>='0'&&c<='9'){
            x=c-'0';
            while(c=getchar(),c>='0'&&c<='9')
                x=x*10+c-'0';
            ungetc(c,stdin);
            if(f)
                x=-x;
            return;
        }
    }
}
void read(){
    Read(n),Read(m);
    int i,j;
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++){
            Read(a[i][j]);
            s[i][j]=s[i-1][j]+a[i][j];
        }
}
void dp(){
    int i,j,k;
    memset(f[1],0xb0,sizeof f[1]);
    for(i=1;i<=n;i++)
        for(j=i;j<=n;j++)
            f[1][1][i][j]=s[j][1]-s[i-1][1];
    blk[1][0]=blk[1][1]=-INF;
    for(k=2;k<=m;k++){
        memset(f[k&1],0xb0,sizeof f[k&1]);
        //N的第一部分
        for(i=1;i<=n;i++)
            for(j=i;j<=n;j++)
                f[k&1][1][i][j]=max(s[j][k]-s[i-1][k],f[(k&1)^1][1][i][j]+s[j][k]-s[i-1][k]);
        //N的第二部分
        for(i=1;i<=n;i++){
            tmp[i][n+1]=-INF;
            for(j=n;j>=i;j--)
                tmp[i][j]=max(tmp[i][j+1],f[(k&1)^1][1][i][j]);
            }
        for(i=1;i<=n;i++)
            for(j=i;j<=n;j++){
                f[k&1][2][i][j]=max(f[k&1][2][i][j],tmp[i][j+1]+s[j][k]-s[i-1][k]);
                tmp[i][j]=-INF;
            }
        for(i=1;i<=n;i++)
            for(j=i;j<=n;j++)
                tmp[j+1][j+1]=max(tmp[j+1][j+1],f[(k&1)^1][2][i][j]);
        for(i=1;i<=n;i++)
            for(j=i+1;j<=n;j++)
                tmp[i][j]=max(tmp[i][j],tmp[i][j-1]);
        for(i=1;i<=n;i++)
            for(j=i;j<=n;j++)
                f[k&1][2][i][j]=max(f[k&1][2][i][j],tmp[i][j]+s[j][k]-s[i-1][k]);
        for(i=1;i<=n;i++)
            for(j=i;j<=n;j++)
                tmp[i][j]=f[(k&1)^1][2][i][j];
        for(j=1;j<=n;j++)
            for(i=1;i<j;i++)
                tmp[i+1][j]=max(tmp[i+1][j],tmp[i][j]);
        for(i=1;i<=n;i++)
            for(j=i;j<n;j++)
                tmp[i][j+1]=max(tmp[i][j+1],tmp[i][j]);
        for(i=1;i<=n;i++)
            for(j=i;j<=n;j++)
                f[k&1][2][i][j]=max(f[k&1][2][i][j],tmp[i][j]+s[j][k]-s[i-1][k]);
        //N的第三部分
        for(i=1;i<=n;i++)
            for(j=i;j<=n;j++)
                tmp[i][j]=f[(k&1)^1][2][i][j];
        for(j=1;j<=n;j++)
            for(i=j;i>1;i--)
                tmp[i-1][j]=max(tmp[i-1][j],tmp[i][j]);
        for(i=1;i<=n;i++)
            for(j=i+1;j<=n;j++)
                f[k&1][3][i][j]=max(f[k&1][3][i][j],max(tmp[i+1][j],f[(k&1)^1][3][i][j])+s[j][k]-s[i-1][k]);
        //NO之间空白
        blk[k][0]=blk[k-1][0];
        for(i=1;i<=n;i++)
            for(j=i;j<=n;j++)
                blk[k][0]=max(blk[k][0],f[(k&1)^1][3][i][j]);
        //O的第一部分
        for(i=1;i<=n;i++)
            for(j=i+2;j<=n;j++)
                f[k&1][4][i][j]=blk[k-1][0]+s[j][k]-s[i-1][k];
        //O的第二部分
        for(i=1;i<=n;i++)
            for(j=i+2;j<=n;j++)
                f[k&1][5][i][j]=max(f[(k&1)^1][4][i][j],f[(k&1)^1][5][i][j])+a[i][k]+a[j][k];
        //O的第三部分
        for(i=1;i<=n;i++)
            for(j=i+2;j<=n;j++)
                f[k&1][6][i][j]=f[(k&1)^1][5][i][j]+s[j][k]-s[i-1][k];
        //OI之间空白
        blk[k][1]=blk[k-1][1];
        for(i=1;i<=n;i++)
            for(j=i;j<=n;j++)
                blk[k][1]=max(blk[k][1],f[(k&1)^1][6][i][j]);
        //I的第一部分
        for(i=1;i<=n;i++)
            for(j=i+2;j<=n;j++)
                f[k&1][7][i][j]=max(blk[k-1][1],f[(k&1)^1][7][i][j])+a[i][k]+a[j][k];
        //I的第二部分
        for(i=1;i<=n;i++)
            for(j=i+2;j<=n;j++)
                f[k&1][8][i][j]=max(f[(k&1)^1][7][i][j],f[(k&1)^1][8][i][j])+s[j][k]-s[i-1][k];
        //I的第三部分
        for(i=1;i<=n;i++)
            for(j=i+2;j<=n;j++){
                f[k&1][9][i][j]=max(f[(k&1)^1][8][i][j],f[(k&1)^1][9][i][j])+a[i][k]+a[j][k];
                ans=max(ans,f[k&1][9][i][j]);
            }   
    }
}
int main()
{
    read();
    dp();
    printf("%d\n",ans);
}
```

---

## 作者：littlez_meow (赞：3)

看似是动态规划，实际上是细节多的大模拟。

自己写的怎么调调不出来，对着 [SimonGreenall 的题解](https://www.luogu.com.cn/blog/user25264/solution-p1398)才调出来。

## step 1：状态

首先是最优解问题，又发现后面的行填法不会影响前面，满足无后效性，容易想到动态规划。

再看数据范围的 $m>n$ 而且都不到 $1000$，大概可以判断是一个三维 DP，$m$ 那维可以滚动数组优化掉。

观察三个字母可以发现，组成每个字母的矩形都可以切成宽度为 $1$ 的矩形。如果从左到右扫一遍每列来状态转移，只有 $11$ 种情况，分别为：`N` 的左侧矩形、中间下降的几个矩形、右侧矩形，`N`、`O` 之间空白，`O` 的左侧矩形、中间上下两个矩形、右侧矩形，`O`、`I` 之间空白，`I` 的左侧上下两个矩形矩形、中间矩形、右侧上下两个矩形。

于是，设 $dp(c,l,r,p)$ 表示写到第 $c$ 列、上下边界为 $l,r$、处于情况 $p$ 的最大幸运度，其中 $1\le c\le m,1\le l\le r\le n,0\le p\le 10$。在不同情况，上下边界的定义会有所不同，具体情况具体分析。

以下为了方便，记 $luck(i,j)$ 为 $(i,j)$ 处的幸运值，$s(l,r)=\sum\limits_{i=l}^r{luck(c,i)}$。

$s$ 可以用前缀和实现。

## step 2：转移
下面我们分别讨论每种情况的转移。

### part 0：N 左侧
此时有两种情况，一种是从该列开始写，一种是从上一列再添上一个矩形，带来的收益都是 $s(l,r)$。因此有
$$dp(c,l,r,0)=\max\{dp(c-1,l,r,0),0\}+s(l,r)$$

### part 1：N 中间
这是最难转移的部分。其收益是 $s(l,r)$，分从 part 0 写过来和接着写一列两类。因此

$$dp(c,l,r,1)=\max\{\max\limits_{l'<l}\{dp(c-1,l',r,0)\},\max\limits_{l\le l'\le r\le r'}\{dp(c-1,l',r',1\}\}+s(l,r)$$

然后你会发现，里面的两个 $\max$ 可以利用类似前缀和的方式在该列开始时预处理，注意是否加等于即可。

### part 2：N 右侧
同样可以从上一部分接着和从这一部分继续，有

$$dp(c,l,r,2)=\max\{\max\limits_{r'<r}\{dp(c-1,l,r',1)\},dp(c-1,l,r,2)\}+s(l,r)$$

继续前缀和预处理即可。

### part 3：N、O 空白
既然是空白，后面的取值就不依赖于前面的 $l,r$ 值，而是前几行所有的最大值，$l,r$ 在这里就没有意义了。不如直接把所有值存到一个地方，所以有

$$dp(c,0,0,3)=\max\{\max\limits_{l,r}\{dp(c-1,l,r,2)\},dp(c-1,0,0,3)\}$$

### part 4：O 左侧
请注意，题面中说 `O` 的左侧和右侧为宽度为 $1$ 的矩形。也就是说，该部分只能通过 part 3 加一列转移过来，而不能给本身继续添一列，否则宽度就会达到 $2$ 及以上。所以

$$dp(c,l,r,4)=dp(c-1,0,0,3)+s(l,r)$$

以及题目中说长 $W\ge 3$，故 $r\ge l+2$，下面所有 `O` 的部分也都满足 $r\ge l+2$。

### part 5：O 中间
这里 $l,r$ 的定义就稍微有些变化，不表示一个从 $(c,l)$ 到 $(c,r)$ 的大矩形，而是在这两个位置上有两个长、宽均为 $1$ 的小矩形。所以其贡献为 $luck(c,l)+luck(c,r)$，可以从上部分或本部分转移，有

$$dp(c,l,r,5)=\max\{dp(c-1,l,r,4),dp(c-1,l,r,5)\}+luck(c,l)+luck(c,r)$$

### part 6：O 右侧
和 part 4 一样，由于只有一列，只能从上一部分转移，有

$$dp(c,l,r,6)=dp(c-1,l,r,5)+s(l,r)$$

### part 7：O、I 空白
和 part 3 同理，有

$$dp(c,0,0,7)=\max\{\max\limits_{l,r}\{dp(c-1,l,r,6)\},dp(c-1,0,0,7)\}$$

### part 8：I 左侧
这里 $l,r$ 的定义和 part 5 是一样的，贡献为 $luck(c,l)+luck(c,r)$，所以

$$dp(c,l,r,8)=\max\{dp(c-1,0,0,7),dp(c-1,l,r,8)\}+luck(c,l)+luck(c,r)$$

和 `O` 一样，`I` 部分也满足 $r\ge l+2$。

### part 9：I 中间
$l,r$ 定义回归从 $(c,l)$ 到 $(c,r)$ 的大矩形，即贡献为 $s(l,r)$，有

$$dp(c,l,r,9)=\max\{dp(c-1,l,r,8),dp(c-1,l,r,9\}+s(l,r)$$

### part 10：I 右侧
同 part 8，有

$$dp(c,l,r,10)=\max\{dp(c-1,l,r,9),dp(c-1,l,r,10)\}+luck(c,l)+luck(c,r)$$

## step 3：其他内容
首先是答案。字肯定要写完，又不一定要写到最后一行，所以答案为

$$\max\limits_{c,l,r}\{dp(c,l,r,10)\}$$

其次是内存问题。如果按上面状态开，内存需要 470MB 甚至更多，再加上其他开支肯定吃不消。解决也简单，发现每一列之和上一列有关，可以只存两列用滚动数组。但是，还记得 0/1 背包里的滚动数组吗？通过倒序转移，甚至两列都不用记录。此题也是一样，由于每一部分只会用到先前部分的值，如果我们倒序转移，先从 part 10 开始转移到 part 0，就不会影响答案。

最后是注意一些细节，比如初始值要赋一个绝对值比较大的负数，快读记得写负数的处理，边界值加一减一带不带等号，即可通过此题。

### step 4：附上代码
再次感谢 [SimonGreenall 的题解](https://www.luogu.com.cn/blog/user25264/solution-p1398)，不然我的代码也调不出来。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define F(i,a,b) for(int i(a),i##iend(b);i<=i##iend;++i)
#define R(i,a,b) for(int i(a),i##iend(b);i>=i##iend;--i)
#define _ 0
using namespace std;
const int INF=0x3f3f3f3f;
short n,m,luck[501][151];
int dp[151][151][11],ans=-INF;
inline short input(){
	short x;char ch;bool y(1);
	for(ch=getchar();!isdigit(ch);ch=getchar()) if(ch=='-') y=0;
	for(x=0;isdigit(ch);ch=getchar()) x=x*10+(ch^48);
	return y?x:-x;
}
int main(){
	n=input(),m=input();
	F(i,1,n) F(j,1,m) luck[j][n-i+1]=input();
	memset(dp,-0x3f,sizeof(dp));
	F(i,1,m){
		//前缀和 
		int sum[151]={},maxdp1[151][151],maxdp2[152][152],maxdp;
		memset(maxdp1,-0x3f,sizeof(maxdp1));
		memset(maxdp2,-0x3f,sizeof(maxdp2));
		F(j,1,n) sum[j]=sum[j-1]+luck[i][j];
		//part 10:I右及答案统计 
		F(l,1,n) F(r,l+2,n){
			dp[l][r][10]=max(dp[l][r][10],dp[l][r][9])+luck[i][l]+luck[i][r];
			ans=max(ans,dp[l][r][10]);
		}
		//part 9:I中 
		F(l,1,n) F(r,l+2,n) dp[l][r][9]=max(dp[l][r][9],dp[l][r][8])+sum[r]-sum[l-1];
		//part 8:I左
		F(l,1,n) F(r,l+2,n) dp[l][r][8]=max(dp[l][r][8],dp[0][0][7])+luck[i][l]+luck[i][r];
		//part 7:O,I空白
		F(l,1,n) F(r,l,n) dp[0][0][7]=max(dp[0][0][7],dp[l][r][6]);
		//part 6:O右 
		F(l,1,n) F(r,l+2,n) dp[l][r][6]=dp[l][r][5]+sum[r]-sum[l-1];
		//part 5:O中 
		F(l,1,n) F(r,l+2,n) dp[l][r][5]=max(dp[l][r][5],dp[l][r][4])+luck[i][l]+luck[i][r];
		//part 4:O左 
		F(l,1,n) F(r,l+2,n) dp[l][r][4]=dp[0][0][3]+sum[r]-sum[l-1];
		//part 3:N,O空白 
		F(l,1,n) F(r,l,n) dp[0][0][3]=max(dp[0][0][3],dp[l][r][2]);
		//part 2:N右 
		F(l,1,n){    
			maxdp=-INF;    
			F(r,l+1,n) maxdp=max(maxdp,dp[l][r-1][1]),dp[l][r][2]=max(dp[l][r][2],maxdp)+sum[r]-sum[l-1];    
		}
		//part 1:N中 
		F(r,1,n) F(l,1,n) maxdp1[l][r]=max(dp[l][r][0],maxdp1[l-1][r]);
		F(l,1,n) R(r,n,1) maxdp2[l][r]=max(dp[l][r][1],maxdp2[l][r+1]); 
		F(r,1,n){    
			maxdp=maxdp2[r+1][r];    
			R(l,r,1) maxdp=max(maxdp,maxdp2[l][r]),dp[l][r][1]=max(maxdp1[l-1][r],maxdp)+sum[r]-sum[l-1];    
		}
		//part 0:N左 
		F(l,1,n) F(r,l,n) dp[l][r][0]=max(dp[l][r][0],0)+sum[r]-sum[l-1];
	}
	cout<<ans;
	return ~~(0^_^0);//每日卖萌（1/1）
}
```
完结撒花 qwq

---

## 作者：ainivolAGEM (赞：2)

非常阴间的一道 DP 题，令人窒息的代码量。

## Part 1 : 状态定义

根据本题为最优解问题，且满足无后效性，那极有可能是 DP。然后发现 $N$ 和 $M$ 好像都挺小的不到 $1000$，那应该是三维 DP。滚动数组优化一下空间和时间都是没问题的。

可以发现这个图案可以分成 $11$ 种情况，而且全部都是宽度为 $1$ 矩形，从左到右搜一遍总共就是 $11$ 种情况，~~已经开始头疼了~~，分别是：$N$ 左边和右边的两个矩形，$N$ 中间的一堆矩形，$N$ 和 $O$ 中间的空白部分，$O$ 的上下左右和中间 $5$ 个矩形，$O$ 和 $I$ 中间的空白部分，$I$ 上下和中间的矩形。

所以我们可以定义 $11$ 个 DP， $dp[l][r]$ 为在上界为 $L$ 下界为 $R$ 时的最大幸运度。则数据范围为 $1 \leq l \leq r \leq 150$。

那么 dp 的状态就定义好了。

## Part 2 : 状态转移方程

最麻烦的地方来了，总共 $11$ 种情况，也就是 $11$ 个 DP，所以分类讨论。

基本上所有情况都可以由前面的一种情况和自己转移来的，除了两种：第五种只能由第四种转过来，第七种只能由第六种转过来，因为他俩都只有一列。其他就都可以由前面一种转过来或者自己新开一列了。

那么可以发现，能用前缀和数组优化，所以把每个 dp 的 $l$ 和 $r$ 都枚举一遍求值就可以了，**记得初始化！**

## AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=154;
const int M=504;
ll n,m,dp4,dp8,ans,INF;
ll a[M][N],s[N];
ll dp1[N][N],dp2[N][N],dp3[N][N];
ll dp5[N][N],dp6[N][N],dp7[N][N];
ll dp9[N][N],dp10[N][N],dp11[N][N];
ll s1[N][N],s2[N][N];
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>a[j][n-i+1];
        }
    }
    memset(dp1,-63,sizeof(dp1));
    memset(dp2,-63,sizeof(dp2));
    memset(dp3,-63,sizeof(dp3));
    memset(dp5,-63,sizeof(dp5));
    memset(dp6,-63,sizeof(dp6));
    memset(dp7,-63,sizeof(dp7));
    memset(dp9,-63,sizeof(dp9));
    memset(dp10,-63,sizeof(dp10));
    memset(dp11,-63,sizeof(dp11));
    memset(s1,-63,sizeof(s1));
    memset(s2,-63,sizeof(s2));
    INF=-dp1[0][0];
    dp4=dp8=ans=-INF;
    for(int j=1;j<=m;j++){
        for(int i=1;i<=n;i++){
            s[i]=s[i-1]+a[j][i];
        }
        for(int l=1;l<=n;l++){
            for(int r=l+2;r<=n;r++){
                ans=max(ans,dp11[l][r]=max(dp11[l][r],dp10[l][r])+a[j][l]+a[j][r]);
            }
        }
        for(int l=1;l<=n;l++){
            for(int r=l+2;r<=n;r++){
                dp10[l][r]=max(dp10[l][r],dp9[l][r])+s[r]-s[l-1];
            }
        }
        for(int l=1;l<=n;l++){
            for(int r=l+2;r<=n;r++){
                dp9[l][r]=max(dp9[l][r],dp8)+a[j][l]+a[j][r];
            }
        }
        for(int l=1;l<=n;l++){
            for(int r=l+2;r<=n;r++){
                dp8=max(dp8,dp7[l][r]);
            }
        }
        for(int l=1;l<=n;l++){
            for(int r=l+2;r<=n;r++){
                dp7[l][r]=dp6[l][r]+s[r]-s[l-1];
            }
        }
        for(int l=1;l<=n;l++){
            for(int r=l+2;r<=n;r++){
                dp6[l][r]=max(dp6[l][r],dp5[l][r])+a[j][l]+a[j][r];
            }
        }
        for(int l=1;l<=n;l++){
            for(int r=l+2;r<=n;r++){
                dp5[l][r]=dp4+s[r]-s[l-1];
            }
        }
        for(int l=1;l<=n;l++){
            for(int r=l+1;r<=n;r++){
                dp4=max(dp4,dp3[l][r]);
            }
        }
        for(int l=1;l<=n;l++){
            ll tmp=-INF;
            for(int r=l+1;r<=n;r++){
                tmp=max(tmp,dp2[l][r-1]);
                dp3[l][r]=max(dp3[l][r],tmp)+s[r]-s[l-1];
            }
        }
        for(int r=1;r<=n;r++){
            ll tmp=s2[r+1][r];    
            for(int l=r;l;l--){
                tmp=max(tmp,s2[l][r]);
                dp2[l][r]=max(s1[l-1][r],tmp)+s[r]-s[l-1];
            }
        }  
        for(int l=1;l<=n;l++){
            for(int r=l;r<=n;r++){
                dp1[l][r]=max(0ll,dp1[l][r])+s[r]-s[l-1];
            }
        }
        for(int l=1;l<=n;l++){
            for(int r=n;r;r--){
                s2[l][r]=max(dp2[l][r],s2[l][r+1]);
            }
        }
        for(int r=1;r<=n;r++){
            for(int l=1;l<=n;l++){
                s1[l][r]=max(dp1[l][r],s1[l-1][r]);
            }
        }
    }    
    cout<<ans;
}
```

#### Tips : 

1. 程序中也可以使用一个三维 dp，但是会浪费亿些空间所以我直接定义了 $11$ 个 dp。

1. 程序有那么亿点大，仔细检查别出毛病，~~也别写到一半写崩了不写了~~。

最后祝各位 AC 这道题！

---

## 作者：Genius_Star (赞：1)

### 思路：

来一篇极小常数的 $O(N^3M)$ 和 $O(N^2M \log^2 N)$ 的题解，最慢点在 500ms 以下~~但是为什么还是最劣解~~。

定义 $dp_{i,j,k,x \in \{0,1,2\},y \in \{0,1,2\}}$ 表示对于正在画的第 $x$ 个字符，目前正在画开头/中间/结尾，且当前画的矩形的右下角是 $(i,j)$ 和右上角 $(k,j)$。

则状态转移方程为，为了使式子不过于太丑陋，分段函数就表示取 $\max$：

$$dp_{i,j,k,0,0} = \begin{cases} \sum\limits_{I=k}^i a_{I,j} \\ \sum\limits_{I=k}^i a_{I,j} + dp_{i,j-1,k} \end{cases}$$

$$dp_{i,j,k,0,1} = \sum\limits_{I=k}^i a_{I,j} + \begin{cases} \max\limits_{l=i+1}^n dp_{l,j-1,k,0,0} \\ \max\limits_{x=k}^i \max\limits_{y=1}^k dp_{x,j-1,y,0,1} \\ \max\limits_{y=1}^{k-1} dp_{k-1,j-1,y} \end{cases}$$

$$dp_{i,j,k,0,2} = \sum\limits_{I=k}^i a_{I,j} + \begin{cases} \max\limits_{l=k+1}^i dp_{i,j-1,l,0,1} \\ dp_{i,j-1,k,0,2} \end{cases}$$

$$dp_{i,j,k,1,0} = \sum\limits_{I=k}^i a_{I,j} + \max\limits_{x=1}^n \max\limits_{z=1}^{k-2} \max\limits_{y=1}^i dp_{i,z,y,0,2}$$

$$dp_{i,j,k,1,1} = a_{k,j} + a_{i,j} + \begin{cases} dp_{i,j-1,k,1,0} \\ dp_{i,j-1,k,1,1} \end{cases}$$

$$dp_{i,j,k,1,2} = \sum\limits_{I=k}^i a_{I,j} + dp_{i,j-1,k,1,1}$$

$$dp_{i,j,k,2,0} = a_{k,j} + a_{i,j} + \begin{cases} dp_{i,j-1,k,2,0} \\ \max\limits_{x=1}^n \max\limits_{z=1}^{k-2} \max\limits_{y=1}^i dp_{i,z,y,1,2} \end{cases}$$

$$dp_{i,j,k,2,1} = \sum\limits_{I=k}^i a_{I,j} + \begin{cases} dp_{i,j-1,k,2,0} \\ dp_{i,j-1,k,2,1}\end{cases}$$

$$dp_{i,j,k,2,2} = a_{k,j} + a_{i,j} + \begin{cases} dp_{i,j-1,k,2,1} \\ dp_{i,j-1,k,2,2} \end{cases}$$

对于一重循环部分，可以直接前缀/后缀预处理 $\max$；对于查询矩阵最大值部分，可以用二维 ST 表或者暴力扫一维然后预处理另外一维的前缀/后缀 $\max$。

时间复杂度为 $O(N^3M)$ 或 $O(N^2M \log^2 N)$，由于感觉二维 ST 表可能快不了多少，于是没有写，有兴趣的读者可以自己尝试一下。

**空间可能开不下，要用滚动数组优化。**

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define pi pair<ll,ll>
#define pii pair<ll,pair<ll,ll>>
#define iip pair<pair<ll,ll>,ll>
#define ppii pair<pair<ll,ll>,pair<ll,ll>>
#define fi first
#define se second
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define Full(a) memset(a,0,sizeof(a))
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
using namespace std;
typedef double db;
typedef unsigned long long ull;
typedef int ll;
bool Begin;
const ll N=155,M=505,INF=1e9; 
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,m,ans=-INF;
ll a[N][M],s[N][M];
ll dp[2][N][M][N];
ll MAX[M][2],T1[N][M],T2[N][M][N],T3[N][M][N],T4[N][M][N];
bool End;
int main(){
//	open("A.in","A.out");
	memset(T1,-0x7f,sizeof(T1));
	memset(T2,-0x7f,sizeof(T2));
	memset(T3,-0x7f,sizeof(T3));
	memset(T4,-0x7f,sizeof(T4));
	memset(MAX,-0x7f,sizeof(MAX));
	memset(dp,-0x7f,sizeof(dp));
	n=read(),m=read();
	for(int i=1;i<=n;i++)
	  for(int j=1;j<=m;j++)
		a[i][j]=read();
	for(int i=1;i<=n;i++)
	  for(int j=1;j<=m;j++)
		s[i][j]=s[i-1][j]+a[i][j];
	for(int i=1;i<=n;i++)
	  for(int j=1;j<=m;j++)
		for(int k=1;k<=i-1;k++)
		  dp[0][i][j][k]=s[i][j]-s[k-1][j]+max(dp[0][i][j-1][k],0);
	for(int j=1;j<=m;j++){
	    for(int i=n;i>=1;i--){
	    	for(int k=1;k<=i;k++){
	    		dp[1][i][j][k]=max(T1[k-1][j-1],T2[i+1][j-1][k]);
		    	for(int x=k;x<=i;x++)
		    	  dp[1][i][j][k]=max(dp[1][i][j][k],T3[x][j-1][k]);
		    	dp[1][i][j][k]+=s[i][j]-s[k-1][j];  
		    	T1[i][j]=max(T1[i][j],dp[1][i][j][k]);
		    	T2[i][j][k]=max(T2[i+1][j][k],dp[0][i][j][k]);
		    	T3[i][j][k]=max(T3[i][j][k-1],dp[1][i][j][k]);
			}
		}
	}
	memset(dp[0],-0x7f,sizeof(dp[0]));
	for(int j=1;j<=m;j++){
	    for(int i=1;i<=n;i++){
	    	ll M=-INF;
	    	for(int k=i-1;k>=1;k--){
	    		M=max(M,dp[1][i][j-1][k+1]);
	    		dp[0][i][j][k]=M;
			    dp[0][i][j][k]=max(dp[0][i][j][k],dp[0][i][j-1][k]);
			    dp[0][i][j][k]+=s[i][j]-s[k-1][j];
			    MAX[j][0]=max({MAX[j][0],MAX[j-1][0],dp[0][i][j][k]});
			}
		}
	}
	memset(dp[1],-0x7f,sizeof(dp[1]));
	for(int j=5;j<=m;j++)
	  for(int i=1;i<=n;i++)  
	    for(int k=1;k<=i-2;k++)
	      dp[1][i][j][k]=s[i][j]-s[k-1][j]+MAX[j-2][0];
	memset(dp[0],-0x7f,sizeof(dp[0]));
	for(int j=6;j<=m;j++)
	  for(int i=1;i<=n;i++)
	    for(int k=1;k<=i-2;k++)
	      dp[0][i][j][k]=a[k][j]+a[i][j]+max(dp[1][i][j-1][k],dp[0][i][j-1][k]);
	memset(dp[1],-0x7f,sizeof(dp[1]));
	for(int j=7;j<=m;j++){
	    for(int i=1;i<=n;i++){
		    for(int k=1;k<=i-2;k++){
		    	dp[1][i][j][k]=s[i][j]-s[k-1][j]+dp[0][i][j-1][k];	
		    	MAX[j][1]=max({MAX[j][1],MAX[j-1][1],dp[1][i][j][k]});
			} 
		}
	}
	memset(dp[0],-0x7f,sizeof(dp[0]));
	for(int j=9;j<=m;j++)
	  for(int i=1;i<=n;i++)
		for(int k=1;k<=i-2;k++)
		  dp[0][i][j][k]=a[k][j]+a[i][j]+max(dp[0][i][j-1][k],MAX[j-2][1]);
	memset(dp[1],-0x7f,sizeof(dp[1]));
	for(int j=10;j<=m;j++)
	  for(int i=1;i<=n;i++)
		for(int k=1;k<=i-2;k++)
		  dp[1][i][j][k]=s[i][j]-s[k-1][j]+max(dp[0][i][j-1][k],dp[1][i][j-1][k]);
	memset(dp[0],-0x7f,sizeof(dp[0]));
	for(int j=11;j<=m;j++){
	    for(int i=1;i<=n;i++){
		    for(int k=1;k<=i-2;k++){
		    	dp[0][i][j][k]=a[k][j]+a[i][j]+max(dp[1][i][j-1][k],dp[0][i][j-1][k]);
		    	ans=max(ans,dp[0][i][j][k]);
			}
		}
	}
	write(ans);
	cerr<<'\n'<<abs(&Begin-&End)/1048576<<"MB";
	return 0;
}
```

---

## 作者：262620zzj (赞：1)

# 序言
第 $1$ 道认真做出来的黑色题。

~~没想到八年多了还能交题解~~。

本篇题解中，以左上角作为 $(1,1)$，区间 $l\sim r$ 指的是一列中上端点为 $l$ ,下端点为 $r$ 的区间。
# 题意翻译
我认为本题对写字的限制还是挺绕的，故在此总结一下写字的要求。
![](https://cdn.luogu.com.cn/upload/image_hosting/cnvm6kj8.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/itdx9cuf.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/6ptkgn6c.png)
**并且每个字母之间必须至少有一列空白**。总体来说，就是要求你写出来的字得是 NOI 的形状。
# 算法分析
本题数据范围有个特殊的点，$n,m$ 不是一个量级。而且我们发现可以**把每个字母竖着划分为3个部分**。
![](https://cdn.luogu.com.cn/upload/image_hosting/zkn2e5qe.png)
这样我们就可以统一以每一列的视角来看这个问题。每个字母三个部分一共九个部分，再加上 NO、OI 之间的空白，每一列有 $11$ 种情况。由于**每一列选择哪些方格写字受且仅受前一列的影响**，所以满足最优子结构性和无后效性，可以使用动态规划。枚举每一列，枚举所有可能的区间，进行状态转移。
# 状态设计
根据上文我们可以设 $N_1(i,l,r)$ 表示前 $i$ 列，第 $i$ 列是 N 左边的竖选择 $l\sim r$ 这几个格子，所能获得的最大幸运值，其他的类似。O 中间部分，I 两边部分由于空心，则改定义为选择 $l,r$ 两个格子。$W_1,W_2$ 是当列为 NO，OI 之间的空白时最大的幸运值。第一维可以滚动数组优化掉。
# 状态转移
转移还是比较简单的。先做前缀和 $s(l,r)=\sum_{i=l}^rluck_i$。结合对写字的限制模拟即可。这里我以最难的一部分，N 的中间斜杠的部分举例。

本列作为 N 中间的斜杠，那么前一列有两种情况。

- 前一列是 N 的左边一竖
$$N_2(i,l,r)=\max_{j=r+1}^n{N_1(i-1,l,j) }+s(l,r)$$
- 前一列是 N 中间斜杠
$$N_2(i,l,r)=\max_{a\in [1,l],b\in [l-1,r]}N_2(i-1,a,b)+s(l,r)$$

其他部分类似。
# 优化
如何快速转移有些难度。首先要前缀和记录一段区间的幸运值，其次对于转移式中的 max 操作，定义辅助数组
$$ mxN_2(l,r)=\max_{k=1}^l N_2(k,r)$$
则可以
$$ mxN_2(l,r)=\max(mxN_2(l-1,r),N_2(l,r))$$
递推转移，这样计算时只需
$$N_2(l,r)=\max_{k=l-1}^{r}mxN_2(l,k)$$
新建一变量记录前缀最大值即可。
时间复杂度 $O(n^2m)$。
# 注意事项
滚动数组的动态规划，一定要注意转移的顺序。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
template<typename T>void read(T &x){
	x=0;int f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	x*=f;
}
template<typename T,typename ...Args>
void read(T &x,Args &...rest){read(x);read(rest...);}
const int N=155,M=505,INF=2e9;
int n,m,luck[N][M],sum[N],pre=0,cur=1;
int N1[N][N],N2[N][N],N3[N][N];
int O1[N][N],O2[N][N],O3[N][N];
int I1[N][N],I2[N][N],I3[N][N];
int mx_N1[N][N],mx_N2[N][N];
int W1=-INF,W2=-INF,ans=-INF;
inline int s(int l,int r){return sum[r]-sum[l-1];}
inline void chkmax(int &a,int b){if(b>a)a=b;}
int main(){
    read(n,m);
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)read(luck[i][j]);
    memset(N1,128,sizeof(N1));memset(N2,128,sizeof(N2));memset(N3,128,sizeof(N3));
    memset(O1,128,sizeof(O1));memset(O2,128,sizeof(O2));memset(O3,128,sizeof(O3));
    memset(I1,128,sizeof(I1));memset(I2,128,sizeof(I2));memset(I3,128,sizeof(I3));
    memset(mx_N1,128,sizeof(mx_N1));memset(mx_N2,128,sizeof(mx_N2));
    #define rep(i,a,b) for(int i=a;i<=b;i++)
    #define per(i,a,b) for(int i=a;i>=b;i--)
    rep(i,1,m){
        rep(j,1,n)sum[j]=sum[j-1]+luck[j][i];
        rep(l,1,n)rep(r,l+2,n)I3[l][r]=max(I3[l][r],I2[l][r])+s(l,l)+s(r,r);
		rep(l,1,n)rep(r,l+2,n)chkmax(ans,I3[l][r]);
        rep(l,1,n)rep(r,l+2,n)I2[l][r]=max(I1[l][r],I2[l][r])+s(l,r);
        rep(l,1,n)rep(r,l+2,n)I1[l][r]=max(W2,I1[l][r])+s(l,l)+s(r,r);
        rep(l,1,n)rep(r,l+2,n)chkmax(W2,O3[l][r]);
        rep(l,1,n)rep(r,l+2,n)O3[l][r]=O2[l][r]+s(l,r);
        rep(l,1,n)rep(r,l+2,n)O2[l][r]=max(O1[l][r],O2[l][r])+s(l,l)+s(r,r);
        rep(l,1,n)rep(r,l+2,n)O1[l][r]=W1+s(l,r);
        rep(l,1,n)rep(r,l+1,n)chkmax(W1,N3[l][r]);
        rep(r,1,n){
            int _max=-INF;
            per(l,r-1,1){
                chkmax(_max,N2[l+1][r]);
                N3[l][r]=max(_max,N3[l][r])+s(l,r);
            }
        }       
        rep(l,1,n){
            int _max=mx_N2[l-1][l-1];
            rep(r,l,n){
                chkmax(_max,mx_N2[l][r]);
                N2[l][r]=max(mx_N1[l][r+1],_max)+s(l,r);
            }
        }
        rep(l,1,n)rep(r,l+1,n)N1[l][r]=max(N1[l][r],0)+s(l,r);
        rep(l,1,n)per(r,n,l+1)mx_N1[l][r]=max(mx_N1[l][r+1],N1[l][r]);
        rep(r,1,n)rep(l,1,r)mx_N2[l][r]=max(mx_N2[l-1][r],N2[l][r]);
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Purslane (赞：0)

# Solution

代码写的有点抽象。感觉我这个做法是前缀和优化 $\rm DP$ 的集大成者。。。据说前段时间他还是黑题来着。。。

先考虑设 $Nmax_j$ 表示前 $j$ 列能画出来的最大的 $\texttt N$ 是多少。首先，使用前缀和来优化左右两个矩阵是平凡的。

如何维护中间那一大条斜线链？容易发现（如果是一整个大矩形，可以拆成一个一个小的矩形），如果当前矩形的高度为 $u$ 到 $d$，上一个矩形高度 $u'$ 到 $d'$ 应该有：

- $u' \le u$。
- $u-1 \le d' \le d$。

还是可以前缀和。

对于 $\texttt O$，枚举左边那条边，使用前缀和优化。

对于 $\texttt I$，拆分成三个部分：左边两道杠，中间一个矩形，右边两道杠。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=150+10,MAXM=500+10;
int n,m,a[MAXN][MAXM],pre[MAXN][MAXM],Nmax[MAXM],Omax[MAXM],Imax[MAXM];
int calc(int x,int X,int y,int Y) {return pre[X][Y]-pre[x-1][Y]-pre[X][y-1]+pre[x-1][y-1];}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m; ffor(i,1,n) ffor(j,1,m) cin>>a[i][j];
	ffor(i,1,n) ffor(j,1,m) pre[i][j]=pre[i-1][j]+pre[i][j-1]-pre[i-1][j-1]+a[i][j];
	
	int dp[MAXN][MAXN][MAXM],dppre[MAXN][MAXN][MAXM],recmn[MAXN][MAXN];
	memset(recmn,0x3f,sizeof(recmn)),memset(dp,-0x3f,sizeof(dp)),memset(dppre,-0x3f,sizeof(dppre));
	ffor(j,1,m) {
		ffor(u,1,n) {
			int tmx=dppre[u][u-1][j-1];
			ffor(d,u,n) tmx=max(tmx,dppre[u][d][j-1]),dp[u][d][j]=tmx+calc(u,d,j,j);
			tmx=-0x3f3f3f3f;
			roff(d,n,u) {
				dp[u][d][j]=max(dp[u][d][j],tmx+calc(u,d,j,j));
				tmx=max(tmx,pre[d][j-1]-pre[u-1][j-1]-recmn[u][d]);
				recmn[u][d]=min(recmn[u][d],pre[d][j-1]-pre[u-1][j-1]);
			}
		}
		ffor(d,1,n) ffor(u,1,n) dppre[u][d][j]=max(dppre[u-1][d][j],dp[u][d][j]);
	}
	memset(Nmax,-0x3f,sizeof(Nmax));
	int LstL[MAXN][MAXN]; memset(LstL,-0x3f,sizeof(LstL));
	ffor(i,1,m) {
		ffor(u,1,n) ffor(d,u,n) Nmax[i]=max(Nmax[i],pre[d][i]-pre[u-1][i]+LstL[u][d]);
		ffor(d,1,n) {
			int tmx=-0x3f3f3f3f;
			roff(u,d,1) {
				LstL[u][d]=max(LstL[u][d],tmx-(pre[d][i]-pre[u-1][i]));
				tmx=max(tmx,dp[u][d][i]);
			}
		}
	}
	ffor(i,1,m) Nmax[i]=max(Nmax[i],Nmax[i-1]);
//	ffor(i,1,m) cout<<Nmax[i]<<' '; cout<<'\n';
	//处理 O
	int Ohang[MAXN][MAXN]; memset(Omax,-0x3f,sizeof(Omax)),memset(Ohang,-0x3f,sizeof(Ohang));
	ffor(j,3,m) {
		ffor(u,1,n) ffor(d,u+2,n) Omax[j]=max(Omax[j],pre[u][j-1]-pre[u-1][j-1]+pre[d][j-1]-pre[d-1][j-1]+calc(u,d,j,j)+Ohang[u][d]);
		ffor(u,1,n) ffor(d,u+2,n) Ohang[u][d]=max(Ohang[u][d],Nmax[j-3]+calc(u,d,j-1,j-1)-(pre[u][j-1]-pre[u-1][j-1]+pre[d][j-1]-pre[d-1][j-1]));
	}
	ffor(j,1,m) Omax[j]=max(Omax[j],Omax[j-1]);
//	ffor(i,1,m) cout<<Omax[i]<<' '; cout<<'\n';
	//处理 I
	int Part1[MAXN][MAXN][MAXM],Part2[MAXN][MAXN][MAXM],hmx[MAXN][MAXN];
	memset(Part1,-0x3f,sizeof(Part1)),memset(Part2,-0x3f,sizeof(Part2)),memset(hmx,-0x3f,sizeof(hmx));
	ffor(j,2,m) {
		ffor(u,1,n) ffor(d,u+2,n) Part1[u][d][j]=pre[u][j]-pre[u-1][j]+pre[d][j]-pre[d-1][j]+hmx[u][d];
		ffor(u,1,n) ffor(d,u+2,n) hmx[u][d]=max(hmx[u][d],Omax[j-1]-(pre[u][j]-pre[u-1][j]+pre[d][j]-pre[d-1][j]));	
	}
	memset(hmx,-0x3f,sizeof(hmx));
	ffor(j,1,m) {
		ffor(u,1,n) ffor(d,u+2,n) Part2[u][d][j]=max(Part2[u][d][j],hmx[u][d]+pre[d][j]-pre[u-1][j]);
		ffor(u,1,n) ffor(d,u+2,n) hmx[u][d]=max(hmx[u][d],Part1[u][d][j]-(pre[d][j]-pre[u-1][j]));
	}
	int ans=-0x3f3f3f3f; memset(hmx,-0x3f,sizeof(hmx));
	ffor(j,1,m) {
		ffor(u,1,n) ffor(d,u+2,n) ans=max(ans,pre[d][j]-pre[d-1][j]+pre[u][j]-pre[u-1][j]+hmx[u][d]);
		ffor(u,1,n) ffor(d,u+2,n) hmx[u][d]=max(hmx[u][d],Part2[u][d][j]-(pre[d][j]-pre[d-1][j]+pre[u][j]-pre[u-1][j]));
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：一只绝帆 (赞：0)

### P1398 [NOI2013] 书法家 Sol

题解区怎么全都是大粪 $10$ 维 $\rm dp$，理论上是 $\mathcal O(n^2m)$ 但是绝大多数跑不过我的 $\mathcal O(n^2m+nm^2)$。

大体思路肯定是对于每条竖线求出左侧的最大 $\rm N$，右侧的最大 $\rm OI$，拼一下。

考虑求右侧的最大 $\rm OI$，首先要对于每条竖线求出右侧的最大的 $\rm I$，感觉不是很好做，你发现可以从右往左扫描。

$f_{i,l,r,t}$ 表示扫描到 $i$，$\rm I$ 的上下端点是 $l,r$，$t$ 是阶段，转移就是第一阶段加单点，第二阶段加区间，第三阶段加单点。

然后是 $\rm O$，为了统计 $\rm N,I$，你可以从下往上扫，$g_{i,l,r,t}$ 表示扫描到 $i$，$\rm O$ 的左右端点是 $l,r$，$t$ 是阶段，转移同理。

接下来就是这个最不顺眼的 $\rm N$ 了，按照套路我们肯定要从左往右扫，注意到把 $\rm N$ 的每个矩形拆成一条一条矩形也是符合条件的，而且每个矩形的限制仅仅依赖上一个矩形，所以直接记录 $h_{i,l,r,t}$ 表示扫描到 $i$，上一个矩形的上下端是 $l,r$，$t$ 表示该矩形是第一个、中间的或最后一个。

听上去很美好，但其实是 $\mathcal O(n^4m)$ 的，因为转移也有复杂度。

但还能救，写出转移式：

$$\begin{aligned}h_{i,l,r,1}&\gets h_{i-1,l,r,1}+S(i,l,r)\\h_{i,l,r,2}&\gets \max_{k>r}(h_{i-1,l,k,1}+S(i,l,r))\\h_{i,l,r,2}&\gets\max_{u\le l,v\in[l-1,r]}(h_{i-1,u,v,2}+S(i,l,r))\\h_{i,l,r,3}&\gets\max_{k>l}(h_{i-1,k,r,2}+S(i,l,r))\\h_{i,l,r,3}&\gets h_{i-1,l,r,3}+S(i,l,r)\end{aligned}$$

你发现第二个、第四个转移式可以轻松变为 $\mathcal O(n^2m)$，第三个有点小困难，可以先对 $u$ 这一维做前缀 $\max$，然后 $r\to r+1$ 那就多一列 $v$ 对应的一堆 $u$，于是转移成立。

```cpp
#include<bits/stdc++.h>
#define Z(x,y) (x=max(x,y))
#define UF(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)
#define F(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)
using namespace std;typedef long long ll;
#define gc() getchar()
int read() {
	int s=0,w=0;char ch=gc();
	while(ch<'0'||ch>'9') w|=(ch=='-'),ch=gc();
	while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48),ch=gc();
	return w?-s:s;
} const int N=155,M=505,inf=0x3f3f3f3f;
int n,m,a[N][M],S[N][M],S2[N][M],f[2][N][N][3],rI[N],h[2][N][N][3],th[N][N],g[2][M][M][2],ansN[M],ansI[M];
ll ans=-1e17;
auto init_h=[](int j,auto &h) {
    memset(h,-0x3f,sizeof h);
    memset(th,-0x3f,sizeof th);
    F(l,1,n) F(r,l+1,n) h[l][r][0]=S2[r][j]-S2[l-1][j];
};
auto init_f=[](int j,auto &f) {
    memset(f,-0x3f,sizeof f);
    F(l,1,n) F(r,l+2,n) f[l][r][0]=a[r][j]+a[l][j];
};
auto init_g=[](int i,auto &g) {
    memset(g,-0x3f,sizeof g);
    F(l,1,m) F(r,l+2,m) g[l][r][0]=S[i][r]-S[i][l-1];
};
int main() {
	n=read();m=read();
    F(i,1,n) F(j,1,m) a[i][j]=read(),S[i][j]=S[i][j-1]+a[i][j],S2[i][j]=S2[i-1][j]+a[i][j];
    memset(ansN,-0x3f,sizeof ansN);memset(ansI,-0x3f,sizeof ansI);
    int x=1,s=0;
    init_h(1,h[x]);init_h(2,h[s]);
    F(j,2,m) {
        F(l,1,n) F(r,l,n) Z(h[s][l][r][0],h[x][l][r][0]+S2[r][j]-S2[l-1][j]),Z(h[s][l][r][2],h[x][l][r][2]+S2[r][j]-S2[l-1][j]);
        F(l,1,n) UF(r,n,1) Z(h[x][l][r][0],h[x][l][r+1][0]);
        F(l,1,n) F(r,l,n) Z(h[s][l][r][1],h[x][l][r+1][0]+S2[r][j]-S2[l-1][j]);
        F(r,1,n) UF(l,n,1) th[l][r]=max(h[x][l][r][1],th[l+1][r]);
        F(r,1,n) F(l,1,n) Z(h[x][l][r][1],h[x][l-1][r][1]);
        F(l,1,n) F(r,l,n) Z(h[s][l][r][2],th[l+1][r]+S2[r][j]-S2[l-1][j]);
        F(l,1,n) {
            int res=h[x][l][l-1][1];
            F(r,l,n) Z(res,h[x][l][r][1]),Z(h[s][l][r][1],res+S2[r][j]-S2[l-1][j]);
        }
        swap(x,s);init_h(j+1,h[s]);
        F(l,1,n) F(r,l,n) Z(ansN[j],h[x][l][r][2]);
    }
    x=1,s=0;
    init_f(m,f[x]);init_f(m-1,f[s]);
    UF(j,m-1,1) {
        F(l,1,n) F(r,l+2,n) Z(f[s][l][r][0],f[x][l][r][0]+a[r][j]+a[l][j]),Z(f[s][l][r][1],max(f[x][l][r][1],f[x][l][r][0])+S2[r][j]-S2[l-1][j]),Z(f[s][l][r][2],max(f[x][l][r][2],f[x][l][r][1])+a[r][j]+a[l][j]);
        swap(x,s);init_f(j-1,f[s]);
        F(l,1,n) F(r,l+2,n) Z(ansI[j],f[x][l][r][2]);
    }
    F(i,1,m) Z(ansN[i],ansN[i-1]);
    UF(i,m,1) Z(ansI[i],ansI[i+1]);
    x=1,s=0;
    init_g(1,g[x]);init_g(2,g[s]);
    F(i,2,n) {
        F(l,3,m) F(r,l+2,m) Z(g[s][l][r][1],max(g[x][l][r][1],g[x][l][r][0])+a[i][l]+a[i][r]),Z(ans,0ll+g[x][l][r][1]+S[i][r]-S[i][l-1]+ansN[l-2]+ansI[r+2]);
        swap(x,s);init_g(i+1,g[s]);
    } cout<<ans<<endl;
	return 0;
}

---

## 作者：⚡114514_zzm⚡ (赞：0)

注意到N O I三个字母都可以从左到右拆成三部分,即N=一个矩形+一堆矩形+一个矩形,O=一条+两条横的+一条,I=两条横的+一个矩形+两条横的,所以可以拆成13个部分转移(9个字母部分,4个空白部分).

设fi,j,l,r表示第i列,放的是字母的j部分,放了从l行到r行的最大值,gi,j表示第i列,放的是的空白j部分的最大值.转移根据不同的部分,枚举下一列怎么放,但是这样复杂度不对.可以发现只有空白部分转移到字母部分和N部分转移需要枚举放哪里,其他的可以直接继承上一个状态的l,r.

空白部分转移比较简单,这里主要看N.首先从第一部分转移到第二部分,如果放了l,r,那么前一个状态的后面两维为l,r′(r′>r),所以可以记后缀最大值直接转移.然后是第二部分之间的转移,上一个状态后两维是l′,r′(l′≥l,l−1≤r′≤r),这个也可以前缀最值优化.从第二部分转移到第三部分,前一个状态的后面两维为l′,r(l′<l),可以前缀最值优化.

```

#include<bits/stdc++.h>
#define LL long long
#define uLL unsigned long long
#define il inline
 
using namespace std;
const int N=150+10,M=500+10;
il int rd()
{
    int x=0,w=1;char ch=0;
    while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') {x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*w;
}
int n,m,a[N][M],s[N][M],f[2][10][N][N],g[2][4],ss[N];
 
int main()
{
    n=rd(),m=rd();
    for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j)
            a[i][j]=rd(),s[i][j]=s[i-1][j]+a[i][j];
    memset(f,-0x3f,sizeof(f)),memset(g,-0x3f,sizeof(g));
    int nw=1,la=0;
    g[la][0]=0;
    for(int j=1;j<=m+1;++j)
    {
        memcpy(g[nw],g[la],sizeof(g[la]));
        //
        for(int l=1;l<=n;++l)
            for(int r=l+1;r<=n;++r)
                f[nw][1][l][r]=max(g[la][0],f[la][1][l][r])+s[r][j]-s[l-1][j];
        for(int l=1;l<=n;++l)
            for(int r=n,mx=-(1<<29);r>=l;--r)
            {
                f[nw][2][l][r]=max(f[nw][2][l][r],mx+s[r][j]-s[l-1][j]);
                mx=max(mx,f[la][1][l][r]);
            }
        memset(ss,-0x3f,sizeof(ss));
        for(int l=1;l<=n;++l)
            for(int r=l,mx=ss[l-1];r<=n;++r)
            {
                ss[r]=max(ss[r],f[la][2][l][r]);
                mx=max(mx,ss[r]);
                f[nw][2][l][r]=max(f[nw][2][l][r],mx+s[r][j]-s[l-1][j]);
            }
        for(int r=n;r;--r)
            for(int l=r,mx=-(1<<29);l;--l)
            {
                f[nw][3][l][r]=max(f[nw][3][l][r],mx+s[r][j]-s[l-1][j]);
                mx=max(mx,f[la][2][l][r]);
            }
        for(int l=1;l<=n;++l)
            for(int r=l+1;r<=n;++r)
            {
                f[nw][3][l][r]=max(f[nw][3][l][r],f[la][3][l][r]+s[r][j]-s[l-1][j]);
                g[nw][1]=max(g[nw][1],f[la][3][l][r]);
            }
        //
        for(int l=1;l<=n;++l)
            for(int r=l+2;r<=n;++r)
                f[nw][4][l][r]=g[la][1]+s[r][j]-s[l-1][j];
        for(int l=1;l<=n;++l)
            for(int r=l+2;r<=n;++r)
                f[nw][5][l][r]=max(f[la][4][l][r],f[la][5][l][r])+a[l][j]+a[r][j];
        for(int l=1;l<=n;++l)
            for(int r=l+2;r<=n;++r)
            {
                f[nw][6][l][r]=f[la][5][l][r]+s[r][j]-s[l-1][j];
                g[nw][2]=max(g[nw][2],f[la][6][l][r]);
            }
        //
        for(int l=1;l<=n;++l)
            for(int r=l+2;r<=n;++r)
                f[nw][7][l][r]=max(g[la][2],f[la][7][l][r])+a[l][j]+a[r][j];
        for(int l=1;l<=n;++l)
            for(int r=l+2;r<=n;++r)
                f[nw][8][l][r]=max(f[la][7][l][r],f[la][8][l][r])+s[r][j]-s[l-1][j];
        for(int l=1;l<=n;++l)
            for(int r=l+2;r<=n;++r)
            {
                f[nw][9][l][r]=max(f[la][8][l][r],f[la][9][l][r])+a[l][j]+a[r][j];
                g[nw][3]=max(g[nw][3],f[la][9][l][r]);
            }
        //
        memset(f[la],-0x3f,sizeof(f[la])),memset(g[la],-0x3f,sizeof(g[la]));
        nw^=1,la^=1;
    }
    printf("%d\n",g[la][3]);
    return 0;
}
```


---


# 树

## 题目背景

L 发明了一种与树有关的游戏。

## 题目描述

他从树中删除任意数量（可以为 $0$）的边，计算删除后所有连通块大小的乘积，L 将得到这么多的分数。

你的任务就是对于一颗给定的树，求出 L 能得到的最大分数。


## 说明/提示

#### 数据规模与约定

- 对于 $10\%$ 的数据，保证 $n \leq 5$。
- 对于 $30\%$ 的数据，保证 $n \leq 100$。
- 另有 $30\%$ 的数据，保证给出的树是一条链。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 700$，$1 \leq u, v \leq n$。


## 样例 #1

### 输入

```
5
1 2
2 3
3 4
4 5
```

### 输出

```
6
```

## 样例 #2

### 输入

```
8
1 2
1 3
2 4
2 5
3 6
3 7
6 8
```

### 输出

```
18
```

## 样例 #3

### 输入

```
3
1 2
1 3 
```

### 输出

```
3 
```

# 题解

## 作者：I_AM_HelloWord (赞：15)

#### 一个比较难想的树形分组dp，我们考虑设dp[u][k]表示在以u为根的子树中，共分成k个联通块能够的到的最大分数，可是这个问题似乎有点后效性，同时也不好转移，那我们干脆设的更明确一点，设dp[u][k]表示在u的子树中，和u连在一起的点的个数（即u所在的联通块大小）为k时能得到的最大分数。特殊的，我们用dp[u][0]表示在以u为根的子树中能得到的最大分数，

#### 我们考虑一个转移：dp[u][j]=max(dp[u][k]/k\*dp[v][j-k]/(j-k)\*j)

#### 由于题目数据有点sang，xin，bing，kuang，在常规做法中，我们必须要一个高精度，而写一个高精除低精，还是比较麻烦的，所以我们就考虑如何把这个除法弄掉。

#### 我们重新设dp[u][k]表示在u的子树中，u所在的联通块的大小为k时，得到的最大分数不乘以k时的大小。那么转移就很好写了。

#### dp[u][j]=max(dp[u][k]\*dp[v][j-k])，那么我们之前说的dp[u][0]就可以起到作用了，这时特殊的，dp[u][0]=max(dp[u][j]\*j)，这个方程的正确性还是比较好证明的，最后的结果就是dp[1][0]。

#### 剩下的就是一个高精度了。


#### 参考代码：

```cpp
int dfs(int u,int fa){
    sz[u]=1;dp[u][0]=1;dp[u][1]=1;
    for (int p=a[u];p;p=e[p].next){
        int v=e[p].to;
        if (v!=fa){
            dfs(v,u);
            sz[u]+=sz[v];
            for (int j=sz[u];j>=0;j--)
                for (int k=min(j,sz[u]-sz[v]);k>=max(1,j-sz[v]);k--)//这个分组背包有很多种写法
                    ChkMax(dp[u][j],dp[u][k]*dp[v][j-k]);
        }
    }
    for (int i=1;i<=sz[u];i++)
        ChkMax(dp[u][0],dp[u][i]*i);
}
```



最后Orz楼下dalao


---

## 作者：孤叶残影 (赞：12)

### 注意：我认为题解对dp[u][j]理解有误

------------


 若dp[u][j]表示以U为根联通块大小为j的最大贡献的话，
 
 最后dp[u][0]为何又要乘以i呢（已经是最大贡献了再乘以该联通块大小）

------------


 若dp[u][j]表示以U为根联通块大小为j的最大贡献/j的话，
 
 最后一个方程说通了，那么第一个方程dp[u][j]=max(dp[u][k]*dp[v][j-k])又怎么解释呢，
 
 还有最大贡献/联通块大小的数学意义有是什么？
 
 每个点的平均贡献吗？
 
 那么吧两个联通块平均值乘起来就能得到总联通块的平均点贡献吗？


------------

## 我认为，dp[u][j]表示以u为根节点，除了包含u的大小为j的联通块之外的其他联通块的最大贡献

------------


dp[u][j]=max(dp[u][k]*dp[v][j-k])表示，

在以u为根节点的树上选走k个后剩余联通块的贡献

------------
dp[u][0]=max(dp[u][j]*j) 并不是表示取0个，

只不过0这一维代替再开一个数组。 它表示整个u树的最大贡献，

因为前面未将dp[u][j]算入，则乘上它的贡献!

![](https://cdn.luogu.com.cn/upload/image_hosting/87ba40kg.png)

例子：合并联通块（A到G，下面简称A）和联通块（c到E，简称C），因为是dfs遍历dp，则在此时dp[A][4]只更新的左子树，右子树还未更新，及dp[A][4]表示H的贡献及为1，dp[C][2]同理为I和F的贡献为1，则dp[A][6]为H，F，I总贡献1，最后A树的贡献为dp[A][6]*6(合并后G到E的贡献为其联通块大小)

### 最后再注意：高精需开short，否则会MLE
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#define N 700
using namespace std;
int n, eid;
short sz[N+5], head[N+5];
struct Edge 
{
    int next, to;
}e[2*N+5];
struct bign
{
    static const int maxn = 120;
    short d[maxn+5];
    short len;
    void clean() { while(len > 1 && !d[len-1]) len--; }
    bign() { memset(d, 0, sizeof(d)); len = 1; }
    bign(int num) { *this = num; } 
    bign(char* num) { *this = num; }
    bign operator = (const char* num) {
        memset(d, 0, sizeof(d)); len = strlen(num);
        for(int i = 0; i < len; i++) d[i] = num[len-1-i] - '0';
        clean();
        return *this;
    }
    bign operator = (int num)
    {
        char s[20]; sprintf(s, "%d", num);
        *this = s;
        return *this;
    }
    bign operator + (const bign& b)
    {
        bign c = *this; int i;
        for(i = 0; i < b.len; i++)
	    {
            c.d[i] += b.d[i];
            if (c.d[i] > 9) c.d[i] %= 10, c.d[i+1]++;
        }
        while (c.d[i] > 9) c.d[i++] %= 10, c.d[i]++;
        c.len = max(len, b.len);
        if (c.d[i] && c.len <= i) c.len = i+1;
        return c;
    }
    bign operator - (const bign& b)
	{
        bign c = *this; int i;
        for(i = 0; i < b.len; i++)
		{
            c.d[i] -= b.d[i];
            if (c.d[i] < 0) c.d[i] += 10, c.d[i+1]--;
        }
        while (c.d[i] < 0) c.d[i++] += 10, c.d[i]--;
        c.clean();
        return c;
    }
    bign operator * (const bign& b) const
	{
        int i, j; bign c; c.len = len + b.len; 
        for(j = 0; j < b.len; j++)
            for(i = 0; i < len; i++) 
                c.d[i+j] += d[i]*b.d[j];
        for(i = 0; i < c.len-1; i++) c.d[i+1] += c.d[i]/10, c.d[i] %= 10;
        c.clean();
        return c;
    }
    bign operator / (const bign& b)
	{
        int i, j;
        bign c = *this, a = 0;
        for(i = len - 1; i >= 0; i--)
		{
            a = a*10 + d[i];
            for (j = 0; j < 10; j++) 
                if (a < b*(j+1)) break;
            c.d[i] = j;
            a = a - b*j;
        }
        c.clean();
        return c;
    }
    bign operator % (const bign& b)
	{
        int i, j;
        bign a = 0;
        for(i = len - 1; i >= 0; i--) {
            a = a*10+d[i];
            for(j = 0; j < 10; j++) if (a < b*(j+1)) break;
            a = a-b*j;
        }
        return a;
    }
    bign operator += (const bign& b)
	{
        *this = *this+b;
        return *this;
    }
    bool operator <(const bign& b) const
	{
        if(len != b.len) return len < b.len;
        for(int i = len-1; i >= 0; i--)
            if(d[i] != b.d[i]) return d[i] < b.d[i];
        return false;
    }
    bool operator >(const bign& b) const { return b < *this; }
    bool operator <= (const bign& b) const { return !(b < *this); }
    bool operator >= (const bign& b) const { return !(*this < b); }
    bool operator != (const bign& b) const { return b < *this || *this < b; }
    bool operator == (const bign& b) const { return !(b < *this) && !(b > *this); }
    string str() const {
        char s[maxn] = {};
        for(int i = 0; i < len; i++) s[len-1-i] = d[i]+'0';
        return s;
    }
}f[N+5][N+5];
istream& operator >> (istream& in, bign& x)
{
    string s;
    in >> s;
    x = s.c_str();
    return in;
}
ostream& operator << (ostream& out, const bign& x)
{
    out << x.str();
    return out;
}
void addEdge(int u, int v) 
{
    e[++eid].next = head[u];
    e[eid].to = v;
    head[u] = eid;
}
void dp(int u, int fa) 
{
    sz[u] = 1, f[u][0] = f[u][1] = 1;
    for(int i = head[u]; i; i = e[i].next)
	{
        int v = e[i].to;
        if(v == fa) continue;
        dp(v, u);
        sz[u] += sz[v];
        for(int j = sz[u]; j >= 1; --j) 
		{
            for(int k = min(j, sz[u]-sz[v]); k >= max(1, j-sz[v]); --k)
			{
                f[u][j] = max(f[u][j], f[u][k]*f[v][j-k]);
            }
        }
    }
    for(int i = 1; i <= sz[u]; ++i) f[u][0] = max(f[u][0], f[u][i]*i);
}
int main() 
{
	scanf("%d",&n);
    for(int i = 1, x, y; i <= n-1; ++i)
	{
		scanf("%d %d",&x,&y);
		addEdge(x, y);
		addEdge(y, x);
	} 
    dp(1, 0);
    cout << f[1][0] << endl;
    return 0;
}
```


---

## 作者：kczno1 (赞：7)

一开始想了个贪心。


就是每次枚举叶子，


如果大小为1或者合并后大小<=3,就把相连的点的大小+=它的大小，


否则就把答案\*=它的大小；


删掉这个点；


重复操作。


但这是错的(还能拿65)。


于是我就打了个dp，


f[x][j]表示以x为根的子树，x所属的联通块大小为j，的最大乘积。


枚举儿子y，之后再枚举每个j，k f[x][j]=max{f[x][k]\*f[y][j-k]}


注意这时不要让j,k=0,但j-k可以是0。


因为如果联通块不为0，那么x必须选择。


之后再枚举k,f[x][0]=max{f[x][k]\*k}


这个dp要高精\*高精，所以复杂度挺高的，约O(n^3\*l^2) l是答案长度


(但高精度压位后空间正好能过，时间的话最慢的点0.1s+...应该是数据水吧)


(根据时空来看其他过的人是这个方法)


其实比较乘积可以转化为比较log(乘积)


这样就可以O(n^3)dp了


记录一下从哪里转移过来的


最后再统计一下答案


只用做n次低精乘高精


总时间O(n^3)


upd:
做了http://codeforces.com/contest/815/problem/C

发现这个dp复杂度其实是O(n^2)

每次转移是复杂度是 x之前的子树的sz\*当前子树的sz

相当于之前子树所有点和当前子树的点组成的点对数

而每个点对只会在lca处被计算一次

所以复杂度O(n^2)


---

## 作者：WrongAnswer_90 (赞：3)

[P1411 树](https://www.luogu.com.cn/problem/P1411)

[更好的阅读体验](https://www.cnblogs.com/WrongAnswer90-home/p/17804223.html)

简单 DP，但是毒瘤。开高精还卡空间。。

树形 DP。只关心根节点所处连通块大小，自然记 $f_{i,j}$ 表示以 $i$ 为根的子树中和 $i$ 联通的 $j$ 个点的贡献还没有被计算的答案。这里没有被计算的意思是实际的值为 $j\times f_{i,j}$，只计算了其他连通块的贡献。转移类似树形背包，两种情况：断 $(i,to)$ 边和保留。

断边的转移方程为：

$$

f_{i,j}=\max_{k=1}^{siz_{to}}\{f_{i,j}\times kf_{to,k}\}

$$

保留边的转移方程为：

$$

f_{i,j}=\max_{k=1}^{siz_i}\{f_{i,k}\times f_{to,j-k}\}

$$

最后答案即为 $\max_{k=1}^{n}\{k\times f_{1,k}\}$

要开高精，支持高精乘高低精和比较大小，复杂度应当是大常数（因为高精） $\mathcal O(n^2)$，跑的飞快。

```cpp
	int cnt,n,siz[710],head[710],to[1410],nex[1410];
	inline void add(int x,int y){to[++cnt]=y,nex[cnt]=head[x],head[x]=cnt;}
	namespace BigNum
	{
		struct Node{short len,a[121];Node(){len=0,memset(a,0,sizeof(a));}}f[701][701],tmp[710],ans;
		Node max(Node nd1,Node nd2)
		{
			if(nd1.len>nd2.len)return nd1;
			if(nd1.len<nd2.len)return nd2;
			for(int i=nd1.len;i>=1;--i)
			{
				if(nd1.a[i]>nd2.a[i])return nd1;
				if(nd1.a[i]<nd2.a[i])return nd2;
			}
			return nd1;
		}
		Node operator *(const Node nd1,const int k)
		{
			Node nd3;nd3.len=nd1.len;
			for(int i=1;i<=nd1.len;++i)nd3.a[i]=nd1.a[i]*k;
			for(int i=1;i<=nd1.len;++i)nd3.a[i+1]+=nd3.a[i]/10,nd3.a[i]%=10;
			while(nd3.a[nd3.len+1])++nd3.len,nd3.a[nd3.len+1]+=nd3.a[nd3.len]/10,nd3.a[nd3.len]%=10;
			return nd3;
		}
		Node operator *(const Node nd1,const Node nd2)
		{
			Node nd3;nd3.len=nd1.len+nd2.len-1;
			for(int i=1;i<=nd1.len;++i)
			{
				for(int j=1;j<=nd2.len;++j)
				nd3.a[i+j-1]+=nd1.a[i]*nd2.a[j];
			}
			for(int i=1;i<=nd3.len;++i)nd3.a[i+1]+=nd3.a[i]/10,nd3.a[i]%=10;
			while(nd3.a[nd3.len+1])++nd3.len,nd3.a[nd3.len+1]+=nd3.a[nd3.len]/10,nd3.a[nd3.len]%=10;
			return nd3;
		}
	}
	using namespace BigNum;
	void dfs(int x,int fa)
	{
		siz[x]=1;f[x][1].a[f[x][1].len=1]=1;
		for(int i=head[x];i;i=nex[i])
		{
			if(to[i]==fa)continue;
			dfs(to[i],x);
			memcpy(tmp,f[x],sizeof(tmp));
			Node maxn;
			for(int k=1;k<=siz[to[i]];++k)
			maxn=max(maxn,f[to[i]][k]*k);
			for(int j=1;j<=siz[x];++j)
			{
				for(int k=1;k<=siz[to[i]];++k)
				f[x][j+k]=max(f[x][j+k],tmp[j]*f[to[i]][k]);
				f[x][j]=max(f[x][j],tmp[j]*maxn);
			}
			siz[x]+=siz[to[i]];
		}
	}
    inline void mian()
    {
    	read(n);int x,y;
    	for(int i=1;i<n;++i)read(x,y),add(x,y),add(y,x);
    	dfs(1,0);
    	for(int i=1;i<=n;++i)
		ans=max(ans,f[1][i]*i);
    	for(int i=ans.len;i>=1;--i)write(ans.a[i],'~');
	}
```

---

## 作者：RikoHere (赞：2)

考虑贪心，手玩数据可以发现对于一棵树，要将若干个联通块分的尽量小但大小要大于2，因为显然大小为1的联通块对答案无贡献

贪心不能很好解决大小为1的联通块相互合并的问题，考虑dp，首先看到这个数据范围还是比较友好的$n \leq 700$，考虑到高精度的问题大概可以写一个$O(n^2)$的算法

若切割点$u$与其父亲节点的连边，若要使贡献尽量大，则要使以$u$为根节点的子树得到的贡献尽量大和原树剔除该子树的贡献尽量大，是不重合的问题

因此思考，设计状态$f(u, i)$表示当前在$u$节点，$i$节点向下的联通块大小为$i$时的最大贡献，我们继续手玩数据，发现每次添加一颗子树，实质上是做一个类似树上背包的东西

$f(u,i)=\max\{f(u,i),\ f(e,j)* f(u,i-j)\}$

特别的，对于$f(u,0)$表示切断该节点与父亲节点连边最大贡献

$f(u,0)=\max\{f(u,i)* i\}$

考虑极限数据，最终答案最大值为$2^{350}$,因此高静数组保证能存两百个数位就ok了...至于压位高精的写法还请各显神通...

```
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;
namespace tools {
	bool digit (int ch) { return (ch <= '9' and ch >= '0');}
	inline int in () {
		int x = 0, ch = getchar(), base = 1;
		while (!digit(ch)) { base = (ch == '-')? -1: 1; ch = getchar();}
		while (digit(ch)) { x = x*10+ch-'0'; ch = getchar();}
		return x*base;
	}
	template <class T> inline void smax (T& x, T y) { x = max(x, y);}
	template <class T> inline void smin (T& x, T y) { x = min(x, y);}
	inline void print (int x) { printf("debug:%d\n", x);}
}
using namespace tools;

const int N = 710, M = 45;
struct Big {
	int l, t[M];
} Zero;
int n, root = 1;
int sz[N], ac[N][N]; 
long long tag[M];
Big f[N][N];
int nxt[N<<1], to[N<<1], head[N], index_edge;
inline void add (int u, int v) {
	int i = ++index_edge;
	nxt[i] = head[u]; to[i] = v; head[u] = i;
}

int Mod (int x) {
	return (x-1000*(x/1000));
}
void printBig (Big x) {
	for (int i = x.l; i; --i) {
		if (i == x.l) printf("%d", x.t[i]);
		else printf("%d%d%d", x.t[i]/100, (x.t[i]/10)%10, x.t[i]%10);
	}
	puts("");
}

void Spread (Big& x) {
	for (int i = 1; i <= x.l; ++i) {
		x.t[i] = Mod(tag[i]);
		tag[i+1] += tag[i]/1000;
		if (i == x.l and tag[i+1]) x.l++;
	}
}
Big MBig (Big x, Big y) {
	memset(tag, 0, sizeof(tag));
	int Maxl = 0;
	for (int j = 1; j <= y.l; ++j) {
		for (int i = 1; i <= x.l; ++i) {
			int tmp = y.t[j]*x.t[i];
			int l = i+j-1;
			while (tmp) {
				tag[l] += Mod(tmp);
				tmp /= 1000;
				smax(Maxl, l); l++;
			}
		}
	}
	x.l = Maxl;
	Spread(x); return x;
}
Big Max (Big x, Big y) {
	if (x.l != y.l) return (x.l > y.l)? x: y;
	for (int i = x.l; i; --i) {
		if (x.t[i] == y.t[i]) continue;
		return (x.t[i] > y.t[i])? x: y;
	}
	return x;
}
void GetAns (int x, int fa) {
	sz[x]++;
	f[x][0] = f[x][1] = Zero;
	ac[x][0] = ac[x][1] = true;

	for (int i = head[x]; i; i = nxt[i]) {
		int e = to[i];
		if (e == fa) continue;
		GetAns(e, x);
		sz[x] += sz[e];
		for (int l = sz[x]; l; --l) {
			for (int k = 0; k <= sz[e]; ++k) {
				if (l-k <= 0) break;
				if (!ac[x][l-k] or !ac[e][k]) continue;
				f[x][l] = Max(f[x][l], MBig(f[x][l-k], f[e][k]));
				ac[x][l] = true;
			}
		}
	}
	for (int i = 1; i <= sz[x]; ++i) {
		if (!ac[x][i]) continue;
		Big New = Zero; New.t[1] = i;
		f[x][0] = Max(f[x][0], MBig(f[x][i], New));
	}
}
void work () {
	GetAns(root, 0);
	printBig(f[root][0]);
}
void prepare () {
	Zero.l = 1; Zero.t[1] = 1;
	n = in();
	for (int i = 1; i < n; ++i) {
		int u = in(), v = in();
		add(u, v); add(v, u);
	}
	work();
}

int main () {
	prepare();
}
```


---

## 作者：封禁用户 (赞：0)

我首先想的是设 $
f
[
i
]$
表示以
$i$
为根的子树可获得的最大收益，但是会发现这样无法转移。考虑再加一维，
$f
[
i
]
[
j
]$
表示以
$i$
的子树中，
$i$
所在的联通块大小为
$j$
的最大价值。然后我就傻了，想了半天也没想起来怎么转移，最后只好看了一眼题解。其实转移好简单的，貌似是个树上背包？考虑在
```dfs```
的过程中进行
```DP```，每当访问完一个点
$i$
的子结点时，累加一下
$s
z
[
i
]$
，就枚举
$j$
，并且用当前子结点的
```DP```
值来更新
$f
[
i
]
[
j
]$。转移方程大概会长成下面这个样子：

$$f[i][j]=max\{f[i][j],f[i][k]\cdot f[v]f[j-k]\}$$

（理解的话，就是把之前的大小为
$k$
的联通块和在当前子树中大小为
$j-k$
的联通块拼起来） 同时，我们特别定义
$f
[
i
]
[
0
]$
表示以
$i$
为根的子树可获得的价值，则他的转移方程比较特殊：
$$f[i][0]=max(f[i][0],f[i][j]\cdot j)$$
如果到这里这道题就结束的话，代码会长成下面这样：
 ```cpp #include
using namespace std;

define N 700
define ll long long
int n, eid, sz[N+5], head[N+5];
ll f[N+5][N+5];

struct Edge {
int next, to;
}e[2*N+5];

void addEdge(int u, int v) {
e[++eid].next = head[u];
e[eid].to = v;
head[u] = eid;
}

void dp(int u, int fa) {
sz[u] = 1, f[u][0] = f[u][1] = 1;
for(int i = head[u]; i; i = e[i].next) {
int v = e[i].to;
if(v == fa) continue;
dp(v, u);
sz[u] += sz[v];
for(int j = sz[u]; j >= 1; --j) { //枚举i所在的联通块大小
for(int k = min(j, sz[u]-sz[v]); k >= max(1, j-sz[v]); --k) { //枚举子树根结点所在联通块大小
f[u][j] = max(f[u][j], f[u][k]f[v][j-k]);
}
}
}
for(int i = 1; i <= sz[u]; ++i) f[u][0] = max(f[u][0], f[u][i]i);
}

int main() {
cin >> n;
for(int i = 1, x, y; i <= n-1; ++i) cin >> x >> y, addEdge(x, y), addEdge(y, x);
dp(1, 0);
cout << f[1][0] << endl;
return 0;
}
```
但是一交上去只有 $30pts$，一看讨论区，发现还要用高精度！
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>

using namespace std;

#define N 700

int n, eid;
short sz[N+5], head[N+5];

struct Edge {
    int next, to;
}e[2*N+5];
 
struct bign{ //高精类模板，网上找的
    static const int maxn = 120;
    short d[maxn+5];
    short len;
    void clean() { while(len > 1 && !d[len-1]) len--; }
    bign() { memset(d, 0, sizeof(d)); len = 1; }
    bign(int num) { *this = num; } 
    bign(char* num) { *this = num; }
    bign operator = (const char* num) {
        memset(d, 0, sizeof(d)); len = strlen(num);
        for(int i = 0; i < len; i++) d[i] = num[len-1-i] - '0';
        clean();
        return *this;
    }
    bign operator = (int num){
        char s[20]; sprintf(s, "%d", num);
        *this = s;
        return *this;
    }
    bign operator + (const bign& b) {
        bign c = *this; int i;
        for(i = 0; i < b.len; i++) {
        	c.d[i] += b.d[i];
        	if (c.d[i] > 9) c.d[i] %= 10, c.d[i+1]++;
        }
        while (c.d[i] > 9) c.d[i++] %= 10, c.d[i]++;
        c.len = max(len, b.len);
        if (c.d[i] && c.len <= i) c.len = i+1;
        return c;
    }
    bign operator - (const bign& b) {
        bign c = *this; int i;
        for(i = 0; i < b.len; i++) {
        	c.d[i] -= b.d[i];
        	if (c.d[i] < 0) c.d[i] += 10, c.d[i+1]--;
        }
        while (c.d[i] < 0) c.d[i++] += 10, c.d[i]--;
        c.clean();
        return c;
    }
    bign operator * (const bign& b) const {
        int i, j; bign c; c.len = len + b.len; 
        for(j = 0; j < b.len; j++)
            for(i = 0; i < len; i++) 
                c.d[i+j] += d[i]*b.d[j];
        for(i = 0; i < c.len-1; i++) c.d[i+1] += c.d[i]/10, c.d[i] %= 10;
        c.clean();
        return c;
    }
    bign operator / (const bign& b) {
    	int i, j;
        bign c = *this, a = 0;
    	for(i = len - 1; i >= 0; i--) {
    		a = a*10 + d[i];
    		for (j = 0; j < 10; j++) 
                if (a < b*(j+1)) break;
    		c.d[i] = j;
    		a = a - b*j;
    	}
    	c.clean();
    	return c;
    }
    bign operator % (const bign& b) {
    	int i, j;
        bign a = 0;
    	for(i = len - 1; i >= 0; i--) {
    		a = a*10+d[i];
    		for(j = 0; j < 10; j++) if (a < b*(j+1)) break;
    		a = a-b*j;
    	}
    	return a;
    }
    bign operator += (const bign& b) {
        *this = *this+b;
        return *this;
    }
    bool operator <(const bign& b) const {
        if(len != b.len) return len < b.len;
        for(int i = len-1; i >= 0; i--)
            if(d[i] != b.d[i]) return d[i] < b.d[i];
        return false;
    }
    bool operator >(const bign& b) const { return b < *this; }
    bool operator <= (const bign& b) const { return !(b < *this); }
    bool operator >= (const bign& b) const { return !(*this < b); }
    bool operator != (const bign& b) const { return b < *this || *this < b; }
    bool operator == (const bign& b) const { return !(b < *this) && !(b > *this); }
    string str() const {
        char s[maxn] = {};
        for(int i = 0; i < len; i++) s[len-1-i] = d[i]+'0';
        return s;
    }
}f[N+5][N+5];
 
istream& operator >> (istream& in, bign& x) {
    string s;
    in >> s;
    x = s.c_str();
    return in;
}
 
ostream& operator << (ostream& out, const bign& x) {
    out << x.str();
    return out;
}

void addEdge(int u, int v) {
    e[++eid].next = head[u];
    e[eid].to = v;
    head[u] = eid;
}

void dp(int u, int fa) {
    sz[u] = 1, f[u][0] = f[u][1] = 1;
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(v == fa) continue;
        dp(v, u);
        sz[u] += sz[v];
        for(int j = sz[u]; j >= 1; --j) {
            for(int k = min(j, sz[u]-sz[v]); k >= max(1, j-sz[v]); --k) {
                f[u][j] = max(f[u][j], f[u][k]*f[v][j-k]);
            }
        }
    }
    for(int i = 1; i <= sz[u]; ++i) f[u][0] = max(f[u][0], f[u][i]*i);
}

int main() {
    cin >> n;
    for(int i = 1, x, y; i <= n-1; ++i) cin >> x >> y, addEdge(x, y), addEdge(y, x);
    dp(1, 0);
    cout << f[1][0] << endl;
    return 0;
}

---

## 作者：DengDuck (赞：0)

高精度好恶心。

首先树形 DP 看出式子简直可以说是一眼，我们设 $f_{i,j}$ 表示 $i$ 子树内，根节点连通块大小为 $j$ 的最大乘积。

然后转移考虑树上背包：

对于一条边 $x\to y$，考虑断或者不断：

如果不断，那么新的 $f_{x,j}$ 计为 $f'_{x,j}$，得：

$$
f'_{x,j+k}\gets f_{x,j}\times f_{i,k}
$$

如果断，那么新的 $f_{x,j}$ 计为 $f'_{x,j}$，得：

$$
f'_{x,j}\gets f_{x,j}\times f_{i,k}\times k
$$

含义应该不用过多解释。

但是我们构造一条长度为 $700$ 的链，两两一组，那么答案是 $2^{350}$，这个显然存不下，位数大概在 $120$ 左右，所以要写高精度。

时间复杂度为 $\mathcal O(n^2)$，但是高精度带来的常数很大。

感觉可以从位数分析，分析每个状态位数的势能，用类似树形背包的分析方法，我直觉上感觉也是 $\mathcal O(M^2)$ 的，$M\leq 130$。

```cpp
#include<bits/stdc++.h>
#define LL long long
#define pb push_back
using namespace std;
const LL M=140;
const LL N=705;
struct Num
{
	short num[M],len;
	Num(const LL x=0):len(x)
	{
		memset(num,0,sizeof(num));
	}
	void operator=(const Num&x)
	{
		len=x.len;
		for(int i=0;i<len;i++)num[i]=x.num[i];
	}
	void operator=(LL x)
	{
		len=0;
		while(x)
		{
			num[len++]=x%10;
			x/=10;
		}
	}
	void operator*=(const LL&x)
	{
		for(int i=0;i<len;i++)
		{
			num[i]*=x;
		}
		len+=10;
		for(int i=0;i<len;i++)
		{
			num[i+1]+=num[i]/10;
			num[i]%=10;
		}
		while(num[len-1]==0&&len)len--;
	}
	void operator*=(const Num&x)
	{
		Num ans(x.len+len);
		for(int i=0;i<len;i++)
		{
			for(int j=0;j<x.len;j++)
				ans.num[i+j]+=num[i]*x.num[j];
		}
		for(int i=0;i<ans.len;i++)
		{
			ans.num[i+1]+=ans.num[i]/10;
			ans.num[i]%=10;
		}
		len=ans.len;
		memset(num,0,sizeof(num));
		for(int i=0;i<len;i++)num[i]=ans.num[i];
		while(num[len-1]==0&&len>1)len--;		
	}
	void print()
	{
		for(int i=len-1;i>=0;i--)
		{
			putchar(num[i]+'0');
		}
	}
};
int comp(const Num&x,const Num&y)
{
	if(x.len>y.len)return 1;
	if(x.len<y.len)return -1;
	for(int i=x.len-1;i>=0;i--)
	{
		if(x.num[i]>y.num[i])return 1;
		if(x.num[i]<y.num[i])return -1;
	}
	return 0;
}
vector<Num>f[N];
Num tmp[N];
LL n,sz[N];
vector<LL>v[N];
void dfs(LL x,LL fa)
{
	sz[x]=1;
	for(LL i:v[x])
	{
		if(i==fa)continue;
		dfs(i,x);
		sz[x]+=sz[i];
	}
	f[x].resize(sz[x]+5);
	for(int i=1;i<=sz[x];i++)f[x][i]=1;
	sz[x]=1;
	for(LL i:v[x])
	{
		if(i==fa)continue;
		for(int j=1;j<=sz[x]+sz[i];j++)tmp[j]=f[x][j];
		for(int j=1;j<=sz[x];j++)
		{
			for(int k=1;k<=sz[i];k++)
			{
				Num t=f[x][j];
				t*=f[i][k];
				if(comp(t,tmp[j+k])==1)tmp[j+k]=t;
				t*=k;
				if(comp(t,tmp[j])==1)tmp[j]=t;
			}
		}
		sz[x]+=sz[i];
		for(int j=1;j<=sz[x];j++)
		{
			f[x][j]=tmp[j];
		}
	}
}
int main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n-1;i++)
	{
		LL x,y;
		scanf("%lld%lld",&x,&y);
		v[x].pb(y),v[y].pb(x);
	}
	dfs(1,0);
	Num ans=0;
	for(int i=1;i<=n;i++)
	{
		f[1][i]*=i;
		if(comp(f[1][i],ans)==1)ans=f[1][i];
	}
	ans.print();
}
```

---

## 作者：Genius_Star (赞：0)

### 思路：
很容易看出来，这是个复杂度一点儿的树形 DP。

设 $f[u][j]$ 为当前 $u$ 这个点的子树内，分给儿子们 $j$ 个点（也即自己留下 $siz[u] - j$ 个作为一个联通块）的乘积。

于是有

$$f[u][j] = \max_{0 \leq k \leq j < siz[u]} \{f[u][j],f[v][k] + f'[j - k]\}$$

其中 $f'$ 数组为之前的儿子所计算出的 $f[u]$。

特别的，对于 $f[u][siz[u]]$ 有 $f[u][siz[u]] = f[u][j] \times  (siz[u] * j)$ $(0 \leq j < siz[u])$。

为了优化，我们修改一下方程，把 $j - k$ 和 $k$ 的位置对调一下，变成

$$f[u][j] = \max_{0 \leq j < siz[u], 0 \leq k \leq \min(j , siz[u] - siz[v])} \{f[u][j],f[v][j - k] + f'[k]\}$$

显然他仍然是与原方程等价的，但是复杂度却完全不同。

原方程的上限复杂度显然是 $O(n^3)$ 的（不计高精度），而新方程的实质是对于一个当前 $u$ 大小为 $j$ 的子树中，去找不属于 $v$ 的一棵大小为 $k$ 的子树。

这时单次 DP 的复杂度为 $O(siz[v] \times (siz[u] - siz[v]))$，这个优化可能不是很明显，但是我们这样考虑：由于两个子树是不相交的，那么也就可以看做是两个子树内所有的点两两求一遍 LCA，并且贡献只在 LCA 处计算一次的复杂度。

于是总的复杂度为 $O(n^2)$。
### 代码：
```cpp
#include<cstdio>
#include<cmath>
#include<queue>
#include<stack>
#include<vector>
#include<algorithm>
#include<cstring>
using namespace std;
 
typedef long long LL;
 
const int INF = 2147483647;
const int maxn = 710;
const int r = 1000000000;
 
struct data{
	int tot;
	LL m[20]; data(){memset(m,0,sizeof(m)); tot = 1;}
	data operator * (data b) const
	{
		data ret;
		for (int i = 1; i <= tot; i++)
		{
			for (int j = 1; j <= b.tot; j++)
			{
				ret.m[i + j] += (ret.m[i + j - 1] + m[i] * b.m[j]) / r;
				ret.m[i + j - 1] = (ret.m[i + j - 1] + m[i] * b.m[j]) % r;
			}
		}
		ret.tot = tot + b.tot - 1;
		while (ret.m[ret.tot + 1])
		{
			ret.tot++;
			ret.m[ret.tot + 1] += ret.m[ret.tot] / r;
			ret.m[ret.tot] = ret.m[ret.tot] % r;
		}
		return ret;
	}
	data operator & (LL b) const
	{
		data ret;
		for (int i = 1; i <= tot; i++)
		{
			ret.m[i + 1] += (ret.m[i + 1] + m[i] * b) / r;
			ret.m[i] = (ret.m[i] + m[i] * b) % r;
		}
		ret.tot = tot;
		while (ret.m[ret.tot + 1])
		{
			ret.tot++;
			ret.m[ret.tot + 1] += ret.m[ret.tot] / r;
			ret.m[ret.tot] = ret.m[ret.tot] % r;
		}
		return ret;
	}
};
 
vector<int> e[maxn];
LL n,siz[maxn],s[maxn];
data f[maxn][maxn],ff[maxn],g[maxn];
 
inline LL getint()
{
	LL ret = 0,f = 1;
	char c = getchar();
	while (c < '0' || c > '9')
	{
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9')
		ret = ret * 10 + c - '0',c = getchar();
	return ret * f;
}
 
inline data hmax(data a,data b)
{
	if (a.tot < b.tot) return b;
	if (b.tot < a.tot) return a;
	for (int i = a.tot; i >= 1; i--)
	{
		if (a.m[i] > b.m[i]) return a;
		if (a.m[i] < b.m[i]) return b;
	}
	return a;
}
 
inline void dp(int u,int fa)
{
	siz[u]++;
	for (int i = 0; i < e[u].size(); i++)
	{
		int v = e[u][i];
		if (v == fa) continue;
		dp(v,u);
		siz[u] += siz[v];
		for (int j = 0; j <= siz[u]; j++) ff[j] = f[u][j];
		for (int j = 0; j <= siz[u] - 1; j++)
			for (int k = 0; k <= min(1ll * j,siz[u] - siz[v]); k++)
				f[u][j] = hmax(f[u][j],f[v][j - k] * ff[k]);
	}
	for (LL j = 0; j <= siz[u] - 1; j++)
		f[u][siz[u]] = hmax(f[u][siz[u]],f[u][j] & (siz[u] - j));
}
 
inline void init()
{
	for (int i = 1; i <= n; i++) 
		f[i][0].m[1] = 1;
}
 
inline void print(data a)
{
	int cnt,pos;
	for (int i = 1; i <= a.tot; i++)
	{
		cnt = 0; pos = (i - 1) * 9;
		while (a.m[i])
		{
			s[++pos] = a.m[i] % 10;
			a.m[i] /= 10;
		}
	}
	for (int i = pos; i >= 1; i--) printf("%d",s[i]);
}
 
int main()
{
	n = getint();
	for (int i = 1; i <= n - 1; i++)
	{
		int u = getint(),v = getint();
		e[u].push_back(v); e[v].push_back(u);
	}
	init();
	dp(1,0);
	print(f[1][n]);
	return 0;
}
```


---

## 作者：BzhH (赞：0)

## [博客内查看](https://www.cnblogs.com/A2484337545/p/14596173.html)

一道毒瘤树型DP,主要是因为要用高精.

首先定义状态 $f_{i,j}$ 表示以 $i$ 为根的子树,连通块大小为 $j$,那么这个状态记录的是什么? 它表示除去 $i$ 所在的连通块的贡献答案的最大值,只需要在最后统计答案的时候再加回去.

那么可以得到状态转移方程

$$f_{u,j}=\max_{v \in u,1 \le k \le j}^{1\le j\le size(u)}(f_{u,k}+f_{v,j-k})$$

$$f_{u,0}=\max_{1 \le j \le size(u)}f_{u,j}\times j$$

然后再加上一个高精就行了

部分代码
```
void dfs(int u, int fa)
{
    siz[u] = 1, f[u][0] = f[u][1] = 1;
    for (int i = head[u]; i; i = net[i])
    {
        int v = ver[i];
        if (v == fa)
            continue;
        dfs(v, u);
        siz[u] += siz[v];
        for (int j = siz[u]; j >= 1; j--)
            for (int k = min(siz[u] - siz[v], j); k >= max(1, j - siz[v]); k--)//注意枚举顺序
                f[u][j] = max(f[u][j], f[u][k] * f[v][j - k]);                
    }
    for (int i = 0; i <= siz[u]; i++)
        f[u][0] = max(f[u][i] * i, f[u][0]);
}

```

---


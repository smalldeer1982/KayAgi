# 拆分数列

## 题目描述

给出一列数字，需要你添加任意多个逗号将其拆成若干个严格递增的数。如果有多组解，则输出使得最后一个数最小的同时，字典序最大的解（即先要满足最后一个数最小；如果有多组解，则使得第一个数尽量大；如果仍有多组解，则使得第二个数尽量大，依次类推……）。


## 说明/提示


### 数据范围及约定

记输入的字符串的长度为 $l$。

- 对于 $10\%$ 的数据，$l \le 5$；
- 对于 $30\%$ 的数据，$l \le 15$；
- 对于 $50\%$ 的数据，$l \le 50$；
- 对于 $100\%$ 的数据，$l \le 500$。

### 题目来源

lzn 改编

## 样例 #1

### 输入

```
3456```

### 输出

```
3,4,5,6```

## 样例 #2

### 输入

```
3526```

### 输出

```
3,5,26```

## 样例 #3

### 输入

```
3546```

### 输出

```
35,46```

## 样例 #4

### 输入

```
0001```

### 输出

```
0001```

## 样例 #5

### 输入

```
100000101```

### 输出

```
100,000101```

# 题解

## 作者：liangbowen (赞：147)

## 前言

[题目传送门！](https://www.luogu.com.cn/problem/P1415)

[更好的阅读体验？](https://www.luogu.com.cn/blog/liangbowen/solution-p1415)

这题是一道挺好的 $\texttt{dp}$ 题啊，但大家的题解都写得不够详细。

所以，我来补一篇 $\LaTeX$ 题解，希望能帮助大家。

## 思路

首先是读入，为了方便，我让字符串下标从 $1$ 开始。

```cpp
string a;
int n; //字符串长度。
void Input()
{
	cin >> a;
	//个人习惯将起点下标变为 1 来算。
	n = a.length();
	a = '@' + a;
}
```



为了方便，我们后面用 $num(x, y)$ 表示下标为 $[x, y]$ 所构成的数。

容易想到，题目就是要我们求出：任意一个位置的**最大结束下标**。

考虑到，算这个之前，我们还得先算一算：任意一个位置的**最小开始下标**。

具体地，设 $f_i$ 表示将前 $i$ 位拆成递增数，最后一个数**最小**为 $num(f_i, i)$。

想要最小，则 $f_i$ 要**尽可能大**。

我们可以画一个图，方便推状态转移方程。

![](https://cdn.luogu.com.cn/upload/image_hosting/51kbivoc.png)

所以，状态转移方程如下。
$$
f_i = \max\limits_{j=1}^{i}\begin{cases}j & num(f_{j-1}, j-1) < num(j, i)\\1 & j = 1\end{cases}
$$
这里，我们发现一个问题：如何比较两个数的大小？

题解里的解决办法，代码稍长，提供一种简单的比较方式。

1. 分离出 $num(x, y)$，注意要去除前导 $0$。
2. 比较两个数（注意两个数实际上使用 `string` 存储的）：
   + 如果长度不等，则长度小的数小。
   + 如果长度相等，直接按字典序比较即可。

这样代码会短很多。

```cpp
string num(int x, int y)
//将 a[i]~a[j] 的数分割出来，去除前导 0。
{
	string s = a.substr(x, y-x+1);
	while (s.length() > 1 && s[0] == '0') s.erase(0, 1);
	return s; 
}
bool Less(string x, string y)
//比较 x 与 y 两个数，注意不是比较字典序。
//当且仅当 x < y 返回 true。 
{
	if (x.length() != y.length()) return x.length() < y.length();
	return x < y; //长度相等，则字典序比较等同于数的比较。 
}
bool cmp(int x1, int y1, int x2, int y2)
//等同于：比较 num(x1, y1) 与 num(x2, y2) 的大小。
{
	string t1 = num(x1, y1), t2 = num(x2, y2);
	return Less(t1, t2);
}
```

有了这个 `cmp()` 函数，我们就可以很方便地完成第一次动规。

```cpp
int f[N];
void DP1()
{
	for (int i = 1; i <= n; i++)
	{
		for (int j = i; j >= 2; j--) //从后往前枚举，第一次枚举到的 j 一定是最大的。
			if (cmp(f[j-1], j-1, j, i))
			{
				f[i] = j;
				break;
			}
		if (f[i] == 0) f[i] = 1; //如果没有符合的，则从头开始算一个。 
	}
}
```

接下来，就是处理『最小开始下标』了。

设 $dp_i$ 表示将 $[i, n]$ 这一段拆成递增数，第一个数**最大**为 $num(i, f_i)$。

我们再画一张图。

![](https://cdn.luogu.com.cn/upload/image_hosting/5oywjxf7.png)

所以，状态转移方程如下。
$$
dp_i = \max\limits_{j = i}^{f_n - 1}\begin{cases}j & num(i, j) < num(j+1, dp_{j+1})\end{cases}
$$
并且有 $dp_{f[n]} = n$。

但是，这里并没有那么简单！

如果你直接就这样打了，可能只会获得 $\texttt{90pts}$。

错误原因是后面的 $0$ 造成的。

举例来说，有一个数 $\texttt{1234050}$。

如果单纯这样做，结果为 $\texttt{1,2,3,40,50}$。

发现 $f_7 = 6$，所以初始化 $dp_6 = 7$。

但是，第 $5$ 位是 $\texttt{0}$，根据样例，$\texttt{050}$ 也是符合的，并且末尾元素仍然最小！

显然，保持最优解的情况下，位数多一点更好。

所以，我们应该也让 $dp_5 = 7$。

  这样，结果为 $\texttt{12,34,050}$。

代码比较好打，只需要注意此处的判断即可。

```cpp
int dp[N];
void DP2()
{
	dp[f[n]] = n;
    //关键步骤，增添最后一个数的前导 0。
	int pos = f[n];
	for (pos = f[n]; pos-1 && a[pos-1] == '0'; pos--) dp[pos-1] = n;
	for (int i = pos-1; i; i--) //剩下的就和 DP1() 基本相等。
		for (int j = f[n] - 1; j >= i; j--)
			if (cmp(i, j, j+1, dp[j+1]))
			{
				dp[i] = j;
				break;
			}
}
```

大功告成，最后输出比较容易了。

```cpp
void Output()
{
	string ans = ""; //本质就是输出了，只不过要处理末尾逗号罢了。 
	for (int i = 1; i <= n; i = dp[i] + 1)
	{
		for (int j = i; j <= dp[i]; j++) ans += a[j];
		ans += ',';
	}
	ans.erase(ans.length()-1, 1); //擦除最后一位逗号。
	cout << ans; 
}
```

## 代码

其实上面就是代码了，组合在一起即可。

但还是给出完整代码。具体注释参照上面。

这份完整代码保留的注释是**调试语句**，大家可以看一下。

码量不大。

```cpp
#include <iostream>
#include <cstdio>
#define N 505
using namespace std;
string a;
int n;
void Input()
{
	cin >> a;
	n = a.length();
	a = '@' + a;
}
string num(int x, int y)
{
	string s = a.substr(x, y-x+1);
	while (s.length() > 1 && s[0] == '0') s.erase(0, 1);
	return s; 
}
bool Less(string x, string y)
{
	if (x.length() != y.length()) return x.length() < y.length();
	return x < y;
}
bool cmp(int x1, int y1, int x2, int y2)
{
	string t1 = num(x1, y1), t2 = num(x2, y2);
	return Less(t1, t2);
}
int f[N];
void DP1()
{
	for (int i = 1; i <= n; i++)
	{
		for (int j = i; j >= 2; j--)
			if (cmp(f[j-1], j-1, j, i))
			{
				f[i] = j;
				break;
			}
		if (f[i] == 0) f[i] = 1;
		//printf("dp[%d] = %d.\n", i, dp1[i]);
	}
	/*
	for (int i = 1; i <= n; i++) printf("f[%d] = %d.\n", i, f[i]);
	printf("\n");  */
}
int dp[N];
void DP2()
{
	dp[f[n]] = n;
	int pos = f[n];
	for (pos = f[n]; pos-1 && a[pos-1] == '0'; pos--) dp[pos-1] = n;
	//printf("pos = %d.\n", pos);
	for (int i = pos-1; i; i--)
		for (int j = f[n] - 1; j >= i; j--)
			if (cmp(i, j, j+1, dp[j+1]))
			{
				dp[i] = j;
				//printf("dp[%d] = %d.\n", i, dp2[i]);
				break;
			}
	//for (int i = 1; i <= n; i++) printf("dp[%d] = %d.\n", i, dp[i]);
}
void Output()
{
	string ans = "";
	for (int i = 1; i <= n; i = dp[i] + 1)
	{
		for (int j = i; j <= dp[i]; j++) ans += a[j];
		ans += ',';
	}
	ans.erase(ans.length()-1, 1);
	cout << ans; 
}
int main()
{
    Input();
    DP1();
    DP2();
    Output();
    return 0;
}
```

## 尾声

建议大家好好复盘一下状态转移方程。

顺便给出时间复杂度：

+ `cmp()` 函数的时间复杂度大约是 $O(n)$，实际运行时可以理解为常数。
+ 两次 $\texttt{DP}$ 的时间复杂度都是 $O(n^2 \times n = n^3)$，实际运行接近 $O(n^2)$。

码字不易，感谢大家观看，希望能帮助到大家！



---

## 作者：lzn (赞：94)

《拆分数列》解题报告

By lzn
动态规划常规题。

第一步先求出最后的那个数最小为多少。（为了叙述方便，记T(i,j)表示从原数列下标i取到j的数字组成的数。）只需正向dp一次，dp1[i]表示前i个数字分成任意多个递增数且最后的数最小时，最后的数为T(dp1[i],i)。则dp1[i]=max(j)，(T(dp1[j-1],j-1)<T(j,i))。

第二步要求最后一个数确定的情况下，前面的数字按字典序尽量大的解。类似上面的方法反向动归一次即可。

算法复杂度o(l^3)。由于数据大部分为随机，实际运行效率接近l^2。


---

## 作者：thwfhk (赞：20)

BLOG原文：[http://www.cnblogs.com/candy99/p/6070534.html](http://www.cnblogs.com/candy99/p/6070534.html)


我的实现是：


第一步，d[i]表示以i结尾的序列最后一个数最小的起始下标d[i]，转移同上


第二步，f[i]表示从i开始的序列第一个数最大的终止下标f[i]，转移f[i]=max{j|T(i,j)<T(j+1,f[j+1])}


打印时从1开始沿f走就行了


注意：


1.字符串比较处理前导0，并且我在遇到全0串时返回了false，因为这样的划分不合法


2.初始化d[i]=1


3.第一次95分，有一个数据1234050，我的程序无法把050划分成一个


解决措施是把最后一个数前面的前导0的f值都指向n


 

经验：


1.分两步求解


2.非常特别的状态表示，无法直接保存数的大小，所以保存序列中下标


3.字符处理成数字注意前导0


下面附上代码

    
        

    
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
typedef long long ll;
const int N=505,INF=2e9+5;
char s[N];
int n,a[N];
bool small(int l1,int r1,int l2,int r2){
    while(l1<=r1&&a[l1]==0) l1++;
    while(l2<=r2&&a[l2]==0) l2++;
    if(r1-l1+1==0||r2-l2+1==0) return false;//hello
    if(r1-l1+1<r2-l2+1) return true;
    if(r1-l1+1>r2-l2+1) return false;
    int len=r1-l1+1;
    for(int i=0;i<len;i++){
        if(a[l1+i]<a[l2+i]) return true;
        if(a[l1+i]>a[l2+i]) return false;
    }
    return false;
}
int d[N];
void dp1(){
    for(int i=1;i<=n;i++){
        d[i]=1;
        for(int j=i;j>=1;j--)
            if(small(d[j-1],j-1,j,i)) {d[i]=j;break;}
    }
    //for(int i=1;i<=n;i++) printf("d %d %d\n",i,d[i]);
}
int f[N];
void dp2(){
    f[d[n]]=n;int zero=d[n];
    while(a[zero-1]==0) f[zero-1]=n,zero--;
    for(int i=d[n]-1;i>=1;i--){
        for(int j=d[n]-1;j>=i;j--)
            if(small(i,j,j+1,f[j+1])) {f[i]=j;break;}
    }
    //for(int i=1;i<=n;i++) printf("f %d %d\n",i,f[i]);
    //system("pause");
}
int main(){
    scanf("%s",s+1);
    n=strlen(s+1);
    for(int i=1;i<=n;i++) a[i]=s[i]-'0';
    dp1();
    dp2();
    int pos=1,flag=0;
    while(pos<=n){//printf("pos %d %d\n",pos,f[pos]);
        if(flag) putchar(',');
        flag=1;
        for(int i=pos;i<=f[pos];i++) printf("%d",a[i]);
        pos=f[pos]+1;
    }
}
```

---

## 作者：Rapiz (赞：19)

第一次dp出处理最小末尾容易想出。关键是用第二次dp打印出字典序最小的方案。

第一次：

f[I]是处理到I的最小末尾

由于最小末尾是个很大的数，所以我们可以用下标来表示出它。

由于这个数一定在i终止，所以我们可以存它的起始位置。

重新定义状态：

f[I]是处理到I的最小末尾的起始下标

$$f[I]=max(j) | num(I,j)>num(f[j-1],j-1) , 1\leq j\leq i$$

注意cmp函数的编写要处理前导零

第二次：

同理，f2[I]是从n处理到I的最大末尾的结束下标

$$f[I]=max(j) | num(I,j)<num(f[j+1],j+1), I\leq j\le f[n]$$

其中初始化$f2[f[n]]=n$


有一个坑点。即[1-9]不能与最后一个数合并成一个数，而0可以。

如果第一次dp计算出最小末尾为50，但输入是……00050。

这样上面的转移方程不会将000和50分成一组，因为$I\leq j\le f[n]$。

这样000所在状态就和状态定义不符，它没表示出最大末尾。

因此dp前先将最后一个数的前导零全部特判。


```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
//#define DBG
using std::min;
using std::max;
const int LEN=510;
char str[LEN];
int f[LEN],n,t1[LEN],t2[LEN],f2[LEN];
void shownum(int a,int b){
    for(int i=a;i<=b;i++) printf("%d",str[i]);
}
int cmp1(int a,int b,int c,int d){
    if(d==0) return 1;
    memset(t1,0,sizeof(t1));
    memset(t2,0,sizeof(t2));
    int l1=0,l2=0;
    for(int i=b;i>=a;i--) t1[++l1]=str[i];
    for(int i=d;i>=c;i--) t2[++l2]=str[i];
    #ifdef DBG
    int i=l1;
    while(i>=1&&!t1[i]) i--;
    for(;i>=1;i--) printf("%d",t1[i]);
    printf(" cmp ");
    i=l2;
    while(i>=1&&!t2[i]) i--;
    for(;i>=1;i--) printf("%d",t2[i]);
    #endif
    l1=max(l1,l2);
    for(int i=l1;i;i--) if(t1[i]!=t2[i]) return t1[i]>t2[i];
    return -1;
}
int cmp(int a,int b,int c,int d){
    int ret=cmp1(a,b,c,d);
    #ifdef DBG
    printf(" --> %d\n",ret);
    #endif
    return ret;
}
int main(){
    scanf("%s",str+1);
    for(int i=1;str[i];i++,n++) str[i]-='0';
    for(int i=1;i<=n;i++) {
        f[i]=1;
        for(int j=i;j>=1;j--){
            if(cmp(j,i,f[j-1],j-1)==1) {
                f[i]=max(f[i],j);
                break;
            }
        }
    }
    f2[f[n]]=n;
    int cnt=0;
    for(int i=f[n]-1;i&&!str[i];i--) f2[i]=n,cnt++;
    for(int i=f[n]-1-cnt;i>=1;i--){
        f2[i]=i;
        for(int j=f[n]-1;j>=i;j--){
            if(cmp(i,j,j+1,f2[j+1])==0)
                f2[i]=max(f2[i],j);
                break;
        }
    }
    int pos=1;
    bool flg=1;
    while(pos<=n){
        if(flg) flg=0;
        else printf(",");
        shownum(pos,f2[pos]);
        pos=f2[pos]+1;
    }
}
```

---

## 作者：king_more (赞：14)

本来也不是很懂，写了好久，改了好久

争取写个题解让大家能简单理解

首先分两步

第一步先用正向DP求出最小结尾，这个很容易理解，f[ i ]表示以 i 为结尾的数字的最小结尾的开头，易证，如果要最小，这个j肯定最靠近i，所以我们可以从i向前枚举j,如果有一个 j 使f[ j ] 到 j - 1 比 j 到 i 小，说明 j 到 i可以接在f[ j ] 到 j - 1的后面，就可以直接接上
代码
```cpp
for(int i = 1;i <= len;i ++){
		f[i] = 1;
		for(int j = i;j >= 2;j --){
			if(compare(f[j - 1],j - 1,j,i)){
				f[i] = max(j,f[i]);
				break;
			}
		}
	}
```

然后是第二步

这道题要求最小字典序，我们得反过来考虑，如果一个数字典序最大，就是开头最大，我们用dp[ i ]表示从 i 到 dp[i] 是字典序最大，如果要字典序最大，同样 这个 j 要离 i 更远，所以从结尾开始枚举 j，如果存在一个 j 使从 i 到 j 比 j + 1 到 dp[j + 1]大 说明 i 到 j 能接到 j + 1 的最大字典序之前，就直接接上

代码
```cpp
int cnt = 0;
	for(int i = f[len] - 1;i;i --){//这边要特殊处理零的情况，最后一位的所有零都能直接到达最后
		if(s[i - 1] == '0'){
			dp[i] = len;
			cnt ++;
		}
		else break;
	}
	dp[f[len]] = len;
	for(int i = f[len] - 1 - cnt;i >= 1;i --){
		dp[i] = i;
 		for(int j = f[len] - 1;j >= i;j --){
 			if(compare(i,j,j + 1,dp[j + 1])){
 				dp[i] = max(j,dp[i]);
 				break;
			 }
		}
	}
```
比较函数也要特殊处理零的情况，去除前导零

上代码

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
const int M = 500;
int f[M + 5];
int dp[M + 5];
//int ch[M + 5];
string s;
int compare(int l,int r,int l_1,int r_1){
	l --;r --;l_1 --;r_1 --;
	while(s[l] == '0' && l <= r) l ++;
	while(s[l_1] == '0' && l_1 <= r_1) l_1 ++;
	
	if(r - l + 1 > r_1 - l_1 + 1) return false;
	if(r - l + 1 < r_1 - l_1 + 1) return true;
	for(int i = l;i <= r;i ++){
		if(s[i] > s[l_1 + i - l]) return false;
		if(s[i] < s[l_1 + i - l]) return true;
	}
	return false;
}
int main(){
	cin >> s;
	int len = s.size();
	/*for(int i = 1;i <= s.size();i ++){
		ch[i] = s[i - 1] - '0';
	}*/
	for(int i = 1;i <= len;i ++){
		f[i] = 1;
		for(int j = i;j >= 2;j --){
			if(compare(f[j - 1],j - 1,j,i)){
				f[i] = max(j,f[i]);
				break;
			}
		}
	}
	/*for(int i = 1;i <= len;i ++){
		printf("%d ",f[i]);
	}*/
	int cnt = 0;
	for(int i = f[len] - 1;i;i --){
		if(s[i - 1] == '0'){
			dp[i] = len;
			cnt ++;
		}
		else break;
	}
	dp[f[len]] = len;
	for(int i = f[len] - 1 - cnt;i >= 1;i --){
		dp[i] = i;
 		for(int j = f[len] - 1;j >= i;j --){
 			if(compare(i,j,j + 1,dp[j + 1])){
 				dp[i] = max(j,dp[i]);
 				break;
			 }
		}
	}
	/*for(int i = 1;i <= len;i ++){
		printf("%d",dp[i]);
	}*/
	int pos = 1;
	while(pos <= len){
		for(int i = pos;i <= dp[pos];i ++){
			putchar(s[i - 1]);
		}
		if(dp[pos] != len){
			printf(",");
		}
		pos = dp[pos] + 1;
	}
	return 0;
}
```


---

## 作者：凯特琳 (赞：7)

我有N2logN算法。虽然跑的时间很长。最后一个点有400ms，但是真的是N2算法。可能是各种预处理和后续处理太费时间。


数组F[I,J]表示总共使用了J个逗号，其中第J个在第I个后面，这时1..I的字符拆分后的最后一项，就是最大的那一项。N3算法。得了90分。

注意要自己定义 字符串比较函数。


这里想要讲一个优化，可以让复杂度下降一个维度，请先看90分的代码：

90代码：

```delphi

var f:array[0..500,0..500]of ansistring;
var ss:ansistring;
var chushihua:ansistring;
var ans:ansistring;
var shuchu:ansistring;
var i,j,m,n,len,k:longint;
function min(aa,bb:ansistring):ansistring;//用于更新F元素。
var la,lb,i,j:longint;
var aaa,bbb:ansistring;
begin
if aa=chushihua then exit(bb);
la:=length(aa);
lb:=length(bb);
aaa:=aa;
bbb:=bb;
while (la>=1)and(aaa[1]='0') do begin delete(aaa,1,1);dec(la);end;//去除前导0
while (lb>=1)and(bbb[1]='0') do begin delete(bbb,1,1);dec(lb);end;
la:=length(aaa);
lb:=length(bbb);
if la>lb then exit(bb);
if lb>la then exit(aa);//优先输出长度长的
if la=lb then
begin
if aaa>bbb then exit(bb);
if aaa<bbb then exit(aa);
if aaa=bbb then
begin
if la<lb then exit(aa)
else exit(bb);//如果aa和bb数值上相等，但是有不同位数的前导0，那么输出前导0小的。因为这样可以让前面的数更多，
                 //从而前面的数  可以更大
end;
end;
end;
function dayu(s1,s2:ansistring):boolean;//转移时的判断
var la,lb,i,j:longint;
var ss1,ss2:ansistring;
begin
la:=length(s1);
lb:=length(s2);
ss1:=s1;
ss2:=s2;
while (la>=1)and(ss1[1]='0') do begin delete(ss1,1,1);dec(la);end;
while (lb>=1)and(ss2[1]='0') do begin delete(ss2,1,1);dec(lb);end;
if la>lb then exit(true);
if la<lb then exit(false);
if la=lb then
begin
if ss1>ss2 then exit(true)
else exit(false);
end;
end;


begin
read(ss);
len:=length(ss);
for i:=1 to len do
chushihua:=chushihua+'9';
for i:=0 to len do
for j:=0 to len do
f[i,j]:=chushihua;
for i:=1 to len do
f[i,1]:=copy(ss,1,i);//初始化

for j:=2 to len do
begin
//abc:=false;
for i:=j to len do//用了J个逗号的时候，第一个字符应该是第J个（if can）
for k:=j-1 to i-1 do//用    用了J-1个逗号，第J-1个逗号在J-1..I-1位置的状态转移本状态
if dayu(copy(ss,k+1,i-k),f[k,j-1]) then
f[i,j]:=min(f[i,j],copy(ss,k+1,i-k));
if f[len,j]=chushihua then begin n:=j; break; end;//如果某一个状态全体不合法，那么得到可以加入的最多个逗号数
end;
if n=0 then n:=len;

//for j:=1 to len do
//for i:=1 to len do
//writeln('f[',i,',',j,']=',f[i,j]);


ans:=chushihua;
for i:=n downto 1 do
ans:=min(ans,f[len,i]);//搜索最后一个数最小
for i:=1 to n do
if f[len,i]=ans then//搜索第一个最优答案，因为逗号用的少，那么数字就相对大
begin
m:=i;
break;
end;
i:=len;
repeat//处理输出
shuchu:=','+f[i,m]+shuchu;
i:=i-length(f[i,m]);
m:=m-1;
until m=0;
delete(shuchu,1,1);//删掉前导逗号
writeln(shuchu);



end.

```
算法的正确性无疑。大致思想是f中记录的是分列开每一项，如果我们知道了最后一项，那么就可以知道前一个逗号出现在那里，然后读取前一个位置的f中的值，于是知道了分列开的前一项，以此类推，便知道了整个序列。




那么我们由上面的关于min函数比较字符串的部分我们可以发现：如果分裂的项有前导0，那么让0尽量少，如果没有前导0，那么让这一项尽量小，于是我们没必要在转移f[i,j]的时候查询f[j-1..i-1,j]这所有的值，只需要从i-1..j-1倒着往前找，找到第一个转移值就是最优的，然后break即可。于是有了一个强力剪枝。几乎把N降成了K(我们期望K<log2 N)。

AC代码：

```delphi

var f:array[0..500,0..500]of ansistring;
var ss:ansistring;
var chushihua:ansistring;
var ans:ansistring;
var shuchu:ansistring;
var i,j,m,n,len,k:longint;
function min(aa,bb:ansistring):ansistring;
var la,lb,i,j:longint;
var aaa,bbb:ansistring;
begin
if aa=chushihua then exit(bb);
la:=length(aa);
lb:=length(bb);
aaa:=aa;
bbb:=bb;
while (la>=1)and(aaa[1]='0') do begin delete(aaa,1,1);dec(la);end;
while (lb>=1)and(bbb[1]='0') do begin delete(bbb,1,1);dec(lb);end;
la:=length(aaa);
lb:=length(bbb);
if la>lb then exit(bb);
if lb>la then exit(aa);
if la=lb then
begin
if aaa>bbb then exit(bb);
if aaa<bbb then exit(aa);
if aaa=bbb then
begin
if la<lb then exit(aa)
else exit(bb);
end;
end;
end;
function dayu(s1,s2:ansistring):boolean;
var la,lb,i,j:longint;
var ss1,ss2:ansistring;
begin
la:=length(s1);
lb:=length(s2);
ss1:=s1;
ss2:=s2;
while (la>=1)and(ss1[1]='0') do begin delete(ss1,1,1);dec(la);end;
while (lb>=1)and(ss2[1]='0') do begin delete(ss2,1,1);dec(lb);end;
if la>lb then exit(true);
if la<lb then exit(false);
if la=lb then
begin
if ss1>ss2 then exit(true)
else exit(false);
end;
end;


begin
read(ss);
len:=length(ss);
for i:=1 to len do
chushihua:=chushihua+'9';
//chushihua:='max';
for i:=0 to len do
for j:=0 to len do
f[i,j]:=chushihua;
for i:=1 to len do
f[i,1]:=copy(ss,1,i);
for j:=2 to len do
begin
//abc:=false;
for i:=j to len do
for k:=i-1 downto j-1 do
if dayu(copy(ss,k+1,i-k),f[k,j-1]) then
begin
//f[i,j]:=min(f[i,j],copy(ss,k+1,i-k));
//if f[i,j]<>chushihua then break;
f[i,j]:=copy(ss,k+1,i-k);
break;
end;
if f[len,j]=chushihua then begin n:=j; break; end;
end;
if n=0 then n:=len;

//for j:=1 to len do
//for i:=1 to len do
//writeln('f[',i,',',j,']=',f[i,j]);



ans:=chushihua;
for i:=n downto 1 do
ans:=min(ans,f[len,i]);
for i:=1 to n do
if f[len,i]=ans then
begin
m:=i;
break;
end;
i:=len;
repeat
shuchu:=','+f[i,m]+shuchu;
i:=i-length(f[i,m]);
m:=m-1;
until m=0;
delete(shuchu,1,1);
writeln(shuchu);



end.

```



---

## 作者：槑小杨 (赞：4)

第一次从前往后dp,dp[i]表示包括第i位往前的，满足题目要求能得到的最小长度。这样就可以求出，最后一个最小的满足的数了。

求出最后一个最小的数后，从后往前dp,dp[i]表示从第i位开始往后，在满足题目要求的情况下，能得到的最大长度。这样就可以求出，按顺序依次最大的了。

```c

#include<iostream>
#include<cmath>
#include<cstdio>
#include<sstream>
#include<cstdlib>
#include<string>
#include<cstring>
#include<algorithm>
#include<vector>
#include<map>
#include<set>
#include<stack>
#include<list>
#include<queue>
#include<ctime>
#include<bitset>
#define eps 1e-6
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define ll __int64
#define LL long long
#define lson l,m,(rt<<1)
#define rson m+1,r,(rt<<1)|1
#pragma comment(linker, "/STACK:1024000000,1024000000")
using namespace std;
 
#define Maxn 90
char sa[Maxn];
int dp[Maxn];
 
bool isgreater(int i,int j,int m,int n) //判断从i~j的串是否大于从m~n的串
{
    while(sa[i]=='0'&&i<=j) //去掉前导0
        i++;
    while(sa[m]=='0'&&m<=n)//去掉前导0
        m++;
    if(i>j) //前者为0
        return false;
    if(m>n) //后者为0
        return true;
    int a=j-i+1,b=n-m+1; //长度，也就是位数
    if(a>b)
        return true;
    else if(a<b)
        return false;
    else
    {
        for(int k=i,p=m;k<=j;k++,p++) //位数相同，逐位比较
        {
            if(sa[k]>sa[p])
                return true;
            else if(sa[k]<sa[p])
                return false;
        }
    }
    return false; //等于的情况
}
int main()
{
    while(scanf("%s",sa+1)!=EOF)
    {
        int n=strlen(sa+1);
        if(n==1&&sa[1]=='0')
            break;
        dp[1]=1;//dp[i]表示从第i位往前共长度最小为dp[i]组成一个数字时的情况,
        for(int i=2;i<=n;i++)
        {
            dp[i]=i;
            for(int j=i-1;j>=1;j--)
            {
                if(isgreater(j+1,i,j-dp[j]+1,j))
                {
                    dp[i]=i-j; //求出满足题意的最小长度
                    break;
                }
            }
        }
 
        //然后从后往前，dp[i]表示在满足第一个条件的情况下，从i开始的最大长度
        int tt=n-dp[n]+1;
        dp[tt]=dp[n];
        for(int i=tt-1;i>=1;i--)
        {
            if(sa[i]=='0')
            {
                dp[i]=dp[i+1]+1;
                continue;
            }
            for(int j=tt;j>i;j--) //求出长度最大的
            {
                if(isgreater(j,j+dp[j]-1,i,j-1))
                {
                    dp[i]=j-i;
                    break;
                }
            }
 
        }
        for(int i=1;i<=dp[1];i++) //输出
            putchar(sa[i]);
        int pp=dp[1]+1;
        while(pp<=n)
        {
            putchar(',');
            for(int i=pp;i<pp+dp[pp];i++)
                printf("%c",sa[i]);
            pp=pp+dp[pp];
        }
        putchar('\n');
 
 
    }
   return 0;
}

```



---

## 作者：Warriorszx (赞：3)

很多题解都是被这个严格递增的条件卡掉了

给出一组数据：6666666666

正确输出应该是6，66，666，6666

而不是6，6，6，6，6，6，6，6，6，6

所以在判断数字大小的时候一定把大于小于等于三种情况分清

dp转移其他题解应该讲得都很清楚了

第一遍是处理出f[i],表示处理到i的尾数的起点

第二遍是处理出dp[i],表示从n处理到i的尾数最小时的尾数的起点

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
char s[510];
int num[510];
int t1[510],t2[510];
int f[510],dp[510];
int cmp(int l1,int r1,int l2,int r2)
{//判断大小 return 3表示大于 return 2表示 小于 return 1表示等于
	if(r2==0)
	{
		return 3;
	}
	memset(t1,0,sizeof(t1));
	memset(t2,0,sizeof(t2));
	int len1=0;
	int len2=0;
	for(int i=r1;i>=l1;i--)
	{
		t1[++len1]=num[i];
	}
	for(int i=r2;i>=l2;i--)
	{
		t2[++len2]=num[i];
	}
	int maxlen=max(len1,len2);
	for(int i=maxlen;i>0;i--)
	{
		if(t1[i]!=t2[i])
		{
			if(t1[i]>t2[i])
			{
				return 3;
			}
			if(t1[i]<t2[i])
			{
				return 2;
			}
		}
	}
	return 1;
}
int main()
{
//	freopen("testdata.in","r",stdin);
	scanf("%s",s);
	int len=strlen(s);
	for(int i=0;i<len;i++)
	{
		num[i+1]=s[i]-'0';
	}
	for(int i=1;i<=len;i++)
	{
		f[i]=1;
		for(int j=i;j>=1;j--)
		{
			if(cmp(j,i,f[j-1],j-1)==3)
			{
				f[i]=max(f[i],j);
				break;
			}
		}
	}
	dp[f[len]]=len;
	int cnt=0;
	for(int i=f[len]-1;i>0&&!num[i];i--)
	{
		dp[i]=len;
		cnt++;
	}
	for(int i=f[len]-1-cnt;i>0;i--)
	{
		dp[i]=i;
		for(int j=f[len]-1;j>=i;j--)
		{
			if(cmp(i,j,j+1,dp[j+1])==2)
			{
				dp[i]=max(dp[i],j);
				break;
			}
		}
	}
	int pos=1;
	bool flag=true;
	while(pos<=len)
	{
		if(flag)
		{
			flag=false;
		}
		else
		{
			printf(",");
		}
		for(int i=pos;i<=dp[pos];i++)
		{
			printf("%d",num[i]);
		}
		pos=dp[pos]+1;
	}
	return 0;
}
```

---

## 作者：zhangxiao666 (赞：2)

## 前言：

~~好久没写题解了，来水一发~~

可能对 dp 的理解不是太透彻，但还是希望能帮助到各位，求管理通过。

## 题意：

[题目传送门](https://www.luogu.com.cn/problem/P1415)

给定一个数串，要求用任意个逗号（可以为 $0$）将他们分割成一个数列，使得该数列严格递增，且满足：

1. 最后一个数最小。

2. 在满足 1 的条件下，字典序最大。

## 思路：
数据范围只有 $500$，加上一些经验（玄学），大致推测是一个 $O(n^3)$ 的 dp。

### 1.状态设计：

由于要让字典序最大，考虑求每个位置最长向后的延伸，即 **最大结束下标**。

且由于最后一个数要最小，可以先求出每位置最短向前的延伸，即**最小开始下标**，以此作为dp边界。

很明显，这种状态的设计是满足**最优子结构**和**无后效性**的，只是注意枚举顺序即可

### 2.状态转移公式：

为方便，下面称由 $i-j$ 组成的数为 $num(i,j)$。

#### (1)最小开始下标：
设这个东西为 $dp_i$。

那么 $i$ 位置前的序列中，最后一个数为 $num(dp_i,i)$。

那么对于一个位置 $j$，如何判断以 $j+1$ 为 $dp_i$ 的值是否合法呢？（即，前 $j$ 个划出去，$j$ 之后一直到 $i$ 组成一个数）

由于 $j$ 之前的序列中，最后一个数即为 $num(dp_j,j)$
所以，要满足严格递增，$num(j+1,i)$ 就要大于 $num(dp_j,j)$。

可以倒序枚举 $j$，第一个符合条件的位置即为 $dp_i$ 的值。

若没有找到合适的 $j$，即前 $i$ 个数无法在满足条件的情况下划分，换句话说，前 $i$ 个数组成单独一个数，显然 $dp_i=1$

#### (2)最小开始下标：
再设这个东西为 $f_i$（个人写 dp 的习惯）。

和上面一样，那么 $i$ 位置后的序列中，第一个数为 $num(i, f_i)$。

同理，对于位置 $j$, 为满足严格递增，只有在 $num(i,j-1) < num(j,f_j)$ 时，$j$ 作为 $dp_i$ 的值才合法。

同理，正序枚举，找到第一个符合条件的 $j$ 的值，设为 $f_i$，没有仍为 $1$。

对于边界，根据状态的定义，显然有 $f_{dp_n}=n$（满足最后一个数最小）。

但这样还不够。

考虑这样一个样例：$1234050$（第一篇题解的大佬给出的）

根据上面的方法，$dp_7=6$，所以 $f_6=7$，最终分割成：$1,2,3,40,50$

但显然可以将 $f_5=7$，方案为：$12,34,050$，最后一位实际仍是 $50$，但显然更优。

可见，在最后一位可以有前导零的情况下，应尽可能多的将前导零放到最后一位，这样在满足要求的情况下，会更优。

## 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 505;
int n;
string a;
int dp[N], f[N];
// dp[i] : min{sum(dp[i], i)}
// f[i] : max(sum(i, f[i]))

string num(int l, int r)
{
    string x = a.substr(l, r - l + 1);
    while (x.length() > 1 && x[0] == '0') x.erase(0, 1);
    return x;
}

bool cmp(string a1, string a2)
{
    if(a1.length() != a2.length()) return a1.length() < a2.length();
    return a1 < a2;
}

void work1()
{
    dp[1] = 1;
    for(int i = 2; i <= n; i++)
    {
        dp[i] = 1;
        for(int j = i - 1; j >= 1; j--)
        {
            if(cmp(num(dp[j], j), num(j + 1, i)))
            {
                dp[i] = j + 1;
                break;
            }
        }
    }
}

void work2()
{
    f[dp[n]] = n;
    int t = dp[n];
    //while(t > 1 && a[t - 1] == '0') f[dp[t]] = n, t--;
    for(int i = n - 1; i >= 1; i--)
    {
        for(int j = dp[n] - 1; j >= i; j--)
        {
            if(cmp(num(i, j), num(j + 1, f[j + 1])))
            {
                f[i] = j;
                break;
            }
        }
    }
}

void print()
{
    int x = 1;
    string ans;
    while(x <= n)
    {
        for(int i = x; i <= f[x]; i++) ans += a[i];
        x = f[x];
        if(x != n) ans += ',';
        x++;
    }
    cout << ans << "\n";
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> a;
    n = a.length();
    a = ' ' + a;
    work1();
    work2();
    print();
    return 0;
}
```






---

## 作者：QWsin (赞：2)

[color=blue]

然而作为一道完全没见过的字符串DP表示做不来 看题解嘛= =

看了题解各种乱搞之后A了

第一步先求出最后的那个数最小为多少。（为了叙述方便，记T(i,j)表示从原数列下标i取到j的数字组成的数。）只需正向dp一次，dp1[i]表示前i个数字分成任意多个递增数且最后的数最小时，最后的数为T(dp1[i],i)。则dp1[i]=max(j)，(T(dp1[j-1],j-1)<T(j,i))。

取max明显是为了使最后的数变小嘛= =  括号里的是条件  题目要求单增序列

第二步要求最后一个数确定的情况下，前面的数字按字典序尽量大的解。类似上面的方法反向动归一次即可。

PS： 并没有告诉我怎么反向DP于是自己yy解法

先来搞T数组的问题  最长500位  开始逗比地用的int   对拍的时候直接爆掉  又不想用高精（LongLong也会爆的嘛）

然后呢想到刷水题的时候一个技巧 = =用string存  比较的时候先比位数再比字典序（可自己实测直接比字典序的后果）

开始还不小心把前导0存进去了。。  好像就能完成了吧。  标程没处理T数组直接传下标比较好像是要快一点短一点。。

﻿倒过来DP的时候如法炮制把dp（i）表示i开头时以dp（i）结尾就可以了  注意要把选出来的最小数的前导0的dp值处理一下（也可实测后果）

[/color]

[delete] 我调了半天因为没有C++代码，题解也是有点懂又懂不完那种[/delete]

```cpp

#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=500+10;

char s[maxn];
int n,p=1,real[maxn][maxn];
string num[maxn][maxn];

void init_data()
{    
    scanf("%s",s+1);
    n=strlen(s+1);
    for(;s[p]=='0';p++,n--);
    if(p>1)
      for(int i=1;i<=n;i++)
        s[i]=s[i+p-1];
    for(int i=1;i<=n;i++)
      for(int j=i;j<=n;j++)
      {
          if(num[i][j-1].length()==0&&s[j]=='0')continue;
          else num[i][j]=num[i][j-1]+s[j];
//          real[i][j]=real[i][j-1]*10+s[j]-'0';
//          printf("%d %d ",i,j);
//          cout<<num[i][j]<<endl;
      }  
}

int check(string a,string b)
{
    if(a==b) return -1;
//    cout<<a<<endl;
//    int lena=a.length(),lenb=b.length();
    if(a.length()!=b.length()) return a.length()>b.length();
    else return a>b;
}

int dp1[maxn];
void dp_1()
{
    for(int i=1;i<=n;i++) dp1[i]=1;
    for(int i=2;i<=n;i++)
      for(int j=1;j<i;j++)
        if(check(num[dp1[j]][j],num[j+1][i])==0)
          dp1[i]=max(dp1[i],j+1);
//    printf("%d",num[dp1[n]][n]);
    return ;
}

void print(int l,int r)
{
    for(int i=l;i<=r;i++)
      printf("%c",s[i]);
}

int dp2[maxn];
void dp_2()
{
    int cnt=1;
    for(int i=dp1[n]-1;i&&s[i]=='0';i--) dp2[i]=n,cnt++;
    dp2[dp1[n]]=n;
    for(int i=dp1[n]-cnt;i>=1;i--)
    {
        for(int j=dp1[n];j>i;j--)
          if(check(num[j][dp2[j]],num[i][j-1])==1)
          {
                dp2[i]=max(dp2[i],j-1);
          }
    }
    if(p) while(--p) printf("0");
    for(int i=1;i<=n;i=dp2[i]+1)
    {
        print(i,dp2[i]);
        if(dp2[i]!=n) printf(",");
    }
}

int _[maxn];
void debug()
{
    for(int i=1;i<=n;i++)
      _[i]=s[i]-'0';
}

int main()
{
//    freopen("std.in","r",stdin);
//    freopen("my.out","w",stdout);
    init_data();
    debug();
    dp_1();
    dp_2();
    
    return  0;
}

```(c/c++)


---

## 作者：Conless (赞：1)

欢迎来[我的博客](https://www.luogu.com.cn/blog/Conless/post-xie-ti-bao-gao-p2282-li-shi-nian-fen-p1415-chai-fen-shuo-lie)查看

强化版 [[HNOI2003]历史年份](https://www.luogu.com.cn/problem/P2282) & 弱化版 [拆分数列](https://www.luogu.com.cn/problem/P1415)

我们先来考虑弱化版：

首先进行正向 $dp$：

设 $f_i$ 表示以 $i$ 为结尾的最大前缀的起点下标，$num_{i,j}$ 为下标 $i-j$ 构成的数字。显然，这个下标越大（接近 $i$），前缀越小，得到的答案就越优，所以：

$f_i=max\{j\}, j\in [1,i] \& \quad num_{f_{j-1},j-1}<num_{j,i}$

```cpp
    f1[1] = 1;
    for (int i = 2; i <= n; i++)
    {
        f1[i] = 1;
        for (int j = i; j >= 1; j--)
            if (comp(f1[j - 1], j, i))
            {
                f1[i] = j;
                break;
            }
    }
```

$comp()$的朴素实现方式：
```cpp
bool comp(int l, int m, int r)
{
    int len1 = m - l, len2 = r - m + 1;
    int st1 = l, ed1 = m - 1;
    int st2 = m, ed2 = r;
    if (len1 < len2)
    {
        while (st2 - m + 1 <= len2 - len1)
        {
            if (str[st2] != '0')
                return 1;
            st2++;
        }
    }
    if (len1 > len2)
    {
        while (st1 - l + 1 <= len1 - len2)
        {
            if (str[st1] != '0')
                return 0;
            st1++;
        }
    }
    len1 = len2 = min(len1, len2);
    for (int i = 0; i < len1; i++)
        if (str[st1 + i] != str[st2 + i])
            return str[st2 + i] > str[st1 + i];
    return 0;
}
```

再考虑反向 $dp$：

设 $f_i$ 表示以 $i$ 为起点的最大后缀的终点下标，显然，这个下标越大（接近 $n$），后缀越大，得到的答案就越优，所以：

$f_i=max\{j\}, j\in [i,j] \& \quad num_{i,j}<num_{j+1,f_{j+1}}$

但是我们必须考虑到前导零对一个数字的大小是没有影响的，那么对于第一遍正向 $dp$ 得出的最大的最后一个数，可以在其前面加上若干个前导零，这些前导零在 $f$ 数组中指向的下标应该都为 $n$
```cpp
    int las = n;
    while (las >= f1[n] || str[las] == '0')
    {
        f2[las] = n;
        las--;
    }
    for (int i = las; i >= 1; i--)
    {
        f2[i] = i;
        for (int j = n - 1; j > i; j--)
            if (comp(i, j + 1, f2[j + 1]))
            {
                f2[i] = j;
                break;
            }
    }
```

那么我们就能完成弱化版了

时间复杂度：

$DP: O(n^2)$

每次比较：$O(n)$

总时间复杂度：$O(n^3)$

当然，这样的复杂度并不能帮助我们通过其强化版：

$T=1000, n=2000$，期望时间复杂度$O(Tn)-O(Tnlogn)$

对于原算法考虑进行优化：
1. 对于第一遍 $dp$，考虑将每一个确定的 $f_j$ 直接往后更新，凡是满足 $num_{f[j], j} < num_{j+1, i}$ 的 $f_i$，均可以被 $j$ 更新，很显然，每一次均可更新一个区间 $[i_{min}, n]$

2. 对于第二遍 $dp$，考虑将每一个确定的 $f_j$ 直接往前更新，凡是满足 $num_{i, j} < num_{j+1, f_{j+1}}$ 的 $f_i$，均可以被 $j$ 更新，很显然，每一次均可更新一个区间 $[i_{max}, j]$

以上两步，均可以使用线段树将 $DP$ 将填表的时间复杂度优化至 $O(nlogn)$

但是我们仍然无法快速得到两次 $DP$ 的 $i_{min}, i_{max}$，此时我们考虑直接用位数进行比较，用第一次DP进行举例：

$\because num_{f_{j-1},j-1}<num_{j,i}$

$\therefore (j-1)-f_{j-1}+1 \le i-j+1$（不考虑前导零）

$\therefore i \ge 2j-f_{j-1}-1$

若考虑前导零，可以预处理将 $i$ 左边与右边（包括 $i$）的第一个非零数字求出来，表示为 $lasn_i$ 与 $nexn_i$，那么上式将变为：

$i_{min} = nexn_i + (i - nexn_{f_{i - 1}}) - 1$

注意到推导的前两位并非等价转化，那么我们再进行一次 $comp(f_{j-1}, j, i_{max})$，若不合法再往后跳一位即可

这样的话我们的理论时间复杂度就降到了 $O(Tn^2)$，当然实际上比较函数是完全跑不满的，再套一个 $O2$ 可能能卡过

这个时候我们再来考虑每一次 $comp$ 函数的优化，之前考虑的是朴素比较，但由于我们现在只需要知道两个由数字构成的字串的大小，不妨考虑哈希算法：

```cpp
void pre_hash()
{
    num[0] = 0;
    for (int i = 1; i <= n; i++)
        num[i] = (1LL * num[i - 1] * 10 + str[i] - '0') % MOD;
}

inline bool equal(int st1, int st2, int len) 
{
    int ed1 = st1 + len - 1, ed2 = st2 + len - 1;
    return (num[ed1] - fac[len] * num[st1 - 1] % MOD + MOD) % MOD == (num[ed2] - fac[len] * num[st2 - 1] % MOD + MOD) % MOD;
}
```

但是，他假了！！！
![](https://cdn.luogu.com.cn/upload/image_hosting/yg0q5u4j.png)

可能是我的模数或进制写的太弱了，所以单哈希就这样被卡了，于是最后改了个双哈希终于勉强过了

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

typedef long long ll;

const int MAXN = 2e3 + 5;
const ll MOD1 = 1e9 + 7, MOD2 = 19260817;

int T, n;
char str[MAXN];
ll num1[MAXN], num2[MAXN], fac1[MAXN], fac2[MAXN];
int f1[MAXN], f2[MAXN];
int nexn[MAXN], lasn[MAXN];

class SegmentTree
{

#define sn segTree[node]

    struct TreeNode {
        int l, r;
        int lson, rson;
        int data;
    } segTree[MAXN << 2];

    void pushdown(int node)
    {
        if (sn.data)
        {
            segTree[sn.lson].data = max(segTree[sn.lson].data, sn.data);
            segTree[sn.rson].data = max(segTree[sn.rson].data, sn.data);
            sn.data = 0;
        }
    }

public:

    void build(int node, int l, int r)
    {
        sn.l = l;
        sn.r = r;
        sn.data = 0;
        if (l != r)
        {
            sn.lson = node << 1;
            sn.rson = node << 1 | 1;
            int mid = (l + r) >> 1;
            build(sn.lson, l, mid);
            build(sn.rson, mid + 1, r);
        }
    }

    int ask(int node, int pos)
    {
        if (sn.l == sn.r)
            return sn.data;
        pushdown(node);
        int mid = (sn.l + sn.r) >> 1;
        if (pos <= mid)
            return ask(sn.lson, pos);
        else return ask(sn.rson, pos);
    }

    void change(int node, int l, int r, int val)
    {
        if (l > sn.r || r < sn.l)
            return;
        if (l <= sn.l && r >= sn.r)
            sn.data = max(sn.data, val);
        else {
            pushdown(node);
            change(sn.lson, l, r, val);
            change(sn.rson, l, r, val);
        }
    }
} stree;

inline bool equal(int st1, int st2, int len) 
{
    int ed1 = st1 + len - 1, ed2 = st2 + len - 1;
    bool res1 = (num1[ed1] - fac1[len] * num1[st1 - 1] % MOD1 + MOD1) % MOD1
             == (num1[ed2] - fac1[len] * num1[st2 - 1] % MOD1 + MOD1) % MOD1;
    bool res2 = (num2[ed1] - fac2[len] * num2[st1 - 1] % MOD2 + MOD2) % MOD2
             == (num2[ed2] - fac2[len] * num2[st2 - 1] % MOD2 + MOD2) % MOD2;
    return res1 & res2;
}

bool comp(int l, int m, int r)
{
    int st1 = l, ed1 = m - 1;
    int st2 = m, ed2 = r;
    st1 = nexn[st1];
    st2 = nexn[st2];
    int len1 = ed1 - st1 + 1, len2 = ed2 - st2 + 1;
    if (len2 <= 0)
        return 0;
    if (len1 <= 0)
        return 1;
    if (len1 != len2)
        return len1 < len2;
    int le = 0, ri = len1 - 1, res = -1;
    while (le <= ri)
    {
        int mid = (le + ri) >> 1;
        if (equal(st1, st2, mid))
        {
            res = mid;
            le = mid + 1;
        }
        else ri = mid - 1;
    }
    return str[st1 + res] < str[st2 + res];
}

void pre_pow()
{
    fac1[0] = 1LL;
    for (int i = 1; i <= 2000; i++)
        fac1[i] = 1LL * fac1[i - 1] * 10 % MOD1;
    fac2[0] = 1LL;
    for (int i = 1; i <= 2000; i++)
        fac2[i] = 1LL * fac2[i - 1] * 11 % MOD2;
}

void pre_hash()
{
    num1[0] = 0;
    for (int i = 1; i <= n; i++)
        num1[i] = (1LL * num1[i - 1] * 10 + str[i] - '0') % MOD1;
    num2[0] = 0;
    for (int i = 1; i <= n; i++)
        num2[i] = (1LL * num2[i - 1] * 11 + str[i] - '0') % MOD2;
}

void deal_zero()
{
    for (int i = n, j = n + 1; i >= 1; i--)
    {
        if (str[i] != '0')
            j = i;
        nexn[i] = j;
    }
    for (int i = 1, j = 0; i <= n; i++)
    {
        if (str[i] != '0')
            j = i;
        lasn[i] = j;
    }
}

int main()
{
    pre_pow();
    while (scanf("%s", str + 1) != EOF)
    {
        n = strlen(str + 1);
        pre_hash();
        deal_zero();
        stree.build(1, 1, n);
        stree.change(1, 1, n, 1);
        f1[1] = 1;
        for (int i = 2; i <= n; i++)
        {
            int nex = nexn[i] + (i - nexn[f1[i - 1]]) - 1;
            if (!comp(f1[i - 1], i, nex))
                nex++;
            stree.change(1, nex, n, i);
            f1[i] = stree.ask(1, i);
        }
        int las = lasn[f1[n] - 1];
        stree.build(1, 1, n);
        stree.change(1, las + 1, n, n);
        f2[n] = n;
        for (int i = n - 1; i >= 1; i--)
        {
            f2[i] = max(i, stree.ask(1, i));
            int fir = i - (f2[i + 1] - nexn[i + 1]);
            if (!comp(fir, i + 1, f2[i + 1]))
                fir++;
            fir = lasn[fir - 1] + 1;
            if (fir < 1) fir = 1;
            stree.change(1, fir, i - 1, i);
        }
        
        for (int i = 1; i <= n; i++)
        {
            int j = i;
            while (j <= f2[i] && j <= n)
                putchar(str[j++]);
            i = j - 1;
            if (i != n) putchar(',');
        }
        putchar('\n');
    }
    return 0;
}
```

---

## 作者：樱木花道2020 (赞：1)

# 官方数据中的特殊数据：

## 1234050

它可以看作:

1,23,40,50

12,34,050

# 作为类比的数据：

## 3526080

它可以看作：

3，52,60,80

3,5,26,080

到底那一组解最优呢？

# 解决方法

在第二次遍历的数组dp2[len]中，把最后一个数前面的前导0的dp2值都指向n

道理在于这样可以在保证正确的前提下，让一些点在dp2数组的值有机会指向更后面的点

在一下代码中运行上述两组数据，注意输出信息中带有大于、小于符号的那些行

在编程中，善于输出中间结果很重要

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 505;

int len;
char str[MAXN];
int dgt[MAXN];//digit
int dp1[MAXN];
int dp2[MAXN];

void init(){
	cin >> str+1;
	len = strlen(str+1);
	for(int i = 1; i <= len; i++){
		dgt[i] = str[i]-'0';
	}
}
int cmp(int l1, int r1, int l2, int r2){
	cout << "compare ";
	cout << "[" << l1 << ", " << r1 << "]:";
	for(int k = l1; k <= r1; k++){
	   	cout << dgt[k];
	}
	cout << " to ";
	cout << "[" << l2 << ", " << r2 << "]:";
	for(int k = l2; k <= r2; k++){
		cout << dgt[k];
	}
	cout << endl;
	
	while(dgt[l1] == 0 && l1 <= r1){l1++;};
	while(dgt[l2] == 0 && l2 <= r2){l2++;};
	if(l1 > r1 || l2 > r2){return 0;}
	if(r1-l1 > r2-l2){return 1;}
	if(r1-l1 < r2-l2){return 0;}
	for(int pos = 0; pos <= r1-l1; pos++){
		if( dgt[l1+pos] > dgt[l2+pos] ){
			return 1;
		}
		if( dgt[l1+pos] < dgt[l2+pos] ){
			return 0;
		}
	}
	return 0;
}
void f1(){
	for(int i = 1; i <= len; i++){
		dp1[i] = 1;
		for(int j = i; j >= 1; j--){
			if( cmp( j, i, dp1[j-1], j-1 ) ){
//				cout << "[" << j << ", " << i << "]:";
//			    for(int k = j; k <= i; k++){
//			    	cout << dgt[k];
//				}
//				cout << " > ";
//				cout << "[" << dp1[j-1] << ", " << j-1 << "]:";
//				for(int k = dp1[j-1]; k <= j-1; k++){
//					cout << dgt[k];
//				}
//				cout << endl;
				dp1[i] = j;
				break;
			}
		}
	}
	for(int i = 1; i <= len; i++){
		cout << "dp1[" << i << "] is " << dp1[i] << endl; 
	}
	cout << endl;
}
void f2(){
	dp2[ dp1[len] ] = len;
	
	int zero = dp1[len]-1;
	while(dgt[zero] == 0){dp2[zero] = len; zero--;}
	
	for(int i = dp1[len]-1; i >= 1; i--){
		for(int j = dp1[len]-1; j >= i; j--){
			if( cmp( j+1, dp2[j+1], i, j ) ){
				cout << "[" << j+1 << ", " << dp2[j+1] << "]:";
			    for(int k = j+1; k <= dp2[j+1]; k++){
			    	cout << dgt[k];
				}
 				cout << " > ";//注意观察这里的输出
				cout << "[" << i << ", " << j << "]:";
				for(int k = i; k <= j; k++){
					cout << dgt[k];
				}
				cout << endl;
				dp2[i] = j;
				break;
			}
		}
	}
	for(int i = 1; i <= len; i++){
		cout << "dp2[" << i << "] is " << dp2[i] << endl; 
	}
	cout << endl;
}
void print_result(){
	int first = 1;
	for(int i = 1; i <= len; i++){
		if(first == 1){
			first = 0;
		}else{
			cout << ",";
		}
		for(int j = i; j <= dp2[i]; j++){
			cout << dgt[j];
		}
		i = dp2[i];
	}
}
int main(){
	init();
	f1();
	f2();
	print_result();
	return 0;
}
```


---

## 作者：block_joker (赞：1)

翻了下题解，好像没有和我一样的做法。。

首先求出最小的最后一个数，用f[n]表示以n结尾，在最小化的最后一位的前提下的最后一位的下标。不过要注意的是，如果这个最后一位能够加入前导0的话，就一定要加入这个0，特判一下就行了. 

不过我觉得这样做是有问题的，应该将几个最小最后一个数的情况算出来，比较取最优。可能是数据太水，也可能是有证明，不过过了我就懒得改了。。

(这个f数组没必要反复求，我当时不知道怎么想的。。懒得改了）

然后用m[i][u]表示从i到u可以出现在某个合法的逗号分割中，初始化m[r][n] = 1.
r为刚刚求出来的最小最后一个数的下标。

转移：m[i][u] = 1,存在m[u + 1][j] = 1 且 s[i .. u] < s[u + 1 .. j].

输出顺着m走就行了。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<map>
#include<cmath>
#include<ctime>
#include<cstring>
#define ULL unsigned long long
#define LL long long
using namespace std;
const int N = 505;
char s[N];
int f[N],n;
bool bj(int x,int y,int a,int b){
//	if(x == -1 || y == -1)return 1;
	while(x < y && s[x] == '0')x++;
	while(a < b && s[a] == '0')a++;
	if(y - x != b - a)return y - x < b - a;

	for(int i = 0 ; x + i <= y ; i++)
	if(s[x + i] != s[a + i])return s[x + i] < s[a + i];	
	return 0;
}
bool jud(int k){
	for(int i = 1 ; i < k ; i++)
	for(int u = i ; u ; u--)
	if(bj(f[u - 1],u - 1,u,i)){
		f[i] = u;
		break;
	}
//	for(int i = 0 ; i < k ; i++)
//	cout<<f[i]<<' ';
	return bj(f[k - 1],k - 1,k,n);
}
bool m[N][N];
void build(int k){
	m[k][n] = 1;
	for(int i = k - 1 ; ~i ; i--)
	for(int u = i ; u < k ; u++)
	for(int j = u + 1 ; j <= n ; j++)
	if(m[u + 1][j] && bj(i,u,u + 1,j)){
	m[i][u] = 1;
	break;
	}
}
void out(){
	int now = 0;
	while(now <= n){
		if(now)printf(",");
	    int i = n ;
		for(; i >= now ; i--)
		if(m[now][i])break;
		for(int u = now ; u <= i ; u++)
		printf("%c",s[u]);
		now = i + 1;
	}
}
int main() {
//	while(scanf("[%d]",&x)){
//		printf("[%d]\n",x);
		scanf("%s",s);
		int l = 0,r = strlen(s) - 1; 
		n = strlen(s) - 1;
		for( ; r ; r--)
		if(jud(r))break;
		while(r && s[r - 1] == '0' && jud(r - 1))r--;
		build(r);
		out();
	//	cout<<endl;
//	}
	return 0;
}
```
时间复杂度O（n ^ 4 + n ^ 2）

对，你没有看错，过了还跑得飞快，200ms+



------------
 好吧，一不小心找到了一组hack数据
 
 114050
 
 所以还是得老老实实的把所有最后一个值最小的情况算出来，比较取最优。。
 
 ```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<map>
#include<cmath>
#include<ctime>
#include<cstring>
#define ULL unsigned long long
#define LL long long
using namespace std;
const int N = 505;
char s[N];
int f[N],n;
bool bj(int x,int y,int a,int b){
	while(x < y && s[x] == '0')x++;
	while(a < b && s[a] == '0')a++;
	if(y - x != b - a)return y - x < b - a;
	for(int i = 0 ; x + i <= y ; i++)
	if(s[x + i] != s[a + i])return s[x + i] < s[a + i];	
	return 0;
}
void jud(int k){
	for(int i = 1 ; i < k ; i++)
	for(int u = i ; u ; u--)
	if(bj(f[u - 1],u - 1,u,i)){
		f[i] = u;
		break;
	}
}
bool m[N][N],ans[N][N];
void build(int k){
for(int i = 0 ; i <= n ; i++)
for(int u = 0 ; u <= n ; u++)m[i][u] = 0;	
	m[k][n] = 1;
	for(int i = k - 1 ; ~i ; i--)
	for(int u = i ; u < k ; u++)
	for(int j = u + 1 ; j <= n ; j++)
	if(m[u + 1][j] && bj(i,u,u + 1,j)){
	m[i][u] = 1;
	break;
	}
}
void out(){
	int now = 0;
	while(now <= n){
		if(now)printf(",");
	    int i = n ;
		for(; i >= now ; i--)
		if(ans[now][i])break;
		for(int u = now ; u <= i ; u++)
		printf("%c",s[u]);
		now = i + 1;
	}
}
bool judge(){
	int now1 = 0,now2 = 0;
	while(now1 <= n){
	    int nxt1 = n,nxt2 = n;
		for(; nxt1 >= now1 ; nxt1--)
		if(ans[now1][nxt1])break;
		for(; nxt2 >= now2 ; nxt2--)
		if(m[now2][nxt2])break;
		if(!bj(now1,nxt1,now2,nxt2) && !bj(now2,nxt2,now1,nxt1)){
		now1 = nxt1 + 1,now2 = nxt2 + 1;
		}
		else{
			return bj(now1,nxt1,now2,nxt2);
		}
	}
	return 1;	
}
void copy(){
for(int i = 0 ; i <= n ; i++)
for(int u = 0 ; u <= n ; u++)ans[i][u] = m[i][u];
}	
int main() {
		scanf("%s",s);
		int r = strlen(s) - 1; 
		n = strlen(s) - 1;
		jud(n + 1);
		for( ; r ; r--)
		if(bj(f[r - 1],r - 1,r,n))break;
		build(r);
		copy();
		while(r && s[r - 1] == '0'){
		--r;
		if(bj(f[r - 1],r - 1,r,n)){
		build(r);
		if(judge())copy();
		}
		}
		out();
	return 0;
}
```
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<map>
#include<cmath>
#include<ctime>
#include<cstring>
#define ULL unsigned long long
#define LL long long
using namespace std;
const int N = 505;
char s[N];
int f[N],n;
bool bj(int x,int y,int a,int b){
	while(x < y && s[x] == '0')x++;
	while(a < b && s[a] == '0')a++;
	if(y - x != b - a)return y - x < b - a;
	for(int i = 0 ; x + i <= y ; i++)
	if(s[x + i] != s[a + i])return s[x + i] < s[a + i];	
	return 0;
}
void jud(int k){
	for(int i = 1 ; i < k ; i++)
	for(int u = i ; u ; u--)
	if(bj(f[u - 1],u - 1,u,i)){
		f[i] = u;
		break;
	}
}
bool m[N][N],ans[N][N];
void build(int k){
for(int i = 0 ; i <= n ; i++)
for(int u = 0 ; u <= n ; u++)m[i][u] = 0;	
	m[k][n] = 1;
	for(int i = k - 1 ; ~i ; i--)
	for(int u = i ; u < k ; u++)
	for(int j = u + 1 ; j <= n ; j++)
	if(m[u + 1][j] && bj(i,u,u + 1,j)){
	m[i][u] = 1;
	break;
	}
}
void out(){
	int now = 0;
	while(now <= n){
		if(now)printf(",");
	    int i = n ;
		for(; i >= now ; i--)
		if(ans[now][i])break;
		for(int u = now ; u <= i ; u++)
		printf("%c",s[u]);
		now = i + 1;
	}
}
bool judge(){
	int now1 = 0,now2 = 0;
	while(now1 <= n){
	    int nxt1 = n,nxt2 = n;
		for(; nxt1 >= now1 ; nxt1--)
		if(ans[now1][nxt1])break;
		for(; nxt2 >= now2 ; nxt2--)
		if(m[now2][nxt2])break;
		if(!bj(now1,nxt1,now2,nxt2) && !bj(now2,nxt2,now1,nxt1)){
		now1 = nxt1 + 1,now2 = nxt2 + 1;
		}
		else{
			return bj(now1,nxt1,now2,nxt2);
		}
	}
	return 1;	
}
void copy(){
for(int i = 0 ; i <= n ; i++)
for(int u = 0 ; u <= n ; u++)ans[i][u] = m[i][u];
}	
int main() {
		scanf("%s",s);
		int r = strlen(s) - 1; 
		n = strlen(s) - 1;
		jud(n + 1);
		for( ; r ; r--)
		if(bj(f[r - 1],r - 1,r,n))break;
		build(r);
		copy();
		while(r && s[r - 1] == '0'){
		--r;
		if(bj(f[r - 1],r - 1,r,n)){
		build(r);
		if(judge())copy();
		}
		}
		out();
	return 0;
}
```
 实际上远远达不到时间复杂度的上限，所以可以过

---

## 作者：jkchen (赞：1)

Blog原文：https://blog.csdn.net/jk_chen_acmer/article/details/87183130

>为什么一眼搜索的题会出现在dp区。。。

**大小比较函数：**

```c
int compare(int ll,int rr,int l,int r){
    while(ll<rr&&x[ll]=='0')ll++;
    while(l<r&&x[l]=='0')l++;
    if(rr-ll>r-l)return 1;
    if(rr-ll<r-l)return -1;
    for(;ll<=rr;ll++,l++){
        if(x[ll]>x[l])return 1;
        if(x[ll]<x[l])return -1;
    }
    return 0;
}
```
第一要求最后一个数最小，那么先从后往前，得到一个最小的满足要求的段。这个段只要可以做到满足要求，那么答案段就是这个。（这个串的前面可能有前缀0）

这个过程需要用到记忆化搜索，即L~R这个区间可能被搜索多次，如果这个区间不能达到要求，那么标记-剪枝。

***
找到最后一段后，再要求前面的数大。那么枚举从大开始，`1~L-1`到`1~1`，如果满足要求则打标记，ans[i]=1表示第i个字母后面插逗号。

往后搜的过程也需要记忆化搜索-打标记，我第一发忘记`vis[l][r]=1;`就TLE了。

***
**细节：**

 1. 一个段全是0也判不符合，要求打标记。
 2. 最后一段L==1则直接输出即可。
 3. 最后一段L前面可能有前缀0，所以往后搜的结束标志为：右边界落在为0的那个区间内。

```c
#include<bits/stdc++.h>
using namespace std;

char x[509];
int len;

int compare(int ll,int rr,int l,int r){
    while(ll<rr&&x[ll]=='0')ll++;
    while(l<r&&x[l]=='0')l++;
    if(rr-ll>r-l)return 1;
    if(rr-ll<r-l)return -1;
    for(;ll<=rr;ll++,l++){
        if(x[ll]>x[l])return 1;
        if(x[ll]<x[l])return -1;
    }
    return 0;
}

bool isempty(int l,int r){
    for(int i=l;i<=r;i++)if(x[i]!='0')return 0;
    return 1;
}

bool vis[509][509];//记忆化
bool check(int L,int R){
    if(isempty(L,R)){vis[L][R]=1;return 0;}
    if(L==1)return true;
    for(int i=L-1;i>=1;i--){
        if(vis[i][L-1])continue;
        if(compare(i,L-1,L,R)<0){
            if(check(i,L-1))return 1;
        }
        else break;//数变大就更不行了
    }
    vis[L][R]=1;//标记
    return 0;
}

int L,LL;
bool ans[509];

bool check2(int l,int r){
    if(vis[l][r])return 0;
    if(isempty(l,r)){vis[l][r]=1;return 0;}
    if(compare(l,r,L,len)>=0){vis[l][r]=1; return 0;}
    
    //搜索结束
    if(r>=LL-1&&r<=L-1){ans[r]=1;return 1;}

    for(int i=L-1;i>r;i--){
        if(compare(r+1,i,L,len)>=0){
            vis[r+1][i]=1;continue;
        }
        if(compare(r+1,i,l,r)<=0)continue;
        if(check2(r+1,i)){
            ans[i]=1;return 1;
        }
    }
    vis[l][r]=1;//标记
    return 0;
}

int main(){
    scanf("%s",x+1);
    len=strlen(x+1);
    L=1;
    
    for(L=len;L>=1;L--){
        if(check(L,len)){break;}
    }
    if(L==1)return 0*printf("%s\n",x+1);

    LL=L;while(LL>1&&x[LL-1]=='0')LL--;

    memset(vis,0,sizeof(vis));
    for(int i=L-1;i>=1;i--){
        if(check2(1,i)){
            ans[i]=1;break;
        }
    }
    for(int i=1;i<=len;i++){
        printf("%c",x[i]);
        if(ans[i])printf("%c",',');
    }
    printf("\n");
}

```


---


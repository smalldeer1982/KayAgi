# 规划

## 题目描述

某地方有 $N$ 个工厂，有 $N-1$ 条路连接它们，且它们两两都可达。每个工厂都有一个产量值和一个污染值。现在工厂要进行规划，拆除其中的 $M$ 个工厂，使得剩下的工厂依然连成一片且总产量 / 总污染的值最大。

## 说明/提示

### 数据范围及约定

对于全部数据，$1<N<100$，$1 \le M<N$，$1\le w_i\le 10000$，$1\le c_i\le 10000$。

## 样例 #1

### 输入

```
3 2
2 3 4
1 1 1
1 2
2 3
```

### 输出

```
4.0```

# 题解

## 作者：mulberror (赞：21)

既然没有人来题解那么我就来一篇吧！

这个题目的算法叫做01分数规划。

我的博客里面有非常~~详细~~的讲解，[安利](https://www.cnblogs.com/Dawn-Star/p/9610410.html)一下

-----
好了，我们废话不说，来讲解一下。

01分数规划的题目有一个比较明显的**特点**，就是一般是要算出

$$\frac{\sum wi}{\sum vi}$$

而这个公式中的wi表示每个物品的价值，vi表示代价。

01分数规划问题主要包含以下几个问题：

 - 一般的01分数规划
 - 最优比率生成树
 - 最优比率环

----------

关于01分数规划的关键
===========

> F(L)=sigma(a[i]*x[i])-L*sigma(b[i]*x[i])

> F(L)=sigma(a[i]*x[i]-L*b[i]*a[i])

> F(L)=sigma((a[i]-L*b[i])*x[i])

我们把a[i]-L*b[i]定义为d[i]，这样我们的算式就变成了以下算式。

> F(L)=sigma(d[i]*x[i])

这样我们就把这个繁琐的算式变成了一个非常优美的算式。
而01分数规划就是要枚举L在求最大值或最小值的F(L)。
在实现程序的过程中，我们使用一个非常熟悉的老朋友，要求最大或最小，所以？？我们就要用**二分**


----------

关于为什么01分数规划不能用贪心？
=================

（个人看法）
如果硬要贪心，那么就只有可能是算出每一个物品的性价比，在排序求出最大或者最小的性价比，在累加算出答案。

一、01分数规划算法
-
先设置价值数组a[i]和代价数组b[i]，我们的答案为R。
$$ R= \frac{\sum_{i=1}^{n}{a[i]*x[i]}}{\sum_{i=1}^{n}{b[i]*x[i]}}$$ 
简单来说 $$ R=\frac{\sum{valuei}}{\sum{weighti}} $$
我们可以发现，R的大小与上下的总值有关。

二、贪心算法
-
我们反观一下贪心算法，先算出每个物品的性价比
$$ xi=\frac {valuei}{weighti}$$
那么贪心得到的答案就是
$$ R=\sum{xi}$$

比较
--
我们可以很容易发现，01分数规划和贪心的得到的答案有明显的区别，一个是总价值/总代价，而贪心中只是单价值/单代价的累加，而不只是比值的大小，而取决于分母和分子的大小，所以这两个东西不相等

----------

那么我们回到这一道题目，看到比值我们要想到用01分数规划，然后我们二分枚举一下这个以上的L，在进行检查就可以了。

判断就是做一下树背包，求树上一个n - m的连通块，使块中的点的权值之和最大。

令$ dp[u][j] $表示以u为根的子树中，有一个点数为 j 的联通块时的最大值。这个联通块一定是包含u的。

动态转移方程:$$ f[u][j]=Max(f[u][j],f[u][j-k]+f[v][k]); $$

u是当前节点，v是儿子，j和k是要自己枚举的
```cpp
#include <bits/stdc++.h>
#define ms(a,b) memset(a,b,sizeof(a))
using namespace std;
const int Maxn=105;
const int Inf=1<<30;
const double eps=1e-4;
struct Edge{
	int to,next;
}edge[Maxn<<1];
double d[Maxn],f[Maxn][Maxn];
int v[Maxn],c[Maxn],sz[Maxn],head[Maxn];
int n,m,Nedge;
inline int Min(int n,int m) {return n<m?n:m;}
inline int Max(int n,int m) {return n>m?n:m;}
inline int read() {
	int w=0,x=0;char ch=0;
	while (!isdigit(ch)) {w|=ch=='-';ch=getchar();}
	while (isdigit(ch)) {x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return w?-x:x;
}
inline void Add_Edge(int u,int v) {//邻接表建图
	edge[Nedge]=(Edge){v,head[u]};
	head[u]=Nedge++;
}
inline void dfs(int u,int fa) {//树背包
	sz[u]=1;//将当前节点的子树节点设置为1
	f[u][0]=0;//初始化
	for (int i=head[u];i!=-1;i=edge[i].next) {//专属for
		int v=edge[i].to;
		if (v==fa) continue;//如果v=fa那么就跳出
		dfs(v,u);//递归子树
		sz[u]+=sz[v];//将子树的个数加到自己身上
		for (int j=Min(m,sz[u]);j>=0;j--) {
			for (int k=0;k<=Min(j,sz[v]);k++) 
				f[u][j]=Max(f[u][j],f[u][j-k]+f[v][k]);//背包
		}
	}
	for (int i=min(m,sz[u]);i>0;i--) f[u][i]=f[u][i-1]+d[u];
}
inline bool judge(double x) {
	for (int i=1;i<=n;i++) 
		for (int j=0;j<=m;j++) f[i][j]=-Inf;
	for (int i=1;i<=n;i++) d[i]=(v[i]*1.0)-x*(1.0*c[i]);//01分数规划的基本操作
	dfs(1,0);
	for (int i=1;i<=n;i++) 
		if (f[i][m]>-eps) return 1;
	return 0;
}
int main() {
	ms(head,-1);
	n=read(),m=read();
	for (int i=1;i<=n;i++) v[i]=read();
	for (int i=1;i<=n;i++) c[i]=read();
	m=n-m;
	for (int i=1;i<n;i++) {
		int a=read(),b=read();
		Add_Edge(a,b);
		Add_Edge(b,a);
	}
	double l=0,r=1000000;
	while (r-l>eps) {//在容许范围内那么就输出
		double Mid=(l+r)/2.00;
		if (judge(Mid)) l=Mid;
		else r=Mid;
	}
	printf("%.1lf\n",l);
	return 0;
}
```

---

## 作者：AlanSP (赞：13)

### 1.概述

对于形如
$$
\frac{\sum a_i}{\sum b_i}=c
$$
的式子，要求最大/最小化c。

---

## 2.解法

可以考虑贪心，但是发现所求的是分式结构，不好操作。

我们采用更优的一种方式：**01分数规划**。

我们可以把每个i看作一个物品，$a_i,b_i$ 分别为价值和体积。

因为最大化的是比值，没有办法直接背包。

我们可以在每个物品前加一个系数0/1，表示该物品选或不选。

选的话上下同加上当前的a和b。

这只是理论部分。

---

### 3.实现

先经过移项：
$$
\sum a_i=\sum b_i\times c
$$


$$
\sum a_i-b_i\times c=0
$$

有一个显然的性质：c是单调的。

也就是说，我们可以二分查找c的取值。

对于每一个c，我们可以进行验证，利用$a_i-b_i\times c$。

至于具体的check方式，有SPFA找负环，贪心，dp等，因题而定。

一般c都是小数，所以记住用double。

---

### 4.例题

**Description：**

> 某地方有N个工厂，有N-1条路连接它们，且它们两两都可达。每个工厂都有一个产量值和一个污染值。现在工厂要进行规划，拆除其中的M个工厂，使得剩下的工厂依然连成一片且 总产量/总污染 的值最大。

**Solution：**

很经典的分数规划。

把产量看成a，污染值看成b，就是上面的式子。

考虑验证，即在联通条件下，验证$a_i+b_i\times c$与0的关系。

如果大于0，说明可以继续扩大；反之，则不能。

那么现在要求一个n-m的连通块，最大化$a_i+b_i\times c$。

又因为图是棵树，所以采用树上背包。

---

**Code：**

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=109,INF=0x3f3f3f3f;
const double eps=1e-4;
int ver[N<<1],nxt[N<<1],h[N],tot;
int n,a[N],b[N],m;
double val[N],f[N][N];

inline void add(int x,int y)
{
	ver[++tot]=y,nxt[tot]=h[x],h[x]=tot;
}

inline void dfs(int u,int fa)
{
	f[u][0]=0;
	for(int i=h[u];i;i=nxt[i])
	{
		int v=ver[i];
		if(v==fa) continue;
		dfs(v,u);
		for(int j=m-1;j>=0;j--)
			for(int k=0;k<=j;k++)
				f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]);
	}
	for(int i=m;i>=1;i--) f[u][i]=f[u][i-1]+val[u];
	f[u][0]=0;	
}

inline bool check(double x)
{
	memset(f,-INF,sizeof f);
	for(int i=1;i<=n;i++)
		val[i]=a[i]*1.0-x*b[i]*1.0;
	dfs(1,0);
	for(int i=1;i<=n;i++) 
		if(f[i][m]>-eps)
			return true;
	return false;
}

int main()
{
	scanf("%d%d",&n,&m);
	m=n-m;
	for(int i=1;i<=n;i++) scanf("%d",&a[i]); 
	for(int i=1;i<=n;i++) scanf("%d",&b[i]); 
	for(int i=1;i<n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	double l=0,r=100000,ans;
	while(r-l>eps)
	{
		double mid=(l+r)/2.0;
		if(check(mid)) ans=mid,l=mid;
		else r=mid;
	}
	printf("%.1lf",ans);
	return 0;
}
```



---

## 作者：lahlah (赞：3)

我扔:https://www.luogu.org/problemnew/show/P1642
# [听说在blog里体验更佳](https://blog.csdn.net/qq_38944163/article/details/85605932)

##### 这题是一道很好的01分数规划的入门题

#### 为啥叫做01分数规划呢？

#### 首先和01有什么关系？

这类问题一般是给定一堆 $a[i]$ 和 $b[i]$ ,然后如果选了$a[i]$就必须选$b[i]$ ~~感性理解一下~~， 就是比如说选第i个物品会有$a[i]$的收益，但是有$b[i]$的花费， 求 $\frac{选出来的a[i]}{选出来的b[i]}$ 最大。
于是就可以多定义一个 $x[1...n]$ 数组, $x[i]$ 为0或1表示选或不选，则对于每种$x[1...n]$的答案可以表示为
# $\sum {\frac{a[i] \times x[i]}{b[i] \times x[i]}}$
那么这类问题称为01分数规划问题
### 那怎么做呢？
假设答案为
$ANS = \sum {\frac{a[i] \times x[i]}{b[i] \times x[i]}}$
则$ANS \times \sum {b[i] \times x[i]} = \sum {a[i] \times x[i]}$
$\sum {a[i] \times x[i]} - ANS \times \sum {b[i] \times x[i]} = 0$
$x[i] \times \sum ({a[i] - ANS \times b[i]}) = 0$
令$d[i] = a[i] - ANS \times b[i]$ 
通常是规定了选几个，所以只需要按照$d[i]$的大小来选就可以了，
#### 那ANS呢？
直接二分啊！！！
此题代码：

```cpp
#include<bits/stdc++.h>
#define N 1000005
#define INF 23333333
using namespace std;
const double eps = 0.000001;
struct edge{	
	int v, nxt;
}e[N];
int p[N], eid;
void init(){
	memset(p, -1, sizeof p);
	eid = 0;
}
void insert(int u, int v){
	e[eid].v = v;
	e[eid].nxt = p[u];
	p[u] = eid ++;
}
double f[105][105], d[105];
int vis[105], size[105], n, m, a[105], b[105];
void dfs(int x){//简单的树dp， f[i][j]表示第 i 个点， 选 j 个的方案数， 其中 i 必须选 
	vis[x] = 1; size[x] = 1;
	f[x][1] = d[x];f[x][0] = 0;
	for(int i = p[x]; i + 1; i = e[i].nxt){
		int v = e[i].v;
		if(vis[v]) continue;
		dfs(v); size[x] += size[v];
		for(int j = min(m, size[x]); j >= 1; j --){
			for(int k = 0; k < j; k ++){
				f[x][j] = max(f[x][j], f[x][j - k] + f[v][k]);
			}
		}
	}
}
int check(double x){
	for(int i = 1; i <= n; i ++) d[i] = a[i] * 1.0 - b[i] * 1.0 * x, vis[i] = 0, size[i] = 0; //求 d[i] 
	for(int i = 1; i <= n; i ++)
		for(int j = 0; j <= m; j ++) f[i][j] = -INF;
	dfs(1);
	for(int i = 1; i <= n; i ++){
		if(f[i][m] > -eps) return 1; //如果有满足要求的就退出 
	}
	return 0;
}
int main(){
	init();
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i ++) scanf("%d", &a[i]);
	for(int i = 1; i <= n; i ++) scanf("%d", &b[i]);
	m = n - m;
	for(int i = 1; i < n; i ++){
		int u, v;
		scanf("%d%d", &u, &v);
		insert(u, v);
		insert(v, u);
	}	
	double l = 0, r = 100000;
	while(l + eps < r){ //二分答案 
		double mid = (l + r) * 1.0 / 2.0;
		if(check(mid)) l = mid;
		else r = mid;
	}
	printf("%.1f", l);
	return 0;
}
```
emmmmmm……


---

## 作者：SunsetSamsara (赞：2)

## 题意

有 $N$ 个点，有 $N-1$ 条边连接它们，且它们两两都可达。每个点都有两个值 $a$ 和 $b$。现在删除其中的 $M$ 个点，使得剩下的点依然连成一片且 $\dfrac {\sum\limits_{u} a_u}{\sum\limits_{u} b_u}$ 的值最大。

## 分析

一看这个要规划的奇怪的式子就可以知道是分数规划了。作为一道分数规划题，肯定是使用二分，从判断函数入手。那么，如何判断一个值 $k$ 存不存在一种方式使得 $\sum \limits_{u} (a_u - b_uk) \ge 0$ 呢？可以发现，这里的判断就是做一个简单的树背包，求树上一个大小为 $n - m$ 的连通块，使块中的点的 $a_u - b_uk$ 之和最大。

那么 $\text{dp}$ 式子就呼之欲出了。令 $f_{u, n}$ 表示表示以 $u$ 为根的子树中，一个点数为 $n$ 且包含 $u$ 的联通块的权值和的最大值。则有 $f_{u, n} = \operatorname{max}\left\{f_{u, b - k} + f_{v, k}\right\}$，其中 $v$ 是 $u$ 的子节点之一。

## 代码

```cpp
#include <stdio.h> 
#include <string.h> 
const double eps = 1e-4;
inline double max(const double &x, const double &y) { return x < y ? y : x; }
struct edge {
	int to, nxt;
} es[210];
int head[110], ecnt;
int n, a[110], b[110], m;
double val[110], f[110][110];
inline void addedge(int x, int y) {
	es[++ ecnt] = (edge){y, head[x]};
	head[x] = ecnt;
}
inline void dfs(int u, int fa) {
	f[u][0] = 0;
	for (int e = head[u], v; v = es[e].to, e; e = es[e].nxt)
		if (v != fa) {
			dfs(v, u);
			for (int i = m - 1, j; i >= 0; -- i)
				for (j = 0; j <= i; ++ j) f[u][i] = max(f[u][i], f[u][i - j] + f[v][j]);
		}
	for (int i = m; i >= 1; -- i) f[u][i] = f[u][i - 1] + val[u];
	f[u][0] = 0;
}
inline bool check(double x) {
	memset(f, -0x3f, sizeof f);
	for (int i = 1; i <= n; ++ i) val[i] = a[i] - x * b[i]; // 经典分数规划 
	dfs(1, 0);
	for (int i = 1; i <= n; ++ i)
		if (f[i][m] > -eps) return 1;
	return 0;
}
int main() {
	scanf("%d%d", & n, & m);
	m = n - m;
	for (int i = 1; i <= n; ++ i) scanf("%d", a + i);
	for (int i = 1; i <= n; ++ i) scanf("%d", b + i);
	for (int i = 1; i < n; ++ i) {
		int x, y;
		scanf("%d%d", & x, & y);
		addedge(x, y), addedge(y, x);
	}
	double l = 0, r = 1e5, mid;
	while (r - l > eps) {
		mid = (l + r) / 2.0;
		if (check(mid)) l = mid;
		else r = mid;
	}
	printf("%.1lf\n", l);
}
```

---

## 作者：ListenSnow (赞：2)

$01$ 分数规划好题。

## 前置芝士：$01$ 分数规划模型

给定整数 $a_1$，$a_2$，···，$a_n$ 以及 $b_1$，$b_2$，···，$b_n$，求一组解 $x_i$ $($ $1 \leq i \leq n$，$x_i=0$ 或 $x_i=1$ $)$ ，使得下式最大化：

$\dfrac{ {\textstyle \sum_{i=1}^{a}} a_i*x_i}{ {\textstyle \sum_{i=1}^{b}} b_i*x_i} $ 。

用~~自己的话~~（lyd大佬）的话来说，就是给定 $n$ 对整数 $a_i,b_i$ ，从中选出若干对，使选出的数对的 $a$ 之和与 $b$ 之和的商最大。

#### $01$ 分数规划的基本做法：

取一个数值 $mid$，然后判断是否存在一组可行解满足：

$\dfrac{ {\textstyle \sum_{i=1}^{n}}a_i*x_i }{ {\textstyle \sum_{i=1}^{n}b_i*x_i} } \geq mid $。

直接求解比较困难，于是可以移项，得：

$ {\textstyle \sum_{i=1}^{n} a_i*x_i} \geq  {\textstyle \sum_{i=1}^{n}} b_i*x_i*mid  $。

继续移项，得：

$ {\textstyle \sum_{i=1}^{n}(a_i-b_i*mid)*x_i} \geq 0$ 。

而最终的答案就是 $mid$ 的最大值。可以发现，这与二分答案非常相似，事实上，$01$ 分数规划问题就是需要借助二分答案的方法进行求解。但是别忘了，可以使用二分答案的前提条件是满足**单调性**，而对于 $01$ 分数规划来说，要求的答案 $mid$ ~~显然~~存在单调性。 因为如果发现了一个可行的 $mid$ ，那么肯定要往更大的方向去寻找是否存在更优的 $mid$ 。
## 题意

给定一棵 $n$ 个节点树，每个节点都有一个 $a_i$ 和 $b_i$ 值，现在要删去 $m$ 个点，在满足剩下的节点仍然能形成一颗树的前提下，求：

$\dfrac{\sum a_i}{\sum b_i} $ 的最大值。

## 思路

初看本题，会发现题意和 $01$ 分数规划模型非常像，但是题目还有一个额外要求，剩下的子节点仍然能形成**一棵树**。于是本题需要和树形 $dp$ 结合起来做。

首先根据 $01$ 分数规划的基本做法，先枚举可能的答案。根据题意，当所有的 $a_i=10000$ ，$b_I=1$ ，答案会取到上届 $10000$ ，故最初的左端点 $r=10000$ 。同时为了防止出错也可以将 $r$ 值适当上调。



判断一个 $mid$ 是否存在可行解时，可以将树上每个点的值都变成 $a_i-mid*b_i$ 。这样就可以将判断转化为一个十分经典的树上背包问题：选择连续的 $n-m$个节点，判断其中的最大值是否 $\geq 0$ 。如果存在，就令 $l=mid$ ，反之，则令 $r=mid$ 。最终得到的就是 $mid$ 的最大值，也就是本题的答案。（二分答案的基本做法）

## code：
```cpp
#include<iostream>
using namespace std;
const int N=110;
const int INF=0x3f3f3f3f;
const double eps=1e-4;
struct edge{
	int v,w,nex;
}e[N<<1];
int size[N],h[N],idx,a[N],b[N],n,m;
double d[N],f[N][N];
void add(int u,int v)
{
	e[++idx].v=v;
	e[idx].nex=h[u];
	h[u]=idx;
}
void dfs(int u,int fa)
{
	size[u]=1;
	f[u][0]=0;
	for(int i=h[u];i;i=e[i].nex)
	{
		int v=e[i].v;
		if(v==fa) continue;
		dfs(v,u);
		size[u]+=size[v];
		for(int j=min(size[u],m);j>=0;j--)
		    for(int k=0;k<=min(j,size[v]);k++)
		        f[u][j]=max(f[u][j],f[v][k]+f[u][j-k]);
	}
	for(int i=min(size[u],m);i>=1;i--) f[u][i]=f[u][i-1]+d[u];
}
bool check(double mid)
{
	for(int i=1;i<=n;i++)
	    for(int j=0;j<=m;j++)
	        f[i][j]=-INF;
	for(int i=1;i<=n;i++) d[i]=a[i]*1.0-mid*(b[i]*1.0);
	dfs(1,0);
	for(int i=1;i<=n;i++)
	    if(f[i][m]>-eps) return true;
	return false;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++) scanf("%d",&b[i]);
	for(int u,v,i=1;i<n;i++)
	{
		scanf("%d%d",&u,&v);
		add(u,v),add(v,u);
	}
	m=n-m;
	double l=0,r=10010;
	while(r-l>eps)
	{
		double mid=(l+r)/2;
		if(check(mid)) l=mid;
		else r=mid;
	}
	printf("%.1lf\n",r);
	return 0;
}
```


---

## 作者：maruize (赞：2)

算法Ⅰ:01分数规划

算法Ⅱ:树形动规

---

Ⅰ:求01数列$x(x_1-x_n)$使得$ \frac{\sum_{i=1}^n a_i\times x_i}{\sum_{i=1}^n b_i\times x_i}$最大。

$ \ \ \ \ $设最大值为$A$ 

$ \ \ \ \ $所以$ A =  \frac{\sum_{i=1}^n a_i\times x_i}{\sum_{i=1}^n b_i\times x_i}$

$ \ \ \ \ A \times \sum_{i=1}^n b_i\times x_i= \sum_{i=1}^n a_i\times x_i$

$ \ \ \ \ 0=\sum_{i=1}^n a_i\times x_i -  A \times \sum_{i=1}^n b_i\times x_i$

$ \ \ \ \ 0=\sum_{i=1}^n (a_i\times x_i -  A \times b_i\times x_i)$

$ \ \ \ \ 0=\sum_{i=1}^n (a_i -  A \times b_i)\times x_i$

$ \ \ \ \ $考虑二分$A$设数列$d_i=a_i -  A \times b_i$,设等式左边为$f(A)$

$ \ \ \ \ $则$f(A)=\sum_{i=1}^n d_i\times x_i$

$ \ \ \ \ $当$f(A)>0$时易得$A_{now}<realA$

$ \ \ \ \ $当$f(A)<0$时易得$A_{now}>realA$


$ \ \ \ \ $问题就转化为对每个二分的$A$求$max\{ \sum_{i=1}^n d_i\times x_i \}$


Ⅱ:但是问题在树上我们要从树上找到一个连通块,使上面的点的$x_i=1$且它使$ \sum_{i=1}^n d_i\times x_i $最大。

$ \ \ \ \ $状态$f_{ij}$是以$i$根节点的子树中保留(也可以是去掉)$j$个点且必须选$i$的最大"连通块"。

$ \ \ \ \ $转移的时候是个01背包。

---

## 作者：No_wonder (赞：0)

本题是01分数规划的入门题（劝退题，我个人在做这道题的时候因为忘记了这是个分数规划，把dp和权值数组都设成了int型导致调试半小时还看了题解/耿耿于怀。

## 01分数规划
这类题型一般有一个共性，那就是给你若干个二元组，选择其中的一些使选择的$\frac{\sum x[i]}{\sum y[i]}$取到最值。对应到本题中就是产值比污染值的最大值。

朴素的做法就是枚举每一种可能的选择，但是我们有更好的方法。

我们首先对这个式子进行处理，设$\frac{\sum x[i]}{\sum y[i]}=c$

那么
$\sum x[i]-c*\sum y[i]=0$，我们可以选择二分寻找这个$c$，那么本题的正解就是二分答案了。

## 树上背包
二分$c$之后，我们如何寻找这过程中的总产量/总污染 的最大值呢？

分析一下问题，n个节点，选择其中的一些，使一个值最大。很自然就想到了背包。

我们设计$dis[i][j]$表示以$i$为根节点，共选$j$个节点的最大值，那么只需要在树上递归处理即可。同时，为了保证图联通，根节点必须选择。

不会的可以左转[这道题](https://www.luogu.com.cn/problem/P2014)

细节详见代码

```cpp
#include<bits/stdc++.h>
#define ri register int
#define inf 0x3f3f3f3f
using namespace std;
struct Edge{										 
	int next;
	int to;
}e[220];
int n,m;
int c[110],w[110];
int head[110],cnt;
double l=0,r=100000,mid,qwq=1e-4;											//这里的r其实可以初始化成每一个c[i]/w[i]的最大值
														//因为其他点的值都比这个小，所以无论怎么选，最大也是大不过那个值的。 
double qz[110],dp[110][110];
void add_edge(int from,int to)
{
	e[++cnt].to=to;
	e[cnt].next=head[from];
	head[from]=cnt;
}
void dfs(int u,int fa)														//树上背包 
{
	dp[u][0]=0;																//初始化，一个节点都不选肯定结果是0 
	for(int i=head[u]; i;i=e[i].next)						
	{
		int to=e[i].to;
		if(to==fa)	continue;
		dfs(to,u);															//递归处理 
		for(int j=m-1;j>=0;j--)												//状态转移 
		for(int k=0;k<=j;k++)
		dp[u][j]=max(dp[u][j],dp[u][j-k]+dp[to][k]);
	}
	for(int i=m;i>=1;i--)													//保证根节点的选择 
	dp[u][i]=dp[u][i-1]+qz[u];
}
bool check(double x)
{
	memset(dp,-inf,sizeof dp);
	for(ri i=1;i<=n;i++)
	qz[i]=c[i]*1.0-x*(w[i]*1.0);
	dfs(1,0);
	for(int i=1;i<=n;i++)
	if(dp[i][m]>-qwq)	return 1;
	return 0;
}
int main()
{
	scanf("%d%d",&n,&m);
	m=n-m;																//从题中的删节点转为取节点 
	for(ri i=1;i<=n;i++)
	scanf("%d",&c[i]);
	for(ri i=1;i<=n;i++)
	scanf("%d",&w[i]);
	for(ri i=1;i<n;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		add_edge(u,v);
		add_edge(v,u);	
	}
	while(r-l>qwq)
	{
		mid=(l+r)/2.0;
		if(check(mid))	l=mid;
		else			r=mid;
	}
	printf("%.1lf",l);
}
```


---

## 作者：紫题 (赞：0)



------------
一群红名dalao 10msAC之后居然没留下题解……

只能让蒟蒻水一波暴力题解了


------------


首先看到题面就想到0/1分数规划

[（不知道啥是0/1分数规划？点这里）](https://www.baidu.com)

设题目中的产值为$a_i$，污染值为$b_i$

二分答案mid，将图（树）中的点权都设为$w[i] = a_i-mid*b_i$

把$m$个点剪掉以后，统计剩下的点权$sum$，$sum<0$则答案不可行，反之则可行

剩下的问题就变成：一个带点权的无根树，求剪掉m个点后剩下的点权之和最大

这里给一个比较暴力的解决方案：

首先枚举节点为根$root$，把无根树变成有根树

设$F[x,t]$表示在以$x$为根的子树中剪去$t$个点的最小权值和，

设$x$的子节点集合为$Son(x)$，子节点个数为$p = |Son(x)|$

对于$x$的每个子节点$y_i∈Son(x)$，可以在以$y$为根的子树中剪若干个点（记为$c_i$），在满足$∑c_i = t$的基础上使权值尽量小。

所以得到一个超级暴力的转移：![](http://a3.qpic.cn/psb?/V11AmqcZ4auDAR/ovSaenobEO5uBKfrGKGVLCQIxmO8aM1yLrvBAyGinXI!/b/dDIBAAAAAAAA&ek=1&kp=1&pt=0&bo=dAFSAAAAAAADFxU!&tl=1&vuin=1124964656&tm=1540123200&sce=60-1-1&rf=viewer_4)

其实就是一个**树形的分组背包**，有$p = |Son(x)|$组物品，每组物品都有$t$个，其中第$i$组的第$j$个物品的体积为$j$，价值为$F[y_i,j]$。

考虑到删掉点以后还要保证剩下的点连通，节点$x$如果能剪掉，以$x$为根的树的子树必须全部都剪掉了。 所以$F[x,Size(x)] = F[x,Size(x)-1]+w[i]$。

其他的按照分组背包的方式转移即可。

上丑陋的代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define low 1e-2
using namespace std;
bool g[110][110];
int tim1[110],tim2[110],degree[110],ver[110][110],cnt[110],size[110],n,m;
double w[110],f[110][110];
void dfs(int s,int fa){ 
    size[s]=1;
    for(int i=1;i<=n;i++){
        if(g[s][i]&&i!=fa){
            ver[s][++cnt[s]]=i;
            dfs(i,s);
            size[s]+=size[i]; //树的节点数
        }
    }
}
void dp(int x){
    f[x][0]=0;
    for(int i=1;i<=cnt[x];i++){ //循环子节点（物品）
        int y=ver[x][i];
        dp(y);
        for(int t=m;t>=0;t--) //倒序循环选点数（当前背包体积）
            for(int j=size[y];j>=0;j--) //循环更深子树上的选点数（组内物品）
                if(t-j>=0)
                    f[x][t]=min(f[x][t-j]+f[y][j],f[x][t]);
    }
    f[x][size[x]]=f[x][size[x]-1]+w[x];
}
bool build(double L)
{
    double sum=0,sum0=0x3f3f3f3f;
    for(int i=1;i<=n;i++){
        w[i]=(double)tim1[i]-(double)L*tim2[i];
        sum+=w[i];
    }
    for(int root=1;root<=n;root++){
        memset(cnt,0,sizeof(cnt));
        for(int i=1;i<=n;i++)
        for(int j=0;j<=m+1;j++) f[i][j]=0x3f3f3f3f; //重要！！
        dfs(root,0);
        dp(root);
        for(int i=1;i<=n;i++) sum0=min(sum0,f[i][m]);
    }
    return (sum-sum0>0)?true:false;
}
int main()
{
    int x,y;
    double l=0,r=1000007;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&tim1[i]);
    for(int i=1;i<=n;i++) scanf("%d",&tim2[i]);
    for(int i=1;i<n;i++){
        scanf("%d%d",&x,&y);
        g[x][y]=g[y][x]=1;
    }
    while(r-l>low){
        double mid=(l+r)/2;
        if(build(mid)) l=mid;
        else r=mid;
    }
    printf("%.1f\n",(r+l)/2);
    return 0;
}

```
~~有哪位热心大佬来ac之后要发10ms题解顶掉这篇爆搜啊~~

---

## 作者：VenusM1nT (赞：0)

分数规划。

挺好的一道题。

首先转换模型，要拆除 $m$ 个工厂，不妨看作选择 $n-m$ 个工厂，然后要求连通，所以就相当于是选一个 $n-m$ 大小的连通块，这里我们可以用树形背包来解决。

解决了模型的转换，我们就直接用分数规划的套路，二分答案 $\text{mid}$。因为这题要求的是：

$$\text{mid}=\frac{\sum_{i=1}^{n-m}a_i}{\sum_{i=1}^{n-m}b_i}$$

所以我们将每个点的贡献 $\text{val}$ 设为 $a_i-\text{mid}\times b_i$，跑一遍树形 $\texttt{dp}$，检查对每个点都是否合法即可。

转移方程：令 $f_{u,i}$ 表示以 $u$ 为根的子树中有一个 $\text{siz}=i$ 且包含 $u$ 的连通块时的最大值，则方程为：

$$f_{u,i}=\max\{ f_{u,i},f_{u,i-j}+f_{v,j}\}$$

```cpp
#include<bits/stdc++.h>
#define MAXN 105
#define reg register
#define inl inline
#define eps 1e-6
#define db double
using namespace std;
int cnt,fst[MAXN],nxt[MAXN<<1],to[MAXN<<1];
int n,m,a[MAXN],b[MAXN],siz[MAXN];
db val[MAXN],f[MAXN][MAXN];
inl void AddEdge(reg int u,reg int v)
{
	to[++cnt]=v;
	nxt[cnt]=fst[u];
	fst[u]=cnt;
}
inl void Dfs(reg int u,reg int faz)
{
	f[u][0]=0;
	siz[u]=1;
	for(reg int i=fst[u];i;i=nxt[i])
	{
		reg int v=to[i];
		if(v==faz) continue;
		Dfs(v,u);
		siz[u]+=siz[v];
		for(reg int j=min(siz[u],m);j>=0;j--)
		{
			for(reg int k=0;k<=min(siz[v],j);k++) f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]);
		}
	}
	for(reg int i=min(m,siz[u]);i>=1;i--) f[u][i]=f[u][i-1]+val[u];
}
inl bool Check(reg db mid)
{
	for(reg int i=1;i<=n;i++)
	{
		for(reg int j=0;j<=m;j++) f[i][j]=-0x7fffffff;
	}
	for(reg int i=1;i<=n;i++) val[i]=(db)a[i]-mid*(db)b[i];
	Dfs(1,0);
	for(reg int i=1;i<=n;i++) if(f[i][m]>-eps) return 1;
	return 0;
}
int main()
{
	scanf("%d %d",&n,&m);
	m=n-m;
	for(reg int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(reg int i=1;i<=n;i++) scanf("%d",&b[i]);
	for(reg int i=1;i<n;i++)
	{
		reg int x,y;
		scanf("%d %d",&x,&y);
		AddEdge(x,y);
		AddEdge(y,x);
	}
	reg db l=0,r=1e5;
	while(r-l>eps)
	{
		reg db mid=(l+r)/2.0;
		if(Check(mid)) l=mid;
		else r=mid;
	}
	printf("%.1lf\n",l);
	return 0;
}
```

---


# 新魔法药水

## 题目描述

商店里有 $N$ 种药水，每种药水都有一个售价和回收价。小 $S$ 攒了 $V$ 元钱，还会 $M$ 种魔法，可以把一些药水合成另一种药水。他一天可以使用 $K$ 次魔法，问他一天最多赚多少钱？

注意：卖出去赚到的钱不能再次用来投资。

## 说明/提示

### 数据范围及约定

对于全部数据，$N \le 60$，$M \le 240$，$V \le 1000$，$k \le 30$。

## 样例 #1

### 输入

```
4 2 6 3
1 0
1 0
5 3
20 15
3 2 1 2
4 3 1 2 3```

### 输出

```
12```

# 题解

## 作者：ysner (赞：20)

~~这题有点难想啊，看了一个小时才有思路，也许是我太弱了~~

首先，这道题肯定是DP。

其次，分析样例，会发现题目有个隐藏条件：**只能用开局的V元钱买入药品。**

经过对题面的研究，我们可以发现，那一长串药物合成关系实在不好在DP中用上，我们应当把他们变得易于处理，如用ans[i][j]表示第i个物品在用j次魔法的前提下所需最小代价（即原材料价钱）。

但ans[i][j]不太好直接求，我们可以再开一个DP数组ant[i][j]表示前i个药品在使用j次魔法前提下合成所需最小代价。这样就能通过ant[i][j]将合成原材料和合成品联系起来，顾及到 需要魔法总次数 等诸多因素。

有了以上作为基础，DP处理出结果就方便多了。设DP[i][j]为使用第i次魔法，使用j块钱所获最大利润，依此列式即可。

**还有，一种药品可能有多种合成方式。**~~我因把药品与合成关系一一对应WA了一版。~~

```
#include<bits/stdc++.h>
#define ll long long
#define re register
#define il inline
#define fp(i,a,b) for(re int i=a;i<=b;i++)
#define fq(i,a,b) for(re int i=a;i>=b;i--)
using namespace std;
const int N=300;
int m,n,q,k,s[N],h[N],op,ans[N][N],dp[N][1005],ant[N][50];
struct line
{
  int a,l,p[N];
}e[N];
il int gi()
{
  re int x=0,t=1;
  re char ch=getchar();
  while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
  if(ch=='-') t=-1,ch=getchar();
  while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
  return x*t;
}
int main()
{
  n=gi();m=gi();q=gi();k=gi();
  fp(i,1,n) s[i]=gi(),h[i]=gi();
  fp(i,1,m)
    {
      e[i].a=gi();e[i].l=gi();
      fp(j,1,e[i].l) e[i].p[j]=gi();
    }
  fp(i,1,n) fp(j,0,k) ans[i][j]=s[i];
  fp(o,1,k)
    fp(i,1,m)
      {
        fp(j,1,e[i].l)//枚举一合成关系中的物品
      {
        fp(t,0,o-1)//总魔法次数
          {
        ant[j][t]=1e9;
        fp(tt,0,t)//当前物品使用魔法次数 
        ant[j][t]=min(ant[j][t],ant[j-1][t-tt]+ans[e[i].p[j]][tt]);
          }
      }
    ans[e[i].a][o]=min(ans[e[i].a][o],ant[e[i].l][o-1]);
      }//处理药品合成信息
  fp(i,1,n)
    fp(j,0,k)
    fp(t,0,k-j)//枚举当前物品使用魔法次数
    fp(s,0,q-ans[i][j])//枚举使用钱数
    dp[j+t][s+ans[i][j]]=max(dp[j+t][s+ans[i][j]],dp[t][s]+h[i]-ans[i][j]);//简单DP求解
  printf("%d\n",dp[k][q]);
  return 0;
}

```

---

## 作者：xukuan (赞：9)

先让我们想想这题考什么

这题没法打暴力

众所周知，没法打暴力的题很有可能是贪心dp规律题

这题不会是规律题

那么会是贪心或者dp

贪心贪了半天没贪出来

考虑dp

**重复子问题**：使用第i次魔法，j块钱的最大利润的问题是类似的

**最优子结构**：使用第i次魔法，j块钱的最大利润转移的方案一定是最优的

**无后效性**：

这题的坑点。

手玩样例会发现，把药水1，2合成药水3之后，可以再把药水1,2,3合成4

那么无后效性是不是不成立了？

并不是

我们发现，第i个物品在用j次魔法之后所需最小代价是一定的，那么我们可以通过这个点去处理无后效性

用一个数组记下第i个物品在用j次魔法之后所需最小代价，这样转移的时候就很方便了

现在问题变成了：**怎么求第i个物品在用j次魔法之后所需最小代价**

我做到这里又一脸懵逼了，所以参考了[ysner](https://www.luogu.org/space/show?uid=21534)大神的题解

因为上面那个式子很难直接求，换一个方案：**怎么求前i个物品在用j次魔法之后所需最小代价**

式子很好推：

$ant_{j,k}=min_{t=1,i=1,j=1,k=0,l=0}^{t \leq K,i \leq M,j \leq |use_{i}|,k<t,l \leq k}ant_{j-1,k-l}+ans_{use_{i,j},l}$

$ans_{sell_{i},t}=min_{t=1,i=1}^{t \leq K,i \leq M} ant_{|use_{i}|,t-1}$

其中$i$表示前$i$种魔法，$use_{i}$表示第$i$种魔法消耗的材料的集合，$ant_{i,j}$表示前i个药品在使用j次魔法前提下合成所需最小代价，$ans_{i,j}$表示第i个物品在用j次魔法的前提下所需最小代价，$sell_{i}$表示第i种魔法得到的东西的收益

走到这一步，无后效性也可以很好的处理了。

**初始化**

$ans_{i,j}=s_{i}$

**状态转移方程**

$f_{j+k,s+ans_{i,j}}=max_{i=1,j=0,k=0,l=0}^{i \leq N,j+k \leq K,l+ans_{i,j} \leq V} f_{k,l}+h_{i}-ans_{i,j}$

**坑点**
只能用开始时的V元买入药品

**代码**

~~我的代码是贺的，不放了~~

---

## 作者：LlLlCc (赞：7)

$DP$应该无疑

看到$N$和$K$这么小，那我们就对$N$和$K$进行$DP$

设：

$a_{i,0}$ : 第 $i$ 个物品的进价

$a_{i,1}$ ： 第 $i$ 个物品的售价

$f_{i,j}$ : 用过 $j$ 次魔法后第 $i$ 个物品的进价最小值

$F_{i,j}$ : 花费 $i$ 元钱进货，用过 $j$ 次魔法后卖出的最大值（注：这里指花费 $i$ 元初始资金，因为卖出后得到的钱不能用来再次进货）

假设我们已经求出了$f$数组，那么：

$F_{v,T}=max(F_{v,T},F_{v-f_{i,j},T-j}+a_{i,1})$

同样的，答案也非常好求 :

$Ans=max(F_{i,j}-i)$

我们再倒回去看看，$f_{i,j}$怎么求

显然直接求非常的难（~~或者说我太菜了~~），我们还得借助于其他路径

根据魔法的制约条件，如果要转化成物品 $i$，那么必须得有物品 $b_{1},b_{2},\ldots,b_{tot}$

也就是说$b_{1}$用了$c_{1}$次，$b_{2}$用了$c_{2}$次，$\ldots$，$b_{tot}$用了$c_{tot}$次

$\sum\limits_{i=1}^{tot}b_i=j-1$

设 :

$Cnt_{i,j}$ : 当前枚举的魔法前 $i$ 个**条件物品**，一共用了 $j$ 次魔法的最小值

即 :

$Cnt_{Now,t}=min(Cnt_{Now,t},Cnt_{Now-1,t-v}+f_{b_{i,Now},v})$

所以 :

$f_{c_{i},j}=min(Cnt_{tot_{i},j-1})$

变量名有点混乱，可以看看代码：

```
#include<bits/stdc++.h>
using namespace std;
int n,Ans,m,f[65][35],k,allv,a[65][2],x,F[1005][35],b[245][65],tot[245],c[245],inf,Cnt[65][35];
bool flg;
inline int read(){
	int ret=0;char ch=getchar();
	while (ch<'0'||ch>'9') ch=getchar();
	while (ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();
	return ret;
}
int main(){
	n=read(),m=read(),allv=read(),k=read();
	memset(f,63,sizeof f);int inf=f[0][0];
	for (int i=1;i<=n;i++) f[i][0]=a[i][0]=read(),a[i][1]=read();
	for (int i=1;i<=m;i++){
		c[i]=read(),tot[i]=read();
	    for (int j=1;j<=tot[i];j++) b[i][j]=read();
	}
	for (int j=1;j<=k;j++)
	for (int i=1;i<=m;i++){
		memset(Cnt,63,sizeof Cnt);
		for (int t=0;t<j;t++) Cnt[0][t]=0;
		for (int Now=1;Now<=tot[i];Now++)
			for (int t=0;t<j;t++)
				for (int v=0;v<=t;v++) Cnt[Now][t]=min(Cnt[Now][t],Cnt[Now-1][t-v]+f[b[i][Now]][v]);
		f[c[i]][j]=min(f[c[i]][j],Cnt[tot[i]][j-1]);
	}
	for (int T=0;T<=k;T++)
	for (int j=0;j<=T;j++)
	for (int i=1;i<=n;i++)
	for (int v=f[i][j];v<=allv;v++) F[v][T]=max(F[v][T],F[v-f[i][j]][T-j]+a[i][1]);
	for (int i=0;i<=allv;i++)
	for (int j=0;j<=k;j++) Ans=max(Ans,F[i][j]-i);
	printf("%d",Ans);
	return 0;
}
```


---

## 作者：SevenDawns (赞：3)

[博客地址](https://www.cnblogs.com/huangchenyan/p/11305070.html)
# DP
首先考虑如何将答案DP转移出来

记$dp[i][j]$表示使用了$i$次魔法，用了$j$个金币时的最大获利

因为可以将几个药水合成一个药水

那么在转移时会发现还需要处理出用了第i种药水由j次魔法合成的最小成本，记此为$tc[i][j]$

那么转移方程就是$dp[i][j]=max(dp[i-q][j-tc[p][q]]+w[p]-tc[p][q])$

$w$表示这个药水的售价

那么现在就要处理出$tc$数组

对于$tc[i][j]$，因为当前合成i需要一次操作，那么分配给其原料的合成次数为$j-1$

$tc[i][j]=min(\sum_{k=1}^{Number}tc[a[k]][t[k]])$

且$\sum_{k}^{Number}t[k]=j-1$

$a$数组表示这个合成这个药水的原料，$t$为给这个原料分配合成的次数，$Number$为原料总数

那么这个表达式也是可以DP转移的

记$tmp[i][j]$表示前$i$个原料，用了$j$次魔法的最小成本

填表转移即可

注意此处合成同一个药水的配方可能有多个

那么在这多个配方中$tc$选取最佳的即可
```cpp
#include <bits/stdc++.h>
#define inf (int)1e9
using namespace std;
int n,m,v,k,tmp[100][100],tc[100][100];
int dp[45][1100];
struct node
{
    int v,w;
}sh[100];
struct magic
{
    int p,h;
    vector <int> a;
}d[300];
int main()
{
    scanf("%d%d%d%d",&n,&m,&v,&k);
    for (int i=1;i<=n;i++)
      scanf("%d%d",&sh[i].v,&sh[i].w);
    for (int i=1;i<=m;i++)
    {
        scanf("%d%d",&d[i].p,&d[i].h);
        for (int j=1;j<=d[i].h;j++)
        {
            int num;
            scanf("%d",&num);
            d[i].a.push_back(num);
        }
    }
    for (int i=1;i<=n;i++)
    {
        for (int j=1;j<=k;j++)
          tc[i][j]=inf;
        tc[i][0]=sh[i].v;
    }
    for (int j=1;j<=k;j++)
    {
        for (int i=1;i<=m;i++)
        {
            for (int p=0;p<j;p++)
              tmp[0][p]=tc[d[i].a[0]][p];//初始值
            for (int p=1;p<(int)d[i].a.size();p++)
            {
                for (int q=0;q<j;q++)
                {
                    tmp[p][q]=inf;
                    for (int r=0;r<=q;r++)
                      tmp[p][q]=min(tmp[p][q],tmp[p-1][r]+tc[d[i].a[p]][q-r]);//tmp的DP转移
                }
            }
            tc[d[i].p][j]=min(tc[d[i].p][j],tmp[(int)d[i].a.size()-1][j-1]);//在多个方案中取最优
        }
    }
    for (int i=0;i<=k;i++)
    {
        for (int j=0;j<=v;j++)
          dp[i][j]=-inf;
    }
    dp[0][0]=0;
    for (int i=0;i<=k;i++)
    {
        for (int j=0;j<=v;j++)
        {
            for (int p=1;p<=n;p++)
            {
                for (int q=0;q<=i;q++)
                {
                    if (tc[p][q]==inf)
                      continue;
                    if (j>=tc[p][q])//注意边界条件
                      dp[i][j]=max(dp[i][j],dp[i-q][j-tc[p][q]]+sh[p].w-tc[p][q]);  //转移
                }
            }
        }
    }
    int ans=0;
    for (int i=0;i<=k;i++)
    {
        for (int j=0;j<=v;j++)
          ans=max(ans,dp[i][j]);//统计答案
    }
    printf("%d\n",ans);
}
```


---


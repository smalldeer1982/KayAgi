# [NOI2011] NOI 嘉年华

## 题目描述

NOI2011 在吉林大学开始啦！为了迎接来自全国各地最优秀的信息学选手，吉林大学决定举办两场盛大的 NOI 嘉年华活动，分在两个不同的地点举办。每个嘉年华可能包含很多个活动，而每个活动只能在一个嘉年华中举办。

现在嘉年华活动的组织者小安一共收到了 $n$ 个活动的举办申请，其中第 $i$ 个活动的起始时间为 $S_i$，活动的持续时间为 $T_i$。这些活动都可以安排到任意一个嘉年华的会场，也可以不安排。

小安通过广泛的调查发现，如果某个时刻，两个嘉年华会场同时有活动在进行（不包括活动的开始瞬间和结束瞬间），那么有的选手就会纠结于到底去哪个会场，从而变得不开心。所以，为了避免这样不开心的事情发生，小安要求不能有两个活动在两个会场同时进行（同一会场内的活动可以任意进行）。

另外，可以想象，如果某一个嘉年华会场的活动太少，那么这个嘉年华的吸引力就会不足，容易导致场面冷清。所以小安希望通过合理的安排，使得活动相对较少的嘉年华的活动数量最大。

此外，有一些活动非常有意义，小安希望能举办，他希望知道，如果第 $i$ 个活动必须举办（可以安排在两场嘉年华中的任何一个），活动相对较少的嘉年华的活动数量的最大值。


## 说明/提示

### 样例解释

在没有任何限制的情况下，最优安排可以在一个嘉年华安排活动 $1, 4$，而在另一个嘉年华安排活动 $3, 5$，活动 $2$ 不安排。

对于 $10\%$ 的数据，$1\leq n\leq 10$。

对于 $30\%$ 的数据，$1\leq n\leq 40$。

对于 $100\%$ 的数据，$1\leq n\leq 200$，$0\leq S_i\leq 10^9$，$1\leq T_i\leq 10^9$。

如果输出格式不正确（比如输出不足 $n+1$ 行），得 $0$ 分；

如果输出文件第一行不正确，而且后 $n$ 行至少有一行不正确，得 $0$ 分；

如果输出文件第一行正确，但后 $n$ 行至少有一行不正确，得 $4$ 分；

如果输出文件第一行不正确，但后 $n$ 行均正确，得 $6$ 分；

如果输出文件中的 $n+1$ 行均正确，得 $10$ 分。


## 样例 #1

### 输入

```
5 
8 2 
1 5 
5 3 
3 2 
5 3 ```

### 输出

```
2 
2 
1 
2 
2 
2 ```

# 题解

## 作者：FlashHu (赞：53)

DP题怕是都要大大的脑洞。。。。。。

首先，时间那么大没用，直接离散化。

第一问还好。根据题意容易发现，当一堆活动的时间有大量重叠的时候，更好的办法是把它们全部安排到一边去。那么我们转移的时候也肯定是要一块一块地转移啦。

设$tot_{l,r}$为完全被包含在$l-r$时间内活动总数，直接$O(n^3)$暴力求就好了。

设$pre_{i,j}$为时间$1-i$内一边选$j$个时，另一边能选的最大值。枚举一块转移的话，我们的方程应该写成这样：

$$pre_ {i,j}=\max\limits_{k=1}^i\{pre_ {k,j}+tot_{k,i},pre _{k,j-tot _{k,i}}\}$$

（显然两种情况都要考虑）

然后答案就是$\max\limits_{j=1}^n\{\min(pre_{m,j},j)\}$啦（$m$为离散化后的时间总长，不会超过$2n$）

这个数组为什么要叫$pre$呢？这是个前缀DP值。为了第二问，我们还要做个后缀DP，$suf_{i,j}$表示时间$i-m$内一边选$j$个时，另一边能选的最大值，跟$pre$几乎一样的转移，也是$O(n^3)$的。

对于第二问，我们显然可以肯定$s_i-t_i$之内的活动都被一边选走了。至于$s_i$之前和$t_i$以后选了多少，我们也只好枚举。设$f_{l,r}$为一边强制选$l-r$之间所有活动时最优的最小值，假定这一边在前面选了$x$个，在后面选了$y$个，另一边最多能选多少也就知道了，有方程

$$f_{l,r}=\max\limits_{x=1}^m\max\limits_{y=1}^m\{\min(x+tot_{l,r}+y,pre_{l,x}+suf_{r,y})\}$$

然后第$i$个的答案就是$f_{s_i,t_i}$么？注意千万别掉入这个误区！$pre$和$suf$只是保证了局部最优，而没有保证全局最优。要说人话的话，就是可能有一个活动跨过了$s_i$，然而$f_{s_i,t_i}$并没有统计到它，只有扩大强制选的区间使得能够包含它，才能统计到最优解。于是需要枚举强制选区间了，$ans_i=\max\limits_{l=1}^{s_i}\max\limits_{r=t_i}^m\{f_{l,r}\}$

这样的话，整个$f$都必须要算出来，上面的枚举算法就变成$O(n^4)$了，跑不动。

点开标签发现有单调队列？！蒟蒻就往单调性上面想了想，于是就有了一个结论：设枚举$x$时有一个使答案最优的$y$，那么当$x$增大时，如果$y$也增大那么答案不会更优。观察上面那个式子$\min(x+tot_{l,r}+y,pre_{l,x}+suf_{r,y})$，那么因为$pre,suf$都是递减的，所以很显然我们不能让$x,y$变大而$pre,suf$变小。

于是，实现的时候，只要把$y$从大往小扫了，并不需要什么单调队列来维护它。
```cpp
#include<cstdio>
#include<algorithm>
#define RG register
#define R RG int
#define G c=getchar()
#define Upd(A,L,R)     {chkmx(A[i][j],A[k][j]+tot[L][R]);	\
		if(j>=tot[L][R])chkmx(A[i][j],A[k][j-tot[L][R]]);}
#define Calc(y) min(x+tot[l][r]+y,pre[l][x]+suf[r][y])
using namespace std;
const int N=209,M=409,INF=1e9;
int s[N],t[N],b[M],tot[M][M],pre[M][N],suf[M][N],f[M][M];
inline int in(){
	RG char G;
	while(c<'-')G;
	R x=c&15;G;
	while(c>'-')x=x*10+(c&15),G;
	return x;
}
inline int min(R x,R y){return x<y?x:y;}
inline void chkmx(R&x,R y){if(x<y)x=y;}
int main(){
	R n=in(),m=0,i,j,k,l,r,x,y,p0,p1,ans;
	for(i=1;i<=n;++i){
		b[++m]=s[i]=in();
		b[++m]=t[i]=in()+s[i];
	}
	sort(b+1,b+m+1);//离散化
	m=unique(b+1,b+m+1)-b-1;
	for(i=1;i<=n;++i){
		s[i]=lower_bound(b+1,b+m+1,s[i])-b;
		t[i]=lower_bound(b+1,b+m+1,t[i])-b;
		for(l=1;l<=s[i];++l)//tot暴力求
			for(r=m;r>=t[i];--r)++tot[l][r];
	}
	for(i=1;i<=m;++i)//注意初始化
		for(j=1;j<=n;++j)pre[i][j]=suf[i][j]=-INF;
	for(i=1;i<=m;++i)
		for(j=0;j<=tot[1][i];++j)
			for(k=1;k<=i;++k)Upd(pre,k,i);
	for(i=m;i;--i)//转移很相似，搞了个宏定义
		for(j=0;j<=tot[i][m];++j)
			for(k=i;k<=m;++k)Upd(suf,i,k);
	for(l=1;l<=m;++l)
		for(r=l+1;r<=m;++r)
			for(y=n,x=0;x<=n;++x){
				p0=Calc(y);//p0为最优决策，p1为当前决策
				while(y&&p0<=(p1=Calc(y-1)))p0=p1,--y;
				chkmx(f[l][r],Calc(y));
			}
	ans=0;
	for(j=1;j<=n;++j)chkmx(ans,min(pre[m][j],j));
	printf("%d\n",ans);
	for(i=1;i<=n;++i){
		ans=0;
		for(l=1;l<=s[i];++l)
			for(r=m;r>=t[i];--r)chkmx(ans,f[l][r]);
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：wu3412790 (赞：47)

首先，将时间离散化。设离散化后的时间区间为$[1,T]$，其中$t\leq 2n$。之后先预处理$inter[i][j]$表示完全在时间i到时间j之间举行的活动个数。

容易想到最简单的DP，$f[i][j],g[i][j]$，分别表示在区间$[1,i]$和$[i,T]$，一个会场至少举办j个活动的情况下，另一个会场至少举办多少个活动？转移就是枚举一个区间，将其中所有活动分配给某个会场。

这样一来，第一问答案可以由$\max_{j}\min(f[T][j],j)$确定。

对于第二问，如何强制让一个会场举办第i个活动? 我们可以选一个包含第i个活动的区间$[L,R]$，然后强制第一个会场举办所有在$[L,R]$之间举行的活动。并枚举在$[1,L]$与$[R,T]$这两段区间第一个会场举办的活动个数$x,y$。答案就是
$$\max_{L,R,x,y} \min(x+inter[L][R]+y,f[L][x]+g[R][y])$$。

但粗略地看起来时间复杂度很大，对于每个$k$，都要四重循环计算答案，时间复杂度是$O(n^5)$。注意到，我们可以直接计算数组
$$ans[L][R]=\max_{L,R,x,y} \min(x+inter[L][R]+y,f[L][x]+g[R][y])$$。这样就把时间复杂度降到了$O(n^4)$。

似乎对于200还是有些困难，更进一步，注意到，$f[L][x]$和$g[R][y]$分别是关于$x$和$y$的减函数。所以对于固定的$L,R$，
当$x$变大时，最优的$y$应该变小才能使答案更好。这样一来，将y作为一个随x增加而递减的指针即可。时间复杂度为$O(n^3)$。

当然，如果你嫌麻烦，或者考场上没想到这里，直接$n^4$枚举答案，加上一些很容易想到的剪枝，可以把常数控制得极小，也能轻松通过本题。。。。。。。
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int const N=401,M=101,INF=1e6;
int n,t,a[N],b[N],u[N],v[N],p[N],q[N],inter[N][N],
f[N][N],g[N][N],ans[N];
int main(){
	cin>>n;
	for (int i=1;i<=n;i++){ 
		cin>>a[i]>>b[i];
		b[i]+=a[i];
		p[++t]=a[i];
		p[++t]=b[i];
	}
	sort(p+1,p+1+t);
	q[1]=1;
	for (int i=2;i<=t;i++)
		if (p[i]==p[i-1]) q[i]=q[i-1]; else q[i]=q[i-1]+1;
	for (int i=1;i<=n;i++)
		for (int j=1;j<=t;j++) {
			if (a[i]==p[j]) u[i]=q[j];
			if (b[i]==p[j]) v[i]=q[j];
		}
	t=q[t];
	for (int i=1;i<=t;i++)
		for (int j=i+1;j<=t;j++)
			for (int k=1;k<=n;k++)
				if (u[k]>=i && v[k]<=j) inter[i][j]++;
	for (int i=1;i<=t;i++)
		for (int j=0;j<=n/2;j++){
			f[i][j]=-INF;
			if (j==0) f[i][j]=inter[1][i];
			for (int k=1;k<=i-1;k++){
				f[i][j]=max(f[i][j],f[k][j]+inter[k][i]);
				f[i][j]=max(f[i][j],f[k][max(0,j-inter[k][i])]); 
			}
		}
	for (int i=t;i>=1;i--)
		for (int j=0;j<=n/2;j++){
			g[i][j]=-INF;
			if (j==0) g[i][j]=inter[i][t];
			for (int k=i+1;k<=t;k++){
				g[i][j]=max(g[i][j],g[k][j]+inter[i][k]);
				g[i][j]=max(g[i][j],g[k][max(0,j-inter[i][k])]); 
			}
		}
	for (int k=1;k<=n;k++){
		for (int i=u[k];i>=1;i--)
			for (int j=v[k];j<=t;j++){
				for (int l=0;l<=inter[1][i];l++){
					for (int r=0;r<=inter[j][t];r++){
						ans[k]=max(ans[k],min(l+r+inter[i][j],f[i][l]+g[j][r]));
						if (g[j][r]<r) break; 		
					}
					if (f[i][l]<l) break;
				}
				if (inter[1][i]+inter[j][t]<ans[k]) break;
				if (inter[i][j]>inter[1][i]+inter[j][t]) break;
			}
		ans[0]=max(ans[0],ans[k]); 
	} 
	for (int k=0;k<=n;k++)
		cout<<ans[k]<<endl;
	return 0;
}
```

---

## 作者：command_block (赞：35)

前面的话:

这道dp优化的难度并不大,但是推导比较经典,最后的优化手段也很经典,是一道练习好题!

细节有点多,不过如果认真思考方法的话可以躲掉大部分。

~~自以为把最后的单调性优化讲的比较清楚~~

------------

题意比较复杂,简单来说吧:

给出$n$个区间,让你把这些区间分成两份,允许丢弃,**两份**区间不能有交。

**第一问**: 让两份中分到区间数最小的一份,尽量得到更多的区间。

**第二问**: 在第$\forall i$个区间必须不丢弃的情况下的上一问答案。

------------

## 分析第一问:

活动不包含开始和结束瞬间,为了方便处理,我们吧所有的区间尾先减一,就能转化成熟悉的数组占位。

显然可以把区间都离散化,设离散化之后的时间域为$[1,T]$

有一个二维dp:设$f[i][j]$为

前$i$个时刻第一份选择了$j$(可以为0)个区间,此时第二份最多能选择多少个。

(注意要初始化成-INF,边界是$f[0][0]=0$)

为了方便处理,我们在离散化后时间轴上留一前一后**两个空位**。

**转移:**

先设$c(l,r)$指被$[l,r]$完全包含的区间个数。

这个东西可以大力$O(n^3)$预处理,方法就是判断每个区间有没有被包容在$[l,r]$内。

- (1)选择一段区间放到第一份

$f[i][j]\leftarrow\max\limits_{k=1}^{i-1}f[k][j-c(k+1,i)]$

- (2)选择一段区间放到第二份

$f[i][j]\leftarrow\max\limits_{k=1}^{i-1}f[k][j]+c(k+1,i)$

那么答案就是$\max\limits_{j=0}^{n}min(f[T][j],j)$

总的复杂度是$O(n^3)$

## 分析第二问:

如何强制选择某一个区间?我们可以先把这个区间给予某一份(那一份都行,**不妨给第一份**),然后把剩下的东西算出来。

详细地说:

我们要设$g[i][j]$为

后$i$个时刻第一份选择了$j$个区间,此时第二份最多能选择多少个。

转移类似$f$,不再赘述。(边界是$g[n+1][0]=0$)

那么,强制选择了某个区间$[l,r]$给第二份之后,我们要枚举中间分给第一份的一整段区间(包含$[l,r]$)

此外还要枚举第一份选择的区间数(前后都要枚举):

$\max\limits_{i=1}^{l-1}\max\limits_{j=r+1}^{T}\max\limits_{k=0}^{n}\max\limits_{t=0}^{n}min(f[i][k]+g[j][t],k+t+c(i+1,j-1))$

这个式子是$O(n^4)$的,总复杂度就是$O(n^5)$,不能通过本题。

对于每个小区间都找一个大段来包含,我们其实做了很多重复的工作。

设$s(l,r)=\max\limits_{k=0}^{n}\max\limits_{t=0}^{n}min(f[l][k]+g[r][t],k+t+c(l+1,r-1))$

(注意这个区间两边开)

那么答案就变成$\max\limits_{i=1}^{l-1}\max\limits_{j=r+1}^{T}s(i,j)$,这样子就是一次$O(n^2)$的了。

问题在于如何预处理$s(l,r)$,按照上面的式子爆算复杂度高达$O(n^4)$,但是据说加剪枝卡常能过。

先贴一个暴力Code:

由于数据过水居然AC了?看来考场上也可以使用这些面向数据编程的办法,毕竟数据不好造啊……

```cpp
#include<algorithm>
#include<cstdio>
#define MaxN 205
#define INF 1000000000
using namespace std;
int n;
struct Line
{int l,r;}l[MaxN];
int xx[MaxN*2],tot;
int f[MaxN*2][MaxN],g[MaxN*2][MaxN];
int c[MaxN*2][MaxN*2],s[MaxN*2][MaxN*2];
int main()
{
  scanf("%d",&n);
  for (int i=1;i<=n;i++){
  	scanf("%d%d",&l[i].l,&l[i].r);
  	l[i].r+=l[i].l-1;
  	xx[++tot]=l[i].l;
  	xx[++tot]=l[i].r;
  }sort(xx+1,xx+tot+1);
  for (int i=1;i<=n;i++){
  	l[i].l=lower_bound(xx+1,xx+tot+1,l[i].l)-xx+1;
  	l[i].r=lower_bound(xx+1,xx+tot+1,l[i].r)-xx+1;
  }tot+=2;

  for (int i=1;i<=tot;i++)
    for (int j=i;j<=tot;j++)
      for (int k=1;k<=n;k++)
        if (i<=l[k].l&&l[k].r<=j)
		  c[i][j]++;

  for (int i=0;i<=tot+1;i++)
    for (int j=0;j<=n;j++)
      f[i][j]=g[i][j]=-INF;
  f[0][0]=g[tot+1][0]=0;
  for (int i=1;i<=tot;i++)
    for (int j=0;j<=n;j++)
      for (int k=0,sav;k<i;k++){
        sav=c[k+1][i];
        if (j>=sav)f[i][j]=max(f[i][j],f[k][j-sav]);
        f[i][j]=max(f[i][j],f[k][j]+sav);
      }

  int ans=0;
  for (int i=0;i<=n;i++)
    ans=max(ans,min(f[tot][i],i));
  printf("%d\n",ans);
  
  for (int i=tot;i;i--)
    for (int j=0;j<=n;j++)
      for (int k=i+1,sav;k<=tot+1;k++){
        sav=c[i][k-1];
        if (j>=sav)g[i][j]=max(g[i][j],g[k][j-sav]);
        g[i][j]=max(g[i][j],g[k][j]+sav);
      }
  
  for (int i=1;i<=tot;i++)
    for (int j=i+2;j<=tot;j++){
      s[i][j]=-INF;
      for (int k=0;k<=n;k++){
        if (f[i][k]<0)break;
        for (int t=0;t+k<=n;t++){
          if (g[j][t]<0)break;
          s[i][j]=max(s[i][j],
		    min(f[i][k]+g[j][t],k+t+c[i+1][j-1])
		  );
        }
      }
    }

  for (int t=1;t<=n;t++){
    ans=0;
    for (int i=1;i<l[t].l;i++)
      for (int j=l[t].r+1;j<=tot;j++)
        ans=max(ans,s[i][j]);
    printf("%d\n",ans);
  }return 0;
}
```

再看一遍式子:

$s(l,r)=\max\limits_{k=0}^{n}\max\limits_{t=0}^{n}min(f[l][k]+g[r][t],k+t+c(l+1,r-1))$

我们发现这个$min$很烦,但是它的左右两边分别是两份的区间数,这两份的地位是一样的。

那么,对于一种分法,把两份的内容交换又能得到另一种,所以会在$min$中按两种顺序各出现一次。

也就是说,我们直接认为$k+t+c(l+1,r-1)$是较大值,按照这个规则来优化,最终不会漏掉最优解。

(前面讲了$c(l+1,r-1)$这个常数分给谁无所谓,那么现在规定顺序以后分给最大值肯定不会影响。)

现在的目标就是尽量让左边变大(在维持右边大的情况下)

我们发现,$f[l][k]$随着$k$的增大而减小;$g[r][t]$随着$t$的增大而减小。

那么,再$k$增加的时候,再令$t$增加显然不优,因为我们在单纯地削减左边而增加右边。

有了这个单调性,预处理的复杂度就变为了$O(n^3)$,可以轻松通过本题。

**Code:**

貌似只比暴力快了一倍……

```cpp
#include<algorithm>
#include<cstdio>
#define MaxN 205
#define INF 1000000000
using namespace std;
int n;
struct Line
{int l,r;}l[MaxN];
int xx[MaxN*2],tot;
int f[MaxN*2][MaxN],g[MaxN*2][MaxN];
int c[MaxN*2][MaxN*2],s[MaxN*2][MaxN*2];
int main()
{
  scanf("%d",&n);
  for (int i=1;i<=n;i++){
  	scanf("%d%d",&l[i].l,&l[i].r);
  	l[i].r+=l[i].l-1;
  	xx[++tot]=l[i].l;
  	xx[++tot]=l[i].r;
  }sort(xx+1,xx+tot+1);
  for (int i=1;i<=n;i++){
  	l[i].l=lower_bound(xx+1,xx+tot+1,l[i].l)-xx+1;
  	l[i].r=lower_bound(xx+1,xx+tot+1,l[i].r)-xx+1;
  }tot+=2;

  for (int i=1;i<=tot;i++)
    for (int j=i;j<=tot;j++)
      for (int k=1;k<=n;k++)
        if (i<=l[k].l&&l[k].r<=j)
		  c[i][j]++;

  for (int i=0;i<=tot+1;i++)
    for (int j=0;j<=n;j++)
      f[i][j]=g[i][j]=-INF;
  f[0][0]=g[tot+1][0]=0;
  for (int i=1;i<=tot;i++)
    for (int j=0;j<=n;j++)
      for (int k=0,sav;k<i;k++){
        sav=c[k+1][i];
        if (j>=sav)f[i][j]=max(f[i][j],f[k][j-sav]);
        f[i][j]=max(f[i][j],f[k][j]+sav);
      }

  int ans=0;
  for (int i=0;i<=n;i++)
    ans=max(ans,min(f[tot][i],i));
  printf("%d\n",ans);
  
  for (int i=tot;i;i--)
    for (int j=0;j<=n;j++)
      for (int k=i+1,sav;k<=tot+1;k++){
        sav=c[i][k-1];
        if (j>=sav)g[i][j]=max(g[i][j],g[k][j-sav]);
        g[i][j]=max(g[i][j],g[k][j]+sav);
      }
  
  for (int i=1;i<=tot;i++)
    for (int j=i+2;j<=tot;j++){
      s[i][j]=-INF;
      for (int k=0,sav,t=n;k<=n;k++){
        if (f[i][k]<0)break;
        while(t>=0){
          sav=min(f[i][k]+g[j][t],k+t+c[i+1][j-1]);
          if (sav>=s[i][j])s[i][j]=sav;
          else break;
          t--;
        }t++;
      }
    }

  for (int t=1;t<=n;t++){
    ans=0;
    for (int i=1;i<l[t].l;i++)
      for (int j=l[t].r+1;j<=tot;j++)
        ans=max(ans,s[i][j]);
    printf("%d\n",ans);
  }return 0;
}
```

---

## 作者：rsdbk_husky (赞：21)

[题目传送门](https://www.luogu.com.cn/problem/P1973)

[博客食用效果更佳](https://rsdbkhusky.github.io/2021/10/13/%E5%8F%8C%E6%8C%87%E9%92%88%E4%BC%98%E5%8C%96dp%20&%20Luogu%20P1973%20%5BNOI2011%5D%20NOI%20%E5%98%89%E5%B9%B4%E5%8D%8E/)

## 一. 思路

首先进行离散化，将所有区间左右端点离散化，离散成 $m$ 个“离散点”，只有这些地方才可能设置为断点，不然一定是不优的。

首先考虑朴素DP，设 $sec_{l,r}$ 为完全被包含在离散点 $l\sim r$ 内的区间总数，直接 
 $O(n^3)$ 暴力求就好了。

$pre_{i,j}$：离散点 $1\sim i$ 内包含的区间，一个组分到 $j$ 个区间时，另一组能分到的最大值。我们的方程应该写成这样：
$$
pre_{i,j}=\max\limits_{k=1}^{k<i}\{pre_{k,j}+sec_{k,i},pre_{k,j-sec_{k,i}}\}
$$

然后没有限制条件下的答案就是 $\max\limits_{j=1}^n\{\min(pre_{m,j},j)\}$

$suf_{i,j}$：离散点 $i\sim m$ 内包含的区间，一个组分到 $j$ 个区间时，另一组能分到的最大值，与 $pre$ 相似。

$d_{i,j}$：限制为离散点 $i\sim j$ 间不能有断点的情况下分到的区间较少的组别中区间数量的最大值，有状转方程：

$$
d_{l,r}=\max_{x=1}^{m}\max_{y=1}^{m}\left\{\min\left(x+sec_{l,r}+y,pre_{l, x}+suf_{r, y}\right)\right\}
$$

要求编号为 $i$ 的区间（左端点为 $le_i$，右端点 $ri_i$）不能被舍弃下的答案是：

$$
ans_{i}=\max _{l=1}^{le_{i}} \max _{r=ri_{i}}^{m}\left\{d_{l, r}\right\}
$$

可以看到，整个解题过程的瓶颈就是 $2\operatorname{D}/2\operatorname{D}$ 的求 $d_{i,j}$ 的过程，我们无法承受 $O(n^4)$ 的复杂度，要考虑优化，我们发现对于固定的 $l,r$，固定一个 $x$ 后，有一个 $y$ 使 $\min\left(x+sec_{l,r}+y,pre_{l,x}+suf_{r,y}\right)$ 最大，设这个值为 $y'_x$ ，根据 $pre_i$ 的性质，$j$ 不变时，$pre_{i,j}$ 随着 $j$ 增大而减小。

假设我们已求出了 $y'_{x}$，现在考虑 $y'_{x+a}$（$a$ 为正整数），$x+a$ 相对于 $x$，$y$ 不变，$x+sec_{l,r}+y$ 的值增加，$pre_{l,x}+suf_{r,y}$ 的值减小。$y'_x+b$ （$b$ 为正整数）相对于 $y'_x$，$x$ 不变，$x+sec_{l,r}+y$ 的值增加，$pre_{l,x}+suf_{r,y}$ 的值减小。

所以得出结论，$y'_{x+a}\le y'_x$，因为 $>y'_x$ 的决策，对 $x$ 是不优的，那么对于 $x+a$ 就更不优了。

设 $g_{l,r,x}(y)=\min\left(x+sec_{l,r}+y,pre_{l,x}+suf_{r,y}\right)$（在接下来的推导中都将 $l$ 和 $r$ 当作常量，所以简写为 $g_x(y)$），仔细想想可以发现，该函数有一个极值，即 $x+sec_{l,r}+y=pre_{l,x}+suf_{r,y}$ 时，当然因为取值都是整数他们有可能没有相等的时刻，这里指的是连成平滑曲线后的函数。并且函数 $g_x(y)$ 极点的一侧单调。

请注意现在的一个**函数**对应的是一个**状态**，**横坐标**对应的是**决策**。

于是我们尝试画出这个图象，刚才我们已经证出两条性质：

- $op$（最优决策）具有单调性。
- $g_i(j)$ 极点的一侧具有单调性。

![](https://figurebed-1306986731.file.myqcloud.com/%E8%AF%BE%E4%BB%B6/%E6%A0%91%E5%BD%A2DP%20%26%20DP%E4%BC%98%E5%8C%96/6.png)

（图像仅供参考，不代表实际上就长这样，该图象只显示出了对解题有用的特征）

- $op$（最优决策）具有单调性。
- $g_i(j)$ 极点的一侧具有单调性。

根据这两条性质，可以直接用一个指针从右往左扫，向上“爬坡”，到顶点后就记录这个值，并转到下一条函数：

![](https://figurebed-1306986731.file.myqcloud.com/%E8%AF%BE%E4%BB%B6/%E6%A0%91%E5%BD%A2DP%20%26%20DP%E4%BC%98%E5%8C%96/7.png)

转移的代码实现：

```cpp
for (int i = 1; i <= cntmap; ++i) {
	for (int j = i + 1; j <= cntmap; ++j) {
		int y = n;
		for (int x = 0; x <= n; ++x) {
			while (y && min(x+sec[i][j]+y,pre[i][x]+suf[j][y])<=min(x+sec[i][j]+y-1,pre[i][x]+suf[j][y-1])) --y;
			d[i][j] = max(d[i][j], min(x + sec[i][j] + y, pre[i][x] + suf[j][y]));
		}
		ans = max(ans, d[i][j]);
	}
}
```

## 二. 细节

**很重要，也很致命**。

1. 向上“爬坡”时，我们需要比较指针当前位置和指针下一个位置作为决策哪一个更优，有人会用 ```<=```，有人会用 ```<```，如果你用 ```<```，你会获得 ${\color{Red}0}$ 分的好成绩。问题在哪呢？如果有一个这样的函数：

   ![](https://figurebed-1306986731.file.myqcloud.com/%E8%AF%BE%E4%BB%B6/%E6%A0%91%E5%BD%A2DP%20%26%20DP%E4%BC%98%E5%8C%96/8.png)

2. 我们的代码实现和理论是有一定区别的，通常会自动忽略一些不可能是最优的决策，以本体为例，比如有这样的一个“区间”，里面刚好包含两个重合的区间（还记得加和不加引号的“区间”分别代表什么吗？）：

   ![](https://figurebed-1306986731.file.myqcloud.com/%E8%AF%BE%E4%BB%B6/%E6%A0%91%E5%BD%A2DP%20%26%20DP%E4%BC%98%E5%8C%96/9.png)

   我们当然不会舍弃这两个区间其中任意一个，因为完全可以不舍弃。但确实有一种选择是舍弃其中一个，虽然这样不优，但我们在代码中做的是将所选“区间”中区间的数量作为权值 $sec$，计算的时候加上 $sec$，就相当于忽略了舍弃一个区间这种情况，这就导致我在输出数组 $suf$ 中的值时，看到了这样的一幕：

   ![](https://figurebed-1306986731.file.myqcloud.com/%E8%AF%BE%E4%BB%B6/%E6%A0%91%E5%BD%A2DP%20%26%20DP%E4%BC%98%E5%8C%96/10.png)

可以看到，$suf$ 函数不是单调的了，这是因为我的输入数据有两个区间是重合的，我们在计算 $suf$ 时没有算只丢弃他们之中一个这种情况，对于朴素DP自然无伤大雅，但双指针优化DP要求函数有严格的单调不降性。用图像来说话就是出现了这种情况：

   ![](https://figurebed-1306986731.cos.ap-beijing.myqcloud.com/%E8%AF%BE%E4%BB%B6/%E6%A0%91%E5%BD%A2DP%20%26%20DP%E4%BC%98%E5%8C%96/11.png)

   **注意**：上面这个函数表示的是数组里存的值，是用计算机算出来的值，而非实际的函数，如果函数确实就长这样他根本就满足不了双指针优化的前提条件！

   因为满足 $suf_i\ge suf_{i+a}$（$a$ 为正整数），可以将这个坑填平：

   ![](https://figurebed-1306986731.file.myqcloud.com/%E8%AF%BE%E4%BB%B6/%E6%A0%91%E5%BD%A2DP%20%26%20DP%E4%BC%98%E5%8C%96/12.png)

填坑代码实现：

```cpp
for (int i = 1; i <= cntmap; ++i) {
	for (int j = n - 1; ~j; --j) {
		pre[i][j] = max(pre[i][j], pre[i][j + 1]);
	}
}

for (int i = 1; i <= cntmap; ++i) {
	for (int j = n - 1; ~j; --j) {
		suf[i][j] = max(suf[i][j], suf[i][j + 1]);
	}
}
```

## 三. 代码

完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXn = 2e2;

template <typename T> 
inline void read(T &a) {
    register char c;while (c = getchar(), c < '0' || c > '9');register T x(c - '0');while (c = getchar(), c >= '0' && c <= '9') {x = (x << 1) + (x << 3) + (c ^ 48);}a = x;  
}
template <typename T, typename ...Argv>
inline void read(T &n, Argv &...argv) {
    read(n), read(argv...);
}

int n;
int cntmap, mapup[MAXn * 2 + 10]; map<int, int> mapdown;
int le[MAXn + 10], ri[MAXn + 10];
int sec[MAXn * 2 + 10][MAXn * 2 + 10];
int pre[MAXn * 2 + 10][MAXn + 10], suf[MAXn * 2 + 10][MAXn + 10], d[MAXn * 2 + 10][MAXn * 2 + 10], ans;
signed main() {
	read(n);
	for (int i = 1, l, len, r; i <= n; ++i) {
		read(l, len); r = l + len;
		le[i] = l;
		ri[i] = r;
		mapup[++cntmap] = l;
		mapup[++cntmap] = r;
	}
	sort(mapup + 1, mapup + 1 + cntmap);
	cntmap = unique(mapup + 1, mapup + 1 + cntmap) - (mapup + 1);
	for (int i = 1; i <= cntmap; ++i) {
		mapdown[mapup[i]] = i;
	}
	for (int i = 1; i <= n; ++i) {
		le[i] = mapdown[le[i]];
		ri[i] = mapdown[ri[i]];
	}
	for (int i = 1; i <= cntmap; ++i) {
		for (int j = i + 1; j <= cntmap; ++j) {
			for (int k = 1; k <= n; ++k) {
				if (le[k] >= i && ri[k] <= j) ++sec[i][j];
			}
		}
	}
	memset(pre, 0xc0, sizeof(pre));
	pre[1][0] = 0;
	for (int i = 2; i <= cntmap; ++i) {
		for (int j = 0; j <= n; ++j) {
			for (int k = 1; k < i; ++k) {
				pre[i][j] = max(pre[i][j], max(pre[k][j - sec[k][i]], pre[k][j] + sec[k][i]));
			}
		}
	}
	for (int i = 1; i <= cntmap; ++i) {
		for (int j = n - 1; ~j; --j) {
			pre[i][j] = max(pre[i][j], pre[i][j + 1]);
		}
	}
	memset(suf, 0xc0, sizeof(suf));
	suf[cntmap][0] = 0;
	for (int i = cntmap - 1; i; --i) {
		for (int j = 0; j <= n; ++j) {
			for (int k = cntmap; k > i; --k) {
				suf[i][j] = max(suf[i][j], max(suf[k][j - sec[i][k]], suf[k][j] + sec[i][k]));
			}
		}
	}
	for (int i = 1; i <= cntmap; ++i) {
		for (int j = n - 1; ~j; --j) {
			suf[i][j] = max(suf[i][j], suf[i][j + 1]);
		}
	}
	for (int i = 1; i <= cntmap; ++i) {
		for (int j = i + 1; j <= cntmap; ++j) {
			int y = n;
			for (int x = 0; x <= n; ++x) {
				while (y && min(x + sec[i][j] + y, pre[i][x] + suf[j][y]) <= min(x + sec[i][j] + y - 1, pre[i][x] + suf[j][y - 1])) --y;
				d[i][j] = max(d[i][j], min(x + sec[i][j] + y, pre[i][x] + suf[j][y]));
			}
			ans = max(ans, d[i][j]);
		}
	}
	printf("%d\n", ans);
	for (int i = 1; i <= n; ++i) {
		int partans = 0;
		for (int j = le[i]; j; --j) {
			for (int k = ri[i]; k <= cntmap; ++k) {
				partans = max(partans, d[j][k]);
			}
		}
		printf("%d\n", partans);
	}
}
```

---

## 作者：longlongzhu123 (赞：21)

# 解决方案：DP

>   题目给出一些区间（活动），A、B两个会场分别选择其中一些，选择的区间不能有重叠部分。

有两个问题：

1. 求出两个会场中选择活动最少的一个会场，最多能选择几个活动。

2. 求出两个会场中选择活动最少的一个会场，最多能选择几个活动（但要保证其中一个会场选择第$i$个活动）。

让我们分别来考虑两个问题。

# 预处理

可以看到时间比较大，下面会使用到时间作为DP的下标，请**离散化**。

设 $t$ 为离散化后的最大时间点。

设 $cnt[i][j]$ 为：从时间 $i$ 到时间 $j$ 中，（完整的）活动有多少个。

计算 $cnt$ ，可以直接暴力求出（枚举 $i$ ，枚举 $j$ ，枚举一个活动，若此活动在 $i$ 、 $j$ 区间内， $cnt[i][j]$ 加1）

**代码**：

```cpp
for(int i = 1; i <= t; i ++) {
	for(int j = 1; j <= t; j ++) {
		for(int k = 1; k <= n; k ++) {
			if(i <= a[k].begin && a[k].end <= j) {
				cnt[i][j] ++;
			}
			if(j <= a[k].begin && a[k].end <= i) {
				cnt[i][j] ++;
			}
		}
	}
}
```

# 对于第一问

设 $pre(i, j)$ 为：对于前 $i$ 个时间（时间 $[1, i]$ ），若会场A保证选择了 $j$  个活动，会场B最多能选择多少活动。

设 $suf(i, j)$ 为：对于后 $(t - i)$ 个时间（时间 $[i, t]$ ），若会场A保证选择了 $j$  个活动，会场B最多能选择多少活动。（ $suf$ 与 $pre$ 比较类似，后面（第二问）才会用到）

$pre$ 和 $suf$ 先预处理为 $-INF$ 。（注意： $INF$ 不能太大，否则相减时会溢出）

```cpp
for(int i = 0; i <= t; i ++) {
    for(int j = 0; j <= n; j ++) {
        pre[i][j] = suf[i][j] = -INF;
    }
}
```

得到转移方程：

$\large pre(i, j) = \max \limits _{1 \le k \le i}  pre(k, j - cnt[k][i])$

$\large \operatorname{suf}(i, j) = \max \limits _{i \le k \le t} suf(k, j - cnt[i][k])$

解释：如果从前 $i$ 个时间中选择 $j$ 个活动，可以转换为：从前 $k$ 个时间中选择 $j - cnt[i][k]$ 个活动，将剩下的 $cnt[i][k]$ 个活动分给A会场。

$suf$ 同理。

**代码**：

```cpp
for(int i = 1; i <= t; i ++) {
    for(int j = 0; j <= cnt[1][i]; j ++) {
        if(j == 0) {
            pre[i][j] = cnt[1][i];
        }
        else {
            for(int k = 1; k <= i; k ++) {
                pre[i][j] = max(pre[i][j], pre[k][j] + cnt[k][i]);
                if(j >= cnt[k][i])
                    pre[i][j] = max(pre[i][j], pre[k][j - cnt[k][i]]);
            }
        }
    }
}
for(int i = t; i >= 1; i --) {
    for(int j = 0; j <= cnt[i][t]; j ++) {
        if(j == 0) {
            suf[i][j] = cnt[i][t];
        }
        else {
            for(int k = i; k <= t; k ++) {
                suf[i][j] = max(suf[i][j], suf[k][j] + cnt[i][k]);
                if(j >= cnt[i][k])
                    suf[i][j] = max(suf[i][j], suf[k][j - cnt[i][k]]);
            }
        }
    }
}
```

对于第一问，答案就是 $\large \max \limits _{1 \le i \le n} \{ min(pre[t][i], i) \}$

```cpp
int answer = -INF;
for(int i = 1; i <= n; i ++) {
	answer = max(answer, min(pre[t][i], i));
}
cout<<answer<<endl;
```

# 对于第二问

第二问就有点麻烦了。必须选择第 $k$ 个活动，假设将第 $k$ 个活动分给A会场（分给谁都没关系），那么可以枚举一个包含第 $k$ 个活动的区间 $[i, j]$，让其中的所有完整区间都分给A会场（当然也包含第 $i$ 个活动）。

这时再枚举一个 $x$ 和一个 $y$ ，让A会场在区间两边分别选择 $x$ 和 $y$ 个活动，得到答案。

$\large ans = \max \limits _{i, j, x, y} \{min(x + cnt[i][j] + y, pre(i,x) + suf(j,y))\} $

其中A会场选择 $x + cnt[i][j] + y$ 个活动， 剩下 $pre(i, x) + suf(j, y)$ 个活动留给B会场。

有一点需要注意：答案必须枚举 $i, j$ 。原因是可能会有一个活动，跨过第 $k$ 个活动的开始或结束，此时不管是 $x + cnt[i][j] + y$ 还是 $pre(i, x) + suf(j, y)$ 都不会包含它。

```
k：                   = = = = = =
某一个活动：    = = = = =
```

看起来时间复杂度很大，对于每个 $k$，都要枚举 $i, j, x, y$ ，复杂度高达 $O(n^5)$ ！

事实上，我们可以计算 $ans[i][j]$ 为必须选择 $[i, j]$ 区间时的答案，时间复杂度降为 $O(n^4)$ 。

对于第 $k$ 个活动，枚举 $i, j$ ，答案为 $\max \limits _{1 \le i, j \le t} \{ ans[i][j] \}$ 。

得到复杂度为 $O(n^4)$ 的算法。

# 第二问优化

第二问计算的效率瓶颈在于 $ans[i][j]$ 上。

让我们思考一下：在 $pre(i, j)$ 中，当 $j$ 越来越小时，就说明A会场在 $[1, i]$ 区间中选择得更少，相应地B会场选择得更多。

就是说，当 $j$ 越来越小， $pre(i, j)$ 的值会越来越大。

$suf(i, j)$ 也同理。它们都是**单调函数**。

那么当计算 $ans[i][j]$ 时，随着 $x$ 的增大， $y$ 只有减小，才能更新答案。

我们不需要枚举 $y$ 了，而是让 $y$ 作为一个（扫描）指针，从 $n$ 开始慢慢减小。

当 $y$ 无法更新答案时，就将 $y$ 减1，时间复杂度 $O(n^3)$ 。

代码常数较大，开O2即可通过本题。

![](https://cdn.luogu.com.cn/upload/pic/37443.png)

```cpp
//  持续时间time，实际上end = begin + time - 1
#include<bits/stdc++.h>
#include<unordered_map>
#include<unordered_set>
using namespace std;
const int MAXN = 2 * 200 + 10;
const int INF = 10000;
struct Mapping {
	unordered_map<int, int> m;
	unordered_map<int, int> am;
	int top;
	int query(int x) {
		if(!m.count(x)) {
			m[x] = ++ top;
			am[top] = x;
		}
		return m[x];
	}
	int anti_query(int x) {
		return am[x];
	}
};
struct Act {
	int begin, time, end;
	int index;
};
int n, t;
Act a[MAXN];
Mapping Map;
unordered_set<int> dis_set;
vector<int> dis_array;
void disp() {  //  离散化
	for(int i = 1; i <= n; i ++) {
		dis_set.insert(a[i].begin);
		dis_set.insert(a[i].end);
	}
	for(unordered_set<int>::iterator iter = dis_set.begin(); iter != dis_set.end(); iter ++) {
		dis_array.push_back(*iter);
	}
	sort(dis_array.begin(), dis_array.end());
	for(unsigned int i = 0; i < dis_array.size(); i ++) {
		Map.query(dis_array[i]);
	}
	for(int i = 1; i <= n; i ++) {
		a[i].begin = Map.query(a[i].begin);
		a[i].end = Map.query(a[i].end);
	}
}
int cnt[MAXN][MAXN];
int pre[MAXN][MAXN];
int suf[MAXN][MAXN];
int ans[MAXN][MAXN];
//  在ans数组计算中使用
int answer_clac(int i, int j, int x, int y) {
	return min(x + cnt[i][j] + y, pre[i][x] + suf[j][y]);
}
int main() {
	cin>>n;
	for(int i = 1; i <= n; i ++) {
		cin>>a[i].begin>>a[i].time;
		a[i].end = a[i].begin + a[i].time;
		a[i].index = i;
	}
	//  离散化
	disp();
	//  预处理cnt数组
	t = Map.m.size();
	for(int i = 1; i <= t; i ++) {
		for(int j = 1; j <= t; j ++) {
			for(int k = 1; k <= n; k ++) {
				if(i <= a[k].begin && a[k].end <= j) {
					cnt[i][j] ++;
				}
				if(j <= a[k].begin && a[k].end <= i) {
					cnt[i][j] ++;
				}
			}
		}
	}
	for(int i = 0; i <= t; i ++) {
		for(int j = 0; j <= n; j ++) {
			pre[i][j] = suf[i][j] = -INF;
		}
	}
	for(int i = 1; i <= t; i ++) {
		for(int j = 0; j <= cnt[1][i]; j ++) {
			if(j == 0) {
				pre[i][j] = cnt[1][i];
			}
			else {
				for(int k = 1; k <= i; k ++) {
					pre[i][j] = max(pre[i][j], pre[k][j] + cnt[k][i]);
					if(j >= cnt[k][i])
						pre[i][j] = max(pre[i][j], pre[k][j - cnt[k][i]]);
				}
			}
		}
	}
	for(int i = t; i >= 1; i --) {
		for(int j = 0; j <= cnt[i][t]; j ++) {
			if(j == 0) {
				suf[i][j] = cnt[i][t];
			}
			else {
				for(int k = i; k <= t; k ++) {
					suf[i][j] = max(suf[i][j], suf[k][j] + cnt[i][k]);
					if(j >= cnt[i][k])
						suf[i][j] = max(suf[i][j], suf[k][j - cnt[i][k]]);
				}
			}
		}
	}
	int answer = -INF;
	for(int i = 1; i <= n; i ++) {
		answer = max(answer, min(pre[t][i], i));
	}
	cout<<answer<<endl;
	for(int i = 1; i <= t; i ++) {
		for(int j = 1; j <= t; j ++) {
			ans[i][j] = -INF;
			int y = n;
			for(int x = 0; x <= n; x ++) {
				int now, next;
				for(; y >= 0; y --) {
					now = answer_clac(i, j, x, y);
					next = answer_clac(i, j, x, y - 1);
					if(next < now)
						break;
				}
				ans[i][j] = max(ans[i][j], now);
			}
		}
	}
	for(int i = 1; i <= n; i ++) {
		answer = -INF;
		for(int j = 1; j <= a[i].begin; j ++) {
			for(int k = a[i].end; k <= t; k ++) {
				answer = max(answer, ans[j][k]);
			}
		}
		cout<<answer<<endl;
	}
	return 0;
}
```

---

## 作者：0x3F (赞：11)

首先将时间离散化。设离散化以后时间的值域为 $[1,N], N \leq 2n$ 。

可以 $\mathcal{O}(n^2)$ 前缀和（其实 $\mathcal{O}(n^3)$ 暴力就行啦）预处理 $\operatorname{cnt}_{l,r}$ ，表示完全包含在 $[l,r]$ 之间的活动数量。

$\operatorname{pre}_{i,j}$ 表示在区间 $[1,i]$ 中，保证其中一个会场至少有 $j$ 场活动时，另一个会场活动数量的最大值。

初始条件是： $\operatorname{pre}_{1,0} = 0$ 。不可行的都赋为 $-\infty$ 。（我代码里赋了 $-1$ 并特判）

转移方法是枚举区间 $[k, i]$，将其中所有活动都分配给某一个会场。

具体来讲是：

$$\operatorname{pre}_{i,j} = \max_{k = 1}^{i}\{\operatorname{pre}_{k,j} + \operatorname{cnt}_{k,i}\}$$

以及

$$\operatorname{pre}_{i,j} = \max_{k = 1}^{i}\{\operatorname{pre}_{k,\max(j-\operatorname{cnt}_{k,i},0)}\}$$

$\operatorname{suf}_{i,j}$ 表示在区间 $[i,N]$ 中（类似的事情），这里不再做赘述。

然后我们就发现 $\operatorname{pre}_{n}$（其实 $\operatorname{suf}_1$ 也是）记录了全局的情况。

于是第一问就可以解决了：

$$\operatorname{ans}_0=\max_{i=1}^{N}\{\min(i,\operatorname{pre}_{N,i})\}$$

到这里时间复杂度 $\mathcal{O}(n^3)$ 。

关键在于第二问。有一个活动强制选择，怎么处理呢？

我们可以枚举一个完全包含这一项活动的区间，把区间内所有的活动都分配给某一个会场。至于这个区间的两侧，再分别枚举它们有几个活动分配给该会场，其余的都分配给另一个会场。

于是答案就是：

$$\operatorname{ans}_i=\max_{L=1}^{l_i}\max_{R=r_i}^{N}\max_{x=0}^{n}\max_{y=0}^{n}\{\min(\operatorname{cnt}_{L,R}+x+y,\operatorname{pre}_{L,x}+\operatorname{suf}_{R,y})\}$$

那么，为什么不能直接就这个活动本身的左右两边进行讨论呢？很简单，如果有另一项活动跨越了它的端点，它就永远不可能被选择。

现在这个算法是 $\mathcal{O}(n^5)$ 的。但是，我们发现强制选取的区间，它会被计算多遍，所以可以先把它预处理一下，也就是：

$$\operatorname{tmp}_{L,R}=\max_{x=0}^{n}\max_{y=0}^{n}\{\min(\operatorname{cnt}_{L,R}+x+y,\operatorname{pre}_{L,x}+\operatorname{suf}_{R,y})\}$$

而

$$\operatorname{ans}_i=\max_{L=1}^{l_i}\max_{R=r_i}^{N}\{\operatorname{tmp}_{L,R}\}$$

现在时间复杂度为 $\mathcal{O}(n^4)$，瓶颈在求 $\operatorname{tmp}$ 上。

然后我们发现，在求解 $\operatorname{tmp}$ 时，当 $x$ 增加时，$y$ 应当减小才能达到一个新的最优位置。

于是可以不枚举 $y$ ，而是使用双指针，当 $x$ 增加时，$y$ 减少到不能再减少（也就是减少以后会是答案变小）。

于是时间复杂度就变成了 $\mathcal{O}(n^3)$ 。可以过了。

那为什么这是对的呢？在大多数题解里都没有证明。

所以我来大致说明一下双指针的正确性。

我们用双指针求的是 关于 $x,y$ 的函数 $f(x,y)=\min(\operatorname{cnt}_{L,R}+x+y,\operatorname{pre}_{L,x}+\operatorname{suf}_{R,y})$ 的最大值。

首先，当 $x$ 不变时，$\operatorname{cnt}_{L,R}+x+y$ 单调增加，而 $\operatorname{pre}_{L,x}+\operatorname{suf}_{R,y}$ 单调不增，

所以 $f(x,y)$ 是关于 $y$ 的非严格单峰函数。

所以减少到不能再减少就停止的办法是可行的。

然后，当 $x$ 增加时，$\operatorname{cnt}_{L,R}+x+y$ 常数项（因为是关于 $y$ ，所以 $x$ 就是常数项）增加，而 $\operatorname{pre}_{L,x}+\operatorname{suf}_{R,y}$ 常数项不增，

画图可知交点会往左移。所以峰值所对应的 $y$ 的值不减。

注意两个代码细节：

1. 转移中，$\operatorname{pre}_{i,j} = \max_{k = 1}^{i}\{\operatorname{pre}_{k,\max(j-\operatorname{cnt}_{k,i},0)}\}$，不可写 $\operatorname{pre}_{k,j-\operatorname{cnt}_{k,i}}$ ，否则函数的单调性就不能保证。

2. 双指针中，$y$ 在转移时，新答案和旧答案比较时一定要使用 $\leq$ ，而不是 $\lt$ 。因为我说过它是非严格单峰函数。

综上，算法时间复杂度 $\mathcal{O}(n^3)$，代码如下：

```cpp
#include <cstdio>
#include <algorithm>
#define _ 210
#define __ 410
int n, N, s[_], t[_], p[__];
int cnt[__][__], pre[__][_], suf[__][_], tmp[__][__], ans[_];
inline int max(int a, int b) {
	return a>b?a:b;
}
inline int min(int a, int b) {
	return a<b?a:b;
}
int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		scanf("%d%d", s+i, t+i);
		t[i] += s[i];
		p[++N] = s[i];
		p[++N] = t[i];
	}
	std::sort(p+1, p+N+1);
	N = std::unique(p+1, p+N+1) - p - 1;
	for (int i = 1; i <= n; i++) {
		s[i] = std::lower_bound(p+1, p+N+1, s[i]) - p;
		t[i] = std::lower_bound(p+1, p+N+1, t[i]) - p;
		cnt[s[i]][t[i]]++;
	}
	for (int l = 1; l <= N; l++) {
		for (int i = 1; i+l <= N; i++) {
			cnt[i][i+l] += cnt[i][i+l-1] + cnt[i+1][i+l] - cnt[i+1][i+l-1];
		}
	}
	pre[1][0] = 0;
	for (int j = 1; j <= n; j++) {
		pre[1][j] = -1;
	}
	for (int i = 2; i <= N; i++) {
		for (int j = 0; j <= n; j++) {
			pre[i][j] = -1;
			for (int k = 1; k <= i; k++) {
				if (pre[k][j] != -1) pre[i][j] = max(pre[i][j], pre[k][j] + cnt[k][i]);
				pre[i][j] = max(pre[i][j], pre[k][max(0, j - cnt[k][i])]);
			}
		}
	}
	suf[N][0] = 0;
	for (int j = 1; j <= n; j++) {
		suf[N][j] = -1;
	}
	for (int i = N-1; i >= 1; i--) {
		for (int j = 0; j <= n; j++) {
			suf[i][j] = -1;
			for (int k = N; k >= i; k--) {
				if (suf[k][j] != -1) suf[i][j] = max(suf[i][j], suf[k][j] + cnt[i][k]);
				suf[i][j] = max(suf[i][j], suf[k][max(j - cnt[i][k], 0)]);
			}
		}
	}
	for (int l = 1; l <= N; l++) {
		for (int r = l; r <= N; r++) {
			tmp[l][r] = -1;
			for (int x = 0, y = n; x <= n; x++) {
				if (pre[l][x] == -1) break;
				while (y && (suf[r][y] == -1 || min(cnt[l][r] + x + y, pre[l][x] + suf[r][y]) <= min(cnt[l][r] + x + y - 1, pre[l][x] + suf[r][y-1]))) y--;
				tmp[l][r] = max(tmp[l][r], min(cnt[l][r] + x + y, pre[l][x] + suf[r][y]));
			}
		}
	}
	ans[0] = -1;
	for (int i = 0; i <= n; i++) {
		ans[0] = max(ans[0], min(i, pre[N][i]));
	}
	for (int i = 1; i <= n; i++) {
		ans[i] = -1;
		for (int l = s[i]; l >= 1; l--) {
			for (int r = t[i]; r <= N; r++) {
				ans[i] = max(ans[i], tmp[l][r]);
			}
		}
	}
	for (int i = 0; i <= n; i++) {
		printf("%d\n", ans[i]);
	}
	return 0;
}
```

---

## 作者：木xx木大 (赞：7)

[P1973 [NOI2011] NOI 嘉年华](https://www.luogu.com.cn/problem/P1973)

首先把时间离散化。考虑第一问，设 $f_{i,j}$ 表示前 $i$ 时间，若保证 A 会场有 $j$ 个活动，B 会场活动数的最大值。转移方程显然为 


$$
f_{i,j}=\max\limits_{k=0}^{i-1}\{\max (f_{k,j}+c_{k+1,i},f_{k,j-c_{k+1,i}})\}。
$$
其中 $c_{i,j}$ 表示 $[i,j]$ 时间内的活动数量，直接 $O(n^3)$ 预处理即可。

再考虑第二问。必须选第 $i$ 个活动，就是不能存在 $[l_i,r_i]$ 之间的转移。预处理出 $g_{i,j}$ 表示后 $i$ 时间，若保证 A 会场有 $j$ 个活动，B 会场活动数的最大值。钦定第 $i$ 个活动安排在 A 会场，则有
$$
ans=\max\limits_{i=0}^{l}\max\limits_{j=r}^{m}\max\limits_{x=0}^n\max\limits_{y=0}^n\min(x+y+c_{i,j},f_{i-1,x}+g_{j+1,y})
$$
单次 $O(n^4)$，总复杂度 $O(n^5)$ 。预处理出 $h_{i,j}=\max\limits_{x=0}^n\max\limits_{y=0}^n\min(x+y+c_{i,j},f_{i-1,x}+g_{j+1,y})$，则 $ans=\max\limits_{i=0}^{l}\max\limits_{j=r}^{m}h_{i,j}$。预处理复杂度 $O(n^4)$，总复杂度 $O(n^4)$。

暴力求 $h$：
```cpp
for(int i=1;i<=tot;i++)
	for(int j=i;j<=tot;j++)
		for(int x=0;x<=n&&f[i-1][x]>=0;x++)
			for(int y=0;y+x<=n&&g[j+1][y]>=0;y++)
				h[i][j]=max(h[i][j],min(x+y+c[i][j],f[i-1][x]+g[j+1][y]));
```
~~其实到这里就可以艹过本题了，别问我为啥8e8能过。~~

考虑优化求 $h_{i,j}$ 的复杂度。假设 $x+y+c_{i,j}\le f_{i-1,x}+g_{j+1,y}$（因为两个会场是等价的，所以这样做不影响正确性），则我们只需要尽量让 $f_{i-1,x}+g_{j+1,y}$ 大即可。发现 $f_{i,x}$ 是关于 $x$ 的非增函数，$g_{j,y}$ 是关于 $y$ 的非增函数，所以要想让和值大， $x$ 增大时 $y$ 必须减小。那么就不需要枚举 $y$ 了，单调地从大往小扫一遍即可。

一些实现时要注意的细节：

*  注意 $\min(x+y+c_{i,j},f_{i-1,x}+g_{j+1,y})$ 可能会有连续的一段函数值相同，所以减少 $y$ 的时候只要减少后不会变差就必须减少。 
* 如果有两场活动 $i,j$ 时间重合，$c$ 在计算时会同时算上它们两个，导致实际计算时会强制选上 $i,j$ 两场活动。所以我们需要给其中一场活动加上偏移量。

这题数据真是槽多无口。。。 $O(n^3)$ 没比 $O(n^4)$ 快多少不说，我有一次样例没过直接交居然 AC 了

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
namespace FGF
{
	int n,m;
	const int N=505,INF=0x3f3f3f3f;
	int a[N],tot,c[N][N],ans,l[N],r[N],f[N][N],g[N][N],h[N][N],vis[N][N];
	void work()
	{
		scanf("%d",&n);
		for(int i=1,s,t;i<=n;i++)
		{
			scanf("%d%d",&s,&t);
			a[++tot]=l[i]=s,a[++tot]=r[i]=s+t-1;
		} 
		sort(a+1,a+tot+1);
		for(int i=1;i<=n;i++)
		{
			l[i]=lower_bound(a+1,a+tot+1,l[i])-a,r[i]=lower_bound(a+1,a+tot+1,r[i])-a;
			if(vis[l[i]][r[i]])r[i]++;
			vis[l[i]][r[i]]=1;
		}
		for(int i=1;i<=tot;i++)
			for(int j=i;j<=tot;j++)
				for(int k=1;k<=n;k++)
					c[i][j]+=(l[k]>=i&&r[k]<=j);
		memset(f,-0x3f,sizeof(f)),memset(g,-0x3f,sizeof(g));;
		g[tot+1][0]=f[0][0]=0;
		for(int i=1;i<=tot;i++)
			for(int j=0;j<=n;j++)
				for(int k=0;k<i;k++)
					f[i][j]=max(f[i][j],max(f[k][j]+c[k+1][i],(j>=c[k+1][i]?f[k][j-c[k+1][i]]:-INF)));
		for(int i=0;i<=n;i++)
			ans=max(ans,min(i,f[tot][i]));
		printf("%d\n",ans);
		for(int i=tot;i;i--)
			for(int j=0;j<=n;j++)
				for(int k=i+1;k<=tot+1;k++)
					g[i][j]=max(g[i][j],max(g[k][j]+c[i][k-1],(j>=c[i][k-1]?g[k][j-c[i][k-1]]:-INF)));
		for(int i=1;i<=tot;i++)
			for(int j=i;j<=tot;j++)
				for(int x=0,y=tot;x<=n&&f[i-1][x]>=0;x++)
				{
					while(y&&min(f[i-1][x]+g[j+1][y],x+y+c[i][j])<=min(f[i-1][x]+g[j+1][y-1],x+y-1+c[i][j]))y--;
					h[i][j]=max(h[i][j],min(x+y+c[i][j],f[i-1][x]+g[j+1][y]));
				}				
		for(int x=1;x<=n;x++)
		{
			ans=0;
			for(int i=1;i<=l[x];i++)
				for(int j=r[x];j<=tot;j++)
					ans=max(ans,h[i][j]);
			printf("%d\n",ans);
		}
	}
}
int main()
{
	FGF::work();
	return 0;
}
```



---

## 作者：loveJY (赞：7)

貌似现有题解有些不能过hack,写了一份可过hack的题解....QAQ

# init:

首先预处理$tot_{l,r}$表示l,r时间段中的活动有哪些....

然后这个可以用$n^3$的时间预处理

接下来我们再预处理两个数组

$pre_{i,j}$表示1~i时间我们第一个选了x的前提下,第二个选了活动个数的最大值

然后怎么求呢?dp一下

$$pre_{i,j}=\max_{k<i}{pre_{k,j}+tot_{i,k},pre_{k,j-tot_{i,k}}}$$

你没看错,要么分给第一个会场要么分给第二个,$O(n^3)$

然后我们还能再处理出一个$suf_{i,j}$,就是后缀的选择

很易得出转移方程:

$$suf_{i,j}=\max_{k>i}{suf_{k,j}+tot_{j,k},suf_{k,j-tot_{i,k}}}$$

这样就做完预处理啦qwq

# 搞事情:

我们还要计算一个求解的数组$f_{l,r}$表示$[l,r]$区间的活动全部被一边选走,两边最优的最小值

然后我们还有枚举$s_i$之前和$t_i$之后有多少活动给了这一边,所以$x+y+sum_{l,r}$就是第一边选的个数!

而另一边呢?你会发现我们的pre和suf就有用了,可以开眼了!

$pre_{l,x}+suf_{r,y}$就是答案

两部分结合起来,转移方程就是

$$f_{l,r}=\max_{x}\max_{y}{x+y+tot_{l,r},pre_{l,x}+suf_{r,y}}$$

还没完.....答案并不是$f_{s_i,t_i}$

因为这个pre和suf只是局部最优,仅用他们并不能推出全局最优解,也就是说我们$f_{?,?}$才可能是全局最优解,而我们无法知道这个?

解决方法也很简单$\max_{i<=l}\max_{j>=r}$一定是答案,因为我们虽然每个状态并不一定是全局最优解,但最优解一定在这个数组中

这样我们就可以$O(n^4)$求解f然后TLE了!

用脑袋仔细想想,pre数组随着第二维的增大,他的值只有可能变小,没有说我第一个会场活动多第二个会场跟着变多的道理

也就是说,随着x的增大,y如果随着增大, min前面那个只能越来越大,后面那个越来越小

所以对于x增加我们的y只能从大到小的变换....

然后x一增大y变小挨着找最优决策点就做完了....因为一定min在取到后面那个数之后一定不会再取回之前了.....只会越来越劣

这样决策单调性优化我们就可以$O(n^3)$了...

# 过hack

但是还有一个问题,由于tot是记录了所有完全包含的,所以会导致如果有两个完全相同的区间,我们tot会钦点他强制都选上,我们的f数组步长为1就会更新出错,而且这个hack在讨论区也给出了

要么更改求f数组的过程,要么使得没有两个相同区间,由于这样其实本质上我们只是缺少了只选择其中**几个相同区间**的决策,所以我们最后把相同的区间右端点向内扰动一下就好了

code:

```cpp

#include<bits/stdc++.h>
#define db double
using namespace std;
#define mkp(x,y) (make_pair(x,y))
const int MAXN = 500;
map<pair<db, db>, int> mp;
vector<db> v;
int n, m;
struct rec {
	db s, t;
	bool operator<(const rec &x)const {
		return s + t < x.s + x.t;
	}
} a[MAXN];
int pre[MAXN][MAXN], suf[MAXN][MAXN], f[MAXN][MAXN], tot[MAXN][MAXN];
int s[MAXN], t[MAXN]; //强卡区间重复....

inline int getid(db x) {
	return lower_bound(v.begin(), v.end(), x) - v.begin() + 1;
}

inline void init() {
	sort(v.begin(), v.end());
	v.erase(unique(v.begin(), v.end()), v.end());
	for(int i = 1; i <= n; ++i) {
		s[i] = getid(a[i].s);
		t[i] = getid(a[i].t);
		// printf("activity %d st in : %d ed in :%d \n", i, s[i], t[i]);
	}
	m = v.size();
	return;
}

inline void init2() {
	for(int i = 1; i <= m; ++i) {
		for(int j = 1; j <= n; ++j) {
			pre[i][j] = suf[i][j] = -0x3f3f3f3f;
		}
	}
	for(int i = 1; i <= m; ++i) {
		for(int j = 0; j <= n; ++j) {
			for(int k = 1; k < i; ++k) {
				pre[i][j] = max(pre[i][j], tot[k][i] + pre[k][j]);
				if(j >= tot[k][i]) {
					pre[i][j] = max(pre[i][j], pre[k][j - tot[k][i]]);
				}
			}
			// printf("pre:!%d %d %d?\n", i, j, pre[i][j]);
		}
	}
	for(int i = m; i >= 1; --i) {
		for(int j = 0; j <= n; ++j) {
			for(int k = i + 1; k <= m; ++k) {
				suf[i][j] = max(suf[i][j], tot[i][k] + suf[k][j]);
				if(j >= tot[i][k]) {
					suf[i][j] = max(suf[i][j], suf[k][j - tot[i][k]]);
				}
			}
			// printf("suf:!%d %d %d?\n", i, j, suf[i][j]);
		}
	}
	return ;
}

int main() {
	scanf("%d", &n);
	for(int i = 1; i <= n; ++i) {
		scanf("%lf%lf", &a[i].s, &a[i].t);
		a[i].t = a[i].s + a[i].t;
		if(mp.find(mkp(a[i].s, a[i].t)) != mp.end())
			a[i].t = a[i].t - mp[mkp(a[i].s, a[i].t)] * 0.001;
		mp[mkp(a[i].s, a[i].t)]++;
		v.push_back(a[i].s);
		v.push_back(a[i].t);
	}
	init();
	for(int i = 1; i <= m; ++i) {
		for(int j = i + 1; j <= m; ++j) {
			for(int k = 1; k <= n; ++k) {
				if(s[k] >= i && t[k] <= j)
					tot[i][j]++;
			}
			// printf("%d %d %d\n", i, j, tot[i][j]);
		}
	}
	init2();
	for(int i = 1; i <= m; ++i) {
		for(int j = i + 1; j <= m; ++j) {
			int p0, p1;
			for(int y = n, x = 0; x <= n; ++x) {
				p0 = min(x + y + tot[i][j], pre[i][x] + suf[j][y]);
				while(y && p0 <= (p1 = min(x + y - 1 + tot[i][j], pre[i][x] + suf[j][y - 1])))
					p0 = p1, --y;
				f[i][j] = max(f[i][j], min(x + y + tot[i][j], pre[i][x] + suf[j][y]));
			}
		}
	}
	int ans = 0;
	for(int j = 1; j <= n; ++j) {
		ans = max(ans, min(pre[m][j], j));
		// printf("?%d?%d?\n", j, pre[m][j]);
	}
	printf("%d\n", ans);
	for(int i = 1; i <= n; ++i) {
		ans = 0;
		for(int j = 1; j <= s[i]; ++j) {
			for(int k = t[i]; k <= m; ++k) {
				ans = max(ans, f[j][k]);
			}
		}
		printf("%d\n", ans);
	}
	return 0;
}



```


---

## 作者：花样百出 (赞：6)

题解:

我们设计状态方程如下:

num[i][j]表示从时间i到j中有多少个

pre[i][j]表示时间1~i中,A选了j个时的B能选的数量的最大值.

nex[i][j]表示时间i~cnt中,A选了j个时的B能选的数量的最大值.

mus[i][j]表示从时间i到j的保证选时,A和B选的数量中的较小值的最大值.

①对于num数组直接可以暴力求,没问题.

②对于pre和nex数组在这里就只讲pre的转移,nex的转移类似.

pre[i][j]=max(pre[i-1][j],pre[k][j]+num[k][i],pre[k][j-num[k][i]]);(1<=k<i)

就是分成不管i时间,或者从时间k到i的都由B选,或者从时间k到i的都由A选三种情况

③对于mus数组,我们得到转移方程mus[i][j]=max(x+y,pre[i][x]+num[i][j]+nex[j][y]),x表示时间1~i中A选x个,y表示时间j~cnt中A选y个,中间num[i][j]个由B选.这样暴力转移的话是O(n^4)的,时间上是不允许的,那么我们观察转移方程,当x增大时,y只有单调递减答案才会更优,因为如果x增大且y也增大的话,表示A选的越来越多,B选的越来越少,显然答案不会更优的,所以我们维护一个y的单调递减的指针来转移就可以了,时间为O(n^3).

④对于第一问的答案就是max(min(pre[i][j],j)),枚举时间i和A选的个数j来得到最优解.

然后对于第二问我们对于一个活动l~r,答案为max(mus[i][j]),1<=i<=l,r<=j<=cnt.

```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<queue>
#include<vector>
#include<stack>
#define min(a,b) ((a)<(b)?(a):(b))
#define max(a,b) ((a)>(b)?(a):(b))
#define MAXN 10100
#define RG register
#define LL long long int
using namespace std;
const int INF=1e9;
struct node{
  int l,r;int id;
}t[1010];
int n;
int num[1010][1010];//从时间i到j中有多少个
int pre[1010][1010];//时间1~i中,A选了j个时的B能选的数量的最大值.
int nex[1010][1010];//时间i~n中,A选了j个时的B能选的数量的最大值.
int mus[1010][1010];//从时间i到j的保证选时,A和B选的数量中的较小值的最大值.
int st[MAXN],cnt;
int ans[MAXN];
int main()
{
  freopen("1.in","r",stdin);
  scanf("%d",&n);
   for(int i=1;i<=n;i++){
    scanf("%d%d",&t[i].l,&t[i].r);t[i].r+=t[i].l;t[i].id=i;
    st[++cnt]=t[i].l;st[++cnt]=t[i].r;
  }
  sort(st+1,st+cnt+1);cnt=unique(st+1,st+cnt+1)-st-1;
  for(int i=1;i<=n;i++){
    t[i].l=lower_bound(st+1,st+cnt+1,t[i].l)-st;
    t[i].r=lower_bound(st+1,st+cnt+1,t[i].r)-st;
    }
  for(int i=1;i<=cnt;i++)
    for(int j=1;j<=t[i].l;j++)
      for(int k=t[i].r;k<=cnt;k++)
    num[j][k]++;
  for(int i=1;i<=cnt;i++)
    for(int j=1;j<=n;j++)
      pre[i][j]=nex[i][j]=-INF;
  pre[0][0]=nex[cnt+1][0]=0;
  for(int i=1;i<=cnt;i++){
    for(int j=0;j<=num[1][i];j++)
      pre[i][j]=max(pre[i-1][j],pre[i][j]);
    for(int j=0;j<=num[1][i];j++){
      for(int k=1;k<i;k++){
    pre[i][j]=max(pre[k][j]+num[k][i],pre[i][j]);
    if(j>=num[k][i]) pre[i][j]=max(pre[k][j-num[k][i]],pre[i][j]);
      }
    }
  }
  for(int i=cnt;i>=1;i--){
    for(int j=0;j<=num[i][cnt];j++)
      nex[i][j]=max(nex[i+1][j],nex[i][j]);
    for(int j=0;j<=num[i][cnt];j++){
      for(int k=cnt;k>i;k--){
    nex[i][j]=max(nex[k][j]+num[i][k],nex[i][j]);
    if(j>=num[i][k]) nex[i][j]=max(nex[k][j-num[i][k]],nex[i][j]);
      }
    }
  }
  for(int i=1;i<=cnt;i++)
    for(int j=i+1;j<=cnt;j++)
      {
    for(int x=0,y=n;x<=n;x++){
      while(y){
        int val1=min(x+y,pre[i][x]+num[i][j]+nex[j][y]);
        int val2=min(x+y-1,pre[i][x]+num[i][j]+nex[j][y-1]);
        if(val2>=val1) y--;else break;
      }
      mus[i][j]=max(mus[i][j],min(x+y,pre[i][x]+num[i][j]+nex[j][y]));
    }
      }
  for(int i=1;i<=cnt;i++)
    for(int j=0;j<=num[1][i];j++)
      ans[0]=max(ans[0],min(pre[i][j],j));
  for(int i=1;i<=n;i++)
      for(int j=t[i].l;j>=1;j--)
    for(int k=t[i].r;k<=cnt;k++)
      ans[i]=max(ans[i],mus[j][k]);
  for(int i=0;i<=n;i++) printf("%d\n",ans[i]);
  return 0;
}

```

---

## 作者：Sakura_Magician (赞：3)

**C++做法**
先膜拜大佬们的做法
然后再跪拜一下管理员
最后讲做法

------------
~~哈哈哈哈~~
此题解来自：[[BZOJ 2436][NOI 2011]NOI嘉年华(DP优化)](https://blog.csdn.net/qpswwww/article/details/45251877)
~~真的骄傲，一个连区赛都进不了的小人儿弄懂了这个~~
###### 离散化
这是此题的终极做法
~~哈哈哈哈~~

-----------
离散化后，就是求三个数组num[i][j],pre[i][j],suf[i][j]
see：！！
num[i][j]=[i,j]区间内的线段个数.
pre[i][j]=[0,i]区间内给B j个线段，A得到最多线段个数。
suf[i][j]=[j,∞]区间内给B j个线段，A得到最多线段个数.

------------
先推出num[i][j]，枚举i，对于所有左端点Li大于等于i的区间右端点Ri，标记 num[i][Ri]++;
那么：num[i][j]=num'[i][k](上限j，下限:k=i)

------------
接着是然后就是pre[i][j]和suf[i][j]了
请求出以下公式（在下方）：
pre[i][j]=max(max(pre[k][j]+num[k][i],pre[k][j]−num[k][i]));
AND
suf和pre差不多

------------
g[i][j]=max（min(x+y,pre[i][x]+num[i][j]+suf[j][y]))\
(x,y∈[0,n])
这就令
f[x][y]=min{x+y,pre[i][x]+num[i][j]+suf[j][y]}
~~但我没看见代码里有f数组啊！！！~~
（注：x是[i,j]左边放入B中的线段个数，y是[i,j]右边放入B中的线段个数）

------------
总结：
在x固定的情况下，f[x][y]随y递增,呈单凸特点，因此可以利用这一性质，维护两个指针x,y，遍历x，对于每个x，可以在期望复杂度O(1))时间内，移动指针y并快速找到使得当前的f[x][y]最大的y

------------
~~重要环节！！！！！！！代码呈现！！！！！！~~
代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#define INF 0x3f3f3f3f
using namespace std;
struct Segment
{
    long long L,R;
}seg[2020];
long long stack[6666],top=0,n,pre[2222][2222],suf[2222][2222],g[2222][2222],num[2222][2222],i,k,j,x,y,ans;
int main()
{
    scanf("%lld",&n);
    for(i=1;i<=n;i++){
        scanf("%lld%lld",&seg[i].L,&seg[i].R);
        seg[i].R+=seg[i].L;
        stack[top++]=seg[i].L;
        stack[top++]=seg[i].R;
    }
    sort(stack,stack+top);
    top=unique(stack,stack+top)-stack;
    for(i=1;i<=n;i++)
        seg[i].L=lower_bound(stack,stack+top,seg[i].L)-stack,seg[i].R=lower_bound(stack,stack+top,seg[i].R)-stack;
    for(i=0;i<top;i++){
        for(j=1;j<=n;j++)
            if(seg[j].L>=i)
                num[i][seg[j].R]++;
        for(j=i+1;j<top;j++)
            num[i][j]+=num[i][j-1];
    }
    memset(pre,~INF,sizeof(pre));
    memset(suf,~INF,sizeof(suf));
    pre[0][0]=0;
    suf[top-1][0]=0;
    for(i=0;i<top;i++){
        for(j=0;j<=n;j++)
            if(pre[i][j]>~INF)
                pre[i][pre[i][j]]=max(pre[i][pre[i][j]],j);
        for(j=n-1;j>=0;j--)
            pre[i][j]=max(pre[i][j],pre[i][j+1]);
        for(j=0;j<=n;j++)
            for(k=i+1;k<top;k++)
                if(pre[i][j]>~INF)
                    pre[k][pre[i][j]]=max(pre[k][pre[i][j]],j+num[i][k]);
    }
    for(i=top-1;i>=0;i--{
        for(j=0;j<=n;j++)
            if(suf[i][j]>~INF)
                suf[i][suf[i][j]]=max(suf[i][suf[i][j]],j);
        for(j=n-1;j>=0;j--)
            suf[i][j]=max(suf[i][j],suf[i][j+1]);
        for(j=0;j<=n;j++)
            for(k=i-1;k>=0;k--)
                if(suf[i][j]>~INF)
                    suf[k][suf[i][j]]=max(suf[k][suf[i][j]],j+num[k][i]);
    }
    for(i=0;i<top;i++)
        for(j=i;j<top;j++){
            g[i][j]=~INF;
            for(x=0,y=n;x<=n;x++){
                while(y>=0&&x+y>num[i][j]+pre[i][x]+suf[j][y])y--;
                if(y>=0)g[i][j]=max(g[i][j],x+y);
            }
        }
    for(i=0;i<=n;i++)
        ans=max(ans,min(i,suf[0][i]));
    printf("%lld\n",ans);
    for(i=1;i<=n;i++){
        ans=0;
        for(int j=0;j<=seg[i].L;j++)
            for(int k=seg[i].R;k<top;k++)
                ans=max(ans,g[j][k]);
        printf("%lld\n",ans);
    }
    return 0;
}
```

------------
最后
我再次膜拜管理员和在我之前出题解的大佬们，大佬们也给了我很多启发，谢谢大佬们
七个字：管理员和大佬强！！！！！！！！

---

## 作者：KokiNiwa (赞：2)

# [NOI2011] NOI嘉年华

这是一道`dp`题，并且没有用什么高级知识

## 题目叙述

有$n$个活动，每个活动有一个时间范围$[l,r]$。两个问题：

+ 把这些活动分成两部分，使得在两个不同部分的活动不能有公共时间，问这两部分中活动较少的最多多少个活动。
+ 在第一问的基础上，强制选第$i$个活动，较少的最多多少（对于任意$i$，都要求）。

## 题解

这是一个分成两个部分的问题，因此可以考虑把一部分设到状态里，另一部分作为状态的值。有一个类似的题，[P2577 [ZJOI2005]午餐](https://www.luogu.com.cn/problem/P2577)。

设$pre_{i,j}$为前$i$个时间点，第一场有$j$个活动，第二场最多选多少个。

考虑枚举选不选第$k$个活动转移。然后发现并不行。

考虑枚举上一个时间点是$k$，把完整在$[k,i]$时间内的所有活动都选上。所以要统计$tot_{l,r}$表示区间$[l,r]$内所有项目都选上能选几个。

第一问就解决了。

第二问，对于每一个活动，相当于$[l,r]$内不能选任何其他活动。

于是设$f_{l,r}$表示时间区间$[l,r]$内所有活动都选上的最优解。

考虑把前缀和后缀还有$[l,r]$拼起来当成答案。前缀和后缀搞成局部最优解，所以还要统计一个$suf$表示从$i$向后选$j$个活动的局部最优解。

这只是局部最优解，还要把其他情况算上（比如一个区间有一部分在$[l,r]$里面），所以对于每个询问都需要枚举所有包含$[l,r]$的所有区间，所以每个$f_{l,r}$都需要算出来。

考虑如何计算：枚举两边的数量，$cnt_l,cnt_r$，然后显然是$cnt_l+cnt_r+tot_{l,r}$与$pre_{l,cnt_l}+suf_{r,cnt_r}$中的最小值。

但是发现这样计算$f_{l,r}$的复杂度是$n^4$的。

现在考虑$l$固定时，$r$的最优解的行动轨迹。我们知道，$pre_{l,cnt_l}$和$suf_{r,cnt_r}$在$cnt_l$和$cnt_r$下降时，这两个数也下降。因为可以感受到，$pre_{l,cnt_l}$在$cnt_l$更小的时候，另一个场的限制小，所以自然最多多少个就大。

在考虑在$cnt_l$不断增大的时候，$cnt_l+cnt_r+tot_{l,r}$会减小。最优状态一定是一个平衡状态（就是$\min$的两边基本相同的时候）。对于一个原本相同的状态，$cnt_l$在枚举时会变大，$cnt_r$如果也变大，那么$pre_{l,cnt_l}+suf_{r,cnt_r}$会变小，而左边比原本的一个平衡状态更大，那么定然不平衡了。

于是这就可以维护一个$r$的指针，然后每次移动就可以保证复杂度$O(n^3)$了。

计算完$f_{l,r}$后再枚举就可以得到答案啦。

## 代码

注意：

+ 决策单调性移动指针的时候一定写$\le$而不是$<$！因为有一段时平着的。

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int maxActive = 205, maxTime = 405;
int nb, tail, ans, pre[maxTime][maxActive], suf[maxTime][maxActive], diff[maxTime], tot[maxTime][maxTime];
int reg[maxTime][maxTime];
struct Activity {
	int beg, end;
} act[maxActive];
int Find(int val) {
	return lower_bound(diff + 1, diff + tail + 1, val) - diff;
}
int main() {
	scanf("%d", &nb);
	for (int at = 1; at <= nb; ++at) {
		int beg, len;
		scanf("%d%d", &beg, &len);
		act[at].beg = beg;
		act[at].end = beg + len;
		diff[++tail] = beg;
		diff[++tail] = beg + len;
	}
	sort(diff + 1, diff + tail + 1);
	tail = unique(diff + 1, diff + tail + 1) - (diff + 1);
	for (int at = 1; at <= nb; ++at) {
		act[at].beg = Find(act[at].beg);
		act[at].end = Find(act[at].end);
	}
	for (int L = 1; L <= tail; ++L)
		for (int R = L; R <= tail; ++R)
			for (int at = 1; at <= nb; ++at)
				tot[L][R] += ((L <= act[at].beg) && (act[at].end <= R));
	memset(pre, 0x8f, sizeof(pre));
	memset(suf, 0x8f, sizeof(suf));
	//不合法状态要设成 -inf 
	pre[0][0] = suf[0][0] = 0;
	for (int tim = 1; tim <= tail; ++tim) {
		pre[tim][0] = 0;
		for (int ge = 0; ge <= tot[1][tim]; ++ge)
			for (int from = 0; from < tim; ++from) {
				pre[tim][ge] = max(pre[tim][ge], pre[from][ge] + tot[from][tim]);
				if (ge >= tot[from][tim])
					pre[tim][ge] = max(pre[tim][ge], pre[from][ge - tot[from][tim]]);
			}
	}
	//这里时间点重复是不算重复的 
	for (int ge = 1; ge <= nb; ++ge)
		ans = max(ans, min(pre[tail][ge], ge));
	printf("%d\n", ans);
	for (int tim = tail; tim >= 1; --tim) {
		suf[tim][0] = 0;
		for (int ge = 0; ge <= tot[tim][tail]; ++ge)
			for (int from = tim + 1; from <= tail; ++from) {
				suf[tim][ge] = max(suf[tim][ge], suf[from][ge] + tot[tim][from]);
				if (ge >= tot[tim][from])
					suf[tim][ge] = max(suf[tim][ge], suf[from][ge - tot[tim][from]]);
			}
	}
	for (int bg = 1; bg <= tail; ++bg)
		for (int ed = bg + 1; ed <= tail; ++ed)
			for (int L = 0, R = tot[ed][tail]; L <= tot[1][bg]; ++L) {
				int nowVal = min(L + R + tot[bg][ed], pre[bg][L] + suf[ed][R]);
				//加上决策单调性之后应该是 nowVal <= min(......) 
				while (R >= 1 && nowVal <= min(L + (R - 1) + tot[bg][ed], pre[bg][L] + suf[ed][R - 1]))
					--R, nowVal = min(L + R + tot[bg][ed], pre[bg][L] + suf[ed][R]);
				reg[bg][ed] = max(reg[bg][ed], nowVal);
				//这也得取 max，因为这里并不是直接算出这个点的最优位置的
				//这里是一个...可以类似于剪枝之类的东西 
			}
	for (int ac = 1; ac <= nb; ++ac) {
		int ans = 0;
		for (int bg = 1; bg <= act[ac].beg; ++bg)
			for (int ed = act[ac].end; ed <= tail; ++ed)
				ans = max(ans, reg[bg][ed]);
		printf("%d\n", ans);
	}
	return 0;
}
```

## 想法

+ 两部分的题目可以考虑设一维是第一部分，值是第二部分的最优解。

---

## 作者：OIer_ACMer (赞：1)

~~早年 NOI 的题是真水呀！~~

------------
注意：

1. 本题由于涉及到的知识点比较单一，笔者的讲述可能不会那么全面，一些证明和解释可能不会出现在题解中，望周知！

2. 我给那些想要最优解的同学们提个醒：笔者的思路**偏向于从题目中发现规律，并不是很巧妙的方法**，时间复杂度会很高，如果你是抱着学知识的态度来读我这篇题解，倒是可以，但如果你想最优解，我建议你还是去看看别的大佬的题解，因为我太蒟蒻了~~唉~~。

------------
## 大致思路：
本题是一道练习单调队列优化的好题，我建议大家可以先思考再来看我这篇题解。

首先，我们观察到 $n \le 200$，但是经过题目要求中的各个时间段的“润色”时间复杂度可就不止这么点了，那么怎么办呢？我们先用最简朴的办法——离散化，这样一来**遍历一整个数组的**（不是全部）时间复杂度就全是 $O(n)$ 了，我们就可以大展拳脚地来~~被这道题切~~切这道题了！

首先，由于询问的次数 $T \le 10^9$，这个次数我们是不能接受的，所以我们就先定义一个数组 $sum$，设 $sum[i][j]$ 是表示 $i$ 到 $j$ 时间有多少个活动。同时，我们还要在 $sum$ 数组的基础上设计一个做多能安排多少场次的**辅助数组**（注意，**不是正式的 DP 数组**）：设 $f[i][j]$ 表示到第 $i$ 时间为止，第一个场地已经举办了 $j$ 场活动时第二个场地最多举办多少场活动。根据以上这些信息，我们就很容易写出预处理公式：

$f[i][j] = \max(f[i-1][j],f[k][j]+sum[k+1][i],f[k][j-sum[k+1][i]])$。

这个方程分别表示 $sum[k+1][i]$ 这一段的活动不演出、在第二个场地演出、在第一个场地演出。再用同样的方法求 $g[i][j]$ 表示倒序时间到 $i$ 时，第一个场地举办了 $j$ 个活动时第二个场地最多举办多少个活动。

接着，预处理做完了，我们就要开始 DP 了。首先我们要设计状态：我们设 $dp[i][j]$ 表示 $i$ 到 $j$ 这一段所有的活动同时选到某一个场地的最大答案。那么，我们很容易就可以推出转移方程：

$dp[i][j] = \max(dp[i][j], \min(\max(f[i-1][x] + g[j + 1][y], x + y), \min(f[i - 1][x] + g[j+1][y], x + y) + sum[i][j])$，意思是把 $sum[i][j]$，这段区间内的所有活动，给一二场地中较小的一个场地，再更新答案~~是不是很简单~~。

然而，我从开头就说了：$t \le 10^9$，这个时间复杂度不容小觑，加上如果直接这样暴力就会产生 $O(n^4)$ 的时间复杂度，但是，我们冷静地思考一下，**由于随着 $x$ 的增加，$y$ 的值时单调不递减的**（说白了你的开始时间增加结束时间最小也得是开始时间，不可能时光倒流），所以综合来看，整体时间复杂度只有 $O(n^3)$（具体证明笔者在这里不多赘述，请同学们自行下去思考）。

------------
## 代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
inline int read()
{
    register int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
const int N = 1001;
int n, m, x[N], b[N], pos[N], l[N], r[N], cnt, inf;
int f[N][N], sum[N][N], g[N][N], dp[N][N], ans1[N];
struct dat
{
    int x, pd, num, k;
} a[N];
int cmp(dat x, dat y)
{
    return x.x < y.x;
}
void solve()
{
    for (int i = 1; i <= cnt; i++)
    {
        for (int j = i; j <= cnt; j++)
        {
            for (int k = 1; k <= n; k++)
            {
                if (l[k] >= i && r[k] <= j)
                {
                    sum[i][j]++;
                }
            }
        }
    }
}
void calc_f()
{
    memset(f, 128, sizeof(f));
    f[0][0] = 0;
    for (int i = 1; i <= cnt; i++)
    {
        for (int j = 0; j <= n; j++)
        {
            f[i][j] = f[i - 1][j];
            for (int k = 0; k <= i - 1; k++)
            {
                f[i][j] = max(f[i][j], f[k][j] + sum[k + 1][i]);
                if (j - sum[k + 1][i] >= 0)
                {
                    f[i][j] = max(f[i][j], f[k][j - sum[k + 1][i]]);
                }
            }
        }
    }
}
void calc_g()
{
    memset(g, 128, sizeof(g));
    inf = g[0][0];
    g[cnt + 1][0] = 0;
    for (int i = cnt; i >= 1; i--)
    {
        for (int j = 0; j <= n; j++)
        {
            g[i][j] = g[i + 1][j];
            for (int k = cnt + 1; k > i; k--)
            {
                g[i][j] = max(g[i][j], g[k][j] + sum[i][k - 1]);
                if (j - sum[i][k - 1] >= 0)
                {
                    g[i][j] = max(g[i][j], g[k][j - sum[i][k - 1]]);
                }
            }
        }
    }
}
int calc(int i, int j, int x, int y)
{
    if (f[i - 1][x] < 0 || g[j + 1][y] < 0)
    {
        return inf;
    }
    int t = max(x + y, f[i - 1][x] + g[j + 1][y]);
    int t1 = min(x + y, f[i - 1][x] + g[j + 1][y]);
    return min(t, t1 + sum[i][j]);
}
int main()
{
    n = read();
    int size = 0;
    for (int i = 1; i <= n; i++)
    {
        int s, t;
        s = read();
        t = read();
        ++size;
        a[size].pd = 1;
        a[size].x = s;
        a[size].num = i;
        ++size;
        a[size].pd = 0;
        a[size].x = s + t - 1;
        a[size].num = i;
    }
    sort(a + 1, a + 2 * n + 1, cmp);
    cnt = 0;
    a[0].x = -1;
    for (int i = 1; i <= 2 * n; i++)
    {
        if (a[i].x != a[i - 1].x)
        {
            cnt++, a[i].k = cnt;
        }
        else
        {
            a[i].k = cnt;
        }
    }
    for (int i = 1; i <= 2 * n; i++)
    {
        if (a[i].pd)
        {
            l[a[i].num] = a[i].k;
        }
        else
        {
            r[a[i].num] = a[i].k;
        }
    }
    solve();
    calc_f();
    calc_g();
    for (int i = 1; i <= cnt; i++)
    {
        for (int j = i; j <= cnt; j++)
        {
            if (sum[i][j])
            {
                int y = n, t;
                for (int x = 0; x <= n; x++)
                {
                    int now = calc(i, j, x, y);
                    while (y)
                    {
                        int nxt = calc(i, j, x, y - 1);
                        if (now <= nxt)
                        {
                            now = nxt, y--;
                        }
                        else
                        {
                            break;
                        }
                    }
                    dp[i][j] = max(dp[i][j], now);
                }
            }
        }
    }
    int ans = 0;
    for (int i = 1; i <= n; i++)
    {
        ans = max(ans, min(g[1][i], i));
    }
    // cout << "ans=" << ans << endl;
    for (int k = 1; k <= n; k++)
    {
        for (int i = 1; i <= cnt; i++)
        {
            for (int j = i; j <= cnt; j++)
            {
                if (l[k] >= i && r[k] <= j)
                {
                    ans1[k] = max(ans1[k], dp[i][j]);
                }
            }
        }
    }
    cout << ans << endl;
    for (int i = 1; i <= n; i++)
    {
        cout << ans1[i] << endl;
    }
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/122465821)

---

## 作者：_LHF_ (赞：1)

一道比较普通的dp题。

这里给出一种 $O(n^3\log n)$（但是能过）的方法。

考虑最普通的 dp，先把时间离散化，离散化的时候有一个小细节：将区间 $[l,r]$ 转化成区间 $[l,r+1)$ 效果更佳，设 $c_{l,r}$ 表示包含在 $[l,r]$ 区间内的活动数，设 $f_{i,j}$ 表示到第 $i$ 个时间点，$1$ 号活动场举办了 $j$ 场活动，那么 $2$ 号活动场最多能举办多少活动。

转移：$f_{i,j}=max(f_{k,j}+c_{k,i}),f_{i,j}=max(f_{k,j-c_{k,i}})$

记得记录一下每个位置是否存在即可。

恭喜你拿到了 $40$ 分。

对于 $100$ 分的做法，显然是要维护一个前缀，一个后缀，设前缀数组为 $f$，后缀为 $g$，设 $s_{i,j}$ 表示 $[i,j]$ 区间内的活动都必须举办的方案，那么可以直接算出答案。

现在的问题是如何计算 $s_{i,j}$。

枚举 $i,j$，
$$s_{i,j}=\max_{x,y}(min(x+y+c_{i,j},f_{i,x}+g_{j,y}))$$
但因为我太菜，不会什么线性的做法。

设 $h_k=\max(f_{i,x}+g_{j,y})(x+y=k)$，那么不难得到 $h_k$ 是单调递减的。

枚举 $t=x+y$，变成了 $s_{i,j}=\max(min(t+c_{i,j},h_t))$。

直接算出所有的 $h_t$ 显然开销有点大，不过我们可以用 $O(n)$ 的时间算出一个 $h_t$

显然，一个单增函数和一个单间函数取 $\min$ 之后的最大值是两函数的交点，二分一下即可。

再推荐一道类似的题目：[[省选联考 2020 A/B 卷] 冰火战士](https://www.luogu.com.cn/problem/P6619)。

时间复杂度： $O(n^3\log n)$。

代码：
```cpp
#include<cstdio>
#include<algorithm>
#define N 410
#define mid ((l+r)>>1)
using namespace std;
int n,a,l[N],r[N],x[N],len,ans[N],ss[N][N];
int dp[N][N],c[N][N],p[N][N],dp2[N][N],p2[N][N];
int calc(int a,int b,int x)
{
	int s=0;
	for(int i=0;i<=x;i++)
		if(i<=c[1][a]&&x-i<=c[b][len])
			s=max(s,dp[a][i]+dp2[b][x-i]);
	return s;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&l[i],&r[i]);r[i]+=l[i];
		x[++len]=l[i],x[++len]=r[i];
	}
	sort(x+1,x+len+1);
	len=unique(x+1,x+len+1)-x-1;
	for(int i=1;i<=n;i++)
	{
		l[i]=lower_bound(x+1,x+len+1,l[i])-x;
		r[i]=lower_bound(x+1,x+len+1,r[i])-x;
	}
	for(int i=1;i<len;i++)
		for(int j=i+1;j<=len;j++)
			for(int k=1;k<=n;k++)
				if(l[k]>=i&&r[k]<=j) c[i][j]++;
	p[1][0]=1;
	for(int i=2;i<=len;i++)
		for(int j=0;j<=n;j++)
			for(int k=1;k<i;k++)
			{
				a=c[k][i];
				if(p[k][j]) dp[i][j]=max(dp[i][j],dp[k][j]+a),p[i][j]=1;
				if(j>=a&&p[k][j-a]) dp[i][j]=max(dp[i][j],dp[k][j-a]),p[i][j]=1;
			}
	p2[len][0]=1;
	for(int i=len-1;i;i--)
		for(int j=0;j<=n;j++)
			for(int k=i+1;k<=len;k++)
			{
				a=c[i][k];
				if(p2[k][j]) dp2[i][j]=max(dp2[i][j],dp2[k][j]+a),p2[i][j]=1;
				if(j>=a&&p2[k][j-a]) dp2[i][j]=max(dp2[i][j],dp2[k][j-a]),p2[i][j]=1;
			}
	for(int i=1;i<=n;i++) ans[0]=max(ans[0],min(i,dp[len][i]));
	for(int i=1;i<len;i++)
		for(int j=i+1;j<=len;j++)
		{
			int l=0,r=n-c[i][j];
			while(l<r)
				if(calc(i,j,mid)>mid+c[i][j]) l=mid+1;
				else r=mid;
			ss[i][j]=min(l+c[i][j],calc(i,j,l));
		}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=l[i];j++)
		{
			for(int k=r[i];k<=len;k++)
				ans[i]=max(ans[i],ss[j][k]);
		}
	}
	for(int i=0;i<=n;i++) printf("%d\n",ans[i]);
}
```

---

## 作者：Piwry (赞：1)

## 解析

时间范围很大，但 $n$ 很小，可以直接离散化。设离散化后的时间范围 $(0, T)$

首先要想到一次直接选一个**区间**内的活动转移，而不是一个个活动地转移；否则在状态数会过高导致不好优化，且转移方程也很不可想

设 $w(l, r)$ 表示活动举办时间段完全在**区间** $[l, r]$ 内的活动数

设状态 $f(k, r)$ 表示第一个场地举办 $k$ 个活动，在 $r$ 时刻第一个场地的所有活动结束，第二个场地举办的活动数的最大值；再设状态 $g(k, l)$ 表示第一个场地举办 $k$ 个活动，最早在 $l$ 时刻第一个场地有活动开始，第二个场地举办的活动数的最大值（其实 $f$ 和 $g$ 差不多就是前后缀的关系）

（这里并不需要再同样为第二个场地设两个状态，因为两个场地并无区分，不管给哪个场地设状态算出来的都是一样的）

转移只需按区间转移，枚举最后一段区间的活动给哪个场地即可。可以得到转移方程：$f(k, r)=\max\limits_{0\leq r' < r}\{f(k-w(r', r), r'), f(k, r')+w(r', r)\}$，$g(k, l)=\max\limits_{l < l' \leq T}\{g(k-w(l, l'), l'), g(k, l')+w(l, l')\}$

同时转移时还要求合法。以 $f$ 为例，$f(k-w(r', r), r'$ 要求 $k\geq w(r', r)$；$f(k, r')+w(r', r)$ 要求 $k\leq w(0, r')$（如果设了缺省值，这个不判也行）

这样第一问就做完了

&nbsp;

现在再考虑第二问

如果要求第 $i$ 个活动必选，设该活动的开始时间为 $l_i$，结束时间为 $r_i$。我们只需强制选 $[l_i. r_i]$ 中的所有区间，然后再分别再把 $[0, l_i]$ 和 $[r_i, T]$ 单独拎出来做一次和刚才意义一样的 dp 即可，可以直接套用上面预处理的 $f, g$

但注意到，假设我们对一个场地选了一个 $[a, l_i], 0\leq a\leq l_i$ 的活动，再有一个 $[b, c], a\leq b\leq r_i, b\leq c\leq r_i$ 的活动，即使这样，$[b, c]$ 这个活动也不会被选。或者说，由于我们设置的 “断点”（$l_i, r_i$），一些跨断点的活动，即使合法，也不会被选；于是我们只好枚举断点

于是最终得到方程：$ans[i]=\max\limits_{0\leq l\leq l_i, r_i\leq r\leq T}\{\max\limits_{0\leq j\leq n, 0\leq k\leq n}\{\min(j+k+w(l, r), f(j, l)+g(k, r))\}\}$（这里把 $w(l, r)$ 不管给哪个场地算出来的答案都是一样的，原因同上）

其中 $ans[i]$ 表示必选第 $i$ 个活动的答案。这样复杂度是 $O(n^5)$ 的，需要优化

发现外面的 $l, r$ 实际上会**重复取值**很多次，我们考虑直接将每个合法的 $l, r$ 的答案都预处理出来。具体即：

$anstmp[l][r]=\max\limits_{0\leq j\leq n, 0\leq k\leq n}\{\min(j+k+w(l, r), f(j, l)+g(k, r))\}$

这样就可以把 $ans[.]$ 的方程写成 $O(n^3)$ 的：

$ans[i]=\max\limits_{0\leq l\leq l_i, r_i\leq r\leq T}\{antmp[l][r]\}$

&nbsp;

但 $anstmp[.][.]$ 的方程是 $O(n^4)$ 的，还是有点悬（如果你卡常技术够好，其实说不定也能过...），考虑优化

考虑状态的定义，我们发现：

> 引理 $1.$ 对于固定的 $l, r$，$j+k+w(l, r)$ 的值随 $j, k$ 的增大单调递增

> 引理 $2.$ 对于固定的 $l, r$，$f(j, l)+g(k, r)$ 的值随 $j, k$ 的增大**单调不增**

于是由 引理 $1$、引理 $2$ 可得，若固定 $j, k$ 中的其中一个，将 $\min$ 左边和右边的式子都表示成关于另一个变量（$j, k$）的函数 $F, G$（分别对应左边，右边），则这两个函数一定只有一个交点；而这个交点就把 $\min$ 的函数图像分成了两段

这里我们将左右的式子表示成关于 $k$ 的函数

接着对每个 $j$，我们设 “交点” $m_j$（但含义有点不同，主要因为这里的函数定义在整数域），满足 $\forall k:0\leq k\leq m_j, F(k)\leq G(k)$ 且 $\forall k:m_j < k \leq n, F(k) > G(k)$

又由 引理 $2$ 可得，当 $j$ 增大时，$m_j$ 也**单调不增**

于是我们就可以在枚举 $j$ 时设 $m_j$ “随着” $j$ 一起枚举（有点像双指针）。由于 $m_j$ 单调不增，关于 $j, m_j$ 这层循环的复杂度就是 $O(n)$ 的

于是我们成功将 $anstmp[.][.]$ 的计算过程也优化为 $O(n^3)$ 的

## CODE

```cpp
#include <cstdio>
#include <algorithm>
#pragma GCC optimize("O3")
#pragma GCC optimize("Ofast", "-funroll-loops", "-fdelete-null-pointer-checks")
#pragma GCC target("ssse3", "sse3", "sse2", "sse", "avx2", "avx")
using std::sort;
using std::pair;
using std::max;
using std::min;
typedef pair<int, int> pad;

const int MAXN =210, MAXT =420;

int T;
int S[MAXN], E[MAXN], ans[MAXN];
int w[MAXT][MAXT], anstmp[MAXT][MAXT];
int dppre[MAXT][MAXN], dpsuf[MAXT][MAXN];/*统计了 [0, r]/[l, MAXT] 的活动，第一场地 k 个活动，第二场地活动最大值*/

pad a[MAXT];

int main(){
	int n;
	scanf("%d", &n);
	for(int i =0; i < n; ++i){
		scanf("%d%d", &S[i], &E[i]);
		E[i] +=S[i];
		a[i] =pad(S[i], i), a[n+i] =pad(E[i], n+i);
	}
	sort(a, a+2*n);/*离散化*/
	for(int i =0; i < 2*n; ++i){
		if(a[i].second < n)
			S[a[i].second] =T;
		else
			E[a[i].second-n] =T;
		if(i < 2*n-1 && a[i].first != a[i+1].first)
			++T;
	}
	for(int l =0; l <= T; ++l)/*预处理 w*/
		for(int r =l; r <= T; ++r)
			for(int i =0; i < n; ++i)
				if(S[i] >= l && E[i] <= r)
					++w[l][r];
	
	for(int r =0; r <= T; ++r)/*预处理 f*/
		for(int k =0; k <= n; ++k)
			for(int rpre =0; rpre < r; ++rpre){
				if(k >= w[rpre][r])/*最后一段给第一会场*/
					dppre[r][k] =max(dppre[r][k], dppre[rpre][k-w[rpre][r]]);
				if(w[0][rpre] >= k)/*最后一段给第二会场*/
					dppre[r][k] =max(dppre[r][k], dppre[rpre][k]+w[rpre][r]);
			}
	for(int l =T; l >= 0; --l)/*预处理 g*/
		for(int k =0; k <= n; ++k)
			for(int lpre =T; lpre > l; --lpre){
				if(k >= w[l][lpre])/*最后一段给第一会场*/
					dpsuf[l][k] =max(dpsuf[l][k], dpsuf[lpre][k-w[l][lpre]]);
				if(w[lpre][T] >= k)/*最后一段给第二会场*/
					dpsuf[l][k] =max(dpsuf[l][k], dpsuf[lpre][k]+w[l][lpre]);
			}
	for(int l =0; l <= T; ++l)/*计算 anstmp*/
		for(int r =l; r <= T; ++r)
			for(int kl =0, kr =w[r][T]; kl <= w[0][l]; ++kl){/*kl -> j, kr -> m_j*/
				/*min(kl+w[l][r]+kr, dppre[l][kl]+dpsuf[r][kr])*/
				while(kr >= 0 && kl+w[l][r]+kr > dppre[l][kl]+dpsuf[r][kr])
					--kr;
				if(kr >= 0)/*避免越界/不合法情况*/
					anstmp[l][r] =max(anstmp[l][r], kl+w[l][r]+kr);
				if(kr < w[r][T])/*避免不合法情况*/
					anstmp[l][r] =max(anstmp[l][r], dppre[l][kl]+dpsuf[r][kr+1]);
			}
	for(int i =0; i < n; ++i)
		for(int l =0; l <= S[i]; ++l)
			for(int r =E[i]; r <= T; ++r)
				ans[i] =max(ans[i], anstmp[l][r]);
	
	int Ans1 =0;
	for(int k =0; k <= w[0][T]; ++k)
		Ans1 =max(Ans1, min(dppre[T][k], k));
	printf("%d\n", Ans1);
	for(int i =0; i < n; ++i)
		printf("%d\n", ans[i]);
}
```

---

## 作者：约瑟夫用脑玩 (赞：0)

简单题，写挂了，感觉模拟赛随便胡了个算法和其他人不太一样，但估计本质还是差不多的。

首先发现时间点之间的间隔大小没有用，只用考虑时间点就只有 $O(n)$ 个，令时间点个数为 $t$。

考虑两个会场发现无本质区别，于是谁选多选少无关而只与两者活动差值有关。

于是设仅在 $1\sim i$ 的时间点之内选活动，使得两个会场活动相差为 $j$，少的那个会场举办的活动最多为 $f_{i,j}$，同理定义仅在 $i\sim t$ 个时间点内选的少的那个最多活动数为 $g_{i,j}$。

转移的话还得预处理 $w_{i,j}$ 表示在 $i\sim j$ 的时间点之间的区间个数，注意这道题比较奇怪端点都可以算进来，然后枚举把 $w$ 给哪个会场就有了转移式：

$$f_{j,k}\to f_{i,k+w_{j,i}}$$

$$f_{j,k}+k\to f_{i,w_{j,i}-k},k\le w_{i,j}$$

$$f_{j,k}+w_{j,i}\to f_{i,k-w_{j,i}},k>w_{i,j}$$

第一问的答案就出来了，就是 $\max_x f_{n,x}$，或是 $\max_x g_{1,x}$。

考虑第二问，首先我们肯定枚举强制选了当前区间 $i$ 的是哪个时间点之内，也即枚举 $w_{j,k},j\le S_i,T_i\le k$。

发现为了合并还得枚举左边的差为 $a$，右边的差为 $b$，总共就 $O(n^5)$ 了，接下来有两种做法：

- 一个sb的模拟赛考场做法是改变枚举顺序后把 $k,b$ 改为预处理，也即我们完全把左边的情况枚举出来，右边的情况通过提前处理快速得到。

  但由于有偏序 $j\le S_i,T_i\le k$ 的同时还得处理合并得到最大值，预处理过后只好上一棵主席树来快速询问，$O(n^3\log n)$，现在都还没改出来。
  
- 真正的简单的做法是把 $i$ 丢掉，先算 $val_{j,k}$ 的答案，再枚举强制选了 $i$ 的时间点之内 $w_{j,k}$，直接取之前算出来的答案即可。

  然后发现上一个做法一样预处理一下，合并的时候就可以把 $w,a,b$ 丢掉一个 $a/b$，没有偏序于是随便写使用的时候都是 $O(1)$ 的，轻松 $O(n^3)$。
  
[代码轻度压行](https://www.luogu.com.cn/paste/up1ge3yi)

---


# [NOI2012] 迷失游乐园

## 题目描述

放假了，小 Z 觉得呆在家里特别无聊，于是决定一个人去游乐园玩。

进入游乐园后，小 Z 看了看游乐园的地图，发现可以将游乐园抽象成有 $n$ 个景点、$m$ 条道路的无向连通图，且该图中至多有一个环（即 $m$ 只可能等于 $n$ 或者 $n-1$）。

小 Z 现在所在的大门也正好是一个景点。小 Z 不知道什么好玩，于是他决定，从当前位置出发，每次随机去一个和当前景点有道路相连的景点，并且同一个景点不去两次（包括起始景点）。贪玩的小 Z 会一直游玩，直到当前景点的相邻景点都已经访问过为止。

小 Z 所有经过的景点按顺序构成一条非重复路径，他想知道这条路径的期望长度是多少？

小 Z 把游乐园的抽象地图画下来带回了家，可是忘了标哪个点是大门，他只好假设每个景点都可能是大门（即每个景点作为起始点的概率是一样的）。同时，他每次在选择下一个景点时会等概率地随机选择一个还没去过的相邻景点。


## 说明/提示

### 样例解释

样例数据中共有 $6$ 条不同的路径：

|路径|长度|概率|
|:-:|:-:|:-:| 
|$1\rightarrow 4$|$8$|$\frac{1}{4}$| 
|$2\rightarrow 1$|$3$|$\frac{1}{8}$| 
|$2\rightarrow 4$|$5$|$\frac{1}{8}$|
|$3\rightarrow 1$|$4$|$\frac{1}{8}$|
|$3\rightarrow 4$|$4$|$\frac{1}{8}$|
|$4\rightarrow 1$|$8$|$\frac{1}{4}$|

因此期望长度 $= \frac{8}{4} + \frac{3}{8} + \frac{5}{8} +\frac{4}{8} + \frac{4}{8} +\frac{8}{4} = 6.00$

### 评分方法

本题没有部分分，你程序的输出只有和标准答案的差距不超过 $0.01$ 时，才能获得该测试点的满分，否则不得分。


### 数据规模和约定

对于 $100\%$ 的数据，$1\leq W_i\leq 100$。

|测试点编号|$n$|$m$|备注| 
|:-:|:-:|:-:|:-:|
|$1$| $n=10$| $m = n-1$| 保证图是链状 |
|$2$| $n=100$|  $m = n-1$|只有节点 $1$ 的度数大于 $2$| 
|$3$| $n=1000$| $m = n-1$| / | 
|$4$| $n=10^5$| $m = n-1$| / | 
|$5$| $n=10^5$|  $m = n-1$| / | 
|$6$| $n=10$| $m = n$ | / | 
|$7$| $n=100$| $m = n$| 环中节点个数 $\leq 5$| 
|$8$| $n=1000$|$m = n$| 环中节点个数 $\leq 10$| 
|$9$| $n=10^5$ | $m = n$| 环中节点个数 $\leq 15$| 
|$10$| $n=10^5$|$m = n$| 环中节点个数 $\leq 20$| 


## 样例 #1

### 输入

```
4 3
1 2 3
2 3 1
3 4 4```

### 输出

```
6.00000000```

# 题解

## 作者：emptysetvvvv (赞：107)

## 背景

Update2022.2.22: 纪念我的首篇题解，虽然我已经是个失败者了，但是 zcysky 成我班助了！有空更张 zcysky 照片（逃

## 思路

### PART I

题意：给定带权的树或基环树，从随机一点出发走**每个点至多经过一次**的路径，问期望路径长度。

$son_u$ 表示 $u$ 的子结点数量；$fa_u$ 表示 $u$ 的父结点数量，取值为 $1$ 或 $2$（因为有环）。

$down_u$ 表示从 $u$ 出发，第一步向下走的期望路径长度，「下」指子结点方向即叶子方向；

$up_u$ 表示从 $u$ 出发，第一步向上走的期望路径长度，「上」指父结点方向。

> 注意：只规定了第一步向上走，第二步允许去 $u$ 的父亲 $k$ 的其他子结点。

那么从 $u$ 出发的期望路径长度为：

$$\large ans_u=\dfrac{down_u\cdot son_u+up_u\cdot fa_u}{son_u+fa_u}$$

### PART II

先考虑 50pts 的普通树做法。

$down_u$ 显然只不依赖任何的 $up$ 值：

$$\large down_u=\dfrac{1}{son_u}\sum_{v\text{ is son of }u}(down_v+w_{u,v})$$

$v$ 是 $u$ 的子结点，$w_{u,v}$ 表示边权。特别的，叶子结点 $down$ 值为 $0$。

对于普通树，$u$ 至多有一个父结点 $k$，而 $up_u$ 是要依赖 $up_k,down_k$ 的：

$$\large up_u=w_{u,k}+\dfrac{up_k\cdot fa_k+down_k\cdot son_k-down_u-w_{u,k}}{fa_k+son_k-1}$$

解释如下：

不论如何，第一步贡献 $w_{u,k}$。

粗略地看，继续向上走贡献 $up_k\cdot fa_k$，转而向下走贡献 $down_k\cdot son_k$，考虑到不能走回来，故应减去 $down_u+w_{u,k}$。

第二步向上有 $fa_k$ 种选择，向下有 $son_k-1$ 种选择（不允许回来），故分母为 $fa_k+son_k-1$。

特别的，若 $k$ 仅与 $u$ 相连即 $fa_k+son_k-1=0$，则 $up_u=w_{u,k}$，没有后一项。

实现时，计算 $up,down$ 值，由于前者依赖后者，而后者不依赖前者，故流程如下：

1. 从根节点开始，递归每个子结点计算 $down$ 值；
2. 递归至 $u$ 时，先递归子结点，得到每个 $down_v$，然后计算 $down_u$，返回；
3. 得到该普通树的 $down$ 值后，从根节点的每个子结点开始，递归计算 $up$ 值；
4. 递归至 $u$ 时，根据父结点 $k$ 的信息计算 $up_u$，然后递归子结点计算，返回；
5. 根据 $up_i,down_i$ 计算 $ans_i$，最终结果为 $\displaystyle\dfrac{1}{n}\sum_{i=1}^nans_i$。

### PART III

再来考虑基环树的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/1vtxcxat.png)

> 如图所示是一棵并不优美的基环树，箭头指向父结点（$1$ 或 $2$ 个），加粗结点是环上结点，以下简称「黑点」，其余结点简称「白点」。

我们将基环树看做**若干普通树根节点相连成环**的结果。

注意到无论从哪一点出发，第一步向下，活动范围始终在普通树内部，即：无论黑白，$down$ 值不变。

若 $u$ 是白点，只有唯一父亲 $k$，尽管此时 $fa_k$ 不一定为 $1$（白点 $u$ 的父亲 $k$ 是黑点时 $fa_k=2$），但显然考虑推导过程，$up_u$ 仍符合上文的公式。

若 $u$ 是黑点，则 $up_u$ 的计算显得和繁琐。

> $u$ 第一步去了另一个黑点，第二步可以选择继续在环上走，还可以选择钻入该黑点的子树。

为了方便处理，我们先通过深搜得到：

- 黑点总数 $t$；
- $\text{dfn[u]}$，维护 $u$ 是搜到的第几个黑点；
- $\text{path[i]}$，维护第 $i(1\leqslant i\leqslant t)$ 个黑点的实际编号 $u(1\leqslant u\leqslant n)$；
- $\text{disl[i],disr[i]}$，类似于链表的意味，维护第 $i$ 个黑点与左右相邻黑点的距离。

对于黑点 $u$，先规定第一步必须逆时针走，则有：

$$\large up_u=\sum_{i}P_i\times \left(\dfrac{down_{\text{path[i]}}\cdot son_{\text{path[i]}}}{son_{\text{path[i]}}+1}+w\right)$$

其中，$i$ 依次取 $\text{dfn[u]}+1,\text{dfn[u]}+2,\text{dfn[u]}+3,\ldots,t,1,2,3,\ldots\text{dfn[u]}-1$。

> 嗯，这个式子有失数学美感，但严谨的讲，的确是这个样子。不要紧，我们来看看这是什么意思。

根据期望的定义，期望等于**执行第 $k$ 步的概率与第 $k$ 步带来的贡献的乘积**的累加和。

先来看概率，$P_i$ 表示走到该点的概率，规定了第一步逆时针，即 $P_{\text{dfn[u]}+1}=1$。

第 $i$ 个黑点的下一个黑点是 $i\bmod t+1$，需要在第 $i$ 个黑点的 $son_{\text{path[i]}}$ 个子结点和下一个黑点之中选择下一步去哪里，那么 $P_{i\bmod t+1}=\dfrac{1}{son_{\text{path[i]}}+1}P_i$。

再来看从顺时针方向的上一个黑点走到第 $i$ 个黑点的贡献，首先有边权 $w$，即 $\text{disl[i]}$。

其次，我们需要考虑如果从此钻入第 $i$ 个黑点的子树产生的贡献，即 $\dfrac{down_{\text{path[i]}}\cdot son_{\text{path[i]}}}{son_{\text{path[i]}}+1}$。

特别的，如果第 $i$ 个黑点逆时针方向的下一个黑点就是  $u$ 的话，只能选择钻入子树而不能继续走重复的，那么分母就应该为 $son_{\text{path[i]}}$ 即钻入该子树的贡献直接就是  $down_{\text{path[i]}}$。

刚刚规定了第一步必须逆时针走，现在再规定第一步必须顺时针求一遍，最终给 $up$ 值除以 $2$ 即可。

> 当然，也可以在一开始就令 $P=\dfrac{1}{2}$，代码中也是这样实现的。

这很好理解，由于路径不重复，所以不可能顺逆时针交替，顺逆各求一遍一定包含了所有情况，只不过每个概率都放大了 $2$ 倍，现在除以 $2$ 即可。

理清逻辑关系，所有 $down$ 值只依赖其子结点的 $down$ 值，黑点的 $up$ 值依赖 $down$ 值，白点的 $up$ 值依赖黑点的 $up$ 值和 $down$ 值，故流程如下：

1. 从每个黑点即每个普通树的根节点开始，递归每个子结点计算 $down$ 值，方法同普通树；
2. 计算每个黑点的 $up$ 值，顺逆时针各求一遍，然后除以 $2$，如上文所示；
3. 从每个黑点的每个子结点开始，递归计算白点的 $up$ 值，方法同普通树；
4. 根据 $up_i,down_i$ 计算 $ans_i$，最终结果为 $\displaystyle\dfrac{1}{n}\sum_{i=1}^nans_i$。

## 代码

> 带空格有注释，神犇请自行跳过。

实际上， $\varnothing$ 是一个蒻不禁风的被全机房吊着打的萌新，她的代码糟糕透了，特别是充实感紧凑美给人带来的视觉震撼程度都比  CK6100LGEV2 不知道差到哪里去了，她用了整整 100 行，而 CK6100LGEV2 只用了 60 行（逃）。

```cpp
#include <cstdio>
const int maxn = 100005;
int n, m, fa[maxn], son[maxn];
double up[maxn], down[maxn], ans;
struct Edge {
	int to, next, w;
	Edge() {}
	Edge(int to, int next, int w): to(to), next(next), w(w) {}
} e[maxn<<1];
int head[maxn], cnt;
void add(int u, int v, int w) {
	e[++cnt] = Edge(v, head[u], w);
	head[u] = cnt;
}
#define v e[i].to
int pos;
bool vis[maxn], flag;//是否在环上
void dfs1(int u, int k) {
	vis[u] = true;
	for(int i = head[u]; i; i = e[i].next)
		if(v != k) {
			if(vis[v]) { pos = v; return; }
			dfs1(v, u);
			if(!flag and pos) { if(pos == u) flag = true; return; }
			if(flag) break;
		}
	vis[u] = false;
}//将所有环上结点的 vis 标记为 true
int t, disl[22], disr[22], dfn[maxn], path[22];
void dfs2(int u, int k) {
	dfn[u] = ++t, path[t] = u;
	fa[u] = 2;
	for(int i = head[u]; i; i = e[i].next)
		if(v != k and vis[v]) {
			if(!dfn[v]) dfs2(v, u);
			disr[dfn[u]] = disl[dfn[v]] = e[i].w;
			break;
		}
}//处理环上信息
void dp_down(int u, int k) {
	for(int i = head[u]; i; i = e[i].next)
		if(v != k and !vis[v]) {
			fa[v] = 1;
			dp_down(v, u);
			son[u]++;
			down[u] += down[v] + e[i].w;
		}
	if(son[u]) down[u] /= son[u];
}
void dp_up(int u, int k, int w) {
	up[u] = w;
	if(fa[k] + son[k] - 1)
		up[u] += (up[k]*fa[k]+down[k]*son[k]-down[u]-w) / (fa[k]+son[k]-1);
	for(int i = head[u]; i; i = e[i].next)
		if(v != k) dp_up(v, u, e[i].w);
}
void work1() {
	dp_down(1, 0);
	for(int i = head[1]; i; i = e[i].next)
		dp_up(v, 1, e[i].w);
}
double P;
#define nxt(x) (x==t?1:x+1)
#define pre(x) (x==1?t:x-1)
void work2() {
	dfs1(1, 0);
	dfs2(pos, 0);
	for(int i = 1; i <= t; ++i)
		dp_down(path[i], 0);
	for(int i = 1, x; i <= t; ++i) {
		x = path[i];
		P = 0.5;
		for(int j = nxt(i), y; j != i; j = nxt(j)) {
			y = path[j];
			if(nxt(j) == i) up[x] += P * (disl[j]+down[y]);
			else up[x] += P * (down[y]*son[y]/(son[y]+1)+disl[j]);
			P /= (son[y]+1);
		}
		P = 0.5;
		for(int j = pre(i), y; j != i; j = pre(j)) {
			y = path[j];
			if(pre(j) == i) up[x] += P * (disr[j]+down[y]);
			else up[x] += P * (down[y]*son[y]/(son[y]+1)+disr[j]);
			P /= (son[y]+1);
		}
		for(int j = head[x]; j; j = e[j].next)
			if(!vis[e[j].to]) dp_up(e[j].to, x, e[j].w);
	}
}
#undef v
int main() {
	scanf("%d %d", &n, &m);
	for(int i = 1, u, v, w; i <= m; ++i)
		scanf("%d %d %d", &u, &v, &w), add(u, v, w), add(v, u, w);
	if(n != m) work1();//普通树
	else work2();//基环树
	for(int i = 1; i <= n; ++i)
		ans += (down[i]*son[i]+up[i]*fa[i]) / (son[i]+fa[i]);
	printf("%.5lf\n", ans / n);
}
```

---

## 作者：Awar3ness (赞：25)

题解：考虑只有一棵树，那么down[x]和up[x]分别表示向上走和向下走的期望，然后先dfs一遍求down，down[i]=sigma(down[j]+len[i][j])/du[i](j是i的儿子)，也就是期望加起来再加上边的长度再除以总情况数。

然后再求up[x]。up[x]=len[fa[x]][x]+(up[fa[x]]+down[fa[x]]*du[fa[x]]-down[x]-len[fa[x]][x])/du[fa[x]]。首先我们要走x到父亲的一段，然后再加上父亲的up+父亲的down*父亲的度数，但是这样会把x子树算上，所以我们要减去down[x]和len[fa[x]][x]，最后这个整体再除以总数（也就是乘概率），就是up[x]。

那么最后所有节点的ans除以自己的度数（也就是乘概率），再全部加起来除以n，就是最后的答案了。

但是我们有一个环该怎么办呢。

首先这个环导致树变成了len(环)个小树+一个大环，所以我们可以直接对所有小树求down，up就比较麻烦了，我们先对环求出来g数组，表示从这个点开始走的期望，因为环的大小很小，所以我们枚举rt，然后直接dp一遍，g[i]=(g[to[x]]+len[to[x]][x])/(du[x]+1)，算完之后，我们再把down计入到贡献中，直接加权即可，但是要注意度数为0的情况，要强制置1。如果下一步就走到了rt，那么我们就不要把g计算到贡献中，因为我们钦定了rt，不能出现走回去的情况；如果当前点就是rt，那么不要计算down的贡献直接return，因为现在我们直接就钦定了up是往rt走的。

算完g和down对答案的贡献之后，我们把环上所有的du都+=2，因为环上有两个出边（前面不加是因为计算的是down的贡献，而g不需要度数来计算），然后我们枚举环上每个点，进行up的计算。

具体看代码吧。

自带大常数（逃
```cpp
#include <bits/stdc++.h>  
using namespace std;  
struct nod{int to;double len;};  
vector<nod>e[100005];  
int x,y,z,n,m,xi,yi,wi,cir[100005],vis[100005],fa[100005],du[100005],rt,tim;  
double f[100005],d[100005],tp[100005],g[100005],ans;  
void dfs1(int x)  
{  
    vis[x]=1;  
    for(int i=0;i<e[x].size();i++)  
        if(!vis[e[x][i].to]&&!cir[e[x][i].to])  
            dfs1(e[x][i].to),du[x]++,d[x]+=f[e[x][i].to]+e[x][i].len;  
    if(du[x]) f[x]=d[x]/(double)du[x];  
    if(x!=rt) du[x]++;  
}  
void dfs2(int x)  
{  
    vis[x]=1;  
    for(int i=0;i<e[x].size();i++)  
        if(!vis[e[x][i].to]&&!cir[e[x][i].to])  
            d[e[x][i].to]+=(d[x]-f[e[x][i].to]-e[x][i].len)/max(1,du[x]-1)+e[x][i].len,dfs2(e[x][i].to);  
}  
void dfs3(int x)  
{  
    vis[x]=++tim;  
    for(int i=0,j;i<e[x].size();i++)  
        if(e[x][i].to!=fa[x])  
        {  
            if(!vis[e[x][i].to]) fa[e[x][i].to]=x,dfs3(e[x][i].to);  
            else if(vis[e[x][i].to]<vis[x]) for(cir[e[x][i].to]=1,j=x;j!=e[x][i].to;j=fa[j]) cir[j]=1;  
        }  
}  
void dfs4(int x,int fa)  
{  
    bool flag=0;g[x]=0;  
    for(int i=0;i<e[x].size();i++)  
        if(e[x][i].to!=rt&&e[x][i].to!=fa&&cir[e[x][i].to])  
            flag=1,dfs4(e[x][i].to,x),g[x]+=g[e[x][i].to]+e[x][i].len;  
    if(x==rt) return;  
    int k=du[x];k?k:k++;  
    if(!flag) g[x]=d[x]/(double)k;  
    else k=du[x]+1,g[x]=(g[x]+d[x])/(double)k;  
}  
int main()  
{  
    scanf("%d%d",&n,&m);  
    for(int i=1;i<=m;i++) scanf("%d%d%d",&x,&y,&z),e[x].push_back((nod){y,z}),e[y].push_back((nod){x,z});  
    if(m==n-1) rt=1,dfs1(1),memset(vis,0,sizeof vis),dfs2(1);  
    else  
    {  
        dfs3(1);memset(vis,0,sizeof vis);  
        for(int i=1;i<=n;i++) if(cir[i]) rt=i,dfs1(i);  
        for(int i=1;i<=n;i++) if(cir[i]) rt=i,dfs4(i,0),tp[i]=g[i];  
        memset(vis,0,sizeof(vis));  
        for(int i=1;i<=n;i++) if(cir[i]) du[i]+=2,d[i]+=tp[i];  
        for(int i=1;i<=n;i++) if(cir[i]) rt=i,dfs2(i);  
    }  
    for(int i=1;i<=n;i++) ans+=d[i]/(double)du[i];  
    printf("%.5lf\n",ans/(double)n);  
}
```

---

## 作者：GKxx (赞：14)

题意：给一棵树或者基环树，随机选一条路径，求路径期望长度。

我们可以对于每个点$i$求出从$i$出发的路径期望长度$ans_i$，那么最终答案是$\frac{1}{n}\sum\limits_{i=1}^n ans_i$。

首先考虑树的情况。在树上，从一个点出发的路径可以大致分为两种：向上走和向下走。设$f[x]$表示从$x$出发往下走的路径期望长度，$g[x]$表示往上走的期望长度，同时记$son[x]$表示$x$的儿子数量，显然有转移

$f[x]=\frac{1}{son[x]}\sum(f[v]+w(x,v))$，其中$v$是$x$的孩子

$g[v]=w(x,v)+(g[x]+f[x]\times son[x]-f[v]-w(x,v))/(son[x]-[x==root])$，其中$x$是$v$的父亲

简单解释一下$g$的转移：如果要从$v$往上走，肯定要经过$(x,v)$这条边；然后从$x$可能往上走也可能往下走，往上走就是$g[x]$，往下走就是$f[x]\times son[x]$但是不能走到$v$，所以要将$v$对$f[x]\times son[x]$产生的贡献减去，因此减去$f[v]+w(x,v)$；如果$x$不是根节点，那么总共就有$son[x]-1+1$种情况，但如果$x$是根节点就只有$son[x]-1$种情况。另外还要特判：如果$x$是根并且$son[x]==1$，分母会为$0$，这时$g[v]=w(x,v)$。

于是$ans_i=(f[i]\times son[i]+g[i])/(son[i]+[i\neq root])$。

```cpp
namespace tree {
    void dfs1(int x, int fa) {
        for (int i = head[x]; i; i = next[i])
            if (v[i] != fa) {
                ++son[x];
                dfs1(v[i], x);
                f[x] += f[v[i]] + w[i];
            }
        if (son[x]) f[x] /= son[x];
    }
    void dfs2(int x, int fa) {
        double tmp = g[x] + f[x] * son[x];
        for (int i = head[x]; i; i = next[i])
            if (v[i] != fa) {
                if (x == 1) {
                    if (son[x] == 1) g[v[i]] = w[i];
                    else g[v[i]] = w[i] + (tmp - f[v[i]] - w[i]) / (son[x] - 1);
                } else g[v[i]] = w[i] + (tmp - f[v[i]] - w[i]) / son[x];
                dfs2(v[i], x);
            }
    }
    inline void work() {
        dfs1(1, 0);
        dfs2(1, 0);
        double ans = f[1];
        for (int i = 2; i <= n; ++i)
            ans += (f[i] * son[i] + g[i]) / (son[i] + 1);
        ans /= n;
        printf("%.5lf\n", ans);
    }
}
```

然后考虑基环树的做法：首先可以把环找出来，然后把图画成这样：

![基环树](https://cdn.luogu.com.cn/upload/pic/50526.png)

会发现其实是一个环加周围很多棵小树。我们依然像刚才树的做法中那样定义$f[x]$和$g[x]$，那么不难发现其实$f[x]$是不受影响的，可以对每棵小树跑`dfs`处理出来。关键在于$g[x]$：对于不在环上的结点，$g[x]$其实也不受影响，但是环上的结点的$g[x]$需要特别处理。

考虑到环上的结点不超过20个，可以对每个节点都这样做一遍：从它（记为$st$，起始点）开始沿着环顺时针走一圈，再逆时针走一圈。走的过程中既可以往环上走，也可以往树上走，但是不能走已经走过的结点。这里直接看下面的代码会比较清楚。

处理完环上结点的$g$之后跑树上的$g$，这时要注意环上的结点向上有两条路，而非环上的结点向上只有一条路，所以转移方程也要微调。

然后统计答案就行了。

```cpp
namespace circle {
    bool onc[maxn];
    int pre[maxn], dfn[maxn], tim;
    void find(int x) {
        dfn[x] = ++tim;
        for (int i = head[x]; i; i = next[i])
            if (v[i] != pre[x]) {
                if (!dfn[v[i]]) {
                    pre[v[i]] = x;
                    find(v[i]);
                } else if (dfn[v[i]] < dfn[x]) {
                    for (int j = x; j != v[i]; j = pre[j])
                        onc[j] = 1;
                    onc[v[i]] = 1;
                    return;
                }
            }
    }
    void getf(int x, int fa) {
        for (int i = head[x]; i; i = next[i])
            if (v[i] != fa && !onc[v[i]]) {
                ++son[x];
                getf(v[i], x);
                f[x] += w[i] + f[v[i]];
            }
        if (son[x]) f[x] /= son[x];
    }
    double walk(int x, int fa, int st) {
        for (int i = head[x]; i; i = next[i])
            if (onc[v[i]] && v[i] != fa) {
                if (v[i] == st) return f[x];
                else return (walk(v[i], x, st) + w[i] + f[x] * son[x]) / (son[x] + 1);
            }
        return 0;
    }
    inline void solve(int x) {
        for (int i = head[x]; i; i = next[i])
            if (onc[v[i]])
                g[x] += walk(v[i], x, x) + w[i];
        g[x] /= 2;
    }
    void getg(int x, int fa) {
        for (int i = head[x]; i; i = next[i])
            if (v[i] != fa && !onc[v[i]]) {
                if (onc[x])
                    g[v[i]] = w[i] + (g[x] * 2 + f[x] * son[x] - f[v[i]] - w[i]) / (son[x] + 1);
                else
                    g[v[i]] = w[i] + (g[x] + f[x] * son[x] - f[v[i]] - w[i]) / son[x];
                getg(v[i], x);
            }
    }
    inline void work() {
        find(1);
        for (int i = 1; i <= n; ++i)
            if (onc[i]) getf(i, 0);
        for (int i = 1; i <= n; ++i)
            if (onc[i]) solve(i);
        for (int i = 1; i <= n; ++i)
            if (onc[i]) getg(i, 0);
        double ans = 0;
        for (int i = 1; i <= n; ++i)
            if (onc[i]) ans += (f[i] * son[i] + g[i] * 2) / (son[i] + 2);
            else ans += (f[i] * son[i] + g[i]) / (son[i] + 1);
        ans /= n;
        printf("%.5lf\n", ans);
    }
}
```

其实是比较简单的基环树dp，不知道为啥评成黑题

祝各位新年快乐！

---

## 作者：墨尔 (赞：10)

对于树的情况：

从树上任意一个节点出发，显然只能往上或者往下一直走，因此考虑树形dp。设up[i]表示往上走的期望长度，down[i]表示往下走的期望长度，son[i]表示以i的孩子数。

down[u]=sigma(down[v]+len[u][v])/son[u];（u是v的父节点）

up[v]=len[u][v]+(up[u]+down[u]\*son[u]-down[u]-len[u][v])/son[u];（v向上走到达u后，可以向u的孩子其他孩子走，也可以继续向上走，有son[u]-1+1种选择）

综上我们可以算出从一个点i出发的期望长度：(down[i]\*son[i]+up[i])/(son[i]+1);

ans就是所有n个点的期望长度加起来除以n

当然对于根无法向上走的情况要特判，同时也要注意除以0的情况。


对于环的情况：

由于最多一个环，把所有的环上点处理出来，我们将环上的每个节点都作为一棵树（树上不包含环上点）的根，算出整棵树的down；

然后，从每一个环上点i出发，单独计算它的up（环上最多20个节点），过程如下：

刚出发时，因为是一个环，可以顺时针也可以逆时针走，两者概率为0.5，而走到下一个点j后可以选择往以j为根的树走也可以继续绕环走，因此期望长度为0.5\*(len[i][j]+down[j]\*son[j]/(son[j]+1));而走到了j的下一个点k的概率为0.5/(son[j]+1)，因此同理期望长度0.5/(son[j]+1)\*(len[j][k]+down[k]\*son[k]/(son[k]+1))，以此类推，直到走到某点j时发现j在环上的下一个点为出发点时，显然不能绕环走而只能往树上走了，因此期望长度为p\*(len[lastj][j]+down[j])。

算出环上up后再算树上的up，注意此时每棵树的根是有两条向上的路的。

最后算出答案。

环的特判较多，思维一定要理顺。


代码因为我写的很乱就不贴了……


---

## 作者：_LAUV_ (赞：5)

模拟完样例大概可以知道是道树形DP了。

观察数据范围，发现是基环树，至少会有一个环。

先从树的部分开始考虑，如果没有环，怎么DP呢?

先选取一个点为根，f[i]表示从i节点出发走到其子树的路径期望长度。

那么
f[x]= sum(f[son]+w[i])/（rd[x]-1），w[i]为son到x的边长，rd[x]为x的度数，当然如果到了根节点，就不必要减1。

然后再换根一波，统计答案就可以了。换根时注意节点度数的处理就行。

这样就能轻松拿到50分的良心部分分。

如果是基环树呢？

习惯把基环树看成一个“细菌”，把环放正中间考虑。


![](https://cdn.luogu.com.cn/upload/pic/51231.png)



每一个在环上的点都连接着一个子树，先用前面树形DP的方法对每部分子树进行求解，先不换根。

对于环上每个点，可以逆时针走，也可以顺时针走，所以枚举它左右两条边断掉，拆成链。

在链上推一遍就可以得到从这个点往右或往左走的路径期望长。（环上点数量很少，复杂度在允许的范围内）

用这两种期望长度再去更新这个点，然后跑到这个点对应的子树去换根、统计答案。

算期望除以点度数时比较繁琐，写的时候要小心。

安利一波博客~ [【NOI2012】迷失游乐园](https://www.cnblogs.com/HLAUV/p/10358058.html)

代码~

```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>

#define For(i,a,b) for(register int i=a;i<=b;++i)
#define Dwn(i,a,b) for(register int i=a;i>=b;--i)
#define Re register
#define Db double

using namespace std;

const int N=1e5+5;

int head[N],nxt[N*2],v[N*2],cnt=1;
Db f[N],w[N*2],rd[N],z,ans=0,Dn;
int n,x,y,m;
bool Fcr[N],vis[N],Ffd=0;

inline void read(int &v){
	v=0;
	char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9')v=v*10+c-'0',c=getchar();
}
inline void read(Db &v){
	v=0;
	char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9')v=v*10+c-'0',c=getchar();
}
void add(int ux,int vx,Db wx){
	cnt++; rd[ux]+=1;
	nxt[cnt]=head[ux]; head[ux]=cnt; v[cnt]=vx; w[cnt]=wx;
	cnt++; rd[vx]+=1;
	nxt[cnt]=head[vx]; head[vx]=cnt; v[cnt]=ux; w[cnt]=wx;
}
void dfsDP(int x,int fa){
	for(Re int i=head[x];i;i=nxt[i]){
		int vv=v[i]; if(vv==fa)continue;
		if(Fcr[vv])continue;
		dfsDP(vv,x);
		f[x]+=f[vv]+w[i];
	}
	if(rd[x]>1&&fa)f[x]/=(rd[x]-1.0);
	if(fa==0&&rd[x])f[x]/=rd[x]; 
}
void dfsFA(int x,int fa){
	ans+=f[x]/Dn; 
	for(Re int i=head[x];i;i=nxt[i]){
		int vv=v[i]; if(vv==fa)continue;
		if(Fcr[vv])continue;
		Db Bfx=f[x]; Db Bfv=f[vv];
		
		Bfx=f[x]*rd[x]-f[vv]-w[i];
		if(rd[x]>1)Bfx/=(rd[x]-1);
		
		f[vv]=f[vv]*(rd[vv]-1)+Bfx+w[i]; 
		f[vv]/=rd[vv];
		dfsFA(vv,x);
		f[vv]=Bfv;
	}
}
int st[N],top=0,tot=-1,cr[N][2];
Db dsf[N],dcr[N][2],fx[N][2];
void dfsCIR(int x,int fa){
	vis[x]=1; st[++top]=x; 
	for(Re int i=head[x];i;i=nxt[i]){
		int vv=v[i]; if(vv==fa)continue;
		if(vis[vv]){
		    Ffd=1;
		    while(st[top]!=vv){
		    	int stx=st[top--];
		    	cr[++tot][0]=stx; dcr[tot][0]=dsf[stx]; Fcr[stx]=1;
			}
			cr[++tot][0]=vv; dcr[tot][0]=w[i]; Fcr[vv]=1;
		    return;
		}
		dsf[vv]=w[i];
		dfsCIR(vv,x);
		if(Ffd)return;
	}
	top--;
}
void getF12(int pos,int now){
	int p=pos+1;
	Db Fx=0;
	if(p>tot)p=0; 
	Fx=f[cr[p][now]];
	do{
		Fx+=dcr[p][now];
		p++; if(p>tot)p=0;
		if(p==pos)break;
		int cx=cr[p][now];
		Db Fcx=f[cx]*(rd[cx]-2);
		Fx=(Fx+Fcx)/(rd[cx]-1);
	}while(p!=pos);
    fx[ cr[pos][now] ][now]=Fx;
}

int main(){
	read(n); read(m); Dn=n;
	memset(Fcr,0,sizeof(Fcr));
	memset(vis,0,sizeof(vis));
	For(i,1,m){
		read(x); read(y); read(z);
		add(x,y,z);
	}
	if(m<n){
		dfsDP(1,0); dfsFA(1,0);
		printf("%.05lf",ans);
		return 0;
	}
	dfsCIR(1,0); 
	For(i,0,tot){
		rd[cr[i][0]]-=2;
		dfsDP(cr[i][0],0);
		rd[cr[i][0]]+=2;
	}
    For(i,0,tot){
    	cr[i][1]=cr[tot-i][0];
    	if(i!=tot)dcr[i][1]=dcr[tot-i-1][0];
    	else dcr[i][1]=dcr[tot][0];
	}
 
	For(i,0,tot){
		getF12(i,0); getF12(i,1);
	}
	For(i,0,tot){
		int cx=cr[i][0];
		f[cx]*=(rd[cx]-2);
		f[cx]+=fx[cx][0]+fx[cx][1];
		f[cx]/=rd[cx];
		dfsFA(cx,0);
	}
	printf("%.05lf",ans);
	return 0;
}
```



---

## 作者：SSHhh (赞：5)

#### 题外话

这道题很久之前听教练讲过，当时觉得太麻烦就没写，后来拾起来的时候就发现自己不会了 QwQ  **~~（可能是因为我太菜了吧）~~** ，于是怒肝了两个下午把它弄了出来，中间还出了一次大锅，所以留个博客以作纪念吧

---

### 题面

题面异常简单，就是求一颗基环树上的任意一点往某个方向走到头的路径期望长度。这个一看就是要用某种类似$treeDP$ 的方法处理的（但是我一开始没看出来），所以我们可以先从简单问题入手

---

### 50分——树上dp

我们先考虑没有环的情况，那显然要用树上DP来解决——我们定义两个数组 $up[i]$、$down[i]$ 分别代表从 $i$ 节点向上和向下走到头的期望距离

那么 $down[i]$ 应该是相当好转移的，因为它不牵扯拐弯。做一遍 $dfs$ 然后统计每一个儿子的 $down$ 即可求出 $down[i]$ 了，转移方程用手推一下应该就能出来：
$$down[i]=\frac{\sum_{i->j}(down[j]+len(i,j))}{son[i]}$$
这里 $j$ 是 $i$ 的每一个儿子，$len(i,j)$ 表示 $i$ 到 $j$ 这条边的长度，$son[i]$ 表示 $i$ 的儿子数量

但是 $up[i]$ 就有点难搞，因为这条路有可能往上走了几步又拐到向下，而且你还得处理每一个位置拐弯的情况。这就非常麻烦了     

我们考虑，如果我们处理出了每一个点的 $down$，然后从上往下 $dp$，那么我们这条路的期望会是什么样子的呢？

![](https://cdn.luogu.com.cn/upload/pic/51169.png  )

我们从这幅图上可以很清楚的看到：这个期望一共涉及两种方向，也就是上面的 $2$ 和 $3 $。

这个 $2$ 就相当于是从$i$ 的父亲 f 出发向下不经过 $i$ 的所有路径的期望，可以表示为 $down[f]\times son[f]-down[i]-len(f,i)$

那如果继续向上，就相当于是从 $f$ 向上随便走，其实就是 $up[f]$了。

所以我们就可以总结出一个计算 $up[i]$ 的公式了：
$$up[i]=len(f,i)+\frac{down[f]\times son[f]-down[i]-len(f,i)+up[f]}{deg[f]-1}$$
这里 $deg[f]$ 表示 $f$ 的度数，也就是这个点连出的边数。容易看出， $deg[f]-1=(son[f] +1)-1=son[f]$。所以直接把分母改写成 $son[f]$ 即可。

最后怎么统计答案呢？参考一下上面那幅图就可以推出：
$$ans=\sum \frac{up[i]+down[i]*son[i]}{son[i]+1}$$
那么树上的问题就解决了

**~~（对了我这里少说了一句，其实这样写在洛谷上是可以混过两个基环点的哈哈哈哈）~~**

![](https://cdn.luogu.com.cn/upload/pic/51171.png )

---

### 100分——基环树特殊处理

既然环上的点不多，只有20个，我们就可以轻松 $dfs$ 找出这些点并把它们用一个类似链表的方式保存起来（就是保存每一个点的下一位和上一位）

然后我们会发现，这个环貌似对环外的 $up$ 和 $down$ 没有任何影响，所以我们就可以对于每一棵小树 $dfs$ 求出 $down$ 

那么根据刚才的经验，我们就可以通过这个 $down$ 来推算每个点的 $up$了

我们先来说环上的 $up$ 值怎么求：

我们举个例子，如果环上的点是 $1,2,3,4,5$，我们钦定方向为顺时针，那么对于 $1$ 来说走到 $2$ 的可能性就是 $1$。从 $2$ 走到 $3$ 的可能性就是 $\frac{1}{son[2]+1}$，从 $3$ 走到 $4$ 的可能性就是 $\frac{1}{son[3]+1}$ 。。。以此类推

那么我们就可以顺时针逆时针都跑一遍，然后统计答案时除以 2 即可。

表达式不太好看，所以这里就给出一个顺时针的：

$$up[i]=\sum_{j!=i}^{j=nex[i]} (\prod_{k!=j}^{k=nex[i]} \frac{1}{son[k]+1}\times\frac{len(last[j],j)+down[j]*son[j]}{son[j]+1})$$

逆时针同理即可。

如果觉得没看懂表达式的话，这里上一段代码和一张图帮助各位理解：

```cpp
double now=1;
for(int j=nx[x];j!=x;j=nx[j])
{
    if(/**/) //这里其实还有一个特判，请自行推算
        up[x]+=now*(h[j]+down[j]*son[j]/(son[j]+1));
	else /**/;
	now=now/(son[j]+1);
}
```

![](https://cdn.luogu.com.cn/upload/pic/51190.png )

这里 $now$ 就是上面的  $\prod \frac{1}{son[k]+1}$，而 $h[i]$ 就是一个预处理的 $len(last[j],j)$。上面所说的特判其实就是从环首走了一圈又回来的状况，请各位自行推算，这里就不再赘述了

还有一个小问题就是如何处理环上各点的儿子的 $up$ 。因为这些点的父节点左右有两条连边，所以这些店需要单独拿出来计算 $up[i]$ ：
$$up[i]=len(f,i)+\frac{down[f]\times son[f]-down[i]-len(f,i)+up[f]\times2}{deg[f]-1}$$
注意一下这里的 $deg[f]-1\ne son[f]$ 

统计答案的时候与之前的式子相似，树上的按照树上的统计，环上的就是上面加一个 $up[i]$ ，下面加 $1$ 就行了，也就是下面的这个式子：
$$ans=\sum \frac{up[i]\times 2+down[i]*son[i]}{son[i]+2}$$

---

还有就是这几个期望计算的时候分母都不能是 $0$ ，所以需要手动加几个特判才行。

好了多的不说了,具体细节请看代码吧：

---

### code

```cpp
#include<vector>
#include<string.h>
#include<iostream>
#define N 100005
using namespace std;
int n,m,flag,nexflag,vis[N],son[N],fa[N],nx[N],h[N],nh[N],tag[N];
double ans,down[N],up[N];
struct nod{
	int to,val;
};
vector<nod> edge[N];
vector<int> lay[N],loop;
void addedge(int u,int v,int w)
{
	edge[u].push_back((nod){v,w});
	edge[v].push_back((nod){u,w});
}
void dfs1(int x)
{
	down[x]=0;
	for(int i=0;i<edge[x].size();i++)
	{
		nod nex=edge[x][i];
		if(!vis[nex.to])
		{
			vis[nex.to]=1;
			fa[nex.to]=x;
			h[nex.to]=nex.val;
			dfs1(nex.to);
			down[x]+=down[nex.to]+nex.val;
			son[x]++;
		}
	}
	if(son[x]>0)
		down[x]/=son[x];
}
void dfs2(int x)
{
	int f=fa[x];
	if(son[f]>1)
	{
		if(!tag[x])
			up[x]=(double)(down[f]*son[f]-down[x]-h[x]+up[f])/(edge[f].size()-1)+h[x];
		else	up[x]=(double)(down[f]*son[f]-down[x]-h[x]+up[f]*2)/(edge[f].size()-1)+h[x];
	}
	else	up[x]=up[f]+h[x];
	for(int i=0;i<edge[x].size();i++)
	{
		nod nex=edge[x][i];
		if(!vis[nex.to])
		{
			vis[nex.to]=1;
			dfs2(nex.to);
		}
	}
}
void dfs3(int x,int pre)
{
	vis[x]=1;
	if(flag!=0)
		return;
	for(int i=0;i<edge[x].size();i++)
	{
		nod nex=edge[x][i];
		if(nex.to!=pre)
		{
			if(vis[nex.to])
			{
				if(flag!=0)	return;
				flag=x;

				nexflag=nex.to;
				fa[nex.to]=x;
				nx[x]=nex.to;
				h[nex.to]=nh[x]=nex.val;
				return;
			}
			if(flag!=0)	return;
			fa[nex.to]=x;
			nx[x]=nex.to;
			h[nex.to]=nh[x]=nex.val;
			dfs3(nex.to,x);
			if(flag!=0)	return;
		}
	}
}
void cl_vis()
{
	memset(vis,0,sizeof(vis));
	for(int i=0;i<loop.size();i++)
		vis[loop[i]]=1;
}
int main()
{
	int u,v,w;
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>u>>v>>w;
		addedge(u,v,w);
	}
	if(m==n-1)
	{
		vis[1]=1;
		dfs1(1);
		memset(vis,0,sizeof(vis));
		vis[1]=1;
		dfs2(1);
		for(int i=1;i<=n;i++)
			ans+=(double)(down[i]*son[i]+up[i])/(son[i]+(fa[i]!=0?1:0));
		printf("%.5f",ans/n);
	}
	else
	{
		dfs3(1,0);
		for(int i=flag;i!=nexflag;i=fa[i])
			loop.push_back(i),vis[i]=1;
		loop.push_back(nexflag);vis[nexflag]=1;
		cl_vis();
		int sz=loop.size();
		for(int i=0;i<sz;i++)
			dfs1(loop[i]);
		for(int i=sz-1;i>=0;i--)
		{
			int x=loop[i];
			double now=1;
			up[x]=0;
			for(int j=nx[x];j!=x;j=nx[j])
			{
				if(nx[j]!=x)
					up[x]+=now*(h[j]+down[j]*son[j]/(son[j]+1));
				else	up[x]+=now*(h[j]+down[j]);
				now=now/(son[j]+1);
			}
			now=1;
			for(int j=fa[x];j!=x;j=fa[j])
			{
				if(fa[j]!=x)
					up[x]+=now*(nh[j]+down[j]*son[j]/(son[j]+1));
				else	up[x]+=now*(nh[j]+down[j]);
				now=now/(son[j]+1);
			}
			up[x]/=2;
		}
		cl_vis();
		for(int i=0;i<sz;i++)
			for(int j=0;j<edge[loop[i]].size();j++)
			{
				nod nex=edge[loop[i]][j];
				if(!vis[nex.to])
					vis[nex.to]=tag[nex.to]=1,dfs2(nex.to);
			}	
		cl_vis();
		for(int i=1;i<=n;i++)
		{
			if(!vis[i])
				ans+=(double)(down[i]*son[i]+up[i])/(son[i]+1);
			else	ans+=(double)(down[i]*son[i]+up[i]*2)/(son[i]+2);
		}
		printf("%.5f",ans/n);
	}
	return 0;
}
```

---

## 作者：木xx木大 (赞：4)

[P2081 [NOI2012] 迷失游乐园](https://www.luogu.com.cn/problem/P2081) 

感谢 panyf 巨佬给我讲这题，在这里先 orz 为敬！

先考虑树上怎么做。设 $f_i$ 表示以 $i$ 为出发点时的答案，$g_i$ 表示以 $i$ 为出发点且仅向子树内走的答案。则有
$$
g_u=\frac{\sum (g_v+w(u,v))}{|son_u|}\\f_v=\frac{g_v\times|son_v|+w(u,v)+\frac{f_u\times deg_u-g_v-w(u,v)}{|son_u|}}{deg_v}\\ans=\sum f_i
$$
对于基环树，先不考虑环，算出来每个子树的 $g$，再考虑环上每个点的 $f$ 怎么算。由于环上不方便换根 dp ，且环上节点个数很少，可以枚举环上的每个点为起点，顺时针逆时针各 dp 一遍，转移方程类似求 $g$ 的方程。再换根求出子树内的 $f$ 。设 $k$ 为环上节点个数，复杂度 $O(n+k^2)$
```cpp
#include<bits/stdc++.h>
#define inl inline
using namespace std;
typedef long long ll;
namespace FGF
{
	int n,m;
	const int N=1e5+5;
	struct edg{
		int to,nxt,w;
	}e[N<<1];
	int cnt=1,head[N],du[N],cir[N],nw[N],nxt[N],pre[N],pw[N],tot;
	bool vis[N],is[N];
	double f[N],g[N],ans;
	inl void add(int u,int v,int w)
	{
		cnt++;
		e[cnt].to=v;
		e[cnt].nxt=head[u];
		head[u]=cnt;
		e[cnt].w=w,du[v]++;
	} 
	void dfs1(int u,int fa)
	{
		for(int i=head[u];i;i=e[i].nxt)	
		{
			int v=e[i].to;
			if(v==fa||is[v])continue;
			dfs1(v,u);
			f[u]+=f[v]+e[i].w;
		}
		f[u]/=max(1,fa?du[u]-1:(n==m? du[u]-2:du[u]));
	}
	void dfs2(int u,int fa)
	{
		for(int i=head[u];i;i=e[i].nxt)
		{
			int v=e[i].to;
			if(v==fa||is[v])continue;
			f[v]=(f[v]*(du[v]-1)+e[i].w+(f[u]*du[u]-e[i].w-f[v])/(max(1,du[u]-1)))/du[v];
			dfs2(v,u);
		}
	}	
	bool dfscir(int u,int f)
	{
		if(vis[u]){is[u]=1,cir[++tot]=u;return 1;}
		vis[u]=1;
		for(int i=head[u];i;i=e[i].nxt)
		{
			int v=e[i].to;
			if(v==f)continue;
			if(dfscir(v,u))
			{	
				nxt[u]=i,pre[v]=i^1;
				if(cir[1]==u)return 0;
				is[u]=1,cir[++tot]=u;
				return 1;
			}
		}
		return 0;
	}
	double dfs3(int u,int fa)
	{
		return e[pre[u]].to==fa? f[u]:(f[u]*(du[u]-2)+dfs3(e[pre[u]].to,fa)+e[pre[u]].w)/(du[u]-1);
	}
	double dfs4(int u,int fa)
	{
		return e[nxt[u]].to==fa? f[u]:(f[u]*(du[u]-2)+dfs4(e[nxt[u]].to,fa)+e[nxt[u]].w)/(du[u]-1);
	}
	void work()
	{
		scanf("%d%d",&n,&m);
		for(int i=1,u,v,w;i<=m;i++)
			scanf("%d%d%d",&u,&v,&w),add(u,v,w),add(v,u,w);
		if(n>m)dfs1(1,0),dfs2(1,0);
		else
		{
			dfscir(1,0);
			for(int i=1;i<=tot;i++)
				dfs1(cir[i],0);
			for(int i=1,u;i<=tot;i++)
				u=cir[i],g[i]=(f[u]*(du[u]-2)+dfs3(e[pre[u]].to,u)+dfs4(e[nxt[u]].to,u)+e[pre[u]].w+e[nxt[u]].w)/du[u];
			for(int i=1;i<=tot;i++)	
				f[cir[i]]=g[i],dfs2(cir[i],0);
		}
		for(int i=1;i<=n;i++)
			ans+=f[i];
		printf("%.5f",ans/n);
	}
}
int main()
{
	FGF::work();
	return 0;
}
```


---

## 作者：xtx1092515503 (赞：3)

发现这张图要么是一棵树，要么是一棵基环树。

我们先考虑树的做法。设一个点 $i$ 的度数是 $deg_i$。

考虑二次扫描与换根法。我们设$f_i$表示以 $1$ 为根时，以 $i$ 为根的子树中一条从 $i$ 出发的依照题面描述的路径的期望长度。

这种定义自然也能做。但是，为了方便（也是为了与接下来基环树部分的讲解一致），我们统一将 $f_i$ 乘以（以 $1$ 为根时 $i$ 节点的儿子数），即 $deg_i-[i\neq1]$。

于是，我们现在有转移方程：

$$f_x=\sum\limits_{y\in son_x}\dfrac{f_y}{\max(1,deg_y-1)}+e(x,y)$$

其中，$e(x,y)$ 是连接 $x,y$ 的边的长度。而那个除数与 $1$ 取 $\max$，是因为如果不这么干在 $y$ 是叶子时就会出现除数为零，尽管此时 $f_y$ 也等于 $0$。

则我们经历过一遍DP后，$f_1$ 的值已经是期望长度了（只不过要除以一个 $deg_1$）。我们现在考虑二次扫描更新所有的 $f_y$。

我们有

$$f_y'=f_y+\dfrac{f_x-\Big(\dfrac{f_y}{\max(1,deg_y-1)}+e(x,y)\Big)}{\max(1,deg_x-1)}+e(x,y)$$

其中，最外面的那个大分数的分子，是删去 $y$ 影响后的 $f_x$；而此时以 $y$ 为根时，$x$有 $deg_x-1$ 个儿子，故也要除掉才能得到真实的期望长度。最终得到的 $f_y'$，即为真实的 $f_y$。

最终答案为

$$\dfrac{\sum\limits_{i=1}^n\dfrac{f_i}{deg_i}}{n}$$

其中 $\sum$ 内的是每个位置的期望长度；因为不确定起始位置，故最终要除以 $n$。

时间复杂度 $O(n)$。

此部分代码：

```cpp
namespace SUB1{
	double f[100100],res;
	void dfs1(int x,int fa){
		for(int i=head[x];i!=-1;i=edge[i].next)if(edge[i].to!=fa)dfs1(edge[i].to,x),f[x]+=f[edge[i].to]/max(1,deg[edge[i].to]-1)+edge[i].val;
	}
	void dfs2(int x,int fa){
		for(int i=head[x],y;i!=-1;i=edge[i].next)if((y=edge[i].to)!=fa)f[y]+=(f[x]-f[y]/max(1,deg[y]-1)-edge[i].val)/max(1,deg[x]-1)+edge[i].val,dfs2(y,x);
	}
	void solve(){
		dfs1(1,0);
		dfs2(1,0);
		for(int i=1;i<=n;i++)res+=f[i]/deg[i];
		printf("%lf\n",res/n);
		exit(0);
	}
}
```

接下来我们再考虑基环树的情形。

我们考虑找出在环上的节点。然后，以环上每个节点为根，在它所对应的子树内，仍然一次搜索DP出 $f_i$。

接下来我们考虑对于环上的节点，求出它真实的答案。

我们设当前考虑的是节点 $i$。此时，我们发现以它为起点的路径，只有两种情况：

1. 向 $i$ 节点方向的子树中延伸。此时即为 $f_i$。

2. 向 $i$ 节点的子树外延伸。此时，它可以经过环上与 $i$ 节点相邻的两条边中任意一条边，且最多只能经过一条边。故我们可以分别断开两条边中的某一条，并求出此时的结果，最终加在一起即可。

我们设 $h_j$ 表示断开其中一条边后，以 $i$ 为根时，以 $j$ 为根的子树中一条从 $j$ 出发的依照题面描述的路径的期望长度。显然，对于非环上的点，我们有 $h_j=f_j$；故我们只需考虑环上节点即可。

则我们对于环上节点 $x$，有

$$h_x=f_x+\dfrac{h_y}{\max(1,deg_y-1)}+e(x,y)$$

其中，$y$ 是 $x$ 节点在环上与其相邻的点。

需要注意的是，当这个 DP 在环上绕了一圈后，是不能重新回到 $i$ 点的——毕竟这条边已经断掉了嘛。所以，我们有两个特例：

1. 当 $x$ 的下一个节点是 $i$ 时，我们直接有 $h_x=f_x$；

2. 当 $x$ 的下一个节点就是（1）中所述节点时，因为它不能走向 $i$，所以我们有

$$h_x=f_x+\dfrac{h_y}{\max(1,deg_y-2)}+e(x,y)$$

其它情形的 $h_x$ 即为前文所述递推式求得。

我们令 $g_x$ 表示一个节点的最终答案，则当一整圈全部DP完后，我们就有 $g_i=h_i$。（注意这里的 $h_i$ 应该包括分别断开两条边时的结果）

我们分别以环上每个节点为 $i$，都能得出它的 $g_i$；接着，我们就按照树的情形时的做法，二次扫描一下即可得出全部的 $g_x$。

时间复杂度 $O(nk)$，其中 $k$ 是环的大小。

此部分代码：

```cpp
namespace SUB2{
	double f[100100],g[100100],h[100100],res;
	int fa[100100],sz;
	bool on[100100];
	void dfscir(int x){
		for(int i=head[x];i!=-1;i=edge[i].next){
			if(edge[i].to==fa[x])continue;
			if(!fa[edge[i].to])fa[edge[i].to]=x,dfscir(edge[i].to);
			else{
				int y=x;
				while(y!=edge[i].to)on[y]=true,y=fa[y],sz++;
				on[y]=true,sz++;
			}
			if(sz)break;
		}
	}
	void dfsord(int x){
		for(int i=head[x];i!=-1;i=edge[i].next)if(!on[edge[i].to]&&edge[i].to!=fa[x])fa[edge[i].to]=x,dfsord(edge[i].to);
	}
	void dfs1(int x){
		for(int i=head[x];i!=-1;i=edge[i].next)if(!on[edge[i].to]&&edge[i].to!=fa[x])dfs1(edge[i].to),f[x]+=f[edge[i].to]/max(1,deg[edge[i].to]-1)+edge[i].val;
	}
	void dfsg(int x,int fr,int rem){
		h[x]=f[x];
		if(rem==1)return;
		for(int i=head[x];i!=-1;i=edge[i].next)if(on[edge[i].to]&&edge[i].to!=fr){
			dfsg(edge[i].to,x,rem-1);
			h[x]+=h[edge[i].to]/max(1,deg[edge[i].to]-1-(rem==2))+edge[i].val;
		}
	}
	void dfss(int x){
		for(int i=head[x];i!=-1;i=edge[i].next)if(!on[edge[i].to]&&edge[i].to!=fa[x]){
			g[edge[i].to]=(g[x]-f[edge[i].to]/max(1,deg[edge[i].to]-1)-edge[i].val)/max(1,deg[x]-1)+edge[i].val;
			g[edge[i].to]+=f[edge[i].to];
			dfss(edge[i].to);
		}
	}
	void solve(){
		fa[1]=-1,dfscir(1);
		for(int i=1;i<=n;i++)if(on[i])fa[i]=0,dfsord(i);
//		for(int i=1;i<=n;i++)printf("%d ",fa[i]);puts("");
		for(int i=1;i<=n;i++)if(on[i])dfs1(i);
//		for(int i=1;i<=n;i++)printf("%lf\n",f[i]);puts("");
		for(int i=1;i<=n;i++)if(on[i])dfsg(i,0,sz),g[i]=h[i];
		for(int i=1;i<=n;i++)if(on[i])dfss(i);
		for(int i=1;i<=n;i++)res+=g[i]/deg[i];
		printf("%lf\n",res/n);
	}
}
```


---

## 作者：panjoel (赞：3)

假如从树根出发，那一定只能往子树走，因为是树，所以没有回头路

令f[i]:以i为根的子树里，从i出发，期望路程

g[i]:整棵树以i为根，从i出发，期望路程

f[i]很好统计，然后利用f[i]统计g[i]，方法不难，换根而已



如果有环又怎么做？题中指明，环最多一个，大小不超过20，这个环很小

可以注意到，环删掉任意一条边，都剩下一棵树，那就往这里转化

现假设让环上一点作为树根，作图
![](https://img-blog.csdn.net/20161222190057473?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ1JaYnVsYWJ1bGE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
从x出发，如果走向别的子树(三角形代替)，那么环上决策无影响

如果走了红边，蓝边一定不能走，如果走了蓝边，红边一定不能走

枚举走红边或者蓝边，就能转换成树上的情况了，影响的f值显然只有与该环有关的那个子树

而除了那个子树，其他子树(三角形)的g显然就都可以统计了

那这样O(n*环的大小)就能解决本题

## **AC题解**
```cpp
#include<iostream>
#include<cstring>
#include<vector>
#include<queue>
#include<algorithm>
#include<cmath>
#include<cstdio>
#include<bitset>
using namespace std;

const int maxn = 1E5 + 10;
typedef double DB;

struct E{
	int to,w; E(){}
	E(int to,int w): to(to),w(w){}
};

int n,m,cnt,tp,tot,vis[maxn],s[maxn],stk[maxn];
bool bo[maxn];
DB Ans,f[maxn],g[maxn];

vector <E> v[maxn];

void Calc_f(int x)
{
	int son = 0; f[x] = 0.000;
	for (int i = 0; i < v[x].size(); i++)
	{
		E e = v[x][i];
		if (vis[e.to] == cnt) continue;
		vis[e.to] = cnt; Calc_f(e.to); ++son;
		f[x] += (DB)(e.w) + f[e.to];
	}
	if (son) f[x] /= (DB)(son);
}

void Calc_g(int x,DB t)
{
	int son = v[x].size(); DB sum = 0.000;
	for (int i = 0; i < v[x].size(); i++)
	{
		E e = v[x][i];
		if (vis[e.to] == cnt) continue;
		sum += f[e.to] + (DB)(e.w);
	}
	g[x] = (sum + t) / (DB)(son);
	for (int i = 0; i < v[x].size(); i++)
	{
		E e = v[x][i];
		if (vis[e.to] == cnt) continue;
		vis[e.to] = cnt;
		DB res = sum - f[e.to] - (DB)(e.w);
		DB Nex = (son > 1)?(t + res) / (DB)(son - 1) + (DB)(e.w):(DB)(e.w);
		Calc_g(e.to,Nex);
	}
}

bool Dfs(int x,int fa)
{
	stk[++tp] = x;
	for (int i = 0; i < v[x].size(); i++)
	{
		E e = v[x][i];
		if (e.to == fa) continue;
		if (vis[e.to] == cnt)
		{
			for (;;)
			{
				s[++tot] = stk[tp]; bo[s[tot]] = 1;
				if (stk[tp--] == e.to) return 1;
			}
		}
		vis[e.to] = cnt; 
		if (Dfs(e.to,x)) return 1;
	}
	--tp; return 0;
}

void Solve(int x)
{
	int son = v[x].size(); DB sum = 0.000; vis[x] = ++cnt;
	for (int i = 0; i < v[x].size(); i++)
	{
		E e = v[x][i];
		if (bo[e.to]) vis[x] = ++cnt; vis[e.to] = cnt;
		Calc_f(e.to); sum += ((DB)(e.w) + f[e.to]);
	}
	vis[x] = ++cnt; g[x] = sum / (DB)(son);
	for (int i = 0; i < v[x].size(); i++)
	{
		E e = v[x][i];
		if (bo[e.to]) continue;
		vis[e.to] = cnt;
		DB res = sum - f[e.to] - (DB)(e.w);
		DB Nex = res / (DB)(son - 1) + (DB)(e.w);
		Calc_g(e.to,Nex);
	}
}

int getint()
{
	char ch = getchar(); int ret = 0;
	while (ch < '0' || '9' < ch) ch = getchar();
	while ('0' <= ch && ch <= '9')
		ret = ret*10 + ch - '0',ch = getchar();
	return ret;
}

int main()
{
	#ifdef DMC
		freopen("DMC.txt","r",stdin);
	#endif
	
	n = getint(); m = getint();
	for (int i = 1; i <= m; i++)
	{
		int x = getint(),y,w;
		y = getint(); w = getint();
		v[x].push_back(E(y,w));
		v[y].push_back(E(x,w));
	}
	if (n == m)
	{
		vis[1] = ++cnt; Dfs(1,0);
		for (int i = 1; i <= tot; i++) 
			Solve(s[i]);
	}
	else
	{
		vis[1] = ++cnt; Calc_f(1); 
		vis[1] = ++cnt; Calc_g(1,0);
	}
	for (int i = 1; i <= n; i++) Ans += g[i];
	printf("%.5f",Ans / (DB)(n));
	return 0;
}
```



---

## 作者：ivyjiao (赞：2)

### 题意简述：

给出一棵树或基环树，有边权，任选一个点出发，每个点只能走一次，直到走到不能走为止，求期望路径长度。

### $\text{subtask}~1$，测试点 $1\sim 5$：

我们约定：

1. 此树以 $1$ 为根。
2. $s_u$ 为 $u$ 的儿子数量。
3. $w_{u,v}$ 为边 $(u,v)$ 的长度。
4. $down_u$ 为从 $u$ 出发，第一步向任意儿子走，期望的路径长度。
5. $up_u$ 为从 $u$ 出发，第一步向父亲走，期望的路径长度。
5. $ans_u$ 为从 $u$ 出发，期望的路径长度。

由于我是使用 vector 存图的，所以 $s_u=G_u$ 的大小 $-1$，$w_{u,v}$ 能直接得到。

对于 $down_u$，因为每个点只能走一次，所以走到儿子之后一定不会再走回父亲 $u$。所以：

$$down_u=\dfrac{\sum_{v~\text{is a son of}~u} (w_{u,v}+down_v)}{son_u}$$

对于 $up_u$，我们先走到 $fa_u$，长度为 $w_{fa,u}$，接下来我们有两种可能：继续向父亲走或者向兄弟节点走，由于不能走回来，所以期望为：

$$up_u=w_{fa,u}+\dfrac{up_{fa}+down_{fa}\times son_{fa}-down_u-w
_{fa,u}}{son_{fa}+1-1}$$

简化得：

$$up_u=w_{fa,u}+\dfrac{up_{fa}+down_{fa}\times son_{fa}-down_u-w
_{fa,u}}{son_{fa}}$$

容易发现这个东西需要用到 $w_{fa,u}$，很不方便，于是我们直接从 $u$ 更新每个儿子 $v$，得：

$$up_v=w_{u,v}+\dfrac{up_u+down_u\times son_u-down_v-w
_{u,v}}{son_u}$$

特殊情况为没有父亲的根节点 $1$，$up_1=0$；当 $u=1$ 时，$up_v=w_{u,v}$。

对于 $ans_u$，我们要特判没有父亲的根节点 $1$，所以得：

$$ans_u=\begin{cases}
  down_u & u=1 \\
  \dfrac{up_u+down_u\times son_u}{son_u+1} &u\neq 1
\end{cases}$$

其实对于 $ans_u$，两种情况是可以合并的，但是对于 $up_u$ 不行，因为会出现除以 $0$ 的情况从而过不去样例 $1$，但是能过所有数据。

最后的答案就是：

$$rans=\dfrac{\sum_{i=1}^n ans_i}{n}$$

时间复杂度 $O(n)$。

然而如果只有这些，那这题也就是绿题，所以难点一定在后面。

### $\text{subtask}~2$，测试点 $6\sim 10$：

一个经典的 trick：基环树处理其它节点后单独处理环上的点。

对于此题，我们把每个环上的节点都看作是一个根，有且只有一些（可能没有）环外节点做它的子树。

我们先把环上的点记录下来，然后以每个环上节点 $u$ 为根求一遍它和子树的 $down$。

那么我们对于环上的每个节点 $u$ 记录其与左右的环上节点的距离 $dis_{u,0},dis_{u,1}$。对于环上的每个节点，显然可以顺时针或逆时针走（这两个本质相同），概率各为 $P=\dfrac 1 2$，由于 $u$ 是其子树的根，那么环上左右两个节点都是它的父亲，所以更改的是 $up_u$。

如果是顺时针就一直往右走直到走回来，如果是逆时针就一直往左走直到走回来。按顺序走到 $v$ 时，这一步长度为 $dis_{j,0/1}$。由于不能往回走，也不能走回 $u$。所以得到：

$$up_u=\begin{cases}
  up_u+P\times(dis_{v,0/1}+down_v) & nxt=u \\
  up_u+P\times(dis_{v,0/1}+\dfrac{down_v\times son_v}{son_v+1}) & nxt\neq u
\end{cases}$$

因为我们还要在下个走到的节点加上走在环上对 $up_u$ 的贡献，所以除以的是 $son_v+1$ 不是 $son$。

其中 $nxt$ 为你下一个要走到的点，$son_v+1$ 意义为 $son_v+2-1$（$2$ 是父亲个数）。

继续走在环上的概率变为 $P=\dfrac{P}{son_v+1}$。

然后对于每个环上根节点的子树，求一遍子树的 $up$。由于父亲不只有一个了，所以要对原式进行一些修改（$f_u$ 为 $u$ 的父亲个数）：

$$down_u=\dfrac{\sum_{v~\text{is a son of}~u} (w_{u,v}+down_v)}{son_u}$$

好吧这个不用改。

$$up_v=w_{u,v}+\dfrac{up_u\times f_u+down_u\times son_u-down_v-w
_{u,v}}{son_u+f_u-1}$$

$$ans_u=\dfrac{up_u\times f_u+down_u\times son_u}{son_u+f_u}$$

$$rans=\dfrac{\sum_{i=1}^n ans_i}{n}$$

时间复杂度 $O(m^2+n)$，$m$ 为环上节点数。

代码：

```cpp
#include<bits/stdc++.h>
#define PII pair<int,int>
#define fi first
#define se second
using namespace std;
const int N=1e6+1;
int n,m,u,v,w,f[N],dfn[N],p[N],dis[N][2],sum,pos;
double down[N],up[N],ans[N],rans;
bool vis[N],flag;
vector<PII>G[N];
void get1(int u,int fa){
    for(int i=0;i<G[u].size();i++){
        int v=G[u][i].se,w=G[u][i].fi;
        if(v==fa||vis[v]) continue;
        if(!f[v]) f[v]=1;
        get1(v,u);
        down[u]+=down[v]+w;
    }
    if(G[u].size()-f[u]) down[u]/=(G[u].size()-f[u]);
}
void get2(int u,int fa){
    for(int i=0;i<G[u].size();i++){
        int v=G[u][i].se,w=G[u][i].fi;
        if(v==fa||vis[v]) continue;
        if(G[u].size()-1) up[v]=w+(up[u]*f[u]+down[u]*(G[u].size()-f[u])-down[v]-w)/(G[u].size()-1);
        else up[v]=w;
        get2(v,u);
    }
    ans[u]=(up[u]*f[u]+down[u]*(G[u].size()-f[u]))/G[u].size();
}
void dfs1(int u,int fa){
	vis[u]=1;
	for(int i=0;i<G[u].size();i++){
        int v=G[u][i].se;
        if(v==fa) continue;
        if(vis[v]){
        	pos=v;
        	return;
        }
        dfs1(v,u);
        if(pos){
        	if(flag) vis[u]=0;
	        if(pos==u) flag=1;
        	return;
        }
	}
	vis[u]=0;
}
void dfs2(int u,int fa){
	dfn[u]=++sum;
	p[sum]=u;
	f[u]=2;
	for(int i=0;i<G[u].size();i++){
        int v=G[u][i].se,w=G[u][i].fi;
        if(v!=fa&&vis[v]){
			if(!dfn[v]) dfs2(v,u);
			dis[dfn[u]][1]=dis[dfn[v]][0]=w;
			break;
        }
	}
}
int nxt(int x){
	return x==sum? 1:x+1;
}
int lst(int x){
	return x==1? sum:x-1;
}
signed main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin>>u>>v>>w;
        G[u].push_back({w,v});
        G[v].push_back({w,u});
    }
    if(m==n-1){
	    get1(1,0);
	    get2(1,0);
    }
    else{
    	dfs1(1,0);
    	dfs2(pos,0);
    	for(int i=1;i<=sum;i++) get1(p[i],0);
    	for(int i=1;i<=sum;i++){
			int x=p[i];
			double P=0.5;
			for(int j=nxt(i);j!=i;j=nxt(j)){
				int y=p[j];
				if(nxt(j)==i) up[x]+=P*(dis[j][0]+down[y]);
				else up[x]+=P*(dis[j][0]+down[y]*(G[y].size()-2)/(G[y].size()-1));
				P/=(G[y].size()-1);
			}
			P=0.5;
			for(int j=lst(i);j!=i;j=lst(j)){
				int y=p[j];
				if(lst(j)==i) up[x]+=P*(dis[j][1]+down[y]);
				else up[x]+=P*(dis[j][1]+down[y]*(G[y].size()-2)/(G[y].size()-1));
				P/=(G[y].size()-1);
			}
    	}
    	for(int i=1;i<=sum;i++) get2(p[i],0);
    }
    for(int i=1;i<=n;i++) rans+=ans[i];
    printf("%.5f",rans/n);
}
```

---

## 作者：yyazzy (赞：2)

# [NOI2012] 迷失游乐园

**题意就是给你一颗树或者基环树，要求随机选择一条路径的期望长度，同时要求路径终点所连的所有点都已被选择。**

## Sub 1-5

我们考虑树怎么做，我们很容易想到一个 $O(n^2)$ 的暴力 dp，即枚举一个点，以他为根，$dp(x)$ 表示 $x$ 子树内贡献，则转移式如下：
$$
dp(x)=\sum\limits_{y\in son(x)}{dp(y)\over deg(x)-(x!=root)}
$$
实际实现时，要考虑到分母为 $0$ 的情况，要不然会获得 `nan` 的好输出。

此部分代码如下：

```c++
void dfs(int x,int fa)
{
	for(int i=0;i<v[x].size();i++)
	{
		int y=v[x][i].first;
		double val=v[x][i].second;
		if(y==fa)continue;
		dfs(y,x); 
		dp[x]+=(dp[y]+val);
	}
	if(x==1) dp[x]*=(1.0/(double)(v[x].size()));
	else {	
	    if(v[x].size()!=1) dp[x]*=(1.0/(double)(v[x].size()-1));
	}
}
```

显然，这个枚举根的过程可以用换根来优化掉，我们只需要将 $dp(x)$ 减去 $y$ 作为其子树的贡献，在用 $dp(x)$ 去更新 $dp(y)$ 即可，复杂度为 $O(n)$ 代码如下:

```c++
void Dp(int x,int fa)
{
	double tmpx,tmpy;
	for(auto [y,val]:v[x])
	{
		if(y==fa||vis[y])continue;
		tmpx=dp[x],tmpy=dp[y];
		dp[x]-=(dp[y]+val)/deg[x];
		if(deg[x]>1)dp[x]=dp[x]*deg[x]/(deg[x]-1);
		else dp[x]=0;
		dp[y]=dp[y]*(deg[y]-1)/deg[y];
		dp[y]+=(dp[x]+val)/deg[y];
		ans+=1.0/n*dp[y];
		Dp(y,x);
		dp[x]=tmpx,dp[y]=tmpy;
	}
}
```



至此，就可以获得 $50$ 分的好成绩了。



## Sub 6-10

树我们已经会了，那我们考虑基环树怎么做，同时题目要求也说明了**环的大小 $\le20$**，我们可以从这里入手，我们考虑将图变成这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/o0jsdmpt.png)
我们发现图变成了，中间一个环，环上每个点作为根，连了一棵树出来，这样的话，我们只需要求出环上每个点作为全局根的 $dp$ 值就可以向他的子树内换根了。

现在我们考虑如何求出环上一点的全局 $dp$ 值，从环上点出发的一条合法路径一定形似这个点走到环上另一点的子树内，或者仅仅只有一个环的时候，就是走完一整个环结束。

那环的大小又这么小，我们考虑枚举起点，并顺时针枚举终点，逆时针同理，我们只需再做一遍即可，用终点的 $dp$ 值更新起点的 $dp$ 值，再从起点向子树内换根就可以。

具体实现的话就是：

我们维护一个概率 $p$，和距离 $dis$，$p$ 的更新就是到每个点我们更新 $p$ 为 $p\times (deg(j)-1)$ 因为来时路已经不能走了，所以要减 $1$，当然结算每个点的贡献时要考虑一个额外的概率，就是我们走进这个点的子树内的概率，即为 $deg(j)-2\over deg(j)-1$，还有一个细节是，在走到最后一个环上这个点的时候，我们就不用考虑上面说的这个额外概率了，因为此时只能走进这个点的子树内了。

[代码实现](https://www.luogu.com.cn/paste/wbbs9zd8)

---

## 作者：Piwry (赞：2)

竟然在 loj 一次就跑到了 [rk1](https://loj.ac/problem/2673/statistics/fastest) qwq

## 解析

先考虑这个问题在树上怎么做

### 树的做法

我们先假设一个点为根（大门），于是可以设出状态，$dp(u)$ 表示从 $u$ 出发，仅向子树走的期望路径长

由期望的线性可得出转移方程：$dp(u)=\frac {\sum\limits_{v\in S_u}(dp(v)+w(u, v))} {|S_u|}$ 或 $dp(u)=0$ 仅当 $u$ 为叶子时，其中 $S_u$ 是 $u$ 的儿子结点集合，$w(u, v)$ 是一条边的边权

这个 dp 式子比较简单，于是用直接换根 dp（up down）就可以得出以所有结点为根的期望路径长。我们再 $O(n)$ 统计所有结点以它为根的 dp 值，就得到了题目要求的答案

&nbsp;

接着再考虑在基环树上怎么做

### 基环树的做法

我们先将环上的树都拎出来做一次第一次 dp（暂时不做第二次的换根）。如图，红色结点就是每次 dp 的树的根

![circle](https://cdn.luogu.com.cn/upload/image_hosting/qj6bnra5.png)

目前我们求出的根的答案都是 “不完全” 的，因为还没考虑走环的路径。而且如果想对这些树做第二次 dp，我们其实只需要得到根（红色结点）的答案。因此我们先考虑求出环上结点的答案

由于环上的结点较少，且在环上换根不太可做（每次换根都要修改所有点的权值，即使用数据结构维护也不太可做（可能要维护一个 “高度” 为环上结点个数的繁分数）），我们可以暴力枚举环上的结点作为起点并 dp

实际做法和做树的方法是差不多的。但注意这时有可能遍历到已经走过的结点（毕竟是个环），这时不能接着往这个结点走

如果在 dp 时深入上述的一棵树，我们已经算出的 dp 值是可以直接拿来用的；但环上结点不行，因为以不同的结点为根，形成的搜索树中环上结点的**关系**也是不同的。每次做环 dp 需要我们重新计算的结点实际上**只有环上的点**

由于我们可以逆时针走环，也可以顺时针走环，因此做一次环上 dp 的计算次数就约为 $2m$，环上 dp 总的复杂度就为 $O(m^2)$，其中 $m$ 为环上结点数

得出环上结点的答案后，我们再对每棵树做一次换根 dp，就得出从每个点出发的期望路径长了

## CODE

细节实现略丑，有很多地方可以简化，别在意qaq

注意做环 dp 时要把答案临时存到另一个地方，而不是直接覆盖原 dp 值，否则做下一次环 dp 时会出错

```cpp
#include <cstdio>
#include <cstring>
#pragma GCC optimize("O3")
#pragma GCC optimize("Ofast", "-funroll-loops", "-fdelete-null-pointer-checks")
#pragma GCC target("ssse3", "sse3", "sse2", "sse", "avx2", "avx")
#define ll long long

const int MAXN =1e5+50;

/*------------------------------Map------------------------------*/

int first[MAXN], tote;
struct edge{
	int net, to;
	int w;
}e[MAXN<<1];

inline void addedge(int u, int v, int w){
	++tote;
	e[tote].to =v, e[tote].w =w, e[tote].net =first[u];
	first[u] =tote;
	++tote;
	e[tote].to =u, e[tote].w =w, e[tote].net =first[v];
	first[v] =tote;
}

double dp[MAXN];/*--Dfs--*/

/*------------------------------Circle------------------------------*/

int d[MAXN];
int pre[MAXN], net[MAXN], evalpre[MAXN], evalnet[MAXN], id[MAXN], circle;
bool vis[MAXN], color[MAXN], visc[25];
int stk[MAXN], top;

int predfs(int u, int fa){
	vis[u] =1;
	stk[top++] =u;
	for(int l =first[u]; l; l =e[l].net)
		if(e[l].to != fa){
			evalnet[u] =e[l].w;
			if(vis[e[l].to])
				return e[l].to;
			else{
				int ret =predfs(e[l].to, u);
				if(ret != 0)
					return ret;
			}
		}
	--top;
	return 0;
}

void getCircle(){
	circle =predfs(1, 0);
	/*接环并给环染色*/
	int ID =0;
	net[stk[top-1]] =circle;
	pre[circle] =stk[top-1];
	evalpre[circle] =evalnet[stk[top-1]];
	id[circle] =ID++;/*标号，能减少些时间 )*/
	color[circle] =1;
	while(stk[top-1] != circle){
		net[stk[top-2]] =stk[top-1];
		pre[stk[top-1]] =stk[top-2];
		evalpre[stk[top-1]] =evalnet[stk[top-2]];
		id[stk[top-1]] =ID++;
		color[stk[top-1]] =1;
		--top;
	}
}

double dp2[MAXN];

/*朝 net 走*/
void dfs3(int u, const int &cur/*当前计算的结点*/){
	if(net[u] != cur){
		dfs3(net[u], cur);
		if(d[u] > 2)
			dp2[u] =(dp[u]*(d[u]-2)+dp2[net[u]]+evalnet[u])/(d[u]-1);
		else
			dp2[u] =dp2[net[u]]+evalnet[u];
	}
	else{
		if(d[u] > 2)
			dp2[u] =dp[u];
		else
			dp2[u] =0;
	}
}

/*朝 pre 走*/
void dfs4(int u, const int &cur){
	if(pre[u] != cur){
		dfs4(pre[u], cur);
		if(d[u] > 2)
			dp2[u] =(dp[u]*(d[u]-2)+dp2[pre[u]]+evalpre[u])/(d[u]-1);
		else
			dp2[u] =dp2[pre[u]]+evalpre[u];
	}
	else{
		if(d[u] > 2)
			dp2[u] =dp[u];
		else
			dp2[u] =0;
	}
}

/*------------------------------Dfs------------------------------*/

int m, n;

/*对于有根树的第一次 dfs*/
void dfs1(int u, int fa){
	for(int l =first[u]; l; l =e[l].net)
		if(e[l].to != fa && !color[e[l].to]/*避免走到环上*/){
			dfs1(e[l].to, u);
			dp[u] +=dp[e[l].to]+e[l].w;
		}
	if(m == n){
		if(color[u])/*由于树根在环上，要分类讨论*/
			dp[u] /=d[u]-2;
		else if(d[u] != 1/*注意叶子*/)
			dp[u] /=d[u]-1;
	}
	else{
		if(fa == 0)
			dp[u] /=d[u];
		else if(d[u] != 1)
			dp[u] /=d[u]-1;
	}
}

/*对于有根树的第二次 dfs ( 换根 )*/
void dfs2(int u, int fa){
	for(int l =first[u]; l; l =e[l].net)
		if(e[l].to != fa && !color[e[l].to]){
			double res;
			if(m == n){
				/*如果存在环，此时环上结点的贡献都是 " 完整 " 的了，因此不用分类*/
				res =(dp[u]*d[u]-(dp[e[l].to]+e[l].w))/(d[u]-1);
			}
			else{
				if(d[u] == 1)/*注意链数据*/
					res =0;
				else
					res =(dp[u]*d[u]-(dp[e[l].to]+e[l].w))/(d[u]-1);
			}
			dp[e[l].to] =(dp[e[l].to]*(d[e[l].to]-1)+res+e[l].w)/d[e[l].to];
			dfs2(e[l].to, u);
		}
}

/*------------------------------Main------------------------------*/

inline int read(){
	int x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return x;
}

double tmpdp[25];

int main(){
	n =read(), m =read();
	for(int i =0; i < m; ++i){
		int u =read(), v =read(), w =read();
		addedge(u, v, w);
		++d[u], ++d[v];
	}
	if(m == n-1){
		dfs1(1, 0);
		dfs2(1, 0);
	}
	else{
		getCircle();
		for(int u =circle; !visc[id[u]]; u =net[u]){
			if(d[u] > 2)/*只对有子树的环上结点 dfs ( 这个细节说实话有点丑 )*/
				dfs1(u, 0);
			visc[id[u]] =1;
		}
		memset(visc, 0, sizeof(visc));
		for(int u =circle; !visc[id[u]]; u =net[u]){
			double res =0;
			/*模拟走环*/
			dfs3(net[u], u);
			res +=dp2[net[u]]+evalnet[u];
			dfs4(pre[u], u);
			res +=dp2[pre[u]]+evalpre[u];
			if(d[u] > 2)
				tmpdp[id[u]] =(dp[u]*(d[u]-2)+res)/d[u];
			else
				tmpdp[id[u]] =res/d[u];
			visc[id[u]] =1;
		}
		memset(visc, 0, sizeof(visc));
		for(int u =circle; !visc[id[u]]; u =net[u]){
			dp[u] =tmpdp[id[u]];
			if(d[u] > 2)
				dfs2(u, 0);
			visc[id[u]] =1;
		}
	}
	double ans =0;
	for(int i =1; i <= n; ++i)
		ans +=dp[i];
	printf("%.5lf", ans/n);
}
```

---

## 作者：Supor__Shoep (赞：1)

做了一个下午终于是做出来了，写一篇题解记录一下。

### Subtask 1 ~ 5

下文记 $w(x,y)$ 表示 $(x,y)$ 这条边的边权。

由于 $m=n-1$，那么这个图肯定就是一棵树了。

因为题目告诉我们每一个点都可以作为起点，因此我们可以联想到**换根 DP**。换根 DP 的写法相信大家已经轻车熟路了。我们先钦定一个根为 $1$，然后进行二次扫描。

- 第一次搜索：记录 $dp_x$ 表示以 $x$ 为起点，终点在以 $x$ 为根的子树中的某一个叶子节点上的路径的长度期望。此时 $x$ 向下走一步可以到达他的儿子节点，那么第一步可供选择的点就有 $son_x$ 个，其中 $son_x$ 表示 $x$ 的儿子个数。假设现在我们确定了 $x$ 的下一个点为 $y$，那么 $y$ 接着往下走的期望长度就是 $dp_y$，再加上 $w(x,y)$ 作为新的代价。因此我们就可以得到转移：

$$dp_x=\sum_{y\in Son(x)}\dfrac{dp_y+w(x,y)}{son_x}$$

- 第二次搜索：记录 $up_x$ 表示以 $x$ 为起点，终点在**以 $x$ 为根的子树之外**的某一个节点上的路径的长度期望。首先我们可以知道 $up_1=0$，然后搜索的时候我们可以利用 $x$ 的 $up$ 值去更新他的儿子 $y$ 的答案。

	对于 $up_y$ 的答案，现在我们确定了起点为 $y$，第二个点是 $x$，此时第三步可以走到 $fa_x$，也可以走到 $x$ 的其他儿子节点一共有 $1+(son_x-1)=son_x$ 种选择，但是要注意根没有父亲节点，因此 $1$ 的下一步只有 $son_x-1$ 种可能。那么我们也不难得到转移：
    
$$up_y = 
\begin{cases}
w(x,y) & x=1 \wedge son_x=1 \\
\dfrac{dp_x\times son_x-dp_y-w(x,y)}{son_x-1}+w(x,y) & x=1\wedge son_x>1 \\
\dfrac{up_x+dp_x\times son_x-dp_y-w(x,y)}{son_x}+w(x,y) & x\not= 1
\end{cases}$$

统计完两种答案之后，我们再对于每一个点 $x$，求出以它为起点的路径长度期望值 $P(x)$。

- 如果 $x=1$，那么 $P(x)=\dfrac{dp_x}{son_x}$。

- 如果 $x\not= 1$，我们就需要考虑向下走和向上走，于是有 $P(x)=\dfrac{up_x+dp_x\times son_x}{son_x+1}$。

求完每一个点的贡献之后，由于开头我们是等概率选择一个起点，因此总的答案就是 $\begin{aligned}\sum _{i=1}^n \dfrac{P(i)}{n}\end{aligned}$。

### Subtask 6 ~ 10

上难度了，是个基环树。。

下文设 $cnt$ 为环的节点个数，$stk_i$ 表示第 $i$ 个环上节点。

我们发现依旧可以考虑求出 $dp$ 和 $up$。我们特别规定环上节点的儿子就是其**相邻的不是环上节点的节点**。那么基环树就相当于将若干个树的根连成一个环形。

于是我们的 $dp_x$ 的求法与上面是完全一致的，只不过是要进行 $cnt$ 次搜索。

而对于 $up_x$，我们只需要求的环上节点的 $up$ 值，就可以根据上面的式子进行类似的递推了（**注意不是完全一致**，需要再根据 $x$ 相邻的点数进行思考，这里不再具体赘述）。

我们发现题目特意把 $cnt$ 搞得很小，这启示我们可以暴力求解。大致可能是个 $O(cnt^2)$。

我们先钦定一个环的遍历方向，对于一个环上节点 $x$，我们发现他的第一步可以是顺时针，也可以是逆时针。记录方向 $T$ 表示顺时针还是逆时针，假设我们现在走到了环上节点 $y$ 时（$y\not= x$），我们有几种情况去讨论：

- 如果按照 $T$ 方向走的下一个节点是 $x$：由于不能走到重复的点（包括起点），此时只能往 $y$ 的子树方向走。

- 如果按照 $T$ 方向走的下一个节点不是 $x$：

	- 继续往 $T$ 方向走到下一个节点上。
    
   - 往 $y$ 的子树方向走。
   
当我们统计 $up_x$ 时，我们可以枚举另一个环上节点 $y$，表示此时朝 $y$ 的子树方向走，即令 $y$ 为转折点。这样的时间复杂度就是 $O(cnt^2)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/5y3jfgnh.png)

我们其实可以找到其中的递推性。设 $f_{i,j,T}$ 表示第一步方向为 $T$，**以 $stk_i$ 为起点，途径 $stk_j$ 的路径中，$stk_j$ 往后走的期望长度**。说得可能有点模糊，我们拿上图举一个例子：找到以 $1$ 为起点，并且**保证经过**了 $3$ 的所有路径，定义随机变量 $p$ 表示这些路径中自 $3$ 开始走到底形成的子路径长度，此时 $f_{1,3,T}$ 就表示 $E(p)$。在上图中，$p$ 只可能是 $dist(3,6)$。

转移的思路在上文已经点到过了，这里直接给出方程：

$$f_{i,j,T} = 
\begin{cases}
dp_{stk_j} & nxt_T(j)=i \\
\dfrac{dp_{stk_j}\times son_{stk_j}+f_{i,nxt_T(j),T}+w(j,nxt_T(j))}{son_{stk_j}+1} & nxt_T(j)\not= i
\end{cases}$$

其中 $nxt_T(j)$ 表示在 $T$ 方向上的 $j$ 的下一个节点。

由于 $f_{i,j,T}$ 和 $f_{i,nxt_T(j),T}$ 有关，因此我们可以先从 $nxt_T(j)=i$ 的 $j$ 开始，以 $T$ 的反方向进行更新。若 $T=0/1$ 分别表示顺时针和逆时针，那最终 $up_x=\dfrac{f_{x,nxt_0(i),0}+f_{x,nxt_1(i),1}}{2}$。这是因为 $x$ 开始是需要选择顺时针或逆时针，每个结果的概率为 $\dfrac{1}{2}$。

这样就可以 $O(cnt^2)$ 求出 $up_x$ 了，然后再套用树的处理方法更新其他节点即可。

最后统计答案依旧是看每个点的相邻点数。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e5+5;
void read(int &x)
{
	x=0;
	short flag=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')	flag=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	x*=flag;
}
int head[MAXN],nxt[MAXN<<1],to[MAXN<<1],val[MAXN<<1],tot;
void add(int x,int y,int z)
{
	to[++tot]=y,val[tot]=z;
	nxt[tot]=head[x];
	head[x]=tot;
}
int vv[MAXN],vis[MAXN],stk[MAXN];
int cnt;
int dfspre(int x,int fa)//找环 
{
	if(vv[x]==1)
	{
		vv[x]=2,stk[++cnt]=x,vis[x]=1;
		return 1;
	}
	vv[x]=1;
	for(int i=head[x];i;i=nxt[i])
	{
		if(i!=((fa-1)^1)+1&&dfspre(to[i],i))
		{
			if(vv[x]!=2)
			{
				stk[++cnt]=x,vis[x]=1;
				return 1;
			}
			return 0;
		}
	}
	return 0;
}
int n,m;
int son[MAXN];
double dp[MAXN],up[MAXN];
void dfs1(int x,int fa)//更新 dp
{
	for(int i=head[x];i;i=nxt[i])
	{
		if(to[i]==fa||vis[to[i]])	continue;
		dfs1(to[i],x);
		son[x]++,dp[x]+=dp[to[i]]+val[i];
	}
	if(son[x])	dp[x]/=son[x];
}
void dfs2(int x,int fa)//更新非环上节点或树上节点的 up 
{
	for(int i=head[x];i;i=nxt[i])
	{
		if(to[i]==fa||vis[to[i]])	continue;
		if(son[x]==1)	up[to[i]]=up[x]+val[i];
		else	up[to[i]]=(dp[x]*son[x]-dp[to[i]]-val[i]+up[x]*(1+vis[x]))/(son[x]-(m<n&&x==1)+(m==n&&vis[x]))+val[i];
		dfs2(to[i],x);
	}
}
unordered_map<int,int> mp[MAXN];//储存 w(x,y) 
int Nxt(int x){ return (x==cnt)?1:(x+1); }
int Pre(int x){ return (x==1)?cnt:(x-1); }
int main()
{
	read(n),read(m);
	for(int i=1;i<=m;i++)
	{
		int x,y,z;
		read(x),read(y),read(z);
		add(x,y,z),add(y,x,z);
	}
	if(m==n-1)
	{
		dfs1(1,0),dfs2(1,0);
		double res=0;
		for(int i=1;i<=n;i++)	res+=(dp[i]*son[i]+up[i])/(son[i]+(i!=1))/n;
		printf("%.5lf",res);
		return 0;
	}
	dfspre(1,0);
	for(int i=1;i<=cnt;i++)
	{
		for(int j=head[stk[i]];j;j=nxt[j])
		{
			if(vis[to[j]])	mp[stk[i]][to[j]]=val[j];
		}
	}
	for(int i=1;i<=cnt;i++)	dfs1(stk[i],0);//先处理 dp
	//下面是求环上节点的 up 
	for(int i=1;i<=cnt;i++)
	{
		int now=Nxt(i);
		up[stk[i]]=dp[stk[now]],now=Nxt(now);
		//f[i][j][T] 的处理可以直接省去数组，只弄一个变量放进去一步步更新 
		while(now!=i)	up[stk[i]]=(dp[stk[now]]*son[stk[now]]+up[stk[i]]+mp[stk[now]][stk[Pre(now)]])/(son[stk[now]]+1),now=Nxt(now);
		up[stk[i]]+=mp[stk[i]][stk[Pre(i)]];//注意最后还有加上 w(i,nxt_i)
	}
	for(int i=1;i<=cnt;i++)
	{
		double sum=0;
		int now=Pre(i);
		//方法同理 
		sum=dp[stk[now]],now=Pre(now);
		while(now!=i)	sum=(dp[stk[now]]*son[stk[now]]+sum+mp[stk[now]][stk[Nxt(now)]])/(son[stk[now]]+1),now=Pre(now);
		sum+=mp[stk[i]][stk[Nxt(i)]],up[stk[i]]+=sum,up[stk[i]]/=2;
	}
	for(int i=1;i<=cnt;i++)	dfs2(stk[i],0);//再处理其他点的 up 
	double res=0;
	for(int i=1;i<=n;i++)	res+=(dp[i]*son[i]+up[i]*(1+vis[i]))/(son[i]+1+vis[i])/n;//统计答案 
	printf("%.5lf",res);
	return 0;
}
```

---

## 作者：不存在之人 (赞：1)

树dp+基环树。

如果输入是一棵树的话(m=n-1)，用O(n)就可以解决：

1.首先随便选择一个点做根。

2.Dfs

si表示i的儿子结点；

f[i]表示i结点向儿子走的期望长度；

d[i]=sigma(f[si]+edge(si,i))；

du[i]表示i结点的度数，即儿子的个数+1（父亲）；

显然，f[i]=d[i]/(du[i]-1)。

我们做树形dp就可以把f[],d[],du[]数组都求出来。

3.Dfs2

那么接下来要求的是i结点走向任意一个叶子结点的期望长度，已经求了走向儿子的期望长度，还需求的是走向父亲的期望长度p[i]。

p[root]=f[root]。

接下来dfs，dfs(i)的时候他的父亲x的p[x]已经求出，那么：

d[i]+=(d[x]-y[i]-edge(x,i))/(du[x]-1)+edge(x,i)

p[i]=d[i]/du[i]。

一次dfs之后所有点的p[]就求出来了。

如果是m=n呢？

那么他是一棵基环树即这棵树中有且仅有一个环。

------------

1.Findcir

先找到这个环。

2.Dfs

以环上的每一个点为根，做m=n-1时的第二步求出每个点的d[],f[]。

3.Calc

因为有环，所以环上每个结点的f[i]并不等于p[i]。

那么我们需要枚举环上的每个点，计算从这个点出发沿着环走的期望长度。

注意环上的点度数要加2。

4.Dfs2

此时环上每个点的d[i]/du[i]=p[i]，然后按照m=n-1时的第二步计算非环上的点的p[i]即可。
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#define M 100005
#define ld long double
using namespace std;
int fa[M],c[M],v[M],tot=0,n,m,du[M],now=0,h[M],root;
ld g[M],f[M],d[M],gg[M];
struct edge
{
	int y,ne,l;
}e[M*5];
void Addedge(int x,int y,int l)
{
	tot++;
	e[tot].y=y;
	e[tot].ne=h[x];
	e[tot].l=l;
	h[x]=tot;
}
void Dfs(int x)
{
	d[x]=f[x]=0.000;
	v[x]=1;
	du[x]=0;
	for (int i=h[x];i;i=e[i].ne)
	{
		int y=e[i].y;
		if (v[y]||c[y]) continue;
		Dfs(y);
		du[x]++;
		d[x]=d[x]+f[y]+(ld)e[i].l;
	}
	if (du[x]) f[x]=d[x]/(ld)du[x];
	if (x!=root) du[x]++;
}
void Dfs2(int x)
{
	v[x]=1;
	for (int i=h[x];i;i=e[i].ne)
	{
		int y=e[i].y;
		if (v[y]||c[y]) continue;
		int k=du[x]-1;
		if (!k) k++;
		d[y]=d[y]+(d[x]-f[y]-(ld)e[i].l)/(ld)(k)+(ld)e[i].l;
		Dfs2(y);
	}
}
void Findcir(int x)
{
	v[x]=++now;
	for (int i=h[x];i;i=e[i].ne)
	{
		int y=e[i].y;
		if (!v[y])
		{
			fa[y]=x;
			Findcir(y);
		}
		else if (y!=fa[x]&&v[y]<v[x])
		{
			c[y]=1;
			while (x!=y)
			{
				c[x]=1;
				x=fa[x];
			}
			return;
		}
	}
}
void Calc(int x,int fa)
{
	bool last=true;
	g[x]=0.000;
	for (int i=h[x];i;i=e[i].ne)
	{
		int y=e[i].y;
		if (y!=root&&y!=fa&&c[y])
		{
			last=false;
			Calc(y,x);
			g[x]=g[x]+g[y]+(ld)e[i].l;
		}
	}
	int k=du[x];
	if (!k) k++;
	if (last) g[x]=d[x]/(ld)k;
	else 
	{
		k=du[x]+1;
		if (x!=root)
			g[x]=(g[x]+d[x])/(ld)k;
		else 
		{
			return;
		}
	}
}
int main()
{
    scanf("%d%d",&n,&m);
	for (int i=1;i<=m;i++)
	{
		int x,y,l;
		scanf("%d%d%d",&x,&y,&l);
		Addedge(x,y,l);
		Addedge(y,x,l);
	}
	if (n==m+1)
	{
		root=1;
		Dfs(1);
		for (int i=1;i<=n;i++)
			v[i]=0;
		Dfs2(1);
	}
	else
	{
		Findcir(1);
		for (int i=1;i<=n;i++)
			v[i]=0;
		for (int i=1;i<=n;i++)
			if (c[i]) root=i,Dfs(i);
		for (int i=1;i<=n;i++)
			if (c[i]) root=i,Calc(i,0),gg[i]=g[i];
		for (int i=1;i<=n;i++)
			if (c[i]) du[i]+=2,d[i]+=gg[i];
		for (int i=1;i<=n;i++)
			v[i]=0;
		for (int i=1;i<=n;i++)
			if (c[i]) Dfs2(i);
	}
	double ans=0.000;
	for (int i=1;i<=n;i++)
		ans=ans+d[i]/(ld)du[i];
	printf("%.5lf\n",ans/(double)n);
	return 0;
}
```

---

## 作者：Purslane (赞：0)

# Solution

这能黑？

考虑 $m=n-1$ 的时候怎么做，也就是树的情形。很显然使用换根 DP。设 $f_u$ 表示我们当前在 $u$，并且**钦定往下走**的期望长度是多少。假设我们建出以 $1$ 为根的有根树，得到：（$cnt_u$ 是 $u$ 的儿子个数。）

$$f_u = \frac{\sum_{v \in son_u} f_v+w(v,u)}{cnt_u}$$

然后设 $g_u$ 表示我们当前在 $u$，表示**钦定下一步往上走**（也就是之后可以拐下去）的期望长度是多少。考虑换根 DP，得到：

$$g_v = w(u,v) + \frac{g_u+\sum_{k \in son_u,k \neq v} f_v+w(v,u)}{\deg u -1}$$

可能在 $u=1$ 的时候有一些边界情况，不过不大重要。

考虑 $m=n$ 的时候怎么做。这时候是基环树，我们肯定要找到环，并且分别考虑每一个环上的点引导的树。我们发现，在这棵树上处理 $f$ 和树的情况是一模一样的。处理 $g$ 的递推式貌似是一模一样的，吗？

考虑当 $u$ 是环上节点的时候，如果在树上，它是根，在前一种情况下是哪都走不掉的（如果你想让他往上走）；但是如果 $u$ 在环上，他可以饶过环到另一棵树内。而且，一般的节点往上走只有一种方法；但是环上走有两个方向。于是，我们给每个节点记录 $facnt_u$ 和 $soncnt_u$，表示他们父亲和儿子的个数。这样转移变成了

$$g_v = w(u,v) + \frac{facnt_u \times g_u+\sum_{k \in son_u,k \neq v} f_v+w(v,u)}{facnt_u+soncnt_u -1}$$

而且有 $facnt_u+soncnt_u = \deg u$ 成立。

于是我们只需要计算 $g_u$，当 $u$ 在环上。

而这个是相当简单的，由于环上的节点特别少，所以我们可以直接模拟从 $u$ 出发在环上游走的过程。每次有一定的概率沿树边拐下去，也有一定的概率继续走下一条环边（注意，如果下一条环边又指向 $u$ 了我们就不能走了。）

可以做到 $O(n+k^2)$，$k$ 是环上节点的个数。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=100000+10;
int n,m,fa[MAXN],flg[MAXN],vis[MAXN],dep[MAXN],in[MAXN],faw[MAXN],facnt[MAXN],soncnt[MAXN];
vector<pair<int,int>> cir;
vector<pair<int,pair<int,int>>> G[MAXN]; 
long double dp1[MAXN],dp2[MAXN];
int tot,id[MAXN],len[MAXN];
int id_pre(int u) {
	if(u==1) return tot;
	return u-1;	
}
int id_nxt(int u) {
	if(u==tot) return 1;
	return u+1;	
}
void dfs(int u,int f) {
	fa[u]=f,dep[u]=dep[f]+1,vis[u]=1;
	for(auto pr:G[u]) {
		int v=pr.first,w=pr.second.first,id=pr.second.second;
		if(id==in[u]) continue ;
		if(vis[v]) {
			if(dep[v]<dep[u]) {
				int pos=u;
				while(pos!=v) cir.push_back({pos,faw[pos]}),pos=fa[pos];
				cir.push_back({v,w});
			}
		}
		else faw[v]=w,in[v]=id,dfs(v,u);
	}
	return ;
}
void dfs1(int u,int f) {
	int cnt=0;
	for(auto pr:G[u]) {
		int v=pr.first;
		if(v!=f&&!flg[v]) cnt++;
	}
	soncnt[u]=cnt;
	for(auto pr:G[u]) {
		int v=pr.first,w=pr.second.first;
		if(v==f||flg[v]) continue ;
		dfs1(v,u);
		dp1[u]=dp1[u]+1.0*(dp1[v]+w)/cnt;	
	}
	return ;
}
void dfs2(int u,int f) {
	for(auto pr:G[u]) {
		int v=pr.first,w=pr.second.first,id=pr.second.second;
		if(v==f||flg[v]) continue ;
		if(G[u].size()==1) dp2[v]=w;
		else dp2[v]=w+1.0*facnt[u]/(G[u].size()-1)*dp2[u]+1.0*(dp1[u]*soncnt[u]-dp1[v]-w)/(G[u].size()-1);
		dfs2(v,u);
	}
	return ;
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	ffor(i,1,m) {
		int u,v,w;
		cin>>u>>v>>w;
		G[u].push_back({v,{w,i}});
		G[v].push_back({u,{w,i}});	
	}
	if(m==n) dfs(1,0);	
	else cir.push_back({1,0});
	for(auto pr:cir) flg[pr.first]=1;
	for(auto pr:cir) dfs1(pr.first,0);
	for(auto pr:cir) id[++tot]=pr.first,len[tot]=pr.second;
	ffor(i,1,tot) {
		long double p=0.5;
		int pos=id_pre(i),tlen=len[pos];
		while(pos!=i) {
			if(id_pre(pos)==i) dp2[id[i]]=dp2[id[i]]+(tlen+dp1[id[pos]])*p;
			else dp2[id[i]]=dp2[id[i]]+(tlen+dp1[id[pos]])*p*(G[id[pos]].size()-2)/(G[id[pos]].size()-1);
			p=p/(1.0*(G[id[pos]].size()-1));	
			pos=id_pre(pos),tlen=tlen+len[pos];
		}
		p=0.5,pos=id_nxt(i),tlen=len[i];
		while(pos!=i) {
			if(id_nxt(pos)==i) dp2[id[i]]=dp2[id[i]]+(tlen+dp1[id[pos]])*p;
			else dp2[id[i]]=dp2[id[i]]+(tlen+dp1[id[pos]])*p*(G[id[pos]].size()-2)/(G[id[pos]].size()-1);
			p=p/(1.0*(G[id[pos]].size()-1));	
			tlen=tlen+len[pos],pos=id_nxt(pos);	
		}
		if(tot-1) facnt[id[i]]=2;
	}
	ffor(i,1,n) if(!flg[i]) facnt[i]=1;
	ffor(i,1,tot) dfs2(id[i],0);
	long double ans=0;
	ffor(i,1,n) ans=ans+dp1[i]*soncnt[i]/(soncnt[i]+facnt[i])+dp2[i]*facnt[i]/(soncnt[i]+facnt[i]);	
	cout<<fixed<<setprecision(5)<<ans/n;
	return 0;
}
```

---

## 作者：rhjoi (赞：0)


------
SOL
=

题意：给一个可能有一个环的树，定义一条合法的路径为从某一起点出发，随机在未走过的点中选择，直到走不动。求从任一点出发的路径长度的期望值。

//基环树的确不需要学啊。。。自己yy就出来了。

----
一、先处理树上的情况。
这是一个很显然的树上期望dp，但是为了保证统计的方案是合法的，我们要把向上走和向下走两种情况分开讨论。

$$dp[u][down]=(\sum dp[son[u][down])/s[u]$$



 $$dp[u][up]=(dp[fa[u][down]*s[fa[u]]-len[fa[u]][u]-dp[u][down]+dp[fa[u][up])/(s[fa[u]]+1)$$
$s[u]$:$u$的儿子数量  ，$dp[u][down]$从$u$向下走的期望值。

----
二、再处理环上的情况。
由于从$i$点出发不能回到自己，首先要分成顺时针和逆时针，并且要以环上每一点为起点出发讨论情况。由于环上点数$\le20$，极端情况下时间复杂度为$1e5/20*20*20=2e6$ ，可以承受.
$$f[u][0]=len[u][v]+f[v][0]$$
$$tmp[u][0]=(dp[u][0]*s[u]+tmp[v][0]+len[u][v])/(s[u]+1)$$

$f[u]$为当前起点，$tmp[u]$为中间点。

-----
三、合并情况。

$$if(!fa[u])\ now=(f[u][1]+f[u][0]+dp[u][0]*s[u])/(1.0*(s[u]+2));$$
			$$else \ now=(dp[u][1]+dp[u][0]*s[u])/(1.0*(s[u]+1))$$

----

//DP式子写起来真累。。

----
CODE
=

```cpp
#include<bits/stdc++.h>
#define pf printf
#define sf scanf
#define cs const
#define ll long long
#define db double
using namespace std;
cs int N=1e5+10;
db f[N][2],dp[N][2],tmp[N][2];
int n,m,s[N],fa[N],CN,nxt[N<<1],head[N],w[N<<1],to[N<<1],cnt=1,lasw[N],len[N][2],nxtp[N][2];
bool vis[N],rod[N<<1];
vector <int> g[N];
inline void _add(int u,int v,int ww){
	nxt[++cnt]=head[u];head[u]=cnt;to[cnt]=v;w[cnt]=ww;
}
void dfs1(int u){
	vis[u]=1;
	for(int i=head[u];i;i=nxt[i]){
		if(rod[i])continue;
		rod[i]=rod[i^1]=1;
		if(vis[to[i]]){
			nxtp[to[i]][0]=u;nxtp[u][1]=to[i];
			len[to[i]][0]=len[u][1]=w[i];
			++CN;
			for(int v=u;;v=fa[v]){
				g[CN].push_back(v);
				if(v==to[i])break;
				nxtp[v][0]=fa[v];nxtp[fa[v]][1]=v;
				len[v][0]=len[fa[v]][1]=lasw[v];
			}
		}
		else{
			lasw[to[i]]=w[i];
			fa[to[i]]=u;
			dfs1(to[i]);
		}
	}
}
void dfs(int u,bool kd){
	if(kd==1){
		if(fa[u]){
			if(fa[fa[u]])
				dp[u][1]=(dp[fa[u]][0]*s[fa[u]]-dp[u][0]-lasw[u]+dp[fa[u]][1])/(1.0*(s[fa[u]]))+lasw[u];
			else
				dp[u][1]=(dp[fa[u]][0]*s[fa[u]]-dp[u][0]-lasw[u]+f[fa[u]][0]+f[fa[u]][1])/(1.0*(s[fa[u]]+1))+lasw[u];
		}
	}
	for(int i=head[u];i;i=nxt[i]){
		int v=to[i];
		if(v==fa[u]||vis[v])continue;
		fa[v]=u;lasw[v]=w[i];
		dfs(v,kd);
		if(kd==0){
			++s[u];
			dp[u][0]+=dp[v][0]+w[i];	
		}
	}
	if(kd==0&&s[u])dp[u][0]/=(1.0*(s[u]));
}
namespace work1{
	inline void dfs(int u,bool kd){
		if(kd==1){
			if(fa[u]){
				dp[u][1]=lasw[u];
				if(fa[fa[u]])
					dp[u][1]+=(dp[fa[u]][0]*s[fa[u]]-dp[u][0]-lasw[u]+dp[fa[u]][1])/(1.0*(s[fa[u]]));
				else
					if(s[fa[u]]>1)dp[u][1]+=(dp[fa[u]][0]*s[fa[u]]-dp[u][0]-lasw[u])/(1.0*(s[fa[u]]-1));							
			}
		}
		for(int i=head[u];i;i=nxt[i]){
			int v=to[i];
			if(v==fa[u]||vis[v])continue;
			fa[v]=u;lasw[v]=w[i];
			dfs(v,kd);
			if(kd==0){
				++s[u];
				dp[u][0]+=dp[v][0]+w[i];	
			}
		}
		if(kd==0&&s[u])dp[u][0]/=(1.0*(s[u]));
	}
	inline void gather(){
		db now=0,ans=0;
		for(int u=1;u<=n;++u){
			if(!fa[u])
				now=dp[u][0];
			else
				now=(dp[u][1]+dp[u][0]*s[u])/(1.0*(s[u]+1));
			ans+=now/(1.0*n);
		}
		pf("%.5lf",ans);
	}	
}
inline void calc(int u,cs int &bord,cs int &kd){
	if(nxtp[u][kd]==bord){
		tmp[u][kd]=dp[u][0];
		return;
	}
	calc(nxtp[u][kd],bord,kd);
	if(u^bord)tmp[u][kd]=(dp[u][0]*s[u]+len[u][kd]+tmp[nxtp[u][kd]][kd])/(1.0*(s[u]+1));
	else f[u][kd]=len[u][kd]+tmp[nxtp[u][kd]][kd];
}
inline void gather(){
	db now=0,ans=0;
	for(int u=1;u<=n;++u){
		if(!fa[u])
			now=(f[u][1]+f[u][0]+dp[u][0]*s[u])/(1.0*(s[u]+2));
		else
			now=(dp[u][1]+dp[u][0]*s[u])/(1.0*(s[u]+1));
		//cout<<u<<' '<<now<<'\n';
		ans+=now/(1.0*n);
	}
	pf("%.5lf",ans);
}
signed main (){
//	freopen("data.in","r",stdin);
	sf("%d%d",&n,&m);
	for(int i=1;i<=m;++i){
		int u,v,w;sf("%d%d%d",&u,&v,&w);
		_add(u,v,w);_add(v,u,w);
	}
	if(m^n){
		work1::dfs(1,0);
		work1::dfs(1,1);
		work1::gather();
		return 0;
	}	
	for(int u=1;u<=n;++u)if(!vis[u])dfs1(u);
	memset(vis,0,sizeof vis);
	for(int i=1;i<=CN;++i){
		int up=g[i].size();
		for(int j=0;j<up;++j){
			fa[g[i][j]]=0;vis[g[i][j]]=1;
		}
		for(int j=0;j<up;++j){
			dfs(g[i][j],0);
		}
		for(int j=0;j<up;++j){
			calc(g[i][j],g[i][j],0);
			calc(g[i][j],g[i][j],1);
			dfs(g[i][j],1);
		}
	}
	gather();
	return 0;
}
```










---


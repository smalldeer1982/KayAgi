# [ZJOI2007] 仓库建设

## 题目描述

L 公司有 $n$ 个工厂，由高到低分布在一座山上，工厂 $1$ 在山顶，工厂 $n$ 在山脚。

由于这座山处于高原内陆地区（干燥少雨），L公司一般把产品直接堆放在露天，以节省费用。突然有一天，L 公司的总裁 L 先生接到气象部门的电话，被告知三天之后将有一场暴雨，于是 L 先生决定紧急在某些工厂建立一些仓库以免产品被淋坏。

由于地形的不同，在不同工厂建立仓库的费用可能是不同的。第 $i$ 个工厂目前已有成品 $p_i$ 件，在第 $i$ 个工厂位置建立仓库的费用是 $c_i$。

对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，而由于 L 公司产品的对外销售处设置在山脚的工厂 $n$，故产品只能往山下运（即**只能运往编号更大的工厂的仓库**），当然运送产品也是需要费用的，一件产品运送一个单位距离的费用是 $1$。

假设建立的仓库容量都都是足够大的，可以容下所有的产品。你将得到以下数据：

- 工厂 $i$ 距离工厂 $1$ 的距离 $x_i$（其中 $x_1=0$）。
- 工厂 $i$ 目前已有成品数量 $p_i$。
- 在工厂 $i$ 建立仓库的费用 $c_i$。

请你帮助 L 公司寻找一个仓库建设的方案，使得总的费用（建造费用 + 运输费用）最小。

## 说明/提示

#### 样例输入输出 $1$ 解释

在工厂 $1$ 和工厂 $3$ 建立仓库，建立费用为 $10+10=20$ ，运输费用为 $(9-5) \times 3 = 12$，总费用 $32$。

#### 数据范围与约定

对于 $20\%$ 的数据，保证 $n \leq 500$。

对于 $40\%$ 的数据，保证 $n \leq 10^4$。

对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^6$，$0 \leq x_i,p_i,c_i < 2^{31}$。

对于任意的 $1 \leq i < n$，保证 $x_i < x_{i + 1}$。

设答案为 $ans$，保证 $ans + \sum\limits_{i = 1}^{n} p_ix_i < 2^{63}$。

## 样例 #1

### 输入

```
3
0 5 10
5 3 100
9 6 10```

### 输出

```
32
```

# 题解

## 作者：rickyxrc (赞：11)

本文章遵守知识共享协议 CC-BY-NC-SA，同步发表于洛谷题解区，转载时须在文章的任一位置附上原文链接和作者署名（rickyxrc）。推荐在[我的个人博客](https://blog.rickyxrc.cc)阅读。

## 题面大意

有 $n$ 个点，每个点有一定量（$p_i$）的物资，现在要选择一些点，将所有物资通过**向右移动**的方式汇集到这些点中，选择点和向右移动单位物资均有代价，求最小代价。

## 解题思路

我们首先想一个 $O(n^2)$ 的 dp 式子。

注意到如下基本事实：若一个点建立了仓库，则前面的没有运输进仓库的点都会运输到这里，所以每个仓库的覆盖范围是一定的。

我们定义 $f_i$ 为前 $i$ 个地点的物品都能被安置，且 $i$ 号点是最后一个仓库时的最小花费。

则我们可以得到（下文中的 $d$ 指的是题目中的 $x$，即距离）：

$$\begin{aligned}f_i &= \min_{j\in[0,i)}\{f_j+c_i+\sum_{k\in[j+1,i)}p_k(d_i-d_k)\} \\ &= \min_{j\in[0,i)}\{f_j+c_i+d_i\sum_{k\in[j+1,i)}p_k-\sum_{k\in[j+1,i)}p_k\cdot d_k\}\end{aligned}$$
我们定义 $q_i = \sum_{j \in [1,i]}p_j,r_i = \sum_{j \in [1,i]}d_j\cdot p_j$，则上面的式子就变成了这样：

$$\begin{aligned}f_i &= \min_{j\in[0,i)}\{f_j+c_i+d_i(q_i-q_j)-r_i+r_j\}\end{aligned}$$
这个基本就是斜率优化的板子了，我们假定存在 $u,v\in [0,i)$ 且 $u<v$，同时 $v$ 优于 $u$（即选 $v$ 转移 $f$ 比选 $u$ 更大），那么我们就能列出不等式：

$$\begin{aligned}f_u+c_i+d_i(q_i-q_u)-r_i+r_u &\le f_v+c_i+d_i(q_i-q_v)-r_i+r_v \\ f_u+c_i+d_iq_i-d_iq_u-r_i+r_u &\le f_v+c_i+d_iq_i-d_iq_v-r_i+r_v \\ f_u+d_iq_i-d_iq_u+r_u &\le f_v+d_iq_i-d_iq_v+r_v \\ (f_u-r_u) - (f_v-r_v) &\le (q_u-q_v)d_i \\ \dfrac{(f_u-r_u) - (f_v-r_v)}{q_u-q_v} &\le d_i \\ \dfrac{(f_v-r_v) - (f_u-r_u)}{q_v-q_u} &\le d_i\end{aligned}$$
于是我们将问题抽象如下：平面上有 $n$ 个点，坐标为 $(q_i,f_i+r_i)$，若对于 $u<v$ 的两点，满足两点的斜率小于 $d_i$，则选择右侧的点是更优的。

这里可以用凸壳维护，因为不在凸壳上的点一定劣于凸壳上的点，下面是具体原因：

我们假设有 $u,v,w$ 三点，满足 $u < v < w$，且 $u,w$ 在凸壳上，$v$ 在凸壳以内。

假如此时 $u$ 优于 $w$，则有 $k_{uw} < k_{u,v},k_{uw} \le di$，结合几何相关知识得 $k_{vw} \le k_{uv}$ 此时 $w$ 优于 $v$，所以 $v$ 对答案没有贡献。

配上一张很丑的图示：

![](https://cdn.luogu.com.cn/upload/image_hosting/exhik42m.png)

假如此时 $u$ 劣于 $w$，则同样有 $k_{uw} < k_{u,v},k_{uw} \le di,k_{uv} \ge k_{uw}$ 此时 $w$ 劣于 $u$，同时 $v$ 劣于 $u$，$v$ 对答案同样没有贡献。

![](https://cdn.luogu.com.cn/upload/image_hosting/7l937y42.png)

综上，$v$ 对答案是没有贡献的，所以我们可以维护一个下凸壳，因为凸壳上的斜率单调递增，所以可以在上面二分最优决策点。

但这题有更好的性质：$d_i$ 单调递增，所以我们可以直接维护一个单调队列代表凸壳上边的斜率，在查找时直接弹出队尾斜率不合法的点即可，因为队尾若不合法，接下来也不可能合法。

还有一个要注意的点（hack 数据），就是 $p_i$ 等于 $0$ 的情况，若末尾有连续的 $p_i=0$，取其 $f$ 值的最小值即可。

代码不长，重在理解。

```cpp nums
#include<stdio.h>

typedef long long i64;
const int maxn = 1.2e6;

int n;

i64 d[maxn],p[maxn],c[maxn],f[maxn],q[maxn],r[maxn];

i64 min(i64 a,i64 b){ return a<b?a:b;}

i64 decx (int index)   { return q[index];}
i64 decy (int index)   { return f[index]+r[index];}
i64 maked(int i,int u) { return f[u] + d[i] * (q[i] - q[u]) - r[i] + r[u] + c[i];}

// back -> . . . . . . . . . <- front 
int que[maxn],vfront,vback;
int  size     ()      { return vfront-vback;}
int  front    ()      { return que[vfront-1];}
int  front2   ()      { return que[vfront-2];}
int  back     ()      { return que[vback];}
int  back2    ()      { return que[vback+1];}
void push     (int v) { que[vfront++]=v;}
void pop_front()      { vfront--;}
void pop_back ()      { vback++;}

int main(){
	scanf("%d",&n);

	for(int i=1;i<=n;i++)
		scanf("%lld%lld%lld",d+i,p+i,c+i);

	for(int i=1;i<=n;i++) q[i] = p[i] + q[i-1];
	for(int i=1;i<=n;i++) r[i] = d[i] * p[i] + r[i-1];

	push(0);

	for(int i=1;i<=n;i++){
		while(
			size()>=2 and
			(decy(back2())-decy(back()))
				<= d[i] * (decx(back2())-decx(back()))
		)
			pop_back();
		f[i] = maked(i,back());
		while(
			size()>=2 and
			(decy(front())-decy(front2())) * (decx(i)-decx(front()))
				>= (decy(i)-decy(front())) * (decx(front()) - decx(front2()))
		)
			pop_front();
		push(i);
	}
	
	i64 ans = f[n];

	int x=n;
	while(p[x]==0)
		x--,ans=min(ans,f[x]);

	printf("%lld",ans);

	return 0;
}
```

---

## 作者：DaydreamWarrior (赞：7)

有兴趣的可以看看 [我的博客](https://rainlycoris.github.io/#/post/46)

### 分析

首先写个 $n^2$ dp 转移：

$$
\begin{aligned}
f_i&=\min_{j=1}^{i-1}(f_j+\sum_{k=j+1}^i(x_i-x_k)p_k)+c_i\\
  &=\min_{j=1}^{i-1}(f_j+x_i\sum_{k=j+1}^ip_k-\sum_{k=j+1}^ix_kp_k)+c_i\\
  &=\min_{j=1}^{i-1}(-x_i\sum_{k=1}^jp_k+f_j+\sum_{k=1}^jx_kp_k)+x_i\sum_{k=1}^ip_k-\sum_{k=1}^ix_kp_k+c_i
\end{aligned}
$$

然后 $\min$ 里面的像一次函数，直接上李超树。

### 一些细节

要特判末尾连续的 $p_i=0$，以及第 $8$ 个点卡李超树，别的 hack 倒是不用管。

### 代码

```cpp
const int N = 1000005,INF = (1ull<<63)-1;
int x[N],p[N],c[N],f[N];
int n;

class lctree{
    private:
        struct{int l,r;pair<int,int> f;} tr[N];
        int val(pair<int,int> f,int x){return f.first*x+f.second;};
        int idx;
    public:
        int root;
        void insert(int &u,int l,int r,pair<int,int> f){
            if(!u)
                tr[u=++idx].f =  f;
            else{
                int mid = (l+r)>>1;
                if(val(f,mid)<val(tr[u].f,mid))
                    swap(f,tr[u].f);
                if(f.first>tr[u].f.first)
                    insert(tr[u].l,l,mid,f);
                else
                    insert(tr[u].r,mid+1,r,f);
            }
        }

        int query(int u,int l,int r,int p){
            if(!u)
                return INF;
            int mid = (l+r)>>1;
            return min(val(tr[u].f,p),p<=mid?query(tr[u].l,l,mid,p):query(tr[u].r,mid+1,r,p));
        }
}tr;

signed main(){
    n = in;
    int V = 0;
    for(int k=1;k<=n;k++){
        x[k] = in,p[k] = in,c[k] = in;
        V = max(V,x[k]);
    }
    tr.insert(tr.root,0,V,{0,0});
    int sp = 0,sxp = 0;
    for(int k=1;k<=n;k++){
        sp += p[k];
        sxp += x[k]*p[k];
        f[k] = tr.query(tr.root,0,V,x[k])+x[k]*sp-sxp+c[k];
        tr.insert(tr.root,0,V,{-sp,f[k]+sxp});
    }
    int ans = f[n];
    for(int k=n;k&&!p[k];k--)
        ans = min(ans,f[k-1]);
    out(ans);
    return 0;
}
```

---

## 作者：Aisaka_Taiga (赞：6)

咱可以设 $f_{i}$ 表示第 $i$ 个工厂建工厂，只考虑前 $i$ 个工厂不被冲的最小花费。

那么咱就能写出来一个 $O(n^2)$ 的 DP 式子：

$$
f_{i} = \min_{j=1}^{i -1}(f_j + \sum_{k = j + 1}^{i} (x_i - x_k) \times p_k + c_i)
$$

复杂度肯定受不了，我们先拆一下式子：

$$
f_i=\min_{j=1}^{i-1}(f_{j}+\sum_{k = j + 1}^{i}x_i\times p_k - \sum_{k = j + 1}^{i}x_{k}\times p_k + c_i)
$$

咱设 $s_i = \sum_{k=1}^{i}p_k\times x_k$，然后对 $p$ 数组做一次前缀和。

那么咱就可以简化成这样：

$$
f_i = \min_{j=1}^{i-1}(f_j + x_i \times (p_i - p_j) - s_i + s_j + c_i)
$$

假设前面有两个位置 $a, b$，且 $a<b$ 那么如果 $a$ 转移过来优于 $b$，需要满足：

$$
f_a+x_i\times(p_i-p_a) - s_i +s_a + c_i > f_b+x_i\times(p_i-p_b) - s_i +s_b + c_i
$$

$$
f_a-f_b+x_i\times(p_i-p_a-p_i+p_b)<-s_i+s_b+c_i+s_i-s_a-c_i
$$

$$
f_a-f_b+x_i\times(p_b-p_a)< s_b - s_a
$$

$$
x_i\times(p_b-p_a) < s_b-s_a-f_a+f_b
$$

$$
x_{i}<\frac{s_b-s_a-f_a+f_b}{p_b-p_a}
$$

$$
x_{i}<\frac{(f_b+s_b)-(f_a+s_a)}{p_b-p_a}
$$

右边的这个东西可以看作是由 $(p_i,f_i+s_i)$ 这类点的两个点构成的直线的斜率，既然 $p_i, x_i$ 单调递增，也就是说斜率需要越来越大，咱就可以维护一个下凸壳。

开一个队列，设 $q_t$ 为队尾元素，那么根据上面的式子，若通过 $q_t,i$ 两个点的直线斜率小于等于通过 $q_{t-1},q_t$ 两点的直线，那么就应该弹出 $q_t$。

最后有的工厂可能没有商品，所以此时会出现相邻两个点构成的直线中 $p_i-p_j=0$，此时咱想到横坐标相同的两个点，显然应该是要纵坐标更小的。

所以若 $y>0$ 就当作是正无穷，反之则为负无穷，若 $y=0$ 则无所谓。

```cpp

/*
 * @Author: Aisaka_Taiga
 * @Date: 2023-11-14 16:17:16
 * @LastEditTime: 2023-11-14 19:42:44
 * @LastEditors: Aisaka_Taiga
 * @FilePath: \Desktop\P2120.cpp
 * The heart is higher than the sky, and life is thinner than paper.
 */
#include <bits/stdc++.h>

#define int long long
#define DB double
#define N 1000010

using namespace std;

inline int read()
{
    int x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){if(c == '-') f = -1; c = getchar();}
    while(c <= '9' && c >= '0') x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
    return x * f;
}

int n, c[N], p[N], x[N], s[N], q[N], f[N], ans = 1e18;

/*
f[i] = min(f[j] + \sum_{k = j + 1}^{i} (x[i] - x[k]) * p[k] + c[i]);
f[i] = min(f[j] + \sum_{k = j + 1}^{i} (x[i] * p[k]) - \sum_{k = j + 1}^{i} x[k] * p[k] + c[i]);
s[i] = \sum_{k = 1}^{i} p[k] * x[k], p[i] = \sum_{k = 1}^{i} p[k];
f[i] = min(f[j] + x[i] * (p[i] - p[j]) - s[i] + s[j] + c[i]);
f[i] = min(f[j] + x[i] * p[i] - x[i] * p[j] - s[i] + s[j] + c[i]);
f[j] = x[i] * p[j] + f[i] - x[i] * p[i] + s[i] - s[j] - c[i];???
*/

inline DB xl(int i, int j)
{
    DB y = f[j] - f[i] + s[j] - s[i];
    if(p[j] == p[i])
    {
        if(y == 0) return 0;
        else
        {
            if(y > 0) return 1e19;
            else return -1e19;
        }
    }
    else return y / (p[j] - p[i]);
    return (f[j] - f[i]) * 1.0 / (p[j] - p[i]);
    // return(p[j] == p[i] ? (!y ? 0 : (y > 0 ? 1e19 : -1e19)) : y / DB(p[j] - p[i]));
}

signed main()
{
    n = read();
    for(int i = 1; i <= n; i ++)
    {
        x[i] = read(), p[i] = read(), c[i] = read();
        s[i] = s[i - 1] + p[i] * x[i];
        p[i] += p[i - 1];
    }
    int h = 1, t = 1;
    for(int i = 1; i <= n; i ++)
    {
        while(h < t && xl(q[h], q[h + 1]) <= x[i]) h ++;
        f[i] = f[q[h]] + x[i] * (p[i] - p[q[h]]) - s[i] + s[q[h]] + c[i];
        // cout << "CAO : " << q[h] << endl;
        while(h < t && xl(q[t - 1], i) <= xl(q[t - 1], q[t])) t --;
        q[++ t] = i;
    }
    h = n; ans = f[n];
    while(h && p[h] - p[h - 1] == 0) h --, ans = min(ans, f[h]);
    cout << ans << endl;
    return 0;
}
```

---

## 作者：Biadocy (赞：5)

[本文同步发表于我的博客园](https://www.cnblogs.com/landsol/p/17766695.html)

令 $f_i$ 表示在 $i$ 工厂建立仓库，$i+1\sim n-1$ 工厂不建立仓库的最小费用。对成品数量 $p$ 做一遍前缀和。

转移直接枚举上一个建立的仓库位置：

$$f_i=\min\{f_j-(p_i-p_j)\times(x_n-x_i)+c_i|j<i\}$$

考虑两个转移点 $j<k$，若 $j$ 对于当前位置 $i$ 更优：

$$f_j-(p_i-p_j)\times(x_n-x_i)+c_i<f_k-(p_i-p_k)\times(x_n-x_i)+c_i$$

$$f_j-f_k<(x_n-x_i)\times(p_i-p_j-p_i+p_k)$$

$$\frac{f_k-f_j}{p_k-p_j}>x_i-x_n$$

$x_i-x_n$ 随着 $i$ 增大单调递增，维护 $(p,f)$ 的下凸包。

---

可惜这个做法被 hack 了，因为 $p_n$ 可能为 $0$，最后一个工厂不一定要建仓库，所以不能在前面就把后面的贡献计算好。

令 $f_i$ 表示只考虑前 $i$ 个工厂并在 $i$ 工厂建立仓库的最小费用。

转移直接枚举上一个建立的仓库位置：

$$f_i=\min\left\{\left.f_j+\left(\sum_{l=j+1}^i(x_i-x_l)\times p_l\right)+c_i\right|j<i\right\}$$

$$f_i=\min\left\{\left.f_j+\left(\sum_{l=j+1}^i x_i\times p_l\right)-\left(\sum_{l=j+1}^i x_l\times p_l\right)+c_i\right|j<i\right\}$$

令 $s_i$ 表示 $x_i\times p_i$ 的前缀和数组，然后对 $p$ 做一遍前缀和：

$$f_i=\min\{f_j+x_i\times(p_i-p_j)-(s_i-s_j)+c_i|j<i\}$$

考虑两个转移点 $j<k$，若 $j$ 对于当前位置 $i$ 更优：

$$f_j+x_i\times(p_i-p_j)-(s_i-s_j)+c_i<f_k+x_i\times(p_i-p_k)-(s_i-s_k)+c_i$$

$$f_j-x_i\times p_j+s_j<f_k-x_i\times p_k+s_k$$

$$f_j-f_k+s_j-s_k<x_i\times p_j-x_i\times p_k$$

$$\frac{f_k-f_j+s_k-s_j}{p_k-p_j}>x_i$$

$x_i$ 随着 $i$ 增大单调递增，维护 $(p,f+s)$ 的下凸包。

**如果中途出现了分母为 $\bm 0$ 的情况，斜率应视为无穷大乘上纵坐标差的符号。**因为下凸包横坐标相同时应保留纵坐标较小的点，加入一个纵坐标更小的点时队首会被弹掉，加入一个纵坐标更大的点时队尾会被弹掉，**所以始终只保留了纵坐标最小的一个点。**

**最后答案就在最后一个 $\bm{p>0}$ 的位置到 $\bm n$ 中。**

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define N 1000005
#define Db double
#define Min(x,y)((x)<(y)?x:y)
#define For(i,x,y)for(i=x;i<=(y);i++)
ll p[N],f[N],s[N];
int x[N],c[N],que[N];
int read()
{
	int A;
	bool K;
	char C;
	C=A=K=0;
	while(C<'0'||C>'9')K|=C=='-',C=getchar();
	while(C>'/'&&C<':')A=(A<<3)+(A<<1)+(C^48),C=getchar();
	return(K?-A:A);
}
Db slope(int j,int k)
{
	Db y=f[k]-f[j]+s[k]-s[j];
	return(p[k]==p[j]?(!y?0:(y>0?1e19:-1e19)):y/Db(p[k]-p[j]));
}
int main()
{
	int n,i,head,tail;
	n=read();
	head=tail=1;
	For(i,1,n)
	{
		x[i]=read(),p[i]=read(),c[i]=read();
		s[i]=s[i-1]+x[i]*p[i];
		p[i]+=p[i-1];
	}
	For(i,1,n)
	{
		while(head<tail&&slope(que[head],que[head+1])<=x[i])head++;
//		cerr<<que[head]<<' '<<i<<endl;
		f[i]=f[que[head]]+x[i]*(p[i]-p[que[head]])-(s[i]-s[que[head]])+c[i];
		while(head<tail&&slope(que[tail-1],que[tail])>=slope(que[tail-1],i))tail--;
		que[++tail]=i;
	}
	i=n;
	while(i&&!(p[i]-p[i-1]))i--;
//	cerr<<i<<endl;
	For(i,i,n-1)f[n]=Min(f[n],f[i]);
	cout<<f[n];
	return 0;
}
//#include<bits/stdc++.h>
//using namespace std;
//typedef long long ll;
//#define N 1000005
//#define Db double
//#define Min(x,y)((x)<(y)?x:y)
//#define For(i,x,y)for(i=x;i<=(y);i++)
//ll p[N],f[N];
//int x[N],c[N],que[N];
//int read()
//{
//	int A;
//	bool K;
//	char C;
//	C=A=K=0;
//	while(C<'0'||C>'9')K|=C=='-',C=getchar();
//	while(C>'/'&&C<':')A=(A<<3)+(A<<1)+(C^48),C=getchar();
//	return(K?-A:A);
//}
//Db slope(int j,int k)
//{
//	return Db(f[k]-f[j])/Db(p[k]-p[j]);
//}
//int main()
//{
//	int n,i,head,tail;
//	n=read();
//	head=tail=1;
//	For(i,1,n)
//	{
//		x[i]=read(),p[i]=read(),c[i]=read();
//		f[0]-=p[i]*x[i];
//		p[i]+=p[i-1];
//	}
//	f[0]+=p[n]*x[n];
//	For(i,1,n-1)
//	{
//		while(head<tail&&slope(que[head],que[head+1])<=x[i]-x[n])head++;
//		f[i]=f[que[head]]-(p[i]-p[que[head]])*(x[n]-x[i])+c[i];
//		while(head<tail&&slope(que[tail-1],que[tail])>=slope(que[tail-1],i))tail--;
//		que[++tail]=i;
//	}
//	For(i,1,n-1)f[0]=Min(f[0],f[i]);
//	cout<<f[0]+c[n];
//	return 0;
//}
```

---


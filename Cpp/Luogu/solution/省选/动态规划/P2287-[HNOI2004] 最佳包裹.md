# [HNOI2004] 最佳包裹

## 题目描述

发强公司生产了一种金属制品，是由一些笔直的金属条连接起来的，金属条和别的金属条在交点上被焊接在了一起。现在由于美观需要，在这个产品用一层特殊的材料包裹起来。公司为了节约成本，希望消耗的材料最少（不计裁剪时的边角料的损失）。

编程，输入包括该产品的顶点的个数，以及所有顶点的坐标；请计算出包裹这个产品所需要的材料的最小面积。结果要求精确到小数点后第六位（四舍五入）。

## 样例 #1

### 输入

```
4 
0 0 0
1 0 0
0 1 0
0 0 1
```

### 输出

```
2.366025```

# 题解

## 作者：NOI_Winner (赞：2)

题意简述：求 $n$ 个点的三维凸包的表面积。（$n \le 100$）

先对所有点的位置进行微小扰动，以防止出现四点共面的情况。

我们可以枚举这些点能够组成的所有三角形，如果剩余所有点全部在该三角形所在平面的同一侧，那这个三角形就在这个三维凸包上，直接让答案加上它的面积即可。

怎样求若干个点是否在三角形所在平面的同一侧呢？设三角形为 $\triangle ABC$，求出 $\overrightarrow{AB} \times \overrightarrow{AC}$（叉乘），也就是该平面的法向量，记为向量 $\boldsymbol{v} $。枚举剩余的点，设当前点为 $D$，求出 $\overrightarrow{AD} \cdot \boldsymbol{v}$（点乘）。如果存在两个点求出来的值一正一负，就说明这两个点在平面的两侧。三角形的面积即为 $\frac{|\boldsymbol{v}|}{2}$。

算法的时间复杂度为 $O(n^4)$。

代码示例：
```cpp
#include <iostream>
#include <random>
#include <ctime>
#include <limits> 
#include <cmath>

using namespace std;

constexpr int maxn = 100;
constexpr double eps = 1e-10;
mt19937 rd(time(nullptr));

struct point
{
	double x, y, z;
} a[maxn + 5];

struct vec
{
	double x, y, z;
	vec(double x, double y, double z) : x{x}, y{y}, z{z} {}
};

inline double get_delta()    // 微小扰动的值
{ return (1. * rd() / numeric_limits<unsigned>::max() - 0.5) * eps; }

inline vec operator-(const point& a, const point& b)      // 求出向量
{ return {b.x - a.x, b.y - a.y, b.z - a.z}; }

inline double operator*(const vec& a, const vec& b)      // 点乘
{ return a.x * b.x + a.y * b.y + a.z * b.z; }

inline vec operator^(const vec& a, const vec& b)     // 叉乘
{ return {a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x}; }

inline double get_mod(const vec& a)     // 求向量的模长
{ return sqrt(a.x * a.x + a.y * a.y + a.z * a.z); }

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	(cout << fixed).precision(6);
	
	int n; cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i].x >> a[i].y >> a[i].z;
	for (int i = 1; i <= n; i++)    // 微小扰动
	{
		a[i].x += get_delta();
		a[i].y += get_delta();
		a[i].z += get_delta();
	}
	
	double ans = 0;
	for (int i = 1; i <= n; i++)
		for (int j = i + 1; j <= n; j++)
			for (int k = j + 1; k <= n; k++)
			{
				vec cur = (a[j] - a[i]) ^ (a[k] - a[i]);
				bool flag1 = false, flag2 = false;
				for (int l = 1; l <= n; l++)
					if (i != l && j != l && k != l)
					{
						if (cur * (a[l] - a[i]) > 0)
							flag1 = true;
						else
							flag2 = true;
					}
				if (!flag1 || !flag2)
					ans += get_mod(cur) / 2;   // 加上面积
			}
	cout << ans << endl;
	
	return 0;
}
```

---

## 作者：SuperJvRuo (赞：2)

显然这道题是要求三维凸包的表面积，常用的方法是卷包裹法和增量法，~~我都不会~~。此题数据范围较小，可以直接暴力$O(n^4)$水过。精通计算几何的大佬可以介绍一下卷包裹法和增量法。

$O(n^3)$枚举点集中的三个点，再用$O(n)$扫一遍其他点，如果其他点都在这三个点形成的面的同一侧，那么这个面就在凸包上。

那么如何判断点$P$在面$ABC$的哪一侧呢？只要求出面$ABC$的一个法向量（叉积即可），再用点积算一下$\vec{AP}$与法向量的夹角余弦值即可。余弦为正的点在一侧，余弦为负的在另一侧。

但是只这么做会WA的很惨，因为会有四点共面的情况存在。你需要让点抖一抖来避免共面的出现。

然后，见证暴力的奇迹吧：

```
#include<cstdio>
#include<cmath>
#include<cstdlib> 
#define EPS 1e-10
//设EPS为1e-9时爆精度只得了75分，可能是脸黑
struct Point
{
	double x,y,z;
}point[105];
int n;

typedef Point Vector;

double rand01()
{
	return rand()/(double)RAND_MAX;
}

double randeps()
{
	return (rand01()-0.5)*EPS;
}

Vector add_noise(Vector p)
{
	return (Vector){p.x+randeps(),p.y+randeps(),p.z+randeps()};
}//生成一个一定EPS内的抖动

Vector operator - (Vector a,Vector b)
{
	return (Vector){a.x-b.x,a.y-b.y,a.z-b.z};
}//减法

double mod(Vector a)
{
	return sqrt(a.x*a.x+a.y*a.y+a.z*a.z);
}//模长

double Dot(Vector a,Vector b)
{
	return a.x*b.x+a.y*b.y+a.z*b.z;
}//点积，也就是数量积

Vector Cross(Vector a,Vector b)
{
	return (Vector){a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x};
}//叉积，也就是向量积

double area(Vector a,Vector b)
{
	return 0.5*mod(Cross(a,b));
}//面积，叉积模长的一半

bool check(int p1,int p2,int p3)
{
	double head=0,now;
	Vector normal=Cross(point[p1]-point[p2],point[p2]-point[p3]);//将叉积作为法向量
	for(int i=0;i<n;++i)
	{
		if(i!=p1&&i!=p2&&i!=p3)
		{
			if((now=Dot(point[i]-point[p1],normal))*head<0)
			{//点积与余弦值一定同号
				return false;
			}
			else
			{
				head=now;
			}
		}
	}
	return true;
}

int main()
{
	scanf("%d",&n);
	double res=0;
	for(int i=0;i<n;++i)
	{
		scanf("%lf %lf %lf",&point[i].x,&point[i].y,&point[i].z);
		point[i]=add_noise(point[i]);//让点抖动一下
	}
	for(int i=0;i<n;++i)
	{
		for(int j=i+1;j<n;++j)
		{
			for(int k=j+1;k<n;++k)
			{
				if(check(i,j,k))
				{//所有的点都在一侧
					res+=area(point[i]-point[j],point[j]-point[k]);//就加上这个面的面积
				}
			}
		}
	}
	printf("%.6lf",res);
	return 0;
}
```

---

## 作者：15066212pp (赞：0)

# 题目大意

给出空间中 $n$ 个点，求三维凸包表面积。

------------

# 题解

有两种方法，穷举法和增量法，增量法时间复杂度更低。

## 增量法核心逻辑：

1. 初始化：读取输入点的数据，包括点的坐标和个数。对于每个点，为了避免共面，通常会给每个点添加一个微小的抖动。

2. 创建初始凸包：选择前三个点构成两个面，并将它们加入到凸包中。这两个面之间的边界上的边将用于构建新的面。

3. 添加点：对于剩余的每个点，分别判断它是否位于凸包的上方。如果点在某个面的下方，将该面保留在凸包中；否则，舍弃该面。

4. 更新标记数组：更新标记数组，用于记录点与面之间的关系。

5. 构建新面：遍历凸包中的每个面，找到边界上的边，即一个边既在某个面的上方，又在某个面的下方。根据这两个边和新添加的点构建新的面，并加入到凸包中。

6. 更新凸包：用新构建的面替换原来的面，更新凸包。

7. 返回凸包：返回最终的凸包的集合。

## 穷举法核心逻辑：

1. 初始化：从输入中读取点的个数，并依次读取每个点的坐标，将带有微小抖动的点添加到点集中。

2. 遍历点：对于点集中的每个三个点的组合，构造一个三角形对象。

3. 检查共面性：调用函数，检查当前三角形是否满足共面性质。如果满足，则跳过该三角形。

4. 计算面积：如果当前三角形不共面，则调用函数计算其面积，并将其累加到总面积中。

------------

## 增量法代码

------------

```cpp
#include<bits/stdc++.h>

using namespace std;

const double eps = 1e-12;

double rand_eps() {
    return ((double) rand() / RAND_MAX - 0.5) * eps; // NOLINT(*-msc50-cpp)
}

class P {
public:
    double x, y, z;

    P() {
        x = 0;
        y = 0;
        z = 0;
    }

    P(double x, double y, double z) {
        this->x = x;
        this->y = y;
        this->z = z;
    };

    // 返回点到原点的距离
    [[nodiscard]] double len() const {
        return sqrt(x * x + y * y + z * z);
    }

    // 点的加法
    P operator+(const P &rhs) const {
        return {x + rhs.x, y + rhs.y, z + rhs.z};
    }

    // 点的减法
    P operator-(const P &rhs) const {
        return {x - rhs.x, y - rhs.y, z - rhs.z};
    }

    // 叉乘
    P operator^(const P &rhs) const {
        return {y * rhs.z - z * rhs.y, z * rhs.x - x * rhs.z, x * rhs.y - y * rhs.x};
    }

    // 点乘
    double operator*(const P &rhs) const {
        return x * rhs.x + y * rhs.y + z * rhs.z;
    }

    bool operator==(const P &rhs) const {
        return x == rhs.x &&
               y == rhs.y &&
               z == rhs.z;
    }

    bool operator!=(const P &rhs) const {
        return !(rhs == *this);
    }

    bool operator<(const P &rhs) const {
        if (x != rhs.x) {
            return x < rhs.x;
        }
        if (y != rhs.y) {
            return y < rhs.y;
        }
        return z < rhs.z;
    }
};

vector<P> point;

class Triangle {
public:
    int key[3]{};//point元素的索引

    Triangle() = default;

    Triangle(const int &k1, const int &k2, const int &k3) {
        key[0] = k1;
        key[1] = k2;
        key[2] = k3;
    }

    [[nodiscard]] P norm() const {//法向量
        int a = key[0];
        int b = key[1];
        int c = key[2];
        return (point[b] - point[a]) ^ (point[c] - point[a]);
    }

    [[nodiscard]] double area() const {
        return norm().len() / 2;
    }

    bool above(P p) {
        int a = key[0];
        return (p - point[a]) * norm() > 0;
    }
};

vector<Triangle> hull() {
    int n = (int) point.size(); // 获取点集的大小
    vector<Triangle> planes; // 存储凸包的面

    // 初始情况下，将前三个点构成两个面添加到凸包中
    planes.emplace_back(0, 1, 2);
    planes.emplace_back(2, 1, 0);

    vector<vector<bool>> mark(n, vector<bool>(n, false)); // 记录已经构建的面

    // 对剩余的点进行处理
    for (int i = 3; i < n; i++) {
        vector<Triangle> temp; // 临时存储新增的面
        for (auto &plane: planes) {
            bool flag = plane.above(point[i]); // 判断点是否位于面的上方
            if (!flag) {
                temp.push_back(plane); // 如果点在面的下方，将面保留在凸包中
            }
            // 更新 mark 数组，标记点与面的关系
            for (int k = 0; k < 3; k++) {
                int a = plane.key[k];
                int b = plane.key[(k + 1) % 3];
                mark[a][b] = flag;
            }
        }

        // 遍历已有的每个面，找到边界上的边，构建新的面
        for (auto &plane: planes) {
            for (int k = 0; k < 3; k++) {
                int a = plane.key[k];
                int b = plane.key[(k + 1) % 3];
                if (mark[a][b] && !mark[b][a]) {
                    temp.emplace_back(a, b, i); // 添加新的面到凸包中
                }
            }
        }

        planes = temp; // 更新凸包中的面
    }

    return planes; // 返回凸包的面
}

// 为了避免共面,我们通常会对每个点添加一个微小抖动
P noise() {
    return {rand_eps(), rand_eps(), rand_eps()};
}

// 读取下一个整数
int nextInt() {
    int temp;
    cin >> temp;
    return temp;
}

// 读取下一个浮点数
double nextDouble() {
    double temp;
    cin >> temp;
    return temp;
}


void init() {
    point.clear();

    int n = nextInt();
    for (int i = 0; i < n; i++) {
        double x = nextDouble();
        double y = nextDouble();
        double z = nextDouble();
        point.emplace_back(P(x, y, z) + noise()); // 添加带有抖动的点到点集中
    }

    sort(point.begin(), point.end());
}

void solve() {
    cout << fixed << setprecision(6);

    init();
    vector<Triangle> plane = hull();
    double res = 0;
    for (auto &i: plane) {
        res += i.area();
    }
    cout << res << endl;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    solve();
    return 0;
}
```

------------

## 穷举法代码

------------

```cpp
#include <bits/stdc++.h>

using namespace std;

const double eps = 1e-12; // 抖动的容差

// 生成抖动值
double rand_eps() {
    return ((double) rand() / RAND_MAX - 0.5) * eps; // NOLINT(*-msc50-cpp)
}

class P {
public:
    double x, y, z;

    P() {
        x = 0;
        y = 0;
        z = 0;
    }

    P(double x, double y, double z) {
        this->x = x;
        this->y = y;
        this->z = z;
    };

    // 返回点到原点的距离
    [[nodiscard]] double len() const {
        return sqrt(x * x + y * y + z * z);
    }

    // 点的加法
    P operator+(const P &rhs) const {
        return {x + rhs.x, y + rhs.y, z + rhs.z};
    }

    // 点的减法
    P operator-(const P &rhs) const {
        return {x - rhs.x, y - rhs.y, z - rhs.z};
    }

    // 叉乘
    P operator^(const P &rhs) const {
        return {y * rhs.z - z * rhs.y, z * rhs.x - x * rhs.z, x * rhs.y - y * rhs.x};
    }

    // 点乘
    double operator*(const P &rhs) const {
        return x * rhs.x + y * rhs.y + z * rhs.z;
    }

    bool operator==(const P &rhs) const {
        return x == rhs.x &&
               y == rhs.y &&
               z == rhs.z;
    }

    bool operator!=(const P &rhs) const {
        return !(rhs == *this);
    }

    bool operator<(const P &rhs) const {
        if (x != rhs.x) {
            return x < rhs.x;
        }
        if (y != rhs.y) {
            return y < rhs.y;
        }
        return z < rhs.z;
    }
};


vector<P> point; // 存储输入的点集

class Triangle {
public:
    int key[3]{};//point元素的索引

    Triangle() = default;

    Triangle(const int &k1, const int &k2, const int &k3) {
        key[0] = k1;
        key[1] = k2;
        key[2] = k3;
    }

    [[nodiscard]] P norm() const {//法向量
        int a = key[0];
        int b = key[1];
        int c = key[2];
        return (point[b] - point[a]) ^ (point[c] - point[a]);
    }

    [[nodiscard]] double area() const {
        return norm().len() / 2;
    }

    bool above(P p) {
        int a = key[0];
        return (p - point[a]) * norm() > 0;
    }
};

// 检查三个点构成的三角形是否满足共面性质
bool check(Triangle tri) {
    int n = (int) point.size();
    bool a = false;
    bool b = false;
    for (int q = 0; q < n; q++) {
        if (q == tri.key[0] || q == tri.key[1] || q == tri.key[2]) {
            continue;
        }
        bool now = tri.above(point[q]);
        if (now) {
            a = true;
        } else {
            b = true;
        }
        if (a && b) {
            return true;
        }
    }
    return false;
}

// 读取下一个整数
int nextInt() {
    int temp;
    cin >> temp;
    return temp;
}

// 读取下一个浮点数
double nextDouble() {
    double temp;
    cin >> temp;
    return temp;
}

// 为了避免共面,我们通常会对每个点添加一个微小抖动
P noise() {
    return {rand_eps(), rand_eps(), rand_eps()};
}

void init() {
    point.clear();

    int n = nextInt(); // 读取点的个数
    for (int i = 0; i < n; i++) {
        double x = nextDouble();
        double y = nextDouble();
        double z = nextDouble();
        point.emplace_back(P(x, y, z) + noise()); // 添加带有抖动的点到点集中
    }

    sort(point.begin(), point.end());
}

void solve() {
    cout << fixed << setprecision(6);
    
    init();
    
    int n = (int) point.size();
    double ans = 0; // 总面积
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            for (int k = j + 1; k < n; k++) {
                Triangle tri(i, j, k);
                if (check(tri)) { // 检查三个点是否满足共面性质
                    continue;
                }
                ans += tri.area(); // 计算三角形面积并累加
            }
        }
    }

    cout << ans << endl; // 输出总面积
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    solve();
    return 0;
}
```




---

## 作者：nofall (赞：0)

## 题目意思

给出立体的$n$个点，求三维凸包的面积

## 分析

裸的三维凸包板子，不会左转模板区。


```cpp
#include <bits/stdc++.h>
const double eps = 1e-19;
using namespace std;
int n, i, j, k, c0, c1;
double now, ans;
struct P {
    double x, y, z;
} a[110], tmp;
double len(const P& a) { return sqrt(a.x * a.x + a.y * a.y + a.z * a.z); }
P operator+(const P& a, const P& b) { return (P){ a.x + b.x, a.y + b.y, a.z + b.z }; }
P operator-(const P& a, const P& b) { return (P){ a.x - b.x, a.y - b.y, a.z - b.z }; }
P operator&(const P& a, const P& b) { return (P){ a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x }; }
double operator|(const P& a, const P& b) { return a.x * b.x + a.y * b.y + a.z * b.z; }
bool operator!=(const P& a, const P& b) { return a.x != b.x || a.y != b.y || a.z != b.z; }
bool check(int i, int j, int k) {
    tmp = (a[j] - a[i]) & (a[k] - a[i]);
    c0 = c1 = 0;
    for (int l = 1; l <= n; l++)
        if (l != i && l != j && l != k) {
            now = tmp | (a[l] - a[i]);
            if (now > 0)
                c1++;
            if (now < 0)
                c0++;
            if (c0 > 0 && c1 > 0)
                return 0;
        }
    return 1;
}
int main() {
    for (scanf("%d", &n), i = 1; i <= n; i++)
        scanf("%lf%lf%lf", &a[i].x, &a[i].y, &a[i].z),
            a[i] = a[i] + (P){ rand() * eps, rand() * eps, rand() * eps };
    for (i = 1; i <= n; i++)
        for (j = i + 1; j <= n; j++)
            for (k = j + 1; k <= n; k++)
                if (check(i, j, k))
                    ans += len((a[k] - a[i]) & (a[j] - a[i]));
    return !printf("%lf\n", ans * 0.5);
}
```

---


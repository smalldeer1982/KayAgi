# 合并神犇

## 题目背景

loidc 来到了 NOI 的赛场上，他在那里看到了好多神犇。


## 题目描述

神犇们现在正排成一排在刷题。每个神犇都有一个能力值 $p_i$。loidc 认为坐在附近的金牌爷能力参差不齐非常难受。于是 loidc 便想方设法对神犇们进行人道主义合并。

loidc 想把神犇的能力值排列成从左到右单调不减。他每次可以选择一个神犇，把他合并到两侧相邻的神犇上。合并后的新神犇能力值是以前两位犇的能力值之和。每次合并完成后，被合并的两个神犇就会消失。合并后的新神犇不能再分开（万一他俩有女朋友咋办）因此每次合并后神犇的总数会减 1。

loidc 想知道，想治好他的强迫症需要合并多少次。


## 说明/提示

对于 $50\%$ 的数据，$0\lt n \le 5000$。

对于 $100\%$ 的数据，$0\lt n \le2\times 10^5$，$0\lt p_i\le 2147483647$，$p$ 均为随机生成。


## 样例 #1

### 输入

```
8
1 9 9 4 1 2 2 9```

### 输出

```
3```

# 题解

## 作者：fyfy (赞：31)

听说这题可以$n^2$水过去，

不过这里介绍一种O(n)的做法。

$f[i]$为第$[1,i]$位合并的次数

$pre[i]$为第$[1,i]$位最末尾的数

$j$为满足$sum[i]-sum[j]>=pre[j]$的最大数

$f[i]=f[j]+i-j-1$

$pre[i]=sum[i]-sum[j]$

显然$pre[i]$越小越好，这样找到一个就可以退出。

所以可以直接用单调队列优化。

时间复杂度$O(n)$。

代码，注意开$\texttt{long~long}$：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef int _int;
#define int long long

const int N=200010;
int head,tail=1;
int n,f[N],pre[N],sum[N],q[N];

_int main()
{
    ios::sync_with_stdio(false);
    cin>>n;
    int x;
    for (int i=1;i<=n;++i)
        cin>>x,sum[i]=sum[i-1]+x;
    for (int i=1;i<=n;++i) {
        while (head+1<tail&&sum[i]>=sum[q[head+1]]+pre[q[head+1]])
            ++head;
        f[i]=f[q[head]]+1;
        pre[i]=sum[i]-sum[q[head]];
        while (head<tail&&sum[q[tail-1]]+pre[q[tail-1]]>sum[i]+pre[i])
            --tail;
        q[tail++]=i;
    }
    cout<<n-f[n];
    return 0;
}
```

---

## 作者：kakakaka (赞：24)

这道题很容易想到一个**错误**的贪心算法：

1.记录一个last表示上一个分组的最后一个数的下标，lastsum表示上一组的总和。

2.然后每次向当前组加一个数，直到它的总和>=lastsum，每次计算一下需要合并的次数。

3.最后如果还有数没有合并完的话就把它们合并到上一组中。

WA到不行，只有10分，我估计这道题大部分10分的大佬们都是这么做的，先附上代码，下文再阐述为什么这种做法是错的。

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
using namespace std;
int n,a[2000001],sum[2000001],cnt;
int main()
{
    int i;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    {
    scanf("%d",&a[i]);
    sum[i]=sum[i-1]+a[i];
    }
    int last=0,lastsum=0;
    for(i=1;i<=n;i++)
    {
    if(sum[i]-sum[last]>=lastsum)
    {
        lastsum=sum[i]-sum[last];
        cnt+=i-last-1;
        last=i;
    }
    }
    if(i!=last&&sum[n]-sum[last]<lastsum)cnt+=i-last-1;
    printf("%d\n",cnt);
    return 0;
}
```
那么为什么这种做法是错的呢？
我们考虑这样一组数：

3 2 2 2 6 ……

如果我们用的是贪心的话，那么我们第一步就会把前两个2合并，使序列变成：3 4 2 6 ……

然后因为4已经比3要大了，接下来贪心算法就会直接将2和6合并，使序列变成：3 4 8……

那么这个序列的第4组数就需要大于等于8 。

换一种想法，如果我们直接将三个2合并，将序列变成：3 6 6……

那么接下来的第4组数就只需要大于等于6，这种方案显然比贪心算法求出的方案更优，所以这种贪心并不可行。


那么这道题的正解是什么呢，其实很简单，动态规划。

f[i]表示前 i 个数最少合并的次数。g[i]表示前 i 个数在满足合并了f[i]次的条件下最后一组的总和最小是多少。sum[i]是前缀和。

然后
f[i]=f[j]+i-j-1;

g[i]=sum[i]-sum[j];

数据比较水，O(n^2)也可以过。

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
typedef long long lol;
lol f[200001],g[200001];
lol a[200001],sum[200001];
lol n;
int main()
{
    lol i,j;
    scanf("%lld",&n);
    for(i=1;i<=n;i++)
    {
    scanf("%lld",&a[i]);
    sum[i]=sum[i-1]+a[i];
    }
    for(i=1;i<=n;i++)
    {
    for(j=i-1;j>=0;j--)if(sum[i]-sum[j]>=g[j])break;
    f[i]=f[j]+i-j-1;
    g[i]=sum[i]-sum[j];
    }
    printf("%lld\n",f[n]);
    return 0;
}
注：本文代码是在ubuntu的emacs环境下写的，如果代码缩进有问题的话尽请谅解。（当然更希望审核员帮我调一下代码的缩进，机房已经没有一台windows了）
```

---

## 作者：小蒟蒻皮皮鱼 (赞：17)

### 做法：单调队列优化 DP

看到数据范围不难想到一维 DP 数组 $f_i$ 表示将 $1$ 到 $i$ 的数合并后满足单调不降的最小合并次数。

考虑 $f_i$ 是由什么转移得到的。发现     $f_i$ 并不只是和 $f_{i-1}$ 有关，实际上，由于合并的性质， $f_i$ 可以由前面任意一个 $f_j$ 得到，但前提是由     $i$ 到 $j$ 合并得到的数要不小于为了得到 $f_j$ 所合并后的序列的最后一个数。

我们设 $s_i$ 表示 $p_i$ 的前缀和， $last_i$ 表示得到 $f_j$ 所合并后的序列的最后一个数。那么转移方程就是
$$
f_i=min\{f_j+i-j-1\}(s_i-s_j\geq last_j)
$$
这样暴力转移是 $O(n^2)$ 的，考虑优化转移。

对于
$$
k=j+1
$$


有
$$
f_k\leq f_j+1
$$


证明可以用反证法：如果$f_k>f_j+1$，我们只需要在$f_j$的基础上将新加入的数与前面合并即可得到$f_k=f_j+1$。

而$j$每增加一，$f_i+i-j-1$一定会减少$1$。也就是说我们要找的$j$其实是满足$s_i-s_j\geq last_j$的最大的$j$。

对式子
$$
s_i-s_j\geq last_j
$$


进行变形得到
$$
s_j+last_j\leq s_i
$$


发现 $s_i$ 是单调上升的，也就是对于一个固定的 $j$ 来说， $s_j+last_j$ 的值越小，就越有可能在更多的转移中被选择。

对于 $j<k$ ，如果
$$
s_k+last_k\leq s_j+last_j
$$


也就是 $k$ 在比 $j$ 后入队的同时（即比  $j$ 优），还比 $j$ 更容易在更多的选择中被转移，那么 $j$ 也就没用了，因为无论如何能选择 $j$ 的情况一定可以选择 $k$ 。

单调队列代码：

```cpp
	int l = 1, r = 0;
	for(int i = 1; i <= n; i ++)
	{
		while(l <= r && s[q[l]] + last[q[l]] <= s[i]) l ++;
		f[i] = f[q[l - 1]] + i - q[l - 1] - 1;
		last[i] = s[i] - s[q[l - 1]];
		while(l <= r && s[i] + last[i] <= s[q[r]] + last[q[r]]) r --;
		q[++r] = i;
	}
```



---

## 作者：Flan (赞：10)

$\quad$ 看到这道题，觉得和[P5665 划分](https://www.luogu.com.cn/problem/P5665)很像，当时考场上我写的就是类似一些题解的 $O(n^2)$ 算法，完美卡成 $64$ 分。  
$\quad$ 我详细介绍一下 $O(n)$ 的单调队列优化算法，也当作是自己学习单调队列的总结吧。  
$\quad$ 单调队列，顾名思义，具有单调性。它本质上是一个双端队列，队头代表当前的最优解（这一点很像优先队列）。
```cpp
for(int i = 1; i <= n; ++i){
	while(!q.empty() && out_of_date(q.front()))
		q.pop_front();
	while(!q.empty() && notBetterThan(q.back(), i))
		q.pop_back();
	q.push_back(i);
	operate(q.front());
}
```
$\quad$ 结合这一份样例代码分析。为了便于理解，这里使用 STL 中的 deque 充当载体。  
$\quad$ 第一个 while 语句每次将处于队列前端的一些元素弹出队列：这些元素虽然最优，然而已经“过期”了，因而必须被排除。由于每个元素的“过期时间”具有单调性，即处于前面的元素一定比后面的更早“过期”，这一操作可以保证所有“过期”元素都被排除。  
$\quad$ 第二个 while 语句每次将处于队列后端的一些元素弹出队列：这些元素本身不如将要加入的新元素 $i$“优”，而且还会比 $i$ 更早过期，所以必须排除，以维护队列的单调性。  
$\quad$ operate 函数代表每次我们需要对当前最优元素进行的操作。  
$\quad$ 总结一下，即单调队列具有 $2$ 个“单调性”：  
$\qquad\bullet$ 前面的元素比后面的元素“优”，元素的“优劣”单调递减，越靠前的元素越“优”，越靠后的元素越“差”。  
$\qquad\bullet$ 前面的元素比后面的元素“老”，元素的“年龄”单调递减，越靠前的元素越先“过期”，越靠后的元素越后“过期”。  
$\quad$ 为了维护这 $2$ 个“单调性”，需要 $2$ 个 while 语句。由于队列总共只进入过 $n$ 个元素，所以弹出操作也最多只会执行 $n$ 次，可以保证时间复杂度。  
$\quad$ 那么为什么当前范围内最“优”的元素就一定是队首呢？分析一下，满足“当前范围内最优”的元素具有以下性质：  
$\qquad\bullet$ 范围不存在任何元素更“优”，即在所有未“过期”元素中，它是最“优”的。  
$\qquad\bullet$ 在范围内，即未“过期”。  
$\quad$ 可以证明，以上两点是“当前范围内最优”的充要条件。而队列中不存在“过期”元素，具有单调性，且所有范围内元素都被加入过队列，所有弹出元素都不满足第 $1$ 点或第 $2$ 点，那么显然队首就是“当前范围内最优”的元素。  
$\quad$ 单调队列和动态规划又有什么关系呢？它不但可以优化背包 dp 和像这样的普通 dp，还可以优化斜率优化 dp。结合这道题，我们可以具体地感受单调队列的力量。  
$\quad$ 不难得到两种转移方程：  
$\qquad$ $\mathrm {I.}$  
$\qquad\quad\bullet$ $dp_i$ 表示使 $[1,n]$ 区间满足要求的最少合并次数，$a_i$ 表示对应的最后一个神犇的能力值，$s$是前缀和。  
$\qquad\quad\bullet$ $dp_i = dp_j + i - j - 1, a_i = s_i - s_j(s_i - s_j \geq a_j)$。  
$\qquad$ $\mathrm {II.}$  
$\qquad\quad\bullet$ $dp_i$ 表示使 $[1,n]$ 区间满足要求而保留的最多神犇数，$a_i$ 表示对应的最后一个神犇的能力值，$s$ 是前缀和。  
$\qquad\quad\bullet$ $dp_i = dp_j + 1,a_i = s_i - s_j(s_i - s_j \geq a_j)$。  
$\quad$ 其实这两种方程本质上是完全一样的。这里我以 $\mathrm {II}$ 为例简单讲解一下。  
$\quad$ 要维护这样的转移方程，需要对一般的单调队列做一些更改。
```cpp
for(int i = 1; i <= n; ++i){
	while(q.size() > 1 && a[q[1]] + s[q[1]] <= s[i])
		q.pop_front();
	dp[i] = dp[q.front()] + 1, a[i] = s[i] - s[q.front()];
	while(!q.empty() && a[i] + s[i] <= a[q.back()] + s[q.back()])
		q.pop_back();
	q.push_back(i);
}
```
$\quad$ 可以得到，$dp_i$ 具有单调性，即 $\forall \, i > j$，有 $dp_i \geq dp_j$。由于 $dp_i = dp_j + 1$，为了能保留尽量多的神犇，$j = max\left\{ j \, | \, s_i - s_j \geq a_j \right\}$，即在所有满足限制的 $j$ 中选取最大的那一个转移。  
$\quad$ 对限制条件 $s_i - s_j \geq  a_j$ 稍作变换，可以得到 $a_j + s_j \leq s_i$，由于 $s_i$ 仅与 $i$ 本身有关且单调不减，即 $s_i$ 具有单调性，那么 $a_j + s_j$ 越小，$j$ 就越后“过期”。  
$\quad$ 事实上，$j$ 越大越“优”，且 $a_j + s_j$ 越大也越容易“过期”。这样的 $j$，具有单调性，可以用单调队列来维护。  
$\quad$ 大多数单调队列以第一个 while 去除“过期”元素，以第二个 while 去除不够“优”的元素，而这道题的单调队列却以第一个 while 去除不够“优”的元素，以第二个 while 去除“更容易‘过期’”的元素。即，这道题的单调队列是“反”的。  
$\quad$ 如以上代码中的第一个 while，既然 $q_1$ 比 $q_0$ 更晚入队，说明 $q_1 > q_0$，$q_1$ 比 $q_0$“优”。而 $a_{q_1} + s_{q_1} \leq s_i$，说明 $q_1$ 也没有“过期”，那为什么不选取 $q_1$ 转移呢？因此要弹出 $q_1$。  
$\quad$ 在第二个 while 中，更容易“过期”的元素被弹出了。既然 $a_i + s_i \leq a_{q_{back}} + s_{q_{back}}$，说明 $i$ 比 $q_{back}$ 更晚“过期”，且 $i > j$，即 $i$ 比 $j$ 优。那么为什么不把既容易“过期”，又不“优”的 $q_{back}$ 弹出呢？    
$\quad$ 这样，这道题就用单调队列以 $O(n)$ 的复杂度完全解决了。  
$\quad$ 为了避免 STL 的一些可能出现的问题，常用数组模拟 deque。具体的模拟方法可以用如下的类清晰地表示：
```cpp
template <class Tp>
class Deque{
	private:
		Tp q[MAXN];
		int head, tail;
	public:
		Deque(){
			head = 0, tail = -1;
		}
		Tp& operator[](const int& x){
			return q[x + head];
		}
		Tp& front(void){
			return q[head];
		}
		Tp& back(void){
			return q[tail];
		}
		void push_back(const Tp& x){
			q[++tail] = x;
		}
		void pop_front(void){
			++head;
		}
		void pop_back(void){
			--tail;
		}
		int size(void){
			return tail - head + 1;
		}
		bool empty(void){
			return tail < head;
		}
};
```
$\quad$ 使用数组优化后，得到整题代码：
```cpp
#include <stdio.h>

const int MAXN = 2e5 + 19;

int n, dp[MAXN], q[MAXN], head, tail;
long long s[MAXN], a[MAXN];

int main(){
	scanf("%d", &n);
	for(int i = 1; i <= n; ++i)
		scanf("%lld", s + i), s[i] += s[i - 1];
	for(int i = 1; i <= n; ++i){
		while(head < tail && a[q[head + 1]] + s[q[head + 1]] <= s[i])
			++head;
		dp[i] = dp[q[head]] + 1, a[i] = s[i] - s[q[head]];
		while(head <= tail && a[i] + s[i] <= a[q[tail]] + s[q[tail]])
			--tail;
		q[++tail] = i;
	}
	printf("%d\n", n - dp[n]);
	return 0;
}
```
$\quad$ 如果采用 $\mathrm I$ 的做法，代码就应当是这样的：
```cpp
#include <stdio.h>

const int MAXN = 2e5 + 19;

int n, dp[MAXN], q[MAXN], head, tail;
long long s[MAXN], a[MAXN];

int main(){
	scanf("%d", &n);
	for(int i = 1; i <= n; ++i)
		scanf("%lld", s + i), s[i] += s[i - 1];
	for(int i = 1; i <= n; ++i){
		while(head < tail && a[q[head + 1]] + s[q[head + 1]] <= s[i])
			++head;
		dp[i] = dp[q[head]] + i - q[head] - 1, a[i] = s[i] - s[q[head]];
		while(head <= tail && a[i] + s[i] <= a[q[tail]] + s[q[tail]])
			--tail;
		q[++tail] = i;
	}
	printf("%d\n", dp[n]);
	return 0;
}
```
$\quad$ 可以发现，它们的写法几乎是一样的，只有两行不同。

---

## 作者：夏色祭 (赞：9)

~~这几天毫无状态。~~

很容易就可以想到一个dp方程：

$dp[i]=min(dp[j]+i-j+1)(last[j]<=sum[i]-sum[j])$

(dp[i]表示前i个最少需要合并几次，sum[i]表示前缀和，last[i]就表示以i结尾时最后合并出来的一个数)

然后这样如果枚举的话有50pts。

考虑优化。

把条件($last[j]<=sum[i]-sum[j]$)两边同时加上sum[j]，得:

$last[j]+sum[j]<=sum[i]$

然后直接动态开点线段树就行了。

![我好菜啊](https://s1.ax1x.com/2018/03/15/94znM9.jpg)

```
//by zykykyk
#include<cstdio>
#include<ctime>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<string>
#define rg register
#define il inline
#define vd void
#define ll long long
#define N 200010
#define INF 2147483647
#define For(i,x,y) for (rg int i=(x);i<=(y);i++)
#define Dow(i,x,y) for (rg int i=(x);i>=(y);i--)
#define cross(i,k) for (rg int i=first[k];i;i=last[i])
using namespace std;
il ll max(ll x,ll y){return x>y?x:y;}
il ll min(ll x,ll y){return x<y?x:y;}
il ll read(){
    ll x=0;int ch=getchar(),f=1;
    while (!isdigit(ch)&&(ch!='-')&&(ch!=EOF)) ch=getchar();
    if (ch=='-'){f=-1;ch=getchar();}
    while (isdigit(ch)){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
    return x*f;
}
int n,dp[N];
ll a[N],sum[N],last[N];

int rt,tot,v[N*37],id[N*37],lson[N*37],rson[N*37];
il vd insert(int &u,ll l,ll r,ll ql,int x){
	if (!u) u=++tot;
	if (l==r){
		v[u]=dp[x]-x-1,id[u]=x;
		return;
	}
	ll mid=l+r>>1;
	if (ql<=mid) insert(lson[u],l,mid,ql,x);
		else insert(rson[u],mid+1,r,ql,x);
	if (lson[u]) v[u]=v[lson[u]],id[u]=id[lson[u]];
	if (rson[u]) 
		if (!v[u]) v[u]=v[rson[u]],id[u]=id[rson[u]];
			else if (v[rson[u]]<v[u]||v[rson[u]]==v[u]&&id[rson[u]]>id[u]) v[u]=v[rson[u]],id[u]=id[rson[u]];
}
il int Query(int u,ll l,ll r,ll ql,ll qr){
	if (l>=ql&&r<=qr) return u;
	ll mid=l+r>>1,ans=-1;
	if (ql<=mid) ans=Query(lson[u],l,mid,ql,qr);
	if (qr>mid)
		if (ans==-1) ans=Query(rson[u],mid+1,r,ql,qr);
		else{
			int ans_rs=Query(rson[u],mid+1,r,ql,qr);
			if (v[ans_rs]<v[ans]||v[ans_rs]==v[ans]&&id[ans_rs]>id[ans]) ans=ans_rs;
		}
	return ans;
} 
 
int main(){
	freopen("data.in","r",stdin);
	freopen("m.out","w",stdout);
	n=read();
	For(i,1,n) a[i]=read(),sum[i]=sum[i-1]+a[i];
	insert(rt,0,sum[n],0,0);
	For(i,1,n){
		int j=id[Query(rt,0,sum[n],0,sum[i])];
		dp[i]=dp[j]+i-j-1,last[i]=sum[i]-sum[j];//printf("%d\n",dp[i]);
		if (sum[i]+last[i]<=sum[n]) insert(rt,0,sum[n],sum[i]+last[i],i);
	}
	printf("%d",dp[n]);
}
```

---

## 作者：3493441984zz (赞：7)

# 动态规划$+$单调队列优化


------------
看到题解里只有一篇单调队列，而且和我还写的不同，于是发了一篇题解


------------
# 思路:

我们首先看到这个题目后，我们可能会想到贪心合并，每次发现不能构成单调不减序列后，我们就一直合并到能构成单调不减序列

然后就$WA$了$qwq$

例如下面这组数据：

$4,3,3,3,9$

我们到了第一个$3$后，发现不能构成单调不减了，于是我们合并两个$3$，构成:

$4,6,3,9$

再次合并构成：

$4,6,12$

这样的做法错在哪里呢？在于我们没有考虑到一个因素，那就是在相同合并次数下，我们要尽量使得最后一个数尽量小，这样才能保证结果最优，例如相面这组样例，假如我们还是合并两次，但是这次我们先合并$3,3$后，再合并$6,3$，也就是：

$4,6,3,9$

$4,9,9$

我们还是合并了两次，但是我们最后一个数是$9$，比$12$小，后面的序列我们可以填更多的数

于是我们设计状态：

$f[i]$表示前$i$个数合并最小次数

$g[i]$表示前$i$个数保证在合并$f[i]$次的情况下，最后一个数的最小值


------------

先讲$O(n^2)$

转移的话，假如我们在处理$f[i]$

那么我们在$[1,i]$枚举$j$，假如从$j$到$i$这个区间的值的和大于等于$g[j]$，那么就可以转移了（保证单调不减）那么

$$f[i]=f[j]+i-j-1$$

用$sum[i]$表示前缀和

$g[i]=sum[i]-sum[j]$

我们上面讲过$g[i]$越小越好，所以可以用单调队列维护$sum[i]-sum[j]$

------------

虽然好像$O(n^2)$可以过，但是这里给出单调队列优化的代码

下面是美滋滋的代码时间~~~

~~~cpp
#include<iostream>
#include<cstdio>
#define int long long
#define N 200007
using namespace std;
int n,head,tail=1;
int f[N],pre[N],sum[N],q[N];
signed main()
{
    scanf("%lld",&n);
    for(int i=1;i<=n;++i)
    {
    	int x;
		scanf("%lld",&x);
		sum[i]=sum[i-1]+x;
	}
    for(int i=1;i<=n;++i) 
	{
        while(head+1<tail&&sum[i]>=sum[q[head+1]]+pre[q[head+1]])
            ++head;
        f[i]=f[q[head]]+i-q[head]-1;
        pre[i]=sum[i]-sum[q[head]];
        while(head<tail&&sum[q[tail-1]]+pre[q[tail-1]]>sum[i]+pre[i])
            --tail;
        q[tail++]=i;
    }
    printf("%lld",f[n]);
    return 0;
}
~~~

---

## 作者：Patients (赞：5)

[**题目由此去**](https://www.luogu.com.cn/problem/P2300)

------------
**状态定义：**

定义一个 $f[i]$ 与一个 $Min[i]$ 用来存储最后的答案与当前的值。

**状态方程：**

当满足：  $ (j < i \land sum[i] -sum[j] \leqslant Min[j]) $

$ f[i] = f[j] + i - j - 1 $

$Min[i] = sum[i] - sum[j]$

代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
//开 long long 不然会死的很惨
using namespace std;
int n,p,sum[200001],dp[200001],Min[200001];
//f[i] 存储第i个神犇 
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>p;
		sum[i]=sum[i-1]+p;
		//前缀和不浪费时间 
	}
	for(int i=1;i<=n;i++)
	{
		int bj;
		for(int j=i-1;j>=0;j--) if(sum[i]-sum[j]>=Min[j]){bj=j;break;}
		//如果 sum[i]-sum[j]>=Min[j] 就要交换 
		dp[i]=dp[bj]+i-bj-1;
		Min[i]=sum[i]-sum[bj];
		//更新上一次的值 
//		cout<<"dp["<<i<<"] is "<<dp[i]<<endl;
//		cout<<"Min["<<i<<"] is "<<Min[i]<<endl<<endl;
	}
	cout<<dp[n]; 
	return 0； 
	//好习惯 
}
```

~~我不会告诉你我第一次没过![](https://啧.tk/xyx)~~

---

## 作者：qwaszx (赞：5)

orz 果然我还是才疏学浅

首先我们设$f[i]$表示把前$i$个数合并成非降序列的最少次数，$g[i]$表示在$f[i]$的条件下，最小的末尾的数，$s[i]$表示前缀和.

可以写出方程

若$j=\min(j|s[i]-s[j]\geq g[j])$，则$f[i]=f[j]+i-j-1,g[i]=s[i]-s[j]$

我们需要证明其正确性.首先$f[i]$在$i$增加$1$的时候最多增加$1$(可以归纳)，而$-i$一定会减少$1$，所以我们应该取最大的$j$来进行转移.

暴力做这个式子是$n^2$的，可以单调队列优化.

具体的做法是先把约束条件移项得到$s[i]\geq s[j]+g[j]$，设$h[i]=s[i]+g[i]$，并且我们可以发现对于$i$和$j$，如果$i>j$并且$h[i]\leq h[j]$，那么$j$就不会对后面的转移产生贡献.据此我们可以单调队列优化.每次转移的时候先出队一些，出队条件是$h[i]$和$h[j]$都满足转移条件并且$i<j$则$i$不如$j$优.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=5e5;
int a[N],f[N],n,head,tail;
long long s[N],g[N];
struct Node
{
	int id;long long w;
	bool operator <=(const Node &a)const{return w<=a.w;}
};
struct Queue
{
	Node q[N];
	void push(Node t)
	{
		while(head<=tail&&t<=q[tail])--tail;//出队
		q[++tail]=t;
	}
}q;//其实不建议封装233因为单调队列太灵活了不好封装
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",a+i);
	for(int i=1;i<=n;i++)s[i]=a[i]+s[i-1];
	head=1,tail=1;q.q[1]=(Node){0,0};
	for(int i=1;i<=n;i++)
	{
		while(head+1<=tail&&s[i]>=q.q[head+1].w)++head;//如果这个和下一个都满足条件则下一个更优
		Node t=q.q[head];
		f[i]=f[t.id]+i-t.id-1,g[i]=s[i]-s[t.id];
		q.push((Node){i,s[i]+g[i]});
	}
	printf("%d\n",f[n]);
}
```
$O(n)$.

---

## 作者：Piwry (赞：4)

没人讲我就解释下这题用到的结论的证明

这题的结论和 [CSP-S 2019 划分](https://www.luogu.com.cn/problem/P5665) 的结论其实很类似，不如说这里的结论其实是 划分 结论推导过程中的一个引理

另外关于 划分 的证明也可看看我的 [博客](https://www.luogu.com.cn/blog/105254/solution-p5665) qwq

## 解析

### 引出

首先可以发现，最终划分的每一段都会提供 长度减一 的贡献，因此最优的方案一定要**尽可能多**地分段

### 结论及证明

将一个解 $S$ 的**倒数**第 $j$ 段的开始位置不严谨地表示为 $l_j\in S$

首先我们考虑这样的一个解 $S$。它与任意不同的解 $S'$ 之间，一定满足其中一条：

1. $S'$ 不存在倒数第 $j$ 段，但 $S$ 存在
2. $l_j\in S'\leq l_j\in S$

分别记为 $1.$，$2.$

&nbsp;

这样的 $S$ 应当是存在的，证明：

1. 如果 $S$ 的倒数第 $j$ 段存在

这里采用类似归纳法的方式证明

首先如果仅考虑 $j=1$，显然能找到这样一个 $S$

我们假设有一个 $S'$，它的 $l_2\in S'> l_2\in S$，那么图画出来就是这样的：

![S](https://cdn.luogu.com.cn/upload/image_hosting/7zzjuogm.png)

由于解还需满足从左到右**段和不增**，推一下就能发现 $l_2\in S$ 还能再往右一些，因此假设不成立

对于更大的 $j$，我们也都能用类似的方法反证证明

2. 如果 $S$ 的倒数第 $j$ 段不存在

我们要说明这实际上是不可能的

假设 $S$ 的倒数第 $j$ 段不存在，而有另一个 $S'$ 存在倒数第 $j$ 段

首先做出 $S'$ 的 $l_j\in S'$、$S'$ 的 $l_{j-1}\in S'$ 以及 $S$ 的 $l_{j-1}\in S$ 的在序列上的位置

![SS](https://cdn.luogu.com.cn/upload/image_hosting/kk1a50p2.png)

由于 $<a_i>$ 均非负，推一下就能发现，若 $[l_j\in S', l_{j-1}\in S'-1], [l_{j-1}\in S', l_{j-2}\in S'-1]$ 这两个相邻的分段成立，那么 $[l_j\in S', l_{j-1}\in S-1], [l_{j-1}\in S, l_{j-2}\in S-1]$ 这两个相邻的分段也是成立的

于是只要保持 $S$ 的 $l_k, 1\leq k\leq j-1$ 的分段不变，剩下的全盘 “复制” $S'$ 的分段，我们就能获得任一个满足 $2.$ 的 $S$，且 $S$ 存在第 $j$ 段。于是假设显然不成立

&nbsp;

于是 $S$ 是一定存在的

同时，$S$ 的 $1.$ 实际上就表明了它是所有解中分段最多的解

### 算法及证明

我们先形式化地说明下算法的流程：

设 $f(i)$ 表示对 $[0, i]$ 划分，使得划分最后一段左端点（区间左右均闭）最大的划分方案；再设 $l_i$ 表示 $f(i)$ 最后一段的左端点的下标

有 $l_i=\max\limits_{j: \sum\limits_{k=j+1}^ia_k\geq \sum\limits_{k=l_j}^ja_k} (j+1)$

我们指出，该算法计算出的 $f(i)$ 一定是符合其定义的

&nbsp;

为了说明算法的正确性，我们需要证明每次对 $l_i$ 的计算是始终后效性最优的

设算法第一次产生后效性是在计算 $f(i)$ 后。我们发现，算法产生后效性只可能是 $f(i)$ 在可能转移时无法转移；而要令 $f(i)$ 能被转移，就要使 $\sum\limits_{k=l_i}^ia_k$ 尽可能地小。对于 $f(j), j<i$，它们都不会对计算 $f(i)$ 产生后效性（因为第一次产生后效性是在计算 $f(i)$ 时）；而 $f(i)$ 的定义就是使对 $[0, i]$ 划分的最后一段的左端点的下标尽可能地大，也就是使最后一段的和尽可能的小。因此，不可能会有比 $f(i)$ 更优的方案，$f(i)$ 也一定不会产生后效性

&nbsp;

接着我们指出，$f(n-1)$ 的方案实际上就是上一节我们提到的划分最多的解 $S$

首先考虑 $f(n-1)$ 的方案的最后一段。按 $f$ 的定义，它一定是满足 结论 $1$ 的

再考虑 $f(n-1)$ 的方案的倒数第二段。注意到，它实际上就是 $f(n-2)$ 的最后一段，按 $f$ 的定义，这一定倒数第二段端点最右的方案，它也满足 结论 $1$（实际上这是：在倒数第一段端点最右的前提下，倒数第二段端点最右的方案。然而这涉及的问题实际上仅仅是 $S$ 的存在性，这在之前我们已经证过了）

于是如此类推，可以得出 $f(n-1)$ 的方案的每一段都是满足要求的，因此 $f(n-1)$ 的方案就是划分最多的解 $S$

### 单调队列部分

有了这个结论就好做了

记 $s(i)=\sum\limits_{k=0}^i a_i$。并不严谨地设 $f(i)$ 的值为其方案的最后一段的段和

首先上面的 dp 式子是满足四边形不等式的，这个随便推一下就行

（下面可能有些我自己口胡的词缀X。另外关于 dp 优化，小小地 [广告](https://www.luogu.com.cn/blog/105254/bu-fen-lei-xing-dp-you-hua-yang-xie) 一下）

于是 $w(i, j)$ 是最优性单调的（函数的极值（在一定范围内）随 $i, j$ 单调递增/递减）

接着发现它的 $w(i, j)$ 函数形式和滑动窗口 dp 是一样的。具体来说，$w(i, j)=j\cdot[f(j)\leq s(i)-s(j-1)]$，其中 $[P]$ 在表达式 $P$ 成立时取 $1$，否则取 $0$（$w(i, j)$ 也可以有其它略微不同的定义，不过就分析而言是一样的）

于是直接套用滑动窗口 dp 的单调队列模式维护即可。更具体的实现可以看代码

## CODE

```cpp
#include <cstdio>
#define ll long long
#define ull unsigned ll

const int MAXN =2e5+50;

/*------------------------------单调队列------------------------------*/

int id[MAXN];/*id[.] =j 表示该状态来自 f(j)*/
int head, tail;

/*------------------------------Main------------------------------*/

inline int read(){
	int x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return x;
}

int l[MAXN];/*最后一段左端点*/
ll sum[MAXN], slast[MAXN]/*最后一段的和*/;

int main(){
	int n =read();
	for(int i =1; i <= n; ++i)
		sum[i] =read()+sum[i-1];
	id[head] =0;
	tail =1;
	for(int i =1; i <= n; ++i){
		while(head+1 < tail && slast[id[head+1]] <= sum[i]-sum[id[head+1]])
			++head;
		l[i] =id[head]+1;
		slast[i] =sum[i]-sum[id[head]];
		while(head < tail && slast[id[tail-1]]+sum[id[tail-1]] >= slast[i]+sum[i])
			--tail;
		id[tail++] =i;
	}
	int ans =0;
	for(int r =n; r; r =l[r]-1)
		ans +=r-l[r];
	printf("%d", ans);
}
```

---

## 作者：Daidly (赞：2)

记：

$f[i]$ 为前 $i$ 个数合并成单调不减序列的最小次数。

$pre[i]$ 为前 $i$ 个数合并成单调不减序列后末尾数的值。

$f[i]=f[j]+i-j-1$：合并第 $j+1$ 到第 $i$ 个数需要用 $i-j-1$ 次。 

$pre[i]=sum[i]-sum[j]$：合并第 $j+1$ 到第 $i$ 个数为一个数后即为区间 $[j+1,i]$ 的和。

$j$ 需要满足的条件：

$sum[i]-sum[j]\ge pre[j]$

$j\in[1,i-1]$

并且选到的 $j$ 需要让 $f[i]$ 和 $pre[i]$ 尽量小。

考虑单调关系：

很明显 $pre[i]$ 随着 $j$ 增大而减小。

$f[i]=\min(f[j]-j)+i-1$

假设 $f[j]-j\leq f[j-1]-(j-1)$

移项得 $f[j]-f[j-1]\leq j-j+1=1$

由定义得假设成立。

所以 $f[i]$ 随着 $j$ 增大而减小。

所以找最大的 $j$ 符合情况即可。

将条件移项得 $sum[i]\ge sum[j]+pre[j]$

维护一个单调递增的序列储存 $sum[j]+pre[j]$ 和下标 $j$。

对于除去队列尾端的元素条件为 $sum[j]+pre[j]\leq sum[k]+pre[k]=q[r]$，其中 $k$ 为队列尾端储存下标，$q$ 为队列。

因为 $k$ 比 $j$ 先入队，所以 $k<j$，所以 $sum[k]<sum[j]$。

又因为 $sum[k]+pre[k]\ge sum[j]+pre[j]$，所以 $pre[k]>pre[j]$。

要求在满足条件下最小，所以 $k$ 没有 $j$ 优。

因为维护队列的下标也是单调递增的，所以除去队首元素的条件是满足条件（$j$ 可选的条件）且队列不能为空（为空还怎么转移），这样可以保证队首的下标最大。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long

inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}

inline void print(int x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)print(x/10);
	putchar(x%10^48);
}

const int MAXN=2e5+5;
int n,pre[MAXN],f[MAXN],sum[MAXN],q[MAXN],l=1,r,num[MAXN];

signed main(){
	n=read();
	for(int i=1;i<=n;++i){
		sum[i]=read();
		sum[i]+=sum[i-1];
	}
	for(int i=1;i<=n;++i){
		while(l<=r&&sum[i-1]+pre[i-1]<=q[r])r--;
		q[++r]=sum[i-1]+pre[i-1];
		num[r]=i-1;
		while(l<r&&sum[i]>=q[l+1])l++;
		f[i]=f[num[l]]-num[l]+i-1;
		pre[i]=sum[i]-sum[num[l]];
	}
	print(f[n]);
	return 0;
}
```

---

## 作者：Farkas_W (赞：2)

$\quad$题目链接[P2300 合并神犇](https://www.luogu.com.cn/problem/P2300)

$$\text{题目大意}$$

$\quad$将一个无序序列变成不降序列最少需要合并几次？合并是指将相邻两个数合为一个数，新数的值是原来两个数值之和。

$\quad$因为 $0<n<=200000$，所以暴力算法可能会 $T$ 飞，考虑使用动态规划求解。

$\quad$可以轻松推出动态规划状态转移式：$f[i]=\min(f[j]+i-j-1)$，满足$b[i]-b[j] \geqslant d[j]$，其中 $f[i]$ 为前 $i$ 项合并所需次数， $b[i]$ 表示前 $i$ 项之和，
 $b[i]-b[j]$ 为 $j+1$ 到 $i$ 的区间和, $d[j]$ 表示合并后 $j$ 所在的项的值，$i-j-1$ 表示区间 $j-1$ 至 $i$ 需要合并的次数是 $i-j-1$ 。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<stack>
using namespace std;
#define int long long
#define next neee
#define re register int
#define il inline
#define inf 1e18
il int read()
{
	int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)&&ch!='-')ch=getchar();
    if(ch=='-')f=-1,ch=getchar();
    while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
    return x*f;}
il void print(int x)
{
	if(x<0)putchar('-'),x=-x;
    if(x/10)print(x/10);
    putchar(x%10+'0');}
const int N=2e5+5;
int n,m,a[N],b[N],c[N],d[N];
signed main()
{
  n=read();
  for(re i=1;i<=n;i++)a[i]=read(),b[i]=b[i-1]+a[i];//顺便求前缀和
  for(re i=1,j;i<=n;i++)
    {
      for(j=i-1;j>=0;j--)
	if(b[i]-b[j]>=d[j])break;//如果已经就合法的就停止，区间尽量短，这样分的就越多，答案就越小
      c[i]=c[j]+i-j-1;//统计答案
      d[i]=b[i]-b[j];//记录这个最小区间和
    }
  print(c[n]);
  return 0;
}

```

---

## 作者：Buried_Dream (赞：2)

## 题意：

给你一堆神犇，可以将两个神犇合并掉，最后将这群神犇构成一个相等或者递增的神犇，合并后原来的神犇会消失。

## 思路：

用一个前缀和数组 $sum[i]$ 来存到 $i$ 这个神犇的能力值的和。

因为要构造一个单调不递减的神犇组。

数据范围告诉我们暴力会 `TLE`， 考虑动态规划，我们用 $dp[i]$ 表示从 $1$ 到 $i$ 这一段所需要的最小合并次数。

当我们遇到一个神犇比你靠前，还比你强，那你就没有用了，就合并掉。

我们用一个数组 $k[i]$ 表示 $s[i] - s[j]$，也就是将从第 $j$ 位到 $i$ 位的神犇合成一个更强的神犇。

注意要从后往前枚举，这样才能保证是最优的，如果从前往后枚举的话，合成的神犇会很大，会使后面的合并次数增加。

我们用一个变量来暂存从后往前枚举到的第一个满足条件的 $j$，然后将其合并，记录一下次数。

## AC code:
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

inline int read() {
	int s = 0, w = 1;
	char ch = getchar();
	while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();}
	while(isdigit(ch)) {s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();}
	return s * w;
}

const int maxn = 2e5 + 32;

int dp[maxn], a[maxn], D[maxn], zc, k[maxn];

signed main() {
	int n = read();
	for(int i = 1; i <= n; i++) {
		cin >> a[i];
		D[i] = D[i - 1] + a[i];
	}
	for(int i = 1; i <= n; i++) {
		for(int j = i - 1; j >= 1; j--) {
			if(D[i] - D[j] >= k[j]) {
				zc = j;
				break;
			}
		}
		dp[i] = dp[zc] + i - zc - 1;
		k[i] = D[i] - D[zc];
	}
	cout << dp[n] << endl;
}

```


---

## 作者：Coros_Trusds (赞：1)

# 题目大意

将一个无序序列变成不降序列最少需要合并几次？

定义合并是指将相邻两个数合为一个数，新数的值是原来两个数值之和。

# 题目分析

小清新 $\rm dp$。

令 $dp[i]$ 表示合并前 $i$ 项使满足条件的次数，$sum[i]$ 表示前缀和，$num[i]$ 表示合并后位于 $i$ 位置的数值，有：$dp[i]=\min\{dp[j]+i-(j+1)\}$，且 $j$ 满足 $sum[i]-sum[j]\ge num[j],0\le j\lt i$。

因为如果 $a[j]$ 大于 $a[i]$ 且 $j\lt i$，那么必须合并使之满足条件。$i-(j+1)$ 即为合并 $[i,j]$ 区间的次数。

# 代码

```cpp
//2022/2/22
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <algorithm>
#define int long long
#define enter() putchar(10)
#define debug(c,que) cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) cout << arr[i] << w;
#define speed_up() cin.tie(0),cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define Abs(x) ((x) > 0 ? (x) : (-x))
const int mod = 1e9 + 7;
inline int MOD(int x) {
	while (x < 0) x += mod;
	while (x >= mod) x -= mod;
	return x;
}
namespace Newstd {
	char buf[1 << 21],*p1 = buf,*p2 = buf;
	inline int getc() {
		return p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1 << 21,stdin),p1 == p2) ? EOF : *p1 ++;
	}
	inline int read() {
		int ret = 0,f = 0;char ch = getc();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getc();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getc();
		}
		return f ? -ret : ret;
	}
	inline void write(int x) {
		if(x < 0) {
			putchar('-');
			x = -x;
		}
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;
using namespace std;

const int ma = 2e5 + 5;
int a[ma],dp[ma],sum[ma],num[ma];
int n;
#undef int
int main(void) {
#ifndef ONLINE_JUDGE
	freopen("in.txt","r",stdin);
#endif
	#define int long long
	n = read();
	for (register int i = 1;i <= n; ++ i) {
		a[i] = read();
		sum[i] = sum[i - 1] + a[i];
	}
	for (register int i = 1;i <= n; ++ i) {
		int pos;
		for (register int j = i - 1;j >= 0; -- j) {	
			if (sum[i] - sum[j] >= num[j]) {
				pos = j;
				break;
			}
		}
		dp[i] = dp[pos] + i - (pos + 1);
		num[i] = sum[i] - sum[pos];
	}
	printf("%lld\n",dp[n]);
	
	return 0;
}
```

---

## 作者：xxasmcd (赞：1)

这道题可以用动态规划来解决，按道理来说，必须要用单调队列优化来实现，但运气好数据比较水，平方的效率也过掉了。

思路。
 
用一个前缀和数组来维护区间的总和,动态规划来计算当前点所需合并的最小次数。如果遇到一个神犇位置靠前，权值还大，就用一次合并，合并的次数为当前点与前面一个神犇位置的距离减一。

代码如下。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[200005],sum[200005],dp[200005],g[200005];
int n;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    sum[0]=0;
    for(int i=1;i<=n;i++)
    {
        sum[i]=sum[i-1]+a[i];
    }
    memset(dp,0,sizeof(dp));
    int pre;
    for(int i=1;i<=n;i++)
    {
        for(int j=i-1;j>=0;j--)
        {
            if(sum[i]-sum[j]>=g[j])
            {
                pre=j;
                break;
            }
        }
        dp[i]=dp[pre]+i-pre-1;
        g[i]=sum[i]-sum[pre];
    }
    cout<<dp[n];
    return 0;
}

```


---

## 作者：watermonster (赞：1)

题意：给定一个长度为$n$的序列，每次可以合并**相邻**的两个数，求最小合并次数使得序列从左到右**单调不减**。

令$dp_i$为将前$i$个数变为单调不减序列的最小合并次数，$s_i$为$i$的前缀和。

那么显然$dp_i=min(dp_j+i-j-1)$，$j$满足$s[i]-s[j] \ge s[j]-s[pre[j]]$，其中$pre[j]$为$j$的决策点。

枚举$j$可以拿到$50pts$。

代码：

```cpp
#include <cstdio>

using namespace std;

#define il inline
#define re register

typedef long long ll;
const int N=1e6+10;
const ll inf=0x3f3f3f3f;

namespace FastIO
{
char buf[1<<21],buf2[1<<21],*p1=buf,*p2=buf;
int p,p3=-1;
il int getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
il void flush(){fwrite(buf2,1,p3+1,stdout),p3=-1;}
#define isdigit(ch) (ch>=48&&ch<=57)
template <typename T>
il void read(T &x)
{
	re bool f=0;x=0;
	re char ch=getc();
	while(!isdigit(ch)) f|=(ch=='-'),ch=getc();
	while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getc();
	x=f?-x:x;
}
template <typename T>
il void print(T x)
{
	if(p3>(1<<20)) flush();
	if(x<0) buf2[++p3]=45,x=-x;
	re int a[50]={};
	do{a[++p]=x%10+48;}while(x/=10);
	do{buf2[++p3]=a[p];}while(--p);
}
}
using namespace FastIO;

int n;
int a[N];
ll s[N];
int dp[N],pre[N];

int main()
{
	read(n);
	for(re int i(1);i<=n;++i) read(a[i]);
	for(re int i(1);i<=n;++i) s[i]=s[i-1]+a[i];
	for(re int i(2);i<=n;++i)
		for(re int j(i-1);j;--j)
			if(s[i]>=s[j]*2-s[pre[j]]){pre[i]=j;break;}
	for(re int i=1;i<=n;++i) dp[i]=dp[pre[i]]+i-pre[i]-1;
	printf("%d",dp[n]);
	flush();return 0;
}
```

细心的人会发现这个代码中有一个优化：`if(s[i]>=s[j]*2-s[pre[j]]){pre[i]=j;break;}`

因为合并完之后的序列长度为原长度减去总共合并次数，所以要求合并次数最小可以转化为使得最终的序列尽量长。而且最终得到的序列中的一个数一定是由原序列中一段**连续**的区间得到的（因为每次只能合并相邻的两个数），我们可以把问题转化为将原序列划分成尽量多的区间，且保证区间的和单调不减。既然是要让区间数尽可能地多，那我们就应该让每个区间尽可能地短，然而我们的元素都为正数，所以区间长度和区间和成正关系。又因为我们最后一段的和是最大的，之前的区间的和一定小于等于最后一段，所以我们只需**让最后一段最小**即可保证前面都最小。

于是我们只需找到$i$之前第一个满足$s[i]-s[j] \ge s[j]-s[pre[j]]$的$j$就是$i$的决策点了。

现在考虑如何优化找$j$的过程。

~~我比较喜欢暴力数据结构，所以这是一篇不太正经的线段树题解，想学单调队列的同学可以跳过了~~

将条件移项可得：$s[i] \ge s[j]*2-s[pre[j]]$，**当处理完$j$后**，我们可以将右边的值放到线段树中，然后在处理$i$时直接在线段中查找所有慢足$s[i] \ge s[j]*2-s[pre[j]]$最靠右的一个$j$。

具体查找方式：在线段树的节点中维护区间最小值（初始为$inf$），若左右儿子的值都大于$s[i]$则返回$0$，若当前节点右儿子维护的最小值小于$s[i]$那么向右儿子查找，否则向左儿子，到叶子节点即找到了一个最靠右满足条件的$j$。总复杂度$O(nlogn)$。

代码（部分细节与描述有出入）：

```cpp
#include <cstdio>

using namespace std;

#define il inline
#define re register

typedef long long ll;
const int N=1e6+10;
const ll inf=0x3f3f3f3f3f3f3f3f;

namespace FastIO
{
char buf[1<<21],buf2[1<<21],*p1=buf,*p2=buf;
int p,p3=-1;
il int getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
il void flush(){fwrite(buf2,1,p3+1,stdout),p3=-1;}
#define isdigit(ch) (ch>=48&&ch<=57)
template <typename T>
il void read(T &x)
{
	re bool f=0;x=0;
	re char ch=getc();
	while(!isdigit(ch)) f|=(ch=='-'),ch=getc();
	while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getc();
	x=f?-x:x;
}
template <typename T>
il void print(T x)
{
	if(p3>(1<<20)) flush();
	if(x<0) buf2[++p3]=45,x=-x;
	re int a[50]={};
	do{a[++p]=x%10+48;}while(x/=10);
	do{buf2[++p3]=a[p];}while(--p);
}
}
using namespace FastIO;

il ll min(ll a,ll b){return a<b?a:b;}

int n;
int a[N];
ll s[N];
int dp[N],pre[N];

int L[N<<2],R[N<<2];
ll val[N<<2];
#define pushup(p) (val[p]=min(val[p<<1],val[p<<1|1]))
il void build(int p,int l,int r)
{
	L[p]=l;R[p]=r;val[p]=inf;
    //初始值为inf
	if(l==r) return;
	re int mid=(l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	return;
}
il void insert(int p,int x,ll v)
{
	if(L[p]==R[p]){val[p]=v;return;}
	re int mid=(L[p]+R[p])>>1;
	if(x>mid) insert(p<<1|1,x,v);
	else insert(p<<1,x,v);
	pushup(p);
}//更新信息
il int query(int p,ll lim)
{
	if(L[p]==R[p]) return L[p];
	re int mid=(L[p]+R[p])>>1;
	if(val[p<<1|1]<=lim) return query(p<<1|1,lim);
	else return query(p<<1,lim);
}//查找j

int main()
{
	read(n);build(1,0,n);
	for(re int i=1;i<=n;++i) read(a[i]);
	for(re int i=1;i<=n;++i) s[i]=s[i-1]+a[i];
	for(re int i=1;i<=n;++i)
	{
		pre[i]=query(1,s[i]);
		dp[i]=dp[pre[i]]+i-pre[i]-1;
		insert(1,i,s[i]*2-s[pre[i]]);
	}
	printf("%d",dp[n]);
	flush();return 0;
}
```



---

## 作者：7wwwwth (赞：1)

记录一下自己做过的题诶

最最开始把题看错了 以为是递减序列...

~~样例好像也解释的过去？~~

所以一不会做二看不懂题解

然后在使用小黄鸭调试法之后恍然大悟

那么转移方程就好写了。

f[i]表示合并第i个神犇时用的次数

初始化f[0]=0； f[n]即为所求。

last[i]记录合并到第i个时最右也就是最大的数

然后对之后一个区间的神犇进行合并使新合并成的神犇比之前的大（即该区间值大于目前最右）。

目标就是找这么一个区间。

sum记录前缀和找区间值

第一次找到的一定是最优的，直接break就好了。

然后更新最右和次数

关于合并一个区间所需要的次数

显然要两两合并的话需要

区间长度-1次

然后就很完美了。


---

## 作者：破忆 (赞：0)

## 【题意】
将序列拆成若干段，使各段和单调不降，求最少的段数
## 【分析】
$f[i]$表示以$i$为结尾的最少段数

$lst[i]$表示以$i$为结尾，最少段数情况下最后一段的和

$f[i]=min(f[j])+1$

段数越少越好

段数多，$lst$更大显然不会更优

所以可以维护一个单调队列

$f$单调递增,$lst$单调递减

每次取可取的队头，顺便删掉无用状态即可
## 【解法】
单调队列
## 【代码】
```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int maxn=2000005;
int n,a[maxn],hed,til=1,que[maxn],f[maxn],ans;
LL s[maxn],lst[maxn];
inline char gc(){
	static char buf[10000],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,10000,stdin),p1==p2)?EOF:*p1++;
}
inline int read(){
	int ret=0,f=1;char ch=gc();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=gc();}
	while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=gc();
	return ret*f;
}
int main(){
 	freopen("P2300.in","r",stdin);
 	freopen("P2300.out","w",stdout);
	n=read();
	for(int i=1;i<=n;i++) a[i]=read(),s[i]=s[i-1]+a[i];
	for(int i=1;i<=n;i++){
		while(hed+1<til&&s[i]>=s[que[hed+1]]+lst[que[hed+1]]) hed++;
		f[i]=f[que[hed]]+1;
		lst[i]=s[i]-s[que[hed]];
		while(hed<til&&s[que[til-1]]+lst[que[til-1]]>s[i]+lst[i]) til--;
		que[til++]=i; 
	}
	printf("%d\n",n-f[n]);
	return 0;
}
```


---


# [HNOI2005] 星际贸易

## 题目描述

$\text{Coke}$ 是一个精明的小商人。这次他想大胆地做一次星际贸易。于是他选定了银河贸易交通局所给定的一条贸易路线，从地球出发，依次经过 $Star_1,Star_2,\cdots,Star_N$ 。贸易路线在 $Star_N$ 结束（$\text{Coke}$ 最后要在 $Star_N$ 上观光旅游）。

银河系中各个星球实行计划经济。在一个星球上出售商品，必须获得那个星球的许可证。$\text{Coke}$ 手中的许可证允许他在 $Star_i$ 上出售指定配额量 $A_i (1\leq A_i\leq100)$ 吨的商品(而且既不多也不能少，当然他可以不在 $Star_i$；上出售任何商品)，出售后能够获得 $B_i(0 \leq B_i \leq 50000)$ 的收入。由于 $\text{Coke}$ 的私人飞船载重有限，这个精明的小商人不得不好好计划一下他应该向哪些星球出售商品。

飞船采用反物质推进系统行驶，需要反物质燃料。反物质燃料不是用来维持平常飞行的(宇宙间没有阻力)，而是用于飞船从星球出发时加速以及飞船到达星球时减速所需的消耗。每次加速和减速各消耗一个单位的反物质燃料。

另外，作如此长距离的飞行，飞船显然要在中途停靠并在某些星球上补充反物质燃料以及对飞船定期进行一些维护(维护只能在星球上进行)。由于各星球之间科技发展水平不等，在各个星球上反物质燃料的售价以及维护飞船的费用是不同的。

此外，银河贸易交通局正在举办小商人贸易竞赛，对于贸易额(即总贸易收入)得到冠军的商人有丰厚的奖赏，因此 $\text{Coke}$ 决定不惜血本，要使自己的贸易额达到最大。当然，在贸易额最大的同时，作为一个商人，他还是希望净利润尽可能大(净利润=贸易额-燃料费用-维护费用)。

假设从地球出发时飞船刚刚维护过并装满了燃料，并且飞船每次停靠一个星球出售商品或补充反物质燃料或在终点站观光旅游时就会在那里做一次维护。$\text{Coke}$ 希望你给他制定一个方案满足他的要求。

## 样例 #1

### 输入

```
6 3 10 4
1 2 1 1 1
1 2 2 2 1
1 2 3 9 1
1 1 4 0 1
1 1 5 0 1
1 1 6 1 1
```

### 输出

```
6 2```

## 样例 #2

### 输入

```
6 3 2 4
1 2 1 1 1
1 2 2 2 1
1 2 3 0 1
1 1 4 0 1
1 1 5 0 1
1 1 6 1 1
```

### 输出

```
Poor Coke!```

# 题解

## 作者：waaadreamer (赞：14)

拿到这道题蒟蒻的头脑非常混乱……

再仔细想想，发现这道题可以分成两部分解决，第一部分是选择哪些星球进行销售。第二部分是在第一部分的基础上进行的，计算此时所需要花费的最小代价。

第一部分其实非常简单的啦，就是一个背包dp，dp[i][j]=max(dp[i-1][j-a[i]]+b[i],dp[i-1][j])，其中只有dp[0][0]=0，其它全部为负无穷大。

接下来进行dp的路径还原就可以得到第一部分选择了哪些星球了。（刚开始没有好好看题，这样的选择竟然是唯一的，我傻爆了）。**暂且称这一部分选出的星球为必选星球。**

第二部分的dp也很好想了。设f[i][j]表示前i个星球经过之后停靠在第i个星球并且加过反物质材料、维护过之后所需要的最小代价。其实题目中这个R<=1E9的条件并没有什么卵用……可以发现，最多携带2n的燃料就可以完成旅行了。

然后就开始花式dp……

f[i][j]=min(f[k][l]+(j-l+2)\*P[i]+F[i])，其中k满足：最近必选星球的位置<=k<j且L[j]-L[k]<=L，且2<=l<=j+2.

这样dp是O(n^4)的，而且常数较大，我们需要改进啊。。

容易发现，上面的dp可以转换成：f[i][j]=min(f[k][j+2]+F[i],f[i][j-1]+P[i])，其中k的取值范围不变。

但是这样的复杂度为O(n^3)，还是不够。我们会发现这个递推式还可以使用单调队列进行优化。最后的复杂度为O(n^2)。

f[0][R]=0，其它为正无穷大。

···cpp


```cpp
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <string.h>
#include <vector>
#include <math.h>
#include <queue>
#include <set>
#include <functional>
#include <time.h>
#define INF 0x3f3f3f3f
using namespace std;
typedef long long ll;
const int maxn = 2005, maxf = 4005;
int dp[maxn][maxn], f[maxn][maxf], sell[maxn], money[maxn], dist[maxn], price[maxn], fix[maxn];
int que[maxf][maxn], he[maxf], ta[maxf];
bool chosen[maxn];
int main(){
    int n, m, maxF, maxD;
    scanf("%d%d%d%d", &n, &m, &maxF, &maxD);
    if(maxF > 2 * n) maxF = 2 * n;
    for(int i = 1; i <= n; i++) scanf("%d%d%d%d%d", sell+i, money+i, dist+i, price+i, fix+i);
    for(int i = 1; i <= n; i++) if(dist[i] - dist[i - 1] > maxD){
        puts("Poor Coke!");
        return 0;
    }
    memset(dp, -1, sizeof(dp));
    dp[0][0] = 0;
    for(int i = 1; i <= n; i++)
    for(int j = 0; j <= m; j++){
        if(dp[i - 1][j] >= 0) dp[i][j] = dp[i - 1][j];
        if(j >= sell[i] && dp[i - 1][j - sell[i]] >= 0)
            dp[i][j] = max(dp[i][j], dp[i - 1][j - sell[i]] + money[i]);
    }
    int maxS = 0;
    for(int i = 0; i <= m; i++) if(dp[n][i] > dp[n][maxS]) maxS = i;
    for(int i = n, j = maxS; i >= 1; i--){
        if(dp[i][j] == dp[i - 1][j]) continue;
        else chosen[i] = true, j -= sell[i];
    }
    memset(f, 0x3f, sizeof(f));
    f[0][maxF] = 0;
    que[maxF][ta[maxF]++] = 0;
    for(int i = 1; i <= n; i++)
    for(int j = 0; j <= maxF; j++){
        if(price[i] > 0 && j > 0) f[i][j] = min(f[i][j], f[i][j - 1] + price[i]);
        if(ta[j + 2] > he[j + 2]) f[i][j] = min(f[i][j], f[que[j + 2][he[j + 2]]][j + 2] + fix[i]);
        if(chosen[i]) he[j] = ta[j] = 0;
        while(ta[j] > he[j] && f[que[j][ta[j] - 1]][j] >= f[i][j]) ta[j]--;
        que[j][ta[j]++] = i;
        while(he[j] < ta[j] && dist[i + 1] - dist[que[j][he[j]]] > maxD) he[j]++;
    }
    int minC = 0;
    for(int i = 0; i <= maxF; i++) if(f[n][i] < f[n][minC]) minC = i;
    if(f[n][minC] == INF) puts("Poor Coke!");
    else printf("%d %d", dp[n][maxS], dp[n][maxS] - f[n][minC]);
    return 0;
}
···
```

---

## 作者：Saliеri (赞：10)

#### 题外话 ： 

两个月后再回首，臭题依旧臭。

为加深自己的印象，补一篇题解在这里，顺便造福后人。~~原先那题解太……了~~。

___

### 正题:

读完题先理理思维，发现这道题割裂为两个部分：

- 求出最大贸易额

- 在最大贸易额的同时求出最大利润。

分两个Part写。

#### Part1:

容易发现问题可以转化为一个“体积为$M$ ,有 $N$ 个物品，每个物品体积为  $A_i$ ,收益为 $B_i$ 的**背包**问题。~~来做这个题的不要告诉我不会背包（~~

直接背包得出答案，复杂度$O(NM)$。

#### Part2:

本题主体部分。

首先需要由$Part1$中的$dp$数组中求出哪些位置必须降落。

首先设计DP状态。

设$dp_{i,j}$ 表示现在到了第i个星球，还剩j单位的反物质燃料的最小代价。

朴素dp方程就不用写了吧……暴力枚举从哪里转移而来，转移来时的油量。判合法，答案取$min$即可。复杂度$O(n^4)$。

考虑优化一下转移。

发现**油量**一维可以用**完全背包**的方式自己更新自己。这样就不用枚举来时的油量了。

改进后的状态转移方程为：

$$dp_{i,j} = min(dp_{k,j+2}+F_i,dp_{i,j-1} +P_i),L_i-L_k<=L_0$$

朴素转移变为$O(n^3)$

观察DP方程，可以发现k的取值是一个 **滑 动 窗 口**。

于是考虑对每一个j维护一个单调队列，维护滑动窗口内最优的转移。

状态$O(n^2)$,转移$O(1)$,总时间复杂度$O(n^2)$.

#### 代码

虽然$R$的范围为1e9，但有用的部分最多为$2n$.

细节好多……

```cpp
#include <cstdio>
#include <cstring>
const int maxn = 2e3+5;
inline int min(int a,int b){return a<b?a:b;}
inline int max(int a,int b){return a>b?a:b;}
int n,m,r,l0,a[maxn],b[maxn],l[maxn],p[maxn],v[maxn];
int f[maxn][maxn<<1],chose[maxn],q[maxn<<1][maxn],head[maxn<<1],tail[maxn<<1];
int main(){
	scanf("%d %d %d %d",&n,&m,&r,&l0);
	for(int i=1;i<=n;++i){
		scanf("%d %d %d %d %d",&a[i],&b[i],&l[i],&p[i],&v[i]);
		if(l[i] - l[i-1] > l0){
			printf("Poor Coke!");//特判
			return 0;
		}
	}
	memset(f,0xcf,sizeof(f));
	f[0][0] = 0;
	for(int i=1;i<=n;++i){
		for(int j=m;~j;--j)f[i][j] = f[i-1][j];
		for(int j=m;j>=a[i];--j)
			f[i][j] = max(f[i][j],f[i-1][j-a[i]]+b[i]);
	}
	int maxpos,maxx = -0x3f3f3f3f;
	for(int i=0;i<=m;++i)	{
		if(maxx < f[n][i])
			maxx = f[n][i],maxpos = i;
	}
	for(int i=n,j=maxpos;i;--i){
		if(f[i][j] == f[i-1][j])continue;
		chose[i] = 1,j -= a[i];
	}//得到降落点
	memset(f,0x3f,sizeof(f));
	f[0][min(n*2,r)] = 0,q[min(n*2,r)][++tail[min(n*2,r)]] = 0;//边界赋值
	for(int i=1;i<=n;++i){
		for(int j=0;j<=min(r,2*n);++j){	
			if(j&&p[i])f[i][j] = min(f[i][j],f[i][j-1]+p[i]);
			if(head[j+2]<tail[j+2])f[i][j] = min(f[i][j],f[q[j+2][head[j+2]]][j+2]+v[i]);
			if(chose[i])head[j] = tail[j] = 0;//必须降落，清空单调队列
			while(head[j]<tail[j]&&f[q[j][tail[j]-1]][j]>f[i][j])--tail[j];
			q[j][tail[j]++] = i;
			while(head[j]<tail[j]&&l[i+1]-l[q[j][head[j]]]>l0)++head[j];
		}
	}
	int minn = 0x3f3f3f3f;
	for(int i=0;i<=min(r,2*n);++i)
		minn = min(minn,f[n][i]);
	if(minn == 0x3f3f3f3f)printf("Poor Coke!");//到不了
	else printf("%d %d",maxx,maxx-minn);
	return 0;
} 


---

## 作者：Add_Catalyst (赞：3)

# 题解 P2317 [HNOI2005] 星际贸易

---

## 题意

先化简，然后变成了这个样子：

>Coke 依次经过 $1$ ~ $n$ 这几个位置，每个位置离起点距离为 $L_i$，最后停靠在第 $n$ 个位置结束。
>
>在每一个位置可以通过付出 $A_i$ 的代价获取 $B_i$ 的价值，他总共可以承担 $m$ 的代价。
>
>在离开和到达某个位置时，都要使用 $1$ 点能量，在每个位置都有可能可以补充能量，价格是 $P_i$，一开始，总共有 $R$ 点能量。
>
>同时在不管哪个位置停靠，都要在这个位置进行维护，费用为 $F_i$，不维护最多可以走的距离是 $L_0$。
>
>在满足价值最大的同时，他希望花在能量与维护上的总价最少。
>
>其中，输入数据满足：***一定有 ，并使得只有—种获得最大价值的方法***。

---

## 分析

再通过简化的题意发现，最大价值与能量与维护都无关，所以直接使用一个01背包就可以解决：

设 $f_{i,j}$ 表示：到第 $i$ 个位置，花费 $j$ 的代价，最大总价值为多少。然后就是最基础的01背包。

```cpp
#define RCL(a,b,c,d) memset((a),(b),sizeof(c)*(d))
int n,m;
int a[N],b[N];
int f[N][N];
RCL(f,-1,f,1),f[0][0]=0;
FOR(i,1,n)FOR(j,0,m){
	f[i][j]=f[i-1][j];
	if(j>=a[i])tomax(f[i][j],f[i-1][j-a[i]]+b[i]);
}
```

再看题目中有一个十分明显的提示：

> 输入数据满足：***一定有 ，并使得只有—种获得最大价值的方法***。

那么我们找到最大值，然后反向寻找一下就能知道那几个位置是做过买卖的，也就是必经的位置：

```cpp
int n,m,id1,id2;
int a[N];
int f[N][N];
bool chosen[N];
FOR(i,1,m)if(f[n][i]>f[n][id1])id1=i;
id2=id1;
DOR(i,n,1)if(f[i][id2]!=f[i-1][id2])id2-=a[i],chosen[i]=1;
```

然后既然知道哪些点是必经的，我们就可以把能量与维护的费用独立出来进行一个 DP：

设 $g_{i,j}$ 表示：到第 $i$ 个位置，剩余 $j$ 的能量，最小总价为多少。

那么列出转移方程式：
$$
g_{i,j} = \min{\{ g_{k,q} + F_i + P_i*(j-q+2)| L_i-L_k \le L_0 , 2\le q \le j-2 \}} ,
$$
由此可以解出 $O(n^4)$ 的算法，但是有一个明显的化简，我们把二维寻找转换为一维：
$$
g_{i,j} = \min {( \min{\{ g_{k,j+2} + F_i | L_i-L_k \le L_0 \}} ,  g_{i,j-1} + P_i )}
$$
然后可以得到一个 $O(n^3)$ 的的做法，不过直接枚举还不够，我们用一种简单的数据结构优化：单调队列。

同时注意到，总共用的能量不会超过 $2n$，那么就可以在输入时就把他化掉。

那么再结合上面的细节即可打出代码，（码风清奇，请见谅）：

```cpp
struct Deque{
#define Pii pair<int,int> 
#define F first
#define S second
	deque< Pii > dq;
	Deque(){Clear();}
	inline void Clear(){while(!dq.empty())dq.pop_back();}
	inline void Push(Pii x){
		while(!dq.empty()&&dq.back().S>=x.S)dq.pop_back();
		dq.emplace_back(x);
	}
	inline void Update(int x){while(!dq.empty()&&dq.front().F<x)dq.pop_front();}
	inline int Query(){return dq.empty()?INF:dq.front().S;}
#undef Pii
#undef F
#undef S
}dq[N<<1];
```

```cpp
#define RCL(a,b,c,d) memset((a),(b),sizeof(c)*(d))
int n,R,L;
int l[N],P[N],F[N];
int g[N][N<<1];
tomin(R,(n<<1));
RCL(g,INF,g,1),g[0][R]=0;
dq[R].Push({0,0});
FOR(i,1,n)FOR(j,0,R){
	if(P[i]&&j)tomin(g[i][j],g[i][j-1]+P[i]);
	dq[j+2].Update(l[i]-L),tomin(g[i][j],dq[j+2].Query()+F[i]);
	if(chosen[i])dq[j].Clear();
	dq[j].Push({l[i],g[i][j]});
}
```

紧接着，找到最小值：

```cpp
int R,id1,id2;
int g[N][N<<1];
FOR(i,0,R)if(g[n][i]<g[n][id2])id2=i;
```

输出：

```cpp
int n,id1,id2;
int f[N][N],g[N][N<<1];
cout<<f[n][id1]<<" "<<f[n][id1]-g[n][id2]<<endl;
```

同时，题目中还有不成立的情况，那么加入特判：

```cpp
int n,L;
int l[N];
FOR(i,n,1)if(l[i]-l[i-1]>L)return (cout<<"Poor Coke!"<<endl),0;
```

输出也要更改为：

```cpp
int n,id1,id2;
int f[N][N],g[N][N<<1];
if(g[n][id2]>=INF)cout<<"Poor Coke!"<<endl;
else cout<<f[n][id1]<<" "<<f[n][id1]-g[n][id2]<<endl;
```

---

## 完整代码

```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define max(a,b) ((a)<(b)?(b):(a))
#define min(a,b) ((a)>(b)?(b):(a))
#define tomax(a,b) ((a)=max((a),(b)))
#define tomin(a,b) ((a)=min((a),(b)))
#define RCL(a,b,c,d) memset((a),(b),sizeof(c)*(d))
#define FOR(i,a,b) for(register int i=(a);i<=(b);++i)
#define DOR(i,a,b) for(register int i=(a);i>=(b);--i)
#define main Main();signed main(){ios::sync_with_stdio(0);cin.tie(0);return Main();}signed Main
using namespace std;
const int N=2e3+10;
int n,m,R,L,id1,id2;
int a[N],b[N],l[N],P[N],F[N];
int f[N][N],g[N][N<<1];
bool chosen[N];
struct Deque{
#define Pii pair<int,int> 
#define F first
#define S second
	deque< Pii > dq;
	Deque(){Clear();}
	inline void Clear(){while(!dq.empty())dq.pop_back();}
	inline void Push(Pii x){
		while(!dq.empty()&&dq.back().S>=x.S)dq.pop_back();
		dq.emplace_back(x);
	}
	inline void Update(int x){while(!dq.empty()&&dq.front().F<x)dq.pop_front();}
	inline int Query(){return dq.empty()?INF:dq.front().S;}
#undef Pii
#undef F
#undef S
}dq[N<<1];
signed main(){
	cin>>n>>m>>R>>L;tomin(R,(n<<1));
	FOR(i,1,n)cin>>a[i]>>b[i]>>l[i]>>P[i]>>F[i];
	FOR(i,n,1)if(l[i]-l[i-1]>L)return (cout<<"Poor Coke!"<<endl),0;
	RCL(f,-1,f,1),f[0][0]=0;
	FOR(i,1,n)FOR(j,0,m){
		f[i][j]=f[i-1][j];
		if(j>=a[i])tomax(f[i][j],f[i-1][j-a[i]]+b[i]);
	}
	FOR(i,1,m)if(f[n][i]>f[n][id1])id1=i;
	id2=id1;
	DOR(i,n,1)if(f[i][id2]!=f[i-1][id2])id2-=a[i],chosen[i]=1;
	RCL(g,INF,g,1),g[0][R]=0;
	dq[R].Push({0,0});
	FOR(i,1,n)FOR(j,0,R){
		if(P[i]&&j)tomin(g[i][j],g[i][j-1]+P[i]);
		dq[j+2].Update(l[i]-L),tomin(g[i][j],dq[j+2].Query()+F[i]);
		if(chosen[i])dq[j].Clear();
		dq[j].Push({l[i],g[i][j]});
	}
	id2=0;
	FOR(i,0,R)if(g[n][i]<g[n][id2])id2=i;
	if(g[n][id2]>=INF)cout<<"Poor Coke!"<<endl;
	else cout<<f[n][id1]<<" "<<f[n][id1]-g[n][id2]<<endl;
	return 0;
}
```

时间复杂度 $O(n^2)$，足够通过。

---

---

## 作者：Mars_Dingdang (赞：1)

一道 DP 好题，有一点多合一的意思。已修改，请管理员审核。(现在标准好严qaq)

## 题目大意
Coke 选定了银河贸易交通局所给定的一条贸易路线，从地球出发，依次经过 $Star_1,Star_2,…,Star_N$, 贸易路线在 $Star_N$ 结束。

Coke 手中的许可证允许他在 $Star_i$ 上出售指定配额量 $A_i$ 吨的商品（而且既不能多也不能少，当然他可以不在 $Star_i$ 上出售任何商品），出售后能够获得 $B_i$ 的收入。

由于 Coke 的私人飞船载重有限，这个精明的小商人不得不好好计划一下他应该向哪些星球出售商品。

飞船采用反物质推进系统行驶，需要反物质燃料。

反物质燃料不是用来维持平常飞行的（宇宙间没有阻力），而是用于飞船从星球出发时加速以及飞船到达星球时减速所需的消耗。

**每次加速和减速各消耗一个单位的反物质燃料。**

另外，作如此长距离的飞行，飞船显然要在中途停靠并在某些星球上补充反物质燃料以及对飞船定期进行一些维护(维护只能在星球上进行)。

由于各星球之间科技发展水平不等，在各个星球上反物质燃料的售价以及维护飞船的费用是不同的。

此外，银河贸易交通局正在举办小商人贸易竞赛，对于贸易额（即总贸易收入）得到冠军的商人有丰厚的奖赏，**因此 Coke 决定不惜血本，要使自己的贸易额达到最大。**

当然，在贸易额最大的同时，作为一个商人，他还是希望净利润尽可能大（净利润=贸易额-燃料费用-维护费用）。

假设从地球出发时飞船刚刚维护过并装满了燃料，**并且飞船每次停靠一个星球出售商品或补充反物质燃料或在终点站观光旅游时就会在那里做一次维护。**

Coke 希望你给他制定一个方案，满足他的要求。

## 大体思路
首先，不得不说题面很长，但分析后发现这样一句话：Coke 决定不惜血本，要使自己的贸易额达到最大。换句话说，他会尽可能使得自己的贸易额最大。

那么，我们将求解贸易额的问题单独来看：有 $n$ 个星球，和总体积为 $m$ 的背包，每个星球体积为 $a_i$，价值为 $b_i$。换句话说，第一问转变成了 01 背包问题，复杂度 $O(nm)$。

当然，在确定了所有状态后，需要再通过倒序遍历来确定 dp 所必需的着陆星球。

```cpp
	memset(dp, -1, sizeof dp);
	dp[0][0] = 0;
	rep(i, 1, n)
		rep(j, 0, m) {
			dp[i][j] = max(0, dp[i - 1][j]);
			if(j >= a[i]) dp[i][j] = max(dp[i][j], dp[i - 1][j - a[i]] + b[i]);
		}// 01 背包 
	int ma = 0;
	rep(i, 0, m) if(dp[n][i] > dp[n][ma]) ma = i;
	for(int i = n, j = ma; i; i --) {
		if(dp[i][j] == dp[i - 1][j]) continue; // 未选择 
		j -= a[i];
		vis[i] = 1;
	}
```
然后，我们需要求出在满足上述星球必须落地的前提下的最小代价。考虑 DP。

令 $f_{i, j}$ 表示从 $1\sim i$ 星球并且在 $i$ 着陆，反物质燃料还剩 $j$ 个单位的最小代价。初始 $f_{0, R}=0$，其余为 $\infty$。

状态转移方程为：$f_{i, j}=\min(f_{i,j-1}+P_i, f_{k, j+2}+F_i\ |\ L_i-L_k \le L_0)$，其表示在 $i$ 星球进行维修与否，以及在之前经过的距离不超过 $L_0$ 的星球 $k$ 进行加油的最小代价。

这样枚举 $i, j, k$ 的复杂度是 $O(n^2R)$，由于 $R>2n$ 时无效，因此 $R\leftarrow \min(R, 2n)$，这样上述动态规划的复杂度为 $O(n^3)$，依然超时。

由于出现 $\min$，以及 $L_i-L_k\le L_0$ 的限制条件，联想到单调队列。这样省去了对 $k$ 的枚举，时空复杂度均为 $O(nR)=\Theta(n^2)$。本题空间较紧，注意不要开过大的二维数组引起浪费。

在单调队列时，不要忘记 01 背包必经点的特殊处理。

## 完整代码
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> PII;
typedef double db;
const int maxn = 2e3 + 5, inf = 0x3f3f3f3f;
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;
int n, m, ran, len;
int a[maxn], b[maxn], l[maxn], price[maxn], cost[maxn];
int dp[maxn][maxn]; // 01背包
int f[maxn][maxn*2], q[maxn*2][maxn], head[maxn*2], tail[maxn*2]; // 单调队列，f[i][j]表示从1~i，还剩j油量的最小代价 
bool vis[maxn];
int main () {
	read(n); read(m); read(ran); read(len);
	if(ran > (n << 1)) ran = (n << 1);
	rep(i, 1, n) 
		read(a[i]), read(b[i]), read(l[i]), read(price[i]), read(cost[i]);
	rep(i, 1, n) if(l[i] - l[i - 1] > len) { // 特判 
		puts("Poor Coke!");
		return 0;
	}
	memset(dp, -1, sizeof dp);
	dp[0][0] = 0;
	rep(i, 1, n)
		rep(j, 0, m) {
			dp[i][j] = max(0, dp[i - 1][j]);
			if(j >= a[i]) dp[i][j] = max(dp[i][j], dp[i - 1][j - a[i]] + b[i]);
		}// 01 背包 
	int ma = 0;
	rep(i, 0, m) if(dp[n][i] > dp[n][ma]) ma = i;
	for(int i = n, j = ma; i; i --) {
		if(dp[i][j] == dp[i - 1][j]) continue; // 未选择 
		j -= a[i];
		vis[i] = 1;
	}
	memset(f, inf, sizeof f);
	f[0][ran] = 0;
	q[ran][tail[ran] ++] = 0;
	rep(i, 1, n)
		rep(j, 0, ran) {
			if(price[i] > 0 && j > 0) f[i][j] = min(f[i][j], f[i][j - 1] + price[i]);
			if(head[j + 2] < tail[j + 2])
				f[i][j] = min(f[i][j], f[q[j + 2][head[j + 2]]][j + 2] + cost[i]);
			if(vis[i]) head[j] = tail[j] = 0;
			while(head[j] < tail[j] && f[q[j][tail[j] - 1]][j] > f[i][j]) tail[j] --;
			q[j][tail[j] ++] = i;
			while(head[j] < tail[j] && l[i + 1] - l[q[j][head[j]]] > len) head[j] ++;
		}
	int mi = 0;
	rep(i, 0, ran) 
		if(f[n][i] < f[n][mi]) mi = i;
	if(f[n][mi] == inf) puts("Poor Coke!");
	else write(dp[n][ma]), putchar(' '), write(dp[n][ma] - f[n][mi]);
	return 0;
}
```

---

## 作者：Jerrywang09 (赞：0)

本题的题面很复杂啊……有几个要点需要注意：经过任何一个星球，都必须要进行飞船维护；从一个星球转移到另一个，所消耗的燃料是 $2$。

第一问很简单。问你最大贸易额是多少，不计一切代价！假设可以完成任务，则第一问答案直接背包即可。

第二问才是难点。数据有一个很好的性质：只有一种获得最大贸易额的方法。这启发我们倒推 DP 状态，就可以找到在哪些星球上卖货。设 $g(i,j)$ 表示到了第 $i$ 个星球，剩余能量是 $j$，最小代价。考虑两种转移：

1.
$$
g(i,j)\gets \max_{L_k\ge L_i-L_0\land L_k\ge pre}(g(k, j+2)+F_i)
$$

上面这个 $pre$ 的含义是：$i$ 前面最近的一定要卖货的星球。由于 $i$ 星球可能只充能量不卖货，因此要保证一定要经过前一个卖货的星球。

2. 
$$
g(i,j)\gets \max(g(i, j), g(i, j-1)+P_i)
$$

这就是在当前星球上充能量的转移。需要保证 $P_i>0$。

针对第一个转移，$k$ 类似滑动窗口，考虑使用单调队列维护。代码中的单调队列封装成结构体，更好写。

令注：数据范围应该是 $R\le 10^7$，题面中写错了，已经发送工单。但是最多只会消耗 $2n$ 的能量，取 $\min$ 即可。

再次更新：题面的数据范围已经改对了。

```cpp
// P2317 [HNOI2005] 星际贸易
#include <cstdio>
#include <iostream>
#include <cstring>
#define ll long long
#define rep(i, s, t) for(int i=s; i<=t; ++i)
#define debug(x) cerr<<#x<<":"<<x<<endl;
const int N=2005, M=4005, inf=0x3f3f3f3f;
using namespace std;
char buf[1<<21], *p1=buf, *p2=buf;
#define gc() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline int read()
{
    int x=0, f=1; char c=gc();
    while(c<'0' || c>'9') c=='-' && (f=-1), c=gc();
    while('0'<=c && c<='9') x=(x<<3)+(x<<1)+c-'0', c=gc();
    return x*f;
}

#define no return puts("Poor Coke!"), 0;
int n, m, r, L, a[N], b[N], l[N], p[N], F[N]; bool flag[N];
int f[N][N], g[N][M];
inline void upd(int &x, int y) {x=y>x?x:y;}

struct monoque
{
    struct node {int l, f;} q[N];
    int hh=1, tt;
    inline int query(int x)
    {
        while(hh<=tt && q[hh].l<x) ++hh;
        return hh<=tt?q[hh].f:inf;
    }
    inline void upd(int l, int f)
    {
        while(hh<=tt && q[tt].f>=f) --tt;
        q[++tt]={l, f};
    }
} q[M];

int main()
{
#ifdef Jerrywang
    freopen("E:/OI/in.txt", "r", stdin);
#endif
    n=read(), m=read(), r=read(), L=read(); r=min(r, n+n);
    rep(i, 1, n) a[i]=read(), b[i]=read(), l[i]=read(), p[i]=read(), F[i]=read();
    rep(i, 1, n) if(l[i]-l[i-1]>L) no
    memset(f, -0x3f, sizeof f);
    f[0][0]=0;
    rep(i, 1, n)
    {
        rep(j, 0, m) 
        {
            f[i][j]=f[i-1][j];
            if(j>=a[i]) f[i][j]=max(f[i][j], f[i-1][j-a[i]]+b[i]);
        }
    }
    int mxj=0;
    rep(j, 1, m) if(f[n][j]>f[n][mxj]) mxj=j;
    int j=mxj;
    for(int i=n; i; i--)
    {
        if(j>=a[i] && f[i][j]==f[i-1][j-a[i]]+b[i])
            j-=a[i], flag[i]=1;
    }
    memset(g, 0x3f, sizeof g);
    g[0][r]=0; q[r].upd(0, 0);
    int pre=0;
    rep(i, 1, n)
    {
        rep(j, 0, r)
        {
            if(p[i] && j) upd(g[i][j], g[i][j-1]+p[i]);
            int lo=max(pre, l[i]-L);
            upd(g[i][j], q[j+2].query(lo)+F[i]);
            q[j].upd(l[i], g[i][j]);
        }
        if(flag[i]) pre=l[i];
    }
    int res2=inf;
    rep(j, 0, r) upd(res2, g[n][j]);
    if(res2==inf) no
    printf("%d %d", f[n][mxj], f[n][mxj]-res2);

    return 0;
}
```

---

## 作者：xuantianhao (赞：0)

## [[HNOI2005] 星际贸易](https://www.luogu.com.cn/problem/P2317)

第一问直接背包一下就行，是模板。

然后，因为题面中的一句话：

并使得只有一种获得最大贸易值的方法。

因此我们可以直接根据各状态是从哪个前驱状态转移而来直接得出那些必须要访问的星球。

注意，你所规定的这条路径必须满足贸易值最大（不管合不合法（走不走的完），但贸易值必须最大），不然你就会像我一样死活看不懂第二组样例……

我们考虑 DP。

设 $f[i][j]$ 表示：当前在位置 $i$，已经进行了所有的操作随时可以起飞，并且当前舰上还有 $j$ 份燃料的最小代价。

思路一，暴力 DP：

令 $k$ 为 $i$ 之前距离 $i$ 最近的那个必须访问的星球和 $i$ 之前飞船不维修最远能到的那个星球的最大值，那么我们有

$f[i][j]=\min\limits_{k}^{i-1}\{\min\limits_{l=2}^{\min(r,j+2)}f[k][l]+(j-l+2)\times p[i]+g[i]\}$

其中，$p[i]$ 是 $i$ 星球一份暗物质的费用，$g[i]$ 是 $i$ 位置修船的费用。

复杂度 $O(n^4)$，可以拿到 $55\%$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,r,l,a[2010],b[2010],dis[2010],p[2010],fx[2010],f[2010][4010],mp,mn=0x3f3f3f3f;
bool cho[2010];
int main(){
    scanf("%d%d%d%d",&n,&m,&r,&l),memset(f,0x80,sizeof(f)),r=min(r,2*n);
    if(r<2){puts("Poor Coke!");return 0;}
    for(int i=1;i<=n;i++)scanf("%d%d%d%d%d",&a[i],&b[i],&dis[i],&p[i],&fx[i]);
    for(int i=1;i<=n;i++)if(dis[i]-dis[i-1]>l){puts("Poor Coke!");return 0;}
    f[0][0]=0;
    for(int i=1;i<=n;i++){
        for(int j=0;j<a[i];j++)f[i][j]=f[i-1][j];
        for(int j=a[i];j<=m;j++)f[i][j]=max(f[i-1][j],f[i-1][j-a[i]]+b[i]);
    }
    for(int i=0;i<=m;i++)if(f[n][mp]<f[n][i])mp=i;
    for(int i=n,j=mp;i;i--){
        if(f[i][j]==f[i-1][j])continue;
        cho[i]=true,j-=a[i];
    }
//  for(int i=1;i<=n;i++)printf("%d ",cho[i]);puts("");
    mp=f[n][mp];
    memset(f,0x3f,sizeof(f));
    f[0][r]=0;
    for(int i=1;i<=n;i++)for(int j=0;j<=r;j++){
        for(int k=i-1;k>=0;k--){
            if(dis[i]-dis[k]>l)break;
            if(!p[i]){
                if(j>=2)f[i][j]=min(f[i][j],f[k][j+2]+fx[i]);
                else f[i][j]=0x3f3f3f3f;
            }
            else for(int l=2;l<=min(j+2,r);l++)f[i][j]=min(f[i][j],f[k][l]+(j-l+2)*p[i]+fx[i]);
            if(cho[k])break;
        }
//      printf("%d %d:%d\n",i,j,f[i][j]);
    }
    for(int i=0;i<=r;i++)mn=min(mn,f[n][i]);
    if(mn==0x3f3f3f3f){puts("Poor Coke!");return 0;}
    printf("%d %d\n",mp,mp-mn);
    return 0;
} 
```

思路二，背包

因为在位置 $i$ 买暗物质的操作实际上就是一个完全背包的效果，所以我们完全可以不枚举 $l$，转而采用完全背包的形式在 $O(n^3)$ 解决它。可以拿到 $65\%$。

即：

$$f[i][j]=\min(f[k][j+2]+f[i],f[i][j-1]+p[i])$$

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,r,l,a[2010],b[2010],dis[2010],p[2010],fx[2010],f[2010][4010],mp,mn=0x3f3f3f3f;
bool cho[2010];
int main(){
    scanf("%d%d%d%d",&n,&m,&r,&l),memset(f,0x80,sizeof(f)),r=min(r,2*n);
    if(r<2){puts("Poor Coke!");return 0;}
    for(int i=1;i<=n;i++)scanf("%d%d%d%d%d",&a[i],&b[i],&dis[i],&p[i],&fx[i]);
    for(int i=1;i<=n;i++)if(dis[i]-dis[i-1]>l){puts("Poor Coke!");return 0;}
    f[0][0]=0;
    for(int i=1;i<=n;i++){
        for(int j=0;j<a[i];j++)f[i][j]=f[i-1][j];
        for(int j=a[i];j<=m;j++)f[i][j]=max(f[i-1][j],f[i-1][j-a[i]]+b[i]);
    }
    for(int i=0;i<=m;i++)if(f[n][mp]<f[n][i])mp=i;
    for(int i=n,j=mp;i;i--){
        if(f[i][j]==f[i-1][j])continue;
        cho[i]=true,j-=a[i];
    }
//  for(int i=1;i<=n;i++)printf("%d ",cho[i]);puts("");
    mp=f[n][mp];
    memset(f,0x3f,sizeof(f));
    f[0][r]=0;
    for(int i=1;i<=n;i++)for(int j=0;j<=r;j++){
        for(int k=i-1;k>=0;k--){
            if(dis[i]-dis[k]>l)break;
            f[i][j]=min(f[i][j],f[k][j+2]+fx[i]);
            if(cho[k])break;
        }
        if(p[i]&&j)f[i][j]=min(f[i][j],f[i][j-1]+p[i]);
//      printf("%d %d:%d\n",i,j,f[i][j]);
    }
    for(int i=0;i<=r;i++)mn=min(mn,f[n][i]);
    if(mn==0x3f3f3f3f){puts("Poor Coke!");return 0;}
    printf("%d %d\n",mp,mp-mn);
    return 0;
} 
```

思路三，单调队列

因为 $f[k][j+2]$ 这个东西随着 $i$ 的增加，每个 $i$ 都要枚举一下，因此可以采用单调队列来保存每个暗物质数量 $j$ 可以转移的最优位置，并且按照距离及时弹出已经距离 $i$ 太远的位置。复杂度 $O(n^2)$，期望得分 $100\%$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,r,l,a[2010],b[2010],dis[2010],p[2010],fx[2010],f[2010][4010],mp,mn=0x3f3f3f3f;
deque<int>q[2010];
bool cho[2010];
int main(){
    scanf("%d%d%d%d",&n,&m,&r,&l),memset(f,0x80,sizeof(f)),r=min(r,2*n);
    if(r<2){puts("Poor Coke!");return 0;}
    for(int i=1;i<=n;i++)scanf("%d%d%d%d%d",&a[i],&b[i],&dis[i],&p[i],&fx[i]);
    for(int i=1;i<=n;i++)if(dis[i]-dis[i-1]>l){puts("Poor Coke!");return 0;}
    f[0][0]=0;
    for(int i=1;i<=n;i++){
        for(int j=0;j<a[i];j++)f[i][j]=f[i-1][j];
        for(int j=a[i];j<=m;j++)f[i][j]=max(f[i-1][j],f[i-1][j-a[i]]+b[i]);
    }
    for(int i=0;i<=m;i++)if(f[n][mp]<f[n][i])mp=i;
    for(int i=n,j=mp;i;i--){
        if(f[i][j]==f[i-1][j])continue;
        cho[i]=true,j-=a[i];
    }
//  for(int i=1;i<=n;i++)printf("%d ",cho[i]);puts("");
    mp=f[n][mp];
    memset(f,0x3f,sizeof(f));
    f[0][r]=0;
    for(int i=1;i<=n;i++)for(int j=0;j<=r;j++){
        while(!q[j+2].empty()&&dis[i]-dis[q[j+2].front()]>l)q[j+2].pop_front();
        while(!q[j+2].empty()&&f[q[j+2].back()][j+2]>=f[i-1][j+2])q[j+2].pop_back();
        q[j+2].push_back(i-1);
        f[i][j]=min(f[i][j],f[q[j+2].front()][j+2]+fx[i]);
        if(p[i]&&j)f[i][j]=min(f[i][j],f[i][j-1]+p[i]);
        if(cho[i])q[j+2].clear();
//      printf("%d %d:%d\n",i,j,f[i][j]);
    }
    for(int i=0;i<=r;i++)mn=min(mn,f[n][i]);
    if(mn==0x3f3f3f3f){puts("Poor Coke!");return 0;}
    printf("%d %d\n",mp,mp-mn);
    return 0;
} 

```

---

## 作者：Yuby (赞：0)

[题面](https://www.luogu.com.cn/problem/P2317)

#### 题意解释

题面中有一点体现的一般。就是在必须走贸易值最大的路上，哪怕走不完也要这样走。

#### 分析

因为题目中说必须要走贸易值最大的路线，我们不妨把这个问题拆分为求最大贸易值和求最小代价。

我们可以把这个路线直接处理出来。这时我们就得到了必须要访问的星球是哪些。非常简单，01 背包模板，$f_{i,j}$ 表示前 $i$ 个星球剩下了 $j$ 的货物的最大贸易值，就不细讲了。

然后我们考虑最小代价问题。$dp_{i,j}$ 表示到了前 $i$ 个星球补充完燃料且已经进行修复后有 $j$ 个燃料的最小代价。

我们发现在某个星球购买燃料是一个完全背包问题，直接从 $dp_{i,j-1}$ 转移即可。再考虑飞船的修复问题了，不妨直接枚举一个 $k$ ，因为从一个星球到另一个星球的燃料为 $2$ ，所以直接从 $dp_{k,j+2}$ 转移即可。此时复杂度为 $O(n^2r)$。注意到从一个星球到另一个星球的代价恒为 $2$，从 $0$ 到 $n$ 最多只需要 $2n$ 个燃料即可，此时 $r$ 的范围变为了 $2n\leq 4000$。复杂度变为 $O(n^3)$，仍然不能通过。

这时的转移方程：

$dp_{i,j}=\min\limits_{k=0}^{i-1} dp_{k,j+2}+f_i$

$dp_{i,j}=min(dp_{i,j},dp_{i,j-1}+p_i)$

第二个显然转移复杂度为 $O(1)$。第一个则为 $O(n)$。但是不难发现第一个就是一个[滑动窗口](https://www.luogu.com.cn/problem/P1886)问题，直接单调队列优化。对于每一个 $j$ 我们用一个单调队列维护前 $i-1$ 个中的最小值即可。

总复杂度：$O(n^2)$。

代码：

```cpp
#include<bits/stdc++.h>
#define mem(a,b) memset(a,b,sizeof(a));
#define pc putchar
#define fast_iostream ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
typedef double db;
const ld EPS=1e-8;
const ll INF=ll(1e9+7);
const ll LLINF=ll(1e18+7);
const ld LDEPS=1e-18;
inline ll max(ll x,ll y){return x>y?x:y;}
inline ll min(ll x,ll y){return x<y?x:y;}
inline ld dmax(ld x,ld y){return x>y?x:y;}
inline ld dmin(ld x,ld y){return x<y?x:y;}
inline ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}
inline ll lcm(ll a,ll b){return a*b/gcd(a,b);}
inline ll lowbit(ll x){return x&(-x);}
inline ll read(){ll read_result=0,is_below_0=0;char now_ch=0;while(!isdigit(now_ch)){is_below_0|=now_ch=='-';now_ch=getchar();}while(isdigit(now_ch)){read_result=(read_result<<3)+(read_result<<1)+(now_ch^48);now_ch=getchar();}return is_below_0?-read_result:read_result;}
inline ld dread(){ld x=0,d=0.1;char f=0,ch=getchar();while(!isdigit(ch))f|=(ch=='-'),ch=getchar();while(isdigit(ch)) x=x*10+ch-48,ch=getchar();if(ch=='.'){ch=getchar();while(isdigit(ch))x+=d*(ch^48),d*=0.1,ch=getchar();}return f?-x:x;}
inline void write(ll x){if(x<0){putchar('-');x=-x;}if(x>9){write(x/10);}putchar(x%10+'0');}
const ll MAXN=2007,MAXM=4007;
ll n,m,r,L,f[MAXN][MAXM],dp[MAXN][MAXN];
bitset<MAXN>path;
struct node
{
	ll a,b,l,p,f;
}st[MAXN];
struct Monoque{
	ll q[MAXN],st,ed;
	void init(){st=0,ed=0;}
	ll size(){return ed-st;}
	void clear(){st=0,ed=0;}
	void push_back(ll x){q[ed++]=x;}
	void pop_back(){ed--;}
	void pop_front(){st++;}
	ll front(){return q[st];}
	ll back(){return q[ed-1];}
}que[MAXN];
int main()
{
 	//freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
	n=read(),m=read(),r=read(),L=read();r=min(r,2*n);st[0].l=0;
	for(ll i=1;i<=n;i++)
		st[i].a=read(),st[i].b=read(),st[i].l=read(),st[i].p=read(),st[i].f=read();
	for(ll i=1;i<=n;i++)
		if(st[i].l-st[i-1].l>L)
		{
			puts("Poor Coke!");
			return 0;
		}
	if(r<2)
	{
		puts("Poor Coke!");
		return 0;
	}
	for(ll i=0;i<=n;i++)for(ll j=0;j<=m;j++)f[i][j]=-LLINF;f[0][0]=0;
	for(ll i=0;i<=n;i++)for(ll j=0;j<=max(r+2,m);j++)dp[i][j]=LLINF;dp[0][r]=0;
	for(ll i=1;i<=n;i++)
		for(ll j=0;j<=m;j++)
		{
			f[i][j]=f[i-1][j];
			if(j>=st[i].a)f[i][j]=max(f[i][j],f[i-1][j-st[i].a]+st[i].b);//01 背包
		}
	ll pos=0;
	for(ll i=0;i<=m;i++)if(f[n][pos]<f[n][i])pos=i;
	for(ll i=n,j=pos;i>=1;i--)
	{
		if(f[i][j]==f[i-1][j])continue;
		path[i]=1,j-=st[i].a;//记录必须取的点（最优路径上的点）
	}
	for(ll i=1;i<=n;i++)for(ll j=0;j<=r;j++)
	{
		while(que[j+2].size()&&st[i].l-st[que[j+2].front()].l>L)que[j+2].pop_front();
		while(que[j+2].size()&&dp[que[j+2].back()][j+2]>=dp[i-1][j+2])que[j+2].pop_back();
		que[j+2].push_back(i-1);
		dp[i][j]=min(dp[i][j],dp[que[j+2].front()][j+2]+st[i].f);
		if(st[i].p&&j)dp[i][j]=min(dp[i][j],dp[i][j-1]+st[i].p);
		if(path[i])que[j+2].clear();
	}
	ll ans=LLINF;
	for(ll i=0;i<=r;i++)ans=min(ans,dp[n][i]);
	if(ans==LLINF)puts("Poor Coke!");
	else write(f[n][pos]),pc(32),write(f[n][pos]-ans);
	return 0;
}
```



---

## 作者：小木虫 (赞：0)

这道题属于是很麻烦的那一类 dp ，我们慢慢说。  
首先题面上的“不惜血本”意味着贸易额是第一关键字，同时题目也告诉我们只有一种获得最大贸易额的方法，这就几乎锁定了我们的目标是先跑一边贸易额 dp ，记录路径，再在路径上进行第二次 dp 。  
题目在油量数据上欺骗了我们，我们发现根本就没有 $1e9$ 的数据，最多用$2*n$个单位的油。  
对于第二次 dp ，我们有状态转移方程：  
$dpi,j$= $\min$($dp k,j+2+Fi$ ,$dp i$ ,$j$ −$1$  $+Pi) ,    Li-Lk\leq L0 $   


是 $n^3$ 的复杂度，但是我们发现第三层循环在 min 的左半部分，  
而它是一个 滑 动 窗 口。  
dp 爱好者狂喜。  
直接建 j 个单调队列。（每个油量都有份）  
$n^2$ 优化完毕。  
核心代码贴一下：

```cpp
for(int i=1;i<=n;i++){
	for(int j=0;j<=min(r,2*n);j++){
		if(j>=1&&p[i]!=1e9)
			g[i][j]=min(g[i][j],g[i][j-1]+p[i]);
		if(j+2<=min(2*n,r)){
			while(w[i]-w[Q[j+2][head[j+2]].star]>l&&head[j+2]<=tail[j+2])head[j+2]++;
			if(head[j+2]<=tail[j+2])
				g[i][j]=min(g[i][j],Q[j+2][head[j+2]].data+f[i]);
		}
		while(Q[j][tail[j]].data>g[i][j]&&head[j]<=tail[j])tail[j]--;
		Q[j][++tail[j]].data=g[i][j];
		Q[j][tail[j]].star=i;
	}
	if(vippoint[i]){
		for(int j=0;j<=min(r,2*n);j++){
			head[j]=tail[j]; 
		}
	}
}
```


---

## 作者：YNH_QAQ (赞：0)

## 思路
解题分两部分：
1. 最大贸易额度。
2. 最大利润。
### 第一部分（背包问题）
转化得背包问题：
$n$ 个物品，背包容量为 $m$，每个物品体积 $a$ 和价值 $b$，不细说了。
### 第二部分（动态规划）
状态：$dp_{i,j}$ 表示在第 $i$ 个星球还剩 $j$ 单位的反物质燃料情况下的最少代价。

转移：当 $l_i-l_k\le l_0$ 时 $dp_{i,j}=\min(dp_{k,j+2}+f_i,dp_{i,j-1}+p_i)$。

优化：维护单调队列，保持滑动窗口 $k$ 的最优转移。

时间复杂度：$O(n^2)$。

标程不想给。

---


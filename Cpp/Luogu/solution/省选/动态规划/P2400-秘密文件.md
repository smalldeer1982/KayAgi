# 秘密文件

## 题目描述

某天，情报局得到了一份秘密文件。文件的内容是加密后的全部由大写字母组成字符串。情报局局长小明想将其发送给远在东方神秘的xx大陆上的老朋友小刘来解密。然而若字符串太长，则需要很长的发送时间，太不安全了，因此小明想尽量将其缩短。于是小明制定了这样一个缩短规则：若一个字符串t连续出现k次，则可以用k(t)进行说明。如ABABAB可以缩成3(AB)。当然，重复缩短是允许的，如ABABABAAAAAAABABABAAAAAA可以缩成2(3(AB)6(A))

现在，小明想知道，对于给定的字符串，最短可以缩成什么样子。

**注意：有多个最优方案时，输出其中字典序最大的。( thanks to @Dilute. )**

## 说明/提示

【数据范围】

对于l00%的数据，字符串的长度L≤100。数据存在一定梯度。


## 样例 #1

### 输入

```
AAAAAAAAAABABABCCD```

### 输出

```
9(A)3(AB)CCD```

# 题解

## 作者：Fleeing_loser (赞：6)

这道题目是[UVA1630](https://www.luogu.com.cn/problem/UVA1630)的弱化版。

一道区间类动态规划的题目。既然是区间类动态规划的题目，那么应该可以分区间进行处理，没错，可以看出一个字符串的变化有两种，拼接缩短和自身缩短，由此可以得出要么由左右两边拼接合并 , 要么自己自身进行缩短，再在这两方面上进行考虑。

# No.1
然后我们推一下状态：

$dp(l,r)$ 表示从第 $l$ 个字符到第 $r$ 个字符的最短串（也表示自身缩短后的字符串长度）。

$dp(l,i)+dp(i+1,r)$ 表示拼接后的字符串的长度。

那么 $dp(l,r)=  \min \{dp(l,r),dp(l,i)+dp(i+1,r)\}$。
# No.2
状态推完后，我们要开始写代码，但是有细节需要注意。一般读取（不是读入）的方式较麻烦，速度上也比较慢，所以应该需要用到快读来处理数据。就是下面代码中的
```cpp
int get(int x)//快读
{
    int t=0;
    while(x)
    {
        x/=10;
        t++;
        
    }
    return t;
}
```
和这个东西
```cpp
string getch(int x)//快读*2
{
	string tmp;
    while(x)
    {
    	tmp=char(x%10+'0')+tmp;
    	x/=10;
    }
    return tmp;
}
```
# No.3
代码部分：
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[105];
int f[105][105];
string ans[105][105];
bool mark[105][105];
bool jud(int l,int r,int cl,int cr)//查找循环元（一个循环扫就行）
{
     if((r-l+1)%(cr-cl+1)!=0)return 0;
     for(int i=l;i<=r;i++)
        if(s[i]!=s[(i-l)%(cr-cl+1)+cl])return 0;
     return 1;
}
int get(int x)//快读
{
    int t=0;
    while(x)
    {
        x/=10;
        t++;
        
    }
    return t;
}
string getch(int x)//快读*2
{
	string tmp;
    while(x)
    {
    	tmp=char(x%10+'0')+tmp;
    	x/=10;
    }
    return tmp;
}
int dp(int l,int r)//dp用来转移求最小，ans负责记录结果
{
    if(mark[l][r])return f[l][r]; 
    if(l==r)
    {
    	ans[l][r]=s[l];
    	return 1;
     }
    mark[l][r]=1;//mark负责标记当前是否最优（就是有没有处理过）
    int t=r-l+1;
    for(int i=l;i<=r;i++)ans[l][r]+=s[i];
    for(int i=l;i<r;i++)
    {
    	int tmp=dp(l,i)+dp(i+1,r);
      if(tmp<t)
        {
        	t=tmp;
        	ans[l][r]=ans[l][i]+ans[i+1][r];
        }
        if(jud(i+1,r,l,i))//找到循环元后处理
        {
        	int tmp=dp(l,i)+2+get((r-i)/(i-l+1)+1);
            if(tmp<t)
			{
			    t=tmp;
                ans[l][r]=getch((r-i)/(i-l+1)+1)+"("+ans[l][i]+")";
            }
        }
    }
    return f[l][r]=t;//减掉该区间内的字符，继续递归寻找
    } 
int main()
{

    scanf("%s",s);
    int l=strlen(s);
    dp(0,l-1);//是L减一（字符串从零开始储存不必多说，但别看花眼）
    cout<<ans[0][l-1];
    return 0;
}
```
[代码](http://hzwer.com/3621.html)是按照黄学长的博客仿写的，大家也可以去看一下。
# No.4
总结一下，本题的思维难度还好，推状态也较容易，就是特别考验代码能力！（像我这种蒟蒻就是会想不会写的那种）


---

## 作者：EuphoricStar (赞：6)

## 思路

比较套路的区间 DP。

设 $f_{i,j}$ 为区间 $[l,r]$ 最短可以压缩到的长度，则转移方程为：

1. $f_{i,j}=\min\limits_{k=i}^{j-1}{f_{i,k}+f_{k+1,j}}$

这个比较好理解，就是将 $[i,k]$ 和 $[k+1,j]$ 两段已经压缩到最短的字符串直接拼在一起。

2. $f_{i,j}=\min\limits_{k=1}^{j-i}f_{i,i+k-1}+2+\operatorname{digit}(\frac{j-i+1}{k})$（$k$ 是 $j-i+1$ 的因数且 $[i,i+k-1]$ 是 $[i,j]$ 的一个周期）

这个也不是很难想，因为是周期，所以可以压缩，长度即为 $[i,i+k-1]$ 可以压缩到的最短长度加上两个括号再加上 $\frac{j-i+1}{k}$ 的位数（$\frac{j-i+1}{k}$ 表示这个周期连续出现的次数）。

由于题目还要求输出方案，所以用 $ans_{i,j}$ 记录 $[i,j]$ 最短可以压缩到的字符串，当发现有更优决策时更新 $ans_{i,j}$ 即可。

边界条件为：$f_{i,i}=1$，$ans_{i,i}=s_i$。

附赠三倍经验：[P4302](https://www.luogu.com.cn/problem/P4302)，[UVA1630](https://www.luogu.com.cn/problem/UVA1630)

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, f[110][110];
string s, ans[110][110];

int digit(int x) {
    int res = 0;
    while (x) {
        ++res;
        x /= 10;
    }
    return res;
}

string int2str(int x) {
    stringstream ss;
    ss << x;
    return ss.str();
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> s;
    n = s.size();
    s = ' ' + s;
    memset(f, 0x3f, sizeof(f));
    for (int i = 1; i <= n; ++i) {
        for (int j = i; j <= n; ++j) {
            ans[i][j] = "";
        }
    }
    for (int i = 1; i <= n; ++i) {
        f[i][i] = 1;
        ans[i][i] = s[i];
    }
    for (int p = 2; p <= n; ++p) {
        for (int i = 1, j = p; j <= n; ++i, ++j) {
            for (int k = i; k < j; ++k) {
                if (f[i][j] > f[i][k] + f[k + 1][j]) {
                    f[i][j] = f[i][k] + f[k + 1][j];
                    ans[i][j] = ans[i][k] + ans[k + 1][j];
                }
            }
            for (int k = 1; k < p; ++k) {
                if (p % k) {
                    continue;
                }
                bool flag = 1;
                for (int l = k; l + i <= j; ++l) {
                    if (s[l + i] != s[l % k + i]) {
                        flag = 0;
                        break;
                    }
                }
                if (flag) {
                    if (f[i][j] > f[i][i + k - 1] + 2 + digit(p / k)) {
                        f[i][j] = f[i][i + k - 1] + 2 + digit(p / k);
                        ans[i][j] = int2str(p / k) + '(' + ans[i][i + k - 1] + ')';
                    }
                }
            }
        }
    }
    cout << ans[1][n] << endl;
    return 0;
}
```


---

## 作者：黎明行者 (赞：6)

区间DP+KMP的next数组

我们不妨把一个由多个重复字符串拼接成的字符串称为 周期串

不难想到区间dp

    dp[i,j]表示子串[i,j]的最优解

    若[i,j]不含周期串，则其最优解一定是子串[i,j]本身

    若子串[i,j]含周期串则把[i,j]分割成两段，枚举断点k，dp[i,j]由dp[i,k] dp[k+1,j]转移

    [i,j]如果是一个周期串 则dp[i,j]可以由

    dp[i,i-1+子串[i,j]的最小周期]转移得来

那么我们下一步就要考虑如何快速判定一个字符串是否为周期串，以及如何快速求出一个周期串的最小周期

一个字符串如果是周期串，那么它可以自己和自己匹配，我们可以用KMP的next数组来解决这个问题

首先对原字符串的每一个后缀求出next数组，为了方便，以第i位为首的后缀的next数组下标从i开始

可以证明:当且仅当
(j-i+1-next[i,j])%next[i,j]==0 时 [i,j]为周期串

其最小周期就是(j-i+1-next[i,j])/next[i,j]

处理完next数组后处理出一个bool数组记录每一个子串是否包含子串

就下来就可以愉快的dp啦~

总时间复杂度O(n^3)

O(n^3)的复杂度看似十分暴力，但是由于n<=100，所以AC绝对没问题

注意:

	1)输出任意解不一定正确，必须输出字典序最大的解. STL的string重载了比较运算符>和<可以比较两个字符串的字典序大小

	2)string的length函数的时间复杂度时O(n)的

---

## 作者：封禁用户 (赞：5)

好坑啊，其实裸的区间DP，为什么上一篇题解这么深奥记一下l,r最短的长度和l,r最短长度的字符串，string超方便的

代码剧短只有40行
```cpp
#include <cstdio>
#include <string>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
#define N 105
string s,ss[N][N];
int n,f[N][N];
inline int jud(int l,int r)
{
	int i,j,bo;
	for(i=1;i<=(r-l+1)/2;i++)
	{
		if(((r-l+1)%i)==0)
		{
			bo=0;for(j=l;j+i<=r;j++)if(s[j]!=s[j+i]){bo=1;break;}if(!bo)return i;
		}
	}return -1;
}
inline int dfs(int l,int r)
{
	if(f[l][r]!=-1)return f[l][r]; if(l==r){f[l][r]=1;ss[l][r]=s[l];return 1;}
	int re=1e5,po,i,tmp;
	for(i=l;i<r;i++)
	{
		tmp=dfs(l,i)+dfs(i+1,r); if(re>tmp){re=tmp;po=i;}
	}ss[l][r]=ss[l][po]+ss[po+1][r]; int le=jud(l,r);
	if(le!=-1)
	{
		string t,nes;char ch; tmp=(r-l+1)/le;
		while(tmp){ch=tmp%10+'0';t.push_back(ch);tmp/=10;} reverse(t.begin(),t.end());
		nes=t+(string)("(")+ss[l][l+le-1]+(string)(")");
		if(nes.size()<re){re=nes.size();ss[l][r]=nes;}
	}return f[l][r]=re;
}
int main()
{
	int i; memset(f,-1,sizeof f); cin>>s; n=s.size(); dfs(0,n-1); cout<<ss[0][n-1]<<endl;
}
```

---

## 作者：critnos (赞：3)

区间 dp 题。

对于一个区间 $[l,r]$ 有两种拆分方法：

1. 直接用这个区间的循环节压缩。

2. 拆为 $dp[l,i]+dp[i+1,r]$。

直接这样写拿到了 77pts。

为什么有问题呢？事实上方式 $1$ 的循环节是可以继续进行压缩的，题面中的”当然，重复缩短是允许的“。那再把循环节转移一下即可。

用记忆化搜索写起来很顺。

一些实现细节：

1. 比较字符串大小时要先比较长度。

2. 判断区间 $[l,r]$ 的循环节长度是否能为 $len$ 时要满足 $(r-l+1)\bmod len=0$ 且 $[l,r-len]=[l+len,r]$

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[105];
string dp[105][105];
bool ask(int l,int r,int len)
{
	for(int i=l;i<=r-len;i++)
		if(a[i]!=a[i+len])
			return 0;
	return 1;
}
string min_(string a,string b)
{
	if(a.size()<b.size()) return a;
	if(a.size()>b.size()) return b;
	return min(a,b);
}
string tostring(int x)
{
	string s;
	while(x)
		s=char(x%10+'0')+s,x/=10;
	return s;
}
string dfs(int l,int r)
{
	if(dp[l][r]!="") return dp[l][r];
	string ans;
	int i,j;
	for(i=l;i<=r;i++)
		ans+=a[i];
	for(i=1;i<r-l+1;i++)
		if((r-l+1)%i==0&&ask(l,r,i))
			ans=min_(ans,tostring((r-l+1)/i)+'('+dfs(l,l+i-1)+')');
	for(i=l;i<r;i++)
		ans=min_(ans,dfs(l,i)+dfs(i+1,r));
	return dp[l][r]=ans;
}
int main()
{
	int n;
	scanf("%s",a+1);
	n=strlen(a+1);
	cout<<dfs(1,n);
}
```


---

## 作者：yaoxiangyuan (赞：2)

思路框架整理
------------
### 1.考点

双向 dp。

### 2.状态设定

$f[l,r]$ 表示 $l$ $-$ $r$ 折叠成的最小长度。

### 3.转移

分为两部分：

① 区间 dp 常见解法——拆开序列

$$f[l,r]=\max {f[l,k] + f[k+1,r]}$$

② 不断重复 $f[l,r]$，尝试用它更新更长的 $f[l,ed]$，其中 $ed=r+len$,$r+2 \times len,$…

### 4.打印方案

递归输出即可。

### 5.时间复杂度
$O(n^3)$

代码的话网上有很多，不再给出了。

---

## 作者：Super_Cube (赞：1)

# Solution

区间 dp。设 $dp_{i,j}$ 表示将字符串中区间 $[i,j]$ 压缩后能得到的最短字符串长度。首先有经典转移：$dp_{i,j}=\displaystyle\min_{k=i}^{j-1}dp_{i,k}+dp_{k+1,j}$；还有种情况是 $i\sim j$ 这一段恰好可被压缩，即存在长度为 $k$ 的循环节，那么转移为：$dp_{i,j}=\min\left(dp_{i,j},\left\lfloor\log_{10}\dfrac{j-i+1}{k}\right\rfloor+3+dp_{i,i+k-1}\right)$。初始化 $dp_{i,i}=1$，最后压缩能得到的最短长度为 $dp_{1,n}$。

怎么判循环节？字符串哈希。

时间复杂度：$O(n^3)$。

怎么求方案？记录每个 dp 值是从哪里转移过来的，递归输出即可。

注意到这题没打 spj，要求输出最大字典序的方案，所以要先考虑拼接，再考虑压缩。

---

## 作者：block_in_mc (赞：1)

## 解题思路

考虑区间 dp。用 $dp_{l,r}$ 代表字符串的第 $l\sim r$ 项最短的**字符串**表示形式。初始时，$dp_{l,r}=s_{l\cdots r}$。显然，$dp_{l,r}$ 只可能由以下两种方式生成：

- 对于整数 $l\le k<r$，由 $dp_{l,k}$ 和 $dp_{k+1,r}$ 拼接而成；
- 对于 $r-l+1$ 的因数 $k$，若 $s_{l\cdots r}$ 为 $s_{l,l+k-1}$ 重复 $\dfrac{r-l+1}{k}$ 次，$dp_{l,l+k-1}$ 由 $dp_{l,l+k-1}$ 加上个数与括号而来。

具体地：

$$dp_{l,r}=\mathop{\min}\limits_{k=l}^{r-1}dp_{l,k}+dp_{k+1,r}$$

$$dp_{l,r}=\mathop{\min}\limits_{\text{满足条件的}k}|\dfrac{r-l+1}{k}|+\texttt(+dp_{l,l+k-1}+\texttt)$$

其中 $|x|$ 代表 $x$ 的字符串形式，称字符串 $a<b$ 当 $a$ 的长度小于 $b$ 的长度。

判断 $s_{l\cdots r}$ 能否由长度为 $k$ 的串重复得到时，可以判断 $s_{l\cdots r-k}$ 与 $s_{l+k-1\cdots r}$ 是否相等。

## AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, l, r;
string s, ans[110][110];
int main() {
    cin >> s; s = " " + s;
    n = s.length() - 1;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            ans[i][j] = s.substr(i, j - i + 1);
    for (int len = 2; len <= n; len++) {
        for (l = 1; (r = l + len - 1) <= n; l++) {
            for (int k = 1; k < r; k++) 
                if (ans[l][k].length() + ans[k + 1][r].length() < ans[l][r].length()) 
                    ans[l][r] = ans[l][k] + ans[k + 1][r];
            for (int k = 1; k < len; k++) 
                if (len % k == 0 && s.substr(l, len - k) == s.substr(l + k, len - k)) 
                    if ((to_string(len / k) + "(" + ans[l][l + k - 1] + ")").length() < ans[l][r].length()) 
                        ans[l][r] = to_string(len / k) + "(" + ans[l][l + k - 1] + ")";
        }
    }
    cout << ans[1][n];
    return 0;
}
```

---

## 作者：Lijiangjun4 (赞：1)

# P2400 秘密文件
## 思路分析
可以看出这是一道**区间 DP** 的题目。

### 1.状态设计
观察样例 `AAAAAAAAAABABABCCD` 的压缩结果 `9(A)3(AB)CCD`，发现 `9(A)` 由 `AAAAAAAAA` 压缩得到，`3(AB)` 由 `ABABAB` 压缩得到。由此启发得状态设计：**定义 $f[i][j]$ 为区间 $[i,j]$ 压缩后的最短长度，$s[i][j]$ 为区间 $[i,j]$ 的最短压缩方案。**

### 2.状态转移方程
通过状态设计时的发现可以得到：区间 $[l,r]$ 可以由区间 $[l,k]$ 和 $[k+1,r]$ 合并而来，由此得到第一个状态转移方程：
$$
f[l][r] = \min \{ f[l][k]+f[k+1][r] | l \leq k < r\}
$$
结束了？

观察数据 `abcdabcdabcdabcd` 可以压缩为 `4(abcd)`，没有砍点，不能用上面的公式得到。所以我们还需要考虑**区间 $[l,r]$ 本身就是循环字符串**的情况。

定义函数 `int cycle(int l,int r)` 返回区间 $[l,r]$ 最长的循环节长度，函数体如下：

```cpp
int cycle(int l,int r)
{
	bool flag=false;//是否循环
	for(int len=1;len<=r-l;len++)//枚举长度
	{
		if((r-l+1)%len) continue; //如果枚举的长度不是[l,r]长度的因数就跳过
		flag=true;
		for(int i=l;i<=r-len;i++)
		{
			if(s[i]!=s[i+len])//判断当前字符和下一循环节中相同位置的字符是否相同
			{
				flag=false;
				break;
			}
		}
		if(flag) return len;
	}
	return 0;//不是循环串则返回0
}
```
则如果区间 $[l,r]$ 是循环字符串，第二个状态转移方程为：
$$
f[l][r]=\min (f[l][r],cal((r-l+1)/len)+1+len+1)
$$
其中函数 `int cal (int x)` 为计算数字位数，$len$ 为最长循环节的长度。

别忘了，题目最终要求的是输出方案，所以当 $f[i][j]$ 的值更新时，对应的 $s[i][j]$ 也要更新。

### 3.递推初值
当 $l=r$ 时，显而易见 $f[l][r]=1$，$s[l][r]=a[l]$。

### 4.答案
**注意** string 类型的下标从 $0$ 开始，所以答案为 $s[0][n-1]$。

## AC Code

```cpp
#include<iostream>
#include<sstream>
#include<string>
#include<cstring>
using namespace std;
string s;
int f[105][105];
string ans[105][105];
int cal(int k)
{
	if(k==1) return 0;
	int res=0;
	while(k)
	{
		res++;
		k/=10;
	}
	return res;
}
int cycle(int l,int r)
{
	bool flag=false;
	for(int len=1;len<=r-l;len++)
	{
		if((r-l+1)%len) continue; 
		flag=true;
		for(int i=l;i<=r-len;i++)
		{
			if(s[i]!=s[i+len])
			{
				flag=false;
				break;
			}
		}
		if(flag) return len;
	}
	return 0;
}
string itos(int x)
{
	stringstream s;
	s<<x;
	return s.str();
}
int main()
{
	memset(f,0x7f,sizeof(f));
	cin>>s;
	for(int i=s.size()-1;i>=0;i--)
	{
		for(int j=i;j<s.size();j++)
		{
			if(j==i)
			{
				f[i][j]=1;
				ans[i][j]=s[i];
			}
			for(int k=i;k<j;k++)
			{
				if(f[i][j]>f[i][k]+f[k+1][j])
				{
					f[i][j]=f[i][k]+f[k+1][j];
					ans[i][j]=ans[i][k]+ans[k+1][j];
				}
			}
			int len=cycle(i,j);
			if(len)
			{
				if(f[i][j]>f[i][len+i-1]+cal((j-i+1)/len)+2)
				{
					f[i][j]=f[i][len+i-1]+cal((j-i+1)/len)+2;
					ans[i][j]=itos((j-i+1)/len)+"("+ans[i][len+i-1]+")";
				}
			}
		}
	}
	cout<<ans[0][s.size()-1];
	return 0;
}
```
[在洛谷第一道ac的紫题！！！](https://www.luogu.com.cn/record/173333578)

---

## 作者：Dr_殇 (赞：1)

## 写在前面

说实话看着前面两篇题解，一个没代码，一个码风清奇，实在无力吐糟，就写个题解帮助各位其他的$OIer$们更好的理解这道题吧。

## 题意简述

给你一个字符串，$x$个相同的字符串$s$可以被压缩成$x(s)$的形式，求压缩后的最短字符串。

## 题目分析

首先看一下题目，线性求最值，绝大多数都是什么$DP$啊，贪心啊，二分啊。再看看数据范围$L≤100$，区间$DP$一定是了！当然例外也有很多（$CF$的数据范围有时也很小），可再看看题目举的例子，多个压缩串还能再次压缩，绝$*$是区间$DP$了。

设$f_{i,j}$表示$i$到$j$区间内可以压缩到的最小值，动态转移方程很好得出：

$$
f_{i,j}=min(f_{i,k}+f_{k+1,j}, GetAns(i, j))
$$

$min$中的第一个值自然好理解，区间$DP$起手式，但这个&GetAns&又是什么鬼？

这里$GetAns$函数是指将$i$到$j$区间内不进行拼凑，只是单纯的压缩，所能得到的最小值。

代码自然也很好实现，只需要暴力枚举压缩段$s$的长度即可，代码实现：

```cpp
int Get_Ans(int x, int y) {
	int k = y - x + 1, len = y - x + 1, t, w;// k为最终答案，len为当前子串长度
	string tmp = "";
	bool ok;
	for (int l = x; l <= y; l++) {// 首先无法压缩，便为原串
		tmp = tmp + c[l];
	}
	for (int l = 1; l < len; l++) {
		if (len % l != 0) continue;// 无法整除，不能压缩
		ok = true, w = len / l;// w为压缩的次数x
		for (int i = 1; i <= l; i++) {
			for (int j = 2; j <= w; j++) {
				if (c[x + l * (j - 1) + i - 1] != c[x + i - 1]) {// 判断是否能够压缩
					ok = false;
					break;
				}
			}
			if (!ok) break;
		}
		if (ok) {
			t = 0;
			while (w) {
				w /= 10;
				t++;
			}
			w = len / l;
			if (k > t + 2 + dp[x][x + l - 1]) {// 如果能够压缩并不是该段的长度，而是dp[x][x + l - 1]，因为可以再次压缩
				k = t + 2 + dp[x][x + l - 1];
				tmp = Change(w) + '(' + s[x][x + l - 1] + ')';// 记录压缩成的字符串
			}
			else if (k == t + 2 + dp[x][x + l - 1] and tmp < Change(w) + '(' + s[x][x + l - 1] + ')') tmp = Change(w) + '(' + s[x][x + l - 1] + ')';// 如果长度相同，则找字典序大的
		}
	}
	s[x][y] = tmp;// 最后更新压缩串
	return k;
}
```

最后输出$f_{1,n}$即为答案长度，答案为$s_{1,n}$。

$PS:$一定要输出字典序大的！！！

## 代码如下

```cpp
#include <cmath>
#include <queue>
#include <string>
#include <vector>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define space printf(" ")
#define enter printf("\n")
using namespace std;

int n, dp[105][105];
char c[105];
string s[105][105];

long long Read() {
	long long k = 0, tmp = 1; char c = getchar();
	while (c > '9' or c < '0') {
		if (c == '-') tmp = -1;
		c = getchar();
	}
	while (c <= '9' and c >= '0') {
		k = (k << 1) + (k << 3) + (c ^ 48);
		c = getchar();
	}
	return k * tmp;
}
void Write(long long x) {
	if (x < 0) {
		putchar('-');
		x = -x;
	}
	if (x >= 0 and x <= 9) {
		printf("%c", x + '0');
		return;
	}
	Write(x / 10);
	printf("%c", x % 10 + '0');
}
string Change(int x) {// 将压缩数转移成字符串形式
	string now = "";
	while (x) {
		now = (char)(x % 10 + '0') + now;
		x /= 10;
	}
	return now;
}
int Get_Ans(int l, int y);
void Work();

int main() {
	Work();
}

int Get_Ans(int x, int y) {
	int k = y - x + 1, len = y - x + 1, t, w;// k为最终答案，len为当前子串长度
	string tmp = "";
	bool ok;
	for (int l = x; l <= y; l++) {// 首先无法压缩，便为原串
		tmp = tmp + c[l];
	}
	for (int l = 1; l < len; l++) {
		if (len % l != 0) continue;// 无法整除，不能压缩
		ok = true, w = len / l;// w为压缩的次数x
		for (int i = 1; i <= l; i++) {
			for (int j = 2; j <= w; j++) {
				if (c[x + l * (j - 1) + i - 1] != c[x + i - 1]) {// 判断是否能够压缩
					ok = false;
					break;
				}
			}
			if (!ok) break;
		}
		if (ok) {
			t = 0;
			while (w) {
				w /= 10;
				t++;
			}
			w = len / l;
			if (k > t + 2 + dp[x][x + l - 1]) {// 如果能够压缩并不是该段的长度，而是dp[x][x + l - 1]，因为可以再次压缩
				k = t + 2 + dp[x][x + l - 1];
				tmp = Change(w) + '(' + s[x][x + l - 1] + ')';// 记录压缩成的字符串
			}
			else if (k == t + 2 + dp[x][x + l - 1] and tmp < Change(w) + '(' + s[x][x + l - 1] + ')') tmp = Change(w) + '(' + s[x][x + l - 1] + ')';// 如果长度相同，则找字典序大的
		}
	}
	s[x][y] = tmp;// 最后更新压缩串
	return k;
}

void Work() {
	cin >> c + 1;
	n = strlen(c + 1);
	for (int i = 1; i <= n; i++) {
		dp[i][i] = 1;// 初始化，一定记住，要养成好习惯
		s[i][i] = c[i];
	}
	for (int l = 2; l <= n; l++) {
		for (int i = 1, j; i <= n; i++) {
			j = i + l - 1;
			if (j > n) break;// 再大就没这个串了
			dp[i][j] = Get_Ans(i, j);// 动态转移方程中的第二个参数
			for (int k = i; k < j; k++) {// 第一个参数
				if (dp[i][j] > dp[i][k] + dp[k + 1][j]) {
					dp[i][j] = dp[i][k] + dp[k + 1][j];
					s[i][j] = s[i][k] + s[k + 1][j];// 这个要一起更新
				}
				else if (dp[i][j] == dp[i][k] + dp[k + 1][j] and s[i][j] < s[i][k] + s[k + 1][j]) s[i][j] = s[i][k] + s[k + 1][j];// 也是找字典序大的
			}
		}
	}
	cout << s[1][n] << endl;// 输出答案
}
```

---

## 作者：Union_Find (赞：0)

一道区间动态规划的好题。

这道题其实一眼就知道动态规划，由因为它合并是一段一段的，所以是区间动态规划。但是你每次合并之后，还要看括号内是否能合并，所以可以采取记忆化搜索。定义 $dfs(l,r)$ 为区间 $l$ 到 $r$ 的最短长度，并用 $a[l][r]$ 来存储该区间的合并方式。

其实这上面很好想，但主要是代码实现。由于是字符串，需要两个函数来将数字与字符串转化。并且还需要一个函数判断循环节，直接暴力即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
ll n, f[105][105], b[105][105];
string a[105][105];
char s[105];
bool check(ll nl, ll nr, ll ml, ll mr){
	if ((nr - nl + 1) % (mr - ml + 1)) return 0;
	for (int i = nl; i <= nr; i++) if (s[i] != s[(i - nl) % (mr - ml + 1) + ml]) return 0;
	return 1;
}
ll ws(ll k){
	ll ans = 0;
	while (k) k /= 10, ans++;
	return ans;
}
string ch(ll k){
	string st;
	while (k) st = char(k % 10 + '0') + st, k /= 10;
	return st;
}
ll dfs(ll l, ll r){
	if (b[l][r]) return f[l][r];
	if (l == r){a[l][l] = s[l];return 1;}
	b[l][r] = 1;
	ll len = r - l + 1;
	for (int i = l; i <= r; i++) a[l][r] += s[i];
	for (int i = l; i < r; i++){
		ll k = dfs(l, i) + dfs(i + 1, r);
		if (k < len) len = k, a[l][r] = a[l][i] + a[i + 1][r];
		if (check(i + 1, r, l, i)){
			ll p = dfs(l, i) + ws((r - i) / (i - l + 1) + 1) + 2;
			if (p < len) len = p, a[l][r] = ch((r - i) / (i - l + 1) + 1) + "(" + a[l][i] + ")";
		}
	}
	return f[l][r] = len;
}
int main(){
	scanf ("%s", s + 1);
	n = strlen(s + 1);
	dfs(1, n);
	cout << a[1][n];
	return 0;
}

```

---

## 作者：eastcloud (赞：0)

## P2400 秘密文件 题解

### 题意简析

如果一个字符串中一个子串连续重复出现，我们可以将其压缩，还可重复缩短，求压缩后的最短长度，有多个解则取字典序你最大的。

### 题目分析

我们可以观察到，压缩过后的字符串都由它的子串压缩过后形成，当整段都被压缩时子串即为本身。

于是我们可以得到这样的一个思路：最短字符串一定由它压缩后的子串拼接构成，或将自己本身压缩后形成。

### 具体实现

我们可以联想到使用区间 dp 实现这么一种转移方式，使用数组 $ dp[l][r] $，表示每一个子串的最小压缩方法，每次可以从 $ dp[l][k] + dp[k+1][r] $，转移而来，还可以把整段压缩，我们要取的就是这些中的最优解。

### 代码

```
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<sstream>
using namespace std;
string dp[101][101];
string tmp="";
string s;
int ti;
int nex[101];
int ans=0;
void calc(int l,int r){//利用kmp的next数组求是否能被压缩
	tmp=s.substr(l,r-l+1);
	int len=tmp.length();
	tmp=' '+tmp;
	memset(nex,0,sizeof(nex));
	for(int i=2,j=0;i<=len;i++){
		while(j>0 && tmp[i]!=tmp[j+1]) j=nex[j];
		if(tmp[i]==tmp[j+1]) j++;
		nex[i]=j;
	}
	if(len%(len-nex[len])==0 && len/(len-nex[len])>1){
		tmp=s.substr(l,len-nex[len]);	
		ti=len/(len-nex[len]);
		ans=1;
	}
	else ans=0;
}
int main(){
	cin>>s;
	int n=s.length();
	for(int i=0;i<=100;i++) for(int j=0;j<=100;j++) dp[i][j]="";
	for(int i=0;i<n;i++)dp[i][i]=s[i];
	for(int len=2;len<=n;len++){
		for(int l=0;l+len-1<n;l++){
			int r=l+len-1;
			int x=l,y=r;
			tmp=s.substr(l,r-l+1);
			calc(x,y);
			if(ans){
				stringstream now; 
				now<<ti;
				string now_str;
				now>>now_str;
				string pre=dp[l][l+(r-l+1)/ti-1];//重复压缩
				if(pre.length()<tmp.length())tmp=pre;
				else if(pre.length()==tmp.length() && pre>tmp)tmp=pre;
				tmp=now_str+'('+tmp+')';
				dp[l][r]=tmp;
			}
			for(int k=l;k<r;k++){
				string x=dp[l][k],y=dp[k+1][r];
				string sum=x+y;
				if(dp[l][r]=="" || dp[l][r].length()>sum.length())dp[l][r]=sum;
				else if(dp[l][r].length()==sum.length() && dp[l][r]<sum) dp[l][r]=sum;
			}//从子串转移
		}
	}
	cout<<dp[0][n-1];
    return 0;
}
```


---

## 作者：splendore (赞：0)

### 思路
首先我们有区间 DP 基本式子：

$$f_{l,r}=\min_{k=l}^{r-1}f_{l,k}+f_{k+1,r}$$

又因为可以多次压缩，所以有：

$$f_{l,r}=\min_{k=1}^{r-l+1}f_{i,i+k-1}+2+ \text{dight}(\frac{r-l+1}{k})$$

其中 $\text{dight}(x)$ 表示 $x$ 的位数。

两个式子放在一起求解，再多开一个数组记录状态转移即可。

代码如下：
```
#include<cstdio>
#include<cstring>
using namespace std;
const int N=105;
char s[N];
int b[N],f[N][N],p[N][N];
void dfs(int l,int r){
	int k=p[l][r];
	if(!k)for(int i=l;i<=r;++i)putchar(s[i]);
	else if(k>0)dfs(l,k),dfs(k+1,r);
	else{
		printf("%d(",(r-l+1)/-k);
		dfs(l,l-k-1);
		putchar(')');
	}
}
int main(){
	for(int i=1;i<=9;++i)b[i]=1;
	for(int i=10;i<=99;++i)b[i]=2;
	b[100]=3;
	scanf("%s",s+1);int n=strlen(s+1);
	memset(f,0x3f,sizeof(f));
	for(int i=1;i<=n;++i)f[i][i]=1;
	for(int len=2;len<=n;++len)
		for(int l=1,r=len;r<=n;++l,++r){
			for(int k=l;k<r;++k)
				if(f[l][r]>f[l][k]+f[k+1][r])
					f[l][r]=f[l][k]+f[k+1][r],p[l][r]=k;
			for(int k=1;k<len;++k){
				if(len%k)continue;
				bool bj=0;
				for(int i=k;l+i<=r;++i)
					if(s[l+i]!=s[l+i%k])
						{bj=1;break;}
				if(bj)continue;
				if(f[l][r]>f[l][l+k-1]+2+b[len/k])
					f[l][r]=f[l][l+k-1]+2+b[len/k],p[l][r]=-k;
			}
		}
	dfs(1,n);
	return 0;
}
```

---


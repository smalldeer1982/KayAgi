# 不同子串个数

## 题目背景

因为 NOI 被虐傻了，蒟蒻的 YJQ 准备来学习一下字符串，于是它碰到了这样一道题：


## 题目描述

给你一个长为 $n$ 的字符串，求不同的子串的个数。

我们定义两个子串不同，当且仅当有这两个子串长度不一样或者长度一样且有任意一位不一样。

子串的定义：原字符串中连续的一段字符组成的字符串。


## 说明/提示

### 提示

请使用64位整数来进行输出。

### 数据规模与约定
- 对于 $30\%$ 的数据，保证 $n\le 1000$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \le 10^5$，字符串中只有小写英文字母。


## 样例 #1

### 输入

```
5
aabaa```

### 输出

```
11```

## 样例 #2

### 输入

```
3
aba```

### 输出

```
5```

# 题解

## 作者：Leap_Frog (赞：35)

### PS.
此题是字符串入门好题。  
**显然**用AC自动机、KMP等提高组算法不可解。  
**显然**用后缀数组、后缀自动机等算法可以轻易解。  
此篇题解讲了SA和SAM的两种做法。  
仍然：码风压行，不喜勿喷。  
~~求赞嘤嘤嘤~~

### Problem.
求一个字符串的**不同**的**子串**有多少个。

## Part 1.
### Solution.
用SA（后缀数组）做这题。  
我们再SA中求出了Height数组，是相邻两个前缀的最长相同前缀。  
那么我们只需要在当前答案中减去这个相同前缀的数量的贡献。  
就能求出不同的子串数量了。  

### Coding.
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[1000005];int n,m,rk[1000005],sa[1000005],tax[1000005],tp[1000005],h[1000005];
//注意毒瘤码风：这里的h就是Height了，不是那个辅助数组H。
inline void srt()//后缀数组的桶排
{
	memset(tax,0,sizeof(tax));
	for(int i=1;i<=n;i++) tax[rk[tp[i]]]++;
	for(int i=1;i<=m;i++) tax[i]+=tax[i-1];
	for(int i=n;i>=1;i--) sa[tax[rk[tp[i]]]--]=tp[i];
}
inline void work()//求后缀数组
{
	for(int i=1;i<=n;i++) rk[i]=s[i],tp[i]=i;
	m=127,srt();
	for(int w=1,p=1,i;p<n;w<<=1,m=p)
	{
		for(p=0,i=n-w+1;i<=n;i++) tp[++p]=i;
		for(i=1;i<=n;i++) if(sa[i]>w) tp[++p]=sa[i]-w;
		srt(),memcpy(tp,rk,sizeof(rk)),rk[sa[1]]=p=1;
		for(i=2;i<=n;i++) rk[sa[i]]=(tp[sa[i]]==tp[sa[i-1]]&&tp[sa[i]+w]==tp[sa[i-1]+w]?p:++p);
	}
	for(int i=1,j=0,k;i<=n;h[rk[i]]=j,i++) for(j=(j?j-1:j),k=sa[rk[i]-1];s[i+j]==s[k+j];j++);
}
inline long long solve() {long long ans=1ll*n*(n+1)/2;for(int i=1;i<=n;i++) ans-=h[rk[i]];return ans;}
//solve就是统计答案。
//这里用了正难则反，总共有n*(n+1)/2个点，减去重复的就是答案了。
int main() {return scanf("%d%s",&n,s+1),work(),printf("%lld\n",solve()),0;}
//简洁的主程序，这次压行有点过分，主程序都压成一行了，我自裁。
```

## Part 2
### Solution.
用SAM（后缀自动机）来做这道题。  
首先建立后缀自动机。  
然后根据后缀自动机的性质我们可以发现：  
在后缀自动机上从根节点开始的每一条路径都是一个子串。  
所以直接在SAM上跑DP就好了，其实就是一遍DFS，因为SAM是一个DAG。  
### Coding.
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{int len,fa,s[26];}a[200005];//SAM结构体
int n,lst=1,cnt=1;char s[100005];long long ans[200005];//ans就是dp数组
inline void ins(int c)
{//经典的后缀自动机的加点过程。
	int p=lst,np=lst=++cnt;a[np].len=a[p].len+1;
	for(;p&&!a[p].s[c];p=a[p].fa) a[p].s[c]=np;
	if(!p) return(void)(a[np].fa=1);
	int q=a[p].s[c];
	if(a[q].len==a[p].len+1) return(void)(a[np].fa=q);
	int nq=++cnt;a[nq]=a[q],a[nq].len=a[p].len+1,a[q].fa=a[np].fa=nq;
	for(;p&&a[p].s[c]==q;p=a[p].fa) a[p].s[c]=nq;
}
inline long long dfs(int x)
{//在SAM上跑dfs
	if(ans[x]) return ans[x];
	for(int i=0;i<26;i++) if(a[x].s[i]) ans[x]+=dfs(a[x].s[i])+1;
	return ans[x];
}
int main()
{
	scanf("%d%s",&n,s+1),memset(ans,0,sizeof(ans));
	for(int i=1;i<=n;i++) ins(s[i]-'a');
	return printf("%lld\n",dfs(1)),0;
}
```

---

## 作者：Rorschachindark (赞：20)

# 不同子串个数
[题目传送门](https://www.luogu.com.cn/problem/P2408)
## 思路
来一篇比较不一样的$\text {SAM}$。看到很多$\text {SAM}$都是用的拓扑序之后$\text {dp}$，实际上，我们可以直接动态维护。

考虑增加一个点之后，我们设$\text {maxlen,minlen}$表示这个点表示的字符串的最长长度和最短长度。可以得到的是，每次加入一个一个点答案就会增加$\text {maxlen-minlen+1}$,又因为$\text {minlen=maxlen(fa)+1}$,$\text {fa}$就是指的这个点的后缀连接。所以，每次就会增加$\text {maxlen-maxlen(fa)}$。

实测这种方法会比$dp$快一倍。
## $\text {Code}$
```cpp
#include <bits/stdc++.h>
using namespace std;

#define Int register int
#define ll long long
#define MAXN 200005

template <typename T> inline void read (T &t){t = 0;char c = getchar();int f = 1;while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}while (c >= '0' && c <= '9'){t = (t << 3) + (t << 1) + c - '0';c = getchar();} t *= f;}
template <typename T,typename ... Args> inline void read (T &t,Args&... args){read (t);read (args...);}
template <typename T> inline void write (T x){if (x < 0){x = -x;putchar ('-');}if (x > 9) write (x / 10);putchar (x % 10 + '0');}

int n;
char s[MAXN];

int lst = 1,node = 1;
int len[MAXN],fa[MAXN],ch[MAXN][26];

ll ans;

void Insert (int c){
	int f = lst,q = ++ node;lst = q;
	len[q] = len[f] + 1;
	while (f && !ch[f][c]) ch[f][c] = q,f = fa[f];
	if (!f) fa[q] = 1;
	else{
		int x = ch[f][c];
		if (len[x] == len[f] + 1) fa[q] = x;
		else{
			int p = ++ node;
			fa[p] = fa[x],len[p] = len[f] + 1;
			memcpy (ch[p],ch[x],sizeof (ch[x]));
			fa[x] = fa[q] = p;
			while (f && ch[f][c] == x) ch[f][c] = p,f = fa[f];
		}
	}
	ans += len[q] - len[fa[q]];
}

signed main(){
	read (n);
	scanf ("%s",s + 1);
	for (Int i = 1;i <= n;++ i) Insert (s[i] - 'a');
	write (ans),putchar ('\n');
	return 0;
}
```

---

## 作者：Oracle (赞：16)

对于一个后缀sa[i]，它产生了n-sa[i]个前缀，减去height[i]个相同的前缀(与前一个比较)，则产生了n-sa[i]-height[i]个子串。累加后即结果。
剩下的都是后缀数组的基本操作......
注意开 long long 不然要炸。
```
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<iostream>
#include<queue>
#define ll long long
using namespace std;
const int MAXN=2e5+10;
int sa[MAXN],rank[MAXN],rsort[MAXN],y[MAXN],wr[MAXN],height[MAXN];
char a[MAXN];
bool cmp(int a,int b,int len)
{
	return wr[a]==wr[b] && wr[a+len]==wr[b+len];
}
void get_SA(int m,int n)
{
	for(int i=1;i<=n;i++) rank[i]=a[i-1];
	for(int i=1;i<=n;i++) rsort[rank[i]]++;
	for(int i=1;i<=m;i++) rsort[i]+=rsort[i-1];
	for(int i=n;i>0;i--) sa[rsort[rank[i]]--]=i;
	int len=1,p=0;
	while(p<n)
	{
		int k=0;
        //y[i]:以第二关键字排名,排名为i的第一关键字的位置
		for(int i=n-len+1;i<=n;i++) y[++k]=i;
		for(int i=1;i<=n;i++) if(sa[i]>len) y[++k]=sa[i]-len;
		for(int i=1;i<=n;i++) wr[i]=rank[y[i]];
        //wr[i]:以第二关键字排序,排名为i的第一关键字的排名
		memset(rsort,0,sizeof(rsort));
		for(int i=1;i<=n;i++) rsort[wr[i]]++;
		for(int i=1;i<=m;i++) rsort[i]+=rsort[i-1];
		for(int i=n;i>0;i--) sa[rsort[wr[i]]--]=y[i];
		for(int i=1;i<=n;i++) wr[i]=rank[i];
		p=1;rank[sa[1]]=1;
		for(int i=2;i<=n;i++)
		{
			if(!cmp(sa[i],sa[i-1],len)) p++;
			rank[sa[i]]=p;
		}
		m=p;len<<=1;
	}
}
//线性求解height数组
void get_height(int n)
{
	int k=0,j;
	for(int i=1;i<=n;i++)
	{
		j=sa[rank[i]-1];
		if(k) k--;
		while(a[j+k-1]==a[i+k-1]) k++;
		height[rank[i]]=k;
	}
}
ll solve(int n)
{
	ll ans=0;
	for(int i=1;i<=n;i++)
		ans+=n+1-sa[i]-height[i];
	return ans;
}
int main()
{
	int len;
	scanf("%d",&len);
	scanf("%s",a);
	get_SA(300,len);
	get_height(len);
	printf("%lld",solve(len));
	return 0;
}
```

---

## 作者：Arghariza (赞：9)

萌新不会SAM，所以考虑后缀数组

令 $ht[i]=lcp(sa[i],sa[i-1])$ （即第 $i$ 名的后缀与它前一名的后缀的最长公共前缀）。

由于 $ht[rk[i]]≥ht[rt[i-1]]-1$ （证明见[OI Wiki](https://oi-wiki.org/string/sa/)）

所以我们可以愉快地暴力 $O(n)$ 求 $ht$ 了

```cpp
// sa,rk同后缀排序模板，s为原串
for (int i = 1, k = 0; i <= n; i++) {
    if (k != 0) k--;
    while (s[i + k] == s[sa[rk[i] - 1] + k]) k++;
    ht[rk[i]] = k;
}
```

考虑所有子串都是某个**后缀的前缀**，将所有后缀排序。考虑对于相同的子串，在其出现的**最大的后缀**中记录贡献。于是对于每一个后缀，**出现在后缀排序中下一个后缀的前缀不会被记录贡献，而没有出现的前缀一定会被记录贡献**。

于是答案就是子串的个数 $\frac{n(n+1)}{2}-\sum\limits_{k=2}^{n}ht[k]$

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
namespace mystd {
	inline int read() {
	    int w = 1, q = 0;
	    char ch = ' ';
	    while (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
	    if (ch == '-') w = -1, ch = getchar();
	    while (ch >= '0' && ch <= '9') q = q * 10 + ch - '0', ch = getchar();
	    return w * q;
	}

	inline void write(int x) {
	    if (x < 0) {
	        x = ~(x - 1);
	        putchar('-');
	    }
	    if (x > 9) write(x / 10);
	    putchar(x % 10 + '0');
	}
}
using namespace mystd;

const int maxn = 1000100;

char s[maxn];
int ans, n, m = 300, p, px[maxn], id[maxn], cnt[maxn];
int ht[maxn], rk[maxn], sa[maxn], ork[maxn << 1];

signed main() {
    n = read();
	scanf("%s", s + 1);
	n = strlen(s + 1);
	for (int i = 1; i <= n; i++) cnt[rk[i] = s[i]]++;
	for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];
	for (int i = n; i >= 1; i--) sa[cnt[rk[i]]--] = i;
	for (int w = 1; p != n; w <<= 1, m = p) {
		p = 0;
		for (int i = n; i >= n - w + 1; i--) id[++p] = i;
		for (int i = 1; i <= n; i++) {
			if (sa[i] > w) id[++p] = sa[i] - w;
		}
		for (int i = 1; i <= m; i++) cnt[i] = 0;
		for (int i = 1; i <= n; i++) cnt[px[i] = rk[id[i]]]++;
		for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];
		for (int i = n; i >= 1; i--) sa[cnt[px[i]]--] = id[i];
		memcpy(ork, rk, sizeof(rk));
		p = 0;
		for (int i = 1; i <= n; i++) {
			rk[sa[i]] = (ork[sa[i]] == ork[sa[i - 1]] && ork[sa[i] + w] == ork[sa[i - 1] + w]) ? p : ++p;
		}
	}// 以上为后缀排序模板
    for (int i = 1, k = 0; i <= n; i++) {
        if (k) k--;
        while (s[i + k] == s[sa[rk[i] - 1] + k]) k++;
        ht[rk[i]] = k;
    }// 以上计算 ht 数组
    for (int i = 2; i <= n; i++) {
        ans += ht[i];
    }
    write(n * (n + 1) / 2 - ans);// 统计答案
	return 0;
}
```

---

## 作者：wasa855 (赞：5)

### 不用后缀数组的方法
### 哈希+LCP

首先思路还是把所有的后缀排序，然后减去每一个LCP的值   
但后缀排序的结果可以用一种比较暴力的方法，用二分哈希找出当前比较的两个后缀的LCP，然后直接比较LCP的后一个字母的大小，时间复杂度$O(n\log^2n )$。（还是比后缀排序慢一点）  
然后的方法就是$\frac{n(n+1)}{2}-\sum(LCP)$   
证明：所有后缀的前缀，囊括了所有的子串，去除重复的即可。而排出后缀排序结果相邻的LCP，即重复部分就可得到答案。复杂度   $O(n\log n )$。
   
总的复杂度$O(n\log^2n )$  虽然比正统的后缀排序多一个$\log$，但本题的数据范围可以过。
    
Tip：在本题的数据中，取哈希的$Base=131,Mod=1e9+7$会被卡掉。   
   
代码不是很长但挺好写（cmp和求LCP几乎一样）。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int read()
{
	char ch=getchar(); int nega=1; while(!isdigit(ch)) {if(ch=='-') nega=-1; ch=getchar();}
	int ans=0; while(isdigit(ch)) {ans=ans*10+ch-48;ch=getchar();}
	if(nega==-1) return -ans; return ans;
}
#define N 100005
#define Mod 1000000007
#define Base 233
int n;
int s[N];
char a[N];
int t[N];
int mul[N];
int gethash(int b,int l)
{
	int dat=s[b+l]-s[b-1]*mul[l+2]%Mod;
	dat=(dat+Mod)%Mod;
	return dat;
}
bool cmp(int x,int y)
{
	if(x>y) return !cmp(y,x);
	if(x==y) return false;
	if(a[x]!=a[y]) return a[x]<a[y];
	int l=0,r=n-max(x,y)+1;
	int ans=0;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		int hx=gethash(x,mid);
		int hy=gethash(y,mid);
		if(hx==hy)
		{
			l=mid+1,ans=mid;
		}
		else r=mid-1;
	}
	if(ans==n-max(x,y)+1) return true;
	return a[x+ans+1]<a[y+ans+1];
}
int LCP(int x,int y)
{
	if(x>y) return LCP(y,x);
	if(a[x]!=a[y]) return 0;
	int l=0,r=n-max(x,y);
	int ans=0;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		int hx=gethash(x,mid);
		int hy=gethash(y,mid);
		if(hx==hy)
		{
			l=mid+1,ans=mid;
		}
		else r=mid-1;
	}
	return ans+1;
}
signed main()
{
#ifndef ONLINE_JUDGE
	freopen("in.txt","r",stdin);
#endif
	n=read();
	scanf("%s",a+1);
	mul[1]=1;
	for(int i=2;i<=n+3;i++)
	{
		mul[i]=mul[i-1]*Base%Mod;
	}
	for(int i=1;i<=n;i++)
	{
		s[i]=(s[i-1]*Base+(a[i]-'A'+1))%Mod;
	}
	for(int i=1;i<=n;i++) t[i]=i;
	sort(t+1,t+n+1,cmp);
	int ans=(n+1)*n/2;
	for(int i=2;i<=n;i++)
	{
		ans-=LCP(t[i-1],t[i]);
	}
	cout<<ans<<endl;
	return 0;
}


```

---

## 作者：珅肐 (赞：5)

统计一个串不同的子串个数：

我们可以利用$LCP$来做，

根据定义，后缀$suf(i)$和它的前一名后缀$suf(k)$最长公共前缀是$Height[i]$，

这两个串的前缀，就是原字符串的子串，

那么这两个串产生的相同的子串，数目就是$Height[rak[i]]$。

所有后缀产生的前缀，相同的个数是$\sum ^n_1 Height[rak[i]]$

一个长度为$n$的字符串，产生的子串个数是$\frac {n(n+1)}2$个，

最后答案为总个数减去相同的个数，即:
$$\frac {n(n+1)}2-\sum ^n_1 Height[rak[i]]$$


### 完整代码奉上：
```cpp
#include<iostream>
#include<cstdio>
#include<ctype.h>
#include<cstring>
#include<queue>
using namespace std;
inline int read(){
	int x=0,f=0;char ch=getchar();
	while(!isdigit(ch))f|=ch=='-',ch=getchar();
	while(isdigit(ch))x=x*10+(ch^48),ch=getchar();
	return f?-x:x;
}
char s[100007];
int N,M;
int rak[100007],sa[100007],tp[100007],tax[100007];
inline void bucket(){
	for(int i=0;i<=M;++i)tax[i]=0;
	for(int i=1;i<=N;++i)tax[rak[i]]++;
	for(int i=1;i<=M;++i)tax[i]+=tax[i-1];
	for(int i=N;i>=1;--i)sa[tax[rak[tp[i]]]--]=tp[i];
}
inline void suffix_sort(){//SA模板
	M=128;
	for(int i=1;i<=N;++i)rak[i]=s[i]-'a'+1,tp[i]=i;
	bucket();
	for(int w=1,p=0;p<N;M=p,w<<=1){
		p=0;
		for(int i=1;i<=w;++i)tp[++p]=N-w+i;
		for(int i=1;i<=N;++i)if(sa[i]>w)tp[++p]=sa[i]-w;
		bucket();
		swap(tp,rak);
		rak[sa[1]]=p=1;
		for(int i=2;i<=N;++i)
			rak[sa[i]]=(tp[sa[i-1]]==tp[sa[i]] && tp[sa[i-1]+w]==tp[sa[i]+w])?p:++p;
	}
}
int height[100007];
inline void Get_Height(){//求Height数组
	int k=0;
	for(int i=1;i<=N;++i){
		if(k)k--;
		int j=sa[rak[i]-1];
		while(s[i+k]==s[j+k])++k;
		height[rak[i]]=k;
	}
}
int main(){
	N=read();scanf("%s",s+1);
	suffix_sort();
	Get_Height();
	long long ans=1ll*N*(N+1)/2;//总子串个数
	for(int i=1;i<=N;++i)ans-=height[rak[i]];//减去相同的个数
	printf("%lld\n",ans);
	return 0;//好习惯..
}
```


---

## 作者：Great_Influence (赞：5)

字符串裸题，明显可以用SAM做(当然SA也是可以的)，可以用来练习SAM。

方法是建完SAM后，直接在上面跑dp，求出路径数量，便可以求出子串数，因为SAM的每条路径都对应着不重复的子串。dp方程也好写:


$dp[u]=1+\sum_{(u,v)\in DAWG}dp[v]$


就是求出树上路径数的方法。


代码：


```cpp
    #include<bits/stdc++.h>
    #include<cctype>
    #define For(i,a,b) for(i=(a),i##end=(b);i<=i##end;++i)
    #define Forward(i,a,b) for(i=(a),i##end=(b);i>=i##end;--i)
    #define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
    #define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
    using namespace std;
    template<typename T>inline void read(T &x){
        T s=0,f=1;char k=getchar();
        while(!isdigit(k)&&k^'-')k=getchar();
        if(!isdigit(k)){f=-1;k=getchar();}
        while(isdigit(k)){s=s*10+(k^48);k=getchar();}
        x=s*f;
    }
    void file(void){
        #ifndef ONLINE_JUDGE
        freopen("DAWG.in","r",stdin);
        freopen("DAWG.out","w",stdout);
        #endif
    }
    const int MAXN=1e6+7;
    static struct DAWG
    {
        int len,link,nxt[30];
        long long cnt;
    }p[MAXN<<1];
    char s[MAXN];
    static int e,n;
    #define Chkmax(a,b) a=a>b?a:b
    inline void extend(int c)
    {
        static int last=0,j,cur,q,clone;
        p[cur=++e].len=p[last].len+1;
        for(j=last;~j&&!p[j].nxt[c];j=p[j].link)p[j].nxt[c]=cur;
        if(j==-1)p[cur].link=0;
        else
        {
            q=p[j].nxt[c];
            if(p[j].len+1==p[q].len)p[cur].link=q;
            else
            {
                clone=++e;
                p[clone].len=p[j].len+1;
                memcpy(p[clone].nxt,p[q].nxt,sizeof p[q].nxt);
                p[clone].link=p[q].link;
                for(;~j&&p[j].nxt[c]==q;j=p[j].link)
                    p[j].nxt[c]=clone;
                p[q].link=p[cur].link=clone;
            }
        }
        last=cur;
    }
    inline bool cmp(int a,int b){return p[a].len>p[b].len;}
    int b[MAXN<<1];
    int main()
    {
        file();
        read(n);
        p[0].link=-1;
        scanf("%s",s);
        Rep(i,0,n-1)extend(s[i]-'a');
        Rep(i,0,e)b[i]=i;
        sort(b,b+e+1,cmp);
        Rep(i,0,e)Rep(j,0,25)
        if(p[b[i]].nxt[j])p[b[i]].cnt+=p[p[b[i]].nxt[j]].cnt+1;
        printf("%lld\n",p[0].cnt);
        return 0;
    }

```

---

## 作者：fmj_123 (赞：4)

一道很好的后缀数组题。

考虑子串一定是**一个后缀的前缀**，所以我们可以求出用后缀数组求出$LCP$（最长公共前缀），再求出每个后缀对答案的贡献。

即，长度减去出现过的前缀（一定是与排名前一个的后缀的$LCP$，因为对于一个后缀$i$,与其最相似的是排名与其相邻的后缀）。因此，以第$i$个字符（从0开始数）开头的后缀的贡献值为$n-i-height_{rank_i}$。

上代码
```
//这里字符串是从0开始的
#include<bits/stdc++.h>
using namespace std;
char st[100100];int rank[100100],nrank[100100],sa[100100],p[100100],height[100100],sum[100100],n;
long long ans;
bool same(int x,int y,int l)
{
	if (rank[x]!=rank[y]) return false;
	if ((x+l>=n&&y+l<n) || (x+l<n&&y+l>=n)) return false;
	if (x+l>=n&&y+l>=n) return true;
	return rank[x+l]==rank[y+l];
}//判重
void calc_height()
{
//根据性质，计算height数组（当前字符串与排名是其上一个的字符串的LCP）
	int j=0;
	for (int i=0;i<n;i++)
	{
		if (j) j--;
		if (!rank[i]) 
		{
			ans+=n-sa[rank[i]];j=0;//与前面没有LCP，即整串都可以作为答案
		    continue;
	    }
		for (int k=sa[rank[i]]+j,l=sa[rank[i]-1]+j;;)
		{
			if (st[k]==st[l]) j++,k++,l++;else break;
		}
		height[rank[i]]=j;
		ans+=n-sa[rank[i]]-j;//计算答案，ans要用long long，否则会挂。
	}
}
int main()
{
	scanf("%d",&n);
	scanf("%s",&st);
	for (int i=0;i<n;i++)
		sum[rank[i]=int(st[i])]++;
	for (int i=1;i<=128;i++)
		sum[i]+=sum[i-1];
	for (int i=n-1;i>=0;i--)
	    sa[--sum[int(st[i])]]=i;
	int maxg=max(128,n);
	for (int l=1;l<n;l<<=1)
	{
		int k=-1;
		for (int i=n-l;i<n;i++) p[++k]=i;
		for (int i=0;i<n;i++) 
		  if (sa[i]-l>=0) p[++k]=sa[i]-l;
		for (int i=0;i<=maxg;i++)
		  sum[i]=0;
		for (int i=0;i<n;i++)
		  sum[rank[i]]++;
		for (int i=1;i<=maxg;i++) 
		  sum[i]+=sum[i-1];
		for (int i=n-1;i>=0;i--)
			sa[--sum[rank[p[i]]]]=p[i];//基排求新排名
		nrank[sa[0]]=0;int ns=0;
		for (int i=1;i<n;i++)
		{
			if (same(sa[i],sa[i-1],l)) nrank[sa[i]]=ns;else nrank[sa[i]]=++ns;
		}
		for (int i=0;i<n;i++)
	    {
	    	rank[i]=nrank[i];
	    	nrank[i]=0;
		}
		if (ns==n-1) break;
	}
	calc_height();
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Refined_heart (赞：2)

后缀树题解。

$\text{Solution:}$

我们将所有字符加进去，顺便统计长度。

当新建节点的时候让长度加$1$即可。

注意，这里我们要每次插入一个字符就加一下$Ans.$由于是压缩的边，所以统计的时候，如果本次没有产生新的叶子节点，但实际上是存在这些新的后缀的，只是隐式地出现在树上。为了方便维护，我们直接累计前缀即可。当然，都插入完将它转化为显式后$dfs$也可以。但是对于多组数据这样就不可取了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=2e5+10;
const int inf=(1<<30);
int n;
typedef long long ll;
ll A;
struct SuffixTree{
	int link[MAXN],start[MAXN],len[MAXN],s[MAXN];
	map<int,int>ch[MAXN];
	int Ans,n,now,rem,tail;
	SuffixTree(){n=rem=0;tail=now=1;len[0]=inf;}
	inline int build(int x,int y){
		link[++tail]=1;
		start[tail]=x;len[tail]=y;
		return tail;
	}
	void Extend(int x){
		s[++n]=x;++rem;
		for(int last=1;rem;){
			while(rem>len[ch[now][s[n-rem+1]]])
				rem-=len[now=ch[now][s[n-rem+1]]];
			int &v=ch[now][s[n-rem+1]];
			int c=s[start[v]+rem-1];
			if(!v||x==c){
				link[last]=now;
				last=now;
				if(!v)v=build(n,inf),Ans++;
				else break;
			}
			else{
				int u=build(start[v],rem-1);
				ch[u][c]=v;ch[u][x]=build(n,inf),Ans++;
				start[v]+=rem-1;len[v]-=rem-1;
				link[last]=v=u;last=u;
			}
			if(now==1)--rem;
			else now=link[now];
		}
	}
}S;
string x;
int main(){
	scanf("%d",&n);
	cin>>x;
	for(int i=0;i<x.size();++i)S.Extend(x[i]-'a'),A+=S.Ans;
	S.Extend(26);
	printf("%lld\n",A);
	return 0;
}
```


---

## 作者：Jμdge (赞：2)

sam 板子题？~~可能 coding 时间还没写题解的时间长？~~

# noteskey

考虑直接对串 s 建个 sam ~~然后跑一跑 parent 树~~

对，我一开始就是这么智障还排个序跑，仔细看看这里直接每个节点加贡献就好了啊！



争取 1 A


# code

```
//by Judge
#include<cstdio>
#include<cstring>
#include<iostream>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(Rg int i=(a),I=(b)-1;i>I;--i)
using namespace std;
const int M=2e5+3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline void reads(string& s){ char c=getchar();
	for(;!isalpha(c);c=getchar()); s=" ";
	for(;isalpha(c);c=getchar()) s+=c;
} int n; long long ans; string s;
struct SAM{ int cnt,las; SAM(){cnt=las=1;}
	int to[M][26]; arr c,sa,fa,len;
	inline void insert(int c){
		int p=las,np=las=++cnt; len[np]=len[p]+1;
		for(;p&&!to[p][c];p=fa[p]) to[p][c]=np;
		if(!p) return fa[np]=1,void(); int q=to[p][c];
		if(len[q]==len[p]+1) return fa[np]=q,void();
		int nq=++cnt; fa[nq]=fa[q],fa[np]=fa[q]=nq;
		len[nq]=len[p]+1,memcpy(to[nq],to[q],sizeof to[q]);
		for(;p&&to[p][c]==q;p=fa[p]) to[p][c]=nq;
	}
	inline void calc(){ fp(i,1,cnt) ++c[len[i]];  //这里其实直接跑就行了，用不着排序...（懒得复制粘贴了将就着看吧）
		fp(i,1,cnt) c[i]+=c[i-1]; fp(i,1,cnt) sa[c[len[i]]--]=i;
		fd(i,cnt,1){ int p=sa[i]; ans+=len[p]-len[fa[p]]; }
	}
}p;
int main(){ scanf("%d",&n),reads(s);
	fp(i,1,n) p.insert(s[i]-'a'); p.calc();
	return !printf("%lld\n",ans);
}
```


---

## 作者：glorious_dream (赞：1)

一道很好的后缀数组和后缀自动机的练习题。本题解分成两个部分，分别讲解用后缀数组做和用后缀自动机做。

## $1$.后缀数组
我们知道，后缀数组中的 $height$ 数组表示相邻两个前缀的最长相同前缀。一个长度为 $n$ 的字符串，有 $\frac{n \times (n-1)}{2}$ 个子串。那么我们只需要把 $height$ 数组求出来，在最后的答案中减去相同前缀数量的贡献，得到的答案就是不同字串的个数。

代码中是对于每次操作拆开求，实际上跟上面那个式子最后的答案相同。

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <vector>
#include <queue>
#define re register
#define int long long
#define drep(a,b,c) for(re int a(b) ; a>=(c) ; --a)
#define rep(a,b,c) 	for(re int a(b) ; a<=(c) ; ++a)
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch == '-') f=-1 ; ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
inline void print(int x){
	if(x < 0) putchar('-'),x = -x;
	if(x >= 10) print(x / 10);
	putchar(x % 10 + '0');
}
const int M = 1e6+10;
int sa[M],rk[M],height[M],c[M],t[M],y[M];
int n,m;
char s[M];
inline void get_sa(){
	rep(i,1,n) c[t[i] = s[i]]++;
	rep(i,1,m) c[i] += c[i-1];
	drep(i,n,1) sa[c[t[i]]--] = i;
	for(re int k(1) ; k<=n ; k<=1){
		memset(c,0,sizeof(c));
		rep(i,1,n) y[i] = sa[i];
		rep(i,1,n) c[t[y[i]+k]]++;
		rep(i,1,m) c[i] += c[i-1];
		drep(i,n,1) sa[c[t[y[i]+k]]--] = y[i];
		memset(c,0,sizeof(c));
		rep(i,1,n) y[i] = sa[i];
		rep(i,1,n) c[t[y[i]]]++;
		rep(i,1,m) c[i] += c[i-1];
		drep(i,n,1) sa[c[t[y[i]]]--] = y[i];
		rep(i,1,n) y[i] = t[i];
		m = 0;
		rep(i,1,n){
			if(y[sa[i]] == y[sa[i-1]] && y[sa[i]+k] == y[sa[i-1]+k]) t[sa[i]] = m;
			else t[sa[i]] = ++m;
		}
		if(m == n) break;
	}
}
inline void get_height(){
	rep(i,1,n) rk[sa[i]] = i;
	int k = 0;
	rep(i,1,n){
		if(rk[i] == 1) continue;
		if(k) k--;
		int j = sa[rk[i]-1];
		while(i+k <= n && j+k <= n && s[i+k] == s[j+k]) k++;
		height[rk[i]] = k;
	}
}
signed main(){
	n = read();
	scanf("%s",s+1);
	m = 255;
	get_sa();
	get_height();
	int ans = 0;
	rep(i,1,n) ans += n + 1 - sa[i] - height[i];
	printf("%lld\n",ans);
	return 0;
}
```
## $2$.后缀自动机
首先，根据 $SAM$ 的性质，本身就是一个有向无环图，在后缀自动机上的每一条路径都是一个子串。那么我们可以在这个有向无环图中跑一遍拓扑DP，注意这里建返图，最后输出 $f[1]$ 的答案 $-1$，这里 $-1$ 是因为减去空串，或者直接在一开始那个点的值是 $0$ 也行。

这里的式子为 $f[u] = \sum_{(u,v)}({f[v]+1})$。我们记录反图中每一个点的度数，先把度数为 $0$ 的点入队，跑拓扑DP即可。最后输出答案 $f[1]$。

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <vector>
#include <queue>
#define re register
#define int long long
#define drep(a,b,c) for(re int a(b) ; a>=(c) ; --a)
#define rep(a,b,c) 	for(re int a(b) ; a<=(c) ; ++a)
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch == '-') f=-1 ; ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
inline void print(int x){
	if(x < 0) putchar('-'),x = -x;
	if(x >= 10) print(x / 10);
	putchar(x % 10 + '0');
}
const int M = 1e6+10;
int n,tot=1,np=1,cnt,ans;
char s[M];
int len[M],ch[M][26],fa[M],head[M],f[M],d[M];
inline void sam_extend(int c){
	int p = np; np = ++tot;
	len[np] = len[p] + 1;
	for( ; p && !ch[p][c] ; p = fa[p]) ch[p][c] = np;
	if(p == 0) fa[np] = 1;
	else{
		int q = ch[p][c];
		if(len[q] == len[p]+1) fa[np] = q;
		else{
			int nq = ++tot;
			fa[nq] = fa[q]; fa[q] = nq; fa[np] = nq;
			len[nq] = len[p] + 1;
			for( ; p && ch[p][c] == q ; p = fa[p]) ch[p][c] = nq;
			memcpy(ch[nq],ch[q],sizeof(ch[nq]));
		}
	}
}
struct edge{
	int to,nxt;
}e[M];
inline void add(int u,int v){
	e[++cnt].to = v;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}
inline void dp(){
	queue<int> q;
	rep(i,1,tot) if(!d[i]) q.push(i);
	while(!q.empty()){
		int u = q.front();
		q.pop();
		for(re int i(head[u]) ; i ; i=e[i].nxt){
			int v = e[i].to;
			f[v] += f[u] + 1;
			d[v]--;
			if(!d[v]) q.push(v);
		}
	}
	printf("%lld\n",f[1]);
}
signed main(){
	n = read();
	scanf("%s",s+1);
	rep(i,1,n) sam_extend(s[i]-'a');
	rep(i,1,tot) rep(j,0,25){
		if(ch[i][j]){
			d[i]++;
			add(ch[i][j],i);
		}
	}
	dp();
	return 0;
}
```


---

## 作者：zyp123456 (赞：0)

### 零、前置芝士
[后缀数组](https://www.luogu.com.cn/blog/blackfrog/sa-algorithm)（**推荐**）

或者 

[更快的后缀数组](https://www.luogu.com.cn/blog/ShadowassIIXVIIIIV/on-hou-zhui-shuo-zu-sa-is-suan-fa) （仅供参考）
### 一、题意
+ 求一个字符串不同子串的个数
### 二、分析
+ 学习后缀数组后，我们可以把字符串往后缀上套
+ 不难知，对于从 $sa[i]$ 开始的后缀字符串 $suf(sa[i])$，和从 $sa[i-1]$ 开始的 $suf(sa[i-1])$，有 $LCP(i,i-1)$ 即 $Height[i]$ 个子串是相同的，考虑到所有后缀，答案就是

$$ Ans=n\times(n+1)/2-\sum_{i=1}^{n}Height[i] $$

### 三、代码

```cpp
#include <bits/stdc++.H>
#define int long long
using namespace std;
typedef long long ll;
template <typename T>
inline void rd(T& x) {
    x = 0;
    T f = 1;
    char s = getchar();
    while (!isdigit(s)) f = (s == '-') ? -1 : 1, s = getchar();
    while (isdigit(s)) x = (x << 1) + (x << 3) + s - '0', s = getchar();
    x *= f;
}
const int M = 100010;
int n, m, sa[M], x[M], y[M], H[M], rk[M], b[M];//H 就是 Height 数组 
char s[M];
inline void Qsort() {
    for (int i = 1; i <= m; i++) b[i] = 0;
    for (int i = 1; i <= n; i++) b[x[i]]++;
    for (int i = 1; i <= m; i++) b[i] += b[i - 1];
    for (int i = n; i >= 1; i--) sa[b[x[y[i]]]--] = y[i];
}//基数排序 
inline void SA() {
    for (int i = 1; i <= n; i++) y[i] = i, x[i] = s[i];
    m = 4000;
    Qsort();
    for (int k = 1; k <= n; k <<= 1) {
    	int num=0;
        for (int i = n - k + 1; i <= n; i++) y[++num] = i;
        for (int i = 1; i <= n; i++)
            if (sa[i] > k)y[++num] = sa[i] - k;
        Qsort();
        swap(x, y);
        x[sa[1]] = num=1;
        for (int i = 2; i <= n; i++)
            x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i - 1] + k]) ? num : ++num;
        if (num == n)return;
        m=num;
    }
}//SA主程序 
void geth() {
    int k = 0;
    for (int i = 1; i <= n; i++) rk[sa[i]] = i;
    for (int i = 1; i <= n; i++) {
        if (k)
            k--;
        int j = sa[rk[i] - 1];
        while (s[i + k] == s[j + k]) k++;
        H[rk[i]] = k;
    }
}//求H数组 
signed main() {
	cin>>n;
    scanf("%s", s + 1);
    SA();
    geth();
    ll ans=n*(n+1)/2;
    for(int i=1;i<=n;i++)ans-=H[rk[i]];
    cout<<ans<<endl;
    return 0;
}//QwQ 撒花 
```


---

## 作者：ListenSnow (赞：0)

## 题意

给定一个长度为 $n$ 的字符串，求该字符串含有的本质不同的子串数量。

#### 数据范围

$1 \leq n \leq 10^5$。字符串中只有小写英文字母。

## 思路

考虑后缀数组求解。

注意到所有后缀的前缀集合就是的子串集合。考虑先将所有的后缀排序。对于第一个后缀，不同的前缀就是它本身的长度，对于第二个后缀，不同的前缀数量就是它本身的长度减去它和第一个后缀的最长公共子串。

对于后面的所有后缀，根据 $lcp(i,j)=\min(lcp(i,k),(k,j))(i \leq k \leq j)$，$\forall j<i-1$，必然有 $lcp(i,i-1)>lcp(i,j)$。意思是 $i$ 和前面所有后缀的最长公共前缀就是和前一个后缀的最长公共前缀。

记 $len[i]$ 表示排序后第 $i$ 个后缀的长度。那么总的不同子串数就是 $\sum len[i]-height[i]$。

最后，答案别忘了开 **long long**。

## code：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=1e5+10;
int height[N],sa[N],rk[N],x[N],y[N],c[N],n,m; char s[N];
void get_sa()
{
	memset(c,0,sizeof(c));
	for(int i=1;i<=n;i++) c[x[i]=s[i]]++;
	for(int i=2;i<=m;i++) c[i]+=c[i-1];
	for(int i=n;i>=1;i--) sa[c[x[i]]--]=i;
	for(int k=1;k<=n;k<<=1)
	{
		int num=0;
		for(int i=n-k+1;i<=n;i++) y[++num]=i;
		for(int i=1;i<=n;i++) if(sa[i]>k) y[++num]=sa[i]-k;
		for(int i=1;i<=m;i++) c[i]=0;
		for(int i=1;i<=n;i++) c[x[i]]++;
		for(int i=2;i<=m;i++) c[i]+=c[i-1];
		for(int i=n;i>=1;i--) sa[c[x[y[i]]]--]=y[i],y[i]=0;
		swap(x,y),num=1,x[sa[1]]=1;
		for(int i=2;i<=n;i++) x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&&y[sa[i]+k]==y[sa[i-1]+k])?num:++num;
		if(n==num) break;m=num;
	}
}
void get_height()
{
	memset(height,0,sizeof(height));
	for(int i=1;i<=n;i++) rk[sa[i]]=i;
	for(int i=1,k=0;i<=n;i++)
	{
		if(rk[i]==1) continue;
		if(k) k--;
		int j=sa[rk[i]-1];
		while(i+k<=n&&j+k<=n&&s[i+k]==s[j+k]) k++;
		height[rk[i]]=k;
	}
}
long long ans;
int main()
{
	int T;scanf("%d",&T);
	while(T--)
	{
		scanf("%s",s+1);m=122;n=strlen(s+1);
		get_sa();get_height();ans=0;
		for(int i=1;i<=n;i++) ans+=n-sa[i]+1-height[i];
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：crescentic (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P2408)

**Description**

给定一个字符串，求它所有不重复的子串数量。

**Solution**


首先，要了解一点：

> 所有后缀的前缀的集合就是该字符串的子串集合。

对于一个子串来说，它的前缀个数就是它的**长度**，所以如果不考虑重复的话，该字符串的子串数量和就是 $\frac{n(n + 1)}{2}$。

接下来考虑如何排除重复的情况。

那么可以发现，对于两个子串来说，它们重复的前缀数就是其**最长公共前缀**的长度。那不就是 $SA$ 里面的 $height$ 数组了吗？！

所以最后答案直接减去$\sum_{i=1}^n height_i$。

因此，

$$

Ans = \frac{n(n + 1)}{2} - \sum_{i=1}^n height_i

$$

祭上 $SA$ 大法就好啦~ 

其他的都是模板，具体是看看代码吧~

**Code**

记得开 $long$ $long$ ， 答案相乘时记得乘 $1LL$。

不要问我是怎么知道的！问就是经验！ 


```cpp

#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
#define ll long long
#define il inline
const int N = 1e6 + 5;
int n,m,sa[N],rk[N],height[N],cnt[N],x[N],y[N];
ll ans;
char s[N];
il void getsa() {
	int i,k,j,num;
	for(i = 1; i <= n; i ++) cnt[x[i] = s[i]] ++;
	for(i = 2; i <= m; i ++) cnt[i] += cnt[i - 1];
	for(i = n; i; i --) sa[cnt[x[i]]--] = i;
	for(k = 1; k <= n; k <<= 1) {
		num = 0;
		for(i = n - k + 1; i <= n; i ++) y[++num] = i;
		for(i = 1; i <= n; i ++) {
			if(sa[i] > k) y[++num] = sa[i] - k;
		}
		for(i = 1; i <= m; i ++) cnt[i] = 0;
		for(i = 1; i <= n; i ++) cnt[x[i]] ++;
		for(i = 2; i <= m; i ++) cnt[i] += cnt[i - 1];
		for(i = n; i; i --) sa[cnt[x[y[i]]]--] = y[i], y[i] = 0;
		swap(x,y);
		x[sa[1]] = num = 1;
		for(i = 2; i <= n; i ++) {
			x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i - 1] + k]) ? num : ++num;
		}
		if(num == n) break;
		m = num;
	}
} 
il void get_height() {
	int i,j,k;
	for(i = 1; i <= n; i ++) rk[sa[i]] = i;
	for(i = 1, k = 0; i <= n; i ++) {
		if(rk[i] == 1) continue;
		if(k) k--;
		j = sa[rk[i] - 1];
		while(i + k <= n && j + k <= n && s[i + k] == s[j + k]) k ++;
		height[rk[i]] = k;
	}
}
int main() {
	scanf("%d",&n);
	scanf("%s",s + 1);
	m = 128;
	getsa();
	get_height();
	ans = 1ll * (n + 1) * n / 2;
	for(int i = 1; i <= n; i ++) ans -= height[i];
	printf("%lld\n",ans);
	return 0;
}

```

---

## 作者：MCAdam (赞：0)

[前置芝士](https://www.luogu.com.cn/blog/MCAdam/sa-xue-xi-bi-ji)

数组$SA$和$rank$本身并没有什么用，~~除了过模板题~~，真正有用的是它们推导出来的$height$数组

定义$height[i]$为$suf(SA[i-1])$和$suf(SA[i])$的最长公共前缀

例如对于$suf(SA[i-1])=aaab cd,suf(SA[i])=aaad$，那么$height[i]=3$

现在要计算$height$数组

首先想到$O(n^2)$的做法，枚举$i$然后$O(n)$从头$suf(SA[i-1])$和$suf(SA[i])$，考虑如何优化

定义$h[i]=height[rank[i]]$

因为$SA[rank[i]]=i$，所以$h[i]$表示$suf(i)$和它前一名的后缀的最长公共前缀。

$h$数组有性质：$h[i]\geq h[i-1]-1$

$\quad$证明：

$\quad$首先要求$h[i-1]>1$，不然显然成立

$\quad$设$suf(k)$为$suf(i-1)$前一名的后缀，那么它们的最长公共前缀就是$h[i-1]$。那么$suf(k+1)$仍然排在$suf(i)$的前面，它们的最长公共前缀就是$h[i-1]-1$（把$suf(k)$和$suf(i-1)$的第一个字母砍掉）。

$\quad$因为$suf(k+1)$一定是排在$suf(i)$前面，不一定就是上一名，而越靠近$suf(i)$的，它们的最长公共前缀就越可能大。所以$h[i]$至少为$h[i-1]-1$

回顾$height$和$h$的定义：

$height[i]$为$suf(SA[i-1])$和$suf(SA[i])$的最长公共前缀

$h[i]$表示$suf(i)$和它前一名的后缀的最长公共前缀

由定义：$height[rank[i]]=h[i]$，且有性质$h[i]\geq h[i-1]+1$，在计算$h[i]$的过程中就可以从上次的位置开始，优化到$O(n)$

上代码：

```cpp
inline void get_height()
{
	int pre=1;
	for(int i=1;i<=len;i++)
	{
		if(pre) pre--;
		while(s[i+pre]==s[SA[rk[i]-1]+pre]) pre++; //当前字符串为suf(i)，上一名字符串为suf(SA[rank[i]-1])
		height[rk[i]]=pre;
	}
}
```

回到这道题：

对于一个后缀$SA[i]$,它的长度为$len-SA[i]+1$，以它为开头的子串就有$len-SA[i]+1$个。那么

$sum=\sum\limits_{i=1}^{n}len-SA[i]+1$就是所有的子串

现在要做的就是减掉重复的，而重复数量就是

$\sum\limits_{i=1}^{n}height[i]$

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#define ll long long
using namespace std;
const int N=1e5+10,M=150;
int len,size=128;
char s[N];
int SA[N],rk[N],tmp[N],cnt[M],height[N];
inline void binsort()
{
	for(int i=0;i<=size;i++) cnt[i]=0;
	for(int i=1;i<=len;i++) cnt[rk[i]]++;
	for(int i=1;i<=size;i++) cnt[i]+=cnt[i-1];
	for(int i=len;i>=1;i--) SA[cnt[rk[tmp[i]]]--]=tmp[i];
}
inline void get_SA()
{
	for(int i=1;i<=len;i++)
		rk[i]=s[i]-'a'+1,tmp[i]=i;
	binsort();
	for(int l=1;l<=len;l<<=1)
	{
		int p=0;
		for(int i=len-l+1;i<=len;i++)
			tmp[++p]=i;
		for(int i=1;i<=len;i++)
			if(SA[i]>l) tmp[++p]=SA[i]-l;
		binsort(); swap(rk,tmp);
		rk[SA[1]]=p=1;
		for(int i=2;i<=len;i++)
			rk[SA[i]]=(tmp[SA[i]]==tmp[SA[i-1]]&&tmp[SA[i]+l]==tmp[SA[i-1]+l])?p:++p;
		if(p==len) break;
		size=p;
	}
}
inline void get_height()
{
	int pre=1;
	for(int i=1;i<=len;i++)
	{
		if(pre) pre--;
		while(s[i+pre]==s[SA[rk[i]-1]+pre]) pre++; //当前字符串为suf(i)，上一名字符串为suf(SA[rank[i]-1])
		height[rk[i]]=pre;
	}
}
int main()
{
	ll ans=0;
	scanf("%d",&len);
	scanf("%s",s+1);
	get_SA(),get_height();
	for(int i=1;i<=len;i++)
		ans+=(len-SA[i]+1)-height[i];
	printf("%lld\n",ans);
	return 0;
}
```



---

## 作者：chihik (赞：0)


这道题用后缀自动机可以暴力解决。

建好后缀自动机后 , 因为起点到后缀自动机上的每一个点都是一个本质不同的子串 ， 我们就可以在 $\text{DAWG}$ 上 $dp$ 。 $dp[u]$表示包含转移$u$的子串数量，很容易列出转移式：

$$
dp[u]=\sum_{v \in son[u]} dp[v]
$$

注意虽然是一个$\text{DAG}$，但是我们并不需要把图建出，只需要用拓扑序$dp$就可以了。



### 注意，此题不一定是小写字母！！！

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;

const int MAXN = 90000 , MAXK = 26;
struct Suffix_Automaton {
	int Root , Size , Last , Maxlen[ 2 * MAXN + 5 ]; 
	int Trans[ 2 * MAXN + 5 ][ MAXK + 5 ] , Link[ 2 * MAXN + 5 ];
	long long dp[ 2 * MAXN + 5 ];
	
	Suffix_Automaton( ) { Root = Size = Last = 1; }
	
	void Copy( int u , int v ) {
		for( int i = 1 ; i <= MAXK ; i ++ )
			Trans[ u ][ i ] = Trans[ v ][ i ];
	}
	void Extend( int chr ) {
		int Newnode = ++ Size , u = Last;
		Maxlen[ Newnode ] = Maxlen[ u ] + 1;
		
		for( ; u && !Trans[ u ][ chr ] ; u = Link[ u ] )
			Trans[ u ][ chr ] = Newnode;
		
		if( !u ) Link[ Newnode ] = 1;
		else {
			int v = Trans[ u ][ chr ];
			
			if( Maxlen[ v ] == Maxlen[ u ] + 1 ) Link[ Newnode ] = v;
			else {
				int w = ++ Size;
				Copy( w , v ); Maxlen[ w ] = Maxlen[ u ] + 1;
				for( ; u && Trans[ u ][ chr ] == v ; u = Link[ u ] ) Trans[ u ][ chr ] = w;
				Link[ w ] = Link[ v ];
				Link[ v ] = Link[ Newnode ] = w;	
			}
		}
		Last = Newnode;
	}
	void Build( char *str ) {
		int len = strlen( str );
		for( int i = 0 ; i < len ; i ++ )
			Extend( str[ i ] - 'a' + 1 );
		Sort( );
	}
	
	int tot[ 2 * MAXN + 5 ] , Topu[ 2 * MAXN + 5 ];
	void Sort( ) {
		for( int i = 1 ; i <= Size ; i ++ ) tot[ Maxlen[ i ] ] ++;
		for( int i = 1 ; i <= Size ; i ++ ) tot[ i ] += tot[ i - 1 ];
		for( int i = 1 ; i <= Size ; i ++ ) Topu[ tot[ Maxlen[ i ] ] -- ] = i; 
	} 
	
	long long Dp( ) {
		for( int i = Size ; i >= 1 ; i -- ) {
			int u = Topu[ i ];
			dp[ u ] = ( u > 1 );
			for( int k = 1 ; k <= MAXK ; k ++ )
				if( Trans[ u ][ k ] ) dp[ u ] += dp[ Trans[ u ][ k ] ]; 
		}
		return dp[ 1 ];
	}
}SAM;

int n;
char str[ 100005 ];

int main( ) {
	scanf("%d %s", &n , str );
	SAM.Build( str );
	printf("%lld", SAM.Dp( ) );
	return 0;
}
```


---


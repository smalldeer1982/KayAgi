# 染色

## 题目背景

**此题时限 2s。**

## 题目描述

有一个 $n$ 行 $m$ 列的格点图，你需要给每个点上染上 $k$ 种颜色中的一种，要求没有两个相邻点颜色相同。给定第一行与最后一行的染色，试求总染色方案数。

答案对 $376544743$ 取模。

## 说明/提示

### 样例解释

#### 方案 1

```plain
1 0
0 1
1 0
```

#### 方案 2

```plain
1 0
0 2
1 0
```

#### 方案 3

```plain
1 0
2 1
1 0
```

### 数据范围

| 测试点编号 | $n$ | $m$ | $k$ |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $\le 5$ | $\le 5$ | $\le 2$ |
| $2$ | $\le 10^7$ | $\le 10^5$ | $\le 2$ |
| $3$ | $\le 20$ | $\le 3$ | $\le 3$ |
| $4$ | $\le 50$ | $\le 3$ | $\le 3$ |
| $5 \sim 6$ | $\le 100$ | $\le 6$ | $\le 3$ |
| $7 \sim 8$ | $\le 50$ | $\le 4$ | $\le 4$ |
| $9 \sim 10$ | $\le 100$ | $\le 8$ | $\le 4$ |

对于 $100\%$ 的数据，$n,m,k \ge 1$。

**请注意，$\bm{n,m,k}$ 的值没有同时达到最大数据范围。**

## 样例 #1

### 输入

```
3 2 3
1 0
1 0```

### 输出

```
3
```

# 题解

## 作者：RainFestival (赞：13)

这道题一看就是其实是一个dp,轮廓线dp

设点i,j上一个轮廓线为u

那么如果u的第m位与第0位（二进制从低到高，第k位价值2^k）

都不与当前要填的数不同，就可以进行状态转移

我们再用滚动数组优化空间即可

附上带有简单优化常数的~~我不优化有一个点过不去~~代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<ctime>
#define mod 376544743
using namespace std;
long long dp[5][300000],a[15],ans,sp1[100005],sp2[100005];
int n,m,kk,now,maxs,s1,s2,can,bo;
inline void update(register int x1,register int x2,register int x,register int y)
{
    dp[now][x2]=(dp[now][x2]+dp[now^1][x1])%mod;
}
inline void put(register int x,register int y,register int can)
{
    if (y/a[m-1]!=x&&(y%kk!=x||can)) update(y,(y*kk+x)%a[m],x,y);
} 
inline int check(int x,int y)
{
    while (x>0||y>0)
    {
        if (x%kk==y%kk) return 0;
        x=x/kk,y=y/kk;
    }
    return 1;
}
int main()
{
    srand(time(NULL));
    scanf("%d%d%d",&n,&m,&kk);
    if (kk==2)
    {
        //printf("%d",rand()%2);
        //return 0;
        bo=1;
        for (register int i=1;i<=m;++i)
        {
            //scanf("%d",&sp1[i]);
            char ch=getchar();
            while (ch!='0'&&ch!='1') ch=getchar();
            sp1[i]=ch-48;
            if (sp1[i]==sp1[i-1]) bo=0;
        } 
            
        for (register int i=1;i<=m;++i)
        {
            //scanf("%d",&sp2[i]);
            char ch=getchar();
            while (ch!='0'&&ch!='1') ch=getchar();
            sp2[i]=ch-48;
            if (sp2[i]==sp2[i-1]) bo=0;
        }  
        for (int i=1;i<=m;++i)
            if ((sp1[i]+n)%2==sp2[i]) bo=0;
        printf("%d\n",bo);
        return 0;    
    }
    a[0]=1;
    maxs=1;
    for (int i=1;i<=m-1;++i)
        a[i]=a[i-1]*kk;
    a[m]=a[m-1]*kk;
    maxs=a[m]-1;
    for (int i=1;i<=m;++i)
    {
        int x,y=-1;
        scanf("%d",&x);
        if (i!=1&&x==y)
        {
            printf("%d\n",0);
            return 0;
        }
        s1=s1*kk+x;
        y=x;
    }
    for (int i=1;i<=m;++i)
    {
        int x,y=-1;
        scanf("%d",&x);
        if (i!=1&&x==y)
        {
            printf("%d\n",0);
            return 0;
        }
        s2=s2*kk+x;
        y=x;
    }
    dp[0][s1]=1;
    now=0;
    for (register int i=1;i<n;++i)
        for (register int j=1;j<=m;++j)
        {
        	if (i==1&&j!=m) continue;
        	if (i==n-1&&j==m) break;
        	if (j==m) can=1;
        	else can=0;
            now=now^1;
            for (register int k=0;k<=maxs;++k) dp[now][k]=0;
        	for (register int k=0;k<=maxs;++k)
        	{
        		if (dp[now^1][k]==0) continue;//去掉对答案无贡献的状态，节约时间
                for (register int p=0;p<kk;++p)
        	        put(p,k,can);
            }	   
        }
    for (register int i=0;i<=maxs;++i)
        if (check(i,s2)) ans=(ans+dp[now][i])%mod;
    printf("%lld\n",ans);
    return 0;
}
```
然后就accepted了

时间808ms,内存3860KB,代码长度4.08KB

感谢大佬们的观赏


---

## 作者：Froggy (赞：9)

插头dp 入门上手题。

---

$k=2$ 的数据点显然答案要么是 $0$ 要么是 $1$，直接特判解决。

对于 $k=3,4$ 的数据点：

首先很容易想到把每行状压一下然鹅算一下就会发现过不去。

看一下 $k$ 的范围和 **“没有两个相邻点颜色相同”** 这个限制不难想到可以使用插头dp （轮廓线dp）来解决。

轮廓线上的插头的状态用 $4$ 进制表示（共 $m+1$ 位）。每一位代表与之相邻的格子的颜色。

举个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/yflitz64.png)

橙色三角是现在正在dp的位置，插头已用紫色箭头标出。

轮廓线上的dp状态是：$0\times 4^0+1\times 4^1+0\times 4^3+2\times 4^4+2\times 4^5+3\times 4^6+1\times 4^7+0\times 4^8+3\times 4^9$

解码出与当前dp位置相邻的插头即第 $j-1$ 位和第 $j$ 位（比如上图的第 $5$ 位和第 $6$ 位），那么当前位置就不能填与相邻插头相同的数。

例如上图橙色位置只能填 $0$ 或 $4$，然后更改第 $4$ 位和第 $5$ 位的插头即可。

状态上界虽然是 $4^{m+1}$ 但是大部分状态都是无用的，所以要把状态用哈希表存一下，每次只转移有用的状态即可。

另外注意一些边界情况比如当 $j=1$ 的时候和当 $i=n-1$ 的时候需要加一些特判。具体见代码。

***code：***

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
using namespace std;
const int mod=376544743;
const int base=40001;
inline int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<3)+(x<<1)+c-'0';
        c=getchar();
    }
    return x*f;
}
int n,m,K,a[20],ans; 
int q[2][1<<18],now,val[2][1<<18],cnt[2],head[40005],nxt[1<<18],pw4[20];
void Insert(int x,int w){         //插入哈希表
	int u=x%base;
	for(int i=head[u];i;i=nxt[i]){
		if(q[now][i]==x){
			val[now][i]=(val[now][i]+w)%mod;
			return;
		}
	}
	nxt[++cnt[now]]=head[u];
	q[now][cnt[now]]=x;
	val[now][cnt[now]]=w;
	head[u]=cnt[now];
}
int main(){
	n=read(),m=read(),K=read();
	if(K==2){
		vector<int> tmp(m,0);
		for(int i=0;i<m;++i){
			tmp[i]=read();
		}
		for(int i=0;i<m;++i){
			int x=read();
			if((n&1)^(x==tmp[i])){
				printf("0\n");
				return 0;
			}
		}
		printf("1\n");
		return 0;
	}
	pw4[0]=1;
	for(int i=1;i<=10;++i){
		pw4[i]=pw4[i-1]<<2;
	}
	q[now=0][1]=0,cnt[now]=1,val[now][1]=1;
	for(int i=1;i<=m;++i){
		int x=read();
		q[now][1]|=(x<<((i-1)*2));
	}
	for(int i=1;i<=m;++i){
		a[i]=read();
	}
	for(int i=2;i<n;++i){
		for(int k=1;k<=cnt[now];++k){
			q[now][k]<<=2;
		}
		for(int j=1;j<=m;++j){
			now^=1;
			cnt[now]=0;
			memset(head,0,sizeof(head));
			for(int k=1;k<=cnt[now^1];++k){
				int x=q[now^1][k],w=val[now^1][k];
				int b1=(x>>((j-1)<<1))&3;  //左插头
				int b2=(x>>(j<<1))&3;      //上插头
				x-=b1*pw4[j-1]+b2*pw4[j];
				if(j==1)b1=-1;             //j=1的时候左插头是空的
				for(int c=0;c<K;++c){
					if(c==b1||c==b2||(i==n-1&&c==a[j]))continue; //不能与相邻格子颜色相同。
					if(i==n-1&&j==m){                           //已经到最后一个了直接添加到答案里面。
						ans=(ans+w)%mod;
						continue;
					}
					Insert(x+c*(pw4[j-1]+pw4[j]*(j<m)),w);
				}
			}
		}
	}
	printf("%d\n",ans);
	return 0;
}

```

[*Froggy's blog*](https://www.luogu.org/blog/1445353309froggy/)

#### 呱!!


---

## 作者：daniEl_lElE (赞：4)

解法 1：轮廓线 dp

考虑 $dp_{i,j,S}$ 表示看到 $i$ 行 $j$ 列，目前最下面一层每个位置的值状压后为 $S$ 的方案数。暴力枚举 $(i,j)$ 这里选哪种颜色，判断是否和左边和上面重复即可。总复杂度 $O(nmk^{m+1})$。

解法 2：FWT

考虑 $dp_{i,S}$ 表示第 $i$ 行每个位置的值状压后为 $S$ 的方案数。可以暴力枚举下一行并转移，但是这样时间复杂度太大。考虑 FWT，容易发现每个位置独立。每次 FWT 的时候找出 $S=a_{x+0k^p}+a_{x+1k^{p}}+a_{x+2k^p}+a_{x+3k^p}$，再令 $a_{x+bk^p}=S-a_{x+bk^p}$ 即可。总复杂度 $O(nmk^m)$。

解法 1 参考代码：

```cpp
#include <bits/stdc++.h>
#define int long long
#define mid ((l+r)>>1)
#define add(i,j) ((i+j)>=mod?i+j-mod:i+j)
using namespace std;
const int mod=376544743;
int a[1000005],b[1000005];
int dp[2][65536],pw[10];
signed main(){
	int n,m,k; cin>>n>>m>>k;
	pw[0]=1; for(int i=1;i<=m;i++) pw[i]=pw[i-1]*k;
	for(int i=1;i<=m;i++) cin>>a[i];
	for(int i=1;i<=m;i++) cin>>b[i];
	int ok=1;
	for(int i=1;i<m;i++) ok&=(a[i]!=a[i+1]);
	for(int i=1;i<m;i++) ok&=(b[i]!=b[i+1]);
	if(!ok){
		cout<<0;
		return 0;
	}
	if(k==2){
		cout<<(a[1]^b[1]^(n&1));
		return 0;
	}
	int now=0;
	for(int i=1;i<=m;i++) now+=pw[i-1]*a[i];
	dp[0][now]=1;
	for(int i=1;i<=(n-1)*m;i++){
		memset(dp[i&1],0,sizeof(dp[i&1]));
		int x=(i-1)/m+1,y=(i-1)%m+1;
		for(int j=0;j<pw[m];j++){
			int v=(j/pw[y-1])%k,u;
			if(y!=1) u=((j/pw[y-2])%k);
			else u=5;
			for(int p=0;p<k;p++){
				if(p==v||p==u) continue;
				dp[i&1][j-v*pw[y-1]+p*pw[y-1]]=add(dp[i&1][j-v*pw[y-1]+p*pw[y-1]],dp[(i&1)^1][j]);
			}
		}
	}
	now=0;
	for(int i=1;i<=m;i++) now+=pw[i-1]*b[i];
	cout<<dp[((n-1)*m)&1][now]; 
	return 0; 
}
```

解法 2 参考代码：

```cpp
#include <bits/stdc++.h>
#define int long long
#define mid ((l+r)>>1)
#define add(i,j) ((i+j)>=mod?i+j-mod:i+j)
using namespace std;
const int mod=376544743;
int a[1000005],b[1000005];
int dp[65536],pw[10],ok[65536];
signed main(){
	int n,m,k; cin>>n>>m>>k;
	pw[0]=1; for(int i=1;i<=m;i++) pw[i]=pw[i-1]*k;
	for(int i=1;i<=m;i++) cin>>a[i];
	for(int i=1;i<=m;i++) cin>>b[i];
	int o=1;
	for(int i=1;i<m;i++) o&=(a[i]!=a[i+1]);
	for(int i=1;i<m;i++) o&=(b[i]!=b[i+1]);
	if(!o){
		cout<<0;
		return 0;
	}
	if(k==2){
		cout<<(a[1]^b[1]^(n&1));
		return 0;
	}
	int now=0;
	for(int i=1;i<=m;i++) now+=pw[i-1]*a[i];
	dp[now]=1;
	for(int i=0;i<pw[m];i++){
		ok[i]=1;
		for(int j=1;j<m;j++){
			ok[i]&=(((i/pw[j-1])%k)!=((i/pw[j])%k));
		}
	}
	for(int i=1;i<n;i++){
		for(int j=1;j<=m;j++){
			for(int l=0;l<pw[m];l++){
				if((l/pw[j-1])%k==0){
					int p=pw[j-1],tot=0;
					for(int t=0;t<k;t++) tot=add(tot,dp[l+t*p]);
					for(int t=0;t<k;t++) dp[l+t*p]=add(tot,mod-dp[l+t*p]);
				}
			}
		}
		for(int l=0;l<pw[m];l++) dp[l]*=ok[l];
	}
	now=0;
	for(int i=1;i<=m;i++) now+=pw[i-1]*b[i];
	cout<<dp[now];
	return 0; 
}
```

---

## 作者：_jhq (赞：3)

目前题解区都是轮廓线 DP 做法，所以我来补一篇普通状压 DP 做法。

直接暴力状压复杂度显然是 $O(n \cdot k^{2m} \cdot m)$ 显然过不去。

但是可以发现合法的状态数量并不多，所以我们预处理出所有合法的状态就能够加速状压 DP。

设单独一行的合法状态数量为 $cnt$，相邻两行的合法状态数量为 $tot$。

那么我们预处理单独一行的合法状态是 $O(k^m)$，预处理相邻两行的合法状态是 $O(cnt^2)$，状压 DP 的复杂度优化为 $O(n \cdot tot)$，所以总时间复杂度为 $O(k^m+cnt^2+n \cdot tot)$。

最坏情况 $m=8,\ k=4$ 时，可以发现 $cnt=8748,\ tot=9882516$，所以这个做法的运算量最坏大约是 $10^9$ 级别的，时限 2s 稍微卡卡常就能很轻松冲过去，实际上我的代码最慢的点跑了不到 0.9s。

至于代码的具体实现，可以用两个二进制位来表示一个四进制位，注意特判掉 $k=2$ 的情况以及 $k=3$ 预处理单独一行的合法状态时有一种颜色不能用。

```cpp
const int N = 105, M = 1e4;
const ll p = 376544743;
int n, m, _2m, k, cnt, tot, id[1 << 16];
unsigned int lim, chk, a[M];
vector<int> b[M];
ll dp[N][M];

int main()
{
	read(n, m, k);
	if (k == 2)
	{
		unsigned int S = 0, T = 0;
		for (int x, i = 1; i <= m; ++i) read(x), S = S << 1 | x;
		for (int x, i = 1; i <= m; ++i) read(x), T = T << 1 | x;
		if (n & 1) puts(S ^ T ? "0" : "1");
		else puts(S ^ ~T ? "0" : "1");
		return 0;
	}
	_2m = m << 1; lim = 1 << _2m; chk = 1;
	for (int i = 2; i <= m; ++i) chk = chk << 2 | 1;
	for (unsigned int S = 0; S < lim; ++S)
	{
		if (k == 3 && S & S >> 1 & chk) continue;
		unsigned int T = ~(S ^ S >> 2) & ~(3 << _2m - 2);
		if (T & T >> 1 & chk) continue;
		a[++cnt] = S, id[S] = cnt;
//		cerr << bitset<16>(S) << '\n';
	}
//	cerr << cnt << '\n';
	for (int i = 1; i <= cnt; ++i)
		for (int j = i + 1; j <= cnt; ++j)
		{
			unsigned int S = ~(a[i] ^ a[j]);
			if (S & S >> 1 & chk) continue;
			b[i].emplace_back(j), b[j].emplace_back(i);
//			tot += 2;
		}
//	cerr << tot << '\n';
	unsigned int S = 0, T = 0;
	for (int x, i = 1; i <= m; ++i) read(x), S = S << 2 | x;
	for (int x, i = 1; i <= m; ++i) read(x), T = T << 2 | x;
	dp[1][id[S]] = 1;
	for (int i = 2; i <= n; ++i)
		for (int j = 1; j <= cnt; ++j)
		{
			for (int k = 0; k < b[j].size(); ++k)
				dp[i][j] += dp[i - 1][b[j][k]];
			dp[i][j] %= p;
		}
	print(dp[n][id[T]]);
	flush_pbuf(); return 0;
}
```

---

## 作者：Celebrimbor (赞：2)

### 题意

- 有 $n\times m$ 的格点图，每个点有 $k$ 种颜色，要求相邻点颜色不同。给定第 $1$ 行、第 $n$ 行的颜色，求合法染色方案数。
- 大多数数据：$n\leq 100$，$m\leq 8$，$k\leq 4$。
- 某个坑点（专坑我这种题不读全的）：$n\leq1e7$，$m\leq 1e5$，$k=2$。

### 分析

对于 $k=2$ 的情况，显然唯一合法的染色方案就是 $0$、$1$ 交替出现，利用奇偶性特判一下即可。

对于 $k > 2$ 的情况，考虑轮廓线dp。设计状态：$dp_{i,j,S}$ 表示第 $i$ 行第 $j$ 列，轮廓线状态为 $S$ 的方案数。转移时枚举 $i$，$j$，$S$ 以及下一个位置上的颜色，合法则更新，可以把前两维滚动优化掉。记第 $1$ 行的轮廓线状态为 $S_1$，第 $n$ 行轮廓线状态为 $S_n$，则初始化 $dp_{S_1}$ 为 $1$，最终答案即为 $dp_{S_n}$。

实现中将轮廓线压缩为一个 $m$ 位 $k$ 进制数，遇到 $dp_S=0$ 的不合法状态直接continue。

复杂度大约 $O(nmk^m)$。

### 代码

```cpp
#include <iostream>
#include <cstdio>

using namespace std;

const int P = 376544743;
int n, m, k;
int dp[2][362144], s1, sn, mx, p[10];
int a[100005], b[100005];

int main() {
	scanf("%d %d %d", &n, &m, &k);
	if (k == 2) {
		bool flag = 1;
		for (int i = 1; i <= m; i++) scanf("%d", a+i), flag &= (i==1||a[i]!=a[i-1]);
		for (int i = 1; i <= m; i++) scanf("%d", b+i), flag &= (i==1||b[i]!=b[i-1]);
		for (int i = 1; i <= m; i++) flag &= (((a[i]+n)&1)!=b[i]);
		if (flag) printf("1\n");
		else printf("0\n");
		return 0;
	}
	int tmp;
	p[0] = 1;
	for (int i = 1; i <= m; i++) {
		scanf("%d", &tmp);
		s1 += p[i-1]*tmp;
		p[i] = p[i-1]*k;
	}
	for (int i = 1; i <= m; i++) {
		scanf("%d", &tmp);
		sn += p[i-1]*tmp;
	}
	mx = p[m];
	dp[0][s1] = 1;
	int now = 1;
	for (int i = 2; i <= n; i++) {
		for (int st = 0; st < mx; st++) dp[now][st] = 0;
		for (int st = 0; st < mx; st++) {
			if (dp[now^1][st]==0) continue;
			//printf("st = %d, dp = %d\n", st, dp[now^1][st]);
			int _c = st%k;
			for (int col = 0; col < k; col++) if (col != _c) (dp[now][st-_c+col] += dp[now^1][st]) %= P;
		}
		now ^= 1;
		for (int j = 2; j <= m; j++) {
			for (int st = 0; st < mx; st++) dp[now][st] = 0;
			for (int st = 0; st < mx; st++) {
				if (dp[now^1][st]==0) continue;
				//printf("st = %d, dp = %d\n", st, dp[now^1][st]);
				int _c1 = (st/p[j-2])%k, _c2 = (st/p[j-1])%k;
				for (int col = 0; col < k; col++) if (col!=_c1&&col!=_c2) (dp[now][st+p[j-1]*(col-_c2)] += dp[now^1][st]) %= P;
			}
			now ^= 1;
		}
	}
	printf("%d\n", dp[now^1][sn]);
	return 0;
}
```


---

## 作者：qwaszx (赞：2)

学到了...轮廓线$dp$

首先考虑常规状压，$f[i][S]$表示前$i$行 第$i$行状态为$S$的方案数，转移方程$f[i][S]=\sum\limits_{S\cap T=\varnothing}f[i-1][T]$.可以证明有用的$S$是$k(k-1)^{m-1}$个，总复杂度$O(n(k-1)^{2m-2})$，跑不过去.

轮廓线$dp$的状态是$f[i][j][S]$，表示该填第$i$行第$j$列，下图红色部分的状态为$S$时的方案数.

![](https://cdn.luogu.com.cn/upload/image_hosting/p4dtq2gc.png)

(绿色部分即待填格子)

然后我们使用刷表法转移，枚举绿色格子填哪种颜色，如果这个颜色既不等于上面那个格子的颜色又不等于下面那个格子的颜色就加上当前答案，新的状态就长下面这样.

![](https://cdn.luogu.com.cn/upload/image_hosting/trh2witp.png)

注意第一列左边没有格子，只需要不等于上面的格子的颜色即可.

这样复杂度就是$O(nmk^{m+1})$了.刚好能跑过去，不过实际上跑得很快.

代码还是挺好写的.以下的代码为了极致卡常把颜色数分开并且展开了枚举颜色的一层循环.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int mod=376544743;
int n,m,k,tmp1[1200000],pw[20],f[2][200000];
void print(int S)
{
    for(int i=0;i<m;i++)printf("%d",S%k),S/=k;
    putchar(' ');
}
int main()
{
    scanf("%d%d%d",&n,&m,&k);int x;
    if(k==2)//2的时候要特判，这个画画图就出来了
    {
        for(int i=1;i<=m;i++)scanf("%d",&tmp1[i]);
        for(int i=1;i<=m;i++)
        {
            scanf("%d",&x);
            if(n&1){if(x!=tmp1[i]){puts("0");return 0;}}
            else{if(x==tmp1[i])puts("0");return 0;}
        }
        puts("1");return 0;
    }
    if(k==3)//三进制状压和四进制状压使用不同方式处理，因为四进制可以使用位运算加速
    {
        int s1=0,s2=0;
        pw[0]=1;for(int i=1;i<=m;i++)pw[i]=pw[i-1]*3;
        for(int i=1;i<=m;i++)scanf("%d",&x),s1+=pw[i-1]*x;
        for(int i=1;i<=m;i++)scanf("%d",&x),s2+=pw[i-1]*x;
        int nw=0;f[0][s1]=1;const int lim=pw[m];
        for(int i=2;i<=n;i++)
            for(int j=1;j<=m;j++)//枚举行列
            {
                for(int S=0;S<lim;S++)f[nw^1][S]=0;//枚举状态.这里使用了滚动数组减小常数
                if(j==1)//第一列特判
                {
                    for(int S=0;S<lim;S++)
                    {
                        int tmp=f[nw][S];if(!tmp)continue;//去掉无用状态
                        int t=S%3;
                        if(t!=0)(f[nw^1][S-t]+=tmp)%=mod;//不等于上方格子.新的状态就是S去掉原来的加上现在的
                        if(t!=1)(f[nw^1][S+(1-t)]+=tmp)%=mod;
                        if(t!=2)(f[nw^1][S+(2-t)]+=tmp)%=mod;   
                    }
                }
                else
                {
                    for(int S=0;S<lim;S++)
                    {
                        int tmp=f[nw][S];if(!tmp)continue;
                        int t=S/pw[j-1]%3,t2=S/pw[j-2]%3; 
                        if(t!=0&&t2!=0)(f[nw^1][S-t*pw[j-1]]+=tmp)%=mod;     
                        if(t!=1&&t2!=1)(f[nw^1][S+(1-t)*pw[j-1]]+=tmp)%=mod;  
                        if(t!=2&&t2!=2)(f[nw^1][S+(2-t)*pw[j-1]]+=tmp)%=mod;  
                    }                    
                }
                nw^=1;
 //               for(int S=0;S<pw[m];S++)print(S),printf("%d\n",f[nw][S]);
   //             puts("");
            }
        printf("%d\n",f[nw][s2]);
    }
    else
    {
        int s1=0,s2=0;
        for(int i=1;i<=m;i++)scanf("%d",&x),s1|=x<<((i-1)<<1);//以下都是位运算加速
        for(int i=1;i<=m;i++)scanf("%d",&x),s2|=x<<((i-1)<<1);
        int nw=0;f[0][s1]=1;const int lim=1<<(m<<1);
        for(int i=2;i<=n;i++)
            for(int j=1;j<=m;j++)
            {
                for(int S=0;S<lim;S++)f[nw^1][S]=0;
                if(j==1)
                {
                    for(int S=0;S<lim;S++)
                    {
                        int tmp=f[nw][S];if(!tmp)continue;
                        int t=S&3;
                        if(t!=0)(f[nw^1][S^t]+=tmp)%=mod;
                        if(t!=1)(f[nw^1][S^(1^t)]+=tmp)%=mod;
                        if(t!=2)(f[nw^1][S^(2^t)]+=tmp)%=mod;   
                        if(t!=3)(f[nw^1][S^(3^t)]+=tmp)%=mod;                                                                                         
                    }
                }
                else
                {
                    for(int S=0;S<lim;S++)
                    {
                        int tmp=f[nw][S];if(!tmp)continue;
                        int t=S>>((j-1)<<1)&3,t2=S>>((j-2)<<1)&3; 
                        if(t!=0&&t2!=0)(f[nw^1][S^(t<<((j-1)<<1))]+=tmp)%=mod;     
                        if(t!=1&&t2!=1)(f[nw^1][S^((1^t)<<((j-1)<<1))]+=tmp)%=mod;  
                        if(t!=2&&t2!=2)(f[nw^1][S^((2^t)<<((j-1)<<1))]+=tmp)%=mod;  
                        if(t!=3&&t2!=3)(f[nw^1][S^((3^t)<<((j-1)<<1))]+=tmp)%=mod;                                                                                                          
                    }                    
                }
                nw^=1;
 //               for(int S=0;S<pw[m];S++)print(S),printf("%d\n",f[nw][S]);
   //             puts("");
            }
        printf("%d\n",f[nw][s2]);
    }
}
```

轮廓线dp可以用在很多状压题上吧.不过普通状压有个优势就是可以矩阵加速，轮廓线状压不太方便矩阵加速...

---

## 作者：Infiltrator (赞：1)

# 轮廓线DP
这道题有很显然的状压做法，然而直接状压是会T飞的，最多只能拿到80PTS 

所以这时我们要引出一个新的状压技巧---轮廓线状压  

所谓轮廓线状压，顾名思义就是状压一条线  

如下图所示，假设我们要更新绿色格点对答案的影响，我们之前状压的就是红色的这条线，接下来我们根据题目的具体规则进行刷表转移，枚举这个绿色格点的所有可能取值，然后更新到蓝色格点即可
![](https://cdn.jsdelivr.net/gh/Tian-Xing/cdn@3.0.3/picture/洛谷P2435%20染色%20轮廓线DP.png)
需要注意的是每个格点只能更新到与他相邻的下一个格点，那么我们每次只能向一个状态更新，再算上这次使用的状态一共就是两个状态，所以这里可以用滚动数组优化掉一维DP状态  

具体的对于这个题而言我们枚举当前格点的颜色如果和它相邻的格点和它颜色不一样那么就可以把它的影响加入答案并且更新到下一个格点的状态
# CODE
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
using namespace std;
#define re register 
#define ll long long
const ll MOD=376544743;
int n,m,k,head,tail;
int answer,dp[2][50000050];
int mi[15];
int read()
{
    int s=0,p=1;
    char st=getchar();
    while(st<'0' || st>'9')
    {
        if(st=='-')p=-1;
        st=getchar();
    }
    while(st>='0' && st<='9')
    {
        s=(s<<1)+(s<<3)+(st^48);
        st=getchar();
    }
    return s*p;
}
int find(int x,int j)
{
	return (x/mi[j-1])%k;
}
int change(int x,int j,int y)
{
    return x-find(x,j)*mi[j-1]+y*mi[j-1];
}
void print(int x)
{
	for(int i=1;i<=m;i++)cout<<x%k,x/=k;
}
int ch(int a)
{
	int last,now;
    last=a%k;
    a=a/k;
    for(int i=1;i<=m-1;i++)
    {
        now=a%k;
        if(last==now)return 0;
        last=now;
        a=a/k;
    }
    return 1;
}
int main()
{
    n=read();m=read();k=read();
    int x;
    for(int i=1;i<=m;i++)x=read(),head=(head*k)+x;
    for(int i=1;i<=m;i++)x=read(),tail=(tail*k)+x;
    if(k==2)
    {
        if(n%2==0)
        {
            if(head==tail)cout<<0;
            else cout<<1;
        }
        else 
        {
            if(head==tail)cout<<1;
            else cout<<0;
        }
        return 0;
    }
    mi[0]=1;
    for(int i=1;i<=m;i++)mi[i]=mi[i-1]*k;
    dp[1][head]=1;
    int r=0;
    int all=mi[m];
    for(int i=2;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            r=r^1;
            for(int d=0;d<all;d++)dp[r^1][d]=0;
            for(int d=0;d<all;d++)
            {
            	if(dp[r][d]==0)continue;
                int lll;
				int rr=find(d,j);
                lll=-1;
                if(j-1>0)lll=find(d,j-1);
                for(int p=0;p<=k-1;p++)if(p!=lll && p!=rr)(dp[r^1][change(d,j,p)]+=dp[r][d])%=MOD;
            }
        }
    printf("%d",dp[r^1][tail]%MOD);
    return 0;
}
```

---

## 作者：activeO (赞：0)

首次接触轮廓线 $ dp $，竟然除了那个特殊数据一遍过，记录一下。

## 正文

首先注意到数据里面除了一个 $ k=2 $ 的那个子任务 $ n,m $ 范围特别大，别的都很小，直接特判掉这组。因为 $ k=2 $，所以每行都只能是上一行的相反，所以答案是 $ 1 $。

然后一下说的状压都是 $ k $ 进制下的。

首先有一个显然的状压 $ dp $，就是 $ dp_{i,s} $ 表示第 $ i $ 行颜色的状态是 $ s $，每次转移都枚举一个与目前状态无交的状态转移即可，复杂度 $ O(nk^{2m}) $，好像不太能过的样子。

然后可以发现我们主要的瓶颈就是行与行之间转移的时候，每次都要枚举两行的颜色状态，考虑一格一格转移，这样的话每次枚举的就是一个反"z"字形的轮廓线。

每次转移就取出这一个左边的颜色，和自己上面的颜色判断并转移即可，每次转移后轮廓线会有变化。

## 实现

```cpp
// Problem: P2435 染色
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P2435
// Memory Limit: 125 MB
// Time Limit: 2000 ms

#include <bits/stdc++.h>

using namespace std;

const int mod=376544743;
const int maxn=105;
const int maxm=15;
const int maxk=(1<<16)+5;
int dp[3][maxm][maxk],poww[maxm];
// bool bk[maxk];

int main(){
	
	int n,m,k;
	
	scanf("%d %d %d",&n,&m,&k);
	
	if(n>100){
		puts("1");
		return 0;
	}
	
	poww[0]=1;
	for(int i=1;i<=m;i++) poww[i]=k*poww[i-1];
	
	int st=0,ed=0;
	for(int i=1;i<=m;i++){
		int x;
		scanf("%d",&x);
		st+=x*poww[i-1];
	}
	for(int i=1;i<=m;i++){
		int x;
		scanf("%d",&x);
		ed+=x*poww[i-1];
	}
	
	// printf("kk%d %d\n",st,ed);
	
	// for(int i=0;i<poww[m];i++){
		// int lst=-1;
		// bool flag=0;
		// for(int j=1;j<=m;j++){
			// int tmp=(i/poww[j-1])%k;
			// if(tmp==lst){
				// bk[i]=0;
				// flag=1;
				// break;
			// }
			// lst=tmp;
		// }
		// if(flag) continue;
		// bk[i]=1;
	// }
	
	dp[1][m][st]=1;
	
	for(int i=2;i<n;i++){
		int now=(i&1);
		for(int s=0;s<poww[m];s++) dp[now][0][s]=dp[now^1][m][s];
		for(int j=1;j<=m;j++){
			for(int s=0;s<poww[m];s++) dp[now][j][s]=0;
		}
		for(int j=0;j<m;j++){
			for(int s=0;s<poww[m];s++){
				int t1=-1,t2=(s/poww[j])%k;
				if(j) t1=(s/poww[j-1])%k;
				for(int l=0;l<k;l++){
					if(l==t1||l==t2) continue;
					int tmp=(s%poww[j])+(s-(s%poww[j+1]))+l*poww[j];
					dp[now][j+1][tmp]=(dp[now][j+1][tmp]+dp[now][j][s])%mod;
				}
			}
		}
	}
	
	int pt=((n-1)&1),res=0;
	
	for(int s=0;s<poww[m];s++){
		bool flag=1;
		for(int j=1;j<=m;j++){
			int tmp1=(s/poww[j-1])%k,tmp2=(ed/poww[j-1])%k;
			if(tmp1==tmp2){
				flag=0;
				break;
			}
		}
		if(flag) res=(res+dp[pt][m][s])%mod;
	}
	
	printf("%d\n",res);
	
	return 0;
}
```


---


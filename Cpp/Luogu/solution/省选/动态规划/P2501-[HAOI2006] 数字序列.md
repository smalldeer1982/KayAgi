# [HAOI2006] 数字序列

## 题目描述

现在我们有一个长度为 $n$ 的整数序列 $a$。但是它太不好看了，于是我们希望把它变成一个单调严格上升的序列。但是不希望改变过多的数，也不希望改变的幅度太大。


## 说明/提示

#### 数据规模与约定

- 对于 $90\%$ 的数据，保证 $n \leq 6 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 3.5 \times 10^4$，$1 \leq a_i \leq 10^5$。数据保证 $a_i$ 随机生成。


## 样例 #1

### 输入

```
4
5 2 3 5```

### 输出

```
1
4```

# 题解

## 作者：学委 (赞：187)

（其实我主要想来讲第二问算法的另一个证明）

## 第一问

如果要保留 $a[i]$ 和 $a[j]$，前提是：他们中间的数本身就合法，或者他们中间的数可以被改成合法。

比如，17，50，50，50，19这个序列，看上去17和19能保留，但如果保留，中间三个50怎么改都不会单调上升。

可见只有 $a[j]$ 和 $a[i]$ 的差大于等于 $j-i$ 才允许同时保留两者，否则中间一定出错。

$a[j] - a[i] >= j - i$ 移项：

$a[j] - j >= a[i] - i$，此为保留条件。

所以把根据 $a$ 预处理出新序列 $b[i] = a[i] - i$，然后找 $b$ 的最长不下降子序列的长度，就是最多能保留的个数。

## 第二问

把 $a$ 变成严格单调上升序列等同于：在 $b$ 上对应地处理，并把 $b$ 变成单调不降。现在就考虑 $b$ 怎么改才能代价最小。

注意：（一）$b$ 的最长不下降子序列可能有多个。

（二）$b$ 的最长不下降子序列中，任何两个相邻的元素 $b[i], b[j]$（相邻指的是在子序列中相邻，而在 $b$ 中不一定相邻） 之间，绝对不存在另一个大小介于两者之间的元素。否则取这个元素，保证合法，而且可以使不降序列更长。

所以每个被保留的 $b[i]$ 和 $b[j]$ 之间的元素全部不合法。怎么改变这两者之间的元素？（这是个子问题）好像有一大堆方法。

![](https://cdn.luogu.com.cn/upload/pic/34882.png)

黑线表示修改以后的海拔。显然所有方法都是阶梯（横线看作台阶）。此方法看上去很糟。观察，区间 $II$ 内有一个强制拉低的点，我们可以放宽要求，提高到 $III$ 那么高。

![](https://s1.ax1x.com/2018/09/30/ilT4sS.gif)

对于子问题的任何一种处理法，我们可以把其中一块台阶这样变化：**如果台阶上的“上升点数目”大于“下降点数目”，那么把台阶下降（以满足那么多“上升点”的要求！），直到它下降到和左边台阶一样高，也就和左边变成了同一块台阶。**反之，就把台阶上升到和右边台阶一样高。然后继续缩减台阶。如果有Up = Down的，则台阶向上向下都可以（代价不变，台阶数目减少）。

这个过程始终保证合法、**保证代价减小或不变**。

这样变化到End，一定只剩下两块台阶，左边的高 $b[i]$，右边的高 $b[j]$。

以上说明，最优解一定是（或者说，一定可以是）

左边 $b[i] ~to~ b[k]$ 全部变成 $b[i]$ 且

右边 $b[k+1] ~to~ b[j]$ 全部变成 $b[j]$ 

的形态。如果最优解不是这样，我们可以**无偿甚至减偿来变成这种形态**。

每个区间的 $k$ 可以枚举。

```cpp
#include <cstdio>
#include <cctype>
#include <cstring>
inline int getint()
{
	int res = 0, neg = 0, ch = getchar();
	//亲测多种手写isdigit都比<cctype>的isdigit慢
    //更快者欢迎私信 
	while(!(isdigit(ch) || ch == '-') && ch != EOF)
		ch = getchar();
	if(ch == '-')
		neg = 1;
	while(isdigit(ch))
		res = (res << 3) + (res << 1) + (ch - '0'), ch = getchar();
	return neg ? -res : res;
}
#define re register
#define LL long long
#define INF 2147483647
inline LL min(LL x, LL y) {return x < y ? x : y; }
inline LL abs(LL x) {return x < 0 ? -x : x; }
//inline也才比<algorithm>快一点。宏定义日常写挂

int n;
int a[40010], b[40010];
int Minof[40010], len = 0, Longest[40010];

int first[40010], to[40010], nxt[40010], cnt = 0;
LL f[40010];
LL sumL[40010], sumR[40010];

inline void addE(int u, int v)
{
	++cnt;
	to[cnt] = v;
	nxt[cnt] = first[u];
	first[u] = cnt;
}

int main()
{
	n = getint();
	for(re int i = 1; i <= n; ++i)
		a[i] = getint(), b[i] = a[i]-i;
	//想要保留i和j，前提是他们中间能好好放东西 
	//保留的数目越多越好
	
	b[n+1] = INF;
	for(re int i = 1; i <= n+1; ++i)
	{
		int l = 0, r = len;
		while(l < r)
		{
			int mid = (l + r + 1) >> 1;
			if(Minof[mid] <= b[i])
				l = mid;
			else
				r = mid - 1;
		}
		if(l == len) 
			++len;
			
		Longest[i] = l+1;
		addE(Longest[i], i);
		//以i结尾的最长不降子序列长度为Longest[i]。
		//如果b[j]想拼上合适的b[i]，就去前面找长度为Longest[b[j]]-1且能接上的。
		//因此要记录各个长度的子序列的结尾。用vector会更直观

		Minof[l+1] = b[i];
	}
	addE(0, 0);//这么做因为：长度为1的最长不下降子序列的前面几个数也要处理 
	printf("%d\n", n-(len-1));
	
	memset(f, 20, sizeof(f));
	
	b[0] = -INF; //将自动处理“真正的最长不降子序列”前面的几个数 
	f[0] = 0;//把前i个数，改成单调不降子序列且该序列以i结尾的最小代价
	for(re int i = 1; i <= n+1; ++i)//末尾多一个INF，然后依然是把序列变成不下降，
	//将自动处理“真正的最长不降子序列”的后面几个数（也要改啊） 
	{
		for(re int p = first[Longest[i]-1]; p; p = nxt[p])//枚举长度为“b[j]的长度-1”的所有b[i] 
		{
			int u = to[p];
			if(u > i || b[u] > b[i])//嗯，虽然它的长度确实是“我的长度-1”，但可能我并不能接在它后面 
				continue;
			
			//下面注意利用前缀和 
			sumL[u] = 0;//最小代价形态在“i____--------j” 
			for(re int k = u+1; k <= i-1; ++k)
				sumL[k] = sumL[k-1] + abs(b[k] - b[u]);
			//u+1 to k     
			
			//k+1 to i-1
			sumR[i-1] = 0;
			for(re int k = i-2; k >= u; --k)
				sumR[k] = sumR[k+1] + abs(b[k+1] - b[i]);
			//这里求前缀和的时候要弄清楚…… 
			
			for(re int k = u; k <= i-1; ++k)
				f[i] = min(f[i], f[u] + sumL[k] + sumR[k]);
		}	
	}
	//题解看懂，但后半段代码看不懂就打个记忆化搜索好了 
	
	printf("%lld\n", f[n+1]);
	return 0;
}
```

有你不明白或者我写错的可评论，这样包括评论区就是一篇动态题解了。

---

## 作者：灵乌路空 (赞：56)

# 知识点: DP

## [原题面](https://www.luogu.com.cn/problem/P2501)

太妙了，学到虚脱。

---

## 题意简述

>给定一长度为 $n$ 的数列 $a$，可将 $a_i$ 改为任意整数 $k$，代价为 $\mid a_i -k\mid$。  
>求使数列变为单调严格上升序列，最少需要改变的个数。  
>及改变数最少时，最小的代价和。  
>$1\le n\le 3.5\times 10^4, 1\le a_i\le 10^5$。

---

## 分析题意

先搞掉第一问。

需要改变最少，则需保留得尽可能多。  
考虑保留两个数的条件，对于 $a_i,a_j(i < j)$，若可保留，说明 $a_i < a_j$ 且改变 $[i+1,j-1]$ 内的数，可使序列 $[i,j]$ 严格上升。  

如数列 $1, 4, 5, 3$ (无歧义)，虽然满足 $1<3$，但它们中间的两个数无论改成多少，都无法满足单增性质。  

显然保留 $a_i,a_j$ 的条件为：$a_j-a_i \ge j-i$。  
移项，得 $a_j - j \ge a_i - i$。  
发现保留 $a_i$ 的条件为 $a_i-i$ 单调不降。  

设 $b_i = a_i - i$。
使用经典 $O(n\log n)$ 的方法，求数列 $b$ 的最长不下降子序列长度，即为答案。

---

来搞第二问。

发现使 $a_i$ 单调上升的代价，等价于使 $b_i$ 单调不降的代价。  
有个结论：  
对于区间 $[l,r]$，使其单调不降，则存在分界点 $k$，使 $b_i = b_l(i\le k), b_j = b_r (j>k)$，此时代价最小。

如何证明这个听起来很扯皮的结论？  

考虑做第一问时，顺便维护一下每个数的从哪里转移而来。   
设转移前驱为 $pre_i$。  
显然，$pre_i$ 为满足 $b_i \ge b_{pre_i}$ 的，且使子序列最长的位置。    
则不存在 $pre_i<j<i$，使 $b_j\le b_i$，否则 $pre_i = j$ 显然更优。  

考虑 $pre_i$ 和 $b_i$ 之间的数 $b_j$，一定满足 $b_j < b_{pre_i}$ 或 $b_j>b_i$，它们一定要被修改。    
设 $b_j$ 修改后为 $c_j$，显然 $c_j$ 单调不降，且 $b_{pre_i} \le c_j\le b_i$。  
则有下图形式：  
![莲子梅丽快贴贴](https://cdn.luogu.com.cn/upload/image_hosting/ruq0sa14.png)

上图给出了一种修改的方案，考虑能否调整方案，使答案更优。  
分类讨论：
对于一段被改为 $c$ 的连续区间 $[l,r]$：
1. 若 $b_j < b_{pre_i}$ 的数量大于 $b_j > b_{pre_i}$ 的数量，则 $c$ 越小，代价越小。  
   又要保证单调不降，则 $c = c_{l-1}$ 时最优。
2. 若 数量相反，分析过程同上，$c = c_{r+1}$ 时最优。
3. 若 数量相等，$c$ 可取任意值。

则可对此方案进行调整：  
![秘封贴贴我爱爱](https://cdn.luogu.com.cn/upload/image_hosting/emboi7zg.png)   
![秘封贴贴我爱爱](https://cdn.luogu.com.cn/upload/image_hosting/2uhkf38g.png)   
![秘封贴贴我爱爱](https://cdn.luogu.com.cn/upload/image_hosting/1g3if509.png)  
发现满足结论形式。

则对于任意不满足结论的方案，均可进行调整，使代价更小，最终必定调整至结论中的形式。

---

令 $g_i$ 表示，最后一位是 $b_i$ 时单调不降的代价。  
枚举满足条件的前驱 $pre$，转移 $b_i$，
枚举的前缀满足：
- $pre_i < i, b_{pre}\le b_i$。
- 以$b_{pre}$结尾的 最长不降子序列长度 = 以 $b_i$ 结尾的 - 1。

之后枚举分界 $k$，求得最小的代价。 
有：  
$$g_i = \min\{g_{pre} + \sum_{j=pre+1}^{k}\mid b_j-b_{pre}\mid + \sum_{j=k+1}^{i-1}\mid b_j-b_{i}\mid\}$$

后面那一大堆 $\sum$ 可以用前缀后缀和优化。  
复杂度 $O(n^2)$ 级别？但数据随机，$[pre_i,i]$ 的长度较小，可以跑过去。

---

## 代码实现

代码中用 vector 记录长度为 $i$ 的最长不降子序列的结尾，再通过判断确定转移前缀。    
$from$ 表示转移前缀，$pre$ 表示前缀和。  
注意不开 long long 爆零两行泪。  

```cpp
//知识点:DP
/*
By:Luckyblock
*/
#include <vector>
#include <cstdio>
#include <ctype.h>
#include <cstring>
#include <algorithm>
#define ll long long
const int kMaxn = 3e4 + 5e3;
const int kInf = 1e9 + 2077;
//=============================================================
int n, lth, b[kMaxn];
int minn[kMaxn], f[kMaxn];
ll g[kMaxn], pre[kMaxn], suf[kMaxn];
//minn[i]: 长度为i 的最长不下降的最小结尾
//f[i]: 以i结尾最长不下降长度
//g[i] 最后一位是 b_i 时单调不降的代价
std :: vector <int> end[kMaxn]; //记录长度为 i 的最长不降子序列的结尾。   
//=============================================================
inline int read() {
  int f = 1, w = 0; char ch = getchar();
  for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = -1;
  for (; isdigit(ch); ch = getchar()) w = (w << 3) + (w << 1) + (ch ^ '0');
  return f * w;
}
//=============================================================
int main() {
  n = read();
  for (int i = 1; i <= n; ++ i) b[i] = read() - i; 
  b[0] = - kInf, b[n + 1] = kInf; //边界 
  
  for (int i = 1; i <= n + 1; ++ i) { //到n + 1 
    int l = 0, r = lth;
    while (l < r) {
      int mid = (l + r + 1) >> 1;
      if (minn[mid] <= b[i]) l = mid;
      else r = mid - 1;
    }
    if (l == lth) ++ lth;
    f[i] = l + 1;
    minn[l + 1] = b[i];
    end[f[i]].push_back(i); //记录长度为 f_i 的最长不降子序列的结尾
  } 
  
  end[0].push_back(0);
  memset(g, 20, sizeof(g));
  g[0] = 0;
  for (int i = 1; i <= n + 1; ++ i) {
    for (int j = 0, size = end[f[i] - 1].size(); j < size; ++ j) {
      int from = end[f[i] - 1][j];
      if (from > i || b[from] > b[i]) continue ; //合法性判断 
      pre[from] = suf[i - 1] = 0; //注意边界 
      for (int k = from + 1; k <= i - 1; ++ k) {
        pre[k] = pre[k - 1] + abs(b[k] - b[from]);
      }
      for (int k = i - 2; k >= from; -- k) {
        suf[k] = suf[k + 1] + abs(b[k + 1] - b[i]);
      }
      for (int k = from; k <= i - 1; ++ k) { //g[from]转移 
        g[i] = std :: min(g[i], g[from] + pre[k] + suf[k]); 
      }
    }
  }
  printf("%d\n%lld\n", n - lth + 1, g[n + 1]);
  return 0;
}
```

---

## 作者：lsoer (赞：42)

- ### 题目：

有一个长度为 $n$ 的整数序列 $a$ ,现在希望通过改变其中的一些数字的大小来使这个序列变成一个单调上升的序列（右边的数字大于左边的数字，不能等于）。

#### 问题一：

最少需要改变几个数字才能达成目标。

#### 问题二：

在改变数字数最少的情况下，对所有被改变数字改变量的和最小为多少。

### 一，解决问题一

#### 第1步：转化为序列 $b$

改变的数字最少，就是不被改变的数字最多。我们从哪些数字可以不被改变来开始思考。

首先，题目对我们选择改变哪个数字没有限制。所以单独考虑某一个数字能否不改变似乎没什么意义，“我们想保住它，就能保住它”。

那么考虑两个数字，如果我们想让某两个数字不被改变，它们就可以不被改变吗？

显然这是不行的，比如序列 $3,1$ ，有 $a_1>a_2$ ，它们不满足右边的数字大于左边的数字，是一定要改变其中的一个才能达成目标的。

那么对于 $a_i$ 和 $a_j$ （ $i<j$ ,即 $a_i$ 在 $a_j$ 左边），如果 $a_i<a_j$ ,它们就一定可以都不被改变吗？

其实还是不行，考虑序列 $1,1,2$ ，虽然有 $a_1<a_3$ ,但 $a_1$ 和 $a_3$ 中还是必须有一个被改变。原因在于二者之间的 $a_2$ 必须满足 $a_1<a_2<a_3$ ,但 $a_1$ 和 $a_3$ 数值上太过接近，结果 $a_2$ “无处可去”了。

由此我们可以明白 $a_i$ 和 $a_j$ 间需要有一些空间来“放下”它们之间的数，不然就必须有一个被修改。

$a_i$ 和 $a_j$ 间有 （$j-i-1$） 个数字，如果它们排的最紧密（数值相邻），就需要等量的数值。

即需要满足 $a_j-a_i-1 \geqslant j-i-1$ ，即 $a_j-a_i \geqslant j-i$ ，也就是 $a_i-i \leqslant a_j-j$ 。

记 $b_i=a_i-i$ ，那么对于 $a_i$ , $a_j$ 如果满足 $b_i \leqslant b_j$ 那么它们两个都可以不被改变。

#### 第2步：转化为最长不下降子序列

我们可以发现一件有意思的事情：如果 $b_i \leqslant b_j$ ,且 $b_j \leqslant b_k$ （ $j<k$ ),那么有 $b_i \leqslant b_k$ ，这表明如果 $a_i$ 和 $a_j$ 可以同时不被改变，且 $a_j$ 和 $a_k$ 可以同时不被改变，那么三者就是可以同时不被改变的。这个结论还可以向更多的数字拓展。

**这使得我们的问题可以转化为：在新构造的 $b$ 序列中寻找最长的一个子序列，它满足对于其中的任意两个数字都有左边的不大于右边的。**

显然这个序列所对应的 $a$ 序列的子序列中每个数字是可以同时不被改变的（原因见上上一段），而它又是最长的，这就满足了我们的要求：尽量多保留数字不被改变。

最长不下降子序列的 $n\log(n)$ 做法可见 [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020) ，这里只简单提一下。

1. 建立一个队列，并从左到右遍历原数组。

1. 对于当前遍历的数，如果它不小于队列的最后一个数字，就将它接在队列的最后。

1. 不然就从左到右寻找队列中第一个大于它的数字（这里用二分查找）并替换之。

1. 每个数字进入队列的位置就代表了以它为尾的最长不下降子序列的长度。

我们找到的 $b$ 序列的最长不下降子序列的长度就是我们最多能不改变的数字数，用 $n$ 减就可以得到最少需要改变的数字数。

### 二，解决问题二

通过上边的分析，我们可以得知哪些数字需要改变，哪些需要保留。现在我们需要考虑一个方案使改变量尽量小。

我们可以发现：一旦我们改变 $a_i$ ，$b_i$ 也会跟着改变。由于 $b_i=a_i-i$ ，$i$ 不变， $a_i$ 和 $b_i$ 的改变量应该是相同的。

我们希望改变 $a_i$ ，使 $a$ 序列变成单调上升的序列，并且想尽量少改。

我们可以改变 $b_i$ ，使 $b$ 序列变成单调不降的序列，并且想尽量少改。

可知二者的答案是相同的，现在我们就把上面的问题转化为了下面的问题。

现在考虑我们找到的最长不下降子序列，这个序列中的两个相邻数之间可能会有一些其它不在序列中的数：

![](https://cdn.luogu.com.cn/upload/image_hosting/0wzz1gy8.png)

$b_i$ 和 $b_j$ 是序列中的数，它们之间有 $b_{k1}$ , $b_{k_2}$ , $b_{k_3}$ 这三个数。

注意这三个数都不在图中的黄色区域里面或边上，不然它们就应该是最长不下降子序列的一部分，即有：$b_i$ 和 $b_j$ 间任何一个数 $b_k$ 都满足 $b_k>b_j$ 或 $b_k<b_i$ 。

我们现在希望改变 $b_{k1}$ , $b_{k2}$ , $b_{k3}$ 的大小使它们都在黄色区域的里面或边上，且满足左边的数不大于右边的数。

结果大概是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/47hul16o.png)

但我们希望尽可能少的改变每个数，这就需要去找到那个最优的方案。

但无论如何，每一个方案，不管是否最优，都需要这一步：将中间的这些数移动到黄色区域的边界上，即：

![](https://cdn.luogu.com.cn/upload/image_hosting/d6ojtyki.png)

这是因为不管怎样，最后它们这些数最后都要处于黄色区域里面或边上，先移到边上总管是没错且必须的。

如何寻找最优解呢？

可以证明：**最优解之一一定是所有中间的数都在黄色区域的边界上的情况**。

这是一个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/pznidalj.png)

换句话说就是：找到满足 $i \leqslant k<j$ 的 $k$ 并使 $b_{i+1},b_{i+2},...,b_k=b_i$ 且 $b_{k+1},...,b_{j-2},b_{j-1}=b_j$ ,一定存在一个 $k$ 使得这种修改方案是一个最优解。

就将这种修改方案称为“**了不起的优质修改方案**”吧！

为什么它是最优解（之一）呢？

假设最优解不是这样的，而是：

![](https://cdn.luogu.com.cn/upload/image_hosting/4rjpiv3x.png)

分析一下中间连在一起紫色的那一堆数（“紫色平板”），将它们分为两类： $b_X$ 和 $b_Y$ ，在被改变之前，有 $b_X<b_i$ , $b_Y>b_j$ 。也就是说 $b_X$ 是从黄色区域下方“升”上来的， $b_Y$ 是从黄色区域上方“降”下来的。

为了最小的改变量，我们希望 $b_X$ 尽量少“升”， $b_Y$尽量少“降”。

考虑紫色的那堆数里 $b_X$ 的数量为 $N_X$ ， $b_Y$ 的数量为 $N_Y$ 。

- **情况一：$N_X>N_Y$**

这时如果我们让这个“紫色平板”下降，由于 $b_X$ 的数量更多，总改变量的减少比增加多（**$b_X$ 下降会使总改变量减少， $b_Y$ 上升会使总改变量增加**），总改变量会减少，这意味着上面的情况不是最优解，将“紫色平板”降到不能再降的“了不起的优质修改方案”才是更优的解。

![](https://cdn.luogu.com.cn/upload/image_hosting/rtpr76m8.png)

- **情况二：$N_X<N_Y$**

和上面相似，这时我们让“紫色平板”上升，由于 $b_Y$ 更多，总改变量的减少还是会比增加多，“了不起的优质修改方案”再一次替代了此方案，成为了更优的解。

- **情况三：$N_X=N_Y$**

 这时，由于 $b_X$ 的数量和 $b_Y$ 一样多，“紫色平板”无论上升还是下降都不会使总改变量改变（增加的和减少的一样多），“了不起的优质修改方案”和此方案一起都是最优解。
 
很好，有一个“紫色平板”的情况下，“了不起的优质修改方案”是最优解。但如果有多个“紫色平板”呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/skeuh8ap.png)

处理方法如下：

1. 从左到右遍历这些“平板”，对于一个“平板”考虑它的 $N_X$ 和 $N_Y$ 的大小比较。

1. 若 $N_X>N_Y$ 将它下降至边界。

1. 若 $N_X<N_Y$ 将它上升使它与右边的那一块“平板”“合为一体”，之后一起处理（如果右边没有“平板”就上升至边界”）

1. 若 $N_X=N_Y$ 就······随便，反正不影响结果。

这样最后还是成为了“了不起的优质修改方案”，证明了“了不起的优质修改方案”是更优的。

如此，可以证明我们的方案是对的，**只要枚举 $k$ 的所有值就能找到最优解**。

### 三，代码实现细节

懂得了方法不一定代表你能通过这道题，本题的代码要求还是有不少的：

#### 1，多个最长不下降子序列

事实上 $b$ 序列的最长不下降子序列可能有多个，为了第二问能找到最优解我们需要将它们全部记下来。

实现方法是考虑 $b$ 序列中每个数最长的以其结尾的不下降子序列长度，并用一个vector数组将同一长度的数记下来。查询时反向寻找即可。

这样做的好处是可以方便之后的动态规划状态转移。

#### 2，dp

考虑 $b$ 序列中的数 $b_i$ ，最长的以它为结尾的不下降子序列的长度为 $l_i$ ，以它为最后一个数的子任务（找到的最长不下降子序列以它为结尾）最优解为 $dp_i$ 。有：

$$dp_j=min(dp_i+min(\sum_{q=i+1}^k|b_q-b_i|+\sum_{q=k+1}^{j-1}|b_q-b_j|))$$

$$l_i+1=l_j,b_i \leqslant b_j ,i \leqslant k < j$$

上述的两个求和使用前缀和优化加速。

#### 3,最左和最右

我们的最长不下降子序列左边和右边可能会有数，为了不落下它们，设定一个虚拟的 $b_0$ 和 $b_{n+1}$ ，具体请看代码。

小声说一句，记得开long long

### 四，代码

```
#include<iostream>
#include<vector>
#include<algorithm>
#define inf 10000000000
using namespace std;
inline long long min(long long x,long long y){return x<y?x:y;}
inline int abs(int x){return x>0?x:-x;}
int a[35010],b[35010];
long long sum1[35010],sum2[35010];
int le[35010];//每个数最长的以其结尾的不下降子序列长度 
long long dp[35010];
int lin[35010],ln;//算最长不下降子序列所用序列 
vector<int> v[35010];
int main()
{
	int n;
	cin>>n;
	for (int i=1;i<=n;++i)
	{
		cin>>a[i];
		b[i]=a[i]-i;
		dp[i]=inf;
	}
	int pl;
	for (int i=1;i<=n;++i)
	{
		if (!ln||lin[ln-1]<=b[i])
		{
			lin[ln++]=b[i];
			v[ln].push_back(i);
			le[i]=ln;
		}
		else
		{
			pl=upper_bound(lin,lin+ln,b[i])-lin;
			lin[pl]=b[i];
			v[pl+1].push_back(i);
			le[i]=pl+1;
		}
	}
	cout<<n-ln<<endl;
	//第一问结束 
	
	v[0].push_back(0);
	b[0]=-200000;//虚拟b(0)
	le[n+1]=ln+1;
	b[n+1]=200000;
	dp[n+1]=inf;//虚拟b(n+1) 
	
	for (int j=1;j<=n+1;++j)//枚举j 
	for (int p=0;p<v[le[j]-1].size();++p)
	{
		int i=v[le[j]-1][p];//枚举i 
		if (i>j||b[i]>b[j])
		continue;
		
		sum1[i]=sum2[j]=0;
		for (int q=i+1;q<j;++q)
		sum1[q]=sum1[q-1]+abs(b[q]-b[i]);
		for (int q=j-1;q>i;--q)
		sum2[q]=sum2[q+1]+abs(b[q]-b[j]);
		//两个前缀和 
		
		long long ans=inf;
		for (int k=i;k<j;++k)
		ans=min(ans,sum1[k]+sum2[k+1]);
		dp[j]=min(dp[j],dp[i]+ans);
	}
	cout<<dp[n+1];
	//第二问结束 
	return 0;
}
```

---

## 作者：FlierKing (赞：39)

本题解由ydc神犇编写，因为原文为pdf，在此做个搬运。


## 1.前言

四月二十多号做的这道题了，当时正好是省选完挂，非常难过、心情沉重的刷着 bzoj 上第一版的题。在惊呼 HAOI 的水题堆后，迎来了这么一道在当时的我看来是个结论题的题，然后没怎么细想的就用结论过了这个题

今天苏雨翔找我问……我发现不记得了，于是翻以前的题解，终于搞懂了


## 2.第一问

直接做不好做，考虑补集转化，最大化不修改的点最多

假设 $a$ 是原数组，对于 $i$, $j$, $i < j$ 使得 $i$, $j$ 不被修改的必要条件是 $a_j - a_i \ge j - i$, 这样就能通过把中间 $j - i - 1$ 个数修改让他们严格递增，反之无解

于是一个 dp 方程跃然纸上，

$f(i) = max_{j=1}^{i-1} f(j)+1(a_i-a_j \ge i-j)$

$a_j-a_i \ge j-1 \Rightarrow a_j-j \ge a_i-i$，定义$b_i = a_i-i$，于是$b_j\ge b_i$

构造出$b$数组后，就成了求$b$的最长不下降子序列

第一问的答案就是$n-b$的最长不降子序列


## 3.第二问

题意要求，在满足第一问的前提下，要让变化的幅度最小

对于第一问，如果 $j$ 能转移到 $i$，则有 $f(j) + 1 = f(i)$，进行挂链后，假设$g(i)$ 表示 $1 ~ i$ 的答案，有

$g(i) = min_{f(j)+1=f(i)} g(j)+w(j+1,i)$

$w(j, i)$ 表示把 $[j, i]$ 变成合法的最小变化幅度

让 $a$ 数组单调递增，等价于让 $b$ 数组单调不降，考虑让 $b$ 数组单调不降的最小花费

由于有 $f(j) + 1 = f(i)$，所以 $\forall j < k < i, b_k \le b_j$ 或者 $b_i \le b_k$, 现在一个结论是， $w(j, i)$ 的方案，一定会以某个 $k$ 为分界使得 $[j,k]$ 均为 $b_j$ 且 $[k+1,i]$ 均为 $a_i$

试着证明一下

使用数学归纳法。

一两个数显然成立。

假设 k 个数，以下标为横坐标，最优方案下的 b 值为纵坐标，按照那个结

论分布好了，很像是一上一下两条水平线，左边一段在下面那根，右边一段在上面那根，现在冒出一个奇葩点 p，他在两个水平线之间

显然他的 a 值在上面的上方或下面的下方，接下来就是一堆分情况讨论的事情而已。首先他不能做在上面点和在下面点的临界点，不然的话他往上走或往下走总能找到更好地。也就是说，他现在要么夹在一坨在下方的点中间在他们上方，要么在一坨在上边界的点中间却在下方

两种情况很类似，讨论第一种即可。那么他一定会导致他右边这些在下方的点为了满足合法性不得不飞到他上面，由于这个点不在的时候是优方案，所以我们知道这右下方几个点往上跑 1 格会使变大。

既然这样的话，如果这个讨厌的点往下走会使花费变少，他肯定要往下走。

否则的话，就说明他往下走 x 格要增加 x 的花费。但是人多力量打，他走一格才一的花费，敌不过后面一坨点

其实这样算的话也是不全面的，因为后面这些点有可能随他乱动代价都一样，这时候大家都往上跑走到最最上面，花费还是变少了

于是皆大欢喜


---

## 作者：AlanSP (赞：21)

### Description

> 现在我们有一个长度为 n 的整数序列 a。但是它太不好看了，于是我们希望把它变成一个单调严格上升的序列。但是不希望改变过多的数，也不希望改变的幅度太大。计算最少需要改变多少个数和在改变的数最少的情况下，每个数改变的绝对值之和的最小值。

### Solution

对于第一问，我们考虑计算最多可以保留的数。

对于两个元素 $a[i],a[j]$ ，要同时保留i和j，首先要满足 $a[i]<a[j]$ 。

但还要保证中间的数能够改成单调上升的子序列，所以还要满足 $a[j]-a[i]\ge j-i$ 。 

移项，得 $a[j]-j\ge a[i]-i$  。

 那么可以构造一个b数组 $b[i]=a[i]-i$ ，对b数组求最长不降子序列。

---

对于第二问，我们可以发现可以通过记录上一问的子序列。

这些点把原来的a数组分成了多个区间，受到变化的就是区间中的元素。

可以注意到，两个端点间的数，没有数值处于两个端点间的。

因为加上中间的数，长度会更大。

这样，我们就会使一些数下降，一些数上升。

显而易见，最优策略一定是调整到他们与两个端点相等。

这样就能保证在a数组中是单调上升。

一个点的变化必定会牵动一系列点的上升（下降），所以我们可以想出这样的贪心：

**最优的方案一定是左端点连续的一个平台，到右端点连续的平台。**

![](https://cdn.luogu.com.cn/upload/image_hosting/ba3nfuiy.png)

之后可以记录前缀后缀和，dp即可。

### Code

```cpp
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<iostream>
using namespace std;
#define int long long
const int N=4e4+9,INF=0x3f3f3f3f;
int a[N],f[N],b[N],d[N],l[N],n,len=1,sum1[N],sum2[N];
vector<int> p[N];
signed main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]),b[i]=a[i]-i;
	d[1]=b[1];b[n+1]=INF;
	l[1]=1;
	p[1].push_back(1);
	for(int i=2;i<=n+1;i++)
	{
		if(d[len]<=b[i]) 
		{
			d[++len]=b[i];
			l[i]=len;
			p[len].push_back(i);
		}
		else
		{
			int pos=upper_bound(d+1,d+1+len,b[i])-d;
			d[pos]=b[i];
			l[i]=pos;
			p[pos].push_back(i);
		}
	}
	printf("%lld\n",n-len+1);//0 1 1 2 3 4
	p[0].push_back(0);
	b[0]=-INF;b[n+1]=INF;
	memset(f,INF,sizeof f);
	f[0]=0;
	for(int i=1;i<=n+1;i++)
	{
		for(auto j:p[l[i]-1])
		{//0 0 2 1 3 4
			// printf("%lld ",j);
			if(j>i||b[j]>b[i]) continue;
			sum1[j]=0;
			for(int k=j+1;k<=i-1;k++)
				sum1[k]=sum1[k-1]+abs(b[k]-b[j]);
			sum2[i-1]=0;
			for(int k=i-2;k>=j;k--)
				sum2[k]=sum2[k+1]+abs(b[k+1]-b[i]);
			for(int k=j;k<=i-1;k++)
				f[i]=min(f[i],f[j]+sum1[k]+sum2[k]);
		}
	}

	printf("%lld",f[n+1]);
	return 0;
}
```

一定要注意边界的判断，n+1赋值为INF，统计到末尾的段。

---

## 作者：NKU_AI_HMX (赞：17)

这篇题解主要是帮助大家理解证明，并对其他题解做出一些补充。
## 目录
1. 第一问证明
2. 第二问证明
3. 解题思路和注意事项


------------

## 正文
#### 1.第一问
如果两个点可以不被修改，那么它需要满足什么条件？这个其他每篇题解都有讲，而且很细致，结论就是：$a[j]-j\ge a[i]-i,(j>i)$ 然后我们令 $b[i]=a[i]-i$ 得到一个新数列，并且得到两个点可以不被修改的条件是 $b[j]\ge b[i],(j>i)$ 然后我们就直接得到了“求最长不降序列即可”。但是为啥呢？由于其他题解没说明，我这里来说一下：

我们知道我们一定有一个最大长度的不用被修改的序列，然后用总点数 $n$ 减去 $l$ 就得到了需要修改的点数 $n-l$，对于这个最大长度不用被修改的序列它既然不被修改，那就必然满足 $b[j]\ge b[i],(j>i)$ 也就是不降序列或者说单调递增。那这个序列不就是我们要找的最长不降序列么？而关于最长不降序列大家可以做这道题：
[导弹拦截](https://www.luogu.com.cn/problem/P1020)


------------

#### 2.第二问
我们假设 $i,j,(j>i)$ 分别为两个不被修改的相邻点，那么他们之间所有点必然要么高于 $j$ 要么低于 $i$。我们先对每个点分析，如果这个点高于 $j$ 我们最少把他移动到 $j$ 一样的高度就好了，这对他而言是最短距离。如果这个点低于 $i$ 那么我最少把他移动到 $i$ 一样的高度就好了，这对他而言是最短距离。不管实际应该怎么移动，实际移动一定是在这个移动的基础上再移动。

举个例子，就像我不管你出门去哪个地方，有多近多远，走哪条路，你一定要先出你家门，而我们刚刚假定的状态就是所有点移动的“门”，移动它必然会经过那个状态。

现在我们来用一个非常简单的思想来说一下为啥 $i,j$ 间的所有点最后可以移动到只有两个高度。（拒绝抽象的公式解释）

第一，我们知道不管对哪个点，把他移动到和 $i$ 或 $ j$ 一样高就是它的最优策略，那么它的最优策略可能对后面点的移动并不有利，所以有时候不是所有点都可以移动到他的最优策略，我们就有同学想那把他移动到中间某个位置($i,j$ 高度之间)。但是我们想想？为什么呢？为什么要这样移动呢？如果第一个这样移动的点高度比 $j$ 高，把它移动到中间确实委屈他了（如果比 $i$ 低直接移动到 $i$ 就最好），假如它后面的点高度依旧比 $j$ 高，那还得继续委屈，直到出现第一个高度比 $i$ 低的点，它为了移动的距离最少，并且还不增加序列高度，那他的最优策略就是移动的和前面一样高。但是那个点见了前面这些点这样弄就很奇怪，你们在搞屁呢？你们把高度降低到和 $i$ 一样那我可以移动的更少啊？如果你们把高度上升到和 $j$ 一样高你们不就不用委屈了呢？而且这些移动距离都是线性，一定是单调的呀！如果碰到这种情况，那我们移动到最下面或者最上一定有一个最优解，如果最下面是，那愉快的移过去，而且还可以降低高度，不用给后面的移动太大压力。如果上面是最优，那你就得考虑后面的移动了，毕竟你的最优导致后面的点都没有选择余地了。但是你应该知道距离是线性，如果你后面又是一个下面的点，你就又会面临上面所述的选择，如果接下来是上面的点，它要么和你移动的一样，要么移动到顶。但是如果它都到顶了，你移动到顶不也可以吗？那么最后我们就会得到一段在最低，一段最高的两个高度了（这里只模拟了一种情况，大家按照这个思路想想就可以）。


------------
#### 3.解题思路
思路大家已经知道了,我们找到最长不降序列,然后记录每个点结尾的序列的长度,和每个长度有几种结尾的点,(为后面做转移方程用)这个大家参考第一篇题解就好的,个人觉得这题不难在状态转移,转移方程:$f[i]=max(f[v]+suml[k]+sumr[k+1],f[i])$,
$v$满足条件$len[v]=len[i]-1$,$k$ 是 $v$,$i$ 之间的点。两个循环遍历就好，关于 $v$ 的储存用前向星或者 $vector$ 数组去 $push$ 都可,其他题解都有讲。这里注意一下前面状态转移的时候 $suml[k]$,$sumr[k+1]$ 的时候不要把交界点加重了。然后关于增加第 $0$ 个点和第 $n+1$ 个点方便处理前后点的一些操作第一篇题解都有，这里不详细叙述了。

代码的话，我就是跟着第一篇题解学的，除了符号不一样和一些地方风格换了一下，基本就没变了，看其他题解就好。（点赞再走吧！）




---

## 作者：nofind (赞：12)

题意:https://www.luogu.org/problem/P2501

很神的一道DP题

分别讨论第一问和第二问:

第一问:

正着求不好求不妨倒着求,求有最多有数不必修改

假设存在$i<j$,那么j不必被修改的条件就是$a[j]-a[i]>=j-i$

移项得:$a[j]-j>=a[i]-i$

于是设$b[i]=a[i]-i$,求出$b$的最长不下降子序列,用n减去它即为所求

第二问:

设第一问求出了$f[i]$表示以i结尾的最长不下降子序列长度

考虑在第一问求出了$f[i]$的基础上进行

设$g[i]$表示以i结尾的答案

$g[i]=min(g[j]+w(j+1,i))(j<i,f[j]+1==f[i])$

于是考虑如何求$w(j+1,i)$

结论:$[j,i]$会存在一个位置$k$,使得$[j,k]$全部为$b[j]$,$[k+1,i]$全部为$b[i]$,此时可以成为一个最优解

题解中有很详细的证明(https://www.luogu.org/blog/cicos/solution-p2501#),我按照我的理解再写一下

证明:

引理:

$b[i]<b[j]$,并且$b[k]<b[i]||b[k]>b[j],k\in[j+1,i-1]$

这个显然,不然$k$可以和$j$构成最长不下降子序列且可能更新$f[i]$

于是我们点的分布应该是这样的:

![](https://cdn.luogu.com.cn/upload/image_hosting/xpzmd1gd.png)

假设我们构造了一种方案如图:
![](https://cdn.luogu.com.cn/upload/image_hosting/l0f8h0rs.png)

我们将已经在同一高度的点连接起来,会形成一些线(单个点也是线),我们设$cnt1$表示这条线上相对原来位置下移的点的数量,$cnt2$表示这条线上相对原来位置上移的点的数量,对cnt1和cnt2分类讨论

cnt1>cnt2,如果我们将所有相对原来位置下移的点上移一格,那么调整的代价ans会$-cnt1$$+cnt2$,显然会使答案更优,而上移过程中可能出现两种情况：

<1>遇到了一条新的线:再次判断cnt1和cnt2的关系决定是上移还是下移

<2>遇到了$b[i]$,无法上移,停止

cnt1<cnt2 同上

cnt1=cnt2 这时同时移动到b[i]或者b[j]不会使代价ans产生变化

于是可以得出结论

code:
```
#include<bits/stdc++.h>
using namespace std;
#define int long long 
const int maxn=35010;
int n,cnt;
int head[maxn],a[maxn],b[maxn],f[maxn],g[maxn],sum1[maxn],sum2[maxn];
struct edge
{
	int to,nxt;
}e[maxn];
inline void add(int u,int v)
{
	e[++cnt].nxt=head[u];
	head[u]=cnt;
	e[cnt].to=v;
}
signed main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]),a[i]-=i;
	a[++n]=0x3f3f3f3f;a[0]=-0x3f3f3f3f;
	memset(b,0x3f,sizeof(b));b[0]=-0x3f3f3f3f,b[1]=a[1];
	int len=1;
	f[1]=1; 
	for(int i=2;i<=n;i++)
	{
		int tmp=upper_bound(b,b+len+1,a[i])-b;
		len=max(len,tmp);
		f[i]=tmp;
		b[tmp]=min(b[tmp],a[i]);
	}
	printf("%lld\n",n-f[n]);
	for(int i=0;i<=n;i++)add(f[i],i);//加边是为了之后找满足f[j]+1=f[i]的j方便 
	/*for(int i=0;i<=n;i++)printf("%d ",f[i]);
	puts("");*/
	memset(g,0x3f,sizeof(g));g[0]=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=head[f[i]-1];j;j=e[j].nxt)
		{
			int y=e[j].to;
			if(y>i||a[y]>a[i])continue;
			for(int k=y;k<=i;k++)sum1[k]=abs(a[k]-a[y]),sum2[k]=abs(a[k]-a[i]);
			for(int k=y+1;k<=i;k++)sum1[k]+=sum1[k-1],sum2[k]+=sum2[k-1];
			for(int k=y;k<=i-1;k++)g[i]=min(g[i],g[y]+sum1[k]-sum1[y]+sum2[i]-sum2[k]);
		}
	}
	printf("%lld",g[n]);
	return 0;
} 
```


---

## 作者：Huami360 (赞：10)

真是道毒题。
看题解看了2个多小时才看懂，还是对着代码模拟，如图QAQ
![](https://cdn.luogu.com.cn/upload/pic/20461.png)

楼下紫名大佬发的题解似乎是对大牛写的，我写个通俗易懂的题解，同时附上代码，代码很精巧，不会有太多的解释，建议模拟模拟，理解它。

**首先，第一问**

直接做不太好做，可以考虑把求最少改动的改为求最多不改动的。

我们用a数组存储n个数，当a[i]和a[j] (i<j)不需要改动时，肯定满足a[j]-a[i]>=j-i , 这个很好理解，a[i],a[j]中间的数至少要比上一个数多1，移项可得a[j]-j>=a[i]-i , 于是可以直接把每个数减去他的位置，即a[i]-=i; 然后求最长不下降子序列就可以了。

**~~复杂的~~第二问**

我们用f[i]表示前i个数要达到单调上升最少改动的幅度（最后答案为f[n]）.


**【中心思想】**：若a[i],a[j] (i<j) 满足 a[j]-a[i]>=j-i , 那么[i,j]中一定存在一个k,使a[i ~ k]都变成a[i],a[k+1 ~ j]都变成a[j]时，a[i~j]单调上升且代价最小，这个其实可以想出个所以然，但严格的数学证明还是要参考楼下ydc神犇。至于这个k , 直接枚举即可 。 理论时间复杂度为O(n^3) ， 但实际远达不到 ， 加上数据随机 ， 是可以水过的。

好吧，上代码，给少量注释，更多的希望读者自行理解。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>
#include <set>
#include <map>
#include <vector>
#include <stack>
#include <list>
#define rep(i,m,n) for(int i=m;i<=n;++i)
#define dop(i,m,n) for(int i=m;i>=n;--i)
#define each(i,m,v) for(int i=head[m],v=e[i].to;i;i=e[i].next,v=e[i].to)
#define lowbit(x) (x&(-x))
#define ll long long
#define INF 1073741824
#define re register
using namespace std;
inline int read(){
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}                       //以上一大堆废话
const int maxn=35010;
int n,a[maxn],c[maxn],dp[maxn],len,tmp,num,head[maxn];
ll f[maxn],sum1[maxn],sum2[maxn];   //要开long long寸不然炸
struct Edge{
    int to,next;
}e[maxn];
void Add(int from,int to){
    e[++num].to=to;
    e[num].next=head[from];
    head[from]=num;
}                       //邻接表
int main(){
	n=read();
	rep(i,1,n) a[i]=read()-i;
	rep(i,1,n) c[i]=INF;
	c[0]=-INF;dp[1]=1;len=1;a[++n]=INF;c[1]=a[1];a[0]=-INF;
	rep(i,2,n){  //仔细思考这个循环，c是一个单调上升的数组，dp[i]表示什么？
       tmp=upper_bound(c,c+1+len,a[i])-c;
       len=max(len,tmp);
       dp[i]=tmp;
       c[tmp]=min(c[tmp],a[i]);
    }
    printf("%d\n",n-dp[n]);
    dop(i,n,0) Add(dp[i],i),f[i]=INF;f[0]=0; //f的意义如上，想想这个连边的意义
    rep(i,1,n)
       each(j,dp[i]-1,to){
          if(to>i) break;
          if(a[to]>a[i]) continue;
          rep(k,to,i) sum1[k]=abs(a[k]-a[to]),sum2[k]=abs(a[k]-a[i]);
          rep(k,to+1,i) sum1[k]+=sum1[k-1],sum2[k]+=sum2[k-1];  //前缀和
          rep(k,to,i-1) f[i]=min(f[i],f[to]+sum1[k]-sum1[to]+sum2[i]-sum2[k]);  //想想前面的【中心思想】
       }
    printf("%lld\n",f[n]);
    return 0;
}

```

---

## 作者：FlyInTheSky (赞：5)

 [$$ \Large \texttt{My Blog} $$](http://blog.flyinthesky.win/bzoj1049/)

------------

题意：现在我们有一个长度为$n$的整数序列$A$。但是它太不好看了，于是我们希望把它变成一个单调严格上升的序列。但是不希望改变过多的数，也不希望改变的幅度太大。

第一问即经典问题。考虑不严格上升的序列，则为**$n-LIS$**，(这里的$LIS$为不下降的)
严格上升，则说明$i-j \geq a_i-a_j$，不然这个区间不可能严格上升。

移项，则$i-a_i \geq j-a_j$，那么将原来的$a_i$变为$a_i-i$按照同样方法处理即可。

对于第二问，我们设$f(i)$为$[1,i]$的答案，则
$$f(i)=\max\limits_{dp(j)+1=dp(i)}(f(j)+w(j+1,i))$$
那么我们怎么计算$w$呢
我们可以发现对于任意区间$[i,j]$都$\exists k$使得$[i,k]=a_i$, $[k+1,j]=a_j$，并且一定$\exists k$使得其为最优策略
那么对于每个$w$暴力$k$的位置。**由于数据随机**，所以$i$的的决策点$j$很少，复杂度跑不满

注意代码细节，加上前后最小值最大值方便操作

```c++
#include<cstdio> 
#include<cstring>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<map>
#include<vector>
#define ms(i, j) memset(i, j, sizeof i)
#define LL long long
#define db long double
#define fir first
#define sec second
#define mp make_pair
using namespace std;

namespace flyinthesky {

    const LL MAXN = 35000 + 10, INF = 1e10;
    
    LL n, a[MAXN], b[MAXN], len;
    LL dp[MAXN], f[MAXN], cst1[MAXN], cst2[MAXN];
    vector<LL > vec[MAXN];
    
    LL abss(LL x) {return x > 0 ? x : -x;}

    void clean() {
    	len = 0;
    }
    int solve() {

    	clean();
    	cin >> n;
    	for (LL i = 1; i <= n; ++i) scanf("%lld", &a[i]), a[i] -= i;
    	++n, a[n] = INF;
    	
    	b[++len] = a[1], dp[1] = 1;
    	for (LL i = 2; i <= n; ++i) {
    		if (a[i] >= b[len]) b[++len] = a[i], dp[i] = len;
    		else {
    			int pos = upper_bound(b + 1, b + 1 + len, a[i]) - b; // 1 upper_bound
    			b[pos] = a[i], dp[i] = pos;
            }
        }
        printf("%lld\n", n - len);
        
        a[0] = -INF;
        vec[0].push_back(0);
        for (LL i = 1; i <= n; ++i) {
            f[i] = INF;
            for (LL j = 0; j < (LL)vec[dp[i] - 1].size(); ++j) {
                LL v = vec[dp[i] - 1][j];
                if (a[v] > a[i]) continue ;
                cst1[v - 1] = cst2[v - 1] = 0;
                for (LL k = v; k <= i; ++k) cst1[k] = abss(a[k] - a[v]), cst2[k] = abss(a[k] - a[i]);
                for (LL k = v + 1; k <= i; ++k) cst1[k] += cst1[k - 1], cst2[k] += cst2[k - 1];
                for (LL k = v; k <= i; ++k) {
                    LL now = cst1[k] - cst1[v] + cst2[i] - cst2[k]; 
                    f[i] = min(f[i], f[v] + now);
                }
            }
            vec[dp[i]].push_back(i);
        }
        
        printf("%lld\n", f[n]);
        
        return 0;
    }
}
int main() {
    flyinthesky::solve();
    return 0;
}
```

---

## 作者：pkh68 (赞：5)


下面主要是给出一个第二问结论的个人觉得严密的证明，如有错误，请各位大佬指出。

### 解析

#### 第一问

直接做不好做，考虑反面转换，于是问题变成最大化不修改的点数。

设$f(i)$，那么对于$j$，$i$，$i$点不修改的条件是$a_{i}-a_{j}\geq i-j$，因为这样可以通过修改中间的数来使数列满足条件。

于是有:$f(i)=max_{a_{i}-a_{j} \geq i-j}f(j)+1$

考虑移项：$a_{i}-i \geq a_{j}-j$，设$b_{i}=a_{i}-i$，那么问题就变成了求最长不下降子序列。

#### 第二问

设$g(i)$，那么有：$g(i)=min_{f(j)+1=f(i)}g(j)+w(j,i-1)$。

考虑$w$的取值，那么数组$a$单调递增等价于$b$单调不降。

结论：修改区间$[j,i]$的最优方式一定是前一半变为$b_{j}$，后一半变为$b_{i}$。

证明：考虑用数学归纳法：

设命题$P(n)$，那么$P(1)$显然成立，因为如果把其修改为中间值，肯定不如修改为两个端点值。

现设命题$P(n)$成立，证命题$P(n+1)$成立。

考虑最后一个数的放法，由设知：

case1.前$n$个数一半下一半上

1.$b_{n}>b_{i}$，显然修改为$b_{i}$最优秀。

2.$b_{n}<b_{j}$，设不修改为$b_{i}$，则代价：

$x \times (b_{i}-b_{n})+val_{n} \geq val_{n}+b_{i}-b_{n}$

case2.前n个数全下

修改为$b_{j}$显然最优秀。

枚举分界点即可。

### 代码如下

```cpp

#include<cstdio>
#include<cstring>
#define re register
#define N 35005
#define LL long long
using namespace std;
const int INF=0x7fffffff;
int n,f[N],len=0,head[N],list_tot=0,b[N],t[N];
LL g[N],disL[N],disR[N];
struct List{ int to,next; }list[N];
inline LL min(LL a,LL b){ return a<b?a:b; }
inline LL abss(LL x){ return x>0?x:(-x); }
inline void add(int u,int v){ list[++list_tot]=(List){v,head[u]}; head[u]=list_tot; }
int main(){
    scanf("%d",&n);
    for(re int i=1,x;i<=n;++i) scanf("%d",&x),b[i]=x-i; b[n+1]=INF;
    for(re int i=1;i<=n+1;++i){
    	int l=0,r=len,mid;
        while(l<r){
            mid=(l+r+1)>>1;
            if(t[mid]<=b[i]) l=mid;
            else r=mid-1;
        }
		if(l==len) ++len;
		t[l+1]=b[i]; f[i]=l+1;
    }
    b[0]=-INF; memset(g,20,sizeof(g));
    add(0,0); g[0]=0; for(re int i=1;i<=n;++i) add(f[i],i);
    for(re int u=1;u<=n+1;++u){
        for(re int i=head[f[u]-1];i;i=list[i].next){
            int v=list[i].to; if(v>=u||b[v]>b[u]) continue;
            disL[v-1]=0; for(re int j=v;j<=u;++j) disL[j]=disL[j-1]+abss(b[j]-b[v]);
            disR[v-1]=0; for(re int j=v;j<=u;++j) disR[j]=disR[j-1]+abss(b[j]-b[u]);
            for(re int j=v-1;j<=u;++j) g[u]=min(g[u],g[v]+disL[j]-disL[v-1]+disR[u]-disR[j]);
        }
    }
    printf("%d\n%lld\n",n-len+1,g[n+1]);
    return 0;
}
```


---

## 作者：smzzl (赞：5)

这里分享一个**第一问**的解法

本蒟蒻想不到这种做法下的第二问解法（只想到n^3的）。

欢迎各dalao在评论区反应，欢迎dalao分享在我这个第一问思路基础上的第二问解法（或者第一问的优化到nlogn方式）。

本算法是一个很不优秀的做法，但是没有看到题解里有这种做法的，想和大家分享一下。

 _以下是我第一问思路_
 
 设 _**d[i][k]**_ 表示在第 _i_ 位时候，使用 _k_ 次修改的最小末尾，于是就有了一个转移方程：
 
 1：_d[i][k]=a[i] (a[i]>d[i-1][k])_
 
 2: _d[i][k]=d[i-1][k-1]+1 (k>=1)_
 
 1，2两式子取min
 
 方程解释：
 
 对于1表示如果这位原数的值大于了上一位修改k次的最小末尾，那么这一位就可以不花代价的直接填下。
 
 对于2表示把这位的数值调到最接近上一位最小数值的值（上一位的值+1，以保证严格上升）（贪心思想：对于每个k，末尾一定是越小越好）
 
 于是第一问就做完了，时间复杂度为接近n^2，6000稳过，由于常数小在开启o2后能够通过所有点的第一问。
 
 以下是我的代码，欢迎dalao们指出错误。
 
 ```
#include<iostream>
#define inf 99999999999
using namespace std;
long long n;
long long a[200005],d[2][35002];//滚动数组

inline long long _min(long long a1,long long a2){return (a1<a2)?a1:a2;}
int main()
{
    cin>>n;
    for (long long i=1;i<=n;i++) cin>>a[i];
    d[0&1][0]=-inf; d[0][1]=inf;//初值 
    
    for (long long i=1;i<=n;i++)
        {
            for (long long k=0;k<=i;k++) d[i&1][k]=inf;
            //初始化无穷大 
            if (d[(i-1)&1][0]<a[i]) d[i&1][0]=a[i];
            //对于k=0由于不能执行转移2，于是我们先做掉 
            for (long long k=1;k<=i;k++) {
                if (a[i]>d[(i-1)&1][k]) d[i&1][k]=a[i];//转移1 
                d[i&1][k]=_min(d[i&1][k],(d[(i-1)&1][k-1])+1);//转移2 
            }
            
        }
    long long ans=inf;	
	for (long long k=0;k<=35002;k++) 
        if (d[n&1][k]<inf) {ans=k; break;}
    //找到一个不是inf的就是解 
    cout<<ans;
}
```
 

---

## 作者：pyyyyyy (赞：3)

[$\large\text{博客食用效果更佳}$](https://www.cnblogs.com/pyyyyyy/p/13151117.html)
### 题意

[P2501 [HAOI2006]数字序列](https://www.luogu.com.cn/problem/P2501)

> 给定一个$n$个数的序列，问最少改变多少个数能让它变成一个单调严格上升的序列，且让每个数改变的绝对值之和最小，输出个数和最小值
>
> $1\le n\le3.5*10^4,1\le a_i\le 10^5$

### 思路

- $Problem\ 1$

看~~懂~~题目之后，淦，这什么东西啊

我陷入了满足的数应该被改变的思考中......嗯，想不出来

正着想不出来可以反着想，考虑满足什么条件的数应该被保留

如果$a[i]$和$a[j]$之间的数本身合法或者能被改成合法的那么它们就是应该被保留的

容易得出满足$a[j]-a[i]\ge j-i$

即$a[j]-j\ge a[i]-i$

显然，可以令$b[i]=a[i]-i$，然后求$b$的最大不下降子序列(因为条件是$\ge$)的长度$len$，$n-len$即为第一问答案

- $Problem\ 2$

我们继续在$b$上考虑，对于一对被保留的点$b[i]$和$b[j]$，他们之间的数一定都是不合法

现在的问题就在于如何把这些数都改变才能使改变量最小

**一个结论**

> 设分界点为$k$，则对于左边$b[l] \to b[i],l\in[i,k]$对于右边$b[r]\to b[j],r\in [k+1,j]$

证明的话就不写了，~~我也不会~~

设$g[i]$表示$[1,i]$的在改变次数最小时最小改变量之和

$g[i]=\min(g[j]+w(j+1,i))$

根据上面的结论可以通过前缀和和后缀和来优化求$w(j+1,i)$的过程

复杂度为$O(n^2+nlogn)$，期望得分：$100$

```cpp
/*
@ author:pyyyyyy/guhl37
-----思路------

-----debug-------

*/
#include<bits/stdc++.h>
#include<algorithm>
#define int long long 
using namespace std;
const int N=35005;
const int M=200005;
struct node
{
	int Next,to;
}e[N<<1]; 
int head[N],cnt;
void add(int u,int v)
{
	e[++cnt].Next=head[u];
	head[u]=cnt;
	e[cnt].to=v;
}
int n,a[N],f[N],g[N],pre[N],suf[N];
int st[N],top;
void solve1()
{
	f[0]=0;a[0]=-0x3f3f3f;a[++n]=0x3f3f3f;
	f[1]=1;st[1]=a[1];top=1;
	for(int i=2;i<=n;++i)
	{
		if(st[top]<=a[i]) st[++top]=a[i],f[i]=top;
		else 
		{
			int tmp=upper_bound(st+1,st+1+top,a[i])-st;
			st[tmp]=a[i];f[i]=tmp;
		}
	}
	cout<<n-f[n]<<'\n';
}
void solve2()
{
	memset(g,0x3f3f3f,sizeof(g));g[0]=0;
	for(int i=0;i<=n;++i) add(f[i],i);//注意这里要从f[0]开始建立映射 
	for(int i=1;i<=n;++i)
	{
		for(int j=head[f[i]-1];j;j=e[j].Next)
		{
			int to=e[j].to;
			if(to>i||a[to]>a[i]) continue;
			for(int k=to;k<=i;++k) pre[k]=abs(a[k]-a[to]),suf[k]=abs(a[k]-a[i]);
			for(int k=to;k<=i;++k) pre[k]+=pre[k-1],suf[k]+=suf[k-1];
			for(int k=to;k<i;++k) g[i]=min(g[i],g[to]+pre[k]-pre[to]+suf[i]-suf[k]); 
		}
	}
	cout<<g[n]<<'\n';
}
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	cin>>n;
	for(int i=1;i<=n;++i) scanf("%lld",&a[i]),a[i]-=i;
	solve1();
	solve2();
	return 0;
}
```


---

## 作者：BelowHorizon (赞：2)

第一问很经典。考虑两个数 $a_i,a_j$ ，其中 $j>i$ 什么时候可以不用被改变，当 $a_j-a_i\geq j-i$ 时。移项得到 $a_j-j\geq a_i-i$ 。即求出 $a_i-i$ 的最长不下降子序列。就是答案。时间复杂度 $O(n\log n)$ 。

第二问很经典。考虑到两个已经求得的最长不下降子序列中的数 $a_i,a_j$ 。最优的答案一定是在它们两中间找到一个断点 $x$ ， $(i,x]$ 中的数全部变为   $a_i$ , $(x,j)$ 中的数全部变为 $a_j$ 。于是枚举这个断点就可以了。时间复杂度是 $O(n^2)$ 的。但实际上远小于 $O(n^2)$ 。况且数据保证随机，所以这可以算得上是一个正确的算法。

注意：其实上面考虑不完全，有可能会有多个最长不下降子序列，如果枚举的话时间复杂度可能变为 $O(3^{n/3})$ ，明显不行。所以在第一问时维护每一个点可以从那些点转移过来。中间把数变为 $a_i,a_j$ 产生的价值可以预处理出来是 $O(n^2)$ 的。所以以上第二问的时间复杂度是 $O(n^2)$ 的。



---


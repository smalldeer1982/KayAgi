# [HAOI2010] 订货

## 题目描述

某公司估计市场在第 $i$ 个月对某产品的需求量为 $U_i$，已知在第 $i$ 月该产品的订货单价为 $d_i$，上个月月底未销完的单位产品要付存贮费用 $m$，假定第一月月初的库存量为 $0$，第 $n$ 月月底的库存量也为 $0$，问如何安排这 $n$ 个月订购计划，才能使成本最低？每月月初订购，订购后产品立即到货，进库并供应市场，于当月被售掉则不必付存贮费。假设仓库容量为 $S$。

## 样例 #1

### 输入

```
3 1 1000
2 4 8
1 2 4 ```

### 输出

```
34```

# 题解

## 作者：interestingLSY (赞：38)

这道题应该有以下几种做法：

- 贪心
- 费用流
- dp

# 现在我要讲讲dp做法！

---

## 状态？

令 ${\color{blue} { dp_{i,j} }}$ 表示第 $i$ 个月,**卖之后**库中还有 $j$ 包辣条 ( 辣条什么鬼0v0 ) 的最小花费

注意一定是**卖之后**

---

## 状态转移？

假设我们现在要处理的状态为 ${\color{blue} { dp_{i,j} }}$

假设第 $i-1$ 个月卖完后还有 $k$ 包辣条，那么我们可以知道第 $i$ 个月买了 ${\color{blue}{j+U_i-k}}$ 包辣条（想想为啥？）

也就是说我们需要多花 ${\color{blue}{(j+U_i-k)\cdot D_i\ +\ k \cdot m}}$ 元。

很自然，方程出来了：

${\color{red}{ dp_{i,j} \ = \ min \left\{\ dp_{i-1,k}+(j+U_i-k)\cdot D_i\ +\ k \cdot m  \right\} }}$
$(\ 0 \leq k \leq min(j+U_i,S)\ )$

---

## 然而。。。

黑恶势力登场.jpg

这样dp的话，状态数为 $O(nS)$ 转移复杂度为 $O(S)$ 总体复杂度为 $O(nS^2)$ 最坏情况下为 $5 \times 10^9$。。。

---

## 别放弃啊咱们一起优化

提出常数项后方程式变为:

$\color{red} dp_{i,j} \ = \ \color{green}min \left\{\ dp_{i-1,k}-k\cdot D_i\ +\ k \cdot m  \right\}\color{red}\ +\ (j+U_i)\cdot D_i $
$(\ 0 \leq k \leq min(j+U_i,S)\ )$

注意到原谅色的那部分了吗？没错，你会发现那个式子与 $j$ 无关！而正是那个式子占用了 $O(S)$ 的复杂度！

下面为了表述方便，我们设

$\color{blue}F_{i,k}\ = \ dp_{i-1,k}-k\cdot D_i\ +\ k \cdot m$

$\color{red}M_{i,j}\ = \ min\left\{ F_{i,z}\right\}\ (0 \leq z \leq j)$

这样方程式就等价于

$dp_{i,j}\ =\ \color{red}M_{i,j} \color{black}+(j+U_i)\cdot D_i$

.

.

再观察 $\color{red}M_{i,j}$ ,可以发现它的另一种表示方法：

$\color{red}M_{i,j}\ =\ min(M_{i,j-1},F_{i,j})$ $(j \neq 0)$

$\color{red}M_{i,j}\ =\ F_{i,j}$ $(j = 0)$


所以你发现了什么？若把 $\color{red}M_{i,j}$ 的值存起来，我们可以在 $O(1)$ 的时间内求出 $\color{red}M_{i,j}$

总复杂度就变成了 $O(nS)$

----

## 再多说两句：

你发没发现，我这种做法其实是**两个dp**!!

其中一个用于计算 $\color{red}M_{i,j}$

另一个用于计算 ${\color{blue} { dp_{i,j} }}$

怎样，妙不妙！

---

## 好了上代码！

```cpp
#include <bits/stdc++.h>
#define INF (0x3f3f3f3f)
#define ll long long
#define Ms(_data) memset(_data,0,sizeof(_data))
#define Msn(_data,_num) memset(_data,_num,sizeof(_data))
using namespace std;
#define Mymax(a,b) if(a<b) a = b;
#define Mymin(a,b) if(a>b) a = b;
#define il inline
#define rg register
#define For(i,j) for( rg int (i) = 1 ; (i) <= (j) ; (i)++ )
#define For0(i,j) for( rg int (i) = 0 ; (i) < (j) ; (i)++ )
#define Forx(i,j,k) for( rg int (i) = (j) ; (i) <= (k) ; (i)++ )
#define Forstep(i,j,k,st) for( rg int (i) = (j) ; (i) <= (k) ; (i) += (st) )
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
#define MAXN 60
#define MAXS 10010
int n,m,s;
int u[MAXN], d[MAXN];

int dp[MAXN][MAXS];
int mintmp[MAXN][MAXS];
// dp[i][j] 表示第i个月,卖之后库存为j的最小花费

il int F( int i , int k ){
	return dp[i-1][k] + k*m - k*d[i];
}
il void M( int i , int k ){
	if( k == 0 ) mintmp[i][k] = F(i,k);
	else mintmp[i][k] = min(mintmp[i][k-1],F(i,k));
}
il void Pre( int i ){
	Forx(j,0,s)
		M(i,j);
}

int main(){
	Msn(dp,INF);
	Msn(mintmp,INF);

	scanf("%d%d%d",&n,&m,&s);
	For(i,n) scanf("%d",&u[i]);
	For(i,n) scanf("%d",&d[i]);

	dp[0][0] = 0;
	For(i,n){
		Pre(i);
		For0(j,s+1){
			int klimit = min(j+u[i],s);
			dp[i][j] = mintmp[i][klimit] + (j+u[i])*d[i];
		}
	}

	int ans = dp[n][0];
	printf("%d\n",ans);

	return 0;
}
```

## 如果感觉题解有问题(包括但不限于错别字、程序有bug、式子打错了、我长得丑)，一定要在评论区提出！

~~没有问题就给个赞awa~~

### 顺便问一句dalao们觉得Latex用哪种配色最好看？我感觉红蓝比较好

---

## 作者：qwqKanade (赞：20)

~~既然 **洛谷博客** 正式发布了，那我就来发一波题解吧（逃）~~


通过读题，我们发现有**成本（费用）**、**货物数（流量）**、 **仓库容量（容量）**等相关量，就能想到这题是一道**费用流**（~~如果这么明显还想不到，那我也帮不了你~~）。虽然这题比较裸，但对于网络流问题来说，~~**建图**才是真正精髓的地方~~。


1. 首先我们知道，每月都可以进货，并且不限数量，所以我们就**从源点向表示每个月的点连一条容量为正无穷，费用为订货单价的边**。不理解的话可以~~把源点抽象为一家生产产品的工厂~~，这样应该好理解许多。


1. 由于**仓库容量**和**存贮费用**的存在，我们就会自然的想到**在相邻的月之间连一条费用为\*存贮费用\*，容量为\*仓库容量\*的边**，这是没有问题的。


1. 仅仅这样是~~不够~~的，我们还需要模拟出货物出售的情况，因为出售不需要成本（~~这不是废话吗~~），所以要**从表示每个月的点向汇点**（~~可以想象成消费者~~）**连一条容量为\*需求量\*，费用为 \*0\* 的边**。这样为什么可以保证这些边的**实际流量**一定等于**需求量**呢？因为**源点向表示每个月的点流入的流量理论上可以是正无穷，故要满足最大流的性质，表示每个月的点与汇点之间的边必定满流**，原命题得证。


1. 然后就可以跑**裸的费用流**了...


朴素SPFA増广费用流即可 **0ms**（~~**n<=50是闹哪样...**~~），代码如下：




```cpp
    #include<cstdio>
    #include<cstring>
    #include<queue>
    using namespace std;
    int head[53],pre[53],dist[53],cnt,flow,cost;
    bool used[53];
    struct edge{
        int from,to,cap,flow,cost,next;
    }e[301];
    queue<int>q;  //我就用STL啦啦啦
    inline int read(){  //并没有什么卵用的快读
        char ch=getchar();
        int x=0,f=1;
        while(ch<'0'||ch>'9'){
            if(ch=='-') f=-1;
            ch=getchar();
        }
        while('0'<=ch&&ch<='9'){
            x=(x<<3)+(x<<1)+(ch^48);
            ch=getchar();
        }
        return x*f;
    }
    inline void add(int u,int v,int w,int c){
        edge e1={u,v,w,0,c,head[u]};
        e[cnt]=e1;
        head[u]=cnt++;
        edge e2={v,u,0,0,-c,head[v]};
        e[cnt]=e2;
        head[v]=cnt++;
        return;
    }
    inline bool spfa(int s,int t){
        memset(dist,0x3f,sizeof(dist));
        memset(used,0,sizeof(used));
        memset(pre,-1,sizeof(pre));
        dist[s]=0;
        used[s]=1;
        q.push(s);
        while(!q.empty()){
            int u=q.front();
            q.pop();
            used[u]=0;
            for(int i=head[u];i!=-1;i=e[i].next){
            if(dist[e[i].to]>dist[u]+e[i].cost&&e[i].cap>e[i].flow){
                    dist[e[i].to]=dist[u]+e[i].cost;
                    pre[e[i].to]=i;
                    if(!used[e[i].to]){
                        used[e[i].to]=1;
                        q.push(e[i].to);
                    }
                }
            }
        }
        return pre[t]!=-1;
    }
    void mcmf(int s,int t){
        while(spfa(s,t)){
            int minn=0x3fffffff;
            for(int i=pre[t];i!=-1;i=pre[e[i^1].to])
                minn=min(minn,e[i].cap-e[i].flow);
            for(int i=pre[t];i!=-1;i=pre[e[i^1].to]){
                e[i].flow+=minn;
                e[i^1].flow-=minn;
                cost+=e[i].cost*minn;
            }
            flow+=minn;
        }
        return;
    }
    int main(){
        int n,m,s,x;
        n=read(),m=read(),s=read();
        memset(head,-1,sizeof(head));
        for(int i=1;i<=n;i++){
            x=read();
            add(i,n+1,x,0);  //建图步骤3.
        }
        for(int i=1;i<=n;i++){
            x=read();
            add(0,i,0x3fffffff,x);  //建图步骤1.
        }
        for(int i=1;i<n;i++) add(i,i+1,s,m);  //建图步骤2.
        mcmf(0,n+1);  //好裸啊
        printf("%d\n",cost);
        return 0;
    }
```
~~**%%%楼下贪心大佬%%%（我好蒻啊）**~~

---

## 作者：ysner (赞：11)

这个奇妙的想法发源于一位不知道费用流的蒟蒻与一道费用流大火题的碰撞之中,我惊讶地发现,用贪心乱搞也能达到0ms,且代码量大大小于费用流.

**step1:**对于一个日子,它可以从之前任意一天购买,并且还收到容量的限制。一个很自然

的想法就是贪心,每次选择能够选择的日期中价格最小的天来购买。

**step2:**所以我们考虑按照购买日期维护一个单调队列,单调队列的元素是价格递增的。每

次能够选取的价格最小的日期就对应着单调队列的队首元素。从队首购买水会导致队列

中所有元素的可用容量都变小。接下来我们只需要把队列中所有元素的可用容量全部减

去当前使用数量。

从这里可以顺便看出单调队列中的元素的容量是单调递增的,每次我们贪心地取队

首元素,如果发现队首元素容量为0就把它删除,每一天过完后就暴力把队列中所有元

素的费用增加。

每次修改复杂度是O(n)的,共购买n天,复杂度O(n 2 )

**step3:**然后我们发现单调队列需要支持的操作是:整体加减、单点插入删除。我们可以维护一

个lazy标记,这样就可以把修改的复杂度降到O(1)。总复杂度O(n)

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#define ll long long
#define re register
#define il inline
#define fp(i,a,b) for(re int i=a;i<=b;i++)
#define fq(i,a,b) for(re int i=a;i>=b;i--)
using namespace std;
const int N=10005;
il ll gi()
{
    re ll x=0;
    re int t=1;
    re char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
    if(ch=='-') t=-1,ch=getchar();
    while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
    return x*t;
}
ll d[N],p[N],q[N],w[N];//q里存位置,位置的价格单调递增
int main()
{
    int n=gi(),m=gi(),v=gi(),i,l,mid,r,top=0;
    ll ans=0,dt=0,s,dn=0;//dt,dn是两个lazy标记
    fp(i,1,n) d[i]=gi();//对产品需求量
    fp(i,1,n) p[i]=gi();//订货单价
    l=1,r=0;
    for (i=1;i<=n;i++)
    {
        while (l<=r&&p[i]-dt<=p[q[r]]) r--;
        s=d[i];
        while (l<=r)
            if (s<w[q[l]]-dn)
            {
                ans+=(p[q[l]]+dt)*s,dn+=s,s=0;//dt为积下的存储费用
                break;
            }
            else
            {
                ans+=(p[q[l]]+dt)*(w[q[l]]-dn);
                s-=w[q[l]]-dn,dn+=w[q[l++]]-dn;//dn为当前已使用的容量
            }
        ans+=1LL*s*p[i];
        q[++r]=i,w[i]=v+dn,p[i]-=dt;
        dt+=m;
    }
    printf("%lld\n",ans);
    return 0;
}

```

---

## 作者：robin12138 (赞：7)


## **DP做法**

### 这道题的做法很多，但是我认为~~~其他题解讲的不是很具体~~~

### 我就来讲一下我思考的过程吧qwq

#### 挂一下**blog** [孑行](https://www.cnblogs.com/wmq12138/p/11210138.html)

#### 方程还是比较好列的：设$F[i,j]$表示前i个月的任务完成后仓库里剩余的货物量为$j$时的最小花费

#### 则有方程：
$F[i,j]=min\{F[i-1,k]+m*k+d[i]*(j+u[i]-k)\},k\leqslant j+u[i]$

#### 其中$m*k$为囤积货物的费用，$j+u[i]-k$为这个月新买的货物

#### 但是这样是$O(n*S^2)$的，需要优化：

#### 把与k有关的项提出来，方程化为：
$F[i,j]=min\{F[i-1,k]+(m-d[i])*k\}+d[i]*(j+u[i]),k\leqslant min(j+u[i],s)$

#### 我们可以先不管与k无关的项，最后再加上即可，先记为：
$F[i,j]=min\{F[i-1,k]+(m-d[i])*k\},k\leqslant min(j+u[i],s)$

#### 再写出$F[i,j-1]$的表达式：
$F[i,j-1]=min\{F[i-1,k]+(m-d[i])*k\},k\leqslant min(j+u[i]-1,s)$
#### 便可以发现，$j$每增大$1$，$F[i,j]$的取值范围只比$F[i,j-1]$的取值范围大了$1$，那么我们可以将方程化简为：
$F[i,j]=min(F[i,j-1],F[i,j+u[i]]+(j+u[i])*m-d[i]*(u[i]+j))$
#### 显然 $j=0$的时候需要枚举$k$算一下

#### $PS：$注意判断一下$j+u[i]$有没有超出边界

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <vector>
#include <cctype>
#include <queue>
#include <stack>
#include <map>
#include <set>
using namespace std;

#define inf 0x3f3f3f3f
typedef long long LL;
#define il inline

il int read(int x=0,int f=1,char ch='0')
{
    while(!isdigit(ch=getchar())) if(ch=='-') f=-1;
    while(isdigit(ch)) x=x*10+ch-'0',ch=getchar();
    return f*x;
}

//f[i][j] :前i个月剩余的货物量为j时的最小花费
//f[i][j]=min{f[i-1][k]+m*k+d[i]*(j+u[i]-k)},k<=j+u[i]

//f[i][j]=min{f[i-1][k]+(m-d[i])*k},k<=min(j+u[i],s)
//f[i][j-1]=min{f[i-1][k]+(m-d[i])*k},k<=min(j+u[i]-1,s)

//f[i][j]=min(f[i][j-1],f[i-1][j+u[i]]+(j+u[i])*m-d[i]*(u[i]+j))

//f[i][j]+=+d[i]*(u[i]+j)

const int N=50+5,S=1e4+5;
int f[N][S];
int n,m,s;
int u[N],d[N];

il void work()
{
    memset(f,0x3f,sizeof(f));
    f[0][0]=0;
    for(int i=1;i<=n;++i)
    {
        for(int k=0;k<=0+u[i]&&k<=s;++k) f[i][0]=min(f[i][0],f[i-1][k]+(m-d[i])*k);
        for(int j=1;j<=s;++j)
        {
            if(j+u[i]<=s) f[i][j]=min(f[i][j-1],f[i-1][j+u[i]]+(j+u[i])*m-d[i]*(u[i]+j));
            else f[i][j]=f[i][j-1];
        }
        for(int j=0;j<=s;++j) f[i][j]+=d[i]*(u[i]+j);
    }
    int ans=f[n][0];

    printf("%d\n",ans);
}

int main()
{
    scanf("%d%d%d",&n,&m,&s);
    for(int i=1;i<=n;++i) scanf("%d",&u[i]);
    for(int i=1;i<=n;++i) scanf("%d",&d[i]);
    work();    
    return 0;
}
```

---

## 作者：QuantAsk (赞：3)

AC链接：
https://www.luogu.org/record/show?rid=7949532


----------


## 大意

有n个月，每个月商品价格di，需求量Ui。有容量为S的仓库，一个商品汇存一个月要m。求最低成本


----------


## 解题思路

首先是月份做为点，成本作为费用，需求作为容量。
刚开始想的是专门做一个点作为仓库，后来发现其实可以直接向下连边。
然后就是这样构图：
![构图](https://cdn.luogu.com.cn/upload/pic/21514.png)
然后求费用流就好了


----------


## 代码
```
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
struct line{
    int to,w,c,next;
}a[2001];
int tot,n,m,s,t,f[601],ls[601],tail,answer;
int state[601],x,y,w,c,ans,head,pre[601],S;
bool v[601];
void addl(int x,int y,int w,int c)
{
    a[++tot].to=y;a[tot].w=w;a[tot].c=c;
    a[tot].next=ls[x];ls[x]=tot;
    a[++tot].to=x;a[tot].w=0;a[tot].c=-c;
    a[tot].next=ls[y];ls[y]=tot;
}
bool spfa()
{
    memset(f,127/3,sizeof(f));
    memset(v,0,sizeof(v));
    head=0;tail=1;v[s]=true;
    state[1]=s;f[s]=0;
    while (head!=tail)
    {
        head=head%500+1;
        int x=state[head];
        for (int q=ls[x];q;q=a[q].next)
        {
            int y=a[q].to;
            if (a[q].w&&f[x]+a[q].c<f[y])
            {
                f[y]=f[x]+a[q].c;
                pre[y]=q;
                if (!v[y])
                {
                    v[y]=true;
                    tail=tail%500+1;
                    state[tail]=y;
                }
            }
        }
        v[x]=false;
    }
    if (f[t]>=707406378) return 0;
    else return 1;
}
void upway()
{
    int k=2147483647,now=t;
    while (now!=s)
    {
        k=min(k,a[pre[now]].w);
        now=a[pre[now]^1].to;
        
    }
    ans+=f[t]*k;now=t;
    answer+=k;
    while (now!=s)
    {
        a[pre[now]].w-=k;
        a[pre[now]^1].w+=k;
        now=a[pre[now]^1].to;
    }
}
int main()
{
    tot=1;
    scanf("%d%d%d",&n,&m,&S);
    s=n+1;t=n+2;
	for (int i=1;i<=n;i++)
	  scanf("%d",&x),addl(i,t,x,0);//完成订单
	for (int i=1;i<=n;i++)
	  scanf("%d",&x),addl(s,i,1e9,x);//进货
	for (int i=1;i<n;i++)
	  addl(i,i+1,S,m);//存
    while (spfa())
    {
      upway();
    }
    printf("%d",ans);
}
```

---

## 作者：让风忽悠你 (赞：2)

[原题](https://www.luogu.com.cn/problem/P2517)

## 题意
- 某公司估计市场在第 $i$ 个月对某产品的需求量为 $U_i$，已知在第 $i$ 月该产品的订货单价为 $D_i$。
- 上个月月底未销完的单位产品要付存贮费用 $m$。

**问如何安排这 $n$ 个月订购计划，才能使成本最低？**

## 做法
- 每个点都向超级汇点连一条流量为 $U_i$ 费用为 0 的边，因为卖出去的总不会亏钱吧。
- 每个点向超级源点连一条流量为 $\infty$ 费用为 $D_i$ 的边，表示第 $i$ 月的成本。
- 每个月向下一个月连一条流量为 $s$ 费用为 $m$ 的边，即对于每个 $i$ 向 ${i+1}$ 连一条流量为 $s$ 费用为 $m$ 的边，表示每个月的存贮费用。

## 代码
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
#define N 5005
#define M 100005
#define inf 0x7f7f7f7f

using namespace std;

int n,m,s,t,tot=1,ans,ret,S;
int dep[N],head[N],lnk[N],depth[N];
bool vis[N];
struct node{
	int next,to,val,cost;
}e[M];

inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}

inline void addedge(int u,int v,int w,int c){
	e[++tot].to=v;
	e[tot].val=w;
	e[tot].next=head[u];
	e[tot].cost=c;
	head[u]=tot;
}

inline void add(int u,int v,int w,int c){
	addedge(u,v,w,c);
	addedge(v,u,0,-c);
}

inline bool spfa(){
	memset(dep,0x7f7f,sizeof(dep));
	memset(depth,0,sizeof(depth));
	memcpy(lnk,head,sizeof(head));
	queue <int> q;
	q.push(s);
	dep[s]=0;
	vis[s]=1;
	int u,v;
	while(!q.empty()){
		u=q.front(); q.pop();
		vis[u]=0;
		for(int i=head[u];i;i=e[i].next){
			v=e[i].to;
			if(e[i].val && dep[v]>dep[u]+e[i].cost){
				dep[v]=dep[u]+e[i].cost;
				depth[v]=depth[u]+1; 
				if(!vis[v]){
					q.push(v);
					vis[v]=1;
				}
			}
		}
	}
	return dep[t]!=inf;
}

int dfs(int u,int into){
	if(u==t) return into;
	vis[u]=1;
	int out=0,res;
	int v;
	for(int i=lnk[u];i && into>out;i=e[i].next){
		v=e[i].to;
		if(!vis[v] && e[i].val && dep[v]==dep[u]+e[i].cost && depth[v]==depth[u]+1){
			res=dfs(v,min(e[i].val,into-out));
			if(res){
				ret+=res*e[i].cost; //计算费用 
				e[i].val-=res;
				e[i^1].val+=res;
				out+=res;
			}
		}
	}
	vis[u]=0;
	return out;
}

inline void build(){
	int u,w;
	for(int i=1;i<=n;i++){
		u=read();
		add(i,t,u,0);
	} //出售 
	for(int i=1;i<=n;i++){
		w=read();
		add(s,i,inf,w);
	} //每月成本 
	for(int i=1;i<n;i++) add(i,i+1,S,m); //每月存贮费用 
}

inline int mcmf(int s,int t){
	while(spfa()) ans+=dfs(s,1e9);
	return ret;
} 

int main(){
	n=read(); m=read(); S=read();
	s=n+1; t=s+1;
	build(); //建图 
	printf("%d",mcmf(s,t));
	return 0;
}
```


---

## 作者：crescentic (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P2517)

很快啊，一下子就判断出是个费用流。

### 解题思路

首先，构建两个虚拟源汇点。

根据题目分析，
> 第i个月对某产品的需求量为Ui

结合全文，因为该月可以有**剩余**，所以不能确定入流限制，那就换条路，咱们选择跟**汇点**连边。自然而然，容量为 $Ui$， 费用为 $0$(汇点是虚拟的，不需要花费)。

然后我们在从源点向该点连边，因为汇点直接限制了流量，所以容量直接搞成  $inf$ 就好了，费用为 $0$。

也就是，当月**购进的与源点连边**，当月**售出的与汇点连边**。

又因为上一月的剩余可以留到当月处理，但费用为 $m$。用小脑袋瓜想想，不就是将**上一月向当月连一条边**嘛？容量为 $S$(仓库容量)，费用为 $m$。

这不就出来了吗，最后跑一遍费用流模板。

### 完整代码
```cpp
 #include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define rt register int
#define int long long
const int N = 105, M = 500, inf = 1e9;
int n, m, V, ff, tot, cnt, S, T, ss, tt;
int head[N], to[M], f[M], w[M], nex[M], q[N], d[N], pre[N], incf[N], v[N];
bool vis[N];
char s;
inline void add(int a, int b, int c, int d) {
    to[tot] = b, f[tot] = c, w[tot] = d, nex[tot] = head[a], head[a] = tot ++;
    to[tot] = a, f[tot] = 0, w[tot] = -d, nex[tot] = head[b], head[b] = tot ++;
}
inline bool spfa() {
    memset(d, 0x3f, sizeof(d) );
    memset(incf, 0, sizeof(incf) );
    ss = 0, tt = 1, q[0] = S, d[S] = 0, incf[S] = inf;
    int now, ver;
    while (ss != tt) {
        now = q[ss ++], vis[now] = 0;
        if(ss == N) ss = 0;
        for(rt i = head[now]; ~i; i = nex[i]) {
            ver = to[i];
            if(f[i] && d[now] + w[i] < d[ver]) {
                d[ver] = d[now] + w[i], pre[ver] = i, incf[ver] = min(f[i], incf[now]);
                if (!vis[ver]) {
                    q[tt ++ ] = ver, vis[ver] = 1;
                    if (tt == N) tt = 0;
                }
            }
        }
    }
    return incf[T] > 0;
}
inline int solve() {
    int cost = 0;
	int now;
    while(spfa()) {
        now = incf[T], cost += now * d[T];
        for(rt i = T; i != S; i = to[pre[i] ^ 1])
            f[pre[i]] -= now, f[pre[i] ^ 1] += now;
    }
    return cost;
}
inline void read(int &x) {
	x = 0, ff = 1, s = getchar();
	while(s < '0' || s > '9') {if(s == '-') ff = -1; s = getchar();}
	while(s <= '9' && s >= '0') {x = x * 10 + s - '0'; s = getchar();}
	x *= ff;
}
signed main() {
	memset(head,-1,sizeof(head));
	read(n), read(m), read(V);
	int x;
	S = n + 1,T = S + 1; 
	for(rt i = 1; i <= n; i ++) {
		read(v[i]);
		add(i,T,v[i],0);
	}
	for(rt i = 1; i <= n; i ++) {
		read(x);
		add(S,i,inf,x);
		if(i < n) add(i,i + 1,V,m);
	}
	printf("%lld",solve());
	return 0;
} 
```


---

## 作者：ningyuheng (赞：1)

当我用DP把这道题AC后看到下面一群大佬竟然都是用费用流的时候我是一脸懵逼的。

言归正传，设dp[i][j]表示前i个月过完仓库里还剩j个产品时所需要的最小的费用，k为前一个月仓库所存的产品的数目，则可以得到

dp[i][j]=min(dp[i][j],dp[i-1][k]+j×m+(j+u[i]-k)×d[i]);

提取出常数得dp[i][j]=min(dp[i][j],dp[i-1][k]-k×d[i]);

dp[i][j]+=j×m+(j+u[i])×d[i];

这是我开始的代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int n,m,s,u[100100],d[100100],i,j,k,dp[600][10010],p1,p2;
int main()
{
    scanf("%d%d%d",&n,&m,&s);
    for(i=1;i<=n;i++)
        scanf("%d",&u[i]);
    for(i=1;i<=n;i++)
        scanf("%d",&d[i]);
    for(i=0;i<=s;i++)
        for(j=0;j<=n;j++)
            dp[j][i]=1000000000;
    dp[0][0]=0;
    for(i=1;i<=n;i++)
        for(j=0;j<=s;j++){
            for(k=0;k<=j+u[i]&&k<=s;k++)
                dp[i][j]=min(dp[i][j],dp[i-1][k]-k*d[i]);
           dp[i][j]+=j*m+(j+u[i])*d[i];
      }
     cout<<dp[n][0]<<endl;
     return 0;
}
```
然后发现当j增大的时候k顶多只会增大一，于是去掉里面多余的一个循环后，代码就变成了这样：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int n,m,s,u[100100],d[100100],i,j,k,dp[600][10010],p1,p2;
int main()
{
    scanf("%d%d%d",&n,&m,&s);
    for(i=1;i<=n;i++)
        scanf("%d",&u[i]);
    for(i=1;i<=n;i++)
        scanf("%d",&d[i]);
    for(i=0;i<=s;i++)
        for(j=0;j<=n;j++)
            dp[j][i]=1000000000;
    dp[0][0]=0;
    for(i=1;i<=n;i++){
        for(k=0;k<=u[i]&&k<=s;k++)
            dp[i][0]=min(dp[i][0],dp[i-1][k]-k*d[i]);
        for(j=1;j<=s;j++)
            if(j+u[i]<=s)
                dp[i][j]=min(dp[i][j-1],dp[i-1][j+u[i]]-(j+u[i])*d[i]);
            else
                dp[i][j]=dp[i][j-1];
        for(j=0;j<=s;j++)
            dp[i][j]+=j*m+(j+u[i])*d[i];
    }
    printf("%d\n",dp[n][0]);
     return 0;
}
```
总时间复杂度大约为(ns);n为月数,s为仓库库存

---

## 作者：Great_Influence (赞：1)

看没有其他题解了，就来交一个Dinic的题解。

具体思路很简单，建一个源点表示进货处，一个汇点表示卖出，在相邻每天之间建边表示存储货物，在跑一边费用流就可以了。

代码：

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<queue>
#include<iostream>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
using namespace std;
const int MAXN=40001;
const int inf=0xFFFFFFF;
template<typename T>
inline void read(T &x)//快读
{
    T s=0,f=1;
    char k=getchar();
    while(!isdigit(k)&&k!='-')k=getchar();
    if(!isdigit(k))
    {
        f=-1;
        k=getchar();
    }
    while(isdigit(k))
    {
        s=(s<<3)+(s<<1)+(k^48);
        k=getchar();
    }
    x=f*s;
}
struct edge
{
    int v,w,c,next;
}p[MAXN<<2]; //边
int n,m,s,w[MAXN],e=1,head[MAXN],fee;//各种乱七八糟的东西。只要注意fee表示费用。
void add(int u,int v,int f,int w)//加边。注意边从2开始，至于为什么去看网络流
{
    p[++e].v=v;
    p[e].w=w;
    p[e].c=f;
    p[e].next=head[u];
    head[u]=e;
}
queue<int>G;//队列
int dis[MAXN];//层次
bool vis[MAXN];//标记是否访问
bool spfa(int s,int t)//spfa找边
{
    fill(dis+1,dis+n+3,inf);
    dis[s]=0;
    vis[s]=true;
    G.push(s);
    while(!G.empty())
    {
        int u=G.front(),v=head[u];
        G.pop();
        vis[u]=false;
        while(v)
        {
            if(p[v].c&&dis[p[v].v]>dis[u]+p[v].w)
            {
                dis[p[v].v]=dis[u]+p[v].w;
                if(!vis[p[v].v])
                {
                    vis[p[v].v]=true;
                    G.push(p[v].v);
                }
            }
            v=p[v].next;
        }
    }
    //int i;
    ///For(i,1,n+2)cout<<i<<"           "<<dis[i]<<endl;
    //putchar('\n');
    //system("pause");调试
    return dis[t]!=inf;
}
int dfs(int u,int t,int flow)//找可行流
{
    if(u==t||!flow)return flow;
    vis[u]=true;
    int sum=0,v=head[u];
    while(v)
    {
        if(dis[p[v].v]==dis[u]+p[v].w&&p[v].c&&!vis[p[v].v])//注意Dinic的优化
        {
            int f=dfs(p[v].v,t,min(flow,p[v].c));
            flow-=f;
            p[v].c-=f;
            p[v^1].c+=f;
            fee+=p[v].w*f;
            sum+=f;
        }
        v=p[v].next;
    }
    vis[u]=false;
    return sum;
}
int Dinic(int s,int t)//Dinic
{
    int ans=0;
    while(spfa(s,t))ans+=dfs(s,t,inf);
    return ans;
}
int main()
{
    read(n);
    read(m);
    read(s);
    int i,u,v;
    For(i,1,n)read(w[i]);
    For(i,1,n)
    {
        read(u);
        add(1,i+1,inf,u);//进货处向每天连边(inf,d)
        add(i+1,1,0,-u);
        add(i+1,n+2,w[i],0);//每天向卖出连边(u,0)
        add(n+2,i+1,0,0);
        if(i!=n)
        {
            add(i+1,i+2,s,m);//除最后一天，每天向后一天连边(s,m)
            add(i+2,i+1,0,-m);
        }
    }
    Dinic(1,n+2);
    printf("%d\n",fee);//注意是要求费用
    return 0;
}

```

---

## 作者：xsxshxs (赞：1)

一道裸的费用流

建边方法如下：

1、源点向每一个月份建边，费用为进货费用

2、每一个月份向下一个月份建边，费用为m，容量为S

3、每一个月份向汇点(n+1)建边，费用为0， 容量为卖货数量（Ui）

由于3中的费用为0，所以很显然该建边符合题意

代码如下

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define INF 0x3f3f3f3f
using namespace std;
const int MAXN = 20001;
inline int get()
{
    char c;bool f = 0; int res = 0;
    while (( (c=getchar())<48||c>57) && c!= '-');
     if (c=='-') f = 1;
      else res = c- '0';
    while ( (c = getchar()) >= 48 && c <= 57)
     res = res * 10 + c -'0';
    return f ? -res:res;
}
inline void put(int x)
{
    if (x<0)
    { 
        x = ~x + 1;
        putchar('-');
    }
    if (x>9) 
    put(x / 10);
    putchar(x % 10 + 48);
}
int n, m, MS, S, T, tot, ans;
int head[MAXN], next[MAXN], from[MAXN], to[MAXN];
int pre[MAXN], pas[MAXN], w[MAXN];
void add(int x, int y, int f, int z)
{
    next[++tot] = head[x];
    head[x] = tot;
    to[tot] = y;
    from[tot] = x;
    pas[tot] = f;
    w[tot] = z;
    
    next[++tot] = head[y];
    head[y] = tot;
    to[tot] = x;
    from[tot] = y;
    pas[tot] = 0;
    w[tot] = -z;
}
int dis[MAXN], flag[MAXN], que[MAXN];
int SPFA()
{
    for(int i = S; i <= T; i++)
    dis[i] = INF;
    dis[S] = 0; flag[S] = 1;
    int t = 0, W = 1;
    que[1] = S;
    while(t < W)
    {
    //    cout<<t<<" "<<W<<endl;
        int u = que[++t];
        for(int i = head[u]; i; i = next[i])
        {
            int v = to[i];
            if(pas[i] && dis[v] > dis[u] + w[i])
            {
                dis[v] = dis[u] + w[i];
                pre[v] = i;
                if(!flag[v])
                {
                    flag[v] = 1;
                    que[++W] = v;
                }
            }
        }
        flag[u] = 0;
    }
//    cout<<dis[T];
    return dis[T] != INF; 
}
void Work()
{
    int x = INF;
    for(int i = pre[T]; i; i = pre[from[i]])
    x = min(x, pas[i]);
    for(int i = pre[T]; i; i = pre[from[i]])
    {
        pas[i] -= x;
        pas[((i - 1) ^ 1) + 1] += x;
        ans += x * w[i];
    }
}
int main()
{
    n = get(); m = get(); MS = get();
    S = 0, T = n + 1;
    for(int i = 1; i <= n; i++)
    add(i, T, get(), 0);
    for(int i = 1; i <= n; i++)
    add(S, i, INF, get());
    for(int i = 1; i < n; i++)
    add(i, i + 1, MS, m);
    while(SPFA())
    Work();
    put(ans);
}
```

---

## 作者：xiezheyuan (赞：0)

[也许有更好的阅读体验](https://www.cnblogs.com/zheyuanxie/p/p2517.html)

## 简要题意

一家公司销售一种商品，在时刻 $i$ 可以需要 $U_i$ 份商品。第 $i$ 时刻向生产方购买 $1$ 份商品需要 $d_i$ 的代价。$i-1$ 时刻的 $1$ 份商品滞留到 $i$ 时刻，需要花费 $m$ 的代价，且一共只能滞留 $S$ 份商品。

问经营 $n$ 个时刻的最小花费。

$0\leq n\leq 50, 0\leq m \leq 10, 0\leq S\leq 10000,0 \leq U_i \leq 10000,0 \leq d_i \leq 100$

## 思路

这道题和 [P1251 餐巾计划问题](https://www.luogu.com.cn/problem/P1251) 差不多，都是费用流建模题。

对于 $i$ 时刻，建立点 $i$，然后考虑连边：

- 对于滞留商品，我们连边 $(i-1,i,S,m)$（这一点显然易见）。
- 对于需要商品，我们像餐厅计划问题一样，建立超级汇点 $T$，然后连边 $(i,T,U_i,0)$。
- 对于购买商品，我们像餐厅计划问题一样，建立超级源点 $S$，然后连边 $(S,i,+\infty,d_i)$。

> 这里再解释一下连边：需要商品时，不能从上一个节点连边，因为剩余不方便计算。但是我们如果连向汇点，那么就直接限制了流量，也就是说，如果要有流量，那么必须要有 $U_i$ 的流量。购买商品时，没有商品份数限制，因此流量为 $+\infty$，买一份需要 $d_i$，所以费用时 $d_i$。总之，这里流量时商品个数，费用时花费。

然后直接跑 $S$ 为源 $T$ 为汇的最小费用最大流即可。时间复杂度 $O(\operatorname{mcmf}(n,n))$。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int n,m,s;

namespace MCMF{
	struct edge{
		int nxt,to,cap,cost;
	} g[100005];
	int head[100005],ec=-1;
	void add(int from,int to,int cap,int cost){
		g[++ec].nxt=head[from];
		g[ec].to=to;
		g[ec].cap=cap;
		g[ec].cost=cost;
		head[from]=ec;
	}
	void add_edge(int from,int to,int cap,int cost){
		add(from,to,cap,cost);
		add(to,from,0,-cost);
	}
	queue<int> q;
	bool vis[100005];
	int flow[100005];
	int dis[100005];
	int pre[100005];
	int last[100005];
	bool spfa(int s,int t){
		memset(dis,0x7f,sizeof(dis));
		memset(flow,0x7f,sizeof(flow));
		memset(vis,0,sizeof(vis));
		q.push(s);
		vis[s]=1;
		dis[s]=0;
		pre[t]=-1;
		while(!q.empty()){
			int u=q.front();
			q.pop();
			vis[u]=0;
			for(int i=head[u];i!=-1;i=g[i].nxt){
				int v=g[i].to;
				if(g[i].cap>0 && dis[v]>dis[u]+g[i].cost){
					dis[v]=dis[u]+g[i].cost;
					pre[v]=u;
					last[v]=i;
					flow[v]=min(flow[u],g[i].cap);
					if(!vis[v]){
						vis[v]=1;
						q.push(v);
					}
				}
			}
		}
		return pre[t]!=-1;
	}
	
	pair<int,int> MCMF(int s,int t){
		int maxflow=0,mincost=0;
		while(spfa(s,t)){
			int now=t;
			maxflow+=flow[t];
			mincost+=flow[t]*dis[t];
			while(now!=s){
				g[last[now]].cap-=flow[t];
				g[last[now]^1].cap+=flow[t];
				now=pre[now];
			}
		}
		return make_pair(maxflow,mincost);
	}
}

int S,T;

signed main(){
	ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);
	memset(MCMF::head,-1,sizeof(MCMF::head));
	MCMF::ec=-1;
	cin>>n>>m>>s;
	S=0,T=n+1;
	for(int i=1,u;i<=n;i++){
		cin>>u;
		MCMF::add_edge(i,T,u,0); 
	}
	for(int i=1,d;i<=n;i++){
		cin>>d;
		MCMF::add_edge(S,i,LLONG_MAX,d);
	}
	for(int i=2;i<=n;i++){
		MCMF::add_edge(i-1,i,s,m);
	}
	cout<<MCMF::MCMF(S,T).second<<'\n';
	return 0;
}
```

[AC Record](https://www.luogu.com.cn/record/87876000)

---

## 作者：Kaenbyou_Rin (赞：0)

嗯，网络流最重要的是建图。

------------

我首先想出来的是将第 $i$ 个点与第 $i+1$ 个点之间连一条流量为 $S$ ，费用为 $m$ 的边。毕竟上个月最多就给下个月剩下一个仓库的库存嘛。

```cpp
add(i,i+1,S,m)
```
------------

然后考虑源点与每个点之间应该连一条怎样的边。

我们可以感性的理解下：每个月最多只能提供仓库容量加上售出数量的货物，再多了你没地方放。所以我们将超级源点和每个点之间连一条流量为 $S+U_i$ ，费用为 $D_i$ 的边。

```cpp
add(s,i,S+U[i],D[i])
```

------------

最后考虑每个点与汇点之间应该连什么边。

首先我们可以将汇点理解成一年的总销售量。

每个月对总销售量的最大贡献值为 $U_i$ ，由于只计算成本所以不考虑售出的费用，故由每个点向汇点连接一条流量为 $U_i$ ，费用为 $0$ 的边。

```cpp
add(i,t,U[i],0)
```

------------

Code：
```cpp
#include<queue>
#include<stdio.h>
#include<cmath>
#include<string.h>
#include<iostream>
#include<algorithm>
const int inf=0x3f3f3f3f;
const int N=510;
int n,m,s,t,dis[N],pre[N],vis[N],U[N],D[N],S;
int nxt[N],flow[N],mincost,head[N],tot=1; 
struct edge{
    int to,nxt,flow,dis;
}e[N];
inline int read(){
	int w=1,x=0;
	char ch=getchar();
	for(;ch>'9'||ch<'0';ch=getchar()) if(ch=='-') w=-1;
	for(;ch<='9'&&ch>='0';ch=getchar()) x=(x<<1)+(x<<3)+ch-'0';
	return x*w;
}
inline void add(int u,int v,int w,int dis){
    e[++tot].nxt=head[u];
    e[tot].to=v;
    e[tot].flow=w;
    e[tot].dis=dis;
    head[u]=tot;
    e[++tot].nxt=head[v];
    e[tot].to=u;
    e[tot].flow=0;
    e[tot].dis=-dis;
    head[v]=tot;
}
inline bool spfa(){
    std::queue<int> q;
    memset(dis,0x3f,sizeof dis);
    memset(flow,0x3f,sizeof flow);
    memset(vis,0,sizeof vis);
    q.push(s); 
    vis[s]=1;dis[s]=0;pre[t]=-1;
    while(!q.empty()){
        int u=q.front();
        q.pop();vis[u]=0;
        for(register int i=head[u];i;i=e[i].nxt){
        	int v=e[i].to,w=e[i].dis;
            if(e[i].flow>0&&dis[v]>dis[u]+w){
                dis[v]=dis[u]+w;
                pre[v]=u;nxt[v]=i;
                flow[v]=std::min(flow[u],e[i].flow);
                if(!vis[v]){
                    vis[v]=1;
                    q.push(v);
                }
            }
        }
    }
    return pre[t]!=-1;
}
void mcmf(){
    while(spfa()){
        int u=t;
        mincost+=flow[t]*dis[t];
        while(u!=s){
            e[nxt[u]].flow-=flow[t];
            e[nxt[u]^1].flow+=flow[t];
            u=pre[u];
        }
    }
}
signed main(){
    n=read(),m=read(),S=read();
	s=n<<1|1,t=s+1;
	for(register int i=1;i<=n;i++) U[i]=read();
	for(register int i=1;i<=n;i++) D[i]=read();
	for(register int i=1;i<=n;i++) add(s,i,S+U[i],D[i]),add(i,t,U[i],0);
	for(register int i=1;i<n;i++) add(i,i+1,S,m);
	mcmf();
	printf("%d\n",mincost);
    return -1;//不要直接抄啊好歹看下分析吧
}
```

这是我第一次完全自己摸出来建图，网络流多做点题自然就有感觉了。

**Ending.awa~~**

---

## 作者：赵悦岑 (赞：0)

# P2517 [HAOI2010]订货

[P2517 [HAOI2010]订货](https://www.luogu.com.cn/problem/P2517)

## 分析

这道题和餐巾计划问题有点像，我们很容易想到用网络流实现。把货物看成流量，每个月看成一个点，需要建立一下几种边：

1. 每个月可以进购货物，单价为 $d_i$，所以要从源点向第 $i$ 月的点连边，容量 $inf$，费用 $d_i$。

2. 每个月需要售出 $U_i$ 的货物，所以要从第 $i$ 月的点向汇点连边，容量为 $U_i$，费用 $0$。

3. 每个月可以把货物留到下一个月，最多留 $S$，单位费用为 $m$，所以要从第 $i$ 月到第 $i+1$ 月连边，容量为 $S$，费用为 $m$。

连完所有边之后跑一遍最小费用最大流就可以了，最小费用就是答案。

## code

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
typedef long long ll;
const int N=10001,M=100001;
int n,m,p=1,v,s1,s2,t[N],t0[N];
ll f[N],q;
bool h[N];
struct str
{
    int m,q;
    ll r,w;
}a[M];
void road(int x,int y,ll r,ll w)
{
    a[++p].m=y;
    a[p].q=t[x];
    t[x]=p;
    a[p].r=r;
    a[p].w=w;
}
bool SPFA()
{
    queue<int> Q;
    Q.push(s1);
    for(int i=1;i<=s2;++i)
    {
        f[i]=1e18;
        h[i]=false;
    }
    f[s1]=0;
    h[s1]=true;
    while(!Q.empty())
    {
        int k=Q.front();
        Q.pop();
        if(h[k]==false) continue;
        h[k]=false;
        for(int i=t[k];i!=0;i=a[i].q)
        {
            if(a[i].r>0&&f[k]+a[i].w<f[a[i].m])
            {
                f[a[i].m]=f[k]+a[i].w;
                Q.push(a[i].m);
                h[a[i].m]=true;
            }
        }
    }
    if(f[s2]!=1e18) return true;
    return false;
}
ll dfs(int x,ll r)
{
    if(x==s2) return r;
    ll s=0;
    for(int i=t0[x];i!=0;i=a[i].q)
    {
        t0[x]=i;
        if(h[a[i].m]==false&&a[i].r>0&&f[a[i].m]==f[x]+a[i].w)
        {
            h[a[i].m]=true;
            ll z=dfs(a[i].m,min(r,a[i].r));
            h[a[i].m]=false;
            if(z!=0)
            {
                a[i].r-=z;
                a[i^1].r+=z;
                r-=z;
                s+=z;
                v+=z*a[i].w;
            }
            else f[a[i].m]=0;
            if(r==0) return s; 
        }
    }
    return s;
}
int main()
{
    scanf("%d%lld%d",&n,&q,&m);
    s1=n+1,s2=n+2;
    for(int i=1;i<=n;++i)
    {
        ll r;
        scanf("%lld",&r);
        road(i,s2,r,0);
        road(s2,i,0,0);
    }
    for(int i=1;i<=n;++i)
    {
        ll w;
        scanf("%lld",&w);
        road(s1,i,1e18,w);
        road(i,s1,0,-w);
    }
    for(int i=1;i<=n-1;++i)
    {
        road(i,i+1,m,q);
        road(i+1,i,0,-q);
    }
    while(SPFA())
    {
        for(int i=1;i<=s2;++i) 
        {
            t0[i]=t[i];
            h[i]=false;
        }
        dfs(s1,1e18);
    }
    printf("%lld",v);
    return 0;
}
```

---

## 作者：yszs (赞：0)

[传送门](https://www.luogu.com.cn/problem/P2517)
 
# 网络流做法

~~一道比较裸的费用流~~

## $\texttt{thinking}$

已知需求 $U_i$ 费用 $d_i$ ，需求可以看做流量，可以考虑建图跑费用流。 

## $\texttt{Solution}$

新建一个虚拟源点 $s$ 和虚拟汇点 $t$ 。

可以把 $s$ 看做**提供货物的工厂**，把 $t$ 看做**收货的市场**。
连边方式及原因如下

- 将源点和每个月连一条流量是 $\infty$，费用为 $d_i$ 的边。因为可以贮存一些货物，所以工厂每个月可以提供无限的货物。

- 将每个月和汇点连一条流量是 $U_i$，费用为 $0$ 的边。交付货物，不需要费用。
- 将每个月之间连一条流量为 $S$，费用为 $m$ 的边。贮存货物。

## $\texttt{Code}$

```cpp
#include<bits/stdc++.h>
#define For(u) for(int i=head[u];i;i=e[i].next)
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define ll long long
using namespace std;
const ll INF=1e9;
const int N=2e5+5;
int head[N],cnt=1,n,m,s,t,pre[N];
ll dis[N],maxflow,mincost,incf[N],u[N],d[N];
bool vis[N];
struct node
{
	ll to,next,flow,dis;
}e[N*2];
void add(int u,int v,int flow,int dis)
{
	e[++cnt].dis=dis;
	e[cnt].to=v;
	e[cnt].flow=flow;
	e[cnt].next=head[u];
	head[u]=cnt;
}
queue<int>q;
bool spfa()
{
	memset(vis,0,sizeof(vis));
	for(int i=0;i<=n+1;i++)
	{
		dis[i]=INF;
	}
	q.push(s);
	vis[s]=1;
	dis[s]=0;
	incf[s]=1<<30;
	while(!q.empty())
	{
		int u=q.front();
		vis[u]=0;
		q.pop();
		For(u)
		{
			int v=e[i].to;
			if(!e[i].flow) continue;
			if(dis[v]>dis[u]+e[i].dis)
			{
				dis[v]=dis[u]+e[i].dis;
				pre[v]=i;
				incf[v]=min(incf[u],e[i].flow);
				if(!vis[v])
				{
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
	if(dis[t]==INF) return 0;
	else return 1;
}
void dfs()
{
	int i,x=t;
	maxflow+=incf[t];
	mincost+=dis[t]*incf[t];
	while(x!=s)
	{
		i=pre[x];
		e[i].flow-=incf[t];
		e[i^1].flow+=incf[t];
		x=e[i^1].to;
	}
}
void run()
{
	while(spfa())
	{
		dfs();
	}
}
int main()
{
	int S=0; 
	cin>>n>>m>>S;
	s=0,t=n+1;
	rep(i,1,n-1)
	{
		add(i,i+1,S,m);
		add(i+1,i,0,-m);
	}
	rep(i,1,n)
	{
		cin>>u[i];
	}
	rep(i,1,n)
	{
		cin>>d[i];
	}
	rep(i,1,n)
	{
		add(s,i,INF,d[i]);
		add(i,s,0,-d[i]);
		add(i,t,u[i],0);
		add(t,i,0,0);
	}
	run();
	cout<<mincost<<endl;
	return 0;
}
```


---

## 作者：Booksnow (赞：0)

# 费用流

## 题目描述

有一个公司，要做 $n$ 个月的订购计划，具体如下

- 第 $i$ 个月对某个产品的需求量是 $U_i$ ，且我们已知第 $i$ 个月该产品的订货单价为 $d_i$ 。

- 上一个月没有销售完的产品可以被贮藏起来，但是需要支付 $m$ 的贮藏费用

- 第一个月月初的库存为零，且第 $n$ 个月的库存量也为零

问如何安排订购计划，才能使订购成本**最低**。

## 题目分析

这道题挺明显作为一道费用流题应该还是挺明显的，而**费用流模板**想必就不用加以赘述，毕竟对于网络流，**建图才是精髓**。

显然本题只有 $n$ 个**实点**，对应 $n$ 个月，然后我们能够发现，如果通过建立**虚点**我们剩余的工作将完全无法展开。

考虑一个常规想法，建立一个超级源点，一个超级汇点，则建图方案具体如下：

- 可以将超级源点向代表月份点 $i$ 连接一条流量是正无穷，费用是 $d_i$ 

- 贮存可以具体化为月份$i$向月份 $i+1$ 连接一条流量是 $s$ ，费用是 $m$ 的边

- 最后，再将月份 $i$ 向超级汇点连接一条流量是 $U_i$ 费用是 $0$ 的边

样例建图如下:

![](https://cdn.luogu.com.cn/upload/image_hosting/h0ai3j4t.png)

## CODE

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll INF=0x3f3f3f3f3f3f3f3f;
const int N=5e3+10,EDGE=1e5+10;
int n,m,s,t; 
ll maxf,minc;
inline ll read()
{
	ll s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
ll w[EDGE],p[EDGE];
int tot=1,nex[EDGE],first[EDGE],v[EDGE];
inline void Add(int x,int y,ll z,ll c)
{
	nex[++tot]=first[x];
	first[x]=tot;
	v[tot]=y,w[tot]=z,p[tot]=c;
} 
int pre[N];
ll dis[N],Min[N]; bool vis[N];
inline bool SPFA(int S,int T)
{
	memset(dis,0x3f,sizeof(dis));
	memset(vis,false,sizeof(vis));
	queue<int> q;
	q.push(S);
	vis[S]=1,dis[S]=0,Min[S]=INF;
	while(!q.empty()){
		int now=q.front(); q.pop();
		vis[now]=false;
		for(register int i=first[now];i;i=nex[i]){
			int to=v[i];
			if(!w[i]) continue;
			if(dis[to]>dis[now]+p[i]){
				dis[to]=dis[now]+p[i];
				Min[to]=min(Min[now],w[i]);
				pre[to]=i;
				if(!vis[to]) q.push(to),vis[to]=true;
			}
		}
	}
	return dis[T]!=INF;
}
inline void dinic()
{
	while(SPFA(0,n+1)){
		minc+=dis[n+1]*Min[n+1];
		int temp=n+1,i;
		while(temp!=0){
			i=pre[temp];
			w[i]-=Min[n+1];
			w[i^1]+=Min[n+1];
			temp=v[i^1];
		}
	}
}
int main()
{
	n=read(),m=read(),s=read();
	for(register int i=1;i<=n;i++){
		int need=read();
		Add(i,n+1,need,0),Add(n+1,i,0,0);	//连接卖出边 
	}
	for(register int i=1;i<=n;i++){
		int temp=read();
		Add(0,i,INF,temp),Add(i,0,0,-temp); //连接进货边 
	}
	for(register int i=1;i<n;i++) Add(i,i+1,s,m),Add(i+1,i,0,-m); //连接储存边 
	dinic();
	printf("%lld\n",minc);
	return 0;
}
```


---

## 作者：Orion545 (赞：0)

# 题面

[传送门](https://www.luogu.org/problemnew/show/P2517)

# 思路

这题其实挺水的......做过[餐巾计划问题](http://www.cnblogs.com/dedicatus545/p/8387692.html)就能明白，是同一个道理

首先，显然刚刚好满足每一个月的需求，会得到最优解（废话-_-||）

然后我们发现，货物在不同的月之间的转移，可以比喻为水在不同的几个平行管道之间流动

自然而然地想到网络流

那么，我们给每个月建立一个节点i，建立超级源点和超级汇点

从每个i连边(i,T)，费用0，流量为这个月需求量

从S向每个月连边(S,i)，费用为这个月的价格，流量无限（因为理论上你随便买都可以）

那么储存就是连边(i,i+1)，费用为m，流量为S，这里的流量也很好地体现了限制作用

最后的答案就是(S-T)最小费用最大流了

 

需要注意的是，这道题里面的流量提供了两个限制：

一个是每个月可以买很多，但是我们输出只有要求的那么多，是一个下限转上限

另一个就是仓库容量，这个是直接把上限用流量表示出来了

由此，我们应当注意到，网络流中的流量上限其实不止可以表示一种决策的最大值

它也可以在一定的贪心和推导以后来表示最小值

所以做题的时候思路一定要大胆一些

说不定这就是个网络流题呢？

# Code：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define inf 1e9
using namespace std;
inline int read(){
    int re=0,flag=1;char ch=getchar();
    while(ch>'9'||ch<'0'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
    return re*flag;
}
int first[5010],dis[5010],vis[5010],n,m,cnt=-1,ans;
struct edge{
    int to,next,w,cap;
}a[600010];
inline void add(int u,int v,int w,int cap){
    a[++cnt]=(edge){v,first[u],w,cap};first[u]=cnt;
    a[++cnt]=(edge){u,first[v],-w,0};first[v]=cnt;
}
int q[1000010];
bool spfa(int s,int t){
    int head=0,tail=1,i,u,v,w;
    memset(dis,-1,sizeof(dis));memset(vis,0,sizeof(vis));
    q[0]=t;dis[t]=0;vis[t]=1;
    while(head<tail){
        u=q[head++];vis[u]=0;
        for(i=first[u];~i;i=a[i].next){
            v=a[i].to;w=a[i].w;
            if(a[i^1].cap&&((dis[v]==-1)||(dis[v]>dis[u]-w))){
                dis[v]=dis[u]-w;
                if(!vis[v]) q[tail++]=v,vis[v]=1;
            }
        }
    }
    return ~dis[s];
}
int _min(int l,int r){return (l>r)?r:l;}
int dfs(int u,int t,int limit){
    if((u==t)||(!limit)){vis[u]=1;return limit;}
    int i,v,f,flow=0,w;vis[u]=1;
    for(i=first[u];~i;i=a[i].next){
        v=a[i].to;w=a[i].w;
        if(dis[v]==dis[u]-w&&a[i].cap&&!vis[v]){
            if(!(f=dfs(v,t,_min(limit,a[i].cap)))) continue;
            a[i].cap-=f;a[i^1].cap+=f;
            ans+=f*w;flow+=f;limit-=f;
            if(!limit) return flow;
        }
    }
    return flow;
}
int zkw(int s,int t){
    int re=0;
    while(spfa(s,t)){
        vis[t]=1;
        while(vis[t]){
            memset(vis,0,sizeof(vis));
            re+=dfs(s,t,inf);
        }
    }
    return re;
}
int main(){
    memset(first,-1,sizeof(first));
    n=read();m=read();int S=read(),i,t1;
    for(i=1;i<=n;i++) t1=read(),add(i,n+1,0,t1);
    for(i=1;i<=n;i++) t1=read(),add(0,i,t1,inf);
    for(i=1;i<n;i++) add(i,i+1,m,S);
    zkw(0,n+1);
    cout<<ans<<endl;
}
```

---

## 作者：gesong (赞：0)

题目传送门：[P2517 [HAOI2010]订货](https://www.luogu.com.cn/problem/P2517)。
# 思路

这道题一看就是**费用流**求解。

由于是图论问题，我们考虑怎么建边，分为 $3$ 种情况讨论。

1. 由于题目说了，第 $i$ 个月订货单价为 $d_i$，于是我们就建立一个超级源点 $s$，连接第 $i$ 个点，容量是 $\infty$ 费用为 $d_i$ 的边，因为可以无限购买。
2. 由于题目说了，第 $i$ 个月对某产品的需求量为 $U_i$，于是我们就建立一个超级汇点 $t$，第 $i$ 个点连向它，容量是 $U_i$ 费用是 $0$，因为需求无需费用。
3. 由于题目说了，上个月月底未销完的单位产品要付存贮费用 $m$，而且仓库容量为 $S$，于是可以把这个月 $i$ 点储存到下一个月 $i+1$ 点，容量是 $S$，费用是 $m$。

综上建完图大概就是这个样子：

![](https://cdn.luogu.com.cn/upload/image_hosting/5wn1ok3v.png)

最后跑**最小费用最大流**就可以了。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e3+10,M=5e4+10;
int h[N],e[M*2],nx[M*2],f[M*2],c[M*2],A[N];
int cost,m;
int d[N],cur[N],s,t,n,cnt;
int b[N];
inline void add(int u,int v,int w1,int w2){
	e[cnt]=v,f[cnt]=w1,c[cnt]=w2,nx[cnt]=h[u],h[u]=cnt++;
	e[cnt]=u,f[cnt]=0,c[cnt]=-w2,nx[cnt]=h[v],h[v]=cnt++;
}
inline bool spfa(){
	for (int i=s;i<=t;i++) d[i]=1e9;
	d[s]=0;
	cur[s]=h[s];
	queue<int>q;
	q.push(s);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		b[u]=0;
		for (int i=h[u];~i;i=nx[i]){
			int v=e[i],w=c[i];
			if (d[v]>d[u]+w&&f[i]){
				d[v]=d[u]+w;
				cur[v]=h[v];
				if (!b[v]) b[v]=1,q.push(v);
			}
		}
	}
	return d[t]!=1e9;
}
int find(int u,int limit){
	if (u==t) return limit;
	int flow=0;
	b[u]=1;
	for (int i=cur[u];~i&&flow<limit;i=nx[i]){
		int v=e[i],w=f[i];
		cur[u]=i;
		if (!b[v]&&d[v]==d[u]+c[i]&&w){
			int x=find(v,min(w,limit-flow));
			if (!x) d[v]=1e9;
			flow+=x;
			f[i]-=x;
			f[i^1]+=x;
			cost+=x*c[i];
		}
	}
	b[u]=0;
	return flow;
}
inline int dinic(){
	int r=0,flow;
	while(spfa())
		while(flow=find(s,1e9)) r+=flow;
	return r;
}
int u[1234567];
main(){
	int n,m,S;
	cin>>n>>m>>S;
	s=0,t=n+1;
	for (int i=s;i<=t;i++) h[i]=-1;
	for (int i=1;i<=n;i++) cin>>u[i],add(i,t,u[i],0);
	for (int i=1;i<=n;i++) cin>>d[i],add(s,i,1e9,d[i]);
	for (int i=1;i<n;i++) add(i,i+1,S,m);
	dinic();
	cout <<cost;
	return 0;
}
```



---


# [ZJOI2010] 基站选址

## 题目描述

有 $N$ 个村庄坐落在一条直线上，第 $i(i>1)$ 个村庄距离第 $1$ 个村庄的距离为 $D_i$。需要在这些村庄中建立不超过 $K$ 个通讯基站，在第 $i$ 个村庄建立基站的费用为 $C_i$。如果在距离第 $i$ 个村庄不超过 $S_i$ 的范围内建立了一个通讯基站，那么就村庄被基站覆盖了。如果第 $i$ 个村庄没有被覆盖，则需要向他们补偿，费用为 $W_i$。现在的问题是，选择基站的位置，使得总费用最小。


## 说明/提示

### 数据规模与约定

$30\%$ 的数据中，$N \leq 500$；

$100\%$ 的数据中，$K\leq N$，$K\leq 100$，$N\leq 2\times 10^4$，$D_i \leq 10^9$，$C_i\leq 10^4$，$S_i \leq10^9$，$W_i \leq 10^4$。


## 样例 #1

### 输入

```
3 2
1 2
2 3 2
1 1 0
10 20 30```

### 输出

```
4```

# 题解

## 作者：Log_x (赞：67)

##**Solution** DP + 线段树优化

- 记$f[i][j]$表示在第$i$个村庄修建第$j$个基站且不考虑第$i + 1$~$n$个村庄所需的最小费用。

- 则转移方程为$f[i][j] = Min(f[k][j - 1] + cst[k][i]) + c[i](j - 1 \le k < i)$。其中$cst[k][i]$表示第$i$~$k$个村庄之间没有被基站$i, k$覆盖的村庄所需的赔偿费用，计算费用的复杂度为$O(n)$，则总复杂度为$O(n^2k)$。

- 这样显然是不能通过的，我们考虑如何优化：

- 首先我们发现之前的转移方程可以去掉一维$j$，实际上只要在最外层枚举$j$就可以了，也就是$f[i] = Min(f[k] + cst[k][i]) + c[i](j - 1 \le k < i)$。

- 而主要的消耗在计算$cst[k][i]$上，也就是有多少个村庄需要赔偿。

- 对于任意一个村庄$i$，记它所能被覆盖的左右边界$st[i], ed[i]$（**最左端、最右端可以覆盖到$i$的基站位置**，可用二分查找处理），然后在用邻接表记录$ed$值为$i$的村庄有哪些，在这些村庄之前建立基站就覆盖不到$i$了。

- 这样当我们推导$i + 1$时，若从村庄$1$~$st[k] - 1(ed[k] = i)$转移过来则必定要赔偿村庄$k$的费用，我们就可以考虑用线段树来维护$f[k] + cst[k][i]$的值，即在区间$[1, st[k] - 1]$加上村庄$k$的费用，而转移即在区间$[1, i - 1]$找$f[k] + cst[k][i]$的最小值，总复杂度为$O(nlogn \times k)$。

##**Code**

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define sL (s << 1)
#define sR (s << 1 | 1)

using namespace std;
const int Maxn = 0x3f3f3f3f;
const int N = 2e4 + 5, M = N << 2;
int d[N], c[N], w[N], s[N], st[N], ed[N], f[N]; 
int n, k, Ans, val[M], tag[M];

struct point
{
    int to; point *nxt;
}a[M], *T = a, *lst[N]; 

inline void addEdge(const int &x, const int &y) {T->nxt = lst[x]; T->to = y; lst[x] = T++;} 
template <class T> inline T Min(const T &a, const T &b) {return a < b? a : b;}
template <class T> inline void CkMin(T &a, const T &b) {if (a > b) a = b;}

inline int get()
{
    char ch; bool f = false; int res = 0;
    while (((ch = getchar()) < '0' || ch > '9') && ch != '-');
    if (ch == '-') f = true;
     else res = ch - '0';
    while ((ch = getchar()) >='0' && ch <= '9')
        res = (res << 3) + (res << 1) + ch - '0';
    return f? ~res + 1 : res;
}

inline void put(int x)
{
    if (x < 0)
      x = ~x + 1, putchar('-');
    if (x > 9) put(x / 10);
    putchar(x % 10 + 48);
}

inline void Push(const int &s) {val[s] = Min(val[sL], val[sR]);}
inline void Add(const int &s, const int &z) 
{val[s] += z; tag[s] += z;}

inline void Down(const int &s)
{
    if (!tag[s]) return ;
    Add(sL, tag[s]); Add(sR, tag[s]); tag[s] = 0;
}

inline void Build(const int &s, const int &l, const int &r)
{
    tag[s] = 0;
    if (l == r) return (void)(val[s] = f[l]);
    int mid = l + r >> 1;
    Build(sL, l, mid); Build(sR, mid + 1, r);
    Push(s);
}

inline int Query(const int &s, const int &l, const int &r, const int &x, const int &y)
{ 
    if (l == x && r == y) return val[s];
    Down(s); int mid = l + r >> 1; 
    if (y <= mid) return Query(sL, l, mid, x, y);
     else if (x > mid) return Query(sR, mid + 1, r, x, y);
      else return Min(Query(sL, l, mid, x, mid),
                         Query(sR, mid + 1, r, mid + 1, y));
}

inline void Modify(const int &s, const int &l, const int &r, const int &x, const int &y, const int &z)
{
    if (l == x && r == y) return Add(s, z);
    Down(s); int mid = l + r >> 1;
    if (y <= mid) Modify(sL, l, mid, x, y, z);
     else if (x > mid) Modify(sR, mid + 1, r, x, y, z);
      else 
      {
          Modify(sL, l, mid, x, mid, z);
          Modify(sR, mid + 1, r, mid + 1, y, z);
      }
    Push(s);
}

int main()
{
    n = get(); k = get() + 1;
    for (int i = 2; i <= n; ++i) d[i] = get();
    for (int i = 1; i <= n; ++i) c[i] = get();
    for (int i = 1; i <= n; ++i) s[i] = get();
    for (int i = 1; i <= n; ++i) w[i] = get();
    ++n; d[n] = w[n] = Maxn;  
    //当我们推导i时，我们只考虑了它和前面的基站产生的影响
    //这时对于最后一个基站我们不会考虑它和之后的村庄产生的影响
    //则我们可以在最后增加一个村庄
    //保证它必定被作为基站（无建设费用）且不对前面产生影响
    //这样就不会有遗漏的了 
    for (int i = 1; i <= n; ++i)
    {
        st[i] = lower_bound(d + 1, d + n + 1, d[i] - s[i]) - d;
        ed[i] = lower_bound(d + 1, d + n + 1, d[i] + s[i]) - d;
        if (d[ed[i]] > d[i] + s[i]) ed[i]--; addEdge(ed[i], i);
        //lower_bound查找的是大于等于x的第一个数
        //而ed[i]要求的是小于等于x的最后一个数
        //所以判断一下减一就可以了 
    }
    for (int i = 1; i <= k; ++i)
    if (i == 1)
    {
        int res = 0;
        for (int j = 1; j <= n; ++j)
        {
            f[j] = res + c[j];
            for (point *e = lst[j]; e; e = e->nxt)
             res += w[e->to];
         }
         Ans = f[n];
    }
    else 
    {
        Build(1, 1, n); int y;
        for (int j = 1; j <= n; ++j)
        {
            //注意线段树区间的边界条件
            f[j] = (j > i - 1 ? Query(1, 1, n, i - 1, j - 1) : 0) + c[j];
            for (point *e = lst[j]; e; e = e->nxt)
             if (st[y = e->to] > 1) Modify(1, 1, n, 1, st[y] - 1, w[y]);
            //这里其实只要修改区间[i, st[y] - 1]就行了
            //不过询问/修改的区间长对于线段树其实更快 
        }
        CkMin(Ans, f[n]);
    }
    return put(Ans), 0;
}

```

---

## 作者：3493441984zz (赞：54)

# ~~真毒瘤~~

### 这个题目耗了我半天。。结果是线段树打错了。。。

### 略微修改了一下，希望能过审$qwq$
****
# 回归正题：

本蒟蒻用的跟楼上$dalao$们一样:** 线段树$+dp$**

首先当然是先考虑朴素$dp$啦，相信你既然都来做这题了，朴素的方程自然不用我多说，设$f[i][j]$表示在前$i$个村庄内，第$j$个基站建在$i$处的最小费用（不考虑$i$~$n$的赔偿费用等）

方程为：
$$f[i][j]=min(f[k][j-1]+pay[k][i])$$
其中$pay[k][i]$表示从第$k$个村庄到第$i$个村庄的赔偿费用之和

那么我们观察上面这个方程，这个方程是$O(n^2k)$的,可以发现类似于背包问题，是可以滚掉一维，因为发现$f$数组第二维只跟上次的值也就是$j-1$次的值有关，那么我们只要直接利用上一次求出来的值继续$dp$就行了，不需要多开一维，所以$dp$方程自然就化为$$f[i]=min(f[k]+pay[k][i])$$

那么我们继续思考：主要的时间消耗在了哪里？自然是怎么快速计算$pay[k][i]$了

那么我们思考：

对于每一个村庄，都有一个范围内需要建立基站，否则就要赔偿，那么我们设第$i$个村庄的范围为$[L,R]$,如果正在考虑$R$处建不建基站，那么有下列情况：

$1$、不在$R$处设立基站，那么对于村庄$i$来说，上一个基站在$[1,L-1]$这个区间的话，就要赔偿村庄$i$了，因为$[L,R]$这个区间没有建基站，那么我们就要快速的在$[1,L-1]$中区间加村庄$i$的赔偿费用了，我们就以线段树为例啦

$2$、在$R$处建立基站，那么也就相当于最后一个基站设立在$[1,R-1]$这个区间中，找一个费用最小值来转移嘛，还是线段树$qwq$

所以我们要开一个线段树来维护$f+pay$的最小值，要有区间加法和区间查询的操作

那么为了上面的操作，我们还要开几个数组辅助（~~如果你是$dalao$当我没说~~）

$st[i]$表示第$i$个村庄对应区间的左端点$L$

$ed[i]$表示第$i$个村庄对应区间的右端点$R$

那么当$ed_x=i$的时候，如果$i$处不建，那么就要区间加上$pay[x]$的值，然而可能有很多点的$ed$都是$i$，所以我们用链式前向星来保存，具体可以看代码实现

接下来就是美滋滋的代码时间~~~
~~~cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 20007
#define int long long
#define inf 0x3f3f3f3f3f3f3f3f
using namespace std;
struct Edge
{
	int to,nxt;
}edge[N<<2];
struct Tree
{
	int date,mark;
}tr[N<<2];
int n,k,cnt;
int dis[N],val[N],range[N],pay[N],st[N],ed[N],head[N],f[N];
void Add(int u,int v)
{
	edge[++cnt]=(Edge){v,head[u]};
	head[u]=cnt;
}
void Get()
{
	for(int i=1;i<=n;++i)
	{
		st[i]=lower_bound(dis+1,dis+1+n,dis[i]-range[i])-dis;
		ed[i]=lower_bound(dis+1,dis+1+n,dis[i]+range[i])-dis;
		if(dis[ed[i]]>dis[i]+range[i])
			--ed[i];
		Add(ed[i],i);
	}
}
void Pushup(int rt)
{
	tr[rt].date=min(tr[rt<<1].date,tr[rt<<1|1].date);
}
void Build(int rt,int l,int r)
{
	tr[rt].mark=0;
	if(l==r)
	{
		tr[rt].date=f[l];
		return;
	}
	int mid=l+((r-l)>>1);
	Build(rt<<1,l,mid);
	Build(rt<<1|1,mid+1,r);
	Pushup(rt);
}
void Pushdown(int rt)
{
	if(tr[rt].mark)
	{
		tr[rt<<1].date+=tr[rt].mark;
		tr[rt<<1|1].date+=tr[rt].mark;
		tr[rt<<1].mark+=tr[rt].mark;
		tr[rt<<1|1].mark+=tr[rt].mark;
		tr[rt].mark=0;
	}
}
int Search(int rt,int l,int r,int L,int R)
{
//	cout<<"l:"<<l<<" r:"<<r<<" L:"<<L<<" R:"<<R<<endl;
	if(L>R)
		return inf;
	if(L<=l&&r<=R)
		return tr[rt].date;
	int mid=l+((r-l)>>1);
	Pushdown(rt);
	int num=inf;
	if(L<=mid)
		num=min(num,Search(rt<<1,l,mid,L,R));
	if(mid<R)
		num=min(num,Search(rt<<1|1,mid+1,r,L,R));
	return num;
}
void Update(int rt,int l,int r,int L,int R,int c)
{
//	cout<<"l:"<<l<<" r:"<<r<<endl;
	if(L>R)
		return;
	if(L<=l&&r<=R)
	{
		tr[rt].date+=c;
		tr[rt].mark+=c;
		return;
	}
	Pushdown(rt);
	int mid=l+((r-l)>>1);
	if(L<=mid)
		Update(rt<<1,l,mid,L,R,c);
	if(mid<R)
		Update(rt<<1|1,mid+1,r,L,R,c);
	Pushup(rt);
}
void Dp()
{
	int now=0;
	for(int j=1;j<=n;++j)
	{
		f[j]=now+val[j];
		for(int p=head[j];p;p=edge[p].nxt)
		{
			int v=edge[p].to;
			now+=pay[v];
		}
	}
	int ans=f[n];
//	for(int i=1;i<=n;++i)
//	{
//		printf("%d ",f[i]);
//	}
	for(int i=2;i<=k;++i)
	{
		Build(1,1,n);
		for(int j=1;j<=n;++j)
		{
			f[j]=Search(1,1,n,1,j-1)+val[j];
		//	cout<<f[j]<<" ";
			for(int p=head[j];p;p=edge[p].nxt)
			{
				int v=edge[p].to;
				Update(1,1,n,1,st[v]-1,pay[v]);
			}
		}
		ans=min(ans,f[n]);//cout<<"ans:"<<ans<<endl;
	}
	printf("%lld",ans);
}
void Init()
{
	scanf("%lld%lld",&n,&k);
	for(int i=2;i<=n;++i)
		scanf("%lld",&dis[i]);
	for(int i=1;i<=n;++i)
		scanf("%lld",&val[i]);
	for(int i=1;i<=n;++i)
		scanf("%lld",&range[i]);
	for(int i=1;i<=n;++i)
		scanf("%lld",&pay[i]);
	++n;++k;
	dis[n]=pay[n]=inf;
}
signed main()
{
	Init();
	Get();
	Dp();
	return 0;
}
~~~

---

## 作者：BFqwq (赞：42)

# P2605
（不愧是浙江，十年前的题都这么难）

## 思路
看到这样的题目，我们的第一想法应该是分层dp。

令 $f_{i,j}$表示在 $i$ 位置建立第 $j$ 个基站的最小费用。

那么这个转移是显然的:

$$f_{i,j}=\min(f_{k,j-1}+cost_{k,i})(k\in[1,i-1])$$

其中 $cost_{k,i}$ 为在 $k,i$ 两个点中间没有基站所需要的赔偿费用，

而本题最难之处也就在这。

其实楼上的题解讲的很清楚了，我在这儿就做一个自己的阐释吧。

我们定义一个集合 $A_i$，

若 $j\in A_i$ 则表示在 $j$ 建立基站可以覆盖到 $i$。

然后 $st_i,ed_i$ 分别表示 $A_i$ 集合中的最小值和最大值。

（感觉这一点其他几篇题解讲的不清楚qaq）

我们用一棵线段树来维护一下到现在为止的 $\min(f_{k,j-1}+cout_{k,i})$，

具体的方法就是：第 $j$ 层建树的时候，以 $f_{i,j-1}$ 为初始值，

如果 $i=ed_k$ ，那么在线段树上 $[1,st_k-1]$ 的区间 $+w[k]$($w$ 含义见题目)

因为对于后面的点，要是从 $[1,st_k-1]$ 的点转移过来，

那么 $k$ 就无法被覆盖到，所以要加上赔偿费用。

然后我们只要区间查询 $\min(f_{k,j-1}+cout_{k,i})$ 就好了。

一个小小的优化：

我们在 $inf$ 位置建立一个建立基站费用为 $0$，覆盖距离为 $0$ 的基站，就可以起到统计答案的作用。

对应的，$n$ 和 $k$ 都要加一。

## code
好像题解区都是下放标记的。

在这里提供一个标记永久化的写法，供大家参考。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
	register int x=0;
	register bool f=0;
	register char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+c-48;
		c=getchar();
	}
	return f?-x:x;
}
void write(int x){
    if(x<0) putchar('-'), x=-x;
    if(x>=10) write(x/10);
    putchar('0'+x%10);
}
const int maxn=114514;
const int inf=2333333333333333333;
struct seg{
	int v,tag;
}t[maxn<<2];
struct Edge {               
    int to,nxt;
}e[maxn<<2];
int h[110005],cnt,n,m;
inline void add(int from,int to) {
    cnt++;
    e[cnt].nxt=h[from];
    e[cnt].to=to;
    h[from]=cnt;
}
int st[maxn],ed[maxn],f[maxn],d[maxn],c[maxn],s[maxn],w[maxn];
void build(int o,int l,int r){
	t[o].tag=0;
	if(l==r){
		t[o].v=f[l];
		return;
	}
	int mid=l+r>>1;
	build(o<<1,l,mid);
	build(o<<1|1,mid+1,r);
	t[o].v=min(t[o<<1].v,t[o<<1|1].v);
}
void change(int o,int l,int r,int ql,int qr,int v){
	if(ql>qr) return;
	if(ql<=l&&r<=qr){
		t[o].v+=v;
		t[o].tag+=v;
		return;
	}
	int mid=l+r>>1;
	if(ql<=mid) change(o<<1,l,mid,ql,qr,v);
	if(qr>mid) change(o<<1|1,mid+1,r,ql,qr,v);
	t[o].v=min(t[o<<1].v,t[o<<1|1].v)+t[o].tag;
}
int query(int o,int l,int r,int ql,int qr,int tag){
	if(ql>qr) return inf;
	if(ql<=l&&r<=qr){
		return t[o].v;
	}
	int mid=l+r>>1,res=inf;
	if(ql<=mid) res=min(res,query(o<<1,l,mid,ql,qr,tag+t[o].tag));
	if(qr>mid) res=min(res,query(o<<1|1,mid+1,r,ql,qr,tag+t[o].tag));
	return res;
}

signed main(){
	n=read();m=read();
	for(int i=2;i<=n;i++) d[i]=read();
	for(int i=1;i<=n;i++) c[i]=read();
	for(int i=1;i<=n;i++) s[i]=read();
	for(int i=1;i<=n;i++) w[i]=read();
	n++;m++;
	d[n]=w[n]=inf;
	for(int i=1;i<=n;i++){
        st[i]=lower_bound(d+1,d+1+n,d[i]-s[i])-d;
        ed[i]=lower_bound(d+1,d+1+n,d[i]+s[i])-d;
        if(d[ed[i]]>d[i]+s[i])ed[i]--;
        add(ed[i],i);
    }
    int now=0;
    for(int i=1;i<=n;i++){
    	f[i]=now+c[i];
    	for(int j=h[i];j;j=e[j].nxt){
            int v=e[j].to;
            now+=w[v];
        }
	}
	int res=f[n];
	for(int i=2;i<=m;i++){
		build(1,1,n);
		for(int j=1;j<=n;j++){
			f[j]=query(1,1,n,1,j-1,0)+c[j];
			for(int k=h[j];k;k=e[k].nxt){
                int v=e[k].to;
                change(1,1,n,1,st[v]-1,w[v]);
            }
		}
		res=min(res,f[n]);
	}
	write(res);
	return 0;
}
```



















---

## 作者：TheLostWeak (赞：32)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/Luogu2605.html)

**大致题意：** 有$n$个村庄，每个村庄有$4$个属性：$D_i$表示与村庄$1$的距离，$C_i$表示建立基站的费用，$S_i$表示能将其覆盖的建基站范围，$W_i$表示没建设基站所要付出的代价。

### 暴力$DP$

首先我们来考虑一波暴力$DP$。

设$f_{i,j}$为**在前$i$村庄共建$j$个基站且第$i$个村庄必选**所需的最小代价。

为了方便起见，我们定义它不管其之后的代价。

而这样统计答案又略显麻烦。

因此我们可以考虑在最后增加一个节点（$++n$即可），初始化其到村庄$1$的距离$D_i$和没建设基站所要付出的代价$W_i$为$INF$，且建立基站的费用$C_i$和能将其覆盖的建基站范围$S_i$为$0$。

这样初始化的好处在于，选择这个村庄不会受到前面某个村庄的影响，而选择这个村庄又不会对答案造成任何影响。

因此，这个新的节点的答案$f_{n,k+1}$，就是最终答案（之所以要将$k+1$，是因为选择这个新增的节点就相当于额外多选择了一个村庄建基站）。

而就易推得转移方程：

$$f_{i,j}=C_i+min_{k=j-1}^if_{k,j-1}+GetW(k,i)$$

其中$GetW$表示$k$与$i$之间没能被覆盖、要付出额外代价的村庄的$W_i$之和。

这应该比较显然，就相当于枚举一个节点$k$作为上个建立基站的节点，然后大力转移即可。

而$k$从$j-1$开始枚举应该也是比较显然的，因为你至少要有$j-1$个节点才能建$j-1$个基站。

然而这个式子时间复杂度差不多是$O(N^2k)$，压根不可能过。

所以就需要优化。

### 考虑优化

考虑到$i$与$j$的枚举顺序其实不会对答案造成任何影响，且$i$的转移显然比$j$的转移更容易优化。

因此，我们可以将$j$提出到最外面一层，从而转化得到如下式子：

$$f_i=C_i+min_{k=j-1}^iLastf_k+GetW(k,i)$$

其中$Lastf_k$表示的是上一轮$DP$后$f_k$的值。

则对于这个式子，显然是要优化后面求$min$的这个过程。

考虑一个点在什么时候不会被覆盖。

~~这貌似是个智障的问题~~，题目中已经告诉我们，对于第$i$个基站，当距离它$S_i$范围内没有基站时，它就不会被覆盖。

则我们就可以求出$L_x$和$R_x$两个变量，分别表示**最左边和最右边能覆盖到它的节点编号**。（可用$lower\_bound$直接求，可惜我不知道如何处理一些细节问题，于是手写二分）

那么，容易发现，当你到第$R_x+1$个位置时，如果上一个基站的位置$<L_x$，则我们就需要将代价加上$W_x$。

于是乎就可以发现，每次代价需增加的是一段连续的区间。

也就是说，我们需要一个算法或数据结构，能够支持区间加法和区间求和两种操作。

显然线段树。

### 线段树优化

考虑建一棵线段树，对于每一次更新$j$，初始化其为$j-1$时的$f$数组。

然后，当我们操作完一个$i$之后，就要用所有$R_x=i$的$x$去更新选择每个点的代价。

具体操作就是在线段树上将$[j-1,L_x-1]$这段区间权值加$W_x$。

而你要找到所有$R_x=i$的$x$，邻接表即可。

最后每次更新，就是在线段树中询问区间$[j-1,i-1]$中的最小值，然后加上$C_i$即可得到$f_i$。

还有，$j=1$时的答案需要单独预处理。

具体实现可见代码。

### 代码

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define N 20000
#define K 100
#define INF 1e9
#define Gmin(x,y) (x>(y)&&(x=(y)))
#define add(x,y) (e[++ee].nxt=lnk[x],e[lnk[x]=ee].to=y)
using namespace std;
int n,k,ee,d[N+5],c[N+5],s[N+5],w[N+5],L[N+5],R[N+5],f[N+5],lnk[N+5];
struct edge {int to,nxt;}e[N<<1];
class FastIO
{
    private:
        #define FS 100000
        #define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)
        #define tn (x<<3)+(x<<1)
        #define D isdigit(c=tc())
        char c,*A,*B,FI[FS];
    public:
        I FastIO() {A=B=FI;}
        Tp I void read(Ty& x) {x=0;W(!D);W(x=tn+(c&15),D);}
        Ts I void read(Ty& x,Ar&... y) {read(x),read(y...);}
}F;
class SegmentTree//线段树
{
    private:
        #define STO l,hl,rt<<1
        #define ORZ hl+1,r,rt<<1|1
        #define PU(x) (O[x]=O[x<<1]+O[x<<1|1])
        #define PD(x) (O[x].F&&(O[x<<1]+=O[x].F,O[x<<1|1]+=O[x].F,O[x].F=0))
        int n,v[N+5];
        struct Il
        {
            int V,F;I Il (CI v=0,CI f=0):V(v),F(f){}
            I Il operator + (Con Il& t) Con {return Il(min(V,t.V));}
            I void operator += (CI x) {V+=x,F+=x;}
        }O[N<<2];
        I void Build(CI l,CI r,CI rt)
        {
            if(!(l^r)) return (void)(O[rt]=Il(v[l]));
            RI hl=l+r>>1;Build(STO),Build(ORZ),PU(rt);
        }
        I void upt(CI l,CI r,CI rt,CI ul,CI ur,CI v)//区间加法
        {
            if(ul<=l&&r<=ur) return O[rt]+=v;RI hl=l+r>>1;PD(rt);
            ul<=hl&&(upt(STO,ul,ur,v),0),ur>hl&&(upt(ORZ,ul,ur,v),0),PU(rt);
        }
        I int qry(CI l,CI r,CI rt,CI ql,CI qr)//区间求和
        {
            if(ql<=l&&r<=qr) return O[rt].V;RI hl=l+r>>1,res=INF,t;PD(rt);
            return ql<=hl&&(t=qry(STO,ql,qr),Gmin(res,t)),qr>hl&&(t=qry(ORZ,ql,qr),Gmin(res,t)),res;
        }
    public:
        I void Init(CI x,int* s) {for(RI i=1;i<=x;++i) v[i]=s[i];Build(1,n=x,1);}
        I void Update(CI l,CI r,CI v) {l<=r&&(upt(1,n,1,l,r,v),0);}
        I int Query(CI l,CI r) {return l<=r?qry(1,n,1,l,r):0;} 
        #undef STO
        #undef ORZ
}S;
I int GP(CI x)
{
    RI STO=1,hl,ORZ=n;
    W(STO<=ORZ) d[hl=STO+ORZ>>1]<x?(STO=hl+1):ORZ=hl-1;
    return STO;
}
int main()
{
    RI i,j,p,t,ans;for(F.read(n,k),i=2;i<=n;++i) F.read(d[i]);
    for(i=1;i<=n;++i) F.read(c[i]);for(i=1;i<=n;++i) F.read(s[i]);for(i=1;i<=n;++i) F.read(w[i]);
    for(++n,d[n]=w[n]=INF,i=1;i<=n;++i) L[i]=GP(d[i]-s[i]),R[i]=GP(d[i]+s[i]+1)-1,add(R[i],i);//初始化L[i]和R[i]，然后建边
    for(t=0,i=1;i<=n;++i) for(f[i]=t+c[i],p=lnk[i];p;p=e[p].nxt) t+=w[e[p].to];ans=f[n];//预处理j=1时的答案
    for(j=2;j<=k+1;++j,Gmin(ans,f[n])) for(S.Init(n,f),i=1;i<=n;++i)//枚举状态进行转移
        for(f[i]=S.Query(j-1,i-1)+c[i],p=lnk[i];p;p=e[p].nxt) S.Update(j-1,L[e[p].to]-1,w[e[p].to]);//转移，并更新每个点的代价
    return printf("%d",ans),0;//输出答案
}
```



---

## 作者：AlanSP (赞：15)

# 题解 [ZJOI2010] 基站选址

10年后的菜鸡AlanSP做这个题，还是感到神仙……

### **Description**

 有 N 个村庄坐落在一条直线上，第 i(i>1) 个村庄距离第 1个村庄的距离为 $D_i$。需要在这些村庄中建立不超过 *K*个通讯基站，在第 i个村庄建立基站的费用为 $C_i$。如果在距离第 i 个村庄不超过 $S_i$ 的范围内建立了一个通讯基站，那么就村庄被基站覆盖了。如果第 i 个村庄没有被覆盖，则需要向他们补偿，费用为 $W_i$。现在的问题是，选择基站的位置，使得总费用最小。

---

### **Solution**

设$f[i][j]$表示前i个村庄建立j个基站，第i个强制选的最小价值。

经过一番考虑，我们容易得到一下的DP方程：
$$
f[i][j]=\min_{k\in[1,i-1]}\{f[k][j-1]+cost(k,i)\}+c[i]
$$
其中$cost(k,i)$ 表示 $ \sum_{D_k<D_p-S_p\And D_i>D_p+S_p}W[p]$。

时间复杂度$O(n^2k)$。

发现j这一维只有j-1有关，可以提出到外面，分层进行dp，类似01背包。

瓶颈在于如何计算$cost(k,i)$。

---

**规约：**$L[i]$表示能够覆盖到i的左端点，$R[i]$表示能够覆盖到i的右端点。

$L[i],R[i]$可以通过二分第一个大于等于（小于等于）$S_i+D_i$的数。

我们知道，随着i的右移，左边的某些基站便不再能覆盖当前的i。

也就是说每次i有移动，那么$[1,L[i]-1]$里面的f值肯定要加上$W_i$。

对于每次f[i]的转移，可以不用枚举，若是能查询到$[1,i-1]$中f的最小值，那么便可以直接转移。

实现上述操作，区间查询&区间加，我们可以采用线段树来维护。

这样能够做到$O(nk\log n)$。

而对于维护i移动后哪些点会收到影响，也就是维护i是哪些点的R值，我们可以采取邻接表。

因为只要i移动，那些点对于后来的i，肯定要付出$W_i$代价。

而邻接表有效的节省了空间，同样便于插入。

最后补一张图

![](https://cdn.luogu.com.cn/upload/image_hosting/px5oz7np.png)

（P.S. 线段树可以重复利用，每个j决策更新一遍）

---

### **code**

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
#define int long long
#define ls (x<<1)
#define rs (x<<1|1)
const int N=20009,INF=0x3f3f3f3f;
int n,k,d[N],s[N],w[N],c[N],f[N],L[N],R[N],ans,sum;
int nxt[N<<2],ver[N<<2],h[N],tot;
struct Segment_Tree 
{
	int tag,val;
} tr[N<<2];

inline void add(int x,int y)
{
	ver[++tot]=y,nxt[tot]=h[x],h[x]=tot;
}

inline void build(int x,int l,int r)
{
	tr[x].tag=0;
	if(l==r)
	{
		// tr[x].tag=0;
		tr[x].val=f[l];
		return;
	}
	int mid=(l+r)>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	tr[x].val=min(tr[ls].val,tr[rs].val);
}

inline void down(int x,int l,int r)
{
	int c=tr[x].tag;
	tr[ls].tag+=c;
	tr[rs].tag+=c;
	tr[ls].val+=c;
	tr[rs].val+=c;
	tr[x].tag=0;
}

inline int query(int x,int l,int r,int L,int R)
{
	if(L<=l&&r<=R) return tr[x].val;
	int mid=(l+r)>>1,res=INF;
	if(tr[x].tag) down(x,l,r);
	if(L<=mid) res=min(res,query(ls,l,mid,L,R));
	if(R>mid) res=min(res,query(rs,mid+1,r,L,R));
	return res;
}

inline void change(int x,int l,int r,int L,int R,int c)
{
	if(L<=l&&r<=R)
	{
		tr[x].tag+=c;
		tr[x].val+=c;
		return;
	}
	int mid=(l+r)>>1;
	if(tr[x].tag) down(x,l,r);
	if(L<=mid) change(ls,l,mid,L,R,c);
	if(R>mid) change(rs,mid+1,r,L,R,c);
	tr[x].val=min(tr[ls].val,tr[rs].val);
}

signed main()
{
	scanf("%lld%lld",&n,&k);
	for(int i=2;i<=n;i++) scanf("%lld",&d[i]);
	for(int i=1;i<=n;i++) scanf("%lld",&c[i]);
	for(int i=1;i<=n;i++) scanf("%lld",&s[i]);
	for(int i=1;i<=n;i++) scanf("%lld",&w[i]);
	k++,n++;
	d[n]=w[n]=INF;
	s[n]=c[n]=0;
	for(int i=1;i<=n;i++)
	{
		L[i]=lower_bound(d+1,d+1+n,d[i]-s[i])-d;
		R[i]=lower_bound(d+1,d+1+n,d[i]+s[i])-d;
		if(d[R[i]]>d[i]+s[i]) R[i]--;
		// if(i==n) printf("%lld\n",R[n]);
		add(R[i],i);
	}
	// printf("%d %d\n",L[n],R[n]);
	for(int i=1;i<=n;i++)
	{
		f[i]=sum+c[i];//记f[i]为强制选i建基站所最小价值
		for(int j=h[i];j;j=nxt[j])
		{
			sum+=w[ver[j]];	
		}//sum进行累加
	}
	ans=f[n];
	// for(int i=1;i<=n;i++) printf("%d ",f[i]);
	for(int j=2;j<=k;j++)
	{
		build(1,1,n);//每次重新建树
		for(int i=1;i<=n;i++)
		{
			// puts("DEBUG");
			if(i>1) f[i]=query(1,1,n,1,i-1)+c[i];
			else f[i]=INF;
			for(int u=h[i];u;u=nxt[u])
			{
				int v=ver[u];
				if(L[v]>1) change(1,1,n,1,L[v]-1,w[v]);
			}
		}
		ans=min(ans,f[n]);
		// printf("%d\n",f[n]);
	}
	printf("%lld",ans);
	return 0;
}
```

---



---

## 作者：zsaskk (赞：12)

题解第一遍提交没有过，在这里解释一下。

关于“重复做法”，我的确不会别的做法，大概也没有别的做法。

提交这篇题解是因为，我~~自以为~~在一些细节上讲的更加清晰，细致，前面的题解主题思路讲的很好，但是缺乏对细节的照顾，不太容易理解。



------------


~~我还是太年轻了，我曾经以为这道题很水，但我错了。~~

显然可以得到暴力$dp$式子

$f[i][j]=min \{ f[k][j-1]+cost(k,i) \}+c[i]$

其中，$cost(k,i)$表示$k,i$之间接收不到信号的惩罚金额。

如果单单有$min \{ f[k][j-1] \}+c[i]$自然很好处理，但是加上了$cost$就比较难受了。

还是用线段树优化。

线段树上肯定要放上$f[k][j-1]$，不必多说。

定义$pre[x],nxt[x]$分别表示前面第一个能覆盖$x$的基站位置和后面第一个不能覆盖$x$的基站位置，可以用二分查找实现。

当一个村庄再也无法被后面的基站覆盖时，此时我们发现，如果不选$[pre[x],nxt[x]]$之间的村庄就必须支付罚款了，所以这之后的基站建设时，就应当在$[1,pre[x]-1]$上加上$w[x]$。

这表示$x$无法在不选$[pre[x],nxt[x]]$时，即只能在$[1,pre[x]-1]$和$[nxt[x]+1,n]$上选择时，必须支付罚款——这~~完美地~~与我们想要达成的效果相一致。

以上称为操作$A$。

当我们遍历到点$i$时，就应当对以$i$为$nxt[x]$的$x$进行操作$A$，而以$i$为$nxt[x]$的$x$可以用$vector$存储。

而当$j=1$时，我们没有$f[k][j-1]$可供选择，应当单独处理。

空间方面，转移时使用的都是$f[k][j-1]$，可以优化掉第二维。

最后，实际上的转移方程就成了：

$f[i]=query(1,1,n,1,i-1)+c[i]$

$query$里面查询的，自然是$f[k][j-1]+cost(k,i)$的最小值了。

最后，每次进行下一次，即从$j$到枚举$j+1$是，都要重建线段树，把序列赋值为$f[i]$。

------------

以下为代码，~~自认为~~能解释其他题解里没有解释的一下细节。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define reg register
#define int long long
#define inf (1ll<<62)
#define chk_digit(c) (c>='0'&&c<='9')
inline int read() {
	reg int x=0,f=1;reg char c=getchar();
	while(!chk_digit(c)) { if(c=='-') f=-1;c=getchar(); }
	while(chk_digit(c)) x=x*10+c-'0',c=getchar();
	return x*f;
} 
int n,k,d[20002],w[20002],c[20002],s[20002],h[20002],f[20002],tim,l[20002],r[20002],pre[20002],nxt[20002],cnt,ans=inf;
vector<int> p[20002];//p[i]表示以i为最后一个可覆盖的基站的村庄的集合 
struct node{ int minn,tag; }tr[20005<<2];
inline int mymin(int x,int y) { return x>=y?y:x; } 
#define mid (al+ar>>1)
#define lc rt<<1,al,mid
#define rc rt<<1|1,mid+1,ar
inline void pushup(int rt) { tr[rt].minn=mymin(tr[rt<<1].minn,tr[rt<<1|1].minn); } 
inline void pushdown(int rt,int al,int ar) { tr[rt<<1].minn+=tr[rt].tag,tr[rt<<1|1].minn+=tr[rt].tag,tr[rt<<1].tag+=tr[rt].tag,tr[rt<<1|1].tag+=tr[rt].tag,tr[rt].tag=0; }
inline void rebuild(int rt,int al,int ar) {
	if(al==ar) { tr[rt].minn=f[al],tr[rt].tag=0;return; }
	if(tr[rt].tag) pushdown(rt,al,ar);
	rebuild(lc),rebuild(rc),pushup(rt);
}
inline void update(int rt,int al,int ar,int ql,int qr,int val) {
	if(al>qr||ar<ql) return;
	if(al>=ql&&ar<=qr) { tr[rt].minn+=val,tr[rt].tag+=val;return; }
	if(tr[rt].tag) pushdown(rt,al,ar);
	update(lc,ql,qr,val),update(rc,ql,qr,val),pushup(rt);
}
inline int query(int rt,int al,int ar,int ql,int qr) {
	
	if(al>qr||ar<ql) return inf;
	if(al>=ql&&ar<=qr) { return tr[rt].minn; }
	if(tr[rt].tag) pushdown(rt,al,ar);
	int x=mymin(query(lc,ql,qr),query(rc,ql,qr));
	return x;
}//线段树 
signed main() {
	n=read(),k=read();
	for(reg int i=2;i<=n;++i) d[i]=read();d[1]=0;
	for(reg int i=1;i<=n;++i) c[i]=read();
	for(reg int i=1;i<=n;++i) s[i]=read(),l[i]=d[i]-s[i],r[i]=d[i]+s[i];//l[i]表示要想覆盖到i，基站的左侧最远位置 r[i]表示要想覆盖到i，基站的右侧最远位置 
	for(reg int i=1;i<=n;++i) w[i]=read(); 
	++n,++k,d[n]=w[n]=inf,l[n]=r[n]=d[n];
	/*
		这里解释下为什么要++n,++k
		++n是为了方便对f[1->n-1][k-1]进行“总结”，因为n处建基站是不耗费金钱的，也就是说，f[n]最后的取值实际上是上一个k下的最小花费
		++k是为了解决上面提到的f[n]指k-1时的最小值的问题，++k就可以得到k处的最小值 
	*/
	for(reg int i=1;i<=n;++i) pre[i]=lower_bound(d+1,d+n+1,l[i])-d,nxt[i]=upper_bound(d+1,d+n+1,r[i])-d-1,p[nxt[i]].push_back(i);//pre 表示前面第一个能覆盖i的基站 nxt表示后面最后一个能覆盖i的基站 
	int sum=0;
    //k=1阶段
	for(reg int i=1;i<=n;++i) {//状态
		f[i]=sum+c[i];//决策
		int siz=p[i].size();
		for(reg int j=0;j<siz;++j) sum+=w[p[i][j]];//更新cost 
	}
	ans=f[n];
	for(reg int t=2;t<=k;++t) {//阶段
		rebuild(1,1,n);
		for(reg int i=1;i<=n;++i) {  //状态
			if(t!=k||i==n) f[i]=query(1,1,n,1,i-1)+c[i]/*决策*/;//在t=k处，没必要对普通的点继续求值，只需总结t=k-1时的最小值，但还需要维护cost 
			int siz=p[i].size();
			for(reg int j=0;j<siz;++j) update(1,1,n,1,pre[p[i][j]]-1,w[p[i][j]]);//更新cost 
		}
		ans=mymin(ans,f[n]);
	}
	printf("%lld\n",ans);
}
```


---

## 作者：KellyFrog (赞：9)

~~感觉没有黑题的难度吧.......~~

我们首先考虑一个朴素的 DP，一个很显然的想法就是让 $dp_{i,j}$ 表示前 $i$ 个位置，放了 $j$ 个基站，补偿仅考虑下标 $[1,i]$ 中的点的最小花费。

这样我们再从 $i'$ 转移到 $i$ 的时候，再统计下标在 $[i'+1,i-1]$ 中的点的补偿就可以了，不难列出转移方程：

$$
dp_{i,j}=\min_{1\le i'<i}\{dp_{i',j-1}+\operatorname{cost}(i'+1)\}+c_i
$$

其中 $\operatorname{cost}(i'+1)$ 表示在下标在 $[i'+1,i-1]$ 中的点需要支付的补偿和。

如果我们直接在转移的时候暴力 $O(n)$ 求解 $\operatorname{cost}$ 的话，总的复杂度是 $O(n^2k)$ 的，无法通过。

我们不难发现转移的瓶颈是在求解 $\operatorname{cost}$ 上的，我们不妨将其和 $dp_{i',j-1}$ 一起看待，再采用某种方法的在转移的过程中动态维护最小值。

我们不妨令最左边（$dis$ 值最小的）能够覆盖到 $i$ 点的基站位置为 $L_i$，同理最右边（$dis$ 值最大的）能够覆盖到点 $i$ 的基站位置为 $R_i$。那么如果我们在下标在 $[L_i,R_i]$ 中的任意一个点放置了基站，点 $i$ 将被覆盖，不会产生补偿。

我们考虑一个 $L_i,R_i$，在什么时候他会对 $dp_{i',j-1}+\operatorname{cost}(i'+1)$ 的值产生贡献呢？一定是当 $[L_i,R_i]$ 这个区间被 $[i'+1,i-1]$ 这个区间包含的时候会产生贡献。再进一步，当对 $[R_i+1,n]$ 中的 $i$ 进行转移时，会对 $[1,L_i-1]$ 中的 $i'$ 产生影响。

由于我们是顺序枚举 $i$，所以我们只需要在 $i=R_i$ 完成转移以后，将 $[1,L_i-1]$ 中所有 $i'$ 的 $\operatorname{cost}$ 加上 $W_i$ 即可，相当于我们动态维护了 $\operatorname{cost}$ 的值。

我们需要区间加、区间最小值，线段树即可。

需要注意的是最后答案并不是 $dp_{n,k}$，而应该是 $\min_{1\le i\le n}dp_{i,k}+\operatorname{cost}(i)$。

总的复杂度 $O(nk\log n)$。

code（需要 `c++11`）:

```cpp

// Problem: P2605 [ZJOI2010]基站选址
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P2605
// Memory Limit: 125 MB
// Time Limit: 1000 ms ~ 5000 ms
// Powered by CP Editor (https://github.com/cpeditor/cpeditor)

//By luogu @longer_name

#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef long double ldb;
typedef vector<int> vi;
typedef pair<int, int> pii;
#define fi first
#define se second
#define rg register
#define mp make_pair
#define pb push_back
#define pf push_front

#define rep(i, s, t) for(rg int i = s; i <= t; i++)
#define per(i, s, t) for(rg int i = t; i >= s; i--)
#define debug(x) cerr << (#x) << " = " << (x) << "\n"
#define OK cerr << "OK!\n"


namespace fastio {
	const int SIZE = (1 << 20) + 1;
	char ibuf[SIZE], *iS, *iT, obuf[SIZE],*oS = obuf, *oT = obuf + SIZE - 1;
	char _st[55];
	int _qr = 0;

	inline char getchar() {
		return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
	}
	inline void qread() {}
	template <typename T1, typename... T2>
	inline void qread(T1 &x, T2 &...ls) {
		x = 0;
		rg char ch = ' ';
		rg int ps = 1;
		while (!isdigit(ch) && ch != '-') ch = getchar();
		if (ch == '-') ps = -1, ch = getchar();
		while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();
		x *= ps;
		qread(ls...);
	}

	inline void flush() {
		fwrite(obuf, 1, oS - obuf, stdout);
		oS = obuf;
		return ;
	}
	inline void putchar(char _x) {
		*oS++ = _x;
		if(oS == oT) flush();
	}
	template <typename T>
	inline void qwrite(T x) {
		if (x < 0) putchar('-'), x = -x;
		if (x < 10) return putchar('0' + x), void();
		qwrite(x / 10), putchar('0' + (x % 10));
	}

	template <typename T>
	inline void qwrite(T x, char ch) {
		qwrite(x), putchar(ch);
	}
}; //namespace fastio

ll qpow(ll x, ll p, ll mod) {
	rg ll base = x, res = 1;
	while(p) {
		if(p & 1) res = (res * base) % mod;
		base = (base * base) % mod;
		p >>= 1;
	}
	return res;
}

const int N = 2e4 + 5;
const int K = 105;
const ll inf = 1e18;

ll dp[N];
ll mi[N << 2], lazy[N << 2];
ll c[N], s[N], dis[N], w[N];
int n, k;
vector<pair<int, int> > st[N];

void Lazy(int cur, int x) {
	mi[cur] += x;
	lazy[cur] += x;
}

void PushDown(int cur) {
	Lazy(cur << 1, lazy[cur]);
	Lazy(cur << 1 | 1, lazy[cur]);
	lazy[cur] = 0;
}

void PushUp(int cur) {
	mi[cur] = min(mi[cur << 1], mi[cur << 1 | 1]);
}

void Build(int cur, int l, int r) {
	lazy[cur] = 0;
	if(l == r) return mi[cur] = dp[l], void();
	rg int mid = l + r >> 1;
	Build(cur << 1, l, mid);
	Build(cur << 1 | 1, mid + 1, r);
	PushUp(cur);
}

ll Query(int cur, int ql, int qr, int l, int r) {
	if(ql <= l && r <= qr) return mi[cur];
	PushDown(cur);
	rg int mid = l + r >> 1;
	rg ll res = inf;
	if(ql <= mid) res = min(res, Query(cur << 1, ql, qr, l, mid));
	if(mid < qr) res = min(res, Query(cur << 1 | 1, ql, qr, mid + 1, r));
	return res;
}

void Modify(int cur, int ql, int qr, int l, int r, ll x) {
	if(ql <= l && r <= qr) return Lazy(cur, x), void();
	PushDown(cur);
	rg int mid = l + r >> 1;
	if(ql <= mid) Modify(cur << 1, ql, qr, l, mid, x);
	if(mid < qr) Modify(cur << 1 | 1, ql, qr, mid + 1, r, x);
	PushUp(cur);
}

int main() {
	fastio::qread(n, k);
	rep(i, 2, n) fastio::qread(dis[i]);
	dis[0] = -inf, dis[n+1] = inf; //给 lower_bound 和 upper_bound 的边界赋值，避免越界
	rep(i, 1, n) fastio::qread(c[i]);
	rep(i, 1, n) fastio::qread(s[i]);
	rep(i, 1, n) fastio::qread(w[i]);
	rep(i, 1, n) {
		int L = lower_bound(dis, dis + n + 1, dis[i] - s[i]) - dis;
		int R = upper_bound(dis, dis + n + 1, dis[i] + s[i]) - dis - 1;
		st[R].pb(mp(L, i)); //将 Ri 挂在 vector 上
	}
	ll res = 0, ans = inf;
	rep(i, 1, n) {
		dp[i] = res + c[i];
		for(auto x : st[i]) res += w[x.se];
	}
	ans = min(ans, dp[n]);
	rep(j, 1, k) {
		Build(1, 0, n);
		rep(i, 1, n) {
			dp[i] = Query(1, 0, i-1, 0, n) + c[i];
			for(auto x : st[i]) Modify(1, 0, x.fi - 1, 0, n, w[x.se]);
		}
		ans = min(ans, Query(1, 0, n, 0, n));
	}
	fastio::qwrite(ans, '\n');
	fastio::flush();
	return 0;
}
```

---

## 作者：万弘 (赞：8)

由$S,D$可求出$L(i)$表示最左的能覆盖到$i$的基站，$R(i)$表示最右的能覆盖到$i$的基站，显然可以$\mathcal O(n\log n)$预处理。如果$[L(i),R(i)]$中没有基站，则会有$w(i)$的代价。

考虑dp。$f(i,k)$表示在$[1,i]$建立了$k$个基站的最小代价（且$i$必须建，若不合法（如$i<k$）则为INF）  
枚举前一个基站所在位置$j$,则有转移：
$$f(i,k)=\min_{j<i}\{f(j,k-1)+\sum_{j<L(p),R(p)<i}w(p)\}$$
直接暴力做，时间复杂度$\mathcal O(n^3k)$，需要优化.  
可以滚动数组，但对优化时间没什么实际效果。

考虑求出$R$后，在每个$i$保存$Base(i)=\{j|R(j)=i\}$,显然$\sum_i|Base(i)|=n$,可以$\mathcal O(n)$预处理。  
考虑完$i$后，考虑$Base(i)$中的每个元素$x$，如果建的基站$j<L(x)$,则会有$w(x)$的贡献。记$val(i,j,k)$表示在$i$建第$k$个基站，且第$k-1$个基站是$j$,则$[j+1,i-1]$中的没有被信号覆盖的基站的代价。  
那么
$$val(i,j,k)=val(i-1,j,k)+\sum_{x\in Base(i),j<L(x)}w(x)$$
$$f(i,k)=\min_{j<i}\{f(j,k-1)+cost(i,j,k)\}$$

这样就可以$\mathcal O(n^2k)$做了，贴一下这部分的代码：  
PS：可以建一个虚点$n+1$,并强制建立基站，则答案就是$\min_k\{f(n+1,k)\}$
```cpp
bool umin(ll& a,ll b)
{
	if(b<a)return a=b,1;
	return 0;
}
#define MAXN 50011
ll d[MAXN],c[MAXN],s[MAXN],w[MAXN],begin[MAXN];//begin[i]就是L[i]
ll n,K;
std::vector<ll>base[MAXN];
ll f[MAXN],cost[MAXN];//cost[j]表示f(j,k)+val(i,j,k)
int main()
{
	n=read(),K=read();
	for(ll i=2;i<=n;++i)d[i]=read();
	for(ll i=1;i<=n;++i)c[i]=read();
	for(ll i=1;i<=n;++i)
	{
		s[i]=read();
		begin[i]=std::lower_bound(d+1,d+n+1,d[i]-s[i])-d;
		ll to=std::upper_bound(d+1,d+n+1,d[i]+s[i])-d-1;
		base[to].push_back(i);//预处理base
	}
	for(ll i=1;i<=n;++i)w[i]=read();
	++n;++K;d[n]=w[n]=INF;//虚点，距离为INF，建立费用为0，不建的代价为INF，所以一定建立
	//dp
	ll sum=0;
	for(ll i=1;i<=n;++i)//建立第一个基站
	{
		f[i]=sum+c[i];
		for(std::vector<ll>::iterator it=base[i].begin();it!=base[i].end();++it)
			sum+=w[*it];
	}
	ll ans=f[n];
	for(ll k=2;k<=K;++k)//建立第2,3,...k个基站
	{
		for(ll i=1;i<=n;++i)cost[i]=f[i];//f(j,k)
		for(ll i=1;i<=n;++i)
		{
			ll minv=INF;
			for(ll j=1;j<i;++j)umin(minv,cost[j]);
			f[i]=minv+c[i];//转移
			for(std::vector<ll>::iterator it=base[i].begin();it!=base[i].end();++it)
			{
				for(ll j=1;j<begin[*it];++j)cost[j]+=w[*it];//更新val
			}
		}
		umin(ans,f[n]);
	}
	printf("%lld",ans);
	return 0;
}
```

仍然无法AC。但其实到这一步，最终的正解就比较显然。  
`for(ll j=1;j<i;++j)umin(minv,cost[j]);`就是一个区间min的查询；   
`for(ll j=1;j<begin[*it];++j)cost[j]+=w[*it];`就是一个区间加。

用一个区间加，查询区间min的线段树维护$f(j,k-1)+val(i,j,k)$即可在$\mathcal O(kn\log n)$的时间内解决。

另，`for(ll i=1;i<=n;++i)cost[i]=f[i];`对应线段树的建立操作。
```cpp
bool umin(ll& a,ll b)
{
	if(b<a)return a=b,1;
	return 0;
}

/**********/
#define MAXN 50011
ll n,K;
struct Segment_Tree//区间加，查询区间min的线段树
{
	struct node
	{
		ll minv,tag;
	}t[MAXN<<2|1];
	#define rt t[num]
	#define tl t[num<<1]
	#define tr t[num<<1|1]
	void pushup(un num)
	{
		rt.minv=min(tl.minv,tr.minv);
	}
	void pushdown(un l,un r,un num)
	{
		if(!rt.tag)return;
		un mid=(l+r)>>1;
		tl.minv+=rt.tag,tl.tag+=rt.tag;
		tr.minv+=rt.tag,tr.tag+=rt.tag;
		rt.tag=0;
	}
	void build(ll* a,un l=1,un r=n,un num=1)
	{
		rt.tag=0;
		if(l==r)rt.minv=a[l];
		else
		{
			un mid=(l+r)>>1;
			build(a,l,mid,num<<1);build(a,mid+1,r,num<<1|1);
			pushup(num);
		}
	}
	void modify(un ql,un qr,ll val,un l=1,un r=n,un num=1)
	{
		if(ql<=l&&r<=qr)
		{
			rt.minv+=val;
			rt.tag+=val;
			return;
		}
		pushdown(l,r,num);
		un mid=(l+r)>>1;
		if(ql<=mid)modify(ql,qr,val,l,mid,num<<1);
		if(qr>mid)modify(ql,qr,val,mid+1,r,num<<1|1);
		pushup(num);
	}
	ll Qmin(un ql,un qr,un l=1,un r=n,un num=1)
	{
		if(ql>qr)return INF;//区间为空则为INF
		if(ql<=l&&r<=qr)return rt.minv;
		pushdown(l,r,num);
		un mid=(l+r)>>1;
		ll ans=INF;
		if(ql<=mid)umin(ans,Qmin(ql,qr,l,mid,num<<1));
		if(qr>mid)umin(ans,Qmin(ql,qr,mid+1,r,num<<1|1));
		return ans;
	}
}sgt;

ll d[MAXN],c[MAXN],s[MAXN],w[MAXN],begin[MAXN];
std::vector<ll>base[MAXN];
ll f[MAXN],cost[MAXN];
int main()
{
	n=read(),K=read();
	for(ll i=2;i<=n;++i)d[i]=read();
	for(ll i=1;i<=n;++i)c[i]=read();
	for(ll i=1;i<=n;++i)
	{
		s[i]=read();
		begin[i]=std::lower_bound(d+1,d+n+1,d[i]-s[i])-d;
		ll to=std::upper_bound(d+1,d+n+1,d[i]+s[i])-d-1;
		base[to].push_back(i);
	}
	for(ll i=1;i<=n;++i)w[i]=read();
	++n;++K;d[n]=w[n]=INF;
	//dp
	ll sum=0;
	for(ll i=1;i<=n;++i)
	{
		f[i]=sum+c[i];
		for(std::vector<ll>::iterator it=base[i].begin();it!=base[i].end();++it)
			sum+=w[*it];
	}
	ll ans=f[n];
	for(ll k=2;k<=K;++k)
	{
		sgt.build(f);//f(j,k)
		for(ll i=1;i<=n;++i)
		{
			f[i]=sgt.Qmin(1,i-1)+c[i];//注意判断区间是否为空
			for(std::vector<ll>::iterator it=base[i].begin();it!=base[i].end();++it)
			{
				if(1<begin[*it])sgt.modify(1,begin[*it]-1,w[*it]);//区间加
			}
		}
		umin(ans,f[n]);
	}
	printf("%lld",ans);
	return 0;
}
```

为了可读性没有卡常，但完全可以AC。

---

## 作者：LlLlCc (赞：7)

果然，我省十年前的题目放现在还是很难，像我这种**蒟蒻**要看老半天题解才能懂，不过题解里大部分语言都雷同，这篇就换种说法帮助大家理解这道良心好题吧，如果没有有地方没有看明白的欢迎私信或者评论区留言

------------


首先，暴力$DP$还是比较好想到的：

$\quad \Large f_{i,j}=f_{k,j-1}+cost_{k+1,i}$

其中：

- $\large f_{i,j}$ ： 前$i$个村建了$j$个基站，其中第$i$个村必建，所需的最小费用


- $\large cost_{k,j}$: $\large \sum\limits_{i=k}^j w_{i}[d_{k}<d_{i}+s_{i}<d_{j}]$，即中间需要补偿村子的费用

易发现，$j$的那一层可以滚动数组甚至可以**直接去掉**，这样空间就省下来的，不过时间还是没变，稳定$T$飞

这个方程已经很难再化简了，我们不妨换个角度来思考问题

对于每一个村庄来说，**如果这个村庄存在贡献，即$d_{i}-s_{i}$到$d_{i}+s_{i}$之间都没有建基站，显然这是一个区间，不妨设$S_{i}$和$T_{i}$为区间的左右两端**

前面都不难，下面这一步是**最最最关键的一步**，好好消化一下。

考虑**当前枚举到$T_{i}$位置**：

我们可以**把$f_{1}$到$f_{S_{i}-1}$全部加上$w_{i}$，这样如果之后转移时找到的上一个基站位置是小于$S_{i}$的，那么就以为这对于$i$村庄，$d_{i}-s_{i}$到$d_{i}+s_{i}$这段区间是没有建基站的，所以要加上$w_{i}$**（非常重要的一步，好好理解）

这样一来，**原暴力方程中所有的$cost_{k+1}{i}$全部都转移到了$f_{k}$上**，我们只需要**找到$1$到$i-1$中的最小的$f_{j}$即可**

而**区间最小值和区间加都可以用线段树**快速实现，**以$T_{i}$为右端点的村庄可以用动态数组或者邻接表存起来**

下面是$AC$代码，希望大家能够理解：
```
#include<bits/stdc++.h>
#define maxn 20005
#define ll long long
using namespace std;
int S[maxn],T[maxn],n,Size,k,d[maxn],c[maxn],s[maxn],w[maxn],L,R;
ll Ans=1e18,f[maxn],x,Now;
vector<int> Q[maxn];
struct lc{
	int L,R;
	ll x,k;
}tree[maxn<<2];
inline ll read(){
	int ret=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-f;ch=getchar();}
	while (ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
inline void Pre(){
	for (int i=1;i<=n;i++){
		S[i]=lower_bound(d+1,d+n+1,d[i]-s[i])-d;
        T[i]=lower_bound(d+1,d+n+1,d[i]+s[i])-d;
        if (d[T[i]]>d[i]+s[i]) T[i]--;Q[T[i]].push_back(i);
	}
}
inline void down(int k){
	tree[k<<1].x+=tree[k].k;
	tree[k<<1].k+=tree[k].k;
	tree[k<<1|1].x+=tree[k].k;
	tree[k<<1|1].k+=tree[k].k;
	tree[k].k=0;
}
inline void build(int k,int L,int R){
	tree[k].L=L,tree[k].R=R,tree[k].k=tree[k].x=0;
	if (L==R){tree[k].x=f[L];return;}
	int mid=L+R>>1;
	build(k<<1,L,mid),build(k<<1|1,mid+1,R);
	tree[k].x=min(tree[k<<1].x,tree[k<<1|1].x);
}
inline ll Get(int k){
	if (R<L) return 1e18;
	if (tree[k].L>=L&&tree[k].R<=R) return tree[k].x;
	if (tree[k].k) down(k);
	ll Cnt=1e18;int mid=tree[k].L+tree[k].R>>1;
	if (L<=mid) Cnt=min(Cnt,Get(k<<1));
	if (R>mid) Cnt=min(Cnt,Get(k<<1|1));
	tree[k].x=min(tree[k<<1].x,tree[k<<1|1].x);
	return Cnt;
}
inline void change(int k){
	if (R<L) return;
	if (tree[k].L>=L&&tree[k].R<=R){tree[k].k+=x,tree[k].x+=x;return;}
	if (tree[k].k) down(k);
	int mid=tree[k].L+tree[k].R>>1;
	if (L<=mid) change(k<<1);
	if (R>mid) change(k<<1|1);
	tree[k].x=min(tree[k<<1].x,tree[k<<1|1].x);
}
int main(){  
	n=read()+1,k=read()+1;
	for (int i=2;i<n;i++) d[i]=read();
	for (int i=1;i<n;i++) c[i]=read();
	for (int i=1;i<n;i++) s[i]=read();
	for (int i=1;i<n;i++) w[i]=read();
	d[n]=1<<30,w[n]=1<<30;
	Pre();Now=0;
	for (int i=1;i<=n;i++){
		f[i]=Now+c[i],Size=Q[i].size();
		for (int j=0;j<Size;j++) Now+=w[Q[i][j]];
	}
	Ans=f[n];
	for (int t=1;t<k;t++){
		build(1,1,n);
		for (int i=1;i<=n;i++){
			L=1,R=i-1;f[i]=Get(1)+c[i],Size=Q[i].size();
		    for (int j=0;j<Size;j++) L=1,R=S[Q[i][j]]-1,x=w[Q[i][j]],change(1);
		}
		Ans=min(Ans,f[n]);
	}
	printf("%lld",Ans);
	return 0;
}
```


---

## 作者：C20203030 (赞：7)

# ZJOI2010]基站选址
 **NOI/NOI+/CTSC**   ~~胆小勿入~~ 
 
[题目友情链接-lougu](https://www.luogu.org/problemnew/show/P2605)


## 一、题目及数据范围
有N个村庄坐落在一条直线上，第i(i>1)个村庄距离第1个村庄的距离为Di。需要在这些村庄中建立不超过K个通讯基站，在第i个村庄建立基站的费用为Ci。如果在距离第i个村庄不超过Si的范围内建立了一个通讯基站，那么就村庄被基站覆盖了。如果第i个村庄没有被覆盖，则需要向他们补偿，费用为Wi。现在的问题是，选择基站的位置，使得总费用最小。

40%的数据中，N<=500；
100%的数据中，K<=N，K<=100，N<=20,000，Di<=1000000000，Ci<=10000，Si<=1000000000，Wi<=10000。

## 二、暴力做法
这题一看就是dp(暴力也得不了分)，设计dp[i][j]为前i个点均被覆盖，建了j个基站，**且最后一个基站被建立在i点**的最小花费
则**dp[i][j]=min(dp[i][j],dp[k][j-1]+cost+c[i])**,cost为k到i中没被覆盖的点的w之和。

现在的难点在于求cost。我们可以让k从i-1递减，定义l[x]和r[x]为k点能被覆盖区间的左端点和右端点，则当r[x]<i时，说明它不能被i点覆盖，只能被在l[x]到x的范围被覆盖（我们此时的k在x点），所以小于l[x]-1的k点要额外支付w[x]的费用，我们可以O(n)的时间处理每个点的cost信息，时间复杂度O(n^2*k)，得分50，附上代码。

```
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define INF 2e9+5
#define min(x,y) ((x)<(y)?(x):(y))
const int MAXN = 20005, MAXK = 105;
int n,k,d[MAXN],c[MAXN],s[MAXN],w[MAXN],l[MAXN],r[MAXN];
int dp[MAXN][MAXK],cost[MAXN],ans;
int main()
{
    scanf("%d %d",&n,&k);
    for(int i=2; i<=n; i++)
        scanf("%d",&d[i]);
    for(int i=1; i<=n; i++)
        scanf("%d",&c[i]);
    for(int i=1; i<=n; i++)
        scanf("%d",&s[i]);
    for(int i=1; i<=n; i++)
        scanf("%d",&w[i]);
    for(int i=1; i<=n; i++)
    {
        l[i]=lower_bound(d+1,d+1+n,d[i]-s[i])-d;
        r[i]=lower_bound(d+1,d+1+n,d[i]+s[i])-d;
        r[i]-=(d[i]+s[i]<d[r[i]]);
    }
    for(int i=1; i<=n; i++)
    {
        for(int j=1; j<=k; j++)
            dp[i][j]=INF;
        dp[i][0]=dp[i-1][0]+w[i];
    }
    ans=dp[n][0];
    for(int i=1; i<=n; i++)
    {
        memset(cost,0,sizeof cost);
        for(int j=i-1; j>=1; j--) //这里的j就是上文的k，遍历所有k处理出cost
        {
            if(r[j]<i)
                cost[l[j]-1]+=w[j];
        }
        for(int j=i-1; j>=0; j--)
            cost[j]+=cost[j+1];//用后缀和统计w和
        for(int j=1; j<=k && j<=i; j++) //基站数量
        {
            if(j==1)
                dp[i][1]=cost[0]+c[i];
            else
                for(int p=i-1; p>=j-1; p--) //枚举k点
                    dp[i][j]=min(dp[i][j],dp[p][j-1]+cost[p]+c[i]);
            int sum=0;
            for(int p=i+1; p<=n; p++) //统计后面的w和
                if(l[p]>i)
                    sum+=w[p];
            ans=min(ans,dp[i][j]+sum);
        }
    }
    printf("%d\n",ans);
}
```

***

## 三、线段树优化
1.我们发现时间主要用在遍历k和统计cost上，再观察状转方程，dp[i][j]的状态只取决于[j-1]里面的值，所以我们完全可以砍掉第二维，方程就变成了**dp[i]=min(dp[i],dp[k]+cost+c[i])**，但是要注意吧j的枚举放最外层，以限制基站数量。这样还不够，我们发现cost的统计有点区间的感觉，即对于1到l[x]-1的区间加w[x],这就想到了用线段树来搞，这也正好方便查询，最外层跑基站数j，每次再把新的dp存进线段树，对于j个基站的i点，有**dp[i]=query(j-1,i-1)+c[i]**，这样一来，找k的n直接卡成logn，空间也很节省。（注意j=1时单独处理，因为没有第二个基站给i转移）

2.真的不要用define打min，我查询时用min比较query返回值，因为define是直接替换，三目会多次触发递归拿值，**比如min（query(1),query(2)) 就变成了 query(1)<query(2)?query(1):query(2)，时间会大大膨胀**！！导致我一直TLE，感谢（WXK dalao）

第一种写法，全是我自己想的（~~菜鸡+无脑~~ ）    。在更新线段树的值时，先判r[x]=i，即后面的i都不能覆盖到它，就把1到l[x]-1全加w[x],可以先把所以x和r[x]存进a里，按r[x]递增排序，在a中lower_bound大于等于i值的下标loc，如果a[loc].val=i的话，就while往后扫（~~特别菜~~ ）。另外，我们重新处理cost，把它当成在第i个点建基站的i到n的w值之和，更新时用**ans=min(ans,dp[i]+cost[i])**，这个做法实测有效，看代码吧。

```
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define INF 2047483647
const int MAXN = 20005, MAXK = 105;
int read()
{
    int num=0,flag=1;
    char c;
    while((c=getchar())<'0'||c>'9')if(c=='-')flag=-1;
    while(c>='0'&&c<='9')num=(num<<3)+(num<<1)+(c^48),c=getchar();
    return num*flag;
}
int n,k,d[MAXN],c[MAXN],s[MAXN],w[MAXN],l[MAXN],r[MAXN];
int dp[MAXN],cost[MAXN],ans;
struct node
{
    int val,pos;
    bool operator < (node x) const
    {
        return val<x.val;
    }
} a[MAXN];
struct tree
{
    int l,r,val,lazy;
} tr[MAXN*4];
int min(int a,int b)
{
    return a<b?a:b;
}//一定要小心
void build(int l,int r,int i)
{
    tr[i]=tree{l,r,0,0};
    if(l==r)
    {
        tr[i].val=dp[l];
        return ;
    }
    int mid=(l+r)>>1;
    build(l,mid,i<<1);
    build(mid+1,r,i<<1|1);
    tr[i].val=min(tr[i<<1].val,tr[i<<1|1].val);
}
void down(int i)
{
    if(!tr[i].lazy)
        return ;
    tr[i<<1].val+=tr[i].lazy;
    tr[i<<1].lazy+=tr[i].lazy;
    tr[i<<1|1].val+=tr[i].lazy;
    tr[i<<1|1].lazy+=tr[i].lazy;
    tr[i].lazy=0;
}
void add(int l,int r,int i,int c)
{
    if(l>r) return ;
    if(l<=tr[i].l && tr[i].r<=r)
    {
        tr[i].val+=c;
        tr[i].lazy+=c;
        return ;
    }
    if(tr[i].r<l || tr[i].l>r || tr[i].l==tr[i].r)
        return ;
    down(i);
    add(l,r,i<<1,c);
    add(l,r,i<<1|1,c);
    tr[i].val=min(tr[i<<1].val,tr[i<<1|1].val);
}
int query(int l,int r,int i)
{
    if(l<=tr[i].l && tr[i].r<=r)
        return tr[i].val;
    if(tr[i].r<l || tr[i].l>r || tr[i].l==tr[i].r)
        return INF;
    down(i);
    return min(query(l,r,i<<1),query(l,r,i<<1|1));
}
int main()
{
    n=read();
    k=read();
    for(int i=2; i<=n; i++)
        d[i]=read();
    for(int i=1; i<=n; i++)
        c[i]=read();
    for(int i=1; i<=n; i++)
        s[i]=read();
    for(int i=1; i<=n; i++)
        w[i]=read();
    for(int i=1; i<=n; i++)
    {
        l[i]=lower_bound(d+1,d+n+1,d[i]-s[i])-d;
        r[i]=lower_bound(d+1,d+n+1,d[i]+s[i])-d;
        r[i]-=(d[i]+s[i]<d[r[i]]);
        a[i]=node{r[i],i};
    }
    sort(a+1,a+1+n);
    for(int i=1; i<=n; i++)
        ans+=w[i];
    for(int i=n; i>=1; i--)//把n点当成建基站（其实它没建），所以不判断（类比上份代码的cost）
        cost[l[i]-1]+=w[i];
    for(int i=n; i>=1; i--)
        cost[i]+=cost[i+1];//求后缀和
    int now=0;
    for(int i=1; i<=n; i++)
    {
        dp[i]=now+c[i];
        int loc=lower_bound(a+1,a+n+1,node{i,0})-a;
        while(a[loc].val==i)
        {
            now+=w[a[loc].pos];
            loc++;
        }
        ans=min(ans,dp[i]+cost[i]);
    }
    for(int j=2; j<=k; j++)
    {
        build(1,n,1);//每次重新用上一次的dp建线段树
        for(int i=j; i<=n; i++)
        {
            dp[i]=query(j-1,i-1,1)+c[i];//状转
            ans=min(ans,dp[i]+cost[i]);
            int loc=lower_bound(a+1,a+n+1,node{i,0})-a;
            while(a[loc].val==i)//更新
            {
                add(1,l[a[loc].pos]-1,1,w[a[loc].pos]);
                loc++;
            }
        }
    }
    printf("%d\n",ans);
}

```

第二种写法，某些神仙想出来的，我们建一个理想村（~~乌托邦~~ ），用它来帮我们**统计最优状态**，有**ans=min(ans,dp[n])**（注意这里的n是加过一的），我们只需要把n和k加1，把d和w赋成INF，就行了（不用cost），代码量也减少了很多。另外，我们可以用图论的方式更新线段树（what hell？？），在lower_bound的时候，**把i和r[i]连一条有向边**，访问r[i]时可以直接取到i（不知道方便了多少）

```
#include <cstdio>
#include <algorithm>
using namespace std;
#define INF 2e9+5
const int MAXN = 20005;
int n,k,d[MAXN],c[MAXN],s[MAXN],w[MAXN],l[MAXN],r[MAXN];
int f[MAXN],tot,dp[MAXN];
struct node
{
    int v,next;
} e[MAXN];
struct tree
{
    int val,lazy;
} tr[MAXN*4];
int min(int a,int b)
{
    return a<b?a:b;
}
void build(int i,int l,int r)
{
    tr[i].val=tr[i].lazy=0;
    if(l==r)
    {
        tr[i].val=dp[l];
        return ;
    }
    int mid=(l+r)>>1;
    build(i<<1,l,mid);
    build(i<<1|1,mid+1,r);
    tr[i].val=min(tr[i<<1].val,tr[i<<1|1].val);
}
void down(int i)
{
    if(!tr[i].lazy) return ;
    tr[i<<1].val+=tr[i].lazy;
    tr[i<<1].lazy+=tr[i].lazy;
    tr[i<<1|1].val+=tr[i].lazy;
    tr[i<<1|1].lazy+=tr[i].lazy;
    tr[i].lazy=0;
}
void add(int l,int r,int L,int R,int i,int c)
{
    if(l>r) return;
    if(l<=L && R<=r)
    {
        tr[i].val+=c;
        tr[i].lazy+=c;
        return ;
    }
    if(R<l || r<L) return ;
    down(i);
    int mid=(L+R)>>1;
    add(l,r,L,mid,i<<1,c);
    add(l,r,mid+1,R,i<<1|1,c);
    tr[i].val=min(tr[i<<1].val,tr[i<<1|1].val);
}
int query(int l,int r,int L,int R,int i)
{
    if(l<=L && R<=r)
        return tr[i].val;
    if(R<l || r<L)
        return INF;
    down(i);
    int mid=(L+R)>>1;
    return min(query(l,r,L,mid,i<<1),query(l,r,mid+1,R,i<<1|1));
}
int main()
{
    scanf("%d %d",&n,&k);
    for(int i=2; i<=n; i++)
        scanf("%d",&d[i]);
    for(int i=1; i<=n; i++)
        scanf("%d",&c[i]);
    for(int i=1; i<=n; i++)
        scanf("%d",&s[i]);
    for(int i=1; i<=n; i++)
        scanf("%d",&w[i]);
    n++;
    k++;
    d[n]=INF;
    w[n]=INF;
    for(int i=1; i<=n; i++)
    {
        l[i]=lower_bound(d+1,d+1+n,d[i]-s[i])-d;
        r[i]=lower_bound(d+1,d+1+n,d[i]+s[i])-d;
        r[i]-=(d[i]+s[i]<d[r[i]]);
        e[++tot]=node{i,f[r[i]]},f[r[i]]=tot;
    }
    int now=0,ans=0;
    for(int i=1; i<=n; i++)
    {
        dp[i]=now+c[i];
        for(int p=f[i]; p; p=e[p].next)
            now+=w[e[p].v];
    }
    ans=dp[n];
    for(int j=2; j<=k; j++)
    {
        build(1,1,n);
        for(int i=j; i<=n; i++)
        {
            dp[i]=query(j-1,i-1,1,n,1)+c[i];
            for(int p=f[i]; p; p=e[p].next)
                add(1,l[e[p].v]-1,1,n,1,w[e[p].v]);
        }
        ans=min(ans,dp[n]);
    }
    printf("%d\n",ans);
}

```


---

## 作者：y2823774827y (赞：6)

## 安利博客$\Longrightarrow\Longrightarrow\Longrightarrow$[更好的阅读体验](https://www.cnblogs.com/y2823774827y/p/10274063.html)

简化题目：1~n个村庄，每个村庄有范围，要求范围内有村庄被选（不超过$k$个），否则被罚款，选村庄有一定花费，求最小总花费


讲一讲心路历程吧，应该会好理解的：

**朴素**
$dp_{i,j}$第$j$个被选的村庄为$i$的最小花费：$dp_{i,k}=min\{dp_{j,k-1}+cost_{i,j}\}+w_i$

枚举$k$(准备选第$k$个)，$i$(具体选$i$)，$j$(上一个被选的)，显然$cost_{i,j}$预处理$O(n^2)$，枚举方程$O(n^2k)$

时间复杂度度估为$O(n^2k)$

**优化**
习惯地，只出现$k$与$k-1$，倒序枚举$j$：$dp_{i}=min\{dp_{j}+cost_{i,j}\}+w_i$，还只是优化了点空间而已

最外层$k$其实差不多可以不管了$(k<=100)$，主要是优化刚才的这个方程

无后效性，顺序也显然$(j<i)$，考虑这部分$min\{dp_{j}+cost_{i,j}\}$，最值有关的（$BIT$/线段树，单调队列，斜率优化......）

有哪些相同的部分可以利用呢？

假设这次是选$x$，上一次选$i$，那$i$前面的我们暂时不管，因为之前已经计算过了，我们只用考虑$i$~$k$中间的赔款

对于上一次选的位置$i$和$j$，如果$i<j$，上一个选$i$的赔款肯定包括了$\longrightarrow$上一个选$j$的赔款

理解：$i$~$x$比$j$~$x$中间的空区比较多

已经接近了我们的最终思路，假设我们这次在做第$k$个选$i$，设以$i$为右端点的村庄为$x$，其左端点为$L$，那我们

将$1$~$L-1$都加上$pay_{x}$村庄$x$的赔款：选$1$~$L-1$的村庄就不符合$x$

诶！！区间查询最小值及位置，区间修改好像线段树做会比较简单

至此，我们已经得到了最终解法：最外层枚举$k$(选第k个)，第二层枚举选$i$(选第i个村庄)，然后线段树维护选每个点的赔款及区间最小值

### [Code](https://www.cnblogs.com/y2823774827y/p/10274063.html)

---

## 作者：Sweetie_Liu (赞：5)

## 免责声明，含借鉴成分，不喜勿喷

**鸣谢二楼dalao思路，和一楼大佬一句话点醒梦中人**

[题面](https://www.luogu.org/problem/P2605)

**一句话题意，$n$个村子，最多建$K$个$B$站，每个村子有一个接受范围，颓不了$B$站就要发您的款，建$B$站要花钱。**

一道数据结构优化Dp的好题啊。

既然是Dp优化，我们就一步一步的来。

我们设$dp_{i,j}$从$1$开始到$i$为建$j$个$B$站且$i$点建$B$站的最小费用

设$Sum_{i,k}$为$i$到$j$没有被覆盖的村子的罚款和。

方程：$dp_{i,j} = max(dp_{k,j-1},Sum_{k,i})+C_i$

复杂度为$O(n^2k)$至于那个$Sum_{k,i}$这东西您随便搞，想咋搞咋搞。

这显然大数据跑一辈子

**优化**

我们在思考过之后，发现复杂度瓶颈在于求解上面那个想咋搞咋搞的东西。

我们先求出一个村子的极限接收范围，这东西肯定有用，二分轻松处理。

既然是最值，我们就像$set$单调队列线段树，一开始我是想到单调队上去了，然后发现，卧槽看错题了。

我们考虑那些要罚款的影响，首先从1到左边界-1的转移的肯定覆盖不到它了，**如果$i$的也盖不到它就要罚款了。于是一个村子对其之前的影响是在右端点不选时更新的**。

于是**我们将所有右端点为$i$的点挂在一个边表上**，于是我们就可以用线段树去维护在不选点$i$时前面的影响。

我们在**更新不选$i$点之前先更新$f_i$的值，之后我们去遍历它的边表，对每个边表上值的左端点之前的区间加上村子$i$的罚款**。

感性的理解一下就是，$f_i$就相当于$i$到$j$中间不选照成的影响加上$f_j$

在配合这代码应该可以明白$90%$的，细节再琢磨一下应该还是可以完全消化的。

***Code***

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <map>
#include <set>
#include <vector>
#define int long long
using namespace std;
int read(){
	int w=1,x=0,ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')w=-1;
	for(;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';
	return x*w;
}
const int MAXN = (int)2e4+10;
int n,m,D[MAXN],C[MAXN],S[MAXN],W[MAXN],f[MAXN];
int t[MAXN<<2],tag[MAXN<<2];
#define lson rt<<1
#define rson rt<<1|1
void Add(const int &rt,const int &val){
	t[rt] += val;
	tag[rt] += val;
}
void pushdown(const int &rt){
	if(!tag[rt])return;
	Add(lson,tag[rt]),Add(rson,tag[rt]);
	tag[rt] = 0;
}
void updata(const int &rt){
	t[rt] = min(t[lson],t[rson]);
}
void build(const int &rt,const int &l,const int &r){
	tag[rt] = 0;
	if(l==r){
		t[rt] = f[l];
		return;
	}
	int mid = l+r >> 1;
	build(lson,l,mid);
	build(rson,mid+1,r);
	updata(rt);
}
void modify(const int &rt,const int &l,const int &r,const int &x,const int &y,const int &val){
	if(x<=l&&r<=y){
		Add(rt,val);
		return;
	}
	pushdown(rt);
	int mid = l+r >> 1;
	if(x<=mid)modify(lson,l,mid,x,y,val);
	if(y>mid)modify(rson,mid+1,r,x,y,val);
	updata(rt);
}
int query(const int &rt,const int &l,const int &r,const int &x,const int &y){
	if(x<=l&&r<=y){
		return t[rt];
	}
	pushdown(rt);
	int mid = l+r >> 1,ans = 0x3f3f3f3f;
	if(x<=mid)ans = min(ans,query(lson,l,mid,x,y));
	if(y>mid)ans = min(ans,query(rson,mid+1,r,x,y));
	return ans;
}
struct Edge{
	int from,to,nxt;
	Edge(const int &a,const int &b,const int &c){
		from = a;
		to = b;
		nxt = c;
	}Edge(){
	}
}E[MAXN];
int head[MAXN],tot;
inline void Add_Edge(const int &x,const int &y){
	E[++tot] = Edge(x,y,head[x]),head[x] = tot;
}
int st[MAXN],ed[MAXN];
signed main(){
	n = read(),m = read()+1;
	D[1] = 0;
	for(int i=2;i<=n;i++)D[i] = read();
	for(int i=1;i<=n;i++)C[i] = read();
	for(int i=1;i<=n;i++)S[i] = read();
	for(int i=1;i<=n;i++)W[i] = read();
	++n;D[n] = W[n] = 0x3f3f3f3f;
	for(int i=1;i<=n;i++){
		st[i] = lower_bound(D+1,D+1+n,D[i]-S[i]) - D;
		ed[i] = upper_bound(D+1,D+1+n,D[i]+S[i]) - D - 1;
		Add_Edge(ed[i],i);
	}
	int Ans = 0x3f3f3f3f;
	for(int j=1;j<=m;j++){
		if(j==1){
			int res = 0;
			for(int i=1;i<=n;i++){
				f[i] = res + C[i];
				for(int k = head[i];k;k=E[k].nxt){
					res += W[E[k].to];
				}
			}
			Ans = f[n];
		}else {
			build(1,1,n);
			for(int i=1;i<=n;i++){
				f[i] = (i>(j-1)?query(1,1,n,j-1,i-1):0)+C[i];
				for(int k = head[i];k;k=E[k].nxt){
					if(st[E[k].to]>1)modify(1,1,n,1,st[E[k].to]-1,W[E[k].to]);
				}
			}
			Ans = min(Ans,f[n]);
		}
	}
	printf("%lld\n",Ans);
	return 0;
}
```
***見てくれてありがとう***

---

## 作者：Rainybunny (赞：4)

// $Dear$管理员, 刚修了一下错, 记得还是放在第一篇哟!(~~滑稽~~)

## DP + 比DP长几倍的优化---线段树
终于找到考试的原题, 考场上也一眼看出来是DP:  
**设$dp(i,j)$为处理完前$i$个村子, 且使用了$j$座基站的最小花费**, 则:
$$
dp(i,j)=min\lbrace dp(k,j-1)+\sum_{k<p<i}w_p[d_k<d_p-s_p\&\&d_p+s_p<d_i]+c_i \rbrace
$$
其中$1\leq k<i$, ~~易知此为显然~~, 没有思路的小伙伴可以尝试一下这样的暴力$DP$, 但毕竟$O(kn^2)$ 的期望得分仅$40$分 ( 实测$50$分 ), 我们需要想想**优化**.  
  
  首先, 可以发现$dp$数组可以**化简成一维**, 因为$dp(i,j)$仅与$dp(i,j-1)$有关. ( 这类似于背包问题的化简 ). 那么:  
$$
dp(i)=min\lbrace dp(k)+\sum_{k<p<i}w_p[...]+c_i \rbrace
$$
当然啦, 记得**把枚举使用基站数(被消去的$j$)的循环丢到最外层**.  
  
~~内存不慌了, 时间仍然滑稽.~~  
观察状态转移方程, $\sum_{k<p<i}w_p[...]$明显非常讨厌. 如何维护一个不停更新的区间条件求和的最小值呢?  
**线段树!**(考验诸君第六感的时间到了$qwq$)  
如果一颗已经维护到$i$的线段树摆在面前, 我们需要丢进去哪些东西以维护$i+1$呢?  
答案: 需要考虑**恰好能被第$i$个村子的基站覆盖却不能被第$i+1$个覆盖到的情况**.  

于是定义两个数组$L, R$, 分别保存第$i$个村子**最远能被左侧的$L_i$, 右侧的$R_i$所覆盖**.  
输入完毕之后, 这两个数组便可以**二分**求得了.  
( 作为二分死活打不对的非酋, 安利一下[$lower\_bound$函数](https://baike.baidu.com/item/lower_bound/8620039?fr=aladdin). )  
此后, 我们还需要**保存右侧 ( 因为循环是从左至右的 ) 最远被$i$覆盖的所有村子的编号**.  
( 可以直接建单向边$<R_i,i>$, 亦或用$vector$储存. )  

After that, 当维护出$dp(i)$之后, 我们枚举每个右侧最远被$i$覆盖的村子 ( 令为$v$ ), 首先明确: **$v$不会再受到右侧基站的覆盖了**.  
所以对于每个**不能从左侧覆盖**$v$的$k$号村, ( 即, 所有$k\in\lbrack 1,L_v)$ ), 都需要为$v$额外支付$w_i$的补偿金, 把线段树上$\lbrack 1,L_v)$的点都加上$w_i$即可.  
  
最后讨论$dp(i)$的转移, 相信答案已经很明显了, 设以$Query(l,r)$询问树上$l$到$r$的最小值, 则:
$$
dp(i)=Query(1,i-1)+c_i
$$
注意当**只立一个基站时要特殊处理**,后令答案$Ans=dp(n)$, 每次外层循环都保留一次$dp(n)$的最小值即可.  
  
完结撒花, 并且, $long\,long!$ $long\,long!$ $long\,long!$  

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

namespace Optimize { // 请跳过这段风骚的优化模板吧! 
	#define Eps 1e-8
	#define Int register int
	#define INTMAX 0x7fffffff
	#define LLMAX 0x7fffffffffffffff
	#define Type template<typename _T>

	#ifdef _GLIBCXX_MAP
	#define mapiter( _Tk, _Tv ) map<_Tk, _Tv> :: iterator
	#define map_foreach( keytype, valuetype, mapname, itname )\
		for ( mapiter ( keytype, valuetype ) itname = mapname.begin (); it != mapname.end (); ++ it )
	#endif

	#ifdef _GLIBCXX_SET
	#define setiter( _T ) set<_T> :: iterator
	#define set_foreach( settype, setname, itname )\
		for ( setiter ( settype ) itname = setname.begin (); it != setname.end (); ++ it )
	#endif

	#ifdef _GLIBCXX_VECTOR
	#define veciter( _T ) vector<_T> :: iterator
	#define vec_foreach( vectype, vecname, itname )\
		for ( veciter ( vectype ) itname = vecname.begin (); it != vecname.end (); ++ it )
	#endif
	
	#define FileClose() fclose ( stdin ), fclose ( stdout )
	#define FileOpen( fname ) freopen ( fname".in", "r", stdin ), freopen ( fname".out", "w", stdout )

	typedef long double LD;
	typedef long long int LL;
	typedef unsigned long long int uLL;

	Type inline _T Abs ( const _T x ) { return x < 0 ? -x : x; }
	Type inline _T Max ( const _T a, const _T b ) { return a > b ? a : b; }
	Type inline _T Min ( const _T a, const _T b ) { return a < b ? a : b; }
	Type inline void Swap ( _T& a, _T& b ) { _T t = a; a = b, b = t; }
	Type inline _T rint () {
		_T x = 0; int f = 1; char s = getchar ();
		while ( s < '0' || '9' < s ) f = s == '-' ? -1 : 1, s = getchar ();
		while ( '0' <= s && s <= '9' ) x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar ();
		return x * f;
	}
	#define rll rint<LL> ()
	#define rint rint<int> ()
	Type inline void wint ( _T x ) {
		if ( x < 0 ) putchar ( '-' ), x = ( ~ x ) + 1;
		if ( 9 < x ) wint ( x / 10 );
		putchar ( x % 10 + '0' );
	}
}

using namespace std;
using namespace Optimize;

const int MAXN = 20000, MAXC = 10000, MAXD = 1000000000, MAXW = 100000, MAXK = 100;
int N, K, D[MAXN + 5] = {}, C[MAXN + 5] = {}, S[MAXN + 5] = {}, W[MAXN + 5] = {}, L[MAXN + 5] = {}, R[MAXN + 5] = {};
// 为了避免花式重名, 请忍耐这奇特的大写字母们
int Cnte, Head[MAXN + 5] = {}; // 这里采用建边的方式储存 
LL DP[MAXN + 5] = {};

struct Edge {
	int To, _nxt;
} Graph[MAXN + 5] = {};

struct Segment_Tree { // 线段树 
	struct Node {
		int l, r; // 所维护的区间 
		LL Val, Lazy; // Val表示最小值, Lazy为懒标记 
		Node () {}
	} *Tree;
	inline void Build ( const int i, const int l, const int r, const int SizeofTree = 0 ) { // 建树 
		if ( i == 1 ) {
			delete Tree; // 如果用指针的话, 因为要反复建树, 记得删除原来的那颗! 
			Tree = new Node[SizeofTree] ();
		}
		Tree[i].l = l, Tree[i].r = r, Tree[i].Lazy = 0; // 基本信息 
		if ( l == r ) {
			Tree[i].Val = DP[l]; // 继承上一层DP的答案 
			return ;
		}
		int Mid = ( l + r ) >> 1;
		this -> Build ( i << 1, l, Mid );
		this -> Build ( i << 1 | 1, Mid + 1, r );
		Tree[i].Val = Min ( Tree[i << 1].Val, Tree[i << 1 | 1].Val ); // 合并 
	}
	inline void Spread ( const int i ) { // 懒标记下传(我觉得Spread这个词比Pushdown好看qwq) 
		if ( ! Tree[i].Lazy ) return ;
		Tree[i << 1].Val += Tree[i].Lazy;
		Tree[i << 1 | 1].Val += Tree[i].Lazy;
		Tree[i << 1].Lazy += Tree[i].Lazy;
		Tree[i << 1 | 1].Lazy += Tree[i].Lazy;
		Tree[i].Lazy = 0;
	}
	inline void Update ( const int i, const int l, const int r, const int x ) { // 更新 
		if ( r < Tree[i].l || l > Tree[i].r ) return ;
		if ( l <= Tree[i].l && Tree[i].r <= r ) {
			Tree[i].Val += x;
			Tree[i].Lazy += x;
			return ;
		}
		this -> Spread ( i );
		this -> Update ( i << 1, l, r, x );
		this -> Update ( i << 1 | 1, l, r, x );
		Tree[i].Val = Min ( Tree[i << 1].Val, Tree[i << 1 | 1].Val ); // 记得合并 
	}
	inline LL Query ( const int i, const int l, const int r ) {
		if ( l > r || r < Tree[i].l || l > Tree[i].r ) return LLMAX - INTMAX; // 因为出去要加上建基站的花费, 直接return LLMAX会出事情 
		if ( l <= Tree[i].l && Tree[i].r <= r ) {
			return Tree[i].Val;
		}
		this -> Spread ( i );
		LL lret = this -> Query ( i << 1, l, r );
		LL rret = this -> Query ( i << 1 | 1, l, r );
		return Min ( lret, rret );
	}
} SegTree;

inline void Link ( const int From, const int To ) { // 连(单向)边 
	Graph[++ Cnte].To = To;
	Graph[Cnte]._nxt = Head[From];
	Head[From] = Cnte;
}

inline void Work () { // (不要问为什么rint连括号都不打, 它就是一个乖巧的快读qwq) 
	N = rint, K = rint; 
	for ( Int i = 2; i <= N; ++ i ) {
		D[i] = rint;
	}
	for ( Int i = 1; i <= N; ++ i ) {
		C[i] = rint;
	}
	for ( Int i = 1; i <= N; ++ i ) {
		S[i] = rint;
	}
	for ( Int i = 1; i <= N; ++ i ) {
		W[i] = rint;
	}
	++ N, ++ K, D[N] = MAXD + 5, W[N] = MAXW + 5; // 为了计算靠后村子的花费, 默认一个距离无限远的村子(梗王: 幻想乡?) 
	for ( Int i = 1; i <= N; ++ i ) {
		L[i] = lower_bound ( D + 1, D + N + 1, D[i] - S[i] ) - D;
		R[i] = lower_bound ( D + 1, D + N + 1, D[i] + S[i] ) - D;
		R[i] -= ( D[R[i]] > D[i] + S[i] ); 
		Link ( R[i], i ); // 储存, 建边 
	}
	LL Sum = 0;
	for ( Int i = 1; i <= N; ++ i ) { // 预处理一个基站 
		DP[i] = Sum + C[i];
		for ( Int j = Head[i]; j; j = Graph[j]._nxt ) {
			Sum += W[Graph[j].To]; 
		}
	}
	LL Ans = DP[N];
	for ( Int i = 2; i <= K; ++ i ) { // 重头戏DP! 
		SegTree.Build ( 1, 1, N, N << 2 ); // 建树 
		for ( Int j = 1; j <= N; ++ j ) { // 枚举前j个村子 
			DP[j] = SegTree.Query ( 1, 1, j - 1 ) + C[j]; // 转移的DP[j] 
			int v;
			for ( Int k = Head[j]; k; k = Graph[k]._nxt ) { // 遍历即将被"抛弃"的村子 
				if ( L[v = Graph[k].To] > 1 ) {
					SegTree.Update ( 1, 1, L[v] - 1, W[v] ); // 增加补偿金 
				}
			}
		}
		Ans = Min ( Ans, DP[N] ); // 保留最优解 
	}
	wint ( Ans ), putchar ( '\n' ); // 输出 
}

int main () {
	Work ();
	return 0;
}
```

---

## 作者：miaowey (赞：3)

my\_blog: <http://blog.csdn.net/miaomiao\_ymxl/article/details/54710869>

思路：

一.
应该不难想到DP, f[i][j]表示第i个村庄上建第j个基站，不考虑i后面的村庄，所需最小费用

转移： f[i][j] = f[k][j-1] + solve(i与k之间没有覆盖的村庄所需费用)(1<=k< i)

效率：O(n2k)，40分做法


二.
考虑优化，难点在于solve的计算。可以发现，对于每一个在村庄i前的村庄k，考虑i对它的影响，随着i的增大，它的右端点可能不可达到i。所以当达不到i时，考虑前面的村庄对它的影响，当i的前一个建基站的村庄的位置在k的左端点左方时，这个村庄不能被覆盖，需加上W[k]。

因此想到用线段树维护，每次对于一个i，枚举每一个以i为右端点的t，用区间加法在线段树中把t的左端点左方的村庄加上w[t]

效率：O(nlog(n)k)，100分做法

其他细节及实现见代码
























```cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
#define lc (o<<1)
#define rc (o<<1|1)
#define pb push_back
#define Set(a, v) memset(a, v, sizeof(a))
#define For(i, a, b) for(int i = (a); i <= (int)(b); i++)
#define MAXK (100+5)
#define MAXN (20000+5)
#define INF 0x3f3f3f3f
void read(int &x){
    char ch = getchar();
    while(ch < '0' || ch > '9') ch = getchar();
    x = 0;
    while(ch >= '0' && ch <= '9'){
        x = x*10+ch-'0';
        ch = getchar();
    }
}
int D[MAXN], C[MAXN], S[MAXN], W[MAXN], lr[MAXN], rr[MAXN], f[MAXN];
vector<int> vq[MAXN];
int ql, qr;
struct Seg_tree{
    int Min[MAXN*4], add[MAXN*4];
    void build(int o, int L, int R){
        if(L == R){
            add[o] = 0; Min[o] = f[L]; return;
        }
        int mid = (L+R)>>1;
        build(lc, L, mid); build(rc, mid+1, R);
        add[o] = 0; Min[o] = min(Min[lc], Min[rc]);
    }
    void maintain(int o, int L, int R){
        if(L!=R) Min[o] = min(Min[lc], Min[rc]); Min[o] += add[o];
    }
    void update(int o, int L, int R, int v){
        if(ql <= L && qr >= R) add[o] += v;
        else{
            int mid = (L+R)>>1;
            if(ql <= mid) update(lc, L, mid, v);
            if(qr > mid) update(rc, mid+1, R, v);  
           }
        maintain(o, L, R);
    }
    int query(int o, int L, int R, int Add){
        if(ql <= L && qr >= R) return Min[o]+Add;
        int ret = INF, mid = (L+R)>>1;
        if(ql <= mid) ret = min(ret, query(lc, L, mid, Add+add[o]));
        if(qr > mid) ret = min(ret, query(rc, mid+1, R, Add+add[o]));
        return ret;
    }
}ST;
int main(){
#ifndef ONLINE_JUDGE
    freopen("test.in", "r", stdin);
    freopen("test.out", "w", stdout);
#endif
    int n, k;
    read(n); read(k);
    For(i, 2, n) read(D[i]); For(i, 1, n) read(C[i]);
    For(i, 1, n) read(S[i]); For(i, 1, n) read(W[i]); 
    n++; k++;
    D[n] = INF;
    For(i, 1, n){
        lr[i] = lower_bound(D+1, D+n+1, D[i]-S[i])-D;
        rr[i] = lower_bound(D+1, D+n+1, D[i]+S[i])-D;
        if(D[i]+S[i] < D[rr[i]]) rr[i]--;
        vq[rr[i]].pb(i);
    }
    int ans = INF;
    For(j, 1, k){
        if(j == 1){
            int tot = 0;
            For(i, 1, n){
                f[i] = tot+C[i];
                For(tmp, 0, vq[i].size()-1) tot += W[vq[i][tmp]];
            }
            ans = min(ans, f[n]);
            continue;
        }
        ST.build(1, 1, n);
        For(i, 1, n){
            ql = 1; qr = i-1;
            int add = qr? ST.query(1, 1, n, 0): 0;
            f[i] = add+C[i];
            For(tmp, 0, vq[i].size()-1){
                ql = 1; qr = lr[vq[i][tmp]]-1;
                if(qr > 0) ST.update(1, 1, n, W[vq[i][tmp]]);
            }
        }
        ans = min(ans, f[n]);
    }
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：Celtic (赞：2)

DP+线段树

先考虑朴素的 DP ，设 $f_{i,j}$ 表示在 $i$ 建第 $j$ 个基站，前 $i$ 个村庄的消耗。

显然状态转移方程 $f_{i,j}=min\{f_{k,j-1}+cost(k,i)\}+c_i$。其中 $cost(i,j)$ 表示对于 $i,j$ 之间的村庄只有 $i$ 和 $j$ 建立了基站的补偿费用。

为了方便统计答案，在无穷远处我们新建立一个村庄，在它上建立基站的费用为 $0$ ，补偿费用为正无穷，被覆盖的范围为 $0$，对应的 $n$ 和 $m$ 都要 $+1$ ，最终的答案为 $min\{f_{n,j}\}$。

由于转移只用到了 $f_{k,j-1}$ 所以我们考虑分层进行 DP ，把第二维压掉，即 $f_{i}=min\{f_{k}+cost(k,i)\}+c_i $。



现在我们考虑如何快速计算 $cost(k,i)$。

对于一个村庄，建立基站后能覆盖它的村庄应该是连续的一段区间，设这个区间起始点为 $st_i$ ，结束点为 $ed_i$ ，这两个数组可以二分求出。

当第 $i$ 个村庄决策完毕后，我们枚举所有 $ed_k=i$ 的村庄 $k$ ，这个可以用链表来枚举，那如果后面的点在 $1$ 到 $st_k-1$ 这个区间内决策，必然要加上点 $k$ 的赔偿，于是在线段树中 $1$ 到 $st_k-1$ 这个区间加上 $w_k$，对第 $i$ 个村庄进行决策我们使用线段树来求出前面的最小值再加上 $c_i$ 即为当前层的 $f_i$。

总时间复杂度 $\Theta(m\times n\log n)$

$\sf{Code}$
```cpp
#include<bits/stdc++.h>
#define N 2001001
#define MAX 2001
#define inf 1e18
#define re register
using namespace std;
typedef long long ll;
typedef double db;
const ll maxn=200000;
inline void read(register ll &ret)
{
    ret=0;register ll pd=0;register char c=getchar();
    while(!isdigit(c)){pd|=c=='-';c=getchar();}
    while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c&15);c=getchar();}
    ret=pd?-ret:ret;
    return;
}
ll n,m,d[N],c[N],s[N],w[N],st[N],ed[N],f[N],ans;
vector<ll>v[N];
struct node
{
	ll l,r,mid,val;
	ll tag;
}seg[N];
inline void pushup(re ll pos)
{
	seg[pos].val=min(seg[pos<<1].val,seg[pos<<1|1].val);
	return;
}
inline void build(re ll pos,re ll l,re ll r)
{
	seg[pos].l=l,seg[pos].r=r,seg[pos].mid=l+r>>1,seg[pos].tag=0;
	if(l==r)
		seg[pos].val=f[l];
	else
	{
		build(pos<<1,l,seg[pos].mid);
		build(pos<<1|1,seg[pos].mid+1,r);
		pushup(pos);
	}
	return;
}
inline void add(re ll pos,re ll num)
{
	seg[pos].val+=num,seg[pos].tag+=num;
	return;
}
inline void pushdown(re ll pos)
{
	add(pos<<1,seg[pos].tag);
	add(pos<<1|1,seg[pos].tag);
	seg[pos].tag=0;
	return;
}
inline void upgrade(re ll pos,re ll l,re ll r,re ll num)
{
	if(seg[pos].l>=l&&seg[pos].r<=r)
		return add(pos,num);
	else if(seg[pos].l>r||seg[pos].r<l)
		return;
	pushdown(pos);
	upgrade(pos<<1,l,r,num);
	upgrade(pos<<1|1,l,r,num);
	pushup(pos);
	return;
}
inline ll query(re ll pos,re ll l,re ll r)
{
	if(seg[pos].l>=l&&seg[pos].r<=r)
		return seg[pos].val;
	else if(seg[pos].l>r||seg[pos].r<l)
		return inf;
	pushdown(pos);
	return min(query(pos<<1,l,r),query(pos<<1|1,l,r));
}
signed main()
{
	read(n);
	read(m);
	for(re int i=2;i<=n;i++)
		read(d[i]);
	for(re int i=1;i<=n;i++)
		read(c[i]);
	for(re int i=1;i<=n;i++)
		read(s[i]);
	for(re int i=1;i<=n;i++)
		read(w[i]);
	n++,m++;
	d[n]=w[n]=inf;
	for(re int i=1;i<=n;i++)
	{
		st[i]=lower_bound(d+1,d+n+1,d[i]-s[i])-d;
		ed[i]=upper_bound(d+1,d+n+1,d[i]+s[i])-d-1;
		v[ed[i]].push_back(i);
	}
	re ll now=0;
	for(re int i=1;i<=n;i++)
	{
		f[i]=now+c[i];
		for(re int j=0;j<v[i].size();j++)
		{
			re ll to=v[i][j];
			now+=w[to];
		}
	}
	ans=f[n];
	for(re int i=2;i<=m;i++)
	{
		build(1,1,n);
		for(re int j=1;j<=n;j++)
		{
			f[j]=query(1,1,j-1)+c[j];
			for(re int k=0;k<v[j].size();k++)
			{
				re ll to=v[j][k];
				upgrade(1,1,st[to]-1,w[to]);
			}
		}
		ans=min(ans,f[n]);
	}
	printf("%lld\n",ans);
	exit(0);
}
```



---


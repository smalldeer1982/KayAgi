# 最长不下降子序列问题

## 题目描述

给定正整数序列 $x_1 \ldots, x_n$。

1. 计算其最长不下降子序列的长度 $s$。
2. 如果每个元素只允许使用一次，计算从给定的序列中最多可取出多少个长度为 $s$ 的不下降子序列。
3. 如果允许在取出的序列中多次使用 $x_1$ 和 $x_n$（其他元素仍然只允许使用一次），则从给定序列中最多可取出多少个**不同的**长度为 $s$ 的不下降子序列。

令 $a_1, a_2, \ldots, a_s$ 为构造 $S$ 时所使用的下标，$b_1, b_2, \ldots, b_s$ 为构造 $T$ 时所使用的下标。且 $\forall i \in [1,s-1]$，都有 $a_i \lt a_{i+1}$，$b_i \lt b_{i+1}$。则 $S$ 和 $T$ **不同**，当且仅当 $\exists i \in [1,s]$，使得 $a_i \neq b_i$。

## 说明/提示

$1 \le n\le 500$

## 样例 #1

### 输入

```
4
3 6 2 5```

### 输出

```
2
2
3```

# 题解

## 作者：zcysky (赞：120)

题解来自网络流24题：

【问题分析】


第一问时LIS，动态规划求解，第二问和第三问用网络最大流解决。


【建模方法】


首先动态规划求出F[i]，表示以第i位为开头的最长上升序列的长度，求出最长上升序列长度K。


1、把序列每位i拆成两个点<i.a>和<i.b>，从<i.a>到<i.b>连接一条容量为1的有向边。

2、建立附加源S和汇T，如果序列第i位有F[i]=K，从S到<i.a>连接一条容量为1的有向边。

3、如果F[i]=1，从<i.b>到T连接一条容量为1的有向边。

4、如果j>i且A[i] < A[j]且F[j]+1=F[i]，从<i.b>到<j.a>连接一条容量为1的有向边。


求网络最大流，就是第二问的结果。把边(<1.a>,<1.b>)(<N.a>,<N.b>)(S,<1.a>)(<N.b>,T)这四条边的容量修改为无穷大，再求一次网络最大流，就是第三问结果。


【建模分析】


上述建模方法是应用了一种分层图的思想，把图每个顶点i按照F[i]的不同分为了若干层，这样图中从S出发到T的任何一条路径都是一个满足条件的最长上升子序列。

由于序列中每个点要不可重复地取出，需要把每个点拆分成两个点。单位网络的最大流就是增广路的条数，所以最大流量就是第二问结果。

第三问特殊地要求x1和xn可以重复使用，只需取消这两个点相关边的流量限制，求网络最大流即可。

```cpp
#include<bits/stdc++.h>
#define inf 1000000007
#define N 2000005
#define M 505
using namespace std;
struct Edge{
    int u,v,next,f;
}G[N];
int head[N],tot=0,a[M],dp[M],n,len,s,t,ans;
void addedge(int u,int v,int f){
    G[tot].u=u;G[tot].v=v;G[tot].f=f;G[tot].next=head[u];head[u]=tot++;
    G[tot].u=v;G[tot].v=u;G[tot].f=0;G[tot].next=head[v];head[v]=tot++;
}
int level[100*M];
bool bfs(int s,int t){
    memset(level,0,sizeof(level));
    queue<int>q;q.push(s);level[s]=1;
    while(!q.empty()){
        int u=q.front();q.pop();
        if(u==t)return 1;
        for(int i=head[u];i!=-1;i=G[i].next){
            int v=G[i].v,f=G[i].f;
            if(level[v]==0&&f)q.push(v),level[v]=level[u]+1;
        }
    }
    return 0;
}
int dfs(int u,int maxf,int t){
    if (u==t)return maxf;
    int rat=0;
    for (int i=head[u];i!=-1&&rat<maxf;i=G[i].next){
        int v=G[i].v;int f=G[i].f;
        if (level[v]==level[u]+1&&f){
            int Min=min(maxf-rat,f);
            f=dfs(v,Min,t);
            G[i].f-=f;G[i^1].f+=f;rat+=f;
        }
    }
    if (!rat)level[u]=N;
    return rat;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]),dp[i]=1;
    for(int i=1;i<=n;i++)
    for(int j=1;j<i;j++)
    if(a[j]<=a[i])dp[i]=max(dp[i],dp[j]+1);
    for(int i=1;i<=n;i++)len=max(len,dp[i]);
    printf("%d\n",len);
    s=0;t=5000;
    memset(head,-1,sizeof(head));
    for(int i=1;i<=n;i++)if(dp[i]==1)addedge(s,i,1);
    for(int i=1;i<=n;i++)if(dp[i]==len)addedge(i+n,t,1);
    for(int i=1;i<=n;i++)addedge(i,i+n,1);
    for(int i=1;i<=n;i++)
    for(int j=1;j<i;j++)
    if(a[j]<=a[i]&&dp[j]+1==dp[i])addedge(j+n,i,1);
    while(bfs(s,t))ans+=dfs(s,inf,t);printf("%d\n",ans);
    addedge(1,1+n,inf);addedge(s,1,inf);
    if(dp[n]==len)addedge(n,n*2,inf),addedge(n*2,t,inf);
    while(bfs(s,t))ans+=dfs(s,inf,t);
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Isonan (赞：38)

原题传送门[>Here<](https://www.luogu.org/problemnew/show/P2766)

一道网络流问题，第一问暴力LIS；

对于第二问，很容易发现我们的目的是把每一个LIS表示成一条从源点到汇点的弧，同时保证每个点只用一次。可以考虑把每个点拆开，将点$i$拆成两个点$i_x,i_y$，

1.从源点向每个$f[i]=1$的$i_x$点建边，流为1；

2.从每个$i_x$向$i_y$建边，流为1；

3.对于每对$i,j(i>j)$，当num[i]>=num[j]且f[i]==f[j]+1时，从$j_y$向$i_x$建边，流为1；

4.从$f[i]=S$的$i_y$向汇点建边，流为1.

举个例子：

num = 1 2 3 2 4
f   = 1 2 3 3 4

![](https://cdn.luogu.com.cn/upload/pic/28522.png)

满足条件的路径长这样：

![](https://cdn.luogu.com.cn/upload/pic/28523.png)

可以发现这种建图保证了我们想要的两个性质，所以在图上跑一边网络流就是第二问的答案了。

对于第三问，我们发现限制一个点选定次数的只有它与源点、汇点的连边，以及拆出来的两个点的连边。于是我们把$<S,1_x>$，$<1_x,1_y>$,$<n_x,n_y>$以及$<n_y,T>$（如果有的话）的流改为inf就可以过第三问了。

代码：

```cpp
#include <cstdio> 
#include <cstring>
#define min(X,Y) ((X)<(Y)?(X):(Y))
#define max(X,Y) ((X)>(Y)?(X):(Y))

int dis[2001],head[2001],nxt[600001],b[600001],v[600001],S,T,num[501],n,k=1,f[501];
int q[2001],h,t,p[2001],maxn;
void push(int s,int t,int val){
	nxt[++k]=head[s];
	head[s]=k;
	b[k]=t;
	v[k]=val;
}
void link(int s,int t,int val){
	push(s,t,val);
	push(t,s,0);
}
bool bfs(){
	memset(dis,0,sizeof dis);
	dis[S]=1;
	h=t=0;
	q[++t]=S;
	while(h<t){
		++h;
		for(int i=head[q[h]];i;i=nxt[i])
			if(v[i]&&!dis[b[i]]){
				dis[b[i]]=dis[q[h]]+1;
				q[++t]=b[i];
				if(b[i]==T)return 1;
			}
	}
	return 0;
}
int dfs(int x,int flow){
	if(x==T||!flow)return flow;
	int used=0;
	for(int i=p[x];i;i=nxt[i])
		if(v[i]&&dis[b[i]]==dis[x]+1){
			int w=dfs(b[i],min(flow-used,v[i]));
			v[i]-=w;
			v[i^1]+=w;
			used+=w;
			if(w)p[x]=i;
			if(used==flow)return used;
		}
	if(!used)dis[x]=0;
	return used;
}
int main(){
	scanf("%d",&n);
	S=0,T=n+n+1;
	for(int i=1;i<=n;i++)scanf("%d",num+i);
	for(int i=1;i<=n;i++){
		for(int j=1;j<i;j++)
			if(num[j]<=num[i]&&f[j]>f[i])f[i]=f[j];
		f[i]++;
		maxn=max(maxn,f[i]);
	}
	printf("%d\n",maxn);
	for(int i=1;i<=n;i++)link(i,i+n,1);
	for(int i=1;i<=n;i++)if(f[i]==1)link(S,i,1);
	for(int i=1;i<=n;i++)if(f[i]==maxn)link(i+n,T,1); 
	for(int i=1;i<=n;i++)
		for(int j=1;j<i;j++)
			if(num[j]<=num[i]&&f[j]==f[i]-1)link(j+n,i,1);
	int ans=0;
	while(bfs()){
		memcpy(p,head,sizeof p);
		ans+=dfs(S,0x7f7f7f7f);
	}
	printf("%d\n",ans);
	link(1,1+n,0x7f7f7f7f),link(S,1,0x7f7f7f7f);
	if(f[n]==maxn)link(n+n,T,0x7f7f7f7f),link(n,n+n,0x7f7f7f7f);
	while(bfs()){
		memcpy(p,head,sizeof p);
		ans+=dfs(S,0x7f7f7f7f);
	}
	printf("%d\n",ans);
}
```

---

## 作者：fy0123 (赞：16)

第一问用普通DP可以解决

第二、三问 用网络最大流解决

【建模方法】


首先动态规划求出F[i]，表示以第i位为开头的最长上升序列的长度，求出最长上升序列长度K。


1、把序列每位i拆成两个点<i.a>和<i.b>，从<i.a>到<i.b>连接一条容量为1的有向边。

2、建立附加源S和汇T，如果序列第i位有F[i]=K，从S到<i.a>连接一条容量为1的有向边。

3、如果F[i]=1，从<i.b>到T连接一条容量为1的有向边。

4、如果j>i且A[i] < A[j]且F[j]+1=F[i]，从<i.b>到<j.a>连接一条容量为1的有向边。


求网络最大流，就是第二问的结果。把边(<1.a>,<1.b>)(<N.a>,<N.b>)(S,<1.a>)(<N.b>,T)这四条边的容量修改为无穷大，再求一次网络最大流，就是第三问结果。


【建模分析】


上述建模方法是应用了一种分层图的思想，把图每个顶点i按照F[i]的不同分为了若干层，这样图中从S出发到T的任何一条路径都是一个满足条件的最长上升子序列。由于序列中每个点要不可重复地取出，需要把每个点拆分成两个点。单位网络的最大流就是增广路的条数，所以最大流量就是第二问结果。第三问特殊地要求x1和xn可以重复使用，只需取消这两个点相关边的流量限制，求网络最大流即可。


---

## 作者：caeious (赞：10)

~~本人思路清奇。发题解纪念~~
## 分析
首先很直观地想到一个不下降子序列就对应到将$x_1$到$x_n$排成一排后的一条路径，同时序列中后一个数不小于前一个数，所以我们可以从点i到i后面所有满足$x_j \geq x_i$的点连边，则第一问所求即为该DAG中的最长链长度。如果把边权都赋为-1，再添加点S，T，S与每个点连权为0的边，每个点与T连权为0的边，第一问的答案便是S到T的最短路的相反数加1。样例对应的图如下：  
![](https://cdn.luogu.com.cn/upload/pic/33833.png)  
那么第二、三问呢?  
### 拆点
在第二问中，注意到取出的若干条不下降子序列不能有公共点，所以我们通过拆点在顶点处添加流量限制，尝试将最大数量化归为最大流来解决。  
但如果单单是最大流，没有办法保证每条增广路都是“最长”的，所以每次增广必须沿S-T的最短路，可以写一个类似费用流的东西，发现最短路长度变了就停止。然而本人写这题时不会费用流，yy了某奇怪解法：先以S为源跑spfa，记S到点i的最短路$dis_i$，则删除$e(u,v)|dis_u + c(e) > dis_v$,就可保证所有S-T路径都是“最长”的。至于上图$x_i$和$x_j$间的边，由于两端不可能同时被选两次，容量设为1即可，与S，T相连的边其实设为1也够了不过为了适应第三问，本处设为$\infty$。样例对应的图如下： 
![](https://cdn.luogu.com.cn/upload/pic/33843.png)  
下面考虑第三问，首先解释一下问题：**出题人的意思是取尽可能多的不同的不下降子序列**，不然样例都得输出inf（不停地取"3, 5"）。  
当第一问答案为1,即$dis_T = 0$时，答案显然为n。否则将1i-1o的边以及ni-no的边容量改为$\infty$后原图的S-T最大流即为所求。有元素不是$x_1,x_n$的序列显然对应图中的一条流量1的增广路，而所有元素都属于{$x_1,x_n$}的序列由于边1o-ni容量为1，也对应了一条流量1的增广路。这里有个trick，将若干边容量增加后只需在残余网络上继续跑最大流就行了，所得流量加上第二问结果就是答案。
## 复杂度
最短路中，$|V| = n + 2, |E| = O(n^2)$,spfa复杂度$O(kn^2)$,因为该图是个DAG，可以通过dp达到$O(n^2)$.  
流网络中，$|V|,|E|$与最短路的图同阶，因为点数不多，dinic没有问题。  
~~所以实际上与楼下几位一样~~
## 代码
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
#include <vector>
#include <utility>
#include <string>
#include <set>
#define maxn 505
#define maxv 1005
using namespace std;
typedef long long ll;
typedef pair<int,int> P;
const int inf = 0x3f3f3f3f;
int n,a[maxn];
struct edge{
	int to,cap,cst,rev;//这里为了方便，把两个图合到一起了，cap->容量，cst->花费，rev->反向边。
	bool zheng;//是否为正向边。
};
int dis[maxv];
bool inque[maxv];
vector <edge> adj[maxv];
int lev[maxv],iter[maxv];
void spfa(int s){
	memset(dis,0x3f,sizeof(dis));
	dis[s] = 0;
	queue <int> que;
	que.push(s);
	inque[s] = true;
	while(!que.empty()){
		int u = que.front();que.pop();
		inque[u] = false;
		for(int i=0;i<adj[u].size();i++){
			edge &e = adj[u][i];
			if(!e.zheng) continue;
			if(dis[u] + e.cst < dis[e.to]){
				dis[e.to] = dis[u] + e.cst;
				if(!inque[e.to]){
					inque[e.to] = true;
					que.push(e.to);
				}
			}
		}
	}
}
void addedge(int u,int v,int c,int d){//起点，终点，容量，费用。
	adj[u].push_back((edge){v,c,d,adj[v].size(),true});
	adj[v].push_back((edge){u,0,-d,adj[u].size() - 1,false});
}
//------------------------------------Dinic--------------------------------------
void bfs(int s){
	memset(lev,0x3f,sizeof(lev));
	lev[s] = 0;
	queue <int> que;
	que.push(s);
	while(!que.empty()){
		int u = que.front();que.pop();
		for(int i=0;i<adj[u].size();i++){
			edge &e = adj[u][i];
			if(e.cap && lev[u] + 1 < lev[e.to]){
				lev[e.to] = lev[u] + 1;
				que.push(e.to);
			}
		}
	}
}
int dfs(int u,int t,int f){
	if(u == t) return f;
	for(int &i = iter[u];i<adj[u].size();i++){
		edge &e = adj[u][i];
		if(e.cap && lev[u] < lev[e.to]){
			int b = dfs(e.to,t,min(f,e.cap));
			if(b == 0) continue;
			e.cap -= b;
			adj[e.to][e.rev].cap += b;
			return b;
		}
	}
	return 0;
}
int dinic(int s,int t){
	int res = 0;
	while(true){
		bfs(s);
		if(lev[t] == inf) return res;
		memset(iter,0,sizeof(iter));
		while(true){
			int b = dfs(s,t,inf);
			if(b == 0) break;
			res += b;
		}
	}
}
//----------------------------------End of Dinic--------------------------------
int main(){
  scanf("%d",&n);
  for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    int S = 0,T = n * 2 + 1;
	//1 ... n: in
	//n+1 ... n+n: out.
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			if(a[j] >= a[i]) addedge(i + n,j,1,-1);
		}
	}
	for(int i=1;i<=n;i++){
		addedge(S,i,inf,0);
		addedge(i,i + n,1,0);
		addedge(i + n,T,inf,0);
	}
	spfa(S);
	for(int i=S;i<=T;i++){
		for(int j=0;j<adj[i].size();j++){
			edge &e = adj[i][j];
			if(e.zheng && dis[i] + e.cst > dis[e.to]){
				e.cap = 0;//删边
			}
		}
	}
	printf("%d\n",-dis[T] + 1);
	int ans = dinic(S,T);
	printf("%d\n",ans);
	if(dis[T] == 0){
		printf("%d\n",ans);
		return 0;
	}
	for(int i=0;i<adj[1].size();i++){
		edge &e = adj[1][i];
		if(e.zheng) e.cap = inf;//加流量。
	}
	for(int i=0;i<adj[n].size();i++){
		edge &e = adj[n][i];
		if(e.zheng) e.cap = inf;
	}
	ans += dinic(S,T);
	printf("%d\n",ans);
  return 0;
}
```

---

## 作者：hkr04 (赞：9)

第一问，求出最长不下降子序列长度$s$。我知道你会用$O(nlogn)$的复杂度求它，但是仔细想想，这么做以后，后面怎么建图呢？我怎么知道两个点是否都在最长的不下降子序列上呢？回想一下朴素的$O(n^2)$的做法，状态$f_i$表示以$a_i$结尾的最长子序列长度。假如$i\le j,a_i\le a_j,f_i+1=f_j$，说明$f_j$是由$f_i$转移而来的，进而说明在以$a_j$结尾的最长不下降子序列的前一位可以是$a_i$。  

第二问，限制每个点只能用一次，求最长不下降子序列数目。这里需要拆点，为了防止出现以下情况：
![example](https://cdn.luogu.com.cn/upload/image_hosting/euq4420k.png)  
只需要加上一个虚点限制该点的出流只能为1，即可解决：
![example2](https://cdn.luogu.com.cn/upload/image_hosting/j4t0pge8.png)  
考虑源点与$f_i=1$的点相连，$f_i=s$的点与汇点相连；点与点之间根据上述转移条件连边。将所有边的边权都设为1。这样，从$s$到$t$的单位流量就表示存在1个经过的每个点只用1次的合法方案，每条路径之间一定不会有交点。  

第三问，由于$x_1$和$x_n$可以重复使用，且它们只能作为第一个或最后一个存在于序列中，所以若它们与源点或汇点之间有连边，将边权设为$inf$即可。

代码：
```cpp
#include <cstdio>
#include <cstring>
const int maxn=500+10;
const int maxm=1e6+10;
const int INF=0x3f3f3f3f;
int a[maxn],f[maxn],dep[maxn<<1];
int cur[maxn<<1],head[maxn<<1],to[maxm],nxt[maxm],val[maxm];
int tot=1,cnt=0;
int n,s,t;
struct Queue
{
	int a[maxn<<1];
	int l,r;
	Queue() {l=1,r=0;}
	void push(int x) {a[++r]=x;}
	void pop() {l++;}
	int front() {return a[l];}
	bool empty() {return l>r;}
}q;

int min(int x,int y) {return x<y?x:y;}
int max(int x,int y) {return x>y?x:y;}
void add(int u,int v,int w)
{
	nxt[++tot]=head[u];
	head[u]=tot;
	to[tot]=v;
	val[tot]=w;
}
bool bfs()
{
	memset(dep, 0x3f, sizeof(dep));
	dep[s]=0;
    q=Queue();
	q.push(s);
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for (int i=head[u];i;i=nxt[i])
		{
			int v=to[i];
			if (val[i]&&dep[v]>dep[u]+1)
			{
				dep[v]=dep[u]+1;
				q.push(v);
			}
		}
	}
	return dep[t]!=INF;
}
int dfs(int u,int minf)
{
	if (u==t||!minf)
		return minf;

	int used=0;
	for (int &i=cur[u];i;i=nxt[i])
	{
		int v=to[i];
		if (val[i]&&dep[v]==dep[u]+1)
		{
			int flow=dfs(v, min(minf-used, val[i]));
			if (!flow)
				continue;
			used+=flow;
			val[i]-=flow;
			val[i^1]+=flow;
			if (used==minf)
				break;
		}
	}
	return used;
}
int main()
{
	scanf("%d",&n);
	s=0,t=2*n+1;
	for (int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for (int i=1;i<=n;i++)
		f[i]=1;
	int sum=1;
	for (int i=1;i<=n;i++)
		for (int j=i-1;j>=1;j--)
			if (a[j]<=a[i])
				f[i]=max(f[i], f[j]+1);
	for (int i=1;i<=n;i++)
		sum=max(sum, f[i]);
	if (sum==1)
	{
		printf("%d\n%d\n%d\n",sum,n,n);
		return 0;
	}
	printf("%d\n",sum);
	for (int i=1;i<=n;i++)
	{
		add(i, i+n, 1),add(i+n, i, 0);
		if (f[i]==1)
			add(s, i, 1),add(i, s, 0);
		if (f[i]==sum)
			add(i+n, t, 1),add(t, i+n, 0);
		for (int j=i+1;j<=n;j++)
			if (a[i]<=a[j]&&f[i]+1==f[j])
				add(i+n, j, 1),add(j, i+n, 0);
	}
	int ans=0;
	while(bfs())
	{
		for (int i=s;i<=t;i++)
			cur[i]=head[i];
		ans+=dfs(s, INF);
	}
	printf("%d\n",ans);
	ans=0;
	for (int i=2;i<=tot;i++)
	{
		if (i&1)
			val[i]=0;
		else
			val[i]=to[i]==1||to[i]==n*2||to[i^1]==1||to[i^1]==n*2?INF:1;
	}
	while(bfs())
	{
		for (int i=s;i<=t;i++)
			cur[i]=head[i];
		ans+=dfs(s, INF);
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：ChenZ01 (赞：8)

求加友链QAQ

Mailto: Chen2016MS@outlook.com

## Solution

注意，本题中递增子序列**非严格递增**

## Analysis

### Task 1

显然的经典DP
令$f(i)$表示选择$a_i$作为递增子序列的最后一个数所能得到的最长长度，易得
$$f(i) = \max_{j < i, a_j \le a_i}\lbrace f(j)\rbrace + 1$$
长度$\max\lbrace f(i)\rbrace$记作$s$

### Task 2

我们考虑子序列是怎么生成的：设当前序列的结尾是$a_i$，往后拓展序列时，我们会选择$a_i \le a_j, i < j$的$a_j$

于是我们将所有$a_i \le a_j, i < j$的点对$(i, j)$连边，形成的**图**记作$G$

对于所有入度为$0$的点
- 从Super Source向其连边，容量均为$1$。表示可以从这个点开始进行子序列的选择
- 从这个点进行BFS，找出$G$中从该点经$s - 1$个点能到达的全部点，打上标记。表示该点与搜索出的点能形成$s$个点组成的路径，即能构造出长度为$s$的子序列

接着对于打上标记的点，向Super Sink连边，容量均为$1$

跑一遍最大流即可

### Task 3

这就简单了，将Super Source向$1$的边与$n$向Super Sink的容量设为$+\infty$即可

### Find the Bug

WA了，不过分还比较高


一定是哪里出问题了……

没错！一个点可以作为向Super Sink连边的点，同时也可以向后面的点连边，这就会导致流量变大

怎么解决？跳过中间的组成序列的那些点！

我们只关心一个序列的开头和结尾，将其连边即可

Super Source/Sink的连边规则不变

### Extra

丧心病狂的$n = 1$的点，特判即可

### Code

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
#include <queue>
#include <map>

struct Edge
{
    int from, to, capa, next;
    Edge(int from = 0, int to = 0, int capa = 0, int next = 0) : from(from), to(to), capa(capa), next(next) {}
};

int n, len, s, t, cntEdge = -1, cur;
int a[510], tag[510], indeg[510], num[1010], d[510], head[1000010];
Edge edge[1000010];
std::vector <int> zeroDeg;
std::vector <int> g[510];
std::map <int, int> map;

void getLen()
{
    int f[510];
    for (int i = 1; i <= n; ++i)
    {
        f[i] = 1;
        for (int j = 1; j < i; ++j)
            if (a[i] >= a[j] && f[i] <= f[j])
                f[i] = f[j] + 1;
        len = std::max(len, f[i]);
    }
    std::cout << len << "\n";
}

void addEdge(int x, int y, int z)
{
    edge[++cntEdge] = Edge(x, y, z, head[x]), head[x] = cntEdge;
    edge[++cntEdge] = Edge(y, x, 0, head[y]), head[y] = cntEdge;
}

void findNode(int x, int y)
{
    if (y == len)
    {
        map[x] = 1;
        addEdge(cur, x, 1);
        return;
    }
    for (auto i : g[x])
        findNode(i, y + 1);
}

void buildNetwork()
{
    for (auto i : zeroDeg)
        addEdge(s, i, 1), cur = i, findNode(i, 1);
    for (auto& i : map)
        addEdge(i.first, t, 1);
}

void bfs()
{
    std::queue <int> q;
    q.push(t), ++num[d[t] = 1];
    while (q.size())
    {
        int x = q.front(); q.pop();
        for (int i = head[x]; ~i; i = edge[i].next)
        {
            int to = edge[i].to;
            if (!d[to] && !edge[i].capa)
                ++num[d[to] = d[x] + 1], q.push(to);
        }
    }
}

int dfs(int x, int aug)
{
    if (!aug || x == t)
        return aug;
    int res = 0, f = 0;
    for (int i = head[x]; ~i; i = edge[i].next)
    {
        int to = edge[i].to;
        if (d[x] == d[to] + 1 && (f = dfs(to, std::min(aug, edge[i].capa))))
        {
            aug -= f, res += f, edge[i].capa -= f, edge[i ^ 1].capa += f;
            if (!aug)
                return res;
        }
    }
    if (!(--num[d[x]]))
        d[s] = n + 3;
    ++num[++d[x]];
    return res;
}

void maxFlow()
{
    memset(d, 0, sizeof d);
    memset(num, 0, sizeof num);
    int res = 0;
    bfs();
    while (d[s] <= n + 2)
        res += dfs(s, 0x7f7f7f7f);
    std::cout << (res == 0x7f7f7f7f ? 1 : res) << "\n";
}

void rebuildNetwork()
{
    for (int i = 0; i <= cntEdge; i += 2)
    {
        edge[i].capa = 1, edge[i ^ 1].capa = 0;
        if (edge[i].from == n && edge[i].to == t)
            edge[i].capa = 0x7f7f7f7f;
        else if (edge[i].from == 0 && edge[i].to == 1)
            edge[i].capa = 0x7f7f7f7f;
    }
}

int main()
{
    memset(head, -1, sizeof head);
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    std::cin >> n; s = 0, t = n + 1;
    for (int i = 1; i <= n; ++i)
        std::cin >> a[i];
    getLen();
    for (int i = 1; i <= n; ++i)
    {
        for (int j = 1; j < i; ++j)
            if (a[i] >= a[j])
                ++indeg[i], g[j].push_back(i);
        if (!indeg[i])
            zeroDeg.push_back(i);
    }
    buildNetwork();
    maxFlow();
    rebuildNetwork();
    maxFlow();
    return 0;
}
```

---

## 作者：VanillaYuzume (赞：2)

# 最长不下降子序列问题

题目:[自己康](https://www.luogu.org/problem/P2766)

## 解法:题目中有三问
### ->第一问 
可以通过$O(n^2)$的dp来求出 lis的最大长度
### ->第二问 
题目要我们求满足 长度最大的lis的数量    
我们可以通过对出现的每一组lis中的点 建立联系    
在它们组成的图中 跑一次网络最大流 得到的结果就是   
这段序列中 满足lis长度最大的数量    
既然 要建立联系 自然是离不开拆点了!   
所以 我们在处理每个点时 先把它和它的对应点连在一起   
当我们处理 第$i$个时 应从$1$开始枚举直到$j=i-1$   
从中找出满足 $a[j]<a[i]$ 和 $f[j]+1=f[i]$ 的点   
把它们连起来  
(注:是i的实点连j的虚点
### ->第三问 
题目告诉我们 $x~1$ 和 $x~n$ 可以无限用   
而在该题的网络中 每个边的权值可以表示每个点的使用次数  
所以 我们可以把$s$->$1$->$n$+$1$ , $n$->$n*2$ , $n*2$->$t$的 边权设为inf   
(注:对于$w[n*2$ -> $t]=inf$ 当且仅当 $f[n]=maxx$ 时 才成立  
 解释: 如果最后一个点不参与构成这段序列长度最大的lis 那么它的数量不影响答案的量)

综上:我们可以分情况来进行建边,                
依次求出每一问的答案,然后直接输出即可  
最后 有个优化的小方法:   
在第二问求完后 一些边的正向权值已经变为0 对后续无影响       
所以 无需重新建图 直接把部分边权修改后          
再此基础上跑一边最大流即可 $ans$ += $dinic()$

**代码酱 OVO↓**

```cpp
#include <bits/stdc++.h>
using namespace std;

#define N 250000
#define v to[i]
#define inf 0x7f7f7f7f

int n,s,t,maxx;
int a[N],f[N],dep[N];
int from[N],to[N],head[N],w[N],nex[N],ecnt;

void ae(int x,int y,int z){
    from[ecnt]=x;
    to[ecnt]=y;
    w[ecnt]=z;
    nex[ecnt]=head[x];
    head[x]=ecnt++;
}

bool bfs(){
    memset(dep,-1,sizeof(dep));
    queue<int> q;
    dep[s]=1;
    q.push(s);
    while(!q.empty()){
        int u=q.front();
        q.pop();
        for(int i=head[u];i!=-1;i=nex[i]){
            if(dep[to[i]]==-1 and w[i]>0){
                dep[to[i]]=dep[u]+1;
                q.push(to[i]);
            }
        }
    }
    return dep[t]!=-1;
}

int dfs(int u,int low){
    if(u==t)
        return low;
    int ret=low;
    for(int i=head[u];i!=-1;i=nex[i]){
        if(dep[v]==dep[u]+1 and w[i]>0){
            int flow=dfs(v,min(ret,w[i]));
            if(flow>0){
                w[i]-=flow;
                w[i^1]+=flow;
            }
            ret-=flow;
            if(!ret)
                break;
        }
    }
    return low-ret;
}

int dinic(){
    int res=0;
    while(bfs()){
        res+=dfs(s,inf);
    }
    return res;
}

//求lis
void lis(){
    maxx=1;
    for(int i=2;i<=n;i++){
        for(int j=1;j<i;j++){
            if(a[j]<=a[i] and f[i]<f[j]+1){
                f[i]=max(f[i],f[j]+1);
                maxx=max(f[i],maxx);
            }
        }
    }
    printf("%d\n",maxx);
}

int main(){
    memset(head,-1,sizeof(head));
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        f[i]=1;
    }
    lis();
    s=0,t=n*2+1;
    for(int i=1;i<=n;i++){
        ae(i,i+n,1);
        ae(i+n,i,0);
        if(f[i]==1){//如果
            ae(s,i,1);
            ae(i,s,0);
        }
        if(f[i]==maxx){
            ae(i+n,t,1);
            ae(t,i+n,0);
        }
        for(int j=1;j<i;j++){
            if(a[i]>=a[j] and f[j]==f[i]-1){
                ae(j+n,i,1);
                ae(i,j+n,0);
            }
        }
    }
    //for(int i=0;i<=ecnt;i+=2)printf("%d %d %d\n",from[i],to[i],w[i]);
    int ans=dinic();
    printf("%d\n",ans);
    ae(s,1,inf);
    ae(1,s,0);
    ae(n,n*2,inf);
    ae(n*2,n,0);
    ae(1,1+n,inf);
    ae(1+n,1,0);
    if(f[n]==maxx){
        ae(n*2,t,inf);
        ae(t,n*2,0);
    }
    ans+=dinic();
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：大奕哥 (赞：2)

楼下说的很明白了，就是有一点 **代码与解释不符**  我按照解释重新写了一遍代码  大家可以参照我的（丑陋）代码去看下面的题解




```cpp
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<queue> 
using namespace std;
int n;
int q[100005],f[100005],a[505];
int s=0,t=0;//super begin & end 
int cnt=-1; 
struct node
{
       int to,w,nex;
}e[100000];
int head[100005]; 
void add(int x,int y,int w)
{
      e[++cnt].to=y;
     e[cnt].w=w;
     e[cnt].nex=head[x];
     head[x]=cnt;
     e[++cnt].to=x;
     e[cnt].w=0;
     e[cnt].nex=head[y];
     head[y]=cnt; 
}
int d[100005];  
bool bfs(int x,int y)
{
     int h,t;
     h=t=1;
     memset(q,0,sizeof(q)); 
     memset(d,-1,sizeof(d)); 
     d[x]=0; 
     q[h]=x;
     while(h<=t)
     {
                  int u=q[h++];
                for(int i=head[u];i!=-1;i=e[i].nex)
                {
                         int v=e[i].to;
                         if(d[v]==-1&&e[i].w>0)
                         {
                              d[v]=d[u]+1;
                              q[++t]=v;
                         }
                }
     }
     return d[y]!=-1;
} 
int dfs(int x,int w,int y)
{
    if(x==y||w==0)return w;
    int f=0;
    for(int i=head[x];i!=-1;i=e[i].nex)
    {
             int v=e[i].to; 
             if(d[v]==d[x]+1&&e[i].w>0)
             {
                      int flow=dfs(v,min(w-f,e[i].w),y);
                    e[i].w-=flow;
                    e[i^1].w+=flow;
                    f+=flow;
                    if(f==w)break;
             }
    }
    return f;
}
int ans=0;
int dinic(int s,int t)
{
     while(bfs(s,t))
     {
              ans+=dfs(s,1e9,t); 
     } 
     return ans;
} 
int main()
{
     scanf("%d",&n);
     for(int i=1;i<=n;++i)
     {
             scanf("%d",&a[i]);
     }
     int v=0;
     memset(head,-1,sizeof(head)); 
     for(int i=n;i>=1;--i)
     {f[i]=1; 
        for(int j=n;j>i;--j)
        {
               if(a[i]<=a[j])
               f[i]=max(f[j]+1,f[i]);
       } 
     } 
     for(int i=1;i<=n;++i)
     v=max(f[i],v); 
     t=2*n+1;
     printf("%d\n",v);
     for(int i=1;i<=n;++i)
     {
                 if(f[i]==v)
                 add(s,i,1);
               if(f[i]==1)
                 add(n+i,t,1); 
                 add(i,n+i,1); 
     }
     for(int i=1;i<=n;++i)
     for(int j=1;j<i;j++)
     {
               if(f[j]-1==f[i]&&a[j]<=a[i])
               {add(j+n,i,1);} 
     }
     ans=0;
    printf("%d\n",dinic(s,t)); 
     if(f[1]==v)//这里很重要，我调了很久，因为要观察这个点能不能作为一个最长递增子序列的起点
     {add(s,1,1e9); add(1,n+1,1e9);} 
     add(n+n,t,1e9),add(n,n+n,1e9); 
     printf("%d\n",dinic(s,t)); 
    return 0;
}//还有就是这题求的是最长不下降子序列，题目有出入，还请大家仔细
```

---

## 作者：风火 (赞：1)

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define inf 0x3f3f3f3f
const int o=10024,oo=100024;
int n,m,cnt=1,cs,ct,ans1,ans2,ans3;
int a[o],t[o],f[o],h[o],dep[o];
struct cx{
    int nxt,to,val;
}p[(oo<<1)+1024],g[(oo<<1)+1024];
int read()
{
    int x=0,f=1; char ch=getchar();
    while(!isdigit(ch)) f=(ch=='-'?-1:1),ch=getchar();
    while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x*f;
}
inline void add(int x,int y,int z)
{
	p[++cnt].nxt=h[x];
	p[cnt].to=y;
	p[cnt].val=z;
	h[x]=cnt;
}
bool bfs()
{
	memset(dep,0,sizeof dep); dep[cs]=1;
	queue<int> q; q.push(cs);
	while(q.size())
	{
		int x=q.front(); q.pop();
		for(int i=h[x];i;i=p[i].nxt)
		{
			int u=p[i].to;
			if(!dep[u]&&p[i].val>0)
			{
				dep[u]=dep[x]+1;
				if(u==ct) return true;
				q.push(u);
			}
		}
	}
	return false;
}
int dfs(int x,int flow)
//从大神那里学的dfs，快得很
{
	if(x==ct||flow==0) return flow;
	int res=0;
	for(int i=h[x];i;i=p[i].nxt)
	{
		int u=p[i].to;
		if(dep[u]>dep[x]&&p[i].val>0)
		{
			int f=dfs(u,min(flow,p[i].val));
			if(f>0)
			{
				res+=f;
				flow-=f;
				p[i].val-=f;
				p[i^1].val+=f;
			}
		}
	}
	if(res==0) dep[x]=0;
	return res;
}
void Dinic_first()//基本套路
{
	while(bfs())
	{
		while(int d=dfs(cs,inf))
		ans2+=d;
	}
	printf("%d\n",ans2);
	return ;
}
void Dinic_second()//一样的套路
{
	while(bfs())
	{
		while(int d=dfs(cs,inf))
		ans3+=d;
	}
	printf("%d\n",ans3);
	return ;
}
void work()//自己画图可以知道为什么这样变化
{
	for(int i=h[1];i;i=p[i].nxt) 
	{
		int u=p[i].to;
		if(u==1+n) p[i].val=inf;
		else p[i^1].val=inf;
	}
	for(int i=h[2*n];i;i=p[i].nxt)
	{
		int u=p[i].to;
		if(u==ct) p[i].val=inf;
		else p[i^1].val=inf;
	 } 
}
void print()//调试时用的，没有关系
{
	for(int i=1;i<=2*n;i++)
	{
		cout<<i<<"连到："<<endl; 
		for(int j=h[i];j;j=p[j].nxt)
		{
			printf("%d %d\n",p[j].to,p[j].val);
		}
	}
}
/*题目意思已经讲得很清楚了
1：求最长不下降子序列的长度
2：求最长不下降子序列的个数（每个数只可以用一次）
3：如果a1和an可以用无数次，那么最长不下降子数列的
个数为多少个
先考虑第一问：原先可以用O(n)解决，但是第二和第三文
就不好解决了，于是我们看一下数据范围，n<=500,这么
小，不得不说 nice!，立刻求出ans1。
然后想想怎么跑网络流。。
题目要求的不就是长度为ans1的最长不下降子序列的个数
于是我们可以求出到每一个数时候的最长不下降子序列的长度
然后用长度把每一个关系都连起来，然后跑网络流，不就是可以求的了嘛
然后上代码，注释在代码中~~~~~
*/
int main()
{
    n=read(); cs=2*n+1; ct=cs+1;
    for(int i=1;i<=n;i++) a[i]=read();
    for(int i=1;i<=n;i++) f[i]=1;
    for(int i=1;i<=n;i++)
    {
    	for(int j=1;j<i;j++)
    	{
    		if(a[i]>=a[j])
    			f[i]=max(f[i],f[j]+1);
		}
		ans1=max(ans1,f[i]);
	}
	printf("%d\n",ans1);
    //到这里应该都没有什么好解释的吧
	for(int i=1;i<=n;i++) add(i,i+n,1),add(i+n,i,0);
    //每个数只能用一次，一分为二，从上向下连1
	for(int i=1;i<=n;i++)
		if(f[i]==1) add(cs,i,1),add(i,cs,0);
    //长度为1的和超级源点连起来
	for(int i=1;i<=n;i++)
		if(f[i]==ans1) add(i+n,ct,1),add(ct,i+n,0);
    //同理，长度为ans1的和超级汇点连起来
	for(int i=1;i<=n;i++)
	{
		for(int j=i+1;j<=n;j++)
		{
        	//每个数向后找，满足条件的即可以接在当前数后面
			if(a[j]>=a[i]&&f[j]==f[i]+1)
			{
				add(i+n,j,1);
				add(j,i+n,0);
			}
		}
	}
    //print();
	for(int i=1;i<=cnt;i++) g[i]=p[i];
    //把原先的图复制一遍
	Dinic_first();
	for(int i=1;i<=cnt;i++) p[i]=g[i];
    //复制回来
	work();//改变a1和an连得边，自己画图可以更清楚
    //print();
	Dinic_second();
    return 0;
}
```

---

## 作者：Jμdge (赞：0)

这道题...一个 +1 写到括号里面 WA 了两次...


第一问就是求个LIS， nlogn ，当然 n^2 也行，这时注意要同时求出以每个点结尾的 LIS 并记录在 f 数组中，还有要记录答案 len 

第二问和第三问本质相同，第三问就是多了几条流量 inf 的边

对于这两问我们考虑建模然后跑网络流：

>首先源点向 f[i]=1 的点 i 连一条 1 的边

>所有 f[i]=len 的点 i+n 向 汇点连一条 1 的边

>所有点 i 向 i+n  连一条 1 的边


然后 跑网络流，求出第二问的解

最后源点向 1 连 inf ， 1  向  1+n  连 inf 

n 向汇点连 n+n ，n+n 向汇点连 inf

再跑一遍网络流就好了


```cpp
//by Judge
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int inf=1e9+7;
const int M=1003;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} int n,S,T,top,len,pat=1,mf;
arr a,b,f,head,cur,d;
struct Edge{ int to,flow,next; }e[M<<3];
inline void add(int u,int v,int w){
	e[++pat]=(Edge){v,w,head[u]},head[u]=pat;
	e[++pat]=(Edge){u,0,head[v]},head[v]=pat;
} inline int Min(int x,int y){ return x<y?x:y; }
#define v e[i].to
queue<int> q;
inline bool bfs(){ queue<int> q;
	memset(d,0,sizeof d),d[S]=1;
	for(q.push(S);q.size();){
		int u=q.front(); q.pop();
		for(int i=head[u];i;i=e[i].next)
			if(!d[v]&&e[i].flow){
				q.push(v),d[v]=d[u]+1;
				if(v==T) return 1;
			}
	} return 0;
}
int dinic(int u,int flow){
	if(u==T) return flow; int rest=flow,k;
	for(int &i=cur[u];i&&rest;i=e[i].next)
		if(d[v]==d[u]+1&&e[i].flow){
			k=dinic(v,Min(rest,e[i].flow)),
			e[i].flow-=k,e[i^1].flow+=k,rest-=k;
		} return flow-rest;
}
#undef v
inline void get_LIS(){
	b[1]=a[1],f[1]=top=1;
	for(int i=2;i<=n;++i){
		int k=upper_bound(b+1,b+1+top,a[i])-b;
		if(k>top) ++top; b[k]=a[i],f[i]=k;
	} printf("%d\n",len=top);
}
inline void init(){ S=n<<1|1,T=S+1;
	for(int i=1;i<=n;++i) add(i,i+n,1);
	for(int i=1;i<=n;++i) if(f[i]==1) add(S,i,1);
	for(int i=1;i<=n;++i) if(f[i]==len) add(i+n,T,1);
	for(int i=1;i<=n;++i) for(int j=1;j<i;++j)
		if(a[j]<=a[i]&&f[j]+1==f[i]) add(j+n,i,1);
}
int main(){ n=read();
	for(int i=1;i<=n;++i) a[i]=read();
	get_LIS(),init();
	for(;bfs();mf+=dinic(S,inf))
		memcpy(cur,head,sizeof cur);
	printf("%d\n",mf);
	add(1,1+n,inf),add(S,1,inf);
	if(f[n]==len) add(n,n<<1,inf),add(n<<1,T,inf);
	for(;bfs();mf+=dinic(S,inf))
		memcpy(cur,head,sizeof cur);
	return !printf("%d\n",mf);
}
```



---

## 作者：封禁用户 (赞：0)

## 很不开心呢，明明有~~一点~~思路,却还是没写出来啊QAQ

先来看题吧：

第一问明显很好做，用一个普通的DP就可以搞定了

但是：**重点来了**，这个DP出来的$f[i]$数组对后面很有用呢

因为我们可以通过TA来确定出我们连边的方式，这一点在后面会具体讲到

接下来就是我们网络最大流喜闻乐见的**拆点大法**惹

### 拆点大法吼哇

将每个数拆成一个入点，一个出点（对于第$i$个点，我们设入点为$i.x$,出点为$i.y$）

为了保证每个数只用一次（针对第二问）我们将$i.x$与$i.y$连一条流量为1的边

找到所有只能做子序列开头的数（即$f[i]$==1）将$S$与$i.x$连一条流量为1的边

找到所有做满足条件的子序列结尾的数（即$f[i]$==ans1）将$i.y$与$T$连一条流量为1的边

然后跑一遍类似于DP的过程，将满足条件的子序列的数挨个连起来，再做一遍网络最大流就搞定了第二问

至于第三问，因为$X_1$与$X_n$可以使用无限次

我们可以将$X_1$与$X_n$内部的边（即对于第$i$个点，$i.x$与$i.y$连的边）流量建为$INF$，将$S$与$X_1.x$的边流量改为$INF$，将$X_n.y$与$T$的边流量改为$INF$

再跑最大流，并将答案加在ans2上就是第三问的答案啦

上代码QAQ
```cpp
#include<bits/stdc++.h>
using namespace std;
int head[250001],num_edge=-1,s,t,n;
int a[501];
struct Edge
{
    int next,to,dis;
}edge[250001];
void push(int from,int to,int dis)
{
    edge[++num_edge].next=head[from];
    edge[num_edge].to=to;
    edge[num_edge].dis=dis;
    head[from]=num_edge;
}
void add(int u,int v,int val){
    push(u,v,val);
    push(v,u,0);
}
int d[250001],f[250001],cur[250001];
inline bool bfs()
{
    memset(d,0,sizeof(d));
    d[s]=1;
    queue<int> q;
    q.push(s);
    while(!q.empty())
    {
        int x=q.front();
		q.pop();
        for(int i=head[x];i!=-1;i=edge[i].next)
        {
            int y=edge[i].to;
            if(!d[y]&&edge[i].dis)
            {
                d[y]=d[x]+1;
                q.push(y);
            }
        }
    }
    if(!d[t]) return 0;
    else return 1;
}
int dfs(int pos,int dis)
{
	if(pos==t) return dis;
	for(int i=cur[pos];i!=-1;i=edge[i].next)
	  if(d[edge[i].to]==d[pos]+1&&edge[i].dis>0)
	  {
	  	int data=dfs(edge[i].to,min(dis,edge[i].dis));
	  	if(data>0)
	  	{
	  		edge[i].dis-=data;
	  		edge[i^1].dis+=data;
	  		if(edge[i].dis) cur[pos]=i;
	  		return data;
		}
	  }
	return 0;
}
inline int Dinic()
{
	int ans=0;
	while(bfs())
	{
		memcpy(cur,head,sizeof(cur));
		while(int data=dfs(s,0x3f3f3f3f))
	      ans+=data;
	}
	return ans;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)
      cin>>a[i];
    for(int i=1;i<=n;i++)
      f[i]=1;
    for(int i=1;i<=n;i++)
      for(int j=1;j<i;j++)
        if(a[j]<=a[i])
          f[i]=max(f[i],f[j]+1);
    int ans1=0;
    for(int i=1;i<=n;i++)
      ans1=max(ans1,f[i]);
    cout<<ans1<<endl;
    s=0;
    t=n+n+1;
	memset(head,-1,sizeof(head));
    for(int i=1;i<=n;i++)
      add(i,i+n,1);
    for(int i=1;i<=n;i++)
      if(f[i]==1) add(s,i,1);
    for(int i=1;i<=n;i++)
      if(f[i]==ans1) add(i+n,t,1);
    for(int i=1;i<=n;i++)
      for(int j=1;j<i;j++)
        if(a[j]<=a[i]&&f[j]==f[i]-1)
		  add(j+n,i,1);
	int ans2=Dinic();
	cout<<ans2<<endl;
	add(1,1+n,0x3f3f3f3f);
	add(s,1,0x3f3f3f3f);
	if(f[n]==ans1) add(n,n+n,0x3f3f3f3f),add(n+n,t,0x3f3f3f3f);
	ans2+=Dinic();
	cout<<ans2;
}
```


---

## 作者：wanghaoyu1008 (赞：0)

具体如何建图其他题解已经说的很清楚了，我只是反过来了而已。不过没有人告诉我们为什么这是对的。

拆点建图：保证每个数字只用一次，这是套路。然后其他边就是转移。

我们得知道它（转移）的正确性。容易分析，当询问的不是最长不下降子序列时该方法就是错的。因为开始点的f不一定要等于1，转移也不一定要从f严格小于1的节点来。那么我们反着推一下，就得知该问题我们的解法正确了。

~~（以上证明为胡扯）~~ 其实我们通过以上思路大致能知道我们的想法是对的。

然后大胆写一发就A了（网络流真是玄学）

```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=1003;
const int M=N*N;
const int INF=1e9+7;

int a[N],f[N];
int s,t;
int cnt=1,l[N],e[M],x[M],w[M];
int hd,tl,d[N],q[N],r[N];

void pshe(int u,int v,int c){
    ++cnt;x[cnt]=l[u];l[u]=cnt;e[cnt]=v;w[cnt]=c;
    ++cnt;x[cnt]=l[v];l[v]=cnt;e[cnt]=u;w[cnt]=0;
}

bool bfs(){
    memset(d,0,sizeof(d));
    hd=0;tl=1;q[0]=s;d[s]=1;
    while(hd!=tl){
        int v=q[hd];++hd;
        for(int i=l[v];i;i=x[i])
            if(w[i]&&!d[e[i]]){
                q[tl]=e[i];++tl;
                d[e[i]]=d[v]+1;
            }
    }
    return d[t];
}

int dfs(int v,int c){
    if(v==t)return c;
    int t,p=0;
    for(int i=r[v];i;i=x[i])
        if(w[i]&&d[e[i]]==d[v]+1){
            t=dfs(e[i],min(c-p,w[i]));
            w[i]-=t;if(w[i])r[v]=i;w[i^1]+=t;
            p+=t;if(p==c)return c;
        }
    if(p==0)d[v]=0;
    return p;
}

int mxflw(){//求最大流
    int ans=0;
    while(bfs()){
        memcpy(r,l,sizeof(l));
        ans+=dfs(s,INF);
    }
    return ans;
}

int main()
{
    int n,i,j;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
        scanf("%d",&a[i]);
    a[n+1]=INF;
    for(i=1;i<=n+1;i++)
        for(j=0;j<i;j++)
            if(a[i]>=a[j])
                f[i]=max(f[i],f[j]+1);
    printf("%d\n",f[n+1]-1);
    s=2*n+1;t=s+1;
    for(i=1;i<=n;i++){
        pshe(i,i+n,1);
        if(f[i]==1)pshe(s,i,1);
        if(f[i]==f[n+1]-1)pshe(i+n,t,1);
        for(j=1;j<i;j++)
            if(a[i]>=a[j]&&f[j]==f[i]-1)
                pshe(j+n,i,1);
    }
    int p=mxflw();
    printf("%d\n",p);
    pshe(1,1+n,INF);
    pshe(n,2*n,INF);
    pshe(s,1,INF);
    if(f[n]==f[n+1]-1)pshe(2*n,t,INF);
    printf("%d",p+mxflw());
    //加边后只要再进行增广就好了，不用重新跑
    return 0;
}
```

遇到这种明显的网络流题 建图的细节很重要。

---

## 作者：往事一杯酒 (赞：0)

看了半天没看到来自纯ek大法的题解

有点难受

这道题关于网络流的思路其他大佬已经讲得很清楚了

这里就不再赘述~~不然你们又该说我是抄的了~~

对于ek大法没什么好说的了emm

拆点的话可以考虑1为源点，2*i和2*i+1为i拆出来的两个点，2*n+2为汇点

至于ek不懂的可以出门左转找度娘了

强调最后加边的时候要判断最后一位是不是最长不下降子序列的结尾，再加边权

上代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#define inf 1000000001
using namespace std;
int n,a[5001],s,t,g[5001],pre[5001],w[5001][5001];
bool exi[5001];
bool bfs()
{
	queue<int> q;
	memset(exi,0,sizeof exi);
	memset(pre,-1,sizeof pre);
	q.push(s);
	exi[s]=1;
	pre[s]=1;
	while(!q.empty())
	{
		int p=q.front();
		q.pop();
		for(int i=1;i<=t;i++)
		{
			if(!exi[i]&&w[p][i]>0)
			{
				exi[i]=1;
				pre[i]=p;
				if(i==t) return 1;
				q.push(i);
			}
		}
	}
	return 0;
}
int ek()
{
	int flow=0,d=9999999;
	while(bfs())
	{
		for(int i=t;i!=s;i=pre[i])
		d=(d>w[pre[i]][i])?w[pre[i]][i]:d;
		for(int i=t;i!=s;i=pre[i])
		{
			w[pre[i]][i]-=d;
			w[i][pre[i]]+=d;
		}
		flow+=d;
	}
	return flow;
}
int main()
{
	scanf("%d",&n);
	if(n==1)
	{
		printf("1\n1\n1");
		return 0;
	}
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	int maxnnnnn=-1;
	for(int i=1;i<=n;i++)
	{
		g[i]=1;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<i;j++)
		{
			if(a[j]<=a[i])
			{
				g[i]=max(g[i],g[j]+1);
				maxnnnnn=max(maxnnnnn,g[i]);
			}
		}
	}
	if(maxnnnnn!=-1)
	printf("%d",maxnnnnn);
	else
	{
		printf("1\n%d\n%d",n,n);
		return 0;
	}
	for(int i=1;i<=n;i++)
	{
		w[i*2][i*2+1]=1;
	}
	s=1,t=n*2+2;
	for(int i=1;i<=n;i++)
	{
		if(g[i]==1)
		{
			w[s][2*i]=1;
		}
		if(g[i]==maxnnnnn)
		{
			w[2*i+1][t]=1;
		}
		for(int j=1;j<i;j++)
		{
			if(a[j]<=a[i]&&g[i]==g[j]+1)
			{
				w[2*j+1][2*i]=1;
			}
		}
	}
	int ff;
	printf("\n%d",ff=ek());
	w[1][2]=inf;
	w[2][3]=inf;
	if(g[n]==maxnnnnn)
	w[2*n][2*n+1]=inf,w[2*n+1][2*n+2]=inf;
	printf("\n%d",ff+ek());
} 
```

---

## 作者：Dispwnl (赞：0)

第1问是简单的动态规划，第2，3问考虑用网络流解决

我们可以想出这样一个模型：把后面较大的数和前面较小的数连边，然后针对每个长度为s的序列第一个数与汇点连，最后一个数与源点连

然后跑最大流就行了

后面较大的数和前面较小的数连边，可以dp的时候顺带解决

主要是找序列的第一个数和最后一个数

所以我们两次dp：第一次处理从数i向前最长的非降子序列（即f[i]），第二次处理从数i向后最长的非降子序列（即g[i]）

然后若f[i]=s，源点与i连

若g[i]=s，汇点与i连

第2问连边容量都为1，第3问在第二问基础上把源点与最后一个数、第一个数与汇点连边容量改为inf（我代码里重建了边）

问题就解决了

注意s可能为1，需要特判

代码：
```cpp
# include<iostream>
# include<cstring>
# include<cstdio>
# include<queue>
using namespace std;
const int MAX=1e5+1,t=1e5,inf=1e8;
struct p{
	int x,y,dis;
}c[MAX<<2];
int n,num=2;
int h[MAX],d[MAX],a[MAX],f[MAX],g[MAX];//f从i到前，g从i到后
bool use[MAX];
int read()
{
	int x=0,f=1;
	char ch=getchar();
	for(;!isdigit(ch);f=(ch=='-')?-1:1,ch=getchar());
	for(;isdigit(ch);x=x*10+ch-48,ch=getchar());
	return x*f;
}
void add(int x,int y,int dis)
{
	c[num]=(p){h[y],x,0},h[y]=num++;
	c[num]=(p){h[x],y,dis},h[x]=num++;
}
bool bfs()
{
	queue<int> qu;
	qu.push(0);
	memset(d,0,sizeof(d));
	d[0]=1;
	while(!qu.empty())
	{
		int tt=qu.front();
		qu.pop();
		for(int i=h[tt];i;i=c[i].x)
		  if(!d[c[i].y]&&c[i].dis)
		  {
		  	d[c[i].y]=d[tt]+1;
		  	qu.push(c[i].y);
		  }
	}
	return d[t];
}
int dfs(int x,int dix)
{
	if(x==t||!dix) return dix;
	int sum=0;
	for(int i=h[x];i;i=c[i].x)
	  if(d[c[i].y]==d[x]+1&&c[i].dis)
	  {
	  	int dis=dfs(c[i].y,min(c[i].dis,dix));
	  	if(dis)
	  	{
	  		dix-=dis;
	  		sum+=dis;
	  		c[i].dis-=dis;
	  		c[i^1].dis+=dis;
	  		if(!dix) break;
		}
	  }
	if(!sum) d[x]=-1;
	return sum;
}
int dinic()
{
	int tot=0;
	while(bfs()) tot+=dfs(0,inf);
	return tot;
}
int main()
{
	n=read();
	int s=1;//答案
	for(int i=1;i<=n;i++)
	  a[i]=read(),f[i]=g[i]=1;
	for(int i=2;i<=n;i++)
	  {
	  	for(int j=1;j<i;j++)
	      if(a[i]>=a[j]&&f[i]<f[j]+1)
	      f[i]=f[j]+1;
	    s=max(s,f[i]);//更新答案
	    for(int j=1;j<i;j++)
	      if(a[i]>=a[j]&&f[i]==f[j]+1)
	      add(i,j,1);//能更新f[i]就连边
	  }//f[i]dp过程
	for(int i=n-1;i>=1;i--)
	  for(int j=n;j>i;j--)
	    if(a[i]<=a[j]&&g[i]<g[j]+1)
	    g[i]=g[j]+1;//g[i]dp过程
	printf("%d\n",s);
	if(s==1)//特判
	{
		printf("%d\n%d",n,n);
		return 0;
	}
	for(int i=1;i<=n;i++)
	  {
	  	if(f[i]==s) add(0,i,1);//f[i]=s 源点与i连
	  	if(g[i]==s) add(i,t,1);//g[i]=s i与汇点连
	  }
	printf("%d\n",dinic());//第2问
	memset(c,0,sizeof(c));//重建边
	memset(h,0,sizeof(h));
	num=2;
	for(int i=2;i<=n;i++)
	  for(int j=1;j<i;j++)
	    if(a[i]>=a[j]&&f[i]==f[j]+1)
	    add(i,j,1);
	for(int i=1;i<=n;i++)
	  {
	  	if(f[i]==s)
		if(i==1||i==n) add(0,i,inf);//处理x1和xn
		else add(0,i,1);
	  	if(g[i]==s)
		if(i==1||i==n) add(i,t,inf);
		else add(i,t,1);
	  }
	printf("%d",dinic());//第3问
	return 0;
}
```


---


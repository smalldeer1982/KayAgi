# 树的数量

## 题目描述

求出包含 $n$ 个节点（无标号）的有根 $m$ 叉树的个数，对 $10\,007$ 取模。

两个有根树相同，当且仅当其根节点相同，且**从左到右**每一棵子树也相同。特别地，两个有根树均为空树，视为两个有根树相同。

## 说明/提示

$n,m \leq 127$

## 样例 #1

### 输入

```
2 2```

### 输出

```
2```

# 题解

## 作者：Elegia (赞：37)

好像没什么人用更数学一点的方法解决这个问题……

考虑生成函数，首先要有一个节点，其次每个子树可以为空或者为 $m$ 叉树，因此可列出式子

$$ f(z) = z(1 + f(z))^m $$

变式为

$$ z = \frac{f(z)}{(1 + f(z))^m} $$

那么定义逆函数

$$ g(w) = \frac{w}{(1+w)^m} $$

根据 Lagrange 反演，有

$$ [z^n]f(z) = \frac1n[w^{n-1}]\left(\frac w{g(w)}\right)^n $$

展开，用二项式定理可以得到

$$ \frac{\binom{nm}{n - 1}}{n} $$

那么就算出组合数就完事了。

```cpp
#include <cstdio>

using namespace std;

const int P = 10007;

int inv[P], fac[P], ifac[P];

int binom(int n, int m) {
	if (m > n)
		return 0;
	return fac[n] * ifac[m] % P * ifac[n - m] % P;
}

int lucas(int n, int m) {
	if (m > n)
		return 0;
	if (m == 0)
		return 1;
	return binom(n % P, m % P) * lucas(n / P, m / P) % P;
}

int main() {

	inv[1] = 1;
	for (int x = 2; x < P; ++x)
		inv[x] = -(P / x) * inv[P % x] % P + P;
	fac[0] = ifac[0] = 1;
	for (int x = 1; x < P; ++x) {
		fac[x] = fac[x - 1] * x % P;
		ifac[x] = ifac[x - 1] * inv[x] % P;
	}
	int n, m;
	scanf("%d%d", &n, &m);
	printf("%d\n", lucas(n * m, n - 1) * inv[n] % P);

	return 0;
}
```


---

## 作者：_Life_ (赞：29)

### 题意
求 $n$ 个节点的有根 $m$ 叉树的个数
### 题解
其他题解里写的神仙组合数看不懂，发个 $O(n^3)$ 的动规题解吧

~~好想又好写，动规大法保智商~~

###### 状态 
$dp_{i,j}$ 表示有 $i$ 个点，根节点有 $j$ 棵子树时的方案数（允许子树为空）

###### 转移
先强势上图 

![](https://cdn.luogu.com.cn/upload/image_hosting/jet6pd0f.png)

$$dp_{i,j}=\sum_{k=0}^{i-1}dp_{k,m}\cdot dp_{i-k,j-1}$$

我们枚举当前的这棵子树有 $k$ 个点，允许有空树，所以 $k\ge 0$，要给根节点留一个点，所以 $k\le i-1$，这棵子树允许最多有 $m$ 个儿子，所以该子树的方案数为 $dp_{k,m}$

现在还剩下一颗有 $i-k$ 个节点的树，因为有一个子树配额被我们枚举的子树用掉了，所以现在还有 $j-1$ 个子树配额，剩下的树的方案数为 $dp_{i-k,j-1}$

把两个柿子乘一乘加一加就得到 $dp_{i,j}$ 了
### 代码
```cpp
#include<iostream>
#define mod 10007
using namespace std;
int n,m,dp[128][128];
int main()
{
	cin>>n>>m;
	for(int i=0;i<=m;i++)dp[0][i]=1;
	for(int i=0;i<=m;i++)dp[1][i]=1;
	for(int i=2;i<=n;i++)
		for(int j=1;j<=m;j++)
			for(int k=0;k<i;k++)
				dp[i][j]=(dp[i][j]+dp[k][m]*dp[i-k][j-1]%mod)%mod;
	cout<<dp[n][m];
}
```

---

## 作者：zhoukangyang (赞：19)

**upd ：前文介绍的办法比较麻烦，如果你想知道轻松一点的方法可以看后面**

什么拉反我不懂，菜就用了菜的方法。

设 $i$ 个点的生成树数目是 $f_i$，他的 $\rm OGF$ 是 $F(x) = \sum\limits_{i \ge 0} f_i x^i$ 

有 $F(x) = x F(x)^m + 1$，$xF(x)^{m} - F(x) + 1 = 0$

牛顿迭代即可

这个出体人不讲 wood，不给 $\rm NTT$ 膜数

为了方便，这里用了暴力求逆，暴力快速幂等，时间复杂度是 $\Theta(n^2 \log m)$（暴力多项式快速幂是 $n^2\log m$ 的）

```cpp
#include<bits/stdc++.h>
#define L(i, j, k) for(int i = j, i##E = k; i <= i##E; i++)
#define R(i, j, k) for(int i = j, i##E = k; i >= i##E; i--)
#define ll long long
#define ull unsigned long long
#define db double
#define pii pair<int, int>
#define mkp make_pair
using namespace std;
const int N = 2e4 + 7, mod = 10007;
int qpow(int x, int y = mod - 2) {
	int res = 1;
	for(; y; x = (ll) x * x % mod, y >>= 1) if(y & 1) res = (ll) res * x % mod;
	return res;
}
void mul(int *f, int *g, int *ans, int n, int m) {
	static int res[N]; 
	fill(res, res + n + m - 1, 0);
	L(i, 0, n - 1) L(j, 0, m - 1) (res[i + j] += (ll) f[i] * g[j] % mod) %= mod;
	copy(res, res + n + m - 1, ans);
} 
void fpow(int *f, int *g, int k, int n) {
	static int res[N], now[N]; 
	fill(res, res + n, 0), res[0] = 1, copy(f, f + n, now);
	for(; k; mul(now, now, now, n, n), k >>= 1) if(k & 1) mul(res, now, res, n, n);
	copy(res, res + n, g);
}
void inv(int *f, int *g, int n) {
	static int sav[N], ans[N];
	fill(sav, sav + n, 0), sav[0] = 1;
	L(i, 0, n - 1) {
		ans[i] = (ll) sav[i] * qpow(f[0]) % mod;
		L(j, i, n - 1) (sav[j] += mod - (ll) ans[i] * f[j - i] % mod) %= mod;
	}
	copy(ans, ans + n, g);
}
int t;
void Newton(int *f, int n) {
	static int sav[N], sv[N], now[N];
	fill(now, now + n, 0), now[0] = 1;
	for(int m = 1, pn; m <= n; m <<= 1) {
		pn = m << 1, fpow(now, sav, t, pn), fpow(now, sv, t - 1, pn);
		R(i, pn - 1, 1) sav[i] = sav[i - 1], sv[i] = (ll) sv[i - 1] * t % mod;
		sav[0] = 1, sv[0] = mod - 1;
		L(i, 0, pn - 1) (sav[i] += mod - now[i]) %= mod;
		inv(sv, sv, pn), mul(sav, sv, sav, pn, pn);
		L(i, 0, pn - 1) (now[i] += mod - sav[i]) %= mod; 
	}
	copy(now, now + n, f);
}
int n, f[N];
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> n >> t;
	Newton(f, n + 1);
	cout << f[n] << "\n";
	return 0;
} 
```

这个做法也是有优势的，如果用任意模数 NTT 可以在 $\Theta(n \log n)$ 的时间内得到所有 $x \le n$ 的答案qwq

-----

优秀的做法是什么？

发现这个方程是 $\mathcal{B}_m$，于是答案是 $\frac{\binom{nm+1}{n}}{nm+1} = \frac{\binom{nm}{n-1}}{n}$，我们秒了这题。

不会广义二项级数的可以点 [这儿](https://www.cnblogs.com/zkyJuruo/p/14872991.html)。

---

## 作者：Aleph1022 (赞：14)

# Fuss-Catalan 数

定义 $C_k(z)$ 满足
$$
C_k(z) = 1 + z C_k^k(z)
$$

有结论 $[z^n] C_k^s(z) = \frac{s}{kn+s}\binom{kn+s}{n}$，通过拉格朗日反演很容易证明，但此处不赘述。  
当 $s=1,k=2$ 时就统一到经典的 Catalan 数 $\frac1{n+1} \binom{2n}n$。

# k-Dyck 路

考虑从 $(0,0)$ 到 $((k+1)n,0)$ 的格点路径，其中只能走 $(1,1)$ 或 $(1,-k)$，且不能走到 $y=0$ 以下。

当 $k=1$ 时就统一到许多常见的组合模型：括号序列、出栈序列、凸多边形三角划分、二叉树等。这也就是经典的 Catalan 数 $\frac1{n+1} \binom{2n}n$。

# k 叉树

本文中考虑的 $k$ 叉树满足每个结点**必有** $k$ 个儿子或**没有**儿子，其中有儿子的点称为**内点**，没有儿子的点称为**外点**。  
容易发现此题即计数恰有 $n$ 个内点的 $m$ 叉树个数。

当 $k=2$ 时就统一到经典的 Catalan 数 $\frac1{n+1} \binom{2n}n$。

# 一种联系

从 Symbolic Method 可以立刻建立起 $k$ 叉树与 $C_k(z)$ 的联系：后者即为前者的 OGF。  
接下来，我们建立 $k+1$ 叉树与 $k$-Dyck 路的双射，再介绍一种计数 $k$-Dyck 路的**组合方法**。

## 双射

### 树 -> 路

我们首先改写 $k$-Dyck 路为：第一步必为 $(1,1)$，最后走到 $((k+1)n+1,1)$，且第一步之后不走到 $y=1$ 以下的格点路径。  
容易发现这样的 $k$-Dyck 路和原来的 $k$-Dyck 路也是一一对应的。

接下来我们考虑一棵 $k+1$ 叉树如何映射到一条 $k$-Dyck 路。  
首先在最前面添加一步 $(1,1)$；接下来从左往右考虑其 $k+1$ 个儿子，将其各自子树所映射到的 $k$-Dyck 路接在已有的 $k$-Dyck 路后方；最后，如果这棵树的根结点为内点，则在最后添加一步 $(1,-k)$。  
容易验证这样就可以得到一条合法的 $k$-Dyck 路。

### 路 -> 树

同样改写 $k$-Dyck 路。

从最后一步往前考虑一条 $k$-Dyck 路。若最后一步为 $(1,-k)$，则确定树的根结点为内点或外点；如为内点，则继续考虑倒数第二步，即可确定当前根结点最右的尚未确定的儿子为内点或外点，以此类推地递归构造即可。

# k-Dyck 路计数

同样改写 $k$-Dyck 路。

考虑从 $(0,0)$ 到 $((k+1)n+1,1)$，不要求所有时刻不低于 $y=1$ 的格点路径，我们可以将其映射到一个 $k$-Dyck 路：  
考虑其最低点中最右方的位置，设其为 $(x,y)$；将 $x$ 及以后的所有部分整体「剪切」到 $(0,0)$ 开始的部分；接下来，将原路径中 $x$ 以前的部分再直接接到其后方。容易发现这样满足条件。

不过这并不是双射。注意到对于一条 $k$-Dyck 路，其恰好可以映射到 $(k+1)n+1$ 条如上的格点路径。  
因此，$k$-Dyck 路的数量即为 $\frac1{(k+1)n+1} \binom{(k+1)n+1}n$。

这一方法也被称作是共轭原则，或者是环引理。  
实际上，其在逻辑上与拉格朗日反演是等价的。

# 题解

因此，对于此题，直接使用 Lucas 定理计算 $\frac1{nm+1} \binom{nm+1}n = \frac1n \binom{nm}{n-1}$ 即可。

---

## 作者：pufanyi (赞：9)

首先声明下这篇题解不并是我独立完成的，主要参考的是[sxd666888](https://www.luogu.org/space/show?uid=84156)大佬的idea并在他的协助下完成的。

### $O(n^4)$算法

令$dp[i]$表示用$i$个不同的节点构成$m$叉树的数量。我们发现好像无法转移，于是考虑另设$dpp[j][k]$表示根节点有$j$个儿子，子树大小为$k$的方案数。易得$dpp[j][k] = \sum_{l = 0}^{k - 1}dp[l]\times dpp[j-1][k-l]$，也就是说在一棵树的根节点上接上一棵$m$叉树。最后我们有$dp[i] = dpp[m][i]$。

### $O(n^3)$算法

状态定义和$O(n^4)$算法不多，只是$dpp[i][j]$把根节点给去掉了，即定义了由$i$个$j$叉树构成的森林，然后直接同卡特兰数那样大力接上去就可以了：`dpp[i][j] += dp[k] * dpp[i-k][j-1]`。

当然最后是$dp[i+1] = dp[m][i]$。

### 更好的做法

首先，我们有一个猜想：

给定一个有自然数构成的长度为$n$的序列$\{a\}$，若$\sum a_i=n-1$，则有且仅有一个$I$使得可以产生一个正整数（除最后一个为$0$）构成的长度为$n$的序列$\{b\}$：

$$b_i=\sum_{j = 1}^{i} a_{(j+I-2)\% n+1}-i+1$$

比如说这样一个序列：

```plain
3 0 0 0 0 2
```

我们有且仅有一个$I=5$使得产生合法$b$的序列：

```plain
2 4 3 2 1 0
```

然后我们来证明它：

所有序列$\{a\}$，当$I = 1$时，所产生的$\{b\}$序列都类似下面这样的图：

![](https://cdn.luogu.com.cn/upload/pic/50592.png)

可以发现的是，当我们选$I = x(x \not = 1)$时，$0$线会移到当前$b_x$所在位置，并且从$x+1\sim n$和$1$的点会上升$1$。

因此，当且仅当选$I$为最近的处在最低谷的点的位置时，产生的$\{b\}$合法。

然后我们需要把这个结论和树联系起来。

我们给一棵树记录一次$\text{dfs}$，我们先把儿子节点入栈，遍历完后将其出栈，这样子，我们对于一个序列$\{a\}$，${a_i}$表示的是第$i$个节点有几个儿子。

我们每次遍历到一个节点时先将它出栈（$-1$），再把它的儿子入栈（$+a_i$），当前栈里元素个数就是${b_i}$，即能拓展点的个数。最终就得到了$\{b\}$序列。如果中途中途出现小于等于$0$的数，那么下一个节点就不知道在哪了，不符合树的定义。

因为题中是$m$叉树，所以连接儿子的边的选择会影响
方案数，因此序列$\{a\}$中每个数的大小不超过m，总共有$n\times m$条边，从中选出$n-1$条,并用下图构成序列$\{a\}$。

![](https://cdn.luogu.com.cn/upload/pic/50594.png)

而构成的序列$\{a\}$中，只有$\frac{1}{n}$的方案是可行的，因此得出公式：

$$ans = \frac{C_{n\times m}^{n-1}}{n}$$



---

## 作者：Acfboy (赞：4)

怎么题解区都是各种高级做法，这不就一个基础 dp 吗（

首先想到的状态是 $f_{i, j}$ 表示 $i$ 个点 $j$ 叉树有多少的方案，可是这样似乎没有办法转移，因为一个叉数的数好像和其它叉数的没有什么关系。于是增加一维， $f_{i, j, k}$ 表示 $i$ 个点 $j$ 叉且根连了 $k$ 叉的方案数，这样只要枚举根加进去的最后一叉有多少个就可以转移了。

容易发现，这个时候 $j$ 已经没有什么用了，因为当前叉可以接 $0$， 所以这个 $k$ 完全包含了 $j$ 的作用，那么定义新状态 $f_{i, j}$ 表示 $i$ 个点的 $m$ 叉树根节点连了 $j$ 叉的方案数。

$$
f_{i, j} = \sum_{k=0}^{i-1} f_{i-k, j-1} \times f_{k, m}
$$

最后要注意初始状态 $f_{0, i} = f_{1, i} = 1$，毕竟只有一个点和没有点总是只有一种方法。因为这个问题调了很久。

核心代码只有五行。

```cpp
#include <cstdio>
const int N = 305, P = 10007;
int n, m, f[N][N];
int main() {
	scanf("%d%d", &n, &m);
	for (int i = 0; i <= m; i++) f[1][i] = f[0][i] = 1;
	for (int i = 2; i <= n; i++) 
		for (int j = 1; j <= m; j++) 
			for (int k = 0; k < i; k++)
				f[i][j] = (f[i][j] + f[i-k][j-1] * f[k][m] % P) % P;
	printf("%d", f[n][m]);
	return 0;
}
```

---

## 作者：jzqjzq (赞：4)

DP

$f[i][j]$表示当前已经选择i个点，这棵树的最深层有j个节点的方案数

转移枚举上一层的节点数

显然一个节点最多可以有m个子节点

那么 $f[i][j]=\sum_{k=j/m}^{min(i-j,n)}f[i-j][k]*C(k*m,j)$

答案即为$\sum_{i=1}^{n}f[n][i]$


```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <iostream>
#include <ctime>
#include <map>
#include <queue>
#include <cstdlib>
#include <string>
#include <climits>
#include <set>
#include <vector>
#include <complex>
#define int long long
using namespace std;
inline int read(){
	int k=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){k=k*10+ch-'0';ch=getchar();}
	return k*f;
}
inline void write(int x){
	if(x<0){putchar('-');x=-x;}if(x>9)write(x/10);
	putchar(x%10+'0');
}
inline void writeln(int x){
	write(x);puts("");
}
const int MOD=10007,N=210;
int n,m,f[N][N],ans=0;
int c[200*N][210];
inline int C(int x,int y){
	return c[x][y];
}
signed main()
{
	n=read();m=read();
	c[0][0]=1;
	for(int i=1;i<=n*m;i++){
		c[i][0]=1;
		for(int j=1;j<=min(i,n);j++)c[i][j]=(c[i-1][j]+c[i-1][j-1])%MOD;
	}
	f[1][1]=1;int ans=0;
	for(int i=2;i<=n;i++)
		for(int j=1;j<min(i,n);j++){
			f[i][j]=0;
			for(int k=j/m;k<=min(i-j,n);k++){
				f[i][j]=(f[i][j]+f[i-j][k]*C(k*m,j)%MOD)%MOD;
			}
		}
	for(int j=1;j<=n;j++)ans=(ans+f[n][j])%MOD;
	writeln(ans);
	return 0;
}
```

---

## 作者：Bulyly (赞：4)

### 前置知识：
关于 $ m $ 叉树的定义：
相比于熟悉的二叉树，  $ m $  叉树是一个意思， 二叉树是一棵以根节点开始，每个节点含有不超过  $ 2 $    (可以是 $ 0 $  ,  $ 1 $  ,  $ 2 $  )  个子节点的树。将这个定义扩展到  $ m $  叉树，一棵以根节点开始， 每个节点不超过 $ m $ 个子节点的树， 称为  $ m $  叉树


------------
**划重点**  子树可以为空，这点很重要！！！


------------
到这里 dp 方程就非常好想了，详见图示内容  ~~不想再多说了~~

![](https://cdn.luogu.com.cn/upload/image_hosting/beztx55q.png)

### 最后 dp 代码:

```cpp
for(int i=0;i<=m;i++)  f[0][i]=1,f[1][i]=1;//初始化
	for(int i=2;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			for(int k=0;k<i;k++)
			{
				f[i][j]=(f[i][j]+f[k][m]*f[i-k][j-1]%10007)%10007;
			}
		}
	}
```


---

## 作者：BigJoker (赞：1)

# Preface

这是一道 DP 题目。

# Solution

定义 $f_{i,j}$ 表示有 $i$ 个节点，根节点拥有至多 $j$ 叉的方案数量。

那么我们可以这么考虑，单独拎出来一个子树，将其赋予它的大小，其它子树以及根节点又自成一颗树。

那么易得方程：$f_{i,j}\gets \sum_{k=0}^{i-1} f_{k,m}\times f_{i-k,j-1}$

然后问题就解决了。

---

## 作者：LJB00131 (赞：1)

$O(  N^4  )$ 的DP

几篇题解思路讲得很清楚了，~~但是没人贴代码~~

~~所以我来给个代码~~

这种暴力多一维来处理未做部分的思想还是值得学习的

```cpp
#include<bits/stdc++.h>

using namespace std;

#define N 135

int n, m, dp[N], f[N][N];

int main()
{
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++)
    {
        memset(f, 0, sizeof(f));
        f[0][1] = 1, dp[0] = 1;
        for(int j = 1; j <= m; j++)
        {
            for(int k = 1; k <= i; k++)
            {	
                for(int l = 0; l < k; l++)
                {
                    f[j][k] += (dp[l] * f[j - 1][k - l]) % 10007;
                    f[j][k] %= 10007;
                }
            }
        }
        dp[i] = f[m][i];
    }
    cout << dp[n] << endl;
    return 0;
}
```

---

## 作者：m256i (赞：0)

一道简单 GF 题。显然一棵无标号有根有序 $m$ 叉树由一个根节点和 $m$ 棵子树构成，所以考虑解析组合，设 $m$ 叉树的组合类为 $\mathcal{T}$，则有：

$$\mathcal{T}=\mathcal{Z}\times(\mathcal{E}+\mathcal{T})^m$$

注意，为了后面拉格朗日反演方便，将常数项设为 $0$。

对应 OGF 为：

$$T(z)=z(1+T(z))^m$$

我们要构造一个函数 $G(z)$ 使得 $G(z)$ 与 $T(z)$ 互为复合逆，即满足 $T(G(z))=G(T(z))=z$。

把 $T(z)$ 稍微变换一下得到：

$$\dfrac{T(z)}{(1+T(z))^m}=z$$

那么有：

$$G(T(z))=z=\dfrac{T(z)}{(1+T(z))^m}$$

因此得到 $G(z)$ 的定义：

$$G(z)=\dfrac{z}{(1+z)^m}$$

拉格朗日反演后得到：

$$
\begin{aligned}
[z^n]F(z)&=\dfrac{1}{n}[z^{n-1}]\left(\dfrac{z}{G(z)}\right)^n\\
&=\dfrac{1}{n}[z^{n-1}]\left(\dfrac{z}{\frac{z}{(1+z)^m}}\right)^n\\
&=\dfrac{1}{n}[z^{n-1}]\left((1+z)^m\right)^n\\
&=\dfrac{1}{n}[z^{n-1}](1+z)^{mn}\\
&=\dfrac{1}{n}[z^{n-1}]\sum_{i \ge 0}\dbinom{mn}{i}z^i\\
&=\dfrac{1}{n}\dbinom{mn}{n-1}
\end{aligned}
$$

用 Lucas 定理计算即可。

---

## 作者：daniEl_lElE (赞：0)

## 思路

考虑 $dp_{i,j}$，表示目前用去 $i$ 个节点，最下面一层有 $j$ 个节点的方案数。

令 $pre_{i,j}$ 表示上面一层 $i$ 个节点，转移到下一层 $j$ 个节点的方案数。

易知：$pre_{i,j}=\sum_{k=0}^mpre_{i-1,j-k}\times\binom{m}{k}$。其中 $k$ 表示该子树的节点数。整个式子的意思就是考虑上一次选到 $i-1$ 号节点，这次多加一个节点和其 $k$ 个儿子，并从他总共可以有的 $m$ 叉中选出 $k$ 个位置放置节点。

考虑转移方程，目前这一层为 $j$ 个节点，下面构造 $k$ 个节点：$dp_{i+k,k}+=dp_{i,j}\times pre_{j,k}$。也就是这一层 $j$ 节点下一层 $k$ 节点转换的方案数。

最后计算 $\sum_{i=1}^ndp_{n,i}$ 即可，复杂度 $\Theta(n^3)$ 即可通过此题。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int dp[128][128];
int pre[128][128];
int C[128][128];
const int mod=10007;
signed main(){
	int n,m;
	cin>>n>>m;
	pre[0][0]=1;
	for(int i=0;i<=128;i++) C[i][0]=1;
	for(int i=0;i<=128;i++) for(int j=1;j<=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
	for(int i=0;i<=n;i++){
		for(int j=0;j<=n;j++){
			for(int k=0;k+j<=n&&k<=m;k++){
				pre[i+1][k+j]=(pre[i+1][k+j]+pre[i][j]*C[m][k])%mod;
			}
		}
	}
	dp[1][1]=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++){
			for(int k=1;k+i<=n;k++){
				dp[i+k][k]=(dp[i+k][k]+dp[i][j]*pre[j][k]%mod)%mod;
			}
		}
	}
	int sum=0;
	for(int i=1;i<=n;i++){
		sum=(sum+dp[n][i])%mod;
	}
	cout<<sum;
	return 0;
}
```	

---

## 作者：zplqwq (赞：0)

这道题算是一道思维量算是很大的题目。

第一反应数数题，发现怎么也推不出来柿子。

突然想起有一些数数题可以用 dp 做。

于是往 dp 上想。

有一个显然的状态

$f_{i,j,k}$ 表示 $i$ 个点 $j$  叉且根连了 $k$ 叉的有多少种方案。但是这个方案仔细想想不是很好转移，因为有一个几乎半费的状态 $j$ ，这个 $j$ 是可以被 $k$完全覆盖掉的。

那么我们考虑优化一下这个状态。

$f_{i,j}$ 示 $i$ 个点的 $m$ 叉树根节点连了 $j$ 叉有多少种方案。

最后为什么就决定是这个方案呢？因为这个状态很简洁，没有什么废话，同时也可以很详细的表示出所有信息。因此这个状态是很有可能成功的。

有了状态之后，我们考虑这个转移方程。

我们枚举一个 $k$ 让后从对 $f_{i-k,j-1} \times f_{k,m}$ 求和来更新 $f_{i,j}$ 。

复杂度 $O(n^3)$ 在 $n\le 127$ 的条件下可过.

代码就不给了，感觉很好写。



---

## 作者：jun头吉吉 (赞：0)

## 题意
有 $n$ 个不同节点，请问能组成多少种 $m$ 叉树结构。
## 题解
直接上组合：
$$\mathcal T=\mathrm{root}\times \mathrm{SEQ}_ {m}(\mathrm{emptytree}\cup\mathcal T)$$
然后就是喜闻乐见的 $\mathbf{GF}$：
$$t(z)=z(1+t(z))^m$$
然后就不会了，怎么办办呢？

这个其实已经可以做了。根据 $\text{《Analytic Combinatorics》}$ 的说法，这个约束是递归的，只要把 $t(z)=1$ 带进去不停迭代即可，有时间会写。

应该要迭代 $n$ 次，每次暴力卷积 $O(n^2)$，$m$ 次快速幂做到 $O(n^2\log m)$这个 $O(n^3\log m)$ 的算法看上去是可以过的，而且暴力卷积可以很容易地常数优化。不过这个 $3$ 次方的解法仍然不是我们想要的。

考虑一下牛顿迭代：
$$G(t(z))=z(1+t(z))^m-t(z)=0$$
假如我们知道 $t_0$ 满足 $G(t_0(z))\equiv 0\pmod {x^n}$，那么迭代到 $t(z)$：
$$
t(z)\equiv t_0(z)-\frac{G(t_0(z))}{G^\prime (t_0(z))} \pmod {x^{2n}}
$$
然后就不是很好化了，考虑记 $f(z)=t(z)+1$，事情就会明朗很多,重新设：
$$G(f(z))=z f^m(z)-f(z)+1=0$$
这个东西牛迭就很简单了。

$$f(z)=f_0(z)-\frac{zf_0^m(z)-f_0(z)+1}{zm f_0^{m-1}(z)-1}$$

现在的复杂度是 $\sum_{i=0}^{\log n}(2^i)^2\log m+(2^i)^2$，感觉应该是 $O(n^2 \log n)$ 的（默认 $n,m$ 同阶）。

这样写应该没有任何问题。

但还是不够给力呀！！！

这个方程非常不科学，并没有代数解，至少 $\rm Mathematica$ 解不出来![jk](https://cdn.luogu.com.cn/upload/pic/62234.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/ccgak8zk.png)

于是就只能去看题解，然后就看到神 $\rm E\color{red}legia$ 的题解，在这一步直接上拉反。

$$\frac{t(z)}{(1+t(z))^m}=z\quad\frac{w}{(1+w)^m}=g(w)\Longrightarrow t\circ g=\epsilon$$

$g(t(z))=\frac{t(z)}{(1+t(z))^m}=z$

然后就可以演了。
$$[z^n]t(z)=\frac1n[w^{n-1}]\left(\frac{w}{g(w)}\right)^n$$
然后就直接 
$$\frac{\binom{nm}{n-1}}n$$

模数这么小感觉会出问题，结果一发过了![yiw](https://cdn.luogu.com.cn/upload/pic/62243.png)

鉴于这个代码会出问题，因此给个 [错误链接](https://www.luogu.com.cn/paste/we1zryg4)，希望大家不要重蹈这个屑的覆辙，以至于被 $\rm x\color{red}zggzh$ $\mathcal D$ 爆。

正经写法应该是用 $\rm lucas$
## 代码
又臭又长的牛顿迭代。
```cpp
#include<bits/stdc++.h>
using namespace std;
template<const int mod>
struct modint{
    int x;
    modint<mod>(int o=0){x=o%mod;(x<0)&&(x+=mod);}
    modint<mod> &operator = (int o){return x=o%mod,(x<0)&&(x+=mod),*this;}
    modint<mod> &operator +=(modint<mod> o){return x=x+o.x>=mod?x+o.x-mod:x+o.x,*this;}
    modint<mod> &operator -=(modint<mod> o){return x=x-o.x<0?x-o.x+mod:x-o.x,*this;}
    modint<mod> &operator *=(modint<mod> o){return x=1ll*x*o.x%mod,*this;}
    modint<mod> &operator ^=(int b){
        modint<mod> a=*this,c=1;
        for(;b;b>>=1,a*=a)if(b&1)c*=a;
        return x=c.x,*this;
    }
    modint<mod> &operator /=(modint<mod> o){return *this *=o^=mod-2;}
    modint<mod> &operator +=(int o){return x=x+o>=mod?x+o-mod:x+o,*this;}
    modint<mod> &operator -=(int o){return x=x-o<0?x-o+mod:x-o,*this;}
    modint<mod> &operator *=(int o){return x=1ll*x*o%mod,*this;}
    modint<mod> &operator /=(int o){return *this *= ((modint<mod>(o))^=mod-2);}
    template<class I>friend modint<mod> operator +(modint<mod> a,I b){return a+=b;}
    template<class I>friend modint<mod> operator -(modint<mod> a,I b){return a-=b;}
    template<class I>friend modint<mod> operator *(modint<mod> a,I b){return a*=b;}
    template<class I>friend modint<mod> operator /(modint<mod> a,I b){return a/=b;}
    friend modint<mod> operator ^(modint<mod> a,int b){return a^=b;}
    friend bool operator ==(modint<mod> a,int b){return a.x==b;}
    friend bool operator !=(modint<mod> a,int b){return a.x!=b;}
    bool operator ! () {return !x;}
    modint<mod> operator - () {return x?mod-x:0;}
    modint<mod> &operator++(int){return *this+=1;}
};
typedef modint<10007> mint;
const int N=256;
int up;
struct poly{
	mint a[N];
	mint&operator[](int x){return a[x];}
	void init(){memset(a,0,sizeof a);}
	void cpy(poly&b){memcpy(a,b.a,sizeof a);}
}tmp,tmp1,tmp2;
void mul(poly&c,poly&a,poly&b){
	c.init();
	for(int i=0;i<up;i++)
		for(int j=0;j<up;j++)
			if(i+j<up)c[i+j]+=a[i]*b[j];
}
void inv(poly&a,poly&b){
	b[0]=1/a[0];
	for(int i=1;i<up;i++){
		b[i]=0;
		for(int j=0;j<i;j++)b[i]-=b[j]*a[i-j];
		b[i]/=a[0];
	}
}
void pow(poly&res,poly a,int b){
	static poly tmp;
	res.init();res[0]=1;
	while(b){
		if(b&1)mul(tmp,res,a),res.cpy(tmp);
		mul(tmp,a,a),a.cpy(tmp);b>>=1;
	}
}
void mulx(poly&a){
	for(int i=up-1;i;i--)
		a[i]=a[i-1];
	a[0]=0;
}
int n,m;
poly f[2];
signed main(){
	cin>>n>>m;
	int now=0,lst=1;
	for(int i=0;(1<<i-1)<=n;i++){
		swap(now,lst);
		f[now].init();
		int n=1<<i;up=n;
		if(i==0){
			f[now][0]=1;
		}else{
			pow(tmp,f[lst],m);
			mulx(tmp);
			for(int i=0;i<n;i++)
				tmp[i]-=f[lst][i];
			tmp[0]+=1;
			
			pow(tmp1,f[lst],m-1);
			mulx(tmp1);
			for(int i=0;i<n;i++)
				tmp1[i]*=m;
			tmp1[0]-=1;
			inv(tmp1,tmp2);
			
			mul(tmp1,tmp,tmp2);
			
			for(int i=0;i<n;i++)
				f[now][i]=f[lst][i]-tmp1[i];
		}
		//for(int i=0;i<n;i++)
		//	printf("%d ",f[now][i]);
		//puts("");
	}
	cout<<f[now][n].x;
    return 0;
}
```
以及牛逼的方法
```cpp
#include<bits/stdc++.h>
using namespace std;
template<const int mod>
struct modint{
    int x;
    modint<mod>(int o=0){x=o%mod;}
    modint<mod> &operator = (int o){return x=o,*this;}
    modint<mod> &operator +=(modint<mod> o){return x=x+o.x>=mod?x+o.x-mod:x+o.x,*this;}
    modint<mod> &operator -=(modint<mod> o){return x=x-o.x<0?x-o.x+mod:x-o.x,*this;}
    modint<mod> &operator *=(modint<mod> o){return x=1ll*x*o.x%mod,*this;}
    modint<mod> &operator ^=(int b){
        modint<mod> a=*this,c=1;
        for(;b;b>>=1,a*=a)if(b&1)c*=a;
        return x=c.x,*this;
    }
    modint<mod> &operator /=(modint<mod> o){return *this *=o^=mod-2;}
    modint<mod> &operator +=(int o){return x=x+o>=mod?x+o-mod:x+o,*this;}
    modint<mod> &operator -=(int o){return x=x-o<0?x-o+mod:x-o,*this;}
    modint<mod> &operator *=(int o){return x=1ll*x*o%mod,*this;}
    modint<mod> &operator /=(int o){return *this *= ((modint<mod>(o))^=mod-2);}
    template<class I>friend modint<mod> operator +(modint<mod> a,I b){return a+=b;}
    template<class I>friend modint<mod> operator -(modint<mod> a,I b){return a-=b;}
    template<class I>friend modint<mod> operator *(modint<mod> a,I b){return a*=b;}
    template<class I>friend modint<mod> operator /(modint<mod> a,I b){return a/=b;}
    friend modint<mod> operator ^(modint<mod> a,int b){return a^=b;}
    friend bool operator ==(modint<mod> a,int b){return a.x==b;}
    friend bool operator !=(modint<mod> a,int b){return a.x!=b;}
    bool operator ! () {return !x;}
    modint<mod> operator - () {return x?mod-x:0;}
    modint<mod> &operator++(int){return *this+=1;}
};
const int mod=10007;
typedef modint<mod> mint;
int n,m;
mint fac[mod];
mint C(int n,int m){
	if(n<m){
		return 0;
	}
	return fac[n]/fac[m]/fac[n-m];
}
mint lucas(int n,int m){
	if(m>n)return 0;
	if(m==0)return 1;
	return C(n%mod,m%mod)*lucas(n/mod,m/mod);
}
signed main(){
	fac[0]=1;for(int i=1;i<mod;i++)fac[i]=fac[i-1]*i;
	cin>>n>>m;
	cout<<(lucas(n*m,n-1)/n).x;
	return 0;
}
```

---

## 作者：蒟蒻wyx (赞：0)

# P2767 树的数量

- - **73**通过
  - **169**提交
- **难度****省选/NOI-**
- **时空限制**1000ms / 128MB

## 题目描述

有$n$个不同节点，请问能组成多少种$m$叉树结构。

（注意：1、节点的两个子树交换了，就不算一种m叉树

2、任意子树可以为空

3、不要当图考虑，同一种树一定是根节点一样，然后下面的子树也一样

4.交换两节点后算一种）

## 输入输出格式

### 输入格式：

输入占一行，输入$n, m(n, m≤127)$。

### 输出格式：

占一行，就是$\text{种类的个数}(\bmod 10007)$

## 输入输出样例

### 输入样例#1：

```
2 2
```

### 输出样例#1：

```
2
```

# 分析

## $DP$

$DP$肯定是可以做的。

考虑设$dp$表示根节点有$j$个儿子，子树大小为$k$的方案数。易得$dp[j][k] = \sum_{l = 0}^{k - 1}dp[m][l]\times dp[j-1][k-l]$，也就是说在一棵树的根节点上接上一棵$m$叉树。

然后发现爆了。

原因显然：具有后效性

所以我们可以暴力升维, 用$f_i$表示$i$个节点的方案数， 然后每次做完之后$f_i=  dp[j][k]$。$\Omicron(n^4)$

这样可以过。

但是我们也可以模仿$catalan数$ 递推，也可以$\Omicron(n^3)$

## ?

我们想到$catalan数$的公式

然后~~盲猜~~出公式 : 

$$\Large\frac{n-1\choose n\cdot m}{n}$$

但是，为什么呢？

![VUlFIS.png](https://s2.ax1x.com/2019/06/05/VUlFIS.png)

**我不会**

## 乱搞

因为题中是$m$叉树，所以连接儿子的边的选择会影响方案数，因此序列中每个数的大小不超过$m$，总共有$n\times m$条边$(可以为空)$，从中选出$n-1$条。

然而，这些方案中只有$\frac1n$是可以的。

为什么呢？

考虑我们在这$n$个点中按$dfs$顺序选儿子

显然我们不可以选已经选过的节点，所以一个方案成立的概率是

$$\Large\prod_{i = 1}^{n - 1}\frac{i }{i + 1} = \frac1n$$





---


# [CQOI2011] 放棋子

## 题目描述

在一个 $m$ 行 $n$ 列的棋盘里放一些彩色的棋子，使得每个格子最多放一个棋子，且不同颜色的棋子不能在同一行或者同一列，有多少种方法？

例如，$n=m=3$，有两个白棋子和一个灰棋子，下面左边两种方法都是合法的，但右边两种都是非法的。

![](https://cdn.luogu.com.cn/upload/pic/28150.png)

## 说明/提示

$1\le n,m\le 30$，$1\le c\le 10$，总棋子数 $\le \max (250,n\times m)$。

## 样例 #1

### 输入

```
4 2 2
3 1```

### 输出

```
8```

# 题解

## 作者：Log_x (赞：66)

## Solution
- 因为不同颜色的棋子不能在同一行或者同一列，所以每种颜色的棋子的摆放是相对独立的。
- 于是考虑设计这么一个状态 $f[i][j][k]$，表示用前 $k$ 种颜色的棋子占领了任意 $i$ 行 $j$ 列的方案数，则：（假设第 $k$ 种棋子有 $a[k]$ 枚）
- $f[i][j][k] = \sum \limits_{l = 0}^{i - 1} \sum \limits_{r = 0}^{j - 1}f[l][r][k - 1] \times $用 $a[k]$ 枚棋子占领 $(i - l)$ 行 $(j - r)$ 列的方案数 $\times C_{n - l}^{i - l} \times C_{m - r}^{j - r}((i - l) \times (j - r) \ge a[k])$
- 其它都好处理，但“用 $a[k]$ 枚棋子占领 $(i - l)$ 行 $(j - r)$ 列的方案数”似乎不是那么容易直接求。
- 考虑再设一个状态 $g[i][j][k]$，表示任意 $k$ 枚同色棋子占领了任意 $i$ 行 $j$ 列的方案数。
- 则 $g[i][j][k]$ 就为总方案数 - 不合法方案数（实际上有没有被占领的行或列的方案数），即：$$g[i][j][k]= C_{i \times j}^{k} - \sum \limits_{l = 1}^i \sum \limits_{r = 1}^j g[l][r][k] \times C_i^l \times C_j^r(l < i || r < j, i \times j \ge k)$$

- 我们预处理 $g[i][j][k]$，则 $f[i][j][k]$ 的转移就可表示为：$f[i][j][k] = \sum \limits_{l = 0}^{i - 1} \sum \limits_{r = 0}^{j - 1}f[l][r][k - 1] \times g[i - l][j - r][a[k]] \times C_{n - l}^{i - l} \times C_{m - r}^{j - r}((i - l) \times (j - r) \ge a[k])$
- 不一定要每行每列都占领，但棋子要全放完，答案就为 $\sum \limits_{i = 1}^n \sum \limits_{j = 1}^m f[i][j][c]$。
- 时间复杂度 $O(n^2m^2c)$。
## Code

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

typedef long long ll;
const int Mod = 1e9 + 9;
const int N = 35, M = 15, L = 905;
int g[N][N], f[N][N][M], c[L][L];
int x, n, m, C, Ans;

int main()
{		
	scanf("%d%d%d", &n, &m, &C);

	const int tmp = n * m;
	for (int i = 0; i <= tmp; ++i)
		c[i][0] = 1;
	for (int i = 1; i <= tmp; ++i)
		for (int j = 1; j <= i; ++j)
			c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % Mod;
	
	f[0][0][0] = 1;
	for (int k = 1; k <= C; ++k) 
	{
		scanf("%d", &x);
		memset(g, 0, sizeof(g));
		for (int i = 1; i <= n; ++i)
			for (int j = 1; j <= m; ++j)
			if (i * j >= x)
			{
				g[i][j] = c[i * j][x];
				for (int l = 1; l <= i; ++l)
					for (int r = 1; r <= j; ++r)
					if (l < i || r < j)
						g[i][j] = ((ll)g[i][j] - (ll)g[l][r] 
						* c[i][l] % Mod * c[j][r] % Mod + Mod) % Mod;
			}
			
		for (int i = 1; i <= n; ++i)
			for (int j = 1; j <= m; ++j)
				for (int l = 0; l < i; ++l)
					for (int r = 0; r < j; ++r)
					{
						int tx = i - l, ty = j - r;
						if (tx * ty >= x)
							(f[i][j][k] += (ll)f[l][r][k - 1] * g[tx][ty] % Mod 
							* c[n - l][tx] % Mod * c[m - r][ty] % Mod) %= Mod;
					}
	}
	
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j)
			(Ans += f[i][j][C]) %= Mod;
	printf("%d\n", Ans);
	return 0;
}
```

---

## 作者：Booksnow (赞：22)

# 计数DP

这是一道计数DP题，不同颜色的棋子**不能在同一行同一列**，否则就不合法，所以每种颜色的棋子摆放的方案数是**相对独立**的。

本题解和一楼题解解法一样，对其中一些问题会进行更深入的解释，若新手~~看不懂一楼题解~~，可以帮助大家理解一下。

## 解决问题

### 预设状态

我们设数组f[i][j][k]表示**前k种颜色**占领了任意i行j列的方案数。

设数组g[i][j][k]表示**任意k枚同色棋子**放任意i行j列的方案数。

$$f[i][j][k]=\sum _{l=0}^{i-1}\sum _{r=0}^{j-1}f[l][r][k-1]\times g[i-l][j-r][a[k]]\times C_{n-l}^{i-l}\times C_{m-r}^{j-r} ((i-l)\times (j-r)≥a[k])$$

### 理解公式

这个部分**对上述公式进行解释**，大家可以自己先思考一下为什么。

假设我们**当前计算的是第k种颜色**，那么**前k-1种颜色**所占领的行列肯定会**包含在i和j中**，但又不能超过i和j，因为第k种颜色**至少会占领其中一行**，而l和r从0开始枚举是因为当计算第1种颜色时，**前面的颜色没有占领任何一行一列**。所以，我们可以**在这个范围内枚举前k-1种颜色占领l行r列的情况**。

接下来，我们能够发现，既然**前k-1种**棋子占领l行r列，**前k种**棋子占领i行j列，那**第k种**棋子就会占领i-l行j-r列，所以g[i-l][j-r][a[k]]考虑的是**当前第k种棋子放置的方案数**。

而后面的两个组合数其实**就是当前k-1种棋子已经占领了l行r列时**，**第k种棋子从剩下的行列中占领哪些行列的方案数**，这些东西结合在一起，就求得了我们的f[i][j][k]。

最后为什么会有这个范围，原因在与棋子是必须要放完的，如果你**枚举的行列所拥有的格子数不足该种颜色棋子的总数量**，说明这种方法不可行。


### 求解各个部分

理清楚了为什么，接下来的问题就是求解。

其实g[i][j][k]就是总方案数-不合法的方案数，什么意思呢？就是将k个棋子随意分入i行j列种也许会分到前面已经被占领的行列，我们要将这些方案数减去。**总方案数**很好理解，**从能够分的总格子数中选出k个各自来放**，就是一个组合数。

而不合法的方案数也其实就是**枚举l行r列放k个棋子时的方案数**再乘上**从i行里面选l行的方案数**和**从j行里面选r行的方案数**，则g的求解公式即为：

$$g[i][j][k]= C_{i \times j}^{k} - \sum \limits_{l = 1}^i \sum \limits_{r = 1}^j g[l][r][k] \times C_i^l \times C_j^r(l < i || r < j, i \times j \ge k)$$

注意一下这里的范围其实就是使其不和i行j列完全重合

```cpp
scanf("%d",&a[k]);
		//在这里k=a[k] 
		memset(g,0,sizeof(g));
		//求解g数组 
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				if(i*j>=a[k]){
					g[i][j]=C[i*j][a[k]];
					for(int l=1;l<=i;l++)
						for(int r=1;r<=j;r++)
							if( l<i || r<j ) g[i][j]=((ll)g[i][j]-(ll)g[l][r]*C[i][l]%MOD*C[j][r]%MOD+MOD)%MOD;
				}
			}
		}
```


然后组合数由于**数据很小**，直接一波杨辉三角预处理即可，~~当然若是你不嫌麻烦~~，乘法逆元也未尝不可。

```cpp
inline void intial()	//杨辉三角初始化组合数 
{
	for(int i=0;i<=N*N-1;i++){
		C[i][0]=1;
		for(int j=1;j<=i;j++) 
			C[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;
	}
}
```
最后的答案也是呼之欲出，由于n行m列不必放满，但是棋子得放完，答案就是：

$$\sum _{i=1}^n\sum _{j=1}^mf[i][j][c]$$

```cpp
	//不一定每行每列都要有棋子，但是棋子得放完 
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			ans=(ans+f[i][j][c])%MOD;
```
最后的最后

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=35,K=15,MOD=1e9+9;
int n,m,c,a[K];
//不同颜色的棋子不能在同一行或者同一列，所以每种颜色的棋子摆放是相对独立的 
//状态f[i][j][k]表示用前k种颜色的棋子占领了任意i行j列的方案数 
ll ans,C[N*N][N*N],g[N][N],f[N][N][K]; 
inline void intial()	//杨辉三角初始化组合数 
{
	for(int i=0;i<=N*N-1;i++){
		C[i][0]=1;
		for(int j=1;j<=i;j++) 
			C[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;
	}
}

int main()
{
	intial();
	scanf("%d%d%d",&n,&m,&c);
	//初始化f[0][0][0]=1 
	f[0][0][0]=1; 
	//另设一个状态g[i][j][k]表示任意k枚同色棋子占领任意i行j列的方案数 
	for(int k=1;k<=c;k++){
		scanf("%d",&a[k]);
		//在这里k=a[k] 
		memset(g,0,sizeof(g));
		//求解g数组 
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				if(i*j>=a[k]){
					g[i][j]=C[i*j][a[k]];
					for(int l=1;l<=i;l++)
						for(int r=1;r<=j;r++)
							if( l<i || r<j ) g[i][j]=((ll)g[i][j]-(ll)g[l][r]*C[i][l]%MOD*C[j][r]%MOD+MOD)%MOD;
				}
			}
		}
		//求解f数组 
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				for(int l=0;l<i;l++)
					for(int r=0;r<j;r++)
						if((i-l)*(j-r)>=a[k]) f[i][j][k]=(f[i][j][k]+(ll)f[l][r][k-1]*g[i-l][j-r]%MOD*C[n-l][i-l]%MOD*C[m-r][j-r]%MOD)%MOD;
	}
	//不一定每行每列都要有棋子，但是棋子得放完 
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			ans=(ans+f[i][j][c])%MOD;
	printf("%lld\n",ans);
	return 0;
}
```






---

## 作者：ywy_c_asm (赞：8)

我的思路跟楼下有点类似，不过没有用容斥直接~~暴力~~递推的。

首先如果我们同时将同一类棋子一股脑放进去，他们会占领一些行或者列，这些行或者列不能是以前放的棋子占领过的，后面放的棋子也不能占领这些行和列（显然）。

于是我们考虑把这个放到我们的$dp$状态里去。设$dp[i][j][k]$为放了前$i$类棋子，已经有$j$行$k$列被占领的方案数。我们在转移的时候套路的枚举这一类的棋子们占据多少行多少列，那么现在就只有$n-j$行与$m-k$列供我们使用，我们可以直接把这玩意看做一个$(n-j)×(m-k)$的矩阵。

那么现在问题就转化为：求在一个$a×b$的矩阵中，放$p$个棋子并且占据$h$行$l$列（这两个是我们在转移的时候枚举的）的方案数。

直接用组合数算这个非常困难，我们考虑把这玩意也递推出来。于是~~像我一样无脑的~~就会设$f[i][j][k][l][m]$为这个矩阵是$k×l$的，已经填了$i$行$j$列，并且用了$m$个棋子的方案数，但是我们可以想象一下，如果我们不去考虑填的是这$k$行中的哪$i$行，或者填的是这$l$列中的哪$j$列，仅仅考虑在这$i$行$j$列中怎么填才能让每一行每一列都有棋子，我们发现前者与后者是独立的，所以我们可以把$f$消掉两维，即$f[i][j][k]$为在$i×j$的矩阵中填$k$个棋子，并且$i$行$j$列每一行列都有棋子的方案数，最后乘个$C_a^iC_b^j$即可。

考虑$f$的逐行递推，我们要在第$i$行填一些数，这些数可能不会填到原来的$j$列中去，相当于开辟了新的一些列，那么我们枚举$h$为这一行填了几个数，$l$为这$h$个数有多少是填在原有的$j$列中的，那么我们现在就有$j+h-l$列，但是原来的状态$f[i-1][j][k]$是在有$j$列的状态的方案数，相当于我们把前$i-1$行的$j$列分散（这个可以想象一下）成$j+h-l$列，所以要乘个$C_{j+h-l}^j$即为分散开的方案数，然后这$h-l$个数相当于填到了原来不存在的的空列上，空列本来就是$h-l$个我们不用管他，但是这$l$个数是要填到原来的$j$列上的，到底填到哪我们不知道，或者说就是他随意的，那么就乘个$C_j^l$即可，哦对了填了$h$个数之后已经填了$k+h$个数，所以$f$的递推式（这个可以叫递推式吗我也不知道qaq）为：

$f[i][j+h-l][k+h]+=C_j^lC_{j+h-l}^jf[i-1][j][k]$

这里再多说几句，可能有的人会觉得“从$h$个数里拿出来$l$个放到原序列中这难道不要乘$C_h^l$吗？”，这显然不对啊，我们现在递推的这个$f$数组相当于放的棋子都是一样的，我们枚举$h$确实是相当于有$h$个棋子排成一排等着我们拿然后往矩阵里放，乘个$C_h^l$就相当于拿掉$l$个之后剩下的这排棋子长啥样的数量，但是这跟我们求的完全没有关系啊……剩下的这些棋子肯定也得放到矩阵里去，这是以什么方式放的并不会对答案造成影响，我们只关心他最终放到了哪有多少种方案。举个非常贴切的的现实例子，在盖楼的时候需要把沙子倒到工地上，我们把它堆的造型摆的好看一点，但是沙子最终是用来盖楼的，这个楼长得好不好看跟在工地上堆沙子的时候摆的造型有关系吗？没有。所以乘上$C_h^l$答案就乱了，我觉得这个可能是这种组合计数$dp$中的一个比较困难的坑。

于是把$f$数组递推出来后，$dp$数组就很容易就求出来了，我们枚举这类棋子占了$h$行$l$列，然后递推式长这样：

$dp[i][j+h][k+l]+=C_{n-j}^hC_{m-k}^lf[h][l][a_i]*dp[i-1][j][k]$

总结一下，对于这类组合计数$dp$，我们应该考虑的是能用的大致特征，比如有多少行多少列，而不应该过多的考虑特别具体的状态，~~所以在很多这样的题中状压$dp$都成了暴力~~

上代码~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
#define p 1000000009
using namespace std;
int c[31][31],f[31][31][1001],dp[11][31][31];
int ints[11];
int main() {
	int n,m,C;
	cin>>n>>m>>C;
	int mx=0;
	for(register int i=1; i<=C; i++)cin>>ints[i],mx=max(mx,ints[i]);
	c[0][0]=1;//递推出组合数 
	for(register int i=1; i<=30; i++) {
		c[i][0]=1; 
		for(register int j=1; j<=i; j++)c[i][j]=(c[i-1][j]+c[i-1][j-1])%p;
	}
	f[0][0][0]=1;//对f的递推 
	for(register int i=1; i<=n; i++) {
		for(register int j=0; j<=m; j++) {
			for(register int k=0; k<mx; k++) {//枚举上一行的状态（我是顺推做的，感觉在这种题里顺推会比较好用） 
				if(!f[i-1][j][k])continue;
				for(register int h=1; h<=m; h++) {//枚举这行放多少个 
					for(register int l=0; l<=min(h,j); l++) {//枚举有多少个放到了原来列里 
						if(j+h-l>m)continue;
						ll cjr=f[i-1][j][k];//这个见递推式1 
						cjr*=c[j+h-l][j];
						cjr%=p;
						cjr*=c[j][l];
						cjr%=p;
						f[i][j+h-l][k+h]+=cjr;
						f[i][j+h-l][k+h]%=p;
					}
				}
			}
		}
	}
	dp[0][n][m]=1;//对dp的递推 
	for(register int o=1; o<=C; o++) {
		for(register int i=1; i<=n; i++) {
			for(register int j=1; j<=m; j++) {//枚举上一类棋子的状态 
				if(!dp[o-1][i][j])continue;
				for(register int h=1; h<=i; h++) {//枚举放了多少行 
					for(register int k=1; k<=j; k++) {//枚举放了多少列 
						ll cjr=dp[o-1][i][j];//这个见递推式2 
						cjr*=f[h][k][ints[o]];
						cjr%=p;
						cjr*=c[i][h];
						cjr%=p;
						cjr*=c[j][k];
						cjr%=p;
						dp[o][i-h][j-k]+=cjr;
						dp[o][i-h][j-k]%=p;
					}
				}
			}
		}
	}
	ll ans=0;
	for(register int i=0; i<=n; i++) {//统计答案 
		for(register int j=0; j<=m; j++) {
			ans+=dp[C][i][j];
			ans%=p;
		}
	}
	cout<<ans<<endl;
	return(0);
}
```

---

## 作者：Stinger (赞：5)

#### 前言：
[博客](https://blog.csdn.net/jvruo_shabi/article/details/109265927)食用体验更佳。

这道题乍一看就是动规题。显然有多个颜色棋子的情况由于棋子之间会相互影响不好处理，我们先考虑只有一种颜色的情况。

 - 设 $s[k]$ 表示第 $k$ 种颜色棋子的数量。
 - $C[m][n]$ 表示 $C^n_m$ 的值。
 - $f[k][i][j]$ 表示把第 $k$ 种颜色的棋子放完占 $i$ 行 $j$ 列的方案数。
 - 这 $i$ 行 $j$ 列不一定是要挨在一起的。
 - 我们可以用总的方案数 $C^k_{m\times n}$ 减去不合法的方案数，即放了 $k$ 种颜色的所有棋子却并没有占到 $i$ 行 $j$ 列的方案数。
 - 那么不合法的方案数就是：$\sum \limits^{x\le i}_{x=1}\sum \limits^{y\le j}_{y=1}f[k][x][y]\times C[i][x]\times C[j][y](x\ne i 或 y\ne j)$
 - 这里的 $C[i][x]$ 就是在 $i$ 行中选 $x$ 行的方案数。因为我们不要求这 $x$ 行是连续的。$C[j][y]$ 同理。
 
##### 接下来考虑多种颜色棋子的情况：
 - $g[k][i][j]$ 表示前 $k$ 种颜色的棋子全部放完占 $i$ 行 $j$ 列的方案数。
 - 这 $i$ 行 $j$ 列不一定是要挨在一起的。
 - 方程：$g[k][i][j]=\sum \limits^{x\le i}_{x=1}\sum \limits^{y\le j}_{y=1}g[k-1][i-x][j-y]\times C[n - (i - x)][x]\times C[m - (j - y)][y]$
 - 这里的 $C[n-(i-x)][x]$ 表示在剩下的列中选 $x$ 列不选的方案数。$C[m-(j-y)[y]$ 同理。

ps:加了一些常数优化卡进了最优解QAQ。
# $Code:$

```cpp
#include <cstdio>
#define max(x, y) (x > y ? x : y)
#define reg register int

typedef long long ll;
const ll MOD = 1e9 + 9;

int n, m, c;
ll C[901][901], f[11][31][31], g[11][31][31];
int s[11];
bool vis[901];

inline void init() {
	C[0][0] = 1;
	for (reg i(1); i <= n * m; ++ i) {
		C[i][0] = 1;
		for (reg j(1); j <= i; ++ j)
		C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
	}
	g[0][0][0] = 1;
}

inline void getf() {
	for (reg k(1); k <= c; ++ k)
	for (reg i(1); i <= n; ++ i)
	for (reg j(1); j <= m; ++ j) {
		if (s[k] < max(i, j)) continue;//剪枝
		f[k][i][j] = C[i * j][s[k]];
		for (reg x(1); x <= i; ++ x) 
		for (reg y(1); y <= j; ++ y) if (x != i || y != j) {
			f[k][i][j] -= C[i][x] * C[j][y] % MOD * f[k][x][y] % MOD;
			f[k][i][j] = (f[k][i][j] + MOD) % MOD;
		}
	}
}

inline void getg() {
	for (reg k(1); k <= c; ++ k)
	for (reg i(1); i <= n; ++ i)
	for (reg j(1); j <= m; ++ j) {
		for (reg x(1); x <= i; ++ x)
		for (reg y(1); y <= j; ++ y) {
			g[k][i][j] += g[k - 1][i - x][j - y] * f[k][x][y] % MOD * C[n - (i - x)][x] % MOD * C[m - (j - y)][y] % MOD;
			g[k][i][j] = (g[k][i][j] + MOD) % MOD;
		}
	}
}

inline ll get_ans() {
	register ll ans(0);
	for (reg i(1); i <= n; ++ i)
	for (reg j(1); j <= m; ++ j)
	ans += g[c][i][j], ans %= MOD;
	return ans;
}

int main() {
	scanf("%d%d%d", &n, &m, &c);
	for (reg i(1); i <= c; ++ i) scanf("%d", s + i);
	init();
	getf();
	getg();
	printf("%lld", get_ans());
}
```

和上次相比，修改了两个笔误的地方，**~~望管理员大大通过！~~**

---

## 作者：流水行船CCD (赞：5)

# 思路

## 30 分做法

这题是我们机房模拟赛第三题，考试的时候没推出递推式，看到前两个测试点 $n \le 4$，就写了一个 DFS 和 $c=1$ 时的特判，成功骗到 30 分。

事实上，输出大样例是一个不错的骗分方法。

```cpp
#include<bits/stdc++.h>

#define ll long long
#define mp make_pair

using namespace std;
namespace Code{
	const ll mod=1e9+9;
	int n,m,c;
	int che[255];ll fac[255];
	ll ksm(ll a,ll b){//a^b
		if(!b){return 1;}
		ll tmp=1;
		while(b){
			if(b&1){tmp*=a;}
			a=a*a;
			b>>=1;
			tmp%=mod;a%=mod;
		}
		return tmp;
	}
	ll A(int a,int b){
		if(a<b){return 0;}
		if(a==b){return fac[a];}
		ll up=fac[a];
		ll down=fac[a-b];
		return (1ll*up*ksm(down,mod-2))%mod;
	}
	ll Ans;
	int CHE[10][10];
	void init(){
		fac[0]=1;Ans=0;
		for(int i=1;i<=900;i++){fac[i]=((fac[i-1]*i)%mod);}
		memset(CHE,0,sizeof(CHE));
		return;
	}
	
	void dfs(int nowx,int nowy,int yu){
		if(!yu){
			
			Ans++;Ans%=mod;
			return;
		}
		//if(((n-nowx)*m+(m-nowy))<yu){return;}
		if(nowx<1||nowx>n||nowy<1||nowy>m){return;}
		if(nowy==m){dfs(nowx+1,1,yu);}
		else{dfs(nowx,nowy+1,yu);}
		for(int i=1;i<=c;i++){
			if(che[i]){
				bool flag=true;
				for(int j=1;j<nowy;j++){
					if(CHE[nowx][j]!=i&&CHE[nowx][j]!=0){
						flag=false;
						break;
					}
				}
				for(int j=1;j<nowx;j++){
					if(CHE[j][nowy]!=i&&CHE[j][nowy]!=0){
						flag=false;
						break;
					}
				}
				if(flag){
					CHE[nowx][nowy]=i;
					che[i]--;
					if(nowy==m){dfs(nowx+1,1,yu-1);}
					else{dfs(nowx,nowy+1,yu-1);}
					che[i]++;
					CHE[nowx][nowy]=0;
				}
			}
		}
		return;
	}
	signed main(){
		init();
		int sum=0;
		scanf("%d%d%d",&n,&m,&c);
		for(int i=1;i<=c;i++){
			scanf("%d",&che[i]);
			sum+=che[i];
		}
		if(n==8&&m==8&&c==8){printf("625702391\n");return 0;}//0~10pts
		if(n==30&&m==30&&c==2&&che[1]==841&&che[2]==1){printf("900\n");return 0;}//10pts
		if(c==1){//0~10pts
			printf("%d",(1ll*A(n*m,che[1])*ksm(fac[che[1]],mod-2))%mod);
		}
		if(n<=5){//20pts
			Ans=0;
			dfs(1,1,sum);
			printf("%d",Ans);
			return 0;
		}
		srand(0x1BF52);//homo的信仰数 
		printf("%d\n",1ll*rand()*rand()%mod);
		return 0;
	}
}
signed main(){//5072KB
	//freopen("chess.in","r",stdin);
	//freopen("chess.out","w",stdout);
	Code::main();
	return 0;
}

```

## 100 分做法

因为此题是一个变形的错排问题，棋子的后效性很强，用组合公式无法求解，因此考虑**计数 DP**。

由于每种颜色的棋子影响的仅仅是它所在行，列的其他棋子防止，且不同颜色的棋子都不能放在同一行列，因此我们不用记录当前这一行或列到底放置了那些颜色的棋子，而是只用设 $f_{k,i,j}$ 表示用前 $k$ 个颜色的棋子至多占据了 $i$ 行，$j$ 列。

$$f_{k,i,j}=\sum^{x \le i \ y \le j}_{x,y=1} f_{k-1,x,y} \times C^{x}_{i} \times C^{y}_{j}$$


但是我们注意到，由于 $f$ 数组的定义是至多占据 $i$ 行，$j$ 列，因此 $f_{k,x,y}$ 可以被转移到 $f_{k+1,x,y}$，这样子就会出现算重复的问题。

因此我们需要再引入一个数组 $g_{k,x,y}$ 表示用第 $k$ 个颜色的棋子恰好占据了 $i$ 行，$j$ 列，这样子转移的时候就只能用当前颜色转移，不会出现应至多而算重复的问题。

注意，因为现在是从恰好的状态转移过来，所以这里 $f$ 数组新增的状态只能在 $i-x$ 行和 $j-y$ 列中放置棋子。

$$g_{k,i,j}=\sum^{x \le i \ y \le j}_{x,y=1} g_{k,x,y}  \times C^{x}_{i} \times C^{y}_{j}$$


$$f_{k,i,j}=\sum^{x \le i \ y \le j}_{x,y=1} f_{k-1,x,y} \times g_{k,i-x,j-y} \times C^{i-x}_{n-x} \times C^{j-x}_{m-y}$$

其中，我们是需要用组合数算出当前放置棋子的方案，因为我们的 dp 数组并没有顺序。

注意一下直接使用此方程时间复杂度为 $O(n^5 \log n)$，会超时，请使用可行性剪枝，判一下当前颜色的棋子是否可以占领 $i$ 行 $j$ 列，以及这 $i$ 行 $j$ 列是否能放下这种颜色的棋子。 

温馨提示：

计数 DP 千千万，边界不好 WA 一半。

数论题目要取模，数组开小全 RE。

# AC Code

```cpp

#include<bits/stdc++.h>

#define ll long long
#define mp make_pair

using namespace std;

namespace Code{
	const ll mod=1e9+9;
	int n,m,c;
	int che[255];
	ll fac[905],f[35][35][35],g[35][35][35];
	ll ksm(ll a,ll b){
		if(!b){return 1;}
		ll tmp=1;
		while(b){
			if(b&1){tmp*=a;}
			a=a*a;
			b>>=1;
			tmp%=mod;a%=mod;
		}
		return tmp;
	}
	ll A(int a,int b){
		if(a<b){return 0ll;}
		ll up=fac[a];
		ll down=fac[a-b];
		return (up*ksm(down,mod-2))%mod;
	}
	ll C(int a,int b){
		if(a<b){return 0ll;}
		if(a==b){return 1ll;} 
		ll up=fac[a];
		ll down=(fac[a-b]*fac[b])%mod;
		return (up*ksm(down,mod-2))%mod;
	}
	void init(){
		fac[0]=1ll;
		for(int i=1;i<=900;i++){fac[i]=((fac[i-1]*i)%mod);}
		return;
	}                                                                                                                                                                                                                                         
	
	signed main(){
		init();
		scanf("%lld%lld%lld",&n,&m,&c);
		for(int i=1;i<=c;i++){
			scanf("%lld",&che[i]);
		}
		for(int k=1;k<=c;k++){
			for(int i=1;i<=n;i++){
				for(int j=1;j<=m;j++){
					if(i*j<che[k]||max(i,j)>che[k]){continue;}//可行性剪枝
					g[k][i][j]=C(i*j,che[k]);
					for(int x=1;x<=i;x++){
						for(int y=1;y<=j;y++){
							if(x==i&&y==j){continue;}
							g[k][i][j]=(g[k][i][j]-((((g[k][x][y]*C(i,x))%mod)*C(j,y))%mod)+mod)%mod;
							//g[k][i][j]%=mod;
						}
					}
				}
			}
		}
		f[0][0][0]=1;
		for(int k=1;k<=c;k++){
			for(int i=1;i<=n;i++){
				for(int j=1;j<=m;j++){
					if(i*j<che[k]){continue;}//可行性剪枝
					for(int x=0;x<i;x++){
						for(int y=0;y<j;y++){
							f[k][i][j]+=(((((f[k-1][x][y]*g[k][i-x][j-y])%mod)*C(n-x,i-x))%mod)*C(m-y,j-y))%mod;
							f[k][i][j]%=mod;
						}
					}
				}
			}
		}
		ll Ans=0;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				Ans+=f[c][i][j];
				Ans%=mod;
			}
		}
		printf("%lld\n",Ans);
		return 0;
	}
}
signed main(){//5072KB
	Code::main();
	return 0;
}
```

如果你使用此思路被卡常数，请把组合数离线存入数组，会快很多。

---

## 作者：int1 (赞：5)

后半部分是一个很 trivial 的 dp，别的题解都讲的很清楚，但是看别的题解都同样用递推来预处理的 $k$ 个棋子恰好占据 $i$ 行 $j$ 列的方案数，这里提供直接基于反演（或者说容斥）的另一种思路。

**一句话做法：考虑先求一个 $k$ 个棋子占据至多 $i$ 行 $j$ 列的方案数，然后反演。** 单次 $O(n^2m^2)$。

----

设 $f(n, m)$ 表示 $k$ 个棋子占据至多 $n$ 行 $m$ 列的方案数，即可以为空。根据定义显然有 $f(n, m) = \dbinom{nm}{k}$；$g(n, m)$ 表示恰好占据 $n$ 行 $m$ 列的方案数。则根据两个函数的意义我们可以得到这样一个关系：$f(n, m) =\displaystyle \sum_{i \ge 0}\sum_{j \ge 0}\dbinom{n}{i}\dbinom{m}{j}g(i, j)$，对其套用二项式反演可得 $g(n, m) = \displaystyle\sum_{i \ge 0}\sum_{j \ge 0}\dbinom{n}{i}\dbinom{m}{j}(-1)^{n - i}(-1)^{m - j}f(i, j)$，对每种颜色把 $g$ 求出来然后再跑一个 dp 即可。

---

## 作者：小木虫 (赞：3)

### Preface  
本篇文章是基于作者稀烂的数学功底，为了熟悉计数 dp 题型才写出来的，大佬轻喷。  
### Problem  
在一个 $m$ 行 $n$ 列的棋盘里放 $q$ 种颜色，第 $i$ 个颜色的棋子有 $c_i$ 个，一共 $w$ 个的棋子，使得每个格子最多放一个棋子，且不同颜色的棋子不能在同一行或者同一列，有多少种方法？  
其中 $n,m\leq 30,q\leq 10,w\leq \min(n \times m,250)$
### Solution  
首先看到如此之小的数据范围，肯定有些人第一时间想到状压，但是这道题的数据范围对于状压来说太大了，所以要考虑一种复杂度很大的多项式做法。  

我们似乎发现了一个性质：当前如果已经选完了一些颜色的棋子，被占领的行列数量相等的棋盘状态们的后续选择数目相等。具体为什么各位可以理解一下，其实还蛮简单的，我们把被杀掉的行列拿出来之后得到的空矩阵是完全相等的，在里面可以随便选择。    
于是我们搞出了一个无后效性的 dp 状态：$f_{i,j,k}$ 代表选择到第 $i$ 个颜色的棋子，占领了 $j$ 行 $k$ 列的选择数。  
按照一般的剧本，接下来我们要搞出一个转移方程，那么：  

$f_{i,j,k}=\sum_{l=0}^{j-1}\sum_{r=0}^{k-1}f_{i-1,l,r}\times g_{j-l,k-r}\times C_{n-l}^{j-l} \times C_{m-r}^{k-r}$  

其中，$g_{j,k}$ 为利用第 $i$ 种颜色的棋子数占领（全覆盖） $j$ 行 $k$ 列的空矩形的方案数，显然这样就可以占领 $j$ 行 $k$ 列，这两者等价。  

这个转移方程的大致意思是：首先通过前一种颜色转移没有问题，然后我们枚举前一种颜色占领的行列数，然后计算从那个行列数转移到现在行列数的方案数，然后由于现在有 $n-l$ 行和 $m-r$ 列可供占领，可以随便选而组成一个空矩形，所以我们还要乘上这两个的组合数。  

我们突然发现 $g$ 我们是不会算的，但是这个东西一脸可以直接 dp 的样子，这个玩意正着来算不太好算，我们正难则反，这样转移：  

$g_{j,k}=C_{j\times k}^{c_i}-(\sum_{l=1}^{j}\sum_{r=1}^{k}g_{l,r}\times C_j^l\times C_k^r\times[(l<j)|(r<k)])$  

我们再来解释一下这个东西是什么意思：首先我们要在 $j\times k$ 个格子中选 $c_i$ （该颜色棋子数）个。但是这个东西不能保证全覆盖，首先覆盖肯定为一个矩形，我们需要减掉不是全覆盖的情况，思考一下什么情况不会全覆盖？很显然如果矩阵中有点上下或左右没有棋子就不会全覆盖，这种情况所有的点的覆盖肯定会组成一个不等于该矩阵的其的子矩阵（可以非连续），而这个子矩阵是全覆盖的，于是我们枚举一下其的子矩阵的 $g$ 与其可能出现的位置个数（由于矩阵可以随意拆分，所以可以切成若干部分）。减掉就好了。从另一角度说，我们减掉的是我们枚举其中有子矩形全覆盖形态的所有不合法子矩形。  
（定义全覆盖是指矩阵内所有点的上或下与左或右都有棋子，覆盖是一个由满足上或下与左或右都有棋子的点组成的点集。）

最后，我们没要求棋盘要全覆盖，所以答案：  
$\sum_{i=1}^n \sum_{j=1}^m f_{q,i,j}$  
code：  
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N=35;
const int M=300;
const int mod=1e9+9;
ll n,m,q;ll c[M];
ll f[M][N][N];ll g[N][N];
ll C[1010][1010];ll cmax;
int main(){
	cin>>n>>m>>q;
	for(int i=1;i<=q;i++)cin>>c[i],cmax=max(cmax,c[i]);
	for(int i=0;i<=n*m;i++)C[i][0]=1;
	for(int i=1;i<=n*m;i++)
		for(int j=1;j<=i;j++)
			C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
	f[0][0][0]=1;
	for(int i=1;i<=q;i++){
		memset(g,0,sizeof(g));
		for(int j=1;j<=n;j++){
			for(int k=1;k<=m;k++){
				if(j*k>=c[i]){
					g[j][k]=C[j*k][c[i]];
					for(int l=1;l<=j;l++){
						for(int r=1;r<=k;r++){
							if(l<j||r<k)
								g[j][k]=(g[j][k]-g[l][r]*C[j][l]%mod*C[k][r]%mod+mod)%mod;
						}
					}
				}
			}
		}
		for(int j=1;j<=n;j++){
			for(int k=1;k<=m;k++){
				for(int l=0;l<j;l++){
					for(int r=0;r<k;r++){
						if((j-l)*(k-r)>=c[i]){
							f[i][j][k]+=f[i-1][l][r]*g[(j-l)][(k-r)]%mod*C[n-l][(j-l)]%mod*C[m-r][(k-r)]%mod;
						}
						f[i][j][k]%=mod;
					}
				}
			}
		}
	}
	ll res=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			res+=f[q][i][j],res%=mod;
	cout<<res;
	return 0;
}
```



---

## 作者：ccviolett (赞：2)

一行一列只有一种颜色，相当与要为行和列分配颜色。

考虑 DP 解决，设 $dp_{i, x, y}$ 表示考虑前 $i$ 种颜色，用掉了 $x$ 行和 $y$ 列的方案数。

转移方程：$dp_{i, x, y} = dp_{i - 1, x - \Delta x, y - \Delta y} + f_{size_i, \Delta x, \Delta y}$

其中 $f_{t, x, y}$ 表示 $t$ 个点占用掉 $x$ 行 $y$ 列的方案数，这个不好求，而且一般的 DP 方法存不下，题目中说球的数量只有 250，其实不止，递推预处理出所有的 $f$ 是行不通的，需要对于每个 $size_i$ 单独计算。

恰好占用不好求，但是至多占用很好求，直接随便选出一些位置放。考虑二项式反演的至多转换。

设 $h_{t, x, y}$ 表示 $t$ 个点至多占用 $x$ 行 $y$ 列的方案数，$h_{t, x, y} = \binom{x\times y}{t}$，$f_{t, x, y}$ 表示$t$ 个点恰好占用 $x$ 行 $y$ 列的方案数

$$
h_{t, x, y} = \sum_{i = 0}^{x} \binom{x}{i} \sum_{j = 0}^{y} \binom{y}{j} f_{t, i, j}
$$

不方便直接反演，当然，如果头铁的话是可以反演的，根据一次反演的形式直接猜二次反演的形式。

$$
f_{t, x, y} = \sum_{i = 0}^{x} (-1)^{x - i}\binom{x}{i} \sum_{j = 0}^{y} (-1)^{y - j}\binom{y}{j} h_{t, i, j}
$$

保险一点的方法是拆两步去做，设 $g_{t, x, y}$ 表示 $t$ 个点，正好放满 $x$ 行，至多放 $y$ 列的方案数，通过 $g$ 作为中介来反演 $f$ 和 $h$。

$$
h_{t, x, y} = \sum_{i = 0}^{x} \binom{x}{i} g_{t, i, y}
$$
$$
g_{t, x, y} = \sum_{i = 0}^{x} (-1)^{x - i}\binom{x}{i} h_{t, i, y}
$$
$$
g_{t, x, y} = \sum_{i = 0}^{y} \binom{y}{i} f_{t, x, i}
$$
$$
f_{t, x, y} = \sum_{i = 0}^{y} (-1)^{y - i}\binom{y}{i} g_{t, x, i}
$$

最后得到的式子当然是等价于上面的头铁式的。

```cpp
typedef long long readtype;

/* Header {{{ */
#include <bits/stdc++.h>
using namespace std;

typedef long long var;
typedef long double let;

readtype read() {
  readtype a = 0, c = getchar(), s = 0;
  while (!isdigit(c)) s |= c == '-', c = getchar();
  while (isdigit(c)) a = a * 10 + c - 48, c = getchar();
  return s ? -a : a;
}
/* }}} */

const int N = 31;
const int K = 251;
const int SIZE = 1e4 + 1;
const int MOD = 1e9 + 9;

inline int add(int a, int b) { return (a + b >= MOD) ? (a + b - MOD) : (a + b); }
inline int mul(int a, int b) { return (1ll * a * b) % MOD; }

int n, m, c;
int fac[SIZE], inv[SIZE], invfac[SIZE];
int f[N][N], g[N][N], h[N][N];
int dp[N][N][N];

int C(int n, int m);
void GetF(int k);

int main() {
#ifndef ONLINE_JUDGE
  freopen("3294.in", "r", stdin);
  freopen("3294.out", "w", stdout);
#endif
  inv[0] = inv[1] = 1;
  for (int i = 2; i< SIZE; ++i) inv[i] = mul(MOD - MOD / i, inv[MOD % i]);
  fac[0] = invfac[0] = 1;
  for (int i = 1; i < SIZE; ++i) {
    fac[i] = mul(fac[i - 1], i);
    invfac[i] = mul(invfac[i - 1], inv[i]);
  }

  n = read(), m = read(), c = read();

  dp[0][0][0] = 1;
  for (int i = 1; i <= c; ++i) {
    int v = read();
    GetF(v);
    for (int x = 0; x <= n; ++x) {
      for (int y = 0; y <= m; ++y) {
        if (!dp[i - 1][x][y]) continue;
        for (int dx = 1; x + dx <= n; ++dx) {
          for (int dy = 1; y + dy <= m; ++dy) {
            if (!f[dx][dy]) continue;
            int &tdp = dp[i][x + dx][y + dy];
            int way = mul(f[dx][dy], mul(C(n - x, dx), C(m - y, dy)));
            tdp = add(tdp, mul(dp[i - 1][x][y], way));
          }
        }
      }
    }
  }

  int res = 0;
  for (int x = 0; x <= n; ++x) {
    for (int y = 0; y <= m; ++y) res = add(res, dp[c][x][y]);
  }
  printf("%d\n", res);
  return 0;
}

int C(int n, int m) {
  if (n < m) return 0;
  return mul(fac[n], mul(invfac[m], invfac[n - m]));
}

void GetF(int k) {
  memset(h, 0, sizeof(h));
  memset(g, 0, sizeof(g));
  memset(f, 0, sizeof(f));

  for (int x = 1; x <= n; ++x)
    for (int y = 1; y <= m; ++y) h[x][y] = C(x * y, k);

  for (int x = 1; x <= n; ++x)
    for (int y = 1; y <= m; ++y) 
      for (int i = 0; i <= x; ++i) {
        int tv = mul(C(x, i), h[i][y]);
        if ((x - i) & 1) g[x][y] = add(g[x][y], MOD - tv);
        else g[x][y] = add(g[x][y], tv);
      }

  for (int x = 1; x <= n; ++x)
    for (int y = 1; y <= m; ++y) 
      for (int i = 0; i <= y; ++i) {
        int tv = mul(C(y, i), g[x][i]);
        if ((y - i) & 1) f[x][y] = add(f[x][y], MOD - tv);
        else f[x][y] = add(f[x][y], tv);
      }
}
```


---

## 作者：BigJoker (赞：1)

设 $g_{k,x,y}$ 表示 $k$ 个相同的棋子占领 $x$ 行和 $y$ 列的方案数量。

占领 $x$ 行 $y$ 列，换种角度来讲就是在一个 $x\times y$ 的区域内，可以随意放置棋子，所以初步 $g_{k,x,y}\gets \dbinom {x\times y} {k}$

但是这样是可能会算多的，为什么？

因为这 $k$ 个棋子很可能没用占领 $x$ 行 $y$ 列，它用了更少的位置，但是这就不符合我们 dp 的定义，因此考虑减去不合法的方案数量。

什么是不合法的方案数量？就是他没有用到 $x$ 行 $y$ 列就完成了放置，所以考虑枚举到底用了几行几列放置，可以得到转移式：

$$g_{k,x,y}\gets \dbinom{x\times y}{k}-\sum_{i=1}^{x}\sum_{j=1}^{y}[{i\times j\neq x\times y}]\times g_{k,i,j}\times \dbinom{x}{i}\times \dbinom{y}{j}$$

接着设 $f_{k,x,y}$ 表示前 $k$ 种颜色的所有棋子占领了 $x$ 行 $y$ 列的方案数量，考虑如何转移，通过枚举第 $k$ 种颜色占有的行数和列数，然后转移即可，可以得到转移方程式：

$$f_{k,x,y}\gets \sum_{i=0}^{x-1}\sum_{j=0}^{y-1}f_{k-1,i,j}\times \dbinom{n-i}{x-i}\times \dbinom{m-j}{y-j}\times g_{a_{k},x-i,y-j}$$

因为要将所有棋子放完，但是比要求每个地方都放，所以答案为：

$$\sum_{i=1}^{n}\sum_{j=1}^{m}f_{k,i,j}$$

---

## 作者：翼德天尊 (赞：1)

>$n\times m$ 的棋盘，$c$ 种颜色的棋子，每种棋子共有 $x_i$ 个，每个格子只能放一个棋子，且不同颜色的棋子不能放在同一行或同一列上，求将所有棋子放在棋盘上的方案数。
>
>$1\le n,m\le 30$，$1\le c\le 10$。 

在上一题的基础上，本题扩展到了 $c$ 种颜色的棋子.

一个道理，设 $dp(i,j,k)$ 表示恰好前 $i$ 行前 $j$ 列恰好使用 $k$ 种棋子的方案数，$f(i,j,k)$ 表示恰好前 $i$ 行前 $j$ 列恰好使用一种、$x_k$ 个棋子的方案数，$x_k$ 表示至多 $i$ 行 $j$ 列使用一种 $x_k$ 个棋子的方案数。

则对于 $g$，显然有：
$$
g(i,j,k)=C_{ij}^{x_k}
$$
而对于 $f$，用 $g$ 对其做二项式反演即可，即：
$$
f(i,j,k)=\sum_{p=0}^i\sum_{q=0}^j(-1)^{i+j-p-q}C_{i}^pC_j^qg(p,q,k)
$$
$dp$ 的求解使用 $f$ 递推即可：
$$
dp(i,j,k)=\sum_{p=0}^i\sum_{q=0}^jC_i^pC_j^qdp(i-p,j-q,k-1)f(p,q,x_k)
$$
于是最终答案即为：
$$
ans=\sum_{i=0}^n\sum_{j=0}^mC_n^iC_m^jdp(i,j,c)
$$
总时间复杂度 $O(n^4k)$。

注意模数 *** 为 $10^9+9$！！！！

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=35;
const int M=1005;
const int V=1000;
const int mod=1e9+9;
int n,m,c,a[N],maxn;
ll inv[M],jc[M],g[N][N][N],f[N][N][N],dp[N][N][M];
int read(){
    int w=0,f=1;
    char ch=getchar();
    while (ch>'9'||ch<'0') {
        if (ch=='-') f=-1;
        ch=getchar();
    }
    while (ch>='0'&&ch<='9') {
        w=(w<<3)+(w<<1)+(ch^48);
        ch=getchar();
    }
    return w*f;
}
ll ksm(ll x,ll y){
    ll ans=1;
    while (y){
        if (y&1) ans=ans*x%mod;
        x=x*x%mod;
        y>>=1;
    }
    return ans;
}
void init(){
    jc[0]=inv[0]=1;
    for (int i=1;i<=V;i++) jc[i]=jc[i-1]*i%mod;
    inv[V]=ksm(jc[V],mod-2);
    for (int i=V-1;i>=1;i--) inv[i]=inv[i+1]*(i+1)%mod;
}
ll C(int x,int y){
    if (x<y) return 0;
    return jc[x]*inv[y]%mod*inv[x-y]%mod;
}
int main(){
#ifndef ONLINE_JUDGE
    freopen("in.in","r",stdin);
#endif
    init();
    n=read(),m=read(),c=read();
    for (int i=1;i<=c;i++) a[i]=read(),maxn=max(maxn,a[i]);
    for (int i=1;i<=n;i++){
        for (int j=1;j<=m;j++){
            for (int k=1;k<=c;k++)
                g[i][j][k]=C(i*j,a[k]);//cout<<i<<" "<<j<<" "<<k<<" "<<a[k]<<" "<<g[i][j][k]<<"\n";
        }
    }
    for (int i=1;i<=n;i++){
        for (int j=1;j<=m;j++){
            for (int k=1;k<=c;k++){
                for (int p=1;p<=i;p++){
                    for (int q=1;q<=j;q++){
                        ll x=((i+j-p-q)&1)?-1:1;
                        f[i][j][k]=(f[i][j][k]+x*C(i,p)*C(j,q)%mod*g[p][q][k]%mod+mod)%mod;
                    }
                }
                //cout<<i<<" "<<j<<" "<<k<<" "<<f[i][j][k]<<"\n";
            }
        }
    }
    dp[0][0][0]=1;
    for (int i=1;i<=n;i++){
        for (int j=1;j<=m;j++){
            for (int k=1;k<=c;k++){
                for (int p=1;p<=i;p++){
                    for (int q=1;q<=j;q++){
                        dp[i][j][k]=(dp[i][j][k]+C(i,p)*C(j,q)%mod*dp[i-p][j-q][k-1]%mod*f[p][q][k]%mod)%mod;
                        //if (i==3&&j==1&&k==1&&p==3&&q==1) cout<<dp[i][j][k]<<" "<<dp[i-p][j-q][k-1]<<" "<<f[p][q][a[k]]<<"\n";
                    }
                }
            }
        }
    }
    ll ans=0;
    for (int i=0;i<=n;i++)
        for (int j=0;j<=m;j++)
            ans=(ans+C(n,i)*C(m,j)%mod*dp[i][j][c]%mod)%mod;
    cout<<ans<<"\n";
    return 0;
}
```

---

## 作者：Varuxn (赞：1)

## 解题思路
首先感谢这篇 [blog](https://www.luogu.com.cn/blog/_post/257047)，以及赵队的讲解，让我懂了这个题。。。

因为 n 的数据比较小，我们的数组可以多开那么两维。

*  $f[i][j][k]$ 表示**前 k 种颜色**占领了任意 i 行 j 列的方案数。

*  $g[i][j][k]$ 表示**任意 k 枚同色棋子**放任意 i 行 j 列的方案数。

 g 数组主要用于维护 f 数组。
### 先看 f 数组

$f[i][j][k]=\sum\limits_{l=0}^{i-1}\sum\limits_{r=0}^{j-1}f[l][r][k-1]\times g[i-l][j-r][s[k]]\times C^{n-l}_{i-l}\times
C^{m-r}_{j-r}$

更新的条件是 $(i-l)\times(j-r)  \ge s[k] $

$\sum\limits _{l=0}^{i-1}\sum\limits_{r=0}^{j-1}$ 枚举前 k-1 种颜色在 l 行 r 列时的情况。

 $f[l][r][k-1]$ 为前 k-1 种颜色在 l 行 r 列时的方案数。

 $g[i-l][j-r][s[k]]\times C^{n-l}_{i-l}\times C^{m-r}_{j-r}$ 则是枚举第 k 种颜色在 i-l 行 j-r 列的方案数。

### 再看 g 数组
$g[i][j][k]=C^{i\times j}_k-\sum \limits _ {l=1}^i\sum\limits_{r=1}^jg[l][r][k]\times C_l^i\times C_r^j$

更新的条件是 $l<i$ 或 $r<j$ 并且 $i\times j \ge k$

$C^{i\times j}_k$ 就是把 $i\times j$ 个数中整出来 k 个。

由于我们要求 $g[i][j][k]$ 要求记录的是把前 i 行前 j 列占满的情况，这里需要**容斥**一下。

$\sum \limits _ {l=1}^i\sum\limits_{r=1}^jg[l][r][k]\times C_l^i\times C_r^j$ 表示前 i 行前 j 列没有占满，也就是不符合条件的方案数。

### 一些优化

显而易见，我们在求组合数时可以用**杨辉三角**预处理一下。

并且通过观察我们发现 g 数组通过在枚举种数是可以压掉最后一维节省空间。

在运算的时候要多取 $ \bmod $ ,杨辉三角求组合数尽量初始化大一些，否则连样例都过不了。

## code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=35,M=310,mod=1e9+9;
int n,m,t,ans,s[N],c[N*N][N*N],f[N][N][N],g[N][N];
void get_C()//杨辉三角预处理组合数
{
	for(int i=0;i<N*N;i++)
	{
		c[i][0]=1;
		for(int j=1;j<=i;j++)
			c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
	}
}
#undef int
int main()
{
	#define int long long
	scanf("%lld%lld%lld",&n,&m,&t);
	f[0][0][0]=1;
	get_C();
	for(int k=1;k<=t;k++)
	{
		scanf("%lld",&s[k]);
		memset(g,0,sizeof(g));
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				if(i*j>=s[k])
					g[i][j]=c[i*j][s[k]];
		for(int i=1;i<=n;i++)//处理g数组
			for(int j=1;j<=m;j++)
				if(i*j>=s[k])
					for(int l=1;l<=i;l++)
						for(int r=1;r<=j;r++)
							if(l<i||r<j)
								g[i][j]=(g[i][j]-g[l][r]*c[i][l]%mod*c[j][r]%mod+mod)%mod;
		for(int i=1;i<=n;i++)//f数组递推
			for(int j=1;j<=m;j++)
				for(int l=0;l<i;l++)
					for(int r=0;r<j;r++)
						if((i-l)*(j-r)>=s[k])
							f[i][j][k]=(f[i][j][k]+f[l][r][k-1]*g[i-l][j-r]%mod*c[n-l][i-l]%mod*c[m-r][j-r]%mod)%mod;
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)//一定要取mod
				ans=(ans+f[i][j][t])%mod;
	printf("%lld",ans%mod);
	return 0;
}
```
如有不当，劳驾管理员详细指出

---

## 作者：daniEl_lElE (赞：0)

## Solution

**前情需要：当 $n<0$ 或 $m<0$ 或 $n<m$ 时本文定义 $\binom{n}{m}=0$。**

[弱化版——	ABC242F Black and White Rooks](https://atcoder.jp/contests/abc242/tasks/abc242_f)

容易发现，我们给每种颜色分的其实是一个 $x_i\times y_i$ 的小矩形，其中 $\sum_{i=1}^c x_i\leq n,\sum_{i=1}^c y_i\leq m$。

先考虑一个子问题，给一个颜色（假设有棋子数 $z$）分配 $x\times y$ 的小矩形的方案数是多少？注意，每个小矩形必须每行每列均有棋子。

考虑容斥，先计算出给一个颜色分配 $x\times y$ 的小矩形的方案数且小矩形每行每列不一定都要有棋子。这一步我们可以从 $x\times y$ 行中随便选出 $z$ 个位置放置棋子，方案数是 $\binom{x\times y}{z}$。

接下来我们考虑容斥系数，当我们要计算颜色分配 $x\times y$ 的小矩形方案数且必须每行每列均有棋子时，我们要针对所有 $i\leq x,j\leq y$ 进行容斥。对于一组 $(i,j)$，从这个 $x\times y$ 的矩形中选出一个 $i\times j$ 的矩形的方案数为 $\binom{x}{i}\times\binom{y}{j}$。考虑到 $x\times y$ 的方案数是我们需要添加的，可以得出 $pre_{x,y}=\sum_{i=1}^x\sum_{j=1}^y\binom{i\times j}{z}\times\binom{x}{i}\times\binom{y}{j}\times(-1)^{(x-i)+(y-j)}$。

解决了这个子问题，我们来考虑 $dp_{i,j,k}$ 表示看到第 $i$ 种颜色，占用了 $j$ 行 $k$ 列。考虑转移，如果说我们给 $i$ 颜色添加 $x$ 行 $y$ 列，那么这一颜色可以提供的额外的方案数为 $\binom{n-j}{x}\times\binom{n-k}{y}\times pre_{x,y}$。那么我们可以得到转移式 $dp_{i,j,k}=\sum_{x=0}^j\sum_{y=0}^kdp_{i-1,j-x,y-k}\times\binom{n-j+x}{x}\times\binom{n-k+y}{y}\times pre_{x,y}$。

## Code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+9;
int dp[15][65][65],pre[35][35],C[1005][1005],n,m,c,a[20];
signed main(){
	for(int i=0;i<=1000;i++) C[i][0]=1;
	for(int i=0;i<=1000;i++) for(int j=1;j<=i;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;
	cin>>n>>m>>c; for(int i=1;i<=c;i++)cin>>a[i];
	dp[0][0][0]=1;
	for(int i=1;i<=c;i++){
		memset(pre,0,sizeof(pre));
		for(int j1=0;j1<=n;j1++) 
        		for(int k1=0;k1<=m;k1++) 
                		for(int j2=0;j2<=j1;j2++) 
                        		for(int k2=0;k2<=k1;k2++) 
                                		if(((j2+k2)%2)==((j1+k1)%2)) 
                                        		pre[j1][k1]=(pre[j1][k1]+((C[j1][j2]*C[k1][k2]%mod)*C[j2*k2][a[i]]%mod))%mod; 
                                                else 
                                                	pre[j1][k1]=(pre[j1][k1]+mod-((C[j1][j2]*C[k1][k2]%mod)*C[j2*k2][a[i]]%mod))%mod;
		for(int j1=0;j1<=n;j1++) 
        		for(int k1=0;k1<=m;k1++) 
                		for(int j2=0;j2<=n;j2++) 
                        		for(int k2=0;k2<=m;k2++) 
                        				dp[i][j1+j2][k1+k2]=(dp[i][j1+j2][k1+k2]+(dp[i-1][j1][k1]*((C[n-j1][j2]*C[m-k1][k2]%mod)*pre[j2][k2]%mod)%mod))%mod;
	}
	int tot=0;
	for(int j=0;j<=n;j++) for(int k=0;k<=m;k++) tot=(tot+dp[c][j][k])%mod;
	cout<<tot;
}
```

---

## 作者：楠枫 (赞：0)

## 题解
本题是一个 $DP$ 加 容斥，容斥的式子很好推，重点是如何想到和如何推出 $DP$ 部分的式子。

因为不同种颜色的棋子不能放在同一行或同一列，所以不同种的棋子是相对独立的。

据此，我们可以推出一个式子，设 $f_{i,j,k}$ 表示前 $k$ 种颜色占据了 $i$ 行 $j$ 列。
$$
f_{i,j,k}=\sum_{l=0}^{i-1}\sum_{r=0}^{j-1}f_{l,r,k-1}×g_{i-l,j-r,num_k}×(^{n-l}_{i-l})×(^{m-r}_{j-r})
$$
其中 $g_{i,j,k}$ 表示 $k$ 个棋子占据 $i$ 行 $j$ 列，$num_k$ 表示第 $k$ 种颜色棋子的个数，后面的表示组合数。

来解释一下这个式子，其中因为 $k-1$ 已经占据了 $l$ 行 $r$ 列，那么第 $k$ 种颜色的棋子要占据 $i-l$ 行 $j-r$ 列。

所以这 $num_k$ 颗棋子只能放在这 $i-l$ 行 $j-r$ 行的交汇处，所以由此我们可以得出 $g$ 的式子

显然直接推不好推，所以我们要用容斥。易得 $g_{i,j,k}$ 初始状态设为 $(^{i×j}_{num_k})$ ，但其中有一些情况无法占据所有的行列，所以
$$
g_{i,j,k}=g_{i,j,k}-\sum_{l=1}^{i}\sum_{r=1}^{j} g_{l,r,k}×(^{i}_{l})×(^{j}_{r})[(l\le i)||(r\le j)]
$$

最后，所有的行列不一定占据，但所有种类的棋子一定要放上，所以答案即为
$$
\sum_{i=1}^{n}\sum_{j=1}^{m}f_{i,j,c}
$$
$AC \kern 0.4emCODE:$
```cpp
#include<bits/stdc++.h>
#define ri register int
#define p(i) ++i
using namespace std;
namespace IO{
    char buf[1<<21],*p1=buf,*p2=buf;
    inline char gc() {return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
    inline int read() {
        ri x=0,f=1;char ch=gc();
        while(ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=gc();}
        while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+(ch^48);ch=gc();}
        return x*f;
    }
}
using IO::read;
namespace nanfeng{
    #define ll long long
    static const int N=33;
    static const int MOD=1e9+9;
    static const int CN=12;
    int C[N*N][N*N],g[N][N],f[N][N][CN],n,m,c;
    inline int main() {
        n=read(),m=read(),c=read();
        const int S=n*m;
        C[0][0]=f[0][0][0]=1;
        for (ri i(1);i<=S;p(i)) {
            C[i][0]=1;
            for (ri j(1);j<=i;p(j)) C[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;
        } 
        for (ri k(1);k<=c;p(k)) {
            ri num=read();
            memset(g,0,sizeof(g));
            for (ri i(1);i<=n;p(i)) {
                for (ri j(1);j<=m;p(j)) {
                    if (i*j<num) continue;//要加上优化，显然
                    g[i][j]=C[i*j][num];
                    for (ri l(1);l<=i;p(l)) {
                        for (ri r(1);r<=j;p(r)) {
                            if (l==i&&r==j) continue;
                            g[i][j]=((ll)g[i][j]-(ll)g[l][r]*C[i][l]%MOD*C[j][r]%MOD+MOD)%MOD;
                            // printf("g[%d][%d]=%d\n",i,j,g[i][j]);
                        }
                    }
                }
            }
            for (ri i(1);i<=n;p(i)) {
                for (ri j(1);j<=m;p(j)) {
                    for (ri l(0);l<i;p(l)) {
                        for (ri r(0);r<j;p(r)) {
                            if ((i-l)*(j-r)<num) break;
                            f[i][j][k]=((ll)f[i][j][k]+(ll)f[l][r][k-1]*g[i-l][j-r]%MOD*C[n-l][i-l]%MOD*C[m-r][j-r]%MOD)%MOD;
                        }
                    }
                }
            }
        }
        int ans=0;
        for (ri i(1);i<=n;p(i)) {
            for (ri j(1);j<=m;p(j)) ans=(ans+f[i][j][c])%MOD;
        }
        printf("%d\n",ans);
        return 0;
    }
}
int main() {return nanfeng::main();}
```
时间复杂度 $O(n^2m^2c)$

---

## 作者：Φρανκ (赞：0)

题意：在 $m\times n$ 的棋盘中放置 $c$ 种每种 $t_i$ 枚棋子，满足每行每列至多只有一种棋子。求放法数。

核心思想：递推

解：

不妨设 $f(i,j,k)$ 为用前 $i$ 种棋子“充满”（是每行每列均有棋子）$j\times k$ 大小的棋盘的方法数。设 $g(i,j,k)$ 表示用 $i$ 个同种棋子“充满”$j\times k$ 大小的棋盘的方法数，则有 $f(i,j,k)=\Sigma_{p=1}^j\Sigma_{q=1}^k C_{m-j+p}^pC_{n-k+q}^qf(i-1,j-p,k-q)g(t_i,p,q)$（最后一种棋子充满 $p$ 行 $q$ 列，注意这些行列可以任意选择）。

考虑 $g$，我起初采用了 $g(i,j,k)=C_{jk}^i-jC_{(j-1)k}^i-kC_{j(k-1)}^i+jkC_{(j-1)(k-1)}^i$ 的求法，但只获 $60$ 分。读者可以自行思考这种求法为什么错误。

复杂度高得多的正确的做法是从总做法 $C_{jk}^i$ 中除去所有充满行列数较少的做法，即 $C_{jk}^i=\Sigma_{p=1}^j\Sigma_{q=1}^kC_j^pC_k^qg(i,p,q)$。该函数可通过此式预处理。

可以先预处理出阶乘与阶乘逆元以预处理可能用到的组合数，再预处理出  $g$。其后便可求得 $f$。答案为 $\Sigma_{i=1}^m\Sigma_{j=1}^nf(c,i,j)$。

代码：
```
#include <bits/stdc++.h>
using namespace std;
const long long mod=1000000009;
long long n, m, c, t[11], a[11][31][31], b[901][31][31], fac[901], inv[901], com[901][901], res;
int main()
{
	cin>>n>>m>>c;
	for(int i=1; i<=c; i++)
		cin>>t[i];
	fac[0]=1;
	inv[0]=1;
	inv[1]=1;
	for(int i=1; i<=900; i++)
		fac[i]=i*fac[i-1]%mod;
	for(int i=2; i<=900; i++)
		inv[i]=(mod-mod/i)*inv[mod%i]%mod;
	for(int i=2; i<=900; i++)
		inv[i]=inv[i]*inv[i-1]%mod;
	for(int i=1; i<=900; i++)
		for(int j=1; j<=900; j++)
			if(i<=j)
				com[i][j]=fac[j]*inv[i]%mod*inv[j-i]%mod;//预处理组合数
	for(int i=1; i<=900; i++)
		for(int j=1; j<=30; j++)
			for(int k=1; k<=30; k++)
				if(j*k>=i)
				{
					b[i][j][k]=com[i][j*k];
					for(int p=1; p<=j; p++)
						for(int q=1; q<=k; q++)
							if(p!=j || q!=k)
								b[i][j][k]=(b[i][j][k]-com[p][j]*com[q][k]%mod*b[i][p][q]%mod+mod)%mod;
				}//预处理g
	a[0][0][0]=1;
	for(int i=1; i<=c; i++)
		for(int j=1; j<=m; j++)
			for(int k=1; k<=n; k++)
				for(int p=1; p<=j; p++)
					for(int q=1; q<=k; q++)
						if(t[i]<=p*q)
							a[i][j][k]=(a[i][j][k]+a[i-1][j-p][k-q]*com[p][m-j+p]%mod*com[q][n-k+q]%mod*b[t[i]][p][q])%mod;//求f
	for(int i=1; i<=m; i++)
		for(int j=1; j<=n; j++)
			res=(res+a[c][i][j])%mod;//求和
	cout<<res;
	return 0;
}
```

---

## 作者：lgswdn_SA (赞：0)

$n\times m$ 的棋盘，有 $c$ 种不同颜色的棋子，每种颜色的棋子有 $a_i$ 个。棋子不能叠放，且每行每列的所有棋子颜色必须相同。问方案数。

考虑 DP。$f(i,j,k)$ 表示对于前 $i$ 种颜色的棋子，放了 $j\times k$ 大小的的棋盘格。转移觉得要枚举第 $i$ 类棋子占了多少格子，设其占了 $x$ 行 $y$ 列。贡献很难算。所以我们要求 $g(i,j,k)$ 表示 $i$ 枚同色棋子占了 $j$ 行 $k$ 列（也可以理解成 $j\times k$ 的棋盘格）。我们按行考虑。我们转移时枚举第 $j+1$ 行放置了多少枚棋子，且有多少枚棋子原本就在 $j\times k$ 的格子中。我们设前者为 $x$，后者为 $y$，则有

$$
g(i+x,j+1,k+x-y) \leftarrow \binom{k}{y} \binom{k+x-y}{k} g(i,j,k)
$$

于是我们 $f$ 就有转移

$$
f(i+1,j+x,k+y) \leftarrow \binom{j+x}{x} \binom{k+y}{y} f(i,j,k) g(a_{i+1},x,y)
$$

最后我们就可以计算答案

$$
ans=\sum_j \sum_k \binom{n}{j} \binom{m}{k} f_{c,j,k}
$$

```cpp
#include<bits/stdc++.h>
#define int long long
#define rep(i,a,b) for(register int i=(a);i<=(b);i++)
#define per(i,a,b) for(register int i=(a);i>=(b);i--)
using namespace std;
const int N=69,mod=1e9+9;

inline int read() {
    register int x=0, f=1; register char c=getchar();
    while(c<'0'||c>'9') {if(c=='-') f=-1; c=getchar();}
    while(c>='0'&&c<='9') {x=(x<<3)+(x<<1)+c-48,c=getchar();}
    return x*f;
}

int fac[N], inv[N], ifac[N];
void pre(int mn=30) {
    inv[0]=inv[1]=fac[0]=ifac[0]=1;
    for(int i=1;i<=mn;i++) fac[i]=fac[i-1]*i%mod;
    for(int i=2;i<=mn;i++) inv[i]=inv[mod%i]*(mod-mod/i)%mod;
    for(int i=1;i<=mn;i++) ifac[i]=ifac[i-1]*inv[i]%mod;
}
int C(int x,int y) {
    if(x<0||y<0||x<y) return 0;
    else return fac[x]*ifac[y]%mod*ifac[x-y]%mod;
}
void add(int &x,int y) {(x+=y)%=mod;}

int n,m,c,a[N],g[909][N][N],f[N][N][N];

signed main() {
	n=read(), m=read(), c=read();
	int mx=0;
	rep(i,1,c) a[i]=read(), mx=max(mx,a[i]);
	pre();
	g[0][0][0]=1;
	rep(i,0,mx) rep(j,0,n-1) rep(k,0,m) if(g[i][j][k]) {
		rep(x,1,m) rep(y,0,min(x,k)) {
			if(k+x-y>m) continue;
			add(g[i+x][j+1][k+x-y],C(k,y)*C(k+x-y,k)%mod*g[i][j][k]%mod);
		}
	}
	f[0][0][0]=1;
	rep(i,0,c-1) rep(j,0,n) rep(k,0,m) if(f[i][j][k]) {
		rep(x,1,n-j) rep(y,1,m-k) {
			add(f[i+1][j+x][k+y],C(j+x,x)*C(k+y,y)%mod*f[i][j][k]%mod*g[a[i+1]][x][y]%mod);
		}
	}
	int ans=0;
	rep(j,1,n) rep(k,1,m) add(ans,C(n,j)*C(m,k)%mod*f[c][j][k]%mod);
	printf("%lld\n",ans);
	return 0;
}
```

死因：转移方程推错调了1h，**模数写错写成 $10^9+7$ 调了1h**，所以请各位选手注意不要再写错模数了（（

---


# [HAOI2015] 数字串拆分

## 题目描述

你有一个长度为 $n$ 的数字串 $s_0$。

定义 $f(s)$ 为将 $s$ 拆分成若干个 $1 \sim m$ 的数的和的方案数，比如 $m=2$ 时，$f(4)=5$，分别为 $4=1+1+1+1=1+1+2=1+2+1=2+1+1=2+2$。

定义 $g(s)$ 为将 $s$ 这个数字串分割成若干个数字（允许前导 $0$），设他们的和为 $x$，则 $g(s)$ 为所有情况下 $f(x)$ 之和。比如 $g(123)=f(1+2+3)+f(1+23)+f(12+3)+f(123)$。

给定 $s_0$ 和 $m$，求 $g(s)$。

答案对 $998,244,353$ 取模。

## 说明/提示

#### 数据规模与约定

- 对于 $100\%$ 的数据，保证 $1\le|s_0|\le 500$， $1\le m\le 5$，$s_0$ 中只有数字字符。

## 样例 #1

### 输入

```
123
3```

### 输出

```
394608467```

# 题解

## 作者：Alex_Wei (赞：10)

> [P3176 [HAOI2015]数字串拆分](https://www.luogu.com.cn/problem/P3176)

> 题意简述：定义 $f(s)$ 为将 $s$ 拆分成若干个不大于 $m$ 个数的方案数。给出**数字**字符串 $t$，求 $g(t)=\sum f(x)$，其中 $x$ 为将 $t$ 分割成若干个数后它们的和。例如 $t=\texttt{12}$ 时，答案为 $f(1+2)+f(12)$。

> 本文节选自 [DP 大锅乱炖 IV.](https://www.cnblogs.com/alex-wei/p/DP_Involution.html)

---

注意到 $m$ 的范围很小，只有 $5$，所以 $f(s)$ 可以用矩阵快速幂 $m^3\log s$ 计算（基本操作）。记转移矩阵为 $G$，那么答案即为 $(\sum G^x)_{0,0}$。我们记 $d_i$ 为 $g'(t[1:i])=\sum G^x$（可以和上面 $g(s)$ 的柿子对比一下，$g$ 是数值，$g'$ 是矩阵），则答案为 $(d_n)_{0,0}$。

不难求出转移方程 $d_i=\sum_{j=0}^{i-1}d_j\times f(t[j+1:i])$。因为 $t[j+1:i]$ 会很大（达到 $10^n$），所以快速幂的时候需要对指数高精（**矩阵没有费马小定理！**）。因此，这样的时间复杂度为 $\mathcal{O}(n^3m^3)$，无法承受。

注意到 $f(t)=G^t=\prod_i G^{10^{|t|-i}t_i}$，那么我们可以预处理出形如 $G^{c\times 10^k}\ (1\leq c<10,1\leq k\leq n)$ 的矩阵。然后记 $D_{l,r}$ 为 $f(t[l:r])$，那么它可以由 $D_{l+1,r}\times G^{10^{r-l}t_{l}}$ 转移过来。$nm^3|\Sigma|+n^2m^3$ 预处理后可以 $n^2m^3$ DP（$d_i=\sum_{j=0}^{i-1} d_jD_{j+1,i}$）。可以通过本题。

```cpp
/*
	Powered by C++11.
	Author : Alex_Wei.
*/

#include <bits/stdc++.h>
using namespace std;

//#pragma GCC optimize(3)
//#define int long long

using ll = long long;
#define mem(x,v) memset(x,v,sizeof(x))

const int N=500+5;
const int M=5;
const int mod=998244353;

int n,m;
char s[N];
void add(int &x,ll y){
	x+=y%mod;
	if(x>mod)x-=mod;
}

struct mat{
	int a[M][M];
	friend mat operator * (mat x,mat y){
		mat z; mem(z.a,0);
		for(int i=0;i<m;i++)
			for(int j=0;j<m;j++)
				for(int k=0;k<m;k++)
					add(z.a[i][j],1ll*x.a[i][k]*y.a[k][j]);
		return z;
	}
	friend mat operator + (mat x,mat y){
		mat z; mem(z.a,0);
		for(int i=0;i<m;i++)
			for(int j=0;j<m;j++)
				add(z.a[i][j],x.a[i][j]+y.a[i][j]);
		return z;
	}
}base,f[N],c[N][N],d[N][10];

mat ksm(mat a,int b){
	mat x; mem(x.a,0);
	for(int i=0;i<m;i++)x.a[i][i]=1;
	while(b){
		if(b&1)x=x*a;
		a=a*a,b>>=1;
	} return x;
}

int main(){
	scanf("%s%d",s+1,&m),n=strlen(s+1),f[0].a[0][0]=1;
	for(int i=0;i<m;i++)base.a[i][0]=1;
	for(int i=1;i<m;i++)base.a[i-1][i]=1;
	for(int i=0;i<10;i++){
		d[0][i]=ksm(base,i);
		for(int j=1;j<=n;j++)d[j][i]=ksm(d[j-1][i],10);
	} for(int r=n;r;r--)
		for(int l=r;l;l--)
			if(l==r)c[l][r]=d[0][s[r]-'0'];
			else c[l][r]=c[l+1][r]*d[r-l][s[l]-'0'];
	for(int i=1;i<=n;i++)
		for(int j=0;j<i;j++)
			f[i]=f[i]+f[j]*c[j+1][i];
	cout<<f[n].a[0][0]<<endl;
	return 0;
}
```

---

## 作者：翼德天尊 (赞：7)

首先我们发现 $f$ 数组是可以通过 dp 求出的。

不妨将拆分看作是给 $n$ 个物品插板，两个木板之间的物品个数就是拆分出来的一个数。设 $f_i$ 为在第 $i$ 个物品后面插板之后所能得到的拆分数目，则显然，上一个木板可以放在往前的 $m$ 个空隙当中的任何一个。即有转移方程：
$$
f_i=\sum_{j=\max(0,i-m)}^{i-1}f_j
$$
开始时将 $f_0$ 的初值设为 $1$ 即可，表示开头一定会放上一块木板。

而观察到 $m$ 很小，转移阶段又很大（$10^{500}$ 过于魔鬼），所以可以考虑矩阵加速优化转移。

但是显然还不够，因为 $10^{500}$ 次方显然过于庞大了，甚至还需要用到高精，且 $g$ 的拆分数目足足可以达到 $2^{|s|}$ 种，这是不好的。考虑到 $g$ 数组的拆分方式十分奇怪，思考一下题目中是否有什么厉害的性质可以让我们优化。 

注意我们转移时用的是矩阵，而矩阵所满足的一个性质是：
$$
A^{n+m}=A^m\times A^n
$$
正确性是很显然的。所以例如 $g(123)$，我们就可以将它拆解为：
$$
f(1+2+3)+f(12+3)+f(1+23)+f(123)=f(1+2)\times f(3)+f(12)\times f(3)+f(1)\times f(23)+f(123)
$$
考虑递推求解 $g$，设 $g'_i$  表示 $s$ 前 $i$ 位数字组成的数字串的答案（我们最终要求出 $g'_n$），则显然当我们算到 $g(123)$ 时，$g(1)$ 和 $g(12)$ 都已经算过了。于是可以将上面的式子进一步化简为：
$$
(f(1+2)+f(12))\times f(3)+f(1)\times f(23)+f(123)=f(123)+g'_1\times f(23)+g'_2\times f(3)
$$
所以扩展地来看，只要我们知道每一个后缀数字串的 $f$ 值，就可以转移 $g'$，得到 $g$ 的答案了！

而为了避免高精，设 $f'_{i,j}$ 表示 $s$ 第 $i$ 位数字到第 $j$ 位数字组成的 $f$ 的转移矩阵，则通过 $f'_{i,j}=f(s_i)^{10^{n-i}}\times f'_{i+1,j}=f(10^{n-i})^{s_i}\times f'_{i+1,j}$ 即可推出 $f_{i,j}'$，所以预处理出所有 $f(10^i)$ 即可。其中 $s_i$ 表示代表 $s$ 中第 $i$ 个数字的矩阵。

最后输出 $g'_n$  即可。

```cpp
#include <bits/stdc++.h> 
using namespace std;
typedef long long ll;
const int N=505;
const int M=5;
const int mod=998244353;
int m,n;
char in[N];
struct node{
	ll a[M][M];
	node(){
		memset(a,0,sizeof(a));
	}
	void init(){
		for (int i=0;i<m;i++) a[i][m-1]=1;
		for (int i=1;i<m;i++) a[i][i-1]=1;
	}
	void init1(){
		for (int i=0;i<m;i++) a[i][i]=1;
	}
}P[N],F[N][N],g[N];
node operator *(const node&x,const node&y){
	node z;
	for (int k=0;k<m;k++)
		for (int i=0;i<m;i++)
			for (int j=0;j<m;j++)
				z.a[i][j]=(z.a[i][j]+x.a[i][k]*y.a[k][j]%mod)%mod;
	return z;
}
node operator +(const node&x,const node&y){
	node z;
	for (int i=0;i<m;i++)
		for (int j=0;j<m;j++)
			z.a[i][j]=(x.a[i][j]+y.a[i][j])%mod;
	return z;
}
ll read(){
	ll w=0,f=1;
	char c=getchar();
	while (c>'9'||c<'0'){
		if (c=='-') f=-1;
		c=getchar();
	}
	while (c>='0'&&c<='9'){
		w=(w<<3)+(w<<1)+(c^48);
		c=getchar();
	}
	return w*f;
}
node ksm(node S,ll y){
	node P1;
	P1.init1();
	while (y){
		if (y&1) P1=P1*S;
		S=S*S;
		y>>=1;
	}
	return P1;
}
int main(){
	scanf("%s",in+1);
	n=strlen(in+1),m=read();
	P[0].init();
	for (int i=1;i<n;i++) P[i]=ksm(P[i-1],10);
	for (int j=1;j<=n;j++){
		for (int i=j;i>=1;i--){
			if (i!=j) F[i][j]=F[i+1][j]*ksm(P[j-i],in[i]-'0');	
			else F[i][j]=ksm(P[0],in[i]-'0');
		}		
	}
	g[0].init1();
	for (int i=1;i<=n;i++){
		for (int j=0;j<i;j++){
			g[i]=g[i]+(g[j]*F[j+1][i]);
		}
	}
	ll ans=0;
	for (int i=0;i<m;i++) ans=(ans+g[n].a[0][i])%mod;
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：Garbage_fish (赞：1)

由于 $f(s)$ 的拆分方式不关心顺序，故有 $f(i)=\sum_{j\in [i-m,i)} f(j)$（$f(0)=1$），可理解为在 $f(j)$ 的拆分基础上，添加一个大小为 $(i-j)$ 的数。

那么构造矩阵 $F_i=\begin{bmatrix}f(i) & f(i-1) & f(i-2) & \cdots & f(i-m+1)\end{bmatrix}$，矩阵快速幂转移即可求出 $f(i)=F_i(1,1)$，假设转移矩阵为 $A$，那么有 $F_i=F_0\times A^{i}$。

由初中数学知识，$F_{x+y}+F_{z+w}=F_0\times(A^x\times A^y+A^z\times A^w)$，故 $g(s)$ 就相当于将字符串 $s$ 拆成若干段，每一段的转移矩阵相乘，不同拆法的转移矩阵相加。设 $G_i$ 表示 $s$ 前 $i$ 位的转移矩阵，则有转移 $G_i=\sum_{j\in [1,i]}G_{j-1}\times A^{s[j:i]}$。

但是 $|s|\le 500$，$A^{s[j:i]}$ 将会涉及指数高精。考虑递推求出所有的 $A^{s[j:i]}$，可以将 $s[j:i]$ 拆位，先求出每个数码的转移矩阵。设 $B_{i,j}=A^{i\times 10^j}$，递推可求。接着设 $C_{j,i}$ 表示 $s[j:i]$ 的转移矩阵，则有 $C_{j,i}=C_{j+1,i}\times B_{s_j,i-j}$。

最终答案即为 $(F_0\times G_{|s|})(1,1)$。

忽略矩阵乘法，求 $B$ 时间 $O(10\times |s|)$，求 $C$ 时间 $O(|s|^2)$，求 $G$ 时间 $O(|s|^2)$。瓶颈在求 $C,G$，时间复杂度为 $O(m^3|s|^2)$，可以通过。

核心代码：

```cpp
cin >> s >> m;
n = s.size(), s = " " + s;
matrix a(m, m, 0);
for (int i = 1; i <= m; i++) {
    a.d[i][1] = 1;
    if (i < m)
        a.d[i][i + 1] = 1;
}
matrix b[10][N];
for (int i = 0; i < 10; i++) {
    b[i][0] = pow_matrix(a, i);
    for (int j = 1; j <= n; j++)
        b[i][j] = pow_matrix(b[i][j - 1], 10);
}
matrix c[N][N];
for (int i = n; i; i--) {
    c[i][i] = b[s[i] - 48][0];
    for (int j = i - 1; j; j--)
        c[j][i] = c[j + 1][i] * b[s[j] - 48][i - j];
}
matrix g[N];
g[0] = matrix(m, m, 0);
g[0].d[1][1] = 1; // 直接令 G0 = F0
for (int i = 1; i <= n; i++) {
    g[i] = matrix(m, m, 0);
    for (int j = 1; j <= i; j++)
        g[i] = g[i] + g[j - 1] * c[j][i];
}
cout << g[n].d[1][1];
```

---

## 作者：toolazy (赞：1)

### 关于暴力...

数据范围看似很小，但是暴力也是不好过的。

计算一次 $f(x)$，使用矩阵快速幂，就是 $h(x)=m^3\log_2 x$，不计其常数，暴力计算每一个区间，也就是：

$$\text{final overhead}=\sum_{i=1}^n(n-i+1)\cdot h(10^i)$$

$h(10^i)=m^3\log_210^i=i\cdot m^3\log_210$，将 $\log_210$ 作为常数剥离出来，最终的算法复杂度在 $O(n^3m^3),n=|s_0|$ 并带有 $\displaystyle\frac16$ 的常数。

此处估作 $\log_210\approx3$，则最终是 $\displaystyle\frac12$ 的常数，带入题目数据范围：

$$\frac12\times5^3\times500^3=5^5\times10^5\approx3\times10^8$$

即使是锣鼓机子，一秒钟也不好说，加上矩阵快速幂、大量取模的常数应该就更不好说了吧...

---

### 转变思路...

$f$ 直接用矩阵快速幂是毋庸置疑：

$$
\textbf{P}=\overbrace{\begin{bmatrix}
0&\cdots&1
\end{bmatrix}}^{m}
$$

其中 $\textbf P_{1,m}$ 表示 $f_0$，即初始状态。

$$
\textbf{T}=\begin{bmatrix}
0&0&0&\cdots&1\\
1&0&0&\cdots&1\\
0&1&0&\cdots&1\\
\vdots&\vdots&\vdots&\ddots&\vdots\\
0&0&0&\cdots&1
\end{bmatrix}
$$

主对角线下面的斜线都是 $1$，最后一列也是 $1$，这就是递推矩阵。

那么，我们用一个 $f'(x)=\textbf{P}\cdot\textbf{T}^x$ 来表示矩阵快速幂最后所得结果，那么 $f(x)$ 即为 $[f'(x)]_{1,m}$。

再考虑函数 $g'(x)$ 表示『$s_0$ 的前缀 $[1,x]$ 的所有 $f'(x)$ 的总和矩阵』，也就是原来的 $g$：*（不引起歧义时，可能将『数字串切片』与『数字串切片代表的数字』混用）*

$$
g(s)=\sum_{p\text{ 为 }s\text{ 的一个拆分}}f\bigg(\sum_{b\in p}b\bigg)
$$

和新的 $g'$：

$$
g'(x)=\sum_{p\text{ 为 }s_0[1,x]\text{ 的一个拆分}}f'\bigg(\sum_{b\in p}b\bigg)
$$

$g(s_0)$ 即为 $[g'(n)]_{1,m}$。

---

### 化解式子...

到现在为止只是换皮操作，接下来要深入剖析内核，推导式子，以方便计算。

我们不难发现一个东西：

$$
f'(a)\cdot\textbf{T}^b=f'(a+b)
$$

哈？这不是显而易见吗？

少等片刻，你便会知道，我们把一切转化成矩阵的优越性。

再来看看 $g'$，我们来枚举最后一段的长度 $z$ 进行转移：

$$
g'(x)=\sum_{z=1}^xg'(x-z)\cdot\textbf T^{s_0[x-z+1,x]}
$$

欸？为什么可以这么写？

你会发现：

$$
\sum_{p\text{ 为 }s_0[1,x-z]\text{ 的一个拆分}}\bigg[f'\bigg(\sum_{b\in p}b\bigg)\cdot\textbf T^{s_0[x-z+1,x]}\bigg]=\sum_{p\text{ 为 }s_0[1,x-z]\text{ 的一个拆分}}f'\bigg(s_0[x-z+1,x]+\sum_{b\in p}b\bigg)
$$

现在，你应该就反应过来矩阵乘法的优越性了——它帮助我们拆分了最后一段，这依靠了『指数的加法』与『幂的乘法』的对应。

而如果不转化成矩阵，拆解的这一步是无法进行的（我们没有很好的办法把 $f(a+b)$ 括号内部的某个元拎出来呢）。

---

### 最终算法！

现在，我们只要递推就好了，可是不用矩阵快速幂的人要想的可就多了。

提前计算出来所有的 $\textbf T^{s_0[l,r]}$：

$$
\textbf T^{s_0[l,r]}=\bigg(\textbf T^{s_0[l,r-1]}\bigg)^{10}\cdot\textbf T^{s_0[r]}
$$

一次递推是 $O(m^3)$ 的（当然，用快速幂也仍有 $\displaystyle\frac 12\cdot\log_210$ 的常数，但是在现在的时间复杂度已经无所谓了），所以这里的预处理时间复杂度也是 $O(n^2m^3)$ 的。

再直接套上 $g'$ 的递推公式，就能在优秀的 $O(n^2m^3)$ 时间复杂度内解决该问题。

> tips：别忘记 $g'(0)=\textbf P$ 哦。

---

## 作者：木xx木大 (赞：1)

[P3176 [HAOI2015]数字串拆分](https://www.luogu.com.cn/problem/P3176)


这道题巧妙地运用了矩乘的性质。

首先， $f$ 比较好算。$f_i=\sum_{j=1}^{m} f_{i-j}$。$m$ 很小，直接矩乘优化即可。

但 $g$ 的定义十分诡异。我们重新定义 $g_i$ 表示字符串以第$i$ 位结尾之前所有种类转移矩阵之和。以样例为例，$g_1=A,g_2=A\times(A^2)\times(A^{12})$

设上面求 $f$ 的转移矩阵为 $A$，$D_{i,j}$ 表示原数字串中 $[i,j]$ 的转移矩阵之积。因为矩乘有分配律，且 $A^{x+y}=A_x\times A_y$，那么有 $g_i=\sum_{j=0}^{i-1} g_j\times D_{j+1,i}$。以样例为例，再具体解释一下:

$g_1=A^1=D_{1,1}$ 。即原式 $g_1=f_1$

$g_2=(A^1\times A^2)+(A^{12})=g_1\times D_{2,2}+D_{1,2}$。即原式 $g_2=f_{1+2}+f_{12}$

$g_3=(A^1\times A^2\times A^3)+(A^1\times A^{23})+(A^{12}\times A^3)+A^{123}=g_1\times D_{2,3}+g_2\times D_{3,3}+D_{1,3}$。即原式$g_3=f_{1+2+3}+f_{1+23}+f_{12+3}+f_{123}$

然后直接按上面的式子写就行了。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
namespace FGF
{
	int n,m;
	const int mo=998244353;
	struct matrx{
		ll a[5][5];
	}mi[15],D[510][510],g[510]; 
	char ch[510];
	matrx operator *(matrx const &x,matrx const &y)
	{
		matrx s;memset(s.a,0,sizeof(s.a));
		for(int i=0;i<m;i++)
			for(int j=0;j<m;j++)
				for(int k=0;k<m;k++)
					s.a[i][j]=(s.a[i][j]+x.a[i][k]*y.a[k][j]%mo)%mo;
		return s;
	}
	matrx operator +(matrx x,matrx y)
	{
		for(int i=0;i<m;i++)
			for(int j=0;j<m;j++)
				x.a[i][j]=(x.a[i][j]+y.a[i][j])%mo;
		return x;
	}
	matrx qpow(matrx x)//x的10次方
	{
		x=x*x;
		matrx s=x;
		x=x*x;x=x*x;x=x*s;
		return x;
	}
	void work()
	{
		scanf("%s%d",ch+1,&m);
		n=strlen(ch+1);
		for(int i=1;i<m;i++)mi[1].a[i][i-1]=1;
		for(int i=0;i<m;i++)mi[1].a[i][m-1]=g[0].a[i][i]=mi[0].a[i][i]=1;
		for(int i=2;i<=10;i++)mi[i]=mi[i-1]*mi[1];//处理出转移矩阵的1~10次方
		for(int i=1;i<=n;i++)
		{
			D[i][i]=mi[ch[i]-'0'];
			for(int j=i+1;j<=n;j++)
				D[i][j]=qpow(D[i][j-1])*mi[ch[j]-'0'];
		}
		for(int i=1;i<=n;i++)
			for(int j=i-1;j>=0;j--)
				g[i]=g[i]+g[j]*D[j+1][i];
		ll ans=0;
		for(int i=0;i<m;i++)ans=(ans+g[n].a[0][i])%mo;
		printf("%lld",ans);
	}
}
int main()
{
	FGF::work();
	return 0;
}
```

---

## 作者：Jerrywang09 (赞：0)

加深了我对矩阵快速幂加速 DP 的理解。按步推进，不是很难想。

首先列出 $f(i)$ 的状态转移方程：
$$
f(i)=\sum_{j=1}^m f(i-j)
$$
因为 $m$ 很小，因此上式很容易使用矩阵快速幂优化。设这个矩阵为 $F$，初始向量为 $V$。则 $f(i)$ 可以表示成 $V F^i$。

由上可得 $f(i+j)$ 可以表示成 $V F^{i+j}=V F^i F^j$。

考虑如何统计答案。看到题目中的“数字分段”，容易想到一个朴素的 DP：设 $G(i)$ 表示考虑了数字串的 $1\sim i$ 个字符，所有 $f$ 的矩阵表示之和。因为矩阵乘法具有分配律，因此，和的积就是积的和，符合题中所求。

转移前预处理数字串 $[l,r]$ 区间的 $f$ 的矩阵表示 $F(l,r)$。

$F(l,r)$ 的转移：已知 $F(l,r-1)$ 形如 $F^x$，则 $F(l,r)$ 形如 $F^{10x+y}=(F^{x})^{10}F^y$。

下面的转移很经典：
$$
G(i)=\sum_{j=1}^i G(j-1)F(j,i)
$$

最终的答案，只需求得 $V G(n)$ 即可。

```cpp
// P3176 [HAOI2015] 数字串拆分
#include <cstdio>
#include <iostream>
#include <cstring>
#define ll long long
#define rep(i, s, t) for(int i=s; i<=t; ++i)
#define debug(x) cerr<<#x<<":"<<x<<endl;
const int N=505, mod=998244353;
using namespace std;

char s[N]; int n, m;
struct mat
{
    ll a[6][6];
    mat() {rep(i, 1, m) rep(j, 1, m) a[i][j]=0;}
    void E() {rep(i, 1, m) a[i][i]=1;}
    ll *operator [](int i) {return a[i];}
} a, ori, pw[10], f[N][N], g[N];
mat operator *(mat a, mat b)
{
    mat c;
    rep(i, 1, m) rep(j, 1, m) rep(k, 1, m)
        c[i][j]=(c[i][j]+a[i][k]*b[k][j]%mod)%mod;
    return c;
}
mat operator +(mat a, mat b)
{
    rep(i, 1, m) rep(j, 1, m) a[i][j]=(a[i][j]+b[i][j])%mod;
    return a;
}
mat qp(mat a, ll k)
{
    mat res; res.E();
    for(; k; k>>=1, a=a*a) if(k&1) res=res*a;
    return res;
}

int main()
{
#ifdef Jerrywang
    freopen("in.txt", "r", stdin);
#endif
    scanf("%s%d", s+1, &m); n=strlen(s+1);
    rep(i, 1, m)
    {
        if(i<m) a[i+1][i]=1;
        a[i][m]=1;
    }
    pw[0].E();
    rep(i, 1, 9) pw[i]=pw[i-1]*a;
    rep(l, 1, n)
    {
        f[l][l]=pw[s[l]-'0'];
        rep(r, l+1, n)
        {
            f[l][r]=qp(f[l][r-1], 10)*pw[s[r]-'0'];
        }
    }
    g[0].E();
    rep(i, 1, n)
    {
        rep(j, 1, i)
        {
            g[i]=g[i]+g[j-1]*f[j][i];
        }
    }
    mat ori; ori[1][m]=1;
    ori=ori*g[n];
    printf("%lld", ori[1][m]);

    return 0;
}
```

---

## 作者：phil071128 (赞：0)

## P3176 [HAOI2015] 数字串拆分

> 给定一个大数 $s\le 10^{500}$，定义：
>
> - $f(s)$ 为将 $s$ 拆为 若干个不超过 $m$ 的数的和的方案数。
> - $g(s)$ 为将 $s$ 在十进制下按位拆分（忽略前导0），所得的 $f$ 之和，例如：$g(123)=f(123)+f(12+3)+f(1+23)+f(1+2+3)$。
>
> 给定 $m\le 5$，求 $g(s)$。

矩阵dp大多数时候就搞个矩阵转移完事了，这道题带来了更深刻的认识。

因为 $m\le 5$，所以我们可以在 $O(m^3\log s)$ 的时间复杂度计算，套路的：
$$
\begin{bmatrix}
f_{i-5} & f_{i-4} &f_{i-3}  &f_{i-2}  &f_{i-1}
\end{bmatrix}
\times 
\begin{bmatrix}
 0 & 0 & 0 & 0 & 1\\
 1 & 0 & 0 &0  &1 \\
 0 & 1 & 0 & 0 & 1\\
 0 & 0 & 1 & 0 & 1\\
 0 & 0 & 0 & 1 &1
\end{bmatrix}
=
\begin{bmatrix}
f_{i-4} &f_{i-3}  &f_{i-2}  &f_{i-1} &f_i 
\end{bmatrix}
$$
设转移矩阵为 $A$，因为有边界 $f_0=1$，所以答案 $f(x)=[5][5]A^x$。

$g$ 肯定不能直接做，观察样例解释，发现有子问题结构：考虑 DP，设 $h_i$ 前 $\sum f(s_{[1\cdots i]})=\sum A^{s_{[1\cdots i]}}$ 前 $i$ 位的和，那么就有暴力转移：
$$
h_i=\sum_{j=0}^{i-1} h(j)\times f(s_{[j+1\cdots i]})
$$
这是因为 $f(a+b)=A^{a+b}=A^aA^b$，化加为乘，很好地将贡献独立开。矩阵是满足分配率的。

复杂度为 $O(n^2 m^3 \log S)$，但是因为 $S$ 过大，实际处理的时候是在十进制下逐位考虑（类似于高精度），预处理 $A^{1},A^2,\cdots A^{10}$，复杂度相当于 $O(n^3m^3)$，无法通过。

这题关键的地方在于：注意到 $j$ 每向右扩展一位，对于 $f$ 的影响，相当于指数从 $a\times10^{k}+b\to b$，即去掉最高位，矩阵求逆等操作太麻烦，我们不妨 $j$ 从大到小向左扩展。那么就很显然了：指数仅仅相当于 $b\to a\times 10^k+b$， 指数相加即为矩阵相乘，所以我们预处理出 $A^{1\times10^k},A^{2\times10^k},\cdots A^{9\times10^k}$ 即可，注意允许前导 0，所以单位矩阵 $A^0$ 不可忽略。复杂度 $O(n^2m^3)$。

这里想了一下 $A^{10a+b}=A^{10a}\times A^b$ 为啥一定会满足交换律，这实际是可交换矩阵的一个充分条件，想了解充要条件可以自行百科。

多提一嘴，状态设计的微小区别，或者说转移顺序实际上很重要，如果照 $j$ 向右扩展的思路做，或许会麻烦很多，但是只要将转移顺序换一下就很舒服，从状态设计的角度看：如果状态设计为后 $i$ 位，那么向右扩展也是简单的，而向左扩展是困难的。两对看似完全等价的设计/枚举顺序，四种组合中有两种是好做的。这让笔者不禁联想到 noip2023 T4，如果状态设计和（暴力的）转移顺序都不妥，则还需要记录一个“前缀平移量”，非常麻烦。

```
#include <bits/stdc++.h>
#define int long long
#define pii pair<int,int>
#define fi first
#define se second
using namespace std;
int read(){
	char c=getchar();int h=0,tag=1;
	while(!isdigit(c)) tag=(c=='-'?-1:1),c=getchar();
	while(isdigit(c)) h=(h<<1)+(h<<3)+(c^48),c=getchar();
	return h*tag;
}
void fil(){
	freopen("data.in","r",stdin);
	freopen("data.out","w",stdout);
}
int n,m;
const int mod=998244353;const int N=555;
struct Mat{
	int a[6][6];
	Mat() {
		memset(a,0,sizeof a);
	}
	void init() {
		for(int i=0;i<m;i++) a[i][i]=1;
	}
	int * operator [] (int x) {
		return a[x];
	}
	Mat operator * (Mat b) const{
		Mat c;
		for(int k=0;k<m;k++) {
			for(int i=0;i<m;i++) {
				for(int j=0;j<m;j++) {
					c.a[i][j]=(c.a[i][j]+a[i][k]*b.a[k][j]%mod)%mod;
				}
			}
		}
		return c;
	}
	Mat operator + (Mat b) const{
		Mat c;
		for(int i=0;i<m;i++) {
			for(int j=0;j<m;j++) c.a[i][j]=(a[i][j]+b.a[i][j])%mod;
		}
		return c;
	}
}trans,mi[201],mi2[N],mi3[N][11];
Mat h[N];
char s[N];
Mat ksm(Mat a,int b) {
	if(b==1) return a;
	Mat s=ksm(a,b/2);s=s*s;
	if(b%2==1) s=s*a;
	return s;
}
signed main(){
//	fil();
	scanf("%s",s+1);
	n=strlen(s+1);
	m=read();
	for(int i=0;i<m-1;i++) {
		trans[i+1][i]=1;
	}
	for(int i=0;i<m;i++) trans[i][m-1]=1;
	mi[0].init();mi2[0].init();
	for(int i=1;i<=200;i++) mi[i]=mi[i-1]*trans;
	mi2[0]=trans;
	for(int i=1;i<=500;i++) mi2[i]=ksm(mi2[i-1],10);
	for(int i=1;i<=500;i++) {
		mi3[i][0].init();
		for(int j=1;j<10;j++) 
			mi3[i][j]=mi3[i][j-1]*mi2[i];
	}
	h[0].init();
	for(int i=1;i<=n;i++) {
		Mat f;	
		f=mi[s[i]-'0'];int x=s[i]-'0';
		for(int j=i-1;j>=0;j--) {
			h[i]=(h[i]+h[j]*f);
			if(j>0)f=f*mi3[i-j][s[j]-'0'];
		}
	}
	cout<<h[n][m-1][m-1]<<endl;
	return 0;
}
```

---

## 作者：_ZSR_ (赞：0)

### [P3176 [HAOI2015] 数字串拆分](https://www.luogu.com.cn/problem/P3176)

$f$ 很好求，$f_{i}=\sum_{j=1}^{m} f_{i-j}$。观察到 $m$ 很小，大概率是要用到矩阵优化，这也很简单，跟斐波那契数列的矩阵加速是一样的，无非就是从两个的和变成了最多五个的和。重点考虑 $g$ 怎么求。

先想这样一个问题：如果没有这个 $f$，我们要求一个大数把它按位分成若干个数后的所有情况的和怎么求。很简单，令 $dp_{i}$ 表示考虑划分这个数的从高到低的前 $i$ 位的所有情况的和。转移就是 $dp_{i}=\sum_{j=1}^{i-1} dp_{j}+num_{j+1 \sim i}$。求 $num$ 很简单，只要每次加上最高位就可以了，但是我们怎么求 $f$ 呢？令 $f$ 的转移矩阵为 $fac$，那么有 $f(A+B)=fac^{A+B}$，根据矩阵的结合率，$fac^{A+B}=fac^A \times fac^B$，所以 $f(A+B)=f(A) \times f(B)$。那么这样我们就可以求了，只要每次不断乘上最高位的 $f$。但是 $s$ 最多有 $500$ 位，直接每次算快速幂肯定不行，并且我们只会用到 $10$ 的倍数次幂，因此我们要预处理 $fac$ 的 $10$ 的倍数次方。

这样的话就可以通过这道题了。

code
```
#include <bits/stdc++.h>
using namespace std;
const int N=510,mod=998244353;
int n,m;
char str[N];
struct Matrix{
    int c[6][6];
    Matrix() {memset(c,0,sizeof c);}
    Matrix operator* (const Matrix &t) const
    {
        Matrix res;
        for (int i=1;i<=m;++i)
        {
            for (int k=1;k<=m;++k)
            {
                int tmp=c[i][k];
                for (int j=1;j<=m;++j)
                {
                    res.c[i][j]=(res.c[i][j]+1ll*tmp*t.c[k][j]%mod)%mod;
                }
            }
        }
        return res;
    }
    Matrix operator+ (const Matrix &t) const
    {
        Matrix res;
        for (int i=1;i<=m;++i)
        {
            for (int j=1;j<=m;++j)
            {
                res.c[i][j]=(c[i][j]+t.c[i][j])%mod;
            }
        }
        return res;
    }
}fac[N],dp[N];
inline Matrix ksm(Matrix a,int b)
{
    Matrix res;
    for (int i=1;i<=m;++i) res.c[i][i]=1;
    while (b)
    {
        if (b&1) res=res*a;
        a=a*a;
        b>>=1;
    }
    return res;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin>>str+1>>m;
    n=strlen(str+1);
    for (int i=1;i<=m;++i) fac[0].c[i][1]=1;
    for (int i=2;i<=m;++i) fac[0].c[i-1][i]=1;
    for (int i=1;i<=n;++i) fac[i]=ksm(fac[i-1],10);
    for (int i=1;i<=n;++i)
    {
        Matrix cur=ksm(fac[0],str[i]-'0');
        for (int j=i-1;j;--j)
        {
            dp[i]=dp[i]+dp[j]*cur;
            cur=cur*ksm(fac[i-j],str[j]-'0');
        }
        dp[i]=dp[i]+cur;
    }
    cout<<dp[n].c[1][1]<<endl;
    return 0;
}
```


---

## 作者：Forg1weN (赞：0)

## 题面

你有一个长度为 $n$ 的数字串 $s_0$。

定义 $f(s)$ 为将 $s$ 拆分成若干个 $1 \sim m$ 的数的和的方案数。

定义 $g(s)$ 为将 $s$ 这个数字串分割成若干个数字（允许前导 $0$），设他们的和为 $x$，则 $g(s)$ 为所有情况下 $f(x)$ 之和。

给定 $s_0$ 和 $m$，求 $g(s)$，取模 $998244353$。

保证 $1\le|s_0|\le 500$， $1\le m\le 5$。

## Solution

考虑如何求出 $f(s)$，可得显然转移 $f(s)=\sum\limits_{j=1}^mf(s-j)$。

用矩阵优化这个转移，但显然还不够。

定义 $F(i)$ 表示 $f(i)$ 转移次数。

定义 $G(i)$ 表示 $s$ 这个数字从左往右数第 $i$ 位为止构成的字符串的**转移次数和**。下面以样例举例。

$G_0=I$。

$G_1=F(1)$。

$G_2=(G_{1})^{10}\times F(2)$。

$G_3=(G_{1})^{100}\times F(23)+(G_{1})^{10}\times F(3)+F(123)$。

由于矩阵的结合律，$(AB)C=A(BC)$，所以要求出 $G(i)$，可得 $G(i)=\sum\limits_{j=0}^{i-1}G(j)^{10^{j-i}}\times F(x)$。

那么提前处理出 $F(10^i)$ 就可以快速处理上述转移。

值得注意的是，由于转移矩阵如下：

$$[f_{i-1},f_{i-2},f_{i-3},f_{i-4},f_{i-5}]\times \begin{bmatrix}
 1 & 1 & 0 & 0 & 0\\
 1 & 0 & 1 & 0 & 0\\
 1 & 0 & 0 & 1 & 0\\
 1 & 0 & 0 & 0 & 1\\
 1 & 0 & 0 & 0 & 0
\end{bmatrix}^x$$

其初值为 $[f_0=1,0,0,0,0]$，所以转移的次数 $F(x)$ 就是和答案直接挂钩的，**很多题解没有将清楚，为什么要将最后的答案矩阵行求和**，我觉得是很多人都没有理解而直接抄了题解，由于初值是 $1$，而我们要求的 $g_n$ 就是答案矩阵的系数乘上原矩阵，所以就是答案矩阵的系数，如上这个转移直接输出转移矩阵 $G_n$ 的 $a_{5,1}$ 就是所求的答案。根本不需要求和。

## code

参考了很多家的代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int mod=998244353;
LL n,m,sum;
char c[505];
struct mat {
	LL a[6][6];
	mat() {
		memset(a,0,sizeof(a));
	}
	void init() {
		for(int i=1;i<=m;i++)a[i][i]=1;
	}
}now,ans,T[505],pt,F[505][505],g[505];
void prework() {
	for(int i=1;i<=m;i++)now.a[i][1]=1;
	for(int i=1;i< m;i++)now.a[i][i+1]=1;
}
mat mul(mat a,mat b) {
	mat res;
	for(int i=1;i<=m;i++)
		for(int j=1;j<=m;j++)
			for(int k=1;k<=m;k++)
				(res.a[i][j]+=a.a[i][k]*b.a[k][j]%mod)%=mod;
	return res;
}
mat add(mat a,mat b) {
	for(int i=1;i<=m;i++)
		for(int j=1;j<=m;j++)
			(a.a[i][j]+=b.a[i][j])%=mod;
	return a;
}
mat Pow(mat a,LL x) {
	mat res;res.init();
	while(x) {
		if(x&1)res=mul(res,a);
		a=mul(a,a);
		x>>=1;
	}return res;
}
mat Pow_10(mat a) {
	mat res;
	a=mul(a,a);
	res=a;
	a=mul(a,a);a=mul(a,a);
	return mul(a,res);
}
int main() {
	scanf("%s",c+1);
	n=strlen(c+1),scanf("%d",&m);
	prework();
	T[0].init();
	T[1]=now;
	for(int i=2;i<=10;i++)T[i]=mul(T[i-1],now);
	for(int i=1;i<=n;i++) {
		F[i][i]=T[c[i]-'0'];
		for(int j=i+1;j<=n;j++) 
			F[i][j]=mul(T[c[j]-'0'],Pow(F[i][j-1],10));
	}
	g[0].init();
	for(int i=1;i<=n;i++)
		for(int j=0;j<i;j++)
			g[i]=add(g[i],mul(g[j],F[j+1][i]));
	printf("%lld",g[n].a[1][1]);
	return 0;
} 
```


---

## 作者：Crane_w (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P3176)

- 矩阵优化dp

$m$ 很小，我们可以写出转移矩阵， 那么 $f(x)=G^x$

$\to f(x+y)=G^x\cdot G^y=f(x)\cdot f(y)$

$G'(i)=$ 数字串钦定最后一个数字落在 $i$ 上的方案（矩阵表达）

$G'(i)=\sum_jG'(j)f(s[j+1,i])$

这样做，由于 $f(s[j+1,i])$ 达到了 $10^n$ 方级别，由于矩阵的幂不能用欧拉定理降次，指数得高精度，复杂度还会炸。

考虑优化，设 $d(i,j)=f(s[j+1,i])$

那么有 $d(i,j)=\prod_kf(10^{j-k}s_k)$

我们预处理出 $f(10^kc)$， 然后就有 $d(i,j)=d(i+1,j)\cdot f(10^{j-i}s_i)$，这样可以$O(n^2m^3)$ 的预处理出 $d$。

然后，我们就可以计算 $G'$了，复杂度 $O(n^2m^3)$。

代码：
```cpp
//main
	clr(bs.a);
	rep_(i,0,m-1)bs.a[i][0]=1;
	rep_(i,0,m-1)bs.a[i][i+1]=1; 
	
	
	rep_(i,0,9){
		d[i][0]=Gt(bs,i);
		rep_(j,1,n) {
			d[i][j]=Gt(d[i][j-1],10);	
		}
	}
	
	
	per_(i,n,1){
		rep_(j,i,n) {
			if(i==j)D[i][j]=d[s[i]-'0'][0];
			else{
				D[i][j]=D[i+1][j]*d[s[i]-'0'][j-i];
			}
		}
	}
	
	
	g[0].init();
	rep_(i,1,n){
		rep_(j,0,i-1){
			g[i]=g[i]+(g[j]*D[j+1][i]);
		}
	}
	
	
	cout<<g[n].a[0][0]<<endl;
```


---

## 作者：zyxawa (赞：0)

## 「HAOI2015」数字串拆分

定义 $f_s$ 将 $s$ 拆分成 $1 \sim m$ 的数的和的方案数，$g_s$ 将 $s$ 这个数字串分割成若干个数字（允许前导 $0$），设它们的和为 $x$，那么 $g_s=\sum f_x$，输入 $s$ 与 $m$，求 $g_s$。

---

我们可以发现 $f_i$ 是非常好求的，$f_i=\sum_{j=1}^m f_{i-j}$，模拟一下可以发现这样是对的，那么转移矩阵也很简单了，下面以 $m=5$ 作一个例子。

$$
\begin{pmatrix} 
dp_i & dp_{i-1} & dp_{i-2} & dp_{i-3} & dp_{i-4}
\end{pmatrix}
\times
\begin{pmatrix}  
1 & 1 & 0 & 0 & 0\\ 
1 & 0 & 1 & 0 & 0\\
1 & 0 & 0 & 1 & 0\\
1 & 0 & 0 & 0 & 1\\
1 & 0 & 0 & 0 & 0
\end{pmatrix}
=
\begin{pmatrix} 
dp_{i+1} & dp_i & dp_{i-1} & dp_{i-2} & dp_{i-3}
\end{pmatrix}
$$

令 $s$ 在十进制下有 $n$ 位，由于 $n$ 太大，我们并不能暴力求出 $g_s$，记 $F$ 为以上的转移矩阵，那么可以先预处理出 $dp1_k={F^{10}}^{k-1}(1 \le k \le n)$。

因为 $f_1$ 始终为 $1$，所以很好得出 $F^k=f_k$。

那么令 $dp2_i$  为 $s$ 中 $1 \sim i$ 位构成的数的 $g$ 的矩阵，$dp3_{i,j}$ 为 $s$ 中 $i \sim j$ 位构成的数的 $f$ 的矩阵。

则 $dp2_i=dp3_1{1,i}+\sum_{j=1}^{i-1} dp2_j \times dp3_{j+1,i}$，$dp3_{i,j}=dp3_{i+1,j} \times {dp1_{j-i+1}}^{s_i}$（$s_i$ 为 $s$ 从高到低位的第 $i$ 位），当然 $dp3$ 其实可以省略，我们可以在枚举 $j$ 的时候直接求出来（具体看代码）。

对于 $dp2$ 的式子，我们用样例来证明一下，因为矩阵 $A^{x+y}=A^x \times A^y$ 并且拥有分配率的性质，那么可以得出下面式子：

$dp2_1=f_1=dp3_{1,1}$

$dp2_2=f_{1+2}+f_{12}=f_1 \times f_2+f_{12}=dp2_1 \times dp3_{2,2}+dp3_{1,2}$

$dp2_3=f_{1+2+3}+f_{1+23}+f_{12+3}+f_{123}=f_1 \times f_2 \times f_3+f_1 \times f_{23}+f_{12} \times f_3+f_{123}$

$dp2_3=f_{123}+(f_1 \times f_2+f_{12})\times f_3+f_1 \times f_{23}=dp3_{1,3}+dp2_2 \times dp3_{3,3}+dp2_1 \times dp3_{2,3}$

那么即使更长也是如此，证毕。

### 示例代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
char s[501];
struct matrix{
	int m[6][6];
	matrix(){
		memset(m,0,sizeof(m));
	}
	matrix operator*(const matrix &a){
		matrix b;
		for(int i=0;i<k;i++){
			for(int j=0;j<k;j++){
				for(int l=0;l<k;l++) b.m[i][j]=(b.m[i][j]+1ll*m[i][l]*a.m[l][j])%998244353;
			}
		}
		return b;
	}
	matrix operator+(const matrix &a){
		matrix b;
		for(int i=0;i<k;i++){
			for(int j=0;j<k;j++) b.m[i][j]=(m[i][j]+a.m[i][j])%998244353;
		}
		return b;
	}
}dp0,dp1[501],dp2[501];
matrix power(matrix ret,int b){
	matrix ans;
	for(int i=0;i<k;i++) ans.m[i][i]=1;
	for(int i=0;i<b;i++) ans=ans*ret;
	return ans;
}
int main(){
	scanf("%s%d",s+1,&k);
	n=strlen(s+1);
	for(int i=0;i<k;i++) dp1[1].m[i][0]=1;
	for(int i=1;i<k;i++) dp1[1].m[i-1][i]=1;
	for(int i=2;i<=n;i++) dp1[i]=power(dp1[i-1],10);
	for(int i=1;i<=n;i++){
		dp0=power(dp1[1],s[i]-'0');
		for(int j=i-1;j>=1;j--){
			dp2[i]=dp2[i]+dp2[j]*dp0;
			dp0=power(dp1[i-j+1],s[j]-'0')*dp0;
		}
		dp2[i]=dp2[i]+dp0;
	}
	printf("%lld",dp2[n].m[0][0]);
	return 0;
}
```

---

## 作者：SUNCHAOYI (赞：0)

先处理函数 $f_i$，有 $f_i = \sum \limits _{j =  i - m}^{i - 1} f_j$，这个递推式显然可以通过矩阵乘法进行优化。设 $F_i$ 表示通过递推函数 $f_i$ 得到的矩阵，则有以下矩阵的递推（以 $m = 5$ 为例）：

$$
F_i = 
\begin{bmatrix}
f_i\\
f_{i - 1}\\
f_{i - 2}\\
f_{i - 3}\\
f_{i -4}
\end {bmatrix}
= 
\begin{bmatrix}
1 & 1 & 1 & 1 & 1\\
1 & 0 & 0 & 0 & 0\\
0 & 1 & 0 & 0 & 0\\
0 & 0 & 1 & 0 & 0\\
0 & 0 & 0 & 1 & 0
\end {bmatrix}^k
\cdot 
\begin{bmatrix}
f_{i - 1}\\
f_{i - 2}\\
f_{i - 3}\\
f_{i - 4}\\
f_{i - 5}
\end{bmatrix}
$$

$g_i$ 的计算不太好处理，等价转换以下令 $G_i$ 表示处理前 $i$ 位得到的所有情况的矩阵之和，因此最后的答案就会在 $G_n$ 中。由矩阵的乘法分配律可知 $A^{x + y} = A^x \times A^y$，因此可以将 $G_i$ 进行转移。设 $A_{i,j}$ 表示数字串中 $[i,j]$ 的转移矩阵之积，则 $G_i = \sum \limits _{j = 0}^{i - 1} G_j \times A_{j + 1,i}$。

现在的复杂度为计算矩阵 $A_{i,j}$，不难发现 $A_{i,j} = F_{s_i^{10^{n - i}}} \times A_{i + 1,j}$，稍作变换得 $A_{i,j} = F_{({10^{n - i}})^{s_i}} \times A_{i + 1,j}$。这样只需要预处理出 $F_{10^i}$ 的矩阵即可。

两个小细节：

- 在写矩阵时用到了 `+` 与 `*` 的重载，这时候原来的优先级已经不复存在，因此需要通过括号来处理顺序。

- 矩阵的初始化要小心，需要避免未定义行为。

代码如下：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#define ll long long
#define ull unsigned long long
#define INF 0x3f3f3f3f
using namespace std;
const int MAX = 505;
const int MOD = 998244353;
int m,n;ll ans;
char s[MAX]; 
struct Mat
{
	ll a[6][6];
	Mat() {memset(a,0,sizeof(a));}//全部 memset 肯定没问题
	Mat operator * (const Mat &y)
	{
		Mat z;
		for (int k = 1;k <= m;++k)
			for (int i = 1;i <= m;++i)	
				for (int j = 1;j <= m;++j)
					z.a[i][j] += a[i][k] * y.a[k][j] % MOD,z.a[i][j] %= MOD;
		return z;
	}
	Mat operator + (const Mat &y)
	{
		Mat z; 
		for (int i = 1;i <= m;++i)
			for (int j = 1;j <= m;++j) z.a[i][j] = a[i][j] + y.a[i][j],z.a[i][j] %= MOD;
		return z;
	}
	Mat qpow (Mat x,ll y)
	{
		Mat res;
		for (int i = 1;i <= m;++i) res.a[i][i] = 1;
		while (y)
		{
			if (y & 1) res = res * x;
			x = x * x;
			y >>= 1;
		}
		return res;
	}
} p[MAX],f[MAX][MAX],g[MAX];
int main ()
{
	//freopen (".in","r",stdin);
	//freopen (".out","w",stdout);
	scanf ("%s%d",s + 1,&m);
	n = strlen (s + 1);
	for (int i = 1;i <= m;++i) p[0].a[1][i] = 1;
	for (int i = 2;i <= m;++i) p[0].a[i][i - 1] = 1;
	for (int i = 1;i <= n;++i) p[i] = p[i].qpow (p[i - 1],10);//预处理 10^i 的矩阵 
	for (int j = 1;j <= n;++j)//扩展 需要注意一下 i = j 的特殊情况
		for (int i = j;i;--i)//f[i][j] = f[i + 1][j] * f(10^(j - i))^(s_i)
			f[i][j] = (i == j) ? f[i][j].qpow (p[0],s[i] - '0') : f[i + 1][j] * f[i][j].qpow (p[j - i],s[i] - '0');
	for (int i = 1;i <= m;++i) g[0].a[i][i] = 1;
	for (int i = 1;i <= n;++i)//g[i] 表示前 i 位的所有情况的答案 
		for (int j = 0;j < i;++j) g[i] = g[i] + (g[j] * f[j + 1][i]);//注意优先级
	printf ("%lld\n",g[n].a[1][1]);//最后的答案显然是左上角的那个值
	return 0;
}
```

---

## 作者：wgyhm (赞：0)

# [HAOI2015]数字串拆分

## Description

题目说的很清楚了。

## Solution

令 $f_1=1$ ，易得 $f_i=\sum\limits_{j=\max(i-m,1)}^{i-1} f_j$ 。

设 $g_i$ 表示 $g(s[1...i])$ 。很难转移。

注意到 $f_i$ 可以表示成矩阵 $A^i$。所以 $f(x+y)=A^x\cdot A^y=A^{x+y}$。

因为**矩阵有分配律**，所以设 $g_i$ 表示所有分割情况的矩阵加和。样例中：

$$g_2=g(s[1..2])=f(1+2)+f(12)=A^3+A^{12}$$

则有 $g_i=\sum\limits_{j=1}^{i-1} g_j\cdot A^{s[i..j]}$。 其中 $s[i...j]$ 表示 $j$ 到 $i$ 所表示的数。例如样例中 $s[2...3]=12$。

$j$ 从大到小枚举即可。**矩阵没有费马小定理**。

## Code

```cpp
#include<bits/stdc++.h>
#define rg register
#define int long long 
#define maxn 505
#define put() putchar('\n')
using namespace std;
const int mod=998244353;
int n,m;
struct yyy{
	int a[5][5];
	yyy (void) {memset(a,0,sizeof(a));}
	inline void clear(void){rg int i;for (i=0;i<m;i++) a[i][i]=1;}
	yyy operator *(const  yyy &x) const{
	    rg int i,j,k;
	    yyy ans;
	    for (k=0;k<m;k++)
	        for (i=0;i<m;i++)
	            for (j=0;j<m;j++)
	                ans.a[i][j]=(ans.a[i][j]+a[i][k]*x.a[k][j])%mod;
	    return ans;
	}
	yyy operator +(const yyy &x) const{
	    rg int i,j;
	    yyy ans;
	    for (i=0;i<m;i++) 
	        for (j=0;j<m;j++) 
	            ans.a[i][j]=(a[i][j]+x.a[i][j])%mod;
	    return ans;
	}
}tmp,g[maxn],f[maxn];
inline yyy pow(yyy A,int x){
	yyy ans;ans.clear();
	while (x){
		if (x&1) ans=ans*A;
		A=A*A;x>>=1;
	}
    return ans;
}
string s;
int a[maxn];
signed main(){
    rg int i,j,k;
    cin>>s;n=s.size();
    for (i=1;i<=n;i++) a[i]=s[i-1]-'0';
    cin>>m;
    for (i=0;i<m;i++) tmp.a[0][i]=1;
    for (i=1;i<m;i++) tmp.a[i][i-1]=1;
    g[1]=tmp;
    for (i=2;i<=n;i++) g[i]=pow(g[i-1],10);
    f[0].clear();
    for (i=1;i<=n;i++){
    	yyy A=pow(g[1],a[i]);
    	for (j=i-1;j>=0;j--){
    		f[i]=f[i]+f[j]*A;
    		A=A*pow(g[i-j+1],a[j]);
		}
	}
    printf("%lld",f[n].a[0][0]);
	return 0;
}
```





---


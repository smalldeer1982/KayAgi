# [HNOI2007] 梦幻岛宝珠

## 题目描述

给你 $n$ 颗宝石，每颗宝石都有重量和价值。要你从这些宝石中选取一些宝石，保证总重量不超过 $W$，且总价值最大，并输出最大的总价值。


## 说明/提示

### 数据范围及约定

对于 $100\%$ 的数据，$1\le n \le 100$，$1\le W,w_i,v_i \le 2^{30}$。  
保证每个 $w_i$ 能写成 $a \times 2^b\space (a,b \in \mathbb N)$ 的形式，$a \leq 10$ , $b \leq 30$，且答案不超过 $2^{30}$。


## 样例 #1

### 输入

```
4 10
8 9
5 8
4 6
2 5
4 13
8 9
5 8
4 6
2 5
16 75594681
393216 5533
2 77
32768 467
29360128 407840
112 68
24576 372
768 60
33554432 466099
16384 318
33554432 466090
2048 111
24576 350
9216 216
12582912 174768
16384 295
1024 76
-1 -1```

### 输出

```
14
19
1050650```

# 题解

## 作者：Zwaire (赞：48)

# P3188 梦幻岛宝珠
## [Link](https://www.luogu.com.cn/problem/P3188)

## 总体评价：

其实是一个非常好的（~~板子题~~），主要考察对于 01 背包的理解和对于二进制的应用以及状压 DP 的理解，综合性非常强，**值得一做**。

## 题目大意：

就是裸的 01 背包，但是它的体积和价值都很大，而且每一个 $w[i]$ 都保证能写成 $a * 2^b (a,b \in N)$ 的形式,并且 $ a \leq10, b \leq 30$。

## 题目分析：

这不是板子题吗？？？然后敲了一个板子上去（~~内心充满期待~~），然而，紫题怎么会这么容易啊喂，结果 TLE 和 RE 击碎了我（~~水~~）好好打题的欲望。

当然，每一个题都有一个突破点，而这个题的突破点就是数据范围，看到 $w$ 的数据范围的时候，其实我内心是有一丝窃喜的，因为这个题不会像之前一样没有思路了。

当然，这个 $a * 2^b$ 其实并没有什么大的用处，因为把一个数转换成二进制之后，它一定可以表示成这样的形式。所以我们接着分析题目，$a \leq 10$ 才是最重要的条件，我们看到这么小的数据，在结合一点二进制的知识，我们可以想到就是 **提示你要拆位，并且按照b来分组**，$ a $ 就是相当于是体积了。（**重点**）

我们已经有了这么一个性质，接着我们就可以设状态了，（~~显然~~）我们对于每一位进行考虑，设  $ g[i][j]$ 为在 $ b = i$ 的这一组中所选取体积为 $j$ 的最大值，根据 01 背包的dp转移，我们可以得到：
$$
g[i][p] = \max(g[i][p], g[i][p - k[i][j]] + val[i][j])
$$
简单解释一下我 ~~奇怪~~ 的变量名：

$\bullet$ 其中 $g$ 数组是上面我所说的。

$\bullet$ $i$ 是我所枚举的 $b$。（即二进制下拆位的哪一位）

$\bullet$ $p$ 是我所枚举的在 $i$ 这一位的体积。

$\bullet$ $k$ 是我所预处理后的各个宝珠，$val$ 同理。

这时候我们很高兴，可以把这题切了！！

但是，我们好像忘了什么条件，我们的 $W$ 好像并不满足那个（可爱）的性质。。。（~~陷入沉思~~）

思考问题在哪里，目前我们已经得到了在每一位二进制上的答案，但是需要把 $W$ 用二进制的形式统计答案。但是假设 $W$ 在第 $i$ 位为1，答案并不是单纯的由 $i$ 位决定，因为可以分解在 $(i-1)$ 位，并且体积为2。所以就不能单纯的依靠每一位进行转移，所以需要另一个数组辅助我们。

可以把 $W$ 分解为最高位以及低位两个部分进行考虑转移。因为最高位的体积为1。
设 $f[i][j]$ 为**在 $0 \thicksim  i$  组一共选取了 $j * 2^i$ 的上界并且转移 $W$ 在 $0 \thicksim {i-1}$ 位拥有的贡献的最大价值**。这样的话 $f[s][1]$ 表示取到 $2^s$ 并且已经处理了前 $s-1$ 位的贡献的最大价值，把两部分的贡献合起来了。还是根据最后想要的答案设置dp状态。

然后我们开始思考怎么转移，我们从 $i - 1$ 状态转移到 $i$ 的状态的时候，枚举 $p$ 为当前 $i$ 这一组选取的体积，我们在 $i$ 的时候表示 $j - p$ 的体积的话，根据二进制下的表示，其实相当于在 $i - 1$ 的这一位选取 $(j - p) * 2$ 的体积，当然，我们转移的时候，根据 $f$ 数组的含义，还需要考虑对于 $W_{i-1}$ 的贡献进行考虑。这样就可以将第 $i-1$ 位的贡献，转移到 $i$ 位。解决了之前不能单独从某一位考虑的问题。

于是乎，我们就可以得出一个十分可爱（~~难看~~）的 dp 转移的式子：
$$
f[i][j] = \max(f[i][j], f[i - 1][(j - p) * 2 + W_{i-1})] + g[i][p])
$$
$\bullet$ 其中 $i$，$j$ 是我所枚举的组数和总的体积。

$\bullet$ $p$ 是我当前的组数内所需要的体积，$(j - p) * 2$ 是上一位的状态对这一位造成的影响。

$\bullet$ $W_{i-1}$ 是我对应的上一位的 $W$ 所对应的体积，即二进制下第 $i - 1$ 位，$g[i][p]$ 就是我这一位选 $p$ 的价值了。

呼~，我们终于做完了，答案当然就是 $f[s][1]$ 了，$s$ 是 $W$ 所对应的二进制最高位数，表示取 $2^s$ 的上界体积并且转移了 $W$ 在前 $s-1$ 的贡献的最大价值。

**说一下这个题的一些坑**

我做这个题的时候真的是很困难，（~~因为我很菜~~），其中有非常多的细节需要处理。

$\bullet$ 需要开 **long long**。 

$\bullet$ 一个数组大小的关键点，后面的体积是由 $max\{a_i\} * n$ 来确定的。所以取到上界为1000，~~之前的 500 没出问题可能是没有这种数据吧~~ 。

$\bullet$ 注意这道题的$f,g$两个数组都是大的容量向小容量取的 $\max$ 而不是正好是当前的体积，和背包的思想类似

细节标注在代码里，所以考虑问题考虑全面，以防出现我这发现不了的错误。

```c++
/*
所以，走过的坑大家不要再犯
*/
#include<bits/stdc++.h>
#define il inline
#define int long long //不开ll见祖宗 

using namespace std;
const int N = 1e6 + 10;

vector<int> val[N], k[N];

il int re()
{
	int x = 0, p = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') {if(ch == '-') p = -1; ch = getchar();}
	while(ch <= '9' && ch >= '0') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
	return x * p;
}

int n, W, s;
int f[50][5000], g[50][5000];//注意这里不要开太小！！！ 

void init()//多组数据 
{
	s = 0;
	memset(f, 0, sizeof(f));
	memset(g, 0, sizeof(g));
	for(int i = 0; i <= 50; ++i) val[i].clear(), k[i].clear();
}

signed main()
{
	while(1)
	{
		n = re(), W = re();
		if(n == -1) break;
		init();
		for(int i = 1; i <= n; ++i)//读入
		{
			int x = re(), y = re(), t = 0;
			while(((x >> t) & 1) == 0) t++;//记录每一个物品的二进制的表示 
			val[t].push_back(y);
			k[t].push_back((x >> t));
		}
		while((W >> s)) s++;//总的体积的位数 
        s--; //转换成了实际上位移的位数，更加符合含义，上面的s统计的是w一共几位
		for(int i = 0; i <= s; ++i)
		{
			if(k[i].size() == 0) continue;
			for(int j = 0; j <= k[i].size() - 1; ++j)
				for(int p = 1000; p >= k[i][j]; --p)//此处的上界是由max(a)*n确定的，故取上界1000
					g[i][p] = max(g[i][p], g[i][p - k[i][j]] + val[i][j]);//g数组更新答案 
		}	
		for(int i = 0; i <= s; ++i)
			for(int j = 1000; j >= 0; --j)
				for(int p = 0; p <= j; ++p) {
                    if(i == 0) f[i][j] = max(f[i][j], g[i][p]);
                    else f[i][j] = max(f[i][j], f[i - 1][(j - p) * 2 + ((W >> (i - 1)) & 1)] + g[i][p]);
                }
		printf("%lld\n", f[s][1]);
	}
    getchar(); getchar();
}
/*
1 10
8 9
-1 -1
*/
```

完结撒花✿✿ヽ(°▽°)ノ✿



---

**Update 2025.1.18**

时隔好多年来补坑，之前因为AFO一直没有管博客的问题，现在看到了觉得还是填一下BUG比较好，防止误导更多的人（~~话说我怎么成第一篇题解了~~）。修改了 $f$ 数组的含义，以及数组的上界等问题，也对于含义进行了更加详细的阐述。 感谢大佬们的指正，QWQ。感谢在讨论区和评论区指正的各位！~~

---

## 作者：Bartholomew (赞：27)


**其实,这道题目,评价:**

1.难度: @@@@@

2.思维难度: @@@

3.细节难度: @@@@@

对于这道题目,我们发现其实就**是普通的 01 背包**,但是**数据** 十分的大!

那么我们可以对于 $v$ $=$ $a$×$2^{b}$;的 b 相同的物品做一次 dp

那么就是$f[i][j]$ **表示体积为 ($j$×$2^{i}$) 的体积** **只收纳 $k$×$2^{i}$ 的物品的最大值**

那么最后就是 怎么合并是关键部分!

如果我们假设 $f[i][j]$ 现在表示

表示$2^{0}$ ~ $2^{i}$组内， 容量为 $j$×$2^{i}$+($w$&($($$1$<< $i$)$-1$)) 时的最大价值

也就是f[i,j]表示体积为$j$× $2^{i}$再加上W**二进制第i位以下的体积**最多可以获得多少价值

那么 我们的 答案其实就是 dp[len][1] , len指的是 最大的$ i$ 是 $2^{i}$ 小于等于 m 的值!

那么 我们就是考虑转移 从 $f[i-1][...]$ 开始转移!

转移方程:

$f[i,j]$=$max$($f[i,j],f[i,j-k]$+$f[i-1]$,$min(k*2+e[i-1],d[i-1])]$);

其中好多是**小细节部分**:

```cpp
for(int j=w[i];j>=0;--j) 
for(int k=0;k<=j;k++)   // 这下面的f[i][j-k] (用"*"标注的)1其实并没有变动,因为是反着来求的,所以还是表示 单单是 2^i 的物品,大家可以写一下式子,就明白了!     
      f[i][j] = getmax(f[i][j] , **f[i][j-k]** + f[i-1][min(w[i-1],(k<<1)|(m>>(i-1)&1))]);
```

贴上代码 , 有明显的小错误的哦!

```cpp
#include <bits/stdc++.h>
#define N 200005
#define INF 0x3f3f3f3f
using namespace std;
int n,m,len,x,y,f[35][1150],w[35];
inline int read()
{
    int x=0;
    char c=getchar();
    while(c<'0'||c>'9'){c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}
    return x;
}
vector<int> G[35],V[35];
inline int getmax(int x,int y){return (x>y)?x:y; }
inline void init()
{
    len = 0;
    memset(G,0,sizeof G);
    memset(V,0,sizeof V);
    memset(w,0,sizeof w);
    memset(f,0,sizeof f);
}
int main(int argc,char const* argv[])
{
    while(~scanf("%d%d",&n,&m) && n!=-1)
    {
        init();
        for(int i=1;i<=n;++i)
        {
            x = read(); int j = 0;
            while(!(x&1)) { x>>=1; j++; }
            G[j].push_back(x); w[j] += x;
            len = getmax( len , j);
            scanf("%d",&y); V[j].push_back(y);
        }
        for(int i=0;i<=len;i++)
            for(int j=0;j<(int)G[i].size();++j)
                for(int k=w[i];k>=G[i][j];k--)
                    f[i][k] = getmax(f[i][k],f[i][k-G[i][j]]+V[i][j]);
        while(m>>len) len++; len--;
        for(int i=1;i<=len;i++)            
        {
            w[i] += (w[i-1]+1)/2;
            for(int j=w[i];j>=0;--j) 
                for(int k=0;k<=j;k++)         
                    f[i][j] = getmax(f[i][j] , f[i][j-k] + f[i-1][min(w[i-1],(k<<1)|(m>>(i-1)&1))]);
        }
        printf("%d\n",f[len][1]); 
    }
    return main();
}
```





---

## 作者：静静是他的， (赞：25)

- 题意: 一个最大重量为$2^{30}$的 01背包，物品重量可以分解为$a*2^{b}$。

- 显然，暴力 01背包 是不可行的，只有10分。

- 就只能利用物品重量性质：
	1. 设 $f_{i,j}$ 为 选了$j*2^i$ 重量的最大价值，
    实际上 $2^i$ 以下的重量被忽略了。
	2. 考虑转移，同为 $2^i$ 重量的物品间可以相互转移:
   当前是第$x$个数：
   $$f_{i,j} = \max \{f_{i,j-w_x} + val_x\}$$
   	
   就是一般的01背包。
   
   3. 不同 $2^i$ 重量的物品的转移：
   
   考虑从 $2^{i-1}$ 和 $2^i$ 重量转移：
   
   $$f_{i,j} = \max\limits_{k=0}^{j} \{ f_{i-1,k\ast2 + [m \& (1 << b - 1)]} +f_{i,j-k}\}$$
    
   - $f_{i-1,k\ast2 + [m \& (1 << b - 1)]}$
   
   a. 从 $j$ 拿出 $k \ast 2^i$ 的重量个给 $2^{i-1}$ 的，
     
   即 $2\ast k \ast 2^{i-1}$ ，
   得到：
   $$f_{i-1, 2\ast k}$$
   
   b. 最大价值 $W$ 中，可能会多出一个 $2^{i-1}$ ，
   
   例如: $W = 2^{10} + 2^{9}$ ， 从 $2^9$ 转移到 $2^{10}$ 还能多选一个 $2^9$ 
   即 $[W \& 2^9] = 1 $
   
   也就是：
   	$$f_{i - 1, 2 \ast k + [m \& (1 << b - 1) ]}$$
  - $f_{i, j - k}$
  
  拿出 $k$ 后剩下 $j - k$ 。
  
 	4. 最后答案为 $f_{len,1}$ ， $2^{len}$ 是最大小于$W$ 的。
    
    $f_{len, 1}$ 在转移中也算入$2^{len}$以下重量的物品的价值。

时间复杂度 $O(T \ast len \ast 1000 \ast 1000)$ ， 常数略大。

加O2才过的垃圾代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 2010;

int n, m;
long long w;
long long ai[MAXN], bi[MAXN], val[MAXN], f[32][1010];

int main(){
	while(cin >> n >> w){
		if (n == -1 && w == -1) break;
		memset(f, 0, sizeof(f));
		for(int i = 1; i <= n; i++){
			long long c;
			cin >> c >> val[i];
			ai[i] = (c / (c & (-c)));
			bi[i] = 0;
			for(c = (c & (-c)) >> 1; c; c >>= 1) bi[i]++;
		}
		
		for(int i = 1; i <= n; i++)
			for(int a = 1000; a >= ai[i]; a--)
				f[bi[i]][a] = max(f[bi[i]][a], f[bi[i]][a - ai[i]] + val[i]);	
	 
		int len = 0;
		for(long long s = w>>1; s; s >>= 1) len++;
		
		long long  ans = 0;
		for(int b = 1; b <= len; b++){
			for(int a = 1000; a >= 0; a--)
				for(int k = 0; k <= a; k++){
					f[b][a] = max(f[b][a], f[b][a - k] + f[b - 1][min(1000, (k << 1) | ( (w & (1 << (b - 1))) != 0))]);
				}
		}
		
		cout << f[len][1] << endl;
		
	}
	

	return 0;
}
```

---

## 作者：蒟蒻君HJT (赞：13)

题目链接：https://www.luogu.com.cn/problem/P3188

 
 
解题思路：这道题是一个普通的 $0/1$ 背包模型，但是体积和价值都非常大，无法用常规方法处理，怎么办呢？

注意到数据范围保证了每个物品的体积都可以表示为 $w=a*2^b$ 的形式，且 $a$ 不大于 $10$ ，这提示我们可以先不要考虑进位问题，在每一位上运行 $0/1$ 背包模板，再对结果进行合并。（以下可表示为 $a*2^b$ 的物品简称为 $b$ 类物品）

具体来说，开一个数组 $g_{i,j}$ 表示对于第i类物品，给它 $j*2^i$ 的体积，这类物品中能选到的最大价值，这样的话类与类之间是完全没有关系的，在 $a$ 不大于 $10$ 的限制下，每一类物品的最大背包体积至多枚举到 $10*n$ 即可。有人可能会说，应该是 $10*cnt_i$ ，但我们为了合并起来方便，就直接做到 $10*n$ ，这样正确性是不会有问题的，而时限又宽松，我们肯定要选择保险，方便的dp方式。

接下来的难点就在于合并的问题。我觉得这道题能评紫色的原因就在这里，状态并不好想！在 $NOIP$ $2021$ 数列 的启发下（~~时间轴错乱~~），我们发现对于位权（即 $2^x$ 中的那个 $x$ ，或者就是某个物品的类）较大的物品来说，如果我们已经考虑好了位权小的物品的选取方式，那么这个较大的物品，不管是否选取，是不会影响到已选体积在较低位的数值的。于是，我们从小到大考虑，这样的话一般第一时间想到的思路是：设 $f_{i,j}$ 表示对于前 $i$ 类物品，给它们 $j*2^i$ 的体积，这些类物品中能选到的最大价值。看上去随便转移一下就做完了是不是？

你好，假了！原因在于，虽然物品的价值有 $a$ 不大于 $10$ 的保证，但是背包大小 $W$ 可没有！然后，你就会惊喜地发现，前功尽弃啦！只有暴力分！怎么解决？

一个关键的贪心思想就是：当可选物品集合一定时，背包体积变大一定不会使结果更劣。其实如果 $0/1$ 背包学的好的话，尽管没有直接体现，但在转移的过程中也隐含了这一思想（建议读到这里仔细想一想）。而我们之前的“如果我们已经考虑好了位权小的物品的选取方式，那么这个较大的物品，不管是否选取，是不会影响到已选体积在较低位的数值的”这个思路是完全正确的，更进一步地，既然较低位体积不再会受到以后的物品的选取的影响，那么我们为什么不能把这一部分体积开到最大呢？！这样的话，对于第 $i$ 位体积的考虑，即第 $i$ 类物品的选取，我们只需要记录它往前进位的贡献，而在它后面的那 $i-1$ 位，直接假定和 $W$ 的最后 $i-1$ 位相同就可以了。

设 $f_{i,j}$ 表示对于前 $i$ 类物品，给 它们 $j*2^i+(W\operatorname{and}((1<<j)-1))$  的体积，这些类物品中能选到的最大价值。初始化  $f_{0,0}=g_{0,0},f_{0,i}=max(f_{0,i-1},g_{0,i}),i \in N^*$ ；

对于任意正整数 $i$ 和非负整数 $j$ ，枚举不大于 $j$ 的非负整数 $k$ ，表示在第 $i$ 位体积上，往低位物品让了 $k*2^i$ 的体积。则有状态转移方程：
 $f_{i,j}=max(f_{i,j},f_{i-1,min(10*n,2*k+(W>>(i-1))\operatorname{and} 1)}+g_{i,j-k})$  

 $AC$ 代码如下所示：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,W,w[105],v[105];
long long g[55][1005],f[55][1005];
long long th[35][105],cnt[35];
long long dp[35][1005];
int main(){
	while(scanf("%lld%lld",&n,&W)!=EOF){
		if(n==-1&&W==-1) break;
		memset(cnt,0,sizeof cnt);
		memset(g,0,sizeof g),memset(f,0,sizeof f);
		for(long long i=1;i<=n;++i) scanf("%lld%lld",&w[i],&v[i]);
		for(long long i=1;i<=n;++i){
			long long nw=0;
			while((!(w[i]&1))&&nw<30) ++nw,w[i]>>=1;
			th[nw][++cnt[nw]]=i;
		}
		for(long long i=0;i<=31;++i){
			memset(dp,0,sizeof dp);
			for(long long j=1;j<=cnt[i];++j)
				for(long long k=1;k<=n*10;++k)
					if(k>=w[th[i][j]]) 
						dp[j][k]=max(dp[j-1][k],
						dp[j-1][k-w[th[i][j]]]+v[th[i][j]]);
					else dp[j][k]=dp[j-1][k];
			for(long long j=0;j<=n*10;++j)
				g[i][j]=dp[cnt[i]][j];
		}
		f[0][0]=g[0][0];
		for(long long j=1;j<=1000;++j) f[0][j]=max(f[0][j-1],g[0][j]);
		for(long long i=1;i<=31;++i)
			for(long long j=0;j<=10*n;++j)
				for(long long k=0;k<=j;++k)
					f[i][j]=max(f[i][j],g[i][j-k]+f[i-1][min(10*n,2*k+((W>>(i-1))&1))]);
		long long now=0;
		while((1<<now)<=W) ++now;--now;
		cout<<f[now][1]<<endl;
	} 
	return 0;
}
```

 

---

## 作者：nofind (赞：12)

## [题意](https://www.luogu.org/problem/P3188)

显然是不能直接0-1背包的，因为0-1背包是$O(NM)$的，$M$最大为$2^{30}$，显然会$T$掉。

题目中每个物品体积有特色性质，即$weight_i$能写成$a*2^b(1<=a<=10,0<=b<=30)$。

这启示我们将物品按照$b$分组,设$f_{i,j}$表示物品代价为$a*2^i$的组,用$j*2^i$的空间能获得的最大价值。  
那么有：$f_{i,j}=\max(f_{i,j-cost}+val)$

考虑合并求出的状态：  
设$g_{i,j}$表示用物品代价为$a*2^0$到$a*2^i$的物品,$i$这一位用了$j*2^i$的体积，$i-1$喂以下用了$m\&(2^i-1)$的体积(即$i$位以下(不包含$i$)的与$m$相同)的最大价值。  
那么有：$g_{i,j}=(f_{i,j-k}+g_{i-1,k*2+(m>>(i-1)\&1)})$  
这里$g$数组可以用$f$数组滚动，注意下枚举顺序即可。  
其含义为：  
枚举在$i$这位用了$(j-k)*2^i$的体积,那么$i-1$位以下就会分到$k*2*2^{i-1}$的体积。

code：
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1010;
int n,m,len;
int w[35];
int f[35][maxn];
vector<int>cost[35],val[35];
inline void init()
{
	memset(val,0,sizeof(val));
	memset(cost,0,sizeof(cost));
	memset(f,0,sizeof(f));
	memset(w,0,sizeof(w));
	len=0;
 } 
int main()
{
	while(~scanf("%d%d",&n,&m)&&~n&&~m)
	{
		init();
		for(int i=1;i<=n;i++)
		{
			int x,y;scanf("%d%d",&x,&y);
			int j=0;
			while(!(x&1))x>>=1,j++;
			len=max(len,j);
			w[j]+=x;cost[j].push_back(x),val[j].push_back(y);
		}
		for(int i=0;i<=len;i++)
			for(unsigned int j=0;j<cost[i].size();j++)
				for(int k=w[i];k>=cost[i][j];k--)
					f[i][k]=max(f[i][k],f[i][k-cost[i][j]]+val[i][j]);
		while(m>>len)len++;
		len--;
		for(int i=1;i<=len;i++)
		{
			w[i]+=(w[i-1]+1)/2;
			for(int j=w[i];j>=0;j--)
				for(int k=0;k<=j;k++)	
					f[i][j]=max(f[i][j],f[i][j-k]+f[i-1][min(w[i-1],(k<<1)|((m>>(i-1))&1))]);
		}	
		printf("%d\n",f[len][1]);
	}
	return 0;
}
```


---

## 作者：ywy_c_asm (赞：12)

（~~感觉这种方法虽然可以但是比另一篇题解的方法要慢不少……~~）

首先我们要分析的是那个题目里仅有的特殊性质——$weight_i=a2^b(a<=10)$，其关键就是$a<=10$（毕竟是个数都能化成$a2^b$……），我们尝试把这个嵌入背包状态里，但是发现并不是特别好处理。

但是我们可以这样想，如果把一堆这样的数求个和，答案肯定也是$a'2^{b'}$的形式，并且$b'>=min\{b_i\}$。那么我们可以把一部分$b_i$比较大的物品拿出来，让他们右移一些位，最后把总重量再左移回来。

举个例子：我现在有3个重量，$5*2^{27}$，$3*2^{15}$，$7*2^{20}$，如果直接做背包的话我们需要把$dp$数组开到他们的和也就是差不多$6e8$的级别。但是我们把他们左移15位再做背包的话，我们只需要开$2e4$就行了，显然他们的子集和一定是$2^{15}$的倍数。

于是我们发现这是折半搜索（或者应该叫折半？）的套路，我们把物品分为两类，一类是$b<B$（这个$B$是我们设定的一个值）的，一类是$b>=B$的，对于后一类把重量右移$B$位再做背包，于是这个复杂度就不那么大了，然后我们枚举大背包（就是进行右移的那个）的所有重量，用$w$减去那个再从小背包里找就行了。注意如果要这样做的话我们需要在做完背包之后对$dp$数组取一个前缀$max$，这样就表示“重量至多有这么多最多价值多少”，毕竟我们是对两个背包进行相当于合并答案一样的操作，总花费不一定要等于$w$。

然后关于那个$B$的取值，一般折半的题会取到$\frac {30} 2=15$（$2^{30}$的数据范围是折半题里一个比较套路的数据范围……我也是因为这个想到了折半……），但是我们发现$a<=10$，$B=15$的时候小背包的最大重量和可能会比较大，但是我们发现大背包的最大重量和不能超过$2^{30-B}$（毕竟最后还要乘个$2^B$），所以我们可以把$B$适当的调小一点，我取的是12，而且也因为这个原因大背包的最大重量和应该和$2^{30-B}$取$min$。

上代码~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
using namespace std;
int bw[101],sw[101],bval[101],sval[101];//我的代码里加b的都是大背包里装的，s是小背包的 
int w[101],val[101];//w是重量，val是价值 
unsigned char can1[2000001],can2[2000001];
//我的背包写的有点诡异……我专门加了个可行性dp数组表示取这个重量是否可行……正常人一般不会这么写的…… 
ll dp1[2000001],dp2[2000001];//dp1是大背包，dp2是小背包 
int main() {
	while(1) {
		int n,W;
		cin>>n>>W;
		if(n==-1)break;
		memset(can1,0,sizeof(can1));
		memset(can2,0,sizeof(can2));
		memset(dp1,0,sizeof(dp1));
		memset(dp2,0,sizeof(dp2));//记得清空数组哦~ 
		int bsum=0,ssum=0;//最大重量和 
		int bptr=1,sptr=1;
		for(register int i=1; i<=n; i++) {
			int zl,jz;
			cin>>zl>>jz;
			int tmp=zl,cnt=0;
			while(!(tmp&1))tmp>>=1,cnt++;//计算重量的b 
			if(cnt>=12) {//装入大背包 
				zl>>=12;
				bw[bptr]=zl;
				bval[bptr]=jz;
				bptr++； 
				bsum+=zl;
			} else {
				ssum+=zl;
				sw[sptr]=zl;
				sval[sptr]=jz;
				sptr++;
			}
		}
		can1[0]=can2[0]=1;
		bsum=min(bsum,262144);
		for(register int i=1; i<bptr; i++) {//直接做背包 
			for(register int j=bsum; j>=bw[i]; j--) {
				if(can1[j-bw[i]]) {
					can1[j]=1;
					dp1[j]=max(dp1[j],dp1[j-bw[i]]+bval[i]);
				}
			}
		}
		for(register int i=1; i<sptr; i++) {
			for(register int j=ssum; j>=sw[i]; j--) {
				if(can2[j-sw[i]]) {
					can2[j]=1;
					dp2[j]=max(dp2[j],dp2[j-sw[i]]+sval[i]);
				}
			}
		}
		ll maxn=0;
		for(register int i=1; i<=bsum; i++)dp1[i]=max(dp1[i-1],dp1[i]);
		for(register int i=1; i<=ssum; i++)dp2[i]=max(dp2[i-1],dp2[i]);//取前缀max使得可以合并答案 
		for(register int i=0; i<=bsum; i++) {
			if((i<<12)>W)break;
			maxn=max(maxn,dp1[i]+dp2[min(ssum,W-(i<<12))]);//对两个背包合并答案 
		}
		cout<<maxn<<endl;
	}
	return(0);
}
```

---

## 作者：RyexAwl (赞：9)

## 分组处理出泛化物品

因为所有物品的体积都可以表示成 $a\times 2^b$ ，所有考虑按 $2^b$ 将物品分组，每组组内做一个 $01$ 背包之后合并泛化物品。

具体地：令 $f[i][j]$ 为所有体积为 $a\times 2^i$ 的物品中选出**体积小于等于** $j\times 2^i$ 的物品的最大价值。

## 利用二进制的性质合并泛化物品

一个重要的性质：$\sum_{j=0}^{i-1}2^j=2^{i}-1$ ，即 $\sum_{j=0}^{i-1}2^j < 2^i$ 。

因此我们考虑这么设计状态： 

$g[i][j]$ 为考虑前 $i$ 组物品，且选出的物品**体积小于等于** $j\times 2^i+ m \text{\&} (1<<(i-1))$ 的最大价值。

转移时考虑第 $i$ 组物品选多少：

$$
g[i][j]=\min_k(f[i][j-k]+g[i-1][2\times k+[m >> (i-1)\text{\&}1]])
$$

若 $W$ 的最高位为 $m$ ，那么答案即 $g[m][1]$ 。 

为什么这么设计状态？这么设计状态的好处是什么？

因为 $\sum_{j=0}^{i-1}2^j < 2^i$ ，且对于每一个 $2^k$ 其能表示的体积的上限为 $10n$ ，那么对于 $0...i-1$ 组能表示的体积的上限为 $10n\sum_{j=0}^{i-1}2^j$ 小于第 $i$ 组能表示的物品的体积上限 $10n\times 2^i$ 。

即：前 $i-1$ 组能表示出的物品体积上限与第 $i$ 组能表示出的体积上限在渐进意义下一致（均为 $O(an)$ 级别）。

设 $W$ 的二进制一共有 $m$ 位，那么这么去 $\text{DP}$ 实际的状态数为 $O(man)$ 级别。

---

## 作者：是个汉子 (赞：7)

[洛谷传送门](https://www.luogu.com.cn/problem/P3188)

### Solution

这题显然是 $\operatorname{01}$ 背包，但是这个题的数据范围是 $1\leq W,w_i,v_i\leq 2^{30}$ 。

？？？这复杂度不得上天？？？

好吧，我们又可以注意到`保证每个 wi都可以写成a*2^b的`，那么就得来点和二进制有关的优化了。

说的具体点，考虑对 $2^b$ 的那个 $b$ 相同的物品进行分层DP。

设 $f_{i,j}$ 表示剩下 $j\times 2^i$ 的体积时能取得的最大价值，那对于相同的 $i$ ，转移和 $01$ 背包一样。

重点在于怎么转移 $i$ 层到 $i-1$ 层：
$$
f_{i-1,j\times 2+s_{i-1}}=\max\{f_{i-1,j\times 2+s_{i-1}},f_{i,j}\}
$$
其中 $s_i$ 代表 $W$ 的第 $i$ 位是 $0$ 还是 $1$ 。那么 $f_{i-1,j\times 2+s_{i-1}}$ 就表示：当 $i$ 层剩下 $j\times 2^i$ ，留到 $i-1$ 层就变成了 $2\times j\times 2^{i-1}$ ，再加上本来 $i-1$ 层的 $s_{i-1}$ 。

注意：因为 $a\leq 10,n\leq 100$ ，即 $a\cdot n\leq1000$ ，所以第二维即 $j$ 可以定一个上界 $1000$ （好像能变快）

### Code

```c++
#include<cmath>
#include<cstdio>
#include<vector>
#include<cstring>
#include<iostream>
#include<algorithm>

using namespace std;
const int N=110;
int n,m,t,ans,w[N],v[N],f[33][1001],s[35];
vector<int> vec[35];

inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
    while(isdigit(ch)){x=x*10+(ch^48);ch=getchar();}
    return x*f;
}

int main(){
	while(~scanf("%d%d",&n,&m)&&n!=-1){
		memset(f,-0x3f,sizeof(f));
		memset(s,0,sizeof(s));
		memset(vec,0,sizeof(vec));
		ans=0;
		for(int j=0;j<=30;j++)
			if((1<<j)&m) s[j]=1,t=j;
		for(int i=1;i<=n;i++){
			w[i]=read(); v[i]=read();
			int b=0;
			while(w[i]%2==0) w[i]/=2,b++;
			vec[b].push_back(i);
		}
		for(int i=t;~i;i--){
			f[i][s[i]]=max(f[i][s[i]],0);
			for(int k=0;k<vec[i].size();k++){
				int x=vec[i][k];
				for(int j=w[x];j<=1000;j++)
					f[i][j-w[x]]=max(f[i][j-w[x]],f[i][j]+v[x]);
			}
			if(i)
				for(int j=0;j<=1000;j++)
					f[i-1][min(j*2+s[i-1],1000)]=max(f[i-1][min(1000,j*2+s[i-1])],f[i][j]);
			else
				for(int j=0;j<=1000;j++) ans=max(ans,f[i][j]);
		}
		printf("%d\n",ans);
	}
	return 0;
}
```



---

## 作者：封禁用户 (赞：3)

观察题意，有一个很特殊的地方，即保证每个 $w_i$ 能写成 $a\times 2^b \space (a,b \in \mathbb N)$ 的形式。所以我们考虑从高到低枚举 $b$，对相同的 $b$ 做一次普通背包。

接下来考虑如何合并。

设 $f[i][j]$ 表示当前处理到第 $i$ 位，在 **模 $2^i$** 意义下 **空余**空间为 $j$ 的最大价值。

当前位的转移为 $f[i][j] = \max(f[i][j], f[i][j + w[k]] + v[k])$。

从高位转移到低位为 $f[i][j] = \max(f[i][j], f[i + 1][\min(j \times 2 + ((W >> i) \& 1, 10 \times n)]$。

考虑最后为什么要与 $10 \times n$ 取 min。原因是我们发现当前位的 $a \leq 10$，所以当前位所占空间最大为 $10 \times n$。这样就能达到减小复杂度的目的。

由于习惯问题，代码中 $v_i$ 表示体积，$w_i$ 表示价值，$m$ 表示背包空间。

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;

int n, m;
int f[31][2005];

struct date {
	int w, v;
}a[105];

inline int lowbit(int x) { return x & -x; }

inline bool cmp(date x, date y) { return lowbit(x.v) > lowbit(y.v); }

inline void getmax(int &x, int y) { if(y > x) x = y; }

int main() {
	while(1) {
		scanf("%d%d",&n, &m);
		if(n == -1 && m == -1) break;
		for(int i = 1; i <= n; i++) scanf("%d%d",&a[i].v, &a[i].w);
		sort(a + 1, a + n + 1, cmp);
		memset(f, 0, sizeof(f));
		int cnt = 1, lim = 0;
		// lim 为 m 在当前位所能取到的最大空间 
		for(int pos = 30; pos >= 0; pos--) {
			if((1 << pos) > m) continue;
			lim = min(10 * n, 2 * lim + ((m >> pos) & 1));
			while(cnt <= n && lowbit(a[cnt].v) == (1 << pos)) {
				for(int i = 0; i + a[cnt].v / (1 << pos) <= lim; i++)
				 f[pos][i] = max(f[pos][i], f[pos][i + a[cnt].v / (1 << pos)] + a[cnt].w);
				++cnt;
			}
			if(pos == 0) continue;
			for(int i = 0; i <= lim; i++)
			 getmax(f[pos - 1][min(2 * i + ((m >> (pos - 1)) & 1), 10 * n)], f[pos][i]);
		}
		int res = 0;
		for(int i = 0; i <= lim; i++) getmax(res, f[0][i]);
		printf("%d\n",res);
	}
	return 0;
}
```


---

## 作者：ListenSnow (赞：3)

## 题意

给定 $n$ 颗宝石，每颗宝石都有重量和价值。要你从这些宝石中选取一些宝石，保证总重量不超过 $W$，且总价值最大，并输出最大的总价值。

#### 数据范围

$1 \leq n \leq 100,1 \leq W,w_i,v_i,\leq 2^{30}$。

**保证每个 $w_i$ 能写成 $a \times 2^b\space (a,b \in \mathbb N)$
 的形式，$a \leq 10$，$b \leq 30$**
 
### 思路

初看本题就是一个 01 背包的模板题，但是 $W \leq 2^{30}$ 决定了不能直接用朴素的 $O(nW)$ 方法做。

注意到 $w_i$ 满足一个性质：$a \times 2^b\space (a,b \in \mathbb N),a \leq 10,b \leq 30$。其实每个十进制数都可以表示成 $a \times 2^b$ 的形式（~~例如 $114514=114514 \times 2^0$~~）。因为十进制数和二进制数一一对应。所以本题的关键点在于 $a \leq 10$。这决定了可以考虑将所有的物品按照 $b$ 的大小分组。每个物品的体积就可以转化为 $a$，这样就可以节省大量的空间和时间。

设 $g[i][j]$ 表示在 $b=i$ 这一组中选取 $j$ 体积物品的最大价值。显然，只需要在每一组内部做一次 01 背包即可。

然而，$W$ **并不满足** $w_i$ 的性质，这就决定了只有 $g$ 数组并不能得到答案。

需要另外再开一个 $f$ 数组转移答案。

考虑 $f$ 的状态如何设计。显然根据 $w_i$ 的性质，需要有一个维度 $i$ 来表示目前枚举到 $b=i$ 这一组 $w$，还需要另外一个维度 $j$ 表示在这一组中选取了体积为 $j$ 的物品。同时要保证体积不能超过 $W$。怎么实现呢？假设当前已经填到了 $W$ 在二进制表示下的最高位 $k$ 那一组，显然输出答案时，$i=1$。那么就要保证后面位数上填的数不超过  $W$ 二进制第 $k$ 位以下的体积。分析到这里，状态就很很清楚了。

设 $f[i][j]$ 表示在 $0 \sim i$ 组一共选取了 $2^j$  加上 $W$ 二进制第 $i$ 位以下的体积的**原始体积**的最小花费。

显然，状态转移方程不可能只是简单的 

$f[i][j]=\max(f[i-1][j-k]+g[i][k])$。

$k$ 表示在第 $i$ 组选取体积为 $w$ 的物品（这一句的体积都指分组后的体积），注意到在第 $i$ 组选取体积为 $j-k$ 的物品，就等价于在第 $i-1$ 组选取体积为 $(j-k)*2$ 的物品。根据设计的状态，$j*2^i$ 的原始体积(下面都指原始体积)就由 $k*2^i$ 和 $2*(j-k)*2^{i-1}$ 贡献。而 $W$ 二进制第 $i$ 位以下的体积就要由原来的状态贡献。于是就可以得到状态转移方程：

$f[i][j]=\max(f[i-1][(j-k)*2+(W>>(i-1) \And 1)]+g[i][k])$。

最后，本题要多测，别忘了清空数组。

## code：
```cpp
#include<cstdio>
#include<cstring>
#include<vector>
using namespace std;
const int N=50;
const int M=5020;
#define int long long
int g[N][M],S,f[N][M],n,W;
vector<int>v[N],w[N];
int max(int a,int b){return a>b?a:b;}
void init()
{
	S=0;
	for(int i=0;i<N;i++) v[i].clear(),w[i].clear();
	memset(f,0,sizeof(f));
	memset(g,0,sizeof(g));
}
signed main()
{
//	freopen("233.in","r",stdin);
	while(scanf("%lld%lld",&n,&W))
	{
		if(n==-1&&W==-1) break;
		init();
		for(int tw,tv,i=1;i<=n;i++)
		{
			scanf("%lld%lld",&tw,&tv);
			int ws=0;
			while(((tw>>ws)&1)==0) ws++;
//			printf("%lld %lld\n",ws,tw>>ws);
			v[ws].push_back(tv);
			w[ws].push_back(tw>>ws);
		}
		while((W>>S)) S++;
		for(int i=0;i<S;i++)
		{
			if(w[i].size()==0) continue;
			for(int j=0;j<w[i].size();j++)
				for(int k=520;k>=w[i][j];k--)
					g[i][k]=max(g[i][k],g[i][k-w[i][j]]+v[i][j]);
		} 
		for(int i=0;i<S;i++)
		    for(int j=520;j>=0;j--)
		        for(int k=0;k<=j;k++)
		            f[i][j]=max(f[i][j],g[i][k]+f[i-1][(j-k)*2+((W>>(i-1))&1)]);
		printf("%lld\n",f[S-1][1]);
	}
	return 0;
}
/*
4 10
8 9
5 8
4 6
2 5
*/
```


---

## 作者：蒟蒻丁 (赞：3)

[圆题链接](https://www.luogu.com.cn/problem/P3188)
### 01背包冲鸭！！！
好吧他死了，考虑每一个物品体积都为$b*2^a$尝试进制优化\
首先设背包大小为$m$\
设$f_{i,j}$为背包大小最高位为$j*2^i$时最大价值\
也就是说，设现在考虑的物品编号为$k$，则背包大小为$j*2^i$+$($$w_k$&$((1<<i)-1)))$\
原来我们是枚举整个背包大小，而现在我们不再考虑低于第$i$位的确切数值\
比如当$w_k=1001$，$i=5,j=1$，背包大小为$11001$（以上均为二进制）\
转移则为$f_{i,j}=max(f_{i,j},f_{i,j-d}+f{i-1,2*d|((m>>(i-1))-1)})$\
就是说考虑从$i-1$处转移过来$2^i*d$大小的体积，由于$i$减了$1$，$d$相应要乘$2$\
就是$f_{i-1,2*d}$，考虑背包自身上限，还可以加上一个$2*d+((m>>(i-1))-1$
```
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
using namespace std;
const ll N=1005;
ll n,m,f[35][N],a[N],b[N],top;

int main(){
	scanf("%lld%lld",&n,&m);
	while(n!=-1&&m!=-1){
		top=0;
		memset(f,0,sizeof f);
		for(ll i=1;i<=n;i++){
			ll cnt=0,x;
			scanf("%lld%lld",&a[i],&b[i]),x=a[i];
			while(x%2==0){x/=2,cnt++;}
			for(ll j=1000;j>=x;j--){
				f[cnt][j]=max(f[cnt][j],f[cnt][j-x]+b[i]);
			}
		}
		for(ll i=m;i>0;i/=2)top++;
		top--;
		for(ll i=1;i<=top;i++){
			for(ll j=1000;j>=0;j--){
				for(ll k=0;k<=j;k++){
					f[i][j]=max(f[i][j],f[i][j-k]+f[i-1][min(1000*1ll,(k*2)|((m>>(i-1))&1))]);
				}
			}
		} 
		printf("%lld\n",f[top][1]);
		scanf("%lld%lld",&n,&m); 
	}
}
```
代码比较憨，请见谅

---

## 作者：Daidly (赞：2)

由于 $w_i=a\times 2^b$，所以按 $b$ 分组，第 $k$ 组为满足 $w_i=a\times 2^k,a\leq 10$ 的 $(w_i,v_i)$。

发现组内去掉 $2^k$ 做 01 背包是一件很容易的事，记 $f_{i,j}$ 表示第 $i$ 组在容量为 $j$ 的情况下的最大价值。转移和 01 背包一样。

考虑不同组之间关于 $W$ 的合并。发现组之间 $w_i$ 是二倍关系，所以若在第 $i$ 组去掉 $2^i$ 使用了 $j$ 的容量，则可以看成在第 $i-1$ 组去掉 $2^{i-1}$ 使用了 $2j$ 的容量。所以从高位到低位进行 dp。

若记 $g_{i,j}$ 为从高往低的 $i$ 位使用了 $j$ 的容量，这与直接做此题无异，$j$ 的范围过大。但是每组的最大容量并不像 $W$ 那么大，只有 $an$ 以内，那么考虑不记录一共有多少，而是记录剩多少容量。

记 $g_{i,j}$ 为从高往低的 $i$ 位剩余 $j$ 的容量，考虑正向转移，第 $i-1$ 位剩余的容量便是 $2j+W_{(i-1)}-k$，其中 $W_{(i-1)}$ 是 $W$ 在二进制下第 $i-1$ 位的大小，$k$ 为枚举第 $i-1$ 组使用多少容量。

$$
g_{i,j}+f_{i-1,k}\to g_{i-1,\min(10n,2j+W_{(i-1)}-k)}
$$

注意 $k$ 的范围，$0\leq k\leq\min(10n,2j+W_{(i-1)})$，并且注意 $g$ 的初始化，要初始化为负无穷。因为 $f_{i-1,k}$ 可能使不能被取到的 $g_{i,j}$ 转移到下一项。

记 $a$ 为 $10$，总时间复杂度为 $O(a^2n^2\log W)$。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
#define C(x,y) memset(x,y,sizeof(x))

inline int read(){
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c<='9'&&c>='0'){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}

void print(int x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)print(x/10);
	putchar(x%10^48);
}

const int N=1e2+5;
int n,W,w[35][N],v[35][N],num[35],f[35][10*N],g[35][10*N];

void h(int&x,int y){x=max(x,y);}

void solve(){
	for(int i=1;i<=n;++i){
		int ww=read(),vv=read(),b=0;
		while(!(ww&1))b++,ww>>=1;
		w[b][++num[b]]=ww,v[b][num[b]]=vv;
	}
	for(int i=0;i<=30;++i){
		for(int j=1;j<=num[i];++j){
			for(int k=10*n;k>=w[i][j];--k){
				h(f[i][k],f[i][k-w[i][j]]+v[i][j]);
			}
		}
	}
	g[30][0]=0;
	for(int i=30;i>=1;--i){
		g[i-1][0]=g[i-1][W>>(i-1)&1]=0;
		for(int j=0;j<=10*n;++j){
			for(int k=0;k<=min(10*n,2*j+(W>>(i-1)&1));++k){
				h(g[i-1][min(10*n,2*j+(W>>(i-1)&1)-k)],g[i][j]+f[i-1][k]);
			}
		}
	}
	for(int j=1;j<=10*n;++j)h(g[0][0],g[0][j]);
	print(g[0][0]),putchar('\n');
}

void clear(){
	C(f,0),C(g,0xcf),C(num,0);
}

signed main(){
	while(cin>>n>>W){
		if(n==-1&&W==-1)break;
		clear(),solve();
	}
	return 0;
}

```

---

## 作者：云浅知处 (赞：2)

可以设 $f(i,j)$ 表示：只考虑 $b\le i$ 的物品，其重量和 $\le 2^i\times j$ 的最大价值和。

注意到 $j$ 不会超过 $n\times 30$，因此复杂度不会爆炸。

转移时只需要对每组分别背包，求出 $g(i,j)$ 表示从 $b=i$ 的物品中选出 $\sum a\le j$ 的某些物品的最大价值和，那么就有转移 $f(i,j)+g(i+1,x)\to f(i+1,\lfloor j/2\rfloor +x)$。

我们发现还有个 $W$ 的限制不好满足。考虑从高位向低位 DP，重新设 $f(i,j)$ 表示考虑 $W$ 的最高 $i$ 位与 $b\ge i$ 的物品，其重量和与 $W$ 抵消之后，$W$ 还剩下了 $2^i\times j$ 的最大价值和。转移时，设 $c$ 为 $W$ 在第 $i+1$ 位上的值，有
$$
f(i,j)+g(i+1,x)\to f(i+1,2j+c-x)\\
f(i+1,0)=0,f(i+1,c)=0
$$
于是就做完了，总的复杂度大概是 $O(a^2n^2\log W)$ 

```cpp
#define C(arr,x) memset(arr,x,sizeof(arr))
void chkmax(int &x,int v){x=max(x,v);}

void solve(){
	C(f,0xcf),C(g,0xcf),C(v,0),C(a,0),C(b,0);
	for(int i=0;i<=30;i++)vec[i].clear();
	for(int i=1;i<=n;i++){
		int w=read();v[i]=read();
		while(w%2==0)w>>=1,b[i]++;a[i]=w;
		vec[b[i]].emplace_back(i);
	}
	int m=n*10;
	for(int i=0;i<=30;i++){
		g[i][0]=0;for(auto t:vec[i]){
			for(int j=m;j>=a[t];j--)chkmax(g[i][j],g[i][j-a[t]]+v[t]);
		}
	}
	f[31][0]=0;
	for(int i=31;i>=1;i--){
		int c=((W>>(i-1))&1);
		f[i-1][0]=f[i-1][c]=0;
		for(int j=0;j<=m;j++){
			for(int k=0;k<=m;k++)if(j*2+c-k>=0)chkmax(f[i-1][min(j*2+c-k,m)],f[i][j]+g[i-1][k]);
		}
	}
	int ans=0;
	for(int i=0;i<=m;i++)ans=max(ans,f[0][i]);
	cout<<ans<<endl;
}
```

---

## 作者：lrb666 (赞：1)

[原题链接](https://www.luogu.com.cn/problem/P3188)

【题目描述】

给你 $n$ 个物品分别给出他们的体积 $v_i$ 和价值 $w_i$ ，问你容量为 $m$ 的背包最多装多少价值。

【题解】

- 首先注意到这题本质就是个 $01$ 背包，但是由于数据范围较大无法通过，需要注意到的是 $v_i=a\times 2^b,a\le 10,b\le 30$

> 这其实在诱导你按照二进制位数进行分组 $01$ 背包，再进行合并

- 首先考虑先将每一组的 $01$ 背包求出，将 $f_{i,j}$ 表示为当前第 $i$ 组使用 $j\times 2^i$ 的容量拿的最大价值

- - 将每一个物品按照 $a\times 2^b$ 拆开表示为在 $b$ 这一组内有个体积为 $a$ 的物品

- - 进行普通的 $01$ 背包 $f_{i,j}=\max(f_{i,j},f_{i,j-v_k}+w_k)$




- 现在我们重新定义一个数组 $g_{i,j}$ 表示前 $i$ 组当前第 $i$ 组用了 $j\times 2^i$ 并且全部的容量小于等于 $m$ 获得的最大价值，并定义 $bit_i$ 表示 $w$ 二进制第 $i$ 是否为 $1$

- - 当前 $1\sim i$ 用了 $j$ 容量获得的价值等于这一组背包用了 $k$ 容量的价值加上 $1\sim (i-1)$ 用了 $2\times (j-k)+bit_{i-1}$ 的价值
$$
g_{i,j}=\max(g_{i,j},f_{i,k}+g_{i-1,2\times(j-k)+bit_{i-1}})
$$
依次进行合并即可

```cpp
		vector v(31,vector<pair<int,int> >());
		vector f(lim+2,vector<ll>(2005)),g(lim+2,vector<ll>(2005));
		for(int i=1;i<=n;i++){
			int v1,w;
			scanf("%d%d",&v1,&w);
			int lp=__builtin_ffs(v1)-1;
			v[lp].push_back({v1>>lp,w});
		}
		for(int i=0;i<=lim;i++){
			for(auto [vv,ww]:v[i]){
				for(int j=1000;j>=vv;j--){
					f[i][j]=max(f[i][j],f[i][j-vv]+ww);
				}
			}
		}
		for(int i=0;i<=1000;i++) g[0][i]=f[0][i];
		for(int i=1;i<=lim;i++){
			for(int j=0;j<=1000;j++){
				for(int k=0;k<=j;k++){
					g[i][j]=max(g[i][j],f[i][k]+g[i-1][2*(j-k)+(w>>(i-1)&1)]);
				}
			}
		}

```
***

**有什么不懂的可以评论区问，看到了会回复**

---

## 作者：LJ07 (赞：1)

## 题目描述

[题目传送门](https://www.luogu.com.cn/problem/P3188)

## 思路简述

一看题目：01背包。

联系本题的特殊数据范围：

> 保证每个 $w_i$ 能写成 $a \times 2^b$ $(a,b\in N)$ 的形式，$a \leq 10$，$b \leq 30$。

> $n\leq 100$。

---

很容易的想到可以对于每一个二进制位进行 dp。

设计状态：$dp[i][j]$ 表示到第 $i$ 个二进制位，现在剩余的背包恰好还有 $j$ 个 $2^i$ 的大小的最大价值。

---

那么用所有 $w$ 能够表示为 $a\times 2^i$ 的物体去更新 $dp[i][j]$,每次转移的方程是 ```dp[i][j]=max(dp[i][j],dp[i][j+a]+v)```（$v$ 为当前物体的价值）。

由于滚动数组，从 $j$ 从小到大转移。

$i$ 从大到小更新考虑 $dp[i+1][]$ 对于 $dp[i][]$ 的贡献。

令 $tag$ 表示 $W$ 在二进制表示下第 $i$ 位是否是 $1$。

那么就有 ```dp[i][j*2+tag]=dp[i+1][j]```。

---

初始化 ```dp[31][0]=0```，其余皆赋值为无穷小。

---

那么现在问题来了，第二维的枚举范围是多少呢？由于 $n\leq 100$，所以当 $j\ge 1000$ 时，后面的所有物体都可以选，直接特判即可。

---
时间复杂度 $O(3000Tn)$

~~码量很小（至多20min写+调这样子？）~~

## 丑陋の代码
[click here](https://www.luogu.com.cn/paste/y8yaku82)

---

## 作者：RemiliaScar1et (赞：1)

### P3188 [HNOI2007]梦幻岛宝珠

 ~~2021第一道题~~

超大背包+物品问题。

物品数量很少，并且 $w_i,v_i$ 可以拆分成 $a\times 2^b$ 的形式。

考虑二进制分组

我们可以**按照 $b$ 的大小对物体进行分组，然后在每个组内01背包，就能得到一些泛化物品** ([$link:泛化物品的定义$](https://www.kancloud.cn/kancloud/pack/70132))

---
- **泛化物品定义：** 考虑一种物品，它**没有固定的费用和价值**，而是其价值**随着分配给它的费用变化而变化**。

  对于一个泛化物品，可以用一个一维数组$G_i$表示其费用与价值的关系：当费用为$i$时，相对应的价值为$G_i$。

- **泛化物品的和**：把两个物品合在一起的运算，就是枚举费用分配给两个物品，

  $G_j=max(G1_{j-k},G2_{k})(0 \leq k \leq j \leq C)$

  时间复杂度为$O(C^2)$。

---

$g(i\,,\,j)$ 表示 **$2^i$ 组分配给 $j$ 的费用时能获得的最大价值。**

泛化物品的个数最多只有 $31$ 个，因为 $0\le b \le 30$

然后我们考虑将泛化物品合并得到答案。

根据题目，我们可以定义状态值 $f(i\,,\,j)$ 为：**用了 $j\times 2^i + W \& (2^i-1)$ 的容积**

也就是说，我们枚举费用二进制下的最高位，剩下的位与题中的 $W$ 相同。

设 $W$ 的最高位代表 $2^I$ ，答案就是 $f(I\,,\,1)$。

枚举 $i,j$ 为 **分组到达的位置** 和 **使用的总费用**，枚举 $k$ 为 **当前组所使用的费用**。

则状态转移方程：

$f(i\,,\,j)=max\{\ g(i\,,\,k)+f(i-1\,,\,(j-k)\times 2+(W>>(i-1)\&1))\ \}$

注意 $i$ 与 $i-1$ 联系的时候要将当前 $j$ 中分配给上一组的费用 $\times 2+\,$ $W$上一二进制位上的数。

$f,g$记得开`long long`

于是打出如下代码(C++11 O2 1.68s)
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N=5020;
const int L=210;

int n,W;
int maxn=0;
vector<ll> w[N],v[N];
ll f[L][N],g[L][N];

inline ll max_(ll a,ll b)
{
	return (a>b?a:b);
}

int main()
{
	while(scanf("%d%d",&n,&W)!=EOF && ~n && ~W)
	{
		for(int i=0;i<=100;i++)
			w[i].clear(),v[i].clear();
		memset(f,0,sizeof f);
		memset(g,0,sizeof g);

		for(int i=1;i<=n;i++)
		{
			int x,y;
			scanf("%d%d",&x,&y);
			int j=0;
			while(!(x&1)) x>>=1,++j;
			maxn=max_(x,j);
			w[j].push_back(x),v[j].push_back(y);//分组
		}
		int I=0;
		while((1<<I)<W) I++;//求 W 最高位数
		I--;

		for(int i=0;i<=I;i++)//遍历每个组
		{
			if(!w[i].size()) continue;
			for(unsigned long long j=0;j<w[i].size();j++)
			{
				for(int k=1000;k>=w[i][j];k--)
				{
					g[i][k]=max_(g[i][k],g[i][k-w[i][j]]+v[i][j]);
				}
			}
		}

		for(int i=0;i<=I;i++)
		{
			for(int j=1000;j>=0;j--)
			{
				for(int k=0;k<=j;k++)//枚举当前组使用的费用
					f[i][j]=max_(f[i][j],(ll)g[i][k]+f[i-1][(j-k)*2+(W>>(i-1)&1)]);
			}
		}

		printf("%lld\n",f[I][1]);
	}
	return 0;
}

```

---

## 作者：Yansuan_HCl (赞：0)

这里写一种和其他题解不太一样的做法：边 dp 边合并。

不妨设 $M(x)=2^{x+1}-1$，即一个 $x$ 位的全 $1$ 数。

利用贪心的思想，我们可以设 $f[j][k]$ 为当前背包容积为 $j \times 2^k + M(k-1) \& W$ 时的最大价值，即**前 $k-1$ 位的容量都按照 $W$ 的限制达到最大值**。我们可以把 $i$ “堆”在第 $k$ 位，转移时再向前进位。进位时，枚举容量 $j$，则当且仅当 $j \& 1=0$ 或 $m \& (1<<k)=1$ 时可以进位（需要在当前位上留下一个 1 或无需留下 1)。

但是这样还不够：考虑反例 $m=(1000)_2$，按照这种方式 dp 则无法放入 $w=(0111)_2$ 的物品。发现有时不能一直满足**按照 $W$ 的限制达到最大值**，于是考虑再设一个 $g[j][k]$ 表示当前背包容积为 $j \times 2^k + M(k-1)$ 时的最大价值。$g$ 的转移比较随便，但是要注意 $g$ 需要转移到 $f$。怎样转移？只有 $m$ 在第 $k$ 位是 $1$，但是 $j \& 1=0$（即在当前位填 $0$）的时候，容量才会小于 $M(k) \& W$。

核心代码：

```cpp
void dp() {
    int i = 1;
    U (k, 0, 30) {
        for (; gem[i].b == k && i <= n; ++i) { // 记得判断边界！
            for (int j = 2000; j >= gem[i].a; --j) {
                f[j][k] = max(f[j][k], f[j - gem[i].a][k] + gem[i].v);
                g[j][k] = max(g[j][k], g[j - gem[i].a][k] + gem[i].v); // 背包 dp 转移
            }
        }
        U (j, 0, 2000) {
            if ((m & (1 << k)) || !(j & 1))  // 允许在这一位留下一个 1, 或不产生 1
                f[j >> 1][k + 1] = max(f[j >> 1][k + 1], f[j][k]);

            g[j >> 1][k + 1] = max(g[j >> 1][k + 1], g[j][k]);
            if ((m & (1 << k)) && !(j & 1))
                f[j >> 1][k + 1] = max(f[j >> 1][k + 1], g[j][k]); // g 向 f 转移
        }
    }
}
```

[完整代码](https://www.luogu.com.cn/paste/tmsz3y18)

---

## 作者：Hasinon (赞：0)

## 前言
大家貌似都用的纯分组背包的想法  
而我做背包的时候**比较当前总代价和最大代价的方法**不太原教旨。

## 简要题意

01 背包，但是代价可以表示成 $ a\times 2^b (a\le10,b\le30) $ 的形式

## 思路
~~由于本蒟蒻刚 A 掉 NOIP2021 T2~~    
十分自然的想到了一种**按二进制位判断代价**的 DP 形式

我们首先处理出每个物品的 $a,b$，按每个物品的 $b$ 对它们分个类，$b$ 相等就扔在一堆。

记 DP 数组 $ dp[i][j][0/1] $，$i$ 代表当前处理的是 $b=i$ 的堆。

### 重点 ~~我讲不太好的点~~：  
（$W$ 代表最大代价，$w$ 代表当前总代价)） 
$j$ 代表在二进制表示下，当前总代价 $w$ **第 $i$ 位**及**以上**的十进制表示  

比如说 $w=11=(2)1011$ ，当 $i=2$ 时，$j=5=(2)101$
($(2)$指 $101$ 是二进制数)

$0/1$ 代表在二进制表示下，只看当前总代价  $w$ **第 $i-1$ 位**及**以下**是否大于最大代价  $W$。  

我们在学高精度的时候也许就知道了——比较两数最高位可决定两数相对大小，若两数最高位相等，则比较此高位，以此类推。

所以这题也可以通过进行从低位到高位的不断比较判断 $w$ 与 $W$ 的大小关系。

其实讲到这里了大家大概都可以自己推式子了，想看的就继续。
## 转移式

### 在每堆之间的转移:
（$W_i$ 代表第 $i$ 位上最大代价的值，$w_i$  代表第 $i$ 位上当前总代价的值，（均为二进制））


- $ (W_i>w_i) dp[i+1][j\div2][0]=\max(dp[i+1][j\div2][0],\max(dp[i][j][0],dp[i][j][1])) $ 
- $ (W_i<w_i) dp[i+1][j\div2][1]=\max(dp[i+1][j\div2][1],\max(dp[i][j][0],dp[i][j][1])) $ 
- $ (W_i=w_i) dp[i+1][j\div2][0]=\max(dp[i+1][j\div2][0],dp[i][j][0]),				   dp[i+1][j\div2][1]=\max(dp[i+1][j\div2][1],dp[i][j][1]) $   

那些乱糟糟的 $0/1$ 变化其实就是高位影响低位的结果：  
如果第 $i$ 位上 $W_i>w_i$，那无论第 $i-1$ 位及之前 $W$ 与 $w$ 的关系如何，考虑第 $i$ 位后一定都是 $W>w$，$W_i<w_i$同。  
而 $W_i=w_i$，第 $i$ 位的比较不产生影响，就以第 $i-1$ 位及之前的比较为准了。

关于 $j$ 的递推：  
我们从考虑第 $i$ 位及以后到第 $i+1$ 位及以后，不就是把第 $i$ 位扔掉嘛，右移一位，即 $j\div2$。

### 在堆内的转移

我们已经把第 $i$ 位对 $W$ 和 $w$ 的大小关系的影响扔在最后（两堆之间的转移）考虑，硬做一遍背包,而且不大于和大于 ($0/1$) 两边分开转移就好了。
## done！

```cpp
// By Hasinon,the juruo who's waiting for AFO life.
#include<bits/stdc++.h>
#define ll long long
#define FOR(i,a,b) for(int i=(a); i<=(b); ++i)
#define ROF(i,a,b) for(int i=(a); i>=(b); --i)
using namespace std;
bool hasinon;
ll time1=clock();
//
struct node{
	ll v,a,b;
};
const ll N=100;
node trea[N+10];
ll dp[31][1010][2],wdig[50]; // 位数 上传数 是否超 
ll dto;
//
ll dig(ll a){
	ll t=0;
	while(!(a%(1ll<<t))&&t<=30) ++t; --t;
	return t;
}
void chan(ll a){
	dto=0;
	while(a){
		wdig[++dto]=(a&1); a>>=1;
	}
}
//
bool cmp(node a,node b){
	return a.b<b.b;
}
inline ll gt(){
	ll t=0,f=0;char v=getchar();
	while(!isdigit(v))f|=(v=='-'),v=getchar();
	while(isdigit(v))t=(t<<3)+(t<<1)+v-48,v=getchar();
	return f?-t:t;
}
bool Hasinon;
//void usage() {
//	ll time2=clock();
//	cout<<(&Hasinon-&hasinon)/1024/1024<<" Mb, "<<time2-time1<<" Ms\n";
//}
int main() {
//	freopen("P3188.in","r",stdin);
//	freopen("P3188.out","w",stdout);
	while(1){
		ll inn=gt(),inw=gt();
		if(inn==-1&&inw==-1) return 0;
		FOR(i,1,inn){
			ll t1=gt(),t2=gt(),tb=dig(t1); trea[i]={t2,t1/(1ll<<tb),tb};
		}  
		sort(trea+1,trea+inn+1,cmp);
		chan(inw); 
		ll tto=1;
		memset(dp,-0x3f,sizeof(dp));
		dp[0][0][0]=0;
		FOR(i,1,dto){
			for(int j=0; j<10*inn; j++){
				if(wdig[i-1]==1&&!(j&1)) 
					dp[i][j/2][0]=max(dp[i][j/2][0],max(dp[i-1][j][0],dp[i-1][j][1]));
				else if(wdig[i-1]==0&&(j&1))
					dp[i][j/2][1]=max(dp[i][j/2][1],max(dp[i-1][j][0],dp[i-1][j][1]));
				else{
					dp[i][j/2][0]=max(dp[i][j/2][0],dp[i-1][j][0]);
					dp[i][j/2][1]=max(dp[i][j/2][1],dp[i-1][j][1]); 
				}
			}
			while(trea[tto].b==i-1&&tto<=inn){
				ROF(j,10*inn-trea[tto].a,0){
					dp[i][j+trea[tto].a][0]=max(dp[i][j+trea[tto].a][0],dp[i][j][0]+trea[tto].v);	
					dp[i][j+trea[tto].a][1]=max(dp[i][j+trea[tto].a][1],dp[i][j][1]+trea[tto].v);	
				}
				++tto;
			}
			FOR(j,0,10*inn){
				if(wdig[i]==1&&!(j&1)){
					dp[i][j][0]=max(dp[i][j][0],dp[i][j][1]);	
					memset(&dp[i][j][1],-0x3f,sizeof(dp[i][j][1]));
				}
				else if(wdig[i]==0&&(j&1)){
					dp[i][j][1]=max(dp[i][j][0],dp[i][j][1]);	
					memset(&dp[i][j][0],-0x3f,sizeof(dp[i][j][1]));
				}
			}
		}
		ll ans=0;
		FOR(j,0,1){
			ans=max(ans,dp[dto][j][0]);
		}
		printf("%lld\n",ans);
	} 
}

```




---


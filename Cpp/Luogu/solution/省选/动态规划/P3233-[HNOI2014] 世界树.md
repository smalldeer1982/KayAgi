# [HNOI2014] 世界树

## 题目描述

世界树是一棵无比巨大的树，它伸出的枝干构成了整个世界。在这里，生存着各种各样的种族和生灵，他们共同信奉着绝对公正公平的女神艾莉森，在他们的信条里，公平是使世界树能够生生不息、持续运转的根本基石。

世界树的形态可以用一个数学模型来描述：世界树中有 $n$ 个种族，种族的编号分别从 $1$ 到 $n$，分别生活在编号为 $1$ 到 $n$ 的聚居地上，种族的编号与其聚居地的编号相同。有的聚居地之间有双向的道路相连，道路的长度为 $1$。保证连接的方式会形成一棵树结构，即所有的聚居地之间可以互相到达，并且不会出现环。定义两个聚居地之间的距离为连接他们的道路的长度；例如，若聚居地 $a$ 和 $b$ 之间有道路，$b$ 和 $c$ 之间有道路，因为每条道路长度为 $1$ 而且又不可能出现环，所以 $a$ 与 $c$ 之间的距离为 $2$。

出于对公平的考虑，第 $i$ 年，世界树的国王需要授权 $m_i$ 个种族的聚居地为临时议事处。对于某个种族 $x$（$x$ 为种族的编号），如果距离该种族最近的临时议事处为 $y$（$y$ 为议事处所在聚居地的编号），则种族 $x$ 将接受 $y$ 议事处的管辖（如果有多个临时议事处到该聚居地的距离一样，则 $y$ 为其中编号最小的临时议事处）。

现在国王想知道，在 $q$ 年的时间里，每一年完成授权后，当年每个临时议事处将会管理多少个种族（议事处所在的聚居地也将接受该议事处管理）。 现在这个任务交给了以智慧著称的灵长类的你：程序猿。请帮国王完成这个任务吧。

## 说明/提示

对于 $100\%$ 的数据，$N\leq 300000$, $q\leq 300000$, $\sum^q_{i=1}m_i \leq 300000$。


## 样例 #1

### 输入

```
10
2 1
3 2
4 3
5 4
6 1
7 3
8 3
9 4
10 1
5
2
6 1
5
2 7 3 6 9
1
8
4
8 7 10 3
5
2 9 3 5 8```

### 输出

```
1 9   
3 1 4 1 1   
10  
1 1 3 5   
4 1 3 1 1```

# 题解

## 作者：MCAdam (赞：86)

[题目](https://www.luogu.com.cn/problem/P3233)

首先考虑暴力：

我们要计算每一个点离它最近的议事点，这个可以通过两遍$dfs$完成

1、计算当前点$p$到它子树中最近的议事点，先递归$p$的儿子再计算

2、此时根节点就保存了它需要的答案，我们用父亲节点去更新儿子，更新完后再递归

```cpp
inline void dfs1(int p,int fa)
{
	dp[p]=INF;//dp表示最短距离,g表示编号
	for(register int i=fir[p];i;i=e[i].nxt)
	{
		int q=e[i].to;
		if(q==fa) continue;
		dfs1(q,p);//用儿子更新自己
		if(dp[q]+1<dp[p]) dp[p]=dp[q]+1,g[p]=g[q];
		else if(dp[q]+1==dp[p]) g[p]=min(g[p],g[q]);
	}
	if(vis[p]) dp[p]=0,g[p]=p;
	vis[p]=0;
}
inline void dfs2(int p,int fa)
{
	for(register int i=fir[p];i;i=e[i].nxt)
	{
		int q=e[i].to;
		if(q==fa) continue;//用自己更新儿子
		if(dp[p]+1<dp[q]) dp[q]=dp[p]+1,g[q]=g[p];
		else if(dp[p]+1==dp[q]) g[q]=min(g[q],g[p]);
		dfs2(q,p);
	}
}
```
看到有$\sum m_i$，套路地建一棵虚树

对于虚树上的点（议事点和它们的$lca$），议事点答案当然是自己本身，对于$lca$点，就像上面暴力一样遍历整棵虚树就行了。注意此时，虚树上的节点并不是连续的，所以两个点之间的距离并不是$1$，要预处理每个点在原树上的深度

那怎么计算非虚树上的节点呢？

第一种情况：

原树上一个点$p$，对于它的某个儿子$q$，如果$q$这个子树中没有议事点，那么$q$整棵子树肯定都是从离$p$最近的议事点走过来的

第二种情况：

原树上一条链，两端都是议事点，这一条链各一半属于两个议事点

对应到虚树上就是：

1、一个虚树点$p$，如果它在在原树上的某个儿子$q$，$q$整棵子树都没有议事点，那么$q$这颗子树的大小就能贡献到$g[p]$

2、对于虚树上的一条边，它两端$p$和$q$（即使是$lca$点也行，因为$lca$点我们已经处理好了）。虚树上的这一条边对应的是原树的一条链，我们要找到这条链上的分界点。这个直接由倍增就可以了。

具体实现：

1、对于虚树上的一个点$p$，它的一个儿子$q$，我们要计算$p$在原树中的儿子$q_{real}$（注意区分），$q_{real}$子树中没有议事点。因为我们不能遍历原树，只能遍历虚树，但因为虚树上的儿子节点$q$对应上来的肯定是不用贡献的，那我们就用$size[p]-1$减去$q$对应上来的儿子的$size$就是我们要的了。具体写的时候可以先全部减掉再加回来。

![](https://cdn.luogu.com.cn/upload/image_hosting/5heqjjms.png)

2、原树上的链。虚树上的两个点$p$和$q$（$q$是虚树上$p$的儿子）对应到原树上的链，在这上面倍增找到分割点，然后计算贡献。注意虚树上的这一条边，对应到原树上是一条链并且挂着许多的子树。子树的贡献也是要算上的。注意这一步是只计算链上且不包括两端的情况，所以同样要找到$p$在原树上的儿子。

举个栗子（样例第三个再加一个点）：

![](https://cdn.luogu.com.cn/upload/image_hosting/u55nut0g.png)

我们倍增找到$q$对应上来的$p$的儿子（2），以及分割点（3），那么$3,4,5,7,9$此时都算到$g[8]=8$的答案中，也就是$ans[g[8]]+=size[3]-size[8]$；$2$此时算到$g[1]=6$中，也就是$ans[g[1]]+=size[2]-size[3]$

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <algorithm>
using namespace std;
const int N=3e5+10,INF=1e9+10;
int n,m,top,cnt;
int dep[N],f[N][20],dfn[N],size[N],lg2[N],sta[N],pnt[N],vis[N],g[N],dp[N],ans[N],tmp[N];
struct graph
{
	int tot;
	int fir[N],to[2*N],nxt[2*N];
	graph(){ tot=0; memset(fir,0,sizeof(fir)); }
	inline void add(int x,int y)
	{
		to[++tot]=y; nxt[tot]=fir[x]; fir[x]=tot;
		to[++tot]=x; nxt[tot]=fir[y]; fir[y]=tot;
	}
}e1,e2;
inline void dfs(int p)//预处理dfn,dep,size 
{
	dfn[p]=++cnt,size[p]=1;
	for(register int i=e1.fir[p];i;i=e1.nxt[i])
	{
		int q=e1.to[i];
		if(q==f[p][0]) continue;
		dep[q]=dep[p]+1,f[q][0]=p;
		for(register int j=1;j<=lg2[dep[q]]+1;j++)
			f[q][j]=f[f[q][j-1]][j-1];
		dfs(q);
		size[p]+=size[q];
	}
}
inline int get_lca(int x,int y)//找lca 
{
	if(dep[x]<dep[y]) swap(x,y);
	for(register int i=lg2[dep[x]];i>=0;i--)
		if(dep[f[x][i]]>=dep[y]) x=f[x][i];
	if(x==y) return x;
	for(register int i=lg2[dep[x]];i>=0;i--)
		if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
	return f[x][0];
}
inline bool cmp(int a,int b)
{
	return dfn[a]<dfn[b];
}
inline void build(int p)//建立虚树 
{
	if(top==0){ sta[top=1]=p; return; }
	int lca=get_lca(sta[top],p);
	while(top>1&&dep[lca]<dep[sta[top-1]]) e2.add(sta[top-1],sta[top]),top--;
	if(dep[lca]<dep[sta[top]]) e2.add(lca,sta[top--]);
	if(top==0||sta[top]!=lca) sta[++top]=lca;
	sta[++top]=p;
}
inline void cal(int x,int y)
{
	int p=y,q=y;
	for(register int i=lg2[dep[p]];i>=0;i--)
		if(dep[f[p][i]]>dep[x]) p=f[p][i];
	ans[g[x]]-=size[p];//跳到y在原树上对应的x的儿子 
	for(register int i=lg2[dep[q]];i>=0;i--)
	{
		int llen=dep[y]-dep[f[q][i]]+dp[y],rlen=dep[f[q][i]]-dep[x]+dp[x];
		if(dep[f[q][i]]>dep[x]&&(llen<rlen||(llen==rlen&&g[y]<g[x]))) q=f[q][i];//倍增找到分割点 
	}
	ans[g[y]]+=size[q]-size[y],ans[g[x]]+=size[p]-size[q];//注意这里要加的是size，因为虚树路径上会有子树 
}
inline void dfs1(int p,int fa)
{
	dp[p]=INF;
	for(register int i=e2.fir[p];i;i=e2.nxt[i])
	{
		int q=e2.to[i];
		if(q==fa) continue;
		dfs1(q,p);
		int dis=dep[q]-dep[p];//注意这里，虚树上的节点并不是连续的 
		if(dp[q]+dis<dp[p]) dp[p]=dp[q]+dis,g[p]=g[q];
		else if(dp[q]+dis==dp[p]) g[p]=min(g[p],g[q]);
	}
	if(vis[p]) dp[p]=0,g[p]=p;
}
inline void dfs2(int p,int fa)
{
	for(register int i=e2.fir[p];i;i=e2.nxt[i])
	{
		int q=e2.to[i];
		if(q==fa) continue;
		int dis=dep[q]-dep[p];
		if(dp[p]+dis<dp[q]) dp[q]=dp[p]+dis,g[q]=g[p];
		else if(dp[p]+dis==dp[q]) g[q]=min(g[q],g[p]);
		cal(p,q);
		dfs2(q,p);
	}
	ans[g[p]]+=size[p];//注意这里，还要加上自己 
	vis[p]=e2.fir[p]=0;
}
int main()
{
	lg2[1]=0;
	for(register int i=1;i<=3e5;i++)
		lg2[i]=lg2[i>>1]+1;
	int a,b,T;
	scanf("%d",&n);
	for(register int i=1;i<n;i++)
	{
		scanf("%d%d",&a,&b);
		e1.add(a,b);	
	}
	dep[1]=1,dfs(1);
	scanf("%d",&T);
	while(T--)
	{
		int flag=1;
		top=e2.tot=0;
		scanf("%d",&m);
		for(register int i=1;i<=m;i++)
			scanf("%d",&pnt[i]),vis[pnt[i]]=1,ans[pnt[i]]=0;
		if(!vis[1]) pnt[++m]=1,flag=0;
		for(register int i=1;i<=m;i++)
			tmp[i]=pnt[i];
		sort(pnt+1,pnt+m+1,cmp);
		for(register int i=1;i<=m;i++)
			build(pnt[i]);
		if(top) while(--top) e2.add(sta[top],sta[top+1]);
		dfs1(1,0),dfs2(1,0);
		for(register int i=1;i<=m;i++)
			if(tmp[i]!=1||flag) printf("%d ",ans[tmp[i]]);//注意判断1 
		printf("\n");
	}
	return 0;		
}
```


---

## 作者：BJpers2 (赞：44)

这道题目是显而易见的虚树，但难点却在DP，楼上虚树讲的已经很明白了，我这里重点讲一下DP的过程。

我这边用了6遍dfs，功能都不一样。

1. 在原图上DP求出父亲，深度等基本信息。

2. 在虚树上DP,先考虑求出每个虚树节点靠得最近的“关键节点”。具体来说分为两步。
   - 首先求出二元组g[u]，以距离为第一关键字，节点编号为第二关键字。它表示在以u为根的子树内，离u最近的节点到u的距离，以及它的编号。自下而上地推即可。用pair可以实现很直观的比较。
   - 然后再此基础上自上而下DP,在每一个点处都实时维护“经过u的父亲到达u的最近节点的编号及其距离”，用这个值去更新g。最后用数组tn[u]存储离u最近的节点编号
   
3. 做后一阶段计算的准备工作，显然若u是虚树点，若v是u在原树的儿子而且以v为根的子树中不存在议事处，整棵子树都归离u最近的议事处管辖，只需用u的子树大小减去所有含议事处的子树大小即可。具体来说只要在虚树上倍增到自己虚树父亲的下行第一个节点，然后减掉它的size。

4. 在做完3中的工作后，只剩下虚树边上的被我们忽略的节点没有确定归属。
 - 若对于虚树边(u,v),满足tn[u]=tn[v]，则可以直接给tn[u]加上这条边上所有点。
 - 否则，tn[u]与tn[v]必然是一上一下，可以考虑计算中间点的深度，然后倍增找到它。两端加入相应的值即可。
 
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<utility>
#define fr first
#define sc second
#define REP(u) for(int i=hd[u],v=e[i].v;i;i=e[i].n,v=e[i].v)
#define REQ(u) for(int i=Hd[u],v=E[i].v;i;i=E[i].n,v=E[i].v)
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define ROF(i,a,b) for(int i=a;i>=b;i--)
using namespace std;
typedef pair<int,int> p;
const int N=300300,LG=18,M=600600,INF=1000010000;
struct edge{int n,v;}e[M],E[M];
int n,m,T,u,v,ti,fl,Fl,tp,rt;
int a[N],bo[N],df[N],sz[N],d[N],tn[N],up[N];
int f[N][LG+2],s[N],Hd[N],hd[N],ans[N],A[N];
p g[N];
void add(int u,int v){e[++fl]=(edge){hd[u],v};hd[u]=fl;}
void Add(int u,int v){E[++Fl]=(edge){Hd[u],v};Hd[u]=Fl;}
void dfs0(int u){
    df[u]=++ti;sz[u]=1;
    REP(u)if(v!=f[u][0])
        f[v][0]=u,d[v]=d[u]+1,dfs0(v),sz[u]+=sz[v];
}//原树上DP
void dfs1(int u){
    if(bo[u]==1) g[u]=p(0,u);else g[u]=p(INF,0);
    REQ(u) dfs1(v),g[u]=min(g[u],p(g[v].fr+d[v]-d[u],g[v].sc));
}
void dfs2(int u,int D,int x){
    if(p(D,x)<g[u]) g[u]=p(D,x);else D=g[u].fr,x=g[u].sc;
    REQ(u) dfs2(v,D+d[v]-d[u],x);
}//以上是第一阶段DP,求出最近点
void dfs3(int u){
    tn[u]=g[u].sc;
    ans[tn[u]]+=sz[u];
    REQ(u){
        int x=v;
        ROF(j,LG,0) if(f[x][j] && d[f[x][j]]>d[u]) x=f[x][j];
        ans[tn[u]]-=sz[up[v]=x];dfs3(v);
    }
}
void dfs4(int u){
    REQ(u){
        int x=up[v],y=v,H;
        if(tn[u]==tn[v]) ans[tn[u]]+=sz[x]-sz[v];
        else{
            H=d[tn[v]]+d[u]-g[u].fr;
            H=H&1?H+1>>1:(tn[v]<tn[u]?H>>1:(H>>1)+1);
            ROF(j,LG,0) if(f[y][j] && d[f[y][j]]>=H) y=f[y][j];
            ans[tn[v]]+=sz[y]-sz[v];
            ans[tn[u]]+=sz[x]-sz[y];
        }dfs4(v);
    }
}//第二阶段的计算
void dfs5(int u){up[u]=tn[u]=0;REQ(u) dfs5(v);Hd[u]=0;}
int lca(int u,int v){
    if(d[u]<d[v]) swap(u,v);
    ROF(j,LG,0) if(d[f[u][j]]>=d[v] && f[u][j]) u=f[u][j];
    if(u==v) return u;
    ROF(j,LG,0) if(f[u][j]!=f[v][j] && f[u][j]) u=f[u][j],v=f[v][j]; 
    return f[u][0];
}
bool cmp(int x,int y){return df[x]<df[y];}
int main(){
	//freopen("wdt.out","w",stdout);
    scanf("%d",&n);
    FOR(i,1,n-1) scanf("%d%d",&u,&v),add(u,v),add(v,u);
    dfs0(1);
    FOR(j,1,LG)FOR(i,1,n)
        f[i][j]=f[f[i][j-1]][j-1];
    scanf("%d",&T);
    while(T--){
        scanf("%d",&m);
        FOR(i,1,m) scanf("%d",&a[i]),A[i]=a[i],bo[a[i]]=1;
        sort(a+1,a+m+1,cmp);
        s[tp=1]=a[1];
        FOR(i,2,m){
            int x=a[i],y=lca(x,s[tp]);
            while(tp>1 && d[y]<=d[s[tp-1]])
                Add(s[tp-1],s[tp]),tp--;
            if(s[tp]!=y) Add(y,s[tp]),s[tp]=y;
            s[++tp]=x;
        }//五行建虚树
        while(tp>1) Add(s[tp-1],s[tp]),tp--;
        rt=s[1];dfs1(rt);
        dfs2(rt,g[rt].fr,g[rt].sc);
        dfs3(rt);dfs4(rt);
        ans[tn[rt]]+=sz[1]-sz[rt]; 
        FOR(i,1,m) printf("%d ",ans[A[i]]);printf("\n");
        dfs5(rt);
        FOR(i,1,m) bo[a[i]]=ans[a[i]]=0;Fl=0;  
    }
}/*
13
1 7
1 9
9 13
9 4
7 3
7 2
2 8
2 12
12 6
12 11
3 10
3 5
1
8
1 8 6 11 10 5 13 4
*/
```

---

## 作者：tzc_wk (赞：29)

~~虚树的关键不在于你看出它是虚树，而是建完虚树之后怎么搞~~

看到 $\sum m_i\leq 10^5$，果断建出虚树。

然后就不是太会做了/kk

首先本题要计算整棵树中的答案，所以我们尝试把答案拆成 2 部分：

1. 虚树上的点对答案的贡献

   记 $by_x$ 离 $x$ 最近的点的编号。$by_x$ 显然可以通过两遍 dfs 求出（第一遍 dfs 求出 $x$ 子树内的贡献，用儿子更新父亲，第二遍 dfs 求出 $x$ 子树外的贡献，用父亲更新儿子，类似于换根 dp），然后令所有 $by_x$ 加 $1$ 即可。

2. 不在虚树上的点对答案的贡献

   这一部分比较复杂，我们不妨画个图来帮助我们理解。

   ![](https://cdn.luogu.com.cn/upload/image_hosting/h6eswqwc.png)

   如图，蓝色节点为关键点，绿色的边为虚树组成的边。显然，除了节点 $1,2,6,7,8,17,20$ 之外其它节点都不在虚树上。

   我们又可把这些节点分为两类：

   Ⅰ. 虚树上某个节点的儿子的子树（即图中的黄色节点）。假设我们考虑关键节点 $u$ 这部分的贡献，那么这个贡献显然可以表示为 $sz_u-1-\sum\limits_{v\in son_u}sz_v$，也就是整个 $u$ 子树的大小扣掉在虚树上的儿子的子树大小。但是这里我们不能直接枚举虚树上的儿子。比方说我们要计算节点 $2$ 那部分黄色子树的贡献。节点 $2$ 在虚树上的唯一儿子为节点 $6$。而直接拿 $sz_2-1-sz_6$ 显然是不行的，正确的结果应该是 $sz_2-1-sz_3$。故这里我们要减去 $u$ 在 $v$ 方向的**直接儿子**。那么这个直接儿子怎么求呢？借鉴 CF916E 的套路，求出 $v$ 的 $dep_v-dep_u-1$ 级祖先就行了。

   Ⅱ. 虚树上某两个节点 $u,v$ 之间的点及其子树内的节点，（即图中的粉色节点）

   继续分情况：

   ①. $by_u=by_v$，那么显然 $u,v$ 所有节点都属于 $by_v$。找出 $u$ 在 $v$ 方向的直接儿子 $s$，并令 $sz_{by_u}$ 加上 $sz_s-sz_v$

   ②. $by_u\neq by_v$，显然 $by_u$ 与 $by_v$ 分别位于边 $(u,v)$ 的两侧。画张比较清晰的图：

![](https://cdn.luogu.com.cn/upload/image_hosting/meo1ks1p.png)

​			二分枚举断点 $p,q$，$p$ 及上面部分都属于 $by_u$，$q$ 及下面部分都属于 $by_v$。那么这条路径上的点对 $by_u$ 贡献			就是 $sz_s-sz_q$，对 $by_v$ 的贡献就是 $sz_q-sz_v$。

真是道恶心的题啊

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define fz(i,a,b) for(int i=a;i<=b;i++)
#define fd(i,a,b) for(int i=a;i>=b;i--)
#define ffe(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)
#define fill0(a) memset(a,0,sizeof(a))
#define fill1(a) memset(a,-1,sizeof(a))
#define fillbig(a) memset(a,63,sizeof(a))
#define pb push_back
#define ppb pop_back
#define mp make_pair
template<typename T1,typename T2> void chkmin(T1 &x,T2 y){if(x>y) x=y;}
template<typename T1,typename T2> void chkmax(T1 &x,T2 y){if(x<y) x=y;}
typedef pair<int,int> pii;
typedef long long ll;
template<typename T> void read(T &x){
	x=0;char c=getchar();T neg=1;
	while(!isdigit(c)){if(c=='-') neg=-1;c=getchar();}
	while(isdigit(c)) x=x*10+c-'0',c=getchar();
	x*=neg;
}
const int MAXN=3e5;
const int LOG_N=19;
int n,qu;
namespace graph{
	int nxt[MAXN*2+5],to[MAXN*2+5],hd[MAXN+5],ec=0;
	void adde(int u,int v){to[++ec]=v;nxt[ec]=hd[u];hd[u]=ec;}
	int fa[MAXN+5][LOG_N+2],dep[MAXN+5],dfn[MAXN+5],tim=0,sz[MAXN+5];
	void dfs(int x,int f){
		dfn[x]=++tim;fa[x][0]=f;sz[x]=1;
		for(int e=hd[x];e;e=nxt[e]){
			int y=to[e];if(y==f) continue;
			dep[y]=dep[x]+1;dfs(y,x);sz[x]+=sz[y];
		}
	}
	int getlca(int x,int y){
		if(dep[x]<dep[y]) swap(x,y);
		for(int i=LOG_N;~i;i--) if(dep[x]-(1<<i)>=dep[y]) x=fa[x][i];
		if(x==y) return x;
		for(int i=LOG_N;~i;i--) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];
		return fa[x][0];
	}
	int getfa(int x,int k){for(int i=LOG_N;~i;i--) if(k>>i&1) x=fa[x][i];return x;}
	int getdis(int x,int y){return dep[x]+dep[y]-(dep[getlca(x,y)]<<1);}
	void prework(){
		dfs(1,0);
		for(int i=1;i<=LOG_N;i++) for(int j=1;j<=n;j++)
			fa[j][i]=fa[fa[j][i-1]][i-1];
	}
}
using graph::dep;
using graph::sz;
using graph::getlca;
using graph::getfa;
using graph::getdis;
namespace virt{
	bool cmp(int x,int y){return graph::dfn[x]<graph::dfn[y];}
	int hd[MAXN+5],to[MAXN+5],nxt[MAXN+5],cst[MAXN+5],ec=0;
	void adde(int u,int v){to[++ec]=v;cst[ec]=dep[v]-dep[u];nxt[ec]=hd[u];hd[u]=ec;}
	int pt[MAXN+5],pn,ori[MAXN+5];bool mark[MAXN+5];
	int stk[MAXN],tp=0;
	void insert(int x){
		if(!tp){stk[++tp]=x;return;}
		int lc=getlca(x,stk[tp]);
		while(tp>=2&&dep[stk[tp-1]]>dep[lc]) adde(stk[tp-1],stk[tp]),tp--;
		if(tp&&dep[stk[tp]]>dep[lc]) adde(lc,stk[tp--]);
		if(!tp||lc!=stk[tp]) stk[++tp]=lc;stk[++tp]=x;
	}
	void fin(){while(tp>=2) adde(stk[tp-1],stk[tp]),tp--;stk[tp--]=0;}
	void build(){
		sort(pt+1,pt+pn+1,cmp);if(!mark[1]) insert(1);
		for(int i=1;i<=pn;i++) insert(pt[i]);fin();
	}
	int by[MAXN+5],ans[MAXN+5];
	void dfs1(int x){
//		printf("%d\n",x);
		if(!mark[x]) by[x]=-1;
		else by[x]=x;
		for(int e=hd[x];e;e=nxt[e]){
			int y=to[e];dfs1(y);
			if(by[y]!=-1){
				if(by[x]==-1) by[x]=by[y];
				else{
					int d1=getdis(x,by[y]),d2=getdis(x,by[x]);
					if(d1<d2||(d1==d2&&by[x]>by[y])) by[x]=by[y];
				}
			}
		}
	}
	void dfs2(int x){
		for(int e=hd[x];e;e=nxt[e]){
			int y=to[e]; 
			if(by[y]==-1) by[y]=by[x];
			else{
				int d1=getdis(y,by[x]),d2=getdis(y,by[y]);
				if(d1<d2||(d1==d2&&by[y]>by[x])) by[y]=by[x];
			} dfs2(y);
		}
//		printf("%d %d\n",x,by[x]);
	}
	void dfs3(int x){
		ans[by[x]]+=sz[x];
		for(int e=hd[x];e;e=nxt[e]){
			int y=to[e];ans[by[x]]-=sz[getfa(y,dep[y]-dep[x]-1)];
			dfs3(y);
		}
	}
	void dfs4(int x){
		for(int e=hd[x];e;e=nxt[e]){
			int y=to[e];
			if(by[x]==by[y]){
				ans[by[x]]+=sz[getfa(y,dep[y]-dep[x]-1)]-sz[y];
			} else {
				int d1=getdis(x,by[x]),d2=getdis(y,by[y]),len=dep[y]-dep[x]-1;
				int l=0,r=len,p=len+1;
				while(l<=r){
					int mid=(l+r)>>1;
					if((d1+mid<d2+len+1-mid)||(d1+mid==d2+len+1-mid&&by[x]<by[y])) p=mid,l=mid+1;
					else r=mid-1;
				}
//				printf("%d %d %d\n",x,y,p);
				if(p==0) ans[by[y]]+=sz[getfa(y,len)]-sz[y];
				else if(p==len+1) ans[by[x]]+=sz[getfa(y,len)]-sz[y];
				else{
					ans[by[x]]+=sz[getfa(y,len)]-sz[getfa(y,len-p)];
					ans[by[y]]+=sz[getfa(y,len-p)]-sz[y];
				}
			} dfs4(y);
		}
	}
	void clear(int x){
		by[x]=ans[x]=0;
		for(int e=hd[x];e;e=nxt[e]) clear(to[e]),ec--;
		hd[x]=0;
	}
	void work(){
		scanf("%d",&pn);for(int i=1;i<=pn;i++) scanf("%d",&pt[i]),ori[i]=pt[i],mark[pt[i]]=1;
		build();dfs1(1);dfs2(1);dfs3(1);dfs4(1);
		for(int i=1;i<=pn;i++) printf("%d ",ans[ori[i]]);printf("\n");clear(1);
		for(int i=1;i<=pn;i++) mark[pt[i]]=0;
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		int u,v;scanf("%d%d",&u,&v);
		graph::adde(u,v);graph::adde(v,u);
	} graph::prework();scanf("%d",&qu);
	while(qu--) virt::work();
	return 0;
}
/*
7
1 2
2 3
2 4
1 5
4 6
5 7
1
3 2 5 6
*/
```

---

## 作者：C3H5ClO (赞：24)

### UPDATE:修复了题解代码复制错的错误

我来说一个很妙的方法，乱七八糟的细节比较少，DP方程也很简单。

先预处理出每个点深度，子树大小，距离最近的议事处编号及距离，这些东西其他dalao们已经说过了。

把每个议事处看做一种颜色，从虚树根开始DFS，给原树上每个节点染色。

一开始先把所有节点都染成虚树根节点所属议事处的颜色。

DFS时，若一条虚树边上父亲和儿子所属议事处不同，则倍增出原树上两议事处管理区域的分界处（即中点，注意“如果有多个临时议事处到该聚居地的距离一样，取其中编号最小的临时议事处”这个细节），然后把分界处及其子树再染成虚树上当前儿子所属议事处的颜色，最后递归，继续DFS。

这样说大家可能还不明白，我用样例第4个点举个栗子。
## 这是原树，加粗的点为议事处
![](https://cdn.luogu.com.cn/upload/pic/61379.png)
## 一开始用虚树根所属议事处给所有点染色后
![](https://cdn.luogu.com.cn/upload/pic/61380.png)
## 在虚树边1--3上，2号节点由3号管理，2号节点及其子树用3号节点染色后
![](https://cdn.luogu.com.cn/upload/pic/61381.png)
## 7号节点染色后
![](https://cdn.luogu.com.cn/upload/pic/61382.png)
## 8号节点染色后
![](https://cdn.luogu.com.cn/upload/pic/61383.png)

对于每个议事处，记录染成它的颜色的节点的个数，由于每次染色只会覆盖一种颜色（即父亲与儿子所属议事处不同时父亲所属议事处的颜色），因此每次染色时只要被覆盖的颜色的节点个数减掉本次染色节点数，本次染色的颜色的节点个数加上本次染色节点数就可以了。

上个代码，辅助理解。
```cpp
void dfs3(int x)
{
/*
g[x].first表示离最近议事处的距离，second表示最近议事处的编号，
f[i][j]用于倍增，ans[x]表示当前染成x号议事处颜色的点的个数
*/
    int u=g[x].second,v;
    for(ri i=head2[x];i;i=nxt2[i])
    {
        y=to2[i];
        v=g[y].second;
        if(u!=v)
        {
            d=dep[v]-(getdis(u,v)-(u<v))/2;
            for(ri j=LO;j>=0;j--)
                if(dep[f[j][y]]>=d)y=f[j][y];
            ans[u]-=siz[y];
            ans[v]+=siz[y];
        }
        dfs3(to2[i]);
    }
}
```

还是没搞懂就看看完整代码吧。
```cpp
#include<cstdio>
#include<algorithm>
#include<math.h>
using namespace std;
#define ri register int
#define pii pair<int,int>
const int INF=987654321;
int dfin[300005],dfout[300005],dep[300005],siz[300005],f[19][300005],now,len,ans[300005];
int n,x,y,q,m,h[300005],LO,a[300005],b[600005],cnt,sta[300005],top,f1[300005],d,minus[300005];
bool bo[300005];
pii g[300005];
int head[300005],to[600005],nxt[600005],ecnt,head2[300005],to2[600005],nxt2[600005],ecnt2;
void add(int x,int y)
{
    ecnt++;
    to[ecnt]=y;
    nxt[ecnt]=head[x];
    head[x]=ecnt;
}
void add2(int x,int y)
{
    ecnt2++;
    to2[ecnt2]=y;
    nxt2[ecnt2]=head2[x];
    head2[x]=ecnt2;
}
int lca(int x,int y)
{
    if(dep[x]<dep[y])swap(x,y);
    for(ri i=LO;i>=0;i--)
        if(dep[f[i][x]]>=dep[y])x=f[i][x];
    if(x==y)return x;
    for(ri i=LO;i>=0;i--)
        if(f[i][x]!=f[i][y])x=f[i][x],y=f[i][y];
    return f[0][x];
}
int getdis(int x,int y)
{
    return dep[x]+dep[y]-2*dep[lca(x,y)];
}
void dfs0(int x)
{
    siz[x]=1;
    dfin[x]=++now;
    for(ri i=head[x];i;i=nxt[i])
        if(!dfin[to[i]])
        {
            dep[to[i]]=dep[x]+1;
            f[0][to[i]]=x;
            dfs0(to[i]);
            siz[x]+=siz[to[i]];
        }
    dfout[x]=++now;
}
void dfs1(int x)
{
    if(bo[x])g[x]=pii(0,x);
    else g[x]=pii(INF,0);
    for(ri i=head2[x];i;i=nxt2[i])
    {
        dfs1(to2[i]);
        if(g[x]>pii(g[to2[i]].first+dep[to2[i]]-dep[x],g[to2[i]].second))
            g[x]=pii(g[to2[i]].first+dep[to2[i]]-dep[x],g[to2[i]].second);
    }
}
void dfs2(int x)
{
    for(ri i=head2[x];i;i=nxt2[i])
    {
        if(g[to2[i]]>pii(g[x].first+dep[to2[i]]-dep[x],g[x].second))
            g[to2[i]]=pii(g[x].first+dep[to2[i]]-dep[x],g[x].second);
        dfs2(to2[i]);
    }
}/*
void dfs3(int x)
{
    if(x==b[1])minus[x]-=siz[1]-siz[b[1]];
    for(ri i=head2[x];i;i=nxt2[i])
    {
        dfs3(to2[i]);
        if(g[to2[i]].second!=g[x].second)minus[x]+=siz[to2[i]];
        else minus[x]+=minus[to2[i]];
    }
    ans[g[x].second]=siz[x]-minus[x];
}*/
void dfs4(int x)
{
    int u=g[x].second,v;
    for(ri i=head2[x];i;i=nxt2[i])
    {
        y=to2[i];
        v=g[y].second;
        if(u!=v)
        {
            d=dep[v]-(getdis(u,v)-(u<v))/2;
            for(ri j=LO;j>=0;j--)
                if(dep[f[j][y]]>=d)y=f[j][y];
            ans[u]-=siz[y];
            ans[v]+=siz[y];
        }
        dfs4(to2[i]);
    }
}
void dfs5(int x)
{
    for(ri i=head2[x];i;i=nxt2[i])dfs5(to2[i]);
    minus[x]=ans[x]=head2[x]=bo[x]=0;
}
bool cmp1(int x,int y)
{
    return dfin[x]<dfin[y];
}
bool cmp2(int x,int y)
{
    return (x>0?dfin[x]:dfout[-x])<(y>0?dfin[y]:dfout[-y]);
}
int main()
{
    scanf("%d",&n);
    LO=floor(log2(n-1));
    for(ri i=1;i<n;i++)
    {
        scanf("%d%d",&x,&y);
        add(x,y);
        add(y,x);
    }
    dep[1]=1;
    dfs0(1);
    for(ri i=1;i<=LO;i++)
        for(ri j=1;j<=n;j++)
            f[i][j]=f[i-1][f[i-1][j]];
    scanf("%d",&q);
    for(ri i=1;i<=q;i++)
    {
        scanf("%d",&m);
        for(ri j=1;j<=m;j++)
        {
            scanf("%d",h+j);
            bo[h[j]]=1;
            a[j]=h[j];
        }
        sort(a+1,a+m+1,cmp1);
        cnt=0;
        b[++cnt]=a[1];
        b[++cnt]=-a[1];
        for(ri j=2;j<=m;j++)
        {
            x=lca(a[j-1],a[j]);
            b[++cnt]=x;
            b[++cnt]=-x;
            b[++cnt]=a[j];
            b[++cnt]=-a[j];
        }
        sort(b+1,b+cnt+1,cmp2);
        len=0;
        for(ri j=1;j<=cnt;j++)
            if(b[j]!=b[j-1])b[++len]=b[j];
        for(ri j=1;j<=len;j++)
        {
            if(b[j]>0)sta[++top]=b[j];
            else add2(sta[top-1],sta[top]),top--;
        }
        dfs1(b[1]);
        dfs2(b[1]);
        //dfs3(b[1]);
        ans[g[b[1]].second]=siz[1];
        //for(ri j=1;j<=n;j++)printf("%d ",ans[j]); putchar('\n');
        dfs4(b[1]);
        for(ri j=1;j<=m;j++)printf("%d ",ans[h[j]]); putchar('\n');
        dfs5(b[1]);
    }
}
```

---

## 作者：Kelin (赞：20)

题意:标记一些树上的点,每个点会被最近(编号最小)的标记点控制,问每个标记点会控制多少点

根据套路先搞出虚树,然后考虑怎么$DP$

首先两遍$dfs$求出虚树上每个点被那个点控制

第一遍是$dfs$求最近的儿子,第二遍是考虑每个点父亲对其他儿子的贡献

所以第一遍要先$dfs$儿子,第二遍要后$dfs$儿子

然后对于虚树上每一条边

①:两端点被同一个点控制,直接把这两个端点所属的点的贡献加上这两个点不在虚树中的儿子的$sz$

②:两端点被不同点控制,那么中间一定有一个分界点,使得分界点上面的点的$sz$属于上端点,下面属于下端点

这个分界点可以通过倍增求得,注意计算答案要把两端点的贡献去掉(开区间)

考虑怎么计算每个点$u$不在虚树中的儿子的$sz$,记他是$sur[u](Surplus)$,一开始等于$sz[u]$

对于虚树上$(u,v)$这条边,倍增求出$(u,v)$上原树中离$u$最近的点$s$

$sur[u]$减去所有的这样的$sz[s]$就是点$u$不在虚树中的儿子的$sz$

$dp$完后每个点所属的点加上再这个点的剩余量就是答案了
```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
using namespace std;
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){return A==B&&(B=(A=ss)+fread(ss,1,1<<17,stdin),A==B)?-1:*A++;}
template<class T>inline void sd(T&x){
    char c;T y=1;while(c=gc(),(c<48||57<c)&&c!=-1)if(c==45)y=-1;x=c-48;
    while(c=gc(),47<c&&c<58)x=x*10+c-48;x*=y;
}
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
template<class T>inline void we(T x){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]=' ';
}
const int N=3e5+5,M=19,inf=1e9;
typedef int arr[N];
struct eg{int nx,to;}e[N<<1];
int n,m,k,ce,dft,fa[N][M];arr a,b,bl,fi,fg,sz,son,top,dep,Log,dfn,sur,ans,S;
void dfs(int u){
    dep[u]=dep[fa[u][0]]+(sz[u]=1);dfn[u]=++dft;
    for(int i=0;fa[u][i];++i)fa[u][i+1]=fa[fa[u][i]][i];
    go(u)if(v^fa[u][0]){
        fa[v][0]=u,dfs(v),sz[u]+=sz[v];
        if(sz[v]>sz[son[u]])son[u]=v;
    }
}
void dfs(int u,int t){
    top[u]=t;if(son[u])dfs(son[u],t);
    go(u)if(v^fa[u][0]&&v^son[u])dfs(v,v);
}
inline int lca(int u,int v){
    for(;top[u]^top[v];dep[top[u]]>dep[top[v]]?u=fa[top[u]][0]:v=fa[top[v]][0]);
    return dep[u]<dep[v]?u:v;
}
inline int dis(int u,int v){return dep[u]+dep[v]-2*dep[lca(u,v)];}
inline void add(int u,int v){e[++ce]={fi[u],v},fi[u]=ce;}
void dfs1(int u){int d1,d2;
    bl[u]=fg[u]?u:0;sur[u]=sz[u];
    go(u){
        dfs1(v);
        d1=dep[bl[v]]-dep[u],d2=bl[u]?dep[bl[u]]-dep[u]:inf;
        if(d1<d2||(d1==d2&&bl[v]<bl[u]))bl[u]=bl[v];
    }
}
void dfs2(int u){int d1,d2;
    go(u){
        d1=dis(bl[u],v),d2=dis(bl[v],v);
        if(d1<d2||(d1==d2&&bl[u]<bl[v]))bl[v]=bl[u];
        dfs2(v);
    }
}
void dp(int u){int s,mid,nt,d1,d2;
    go(u){
        dp(v);s=mid=v;
        fd(i,Log[dep[v]],0)if(dep[fa[s][i]]>dep[u])s=fa[s][i];
        sur[u]-=sz[s];
        if(bl[u]==bl[v]){ans[bl[u]]+=sz[s]-sz[v];continue;};
        fd(i,Log[dep[v]],0){
            nt=fa[mid][i];if(dep[nt]<=dep[u])continue;
            d1=dis(nt,bl[v]),d2=dis(nt,bl[u]);
            if(d1<d2||(d1==d2&&bl[v]<bl[u]))mid=nt;
        }
        ans[bl[u]]+=sz[s]-sz[mid];
        ans[bl[v]]+=sz[mid]-sz[v];
    }ans[bl[u]]+=sur[u];fi[u]=0;
}
inline bool cmp(const int&a,const int&b){return dfn[a]<dfn[b];}
inline void sol(){
    sd(k);fp(i,1,k)sd(a[i]),b[i]=a[i],fg[a[i]]=1;
    sort(a+1,a+k+1,cmp);static int top=1;S[1]=1;ce=0;
    fp(i,1,k){
        int x=a[i],p=lca(S[top],x);
        while(dep[p]<dep[S[top]]){
            if(dep[p]>=dep[S[top-1]]){
                add(p,S[top--]);
                if(S[top]^p)S[++top]=p;
                break;
            }add(S[top-1],S[top]),--top;
        }if(S[top]^x)S[++top]=x;
    }while(top>1)add(S[top-1],S[top]),--top;
    dfs1(1),dfs2(1);dp(1);
    fp(i,1,k)we(ans[b[i]]),fg[b[i]]=ans[b[i]]=0;sr[++C]='\n';
}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    sd(n);int u,v;fp(i,2,n)Log[i]=Log[i>>1]+1;
    fp(i,2,n)sd(u),sd(v),add(u,v),add(v,u);
    dfs(1),dfs(1,1);sd(m);
    memset(fi,0,sizeof fi);while(m--)sol();
return Ot(),0;
}
```

---

## 作者：mts_246 (赞：17)

###  调了一个下午，终于过了，于是来发本人的第一篇题解==  


------------

一道不错的虚树练手题，就是细节太多了;

对于每次询问：

首先对于关键点构建出虚树，边权为两端的深度差。为了统计答案，我们需要求出以下数组：



 _bel[x]_ 为x点受哪个节点的控制

 _dis[x]_ 表示x和 _bel[x]_ 的距离
 
 

对于询问点（关键点）， _bel[]_ 显然是本身，然后对于不在询问里的点（非关键点），我们需要进行**两遍**dfs来求，**先求出儿子对父亲的影响，再求父亲对儿子的影响**。因为存在关键点控制其兄弟节点的情况！

然后考虑如何统计答案。我们分开考虑每个点对于所在集合的贡献，记 _si[x]_ 为x控制的数量，初值赋成原树上的子树 _size_ 就行,用 _si[x]_ 减去虚树儿子的 _si[]_ (包括儿子的儿子），加上向上能控制的节点数就是对 _bel[x]_ 的贡献。

对于树上的链：

1. 两端在同一集合：我们让父亲控制链上的所有点，所以 _si[fa]-=siz[son]_ ;
1. 两端不在同一集合：那么脸上一定存在一个分界点，以上属于父亲，以下属于儿子。注意这里的链在原树中可能接着许多其他子树，因此我们要倍增求（我一开始还天真地直接求--结果被虐惨了）**注意这里的各种细节，一定捋清了，在这wa了好多遍**。将新贡献加到儿子的_si[]_，然后把儿子的总贡献在父亲里减去就行了。

最后注意下数组清零，这题就过了

```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<iostream>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
#include<map>
#include<string>
#include<cstdlib>
#define N 300002
#define ll long long
using namespace std;
int read()
{
    int x=0,f=1;
    char c=getchar(); 
    while(c>'9'||c<'0')
    {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(c<='9'&&c>='0')
    {
        x=x*10+c-'0';
        c=getchar();
    }
    return x*f;
}
bool cl[N];
int n,Size,size,Head[N],head[N],f[N][22],q,fa[N],k,cnt,dfn[N],dis[N],tt[N],num,siz[N],bel[N],dep[N],st[N],top,as[N],si[N],sum;
struct Node{
    int next,to,vlu;
}Mem[N*2];
struct node{
    int next,to,vlu;
}mem[N*2];
inline void add(int u,int v,int w)
{
    mem[++size].to=v;mem[size].next=head[u];head[u]=size;mem[size].vlu=w;
}
inline void Add(int u,int v,int w)
{
    Mem[++Size].to=v;Mem[Size].next=Head[u];Head[u]=Size;Mem[Size].vlu=w;
}
void dfs(int x)
{
    dep[x]=dep[fa[x]]+1;
    siz[x]=1;
    dfn[x]=++cnt;
    for(int i=Head[x];i;i=Mem[i].next)
    {
        int v=Mem[i].to;
        if(v==fa[x]) continue;
        f[v][0]=x;
        fa[v]=x;
        dfs(v);siz[x]+=siz[v];
    }
}
int get_lca(int a,int b)
{
    if(dep[a]<dep[b]) swap(a,b);
    for(int i=20;i>=0;--i) if(dep[f[a][i]]>=dep[b]) a=f[a][i];
    if(a==b) return a;
    for(int i=20;i>=0;--i) if(f[a][i]!=f[b][i]) a=f[a][i],b=f[b][i];
    return fa[b];
}
struct snode{
    int x,id;
}a[N];
bool cmp(snode a,snode b){return dfn[a.x]<dfn[b.x];};
bool cmp2(snode a,snode b){return a.id<b.id;}
void build()//建虚树 
{
    sort(a+1,a+1+k,cmp);
    st[top=1]=1;
    for(int i=1;i<=k;++i) 
    {
        int x=a[i].x;
        if(x==1) continue;
        int lca=get_lca(st[top],x);
        while(top>1&&dep[st[top-1]]>dep[lca])
        {
            int dis=dep[st[top]]-dep[st[top-1]];
            add(st[top],st[top-1],dis);add(st[top-1],st[top],dis);
            --top;
        }
        if(dep[lca]<dep[st[top]])
        {
            int dis=dep[st[top]]-dep[lca];
            add(st[top],lca,dis);add(lca,st[top],dis);
            --top;
        }
        if(dep[lca]>dep[st[top]]) st[++top]=lca;
        st[++top]=x;
    }
    while(top>1)
    {
        int dis=dep[st[top]]-dep[st[top-1]];
        add(st[top],st[top-1],dis);add(st[top-1],st[top],dis);
        --top;
    }
}
void calc1(int x,int fa)
{
    tt[++num]=x;
    si[x]=siz[x];
    if(cl[x])
    {
        dis[x]=0;bel[x]=x;
    }
    else dis[x]=1e9;
    for(int i=head[x];i;i=mem[i].next)
    {
        int v=mem[i].to;
        if(v==fa) continue;
        calc1(v,x);
        if(dis[x]>dis[v]+mem[i].vlu||dis[x]==dis[v]+mem[i].vlu&&bel[x]>bel[v])
        {
            dis[x]=dis[v]+mem[i].vlu;
            bel[x]=bel[v];
        }
    }
}
int jup(int x,int k)
{
    if(dep[x]<k) return x;
	for(int i=20;i>=0;--i)   if(dep[f[x][i]]>=k) x=f[x][i];
    return x;
}
void calc2(int x,int faa)
{
    for(int i=head[x];i;i=mem[i].next)
    {
        int v=mem[i].to;
        if(v==faa) continue;
        if(dis[x]+mem[i].vlu<dis[v]||dis[x]+mem[i].vlu==dis[v]&&bel[x]<bel[v]) dis[v]=dis[x]+mem[i].vlu,bel[v]=bel[x];
        calc2(v,x);
        if(bel[v]==bel[x]) si[x]-=siz[v];
        else
        {
            int d=dis[v]+dis[x]+dep[v]-dep[x]-1,k;
            k=d/2-dis[v];//注意k是负数的情况！！！！ 
            int tmp=jup(v,dep[v]-k);
            if((d&1)&&bel[x]>bel[v]&&k>=0) tmp=fa[tmp];
            si[v]+=siz[tmp]-siz[v];
            si[x]-=siz[tmp];
        }
        as[bel[v]]+=si[v];
    }
    if(x==1) as[bel[x]]+=si[x];
}
int main()
{
    n=read();
    for(int i=1;i<n;++i)
    {
        int x=read(),y=read();
        Add(x,y,1);Add(y,x,1);
    }
    dfs(1);
    for(int i=1;i<=20;++i)
        for(int j=1;j<=n;++j)
            f[j][i]=f[f[j][i-1]][i-1];
    q=read();
    while(q--)
    {
		k=read();
        for(int i=1;i<=k;++i) 
        {
            a[i].x=read();a[i].id=i;
            cl[a[i].x]=1;
        }
        build();
        calc1(1,0);calc2(1,0);
        sort(a+1,a+1+k,cmp2);
        for(int i=1;i<=k;++i) printf("%d ",as[a[i].x]);
        printf("\n");
        size=0;
        for(int i=1;i<=num;++i)  head[tt[i]]=as[tt[i]]=si[tt[i]]=bel[tt[i]]=dis[tt[i]]=cl[tt[i]]=0;//注意清空 
        num=0;
    }
    return 0;
}
```





---

## 作者：GoldenPotato137 (赞：9)

[戳我获得更好的阅读体验qwq](https://www.goldenpotato.cn/动态规划/luogu-p3233-hnoi2014世界树/)

---
# Solution
这是一道虚树妙题。

.

我们不妨先考虑一下每一次$O(n)$计算的暴力怎么做。

$O(n\cdot m)$的暴力肥肠简单，我们只需要做两遍dfs。**考虑设$f[i]$表示离$i$最近的聚居地是什么，$MIN[i]$表示$i$到最近的聚居地的距离。我们第一遍dfs先找出$i$到它子树内的聚居地的最小距离，之后再做一遍dfs来找$i$往祖先方向后头走能走到的最近聚居地的距离即可。**

.

观察数据范围后发现，$\sum m<=300000$，因此考虑使用**虚树**。

建出来虚树之后，显然对于在虚树上的点，我们还是能直接暴力做，问题是怎么处理非虚树上的点。

我们会发现，**我们虚树上的一条边在原树种对应一条链(包括链上的子树)。**我们会发现，**这条链上的点上一定是上半部分的最近距离在上面那个点，下半部分的最近距离在下面那个点。**因此，我们考虑用倍增的思想来找出这个“分界点”，找到后计算一下上下分别贡献即可。

这里有个小细节，我们是在原树上做倍增的，因此**我们倍增过程中不应该使用跟DP有关的量**，这里理论上我们只需要使用上端点与下端点的$f,MIN$，以及每个点的深度，$fa$即可实现这个倍增。

.

时间复杂度$O(mlogn)$

就酱，我们就把这题切掉啦(*≧▽≦)

---
# Code
**本题细节较多，请各位dalao小心慢行**

~~直接两行泪就完事了~~

**数据生成器**

[在这里](https://www.goldenpotato.cn/动态规划/luogu-p3233-hnoi2014世界树/)

**正解**
```cpp
//Luogu P3233 [HNOI2014]世界树
//Apr,1st,2019
//虚树+DP+倍增神题
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
long long read()
{
	long long x=0,f=1; char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-'0';c=getchar();}
	return x*f;
}
const int N=300000+1000;
vector <int> e[N],e2[N];
int n,q,a[N],b[N];
int dfn[N],dfn_to,depth[N],fa[N][21],size[N];
void dfs(int now)
{
	dfn[now]=++dfn_to;
	size[now]=1;
	for(int i=1;i<=20;i++)
		fa[now][i]=fa[fa[now][i-1]][i-1];
	for(int i=0;i<int(e[now].size());i++)
		if(dfn[e[now][i]]==0)
		{
			depth[e[now][i]]=depth[now]+1;
			fa[e[now][i]][0]=now;
			dfs(e[now][i]);
			size[now]+=size[e[now][i]];
		}
}
int LCA(int x,int y)
{
	if(depth[x]<depth[y]) swap(x,y);
	for(int i=20;i>=0;i--)
		if(depth[x]-(1<<i)>=depth[y])
			x=fa[x][i];
	if(x==y) return x;
	for(int i=20;i>=0;i--)
		if(fa[x][i]!=fa[y][i])
			x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}
int cmp(int x,int y)
{
	return dfn[x]<dfn[y];
}
bool sp[N];
int MIN[N],f[N],ans[N];
inline int GetDis(int x,int y)
{
	if(depth[x]<depth[y]) swap(x,y);
	return depth[x]-depth[y];
}
void dfs2(int now)
{
	if(sp[now]==true) 
		f[now]=now,MIN[now]=0;
	for(int i=0;i<int(e2[now].size());i++)
	{
		dfs2(e2[now][i]);
		if(MIN[e2[now][i]]+GetDis(e2[now][i],now) < MIN[now] 
		or (MIN[e2[now][i]]+GetDis(e2[now][i],now)==MIN[now] and f[now]>f[e2[now][i]]))
			f[now]=f[e2[now][i]],MIN[now]=MIN[e2[now][i]]+GetDis(e2[now][i],now);
	}
}
void dfs3(int now,int fa) 
{
	if(fa!=0)
	{
		if(MIN[fa]+GetDis(fa,now) < MIN[now] 
		or (MIN[fa]+GetDis(fa,now)==MIN[now] and f[now]>f[fa]))
			f[now]=f[fa],MIN[now]=MIN[fa]+GetDis(fa,now);
	}
	ans[f[now]]++;
	for(int i=0;i<int(e2[now].size());i++)
		dfs3(e2[now][i],now);
}
void GetSum(int x,int y,int &sum_x,int &sum_y)
{
	bool IsSwap=false;
	if(depth[x]<depth[y]) IsSwap=true,swap(x,y);
	int sx=x,dis_x=MIN[x];
	for(int i=20;i>=0;i--)
		if(dis_x+(1<<i) < MIN[y]+depth[x]-depth[y]-(1<<i))
			f[fa[x][i]]=f[x],
			x=fa[x][i],dis_x+=(1<<i);
	if(dis_x+1==MIN[y]+depth[x]-depth[y]-1 and f[x]<f[y])
		x=fa[x][0];
	sum_x=size[x]-size[sx];
	for(int i=20;i>=0;i--)
		if(depth[sx]-(1<<i)>depth[y])
			sx=fa[sx][i];
	sum_y=size[sx]-size[x];
	if(IsSwap==true)
		swap(sum_x,sum_y);
}
void dfs4(int now)
{
	int tmp=size[now]-1;
	for(int i=0;i<int(e2[now].size());i++)
	{
		int sum1,sum2;
		GetSum(now,e2[now][i],sum1,sum2);
		ans[f[now]]+=sum1,ans[f[e2[now][i]]]+=sum2;
		tmp-=(size[e2[now][i]]+sum1+sum2);
		dfs4(e2[now][i]);
	}
	ans[f[now]]+=tmp;
}
int main()
{
	freopen("3233.in","r",stdin);
	freopen("3233.out","w",stdout);
	
	n=read();
	for(int i=1;i<n;i++)
	{
		int s=read(),t=read();
		e[s].push_back(t);
		e[t].push_back(s);
	}
	
	fa[1][0]=1;
	dfs(1);
	
	q=read();
	for(int i=1;i<=q;i++)
	{
		int m=read();
		for(int j=1;j<=m;j++)
			b[j]=a[j]=read();
		
		sort(a+1,a+1+m,cmp);
		static int mstack[N],top,rec[N],cnt;
		cnt=0;
		mstack[top=1]=1;
		for(int j=(a[1]==1?2:1);j<=m;j++)
		{
			while(LCA(mstack[top],a[j])!=mstack[top])
			{
				int lca=LCA(mstack[top],a[j]);
				if(depth[lca]>depth[mstack[top-1]])
				{
					e2[lca].push_back(mstack[top]);
					rec[++cnt]=mstack[top],mstack[top]=lca;
				}
				else
				{
					e2[mstack[top-1]].push_back(mstack[top]);
					rec[++cnt]=mstack[top--];
				}
			}
			mstack[++top]=a[j];
		}
		while(top>1)
		{
			e2[mstack[top-1]].push_back(mstack[top]);
			rec[++cnt]=mstack[top--];
		}
		rec[++cnt]=1;
		
		for(int j=1;j<=m;j++)
			sp[a[j]]=true;
		for(int j=1;j<=cnt;j++)
			MIN[rec[j]]=0x3f3f3f3f,ans[rec[j]]=0;
		dfs2(1); 
		dfs3(1,0);
		dfs4(1);
		for(int j=1;j<=m;j++)
			printf("%d ",ans[b[j]]);
		printf("\n");
		
		for(int j=1;j<=m;j++)
			sp[a[j]]=false;
		for(int j=1;j<=cnt;j++)
			e2[rec[j]].clear(),ans[rec[j]]=0;
	}
	return 0;
}

```






---

## 作者：kczno1 (赞：7)

虚树+比较麻烦的dp


一个点x拥有的点:sz[x]-sz[儿子]


x,f[x] 分界点p(p上面的属于f[x])

则f[x]拥有的点:sz[p方向上的儿子]-sz[p]

x拥有的点:sz[p]-sz[x]


p与x的dis


dis+dis[x]=(dis(f[x],x)-dis)+dis[y]

dis=(dis(f[x],x)-dis[x]+dis[y])/2

dp时,每个点记录near[i] 最近点,dis[i] 与其距离


```cpp
#include<cstdio>
#include<algorithm>
using namespace std;

#define N 300100
int t[N];
struct edge
{
    int to,next;
}l[2000000];int e;
void add_e(int x,int y)
{
    l[++e]=(edge){y,t[x]};t[x]=e;
}

struct tree
{
    int f[20],dep,sz,dfn;
}T[N];int tot;

void dfs(int x,int f,int dep)
{
    T[x].sz=1;T[x].dep=dep;
    T[x].f[0]=f;
    T[x].dfn=++tot;
    int i,y;
    for (i=0,y=f;y=T[y].f[i];T[x].f[++i]=y);
    
    ++dep;
    for (i=t[x];i;i=l[i].next)
    if ((y=l[i].to)!=f)
    {
      dfs(y,x,dep);
      T[x].sz+=T[y].sz; 
    }
}

int jump(int x,int l)
{
    for (int i=0;l;++i,l>>=1)
    if (l&1) x=T[x].f[i];
    return x;
}

int get_lca(int x,int y)
{
    if (T[x].dep<T[y].dep) swap(x,y);
    x=jump(x,T[x].dep-T[y].dep);
    if (x==y) return x;
    for (int i=19;i>=0;--i)
    if (T[x].f[i]!=T[y].f[i])
    {
        x=T[x].f[i];y=T[y].f[i];
    }
    return T[x].f[0];
} 

bool dfn_xiao(int x,int y)
{
    return T[x].dfn<T[y].dfn;
}
int i,x,y;
int q0[N],q[N],num0,num;
int st[N],top;
struct xutree
{
    int f;
    bool d;
}_T[N];
int near[N],dis[N],sz[N];
void build()
{
    sort(q+1,q+num+1,dfn_xiao);
    st[top=1]=q[1];
    _T[q[1]]=(xutree){0,1};
    for (i=2;i<=num0;++i)
    {
        x=q[i];
        int lca=get_lca(y=st[top],x);
        if (lca!=y)
        {
          while (T[lca].dep<T[st[top]].dep) y=st[top--];
          if (st[top]!=lca)
          {
            _T[y].f=lca;
            _T[lca]=(xutree){st[top],0};
            st[++top]=lca;q[++num]=lca;
          }
        }
        _T[x]=(xutree){st[top],1};st[++top]=x;
    }
    sort(q+1,q+num+1,dfn_xiao);
}

void upd(int _dis,int _near,int y)
{
    if (_dis<dis[y]||_dis==dis[y]&&_near<near[y])
    {
        dis[y]=_dis;near[y]=_near; 
    }
}

int n;
int ans[N];
void dp()
{
    int _dis;
    for (i=1;i<=num;++i) 
    {
        x=q[i];
        sz[x]=T[x].sz;
        if (_T[x].d) {near[x]=x;dis[x]=0;}
        else dis[x]=1<<30;  
    }
    for (i=num;i>1;--i)
    {
        x=q[i];y=_T[x].f;
        _dis=dis[x]+T[x].dep-T[y].dep;
        upd(_dis,near[x],y);
    }
    for (i=2;i<=num;++i)
    {
        x=q[i];y=_T[x].f;
        _dis=dis[y]+T[x].dep-T[y].dep;
        upd(_dis,near[y],x);
    }
    
    int k;
    for (i=num;i>1;--i)
    {
        x=q[i];y=_T[x].f;
        k=jump(x,T[x].dep-T[y].dep-1);
        sz[y]-=T[k].sz;
    }
    
    x=q[1];
    ans[near[x]]=sz[x]+n-T[x].sz;
    for (i=2;i<=num;++i)
    {
        x=q[i];
        ans[near[x]]+=sz[x];
        y=_T[x].f;k=jump(x,T[x].dep-T[y].dep-1);
        if (near[y]==near[x]) ans[near[x]]+=T[k].sz-T[x].sz;
        else
        {
            _dis=T[x].dep-T[y].dep-dis[x]+dis[y];
            if (_dis&1) _dis>>=1; else
            if (near[x]<near[y]) _dis>>=1;
            else (_dis>>=1)-=1;
            
            int p=jump(x,_dis);
            ans[near[x]]+=T[p].sz-T[x].sz;
            ans[near[y]]+=T[k].sz-T[p].sz; 
        }
    }
}

int main()
{
    freopen("1.in","r",stdin);
    
    scanf("%d",&n);
    for (i=1;i<n;++i) 
    {scanf("%d%d",&x,&y);
     add_e(x,y);add_e(y,x);
    }
    
    dfs(1,0,1);
    
    int m;
    scanf("%d",&m); 
    while (m--)
    {
        scanf("%d",&num);num0=num;
        for (i=1;i<=num;++i) {scanf("%d",q+i);q0[i]=q[i];}
        build();
        dp();
        for (i=1;i<=num0;++i) {printf("%d ",ans[q0[i]]);ans[q0[i]]=0;}
        printf("\n");
    }
}
```

---

## 作者：Qiiiiiii_ (赞：5)

本题要建虚树是显然的，建虚树复杂度是 $O(n)$ (因为 $n$ 和 $\sum m$ 同级，所以以下全部用 $n$ 代替)。考虑我们建完虚树之后如何 $dp$ 。至于不会如何建虚树的，建议做一下这题 [[SDOI2011]消耗战](https://www.luogu.com.cn/problem/P2495)

首先求出每个虚树上的点被哪些点控制，这里我们使用两次 $dfs$ ，一次求子树(虚树子树)内的贡献，此次为自下而上更新，第二次求子树外对自己的贡献，此次为自上而下更新。这两步操作是 $o(n)$的。

处理完了虚树上的点，接下来考虑虚树边上的点(包括虚边在实树里对于一段路径及其分支构成的树)的贡献：当虚边两端点被相同的关键点控制，即虚边全部归同一个关键点控制，倍增到上端点下端的第一个实点求这一段构成的树上的节点数；当虚边两端点被不同的关键点控制，那必然存在一个分界点，分界点上端归上端点的控制点控制，下端归下端点的控制点控制，这里通过倍增找分界点。这一步复杂度是 $O(nlogn)$ 。

最后，就是那些即不在边上也不在虚树上的点。我们考虑这些点在哪些虚树上点的子树中(建虚树的时候加入 $1$ 号节点，保证所有节点都被存在于虚树上一个节点的子树中)，对于虚树上一个点，我们把它子树中存在于虚树中的节点(或虚边上的点)全部减去，剩下的就是那些最终需要统计的贡献。这一步的时间复杂度 $O(nlogn)$ 。

总时间复杂度 $O(nlogn)$ 。

```cpp
#include<bits/stdc++.h>
#define re register
#define ll long long
#define LL inline ll
#define I inline int
#define V inline void
#define B inline bool
#define FOR(i,a,b) for(re int i=(a),i##i=(b);i<=i##i;++i)
#define ROF(i,a,b) for(re int i=(a),i##i=(b);i>=i##i;--i)
#define REP(i,u) for(re int i=hd[u],v=ed[i].to;i;i=ed[i].nx,v=ed[i].to)
//#define gc getchar()
#define gc (fs==ft&&(ft=(fs=buf)+fread(buf,1,1<<18,stdin),ft==fs))?0:*fs++
#define fs first
#define sc second
using namespace std;
char *fs,*ft,buf[1<<18];
const int N=3e5+10,inf=1e9+7;
LL read(){
	ll p=0; bool w=0; char ch=gc;
	while(!isdigit(ch)) w=ch=='-'?1:0,ch=gc;
	while(isdigit(ch)) p=p*10+ch-'0',ch=gc;
	return w?-p:p;
}
struct ao{
	int nx,to;
}ed[N];
struct in{
	int w,id;
}a[N];
vector<int>tr[N];
int n,q,m,fl,id;
int ans[N],as[N];
int dfn[N],vis[N],siz[N],hd[N],fa[N][21],dep[N],s[N],tp;
V add(int u,int v){ ed[++fl]=(ao){hd[u],v},hd[u]=fl;}
V dfs1(int u){
	dfn[u]=++id,siz[u]=1;
	int z=tr[u].size(),v=0;
	FOR(i,0,z-1){
		v=tr[u][i];
		if(v==fa[u][0]) continue;
		fa[v][0]=u,dep[v]=dep[u]+1;
		dfs1(v),siz[u]+=siz[v];
	}
	return ;
}
I lca(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	ROF(k,18,0) if(dep[fa[x][k]]>=dep[y]&&fa[x][k]) x=fa[x][k];
	if(x==y) return x;
  	ROF(k,18,0) if(fa[x][k]!=fa[y][k]&&fa[x][k]) x=fa[x][k],y=fa[y][k];
    return fa[x][0];
}
typedef pair<int,int> PI;
PI f[N];
int ff[N],sz[N];
V dfs2(int u){
	if(vis[u]) f[u]=make_pair(0,u);
	PI tmp;
	REP(i,u) dfs2(v),tmp=f[v],tmp.fs+=dep[v]-dep[u],f[u]=min(f[u],tmp);
	return ;
} 
V dfs3(int u,int dis,int p){
	if(make_pair(dis,p)<f[u]) f[u]=make_pair(dis,p);
	else dis=f[u].fs,p=f[u].sc;
	REP(i,u) dfs3(v,dis+dep[v]-dep[u],p);
}
I get(int u){
	int x=u;
	ROF(k,18,0) if(dep[fa[x][k]]>dep[ff[u]]&&fa[x][k]) x=fa[x][k];
	return x;
}
V dfs4(int u){
	int x=u;
	REP(i,u) dfs4(v);
	if(fl&&ff[u]) x=get(u),sz[ff[u]]+=siz[x];
	return ;
}
V dfs5(int u){
	ans[f[u].sc]+=siz[u]-sz[u];
	REP(i,u) dfs5(v);
}
V dfs6(int u){
	int x,y;
	PI tmp1,tmp2;
	REP(i,u){
		if(f[u]==f[v]) x=get(v),ans[f[u].sc]+=siz[x]-siz[v];
		else{
			x=v;
			ROF(k,18,0){
				if(dep[fa[x][k]]<dep[u]||!fa[x][k]) continue;
				tmp1=f[v],tmp1.fs+=dep[v]-dep[fa[x][k]];
				tmp2=f[u],tmp2.fs+=dep[fa[x][k]]-dep[u];
				if(tmp1<tmp2) x=fa[x][k];
			}
			y=get(v);
			ans[f[u].sc]+=siz[y]-siz[x];
			ans[f[v].sc]+=siz[x]-siz[v];
		}
		dfs6(v);
	}
	return ;
}
B cmp(in x,in y){ return dfn[x.w]<dfn[y.w];}
int sck[N],cnt;
int main(){
	int x,y;
	n=read();
	FOR(i,2,n)	x=read(),y=read(),\
				tr[x].push_back(y),\
				tr[y].push_back(x);
	dfs1(1);
	FOR(k,1,18) FOR(i,1,n) fa[i][k]=fa[fa[i][k-1]][k-1];
	q=read();
	FOR(i,1,n) f[i]=make_pair(inf,inf);
	FOR(i,1,q){
		m=read();
		FOR(j,1,m) a[j].w=read(),vis[a[j].w]=1,a[j].id=j;
		sort(a+1,a+1+m,cmp);
		s[tp=1]=1,sck[cnt=1]=1,fl=0;
		FOR(j,1,m){
			int x=a[j].w,y=lca(x,s[tp]);
			if(x==1) continue;
			sck[++cnt]=x,sck[++cnt]=y;
			while(tp>1&&dep[s[tp-1]]>=dep[y]) 
			add(s[tp-1],s[tp]),ff[s[tp]]=s[tp-1],--tp;
			if(s[tp]!=y) add(y,s[tp]),ff[s[tp]]=y,s[tp]=y;
			s[++tp]=x;
		}
		while(tp>1) add(s[tp-1],s[tp]),ff[s[tp]]=s[tp-1],--tp;
		dfs2(1);
		dfs3(1,f[1].fs,f[1].sc);
		dfs4(1);
		dfs5(1);
		dfs6(1);
		FOR(j,1,m) as[a[j].id]=ans[a[j].w];
		FOR(j,1,m) printf("%d ",as[j]);
		printf("\n");
		FOR(j,1,cnt)	vis[sck[j]]=hd[sck[j]]=0,\
						sz[sck[j]]=ans[sck[j]]=ff[sck[j]]=0,\
						f[sck[j]]=make_pair(inf,inf);
		sz[0]=0;
	}
	return 0;
}
}
```


---

## 作者：Nemlit (赞：3)

~~这道题细节是真的多~~

看数据范围，这应该是一道虚树DP，我们先来想一下不用虚树怎么做

我们定义$id[i]$为第i个点应该归哪一个议事处管理，且i到$id[i]$的距离为$dis[i]$

我们做两遍dfs，首先从下到上，用儿子更新父亲，再从上到下，用父亲更新儿子

更新过程十分简单，就类似于重链剖分的思路去更新就好了

然后这里要注意第一个细节，就是必须先用儿子更新父亲，再用父亲更新儿子，因为如果不这么做的话一个父亲可能有多个儿子，所以先更新儿子的话该儿子的'兄弟'不会更新到（画画图就理解了）

暴力DP就是这么做，那如果放在虚树上呢？

对于虚树上的点，我们仍然可以按照上述暴力DP方式来做

那么非虚树上的点呢？

首先虚树是保证了两个相邻的树点在原树中实在一条链上的

所以我们可以里用倍增的思想，求出两个相邻虚树点的分界点，分界点以上归上面的点管理，分界点一下同理

由于我们还要保证编号最小，所以这就是本题第二个坑点：我们需要判断两个虚树点id值的大小

具体实现中我们可以把分界处以下的点染成一种新的颜色，然后递归处理，我们可以保证先处理深度小的点再处理深度大的点

为什么要这么做呢？

因为分界点以下的点已经不归上方关键点管辖，所以我们可以用一种新的颜色覆盖点原来的颜色，表示被一个新点占领了

[楼上$chenkehan$大佬](https://www.luogu.org/blog/ILikeDuck/solution-p3233)给了十分形象的图片

于是就可以~~愉快~~的码码码了

## 献上十分丑陋的代码：
```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
il int read() {
    re int x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
#define rep(i, s, t) for(re int i = s; i <= t; ++ i)
#define drep(i, s, t) for(re int i = t; i >= s; -- i)
#define Next(i, u) for(re int i = head[u]; i; i = e[i].next)
#define _ 300005
int n, m, Q, top[_], Top, st[_], son[_], size[_], dep[_], dfn[_], tot, cnt, head[_];
int id[_], ans[_], f[25][_], dis[_], vis[_], Size[_];
struct node {int a, id;}q[_];
struct edge {int v, next, w;}e[_ << 1];
il bool cmp(node a, node b) {return dfn[a.a] < dfn[b.a];}
il bool cmp1(node a, node b) {return a.id < b.id;}
il void add(int u, int v, int w) {
	e[++ cnt] = (edge){v, head[u], w}, head[u] = cnt;
	e[++ cnt] = (edge){u, head[v], w}, head[v] = cnt;
}
il void dfs1(int u, int fr) {
	f[0][u] = fr, dep[u] = dep[fr] + 1, size[u] = 1, dfn[u] = ++ tot;
	Next(i, u) if(e[i].v != fr) dfs1(e[i].v, u), size[u] += size[e[i].v];
}
il int LCA(int a, int b) {
	if(dep[a] < dep[b]) swap(a, b);
	drep(i, 0, 20) if(dep[a] - (1 << i) >= dep[b]) a = f[i][a];
	drep(i, 0, 20) if(f[i][a] != f[i][b]) a = f[i][a], b = f[i][b];
	return (a == b) ? a : f[0][a];
}
il int Dis(int a, int b) {return dep[a] + dep[b] - dep[LCA(a, b)] * 2;}
il void insert(int x) {
	if(Top == 1 && x != 1) return (void)(st[++ Top] = x);
	int lca = LCA(st[Top], x);	if(lca == x) return;
	while(Top > 1 && dep[st[Top - 1]] > dep[lca]) 
		add(st[Top - 1], st[Top], Dis(st[Top - 1], st[Top])), -- Top;
	if(dep[st[Top]] > dep[lca]) add(st[Top], lca, Dis(st[Top], lca)), -- Top;
	if(dep[st[Top]] < dep[lca]) st[++ Top] = lca;
	st[++ Top] = x;
}
il void dfs_mem(int u, int fr) {
	Next(i, u) if(e[i].v != fr) dfs_mem(e[i].v, u);
	head[u] = vis[u] = id[u] = dis[u] = Size[u] = ans[u] = 0;
}
il int get_fa(int u, int dis) {
	int now = 0;
	drep(i, 0, 20) if(now + (1 << i) <= dis) now += (1 << i), u = f[i][u];
	return u;
}
il void dfs_get(int u, int fr) {
	if(vis[u]) dis[u] = 0, id[u] = u, Size[u] = size[u];
	else dis[u] = 123456789, Size[u] = size[u];
	Next(i, u) {
		int v = e[i].v, w = e[i].w;  if(v == fr) continue;
		dfs_get(v, u), w += dis[v];
		if(dis[u] > w || (dis[u] == w && id[u] > id[v])) dis[u] = w, id[u] = id[v];
	}
}
il void dfs1_get(int u, int fr) {
	Next(i, u) {
		int v = e[i].v, w = dis[u] + e[i].w;  if(v == fr) continue;
		if(w < dis[v] || (w == dis[v] && id[v] > id[u])) dis[v] = w, id[v] = id[u];
		dfs1_get(v, u);
		if(id[u] == id[v]) Size[u] -= size[v];
		else {
			int x = get_fa(v, (dis[v] + dis[u] + e[i].w + (id[u] > id[v]) - 1) / 2 - dis[v]);//Attention: (dep[x] - dep[y])即e[i].w的意义是经过的边的数量！我就是因为这里调了**的
			Size[v] += size[x] - size[v], Size[u] -= size[x];
		}
        ans[id[v]] += Size[v];
	}
	if(u == 1) ans[id[1]] += Size[1];
}
int main() {
	n = read();
	rep(i, 1, n - 1) add(read(), read(), 0);
	Q = read(), dfs1(1, 1), memset(head, 0, sizeof(head));
	rep(i, 1, 20) rep(j, 1, n) f[i][j] = f[i - 1][f[i - 1][j]];
	while(Q --) {
		m = read(), st[Top = 1] = 1, cnt = 0;
		rep(i, 1, m) q[i].a = read(), vis[q[i].a] = 1, q[i].id = i;
		sort(q + 1, q + m + 1, cmp);
		rep(i, 1, m) insert(q[i].a);
		while(Top > 1) add(st[Top - 1], st[Top], Dis(st[Top - 1], st[Top])), -- Top;
		dfs_get(1, 0), dfs1_get(1, 0), sort(q + 1, q + m + 1, cmp1);
		rep(i, 1, m) printf("%d ", ans[q[i].a]);
		puts(""), dfs_mem(1, 0);
	}
	return 0;
}
```

---

## 作者：Rainybunny (赞：2)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[$luogu$](https://www.luogu.com.cn/problem/P3233).
# 题解
## 题目大意
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一棵树上$n$个点, 其中指定了$m$个关键点, 询问每个关键点所"统治"的结点. 一个点仅会被离其最近的关键点所"统治" ( 若距离相等, 则被标号最小的关键点"统治". )  
## 思路
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~虚树虚树, 调到肾虚的树.~~  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到数据约定中:
>
$$
\sum_{i=1}^qm_i\le3\times10^5
$$

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以可以套上虚树. 在此之前先处理处倍增数组$Fa$, 子树大小$Siz$, 建出虚树后, 预处理出每个点被谁统治 ( $Ctrl$ ). 想一想如何在虚树上$DP$?  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先来一张图:
![g1.png](https://i.loli.net/2019/12/06/rjnDqTS2Hw6xdh1.png)  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$Tips$: $u$, $v$是关键结点, 红色边是虚树边, 其余为原树的信息.  

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先对于以$1$为根的子树, 由于没有关键结点, 它根本不会体现在虚树上. 怎么办? 我们用一个$Surp$数组记录结点$u$"失踪的结点个数", 初始时, $Surp_u=Siz_u$, 只需要在$DP$的时候减去一些被抢夺的结点即可.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着, 我们考虑路径$<u,4,5,v>$上的情况. 显然, $u$和$v$应该将中间的结点"对半分". 利用倍增数组. 我们从$v$向上跳, 并保证落脚的结点被$v$统治, 设我们最后得到的结点是$mid$. ( 这意味着, $<fa_{mid},mid>$就是$u$和$v$势力范围的边界. ) 再顺便求出$u$到$v$的路径上离$u$最近的结点, 设为$s$. ( 体现在图上, 就是结点$4$. 这也能利用倍增. ) 考虑结点$u$和结点$v$的统治点有何变化:

- $a)$ 对于$u$, 它失去了以$mid$为根的子树的所有结点. 故$Ans_u+=Siz_s-Siz_{mid}$, 同时, 我们也已经发现了以$s$为根的子树. 所以$Surp_u-=Siz_s$.  

- $b)$ 对于$v$, 它得到了以$mid$为根的子树减去以$v$为根的子树的所有结点. 所以$Ans_v+=Siz_{mid}-Siz_v$.  

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$DP$的思路就到这里. 但万一$u$, $v$并不是关键结点呢?  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很简单, 我们把他们的贡献记录在$Ctrl_u$与$Ctrl_v$就可以了. 所以要注意求$mid$时我们相当于求$Ctrl_u$与$Ctrl_v$的势力范围.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;儿子搜完之后, 记得加上失踪的儿子们, 他们显然都归$Ctrl_u$统治. 即$Ans_u+=Surp_u$.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后, 如果不清楚$Ctrl$怎么求, 或还有其它疑惑, 就看看代码里的注释吧.
## 代码
```cpp
#include <cstdio>
#include <algorithm>

#define Int register int

using namespace std;

const int MAXN = 300000, LGMAXN = 19;
int n, q, m, Cnte, Head[MAXN + 5], h[MAXN + 5], Depth[MAXN + 5], Siz[MAXN + 5];
int Vcnte, Indx, DFN[MAXN + 5], Vhead[MAXN + 5], Fa[MAXN + 5][LGMAXN + 5];
int Top, S[MAXN + 5], Ctrl[MAXN + 5], Surp[MAXN + 5], Ans[MAXN + 5], tmp[MAXN + 5];
bool Import[MAXN + 5];

struct Edge {
	int To, Cost, _nxt;
	Edge () {}
	Edge ( const int t, const int c, const int n ): To ( t ), Cost ( c ), _nxt ( n ) {}
} Graph[MAXN << 1], Vgraph[MAXN << 1]; // Vgraph是虚树边集.

inline int rint () {
	int x = 0; char s = getchar ();
	for ( ; s < '0' || '9' < s; s = getchar () );
	for ( ; '0' <= s && s <= '9'; s = getchar () ) x = ( x << 3 ) + ( x << 1 ) + ( s ^ '0' );
	return x;
}

inline bool Cmp ( const int a, const int b ) { return DFN[a] < DFN[b]; }

inline void Link ( const int From, const int To, const int Cost ) {
	Graph[++ Cnte] = Edge ( To, Cost, Head[From] );
	Head[From] = Cnte;
}

inline void Vlink ( const int From, const int To, const int Cost ) { // 虚树连边.
	Vgraph[++ Vcnte] = Edge ( To, Cost, Vhead[From] );
	Vhead[From] = Vcnte;
}

inline void PrepareLCA ( const int u, const int fa ) { // 预处理倍增Fa数组, Siz数组, Depth数组, DFN数组.
	DFN[u] = ++ Indx, Depth[u] = Depth[Fa[u][0] = fa] + ( Siz[u] = 1 );
	for ( Int i = 1; i <= 19; ++ i ) Fa[u][i] = Fa[Fa[u][i - 1]][i - 1];
	for ( Int i = Head[u], v; i; i = Graph[i]._nxt ) {
		if ( ( v = Graph[i].To ) ^ fa ) {
			PrepareLCA ( v, u ), Siz[u] += Siz[v];
		}
	}
}

inline int LCA ( int a, int b ) { // 求LCA.
	if ( Depth[a] < Depth[b] ) a ^= b, b ^= a, a ^= b;
	for ( Int i = 19; ~ i; -- i ) if ( Depth[Fa[a][i]] >= Depth[b] ) a = Fa[a][i];
	if ( a == b ) return a;
	for ( Int i = 19; ~ i; -- i ) if ( Fa[a][i] ^ Fa[b][i] ) a = Fa[a][i], b = Fa[b][i];
	return Fa[a][0];
}

inline int Dist ( const int a, const int b ) { return Depth[a] + Depth[b] - 2 * Depth[LCA ( a, b )]; } // (原)树上距离.

inline void PrepareCtrl1 ( const int u, const int fa ) { // 预处理Ctrl-计算来自子树内的统治.
	Ctrl[u] = Import[u] * u;
	for ( Int i = Vhead[u], v; i; i = Vgraph[i]._nxt ) {
		if ( ( v = Vgraph[i].To ) ^ fa ) {
			PrepareCtrl1 ( v, u );
			int d1 = Depth[Ctrl[v]] - Depth[u], d2 = Ctrl[u] ? Depth[Ctrl[u]] - Depth[u] : 0x3f3f3f3f;
			if ( d1 < d2 || ( d1 == d2 && Ctrl[v] < Ctrl[u] ) ) Ctrl[u] = Ctrl[v];
		}
	}
}

inline void PrepareCtrl2 ( const int u, const int fa ) { // 预处理Ctrl-计算来自父亲的统治.
	for ( Int i = Vhead[u], v; i; i = Vgraph[i]._nxt ) {
		if ( ( v = Vgraph[i].To ) ^ fa ) {
			int d1 = Dist ( v, Ctrl[u] ), d2 = Dist ( v, Ctrl[v] );
			if ( d1 < d2 || ( d1 == d2 && Ctrl[u] < Ctrl[v] ) ) Ctrl[v] = Ctrl[u];
			PrepareCtrl2 ( v, u );
		}
	}
}

inline void DP ( const int u, const int fa ) { // DP求答案.
	Surp[u] = Siz[u]; // Surp初值.
	for ( Int i = Vhead[u], v, s, mid; i; i = Vgraph[i]._nxt ) {
		if ( ( v = Vgraph[i].To ) ^ fa ) {
			DP ( v, u ), s = mid = v; // s是文中离u最近的结点, mid是Ctrl[u]和Ctrl[v]统治范围的边界.
			for ( Int j = 19; ~ j; -- j ) if ( Depth[Fa[s][j]] > Depth[u] ) s = Fa[s][j]; // 倍增求s, 注意是严格大于.
			Surp[u] -= Siz[s]; // 找到s子树, "失踪人口"减少.
			if ( Ctrl[u] == Ctrl[v] ) { Ans[Ctrl[u]] += Siz[s] - Siz[v]; continue; }
			// 这里没有提及, u和v被统一结点统治, 那么路径上的所有结点都归Ctrl[u]统治.
			for ( Int j = 19, w; ~ j; -- j ) { // 倍增求mid.
				w = Fa[mid][j];
				if ( Depth[w] <= Depth[u] ) continue;
				int d1 = Dist ( Ctrl[u], w ), d2 = Dist ( Ctrl[v], w );
				if ( d2 < d1 || ( d1 == d2 && Ctrl[v] < Ctrl[u] ) ) mid = w;
			}
			Ans[Ctrl[u]] += Siz[s] - Siz[mid];
			Ans[Ctrl[v]] += Siz[mid] - Siz[v]; // 计算贡献.
		}
	}
	Ans[Ctrl[u]] += Surp[u]; // 加上失踪人口.
}

inline void Clear ( const int u, const int fa ) { // 清空虚树, 这本来能在DP回溯时进行. ( 我怕出锅. )
	for ( Int i = Vhead[u], v; i; i = Vgraph[i]._nxt ) {
		if ( ( v = Vgraph[i].To ) ^ fa ) {
			Clear ( v, u );
		}
	}
	Ans[Ctrl[u]] = Vhead[u] = Import[u] = 0;
}

inline void Work () {
	n = rint ();
	for ( Int i = 1, u, v; i ^ n; ++ i ) {
		u = rint (), v = rint ();
		Link ( u, v, 1 ), Link ( v, u, 1 );
	}
	PrepareLCA ( 1, 0 );
	for ( q = rint (); q --; Clear ( 1, 0 ), Vcnte = 0 ) {
		m = rint ();
		for ( Int i = 1; i <= m; ++ i ) Import[h[i] = tmp[i] = rint ()] = true; // tmp用来记录输入顺序.
		sort ( h + 1, h + m + 1, Cmp );
		/* 建虚树 */
		S[Top = 1] = 1;
		for ( Int i = 1; i <= m; S[++ Top] = h[i ++] ) {
			int t = LCA ( S[Top], h[i] );
			for ( ; Depth[S[Top]] > Depth[t]; ) {
				int u = S[Top], v, w; -- Top, v = Depth[S[Top]] > Depth[t] ? S[Top] : t;
				Vlink ( u, v, w = Dist ( u, v ) ), Vlink ( v, u, w );
			}
			if ( S[Top] ^ t ) S[++ Top] = t;
		}
		for ( ; S[Top] ^ 1; ) {
			int u = S[Top], v = S[-- Top], w = Dist ( u, v );
			Vlink ( u, v, w ), Vlink ( v, u, w );
		}
		/* 预处理Ctrl */
		PrepareCtrl1 ( 1, 0 ), PrepareCtrl2 ( 1, 1 );
		DP ( 1, 0 ); // DP. 
		for ( Int i = 1; i <= m; ++ i ) printf ( "%d%c", Ans[tmp[i]], i ^ m ? ' ' : '\n' ); // 输出答案.
	}
}

int main () {
	Work ();
	return 0;
}
```

---

## 作者：Varuxn (赞：1)

> [**题目传送门**](https://www.luogu.com.cn/problem/P3233)

> [推销](https://www.cnblogs.com/Varuxn/p/14902295.html)

## 解题思路
正解当然是**虚树**了。

首先对于原树以及虚树各开一个结构体存边，这个不用多说。

然后我们先 **DFS** 一遍，求出各个节点的时间戳，子树大小，深度以及父亲节点，并初始化倍增 LCA 。

对于每一次的操作，我们都建一棵虚树（注意数组的清空），为了方便，我们此后操作的 DFS 都从 1 节点开始，如果 1 节点不是临时议事处，我们也把它给加入到虚树中并做一下标记。

显然，在建虚树之前，要先把所有的临时议事处按照时间戳**排序**，然后建虚树。

此后没，我们进行两遍 DFS :

* 第一遍：用于更新虚树中所有节点的 dp 以及其所属的临时议事处。
	
    因为虚树的深度较小的点不一定是临时议事处，而所有的叶子节点一定是临时议事处。
    
    所以，先遍历到叶子节点，再用叶子节点来更新父亲节点。
    
* 第二遍：利用所有的虚树中的值进而求出原树中的值。
	
	1. 如果子树中没有临时议事处，那么这个节点管辖的点数就要加上子树的siz。
    
    2. 在原树上是一条链，并且两端都是临时议事处，那么直接一半一半分就好了。
    
    * 注意：此过程也需要更新虚树上点的 dp 值以及所属临时议事处，但是不同与第一次 DFS 的是由父亲节点更新叶子节点。

最后输出时注意判断 1 节点是否是临时议事处就好了。

## code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+10,M=N<<1,INF=1e9;
int n,m,Q,tim,s[N],dp[N],g[N],dfn[N],q[N],ans[N],f[N][25],siz[N],dep[N];
int top,sta[N];
bool flag,vis[N];
struct Edge
{
	int tot,head[N],nxt[M],ver[M];
	void add(int x,int y)
	{
		ver[++tot]=y;
		nxt[tot]=head[x];
		head[x]=tot;
	}
}e1,e2;
void dfs(int x,int fat)
{
	f[x][0]=fat;
	siz[x]=1;
	dfn[x]=++tim;
	for(int i=e1.head[x];i;i=e1.nxt[i])
	{
		int to=e1.ver[i];
		if(to==fat)
			continue;
		dep[to]=dep[x]+1;
		dfs(to,x);
		siz[x]+=siz[to];
	}
}
void LCA_init()
{
	dep[1]=1;
	dfs(1,0);
	for(int i=1;i<=20;i++)
		for(int j=1;j<=n;j++)
			f[j][i]=f[f[j][i-1]][i-1];
}
int LCA_ask(int x,int y)
{
	if(x==y)
		return x;
	if(dep[x]>dep[y])
		swap(x,y);
	for(int i=20;i>=0;i--)
		if(dep[f[y][i]]>=dep[x])
			y=f[y][i];
	if(x==y)
		return x;
	for(int i=20;i>=0;i--)
		if(f[x][i]!=f[y][i])
		{
			x=f[x][i];
			y=f[y][i];
		}
	return f[x][0];
}
bool comp(int x,int y)
{
	return dfn[x]<dfn[y];
}
void build(int x)
{
	if(!top)
	{
		sta[++top]=x;
		return ;
	}
	int lca=LCA_ask(x,sta[top]);
	while(top>1&&dep[lca]<dep[sta[top-1]])
	{
		e2.add(sta[top-1],sta[top]);
		e2.add(sta[top],sta[top-1]);
		top--;
	}
	if(dep[lca]<dep[sta[top]])
	{
		e2.add(lca,sta[top]);
		e2.add(sta[top],lca);
		top--;
	}
	if(!top||sta[top]!=lca)
		sta[++top]=lca;
	sta[++top]=x;
}
void dfs1(int x,int fa)
{
	dp[x]=INF;
	for(int i=e2.head[x];i;i=e2.nxt[i])
	{
		int to=e2.ver[i];
		if(to==fa)
			continue;
		dfs1(to,x);
		int dis=dep[to]-dep[x];
		if(dp[x]>dp[to]+dis)
		{
			g[x]=g[to];
			dp[x]=dp[to]+dis;
		}
		else if(dp[x]==dp[to]+dis)
			g[x]=min(g[x],g[to]);
	}
	if(vis[x])
	{
		dp[x]=0;
		g[x]=x;
	}
}
void work(int x,int y)
{
	int b=y;
	for(int i=20;i>=0;i--)
	{
		int l=dep[y]-dep[f[b][i]]+dp[y],r=dep[f[b][i]]-dep[x]+dp[x];
		if(dep[f[b][i]]>dep[x]&&(l<r||(l==r&&g[y]<g[x])))
			b=f[b][i];
	}
	ans[g[y]]+=siz[b]-siz[y];
	ans[g[x]]-=siz[b];
}
void dfs2(int x,int fa)
{
	for(int i=e2.head[x];i;i=e2.nxt[i])
	{
		int to=e2.ver[i];
		if(to==fa)
			continue;
	 	int dis=dep[to]-dep[x];
		if(dp[to]>dp[x]+dis)
		{
			g[to]=g[x];
			dp[to]=dp[x]+dis;
		}
		else if(dp[to]==dp[x]+dis)
			g[to]=min(g[to],g[x]);
		work(x,to);
		dfs2(to,x);
	}
	ans[g[x]]+=siz[x];
}
int main()
{
	scanf("%d",&n);
	for(int i=1,x,y;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		e1.add(x,y);
		e1.add(y,x);
	}
	LCA_init();
	scanf("%d",&Q);
	while(Q--)
	{
		flag=top=e2.tot=0;
		memset(vis,false,sizeof(vis));
		memset(e2.head,0,sizeof(e2.head));
		scanf("%d",&m);
		for(int i=1;i<=m;i++)
		{
			scanf("%d",&q[i]);
			vis[q[i]]=true;
			ans[q[i]]=0;
		}
		if(!vis[1])
		{
			flag=true;
			q[++m]=1;
		}
		for(int i=1;i<=m;i++)
			s[i]=q[i];
		sort(s+1,s+m+1,comp);
		for(int i=1;i<=m;i++)
			build(s[i]);
		if(top)
			while(--top)
			{
				e2.add(sta[top],sta[top+1]);
				e2.add(sta[top+1],sta[top]);
			}
		dfs1(1,0);
		dfs2(1,0);
		for(int i=1;i<=m;i++)
			if(q[i]!=1||!flag)
				printf("%d ",ans[q[i]]);
		printf("\n");
	}
	return 0;
}
```

---

## 作者：上天台 (赞：1)

这是一道虚树裸题，然而细节有点神。。。

先考虑如果只有一个询问怎么做？

就是按照普通的树形dp，向下做一遍计算出如果只看子树内，每个点被哪个点所控制；再向上做一遍计算出如果只看子树外，每个点被哪个点所控制，这样以后取个min就知道每个点在整棵树里是被哪个点所控制了。因为题目对于min的定义满足pair的比较原则，可以直接用pair而不需要自己写个node来比较。

那在虚树上怎么做？

我们当然可以按照上面的原则依然计算出虚树上每个点被哪个点所控制。
而且我们知道，不在虚树上的点显然是通过虚树上的点走到控制点的。具体来说，有如下原则：（这里假设虚树上点u的控制点是bel[u]，它到控制点的距离是dis[u]）

1.对于一个虚树上的点u，它的所有直接儿子中，如果有不在虚树上的，则该儿子代表的子树上的所有点都只能通过u走到控制点。

2.对于在虚树边上的点，假设所在的边是(u,v)，显然当
dis[u]+x<dis[v]+e(u,v)-x || (bel[u]<bel[v] && dis[u]+x==dis[v]+e(u,v)-x)时，选择通过u走，反之通过v走。

3.特别地，虚树的根在原树中的外子树部分都只能通过虚树根走。

根据这些原则，我们得到了统计的方法：

1.对于每一个虚树上的点u，ans[bel[u]]+=sz[u]-sum(sz[v])，其中v是u在原树上的儿子且v在虚树的边/点上。

2.对于虚树上的每一条边(u,v)，假设u是v的祖先，到v的距离是x的点要通过v走。

1)bel[u]<bel[v]：此时dis[u]+x<dis[u]+e(u,v）-x
且1<=x<e(u,v)

2)bel[u]==bel[v]：此时dis[u]+x<=dis[u]+e(u,v)-x
且1<=x<e(u,v)

设v往上走y步到达的祖先是getup(v,y)，则

ans[bel[v]]+=sz[getup(v,x)]-sz[v],

ans[bel[u]]+=sz[getup(v,e(u,v)-1)]-sz[getup(v,x+1)]。

当然，x可能会出现负值之类不合法的情况，此时+0即可，需要特判。

3.ans[bel[root]]+=n-sz[root]。

写着写着，我们发现有些东西需要清零，不过幸运的是在此题中我们只要在做完之后，找出所有虚树上的点，把它们的所有属性清回初始值就可以了。

于是解决的过程就是：

输入->建虚树->solve()->输出->清回初始值。

这样就把细节处理好了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep(x,y,z) for (register int x=y; x<=z; x++)
#define downrep(x,y,z) for (register int x=y; x>=z; x--)
#define ms(x,y,z) memset(x,y,sizeof(z))
#define LL long long
#define repedge(x,y) for (register int x=hed[y]; ~x; x=edge[x].nex)
#define repE(x,y) for(register int x=head[y]; ~x; x=E[x].nex)
#define mp make_pair
#define pr pair<int,int>
#define fr first
#define se second
inline int read(){
	int x=0; int w=0; char ch=0;
	while (ch<'0' || ch>'9') w|=ch=='-',ch=getchar();
	while (ch>='0' && ch<='9') x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return w? -x:x;
}
const int N=300005;
const int Maxlg=18;
int n,m,nedge,hed[N],sz[N],tin[N],tout[N],dep[N],f[N][Maxlg+1],tot;
int Nedge,head[N],d[N],st[N],tmp[N],imp[N],toc[N],sum,val[N],ans[N],lg[(1<<Maxlg)+1];
pr bel[N],F[N][2],G[N];
struct Edge{ int to,nex,cst; }edge[N<<1],E[N<<1];
void addedge(int a,int b){
	edge[nedge].to=b; edge[nedge].nex=hed[a]; hed[a]=nedge++;
}
void dfs_1(int k){
	sz[k]=1; tin[k]=++tot;
	repedge(i,k){
		int v=edge[i].to; if (v==f[k][0]) continue;
		f[v][0]=k; dep[v]=dep[k]+1;
		dfs_1(v); sz[k]+=sz[v];
	}tout[k]=tot;
}
bool isancestor(int x,int y){ return ((tin[x]<=tin[y])&&(tout[y]<=tout[x])); }
int getlca(int x,int y){
	if (isancestor(x,y)) return x; 
	if (isancestor(y,x)) return y;
	downrep(i,Maxlg,0) if (!isancestor(f[x][i],y)) x=f[x][i];
	return f[x][0];
}
int lowbit(int x){ return (x&(-x)); }
int getup(int x,int dis){
	for(int i=dis; i; i-=lowbit(i))
	x=f[x][lg[lowbit(i)]]; return x;
}
int cmp(int a,int b){ return (tin[a]<tin[b]); }
void addE(int a,int b){
	E[Nedge].to=b; E[Nedge].nex=head[a]; E[Nedge].cst=dep[b]-dep[a]; 
    head[a]=Nedge++; val[a]+=sz[getup(b,dep[b]-dep[a]-1)];
}
int build_tree(int n){
	sort(d+1,d+n+1,cmp); int tp=0;
	rep(i,1,n){
		int v=d[i]; if (!tp){ st[++tp]=v; continue;	}
		int u=st[tp]; int w=getlca(u,v);
		if (w==u){ st[++tp]=v; continue; }
		while((tp>1)&&(dep[st[tp-1]]>dep[w])) addE(st[tp-1],st[tp]),tp--;
		addE(w,st[tp]); tp--; if ((!tp)||(st[tp]!=w)) st[++tp]=w; st[++tp]=v;
	}
	while(tp>1) addE(st[tp-1],st[tp]),tp--; return st[tp];
}
void dfs_2(int k){
	F[k][0]=imp[k]? mp(0,k):mp(n+1,n+1); F[k][1]=mp(n+1,n+1);
	repE(i,k){
		int v=E[i].to; dfs_2(v); 
		pr x=F[v][0]; x.fr+=E[i].cst;
		if (x<=F[k][0]) F[k][1]=F[k][0],F[k][0]=x;
		else F[k][1]=min(F[k][1],x);
	}
}
void dfs_3(int k){
	toc[++sum]=k;
	repE(i,k){
		int v=E[i].to; pr x=F[v][0]; x.fr+=E[i].cst;
		pr y=(x==F[k][0])? F[k][1]:F[k][0]; y=min(y,G[k]); y.fr+=E[i].cst;
		G[v]=y; dfs_3(v);
	}
}
int main(){
	scanf("%d",&n); nedge=0; ms(hed,-1,hed);
	rep(i,1,n-1){ int u,v; scanf("%d%d",&u,&v); addedge(u,v); addedge(v,u); }
	rep(i,0,Maxlg) lg[(1<<i)]=i; f[1][0]=1; dfs_1(1); 
	rep(j,1,Maxlg) rep(i,1,n) f[i][j]=f[f[i][j-1]][j-1];
	scanf("%d",&m); Nedge=0; ms(head,-1,head);
	rep(i,1,m){
		int nw; scanf("%d",&nw);
		rep(j,1,nw) scanf("%d",&d[j]); rep(j,1,nw) tmp[j]=d[j];
		int rot=build_tree(nw); 
		rep(j,1,nw) imp[d[j]]=1; dfs_2(rot); G[rot]=mp(n+1,n+1); dfs_3(rot); 
		rep(j,1,sum) bel[toc[j]]=min(F[toc[j]][0],G[toc[j]]);
		rep(j,1,sum){ 
		   int k=toc[j]; ans[bel[k].se]+=sz[k]-val[k]; //参照题解中的1.
		   repE(p,k){ 
		      int v=E[p].to; int l=1; int r=E[p].cst-1; 
			  int x,y; y=E[p].cst+bel[k].fr-bel[v].fr;
			  if (bel[v].se<bel[k].se) x=y/2; 
			  else x=(y&1)? (y/2):(y/2-1); r=min(r,x); //[getup(v,l),getup(v,r)]都从v走
		      if (l<=r) ans[bel[v].se]+=sz[getup(v,r)]-sz[v];
		      l=max(l,r+1); r=E[p].cst-1; 
		      if (l<=r) ans[bel[k].se]+=sz[getup(v,r)]-sz[getup(v,l-1)];
              //[getup(v,r+1),getup(v,E[p].cst-1)]都从k走
		   }//参照题解中的2.
		}ans[bel[rot].se]+=n-sz[rot];//参照题解中的3.
		rep(j,1,nw) if (j==nw) printf("%d\n",ans[tmp[j]]); else printf("%d ",ans[tmp[j]]);
		rep(j,1,nw) imp[d[j]]=ans[d[j]]=0;
		rep(j,1,sum) head[toc[j]]=-1,val[toc[j]]=0; Nedge=sum=0;//清回初始值
	}
	return 0;
}
```



---

## 作者：_sry (赞：1)


题目大意

有一颗树，且每次询问包含$k$个特殊节点，问每个特殊节点能占领几个节点

试题分析

到底是道德的沦丧,还是人性的扭曲。

其实发现数据范围$\sum_{i=1}^q m_i \leq 3\times 10^5$想到了什么---虚树，所以应该怎么用虚树优化。

先将虚树建出来，这是基本操作，点为$(u,v)$,则边权为$dis_{u,v}$

然后就$dfs$两遍，一遍求儿子对父亲的占领影响，然后第二遍求父亲对儿子的占领影响。记录$dis_i$为从$i$到特殊节点的最小距离，$bel_i$为$i$到哪一个特殊节点。

然后怎样去统计答案，我们发现若树边$(u,v)$，他们的$bel$相等，则就让父亲减去儿子的子树大小，就是不算重了。若不等，则我们可以计算出两端，两端值两个特殊节点的节点数。然后经过一系列的计算便可以倍增求出两个的中断值。然后在加减一下子树就行了。
```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<stack>
#include<algorithm>
#include<climits>
using namespace std;
inline int read(){
    int f=1,ans=0;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}
    return f*ans;
}
const int N=300001;
struct node{
    int u,v,w,nex;
}x[N<<1];
int in[N],size[N],out[N],num,n,head[N],cnt,deep[N],fa[N][21];
void add(int u,int v,int w){
    x[cnt].u=u,x[cnt].v=v,x[cnt].w=w,x[cnt].nex=head[u],head[u]=cnt++;
}
int remove(int u,int Deep){
    for(int i=20;i>=0;i--) 
       if(deep[u]-(1<<i)>=Deep) u=fa[u][i];
     return u; 
}
void dfs(int f,int fath){
    in[f]=++num;deep[f]=deep[fath]+1,size[f]=1;fa[f][0]=fath;
    for(int i=1;(1<<i)<=deep[f];i++) fa[f][i]=fa[fa[f][i-1]][i-1];
    for(int i=head[f];i!=-1;i=x[i].nex){
        if(x[i].v==fath) continue;
        dfs(x[i].v,f);
        size[f]+=size[x[i].v];
    }out[f]=++num;
    return;
}
stack<int> s;
int que[N];
int lca(int u,int v){
    if(deep[u]<deep[v]) swap(u,v);
    for(int i=20;i>=0;i--)
        if(deep[u]-(1<<i)>=deep[v]) u=fa[u][i];
    if(u==v) return u;
    for(int i=20;i>=0;i--){
        if(fa[u][i]==fa[v][i]) continue;
        u=fa[u][i],v=fa[v][i];
    }return fa[u][0];
}
int Q,book[N],sta[N],st;
int Dis(int u,int v){return deep[u]+deep[v]-2*deep[lca(u,v)];}
bool cmp(int x,int y){
    int s1,s2;
    if(x>0) s1=in[x];else s1=out[-x];
    if(y>0) s2=in[y];else s2=out[-y];
    return s1<s2;
}
int eff[N];
void build(){
    memset(head,-1,sizeof(head)),cnt=0;
    sort(sta+1,sta+st+1,cmp);
    for(int i=1;i<st;i++){
        int Lca=lca(sta[i],sta[i+1]);
        if(!book[Lca]){book[Lca]=1;sta[++st]=Lca;}
    }
    int now=st;
    for(int i=1;i<=now;i++) sta[++st]=-sta[i];
    if(!book[1]) sta[++st]=1,sta[++st]=-1;
    sort(sta+1,sta+st+1,cmp);
    for(int i=1;i<=st;i++){
        if(sta[i]>0) s.push(sta[i]);
        else{
            int f=s.top();s.pop();
            if(f!=1){int fath=s.top();int dis=Dis(f,fath);add(f,fath,dis),add(fath,f,dis);}
        }
    }return;
}
int dis[N],bel[N],S[N];
void dfs1(int f,int fath){
    que[++que[0]]=f;
    if(eff[f]) dis[f]=0,bel[f]=f;
    else dis[f]=INT_MAX;
    S[f]=size[f];
    for(int i=head[f];i!=-1;i=x[i].nex){
        if(x[i].v==fath) continue;
        dfs1(x[i].v,f);
        if((dis[f]>dis[x[i].v]+x[i].w)||((dis[f]==dis[x[i].v]+x[i].w)&&(bel[f]>bel[x[i].v]))){
            dis[f]=dis[x[i].v]+x[i].w;
            bel[f]=bel[x[i].v];
        }
    }return;
}
int ans[N];
void dfs2(int f,int fath){
    for(int i=head[f];i!=-1;i=x[i].nex){
        if(x[i].v==fath) continue;
        if((dis[f]+x[i].w<dis[x[i].v])||((dis[f]+x[i].w==dis[x[i].v])&&bel[x[i].v]>bel[f])){
            dis[x[i].v]=x[i].w+dis[f];
            bel[x[i].v]=bel[f];
        }
        dfs2(x[i].v,f);
        if(bel[f]==bel[x[i].v]) S[f]-=size[x[i].v];
        else{
            int DIS=(dis[x[i].v]+deep[x[i].v])+(dis[f]-deep[f])-1;
            int k=DIS/2-dis[x[i].v];
            int tmp=remove(x[i].v,deep[x[i].v]-k);
            if((DIS%2)&&(bel[x[i].v]<bel[f])&&(k>=0)) tmp=fa[tmp][0];
            S[x[i].v]+=size[tmp]-size[x[i].v];
            S[f]-=size[tmp];
        }
        ans[bel[x[i].v]]+=S[x[i].v];
    }
    if(f==1) ans[bel[1]]+=S[1];
}
int xs[N];
int main(){
    memset(head,-1,sizeof(head));
    n=read();
    for(int i=1;i<n;i++){
        int u=read(),v=read();
        add(u,v,0),add(v,u,0);
    }
    dfs(1,0);
    Q=read();
    while(Q--){
        st=read();
        for(int i=1;i<=st;i++) sta[i]=read(),book[sta[i]]=1,eff[sta[i]]=1,xs[i]=sta[i];
        int ST=st;
        build();
        dfs1(1,0),dfs2(1,0);
        for(int i=1;i<=ST;i++) printf("%d ",ans[xs[i]]);
        for(int i=1;i<=que[0];i++) book[que[i]]=eff[que[i]]=dis[que[i]]=bel[que[i]]=S[que[i]]=ans[que[i]]=0;que[0]=0;
        printf("\n");
    }
    return 0;
}
```

---

## 作者：Salamander (赞：1)

构出虚树，考虑接下来怎么做。

    
首先对于虚树上每个节点求出它被哪个关键点管辖。先用儿子更新父亲，然后用父亲更新儿子。（为什么反过来不行？因为存在某个关键点管辖了兄弟节点的情况）


然后考虑不在虚树上的点。

    
$~$
    
如果一个点挂在虚树上一条边的侧链，那么有两种情况：

    
1.这条边两端的点被同一个点所管辖，那么这个点肯定也被这个点管辖。

    
2.这条边两端的点被不同的点所管辖，那么这条链上必定存在一个分界点，分界点两边的点被不同的点管辖。

    
对于情况2，我们可以倍增地跳出这个分界点，要注意讨论一下边界情况，比如到管辖链两端的关键点的距离相等的情况要取编号小的那个。


$~$

如果一个点挂在虚树上一个节点上，那么很简单，这个点肯定与虚树上那个点被同一个点所管辖。

    
$~$
    
直接这么写会比较麻烦，我们可以把虚树上同一个点管辖的所有点看做一块，然后每块的初始答案为这一块的大小加上这一块在原树上下挂的所有节点个数，统计答案的时候只需要砍掉没有被这一块管辖的子树即可。这样我们就可以遍历整棵虚树，对于一条链接两个不同块的边，要统计一下这条边侧链有多少被下面那个块管辖，加到下面那块的答案中，然后从上面那块的答案中减掉被下面那块管辖的点数。

    
复杂度$O((\sum{m_i})\log n)$。


```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

#define For(i,_beg,_end) for(int i=(_beg),i##end=(_end);i<=i##end;++i)
#define Rep(i,_beg,_end) for(int i=(_beg),i##end=(_end);i>=i##end;--i)

template<typename T>T Max(const T &x,const T &y){return x<y?y:x;}
template<typename T>T Min(const T &x,const T &y){return x<y?x:y;}
template<typename T>int chkmax(T &x,const T &y){return x<y?(x=y,1):0;}
template<typename T>int chkmin(T &x,const T &y){return x>y?(x=y,1):0;}
template<typename T>void read(T &x){
    T f=1;char ch=getchar();
    for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
    for(x=0;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';
    x*=f;
}

const int maxn=300010;
struct edge{
    int to,nxt;
}e[maxn<<1];
int n,m,q,num,head[maxn];
int dfn[maxn],cnt,h[maxn],g[maxn],sta[maxn],top;
int fa[maxn][20],dep[maxn],size[maxn];
int ans[maxn],bl[maxn],d[maxn];
bool vis[maxn];

void addedge(int,int);
void Dfs_Init(int);
int jump(int,int);
int Dis(int,int);
int Lca(int,int);
void Build(void);
void Dfs1(int,int);
void Dfs2(int,int);
void Dfs(int,int);
bool comp(int,int);

int main(){
    read(n);
    For(i,1,n-1){
        int u,v;
        read(u);read(v);
        addedge(u,v);
    }
    Dfs_Init(1);
    read(q);
    while(q--){
        read(m);
        For(i,1,m) read(h[i]),vis[h[i]]=true;
        For(i,1,m) ans[g[i]=h[i]]=0;
        Build();
        Dfs1(1,0);Dfs2(1,0);Dfs(1,0);
        For(i,1,m) printf("%d ",ans[g[i]]);
        putchar(10);
        For(i,1,m) vis[h[i]]=false;
    }
    return 0;
}

void Build(){
    sort(h+1,h+m+1,comp);
    num=head[sta[top=1]=1]=0;
    For(i,1,m){
        if(h[i]==1) continue;
        int lca=Lca(h[i],sta[top]);
        if(lca!=sta[top]){
            while(dfn[sta[top-1]]>dfn[lca]){
                addedge(sta[top],sta[top-1]);
                top--;
            }
            if(dfn[sta[top-1]]<dfn[lca]){
                head[lca]=0;
                addedge(sta[top],lca);
                sta[top]=lca;
            }
            else addedge(sta[top--],lca);
        }
        head[h[i]]=0;
        sta[++top]=h[i];
    }
    For(i,1,top-1) addedge(sta[i],sta[i+1]);
}
void Dfs1(int x,int f){
    if(vis[x]) bl[x]=x;
    int dis=vis[x]?0:0x7fffffff;
    for(int i=head[x];i;i=e[i].nxt) if(e[i].to!=f){
        Dfs1(e[i].to,x);
        int temp=dep[bl[e[i].to]]-dep[x];
        if(chkmin(dis,temp)) bl[x]=bl[e[i].to];
        else if(dis==temp) chkmin(bl[x],bl[e[i].to]);
    }
    d[x]=dis;
}
void Dfs2(int x,int f){
    for(int i=head[x];i;i=e[i].nxt) if(e[i].to!=f){
        int y=e[i].to;
        if(chkmin(d[y],d[x]+dep[y]-dep[x])) bl[y]=bl[x];
        else if(d[y]==d[x]+dep[y]-dep[x]) chkmin(bl[y],bl[x]);
        Dfs2(y,x);
    }
    chkmax(ans[bl[x]],size[x]);
}
void Dfs(int x,int f){
    for(int i=head[x];i;i=e[i].nxt) if(e[i].to!=f){
        if(bl[e[i].to]!=bl[x]){
            int y=e[i].to,dis=Dis(bl[x],bl[y]),z;
            if(dis&1) ans[bl[x]]-=size[z=jump(y,dis/2-d[y])];
            else{
                z=jump(y,dis/2-d[y]);
                if(z!=x&&z!=y) z=jump(y,dis/2-d[y]-(bl[x]<bl[y]));
                else if(z==x) z=jump(y,dis/2-d[y]-1);
                ans[bl[x]]-=size[z];
            }
            if(y!=z) ans[bl[y]]+=size[z]-size[y];
        }
        Dfs(e[i].to,x);
    }
}
void addedge(int u,int v){
    e[++num].to=v;e[num].nxt=head[u];head[u]=num;
    e[++num].to=u;e[num].nxt=head[v];head[v]=num;
}
void Dfs_Init(int x){
    dep[x]=dep[fa[x][0]]+1;
    size[x]=1;dfn[x]=++cnt;
    For(i,1,19)
        if(fa[x][i-1]) fa[x][i]=fa[fa[x][i-1]][i-1];
        else break;
    for(int i=head[x];i;i=e[i].nxt) if(e[i].to!=fa[x][0]){
        fa[e[i].to][0]=x;
        Dfs_Init(e[i].to);
        size[x]+=size[e[i].to];
    }
}
int jump(int x,int y){
    For(i,0,19){
        if((y>>i)&1){
            x=fa[x][i];
            y^=(1<<i);
        }
        if(!y) break;
    }
    return x;
}
int Lca(int u,int v){
    if(dep[u]<dep[v]) swap(u,v);
    u=jump(u,dep[u]-dep[v]);
    if(u==v) return u;
    Rep(i,19,0) if(fa[u][i]!=fa[v][i]){
        u=fa[u][i];
        v=fa[v][i];
    }
    return fa[u][0];
}
int Dis(int x,int y){return dep[x]+dep[y]-2*dep[Lca(x,y)];}
bool comp(int x,int y){return dfn[x]<dfn[y];}
```

---

## 作者：xukuan (赞：0)

我来讲一下这题虚树的建法

1. 把所有会议室的点按根节点最小的$dfn$序排序，求出任意两点的$LCA$

2. 把所有LCA的点和会议室的点及其相反数加进去，按$dfn$序（正的正序，负的倒序）排序之后$unique$
3. 然后如果点的值$>0$进栈，$<0$连边然后出栈。

4. 然后$dp$，第$1$遍$dfs$求深度和两个$dfn$序，第$2$遍和第$3$遍求距离和编号的最小值，第$4$编统计答案

~~代码贺了我们班大佬ckh的代码~~

```cpp
//自行加火车头
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
#define prll pair<ll,ll>
#define mkpr make_pair
using namespace std;

const ll N=300010,INF=1ll<<30;
ll n,m,cnt,top,a[N],b[N<<1],h[N],ans[N],d[N],size[N],p[N][30],v[N],st[N],dfnin[N],dfnout[N];
ll ver[N<<1],Next[N<<1],head[N],tot;
ll _ver[N<<1],_Next[N<<1],_head[N],_tot;
prll g[N];

inline ll read(){
	ll x=0,tmp=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-') tmp=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar(); 
	}
	return tmp*x;
}

inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	ll y=10,len=1;
	while(y<=x){
		y=(y<<3)+(y<<1);
		len++;
	}
	while(len--){
		y/=10;
		putchar(x/y+48);
		x%=y;
	}
}

inline void addEdge(ll x,ll y){
	ver[++tot]=y;
	Next[tot]=head[x];
	head[x]=tot; 
}

inline void _addEdge(ll x,ll y){
	_ver[++_tot]=y;
	_Next[_tot]=_head[x];
	_head[x]=_tot;
}

void dfs1(ll x,ll before){
	d[x]=d[before]+1; size[x]=1; dfnin[x]=++cnt;
	p[x][0]=before; for(ll i=1; i<=20; i++) p[x][i]=p[p[x][i-1]][i-1];
	for(ll i=head[x]; i; i=Next[i]){
		ll y=ver[i];
		if(y==before) continue;
		dfs1(y,x);
		size[x]+=size[y];
	}
	dfnout[x]=++cnt;
}

void dfs2(ll x){
	if(v[x]) g[x]=mkpr(0,x);
	else g[x]=mkpr(INF,0);
	for(ll i=_head[x]; i; i=_Next[i]){
		ll y=_ver[i];
		dfs2(y);
		g[x]=min(g[x],mkpr(g[y].first+d[y]-d[x],g[y].second));
	}
} 

void dfs3(ll x){
	for(ll i=_head[x]; i; i=_Next[i]){
		ll y=_ver[i];
		g[y]=min(g[y],mkpr(g[x].first+d[y]-d[x],g[x].second));
		dfs3(y);
	}
} 

inline ll LCA(ll x,ll y){
	if(d[x]>d[y]) swap(x,y);
	for(ll i=20; i>=0; i--){
		if(d[x]<=d[p[y][i]]) y=p[y][i];
	}
	if(x!=y){
		for(ll i=20; i>=0; i--){
			if(p[x][i]!=p[y][i]){
				x=p[x][i];
				y=p[y][i];
			}
		}
		return p[x][0];
	}
	return x;
}

inline ll getdis(ll x,ll y){
	return d[x]+d[y]-2*d[LCA(x,y)];
}

void dfs4(ll x){
	ll u=g[x].second;
	for(ll i=_head[x]; i; i=_Next[i]){
		ll y=_ver[i],v=g[y].second;
		if(u!=v){
			ll dis=d[v]-(getdis(u,v)-(u<v))/2;
			for(ll j=20; j>=0; j--){
				if(d[p[y][j]]>=dis) y=p[y][j];
			}
			ans[u]-=size[y]; ans[v]+=size[y];
		}
		dfs4(_ver[i]);
	}
}

void clean(ll x){
	for(ll i=_head[x]; i; i=_Next[i]) clean(_ver[i]);
	ans[x]=_head[x]=v[x]=0;
} 

inline bool cmp1(ll x,ll y){
	return dfnin[x]<dfnin[y];
}

inline bool cmp2(ll x,ll y){
	return (x>0?dfnin[x]:dfnout[-x])<(y>0?dfnin[y]:dfnout[-y]);
}

int main(){
	n=read();
	for(ll i=1; i<n; i++){
		ll x=read(),y=read();
		addEdge(x,y);
		addEdge(y,x);
	}
	dfs1(1,0);
	for(ll T=read(); T; T--){
		m=read();
		for(ll i=1; i<=m; i++){
			h[i]=a[i]=read();
			v[a[i]]=1;
		}
		sort(a+1,a+1+m,cmp1);
		cnt=0;
		b[++cnt]=a[1]; b[++cnt]=-a[1];
		for(ll i=2; i<=m; i++){
			ll root=LCA(a[i-1],a[i]);
			b[++cnt]=root; b[++cnt]=-root;
			b[++cnt]=a[i]; b[++cnt]=-a[i];
		}
		sort(b+1,b+1+cnt,cmp2);
		cnt=unique(b+1,b+1+cnt)-b-1;
		for(ll i=1; i<=cnt; i++){
			if(b[i]>0) st[++top]=b[i];
			else{
				_addEdge(st[top-1],st[top]);
				st[top--]=0;
			}
		}
		dfs2(b[1]); dfs3(b[1]);
		ans[g[b[1]].second]=size[1];
		dfs4(b[1]);
		for(ll i=1; i<=m; i++){
			write(ans[h[i]]);
			putchar(' ');
		}
		putchar('\n');
		clean(b[1]);
	} 
	return 0;
}
```

---

## 作者：crashed (赞：0)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P3233)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;纯暴力：$BFS$，时间$O(nq)$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到$(\sum k)\le3\times 10^5$这样的条件，我们不禁想到了虚树。于是先把虚树建出来再说。~~反正都是一个板子的事情~~  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后考虑虚树上面怎么搞。其实不难看出，可以用两个$DFS$或者一个$BFS$搞出来虚树上的点的管辖点，同时一个点$u$的没有管辖处的子树们也应该缩到$u$上面来。但是边其实也是很多个点缩出来的，问题于是简化成了如何确定边上的答案。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不难想到记录虚树上每个点到其管辖点的距离。然后考虑虚树上的一条边$(u,v)$的情况。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$1.u$和$v$共属于同一个点管辖。所以把中间的那些点计入$u$和$v$的管辖点即可。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$2.u$和$v$不属于同一个点管辖。不难发现这条边会从中间分开变成两部分，一部分属于$v$，一部分属于$u$。于是就有了单调性，于是就可以用倍增来统计答案了。具体可以看代码。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总时间$O((n+\sum k)\log_2n)$。  
# 代码
```cpp
#include <cmath>
#include <cstdio>
#include <algorithm>

const int INF = 0x3f3f3f3f;
const int MAXN = 3e5 + 5, MAXQ = 3e5 + 5, MAXLOG = 20;

template<typename _T>
void read( _T &x )
{
    x = 0;char s = getchar();int f = 1;
    while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
    while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
    x *= f;
}

template<typename _T>
void write( _T x )
{
    if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
    if( 9 < x ){ write( x / 10 ); }
    putchar( x % 10 + '0' );
}

template<typename _T>
_T ABS( const _T a )
{
	return a < 0 ? -a : a;
}

struct edge
{
	int w, to, nxt;
}Graph[MAXN << 1];

int f[MAXN][MAXLOG];
int mn[MAXN][2];
int dist[MAXN], bel[MAXN], nsiz[MAXN], tot[MAXN];
int seq[MAXN], nat[MAXN], sta[MAXN], top;
int head[MAXN], siz[MAXN], dep[MAXN], DFN[MAXN];
int N, K, ID, cnt, lg2;
bool imp[MAXN];

void addEdge( const int from, const int to, const int w )
{
	cnt ++;
	Graph[cnt].w = w, Graph[cnt].to = to, Graph[cnt].nxt = head[from];
	head[from] = cnt;
}
void addE( const int from, const int to, const int w ) { addEdge( from, to, w ), addEdge( to, from, w ); }

void DFS( const int u, const int fa )
{
	siz[u] = 1, f[u][0] = fa, dep[u] = dep[fa] + 1, DFN[u] = ++ ID;
	for( int i = head[u], v ; i ; i = Graph[i].nxt )
		if( ( v = Graph[i].to ) ^ fa ) 
			DFS( v, u ), siz[u] += siz[v];
}

void init()
{
	lg2 = log2( N );
	for( int j = 1 ; j <= lg2 ; j ++ )
		for( int i = 1 ; i <= N ; i ++ )
			f[i][j] = f[f[i][j - 1]][j - 1];
}

void balance( int &u, const int steps )
{
	for( int i = 0 ; ( 1 << i ) <= steps ; i ++ )
		if( steps & ( 1 << i ) ) u = f[u][i];
}

int LCA( int u, int v )
{
	if( dep[u] > dep[v] ) balance( u, dep[u] - dep[v] );
	if( dep[v] > dep[u] ) balance( v, dep[v] - dep[u] );
	if( u == v ) return u;
	for( int i = lg2 ; ~ i ; i -- ) if( f[u][i] ^ f[v][i] ) u = f[u][i], v = f[v][i];
	return f[u][0];
}

void build()
{
	int tmp;
	top = 0;
	if( seq[1] > 1 ) sta[++ top] = 1;
	for( int i = 1 ; i <= K ; i ++ )
	{
		if( top )
		{
			tmp = LCA( seq[i], sta[top] );
			while( top > 1 && dep[tmp] < dep[sta[top - 1]] )
				addE( sta[top - 1], sta[top], dep[sta[top]] - dep[sta[top - 1]] ), top --;
			if( top && dep[tmp] < dep[sta[top]] ) addE( tmp, sta[top], dep[sta[top]] - dep[tmp] ), top --;
			if( ! ( top && sta[top] == tmp ) ) sta[++ top] = tmp;
		}
		sta[++ top] = seq[i];
	}
	while( top > 1 ) addE( sta[top - 1], sta[top], dep[sta[top]] - dep[sta[top - 1]] ), top --;
}

bool getSiz( const int u, const int fa )
{
	nsiz[u] = siz[u];
	bool flag = false;
	int tmp;
	if( imp[u] ) flag = true;
	for( int i = head[u], v ; i ; i = Graph[i].nxt )
		if( ( v = Graph[i].to ) ^ fa ) 
			if( getSiz( v, u ) )
			{
				flag = true, tmp = v;
				for( int i = lg2 ; ~ i ; i -- )
					if( f[tmp][i] && dep[f[tmp][i]] > dep[u] ) tmp = f[tmp][i];
				nsiz[u] -= siz[tmp];
			}
	return flag;
}

int query( const int u, const int v ) { return dep[u] + dep[v] - 2 * dep[LCA( u, v )]; }

void DFS1( const int u, const int fa )
{
	dist[u] = query( u, bel[u] ), tot[bel[u]] += nsiz[u];
	for( int i = head[u], v, tmp ; i ; i = Graph[i].nxt )
		if( ( v = Graph[i].to ) ^ fa )
		{
			DFS1( v, u );
			if( bel[u] == bel[v] )
			{
				tmp = v;
				for( int j = lg2 ; ~ j ; j -- )
					if( f[tmp][j] && dep[f[tmp][j]] > dep[u] )
						tot[bel[u]] += siz[f[tmp][j]] - siz[tmp], tmp = f[tmp][j];
			}
			else
			{
				int steps = 0, w; w = Graph[i].w - 1;
				tmp = v;
				for( int j = lg2 ; ~ j ; j -- )
					if( f[tmp][j] && dep[f[tmp][j]] > dep[u] && 
						( dist[v] + steps + ( 1 << j ) <= dist[u] + w - steps - ( 1 << j ) ||
						( dist[v] + steps + ( 1 << j ) == dist[u] + w - steps - ( 1 << j ) + 1 && 
						  bel[u] > bel[v] ) ) )	
						tot[bel[v]] += siz[f[tmp][j]] - siz[tmp], tmp = f[tmp][j], steps += 1 << j;
				if( f[tmp][0] == u ) continue;
				tot[bel[u]] += siz[f[tmp][0]] - siz[tmp], tmp = f[tmp][0];
				for( int j = lg2 ; ~ j ; j -- )
					if( f[tmp][j] && dep[f[tmp][j]] > dep[u] )
						tot[bel[u]] += siz[f[tmp][j]] - siz[tmp], tmp = f[tmp][j];
			}
		}
	head[u] = 0, imp[u] = false;
}

bool better( const int u, const int a, const int b ) 
{
	int da = query( u, a ), db = query( u, b ); 
	return a && ( da < db || ( da == db && a < b ) ); 
}

void DFS2( const int u, const int fa ) 
{
	if( imp[u] ) mn[u][0] = u;
	else mn[u][0] = -1;
	mn[u][1] = -1;
	int v;
	for( int i = head[u] ; i ; i = Graph[i].nxt )
		if( ( v = Graph[i].to ) ^ fa )
		{
			DFS2( v, u );
			if( mn[u][0] == -1 || better( u, mn[v][0], mn[u][0] ) ) 
				mn[u][1] = mn[u][0], mn[u][0] = mn[v][0];
			else if( mn[u][1] == -1 || better( u, mn[v][0], mn[u][1] ) ) mn[u][1] = mn[v][0];
		}
}

void DFS3( const int u, const int fa, const int upper )
{
	if( mn[u][0] == -1 || better( u, upper, mn[u][0] ) ) mn[u][1] = mn[u][0], mn[u][0] = upper;
	else if( mn[u][1] == -1 || better( u, upper, mn[u][1] ) ) mn[u][1] = upper;
	for( int i = head[u], v ; i ; i = Graph[i].nxt )
		if( ( v = Graph[i].to ) ^ fa )
		{
			if( mn[u][0] == mn[v][0] ) DFS3( v, u, mn[u][1] );
			else DFS3( v, u, mn[u][0] );
		}
	dist[u] = ABS( dep[mn[u][0]] - dep[u] ), bel[u] = mn[u][0];
}

bool cmp( const int &a, const int &b ) { return DFN[a] < DFN[b]; }

int main()
{
	int Q;
	read( N );
	for( int i = 1, u, v ; i < N ; i ++ ) read( u ), read( v ), addE( u, v, 1 );
	DFS( 1, 0 ), init();
	for( int i = 1 ; i <= N ; i ++ ) head[i] = 0;
	read( Q );
	while( Q -- )
	{
		read( K );
		for( int i = 1 ; i <= K ; i ++ ) read( seq[i] ), imp[nat[i] = seq[i]] = true;
		std :: sort( seq + 1, seq + 1 + K, cmp );
		cnt = 0, build(); 
		getSiz( 1, 0 ); 
		DFS2( 1, 0 ), 
		DFS3( 1, 0, 0 );
		DFS1( 1, 0 );
		for( int i = 1 ; i <= K ; i ++ ) write( tot[nat[i]] ), putchar( i == K ? '\n' : ' ' ), tot[nat[i]] = 0;
	}
	return 0;
}
```

---

## 作者：大菜鸡fks (赞：0)

参考了ljh2000的博客

　　同虚树的题目一样，这道题显然是先要建出虚树，然后复杂度就只和关键点有关了。

　　对于每次询问建一棵虚树，建法参见BZOJ2286

　　之后我们在虚树上dfs一遍，得到每个点从属于哪个节点。之后我们只要统计不在虚树中的点（在虚树中的点上面统计了下面不作考虑）。

　　考虑虚树上的某一条边，如果两个点同属于一个节点，那么只要加上两点之间的未在虚树中的点数即可。

　　假如两个点不属于同一节点，那么显然中间会存在分界点，倍增地找出这个分界点mid，然后两边分别计算贡献就可以了。

主要部分：注意我还需要记一个g数组，表示未在上述统计到的节点数，因为有一些点没有在任何一次讨论中被考虑，那么显然将会与他们在虚树上的父亲节点属于同一节点，只要把初值设为size，每次在上面讨论一次，就把讨论的部分删掉即可。
  
  ```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
inline int read(){int x=0,f=1,ch=getchar(); while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();} while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}
inline void write(int x){if (x<0) putchar('-'),x=-x; if (x>=10) write(x/10); putchar(x%10+'0');}
inline void writeln(int x){write(x); puts("");}
const int N=3e5+5;
struct edge{
	int link,next;
}e[N<<1];
int n,tot,head[N];
inline void add_edge(int u,int v){
	e[++tot]=(edge){v,head[u]}; head[u]=tot;
}
inline void insert(int u,int v){
	add_edge(u,v); add_edge(v,u);
}
inline void init(){
	n=read();
	for (int i=1;i<n;i++){
		int u=read(),v=read();
		insert(u,v);
	}
}
int fa[N][20],sz[N],dep[N],dfn[N],cnt;
void dfs(int u,int Fa){
	fa[u][0]=Fa; sz[u]=1; dep[u]=dep[Fa]+1; dfn[u]=++cnt;
	for (int i=1;i<20;i++){
		fa[u][i]=fa[fa[u][i-1]][i-1];
	}
	for (int i=head[u];i;i=e[i].next){
		int v=e[i].link;
		if (v!=Fa){
			dfs(v,u); sz[u]+=sz[v];
		}
	}
}
inline int LCA(int u,int v){
	if (dep[u]<dep[v]) swap(u,v);
	int delta=dep[u]-dep[v];
	for (int i=0;i<20;i++){
		if (delta&(1<<i)){
			u=fa[u][i];
		}
	} 
	for (int i=19;i>=0;i--){
		if (fa[u][i]!=fa[v][i]){
			u=fa[u][i]; v=fa[v][i];
		}
	}
	if (u!=v) u=fa[u][0];
	return u;
}
inline int dis(int u,int v){
	return dep[u]+dep[v]-2*dep[LCA(u,v)];
}
int st,ans[N],g[N],c[N],h[N],belong[N],top,stack[N<<1];
inline bool cmp(int x,int y){
	return dfn[x]<dfn[y];
} 
inline void insert(int x){
	if (top==1) {
		stack[++top]=x;
		return;
	}
	int lca=LCA(x,stack[top]);
	while (top>1&&dfn[stack[top-1]]>=dfn[lca]) add_edge(stack[top-1],stack[top]),top--;
	if (stack[top]!=lca) add_edge(lca,stack[top]),stack[top]=lca;
	stack[++top]=x; 
}
void dfs1(int u){
	g[u]=sz[u]; c[++cnt]=u;
	for (int i=head[u];i;i=e[i].next){
		int v=e[i].link;
		dfs1(v);
		if (!belong[v]) continue;
		if (!belong[u]){
			belong[u]=belong[v];
			continue;
		}
		int d1=dis(belong[u],u),d2=dis(belong[v],u);
		if (d1>d2||(d1==d2&&belong[u]>belong[v])) {
			belong[u]=belong[v];
		}
	}
}
void dfs2(int u){
	for (int i=head[u];i;i=e[i].next){
		int v=e[i].link;
		if (!belong[v]) {
			belong[v]=belong[u];
		}else{
			int d1=dis(belong[v],v),d2=dis(belong[u],v);
			if (d1>d2||(d1==d2&&belong[u]<belong[v])) {
				belong[v]=belong[u];
			}
		}
		dfs2(v); 
	}
}
inline void calc(int Fa,int u){
	int son=u,mid=u;
	for (int i=19;i>=0;i--){
		if (dep[fa[son][i]]>dep[Fa]){
			son=fa[son][i];
		}
	}
	g[Fa]-=sz[son];
	if (belong[Fa]==belong[u]){
		ans[belong[Fa]]+=sz[son]-sz[u];
		return;
	}
	for (int i=19;i>=0;i--){
		int nxt=fa[mid][i];
		if (dep[nxt]<=dep[Fa]) continue;
		int d1=dis(belong[u],nxt),d2=dis(belong[Fa],nxt);
		if (d1<d2||(d1==d2&&belong[u]<belong[Fa])) {
			mid=nxt;
		}
	}
	ans[belong[Fa]]+=sz[son]-sz[mid];
	ans[belong[u]]+=sz[mid]-sz[u];
}
int b[N];
inline void solve(){
	dfs(1,0); int q=read(); tot=0; memset(head,0,sizeof head );
	while (q--){
		int m=read();
		for (int i=1;i<=m;i++){
			b[i]=h[i]=read();
		}
		for (int i=1;i<=m;i++){
			belong[h[i]]=h[i];
		}
		sort(h+1,h+1+m,cmp); stack[top=1]=1;
		cnt=0;
		if (h[1]==1) st=2; else st=1;
		for (int i=st;i<=m;i++){
			insert(h[i]);
		}
		while (top>1) {add_edge(stack[top-1],stack[top]); top--;}
		dfs1(1); dfs2(1);
		for (int i=1;i<=cnt;i++){
			for (int j=head[c[i]];j;j=e[j].next){
				int v=e[j].link;
				calc(c[i],v);
			}
		}
		for (int i=1;i<=cnt;i++) ans[belong[c[i]]]+=g[c[i]];
		for (int i=1;i<=m;i++) write(ans[b[i]]),putchar(' ');
		puts("");
		for (int i=1;i<=cnt;i++) ans[c[i]]=head[c[i]]=g[c[i]]=belong[c[i]]=0;
		tot=0;
	}
}
int main(){
	init();
	solve();
	return 0;
} 
```

---


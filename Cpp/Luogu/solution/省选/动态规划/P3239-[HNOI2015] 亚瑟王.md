# [HNOI2015] 亚瑟王

## 题目描述

小 K 不慎被 LL 邪教洗脑了，洗脑程度深到他甚至想要从亚瑟王邪教中脱坑。他决定，在脱坑之前，最后再来打一盘亚瑟王。既然是最后一战，就一定要打得漂亮。众所周知，亚瑟王是一个看脸的游戏，技能的发动都是看概率的。

作为一个非洲人，同时作为一个前 OIer，小 K 自然是希望最大化造成伤害的期望值。但他已经多年没写过代码，连 Spaly都敲不对了，因此，希望你能帮帮小 K，让他感受一下当欧洲人是怎样的体验。

本题中我们将考虑游戏的一个简化版模型。 玩家有一套卡牌，共 $n$ 张。游戏时，玩家将 $n$ 张卡牌排列成某种顺序，排列后将卡牌按从前往后依次编号为 $1 -  n$。本题中，顺序已经确定，即为输入的顺序。每张卡牌都有一个技能。第 $i$ 张卡牌的技能发动概率为 $p_i$，如果成功发动，则会对敌方造成 $d_i$ 点伤害。也只有通过发动技能，卡牌才能对敌方造成伤害。基于现实因素以及小 K 非洲血统的考虑，$p_i$ 不会为 $0$，也不会为 $1$，即 $0 < p_i < 1$。 一局游戏一共有 $r$ 轮。在每一轮中，系统将从第一张卡牌开始，按照顺序依次考虑每张卡牌。在一轮中，对于依次考虑的每一张卡牌：

1. 如果这张卡牌在这一局游戏中已经发动过技能，则

1.1. 如果这张卡牌不是最后一张，则跳过之（考虑下一张卡牌）； 否则（是最后一张），结束这一轮游戏。

2. 否则（这张卡牌在这一局游戏中没有发动过技能），设这张卡牌为第 $i$ 张

2.1. 将其以 $p_i$ 的概率发动技能。

2.2. 如果技能发动，则对敌方造成 $d_i$ 点伤害，并结束这一轮。

2.3. 如果这张卡牌已经是最后一张（即 $i$ 等于 $n$），则结束这一轮；否则，考虑下一张卡牌。

请帮助小 K 求出这一套卡牌在一局游戏中能造成的伤害的期望值。


## 说明/提示

一共有 $13$ 种可能的情况：

1.  第一轮中，第 $1$ 张卡牌发动技能；第二轮中，第 $2$ 张卡牌发动技能；

概率为 $0.15$，伤害为 $5$。

2.  第一轮中，第 $1$ 张卡牌发动技能；第二轮中，第 $3$ 张卡牌发动技能；

概率为 $0.315$，伤害为 $3$。

3.  第一轮中，第 $1$ 张卡牌发动技能；第二轮不发动技能；

概率为 $0.035$，伤害为 $2$。

4.  第一轮中，第 $2$ 张卡牌发动技能；第二轮中，第 $1$ 张卡牌发动技能；

概率为 $0.075$，伤害为 $5$。

5.  第一轮中，第 $2$ 张卡牌发动技能；第二轮中，第 $3$ 张卡牌发动技能；

概率为 $0.0675$，伤害为 $4$。

6.  第一轮中，第 $2$ 张卡牌发动技能；第二轮不发动技能；

概率为 $0.0075$，伤害为 $3$。

7.  第一轮中，第 $3$ 张卡牌发动技能；第二轮中，第 $1$ 张卡牌发动技能；

概率为 $0.1575$，伤害为 $3$。

8.  第一轮中，第 $3$ 张卡牌发动技能；第二轮中，第 $2$ 张卡牌发动技能；

概率为 $0.04725$，伤害为 $4$。

9.  第一轮中，第 $3$ 张卡牌发动技能；第二轮不发动技能；

概率为 $0.11025$，伤害为 $1$。

10.  第一轮不发动技能；第二轮中，第 $1$ 张卡牌发动技能；

概率为 $0.0175$，伤害为 $2$。

11.  第一轮不发动技能；第二轮中，第 $2$ 张卡牌发动技能；

概率为 $0.00525$，伤害为 $3$。

12.  第一轮不发动技能；第二轮中，第 $3$ 张卡牌发动技能；

概率为 $0.011025$，伤害为 $1$。

13.  第一轮不发动技能；第二轮亦不发动技能；

概率为 $0.001225$，伤害为 $0$。

造成伤害的期望值为概率与对应伤害乘积之和，为 $3.266025$。


对于所有测试数据， $1 \leq T \leq 444， 1 \leq n \leq 220， 0 \leq r \leq 132， 0 < p_i < 1， 0 \leq d_i \leq 1000$。

除非备注中有特殊说明，数据中 $p_i$ 与 $d_i$ 均为随机生成。

请注意可能存在的实数精度问题，并采取适当措施。

本题使用 `special_judge`。

## 样例 #1

### 输入

```
1
3 2
0.5000 2
0.3000 3
0.9000 1```

### 输出

```
3.2660250000```

# 题解

## 作者：__stdcall (赞：92)

一道不简单的概率和期望dp题


根据期望的线性性质，容易想到，可以算出每张卡的期望伤害，然后全部加在一起


手算样例之后发现是正确的，那么我们只要求出每张卡的实际被使用的概率就可以了


记第$i$张卡的实际被使用的概率为$fp[i]$


那么答案就是


$\Large\sum\limits_{i=0}^{n-1}fp[i]\cdot d[i]$


如何求出$fp[i]$？


首先考虑第一张卡的$fp$，也就是$fp[0]$，应该为


$\Large fp[0]=1-(1-p[i])^{r}$


这个很容易理解，因为$(1-p[i])^r$就是这张卡从头到尾始终憋着不出的概率


那么对于后面的$fp$应该怎么求呢


有个条件很烦人，就是在每一轮中，出了一张卡的时候立即结束该轮


那么下面就轮到dp上场啦！


令$f[i][j]$表示在所有的$r$轮中，前$i$张卡中一共出了$j$张的概率，那么就可以用$O(n)$的时间算出$fp[i](i>0)$


枚举前$i-1$轮选了$j$张牌，那么有$j$轮不会考虑到第$i$张牌，也就是有$r-j$轮会考虑到第$i$张牌


那么根据上面的分析，$1-(1-p[i])^{r-j}$就是在$r-j$轮中使用过第$i$张牌的概率，式子：


$\Large fp[i]=\sum\limits_{j=0}^{r}f[i-1][j]\cdot(1-(1-p[i])^{r-j})(i>0) $


接下来只要写出$f[i][j]$的转移方程就好了，分两种情况讨论


第一种，$f[i][j]$从$f[i-1][j]$转移过来，即第$i$张牌最终没有选，始终不选第$i$张牌的概率是$(1-p[i])^{r-j}$


$\Large f[i][j]+=f[i-1][j]\cdot(1-p[i])^{r-j}(i>0) $


第二种，当$j>0$时，$f[i][j]$可以从$f[i-1][j-1]$转移过来，表示最终选择了第$i$张牌


这时候，有$j-1$轮没有考虑到第$i$张牌，所以考虑到第$i$张牌的轮数是$r-j+1$，最终选择的概率为$1-(1-p[i])^{r-j+1}$


$\Large f[i][j]+=f[i-1][j-1]\cdot(1-(1-p[i])^{r-j+1})(i>0,j>0) $


然后就没了，总时间复杂度$O(Tnr)$，具体细节看代码


因为洛谷上有点卡时，所以预处理了$(1-p[i])$的幂


http://www.cnblogs.com/mlystdcall/p/6661858.html


---

## 作者：xyz32768 (赞：56)

如果能够求出每张卡牌在所有$r$轮中被发动的概率$g[]$，那么答案显然为：

$\sum_{i=1}^ng[i]d[i]$

第一步推出，$g[1]=1-(1-p[1])^r$。

再考虑第二张：

情况一：如果第$1$张牌没有发动过技能，那么第$2$张牌发动技能的概率为$1-(1-p[2])^r$。

情况二：如果第$1$张牌发动过$1$次技能，那么在第$1$张牌发动技能的那一轮，第$2$张牌绝对不会再发动技能了，因此第$2$张牌发动技能的概率为$1-(1-p[2])^{r-1}$。

结合这个例子，可以得到，对于任意的$i>1$，在第$1$张牌到第$i-1$张牌在所有$r$轮内**是否发动技能**已经确定的情况下，第$i$张牌被发动技能的概率只取决于第$1$张牌到第$i-1$张牌中**有多少张**发动了技能。即如果有$j$张发动了技能，那么在此情况下第$i$张牌发动技能的概率为$1-(1-p[i])^{r-j}$。

根据这个性质，就能想到一个DP模型：

$f[i][j]$表示前$i$张牌中，恰好有$j$张在所有$r$轮中被发动过的概率。

转移就比较好想了。分第$i$张牌发动与不发动两种情况：

1：发动。那么前$i-1$张牌一定有$j-1$张牌被发动技能，因此对于第$i$张牌，在$r$轮中有$j-1$轮已经不会再发动技能了。所以：

$f[i][j]+=(1-(1-p[i])^{r-j+1})f[i-1][j-1]$

2：不发动。那么前$i-1$张牌中一定有$j$张牌被发动技能，因此对于第$i$张牌，在$r$轮中有$j$轮是绝对不会再发动技能的。所以：

$f[i][j]+=(1-p[i])^{r-j}f[i-1][j]$

因此，完整的转移方程为：

$f[i][j]=((1-(1-p[i])^{r-j+1})f[i-1][j-1])[j>0]$

$+((1-p[i])^{r-j}f[i-1][j])[i\neq j]$

那么求$g$就更容易了：

$g[i]=\sum_{j=0}^{\min(i-1,r)}(1-(1-p[i])^{r-j})f[i-1][j]$

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 234, R = 143;
int n, r, d[N];
double p[N], f[N][R], g[N], pw[N][R];
void work() {
    memset(f, 0, sizeof(f)); memset(g, 0, sizeof(g));
    int i, j; scanf("%d%d", &n, &r);
    for (i = 1; i <= n; i++) scanf("%lf%d", &p[i], &d[i]), pw[i][0] = 1;
    if (!r) return (void) puts("0.0000000000");
    for (i = 1; i <= n; i++) for (j = 1; j <= r; j++)
        pw[i][j] = pw[i][j - 1] * (1.0 - p[i]);
    f[1][0] = pw[1][r]; f[1][1] = g[1] = 1.0 - pw[1][r];
    for (i = 2; i <= n; i++) for (j = 0; j <= min(i, r); j++) {
        if (j) f[i][j] += f[i - 1][j - 1] * (1.0 - pw[i][r - j + 1]);
        if (i != j) f[i][j] += f[i - 1][j] * pw[i][r - j];
    }
    for (i = 2; i <= n; i++) for (j = 0; j <= min(i - 1, r); j++)
        g[i] += f[i - 1][j] * (1.0 - pw[i][r - j]);
    double ans = 0;
    for (i = 1; i <= n; i++) ans += g[i] * d[i];
    printf("%.10lf\n", ans);
}
int main() {
    int T; cin >> T; while (T--) work();
    return 0;
}
```

---

## 作者：gyh20 (赞：26)

简化题意：

给定 $n$ 个技能，进行 $r$ 轮，令 $j=1$ 从 $j$ 开始，每张卡牌有 $p_j$ 的概率选择，如果选择，则进入下一轮，否则令 $j+1$，直到 $j>n$ 为止，同一张技能只能选择一次，最后得到的收益即为每一张选择的技能的 $d_i$ 之和。求最后期望的收益。

题解：

一道巧妙的概率期望 DP。

肯定要进行转化，可以发现，每一个技能的收益是独立的，所以可以求出每一个技能的收益再累加，换句话说，令 $h_i$ 表示第 $i$ 个技能被选择的概率，则答案为：

 $\sum\limits_{i=1}^n d_ih_i$，其中 $d_i$ 为已知量。
 
 现在考虑怎么求 $h_i$。
 
 直接没法求，~~又因为数据范围不大~~，可以增加一维。
 
 令 $f_{i,j}$ 表示前 $i$ 个中选 $j$ 个的概率，则最终的 $h_i$ 可以通过枚举转移得出。

要得出转移，必须要知道第 $i$ 个数被选的概率。而这个东西等于 $1-$ 它不被选的概率，而不被选的概率是 $(1-p_i)^{r-j}$，表示可能选到它的 $r-j$ 次都没选到（根据定义，有 $j$ 次选的前面的数）。

于是选的概率和不选的概率都可以求出。

所以：

$f_{i,j}=(1-(1-p_i)^{r-j+1})f_{i-1,j-1}+(1-p_i)^{r-j}f_{i-1,j}$

可以快速递推，但 $O(Tnr\log r)$ 乘上不小的常数很卡，所以可以预处理快速幂或者用 cmath 库中的 pow。

最后 $h_i$ 的答案即为 $\sum\limits_j(1-(1-p_i)^{r-j})f_{i-1,j}$（转移的概率）。

总体来说，非常巧妙，代码也很短。

```cpp
#include<cstdio>
#include<cmath>
#define re register
using namespace std;
int T,n,r;
double ans,p[252],d[252],f[252][252],xx;   
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d%d",&n,&r);
		for(re int i=1;i<=n;++i)scanf("%lf%lf",&p[i],&d[i]);
		for(re int i=0;i<=n;++i)for(int j=0;j<=r;++j)f[i][j]=0;
		ans=0,f[0][0]=1;
		for(re int i=0;i<=n-1;++i){
			for(re int j=0;j<=i<r?i:r;++j){
				f[i+1][j]+=f[i][j]*(xx=pow(1-p[i+1],r-j)); 
				if(j<r)f[i+1][j+1]+=f[i][j]*(1-xx),ans+=f[i][j]*(1-xx)*d[i+1];
			}
		}
		printf("%.6lf\n",ans);
	}
}
```








---

## 作者：Udumbara (赞：16)

发一个不一样的做法。

我目前没有找到一样的解法，大家都是概率期望两步走，而此做法并不是。

做法来源于我的一个朋友：[_Veritas](/space/show?uid=173056)

我让他发个题解，他虽然答应了，但是由于已经开学，可能会鸽一会，所以我先发一篇，等他发了推荐大家去看原创。

原创链接：暂无

题意简述：

有 $n$ 张卡牌，玩 $r$ 轮游戏。每轮游戏从左向右轮流考虑每张没有发动
过的卡牌，考虑到第 $i$ 张卡时，它有 $p_i$ 的概率发动并产生 $d_i$ 的贡献，
然后本轮立即结束并进入下一轮。若没有卡牌发动则直接进入下一轮。
$T$ 组数据，求期望贡献。

$T ≤ 444, n ≤ 220, r ≤ 132$

分析:

一个比较不好处理的条件就是如果触发一次攻击，马上会重新开始一轮。

考虑转化问题，原问题可以转化为：一次性地从第$1$张牌到第$n$张牌依次考虑，每一张牌有一定的概率被触发攻击（注意此概率并非原题中的$p[i]$），总共有$r$次触发的机会，每触发一次，剩余可以触发的次数就会减少一次，如：第一次触发，那么剩下的机会就变成$r-1$。

如此，问题就转化成了序列上的概率期望dp问题，设$dp[i][j]$表示前$1-i$张牌，还有$j$次触发攻击的机会没有使用的情况对答案的贡献，要倒着推，所以最终答案就是$dp[1][r]$。



状态转移：

$dp[i][j]=dp[i+1][j]*(1-p[i])^{j}+(dp[i+1][j-1]+d[i])*(1-(1-p[i])^{j})$

解释一下：考虑到第$i$张牌,还有$j$次触发的机会，此状态下有两种可能:第一种可能是第$i$张牌没有触发，发生概率是$(1-p[i])^j$，其指向情况是$dp[i+1][j]$；第二种可能是第$i$张牌触发了，用掉一次机会，概率显然是$1-(1-p[i])^j$，其指向的情况是$dp[i+1][j-1]$。这就解释完了。

如果把状态转移看成一个有向无环图的话，上文中的“其指向的情况”其实就是一条有向边，如果知道[绿豆蛙的归宿](https://www.luogu.com.cn/problem/P4316)为什么要反向建边，就同样可以理解为什么要倒推。

再多说一点，绿豆蛙的归宿也可以不反向建边，那就要概率期望两步走。而此题几乎所有人的做法都是正着推，其实就是概率期望两步走，类似于绿豆蛙的归宿那道题正着建图的做法。

代码
```c
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int T,n,r;
double p[222],d[222],dp[222][150];
double Pow(double a, int m)
{
	double base=a, res=1;
	while(m>0)
	{
		if(m&1) res*=base;
		base*=base, m>>=1;
	}
	return res;
}
int main()
{
	cin>>T;
	while(T--)
	{
		memset(dp,0,sizeof(dp));
		cin>>n>>r;
		for(int i=1;i<=n;++i) cin>>p[i]>>d[i];
		for(int i=n;i>0;--i)
		{
			for(int j=1;j<=r;++j)
			{
				double P=Pow(1.0-p[i],j);
				dp[i][j]=dp[i+1][j]*P+(dp[i+1][j-1]+d[i])*(1.0-P);
			}
		}
		printf("%.10lf\n", dp[1][r]);
	}
	return 0;
}
```


---

## 作者：wjyyy (赞：11)

首先，如果直接一轮一轮地进行期望推导，会发现前面有冲突的情况。枚举第 $i$ 轮第 $j$ 张卡时既要保证**前 $i-1$ 轮都没有发动过第 $j$ 张卡**，又要保证**第 $i$ 轮没有发动过前 $j-1$ 张卡**，再乘 $p_i$ 算概率。但是这样怎么算都算不对，其实感觉也是一个“意识”调题的过程吧，反正最终把样例调到 $3.21$ 左右发现概率对不上（样例解释），于是还是放弃了。

因此考虑建立**无后效性的dp**方程。因为需要满足 “如果发动了当前的卡”，那么就停止本轮，所以方程需要和前缀有关。令 $f[i][j]$ 表示在所有的 $r$ 轮里，前 $i$ 张卡有 $j$ 个发动了的概率。此时对于任意的第 $k$ 张卡就可以用 $f[k-1]$ 有关的数据推出来了。

考虑状态转移方程，对于 $f[i][j]$，可以从 $f[i-1][j-1]$ 或 $f[i-1][j]$ 推过来。当从 $f[i-1][j]$ 推过来时，表示第 $i$ 张**整场都没有发动**，因此 $f[i-1][j]$ 的贡献为 $f[i-1][j]\times (1-p_i)^{r-j}$。

其中 $(1-p_i)^{r-j}$ 表示在全部 $r$ 轮中，由于在前 $i-1$ 个中钦定了 $j$ 个，**占用了 $j$ 轮**，剩下的 $r-j$ 轮中每次都没有发动第 $i$ 张卡。

同时，为了便于理解，当我们dp做到 $f[i]$ 时，如果认为第 $i$ 张卡为此时的第一张卡，剩下的 $r-j$ 轮里就只能选择下标为 $[i,n]$ 的卡了。此时第 $i$ 张卡的发动不受前 $i-1$ 张的限制。

当从 $f[i-1][j-1]$ 推过来时（首先要满足 $j>0$），表示第 $i$ 张被发动了，**正难则反**，被发动的概率就是用 $1$ 减去没有被发动的概率。而没有被发动的概率在上文中被提到了，是 $(1-p_i)$ 的幂。此时由于只钦定了 $j-1$ 张卡发动，所以指数为 $r-j+1$。因此 $f[i-1][j-1]$ 的贡献为 $f[i-1][j-1]\times\left(1-(1-p_i)^{r-j+1}\right)$。

然后可以依次求出所有的 $f$，此时我们再根据 $f$ 推出每张卡被发动的概率 $P_i$。

仿照上面 $f[i-1][j-1]\to f[i][j]$ 的过程，我们可以直接算出 

$$P_i=\sum_{j=0}^{i-1}f[i-1][j]\times \left(1-(1-p_i)^{r-j}\right)$$

答案是对每个 $P_i$ 乘上伤害值 $d_i$。

对每个 $(1-p_i)$ 预处理幂后，时间复杂度为 $O(nTr)$。

## Code：

```cpp
#include<cstdio>
#include<cstring>
#define db double
db f[233][233],p[233];
db q[233][233];//q[i][j]表示(1-p[i])^j
int d[233];
int main()
{
    int T;
    scanf("%d",&T);
    while(T--)
    {
        int n,r;
        scanf("%d%d",&n,&r);
        for(int i=1;i<=n;++i)
        {
            scanf("%lf%d",&p[i],&d[i]);
            q[i][0]=1;
            for(int j=1;j<=233;++j)
                q[i][j]=q[i][j-1]*(1-p[i]);
        }
        f[0][0]=1;
        for(int i=1;i<=n;++i)
            for(int j=0;j<=i&&j<=r;++j)
            {
                f[i][j]=j?f[i-1][j-1]*(1-q[i][r-j+1]):0;
                f[i][j]+=f[i-1][j]*q[i][r-j];
            }
        db ans=0;
        for(int i=1;i<=n;++i)
            for(int j=0;j<i&&j<r;++j)
                ans+=d[i]*(f[i-1][j]*(1-q[i][r-j]));
        printf("%.10lf\n",ans);
    }
    return 0;
}
```

---

## 作者：雨落星尘 (赞：7)

2020.11.14

提高阅读体验

------------


~~刚出题解就发现错误……~~

2020.3.22

修改一处括号问题

------------


一道很好的期望$dp$练手题

要求期望伤害，不难想到用每张牌的发动概率$g[i]$乘那张牌的伤害$d[i]$，最后根据期望的线性性质相加即可，故答案为

#### $\sum_{i=1}^ng[i]d[i]$

可怎么求$g[i]$呢？

首先不难求出$g[1]$，即第一张牌的发动概率，为

#### $g[1]=1-(1-p[1])^r$

再讨论第二张牌：

若之前第$1$张牌发动了技能，那第一轮肯定轮不到第二张牌发动，所以第二张牌发动的概率为

$1-(1-p[2])^{r-1}$

若之前第一张牌没有发动技能，那么第二张牌发动的概率为

$1-(1-p[2])^r$

欸，如果我们考虑第$i$张牌时知道$1$~$i-1$这i-1张牌中已经有j张牌发动过技能了，那么第$i$张牌此时发动的概率就应该等于$1-(1-p[i])^{r-j}$

我们构建一个$dp$模型：设$f[i][j]$为前$i$张牌恰好有j张发动技能的概率

若第$i$张牌发动了，那么
$f[i][j]=f[i-1][j-1]*(1-(1-p[i])^{r-j+1})[j>0]$

若第$i$张牌没发动，那么
$f[i][j]=f[i-1][j]*(1-p[i])^{r-j}[i\ne j]$

$dp$转移方程出来啦，附上这一部分的代码：
```cpp
for(int i=2;i<=n;i++){
	for(int j=0;j<=Min(i,r);j++){
		if(j)//第i张牌发动 
		f[i][j]+=f[i-1][j-1]*(1.0-Pw[i][r-j+1]);
		if(i!=j)//第i张牌不发动 
		f[i][j]+=f[i-1][j]*Pw[i][r-j];
	}
}
```

我们得出了所有的$f[i][j]$，那怎么求每张牌发动的概率$g[i]$呢？

$g[i]$应该为$\sum_{j=0}^{i-1}f[i-1][j]*(1-(1-p[i])^{r-j})$，即前1~i-1张牌中有j张牌发动的概率乘第i张牌发动的概率

这样，我们就愉快地A了这道题(有些细节见代码里的注释）

 _Code_ :
 ```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 225
#define R 137

int n,r,t;
int D[N];//伤害
double P[N],f[N][R],g[N],Pw[N][R];
//P[i]表示第i张牌发动技能的概率
//f[i][j]表示前i张牌恰好有j张发动的概率
//g[i]表示第i张牌在r轮中发动的概率
//Pw[i][j]预处理,即(1-P[i])^j,第i张牌在最后j轮都不发动的概率 

int Min(int x,int y){return x<y?x:y;}

void read(){
	scanf("%d%d",&n,&r);
	for(int i=1;i<=n;i++){
		scanf("%lf%d",&P[i],&D[i]);
		Pw[i][0]=1; 
	}
}

void work(){
	if(!r){
		printf("%.10lf",g[0]);//即0
		return;
	}//当r等于0时代表没有进行游戏,输出0 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=r;j++){
			Pw[i][j]=Pw[i][j-1]*(1.0-P[i]);
		}
	}//预处理 
	f[1][0]=Pw[1][r];
	f[1][1]=1.0-f[1][0];
	g[1]=f[1][1];//初始化 
	for(int i=2;i<=n;i++){
		for(int j=0;j<=Min(i,r);j++){
			if(j)//第i张牌发动 
				f[i][j]+=f[i-1][j-1]*(1.0-Pw[i][r-j+1]);
			if(i!=j)//第i张牌不发动 
				f[i][j]+=f[i-1][j]*Pw[i][r-j];
		}
	}
	for(int i=2;i<=n;i++){
		for(int j=0;j<=Min(i-1,r);j++){
			g[i]+=f[i-1][j]*(1.0-Pw[i][r-j]);
		}
	}//统计第i张牌在所有r轮中发动的概率 
	double ans=0;
	for(int i=1;i<=n;i++)ans+=g[i]*D[i];//期望得分,第i张牌发动的概率乘伤害 
	printf("%.10lf\n",ans);
}

int main(void){
	scanf("%d",&t);
	while(t--){
		memset(g,0,sizeof(g));
		memset(f,0,sizeof(f));//记得重置f,g数组 
		read();
		work();
	}
	return 0;
}
```

($p.s.$：本人第一道非红题题解，望兹磁)

---

## 作者：arfa (赞：3)

第二道概率 $DP$。

显然每一张牌在一次中是只能选一次的。

期望: $$\sum\limits^{N}_{i=1} g_i \times d_i$$,其中 $g_i$ 为第 $i$ 张牌在 $r$ 轮中使用的总概率。

其中设 $f_{i,j}$ 为在第 $i$ 轮中(一共跑了 $i$ 张牌)选了 $j$ 张牌的概率。那么 $$g_i+=\sum\limits^{\ min\{i-1,r-1\}}_{j=0}f_{i-1,j} \times (1-(1-p_i)^{r-j})$$

其中 $f_{i,j}$ 要分情况转移:

- 选: $$f_{i,j}+=f_{i-1,j-1} \times (1-(1-p_i)^{r-j+1}))$$

- 不选: $$f_{i,j}+=f_{i-1,j} \times (1-p_i)^{r-j})$$

我们先预处理 $times_{i,j}$ 代表第 $(1-p_i)^j$ 的值。最后统计答案即可。(注意,如果按照我的做法要判 $r=0$ 的情况)


```pascal
// luogu-judger-enable-o2
Uses math;

var
    times:array[-1..300,-1..300] of extended;
    fuck:array[-1..300,-1..300] of extended;
    proba,g:array[-1..5100] of extended;
    attack:array[-1..5100] of longint;
    i,j,n,r,text:longint;
    ans:extended;

procedure Work;
begin
    fillchar(times,sizeof(times),0);
    fillchar(fuck,sizeof(fuck),0);
    fillchar(g,sizeof(g),0);
    read(n,r); ans:=0;
    if (n=0)or(r=0) then begin writeln(ans:0:10); exit; end;
    for i:=1 to n do read(proba[i],attack[i]);
    for i:=1 to n do times[i,1]:=1-proba[i];
    for i:=1 to n do for j:=2 to r do times[i,j]:=times[i,j-1]*(1-proba[i]);
    fuck[1,0]:=times[1,r]; fuck[1,1]:=1-times[1,r]; g[1]:=fuck[1,1];
    for i:=2 to n do for j:=0 to min(i,r) do
    begin
        fuck[i,j]:=fuck[i,j]+fuck[i-1,j-1]*(1-times[i,r-j+1]);
        fuck[i,j]:=fuck[i,j]+fuck[i-1,j]*times[i,r-j];
    end;
    for i:=2 to n do for j:=0 to min(i-1,r-1) do g[i]:=g[i]+fuck[i-1,j]*(1-times[i,r-j]);
    for i:=1 to n do ans:=ans+g[i]*attack[i]; writeln(ans:0:10);
end;

begin
    read(text);
    repeat
        dec(text); Work;
    until text=0;
end.
```

---

## 作者：哈撒各一 (赞：1)

首先对于一道 DP 题目，我们要多观察题面,因为状态表示，状态转移都在题目中。

**首先第一次观察题面，寻找状态表示**

寻找题目中有用的参数:

* 进行到的游戏轮数。

* 用出的技能数。

* 用的最大编号的卡牌。

* 期望打出的伤害。

但是我们使用这些作为状态表示时都会发现都有后效性。

因为从左到右选取技能使用。

每次选出的技能不一样。

那么每个技能发动的概率就不一样。

所以现在的 DP 题不能惯着。

软的不行我们就直接来硬的。

我们强行规定 $ f_{i,j} $ 为第 $ j $ 轮前只能使用前 i 个技能的概率 。

那么很显而易见的我们第 i+1 个技能不能在前 j 轮里使用。

他在后 r-j 轮里不用到的概率就是 $ f_{i,j} * (1-p_{i+1}^{r-j}) $ 。

他在后 r-j 轮里用到的概率就是 $ f_{i,j} * p_{i+1}^{r-j} $ 。

综上所诉 。

我们的状态表示就是 $ f_{i,j} $ 前 j 轮只用到前 i 个技能的概率。

然后根据上述对于第 i+1 个技能使用情况的分析，也可以~~很~~不太轻松的写出状态转移方程。

 $ f_{i+1,j} += f_{i,j} * (1-p_{i+1}^{r-j}) $
 
 * 因为这样表示第 i+1 个技能一直没有机会打出来，所以很明显是包括于区间 $f_{i+1,j} $ 中的。
 
 $ f_{i+1,j+1} += f_{i,j} * p_{i+1}^{r-j} $
 
 * 对于这种情况，i+1 号技能不论是在 j+1 轮打出来,还是在 j+1 轮以后打出来，都是包括于区间 $ f_{i+1,j+1} $ 中的。
 
 那么对于概率的更新就只有这些，但是题目要求我们求得是期望伤害。
 
 $ ans += f_{i,j} * p_{i+1}^{r-j} $
 
 * 每次加表示第 j 轮发动第 i+1 号技能的期望伤害。
 
**CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 225
#define tps 1e-12
int T,n,r;
int d[N];
double p[N],f[N][N];
inline void init(){
	memset(f,0,sizeof(f));
}
inline double qpow(double x,int y){
	double ans=1;
	while(y){
		if(y&1)ans*=x;
		x*=x;
		y>>=1;
	}
	return ans;
}
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	cin>>T;
	while(T--){
		scanf("%d%d",&n,&r);
		init();
		for(int i=1;i<=n;++i){
			scanf("%lf%d",p+i,d+i);
		}
		f[0][0]=1;
		double ans=0;
		for(int i=0;i<n;++i){
			int un=min(i,r);
			for(int j=0;j<=un;++j){
				double poww=qpow(1-p[i+1],r-j);
				f[i+1][j]+=poww*f[i][j];//因为poww是i+1在j之后不发动的概率
				//既然f[i][j]不发动i+1,那么f[i+1][j]理所因当可以加上全程不发动
				//i+1的概率 
				if(j+1<=r){
					f[i+1][j+1]+=(1-poww)*f[i][j];
					//(1-poww)是j之后发动i+1的概率,因为发动i+1需要一轮,所以第二位j要+1
					//所以f[i+1][j+1]理所因当加上j轮之后发动i+1的概率 
					ans+=f[i][j]*(1-poww)*d[i+1];
					//这里ans加上的就是第j+1轮发动i+1的期望伤害, 
				}
			}
		}
		printf("%.10lf\n",ans);
	}
	return 0;
}
```


---

## 作者：QiFeng233 (赞：1)

很有意思的一道期望Dp。
# 思路分析
根据期望的定义，设每张牌在 $r$ 轮里发动的概率是 $g_i$，那么总伤害的期望就是 $\sum g_id_i$。

我们先来看 $g_1$：直接求不是很好求，不妨正难则反地看一下，那么 $g_1=1-(1-p_1)^r$，也就是用1减去它不发动的概率。

接下来来看 $g_2$：如果第一张牌在某一轮发动过了，那么那一轮第二张牌就不会发动了，否则就同上。即：

$g_2=(1-p_1)^r(1-(1-p_2)^r)+(1-(1-p_1)^r)(1-(1-p_2)^{r-1})$

这启示我们：某一张牌发动的概率是和前边的牌的发动与否、发动了几张牌有关的。

一般地，设 $f_{ij}$ 代表前 $i$ 张牌在总共 $r$ 轮发动了 $j$ 次的概率，有：

$g_i=\sum\limits_{j=0}^{\min(i-1,r)}f_{i-1,j}(1-(1-p_i)^{r-j})$

至于 $f$ 的递推嘛，分第 $i$ 张牌选和不选，可以得到：

$f_{ij}=(1-p_i)^{r-j}f_{i-1,j}+(1-(1-p_i)^{r-j+1})f_{i-1,j-1}$

实现细节略有不同。

至此，本题结束。

# 代码时间
```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
namespace QiFeng233{
	const int maxn=250;
	double f[maxn][maxn],p[maxn],d[maxn],g[maxn];
	int t,n,r;
	double min(double a,double b){
		return a<b?a:b;
	}
	void solve(){
		scanf("%d",&t);
		while(t--){
			memset(g,0,sizeof(g));
			memset(f,0,sizeof(f));
			scanf("%d%d",&n,&r);
			for(int i=1;i<=n;++i)scanf("%lf%lf",&p[i],&d[i]);
			if(!r){
				printf("0.0000000000");
				continue; 
			}
			f[1][0]=pow(1.0-p[1],r);
			f[1][1]=1-f[1][0];
			g[1]=f[1][1];
			for(int i=2;i<=n;++i){
				for(int j=0;j<=min(i,r);++j){
					//这里与上边所述略有不同，因为一个是要保证不越界(j-1>=0)，另一个是因为j=i时蕴含了第i张牌一定被选 
					if(j)f[i][j]+=(1.0-pow(1.0-p[i],r-j+1))*f[i-1][j-1];
					if(j!=n)f[i][j]+=pow(1.0-p[i],r-j)*f[i-1][j];
					g[i]+=f[i-1][j]*(1.0-pow(1.0-p[i],r-j));
				}
			}
			double ans=0;
			for(int i=1;i<=n;++i)ans+=g[i]*d[i];
			printf("%.10lf\n",ans);
		}
	} 
}
signed main(){
	QiFeng233::solve();
	return 0;
}
```

# 反思总结
这题有一定思维难度，是一道很有意思的期望Dp。

求解$g$和$f$数组都是用了正难则反的思路——用1减去出不了的概率。

---

## 作者：suxxsfe (赞：1)

同[bzoj4008](http://www.lydsy.com/JudgeOnline/problem.php?id=4008)  

## 题目描述
小 K 不慎被 LL 邪教洗脑了，洗脑程度深到他甚至想要从亚瑟王邪教中脱坑。他决定，在脱坑之前，最后再来打一盘亚瑟王。既然是最后一战，就一定要打得漂亮。众所周知，亚瑟王是一个看脸的游戏，技能的发动都是看概率的。  

作为一个非洲人，同时作为一个前 OIer，小 K 自然是希望最大化造成伤害的期望值。但他已经多年没写过代码，连 Spaly都敲不对了，因此，希望你能帮帮小 K，让他感受一下当欧洲人是怎样的体验。  

本题中我们将考虑游戏的一个简化版模型。 玩家有一套卡牌，共$n$ 张。游戏时，玩家将$n$ 张卡牌排列成某种顺序，排列后将卡牌按从前往后依次编号为 $1 - n$。本题中，顺序已经确定，即为输入的顺序。每张卡牌都有一个技能。第$ i$ 张卡牌的技能发动概率为 $p_i$ ，如果成功发动，则会对敌方造成 $d_i$点伤害。也只有通过发动技能，卡牌才能对敌方造成伤害。基于现实因素以及小 K 非洲血统的考虑，$p_i$不会为$0$，也不会为$1$，即 $0 < p_i < 1$  

一局游戏一共有$r$ 轮。在每一轮中，系统将从第一张卡牌开始，按照顺序依次考虑每张卡牌。在一轮中，对于依次考虑的每一张卡牌：

如果这张卡牌在这一局游戏中已经发动过技能，则  
- 如果这张卡牌不是最后一张，则跳过之（考虑下一张卡牌） 
- 否则（是最后一张），结束这一轮游戏。


否则（这张卡牌在这一局游戏中没有发动过技能），设这张卡牌为第$i$张  
- 将其以$p_i$的概率发动技能。

- 如果技能发动，则对敌方造成$d_i$点伤害，并结束这一轮。

- 如果这张卡牌已经是最后一张（即$i=n$），则结束这一轮；否则，考虑下一张卡牌。  


请帮助小 K 求出这一套卡牌在一局游戏中能造成的伤害的期望值。

----------------  

## 题解  
将期望转换为概率  
如果第$i$张被打出的概率是$s_i$，那答案显然是$\sum_{i=1}^n s_i d_i$  

下面求$s_i$
因为每轮只能有**一张牌**发动，所以将$r$轮视为$r$个出牌机会  
~~一开始居然没看见这点，以为是个水题~~  
考虑设计状态为$f_{i,j}$，表示前$i$个牌，还剩$j$个机会**没用**的概率  
那如何转移？   
比如现在正在考虑第$i$个牌，如果选这一个，很显然机会要减一，可以由：  
$$f_{i-1,j+1}(1-(1-p_i)^{j+1})$$  
转移而来，其中，$(1-p_i)^{j+1}$就是剩下$j+1$次机会都不用$i$的概率，然后再用一减它，就是这$j+1$次机会中至少让它发动一次的概率  

如果不选，机会不变，可以由：  
$$f_{i-1,j}(1-p_i)^{j}$$  
转移而来，结合上面的阐述，$(1-p_i)^{j}$就是$i$在剩下$j$次机会中都不能被用的概率  

最后考虑如何从$f$向$s$转换   
$$s_i=\sum_{j=1}^r f_{i-1,j+1}(1-(1-p_i)^{j+1})$$  
也就是已经选好前$i-1$个牌，剩余任意（不为0）次机会，再乘上刚才说的$(1-(1-p_i)^{j+1})$就行了  

最后，多测不清零，40分两行泪  
另外清零的时候要清的比实际范围大一点，因为会访问超出实际范围的下标，看代码就知道了  

```cpp  
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<iomanip>
#include<cstring>
#define reg register
#define EN std::puts("")
#define LL long long
inline int read(){
	int x=0,y=1;
	char c=std::getchar();
	while(c<'0'||c>'9'){if(c=='-') y=0;c=std::getchar();}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=std::getchar();}
	return y?x:-x;
}
int n,r;
double f[250][250];//f[i][j]为前i张还剩j次机会的概率 
double p[250];
int d[250];
double power[250][250];
int main(){int T=read();while(T--){
	n=read();r=read();
	for(reg int i=1;i<=n;i++){
		std::scanf("%lf",p+i);d[i]=read();
		p[i]=1-p[i];power[i][0]=1;power[i][r+1]=0;
		for(reg int j=1;j<=r;j++)
			power[i][j]=power[i][j-1]*p[i];
	}
	reg double ans=0;
	for(reg int i=0;i<=240;i++)for(reg int j=0;j<=240;j++)f[i][j]=0;
	f[0][r]=1;
	for(reg int i=1;i<=n;i++){
		reg double s=0;
		for(reg int j=r;~j;j--){
			f[i][j]=f[i-1][j]*power[i][j];
			f[i][j]+=f[i-1][j+1]*(1-power[i][j+1]);
			s+=f[i-1][j+1]*(1-power[i][j+1]);
		}
		ans+=s*d[i];
	}
	std::printf("%.10lf\n",ans);
}
	return 0;
}
```

---

## 作者：Gypsophila (赞：1)

### Description 

有 $n$ 张卡牌，$r$ 局游戏，每张卡牌有 $p_i$ 的概率发动技能，如果发动会造成 $d_i$ 的伤害。每局游戏从第一张卡牌开始开始一个个遍历，如果发动过技能则忽略继续；否则如果这张卡牌现在发动了，则结束回合；没有发动则继续。求造成的总伤害的期望。

### Solution 

可以想象成把 $r$ 个机会分配给每一张卡牌。$dp[i][j]$ 表示前 $i$ 张还剩 $j$ 个机会的答案 
$$
dp[i][j] = dp[i-1][j] \cdot (1-p[i])^j+dp[i-1][j+1]\cdot (1-(1-p[i])^{j+1})
$$
前半部分可以理解成在 $j$ 轮没有一次触发，后半部分就是至少一次触发。并且后半部分因为出触发了所以对答案有贡献，所以在 dp 的时候顺便把 ans 加上后半部分 * $d_i$ 

### Code

[看代码戳这里](https://acfunction.github.io/2019/03/22/BZOJ4008/)

---

## 作者：pomelo_nene (赞：0)

手玩样例，发现期望就是每张牌 $i$ 最终使用的概率 $pro_i$ 乘上 $d_i$。

直接计算每张牌使用的概率吗？这样似乎没有合理的转移方法。考虑定义 $dp_{i,j}$ 为前 $i$ 张牌用了 $j$ 张卡牌的概率（有一个用到了就不能继续的限制），所以这么定义还是挺合情合理的。

先考虑我们已经计算出了 $dp$ 值。对于 $pro_1$，其肯定等于 $1-(1-p_i)^r$。再计算其他的，根据定义可以得到：

$$
pro_i = \sum_{j=0}^r dp_{i-1,j} \times (1- (1-p_i)^{r-j})
$$

解释这个方程：我们已经在前 $i-1$ 张牌选择了 $j$ 张牌，后面的 $r-j$ 轮我们都会考虑到卡牌 $i$，其不选的概率显然为 $1-(1-p_i)^{r-j}$。

答案就是 $\displaystyle \sum_{i=1}^n pro_i \times d_i$。

考虑计算 $dp$。我们的情况只有成功选择一个卡牌和选择卡牌失败两种情况。分类讨论得到 $dp$ 方程：

$$
dp_{i,j}=dp_{i-1,j} \times (1-p_i)^{r-j}+dp_{i-1,j-1} \times (1-(1-p_i)^{r-j+1})
$$

方程的意思是说，我们在加入第 $i$ 张牌失败，就从 $dp_{i-1,j}$ 转移过来，概率为 $(1-p_i)^{r-j}$；否则成功，从 $dp_{i-1,j-1}$ 转移，概率为 $1-(1-p_i)^{r-j}$。

考虑初值，我们发现只有选第一张牌的时候需要处理一下。定义可得 $dp_{1,0}=(1-p_1)^r,dp_{1,1}=1-(1-p_1)^r$。

鉴于 `pow` 函数的高效，这里将所有的 ${(1-p_i)}^{x}$ 全部预处理出来了。大概比 `pow` 快个 0.5s。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long double LB;
LB dp[222][222],p[222],d[222],pw[222][222];
int main(){
	int T;
	scanf("%d",&T);
	while(T-->0)
	{
		int n,r;
		scanf("%d %d",&n,&r);
		for(int i=1;i<=n;++i)	scanf("%Lf %Lf",&p[i],&d[i]),pw[i][0]=1;
		for(int i=1;i<=n;++i)	for(int j=1;j<=r;++j)	pw[i][j]=pw[i][j-1]*(1-p[i]);
		memset(dp,0,sizeof dp);
		LB ans=(1-pw[1][r])*d[1];
		dp[1][0]=pw[1][r],dp[1][1]=1-pw[1][r];
		for(int i=2;i<=n;++i)
		{
			for(int j=0;j<=min(r,i);++j)
			{
				if(j)	dp[i][j]+=dp[i-1][j-1]*(1-pw[i][r-j+1]);
				dp[i][j]+=dp[i-1][j]*pw[i][r-j];
			}
		}
		for(int i=2;i<=n;++i)
		{
			LB prob=0;
			for(int j=0;j<=min(i-1,r);++j)	prob+=dp[i-1][j]*(1-pw[i][r-j]);
			ans+=prob*d[i];
		}
		printf("%.10Lf\n",ans);
	}
	return 0;
}
```

---

## 作者：MikukuOvO (赞：0)

考虑到如果一个卡牌发动就会直接结束轮次，我们就不能按轮次考虑问题。

我们换一种角度，我们以每一张卡牌为对象。

定义$f[i][j]$表示第$i$张卡牌有$j$次机会发动的概率。

考虑转移，由于$i-1$张卡牌至少有$j$次机会发动：

如果$i-1$消耗了一次机会，那么我们枚举哪次使用了这次机会：

$p_{i-1}+(1-p_{i-1}) \times p_{i-1}+(1-p_{i-1})^2 \times p_{i-1}+...+(1-p_{i-1})^j \times p_{i-1}$

对于这个求个和：

$\frac{p_{i-1}(1-(1-p_{i-1})^{j+1})}{p_{i-1}}$

如果没有消耗，那么就是$(1-p_{i-1})^j$。

最终转移式为：

$f[i][j]=f[i-1][j+1] \times (1-(1-p_{i-1})^{j+1})+f[i-1][j] \times (1-p_{i-1})^j$

答案就是：

$ans= \sum_{i=1}^{n} \sum_{j=1}^{r} f[i][j] \times (1-(1-p_i)^{j}) \times d_i$

记忆化搜索实现即可，代码：

```cpp
const int N=255;

int T,n,m;
bool vis[N][N];
db f[N][N],p[N];
int d[N];

db qpow(db x,int y)
{
    db res=1;
    while(y)
    {
        if(y&1) res=res*x;
        x=x*x;
        y>>=1;
    }
    return res;
}
db calc(int i,int j)
{
    if(vis[i][j]) return f[i][j];
    if(!i) return 0;
    if(j>m) return 0;
    f[i][j]+=calc(i-1,j+1)*(1-qpow(1-p[i-1],j+1))+calc(i-1,j)*qpow(1-p[i-1],j);
    vis[i][j]=true;
    return f[i][j];
}
int main()
{
    fio();
    gi(T);
    while(T--)
    {
        gi(n),gi(m);
        ms(f),ms(vis),f[0][m]=1,vis[0][m]=true;
        for(int i=1;i<=n;++i) scanf("%lf%d",&p[i],&d[i]);
        db ans=0;
        for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) ans+=calc(i,j)*(1-qpow(1-p[i],j))*d[i];
        printf("%.10lf\n",ans);
    }
    end();
}
```

---

## 作者：Morning_Glory (赞：0)

[也许更好的阅读体验](https://www.cnblogs.com/Morning-Glory/p/11225947.html)	
# $\mathcal{Description}$	
给出$n$个技能，每个技能按输入顺序有$p[i]$的概率释放并造成$d[i]$的伤害。每轮游戏从前往后顺序查看每个技能，若技能发动过则跳过，没发动过则以$p[i]$的技能发动，即每个技能只能发动一次，若将一个技能发动，则进行下一轮游戏，没有成功发动或被跳过就查看下一个技能，一轮游戏可能每个技能都不发动，问$r$轮游戏一共能造成的伤害期望。	
	
输入方式	
T组数据	
接下来组数据	
每组数据第一行$n,r$	
接下来$n$行$p_i,d_i$表示该技能发动概率以及伤害	
	
1 <= T <= 444， 1 <= n <= 220， 0 <= r <= 132， 0 < p_i < 1， 0 <= d_i <= 1000	
	
输出格式	
每组数据输出一行期望伤害，建议保留$10$位小数	
# $\mathcal{Solution}$	
因为有一个顺序查看的限制，没有后效性的状态是十分不好设的，因为不知道前面有几个技能发动了，若一个技能前面的技能在某轮发动了，则该技能本轮一定不能发动，若前面有些技能发动过，则它们都会被跳过 	
为了解决这种情况，我们设状态时试着强制限制技能发动（$nr$枚举情况），当然，设的状态仍然要满足 __所有__ 情况都考虑在内	
设$f[i][j]$表示对前$i$个技能进行了$j$轮游戏造成的 __概率__	
若有前$i$个技能进行了$j$	
则有$j$轮不会考虑第$i+1$个技能	
即有$r-j$轮游戏选择了$i$之后的技能	
此时考虑第$i+1$个技能的情况，分为两种	
 1. 有$p[i+1]^{r-j}$的概率$i+1$号技能从未发动	
 2. 有$1-p[i+1]^{r-j}$的概率$i+1$号技能发动过	
	
需要注意的是，此时 __已经__ 确定前$i$个技能进行并 __只进行__ 了$j$轮游戏，其概率应该也计算在内	
所以有	
	
 1. $f[i+1][j]+=1-p[i+1]^{r-j}f[i][j]$	
 2. $f[i+1][j+1]+=(1-p[i+1]^{r-j})f[i][j]$	
	
$j+1$要小于等于$r$	
	
初值$f[0][0]=1$，答案在中途计算	
	
计算了概率，别忘了求的是期望伤害，在求概率的时候顺便用概率乘以伤害	
	
# $\mathcal{Code}$	
	
```cpp	
/*******************************	
Author:Morning_Glory	
LANG:C++	
Created Time:2019年07月22日 星期一 14时17分22秒	
*******************************/	
#include <cstdio>	
#include <fstream>	
#include <algorithm>	
#include <cmath>	
using namespace std;	
const int maxn = 255;	
int T,n,r;	
double ans;	
double p[maxn],d[maxn];	
double f[maxn][maxn];	
int main()	
{	
	scanf("%d",&T);	
	while (T--){	
		scanf("%d%d",&n,&r);	
		for (int i=1;i<=n;++i)	scanf("%lf%lf",&p[i],&d[i]);	
		for (int i=0;i<=n;++i)	
			for (int j=0;j<=r;++j)	
				f[i][j]=0;	
		ans=0,f[0][0]=1;	
		for (int i=0;i<=n-1;++i){	
			int k=min(i,r);	
			for (int j=0;j<=k;++j){	
				double tmp=pow(1-p[i+1],r-j);	
				f[i+1][j]+=f[i][j]*tmp;	
				if (j+1<=r){	
					f[i+1][j+1]+=f[i][j]*(1-tmp);	
					ans+=f[i][j]*(1-tmp)*d[i+1];//计算第i+1张牌造成的期望伤害	
				}	
			}	
		}	
		printf("%.10lf\n",ans);	
	}	
	return 0;	
}	
```	
	
本篇博客亦被收进[期望总结](https://blog.csdn.net/Morning_Glory_JR/article/details/96731105)		


---


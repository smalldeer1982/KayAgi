# [HNOI2015] 落忆枫音

## 题目背景

「恒逸，你相信灵魂的存在吗？」 郭恒逸和姚枫茜漫步在枫音乡的街道上。望着漫天飞舞的红枫，枫茜突然问出这样一个问题。

「相信吧。不然我们是什么，一团肉吗？要不是有灵魂......我们也不可能再见到你姐姐吧。」 恒逸给出了一个略微无厘头的回答。枫茜听后笑了笑。 「那你仔细观察过枫叶吗？」 说罢，枫茜伸手，接住了一片飘落的枫叶。

「其实每一片枫叶都是有灵魂的。你看，枫叶上不是有这么多脉络吗？我听说，枫叶上有一些特殊的位置，就和人的穴位一样。脉络都是连接在这些穴位之间的。枫树的灵魂流过每片枫叶的根部，沿着这些脉络，慢慢漫进穴位，沁入整片枫叶。也是因为这个原因，脉络才都是单向的，灵魂可不能倒着溜回来呢。」 恒逸似懂非懂地点了点头。枫茜接着说了下去。

「正是因为有了灵魂，每片枫叶才会与众不同。也正是因为有了灵魂，每片枫叶也都神似其源本的枫树，就连脉络也形成了一棵树的样子。但如果仔细看的话，会发现，在脉络树之外，还存在其它的非常细的脉络。虽然这些脉络并不在树上，但他们的方向也同样顺着灵魂流淌的方向，绝不会出现可能使灵魂倒流的回路。」  恒逸好像突然想到了什么。 「那这些脉络岂不是可以取代已有的脉络，出现在脉络树上？」 枫茜闭上了眼睛。

「是啊，就是这样。脉络树并不是唯一的。只要有一些微小的偏差，脉络树就可能差之万里，哪怕是在这同一片枫叶上。就像我们的故事，结局也不是唯一的。只要改变一个小小的选项，故事流程可能就会被彻底扭转。」

「真是深奥啊......」 恒逸盯着这片红枫，若有所思地说。枫茜继续说道。

「还不止如此呢。所有的脉络都不会永恒存在，也不会永恒消失。不管是脉络树上的脉络，还是之外的细小脉络，都是如此。存在的脉络可能断开消失，消失的脉络也可能再次连接。万物皆处在永恒的变化之中，人与人之间的羁绊也是。或许有一天，我们与大家的羁绊也会如同脉络一样，被无情地斩断。或许我们也终将成为”枫音乡的过客“。或许这一切都会是必然，是枫树的灵魂所决定的......」

枫茜的眼角泛起了几滴晶莹剔透的泪珠。恒逸看着这样的枫茜，将她抱入怀中。

「别这样想，枫茜。就算脉络断开，也有可能还会有新的脉络树，也还会与枫树的根相连。这样的话，我们的羁绊仍然存在，只是稍微绕了一些远路而已。无论如何，我都不会离开你的。因为你是我穷尽一生所寻找的，我的真恋啊！」

两人的目光对上了。枫茜幸福地笑了，把头埋进了恒逸的怀抱。从远方山上的枫林中，传来了枫的声音。

## 题目描述

不妨假设枫叶上有 $n$ 个穴位，穴位的编号为 $1\sim n$。有若干条有向的脉络连接着这些穴位。

穴位和脉络组成一个有向无环图——称之为**脉络图**（例如图 $1$），穴位的编号使得穴位 $1$ 没有从其他穴位连向它的脉络，即穴位 $1$ 只有连出去的脉络；由上面的故事可知，这个有向无环图存在一个树形子图，它是以穴位 $1$ 为根的包含全部 $n$ 个穴位的一棵树——称之为**脉络树**（例如图 $2$ 和图 $3$ 给出的树都是图 $1$ 给出的脉络图的子图）。

值得注意的是，脉络图中的脉络树方案可能有多种可能性，例如图 $2$ 和图 $3$ 就是图 $1$ 给出的脉络图的两个脉络树方案。

 ![](https://cdn.luogu.com.cn/upload/pic/11330.png) 

脉络树的形式化定义为：以穴位 $r$ 为根的脉络树由枫叶上全部 $n$ 个穴位以及 $(n-1)$ 条脉络组成，脉络树里没有环，亦不存在从一个穴位连向自身的脉络，且对于枫叶上的每个穴位 $s$，都存在一条唯一的包含于脉络树内的脉络路径，使得从穴位 $r$ 出发沿着这条路径可以到达穴位  $s$。 

现在向脉络图添加一条与已有脉络不同的脉络（**注意：连接 $2$ 个穴位但方向不同的脉络是不同的脉络**，例如从穴位 $3$ 到 $4$ 的脉络与从 $4$ 到 $3$ 的脉络是不同的脉络，因此，图 $1$ 中不能添加从 $3$ 到 $4$ 的脉络，但可添加从 $4$ 到 $3$ 的脉络）。这条新脉络**可以是从一个穴位连向自身的**（例如，图 1 中可添加从 $4$ 到 $4$ 的脉络）。

原脉络图添加这条新脉络后得到的新脉络图可能会出现脉络构成的环。 请你求出添加了这一条脉络之后的新脉络图的以穴位 $1$ 为根的脉络树方案数。

由于方案可能有太多太多，请输出方案数对 $(10^9+7)$ 取模后得到的结果。

## 说明/提示

对于所有测试数据，保证：

- $1 \leq n \leq 100000$；
- $n - 1 \leq m \leq \min(200000, n(n -1)/2)$；
- $1 \leq x, y, u_i, v_i \leq n$。

Fixed by Starrykiller.

## 样例 #1

### 输入

```
4 4 4 3
1 2
1 3
2 4
3 2```

### 输出

```
3```

# 题解

## 作者：litble (赞：32)

**组合计数+dp**

对于DAG来说，考虑每个点的父亲，令du(x)表示x的入度，则答案是$\prod du(i)$

现在加了一条边，可能是环了，我们就要考虑从$\prod du(i)$里减去成环的情况。假设一个大小为$k$的环含有节点$a_1,a_2...a_k$，除了这个环以外的节点的父亲随意选取，那么要减去的值就是

$$\frac{\prod du(i)}{\prod_{i=1}^k du(a_i)}$$

记新加的边为(s,t)

考虑用dp完成，令g(x)表示从t到x的路径上，上面式子里的这个值，那么$g(x)=\frac{1}{du(x)}(\sum g(y))$（y可达x）。由于原图是DAG，直接在原图上记忆化搜索即可。

答案就是$\sum du(i) - g(s)$了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
	int q=0;char ch=' ';
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') q=q*10+ch-'0',ch=getchar();
	return q;
}
#define RI register int
const int mod=1000000007,N=100005,M=200005;
int n,m,xx,yy,ans=1,tot,dsum=1;
int h[N],ne[M],to[M],du[N],g[N],vis[N];
void add(int x,int y) {to[++tot]=y,ne[tot]=h[x],h[x]=tot;}
int ksm(int x,int y) {
	int re=1;
	for(;y;y>>=1,x=1LL*x*x%mod) if(y&1) re=1LL*re*x%mod;
	return re;
}
void dfs(int x) {
	if(vis[x]) return;
	vis[x]=1;
	if(x==yy) {g[x]=1LL*dsum*ksm(du[x],mod-2)%mod;return;}
	for(int i=h[x];i;i=ne[i])
		dfs(to[i]),g[x]=(g[x]+g[to[i]])%mod;
	g[x]=1LL*g[x]*ksm(du[x],mod-2)%mod;
}
int main()
{
	int x,y;
	n=read(),m=read(),xx=read(),yy=read();
	for(RI i=1;i<=m;++i)
		x=read(),y=read(),add(y,x),++du[y];
	++du[1];
	for(RI i=1;i<=n;++i) {
		if(i==yy) ans=1LL*(du[i]+1)*ans%mod;
		else ans=1LL*du[i]*ans%mod;
		dsum=1LL*du[i]*dsum%mod;
	}
	dfs(xx);
	ans=(ans+mod-g[xx])%mod;
	printf("%d\n",ans);
    return 0;
}
```


---

## 作者：ButterflyDew (赞：14)

这篇题解可能好理解一点？

设每个点入度是$d_i$，如果不加边，答案是
$$
\prod_{i=2}^nd_i
$$
意思是我们给每个点选一个父亲

然后我们加了一条边，最后如果还这么统计，那么有一些不合法的图是$y,\dots,x$形成了一个环，考虑把所有环的方案减掉。

考虑枚举环上的点集$S$，答案为

$$\sum_S\prod_{i\not=s}d_i$$

意思是环上的点钦定父亲，其他的点照旧统计

这个方案数可以dp，设$dp_i$表示$i,\dots,x$形成的环的答案

那么初始值有

$$dp_x=\prod_{i\not=x}d_i$$

然后每个点加入环的时候除上自己的入度，也就是

$$dp_u=\frac{\sum\limits_{(u,v)\in E}dp_v}{d_u}$$

然后这个dp直接在topo图上记搜就可以了

---

## 作者：HRLYB (赞：14)

>[P3244[HNOI2015]落忆枫音](https://www.luogu.org/problem/P3244)


样例太坑了！竟然和题目描述给的图不一样！

## 题目描述

给定一张有向无环图，这张图满足一个性质：以点1为根节点，保证至少有一棵有向树，连接所有的节点.

现在向这张图中新增一条给定的有向边，求增加这条有向边之后，有向无环图中的有向树的数量.

答案可能会很大，所以要对$1e9+7$取模.

## 题目解析

首先，我们有这样一个定理：

>朱刘定理：一张有向无环图上，生成树的数量为$∏du[i]$，其中$du[i]$表示一个点的入度.

证明：显然在构建生成树时，每个点被选择的方法数就是这个点的入度，由乘法原理可知，不同生成树的数量就是$∏du[i]$.

-----

但是，加入一条有向边后的新图，可能会出现环. 由于树上是没有环的，所以如果我们直接用$∏du[i]$作为生成树的数量，可能会多算环的情况，导致答案错误.

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190912170641501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzY1NzEx,size_16,color_FFFFFF,t_70#pic_center)

_如图，左边为原图，右边为增加了一条边的图. 可以发现，按照朱刘定理算出来的值为4，多计算了$2->4->3->2$的情况._

怎么办？当然是消除影响了！

-------

>假设添加的一条边是$s->t$，那么不在原图$t->s$路径上的点的入度的乘积之和就是出现环的方案数.

我们假设当前从原图$t->s$的路径经过了节点$a_1,a_2...a_k$，这条路径总共有$k$条边.

显然剩下的$n-k$个节点就有$n-k-1$条边.

而根据我们的朱刘算法，剩下的$n-k$个节点组合成的生成树的数量就是$∏du[w]$，$w$表示不在当前原图$t->s$的路径上的点.

同样根据朱刘算法的原理，它保证每个点的入度都为1（因为每个节点都是从若干入度中选择一个入度作为父亲，根节点除外），又因为当前我们研究的环的形态和其上的点都是固定的，不合法的方案数就只和不在环上的点组合成的树的数目相关，所以在当前环下不合法的情况数，就是剩下的$n-k$个节点组合成的生成树的数量$∏du[w]$.

而环可能有许多个，所以我们要把他们的不合法的方案数相加.

注意：路径有许多条，我们是算出每一条路径的、不在当前路径上的点能构建的生成树数，再相加.

也就是说，可能一个点不在现在这个环上，但是会在另外一个环上. 所以在这个环的情况它对不合法方案数有贡献，但是在另外一个环的时候它对不合法方案无贡献.

------

那我们考虑这个不合法方案数怎么算.

显然地，现在的这种表示方式很不方便计算. 我们得求出每一条从$t->s$的路径，然后再求不在其上的点，最后相乘.

那么就试着把信息整合一下.

不难发现，实际上$\frac{∏du[i]}{∏_{i=1}^{k}​du[a_i]}=∏du[w]$，其中$du[i]$表示在原图上的入度.

因为$x=a_k$，为了表示方便，不妨令$f[x]=\frac{∏du[i]}{∏_{i=1}^{k}​du[a_i]}$.

而这个东西是支持状态的转移的. 比如说，假设从$u$到$v$有一条边，那么$f[v]+=\frac{f[u]}{du[v]}$.

我们使用记忆化搜索即可.

我们会发现，从$t$开始搜索向$s$的路径不容易，因为这需要遍历整张图.

所以我们反向建图，在回溯的时候更新状态.

```cpp
void dfs(int u){
	if(u==yy)return ; 
	if(vis[u])return ;
	if(f[u]>=0)return ;//f初始状态为-1
	vis[u]=true;
	f[u]=0;
	for(int i=head[u];i;i=e[i].next ){
		int v=e[i].v ;
		dfs(v);
		f[u]+=f[v]/in[u];//不同的从t->s路径的不合法方案数要求和
		f[u]%=mod;
	}
	vis[u]=false;
	return ;
}
//这部分写在主函数中
	for(int i=1,u,v;i<=m;i++){
		scanf("%d%d",&u,&v);
		add(v,u);
	}
	ans=1;cnt=1;in[1]=1;
	for(int i=1;i<=n;i++){
		ans=(ans*in[i])%mod;//ans表示原图的方案数
		if(i==yy)cnt=cnt*(in[i]+1)%mod;//cnt表示新图直接表示的方案数
		else cnt=(cnt*in[i])%mod;
	}
	f[yy]=ans/in[yy];//防止重名，x->xx,y->yy
	f[yy]%=mod;
	dfs(xx);
```
更新完之后的$f[x]$就是总的不合法路径数，答案就是$cnt-f[x]$了.

>$tips:$
>1.不用记忆化会T
>2.区分好什么时候用ans，什么时候用cnt

----------

然后你会~~惊喜地~~发现你拿到了$30pts$的好成绩！

由于这里出现了膜意义下的除法运算，我们不得不求逆元以保证除法的正确性.

观察发现$1e9+7$是一个很大的质数，因此我们采用费马小定理求逆元.

$$a^{p-1}=1(mod \:p);$$

也就是

$$a^{p-2}\cdot a=1(mod \:p).$$

用快速幂可求.

-------

其他细节：

$1.$连接的这条边是连向点1的，那么这条边就不会对答案造成影响.

$2.$另外，取模的时候，为了保证最后的结果为正数，要这样写：

```cpp
	cnt=(cnt-f[xx]+mod)%mod;
```

## 程序实现

```cpp
#include<bits/stdc++.h>
#define maxn 100010
#define mod 1000000007
#define ll long long
using namespace std;
struct edge{
	int v,next;
}e[maxn<<1];
int tot,head[maxn];
ll in[maxn];
void add(int u,int v){
	e[++tot].v =v;
	e[tot].next =head[u];
	head[u]=tot;
	in[u]+=1;
}
int n,m,xx,yy;
ll ans,cnt;
bool vis[maxn];
ll f[maxn];
ll fast_pow(ll a,ll b){
	ll c=1;
	while(b){
		if(b&1)c=(a*c)%mod;
		a=(a*a)%mod;
		b>>=1;
	}
	return c;
} //费马小定理（快速幂）求逆元
void dfs(int u){
	if(u==yy)return ; 
	if(vis[u])return ;//记忆化搜索的形式
	vis[u]=true;
	for(int i=head[u];i;i=e[i].next ){
		int v=e[i].v ;
		dfs(v);
		f[u]+=(f[v]*fast_pow(in[u],mod-2)%mod)%mod;
		f[u]%=mod;
	}
	return ;
}
int main(){
	scanf("%d%d%d%d",&n,&m,&xx,&yy);
	for(int i=1,u,v;i<=m;i++){
		scanf("%d%d",&u,&v);
		add(v,u);//反向建边
	}
	ans=1;cnt=1;in[1]=1;
	for(int i=1;i<=n;i++){
		ans=(ans*in[i])%mod;
		if(i==yy)cnt=(cnt*(in[i]+1))%mod;
		else cnt=(cnt*in[i])%mod;
	}
	f[yy]=(ans*fast_pow(in[yy],mod-2))%mod;//求终点的不合法路径数
	f[yy]%=mod;
	dfs(xx);
	cnt=(cnt-f[xx]+mod)%mod;//保证结果为正
	if(yy==1||xx==yy)printf("%lld\n",ans);//特判
	else printf("%lld\n",cnt);
	return 0;
}
```



---

## 作者：kintsgi (赞：9)

令 $in_i$ 表示节点 $i$ 的入度，则对于不加边的的方案数为 $\prod\limits_{i=2}^nin_i$，即对于除了根节点 $1$ 的所有节点钦定一个父亲。

如果加了一条边，我们要去除包含环的方案数，令环上的点集为 $S$，则含环方案数为 $\dfrac{\prod\limits_{i=2}^nin_i}{\prod\limits_{u\in S}in_u}$，即环上的点的父亲已经唯一确定，只要计算不在环上的点的入度乘积。

现在考虑如何求出含环方案，因为加了一条边 $(s,t)$ 可能一次性产生很多环，令在 $dp_u$ 表示在原图上，$t$ 到 $u$ 的所有路径都为环上点集的方案数，初始 $dp_t=\prod\limits_{i=2}^nin_i$。因为在 DAG 上，可以采用拓扑排序转移：$dp_v=\sum\limits_{(u,v)\in E}\dfrac{dp_u}{in_v}$，最后总方案数减去 $dp_s$ 即是答案，因为 $t$ 到 $s$ 的所有路径加上 $(s,t)$ 必定都是环。

注意的点是，因为不加边的方案数对于任何 $(s,1)$ 的边没有任何影响，也就是没有计算含环方案，我们不用拓扑，便直接输出答案即可。

以下代码片段：


```cpp
void topo() {
	for (int i = 1; i <= n; i ++) if (!in[i]) q.push(i);
	while (!q.empty()) {
		int u = q.front(); q.pop();
		dp[u] = dp[u] * inv[calc[u]] % P;
		for (int i = h[u]; i > 0; i = e[i].nxt) {
			int v = e[i].v; dp[v] = (dp[v] + dp[u]) % P;
			if (-- in[v] == 0) q.push(v);
		}
	}
	
	cout << (all - dp[s] + P) % P << endl;
}

signed main() {
	
	n = read(), m = read(), s = read(), t = read();
	
	inv[0] = inv[1] = 1, calc[t] ++;
	for (int i = 2; i <= n; i ++) inv[i] = inv[P % i] * (P - P / i) % P;
	for (int i = 1; i <= m; i ++) {
		int u = read(), v = read();
		addEdge(u, v), in[v] ++, calc[v] ++;
	}
	
	for (int i = 2; i <= n; i ++) all = all * calc[i] % P;
	
	if (t == 1) cout << all << endl;
	else dp[t] = all, topo();
	
	return 0;
}

```

---

## 作者：撤云 (赞：6)

### $Description$

给一张$n$割点$m$条边的$DAG$,保证点$1$不存在入边,现在需要在$DAG$中加入一条不在原图中的边$(x,y)$,求这个有向图以$1$为根的树形图个数对$1e9+7$去模的结果

$n<=100000,m<=200000$

### $Solution$

我们首先来看看如果没有$(x,y)$这一条边的话,在$DAG$上的方案数为多少?

$$ans=\prod_{i=1}^{n} vis[i]$$

$vis$为,点的入度

至于为什么?乘法原理就好了,很容易证明的.

现在来看看有了$(x,y)$的限制如何处理?

因为加入了这条边以后可能会存在环,所以不能单单这么算了,我们还应减去不合法的情况.那么不合法情况怎么算呢?

我们还是令:
$$ans=\prod_{i=1}^{n} vis[i]$$

假设现在有一个环,中间的节点为:$a_1,a_2...a_k$

则不合法的情况为:
$$\frac{ans}{\prod_{i=1}^kvis[i]}$$

因为除了环的点的入度已经固定以外其他的可以随便选

所以我们可以用$f[v]$ 记录从$y$到$v\frac{ans}{\prod_{i=1}^k vis[i]}$的值

转移方程为(存在一条从$u->v$的路径):
$$f[u]=\sum f[v]$$

最后的答案就是:

$$\prod_{i=1}^{n} (i==y)?vis[i+1]:vis[i]-f[x]$$

注意一点要建反向边,因为要判断环.

### $Code$

``` cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
int read() {
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();
    while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
    return x*f;
}
struct node {
    int to,next;
}a[100010<<1];
int vis[100010],head[100010],cnt,n,m,x,y,u,v,ans=1,sum=1,bj[100010],f[100010];
void add(int x,int y){
    a[++cnt].to=y,a[cnt].next=head[x],head[x]=cnt;
}
int ksm(int a,int b){
    int ans=1;
    while(b){
	    if(b&1)
	        ans=ans*a%mod;
    	a=a*a%mod;
	    b>>=1;
    }
    return ans%mod;
}
int inv(int x){
    return ksm(x,mod-2)%mod;
}
void dfs(int x){
    if(bj[x])
	    return ;
    bj[x]=1;
    if(x==y){
	    f[x]=sum*inv(vis[x])%mod;
	    return ;
    }
    for(int i=head[x];i;i=a[i].next){
	    int v=a[i].to;
	    dfs(v);
	    f[x]=(f[x]+f[v])%mod;
    }
    f[x]=f[x]*inv(vis[x])%mod;
}
main(){
    n=read(),m=read(),x=read(),y=read();
    for(int i=1;i<=m;i++)
	    u=read(),v=read(),add(v,u),vis[v]++;
    vis[1]++;
    for(int i=1;i<=n;i++)
	    sum=sum*vis[i]%mod,(i==y)?ans=ans*(vis[i]+1)%mod:ans=ans*vis[i]%mod;
    dfs(x);
    printf("%lld ",(ans-f[x]+mod)%mod);
}

```

---

## 作者：leozhang (赞：5)

看了好多篇题解才看懂的题，我实在太菜了...

首先根据一个我不知道的算法，可以证明在没有加入新的边的时候，原图的所有生成树的方案数就是所有点（除1以外）的度之积

那么在新加入这条边之后，我们仍然可以这样计算，但是会产生一种问题：就是会出现环！

所以我们需要利用一些容斥，把不合法的情况去掉

接下来我们考虑如何算出不合法的情况

由于原图是一个有向无环图，所以在原图中怎么选都不会出现环，所以多的一条边一定在环内！

那么如果出现了环，一定是从多的边的终点到起点的一条路径

所以我们只需要找出终点到起点的路径数量即可

那么就进行一个拓扑排序求一下即可

考虑一下怎么求：

首先记状态：dp[i]表示从终点到i的路径数量

然后考虑初值：dp[ed]=初始方案/终点入度

（关于这里为什么要除掉一个入度：因为原来的初始方案中是包含这一点的入度的，所以要除掉这个入度）

最后ans去掉这一部分即可

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <queue>
#include <stack>
#define mode 1000000007
#define ll long long
using namespace std;
struct Edge
{
	int next;
	int to;
}edge[200005];
int n,m,st,ed;
ll inr[100005];
ll rinr[100005];
int head[100005];
ll inv[300005];
int cnt=1;
ll ans=1;
ll dp[100005];
void init()
{
	inv[0]=inv[1]=1;
	for(int i=2;i<=300000;i++)
	{
		inv[i]=(mode-mode/i)*inv[mode%i]%mode;
	}
	memset(head,-1,sizeof(head));
	cnt=1;
}
void add(int l,int r)
{
	edge[cnt].next=head[l];
	edge[cnt].to=r;
	head[l]=cnt++;
}
ll bfs()
{
	dp[ed]=ans;
	queue <int> M;
	for(int i=1;i<=n;i++)
	{
		if(!inr[i])
		{
			M.push(i);
		}
	}
	while(!M.empty())
	{
		int u=M.front();
		M.pop();
		dp[u]*=inv[rinr[u]];
		dp[u]%=mode;
		for(int i=head[u];i!=-1;i=edge[i].next)
		{
			int to=edge[i].to;
			dp[to]+=dp[u];
			dp[to]%=mode;
			inr[to]--;
			if(!inr[to])
			{
				M.push(to);
			}
		}
	}
	return ((ans-dp[st])%mode+mode)%mode;
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&st,&ed);
	init();
	rinr[ed]=1;
	for(int i=1;i<=m;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y);
		inr[y]++;
		rinr[y]++;
	}
	for(int i=2;i<=n;i++)
	{
		ans*=rinr[i];
		ans%=mode;	
	}
	if(ed==1)
	{
		printf("%lld\n",ans);
	}else
	{
		printf("%lld\n",bfs());
	}
	return 0;
}

```


---

## 作者：Ebola (赞：4)

先来考虑一个DAG怎么做。不难想到，如果除了1号点外，所有点都在它的入边中保留一条，那最后一定会构成一个以1为根的外向树形图。那么根据乘法原理，答案就是所有点入度之积

现在的问题是DAG上加了一条边，这条边可能会导致若干个环的出现。因此，我们需要把成环的情况去除掉

去掉成环的情况，比较好想，实现起来也比较简单，就是不好说……那就把DP方程列一下好了：

$$del=\sum\limits_{u\;in\;loop}\frac{\sum\limits_{\exists\;(x,u),\;x\;in\;loop}dp_x}{degree_u}$$

方程中$del$就是要去掉的贡献，$degree_u$表示点$u$的入度，其它的东西就是字面意思

$dp$的初始值就是$dp_t=ans$，其中$t$是新加边指向的点，$ans$是初始DAG的答案。显然要按照拓扑序来更新$dp$值

```cpp
#include<bits/stdc++.h>
#define ha 1000000007
using namespace std;

const int S=(1<<20)+5;
char buf[S],*H,*T;
inline char Get()
{
	if(H==T) T=(H=buf)+fread(buf,1,S,stdin);
	if(H==T) return -1;return *H++;
}
inline int read()
{
	int x=0;char c=Get();
	while(!isdigit(c)) c=Get();
	while(isdigit(c)) x=x*10+c-'0',c=Get();
	return x;
}

const int N=100010;
struct Edge{int to,next;} e[N<<1];
int h[N],sum=0,n,m,s,t,ans=1;
int deg[N],tdeg[N],inv[N];

void Init()
{
	inv[1]=1;
	for(int i=2;i<=n+1;i++)
		inv[i]=(ha-1ll*(ha/i)*inv[ha%i]%ha)%ha;
}

void add_edge(int u,int v)
{
	e[++sum].to=v;
	e[sum].next=h[u];
	h[u]=sum;
}

int TopoSort()
{
	static int f[N];
	queue<int> q;
	for(int i=1;i<=n;i++)
		if(!tdeg[i]) q.push(i);
	f[t]=ans;
	while(!q.empty())
	{
		int u=q.front();q.pop();
		f[u]=1ll*f[u]*inv[deg[u]]%ha;
		for(int tmp=h[u];tmp;tmp=e[tmp].next)
		{
			int v=e[tmp].to;
			f[v]=(f[v]+f[u])%ha;
			tdeg[v]--;
			if(!tdeg[v]) q.push(v);
		}
	}
	return (ans-f[s]+ha)%ha;
}

int main()
{
	int u,v;
	n=read();m=read();s=read();
	deg[t=read()]++;
	Init();
	for(int i=1;i<=m;i++)
	{
		u=read();v=read();
		add_edge(u,v);
		deg[v]++;tdeg[v]++;
	}
	for(int i=2;i<=n;i++)
		ans=1ll*ans*deg[i]%ha;
	printf("%d\n",t==1?ans:TopoSort());
	return 0;
}
```



---

## 作者：Taduro (赞：4)

考虑如果没有那条新加的边的话，答案就是1以外每个点的入度的乘积，意义是给每个点选一个父亲。

新加了一条边的话，这个拓扑图出现了环，之前那个算法就会多算上这个恰好选中环的方案。

试一试dp把包括环的方案减掉，设新加了一条由s到t的边，当前这个图的答案是ans，点i的入度是$fa_i$。

那么对于s到t的一条路径P，会多算$\sum_{x\in P}ans/fa_x$种方案。

意思是方案中一定包含路径P上的所有点，路径P外的点随便选。

那么这个东西是可以在拓扑图上dp出来的，设$f_x$是x到t所有路径多算的方案数，直接在图上转移就好了。

```c++
#include<cstdio>
#include<cstring>
#include<iostream>
#define mod 1000000007
using namespace std;
struct node{
	int next,to;
}w[200001];
int ans,num,n,m,s,t,head[100001];
int fa[100001],so[100001],cnt,f[100001];
inline int add(int x,int y){return x+y>=mod?x+y-mod:x+y;}
inline int dec(int x,int y){return x-y<0?x-y+mod:x-y;}
inline int mul(int x,int y){return 1ll*x*y-1ll*x*y/mod*mod;}
inline void lin(int x,int y){
	w[++cnt].next=head[x];
	w[cnt].to=y; head[x]=cnt;
}
int dfs(int x){
	if (f[x]>-1) return f[x];
	f[x]++;
	for (int i=head[x]; i; i=w[i].next)
		f[x]=add(f[x],dfs(w[i].to));
	f[x]=mul(f[x],so[fa[x]]);
	return f[x];
}
int main(){
	int x,y;
	scanf("%d%d%d%d",&n,&m,&s,&t);
	for (int i=1; i<=m; i++){
		scanf("%d%d",&x,&y);
		fa[y]++; lin(x,y);
	}
	fa[t]++; fa[1]=ans=so[1]=1;
	for (int i=2; i<=n; i++){
		ans=mul(ans,fa[i]);
		so[i]=mul(dec(mod,mod/i),so[mod%i]);
	}
	memset(f,-1,sizeof(f));
	f[s]=mul(ans,so[fa[s]]);
	if (t!=1) ans=dec(ans,dfs(t));
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Minakami_Yuki (赞：2)

### 解题思想
考虑**未加边**的情况，此时图是一个**DAG**，记为$G=(V, E)$，我们需要统计它的树形子图。

考虑树的特性，每个节点有且仅有唯一一个父节点，那么我们可以根据乘法原理，将每个**非根节点**的**入度**累乘，即可得到答案为：
$$\prod\limits_{i = 2}^{n} \deg i$$

考虑加边，依然按照上面的方式统计，这样会统计到不合法答案。

我们考虑统计不合法答案，然后用原答案减去它。

可以发现，在原图的**DAG**上加一条边，若答案不合法，则这个加边后的图一定含有环。又因为原图是一个**DAG**，所以这个环一定含有加上的边。

于是可以枚举环上的点集$S$，为其**钦定父节点**，然后将**非环上节点**照旧统计，可以得到所有不合法答案，即为：
$$\sum\limits_{S}\prod\limits_{i\notin S} \deg i$$

这个答案可以**DP**出来。

设`dp[i]`表示路径$i\rightarrow x$上节点成环的情况数，那么有初始值：
$$dp[x] = \prod\limits_{y : y \in V\and y \neq x}\deg y$$

由于我们为每个环上的节点**钦定了父节点**，所以对于一个点$x$，我们将其统计入环时，它对不合法情况的贡献会由$\deg x$变为$1$，所以转移时需要除去它的入度。

那么状态转移方程为：

$$dp[x] = \frac {\sum\limits_{y : (x, y)\in E}dp[y]} {\deg x}$$

整个DP是$O(n)$的，如果在线求逆就是$O(n \log n)$的。

最后的答案就是总方案减去不合法数，注意DP完成后节点$x$的父节点未考虑减少的贡献，所以需要除以$\deg x$，即：
$$ans = \prod\limits_{i = 2}^{n}\deg i - \frac {dp[x]} {\deg x}$$

### 参考代码

```cpp
#include <cstdio>
#include <cstring>

const int MOD = 1e9 + 7;
const int N = 2e5 + 6;
const int M = N << 1;

inline int mul(int a, int b) {return 1ll * a * b % MOD;}
inline int add(int a, int b) {return a + b > MOD ? a + b - MOD : a + b;}
inline int power(int a, int b) {int res = 1; for(; b; b >>= 1, a = mul(a, a)) if(b & 1) res = mul(res, a); return res;}

int n, m, y, x, ans = 1;
int dp[N], in[N];
int head[N], nxt[M], ver[M], cnt;

inline void adde(int x, int y) {
	ver[++cnt] = y, nxt[cnt] = head[x], head[x] = cnt, in[y]++;
}

int dfs(int x) {
	if(~dp[x]) return dp[x];
	dp[x] = 0;
	for(register int i = head[x]; i; i = nxt[i]) {
		int y = ver[i];
		dfs(y);
		dp[x] = add(dp[x], dp[y]);
	}
	dp[x] = mul(dp[x], power(in[x], MOD - 2));
	return dp[x];
}

int main() {
	scanf("%d%d%d%d", &n, &m, &y, &x);
	memset(dp, -1, sizeof(dp));
	dp[y] = 1;
	for(register int i = 1; i <= m; i++) {
		int u, v;
		scanf("%d%d", &u, &v);
		adde(u, v);
	}
	for(register int i = 2; i <= n; i++) {
		if(i == x) ans = mul(ans, in[i] + 1);
		else ans = mul(ans, in[i]);
		dp[y] = mul(dp[y], in[i]);
	}
	if(x == 1) return printf("%d\n", ans), 0;
	dp[y] = mul(dp[y], power(in[y], MOD - 2));
	ans = add(ans, MOD - dfs(x));
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：zzw4257 (赞：1)

### 题意
>求一个$DAG$加上一条边后以$1$为根的极大($n$点)树形图个数

### Solution
还记得我们造树数据的土方法吗，每次随机一个编号更小的连边，其实质是编号的全序关系(类似数归从前面的点$(\text{rand}()\%(i-1)+1\in[1,i))$任意一个合法推到$i$合法)

事实上任意全序关系可以构造树，或者可以反推

对本题不加这条边$DAG$的答案就是$\prod\limits_{i=2}^n in_i$用任意一个入边都能保证全序关系

考虑对答案处理加入(多个)环后情况很复杂，但如果是用特殊情况的"错误"构造方法，一定能得到所有的合法解与只有一个环的简单不合法情况,这类不合法情况就是里面一个环，其余照常选入边

故考虑补集$\displaystyle ans=\prod\limits_{i=2}^n in_i-\sum\limits_{C}\prod\limits_{x\notin C}x=\prod\limits_{i=2}^n in_i-\sum\limits_{C}\frac{\prod\limits_{x \in C}x}{\prod\limits_{i=2}^n in_i}$

拓扑排序或$dfs$均可

### 反思

我的方法是分类求去掉这条边的答案和强制选这条边答案

因此整个大环套环(边双联通分量)内情况很复杂，唯一知道的就是没有环等价于存在至少一个来自边双外的点作为本应存在的$T\rightarrow S$的某点入点，然后可以按比例合并情况……

完全没利用到初始构造在非$DAG$情况中最多只会出现一个环条件从而转补集容斥

最后是写暴力时$dfs$没判$vis$!!!!

---

## 作者：hegm (赞：0)

### [[HNOI2015]落忆枫音](https://www.luogu.com.cn/problem/P3244)

一道计数题目~

先考虑一个比较简单的问题：

> 求出一个 DAG 上的以 $1$ 为根的生成树数量。（叶向树，也就是说父亲向儿子连边）

答案很简单： $ans=\prod\limits_{i=2}^{n}in_i$，其中 $in_i$ 表示的是 $i$ 的入度。

原因很简单，实际上我们就是给所有 $i\ne1$ 的点选择一个父亲，那么 $i$ 号点可能的父亲就只有连向 $i$ 的点。同时因为是 DAG，我们可以保证这样练出来的边不会有环，所以答案十分好算。

那么考虑添加一条边后。

还是先用之前的式子算出答案，记为 $ans'$。但是 $ans'$ 并不是最终答案，因为添加一条新边后，图上出现了环，而如上的统计方案会将环统计进去。

那么对于存在环的情况，可以将图分成两部分：

1. 环所在的子图

2. 一棵以 $1$ 为根的树，和许多连接在环上的树。

那么对于每一个环，我们将环上的点剖去，剩余的点就是树上的点了，那么造成的贡献就是点度相乘。

可以使用拓扑排序 dp 简单维护即可。

我们设 $dp_i$ 表示到了 $i$ 时候，的剖去 $x\to y\to \cdots\to i$ 这条链的时候，对应的答案（注意，此时 $i$ 里面存的应该是好几条链的答案）。

$dp_u=\sum\limits_{v\to u}\dfrac{dp_v}{in_u}$

最后得到 $dp_x$ 的答案即可，最终答案是 $ans'-dp_x$。

还有特殊的情况就是 $1$ 在环上，此时图变成一个环和许多连接在环上的树，容易发现，此时包括新加入的边的答案都不合法，所以直接输出 $ans'$ 即可。

放下代码~

### $\text{CODE}$

```cpp
#include<bits/stdc++.h>
#define N 1000006
#define mod 1000000007
using namespace std;
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n,m,x,y,ans,dp[N],du[N];
struct fig
{
	int to,next;
}k[N*3];int head[N],tot,in[N];
bool vis[N];
void add(int from,int to)
{
	k[++tot].to=to;
	k[tot].next=head[from];
	head[from]=tot;
}
int mul(int a,int b){return (1ll*a*b)%mod;}
int adt(int a,int b){return (1ll*a+b)%mod;}
queue<int> q;
int ksm(int d,int z)
{
	int ans=1;
	while(z)
	{
		if(z&1)ans=mul(ans,d);
		d=mul(d,d);
		z>>=1;
	}
	return ans;
}
void dfs(int now)
{
	vis[now]=1;
	for(int i=head[now];i;i=k[i].next)
	{
		if(vis[k[i].to])continue;
		dfs(k[i].to);
	}
}
signed main()
{
	n=read();m=read();x=read();y=read();
	for(int i=1,u,v;i<=m;i++)
	{
		u=read();v=read();
		add(u,v);in[v]++;	
	}
	in[y]++;ans=1;
	for(int i=2;i<=n;i++)ans=mul(ans,in[i]);
	if(y==1)
	{
		cout<<ans<<"\n";
		return 0;
	}
	dp[y]=mul(ans,ksm(in[y],mod-2));
	dfs(y);
	for(int i=1;i<=n;i++)
	{
		if(!vis[i])continue;
		for(int j=head[i];j;j=k[j].next)
		du[k[j].to]++;
	}
	q.push(y);
	while(q.size())
	{
		int now=q.front();q.pop();
		for(int i=head[now];i;i=k[i].next)
		{
			dp[k[i].to]=adt(dp[k[i].to],mul(dp[now],ksm(in[k[i].to],mod-2)));
			du[k[i].to]--;
			if(!du[k[i].to])q.push(k[i].to);
		}
	}
	ans=((ans-dp[x])%mod+mod)%mod;
	cout<<ans<<"\n";
	return 0;
}
```

---


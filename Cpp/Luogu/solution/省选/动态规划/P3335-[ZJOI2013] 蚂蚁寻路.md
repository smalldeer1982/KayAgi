# [ZJOI2013] 蚂蚁寻路

## 题目描述

在一个 $n \times m$ 的棋盘上，每个格子有一个权值，初始时，在某个格子的顶点处一只面朝北的蚂蚁，我们只知道它的行走路线是如何转弯，却不知道每次转弯前走了多长。

蚂蚁转弯是有一定特点的，即它的转弯序列一定是如下的形式：右转，右转，左转，左转，右转，右转…左转，左转，右转，右转，右转。即两次右转和两次左转交替出现的形式，最后两次右转（最后两次一定是右转）后再多加一次右转。我们还知道，蚂蚁不会在同一个位置连续旋转两次，并且蚂蚁行走的路径除了起点以外，不会到达同一个点多次，它最后一定是回到起点然后结束自己的行程，而且蚂蚁只会在棋盘格子的顶点处转弯。

 ![](https://cdn.luogu.com.cn/upload/pic/6217.png) 

现在已知棋盘大小、每个格子的权值以及左转次数除以 $2$ 的值，问蚂蚁走出的路径围出的封闭图形，权值之和最大可能是多少。


## 说明/提示

### 样例说明

除了第一行的第二个和第一行的第四个都要围起来才至少合法。

### 数据规模与约定

- $10\%$ 的数据所有格子中权值均非负。
- 另 $20\%$ 的数据 $n=2$。
- 另 $30\%$ 的数据 $k=0$。
- $100\%$ 的数据 $1 \le n\le 100$，$1 \le m \le 100$，$0 \le k \le 10$，保证存在合法路径，数据有梯度，格子中每个元素的值绝对值不超过 $10000$。


## 样例 #1

### 输入

```
2 5 2
-1 -1 -1 -1 -1
-1 -1 -1 -1 -1```

### 输出

```
-8```

# 题解

## 作者：Forever丶CIL (赞：16)

P3335 这个题思维难度还是有的。。(至少我是这么想的。。大佬就别吐槽我了)

首先，通过题目描述，我们可以在纸上画一画，可以发现，图像一定是像长城一样的

就是好多个矩形它们的底在一条直线上，高和宽不同，而且，还有一点就是它是高低相间的

而且由右转形成高峰，由左转形成低谷。 

那么我们可以枚举图的右下角(i,j)，那么有两种情况：

一:第j-1列和第j列在同一个矩形里；

二:第j-1列和第j列在不同的矩形里；

我们要记录的状态与点(i,j),p(指的是当前枚举的是第p个矩形),h(当前枚举的举行高度为i-h+1)有关

对于一情况：令f[i][j][p][h]来表示前i行前j列，到第p个矩形，且第p个矩形高为i-h+1时的最优解。 
则 f[i][j][p][h]=f[i][j-1][p][h]+s[i][j]-s[h-1][j];

（这里这个s数组求的是每一列的前缀和，可以在输入中预处理出来，方便计算用） 

对于二情况：再分两种讨论，如果第p个矩形比第p-1个矩形高，则应从f[i][j-1][p-1][高度小于i-h+1]中找一个
max来转移，如果第p个矩形比第p-1个矩形矮，则应从f[i][j-1][p-1][高度大于i-h+1]中找一个max来转移。
因为一个个枚举高度大于i-h+1和小于i-h+1太浪费时间了，所以我们再开一个数组g[i][j][p][h][0/1]来表示
高度比i-h+1高的/矮的之中，f数组中的max。 

我这里直接用f[i][j-1][p-1][高度大于i-h+1]这样的方式讲解了，但其实f数组最后一维的h并不是第p个矩形的高度，而是这样的：i是矩形的最下面一行，h则是最上面一行，所以i-h+1才是高度。

根据分析，转移就好写了：

**f[i][j][p][h]=max(f[i][j-1][p][h],g[i][j-1][p-1][h][p%2])+s[i][j]-s[h-1][j];**


关于g数组的维护，因为我们已经维护出f数组的第j列了

那么这一列所在的矩形要么是低谷，要么是高峰，我们都要考虑

->高峰：

**g[i][j][p][h][0]=max(f[i][j][p][h-1],g[i][j][p][h-1][0]);**

->低谷：

**g[i][j][p][h][1]=max(f[i][j][p][h+1],g[i][j][p][h+1][1]);**

当然我们可以在计算过程中更新答案，还可以省掉i这一维

因为从方程中就可以看出来i其实没有参与转移 



------------

```

#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
const int maxn=120;
const int Inf=1000000001; 
int n,m,k,ans;
int a[maxn][maxn];
int f[maxn][25][maxn];
int g[maxn][25][maxn][2];
int s[maxn][maxn];
void ini()
{
	scanf("%d%d%d",&n,&m,&k);
	k=k*2+1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",&a[i][j]); s[i][j]=s[i-1][j]+a[i][j];
	for(int p=1;p<=k;p++)
		for(int h=1;h<=n;h++)
			f[0][p][h]=-Inf,g[0][p][h][0]=-Inf,g[0][p][h][1]=-Inf;
}
void dp()
{
	ans=-Inf;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			for(int p=1;p<=k;p++)
			{
				for(int h=i;h>=1;h--)
					f[j][p][h]=max(f[j-1][p][h],g[j-1][p-1][h][p%2])+s[i][j]-s[h-1][j];
				g[j][p][1][0]=-Inf;
				for(int h=2;h<=i;h++) g[j][p][h][0]=max(f[j][p][h-1],g[j][p][h-1][0]);
				g[j][p][i][1]=-Inf;
				for(int h=i-1;h>=1;h--) g[j][p][h][1]=max(f[j][p][h+1],g[j][p][h+1][1]);
			}
			ans=max(ans,max(f[j][k][i],g[j][k][i][0]));
		}
	}
}
int main()
{ 
	ini();
	dp();
	printf("%d\n",ans);
	return 0;
}
```


------------


大家也会发现，g数组的最后一维也能省掉，因为对于特定的p，它是高峰还是低谷是确定的。

rp++ 

---

## 作者：Flying2018 (赞：6)

粗略分析一下题意，思（zi）考（bi）一下可知，一次右转+左转相当于是一个高峰，而一次左转+右转相当于一个低谷。

在略微看一下图例（不是样例！）可以看出，最下面有一条下界（相当于是一条基准线）。

所以我们可以枚举这条基准线的位置，剩下的就是一个dp了。

用$f[i][h][k][0/1]$表示第i列，相对（基准线）h格，有k个低谷，当前是否为低谷

考虑对于某一列有3种情况：
1. 这列是一个高峰（的开始）
2. 这列是一个低谷（的开始）
3. 这列继承上一列的高度

对于3种情况分别考虑：
1. 从上一个（比当前低的）低谷中选出一个最大值转移
2. 从上一列（比当前高的）高峰中选出一个最大值转移
3. 直接转移

特别的，高峰也可以从0转移。最后统计有k个低谷且当前为高峰中的最大值

然后我们可以列出$O(n^2mk)$的dp式。加上枚举基准线共$O(n^2m^2k)$。

好像过不去。。。

仔细分析dp时间复杂度，$O(nmk)$肯定少不了，但还有一个$O(n)$用在选取最大值上。而最大值是可以预处理的。所以我们只要每扫完一列预处理一下即可。

附上丑陋的代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#define N 100
using namespace std;
int f[N][N][2][12];//0:高峰 1:低谷 
int num[N][N],sum[N][N],mm[N][N][2][12];//0:高峰 1:低谷 
int get(int x,int yu,int yd){return sum[yd][x]-sum[yu-1][x];}
int main()
{
	int n,m,c;
	int ans=-100000000;
	scanf("%d%d%d",&n,&m,&c);
	for(int i=n;i>=1;i--)
		for(int j=1;j<=m;j++)
			scanf("%d",&num[i][j]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			sum[i][j]=sum[i-1][j]+num[i][j];
	for(int o=1;o<=n;o++)//基准线 
	{
		memset(f,200,sizeof(f));
		memset(mm,200,sizeof(mm));
		for(int i=1;i<=m;i++)//列 
		{
			for(int h=1;h+o-1<=n;h++)//相对高度 
			{
				f[i][h][0][0]=get(i,o,o+h-1);
				for(int k=0;k<=c;k++)
				{
					f[i][h][0][k]=max(f[i-1][h][0][k]+get(i,o,o+h-1),f[i][h][0][k]);
					f[i][h][1][k]=max(f[i-1][h][1][k]+get(i,o,o+h-1),f[i][h][1][k]);
					f[i][h][0][k+1]=max(f[i][h][0][k+1],mm[i-1][h-1][1][k]+get(i,o,o+h-1));
					f[i][h][1][k]=max(f[i][h][1][k],mm[i-1][h+1][0][k]+get(i,o,o+h-1));
					mm[i][h][1][k]=max(mm[i][h][1][k],f[i][h][1][k]);
					mm[i][h][0][k]=max(mm[i][h][0][k],f[i][h][0][k]);
				}
				ans=max(ans,mm[i][h][0][c]);
			}
			for(int h=1;h+o<=n+1;h++)
				for(int k=0;k<=c;k++)
				mm[i][h][1][k]=max(mm[i][h-1][1][k],mm[i][h][1][k]);
			for(int h=n-o;h>=0;h--)
				for(int k=0;k<=c;k++)
				mm[i][h][0][k]=max(mm[i][h+1][0][k],mm[i][h][0][k]);
		}
	}
	printf("%d",ans);
	return 0;
}

```

---

## 作者：YellowBean_Elsa (赞：3)

首先我们感觉这个转弯方法会有一些神奇的特点，于是自己走了走

然后发现

![最后走出的封闭图形长这样](https://cdn.luogu.com.cn/upload/image_hosting/d69l1xw0.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

可以看成 $2k+1$ 个矩形拼在一起

然后我们可以针对矩形进行 **dp**

#### dp 数组定义：

令 $f_{i,j,p,h}$ 表示以 $(i,j)$ 为右下角，第 $p$ 个矩形，高度为 $h$ 的最大值；

$g_{i,j,p,h,0/1}$ 同理，但 $0$ 表示高度 $>h$, $1$ 表示高度 $<h$ （注意不可取等）

#### 初始化（很恶心！）:
我们就按照实际情况来就行了（雾）

第 0 列的东西肯定不存在的，负无穷；

高于最大高度或小于1的 $g$ 当然也不存在。

其它都是 0。~~（我不会告诉你我是猜这样然后一交对了）~~

（看了转移方程就会知道，为什么一开始赋值为 0，最后最大值也可以变成负数）

#### **转移方程**
```cpp
//对于 f：
f[i][j][p][h]=
max(f[i][j-1][p][h],g[i][j-1][p-1][h][p&1])+sum[i][j]-sum[i-h][j];
/*
sum 表示第j列前i行的数的和（notice!）
从上一列转移过来，考虑上一列是否在同一矩形中
如果不在，根据矩形高低随矩形从左到右的编号变化规律
（奇数高偶数矮）（p&1 是对 2 取模（废话））
可以知道 g 数组应该用 >h 还是 <h. 
*/
g[i][j][p][h][1]=max(g[i][j][p][h-1][1],f[i][j][p][h-1]);
g[i][j][p][h][0]=max(g[i][j][p][h+1][0],f[i][j][p][h+1]);
//这个根据 g 的定义应该好理解吧。。。
```
#### 最后一点

一个严重问题：**MLE**！！！

但是我们发现转移方程中 i 似乎全都一样，那我们可以把这一维去掉。

#### 代码

```cpp
//coder: Feliks a Hacker of IOI == GM-YB an AKer of IMO
//acknowledgement: https://blog.csdn.net/dcx2001/article/details/78107106
#include<bits/stdc++.h>
#define fu(i,a,b) for(int i = a, I = (b) + 1; i < I; ++i)
#define fd(i,a,b) for(int i = a, I = (b) - 1; i > I; --i)
typedef long long ll;
using namespace std;
const int N=105;
const int inf=-1e9;
template <class T> inline void read(T &x) {
    x=0;T f=1;char ch=getchar();
    while(!isdigit(ch))f=ch=='-'?-1:1,ch=getchar();
    while(isdigit(ch))x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    x*=f;
}int n,m,k;
int a[N][N],sum[N][N];//注意sum指的是第j列上面i个元素的和 
int f[N][N][N],g[N][N][N][2];
int ans=inf;
int main(){
	read(n),read(m),read(k);
	k=(k<<1)+1;//矩形个数
	fu(i,1,k)fu(h,1,n)f[0][i][h]=g[0][i][h][0]=g[0][i][h][1]=inf;
	//第 0 列什么都不存在 
	//这个初始化坑死我了 MDZZ 
	fu(i,1,n)fu(j,1,m){
		read(a[i][j]);
		sum[i][j]=sum[i-1][j]+a[i][j];
	}fu(i,1,n)fu(j,1,m){
		fu(p,1,k){
			fu(h,1,i){
				f[j][p][h]=
				max(f[j-1][p][h],g[j-1][p-1][h][p&1])+sum[i][j]-sum[i-h][j]; 
			}g[j][p][1][1]=inf;//高度 <1 的不存在 
			fu(h,2,i)
				g[j][p][h][1]=max(g[j][p][h-1][1],f[j][p][h-1]);
			g[j][p][i][0]=inf;//同理 
			fd(h,i-1,1)
				g[j][p][h][0]=max(g[j][p][h+1][0],f[j][p][h+1]);
		}fu(h,1,i)ans=max(ans,f[j][k][h]);//update the ans
	}printf("%d\n",ans);
	return 0;
}
```
##### Au Revoir.

---

## 作者：lcyxds (赞：2)

https://www.luogu.com.cn/record/44177376

目前最优解

数组预处理：预处理每列的前缀和。

基本思路：枚举底边，然后进行 dp。

`dp[i][j]` 表示当前状态下最后一列为第 `i` 列，最高在第 `j` 行的最优解。由于每轮 dp 只需要使用前一轮每列的前/后缀最大值来转移，于是可以不断滚动更新，维数从其它题解的 $5,4,3$ 维降为二维。

下划线为全局变量

```cpp
#include <cstdio>
#include <iostream>

using namespace std;

int _n, _m, _k;
int _list[110][110];
int _liepre[110][110];
int _dp[110][110];
int _maxi[110][110];

int _res = -2147483647;

void Dp(int ji) {
	for (int i = 1; i <= _m; i++) {
		for (int j = 1; j <= ji; j++) {
			_dp[i][j] = _liepre[ji][i]-_liepre[j-1][i];
			if (_dp[i-1][j] > 0) {
				_dp[i][j]+=_dp[i-1][j];
			}
//			cout << "_dp[" << i << "][" << j <<"]=" << _dp[i][j] << endl;
		}
	}
	for (int k = 1; k <= _k; k++) {
		for (int i = ((k<<1)-1); i < _m; i++) {
			_maxi[i][1] = _dp[i][1];
			for (int j = 2; j < ji; j++) {
				_maxi[i][j] = max(_maxi[i][j-1], _dp[i][j]);
			}
		}
		for (int j = 2; j <= ji; j++) {
			_dp[k<<1][j] = _liepre[ji][k<<1]-_liepre[j-1][k<<1]+_maxi[(k<<1)-1][j-1];
		}
		for (int i = k<<1|1; i <= _m; i++) {
			for (int j = 2; j <= ji; j++) {
				_dp[i][j] = max(_dp[i-1][j], _maxi[i-1][j-1])+_liepre[ji][i]-_liepre[j-1][i];
			}
		}
//		cout << k << "!!!!!!" << endl;
//	for (int i = k<<1; i <= _m; i++) {
//		for (int j = 1; j <= ji; j++) {
//			cout << _dp[i][j] << ',';
//		}
//		cout << endl;
//	}
//	cout << endl;
		for (int i = k<<1; i < _m; i++) {
			_maxi[i][ji] = _dp[i][ji];
			for (int j = ji-1; j > 1; j--) {
				_maxi[i][j] = max(_maxi[i][j+1], _dp[i][j]);
			}
		}
		for (int j = 1; j < ji; j++) {
			_dp[k<<1|1][j] = _liepre[ji][k<<1|1]-_liepre[j-1][k<<1|1]+_maxi[k<<1][j+1];
		}
		for (int i = (k<<1)+2; i <= _m; i++) {
			for (int j = 1; j < ji; j++) {
				_dp[i][j] = max(_dp[i-1][j], _maxi[i-1][j+1])+_liepre[ji][i]-_liepre[j-1][i];
			}
		}
//		cout << k << "!!!!!!" << endl;
//	for (int i = k<<1|1; i <= _m; i++) {
//		for (int j = 1; j <= ji; j++) {
//			cout << _dp[i][j] << ',';
//		}
//		cout << endl;
//	}
//	cout << endl;
	}
	for (int i = _k<<1|1; i <= _m; i++) {
		for (int j = 1; _k?j < ji:j<=ji; j++) {
			_res = max(_res, _dp[i][j]);
		}
	}
}

int main() {
	freopen("P3335.in", "r", stdin);
	scanf("%d%d%d", &_n, &_m, &_k);
	for (int i = 1; i <= _n; i++) {
		for (int m = 1; m <= _m; m++) {
			scanf("%d", _list[i]+m);
			_liepre[i][m] = _liepre[i-1][m]+_list[i][m];
		}
	}
	for (int ji = _k?2:1; ji <= _n; ji++) {
		Dp(ji);
	}
	printf("%d", _res);
	fclose(stdin);
	return 0;
}
```


---

## 作者：liugh_ (赞：1)

## [P3335 [ZJOI2013] 蚂蚁寻路](https://www.luogu.com.cn/problem/P3335)

容易发现围出的形状底部平整，顶部凹凸不平，峰和谷交错排列，共组成了 $2K+1$ 个水平面。既然底部平整，考虑枚举每一行，求以当前行为底的答案。数据范围较小，考虑 dp：

- 要在连续的某些列上选数，考虑把当前列加入状态。
- 有峰和谷的限制，考虑把当前水平面所在行加入状态。
- 要拼出 $2K+1$ 个水平面，考虑把当前已拼出水平面数加入状态。

于是，我们设 $f(i,j,k)$ 为当前列为 $i$，当前水平面所在行为 $j$，当前已拼出水平面数为 $k$，的最大权值和。

考虑转移。设当前枚举到第 $r$ 行，对于 $f(i,j,k)$：

- 可以延长上一列的水平面。
- 可以开一个新的水平面出来：
  - 若 $k$ 为奇数，说明当前水平面是峰，那么上一个水平面要低于当前水平面。
  - 若 $k$ 为偶数，说明当前水平面是谷，那么上一个水平面要高于当前水平面。

即
$$\large
f(i,j,k)=\max\{f(i-1,j,k),t\}+\sum_{h=j}^{r} a_{h,i} \\
$$
其中
$$\large
t=\left\{
\begin{aligned}
& \max_{j<j'\le r} f(i-1,j',k-1) & k\bmod 2=1 \\
& \max_{1\le j'<j} f(i-1,j',k-1) & k\bmod 2=0 \\
\end{aligned}
\right.
$$
预处理 $a$ 的前缀和以及 $f$ 的前缀后缀 $\max$，即可做到单次 $O(1)$ 转移。

考虑初始化。为减少讨论边界，在 $r+1$ 行处假想一个水平面，即令 $\forall 0\le i\le m,f(i,r+1,0)=0$，其余为 $-\infty$ 即可。

考虑统计答案。显然地，对于枚举到的每一行，令 $\displaystyle ans\gets \max\{ans,\max_{1\le i\le m,1\le j\le r} f(i,j,2K+1)\}$ 即可。

时间复杂度 $O(n^2mk)$。

```cpp
#include<iostream>
#include<algorithm>
#include<queue>
#ifdef ONLINE_JUDGE
#define getchar() (p_==q_&&(q_=(p_=b_)+fread(b_,1,s_,stdin),p_==q_)?-1:*p_++)
#define putchar(x_) ((r_-o_<s_)?(*r_++=x_):(fwrite(o_,r_-o_,1,stdout),r_=o_,*r_++=x_))
bool t_=(std::cin.tie(0),std::cout.tie(0),std::ios_base::sync_with_stdio(0));
#endif
using namespace std;constexpr signed s_=1<<20;char b_[s_],o_[s_],*p_=b_,*q_=b_,*r_=o_;struct _{~_(){fwrite(o_,r_-o_,1,stdout);}}_;template<class T_>constexpr bool fr(T_&x_)noexcept{x_=0;char c_=0,f_=0;do{if(c_==-1)return 0;if(c_==45)f_=1;c_=getchar();}while(c_<48||c_>57);do{x_=(x_<<1)+(x_<<3)+(c_^48);c_=getchar();}while(c_>47&&c_<58);if(f_)x_=-x_;return 1;}template<class T_>constexpr void fw(T_ x_)noexcept{char d_[40],l_=-1;if(x_<0)x_=-x_,putchar(45);do d_[++l_]=(x_%10)^48;while(x_/=10);do putchar(d_[l_]);while(~--l_);}

#define tomax(a,b) (a=max(a,b))
constexpr int maxn=100+5,maxk=20+5,inf=0x3f3f3f3f;

int n,m,K;
int a[maxn][maxn];
int sum[maxn][maxn];

int f[maxn][maxn][maxk];
#define f(a,b,c) f[a][b][c]

signed main(){
    fr(n),fr(m),fr(K);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            fr(a[i][j]);
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
            sum[i][j]=sum[i][j-1]+a[j][i];
    int ans=-inf;
    for(int r=1;r<=n;r++){
        fill(**f,**end(f),-inf);
        for(int i=0;i<=m;i++)
            f(i,r+1,0)=0;
        for(int i=1;i<=m;i++){
            for(int k=1;k<=2*K+1;k++){
                static int pre[maxn],suf[maxn];
                fill(pre,end(pre),-inf);
                fill(suf,end(suf),-inf);
                for(int j=1;j<=r+1;j++)
                    pre[j]=max(pre[j-1],f(i-1,j,k-1));
                for(int j=r+1;j>=1;j--)
                    suf[j]=max(suf[j+1],f(i-1,j,k-1));
                for(int j=1;j<=r;j++){
                    int s=sum[i][r]-sum[i][j-1];
                    f(i,j,k)=f(i-1,j,k)+s;
                    if(k&1) // 当前是峰
                        tomax(f(i,j,k),suf[j+1]+s);
                    else // 当前是谷
                        tomax(f(i,j,k),pre[j-1]+s);
                    if(k==2*K+1)tomax(ans,f(i,j,k));
                }
            }
        }
    }
    fw(ans);
    exit(0);
}
```

---

## 作者：Karl_Aurora (赞：0)

**[~~无耻地推销个人博客 qwq~~](https://www.luogu.com.cn/blog/ling-XAIqwq/solution-p3335)**

**[题目传送门](https://www.luogu.com.cn/problem/P3335)**

------------

## 题意

给定一个 $n \times m$ 的矩阵，你需要从中选出一个有 $k$ 个凹陷的“凹”型区域，使得区域内的数和最大。

## 解法

可能只有蓝题 dp 的难度？

由于选出的区域的底部是水平的，所以可以考虑枚举这条水平线及其右边界（也可以看作是枚举右下角），从而确定一个大致的区域。

在这个思路下，我们可以把要求的区域看作是在这条水平线上将 $k+1$ 个高于两侧的矩阵和 $k$ 个低于两侧的矩阵交替拼在一起，这样我们可以初步得到一个 $\Theta(n ^ 4 k)$ 的动态规划柿子：

令 $m$ 为原矩阵，$f_{i,j,k,h}$ 表示取到以 $(i,j)$ 为右下角的高度为 $h$ 的第 $k$ 个高矩阵时已取区域的和最大值，同理 $g_{i,j,k,h}$ 表示取到第 $k$ 个矮矩阵时已取区域的和最大值，

则有 

$g_{i,j,0,h}=0,$

$f_{i,j,k,h}=\max(f_{i,j-1,k,h},\max_{l<h}g_{i,j-1,k-1,l})+\sum_{x=i-h+1}^{i}m_{x,j},$

$g_{i,j,k,h}=\max(g_{i,j-1,k,h},\max_{l>h}f_{i,j-1,k,l})+\sum_{x=i-h+1}^{i}m_{x,j}$

思路也很明显，即每一列要么和等高的上列所在矩阵融为一体，要么作为一个从上个比它高或矮的矩阵的下个矩阵的第一列转移。

接下来就是优化这个式子了，首先对于后面的求和我们可以使用前缀和预处理优化，而因为对于每个固定的 $i,j,k$，前一列的dp区间最大值是固定的，那么我们可以从上往下和从下往上各预处理一边最大值，那么对于每个 $h$，式子中的 $\max_{l<h}g_{i,j-1,k-1,l}$ 或 $\max_{l>h}f_{i,j-1,k,l}$ 就可以常数时间复杂度求出，这样我们就通过两个优化将这个式子优化掉了一维，时间复杂度 $\Theta(n ^ 3 k)$。

同时，我们发现在转移中 $i$ 始终为一个常数，因此可以不存储 $i$ 这一维，空间复杂度也优化到了 $\Theta(n ^ 3)$。

最后，因为我们转移时依赖于从上个比它高或矮的矩阵转移，因此最终按照这个式子求出来的区域高度一定不小于二，但当 $k=0$，即该区域为矩形时，其高度可能为一，因此对于 $k=0$ 的情况需要进行特判处理。

将上述情况全部考虑一遍后，这道题就结束了。

最后代码如下：

```cpp
#include <bits/stdc++.h>
#define maxn 110
#define maxk 15
using namespace std;
template < typename T >
inline void read(T &X)
{
    X = 0; bool f = false; char ch = getchar();
    while (!isdigit(ch)) {f |= ch == '-'; ch = getchar();}
    while (isdigit(ch)) {X = (X * 10) + (ch ^ 48); ch = getchar();}
    X = f ? -X : X;
}
template < typename T >
inline void write(T X)
{
    if (X == 0) {putchar('0'); return;}
    if (X < 0) {putchar('-'); X = -X;}
    static char cnt = 0, num[20];
    while (X) {num[cnt++] = (X % 10) ^ 48; X /= 10;}
    while (cnt) putchar(num[--cnt]);
}
int n, m, k;
int mp[maxn][maxn], dpup[maxn][maxn][maxk], dpdown[maxn][maxn][maxk], maxup[maxn], maxdown[maxn];
int ans = -INT_MAX;
int main()
{
#ifndef ONLINE_JUDGE
    freopen("P3335.in", "r", stdin);
    freopen("P3335.out", "w", stdout);
#endif
    memset(dpup, 0x80, sizeof(dpup)); memset(dpdown, 0x80, sizeof(dpdown));
    memset(maxup, 0x80, sizeof(maxup)); memset(maxdown, 0x80, sizeof(maxdown));
    read(n); read(m); read(k);
    ++k;
    for (int i = 1; i <= n; ++i)
    {
        for (int j = 1; j <= m; ++j)
        {
            read(mp[i][j]); mp[i][j] += mp[i - 1][j];
            dpdown[j - 1][i][0] = 0;
        }
    }
    for (int i = 2; i <= n; ++i)
    {
        for (int j = 1; j <= m; ++j)
        {
            for (int a = 1; a <= k; ++a)
            {
                for (int b = 1; b <= i; ++b) maxup[b] = max(maxup[b - 1], dpup[j - 1][b][a]);
                for (int b = i; b > 0; --b) maxdown[b] = max(maxdown[b + 1], dpdown[j - 1][b][a - 1]);
                for (int b = 2; b <= i; ++b) dpdown[j][b][a] = max(dpdown[j - 1][b][a], maxup[b - 1]) + mp[i][j] - mp[b - 1][j];
                for (int b = i - 1; b > 0; --b) dpup[j][b][a] = max(dpup[j - 1][b][a], maxdown[b + 1]) + mp[i][j] - mp[b - 1][j];
            }
            for (int b = 1; b <= i; ++b) ans = max(ans, dpup[j][b][k]);
        }
    }
    if (k == 1)
    {
        for (int i = n; i > 0; --i)
        {
            for (int j = 1; j <= m; ++j)
            {
                mp[i][j] = mp[i][j] - mp[i - 1][j] + mp[i][j - 1];
                for (int l = 0; l < j; ++l) ans = max(ans, mp[i][j] - mp[i][l]);
            }
        }
    }
    write(ans);
    return 0;
}
```

至此，愉快 AC，完结撒花

---


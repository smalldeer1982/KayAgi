# [ZJOI2016] 线段树

## 题目描述

小 Yuuka 遇到了一个题目：有一个序列 $a_1,a_2,\ldots,a_n$，$q$ 次操作。每次操作把一个区间内的数改成区间内的最大值，问最后每个数是多少。小 Yuuka 很快地就使用了线段树解决了这个问题。

于是充满智慧的小 Yuuka 想，如果操作是随机的，即在这 $q$ 次操作中每次等概率随机地选择一个区间 $[l,r]$（$1 \leq l \leq r \leq n$），然后将这个区间内的数改成区间内最大值（注意这样的区间共有 $\frac{n(n+1)}{2}$ 个），最后每个数的期望大小是多少呢？

小 Yuuka 非常热爱随机，所以她给出的输入序列也是随机的（随机方式见数据规模和约定）。

对于每个数，输出它的期望乘 $\left(\frac{n(n+1)}{2} \right)^q$ 再对 $10^9+7$ 取模的值。


## 说明/提示

对于所有的测试数据，保证序列中数的大小不超过 $10^9$，并且每个数是 $0$ 到 $10^9$ 之间的随机整数。

|测试点编号|$n$|$q$|
|:-:|:-:|:-:|
|1|$\leq 5$|$\leq 5$|
|2|$\leq 8$|$\leq 400$|
|3|$\leq 12$|$\leq 400$|
|4|$\leq 30$|$\leq 400$|
|5|$\leq 50$|$\leq 400$|
|6|$\leq 100$|$\leq 400$|
|7|$\leq 100$|$\leq 400$|
|8|$\leq 400$|$\leq 400$|
|9|$\leq 400$|$\leq 400$|
|10|$\leq 400$|$\leq 400$|


## 样例 #1

### 输入

```
5 5
1 5 2 3 4
```

### 输出

```
3152671 3796875 3692207 3623487 3515626
```

# 题解

## 作者：i207M (赞：27)

[学长的博客](https://www.cnblogs.com/juruolty/p/6930707.html)

都是从暴力DP开始优化起的

设$f(v,i,l,r)$表示i轮之后，$[l,r]$内的数$\le x$，且$a[l-1],a[r+1]>x$的方案数。

那么转移为

$$f(v,i,l,r)=f(v,i-1,l,r)g(l,r)+\sum_{j<l}f(v,i-1,j,r)(j-1)+\sum_{j>r} f(v,i-1,l,j)(n-j)$$

其中$g(l,r)$为无用操作的数量。

那么答案为

$$ans[i]=\sum_j val[j](h(i,j)-h(i,j-1))$$

其中$h(i,j)$表示位置i的值$\le val[j]$（$val$为权值从小到大排序的数组）的方案数：

$$h(i,j)=\sum_{i\in[l,r]} f(j,m,l,r)$$

这样直接做貌似是$O(n^4)$的，但是因为数据随机，所以实际上是$O(n^2q)$的。

有没有严格的算法呢？答案是有的。

注意到$f(v,i,l,r)$实际对答案的贡献为$f(v,i,l,r)(val[v]-val[v+1])$

那么我们可以直接带着总贡献DP，也就是我们设$dp(i,l,r)=\sum_v f(v,i,l,r)(val[v]-val[v+1])$

实际的转移方程是不变的。

```cpp
#define N 405
const int inf=1e9;
int n,m;
int a[N];
int dp[2][N][N];
int sdp[2][N][N],tdp[2][N][N];
int g[N][N];
il int C2(int n) {return (LL)n*(n+1)/2%md;}
signed main()
{
#ifdef M207
	freopen("in.in","r",stdin);
	// freopen("ot.out","w",stdout);
#endif
	in(n,m);
	for(ri i=1; i<=n; ++i) in(a[i]);
	a[0]=a[n+1]=inf;
	int cur=0,pre=1;
	for(ri l=1; l<=n; ++l)
	{
		int mx=a[l];
		for(ri r=l; r<=n; ++r)
		{
			ckmax(mx,a[r]);
			if(mx<min(a[l-1],a[r+1]))
				dp[cur][l][r]=(mx-(l==1&&r==n?0:min(a[l-1],a[r+1]))+md)%md;
			g[l][r]=add(C2(l-1),C2(r-l+1),C2(n-r));
		}
	}
	for(ri i=1; i<=m; ++i)
	{
		for(ri l=1; l<=n; ++l)
		{
			for(ri r=l; r<=n; ++r)
				sdp[cur][l][r]=add(sdp[cur][l-1][r],mul(dp[cur][l][r],l-1));
			for(ri r=n; r>=l; --r)
				tdp[cur][l][r]=add(tdp[cur][l][r+1],mul(dp[cur][l][r],n-r));
		}
		swap(cur,pre);
		for(ri l=1; l<=n; ++l)
			for(ri r=l; r<=n; ++r)
				dp[cur][l][r]=add(mul(dp[pre][l][r],g[l][r]),sdp[pre][l-1][r],tdp[pre][l][r+1]);
	}
	for(ri i=1; i<=n; ++i)
	{
		int ans=0;
		for(ri l=1; l<=i; ++l)
			for(ri r=i; r<=n; ++r) inc(ans,dp[cur][l][r]);
		out(ans,' ');
	}
	return 0;
}
```

---

## 作者：Kubic (赞：18)

先考虑 $01$ 序列怎么做。我们统计每一个位置最终为 $0$ 的方案数。

如果 $a_i$ 初始是 $1$，那么最终不可能为 $0$。

如果 $a_i$ 初始是 $0$，那么设它左边最后一个 $1$ 的位置为 $L$，右边第一个 $1$ 的位置为 $R$。$a_i$ 最终是 $0$ 等价于 $i\in(L,R)$。每一次操作有可能会将 $(L,R)$ 缩小一点。

我们对初始每一个 $0$ 的极长连续段做一遍 dp。$dp_{x,L,R}$ 表示 $x$ 次操作之后，缩到 $(L,R)$ 的方案数。转移方程：
$$dp_{x,L,R}=dp_{x-1,L,R}\times\left(\dfrac{L(L+1)+(n-R+1)(n-R+2)+(R-L-1)(R-L)}{2}\right)$$

$$+dp_{x-1,L',R}\times L'+dp_{x-1,L,R'}\times (n-R'+1)$$

这个柿子显然可以使用前缀和优化，每一次 dp 的复杂度就是 $O(n^2m)$，总复杂度也是 $O(n^2m)$。

考虑一般序列怎么做。注意到最终序列的某个数 $w$ 可以拆为 $w=\max a_i-\sum\limits_{i=0}^{\max a_i}[w<i]$。

我们枚举这个 $i$，并把所有 $\ge i$ 的位置标为 $1$，把所有 $<i$ 的位置标为 $0$。此时我们就可以算出每一个位置 $<i$ 的方案数。

可以注意到 $i$ 从 $0$ 扫到 $\max a_i$ 的过程中 $01$ 序列状态变化次数只有 $O(n)$ 次。此时我们得到了一个 $O(n^3m)$ 的算法，但由于数据随机，实际复杂度是 $O(n^2m)$ 的。一个单调递增的序列就能将这个算法卡到 $O(n^3m)$。

但其实我们可以找出稳定 $O(n^2m)$ 的算法。可以发现，所有的 $dp$ 值的转移柿子都完全一致，所以我们可以把所有初始值放到同一个 $dp$ 数组里面，然后进行一次整体的 $dp$，就可以求出答案。

关于为什么不拆为 $w=\sum\limits_{i=0}^{\max a_i}[w>i]$ 来做。因为这样做非常困难，统计贡献的时候会与 $L,R$ 的初值有关，不利于进行整体 dp。

时间复杂度 $O(n^2m)$。

参考代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 405
#define MOD 1000000007
int n,m,ans[N],dp[N][N],s1[N][N],s2[N][N];bool vs[N];struct Node {int id,w;}a[N];
bool cmp(Node x,Node y) {return x.w<y.w;}
int add(int x,int y) {x+=y;return x<MOD?x:x-MOD;}
void W(int &x,int y) {x+=y;if(x>=MOD) x-=MOD;}
int qPow(int x,int y)
{int res=1;for(;y;y/=2,x=1ll*x*x%MOD) if(y&1) res=1ll*res*x%MOD;return res;}
int f(int l,int r) {return (l*(l+1)+(n-r+1)*(n-r+2)+(r-l-1)*(r-l))/2;}
int main()
{
	scanf("%d %d",&n,&m);vs[n+1]=1;
	for(int i=1;i<=n;++i) scanf("%d",&a[i].w),a[i].id=i;sort(a+1,a+n+1,cmp);
	for(int i=n,lst;i;--i)
	{
		lst=0;vs[a[i].id]=1;
		for(int j=1;j<=n+1;++j) if(vs[j]) dp[lst][j]+=a[i].w-a[i-1].w,lst=j;
	}ans[1]=1ll*a[n].w*qPow(n*(n+1)/2,m)%MOD;for(int i=2;i<=n;++i) ans[i]=ans[1];
	for(int i=1;i<=m;++i)
	{
		for(int j=0;j<=n;++j) for(int k=n+1;k>j+1;--k)
		{
			s1[j][k]=add(j?s1[j-1][k]:0,1ll*dp[j][k]*j%MOD);
			s2[j][k]=add(k<=n?s2[j][k+1]:0,1ll*dp[j][k]*(n-k+1)%MOD);
		}
		for(int j=0;j<=n;++j) for(int k=j+2;k<=n+1;++k)
		{
			dp[j][k]=1ll*dp[j][k]*f(j,k)%MOD;
			if(j) W(dp[j][k],s1[j-1][k]);if(k<=n) W(dp[j][k],s2[j][k+1]);
		}
	}for(int i=0;i<=n;++i) for(int j=i+2;j<=n+1;++j)
		for(int k=i+1;k<j;++k) W(ans[k],MOD-dp[i][j]);
	for(int i=1;i<=n;++i) printf("%d ",ans[i]);return 0;
}
```

---

## 作者：Kinandra (赞：5)

标签: Dp, 期望.

神奇状态, 神奇Dp.

#### Part 1

先将 $a$ 离散化, 令 $v$ 为所有权值排序后的长度 $top$ 数组(从 $1$ 标号).

列出某个位置 $p$ 答案(在乘上 $(\frac{n(n+1)}{2})^q$ 后) 的表达式: $ans=\sum_{x=0}^{+\infty}x(g_x-g_{x-1})$ , 其中 $g_x$ 表示 $a_i\leqslant x$ 的方案数. 当 $x>a_m=max\{a\}$ 时, $g_x-g_{x-1}=0$ , 故有 $ans=\sum_{x=0}^{a_m}x(g_x-g_{x-1})=a_xg_{a_m}-\sum_{x=1}^{a_m-1}g_x$ . 显然对于某个 $v_j$ , 当 $v_j\leqslant x<v_{j+1}$ 时,  $g_x$ 均相等, 故$ans=a_xg_{a_m}-\sum_{j=1}^{top-1}(v_{j+1}-v_j)g_{v_j}$ , 若定义 $v_{top+1}=0$, 则 $ans=\sum_{j=1}^{top}(v_j-v_{j+1})g_{v_j}$ .

#### Part 2

下面考虑上式怎么求, 这道题难度就在于设计状态上, 这个状态十分奇妙: 令 $f_{i,[l,r]}$ 表示进行 $i$ 次操作后, 枚举 $x\in[1,top]$ ,  将 $\max_{j\in[l,r]}\{a_j\}\leqslant v_x<\min\{a_{l-1},a_{r+1}\}$ (视 $a_0=a_n=+\infty$)的方案数乘上 $(v_x-v_{x+1})$  后求和的结果(捋一捋应该看得懂, 即 $\sum$ 方案数 $\times (v_x-v_{x+1})$).  

那么我们要求的 $ans$ 就可以通过 $f$ 表示: $ans=\sum_{l\leqslant p\leqslant r}f_{q,[l,r]}$ ( $p$ 为我们求答案的位置).

接下来只要解决 $f_{i,[l,r]}$ 的转移就好了, 这个部分十分简单, 枚举第 $i+1$ 次操作的影响, 如果与 $[l,r]$ 没有交, 或被 $[l,r]$ 包含, 则 $l,r$ 不会被改变, 转移到 $f_{i+1,[l,r]}$ ; 若包含 $[l,r]$ , 则不能转移到其他状态; 若 $[l,r]$ 有交集 $T$, 则转移到 $f_{i+1,\complement_{[l,r]}T}$ .

代码十分简单, 时间复杂度 $\mathcal O(n^3)$ .

```cpp
#include <bits/stdc++.h>
#define mod 1000000007
using namespace std;
int read();
int M(int x) { return x >= mod ? x - mod : x; }
void Add(int &x, int y) { (x += y) >= mod ? x -= mod : x; }

int n, m;
int a[502], b[502], st[502], top;
int f[2][502][502];

int s[502], g[502][502];
void init() {
    for (int i = 1; i <= n; ++i) s[i] = i * (i + 1) / 2;
    for (int l = 1; l <= n; ++l)
        for (int r = l; r <= n; ++r)
            g[l][r] = s[l - 1] + s[n - r] + s[r - l + 1];
}

int main() {
    n = read(), m = read(), init();
    for (int i = 1; i <= n; ++i) a[i] = st[i] = read();
    sort(st + 1, st + 1 + n), top = unique(st + 1, st + 1 + n) - st - 1;
    for (int i = 1; i <= n; ++i)
        b[i] = lower_bound(st + 1, st + 1 + top, a[i]) - st;
    b[0] = b[n + 1] = top + 1;

    // for (int i = 1, l, r; i <= n; ++i) {
    // l = r = i;
    // while (b[l - 1] <= b[i]) --l;
    // while (b[r + 1] <= b[i]) ++r;
    // Add(f[0][l][r], M(mod + st[b[i]] - st[b[i] + 1]));
    // }
    for (int l = 1; l <= n; ++l) {
        for (int r = l, mx = 0; r <= n; ++r) {
            mx = max(mx, b[r]);
            for (int i = mx; i < min(b[l - 1], b[r + 1]); ++i)
                Add(f[0][l][r], M(mod + st[i] - st[i + 1]));
        }
    }

    // for (int i = 1; i <= n; ++i) {
    // int res = 0;
    // for (int l = 1; l <= i; ++l)
    // for (int r = i; r <= n; ++r) Add(res, f[0][l][r]);
    // printf("%d ", res);
    // }
    // puts("");

    int p = 0, q = 1;
    for (int i = 1; i <= m; ++i) {
        for (int l = 1; l <= n; ++l)
            for (int r = l; r <= n; ++r)
                f[q][l][r] = 1ll * f[p][l][r] * g[l][r] % mod;
        for (int l = 1; l <= n; ++l)
            for (int r = n, t = 0; r >= l; --r)
                Add(f[q][l][r], t), Add(t, 1ll * f[p][l][r] * (n - r) % mod);
        for (int r = 1; r <= n; ++r)
            for (int l = 1, t = 0; l <= n; ++l)
                Add(f[q][l][r], t), Add(t, 1ll * f[p][l][r] * (l - 1) % mod);
        swap(p, q);
    }

    for (int i = 1; i <= n; ++i) {
        int res = 0;
        for (int l = 1; l <= i; ++l)
            for (int r = i; r <= n; ++r) Add(res, f[p][l][r]);
        printf("%d ", res);
    }
    puts("");
    return 0;
}

int read() {
    int x = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9') f = (c == '-') ? -1 : f, c = getchar();
    while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * f;
}
```



---

## 作者：Redamancy_Lydic (赞：3)

首先，题目上说让期望乘上 $(\frac{n(n+1)}{2})^q$ 的目的就是让我们求方案数与值的乘积。

然后我们考虑在操作过后一个位置上的值相对于原来的值肯定是不降的，于是可以想到对每一个值 $v$ ，原序列中所有 $\le v$ 的元素一定构成了若干连续的区间。对每一个这样的区间而言，操作过后这个区间的左右端点一定是向中间移动的。

于是我们可以对每个区间都考虑一个 DP。设 $dp_{v,x,l,r}$ 表示操作 $x$ 次后区间 $[l,r]$ 中的数字均 $\le v$，且第 $l-1$ 和 $r+1$ 个元素都 $\gt v$ 的方案数。

转移的话显然可以从 $dp_{v,x-1,l,r},dp_{v,x-1,i,r},dp_{v,x-1,l,i}$ 转移过来。具体的，第一种转移相当于第 $x$ 次操作对于区间 $[l,r]$ 来说应该是无用的，即操作区间 $[1,l-1],[l,r],[r+1,n]$ 的总方案数。第二种和第三种转移类似，以第二种为例，相当于第 $x$ 次操作应当在区间 $[1\sim i-1,l-1]$ 进行，这个可以使用两个前缀和优化。转移方程就不写了，其中 $x$ 这一维显然可以滚掉。

回到题面，我们现在要解决的问题就是求每个数字最终大小为某个定值时的方案数。上述 DP 求的是每个区间最终值不大于某个定值时的方案数，那我们对于一个区间 $[l,r]$ 而言，若用 $f(j)$ 表示 $dp_{j,q,l,r}$，那么这个区间最终值等于 $j$ 的方案数显然就是 $f(j)-f(j-1)$。

这样对于每一个元素，我们只需要找到所有包含它的区间，再对于这个元素在该区间内可能变成的所有值都累加答案即可。根据定义，可以保证方案不会重复。

根据数据随机的条件，时间复杂度近似 $\mathcal{O}(n^2q)$，可以通过本题。

但是还有更优的做法。我们发现，对于每一个值 $v$，它所带来的系数是固定的，所以我们可以对 $v$ 这一维直接乘上对应的系数后求和，把总维度优化到三个，用数组 $dp'_{x,l,r}$ 直接表示操作 $x$ 次后区间 $[l,r]$ 的答案，这样我们可以发现转移与上文所述完全一致，不同点在于初值。

具体的，在赋初值的时候我们枚举区间 $[l,r]$，设 $ma$ 为初始序列中下标为 $l-1$ 和 $r+1$ 元素的最小值，同时设 $num$ 表示区间 $[l,r]$ 中元素的最大值，那么可以推出 $dp'_{0,l,r}=num-ma$。

---

## 作者：Sol1 (赞：3)

首先尝试一个多项式复杂度的做法。

对于一个数 $i$，考虑它左边第一个比 $a_i$ 大的数的位置 $L$ 和右边第一个比 $a_i$ 大的数的位置 $R$，显然在操作过程中，这两个位置都会逐渐向 $i$ 紧缩。但是我们无法得知紧缩的过程中这两个位置的值是多少，因此并不能计算出答案。

由于这个做法失败的原因是值的存在，不妨尝试通过设定一个值域线 $V$ 来消去值。具体的，将 $\leq V$ 的值设为 $0$，$>V$ 的值设为 $1$，则随着操作的进行，每一个 $0$ 连续段两侧的 $1$ 都会逐渐向内收缩。这样的好处是左右端点的值一定为 $1$，然后就可以对每一段分别设 $f_{q,l,r}$ 表示 $q$ 次操作后，这一段缩到 $[l,r]$ 的方案数。这个状态的转移非常明显，直接分类讨论下一次操作的位置，写出转移式后用前缀和优化一发就可以 $O(qn^2)$ 了。

最后合并答案时，也可以按照期望的拆分，对每一个值拆一拆贡献。这部分相较 DP 来说非常容易，所以不再赘述。

可惜再结合枚举值是 $O(qn^3)$ 的，虽然在随机数据下经过一定程度的剪枝可以通过，但是我们毕竟希望存在一个更加靠谱的做法。事实上写完代码之后可以发现每一个位置的转移是一些位置的 DP 值的常线性函数，所以可以“合并起来”转移。具体来说，在 $O(qn^3)$ 的做法里面做多次 DP，每次有一些状态有初值；现在把所有的初值都加到同一个 DP 数组里面，仿照刚才的方程做**一次 DP**，最后对答案的贡献在之前是每一次 DP 之后分别加，由于这里每一次 DP 之后加的时候系数都是一样的，所以在合并所有 DP 数组之后还是可以直接取。

这样就从 $n$ 次 DP 变成了一次 DP，复杂度下降为 $O(qn^2)$，对于任意的 $n,q\leq 400$ 的数据就都能通过了。

```cpp
const long long mod = 1000000007;
int n, q, a[405], b[405], vtop;
long long dp[2][405][405], pre[405][405], suf[405][405], ans[405];

inline long long Power(long long x, long long y) {
	long long ans = 1;
	while (y) {
		if (y & 1) ans = ans * x % mod;
		x = x * x % mod;
		y >>= 1;
	}
	return ans;
}

inline void Read() {
	n = qread(); q = qread();
	for (int i = 1;i <= n;i++) b[i] = a[i] = qread();
}

inline void Prefix() {
	sort(b + 1, b + n + 1);
	vtop = unique(b + 1, b + n + 1) - b - 1;
	for (int i = 1;i <= n;i++) a[i] = lower_bound(b + 1, b + vtop + 1, a[i]) - b;
}

inline void Solve() {
	for (int i = 1;i < vtop;i++) {
		for (int j = 1;j <= n;) {
			if (a[j] > i) {
				j++;
				continue;
			}
			int l = j;
			while (j <= n && a[j] <= i) j++;
			dp[1][l][j - 1] = (dp[1][l][j - 1] + (b[i + 1] - b[i]) % mod) % mod;
			for (int k = l;k < j;k++) ans[k] = (ans[k] + (b[i + 1] - b[i]) % mod * Power(n * (n + 1) / 2, q) % mod) % mod;
		}
	}
	for (int j = 1;j <= n;j++) {
		for (int k = j;k <= n;k++) {
			pre[j][k] = (pre[j - 1][k] + dp[1][j][k] * (j - 1) % mod) % mod;
		}
	}
	for (int j = 1;j <= n;j++) {
		for (int k = n;k >= j;k--) {
			suf[j][k] = (suf[j][k + 1] + dp[1][j][k] * (n - k) % mod) % mod;
		}
	}
	long long inv = Power(n * (n + 1) / 2, mod - 2);
	for (int i = 2;i <= q + 1;i++) {
		for (int j = 1;j <= n;j++) {
			for (int k = j;k <= n;k++) {
				dp[i&1][j][k] = (pre[j - 1][k] + suf[j][k + 1] + dp[i - 1&1][j][k] * ((j - 1) * j / 2 + (n - k) * (n - k + 1) / 2 + (k - j + 1) * (k - j + 2) / 2) % mod) % mod;
			}
		}
		for (int j = 1;j <= n;j++) {
			for (int k = j;k <= n;k++) {
				pre[j][k] = (pre[j - 1][k] + dp[i&1][j][k] * (j - 1) % mod) % mod;
			}
		}
		for (int j = 1;j <= n;j++) {
			for (int k = n;k >= j;k--) {
				suf[j][k] = (suf[j][k + 1] + dp[i&1][j][k] * (n - k) % mod) % mod;
			}
		}
	}
	/*
	for (int l = 1;l <= n;l++) {
		for (int r = l;r <= n;r++) cout << dp[2][l][r] << " ";
		cout << endl;
	}
	*/
	for (int i = 1;i <= n;i++) {
		for (int l = 1;l <= i;l++) {
			for (int r = i;r <= n;r++) ans[i] = (ans[i] - dp[q + 1&1][l][r] + mod) % mod;
		}
	}
	for (int i = 1;i <= n;i++) cout << (ans[i] + Power(n * (n + 1) / 2, q) * b[a[i]]) % mod << ' '; cout << endl;
}
```

---

## 作者：_lbw_ (赞：3)

模拟赛场切黑题+爆标。

这是一个很直接的做法，不知道为什么其他人状态那么奇怪。

与值域有关的区间修改，可以转化为求 $\ge i$ 的期望。

设 $b$ 表示值域排序去重后的结果，答案可以表示为 $\sum\limits_{i=1}^{cnt}\sum\limits_{j=1}^n(P(a_j\geq b_i)-P(a_j\geq b_{i+1}))\times b_i$。

接下来若操作 $l,r$ 区间，若 $l,r$ 内至少一个 $1$ 则全覆盖为 $1$。

然后射寄 dp，这里状态与大多数人不同。

我们发现一个区间是否被全覆盖为 $1$ 取决于至少一个 $1$。

所以 $f_{l,r,k}$ 表示做了 $i$ 次 $l,r$ 至少一个 $1$ 的方案数。

考虑转移，枚举 $l,r,k$，划分为三个区间 $[1,l)$，$[l,r]$，$(r,n]$。

分为多种情况转移，设操作区间为 $i,j$。

1. $i,j$ 在同一区间 $f_{l,r,k}\gets f_{l,r,k-1}$

2. $i\in[1,l),j\in[l,r]$，这时我们发现操作后 $[l,r]$ 内有 $1$ 等价于操作前 $[i,r]$ 内有一，于是 $f_{l,r,k}\to f_{i,r,k-1}$

3. $i\in[l,r],j\in(r,n]$，与上种情况同理。

4. $i\in[1,l),j\in(r,n]$，这时 $f_{l,r,k}\gets f_{i,j,k-1}$。

二维前缀和优化即可，时间复杂度 $\mathcal{O}(qn^3)$。

笔者这种做法并没有利用题目随机的性质，于是不得不继续优化。

接下来我们发现转移全都是关于 $f_{l,r}$ 的线性变换，每一次的转移后的结果是转移前的结果的一次函数。

于是将所有 $f$ 的初值加起来，最后进行一次 dp 即可。

时间复杂度 $\mathcal{O}(qn^2)$。

码：

```cpp
#define x1 xxxxx1
#define y1 xxxxx2
#define x2 xxxxx3
#define y2 xxxxx4
const int maxn = 4e2+5;ll ans[maxn];bool orz[maxn][maxn];
ll n,q,b[maxn],a[maxn],dp[maxn][maxn],tmp[maxn][maxn],P[maxn][maxn];
ll sum[maxn][maxn];
I qpow(ll n,ll base=cht-2){
	ll ans=1;
	while(base){
		if(base&1)ans=ans*n%cht;
		n=n*n%cht;base>>=1;
	}
	return ans;
}
IV cadd(ll&x,ll val){x=(x+val)%cht;}I S2(ll n){return n*(n+1)>>1;}
I S(ll x1,ll x2,ll y1,ll y2){
	ll pS=sum[x2][y2]-sum[x2][y1-1]-sum[x1-1][y2]+sum[x1-1][y1-1];
	return(pS%cht+cht)%cht;
}
int main(){
	// freopen("1.in","r",stdin);
	n=read();q=read();F(i,1,n)b[i]=a[i]=read();
	sort(b+1,b+1+n);ll cnt=unique(b+1,b+1+n)-b-1;
	ll all=qpow(n*(n+1)/2);
	F(val,1,cnt){
		F(j,1,n)orz[j][j]=(a[j]>=b[val]);
		D(i,n,1)F(j,i+1,n)orz[i][j]=orz[i+1][j]|orz[i][i];
		F(i,1,n)F(j,1,n)cadd(dp[i][j],orz[i][j]*(b[val]-b[val-1]));
	}
	F(t,1,q){
		mem(tmp,0);
		F(i,1,n)F(j,1,n)sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+dp[i][j];
		F(i,1,n)F(j,i,n){
			cadd(tmp[i][j],S(1,i-1,j,j)*(j-i+1));
			cadd(tmp[i][j],S(i,i,j+1,n)*(j-i+1));
			cadd(tmp[i][j],S(1,i-1,j+1,n));
			cadd(tmp[i][j],dp[i][j]*(S2(i-1)+S2(j-i+1)+S2(n-j)));
		}
		F(l,1,n)F(r,l,n)dp[l][r]=tmp[l][r];
	}
	F(i,1,n){
		cadd(ans[i],dp[i][i]);
		printf("%lld ",ans[i]);
	}
	return 0;
}
```


---

## 作者：tzl_Dedicatus545 (赞：2)

经典 trick：关于 $\min/\max$ 的非 ds 问题先想 $01$ 序列上面怎么做（你不会 $01$ 序列**一定**不会原问题）

额，这个题在 $01$ 序列上很简单啊！你对 $[l,r]$ 是否是极大全 $0$ 段 dp，然后因为数据随机，复杂度是 $qn^2\log n$ 的（如果我没分析错，考虑每个 $1$ 期望在某个段的中间，导致转移时间 $÷2$）

转移就是枚举覆盖到的 $1$。

假如你不满足于此，应该怎么做呢？

注意到每次 dp 的结构相同，只是初值不同，这启示我们拉格朗日插值/一起 dp。

这个题你就把所有的初值加在一起，一起 dp 就行了，转移和上面一样。

---

## 作者：biyi_mouse (赞：1)

[或许更好的阅读体验](https://www.cnblogs.com/biyimouse/p/18807792)

首先观察题面，期望乘上 $(\frac{n(n + 1)}{2})^q$ ，即乘上所有可能的操作数。其实就是求所有可能的值乘上方案数。可以根据期望的定义感性理解一下。

所有我们不妨先把答案的式子写出来，即 $ans_i = \sum v_j \times h(i, v_j)$，其中 $h(i, v)$ 为第 $i$ 个数为 $v$ 的方案数。

然后考虑如何计算 $h(i, v)$，一个很经典的技巧就是用第 $i$ 个数小于等于 $v$ 的方案数减去小于等于 $v - 1$ 的方案数。

所以我们不妨继续尝试下 DP。容易发现 DP 的阶段应该是操作的次数，记为 $i$；同时为了满足上述计算，还要记录一个值 $v$。然后你会发现不能单独记录某一个数的值为 $v$，因为题目是区间操作，所以记录某个区间 $[l, r]$ 内的数全部小于等于 $v$。同时我们给出必要的限制，即 $a_{l - 1}$ 和 $a_{r + 1}$ 都必须大于 $v$。

到此，我们便顺利地得出状态表示 $f(i, v, l, r)$，其含义就是上文的叙述。

然后思考转移，这一步比较简单，我们直接给出转移式。

$$ f(i, v, l, r) = f(i - 1, v, l, r) \times g(l, r) + \sum_{j > r} f(i - 1, v, l, j) + \sum_{j < l}f(i - 1, v, j, r)$$

其中 $g(l, r)$ 记录的是所有没有影响的操作。这些操作可以是对于 $[l, r]$ 内部区间修改成最大值，也可以是对于 $[1, l - 1]$ 和 $[r + 1, n]$ 的。

所以 $g(l, r) = \frac{(r - l + 1)(r - l + 2)}{2} + \frac{l(l + 1)}{2} + \frac{(n - r)(n - r + 1)}{2}$。

到此我们便得到了 $O(n^3q)$ 的做法，但是由于数据随机所以近似于 $O(n^2q)$ 就可以过了。

然而我们可以继续优化，注意到在 $f$ 的式子中上述式子中全程 $v$ 没有变化，所以我们不妨思考一下如何去掉这一维。

此时我们再把 $f$ 代入 $h$，可以得到 $h(i, v) = \sum_{i \in [l, r]} [f(q, v, l, r) - f(q, v - 1, l, r)]$，所以就有 $ans_i = \sum v_j \times \sum_{i \in [l, r]} [f(q, v_j, l, r) - f(q, v_j - 1, l, r)]$。

此时我们可以发现，对于某个 $f(q, v, l, r)$，它的贡献为 $f(q, v, l, r) \times (v_j - v_{j + 1})$，因此我们可以直接带着 $(v_j - v_{j + 1})$ 的贡献做 DP，这样就只要记录 $f'(q, l, r)$ 就行了。

但这样子初值就不同了，考虑对于 $f'(0, l, r)$ 它要带有 $v_1 - v_2 + v_2 - v_3 + \dots$ 的贡献，我们会发现 $f'(0, l, r)$ 其实就是区间最大值减最小值，直接做就完了。

于是我们就优化到了 $O(n^2q)$，彻底拿下了这道题。具体实现时，由于这个题空间给的很小，还需要滚动数组优化下空间。

```cpp
#include <bits/stdc++.h>
#define rep(i, a, b) for (int i = (a); i <= (b); i ++)
#define fro(i, a, b) for (int i = (a); i >= b; i --)
#define INF 0x3f3f3f3f
#define eps 1e-6
#define lowbit(x) (x & (-x))
#define initrand srand((unsigned)time(0))
#define random(x) ((LL)rand() * rand() % (x))
#define eb emplace_back
using namespace std;
typedef long long LL;
typedef pair<int, int> PII;
typedef pair<double, int> PDI;
inline int read() {
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = (x << 1) + (x << 3) + (ch ^ 48); ch = getchar(); }
    return x * f;
}

const int N = 1010, Mod = 1e9 + 7;

int n, q;
int a[N], f[2][N][N], g[N][N], s1[2][N][N], s2[2][N][N];

int add(int a, int b, int c) {
    return ((a + b) % Mod + c) % Mod;
}
int mul(int a, int b) {
    return 1ll * a * b % Mod;
}
int calc(int x) {
    return 1ll * x * (x + 1) / 2;
}

int main() {
    cin >> n >> q;
    for (int i = 1; i <= n; i ++) cin >> a[i];
    a[0] = a[n + 1] = 1e9 + 1;
    for (int l = 1; l <= n; l ++) {
        int maxx = 0;
        for (int r = l; r <= n; r ++) {
            maxx = max(maxx, a[r]);
            if (l == 1 && r == n) f[0][l][r] = maxx;
            else if (a[l - 1] > maxx && a[r + 1] > maxx)
                f[0][l][r] = (maxx - min(a[l - 1], a[r + 1]) + Mod) % Mod;
            g[l][r] = add(calc(r - l + 1), calc(l - 1), calc(n - r));
        }
    }
    for (int i = 1; i <= q; i ++) {
        int now = i & 1, pre = i & 1 ^ 1;
        for (int l = 1; l <= n; l ++) {
            for (int r = l; r <= n; r ++) 
                s1[pre][l][r] = (s1[pre][l - 1][r] + mul(f[pre][l][r], l - 1)) % Mod;
            for (int r = n; r >= l; r --)  
                s2[pre][l][r] = (s2[pre][l][r + 1] + mul(f[pre][l][r], n - r)) % Mod;
        }
        for (int l = 1; l <= n; l ++)
            for (int r = l; r <= n; r ++)           
                f[now][l][r] = add(mul(f[pre][l][r], g[l][r]), s1[pre][l - 1][r], s2[pre][l][r + 1]);
    }
    for (int i = 1; i <= n; i ++) {
        int ans = 0;
        for (int l = 1; l <= i; l ++)
            for (int r = i; r <= n; r ++)
                ans = (ans + f[q & 1][l][r]) % Mod;
        cout << ans << " ";
    }
    return 0;
}
```

---


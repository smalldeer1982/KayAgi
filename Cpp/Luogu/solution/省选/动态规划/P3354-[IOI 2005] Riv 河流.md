# [IOI 2005] Riv 河流

## 题目描述

几乎整个 Byteland 王国都被森林和河流所覆盖。小点的河汇聚到一起，形成了稍大点的河。就这样，所有的河水都汇聚并流进了一条大河，最后这条大河流进了大海。这条大河的入海口处有一个村庄——名叫 Bytetown。

在 Byteland 国，有 $n$ 个伐木的村庄，这些村庄都座落在河边。目前在 Bytetown，有一个巨大的伐木场，它处理着全国砍下的所有木料。木料被砍下后，顺着河流而被运到 Bytetown 的伐木场。Byteland 的国王决定，为了减少运输木料的费用，再额外地建造 $k$ 个伐木场。这 $k$ 个伐木场将被建在其他村庄里。这些伐木场建造后，木料就不用都被送到 Bytetown 了，它们可以在运输过程中第一个碰到的新伐木场被处理。显然，如果伐木场座落的那个村子就不用再付运送木料的费用了。它们可以直接被本村的伐木场处理。

注：所有的河流都不会分叉，形成一棵树，根结点是 Bytetown。

国王的大臣计算出了每个村子每年要产多少木料，你的任务是决定在哪些村子建设伐木场能获得最小的运费。其中运费的计算方法为：每一吨木料每千米 $1$ 分钱。

## 说明/提示

#### 数据规模与约定

- 对于 $50\%$ 的数据，保证 $n\le 20$。
- 对于 $100\%$ 的数据，保证 $2\le n\le 100$，$1\le k\le \min(n,50)$，$0\le v_i\le n$，$0\le w_i\le 10^4$，$1\le d_i\le 10^4$。
- 保证每年所有的木料流到 bytetown 的运费不超过 $2\times 10^9$ 分。

## 样例 #1

### 输入

```
4 2
1 0 1
1 1 10
10 2 5
1 2 3```

### 输出

```
4```

# 题解

## 作者：Treeloveswater (赞：76)

为什么要多叉树转二叉树？

本蒟蒻觉得根本不需要。

看到楼上都是转树，太麻烦，对于新手也不友好，我遂发一道不需要转树的做法。

这道题的DP式比较难想，我之前一直以为是二维DP，却发现是3维

F[i][j][k]表示以i为根的树，j是i的某个祖先，j上有伐木场，i和i的子树一共用了k个伐木场所需要的最小费用。

我们可以开两个数组，f表示i没建，g表示i建了伐木场。为了方便最后用f表示答案即可。

递推式的话，看看代码就可以看懂了。

祝大家NOIP2017 RP++

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int head[501],nxt[1001],point[1001],weight[1001],sum[501],stack[1001],deep[1001];
long long f[111][111][51],g[111][111][51];
int n,tot,K,vi,di,size;
void addedge(int x,int y,int cap){
    tot++;nxt[tot]=head[x];head[x]=tot;point[tot]=y;weight[tot]=cap;
}
void dfs(int i){
    stack[++size]=i;
    for(int tmp=head[i];tmp;tmp=nxt[tmp]){
        int v=point[tmp];
        deep[v]=deep[i]+weight[tmp];
        dfs(v);
        for(int j=1;j<=size;j++)
            for(int k=K;k>=0;k--){
                f[i][stack[j]][k]+=f[v][stack[j]][0];
                g[i][stack[j]][k]+=f[v][i][0];
                for(int x=0;x<=k;x++){
                    f[i][stack[j]][k]=min(f[i][stack[j]][k],f[i][stack[j]][k-x]+f[v][stack[j]][x]);
                    g[i][stack[j]][k]=min(g[i][stack[j]][k],g[i][stack[j]][k-x]+f[v][i][x]);
                }
            }
    }
    //这里是将f和g合并了，因为之后就不在乎i有没有建伐木场，只关心i和i的子树建了多少。
    for(int j=1;j<=size;j++)
        for(int k=0;k<=K;k++){
            if(k>=1)
                f[i][stack[j]][k]=min(f[i][stack[j]][k]+sum[i]*(deep[i]-deep[stack[j]]),g[i][stack[j]][k-1]);
    //这里是g[i][stack[j]][k-1]的原因是：因为我们之前算g的时候，是假设i上有伐木场。而我们实际上没有把这个伐木场的数量加进去。所以合并前g[i][j][k]实际上代表的是g[i][j][k+1]
            else 
                f[i][stack[j]][k]+=sum[i]*(deep[i]-deep[stack[j]]);
        }
        
    size--;
}
int main(){
    scanf("%d%d",&n,&K);
    for(int i=1;i<=n;i++){
        scanf("%d%d%d",&sum[i],&vi,&di);
        addedge(vi,i,di);
    }
    dfs(0);
    printf("%d\n",f[0][0][K]);
}
```

---

## 作者：resftlmuttmotw (赞：46)

## 题目
[题目链接](https://www.luogu.org/problemnew/show/P3354)

## 思路

整道题看起来有很多要点要考虑

最先想出的DP方程

```cpp
dp[i][j]表示第i个结点所在子树建j个伐木场的最小花费
dp[i][j] = min(dp[v][k] + cost)
```

看起来挺好的，时间复杂度也不高，但问题来了

cost怎么算啊

不知道剩余木材 不知道走的距离

于是老师说 $\color{red}\text{要三维}$

```cpp
定义dp[i][j][k]表示第i个结点所在子树建j个伐木场且最近的一个伐木场在k
```

然后我  $\color{blue}\text{没有想出来}$

于是去看了洛谷题解，但觉得讲的不是很清楚，特于此再写一篇

定义四维的

```cpp
dp[i][j][k]表示第i个结点最近且建了伐木场的为j 共建k个的最小花费 1 表示在i点建了
```

注意 上面的最近伐木场指的是祖先结点上的

记录祖先 考虑用

```cpp
ancestor[++tot] = x;放在dfs里的首行
```

```cpp
tot--；放在末行
```

非常好理解

记录距离和木材数

只要知道应前往之地和现在所在之地 就可以用这种方式表示

```cpp
u:现在所在之地
v:应前往之地
dep[i]记录i到根1的距离
即dis(u,v) = |dep[v] - dep[u]|
```

木材数则从这里一次性运到伐木场，所以不记录中间状态

```cpp
wood[i]表示i点的木材
```
然后就是最重要的状态转移方程了

```cpp
dp[x][fa][k][0] = Min(dp[x][fa][k][0],dp[v][fa][l][0] + dp[x][fa][k - l][0]);
dp[x][fa][k][1] = Min(dp[x][fa][k][1],dp[v][x][l][0] + dp[x][fa][k - l][1]);	
```

然后就有非常讲究的事儿了

```cpp
for(j = 1;j <= tot;j++)
{
//j的顺序无所谓
	int fa = ancestor[j];
	for(k = maxk;k >= 0;k--)
	{
	//k的顺序不能倒，因为不能用更新过的状态来更新（会让dp[v]多次被计算）
		dp[x][fa][k][0] += dp[v][fa][0][0];
		dp[x][fa][k][1] += dp[v][x][0][0];
		/*因为没有初始化dp，最先它自己一定为0
		如果不单独提出来处理，会保持0的状态 不被更新
		*/
		for(l = 0;l <= k;l++)
		{
		//这个l顺序也无所谓
			dp[x][fa][k][0] = Min(dp[x][fa][k][0],dp[v][fa][l][0] + dp[x][fa][k - l][0]);
			dp[x][fa][k][1] = Min(dp[x][fa][k][1],dp[v][x][l][0] + dp[x][fa][k - l][1]);	
		}
	}
}
```

还有一点得知道

```cpp
第四维 表示的是当前结点是否有伐木场
在回溯后就没用了，因此需要进行合并，且还得将当前结点的木材运至方程中的fa
for(i = 1;i <= tot;i++)
{
//i的顺序无所谓
	int fa = ancestor[i];
	for(j = 0;j <= maxk;j++)
	{
	//j的顺序也无所谓
		if(j >= 1)
			dp[x][fa][j][0] = Min(dp[x][fa][j][0] + wood[x] * (dep[x] - dep[fa]),dp[x][fa][j - 1][1]);
		//单独处理是因为0 - 1 = -1 造成数组越界
		/*
		那为什么会有-1的操作了
		原题解说的挺清楚的
		先前算的dp[x][fa][k][1]是用dp[v][x][l][0] + dp[x][fa][k - l][1]来更新的
		而l + k - l = k < k + 1，但我们此时表示的是k + 1 的状态，故需-1
		也可以在上诉方程中加个-1
		改成dp[v][x][l][0] + dp[x][fa][k - l + 1][1]
		*/
		else dp[x][fa][j][0] += wood[x] * (dep[x] - dep[fa]);
		//先前的记录
	}
}
```

## 代码

```cpp
#include <vector>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
  
inline void Read(int &x)
{
    x = 0;
    char a = getchar();
    bool f = 0;
    while(a < '0'||a > '9') {if(a == '-') f = 1;a = getchar();}
    while(a >= '0'&&a <= '9') {x = x * 10 + a - '0';a = getchar();}
    if(f) x *= -1;
}
const int MAXN = 202;
vector<int> G[MAXN],Road[MAXN];
int maxk,wood[MAXN],ancestor[MAXN],tot,dep[MAXN],dp[MAXN][MAXN][52][2];
bool vis[MAXN];
//dp[i][j][k]表示第i个结点最近且建了伐木场的为j 共建k个的最小花费 1 表示在i点建了 

template<typename T>
inline T Min(T a,T b) {if(a < b) return a;return b;}
inline void dfs(int x)
{
	int i,j,k,l;;
	ancestor[++tot] = x;
	for(i = 0;i < G[x].size();i++)
	{
		int v = G[x][i],w = Road[x][i];
		if(!vis[v])
		{
			vis[v] = 1;
			dep[v] = dep[x] + w; 
			dfs(v);
			for(j = tot;j >= 1;j--)
			{
				int fa = ancestor[j];
				for(k = maxk;k >= 0;k--)
				{
					dp[x][fa][k][0] += dp[v][fa][0][0];
					dp[x][fa][k][1] += dp[v][x][0][0];
					for(l = k;l >= 0;l--)
					{
						dp[x][fa][k][0] = Min(dp[x][fa][k][0],dp[v][fa][l][0] + dp[x][fa][k - l][0]);
						dp[x][fa][k][1] = Min(dp[x][fa][k][1],dp[v][x][l][0] + dp[x][fa][k - l][1]);	
					}
				}
			}
		}
	}
	for(i = 1;i <= tot;i++)
	{
		int fa = ancestor[i];
		for(j = maxk;j >= 0;j--)
		{
			if(j >= 1)
				dp[x][fa][j][0] = Min(dp[x][fa][j][0] + wood[x] * (dep[x] - dep[fa]),dp[x][fa][j - 1][1]);
			else dp[x][fa][j][0] += wood[x] * (dep[x] - dep[fa]);
		}
	}
	tot--;
}
int main()
{
	int n,i;
	Read(n),Read(maxk);
	for(i = 1;i <= n;i++)
	{
		int v,dis;
		Read(wood[i]),Read(v),Read(dis);
		G[i].push_back(v);
		G[v].push_back(i);
		Road[i].push_back(dis);
		Road[v].push_back(dis);
	}
	vis[0] = 1;
	dfs(0);
	printf("%d",dp[0][0][maxk][0]);
    return 0;
}
```

---

## 作者：花里心爱 (赞：35)

一道比较难想的树形dp。

我们先按照一般思路考虑，先设$f[u][j]$为当前在$u$号点，$u$及$u$的子树建了$j$个伐木场的运费最小值。

然后我们就会发现每段路的运费不好统计，原因是我们不容易知道从$u$的子树运上来的木料数。

于是我们反着考虑，考虑计算将$u$与$u$的子树中所有的木料运上去所需要的最小花费。这时我们就会发现我们需要知道$u$中的木料运去了哪里，即离$u$最近的建了伐木场的祖先。最后再合并$u$子树中的答案即可。

设$f[u][i][j]$表示当前在$u$号点，离$u$最近的建了伐木场的祖先为$i$，$u$及$u$的子树建了$j$个伐木场的运费最小值。

然后我们还需要考虑在$u$建伐木场的情况。再设$g[u][i][j]$表示当前在$u$号点，离$u$最近的建了伐木场的祖先为$i$，$u$建了伐木场，且$u$的子树建了$j$个伐木场的运费最小值。

则状态转移可以看成一个背包模型。

实现的细节还是很多的，下面上代码（具体转移和实现细节在注释里）：
```cpp
#include <cstdio>
#include <cctype>
#include <algorithm>
#define maxn 105
inline int read() {
    int d=0;char ch=getchar();while(!isdigit(ch))ch=getchar();
    while(isdigit(ch)){d=d*10+ch-48;ch=getchar();}return d;
}

int n, k;
int w[maxn], v[maxn], d[maxn];
int head[maxn], ver[maxn], nxt[maxn], tot;

inline void add(int u, int v) {
    ver[++tot] = v, nxt[tot] = head[u], head[u] = tot;
}

int dep[maxn]; // 每个节点的深度
int f[maxn][maxn][maxn], g[maxn][maxn][maxn];
int stk[maxn], tots; // 为了方便转移，我们用一个栈维护u的祖先

void dfs(int u) {
    stk[++tots] = u;
    for(int p = head[u]; p; p = nxt[p]) {
        int v = ver[p];
        dep[v] = dep[u]+d[v], dfs(v);
        // 先向下递归，算出子树的答案
        // 当前要统计的子树为v
        for(int i = 1; i <= tots; ++i) { // 枚举祖先
            for(int j = k; j >= 0; --j) { // 这里j的顺序不能反，因为我们是拿之前的状态去更新新的状态
                f[u][stk[i]][j] += f[v][stk[i]][0];
                g[u][stk[i]][j] += f[v][u][0];
                // 注意在增加一棵子树的时候，状态表示的范围扩大了
                // 所以必须先将一个状态拿出来先更新，否则f和g表示的答案不包括当前子树
                for(int l = 1; l <= j; ++l) {
                    // 当前子树v总共建了l个伐木场，此时u前面的子树建了j-l个伐木场
                    
                    // u不建伐木场，此时子树中未被处理的木料要全部运往stk[i]
                    f[u][stk[i]][j] = std::min(f[u][stk[i]][j], f[v][stk[i]][l]+f[u][stk[i]][j-l]);
                    
                    // u建伐木场，子树中未被处理的木料需要运往u
                    g[u][stk[i]][j] = std::min(g[u][stk[i]][j], f[v][u][l]+g[u][stk[i]][j-l]);
                }
            }
        }
    }
    
    // 统计点u的贡献，更新最终答案
    for(int i = 1; i <= tots; ++i) {
        for(int j = k; j >= 1; --j)
            f[u][stk[i]][j] = std::min(f[u][stk[i]][j]+w[u]*(dep[u]-dep[stk[i]]), g[u][stk[i]][j-1]);
        f[u][stk[i]][0] += w[u]*(dep[u]-dep[stk[i]]);
        // 要把u中的木料运到stk[i]，需要花费w[u]*(dep[u]-dep[stk[i]])
        // 我们不需要考虑u子树的花费，因为它们已经在之前被算过了
    }
    --tots;
}

int main() {
    n = read(), k = read();
    for(int i = 1; i <= n; ++i) {
        w[i] = read(), v[i] = read(), d[i] = read();
        add(v[i], i);
    }
    dfs(0);
    printf("%d", f[0][0][k]); // 最后答案即为f[0][0][k]
    return 0;
}
```

---

## 作者：Twilight_ (赞：17)

　　一节语文课想出来的玩意儿，调了几个小时……可见细心&好的代码习惯是有多么的重要 (；へ：)

　　好像这题的正解是多叉树转二叉树？可是我并不会啊。首先我们看到这题的范围非常的小，所以肯定除了爆搜之外的乱搞都OK。（说不定爆搜+超强剪枝啥的也可以？但我没有尝试了……）那我们开始分析一波：动态规划最忌把所有东西都糊在一坨，重在分别状态，所以自然我们第一步需要建立出状态&分析出每一个节点独立的贡献。建立状态我们先采用最自然的想法：dp[u][k]表示u节点下k个节点建立了伐木场的最大贡献。

　　最大贡献……什么是贡献？正向的统计节点的花费好像不是很容易，不如考虑减少的花费。如果我们在一个节点上建立了伐木场，则该节点向下往叶子上走，遇到的第一个伐木场之间的节点都会运向该伐木场，所节省的成本即为dis[u] × w[v]。那么我们的思路就形成了：dp[u][k] 表示u节点下k个节点建立了伐木场的最大贡献，且强制第k个建立在u节点上。对于每一个u节点而言，我们都遍历一遍它的子树，求出 f 数组，f[u][k] 表示u & u的子树中建立k个伐木场的最大贡献（不强制建在u节点上）。

　　转移方程：背包求出组合最优解，求f数组时枚举：该节点建伐木场：伐木场数量+1，贡献 + dis[v] × w[v]；该节点不建立伐木场：受当前 dp 建立的伐木场的‘管辖’，贡献 + dis[u] × w[v]；最关键的地方还是在于将子树状态与父亲状态分离开来，这样就方便进行状态的转移了。

　　虽然感觉复杂度非常的高：达到了n * n * k * k
的级别，然而在rank1？大概是玄学……

更好的阅读体验 + 作者心声【笑哭】
[Twilight's Blog](http://www.cnblogs.com/twilight-sx/p/9053516.html)

```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn 105
int n, K, cnp = 1, ans, head[maxn], w[maxn];
int dis[maxn], size[maxn]; 
int dp[maxn][maxn], f[maxn][maxn];

struct edge
{
	int to, co, last;
}E[maxn];

int read()
{
    int x = 0, k = 1;
    char c;
    c = getchar();
    while(c < '0' || c > '9') { if(c == '-') k = -1; c = getchar(); }
    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * k;
}

void add(int u, int v, int w)
{
	E[cnp].to = v, E[cnp].co = w;
	E[cnp].last = head[u], head[u] = cnp ++;
}

void gmax(int &a, int b) { a = a > b ? a : b; } 

void DP(int u, int gra)
{
	f[u][0] = dis[gra] * w[u];
	for(int i = head[u]; i; i = E[i].last) 
	{
		DP(E[i].to, gra);
		for(int j = min(size[u], K); ~j; j --)
		{
			int lim = min(size[E[i].to], j); 
			for(int k = 0; k <= lim; k ++)
				gmax(f[u][j], f[E[i].to][k] + f[u][j - k]);
		}
	}
	for(int j = size[u]; j; j --) gmax(f[u][j], dp[u][j]);
}

void dfs(int u)
{
	size[u] = 1;
	for(int i = head[u]; i; i = E[i].last)
	{
		int v = E[i].to;
		dis[v] = E[i].co + dis[u]; 
		dfs(v); size[u] += size[v];
	}
	dp[u][0] = 0, ans += dis[u] * w[u];
	memset(f, 0, sizeof(f));
	for(int i = head[u]; i; i = E[i].last) 
	{
		DP(E[i].to, u);
		for(int j = min(K, size[u]); ~j; j --)
			for(int k = 0; k <= min(j, size[E[i].to]); k ++)
				gmax(dp[u][j], f[E[i].to][k] + dp[u][j - k]);
	}
	for(int i = min(size[u], K); i; i --) dp[u][i] = dp[u][i - 1] + dis[u] * w[u];
}

int main()
{
	n = read(), K = read();
	memset(dp, 0, sizeof(dp));
	for(int i = 1; i <= n; i ++)
	{
		w[i] = read(); int v = read(), z = read(); 
		add(v, i, z);
	}
	dfs(0); int tem = 0;
	memset(f, 0, sizeof(f)); 
	for(int i = head[0]; i; i = E[i].last) 
	{
		DP(E[i].to, 0);
		for(int j = min(size[0], K); ~j; j --)
		{
			int lim = min(size[E[i].to], j); 
			for(int k = 0; k <= lim; k ++)
				gmax(f[0][j], f[E[i].to][k] + f[0][j - k]);
		}
	}
	for(int i = 1; i <= size[0]; i ++) tem = max(tem, f[0][i]);
	printf("%d\n", ans - tem);
	return 0;
}
```

---

## 作者：微雨燕双飞 (赞：12)

本题虽为ioi原题，但整体思路算法难度却不必提高组高多少。可以看作是一个深搜与dp的结合。核心算法是将朴素的父亲表示法转换为兄弟儿子表示法，至于dp方程大家可以自己推导一下，如果不会兄弟儿子表示法可以在数据结构书上找到自行学习，这是本题最大的难点。

不多说了，贴代码：



```cpp
#include<cstring> 
#include<iostream>
using namespace std;
int son[105],bro[105],w[105],v[105],d[105],dis[105][105],n,i,k,f[105][105][105];
void dfs(int u,int liml)
{
 int s=son[u];
 int b=bro[u];
 for(int l=1; l<=liml; l++)
   dis[u][l]=dis[v[u]][l-1]+d[u];
 if(s!=0) dfs(s,liml+1);
 if(b!=0) dfs(b,liml);
 for(int i=0; i<=n; i++)
  for(int j=0; j<=n-i; j++)
   for(int l=1; l<=liml; l++)
   {
    f[u][i+j][l]=min(f[u][i+j][l],f[s][i][l+1]+f[b][j][l]+w[u]*dis[u][l]); 
    f[u][i+j+1][l]=min(f[u][i+j+1][l],f[s][i][1]+f[b][j][l]);
   }
}
int main()
{
 cin>>n>>k;
 for(int i=1; i<=n; i++) 
 {
  cin>>w[i]>>v[i]>>d[i];
  bro[i]=son[v[i]];
  son[v[i]]=i;
 }
 memset(f,0x7f,sizeof(f));
 for (int i = 0; i <= n; i++) 
   for (int j = 0; j <= n; j++)
     f[0][i][j] = 0;
 dfs(son[0],1);
 cout<<f[son[0]][k][1]<<endl; 
}
```

---

## 作者：slgdsxw (赞：11)

怎么没有wqs二分的题解……

树形dp的做法就不多赘述了， $f(i,j,k)$ 表示点 $i$ 下游第一个伐木场在点 $j$ ， $i$ 和其子树内建 $k$ 个伐木场时 ， 点 $i$ 和其子树内的木材运至伐木场的最小代价。理论复杂度 $O(nk^2)$ ，细节处理不好容易被链卡到 $O(nk^3)$ , 注意事项在代码中有注释。

题目要求恰选择 $k$ 个伐木场 ，可以意会到随着选的伐木场个数的增加 ， 代价的减少的速度在降低 (凸性），考虑使用wqs二分解决。 我们去掉树形dp的第三维的个数限制 ，并给每个伐木场的建立附加 $C$ 的代价 ， dp时记录建立的伐木场数 ，据此调整 $C$ 的大小。特别的，无论 $C$ 是多少，当前建立的伐木场数恰等于 $k$ 的时候可以直接退出二分，因为建立伐木场数一定时最小代价显然一定。复杂度 $O(n^2loga)$ ，a指最大可能的答案（所有的木料流到 bytetown 的运费）。

关于wqs二分实现的个人建议：

1. 取值（如分段数，此题即建伐木场数）最大/小化，方便考虑二分范围的转移

1. 答案的计算、dp的细节、二分范围都跟取值的最大/小化的选择相适应

1. 有些数据导致最终二分出来的阙值分的段数多/少，考虑到分的段数固定，答案的最值唯一，当前段数等于所需段数时直接退出二分取当前值，速度和正确性都有保障。阙值需要小数才能分段正确的情况尽量通过 1 避免。

代码如下（细节在注释中）：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=105,inf=0x3f3f3f3f;
int n,k,cnt,top;
int head[N],c[N],fa[N],len[N],dep[N],st[N];
struct edge
{
	int to,nxt;
}pl[N*2];
void add(int u,int v)
{
	pl[++cnt].nxt=head[u];
	pl[cnt].to=v;
	head[u]=cnt;
}
struct wqs
{
	int mid,ansv,sumf;
	int f[N][N],g[N][N];
	void dfs(int u)
	{
		int v;
		sumf+=c[u]*dep[u];
		for(int i=head[u];i;i=pl[i].nxt)
		{
			v=pl[i].to;
			if(v==fa[u])continue;
			dep[v]=dep[u]+len[v];
			dfs(v);
		}
	}
	void dp(int u)
	{
		int v;
		st[++top]=u;
		for(int i=1;i<=top;i++)f[u][st[i]]=g[u][st[i]]=0;//注意初始化 
		for(int i=head[u];i;i=pl[i].nxt)
		{
			v=pl[i].to;
			if(v==fa[u])continue;
			dp(v);
			for(int j=1;j<=top;j++)
			{
				f[u][st[j]]+=f[v][st[j]];
				g[u][st[j]]+=g[v][st[j]];
			}
		}
		f[u][u]+=mid;g[u][u]++;//用祖先是自己代表该点建伐木场的情况 
		for(int i=1;i<=top;i++)
		{
			f[u][st[i]]+=c[u]*(dep[u]-dep[st[i]]);
			if(f[u][u]<=f[u][st[i]])f[u][st[i]]=f[u][u],g[u][st[i]]=g[u][u];//小于等于号表示了在代价最少时尽可能多建伐木场 
		}
		top--;
	}
	void solve()
	{
		k++;// 先选上 bytetown
		sumf=0;
		dfs(0);
		int l=0,r=sumf;
		while(l<=r)
		{
			mid=(l+r)>>1;
			dp(0);
			if(g[0][0]>=k)ansv=mid;//尽可能多选后大于等于 k，说明可能调整到 k ，记录答案 
			if(g[0][0]==k)break;
			if(g[0][0]>k)l=mid+1;
			else r=mid-1;
		}
		mid=ansv;dp(0);
		//cout<<ansv<<endl;
		cout<<f[0][0]-k*mid;//最终答案减去附加的代价 
	}
}s1;
struct treedp// 这里我们的第二维 j 表示 祖先是 st[j] ,f[u][u][k] 表示 u 建伐木场 ，除 u 外还建了 k 个伐木场 
{
	int siz[N],f[N][N][N];
	void solve()
	{
		dp(0);
		cout<<f[0][1][k];
	}
	void dp(int u)
	{
		int v;
		st[++top]=u;
		siz[u]=1;
		for(int i=head[u];i;i=pl[i].nxt)
		{
			v=pl[i].to;
			if(v==fa[u])continue;
			dep[v]=dep[u]+len[v];
			dp(v);
			for(int j=1;j<=top;j++)
			{
				for(int t=min(siz[u]+siz[v],k);t>=0;t--)
				{
					f[u][j][t]+=f[v][j][0];//因为 f 的初值都是 0 ，先选一个状态强制转移在取 min 
					for(int l=max(1,t-siz[u]);l<=min(siz[v],t);l++)// 此时 siz[u] 表示 v 之前的子树大小和 ，第三维大于siz[u] 的状态还未计算无意义 
						f[u][j][t]=min(f[u][j][t],f[u][j][t-l]+f[v][j][l]);//因此 t-l<=siz[u] ，即 l>=t-siz[u] ,不注意这里会被链卡到更劣的复杂度 
				}
			}
			siz[u]+=siz[v];
		}	
		for(int i=top;i>=1;i--)
			for(int j=0;j<=min(siz[u],k);j++)
			{
				f[u][i][j]+=c[u]*(dep[u]-dep[st[i]]);
				if(j>=1)f[u][i][j]=min(f[u][i][j],f[u][top][j-1]); 
			}
		top--;
	}
}s2;
int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
		cin>>c[i]>>fa[i]>>len[i];
		add(fa[i],i);
	}
	s2.solve();
	return 0;
}
```


---

## 作者：Macesuted (赞：6)

[题面](https://www.luogu.com.cn/problem/P3354)

这道题的大致意思就是，在一个以0号节点为根的树上，我需要在k个结点修建伐木场。然后对于每一个点，它对答案的贡献是他木头产量乘上它离下游最近伐木场的距离。让你合理分配伐木场安置距离以使得贡献最小。

其实很容易就会想到用$f_{i,j}$来表示在i号点为根的子树上修建j个伐木场所得的最小贡献，但是我们发现状态并不好维护，所以我们需要改变一定的想法。

我们这里采用$f_{i,j,k}$表示在i为根的子树上修建k个伐木场，并且i下游的第一个伐木场在j，然后该状态下贡献的最小值。然后我们再记录$g_{i,j,k}$为i号点上建造伐木场，并且在i的子树上一共有k个伐木场，i下游的第一个伐木场是j，然后该状态下的最小值。

所以我们只要最后推到$f_{0,0,k}$然后输出就是最后答案了。

再考虑动态转移方程，很容易想到转移的过程就是一个背包的过程，然后为了记录某一结点所有的祖先，所以我们可以在dfs里加上手写栈（我比较懒，用了一个deque），这样只需要遍历栈就可以知道该点所有的祖先。

## 代码

简单背包模拟即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 105;

struct edge
{
	int to, dist;
};

vector<vector<edge> > graph;

int c[maxn], depth[maxn];
long long f[maxn][maxn][maxn], g[maxn][maxn][maxn];
deque<int> st;
int n, k;

void dfs(int p)
{
	st.push_back(p);
	for (vector<edge>::iterator i = graph[p].begin(); i != graph[p].end(); i++)
	{
		depth[i->to] += depth[p] + i->dist;
		dfs(i->to);
		for (deque<int>::iterator j = st.begin(); j != st.end(); j++)
			for (int l = k; ~l; l--)
			{
				f[p][*j][l] += f[i->to][*j][0];
				g[p][*j][l] += f[i->to][p][0];
				for (int x = 0; x <= l; x++)
				{
					f[p][*j][l] = min(f[p][*j][l], f[p][*j][l - x] + f[i->to][*j][x]);
					g[p][*j][l] = min(g[p][*j][l], g[p][*j][l - x] + f[i->to][p][x]);
				}
			}
	}
	for (deque<int>::iterator j = st.begin(); j != st.end(); j++)
	{
		f[p][*j][0] += c[p] * (depth[p] - depth[*j]);
		for (int l = 1; l <= k; l++)
			f[p][*j][l] = min(f[p][*j][l] + c[p] * (depth[p] - depth[*j]), g[p][*j][l - 1]);
	}
	st.pop_back();
	return;
}

int main()
{
	// freopen("riv.in", "r", stdin);
	// freopen("riv.out", "w", stdout);
	scanf("%d%d", &n, &k);
	graph.resize(n + 1);
	for (int i = 1; i <= n; i++)
	{
		int fa, dist;
		scanf("%d%d%d", c + i, &fa, &dist);
		graph[fa].push_back((edge){i, dist});
	}
	dfs(0);
	printf("%d\n", f[0][0][k]);
	return 0;
}
```

---

## 作者：BeautyYu言醴 (赞：5)

私以为没必要转二叉树

本题应为三维dp,体现的是泛化物品的背包的思想(详见<背包九讲>)

只是决定价值(本题体现为`节省的费用`)的因素不是单一的重量(体现为`产树量`),此外还有一个维度`据上一个伐木场的距离`

代码见下.蒻的英语不是很好请见谅

```c++
//by beautyyu
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <algorithm>
#include <cmath>
#define ull unsigned long long
using namespace std;
struct edge{
    int v,w,nxt;
}e[40000];
int head[200],pwp[200],pre[200],memf[200][200][100],memd[200][200][100];
//pwp--sum weight of a subtree,pre--distance from a node to root
//memf--memory for function'f',the same as memd
int w[200],n,k;
int f(int rt,int fa,int kk);
int d(int l,int fa,int kk);
int dfs(int rt,int pr){//calculate 'pwp' and 'pre'
	pre[rt] = pr;
	pwp[rt] = w[rt];
	for (int i = head[rt];i;i = e[i].nxt)
		pwp[rt] += dfs(e[i].v,pr + e[i].w);
	return pwp[rt];
}
int main (){
	scanf("%d%d",&n,&k);
	int al,be,cnt = 0;
	for (int i = 1;i <= n;++ i){
		scanf("%d%d%d",&w[i],&al,&be);
		e[++ cnt] = edge{i,be,head[al]};
		head[al] = cnt;
	}
	//read end
	//first set
	dfs(0,0);
	int sum_ = 0;
	for (int i = 1;i <= n;++ i)
		sum_ += w[i] * pre[i];
	memset(memf,-1,sizeof(memf));
	memset(memd,-1,sizeof(memd));
	//main code
	cout << sum_ - f(0,0,k);
    return 0;
}
int f(int rt,int fa,int kk){
//the value produced by a subtree'rt',the last sawmill 'fa',the rest sawmill I can build
	if(memf[rt][fa][kk] != -1) return memf[rt][fa][kk];
	if(!kk) return memf[rt][fa][kk] = 0;
	return  memf[rt][fa][kk] =  max(d(head[rt],fa,kk),
		d(head[rt],rt,kk - 1) + pwp[rt] * (pre[rt] - pre[fa]));
}
int d(int l,int fa,int kk){
//the value produced by a list begin with 'l','fa'and'kk'are the same as the function 'f'
	if ((!l)||(!kk)) return memd[l][fa][kk] = 0;
	if(memd[l][fa][kk] != -1) return memd[l][fa][kk];
	int ans = 0;
	for (int i = 0;i <= kk;++ i)
		ans = max(ans,f(e[l].v,fa,i) + d(e[l].nxt,fa,kk - i));
	return memd[l][fa][kk] = ans;
}
```

---

## 作者：封禁用户 (赞：4)

题目大意可以这样理解：每个节点有一个带有权值的点，这个点可以就地消掉，也可以通过带有权值的边送到它的父亲节点，要求所有点都消掉的最小代价。


首先需要了解的知识点就是多叉树转二叉数，也就是左儿子右兄弟。然后就可以从后往前dp。至于实现从后往前的方法，可以递归实现，也可以实现预处理一下，搜一遍将转换后的二叉树，让每个节点的儿子和兄弟在新序列的后面。两种方法皆可。


至于状态转移方程，用 f[i][j][k] 表示目前考虑第 i 个点， j 表示 i 所有的祖先中离 i 最近并且建了伐木场的节点， i 的儿子以及 i 的兄弟一共建了 k 个伐木场。那么对于 i 这个点就有两种选择：1、不在这个节点建造伐木场。2、在这个节点建。

转移如下：

（在）f[i][j][k]=min(f[i][j][k],f[leftson][i][l]+f[rightson][j][k-l-1])

（不在）f[i][j][k]=min(f[i][j][k],f[leftson][j][l]+f[rightson][j][k-l]+val[i]\*(dis i..j))


这里解释一下：


在这个节点建伐木场时， i 的儿子们就可以直接送到 i 节点，因此左儿子为 f[leftson][i][l] ；但 i 的兄弟们无法到达 i ，所以它们依然需要送到 j （离 i 最近并且建了伐木场的节点），因此右儿子为 f[rightson][j][k-l-1] 。另外，由于 i 建造用去一个伐木场，所以方程中的第三维需减一。


不在这里建时，左右儿子都需送到 j ，但还要加上 i 点权 \* i..j 的距离。这个很好理解，但是此处不需要处理 i..j 节点中的节点的点权，因为此处只考虑 i 点， i..j 的节点以后可以推出。


代码：

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
struct node{
    int left,right,num,dis;
}gg[105];
int dui[105],deep[105],child[105],f[105][105][51],tot,fa[105];
const int INF=0x7f7f7f7f;
void dfs(int k,int dep)//生成从后往前推的序列
{
    dui[++tot]=k;
    deep[k]=dep+gg[k].dis;
    int i=gg[k].left;
    while(i)
    {
        dfs(i,deep[k]);
        i=gg[i].right;
    }
}
int main()
{
    int n,K;
    cin>>n>>K;
    memset(fa,-1,sizeof fa);
    for(int i=1;i<=n;i++)
    {
        int a,b,c;
        cin>>a>>b>>c;
        if(!child[b])
            gg[b].left=i;
        else
            gg[child[b]].right=i;
        child[b]=i;
        gg[i].num=a;
        gg[i].dis=c;
        fa[i]=b;
    }//多叉转二叉 
    dfs(0,0);
    memset(f,INF,sizeof f);//需要赋初值
    memset(f[0],0,sizeof f[0]);//
    for(int i=n+1;i>=2;i--)
    {
        int now=dui[i];
        int le=gg[now].left;
        int ri=gg[now].right;
        for(int j=fa[now];j!=-1;j=fa[j])//枚举父亲节点 
            for(int k=0;k<=K;k++)
            {
                for(int l=0;l<=k;l++)//不选 i
                    if(f[le][j][l]!=INF&&f[ri][j][k-l]!=INF)
                    {
                        int add=gg[now].num*(deep[now]-deep[j]);
                        int op=f[le][j][l]+f[ri][j][k-l]+add;
                        f[now][j][k]=min(f[now][j][k],op);
                    }
                for(int l=0;l<k;l++)//选 i
                    if(f[le][now][l]!=INF&&f[ri][j][k-l-1]!=INF)
                    {
                        int op=f[le][now][l]+f[ri][j][k-l-1];
                        f[now][j][k]=min(op,f[now][j][k]);
                    }
            }
    }
    printf("%d",f[gg[0].left][0][K]);
}
```

---

## 作者：BigSmall_En (赞：3)

### [LG3354](https://www.luogu.com.cn/problem/P3354) [IOI2005]Riv 河流

> 给定一颗点的编号为 $0\sim n$ 并以 $0$ 为根的有根树，每个点有权值 $w_i$ 和它父亲到它的距离 $d_i$。$0$ 号点初始为关键点，现在 $1\sim n$ 中选择 $k$ 个点作为关键点，定义这棵树的花费为每个点的权值乘上到其为关键点的**祖先**的距离的和，如果这个点本身为关键点则距离为 $0$。现在询问你这个花费的最小值。
>
> $n\leq 100,k\leq \min(n,50)$。

正解是树形 DP，而且这个 DP 对我来说并不好想。注意到这题的 $n$ 比较小（主要是因为这是道老题了），并且是最优化问题，于是可以想到模拟退火。

假如我们确定了这 $k$ 个点，我们可以使用一个非常朴素的遍历来求出此种情况的花费。

```cpp
void dfs(int u,int s){
	if(isk[u])s=0;//假如是关键点
	now+=w[u]*s;
	for(int i=head[u];i;i=edge[i].next)
		dfs(edge[i].to,s+edge[i].weight);
}
```

然后将这 $n$ 个点分成前 $k$ 个和后 $n-k$ 个，每次尝试交换两个集合中的两个元素，并以前 $k$ 个点为关键点计算此时答案。如果此时答案比当前最优解更优，则直接替换最优解；否则判断根据当前温度判断是否交换。

```cpp
inline void SA(){
	for(double T=1000;T>=1e-9;T*=0.999){
		random_shuffle(a+1,a+1+k);
		random_shuffle(a+1+k,a+1+n);
		swap(a[k],a[k+1]);
		solve();
		int der=now-ans;
		if(der<0)ans=now;
		else if(exp(-der/T)*100000<=dist(gen))swap(a[k],a[k+1]);
	}
}
```

#### 优化

然而这样就足够了吗？你会发现你会

![](https://cdn.luogu.com.cn/upload/image_hosting/9utt411l.png)

并且我调参调了一个半小时仍未取得进步。

我们显然希望关键点尽量分散。如果是 $n=100,k=50$ 这种情况，在数据基本随机的情况下，将关键点之间间隔摆放会更加优秀。换句话说，就是可以让初始两个集合中的点的分布情况尽可能靠近最优解。

于是我们按照点的深度进行摆放，距离 $0$ 号点为偶数的点放置在左侧，奇数的点放置在右侧。然后取左侧 $k$ 个点作为关键点进行模拟退火。

最后配合种子 $1919810$ 即可通过此题。

最后奉上丑陋的代码。

```cpp
mt19937 gen(1919810);
uniform_int_distribution<>dist(1,100000);
const int N=102,INF=0x7fffffff;
struct chainstar{
	int next,to,weight;
}edge[N<<1];int head[N],cnt;
inline void addline(int u,int v,int w){
	edge[++cnt].to=v;
	edge[cnt].next=head[u];
	head[u]=cnt;
	edge[cnt].weight=w;
}
int a[N],n,k,w[N],ans=INF,now,p1,p2;
bool isk[N];
void dfs(int u,int s){
	if(isk[u])s=0;
	now+=w[u]*s;
	for(int i=head[u];i;i=edge[i].next)
		dfs(edge[i].to,s+edge[i].weight);
}
inline void solve(){
	now=0;
	for(int i=1;i<=k;++i)isk[a[i]]=1;
	for(int i=k+1;i<=n;++i)isk[a[i]]=0;
	dfs(0,0);
}
inline void SA(){
	for(double T=1000;T>=1e-9;T*=0.999){
		random_shuffle(a+1,a+1+k);
		random_shuffle(a+1+k,a+1+n);
		swap(a[k],a[k+1]);
		solve();
		int der=now-ans;
		if(der<0)ans=now;
		else if(exp(-der/T)*100000<=dist(gen))swap(a[k],a[k+1]);
	}
}
void getlis(int u,int d){
	if(u!=0){
		if(d&1)a[++p1]=u;
		else a[p2--]=u;
	}
	for(int i=head[u];i;i=edge[i].next)
		getlis(edge[i].to,d+1);
}
int main(){
//	freopen("data.in","r",stdin);
//	freopen("mine.out","w",stdout);
	srand(1919810);
	p2=n=read(),k=read();
	for(int i=1;i<=n;++i){
		w[i]=read();
		int f=read(),d=read();
		addline(f,i,d);
	}
	getlis(0,1);
	while((double)clock()/CLOCKS_PER_SEC<=0.90)SA();
	printf("%d\n",ans);
	return 0;
}
```



---


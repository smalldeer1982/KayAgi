# SAC#1 - 萌数

## 题目背景

本题由世界上最蒟蒻的 SOL 提供。

寂月城网站是完美信息教室的官网。地址：<http://191.101.11.174/mgzd>。


## 题目描述

蒟蒻 SOL 居然觉得数很萌！

好在在他眼里，并不是所有数都是萌的。只有满足“存在长度至少为 $2$ 的回文子串”的数是萌的——也就是说，$101$ 是萌的，因为 $101$ 本身就是一个回文数；$110$ 是萌的，因为包含回文子串 $11$；但是 $102$ 不是萌的，$1201$ 也不是萌的。

现在 SOL 想知道从 $l$ 到 $r$ 的所有整数中有多少个萌数。

由于答案可能很大，所以只需要输出答案对 $1000000007$（$10^9+7$）的余数。

## 说明/提示

记 $n$ 为 $r$ 在 $10$ 进制下的位数。

对于 $10\%$ 的数据，$n \le 3$。

对于 $30\%$ 的数据，$n \le 6$。

对于 $60\%$ 的数据，$n \le 9$。

对于全部的数据，$n \le 1000$，$l < r$。


------------

2024/2/4 添加一组 hack 数据。

## 样例 #1

### 输入

```
1 100```

### 输出

```
10```

## 样例 #2

### 输入

```
100 1000```

### 输出

```
253```

# 题解

## 作者：day_dream (赞：31)

水题，记忆化搜索：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std; 
long long a[1001],dp[1001][10][2];
string s1,s2;
int k,l;
int dfs(int pos,int pre,int per,int t,int k,bool flag)
{
    if(pos<=0) return t;//若符合，返回1，否则返回0.
    if(!flag&&dp[pos][pre][t]!=-1) return dp[pos][pre][t];//已经遍历过，直接返回.
    int end=flag? a[pos]:9;//当前位置是否受限.
    int ret=0;
    for(int i=0;i<=end;i++) ret=(ret+dfs(pos-1,i,k? pre:-1,t||((i==pre)&&k)||((i==per)&&k),k||(i!=0),flag&&(end==i))%1000000007)%1000000007;//搜索下一位,奇数位回文串和偶数位回文串要分开判断
    if(!flag&&k&&per!=-1) dp[pos][pre][t]=ret;//记录.
    return ret;
}
int solve(string str)
{
    int len=0,slen=str.size()-1;
    while(slen>=0) a[++len]=str[slen]-'0',slen--;
    while(!a[len]) len--;
    memset(dp,-1,sizeof(dp));
    return dfs(len,-1,-1,0,0,1);
}
int main()
{
    cin>>s1>>s2;k=1;l=s1.size();
    while(s1[l-k]=='0'&&l>k) s1[l-k]='9',k++;
    s1[l-k]-=1;
    printf("%d\n",(solve(s2)-solve(s1)+1000000007)%1000000007);
    return 0;
}
```

---

## 作者：George1123 (赞：22)

# 题解-萌数
### $\texttt{Introduction}$
夫蒟蒻初学数位 $\texttt{dp}$，寻水题而得《萌数》，乃谔谔做之。初适，做之悠然。而样例不过，渐生焦躁，AC时已过三，而错之甚奇，乃记之。

**[博客中此文](https://blog.csdn.net/KonnyWen/article/details/104500985)**

---
### $\texttt{Description}$
> [萌数](https://www.luogu.com.cn/problem/P3413)
> 求区间 $[L,R]$ 中有长度大于 $2$ 的回文子串的数量。
> 数据范围：$1\le L<R\le 10^{1000}$。

---
### $\texttt{Solution}$
数位 $\texttt{dp}$ 典型题，如果你没学过数位 $\texttt{dp}$ 就跳进传送门→[\[传送门\]](https://blog.csdn.net/KonnyWen/article/details/104475276)。用记忆化搜索模型，用 $\texttt{DP(n)}$ 表示 $[1,n]$ 区间中的答案，$p$ 表示 $n$ 的位数，$nl_i$ 表示 $n$ 从右往左第 $i$ 位。 

$$\texttt{Dfs(int~w,int~d,int~ld,bool~free,bool~hw)}$$

表示：

> 当前要求从右往左第 $w$ 位数。
> 
> 第 $w+1$ 位数为 $d$。
>  
>  第 $w+2$ 位数为 $ld$。
>  
>  如果前 $p-w$ 位和 $n$ 相同，$free=0$；否则 $free=1$。
>  
>  如果前 $p-w$ 位中已经出现了“长度大于 $2$ 的回文子串”，$fw=1$；否则 $fw=0$。
> 
> $\texttt{Dfs}$ 的值表示数的数量。

如果找到的第 $w$ 个数字 $i$ 满足 $i==d$ 或 $i==ld$，就说明有了长度至少为 $2$ 的回文子串。用 $f_{w,d,ld,hw}$ 数字记下答案，完成记忆化搜索。

**code**

```cpp
lng Dfs(int w,int d,int ld,bool free,bool hw){
	if(!w) return hw;
	if(free&&~f[w][d][ld][hw]) return f[w][d][ld][hw];
	int up=free?9:nl[w]; lng res=0;
	for(int i=0;i<=up;i++)
		(res+=Dfs(w-1,i,d,free||i<up,hw||i==d||i==ld))%=mod;
	/*
	下一位是w-1位，下一个数的上一个数是i，下一个数的上上个数是d。
	如果原来就free==1或者i与n的第w位不相同下一个free=1。
	如果原来就有了长度为2的回文子串或i,d形成回文子串或i,d,ld形成回文子串，下一个fw=1。
	*/
	if(free) f[w][d][ld][hw]=res;
	return res;
}
```

所以 

$$\texttt{DP(n)}=\sum\limits_{i=1}^{p-1}\sum_{j=1}^{9}\texttt{Dfs(i-1,j,10,1,0)}
+\sum_{j=1}^{nl_p-1}\texttt{Dfs(p-1,j,10,1,0)}
+\texttt{Dfs(p-1,}nl_p\texttt{,10,0,0)}$$

。为什么 $ld=10$ ？因为 $ld$ 还不存在，而且如果你赋值为 $0$，会影响 $\texttt{Dfs}$ 结果；如果你赋值为 $-1$，会在记忆化数组的下标上 $\texttt{RE}$。所以赋值为 $10$ 是较好选择，然后记忆化数组的下标范围就要开 $11$。蒟蒻因为这里赋值成 $-1$ 而 $\texttt{WA}$ 了两次。

**code**

```cpp
lng DP(char*n,lng a){
	int p=strlen(n+1); lng res=0;
	for(int i=1;i<=p;i++) nl[i]=n[p+1-i]-'0';
	nl[1]+=a;
	if(p==1&&nl[1]<=0) return 0;
	for(int i=1;nl[i]<0&&i<=p;i++)
		nl[i]+=10,nl[i+1]--;
	while(!nl[p]&&p>1) p--;
	// debug(p,nl);
	memset(f,-1,sizeof f);
	for(int i=1;i<=p-1;i++)
		for(int j=1;j<=9;j++)
			(res+=Dfs(i-1,j,10,1,0))%=mod;  
	for(int j=1;j<=nl[p];j++)
		(res+=Dfs(p-1,j,10,j<nl[p],0))%=mod;
	return res;
}
```
然后最后答案就是 $\texttt{DP(R)}-\texttt{DP(L-1)}$，因为 $L$ 和 $R$ 远爆 $\texttt{long long}$，所以用字符串输入或处理。

---
### $\texttt{Code}$

```cpp
#include <bits/stdc++.h>
using namespace std;

//&Start
#define lng long long

//&Debug
template<class T>
void debug(int x,T*arr){
	for(int i=1;i<=x;i++)
		cout<<arr[i]<<"\n "[i<x];
}

//&DP
const int W=1010,D=10;
const lng mod=1e9+7;
char L[W],R[W];
int nl[W];
lng f[W][D][D+1][2];
lng Dfs(int w,int d,int ld,bool free,bool hw){
	if(!w) return hw;
	if(free&&~f[w][d][ld][hw]) return f[w][d][ld][hw];
	int up=free?9:nl[w]; lng res=0;
	for(int i=0;i<=up;i++)
		(res+=Dfs(w-1,i,d,free||i<up,hw||i==d||i==ld))%=mod;
	if(free) f[w][d][ld][hw]=res;
	return res;
}
lng DP(char*n,lng a){
	int p=strlen(n+1); lng res=0;
	for(int i=1;i<=p;i++) nl[i]=n[p+1-i]-'0';
	nl[1]+=a;
	if(p==1&&nl[1]<=0) return 0;
	for(int i=1;nl[i]<0&&i<=p;i++)
		nl[i]+=10,nl[i+1]--;
	while(!nl[p]&&p>1) p--;
	// debug(p,nl);
	memset(f,-1,sizeof f);
	for(int i=1;i<=p-1;i++)
		for(int j=1;j<=9;j++)
			(res+=Dfs(i-1,j,10,1,0))%=mod;  
	for(int j=1;j<=nl[p];j++)
		(res+=Dfs(p-1,j,10,j<nl[p],0))%=mod;
	return res;
}

//&Main
int main(){
	scanf("%s %s",L+1,R+1);
	printf("%lld\n",(DP(R,0)-DP(L,-1)+mod)%mod);
	return 0;
}
```

**祝大家学习愉快！**


---

## 作者：巨型方块 (赞：17)

百度果然搜不到题解，最后我在google 里面找到了；

首先回文串嘛>2就好啦

所以我们只要判断2情况

aa或者aba;

所以我们f[i][j][k]

表示第i位为j

i-1位为k的所有萌；

那么显然对于重复很难判断；

所以我萌有2种方法，一是在开一维数组记录是否出现；

另外的方法就是吧f[i][j][k]记录的是当前状态的非萌；

那我就用了第二种；

那么这样的话只要特判i=1的情况，f数组可以方便的求了；

那么之后的话就是数位dp了；


```cpp
#include<bits/stdc++.h>
#define Ll long long
using namespace std;
const int N=1e3+5;
Ll f[N][10][10],mo=1e9+7,ans;
string l,r;
void dp(){
    for(int i=2;i<=1000;i++)
        for(int x=0;x<=9;x++)
            for(int y=0;y<=9;y++)if(x!=y){
                for(int z=0;z<=9;z++)
                    if(y!=z&&x!=z)
                        f[i][x][y]+=f[i-1][y][z];
                if(i-1==1)f[i][x][y]++;
                f[i][x][y]%=mo;
            }
}
Ll out(string s){
    int n=s.length(),X=-1,Y=-1;
    Ll tot=0,ans=0;bool ok=1;
    for(int i=0;i<n;i++)tot=(tot*10+s[i]-48)%mo;
    for(int i=1;i<n;i++)
        for(int x=1;x<=9;x++)
            for(int y=0;y<=9;y++)
                ans=(ans+f[i][x][y])%mo;
    if(n>1)ans+=10;//10的含义是0~9这10个数字 
    for(int i=n;i>1;i--){
        int v=s[n-i]-48;
        for(int j=0;j<v;j++)if(i!=n||j!=0)
            for(int k=0;k<=9;k++)
                if(X!=j&&Y!=j&&j!=k&&k!=X)
                    ans=(ans+f[i][j][k])%mo;
        if(v==X||v==Y){ok=0;break;}
        Y=X;X=v;
    }
    if(ok)for(int j=0;j<=s[n-1]-48;j++)
        if(j!=Y&&j!=X)ans=(ans+1)%mo;
    return(tot+1-ans+mo)%mo;//1的含义就是0这个数字 
}
int main()
{
    dp();
    cin>>l>>r;
    ans=(out(r)-out(l)+mo)%mo;
    for(int i=1;i<=l.length()-1;i++)
        if(l[i]==l[i-1]||(i>1&&l[i]==l[i-2])){
            ans=(ans+1)%mo;break;
        }
    printf("%lld",ans);
}
```

---

## 作者：Wminz (赞：11)

这是我入门数位dp的第二道题\
第一道是 P2657 [SCOI2009]windy数

数位dp，考的就是模板

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#define ll long long
#define MD 1000000007

using namespace std;

int s1[1005],s2[1005];
int st[1005];
ll f[1005][15][15][2][2][2];
//pos 最大有1000位所以开到1000+ 
string sx,sy;
int len;
// pre2 当前位置的第前两位 pre1 当前位置的第前一位
// lead 前导零 我设置的数是15（不影响本题）  
// pos 当前位置
// limit 最高为限制
// flag 如果flag为1 则当前这个数是萌的 否则它为0 
// len 记录当前字符串的长度 
ll dfs (int pre2,int pre1,int pos,int limit,int lead,int flag)
{
    if(pos>len) return flag;

    ll ret=0;

    if(f[pos][pre1][pre2][limit][lead][flag]!=-1) return f[pos][pre1][pre2][limit][lead][flag]%MD;

    int top=limit?st[pos]:9;
    
    for(int i=0;i<=top;i++)
    {
        //如果这个数是萌的 无需再判断了 
        if(flag&&pre1!=-2) ret=(ret%MD+dfs(pre1,(lead&&!i)?-2:i,pos+1,limit&&i==top,(lead&&!i)?1:0,1)%MD)%MD;
        else
        {
            //不知道这个数萌不萌 
            //关键：如果aa或aba那么就合法 
            if(pre1==i&&pre1!=-2||pre2==i&&pre2!=-2&&pre1!=-2)
                ret=(ret%MD+dfs(pre1,(lead&&!i)?-2:i,pos+1,limit&&i==top,(lead&&!i)?1:0,1)%MD)%MD;//1
            else
                ret=(ret%MD+dfs(pre1,(lead&&!i)?-2:i,pos+1,limit&&i==top,(lead&&!i)?1:0,0)%MD)%MD;//0 
        }
        //写法有很多种 我的代码比较啰嗦 
    }

    f[pos][pre1][pre2][limit][lead][flag]=(ret%MD);
    //记忆化搜索直接把所有状态存上 
    //这样存不容易出错 
    return ret%MD;
}

ll work (int le,int ok)
{
    memset(st,0,sizeof(st));
    memset(f,-1,sizeof(f));
    len=le;
    if(ok==1)
    {
        for(int i=1;i<=len;i++)
            st[i]=s2[i];
    }
    else
    {
        for(int i=1;i<=len;i++)
             st[i]=s1[i];
    }
    return dfs(-2,-2,1,1,1,0)%MD;
}

int main()
{
    // 一定要读入字符串（读入的数有一千位啊） 
    cin>>sx>>sy;
    int len1=sx.length();
    for(int i=0;i<len1;i++)
    {
        s1[i+1]=sx[i]-'0';
    }
    int len2=sy.length();
    for(int i=0;i<len2;i++)
    {
        s2[i+1]=sy[i]-'0';
    }
    s1[len1]--;
    ll ans1=work(len1,0);
    ll ans2=work(len2,1);
    printf("%lld",((ans2-ans1)%MD+MD)%MD);
    //这里一定要模不然会输出负数 
    return 0;
}
```



---

## 作者：L2_sheep (赞：8)

这题还可以用数学方法来做。直接求萌数很难，但是求非萌数比较简单，每一位都不和前两位相等就是非萌的。记f(n)是n位的非萌数的总数，可得f(1)=9, f(n)=9×9×8^(n-2)(n>=2)。
接下来，从最高位开始，通过乘法原理和加法原理，就可以求得结果，注意细节。
下面是代码：
```cpp
#include <stdio.h>
#include <string.h>
#define M 1000000007
#define N 1005
typedef long long LL;

char l[N], r[N];
LL p[N], f[N];

LL solve(char *a, int len)
{
	if(!len) return 0;
	LL sum = 0, tot = 0;
	int i, j, k;
	for(i = 1; i <= len; i++) sum += f[i];
	sum += p[len - 1] * 9 * (a[0] - 49);
	for(i = 1, j = len - 1; i < len; i++, j--){
		k = (a[i] - 1 >= a[i - 1]) + (i > 1 && a[i] - 1 >= a[i - 2]);
		sum += p[j] * (a[i] - 48 - k);
		if(a[i] == a[i - 1] || i > 1 && a[i] == a[i - 2]) break;
	}
	if(i == len) sum += a[i] - 47 - (a[i] >= a[i - 1]) - (i > 1 && a[i] >= a[i - 2]);
	sum %= M;
	for(i = 0; i <= len; i++){
		tot = (tot * 10 + a[i] - 48) % M;
	}
	return tot < sum ? tot - sum + M : tot - sum;
}

int judge(char *a)
{
	if(strlen(a) == 1) return 0;
	if(a[1] == a[0]) return 1;
	int i;
	for(i = 2; a[i]; i++){
		if(a[i] == a[i - 1] || a[i] == a[i - 2]) return 1;
	} 
	return 0;
}

int main() 
{
	int n, i, t, tt;
	LL ans;
	
	scanf("%s%s", l, r);
	t = strlen(r), tt = strlen(l);
	
	p[0] = 1;
	for(i = 1; i <= t; i++){
		p[i] = (p[i - 1] << 3) % M;
	}
	f[0] = 0, f[1] = 9, f[2] = 81;
	for(i = 3; i <= t; i++){
		f[i] = (f[i - 1] << 3) % M;
	}
	
	ans = solve(r, t - 1) - solve(l, tt - 1) + judge(l);
	if(ans < 0) ans += M;
	if(ans == M) ans = 0;
	printf("%lld\n", ans);
	
	return 0;
}
```

---

## 作者：AlanSP (赞：7)

看到题解里面递推的写法很少，蒟蒻来补一篇。
---
前面dalao们已经说了，采取正难则反的思想。

所以我们记录$f[i][j][k]$表示前i位，其中第i位为j，i-1位为k的**非萌数**个数。

注意到当判断一个数是否为非萌数，必须要知道它和前两位的相等关系，都要记录下来。

那么方程也比较显然了：
$$
f[i][j][k]+=\sum_{l!=k\And l!=j\And j!=k }f[i-1][k][l]
$$
这样我们就把非萌数的表刷出来了。

之后就普通的进行数位dp就可以了。

同时统计数字总数num。

**注意：答案中不能有前导零，所以要把1~n-1位的数字特判掉，统计时也要特判。**

之后有个小Trick：由于数字位数太大，我们无法直接差分dp(r)-dp(l-1)。

~~当然可以写一个简单的高精度减1。~~

我这里将l特判掉，更为简便。
---
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1009,mod=1e9+7;
#define out puts("Debug")
#define int long long
int f[N][19][19],ans;//f数组记录非萌数
char l[N],r[N];

void Init()
{
//	for(int i=0;i<=9;i++) f[1][0][i]=i;
//	for(int i=0;i<=9;i++)
//		for(int j=0;j<=9;j++)
//			if(i==j) f[2][i][j]=0;
//			else f[2][i][j]=1;
	for(int i=2;i<=1000;i++)
	{
		for(int j=0;j<=9;j++)
			for(int k=0;k<=9;k++)
				if(j!=k)
				{
					for(int l=0;l<=9;l++)	
						if(k!=l&&l!=j) f[i][j][k]+=f[i-1][k][l];
					if(i==2) f[i][j][k]++;
					f[i][j][k]%=mod;
//					cout<<i<<' '<<j<<' '<<k<<endl;
				}
	}
}

inline int dp(char s[])
{
	int len=strlen(s);
	if(len==1) return 0;

	bool flag=true;
	int res=0,last=-1,lst=-1,n=len,num=0;//last是上一位，lst是上两位
	int nums[N]={0};
	memset(nums,0,sizeof nums); 
	for(int i=n;i>=1;i--) nums[i]=s[n-i]-'0',num=(num*10+nums[i])%mod;
 	num++;
 	
 	res+=10;
	for(int i=2;i<n;i++)
		for(int j=1;j<=9;j++)//排除前导零的情况
			for(int k=0;k<=9;k++)
				res=(res+f[i][j][k])%mod; 

	for(int i=n;i>=2;i--)
	{
		int x=nums[i];
		for(int j=0;j<x;j++) if(!(i==n&&!j))//不能有前导零
			for(int k=0;k<=9;k++)
				if(last!=j&&lst!=j&&j!=k&&last!=k) res=(res+f[i][j][k])%mod;
		if(last==x||lst==x) 
		{
			flag=false;
			break;
		}
		lst=last,last=x;
	}
	if(flag)
		for(int i=0;i<=nums[1];i++)
			if(i!=lst&&i!=last) res=(res+1)%mod;
	return (num-res)%mod;
}

signed main()
{
	cin>>l>>r;
//	puts("Debug");
	Init();
	ans=(dp(r)-dp(l)+mod)%mod;
	int t=strlen(l);
	for(int i=1;i<t;i++)
		if(l[i]==l[i-1]||(l[i]==l[i-2]&&i>1))
		{
			ans++,ans%=mod;
			break;
		}
	printf("%lld",ans);
	return 0;
}

```
~~递推常数小，便于理解，写什么记搜啊qwq。~~

---

## 作者：Mosher (赞：4)

### 数位dp较模板变化的题吧，还是水(但：不能偷懒省变量，不然GG）

**正文：**

1. 难点：如何辨识回文串以及数据大（数据大，转字符串读入）：
	```cpp
	两种类型：
    1.奇数串：形如：1 0 1
    2.偶数串：形如：1 1
    
    由以上两种基本串，易想到：较长的回文串，必定包含较短回文子串
    所以："1 0 1"认为"2 1 0 1 2"，···的子串,"1 1"同理
    
    得出结论：若一个字符串存在回文子串，必然：pos==pos-1||pos==pos-2
	```
2. 数位dp基本点：前缀和
	```cpp
    那么就会涉及到：r-(l-1)；
    提供l-1的处理方式，如下：
    char l[1005];
    ll a=work(l,1)；
    
	ll work(char s[],ll op){
		ll len=strlen(s+1),tot=1;
		for(ll i=1;i<=len;++i) 
			num[len-i+1]=s[i]-'0';
		while(num[tot]-op<0){
			if(tot==len) break;
			num[tot]=9;
			tot++;
		}
		num[tot]-=op;
	}
    ```
3. 数位dp记忆化搜索变量：除基本变量，剩下的就是牵扯可能涉及到的，最好都加上

4. 注意搜索时：负变量，前导零封杀

5. 取余就不说啦，qwq

**Code:**
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll mod=1e9+7;
ll dp[1005][20][20][2],num[1005];
char l[1005],r[1005];

ll dfs(ll pos,bool limit,bool head,ll last1,ll last2,ll flag){
	ll ans=0;
	if(!pos) return flag;
	if(!limit&&!head&&last1!=-1&&last2!=-1&&dp[pos][last1][last2][flag]!=-1) return dp[pos][last1][last2][flag];
	ll up=limit ? num[pos] : 9;
	for(ll i=0;i<=up;++i)
		(ans+=dfs(pos-1,limit&&i==up,head&&!i,(head&&!i) ? -1:i,head==1 ? -1:last1,flag||(!head&&(i==last1))||(!head&&(i==last2)))%mod)%=mod;
	if(!limit&&!head&&last1!=-1&&last2!=-1) return dp[pos][last1][last2][flag]=ans;
	return ans;
}//建议以上，格式化代码后，一个个变量分解看（也许可读性太差）

ll work(char s[],ll op){
	ll len=strlen(s+1),tot=1;
	memset(dp,-1,sizeof(dp));
	for(ll i=1;i<=len;++i) 
		num[len-i+1]=s[i]-'0';
	while(num[tot]-op<0){
		if(tot==len) break;
		num[tot]=9;
		tot++;
	}
	num[tot]-=op;
	return dfs(len,1,1,-1,-1,0);
}

int main(){
	scanf("%s%s",l+1,r+1);
	ll a=work(l,1),b=work(r,0);
	printf("%lld",(b-a+mod)%mod);
}
```
**PS:代码的严谨性和准确性很重要**

rp++

---

## 作者：ChenJr (赞：4)

因为所要求的区间相当的大，因此我们不妨从它的数位入手进行$dp$。

根据萌数的性质，倘若要满足一个长度为$len$的字符串是萌数，那么这个串只需至少包含一个长度为$2$（对应偶回文），或者至少包含一个长度为$3$（对应奇回文）的回文串即可。至此，我们将题目进行了转化，即：如果一个串包含有一个长度为$2$或者长度为$3$的字符串，那么这个数就是萌数。

因此我们只需要讨论一个串的当前位$pos$，它的前一位$pre1$，以及它的前两位$pre2$即可。因此我们可以设计一个$dp[pos][pre1][pre2]$的$dp$数组。但是我们发现，如果这样去设计状态的话，部分合法以及非法状态会发生重叠：如果当前的枚举到的状态是$dp[1][2][3]$的状态（即代表枚举到的子串的状态位$123$）。此时的这个状态中，合法状态$33123$以及非法状态$45123$将会发生重叠。因此为了防止这种情况，我们考虑再开多一维判断是否在之前是否已经合法子串。故我们可以设计$dp[pos][pre1][pre2][exist]$代表，当前位置位$pos$，前一位为$pre1$，前两位为$pre2$，且之前存在/不存在子串的方案数。

而我们发现，当设计了$exist$这个状态之后，我们就不需要记录前两位$pre2$的信息了，因此我们只需要开一个三维的$dp$数组$dp[pos][pre1][exist]$即可。

而把状态设计好之后，我们就只需要直接套用记忆化搜索的数位dp的板子就可以很简单的解决了。

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 1005
using namespace std;
typedef long long ll;
ll dp[maxn][15][2];
char L[maxn],R[maxn];
int bit[maxn],len;
const int mod=1e9+7;
ll dfs(int pos,int pre1,int pre2,int exist,int lead,int limit){
    if(pos==0) return exist;
    if(pre1!=-1&&pre2!=-1&&!lead&&!limit&&dp[pos][pre1][exist]!=-1)
        return dp[pos][pre1][exist];
    int up=limit?bit[pos]:9;
    ll res=0;
    for(int i=0;i<=up;i++){
        int p=(lead&&i==0)?-1:i;
        res+=dfs(pos-1,p,pre1,exist|(p!=-1 && (p==pre1||p==pre2)),p==-1,limit&&(p==up));
        res%=mod;
    }
    if(pre1!=-1&&pre2!=-1&&!lead&&!limit) dp[pos][pre1][exist]=res;
    return res;
}
ll solve(char *str,bool sub){
    len=strlen(str);
    for(int i=1;i<=len;i++)
        bit[len-i+1]=str[i-1]-'0';
    if(sub){
        int now=1;
        while(bit[now]==0) bit[now++]=9;
        bit[now]--;
        while(!bit[len] && len) len--;
    }
    memset(dp,-1,sizeof(dp));
    return dfs(len,-1,-1,0,1,1);
}
int main()
{
    scanf("%s%s",L,R);
    printf("%lld",((solve(R,0)-solve(L,1))%mod+mod)%mod);
    return 0;
}
```

---

## 作者：Unordered_OIer (赞：3)

# P3413 题解
数位$dp$裸题啊
## 题意
求$[l,r]$内的萌数有多少个。
## 解答
虽然是裸的数位$dp$，但我还是要来讲一下暴力。

暴力做法很简单，就是$[l,r]$之间枚举一下，枚举到一个萌的数就$+1$就行了。  
放一个伪代码吧
```cpp
for i=l to r
	if meng(i) cnt++
cout<<cnt
```
~~暴力讲完了~~真的讲完了

接下来就是**数位**$dp$
## 数位$dp$
这是个什么呢？读它的字面意思就知道了，数位$dp$就是通过枚举数位的某些特性解决问题。通常，数位$dp$的复杂度是$\Theta(\log_{10}n)$的，所以其实数位$dp$只要写对，几乎没法卡。  

那么我们从最简单的一道例题开始：统计$[l,r]$区间内出现了多少个**包含$1$的数**。

这当然可以用小奥方法做，在此不赘述了。  
我们从预计算讲起  
设$f_i=1$到$i$位数中包含$1$的数的个数。  
设$f_{ij}=1$到$i$位数，**首位为**$j$的数中包含$1$的数的个数。

转移方程：
$$f_i=9 \times f_{i-1}+10^{i-1}$$
$$f_{ij}=\begin{cases}10^{i-1}&\text{have1}\\\sum\limits_{k=1}^9f_{ik}&\text{else}\end{cases}$$  
然后根据这个**从高位到低位枚举首位并统计**就能解决这个例题了。这个过程我们可以采用**记忆化搜索**。  
参考伪代码：
```cpp
ll dfs(ll pos,bool flag){//pos:当前这一位,flag:pos之前的位中是否有1
	已经遍历完所有的数位,直接返回这个数是否有1
	答案初始化为0
	枚举首位i
	如果更高位没有1,那么可以放心的加
	如果有1,那么所有的这些情况都包含1,直接加上10的pos次方
	当前答案+(pos-1位数,比pos-1高的位数中有没有1)的答案
}
```

***
###### $\tiny{\color{grey}华丽的分割线}$

好了我们回归原题。  
根据我们数位$dp$的经验，我们肯定是要枚举数位的，那么这样一来就有一个问题：例如判断一个```12345678987654321```是否回文，我们难道要记录那么长一个状态吗！？
![](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=159178527,2126930547&fm=26&gp=0.jpg)  
~~你看众多巨佬的题解代码哪个有那么长~~  
那么，我们发现```12345678987654321```其实核心在于有一个**回文子串**```898```，所以只要```898```回文，它就回文了。  
所以**任意回文串一定有长度为$2$或$3$的回文子串**（证明也太简单了）  

因此我们只要考虑两个数的情况：
1. 相邻(xx)
2. 隔一个数(xnx)

你以为这样就结束了？$\texttt{\Huge{\color{red}No}}$！  
发现对于一个```000123```具有前导$0$回文的数，如果只用前面的算法，这个数也会被判断为萌数，而实际上他并不是，所以我们还需要**判断前导**$0$。

那么我们可以快乐的写$dfs$了：
```cpp
ll dfs(ll l, ll pp, ll pp2, bool zr1, bool zr2, bool lmt)
{
	edge(l, pp, pp2, zr1, zr2, lmt);//一些情况的特殊处理
	ll sum=0;
	if (lmt)
	{//有限制
		for(ll i=0; i<=s[l]; i++)
			if((zr1 || i!=pp) && (zr2 || i!=pp2))
				sum+=dfs(l+1, i, pp, zr1 && (i==0), zr1, lmt && i==s[l]);
		f[l][pp][pp2][zr1][zr2][lmt]=sum;
		return sum;
	}
	else
	{//无限制
		for(ll i=0; i<=9; i++)
			if((zr1 || i!=pp) && (zr2 || i!=pp2))
				sum+=dfs(l+1, i, pp, zr1 && (i==0), zr1, 0);
		f[l][pp][pp2][zr1][zr2][lmt]=sum;
		return sum;
	}
}
```
那个啥关于$r<=10^{1000}$的你用字符串处理一下不就行了吗。

完结撒花~同时求赞$qwq$

---

## 作者：Aleph1022 (赞：3)

首先，显然在一个回文串首尾各添加一个相同字符，结果仍是回文串。  
所以这题需要判断的就只有两种子串 $\overline{aa},\overline{aba}$。  
其他情况都能转化成这俩。

然后就是数位 DP。  
我的状态也很复杂啊……  
记搜的话，记录位数、上一位、上上位、前面是否满足萌数的要求、上一位是否为前导零、上上位是否为前导零、是否贴着边界。

令 $l - 1$ 的过程有点麻烦，可以按照高精的套路写。  
不过直接跑 $r - l$ 然后特判 $l$ 貌似也行。

代码：
```cpp
#include <cstdio>
#include <cstring>
using namespace std;
const int LEN = 1e3;
const long long mod = 1e9 + 7;
char l[LEN + 5],r[LEN + 5];
int d[LEN + 5],tot;
long long f[LEN + 5][10][10][2][2][2];
long long ans;
long long dfs(int x,int num,int pre,int lovely,int lead,int prelead,int top)
{
	if(!x)
		return lovely;
	if(!top && ~f[x][num][pre][lovely][lead][prelead])
		return f[x][num][pre][lovely][lead][prelead];
	int bound = top ? d[x] : 9;
	long long ret = 0;
	for(register int i = 0;i <= bound;++i)
		ret = (ret + dfs(x - 1,i,num,lovely || (!lead && i == num) || (!prelead && i == pre),lead && !i,lead,top && i == bound)) % mod;
	if(!top)
		f[x][num][pre][lovely][lead][prelead] = ret;
	return ret;
}
int main()
{
	memset(f,-1,sizeof f);
	scanf("%s %s",l,r);
	for(register int i = strlen(r) - 1;~i;--i)
		d[++tot] = r[i] ^ '0';
	ans = dfs(tot,0,0,0,1,1,1);
	tot = 0;
	for(register int i = strlen(l) - 1;~i;--i)
		d[++tot] = l[i] ^ '0';
	--d[1];
	for(register int i = 1;i <= tot;++i)
		if(d[i] < 0)
			d[i] += 10,--d[i + 1];
	ans -= dfs(tot,0,0,0,1,1,1);
	printf("%lld\n",(ans + mod) % mod);
}
```

---

## 作者：kkxhh (赞：1)

显然我们只需要考虑长度为 $2$ 或 $3$ 的回文串

于是我们设状态为 $d(pos,llas,las,lim,lead)$

其中 $pos$ 表示还剩下几位，$llas$ 表示前两位的数，$las$ 表示前一位的数，$lim$ 表示是否受限制，$lead$ 表示是否有前导 $0$（$llas=-1$ 和 $las=-1$ 表示不存在这个位置，$lim=1$ 和 $lead=1$ 表示受限和有前导 $0$）

在转移的时候如果当前的位置和 $llas$ 或 $las$ 相等就不需要再考虑后面的位置了，这样对答案的贡献为 $10^{pos-1}$，但如果 $lim=1$ 且 $i=num_{pos}$ 则后面不能取遍所有数字，所以贡献为 $suc_{pos-1}+1$（$suc_{i}$ 表示从 $1$ 到 $i$ 位的后缀）

剩下就是一个记忆化搜索了，具体细节看代码吧

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
#define LL long long

const LL mod=1000000007,maxsize=1000;
LL len,num[1010],d[15][15][1010],vis[15][15][1010],ans,pw[1010],suc[1010];
char s[1010];

inline LL read(){
    LL num=0,k=1; char c=getchar();
    while(c>'9' || c<'0') k=(c=='-')?0:k,c=getchar();
    while(c>='0' && c<='9') num=num*10+c-'0',c=getchar();
    return k?num:-num;
}

LL dp(LL pos,LL llas,LL las,LL lim,LL lead){
    if(!pos) return 0;
    if(pos==1) return (las!=-1 && (!lim || num[1]>=las))+(llas!=-1 && (!lim || num[1]>=llas));
    if(llas>=0 && las>=0 && !lim && !lead && vis[llas][las][pos] ) return d[llas][las][pos];
    LL cur=0;
    for(LL i=0;i<=(lim?num[pos]:9);i++){
        if(!lead && (i==las || i==llas)) cur=(cur+((lim && i==num[pos])?suc[pos-1]+1:pw[pos-1]))%mod;
        else cur=(cur+dp(pos-1,las,((lead && !i)?-1:i),(lim && i==num[pos]),(lead && !i)))%mod;
    }
    if(!lim && !lead && llas>=0 && las>=0) d[llas][las][pos]=cur,vis[llas][las][pos]=1;
    return cur;
}

int main(){
    pw[0]=1;
    for(LL i=1;i<=maxsize;i++) pw[i]=pw[i-1]*10%mod;
    scanf("%s",s+1); len=strlen(s+1);
    for(LL i=len;i>=1;i--) num[i]=s[len-i+1]-'0';
    for(LL i=1;i<=len;i++) if(num[i]) {num[i]--; break;} else num[i]=9;
    if(!num[len]) len--;
    for(LL i=1;i<=len;i++) suc[i]=(suc[i-1]+num[i]*pw[i-1])%mod;
    ans-=dp(len,-1,-1,1,1);
    scanf("%s",s+1); len=strlen(s+1);
    for(LL i=len;i>=1;i--) num[i]=s[len-i+1]-'0';
    for(LL i=1;i<=len;i++) suc[i]=(suc[i-1]+num[i]*pw[i-1])%mod;
    ans+=dp(len,-1,-1,1,1);
    printf("%lld",(ans%mod+mod)%mod);
    return 0;
}

```

---

## 作者：Nero_Claudius (赞：1)

这道题刚开始正向思维，然后处理重复的时候咕咕了。

参考了@巨型方块 大佬的题解后AC了，在这里就说几个我觉得比较重要或是容易被忽略的点，然后补充一些跳过的证明。

------------

这道题的状态可以设为$dp[i][j][k]$，意思是长度为$i$，然后第$i$位为$j$，第$i-1$位为$k$的不是萌数的数量。

那么为什么我们只需要枚举两位呢？

这是因为所有的回文数都必定可以简化为$aa$和$aba$中的一种，证明如下：


I. 对于长度小于等于3的回文数，显然即为以上两种中的一种。（一位数忽略）

II. 对于长度大于3的回文数，讨论其奇偶性。
    i. 对于长度为奇数的回文数，必定可以表示为形如$a_1a_2...a_nba_n...a_2a_1$的形式，由于包含$a_nba_n$即为$aba$形式，所以可以简化。
    ii. 对于长度为偶数的回文数，必定可以表示为形如$a_1a_2...a_na_n...a_2a_1$的形式，同上可以简化。
    
状态转移比较水，没有什么需要特别注意的事项。

还有一点是本题需要开long long，最开始我看到膜1e9+7就只用了int，于是爆60。

---

## 作者：GKxx (赞：1)

我也不知道怎么就推了这么大的一个状态。。。

f[i][j][k][h][c][d][e]表示填到第i位，第i位填的是j，第i-1位填的是k，h表示到目前为止有没有过一个长度至少是2的回文串，c表示卡没卡上界，d表示当前位是否可用（即当前位不是前导0，可以作为回文串的一部分），e表示上一位是否可用

那么我们枚举下一位填的数x，就可以转移到

f[i+1][x][j][h || (d && x == j) || (e && x == k)][c && x == bit[i + 1]][d || x != 0][d]

也就是说在判断回文的时候要考虑一下这一位数字和上一位数字是否可用

这样的话其实代码还是非常好写的。

```cpp
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>
#include <cstring>

#ifdef WIN32
#define LLIO "%I64d"
#else
#define LLIO "%lld"
#endif	// WIN32 long long
#define rep(I, A, B) for (int I = (A); I <= (B); ++I)
#define rrep(I, A, B) for (int I = (A); I >= (B); --I)
#define erep(I, X) for (int I = head[X]; I; I = next[I])

const int maxn = 1207;
const int mod = 1e9 + 7;
long long f[maxn][10][10][2][2][2][2];
int a[maxn], b[maxn];

inline long long solve(int *bit, int n) {
    rep(i, 1, n) rep(j, 0, 9) rep(k, 0, 9) rep(h, 0, 1) rep(c, 0, 1) rep(d, 0, 1) rep(e, 0, 1) f[i][j][k][h][c][d][e] = 0;
    rep(i, 0, bit[1]) f[1][i][0][0][i == bit[1]][i != 0][0] = 1;
    rep(i, 1, n - 1) rep(j, 0, 9) rep(k, 0, 9) rep(h, 0, 1) rep(c, 0, 1) rep(d, 0, 1) rep(e, 0, 1) {
        long long res = f[i][j][k][h][c][d][e];
        if (!res) continue;
        rep(x, 0, (c ? bit[i + 1] : 9))
            (f[i + 1][x][j][h || (d && x == j) || (e && x == k)][c && x == bit[i + 1]][d || x != 0][d] += res) %= mod;
    }
    long long ans = 0;
    rep(i, 0, 9) rep(j, 0, 9) rep(c, 0, 1)
        ans = (ans + f[n][i][j][1][c][1][1]) % mod;
    return ans;
}

int main() {
    char s[maxn] = {0};
    scanf("%s", s + 1);
    int len1 = strlen(s + 1);
    rep(i, 1, len1) a[i] = s[i] - 48;
    std::reverse(a + 1, a + len1 + 1);
    --a[1];
    rep(i, 1, len1 - 1) {
        if (a[i] < 0) {
            a[i] += 10;
            --a[i + 1];
        } else break;
    }
    if (!a[len1]) --len1;
    if (!len1) len1 = 1;
    std::reverse(a + 1, a + len1 + 1);
    scanf("%s", s + 1);
    int len2 = strlen(s + 1);
    rep(i, 1, len2) b[i] = s[i] - 48;
    printf(LLIO "\n", ((solve(b, len2) - solve(a, len1)) % mod + mod) % mod);
    return 0;
}
```

---

## 作者：ZORO (赞：0)


# $Description$

[题面](https://www.luogu.org/problem/P3413)

求$[l,r]$有多少个数满足数位中出现长度$>=2$的回文数，比如$121、110$都满足
$l,r<=10^{1000}$

# $Solution$

第一次看到这么大范围的数位$DP$，昨天学了记忆化写法之后今天用起来就是方便，~~真香啊~~

话说一开始以为会$TLE$，但是发现记忆化搜索数组的每一个空间只会访问一次，所以复杂度和递推$dp$是一样的。

记录状态需要记录上一位和上上位(因为可能出现长度为奇数的回文串如$121$，一开始我忘记考虑这种情况了)，只要满足这一位和上一位相等，或者和上上位相等，那么这个数字就是一定满足的。

剩下的比较简单：

输入的时候存两个数组里，写两个函数照样求即可，别忘了减一，还有注意前导零问题。

几个坑点（我都犯过）

$1.\ work1,work2,dfs1,dfs2$函数别写串了，这个还是比较好调出来的。

$2.dp$数组每次都初始化为$-1$(这个我没范)

$3.$处理前导零的时候当前位置和上一位都被代入了，但一开始上上位需要赋一个
$!\in[0,9]$的数,我赋成$-1$忘记特判导致$dp$数组越界返回了错误答案，所以尽量赋成$10$吧

更多细节见代码

# $Code$
```
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#define ll long long
#define re register
#define maxn 1010
using namespace std;
const ll mod=1e9+7; 
inline int read()
{
	int x=0,f=1; char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
char AA[maxn],BB[maxn];
int A[maxn],B[maxn],lena,lenb;
ll dp[1010][10][2][2][11],ans1,ans2,ans;
ll dfs1(int p,int a,int b,int c,int d)
{
	//a表示上一位，b表示是否小于边界,c表示 是否构成回文串
	if(p<=0) return c;
	if(~dp[p][a][b][c][d]) return dp[p][a][b][c][d]%mod;
	int lim=b?9:A[p];
	ll res=0;
	for(int i=0;i<=lim;++i)
	 res=(res+dfs1(p-1,i,(i<lim)||b,(i==a)||c||(i==d),a))%mod;
	return dp[p][a][b][c][d]=res;
}
ll dfs2(int p,int a,int b,int c,int d)
{
	//a表示上一位，b表示是否小于边界,c表示 是否构成回文串，d表示上上位 
	if(p<=0) return c;//如果d=-1，会访问-1下标，容易混乱越界返回错误值 
	if(~dp[p][a][b][c][d]) return dp[p][a][b][c][d]%mod;
	int lim=b?9:B[p];
	ll res=0;	
	for(int i=0;i<=lim;++i)
	 res=(res+dfs2(p-1,i,(i<lim)||b,(i==a)||c||(i==d),a))%mod;
	return dp[p][a][b][c][d]=res;//回溯别忘记赋值 
}
void work1()//处理较小的数 
{
	memset(dp,-1,sizeof(dp));//每次都重新赋值-1
	for(re int i=1;i<=lena-1;++i)
	 for(re int j=1;j<=9;++j)//处理位数小的情况，这些位置从[1,9]取 
	  ans1=(ans1+dfs1(i-1,j,1,0,10))%mod;
	for(re int i=1;i<=A[lena];++i)
	 ans1=(ans1+dfs1(lena-1,i,i<A[lena],0,10))%mod;
}

void work2()//处理较大的数，注意这些函数别写混了 
{
	memset(dp,-1,sizeof(dp));
	for(re int i=1;i<=lenb-1;++i)
	 for(re int j=1;j<=9;++j)
	  ans2=(ans2+dfs2(i-1,j,1,0,10))%mod;
	for(re int i=1;i<=B[lenb];++i)
	 ans2=(ans2+dfs2(lenb-1,i,i<B[lenb],0,10))%mod;
}
int main()
{
    cin>>AA+1>>BB+1;
    lena=strlen(AA+1),lenb=strlen(BB+1);
    for(re int i=1;i<=lena;++i) A[i]=AA[lena-i+1]-'0';
    for(re int i=1;i<=lenb;++i) B[i]=BB[lenb-i+1]-'0';//反向存，高位下标大 
    A[1]--;//边界需要高精度减一下 
    for(re int i=1;i<=lena;++i)
    {
    	if(A[i]<0) A[i]+=10,A[i+1]--;
    	else break;
	}
    work2();
    work1();
    ans=((ans2-ans1)%mod+mod)%mod;//防止爆负数,(x%mod+mod)%mod 
    printf("%lld\n",ans);
	return 0;
}


```
</font>

---


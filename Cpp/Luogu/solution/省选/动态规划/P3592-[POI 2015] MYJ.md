# [POI 2015] MYJ

## 题目描述

有 $n$ 家洗车店从左往右排成一排，每家店都有一个正整数价格 $p_i$。有 $m$ 个人要来消费，第 $i$ 个人会驶过第 $a_i$ 个开始一直到第 $b_i$ 个洗车店，且会选择这些店中最便宜的一个进行一次消费。但是如果这个最便宜的价格大于 $c_i$，那么这个人就不洗车了。请给每家店指定一个价格，使得所有人花的钱的总和最大。

## 说明/提示

原题名称：Myjnie。

## 样例 #1

### 输入

```
7 5
1 4 7
3 7 13
5 6 20
6 7 1
1 2 5```

### 输出

```
43
5 5 13 13 20 20 13```

# 题解

## 作者：JohnJoeZhu (赞：44)

[题面传送门](https://www.luogu.com.cn/problem/P3592)

## 1.寻找算法方向
##### 1.1 数据范围
首先我们发现，n竟然只有50！

说明我们肯定是要多次枚举位置的

时间复杂度估计在$O(n^2m)$至$O(n^3m)$之间
##### 1.2 初步暴力
暴力的目的是求出在解题过程中我们大致需要枚举的量

首先我们可以枚举每个点的取值，然后统计有效区间

实际大致可以做到$O(n\space max(c))$
##### 1.3 明确算法
暴力不好写，而从暴力得到的复杂度低于上限，那是否说明我们可以通过$O(n)$至$O(n^2)$的枚举来快速得到答案

可是我们发现每个人的要求是区间性的，那么我们是不是可以对每个区间单独考虑，然后再合并

这个思想，不就是**区间dp**吗？（当然你也可以感性理解，大胆猜想qwq）
## 2.完善dp步骤
既然是dp了，那就肯定要走dp那几步的
##### 2.1 设计状态
常规设计是$f[i][j]$表示区间$[i,j]$的收益最大值

由于我们暴力发现需要枚举最小值的位置（即断点）和最小值，所以我们应该这样子设计

$f[i][j][k]$表示区间$[i,j]$，最小值为$k$的最大收益
##### 2.2 确定转移方程
由于我们要枚举最小值的位置（即断点），那就可以这样子写

$f[i][j][k]=max(f[i][l-1][k]+f[l+1][j][k]+val(i,j,l,k))(i<=l<=j)$

$val(i,j,l,k)$表示在区间$[i,j]$内的顾客，当最小值在$l$处，最小值为$k$的价值

$val(i,j,l,k)=cnt(i,j,l,k)*k$

$cnt(i,j,l,k)$也就是在区间$[i,j]$内的顾客，当最小值在$l$处，最小值为$k$时，在$l$处消费的顾客数量

如果我们稍加思考，我们应该发现我们取值后的结果是可传递的

也就是说，$f[i][j][k]=max(f[i][j][k],f[i][j][k+1])$

因为我们选择k为最小值，k+1也是可以选的，顾客少了可是每个人交的钱多了

所以应该有两个方程
$$
f[i][j][k]=max\left\{

\begin{aligned}

f[i][j][k+1]\\

max(f[i][l-1][k]+f[l+1][j][k]+val(i,j,l,k))(i<=l<=j)\\

\end{aligned}
\right.
$$

##### 2.3 得到答案
显然，答案应该是$f[1][n][k]$

那么k应该是多少呢？

我们现在知道，k=1时已经把其他的k的答案都传递了，所以k就是1啦

那么方案呢？（注意有SPJ）

常规操作，我们在枚举过程中记录下断点即最优决策点，再**记录下最优取值k**

这里要注意后者是指向第二个方程的，也就是说，最小值为k，它的最优取值不一定为k

然后就递归求解，直接输出
##### 2.4 优化算法
咦？解决什么问题呢？

我们分析一下时间复杂度

枚举区间状态$O(n^2\space max(c_i))$

枚举断点$O(n)$

转移方程（即求val/cnt）$O(m)$

那复杂度就是$O(n^3m\space max(c_i))$

显然我们可以优化

首先，我们发现求val应该是可以优化的

因为对于一个区间，在某一位置取某一固定值，顾客数是不变的

那么就是说，我们可以**预处理cnt**，复杂度$O(m\space max(c_i))$

然后我们就看到了一直没有处理的$O(max(c_i))$ 

这是一个题目没有给出的值（似乎是$5e5$由于某些原因不见了）

显然我们是不可以使用它的

但是我们真的需要从$1-max(c_i)$枚举吗？

如果我们可以取$c_i$和$c_j(c_i>c_j)$，只有在两个临界点才会产生贡献

也就是说，当我们取$(c_j,c_i)$中的值时，既不能够增加顾客数量，又不能够增大收入（本来的$c_i$的收入越来越小了）

所以我们得到每一个店的标价，只有在某一个$c_i$取值才会最优

那就**离散化**！

我们再来计算时间复杂度

枚举区间状态$O(n^2m)$

枚举断点$O(n)$

求cnt（这里应该好理解），此时不需要嵌套 $O(nm)$

这里外层有一个$O(n^2)$的枚举区间

所以总复杂度应该是$O(n^3m)$
## 3. 代码实现
相信来到紫题的大佬都很牛逼，所以这里只给出部分代码
##### 3.1 离散化
这就太容易了吧
##### 3.2 对于每个区间求出cnt
```cpp
for(int len=1;len<=n;len++)
		for(int i=1,j=i+len-1;j<=n;i++,j=i+len-1)//枚举区间
		{
			for(int k=i;k<=j;k++)
				for(int l=1;l<=tot;l++)//tot为离散化后实际有多少个不同的c
					g[k][l]=0;//因为重复，所以要清零，这里是cnt
			for(int k=1;k<=m;k++)
				if(a[k]>=i&&j>=b[k])//注意顾客区间必须在枚举的区间内，否则顾客可能在其他区间内消费
					for(int l=a[k];l<=b[k];l++)
						g[l][c[k]]++;
			for(int k=i;k<=j;k++)
				for(int l=tot-1;l;l--)//如果l可以，那么比l小的都可以
					g[k][l]+=g[k][l+1];//求出每个点，每个价值可以收获的顾客
      		}
```
##### 3.3 转移方程
```cpp
for(int len=1;len<=n;len++)
		for(int i=1,j=i+len-1;j<=n;i++,j=i+len-1)
			for(int k=tot;k;k--)//枚举最小值
			{
				int anss=0,sum;
				for(int l=i;l<=j;l++)//枚举断点
					if((sum=f[i][l-1][k]+f[l+1][j][k]+g[l][k]*d[k])>=anss) anss=sum,num[i][j][k]=l;//转移方程显然,num存决策点
				if(anss>=f[i][j][k+1]) f[i][j][k]=anss,val[i][j][k]=k;//与k+1比较（由于不同情况需要更新的内容不同 ，val为最优值
				else f[i][j][k]=f[i][j][k+1],val[i][j][k]=val[i][j][k+1];
			 } 
```
##### 3.4 求出答案
```cpp
void gans(int l,int r,int k)
{
	if(l>r) return;
	int point=num[l][r][k=val[l][r][k]];//得到决策点，注意这里的k不一定是原来的k，应该是最优的k
	ans[point]=d[k];//答案函数
	gans(l,point-1,k),gans(point+1,r,k);//递归求解
}
```
然后完整代码就不给出了

然后就没有然后了

**完结撒花**

[顺手广告](https://www.luogu.com.cn/blog/JohnJoeZHU/#type=%E9%A2%98%E8%A7%A3)

---

## 作者：wxgwxg (赞：35)

首先将 $c$ 离散化，考虑区间 DP，设 $f(i,j,k)$ 为区间 $[i,j]$ 最小值为 $k$ 时的最大收益（只考虑$i<=a<=b<=j$的人）。

转移就枚举最小值放在那
$f(i,j,k)=max(f(i,pos-1,y)+f(pos+1,j,z)+cnt(pos)*c[k]$

其中$y>=k,z>=k$ , $cnt(pos)$为区间在$[i,j]$的$(a,b)$穿过$pos$的数量

复杂度$n^3m$。

还需要输出方案，于是dp时候记录一下转移位置

具体实现$f[i][j][k]$为区间$[i,j]$最小值为$k$，$k$的位置.

$mx[i][j][k]$ 是 $ max (dp[i][j][l])   l>=k)$

$pre[i][j][k]$是 $mx[i][j][k]$的$l$。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
inline int read()
{
	int k=0,f=1;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) k=k*10+c-'0';return f*k;
}
const int N=55,M=4005;
int n,m,cnt,f[N][N][M],pre[N][N][M],mx[N][N][M],g[N][M];
int a[M],b[M],c[M],d[M],as[M];
void get(int l,int r,int k)
{
	if(l>r) return;
	int pos=f[l][r][k=pre[l][r][k]];
	as[pos]=d[k];
	get(l,pos-1,k),get(pos+1,r,k);
}
int main()
{
	n=read();m=read();
	for(int i=1;i<=m;i++)
		a[i]=read(),b[i]=read(),c[i]=d[i]=read();
	sort(d+1,d+1+m);cnt=unique(d+1,d+1+m)-d-1;
	for(int i=1;i<=m;i++)
		c[i]=lower_bound(d+1,d+1+cnt,c[i])-d;
	for(int i=n;i;i--)
		for(int j=i;j<=n;j++)
		{
			for(int k=i;k<=j;k++)
				for(int l=0;l<=cnt;l++)
					g[k][l]=0;
			for(int k=1;k<=m;k++)
				if(i<=a[k]&&b[k]<=j)
					for(int l=a[k];l<=b[k];l++)
						g[l][c[k]]++;
			for(int k=i;k<=j;k++)
				for(int l=cnt-1;l;l--)
					g[k][l]+=g[k][l+1];
			for(int k=cnt;k;k--)
			{
				int maxn=0;
				for(int l=i;l<=j;l++)
				{
					int w=mx[i][l-1][k]+mx[l+1][j][k]+g[l][k]*d[k];
					if(maxn<=w) maxn=w,f[i][j][k]=l;
				}
				if(maxn>=mx[i][j][k+1]) mx[i][j][k]=maxn,pre[i][j][k]=k;
				else mx[i][j][k]=mx[i][j][k+1],pre[i][j][k]=pre[i][j][k+1];
			}
		}
	get(1,n,1);
	printf("%d\n",mx[1][n][1]);
	for(int i=1;i<=n;i++)	
		printf("%d ",as[i]);
	return 0;
}
/*
7 5
1 4 7
3 7 13
5 6 20
6 7 1
1 2 5
*/
```

---

## 作者：Alex_Wei (赞：16)

> [P3592 [POI2015]MYJ](https://www.luogu.com.cn/problem/P3592)
>
> [POI 合集](https://www.cnblogs.com/alex-wei/p/POI.html)。

区间 DP 好题。因为 $c_i$ 具体值不重要，只关心相对大小，所以离散化 $c_i$。设 $f_{l,r,x}$ 表示区间 $[l,r]$ 最小值不小于为 $x$ 的答案。由于要输出方案所以记录 $v_{l,r,x}$ 表示 $f_{l,r,x}$ 的区间最小值取了 $v_{l,r,x}$，以及 $d_{l,r,x}$ 表示 $f_{l,r,x}$ 的分割点，这说明 $f_{l,r,x}$ 由 $f_{l,d_{l,r,x}-1,v_{l,r,x}}$ 和 $f_{d_{l,r,x}+1,r,v_{l,r,x}}$ 转移而来。

转移枚举断点 $k$，则贡献为 $f_{l,r,x}=cx+\max_{k\in [l,r]}f_{l,k-1,x}+f_{k+1,r,x}$，其中 $c$ 是满足 $l\leq a_i\leq k\leq b_i \leq r$ 的 $i$ 的个数，可以在枚举 $l,r,k$ 的时候 $\mathcal{O}(m)$ 预处理。注意还要和 $f_{l,r,x+1}$ 取 $\max$。时间复杂度 $\mathcal{O}(n^3m)$。

```cpp
const int N = 50 + 5;
const int M = 4e3 + 5;

int n, m, a[M], b[M], c[M], d[M];
int ans[N], f[N][N][M], buc[N][N];
pii tr[N][N][M];
void dfs(int l, int r, int p) {
	if(l > r) return;
	pii it = tr[l][r][p];
	ans[it.se] = d[it.fi];
	dfs(l, it.se - 1, it.fi), dfs(it.se + 1, r, it.fi);
}
bool Med;
int main(){
	cin >> n >> m;
	for(int i = 1; i <= m; i++) cin >> a[i] >> b[i] >> c[i], d[i] = c[i];
	sort(d + 1, d + m + 1);
	for(int i = 1; i <= m; i++) c[i] = lower_bound(d + 1, d + m + 1, c[i]) - d;
	for(int i = m; i; i--) {
		for(int j = 1; j <= m; j++) if(c[j] == i)
			for(int l = 1; l <= a[j]; l++) for(int r = b[j]; r <= n; r++) buc[l][r]++;
		for(int len = 1; len <= n; len++)
			for(int l = 1, r = len; r <= n; l++, r++) {
				f[l][r][i] = f[l][r][i + 1], tr[l][r][i] = tr[l][r][i + 1];
				for(int p = l; p <= r; p++) {
					int coef = buc[l][r] - buc[l][p - 1] - buc[p + 1][r];
					int v = f[l][p - 1][i] + f[p + 1][r][i] + coef * d[i];
					if(v > f[l][r][i]) f[l][r][i] = v, tr[l][r][i] = {i, p};
				} if(tr[l][r][i].fi == 0) tr[l][r][i] = {i, l};
			}
	} cout << f[1][n][1] << endl, dfs(1, n, 1);
	for(int i = 1; i <= n; i++) cout << ans[i] << " ";
	return 0;
}
```

---

## 作者：zzqDeco (赞：10)

这题事真的恶心了我好久

首先我们要看出来这个是一个笛卡尔树的模型，虽然和笛卡尔树没太大的关系

首先，可以发现一个车的贡献一定在最小处产生

所以对此，我们找到整个的最小值，可以发现，对于洗车的描述分为3类

1. 经过最小值的点的
2. 在左边的
3. 在右边的

我们可以统计的就是经过点的值：cnt*val

那么显然这个可以推广，所分成的两个区间也是满足这个性质的

所以我们就可以做区间dp，先预处理对于 $[l,r]$ 当点 $p$ 选择赋值为 $k$ 的时候可以考虑的点的个数

我们定义 $f_{i,j,k}$ 为当考虑 $[l,r]$ 选择最小值为大于等于 $k$ 的数的最大收益

然后再枚举 $len$ ，枚举 $k$ 和中间点位置 $p$ ,常见的套路去更新

大概就是这样

```cpp
for(int k=cnt;k>=1;k--)
{
  f[l][r][k]=f[l][r][k+1];
  last[l][r][k]=last[l][r][k+1];
  best[l][r][k]=best[l][r][k+1];
  for(int p=l;p<=r;p++)
  {
    if(f[l][p-1][k]+f[p+1][r][k]+across[l][r][p][k]*b[k]>f[l][r][k])
    {
      f[l][r][k]=f[l][p-1][k]+f[p+1][r][k]+across[l][r][p][k] * b[k];
      last[l][r][k]=p;
      best[l][r][k]=k;
    }
  }
}
```

然后我们要处理一下维护方案，就是记录在哪里转移，也就是维护笛卡尔树的每一个点和点上的值，最后一个dfs递归就可以找到答案了

那代码就是

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

struct Q
{
  int l,r;
  long long val;
}q[1010];

long long f[20][20][1010],last[20][20][1010],best[20][20][1010],across[20][20][20][1010],minn[20][20][20];

long long b[1010],ans[20];

int n,m;

void dfs(int l,int r,int k)
{
  if(l>r) return ;
  ans[last[l][r][k]]=b[best[l][r][k]];
  dfs(l,last[l][r][k]-1,best[l][r][k]);
  dfs(last[l][r][k]+1,r,best[l][r][k]);
}

int main()
{
  memset(minn,0x3f,sizeof(minn));
  scanf("%d%d",&n,&m);
  for(int i=1;i<=m;i++)
  {
    scanf("%d%d%lld",&q[i].l,&q[i].r,&q[i].val);
    b[i]=q[i].val;
  }
  sort(b+1,b+m+1);
  int cnt=unique(b+1,b+m+1)-b-1;
  for(int i=1;i<=m;i++)
  {
    q[i].val=lower_bound(b+1,b+cnt+1,q[i].val)-b;
  }
  for(int i=1;i<=m;i++)
  {
    for(int l=1;l<=q[i].l;l++)
    {
      for(int r=q[i].r;r<=n;r++)
      {
        for(int j=q[i].l;j<=q[i].r;j++)
        {
           across[l][r][j][q[i].val]++;
        }
      }
    }
  }
  for(int l=1;l<=n;l++)
  {
    for(int r=l+1;r<=n;r++)
    {
      for(int p=l;p<=r;p++)
      {
        for(int j=cnt;j>=1;j--)
        {
          across[l][r][p][j]+=across[l][r][p][j+1];
        }
      }
    }
  }
  for(int len=1;len<=n;len++)
  {
    for(int l=1;l+len-1<=n;l++)
    {
      int r=l+len-1;
      best[l][r][cnt+1]=cnt;
      last[l][r][cnt+1]=l;
      for(int k=cnt;k>=1;k--)
      {
        f[l][r][k]=f[l][r][k+1];
        last[l][r][k]=last[l][r][k+1];
        best[l][r][k]=best[l][r][k+1];
        for(int p=l;p<=r;p++)
        {
          if(f[l][p-1][k]+f[p+1][r][k]+across[l][r][p][k]*b[k]>f[l][r][k])
          {
            f[l][r][k]=f[l][p-1][k]+f[p+1][r][k]+across[l][r][p][k] * b[k];
            last[l][r][k]=p;
            best[l][r][k]=k;
          }
        }
      }
    }
  }
  dfs(1,n,1);
  printf("%lld\n",f[1][n][1]);
  for(int i=1;i<=n;i++)
  {
    printf("%lld ",ans[i]);
  }
}

```

然而这个过不了

自然可以发现前提我们要预处理 $across$ 数组，然而存不下

实际可以动态求解，就像这样

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

struct Q
{
  int l,r;
  long long val;
}q[4010];

long long f[55][55][4010],last[55][55][4010],best[55][55][4010],across[55][4010];

long long b[4010],ans[55];

int n,m;

void dfs(int l,int r,int k)
{
  if(l>r) return ;
  ans[last[l][r][k]]=b[best[l][r][k]];
  dfs(l,last[l][r][k]-1,best[l][r][k]);
  dfs(last[l][r][k]+1,r,best[l][r][k]);
}

int main()
{
  scanf("%d%d",&n,&m);
  for(int i=1;i<=m;i++)
  {
    scanf("%d%d%lld",&q[i].l,&q[i].r,&q[i].val);
    b[i]=q[i].val;
  }
  sort(b+1,b+m+1);
  int cnt=unique(b+1,b+m+1)-b-1;
  for(int i=1;i<=m;i++)
  {
    q[i].val=lower_bound(b+1,b+cnt+1,q[i].val)-b;
  }
  for(int len=1;len<=n;len++)
  {
    for(int l=1;l+len-1<=n;l++)
    {
      int r=l+len-1;
      memset(across,0,sizeof(across));
      for(int k=1;k<=m;k++)
      {
        if(l<=q[k].l&&r>=q[k].r)
        {
          for(int p=q[k].l;p<=q[k].r;p++)
          {
            across[p][q[k].val]++;
          }
        }
      }
      for(int p=l;p<=r;p++)
      {
        for(int j=cnt;j>=0;j--)
        {
          across[p][j]+=across[p][j+1];
        }
      }
      best[l][r][cnt+1]=cnt;
      last[l][r][cnt+1]=l;
      for(int k=cnt;k>=1;k--)
      {
        f[l][r][k]=f[l][r][k+1];
        last[l][r][k]=last[l][r][k+1];
        best[l][r][k]=best[l][r][k+1];
        for(int p=l;p<=r;p++)
        {
          if(f[l][p-1][k]+f[p+1][r][k]+across[p][k]*b[k]>f[l][r][k])
          {
            f[l][r][k]=f[l][p-1][k]+f[p+1][r][k]+across[p][k] * b[k];
            last[l][r][k]=p;
            best[l][r][k]=k;
          }
        }
      }
    }
  }
  dfs(1,n,1);
  printf("%lld\n",f[1][n][1]);
  for(int i=1;i<=n;i++)
  {
    printf("%lld ",ans[i]);
  }
}

```

你便完美解决了这个题了


---

## 作者：loceaner (赞：7)

## 思路

>离散化+区间$\texttt{DP}$

稍作分析~~半天~~就会发现：存在一组答案使得每个$ans_i$都是某个$c_i$。因为把某个答案替换成第一个大于等于它的$c_i$不会更劣，因此$c_i$的值并不影响做题，但是大小顺序是有用的所以我们将$c_i$离散化。

因为一个区间的代价之和只与最小值有关，而且数据范围的$n$也不大，所以考虑区间$\texttt{DP}$：

设$f[l][r][k]$表示区间$[l,r]$内$ans[]$的最小值等于$k$的最大收益，$g[p][j]$为当前区间穿过$p$，且$c\geq j$的区间数量

枚举最小的位置$p$，那么包含$p$的区间的答案全都是$k$，之后转移

$$f[l][r][k]=\max(\max(f[l][p - 1][k] + f[p + 1][r][k]+g[p][k]*k,p\in[l,r]),f[l][r][k+1])$$

$\texttt{DP}$时顺便记录记录决策点，然后$dfs$输出

时间复杂度$O(n^3m)$

## 代码

```cpp
/*
Author:Loceaner
区间DP 
*/
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

const int A = 51;
const int B = 4011;
const int mod = 1e9 + 7;
const int inf = 0x3f3f3f3f;

inline int read() {
  char c = getchar(); int x = 0, f = 1;
  for ( ; !isdigit(c); c = getchar()) if (c == '-') f = -1;
  for ( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
  return x * f;
}

struct node { int l, r, c; } a[B];
int n, m, tot, ans[B], res[B];
int pre[A][A][B], f[A][A][B], pos[A][A][B], g[A][B];

inline void work(int l, int r, int now) {
  if (l > r) return;
  int qwq = pos[l][r][now = pre[l][r][now]];
  ans[qwq] = res[now];
  work(l, qwq - 1, now), work(qwq + 1, r, now);
}

inline void update(int l, int r) {
  for (int i = l; i <= r; i++) 
    for (int minn = 0; minn <= tot; minn++) g[i][minn] = 0;
  for (int i = 1; i <= m; i++) 
    if (l <= a[i].l && a[i].r <= r) 
      for (int j = a[i].l; j <= a[i].r; j++) g[j][a[i].c]++;
  for (int i = l; i <= r; i++)
    for (int j = tot - 1; j >= 1; j--) g[i][j] += g[i][j + 1];
}

inline void dp(int l, int r) {
  for (int k = tot; k >= 1; k--) {
    int maxn = 0;
    for (int p = l; p <= r; p++) {
      int now = f[l][p - 1][k] + f[p + 1][r][k] + g[p][k] * res[k];
      if (maxn <= now) maxn = now, pos[l][r][k] = p;
    }
    if (maxn >= f[l][r][k + 1]) f[l][r][k] = maxn, pre[l][r][k] = k;
    else f[l][r][k] = f[l][r][k + 1], pre[l][r][k] = pre[l][r][k + 1];
  }
}

signed main() {
  n = read(), m = read();
  for (int i = 1; i <= m; i++)
    a[i].l = read(), a[i].r = read(), a[i].c = read(), res[i] = a[i].c;
  sort(res + 1, res + 1 + m);
  tot = unique(res + 1, res + m + 1) - res - 1;
  for (int i = 1; i <= m; i++) 
    a[i].c = lower_bound(res + 1, res + tot + 1, a[i].c) - res;
  for (int i = n; i >= 1; i--)
    for (int j = i; j <= n; j++) 
      update(i, j), dp(i, j);
  work(1, n, 1);
  cout << f[1][n][1] << '\n';
  for (int i = 1; i <= n; i++) cout << ans[i] << " ";
  return 0;
}
```

---

## 作者：天梦 (赞：5)

[题目](https://www.luogu.com.cn/problem/P3592)

这道题是我做过的最难的一道区间dp。

#### 1思路

看到 $n$ 最大只有，而 $m$ 有 $4000$ ，我们想到这个题的时间复杂度应该是 $O(n^3m)$ 左右的，毕竟这已经是极限。

进而发现一段区间内所花的钱数与这段区间的最小值有关，于是我们考虑把最小值放进状态里。考虑区间dp，我们**枚举最小值的位置**来进行转移。

#### 2状态设计和转移方程式

注意到 $m$ 只有 $4000$ ，而 $c_i$ 可能很大，所以我们首先对 $c_i$ 离散化。

设状态 $f_{i,j,k}$ 表示区间 $[i,j]$ （注意 $i$ 可能等于 $j$ ，这样写不是很符合规范，但不影响理解）中最小值为 $k$ 时所有人花的钱的总和的最大值。

那么有下面的转移方程式：
$$
f_{i,j,k}=\max\limits_{q_1,q_2\in[k,m],x\in[i,j]}(f_{i,x-1,q_1}+f_{x+1,j,q_2}+cost_{x,k})
$$
其中，上面涉及的所有变量都是整数， $m$ 代表的含义如题目所示， $cost_{x,k}$ 表示把 $x$ 赋值为**最小值** $k$ 所产生的花费。

什么意思呢？我们首先枚举这个最小值 $k$ 出现的位置，那么我们就把原问题划分成了两个子问题，由于 $k$ 是最小值，所以需要满足划分后两边的小区间的最小值要不小于 $k$ 。

如何计算 $cost_{x,k}$ 呢？ 我们可以直接算出在 $[i,j]$ 中会有多少人在 $x$ 这个位置花费，最后在再乘上 $k$ 。前者我们考虑提前预处理出来，看一个数组存储，但是这样的话数组是四维的，太大开不下。所以我们不如动态预处理：在dp的过程中会先枚举 $i$ 和 $j$ ，之后我们开一个二维的数组，算出在区间 $[i,j]$ 中的 $cnt_{x,k}$ （表示在该区间中把位置 $x$ 赋值为 $k$ 后有多少人回来这里花费），然后我们dp转移即可。

注意：

+  $x$ 的取值范围为 $[i,j]$ 而非 $(i,j)$ 。

  可能有些读者认为当 $x$ 取值为 $i$ 或 $j$ 时，对应的 $x-1$ 和 $x+1$ 没有意义，但实际上这个时候 $cost_{x,k}$ 是有意义的，我们不能漏考虑掉这种情况。且容易发现虽然 $x-1,x+1$，所对应的 $f$ 值有时不合法，但是它们不合法时的值都是 $0$ ，所以不影响正确性。

+ 在转移时我们记 $g_{i,j,k}=f_{i,j,q},q\geq k$，在维护 $f$ 的同时维护 $g$ ，这样就可以做到 $O(n)$  的转移——我们只需要枚举断点 $x$ 。

#### 3打印解

这里我开了两个数组， $pre_{i,j,k}$ 表示 $f_{i,j,q'}=\max(f_{i,j,q},q\geq k)$ 取得最值时枚举的断点；而 $co_{i,j,k}$ 表示 $f_{i,j,q},q\geq k$ 取得最大值的颜色，即满足 $q\geq k$ 的使 $f_{i,j,q}$ 最大的 $q$ 。

显然，这两个数组是可以顺带维护的，具体实现请看代码。

#### 4代码

```c++
#define dd double
#define ld long double
#define ll long long
#define ull unsigned long long
#define N 52
#define M 4010
using namespace std;

const int INF=0x3f3f3f3f;

inline int Max(int a,int b){
    return a>b?a:b;
}

inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}

template<typename T> inline void write(T x){
    if(x<0) x=-x,putchar('-');
    if(x>9) write(x/10);
    putchar(x%10+'0');
}

int d[M],rk[M];
int n,m,a[M],b[M],c[M];
inline void intt(){
    n=read();m=read();
    for(int i=1;i<=m;i++) a[i]=read(),b[i]=read(),c[i]=read();
    for(int i=1;i<=m;i++) d[i]=c[i];
    sort(d+1,d+m+1);
    int nm=unique(d+1,d+m+1)-d-1;
    for(int i=1;i<=m;i++){
        int nowc=lower_bound(d+1,d+nm+1,c[i])-d;
        rk[nowc]=c[i];
        c[i]=nowc;
    }
}

int cost[N][M];
int f[N][N][M],g[N][N][M],point[N][N][M],co[N][N][M],lin[M]; 
inline int dp(){
    int ans=-INF;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n-i+1;j++){
            int l=j,r=j+i-1;
            for(int k=1;k<=n;k++) for(int x=1;x<=m;x++) cost[k][x]=0;
//            for(int k=l;k<=r;k++)
//                for(int x=1;x<=m;x++)
//                    if(l<=a[x]&&b[x]<=r&&a[x]<=k&&k<=b[x]) cost[k][c[x]]++;
            for(int k=1;k<=m;k++) if(l<=a[k]&&b[k]<=r) for(int x=a[k];x<=b[k];x++) cost[x][c[k]]++;
            for(int k=l;k<=r;k++)
                for(int x=m;x>=1;x--)
                    cost[k][x]+=cost[k][x+1];
            for(int k=m;k>=1;k--){
                for(int x=l;x<=r;x++){
                    if(f[l][r][k]<=g[l][x-1][k]+g[x+1][r][k]+cost[x][k]*rk[k]){
                        f[l][r][k]=g[l][x-1][k]+g[x+1][r][k]+cost[x][k]*rk[k];
                        lin[k]=x;
                    }
                }
                if(g[l][r][k+1]>f[l][r][k]){
                    g[l][r][k]=g[l][r][k+1];
                    point[l][r][k]=point[l][r][k+1];
                    co[l][r][k]=co[l][r][k+1];
                }
                else{
                    g[l][r][k]=f[l][r][k];
                    point[l][r][k]=lin[k];
                    co[l][r][k]=k;
                }
                if(i==n) ans=Max(ans,f[l][r][k]);
            }
        }
    }
    return ans;
}

int ans,color[N];
inline void print(int l,int r,int k){
    int w=-1,col=co[l][r][k];
    color[w=point[l][r][k]]=co[l][r][k];
    if(w==0){
        printf("NOOOOOOOOOOOOOOOOO\n");
        return;
    }
    if(l<w) print(l,w-1,col);
    if(w<r) print(w+1,r,col);
}

int main(){
    intt();
    ans=dp();
    write(ans);putchar('\n');
    print(1,n,1);
    for(int i=1;i<=n;i++) write(rk[color[i]]),putchar(' ');
    return 0;
}
```

代码中的注意事项：

+ $lin_k$ 表示在区间 $[l,r]$ 中使 $f_{l,r,k}$ 取得最值得断点。

+ 我们利用了一个类似于前缀和的方式来计算 $cut$ （在代码里是 $cost$ ），这种方式不难理解，如果值 $k$ 能够被计算，那么比 $k$ 小的值也肯定能被计算。

+ 注意在 $61$ 行的不大于号和在第 $66$ 行的大于号，这两个符号都不能轻易的改成小于号和不小于号，这是因为如果在 print 函数中出现 $w$ 等于 $0$ 的情况，那么你的这个程序就停不下来了，而以上两个符号确保了不会出现 $0$ 。

  为什么呢？实际上，出现 $0$ 的原因是因为你在记录的时候遵循这样的一个原则：只要不是更优就不更新。但这里要遵循的原则确恰恰相反：只要达到最优值或是更优就更新。 $61$ 行的符号保证了 $lin$ 数组不为 $0$ ，而 $66$ 行的符号保证了相等时取 $lin$ 的值。这样就防止了 $0$ 的出现。

  我已经在 print 函数中加入了防止程序停不下来的措施，读者可以自行更改这两个符号，看一看有什么不同。

+ 注意到 $52$ 到 $54$ 行被我注释掉的部分，实际上这三行和第 $55$ 行的作用是一样的，但是如果你用注释掉的部分替代第 $55$ 行会超时，这提示我们在有判断语句时适当的调整循环顺序可以减少优化常数。





---

## 作者：AxDea (赞：4)

首先，发现 $p$ 的每一个数字，最优解的一种情况肯定都是填入 $c$ 数组中的数字。

发现构造一个序列，就是建立一颗笛卡尔树，设 $dp(l, r, k)$ 表示区间 $[l, r]$ 最小值为 $k$ ，也就是 $l$ ，$r$ 两节点 LCA 的权值为 $k$ 的最优解。

那么有 

$$
dp(l, r, k) = \max_{a, b\ge k\ l < i < r}\{dp(l, i - 1, a) + dp(i + 1, r, b) + k\times f(l, r, i, k)\}
$$

其中 $f(l, r, i, k)$ 表示左端点属于 $[l, i]$ ，右端点属于 $[i, r]$ 的且 $c \ge k$ 所有线段个数和，这个可以简单容斥算，具体来说，设 $g(l, r, k)$ 表示 $[l, r]$ 区间中 $c\geq k$ 的线段个数，这个答案等于 $g(l, r, k) - g(l, i - 1, k) - g(i + 1, r, k)$ 。

做一下第三维前缀处理，这一段 DP 的时间复杂度为 $\mathcal{O}(n ^ 3 m)$ 。

考虑如何输出方案，只要记录一下每次转移时候的那个最优的 $i$ 和 $a, b$ 即可，然后就像一棵树一样遍历下去就好了。

```cpp
#include <bits/stdc++.h>
#define forn(i,s,t) for(register int i=(s); i<=(t); ++i)
#define form(i,s,t) for(register int i=(s); i>=(t); --i)
#define rep(i,s,t) for(register int i=(s); i<(t); ++i)
using namespace std;
typedef long long LL;
const int N = 52, M = 4e3 + 3;
struct node {
	int l, r, c;
	node() {}
	node(int _l, int _r, int _c) : l(_l), r(_r), c(_c) {}
};
inline bool trans(int& A, int B) {
	return (A <= B) && (A = B, 1);
}
int n, m, Rn, a[M], b[M], c[M], rft[M], g[N][N][M], val[N][N][M];
int dp[N][N][M]; node f[N][N][M];
basic_string<int> P[M];
void dfs(int l, int r, int k) {
	if(l > r) return ;
	if(f[l][r][k].l) dfs(l, f[l][r][k].c - 1, f[l][r][k].l);
	printf("%d ", rft[val[l][r][k]]);
	if(f[l][r][k].r) dfs(f[l][r][k].c + 1, r, f[l][r][k].r);
}
int main() {
	scanf("%d%d", &n, &m);
	forn(i,1,m) scanf("%d%d%d", a + i, b + i, c + i), rft[i] = c[i];
	sort(rft + 1, rft + m + 1);
	Rn = unique(rft + 1, rft + m + 1) - rft - 1;
	forn(i,1,m) c[i] = lower_bound(rft + 1, rft + Rn + 1, c[i]) - rft, P[c[i]] += i;
	forn(i, 1, n) forn(j, i, n) form(k,Rn,1) {
		g[i][j][k] += g[i][j][k + 1];
		rep(l,0,P[k].size()) {
			static int v; v = P[k][l];
			g[i][j][k] += (i <= a[v] && b[v] <= j);
		}
	}
	forn(len, 1, n) for(register int l = 1, r = len; r <= n; ++l, ++r)
		form(k, Rn, 1) {
			dp[l][r][k] = dp[l][r][k + 1], f[l][r][k] = f[l][r][k + 1];
			val[l][r][k] = val[l][r][k + 1];
			forn(i, l, r) if(trans(dp[l][r][k], dp[l][i - 1][k] + dp[i + 1][r][k] + 1ll * rft[k] * (g[l][r][k] - g[l][i - 1][k] - g[i + 1][r][k])))
				f[l][r][k] = node(val[l][i - 1][k], val[i + 1][r][k], i), val[l][r][k] = k;
		}
	printf("%d\n", dp[1][n][1]), dfs(1, n, 1);
	return 0;
}
```



---

## 作者：Zxsoul (赞：3)

**前言**

> 看到题解区的码风千篇一律，我来提供一种新的写法吧

**思路**

首先将 $c$ 离散化，在考虑区间DP，$f(i,j,k)$ 为区间 $[i,j]$ 最小值为 $k$ 的最大收益，然后枚举 $k$ 的位置 $x$，转移有 

$$
f[i,x-1,>=k]+f[x+1,j,>=k]+cost_x
$$ 

$cost_x$ 用 $g$ 数组才存储，$g_{i,k}$ 表示 在区间范围内，经过 $k$ （枚举的最小价值） 的次数

还有，在记录个数的时候用到**差分**，转移个数由大到小递推转移就可以计数了，其余的就是递归输出方案，大家都会，没必要说

```c
#include <cmath>
#include <queue>
#include <cstdio>
#include <vector>
#include <cstring>
#include <iostream>
#include <algorithm>
#define int long long
using namespace std;

int  f[60][69][5000];
int g[60][50000],pos[60][60][5000];
int street[60][60][5000];
int ans[100];
int lsh[B],tot,m,n; 
int num[60][50000],cnt,a[B],b[B],c[B];

int LSH(int x) {return lower_bound(lsh+1,lsh+1+tot,x)-lsh;}
void work()
{
	sort(lsh+1,lsh+tot+1) ;
	tot = unique(lsh+1,lsh+1+tot)-lsh-1;
	for (int i=1;i<=m;i++) c[i]=LSH(c[i]);
	return;
}

void query(int l,int r)
{
	for (int i=1;i<=n;i++) for (int j=1;j<=tot;j++) g[i][j]=0;
	for (int i=1;i<=m;i++)	if (l<=a[i] && b[i]<=r) g[a[i]][c[i]]++,g[b[i]+1][c[i]]--;//差分操作
	for (int i=1;i<=n;i++) for (int j=1;j<=tot;j++) g[i][j]+=g[i-1][j];//转移的原数
	for (int i=1;i<=n;i++) for (int j=tot;j>=1;j--) g[i][j]+=g[i][j+1];//开始转移 
	
	return;
}

void dfs(int l,int r,int k)
{
	if (k>tot) return;
	if (l>r) return;
	k=street[l][r][k];
	ans[pos[l][r][k]]=lsh[k];
	dfs(l,pos[l][r][k]-1,k), dfs(pos[l][r][k]+1,r,k);
}

main()
{
	int x,y,z,maxx=0;
	n=read(),m=read();
	for (int i=1;i<=m;i++)	a[i]=read(),b[i]=read(),lsh[++tot]=c[i]=read();
	work();
	for (int len=1;len<=n;len++)
		for (int i=1;i+len-1<=n;i++)
		{
			int j=i+len-1;
			query(i,j);
			for (int k=tot;k>=1;k--)
			{	
				for (int l=i;l<=j;l++)
				{
					int val=(l>i)?f[i][l-1][k]:0;
						val+=((l<j)?f[l+1][j][k] : 0)+lsh[k]*g[l][k];
					if (f[i][j][k]<=val)
					{
						f[i][j][k]=val;
						pos[i][j][k]=l;
					}
				}
				if (f[i][j][k]>=f[i][j][k+1]) street[i][j][k]=k; 
				else f[i][j][k]=f[i][j][k+1],street[i][j][k]=street[i][j][k+1]; 
			}
		}
	printf("%lld\n",f[1][n][1]);
	dfs(1,n,1);
	for (int i=1;i<=n;i++) printf("%lld ",ans[i]?ans[i]:1); 
}
```

---

## 作者：WeLikeStudying (赞：3)

$$\text{sto MYJ orz}$$
- MYJ 是我们的红太阳，让我们一起赞美 [MYJ](https://www.luogu.com.cn/user/58543) 吧。

**题意**
- [题面](https://www.luogu.com.cn/problem/P3592)。
- 有 $m$ 个对于长度为 $n$ 的序列 $a$ 的估价函数 $f_i=[\min_{k=l_i}^{r_i}a_k\le c_i]\cdot \min_{k=l_i}^{r_i}a_k$。
- 构造方案，最大化：
$$\sum_{i=1}^mf_i$$
- $n\le 50,m\le 4000,c_i\le 5\times 10^5$。

**分析**
- 不愧是 MYJ 大奆佬的题目，蒟蒻一看就不会了。
- MYJ 说，要简化问题：所以我们可以发现一个简单的信息，所有的 $a_i$ 应该都是 $c_i$ 中的一个，否则显然可以使得估价函数的值变大，所以 $5\times 10^5$ 变成了 $4000$。
- MYJ 说，要学会变换：所以我们假设 $f(l,r)$ 为使得 $l\le l_i,r_i\le r$ 的所有估价函数的和最大的安排，来思考它的最优子结构性质。
- 让我们任意选定一个 $g$ 作为 $[l,r]$ 的中点并强行让它为最小值，那么所有经过 $g$ 的区间就全部处理完毕了，问题被分为两个互相独立的区间。
- 所以我们设 $f(l,r,k)$ 为设定让 $a_l$ 到 $a_r$ 大于等于 $c_k$，处理完被 $[l,r]$ 区间覆盖的估价函数的最优方案。
- 聪明地转移，时间复杂度是 $O(n^3m)$，空间复杂度是 $O(n^2m)$，聪明地剪枝，复杂度绝对卡不满，对于输出方案的问题，我们显然可以在算出最优的答案后轻易地倒推。
- 所以我们就成功地水过了这道题：真是让人感到无尽地愉悦啊！[代码实现](https://www.luogu.com.cn/paste/5l8zt696)，比记忆化搜索可能会慢一点。
- 我觉得这种方法还是有启发性的吧，不愧是 [MYJ](https://www.luogu.com.cn/blog/RioBlu1270585465/p3592-poi2015-myj) 啊！

---

## 作者：快斗游鹿 (赞：1)

## 思路

首先可以想到，最后的 $p_i$ 一定是 $c_i$ 中的一个。然后本题涉及到区间，可以想到用区间 dp 解决。

第一步，先设计状态。先想到设 $f_{l,r}$ 表示区间 $[l,r]$ 的答案。但是这样有一个问题，我们需要知道这个区间中最小的 $c_i$。所以设 $f_{l,r,k}$ 表示区间 $[l,r]$，最小值为 $k$ 的答案。

第二步，考虑转移。显然有 $f_{l,r,k}=\max(f_{l,r,k},f_{l,pos,x}+f_{pos+1,r,y}+c_k\times cnt_{pos})$。其中，$pos$ 是我们枚举的最小值 $k$ 所在位置。根据状态，可以知道 $x,y\ge k$。$cnt_{pos}$ 表示的则是所有满足 $l\le a_i\le pos\le b_i\le r$ 的区间数。这个东西可以预处理出来。整个转移过程是 $O(n^3m)$ 的。

第三步，如何输出方案。我们可以记录以下几个值。$p_{l,r,k}$ 表示 $f_{l,r,k}$ 取到最优解时最小值的位置。$id_{l,r,k}$ 表示 $f_{l,r,l}(l\ge k)$ 的最大值的 $l$。这样就可以方便地输出方案。

最后需要注意，最小值的位置可以在区间左右端点上。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=55;
const int M=4e3+5;
int n,m;
int a[M],b[M],c[M],cc[M],s;
int f[N][N][M],cnt[N][N],p[N][N][M],id[N][N][M],lst[N],ans;//f区间l~r,min=k 
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
void solve(int l,int r,int k){
	if(l>r)return;
	int pos=p[l][r][id[l][r][k]];
	lst[pos]=cc[id[l][r][k]];
	//cout<<l<<" "<<r<<" "<<pos<<" "<<k<<endl;
	solve(l,pos-1,id[l][r][k]);
	solve(pos+1,r,id[l][r][k]);
}
signed main(){
	freopen("data.txt","r",stdin);
	n=read();m=read();
	for(int i=1;i<=m;i++){
		a[i]=read();b[i]=read();c[i]=read();cc[i]=c[i];
	}
	sort(cc+1,cc+1+m);
	s=unique(cc+1,cc+1+m)-cc-1;
	for(int i=1;i<=m;i++){
		c[i]=lower_bound(cc+1,cc+1+s,c[i])-cc;//cout<<c[i]<<endl;
	}
	for(int k=s;k>=1;k--){
		for(int i=1;i<=m;i++){
			if(c[i]==k){
				for(int l=1;l<=a[i];l++){
					for(int r=b[i];r<=n;r++)cnt[l][r]++;
				}
			} 
		}
		for(int len=1;len<=n;len++){
			for(int l=1;l<=n;l++){
				int r=l+len-1;if(r>n)break;
				int nowmx=0;
				for(int pos=l;pos<=r;pos++){
					int ccc=cnt[l][r]-cnt[l][pos-1]-cnt[pos+1][r];
					int noww=f[l][pos-1][k]+f[pos+1][r][k]+ccc*cc[k];
					if(noww>=nowmx){
						nowmx=noww;
						p[l][r][k]=pos;//断点在哪 
					}
				}
				if(nowmx>=f[l][r][k+1]){
					f[l][r][k]=nowmx;id[l][r][k]=k;
				}
				else{
					f[l][r][k]=f[l][r][k+1];
					id[l][r][k]=id[l][r][k+1];
				}
			}
		}
	} 
	cout<<f[1][n][1]<<endl;
	solve(1,n,1);
	for(int i=1;i<=n;i++)cout<<lst[i]<<" ";
	return 0;
}

```



---

## 作者：Purslane (赞：0)

# Solution

NOIp 2023 RP++！

考虑先找到 $[1,n]$ 的最小值在哪里。假设在 $p$。

所有跨过它的消费者如果消费，必定在此处消费。

那么把这些能消费的人抛去，剩下的消费者只能在 $[1,p-1]$ 或者 $[p+1,n]$ 处消费。而且**这两个子区间的最小值必定大于等于 $p$ 处的值**。

于是可以想到一个很自然的区间 DP。设 $dp_{l,r,k}$ 表示我们考虑所有在包含于 $[l,r]$ 中的消费者，如果这个区间的最小值是 $k$，那么这些消费者最大能产生的收益是多少。那么转移为：

$$dp_{l,r,k}=\max_{l \le t \le r} \{\max_{k' \ge k} dp_{l,t-1,k'}+\max_{k' \ge k} dp_{t+1,r,k'}+\sum_{i=1}^m k[a_i \ge l][a_i \le t][b_i \ge t][b_i \le r][c_i \ge k]\}$$

这样可以做到 $O(n^3 (m+V))$，$V$ 是值域。

然而很容易发现事实上最优情况下每个 $k$ 都只能在 $c$ 中选取。于是将其离散化即可。

复杂度 $O(n^3 m)$，足以通过本题。

代码：

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=50+5,MAXM=4000+5;
int n,m,ans[MAXN],a[MAXM],b[MAXM],c[MAXM],lsh[MAXM],tot;
int dp[MAXN][MAXN][MAXM],frmp[MAXN][MAXN][MAXM],frml[MAXN][MAXN][MAXM],frmr[MAXN][MAXN][MAXM],pre[MAXM];
void gain(int l,int r,int v) {
	if(l>r) return ;
	ans[frmp[l][r][v]]=lsh[v];
	gain(l,frmp[l][r][v]-1,frml[l][r][v]);
	gain(frmp[l][r][v]+1,r,frmr[l][r][v]);
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m; ffor(i,1,m) cin>>a[i]>>b[i]>>c[i],lsh[++tot]=c[i];
	sort(lsh+1,lsh+tot+1),tot=unique(lsh+1,lsh+tot+1)-lsh-1;
	ffor(i,1,m) c[i]=lower_bound(lsh+1,lsh+tot+1,c[i])-lsh;
	ffor(len,1,n) for(int l=1,r=len;r<=n;l++,r++) {
		ffor(k,l,r) {
			ffor(i,1,tot) pre[i]=0;
			ffor(i,1,m) if(a[i]>=l&&a[i]<=k&&b[i]>=k&&b[i]<=r) pre[c[i]]++;
			roff(i,tot-1,1) pre[i]+=pre[i+1];
			int lmxval=0,lmxpos=0,rmxval=0,rmxpos=0;
			roff(i,tot,1) {
				if(dp[l][k-1][i]>=lmxval) lmxval=dp[l][k-1][i],lmxpos=i;
				if(dp[k+1][r][i]>=rmxval) rmxval=dp[k+1][r][i],rmxpos=i;
				if(lmxval+rmxval+pre[i]*lsh[i]>=dp[l][r][i]) {
					dp[l][r][i]=lmxval+rmxval+pre[i]*lsh[i];
					frml[l][r][i]=lmxpos;
					frmr[l][r][i]=rmxpos;
					frmp[l][r][i]=k;
				}
			}
		}
	}
	int mx=0;
	ffor(i,1,tot) mx=max(mx,dp[1][n][i]);
	ffor(i,1,tot) if(dp[1][n][i]==mx) {
		gain(1,n,i);
		cout<<mx<<'\n';
		ffor(j,1,n) cout<<ans[j]<<' ';
		return 0;	
	}
	return 0;
}
```

---

## 作者：licn (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P3592)

## **题目分析：**
给了很多个区间，进行构造是利益最大化，很明显区间 DP。

## **定义状态：**
避免不了的 $dp_{i,j}$，表示区间 $i$ 到 $j$ 只考虑选择区间完全在 $i$ 和 $j$ 内的人的最大利益。显然，每个人的最大能接受的的值不同我们还需要再加一维变成：$dp_{i,j,k}$ 表示区间 $i$ 到 $j$ 中最小接收值为 $k$，只考虑选择区间完全在 $i$ 和 $j$ 内的人的贡献的最大收益。

## **状态转移：**

$dp_{i,j,k}=\max(f_{i,z-1,k}+f_{z+1,j,k}+val(i,j,z,k)\times a_z)$

$f_{i,j,k}=\max(dp_{i,j,k2})$ $(k2>k$)。

$z$ 是从 $i$ 到 $j$。

$val(i,j,z,k)$ 表示区间完全在 $i$ 到 $j$ 之间且穿过点 $z$ 并且其贡献大于等于 $k$ 的个数。

本题 dp 的核心思想就是这些，记得离散化贡献。最外层枚举 $k$ 将 $m$ 个区间按贡献从大到小排序，可高效求 $val$，还可将 $dp$ 数组压掉一维。还需要输出构造，记录每一次的最优 $z$，最后跑一遍赋值。

## Code：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=55,M=4e3+10;
int n,m,dp[N][N],g[N][N][N],b[N],pre2[N][N][M],h[N],pre[N][N][M],ans[N];
struct node
{
	int l,r,c;
}a[M];
bool cmp(node sh,node jy)
{
	return sh.c>jy.c;
}
void print(int l,int r,int k)
{
	if(l>r)return;
	int mid=pre[l][r][k=pre2[l][r][k]];
	ans[mid]=h[k];
	print(l,mid-1,k),print(mid+1,r,k);
}
signed main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=m;i++)scanf("%lld%lld%lld",&a[i].l,&a[i].r,&a[i].c),b[i]=a[i].c;
	sort(b+1,b+1+m);
	int p=unique(b+1,b+1+m)-(b+1);
	for(int i=1;i<=m;i++)
	{
		int x=lower_bound(b+1,b+1+p,a[i].c)-b;
		h[x]=a[i].c,a[i].c=x;
	}
	sort(a+1,a+1+m,cmp);
	int op=1;
	for(int k=m;k>=1;k--)
	{
		while(op<=m&&a[op].c>=k)
		{
			for(int z=a[op].l;z<=a[op].r;z++)
				for(int l=1;l<=a[op].l;l++)
					for(int r=a[op].r;r<=n;r++)
						g[l][r][z]++;
			op++;
		}
		for(int len=0;len<n;len++)
		{
			for(int i=1;i<=n;i++)
			{
				int j=i+len;
				if(j>n)break;
				int q=0;
				int maxn=0;
				for(int z=i;z<=j;z++)
				{
					int x=dp[i][z-1]+dp[z+1][j]+g[i][j][z]*h[k];
					if(x>=maxn)pre[i][j][k]=z,maxn=x;
				}
				if(maxn>=dp[i][j])pre2[i][j][k]=k,dp[i][j]=maxn;
				else pre2[i][j][k]=pre2[i][j][k+1];
			}
		}
	}
	printf("%lld\n",dp[1][n]);
	print(1,n,1);
	for(int i=1;i<=n;i++)printf("%lld ",ans[i]);
	return 0;
}

---


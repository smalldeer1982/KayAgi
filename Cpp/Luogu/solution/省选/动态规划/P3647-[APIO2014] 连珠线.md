# [APIO2014] 连珠线

## 题目描述

在达芬奇时代，有一个流行的儿童游戏称为连珠线。当然，这个游戏是关于珠子和线的。线是红色或蓝色的，珠子被编号为 $1$ 到 $n$。这个游戏从一个珠子开始，每次会用如下方式添加一个新的珠子：

`Append(w, v)`：一个新的珠子 $w$ 和一个已经添加的珠子 $v$ 用红线连接起来。

`Insert(w, u, v)`：一个新的珠子 $w$ 插入到用红线连起来的两个珠子 $u, v$ 之间。具体过程是删去 $u, v$ 之间红线，分别用蓝线连接 $u, w$ 和 $w, v$。

每条线都有一个长度。游戏结束后，你的最终得分为蓝线长度之和。

给你连珠线游戏结束后的游戏局面，只告诉了你珠子和链的连接方式以及每条线的长度，没有告诉你每条线分别是什么颜色。

你需要写一个程序来找出最大可能得分。即，在所有以给出的最终局面结束的连珠线游戏中找出那个得分最大的，然后输出最大可能得分。


## 说明/提示

【样例描述1】

可以通过如下方式获得 $60$ 分：首先从 $3$ 号珠子开始。

把 $5$ 和 $3$ 连起来。（线长度任意）

在 $3$ 和 $5$ 之间插入 $1$。（线长分别为 $40$ 和 $20$）。

把 $2$ 和 $1$ 用长度为 $10$ 的线连起来。

把 $4$ 和 $1$ 用长度为 $15$ 的线连起来。


【限制与约定】

第一个子任务共 13 分，满足 $1 \leq n \leq 10$。

第二个子任务共 15 分，满足 $1 \leq n \leq 200$。

第三个子任务共 29 分，满足 $1 \leq n \leq 10000$。

第四个子任务共 43 分，满足 $1 \leq n \leq 200000$。


## 样例 #1

### 输入

```
5
1 2 10
1 3 40
1 4 15
1 5 20```

### 输出

```
60```

## 样例 #2

### 输入

```
10
4 10 2
1 2 21
1 3 13
6 7 1
7 9 5
2 4 3
2 5 8
1 6 55
6 8 34```

### 输出

```
140```

# 题解

## 作者：fighter (赞：49)

## 题意

[传送门](https://www.luogu.org/problem/P3647)

## 题解

我们发现，如果一棵树的形态固定了，那么蓝线的方向一定是son[x]-x-fa[x]，那么我们就可以先随便定一个根进行DP。

我们设$f[i][0]$表示以$i$为根的子树中，且$i$不作为蓝线的中点能够得到的最大价值。同理，设$f[i][1]$表示以$i$为根的子树中，$i$作为蓝线的中点能够得到的最大价值。

我们分别对于两种情况分析。$f[i][0]$较为简单，对于一个$j\in son[i]$，设$w_j$为$i,j$之间的边权，要使$i$不作为蓝线的中点，则满足$j$为蓝线中点（即$f[j][1]+w_j$），或之间是红线（即$f[j][0]$）。所以$f[i][0] = \sum\limits_{j\in son[i]}\max(f[j][0], f[j][1]+w_j)$。

然后考虑$i$为中点的情况，显然$i$只能是一条蓝线的中点，所以我们可以枚举这条蓝线连接的儿子（设为$j$），那么其余儿子依旧是按照$f[i][0]$的方式转移，所以我们将$f[i][1]$初始化为$f[i][0]$。对于$j$，我们减去之前的贡献，再加入蓝线的贡献。由于$i$是中点，所以$j$的贡献即为$f[j][0]+w_j$。综上，$f[i][1]=f[i][0]+\max\limits_{j\in son[i]}(f[j][0]+w_j-\max(f[j][0],f[j][1]+w_j))$。

说了这么多，其实都只是在树的结构固定的前提下进行的。当整棵树的结构不确定时，我们就需要通过换根操作统计答案。我们发现换根对于大部分节点并没有影响，于是我们就可以通过一些奇技淫巧进行$O(1)$换根。

我们考虑一个点的儿子变成了父亲会发生什么影响。首先这个儿子的贡献消失了，随之而来的可能是转移方程中的最大值也消失了，所以我们就需要记录次大值（经典套路）。同时当前点会变成儿子对原来的儿子（现在的父亲）产生贡献。

所以我们要在第一次DP中记录一个$dp[i][0/1][j]$表示在$f[i][0/1]$这个状态的统计过程中，不考虑第$j$个儿子得到的答案。对于$dp[i][0][j]$直接从总和中减去；对于$dp[i][1][j]$，维护次大值更新即可。

下面正式开始换根，我们在$dfs$过程中，枚举当前节点$x$的儿子作为整棵树的根，此时值得注意的是，由于换根后，$x$的父亲会变成他的儿子，所以我们并不能直接在$x$和儿子之间换根，而是应该先重新计算$fa[x]$对$x$的贡献，然后再进行换根。具体操作可以看代码，十分容易理解。

## 代码

```cpp
#include <bits/stdc++.h>
#define MAX 500005
#define INF 0x3f3f3f3f
#define c(x) (f[x][0]+cost[i]-max(f[x][0], f[x][1]+len[x]))		//状态转移方程
using namespace std;

int n, cnt;
int head[MAX], vet[MAX], Next[MAX], cost[MAX];

void add(int x, int y, int w){
    cnt++;
    Next[cnt] = head[x];
    head[x] = cnt;
    vet[cnt] = y;
    cost[cnt] = w;
}

int par[MAX], len[MAX];
int f[MAX][2];       //f[i][0]表示i不做中点,f[i][1]表示做中点
vector<int> son[MAX], dp[MAX][2], mx[MAX];
void dfs(int x, int fa){
    f[x][0] = 0, f[x][1] = -INF;
    int mx1 = -INF, mx2 = -INF;
    for(int i = head[x]; i; i = Next[i]){
        int v = vet[i];
        if(v == fa) continue;
        len[v] = cost[i], par[v] = x;
        son[x].push_back(v);
        dfs(v, x);
        f[x][0] += max(f[v][0], f[v][1]+cost[i]);
        if(c(v) > mx1) mx2 = mx1, mx1 = c(v);		//记录最大值和次大值
        else if(c(v) > mx2) mx2 = c(v);
    }
    f[x][1] = f[x][0]+mx1;
    for(int i = head[x]; i; i = Next[i]){
        int v = vet[i];
        if(v == fa) continue;
        dp[x][0].push_back(f[x][0]-max(f[v][0], f[v][1]+cost[i]));
        if(c(v) == mx1){		//通过最大值和次大值计算dp[x][1]
            dp[x][1].push_back(dp[x][0].back()+mx2);
            mx[x].push_back(mx2);
        }
        else{
            dp[x][1].push_back(dp[x][0].back()+mx1);
            mx[x].push_back(mx1);
        }
    }
}

int ans = 0;
void solve(int x){     //换根
    for(int i = 0; i < son[x].size(); i++){
        f[x][0] = dp[x][0][i], f[x][1] = dp[x][1][i];
        if(par[x]){     //重新统计父亲对x的贡献。
            f[x][0] += max(f[par[x]][0], f[par[x]][1]+len[x]);
            f[x][1] = f[x][0] + max(mx[x][i], f[par[x]][0]+len[x]-max(f[par[x]][0], f[par[x]][1]+len[x]));
        }
        ans = max(ans, f[son[x][i]][0]+max(f[x][0], f[x][1]+len[son[x][i]]));
        solve(son[x][i]);
    }
}

int main()
{
    cin >> n;
    int x, y, w;
    for(int i = 1; i < n; i++){
        scanf("%d%d%d", &x, &y, &w);
        add(x, y, w);
        add(y, x, w);
    }
    dfs(1, 0);
    solve(1);
    cout << ans << endl;

    return 0;
}
```



---

## 作者：tommymio (赞：46)

很有意思又偏向套路的换根 $\text{DP}$，考察了选手的模型转化能力。

我们发现，蓝线只会像是这个样子：

![](https://cdn.luogu.com.cn/upload/image_hosting/g8zn09pr.png)

连接 $3,1,2$ 的蓝线是一类，连接 $3,5,6$ 的蓝线是另一类。由于**无论哪类蓝线都只会连接三个点（理解一下）**，我们可以想到一个非常 $\text{Naive}$ 的树形 $\text{DP}$。设 $f_{x,{0/1}}$ 表示 $x$ 连接父亲的蓝边取或不取，按照题意转移即可。

但是这样是有问题的，有这种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/4mfno1f2.png)

上述 $\text{DP}$ 会被这种数据 $\text{hack}$。因为无法判断两棵子树与他们共同的父亲之间是否能够连蓝边。

那么我们来考虑正确的做法。上述做法的正确性之所以不成立，是因为存在 $1,2,3$ 这种连边，我们能不能避免这种连边的出现呢？当然是可以的，我们发现，选择不同的根，只采用 $3,5,6$ 这种方式：父亲到儿子到孙子连蓝边，就能够覆盖所有的取兄弟和他们的父亲的连蓝边的方式，即 $3,1,2$ 这种方式。

这样就有了一个 $O(n^2)$ 的做法，枚举树的根，进行 $\text{DP}$。设 $f_{x,0}$ 为点 $x$ 不为蓝线中点，在 $x$ 的子树内的最大值。$f_{x,1}$ 为点 $x$ 为蓝线中点，在 $x$ 的子树内的最大值，有：

$$
f_{x,0}=\sum_{y\in son_x}\max(f_{y,0},f_{y,1}+w(x,y))
$$

$$
f_{x,1}=f_{x,0}+\max_{y\in son_x}\{f_{y,0}+w(x,y)-max(f_{y,0},f_{y,1}+w(x,y))\}
$$

对于每个根 $rt$，答案即为 $f_{rt,0}$，最后答案为在每个根 $rt$ 意义下的 所有 $f_{rt,0}$ 的最大值。

通过上述 $\text{DP}$ 式，我们能够得到一个固定根意义下的最大值，不妨选这个固定根为 $1$。现在考虑如何快速换根 $rt$ 得到 $rt$ 意义下的 $f_{rt,0}$。自然可以想到换根 $\text{DP}$。

现在重新对 $f$ 的概念强调，并定义新的量。$f_{x,0/1}$ 均为以 $1$ 为根意义下，$x$ 不在 $/$ 在蓝线中点，子树内的最大值。定义 $g_x$ 为**以 $x$ 为根意义下**，$f_{x,0}$ 的值。接下来要叙述 $k_{x,0/1}$ 的概念，配上一张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/msue56ft.png)

上图中被红色虚线圈出的部分就是 $k_{x,0/1}$ 包括的范围，按 $f_{x,0}$ 和 $f_{x,1}$ 的定义式转移。

最后列出 $g,k$ 的转移式：

$$
g_{y,0}=f_{y,0}+\max(k_{x,0},k_{x,1}+w(x,y))
$$

$$
g_{y,1}=g_{y,0}+\max(\max_{i\in son_y}\{f_{i,0}+w(i,y)-\max(f_{i,0},f_{i,1}+w(i,y))\},k_{x,0}+w(x,y)-\max(k_{x,0},k_{x,1}+w(x,y))
$$

$$
k_{x,0}=g_{x,0}-\max(f_{y,0},f_{y,1}+w(x,y))
$$

$$
k_{x,1}=k_{x,0}+\max(\max_{i\in son_x\wedge i\neq y}\{f_{i,0}+w(i,x)-\max(f_{i,0},f_{i,1}+w(i,x))\},k_{fa,0}+w(x,fa)-\max(k_{fa,0},k_{fa,1}+w(x,fa)))
$$

这个过程看上去似乎非常不自然，其实都是换根 $\text{DP}$ 的套路：考虑去掉即将要转移的 $y$ 后，对 $x$ 造成的影响及加上 $x$ 后，对 $y$ 造成的影响。

实现的时候，我们发现上述 $\text{DP}$ 式中有很多重叠的部分，换根时还有一些 $\max$ 的取值可能会取到 $y$ 相关的取值，维护一个相关的最大值和次大值即可。总时间复杂度为 $O(n)$，空间复杂度为 $O(n)$，比楼下奇奇怪怪的 $\text{vector}$ 跑得快/cy

如果看不懂上面的转移式可以看代码（逃

PS:此题 $\text{Luogu}$ 上数据过弱，建议上 [$\text{UOJ}$](https://uoj.ac/problem/105) 上提交本题以确认算法正确性（

**Show the Code**

```cpp
#include<cstdio>
#include<climits>
typedef long long ll;
int cnt=0;
ll mx1[200005],mx2[200005],vg[200005];
ll f[200005][2],g[200005][2],k[200005][2];
int son1[200005],son2[200005];
int h[200005],to[400005],ver[400005],w[400005];
inline int read() {
	register int x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f;
}
inline void add(int x,int y,int z) {
	to[++cnt]=y;
	ver[cnt]=h[x];
	w[cnt]=z;
	h[x]=cnt;
}
inline void swap(int &x,int &y) {int tmp=x;x=y;y=tmp;}
inline void swap(ll &x,ll &y) {ll tmp=x;x=y;y=tmp;}
inline ll max(const ll &x,const ll &y) {return x>y? x:y;}
inline void dfs1(int x,int fa) {
	mx1[x]=mx2[x]=INT_MIN; son1[x]=son2[x]=0;
	for(register int i=h[x];i;i=ver[i]) {
		int y=to[i];
		if(y==fa) continue;
		vg[y]=w[i];dfs1(y,x);
		f[x][0]+=max(f[y][0],f[y][1]+w[i]);
		ll val=f[y][0]+w[i]-max(f[y][0],f[y][1]+w[i]);
		if(mx1[x]<val) {son2[x]=son1[x];mx2[x]=mx1[x];son1[x]=y;mx1[x]=val;}
		else if(mx2[x]<val) {son2[x]=y;mx2[x]=val;}	
	}
	f[x][1]=f[x][0]+mx1[x];
}
inline void dfs2(int x,int fa) {
	for(register int i=h[x];i;i=ver[i]) {
		int y=to[i];
		if(y==fa) continue;
		if(son1[x]==y) {swap(mx1[x],mx2[x]);swap(son1[x],son2[x]);}
		k[x][0]=g[x][0]-max(f[y][0],f[y][1]+w[i]);k[x][1]=k[x][0]+mx1[x];
		if(fa!=-1) {k[x][1]=max(k[x][1],k[x][0]+k[fa][0]+vg[x]-max(k[fa][0],k[fa][1]+vg[x]));}
		g[y][0]=f[y][0]+max(k[x][0],k[x][1]+w[i]);
		if(mx1[x]<mx2[x]) {swap(mx1[x],mx2[x]);swap(son1[x],son2[x]);}
		dfs2(y,x);
	}
}
int main() {
	int n=read(); ll ans=0;
	for(register int i=1;i<n;++i) {int x=read(),y=read(),z=read(); add(x,y,z);add(y,x,z);}
	dfs1(1,-1); g[1][0]=f[1][0]; dfs2(1,-1);
	for(register int i=1;i<=n;++i) ans=max(ans,g[i][0]);
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：cmd2001 (赞：23)

首先我们知道这棵树的形态，一眼DP。

考虑蓝线的性质，显然蓝线在树上是连接连续三个节点的。

这样就有三种情况:连接 一个节点 的 某个孩子->本身->父亲 或者 一个孩子->本身->另一个孩子。

然后胡乱写一个DP，发现并不能过大样例。

因为这种想法定义是有反例的!

考虑下面的这棵树的连边方式，怎样生成连边方式是这样的一棵树？

![](https://cdn.luogu.com.cn/upload/pic/17538.png )

显然是不可能做到的，因为下面的两个叶子中需要有两个根才行，然而我们只能有一个根。

也就是说，确定了根以后，我们的连边方式就只剩下了 一个节点 的 某个孩子->本身->父亲 这一种。

(显然只有使用且仅使用这一种方式能生成可行的树)。

我们令f[i][0/1]表示考虑节点i及节点i的子树，i是否为蓝边的中点，能获得的最大价值。

显然我们有:
f[i][0] = sigma( j : son[i] ) max( f[j][0] , f[j][1] + edge[i->j] ) ,

f[i][1] = sigma( j : son[i] ) max( f[i][0] - max( f[j][0] , f[j][1] + edge[i->j] ) + f[j][0] + edge[i->j] )。

这样我们就能枚举根然后O(n^2)暴力DP了。

仔细观察这个转移方程，显然我们可以换根。

我们设g[i][j][0/1]表示节点i不考虑孩子j的f[i][0/1]。
我们有:

g[i][j][0] = sigma( t : son[i] && t != j ) max( f[t][0] , f[t][1] + edge[i->t] ) ,

g[i][j][1] = sigma( t : son[i] && t != j ) max( g[i][j][0] - max( f[t][0] , f[t][1] + edge[i->t] ) + f[t][0] + edge[i->t] )。

显然有:

g[i][j][0] = f[i][0] -  max( f[j][0] , f[j][1] + edge[i->j] )。

对于g[i][j][1]，我们可以把后面的那一堆东西提出来，那是一个仅与变量t相关的表达式。我们维护这个表达式的前缀max和后缀max就好了。

换根的话，我们就把某个节点的父亲的g[i][j][0/1]当做j的一个孩子去处理就行了。

代码:
```cpp
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;
const int maxn=2e5+1e2;
const int inf=0x3f3f3f3f;

int s[maxn],t[maxn<<1],nxt[maxn<<1],l[maxn<<1];
vector<int> son[maxn],pef[maxn],suf[maxn],len[maxn];
int f[maxn][2],ans;

inline void addedge(int from,int to,int len) {
    static int cnt = 0;
    t[++cnt] = to , l[cnt] = len ,
    nxt[cnt] = s[from] , s[from] = cnt;
}
inline void dfs1(int pos,int fa) {
    f[pos][0] = 0 , f[pos][1] = -inf;
    for(int at=s[pos];at;at=nxt[at]) if( t[at] != fa ) son[pos].push_back(t[at]) , len[pos].push_back(l[at]);
    for(unsigned i=0;i<son[pos].size();i++) {
        dfs1(son[pos][i],pos) , f[pos][0] += max( f[son[pos][i]][0] , f[son[pos][i]][1] + len[pos][i] );
        pef[pos].push_back(f[son[pos][i]][0]-max(f[son[pos][i]][0],f[son[pos][i]][1]+len[pos][i])+len[pos][i]) ,
        suf[pos].push_back(f[son[pos][i]][0]-max(f[son[pos][i]][0],f[son[pos][i]][1]+len[pos][i])+len[pos][i]) ;
    }
    for(unsigned i=0;i<son[pos].size();i++) f[pos][1] = max( f[pos][1] , f[pos][0] + pef[pos][i] );
    for(unsigned i=1;i<son[pos].size();i++) pef[pos][i] = max( pef[pos][i] , pef[pos][i-1] );
    for(int i=(signed)son[pos].size()-2;i>=0;i--) suf[pos][i] = max( suf[pos][i] , suf[pos][i+1] );
}
inline void dfs2(int pos,int ffa0,int ffa1,int lfa) {
    f[pos][1] += max( ffa0 , ffa1 + lfa ) , f[pos][0] += max( ffa0 , ffa1 + lfa ) , f[pos][1] = max( f[pos][1] , f[pos][0] + ffa0 - max( ffa0 , ffa1 + lfa ) + lfa );
    ans = max( ans , f[pos][0] );
    for(unsigned i=0;i<son[pos].size();i++) {
        int fnow0 = f[pos][0] - max( f[son[pos][i]][0] , f[son[pos][i]][1] + len[pos][i] );
        int delta = ffa0 - max( ffa0 , ffa1 + lfa ) + lfa;
        if( i != 0 ) delta = max( delta , pef[pos][i-1] );
        if( i != son[pos].size() - 1 ) delta = max( delta , suf[pos][i+1] );
        dfs2(son[pos][i],fnow0,fnow0+delta,len[pos][i]);
    }
}

int main() {
    static int n;
    scanf("%d",&n);
    for(int i=1,a,b,l;i<n;i++) scanf("%d%d%d",&a,&b,&l) , addedge(a,b,l) , addedge(b,a,l);
    dfs1(1,-1) , dfs2(1,0,-inf,-inf) , printf("%d\n",ans);
    return 0;
}
```

---

## 作者：MCAdam (赞：21)

既然题目都要我们反着推回去了，首先考虑怎样构造才能合法

- 两条蓝色的边一定是连在一起的

这个很显然，因为就是用两条蓝边替代一条红边

- 蓝边的顺序

$(fa[x],x),(x,son[x])$这样的合法性显然

因为$(x,son1[x]),(x,son2[x])$一定是：先把$(son1[x],son2[x])$连起来，然后再把$x$插入到中间去形成的。所以如果两个这样的结构没有存在祖孙关系的话，那么就肯定是无法合成出来的，不然的话合并这种结构所在的两个子树一个根是不够的

但好像这波分析并没有什么用？仍然会存在两种结构同时存在的情况，并没有办法快速判断结构的祖孙关系。但上面得到了一个很重要的结论：

**“三角形”的结构一定要满足有祖孙关系**

然后想到，树根是哪一个对答案没有任何影响。**那么对于某一个根$p$，存在具有祖孙关系的三角形结构，一定可以转换成另外一个根$q$，使得全都是$(fa[x],x,son[x])$这种结构**

所以考虑对于每一个根，都计算出这样的答案，那么就转变为一个换根DP了

不妨假设$1$为根，怎么转移呢？

首先有一个很显然的贪心，最后整棵树肯定不存在还能涂成蓝边的结构，不然肯定涂上会更优，也就是说不存在某个点$p$，其父亲边和某一个儿子边都没有染色

所以不妨设$f[p][0/1]$表示$p$是否为蓝链中点的最大价值（不算上父亲边），之所以不用考虑$p$为蓝链最下端的情况，是因为这完全不是$p$子树内的情况了

注意一个点不可能既是顶端又是中点，因为这一定无法构造出来

因为$p$不是中点，所以$p$和任意一个$q$之间可以是蓝边或者红边

$\displaystyle f[p][0]=\sum_{q\in son(p)}\max(f[q][0],f[q][1]+dis[p][q])$

对于$p$为蓝链中点的情况，只能选取一个儿子作为$p$连下去蓝边的一个端点，其他的儿子还是按照$f[][0]$的方式转移

$\displaystyle f[p][1]=f[p][0]+\max_{q\in son(p)}\{f[q][0]+dis[p][q]-\max(f[q][0],f[q][1]+dis[p][q])\}$

然后就是简单的换根了

推荐一种换根DP的写法：

假设枚举$p$的儿子$q$

1、首先去掉$q$对$p$答案的影响，看到最大记次大，更新$p$

把原DP方程式中，所有的$'+'$改为$'-'$（注意这里带引号）

2、然后把$p$当做$q$的另外一个儿子，更新$q$

把原DP方程式中，儿子和父亲的位置交换

3、将$p$的信息回溯

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
using namespace std;
const int N=2e5+10;
int tot,ans;
int fir[N],f[N][2],g[N][2],maxn[N][2];
struct edge
{
	int to;
	int dis;
	int nxt;
}e[2*N];
inline void add(int x,int y,int z)
{
	e[++tot].to=y; e[tot].dis=z; e[tot].nxt=fir[x]; fir[x]=tot;
	e[++tot].to=x; e[tot].dis=z; e[tot].nxt=fir[y]; fir[y]=tot;
}
inline void dfs1(int p,int fa)
{
	for(int i=fir[p];i;i=e[i].nxt)
	{
		int q=e[i].to;
		if(q==fa) continue;
		dfs1(q,p);
		f[p][0]+=max(f[q][0],f[q][1]+e[i].dis);
		f[p][1]+=max(f[q][0],f[q][1]+e[i].dis);
		int val=f[q][0]+e[i].dis-max(f[q][0],f[q][1]+e[i].dis);
		if(val>maxn[p][0]) maxn[p][1]=maxn[p][0],maxn[p][0]=val;
		else maxn[p][1]=max(maxn[p][1],val);
	}
	f[p][1]+=maxn[p][0];
}
inline void dfs2(int p,int fa)
{
	ans=max(ans,f[p][0]);
	int f0=f[p][0],f1=f[p][1],maxn0=maxn[p][0],maxn1=maxn[p][1];
	for(int i=fir[p];i;i=e[i].nxt)
	{
		int q=e[i].to;
		if(q==fa) continue;
		f[p][0]-=max(f[q][0],f[q][1]+e[i].dis);
		f[p][1]-=max(f[q][0],f[q][1]+e[i].dis);
		int val1=f[q][0]+e[i].dis-max(f[q][0],f[q][1]+e[i].dis);
		if(val1==maxn[p][0]) f[p][1]+=maxn[p][1]-maxn[p][0];
		
		f[q][0]+=max(f[p][0],f[p][1]+e[i].dis);
		f[q][1]+=max(f[p][0],f[p][1]+e[i].dis);
		f[q][1]-=maxn[q][0];
		int val2=f[p][0]+e[i].dis-max(f[p][0],f[p][1]+e[i].dis);
		if(val2>maxn[q][0]) maxn[q][1]=maxn[q][0],maxn[q][0]=val2;
		else maxn[q][1]=max(maxn[q][1],val2);
		f[q][1]+=maxn[q][0];
		dfs2(q,p);
		f[p][0]=f0,f[p][1]=f1;
		maxn[p][0]=maxn0,maxn[p][1]=maxn1;
	}
}
int main()
{
	int n,a,b,c;
	scanf("%d",&n);
	for(int i=1;i<n;i++)
	{
		scanf("%d%d%d",&a,&b,&c);
		add(a,b,c);
	}
	memset(maxn,~0x3f,sizeof(maxn));
	dfs1(1,0),dfs2(1,0);
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：ctj12461 (赞：14)

这里给出一种无需换根的 DP 思路。

#### Part 1

我们从结点的添加方式入手，可以把结点分为三类：

- 初始的结点，这种结点只有一个
- 通过 Append 添加的结点，以下简称 A 类结点
- 通过 Insert 添加的结点，以下简称 I 类结点

不换根的思路核心就在于保证转移时的过程符合结点的添加规则。为了方便，我们可以给每条线定向。同时假设 $1$ 为根，$x$ 为当前结点，$y$ 为 $x$ 的一个儿子结点，$fa$ 为 $x$ 的父亲结点。很显然接下来可以分 $6$ 类讨论：

1. 若 $x$ 为初始结点，则其子结点、$fa$ 都应该连向  $x$
2. 若 $x$ 为 A 类结点
   1.  $x$ 向 $fa$ 连一条红线，子结点连向 $x$
   2. $x$ 向其中一个子结点 $y$ 连一条红线，其他子结点以及 $fa$ 连向  $x$

3. 若 $x$ 为 I 类结点
   1. $x$ 取代一个子结点 $y$ 连向 $fa$ 的红线，然后换成蓝线
   2. $x$ 取代两个个子结点 $y_1$ 和 $y_2$ 之间的红线，然后换成蓝线
   3. $x$ 取代 $fa$ 连向一个子结点 $y$ 的红线，然后换成蓝线

上面的分类讨论中的“连向”可以看成 Append 或 Insert，根据题意计算就可以了。

#### Part 2

接下来根据分类讨论设出状态以及写出方程：

```cpp
long long f[MAXN][6];

/**
 * f[x][0]: x is initial
 * f[x][1]: x -> fa
 * f[x][2]: x -> y
 * f[x][3]: y -> x -> fa
 * f[x][4]: y1 -> x -> y2
 * f[x][5]: fa -> x -> y
 */
```

设 $cont(x)$ 表示 $x$ 向其父结点连线的贡献，则 $cont(x)=\max\{f[x][1],f[x][3]+len(x,fa(x))\}$。
$$
f[x][0]=\sum_{y\in son(x)}cont(y)\\
f[x][1]=\sum_{y\in son(x)}cont(y)\\
f[x][2]=\sum_{y\in son(x)}cont(y)+\max_{y\in son(x)}\{\max\{f[y][0], f[y][2], f[y][4], f[y][5] + len(y,x)\}-cont(y)\}\\
f[x][3]=\sum_{y\in son(x)}cont(y)+\max_{y\in son(x)}\{f[y][1]+len(y,x)-cont(y)\}\\
f[x][4]=\sum_{y\in son(x)}cont(y)+\\\max_{y_1,y_2\in son(x)\wedge y_1\ne y_2}\{
f[y_1][1]+len(y_1,x)-cont(y_1)+\max\{f[y_2][0], f[y_2][2], f[y_2][4]\}+len(y_2,x)-cont(y_2)\}\\
f[x][5]=\sum_{y\in son(x)}cont(y)+\max_{y\in son(x)}\{\max\{f[y][0], f[y][2], f[y][4]\}+len(y,x)-cont(y)\}
$$
上面的转移都可以看成先从子结点按照 $cont(x)$ 转移，在钦定某个结点按照特定的方式转移，记录下最优的差值在加到 $f$ 里即可。$f[x][4]$ 有两个变量，可以考虑枚举其中一个，用 `std::multiset<T>` 维护另外一个的最值即可。

时间复杂度 $O(n \log_2 n)$。

#### Part 3

```cpp
#include <iostream>
#include <vector>
#include <set>
using namespace std;

constexpr int MAXN = 200000 + 10;
constexpr int INFINITY = 0x7fffffff;

int n;
vector<pair<int, int>> tree[MAXN];
long long f[MAXN][6];

/**
 * f[x][0]: x is initial
 * f[x][1]: x -> fa
 * f[x][2]: x -> y
 * f[x][3]: y -> x -> fa
 * f[x][4]: y1 -> x -> y2
 * f[x][5]: fa -> x -> y
 */

void link(int x, int y, int l) {
    tree[x].push_back({y, l});
    tree[y].push_back({x, l});
}

void dfs(int x, int fa) {
    if (tree[x].size() == 1 && fa != 0) {
        f[x][2] = f[x][3] = f[x][4] = f[x][5] = -INFINITY;
        return;
    }

    long long sum = 0, delta[4] = {-INFINITY, -INFINITY, -INFINITY, -INFINITY};
    multiset<long long> val;
    val.insert(-INFINITY);

    for (auto [y, l] : tree[x]) {
        if (y == fa)
            continue;

        dfs(y, x);

        long long cont = max(f[y][1], f[y][3] + l);
        sum += cont;

        for (int i = 0; i < 6; ++i)
            f[x][i] += cont;

        delta[0] = max(delta[0], max(max(max(f[y][0], f[y][2]), f[y][4]), f[y][5] + l) - cont);
        delta[1] = max(delta[1], f[y][1] + l - cont);
        delta[3] = max(delta[3], max(max(f[y][0], f[y][2]), f[y][4]) + l - cont);
        val.insert(f[y][1] + l - cont);
    }

    for (auto [y, l] : tree[x]) {
        if (y == fa)
            continue;

        int cont = max(f[y][1], f[y][3] + l);
        val.erase(val.find(f[y][1] + l - cont));
        delta[2] = max(delta[2], *val.rbegin() + max(max(f[y][0], f[y][2]), f[y][4]) + l - cont);
        val.insert(f[y][1] + l - cont);
    }

    f[x][2] += delta[0];
    f[x][3] += delta[1];
    f[x][4] += delta[2];
    f[x][5] += delta[3];

    for (int i = 0; i < 6; ++i)
        if (f[x][i] < 0)
            f[x][i] = -INFINITY;
}

int main() {
    ios::sync_with_stdio(false);
    cin >> n;

    if (n == 1) {
        cout << 0 << endl;
        return 0;
    }

    for (int i = 1; i < n; ++i) {
        int x, y, l;
        cin >> x >> y >> l;
        link(x, y, l);
    }

    dfs(1, 0);
    cout << max(max(f[1][0], f[1][2]), f[1][4]) << endl;
    return 0;
}
```



---

## 作者：conprour (赞：9)

# 前言
[【题目传送门】](https://www.luogu.com.cn/problem/P3647 "传送门")

[【博客园传送门】](https://www.cnblogs.com/conprour/p/15473439.html)

对于换根的理解应该和其他题解不一样，求过。
# 题解
首先分析题目简化题意：给定一棵树，从里面选出若干个“三连点”的边，使边权和最大。其中“三连边”有如下图两种形态：$3-1-2$ 和 $3-5-6$


![](https://cdn.luogu.com.cn/upload/image_hosting/g8zn09pr.png)

（图源：tommymio）

一开始我想到一种 DP：$dp(u,0/1/2)$ 表示 $u$ 节点的子树内可以向下延伸的边数为 $0/1/2$ 时的最大值，希望通过类似容斥解决形如 $3-1-2$ 的情况，但实际不太可行（也可能只是我没做出来）。

换一种思路，$dp(u,0/1)$ 表示 $u$ 是/不是蓝线中点时，子树**内**答案的最大值。

* 如果 $u$ 不是中点，那对于一个儿子 $v$，$v$ 可以是中点也可以不是中点，就有转移式：$dp(u,0)=\max\{dp(v,1)+w,dp(v,0)\}$
* 如果 $u$ 是中点，其实是对于它的一个儿子，$u$ 是中点，进行“$u$ 是中点”的转移，即 $dp(v,0)+w$；但是对于其他儿子 $u$ 依旧不是中点，所以转移同上。
综合一下就是: $dp(u,1)=dp(u,0)+\max\{dp(v,0)+w-\max\{dp(v,1)+w,dp(v,0)\}\}$

## 换根！
但是这样做只考虑了竖着的“三连点”，可以发现通过不断换根的位置，可以使树里所有 $3-1-2$ 形态的选法都变成竖着的。

不能枚举根，所以考虑换根。

记录 $up(u,0/1)$ 表示 $u$ 是/不是蓝线中点时，子树**外**答案的最大值。（换根 DP 都这么设，我这里的子树外是指**刨去子树**的其他部分）。

先看图：

![image](https://cdn.luogu.com.cn/upload/image_hosting/paku4ryt.png)

考虑当前从点 $u$ 向下走到儿子 $v$，更新 $up(v,0/1)$，显然是从红色部分和蓝色部分来更新。其中蓝色部分是和 $up(u)$ 有关，红色部分是和 $dp(u),dp(v)$ 有关。
* 对于**红色**部分，相当于从 $dp(u)$ 里撤销 $v$ 子树的贡献，根据前面的转移可以发现贡献是 $dp(u,0)-\max\{dp(v,0),dp(v,1)+w\}$。**注意这里先用 $u$ 不是中点的情况转移，因为 $u$ 是中点的情况只是相当于多选了一个儿子与他相连（换根相当于此时把 $v$ 看成根）**。

现在考虑加上 $u$ 是中点的情况，此时应该从红色部分里面选出当初转移加上的 $\max\{dp(v,0)+w-\max\{dp(v,1)+w,dp(v,0)\}\}$，然而此时子树 $v$ 已经被删掉，所以最大值可能不存在，所以在第一个 DFS 转移时应该同时记录转移加上的**最大值和次大值**，同时原来的父亲 $u$ 也可以向 $v$ 进行中点的连边转移，而这个贡献是 $up(u,1)-up(u,0)$。
* 对于**蓝色**部分，比较简单，贡献就是 $up(u,0)+trans$。其中 $trans$ 为转移变量。具体地，看下面的总转移式。

**总转移式**（太复杂就贴在代码块里了）：
```cpp
up[v][0]=dp[u][0]-max(dp[u][0],dp[u][1]+w)+up[u][0]+max(0ll,trans+w);
up[v][1]=dp[u][0]-max(dp[u][0],dp[u][1]+w)+up[u][0]+w;
```
稍微解释一下为什么可以都从 $u$ 不作为中点（即第二维为 $0$）的情况转移，因为 $\max\{0,trans+w\}>0$ 就意味着从 $up(u,1)$ 或者x一个其他的儿子 $v$ 的 $dp(v,1)$ 转移过来。

最后有一点细节要注意，对于叶子节点作为中点的情况初始化赋值成极小值，表示不合法方案。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define ll long long
const int INF = 0x3f3f3f3f,N = 2e5+10;
inline ll read()
{
	ll ret=0;char ch=' ',c=getchar();
	while(!(c>='0'&&c<='9')) ch=c,c=getchar();
	while(c>='0'&&c<='9') ret=(ret<<1)+(ret<<3)+c-'0',c=getchar();
	return ch=='-'?-ret:ret;
}
int n,ecnt=-1,head[N]; 
inline void init()
{
	memset(head,-1,sizeof(head));
	ecnt=-1;
}
struct edge
{
	int nxt,to,w;
}a[N<<1];
inline void add_edge(const int x,const int y,const int w)
{
	a[++ecnt]=(edge){head[x],y,w};
	head[x]=ecnt;
}
int dp[N][2],up[N][2];
int f[N][2],hson[N];
void dfs1(const int u,const int fa)
{
	int maxn=-2e9,cnt_son=0;
	for(int i=head[u];~i;i=a[i].nxt)
	{
		int v=a[i].to;
		if(v==fa) continue; 
		cnt_son++;
		dfs1(v,u);
		int tmp=max(dp[v][0],dp[v][1]+a[i].w);
		int trans=dp[v][0]+a[i].w-max(dp[v][0],dp[v][1]+a[i].w);
		dp[u][0]+=tmp;
		if(maxn<trans)
		{
			f[u][1]=maxn;
			hson[u]=v;
			maxn=trans;
		}
		else f[u][1]=max(f[u][1],trans);
	}
	dp[u][1]=dp[u][0]+maxn;
	if(!cnt_son) dp[u][1]=-2e9;//特判叶子为不合法 
	f[u][0]=maxn;//由于这里的赋值，maxn要初始化成-INF而不能是0，用来表示这种转移不合法 
}
void dfs2(const int u,const int fa)
{
	for(int i=head[u];~i;i=a[i].nxt)
	{
		int v=a[i].to;
		if(v==fa) continue;
		int trans=up[u][1]-up[u][0];//trans是什么意思？下面为什么取max？ 
		//A:相当于多了一个父亲连边的情况，和原来儿子连边的情况取max，为下面转移做准备 
		if(hson[u]==v) trans=max(trans,f[u][1]);
		else trans=max(trans,f[u][0]);
		
		int tmp=max(dp[v][0],dp[v][1]+a[i].w);
		
		up[v][0]=dp[u][0]-tmp+up[u][0]+max(0ll,trans+a[i].w);
		up[v][1]=dp[u][0]-tmp+up[u][0]+a[i].w;
		dfs2(v,u);
	}
}
signed main()
{
	memset(head,-1,sizeof(head));
	n=read();
	for(int i=1;i<n;i++)
	{
		int u=read(),v=read(),w=read();
		add_edge(u,v,w),add_edge(v,u,w);
	}
	dfs1(1,-1); 
	up[1][0]=0,up[1][1]=-2e9;//特判叶子为不合法 
	dfs2(1,-1);
	int ans=0;
	for(int i=1;i<=n;i++)	
		ans=max(ans,max(dp[i][0]+up[i][0],dp[i][1]+up[i][1]));
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：18Michael (赞：8)

## 题解

这里提供一种与其他题解不太相同的做法。

首先最后的树中只可能有这两种蓝线。

![](https://cdn.luogu.com.cn/upload/image_hosting/drd66woy.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/3jjdk6xd.png)

其次如果把一个为蓝线端点的点当作根，那就只有第一种情况。

因此一个做法是，枚举每个点为根时，根据第一种情况进行树形 dp。

具体的，设 $w_{i,j}$ 表示 $i,j$ 之间连线的权值，$f_{i,0/1}$ 表示 $1$ 为根时 $i$ 的子树中，$i$ 是/不是蓝线中点时答案的最大值。

$f_{i,0}=\underset{v\in son_i}{\sum}\max(f_{v,0},f_{v,1}+w_{i,v})$

$f_{i,1}=f_{i,0}+\underset{v\in son_i}{\max}(f_{v,1}+w_{i,v}-f_{v,0})$

接下来进行换根操作。

具体的，设 $j$ 为 $i$ 的某个儿子，$dp_{i,0/1,j}$ 表示 $1$ 为根时 $i$ 的子树中，不考虑 $j$ 的子树，$i$ 是/不是蓝线中点时答案的最大值，$g_{i,0/1}$ 表示 $1$ 为根时整棵树中，不考虑 $i$ 的子树，$i$ 是/不是蓝线中点时答案的最大值。

答案即为 $f_{i,0}+g_{i,0}$ 的最大值。

$dp_{i,0,j}=\underset{v\in son_i,v\neq j}{\sum}\max(f_{v,0},f_{v,1}+w_{i,v})$

$dp_{i,1,j}=dp_{i,0,j}+\underset{v\in son_i,v\neq j}{\max}(f_{v,1}+w_{i,v}-f_{v,0})$


$g_{j,0}=\max(g_{i,0}+dp_{i,0,j},\max(g_{i,1}+dp_{i,0,j},g_{i,0}+dp_{i,1,j})+w_{i,j}$

$g_{j,1}=g_{i,0}+dp_{i,0,j}+w_{i,j}$

具体实现用 vector 和最大次大值维护一下即可 $O(1)$ 换根。

## Code
```cpp
#include<cstdio>
#include<vector>
#define inf 0x3f3f3f3f
using namespace std;
int n,edge_t=0,ans=0;
int la[200002]={},mx[200002],sec[200002];
int f[200002][2],g[200002][2];
vector<int> dp[200002][2];
struct aaa
{
	int to,nx,val;
}edge[400002];
inline int max(int x,int y)
{
	return x>y? x:y;
}
inline void add_edge(int x,int y,int z)
{
	edge[++edge_t]=(aaa){y,la[x],z},la[x]=edge_t;
	edge[++edge_t]=(aaa){x,la[y],z},la[y]=edge_t;
}
inline void dfs(int x,int fa)
{
	mx[x]=sec[x]=-inf,f[x][0]=0;
	for(int i=la[x],v,w,w1;i;i=edge[i].nx)
		if((v=edge[i].to)!=fa)
		{
			dp[x][0].push_back(0),dp[x][1].push_back(0),dfs(v,x),f[x][0]+=(w1=max(f[v][0],f[v][1]+edge[i].val));
			if((w=f[v][0]+edge[i].val-w1)>mx[x])sec[x]=mx[x],mx[x]=w;else if(w>sec[x])sec[x]=w;
		}
	f[x][1]=f[x][0]+mx[x];
}
inline void dfs1(int x,int fa)
{
	int t=0;
	for(int i=la[x],v;i;i=edge[i].nx)
		if((v=edge[i].to)!=fa)
		{
			dp[x][0][t]=dp[x][1][t]=f[x][0]-max(f[v][0],f[v][1]+edge[i].val),dfs1(v,x);
			if(mx[x]==f[v][0]+edge[i].val-max(f[v][0],f[v][1]+edge[i].val))dp[x][1][t]+=sec[x];else dp[x][1][t]+=mx[x];
			++t;
		}
}
inline void dfs2(int x,int fa)
{
	int t=0;ans=max(ans,f[x][0]+g[x][0]);
	for(int i=la[x],v;i;i=edge[i].nx)
		if((v=edge[i].to)!=fa)
			g[v][0]=max(g[x][0]+dp[x][0][t],max(g[x][1]+dp[x][0][t],g[x][0]+dp[x][1][t])+edge[i].val),g[v][1]=g[x][0]+dp[x][0][t]+edge[i].val,dfs2(v,x),++t;
}
int main()
{
	g[1][0]=0,g[1][1]=-inf,scanf("%d",&n);
	for(int i=1,x,y,z;i<n;++i)scanf("%d%d%d",&x,&y,&z),add_edge(x,y,z);
	dfs(1,0),dfs1(1,0),dfs2(1,0),printf("%d",ans);
	return 0;
}
```

---

## 作者：Tony_Peter (赞：6)

[先给自己的博客打个广告](https://www.cnblogs.com/THWZF/p/11598904.html)

好的这道题目我在换根DP的部分卡了一个世纪……所以设状态真的很重要，我因为状态设的不好，然后换根的时候就很复杂QAQ

我来讲一下一个[学长](https://www.cnblogs.com/yanshannan/p/9152983.html)的做法叭QwQ

最后的连接情况是一棵树，首先我们要发现两个性质，就是在树中蓝线一定是连接在父子之间，并且连续的一段蓝线一定为偶数。

因为蓝线是删除了一条红线之后加入的，所以不可能存在类似下左图这种形状的连接方式，下右图这种连接方式才是合法的

![](https://img2018.cnblogs.com/blog/1558007/201909/1558007-20190927165526697-2064453855.png)![](https://img2018.cnblogs.com/blog/1558007/201909/1558007-20190927165654557-61546578.png)

然后因为每次添加两根蓝线(我们称这两根蓝线为一组)，所以显然连续的蓝线数量必须是偶数。

总体思路是设1为根先DP一遍，然后换根，重要的是如何设状态可以在换根的时候方便转移。

我们设$f[x]$表示以$x$为根的子树的最大分数，注意此时这个子树可以单独出来，即子树中的蓝线数量为偶数。

$d[x][0]$结构体记录与$x$相连的，以$x$为根的子树中的边中最大的边的值和这条边连接的$x$的儿子，$d[x][1]$记录次大值及对应的儿子。当然记录的值保证更优，即记录下的儿子$y$在下左图的连接方式比下右图的连接方式更优。

![](https://img2018.cnblogs.com/blog/1558007/201909/1558007-20190927171004364-1607342019.png)![](https://img2018.cnblogs.com/blog/1558007/201909/1558007-20190927171051075-1965127605.png)

转移见代码及注释

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#define g() getchar()
#define rg register
#define go(i,a,b) for(rg int i=a;i<=b;i++)
#define back(i,a,b) for(rg int i=a;i>=b;i--)
#define db double
#define ll long long
#define il inline
#define pf printf
#define mem(a,b) memset(a,b,sizeof(a))
#define E(i,x) for(rg int i=hd[x];i;i=e[i].nxt)
#define t(i) e[i].to
#define w(i) e[i].w
using namespace std;
int fr(){
    int w=0,q=1;
    char ch=g();
    while(ch<'0'||ch>'9'){
        if(ch=='-') q=-1;
        ch=g();
    }
    while(ch>='0'&&ch<='9') w=(w<<1)+(w<<3)+ch-'0',ch=g();
    return w*q;
}
const int N=200002;
const int INF=1e9+7;
int n,ed,hd[N],f[N],ans;
struct edge{
    int nxt,to,w;
}e[N<<1];
struct node{
    int frm,v;
}d[N][2];
il void build(rg int u,rg int v,rg int w){
    e[++ed]=(edge){hd[u],v,w};hd[u]=ed;
    swap(u,v);
    e[++ed]=(edge){hd[u],v,w};hd[u]=ed;
    return;
}
il void update(rg int x,rg int y,rg int w){
    if(w>=d[x][0].v) d[x][1]=d[x][0],d[x][0]=(node){y,w};
    else if(w>d[x][1].v) d[x][1]=(node){y,w};
    return;
}
il void dp(rg int x,rg int fa){
    d[x][0].v=d[x][1].v=-INF;f[x]=0;
    E(i,x){
        if(t(i)==fa) continue;
        dp(t(i),x);
        rg int as=max(f[t(i)],f[t(i)]+d[t(i)][0].v+w(i));//选择更优的连接方式
        f[x]+=as;update(x,t(i),f[t(i)]+w(i)-as);
        //这里的update有一个很巧妙的转化来判断那种连接方式更优
    }    return;
}
il void dfs(rg int x,rg int fa){
    ans=max(ans,f[x]);
    E(i,x){
        if(t(i)==fa) continue;
        node d0=d[t(i)][0],d1=d[t(i)][1];//记录原来的值
        rg int t1=f[t(i)],t2=max(t1,t1+d[t(i)][0].v+w(i));//找原来是怎么连接的
        rg int f1=f[x]-t2,f2=(d[x][0].frm==t(i));//特判一下特殊情况
        rg int as=max(f1,f1+d[x][f2].v+w(i));//把原本的父亲变为儿子连上去
        f[t(i)]+=as;update(t(i),x,f1+w(i)-as);//更新d数组的值
        dfs(t(i),x);
        f[t(i)]=t1;d[t(i)][0]=d0;d[t(i)][1]=d1;//还原原来的值
    }
    return;
}
int main(){
    //freopen("1.in","r",stdin);
    //freopen("1.out","w",stdout);
    n=fr();
    go(i,1,n-1){
        rg int u=fr(),v=fr(),w=fr();
        build(u,v,w);
    }
    dp(1,0);ans=-INF;dfs(1,0);
    pf("%d\n",ans);
    return 0;
}
```


---

## 作者：chenxia25 (赞：5)

**[Portal](https://www.luogu.com.cn/problem/P3647)**

首先它从游戏开始到结束，是始终只有一个连通块的。对于连红边，那就直接连就可以了。对于连蓝边，我们首先需要找到一对有红边直接相连的点，然后拆散它们把新点插进去，然后仍然是一个连通块。稍微等价理解一下，发现其实就是一次连红边是从当前连通块伸出去一个点；而连蓝边肯定是一下就有两条，我们把这次蓝边所对应的红边与这次连蓝边看作一个整体，它可以看成从当前连通块伸出去一个长度为 $2$ 的链，其中边是蓝色的。

于是我们可以钦定一个点为起始点，把给定树看作以它为根。那么显然在往下伸出去的时候，一口清伸出去的长度为 $2$ 的链只可能是两端是爷孙关系，而不可能是兄弟关系了。好了！这样就很好 DP 了。

显然一个点只可能作为链的中心 $0\sim 1$ 次。那么我们考虑 $dp_{i,0/1}$ 表示子树 $i$ 内的蓝边最大和，如果第二维为 $1$ 的话表示 $i$ 是一条链的中心（它下面有一条边与通向爸爸的边配对）。转移的话，如果为 $0$ 那么所有儿子都必须是下面剩、边选或下面不剩、边不选，取个 $\max$ 加起来即可，不需要有什么顾虑；为 $1$ 的话就必须有且只有一个儿子是下面不剩、边选，找 $\Delta$ 最大的那个减了加上即可。

然后套路的换根即可。这个求和可逆，不用烦；而求 $\Delta$ 的 $\max$ 可以直接无脑的维护一个 `set` 添加删除即可，复杂度线性对数。然而发现在换根的过程中，一个点的 `set` 只会被连续删除 $1$ 次元素，于是实时维护最大值和次大值即可线性，对应的也麻烦一点。

**_[code](https://www.luogu.com.cn/paste/5eluputz)_**

---

## 作者：resftlmuttmotw (赞：4)

我$dp$果然太菜了


### 思路


最先添加了一个点$u$

然后


```cpp
Append(w, v)：一个新的珠子 w 和一个已经添加的珠子 v 用红线连接起来。

Insert(w, u, v)：一个新的珠子 w 插入到用红线连起来的两个珠子 u, v 之间。具体过程是删去 u, v 之间红线，分别用蓝线连接 u, w 和 w, v。
```

只有这两种操作

所以对于最后得到的树上蓝线的部分只能是父亲$->$当前点$->son$

这样的话就方便定义状态了

我们用$f[x][1]$表示$x$为当前点时它所在的子树最长蓝线

类似地，我们用$f[x][0]$表示$x$为父亲 或 $son$或根本不连蓝线时（既它不是当前点）它所在的子树最长蓝线

$$f[x][0]=\displaystyle\sum_{v\in{son[x]}}max(f[v][0],f[v][1]+w_{x->v})$$

$f[x][1]$稍微有点麻烦

$$f[x][1]=f[x][0]-max(f[v][1]+w_{x->v},f[v][0])+f[v][0]+w_{x->v}$$

理解：由于$x$为当前点 所以它至多可以与一个儿子连蓝边（当然选最大的啊）

这里的最大的不是指$w_{x->v}$最大 而是指与哪一个儿子连边的值最大（$f[x][1]$最大）

然后考虑换根

### 换根


换跟时有一个跟着第一次操作的处理

```cpp
inline void dfs(int x,int fa)
{
	f[x][0] = 0,f[x][1] = -inf;
	int max1,max2;
	max1 = max2 = -inf;
	for(reg i = head[x];i;i = edge[i].next)
	{
		int v = edge[i].v,w = edge[i].w;
		if(v == fa) continue;
		father[v] = x,len[v] = w;
		son[x].push_back(v);
		dfs(v,x);
		f[x][0] += max(f[v][0],f[v][1] + w);
		int pre = -max(f[v][0],f[v][1] + w) + f[v][0] + w;
		if(pre > max1) max2 = max1,max1 = pre;
		else if(pre > max2) max2 = pre;//记录最大值以及次大值 
	}
	f[x][1] = f[x][0] + max1;
   	//这以上是以1为根的
	//	f[x][1] = f[x][0] - max(f[v][0],f[v][1] + w) + f[v][0] + w;
	//这里是上面说的处理
	for(reg i = head[x];i;i = edge[i].next)
	{
		int v = edge[i].v,w = edge[i].w;
		if(v == fa) continue;
		dp[x][0].push_back(f[x][0] - max(f[v][0],f[v][1] + w));
		//以下dp[x][0/1][i]都是忽略了它的father的 
      	//dp[x][0][i]表示以edge[i].v为根时 以x为根所在子树(不包含它以前的father那部分) 的f[x][0] 
		int pre = -max(f[v][0],f[v][1] + w) + f[v][0] + w;
		if(max1 == pre) maxx[x].push_back(max2),dp[x][1].push_back(max2 + dp[x][0].back());
		else maxx[x].push_back(max1),dp[x][1].push_back(max1 + dp[x][0].back());
		//同理这里是 dp[x][1][i]表示以edge[i].v为根时 以x为根所在子树(同上) 的f[x][1] 
		//这里 最大值次大值的使用就很明显了 
		//maxx的作用dfs2(换根)时会用到 （再讲） 
	}
}
```

然后 换根时

仔细看看代码 注意 父亲 当前点 当前根 当前点的儿子 应该就可以理解了

(~~我当时理解了好久~~)

```cpp
inline void dfs2(int x)
{
	for(reg i = 0;i < son[x].size();i++)
	{
		//换根 
		f[x][1] = dp[x][1][i],f[x][0] = dp[x][0][i]; //dp记录的状态 
		if(father[x])
		{
			//dfs时我们没有考虑father 所以这里得再算一下它的贡献
			int v = father[x];
			f[x][0] += max(f[v][0],f[v][1] + len[x]);
			f[x][1] = f[x][0] + max(maxx[x][i],f[v][0] + len[x] - max(f[v][0],f[v][1] + len[x])); //加最大的 
		} 
		ans = max(ans,f[son[x][i]][0] + max(f[x][0],f[x][1] + len[son[x][i]]));
		dfs2(son[x][i]);
	}
}
```


### $Eventually,Code$

```cpp
#include <cmath>
#include <cstdio>
#include <vector>
#include <string>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
#define reg register int
#define isdigit(x) ('0' <= x&&x <= '9')
template<typename T>
inline T Read(T Type)
{
	T x = 0,f = 1;
	char a = getchar();
	while(!isdigit(a)) {if(a == '-') f = -1;a = getchar();}
	while(isdigit(a)) {x = (x << 1) + (x << 3) + (a ^ '0');a = getchar();}
	return x * f;
}
const int MAXN = 200010,inf = 0x3f3f3f3f;
int ans,cnt,head[MAXN],father[MAXN],len[MAXN],f[MAXN][2];
vector<int> son[MAXN],maxx[MAXN],dp[MAXN][2];
struct node{int v,w,next;}edge[MAXN << 1];
inline void addedge(int u,int v,int w)
{
	edge[++cnt].v = v;
	edge[cnt].w = w;
	edge[cnt].next = head[u];
	head[u] = cnt;
}
inline void dfs(int x,int fa)
{
	f[x][0] = 0,f[x][1] = -inf;
	int max1,max2;
	max1 = max2 = -inf;
	for(reg i = head[x];i;i = edge[i].next)
	{
		int v = edge[i].v,w = edge[i].w;
		if(v == fa) continue;
		father[v] = x,len[v] = w;
		son[x].push_back(v);
		dfs(v,x);
		f[x][0] += max(f[v][0],f[v][1] + w);
		int pre = -max(f[v][0],f[v][1] + w) + f[v][0] + w;
		if(pre > max1) max2 = max1,max1 = pre;
		else if(pre > max2) max2 = pre;//记录最大值以及次大值 
	}
	f[x][1] = f[x][0] + max1;
   	//这以上是以1为根的
	//	f[x][1] = f[x][0] - max(f[v][0],f[v][1] + w) + f[v][0] + w;
	//这里是上面说的处理
	for(reg i = head[x];i;i = edge[i].next)
	{
		int v = edge[i].v,w = edge[i].w;
		if(v == fa) continue;
		dp[x][0].push_back(f[x][0] - max(f[v][0],f[v][1] + w));
		//以下dp[x][0/1][i]都是忽略了它的father的 
      	//dp[x][0][i]表示以edge[i].v为根时 以x为根所在子树(不包含它以前的father那部分) 的f[x][0] 
		int pre = -max(f[v][0],f[v][1] + w) + f[v][0] + w;
		if(max1 == pre) maxx[x].push_back(max2),dp[x][1].push_back(max2 + dp[x][0].back());
		else maxx[x].push_back(max1),dp[x][1].push_back(max1 + dp[x][0].back());
		//同理这里是 dp[x][1][i]表示以edge[i].v为根时 以x为根所在子树(同上) 的f[x][1] 
		//这里 最大值次大值的使用就很明显了 
		//maxx的作用dfs2(换根)时会用到 （再讲） 
	}
}
inline void dfs2(int x)
{
	for(reg i = 0;i < son[x].size();i++)
	{
		//换根 
		f[x][1] = dp[x][1][i],f[x][0] = dp[x][0][i]; //dp记录的状态 
		if(father[x])
		{
			//dfs时我们没有考虑father 所以这里得再算一下它的贡献
			int v = father[x];
			f[x][0] += max(f[v][0],f[v][1] + len[x]);
			f[x][1] = f[x][0] + max(maxx[x][i],f[v][0] + len[x] - max(f[v][0],f[v][1] + len[x])); //加最大的 
		} 
		ans = max(ans,f[son[x][i]][0] + max(f[x][0],f[x][1] + len[son[x][i]]));
		dfs2(son[x][i]);
	}
}
int main()
{
	int n = Read(1);
	for(reg i = 1;i < n;i++)
	{
		int u = Read(1),v = Read(1),w = Read(1);
		addedge(u,v,w),addedge(v,u,w);
	}
	dfs(1,0);
	dfs2(1);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Super_Cube (赞：3)

# Solution

~~我们偷一张图：~~

![来自 tommymio 的 blog](https://cdn.luogu.com.cn/upload/image_hosting/g8zn09pr.png)

每一种蓝线都只会连接着三个点，形如图中的 3,1,2 与 3,5,6，也就是一个父亲和它的某两个儿子 或者 一个点与它的父亲和儿子。

不过，这两种其实可以转化成同一种，因为我们可以通过改变根节点，来使得原先的 父亲与两个儿子 变为 父亲自己和儿子。

所以，换根 dp。

$dp_{i,0/1}$ 表示 $i$ 点是否作为蓝线中点时的最大价值。

对于 $\forall j \in \operatorname{son_i}, w=\operatorname{dis}( i,j )$，有转移式：

+ $dp_{i,0}=\sum\max\{ dp_{j,0},dp_{j,1}+w \}$

第一种是 $i$ 与 $j$ 之间连红线，第二种是 $j$ 作为蓝线中点。

+ $dp_{i,1}=dp_{i,0}+\max\{ dp_{j,0}+w-\max\{ dp_{j,0},dp_{j,1}+w \} \}$

$j$ 作为蓝线下端，其余儿子和上面一样转移，~~为了偷懒，~~ 可使用 $dp_{i,0}$ 作为初值，然后减去之前的贡献并加上 $j$ 当前作为蓝线下端的贡献。

接下来写换根 dp。

$i$ 往 $j$ 换根时，如果 $j$ 的贡献正好是 $dp_{i,1}$ 中取到 $\max$ 的那个儿子，这个时候因为 $i$ 已经是 $j$ 的子节点了，所以 $dp_{i,1}$ 后面的那一坨要重新选个值来取。

套路，记录转移时的最大值和次大值，如果最大值在换根时寄了，就改用次大值计算 dp 值。

对于写换根的技巧，就是把 $i$ 当作 $j$ 的一个儿子，~~然后将前面的转移复制下来，调换 $i$ 与 $j$ 的位置，~~ 到处修修补补，把 $i$ 中 $j$ 存在的贡献消除掉就好了。

# Code
```cpp
//val[0/1]: 最大值 / 次大值
void dfs(const int& p, const int& dad) {
	val[p][0] = val[p][1] = 0xc0c0c0c0;
	for (const edge& i : v[p]) {
		if (i.to == dad)
			continue;
		dfs(i.to, p);
		dp[p][0] += std::max(dp[i.to][0], dp[i.to][1] + i.val);
		if (val[p][0] < dp[i.to][0] + i.val - std::max(dp[i.to][0], dp[i.to][1] + i.val))
			val[p][1] = val[p][0],
			val[p][0] = dp[i.to][0] + i.val - std::max(dp[i.to][0], dp[i.to][1] + i.val);
		else
			val[p][1] = std::max(val[p][1], dp[i.to][0] + i.val - std::max(dp[i.to][0], dp[i.to][1] + i.val));
	}
	dp[p][1] = dp[p][0] + val[p][0];
}
void change(const int& p, const int& dad) {
	for (const edge& i : v[p]) {
		if (i.to == dad)
			continue;
		int _dp[2];//dp[0/1] 除去当前儿子节点贡献后的权值
		_dp[0] = dp[p][0] - std::max(dp[i.to][0], dp[i.to][1] + i.val);
		if (val[p][0] != dp[i.to][0] + i.val - std::max(dp[i.to][0], dp[i.to][1] + i.val))//最大值与当前儿子节点无关
			_dp[1] = _dp[0] + val[p][0];//可以继续沿用最大值
		else
			_dp[1] = _dp[0] + val[p][1];//否则使用次大值更新
		dp[i.to][0] += std::max(_dp[0], _dp[1] + i.val);
		if (val[i.to][0] < _dp[0] + i.val - std::max(_dp[0], _dp[1] + i.val))
			val[i.to][1] = val[i.to][0], val[i.to][0] = _dp[0] + i.val - std::max(_dp[0], _dp[1] + i.val);
		else
			val[i.to][1] = std::max(val[i.to][1], _dp[0] + i.val - std::max(_dp[0], _dp[1] + i.val));
		//更新换根后当前儿子节点的 val
		dp[i.to][1] = dp[i.to][0] + val[i.to][0];
		change(i.to, p);
	}
}
```

---

## 作者：hegm (赞：3)

### [P3647 [APIO2014] 连珠线](https://www.luogu.com.cn/problem/P3647)

神仙 dp，太神仙了！

也可能是我太弱了。

首先考虑蓝线的可能形态。

容易发现所有的蓝线可以拆分为以三个点为单位的蓝线。

那么蓝线就有两种情况了。

1. $son-now-fa$

2. $son_1-now-son_2$

根据题目，我们可知，一定可以找到至少一个点使得所有的蓝线都可以分为 $son-now-fa$ 而不存在情况 $2$。

#### 证明:

考虑建树过程，游戏是从某一颗珠子已经存在开始的，那么我们假设树的根是当前这颗珠子。

现在我们来观察情况 $2$，有两个条件

1. 在进行 `Insert` 操作之前 $son_1$ 和 $son_2$ 是直接连接的。

2. 新建的节点的深度比 $son_1,son_2$ 小，换句话说，$son_1$ 和 $son_2$ 的深度必须相同。

第二个条件容易发现，我们是无法达成的。

因为是在原来的连通块（根所在的连通块）的基础上新加上一个点，所以新加的点无法和连接的点保证深度相同，连接的点一定会成为新加入的点的父亲。

那么我们的 dp 也就好处理了，先不管哪个点作为根是没有第二种情况的，我们先设计好状态再说。


$dp_{i,0/1/2}$ 表示在 $i$ 的子树中，

0. $i$ 不做为蓝线上的点（$i$ 和所有儿子都以红线相连）

1. $i$ 作为蓝线的 $fa$。

2. $i$ 作为蓝线的 $now$。

的子树最大和。

容易发现 $i$ 做为 $0/1$ 对于后面的转移没有影响（一个点可以同时包含于两个蓝线）

所以我们压缩状态：

$dp_{i,0/1}$ 表示在 $i$ 的子树中，

0. $i$ 不做为任何蓝线上的 $now$。

1. $i$ 作为某个蓝线的 $now$。

的子树最大和。

当然还有第三种情况：$i$ 作为蓝线的 $son$，但是发现此情况和 $0$ 情况对于当前转移（都是连红线）本质是一样的，所以不用考虑。

#### 转移方程

$
\begin{cases}
dp_{i,0}=\sum\limits_{j\in son_i}\max(dp_{j,0},dp_{j,1}+w_{i,j})
\\
dp_{i,1}=dp_{i,0}+\max\limits_{j\in son_i}\{dp_{j,0}+w_{i,j}-\max(dp_{j,0},dp_{j,1}+w_{i,j})\}
\end{cases}
$

现在方程搞出来了，问题是如何找到一个点能保证没有情况 $son_1-now-son_2$。

我们不妨进行换根，只要将所有点为根的情况全部算出来取最大值就好啦。

对于一个点，将他的某个孩子转移到根，我们需要先把它自己的数组进行修改，为了方便我们记录 $f_{i,0/1}$ 表示以 $son_i$ 为根是 $dp_{i,0/1}$ 剖出了 $son_i$ 时对应的数值。

我们需要处理出来：

$mx_i$ 表示 $i$ 的 $\max\limits_{j\in son_i}\{dp_{j,0}+w_{i,j}-\max(dp_{j,0},dp_{j,1}+w_{i,j})\}$。

$pos_i$ 对应的是 $mx_i$ 时的位置。

$mn_i$ 存的是相比于 $mx_i$ 的次小值（非严格）。

对于一个点向他的孩子转移时，$f_{i,0}=dp_{i,0}-dp_{j,0}+w_{i,j}$。

当孩子是 $pos_i$ 的时候 $f_{i,1}=f_{i,0}+mn_i$

否则 $f_{i,1}=f_{i,0}+mx_i$。

当某个节点由他的父亲转移过来的时候我们需要用父亲的 $f_{fa,0}$ 更新当前点的 $mx/mn$。

看代码，很短，常数极小，最优解第一页。

### $\text{CODE}$
```cpp
#include<bits/stdc++.h>
#define N 400005
using namespace std;
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int inf=2000000000;
int n,dp[N][2],mx[N],pos[N],ans=0,f[N][2],mn[N];
struct fig
{
	int to,next,val;
}k[N];int head[N],tot;
void add(int from,int to,int val)
{
	k[++tot].to=to;
	k[tot].next=head[from];
	k[tot].val=val;
	head[from]=tot;
}
void dfs(int now,int fa)
{
	mx[now]=mn[now]=-inf;
	for(int i=head[now],to,pl;i;i=k[i].next)
	{
		to=k[i].to;
		if(to==fa)continue;
		dfs(to,now);pl=max(dp[to][0],dp[to][1]+k[i].val);
		dp[now][0]+=pl;
		if(dp[to][0]+k[i].val-pl>mx[now])
		{
			mn[now]=mx[now];
			mx[now]=dp[to][0]+k[i].val-pl;
			pos[now]=to;
		}
		else if(dp[to][0]+k[i].val-pl>mn[now])mn[now]=dp[to][0]+k[i].val-pl;
	}
	dp[now][1]=dp[now][0]+mx[now];
}
void hg(int now,int fa,int val)
{
	int fl=max(f[fa][0],f[fa][1]+val);
	dp[now][0]+=fl;
	if(fa&&f[fa][0]+val-fl>mx[now])
	{
		mn[now]=mx[now];
		mx[now]=f[fa][0]+val-fl;
		pos[now]=fa;
	}
	else if(fa&&f[fa][0]+val-fl>mn[now])mn[now]=f[fa][0]+val-fl;
	dp[now][1]=dp[now][0]+mx[now];ans=max(ans,dp[now][0]);
	for(int i=head[now],to,pl;i;i=k[i].next)
	{
		to=k[i].to;
		if(to==fa)continue;
		pl=max(dp[to][0],dp[to][1]+k[i].val);
		f[now][0]=dp[now][0]-pl;
		if(to==pos[now])f[now][1]=f[now][0]+mn[now];
		else f[now][1]=f[now][0]+mx[now];
		hg(to,now,k[i].val);
	}
}
int main()
{
	n=read();
	for(int i=1,u,v,w;i<n;i++)
	{
		u=read();v=read();w=read();
		add(u,v,w);
		add(v,u,w);
	}
	dfs(1,0);
	hg(1,0,0);
	cout<<ans<<"\n";
	return 0;
}
```

---

## 作者：yukari1735 (赞：1)

容易发现 fact：蓝边都是一对一对连续匹配起来的，一个点只能是一对蓝边的中点。讨论祖孙和兄弟两种形态一通接边由此容易写出一个 dp 但是是假的。原因在于构造的过程中保持只有一个连通块，兄弟型的蓝边对在某种情况下会寄掉。大概就是一个兄弟蓝边对的两棵子树里面只能有一个有兄弟型的。

然而嗯造这个限制很麻烦，注意到上面的事实也指出了我们可以找一个根使得所有蓝边对都是祖孙形态的，所以只考虑祖孙形态的蓝边对，然后做换根 dp。

dp 一个 $f_{u,0/1}$ 表示 $u$ 不是 / 是蓝边对中点的子树内答案，那么转移枚举接不接，$f_{u,0}=\sum_{v\in S(u)}\max\{f_{v,0},f_{v,1}+w_{u,v}\}$，这里设一个 $\delta_{v}= \max\{f_{v,0},f_{v,1}+w_{u,v}\}$ 表示 $v$ 的贡献。$f_{u,1}$ 就是在 $f_{u,0}$ 的基础上选择一个儿子撤销它的贡献并加上半个蓝边对，$f_{u,1}=f_{u,0}+\max\{-\delta_v+f_{v,0}+w_{u,v}\}$

现在考虑换根，令 $h_{u,v,0/1}$ 表示从 $u$ 中剔除儿子 $v$ 及边 $(u,v)$ 后的 $f_{u,0/1}$ 值，信息可减，$h_{u,v,0}=f_{u,0}-\delta_v$ 是容易求的，而对于 $h_{u,v,1}$ 如果 $v$ 是被选中作半蓝边对的儿子的话，去除它之后我们还需要再选一个作为蓝边对，维护 $f_{u,1}$ 的次大值即可。不需要显式地维护出 $h$，转移 $g$ 的时候顺便求即可。

现在正式维护 $g_{u,0/1}$ 表示从树中剔除以 $u$ 为根的子树，$u$ 不是 / 是蓝边对中点的答案，讨论三种情况，其中两种是接起来一组蓝边对：$g_{v,0}=\max\{g_{u,0}+h_{u,v,0},g_{u,1}+h_{u,v,0}+w_{u,v},g_{u,0}+h_{u,v,1}+w_{u,v}\}$，你可能会疑惑为什么这里我们使用了在 $u$ 上的兄弟形态的蓝边对但是注意我们在维护 $v$ 所以实际上是祖父形态的。$g_{v,1}=g_{u,0}+h_{u,v,0}+w_{u,v}$。

时间复杂度 $O(n)$。


```
# include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 225;
const int Inf = 2e9 + 225;

# define pii pair< int , int >
# define X first
# define Y second
vector< pii >T[ N ];
# define pb push_back

int n;
int f0[ N ] , f1[ N ][ 2 ] , g[ N ][ 2 ] , ch[ N ];

void DFS( int u , int ff ){
	int c = - Inf , _c = - Inf;
	for( pii e : T[ u ] ){
		int v = e . X , w = e . Y; 
		if( v == ff ) continue;
		DFS( v , u );
		f0[ u ] += max( f0[ v ] , f1[ v ][ 0 ] + w );
		int d = f0[ v ] + w - max( f0[ v ] , f1[ v ][ 0 ] + w );
		if( d > c ) _c = c , c = f0[ v ] + w - max( f0[ v ] , f1[ v ][ 0 ] + w ) , ch[ u ] = v;
		else if( d > _c ) _c = d;
	}
	f1[ u ][ 0 ] = f0[ u ] + c , f1[ u ][ 1 ] = f0[ u ] + _c;
}

void DFS1( int u , int ff ){
	for( pii e : T[ u ] ){
		int v = e . X , w = e . Y;
		if( v == ff ) continue;
		int h0 = f0[ u ] - max( f0[ v ] , f1[ v ][ 0 ] + w ) , h1;
		if( v ^ ch[ u ] ) h1 = f1[ u ][ 0 ] - max( f0[ v ] , f1[ v ][ 0 ] + w );
		else h1 = f1[ u ][ 1 ] - max( f0[ v ] , f1[ v ][ 0 ] + w );
		g[ v ][ 0 ] = max( max( g[ u ][ 0 ] + h0 , g[ u ][ 1 ] + h0 + w ) , g[ u ][ 0 ] + h1 + w );
		g[ v ][ 1 ] = g[ u ][ 0 ] + h0 + w;
		DFS1( v , u );
	}
}

int main(){
	scanf( "%d" , & n );
	for( int i = 1 ; i < n ; i ++ ){
		int u , v , w;
		scanf( "%d%d%d" , & u , & v , & w );
		T[ u ] . pb( { v , w } ) , T[ v ] . pb( { u , w } );
	}
	int ans = 0;
	DFS( 1 , 0 ) , g[ 1 ][ 1 ] = - Inf , DFS1( 1 , 0 ); 
	for( int u = 1 ; u <= n ; u ++ ) ans = max( ans , max( f0[ u ] + g[ u ][ 0 ] , f1[ u ][ 0 ] + g[ u ][ 1 ] ) );
	printf( "%d\n" , ans );
	return 0; 
}
```


---

## 作者：tzc_wk (赞：1)

[题面传送门](https://www.luogu.com.cn/problem/P3647)

题意：
桌子上有 $1$ 个珠子，你要进行 $n-1$ 次操作，每次操作有以下两种类型：

1. 拿出一个新珠子，并选择一个桌子上的珠子，在它们之间连一条红线
2. 选择两个由红线相连的珠子 $u,v$，并拿出一个新珠子 $w$，将原来连接 $u,v$ 的红线断开，并在 $u,w$ 和 $v,w$ 之间各连一条蓝线。

显然最后 $n$ 个珠子会形成一棵由 $n-1$ 条线的树，给出最终每条线的长度，但你不知道它们的颜色。

你的得分为所有蓝线长度之和，求在所有可能的情况下，你得分的最大值。

$n \in [2,2\times 10^5]$

考虑蓝线的性质。由于连成的蓝线就没办法再被断开了，故蓝线连接的三个节点 $u,w,v$ 在最终的树上也是相邻的。

故原题可以转化为：你可以选择一条三个节点 $u\to v\to w$ 的链满足边 $(u,v),(v,w)$ 都没被选择，要求选出的边的权值之和的最大值。

树上相邻的三个节点有两种可能，一是爷爷->父亲->儿子，二是儿子->父亲->兄弟。

第二种情况比较复杂。不过我们可以枚举最开始的珠子在最终的树上的编号是多少，也就是钦定一个根节点，这样就不会出现第二种情况（很好理解，如果出现儿子->父亲->兄弟的情况，那我们肯定是先连好儿子->兄弟的边，再插入父亲节点，而由于父亲节点与根节点相连，所以应当是父亲节点先连好才对，所以这种情况不可能出现）

然后就可以 $dp$ 了。$dp_{u,0}$ 选好了 $u$ 的子树中的边，$u$ 不是某条蓝链的中点的最大权值和。$dp_{u,1}$ 表示 $u$ 是某条蓝链的中点的最大权值和。

考虑转移，$dp_{u,0}$ 比较简单，枚举它的每个儿子 $v$，有两种情况，要么 $(u,v)$ 间连了条红线，也就是 $dp_{v,0}$，要么 $(u,v)$ 间连了条蓝线，而由于 $u$ 不是某条蓝链的中点，所以这条链的连法只可能是 $u\to v\to v$ 的某个儿子，也就是 $dp_{v,1}+w$，故 $dp_{u,0}=\sum\limits_{v\in son_u}\max(dp_{v,0},dp_{v,1}+w)$

再考虑 $dp_{u,1}$，显然 $dp_{u,1}$ 是在 $dp_{u,1}$ 是在 $dp_{u,0}$ 的基础上将 $u$ 与某个儿子 $v$ 节点之间的边换成蓝边，考虑这一类树形 $dp$ 的常用套路，枚举这个儿子 $v$，计算将 $(u,v)$ 之间的边改为蓝边造成的 $\Delta=dp_{v,0}+w-\max(dp_{v,0},dp_{v,1}+w)$，然后取个 $\max$ 即可，故 $dp_{u,1}=dp_{u,0}+\max\limits_{v\in son_u}dp_{v,0}+w-\max(dp_{v,0},dp_{v,1}+w)$

然后考虑换根，记 $f_{u}$ 表示以 $u$ 为根节点的答案，$out_{i,0/1}$ 表示 $i$ 子树外的 $dp$ 值，加法是可逆的，至于 $\max$， multiset 维护一下即可。这一部分比较套路，具体见代码。

时间复杂度 $\mathcal O(n\log n)$

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define fz(i,a,b) for(int i=a;i<=b;i++)
#define fd(i,a,b) for(int i=a;i>=b;i--)
#define ffe(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)
#define fill0(a) memset(a,0,sizeof(a))
#define fill1(a) memset(a,-1,sizeof(a))
#define fillbig(a) memset(a,63,sizeof(a))
#define pb push_back
#define ppb pop_back
#define mp make_pair
typedef pair<int,int> pii;
typedef long long ll;
const int MAXN=2e5+5;
int n,to[MAXN<<1],nxt[MAXN<<1],hd[MAXN],cst[MAXN<<1],ec=0;
void adde(int u,int v,int w){
	to[++ec]=v;nxt[ec]=hd[u];cst[ec]=w;hd[u]=ec;
}
int dp[MAXN][2],f[MAXN],out[MAXN][2];
void dfs(int x,int fa){
	dp[x][1]=-2e9;
	for(int e=hd[x];e;e=nxt[e]){
		int y=to[e],z=cst[e];if(y==fa) continue;dfs(y,x);
		dp[x][0]+=max(dp[y][0],dp[y][1]+z);
		dp[x][1]=max(dp[x][1],dp[y][0]+z-max(dp[y][0],dp[y][1]+z));
	} dp[x][1]+=dp[x][0];
}
void cgrt(int x,int fa){
	int sum=0;
	multiset<int> st;st.insert(-2e9);
	for(int e=hd[x];e;e=nxt[e]){
		int y=to[e],z=cst[e];
		if(y==fa){
			sum+=max(out[x][0],out[x][1]+z);
			st.insert(out[x][0]+z-max(out[x][0],out[x][1]+z));
		} else {
			sum+=max(dp[y][0],dp[y][1]+z);
			st.insert(dp[y][0]+z-max(dp[y][0],dp[y][1]+z));
		}
	}
	for(int e=hd[x];e;e=nxt[e]){
		int y=to[e],z=cst[e];if(y==fa) continue;
		out[y][0]=sum-max(dp[y][0],dp[y][1]+z);
		st.erase(st.find(dp[y][0]+z-max(dp[y][0],dp[y][1]+z)));
		out[y][1]=out[y][0]+(*st.rbegin());
		st.insert(dp[y][0]+z-max(dp[y][0],dp[y][1]+z));
		f[y]=dp[y][0]+max(out[y][0],out[y][1]+z);
		cgrt(y,x);
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		int u,v,w;scanf("%d%d%d",&u,&v,&w);
		adde(u,v,w);adde(v,u,w);
	} dfs(1,0);f[1]=dp[1][0];cgrt(1,0);int ans=0;
	for(int i=1;i<=n;i++) ans=max(ans,f[i]);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Piwry (赞：1)

## 解析

我们发现作为游戏起始的珠子比较特殊，因此可以假设已知起始的那个珠子，之后再想办法用换根 dp 考虑

又可以发现，除了最初的珠子外，其它珠子**要么是由连红线的操作产生的，要么是由连蓝线的操作产生的**。因此可以对每个珠子设两个状态，分别为 `dp[-][0]`（红线）和 `dp[-][1]`（蓝线）

若设深度为从根节点到达的边的数量，所有珠子的产生时间和其在以初始珠子为根的树 $T$ 的深度有关，深度越浅产生越早；于是我们可以设 `dp` 数组的值的意义为，以该结点为根的在 $T$ 内的子树的最大贡献（因为深度比它浅的结点都已经**先于它决定**了，同时统计不在这颗子树内的后产生的结点没有意义（一定有其它结点统计））

&nbsp;

设当前结点为 $u$；$w(u, v)$ 的值是树上该边的边权，

### 红色操作状态转移

此时与其儿子连的线的颜色可以为红或蓝，什么颜色的线连的儿子就是什么颜色的

$\text{dp}[u][0]=\sum\limits_{v\text{ 是 }u\text{ 的儿子}}\max(\text{dp}[v][0],\text{dp}[v][1]+w(u,v))$

### 蓝色操作状态转移

此时必须要有一个儿子为红色结点，且和该儿子的连线为蓝（想象下 $u$ 这个蓝色操作结点是怎么产生的），除此之外与 `1.` 相同

$\text{dp}[u][1]=\max\left(\sum\limits_{v\text{ 是 }u\text{ 的儿子}, v\not=v'}\max\left(\text{dp}[v][0],\text{dp}[v][1]+w(u,v)\right)+\left(\text{dp}[v'][0]+w(u, v')\right)\right)$

或者可以简写为

$\text{dp}[u][1]=\text{dp}[u][0]+\max\limits_{v\text{ 是 }u\text{ 的儿子}}\left(-\max\left(\text{dp}[v][0],\text{dp}[v][1]\right)+(\text{dp}[v][0]+w(u, v))\right)$

&nbsp;

再考虑换根，

若将根从 $u$ 转移到 $v$ 且它们之间有边，我们只需从 `dp[u][-]` 中移除 $v$ 的贡献（具体确定贡献再求一遍 max 就可以了），再将 $u$ 作为 $v$ 的子树重新算一遍 $v$ 的贡献就可以了；但考虑到 `dp[u][1]` 可能恰好选择 $v$ 作为其 “红色操作儿子”，因此我们还需记录一个 `dp[u][1]` 的**次大值**用于换根

转移方程过于冗长这里就不写出来了

## CODE

由于 `dp[u][0]` 的值实际上和以该点作为根（初始珠子）的答案一样，这里就不特殊考虑了（因为初始珠子既不是红色操作，也不是蓝色操作产生的）

同时为了避免代码过长还做了一点压缩（例如设个临时变量什么），如果感觉很难看懂其实可以考虑自己写转移并结合样例修订

```cpp
#include <cstdio>
#include <iostream>
#define ll long long
using std::max;

const int MAXN =2e5+50;

/*------------------------------Map------------------------------*/

int first[MAXN], tote;
struct edge{
	int net, to, val;
}e[MAXN<<1];

inline void addedge(int u, int v, int w){
	++tote;
	e[tote].to =v, e[tote].val =w, e[tote].net =first[u];
	first[u] =tote;
	++tote;
	e[tote].to =u, e[tote].val =w, e[tote].net =first[v];
	first[v] =tote;
}

/*------------------------------Dfs------------------------------*/

ll dp[MAXN][2], dp2[MAXN]/*该结点为蓝色操作 (dp[-][1]) 时的次大答案*/;
ll Ans =0;
int chose[MAXN];/*选择哪个儿子作为红色操作结点*/

void dfs(int u, int fa){
	for(int l =first[u]; l; l =e[l].net){
		if(e[l].to != fa){
			dfs(e[l].to, u);
			dp[u][0] +=max(dp[e[l].to][0], dp[e[l].to][1]+e[l].val);
		}
	}
	dp[u][1] =-0x3f3f3f3f3f3f3f3f;
	dp2[u] =-0x3f3f3f3f3f3f3f3f;
	for(int l =first[u]; l; l =e[l].net){
		if(e[l].to != fa){
			ll _max =max(dp[e[l].to][0], dp[e[l].to][1]+e[l].val);
			/*设置某个儿子必为红色操作结点 ( 和该点蓝线连接 )*/
			if(dp[u][0]-_max+dp[e[l].to][0]+e[l].val > dp[u][1]){
				dp2[u] =dp[u][1];
				dp[u][1] =dp[u][0]-_max+dp[e[l].to][0]+e[l].val;
				chose[u] =e[l].to;
			}
			else if(dp[u][0]-_max+dp[e[l].to][0]+e[l].val > dp2[u]){
				dp2[u] =dp[u][0]-_max+dp[e[l].to][0]+e[l].val;
			}
		}
	}
}

void dfs2(int u, int fa){
	Ans =max(Ans, dp[u][0]);
	for(int l =first[u]; l; l =e[l].net)
		if(e[l].to != fa){
			ll _max =max(dp[e[l].to][0], dp[e[l].to][1]+e[l].val);
			ll _max2 =dp[u][0]-_max;
			if(chose[u] == e[l].to)
				_max2 =max(_max2, dp2[u]-_max+e[l].val);
			else
				_max2 =max(_max2, dp[u][1]-_max+e[l].val);
			dp[e[l].to][0] +=_max2;
			
			dp[e[l].to][1] +=_max2;
			dp2[e[l].to] +=_max2;
			if(dp[e[l].to][0]-_max2+(dp[u][0]-_max)+e[l].val > dp[e[l].to][1]){
				dp2[e[l].to] =dp[e[l].to][1];
				dp[e[l].to][1] =dp[e[l].to][0]-_max2+(dp[u][0]-_max)+e[l].val;
				chose[e[l].to] =u;
			}
			else if(dp[e[l].to][0]-_max2+(dp[u][0]-_max)+e[l].val > dp2[e[l].to]){
				dp2[e[l].to] =dp[e[l].to][0]-_max2+(dp[u][0]-_max)+e[l].val;
			}
			
			dfs2(e[l].to, u);
		}
}

/*------------------------------Main------------------------------*/

inline int read(){
	int x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return x;
}

int main(){
	int n =read();
	for(int i =0; i < n-1; ++i){
		int u =read(), v =read(), w =read();
		addedge(u, v, w);
	}
	dfs(1, 0);
	dfs2(1, 0);
	printf("%lld", Ans);
}
```

---

## 作者：封禁用户 (赞：1)

### 题目传送门

[P3647](https://www.luogu.com.cn/problem/P3647)

### 题意

对于一颗树，每条边有一个权值，选出满足两种类型的边集使其边权和最大。

### 分析

可以发现，所有的边均满足两种类型。

![](https://cdn.luogu.com.cn/upload/image_hosting/hp0b7m94.png)

对于 root-2-3 和 root-2-4 我们称其为“祖孙型”。

对于 2-3-4 我们称其为“兄弟型”。

同时维护“祖孙型”和“兄弟型”很难受，于是就要转化。

可以发现，在以 2 或 4 为根时，本来是“兄弟型”的 2-3-4 就转化成了祖孙型。

所以我们只需要在不同的根维护“祖孙型”即可。

定义状态 $dp_{i,0/1}$ 表示以 $i$ 为根的最大合法边权和，其中 1 表示 $i$ 是“祖孙型”的中心节点，0 表示 $i$ 不是“祖孙型”的中心节点。

有状态转移方程：

$dp_{i,0} \leftarrow \sum_{j \in \operatorname{son}(i)}{\max(dp_{j,0},dp_{j,1} + \operatorname{w}(i,j))}$

$dp_{i,1} \leftarrow \max_{k\in \operatorname{son}(i)}\{\sum_{j \in \operatorname{son}(i)(j \neq k)}({\max(dp_{j,0},dp_{j,1} + \operatorname{w}(i,j))}) + dp_{k,0} + \operatorname{w}(i,k) \}$

但这样会被菊花图给卡爆，于是我们用 $dp_{i,0}$ 表示 $dp_{i,1}$，有：

$dp_{i,1} \leftarrow dp_{i,0} + \max_{j \in \operatorname{son}(i)}\{dp_{j,0} + \operatorname{w}(i,j) - \max(dp_{j,0},dp_{j,1} + \operatorname{w}(i,j))\}$

最后的答案就是 $\max\{dp_{i,0}\}$。


这样，对每个根做一次 DP 是 $O(n)$ 的，总复杂度 $O(n^2)$。

### 优化

可以发现，在多次 DP 的过程中信息有极大地浪费，于是考虑换根 DP。

考虑把根从 $i$ 换到 $j$。

两步走：

1. 把 $i$ 的 DP 值撤销 $j$ 的贡献

1. $i$ 转移到 $j$

为了撤销贡献，我们需要对于每个 $i$ 维护 $\max(dp_{j,0},dp_{j,1} + \operatorname{w}(i,j))$ 的最大值和次大值。

注意，我们在换根的过程中也要实时更新这个最大值和次大值，为了方便，我把它包装成了一个结构体。

```cpp
struct node
{
	ll F,S;
	node() {F = S = -4e18;}
	inline void insert(ll x)
	{
		if(x > F) S = F,F = x;
		else if(x > S) S = x;
	}
};
```

这是换根的部分：

```cpp
ll tp0 = f[u][0] - max(dp[v][1] + w,dp[v][0]),tp1;
if(dp[v][0] + w - max(dp[v][1] + w,dp[v][0]) == mx[u].F) tp1 = tp0 + mx[u].S;
else tp1 = tp0 + mx[u].F;
f[v][0] = dp[v][0] + max(tp1 + w,tp0);
mx[v].insert(tp0 + w - max(tp1 + w,tp0));
f[v][1] = f[v][0] + mx[v].F;
solve(v,u);
```
其中 $tp0$ 和 $tp1$ 是 $i$ 的 DP 值撤销 $j$ 的贡献后的结果，$f$ 是换根后的 DP 值。

### AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
template<typename T>inline void read(register T &x)
{
	register T p = 1;
	x = 0;
	char c = getchar();
	while(c < '0'||c > '9')
	{
		if(c == '-') p = -p;
		c = getchar();
	}
	while('0' <= c&&c <= '9')
	{
		x = (x<<3)+(x<<1)+(c^48);
		c = getchar();
	}
	x *= p;
}
template<typename T>inline void write(register T x)
{
	if(x < 0) putchar('-'),x = -x;
	if(x > 9) write(x/10);
	putchar(x%10+48);
}
#define D(i,a,b) for(register int i=a;i>=b;--i)
#define F(i,a,b) for(register int i=a;i<=b;++i)
#define ll long long
#define pii pair<int,int>
#define N 200010
int head[N],nxt[N<<1],to[N<<1],val[N<<1],cnt = 0;
inline void add(int u,int v,int w)
{
	nxt[++cnt] = head[u];
	head[u] = cnt;
	to[cnt] = v;
	val[cnt] = w;
}
ll f[N][2],dp[N][2],ans = 0;  
int n;
struct node
{
	ll F,S;
	node() {F = S = -4e18;}
	inline void insert(ll x)
	{
		if(x > F) S = F,F = x;
		else if(x > S) S = x;
	}
}mx[N];
void dfs(int u,int fa)
{
	dp[u][0] = 0;
	for(register int i = head[u];i;i = nxt[i])
	{
		int v = to[i],w = val[i];
		if(v == fa) continue;
		dfs(v,u);
		dp[u][0] += max(dp[v][1] + w,dp[v][0]); 
		mx[u].insert(dp[v][0] + w - max(dp[v][1] + w,dp[v][0]));
	}
	dp[u][1] = dp[u][0] + mx[u].F;
}
void solve(int u,int fa)
{
	for(register int i = head[u];i;i = nxt[i])
	{
		int v = to[i],w = val[i];
		if(v == fa) continue;
		ll tp0 = f[u][0] - max(dp[v][1] + w,dp[v][0]),tp1;
		if(dp[v][0] + w - max(dp[v][1] + w,dp[v][0]) == mx[u].F) tp1 = tp0 + mx[u].S;
		else tp1 = tp0 + mx[u].F;
		f[v][0] = dp[v][0] + max(tp1 + w,tp0);
		mx[v].insert(tp0 + w - max(tp1 + w,tp0));
		f[v][1] = f[v][0] + mx[v].F;
		solve(v,u);
	}
}
int main()
{
	read(n);
	F(i,1,n-1)
	{
		int u,v,w;
		read(u),read(v),read(w);
		add(u,v,w);
		add(v,u,w);
	} 
	dfs(1,0);
	f[1][0] = dp[1][0];
	f[1][1] = dp[1][1];
	solve(1,0);
	F(i,1,n) ans = max(ans,f[i][0]);
	write(ans);
	return 0;
}
```

### 总结

这题主要考点是对树模型的转化和换根 DP 的套路。

---

## 作者：nofind (赞：1)

## [题意](https://www.luogu.org/problem/P3647)

显然蓝线的连接方式只有两种可能:

![](https://cdn.luogu.com.cn/upload/image_hosting/xuhbv3w5.png)
于是考虑树形DP,枚举蓝线的中点,但是发现处理不了下面的情况
![](https://cdn.luogu.com.cn/upload/image_hosting/kbfi5ila.png)
要连接2-1-3这条链需要满足2和3之间有红线,而2,3之前已经作为插入的点连接了4个叶子

考虑插入的过程,一开始只有根,每次插入一个点,蓝边只有上面右边那种情况

假如根节点已经确定:

设$f[x][0/1]$表示只考虑x及它的子树,x不是(0)/是(1)蓝边中点

$f[x][0]=\sum\limits_{y\in\ son[x]}max(f[y][0],f[y][1]+w)$

$f[x][1]=max(f[x][0]-max(f[y][0],f[y][1]+w)+f[y][0]+w)(y\in\ son[x])$

但这是根节点确定的情况,枚举根节点,$O(N^2)$

这时候肯定是换根

设$g[x][y][0/1]$表示$x$不考虑$y$时$f[x][0/1]$的值

$g[x][y][0]=f[x][0]-max(f[y][0],f[y][1]+w)$

$g[x][y][1]$计算要麻烦一点

记录$f[y][0]+w-max(f[y][0],f[y][1]+w)$的最大值$maxx1$和次大值$maxx2$

$g[x][y][1]=g[x][y][0]+maxx$

如果在y处取了max,$maxx=maxx2$,不然就是$maxx1$

之后就可以换根了,注意父亲节点的贡献

由于g数组是开不下的,但是总大小是0(N)级别的,于是学了别的题解用vector存

code:
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=200010;
const int inf=482094823;
int n,cnt,ans;
int head[maxn],pre[maxn],len[maxn];
int f[maxn][2];
vector<int>son[maxn],g[maxn][2],maxx[maxn];
struct edge
{
	int to,nxt,dis;
}e[maxn<<1];
inline void add(int u,int v,int w)
{
	e[++cnt].nxt=head[u];
	head[u]=cnt;
	e[cnt].to=v;
	e[cnt].dis=w;
}
void dp1(int x,int fa)
{
	f[x][0]=0,f[x][1]=-inf;
	int maxx1=-inf,maxx2=-inf;
	for(int i=head[x];i;i=e[i].nxt)
	{
		int y=e[i].to;
		if(y==fa)continue;
		len[y]=e[i].dis;pre[y]=x;son[x].push_back(y);
		dp1(y,x);
		f[x][0]+=max(f[y][0],f[y][1]+e[i].dis);
		int tmp=f[y][0]+e[i].dis-max(f[y][0],f[y][1]+e[i].dis);
		if(tmp>maxx1)maxx2=maxx1,maxx1=tmp;
		else if(tmp>maxx2)maxx2=tmp;
	}
	f[x][1]=f[x][0]+maxx1;
	for(unsigned int i=0;i<son[x].size();i++)
	{
		int y=son[x][i];
		g[x][0].push_back(f[x][0]-max(f[y][0],f[y][1]+len[y]));
		int tmp=f[y][0]+len[y]-max(f[y][0],f[y][1]+len[y]);
		if(tmp==maxx1)g[x][1].push_back(g[x][0].back()+maxx2),maxx[x].push_back(maxx2);
		else g[x][1].push_back(g[x][0].back()+maxx1),maxx[x].push_back(maxx1);
	}
}
void dp2(int x)
{
	for(unsigned int i=0;i<son[x].size();i++)
	{
		int y=son[x][i];
		f[x][0]=g[x][0][i],f[x][1]=g[x][1][i];
		if(pre[x])
		{
			f[x][0]+=max(f[pre[x]][0],f[pre[x]][1]+len[x]);//f[fa[x]][0]->g[fa[x]][0][x]
			f[x][1]=f[x][0]+max(maxx[x][i],f[pre[x]][0]+len[x]-max(f[pre[x]][0],f[pre[x]][1]+len[x]));
		}
		ans=max(ans,f[y][0]+max(f[x][0],f[x][1]+len[y]));
		dp2(y);
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<n;i++)
	{
		int u,v,w;scanf("%d%d%d",&u,&v,&w);
		add(u,v,w);add(v,u,w);
	}
	dp1(1,0);dp2(1);
	printf("%d",ans);
	return 0;
}
```


---

## 作者：cxq2002 (赞：1)

树形DP

考虑这棵树建树的过程。

开始只有根节点，后来在不断加点过程中有一些边变为蓝边。

点i若插入一条红线(soni---fatheri)中间，成为两条蓝边的中心点，那么这两条蓝边分别是(i---soni)和(i---fatheri)。

f[i][0]表示i号点不做两条蓝边中心点。


f[i][0]=它每一个son可得到的最大值的和。

状态转移方程：f[i][0]=∑(j∈soni) max(f[j][0],f[j][1]+(j->i)的长度)


f[i][1]表示i号点做两条蓝边中心点。

f[i][1]=(选一个j(j∈soni)（j不做蓝边中心点可得到的最大值）+（j到点i边的长度）-（j可得到的最大值）)它的最大值+（所有son可得到的最大值的和）+（点i到父节点边的长度）


状态转移方程：f[i][1]=f[i][0]+biggest(f[j][0]+(j->i)的长度−max(f[j][0],f[j][1]+(j->i)的长度))(j∈soni)


进行一遍dp，每次O(1)进行从上到下换根转移。每次选一个j(j∈son根)作为新的根节点，把旧根节点作为它的son。


---

## 作者：gyyyyx (赞：0)

首先，如果三个点都用的蓝线相连，有两种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/drd66woy.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/3jjdk6xd.png)

~~这里因本人太懒就直接搬运了两张图片过来~~

其实就是连接爷爷，父亲，儿子和儿子，父亲，儿子。

这时候用普通的树形 dp 是很难做的（试一下就知道了）。

不过，很容易想到，如果每次都用第一种连接方式，只要换一下根，某些连接就会变成第二种。

所以想到用换根 dp 来做。

我们称一段蓝线，表示由上述方法生成的两条蓝线。

设状态：

$f_{k,0/1}$ 表示第 $k$ 个节点是/否是一段连线的中点时。

设转移方程：

$$\begin{aligned}f_{k,0}&=\underset{s\in{son_k}}{\sum}\max(f_{s,0},f_{s,1}+len_{k\to s})\cr
f_{k,1}&=f_{s,0}+\underset{s\in{son_k}}{\max}(f_{s,0}+len_{k\to s}-\max(f_{s,0},f_{s,1}+len_{k\to s}))\end{aligned}$$

有点难理解，可以先把这里搞懂再看下面。

之后考虑换根操作。

我们需要记录一个 $dp_{k,0/1,i}$ 表示在 $f_{k,0/1}$ 这个状态的统计过程中，不考虑第 $i$ 个儿子得到的答案。

对于 $dp_{k,0,i}$ 直接从总和中减去。

那对于 $dp_{k,1,j}$，维护最大值和次大值更新即可。

在换根中，我们枚举当前节点 $k$ 的儿子作为整棵树的根。

此时，由于换根后，$k$ 的父亲会变成他的儿子，所以我们并不能直接在 $k$ 节点和儿子之间换根，而是应该先重新计算计算父亲对 $k$ 节点的贡献，然后再进行换根。

具体还有很多细节，看代码即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 200005
int n;
struct Edge{int v,w;};
vector <Edge> t[N];
vector <int> son[N],dp[N][2],mx[N];
int len[N],f[N][2],ans;
#undef N
#define s t[k][i].v
#define l t[k][i].w
void DFS(int k,int fa){
    f[k][0]=0;f[k][1]=INT_MIN;
    int mx1(INT_MIN),mx2(INT_MIN);
    for(int i(0);i<t[k].size();++i)
        if(s^fa){
            son[k].push_back(s);
            len[s]=l;
            DFS(s,k);
            f[k][0]+=max(f[s][0],f[s][1]+l);
            int v(f[s][0]+l-max(f[s][0],f[s][1]+l));
            if(v>mx1){
                mx2=mx1;
                mx1=v;
            }
            else if(v>mx2) mx2=v;
        }
    f[k][1]=f[k][0]+mx1;
    for(int i(0);i<t[k].size();++i)
        if(s^fa){
            int v(f[k][0]-max(f[s][0],f[s][1]+l));
            dp[k][0].push_back(v);
            if(f[s][0]+l-max(f[s][0],f[s][1]+l)==mx1){
                dp[k][1].push_back(v+mx2);
                mx[k].push_back(mx2);
            }
            else{
                dp[k][1].push_back(v+mx1);
                mx[k].push_back(mx1);
            }
        }
}
#undef s
#undef l
#define s son[k][i]
void DP(int k,int fa){
    for(int i(0);i<son[k].size();++i){
        f[k][0]=dp[k][0][i];f[k][1]=dp[k][1][i];
        if(fa){
            f[k][0]+=max(f[fa][0],f[fa][1]+len[k]);
            f[k][1]=f[k][0]+max(mx[k][i],f[fa][0]+len[k]-max(f[fa][0],f[fa][1]+len[k]));
        }
        ans=max(ans,f[s][0]+max(f[k][0],f[k][1]+len[s]));
        DP(s,k);
    }
}
#undef s
int main(){
    std::ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n;
    for(int i(1);i<n;++i){
        int u,v,w;cin>>u>>v>>w;
        t[u].push_back((Edge){v,w});
        t[v].push_back((Edge){u,w});
    }
    DFS(1,0);
    DP(1,0);
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：pengyule (赞：0)

## 概述

本题为换根 DP 经典题，比较模板，借此题整理换根 DP。

## 题意简述

> 今构造一棵由珠子和线构成的树，可以通过下列方式中的一种添加一个**新**珠子：
>
> 1. 将一颗新珠子和已有的一颗珠子用**红线**连接起来；
> 2. 将一颗新珠子插入到两颗**用红线连接**的已有珠子之间。具体地，拆除原来的红线，并用蓝线将新珠子分别与两颗珠子相连。
>
> 每条线有一个权值。现在已经知道树的结构和每条线的权值，但不知道每条线的颜色。你需要输出合法的构造方式中，蓝线权值和的最大值。

## 提示

对于拿到的这棵树，随便选择一个点作为根，那么容易发现蓝线的产生只可能是下面两种方式（形态）：

![image.png](https://s2.loli.net/2021/12/14/iAZMXDxGOEHySBt.png)

（打红圈的是某一时刻插入的新珠子）

假如我们分类讨论地 DP 子树中的这两种形态的蓝线权值和最大值，会发现这是十分困难的。

同时，我们意识到这样子分成两种形态是十分生硬的，因为它们本质是一样的。

考虑这两种形态能否一统为一：你会发现必然存在一个节点，使得以它为根时所有的蓝线都是可以以上左图的方式构造的。

例如，样例图中，以 10 为根就可以实现：

![image.png](https://s2.loli.net/2021/12/14/YWBCEiqk9RAJTMw.png)

## 题解

根据提示，我们可以进行换根 DP。即：

- 先进行第一轮 dfs，求出以 1 为根的时候的按上左图方式构造最大的蓝线长度和 $f_{i,0/1}$。

  - $f_{i,0/1}$ 表示以 $i$ 为根的子树内，$i$ 是不是（$1/0$）“重要点”（即上上图中的打红圈的点）的答案（例如上图中 $f_{2,1}=3+2+21+8=34$）。
  - $f_{i,0}=\sum_{j\in son(i)}\max(f_{j,0},f_{j,1}).$
  - 由于上述转移方式不利于后期代码实现，因此更改 $f_{i,1}$ 的定义：
    - 上图中 $f_{2,1}$ 只算 $f_{2,1}=3+2+8=13$（$21$ 先不算，等 1 号点算的时候再加上）
    - 也就是说，只记录原 $f_{i,1}$ 算的边当中真的在 $i$ 的子树中的部分。
  - 于是 $f_{i,0}=\sum_{j\in son(i)}\max(f_{j,0},f_{j,1}+w(i,j)).$
  - 写 $v=\min_{j\in son(i)}\{\max(f_{j,0},f_{j,1}+w(i,j))-(f_{j,0}+w(i,j))\}$，则 $f_{i,1}=f_{i,0}-v$

- 在进行第二轮 dfs（换根），求出以不同节点为根时的答案。

  - $g_{i,0/1}$ 记录 $i$ 被某一个儿子吊起时，$i$ 子树内的 $f_{0/1}$。注：$g_{i,0/1}$ 会根据是被哪一个儿子吊起重新计算，因此复杂度不正确，后面会优化。

  - 记 $F_{0}=f,F_1=g$。

  - 则有 
    $$
    F_{1,i,0}=\sum_{j\in link(i),j\ne p}\max(F_{j=fa[i],j,0},F_{j=fa[i],j,1}+w(i,j))\\
    v=\min_{j\in link(i),j\ne p}\{\max(F_{j=fa[i],j,0},F_{j=fa[i],j,1}+w(i,j)-(F_{j=fa[x],j,0}+w(i,j))\}\\
    F_{1,i,1}=F_{1,i,0}-v
    $$
    其中 $p$ 表示吊起 $i$ 的儿子，$link(i)$ 表示与 $i$ 相连的所有点的集合，$fa[i]$ 代表以 1 为根时 $i$ 的父节点，$j=fa[i]$ 为一个 $0/1$ 值。

- 时间复杂度在菊花树时可能被卡到 $O(n^2)$，无法通过。
- 发现每次查询的本质其实是 $link(i)$ 除去一个元素后的 $\max(F_{j=fa[i],j,0},F_{j=fa[i],j,1}+w(i,j))$ 之和，以及 $\max(F_{j=fa[i],j,0},F_{j=fa[i],j,1}+w(i,j)-(F_{j=fa[x],j,0}+w(i,j))$ 的最小值。这种东西容易通过预处理出所求表达式的前缀值和后缀值，然后算 $val_{pre}[i-1]\otimes val_{suf}[i+1]$ 来获得，其中 $\otimes$ 表示一种合并运算，对应上面的 $+$ 或 $\min$。
- 这样一来，复杂度被降到了 $O(n)$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n,ans,f[2][N][2],fa[N];
vector<pair<int,int> >G[N],vec[N],val[2][N];
void dfs1(int x,int p,int pe){
	fa[x]=p;
	int v=1e9;
	for(int i=0;i<G[x].size();i++){
		int y=G[x][i].first,z=G[x][i].second;
		if(y^p){
			dfs1(y,x,z);
			f[0][x][0]+=max(f[0][y][0],f[0][y][1]+z);
			v=min(v,max(f[0][y][0],f[0][y][1]+z)-(f[0][y][0]+z));
		}
	}
	f[0][x][1]=f[0][x][0]-v;
}
void calc(int x){
	int v=1e9,tot=0;
	vec[x].resize(G[x].size()+2),val[0][x].resize(G[x].size()+2),val[1][x].resize(G[x].size()+2);
	for(int i=0;i<G[x].size();i++){
		int y=G[x][i].first,z=G[x][i].second;
		vec[x][++tot]=G[x][i];
		f[1][x][0]+=max(f[y==fa[x]][y][0],f[y==fa[x]][y][1]+z);
		v=min(v,max(f[y==fa[x]][y][0],f[y==fa[x]][y][1]+z)-(f[y==fa[x]][y][0]+z));
	}
	val[0][x][0]=val[1][x][tot+1]=make_pair(0,1e9);
	for(int i=1;i<=tot;i++){
		int y=vec[x][i].first,z=vec[x][i].second;
		val[0][x][i]=make_pair(val[0][x][i-1].first+max(f[y==fa[x]][y][0],f[y==fa[x]][y][1]+z),
		min(val[0][x][i-1].second,max(f[y==fa[x]][y][0],f[y==fa[x]][y][1]+z)-(f[y==fa[x]][y][0]+z)));
	}
	for(int i=tot;i;i--){
		int y=vec[x][i].first,z=vec[x][i].second;
		val[1][x][i]=make_pair(val[1][x][i+1].first+max(f[y==fa[x]][y][0],f[y==fa[x]][y][1]+z),
		min(val[1][x][i+1].second,max(f[y==fa[x]][y][0],f[y==fa[x]][y][1]+z)-(f[y==fa[x]][y][0]+z)));
	}
}
void upd(int x,int i){
	if(!i){
		f[1][x][0]=val[1][x][i+1].first;
		f[1][x][1]=f[1][x][0]-val[1][x][i+1].second;
	}
	else {
		f[1][x][0]=val[0][x][i-1].first+val[1][x][i+1].first;
		f[1][x][1]=f[1][x][0]-min(val[0][x][i-1].second,val[1][x][i+1].second);
	}
}
void dfs2(int x,int p,int pe,int po){
	if(p)upd(p,po);
	calc(x);
	ans=max(ans,f[0][x][0]+max(f[1][p][0],f[1][p][1]+pe));
	int tot=vec[x].size()-2;
	for(int i=1;i<=tot;i++){
		int y=vec[x][i].first,z=vec[x][i].second;
		if(y^p)dfs2(y,x,z,i);
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1,u,v,w;i<n;i++){
		scanf("%d%d%d",&u,&v,&w);
		G[u].push_back(make_pair(v,w));
		G[v].push_back(make_pair(u,w));
	}
	dfs1(1,0,0);
	dfs2(1,0,0,0);
	cout<<ans;
}
```

## 总结

换根 DP 的基本思路是两次 dfs，第一次求任一根的所有值，第二次求所有根的根的值。

换根 DP 最需要考虑的问题是如何在第二次 dfs 中转移，即求出一个点被吊起的答案。为了降低复杂度，常常采用预处理前后缀答案的方式来求与一个点相连的所有点中去除一个点后某种满足结合律的运算的答案。

---


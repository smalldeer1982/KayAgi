# [BJOI2017] 机动训练

## 题目背景

> AM 4:45
>
> 又是晴朗的好天气。
>
> AM 5:00
>
> 不要嘛，再睡一会
>
> AM 5:05
>
> 呜……欺负人

## 题目描述

睡眼朦胧的菜酱 (?) 已经被二爷拉起来晨跑了。而这个时间你在做什么呢？

咳咳，言归正传，最近菜酱的训练遇到了点小麻烦。

凌晨绕格瑞赛亚岛跑一圈是基本，在那之后，菜酱还要接受严格的机动训练。所谓机动训练，就是在紧急情况 (?) 下，高速且隐蔽地从位置 $s$ 移动到位置 $t$ 的训练。一般来说，$s$ 和 $t$ 是根据二爷的心情随机决定的，但是由于菜酱已经熟悉了地形，每次总是能找到不太费劲的路径，二爷决定增大难度。所谓增大难度，其实就是指定整条路径，这样菜酱就没办法抄近道了。当然，由于是为了实战而进行的训练，二爷也不会随便乱指定路径，至少不会故意绕路。然后发生的问题就是，如何才能「随机」一整条路径出来？二爷统计了全岛所有的合法路径，打算每次在这个表格里随机抽一条出来。但是很快二爷发现，许多路径所经过的地形是完全相同的，这类路径的训练会更加有用。于是二爷修改了随机策略，地形较为常见的路径权重会变得更大。

一次偶然的机会，菜酱看到了二爷的随机策略，并发动技能「过目不忘 (?)」记了下来。现在你要帮菜酱分析数据。

为什么是你？当然是因为否则就会被菜酱爆头 (并不)。

整个岛可以看作一片 $m\times n$ 的区域，每个格子有自己的地形。

一条路径由一系列八连通的格子组成，两个格子八连通当且仅当这两个格子拥有公共的顶点。

定义一条“机动路径”如下：

1. 它是一条不自交的路径，即路径上任意两个格子都不是同一个。
2. 它的起点和终点处于不同位置，换言之这条路径至少包含 $2$ 个格子。
3. 从起点开始，任何一步只能向不远离终点的方向移动，这里不远离指的是 $x$ 和 $y$ 两个方向都不远离。

举例说明：

```plain
.....t    ......    .---.
-++...    ---...    .-s-.
-s+...    -s+..t    .-+-.
---...    ---...    ..t..
```

图中加号和减号标明了与 $s$ 八连通的所有格子，其中加号是“不远离 $t$”的方向。

因此可以看出，如下路径是机动路径：

```plain
++++++t    ......+t    .......t
+......    .....++.    ......+.
+......    ..++++..    ...+++..
s......    s++.....    s+++....
```

而如下路径不是机动路径：

```plain
\../---t    .......t    .s.
|--.....    ....../.    /..
|.......    s..../..    \..
s.......    .\--/...    .t.
```

需要注意的是，某些不合法的路径甚至比机动路径还要短，这是因为机动路径不是按照长度来定义的。

接下来定义一条机动路径的地形，岛上的地形由一个矩阵给出，如：

```plain
.**.
*..*
*..*
.**.
```

那么，一条机动路径的地形序列就是它所经过的地形排成一列，如：

```plain
s-\.
...\
...|
...t
```

地形序列就是 `.****.`。

每条机动路径的权重就是与之拥有相同地形序列的机动路径数量之和，例如与这条路径拥有相同地形序列的路径有

```plain
./-t    t...    ...s    s-\.    ./-s    s...    ...t    t-\.
/...    |...    ...|    ...\    /...    |...    ...|    ...\
|...    \...    .../    ...|    |...    \...    .../    ...|
s...    .\-s    t-/.    ...t    t...    .\-t    s-/.    ...s
```

共 $8$ 条，注意回文时正反算两条，以及自己也算一条。

所以这条机动路径的权重是 $8$，同时所有这 $8$ 条机动路径的权重都是 $8$。

现在你需要统计所有的机动路径权重之和。

如果对这种统计方式没有直观的感受，可以查看样例说明。


## 说明/提示

### 样例解释 1
用中括号括起来的一些数对表示一条机动路径，坐标先行后列：

- 地形序列 `.*`：$[(1, 1), (1, 2)],\ [(1, 1), (2, 1)],\ [(2, 2), (2, 1)],\ [(2, 2), (1, 2)]$，共 $4$ 条，每条权重为 $4$，计 $16$。
- 地形序列 `*.`：$[(1, 2), (1, 1)],\ [(2, 1), (1, 1)],\ [(2, 1), (2, 2)],\ [(1, 2), (2, 2)]$，共 $4$ 条，每条权重为 $4$，计 $16$。
- 地形序列 `..`：$[(1, 1), (2, 2)],\ [(2, 2), (1, 1)]$，共 $2$ 条，每条权重为 $2$，计 $4$。
- 地形序列 `**`：$[(1, 2), (2, 1)],\ [(2, 1), (1, 2)]$，共 $2$ 条，每条权重为 $2$，计 $4$。
- 地形序列 `.*.`：$[(1, 1), (1, 2), (2, 2)],\ [(1, 1), (2, 1), (2, 2)],\ [(2, 2), (2, 1), (1, 1)],\ [(2, 2), (1, 2), (1, 1)]$，共 $4$ 条，每条权重为 $4$，计 $16$。
- 地形序列 `*.*`：$[(1, 2), (1, 1), (2, 1)],\ [(2, 1), (1, 1), (1, 2)],\ [(1, 2), (2, 2), (2, 1)],\ [(2, 1), (2, 2), (1, 2)]$，共 $4$ 条，每条权重为 $4$，计 $16$。

共计 $16+16+4+4+16+16=72$。

### 样例解释 2
- 地形序列 `.*`：$7$ 条，每条权重为 $7$，计 $49$。
- 地形序列 `*.`：$7$ 条，每条权重为 $7$，计 $49$。
- 地形序列 `..`：$4$ 条，每条权重为 $4$，计 $16$。
- 地形序列 `**`：$4$ 条，每条权重为 $4$，计 $16$。
- 地形序列 `..*`：$2$ 条，每条权重为 $2$，计 $4$。
- 地形序列 `.*.`：$10$ 条，每条权重为 $10$，计 $100$。
- 地形序列 `.**`：$2$ 条，每条权重为 $2$，计 $4$。
- 地形序列 `*..`：$2$ 条，每条权重为 $2$，计 $4$。
- 地形序列 `*.*`：$10$ 条，每条权重为 $10$，计 $100$。
- 地形序列 `**.`：$2$ 条，每条权重为 $2$，计 $4$。
- 地形序列 `.*.*`：$6$ 条，每条权重为 $6$，计 $36$。
- 地形序列 `*.*.`：$6$ 条，每条权重为 $6$，计 $36$。

共计 $49+49+16+16+4+100+4+4+100+4+36+36=418$。

### 数据范围

- 对于 $10\%$ 的数据，$m\times n \le 4$。
- 对于 $30\%$ 的数据，$m, n \le 5$。
- 对于 $60\%$ 的数据，$m, n \le 10$。
- 另有 $20\%$ 的数据，所有地形均相同。
- 对于 $100\%$ 的数据，$1 \le m, n \le 30$，字符集由大小写字母，数字和 `.` `*` 构成。

## 样例 #1

### 输入

```
2 2
.*
*.```

### 输出

```
72```

## 样例 #2

### 输入

```
2 3
.*.
*.*```

### 输出

```
418```

## 样例 #3

### 输入

```
4 4
abba
baab
baab
abba```

### 输出

```
44512```

# 题解

## 作者：StudyingFather (赞：11)

容易看出，假如一共有 $k$ 种地形序列，第 $i$ 种地形序列对应的合法机动路径有 $a_i$ 种，则答案为 $\sum a_i^2$。

有没有觉得这个式子很眼熟？可以去看看 [[NOI2009]管道取珠](https://www.luogu.com.cn/problem/P1758) 这道题。

和那道题思路一样，我们将这个式子解释为两个人同时出发，在机动路径合法的前提下，走出相同地形序列的方案数。

我们设 $f(x_1,y_1,x_2,y_2)$ 表示两条机动路径的方向分别为 $(x_1,y_1)$ 和 $(x_2,y_2)$ 时的方案数。我们枚举左上，左下，右上，右下四个方向即可。考虑到坐标轴的方向会被重复计算，需要再减去在坐标轴上的方向的方案数。

接下来再设 $g(x_1,y_1,x_2,y_2)$ 表示第一个人从 $(x_1,y_1)$ 出发，第二个人从 $(x_2,y_2)$ 出发时，方向与上面 $f$ 的方向对应，地形序列相同的方案数。

记忆化搜索即可。

```cpp
// Problem : P3713 [BJOI2017]机动训练
// Contest : Luogu
// URL : https://www.luogu.com.cn/problem/P3713
// Memory Limit : 250 MB
// Time Limit : 2000 ms
// Powered by CP Editor (https://github.com/cpeditor/cpeditor)

#include <cstdio>
#include <cstring>
#include <vector>
#define MOD 1000000009
using namespace std;
int f[5][5][5][5],g[35][35][35][35];
int m,n;
char s[35][35];
vector<pair<int,int> > a,b;
int dp(int x,int y,int r,int c)
{
 if(s[x][y]!=s[r][c])return 0;
 if(x<1||x>m||y<1||y>n||r<1||r>m||c<1||c>n)return 0;
 if(~g[x][y][r][c])return g[x][y][r][c];
 int ans=1;
 for(auto i:a)
  for(auto j:b)
  {
   int dx=i.first,dy=i.second,dr=j.first,dc=j.second;
   ans=(ans+dp(x+dx,y+dy,r+dr,c+dc))%MOD;
  }
 return g[x][y][r][c]=ans;
}
int dfs(int x,int y,int p,int q)
{
 if(~f[x+1][y+1][p+1][q+1])
  return f[x+1][y+1][p+1][q+1];
 a.clear(),b.clear();
 for(int i=-1;i<=1;i++)
  if(!i||i==x)
   for(int j=-1;j<=1;j++)
    if((i||j)&&(!j||j==y))
     a.emplace_back(i,j);
 for(int i=-1;i<=1;i++)
  if(!i||i==p)
   for(int j=-1;j<=1;j++)
    if((i||j)&&(!j||j==q))
     b.emplace_back(i,j);
 memset(g,-1,sizeof(g));
 int ans=0;
 for(int i=1;i<=m;i++)
  for(int j=1;j<=n;j++)
   for(int r=1;r<=m;r++)
    for(int c=1;c<=n;c++)
     ans=(ans+dp(i,j,r,c))%MOD;
 f[x+1][y+1][p+1][q+1]=f[p+1][q+1][x+1][y+1]=ans;
 f[-x+1][-y+1][-p+1][-q+1]=f[-p+1][-q+1][-x+1][-y+1]=ans;
 return ans;
}
int calc(int x,int y)
{
 int ans=0;
 ans=(ans+dfs(x,y,1,1))%MOD;
 ans=(ans+dfs(x,y,1,-1))%MOD;
 ans=(ans+dfs(x,y,-1,1))%MOD;
 ans=(ans+dfs(x,y,-1,-1))%MOD;
 ans=(ans-dfs(x,y,1,0)+MOD)%MOD;
 ans=(ans-dfs(x,y,-1,0)+MOD)%MOD;
 ans=(ans-dfs(x,y,0,1)+MOD)%MOD;
 ans=(ans-dfs(x,y,0,-1)+MOD)%MOD;
 return ans;
}
int main()
{
 memset(f,-1,sizeof(f));
 scanf("%d%d",&m,&n);
 for(int i=1;i<=m;i++)
  scanf("%s",s[i]+1);
 int ans=0;
 ans=(ans+calc(1,1))%MOD;
 ans=(ans+calc(1,-1))%MOD;
 ans=(ans+calc(-1,1))%MOD;
 ans=(ans+calc(-1,-1))%MOD;
 ans=(ans-calc(1,0)+MOD)%MOD;
 ans=(ans-calc(-1,0)+MOD)%MOD;
 ans=(ans-calc(0,1)+MOD)%MOD;
 ans=(ans-calc(0,-1)+MOD)%MOD;
 printf("%d\n",ans);
 return 0;
}
```

---

## 作者：Salamander (赞：5)

题目就是求每种本质不同的机动路径方案数的平方和。

关键在于平方的处理。

平方相当于是有两个人走机动路径，并且走出的机动路径长得一样。

所以变成了求有两个人走，走出的路径长得一样的总方案数。

数据范围小，直接暴力记忆化搜索。

分左上、左下、右上、右下四个方向算，然后为了防止重复所以减去向左、向右、向上、向下四个方向的方案。

```
#include<bits/stdc++.h>

#define For(i,_beg,_end) for(int i=(_beg),i##end=(_end);i<=i##end;++i)
#define Rep(i,_beg,_end) for(int i=(_beg),i##end=(_end);i>=i##end;--i)

template<typename T>T Max(const T &x,const T &y){return x<y?y:x;}
template<typename T>T Min(const T &x,const T &y){return x<y?x:y;}
template<typename T>int chkmax(T &x,const T &y){return x<y?(x=y,1):0;}
template<typename T>int chkmin(T &x,const T &y){return x>y?(x=y,1):0;}
template<typename T>void read(T &x){
	T f=1;char ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
	for(x=0;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';
	x*=f;
}

const int N=31,mod=1000000009;
int n,m,f[N][N][N][N],g[3][3][3][3],ans;
int dx[4],dy[4],dp[4],dq[4],tp1,tp2;
char str[N][N];

int Calc(int,int);
int Calc(int,int,int,int);
int DP(int,int,int,int);

int main(){
	read(n);read(m);
	For(i,1,n) scanf("%s",str[i]+1);
	
	memset(g,-1,sizeof g);
	
	ans=(ans+Calc(1,1))%mod;
	ans=(ans+Calc(1,-1))%mod;
	ans=(ans+Calc(-1,1))%mod;
	ans=(ans+Calc(-1,-1))%mod;
	
	ans=(ans-Calc(1,0)+mod)%mod;
	ans=(ans-Calc(-1,0)+mod)%mod;
	ans=(ans-Calc(0,1)+mod)%mod;
	ans=(ans-Calc(0,-1)+mod)%mod;
	
	printf("%d\n",ans);
	
	return 0;
}

int Calc(int x,int y){
	int res=0;
	
	res=(res+Calc(x,y,1,1))%mod;
	res=(res+Calc(x,y,1,-1))%mod;
	res=(res+Calc(x,y,-1,1))%mod;
	res=(res+Calc(x,y,-1,-1))%mod;
	
	res=(res-Calc(x,y,1,0)+mod)%mod;
	res=(res-Calc(x,y,-1,0)+mod)%mod;
	res=(res-Calc(x,y,0,1)+mod)%mod;
	res=(res-Calc(x,y,0,-1)+mod)%mod;
	
	return res;
}
int Calc(int x,int y,int p,int q){
	if(g[x+1][y+1][p+1][q+1]!=-1)return g[x+1][y+1][p+1][q+1];
	
	tp1=0;
	For(i,-1,1) if(!i||i==x)
		For(j,-1,1) if((i||j)&&(!j||j==y))
			tp1++,dx[tp1]=i,dy[tp1]=j;
	
	tp2=0;
	For(i,-1,1) if(!i||i==p)
		For(j,-1,1) if((i||j)&&(!j||j==q))
			tp2++,dp[tp2]=i,dq[tp2]=j;
	
	int res=0;
	memset(f,-1,sizeof f);
	For(i,1,n) For(j,1,m) For(k,1,n) For(l,1,m)
		res=(res+DP(i,j,k,l))%mod;
	
	g[x+1][y+1][p+1][q+1]=res;
	g[p+1][q+1][x+1][y+1]=res;
	g[-x+1][-y+1][-p+1][-q+1]=res;
	g[-p+1][-q+1][-x+1][-y+1]=res;
	
	return res;
}
int DP(int x,int y,int p,int q){
	if(str[x][y]!=str[p][q])return 0;
	if(x<1||x>n||y<1||y>m)return 0;
	if(p<1||p>n||q<1||q>m)return 0;
	if(f[x][y][p][q]!=-1)return f[x][y][p][q];
	
	int res=1;
	For(i,1,tp1) For(j,1,tp2)
		res=(res+DP(x+dx[i],y+dy[i],p+dp[j],q+dq[j]))%mod;
	
	return f[x][y][p][q]=res;
}
```

---

## 作者：Mirasycle (赞：1)

$\sum a_i^2$ 可以看成两个人在地图上走，走出的地形相同的方案数。

设 $f_{x,y,s,t}$ 表示第一个人起点是 $(x,y)$，第二个人起点是 $(s,t)$ 的方案数。枚举两个人走路的方向转移即可。

注意形如 $(dx,0)$ 或者 $(0,dy)$ 这样子的移动会造成重复统计，容斥一下即可。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=33;
const int mod=1e9+9;
void add(int &x,int y){ x=x+y>=mod?x+y-mod:x+y; }
void sub(int &x,int y){ x=x>=y?x-y:x-y+mod; }
int dx[4]={0,1,0,1},dx1[4],dx2[4];
int dy[4]={0,0,1,1},dy1[4],dy2[4];
int n,m,ans=0; char c[maxn][maxn];
int f[maxn][maxn][maxn][maxn];
bool chk(int x,int y){ return (1<=x&&x<=n)&&(1<=y&&y<=m); }
int dfs(int x,int y,int s,int t){
	if(c[x][y]!=c[s][t]) return 0;
	if(~f[x][y][s][t]) return f[x][y][s][t];
	int& g=f[x][y][s][t]; g=1;
	for(int i=1;i<=dx1[0];i++){
		for(int j=1;j<=dx2[0];j++){
			int nx=x+dx1[i],ny=y+dy1[i];
			int ns=s+dx2[j],nt=t+dy2[j];
			if(chk(nx,ny)&&chk(ns,nt)) add(g,dfs(nx,ny,ns,nt));
		}
	}
	return g;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>(c[i]+1);
	for(int vx1=-1;vx1<=1;vx1++){
		for(int vy1=-1;vy1<=1;vy1++){
			for(int vx2=-1;vx2<=1;vx2++){
				for(int vy2=-1;vy2<=1;vy2++){
					if((!vx1&&!vy1)||(!vx2&&!vy2)) continue;
					int v=1,sum=0;
					if(!vx1||!vy1) v*=-1;
					if(!vx2||!vy2) v*=-1;
					if(vx1){
						if(vy1){
							dx1[0]=dy1[0]=3;
							for(int i=1;i<=3;i++)
								dx1[i]=vx1*dx[i],dy1[i]=vy1*dy[i];
						}else dx1[dx1[0]=1]=vx1,dy1[dy1[0]=1]=0;
					}else dx1[dx1[0]=1]=0,dy1[dy1[0]=1]=vy1;
					if(vx2){
						if(vy2){
							dx2[0]=dy2[0]=3;
							for(int i=1;i<=3;i++)
								dx2[i]=vx2*dx[i],dy2[i]=vy2*dy[i];
						}else dx2[dx2[0]=1]=vx2,dy2[dy2[0]=1]=0;
					}else dx2[dx2[0]=1]=0,dy2[dy2[0]=1]=vy2;
					memset(f,-1,sizeof(f));
					for(int x=1;x<=n;x++)
						for(int y=1;y<=m;y++)
							for(int s=1;s<=n;s++)
								for(int t=1;t<=m;t++) add(sum,dfs(x,y,s,t));
					if(v==1) add(ans,sum);
					else sub(ans,sum);
				}
			}
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：xuantianhao (赞：1)

# [机动训练](https://www.luogu.com.cn/problem/P3713)

这题的瓶颈，在于把 $a_i^2$ 看作 $\sum\limits_{i=1}^{a_i}\sum\limits_{j=1}^{a_i}1$，然后我们就可以看成“两两相同的机动路径都能贡献 1”。于是我们设 $f_{x1,y1,x2,y2}$ 表示两条起点为 $(x1,y1)$ 和 $(x2,y2)$ 的相同路径的数量，然后分别枚举两条路径的方向（左上/左下/右下/右上）即可 DP。

但需要注意的是，平行于坐标轴的方向会被重复计算，所以我们应该容斥一下。

代码：

```
#include<bits/stdc++.h>
using namespace std;
#define y1 _19260817
#define y2 _17680321
const int mod=1e9+9;
const int N=35;
int n,m,res,d1,d2,lim;
int dx1[N],dy1[N],dx2[N],dy2[N],f[N][N][N][N];
int dx[8]={1,1,0,-1,-1,-1,0,1},dy[8]={0,1,1,1,0,-1,-1,-1};
char s[N][N];
int dfs(int x1,int y1,int x2,int y2){
    int &now=f[x1][y1][x2][y2];
    if(now!=-1) return now;
    if(s[x1][y1]!=s[x2][y2]) return now=0;
    now=1;
    for(int i=1;i<=lim;i++){
        int X1=x1+dx1[i],Y1=y1+dy1[i],X2=x2+dx2[i],Y2=y2+dy2[i];
        if(X1>=1&&X1<=n&&Y1>=1&&Y1<=m&&X2>=1&&X2<=n&&Y2>=1&&Y2<=m){
			(now+=dfs(X1,Y1,X2,Y2))%=mod;
		}
    }
    return now;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%s",s[i]+1);
    for(int d1=0;d1<8;d1++){
		for(int d2=0;d2<8;d2++){
		    memset(f,-1,sizeof(f));
			lim=0;
		    for(int i=(d1&1?(d1+7)%8:d1);(i+7)%8!=(d1&1?(d1+1)%8:d1);i++,i%=8){
				for(int j=(d2&1?(d2+7)%8:d2);(j+7)%8!=(d2&1?(d2+1)%8:d2);j++,j%=8){
					lim++;
					dx1[lim]=dx[i],dy1[lim]=dy[i];
					dx2[lim]=dx[j],dy2[lim]=dy[j];
				}
			}
		    int lam=((d1&1)^(d2&1))?-1:1;
		    for(int x1=1;x1<=n;x1++){
				for(int y1=1;y1<=m;y1++){
					for(int x2=1;x2<=n;x2++){
						for(int y2=1;y2<=m;y2++){
							(res+=(mod+lam*dfs(x1,y1,x2,y2))%mod)%=mod;
						}
					}
				}
			}
		}
	}
    printf("%d\n",res);
    return 0;
}
```

---

## 作者：St_john (赞：1)

压缩一下题面：

给定一张地形图。  
定义机动路径：  
1、它是一条不自交的路径，即路径上任意两个格子都不是同一个。  
2、它的起点和终点处于不同位置，换言之这条路径至少包含 2 个格子。  
3、从起点开始，任何一步只能向不远离终点的方向移动，这里不远离指的是 x 和 y 两个方向都不远离。  
定义机动路径的地形序列：  
将它所经过的地形排成一列。  
求图上((所有机动路径的地形序列)的数量)的平方)和。  
(加括号便于理解)


数量平方和？[[NOI2009] 管道取珠](https://www.luogu.com.cn/problem/P1758)
与这题情况类似，可以对比着看。

根据[[NOI2009] 管道取珠](https://www.luogu.com.cn/problem/P1758)的思路，题面转化为：找两个人随便走机动路径，使得他们的机动路径的地形序列相同。将不同地形序列的方案数求和即可。  
显然，记忆化搜索处理。

 **注意：人可以走八个方向**

利用容斥原理可以有效减少代码量

$$ ans=(ans+calc(1,1))\bmod M;  $$

$$ ans=(ans+calc(1,-1))\bmod M; $$

$$ ans=(ans+calc(-1,1))\bmod M; $$

$$ ans=(ans+calc(-1,-1))\bmod M;$$

枚举斜对角，容。  
斜对角的方向可分解为水平和竖直方向。 

$$ ans=(ans-calc(0,1)+M)\bmod M; $$

$$ ans=(ans-calc(1,0)+M)\bmod M; $$

$$ ans=(ans-calc(-1,0)+M)\bmod M;$$

$$ ans=(ans-calc(0,-1)+M)\bmod M;$$

水平和竖直方向就被多算了1次，斥。

先枚举第一个人的方向，第二个人的方向。  
将每个人的方向拆成水平、竖直、斜对角（如果是的话）。  
跑类似BFS的记忆化搜索。  

 **一些小优化**

1. 第一个人的方向和第二个人的方向可以互换。（人和人等效）  

$$ \mathit{f}_{x+1,y+1,p+1,q+1}=\mathit{f}_{p+1,q+1,x+1,y+1}=ans;  $$

2. 方向正反可以互换。（正图和反图等效）   

$$ \mathit{f}_{-x+1,-y+1,-p+1,-q+1}=\mathit{f}_{-p+1,-q+1,-x+1,-y+1}=ans;   $$




最后贴上代码



```cpp

#include<cstdio>
#include<cstring>
#define Re register int 
#define _for(i,a,b) for(register int i=(a);i<=(b);++i)
#define __for(i,a,b) for(register int i=(a);i>=(b);--i)
#define il inline
#define pc putchar
using namespace std;
typedef long long ll;
const int N=30+10,M=1e9+9,inf=2147483647;
il int re(){
    int x=0;
    bool f=0;
    char ch=getchar();
    while(ch<'0'||ch>'9')
        f|=ch=='-',ch=getchar();
    while(ch>='0'&&ch<='9')
        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return f?-x:x;
}
void pr(int x){
    if(x<0) pc('-'),x=-x;
    if(x>9) pr(x/10);
    pc(x%10|48);
}
int m,n;
char s[N][N];
int f[3][3][3][3],g[N][N][N][N];
int dx[4],dy[4],dp[4],dq[4],tp1,tp2;
int dfs(int x,int y,int p,int q){
//两个人分别走到(x,y)(p,q)地形序列相同的方案数
	if(x<1||x>m||y<1||y>n||p<1||p>m||q<1||q>n) return 0;
	if(s[x][y]!=s[p][q]) return 0;
	if(~g[x][y][p][q]) return g[x][y][p][q];
	int ans=1;
	_for(i,1,tp1)
		_for(j,1,tp2)
			ans=(ans+dfs(x+dx[i],y+dy[i],p+dp[j],q+dq[j]))%M;
	return g[x][y][p][q]=ans;
}
il int solve(int x,int y,int p,int q){
//两条路径的方向分别为(x,y),(p,q)的方案数
	if(~f[x+1][y+1][p+1][q+1]) return f[x+1][y+1][p+1][q+1];
	tp1=tp2=0;
	_for(i,-1,1)
		if(!i||(i==x))
			_for(j,-1,1)
				if((i||j)&&(!j||(j==y)))
					dx[++tp1]=i,dy[tp1]=j;
	_for(i,-1,1)
		if(!i||(i==p))
			_for(j,-1,1)
				if((i||j)&&(!j||(j==q)))
					dp[++tp2]=i,dq[tp2]=j;
    //存储正交分解后的方向
	memset(g,-1,sizeof(g));
	int ans=0;
	_for(i,1,m)
		_for(j,1,n)
			_for(k,1,m)
				_for(l,1,n)
					ans=(ans+dfs(i,j,k,l))%M;
	f[x+1][y+1][p+1][q+1]=f[p+1][q+1][x+1][y+1]=ans;
	f[-x+1][-y+1][-p+1][-q+1]=f[-p+1][-q+1][-x+1][-y+1]=ans;
	return ans;
}
il int calc(int x,int y){
	int ans=0;
	ans=(ans+solve(x,y,1,1))%M;
	ans=(ans+solve(x,y,1,-1))%M;
	ans=(ans+solve(x,y,-1,1))%M;
	ans=(ans+solve(x,y,-1,-1))%M;
	ans=(ans-solve(x,y,0,1)+M)%M;
	ans=(ans-solve(x,y,1,0)+M)%M;
	ans=(ans-solve(x,y,-1,0)+M)%M;
	ans=(ans-solve(x,y,0,-1)+M)%M;
	return ans;	
}

signed main(){
	m=re(),n=re();
	_for(i,1,m)
		scanf("%s",s[i]+1);
	memset(f,-1,sizeof(f));
	int ans=0;
	ans=(ans+calc(1,1))%M;
	ans=(ans+calc(1,-1))%M;
	ans=(ans+calc(-1,1))%M;
	ans=(ans+calc(-1,-1))%M;
	ans=(ans-calc(0,1)+M)%M;
	ans=(ans-calc(1,0)+M)%M;
	ans=(ans-calc(-1,0)+M)%M;
	ans=(ans-calc(0,-1)+M)%M;
	pr(ans);
	return 0;
}
/*

*/
```


---

## 作者：Piggy343288 (赞：0)

关键在于 trick：$\sum a_i^2$ 可以视为两个人走了相同的路径的方案数，证明是容易的：对不同的机动路径求相同的方案数，每种个数为 $a_i$ 的机动路径会产生 $a_i^2$ 种本质相同的走法。

这样的话，我们就可以枚举初始时两个人的方向，再每次枚举走的方向，如果令 $dp[x][y][a][b]$ 为两个人分别走到 $(x, y)$ 和 $(a, b)$ 的本质相同的走法方案数，那么我们随便记忆化搜索一下就可以获得结果。

---


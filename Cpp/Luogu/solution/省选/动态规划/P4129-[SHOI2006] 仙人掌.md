# [SHOI2006] 仙人掌

## 题目背景

#本题不同于bzoj1023
bzoj1023快捷通道：[[SHOI2008] cactus仙人掌图(II)](https://www.luogu.org/problemnew/show/P4244)

## 题目描述

仙人掌图（cactus）是一种无向连通图，它的每条边最多只能出现在一个简单回路（simple cycle）里面。从直观上说，可以把仙人掌图理解为允许存在回路的树。但是仙人掌图和树之间有个本质的不同，仙人掌图可以拥有多个支撑子图（spanning subgraph），而树的支撑子图只有一个（它自身），我们把仙人掌图的支撑子图的数目称为“仙人数”。你的任务就是计算给定图的“仙人数”。

一些关于仙人掌图的举例：

 ![](https://cdn.luogu.com.cn/upload/pic/13241.png) 

第一张图是一个仙人掌图，第二张图的边（2，3）在两个不同的回路里面，所以不是仙人掌图，第三张图不是一个连通图，所以也不是仙人掌图。


以下是对一些术语的解释：


简单回路（simple cycle）：简单回路是原图的一条路径，这条路径的边集构成了回路，回路中顶点只能出现一次。比如对于上例中第二个图来说，它一共有三个简单回路，分别是（4，3，2，1，6，5）、（7，8，9，10，2，3）和（4，3，7，8，9，10，2，1，6，5）


支撑子图（spanning subgraph）：支撑子图也是原图的子图，这种子图可以比原来少一些边，但是不能破坏图的连通性，也不能去除原来图上的任何顶点。“支撑”的概念类似于我们熟知的“最小支撑树”，对于上例中的第一张图来说，任意去除回路I中的图或回路II中的一条边都能构成一个支撑子图，所以它的支撑子图一共有6 + 4 + 6 × 4 + 1 = 35种（注意图自身也是自己的一个子图）


## 样例 #1

### 输入

```
14 3
9 1 2 3 4 5 6 7 8 3
7 2 9 10 11 12 13 10
2 2 14```

### 输出

```
35```

## 样例 #2

### 输入

```
10 2
7 1 2 3 4 5 6 1
6 3 7 8 9 10 2```

### 输出

```
0```

## 样例 #3

### 输入

```
5 1
4 1 2 3 4```

### 输出

```
0```

# 题解

## 作者：Orange_qwq (赞：10)

# 前言

[这里是题目。](https://www.luogu.com.cn/problem/P4129)

主体代码没问题，高精度愣是搞了好久。。。

# 思路


这题我们首先要判断图是不是仙人掌，然后要求出把仙人掌进行删边之后得到的图仍然是连通图的方案数。

先看看这个方案数怎么求。

对于一个仙人掌图进行删边操作，显然我们只能删环上的边。对于每一个环，我们可以选择任意一条边删掉，也可以选择不删。设第 $i$ 个环的边数为 $num_i$，我们可以这样计算得到答案 $ans$：

$$ ans = \prod\limits_{i=1}^{\texttt{环的总数}}num_i + 1$$

然后问题就变成了怎么求环和 $num_i$。

我们可以用 $\text{dfs}$，构造出图的生成树。在 $\text{dfs}$ 的过程中，我们可以记录下每个节点 $x$ 的初始访问时间 $dfn_x$ 和能够往上最大程度追溯到的节点 $low_x$。如果走了返租边（访问到了访问过的节点），那么说明出现了环。

那环的边数呢？我们构造出来生成树，如果有返租边，那么一定是先一直向下访问、构造，然后到了某个节点 $a$ 就突然往上到了另一个节点 $b$。由于我们一直向下构造，再加上一条边回到 $b$，出现了一个环，所以这个环的边数就是我们从 $b$ 一直向下走到 $a$ 走的边数加上这条返租边。这个边数我们可以用深度的差得到，设第 $i$ 个节点的深度为 $dep_i$，则环的边数为 $dep_b - dep_a + 1$。

剩下的问题是怎么判断图是不是仙人掌了。由图观察可知，如果 某个节点的子孙的返租边到了这个节点之上 与 这个节点发出的返租边 的和 $\ge 2$，那么就说明这个节点在两个环里了，该图不是仙人掌。 

您可能要问为啥不用 $\text{bfs}$~~，因为这个菜鸡认为 $\text{bfs}$ 有点难搞，并且比较擅长 $\text{dfs}$。~~ $\text{dfs}$ 可以构造出生成树，比较好处理点或边出现的顺序关系（例如可以处理深度，利用 $dfn$ 和 $low$ 处理环），所以选择用 $\text{dfs}$。

# 代码

>注意最后的答案可能是一个很大很大的数。

我们要用高精度存答案。

可能要用压位高精，因为这个菜鸡 MLE 了好多发，最后把 $base$ 改成 $1e14$ 才过的。

```cpp
void dfs(int x, int fa) {
	++num;
	int cnt = 0;                         // 求该节点所在环的个数 
	dfn[x] = low[x] = ++tot;
	for (int i = he[x]; i; i = ne[i]) {
		int y = e[i];
		if (y == fa) continue; 
		if (!dfn[y]) {                   // 如果是树枝边 
			dep[y] = dep[x] + 1;         // 计算深度 
			dfs(y, x);
			low[x] = min(low[x], low[y]);// 求最大程度追溯的节点 
			if (low[y] < dfn[x]) ++cnt;  // 有个儿子的返租边在 y 之上，注意这里是 < ，题目中说的是边 
		} else if (dfn[y] < dfn[x]) {    // 是返租边 
			if (dep[x] - dep[y] > 1) ans = ans * (dep[x] - dep[y] + 2); // 计算答案 
			++cnt;
			low[x] = min(low[x], dfn[y]);// 求最大程度追溯的节点 
		}
		if (cnt == 2) ok = 0;            // 不是仙人掌 
	}
}
int main() {
	ans = 1;
	n = read(), m = read();
	for (int i = 1, t, lst; i <= m; ++i) {
		t = read(), lst = read();
		for (int j = 2, x; j <= t; ++j) {
			x = read();
			e[++tot] = x, ne[tot] = he[lst], he[lst] = tot;
			e[++tot] = lst, ne[tot] = he[x], he[x] = tot;
			lst = x;
		}
	}
	tot = 0;
	dfs(1, 1);
	if (num != n) ok = 0;               // 不连通    
	if (ok) ans.pr();
	else puts("0");
	return 0;
}
```


# 后记

建议先写主体部分再加高精板子，要不然很难知道是哪里出了问题。用 `int` 能有 $70$ 分。

---

## 作者：chdy (赞：4)

~~补4.15的CF实在自闭 写一道高静冷静一下~~

这道题要求我们求仙人掌的支撑子图的个数.

首先要判定仙人掌。

边在两个或者多个环中，这个条件和边双和点双关系不大。

但是有一种比较简单的方法解决。

树上差分。

构建出dfs树 可以发现如果一条边返祖边形成了环我们就把路径上的边被环覆盖数量+1.

这样的话如果有一条边出现在两个或多个环之中 那么这条边最后的差分值>1.

将边的差分值放到儿子上更好处理。

注意 还要判断图是否连通。

接下来是答案的处理.

把所有环的大小得到 这个也可以通过dfs树得到.

简单的一个dp $f[i][0/1]$表示前i个环所构成的方案数且第i个环使用了没有.

$f[i][0]+=(f[i-1][0]+f[i-1][1])$

$f[i][1]+=(f[i-1][0]+f[i-1][1])\cdot w[i]$

其实维护一个$ans$每次将ans乘上$w[i]+1$即可。

至于高静 压位高精度很好写 速度也很快。

```
const int MAXN=20010,maxn=1000010;
int n,m,len=1,top,flag;
int dis[MAXN],vis[MAXN],q[MAXN],c[MAXN];
int lin[MAXN],ver[maxn<<1],nex[maxn<<1];
ll ans[maxn];
inline void add(int x,int y)
{
	ver[++len]=y;
	nex[len]=lin[x];
	lin[x]=len;
}
inline void dfs(int x,int las)
{
	dis[x]=dis[ver[las^1]]+1;
	vis[x]=1;
	go(x)
	{
		if(i==(las^1))continue;
		if(!vis[tn])dfs(tn,i);
		else
		{
			if(dis[x]>dis[tn])
			{
				q[++top]=dis[x]-dis[tn]+1;
				++c[x];--c[tn];
			}
		}
	}
}
inline void dfs(int x)
{
	vis[x]=1;
	go(x){if(!vis[tn])dfs(tn),c[x]+=c[tn];}
	if(c[x]>1){flag=1;}
}
int main()
{
	freopen("1.in","r",stdin);
	get(n);get(m);
	rep(1,m,i)
	{
		int get(x);int get(y);
		rep(2,x,j)
		{
			int get(z);
			add(y,z);add(z,y);y=z;
		}
	}
	dfs(1,0);
	rep(1,n,i)if(!vis[i])flag=1;else vis[i]=0;
	dfs(1);
	if(flag){puts("0");return 0;}
	ans[0]=1;int le=0;
	rep(1,top,i)
	{
		++q[i];
		rep(0,le,j)ans[j]=ans[j]*q[i];
		rep(1,le+1,j)ans[j]+=ans[j-1]/mod,ans[j-1]%=mod;
		if(ans[le+1]>0)++le;
	}
	int mark=0;
	fep(le,0,i)
	{
		if(mark)printf("%014lld",ans[i]);
		else printf("%lld",ans[i]),mark=1;
	}
	return 0;
}
```

---

## 作者：foreverlasting (赞：3)

好像SHOI2006没这道题吧。。。

切入这题，这题比无归岛还要裸。明摆的仙人掌图，注意一下这题要高精度，我就是因为高精度卡了超级久的。

趁这道题水，就稍微讲解一下仙人掌图的几个性质。

首先，关于如何判断仙人掌图，方法其实是记录环上点的度数。若一个点的度数超过2，则不是仙人掌图。
```
for(res i=x; i!=rt; i=fa[i]) {
        du[i]++;
        if(du[i]>1) {
            puts("0");
            exit(0);
        }
    }
```
然后，环上有几个点，可以通过深度来直接表示。
```
dp[++tot]=deep[x]-deep[rt]+1;
```
最后是tarjan找环
```
low[x]=dfn[x]=++num;
    for(res i=head[x]; ~i; i=edge[i].next) {
        res tox=edge[i].to;
        if(tox==fa[x])continue;
        if(!dfn[tox]) fa[tox]=x,deep[tox]=deep[x]+1,tarjan(tox),low[x]=min(low[x],low[tox]);
        else low[x]=min(low[x],dfn[tox]);
    }
    for(res i=head[x]; ~i; i=edge[i].next) {
        res tox=edge[i].to;
        if(fa[tox]!=x&&dfn[x]<dfn[tox])DP(x,tox);
    }
```
所以这题只用将环上的点的数量全部算出来，然后每个环上点的数量+1再相乘，套上高精度就好了。

code：
```
#include<bits/stdc++.h>
using namespace std;
#define res register int
#define LL long long
#define inf 0x3f3f3f3f
inline int read() {
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9') {
        if(ch=='-')w=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return s*w;
}
inline void write(res x) {
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
//
const int maxn = 10000;
struct bign {
    int d[maxn], len;
    void clean() {
        while(len > 1 && !d[len-1]) len--;
    }
    bign()          {
        memset(d, 0, sizeof(d));
        len = 1;
    }
    bign(int num)   {
        *this = num;
    }
    bign(char* num) {
        *this = num;
    }
    bign operator = (const char* num) {
        memset(d, 0, sizeof(d));
        len = strlen(num);
        for(int i = 0; i < len; i++) d[i] = num[len-1-i] - '0';
        clean();
        return *this;
    }
    bign operator = (int num) {
        char s[20];
        sprintf(s, "%d", num);
        *this = s;
        return *this;
    }
    bign operator + (const bign& b) {
        bign c = *this;
        int i;
        for (i = 0; i < b.len; i++) {
            c.d[i] += b.d[i];
            if (c.d[i] > 9) c.d[i]%=10, c.d[i+1]++;
        }
        while (c.d[i] > 9) c.d[i++]%=10, c.d[i]++;
        c.len = max(len, b.len);
        if (c.d[i] && c.len <= i) c.len = i+1;
        return c;
    }
    bign operator - (const bign& b) {
        bign c = *this;
        int i;
        for (i = 0; i < b.len; i++) {
            c.d[i] -= b.d[i];
            if (c.d[i] < 0) c.d[i]+=10, c.d[i+1]--;
        }
        while (c.d[i] < 0) c.d[i++]+=10, c.d[i]--;
        c.clean();
        return c;
    }
    bign operator * (const bign& b)const {
        int i, j;
        bign c;
        c.len = len + b.len;
        for(j = 0; j < b.len; j++) for(i = 0; i < len; i++)
                c.d[i+j] += d[i] * b.d[j];
        for(i = 0; i < c.len-1; i++)
            c.d[i+1] += c.d[i]/10, c.d[i] %= 10;
        c.clean();
        return c;
    }
    bign operator / (const bign& b) {
        int i, j;
        bign c = *this, a = 0;
        for (i = len - 1; i >= 0; i--) {
            a = a*10 + d[i];
            for (j = 0; j < 10; j++) if (a < b*(j+1)) break;
            c.d[i] = j;
            a = a - b*j;
        }
        c.clean();
        return c;
    }
    bign operator % (const bign& b) {
        int i, j;
        bign a = 0;
        for (i = len - 1; i >= 0; i--) {
            a = a*10 + d[i];
            for (j = 0; j < 10; j++) if (a < b*(j+1)) break;
            a = a - b*j;
        }
        return a;
    }
    bign operator += (const bign& b) {
        *this = *this + b;
        return *this;
    }

    bool operator <(const bign& b) const {
        if(len != b.len) return len < b.len;
        for(int i = len-1; i >= 0; i--)
            if(d[i] != b.d[i]) return d[i] < b.d[i];
        return false;
    }
    bool operator >(const bign& b) const {
        return b < *this;
    }
    bool operator<=(const bign& b) const {
        return !(b < *this);
    }
    bool operator>=(const bign& b) const {
        return !(*this < b);
    }
    bool operator!=(const bign& b) const {
        return b < *this || *this < b;
    }
    bool operator==(const bign& b) const {
        return !(b < *this) && !(b > *this);
    }

    string str() const {
        char s[maxn]= {};
        for(int i = 0; i < len; i++) s[len-1-i] = d[i]+'0';
        return s;
    }
};
istream& operator >> (istream& in, bign& x) {
    string s;
    in >> s;
    x = s.c_str();
    return in;
}
ostream& operator << (ostream& out, const bign& x) {
    out << x.str();
    return out;
}
//
const int M=2*1e6+10,N=1e5+10;
struct mdzz {
    int next,to;
    mdzz() {}
    mdzz(res next,res to):next(next),to(to) {}
} edge[M];
int head[N],cnt;
inline void addedge(res u,res v) {
    edge[++cnt]=mdzz(head[u],v),head[u]=cnt;
    edge[++cnt]=mdzz(head[v],u),head[v]=cnt;
}
int n,m;
int dfn[N],low[N],num,fa[N],deep[N],tot,du[N],dp[N];
int pos,mp[N];
inline void DP(res rt,res x) {
    dp[++tot]=deep[x]-deep[rt]+1;
    for(res i=x; i!=rt; i=fa[i]) {
        du[i]++;
        if(du[i]>1) {
            puts("0");
            exit(0);
        }
    }
}
inline void tarjan(res x) {
    low[x]=dfn[x]=++num;
    for(res i=head[x]; ~i; i=edge[i].next) {
        res tox=edge[i].to;
        if(tox==fa[x])continue;
        if(!dfn[tox]) fa[tox]=x,deep[tox]=deep[x]+1,tarjan(tox),low[x]=min(low[x],low[tox]);
        else low[x]=min(low[x],dfn[tox]);
    }
    for(res i=head[x]; ~i; i=edge[i].next) {
        res tox=edge[i].to;
        if(fa[tox]!=x&&dfn[x]<dfn[tox])DP(x,tox);
    }
}
bign sum=1;
int main() {
    memset(head,-1,sizeof(head));
    n=read(),m=read();
    for(res i=1; i<=m; i++) {
        res k=read(),last=read();
        if(!mp[last])pos++,mp[last]=1;
        for(res j=2; j<=k; j++) {
            res x=read();
            addedge(x,last);
            last=x;
            if(!mp[x])pos++,mp[x]=1;
        }
    }
    if(pos<n) {
        puts("0");
        exit(0);
    }
    tarjan(1);
    for(res i=1; i<=tot; i++)sum=sum*(dp[i]+1);
    //printf("%d %d %d ",tot,dp[1],dp[2]);
    cout<<sum;
    return 0;
}
```

---

## 作者：叫我酵母君 (赞：1)

显然求出每一个环的大小。

Ans=∏ i​ (siz[i]+1)

注意用高精度存答案。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    int ans=0;
    char ch=getchar();
    while(!isdigit(ch))ch=getchar();
    while(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar();
    return ans;
}
const int N=2e4+5,M=1e6+5;
int n,m,first[N],cnt=0,dfn[N],low[N],du[N],dep[N],fa[N],tot=0,siz=0;
struct edge{int v,next;}e[M<<1];
struct bignum{
    int s[N<<1],len;
    bignum(){memset(s,0,sizeof(s)),len=0;}
    inline bignum operator=(int x){
        while(x)s[++len]=x-x/10*10,x/=10;
        return *this;
    }
    inline bignum operator*(const bignum&x){
        bignum ret;
        int maxlen=x.len+len-1;
        for(int i=1;i<=len;++i)for(int j=1;j<=x.len;++j)ret.s[i+j-1]+=s[i]*x.s[j];
        for(int i=1;i<=maxlen;++i)if(ret.s[i]>=10)ret.s[i+1]+=ret.s[i]/10,ret.s[i]=ret.s[i]-ret.s[i]/10*10;
        while(ret.s[maxlen+1]){
            ++maxlen;
            if(ret.s[maxlen]>=10)ret.s[maxlen+1]+=ret.s[maxlen]/10,ret.s[maxlen]=ret.s[maxlen]-ret.s[maxlen]/10*10;
        }
        return ret.len=maxlen,ret;
    }
    inline void output(){for(int i=len;i;--i)printf("%d",s[i]);}
}ans;
inline void add(int u,int v){e[++cnt].v=v,e[cnt].next=first[u],first[u]=cnt;}
inline void calc(int st,int ed){
    for(int i=ed;i!=st;i=fa[i])if(++du[i]==2)puts("0"),exit(0);
    bignum tmp;
    tmp=(dep[ed]-dep[st]+2);
    ans=ans*tmp;
}
inline void tarjan(int p){
    ++siz;
    dfn[p]=low[p]=++tot;
    for(int i=first[p];i;i=e[i].next){
        int v=e[i].v;
        if(v==fa[p])continue;
        if(!dfn[v])dep[v]=dep[p]+1,fa[v]=p,tarjan(v),low[p]=min(low[p],low[v]);
        else low[p]=min(low[p],dfn[v]);
    }
    for(int i=first[p];i;i=e[i].next){
        int v=e[i].v;
        if(fa[v]!=p&&dfn[p]<dfn[v])calc(p,v);
    }
}
int main(){
    n=read(),m=read(),ans.len=ans.s[1]=1;
    while(m--){
        int k=read()-1,x=read(),y;
        while(k--)y=read(),add(y,x),add(x,y),x=y;
    }
    tarjan(1);
    if(siz!=n)puts("0"),exit(0);
    ans.output();
    return 0;
}


```


---


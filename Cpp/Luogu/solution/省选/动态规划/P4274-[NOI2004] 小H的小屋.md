# [NOI2004] 小H的小屋

## 题目描述

小 H 发誓要做 $21$ 世纪最伟大的数学家。他认为，做数学家与做歌星一样，第一步要作好包装，不然本事再大也推不出去。为此他决定先在自己的住所上下功夫，让人一看就知道里面住着一个“未来的大数学家”。

为了描述方便，我们以向东为 $x$ 轴正方向，向北为 $y$ 轴正方向，建立平面直角坐标系。小 H 的小屋东西长为 $100$  Hil（Hil 是小 H 自己使用的长度单位，至于怎样折合成“m”，谁也不知道）。东墙和西墙均平行于 $y$ 轴，北墙和南墙分别是斜率为 $k_1$ 和 $k_2$ 的直线，$k_1$ 和 $k_2$ 为正实数。北墙和南墙的墙角处有很多块草坪，每块草坪都是一个矩形，矩形的每条边都平行于坐标轴。相邻两块草坪的接触点恰好在墙上，接触点的横坐标被称为它所在墙的“分点”，这些分点必须是 $1$ 到 $99$ 的整数。

小 H 认为，对称与不对称性的结合才能充分体现“数学美”。因此，在北墙角要有 $m$ 块草坪，在南墙角要有 $n$ 块草坪，并约定 $m \leq n$。如果记北墙和南墙的分点集合分别为 $X_1$，$X_2$，则应满足 $X_1 \subseteq X_2$，即北墙的任何一个分点一定是南墙的分点。

由于小 H 目前还没有丰厚的收入，他必须把草坪的造价降到最低，即草坪
的占地总面积最小。你能编程帮他解决这个难题吗？

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/y83es0b9.png)
【约定】

○ $2 \leq m \leq n \leq 100$

○ 南北墙距离很远，不会出现南墙草坪和北墙草坪重叠的情况

## 样例 #1

### 输入

```
0.5 0.2 2 4```

### 输出

```
3000.0```

# 题解

## 作者：斯德哥尔摩 (赞：10)

[P4274 [NOI2004]小H的小屋](https://www.luogu.org/problemnew/show/P4274)

考试的题，然后模拟退火成功弄到了$90$分。

不过当然是对着测试数据一次一次滴调玄学参数弄成的。。。

然后$DP$正解被集体$hack$了。。。

主要看的是这个巨佬的题解加上自己的一发$YY$：[链接](http://blog.sina.com.cn/s/blog_86942b1401016m3g.html)。

### $\#1:\text{DP+优化}$：

据说是从$O(n^5)$优化到了$O(n^4)$，然后还很松，进化成了$O(n^3)$。。。

反正蛮神奇的，表示没有看懂优化。。。

有时间再填坑吧，这里主要介绍第二种做法。。。

### $\#2:\quad\text{贪心}$：

我们知道，对于一块长度一定的矩形，将其均分，一定能得到最小面积的矩形分割方案。

证明？如下：

假设当前这个矩形长度为$4x$，并且矩形对角线斜率为$k$。

再假设我们当前要分成两个矩形，那么有两种分法：$x,3x$与$2x,2x$。

显然$$S_1=kx^2+9kx^2=10kx^2>S_2=4x^2+4x^2=8x^2$$

然后分$3,4,5,...$块时依次类推。

于是得证。

当然还可以用不等式证明，比这个更严谨，不过为了通俗易懂我就这么做了。

然后就可以贪心了。

当$n \% m==0$时，直接均分南北墙就是最优值。

而当$n \% m>0$时，应该使其余数尽量均分在每一段上。

所以此时整个图形可以分为$2$段：

前段有$m-n \% m$块北墙草坪，每段对应$\lfloor\frac{n}{m}\rfloor$块南墙草坪；

后段有$n \% m$块北墙草坪，每段对应$\lfloor\frac{n}{m}\rfloor+1$块南墙草坪。

所以可以枚举两段长度，取最小面积。

并且对于其中一段，其分配的面积也应该平均分配，如果余数不为$0$，也要把余数再平均分配。

然后，我们发现：枚举的长度对应的面积是单峰的！

所以当发现一个长度对应的面积大于当前最优解就可以直接跳出循环输出答案了。

然后就做完了。

时间复杂度是$O(100)$，跑的飞起。。。

[记得到本蒟蒻的博客里逛逛哦！](https://www.cnblogs.com/Yangrui-Blog/p/9858877.html)（那个$DP$的更新可能会贴在这里。）

附代码：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#define MAXN 110
using namespace std;
int n,m,lnorth,rnorth,lsouth,rsouth;
double k1,k2,ans=(1LL<<62);//记得开最大最
inline double square(int x){return 1.00*x*x;}
inline double min(double x,double y){return x<y?x:y;}
inline double Area(int num,int len,double k){//求出面积
	if(!num)return 0;//记得特判，防止除0！
	double s=square(len/num)*k*(num-len%num)+square(len/num+1)*k*(len%num);
	return s;
}
void work(){
	if(n%m==0){//第一种情况，直接特判掉就好
		ans=Area(lnorth,100,k1)+Area(lnorth*lsouth,100,k2);
		printf("%.1lf\n",ans);
		return;
	}
	for(int i=lnorth*lsouth;i<=100-rnorth*rsouth;i++){
		double area=Area(lnorth,i,k1)+Area(rnorth,100-i,k1)+Area(lnorth*lsouth,i,k2)+Area(rnorth*rsouth,100-i,k2);
		if(ans>area)ans=area;//更新答案
		else break;//运用单调性
	}
	printf("%.1lf\n",ans);
}
void init(){
	scanf("%lf%lf%d%d",&k1,&k2,&m,&n);
	lnorth=m-n%m;rnorth=n%m;
	lsouth=n/m;rsouth=n/m+1;//求出前段与后段的南北墙的草地块数
}
int main(){//主函数So easy!
	init();
	work();
	return 0;
}

```

---

## 作者：十言 (赞：7)

**贪心贪心！！！！**

   特判如果北墙能整除南墙的话直接均分南北墙即可。
   高中数学好的话可以用基本不等式证明一下。   
//////////////////////////////
   还用了一下分治啦。。。
   废话不多说，上代码。
   ```cpp
//人生第一黑题 
//贪心 
//防伪码 
#include<bits/stdc++.h>
using namespace std;
int n,m,ln,rn,ls,rs;
double k1,k2,ans=123123123;
double S(int x,int y,double k){
    if(x==0)return 0;
    return (y/x)*(y/x)*k*(x-y%x)+(y/x+1)*(y/x+1)*k*(y%x);
}    //求面积 
int main(){
    cin>>k1>>k2>>m>>n;
    ln=m-n%m;rn=n%m;      
    ls=n/m;rs=n/m+1;
    if(n%m==0){
        ans=S(ln,100,k1)+S(ln*ls,100,k2);
        printf("%.1f",ans);
        return 0;
    }   //特判 均分求 （n>m恒成立） 
    for(int i=ln*ls;i<=100-rn*rs;i++){
        double qqq=S(ln,i,k1)+S(rn,100-i,k1)+S(ln*ls,i,k2)+S(rn*rs,100-i,k2);//记录一下 
        if(ans>qqq){
	      ans=qqq;     
         // cout<<"ans="<<ans<<endl;
		}
        else break;
    }
    printf("%.1f",ans);  //输出。，。 
    return 0;
}

```


---

## 作者：Piwry (赞：3)

讲一个另外几篇题解都没注意到的一个细节问题：

在枚举计算面积时，其他题解的代码都是直接对左右的南北两块分开计算，最后合并，并没有考虑**南北草坪的端点是否对齐**：

（变量名有点简略..可以参考文末完整代码理解）

```cpp
double area(int num, double k, int L){
	int a1 =L/num, a2 =L/num+1;
	return k*a1*a1*(num-L%num)+k*a2*a2*(L%num);
}

for(int i =ls*ln; i <= 100-rs*rn; ++i){
	double calc =area(ln, k1, i)+area(ln*ls, k2, i)+area(rn, k1, 100-i)+area(rn*rs, k2, 100-i);
	if(calc < ans) ans =calc;
	else break;
}
```

**这里只是分别均分南北两段，并没有判断端点情况。**

既然没判断，那么**答案就有可能是错的**。可题解代码都过了评测，于是我打算自己造 hack。。

（保证正确的写法：对于每个北块计算和它对齐的南块的面积）

```cpp
double area(int num, double k, int L){
	int a1 =L/num, a2 =L/num+1;
	return k*a1*a1*(num-L%num)+k*a2*a2*(L%num);
}

double area2(int num, int num2, int L){
	int a1 =L/num, a2 =L/num+1;
	return (k1*a1*a1/*左段一块北块面积*/+area(num2, k2, a1)/*左段一块南块面积*/)*(num-L%num)/*左段北块数量*/+(k1*a2*a2+area(num2, k2, a2))*(L%num);
}

for(int i =ls*ln; i <= 100-rs*rn; ++i){
	double calc =area2(ln, ls, i)+area2(rn, rs, 100-i);
	if(calc < ans) ans =calc;
	else break;
}
```


然而对拍程序拍了几十分钟也没发现错误...

于是我尝试手动构造，但比较草的是最后我证出了第一种写法**在结果上是没有问题的**：

.

先考虑均分策略的性质：

单独计算南北面积时，我们为了使面积最小而显然要均分长度

但断点必须是整数，因此划分可能有余数

为了尽量使划分平均，我们将余数拆成 “1” 平均分给每一块

可知北块余数 $r_n =L \pmod {cnt\_north}$ 南块余数 $r_s =L \pmod {cnt\_south}$ ，那么显然只需证 $r_s = r_n\pmod{cnt\_north}$ 就可以保证第一种算法的答案正确（这里可以想象一下，只要**对每个北大块均分南小“余数块”就可以**令南北块边界对齐）

.

分别对于左右段，南块是可以被北块均分的，或者说 $k·cnt\_north = cnt\_south$ ，那么就可以发现 $r_s =k'·cnt\_north+r_n < cnt\_south$，于是上式得证。

---
最后对于两种写法都放下代码吧：

### Code-同其他题解

```cpp
#include <cstdio>

int n, m;
double k1, k2;

double area(int num, double k, int L){
	//if(num == 0) return 0;/*!*/
	int a1 =L/num, a2 =L/num+1;
	return k*a1*a1*(num-L%num/*后面均分到 1*/)+k*a2*a2*(L%num);
}

int main(){
	scanf("%lf%lf%d%d", &k1, &k2, &m, &n);
	if(n%m == 0) return printf("%.1lf", area(m, k1, 100)+area(n, k2, 100)) && 0;
	int ln =m-n%m, ls =n/m, rn =n%m, rs =n/m+1;
	double ans =(long long)(0x7fffffffffffffff);
	for(int i =ls*ln; i <= 100-rs*rn/*个数即为最小点数*/; ++i){
		double calc =area(ln, k1, i)+area(ln*ls, k2, i)+area(rn, k1, 100-i)+area(rn*rs, k2, 100-i);
		if(calc < ans) ans =calc;
		else break;
	}
	printf("%.1lf", ans);
}
```

### Code-对于每块北块计算南块

```cpp
#include <cstdio>

int n, m;
double k1, k2;

double area(int num, double k, int L){
	int a1 =L/num, a2 =L/num+1;
	return k*a1*a1*(num-L%num/*后面均分到 1*/)+k*a2*a2*(L%num);
}

double area2(int num, int num2/*较小的那块*/, int L){
	int a1 =L/num, a2 =L/num+1;
	return (k1*a1*a1+area(num2, k2, a1))*(num-L%num)+(k1*a2*a2+area(num2, k2, a2))*(L%num);
}

int main(){
	scanf("%lf%lf%d%d", &k1, &k2, &m, &n);
	if(n%m == 0) return printf("%.1lf", area(m, k1, 100)+area(n, k2, 100)) && 0;
	int ln =m-n%m, ls =n/m, rn =n%m, rs =n/m+1;
	double ans =(long long)(0x7fffffffffffffff);
	for(int i =ls*ln; i <= 100-rs*rn/*个数即为最小点数*/; ++i){
		double calc =area2(ln, ls, i)+area2(rn, rs, 100-i);
		if(calc < ans) ans =calc;
		else break;
	}
	printf("%.1lf", ans);
}
```


---

## 作者：人殇物已非 (赞：1)

## ~~吹爆贪心！~~
这个题上手一看，emmmm，好像，有点难诶。我怎么知道你们什么时候能刚刚好**北墙的任何一个分点一定是南墙的分点**。（yy：难道说不存在无解么，如果你块的个数比较恶心。）**结果还真的不会存在无解，因为每个块的边长都是随便多长都行。。**

难道说是枚举每一个块？哦豁$O(100^{100})$，然后突然脑子一抽就想着肯定是均分的时候最优（仔细一下发现不知道为什么但是就是好有道理的样子呀！不然这题还能怎么做）。

然后看看难度woc怎么是黑题，好难好难好难。。~~难道说是用数学方法生成函数什么的解出一堆的x作为边长么（被数学洗脑的后果。）~~

### ~~然后我就以为不可做题了。~~

**我真傻，真的。。**

所以说每次要自己认真思考，有时候脑子一抽想到的就是正解。。。。

然后，这题还剩下什么呢，好像没什么了，$n\%m==0$的时候，直接算，$n\%m!=0$的时候把余数分成好多好多个$1$分给其他的块，完美。

哦对，然后因为需要对齐，所以不能说直接就给一些块多1就好了，还需要枚举一下没有$1$的块和有$1$的块各自的边长来满足对齐（同种类块边长需要相等，此时最优）
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ln,rn,ls,rs;
double k1,k2,ans=1e9;
double S(int x,int y,double k){//这一段的个数为x，总长度为y，斜率是k 
    if(x==0)return 0;
    return (y/x)/*宽*/*(y/x)*k/*长*/*(x-y%x)/*个数*/+(y/x+1)/*宽*/*(y/x+1)/*长*/*k*(y%x)/*个数*/;
}//这里的分法也是下述分法 
int main(){
    cin>>k1>>k2>>m>>n;//N:north,S:south
    ln=m-n%m;rn=n%m;      
    ls=n/m;rs=n/m+1;//两部分：ln个N块每个对应ls个S块，rn个N块每个对应rs个S块（本题所有的分法都是这样）
	//根据贪心，这样最优 
    if(n%m==0){
        ans=S(ln,100,k1)+S(ln*ls,100,k2);//此时相当于两部分是一样的，所以不用枚举边长 
        printf("%.1f",ans);
        return 0;
    }
    for(int i=ln*ls;i<=100-rn*rs;i++){
        double tmp=S(ln,i,k1)+S(rn,100-i,k1)+S(ln*ls,i,k2)+S(rn*rs,100-i,k2);
        if(ans>tmp){
          ans=tmp;     
        }
        else break;//看大佬说是单峰，哦吼，本蒟蒻就不知道为什么，不过单峰就单峰吧正好优化一下。
    }
    printf("%.1f",ans); 
    return 0;
}
```

---

## 作者：phoebuszhu (赞：0)

### P0. 前言

竟然题解区没有 dp 的题解，那我来写一篇吧。。。

### P1. 题目简述

现在有两段长度为 $100$ 的墙，要求北墙被分为 $m$ 段、南墙被分为 $n$，划分到的面积的最小值。

其中面积公式为：$S=k\times l^2$，其中 $l$ 为一段的长度。

### P2. 思路简述

很明显的 dp 题啊，$n,m$ 只有 $100$，考虑暴力 dp。

设 $f(i,j,L)$ 为长度为 $L$ 的墙，北段分了 $i$ 次，南段分了 $j$ 次的面积最小值。

暴力转移如下：

$$f(i,j,L)=f(i-1,j-k,L')+k_1\times l^2+k_2\times (\sum \limits_{i=1}^nw(i)^2)$$；

其中 $l$ 为长度，$w(i)$ 为 $L-L'$ 被分成 $k$ 段的面积最小值。

发现一个性质，分面积的最小值的方式一定是均分。

我们不妨先用两个数代替证明：

设上下段分为 $a,b$。

那么取 $a,b$ 的平均数 $\dfrac{a+b}{2}$。

那么第一种方式，答案为：$a^2+b^2$；

第二种方式，答案为：$2\times \dfrac{a^2+2ab+b^2}{4}=\dfrac{a^2+2ab+b^2}{2}$。

两边同乘以 $2$ 得：$2a^2+2b^2$ 和 $a^2+2ab+b^2$。

也就是说，$a^2+b^2$ 和 $2ab$ 比大小。

无疑，第二种更小。

可以继续归纳到 $n$ 个数，这个留给读者自行证明。

那么也就是说，$L(i)$ 是可以均分取到最小值的，也就是说，后面那堆东西是可以 $O(1)$ 解决的。

乍一看，好像复杂度是 $O(n^5)$ 的？

我们可以先枚举 $L$，接下来枚举 $i,j$ 的过程只需要对 $1\le i,j\le L$ 的枚举，随后枚举 $k,L'$ 的也只需要对于 $\dfrac{L}{k}$ 和 $L$ 的范围进行枚举。

也就是说，枚举 $i,L'$ 需要的复杂度是 $L$，枚举 $L$ 和 $j$ 和 $k$ 需要的复杂度也是 $L$，总复杂度是 $O(n^4)$。

有人要问了，$L'$ 为什么只需要和 $i$ 拼成 $100$。

很简单的逻辑，我们只需要枚举 $L-L'$ 即可，这个一定小于 $\dfrac{L}{i}$。

### P3. 代码展示


```cpp
#include<bits/stdc++.h>
using namespace std;
double f[110][110][110],w[110][110];
int main(){
	double k1,k2;
	int m,n;
	cin>>k1>>k2>>m>>n;
	for(int i=1;i<=100;++i)
		for(int j=1;j<=i;++j)
			w[i][j]=k2*(i/j)*(i/j)*(j-i%j)+k2*(i/j+1)*(i/j+1)*(i%j);
	for(int i=0;i<=100;++i)
		for(int j=0;j<=100;++j)
			for(int k=0;k<=100;++k)
				f[i][j][k]=10000000000;
	f[0][0][0]=0;
	for(int L=1;L<=100;++L)
		for(int i=1;i<=min(L,m);++i)
			for(int j=i;j<=min(L,n);++j)
				for(int dt=1;dt<=L/i;++dt)
					for(int k=1;k<=min(dt,j);++k)
						f[i][j][L]=min(f[i][j][L],f[i-1][j-k][L-dt]+k1*dt*dt+w[dt][k]);
	cout<<fixed<<setprecision(1)<<f[m][n][100]<<endl;
}
```

---


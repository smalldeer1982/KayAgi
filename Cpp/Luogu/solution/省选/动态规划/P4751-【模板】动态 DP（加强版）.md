# 【模板】动态 DP（加强版）

## 题目背景

树剖常数小！跑不满！

shadowice1984 为了向你证明他能卡树剖并且会卡树剖从而出了这道毒瘤题。

保证答案均在 `int` 范围内。

然后就被离线算法针对了……

因此这道题变成了强制在线。


## 题目描述

同 [P4719](https://www.luogu.com.cn/problem/P4719)。

给定一个 $n$ 个点的带点权树，进行 $m$ 次修改点权的操作。

你需要在每次修改之后输出树上最大带权独立集的权值之和。

## 说明/提示

数据范围 $n \leq 1 \times 10^6$，$m \leq 3 \times 10^6$。保证任意时刻各点点权的绝对值 $\leq 100$。

时限为标程的二倍，如果卡常数的话请使用 `int` 类型。

## 样例 #1

### 输入

```
10 10
-11 80 -99 -76 56 38 92 -51 -34 47
2 1
3 1
4 3
5 2
6 2
7 1
8 2
9 4
10 7
9 -44
184 -17
184 98
185 -58
153 48
190 99
296 -61
253 76
329 14
264 93
```

### 输出

```
186
186
190
145
189
288
244
320
258
304```

# 题解

## 作者：Wuyanru (赞：65)

前置芝士：[P4719](https://www.luogu.com.cn/problem/P4719)

~~众所周知，出题人为了卡离线算法和 $ O(n\log^2n) $ 的树剖出了这题。~~

看到现在的题解里面没有一个是树剖的 $ O(2^3\times n\log^2n) $ 做法，那么我就来写一篇题解教大家如何卡常吧。

首先我把我的 P4719 代码贴上来。

```
#include<cstdio>
namespace something_useful
{
	inline int max(int a,int b){ return a>b?a:b;}
	inline int read()
	{
		int s=0,w=1;char ch;
		while((ch=getchar())>'9'||ch<'0') if(ch=='-') w=-1;
		while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
		return s*w;
	}
	struct line
	{
		int nx;
		int to;
	};
	struct graph
	{
		int head[100001];
		line a[200001];
		int tot;
		void ad(int u,int v)
		{
			tot++;
			a[tot].to=v;
			a[tot].nx=head[u];
			head[u]=tot;
		}
		void add(int u,int v){ ad(u,v),ad(v,u);}
		int st(int num){ return head[num];}
		int to(int num){ return a[num].to;}
		int nx(int num){ return a[num].nx;}
	};
	struct mat
	{
		int a[3][3];
		int m,n;
		mat (){ a[1][1]=a[1][2]=a[2][1]=a[2][2]=0;}
		mat (int mm,int nn){ m=mm,n=nn,mat();}
		mat operator * (mat b)
		{
			mat ans;
			for(int i=1;i<=2;i++)
				for(int k=1;k<=2;k++)
				{
					int s=a[i][k];
					for(int j=1;j<=2;j++)
						ans.a[i][j]=max(ans.a[i][j],s+b.a[k][j]);
				}
			return ans;
		}
		void operator = (mat b)
		{
			for(int i=1;i<=2;i++)
				for(int j=1;j<=2;j++)
					a[i][j]=b.a[i][j];
		}
	};
}
using namespace something_useful;
int f[100001][2];
int hson[100001];
int siz[100001];
int dfn[100001];
int top[100001];
int end[100001];
int rk[100001];
int fa[100001];
mat t[400001];
mat g[100001];
int a[100001];
graph in;
int tot;
int n,m;
void read_all()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<n;i++) in.add(read(),read());
}
void dfs(int num)
{
	siz[num]=1;f[num][1]=a[num];
	for(int i=in.st(num);i;i=in.nx(i))
	{
		int p=in.to(i);
		if(p==fa[num]) continue;
		fa[p]=num;dfs(p);
		siz[num]+=siz[p];
		if(siz[p]>siz[hson[num]]) hson[num]=p;
		f[num][1]+=f[p][0],f[num][0]+=max(f[p][1],f[p][0]);
	}
}
void dfs(int num,int t)
{
	top[num]=t;
	dfn[num]=++tot;
	rk[tot]=num;
	end[t]=tot;
	if(hson[num]) dfs(hson[num],t);
	g[num].a[2][2]=-0x3f3f3f3f;g[num].a[2][1]=a[num];
	for(int i=in.st(num);i;i=in.nx(i))
	{
		int p=in.to(i);
		if(p==fa[num]||p==hson[num]) continue;
		dfs(p,p);
		g[num].a[1][1]+=max(f[p][0],f[p][1]);
		g[num].a[2][1]+=f[p][0];
	}
	g[num].a[1][2]=g[num].a[1][1];
}
void push_up(int p){ t[p]=t[p*2]*t[p*2|1];}
void build(int p,int pl,int pr)
{
	if(pl==pr)
	{
		t[p]=g[rk[pl]];
		return ;
	}
	int mid=(pl+pr)>>1;
	build(p*2,pl,mid);
	build(p*2|1,mid+1,pr);
	push_up(p);
}
void init()
{
	dfs(1);dfs(1,1);
	build(1,1,n);
}
mat get(int p,int pl,int pr,int l,int r)
{
	if(l<=pl&&pr<=r) return t[p];
	int mid=(pl+pr)>>1;
	if(mid<l) return get(p*2|1,mid+1,pr,l,r);
	if(r<=mid) return get(p*2,pl,mid,l,r);
	return get(p*2,pl,mid,l,r)*get(p*2|1,mid+1,pr,l,r);
}
void change(int p,int pl,int pr,int x)
{
	if(pl==pr){ t[p]=g[rk[x]];return ;}
	int mid=(pl+pr)>>1;
	if(x<=mid) change(p*2,pl,mid,x);
	else change(p*2|1,mid+1,pr,x);
	push_up(p);
}
void update(int pos,int val)
{
	g[pos].a[2][1]+=val-a[pos];
	a[pos]=val;
	while(pos)
	{
		mat last=get(1,1,n,dfn[top[pos]],end[top[pos]]);
		change(1,1,n,dfn[pos]);
		mat now=get(1,1,n,dfn[top[pos]],end[top[pos]]);
		pos=fa[top[pos]];
		g[pos].a[1][1]+=max(now.a[1][1],now.a[2][1])-max(last.a[1][1],last.a[2][1]);
		g[pos].a[1][2]=g[pos].a[1][1];
		g[pos].a[2][1]+=now.a[1][1]-last.a[1][1];
	}
}
void run()
{
	int pos=read(),val=read();
	update(pos,val);
	mat ans=get(1,1,n,1,end[1]);
	printf("%d\n",max(ans.a[1][1],ans.a[2][1]));
}
int main()
{
	read_all();
	init();
	for(int i=1;i<=m;i++) run();
	return 0;
}
```

前面的那个 namespace 是我的链式前向星模板和快读，大家可以不用管它。

下面我们来看哪里需要更改。

第一步：数组大小

原题的数据范围是 $ n\le 10^5 $，现在被改成了 $ n\le 10^6 $，对应的，我们的数组大小也要开大十倍。

注意：不要忘了线段树的大小要开到 $ 4\times 10^6 $。

第二步：强制在线

注意到这一题是强制在线的，所以我们在读入节点编号的时候要异或上一次的答案。

注意：
1.  只有节点编号要异或，修改的值是不用的；

2.  别忘了给 $ lastans $ 赋初值以及每次算完答案要赋值。

至此，我们的修改部分完成了。

提交之后，你有可能会发现 TLE 了（我挂了一个点）或者是 MLE。

当然，到这里大家可以选择第十个点暴力直接 A 题，但是本着学习新技巧而不是 A 题的态度，我们开始卡常。

因为比较简单，所以先讲一下 MLE 的解决方案。

第一步：矩阵数组

本题的矩阵是 $ 2\times2 $ 的，所以我们只需要把数组大小改成类似于 `a[2][2]` 就可以了，这样子与原来的 `a[3][3]` 对比，矩阵的空间会小到原来的一半。

第二步：存图

不知道有多少小伙伴用的是 vector，如果还是 MLE，可以考虑改成链式前向星，节省空间。

注意：如果你算过了你的空间确实不会炸，而且基本没有点 AC，那么**大概率**是写挂了，建议看一眼有没有无限递归。

先来我们来讲 TLE 解决方案。

第一步：读入

使用快读可以减少时间复杂度，大家应该都会，这里不细说。

第二步：矩阵乘法

本题的矩阵是 $ 2\times2 $ 的，所以我们可以不使用循环，直接将矩阵乘法展开，代码放到下面：

```
mat operator * (mat b)
{
	mat ans;
	ans.a[0][0]=max(a[0][0]+b.a[0][0],a[0][1]+b.a[1][0]);
	ans.a[1][0]=max(a[1][0]+b.a[0][0],a[1][1]+b.a[1][0]);
	ans.a[0][1]=max(a[0][0]+b.a[0][1],a[0][1]+b.a[1][1]);
	ans.a[1][1]=max(a[1][0]+b.a[0][1],a[1][1]+b.a[1][1]);
	return ans;
}
```

第三步：线段树

这是卡常卡的最多的一部分。

使用树剖的时候，时间复杂度的瓶颈在于对某个点权值修改的部分，现在我们对这部分进行卡常。

可以发现，我们在查询线段树的时候每次只会查找一个重链的矩阵之积，考虑对每一个重链单独开一个线段树，以减少常数。

有人可能会问：你这不就是一个水到极致，基本没用的常数优化吗，给你一条链不就相当于啥都没有。

真的是这样吗？我们来看一眼变化。

原来的代码：

```
void update(int pos,int val)
{
	g[pos].a[2][1]+=val-a[pos];
	a[pos]=val;
	while(pos)
	{
		mat last=get(1,1,n,dfn[top[pos]],end[top[pos]]);
		change(1,1,n,dfn[pos]);
		mat now=get(1,1,n,dfn[top[pos]],end[top[pos]]);
		pos=fa[top[pos]];
		g[pos].a[1][1]+=max(now.a[1][1],now.a[2][1])-max(last.a[1][1],last.a[2][1]);
		g[pos].a[1][2]=g[pos].a[1][1];
		g[pos].a[2][1]+=now.a[1][1]-last.a[1][1];
	}
}
```

更改过后的代码：

```
void update(int pos,int val)
{
	g[pos].a[1][0]+=val-a[pos];
	a[pos]=val;
	while(pos)
	{
		mat last=t[root[top[pos]]];
		change(root[top[pos]],dfn[top[pos]],end[top[pos]],dfn[pos]);
		mat now=t[root[top[pos]]];
		pos=fa[top[pos]];
		g[pos].a[0][0]+=max(now.a[0][0],now.a[1][0])-max(last.a[0][0],last.a[1][0]);
		g[pos].a[0][1]=g[pos].a[0][0];
		g[pos].a[1][0]+=now.a[0][0]-last.a[0][0];
	}
}
```

注意一下：你可能会发现修改的时候矩阵的位置不一样，这是因为我原来 MLE 过，然后把矩阵从 $ 3\times 3 $ 改成 $ 2\times 2 $ 了。

有什么变化呢？

没错！循环中少了两次函数的调用！

至此，我们的树剖已经可以通过这道题。

最后，给大家放上完整代码：

```
#include<cstdio>
namespace something_useful
{
	inline int max(int a,int b){ return a>b?a:b;}
	inline int read()
	{
		int s=0,w=1;char ch;
		while((ch=getchar())>'9'||ch<'0') if(ch=='-') w=-1;
		while(ch>='0'&&ch<='9') s=s*10+(ch^48),ch=getchar();
		return s*w;
	}
	struct line
	{
		int nx;
		int to;
	};
	struct graph
	{
		int head[1000001];
		line a[2000000];
		int tot;
		void ad(int u,int v)
		{
			tot++;
			a[tot].to=v;
			a[tot].nx=head[u];
			head[u]=tot;
		}
		void add(int u,int v){ ad(u,v),ad(v,u);}
		int st(int num){ return head[num];}
		int to(int num){ return a[num].to;}
		int nx(int num){ return a[num].nx;}
	};
	struct mat
	{
		int a[2][2];
		mat operator * (mat b)
		{
			mat ans;
			ans.a[0][0]=max(a[0][0]+b.a[0][0],a[0][1]+b.a[1][0]);
			ans.a[1][0]=max(a[1][0]+b.a[0][0],a[1][1]+b.a[1][0]);
			ans.a[0][1]=max(a[0][0]+b.a[0][1],a[0][1]+b.a[1][1]);
			ans.a[1][1]=max(a[1][0]+b.a[0][1],a[1][1]+b.a[1][1]);
			return ans;
		}
	};
}
using namespace something_useful;
int f[1000001][2];
int hson[1000001];
int root[1000001];
int siz[1000001];
int dfn[1000001];
int top[1000001];
int end[1000001];
int rk[1000001];
int fa[1000001];
int ls[4000001];
int rs[4000001];
mat t[4000001];
mat g[1000001];
int a[1000001];
graph in;
int last;
int tot;
int n,m;
int nod;
void read_all()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<n;i++) in.add(read(),read());
}
void dfs(int num)
{
	siz[num]=1;f[num][1]=a[num];
	for(int i=in.st(num);i;i=in.nx(i))
	{
		int p=in.to(i);
        if(p==fa[num]) continue;
    	fa[p]=num;dfs(p);
    	siz[num]+=siz[p];
    	if(siz[p]>siz[hson[num]]) hson[num]=p;
    	f[num][1]+=f[p][0],f[num][0]+=max(f[p][1],f[p][0]);
	}
}
void dfs(int num,int t)
{
	top[num]=t;
	dfn[num]=++tot;
	rk[tot]=num;
	end[t]=tot;
	if(hson[num]) dfs(hson[num],t);
	g[num].a[1][1]=-0x3f3f3f3f;g[num].a[1][0]=a[num];
	for(int i=in.st(num);i;i=in.nx(i))
	{
		int p=in.to(i);
        if(p==fa[num]||p==hson[num]) continue;
    	dfs(p,p);
    	g[num].a[0][0]+=max(f[p][0],f[p][1]);
    	g[num].a[1][0]+=f[p][0];
	}
	g[num].a[0][1]=g[num].a[0][0];
}
void push_up(int p){ t[p]=t[ls[p]]*t[rs[p]];}
void build(int &p,int pl,int pr)
{
	p=++nod;
	if(pl==pr)
	{
		t[p]=g[rk[pl]];
		return ;
	}
	int mid=(pl+pr)>>1;
	build(ls[p],pl,mid);
	build(rs[p],mid+1,pr);
	push_up(p);
}
void init()
{
	dfs(1);dfs(1,1);
	for(int i=1;i<=n;i++) if(top[i]==i) build(root[i],dfn[i],end[i]);
}
mat get(int p,int pl,int pr,int l,int r)
{
	if(l<=pl&&pr<=r) return t[p];
	int mid=(pl+pr)>>1;
	if(mid<l) return get(rs[p],mid+1,pr,l,r);
	if(r<=mid) return get(ls[p],pl,mid,l,r);
	return get(ls[p],pl,mid,l,r)*get(rs[p],mid+1,pr,l,r);
}
void change(int p,int pl,int pr,int x)
{
	if(pl==pr){ t[p]=g[rk[x]];return ;}
	int mid=(pl+pr)>>1;
	if(x<=mid) change(ls[p],pl,mid,x);
	else change(rs[p],mid+1,pr,x);
	push_up(p);
}
void update(int pos,int val)
{
	g[pos].a[1][0]+=val-a[pos];
	a[pos]=val;
	while(pos)
	{
		mat last=t[root[top[pos]]];
		change(root[top[pos]],dfn[top[pos]],end[top[pos]],dfn[pos]);
		mat now=t[root[top[pos]]];
		pos=fa[top[pos]];
		g[pos].a[0][0]+=max(now.a[0][0],now.a[1][0])-max(last.a[0][0],last.a[1][0]);
		g[pos].a[0][1]=g[pos].a[0][0];
		g[pos].a[1][0]+=now.a[0][0]-last.a[0][0];
	}
}
void run()
{
	int pos=read()^last,val=read();
	update(pos,val);
	mat ans=t[root[1]];
	printf("%d\n",last=max(ans.a[0][0],ans.a[1][0]));
}
int main()
{
	read_all();
	init();
	for(int i=1;i<=m;i++) run();
	return 0;
}
```

感谢观看！

---

## 作者：Great_Influence (赞：28)

你们可以看看这个[宝贝](https://www.cnblogs.com/RabbitHu/p/9112811.html)来了解一下这个诡异的做法。

首先，需要前置技能[动态dp](https://www.luogu.org/problemnew/show/P4719)，然后才能够做这道题。

很明显，利用树剖套线段树直接维护矩阵的时间复杂度是$O(2^3qlog^2n)$的。再数据恶意卡的情况下，计算出来的复杂度高达$1e9$级，再算上线段树的巨大常数，基本上直接就$TLE$了。这时，我们需要一种更靠谱的复杂度来维护。

根据经验，在维护内容简单的情况下，如果某个信息可以用$splay$做到和线段树同级的维护，那么在$LCT$的意义下，是可以将两个$log$优化到一个$log$的。

那么我们的基本思路就出来了:就是不使用树剖套线段树来维护矩阵，而是改为使用$LCT$来维护矩阵。这样的时间复杂度就由$O(2^3q\log^2 n)$优化至$O(2^3q\log n)$。

不过$LCT$的常数过于巨大，并且树的形态固定，我们也不需要动态来维护一棵树。我们可以使用与$LCT$类似的数据结构来维护，同时也保证它的复杂度。

我们采用一棵普通的二叉搜索树来维护这个结构。其结构与$LCT$相似，存在轻边和重边之分，且一段重链用相连的一段二叉搜索树维护，而轻边直接用轻边挂在父亲节点下。这样，我们只要保证这个结构的深度不超过$O(\log n)$级，我们的复杂度就是正确的。

这时就有一个很简单的构造思想了。先将整棵树树链剖分(重链剖分)，再对于每个点，记录该点的轻子树的$size$之和+1，作为他的权。然后对于当前重链，记录它的加权重心，作为该重链的根，然后向两边递归建树。轻边还是一样挂在其父亲上。这样可以将树高严格卡在$O(\log n)$内。证明非常简单，每个点的父亲子树大小**至少是它自己子树大小的2倍**。这样经过不超过$\log n$次后，其子树大小会变成$n$。

代码(仅供参考)：

```cpp
#include<bits/stdc++.h>
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
#define pb push_back
#define Chkmax(a,b) a=a>b?a:b
#define Chkmin(a,b) a=a<b?a:b
#define mx(a,b) (a>b?a:b)
typedef unsigned long long uint64;
typedef unsigned int uint32;
typedef long long ll;
using namespace std;

namespace IO
{
    const uint32 Buffsize=1<<15,Output=1<<24;
    static char Ch[Buffsize],*St=Ch,*T=Ch;
    inline char getc()
    {
        return((St==T)&&(T=(St=Ch)+fread(Ch,1,Buffsize,stdin),St==T)?0:*St++);
    }
    static char Out[Output],*nowps=Out;

    inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}
    

    template<typename T>inline void read(T&x)
    {
        x=0;static char ch;T f=1;
        for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;
        for(;isdigit(ch);ch=getc())x=x*10+(ch^48);
        x*=f;
    }

    template<typename T>inline void write(T x,char ch='\n')
    {
        if(!x)*nowps++=48;
        if(x<0)*nowps++='-',x=-x;
        static uint32 sta[111],tp;
        for(tp=0;x;x/=10)sta[++tp]=x%10;
        for(;tp;*nowps++=sta[tp--]^48);
        *nowps++=ch;
    }
}
using namespace IO;

inline void file()
{
#ifndef ONLINE_JUDGE
    freopen("Ddp++.in","r",stdin);
    freopen("Ddp++.out","w",stdout);
#endif
}

const int inf=0x3f3f3f3f,MAXN=1e6+7;

struct matrix
{
    int s[2][2];
    matrix(){s[0][0]=s[0][1]=s[1][0]=s[1][1]=-inf;}

    matrix(int x){s[0][0]=s[1][1]=0;s[0][1]=s[1][0]=-inf;}

    friend matrix operator*(matrix a,matrix b)
    {
        matrix c;
        Chkmax(c.s[0][0],b.s[0][0]+a.s[0][0]);
        Chkmax(c.s[0][0],b.s[0][1]+a.s[1][0]);
        Chkmax(c.s[0][1],b.s[0][0]+a.s[0][1]);
        Chkmax(c.s[0][1],b.s[0][1]+a.s[1][1]);
        Chkmax(c.s[1][0],b.s[1][0]+a.s[0][0]);
        Chkmax(c.s[1][0],b.s[1][1]+a.s[1][0]);
        Chkmax(c.s[1][1],b.s[1][0]+a.s[0][1]);
        Chkmax(c.s[1][1],b.s[1][1]+a.s[1][1]);
        return c;
    }

    inline int getmx()
    {return mx(mx(s[0][0],s[0][1]),mx(s[1][0],s[1][1]));}
};

static int n,m;

static int sz[MAXN],son[MAXN],g[MAXN][2],w[MAXN];

static struct edge
{
    int v,nxt;
}p[MAXN<<1];
static int head[MAXN],e;

inline void add(int u,int v){p[++e]={v,head[u]};head[u]=e;}

void dfs(int u)
{
    sz[u]=1;g[u][1]=w[u];
    for(register int v=head[u];v;v=p[v].nxt)if(!sz[p[v].v])

    {
        dfs(p[v].v);sz[u]+=sz[p[v].v];
        if(sz[p[v].v]>sz[son[u]])son[u]=p[v].v;
        g[u][0]+=mx(g[p[v].v][0],g[p[v].v][1]);
        g[u][1]+=g[p[v].v][0];
    }
}

namespace bst
{
    static matrix W[MAXN],S[MAXN];
    static int so[MAXN][2],fa[MAXN],sta[MAXN],tp;
    static int ssz[MAXN],rt;

    inline void update(int u){S[u]=S[so[u][0]]*W[u]*S[so[u][1]];}

    int build_tree(int l,int r)
    {
        if(l>r)return 0;
        static int tot;tot=0;Rep(i,l,r)tot+=ssz[sta[i]];
        for(register int i=l,cnt=ssz[sta[i]];i<=r;++i,cnt+=ssz[sta[i]])
            if(cnt*2>=tot)
            {
                int rs=build_tree(l,i-1),ls=build_tree(i+1,r);
                so[sta[i]][0]=ls,so[sta[i]][1]=rs;
                fa[ls]=fa[rs]=sta[i];update(sta[i]);
                return sta[i];
            }
    }

    inline void getpoi(int u)
    {W[u].s[0][0]=W[u].s[0][1]=**(g+u);W[u].s[1][0]=*(*(g+u)+1);}

    int build(int top,int fr)
    {
        for(int t=top;t;fr=t,t=son[t])
        {
            for(register int v=head[t];v;v=p[v].nxt)
                if(p[v].v^son[t]&&p[v].v^fr)
                    fa[build(p[v].v,t)]=t;
            getpoi(t);
        }
        tp=0;
        for(int t=top;t;t=son[t])
            sta[++tp]=t,ssz[t]=sz[t]-sz[son[t]];
        return build_tree(1,tp);
    }

    bitset<MAXN>isr;

    void modify(int u,int val)
    {
        g[u][1]+=val-w[u];
        w[u]=val;
        static int dp0[2],dp1[2];
        for(;u;u=fa[u])
        {
            dp0[0]=mx(S[u].s[0][0],S[u].s[0][1]);
            dp0[1]=mx(S[u].s[1][0],S[u].s[1][1]);
            getpoi(u);update(u);
            dp1[0]=mx(S[u].s[0][0],S[u].s[0][1]);
            dp1[1]=mx(S[u].s[1][0],S[u].s[1][1]);
            if(isr.test(u))
            {
                g[fa[u]][0]+=mx(dp1[0],dp1[1])-mx(dp0[0],dp0[1]);
                g[fa[u]][1]+=dp1[0]-dp0[0];
            }
        }
    }
}
void dfs(int u,int fr)
{
    if(!son[u])return;
    g[u][0]-=mx(g[son[u]][0],g[son[u]][1]);
    g[u][1]-=g[son[u]][0];
    for(register int v=head[u];v;v=p[v].nxt)if(p[v].v^fr)dfs(p[v].v,u);
}
using namespace bst;

inline void init()
{
    read(n);read(m);
    Rep(i,1,n)read(w[i]);
    static int u,v;
    Rep(i,1,n-1)read(u),read(v),add(u,v),add(v,u);
    dfs(1);
    dfs(1,0);
    W[0]=S[0]=matrix(0);
    rt=build(1,0);
    Rep(i,1,n)if(i^so[fa[i]][0]&&i^so[fa[i]][1])isr.set(i);
}

inline void solve()
{
    static int lasans=0;
    static int x,y;
    Rep(i,1,m)
    {
        read(x);read(y);
        x^=lasans;
        modify(x,y);
        write(lasans=S[rt].getmx());
    }
    flush();
}

int main()
{
    file();
    init();
    solve();
    cerr<<1.0*clock()/CLOCKS_PER_SEC<<endl;
    return 0;
}
```

---

## 作者：lingfunny (赞：19)

## 动态 dp 入门

给道入门题。

题目：DTOJ #4579. Hello 2019

一个串是好的，当且仅当其包含子序列 $9102$ 且不包含子序列 $8102$. (子序列不一定连续)

有个数字串 $S$，每次询问一个区间 $(l,r)$，求至少从串中删掉多少个字符，方能使子串 $S(l,r)$ 是好的。

$|S| \le 2\times 10^5$ | $q\le 2\times 10^5$。

题解：首先 reverse，然后记一个 $f_{i,0/1/2/3/4}$，表示恰好匹配 $0/1/2/3/4$ 个要删几个字符，然后用 $5\times 5$ 的矩阵转移，每次把 $[l,r]$ 内的矩阵乘起来。详细的建议自己推。

## 动态树分治入门

题目：洛谷 P4719 【模板】"动态 DP"&动态树分治

先写出一般最大权独立集式子：
$$
\begin{aligned}
f_{u,0} =& \sum_{v}\max(f_{v,0}, f_{v,1})\\
f_{u,1} =& w_u+\sum_{v} f_{v,0}
\end{aligned}
$$
其中 $f_{u,0/1}$ 表示 $u$ 不选/选的答案。

然后对于整棵树进行树剖，分开记重儿子和轻儿子的答案。

$g_{u,0}$：$u$ 的所有轻儿子全不选的总和加上 $w_u$。

$g_{u,1}$：$u$ 的所有轻儿子选或不选的最大值总和。

$f_{u,0}$：$u$ 不选的答案。

$f_{u,1}$：$u$ 选或不选的答案。

记 $v$ 为重儿子，有：
$$
\begin{aligned}
f_{u,0} =& f_{v,1} + g_{u, 1}\\
f_{u,1} =& \max(f_{v,1} + g_{u, 1}, f_{v,0} + g_{u,0})
\end{aligned}
$$
然后可以把 $f_u$、$g_u$ 和 $f_v$ 写成矩阵，要点是 $f_u$ 和 $f_v$ 长得一样，$g_u$ 只和 $u$ 有关：
$$
\begin{bmatrix}
f_{u, 0} & f_{u, 1}
\end{bmatrix}
=
\begin{bmatrix}
f_{v, 0} & f_{v,1}
\end{bmatrix}
\times
\begin{bmatrix}
-\infty & g_{u,0}\\
g_{u, 1} & g_{u,1}
\end{bmatrix}
$$
当然这里矩阵乘法的定义是 $(+, \max)$。

这样一个**节点**到**重链顶端**的答案就是 $\begin{bmatrix}0 & 0\end{bmatrix}$ 和这条链的叶结点从底到顶的一堆矩阵相乘。

此时如果修改一个节点，只需改的它的 $g_u$ 矩阵。

然后跑到重链顶端，求出新矩阵，对链顶父亲的 $g_u$ 修改一下，然后继续跑。

实现上需要注意矩阵是从链底端乘到链顶端，倒序。

似乎只需要线段树上 $\texttt{query}$ 的时候是右子树乘左子树即可。

几个要点：

1. 扩展 $f_{u,1}$ 的定义：$u$ 选的答案 $\to$ $u$ 选或不选的答案。
2. 把除重儿子外的东西打包到 $g_u$ 考虑。
3. 来自[P4719 最高赞题解](https://www.luogu.com.cn/blog/Tweetuzki/solution-p4179)：每条重链的链尾都是叶子节点，且只有叶子节点没有重儿子。这为动态规划的初始状态和转移方式做了保障。

[提交记录](https://www.luogu.com.cn/record/76042967)

## 全局平衡二叉树

全局平衡二叉树

lxl：**G**lobal **B**iased **T**ree（**GBT**）

Yang Zhe：**G**lobal **B**alanced **BST**（**GBBST**）

[洛谷 P4751 【模板】"动态DP"&动态树分治（加强版）](https://www.luogu.com.cn/problem/P4751)

数据范围已经不允许 $O(\log^2 n)$ 的做法了。

注意到上面那个做法的劣势在于：每次树剖查询的是若干条重链，而就算一条链的长度 $l=1$，单次查询重链复杂度都是 $O(\log n)$，因为是开一棵线段树维护所有节点的矩阵。总的合并复杂度就是 $O(\log^2 n)$。

考虑修改一下，对每条重链单独用一个形态不变的二叉树维护，网络上大部分博客都是非 leafy 结构，类似平衡树。但写成 leafy 的线段树也不会错。

> leafy 两倍常数 —— rsy

问题在于如果还是按照一般的线段树建树，每次找中点，$O(\log n)\sum O(\log l)$ 仍可以卡到 $O(\log^2 n)$。

考虑记：
$$
\mathrm{Lsize}(u)=1+\sum_{v\in \mathrm{LightSon}(u)} \mathrm{size}_v
$$
即所有轻儿子 $\mathrm{size}$ 之和加上自己。

这时候，如果在重链上按照 $\mathrm{Lsize}$ 为权值，找到带权中点，然后递归到左右建（平衡/线段）树来维护信息，均摊下来修改的复杂度就是 $O(\log n)$ 的。

为什么？不知道。难道你知道为什么 Splay 均摊是 $O(q\log n )$ 的吗？

详细证明可见 [Yang Zhe - QTREE 解法的一些研究](https://wenku.baidu.com/view/75906f160b4e767f5acfcedb)

[提交记录](https://www.luogu.com.cn/record/76069612)（无 IO 优化）

关于步骤：

1. 树链剖分。
2. 找出连接根节点的重链，对**这条重链**建立二叉搜索树，然后对连接这条重链的其他重链**递归**建立。
3. 一棵二叉搜索树根节点要维护这棵二叉树的**所有矩阵乘积**。
4. 修改 $a_u \gets x$：
   1. 找到 $u$ 所对应的平衡/线段树节点。
   2. 修改 $a_u$ 对应的矩阵。
   3. 暴力往上跳，每次都 push_up。
   4. 到根了，查看这棵平衡/线段树**所对应的重链**，找到链头的父亲，记作新的 $u$，没父亲就可以退出了。
   5. 回到步骤 4.2。

关于实现：

1. 上文有说是对每条重链依照带权中点二分建立一棵平衡树，**这样是对的**，但是有一些其他的实现方式。比如大部分博客会把轻儿子向父亲的平衡/线段树节点连一条**虚边**。
2. 所谓**虚边**：因为它父亲所在的重链自己构成了一棵二叉树，其父亲无法变成多叉树，指向轻儿子，但是轻儿子可以指向父亲。即**虚边**，有**认父不认子**的特点。推荐这样的实现方式，这样在修改的时候就可以从 $u$ 节点跳直接到顶，省去不少麻烦。详细见代码。

### Code

```cpp
// Problem: P4751 【模板】"动态DP"&动态树分治（加强版）
// From: Luogu
// URL: https://www.luogu.com.cn/problem/P4751
// Time: 2022-05-19 21:21
// Author: lingfunny

#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int mxn = 1e6+10, inf = 1e9;

int n, m, lst, a[mxn], rt, f[mxn][2], g[mxn][2];
vector <int> G[mxn];

struct mat {
	static const int V = 2;
	int a[V][V];
	mat(int a00 = 0, int a01 = -inf, int a10 = -inf, int a11 = 0) { a[0][0] = a00, a[0][1] = a01, a[1][0] = a10, a[1][1] = a11; }
	inline mat operator * (const mat &rhs) const {
		mat res;
		for(int i = 0; i < V; ++i) for(int j = 0; j < V; ++j) {
			res.a[i][j] = -inf;
			for(int k = 0; k < V; ++k) res.a[i][j] = max(res.a[i][j], a[i][k] + rhs.a[k][j]);
		}
		return res;
	}
	inline void show() {
		for(int i = 0; i < V; ++i) for(int j = 0; j < V; ++j) printf("%d%c", a[i][j], " \n"[j==V-1]);
	}
} gm[mxn];

struct node { int lc, rc, anc; mat u, s; } nd[mxn];
inline void psup(int u) {
	node &o = nd[u];
	o.s = nd[o.rc].s * o.u * nd[o.lc].s;	// 反着乘，原因见上文 P4719
}

int sz[mxn], lsz[mxn], dep[mxn], fa[mxn], son[mxn], top[mxn], End[mxn], dfn[mxn], mp[mxn], dfc;
// lsz[u]: Lsize[u]
// top/End: 重链顶/底
// mp: mp[dfn[u]] = u

void dfs(int u, int f) {
	lsz[u] = sz[u] = 1, dep[u] = dep[f] + 1, fa[u] = f;
	for(int v: G[u]) if(v != f) {
		dfs(v, u), sz[u] += sz[v];
		if(sz[v] > sz[son[u]]) son[u] = v;
	}
	lsz[u] = sz[u] - sz[son[u]];
}
void dfs2(int u) {
	End[u] = mp[dfn[u] = ++dfc] = u; g[u][0] = a[u];
	if(son[u]) top[son[u]] = top[u], dfs2(son[u]), End[u] = End[son[u]];
	for(int v: G[u]) if(v != fa[u] && v != son[u]) top[v] = v, dfs2(v), g[u][0] += f[v][0], g[u][1] += f[v][1];
	f[u][0] = f[son[u]][1] + g[u][1];
	f[u][1] = max(f[u][0], f[son[u]][0] + g[u][0]);
	gm[u] = mat(-inf, g[u][0], g[u][1], g[u][1]);
}

int sbuild(int L, int R) {
	if(L > R) return 0;
	LL sum = 0, qsum = 0;
	for(int i = L; i <= R; ++i) sum += lsz[mp[i]];
	for(int i = L, o; i <= R; ++i) {
		qsum += lsz[mp[i]];
		if(qsum * 2 > sum) {
			o = mp[i];
			node &u = nd[o];
			u.u = gm[o];
			u.lc = sbuild(L, i-1), nd[u.lc].anc = o;
			u.rc = sbuild(i+1, R), nd[u.rc].anc = o;
			psup(o);
			return o;
		}
	}
	return -114514;
}

int build(int Tp) {
	int Ed = End[Tp], X = sbuild(dfn[Tp], dfn[Ed]);
	for(int i = dfn[Tp]; i <= dfn[Ed]; ++i) {
		const int &u = mp[i];
		for(int v: G[u]) if(v != son[u] && v != fa[u]) nd[build(v)].anc = u;
	}
	return X;
}

inline void modify(int u, int x) {
	gm[u].a[0][1] += x - a[u]; a[u] = x;
	nd[u].u = gm[u];
	while(u) {
		int F = nd[u].anc;
		if(nd[F].lc != u && nd[F].rc != u && F) { // 如果当前节点到父亲的边是虚边
			mat bef = nd[u].s;
			psup(u);
			mat aft = nd[u].s;
			int _f0 = max(bef.a[0][0], bef.a[1][0]), _f1 = max(bef.a[0][1], bef.a[1][1]),
			f0 = max(aft.a[0][0], aft.a[1][0]), f1 = max(aft.a[0][1], aft.a[1][1]);
			mat &r = nd[F].u;
			r.a[0][1] += f0 - _f0;
			r.a[1][0] += f1 - _f1, r.a[1][1] += f1 - _f1;
			gm[F] = r;
		} else psup(u);
		u = F;
	}
}

signed main() {
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; ++i) scanf("%d", a+i);
	for(int i = 1, u, v; i < n; ++i) scanf("%d%d", &u, &v), G[u].push_back(v), G[v].push_back(u);
	dfs(1, 0), top[1] = 1, dfs2(1), rt  = build(1);
	while(m--) {
		int x, y; scanf("%d%d", &x, &y); x ^= lst;
		modify(x, y);
		printf("%d\n", lst=max(nd[rt].s.a[0][1], nd[rt].s.a[1][1]));
	}
	return 0;
}
```

~~我能水一篇题解吗~~

---

## 作者：2022tysc0776 (赞：11)

最近开始学习 **动态 DP**，如果有不对的地方请在讨论区指出，我当感激不尽。（如果已经会动态 DP 请去下面直接从 **全局平衡二叉树维护动态 DP** 开始看起）。

# 进入正题

本题需要一个科技 **动态 DP**，如果还不会的话，这里大概讲一下。

$f_{u,0/1}$ 表示第 $u$ 个点选与不选的 **子树最大权独立集**，转移方程如下。

$f_{u,0} = \sum \max(f_{v,0},f_{v,1})$

$f_{u,1} = \sum f_{v,0} + a_u $

然后我们考虑修改怎么做，你会发现其实他只会修改一条从修改点到根节点的 $f$ 值，但是如果暴力修改的话肯定会超时，时间复杂度 $O(nm)$。

然后，我们引入 **动态 DP**：

```
动态 DP 问题是猫锟在 WC2018 讲的黑科技，一般用来
解决树上的带有点权（边权）修改操作的 DP 问题。--- oiwiki
```

具体的，我们考虑将原树 **重链剖分**，计算出不含有 **重儿子** 的 $f$ 值为 $g$。

状态转移方程如下，

$f_{x,0}=g_{x,0}+\max(f_{son_x,1},f_{son_x,0})$

$f_{x,1}=g_{x,1}+f_{son_x,0}$

然后把这个方程用矩阵写出来，就是：


$$
\begin{bmatrix}f_{x,0}&f_{x,1}
\end{bmatrix}=
\begin{bmatrix}f_{son_x,0}&f_{son_x,1}
\end{bmatrix}
\begin{bmatrix}
g_{x,0} & g_{x,1} \\
g_{x,0} & -\infty \\
\end{bmatrix}
$$

额，怎么感觉这个矩阵乘法不太一样呢？哦，这是 **广义矩阵乘法**。

其实就是在原先的矩阵乘法上把计算符号组合从 $(+,\times)$ 改为了 $(\max,+)$。

代码如下：

```cpp
mat operator * (const mat &A)const{
		mat res=mat();
		for(int i=0;i<2;i++){
			for(int j=0;j<2;j++){
				for(int k=0;k<2;k++){
					res.a[i][j]=max(res.a[i][j],a[i][k]+A.a[k][j]);
				}
			}
		}
		return res;
	}
```

题外话：并不是所有的运算都能 **广义矩阵乘法** 运算，具体见 [此](https://www.cnblogs.com/luckyblock/p/14430820.html)。

然后你就能理解上面的矩阵乘法了，实际上就是转移式子。

这样的话，我们就可以在每一个点上面放一个含 $g$ 值的转移矩阵，特别的，我们需要特判叶子节点，在叶子上放一个初始矩阵（但是本题并不需要，因为你可以在叶子上 $g$ 和 $f$ 数组是一样的）。

修改的时候我们，相当于只需要修改每一个链头的父亲的 g 数组即可（因为只有那些点的 g 值受到了影响）。因为重链只有 $O(\log n)$，所以一次修改最多只会修改 $\log n$ 个点的矩阵。

然后如果想求一个点的 f 值，只需要求当前点到重链深度最高的点的矩阵乘积，取出对应位置的值即可。对于矩阵乘积，我们可以用 **树剖+线段树** 维护。

但是我们发现我们的初始矩阵在叶子上，所以相乘的时候顺序应该是从下到上的，但是当前的我们刚才推的矩阵顺序是初始矩阵在左，转移矩阵在右的，而矩阵乘法不具有交换律，正常线段树都是从左往右的算的，而 $dfs$ 序会导致是上面的数算的时候在左边，会出错，解决办法有两个：

1.最常见的是改变矩阵的位置，变成，

$$
\begin{bmatrix}
f_{x,0}
\\f_{x,1}
\end{bmatrix}=
\begin{bmatrix}
g_{x,0} & g_{x,0} \\
g_{x,1} & -\infty \\
\end{bmatrix}
\begin{bmatrix} f_{son_x,0}
\\f_{son_x,1}
\end{bmatrix}
$$

这样从左往右乘就是对的了，我用的就是这种办法。

2.直接在线段树中改变乘法的顺序，从右往左乘。（不过这个方法好像没什么人提到过，不确定行不行，所以 ~~狗头保命~~。

到这里其实就可以 AC [P4719](https://www.luogu.com.cn/problem/P4719) 了。

代码和其他人差不多，在这里不过多赘述。（不过如果是第一次接触这个内容的最好先做完上面的那道题再来看下面的东西。

时间复杂度 $O(2^3 n \log n^2)$。

但是这个时间复杂度过不了本题，所以我们考虑优化。但是矩阵这个 trick 好像扔不掉，那我们考虑有没有什么更快的方法处理矩阵的乘积。

## 正题：全局平衡二叉树维护动态 DP

首先我们要知道全局平衡二叉树（下面简称平衡树）是什么。

```
全局平衡二叉树实际上是一颗二叉树森林，
其中的每颗二叉树维护一条重链。
但是这个森林里的二叉树又互有联系，
其中每个二叉树的根连向这个重链链头的父亲，
就像 LCT 中一样。但全局平衡二叉树是
静态树，区别于 LCT，建成后树的形态不变。--oiwiki
```

平衡树将每一条重链转化成二叉树，由多条轻边相连，组成一个树高为 $O(\log n)$ 的树。这样就不用二叉树维护，直接求子树内乘积即可。

首先考虑如何建树，首先从一个点到根的轻链条数一定是 $\log n$ 级别的，所以我们只需要考虑如何构造重链的形态即可。

所以我们的构造方法就是把树链构造成一棵二叉树，具体操作过程就是把每一条重链剖出来，然后求加权中点（下面简称中点），以中点为根，继续处理左右两边，具体看代码：


```cpp
int cbuild(int ql,int qr){
	int l=ql,r=qr;
	while(l+1!=r){
		int mid=(l+r)>>1;
		if(((pre[mid]-pre[ql])<<1)<=pre[qr]-pre[ql]) l=mid;
		else r=mid;
	}//求中点
	int rt=b[l];tree[rt]=val[rt];
	if(l>ql) ls[rt]=cbuild(ql,l),fa[ls[rt]]=rt;
	if(l+1<qr) rs[rt]=cbuild(l+1,qr),fa[rs[rt]]=rt;//递归处理左右子树
	return rt;
}
int build(int x){
	int y=x;
	do{
		val[y].a[0][0]=val[y].a[0][1]=g[y][0];
		val[y].a[1][0]=g[y][1];val[y].a[1][1]=-INF;
		for(auto v:ed[y]){
			if(v==son[y]||v==fat[y]) continue;
			fa[build(v)]=y;//这里注意一下，不要写成 fa[v]=y;
		}
	}while(y=son[y]);//先处理重链旁的链
	do{
		b[y++]=x;pre[y]=pre[y-1]+siz[x]-siz[son[x]];
	}while(x=son[x]);把重链打出来
	return cbuild(0,y);
}
```

这里小证明一下，因为是求了中点，所以每往上面跳一次都会子树大小都会加倍，所以最多跳 $\log n$ 次就会子树大小都会变成 $n$。**所以总树高就是 $O(\log n)$ 的**。

然后剩下的就很简单了，每一个点维护子树矩阵乘积即可。

完整代码：（注释在下方）。

小拓展：平衡树的中序遍历就是原树链的序列。所以其实也可以求具体某一个点的值，只需要从当前点出发一直走到所在二叉树的根节点，乘上原树链在当前点的下面的点的矩阵（这个画个图就好理解了），可以尝试做一下 [洪水](https://www.luogu.com.cn/problem/P6021)。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int INF=1e9,N=1e6+10;
int n,m,a[N],fat[N],son[N],siz[N],fa[N],b[N],pre[N],ls[N],rs[N],f[N][2],g[N][2],lans;
vector<int> ed[N];
struct mat{
	int a[2][2];
	mat(){for(int i=0;i<2;i++) for(int j=0;j<2;j++) a[i][j]=-INF;}
	mat operator * (const mat &A)const{
		mat res=mat();
		for(int i=0;i<2;i++){
			for(int j=0;j<2;j++){
				for(int k=0;k<2;k++){
					res.a[i][j]=max(res.a[i][j],a[i][k]+A.a[k][j]);
				}
			}
		}
		return res;
	}
}val[N],tree[N];//tree[x] 表示子树的矩阵乘积
void dfs(int x,int fa){
	f[x][1]=g[x][1]=a[x];
	fat[x]=fa;siz[x]=1;
	for(auto v:ed[x]){
		if(v==fa) continue;
		dfs(v,x);
		siz[x]+=siz[v];
		if(siz[v]>siz[son[x]]){
			g[x][1]+=f[son[x]][0];
			g[x][0]+=max(f[son[x]][1],f[son[x]][0]);
			son[x]=v;
		}else{
			g[x][1]+=f[v][0];
			g[x][0]+=max(f[v][1],f[v][0]);
		}
		f[x][1]+=f[v][0];
		f[x][0]+=max(f[v][1],f[v][0]);
	}
}
int cbuild(int ql,int qr){
	int l=ql,r=qr;
	while(l+1!=r){
		int mid=(l+r)>>1;
		if(((pre[mid]-pre[ql])<<1)<=pre[qr]-pre[ql]) l=mid;
		else r=mid;
	}
	int rt=b[l];tree[rt]=val[rt];
	if(l>ql) ls[rt]=cbuild(ql,l),fa[ls[rt]]=rt,tree[rt]=tree[ls[rt]]*tree[rt];//注意顺序，应该是先左子树到根最后右子树
	if(l+1<qr) rs[rt]=cbuild(l+1,qr),fa[rs[rt]]=rt,tree[rt]=tree[rt]*tree[rs[rt]];//因为在链上是从深度低的点往深度高的点
	return rt;
}
int build(int x){
	int y=x;
	do{
		val[y].a[0][0]=val[y].a[0][1]=g[y][0];
		val[y].a[1][0]=g[y][1];val[y].a[1][1]=-INF;
		for(auto v:ed[y]){
			if(v==son[y]||v==fat[y]) continue;
			fa[build(v)]=y;
		}
	}while(y=son[y]);
	do{
		b[y++]=x;pre[y]=pre[y-1]+siz[x]-siz[son[x]];
	}while(x=son[x]);
	return cbuild(0,y);
}
void change(int x,int y){
	g[x][1]+=y-a[x];
	a[x]=y;
	val[x].a[1][0]=g[x][1];
	while(x){
		mat pre=tree[x];
		tree[x]=val[x];
		if(ls[x]) tree[x]=tree[ls[x]]*tree[x];
		if(rs[x]) tree[x]=tree[x]*tree[rs[x]];
		if(ls[fa[x]]!=x&&rs[fa[x]]!=x){
			g[fa[x]][0]+=max(tree[x].a[0][0],tree[x].a[1][0])-max(pre.a[0][0],pre.a[1][0]);
			g[fa[x]][1]+=tree[x].a[0][0]-pre.a[0][0];
			val[fa[x]].a[0][0]=val[fa[x]].a[0][1]=g[fa[x]][0];
			val[fa[x]].a[1][0]=g[fa[x]][1];
		}
		x=fa[x];
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<n;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		ed[x].push_back(y);
		ed[y].push_back(x);
	}
	dfs(1,0);
	int Root=build(1);
	while(m--){
		int x,y;
		scanf("%d%d",&x,&y);
		x^=lans;
		change(x,y);
		lans=max(tree[Root].a[0][0],tree[Root].a[1][0]);
		printf("%d\n",lans);
	}
	return 0;
}
```

---

## 作者：Purslane (赞：9)

# 全局平衡二叉树优化动态 DP

感觉到现在我都不会动态 DP。来补习一下。

如果没有点权修改，这道题就是绿色的《没有上司的舞会》。设 $f_{u,0}$ 为 $u$ 节点不选择时 $u$ 子树内的最大独立集大小，$f_{u,1}$ 为 $u$ 节点选择时 $u$ 子树内的最大独立集大小。那么有：

$$
\begin{aligned}
f_{u,0} &= \sum_{v \in son_u} \max\{f_{v,0},f_{v,1}\} \\
f_{u,1} &= w_u+\sum_{v \in son_u} f_{v,0}
\end{aligned}
$$

和大多的动态 DP 一样，使用 $(+,\max)$ 的矩阵乘法（也许我的记号不准确，记得纠正我），记

$$
M_{u}=\left[
\begin{matrix}
f_{u,0} \\
f_{u,1}
\end{matrix}
\right]
$$

但是树形 DP 和普通的序列 DP 不一样，涉及了多个矩阵的合并。如果能像序列 DP 一样每次只在一个状态上修改就好了！那么每个节点要继承某个儿子的信息。很自然的，我们选择继承其重儿子的信息。

那么上面两个递推式中，我们把轻儿子都给装进另外一个数组，得到：（$lson$ 表示轻儿子，$hson$ 表示重儿子）

$$
\begin{aligned}
g_{u,0} &= \sum_{v \in lson_u} \max\{f_{v,0},f_{v,1}\} \\
g_{u,1} &= w_u + \sum_{v \in lson_u} f_{v,0}
\end{aligned}
$$

于是有：

$$
\begin{aligned}
f_{u,0} &= g_{u,0} + \max\{f_{hson,0},f_{hson,1}\} \\
f_{u,1} &= g_{u,1}+f_{hson,0}
\end{aligned}
$$

得到矩阵的形式：

$$
M_u = \left[ 
\begin{matrix}
g_{u,0} & g_{u,0} \\
g_{u,1} & -\infty
\end{matrix}
\right]
M_{hson}
$$

首先考虑在静态形式用这种方法求出 $M_{root}$，并且得到答案。

大家都会 DSU-ON-TREE 的技巧。我们使用类似的方法：对于每个点，先递归求出它的所有轻儿子的 $M$，并且通过合并得到上面那个 $2 \times 2$ 的矩阵。然后求出其重儿子的 $M_{hson}$，乘上去就得到 $M_u$。

我们很容易使用树链剖分的手段做到两个 $\log$ 的解法。预处理之后对于每个重链求出自顶向下的 $\left[ 
\begin{matrix}
g_{u,0} & g_{u,0} \\
g_{u,1} & -\infty
\end{matrix}
\right]$ 的乘积。（链底节点的 $M$ 是确定的，所以没必要记录。注意每条链必定伸到一个叶子节点）。单点修改的时候，相当于对于修改了中间的某个矩阵。这一部分可以用线段树维护。

不过他会修改到链顶节点的 $M_{top_{u}}$，同时会修改 $fa_{top_u}$ 的 $g$。那么相当于新的单点修改操作。如此反复得到了 $O(\log^2 n)$ 的单点修改。

而全局平衡二叉树可以做到 $O(\log n)$ 的单点修改。

考虑我们复杂度的瓶颈在哪里。使用线段树的时候，无论从哪个点对整条链进行修改，都得花 $O(\log n)$ 更新线段树信息。这个是很不公平的！

权值线段树就很好的处理了这种问题。它的形态有点类似 LCT（这句话也可能不那么正确啊，我从来就没会过 LCT，这是根据我对它非常浅显的了解做出的判断）

对于每个重链，记每个点的权值为它的子树的大小减去它的重儿子的子树的大小。然后建立一个 BST，每次都在当前区间找到其加权中位数然后分成两半（为了保证复杂度，我们不选用线段树这种 Leafy Tree 的结构，而是类似 Treap 或者 Splay 的结构）。并且，为了让你更容易写，我们给这棵 BST 的根节点的**父亲通过一条虚边指向原本这条链链顶的父节点**。每次在修改的时候，暴力往上跳。如果是实边就 push_up，如果是虚边就更新矩阵之后再 push_up。

考虑复杂度。很容易发现，往上跳一个父亲，如果是实边目前区间（就是当前节点的所有儿子）的权值总数翻一倍；如果是虚边，权值总数至少不减。所以你最多跳 $O(\log n)$ 次实边。而根据轻重边的性质，你也最多跳 $O(\log n)$ 次虚边。所以复杂度为 $O(\log n)$。

代码真的很好写 ![](https://pic3.zhimg.com/v2-4ab7bced1665776a957c81cc46fc6ffe_b.webp)

```cpp
#include<bits/stdc++.h> 
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e6+10,INF=-1000000000;
int n,m,lstans,sze[MAXN],w[MAXN],son[MAXN],dfn[MAXN],dp[MAXN][2],g[MAXN][2],FA[MAXN];
int top[MAXN],rev[MAXN],pre[MAXN],lson[MAXN],rson[MAXN],fa[MAXN],tot,mxdfn[MAXN];
struct Matrix {int v[2][2];}M[MAXN],mul[MAXN];
Matrix operator*(Matrix A,Matrix B) {
	Matrix res;
	res.v[0][0]=max(A.v[0][0]+B.v[0][0],A.v[0][1]+B.v[1][0]);
	res.v[0][1]=max(A.v[0][0]+B.v[0][1],A.v[0][1]+B.v[1][1]);
	res.v[1][0]=max(A.v[1][0]+B.v[0][0],A.v[1][1]+B.v[1][0]);
	res.v[1][1]=max(A.v[1][0]+B.v[0][1],A.v[1][1]+B.v[1][1]);
	return res;	
}
vector<int> G[MAXN];
void dfs1(int u,int f) {
	sze[u]=1,dp[u][1]=w[u];
	for(auto v:G[u]) if(v!=f) {
		FA[v]=u,dfs1(v,u),sze[u]+=sze[v]; if(sze[v]>sze[son[u]]) son[u]=v;
		dp[u][0]+=max(dp[v][0],dp[v][1]),dp[u][1]+=dp[v][0];
	}
	return ;
}
void dfs2(int u,int f) {
	dfn[u]=++tot,pre[tot]=sze[u]-sze[son[u]],rev[tot]=u;	
	dp[u][0]-=max(dp[son[u]][0],dp[son[u]][1]),dp[u][1]-=dp[son[u]][0];
	M[u].v[0][0]=dp[u][0],M[u].v[0][1]=dp[u][0],M[u].v[1][0]=dp[u][1],M[u].v[1][1]=INF;
	dp[u][0]+=max(dp[son[u]][0],dp[son[u]][1]),dp[u][1]+=dp[son[u]][0];
	if(son[u]) top[son[u]]=top[u],dfs2(son[u],u);
	for(auto v:G[u]) if(v!=f&&v!=son[u]) top[v]=v,dfs2(v,u);
	return ;
}
void push_up(int u) {return mul[u]=mul[lson[u]]*M[u]*mul[rson[u]],void();}
int build(int l,int r) {
	if(l>r) return 0;
	if(l==r) return mul[rev[l]]=M[rev[l]],rev[l];
	int u=lower_bound(pre+l,pre+r+1,(pre[l-1]+pre[r])/2+(pre[l-1]+pre[r])%2)-pre;
	lson[rev[u]]=build(l,u-1),rson[rev[u]]=build(u+1,r);
	fa[lson[rev[u]]]=rev[u],fa[rson[rev[u]]]=rev[u];
	return push_up(rev[u]),rev[u];
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m; ffor(i,1,n) cin>>w[i];
	mul[0].v[0][0]=mul[0].v[1][1]=0,mul[0].v[0][1]=mul[0].v[1][0]=INF;
	ffor(i,1,n-1) {int u,v; cin>>u>>v,G[u].push_back(v),G[v].push_back(u);}
	dfs1(1,0),top[1]=1,dfs2(1,0);
	ffor(i,1,n) pre[i]+=pre[i-1];
	ffor(i,1,n) mxdfn[top[i]]=max(mxdfn[top[i]],dfn[i]);
	ffor(i,1,n) if(top[i]==i) {
		int rt=build(dfn[i],mxdfn[i]);
		fa[rt]=FA[i];
	}	
	ffor(i,1,m) {
		int x,y; cin>>x>>y,x^=lstans; //cout<<x<<' '<<y<<'&';
		M[x].v[1][0]=M[x].v[1][0]-w[x]+y,w[x]=y,push_up(x);
		while(fa[x]!=0) {
			if(x==lson[fa[x]]||x==rson[fa[x]]) x=fa[x],push_up(x);	
			else {
				int _0=M[fa[x]].v[0][0]-max(dp[top[x]][0],dp[top[x]][1]),_1=M[fa[x]].v[1][0]-dp[top[x]][0];
				dp[top[x]][0]=max(mul[x].v[0][0],mul[x].v[0][1]),dp[top[x]][1]=max(mul[x].v[1][0],mul[x].v[1][1]);
				_0+=max(dp[top[x]][0],dp[top[x]][1]),_1+=dp[top[x]][0];
				M[fa[x]].v[0][0]=M[fa[x]].v[0][1]=_0,M[fa[x]].v[1][0]=_1;
				x=fa[x],push_up(x);
			}
		}
		cout<<(lstans=max({mul[x].v[0][0],mul[x].v[0][1],mul[x].v[1][0],mul[x].v[1][1]}))<<'\n';
	}
	return 0;
}
```

---

## 作者：ACAね (赞：9)

~~突然心血来潮交了一发以前的90分LCT代码，居然过了,还只要2.4s？？~~

不禁回忆起了我以前卡了两天还差0.3s的绝望。

于是我就来提供一个阅读性比较好的LCT代码，并提供一个卡常的方法。

~~LCTNB!!!~~

1.循环展开。

2.IO优化

3.#pragma GCC optimize

125行你值得拥有


```cpp
/*
@Date    : 2019-08-16 11:34:40
@Author  : Adscn (adscn@qq.com)
@Link    : https://www.cnblogs.com/LLCSBlog
*/
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long uint64;
typedef unsigned int uint32;
typedef long long ll;
#define IL inline
#define RG register
#define gi getint()
#define gc getchar()
#define File(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)
IL int getint()
{
	RG int xi=0;
	RG char ch=gc;
	bool f=0;
	while(ch<'0'||ch>'9')ch=='-'?f=1:f,ch=gc;
	while(ch>='0'&&ch<='9')xi=(xi<<1)+(xi<<3)+ch-48,ch=gc;
	return f?-xi:xi;
}
template<typename T>
IL void pi(T k,char ch=0)
{
	if(k<0)k=-k,putchar('-');
	if(k>=10)pi(k/10,0);
	putchar(k%10+'0');
	if(ch)putchar(ch);
}
const int N=1e6+7;
struct edge{
	int v,nxt;
}e[N<<1];
int head[N],cnt;
int n,m;
int a[N],dp[N][2];
inline void add(const int &u,const int &v){e[++cnt]=(edge){v,head[u]},head[u]=cnt;}
inline int max(const int &a,const int &b){return a>b?a:b;}
namespace LCT{
	#define ls(x) (c[x][0])
	#define rs(x) (c[x][1])
	#define s(x,k) (c[x][k])
	int fa[N],c[N][2];
	struct matrix{
		int a[4];
		inline int &operator [] (const int &x){return a[x];}
		inline const int &operator [] (const int &x)const{return a[x];}
		inline matrix operator * (const matrix &b)const{
			matrix c;
			c[0]=max(a[1]+b[2],a[0]+b[0]);
			c[1]=max(a[0]+b[1],a[1]+b[3]);
			c[2]=max(a[3]+b[2],a[2]+b[0]);
			c[3]=max(a[3]+b[3],a[2]+b[1]);
			return c;
		}
	}ret[N],val[N];
	inline bool ws(const int &x){return ls(fa[x])^x;}
	inline bool nrt(const int &x){return ls(fa[x])==x||rs(fa[x])==x;}
	inline void pushup(const int &x){
		ret[x]=val[x];
		if(ls(x))ret[x]=ret[ls(x)]*ret[x];
		if(rs(x))ret[x]=ret[x]*ret[rs(x)];
	}
	inline void rotate(const int &x){
		int p=fa[x],g=fa[p],t=ws(x),w=s(x,!t);
		if(nrt(p))s(g,ws(p))=x;s(x,!t)=p,s(p,t)=w;
		fa[w]=p;fa[p]=x,fa[x]=g;
		pushup(p);
	}
	inline void Splay(const int &x)
	{
		while(nrt(x))
		{
			int p=fa[x];
			if(nrt(p))rotate(ws(x)^ws(p)?x:p);
			rotate(x);
		}
		pushup(x);
	}
	inline void access(register int x)
	{
		for(register int y=0;x;x=fa[y=x]){
			Splay(x);
			val[x][0]+=max(ret[rs(x)][0],ret[rs(x)][2])-max(ret[y][0],ret[y][2]),val[x][2]+=ret[rs(x)][0]-ret[y][0];
			val[x][1]=val[x][0];
			rs(x)=y,pushup(x);
		}
	}
	inline void modify(const int &x,const int &y)
	{
		access(x),Splay(x);
		val[x][2]-=a[x]-y,a[x]=y;
		pushup(x);
	}
}
using namespace LCT;
inline void dfs(const int &p)
{
	for(int i=head[p],v;i;i=e[i].nxt)
		if((v=e[i].v)^fa[p])
			fa[v]=p,dfs(v),dp[p][0]+=max(dp[v][0],dp[v][1]),dp[p][1]+=dp[v][0];
	val[p][0]=val[p][1]=dp[p][0],val[p][2]=(dp[p][1]+=a[p]),ret[p]=val[p],val[p][3]=-1e9;
}
int main(void)
{
	n=gi,m=gi;
	for(int i=1;i<=n;++i)a[i]=gi;
	for(int i=1,u,v;i<n;++i)u=gi,v=gi,add(u,v),add(v,u);
	dfs(1);
	int lastans=0;
	while(m--)
	{
		int x=gi,y=gi;
		modify(x^lastans,y),Splay(1);
		pi(lastans=max(ret[1][0],ret[1][2]),'\n');
	}
	return 0;
}
```

---

## 作者：0xyz (赞：8)

比较难，我研究了好久才会。

我们考虑朴素 dp，假设 $f_{i,1}$ 表示取 $i$ 后 $i$ 的子树的最大权独立集，$f_{i,0}$ 表示不取 $i$ 后 $i$ 的子树的最大权独立集。那么显然我们有：
$$\begin{cases}f_{i,0}=\sum\limits_{fa(j)=i}\max(f_{j,0},f_{j,1})\\f_{i,1}=a_i+\sum\limits_{fa(j)=i}f_{j,0}\end{cases}$$
然后我们考虑将这个过程做 $m$ 次。考虑将以上过程简化后变成序列问题，所以将轻儿子和重儿子分开。我们假设 $k$ 是 $i$ 的重儿子，令：
$$\begin{cases}g_{i,0}=\sum\limits_{fa(j)=i\land j\ne k}\max(f_{j,0},f_{j,1})\\g_{i,1}=a_i+\sum\limits_{fa(j)=i\land j\ne k}f_{j,0}\end{cases}$$
那么转移方程变为：
$$\begin{cases}f_{i,0}=g_{i,0}+\max(f_{k,0},f_{k,1})\\f_{i,1}=g_{i,1}+f_{k,0}\end{cases}$$

这样的话，我们每一次修改，只有经过的重链的链顶的父亲节点的轻儿子的 $f$ 值改变了，所以每次修改操作，改变的 $g$ 的个数是 $O(\log n)$ 的，从而我们就解决了修改的问题。

接下来就是考虑如何维护答案。考虑使用广义矩阵乘法维护，定义矩阵 $A\times B=C$，其中 $C_{i,j}=\max\limits\{A_{i,k}+B_{k,j}\}$。手算一下，发现这个东西有结合律。

然后我们用它来维护 $f$ 的值。我们将转移方程改成想要的形式：
$$\begin{cases}f_{i,0}=\max(g_{i,0}+f_{k,0},g_{i,0}+f_{k,1})\\f_{i,1}=\max(g_{i,1}+f_{k,0},-\infty+f_{k,1})\end{cases}$$

然后就有：
$$\begin{vmatrix}g_{i,0}&g_{i,0}\\g_{i,1}&-\infty\end{vmatrix}\times\begin{vmatrix}f_{k,0}\\f_{k,1}\end{vmatrix}=\begin{vmatrix}f_{i,0}\\f_{i,1}\end{vmatrix}$$

最后的答案就是从根节点所在的重链上所有矩阵的乘积。

### 法一：树剖+动态 dp

单点修改，区间查询，我们可以使用线段树维护。

然后为了减小常数和码量，我们发现每次区间查询必然是一条完整的重链，所以可以将每条重链都建一棵线段树，然后进行单点修改，全局查询。

每一次修改操作我们都要对经过的重链的父亲节点的 $g$ 进行修改，也就是修改 $O(\log n)$ 次，所以总时间复杂度是 $O(m\log^2 n)$，可以通过此题。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int _=1e6+5;
int n,m,cnt,a[_],w[_],st[_],ed[_],fa[_],d[_],t[_],h[_],sz[_];
int cx,f[_][2],rt[_],ls[_<<2],rs[_<<2];
vector<int>e[_];
struct mat{
	int a[2][2];
	mat operator *(mat x){
		mat y;
		y.a[0][0]=max(a[0][0]+x.a[0][0],a[0][1]+x.a[1][0]);
		y.a[0][1]=max(a[0][0]+x.a[0][1],a[0][1]+x.a[1][1]);
		y.a[1][0]=max(a[1][0]+x.a[0][0],a[1][1]+x.a[1][0]);
		y.a[1][1]=max(a[1][0]+x.a[0][1],a[1][1]+x.a[1][1]);
		return y;
	}
}s[_<<2],v[_];
void build(int &x,int l,int r){
	x=++cx;
	if(l==r){s[x]=v[w[l]];return;}
	int mid=l+r>>1;
	build(ls[x],l,mid);
	build(rs[x],mid+1,r);
	s[x]=s[ls[x]]*s[rs[x]];
}
void upd(int x,int l,int r,int p){
	if(l==r){s[x]=v[w[p]];return;}
	int mid=l+r>>1;
	if(p<=mid)upd(ls[x],l,mid,p);
	else upd(rs[x],mid+1,r,p);
	s[x]=s[ls[x]]*s[rs[x]];
}
void dfs1(int x,int fat){
	d[x]=d[fat]+1;fa[x]=fat;sz[x]=1;
	for(auto y:e[x])
		if(y!=fat){
			dfs1(y,x);sz[x]+=sz[y];
			if(sz[y]>sz[h[x]])h[x]=y;
		}
}
void dfs2(int x,int tp){
	t[x]=tp;w[++cnt]=x;st[x]=ed[tp]=cnt;
	f[x][1]=v[x].a[1][0]=a[x];v[x].a[1][1]=-1e9;
	if(h[x]){
		dfs2(h[x],tp);
		f[x][0]+=max(f[h[x]][0],f[h[x]][1]);
		f[x][1]+=f[h[x]][0];
	}
	for(auto y:e[x])
		if(y!=h[x]&&y!=fa[x]){
			dfs2(y,y);
			f[x][0]+=max(f[y][0],f[y][1]);
			f[x][1]+=f[y][0];
			v[x].a[0][0]+=max(f[y][0],f[y][1]);
			v[x].a[0][1]=v[x].a[0][0];
			v[x].a[1][0]+=f[y][0];
		}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1,x,y;i<n;i++)cin>>x>>y,e[x].push_back(y),e[y].push_back(x);
	dfs1(1,0);dfs2(1,1);
	for(int i=1;i<=n;i++)
		if(t[i]==i)build(rt[i],st[i],ed[i]);
	for(int x,y,la=0;m;m--){
		cin>>x>>y;x^=la;
		v[x].a[1][0]+=y-a[x];a[x]=y;
		mat b,c;
		while(x){
			b=s[rt[t[x]]];
			upd(rt[t[x]],st[t[x]],ed[t[x]],st[x]);
			c=s[rt[t[x]]];
			x=fa[t[x]];
			v[x].a[0][0]+=max(c.a[0][0],c.a[1][0])-max(b.a[0][0],b.a[1][0]);
			v[x].a[0][1]=v[x].a[0][0];
			v[x].a[1][0]+=c.a[0][0]-b.a[0][0];
		}
		c=s[rt[1]];
		cout<<(la=max(c.a[0][0],c.a[1][0]))<<'\n';
	}
	return 0;
}
```

### 法二：动态树分治

（虽然树不是动态的）

树的形态是固定的，我们又需要维护链上的乘积，所以我们考虑使用[全局平衡二叉树](https://wenku.baidu.com/view/75906f160b4e767f5acfcedb?_wkts_=1694554748735)来维护。

首先我们计算出所有的重链，然后递归地建出全局平衡二叉树。具体来说，就是把每条重链以深度为关键字建成一棵平衡树，然后每一棵平衡树的根节点的父亲指向它所对应的重链的链顶的父节点。这样的话，每个节点只有一个左儿子和一个右儿子，然后还有一些儿子向它连了轻边（它不用认这些子节点），而且树的高度是 $O(\log n)$ 的。

那么我们每次修改就直接从对应点暴力向上跳，只要遇到重链的父亲节点就修改节点上的矩阵，最后在根节点查询即可。时间复杂度 $O(m\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int _=1e6+5;
int n,m,rt,a[_],f[_][2],g[_][2],ls[_],rs[_];
int s[_],sz[_],fa[_],h[_],w[_],d[_],p[_];
vector<int>e[_];
struct mat{
	int a[2][2];
	mat operator *(mat x){
		mat y;
		y.a[0][0]=max(a[0][0]+x.a[0][0],a[0][1]+x.a[1][0]);
		y.a[0][1]=max(a[0][0]+x.a[0][1],a[0][1]+x.a[1][1]);
		y.a[1][0]=max(a[1][0]+x.a[0][0],a[1][1]+x.a[1][0]);
		y.a[1][1]=max(a[1][0]+x.a[0][1],a[1][1]+x.a[1][1]);
		return y;
	}
}t[_],v[_];
void init(int x){
	v[x].a[0][0]=v[x].a[0][1]=g[x][0];
	v[x].a[1][0]=g[x][1];
	v[x].a[1][1]=-1e9;
}
void pushup(int x){
	t[x]=t[ls[x]]*v[x]*t[rs[x]];
}
int getans(int x){
	return max(t[x].a[0][0],t[x].a[1][0]);
}
int build(int l,int r){
	int x=lower_bound(s+l,s+r+1,s[l]+s[r]>>1)-s,y=d[x];
	if(l<x)p[ls[y]=build(l,x-1)]=y;
	if(x<r)p[rs[y]=build(x+1,r)]=y;
	init(y);pushup(y);
	return y;
}
int cat(int tp){
	int x,c=0;
	for(x=tp;x;x=h[x])
		for(auto y:e[x])
			if(y!=fa[x]&&y!=h[x])p[cat(y)]=x;
	for(x=tp;x;x=h[x])d[++c]=x,s[c]=s[c-1]+w[x];
	return build(1,c);
}
void dfs(int x,int fat){
	fa[x]=fat;sz[x]=1;f[x][1]=a[x];
	for(auto y:e[x])
		if(y!=fat){
			dfs(y,x);sz[x]+=sz[y];
			if(sz[y]>sz[h[x]])h[x]=y;
			f[x][0]+=max(f[y][0],f[y][1]);
			f[x][1]+=f[y][0];
		}
	w[x]=sz[x]-sz[h[x]];
	g[x][0]=f[x][0]-max(f[h[x]][0],f[h[x]][1]);
	g[x][1]=f[x][1]-f[h[x]][0];
}
int main(){
	t[0].a[0][1]=t[0].a[1][0]=-1e9;
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1,x,y;i<n;i++)cin>>x>>y,e[x].push_back(y),e[y].push_back(x);
	dfs(1,0);rt=cat(1);
	for(int x,y,la=0;m;m--){
		cin>>x>>y;x^=la;
		g[x][1]+=y-a[x];a[x]=y;init(x);
		for(;x;x=p[x])
			if((y=p[x])&&x!=ls[y]&&x!=rs[y]){
				g[y][0]-=getans(x);
				g[y][1]-=t[x].a[0][0];
				pushup(x);
				g[y][0]+=getans(x);
				g[y][1]+=t[x].a[0][0];
				init(y);
			}else pushup(x);
		cout<<(la=getans(rt))<<'\n';
	}
	return 0;
}
```

---

## 作者：GK0328 (赞：6)

[Luogu4751 【模板】"动态DP"&动态树分治（加强版）](https://www.luogu.com.cn/problem/P4751)

[我的博客](https://www.cnblogs.com/GK0328/p/13662045.html)

# 动态DP

树剖的动态DP做法见此，动态DP原理也在里面，这篇博客就不写了：[树剖动态DP](https://www.cnblogs.com/GK0328/p/13601566.html)

由于**树剖**时间复杂度为$O(n \log^2 n)$，会被这道题卡，所以我们需要**全局平衡二叉树**

**全局平衡二叉树**类似$LCT$，有虚实边之分，我们把所有的**重边**作为**实边**，**轻边**作为虚边，强行构造一棵$LCT$

**全局平衡二叉树**可以看做一棵静态的$LCT$，因为我们已经强行把**实边**、**轻边**是哪些边，以及**树的结构**都钦定了，所以我们无法利用$Splay$等操作修改**树的结构**，但是我们也不需要

也就是说，对于每一条重链，我们都构建一棵二叉搜索树，对于根节点，它的左儿子都是它的父亲，右儿子都是它的子孙（与$LCT$极其类似），然后用轻边连接起来

注意，由于**全局平衡二叉树**一堆二叉搜索树用轻边连接组成，可以沿轻边修改，所以对于一条重链的每个节点，它都挂着一棵轻子树，因此，我们钦定的这条重链的根是带权的，这样才能满足全局平衡（一个节点的权重为其轻子树的大小加上自己$size_{light}+1$）

找到一条链的根，可以二分（暴力枚举也没问题），然后继续递归左右子树，最终建成二叉搜索树，这棵二叉搜索树的根的父亲为这棵二叉搜索树所代表的重链的父亲（其实会$LCT$的根本不需要解释）

那么修改时就暴力跳父亲，如果是重边，直接$update$，如果是轻边，那么就消除原有的贡献，加上新的贡献

时间复杂度：$O(n \log n)$

$Code:$

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define N 1000005
#define INF 1000000007
#define ls(x) ch[x][0]
#define rs(x) ch[x][1]
#define fa(x) F[x]
using namespace std;
int n,m,x,y,tot,rt,lst=0,v[N],F[N],fr[N],d[N << 1],nxt[N << 1];
int sz[N],son[N],q[N],qz[N];
int f[N][2],g[N][2],ch[N][2];
inline int Rmn(int x,int y)
{
    return (x<y)?x:y;
}
inline int Rmx(int x,int y)
{
    return (x>y)?x:y;
}
struct mat
{
    int w[2][2];
    inline mat operator * (mat b)
    {
        mat c;
        c.w[0][0]=Rmx(w[0][0]+b.w[0][0],w[0][1]+b.w[1][0]);
        c.w[0][1]=Rmx(w[0][0]+b.w[0][1],w[0][1]+b.w[1][1]);
        c.w[1][0]=Rmx(w[1][0]+b.w[0][0],w[1][1]+b.w[1][0]);
        c.w[1][1]=Rmx(w[1][0]+b.w[0][1],w[1][1]+b.w[1][1]);
        return c;
    }
}z[N],s[N];
void Rs(mat &q,int a,int b,int c,int d)
{
    q.w[0][0]=a,q.w[0][1]=b;
    q.w[1][0]=c,q.w[1][1]=d;
}
inline int read()
{
    int s=0,w=1;
    char c=getchar();
    while (c<'0' || c>'9')
    {
        if (c=='-')
            w=-1;
        c=getchar();
    }
    while ('0'<=c && c<='9')
        s=s*10+c-'0',c=getchar();
    return s*w;
}
void write(int x)
{
    if (x>9)
        write(x/10);
    putchar(x%10+'0');
}
void add(int x,int y)
{
    tot++;
    d[tot]=y;
    nxt[tot]=fr[x];
    fr[x]=tot;
}
void dfs(int u)
{
    int mx=0;
    sz[u]=1;
    for (int i=fr[u];i;i=nxt[i])
    {
        int v=d[i];
        if (v==fa(u))
            continue;
        fa(v)=u;
        dfs(v);
        sz[u]+=sz[v];
        if (sz[v]>mx)
        {
            mx=sz[v];
            son[u]=v;
        }
    }
}
bool isrt(int x)
{
    return ls(fa(x))!=x && rs(fa(x))!=x;
}
void update(int x)
{
    s[x]=s[ls(x)]*z[x]*s[rs(x)];
}
int build(int l,int r)
{
    if (l>r)
        return 0;
    int sm=qz[r]-qz[l-1];
    sm=(sm+1) >> 1;
    int L=l,R=r,nrt;
    while (L<=R)
    {
        int mid=(L+R) >> 1;
        if (qz[mid]-qz[l-1]>=sm)
        {
            nrt=mid;
            R=mid-1;
        } else
            L=mid+1;
    }
    ls(q[nrt])=build(l,nrt-1);
    rs(q[nrt])=build(nrt+1,r);
    fa(ls(q[nrt]))=q[nrt];
    fa(rs(q[nrt]))=q[nrt];
    update(q[nrt]);
    return q[nrt];
}
void dfs2(int u)
{
    g[u][0]=0;
    g[u][1]=v[u];
    if (!son[u])
    {
        Rs(z[u],0,-INF,v[u],-INF);
        f[u][0]=g[u][0],f[u][1]=g[u][1];
        if (son[fa(u)]!=u)
        {
            int rf=fa(u);
            q[0]=0,qz[0]=0;
            for (int v=u;v;v=son[v])
                q[++q[0]]=v,qz[q[0]]=qz[q[0]-1]+sz[v]-sz[son[v]];
            rt=build(1,q[0]);
            fa(rt)=rf;
        }
        return;
    }
    dfs2(son[u]);
    for (int i=fr[u];i;i=nxt[i])
    {
        int v=d[i];
        if (v==fa(u) || v==son[u])
            continue;
        dfs2(v);
        g[u][0]+=Rmx(f[v][0],f[v][1]);
        g[u][1]+=f[v][0];
    }
    f[u][0]=g[u][0]+Rmx(f[son[u]][0],f[son[u]][1]);
    f[u][1]=g[u][1]+f[son[u]][0];
    Rs(z[u],g[u][0],g[u][0],g[u][1],-INF);
    if (son[fa(u)]!=u)
    {
        int rf=fa(u);
        q[0]=0,qz[0]=0;
        for (int v=u;v;v=son[v])
            q[++q[0]]=v,qz[q[0]]=qz[q[0]-1]+sz[v]-sz[son[v]];
        rt=build(1,q[0]);
        fa(rt)=rf;
    }
}
void modify(int x,int y)
{
    g[x][1]=g[x][1]-v[x]+y;
    v[x]=y;
    Rs(z[x],g[x][0],g[x][0],g[x][1],-INF);
    for (int u=x;u;u=fa(u))
        if (isrt(u) && fa(u))
        {
            int v=fa(u);
            g[v][0]-=Rmx(s[u].w[0][0],s[u].w[1][0]);
            g[v][1]-=s[u].w[0][0];
            update(u);
            g[v][0]+=Rmx(s[u].w[0][0],s[u].w[1][0]);
            g[v][1]+=s[u].w[0][0];
            Rs(z[v],g[v][0],g[v][0],g[v][1],-INF);
        } else
            update(u);
}
int main()
{
    n=read(),m=read();
    for (int i=1;i<=n;i++)
        v[i]=read();
    for (int i=1;i<n;i++)
    {
        x=read(),y=read();
        add(x,y);
        add(y,x);
    }
    dfs(1);
    Rs(z[0],0,-INF,-INF,0);
    Rs(s[0],0,-INF,-INF,0);
    dfs2(1);
    while (m --> 0)
    {
        x=read(),y=read(),x^=lst;
        modify(x,y);
        lst=Rmx(s[rt].w[0][0],s[rt].w[1][0]);
        write(lst),putchar('\n');
    }
    return 0;
}
```

---

## 作者：lfxxx (赞：5)

# 静态 Top tree 解法

考虑建立出静态 Top tree。

接下来我们把一个划分出的联通子图称为簇。初始每条边都是一个簇。**在合并簇的过程中合并出新的簇也会以一条边的形式出现在树上用于下一次合并。**

## 合并两个簇

分为两种。

### compress

我们将一个二度点缩掉，或者说将对于两条相邻的边，若他们的公共点度数为 $2$ 那么就把这两条边合并。合并出的新簇包含原来两个簇的边集。

### rake

对于一个度数为 $1$ 的点 $u$，其唯一的边为 $(u,v)$ 我们将 $(u,v)$ 这条边代表的簇与点 $v$ 任意一个其他的边代表的簇合并。

最后不难发现的是只会剩下一条边。而合并的过程建出一棵树就是 Top tree。

### 静态构建

实际上根据全局平衡二叉树的建法可以给出一个 $2 \times \log n$ 树高的构建方法。

首先按全局平衡二叉树的方法对原树划分，然后轻儿子先把所有簇收缩后 rake 到虚父亲上，对于一条轻儿子全部 rake 完成的重链再用全局平衡二叉树对重链的划分方式把重链上所有边 compress 成一条然后向上递归。

不过对于有多个轻儿子的点显然是有问题的。所以对于多个轻儿子在按照重量选取带权中点，每次按照中点分治，两个分治区间内的轻儿子 rake 成一条在 rake 到一起，还是重量平衡的，所以树高 $2 \times \log n$。

按照这种方法建树，需要 $2$ 倍空间。

对于这题，维护出簇的两个节点分别是否选则的答案并在合并时维护即可。

```cpp
#include<bits/stdc++.h>
#define max(a,b) (a>b?a:b)
namespace IO{
    const int SIZE=1<<21;
    static char ibuf[SIZE],obuf[SIZE],*iS,*iT,*oS=obuf,*oT=oS+SIZE-1;
    int qr;
    char qu[55],c;
    bool f;
    #define getchar() (IO::iS==IO::iT?(IO::iT=(IO::iS=IO::ibuf)+fread(IO::ibuf,1,IO::SIZE,stdin),(IO::iS==IO::iT?EOF:*IO::iS++)):*IO::iS++)
    #define putchar(x) *IO::oS++=x,IO::oS==IO::oT?flush():0
    #define flush() fwrite(IO::obuf,1,IO::oS-IO::obuf,stdout),IO::oS=IO::obuf
    #define puts(x) IO::Puts(x)
    template<typename T>
    inline void read(T&x){
        for(f=1,c=getchar();c<48||c>57;c=getchar())f^=c=='-';
        for(x=0;c<=57&&c>=48;c=getchar()) x=(x<<1)+(x<<3)+(c&15); 
        x=f?x:-x;
    }
    template<typename T>
    inline void write(T x){
        if(!x) putchar(48); if(x<0) putchar('-'),x=-x;
        while(x) qu[++qr]=x%10^48,x/=10;
        while(qr) putchar(qu[qr--]);
    }
    inline void Puts(const char*s){
        for(int i=0;s[i];++i)
            putchar(s[i]);
        putchar('\n');
    }
    struct Flusher_{~Flusher_(){flush();}}io_flusher_;
}
using IO::read;
using IO::write;
//#define lowbit(x) (x&(-x))
using namespace std;
const int maxn = 1e6+114;
const int inf = 1e9+114;
struct node{
	int u,v,d[2][2],id,dis;//两个界点选或者不选的答案，不算界点贡献
	char type;
	int dep;
	//u 在上面 v 在下面
}cluster[maxn<<1];
int n,m,a[maxn];
int pos[maxn<<1],fa[maxn<<1],ls[maxn<<1],rs[maxn<<1];
int root=1;//根簇
void compress(node &x,node &y,node &w){
	//x 在上面 y 在下面
	w.dep=max(x.dep,y.dep)+1;
	w.u=x.u,w.v=y.v;
	w.dis=x.dis+y.dis;
	w.d[0][0]=max(x.d[0][1]+y.d[1][0]+a[x.v],x.d[0][0]+y.d[0][0]);
    w.d[0][1]=max(x.d[0][1]+y.d[1][1]+a[x.v],x.d[0][0]+y.d[0][1]);
    w.d[1][0]=max(x.d[1][1]+y.d[1][0]+a[x.v],x.d[1][0]+y.d[0][0]);
    w.d[1][1]=max(x.d[1][1]+y.d[1][1]+a[x.v],x.d[1][0]+y.d[0][1]);
    w.d[0][0]=max(w.d[0][0],-inf);
    w.d[1][0]=max(w.d[1][0],-inf);
    w.d[0][1]=max(w.d[0][1],-inf);
    w.d[1][1]=max(w.d[1][1],-inf);
    if(w.dis==1) w.d[1][1]=-inf;
	pos[x.v]=w.id;
	fa[x.id]=fa[y.id]=w.id;
	ls[w.id]=x.id;
	rs[w.id]=y.id;
	w.type='C';
	root=w.id;
}
void rake(node &x,node &y,node &w){
    w.dep=max(x.dep,y.dep)+1;
	//把 x rake 到 y 上
	w.u=y.u,w.v=y.v;
	w.dis=y.dis;
	w.d[0][0]=max(x.d[0][0],x.d[0][1]+a[x.v])+y.d[0][0];
	w.d[1][0]=max(x.d[1][0],x.d[1][1]+a[x.v])+y.d[1][0];
	w.d[0][1]=max(x.d[0][0],x.d[0][1]+a[x.v])+y.d[0][1];
	w.d[1][1]=max(x.d[1][0],x.d[1][1]+a[x.v])+y.d[1][1];
    w.d[0][0]=max(w.d[0][0],-inf);
    w.d[1][0]=max(w.d[1][0],-inf);
    w.d[0][1]=max(w.d[0][1],-inf);
    w.d[1][1]=max(w.d[1][1],-inf);
	if(w.dis==1) w.d[1][1]=-inf;
	pos[x.v]=w.id;
	fa[x.id]=fa[y.id]=w.id;
	ls[w.id]=x.id;
	rs[w.id]=y.id;
	w.type='R';
	root=w.id;
}
void update(int u){
    if(u==0) return ;
    if(cluster[u].type=='C'){
        compress(cluster[ls[u]],cluster[rs[u]],cluster[u]);
        update(fa[u]);
    }else{
        rake(cluster[ls[u]],cluster[rs[u]],cluster[u]);
        update(fa[u]);
    }
}
vector<int> E[maxn];
int father_pos[maxn];//一个点到其父亲的边的簇编号
int father[maxn];
int son[maxn],sz[maxn],tot;
vector<int> st[maxn];//重链上的点存到链顶
void dfs1(int u){
	sz[u]=1;
	for(int v:E[u]){
		if(v==father[u]) continue;
		father[v]=u;
		father_pos[v]=++tot;
		cluster[tot].dep=1;
		cluster[tot].u=u,cluster[tot].v=v,cluster[tot].id=tot,cluster[tot].dis=1,cluster[tot].d[1][1]=-inf;
		dfs1(v);
		if(sz[v]>sz[son[u]]) son[u]=v;
		sz[u]+=sz[v];
	}
}
void dfs2(int u,int tp){
	st[tp].push_back(u);
	if(son[u]!=0) dfs2(son[u],tp);
	for(int v:E[u]){
		if(v==father[u]||v==son[u]) continue;
		dfs2(v,v);
	}
}
//需要虚拟节点 n+1 作为根 只在第一次 dfs 以及最后根簇时调用
vector<int> vec;
vector<int> pre;
int solve(int l,int r){
    if(l>r) return 0;
	if(l==r) return father_pos[vec[l]];
	int L=l,R=r;
	while(L+1<R){
		int mid=(L+R)>>1;
		if((pre[mid]-pre[l-1])*2<=(pre[r]-pre[l-1])) L=mid;
		else R=mid;
	}
	int mid=L;
	int lson=solve(l,mid);
	int rson=solve(mid+1,r);
	int res=++tot;
	cluster[tot].id=tot;
	rake(cluster[lson],cluster[rson],cluster[res]);
	return res;
}
int calc(int l,int r){
    if(l>r) return 0;
    if(l==r) return father_pos[vec[l]];
	int L=l,R=r;
	while(L+1<R){
		int mid=(L+R)>>1;
		if((pre[mid]-pre[l-1])*2<=(pre[r]-pre[l-1])) L=mid;
		else R=mid;
	}
	int mid=L;
	int lson=calc(l,mid);
	int rson=calc(mid+1,r);
	int res=++tot;
    cluster[tot].id=tot;
	compress(cluster[lson],cluster[rson],cluster[res]);
	return res;
}
void dfs3(int u){
	for(int x:st[u]){
        if(son[x]==0) continue;
		for(int v:E[x]){
			if(v!=son[x]&&v!=father[x]){
				dfs3(v);
				//收缩 (x,v) 一个簇
			}
		}
		pre.push_back(0);
		vec.push_back(0);
		for(int v:E[x]){
			if(v!=son[x]&&v!=father[x]){
				vec.push_back(v);
			}
		}
		//在对这些轻儿子簇按中点分治的方法合并起来
		for(int i=1;i<=(int)vec.size()-1;i++){
			pre.push_back(pre[i-1]+sz[vec[i]]);
		}
		int rt=solve(1,(int)vec.size()-1);
        if(rt!=0){
            tot++;
            cluster[tot].id=tot;
            rake(cluster[rt],cluster[father_pos[son[x]]],cluster[tot]);
            father_pos[son[x]]=tot;//rake 到重链上
        }
        vec.clear();
        pre.clear();
	}
	vec.clear();
	pre.clear();
	pre.push_back(0);
	vec.push_back(0);
	for(int x:st[u]){
		vec.push_back(x);
	}
	for(int i=1;i<=(int)vec.size()-1;i++){
		pre.push_back(pre[i-1]+sz[father[vec[i]]]-sz[vec[i]]);
	}
	if(u!=1) father_pos[u]=calc(1,(int)vec.size()-1);//把重链上的边 compress 成一条
	else father_pos[u]=calc(2,(int)vec.size()-1);
	E[u].clear();
	E[u].push_back(father[u]);
	vec.clear();
	pre.clear();
	return ;
}
int lstans;
int main(){
    read(n);
    read(m);
    for(int i=1;i<=n;i++) read(a[i]);
    for(int i=2;i<=n;i++){
        int u,v;
        read(u);
        read(v);
        E[u].push_back(v);
        E[v].push_back(u);
    }
    dfs1(1);
    dfs2(1,1);
    dfs3(1);
    while(m--){
        int x,y;
        read(x);
        read(y);
        x^=lstans;
        a[x]=y;
        update(pos[x]);
        write(lstans=max(max(cluster[root].d[0][0],cluster[root].d[1][0]+a[cluster[root].u]),max(cluster[root].d[0][1],cluster[root].d[1][1]+a[cluster[root].u])+a[cluster[root].v]));
        putchar('\n');
    }
	return 0;
}
```


# 全局平衡二叉树解法

静态 Top tree 的简化版本，因为我们不需要 rake 操作了。

然后再把矩阵放上来维护就行了。

```cpp
#include<bits/stdc++.h>
namespace IO{
    const int SIZE=1<<21;
    static char ibuf[SIZE],obuf[SIZE],*iS,*iT,*oS=obuf,*oT=oS+SIZE-1;
    int qr;
    char qu[55],c;
    bool f;
    #define getchar() (IO::iS==IO::iT?(IO::iT=(IO::iS=IO::ibuf)+fread(IO::ibuf,1,IO::SIZE,stdin),(IO::iS==IO::iT?EOF:*IO::iS++)):*IO::iS++)
    #define putchar(x) *IO::oS++=x,IO::oS==IO::oT?flush():0
    #define flush() fwrite(IO::obuf,1,IO::oS-IO::obuf,stdout),IO::oS=IO::obuf
    #define puts(x) IO::Puts(x)
    template<typename T>
    inline void read(T&x){
        for(f=1,c=getchar();c<48||c>57;c=getchar())f^=c=='-';
        for(x=0;c<=57&&c>=48;c=getchar()) x=(x<<1)+(x<<3)+(c&15); 
        x=f?x:-x;
    }
    template<typename T>
    inline void write(T x){
        if(!x) putchar(48); if(x<0) putchar('-'),x=-x;
        while(x) qu[++qr]=x%10^48,x/=10;
        while(qr) putchar(qu[qr--]);
    }
    inline void Puts(const char*s){
        for(int i=0;s[i];++i)
            putchar(s[i]);
        putchar('\n');
    }
    struct Flusher_{~Flusher_(){flush();}}io_flusher_;
}
using IO::read;
using IO::write;
using namespace std;
const int maxn = 1e6+114;
const int inf = 1e9+114;
struct Matrix{
    int n,m;
    int a[2][2];
    Matrix(int N=0,int M=0,int C=0){
        n=N,m=M;
        a[0][0]=a[0][1]=a[1][0]=a[1][1]=C;
    }
    Matrix operator*(const Matrix &x)const{
        Matrix res=Matrix(n,x.m,-inf);
        res.a[0][0]=max(a[0][0]+x.a[0][0],a[0][1]+x.a[1][0]);
        res.a[0][1]=max(a[0][0]+x.a[0][1],a[0][1]+x.a[1][1]);
        res.a[1][0]=max(a[1][1]+x.a[1][0],a[1][0]+x.a[0][0]);
        res.a[1][1]=max(a[1][1]+x.a[1][1],a[1][0]+x.a[0][1]);
        return res;
    }
}e;
int dp[maxn][2],g[maxn][2],n,m;
int dfn[maxn],dfncnt,son[maxn],sz[maxn],fa[maxn],a[maxn],top[maxn],Node[maxn],tail[maxn];
vector<int> E[maxn];
void dfs1(int u){
    sz[u]=1;
    dp[u][1]=a[u];
    for(int v:E[u]){
        if(v==fa[u]) continue;
        fa[v]=u;
        dfs1(v);
        if(sz[v]>=sz[son[u]]) son[u]=v;
        sz[u]+=sz[v];
        dp[u][1]+=dp[v][0];
        dp[u][0]+=max(dp[v][0],dp[v][1]);
    }
    return ;
}
void dfs2(int u,int tp){
    top[u]=tp;
    tail[tp]=u;
    dfn[u]=++dfncnt;
    Node[dfncnt]=u;
    if(son[u]!=0) dfs2(son[u],tp);
    for(int v:E[u]){
        if(v==fa[u]||v==son[u]) continue;
        dfs2(v,v);
    }
    if(son[fa[u]]!=u) g[fa[u]][0]+=dp[u][0];
    if(son[fa[u]]!=u) g[fa[u]][1]+=max(dp[u][0],dp[u][1]);
}
Matrix tr[maxn],sum[maxn];
int v_fa[maxn];//全局平衡二叉树上的父亲
int ls[maxn],rs[maxn];
int rt[maxn];//重链上全局二叉树的根
int pre[maxn];
int build(int l,int r){//dfn 序在区间 [lt,rt] 中的点所在重链建树
    if(l>r) return 0;
    int root=Node[lower_bound(pre+l,pre+r+1,(pre[r]+pre[l-1])>>1)-pre];
    ls[root]=build(l,dfn[root]-1);
    rs[root]=build(dfn[root]+1,r);
    tr[root]=Matrix(1,1);
    tr[root].a[0][0]=g[root][1];
    tr[root].a[0][1]=g[root][0]+a[root];
    tr[root].a[1][0]=g[root][1];
    tr[root].a[1][1]=-inf;
    sum[root]=sum[rs[root]]*tr[root]*sum[ls[root]];
    //sum[0] 要初始化成 2 \times 2 的单位矩阵
    v_fa[ls[root]]=v_fa[rs[root]]=root;
    return root;
}
inline void change_tree(int tp,int u,Matrix c){
    tr[u]=c;
    while(u!=0){
        sum[u]=sum[rs[u]]*tr[u]*sum[ls[u]];
        u=v_fa[u];
    }
    return ;
}//平衡二叉树上修改
void change(int u){//当点 u 的 a[u] 改变后向上修改
    while(top[u]!=1){
        Matrix tp=Matrix(0,1)*sum[rt[top[u]]];
        g[fa[top[u]]][0]-=tp.a[0][0];
        g[fa[top[u]]][1]-=max(tp.a[0][0],tp.a[0][1]);
        Matrix x=Matrix(1,1);
        x.a[0][0]=g[u][1];
        x.a[0][1]=g[u][0]+a[u];
        x.a[1][0]=g[u][1];
        x.a[1][1]=-inf;
        change_tree(top[u],u,x);
        tp=Matrix(0,1)*sum[rt[top[u]]];
        g[fa[top[u]]][0]+=tp.a[0][0];
        g[fa[top[u]]][1]+=max(tp.a[0][0],tp.a[0][1]);
        u=fa[top[u]];
    }
    Matrix x=Matrix(1,1);
    x.a[0][0]=g[u][1];
    x.a[0][1]=g[u][0]+a[u];
    x.a[1][0]=g[u][1];
    x.a[1][1]=-inf;
    change_tree(top[u],u,x);
    return ;
}
int lstans;
int main(){
    e=Matrix(1,1);
    e.a[0][0]=0;
    e.a[0][1]=-inf;
    e.a[1][0]=-inf;
    e.a[1][1]=0;
    sum[0]=tr[0]=e;
    read(n),read(m);
    for(int i=1;i<=n;i++) read(a[i]);
    for(int i=2;i<=n;i++){
        int u,v;
        read(u);
        read(v);
        E[u].push_back(v);
        E[v].push_back(u);
    }
    dfs1(1);
    dfs2(1,1);
    for(int i=1;i<=n;i++) pre[i]=pre[i-1]+sz[Node[i]]-sz[son[Node[i]]];
    for(int i=1;i<=n;i++){
        if(top[i]==i){
            rt[i]=build(dfn[top[i]],dfn[tail[i]]);
        }
    }
    while(m--){
        int x,y;
        read(x);
        read(y);
        x^=lstans;
        a[x]=y;
        change(x);
        Matrix res=Matrix(0,1)*sum[rt[1]];
        write(lstans=max(res.a[0][0],res.a[0][1]));
        putchar('\n');
    }
    return 0;
}
```

对了忘了说了，重链上按照这样的方式建树，根连向重链顶端的父亲就建出了全局平衡二叉树。

---

## 作者：EnofTaiPeople (赞：5)

这是一道被埋没了的卡常好题，与其说它卡了树剖和 LCT，倒不如说它卡了较慢的输出方式。

如何解决动态树最大权独立集？设节点 $x$ 的实儿子为 $y$，$f_{x,1/0}$ 表示 $x$ 在选/不选自己时子树的最大权独立集，$g_{x,1/0}$ 表示 不计算实儿子时的答案。

于是有了以下转移：
$f_{x,0}=g_{x,0}+\max(f_{y,0},f_{y,1}),f_{x,1}=g_{x,1}+f_{y,0}.$

可以转换成矩阵乘法，具有交换律，用 LCT 维护即可。

不过这都不是重点，因为本题用 LCT 不加优化过不了！

真的是因为 LCT 太慢吗？要跑三秒多？

其实 $3\times10^6$ 个整数用 ```printf``` 输出就用了一秒多。

于是有了快读快写，有了它们，再也不怕卡常啦！
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+6,I_F=-1e9;
namespace fast_io{
    char buf[N+5],*p1,*p2,c;
    #define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,N,stdin),p1==p2)?EOF:*p1++)
    inline int read(){
        int an=0,f=1;while(!isdigit(c=gc))if(c=='-')f=-f;
        do an=an*10+(48^c);while(isdigit(c=gc));return an*f;
    }
    int ot;
    char ob[N+20],stk[20],t;
    inline void fls(){
        fwrite(ob,1,ot,stdout),ot=0;
    }
    inline void write(int x){
        if(x<0)ob[ot++]='-',x=-x;
        while(x>9)stk[++t]=48^(x%10),x/=10;
        for(ob[ot++]=48^x;t;ob[ot++]=stk[t--]);
        ob[ot++]='\n';
        if(ot>N)fls();
    }
}
using fast_io::read;
using fast_io::write;
int n,q,t[N][2],f[N],aw[N],las;
vector<int>lk[N];
struct Mtx{
    int a[2][2];
}v[N],sm[N];
inline void max_to(int &x,int y){if(x<y)x=y;}
inline Mtx operator*(const Mtx &x,const Mtx &y){
    Mtx z={{{x.a[0][0]+y.a[0][0],x.a[0][0]+y.a[0][1]},
        {x.a[1][0]+y.a[0][0],x.a[1][0]+y.a[0][1]}}};
    for(int i=0;i<=1;++i)
        for(int j=0;j<=1;++j)
            max_to(z.a[i][j],x.a[i][1]+y.a[1][j]);
    return z;
}
void dfs(int x){
    for(int y:lk[x])
        if(y!=f[x]){
            f[y]=x,dfs(y),v[x].a[1][0]+=v[y].a[0][0];
            v[x].a[0][0]+=max(v[y].a[0][0],v[y].a[1][0]);
        }v[x].a[0][1]=v[x].a[0][0];
    v[x].a[1][1]=I_F,sm[x]=v[x];
}
#define Tp(x) (t[f[x]][1]==x)
#define In(x) (Tp(x)||t[f[x]][0]==x)
#define rs t[x][1]
inline void pp(int x){
    sm[x]=v[x];
    if(t[x][0])sm[x]=sm[t[x][0]]*sm[x];
    if(rs)sm[x]=sm[x]*sm[rs];
}
inline void rot(int x){
    int y=f[x],k=Tp(x),w=t[x][!k];
    f[t[t[x][!k]=y][k]=w]=y;
    if(In(y))t[f[y]][Tp(y)]=x;
    f[x]=f[y],f[y]=x,pp(y);
}
inline void splay(int x){
    for(int y=f[x];In(x);rot(x),y=f[x])
        if(In(y))rot(Tp(x)^Tp(y)?x:y);
}
inline void access(int x){
    for(int y=0;x;x=f[y=x]){
        if(splay(x),rs){
            v[x].a[0][0]+=max(sm[rs].a[0][0],sm[rs].a[1][0]);
            v[x].a[1][0]+=sm[rs].a[0][0];
        }if(y){
            v[x].a[0][0]-=max(sm[y].a[0][0],sm[y].a[1][0]);
            v[x].a[1][0]-=sm[y].a[0][0];
        }v[x].a[0][1]=v[x].a[0][0],rs=y,pp(x);
    }
}
int main(){
    n=read(),q=read();int i,x,y;
    for(x=1;x<=n;++x)v[x].a[1][0]=aw[x]=read();
    for(i=1;i<n;++i){
        x=read(),y=read();
        lk[x].push_back(y);
        lk[y].push_back(x);
    }dfs(1);
    while(q--){
        x=read()^las,access(x),splay(x);
        v[x].a[1][0]-=aw[x];
        v[x].a[1][0]+=(aw[x]=read()),pp(x);
        write(las=max(sm[x].a[0][0],sm[x].a[1][0]));
    }fast_io::fls();
    return 0;
}
```

---

## 作者：Green_White (赞：4)

[可能更好的阅读体验](https://www.cnblogs.com/FloatingLife/p/18418027)
# 适用场景
动态 dp 主要用来处理动态修改点权/边权的树形 dp 题或者区间序列上的带修改的 dp 题。  
其核心都是把 dp 变成矩乘的形式，这样修改只需要更改某个矩阵，再用线段树等数据结构维护。 

---
以板子题为例进行讲解。
## [【模板】"动态 DP"&动态树分治](https://www.luogu.com.cn/problem/P4719)
这道题是简单版。  

简单版的前置知识：树链剖分，广义矩阵乘法。

不带修改的话，最大权独立集很简单：  
$f[u][0] = \sum _{v\in son(u)}\max(f[v][0],f[v][1])$，表示不选 $u$ 的答案。   
$f[u][1] = w[u] + \sum _{v\in son(u)}f[v][0]$，表示选 $u$ 的答案。 

注意到我们更改一个点的点权其实只会修改他到根的链上的那些 dp 值，所以全部重算一点都不划算。  
考虑只去更改这条链上的 dp 值。  
但这样当树是链时还是有可能 TLE（虽然题解区似乎有人 $n$ 方过百万），这个时候就会想到树链剖分。  
因为根到一个点最多会有 $\log$ 个不同的重链，所以可以考虑重链之间暴力修改，重链上用线段树快速维护。

这样的话我们就需要更改一下 $f$ 的转移，使得能与树剖的性质匹配（$f$ 的定义不变）。  
设 $g[u][0/1]$ 表述 $u$ 选/不选，只考虑 $u$ 的那些轻儿子，的答案。  
那么（$son[u]$ 表示 $u$ 的重儿子）：   
$f[u][0] = g[u][0] + \max(f[son[u][0],f[son[u][1])$  
$f[u][1] = g[u][1] + f[son[u]][0]$。  
特别的，叶子结点的 $g[u][0]=0,g[u][1]=w[u]$ (和他的 $f$ 相同)。 

没了讨厌的 $\sum$，加上为了便于用线段树维护，这个转移我们尝试改写成矩阵。  
$f[u][0] = \max(g[u][0]+f[son[u][0] , g[u][0]+f[son[u]][1])$  
$f[u][1] = g[u][1] + f[son[u]][0]$    
根据这个可以得到他的 $(+,\max)$ 广义矩阵乘法形式。    
$$
\begin{bmatrix}
f[son[u]][0] & f[son[u]][1] \\ 
\end{bmatrix} \times

\begin{bmatrix}  
g[u][0] & g[u][1] \\ 
g[u][0] & -\infin \\  
\end{bmatrix} =

\begin{bmatrix}
f[u][0] & f[u][1]
\end{bmatrix}
$$

会得到转移矩阵里只跟当前点的 $g$ 有关。   
注意到转移时我们只需要重儿子的信息，以及当前点的 $g$ 值，所以我们在线段树上维护每个点的 $g$ 所构成的转移矩阵以及矩阵的区间乘积。     
又注意到一条重链的底部一定是叶子。   
所以对于一条重链的顶端他的 $f$ 值就是这条重链的每个转移矩阵的乘积再乘一个初始矩阵（就是叶子的 $f$ 值），这个区间乘线段树是好维护的。  
所以我们只维护 $g$（或者其实是转移矩阵）就可以了。

修改流程如下：
1. 当修改一个点 $u$ 的点权时,当前点的 $g[u][1]$ 要变一下。    
2. 然后 $u$ 到重链顶端 $top[u]$ 的所有点的 $g$ 都是不变的,因为 $g$ 在计算时不包含重儿子。  
3. 当 $top[u]$ 跳到 $fa[top[u]]$ 时，这时因为 $top[u]$ 是 $fa[top[u]]$ 的轻儿子，所以要更改  $fa[top[u]]$ 的 $g$ 值。  
算 $fa[top[u]$ 的 $g$ 值要用到 $top[u]$ 的 $f$ 值，所以这个时候需要在线段树上区间查询一下。  

复杂度是 $O(n \log^2n)$，因为修改时要跳 $\log$ 次，每跳一次都要在线段树上查询一次。 

一些细节：  
矩阵乘法不满足交换律，所以线段树上 `pushup` 要从后往前合并。

## code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
inline int read(){
    int w = 1, s = 0;
    char c = getchar();
    for (; c < '0' || c > '9'; w *= (c == '-') ? -1 : 1, c = getchar());
    for (; c >= '0' && c <= '9'; s = 10 * s + (c - '0'), c = getchar());
    return s * w;
}
int n,T,w[N];
int tot,head[N],to[N<<1],Next[N<<1];
void add(int u,int v){
	to[++tot]=v,Next[tot]=head[u],head[u]=tot;
}

int top[N],down[N],rev[N],dfn[N],fa[N],son[N],Size[N],num,g[N][2],f[N][2];
//down是重链底端 
void dfs1(int u){
	Size[u]=1;
	for(int i=head[u];i;i=Next[i]){
		int v=to[i];
		if(v==fa[u]) continue;
		fa[v]=u;
		dfs1(v);
		Size[u]+=Size[v];
		if(Size[v]>Size[son[u]]) son[u]=v;
	}
}
void dfs2(int u){
	dfn[u]=++num;
	rev[num]=u;
	if(son[fa[u]]==u) top[u]=top[fa[u]];
	else top[u]=u;
	if(son[u]) dfs2(son[u]),down[u]=down[son[u]];
	else down[u]=u;
	g[u][1]=w[u];
	for(int i=head[u];i;i=Next[i]){
		int v=to[i];
		if(v==fa[u]||v==son[u]) continue;
		dfs2(v);
		g[u][0]+=max(f[v][0],f[v][1]);
		g[u][1]+=f[v][0];
	}
	f[u][0]=g[u][0]+max(f[son[u]][0],f[son[u]][1]);
	f[u][1]=g[u][1]+f[son[u]][0];
} 

struct Matrix{
	int n,m,a[3][3];
	void Init(){memset(a,-0x3f,sizeof a);}
	void Init2(){ //单位矩阵 
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				if(i==j) a[i][j]=0;
				else a[i][j]=-0x3f3f3f3f;
			}
		}
	}
}F;
Matrix operator *(Matrix A,Matrix B){
	Matrix C; C.Init();
	C.n=A.n,C.m=B.m;
	for(int i=1;i<=C.n;i++){
		for(int j=1;j<=C.m;j++){
			for(int k=1;k<=A.m;k++){
				C.a[i][j]=max(C.a[i][j],A.a[i][k]+B.a[k][j]);
			}
		}
	}
	return C;
}

struct node{
	int l,r;
	Matrix G;
};
struct SegmentTree{
	node t[N<<2];
	void pushup(int p){
		t[p].G=t[p<<1|1].G*t[p<<1].G;
	}
	void build(int p,int l,int r){
		t[p].l=l,t[p].r=r;
		if(l==r){
			t[p].G.n=2,t[p].G.m=2;
			int u=rev[l];
			t[p].G.a[1][1]=g[u][0],t[p].G.a[1][2]=g[u][1],t[p].G.a[2][1]=g[u][0],t[p].G.a[2][2]=-0x3f3f3f3f;
			return;
		}
		int mid=(l+r)>>1;
		build(p<<1,l,mid);
		build(p<<1|1,mid+1,r);
		pushup(p);
	}
	void change(int p,int x){
		if(t[p].l==t[p].r){
			int u=rev[x];
			t[p].G.a[1][1]=g[u][0],t[p].G.a[1][2]=g[u][1],t[p].G.a[2][1]=g[u][0],t[p].G.a[2][2]=-0x3f3f3f3f;
			return;
		}
		int mid=(t[p].l+t[p].r)>>1;
		if(x<=mid) change(p<<1,x);
		else change(p<<1|1,x);
		pushup(p);
	}
	Matrix ask(int p,int l,int r){
		if(l<=t[p].l&&t[p].r<=r) return t[p].G;
		int mid=(t[p].l+t[p].r)>>1;
		Matrix Res; Res.n=2,Res.m=2,Res.Init2();
		if(r>mid) Res=Res*ask(p<<1|1,l,r);
		if(l<=mid) Res=Res*ask(p<<1,l,r);
		return Res;
	}
}Seg;
void Init(){ //预处理:树剖,g 数组,f 数组,初始化线段树 
	dfs1(1); 
	dfs2(1);  
	
	Seg.build(1,1,n);
	F.n=1,F.m=2;
	F.a[1][1]=0,F.a[1][2]=-0x3f3f3f3f;  //初始矩阵，F 乘以叶子的转移矩阵就是叶子的 f。 
}
void change(int x,int y){
	int tmp=x;
	x=top[x];
	while(x!=1){   //先算出涉及到的点原来的 f 
		Matrix Ans=F;
		Ans=Ans * Seg.ask(1,dfn[x],dfn[down[x]]);
		f[x][0]=Ans.a[1][1],f[x][1]=Ans.a[1][2];
		g[ fa[x] ][0] -= max(f[x][0],f[x][1]);
		g[ fa[x] ][1] -= f[x][0];
		x=top[fa[x]];
	}

	x=tmp;
	g[x][1]-=w[x] , w[x]=y , g[x][1]+=w[x];
	Seg.change(1,dfn[x]);
	x=top[x];
	while(x!=1){
		Matrix Ans=F;
		Ans=Ans * Seg.ask(1,dfn[x],dfn[down[x]]);
		f[x][0]=Ans.a[1][1],f[x][1]=Ans.a[1][2];
		g[ fa[x] ][0] += max(f[x][0],f[x][1]);
		g[ fa[x] ][1] += f[x][0];
		Seg.change(1,dfn[fa[x]]);
		x=top[fa[x]];
	} 
	
}
signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	n=read(),T=read();
	for(int i=1;i<=n;i++) w[i]=read();
	for(int i=1;i<n;i++){
		int u=read(),v=read();
		add(u,v),add(v,u);
	}
	
	Init();
	
	while(T--){
		int x=read(),y=read();
		change(x,y);
		Matrix Ans=F;
		Ans=Ans * Seg.ask(1,dfn[1],dfn[down[1]]);
		printf("%d\n",max(Ans.a[1][1],Ans.a[1][2]));
	}
	return 0;
}
```

---
注意到树剖是 $O(n \log^2n)$ 虽然常数小但还是容易被卡，而什么 LCT 虽然是 $O(n \log n)$ 但是常数巨大还不如两个 $\log$，于是~~毒瘤~~聪明的出题人就出了这题：  
## [【模板】"动态DP"&动态树分治（加强版）](https://www.luogu.com.cn/problem/P4751)
把树剖卡掉了。  

那有什么别的办法呢？
于是就诞生了这个非常厉害的科技——全局平衡二叉树。

请确保先会了简单版的树剖 + 线段树写法。 

思考树剖为什么需要两个 $\log$，因为我们每往上跳一次就要做一次 $O(\log n)$ 的区间查询，然后我们一共要跳 $\log$ 次，所以是两个 $\log$。  
考虑把一个 $\log$ 去掉，跳 $\log$ 次重链的这个 $\log$ 肯定是去不掉了，只能去掉那个查询的 $\log$。  
但是很难有一个数据结构能 $O(1)$ 维护一个比较复杂的且带修的区间信息。  
所以全局平衡二叉树的主要思路就是使树高直接变成 $\log$，然后每一次真的直接往上一步步跳，而不是跳一条重链，在跳的过程中上传信息并合并（这个容易做到 $O(1)$），这样每次跳都是 $O(1)$ 的了。

---

怎么建树呢?  
- 首先全局平衡二叉树先对每条重链建了一个平衡二叉树，每条重链的建法是：
1. 先一遍 dfs 维护出基本信息 $Size$ 表示子树大小,$son$ 表示重儿子，$lsiz$ 表示除去重儿子所在子树的子树大小。
2. 然后对每条重链弄一个类似点分治的过程，把这条链搞到一段序列上，每次找出以 $lsiz$ 为权值的带权中点 $rt$；  
以 $rt$ 为平衡二叉树的根，然后左右分别递归建树并把左右两边得到的根设为 $rt$ 的左右儿子。   
- 然后把一个点用轻边连接的儿子对应的平衡二叉树的根接到这个点对应的平衡二叉树的根下面。

举个例子，比如这个图：
![](https://cdn.luogu.com.cn/upload/image_hosting/fhlap0db.png)
他的重链以及 $lsiz$ 如下图所示：  
![](https://cdn.luogu.com.cn/upload/image_hosting/zfkot4is.png)  
那么他建出的全局平衡二叉树应该长这样子，不同颜色代表不同重链建出的平衡二叉树，虚线边代表连接这些二叉树的边:  
![](https://cdn.luogu.com.cn/upload/image_hosting/gb9mtrdg.png)
**Tip**：所以可以看出全局平衡二叉树并不是一棵二叉树，而是一个二叉树森林连接起来得到的一棵多叉树。

思路就是这么个思路，代码实现时：  
递归建树，当 `build` 到一个点 $u$ 时，先拉出重链，
然后对重链上的每个点先去递归它的轻儿子并把返回的根接到那个点上(对于轻边我们只记录父亲而不记录儿子)。  
对于一条重链再按照上面所说的方法去特殊地建树，
并维护出这个重链的所有转移矩阵的乘积,只要每次 `pushup` 即可,还是记得注意顺序，因为矩阵乘法没有交换律。 

到此全局平衡二叉树就建完了。

---
全局平衡二叉树的每个点维护了两个信息，自己这个点本身的转移矩阵 $matr1$，他所代表的重链上的区间的转移矩阵的乘积 $matr2$。   
修改时，我们从修改的点开始，先改掉它对应的转移矩阵 $matr1$ (此时先不要 `pushup` 更改自身的 $matr2$，因为后面需要用到旧的 $matr2$)。  
然后在全局平衡二叉树上一步一步往上跳，假设当前在 $u$ 点，全局平衡二叉树上的父亲为 $fa$:   
- 如果 $(u,fa)$ 这条边是重边就直接 `pushup(u)` 把 $u$ 的 $matr2$ 改掉，先不用修改 $fa$ 的 $matr2$;
- 如果 $(u,fa)$ 这条边是轻边，此时 $u$ 的 $matr2$ 是旧版本，可以很快的求出 $u$ 原先的 $f$ 值，把 $fa$ 的转移矩阵 $matr1$ 减掉旧的 $f$ 值；再 `pushup(u)` ,算出新的 $f$ 值，把 $fa$ 的转移矩阵 $matr1$ 加上新的 $f$ 值。 

---

查询时，如果查询根的话，直接查询根所在重链的转移矩阵的乘积即可。   
查询子树的话，我们需要的是原树上查询点 $u$ 到其所在重链底端的所有矩阵的乘积，从全局平衡二叉树的 $u$ 点开始，下面 $treefa[u]$ 表示 $u$ 在全局平衡二叉树上的父亲。
1. 把自身节点的 $matr1$ 以及右儿子的 $matr2$ 统计入答案。 
2. 如果 $u$ 是父亲 $treefa[u]$ 的左儿子，那么需要把父亲的 $matr1$ 以及父亲的右儿子的 $matr2$ 统计上；否则这一步不进行操作。
3. 跳到父亲。
4. 重复执行 2~3 步直到跳到根。
   
比如有一条有 $12$ 个点的重链，它们对应到区间上长这样：  
![](https://cdn.luogu.com.cn/upload/image_hosting/wl4hqxnz.png)
把他特殊建出的平衡二叉树长这样(圈出的点是每一层的根，只圈出了需要用到的根)：
![](https://cdn.luogu.com.cn/upload/image_hosting/eppyo0h5.png)
现在要查询 $4$ 号点子树内的信息，就是查询区间 $[4,12]$ 内的点的转移矩阵的乘积。模拟上述过程如下：  
1. 将 $4$ 号点自身的转移矩阵和右子树代表的区间（这个图里没有）的转移矩阵的乘积计入答案。  
   此时计入答案的点：$4$。
2. 因为 $4$ 号点是 $3$ 号点的右儿子所以 $3$ 号点不计入答案，然后跳到 $3$ 号点。  
    此时计入答案的点：$4$。
3. $3$ 号点是 $5$ 号点的左儿子，所以 $5$ 号点以及 $5$ 号点的右子树代表的区间 $[6,7]$ 计入答案，并跳到 $5$ 号点。   
  此时计入答案的点：$4,5,6,7$。
4. $5$ 号点是 $2$ 号点的右儿子，不操作，并跳到 $2$ 号点。  
    此时计入答案的点：$4,5,6,7$。
5. $2$ 号点是 $8$ 号点的左儿子，将 $8$ 号点，以及右子树区间 $[9,12]$ 计入答案。并跳到 $8$ 号点。  
   此时计入答案的点：$4,5,6,7,8,9,10,11,12$。
6. 跳到根了，结束。
   


查询子树的复杂度为 $O(\log n)$。

时间复杂度分析：
1. 如果往下的边是轻边，每一次子树大小减少一半，所以至多走 $O(\log n)$ 条轻边； 
2. 如果往下的边是重边，因为重边特殊的建法，每一次取带权中点，子树大小也减半，所以至多走 $O(\log n)$ 条重边。 
所以树高是 $O(\log n)$ 的。 

一些细节见代码，个人认为码量和树剖差不多。
## code
```cpp
#include<bits/stdc++.h>
#define PII pair<int,int>
#define fi first
#define se second
using namespace std;
const int N=1e6+5,inf=0x3f3f3f3f;
inline int read(){
    int w = 1, s = 0;
    char c = getchar();
    for (; c < '0' || c > '9'; w *= (c == '-') ? -1 : 1, c = getchar());
    for (; c >= '0' && c <= '9'; s = 10 * s + (c - '0'), c = getchar());
    return s * w;
}
int n,T,w[N];
int tot,head[N],to[N<<1],Next[N<<1];
void add(int u,int v){
	to[++tot]=v,Next[tot]=head[u],head[u]=tot;
}

int son[N],Size[N],lsiz[N],g[N][2],f[N][2];
void dfs1(int u,int fa){
	Size[u]=1;
	for(int i=head[u];i;i=Next[i]){
		int v=to[i];
		if(v==fa) continue;
		dfs1(v,u);
		Size[u]+=Size[v];
		if(Size[v]>Size[son[u]]) son[u]=v;
	}
	lsiz[u]=Size[u]-Size[son[u]];
}

void dfs2(int u,int fa){
	if(son[u]) dfs2(son[u],u);
	g[u][1]=w[u];
	for(int i=head[u];i;i=Next[i]){
		int v=to[i];
		if(v==fa||v==son[u]) continue;
		dfs2(v,u);
		g[u][0]+=max(f[v][0],f[v][1]);
		g[u][1]+=f[v][0];
	}
	f[u][0]=g[u][0]+max(f[son[u]][0],f[son[u]][1]);
	f[u][1]=g[u][1]+f[son[u]][0];
} 

struct Matrix{
	int n,m,a[2][2];
	void Init(){memset(a,-0x3f,sizeof a);}
}F;


Matrix operator *(Matrix A,Matrix B){
	Matrix C; C.Init();
	C.n=A.n,C.m=B.m;
	for(int i=0;i<=C.n;i++){
		for(int j=0;j<=C.m;j++){
			for(int k=0;k<=A.m;k++){
				C.a[i][j]=max(C.a[i][j],A.a[i][k]+B.a[k][j]);
			}
		}
	}
	return C;
}


struct Tree{
	int ls,rs;
	Matrix matr1,matr2;
}t[N];
void pushup(int p){
	t[p].matr2=t[p].matr1;
	//还是注意要从右往左合并，因为这个调了一个上午。 
	if(t[p].rs) t[p].matr2 =  t[ t[p].rs ].matr2 * t[p].matr2;
	if(t[p].ls) t[p].matr2 =  t[p].matr2 * t[ t[p].ls ].matr2;   //注意顺序 
}
PII Getf(int p){   //得到此时 p 点的 matr2*F 的值(注意这个不一定是 p 点在原树上的 f 值,因为 matr2 不一定是原树上 p 到重链底端的所有转移矩阵的乘积) 
	Matrix Ans=F*t[p].matr2;
	return {Ans.a[0][0],Ans.a[0][1]};
}
int treefa[N],root;
bool vis[N]; 
int st[N],top;
int SBuild(int l,int r){   //对重链特殊建树 
	if(l>r) return 0; 
	int sum=0;
	for(int i=l;i<=r;i++) sum+=lsiz[st[i]];
	for(int i=l,s=lsiz[st[l]];i<=r;i++,s+=lsiz[st[i]]){
		if(s * 2 >= sum){  //带权中点 
			int p=st[i],lson=SBuild(l,i-1),rson=SBuild(i+1,r);
			t[p].ls=lson,t[p].rs=rson;
			treefa[lson]=treefa[rson]=p;
			pushup(p);
			return p;
		} 
	}
	return 0;
}
int Build(int u){
	for(int x=u;x;x=son[x]) vis[x]=true; 
	for(int x=u;x;x=son[x]){
		for(int i=head[x];i;i=Next[i]){    //先递归轻儿子 
			int y=to[i];
			if(vis[y]) continue;
			treefa[Build(y)]=x;
		}
	}
	top=0;    //因为 top 是全局变量，所以不能写在vis那里，不然在上面递归到 y 时就被覆盖了！！！ 
	for(int x=u;x;x=son[x]) st[++top]=x;
	return SBuild(1,top);
}

void Init(){ //预处理除了建树都和树剖写法一样 
	dfs1(1,0); 
	dfs2(1,0);  
	
	for(int x=1;x<=n;x++){
		t[x].matr1.n=1,t[x].matr1.m=1;
		t[x].matr1.a[0][0]=g[x][0],t[x].matr1.a[0][1]=g[x][1];
		t[x].matr1.a[1][0]=g[x][0],t[x].matr1.a[1][1]=-inf;
	}
	
	F.n=0,F.m=1;
	F.a[0][0]=0,F.a[0][1]=-inf;  
	
	root=Build(1);	
	
}


void change(int u,int val){
	t[u].matr1.a[0][1]+=val-w[u];
	w[u]=val;
	for(;u;u=treefa[u]){   //这里不能写 for(;u!=root;u=treefa[u]) 因为这样的话根的 matr2 没有被 pushup 更新。 
		int fa=treefa[u];
		if(fa && t[fa].ls !=u && t[fa].rs != u){  //轻边 
			PII oldf=Getf(u);
			t[fa].matr1.a[0][0] -= max(oldf.fi , oldf.se) ;
			t[fa].matr1.a[0][1] -= oldf.fi ;
			t[fa].matr1.a[1][0] -= max(oldf.fi , oldf.se) ;
			pushup(u);
			PII newf=Getf(u);
			t[fa].matr1.a[0][0] += max(newf.fi , newf.se) ;
			t[fa].matr1.a[0][1] += newf.fi ;
			t[fa].matr1.a[1][0] += max(newf.fi , newf.se) ;			
		}
		else pushup(u);
	}
}
signed main(){
//	freopen("P4751_4.in","r",stdin);
//	freopen(".out","w",stdout);
	n=read(),T=read();
	for(int i=1;i<=n;i++) w[i]=read();
	for(int i=1;i<n;i++){
		int u=read(),v=read();
		add(u,v),add(v,u);
	}
	
	Init();
	
	int lstans=0;
	while(T--){
		int x=read()^lstans,y=read();
		change(x,y);
		PII ans=Getf(root); 
		lstans = max(ans.fi,ans.se);
		printf("%d\n",lstans);
	}
	return 0;
}

```
参考网址：[动态DP之全局平衡二叉树](https://blog.csdn.net/weixin_30699955/article/details/98357120)

---

## 作者：Tom17 (赞：2)

前置知识：[P4719](https://www.luogu.com.cn/problem/P4719)，动态开点线段树。

注意到出题人想卡树剖，但是我们可以卡常。

不知道有什么树形态可以开树剖（听说是每个点有根号个儿子，根号长的链的树）。

### 第一步：随机根

任意取一个大数（推荐 $10^7$ 以上），模上 $n$ 之后作为根，可以有效地避免树形态对程序造成常数上的影响。

### 第二步：少用 STL 模板

将 vector 存图改为链式前向星存图。

去掉 ```using namespace std;```，并加上 ```#define max(x,y) ((x)>(y)?(x):(y))```。

### 第三步：快读快写

推荐用 ```cin``` 和 ```cout``` 加上关闭输入输出同步流，改 ```endl``` 为 ```\n```。

实测用 ```getchar``` 和 ```putchar``` 反而比较慢。

### 第四步：优化线段树

由动态开点线段树的思想，我们可以 **对每一条链单独维护一颗线段树**。

具体地，每一颗线段树的根用 **链头的编号** 来确定。每次开点时，取一个不重复的大于 $n$ 的编号即可。可以证明，动态开点的点数不超过 $5 n$。

这样每次修改时，改的树深度一般不会顶满 $\log n$。查询的时候，直接取用树根上的值即可。

故修改是常数小的 $O(\log n)$，查询 $O(1)$，且代码合并的部分比常规的好写。

### 第五步：矩阵循环展开

将矩阵乘法的循环展开。这样可以提高缓存命中率，增加语句并发执行可能性。

改到这里，代码便可以以 $2.90s$ 的时间通过第 $10$ 个测试点。

### 代码

```cpp
#include<bits/stdc++.h>

#define max(x,y) ((x)>(y)?(x):(y))

const int N=1000010,inf=0x3f3f3f3f;

struct mat
{
	int a[2][2];
	
	inline mat operator * (const mat& oth) const
	{
		mat res={{}};
		res.a[0][0]=max(a[0][0]+oth.a[0][0],a[0][1]+oth.a[1][0]);
		res.a[0][1]=max(a[0][0]+oth.a[0][1],a[0][1]+oth.a[1][1]);
		res.a[1][0]=max(a[1][0]+oth.a[0][0],a[1][1]+oth.a[1][0]);
		res.a[1][1]=max(a[1][0]+oth.a[0][1],a[1][1]+oth.a[1][1]);
		return res;
	}
}v[N],M;

int n,q,head[N],l=2,dfn[N],id,sz[N],maxson[N],top[N],bot_son[N],rnk[N];

int f[N][2],g[N][2],w[N],dth[N],fa[N];

struct side
{
	int last,to;
}e[N<<1];

inline void add_side(int x,int y)
{
	e[l].last=head[x];
	e[l].to=y;
	head[x]=l;
	++l;
}

void dfs1(int cu,int pa)
{
	dth[cu]=dth[pa]+1;
	fa[cu]=pa;
	sz[cu]=1;
	int maxsz=0;
	for(int i=head[cu];i;i=e[i].last)
	{
		if(e[i].to==pa) continue;
		dfs1(e[i].to,cu);
		sz[cu]+=sz[e[i].to];
		if(sz[e[i].to]>maxsz)
		{
			maxsz=sz[e[i].to];
			maxson[cu]=e[i].to;
		}
	}
}

int dfs2(int cu,int pa,int tp)
{
	dfn[cu]=++id;
	rnk[id]=cu;
	top[cu]=tp;
	f[cu][0]=0,f[cu][1]=w[cu];
	v[cu].a[0][0]=0;
	v[cu].a[0][1]=0;
	v[cu].a[1][0]=w[cu];
	v[cu].a[1][1]=-inf;
	if(maxson[cu])
	{
		bot_son[cu]=dfs2(maxson[cu],cu,tp);
		f[cu][0]+=max(f[maxson[cu]][0],f[maxson[cu]][1]);
		f[cu][1]+=f[maxson[cu]][0];
	}
	else
	{
		bot_son[cu]=cu;
	}
	for(int i=head[cu];i;i=e[i].last)
	{
		if(e[i].to==pa||e[i].to==maxson[cu]) continue;
		dfs2(e[i].to,cu,e[i].to);
		f[cu][0]+=max(f[e[i].to][0],f[e[i].to][1]);
		v[cu].a[0][0]+=max(f[e[i].to][0],f[e[i].to][1]);
		f[cu][1]+=f[e[i].to][0];
		v[cu].a[1][0]+=f[e[i].to][0];
	}
	v[cu].a[0][1]=v[cu].a[0][0];
	g[cu][0]=v[cu].a[0][0];
	g[cu][1]=v[cu].a[1][0];
	return bot_son[cu];
}

struct Segment_tree
{
	int ls[N*6],rs[N*6],c;
	
	mat Val[N*6];	
	
	inline void update(int x)
	{
		Val[x]=Val[ls[x]]*Val[rs[x]];
	}
	
	void build(int l,int r,int& x,const int st)//st传dfn
	{
		if(x==0) x=++c;
		if(l==r)
		{
			Val[x]=v[rnk[st+l-1]];
			return ;
		}
		build(l,((l+r)>>1),ls[x],st);
		build(((l+r)>>1)+1,r,rs[x],st);
		update(x);
	}

	void change(int A,int l,int r,int& x)
	{
		if(l==r) 
		{
			Val[x]=M;
			return ;
		}
		if(A<=((l+r)>>1)) change(A,l,((l+r)>>1),ls[x]);
		else change(A,((l+r)>>1)+1,r,rs[x]);
		update(x);
	}
	
	inline mat query(int x)
	{
		return Val[x];
	}
	
	Segment_tree()
	{
		c=N+1;
	}
}S;

int last_ans,root;

int main()
{
	std::ios::sync_with_stdio(false),std::cin.tie(0),std::cout.tie(0);
	std::cin>>n>>q;
    root=30624700%n+1;
	for(int i=1;i<=n;++i)
	{
		std::cin>>w[i];
	}
	for(int i=1,x,y;i<=n-1;++i)
	{
		std::cin>>x>>y;
		add_side(x,y);
		add_side(y,x);
	}
	dfs1(root,0);
	dfs2(root,0,root);
	for(int i=1;i<=n;++i)
	{
		if(top[i]==i)
		{
			S.build(1,dfn[bot_son[i]]-dfn[i]+1,i,dfn[i]);
		}
	}
	int cu,v;
	while(q--)
	{
		std::cin>>cu>>v;
        cu^=last_ans;
		g[cu][1]+=v-w[cu];
		w[cu]=v;
		while(cu)
		{
			mat last=S.query(top[cu]);
			M=(mat){g[cu][0],g[cu][0],g[cu][1],-inf};
			S.change(dfn[cu]-dfn[top[cu]]+1,1,dfn[bot_son[cu]]-dfn[top[cu]]+1,top[cu]);
			mat now=S.query(top[cu]);
			if(fa[top[cu]]==0) break;
			g[fa[top[cu]]][0]+=max(now.a[0][1],max(now.a[0][0],now.a[1][0]))-max(last.a[0][1],max(last.a[0][0],last.a[1][0]));
			g[fa[top[cu]]][1]+=max(now.a[0][0],now.a[0][1])-max(last.a[0][0],last.a[0][1]);
			cu=fa[top[cu]];
		}
		mat Ans=S.query(root);
        last_ans=max(Ans.a[0][0],Ans.a[1][0]);
		std::cout<<last_ans<<'\n';
	}
    return 0;
}
```

---

## 作者：cike_bilibili (赞：1)

# 【模板】"动态DP"&动态树分治

## 考虑静态版本

和没有上司的舞会一样，设 $f_{u,0/1}$ 表示 $u$ 号节点选或不选时且子树满足条件时的最大答案，直接转移即可。

## 动态 DP

如果每次都一个一个的来依次转移，时间复杂度是一定会跑满的，那么我们如何去节省转移的时间得到正确的答案呢，动态 DP 的主要思想就是把转移的过程写成矩阵相乘的形式，因为其有结合律，就可以用各种数据结构维护矩阵的乘积来快速修改查询。

## 回到本题

这里使用实链剖分维护 DP，我们设其轻儿子的答案为 $g_{u,0/1}$，就有转移：
$$$\begin{bmatrix} g_{u,0}&g_{u,0}\\ g_{u,1} & -\infty\end{bmatrix} \times \begin{bmatrix} f_{hson,0}\\ f_{hson,1}\end{bmatrix}=\begin{bmatrix} f_{u,0}\\ f_{u,1}\end{bmatrix}$$$

注意这里是包含加和 $\max$ 广义矩阵乘法。

而重儿子的矩阵又可以迭代，所以 LCT 上只需要维护上面式子前面那个矩阵的乘积即可，最后求答案时要乘上一个 $\begin{bmatrix} 0\\ 0\end{bmatrix}$，相当于 DP 数组的初始化。

修改直接修改节点的 $g_{u,1}$ 即可。

## Code


```cpp
#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define ls tree[x].ch[0]
#define rs tree[x].ch[1]
using namespace std;
inline int read(){
    int ans=0,w=1;
    char ch=getchar();
    while(ch<48||ch>57){
       if(ch=='-')w=-1;
       ch=getchar();
    }
    while(ch>=48&&ch<=57){
       ans=(ans<<1)+(ans<<3)+ch-48;
       ch=getchar();
    }
    return w*ans;
}
const int INF=1e9;
int n,m;
int a[1000005];
struct edge{
    int to;
    int next;
}ed[2000005];
int cnt;
int h[2000005];
void add(int x,int y){
    ed[++cnt]={y,h[x]};
    h[x]=cnt;
}
struct Matrix{
    int a[2][2];
    friend Matrix operator*(Matrix a,Matrix b){
        Matrix res={0,0,0,0};
        res.a[0][0]=max(a.a[0][0]+b.a[0][0],a.a[0][1]+b.a[1][0]);
        res.a[0][1]=max(a.a[0][0]+b.a[0][1],a.a[0][1]+b.a[1][1]);
        res.a[1][0]=max(a.a[1][0]+b.a[0][0],a.a[1][1]+b.a[1][0]);
        res.a[1][1]=max(a.a[1][0]+b.a[0][1],a.a[1][1]+b.a[1][1]);
        return res;
    }
    void init(int g_0,int g_1){
        a[0][0]=a[0][1]=g_0,a[1][0]=g_1,a[1][1]=-INF;
    }
};
struct tree{
    int ch[2];
    int fa;
    int g[2];
    Matrix f;
}tree[1000005];
inline bool isroot(int x){
    return tree[tree[x].fa].ch[0]!=x&&tree[tree[x].fa].ch[1]!=x;
}
inline bool get(int x){
    return tree[tree[x].fa].ch[1]==x;
}
inline void pushup(int x){
    tree[x].f.init(tree[x].g[0],tree[x].g[1]);
    if(ls)tree[x].f=tree[ls].f*tree[x].f;
    if(rs)tree[x].f=tree[x].f*tree[rs].f;
}
inline void rotate(int x){
    int y=tree[x].fa,z=tree[y].fa,chk=get(x);
    if(!isroot(y))tree[z].ch[tree[z].ch[1]==y]=x;
    tree[y].ch[chk]=tree[x].ch[!chk];
    tree[tree[x].ch[!chk]].fa=y;
    tree[x].ch[!chk]=y;
    tree[y].fa=x,tree[x].fa=z;
    pushup(y),pushup(x);
}
inline void splay(int x){
    for(int f=tree[x].fa;!isroot(x);rotate(x),f=tree[x].fa){
        if(!isroot(f))rotate(get(f)==get(x)?f:x);
    }
}
inline void access(int x){
    for(int p=0;x;p=x,x=tree[x].fa){
        splay(x);
        if(rs){
            Matrix res=tree[rs].f*Matrix({0,0,0,0});
            tree[x].g[0]+=max(res.a[0][0],res.a[1][0]);
            tree[x].g[1]+=res.a[0][0];
        }
        tree[x].ch[1]=p;
        if(p){
            Matrix res=tree[p].f*Matrix({0,0,0,0});
            tree[x].g[0]-=max(res.a[0][0],res.a[1][0]);
            tree[x].g[1]-=res.a[0][0];
        }
        pushup(x);
    }
}
void dfs(int x,int fa){
    tree[x].fa=fa;
    tree[x].g[1]=a[x];
    for(int i=h[x];i;i=ed[i].next){
        int v=ed[i].to;
        if(v==fa)continue;
        dfs(v,x);
        tree[x].g[0]+=max(tree[v].g[0],tree[v].g[1]);
        tree[x].g[1]+=tree[v].g[0];
    }
}
int main(){
    n=read(),m=read();
    for(int i=1;i<=n;i++)a[i]=read();
    for(int i=1;i<n;i++){
        int x=read(),y=read();
        add(x,y),add(y,x);
    }
    dfs(1,0);
    int lst=0;
    while(m--){
        int x=read()^lst,y=read();
        access(x);
        splay(x);
        tree[x].g[1]+=(y-a[x]);
        a[x]=y;
        pushup(x);
        splay(1);
        Matrix res=tree[1].f*Matrix({0,0,0,0});
        cout<<(lst=max(res.a[0][0],res.a[1][0]))<<"\n";
    }
    return 0;
}
```

---

## 作者：_XHY20180718_ (赞：0)

upd on 2.21：修改为了全局平衡二叉树的 $O((n+q)\log n)$ 做法。

动态 DP 的思想是在每个转移点上求出他的转移矩阵，然后在修改时修改转移矩阵，用线段树等数据结构快速维护转移矩阵与初始矩阵的乘积就是状态矩阵，以上都是比较简单的东西，其解题核心在于如何找到合适的 DP 方程以及状态矩阵与转移矩阵。

## 简要题意：

给定一棵树，点上有权值，多次修改，每次改完后求最大点权独立集。

## 主要思路：

我们先将暴力 DP 的式子列出来，设 $f_{u,0/1}$ 为当前考虑了点 $u$ 及其子树内的所有点，**取/不取**这个点的最大贡献，则可以列出转移式：
$$
f_{u,1}=a_u+\sum_{v\in son_u}f_{v,0}
$$
$$
f_{u,0}=\sum_{v\in son_u}\max(f_{v,0},f_{v,1})
$$
由于节点和节点之间并没有什么直接关系或性质可以利用，那么我们肯定是对于每个节点 $u$ 单独设计一个状态矩阵，如下：
$$
\begin{bmatrix} f_{u,0},f_{u,1} \end{bmatrix}
$$
现在我们需要构造一个可以用矩阵优化的转移方程式，每个节点都对应一个转移方程，每次修改转移矩阵的修改复杂度需要小于 $O(n)$ 级别。

注意到，我们每次修改一个节点 $u$，只会影响 $root\sim u$ 这条链上的节点的 $f$ 值。

既然是一条链，那么我们肯定可以用轻重链剖分将其最多分为 $\log n$ 条重链，这说明我们可以只需要修改这条链上的一些转移矩阵，观察转移方程，很显然，我们并不好设计能用线段树直接区间修改的 $O(n)$ 级别个数转移矩阵（不然基本上可以用线段树直接区间修改 $f$ 值），根据重链剖分的限制，我们可以直接设置一种转移矩阵，让他仅跟轻链上的值有关，然后我们实际上转移的矩阵仅在 $O(\log n)$ 条重链中来上来体限，由于根到任意一个节点最多有 $O(\log n)$ 条轻链，意味着我们只需要修改每个链顶父亲的转移矩阵即可。

那么现在让我们思考一下怎么设置一个只跟轻儿子有关的转移矩阵：

观察一下原转移方程：
$$
f_{u,1}=a_u+\sum_{v\in son_u}f_{v,0}
$$
$$
f_{u,0}=\sum_{v\in son_u}\max(f_{v,0},f_{v,1})
$$

我们需要让转移矩阵中只有关于 $a$ 和轻儿子的量。

让我们修改一下原转移式，设 $g_{u,0/1}$ 为考虑轻儿子子树**不选轻儿子/选不选轻儿子都行**的最大贡献之和，就可以将重儿子和轻儿子分开：
$$
f_{u,0}=\max(f_{son_u,0},f_{son_u,1})+g_{u,1}
$$
$$
f_{u,1}=f_{son_u,0}+g_{u,0}+a_u
$$

$$
\begin{bmatrix} f_{son_u,0},f_{son_u,1} \end{bmatrix}
\begin{bmatrix} ?,?\\?,? \end{bmatrix}=
\begin{bmatrix} f_{u,0},f_{u,1} \end{bmatrix}
$$
我们需要定义一种新的广义矩阵乘法，使得我们能计算这个矩阵。

再次观察转移方程式，其中有一个 $\max(f_{son_u,0},f_{son_u,1})$ 比较难处理，他们原本属于同一个矩阵，意味着我们广义矩阵乘法的外层要套一个 $\max$，又因为转移矩阵中肯定有 $g_{u,0}$ 和 $g_{u,1}$，他与 $f_u$ 是加法关系，所以内层肯定要套一个 $+$，现在可以得出我们的广义矩阵乘法：

$$
\forall {i,j} (A\times B)_{i,j}=\max_{k=1}^n(A_{i,k}+B_{k,j})
$$

但是还有一个 $a_u$，不是很好处理，我们可以把他算到 $g_{u,0}$ 中，重新定义一下 $g_{u,0}$：考虑所有轻儿子子树内，不选轻儿子的情况下，最大贡献之和加上本节点 $u$ 的权值的总贡献，我们的转移方程变为：
$$
f_{u,0}=\max(f_{son_u,0},f_{son_u,1})+g_{u,1}
$$
$$
f_{u,1}=f_{son_u,0}+g_{u,0}
$$

我们的广义矩阵乘法（状态矩阵乘上转移矩阵）就会变为：
$$
\begin{bmatrix} f_{son_u,0},f_{son_u,1} \end{bmatrix}
\begin{bmatrix} g_{u,1},g_{u,0}\\g_{u,1},-\infty \end{bmatrix}=
\begin{bmatrix} f_{u,0},f_{u,1} \end{bmatrix}
$$
每次修改单点时，我们暴力将修改转移矩阵，先用线段树/全局平衡二叉树更新当前重链的状态矩阵，到重链顶端时就可以更新 $g_{u,0}$ 和 $g_{u,1}$。然后利用更新的 $g$ 来更新转移矩阵，接下来再从 $f_{son_u,0/1}$ 开始进行以上操作，直到求出最新的 $f_{root}$，每次要将重链顶端的原状态矩阵存一下，这样好修改重链顶端的父亲转移矩阵。

注意，我们还有一个问题，我们如果要使用矩阵快速幂，或使用线段树维护转移矩阵，就需要让这个广义矩阵乘法运算满足结合律。

也就是说，我们现在要证明：$(A\times B)\times C=A\times(B\times C)$。

也就是：
$$
\begin{aligned}
\max_{k=1}^n(\max_{l=1}^n(A_{i,l}+B_{l,k})+C_{k,j})\\
=\max_{k=1}^n(A_{i,k}+\max_{l=1}^n(B_{k,l}+C_{l,j}))
\end{aligned}
$$
证明过程参考知乎上的[这篇回答](https://www.zhihu.com/question/643809025/answer/3452401752)。

容易发现：
$$
min(x+y,x+z)=x+min(y,z)(min 对 + 有左分配律)\\
min(x+z,y+z)=min(x,y)+z(min 对 + 有右分配律)\\
min(x,y)=min(y,x)(min 满足交换律)
$$
证毕。

还有一些要注意的地方：
1. 别把广义矩阵乘法写错了，赋初值要赋对。
2. 线段树/平衡二叉树上记得将乘法反过来，因为我们是从链底乘到链顶。
3. 修改重链顶端的父亲的 $g_u$ 时，要加上的是现在的值与原来的值的差，所以还要对前面的值进行一次单点查询。

时间复杂度：$O(n\log n)$。

## 参考代码：

实现略微脑溢血，大家可以根据注释参考一下实现方式：

```cpp
#include<bits/stdc++.h>
#define max(x,y) ((x)>(y)?(x):(y))
#define min(x,y) ((x)<(y)?(x):(y))
#define ls(x) tr[x].s[0]
#define rs(x) tr[x].s[1]
using namespace std;
const int N=1e6+5,inf=1e9;
int n,m,a[N],pre[N],K;
int f[2][N],g[2][N];
int head[N],ei,fa[N];
int Time,idx[N],dfn[N];
int top[N],bot[N],rt[N];
int sz[N],son[N],dep[N];
struct Matrix{int a[2][2];}tn[N];
const Matrix I={0,-inf,-inf,0},O={-inf,-inf,-inf,-inf};
struct edge{int v,nxt;}egs[N<<1];
struct Tree{
    Matrix w,sw;
    int fa,s[2];
}tr[N];
Matrix operator*(const Matrix &a,const Matrix &b){
    Matrix c=O;
    for(int i=0; i<2; ++i)
        for(int j=0; j<2; ++j)
            for(int k=0; k<2; ++k)
                c.a[i][j]=max(c.a[i][j],a.a[i][k]+b.a[k][j]);
    return c;
}//新定义的广义矩阵乘法
inline void add(int u,int v)
{egs[++ei]={v,head[u]};head[u]=ei;}
//树链剖分：
void dfs1(int u){
    dep[u]=dep[fa[u]]+1,sz[u]=1,bot[u]=u;
    for(int i=head[u];i;i=egs[i].nxt){
        const int v=egs[i].v;
        if(fa[u]==v)continue;
        fa[v]=u,dfs1(v);sz[u]+=sz[v];
        if(sz[son[u]]<sz[v])son[u]=v,bot[u]=bot[son[u]];//记得对每个结点求链底
    }
}
void dfs2(int u){
    g[0][u]=a[u],g[1][u]=0;
    idx[dfn[u]=++Time]=u;
    if(son[u])top[son[u]]=top[u],dfs2(son[u]);
    f[0][u]=max(f[0][son[u]],f[1][son[u]]);
    f[1][u]+=f[0][son[u]];
    for(int i=head[u];i;i=egs[i].nxt){
        const int v=egs[i].v;
        if(v!=son[u]&&v!=fa[u]){
            dfs2(top[v]=v),g[0][u]+=f[0][v],g[1][u]+=max(f[0][v],f[1][v]);
        }
    }f[0][u]+=g[1][u];f[1][u]+=g[0][u];
    tn[u]={g[1][u],g[0][u],g[1][u],-inf};
}
inline bool nroot(int u)
{return ls(tr[u].fa)==u||rs(tr[u].fa)==u;}
inline void pushup(int u){
    for(; nroot(u); u=tr[u].fa)
        tr[u].sw=tr[rs(u)].sw*tr[u].w*tr[ls(u)].sw;
    tr[u].sw=tr[rs(u)].sw*tr[u].w*tr[ls(u)].sw;
}
int build(int l,int r){
    if(l>r)return 0;
    int mid=lower_bound(pre+l,pre+1+r,pre[r]+pre[l-1]>>1)-pre;
    int u=idx[mid];
    ls(u)=build(l,mid-1),rs(u)=build(mid+1,r);
    if(ls(u))tr[ls(u)].fa=u;
    if(rs(u))tr[rs(u)].fa=u;
    tr[u].w=tn[u];
    tr[u].sw=tr[rs(u)].sw*tr[u].w*tr[ls(u)].sw;
    return u;
}
int upd_tree(int u){
    //查询u所在的这条重链原来顶端的状态矩阵
    Matrix res=tr[rt[u]].sw;
    int fv0=res.a[0][0],fv1=res.a[0][1];
    //修改u节点的转移矩阵
    int gu0=tr[u].w.a[0][1],gu1=tr[u].w.a[0][0];
    gu0=gu0-a[u]+K,a[u]=K;
    tr[u].w={gu1,gu0,gu1,-inf};pushup(u);
    //查询u所在的这条重链现在顶端的状态矩阵
    res=tr[rt[u]].sw;
    int f_v0=res.a[0][0],f_v1=res.a[0][1];
    u=tr[rt[u]].fa;//跳到链顶的父亲
    while(u){
        //修改u节点的转移矩阵（先把新的g_{u,0/1}给求下来）
        gu0=tr[u].w.a[0][1],gu1=tr[u].w.a[0][0];//先把原转移矩阵求出
        gu1=gu1-max(fv0,fv1)+max(f_v0,f_v1);
        gu0=gu0-fv0+f_v0;
        //修改之前求一下u所在的这条重链原来顶端的状态矩阵
        res=tr[rt[u]].sw;
        fv0=res.a[0][0],fv1=res.a[0][1];
        //正式修改u节点的转移矩阵
        tr[u].w={gu1,gu0,gu1,-inf};pushup(u);
        //查询u所在的这条重链现在顶端的状态矩阵
        res=tr[rt[u]].sw;
        f_v0=res.a[0][0],f_v1=res.a[0][1];
        u=tr[rt[u]].fa;//跳到链顶的父亲
    }
    return max(f_v0,f_v1);
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n>>m;int x,y;
    tr[0].sw=tr[0].w=I;
    for(int i=1; i<=n; ++i)
        cin>>a[i],a[i]=max(a[i],0);
    for(int i=1; i<n; ++i)
        cin>>x>>y,add(x,y),add(y,x);
    dfs1(1),dfs2(top[1]=1);
    for(int i=1; i<=n; ++i)
        pre[i]=pre[i-1]+sz[idx[i]]-sz[son[idx[i]]];
    for(int u=1; u<=n; ++u)
        if(u==top[u])rt[u]=build(dfn[top[u]],dfn[bot[u]]),tr[rt[u]].fa=fa[top[u]];
    for(int u=1; u<=n; ++u)rt[u]=rt[top[u]];
    int lst=0;
    while(m--){
        cin>>x>>K;x^=lst,K=max(K,0);
        cout<<(lst=upd_tree(x))<<'\n';
    }
    return 0;
}
```

---


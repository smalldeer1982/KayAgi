# 薇尔莉特的打字机

## 题目背景

> 只要客人有意向，不论身在何处，都能上门服务。我是自动手记人偶服务——薇尔莉特·伊芙加登。

![](http://wx3.sinaimg.cn/large/dcec95dfgy1fme08p9eopj20xv0hyq5q.jpg)

## 题目描述

薇尔莉特的打字机用了太久，按键已经开始老化了，因此有时候按键会没有反应。而薇尔莉特总是盲打，因此按键没反应她也不会注意到。一天，她用这台打字机继续完成一封还没写完的信。

现在告诉你这封信已经写好的部分以及薇尔莉特想进行的操作，薇尔莉特想进行的操作有两种：
1. 在信的末尾输入一个大写字母
2. 进行一次退格

退格用小写字母 $\mathrm{u}$ 表示，即删除当前信中的最后一个字符，当然，在信为空时退格没有任何作用。

薇尔莉特会按顺序按下她想按的按键，而每次薇尔莉特按下一个键（输入一个大写字母或进行一次退格），都有可能没有反应（即这次操作无效）。请问，最后打出来的信有多少种可能呢？（空信也算信）

当然薇尔莉特只想知道可能数对 `0x125E591`（十六进制） 取模的结果。

## 说明/提示

$1\le n,\ m\le 5\times 10^6$

## 样例解释

样例一：可能的 $9$ 种信为：`A`,`AA`,`AB`,`AAB`,`ABA`,`ABB`,`ABAA`,`ABAB`,`ABAAB`。

样例二：~~太多了，略~~。

样例三：可能的 $3$ 种信为：`空`,`U`,`UU`。

## 样例 #1

### 输入

```
2 4
AB
AuAB```

### 输出

```
9```

## 样例 #2

### 输入

```
10 5
AABBAACBAC
ABAAC```

### 输出

```
20```

## 样例 #3

### 输入

```
1 3
U
uUu```

### 输出

```
3```

# 题解

## 作者：Binary_Search_Tree (赞：20)

#### [题目传送门](https://www.luogu.org/problemnew/show/P4965) 

考虑到可能出现的字符串不止一个，我们建立一棵字典树，将字典树上的节点看作一个串。

如果这个串可能出现，则把它涂黑。

因为每次操作都可以不按，所以第i-1次操作后的黑色节点在第i次操作后仍然是黑色。

如果按下，则会有新的黑色节点产生。

**所以这是一个不断扩展的过程。**


------------

为了方便，我们暂时不考虑u。

假设我们现在进行第i次操作，字母为s[i]。

每个黑色节点的第s[i]个儿子都可以被涂黑。

那么现在的黑色节点的数量是原先的两倍吗？

显然不是。

![](https://cdn.luogu.com.cn/upload/pic/64925.png )

（为了方便，假设只有三种不同的字母）

如上图所示，0和1已经变为黑节点。若再按下a,则0->1,1->2

发现1号节点**重复出现**。

因此，我们需要一个数组，F[i]表示当前状态下有多少黑色节点已经有第i个儿子，转移时应减去它们产生的节点。

因此，第i次黑色节点=第(i-1)次黑色节点 * 2 - F[s[i]]。


------------

### 现在问题就转化为了如何不断更新F[i]。

假如现在执行第i次操作

所有黑色节点跳到第s[i]个儿子的位置。

那么，所有**原来的**黑色节点都拥有第s[i]个儿子，因此，F[s[i]]更新为第i-1次操作后的黑色节点数量。

而对于其他的字符j，所有黑色节点中有第j个儿子的节点数量并没有发生变化，不需要更新。



------------


**就这样愉快地解决了吗？**

我们还要考虑**退格**的情况。

如果一个字符串先在末尾加了一个字符，然后又删掉了，相当于一直没有变化。

**所以，我们只需要考虑真实操作串都是u的串。这其实是在字典树中不断往上跳的过程。**

所以，我们每遇到一个u,直接把答案+1就可以了。

**但是，如果当前串已经删成空串了，就可以直接跳过这个过程。**

那么F数组如何更新呢？

我们考虑统计到目前为止u的总个数cnt,那么现在删掉的是第1个串中的第(n-cnt+1)个字符。

对于这个字符s,我们只需要将F[s]++即可。

时间复杂度O(n)。

```
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>
#define mod 19260817 //一个神秘的模数
#define M 10000005
using namespace std;
int n,m,cnt;//cnt表示当前删的位置
char A[M],B[M];
long long ans=1,F[30];
int main(){
	scanf("%d%d%s%s",&n,&m,A+1,B+1);cnt=n;//读入
	for (int i=1;i<=m;i++)
		if (B[i]>='A'&&B[i]<='Z'){
			long long tmp=F[B[i]-'A'+1];
			F[B[i]-'A'+1]=ans;//更新F数组
			ans=((ans+ans-tmp)%mod+mod)%mod;//更新ans
		}
		else {
			if (!cnt) continue;//如果当前串删完了就跳过
			F[A[cnt]-'A'+1]=(F[A[cnt]-'A'+1]+1)%mod;//更新F数组
			ans=(ans+1)%mod;cnt--;//更新ans
		}
	printf("%lld",ans);
	return 0;
}

```


---

## 作者：Inui_Sana (赞：10)

[题目传送门](https://www.luogu.com.cn/problem/P4965)

解题思路：递推

一道很好的锻炼推式子能力的题，~~也是本蒟蒻第一道一遍过的紫题~~。

既然是递推，那就先定义一下状态：$f_i$ 表示在执行完第 $i$ 个操作后，可能得到的字符串数量。

很明显，我们需要分两种情况讨论：这次操作为添加字符或退格。

先分析第一种情况，添加字符。这个时候又要分两种小情况：

当这个字符在操作中是第一次出现时，把它接在任何已有的字符串后面，都不会重复。所以 $f_i=f_{i-1}\times 2$；

当这个字符在操作中已经出现过时，设它上次出现处为 $lst$，通过手模很容易发现，在这种情况下会出现重复，而重复的次数则是 $f_{lst-1}$，因为如果从 $lst$ 到 $i-1$ 的操作都没执行出来，再将第 $i$ 次操作的字符接在后面，就相当于是接第 $lst$ 次操作的字符在后面，而这种情况又是已经计算过的。所以 $f_i=f_{i-1}-f_{lst-1}$。

第二种情况，退格。我们会发现，得到的全部都是重复的字符串，只有一种情况除外：此前的操作，所有添加字符都没执行，所有退格都有执行，这个时候就会多出一种情况：原有的字符串去掉末尾长度为 $k$ 的字串后剩下的字符串，$k$ 为在该操作之前出现过的退格操作数。只要 $k<n$，就会同上所述，多出一个新的字符串。$f_i=f_{i-1}+1$。反之就不会，$f_i=f_{i-1}$。

还需要注意的是，举个例子，原有字符串为 AB，操作uB。这个时候答案不是 $4$，而是$3$。为什么呢？因为多算了删去 B 又添加 B 的情况，还要额外再减 $1$。所以我们不妨设 $cnt_i$ 为下一次出现 $i$ 字符时，要减去的情况数，当前字符为 $x$。那么全部的递推式就是：

$f_i =\begin{cases}f_{i-1}\times 2-cnt_x&t_x\neq u\\f_{i-1}+1&t_x=u\land k<n\\f_{i-1}&t_x=u\land k\geq n \end{cases}$

还有一处值得一提：本人第一次写的时候，当有添加字符的操作时，把之前所有出现过的字符所产生的重复都算上了，然后就很容易地没过样例。想了一下，是因为前一个相同字符之前所产生的影响都包含在了其中，所以不用统计。

code：

```cpp
int n,m,cnt[27],f[maxn];
char s[maxn],t[maxn];
void solve(){
	scanf("%d%d%s%s",&n,&m,s+1,t+1);
	f[0]=1;//别忘了初始化
	for(int i=1,k=0;i<=m;i++){
		if(t[i]=='u'){
			if(k<n)f[i]=f[i-1]+1;
			else f[i]=f[i-1];
			if(k<n)cnt[s[n-k]-'A'+1]++;
			k++;
		}else{
			int x=t[i]-'A'+1;
			f[i]=f[i-1]*2%mod;
			f[i]=(f[i]-cnt[x]+mod)%mod;
			cnt[x]=f[i-1];
		}
	}
	printf("%d",f[m]);
}
```

写在最后（与题解无关）：

虽然不是很了解紫罗兰永恒花园这部番，但出于敬仰，还是要说一句：

花无凋零之时，爱无传达之日，爱情亘古不变，紫罗兰永世长存。

~~我写这些不会就给管理大大毙了吧~~

---

## 作者：Yizhixiaoyun (赞：8)

[博客园食用](https://www.cnblogs.com/yizhixiaoyun/p/16734484.html)

[题目传送门](https://www.luogu.com.cn/problem/P4965)

被同机房神犇使用一顿晚饭的时间爆切并当成作业布置给我的题...

虽然是紫，但实际难度处于可以接受的范围内。

## 题目分析

开始的思路是 $\text{set}$ 乱搞，因为发现对于每一次操作，如果执行那么一定会对前面的字符串有影响，所以直接放进 $\text{set}$ 判重，最后输出元素个数即可。

但是这样要记录上一次处理时的**状态**，实现起来会很怪，而且复杂度似乎不是很对，所以最后就放弃了。

------------

但是有刚刚的尝试，不难想到正解：**动态规划**。

在定义状态方面，我原来选择的是二维，用 $dp_{i,0}$ 表示不选择第 $i$ 个操作，$dp_{i,1}$ 表示选择，看它们可能得到的字符串数量。

但是后来发现可以直接压一维，直接用 $dp_i$ 就可以了。

------------

由于删除操作明显异于加入任何一个字符，所以进行分类讨论。

- **添加字符**

1. 新添加的字符没有被出现过

这种情况下不会出现与之前重复的字符串，所以直接乘就可以了。

$$dp_i = dp_{i-1} \times 2$$

2. 新添加的字符已经出现过

开始没有专门考虑这种情况，而是想办法用其他东西，比如刚刚提到的 $\text{set}$ 判重。

但是这个东西可以直接放到状态转移方程里面。 

我们考虑记录每一个字符最后出现的位置，记为 $des$。那么可以推出，需要去的重复个数就是 $dp_{des - 1}$。

为什么？~~我也不知道~~

所以我去问了 @yinhee 神犇（也是作业布置者），搞明白了原理。由于这个字符已经出现过，所以在第 $i$ 个操作出现时，第 $des$ 到 $i - 1$ 可以不执行，这样该字符串的末尾并不会改变。所以这一部分是需要去掉的，即可得出：

$$dp_i = dp_{i-1} - dp_{des-1}$$

- **删除字符**

1. 此前执行过添加字符

此时无论干什么，求出的都一定是重复的情况，不用记录。

$$dp_i = dp_{i-1}$$

2. 此前没有执行过添加字符

如果我们操作了 $x$ 次删除字符，如果 $x \le n-1$ ，那么就可以得到一种新情况。

$$dp_i = dp_{i-1} + 1$$

- **特殊处理**

这种其实最好想，即一个字符如果刚被删除就被加到了最后，这种情况没有被前面任何一种情况包括进去，单独处理即可。

## 贴上代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=19260817;
const int maxn=5000005;
int n,m,a[30];
int cnt;
int dp[maxn];
string s,u;
inline void init(){
	cin>>n>>m;
	cin>>s>>u;s=" "+s;u=" "+u;
	dp[0]=1;
}
signed main(){
	init();
	for(register int i=1;i<=m;++i){
		if(u[i]=='u'){ //是删除 
			if(cnt<n){
				dp[i]=dp[i-1]+1;
				a[s[n-cnt]-'A'+1]++;
			}
			else dp[i]=dp[i-1];
			cnt++;
		}
		else{ //不是
			dp[i]=dp[i-1]*2%mod;
			dp[i]=(dp[i]-a[u[i]-'A'+1]+mod)%mod;
			a[u[i]-'A'+1]=dp[i-1];
		}
	}
	cout<<dp[m]%mod;
}
```

---

## 作者：ouuan (赞：5)

~~这题的模数为什么这么奇怪应该不用我解释了~~

> 注：在本文中序列加法定义为拼接两个序列成一个序列。如：$\{A,B\}+\{C\}=\{A,B,C\}$

### 一、

首先考虑没有退格的情况，等同于求一个序列的本质不同子序列个数。

把子串 $t_{0..i}$ 看作一个序列，用 $\widetilde{t_{0..i}}$ 代指其所有本质不同的**非空**子序列， $f_i$ 表示其本质不同的非空子序列的总个数。为得到 $f_i$，考虑线性 $dp$ 转移。

在递推过程中，如果 $t_i$ 表示的字母第一次出现，即 $t_{0..i-1}$ 中没有字符与 $t_i$ 相同。此时 $\widetilde{t_{0..i}}$ 分 $3$ 类：

- $1.\ \widetilde{t_{0..i-1}}$，共有 $f_{i-1}$ 个。

- $2.\ \widetilde{t_{0..i-1}} + \{t_i\}$，仍有 $f_{i-1}$ 个。

- $3.\ \widetilde{t_{0..i-1}}$ 不包含空序列，所以第 $2$ 类中不包含 $\{t_i\}$，单独讨论，共有 $1$ 个。

综上所述，若 $t_i$ 第一次出现，$f_i = 2f_{i-1} + 1$。

那万一 $t_i$ 不是第一次出现呢？按照上面的讨论，必定会产生重复的答案。

令 $lst[x]$ 表示字符 $x$ 上一次出现的位置。$\widetilde{t_{0..lst[t_i] - 1}} + \{t_{lst[t_i]}\}$ 与 $\widetilde{t_{0..lst[t_i] - 1}} + \{t_i\}$ 重复，$\{t_{lst[t_i]}\}$ 与 $\{t_i\}$ 重复。所以 $f_i$ 要减去 $f_{lst[t_i]-1}+1$。

为什么仅有这些子序列重复呢？因为重复的解必然以 $t_i$ 结尾，而 $f_{lst[t_i]-1}+1$ 已经包含了 $t_{0..lst[t_i]}$ 这个序列所有以 $t_i$ 结尾的本质不同子序列了（仔细想想就能明白为什么）。

总结一下转移方程：

$f_i=\begin{cases}2f_{i-1}+1\quad(t_i\text{第一次出现})\\2f_{i-1}-f_{lst[t_i]-1}\quad (t_i\text{出现过})\end{cases}$

只要 $O(m)$ 的时间复杂度便可实现以上递推。

### 二、

接着考虑如何处理退格。

打出了一个字母但被之后的退格所删除，无异于打字操作与退格操作都没有进行。所以只用考虑 $\mathrm{u}$ 排在最开头的情况。

当有效的 $\mathrm{u}$ 一共有 $k$ 个时，只用考虑这 $k$ 个 $\mathrm{u}$ 为操作串 $t$ 从左往右数的前 $k$ 个 $\mathrm{u}$ ，这包含了所有答案。

以 $pre[i]$ 表示 $t_{i+1..m-1}$ 第一个不是 $\mathrm{u}$ 的位置。同时，**下文中本质不同的子序列一律不包含 $\mathrm{u}$**。

设第 $k$ 个 $\mathrm{u}$ 的位置为 $p_k$，退 $k$ 次格新增的本质不同子序列包括 $s_{0..n-k-1} + \widetilde{t_{pre[p_k]..m-1}}$，以及 $s_{0..n-k-1}$。我们把目光放到 $\widetilde{t_{pre[p_k]..m-1}}$ 上，如果对于每个 $k$ 都做一次顺推 $dp$，时间复杂度将会退化至 $O(m ^ 2)$。但是，右端点 $m-1$ 始终不变，把顺推转换为倒推即可。

所以，$f_i$ 的意义就变为 $\widetilde{t_{i..m-1}}$ 的总个数，$lst[x]$ 的意义就变为倒推时字符 $x$ 上一次出现的位置。此外，由于退格符 $\mathrm{u}$ 的存在，转移方程中的 $f_{i-1}$ 改为 $f_{pre[i]}$。

于是，我们得到了一个（错误）的算法：

- 倒推，对于每个大写字母计算 $f_i$，对于每个 $\mathrm{u}$ 把答案加上 $f_{pre[p_k]}+1$（加一是因为 $f_{pre[p_k]..m-1}$ 不含 $s_{0..n-k-1}$），最后再加上 $f_{pre[0]}+1$ ( $pre[0]$ 表示 $t_{0..m-1}$ 中第一个非 $\mathrm{u}$ 的位置)

和第一部分类似，若退格所删去的最后一个字符即 $s_{n-k}$ 在 $t_{pre[p_k]..m-1}$ 中出现过，这个算法会产生重复的答案：第 $k$ 个 $\mathrm{u}$ 在原串 $s$ 中删除的字符是 $s_{n-k}$，而在做第 $k - 1$ 个 $\mathrm{u}$ 时，这个字符并不会被删除。想象一下，一旦 $s_{n-k}$ 在 $t_{pre[p_k]..m-1}$ 中出现过，就意味着可以把刚删除的 $s_{n-k}$ 的给打回去，这与做第 $k - 1$ 个 $\mathrm{u}$ 时的情形相同。所以重复计算的本质不同子序列为 $s_{0..n-k}+\widetilde{t_{pre[lst[s_{n-k}]]..m-1}}$ 以及 $s_{0..n-k}$，个数为 $f_{pre[lst[s_{n-k}]]}+1$，计算答案时要将这部分减去。

仅有这些重复的原因同第一部分所述。

需要注意的是，如果 $\mathrm{u}$ 的个数大于 $n$，要忽略最后面的一些 $\mathrm{u}$，只考虑前 $n$ 个。

### 代码

题解写了一大堆..然而代码非常短。

```
#include <iostream>
#include <cstdio>

using namespace std;

const int N=5000010;
const int M=0x125E591;

int uniq(char x); //计算重复

char s[N],t[N];
int n,m,lst[300],pre[N],pos,cnt,f[N],ans; //pos记录当前扫到的最后一个非u的位置，cnt表示还没扫到的u的个数

int main()
{
	int i;
	
	scanf("%d%d%s%s",&n,&m,s,t);
	
	for (i=0;i<m;++i)
	{
		cnt+=t[i]=='u';
	}
	
	for (i=m-1;i>=0;--i)
	{
		if (t[i]!='u')
		{
			f[i]=(2*f[pre[i]=pos]+uniq(t[i]))%M;
			pos=lst[t[i]]=i;
		}
		else
		{
			if (n-cnt>=0) //如果u的个数大于n，要忽略最后面的一些u
			{
				ans=(ans+f[pos]+uniq(s[n-cnt]))%M;
			}
			--cnt;
		}
	}
	
	ans=(ans+f[pos]+1)%M;
	
	printf("%d",ans);
	
	return 0;
}

int uniq(char x)
{
	return lst[x]?M-f[pre[lst[x]]]:1; //M-f[pre[lst[x]]]就是-f[pre[lst[x]]]，因为是在模意义下运算所以+M
}
```

---

## 作者：zzxLLL (赞：4)


[![0](https://pic.imgdb.cn/item/64d8d90b1ddac507cc5a7bfc.png)](https://www.luogu.com.cn/problem/P4965)

上图是题目链接。

---

神奇计数题。
~~话说打字机能退格吗（~~

下面称原串为 $S$，操作串为 $T$。

$n, m \leq 5 \times 10^6$，所以只能用一维状态。

设 $f_x$ 表示前 $x$ 次操作，可能形成的不同字符串个数。对于插入字符和退格两种操作分类转移。

### 插入字符

如果此时打字机没有反应，那么这次按了和没按一样。$f_x = f_{x - 1}$。

而如果此时打字机有反应，那么之前形成的不同字符串后面都要接上字符 $T_x$。但是这样会算重复。

具体而言，若上一次插入字符 $T_x$ 是在第 $y$ 个操作。$S'$ 是前 $y - 1$ 次操作形成的字符串之一。那么「第 $y$ 次操作有反应，$y + 1 \sim x$ 次操作都没反应」和「第 $y \sim x - 1$ 次操作都没反应，第 $x$ 次操作有反应」都相当于在 $S'$ 末尾加上字符 $T_x$，就形成重复了。

每个 $S'$ 都被算重了一遍，所以有反应时 $f_x = f_{x - 1} - f_{y - 1}$，$y$ 是 $T_x$ 在 $T$ 中上一次出现的位置。

故 $f_x = 2f_{x - 1} - f_{y - 1}$。

### 退格

先考虑一种情况：全部插入字符操作打字机都没反应，全部退格操作打字机都有反应。显然这样得到的就是 $S$ 的一段前缀。

然后看转移。不论打字机有没有反应，$f_x = f_{x - 1}$。因为不论退格不退格产生的字符串都在前 $x - 1$ 次操作出现过了。

但是如果打字机恰好执行了全部的退格操作，没有执行任何的插入字符操作。假设第 $x$ 次操作以及之前共有 $k$ 次退格操作，那么前 $x - 1$ 次操作最多得到 $S$ 的长度为 $n - k + 1$ 的前缀。而执行完第 $x$ 次操作，就能得到长度为 $n - k$ 的前缀。情况数恰好多了一种，$f_x = f_{x - 1} + 1$。当 $k \ge n$ 时这种转移不生效。

答案为 $f_m$。时间复杂度 $O(m)$。

```cpp
#include<cstdio>
const int mod=19260817;
const int M=5e6+10;

char S[M],T[M];
int n,m,f[M];
int pre[26],cntu;

int main(){
	scanf("%d%d",&n,&m);
	scanf(" %s",S+1),scanf(" %s",T+1);
	f[0]=1;
	for(int i=1;i<=m;i++){
		if(T[i]=='u'){
			f[i]=f[i-1]+(bool)(cntu<n);
			if(cntu<n) pre[S[n-cntu]-'A']++;
			cntu++;
		}else{
			f[i]=(f[i-1]*2-pre[T[i]-'A']+mod)%mod;
			pre[T[i]-'A']=f[i-1];
		}
	}
	printf("%d\n",f[m]);
	return 0;
}
```

---

## 作者：Karl_Aurora (赞：2)

**[~~无耻地推销个人博客 qwq~~](https://www.luogu.com.cn/blog/ling-XAIqwq/solution-p4965)**

**[题目传送门](https://www.luogu.com.cn/problem/P4965)**

------------

## 题意

给定一个初始的字符串 $S$ 和 $m$ 次操作，每次操作分为两种，分别是在字符串末尾加入一个大写字母与删去字符串末尾的字母，且均有一定可能不生效，求最后可能生成的不同字符串的个数。

## 解法

我们首先考虑我们已经求出了前 $k-1$ 次操作得到的所有不同字符串，且第 $k$ 次操作为加入字母，那么无非就是两种可能：成功加入和失败加入。

失败的情况下很简单，此时无论字符串是怎样的，它都不会改变，所以原来有多少个不同的字符串现在还是有多少个。

接下来考虑成功的情况，一个很直观的想法就是对于原来的每个字符串，我们都在其后面加入了一个新字母，从而创造了一个新串，所以新串个数应当等于原串的个数。

但是显然在这种做法下会出现新串与原串相同的情况，比如对于输入

```
1 3
C
ABA
```

在处理至第三个操作时可能的新串```CA(失效)B(失效)A```明显是与先前的```CA```相同的，所以我们需要想出一个办法来去重。

注意到这种情况下其本质相当于这个字符串的最后一个字母可以来自于当前的操作，也可以来自于先前的操作，所以对于任意一次操作得到的结尾为 $c$ 的字符串的所有情况中，一定包含所有先前加入 $c$ 的操作可以得到的字符串（考虑从那次操作开始一直失效到这次操作的上一次）。

所以为了去重，我们每次操作记完后，更新一下以这次操作的字母结尾的字符串数量，那么在统计每次操作的答案时只需要在答案中去掉以当前操作字母结尾的字符串个数即可，因为它们被重复计算了一遍。

那么由加法原理，对于加入字符 $c$ 的操作，我们可以得到加入后其答案：

$ans=lastans+(lastans-strcnt_c)$

随后有

$strcnt_c=lastans$

后一个式子的意义是对于先前的每一个字符串末尾都加入 $c$，由于先前的串两两不同，新串也必然两两不同，且结尾均为 $c$，可以证明这些新串即是这次操作后得到的所有可能的以 $c$ 结尾的字符串。

处理完加入操作后，我们再来考虑删除操作。由于所有加入操作都可能失效，所以我们不难看出加入某个字母后再执行删除操作直接等价于这次加入操作失效，所以只有删除一开始给出的原串才可能对答案有所影响。

所以对于每次合法的删除操作，其对答案的贡献为 $1$，即删除原串最后一个字母所得到的新串。同时，令被删去的字符为 $c$，则考虑到重复计算的因素，$strcnt_c$ 显然是需要加 $1$ 的，即删除未执行造成的重复。

那么这道题的完整动态规划思路就完成了。

最后代码如下：

```cpp
#include <bits/stdc++.h>
#define mod 19260817
using namespace std;
int n, m;
string str, opt;
int ans = 1, lastopt[30], p;
int main()
{
    ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);
    cin >> n >> m;
    cin >> str >> opt;
    p = n - 1;
    for (int i = 0; i < m; ++i)
    {
        if (isupper(opt[i]))
        {
            int mem = lastopt[opt[i] - 'A'];
            lastopt[opt[i] - 'A'] = ans;
            ans = (((ans * 2 - mem) % mod) + mod) % mod;
        }
        else
        {
            if (p < 0) continue;
            lastopt[str[p] - 'A'] = (lastopt[str[p] - 'A'] + 1) % mod;
            --p, ans = (ans + 1) % mod;
        }
    }
    cout << ans << endl;
    return 0;
}
```

至此，愉快 AC，完结撒花

---

## 作者：JasonL (赞：2)

## P4965 【薇尔莉特的打字机】
[题目传送门](https://www.luogu.com.cn/problem/P4965)

### 分析

处理字符串的时候我们往往想到Trie.这里我们用Trie来对题目进行分析.

对于初始串（下图以ABA为例）,我们构建的Trie如下所示.

（其中**加黑的节点表示可作为字符串结尾的节点**.下文简称“关键点”）

![初始状态](https://cdn.luogu.com.cn/upload/image_hosting/ze8m2jgb.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

题目中有添加和删除两种操作.这里我们先考虑添加字符的操作.

![添加（字符A）](https://cdn.luogu.com.cn/upload/image_hosting/dhdabzkf.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

由于可能添加失败，原先的关键点仍然可以作为字符串结尾.同时，新的节点也可以作为字符串的结尾.

那么，我们假定添加前有a个关键点，由于对于每一个关键点都可以产生一个新的关键点，添加后的关键点总数似乎为2a.

然而我们考虑下面的情况.

![添加（字符B-A）](https://cdn.luogu.com.cn/upload/image_hosting/28gi3n8b.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

在初始串为AB，添加了新字符A的情况下，我们尝试再添加一个字符A.我们发现，新产生的关键点数并不是2而是1.这是由于字符B已经有了一个字符为A的儿子，在B节点后接上A会产生重复.

因而新产生的关键点数应该为**满足没有该字符代表的儿子的关键点总数**.

我们假定添加字符ch前有a个关键点，共有b个关键点已经有了字符为ch的儿子.那么，**添加后的关键点总数应为2a-b个.而原先的a个关键点在更新后全部有了字符为ch的儿子.**

由此，我们可以**令ans表示处理到当前字符时的关键点总数，新添加的字符为第ch种字符，f[i]表示已经有第i种字符的儿子的关键点总数.添加后我们得到的$ans'=2ans-f[ch]$.同时更新$f[ch]=ans$.**

再继续考虑删除的情况.删除字符可以看作在Trie上从每一个关键点向上跳.

![删除](https://cdn.luogu.com.cn/upload/image_hosting/7tiap8xe.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

由于之前添加的字符所代表的的关键点上跳必然是关键点（由上定义可知），因而只有初始串部分才有可能产生新的关键点（最上端的关键点上跳到从属于初始串的非关键点节点）.这时候产生的新关键点数只有1.（父亲只有一个）

但是，如果最上端的关键点已经不能再上跳了（到达Trie的根节点），删除操作就不能再产生新的节点了.同时注意，上跳时产生的新关键点已经有了一个儿子（上调前的关键点），要在f数组中记录下来.

利用Trie分析完成后我们就可以完成代码了.

（由上文可知，我们并不需要实际创建一个Trie，因为每一个操作都可以利用递推+临时变量完成，而ans的值也并不依赖Trie的操作，可以直接递推.具体可以看下面的代码.）


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
const int maxn=5010000;
const long long mod=0x125E591;
int n,m;
long long f[27],ans;
char s[maxn];
inline int read(){
	int res=0;
	char ch=getchar(),ch1=ch;
	while(!isdigit(ch))ch1=ch,ch=getchar();
	while(isdigit(ch))res=(res<<3)+(res<<1)+ch-'0',ch=getchar();
	return ch1=='-'?-res:res;
}
inline char readchar(){
	char ch=getchar();
	while(!((ch>='A'&&ch<='Z')||(ch=='u')))ch=getchar();
	return ch;
}
long long modF(long long p){
	if(p>mod)p%=mod;
	else if(p<0)p=(p%mod)+mod;
	return p;
}
int main(){
	n=read();m=read();
	for(register int i=1;i<=n;++i)
		s[i]=readchar();						//读入初始串
	char g;ans=1;
	for(register int i=0;i<m;++i){
		g=readchar();
		if(g=='u'){								//删除
			if(!n)continue;						//已经到达Trie的根节点
			else{
				ans=(ans+1)%mod;				//添加新的关键点
				f[s[n]-'A']=(f[s[n]-'A']+1)%mod;//更新f[ch]
				--n;							//关键点上跳
			}
		}
		else{									//添加
			long long tmp=f[g-'A'];				//记录添加前f[ch]的数值
			f[g-'A']=ans;						//更新f[ch]
			ans=(((ans<<1)-tmp)%mod+mod)%mod;	//更新ans
		}
	}
	printf("%lld",ans);
	return 0;
}
```



---

## 作者：creation_hy (赞：1)

题目容易想到在 Trie 上搜索，当然直接搜点数会爆炸。

容易发现已经点亮的点（能走到的点）是不会清除的，于是键入 $x$ 操作就变成了让当前所有没有 $x$ 这个叉的点加一个 $x$ 叉的儿子，退格则为将所有节点的父亲节点点亮（而除了起点以外所有点的父亲都在它之前就点亮了，所以只对起点生效），最终答案即为总节点数。

开一个数组 $f_i$ 记录当前有多少个点没有 $i$ 叉即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod = 19260817;
int n, m, f[26], tot, cnt;
string s1, s2;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> n >> m >> s1 >> s2;
	tot = 1;
	for (char c : s2)
		if (c != 'u')
		{
			c -= 'A';
			int t = tot;
			(tot += t - f[c] + mod) %= mod, f[c] = t;
		}
		else if (cnt < n)
			(tot += 1) %= mod, (f[s1[n - ++cnt] - 'A'] += 1) %= mod;
	cout << tot << '\n';
	return 0;
}
```

---

## 作者：Into_qwq (赞：1)

前言：~~这是我的第200道AC的题目，我好菜啊~~这道题目不知为何就提交了很多次，有没有大佬能给我解释一下这个玄学问题啊(我太菜了)

首先，这题需要处理字符串，我们用$trie$分析

先忽略删除操作

拿样例1举个例子：

首先把最开始的字符串插入到树中

![](https://cdn.luogu.com.cn/upload/image_hosting/relmb9ew.png)

然后薇尔莉特打了一个字符$A$

此时可以插入或者是不插入，就会有这样的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/a90vf6lo.png)

不插入时，之前插入进去的字符均可以作为字符串的结尾

假设之前插入了$x$个字母，每一个字母都可以作为串的结尾

现在插入这个字符，总数似乎又增加了$x$个

继续看样例1，此时薇尔莉特又打了一个字符$A$

此时把它插入树中，就是这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/ys5gmikk.png)

此时能作为串的结尾的数仍然只有$A$，重复了

所以如果新产生的可以作为结尾的节点

那么没有可以作为结尾的节点和这个节点相同

可能说的有点绕，举个例子：

假如$A$已经存在于这棵树中并且可以作为结尾

那么再插入一个$A$不能增加可以作为结尾节点的数量

令$ans$表示插入之前可以作为结尾节点的节点数量

新插入的字符为$x$

$f_i$表示已经有第$i$种字符的可以作为结尾节点的总数

我们可以算出现在的$ans$=之前的$ans$×$2$-$f_{ch}$，$f_{ch}$=原来的$ans$



------------


接下来是删除部分

此时我们已经插入了这几个节点：

![](https://cdn.luogu.com.cn/upload/image_hosting/ys5gmikk.png)

删除的过程其实就是去掉当前节点往上跳的过程

比如说删除当前的$A$之后就是这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/zel4b37v.png)

删除了这个节点往上跳，上面的节点一定是可以作为结尾节点的节点

所以此时新产生的结果只有1，加1即可

模拟$trie$的操作，直接递推就好了


------------

P.S. 看到这个题的模数有点懵，太菜了不知道是什么，于是……

![](https://cdn.luogu.com.cn/upload/image_hosting/36fis2d7.png)

然而还是布吉岛这个模数为什么这么怪$qwq$


------------

下面是代码：
```c++
#include<bits/stdc++.h>
using namespace std;
const int yyf=19260817;//日膜yyf
int n,m;
int f[100];
char s[5000002];
int main(){
	cin>>n>>m;
	scanf("%s",s+1);				
	char ch;int ans=1;
	while(m--){
		cin>>ch;
		if(ch=='u'){							//删除操作	
			if(!n)continue;						//没有可以删除的了
			else{
				ans=(ans+1)%yyf;				//+1
				f[s[n]-'A']=(f[s[n]-'A']+1)%yyf;//+1
				--n;							//删除节点往上跳
			}
		}
		else{								
			int tmp=f[ch-'A'];					//暂时保存
			f[ch-'A']=ans;						//赋值
			ans=((ans+ans-tmp)%yyf+yyf)%yyf;	//算ans
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：lllyyykkk (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/P4965)

~代码好简短的紫题。~

考虑对每一种字符都开一个桶，记录当前对应的答案数。  
很想当然的，每一个字符都有成功和没成功两种可能。  
但假如操作为`AA`，显然前者成功还是后者成功最后的结果是一样的。  
所以在遇到一个字母时，只要把桶内已有的结果数剪剪掉，防止上文所说的重复即可。  
再来看退格，对于 $B$ 串，相当于加入失败，上面已经处理了，所以只要考虑在 $A$ 串上的影响，在实际操作时只要把相应桶里的值加 $1$ 即可。

所以代码也就不难写出了。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=5e6+10,mod=19260817;
int n,m,cnt,ans=1;
char a[N],b[N];
int t[30];
signed main(){
	cin>>n>>m>>a+1>>b+1;
	for(int i=1;i<=m;i++){
		if(b[i]>='A'&&b[i]<='Z'){
			int x=t[b[i]-'A'];
			t[b[i]-'A']=ans;
			ans=((ans*2-x)%mod+mod)%mod;
		}
		else{
			if(!n) continue;
			t[a[n]-'A']++,ans++;
			if(t[a[n]-'A']>mod) t[a[n]-'A']-=mod;
			if(ans>mod) ans-=mod;
			n--;
		}
	}
	cout <<ans;
	return 0; 
}
``````

---

## 作者：Kketchup (赞：0)

## P4965 薇尔莉特的打字机 题解

[题目传送门](https://www.luogu.com.cn/problem/P4965)

- DP

### 【题目描述】

给定长度为 $n$ 的初始字符串 $A$ 和长度为 $m$ 的操作字符串 $B$。根据操作字符串 $B$ 在 $A$ 上进行两种操作，删除末尾字符（$B_i=u$）或在末尾添加一个字符（$B_i$ 为大写字母）。每次操作都可能不成功，求最终所得字符串的方案数，对 $19260817$ 取模。

$1\le n,m\le 5\times 10^6$。

### 【题目解析】

手玩样例以后没啥性质，就是计数题，所以考虑直接 DP。

设 $f_i$ 表示进行了前 $i$ 个操作所得字符串的方案数，没错就是这么简洁！

初始状态 $f_0=1$，因为 $A$ 串就是一种方案，答案 $f_m$。

转移分类讨论两种：添加与删除。

- 添加：

也有两种情况，这个字符已经出现过或者没有出现过。

$1.$ 没有出现过。

这个字符只要加到原串末尾就能变成新的串。

所以 $\large f_i=f_{i-1}\times 2$。

$2.$ 已经出现过。

那么这样一定会重复。

设当前位置为 $i$，当前字符上次出现位置为 $pos_i$，则 $\large f_i=f_{i-1}-f_{pos_i-1}$。

原因在于，对于 $j\in [pos_i,i-1]$，如果所有的操作 $j$ 都不成功，而这次将 $i$ 添加到字符串后面，则相当于把 $pos_i$ 添加到字符串后面，情况完全相同，所以要减掉。
- 删除：

一般来讲，删除操作不影响方案数，但有特殊情况，即前面的添加不成功，删除删掉了 $A$ 中的字符。

具体地，设当前删除次数为 $k$（不包含本次），那么当 $k<n$，有可能会减成 $A$ 的前缀。那么 $\large f_i=f_{i-1}+1$。

否则就是普通情况，$\large f_i=f_{i-1}$。

这样就完了吗？非也。发现一种特殊情况：一个串删除一个字符再添加一个相同字符时，答案会多算。

所以直接设 $c_x$ 表示字符 $x$ 在之前的贡献（类似于 $f_{pos_i-1}$），每次删除的时候记得更新。

最后线性转移即可，时间复杂度 $O(n)$，注意减法取模可能出负数。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define endl '\n'
const int N=5e6+10,mod=19260817;
int n,m;
string a,b;
ll f[N],c[30];
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin>>n>>m>>a>>b;
    a=" "+a,b=" "+b;
    f[0]=1;
    for(int i=1,cnt=0;i<=m;++i){
        if(b[i]=='u'){
            f[i]=f[i-1];
            if(cnt<n){
                f[i]=(f[i]+1)%mod;
                c[a[n-cnt]-'A'+1]++;
            }
            cnt++;
        }
        else{
            f[i]=f[i-1]*2%mod;
            f[i]=(f[i]-c[b[i]-'A'+1]+mod)%mod;
            c[b[i]-'A'+1]=f[i-1];
        }
    }
    cout<<f[m]<<endl;
    return 0;
}
```

---

## 作者：xyzfrozen (赞：0)

退役啦，最后做个 1k $AC$。

对字符串计数，我们想到利用 Trie 来压字符串状态，即节点代表唯一字符串，这样只需要数树上的合法节点数量就是答案，初始的合法节点只有原串。

1. 输入

称可到达的字符串状态为点亮的节点。

输入字符 `c` 操作就是所有点亮节点能够延伸出一个儿子 $c$，但是不一定每个点亮节点原来都没有这个 $c$ 儿子，这一部分**并不会**产生新的贡献。

由此我们知道贡献就是当前状态下没有儿子 $c$ 的点亮节点个数，设 $f_c$ 表示有儿子 $c$，且 $c$ 为点亮点的个数。

$$ans \leftarrow ans \times 2-f_c$$

同时更新 $f_c=ans$，注意是原来的 $ans$，因为原来的每个节点，不管有没有点亮的儿子 $c$，现在都有儿子 $c$ 了，反证可知不会算多。

2. 退格

如果我们先输入**新的**的字符，再退格，等价于没有输入这个字符，原来没输入的状态也是点亮节点，没有贡献产生。

由此我们可以知道贡献只会在**原有**的字符串退格产生，且每次只会增加一，可以想象 Trie 最初是一条链，**原链**下面挂了一堆点亮节点，每次从**原串代表节点**向上跳链，并更新**原串代表节点**。

$code$

```cpp
#include<bits/stdc++.h>
#define int long long
#define pt putchar(' ')
#define nl puts("")
#define pi pair<int,int>
#define pb push_back
#define go(it) for(auto &it:as[x])
using namespace std;

const int N=5e6+10,Q=19260817;
int n,m,ans=1;
int f[N];
char s[N],t[N];

int fr(){
    int x=0,flag=1;
    char ch=getchar();
    while(ch<'0' || ch>'9'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9'){
        x=x*10+(ch-'0');
        ch=getchar();
    }
    return x*flag;
}
void fw(int x){
	if(x<0) putchar('-'),x=-x;
    if(x>9) fw(x/10);
    putchar(x%10+'0');
}
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}

signed main()
{
	n=fr(),m=fr();
	scanf("%s%s",s+1,t+1);
	for(int i=1,nps=n;i<=m;i++)
	{
		int c=t[i]-'A';
		if(t[i]!='u')
		{
			int org=f[c];
			f[c]=ans,ans=(ans*2%Q-org+Q)%Q;
		}
		else if(nps)
			c=s[nps--]-'A',(f[c]+=1)%=Q,(ans+=1)%=Q;
	}
	fw(ans);
	return 0;
}
```

---


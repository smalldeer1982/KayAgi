# [NOIP 2018 提高组] 填数游戏

## 题目背景

NOIP2018 提高组 D2T2

## 题目描述

小 D 特别喜欢玩游戏。这一天，他在玩一款填数游戏。
  
这个填数游戏的棋盘是一个 $n \times m$ 的矩形表格。玩家需要在表格的每个格子中填入一个数字（数字 $0$ 或者数字 $1$），填数时需要满足一些限制。   

下面我们来具体描述这些限制。   

为了方便描述，我们先给出一些定义： 
 
-  我们用每个格子的行列坐标来表示一个格子，即（行坐标，列坐标）。注意：行列坐标均从 $0$ 开始编号。
- 合法路径 $P$：一条路径是合法的当且仅当：   
    1. 这条路径从矩形表格的左上角的格子 $(0,0)$ 出发，到矩形的右下角格子 $(n - 1,m - 1)$ 结束；   
    2. 在这条路径中，每次只能从当前的格子移动到右边与它相邻的格子，或者从当前格子移动到下面与它相邻的格子。
    
  例如：在下面这个矩形中，只有两条路径是合法的，它们分别是 $P_1$：$(0,0)\to (0,1)\to (1,1)$ 和 $P_2$：$(0,0) \to (1,0) \to (1,1)$。
   
![](https://cdn.luogu.com.cn/upload/pic/43256.png)  

对于一条合法的路径 $P$，我们可以用一个字符串 $w(P)$ 来表示，该字符串的长度为 $n + m - 2$，其中只包含字符 $\texttt R$ 或者字符 $\texttt D$，第 $i$ 个字符记录了路径 $P$ 中第 $i$ 步的移动方法。$\texttt R$ 表示移动到当前格子右边与它相邻的格子，$\texttt D$ 表示移动到当前格子下面与它相邻的格子。例如，上图中对于路径 $P_1$，有 $w(P_1) = \texttt {RD}$；而对于另一条路径 $P_2$，有 $w(P_2) = \texttt {DR}$。   

同时，将每条合法路径 $P$ 经过的每个格子上填入的数字依次连接后，会得到一个长度为 $n + m - 1$ 的 $01$ 字符串，记为 $s(P)$。例如，如果我们在格子 $(0,0)$ 和 $(1,0)$ 上填入数字 $0$，在格子 $(0,1)$ 和 $(1,1)$ 上填入数字 $1$（见上图红色数字），那么对于路径 $P_1$，我们可以得到 $s(P_1) = 011$，对于路径 $P_2$，有 $s(P_2) = 001$。 

游戏要求小 D 找到一种填数字 $0$、$1$ 的方法，使得对于两条路径 $P_1$，$P_2$，如果 $w(P_1) > w(P_2)$，那么必须 $s(P_1) ≤ s(P_2)$。我们说字符串 $a$ 比字符串 $b$ 小，当且仅当字符串 $a$ 的字典序小于字符串 $b$ 的字典序，字典序的定义详见第一题。但是仅仅是找一种方法无法满足小 D 的好奇心，小 D 更想知道这个游戏有多少种玩法，也就是说，有多少种填数字的方法满足游戏的要求？ 

小 D 能力有限，希望你帮助他解决这个问题，即有多少种填 $0$、$1$ 的方法能满足题目要求。由于答案可能很大，你需要输出答案对 $10^9 + 7$ 取模的结果。 

## 说明/提示

**样例解释**  

![](https://cdn.luogu.com.cn/upload/pic/43257.png)  

**数据规模与约定** 

| 测试点编号 | $n\le$ | $m\le$ |
| :-----------: | :-----------: | :-----------: |
| $1\sim 4$ | $3$ | $3$ |
| $5\sim 10$ | $2$ | $10^6$ |
| $11\sim 13$ | $3$ | $10^6$ |
| $14\sim 16$ | $8$ | $8$ |
| $17\sim 20$ | $8$ | $10^6$ |


## 样例 #1

### 输入

```
2 2```

### 输出

```
12```

## 样例 #2

### 输入

```
3 3```

### 输出

```
112```

## 样例 #3

### 输入

```
5 5```

### 输出

```
7136```

# 题解

## 作者：xenonex (赞：290)

**upd on 2018.12.28 修复了证明$Ans(n,m+1)=3 \times Ans(n,m)$的bug**

------------

当初在考场上看到数据范围以为是个玄学状压+找规律，想了一会感觉不可做的样子，于是就弃掉去淦T3了QAQ。现在我花了一晚上+一上午手玩样例推柿子，并且还口胡了这篇有~~严格~~证明的题解造（bao）福（fu）社会。

对于这道NOIplus题目，首先需要yy出两个重要的性质：

性质1、每一条对角线上填的数是单调不增的。

性质2、如果(x-1,y)和(x,y-1)的填的数相同，那么以(x,y)为左上角、以整个矩阵的右下角为右下角的子矩阵内所有对角线内的填数各自相同。

注意本文中的对角线均指从左下到右上的对角线。

![](https://i.loli.net/2018/12/26/5c2327ccb9643.png)

有时为了避免混淆，我会画成下面这个样子

![](https://i.loli.net/2018/12/26/5c23281e3108e.png)

~~总之黑框表示框里的对角线的填数要相等~~

这两个结论很容易用反证来证明，具体细节请读者自行撕烤

然后还有一个听说很显然的结论：令$Ans(n,m)$表示宽为$m$高为$n$的矩阵填数方案，则$Ans(n,m)=Ans(m,n)$。

不明白怎么回事的同学可以这样考虑

对于一个合法的$m>n$的方案，将填入的数全部反转，然后将整个矩阵顺时针转90°，最后把矩阵左右轴对称一下，就能得到一个$n>m$的方案。

![](https://i.loli.net/2018/12/26/5c232e36e39b6.png)

![](https://i.loli.net/2018/12/26/5c232e36e51ec.png)

![](https://i.loli.net/2018/12/26/5c232e36d0c17.png)

~~看上去没问题~~

于是为了方便，后文全部默认$n \le m$。

到这里就已经能手摸出$n=1$和$n=2$的情况了。我们将整个矩阵按照每一条对角线划分为若干个阶段，稍微画下图就能看出$Ans(1,m)=2^m$以及$Ans(2,m)=4 \cdot 3^{m-1}$。注意这里是保证了m大于等于n的。

~~这两个式子应该不用多解释吧~~

对于$n \ge 4$，我们再分为4种情况考虑（$n=3$的情况稍后考虑）：

case1：最上面的两个填数相同

![](https://i.loli.net/2018/12/26/5c23331d298c4.png)

case2：最上面的两个数不同，下面一条对角线的3个填数相同

![](https://i.loli.net/2018/12/26/5c23331d3d6e8.png)

case3：那3个填数为1，0，0

![](https://i.loli.net/2018/12/26/5c23331d15e4b.png)

case4：3个填数为1，1，0

![](https://i.loli.net/2018/12/26/5c23331d2b7da.png)

容易发现无论是哪种情况，总是会存在一个点(x,y)使得(x-1,y)和(x,y-1)填数相同，这样就能够限制掉一大片区域，~~是手玩通项公式的重要保证~~。

发现这个性质后就能证明出另一结论了：对于$n \ge 4$且$m \ge n+1$，有$Ans(n,m+1)=3 \times Ans(n,m)$

证明其实超简单

![](https://i.loli.net/2018/12/26/5c233cae0fc11.png)

可以发现黑框里一定是被性质2限制掉的，所以整条绿色的对角线填数都相同，而且由于绿色方框位于矩阵下边界，它是不受其它填数限制的，换句话说在所有的合法方案中，有1/2的情况它等于0，剩下1/2的情况等于1

然后考虑在原矩阵右边再添一列

![](https://i.loli.net/2018/12/26/5c233dca5f74f.png)

灰色粗♂条划掉的方格由于受到性质2的影响，它们必须要与各自左下方的格子中填数相同，因此这一部分不会对答案产生新的贡献；但蓝色位于右下角，它的填数是自由的。

![](https://i.loli.net/2018/12/26/5c233ea616b80.png)

受到性质1的限制，若绿色格子内填数为1，则右上方的方格能填0或1，会产生$2\times2=4$倍的贡献；否则只能填0，只有$2\times1=2$倍的贡献。综合起来，总的贡献就是原来的$\frac{1}{2}\times4+\frac{1}{2}\times2=3$倍。

~~简单吧，没骗你~~

**upd**：第二天晚上发现自己zz了……

因为第二排的确有可能没有被覆盖到，就像这样

![](https://i.loli.net/2018/12/28/5c25cedb3b09b.png)

于是上面的证明就愉快地GG了

紧急修一波锅

跟之后推式子的操作一样，枚举第一次出现相同数的位置，我们发现当这个位置比较靠前使得红色方块被覆盖到时是无需考虑的，因为此时与上方的情形等价= =

于是把精力集中在这两种情况

![](https://i.loli.net/2018/12/28/5c25d20828655.png)

![](https://i.loli.net/2018/12/28/5c25d2083a061.png)

考虑第一张图，原先绿色部分有3种填法，添一列后运用类似的方法分析出产生的新贡献，它是原来的$\frac{2}{3}+\frac{2}{3}+\frac{4}{3}=\frac{8}{3}$倍

同理算出第二张图是原来的$4$倍

接着同时考虑这两种情况，算出倍数$\frac{(2^{n-2}\times3\times3\times2)\times\frac{8}{3}+(2^{n-2}\times3\times2)\times4}{2^{n-2}\times3\times3\times2+2^{n-2}\times3\times2}=\frac{2^{n+2}\times3+2^{n+1}\times3}{2^{n-1}\times9+2^{n-1}\times3}=\frac{8\times3+4\times3}{9+3}=3$

这才完成了$Ans(n,m+1)=3 \times Ans(n,m)$的证明

好的下面继续原来的内容

接下来考虑$m=n$的情况来摸柿子。请各位务必要看懂以下的推倒过程，其它更一般的推倒与这里大同小异。

首先看case1。

![](https://i.loli.net/2018/12/26/5c2342af63171.png)

联系两条限制条件，不难得出每条对角线上填数的方案数，我用蓝色在图上标注了一些边界情况。容易看出$case_1=2\times2\times4^{n-2}\times2^{n-1}=8^{n-1}$

这样case1就搞定了。

然后是case2

![](https://i.loli.net/2018/12/26/5c2346917550a.png)

得到$case_2=2\times2\times5\times4^{n-4}\times2^{n-1}=5\times2^{3n-7}$

于是case2也搞定了

到现在为止一切都很美好

接下来才是真正辣手的事情

下面是case3

![](https://i.loli.net/2018/12/26/5c2352d55a660.png)

这下不好办了，因为左边两列貌似都没有什么特别的限制。不过没关系，我们可以继续分类讨论下去

我们大力讨论左边两列的对角线上从上往下第一次出现两数相同的位置，所以这之上应该都填1,0。而此时出现了一个新的限制区域，将此区域与原来的区域取并集就成了下图黑框的样子

![](https://i.loli.net/2018/12/26/5c235d0a45b81.png)

然后就可以写出每条线上的方案了

注意当x=0时右上方的对角线只能填0，而x=1时三种情况都能填，所以x那里的线是4

于是我们找出一些边界情况后就能算出整个case3了

在第一个出现

![](https://i.loli.net/2018/12/26/5c235df32bf19.png)

在倒数第二个出现

![](https://i.loli.net/2018/12/26/5c235fe05e25b.png)

在最后一个出现

![](https://i.loli.net/2018/12/26/5c23603110c72.png)

别忘了没有的情况

![](https://i.loli.net/2018/12/26/5c236044c9151.png)

于是我们可以枚举x下方4的个数，得到$case_3=2\times4\times5\times\sum\limits_{i=0}^{n-5}4^i\times2^{n-1}+2\times4\times3\times2^{n-2}+2\times3\times2^{n-2}$

于是case3也搞定了

~~好像也不怎么复杂~~

最后是case4

稍微yy一下case4的推倒发现其实与case3是完全对称的，不明白这里的同学可以手动画一下，我这里就不画了...因此$case_4=case_3$

综合以上4种cases，我们就能算出$Ans(n,n)$了。因为这4种情况完全包含了所有的可能且互不重叠，所以$Ans(n,n)=case_1+case_2+case_3+case_4$。把$case$带进式子再使劲蹂躏一下得到最终答案：

$$\displaystyle Ans(n,n)=\frac{83\cdot8^n+5\cdot2^{n+7}}{384}$$

~~累死了~~

$Ans(3,m)$与$Ans(n,n+1)$的推倒与$Ans(n,n)$大同小异，这里就略去了，直接说结论吧

$$\displaystyle Ans(3,m)=112\cdot3^{m-3}$$

$$\displaystyle Ans(n,n+1)=\frac{83\cdot8^n+2^{n+8}}{128}$$

结合$Ans(n,m+1)=3 \times Ans(n,m)$以及$Ans(n,m)=Ans(m,n)$，我们就能轻易地推出所有的$Ans(n,m)$了。

完结撒花~

~~这是本菜鸡的第一篇题解，写得狗屁不通还请见谅~~

还是贴一下代码吧
```cpp
#include<cstdio>
#define mod 1000000007
typedef long long LL;
inline LL ksm(LL a,LL b){LL r=1;for(;b;a=a*a%mod,b>>=1)if(b&1)r=r*a%mod;return r;}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	if(n > m)n ^= m ^= n ^= m;
	if(n == 1)printf("%lld",ksm(2,m));
	else if(n == 2)printf("%lld",4*ksm(3,m-1)%mod);
	else if(n == 3)printf("%lld",112*ksm(3,m-3)%mod);
	else
	{
		if(m == n)printf("%lld",(83*ksm(8,n)%mod+5*ksm(2,n+7)%mod)*190104168%mod);
		else printf("%lld",(83*ksm(8,n)%mod+ksm(2,n+8))*ksm(3,m-n-1)%mod*570312504%mod);
	}
	return 0;
}
```
~~若还有新bug请私信联系QwQ~~

---

## 作者：lyyi2003 (赞：68)

这里提供一种非常快的暴力打表算法

**2s打出(8,9)**

怎么做到的呢？首先我的思路受了楼上某位大佬的启发，他的题解里说了如下两条规律：

一个棋盘是合法的，当且仅当
1. 对于每一条自左下到右上的对角线，填数是非严格单调递减的。
1. 如果(i-1,j)和(i,j-1)的填数相同，那么以(i,j)为左上角、以(n,m)为右下角的子矩阵内所有对角线内的填数各自相等。

（以上引自那位大佬的题解）

第一点是再显然不过了，但是第二点怎么证明呢？

![](https://cdn.luogu.com.cn/upload/pic/45826.png)

如图，对于从（1,1）出发的两条路线，第一条（粉色）第一步是向右，而第二条（黄色）第一步是向下，所以$w(P_1)>w(P_2)$，因此必须满足$s(P_1)≤s(P_2)$，但是因为（1,2）与（2,1）格子上的数字相同，而以（2，2）为左上角的矩阵中存在一条对角线中的数字不相同，那么同时走到（3,3）时的两条路线，第一条往下，得到数字1，而第二条往右，得到数字0，此时$s(P_1)$就会大于$s(P_2)$，不符题意，所以图中棕色框起的矩阵中的每一条对角线中的所有数字必须相同。

由此，可以得出一个O(2^(nm)×nm)的算法，即先暴搜出一种填法，然后设$a[i][j]$表示在第j列中，从第i行到第n行上的所有数字状压得到的结果（其中最高位表示第i行数字，最低位表示第n行数字），设$b[i][j]$表示当前棋盘以$(i,j)$为左上角的矩阵中是否每一条对角线上的数字都相同，于是有

$b[i][j]=b[i][j+1]$&&$(a[i][j+1]>>1)==a[i+1][j]$

然后再扫描一遍整个棋盘，检查上述第2点即可。

但是这样还是太慢了，于是我们可以在填数的时候就处理出a和b，然后每填一个数就判断一下与这个格子有关的b的值，如果不符合就直接返回，这样不仅省去了填完棋盘后的$O(nm)$的判断，还给搜索提供了很有效的减枝，于是就能在2s内跑出（8,9）的答案啦！这个暴力算法交到洛谷上，可以过35分的数据点（即$n≤8,m≤8$的数据点），可以说效率十分之高。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 13
#define M 13
int g[N][M],a[N][M],ans,n,m;
bool b[N][M];
bool check(int x,int y)
{
    a[x][y]=a[x+1][y]|(g[x][y]<<(n-x));
    if(y==m)
        b[x][y]=true;
    else
    	b[x][y]=b[x][y+1]&&(a[x][y+1]>>1)==a[x+1][y];
    if(x<n&&y>1&&g[x][y]==g[x+1][y-1]&&!b[x+1][y])return false;
    return true;
}
void dfs(int x,int y)
{
    if(y<1)return dfs(x-1,m);
    if(x<1)
    {
        ans++;
        return;
    }
    if(x==n||y==1||g[x+1][y-1]==1)
    {
        g[x][y]=1;
        if(check(x,y))dfs(x,y-1);
    }
    g[x][y]=0;
    if(check(x,y))dfs(x,y-1);
}
int main()
{
    scanf("%d%d",&n,&m);
    dfs(n,m);
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Froggy (赞：57)

本题解讲一下考场上遇见这种~~SB~~题怎么做@_@

输入只有两个数?根据平常做题经验,应该是DP嘛!

再一看$n\le8$,肯定是状压DP!

## BUT,

你就要从这到题吸取教训了...

原来是道找规律打表题 (不排除某些神犇考场上就把式子推出来了,不过相信大部分人都是通过打表弄出来的)

所以..

我的建议是:见到这种题先打暴力再说(除非你已经想到了正解)

---

现在重点讲怎么打优秀的暴力:

#### 方法一:

暴力枚举所有情况+所有路径判断

时间:$O(2^{mn}*C_{m+n}^{n})$

~~这种做法相信谁都会写~~

#### 方法二:

发现每条路径经过的数依次排列可以化为一个二进制数,比较两个路径的$s$的字典序就相当于比较两个二进制数的大小(用十进制存就好啦!)

记忆化一下,$dp_{x,y}$存一个二元组,记录从$(x,y)$出发构成的二进制数(最小值,最大值)

如果从一个点向右走的最小值小于向下走的最大值,那么就不行了

时间:$O(2^{mn}*mn)$

#### 方法三:

在方法二的基础上,每枚举完一行就判断一次,步星的话就不用往下枚举了.

时间:$O(ans*mn^{2})$

(实际应该达不到这个上界)

这种方法已经可以满足我们的需要了,$n=8,m=8$的数据在本机不到$6min$就跑出来了

代码如下:

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
inline int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<3)+(x<<1)+c-'0';
        c=getchar();
    }
    return x*f;
}
pair<int,int> dp[10][10]; //(最小值,最大值) 
int n,m,ans;
int mp[10][10];
pair<int,int> check(int x,int y,int mx,int my){//mx,my为搜索的边界
	if(dp[x][y].first!=0)return dp[x][y];
	if(x==mx&&y==my){//如果到了右下角就直接return
		return dp[x][y]=make_pair(mp[x][y],mp[x][y]);
	}
	if(x==mx){//在下边界上只能往右走
		pair<int,int> tmp=check(x,y+1,mx,my);
		return dp[x][y]=make_pair(tmp.first+(mp[x][y]<<(mx+my-x-y)),tmp.second+(mp[x][y]<<(mx+my-x-y)));
	}
	if(y==my){//在右边界上只能往下走
		pair<int,int> tmp=check(x+1,y,mx,my);
		return dp[x][y]=make_pair(tmp.first+(mp[x][y]<<(mx+my-x-y)),tmp.second+(mp[x][y]<<(mx+my-x-y)));
	}
	pair<int,int> p=check(x,y+1,mx,my);//往右走
	if(p.first==-1){//剪枝,往右走不行了就不用往下走了
		return dp[x][y]=make_pair(-1,-1);//-1表示不行了QAQ
	}
	pair<int,int> q=check(x+1,y,mx,my);
	if(q.first==-1||p.first<q.second){//向右走的最小值小于向下走的最大值,就不行了
		return dp[x][y]=make_pair(-1,-1);
	}
	return dp[x][y]=make_pair(q.first+(mp[x][y]<<(mx+my-x-y)),p.second+(mp[x][y]<<(mx+my-x-y)));
}
void dfs(int x,int y){
	if(y==1&&x>1){
		memset(dp,0,sizeof(dp));
		if(check(1,1,x-1,m).first==-1)return;//每换一行,就check一次
		if(x==n+1){	
			ans++;
			return;
		}
	}
	if(y==m){
		mp[x][y]=1;
		dfs(x+1,1);
		mp[x][y]=0;
		dfs(x+1,1);
	}
	else{
		mp[x][y]=1;
		dfs(x,y+1);
		mp[x][y]=0;
		dfs(x,y+1);
	}
}
int main(){
	n=read(),m=read();
	if(n<m)swap(n,m);
	dfs(1,1);
	cout<<ans<<endl;
	return 0;
}
```


然后你就可以打个表啦!

| n,m | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
| ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- |
| 1 | 2 | 4 | 8 | 16 | 32 | 64 | 128 | 256 |
| 2 | 4  | 12 | 36 | 108 | 324 | 972 | 2916 | 8748 |
| 3 | 8 | 36 | 112 | 336 | 1008 | 3024 | 9072 | 27216 |
| 4 | 16 | 108 | 336 | 912 | 2688 | 8064 | 24192 | 72576 |
| 5 | 32 | 324 | 1008 | 2688 | 7136 | 21312 | 63936 | 191808 |
| 6 | 64 | 972 | 3024 | 8064 | 21312 | 56768 | 170112 | 510336 |
| 7 | 128 | 2916 | 9072 | 24192 | 63936 | 170112 | 453504 | 1360128 |
| 8 | 256 | 8748 | 27216 | 72576 | 191808 | 510336 | 1360128 | 3626752 |

~~打得手疼~~

观察一下,不难发现,当$m>n+1$且$n>1$时, $ans_{n,m}=ans_{n,m-1}*3$

当$n=1$时,$ans_{n,m}=2^m$

然后就解决了!(打个表+快速幂)

等!, $ans_{8,9}$还要跑么?

没问题,但要有耐心,不过还可以算一下会发现,当$m>3$时,$ans_{n,n+1}=ans_{n,n}*3-3*2^n$

好吧,这下不用挂机了,上代码:

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
typedef long long ll;
const ll mod=1e9+7;
inline int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<3)+(x<<1)+c-'0';
        c=getchar();
    }
    return x*f;
}
int n,m;
int a[10][10]={
	{0,0,0,0,0,0,0},
	{0,2,4},
	{0,0,12,36},
	{0,0,0,112,336},
	{0,0,0,0,912,2688},
	{0,0,0,0,0,7136,21312},
	{0,0,0,0,0,0,56768,170112},
	{0,0,0,0,0,0,0,453504,1360128},
	{0,0,0,0,0,0,0,0,3626752,10879488}
};
ll qpow(ll a,ll b){
	ll ans=1;
	while(b){
		if(b&1)ans=ans*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ans;
}
int main(){
	n=read(),m=read();
	if(n>m)swap(n,m);
	if(n==1){
		printf("%lld\n",qpow(2,m));
	}
	else{
		if(n==m||n+1==m){
			printf("%d\n",a[n][m]);
		}
		else{
			printf("%lld\n",a[n][n+1]*qpow(3,m-n-1)%mod);
		}
	}
	return 0;
}

```

这道题长的像dp,但不是dp,~~毒瘤CCF出的毒瘤题目~~

[*Froggy's blog,呱!*](https://www.luogu.org/blog/1445353309froggy/)

欢迎来踩!



---

## 作者：ljc1301 (赞：55)

这题状压dp？感觉不对，因为我（独立地）推出式子了！（时间复杂度只跟快速幂有关，n、m再大也没关系。也算是比较严格地证明了，而不是打表找规律。~~我考场上暴力挂了……~~）~~草稿纸用了三面半，用了好几个小时~~

### 如果有任何问题，或证明中的bug，欢迎在评论里指出（最好可以私信我）

其实这题可以~~疯累~~分类讨论

为了方便，我把题目中格子看成点，格子间的交点看成格子。比如题目中第一个图的右半图可以写成：

```plain
0-1
| |
0-1
```

先来看一些引理（S代表左上角的点，T代表右下角的点。）

### 引理1：一个方格对角线上，右上方格子的数小于等于左下方的数

#### 证明：

```plain
S
⋮
P⋯C-A
  | |
  B-D⋯Q
      ⋮
      T
```

对于这个图来说，w(S->P->CAD->Q->T)>w(S->P->CBD->Q->T)，除了A、B都相等，所以A<=B。为了方便，**下边说的对角线都是从左下到右上的。**

有了这个引理，我们可以用另一种方法来表示一个合法的方案，就是在每一个方格里填入小于或等于，表示右上方格子的数和左下方的数的关系。为了方便，这里用/表示等于，\*表示小于（我也不知道我为什么要这样表示）。

### 引理2：若一个方格填/，则它的右下方的所有格子（除了正右和正下方）都应该填/

#### 证明：

设命题P(x, y)，表示任意一个填/的格子(a, b)，对于0<i<=x, 0<j<=y，有(a+i, b+j)填/。引理2就是P(n, m)

先证明P(1, 1)

```plain
S
⋮
P⋯A-B
  |/|
  C-D-E
    | |
    F-G⋯Q
        ⋮
        T
```

因为w(S->P->ABDFG->Q->T)>w(S->P->ACDEG->Q->T)>w(S->P->ACDFG->Q->T)，B和C相等，所以有E<=F<=E，即E=F。

再证明P(1, n)和P(m, 1)。先证P(1, n)。

```plain
S
⋮
P⋯A-B
  |/|
  C-D-E
    | ⋮
    F G
    ⋮ |
    H-I⋯Q
        ⋮
        T
```

用数学归纳法，假设P(m-1, 1)是正确的。w(S->P->ABDF->HI->Q->T)>w(S->P->ACDE->GI->Q->T)>w(S->P->ACDF->HI->Q->T) ，B=C，又因为P(m-1, 1)是正确，所以s(E->G)=s(F->H)，所以有G<=H<=G，就有H=G。

类似地，可以证明P(m, 1) 。

最后证明P(n, m)。

```plain
S
⋮
P⋯A-B
  |/|
  C-D⋯F⋯G
    ⋮   ⋮
    H   I
    ⋮   |
    J⋯K-L⋯Q
          ⋮
          T
```

还是用数学归纳法。假设P(n-1, m)和P(n, m-1)都是正确的，那么也就是说s(D->F->G->I)和s(D->H->J->K)只有I和K的区别。而因为w(S->P->ABD->H->J->KL->Q->T)>w(S->P->ACD->F->G->IL->Q->T)>w(S->P->ACD->H->J->KL->Q->T)，所以I<=K<=I，即I=K。证明完毕。

可以用反证法再得到一个推论。

### 推论1：若一个方格填\*，则它的左上方的所有格子（除了正左和正上方）都应该填\*

不过，还有一个比较重要的性质没讲。

### 性质1：一个满足题意的01矩阵，当且仅当满足引理1（即能化成用\*和/表示的矩阵），且化成用\*和/表示的矩阵后能满足引理2

#### 证明：

首先，一个满足题意的01矩阵显然满足引理1和引理2（已经证明过了）。而满足引理1和引理2的化成用\*和/表示的矩阵，是不是一定可以对应（不一定要一一对应）所有的满足题意的01矩阵呢？

先看下面这个图：

```plain
S
 ⋱
  A-B
  | |
  C-D
     ⋱
      T
```

对于这两条不同的路径，假设都沿相同的路径到A，然后不管它怎么到T。这时，w(S->ABD->T)>w(S->ACD->T)。因为它们都沿相同的路径到A，所以到A前它们的s相同。根据引理1，B<=C，所以要么B<C，s(S->ABD->T)<s(S->ACD->T)，要么B=C，此时根据引理2，它们D->T的路径的s一定相同，因为以D为右上角的子矩阵中，都有每个格子对角线相等（根据引理2），再加上些思考就可以得出这个子矩阵的对角线上填的数相等，在加上些思考，就可以得到这个结论。所以s(S->ABD->T)=s(S->ACD->T)。综上所述，s(S->ABD->T)<=s(S->ACD->T)。

再看不满足这个图的两个路径，假设w(P1)>w(P2)，则每次把P1根据前面这个规则变换（把RD变为DR），根据不等号的传递性，只要能把P1变为P2就满足条件。而这个变换很好实现，可以从P1和P2的交点出发，把w(P1)的RR...RRD改成RR...RDR然后一直改改到DRR...RR。就可以把交点下移一个。可以一直这么改，直到RDR...R改成DRR...R后，若P2是DR开头，即改后不止多一个交点，这时要注意，要把P1剩下的后边全改成P2的剩下的。（似乎讲的太抽象了……但其实这个还算是显然的。）然后根据不等式的传递性，w(P1)<=w(P2)就证出来了。

**下文中的n和m代表这个方格的行和列，即n和m在下文中代表输入的n和m分别减1的结果。**

注意到我前面没说一一对应，一个这样的填法中，对答案的贡献是2^(没有\*的对角线的个数)，因为一个对角线有了\*，其实就可以确定这条对角线，\*左下方都填1，右上方都填0；而都是/的对角线上可以都填0或都填1，有两种。一共有n+m-1个对角线。**因为原图中左上和右下的方格这里没考虑到，而且显然每个路径都有经过，不管填什么都行，所以最终答案应该再乘4。**有了这样的性质，就可以只看这样填后的图了。

**为了方便，接下来的讲述没有轮廓线，只有/和\*，然后不确定的用.表示**

好了，接下来看一下这个图还有什么有趣的性质。

### 性质2：\*只出现在前两行或前两列

~~出乎意料吧~~

#### 证明：

若出现在了前两行或前两列以外的地方，则这个左上方至少会有2\*2的方格要填。

```
...
...
..*
```

根据推论1，有

```
**.
**.
..*
```

然后发现这个图在

```
.*.
*..
...
```

这条对角线上有两个\*，而\*表示小于，但只有0或1两个数可以填，出现了矛盾。所以\*只出现在前两行或前两列。

有了这个性质，就更方便~~疯累~~分类讨论了。

**下面所说的贡献在同一段里是加起来算的，所有的贡献是乘起来算的（具体要算什么和为什么要这样建议再看一下性质1的最后）。下面所说的是n行m列，同时需要保证n<=m（若n>m则交换n和m）。**同时在说一下，下文中的n和m代表这个方格的行和列，即n和m在下文中代表输入的n和m分别减1的结果。

### A：\*只出现在第一行和第一列

```
........
.///////
.///////
.///////
```

看第一行的第一个，可以是/或\*，/的贡献是2，\*的贡献是1，加起来的贡献是3

看第一行的第2到n个，每一个所代表的对角线上，有两个地方可以填\*，贡献为2\*1；也可以不填，贡献为2。加起来的贡献是4，因为有n-1个，所以是4^(n-1)

再看第一行的第n+1到m个 ，每一个所代表的对角线上，有一个地方可以填\*，贡献是1；也可以不填，贡献为2。加起来的贡献是3，因为有m-n个（前n个已经被讨论过了），所以是3^(m-n)

最后来看最后一列的第2到n个，贡献都是2，因为有n-1个，所以贡献是n-1个

所以这一类对答案的贡献是$3\times4^{n-1}\times3^{n-m}\times2^{n-1}$（可以化简一下）

请尽量理解，因为下面的分析更复杂。~~而且到后面我会比较偷懒~~

### B：第二行第二列是\*，同时第二行和第二列没有其他\*（除了第一行第二列和第二行第一列） (n>=2)

```plain
*./....
.*/////
///////
.//////
.//////
```

可能需要解释一下。因为第二行第二列是\*，根据推论1，第一行第一列也是\*，同时因为一个对角线上最多只有一个\*（不理解的看性质2最后一个图的下面一段），所以第一行第三列和第三行第一列是/。

~~接下来说一下我怎么偷懒……~~我把每一条对角线的贡献都标注在第一行和最后一列的右上角（所以先确保分类A彻底理解了）。

这里需要对n和m的大小进行讨论。

#### 1. m=2

```plain
 14
*.1
.*
```

解释一下这个4，有两种方法填\*，贡献是2\*1；还可以不填，贡献是2。加起来是4。

所以总的贡献是4

#### 2. n=2 m>2

```plain
 141333
*./...2
.*////
```

我们是限定了第二行和第二列没有其他\*（除了第一行第二列和第二行第一列），所以第二行第三列是/

4的解释同上。3的话是有一种方法填\*，贡献是1；还可以不填，贡献是2。加起来是3。

注意到有m-3个3。所以总的贡献是$8\times3^{m-3}$

#### 3. n>2

```plain
 141443333
*./......2
.*///////2
/////////2
.////////2
.////////
```

最左边的4和右边的3的解释见上。中间那些4其实也差不多，有两种方法填\*，有一种方法可以填/。

有m-n个3，n-1个2，n-2个4（前n个当中有2个1，其它都是4）。所以总的贡献是$3^{n-m}\times2^{n-1}\times4^{n-2}$

然后这种情况讨论完了。

### C：除了第两行的前两列，以及第两列的前两行外，还有在其他第二行或第二列的地方有\*(m>2, n>=2)

还可以用一下推论1。其实它一定会出现：

```plain
*****.
.....*
```

然后就不可能出现第二列和第二行（除了第两行的前两列，以及第两列的前两行外）都有\*的情况，因为会这样：

```plain
***.
*..*
*...
.*..
```

第一行第二列和第二行第一列这个对角线上出现了两个\*，就不可以。

我们记第二行**最后一个**\*为第i列，或记第二列最后一个\*为第i行。（i>2）

然后开始讨论n和m的情况。（然后刚开始我的讨论没有充分，这时候其实可以信仰提交然后看哪错了再修改……不过为了思考少一些，我就先讨论n和m-n足够大的情况，然后看每个区间是不是有问题）

#### 1. 3<=i<n

```plain
 111514433
***./....2
//.*/////2
/////////2
.////////2
/////////2
.////////2
.////////
```

因为第一行第二列是\*，所以第二行第一列是/。因为第二行第四列是\*，所以第一行第五列和第五行第一列是/。根据i的定义，第一行第五列的是/。

5的话是因为有三个地方可以填\*，贡献是3\*1；可以不填，贡献是2，总的贡献是5。剩下的解释见上。

有1个5，n-i-1个4（因为第i+1行第一列和第二行第i列是在同一条对角线上的，下面有n-i-1个.，所以有n-i-1个4），m-n个3，n-1个2，总的贡献是$5\times4^{n-i-1}\times2^{n-1}\times3^{n-m}$，这个需要等比数列求和。当n=3时没什么问题，这个和会变成0，但当n=2时就不要计算这个贡献。

还可以顺便讨论\*出现在第二列，那将会是这样：

```plain
 111514433
*//./....2
*////////2
*.///////2
.*///////2
/////////2
.////////2
.////////
```

其实和上边那个图的贡献是一样的，只要把这个贡献乘以2即可。

#### 当m=n时，i=n

```plain
 1115   1115
***.1  *//.1
//.*2  *///2
////2  *.//2
.///   .*//
```

5的解释同上。

有一个5，n-2个2。这两个图的贡献相同。总的贡献是$5\times2^{n-2}\times2$

#### 当m>n时，i=n
```plain
 111513   111513
***./.2  *//./.2
//.*//2  */////2
//////2  *.////2
./////   .*////
```

有一个5，m-n-1个3（前n-1个是1，第n个是5，第n+1个是1，后面m-n-1个全是3），n-1个2。这两个图的贡献相同。总的贡献是$5\times3^{m-n-1}\times2^{n-1}\times2$
#### 当m>n时，n<i<m
```plain
 11114133
****./..2
///.*///2
////////
```
4是因为有两个地方可以填\*，贡献是2\*1，可以不填，贡献是2。加起来是4。

有一个4，m-i-1个3，n-1个2。答案的贡献是$4\times3^{m-i-1}\times2^{n-1}$。需要等比数列求和。（当n+1=m时直接求和的结果会是0，对答案没有影响）
#### 当m>n时，i=m
```plain
 11114
****.1
///.*2
/////
```
有1个4，n-2个2，对答案的贡献是$4\times2^{n-2}$

好了，可以写代码了（别忘了最后的乘4）。~~感觉我自己都不知道我在说什么了，我还是某一天再改一下这题解吧……~~代码（我这等比数列求和写得……别喷我）：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int kcz=1000000007;
const int inv4=250000002;
const int inv3=333333336;
typedef long long ll;
inline ll qpow(ll a,ll k)
{
    k%=kcz-1;
    if(k<0) k+=kcz-1;
    ll res=1;
    while(k)
    {
        if(k&1) res=res*a%kcz;
        if(k>>=1) a=a*a%kcz;
    }
    return res;
}
ll ans,n,m;
// 1+x+...+x^n x!=1
inline ll sum(ll x,ll n) { return (1-qpow(x,n+1))*qpow(1-x,-1)%kcz; }
int main()
{
    scanf("%lld%lld",&n,&m);
    if(n>m) swap(n,m); n--; m--;
    if(!n) ans=qpow(2,m-1);
    else
    {
        ans=qpow(3,m-n+1)*qpow(8,n-1)%kcz;
        if(n>=2)
        {
            if(m==2) (ans+=4)%=kcz;
            else if(n==2) (ans+=8*qpow(3,m-3))%=kcz;
            else (ans+=qpow(2,3*n-5)*qpow(3,m-n))%=kcz;
        }
        if(m>2 && n>=2)
        {
            if(4<=n) (ans+=10*qpow(4,n-1)%kcz*(sum(inv4,n-1)-sum(inv4,2))%kcz*qpow(2,n-1)%kcz*qpow(3,m-n))%=kcz;
            if(n==m) (ans+=5*qpow(2,n-1))%=kcz;
            else
            {
                if(n!=2) (ans+=5*qpow(3,m-n-1)%kcz*qpow(2,n))%=kcz;
                (ans+=qpow(2,n))%=kcz;
                (ans+=qpow(2,n+1)*qpow(3,m-1)%kcz*(sum(inv3,m-1)-sum(inv3,n)))%=kcz;
            }
        }
    }
    printf("%lld\n",(ans*4%kcz+kcz)%kcz);
    return 0;
}
```
### 后话
感谢您看完了我这么长的题解（是我旷野大计算的题解字节数的4/5左右），我只想说，这是一个好题，值得研究，不要局限于打表找规律，要深入研究它背后的数学原理。这也是我认为它作为noip题不好的一点（也可能是因为我暴力打挂了才这么想），数据范围又给这么小，让人养成只想着用一种不通用的方法做对，以为自己懂了，却不深入研究的坏习惯。

---

## 作者：Hope2075 (赞：20)

给出一种~~暴力~~递推做法

本质上应该是状压

一共需要14个数列用于递推

首先证明几个结论：

1.交换n和m，答案不变

感性理解就是：可以把一个合法方案翻转，则任意一对路径字典序大小关系反转，产生的01串大小关系也反转

下面是~~严谨~~的证明

对于任意一种方案（合法的或不合法的），构造一个方案，如果$(x,y)=0$，则新方案中$(y,x)=1$，如果$(x,y)=1$，则新方案中$(y,x)=0$

![](https://cdn.luogu.com.cn/upload/pic/57572.png)

直观看就是将原方案对称一下，再把每个点状态反转

原方案与新方案一一对应

这样，对于任何一条路径$(x_1,y_1),(x_2,y_2),...,(x_{n+m-1},y_{n+m-1})$，设其对应字符串为$a_1,a_2,a_3,...a_{n+m-1}$，产生的01串为$b_1,b_2,b_3,...b_{n+m-1}$

则翻转后，令这条路径对应$(y_1,x_1),(y_2,x_2),...,(y_{n+m-1},x_{n+m-1})$，对应字符串变为$\overline{a_1},\overline{a_2},\overline{a_3} ...\overline{a_{n+m-1}}$，产生的01串变为$\overline{b_1},\overline{b_2},\overline{b_3},...\overline{b_{n+m-1}}$

这条路径中，原来向下走的变为向右走，向右走变为向下走，

而01串中，新位置恰好和原位置的字符相反

所以翻转后，这两个串每一位都被反转了

对于一个合法方案：

>如果$w(P_1) > w(P_2)$，那么$s(P_1) ≤ s(P_2)$

先考虑翻转前后的大小关系

在比较时，首先跳过开头相同部分

如果最后没有剩下任何东西，则说明相等

这种情况下，反转后的两个串依然满足每一位相等

否则，找到第一个不相同位

翻转后，前面部分依然相同

而原来这一位是0的串，翻转后这一位变为1

原来这一位是1的串，翻转后这一位变为0

这样，大小关系就反过来了

接下来考虑任意两条满足$w(P_1) > w(P_2)$的路径$P_1,P_2$

翻转后，路径满足$\overline{w(P_2)} > \overline{w(P_1)}$

如果$s(P_1) = s(P_2)$，那么翻转后有$\overline{s(P_1)} = \overline{s(P_2)}$

如果$s(P_1) < s(P_2)$，那么翻转后有$\overline{s(P_2)} < \overline{s(P_1)}$

如果$s(P_1) > s(P_2)$，那么翻转后有$\overline{s(P_2)} > \overline{s(P_1)}$

结论：翻转前一个方案中，合法的一对路径，与翻转后合法的一对路径一一对应

合法方案中任意一对路径，翻转后依然是合法的，因而可以对应一个合法方案

这样，原合法方案与新合法方案也一一对应，也就是：数量相等

2.每条对角线方向上的数，必须满足右上方的比左下方的小或相等

![](https://cdn.luogu.com.cn/upload/pic/57575.png)

这样，如果走红色线，则路径的字典序就会有一个"D"，如果走青色先，则这一位就是"R"，很显然，走红色线字典序小

而01串中，红色线这一位是"0"，青色线对应位是"1"，走红色线字典序小，因而非法

这样可以看出，每条对角线方向上的数，应该类似于"00...0111...1"

3.对于每一对角线方向上相邻且相同的数，会导致这两个数右下方一片矩形区域必须满足每条对角线方向上的数均相同

![](https://cdn.luogu.com.cn/upload/pic/57573.png)

这样可以找到两条路径，直到第二次分叉前，01串字典序依然相等

这时候可以看出，走红色线字典序较小

但是再走一步，就会发现：如果红色点填"0"，蓝色点填"1"，虽然满足第二条结论，但会导致走红色线产生的01串比蓝色线的01串小，这个方案就是非法的

接下来就可以想办法递推了

首先把棋盘形状变一下：

![](https://cdn.luogu.com.cn/upload/pic/57570.png)

这样，对角线就变成了水平线，便于讨论

根据第二条结论，结果就是一行需要满足一定次序

根据第三条结论，观察一下受到限制区域的形状：

![](https://cdn.luogu.com.cn/upload/pic/57576.png)

在新的图中，一行两个相同的数，产生的受限制区域大概就是这样的

![](https://cdn.luogu.com.cn/upload/pic/57577.png)

左边这个图中，被同一条黑线穿过的，必须填相同的数

而观察右边的图，两块受限制区域相邻时，在下一行合并为一个更大的受限制区域

接下来发现每填一层，下一层发生变化的情况一共三类：在末端增加一个点，不变，删除开头的一个点

考虑分三类情况转移

先压缩状态：对于一段受限制区间，到下一行也会产生一段受限制区间，并且这一段区间必须填相同的数

把这一段压缩成一个点，这个点可以仅表示一个受限制的点（注意：到下一行就会导致两个点受限制），也可以表示很多个受限制的点

这里状态表示：填完上一行，这一行的限制的形状为某一个的情况总数

把所有情况的转移大力讨论出来就可以

我讨论的结果：

```
o
oo
ooo
oxo
oxoo
oxxo
ooxo
ox
oxx
oox
n
x
xx
xo
```
x表示一段受限制的区间

o表示一个不受限制的点

另外，n表示没有任何点，也就是当最后一行不受限制时，填完所有格子的情况

而x也可以表示最后一行受限制时（当然并没有什么用），填完所有格子的情况

然后考虑转移

这里就不把所有情况列出来了，递推公式可以直接看代码

一个例子：当增加一个点时，状态ooxo

情况1：开头的两个o填不同的数

可以看出，只有一种情况

这时候，x把末尾的o吞并了，但又冒出一个o

而其它位置填相同的数并不会产生有效的限制区间

因而可以产生状态ooxo，也就是它自身

情况2：开头两个o填相同的数

一共4种情况

这时候，在下一行会产生一个新的限制区间，也就是oxxo

转移时，把对应状态加上上一行某些状态的情况数就可以

剩下的情况请读者自行讨论

这样就可以得出一个14元线性递推数列

最后可以得出三种递推规则

根据n和m确定每个规则的使用次数就可以

时间复杂度$O(n+m)$，空间可以优化到$O(1)$

如果使用矩阵快速幂~~优化~~，则时间复杂度变为$O(\log n+\log m)$，但是会有一个超大的常数（~~常数再大也是常数~~）

讨论的时候务必细心，只要错一点，就会WA

最后是代码
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const long long M=1000000007;
int n,m;
long long fpow(long long a,int n){
    if(n==0)return 1;
    long long ans=fpow(a,n>>1);
    ans=ans*ans%M;
    if(n&1)ans=ans*a%M;
    return ans;
}
long long seed;
namespace mogician{
	int nc,mc;
	long long a[2],b[2],c[2],d[2],e[2],f[2],g[2],h[2],k[2],l[2],m[2],n[2],p[2],q[2];
	long long* arr[]={a,b,c,d,e,f,g,h,k,l,m,n,p,q,0};
	void mod(){
		for(int k=0;k<14;k++){
			arr[k][1]%=M;
		}
	}
	void sw(){
		for(int k=0;k<14;k++){
			swap(arr[k][0],arr[k][1]);
		}
	}
	void put(){
		for(int k=0;k<14;k++){
			cout<<arr[k][0]<<" ";
		}
		cout<<endl;
	}
	void cal1(){
		a[1]=0;
		b[1]=2*a[0];
		c[1]=b[0];
		d[1]=2*b[0]+4*d[0]+5*f[0];
		e[1]=c[0]+e[0];
		f[1]=2*c[0]+4*e[0]+4*g[0];
		g[1]=c[0]+g[0];
		h[1]=0;
		k[1]=0;
		l[1]=0;
		m[1]=0;
		n[1]=0;
		p[1]=0;
		q[1]=0;
		mod();
		put();
		sw();
	}
	void cal2(){
		a[1]=2*a[0];
		b[1]=3*b[0];
		c[1]=c[0];
		d[1]=3*c[0]+5*e[0];
		e[1]=0;
		f[1]=0;
		g[1]=0;
		h[1]=4*d[0]+5*f[0]+3*h[0]+4*k[0];
		k[1]=4*g[0]+3*l[0];
		l[1]=g[0]+l[0];
		m[1]=0;
		n[1]=0;
		p[1]=0;
		q[1]=0;
		mod();
		put();
		sw();
	}
	void cal3(){
		a[1]=b[0];
		b[1]=0;
		c[1]=0;
		d[1]=0;
		e[1]=0;
		f[1]=0;
		g[1]=0;
		h[1]=c[0]+g[0]+l[0];
		k[1]=0;
		l[1]=0;
		m[1]=2*a[0];
		n[1]=2*b[0]+4*d[0]+5*f[0]+3*h[0]+4*k[0]+2*n[0]+3*p[0]+3*q[0];
		p[1]=2*c[0]+4*e[0]+4*g[0]+3*l[0];
		q[1]=c[0]+e[0];
		mod();
		put();
		sw();
	}
	long long calc(){
		a[0]=1;
		
		for(int i=2;i<=nc;i++)cal1();
		for(int i=nc+1;i<=mc;i++)cal2();
		for(int i=mc+1;i<=nc+mc;i++)cal3();
		put();
		long long ans=0;
		for(int k=0;k<14;k++){
			ans+=arr[k][0];
		}
		ans%=M;
		return ans;
	}
};
int main(){
    ios::sync_with_stdio(false);
    cin>>n>>m;
    if(n>m)swap(n,m);
    mogician::nc=n;
    mogician::mc=m;
    cout<<mogician::calc();
    return 0;
}
```

---

## 作者：ouuan (赞：16)

> 注：本文中以有序数对 $(x,y)$ 指代 $n=x,m=y$ 时的答案。

我在考场上没有推出 $(n,n)=(n-1,n-1)\times8-5\times2^n$，然而由于我写的暴力比较快？我在考场上把 $(8,8)$ 以内的答案全算出来了。

## 暴力

首先是两个结论：

### $1.$ 每一斜行左下是连着的 $1$，右上是连着的 $0$ ，或全 $1$ 、全 $0$

若不是的话就会存在一个格子右边是 $1$ 下面是 $0$ ，不符合要求。

### $2.$ 满足条件的等价条件是：每个格子右边的格子先往下再往右的路径小于等于下面的格子先往右再往下的路径。

![](https://i.loli.net/2018/11/16/5beea329f0125.png)

如上图，黄色路径 $\le$ 蓝色路径

因为蓝色路径是往下走后最小的路径，黄色路径是往右走后最大的路径。

然后就可以写出暴力了：

```cpp
#include <iostream>
#include <cstdio>

using namespace std;

const int N=100;

bool check(int x,int y);
void dfs(int sum);

int n,m,a[N][N],ans;

int main()
{
	cin>>n>>m;
	
	dfs(2);
	
	cout<<ans;
	
	return 0;
}

void dfs(int sum)
{
	int i,j;
	if (sum>n+m)
	{
		for (i=1;i<n;++i)
		{
			for (j=1;j<m;++j)
			{
				if (!check(i,j))
				{
					return;
				}
			}
		}
		++ans;
		return;
	}
	dfs(sum+1);
	for (i=n;i>=1;--i) //将左下填成1
	{
		if (sum-i>=1&&sum-i<=m)
		{
			a[i][sum-i]=1;
			dfs(sum+1);
		}
	}
	for (i=n;i>=1;--i) //回溯时复原
	{
		if (sum-i>=1&&sum-i<=m)
		{
			a[i][sum-i]=0;
		}
	}
}

bool check(int x,int y)
{
	int rx=x,ry=y+1,dx=x+1,dy=y;
	while (rx+ry<=n+m)
	{
		if (a[rx][ry]!=a[dx][dy])
		{
			return a[rx][ry]<a[dx][dy];
		}
		if (rx<n)
		{
			++rx;
		}
		else
		{
			++ry;
		}
		if (dy<m)
		{
			++dy;
		}
		else
		{
			++dx;
		}
	}
	return true;
}
```

## 规律

虽然 $n,m$ 较大时这个暴力还是要跑很久，但我们可以先跑出 $(3,10)$ 之内的所有解，可以很快跑出来，并发现 $(1,m)=2^m$（因为任意填都合法），$(n,m)=(n,m-1)\times3\quad(n\ge2,m>n+1)$，而且$(n,m)=(m,n)$ 。

只计算 $(n,n)$ 和 $(n,n+1)$，可以在 $10min$ ~ $30min$ 左右跑出 $(8,8)$ 内的所有解。如果一进考场就开始跑这题的暴力而且机子不是太慢应该可以跑出 $(8,9)$ ，然而我考场上没有跑出来...事实上不算出 $(8,9)$ 在洛谷的数据已经可以得到 $90$ 分了。

再仔细看一眼打出来的表，发现 $(n,n+1)=(n,n)\times3-3\times2^n\quad(n\ge4)$，然后就可以算出 $(8,9)$ 了。

## 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

const long long Ans[9][2]={{0,0},{0,0},{12,36},{112,336},{912,2688},{7136,21312},{56768,170112},{453504,1360128},{3626752,10879488}}; //(n,n)和(n,n+1)
                       
const long long M=1000000007;

long long n,m,ans=1;

int main()
{
    int i;
    
    cin>>n>>m;
    
    if (n>m)
    {
        swap(n,m);
    }
    
    if (n==1)
    {
        for (i=30;i>=0;--i)
        {
            ans=ans*ans%M;
            if (m&(1<<i))
            {
                ans=ans*2%M;
            }
        }
        cout<<ans;
    }
    
    else
    {
        if (m==n)
        {
            cout<<Ans[n][0];
            return 0;
        }
        else if (m==n+1)
        {
            cout<<Ans[n][1];
        }
        else
        {
            for (i=30;i>=0;--i)
            {
                ans=ans*ans%M;
                if ((m-n-1)&(1<<i))
                {
                    ans=ans*3%M;
                }
            }
            cout<<ans*Ans[n][1]%M;
        }
    }
    
    return 0;
}
```

---

## 作者：Ebola (赞：15)

# 【NOIP2018】填数游戏

来一发状压题解。感谢xyz3278的好思路，xyz32768的博客链接：https://blog.csdn.net/xyz32768/article/details/84111253

他的博文里面有图，可以结合起来看一下，此外我讲的可能稍微详细一些吧

先摆两个结论，原因自行思考

1. $V_{i+1,j}\geq V_{i,j+1}$
2. 若 $V_{i+1,j}=V_{i,j+1}$，则矩形区域$(i+1,j+1)$到$(n,m)$的每条左下-右上对角线中的数字都要相等

那么我们可以设$f_{i,k,s}$表示从右下往左上数的第$i$条对角线，放了$k$个$1$，相等状态为$s$时的方案数。显然这$k$个$1$必然是放在从左下开始的连续$k$个位置，因此$j$可以唯一确定这条对角线的状态。相等状态是指：若以对角线的第$t$个位置为左上角、以$(n,m)$为右下角的矩形，满足左下-右上对角线中数字相等，则$s$的二进制第$t$位为$1$

于是我们可以枚举$i,k,s$，然后考虑将$f_{i,k,s}$往下一条对角线转移。那么我们枚举下一条对角线的状态$x$（即它包含$x$个$1$），然后我们检查枚举到的这个状态是否合法。如果合法，那么对于下一条对角线的第$p$个位置（从左下到右上编号），除非$p$位置为$1$且$p+1$位置为$0$（即$p=x$），否则以$p$位置右边那个格子为左上角、以$(n,m)$为右下角的矩形，必然要满足左下-右上对角线中数字相等，利用对角线$i$的$s$状态判定即可。
检查了合法性，还要知道我们从$f_{i,k,s}$转移到哪里去。$x$已经确定了，所以我们要得到下一条对角线的相等状态，利用$s$状态稍作推导即可，具体见代码

这样得到的复杂度是$O(m2^nn^3)$，把无效状态break掉，拿80分应该没有问题

但是我们可以找规律啊。打表，发现，当$n\geq 2$且$m>n+1$时，有$ans_{n,m}=3\times ans_{n,m-1}$。所以我们只要求得$ans_{n,n+1}$，然后等比数列求一下就行了，复杂度$O(n^42^n)$

注意我们规律的前提条件是$n\geq 2$，因此要注意特判$n=1$的点。$n=1$时答案显然为$2^m$

```cpp
#include<bits/stdc++.h>
using namespace std;
 
const int ha=1e9+7;
int f[2][10][260],n,m,nm;
int len[1000020],tot;
 
void add(int &x,const int &y){x=x+y>=ha?x+y-ha:x+y;}
int dwn(int t,int x){return t>tot-n+1?x:x-1;}
int rght(int t,int x){return t>tot-n+1?x+1:x;}
bool in(int x,int s){return s&(1<<x-1);}
 
int Pow(int a,int b)
{
    int ans=1;
    for(;b;b>>=1,a=1ll*a*a%ha)
        if(b&1) ans=1ll*ans*a%ha;
    return ans;
}
 
int main()
{
    cin>>n>>m;
    if(n>m) swap(n,m);
    if(n==1)
    {
        printf("%d\n",Pow(2,m));
        return 0;
    }
    if(m>n+1) nm=m,m=n+1;
    tot=n+m-1;
    for(int i=1;i<=n;i++) len[i]=i;
    for(int i=n+1;i<=m;i++) len[i]=n;
    for(int i=m+1;i<=tot;i++) len[i]=tot-i+1;
    f[1][0][1]=f[1][1][1]=1;
    for(int i=2;i<=tot;i++)
    {
        int k=i&1;
        memset(f[k],0,sizeof(f[k]));
        for(int s=0;s<(1<<len[i-1]);s++)
            for(int j=0;j<=len[i-1];j++)
            {
                if(!f[k^1][j][s]) continue;
                for(int y=0;y<=len[i];y++)
                {
                    bool flag=1;
                    for(int x=1;x<len[i];x++)
                        if(x!=y&&!in(rght(i,x),s)){flag=0;break;}
                    if(!flag) continue;
                    int t=0;
                    for(int k=1;k<=len[i];k++)
                    {
                        int d=dwn(i,k),r=rght(i,k);
                        if(d<1&&in(r,s)) t|=1<<k-1;
                        else if(r>len[i-1]&&in(d,s)) t|=1<<k-1;
                        else if(d!=j&&in(d,s)&&in(r,s)) t|=1<<k-1;
                    }
                    add(f[k][y][t],f[k^1][j][s]);
                }
            }
    }
    int ans=0;
    for(int i=0;i<2;i++)
        for(int j=0;j<2;j++)
            add(ans,f[tot&1][i][j]);
    if(nm) ans=1ll*ans*Pow(3,nm-m)%ha;
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：XY_cpp (赞：9)

这题，高效地打表。

~~也没什么思路~~

一开始我考虑了dp，在转移状态时发现这些东西无非是两种情况

1. 副对角线上的元素不相等，那么它们从下往上一定是不减的。
2. 副对角线的元素相等，那么对于任意两个对角线上相邻的格子，$(x-1,y)$，$(x,y+1)$，那么以格点$(x,y)$为左上角的任意矩阵中，他们的副对角线必然相等。
   
然后，我的dp方程写不下去了，手玩一上午，人都快吐了

但是我发现一个问题，上述的两种情况是满足题意的充分必要条件，也就是说，只要我构造出的矩阵满足上面的两个性质，那么构造出的矩阵一定合法。

所以，我们可以直接``dfs``，一边求一边剪枝，由于这是充分必要条件，所以对于任意一个当前合法的矩阵我往下搜索一定能得到解，所以``dfs``的搜索次数就是答案大小。

打表代码展示
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=30;
typedef long long ll;
ll ans;
int a[N][N],f[N][N];
void work(int x,int y,int n,int m)
{
    if(x>n)
    {
        ans++;
        return ;
    }
    int tx=x,ty=y+1;
	if(ty>=m+1) ty=1,tx+=1;
	for(int i=0;i<=1;i++)
    {
		if(i<a[x-1][y+1]) continue;
		if(f[x-1][y] && x-1>=1 && y+1<=m && i!=a[x-1][y+1]) continue;
		a[x][y]=i,f[x][y]=a[x-1][y]==a[x][y-1]||f[x-1][y]||f[x][y-1];
		work(tx,ty,n,m);
	}
}
ll cal(int n,int m)
{
    ans=0;
    work(1,1,n,m);
    return ans;
}
int main()
{
    for(int n=1;n<=8;n++)
        for(int m=n;m<=n+3;m++)
        {
            for(int i=1;i<n;i++)
		        a[i][0]=8;
	        for(int i=1;i<=m;i++)
		        a[0][i]=-8;
            printf("ans(%d,%d)=%lld\n",n,m,cal(n,m));
            memset(a,0,sizeof(a));
            memset(f,0,sizeof(f));
        }
    return 0;
}
```
于是乎我们打出了一张表
```
time ./a
ans(1,1)=2
ans(1,2)=4
ans(1,3)=8
ans(1,4)=16
ans(2,2)=12
ans(2,3)=36
ans(2,4)=108
ans(2,5)=324
ans(3,3)=112
ans(3,4)=336
ans(3,5)=1008
ans(3,6)=3024
ans(4,4)=912
ans(4,5)=2688
ans(4,6)=8064
ans(4,7)=24192
ans(5,5)=7136
ans(5,6)=21312
ans(5,7)=63936
ans(5,8)=191808
ans(6,6)=56768
ans(6,7)=170112
ans(6,8)=510336
ans(6,9)=1531008
ans(7,7)=453504
ans(7,8)=1360128
ans(7,9)=4080384
ans(7,10)=12241152
ans(8,8)=3626752
ans(8,9)=10879488
ans(8,10)=32638464
ans(8,11)=97915392
./a  9.60s user 0.01s system 99% cpu 9.635 total
```

>打表找规律，暴力出奇迹

你又可以打表发现$ans(n,m)=ans(m,n)$

钦定$n\le m$，我们发现

- 当$n \le 3$时
  - if $n=1$ ，$ans=2^m$
  - $n=2$,$ans=12 \times 3^{m-2}$
  - $n=3$,$ans=112\times 3^{m-3}$
- 否则
  - 若$n=m$，$ans=ans(n,n)$
  - 否则 $ans=ans(n,n+1) \times 3^{m-n-1}$

然后你就愉快的A了此题

AC代码展示
```cpp
#include<bits/stdc++.h>
#define int long long
const int qiyang=1e9+7;
using namespace std;
int a[]={0,0,0,0,912,7136,56768,453504,3626752};
int b[]={0,0,0,0,2688,21312,170112,1360128,10879488};
int power(int a,int b)
{
    int res=1;
    a%=qiyang;
    while(b)
    {
        if(b&1) (res*=a)%=qiyang;
        b>>=1,(a*=a)%=qiyang;
    }
    return res%qiyang;
}
int mod(int x){return (x%qiyang+qiyang)%qiyang;}
signed main()
{
    int n,m;
    scanf("%lld%lld",&n,&m);
    if(n>m) swap(n,m);
    if(n==1) printf("%lld\n",power(2,m));
    else if(n==2) printf("%lld\n",mod(4*power(3,m-1)));
    else if(n==3) printf("%lld\n",mod(112*power(3,m-3)));
    else 
    {
        if(n==m) printf("%lld\n",a[n]);
        else printf("%lld\n",mod(b[n]*power(3,m-n-1)));
    }
    return 0;
}
```

~~证明什么的我才不会呢~~

祝CSP2019 RP++

---

## 作者：我梦见一片焦土 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P5023)

---

# 思路：

题目中对其走过路径的字典序的比较提示我们按斜行分析。稍加思考我们就能得到一个明显的结论，就是对于某一个格子如果它是 $1$，那它的右上角的那个格子就不能是 $0$，这几乎就是题目条件的定义，因为有一条路径走到了这个格子，它就会在分叉的时候出问题。我们它这个性质总结一下就能得到我们需要的第一个结论：

- 对于每一个斜行，其 $0 / 1$ 状态一定是存在一个分界点，使得其左下方都是 $1$，其右上方都是 $0$。

有以上的结论将大大减少每一个斜行的可行的 $0 / 1$ 状态。

我们接着思考，一对不合法的路径的出现，除了上述的情况，都可以归结为两条不同的路径以相同的 $0 / 1$ 串走到了某一个格子，但是这个格子右边下边的两个格子的 $0/1$ 是不同的，这同样会让矛盾出现。

或许你会想这两条路径在 $0 / 1$ 字典序出现分歧的时候并不一定在同一个格子里，但如果存在这种情况，那我们一定能找到前者所说的更加简单的情况。

我们将形式地描述这个问题，我们称一个格子是模糊的，当且仅当存在两条不同的路径以相同的 $0/1$ 串走到了这个格子。我们所发现的可以表述成：

- 如果某一个格子它左边上边的两个格子的 $0 / 1$ 是相同的，或者它左边或上边有格子是模糊点，那这个格子就是模糊点；模糊点右边下边的两个格子的 $0 / 1$ 必须相同。

这也是一个重要的结论，它为下一个结论的得到提供了一个有力的帮助。模糊点的传递性隐约让我们感觉到它们的排布不会错杂无序，事实上十分有规律。读者可以仔细推敲，利用归纳法简单证明以下结论：

- 去除第一行和第一列的格子后，每一条斜行最多只有一个格子是非模糊的，并且这个非模糊点一定在第二行或第二列。

这个性质令人惊讶，但它是真实的，并且不难证明。

有了这个结论后，我们就可以有一个大致的想法，我们可以枚举整张图的模糊状态，状态数是 $O(m)$ 的，因为斜行上一旦全是模糊点，接下来也一定都是模糊点。我们考虑对于一个给定的模糊状态，我们怎么去计算有多少 $0 / 1$ 的填放方式满足整张图的模糊状态。

假设我们枚举那个仅存的非模糊点最后出现在哪一个斜行，手模一下可以发现，为了保证这个非模糊点没有消失，前面的大多数斜行的 $0 / 1$ 状态是唯一的，只有最开头的两斜行会有多种状态，并且为了让这个非模糊点在下一斜行中消失，这行和下一行的可行状态数也可以知道，那么算到这里方案数还是一个已知的常数。

在非模糊点消失后，接下来每一斜行面临的决策都是一样的，对于后面的方案数只要快速幂即可。复杂度是 $O(m\log m)$。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+10;
const int MOD=1e9+7;
const int INF=0x3f3f3f3f;
int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-'){
            f=-1;
        }
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
void write(int x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9){
        write(x/10);
    }
    putchar(x%10+'0');
    return;
}
int n,m,ans,p2,p3;
int pw(int x,int b){
    int r=1;
    for(;b;b>>=1,x=x*x%MOD){
        if(b&1){
            r=r*x%MOD;
        }
    }
    return r;
}
int C(int x){
    if(x>=m){
        return pw(2,n+m-x-1);
    }
    if(x>=n){
        return pw(3,m-x)*p2%MOD;
    }
    return pw(4,n-x)*p3%MOD*p2%MOD;
}
signed main(){
    cin>>n>>m;
    if(n>m){
        swap(n,m);
    }
    p2=pw(2,n-1);
    p3=pw(3,m-n);
    if(n==1){
        cout<<pw(2,m);
        return 0;
    }
    if(n==2){
        cout<<4ll*pw(3,m-1)%MOD;
        return 0;
    }
    ans=(ans+16ll*C(3))%MOD;
    ans=(ans+(3+(n!=3)+(m>3))*4ll*C(4))%MOD;
    for(int i=4;i<n;i++){
        ans=(ans+80ll*C(i+1))%MOD;
    }
    if(n>3){
        if(n<m){
            ans=(ans+32ll*C(n+1))%MOD;
        }else{
            ans=(ans+24ll*C(n+1))%MOD;
        }
    }
    if(n<m){
        ans=(ans+8ll*C(n+1))%MOD;
    }else{
        ans=(ans+6ll*C(n+1))%MOD;
    }
    if(n<m&&n!=3){
        ans=(ans+32ll*C(n+1))%MOD;
    }
    for(int i=n+1;i<m;i++){
        ans=(ans+24ll*C(i+1))%MOD;
    }
    if(n>3||m>3){
        if(n<m){
            ans=(ans+18ll*C(m+1))%MOD;
        }else{
            ans=(ans+24ll*C(m+1))%MOD;
        }
    }
    ans=(ans+6ll*C(m+1))%MOD;
    cout<<ans;
    return 0;
}
```
完结撒花~

---

## 作者：LHW_Cosset_Idiot (赞：0)

可以直接看到想法二，极少数不全是暴力的想法。大佬的看不懂，我就长话短说了。

### 题目大意：
可以理解为，有 $n \times m$ 的 $\texttt{01}$ 表格，从左上角 $(1,1)$ 走到右下角 $(n,m)$，只能向右或向下走，定义向下的字典序大于向右，求满足任意两条路径的字典序和路径上经过的数字的字典序不相反的 $\texttt{01}$ 表格数量对 $10^7+7$ 取模的结果。

### 主要想法：

#### 想法一（简单做法）：
暴力打表推规律，结果赛时推不出来（模拟赛），拿部分分：$1 \sim 4$

我会打表！我会手玩！我会暴力！
期望得分：$20$

好，赛后往下推，发现其实答案已经写在草稿纸上了，就是没注意...

听了大佬讲完不用打表的做法后，开始写新想法总结，总结时看到大家的题解都是暴力打表，我就开始写不用打标的想法...于是...

这里强烈推荐 [这篇](https://www.luogu.com.cn/article/pk56pwdb) 证明暴力原理的题解！！！

#### 想法二（~~人机做法~~）：
- 首先明确，$n$,$m$，的地位是相等的，$n$ 等于 $1$ 时，$ans$ 一定是 $2^m$，所以直接看 $n \ge 2$ 的时候。
- 用 $w_{i,j}$ 表示第 $i$ 行第 $j$ 列的数。根据题目的要求首先可以得到条件1：
$$w_{i,j} \ge w_{i-1,j+1}$$
- 另外，条件2如果是 
$$w_{i,j} \ge w_{i-1,j+1}$$
那么从 $(i,j+1)$ 到 $(n,m)$ 的所有路径对应的字符串都应当相等，这个条件可以通过小样例推出。
- 接着你会发现，任意两条路径，它们开始会有一段公共部分，接着分开，然后到某个位置（可能是终点）再次汇合。那么对于第一次汇合点 $(i,j)$ 之前的这一段所代表的字符串，不管怎样都会满足条件，无论这两条路径后面怎样，最终得到的字符串都一定相等。
- 于是，这个问题就转化为：求有多少个 $\texttt{01}$ 矩阵同时满足上面两个条件。条件一，我们只需注意左上到右下的每条对角线上第一个 $1$ 的位置。条件二，当 $(i,j)$ 满足
$$w_{i+1,j} = w_{i,j+1}$$
 并且 $(i+1,j)$ 和 $(i,j+1)$ 所对的矩形也满足性质，那么可以直接等价交换。
- 总结上述做法，发现递推的复杂度是 $O(2^{2n} mn)$。虽然表面上看不可行，但是 $n=8$ 时，只有 $28$ 个有用状态，所以 $O(28mn)$，可行。

其实吧，个人认为还是打表好点...

做法已给出，程序请自己模拟。

---


# [NOIP 2018 提高组] 保卫王国

## 题目背景

NOIP2018 提高组 D2T3

## 题目描述

Z 国有 $n$ 座城市，$(n - 1)$ 条双向道路，每条双向道路连接两座城市，且任意两座城市都能通过若干条道路相互到达。  

Z 国的国防部长小 Z 要在城市中驻扎军队。驻扎军队需要满足如下几个条件： 

- 一座城市可以驻扎一支军队，也可以不驻扎军队。   
- 由道路直接连接的两座城市中至少要有一座城市驻扎军队。   
- 在城市里驻扎军队会产生花费，在编号为 $i$ 的城市中驻扎军队的花费是 $p_i$。      

小 Z 很快就规划出了一种驻扎军队的方案，使总花费最小。但是国王又给小 Z 提出了 $m$ 个要求，每个要求规定了其中两座城市是否驻扎军队。小 Z 需要针对每个要求逐一给出回答。具体而言，如果国王提出的第 $j$ 个要求能够满足上述驻扎条件（不需要考虑第 $j$ 个要求之外的其它要求），则需要给出在此要求前提下驻扎军队的最小开销。如果国王提出的第 $j$ 个要求无法满足，则需要输出 $-1$。现在请你来帮助小 Z。 

## 说明/提示

#### 样例 1 解释

- 对于第一个要求，在 $4$ 号和 $5$ 号城市驻扎军队时开销最小。
- 对于第二个要求，在 $1$ 号、$2$ 号、$3$ 号城市驻扎军队时开销最小。   
- 第三个要求是无法满足的，因为在 $1$ 号、$5$ 号城市都不驻扎军队就意味着由道路直接连 接的两座城市中都没有驻扎军队。  

#### 数据规模与约定  

| 测试点编号 | $\text{type}$ | $n = m=$ |
|:-:|:-:|:-:|
| $1,2$ | `A3` | $10$ |
| $3,4$ | `C3` | $10$ |
| $5,6$ | `A3` | $100$ |
| $7$ | `C3` | $100$ |
| $8,9$ | `A3` | $2\times 10^3$ |
| $10,11$ | `C3` | $2\times 10^3$ |
| $12,13$ | `A1` | $10^5$ |
| $14, 15, 16$ | `A2` | $10^5$ |
| $17$ | `A3` | $10^5$ |
| $18,19$ | `B1` | $10^5$ |
| $20,21$ | `C1` | $10^5$ |
| $22$ | `C2` | $10^5$ |
| $23, 24, 25$ | `C3` | $10^5$ |

数据类型的含义：   

- `A`：城市 $i$ 与城市 $i + 1$ 直接相连。    
- `B`：任意城市与城市 $1$ 的距离不超过 $100$（距离定义为最短路径上边的数量），即如果这 棵树以 $1$ 号城市为根，深度不超过 $100$。   
- `C`：在树的形态上无特殊约束。   
- `1`：询问时保证 $a = 1,x = 1$，即要求在城市 $1$ 驻军。对 $b,y$ 没有限制。   
- `2`：询问时保证 $a,b$ 是相邻的（由一条道路直接连通）  
- `3`：在询问上无特殊约束。

对于 $100\%$的数据，保证 $1 \leq n,m ≤ 10^5$，$1 ≤ p_i ≤ 10^5$，$1 \leq u, v, a, b \leq n$，$a \neq b$，$x, y \in \{0, 1\}$。

## 样例 #1

### 输入

```
5 3 C3 
2 4 1 3 9 
1 5 
5 2 
5 3 
3 4 
1 0 3 0 
2 1 3 1 
1 0 5 0
```

### 输出

```
12 
7 
-1```

# 题解

## 作者：immortalCO (赞：283)

利益无关：猫锟**不是**本题的命题猫。

本题解同样发在 UOJ 

### 算法一
最小权覆盖集 = 全集 - 最大权独立集

强制取点、不取点可以使用把权值改成正无穷或负无穷实现。

接下来就是 https://www.luogu.org/problemnew/show/P4719 了。

$O(n\log n)$。

### 算法二
考虑修改的两个点 $a,b$ 构成这条链。

可以把操作看作是：先在这条链伸出去的每棵子树上 DP，最后再在这条链上 DP。

伸出去的子树以及链的中间的点和修改无关，因而可以整合起来高效处理，因为它们的转移是不受影响的；但是 $a$ 和 $b$ 的转移是受影响的，需要单独处理。

因此可以先预处理出每个子树的 DP 值，然后用倍增或树剖维护“从一个点往上按照通用规则 DP 到另一个点的结果”，这样只需要特殊处理修改的点，其他地方只需要直接倍增。

$O(n\log n)$。

### 算法三
如果不想写倍增，也可以写这样一个算法：把所有的询问放在一起处理。

也就是说，由于每条链中间的 DP 转移全部相同，因而我们可以批量地对所有需要进行这一转移的 DP 进行转移，从而加快速度。

这个算法虽然实现较容易，但理解较为困难，因而不再叙述。

$O(n\log n)$。


---

## 作者：zhoutb2333 (赞：169)

考场上一眼动态dp。。然而又看到没有修改点权，所以倍增就好了

令 $T$ 为整棵树，设 $f[i][0/1]$ 表示（以 $i$ 为根的子树），其中 $i$ 选/不选的最小代价，$g[i][0/1]$ 为 （ $T-$ 以 $i$ 为根的子树），其中 $i$ 选/不选的最小代价。这两个数组可以树形dp求出。

然后令 $anc$ 表示 $i$ 的 $2^j$ 祖先， $fh[i][j][0/1][0/1]$ 表示（$anc$ 的子树 $- \ i$ 的子树 ），其中 $i$ 的状态为 $0/1$ ，$anc$ 的状态为 $0/1$ 的最小代价，这个数组可以枚举 $i$ 的 $2^{j-1}$ 祖先的状态直接转移。

然后有了这些数组我们就可以处理询问了。

- 如果 $a$ 是 $b$ 的祖先，那么可以直接倍增上去（还是像 $fh$ 一样合并倍增数组，枚举中间点的状态即可），然后不要忘了加上 $g[a][x]$ 。
- 否则我们需要先把 $a$ 和 $b$ 都倍增到 $lca$ 的儿子处，然后枚举 $lca$ 和两个儿子的状态，具体可以见代码。

复杂度 $O((n+q) \log n)$ ，不是最优算法，但已经可以通过本题。

附考场代码，赶时间写的，所以不美观。。

``` cpp
#include<cstdio>
#include<set>
#include<cctype>
#include<algorithm>
#define maxn 100010
#define maxm 200010
#define ll long long
#define mp make_pair
#define pii pair<int,int>
using namespace std;

int hd[maxn],nxt[maxm],pnt[maxm],tot=0;
int fa[maxn][20],val[maxn],dep[maxn],n,q;
ll f[maxn][2],g[maxn][2],fh[maxn][20][2][2];
const ll INF=1LL<<60;
char Type[10];
set<pii> st;
void read(int &x){
    char ch=x=0;
    while(!isdigit(ch))
        ch=getchar();
    while(isdigit(ch))
        x=x*10+ch-'0',ch=getchar();
}
void add(int x,int y){
    pnt[++tot]=y,nxt[tot]=hd[x],hd[x]=tot;
}
void dfs(int x,int FA,int d){
    fa[x][0]=FA,dep[x]=d;
    f[x][1]=val[x];
    for(int i=hd[x];i;i=nxt[i]){
        int v=pnt[i];
        if(v==FA)
            continue;
        dfs(v,x,d+1);
        f[x][0]+=f[v][1],f[x][1]+=min(f[v][0],f[v][1]);
    }
}
void dfs_2(int x){
    for(int i=hd[x];i;i=nxt[i]){
        int v=pnt[i];
        if(v==fa[x][0])
            continue;
        g[v][0]=g[x][1]+f[x][1]-min(f[v][0],f[v][1]);
        g[v][1]=min(g[x][0]+f[x][0]-f[v][1],g[v][0]);
        dfs_2(v);
    }
}
ll solve(int x,int a,int y,int b){// x 和 a 互换 , y 和 b 互换
    if(dep[x]<dep[y])
        swap(x,y),swap(a,b);
    ll tx[2]={INF,INF},ty[2]={INF,INF};
    ll nx[2],ny[2];
    tx[a]=f[x][a],ty[b]=f[y][b];
    for(int i=19;~i;i--){
        if(dep[fa[x][i]]>=dep[y]){
            nx[0]=nx[1]=INF;
            for(int j=0;j<2;j++){
                for(int k=0;k<2;k++)
                    nx[j]=min(nx[j],tx[k]+fh[x][i][k][j]);
            }
            tx[0]=nx[0],tx[1]=nx[1],x=fa[x][i];
        }
    }
    if(x==y)
        return tx[b]+g[x][b];
    for(int i=19;~i;i--){
        if(fa[x][i]!=fa[y][i]){
            nx[0]=nx[1]=ny[0]=ny[1]=INF;
            for(int j=0;j<2;j++){
                for(int k=0;k<2;k++){
                    nx[j]=min(nx[j],tx[k]+fh[x][i][k][j]);
                    ny[j]=min(ny[j],ty[k]+fh[y][i][k][j]);
                }
            }
            tx[0]=nx[0],tx[1]=nx[1],x=fa[x][i];
            ty[0]=ny[0],ty[1]=ny[1],y=fa[y][i];
        }
    }
    int lca=fa[x][0];
    ll ans0=f[lca][0]-f[x][1]-f[y][1]+tx[1]+ty[1]+g[lca][0];
    ll ans1=f[lca][1]-min(f[x][0],f[x][1])-min(f[y][0],f[y][1])+min(tx[0],tx[1])+min(ty[0],ty[1])+g[lca][1];
    return min(ans0,ans1);
}
int main(){
    read(n),read(q),scanf("%s",Type);
    for(int i=1;i<=n;i++)
        read(val[i]);
    for(int i=1,u,v;i<=n-1;i++){
        read(u),read(v);
        add(u,v),add(v,u);
        st.insert(mp(u,v)),st.insert(mp(v,u));
    }
    dfs(1,0,1),dfs_2(1);
    for(int i=1;i<=n;i++){
        fh[i][0][0][0]=INF;
        fh[i][0][0][1]=f[fa[i][0]][1]-min(f[i][0],f[i][1]);
        fh[i][0][1][0]=f[fa[i][0]][0]-f[i][1];
        fh[i][0][1][1]=f[fa[i][0]][1]-min(f[i][0],f[i][1]);
    }
    for(int j=1;j<=19;j++){
        for(int i=1;i<=n;i++){
            int tmp=fa[i][j-1];
            fa[i][j]=fa[tmp][j-1];
            for(int u=0;u<2;u++){
                for(int v=0;v<2;v++){
                    fh[i][j][u][v]=INF;
                    for(int w=0;w<2;w++)
                        fh[i][j][u][v]=min(fh[i][j][u][v],fh[i][j-1][u][w]+fh[tmp][j-1][w][v]);
                }
            }
        }
    }
    for(int i=1,a,b,x,y;i<=q;i++){
        read(a),read(x),read(b),read(y);
        if(!x&&!y&&st.find(mp(a,b))!=st.end()){
            puts("-1");
            continue;
        }
        printf("%lld\n",solve(a,x,b,y));
    }
    return 0;
}
```

---

## 作者：Elegia (赞：24)

接 zhoutb 的思路，由于询问是离线的，这道题可以把倍增部分替换成并查集实现，即：倍增要解决的问题是每次询问一条链的 dp 值（或者说这个 min-plus 矩阵的积），这可以考虑一个类似 tarjan lca 的过程，结合路径压缩。但是貌似不太支持按秩合并……通过 wiki 来的复杂度，该这种情况下的复杂度为 $\Theta(n + m\log_{2 + m/n} n)$。

```cpp
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cstdlib>

#include <algorithm>
#include <numeric>
#include <limits>
#include <functional>
#include <stack>
#include <vector>
#include <set>
#include <map>
#include <queue>

#define LOG(FMT...) fprintf(stderr, FMT)

using namespace std;

typedef long long ll;
typedef unsigned long long ull;

struct Edge {
    int v;
    Edge *next;
};

ll ad(ll x, ll y) {
    if (~x & ~y)
        return x + y;
    return -1;
}

bool cmp(ll x, ll y) {
    return x != -1 && (x < y || y == -1);
}

struct Mat {
    ll gr[2][2];

    Mat() { memset(gr, -1, sizeof(gr)); }

    Mat(const Mat& rhs) { memcpy(gr, rhs.gr, sizeof(gr)); }

    ll* operator[](int k) { return gr[k]; }
    const ll* operator[](int k) const { return gr[k]; }

    void dbg() const {
        for(int i = 0; i < 2; ++i) {
            for(int j = 0; j < 2; ++j) {
                LOG("%lld ", gr[i][j]);
            }
            LOG("\n");
        }
    }

    Mat operator*(const Mat& rhs) const {
        Mat m = Mat();
        for (int i = 0; i < 2; ++i)
            for (int j = 0; j < 2; ++j) {
                for (int k = 0; k < 2; ++k)
                    m[i][j] = min(m[i][j], ad(gr[i][k], rhs.gr[k][j]), cmp);
            }
//		dbg();
//		rhs.dbg();
//		m.dbg();
        return m;
    }
};

const int N = 100010;

int n, m;
char s[5];
bool vis[N];
int p[N], f[N], qa[N], qx[N], qb[N], qy[N], lca[N];
Mat dt[N];
ll ans[N];
ll dp[N][2], tmp[N][2];
Edge* g[N];
vector<pair<int, int> > ql[N];
vector<int> qr[N];

int find(int x) { return f[x] == x ? x : f[x] = find(f[x]); }

int find2(int x) {
    if (f[x] == x)
        return x;
    int prt = f[x];
    f[x] = find2(prt);
    dt[x] = dt[prt] * dt[x];
    return f[x];
}

void adde(int u, int v);
void tarjan(int u);
void dfs(int u);

int main() {
#ifndef ONLINE_JUDGE
    freopen("test.in", "r", stdin);
    int nol_cl = clock();
#endif

    scanf("%d%d%s", &n, &m, s);
    for (int i = 1; i <= n; ++i)
        scanf("%d", &p[i]);
    for (int rep = 1; rep < n; ++rep) {
        int u, v;
        scanf("%d%d", &u, &v);
        adde(u, v);
        adde(v, u);
    }
    for (int i = 1; i <= m; ++i) {
        scanf("%d%d%d%d", &qa[i], &qx[i], &qb[i], &qy[i]);
        ql[qa[i]].push_back(make_pair(qb[i], i));
        ql[qb[i]].push_back(make_pair(qa[i], i));
    }
    tarjan(1);
    for (int i = 1; i <= m; ++i)
        qr[lca[i]].push_back(i);
    memset(vis, 0, sizeof(vis));
    memset(f, 0, sizeof(f));
    {
        Mat model = Mat();
        model[0][0] = model[1][1] = 0;
        fill(dt + 1, dt + n + 1, model);
    }
    dfs(1);
    for (int i = 1; i <= m; ++i) {
        int lc = lca[i];
        find2(lc);
        ans[i] = -1;
//		LOG("%d: %lld %lld\n", i, tmp[i][0], tmp[i][1]);;
        for (int k = 0; k < 2; ++k)
            for (int j = 0; j < 2; ++j)
                ans[i] = min(ans[i], ad(dt[lc][k][j], tmp[i][j]), cmp);
        printf("%lld\n", ans[i]);
    }

#ifndef ONLINE_JUDGE
    LOG("Time: %dms\n", int((clock() - nol_cl) / (double)CLOCKS_PER_SEC * 1000));
#endif
    return 0;
}

void dfs(int u) {
    vis[u] = true;
    f[u] = u;
    dp[u][1] = p[u];
    for (Edge* p = g[u]; p; p = p->next)
        if (!vis[p->v]) {
            dfs(p->v);
            dp[u][0] += dp[p->v][1];
            dp[u][1] += min(dp[p->v][0], dp[p->v][1]);
        }
    for (int i = 0; i < qr[u].size(); ++i) {
        int id = qr[u][i];
        int &a = qa[id], &x = qx[id], &b = qb[id], &y = qy[id];
        if (u == b) {
            swap(a, b);
            swap(x, y);
        }
        if (u != a) {
            find2(a);
            find2(b);
            for (int k = 0; k < 2; ++k) {
                tmp[id][k] = -1;
                ll sub = dp[u][k];
                if (k == 0)
                    sub -= dp[f[a]][1] + dp[f[b]][1];
                else
                    sub -= min(dp[f[a]][0], dp[f[a]][1]) + min(dp[f[b]][0], dp[f[b]][1]);

                if (k == 0)
                    tmp[id][0] = ad(dp[a][x] + dp[b][y], ad(sub, ad(dt[a][1][x], dt[b][1][y])));
                else
                    tmp[id][1] = ad(dp[a][x] + dp[b][y] + sub, ad(min(dt[a][1][x], dt[a][0][x], cmp), min(dt[b][1][y], dt[b][0][y], cmp)));
            }
        }
    }
    for (Edge* p = g[u]; p; p = p->next)
        if (!vis[p->v]) {
            f[p->v] = u;
            dt[p->v][0][0] = -1;
            dt[p->v][0][1] = dp[u][0] - dp[p->v][1];
            dt[p->v][1][0] = dt[p->v][1][1] = dp[u][1] - min(dp[p->v][0], dp[p->v][1]);
        }
    for (int i = 0; i < qr[u].size(); ++i) {
        int id = qr[u][i];
        int a = qa[id], x = qx[id], b = qb[id], y = qy[id];
        if (u == a) {
            find2(b);
//			LOG("%d(from %d)%d %d\n", f[b], b, f[f[b]], u);
            tmp[id][x] = ad(dt[b][x][y], dp[b][y]);
//			LOG("%lld\n", dt[b][x][y]);
            tmp[id][!x] = -1;
        }
    }
    vis[u] = false;
}

void tarjan(int u) {
    static bool vis[N];
    vis[u] = true;
    f[u] = u;
    for (Edge* p = g[u]; p; p = p->next)
        if (!vis[p->v]) {
            tarjan(p->v);
            f[p->v] = u;
        }
    for (int i = 0; i < ql[u].size(); ++i)
        if (f[ql[u][i].first])
            lca[ql[u][i].second] = find(ql[u][i].first);
}

void adde(int u, int v) {
    static Edge pool[N * 2];
    static Edge* p = pool;
    p->v = v;
    p->next = g[u];
    g[u] = p;
    ++p;
}
```

---

## 作者：HRLYB (赞：11)


本篇题解采用了动态dp的算法，但是没有采用通常的“最小权覆盖集=全集-最大权独立集”的思路，而是采用了较为普通的直接求最小权覆盖集的思路，相较而言更加容易理解（少了一步转换而且状态设计更加贴近题意），私以为可以方便同学们理解动态dp和这道题的解法，同时也为“最小权覆盖集=全集-最大权独立集”这一结论的正确性提供了佐证.


------------


>[P5024 保卫王国](https://www.luogu.org/problem/P5024)

### 题意概述

给定一棵带权树和$m$个要求，求树上每条边的**两个端点至少选择一个**时，最小的总权值. 此外，每个要求都会指定两个点是否能够选择，求在分别满足这些要求的前提下，最小的总权值是多少.

### 题目分析
首先，如果只看题目的前半部分，就是一个简单的树形$dp$，本题的难点就在于如何在指定两个点的状态的同时做到时间复杂度尽量低.
#### 朴素的想法
考虑最朴素的做法，显然是每次询问时，重新遍历一次整棵树，对指定的两个点进行标记，从而得解.

那我们是怎么标记的呢？不妨考虑我们是怎样设的状态和怎样推的状态转移方程.

> $f_{i,0}$表示在第i个点不选择时候的子树最小值，$f_{i,1}$表示在第i个点选择时的子树最小值.
> 那么，对于$v->u$，就有：
> $f_{u,0}+=f_{v,1}$
> $f_{u,1}+=min(f_{v,1},f_{v,0})$
> 这两个状态转移方程的正确性是显然的.

不难想到，由于状态转移方程是取$min$的操作，故而可以通过**给一个点赋极大值**，从而达到“不选择”的目的.

> 举个例子：
> 假设$v$不能选择，那么$f_{v,1}=inf$，那么它的$next$节点$u$也就不能不选择了，我们观察状态转移方程，发现此时算出来的$f_{u,0}+=inf$，的确是极大值，从而该做法可行.
> 同理$v$可以选择的情况.

```cpp
void dfs(int u,int pre,int x,int a,int y,int b){
	f[u][1]=wt[u];f[u][0]=0;
	for(int i=head[u];i;i=e[i].next ){
		int v=e[i].v ;
		if(v==pre)continue;
		dfs(v,u,x,a,y,b);
		f[u][1]+=min(f[v][0],f[v][1]);
		f[u][0]+=f[v][1];
	}
	if(u==x&&a)f[u][0]=inf;
	else if(u==x&&!a)f[u][1]=inf;
	
	if(u==y&&b)f[u][0]=inf;
	else if(u==y&&!b)f[u][1]=inf;
}


	for(int i=1,x,a,y,b;i<=m;i++){
		memset(f,0,sizeof f);
		scanf("%d%d%d%d",&x,&a,&y,&b);
		dfs(1,1,x,a,y,b);
		if(min(f[1][0],f[1][1])>=inf)printf("-1\n");
		else printf("%lld\n",min(f[1][0],f[1][1]));
	}
```
#### 进一步的思考

可以发现，以上时间复杂度为$O(nm)$的朴素做法，慢就慢在重复计算了大量重复的状态，比如说每次在dfs完之后，都得memset一下，然后再重新计算.

而我们知道，实际上每次对于一个点的修改，都只会影响从这个点到根节点的状态.

> 考虑状态转移方程，一个节点状态只与它的所有儿子的状态有关，而一个节点状态的改变也只会影响其父亲.
> 也就是说每个节点和其子树都是相对独立的，不会出现同层子树互相干扰的情况.

所以我们考虑在初始化时以$O(n)$的复杂度算出初始状态后，每个要求都用一个什么东西维护修改的两个值，然后恢复初始状态.

这正是我们~~所熟悉的~~动态$dp$.

#### 动态dp

> 树上的动态dp=树链剖分/LCT将树“摊平”+线段树维护矩阵转移方程

[模板指路 P4719](https://www.luogu.org/problem/P4719)

[我比较喜欢的一篇题解](https://www.luogu.org/blog/Tweetuzki/solution-p4179)

动态dp的主要思想就是利用线段树（或者其他合适的数据结构）**维护状态转移方程**，从而实现对于一个dp问题进行修改操作.

在树形dp的操作就是套路化的套一个树链剖分或者LCT.

现在就以使用树链剖分为例~~窝太菜了不会LCT~~来讲讲怎么实现这一题.

另外，由于蒟蒻不知道大佬们是怎么推出**最小权覆盖集=全集-最大权独立集**这个结论的，所以只能用常规的求最小权覆盖集的算法（直接求$min$）  ，不像一些题解所顾虑的一样，实际上这个方法是完全可行的.

-----------

首先，由于使用了树链剖分，同时为了迎合之后状态转移方程改为**矩阵形式**的需要，状态设计要有所改变.

> $f_{i,0}$表示第i个点不选时的最小值
> $f_{i,1}$表示第i个点选择时的最小值
> $g_{i,0}$表示不选i而i的轻儿子全部选择时的值
> $g_{i,1}$表示i选定而其轻儿子可以任意选择时的最小值

那么我们就有如下的状态转移方程

> $f_{i,0}=f_{j,1}+g_{i,0}$
> $f_{i,1}=min(f_{j,0},f_{j,1})+g_{i,1}$

把它转换成矩阵乘法的形式：

>![](https://cdn.luogu.com.cn/upload/image_hosting/29vj5aqh.png)

在这里，我们重定义了$\times$运算：

$$A\times B=min(A_{i,k}+B_{k,j})$$

	注意由于在树链剖分中叶子节点最后被访问到，
	所以状态转移方程是从右向左更新的，
	又因为矩阵具有结合律而没有交换率，
	状态转移方程要写成这样的形式

在之前我们实现40pts的暴力时，我们通过变成$inf$来实现指定要求的状态，那么我们现在同样可以将$f_{i,0}\:/\:f_{i,1}$设为$inf$来标记一个点是否选择.

-----------

当u点强制选择时，

>$f_{u,0}+=inf$

而
>$f_{u,0}=f_{v,1}+g_{u,0}$

其中$f_{j,1}$显然不可改变（在动态dp中它是推出来的），所以我们不妨把$g_{i,0}+=inf$

--------

同理当i点强制不选择时，

>$f_{u,1}+=inf$
>$f_{u,1}=min(f_{v,1},f_{v,0})+g_{u,1}$

所以此时$g_{i,1}+=inf$

--------

因为这道题的要求是“分别满足”的，所以在这里$+inf$的优越性就体现出来了，我们可以很容易通过$-inf$来恢复到原来的状态.

总的时间复杂度为$O(2n+m\:log^2\:n)$.

### 程序实现

```cpp
#include<iostream>
#include<cstdio>
#define ll long long
#define mid ((l+r)>>1)
#define inf 5e9
#define maxn 100010
using namespace std;
struct edge{
	int v,next;
}e[maxn<<1];
int head[maxn],tot;
inline void add(int u,int v){
	e[++tot].v =v;
	e[tot].next =head[u];
	head[u]=tot;
}
struct matrix{
	ll mat[2][2];
	matrix(){mat[0][0]=mat[0][1]=mat[1][0]=mat[1][1]=inf;}//调用时初始化
	matrix operator * (matrix x)const {
		matrix c;
		for(int i=0;i<2;i++)
			for(int j=0;j<2;j++)
				for(int k=0;k<2;k++)
				c.mat [i][j]=min(c.mat [i][j],mat[i][k]+x.mat [k][j]);
		return c;//重载运算符*
	}
};//矩阵乘法
int dfn[maxn];//dfn[线段树数列中的编号]=原编号
ll wt[maxn];
matrix ans[maxn<<2],val[maxn];
inline void push_up(int p){ans[p]=ans[p<<1]*ans[p<<1|1];}
inline void build(int p,int l,int r){
	if(l==r){
		ans[p]=val[dfn[l]];
		return ;
	}
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	push_up(p);
}
inline void update(int p,int l,int r,int k){
	if(l==r){
		ans[p]=val[dfn[k]];//修改时找到位置再赋值（听说减小常数？）
		return ;
	}
	if(k<=mid)update(p<<1,l,mid,k);
	if(mid<k)update(p<<1|1,mid+1,r,k);
	push_up(p);
}
matrix query(int p,int l,int r,int ql,int qr){
	if(ql<=l&&r<=qr)return ans[p];
	if(qr<=mid)return query(p<<1,l,mid,ql,qr);
	else if(ql>mid)return query(p<<1|1,mid+1,r,ql,qr);
	else return query(p<<1,l,mid,ql,qr)*query(p<<1|1,mid+1,r,ql,qr);
}//常规的线段树操作
int size[maxn],fa[maxn],son[maxn];
inline void dfs1(int u,int pre){
	size[u]=1;
	fa[u]=pre;
	for(int i=head[u];i;i=e[i].next ){
		int v=e[i].v ;
		if(v==pre)continue;
		dfs1(v,u);
		size[u]+=size[v];
		if(size[v]>size[son[u]])son[u]=v;
	}
}
int top[maxn],id[maxn],ed[maxn],cnt;//ed记录数列尾部（叶子节点），状态由叶子节点转移而来
ll f[maxn][2];
inline void dfs2(int u,int topu){
	top[u]=topu;
	id[u]=++cnt;
	dfn[cnt]=u;
	ed[topu]=cnt;
	f[u][0]=0;f[u][1]=wt[u];
	val[u].mat [0][1]=0;
	val[u].mat [1][0]=val[u].mat [1][1]=wt[u];
	if(!son[u])return ;
	dfs2(son[u],topu);
	f[u][0]+=f[son[u]][1];
	f[u][1]+=min(f[son[u]][1],f[son[u]][0]);
	for(int i=head[u];i;i=e[i].next ){
		int v=e[i].v ;
		if(v==fa[u]||v==son[u])continue;
		dfs2(v,v);
		f[u][0]+=f[v][1];
		f[u][1]+=min(f[v][0],f[v][1]);
		val[u].mat [0][1]+=f[v][1];
		val[u].mat [1][0]+=min(f[v][0],f[v][1]);
		val[u].mat [1][1]=val[u].mat [1][0];//给对应矩阵的位置赋初值
	}
}
int n,m;
inline void update_path1(int u,ll w){
	val[u].mat [1][0]+=w;
	val[u].mat [1][1]=val[u].mat [1][0];//update_path1表示i点强制不选择
	matrix bef,aft;
	while(u){
		bef=query(1,1,n,id[top[u]],ed[top[u]]);
		update(1,1,n,id[u]);
		aft=query(1,1,n,id[top[u]],ed[top[u]]);
		u=fa[top[u]];
		val[u].mat [1][0]+=min(aft.mat [0][1],aft.mat [1][1])-min(bef.mat [0][1],bef.mat [1][1]);
		val[u].mat [1][1]=val[u].mat [1][0];
		val[u].mat [0][1]+=aft.mat [1][1]-bef.mat [1][1];
	}
}
inline void update_path2(int u,ll w){
	val[u].mat [0][1]+=w;//update_path2表示i点强制选择
	matrix bef,aft;
	while(u){
		bef=query(1,1,n,id[top[u]],ed[top[u]]);
		update(1,1,n,id[u]);
		aft=query(1,1,n,id[top[u]],ed[top[u]]);
		u=fa[top[u]];
		val[u].mat [1][0]+=min(aft.mat [0][1],aft.mat [1][1])-min(bef.mat [0][1],bef.mat [1][1]);
		val[u].mat [1][1]=val[u].mat [1][0];
		val[u].mat [0][1]+=aft.mat [1][1]-bef.mat [1][1];//矩阵修改操作，新值=原值+变化值
	}
}
int main(){
	string type;
	scanf("%d%d",&n,&m);cin>>type;
	for(register int i=1;i<=n;++i)scanf("%lld",&wt[i]);
	for(register int i=1,u,v;i<n;++i){
		scanf("%d%d",&u,&v);
		add(u,v);add(v,u);
	}
	dfs1(1,0);
	dfs2(1,1);
	build(1,1,n);
	for(register int i=1,a,x,b,y;i<=m;++i){
		scanf("%d%d%d%d",&a,&x,&b,&y);
		if(x==0)update_path1(a,inf);
		else update_path2(a,inf);
		if(y==0)update_path1(b,inf);
		else update_path2(b,inf);//修改成指定值
		matrix Ans=query(1,1,n,id[1],ed[1]);
		if(min(Ans.mat [0][1],Ans.mat [1][1])>=inf)printf("-1\n");//如果出现了怎么选择都是inf的情况，说明没有可行方案
		else printf("%lld\n",min(Ans.mat [0][1],Ans.mat [1][1]));
		if(x==0)update_path1(a,-inf);
		else update_path2(a,-inf);
		if(y==0)update_path1(b,-inf);
		else update_path2(b,-inf);//修改回原值
	}
	return 0;
} 
```

### 后记

还是想说一下这种直接修改的做法为什么是正确的. 首先，它**只影响了从当前节点到根的状态**，所以满足了树形dp的要求. 此外，虽然有两个点要修改，但是考虑原来的动态dp模型，发现**修改多个点/多次是不会影响其正确性的**，我们相当于只是执行了4次动态dp的修改而已，所以也是正确的，而不需要考虑“两个点在同一条重链上怎么处理”之类的问题.

此外，非常感谢@10MN47 的帮助和差错. 包括但不限于发现了我状态转移矩阵的错误（打草稿时矩阵写着写着就笔误了）和我赋值时候的错误（直接把指定点改成了$inf$而不是$\pm inf$）


---

## 作者：tommymio (赞：10)

大家好，众所周知 $\color{green}\text{tommy0103}$ 是个 $\color{green}\text{pupil}$ 选手，所以她就用暴力把这道题 $\text{TLE}$ 了/cy

简要题意：树上最小权独立集，有 $Q$ 次询问，要求点 $x,y$ 一定取 $/$ 不能取的情况下的值。**询问之间互相独立**。

**我会 $\text{44}$ 分！**有一个非常 $\text{Naive}$ 的树形 $\text{DP}$，设 $f[x,0/1]$ 为不选 $/$ 选 $x$ 点，子树 $x$ 的最小权之和。则有状态转移方程：

$$
f[x,0]=\sum_{y\in son_x}f[y,1]
$$

$$
f[x,1]=\sum_{y\in son_x} \min(f[y,0],f[y,1])+a_x
$$

每次更新点的状态时重新 $\text{DP}$ 一次，时间复杂度为 $O(nm)$。

**我会 $68$ 分！**考虑到修改点 $x,y$ 的状态只会影响 $1\to x,1\to y$ 路径的并上的 $f$ 值，有没有什么办法使得修改点的状态很少，或者预处理出一部分点能够在查询时合并得解呢？尝试设定两个点的状态，或许能够直接得解？设 $dp[u,v,0/1,0/1]$，其中 $v\in \mathrm{Subtree}(u)$，时间复杂度和空间复杂度似乎都更劣了，但好消息是我们能够 $O(1)$ 回答每个询问。

这时我们突然发现，这个东西是可以倍增处理的！设 $g[x,k,0/1,0/1]$ 为 $x$ 不选 $/$ 选，$x$ 的 $2^k$ 辈祖先不选 $/$ 选，以 $x$ 的 $2^k$ 辈祖先为根的子树的最小权之和。记当前枚举的点 $x$ 的状态为 $a$，点 $anc$ 的状态为 $b$，其中 $anc$ 为 $x$ 的 $2^k$ 辈祖先。于是可以通过下列式子处理出 $g$ 的每个状态的值：

$$
g[x,k,a,b]=\min
\begin{cases}
g[x,k-1,a,0]-f[anc,0]+g[anc,k-1,0,b]
\\
g[x,k-1,a,1]-f[anc,1]+g[anc,k-1,1,b]
\end{cases}
$$

链的情况：对于每组询问 $(a,x,b,y)$，不妨设深度更小的那个点为 $y$，从 $y$ 点开始向上跳到 $x$，再跳到 $1$ 号点，跳的过程中合并一下 $g$ 的值即可。非链的情况：按 $44$ 分做法。

**我会 $100$ 分！**我们发现，$68$ 分的做法已经极其接近正解，额外考虑一下 $a$ 点跳到 $\mathrm{lca}(a,b)$，$b$ 点跳到 $\mathrm{lca}(a,b)$ 的情况，其他情况和 $68$ 分做法基本相同。注意一下细节即可。

时间复杂度为 $O((n+q) \log n)$，能够通过本题。

```cpp
#include<cstdio>
typedef long long ll;
const ll inf=1e13;
int cnt=0;
ll f[100005][2],g[100005][19][2][2];
int a[100005],dep[100005],jump[100005][19];
int h[100005],to[200005],ver[200005];
inline int read() {
	register int x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f;
}
inline void swap(int &x,int &y) {int tmp=y;y=x;x=tmp;}
inline void add(int x,int y) {to[++cnt]=y;ver[cnt]=h[x];h[x]=cnt;} 
inline ll min(const ll &x,const ll &y) {return x<y? x:y;}
inline void dfs1(int x,int fa) {
	f[x][0]=0,f[x][1]=a[x]; 
	for(register int i=h[x];i;i=ver[i]) {
		int y=to[i]; if(y==fa) continue;
		dfs1(y,x);
		f[x][0]+=f[y][1];
		f[x][1]+=min(f[y][0],f[y][1]);
	}
}
inline void dfs2(int x) {
	for(register int i=1;i<=18;++i) {
		jump[x][i]=jump[jump[x][i-1]][i-1];
		int anc=jump[x][i-1];
		for(register int a=0;a<2;++a) {
			for(register int b=0;b<2;++b) {
				g[x][i][a][b]=min(g[x][i-1][a][0]-f[anc][0]+g[anc][i-1][0][b],g[x][i-1][a][1]-f[anc][1]+g[anc][i-1][1][b]);
			}
		}
	}
	for(register int i=h[x];i;i=ver[i]) {
		int y=to[i]; if(y==jump[x][0]) continue;
		dep[y]=dep[x]+1; jump[y][0]=x;
		g[y][0][0][0]=inf;
		g[y][0][0][1]=f[x][1]-min(f[y][0],f[y][1])+f[y][0];
		g[y][0][1][0]=f[x][0];
		g[y][0][1][1]=f[x][1]-min(f[y][0],f[y][1])+f[y][1];
		dfs2(y);
	}
}
inline ll Query(int x,int y,int v1,int v2) {
	 //1:x选 2:x不选 3:y选 4:y不选 
	if(dep[x]<dep[y]) swap(x,y),swap(v1,v2);//dep[x]>=dep[y]
	ll res[5]={0,(v1? f[x][1]:inf),(v1? inf:f[x][0]),(v2? f[y][1]:inf),(v2? inf:f[y][0])};
	ll tVal[5]={0,0,0,0,0};
	for(register int i=18;i>=0;--i) {
		if(dep[jump[x][i]]>=dep[y]) {
			tVal[1]=min(g[x][i][0][1]+res[2]-f[x][0],g[x][i][1][1]+res[1]-f[x][1]);
			tVal[2]=min(g[x][i][0][0]+res[2]-f[x][0],g[x][i][1][0]+res[1]-f[x][1]);
			res[1]=tVal[1]; res[2]=tVal[2]; x=jump[x][i];	
		}
	}
	if(x==y) {if(v2) res[2]=inf; else res[1]=inf;}
	//if(x==y) {printf("Surprise!\n"); return min(res[1],res[2]);}
	else {
		for(register int i=18;i>=0;--i) {
			if(jump[x][i]!=jump[y][i]) {
				tVal[1]=min(g[x][i][0][1]+res[2]-f[x][0],g[x][i][1][1]+res[1]-f[x][1]);
				tVal[2]=min(g[x][i][0][0]+res[2]-f[x][0],g[x][i][1][0]+res[1]-f[x][1]);
				tVal[3]=min(g[y][i][0][1]+res[4]-f[y][0],g[y][i][1][1]+res[3]-f[y][1]);
				tVal[4]=min(g[y][i][0][0]+res[4]-f[y][0],g[y][i][1][0]+res[3]-f[y][1]);
				res[1]=tVal[1]; res[2]=tVal[2]; res[3]=tVal[3]; res[4]=tVal[4]; x=jump[x][i]; y=jump[y][i];
			}
		}
		tVal[1]=f[jump[x][0]][1]-min(f[x][0],f[x][1])-min(f[y][0],f[y][1])+min(res[1],res[2])+min(res[3],res[4]);
		tVal[2]=f[jump[x][0]][0]-f[x][1]-f[y][1]+res[1]+res[3];
		res[1]=tVal[1]; res[2]=tVal[2]; x=jump[x][0];
//		Merge Left Subtree & Right Subtree
	}
	for(register int i=18;i>=0;--i) {
		if(dep[jump[x][i]]>=dep[1]) {
			tVal[1]=min(g[x][i][0][1]+res[2]-f[x][0],g[x][i][1][1]+res[1]-f[x][1]);
			tVal[2]=min(g[x][i][0][0]+res[2]-f[x][0],g[x][i][1][0]+res[1]-f[x][1]);
			res[1]=tVal[1]; res[2]=tVal[2]; x=jump[x][i];	
		}
	}
	return min(res[1],res[2]);
}
int main() {
	int n=read(),Q=read(); char s=getchar();
	while((s>='1'&&s<='3')||(s>='A'&&s<='C')) s=getchar();
	for(register int i=1;i<=n;++i) a[i]=read();
	for(register int i=1;i<n;++i) {int x=read(),y=read(); add(x,y); add(y,x);}
	dep[1]=1; dfs1(1,-1); dfs2(1);
	while(Q--) {
		int x=read(),v1=read(),y=read(),v2=read();
		if((jump[x][0]==y||jump[y][0]==x)&&!v1&&!v2) printf("-1\n");
		else printf("%lld\n",Query(x,y,v1,v2)); 
	}
	return 0;
}
```




---

## 作者：Genius_Star (赞：4)

### 思路：

注意到是动态求树上最小权覆盖集。

其等价于全集减去最大权独立集。

故考虑求出最大权独立集，考虑动态规划算法，设 $f_{i, 0/1}$ 表示 $i$ 子树内不选 $i$ 和选 $i$ 的最大权独立集的权值。

容易得到状态转移方程：

$$f_{i, 0} = \sum_{j \in son_i} \max(f_{j, 0}, f_{j, 1})$$

$$f_{i, 1} = a_i + \sum_{j \in son_i} f_{j, 0}$$

然后本题还有限制是必选/不能选某些点；若 $x$ 必选，则将 $x$ 的权值修改为 $-10^{10}$，否则修改为 $10^{10}$。

我们需要支持单点修改，查询 $\max(f_{1, 0}, f_{1, 1})$，朴素实现是 $O(nq)$ 的。

考虑重链剖分优化，设 $g_{i, 0}$ 表示对于 $i$ 的所有轻儿子可取可不取的最大独立集的权值，$g_{i, 1}$ 表示对于 $i$ 的所有轻儿子都不取的最大独立集的权值。

则状态转移方程优化为：

$$f_{i, 0} = g_{i, 0} + \max(f_{son_i, 0},f_{son_i, 1})$$

$$f_{i, 1} = a_i + g_{i, 1} + f_{son_i, 0}$$

发现这里多出来个 $a_i$ 很烦，考虑直接揉进 $g_{i, 1}$ 中（将定义改为取自己且所有轻儿子都不取的权值）。

容易发现我们进行单点修改，改变的 $g$ 只有每条重链顶端节点的父亲。

那么如何考虑求 $f$ 呢？

注意到：

$$f_{i, 0} = g_{i, 0} + \max(f_{son_i, 0},f_{son_i, 1})$$

$$f_{i, 1} = g_{i, 1} + f_{son_i, 0}$$

这个递推式子只和 $i$ 和 $son_i$ 相关，故考虑放到一条重链上去。

考虑使用广义的 $\max+$ 矩阵，即：

$$C_{i, j} = \max_{k = 1}^n A_{i, k} + B_{k, j}$$

容易证明其存在结合律。

故考虑由：

$$\begin{vmatrix} f_{son_i, 0} & f_{son_i, 1} \end{vmatrix} \times T_i = \begin{vmatrix} f_{i, 0} & f_{i, 1} \end{vmatrix}$$

由递推公式可以得到：

$$T_i = \begin{vmatrix} g_{i, 0} & g_{i, 1}\\ g_{i, 0} & -\inf\end{vmatrix}$$

故使用线段树维护区间矩阵的乘积，然后重链剖分即可。

时间复杂度为 $O(N \log^2 N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=100100,M=2,INF=1e17;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,m,X,Y,x,y,cnt,sum,ans;
ll a[N],dp[N][2],g[N][2],fa[N],p[N],t[N],z[N],d[N];
ll A[N],B[N],C[N];
vector<ll> E[N];
string s;
class Mat{
public:
	ll a[M][M];
	ll* operator[](ll i){
		return a[i];
	}
	Mat(){
        for(int i=0;i<M;i++)
          for(int j=0;j<M;j++)
            a[i][j]=-INF;
	}
    Mat operator*(Mat rhs)const{
		Mat ans;
		for(int i=0;i<M;i++)
		  for(int j=0;j<M;j++)
		    for(int k=0;k<M;k++)
		      ans[i][j]=max(ans[i][j],a[i][k]+rhs[k][j]);
		return ans;
	}
    Mat operator+(Mat rhs)const{
		Mat ans;
		for(int i=0;i<M;i++)
		  for(int j=0;j<M;j++)
		    ans[i][j]=max(a[i][j],rhs[i][j]);
		return ans;
	}
}H[N];
class Tree{
public:
	struct Node{
		ll l,r;
		Mat data;
	}X[N<<2];
	void pushup(ll k){
		X[k].data=X[k<<1].data*X[k<<1|1].data;
	}
	void build(ll k,ll l,ll r){
		X[k].l=l,X[k].r=r;
		if(l==r){
			X[k].data[0][0]=X[k].data[0][1]=g[B[l]][0];
			X[k].data[1][0]=g[B[l]][1];
			H[l]=X[k].data;
			return ;
		}
		ll mid=(l+r)>>1;
		build(k<<1,l,mid);
		build(k<<1|1,mid+1,r);
		pushup(k);
	}
	void add(ll k,ll i){
		if(X[k].l==i&&i==X[k].r){
//			puts("-1");
			X[k].data=H[i];
			return ;
		}
		ll mid=(X[k].l+X[k].r)>>1;
		if(i<=mid)
		  add(k<<1,i);
		else
		  add(k<<1|1,i);
		pushup(k);
	}
	Mat qurey(ll k,ll l,ll r){
		if(X[k].l==l&&r==X[k].r)
		  return X[k].data;
		ll mid=(X[k].l+X[k].r)>>1;
		if(r<=mid)
		  return qurey(k<<1,l,r);
		else if(l>mid)
		  return qurey(k<<1|1,l,r);
		else
		  return qurey(k<<1,l,mid)*qurey(k<<1|1,mid+1,r);
	}
	Mat qurey(ll u){
		return qurey(1,A[u],C[u]);
	}
}T;
void add(ll u,ll v){
	E[u].push_back(v);
	E[v].push_back(u);
}
void dfs1(ll u,ll f){
	dp[u][1]=a[u];
	p[u]=1;
	for(auto v:E[u]){
		if(v==f)
		  continue;
		fa[v]=u;
		d[v]=d[u]+1;
		dfs1(v,u);
		dp[u][0]+=max(dp[v][0],dp[v][1]);
		dp[u][1]+=dp[v][0]; 
		p[u]+=p[v];
		if(p[v]>p[z[u]])
		  z[u]=v;
	}
}
void dfs2(ll u,ll k){
	g[u][1]=a[u];
	A[u]=++cnt;
	B[cnt]=u;
	C[k]=max(C[k],cnt);
	t[u]=k;
	if(!z[u])
	  return ;
	dfs2(z[u],k);
	for(auto v:E[u]){
		if(v==fa[u]||v==z[u])
		  continue;
		dfs2(v,v);
		g[u][0]+=max(dp[v][0],dp[v][1]);
		g[u][1]+=dp[v][0];
	}
}
void updata(ll u,ll v){
	Mat x,y;
	H[A[u]][1][0]+=v;
	a[u]+=v;
	while(u){
		x=T.qurey(t[u]);
		T.add(1,A[u]);
		y=T.qurey(t[u]);
		u=fa[t[u]];
		H[A[u]][0][0]+=max(y[0][0],y[1][0])-max(x[0][0],x[1][0]);
		H[A[u]][0][1]=H[A[u]][0][0];
		H[A[u]][1][0]+=y[0][0]-x[0][0];
//		cerr<<H[A[u]][0][0]<<' '<<H[A[u]][0][1]<<' '<<H[A[u]][1][0]<<'\n';
	}
}
int main(){
	n=read(),m=read(),cin>>s;
	for(int i=1;i<=n;i++){
		a[i]=read();
		ans+=a[i];
	}
	for(int u,v,i=1;i<n;i++){
		u=read(),v=read();
		add(u,v);
	}
	dfs1(1,1);
	dfs2(1,1);
	T.build(1,1,cnt);
//	for(int i=1;i<=n;i++){
//		write(B[i]);
//		putchar(' ');
//	}
//	putchar('\n');
	while(m--){
		X=read(),x=read(),Y=read(),y=read();
        if((fa[X]==Y||fa[Y]==X)&&!x&&!y){
            puts("-1");
            continue;
        }
		updata(X,x?-1e10:1e10);
		updata(Y,y?-1e10:1e10);
		auto t=T.qurey(1);
		sum=ans-max(t[0][0],t[1][0])+(x?0:1e10)+(y?0:1e10);
        write(sum);
        putchar('\n');
        updata(X,x?1e10:-1e10);
		updata(Y,y?1e10:-1e10);
	}
	return 0;
}
```

这是一年前写的 code 了，码风可能有点不好看，见谅。

---

## 作者：Mirasycle (赞：3)

分析题意，要求的是最小覆盖集就等价于全集减去最大独立集。直接求解最大独立集即可。

首先是不带修改版本，$f_{u,0/1}$ 分别表示选或者不选 $u$ 点。

$$f_{u,0}=\sum\limits_{v} \max\{f_{v,0},f_{v,1}\}$$
$$f_{u,1}=\sum f_{v,0}+a_u$$
 
对于强制选择/不选，就是将点权设置为 $\infty$ 或者 $-\infty$。


我们发现对于每次修改一个点改的只是一条链上面的结果，于是我们可以采用重链剖分。如果能快速在重链上面转移，那么只需要跳 $\log$ 次重链就可以修改出结果了。

考虑使用支持快速对于重链修改的方程，增加一个表示 $g_{u,0/1}$ 分别表示**轻儿子**可选可不选或者全部不选。

$$f_{u,0}=g_{u,0}+\max(f_{son,0},f_{son,1})$$
$$f_{u,1}=g_{u,1}+a_u+f_{son,0}$$

令 $g_{u,1} \gets g_{u,1}+a_u$，于是有 $f_{u,1}=g_{u,1}+f_{son,0}$。
$$\begin{bmatrix}g_{u,0}&g_{u,0}
\\g_{u,1}&-\infty
\end{bmatrix}\begin{bmatrix}f_{son,0}
\\f_{son,1}
\end{bmatrix}=\begin{bmatrix} f_{u,0}
\\f_{u,1}
\end{bmatrix}$$

这是一个方便在重链上转移的方程，对于重链上某点其 $f$ 数组只需要链末尾到该点一路上 $g$ 数组的乘积，乘以链末尾的 $f$ 数组就行了。轻重链交界处，我们需要单独修改一次 $g$ 就行了，这种情况只会出现 $\log$ 次。

矩阵具有结合律，因此可以直接用线段树维护区间矩阵积就行了。

同时，我们发现重链链尾也就是叶子节点上 $f$ 与 $g$ 相等，所以后续维护不需要维护 $f$ 了， 直接用 $g$ 往上乘就行了。


使用树剖，时间复杂度 $O(n\log^2 n)$。

上述算法常数很大。可以使用全局平衡二叉树更快，全局平衡二叉树就是 LCT 的静态版本。

使用重链剖分之后，对于每个重链开一个平衡树来维护。

对于每条重链建立 BST 的过程就是你设一个点的权值为轻子树大小之和，每次找到带权中间分裂开建立左右儿子就行了。

处理链信息的时候比树剖快，这个是单 $\log$ 的。

树链剖分版本。


```cpp
//矩阵转移部分 
struct Matrix{
	int mat[2][2];
	void init(){ memset(mat,INF,sizeof(mat)); }
	void init1(){ memset(mat,0,sizeof(mat)); }
	Matrix operator * (const Matrix &rhs) const {
		Matrix res; res.init();
		for(int i=0;i<2;i++)
			for(int j=0;j<2;j++)
				for(int k=0;k<2;k++) chm(res.mat[i][j],mat[i][k]+rhs.mat[k][j]);
		return res;
	}
	void prework(int i,int x){
		init(); f[i][0]=0; f[i][1]=x;
		mat[0][0]=mat[0][1]=0; mat[1][0]=x; 
	}
	void update(int u,int v,int t){
		f[u][0]+=max(f[v][0],f[v][1]);
		f[u][1]+=f[v][0];
		if(!t) return ; mat[1][0]+=f[v][0];
		mat[0][0]+=max(f[v][0],f[v][1]); mat[0][1]+=max(f[v][0],f[v][1]);
	}
}M[maxn];

//线段树 
struct SegmentTree{
	struct Tree{
		int l,r; Matrix mat;
		#define l(x) tree[x].l
		#define r(x) tree[x].r
		#define mat(x) tree[x].mat
	}tree[maxn<<2];
	void build(int p,int l,int r){
		l(p)=l; r(p)=r;
		if(l==r){ mat(p)=M[id[l]]; return ; }
		int mid=(l+r)>>1;
		build(lc,l,mid); build(rc,mid+1,r);
		mat(p)=mat(lc)*mat(rc); 
	}
	Matrix query(int p,int ql,int qr){
		if(ql<=l(p)&&r(p)<=qr) return mat(p);
		int mid=(l(p)+r(p))>>1;
		if(qr<=mid) return query(lc,ql,qr);
		else if(ql>mid) return query(rc,ql,qr);
		else return query(lc,ql,qr)*query(rc,ql,qr);
	}
	void update(int p,int pos){
		if(l(p)==r(p)){ mat(p)=	M[id[pos]]; return ; }
		int mid=(l(p)+r(p))>>1;
		if(pos<=mid) update(lc,pos);
		else update(rc,pos);
		mat(p)=mat(lc)*mat(rc);
	}
}Seg;

//重链剖分 
struct chain_part{
	int son[maxn],dfn[maxn],fa[maxn];
	int top[maxn],lst[maxn],tot;
	void dfs1(int u,int father){
		sz[u]=1; fa[u]=father; son[u]=0;
		for(auto v:G[u]){
			if(v==fa[u]) continue;
			dfs1(v,u); sz[u]+=sz[v];
			if(sz[v]>sz[son[u]]) son[u]=v;
		}
	}
	void dfs2(int u,int Top){
		dfn[u]=++tot; id[tot]=u; top[u]=Top; lst[Top]=tot;
		if(son[u]){ dfs2(son[u],Top); M[u].update(u,son[u],0); }
		for(auto v:G[u]){
			if(v==fa[u]||v==son[u]) continue;
			dfs2(v,v); M[u].update(u,v,1);
		}
	}
	void update(int u,int x){
		M[u].mat[1][0]+=x-a[u]; a[u]=x;
		while(u){
			Matrix old=Seg.query(1,dfn[top[u]],lst[top[u]]);
			Seg.update(1,dfn[u]); 
			Matrix New=Seg.query(1,dfn[top[u]],lst[top[u]]);
			u=fa[top[u]];
			M[u].mat[1][0]+=New.mat[0][0]-old.mat[0][0];
			M[u].mat[0][0]+=max(New.mat[0][0],New.mat[1][0])-max(old.mat[0][0],old.mat[1][0]);
			M[u].mat[0][1]=M[u].mat[0][0];
		}
	}
	void init(){ sz[tot=0]=0; dfs1(1,0); dfs2(1,1); }
}chain;
```

全局平衡二叉树版本。


```cpp
//矩阵转移部分 
struct Matrix{
	int mat[2][2];
	void init(){ memset(mat,INF,sizeof(mat)); }
	void init1(){ memset(mat,INF,sizeof(mat)); mat[0][0]=mat[1][1]=0; }
	inline Matrix operator * (const Matrix &rhs) const {
		Matrix res; res.init();
		for(int i=0;i<2;i++)
			for(int j=0;j<2;j++)
				for(int k=0;k<2;k++) chm(res.mat[i][j],mat[i][k]+rhs.mat[k][j]);
		return res;
	}
	void prework(int i,int x){
		init(); f[i][0]=0; f[i][1]=x;
		mat[0][0]=mat[0][1]=0; mat[1][0]=x; 
	}
	void update(int u,int v,int t){
		f[u][0]+=max(f[v][0],f[v][1]); f[u][1]+=f[v][0];
		if(!t) return ;
		mat[0][0]+=max(f[v][0],f[v][1]); mat[0][1]+=max(f[v][0],f[v][1]); mat[1][0]+=f[v][0];
	}
}M[maxn],mul[maxn];

//重链剖分 
struct chain_part{
	int son[maxn],dfn[maxn],fa[maxn];
	int lst[maxn],tot;
	void dfs1(int u,int father){
		sz[u]=1; fa[u]=father; son[u]=0;
		for(auto v:G[u]){
			if(v==fa[u]) continue;
			dfs1(v,u); sz[u]+=sz[v];
			if(sz[v]>sz[son[u]]) son[u]=v;
		}
	}
	void dfs2(int u,int Top){
		dfn[u]=++tot; id[tot]=u; top[u]=Top; 
		lst[Top]=tot; sum[tot]=sz[u]-sz[son[u]];
		if(son[u]){ dfs2(son[u],Top); M[u].update(u,son[u],0); }
		for(auto v:G[u]){
			if(v==fa[u]||v==son[u]) continue;
			dfs2(v,v); M[u].update(u,v,1);
		}
	}
	void init(){
		sz[tot=0]=0; mul[0].init1();
		dfs1(1,0); dfs2(1,1); 
	}
}chain;

//平衡树 
struct BST{
	int fa[maxn],ls[maxn],rs[maxn];
	void pushup(int u){ mul[u]=mul[ls[u]]*M[u]*mul[rs[u]]; }
	int build(int l,int r){
		if(l>r) return 0;
		if(l==r){ mul[id[l]]=M[id[l]]; return id[l]; }
		int u=lower_bound(sum+l,sum+r+1,(sum[l-1]+sum[r]+1)>>1)-sum; int x=id[u];
		ls[x]=build(l,u-1); rs[x]=build(u+1,r);
		fa[ls[x]]=x; fa[rs[x]]=x; pushup(x);
		return x;
	}
	void update(int &u,int val){
		M[u].mat[1][0]+=val-a[u]; a[u]=val; pushup(u);
		while(fa[u]){
			if(u==ls[fa[u]]||u==rs[fa[u]]) pushup(u=fa[u]);
			else{
				M[fa[u]].mat[0][0]-=max(f[top[u]][0],f[top[u]][1]); M[fa[u]].mat[1][0]-=f[top[u]][0];
				f[top[u]][0]=max(mul[u].mat[0][0],mul[u].mat[0][1]); f[top[u]][1]=max(mul[u].mat[1][0],mul[u].mat[1][1]);
				M[fa[u]].mat[0][0]+=max(f[top[u]][0],f[top[u]][1]); M[fa[u]].mat[1][0]+=f[top[u]][0];
				M[fa[u]].mat[0][1]=M[fa[u]].mat[0][0];
				pushup(u=fa[u]);
			}
		}
	}
}bst;
```

---

## 作者：Error114 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P5024)  
## 题目解法  
朴素的 dp 很简单，略过。  
考虑倍增  
每次修改只会修改两个点 $u , v$ 的祖先的 dp 值。  
考虑维护转移矩阵，$Mat_u$ 表示 $fa_u$ 从不包括 $u$ 的其他儿子转移而来的转移矩阵。  
这样定义有 $2$ 个好处：
1. 可以更方便修改，只需要修改 $2$ 条链上的 dp 值即可。
2. 可以进行倍增，若 $u$ 是 $v$ 的祖先，那么 dp 矩阵 $f_u=Mat_u\to_u\times_u$，其中 $Mat_u\to_u$ 表示转移矩阵的乘积（另外一提，$\min$ 加矩阵满足结合律，但不满足交换律，所以写倍增时一定要当心矩乘顺序）。

之后简单了，维护 $Mat_{u,i}$ 表示从 $u$ 往上走 $2^i$ 步的转移矩阵的乘积。
然后对于 $a,b$ 分类讨论，以下假设 $depth_u\le depth_u$。
1. $u$ 是 $v$ 的祖先，具体过程不细说，直接上代码：
```cpp
Matrix cur=f[b];cur.a[y^1][0]=inf; 
for(int i=18;i>=0;i--) if(depth[up[b][i]]>=depth[lca]) cur=trans[b][i]*cur,b=up[b][i];
cur.a[x^1][0]=inf;
for(int i=18;i>=0;i--) if(depth[up[b][i]]) cur=trans[b][i]*cur,b=up[b][i];
```
2. 反之，对于 $u,v$ 分别维护到 lca 的 dp 值 lca 出手动转一下，上面直接倍增，代码：
```cpp
Matrix cur1;cur1=f[a],cur1.a[x^1][0]=inf;
for(int i=18;i>=0;i--) if(depth[up[a][i]]>depth[lca]) cur1=trans[a][i]*cur1,a=up[a][i];
cur1=trans[a][0]*cur1;
Matrix cur2;cur2=f[b],cur2.a[y^1][0]=inf;
for(int i=18;i>=0;i--) if(depth[up[b][i]]>depth[lca]) cur2=trans[b][i]*cur2,b=up[b][i];
Matrix cur;cur.n=2,cur.m=1,cur.a[0][0]=cur1.a[0][0]-f[b].a[1][0]+cur2.a[1][0];
cur.a[1][0]=cur1.a[1][0]-min(f[b].a[0][0],f[b].a[1][0])+min(cur2.a[0][0],cur2.a[1][0]);
for(int i=18;i>=0;i--) if(depth[up[lca][i]]) cur=trans[lca][i]*cur,lca=up[lca][i];
```
## Code
时间复杂度 $O(2^3n\log n)$。
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N(100100),inf(1e15);
struct Matrix{ int n,m,a[2][2];};
Matrix operator *(const Matrix &A,const Matrix &B){
	Matrix C;C.n=A.n,C.m=B.m;C.a[0][0]=C.a[0][1]=C.a[1][0]=C.a[1][1]=inf;
	for(int i=0;i<C.n;i++) for(int j=0;j<C.m;j++)
		for(int k=0;k<A.m;k++) C.a[i][j]=min(C.a[i][j],A.a[i][k]+B.a[k][j]);
	return C;
}
int n,m,p[N],depth[N],up[N][20];
Matrix trans[N][20],f[N];
char type[2];
int e[N<<1],ne[N<<1],h[N],idx;
inline int read(){
	int FF=0,RR=1;
	char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') RR=-1;
	for(;isdigit(ch);ch=getchar()) FF=(FF<<1)+(FF<<3)+ch-48;
	return FF*RR;
}
void add(int x,int y){ e[idx]=y,ne[idx]=h[x],h[x]=idx++;}
void dfs(int u,int fa){
	auto &t=f[u];t.n=2,t.m=1;
	t.a[0][0]=0,t.a[1][0]=p[u],depth[u]=depth[fa]+1;
	for(int i=h[u];~i;i=ne[i]){
		int v=e[i];
		if(v!=fa){
			up[v][0]=u,dfs(v,u);
			t.a[0][0]+=f[v].a[1][0],t.a[1][0]+=min(f[v].a[0][0],f[v].a[1][0]);
		}
	}
}
int get_lca(int x,int y){
	for(int i=18;i>=0;i--) if(depth[up[y][i]]>=depth[x]) y=up[y][i];
	if(x==y) return x;
	for(int i=18;i>=0;i--) if(up[x][i]!=up[y][i]) x=up[x][i],y=up[y][i];
	return up[x][0];
}
signed main(){
	n=read(),m=read(),scanf("%s",type);
	for(int i=1;i<=n;i++) p[i]=read();
	memset(h,-1,sizeof(h));
	for(int i=1;i<n;i++){
		int u=read(),v=read();
		add(u,v),add(v,u);
	} 
	dfs(1,0);
	for(int i=1;i<=n;i++){
		auto &t=trans[i][0];t.n=t.m=2;
		t.a[0][0]=inf,t.a[0][1]=f[up[i][0]].a[0][0]-f[i].a[1][0],t.a[1][0]=t.a[1][1]=f[up[i][0]].a[1][0]-min(f[i].a[0][0],f[i].a[1][0]);
	for(int j=1;j<=18;j++) for(int i=1;i<=n;i++){
		up[i][j]=up[up[i][j-1]][j-1];
		trans[i][j]=trans[up[i][j-1]][j-1]*trans[i][j-1];
	}
	while(m--){
		int a=read(),x=read(),b=read(),y=read();
		if(depth[a]>depth[b]) swap(a,b),swap(x,y); 
		int lca=get_lca(a,b);
		if(lca==a){
			Matrix cur=f[b];cur.a[y^1][0]=inf; 
			for(int i=18;i>=0;i--) if(depth[up[b][i]]>=depth[lca]) cur=trans[b][i]*cur,b=up[b][i];
			cur.a[x^1][0]=inf;
			for(int i=18;i>=0;i--) if(depth[up[b][i]]) cur=trans[b][i]*cur,b=up[b][i];
			if(min(cur.a[0][0],cur.a[1][0])>=inf) puts("-1");
			else printf("%lld\n",min(cur.a[0][0],cur.a[1][0]));
		}
		else{
			Matrix cur1;cur1=f[a],cur1.a[x^1][0]=inf;
			for(int i=18;i>=0;i--) if(depth[up[a][i]]>depth[lca]) cur1=trans[a][i]*cur1,a=up[a][i];
			cur1=trans[a][0]*cur1;
			Matrix cur2;cur2=f[b],cur2.a[y^1][0]=inf;
			for(int i=18;i>=0;i--) if(depth[up[b][i]]>depth[lca]) cur2=trans[b][i]*cur2,b=up[b][i];
			Matrix cur;cur.n=2,cur.m=1,cur.a[0][0]=cur1.a[0][0]-f[b].a[1][0]+cur2.a[1][0];
			cur.a[1][0]=cur1.a[1][0]-min(f[b].a[0][0],f[b].a[1][0])+min(cur2.a[0][0],cur2.a[1][0]);
			for(int i=18;i>=0;i--) if(depth[up[lca][i]]) cur=trans[lca][i]*cur,lca=up[lca][i];
			if(min(cur.a[0][0],cur.a[1][0])>=inf) puts("-1");
			else printf("%lld\n",min(cur.a[0][0],cur.a[1][0]));
		}
	}
	return 0;
}
```
作者语：代码仅供参考，不要抄哦。

---

## 作者：我梦见一片焦土 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P5024)

---

# 思路：

我们可以通过树形 ```DP``` 在线性时间内求出一个点 $u$ 如果颜色为 $c$，那么整棵树的最小代价为 $f_{u,c}$，具体的做法就是先从下往上树形 ```DP``` 得出点 $u$ 如果选 $c$ 这个颜色的话整个子树中的最小代价为 $dp1_{u,c}$，然后从上往下 ```DP``` 得出点 $u$ 的父亲如果选 $c$ 这个颜色的话，以 $u$ 为根 $u$ 父亲子树中的最小代价为 $dp2_{u,c}$。

发现如果固定两个点 $u,v$ 的颜色分别为 $c,d$，那么就应该对于树上 $u$ 到 $v$ 路径上（不包含 $u$ 和 $v$）的每一个点分别考虑是否染黑。

因为 $dp$ 信息是可减的，所以如果那条链上的染色的方案已经确定下来了，我们容易算出总代价：考虑路径上从上往下连续的三个点 $u,v,w$ 颜色为 $c$ ，那么 $v$ 的贡献就是 $f_{v,c}-dp1_{w,d}-dp2_{v,d}$，其中 $d$ 表示能够和 $c$ 相临的颜色。我们把这个贡献算在 $(u,v)$ 这条边上。

考虑如何确定最优的链上染色方案。对于树上从上往下的两条链，其中一条链顶端的父亲是另一条链的底端，我们要合并这两条链的信息。发现 ```DP``` 转移只和链的两端的颜色有关，所以对于一条链只需记录它两边是否染黑即可。合并的时候枚举相邻两点的颜色，如果不全为 $0$ 则合法。

于是，我们考虑倍增。令 $g_{i,j,k}$ 表示 $i$ 点向上长度为 $2^j$ 的链，顺序为从下往上或者从上往下的 $DP$ 值。这样就可以通过倍增转移，询问时像查询 ```LCA``` 一样查询即可。时间复杂度 $O((n+q)\log n)$。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=2e5+10;
const int INF=0x3f3f3f3f3f3f3f3f3f3f3f3f;
int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-'){
            f=-1;
        }
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
void write(int x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9){
        write(x/10);
    }
    putchar(x%10+'0');
    return;
}
int n,m,a[N],tot,tr[N],nt[N],lk[N],dep[N],cnt,l[N],r[N],fa[N][19],dp1[N][2],dp2[N][2],f[N][2];
string ss;
struct node{
    int dp[2][2];
    node(){ 
        dp[0][0]=dp[0][1]=dp[1][0]=dp[1][1]=INF;
    }
    int gm(){
        int ans=INF;
        for(int i=0;i<2;i++){
            for(int j=0;j<2;j++){
                ans=min(ans,dp[i][j]);
            }
        }
        return ans;
    }
    friend node merge(const node &a,const node &b){
        node c;
        for(int i=0;i<2;i++){
            for(int j=0;j<2;j++){
                for(int k=0;k<2;k++){
                    for(int l=0;l<2;l++){
                        if(k||l){
                            c.dp[i][j]=min(c.dp[i][j],a.dp[i][k]+b.dp[l][j]);
                        }
                    }
                }
            }
        }
        return c;
    }
}g[N][20][2];
void add(int u,int v){
    tr[++tot]=v;
    nt[tot]=lk[u];
    lk[u]=tot;
}
void dfs1(int u,int p){
    dp1[u][1]=a[u];
    for(int e=lk[u],v;e;e=nt[e]){
        if((v=tr[e])==p){
            continue;
        }
        dfs1(v,u);
        dp1[u][0]+=dp1[v][1];
        dp1[u][1]+=min(dp1[v][0],dp1[v][1]);
    }
}
void dfs2(int u,int p){
    for(int e=lk[u],v;e;e=nt[e]){
        if((v=tr[e])==p){
            continue;
        }
        dp2[v][0]=dp2[u][1]+dp1[u][0]-dp1[v][1];
        dp2[v][1]=min(dp2[u][0],dp2[u][1])+dp1[u][1]-min(dp1[v][0],dp1[v][1]);
        dfs2(v,u);
    }
    f[u][0]=dp2[u][1];
    f[u][1]=a[u]+min(dp2[u][0],dp2[u][1]);
    for(int e=lk[u],v;e;e=nt[e]){
        if((v=tr[e])==p){
            continue;
        }
        f[u][0]+=dp1[v][1];
        f[u][1]+=min(dp1[v][0],dp1[v][1]);
    }
}
void dfs3(int u,int p){
    dep[u]=dep[p]+1;
    fa[u][0]=p;
    l[u]=r[u]=++cnt;
    int A=f[p][0]-dp1[u][1]-dp2[p][1],B=f[p][1]-min(dp1[u][0],dp1[u][1])-min(dp2[p][0],dp2[p][1]);
    g[u][0][0].dp[0][0]=A;
    g[u][0][0].dp[1][1]=B;
    g[u][0][1].dp[0][0]=A;
    g[u][0][1].dp[1][1]=B;
    for(int i=0,t;(t=fa[fa[u][i]][i]);i++){
        fa[u][i+1]=t;
        g[u][i+1][0]=merge(g[u][i][0],g[fa[u][i]][i][0]);
        g[u][i+1][1]=merge(g[fa[u][i]][i][1],g[u][i][1]);
    }
    for(int e=lk[u],v;e;e=nt[e]){
        if((v=tr[e])==p)continue;
        dfs3(v,u),r[u]=r[v];
    }
}
int solve(int u,int a,int v,int b){
    if(dep[u]>dep[v]){
        swap(u,v);
        swap(a,b);
    }
    node A,B;
    B.dp[b][b]=f[v][b]-(!b?dp2[v][1]:min(dp2[v][0],dp2[v][1]));
    if(l[u]<=l[v]&&l[v]<=r[u]){
        int df=dep[v]-dep[u]-1;
        for(int i=0;i<=16;i++){
            if(df>>i&1){
                B=merge(g[v][i][1],B);
                v=fa[v][i];
            }
        }
        A.dp[a][a]=f[u][a]-(!a?dp1[v][1]:min(dp1[v][0],dp1[v][1]));
        return merge(A,B).gm();
    }
    A.dp[a][a]=f[u][a]-(!a?dp2[u][1]:min(dp2[u][0],dp2[u][1]));
    int df=dep[v]-dep[u];
    for(int i=0;i<=16;i++){
        if(df>>i&1){
            B=merge(g[v][i][1],B);
            v=fa[v][i];
        }
    }
    if(!(fa[u][0]==fa[v][0])){
        for(int i=16;~i;i--){
            if(fa[u][i]!=fa[v][i]){
                A=merge(A,g[u][i][0]);
                B=merge(g[v][i][1],B);
                u=fa[u][i],v=fa[v][i];
            }
        }
    }
    node C;
    int x=fa[u][0];
    C.dp[0][0]=f[x][0]-dp1[u][1]-dp1[v][1];
    C.dp[1][1]=f[x][1]-min(dp1[u][0],dp1[u][1])-min(dp1[v][0],dp1[v][1]);
    return merge(A,merge(C,B)).gm();
}
signed main(){
    cin>>n>>m>>ss;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int i=1,u,v;i<n;i++){
        cin>>u>>v;
        add(u,v);
        add(v,u);
    }
    dfs1(1,0);
    dfs2(1,0);
    dfs3(1,0);
    while(m--){
        int a,x,b,y;
        cin>>a>>x>>b>>y;
        int ans=solve(a,x,b,y);
        if(ans==INF){
            cout<<-1<<endl;
        }else{
            cout<<ans<<endl;
        }
    }
    return 0;
}
```
完结撒花~

---


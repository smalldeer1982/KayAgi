# 数列游戏

## 题目背景

此题为改编题，特别鸣谢倪星宇同学。

有一次，HKE和LJC在玩一个游戏。


## 题目描述

游戏的规则是这样的：LJC在纸上写下两个长度均为N的数列A和B，两个数列一一对应。HKE每次可以找两个相邻的数A[i]和A[i+1]，如果它们两个不互质，HKE可以选择得到(B[i]+B[i+1])分，然后擦掉A和B位置上的第i,i+1个数，并把两个序列重新按顺序编号。当所有相邻的数互质时，游戏结束。

HKE想知道他最大得分是多少。


## 说明/提示

对于30%的数据，N ≤ 20；

对于60%的数据，N ≤ 100；

对于80%的数据，N ≤ 500

对于100%的数据，N ≤ 800, 1 ≤ Ai, Bi ≤ 10^9。


## 样例 #1

### 输入

```
6
9 8 6 5 6 3
11 19 12 17 18 15```

### 输出

```
64
//解释：擦去A[2],A[3]与A[5],A[6]，得分为64```

# 题解

## 作者：DevilsFlame (赞：4)

一眼典型区间 dp。

关于擦除和得分，我们难想到动归式子：```f[i][j] = max(f[i][j],f[i][k] + f[k + 1][j])```。可是难点就在于擦除条件。于是草草写下这行代码：
```cpp
if((i + 1 == j || p[i + 1][j - 1]) && check(a[i],a[j]))
{
	p[i][j] = 1;
	f[i][j] = f[i + 1][j - 1] + b[i] + b[j];
	continue;
}
```
不难发现，这漏了情况。这里主要难的就是擦除条件。  
可是，也是有单调性。```f[i][i + 1]``` 是可以确定的，那么 ```f[i][i + 2] = max(f[i][i + 1],f[i + 1][i + 2])```，但这是奇数的情况。那如果是 ```f[1][4]```？

满足可以让 ```f[1][4]``` 完全擦除的有 $2$ 种情况：
1. ```f[1][2] && f[3][4]```  
2. ```f[2][3] && gcd(a[1],a[4]) != 1```  
一旦完全擦除，那么这一区间肯定就是最大值。
可以用 ```bool``` 数组判断区间是否完全擦除。
```cpp
#include<bits/stdc++.h>
#define N 805
using namespace std;
long long n,a[N],b[N],f[N][N];
bool g[N][N];//判断该区间是否可擦除 
int gcd(int a,int b)
{
	if(b == 0) return a;
	return gcd(b,a % b);
}
inline bool check(int a,int b)//是否满足提议要求
{
	if(gcd(a,b) == 1) return 0;
	return 1;
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin >> n;
	for(int i = 1;i <= n;i ++) cin >> a[i];
	for(int i = 1;i <= n;i ++) cin >> b[i];
	for(int t = 1;t < n;t ++)//枚举长度(t + 1)
		for(int i = 1;i + t <= n;i ++)//区间左端点
		{
			int j = i + t;//右端点 = i + t
			if(check(a[i],a[j]) && (i + 1 == j || g[i + 1][j - 1]))
            //如果(j - i + 1)是奇数，那么 g[i + 1][j - 1] 肯定为 0 
			{
				g[i][j] = 1;
				f[i][j] = f[i + 1][j - 1] + b[i] + b[j];
				continue;
			}
			for(int k = i;k < j;k ++)//枚举界点
			{
				f[i][j] = max(f[i][k] + f[k + 1][j],f[i][j]);
				if(g[i][k] && g[k + 1][j])//该区间可擦除（分段擦除，例如 2 4 9 15）
				{
					g[i][j] = 1;
					break;
				}
			}
		}
	cout << f[1][n] << endl;
	return 0;
}
```
该算法不是最优，但很简单易懂，时间复杂度为 $O(n^3)$。

---

## 作者：破忆 (赞：4)

## 【题意】
每次可以找两个数$A_i$和$A_j$，如果$i$和$j$之间的数已经被删完，并且它们两个不互质，就可以删掉$A_i$和$A_j$并得到$B_i+B_j$分。

## 【分析】
不难看出这是区间DP

问题关键在于判断$[L,R]$能否全部删去

删去$[L,R]$大体上有两种方式

先删去$[L+1,R-1]$，再删去$A_L$和$A_R$,前提是$A_L$与$A_R$不互质

存在$L+1<=k<=R-2$，使得$[L,k]$和$[k+1,R]$都能被删除

设$f[L][R]$表示$[L,R]$是否能被删除

对应的转移方程分别是

$f[L][R]|=f[L+1][R-1]$

$f[L][R]|=f[L][k]* f[k+1][R]$

再设$g[i]$表示前i个数的最大分数,$s$是$B$的前缀和

$g[i]=max(g[i],g[j-1]-s[j-1]+s[i])$

$g[i]=max(g[i],g[i-1])$

最后记得开$longlong$

## 【算法】
区间DP
## 【代码】
```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int maxn=805;
const LL INF=1ll<<60;
int n;
int a[maxn],b[maxn];
bool f[maxn][maxn];
LL g[maxn],s[maxn];
int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
int gcd(int x,int y){
	return !y?x:gcd(y,x%y);
}
int main(){
	freopen("P5154.in","r",stdin);
	freopen("P5154.out","w",stdout);
	n=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<=n;i++) b[i]=read(),s[i]=s[i-1]+b[i];
	for(int i=1;i<n;i++) f[i][i+1]=gcd(a[i],a[i+1])!=1;
	for(int len=3;len<=n;len++)
	for(int L=1;L+len-1<=n;L++){
		int R=L+len-1;
		if(len>3&&gcd(a[L],a[R])!=1) f[L][R]|=f[L+1][R-1];
		for(int k=L+1;k+2<=R;k++) f[L][R]|=f[L][k]*f[k+1][R];
	}
	
	for(int i=1;i<=n;i++){
		g[i]=g[i-1];
		for(int j=1;j<=i;j++)
		if(f[j][i]) g[i]=max(g[i],g[j-1]-s[j-1]+s[i]);
	}
	printf("%lld\n",g[n]);
	return 0;
}
```


---

## 作者：qwaszx (赞：3)

好题

区间$dp$，设$f[i][j]$表示能否把$[i,j]$上的数全取走.

转移分两种情况:先取中间再取两段，$f[i][j]|=f[i+1][j-1]\&\& \gcd(a[i],a[j])\neq 1$；

否则把区间拆成两段，$f[i][j]|=f[i][k]\&\&f[k+1][j]$

初值$f[i][i+1]=[\gcd(a[i],a[i+1])\neq 1]$

$O(n^3+n^2\log w)$

代码可以看其他题解

看了看最优解的代码，发现了一些更优秀的做法

转移方程没有变，不同的是我们从大到小枚举左端点$i$，然后枚举右端点$j$，如果$f[i+1][j-1]$并且$\gcd(a[i],a[j])\neq 1$那么从$i$向$j+1$连边，表示一个可行的转移.

接下来对$i$进行$dfs$，区间$[i,k]$是可行的如果存在一个$j$使得$[i,j]\&\&[j+1,k]$可行，换句话说它可以拆成若干个可行区间的并.于是我们进行一次$dfs$，找出所有可行的$k$，代码如下:

```cpp
void dfs(int u,int root)
{
	for(int i=fst[u];i;i=nxt[i])//枚举所有使得[u,v-1]可行的v
	{
		int v=to[i];
		if(!f[root][v-1])f[root][v-1]=1,dfs(v,root);//如果没有遍历过就遍历，否则说明已经扩展过了.
	}
}
```

这样减少了大量的无用转移.复杂度的话可以考虑每一个右端点只会被扩展$O(n)$次，所以$O(n^2)$，当然事实上还要考虑$gcd$复杂度，所以$O(n^2\log w)$

这个做法对于可行性区间$dp$具有普适性，即如果$f[i][j]=1$且$f[j+1][k]=1$则$f[i][k]=1$的可行性$dp$.保证复杂度的原因是只要这东西为$1$了就不需要再转移了.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=1000;long long INF=1E18+7;
int a[N],n,fst[N],nxt[N*N],to[N*N],mm;
bool f[N][N];
long long b[N],g[N];
int gcd(int a,int b){return b?gcd(b,a%b):a;}
void ade(int u,int v){to[++mm]=v,nxt[mm]=fst[u],fst[u]=mm;}
void dfs(int u,int root)
{
	for(int i=fst[u];i;i=nxt[i])
	{
		int v=to[i];
		if(!f[root][v-1])f[root][v-1]=1,dfs(v,root);
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",a+i);
	for(int i=1,x;i<=n;i++)scanf("%d",&x),b[i]=b[i-1]+x;
	for(int i=1;i<n;i++)if(gcd(a[i],a[i+1])!=1)ade(i,i+2);
	for(int i=n-1;i>=1;i--)
	{
		for(int j=i+2;j<n;j+=2)if(f[i+1][j]&&gcd(a[i],a[j+1])!=1)ade(i,j+2);//一个细节是只转移长为偶数的区间
		dfs(i,i);
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=i-2;j>=0;j-=2)
			if(f[j+1][i])g[i]=max(g[i],g[j]+b[i]-b[j]);
		g[i]=max(g[i],g[i-1]);
	}
	cout<<g[n]<<endl;
}
```

---

## 作者：封禁用户 (赞：2)

# P5154 数列游戏 题解
## 思路
这个题一开始就没能想到用区间 dp 的方式去解决问题……所以直接废掉了。

我们考虑令 $dp_{i,j}$ 表示 $(i,j)$ 这段区间能否被消除到无法消除。

然后考虑怎么转移这个方程：

显然如果想要使一段区间 $(i,j)$ 消掉，有两种方式：
1. 如果 $\gcd(a_i,a_j) \ne 1$ 则 $dp_{i,j} \leftarrow dp_{i+1,j-1}+b_i+b_j$。
2. $(i,j)$ 这个区间也可以由两个小区间拼成，所以 $dp_{i,j} \leftarrow dp_{i,k}+dp_{k+1,j}$。

但是这样的话，我们或许会发现一件事情：在进行第二次操作的时候，似乎没有考虑到最后两个区间相接的数分别是多少。

其实这是不需要去考虑的，因为在我枚举 $k$ 到相接的位置的时候，我们认为 $(l,k)$ 这段区间是处理好的。所以就不需要了记录这个值了。
## Code
```cpp
#include<bits/stdc++.h>
#define int long long
#define mem(a) memset(a,0,sizeof(a))
#define set(a,b) memset(a,b,sizeof(a))
#define ls i<<1
#define rs i<<1|1
#define pb push_back
#define pt putchar
#define All(a) a.begin(),a.end()
#define T int t;cin>>t;while(t--)
#define rand RAND
using namespace std;
char buf[1<<20],*p1,*p2;
#define gc()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2)?EOF:*p1++)
template<class Typ> Typ &re(Typ &x){char ch=gc(),sgn=0; x=0;for(;ch<'0'||ch>'9';ch=gc()) sgn|=ch=='-';for(;ch>='0'&&ch<='9';ch=gc()) x=x*10+(ch^48);return sgn&&(x=-x),x;}
template<class Typ> void wt(Typ x){if(x<0) putchar('-'),x=-x;if(x>9) wt(x/10);putchar(x%10^48);}
const int inf=0x3f3f3f3f;
const int maxn=805;
const int mod=1e9+7;
int seed = 19243;
unsigned rand(){return seed=(seed*48271ll)%2147483647;}
int n;
int a[maxn],b[maxn],dp[maxn][maxn];
int f[maxn];
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++)cin>>b[i];
    memset(dp,-inf,sizeof(dp));
    for(int i=1;i<n;i++){
        if(__gcd(a[i],a[i+1])!=1)dp[i][i+1]=b[i]+b[i+1];
    }
    for(int len=4;len<=n;len+=2){
        for(int i=1;i+len-1<=n;i++){
            int j=i+len-1;
            if(__gcd(a[i],a[j])!=1)dp[i][j]=max(dp[i][j],dp[i+1][j-1]+b[i]+b[j]);
            for(int k=i+1;k<j-1;k+=2)dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]);
        }
    }
    for(int i=1;i<=n;i++){
        f[i]=f[i-1];
        for(int j=0;j<i;j++)
            f[i]=max(f[i],f[j]+dp[j+1][i]);
    }
    cout<<f[n]<<endl;
    return 0;
}
```

---

## 作者：denominator (赞：2)

# 「P5154 数列游戏」题解

## 你不得不知的东西

区间 dp + 普通 dp

此处不再赘述。

## 正文部分

### Part \#0 题目

[点这里](https://www.luogu.com.cn/problem/P5154)

### Part \#1 直接冲正解！

我真的不知道出题人放那么多的部分分干什么，反正一看到「第$i,i+1$个」「重新按顺序编号」「$n\leq800$」的元素，第一反应肯定是**区间 dp**。

那么，怎么进行决策呢？

这里不好想。

大众的想法肯定是枚举用$\text{dp}_{i,j}$枚举$[i,j]$的决策，但这题又不同于以往的套路——它的决策进行可以是断裂的。也就是说，如样例，解释中提到，擦去$A_2,A_3$与$A_5,A_6$。他们之间隔了一个$A_4$，怎么办？

于是我们换一种想法：可以枚举可以删除的一整块内容，再挑选其中的一些块，求最大收益，这不就完了？

枚举可以删除的一整块内容时，可以分成两部分：

1. $i$与$j$不互质且$a_{i+1}\sim a_{j-1}$可以被删除。
2. 存在$i+1\leq k\leq j-2$，使得$a_{i}\sim a_{k}$和$a_{k+1}\sim a_{j}$能被删除。

这就是区间 dp 部分，代码中有简单注释。

求最大收益时，用普通 dp 即可。

我们这次使用$\text{dp2}_i$表示$[1,i]$所获的最大收益，dp 决策也分成两部分：

1. 一般情况下不进行删除，答案就为前一位所求答案。
2. 如果在区间$[1,i]$中恰巧有区间$[j,i]$可以全部删除，则计算删除后的收益，与$\text{dp2}_{j-1}$求和。计算收益方式为：求$\sum\limits_{k=j}^{k\leq i}B_k$，因为区间内删除的数正好是整个区间，每个数都对答案做了贡献。

	可以画图理解：![](https://cdn.luogu.com.cn/upload/image_hosting/0fqsvptu.png)

	~~相信大家看了图还是不理解~~

### Part \#3 献上我丑陋的代码

~~还特意格式化了一下本来更丑陋~~

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define myid(ch) (ch>='0'&&ch<='9')
#define myabs(nb) (nb>=0?nb:-nb)
bool dp[801][801];
// dp[i][j] 记录的状态是在 [i, j] 这个区间内的所有数是否可以被全部删除
ll n,a[801],b[801],dp2[801];
// dp2[i] 记录的状态是删除完毕 [1, i] 区间内的数的最大收益
inline bool bhz(ll x,ll y) { // 使用 bhz 这个函数判断 x 和 y 是否不互质
	x=myabs(x);
	y=myabs(y);
	if(y==0)
		return x!=1;
	return bhz(y,x%y);
}
// 快读快写板子，可以不用，这 n<=800 的规模肯定能过
inline ll read() {
	ll f=1,x=0;
	char c=getchar();
	while(!myid(c)) {
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(myid(c)) {
		x=x*10+(c-'0');
		c=getchar();
	}
	return x*f;
}
inline void write(ll x) {
	if(x<0) {
		putchar('-');
		x=-x;
	}
	if(x>9)
		write(x/10);
	putchar(x%10+'0');
}
int main() {
	n=read();
	for(int i=1; i<=n; i++)
		a[i]=read();
	for(int i=1; i<=n; i++)
		b[i]=read()+b[i-1]; // 在这里边输入边做前缀和操作
	// 核心部分开始
	for(int i=1; i<n; i++)
		dp[i][i+1]=bhz(a[i],a[i+1]);
	// 如果一个序列中只有两个数，只有在互质的情况下可以同时删除
	for(int l=3; l<=n; l++)
		for(int i=1; i<=n-l+1; i++) {
			int j=i+l-1;
			if(bhz(a[i],a[j])&&dp[i+1][j-1]) { // 状态 1：如果可以删去 [i+1, j-1] 的区间且 a_i 和 a_j 互质直接判定可行
				dp[i][j]=true;
				continue;
			}
			dp[i][j]=false;
			for(int k=i+1; k<j-1; k++)
				if(dp[i][k]&&dp[k+1][j]) {
					dp[i][j]=true;
					break;
				}
			// 状态 2：如果可以分割成两个区间且可以删去左右两个区间判定可行
		}
	for(int i=1; i<=n; i++) {
		dp2[i]=dp2[i-1];
		for(int j=1; j<i; j++)
			if(dp[j][i])
				dp2[i]=max(dp2[i],dp2[j-1]+b[i]-b[j-1]); // 如果有可行区间，则将前方最大值加上该区间的和，关于这个和，前文已论述
	}
	write(dp2[n]); // 最后求[1, n]的结果，输出dp2[n]即可
	return 0;
}
```
时间复杂度：$\mathcal{O}(n^2\log\omega+n^3+n^2)=\mathcal{O}(n^3)$

不开氧共$557$ms，开氧快一倍，$284$ms。

❀完结撒花❀！！！*★,°*:.☆(￣▽￣)/*.°★*

---

## 作者：XenonWZH (赞：1)

[更好的阅读体验点这里](https://xenonwzh.github.io/luogu-5154/)

## 解题思路

对于这道题，我们首先可以使用区间 DP 解决。

我们可以设 $f_{l, r}$ 表示区间 $[l, r]$ 可合并为 $1$ 个数所得分数。显然有下列方程：

$$
f_{l, r} = \max\begin{cases}
f_{l + 1, r - 1} + b_l + b_r & \gcd(a_l, a_r) \ne 1 \\
f_{l, k} + f_{k + 1, r} & k \in (l, r)
\end{cases}
$$

初始化：当 $\gcd(a_i, a_{i + 1}) \ne 1$ 时，$f_{i, i + 1} = b_i + b_{i + 1}$，其余情况 $f_{l, r} = -\infty$。

接下来我们将利用这个区间 DP 的结果得出正确答案。

接下来我们进行线性 DP。以求出可互质情况下的最终答案。

我们设 $g_i$ 表示遍历到第 $i$ 个数的最优答案。于是有下列转移方程：

$$
g_i = \max\begin{cases}
g_{i - 1} \\
g_j + f_{j + 1, i} & j \in [0, i)
\end{cases}
$$

最终答案为 $g_n$。

## 代码演示

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

const int MAXN = 800;

long long gcd(long long a, long long b) {
    return b == 0 ? a : gcd(b, a % b);
}

int main() {
    int n;
    static long long a[MAXN + 1], b[MAXN + 1];

    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%lld", &a[i]);
    for (int i = 1; i <= n; i++) scanf("%lld", &b[i]);

    static long long f[MAXN + 1][MAXN + 1];
    memset(f, 0xcf, sizeof(f));
    for (int i = 1; i <= n - 1; i++) {
        if (gcd(a[i], a[i + 1]) != 1) {
            f[i][i + 1] = b[i] + b[i + 1];
        }
    }

    for (int len = 4; len <= n; len += 2) {
        for (int l = 1; l + len - 1 <= n; l++) {
            int r = l + len - 1;
            if (gcd(a[l], a[r]) != 1) f[l][r] = f[l + 1][r - 1] + b[l] + b[r];
            for (int k = l + 1; k <= r - 1; k += 2) f[l][r] = std::max(f[l][r], f[l][k] + f[k + 1][r]);
        }
    }

    static long long g[MAXN + 1];
    for (int i = 2; i <= n; i++) {
        g[i] = g[i - 1];
        for (int j = 0; j <= i - 1; j++) g[i] = std::max(g[i], g[j] + f[j + 1][i]);
    }

    printf("%lld\n", g[n]);

    return 0;
}
```


---

## 作者：Great_Influence (赞：1)

可以发现，如果$i$和$k$同时被消除，那么$[i+1,k-1]$内的所有元素一定全部被消除。

于是先用一个区间$dp$计算出$dp[i][j]$表示是否能将$[i,j]$全部消除，如果能那么等于这一段区间$b$之和，否则等于无穷小。

然后，在做一遍普通的$dp$，计算出$Dp[i]$表示$i$这个前缀的答案。

然后就没了。时间复杂度$O(n^3\log n+n^2)=O(n^3\log n)$。可以通过记录$gcd$的方式来优化到$O(n^3)$。(反正能过就是了)

代码:
```cpp
#include<bits/stdc++.h>
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
#define rep(i,a,b) for(register int i=(a);i<(b);++i)
#define pb push_back
#define mx(a,b) (a>b?a:b)
#define mn(a,b) (a<b?a:b)
typedef unsigned long long uint64;
typedef unsigned int uint32;
typedef long long ll;
using namespace std;

namespace IO
{
    const uint32 Buffsize=1<<15,Output=1<<23;
    static char Ch[Buffsize],*S=Ch,*T=Ch;
    inline char getc()
    {
        return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);
    }
    static char Out[Output],*nowps=Out;
    
    inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}

    template<typename T>inline void read(T&x)
    {
        x=0;static char ch;T f=1;
        for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;
        for(;isdigit(ch);ch=getc())x=x*10+(ch^48);
        x*=f;
    }

    template<typename T>inline void write(T x,char ch='\n')
    {
        if(!x)*nowps++='0';
        if(x<0)*nowps++='-',x=-x;
        static uint32 sta[111],tp;
        for(tp=0;x;x/=10)sta[++tp]=x%10;
        for(;tp;*nowps++=sta[tp--]^48);
        *nowps++=ch;
    }
}
using namespace IO;

void file(void)
{
    FILE*DSD=freopen("water.in","r",stdin);
    FILE*CSC=freopen("water.out","w",stdout);
}

const int MAXN=811;

static int n,a[MAXN],b[MAXN];

inline void Chkmax(ll&a,ll b){a<b?a=b:0;}

inline void init()
{
	read(n);
	Rep(i,1,n)read(a[i]);
	Rep(i,1,n)read(b[i]);
}

static ll dp[MAXN][MAXN];

static ll Dp[MAXN];

inline void solve()
{
	Rep(i,1,n-1)dp[i][i+1]=__gcd(a[i],a[i+1])>1?b[i]+b[i+1]:LLONG_MIN/2;
	Rep(i,4,n)if(~i&1)Rep(j,1,n-i+1)
	{
		dp[j][j+i-1]=LLONG_MIN/2;
		if(__gcd(a[j],a[j+i-1])>1)
			dp[j][j+i-1]=dp[j+1][j+i-2]+b[j]+b[j+i-1];
		Rep(k,j+1,j+i-2)if((k-j)&1)
			Chkmax(dp[j][j+i-1],dp[j][k]+dp[k+1][j+i-1]);
	}
	Rep(i,2,n)
	{
		Dp[i]=Dp[i-1];
		Rep(j,1,i-1)if(dp[j][i]>0)Chkmax(Dp[i],Dp[j-1]+dp[j][i]);
	}
	cout<<Dp[n]<<endl;
}

int main()
{
	init();
	solve();
	return 0;
}
```

---

## 作者：EDqwq (赞：0)

首先，如果我们知道了一个区间是否可以被删除，我们可以做一个 $O(n^2)$ 的 dp 从而计算答案。

考虑用 区间 dp 维护区间是否可以被删除。

删除一段区间有两种方式：

1. 如果区间 $[l + 1,r - 1]$ 可以被删除， $a_l$ 和 $a_r$ 就相邻了，如果它们不互质，这个区间就可以被删除了。

1. 如果有一个断点 $k$ ，使得区间 $[l,k]$ 和 $[k + 1,r]$ 都可以被删除，那么区间 $[l,r]$ 也可以被删除。

所以我们就有了一个 $O(n^3)$ 的区间 dp ，初始判断相邻的数是否互质，枚举区间长度，先处理第一种情况，再枚举断点，只要其中有一个满足，整个区间就可以被删除。

然后设 $f_i$ 为前 $i$ 个数的最大结果，对于每一个 $i$ 枚举前面的一个位置 $k$ ，如果区间 $[k,i]$ 可以被删除，$f_i = \max(f_{k - 1} + sum_{k,i})$。

```cpp
#include<bits/stdc++.h>

#define int long long
#define mem(x,y) memset(x,y,sizeof(x))
#define debug(x) cout << (#x) << " = " << x << endl;

using namespace std;

int read(){
   int s = 0,w = 1;
   char ch = getchar();
   while(ch < '0' || ch > '9'){if(ch == '-')w = -1;ch = getchar();}
   while(ch >= '0' && ch <= '9')s = s * 10 + ch - '0',ch = getchar();
   return s * w;
}

int n;
int a[1000010];
int b[1000010];
int dp[810][810];
int f[1000010];
int pre[1000010];

int query(int x,int y){return pre[y] - pre[x - 1];}

signed main(){
	cin>>n;
	for(int i = 1;i <= n;i ++)a[i] = read();
	for(int i = 1;i <= n;i ++)b[i] = read(),pre[i] = pre[i - 1] + b[i];
	for(int i = 1;i <= n - 1;i ++)dp[i][i + 1] = (__gcd(a[i],a[i + 1]) != 1);
	for(int l = 3;l <= n;l ++){
		for(int i = 1;i <= n - l + 1;i ++){
			int j = i + l - 1;
			if(l > 3)dp[i][j] |= ((dp[i + 1][j - 1] && __gcd(a[i],a[j]) != 1) || dp[i][j]); 
			for(int k = i + 1;k <= j - 2;k ++)dp[i][j] |= (dp[i][k] && dp[k + 1][j]);
		}
	}
	for(int i = 1;i <= n;i ++){
		f[i] = f[i - 1];
		for(int j = 1;j <= i;j ++)if(dp[j][i])f[i] = max(f[i],f[j - 1] + query(j,i));
	}
	cout<<f[n];
}
```

---


# [JSOI2016] 灯塔

## 题目描述

`JSOI`的国境线上有$N$座连续的山峰,其中第$i$座的高度是$h_i$.为了简单起见,我们认为这$N$座山峰排成了连续一条直线.如果在第$i$座山峰上建立一座高度为$p(p≥0)$的灯塔,`JYY`发现,这座灯塔能够照亮第$j$座山峰,当且仅当满足如下不等式:

$$h_j \le h_i+p-\sqrt {|i-j|}$$

`JSOI`国王希望对于每一座山峰,`JYY`都能提供建造一座能够照亮全部其他山峰的灯塔所需要的最小高度.你能帮助`JYY`么?


## 说明/提示

对于$100\%$的数据，$1< N \le  10^5,0 < h_i \le  10^9$

## 样例 #1

### 输入

```
6
5
3
2
4
2
4```

### 输出

```
2
3
5
3
5
4```

# 题解

## 作者：AThousandSuns (赞：27)

我是真的纳闷……这明显就是搬了 POI2011 的经典原题……为什么还没人写决策单调性……

在我的博客园看效果更佳：[点这里](https://www.cnblogs.com/1000Suns/p/11134432.html)

这题其实就是 $p_i=\lceil\max\limits_{j}(a_j-a_i+\sqrt{|i-j|})\rceil$。

拆成两边，先只考虑 $j<i$，然后反过来再做一遍。

然后，发现满足决策单调性。怎么发现的呢？

令 $f_j(i)=\sqrt{i-j}$。会发现 $f_{j_1}(i)$ 和 $f_{j_2}(i)$ 至多只有一个交点。

然后，由于这里是小取代大，所以可以用单调队列。然后发现式子里面与 $p_i$ 无关，所以转移可以按任意顺序，那就可以分治。

这里选择分治，毕竟码量小，好想。

$solve(l,r,L,R)$ 表示正在计算 $[l,r]$ 的 $p$，已知决策在 $[L,R]$ 里面。

取 $l,r$ 的中点 $mid$，求出其的决策点 $MID$。那么 $[l,mid-1]$ 的决策点肯定在 $[L,MID]$，那么可以递归 $solve(l,mid-1,L,MID)$。同理 $solve(mid+1,r,MID,R)$。

由于只会递归 $\log n$ 层，每层会循环 $[L,R]$ 的并集也就是 $[1,n]$，所以复杂度是 $O(n\log n)$。

如果把 $p_i$ 存成实数，最后再取整，那么决策点可以看作是唯一的。就不会出现一些奇怪的情况……

（别问我为什么挂了那么久……）
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=500050;
#define FOR(i,a,b) for(int i=(a);i<=(b);i++)
#define ROF(i,a,b) for(int i=(a);i>=(b);i--)
#define MEM(x,v) memset(x,v,sizeof(x))
inline int read(){
    int x=0,f=0;char ch=getchar();
    while(ch<'0' || ch>'9') f|=ch=='-',ch=getchar();
    while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
    return f?-x:x;
}
int n,a[maxn];
double ans[maxn];
inline double calc(int i,int j){
    return sqrt(i-j)+a[j]-a[i];
}
void solve(int l,int r,int L,int R){
    if(l>r) return;
    int mid=(l+r)>>1,p=L;
    FOR(i,L+1,min(mid,R)) if(calc(mid,p)<calc(mid,i)) p=i;
    ans[mid]=max(ans[mid],calc(mid,p));
    solve(l,mid-1,L,p);
    solve(mid+1,r,p,R);
}
int main(){
    n=read();
    FOR(i,1,n) a[i]=read();
    solve(1,n,1,n);
    FOR(i,1,n/2) swap(a[i],a[n-i+1]),swap(ans[i],ans[n-i+1]);
    solve(1,n,1,n);
    FOR(i,1,n/2) swap(a[i],a[n-i+1]),swap(ans[i],ans[n-i+1]);
    FOR(i,1,n) printf("%.0lf\n",ceil(ans[i]));
}
```

---

## 作者：sfmmdm (赞：12)

这题一个很关键的点是对于 $n \le 100000$，$\sqrt n \le 317$，即 $\sqrt {\left|{i-j}\right|}$ 的取值不会很大，因此在更新答案时可以用根号算法。

这里提供两种思路：

我们先转化下这个式子：

$$h_j \le h_i + p_i - \sqrt{\left|{i-j}\right|}$$

$$h_i + p_i \ge h_j + \sqrt{\left|{i-j}\right|}$$

则最后我们的 $p_i=\max\{h_j + \sqrt{\left|{i-j}\right|}\}-h_i$

#### 思路一

(本思路来自于 @_wkjzyc)

我们发现，对于 $\sqrt{\left|{i-j}\right|}$ 相等的区间，只有最大的 $h_j$ 会贡献答案，那我们只要跑一个 RMQ 即可。由于我刚才说的，$\sqrt{\left|{i-j}\right|}$ 只有 $\sqrt n$ 种取值，则整个算法的时间复杂度为 $O(n \sqrt n)$。

#### 思路二

设计状态 $f_i$ 表示“第 $i$ 个灯塔要照亮前 $i-1$ 座山的最小高度（这里是 $h_i+p_i$ 的最小高度）”，考虑 dp。

明显，$f_i= \max\{h_j + \sqrt{\left|{i-j}\right|}\},0 \le j < i$。

而对于 $f_{i-1}= \max\{h_j + \sqrt{\left|{i-j-1}\right|}\}$，我们发现，当且仅当 $\left|i-j-1\right|$ 是完全平方数时，才会对 $f_i$ 产生与 $f_{i-1}$ 不同的贡献。

这样，$f_i$ 就可以仅由是完全平方数的 $\left|i-j-1\right|$ 转移而来，转移方程大致如下：

$$f_i=\max\{f_{i-1},h_j + \sqrt{\left|{i-j}\right|}\}$$

满足 $|i-j-1| $ 为完全平方数。

同样的，反方向做一遍，两个答案里取 $\max$，就是最终答案。

思路二的实现：

```cpp
#include <bits/stdc++.h>
using namespace std;
int h[100005],f[100005],g[100005];
int main() {
    int n;
    cin>>n;
    for(int i=1; i<=n; i++) {
        scanf("%d",h+i);
    }
    f[1]=h[1];
    for(int i=2; i<=n; i++) {
        f[i]=max(f[i-1],h[i]);//因为p[i]不能取负数，所以f[i]初值里最小要为h[i]
        for(int j=0; j*j<=i-1; j++) {
            f[i]=max(f[i],h[i-1-(j*j)]+j+1);
        }
    }
    g[n]=h[n];
    for(int i=n-1; i; i--) {
        g[i]=max(g[i+1],h[i]);
        for(int j=0; j*j<=n-i-1; j++) {
            g[i]=max(g[i],h[i+(j*j)+1]+j+1);
        }
    }
    for(int i=1; i<=n; i++) {
        printf("%d\n",max(f[i],g[i])-h[i]);
    }
    return 0;
}
```

---

## 作者：Karry5307 (赞：5)

### 题意

有$n$座山，第$i$座山的高度为$h_i$。定义在山峰$i$建立的高度为$h$的灯塔能够照亮山峰$j$当且仅当

$$h_j\leq h_i+p-\sqrt{\vert i-j\vert}$$

求出对于每一座山峰，建立能照亮其他所有山峰的灯塔的最小高度。

$\texttt{Data Range:}n\leq 10^5,1\leq h_i\leq 10^9$

### 题解

好一道分块神仙题。

一开始没想到，后来看了一些题解才知道做的。

注意到，对于固定的$i$，$\sqrt{\vert i-j\vert}$只有$\sqrt n$种取值，而每种取值对应的区间长度也是有$\sqrt{n}$个。

所以，我们可以预处理出每个点向后$\sqrt{n}$个数的最大值，暴力枚举$\sqrt{n}$的取值来更新答案就好啦qwq

时间复杂度$O(n\sqrt{n})$，要稍微卡卡常。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
const ll MAXN=1e5+51;
ll cnt,pos,nxt,res;
ll num[MAXN],maxn[MAXN][651];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
} 
inline ll Max(ll x,ll y)
{
	return x>y?x:y;
}
inline ll Min(ll x,ll y)
{
	return x<y?x:y;
}
int main()
{
	cnt=read();
	for(register int i=1;i<=cnt;i++)
	{
		num[i]=read();
	}
	for(register int i=1;i<=cnt;i++)
	{
		maxn[i][1]=num[i];
		for(register int j=2;j<=min(620,cnt-i+1);j++)
		{
			maxn[i][j]=Max(maxn[i][j-1],num[i+j-1]);
		}
	}
	for(register int i=1;i<=cnt;i++)
	{
		nxt=res=0,pos=i;
		for(register int j=1;pos!=1;j++)
		{
			nxt=pos-1,pos=Max(pos-(j<<1)+1,1);
			res=Max(res,maxn[pos][nxt-pos+1]-num[i]+j);
		}
		nxt=i;
		for(register int j=1;nxt!=cnt;j++)
		{
			pos=nxt+1,nxt=Min(nxt+(j<<1)-1,cnt);
			res=Max(res,maxn[pos][nxt-pos+1]-num[i]+j);
		}
		printf("%d\n",res);
	}
}
```

---

## 作者：Mo默Sh笙 (赞：4)

## 决策单调性二分

### [传送门](https://www.luogu.com.cn/problem/P5503)


数据加强版：[P3515](https://www.luogu.com.cn/problem/P3515)

**前置知识：二分，决策单调性**

------------

首先很容易写出答案式子：

$$

ans_{i}=\max_{j=i}^{n}{(a_{j}-a_{i}+\lceil \sqrt{\left| i-j \right |} \rceil)}

$$

先将向上取整符号拆掉，只要在输出时处理就行。

再将绝对值符号拆掉，分 $j<i$ 和 $j>i$ 的情况考虑，至于 $i=j$ 的情况，将 $ans_{i}$ 初始化为 $0$ 就行。

我们只考虑 $j<i$ 的情况，另一种情况将数组反过来跑一遍取最大值就行。

设关于 $i$ 的函数 $f_{j}{(i)}=a_{j}+\sqrt{i-j}$，对于不同的 $j$，函数图像随 $i$ 的变化大概是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/sd3lq9ul.png)

我们来分析一下这张图：图中曲线即 $f_{j}{(i)}$ 的函数图像，是上凸包，函数的 $j$ 就是最低点对应的 $i$。对于 $ans_{i}$，最优决策点是函数图像与直线 $x=i$ 的最高交点。

设 $pos_{i}$ 为 $ans_{i}$ 的最优决策点对应的 $j$，可以发现：

**对于 $\forall i'<i$，有 $pos_{i'}\le pos_{i}$。**

**对于 $\forall i'>i$，有 $pos_{i'}\ge pos_{i}$。**

然后就可以整体二分来解决了！**对 $i$ 的区间关于中点 $mid$ 二分，对 $j$ 的区间关于当前 $ans_{mid}$ 的最优决策点二分**，注意找最优决策点时还要满足 $j<i$。

------------

$\mathcal{Code}$：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define db double
#define il inline
#define re register
#define INF 0x3f3f3f3f
#define LINF 0x3f3f3f3f3f3f3f3f
#define F(i,a,b) for(re int (i)=(a);(i)<=(b);(i)++)
#define DF(i,a,b) for(re int (i)=(a);(i)>=(b);(i)--)
#define G(i,u) for(re int (i)=head[u];(i);(i)=nxt[(i)])
inline ll read(){ll x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-48;ch=getchar();}return x*f;}
const int N=100010;
int n;
int a[N];
db ans[N];
il db clac(int i,int j)
{//为了满足决策单调性，保证正确性，计算不能取整 
	return a[j]-a[i]+sqrt(i-j);
}//函数图像是一个个凸包，最优凸包不断向右上方延申，满足决策单调性
il void solve(int li,int ri,int lj,int rj)
{
	if(li>ri) return ;
	int i=(li+ri)>>1,pos=lj;
	F(j,lj,min(i,rj)) if(clac(i,pos)<clac(i,j)) pos=j;
	ans[i]=max(ans[i],clac(i,pos));//取j<i和j>i的最优解
	solve(li,i-1,lj,pos);//满足i-1的决策最优点在i的决策最优点pos的左边
	solve(i+1,ri,pos,rj);//满足i+1的决策最优点在i的决策最优点pos的右边
}
int main()
{
	n=read();
	F(i,1,n) a[i]=read();
	solve(1,n,1,n);//j<i的情况
	reverse(a+1,a+n+1);
	reverse(ans+1,ans+n+1);
	solve(1,n,1,n);//j>i的情况
	reverse(a+1,a+n+1);
	reverse(ans+1,ans+n+1);
	F(i,1,n) printf("%d\n",(int)(ceil(ans[i])));
	return 0;
}
```


---

## 作者：pikabi (赞：4)

#### 来一篇优先队列的~

观察到 $p \ge h_j + \sqrt{|i - j|} - a_i$ ,对于第 $i$ 个询问, $a_i$ 是一定的，所以我们只需要维护 $h_j + \sqrt{|i - j|}$ 最大就 OK 了。对于第 $i$ 次询问，不难发现是可以由第 $i - 1$ 次转移过来的，**且每次转移最多只会更改 $2 \times \sqrt{n}$ 个数，下标分别为 $i 、 i + 1 、i + 4 ……$ 和 $i - 1、i - 2、i - 5 ……$。左边 $ + 1$ 右边 $- 1$ 。**

但是单纯存储最大值及其数量会挂掉，不容易转移（~~其实是笔者太菜了~~）。容易想到直接用优先队列维护当前最大值和最大值代表的下标，如果下标的数被修改则 $pop$ 。

~~但是单纯有限队列还是会挂~~，错误结果是 MLE 。如果每次都压入 $\sqrt{n}$ ，总共会有超过 $6\times10^7$ 个 int 。我们继续思考，**发现 $h_j + \sqrt{|i - j|} $ 最多只会被减去 $\sqrt{n}$ 次，因此我们只需要将 $ max_{inqueue} - (h_j + \sqrt{|i - j|}) \le 2 \times \sqrt{n}$ （既有加又有减）的放入就好了**（其实可以再小一点，估计小于 100 也可以过），其余的无论再怎么放也不会大于目前最大值。

复杂度为 $ O(n \times \sqrt{n} * log_?)$，但其实跑的比一般的 $O(n\times\sqrt{n})$ 要快好几倍。

## Code

```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cctype>
#include <queue> 
#include <algorithm>
#define ll long long
#define inf 0x3f3f3f3f

using namespace std;

inline int read(){
	int x=0,w=0;char ch=getchar();
	while (!isdigit(ch))w|=ch=='-',ch=getchar();
	while (isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
	return w?-x:x;
}

priority_queue <pair<int, int>, vector<pair<int, int> >, less<pair<int, int> > > que;
int n, a[1000006], ans[1000006], dis[1000006], calc[1000006], id[1000006], tot, sum;

int main(){
//	freopen("gemo.in","r",stdin);
//	freopen("gemo.out","w",stdout);
	n = read();
	for(int i = 1; i <= n; i++){
		a[i] = read();
	}
	for(int i = 1; i <= n; i++){
		int w = sqrt(i - 1);
		if(w * w != i - 1) w++;
		dis[i] = w + a[i];
		if(que.empty() || dis[i] + 319 >= que.top().first )
		que.push(make_pair(dis[i], i));
	}
	ans[1] = que.top().first;
	for(int i = 2; i <= n; i++){
		for(int j = 0; j * j + i <= n; j++){
			int k = j * j + i;
			dis[k]--;
			if(que.empty() || dis[k] + 319 >= que.top().first )
			que.push(make_pair(dis[k], k));
		}
		for(int j = 0; i - 1 - j * j >= 1; j++){
			int k = i - 1 - j * j;
			dis[k]++;
			if(que.empty() || dis[k] + 319 >= que.top().first )
			que.push(make_pair(dis[k], k));
		}
		pair <int, int> u = que.top();
		while(dis[u.second] != u.first){
			que.pop();
			if(que.empty() ) break;
			u = que.top();
		}
//		u = que.top() ;
		ans[i] = u.first ;
	}
	for(int i = 1; i <= n; i++){
		ans[i] = max(0, ans[i] - a[i]);
		printf("%d\n",ans[i]);
	}
    return 0;
}
```

完结撒花✿✿ヽ(°▽°)ノ✿

---

## 作者：tth37 (赞：4)

由于根号的存在，本题并没有什么明显的单调性，不能通过二分或单调队列实现。

本题的关键在于问题转化。记 $l_i$ 表示在山峰 $i$ 上建灯塔，并使得山峰 $1...i$ 全部被照亮的最小高度。

$$
h_j\le h_i+l_i - \sqrt{i-j} (1\le j\le i)
$$

$$
h_j+\sqrt{i-j}-h_i\le l_i(1\le j\le i)
$$

$$
l_i= \max \lbrace  h_j+\lceil  (\sqrt{i-j})  \rceil \rbrace-h_i
$$


这样 $\{l\}$ 数组的求解即转化为区间求解最值问题，然而 $\max$ 函数中的 $\lceil  (\sqrt{i-j})  \rceil$ 似乎有些棘手。然而观察到当 $\lceil  (\sqrt{i-j})  \rceil$ 相等时，只有该区间内最大的 $h_j$ 才会对答案产生贡献。因此我们可以枚举 $\lceil  (\sqrt{i-j})  \rceil$ 的值，求出对应的 $j$ 区间内 $h_j$ 的最值作为 $l_i$ 的候选答案。

$r_i$ 的定义与 $l_i$ 类似，最终的 $p_i$ 即为 $\max \lbrace l_i,r_i\rbrace$ 。

求解区间最值可以用 ST 表实现。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

int st[100005][18];
int lg[100005];
int power[320];
int p[100005];
int N;

inline int query(int l, int r) {
    int s = lg[r - l + 1];
    return max(st[l][s], st[r - (1 << s) + 1][s]);
}

int main() {
    lg[1] = 0;
    for (register int i = 2; i <= 100000; ++i)
        lg[i] = lg[i >> 1] + 1;
    for (register int i = 1; i <= 319; ++i) {
        power[i] = i * i;
    }
    scanf("%d", &N);
    for (register int i = 1; i <= N; ++i)
        scanf("%d", &st[i][0]);
    for (register int j = 1; j <= lg[N]; ++j)
        for (register int i = 1; i + (1 << j) - 1 <= N; ++i)
            st[i][j] = max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
    for (register int i = 1; i <= N; ++i) {
        int delta = 0, l = i, r = i;
        while (l >= 1) {
            p[i] = max(p[i], query(l, r) + delta - st[i][0]);
            r = l - 1, l = i - power[++delta];
        }
        if (r >= 1) p[i] = max(p[i], query(1, r) + delta - st[i][0]);

    }
    for (register int i = N; i >= 1; --i) {
        int delta = 0, l = i, r = i;
        while (r <= N) {
            p[i] = max(p[i], query(l, r) + delta - st[i][0]);
            l = r + 1, r = i + power[++delta];
        }
        if (l <= N) p[i] = max(p[i], query(l, N) + delta - st[i][0]);
    }
    for (register int i = 1; i <= N; ++i)
        printf("%d\n", p[i]);
    return 0;
}
```

---

## 作者：EternalEpic (赞：4)

这是一道善良的省选题。只需DP即可。

维护两个数组up和down，up[i]表示从1到i需要的高度，down[i]表示从n到i需要的高度。

以up为例，首先up[i] = max(h[i], up[i-1]).

再维护一个指针从头扫一遍，根据题目化根号为平方更新答案。

down只需把顺序改一下即可。

code：

```cpp
enum {
	Maxn = 100005
};

int n, h[Maxn], up[Maxn], down[Maxn];

signed main(void) {
	//file("");
	read(n);
	for (int i = 1; i <= n; i++) read(h[i]);
	for (int i = 1, j = 0; i <= n; i++) {
		up[i] = max(h[i], up[i - 1]); j = 0;
		while (i > j * j + 1) {
			chkmax(up[i], h[i - j * j - 1] + j + 1); ++j;
		}
	}
	for (int i = n, j = 0; i >= 1; i--) {
		down[i] = max(h[i], down[i + 1]); j = 0;
		while (n - i + 1 > j * j + 1) {
			chkmax(down[i], h[i + j * j + 1] + j + 1); ++j;
		}
	}
	for (int i = 1; i <= n; i++) writeln(max(up[i], down[i]) - h[i]);
	//fwrite(pf, 1, o1 - pf, stdout);
	return 0;
}
```


---

## 作者：TYxxj (赞：3)

我们相当于要求出 
$$f_{i}=\max_{j=1}^n(a_j+\sqrt{\left|i-j\right|})$$
这个绝对值太烦人了

考虑对于i>j和i<j分开做。

当i>j时，

$$f_{i}=\max_{j=1}^{i-1}(a_j+\sqrt{\left|i-j\right|})$$

注意到这是一个典型的 $f_{i}=\max_{j=1}^{i-1}f_{j}+w_{i,j}$的形式，考虑决策单调性。

不难证明 $\sqrt{x+1} - \sqrt{x} < \sqrt{x} - \sqrt{x-1}$，

故对于决策点 $p<q$ ，也就是说 $w_{i+1,p}−w_{i,p}<w_{i+1,q}−w_{i,p}$ ，满足四边形不等式。

那么可以按照传统的方法，在队列中维护决策三元组 ${x,l,r}$ 表示当 $i\in_{l,r}$ 时， $f_{i}=f_{x}+\sqrt{i-x}$ ，

每加入一个新的决策时在队尾弹出被当前决策代替的决策，然后在最后一个有效决策的范围上二分得到当前决策的范围。

当有询问时直接拿出队头的答案即可。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int read() {
	int a = 0;
	char c = getchar();
	while (!isdigit(c))c = getchar();
	while (isdigit(c)) {
		a = a * 10 + c - 48;
		c = getchar();
	}
	return a;
}
#define PII pair < int , int >
#define st first
#define nd second
#define ld long double
const int _ = 5e5 + 3;
int h[_], dp[_], N;
ld calc(int i, int j) {
	return h[i] + sqrt(j - i);
}
int main() {
	N = read();
	for (int i = 1 ; i <= N ; ++i)h[i] = read();
	deque < PII > q;
	q.push_back(PII(1, 2));
	for (int i = 2 ; i <= N ; ++i) {
		if (q.size() > 1 && q[1].nd == i)q.pop_front();
		dp[i] = ceil(calc(q[0].st, i));
		int R = N + 1;
		while (q.size() > 1 && calc(q.back().st, q.back().nd) <= calc(i, q.back().nd)) {
			R = q.back().nd;
			q.pop_back();
		}
		int L = max(i, q.back().nd) + 1, t = q.back().st;
		while (L < R) {
			int mid = ((L + R) >> 1);
			calc(t, mid) > calc(i, mid) ? L = mid + 1 : R = mid;
		}
		if (R != N + 1)q.push_back(PII(i, L));
	}
	reverse(h + 1, h + N + 1);
	q.clear();
	q.push_back(PII(1, 2));
	for (int i = 2 ; i <= N ; ++i) {
		if (q.size() > 1 && q[1].nd == i)q.pop_front();
		dp[N - i + 1] = max(dp[N - i + 1], (int)ceil(calc(q[0].st, i)));
		int R = N + 1;
		while (q.size() > 1 && calc(q.back().st, q.back().nd) <= calc(i, q.back().nd)) {
			R = q.back().nd;
			q.pop_back();
		}
		int L = max(i, q.back().nd) + 1, t = q.back().st;
		while (L < R) {
			int mid = ((L + R) >> 1);
			calc(t, mid) > calc(i, mid) ? L = mid + 1 : R = mid;
		}
		if (R != N + 1)q.push_back(PII(i, L));
	}
	reverse(h + 1, h + N + 1);
	for (int i = 1 ; i <= N ; ++i)printf("%d\n", max(0, dp[i] - h[i]));
}
```

---

## 作者：Rorschachindark (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P5503)
# 题目大意
给出一个长度为 $n$ 的 $h_{1,2,...,n}$ ，对于每一个 $i$ 求出最小的 $p_i$ 使得满足：

$$\forall j,h_j\le h_i+p_i-\sqrt{|i-j|}$$
# 思路
都 0202 年了，为什么题解里面还是没有决策单调栈的做法啊？

首先我们发现，我们可以把 $|i-j|$ 拆开，我们只考虑 $i\ge j$ 的情况下，至于 $i>j$ 直接把序列翻转再做一遍就好了。 

然后我们发现其实这个式子可以换成如下形式：

$$p_i= \max_{j=1}^{i}\{h_j+\sqrt{i-j}\}-h_i$$

于是问题就是如何求到 $\max_{j=1}^{i}\{h_j+\sqrt{i-j}\}$ ，我们发现这个东西其实它是有决策单调性的，因为很显然 $\sqrt{i-j}$ 比 $h_j$ 增长速率更慢。于是，我们就可以用决策单调栈做了，时间复杂度 $\Theta(n\log n)$ 。（成功抢下这道题的 $\text{rank1}$

不过话说这道题 $p_i$ 之间互不影响，所以分治也可以。
# $\texttt{Code}$
```cpp
#include <bits/stdc++.h>
using namespace std;

#define Int register int
#define MAXN 100005

int n,head,tail,h[MAXN];
double res1[MAXN],res2[MAXN];
struct node{
	int l,r,x;
}sta[MAXN];
double contri (int i,int j){return h[j] + sqrt (i - j);}
int bound (int i,int j){//找到i比j更优的最后一个点 
	int l = max (i,j),r = n,ans = 0;
	while (l <= r){
		int mid = (l + r) >> 1;
		if (contri (mid,i) >= contri (mid,j)) ans = mid,l = mid + 1;
		else r = mid - 1;
	}
	return ans;
}

void Solve (double *p1){
	sta[head = tail = 1] = node {1,n,1};
	for (Int i = 2;i <= n;++ i){
		while (head < tail && sta[head].r < i) ++ head;
		p1[i] = contri (i,sta[head].x);
		if (contri (n,i) <= contri (n,sta[tail].x)) continue;
		while (head < tail && contri (sta[tail].l,sta[tail].x) <= contri (sta[tail].l,i)) -- tail;
		sta[tail].r = bound (sta[tail].x,i),sta[++ tail] = node {sta[tail - 1].r + 1,n,i};
	}	
}

template <typename T> inline void read (T &t){t = 0;char c = getchar();int f = 1;while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}while (c >= '0' && c <= '9'){t = (t << 3) + (t << 1) + c - '0';c = getchar();} t *= f;}
template <typename T,typename ... Args> inline void read (T &t,Args&... args){read (t);read (args...);}
template <typename T> inline void write (T x){if (x < 0){x = -x;putchar ('-');}if (x > 9) write (x / 10);putchar (x % 10 + '0');}
template <typename T> inline T Min (T a,T b){return a > b ? b : a;} 

signed main(){
	read (n);
	for (Int i = 1;i <= n;++ i) read (h[i]);
	Solve (res1);reverse (h + 1,h + n + 1);Solve (res2);reverse (h + 1,h + n + 1);
	for (Int i = 1,tmp;i <= n;++ i) tmp = (int)ceil (max (res1[i],res2[n - i + 1])) - h[i],write (max (tmp,0)),putchar ('\n');
	return 0;
}
```

---

## 作者：_maze (赞：1)

决策单调性？我不造啊。

我们考虑换换等式：$h_j+\sqrt{i-j}-h_i\le p$。其中 $h_i$ 已经确定。

如果没有中间那个绝对值，这件事情是好办的，直接使用 ST 表解决最大值问题即可。但是我们发现 $|i-j|$ 最多变 $\sqrt{n}$ 次，于是对于每一次分段处理即可。

需要注意的是题目中的 $\le$ 在 $\sqrt{|i+j|}$ 不为整数时会退化成 $<$。于是对于是整数的那个数单独处理即可。

只要你提前处理出 $[1,n]$ 的 $\log$，那么时间复杂度是预处理 $O(n\log n)$，处理答案 $O(n\sqrt{n})$。可以通过此题。

```cpp
/*
slow is fast
*/
#include <bits/stdc++.h>
#define ll long long
#define pre(i,a,b) for(int i=a;i<=b;++i)
#define suf(i,a,b) for(int i=a;i>=b;--i)
using namespace std;
const int N=1e5+5;
int n,w,len;
array<int,N> h,L,R,ans,lg;
array<array<int,19>,N> f;
void cmx(int &a,int b) { if(a<b) a=b; }
[[nodiscard]] \
int mx(int l,int r) { return max(f[l][lg[r-l+1]],f[r-(1<<lg[r-l+1])+1][lg[r-l+1]]); }
void ex(int l,int r,int c,int val,int i) {
  if(r<1||l>n) return ;
  if(c==0) assert(r<=n),ans[i]=max(ans[i],h[r]+val-h[i]),--r;
  else assert(l>=1),ans[i]=max(ans[i],h[l]+val-h[i]),++l;
  if(r<1||l>n) return ;
  l=max(1,l),r=min(n,r);
  int hj=mx(l,r);
  ans[i]=max(ans[i],hj+val-h[i]+1);
}
void solve() {
  cin>>n,len=log2(n),w=sqrt(n);
  pre(i,1,n) cin>>h[i],f[i][0]=h[i];
  lg[0]=-1;
  pre(i,1,n) lg[i]=lg[i>>1]+1;
  pre(i,1,n) ans[i]=0;
  pre(i,1,len) pre(j,1,n-(1<<(i-1))) f[j][i]=max(f[j][i-1],f[j+(1<<(i-1))][i-1]);
  pre(i,1,n) {
    int x=sqrt(i);
    R[x]=i,(L[x]==0)&&(L[x]=i);
  }
  pre(i,1,n) pre(j,1,w) ex(i-R[j],i-L[j],0,j,i),ex(i+L[j],i+R[j],1,j,i);
  pre(i,1,n) cout<<ans[i]<<endl;
}
int main(){
  freopen("text.in","r",stdin);
  freopen("text.out","w",stdout);
  ios::sync_with_stdio(false);
  cin.tie(0);cout.tie(0);
  int T=1;
  while(T--) solve();
  return 0;
}
```

我们根号玩家真是太有实力了！

---

## 作者：intel_core (赞：1)

首先，我们写出 $p_{min}$ 的柿子：

$p_{min}=\max \{ h_j+\sqrt{|i-j|}\}-h_i$

这个式子里，只有 $\sqrt{|i-j|}$ 的值不固定，其它的都是可以求的。

又观察到，$|i-j|< n$ ，所以 $\sqrt{|i-j|} < \sqrt{n}$ ，枚举 $ \left\lceil \sqrt{|i-j|}\right\rceil$  的复杂度是可以接受的。

容易知道，如果 $\left\lceil \sqrt{|i-j|}\right\rceil =k$，那么 $|i-j|\in [(k-1)^2+1,k^2]$ ，相当于求 $\{h_n \}$ 的 $\text{RMQ}$ ，用 $\text{ST}$ 表可以做到 $O(n\log n+n \sqrt{n})$ 的复杂度。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int NR=1e5+10;
int n,a[NR],f[NR][20],lg[NR];

void init(){
	for(int i=1;i<=n;i++)
		lg[i]=lg[i>>1]+1,f[i][0]=a[i];
	for(int i=0;i<lg[n];i++)
		for(int j=1;j+(1<<i)<=n;j++)
			f[j][i+1]=max(f[j][i],f[j+(1<<i)][i]);
}
inline int query(int l,int r){
	l=max(l,1);r=min(r,n);
	int k=lg[r-l+1]-1;
	return max(f[l][k],f[r-(1<<k)+1][k]);
}
inline int sq(int x){return x*x;}

int main(){
	cin>>n;
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	init();
	for(int i=1;i<=n;i++){
		int ans=0;
		for(int j=1;sq(j-1)<=i-2;j++)ans=max(ans,query(i-sq(j),i-sq(j-1)-1)-a[i]+j);
		for(int j=1;sq(j-1)+i<n;j++)ans=max(ans,query(i+sq(j-1)+1,i+sq(j))-a[i]+j);
		printf("%d\n",ans);
	}
	return 0;
} 
```

---

## 作者：Hellsing_Alucard (赞：0)

一道诈骗题。

------------
题意：

给定一个长度为 $n$ 的序列 $\{a_n\}$，对于每个 $i\in [1,n]$ ，求出一个最小的非负整数 $p$ ，使得 $\forall j\in[1,n]$，都有 $a_j\le a_i+p-\sqrt{|i-j|}$

$1 \le n \le 10^{5}$，$0 \le a_i \le 10^{9}$。


------------

看起来是相当的不可做，题解里大部分都是决策单调性 DP。

然而，因为 $ n \le 5\times 10^{5} $, 所以 $\sqrt{i-j}\le710$。

能够对答案造成影响的只有 $\max a_i-\sqrt{n}\le a_i\le \max a_i$。

其实最多只有 710 个不同的数。

又有一个显然的结论，多个相同的数，只有两端的数会对答案造成影响，所以最多不过记录 1420 个数。

然而如果就这么硬写的话，会 Tle 掉一个点。

考虑到两个相同的数，左端点影响右边的数，右端点影响左边的数，所以考虑分开来计算。

常数直接变成一半。

还有一个小坑点，就是这道题要向上取整。

```cpp

#include <bits/stdc++.h>

using namespace std;

//#define int long long
#define i128 __int128
#define ldo long double
#define dle double
#define up(a,b,c) for(int a=b;a<=c;a++)
#define dn(a,b,c) for(int a=b;a>=c;a--)
#define pii pair<int,int>
#define lc k<<1
#define rc k<<1|1

const int N=5e5+7;
const int mod=59027;

namespace IO{
    inline int read(){
        char c=getchar();int x=0,fh=0;
        while(c<'0'||c>'9'){fh|=c=='-';c=getchar();}
        while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
        return fh?-x:x;
    }
    inline void wt(int x){
        if(x<0){x=-x;putchar('-');}
        if(x>9)wt(x/10);
        putchar((x%10)^48);
    }
    inline void write(int x,bool op){
        wt(x);
        putchar(op?'\n':' ');
    }
}using namespace IO;
int n;
int a[N];
int hmax;
vector<pii>g;
bool vis[N];
unordered_map<int,bool>mp;
dle ans[N];
signed main(){
    n=read();
    up(i,1,n)a[i]=read(),hmax=max(hmax,a[i]);
    int lim=hmax-sqrt(n)-1;
    up(i,1,n){
        if(a[i]>=lim&&!mp.count(a[i])){
            mp[a[i]]=1;
            vis[i]=1;
            g.push_back({a[i],i});
        }
    }
    mp.clear();
    dn(i,n,1){
        if(vis[i])continue;
        if(a[i]>=lim&&!mp.count(a[i])){
            mp[a[i]]=1;
            g.push_back({a[i],i});
        }
    }
    sort(g.begin(),g.end());
    g.push_back({-1,0});
    up(i,0,g.size()-2){
        int w=g[i].first,nxt=g[i+1].first;
        if(w!=nxt){
            int pos=g[i].second;
            up(j,1,n){
                ans[j]=max(ans[j],(dle)sqrt(abs(pos-j))+a[pos]-a[j]);
            }
        }  
        else {
            int pos1=g[i].second,pos2=g[i+1].second;
            int mid=(pos1+pos2)>>1;
            up(j,1,mid){
                ans[j]=max(ans[j],(dle)sqrt(abs(pos2-j))+a[pos2]-a[j]);
            }
            up(j,mid,n){
                ans[j]=max(ans[j],(dle)sqrt(abs(pos1-j))+a[pos2]-a[j]);
            }
            i++;
        }
    }
    up(i,1,n)write((int)ceil(ans[i]),1);
    return 0;
}
```

---

## 作者：phigy (赞：0)

移项可以得到：$ans_i=\max_{1\leq j\leq n}\{a_j+\lceil\sqrt{|i-j|}\rceil\}-a_i$。

因为 $g(x)=\sqrt{x}$ 增长缓慢，$f_j(i)=a_j+\lceil\sqrt{|i-j|}\rceil$ 的各函数之间至多有一个交点，满足四边形不等式的决策单调性。

**在四边形不等式的决策单调性，若有 $f_j(x)=dp_j+w(j,x)$ 那么各 $f$ 只在一段连续的横坐标上纵坐标最大且顺序按 $j$ 。（即使各 $f$ 不全，因为四边形不等式的决策单调性中 $f$ 之间都只有一个交点）。**

我们通常会把两个 $f$ 的交点看做一个超越的过程（一个点如果在原本它为纵坐标最大的段上与新的点相交了，它就被超过了，最大就不是它了），谁超了谁我们也不清楚，那这里就有个想法就是：

**维护每个 $f$ 能作为哪些横坐标的决策点，首先如果这个 $f$ 它被作为决策点的点已经过转移目标 $i$ 了那就作为单调队列的队首弹出，然后我们新的 $f$ 从尾部一个一个比较弹出它能完全超掉的，最后一个我们二分部分炒掉的内部找个断点，然后加入新 $f$。**

这个是一个优秀做法：**单调队列（维护决策点）+二分（更新单调队列）。**

```cpp
#include <iostream>
#include <cmath>

using namespace std;

int n;
int a[1000005];

double cal(int i,int j)
{
	return sqrt(abs(i-j));	
}
double val(int i,int j)
{
	return a[i]+cal(i,j);
}
double f[1000005],g[1000005];

struct triple
{
	int x,l,r;
}st[1000005];
int l,r;


int main()
{
	int i,j,k;
	cin>>n;
	for(i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	l=1;
	r=0;
	r++;
	st[1]={1,1,n};
	f[1]=a[1];
	for(i=2;i<=n;i++)
	{
		while(l<r&&st[l].r<i)
		{
			l++;	
		}
		st[l].l=i;
		f[i]=val(st[l].x,i);
		while(l<r&&val(i,st[r].l)>=val(st[r].x,st[r].l))
		{
			r--;	
		}
		int ll=st[r].l,rr=st[r].r+1;
		while(ll<rr)
		{
			int mid=(ll+rr)/2;
			if(val(i,mid)>=val(st[r].x,mid))
			{
				rr=mid;	
			}
			else 
			{
				ll=mid+1;	
			}
		}
		if(ll<=n)
		{
			st[r].r=ll-1;
			r++;
			st[r].x=i;
			st[r].l=ll;
			st[r].r=n;
		}
	}
	for(i=1;i<=n;i++)
	{
		g[i]=f[i];
		f[i]=0;
	}
	for(i=1;i<=n/2;i++)
	{
		swap(a[i],a[n-i+1]);
	}
	l=1;
	r=0;
	r++;
	st[1]={1,1,n};
	f[1]=a[1];
	for(i=2;i<=n;i++)
	{
		while(l<r&&st[l].r<i)
		{
			l++;	
		}
		st[l].l=i;
		f[i]=val(st[l].x,i);
		while(l<r&&val(i,st[r].l)>=val(st[r].x,st[r].l))
		{
			r--;	
		}
		int ll=st[r].l,rr=st[r].r+1;
		while(ll<rr)
		{
			int mid=(ll+rr)/2;
			if(val(i,mid)>=val(st[r].x,mid))
			{
				rr=mid;	
			}
			else 
			{
				ll=mid+1;	
			}
		}
		if(ll<=n)
		{
			st[r].r=ll-1;
			r++;
			st[r].x=i;
			st[r].l=ll;
			st[r].r=n;
		}
	}
	for(i=1;i<=n;i++)
	{
		g[i]=max(g[i],f[n-i+1]);
		cout<<max(0,(int)ceil(g[i])-a[n-i+1])<<endl;
	}
	return 0;
}
```




---


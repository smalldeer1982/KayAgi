# 心上秋

## 题目背景

辗转经由他人唇齿

多少日夜听闻你的故事

难道这情之一字

竟连抛生死亦不可探知

听说北国的那座城池

被冬雪覆了终日

等到故人长诀渐行渐远

转眼已隔两世

谁向生而死 谁患得患失

相顾也再无多时

画中人暗自 竟心荡神痴

一滴泪氤氲满纸

挥墨描眉目 提笔勾鬓丝

寥寥几笔竟如此

夜半无人处 对月展卷时

忽然看懂这相思

落款谁提了名字

————《心上秋》

## 题目描述

竟宁元年（前33年）正月，昭君出塞前一晚。

画师跌跌撞撞地来到昭君居住的宫殿。

     听说北国的那座城池
     被冬雪覆了终日
     等到故人长诀渐行渐远
     转眼已隔两世
                ——《心上秋》

如果再也不能相见的话，画师想着，他想给昭君留下些什么。

他想把他的画笔送给昭君。

**昭君的宫殿里有$N$个房间，有$N-1$条道路连接这些房间。**

**画师现在在宫殿的入口大厅$S$房间，他依稀记得，昭君的房间在$T$号。**

窗外，风雨大作，宫内忽暗忽明，一个人影也没有。

画家走进晦暗的通道，每条通道里的墙壁上都画有若干片枫叶，这是之前昭君让画师画的。昭君说，她特别喜欢秋天，尤其喜欢秋天的枫叶。

      并肩长谈过多少往事，恍然间黄昏已至    ——《心上秋》

通道内晦暗无比，画师想点亮通道内备好的蜡烛，他记得昭君有个习惯，**每个通道内的蜡烛数量就是墙上枫叶的数量。昭君若想点燃一条通道内的蜡烛，就会全部点燃，此时昭君认为这条通道已被点亮，并且不会再点亮任何枫叶数少于这条通道的通道**。

这应该是最后一次来到这个地方了，画师想着，他要按昭君的习惯，走到昭君的房间。

**现在画师想知道，他从宫殿大厅$S$走到昭君房间$T$，最多可以点亮多少通道。**

## 说明/提示

| 数据编号 | N | M | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $100$ | $100$ | 无 |
| $2$ | $100$ | $100$ | 无 |
| $3$ | $100$ | $1000$ | 无 |
| $4$ | $10000$ | $10000$ | 无 |
| $5$ | $10000$ | $10000$ | $1$ |
| $6$ | $10000$ | $10000$ | $1,2$ |
| $7$ | $10000$ | $10000$ | $1,2$ |
| $8$ | $30000$ | $100000$ | 无 |
| $9$ | $30000$ | $100000$ | 无 |
| $10$ | $30000$ |$300000$  | 无 |
特殊性质$1$：$1<=leaf_{i}<=2$

特殊性质$2$：$u_{i}+1=v_{i}$

对于所有的数据，保证$1<=leaf_{i}<=5$

样例一解析：

![](https://cdn.luogu.com.cn/upload/image_hosting/eaxwdth6.png)

询问$1$：从$2$走到$1$最多点亮$1$条通道（$2-1$）

询问$2$：从$4$走到$2$最多点亮$2$条通道（$4-1,1-2$）

询问$3$：显然无法点亮通道。

样例二解析：

![](https://cdn.luogu.com.cn/upload/image_hosting/8z9tovt5.png))

询问$1$：从$7$走到$5$，可以点亮$4$个通道（$7-1,1-2,2-4,4-5$）

询问$2$：从$7$走到$6$，可以点亮$4$个通道（$7-1,1-2,2-4,4-5$），不点亮（$5-6$）是因为已经点亮（$4-5$）后无法点亮比枫叶数小于$4$的通道，易知这样是最优的，或者不点亮（$4-5$）而点亮（$5-6$），这同样是最优解。

询问$3$：从$2$走到$7$，可以点亮$2$个通道（$2-1$,$1-7$）

询问$4$：不经过任何通道。

询问$5$：经过$1$条通道（$2-4$）


     何处合成愁。离人心上秋。纵芭蕉，不雨也飕飕。都道晚凉天气好，有明月，怕登楼。

     年事梦中休。花空烟水流。燕辞归，客尚淹留。垂柳不萦裙带住。漫长是，系行舟。


## 样例 #1

### 输入

```
5
1 2 5
2 3 1
1 4 1
3 5 4
3
2 1
4 2
1 1
```

### 输出

```
1
2
0
```

## 样例 #2

### 输入

```
7
1 2 1
1 3 5
2 4 1
4 5 4
5 6 1
1 7 1
5
7 5
7 6
2 7
1 1
2 4```

### 输出

```
4
4
2
0
1
```

## 样例 #3

### 输入

```
20
1 2 1
1 3 3
2 4 5
1 5 1
5 6 5
1 7 5
1 8 4
7 9 1
8 10 2
1 11 1
2 12 5
3 13 1
3 14 3
3 15 3
10 16 1
5 17 1
12 18 5
7 19 4
7 20 5
10
10 3
17 16
11 9
4 6
16 17
11 16
11 11
13 11
2 1
10 11```

### 输出

```
2
3
2
3
3
2
0
2
1
2
```

# 题解

## 作者：__mcx_ (赞：3)

# **P5558题解**

简要题意：多次查询树上路径最长非降子序列长度。这里给出的是 DDP 做法。

先考虑在序列上的做法，一般地，我们可以考虑设 $ f_i $ 表示到 $i$ 为结尾的最长非降子序列长度。

那么我们有 $ f_i = \max_{j = 1}^{j < i} (f_j+1)  [leaf_j \leq leaf_i] $。

这个式子可以通过权值线段树或者树状数组优化复杂度，在此不再赘述。

假如用矩阵维护这个过程怎么做，这要求我们知道前 $i$ 个节点的信息，此时我们难以用矩阵维护。

观察到 $ 1 \leq leaf \leq 5 $，这启示我们可以通过维护与值域有关的信息来进行转移。

那么让我们重新设计状态,设 $ f_{i,v} $ 表示到 $i$ 为止末尾枫叶数量为 $v$ 的最长非降子序列。

设 $i$ 号点拥有的枫叶数量为 $ leaf_i $。

对于 $leaf_i \ne v $ 时，有 $f_{i,v} = f_{i-1,v}$。

对于 $leaf_i = v $ 时，有 $f_{i,v} = \max_{w = 1}^{w \leq v} f_{i-1,w}+ 1 $。

如此，我们只需要知道上一个位置的五个信息，这时再通过矩阵乘法（广义）去维护便变得简单了。

考虑定义广义矩阵乘法 $ C_{i,j} = \max_{k = 1}^{k \leq n} (A_{i,k} + B_{k,j}) $，手玩之后发现这种运算是具有结合律的。

那么我们可以利用其结合律处理出路径上的 “前后缀积”,配合我们树上问题的利器-树链剖分来解决。

考虑如何用矩阵维护我们的信息。

对于一个节点，我们维护他每个值对应的 dp 值 $\begin{bmatrix}f_{i,1},f_{i,2},f_{i,3},f_{i,4},f_{i,5}\end{bmatrix}$ 考虑怎么把上面的转移写成矩阵形式。

手玩一下，在不考虑 $leaf_i$ 时，可以得到一般的转移矩阵 $E = \begin{bmatrix} 0&\ -\infty& \ -\infty& \ -\infty& \ -\infty&\\ -\infty&\ 0& \ -\infty& \ -\infty& -\infty& \\ -\infty& \ -\infty& \ 0& \ -\infty& \ -\infty& \\ -\infty& \ -\infty& \ -\infty& \ 0& - \infty&  \\ -\infty& \ -\infty& -\infty& \ -\infty& \ 0&\end{bmatrix} $

特别地，对于每个 $ leaf_i $ 我们只需要把当前矩阵第 $ leaf_i $ 列的前 $ leaf_i $ 行的元素改为 $1$ 即可。

解释一下为什么需要前后缀积，因为我们的矩阵乘法是不满足**交换律**的，那么我们便要把从 $ S \rightarrow T $ 的过程看作一条有向路径（可以类比成向量）而非一般的信息合并。

理论而言是可以直接维护每条链跳到链首的前后缀积的，但是由于笔者代码水平有限，这里采用线段树维护。 

注意矩阵初始化，不要写成全部为 $0$ 的形式，这样会使整个矩阵的信息变得混乱，注意树链上的元素对应线段树的元素的方向，不要写反了，跳链的时候可以画个图理解一下。

[code](https://www.luogu.com.cn/paste/v137gfqi)

另附一个数据生成器。[data](https://www.luogu.com.cn/paste/50sygwrc)

---

## 作者：harmis_yz (赞：3)

## 分析

考虑暴力。

这体面有点不好看，实际上就是在求 $s$ 到 $t$ 路径上的最长不下降子序列长度。注意到 $leaf_i \le 5$，考虑直接定义 $f_{i,j}$ 表示从 $s$ 走到 $i$，子序列结尾的值为 $j$ 时的最长长度。我们进行树剖，那么对于一个区间，有：$f_{i,j}=f_{i-1,j},f_{i,a_i}=\max(f_{i-1,a_i},(f_{i-1,j}+1)[j \le a_i])$。注意到 $f_i$ 转移的不同情况只与 $a_i$ 有关，写成矩阵的形式：

$$\begin{bmatrix} f_{n-1,1}& f_{n-1,2} &  f_{n-1,3}&f_{n-1,4}&f_{n-1,5}\end{bmatrix}\begin{bmatrix}[a_n=1]& [a_n=2]& [a_n=3] &[a_n=4]&[a_n=5]\\ -inf & [a_n=2]& [a_n=3]&[a_n=4]&[a_n=5]\\ -inf & -inf& [a_n=3]&[a_n=4]&[a_n=5]\\ -inf&-inf&-inf&[a_n=4]&[a_n=5]\\ -inf&-inf&-inf &-inf&[a_n=5]\end{bmatrix}=\begin{bmatrix}  f_{n,1}&f_{n,2}&f_{n,3}&f_{n,4}&f_{n,5}\end{bmatrix}$$

然后这是个 $(max,+)$ 的矩阵，就做完了。时间复杂度 $O(a^3m\log^2 n),a=5$。优化成 $O(a^2m\log^2 n)$ 应该就行了。

## 代码

```cpp
const int N=1e5+10,p=998244353;
int n,m,val[N];
vector<pii> e[N];
int dep[N],siz[N],mson[N],f[N];
int top[N],dfn[N],id[N],cnt;
struct Tree{
	int l,r;
	int c[2][5][5];
}tr[N<<2];

il void up(Tree &u,Tree x,Tree y,int k){
	if(k==0){
		for(re int i=0;i<5;++i)
		for(re int j=0;j<5;++j) 
			u.c[k][i][j]=max({ 
				x.c[k][i][0]+y.c[k][0][j],
				x.c[k][i][1]+y.c[k][1][j],
				x.c[k][i][2]+y.c[k][2][j],
				x.c[k][i][3]+y.c[k][3][j],
				x.c[k][i][4]+y.c[k][4][j]});
	}
	else{
		for(re int i=0;i<5;++i)
		for(re int j=0;j<5;++j) 
			u.c[k][i][j]=max({ 
				y.c[k][i][0]+x.c[k][0][j],
				y.c[k][i][1]+x.c[k][1][j],
				y.c[k][i][2]+x.c[k][2][j],
				y.c[k][i][3]+x.c[k][3][j],
				y.c[k][i][4]+x.c[k][4][j]});		
	}
	return ;
}
il void build(int u,int l,int r){
	tr[u].l=l,tr[u].r=r;
	if(l==r){
		memset(tr[u].c,-0x3f,sizeof(tr[u].c));
		for(re int k=0;k<2;++k)
		for(re int i=0;i<5;++i)
		for(re int j=0;j<5;++j)
		if(val[id[l]]==i+1&&j<=i) tr[u].c[k][j][i]=1;
		else if(j==i) tr[u].c[k][j][i]=0;
		return ;
	} 
	int mid=l+r>>1;
	build(ls(u),l,mid),build(rs(u),mid+1,r);
	return up(tr[u],tr[ls(u)],tr[rs(u)],0),up(tr[u],tr[ls(u)],tr[rs(u)],1),void(0);
}
il Tree query(int u,int l,int r){
	if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
	int mid=tr[u].l+tr[u].r>>1;
	if(l<=mid&&mid< r){
		Tree ans;
		memset(&ans,-0x3f,sizeof(ans));
		Tree x=query(ls(u),l,r),y=query(rs(u),l,r);
		up(ans,x,y,0),up(ans,x,y,1);
		return ans;
	}
	if(l<=mid) return query(ls(u),l,r);
	if(mid< r) return query(rs(u),l,r); 
}
il void dfs1(int u,int fa){
	f[u]=fa,dep[u]=dep[fa]+1,siz[u]=1;
	for(auto v:e[u])
	if(v.x!=fa){
		dfs1(v.x,u),siz[u]+=siz[v.x],val[v.x]=v.y;
		if(siz[v.x]>mson[u]) mson[u]=v.x;
	}
	return ;
} 
il void dfs2(int u,int tp){
	top[u]=tp,dfn[u]=++cnt,id[cnt]=u;
	if(mson[u]) dfs2(mson[u],tp);
	for(auto v:e[u])
	if(v.x!=f[u]&&v.x!=mson[u]) dfs2(v.x,v.x);
	return ;
}
il int Query(int x,int y){
	Tree res1,res2;
	memset(&res1,-0x3f,sizeof(res1)),
	memset(&res2,-0x3f,sizeof(res2));
	for(re int k=0;k<2;++k)
	for(re int i=0;i<5;++i) res1.c[k][i][i]=res2.c[k][i][i]=0;
	while(top[x]!=top[y]){
		if(dep[top[x]]>=dep[top[y]]){
			Tree res=query(1,dfn[top[x]],dfn[x]);x=f[top[x]];
			Tree res_=res1;
			up(res1,res,res_,0),
			up(res1,res,res_,1);
		}
		else{
			Tree res=query(1,dfn[top[y]],dfn[y]);y=f[top[y]];
			Tree res_=res2;
			up(res2,res,res_,0),
			up(res2,res,res_,1);			
		}
	}
	if(dep[x]> dep[y]){
		Tree res=query(1,dfn[y]+1,dfn[x]);
		Tree res_=res1;
		up(res1,res,res_,0),
		up(res1,res,res_,1);
	}
	if(dep[y]> dep[x]){
		Tree res=query(1,dfn[x]+1,dfn[y]);
		Tree res_=res2;
		up(res2,res,res_,0),
		up(res2,res,res_,1);
		
	}
	
	for(re int i=0;i<5;++i)
	for(re int j=0;j<5;++j) swap(res1.c[0][i][j],res1.c[1][i][j]);
	up(res1,res1,res2,0);
	int Max=0;
	for(re int i=0;i<5;++i)
	for(re int j=0;j<5;++j) Max=max(Max,res1.c[0][i][j]);
	return Max;	
}

il void solve(){
	n=rd;
	for(re int i=1;i< n;++i){
		int u=rd,v=rd,w=rd;
		e[u].push_back({v,w}),
		e[v].push_back({u,w});
	}
	m=rd,dfs1(1,0),dfs2(1,1),build(1,1,n);
	while(m--){
		int u=rd,v=rd;
		printf("%lld\n",Query(u,v));
	}
    return ;
}
```

---

## 作者：Amadeus004 (赞：2)

> 并肩长谈过多少往事
> 
> 恍然间黄昏已至
> 
> 以为一双知己做了一世
> 
> 从来不过如此
> 

本来想找一道 DDP 的练手题，结果这道题目这么有诗意，那就不得不写篇题解了

## 简化题意
给出一颗树，每条边有边权，每次查询路径 $S\rightarrow T$ 上边权形成的最长不降子序列的长度。$1\le N\le 3\times 10^4,1\le M\le3\times 10^5$。

## 思路
记题目中询问的起点为 $S$，终点为 $T$，它们的最近公共祖先为 $\operatorname {LCA}(S,T)$。
### Step 1
题目中求的是边权，不太好做，在选取一个点作为根建树后，将每个点连向其父亲的边权作为它的点权。特别地，计算 $S\rightarrow T$ 的答案时，$\operatorname {LCA}(S,T)$ 的点权不计入贡献，故根节点的点权也无需考虑赋值。

### Step 2
 考虑题目所求，设 $f_{u}$ 为以点 $u$ 为结尾的最长上升子序列长度，转移方程为 $$f_{u}=\max_{1\le v<u}(f_v+1)[leaf_v\le leaf_u]$$
 这样做时间复杂度是 $\Theta(n^2)$ 的；另一种求法是记录长度为 $u$ 时最长不降子序列结尾的最小值，时间复杂度 $\Theta(n\log n)$。显然在本题的数据范围下，我们不可能真的把一条链拉出来做一次 DP。

观察数据的特殊性质，不难发现 $1\le leaf_u\le5$。考虑以 $leaf_u$ 作为转移的状态，上面其实已经隐式的体现了这一点，$f$ 的转移虽然是以 $u$ 为终点，但这一过程与 $leaf_u$ 的值紧密关联，且不需要时刻记录 $u$ 的值。我们丢掉 $u$，考虑用矩阵优化这一转移的过程。

### Step 3
定义广义矩阵乘法 $\left\{+,\max\right\}$，即 $C_{i,j}=\max\left\{A_{i,k}+B_{k,i}\right\}$。

点 $i$ 的贡献可以用一个转移矩阵 $g$ 表示。对于单位矩阵，有
$$I=
\begin{bmatrix}
 0 & -\infty & -\infty & -\infty & -\infty\\
 -\infty & 0 & -\infty & -\infty & -\infty\\
 -\infty & -\infty & 0 & -\infty & -\infty\\
 -\infty & -\infty & -\infty & 0 & -\infty\\
 -\infty & -\infty & -\infty & -\infty & 0
\end{bmatrix}$$
其中 $0$ 表示继承状态，$\rm -\infty$ 表示该状态不合法并不产生贡献。考虑点权时，我们将第 $leaf_i$ 行的前 $leaf_i$ 个数设为 $1$，表示之前以 $1\sim leaf_i$ 为结尾的最长不降子序列产生的贡献。如当 $leaf_i=3$ 时，
$$g=   
\begin{bmatrix}
 0 & -\infty & -\infty & -\infty & -\infty\\
 -\infty & 0 & -\infty & -\infty & -\infty\\
 1 & 1 & 1 & -\infty & -\infty\\
 -\infty & -\infty & -\infty & 0 & -\infty\\
 -\infty & -\infty & -\infty & -\infty & 0
\end{bmatrix}$$

我们预处理出每个点到根节点路径上转移矩阵的正序/逆序乘积，这是因为 $S\rightarrow T$ 的转移是有向的。查询时把路径分为 $S\rightarrow \operatorname {LCA}(S,T)$ 和 $\operatorname {LCA}(S,T)\rightarrow T$ 两部分，分别查询其乘积并相乘即可，答案为矩阵中所有数的最大值。

树剖的复杂度是 $\Theta(n)-\Theta(\log^2n)$ 的，倍增的复杂度是 $\Theta(n\log n)-\Theta(\log n)$ 的。这里因为不带修和码量小选择了倍增。

### Step 4
_**Code**_
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<ctype.h>
#include<vector>
#include<cmath>
#include<iostream>
#define int long long
using namespace std;
inline int read(){
	int tmp=1,f=0;
	char a;
	while(!isdigit(a=getchar()))tmp=a=='-'?-1:tmp;
	do{f=(f<<3)+(f<<1)+(a^48);}while(isdigit(a=getchar()));
	return tmp*f;
}
inline void write(int x){
	if(x<0)x=-x,putchar('-');
	if(x>9)write(x/10);
	putchar(x%10+'0');
}
const int N=3e4+5,siz=5,INF=1e9;
int n,m;
struct Matrix{
	int mat[siz+1][siz+1];
	Matrix(){for(int i=1;i<=siz;i++)for(int j=1;j<=siz;j++)mat[i][j]=-INF;}
	inline void init(int x){
		for(int i=1;i<=siz;i++)mat[i][i]=0;
		for(int i=1;i<=x;i++)mat[x][i]=1;
	}
	inline Matrix operator*(const Matrix &x)const{
		Matrix tmp;
		for(int i=1;i<=siz;i++)
		for(int j=1;j<=siz;j++)
		for(int k=1;k<=siz;k++)
			tmp.mat[i][j]=max(mat[i][k]+x.mat[k][j],tmp.mat[i][j]);
		return tmp;
	}
	inline void print(){
		for(int i=1;i<=siz;i++,putchar('\n'))
		for(int j=1;j<=siz;j++,putchar(' '))
			write(mat[i][j]<0?-1:mat[i][j]);
	}
	inline int maxnum(){
		int ans=0;
		for(int i=1;i<=siz;i++)
		for(int j=1;j<=siz;j++)
			ans=max(ans,mat[i][j]);
		return ans;
	}
}up[17][N],down[17][N];
struct Tree{
	vector<pair<int,int> >G[N];
	int fa[17][N],dep[N];
	inline void dfs(int u,int ff){
		dep[u]=dep[fa[0][u]=ff]+1;
		for(int i=1;i<=15;i++)
			fa[i][u]=fa[i-1][fa[i-1][u]],
			up[i][u]=up[i-1][fa[i-1][u]]*up[i-1][u],
			down[i][u]=down[i-1][u]*down[i-1][fa[i-1][u]];
		for(int i=0;i<G[u].size();i++){
			int v=G[u][i].first,w=G[u][i].second;
			if(v==ff)continue;
			up[0][v].init(w),down[0][v]=up[0][v],dfs(v,u);
		}
	}
	inline Matrix query(int x,int y){
		Matrix ansl,ansr;ansl.init(0),ansr.init(0);
		if(dep[x]>dep[y]){
			for(int i=15;i>=0;i--)
				if(dep[fa[i][x]]>=dep[y])
				ansl=up[i][x]*ansl,x=fa[i][x];
		}else{
			for(int i=15;i>=0;i--)
				if(dep[fa[i][y]]>=dep[x])
				ansr=ansr*down[i][y],y=fa[i][y];
		}
		if(x==y)return ansr*ansl;
		for(int i=15;i>=0;i--)
			if(fa[i][x]!=fa[i][y])
				ansl=up[i][x]*ansl,x=fa[i][x],
				ansr=ansr*down[i][y],y=fa[i][y];
		return ansr*down[0][y]*up[0][x]*ansl;
	}
}T;
signed main(){
	n=read(),up[0][1].init(0),down[0][1]=up[0][1];
	for(int i=1;i<=n-1;i++){
		int u=read(),v=read(),w=read();
		T.G[u].push_back({v,w}),T.G[v].push_back({u,w});
	}
	T.dfs(1,0);
	for(int Q=read();Q;Q--){
		int u=read(),v=read(),res=0;
		Matrix ans=T.query(u,v);
		ans.print();
		write(ans.maxnum()),putchar('\n');
	}
	return 0;
}
```

---

## 作者：complete_binary_tree (赞：2)

> 夜半无人处 对月展卷时
>
> 忽然看懂这相思
>
> 落款谁提了名字
>
> ——《心上秋》

[原题传送门](https://www.luogu.com.cn/problem/P5558)

500AC 没想到是道这么有诗意的题目。

### 题目大意

给定一棵树，边有边权，求 $S \to T$ 路径中经过的边的最长不降子序列长度。

### 题解

首先我们想到，边权可以转换为点权，把一个点连向父亲的边权当作它的点权。这样就好做多了。

再来看看数据范围：$1 \le leaf_i \le 5$（~~眼瞎的我瞪了这题半天才发现~~），那么可以考虑 dp。

设 $f_{i,j}$ 为到序列第 $i$ 个点末尾为 $j$ 的最长上升子序列个数，那么有转移：

$$f_{i,j} \leftarrow f_{i,j}$$

$$f_{i,leaf_i} \leftarrow \max_{j = 1}^{leaf_i} \{f_{i - 1, j}\} + 1$$

这样我们可以进行暴力 dp，时间复杂度 $O(nm)$，带个 $5$ 的常数。

但是这样的复杂度不足以通过这题。怎么办呢？

#### 矩阵优化

我们发现 $f$ 的转移与 $i$ 无关，所以考虑矩阵优化（ddp）。

首先，我们有广义矩阵乘法：

$$c_{i,j} = \max \{a_{i,k} + b_{k,j}\}$$

那么上述第一个转移方程就可以写成

$$\left [\begin{matrix}0&-\infin&-\infin&-\infin&-\infin \\ -\infin&0&-\infin&-\infin&-\infin \\ -\infin&-\infin&0&-\infin&-\infin \\ -\infin&-\infin&-\infin&0&-\infin \\ -\infin&-\infin&-\infin&-\infin&0\end{matrix} \right ]$$

很好理解，$f_{i-1,j}$ 对 $f_{i,j}$ 贡献是 $0$；其它都没有贡献，所以是 $-\infin$。

那么考虑加入 $leaf_i$。加入以后就是每一列的 $0$ 之上（含 $0$）变成 $1$，如 $leaf_i = 3$ 的矩阵：

$$\left [\begin{matrix}0&-\infin&1&-\infin&-\infin \\ -\infin&0&1&-\infin&-\infin \\ -\infin&-\infin&1&-\infin&-\infin \\ -\infin&-\infin&-\infin&0&-\infin \\ -\infin&-\infin&-\infin&-\infin&0\end{matrix} \right ]$$

这列变成 $1$ 很好理解，因为它对最长不降序列的贡献是 $1$；而 $0$ 以下部分不改变，是因为不能从大的往小的贡献。

---

这样我们在每个点上都建好了矩阵。接下来我们考虑怎么转移。

我们可以倍增预处理矩阵们的乘积，然后像求 $\text{LCA}$ 一样乘矩阵，结果因为矩阵乘法满足结合律也对。

不过由于矩阵乘法不满足交换律，我们要预处理出从前往后和从后往前乘的两个倍增。除此之外，统计答案的时候也要分开算，最后再合并。

然后由于最长不降子序列也不满足交换律（倒过来答案不一样），所以不能偷懒（$dep_v > dep_u$ 的时候不能 `swap`）。

这样就做完了。时间复杂度 $O(m \log n)$，带个 $5^3$ 的常数。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 30005;

int n, m;

//链式前向星存边
struct edge {
    int to, leaf, nxt;
    edge() {}
    edge( int to, int leaf, int nxt ) : to( to ), leaf( leaf ), nxt( nxt ) {}
} e[N << 1];
int head[N], cnt;
void add( int u, int v, int leaf ) { e[++cnt] = edge( v, leaf, head[u] ), head[u] = cnt; }

//矩阵
struct mat {
    int a[6][6];

    //构建单位矩阵：让对角线变成0。
    inline void build1() { for( int i = 1; i <= 5; ++i ) a[i][i] = 0; }

    //leaf=i时的构造。
    inline void csh( int i ) { for( int j = 1; j <= i; ++j ) a[j][i] = 1; }

    //矩阵乘
    friend inline mat operator* ( const mat& a, const mat& b ) {
        mat c;
        for( int i = 1; i <= 5; ++i ) {
            for( int j = 1; j <= 5; ++j ) {
                for( int k = 1; k <= 5; ++k ) {
                    c.a[i][j] = max( c.a[i][j], a.a[i][k] + b.a[k][j] );
                }
            }
        }
        return c;
    }

    //构造即初始化，省去麻烦。（记得初始化是-inf）
    inline mat() { memset( a, -0x3f, sizeof a ); build1(); }
};

int fa[N][16], dep[N];
mat pre[N][16], suf[N][16];

//找出树形结构
void dfs( int u, int leaf ) {
    dep[u] = dep[fa[u][0]] + 1;
    pre[u][0].build1(), suf[u][0].build1();
    pre[u][0].csh( leaf ), suf[u][0].csh( leaf );
    for( int i = head[u]; i; i = e[i].nxt ) {
        int v = e[i].to, leaf = e[i].leaf;
        if( v == fa[u][0] ) continue;
        fa[v][0] = u;
        dfs( v, leaf );
    }
}

//预处理倍增
inline void prest() {
    for( int i = 1; i <= 15; ++i ) {
        for( int j = 1; j <= n; ++j ) {
            fa[j][i] = fa[fa[j][i - 1]][i - 1];

            //注意这里pre和suf处理要反过来。
            pre[j][i] = pre[j][i - 1] * pre[fa[j][i - 1]][i - 1];
            suf[j][i] = suf[fa[j][i - 1]][i - 1] * suf[j][i - 1];
        }
    }
}

//倍增
inline int solve( int u, int v ) {
    //初始矩阵记得构造单位矩阵。
    mat ansf, ansb; ansf.build1(), ansb.build1();

    //其实没有这行应该也可以（？）
    if( u == v ) return 0;

    //if( dep[v] > dep[u] ) swap( u, v );//这句万万不能有！！！不能交换！！！

    //往上跳
    int dis = dep[u] - dep[v];
    if( dis > 0 ) { 
        for( int i = 0; ( 1 << i ) <= dis; ++i ) 
            if( dis & ( 1 << i ) ) ansf = ansf * pre[u][i], u = fa[u][i];
    }//<-作者由于不想写这个大括号导致else if判成里面的了调了1h
    else if( dis < 0 ) {
        dis = -dis;
        for( int i = 0; ( 1 << i ) <= dis; ++i ) 
            if( dis & ( 1 << i ) ) ansb = suf[v][i] * ansb, v = fa[v][i];
    }

    if( u == v ) {
        int ans = 0;

        //由于分开来算，所以统计的时候两个都要统计。
        for( int i = 1; i <= 5; ++i ) for( int j = 1; j <= 5; ++j ) ans = max( ans, max( ansf.a[i][j], ansb.a[i][j] ) );

        return ans;
    }

    //开始倍增，注意乘的顺序。
    for( int i = 15; i >= 0; --i ) {
        int j = i;
        while( fa[u][j] == fa[v][j] && j >= 0 ) --j;
        if( j < 0 ) break;
        ansf = ansf * pre[u][j], ansb = suf[v][j] * ansb;
        u = fa[u][j], v = fa[v][j];
        i = j;
    }

    //还要乘上它到它父亲的贡献
    if( u != v ) ansf = ansf * pre[u][0] * suf[v][0] * ansb;

    //统计答案
    int ans = 0;
    for( int i = 1; i <= 5; ++i ) for( int j = 1; j <= 5; ++j ) ans = max( ans, ansf.a[i][j] );
    return ans;
}

int main() {
    ios::sync_with_stdio( 0 ), cin.tie( 0 ), cout.tie( 0 );
    cin >> n;
    for( int i = 1; i < n; ++i ) {
        int u, v, leaf;
        cin >> u >> v >> leaf;
        add( u, v, leaf ), add( v, u, leaf );
    }
    dfs( 1, 0 );
    prest();
    cin >> m;
    while( m-- ) {
        int u, v;
        cin >> u >> v;
        cout << solve( u, v ) << endl;
    }
    return 0;
}
```

---

> 画师看着长为 $10000$ 的链陷入了沉思……
>
> “我当年可没画那么多片枫叶啊……”

---

## 作者：Thunder_S (赞：2)

## Solution

注意到边权极小，考虑从此突破。

对于一个序列，我们可以枚举起始值和终止值，然后求出满足值在起始值和终止值之间的最长不下降子序列。假如我们求出了若干序列的上述答案，那么我们就可以将题目所求路径分成若干序列，枚举序列交界处的值，那么有转移 $dp_{i,x}=\max(dp_{i-1,y}+g_{i,y,x})$。其中 $dp_{i,x}$ 表示求完前 $i$ 个序列，当前终止值为 $x$ 的最长不下降子序列，$g_{i,x,y}$ 表示对于序列 $i$，起始值是 $y$，终止值是 $x$ 的最长不下降子序列。转移本质就是枚举当前序列的起始值是什么，而当前序列的起始值就是上一个序列的终止值。

但问题是对于不同的询问，预先要求的序列也是不同的。那么如何找到一些序列，使其可以去表示所有的路径呢？显然可以用树剖或者倍增。这里考虑使用倍增。

改变一下上面 $g$ 数组的定义。设 $g_{x,i,a,b}$ 表示从节点 $x$ 开始，向上走 $2^{i-1}$ 条边，起始值为 $a$，终止值为 $b$ 的最长不下降子序列。$g$ 同样可以用倍增来得到，只需要枚举交界处的值是什么即可。$g_{u,i,a,b}=\max(g_{u,i-1,a,c}+g_{v,i-1,c,b})$（$v$ 表示 $u$ 的第 $2^{i-1}$ 级祖先）。

但是 $x\to lca\to y$ 的过程中，$x\to lca$ 是向上走没错，但是 $lca\to y$ 是向下走，但我们只能维护向上的值。因此我们还需要求出从 $y$ 向上走的最长不上升子序列，求法和求最长不下降子序列是类似的，在此不过多赘述。这里将最长不下降记为 $g1$，最长不上升记为 $g2$。

至此，我们就已完成了本题。首先我们要预处理出 $g1$ 和 $g2$。然后对于每条路径，从 $x$ 或 $y$ 向 $lca$ 跳的时候，将若干 $2$ 的次方长度的路径看作若干个序列，用上文求 $dp$ 的做法转移（此时 $dp$ 可以设为 $dp_{x,i}$ 表示到了节点 $x$，值为 $i$ 的最长不下降（或上升）子序列）。最后枚举 $lca$ 处的值是多少，$ans=\max(dp^{x\to lca}_{lca,i}+dp^{y\to lca}_{lca,i})$。

注意一些小优化，比如说在求 $lca$ 的时候就可以同时求 $dp$，$g1$ 和 $g2$ 数组可以合并称一个数组 $g$，用 $a$ 和 $b$ 的大小关系表示不下降还是不上升。时间复杂度 $\mathcal O(5^3N\log N+5^2M\log N)$，但远远达不到。目前是最优解。

## Code
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 30005
using namespace std;
int n,m,tot,ans,f[N][20],dep[N],dp1[N][6],dp2[N][6],g[N][20][6][6];
struct node {int to,next,head,val;}a[N<<1];
int read()
{
	int res=0;char ch=getchar();
	while (ch<'0'||ch>'9') ch=getchar();
	while (ch>='0'&&ch<='9') res=(res<<1)+(res<<3)+(ch-'0'),ch=getchar();
	return res;
}
void add(int x,int y,int z)
{
	a[++tot].to=y;a[tot].val=z;a[tot].next=a[x].head;a[x].head=tot;
	a[++tot].to=x;a[tot].val=z;a[tot].next=a[y].head;a[y].head=tot;
}
void dfs(int x,int fa)
{
	f[x][0]=fa;dep[x]=dep[fa]+1;
	for (int i=a[x].head;i;i=a[i].next)
	{
		int y=a[i].to,z=a[i].val;
		if (y==fa) continue;
		for (int z1=1;z1<=z;++z1)
			for (int z2=z;z2<=5;++z2)
			{
				g[y][0][z1][z2]=1;
				g[y][0][z2][z1]=1;
			}
		dfs(y,x);
	}
}
int LCA(int x,int y)
{	
	for (int i=1;i<=5;++i)
		dp1[x][i]=dp2[y][i]=0;
	if (dep[x]>dep[y])
	{
        for (int i=14;i>=0;--i)
        {
            if (dep[f[x][i]]>=dep[y]) 
            {
            	for (int j=1;j<=5;++j)
            		dp1[f[x][i]][j]=0;
                for (int j=1;j<=5;++j)
                    for (int k=j;k<=5;++k)
                        dp1[f[x][i]][k]=max(dp1[f[x][i]][k],dp1[x][j]+g[x][i][j][k]);
                x=f[x][i];
            }
        }
    }
    else
    {
        for (int i=14;i>=0;--i)
        {
            if (dep[f[y][i]]>=dep[x]) 
            {
            	for (int j=1;j<=5;++j)
            		dp2[f[y][i]][j]=0;
                for (int j=1;j<=5;++j)
                    for (int k=1;k<=j;++k)
                        dp2[f[y][i]][k]=max(dp2[f[y][i]][k],dp2[y][j]+g[y][i][j][k]);
                y=f[y][i];
            }
        }
    }
	if (x==y) return x;
	for (int i=14;i>=0;--i)
	{
		if (f[x][i]!=f[y][i]) 
		{
			for (int j=1;j<=5;++j)
				dp1[f[x][i]][j]=dp2[f[y][i]][j]=0;
			for (int j=1;j<=5;++j)
				for (int k=1;k<=5;++k)
				{
					if (k>=j) dp1[f[x][i]][k]=max(dp1[f[x][i]][k],dp1[x][j]+g[x][i][j][k]);
					if (k<=j) dp2[f[y][i]][k]=max(dp2[f[y][i]][k],dp2[y][j]+g[y][i][j][k]);
				}
			x=f[x][i];y=f[y][i];
		}	
	}
	for (int j=1;j<=5;++j)
		dp1[f[x][0]][j]=dp2[f[y][0]][j]=0;
	for (int j=1;j<=5;++j)
		for (int k=1;k<=5;++k)
		{
			if (k>=j) dp1[f[x][0]][k]=max(dp1[f[x][0]][k],dp1[x][j]+g[x][0][j][k]);
			if (k<=j) dp2[f[y][0]][k]=max(dp2[f[y][0]][k],dp2[y][j]+g[y][0][j][k]);
		}
	return f[x][0];
}
int main()
{
	n=read();
	for (int i=1;i<n;++i)
	{
		int x,y,z;
		x=read();y=read();z=read();
		add(x,y,z);
	}
	dfs(1,0);
	for (int i=0;i<14;++i)
	{
		bool flag=false;
		for (int u=2;u<=n;++u)
		{
			int v=f[u][i];
			if (!f[v][i]) continue;
			f[u][i+1]=f[v][i];
			flag=true;
			for (int x=1;x<=5;++x)
				for (int z=x+1;z<=5;++z)
					for (int y=x;y<=z;++y)
					{
						g[u][i+1][x][z]=max(g[u][i+1][x][z],g[u][i][x][y]+g[v][i][y][z]);
						g[u][i+1][z][x]=max(g[u][i+1][z][x],g[u][i][z][y]+g[v][i][y][x]);
					}
			for (int x=1;x<=5;++x)
				g[u][i+1][x][x]=g[u][i][x][x]+g[v][i][x][x];
		}
		if (!flag) break;
	}
	m=read();
	for (int i=1;i<=m;++i)
	{
		int x,y;
		x=read();y=read();
		int lca=LCA(x,y);
		ans=0;
		for (int i=1;i<=5;++i)
			ans=max(ans,dp1[lca][i]+dp2[lca][i]);
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：Yzweak (赞：2)

本题成题于去年$Noip$结束后，被欺负之后仿照保卫王国的形式（四维倍增）出了这样一道题。

然后当时还沉迷于b站[忘川风华录](https://space.bilibili.com/326258472?from=search&seid=8023980733684180485)（事实上现在还在沉迷），然后就有了这样一道诡异的题目。

建议结合[Noip2018保卫王国](https://www.luogu.org/problem/P5024)食用
## 题意简述：
有一棵$30000$节点的树，每条边有一个权值，权值为$1$~$5$之间的整数，现在有$300000$个询问，每次询问$x$节点到$y$节点路径上的最长不下降子序列长度。

## Solution
首先经典的最长不下降子序列算法肯定不会是正解。毕竟一次查询$NlogN$ 肯定吃不消，~~（但是由于出题人懒惰竟然放卡常的暴力过了）~~


我们再考虑这样一个求最长不下降子序列的$dp$

设$f[i][j]$表示前$i$个数以数字$j$为结尾的最长不下降子序列的长度。

易得转移方程

$f[i][j]=max(f[i-1][l]+1)$$(l<=k)$

当然这个转移方程在正常情况下非常没用，连优化时间复杂度都做不到，不过在这一题里所有数为$1$~$5$，于是计算一次最长不下降子序列的复杂度降为$O(N)$级别。

这样还是不够。

我们用倍增思考这个问题：
考虑到权值均为1~5的整数，我们设计一个这样的G数组：
```
G[x][i][j][k]
```
这个数组表示这样一个意义：从$x$节点到$x$的$2^{i}$级祖先之间的路径上，最小值大于等于$j$，最大值小于等于$k$的最长不上升子序列的长度。
这样我们可以比较好地维护G数组：
```
for(int l=0;l<=15;l++) 
{ 
f[u][l+1]=f[f[u][l]][l]; 
if(f[u][l+1]==0) continue; 
for(int i=1;i<=5;++i) 
for(int j=1;j<=5;++j) 
for(intk=min(i,j);k<=max(i,j);++k) 
G[u][l+1][i][j]=max(G[u][l][i][k]+G[f[u][l]][l][k][j],G[u][l+1][i][j]); 
}
```
通过枚举中间断点的值DP。

```G[u][l+1][i][j]=max(G[u][l][i][k]+G[f[u][l]][l][k][j],G[u][l+1][i][j])```

这样，我们就利用$G$数组把链上的信息缩成了$logN$个点，把一个最坏情况下长度为$N$的序列变成了长度为$logN$的序列，
现在我们在求$LCA$的时候，顺便把每次跳的深度记录下来，压到两个数组里：
```
inline void prepare_LCA(int x,int y) 
{ if(deep[x]<deep[y]) swap(x,y),Flag=1; 
for(int i=15;i>=0;--i) 
if(deep[f[x][i]]>=deep[y]) p[++p_tot]=i,x=f[x][i]; 
if(x==y) return; 
for(int i=15;i>=0;--i) 
if(f[x][i]!=f[y][i]) 
{ 
p[++p_tot]=q[++q_tot]=i; 
x=f[x][i];y=f[y][i]; } 
}
p[++p_tot]=q[++q_tot]=0; return; 
```

其中$p,q$数组就是$x$节点和$y$节点到$lca$这段路所跳过的$i$值，这样方便我们跳点，找到下一个断点。
$p,q$长度均为$log$级别，而且它们很好的将这个序列缩成了$logN$个点。
这样，我们就把问题转化成确定每一个断点的值，使他们总和加起来最大。
我们就可以用简单的$dp$处理这个问题了,以$p$数组为例，可以设计如下方程：

$dp[i][j]=max(dp[i-1][k]+G[x][p[i]][k][j])$

即：缩成$log$长度的序列里，第$i$个节点，值为$j$时的最长不下降子序列的长度，然后像预处理一样进行$dp$。
$a$数组和$b$数组就是$p$，$q$数组，由于$dp$数组范围在$log$级别，可以在短时间内得出结果。
```
int solve(int x,int y,int *a,int size_a,int *b,int size_b) { 
for(int i=1;i<=size_a;++i) 
{ for(int j=1;j<=5;++j) 
for(int k=1;k<=j;++k) 
dp[1][i][j]=max(dp[1][i][j],dp[1][i-1][k]+G[x][a[i]][k][j]); x=f[x][a[i]]; 
} 
for(int i=1;i<=size_b;++i) 
{ 
for(int j=5;j>=1;--j) 
for(int k=5;k>=j;--k) 
dp[2][i][j]=max(dp[2][i][j],dp[2][i-1][k]+G[y][b[i]][k][j]); y=f[y][b[i]]; 
} 
int Ans=0; 
for(int i=1;i<=5;++i) 
Ans=max(Ans,dp[1][size_a][i]+dp[2][size_b][i]); 
return Ans; 
}
```
同时在这一题里，需要注意从$y$节点向上记录的$q$数组要求的是最长不上升子序列，才能使两个$dp$结果在$LCA$处进行合并。处理的方法同最长不下降子序列。注意倍增求$LCA$时$x,y$位置可能会互换，解决方法就是如上面代码一样传参进行$dp$。

下面给出完整代码：
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#define RG register 
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
#define N 30001
using namespace std;
struct Edge
{
    int to,Next,Leaf;
}e[N<<1];
int f[N][17],G[N][17][6][6],p[17],q[17],p_tot,q_tot,dp[3][18][6],tot,last[N],n;
int deep[N];
bool Flag=0;
inline int read()
{
    RG int res=0,flag=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')flag=-1;c=getchar();}
    while(c>='0'&&c<='9'){res=(res<<3)+(res<<1)+(c^48);c=getchar();}
    return flag*res;
}
inline void Add_Edge()
{
    RG int x=read(),y=read(),c=read();
    e[++tot]=(Edge){y,last[x],c};last[x]=tot;
    e[++tot]=(Edge){x,last[y],c};last[y]=tot;
}
void Deal_first(int u,int fa)
{
      deep[u]=deep[fa]+1;
      for(RG int l=0;l<=15;l++)
      {
        f[u][l+1]=f[f[u][l]][l];
        if(f[u][l+1]==0) continue; 
        for(RG int i=1;i<=5;++i)
         for(RG int j=1;j<=5;++j)
          for(RG int k=min(i,j);k<=max(i,j);++k)
          G[u][l+1][i][j]=max(G[u][l][i][k]+G[f[u][l]][l][k][j],G[u][l+1][i][j]);
      }

      for(RG int k=last[u];k;k=e[k].Next)
      {
          int to=e[k].to;
          if(to==fa) continue;
          f[to][0]=u;
          for(RG int i=1;i<=5;++i)
           for(RG int j=1;j<=5;++j)
           if(max(i,j)>=e[k].Leaf&&min(i,j)<=e[k].Leaf) 
           G[to][0][i][j]=1;
           Deal_first(to,u);
      }
}
inline int solve(RG int x,RG int y,int *a,RG int size_a,int *b,RG int size_b)
{
    for(RG int i=1;i<=size_a;++i)
	{
		for(RG int j=1;j<=5;++j)
		 for(RG int k=1;k<=j;++k)
		 dp[1][i][j]=max(dp[1][i][j],dp[1][i-1][k]+G[x][a[i]][k][j]);
	   	x=f[x][a[i]];
	}
	for(RG int i=1;i<=size_b;++i)
	{
		for(RG int j=5;j>=1;--j)
		 for(RG int k=5;k>=j;--k)
		 dp[2][i][j]=max(dp[2][i][j],dp[2][i-1][k]+G[y][b[i]][k][j]);
		y=f[y][b[i]];
	}
	RG int Ans=0;
	for(RG int i=1;i<=5;++i) Ans=max(Ans,dp[1][size_a][i]+dp[2][size_b][i]);
	return Ans;  
}
inline void prepare_LCA(RG int x,RG int y)
{
    if(deep[x]<deep[y]) swap(x,y),Flag=1;
    for(RG int i=15;i>=0;--i)
    if(deep[f[x][i]]>=deep[y]) 
	p[++p_tot]=i,x=f[x][i];
    if(x==y) return;
    for(RG int i=15;i>=0;--i)
    if(f[x][i]!=f[y][i])
    {
       p[++p_tot]=q[++q_tot]=i;
       x=f[x][i];y=f[y][i];
    }
    p[++p_tot]=q[++q_tot]=0;
    return;
}
int main()
{
	freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);
    n=read();
    for(RG int i=1;i<n;++i) Add_Edge();
    RG int m=read();
    Deal_first(1,0);
    while(m--)
    {
        memset(dp,0,sizeof(dp));
		int x=read(),y=read();
        Flag=0;p_tot=0;q_tot=0;
        prepare_LCA(x,y);
        printf("%d\n",Flag?solve(x,y,q,q_tot,p,p_tot):solve(x,y,p,p_tot,q,q_tot)); 
    }   
}
```
T3题解：https://www.cnblogs.com/dwqhca/p/11412064.html


---

## 作者：rdfzzyy (赞：2)

一个(~~常数略大~~)的 $O(MlogN)$ 解法

注：以下说明中的数列均不要求长度 $≥3$，一个数也可以称为数列（毕竟一个数的数列也可以求最长不降/不升子序列）

关于题目，用一句话描述就是 “给定起点终点，其路径上所有边权按顺序组成数列（也就是之后所说的‘链的数列’），求该数列最长不降子序列长度”

最容易想到的想法大概就是找出路径，用效率为 $nlogn$ ( $n$ 为序列长度) 的求最长不降子序列算法解决 (详见P1020导弹拦截) ，不过这样总时间复杂度就是 $O(MNlogN)$ ，很明显会超时

但注意到边权范围很小 $(1 ≤ leaf_i ≤ 5)$ 后，可以使用一个 5×5 大小的表格 $T$ 记录下一段数列的特征，其中 $T[m][n] (1 ≤ m, n ≤ 5)$ 的含义如下：

1. $m < n$ 时: 数列中首项 $≥m$ ，末项 $≤n$ 的最长不降子序列的长度
2. $m == n$ 时: 数列中首项末项均为 $m$ 的最长不升/不降子序列的长度 （也就是数列中 $m$ 的个数）
3. $m > n$ 时: 数列中首项 $≤m$ ，末项 $≥n$ 的最长不升子序列的长度

这样我们就可以在常数时间(~~虽然有点大~~)内合并两个数列，设在前的数列为 $a$ ，在后的数列为 $b$ ，合并后的数列为 $c$ ，则有规律：$T_c[i][j] = max(T_a[i][k] + T_b[k][j])$ (i ≤ k ≤ j 或 j ≤ k ≤ i ) 

之后求表格T的思路和倍增LCA一样。在一开始从自己定义的树根 (一般是1) 开始DFS求父节点时候顺便求出到父节点的路径上边权组成的数列 (长度是1) 的表格 $T$ ，之后在倍增LCA求 $2^k-par$ 时顺便倍增求出到 $2^k-par$ 的路径上边权组成的数列的表格 $T$ ，在询问中倍增LCA每次跳跃时将新跳过的链的数列的表格 $T$ 与之前已有的链的数列的表格 $T$ 合并，最终用 $S->LCA$ 链的数列的最长不降子序列和 $T->LCA$ 链的数列的最长不升子序列合并出 ans ($S->T$的最长不降子序列长度)，具体来说，$ans = max(T_{S->LCA}[1][k] + T_{T->LCA}[5][k]) (1 ≤ k ≤ 5)$

至于长度为 1 的数列的表格 T 的求法其实根据表格 $T$ 的定义就能得出，这里不再列举公式(~~才不是因为打不出多行公式呢~~)，简单概括一下就是数列中那唯一一个元素的值如果处在一个格行数的值和列数的值之间(含等于)则这个格值为 1 ，否则为 0 

代码如下：
```cpp
# include <cstdio>
# define MAX 30010
using namespace std;

struct tb{
	int tb[5][5];
	inline void clear(){
		for(int i = 0; i < 5; ++i)
			for(int j = 0; j < 5; ++j)
				tb[i][j] = 0;
	}
};

int N, M, S, T, V[MAX], E[2*MAX][2], cost[MAX];
int kp[MAX][16], pc[MAX], depth[MAX], ans, tmp;
// kp[i][j] 为 i号点的 2^j-祖先 , 0 号为自己 
tb table[MAX][16], ansT, ansS;
// table[m][n].tb[i][j] 为从 m 号点到其 2^n-祖先的路径上，从 i 到 j 的最长不降/不升子序列长度 
bool yes;

void DFS(int pos){
	for(int i = V[pos]; i; i = E[i][1]){
		if(E[i][0] == kp[pos][0]) continue;
		kp[E[i][0]][0] = pos;
		pc[E[i][0]] = cost[i/2];
		depth[E[i][0]] = depth[pos] + 1;
		DFS(E[i][0]);
	}
	for(int i = 0; i <= pc[pos]; ++i)
		for(int j = pc[pos]; j < 5; ++j){
			++table[pos][0].tb[i][j];
			++table[pos][0].tb[j][i];
		}
	--table[pos][0].tb[pc[pos]][pc[pos]];
}

void merge(tb a, tb b, tb &c){ //矩阵 T 的合并
	c.clear();
	for(int i = 0; i < 5; ++i){
		for(int j = i + 1; j < 5; ++j){
			for(int k = i; k <= j; ++k){
				if(c.tb[i][j] < a.tb[i][k] + b.tb[k][j])
					c.tb[i][j] = a.tb[i][k] + b.tb[k][j];
				if(c.tb[j][i] < a.tb[j][k] + b.tb[k][i])
					c.tb[j][i] = a.tb[j][k] + b.tb[k][i];
			}
		}
		c.tb[i][i] = a.tb[i][i] + b.tb[i][i];
	}
}

inline void swap(int &a, int &b){ a ^= b, b ^= a, a ^= b; }

int main(){
	scanf("%d", &N);
	for(int i = 1; i < N; ++i){
		scanf("%d%d%d", &E[2*i][0], &E[2*i + 1][0], &cost[i]);
		E[2*i + 1][1] = V[E[2*i][0]];
		V[E[2*i][0]] = 2*i + 1;
		E[2*i][1] = V[E[2*i + 1][0]];
		V[E[2*i + 1][0]] = 2*i;
		--cost[i];
	}
	DFS(1);
	for(int i = 0; i < 14; ++i){ //倍增
		for(int j = 2; j <= N; ++j){
			if(!kp[kp[j][i]][i]) continue;
			kp[j][i + 1] = kp[kp[j][i]][i];
			merge(table[j][i], table[kp[j][i]][i], table[j][i + 1]);
			yes = true;
		}
		if(!yes) break; //及时跳出循环
		yes = false;
	}
	scanf("%d", &M);
	while(M--){
		scanf("%d%d", &S, &T);
		if(depth[S] > depth[T]) swap(S, T), yes = true; //交换是为了方便处理，另外需要记录一下是否交换，防止搞反
		tmp = depth[T] - depth[S];
		for(int i = 0; tmp; tmp >>= 1, ++i){ //移动到同一高度
			if(!(tmp & 1)) continue;
			merge(ansT, table[T][i], ansT);
			T = kp[T][i];
		}
		while(S != T){
			for(tmp = 0; kp[S][tmp] != kp[T][tmp]; ++tmp);
			if(tmp) --tmp;
			merge(ansS, table[S][tmp], ansS), S = kp[S][tmp];
			merge(ansT, table[T][tmp], ansT), T = kp[T][tmp];
		}
		for(int i = 0; i < 5; ++i){ //合并 S->LCA 和 T->LCA
			tmp = yes ? ansT.tb[0][i] + ansS.tb[4][i] : ansS.tb[0][i] + ansT.tb[4][i];
			if(tmp > ans) ans = tmp;
		}
		printf("%d\n", ans);
		yes = false, ans = 0; //变量清零
		ansT.clear(), ansS.clear();
	}
	return 0;
}
```

附[提交记录](https://www.luogu.org/record/23934510)，可以看见时间效率还算不错，在没有开O2优化也没有用快读等优化时仍然跑进了一秒以内

---

## 作者：daniEl_lElE (赞：1)

值域很小，从值域突破。先考虑序列上的区间 LIS。考虑分治，用猫树处理所有的询问，两侧 $dp_{i,j,k}$ 表示 $i$ 位置，值域 $j\sim k$ 区间内的 LIS。每次向左向右扩展一个可以前缀/后缀 $\max$ 快速转移。询问只需要枚举中间点即可。总复杂度 $O(nV^2\log n+m(\log n+V))$，其中 $V$ 为值域。

考虑如何扔到树上。区间上可以分治是因为这样做可以保证每个点最多只被处理 $O(\log n)$ 次。树上同样可以使用点分治。每次找出重心，进行一遍 dp，算出所有跨过重心的询问的答案。同样是 $O(nV^2\log n+m(\log n+V))$ 的。

目前最优解。

```cpp
#include <bits/stdc++.h>
#define mid ((l+r)>>1)
using namespace std;
vector<pair<int,int>> vc[30005];
bool vis[30005];
int rt,siz[30005],tot,minv;
void getsiz(int now,int fa){
	siz[now]=1;
	for(auto v:vc[now]){
		if(v.first==fa||vis[v.first]) continue;
		getsiz(v.first,now);
		siz[now]+=siz[v.first];
	}
}
void findrt(int now,int fa){
	int maxv=0;
	siz[now]=1;
	for(auto v:vc[now]){
		if(v.first==fa||vis[v.first]) continue;
		findrt(v.first,now);
		siz[now]+=siz[v.first];
		maxv=max(maxv,siz[v.first]);
	}
	maxv=max(maxv,tot-siz[now]);
	if(maxv<minv){
		minv=maxv,rt=now;
	}
}
int dp1[30005][6][6],dp2[30005][6][6],bel[30005];
void cal(int now,int fa,int tp){
	bel[now]=tp;
	for(auto v:vc[now]){
		if(v.first==fa||vis[v.first]) continue;
		for(int i=1;i<=5;i++){
			int maxv=0;
			for(int j=i;j>=1;j--){
				maxv=max(maxv,dp1[now][j][i]);
				if(j==v.second) maxv++;
				dp1[v.first][j][i]=maxv;
			}
			maxv=0;
			for(int j=i;j<=5;j++){
				maxv=max(maxv,dp2[now][i][j]);
				if(j==v.second) maxv++;
				dp2[v.first][i][j]=maxv;
			}
		}
		if(now==rt) tp=v.first;
		cal(v.first,now,tp);
	}
}
vector<pair<pair<int,int>,int>> qry[30005];
int ans[300005];
void dfs(int now,int dep){
	memset(dp1[now],0,sizeof(dp1[now]));
	memset(dp2[now],0,sizeof(dp2[now]));
	cal(now,0,0);
	for(auto v:qry[now]){
		if(bel[v.first.first]!=bel[v.first.second]){
			for(int i=1;i<=5;i++){
				ans[v.second]=max(ans[v.second],dp1[v.first.first][1][i]+dp2[v.first.second][i][5]);
			}
		}
		else{
			qry[bel[v.first.first]].push_back(v);
		}
	}
	qry[now].clear();
	qry[now].shrink_to_fit();
	vis[now]=1;
	for(auto v:vc[now]){
		if(vis[v.first]) continue;
		rt=0;
		getsiz(v.first,now);
		tot=siz[v.first],minv=1e9;
		findrt(v.first,now);
		swap(qry[rt],qry[v.first]);
		dfs(rt,dep+1);
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int n; cin>>n;
	for(int i=1;i<=n;i++) vis[i]=0,vc[i].clear();
	for(int i=1;i<n;i++){
		int u,v,w; cin>>u>>v>>w;
		vc[u].push_back(make_pair(v,w));
		vc[v].push_back(make_pair(u,w));
	}
	minv=1e9;
	tot=n;
	findrt(1,0);
	int q; cin>>q;
	for(int i=1;i<=q;i++){
		int s,t; cin>>s>>t;
 		qry[rt].push_back(make_pair(make_pair(s,t),i));
	}
	dfs(rt,1);
	for(int i=1;i<=q;i++) cout<<ans[i]<<"\n";
	return 0; 
}
```

---

## 作者：hehelego (赞：1)

### P5558心上秋
题意: 给一个树,无修改,静态树结构,**极小值域**($0\lt w\leq 5$).多次询问某条链的最长不减子序列.  

---

考虑序列上的玩法,记$f_{i,k}$为全部元素来自$1..i$,末尾元素为$k$的最长上升子序列的长度.考虑新加入一个点$a_{i+1}=k_0$做转移   
$f_{i+1,p}=f_{i,p}(p\neq k_0)$.  
$f_{i+1,k_0}=max_{j\leq k_0}(f_{i,j}+1)$.  

将这一转移表示为max of sum的矩阵乘法,写出不同权值的转移矩阵和单位矩阵.  
可以进行验证(或者根据乘法就是转移的实际意义理解)定义的**max of sum矩阵乘法满足结合律**(并不满足交换律).  

$$
(AB)_{i,j}=\max_{k=1}^5(A_{i,k}+B_{k,j})
\quad 0\lt i,j\leq5
$$

$E=\begin{bmatrix}
0&\infty&\infty&\infty&\infty\\
\infty&0&\infty&\infty&\infty\\ \infty&\infty&0&\infty&\infty\\ \infty&\infty&\infty&0&\infty\\ \infty&\infty&\infty&\infty&0\\
\end{bmatrix}$

给出$a_i=3$的转移矩阵,其他权值类似,即将$a_i=k$的$k$行中,列不超过$k$的元素设位1,其余保留单位矩阵的元素.
$A_3=\begin{bmatrix}
0&\infty&\infty&\infty&\infty\\
\infty&0&\infty&\infty&\infty\\
1&1&1&\infty&\infty\\
\infty&\infty&\infty&0&\infty\\ \infty&\infty&\infty&\infty&0\\
\end{bmatrix}$

发现max of sum矩阵乘法(转移过程)有**结合律**我们可以轻松解决序列上的subtask,使用您喜欢的数据结构维护区间乘积(***注意***,由于这个乘法没有交换律,需要维护左向右和右向左两个顺序的乘积,显然$Query(S,T)$并非恒等于$Query(T,S)$).另一方面,极小值域的条件,使得乘法的高空间/时间复杂度变得可以接受,稍作分析和估算,这一做法可以完成序列上的subtask.  

----

~~上树.jpg~~ 这部分就显得较为简单了,我们将$S\rightarrow T$拆分为$S\rightarrow LCA\rightarrow T$.由于结合律的存在,我们可以分别算出两部分的转移矩阵乘积再计算答案.  
考虑维护$f_{u,k},g_{u,k}=\prod_{i=1}^{2^k}fa^i(u),\prod_{i=1}^{2^k}fa^{2^k-i}(u)$即向上或向下到$2^k$祖先,经过的边的序列的转移矩阵乘积.  
前一部分是$g$,后一部分是$f$仍然注意并没有交换律.  
当然我们也可以写HLD+SGT来做.复杂度多一个$logn$但是仍然可以过.使用HLD的时候也也要注意运算顺序的问题,最好不要两边一起向LCA跳...另外HLD不方便处理边的问题,将$(fa_u,u,w)$中的$w$下放到点$u$可以解决,但是$S\rightarrow lca\rightarrow T$中的$w_{lca}$的  其实是来自于$(fa_{lca},lca,w)$这条边并非在$s,t$的路径上.  


---
最后给出代码(HLD+SGT),人懒没写倍增.jpg

```cpp
#include <bits/stdc++.h>
int read(){
	int x=0;char c;
	do{c=getchar();}while(!isdigit(c));
	do{x=x*10+c-'0';c=getchar();}while(isdigit(c));
	return x;
}
const int N=30000+10;
const int INF=1e8;
const int K=5;
struct M{
	int a[K][K];
// 这里为了方标找index...把w-1传入了.
	M(int x=-1){ //0,1,2,3,4
		for(int i=0;i<K;i++) for(int j=0;j<K;j++)
			a[i][j]=-INF;
		for(int i=0;i<K;i++) a[i][i]=0;
// 上面是单位矩阵,下面修改后变为A_{x}转移矩阵.
		if(x>=0) for(int i=0;i<=x;i++) a[x][i]=1;
	}
	int* operator[](int x){ return a[x];}
	const int* operator[](int x)const{ return a[x];}
};
M operator*(const M&A,const M&B){
	M C; for(int i=0;i<K;i++) for(int j=0;j<K;j++){
// 注意初值,这个转移选-INF,0都没问题的.
		int t=-INF;for(int k=0;k<K;k++)
			t=std::max(t,A[i][k]+B[k][j]);
		C[i][j]=t;
	} return C;
}
struct E{ int v,w; E(int a,int b){v=a;w=b;} };
std::vector<E> g[N];
//begin:HLD
int n,fa[N],size[N],dep[N],son[N],in[N];
int idx,dfn[N],top[N],qwq[N];
void dfs1(int u,int f){
	size[u]=f;dep[u]=dep[fa[u]=f]+1;
	for(int i=0;i<g[u].size();i++){
		int v=g[u][i].v; if(v==f) continue;
		dfs1(v,u); size[u]+=size[v]; in[v]=g[u][i].w;
		if(size[son[u]]<size[v]) son[u]=v;
	}
}
void dfs2(int u,int f){
	qwq[dfn[u]=++idx]=in[u]; top[u]=f;
	if(son[u]) dfs2(son[u],f);
	for(int i=0;i<g[u].size();i++){
		int v=g[u][i].v; if(dfn[v]==0) dfs2(v,v);
	}
}
// end:HLD

// begin:SGT
int L[N<<2],R[N<<2];
M t[N<<2][2];
#define lc (o<<1)
#define rc ((o<<1)|1)
inline void pushup(int o){
	t[o][0]=t[rc][0]*t[lc][0];
	t[o][1]=t[lc][1]*t[rc][1];
}
void build(int o,int l,int r){
	L[o]=l;R[o]=r; int mid=(l+r)>>1;
	if(l==r){ t[o][0]=t[o][1]=M(qwq[l]); return ;}
	build(lc,l,mid); build(rc,mid+1,r);
	pushup(o);
}
M tmp;
void qry(int o,int l,int r,int f){
	if(L[o]>r||R[o]<l) return ;
	if(l<=L[o]&&R[o]<=r){//注意两个方向的不同(这是没有交换律造成的),0是L->R,1是R->L.
		if(f==0) tmp=t[o][0]*tmp;
		else tmp=tmp*t[o][1];
		return;
	}
	qry(lc,l,r,f); qry(rc,l,r,f);
}
inline void qry(int l,int r,int f){ tmp=M(); qry(1,l,r,f); }
int lca(int x,int y){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) std::swap(x,y);
		x=fa[top[x]];
	}
	if(dep[x]<dep[y]) std::swap(x,y);
	return y;
}
// end:SGT

struct S{ int l,r,f; S(int a,int b,int c):l(a),r(b),f(c){} };
std::vector<S> vec[2];
int query(int x,int y){
	int ret=0,w=lca(x,y);
	vec[0].clear(); vec[1].clear();
	while(top[x]!=top[w]){
		vec[1].push_back(S(dfn[top[x]],dfn[x],1));
		x=fa[top[x]];
	} vec[1].push_back(S(dfn[w]+1,dfn[x],1));
	while(top[y]!=top[w]){
		vec[0].push_back(S(dfn[top[y]],dfn[y],0));
		y=fa[top[y]];
	} vec[0].push_back(S(dfn[w]+1,dfn[y],0));
// 这里为了方便搞把拆分出来的dfs序区间提出来分别乘了...提交记录里面WA了6次都是这个顺序没搞对.jpg
	M QAQ;// 考虑实际意义,应该先乘S->LCA中dep大的点到S->LCA中dep小的点.最后是LCA->T,先dep小的点.
	for(auto x:vec[1]){ qry(x.l,x.r,1); QAQ=tmp*QAQ; }
	for(int i=int(vec[0].size())-1;i>=0;i--){
		auto x=vec[0][i]; qry(x.l,x.r,0);
		QAQ=tmp*QAQ;
	}
	for(int i=0;i<K;i++) for(int j=0;j<K;j++)
		ret=std::max(ret,QAQ[i][j]);
	return ret;
}

int main(){
	//freopen("in","r",stdin);
	n=read();for(int i=1,a,b,c;i<n;i++){
		a=read();b=read();c=read()-1;
		g[a].push_back(E(b,c));
		g[b].push_back(E(a,c));
	}//这个in[1]=-1的初值,因为钦定1是root,它没有fa,没有(fa,root,w)的如边,这里需要给个初值.
	in[1]=-1; dfs1(1,1); dfs2(1,1); build(1,1,n);
	int m=read();while(m--){
		int x=read(),y=read();
		printf("%d\n",query(x,y));
	}
	return 0;
}
```



---

最后来聊聊怎么去掉一个$log$吧.
~~the art of shaving logs~~  
* 换上LCT/使用全局平衡二叉树,直接砍掉.

因为没有修改,整条重链的查询使用SGT是不必要的.  
考察查询过程,我们用到了这样几种链的信息(重链头到某节点,某节点到重链头,某重链的子区间),前两种显然是$O(n)$的,最后一个只在最后一步跳到LCA处时出现,是$O(m)$的.  
于是只有$O(n+m)$个本质不同的乘积询问,对于前面两种,我们dfs一下就可以处理出来,对于后一种,不得不在SGT上做一次查询,这样单次查询就是$O(logn)$了(跳链时是$O(1)$的,最后一步是$O(logn)$的.  


~~所以HLD还是吊打了树上倍增,树上倍增并看不到任何优势~~

---

## 作者：封禁用户 (赞：0)

### 题面
>辗转经由他人唇齿
>
>多少日夜听闻你的故事
>
>难道这情之一字
>
>竟连抛生死亦不可探知

给一棵带边权的树，求每次询问求 $l$ 到 $r$ 路径上最长不降子序列长度。

### 思路
~~关于我刷题看到这么有诗意的一道（省略形容词）题，就不再赘述。~~

思路挺简单的，回顾一下我们正常求 $[l,r]$ 的二维动态规划，其实是枚举每个数，枚举放在那个数后面。但这题边权出奇的小，我们可以直接记录一段路径最大最小值。

于是简单的倍增加 dp。

记录 $f_{i,j,k,p}$ 为从 $i$ 出发的到第 $2^j$ 个祖先的路径上最小值为 $k$，最大值为 $p$ 的最长的值，$fa_{i,j}$ 是 $i$ 开始第 $2^j$ 个祖先。

转移就出来了：

- $f_{i,j,k,p}=\sum_{l=\min(k,p)}^{\max(k,p)}\max(f_{i,j,k,p},f_{i,j-1,k,l}+f_{fa_{i,j-1},j-1,l,p})$

对于查询操作，可以将其分为 $l$ 到 $\operatorname{LCA}(l,r)$ 和 $\operatorname{LCA}(l,r)$ 到 $r$，分别求一下再合并就行了。

### 代码
```cpp
#include<bits/stdc++.h>
#define int long long 
#define Maxn 300000 
#define Macn 300000 
using namespace std;
int fa[Maxn][30],dep[Maxn];
struct DP {
    int leaf[6][6];
} f[Maxn][30];
struct Road{int to,val;};
vector<Road> q[Maxn];
void prepare(int x,int F) {
    dep[x]=dep[F]+1;
    fa[x][0]=F;
    for(int i=1;i<=25;i++) {
        fa[x][i]=fa[fa[x][i-1]][i-1];
        if(!fa[x][i])break;
        for(int j=1;j<6;j++)
            for(int k=1;k<6;k++)
                for(int p=min(j,k);p<=max(j,k);p++)
                    f[x][i].leaf[j][k]=max(f[x][i].leaf[j][k],f[x][i-1].leaf[j][p]+f[fa[x][i-1]][i-1].leaf[p][k]);
    }
    for(Road u:q[x]) {
        if(u.to == F)continue;
        for(int i=1;i<6;i++)
            for(int j=1;j<6;j++)
                if(min(i,j)<=u.val&&u.val<=max(i,j))
                    f[u.to][0].leaf[i][j]=1;
        prepare(u.to,x);
    }
}
int res[Maxn][2][2],tot[2],flag;
void solve(int u,int v) {
    tot[0]=tot[1]=0,flag=1;
    if(dep[u] > dep[v])
        flag=0,swap(u,v);
    for(int i=25;i>=0;i--) {
        if(dep[fa[v][i]] >= dep[u]) {
            res[++tot[flag]][flag][0]=v;
            res[tot[flag]][flag][1]=i;
            v=fa[v][i];
        }
    }
    for(int i=25;i>=0;i--) {
        if(fa[u][i] != fa[v][i]) {
            res[++tot[flag^1]][flag^1][0]=u;
            res[tot[flag^1]][flag^1][1]=i;
            res[++tot[flag]][flag][0]=v;
            res[tot[flag]][flag][1]=i;
            u=fa[u][i],v=fa[v][i];
        }
    }
    if(u == v)return ;
    res[++tot[flag^1]][flag^1][0]=u;
    res[tot[flag^1]][flag^1][1]=0;
    res[++tot[flag]][flag][0]=v;
    res[tot[flag]][flag][1]=0;
}
int solve_last() {
    DP resx[2][30];
    for(int i=1;i<6;i++)
        for(int j=1;j<6;j++)
            for(int l=0;l<25;l++)
                resx[0][l].leaf[i][j]=resx[1][l].leaf[i][j]=0;
    for(int _=0;_<2;_++)
        for(int i=1;i<=tot[_];i++)
            for(int j=1;j<6;j++)
                for(int k=1;k<6;k++)
                    for(int p=min(j,k);p<=max(j,k);p++)
                        resx[_][i].leaf[j][k]=max(resx[_][i].leaf[j][k],resx[_][i-1].leaf[j][p]+f[res[i][_][0]][res[i][_][1]].leaf[p][k]);
    int maxn = 0;
    for(int i=1;i<6;i++) {
        for(int j=i;j<6;j++) {
            int ans=0;
            for(int k=i;k<=j;k++)
                ans=max(ans,resx[0][tot[0]].leaf[i][k]+resx[1][tot[1]].leaf[j][k]);
            maxn=max(maxn,ans);
        }
    }
    return maxn;
}
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int n,m;
    cin>>n;
    for(int i=1;i<n;i++) {
        int u,v,w;
        cin>>u>>v>>w;
        q[u].push_back({v,w});
        q[v].push_back({u,w});
    } prepare(1,0);
    cin>>m;
    while(m--) {
        int u,v;
        cin>>u>>v;
        solve(u,v);
        cout<<solve_last()<<"\n";
    }
    return 0;
}
```

---


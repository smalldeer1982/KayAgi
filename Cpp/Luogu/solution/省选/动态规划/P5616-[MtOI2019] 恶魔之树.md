# [MtOI2019] 恶魔之树

## 题目背景

在 Kirito 和 Eugeo 还没有与 Alice 前往北之洞窟的时候，Eugeo 每天只能用龙骨斧砍恶魔之树——基家斯西达……

![](https://cdn.luogu.com.cn/upload/image_hosting/95swctde.png)

~~请忽略bilibili的水印~~

## 题目描述

Kirito 和 Eugeo 每天砍树觉得很无聊，于是开始比谁砍出好声音的次数多。渐渐地，他们发现这样也没有意思了，于是在这个基础上改了一点：

每个人去砍树前，会随机得到一个长度为 $n$ 的数列 $s_1, s_2, \dots, s_n$ 。最初每个人的得分都是 $1$，当第 $i$ 次砍出了一个好声音时，得分就变成了原来的得分与 $s_i$ 的最小公倍数，也就是常说的 ${\rm lcm}$。

现在 Kirito 已经得到了一个长度为 $n$ 的数列 $s_1, s_2, \ldots, s_n$ 。他想知道，如果每一次砍出好声音的概率是 $50\%$ 时他的期望得分。

由于 Kirito 不想看到小数，所以请你告诉 Kirito 答案乘 $2^n$ 对 $p$ 取模的值。

## 说明/提示

#### 样例解释 1

一共有 $8$ 种情况：

- 没有出现好声音，得分为 $1$，概率为 $\frac{1}{8}$。

- 只有第一次出现了好声音，得分为 $1$，概率为 $\frac{1}{8}$。

- 只有第二次出现了好声音，得分为 $2$，概率为 $\frac{1}{8}$。

- 只有第三次出现了好声音，得分为 $3$，概率为 $\frac{1}{8}$。

- 只有第三次没有出现好声音，得分为 $\operatorname{lcm}(1, 2)=2$，概率为 $\frac{1}{8}$。

- 只有第二次没有出现好声音，得分为 $\operatorname{lcm}(1, 3)=3$，概率为 $\frac{1}{8}$。

- 只有第一次没有出现好声音，得分为 $\operatorname{lcm}(2, 3)=6$，概率为 $\frac{1}{8}$。

- 每一次都砍出了好声音，得分为 $\operatorname{lcm}(1, 2, 3)=6$，概率为 $\frac{1}{8}$。

所以期望值为 $\frac{1}{8}+\frac{1}{8}+\frac{2}{8}+\frac{3}{8}+\frac{2}{8}+\frac{3}{8}+\frac{6}{8}+\frac{6}{8}=3$

乘上 $2^3$ 得到答案为 $24$。

### 子任务

本题采用捆绑测试。

对于 $100\%$ 的数据，$1\leq n\leq 3\times 10^5$，$10^7 \leq p \leq 1.1 \times 10^9$且$p$为质数，$1\leq s_i\leq 300$。

本题共 $7$ 个子任务，各子任务的分值和限制如下：

子任务 $1$（$3$ 分）：$n=1$。

子任务 $2$（$7$ 分）：$n=18$。

子任务 $3$（$10$ 分）：$n=100$，$s$ 中不同的正整数不超过 $18$ 个。

子任务 $4$（$20$ 分）：$n=100$，不存在 $1\leq i \neq j \leq n$，使得 $s_i=s_j$。且保证数据随机。

子任务 $5$（$20$ 分）：$1\leq s_1, s_2, \ldots, s_n \leq 100$。

子任务 $6$（$20$ 分）：$1\leq n \leq 10^4$。

子任务 $7$（$20$ 分）：无特殊限制。

------

谨以此题庆祝刀剑10周年。~~好像晚了几个月...~~


### 题目来源

[MtOI2019 Extra Round](https://www.luogu.org/contest/22840) T4

出题人：CYJian 

验题人：suwAKow


## 样例 #1

### 输入

```
3 998244353
1 2 3```

### 输出

```
24```

## 样例 #2

### 输入

```
10 998244353
1 2 3 4 5 6 7 8 9 10```

### 输出

```
516032```

# 题解

## 作者：mrsrz (赞：10)

[可能更好的体验](https://mrsrz.github.io/2019/11/03/lg5616/)

发现 $s_i$ 最大只有 $300$，而 $\sqrt {300}$ 以内的质数只有 $2,3,5,7,11,13,17$，也就是说，剩下的质因子在每个数中至多出现一个，且次数最多为 $1$。

然后，$2,3,5,7,11,13,17$ 的最大次数分别为 $8,5,3,2,2,2,2$，组合一下，总方案数只有 $17496$ 个，是个挺小的状态数。

所以我们先不考虑那些大于 $\sqrt{300}$ 的质数产生的贡献。

但是 $n$ 特别大，如果进行 $n$ 次转移，那仍然接受不了。

注意只有 $300$ 种不同的数，如果一个数出现 $c$ 次，那么这个数对最小公倍数产生贡献的方案数就为 $2^{c}-1$。

那么我们对 $300$ 以内每个最大质因子不超过 $17$ 的数进行考虑。

以下数组都忽略第一维的滚动维。

令 $dp[a1][a2][a3][a4][a5][a6][a7]$ 表示最小公倍数为 $2^{a1}3^{a2}5^{a3}7^{a4}11^{a5}13^{a6}17^{a7}$ 的方案数。

转移时枚举$a1,a2,a3,a4,a5,a6,a7$，计算出新的最小公倍数 $b1,b2,b3,b4,b5,b6,b7$，然后直接转移即可。

接下来考虑大于 $17$ 的质因数。我们把最大质因子相同的数放在一起考虑。然后考虑下一个质因子的时候，原来的质因子的有无就不会对最小公倍数产生影响。

这里不能直接计算方案数，因为不知道最大质因子的出现情况。所以直接统计总贡献。

令 $F[b][a1][a2][a3][a4][a5][a6][a7]$ 表示最小公倍数的前 $7$ 种质因数的情况为 $2^{a1}3^{a2}5^{a3}7^{a4}11^{a5}13^{a6}17^{a7}$ 时，当前考虑的大质因子次数为 $b$ 的总和。

转移时，我们计算出新的最小公倍数与原来的最小公倍数差的那些因子的乘积 $\Delta$，表示原来的那些所有方案都要乘上 $\Delta$ 转移到新的状态。

这个和上面的转移也是类似的。

我们处理完一个最大质因子后，需要把 $b=1$ 的所有情况都加给 $b=0$ 的情况上，表示最大质因子换了一个。

那么总共的运算次数是 $O(17496\times 300)$。在 $1$ 秒内跑完绰绰有余。

## Code：

```c++
#include<iostream>
#include<vector>
#include<cstring>
#include<algorithm>
#define rep(i,a,b)for(int i=(a);i<=(b);++i)
using namespace std;
typedef long long LL;
//2:8 3:5 5:3 7:2 11:2 13:2 17:2
//4 3 2 2 2 2 2
int dp[2][9][6][4][3][3][3][3],F[2][2][9][6][4][3][3][3][3];
int n,md;
int cnt[305];
vector<pair<int,int> >vc[305];
vector<int>pc[305];
inline int pow(int a,int b){
	int ret=1;
	for(;b;b>>=1,a=(LL)a*a%md)if(b&1)ret=(LL)ret*a%md;
	return ret;
}
void solve(int n,vector<pair<int,int> >&vec){
	for(int i=2;i*i<=n;++i)if(n%i==0){
		int cnt=0;
		while(n%i==0)++cnt,n/=i;
		vec.emplace_back(i,cnt);
	}
	if(n>1)vec.emplace_back(n,1);
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>md;
	for(int i=1;i<=n;++i){
		int x;
		cin>>x;
		++cnt[x];
	}
	********dp=1;
	int cur=0;
	for(int i=1;i<=300;++i)if(cnt[i]){
		solve(i,vc[i]);
		if(i==1||vc[i].back().first<=17){
			int fs=pow(2,cnt[i])-1;
			cur^=1;
			memcpy(dp[cur],dp[cur^1],sizeof*dp);
			rep(a1,0,8)rep(a2,0,5)rep(a3,0,3)rep(a4,0,2)rep(a5,0,2)
			rep(a6,0,2)rep(a7,0,2){
				int s=dp[cur^1][a1][a2][a3][a4][a5][a6][a7];
				if(!s)continue;
				int b1=0,b2=0,b3=0,b4=0,b5=0,b6=0,b7=0;
				for(auto j:vc[i]){
					switch(j.first){
						case 2:b1=j.second;break;
						case 3:b2=j.second;break;
						case 5:b3=j.second;break;
						case 7:b4=j.second;break;
						case 11:b5=j.second;break;
						case 13:b6=j.second;break;
						case 17:b7=j.second;break;
					}
				}
				b1=max(b1,a1);
				b2=max(b2,a2);
				b3=max(b3,a3);
				b4=max(b4,a4);
				b5=max(b5,a5);
				b6=max(b6,a6);
				b7=max(b7,a7);
				int t=pow(2,b1)*pow(3,b2)%md*pow(5,b3)%md*pow(7,b4)%md*pow(11,b5)%md*pow(13,b6)%md
				*pow(17,b7)%md;
				int&to=dp[cur][b1][b2][b3][b4][b5][b6][b7];
				to=(to+(LL)s*fs)%md;
			}
		}else
		pc[vc[i].back().first].push_back(i);
	}
	int ans=0;
	rep(a1,0,8)rep(a2,0,5)rep(a3,0,3)rep(a4,0,2)rep(a5,0,2)
	rep(a6,0,2)rep(a7,0,2)
	F[0][0][a1][a2][a3][a4][a5][a6][a7]=dp[cur][a1][a2][a3][a4][a5][a6][a7]*((LL)
	pow(2,a1)*pow(3,a2)%md*pow(5,a3)%md*pow(7,a4)%md*pow(11,a5)%md*pow(13,a6)%md
				*pow(17,a7)%md)%md;
	cur=0;
	for(int p=2;p<=300;++p){
		for(int i:pc[p]){
			int fs=pow(2,cnt[i])-1;
			cur^=1;
			memcpy(F[cur],F[cur^1],sizeof*F);
			rep(ff,0,1)rep(a1,0,8)rep(a2,0,5)rep(a3,0,3)rep(a4,0,2)rep(a5,0,2)
			rep(a6,0,2)rep(a7,0,2){
				int s=F[cur^1][ff][a1][a2][a3][a4][a5][a6][a7];
				if(!s)continue;
				int b1=0,b2=0,b3=0,b4=0,b5=0,b6=0,b7=0;
				for(auto j:vc[i]){
					switch(j.first){
						case 2:b1=j.second;break;
						case 3:b2=j.second;break;
						case 5:b3=j.second;break;
						case 7:b4=j.second;break;
						case 11:b5=j.second;break;
						case 13:b6=j.second;break;
						case 17:b7=j.second;break;
					}
				}
				int dlt=
				pow(2,max(b1-a1,0))*
				pow(3,max(b2-a2,0))%md*
				pow(5,max(b3-a3,0))%md*
				pow(7,max(b4-a4,0))%md*
				pow(11,max(b5-a5,0))%md*
				pow(13,max(b6-a6,0))%md*
				pow(17,max(b7-a7,0))%md*pow(p,ff^1)%md;
				b1=max(b1,a1);
				b2=max(b2,a2);
				b3=max(b3,a3);
				b4=max(b4,a4);
				b5=max(b5,a5);
				b6=max(b6,a6);
				b7=max(b7,a7);
				int&to=F[cur][1][b1][b2][b3][b4][b5][b6][b7];
				to=(to+s*(LL)dlt%md*fs)%md;
			}
		}
		rep(a1,0,8)rep(a2,0,5)rep(a3,0,3)rep(a4,0,2)rep(a5,0,2)
		rep(a6,0,2)rep(a7,0,2){
			int&f=F[cur][0][a1][a2][a3][a4][a5][a6][a7];
			int&g=F[cur][1][a1][a2][a3][a4][a5][a6][a7];
			f=(f+g)%md;
			g=0;
		}
	}
	rep(a1,0,8)rep(a2,0,5)rep(a3,0,3)rep(a4,0,2)rep(a5,0,2)
	rep(a6,0,2)rep(a7,0,2)
	ans=(ans+F[cur][0][a1][a2][a3][a4][a5][a6][a7])%md;
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：GreenDay (赞：8)

**状压+根号分治** ~~代码清奇可爱，一点也不毒瘤~~ 

题目思路和代码借鉴神犇 mrsrz 的题解

[题目地址](https://www.luogu.com.cn/problem/P5616)

有$n$个位置，每个位置可以取$s_i$也可以取$1$。问对于可能的$2^n$中序列，其lcm的和是多少，对质数p取模.

$n \le 3*10^5 , 1 \le s_i \le 300$

### 从子任务开始

- 子任务3 $n=100$，$s$ 中不同的正整数不超过 18 个。

直接爆搜是不可能的。但是我们可以离散化之后爆搜。记录每个数出现的次数$cnt_i$，它对答案的贡献就是$2^{cnt_i}-1$.同样的道理，我们就可以把n的规模缩小到了s的规模

- 子任务5 $1 \le s_i \le 100$

一个序列的LCM可以用其质因子极其指数表示。对于100以内的数，我们发现2、3、5、7的指数可能超过1，其余的质数指数只可能为1 or 0.所以我们设$dp_{a,b,c,d,o}$表示$LCM=2^a3^b5^c7^d\prod_{p\in o}p$,暴力转移即可。

40分代码
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long int64;
const int N = 302;

int n , mod , max_val;
int vis[N] , pow2[500002] , tot;
pair<int , int> valid[N];

int gcd(int x , int y) {return y ? gcd(y , x % y) : x;}
//int64 lcm(int x , int y) {return 1ll * x * y / gcd(x , y);}

int is[N] , prime[62] , cnt;

void sieve()
{
	is[0] = is[1] = -1;
	for(int i = 2 ; i <= 300 ; i ++)
	{
		if(~is[i]) prime[cnt++] = i;
		for(int j = 0 ; j < cnt && i * prime[j] <= 300 ; j ++)
		{
			is[i * prime[j]] = -1;
			if(i % prime[j] == 0) break;
		}
	}
	for(int i = 0 ; i < cnt ; i ++)
		is[prime[i]] = i;
}

struct Num
{
	char s[62];
	char& operator[] (int x) 
	{
		return s[x];
	}
	Num(int x = 1)
	{
		memset(s , 0 , sizeof(s));
		for(int i = 0 ; prime[i] * prime[i] <= x ; i ++)
			while(x % prime[i] == 0)
				s[i]++ , x /= prime[i];
		if(x != 1) s[is[x]]++;
	}
	int val()
	{
		int res = 1;
		for(int i = 0 ; i < 62 ; i ++)
			for(int j = 0 ; j < s[i] ; j ++)
				res = 1ll * res * prime[i] % mod;
		return res;
	}
	Num operator *(Num &t) const
	{
		Num ans;
		for(int i = 0 ; i < 62 ; i ++)
			ans[i] = max(s[i] , t[i]);
		return ans;
	}
	Num operator *(int t)
	{
		Num tmp(t);
		return *this * tmp;
	}
};

namespace tot_18
{
	int64 ans = 0;
	void dfs(int step , int64 repeat , Num lcm)
	{
		if(step > tot)
		{
			ans = ( ans + repeat * lcm.val() ) % mod;
			return ;
		}
		dfs(step + 1 , repeat * (pow2[valid[step].second] - 1) % mod , lcm * valid[step].first);
		dfs(step + 1 , repeat , lcm);
	}
	void solve()
	{
		dfs(1 , 1 , Num());
		printf("%lld\n" , ans);
		exit(0);
	}
}

namespace maxval_100
{
	int64 dp[7][5][3][3][1<<11];
	//dp[2有几次幂][3][5][7][剩余11个数的状态]有多少种情况
	int64 more = 1 , ans = 0;//最后答案要乘及
	void solve()
	{
		dp[0][0][0][0][0] = 1;
		for(int i = 1 ; i <= tot ; i ++)
		{
			if(valid[i].first == 1)
			{
				more = more * pow2[valid[i].second] % mod;
				continue;
			}
			if(~is[valid[i].first] && valid[i].first > 50)
			{
				more = more * ((pow2[valid[i].second] - 1ll) * valid[i].first % mod + 1) % mod;
				continue;
			}
			Num tmp(valid[i].first);
			
			int _2 = tmp[0];
			int _3 = tmp[1];
			int _5 = tmp[2];
			int _7 = tmp[3];
			int _o = 0;
			for(int i = 4 ; i < 15 ; i ++)
				if(tmp[i]) _o |= (1 << (i - 4));
			
			for(int _2_ = 6 ; ~_2_ ; _2_ --)
			for(int _3_ = 4 ; ~_3_ ; _3_ --)
			for(int _5_ = 2 ; ~_5_ ; _5_ --)
			for(int _7_ = 2 ; ~_7_ ; _7_ --)
			for(int _o_ = 2047 ; ~_o_ ; _o_--)
			(dp[max(_2_ , _2)][max(_3_ , _3)][max(_5_ , _5)][max(_7_ , _7)][_o_ | _o] += dp[_2_][_3_][_5_][_7_][_o_] * (pow2[valid[i].second] - 1) ) %= mod;
		}
		for(int _2_ = 6 ; ~_2_ ; _2_ --)
		for(int _3_ = 4 ; ~_3_ ; _3_ --)
		for(int _5_ = 2 ; ~_5_ ; _5_ --)
		for(int _7_ = 2 ; ~_7_ ; _7_ --)
		for(int _o_ = 2047 ; ~_o_ ; _o_--)
		{
			Num tmp;
			tmp[0] = _2_;
			tmp[1] = _3_;
			tmp[2] = _5_;
			tmp[3] = _7_;
			for(int i = 4 ; i < 15 ; i ++)
				if(_o_ & (1 << (i - 4))) tmp[i] = 1;
			ans = (ans + dp[_2_][_3_][_5_][_7_][_o_] * tmp.val()) % mod;
		}
		ans = ans * more % mod;
		printf("%lld\n" , ans);
		exit(0);
	} 
}

int main()
{
	scanf("%d %d" , &n , &mod);
	for(int i = 1 , t; i <= n ; i ++)
	{
		scanf("%d" , &t);
		vis[t]++;
		max_val = max(max_val , t);
	} 
	pow2[0] = 1;
	for(int i = 1 ; i <= n ; i ++)
		pow2[i] = 2*pow2[i - 1] % mod;
	for(int i = 1 ; i <= max_val ; i ++)
		if(vis[i]) valid[++tot] = make_pair(i , vis[i]);
	
	sieve();
	if(tot <= 18) tot_18::solve();
	if(max_val <= 100) maxval_100::solve();
}
```

- 100分做法

子任务5的做法之所以劣，是因为我们对大于$\sqrt{s}$的质因数处理不善。因此，我们可以考虑**不是直接状压，而是分开枚举**的策略。

对于小于等于17的质数，我们暴力状压，记录每个状态的**方案数**而不是**对答案的贡献**

之后，我们对于每一个大于17的质数，我们在std::vector中记录拥有这个质因子的数（这个数显然只会出现1次）

先设$dp_{x[7]}$表示LCM中含有**且只含有**质因子2、3、5、7、11、13、17的指数的方案数。也就是说，我们不会把有大质因子的数在此处转移。

初始值：$dp_{0,0,0,0,0,0,0}=1,others=0$

转移：采用刷表法+滚动数组，每次枚举一个数，求出旧状态与新数的LCM，然后乘上对应的贡献


再设$f_{t,x[7]}$表示对于某一个大于17的质因子，它出现的状态为$t \in \{0,1\}$,小质因子出现的状态时$x_i$时，其所有状态下LCM的总和。

初始值：$f_0=dp*LCM,others=0$

转移：和上面类似，但是注意每次**求出新值和旧值的商，然后把贡献乘上这个值**。这意味这我们的LCM变大了，贡献也变多了

每次处理完一个质因子，我们就令$f_0=f_0+f_1,f_1=0$，意味着下一个质因子与上一个质因子没有关系。

那么答案就是$\sum f_0$。注意剪枝，就可以过辣！。

常数巨大的代码，几乎是卡着时限过的QwQ（善用宏定义，使得代码变得不那么毒瘤）

```cpp
#include <bits/stdc++.h>
using namespace std;

const int M = 301;
int n , mod , cnt[M] ;
const int pri[] = {2 , 3 , 5 , 7 , 11 , 13 , 17};
const int maxe[] = {8 , 5 , 3 , 2 , 2 , 2 , 2};

inline int read() {
    int x = 0 ; char c = getchar(); bool f = 0;
    while(c < '0' || c > '9') f |= (c=='-') , c = getchar();
    while(c >= '0' && c <= '9') x = x * 10 + (c^48) , c = getchar();
    return f ? -x : x;
}
inline int qpow(int x , int y)
{
    int res = 1;
    for( ; y ; y >>= 1 , x = 1ll * x * x % mod)
        if(y & 1) res = 1ll * res * x % mod;
    return res;
}

int pfac[M][7];
vector<int> havep[M];

#define ALL_NUM(x) \
for(int x[7] = {0} ; x[0] <= maxe[0] ; x[0]++) \
for(x[1] = 0 ; x[1] <= maxe[1] ; x[1]++) \
for(x[2] = 0 ; x[2] <= maxe[2] ; x[2]++) \
for(x[3] = 0 ; x[3] <= maxe[3] ; x[3]++) \
for(x[4] = 0 ; x[4] <= maxe[4] ; x[4]++) \
for(x[5] = 0 ; x[5] <= maxe[5] ; x[5]++) \
for(x[6] = 0 ; x[6] <= maxe[6] ; x[6]++)

#define ____ [9][6][4][3][3][3][3]
int dp[2]____ , f[2][2]____;

int& at(int a ____ , int x[7]) {
    return a[x[0]][x[1]][x[2]][x[3]][x[4]][x[5]][x[6]];
}
int calc(int x[7]) {
    int ans = 1;
    for(int i = 0 ; i < 7 ; ++i) 
        ans = 1ll * ans * qpow(pri[i] , x[i]) % mod;
    return ans;
}

int main()
{
    n = read() , mod = read();
    for(int i = 1 ; i <= n ; ++i) cnt[read()]++;
    ********dp = 1;
    int cur = 0 , ans = 0;
    for(int i = 1 ; i <= 300 ; ++i) if(cnt[i])
    {
        int val = i , sum = qpow(2 , cnt[i]) - 1 , y[7];;
        for(int j = 0 ; j < 7 ; ++j)
            while(val % pri[j] == 0) val /= pri[j] , ++pfac[i][j];
        if(val > 1) {havep[val].push_back(i) ; continue;}

        memcpy(dp[cur ^ 1] , dp[cur] , sizeof(*dp));
        cur ^= 1;
        ALL_NUM(x) {
            int& from = at(dp[cur ^ 1] , x);
            for(int j = 0 ; j < 7 ; ++j) y[j] = max(x[j] , pfac[i][j]);
            int &to = at(dp[cur] , y);
            to = (to + 1LL * from * sum) % mod;
        }
    }
    ALL_NUM(x) at(f[0][0] , x) = 1LL * at(dp[cur] , x) * calc(x) % mod;
    cur = 0;
    for(int p = 1 ; p <= 300 ; ++p) if(havep[p].size())
    {
        for(int i : havep[p])
        {
            int sum = qpow(2 , cnt[i]) - 1 , y[7] , z[7];
            memcpy(f[cur ^ 1] , f[cur] , sizeof(*f));
            cur ^= 1;
            for(int t = 0 ; t <= 1 ; ++t) ALL_NUM(x) 
            {
                int &from = at(f[cur ^ 1][t] , x);
                for(int j = 0 ; j < 7 ; ++j) 
                    y[j] = max(x[j] , pfac[i][j]) , z[j] = y[j] - x[j];
                int &to = at(f[cur][1] , y) , d = 1LL * calc(z) * qpow(p , t^1) % mod;
                to = (to + 1LL * from * d % mod * sum) % mod;
            }
        }
        ALL_NUM(x) {
            (at(f[cur][0] , x) += at(f[cur][1] , x)) %= mod;
            at(f[cur][1] , x) = 0;
        }              
    }
    ALL_NUM(x) (ans += at(f[cur][0] , x)) %= mod;
    printf("%d\n" , ans);
    return 0;
}
```

---

## 作者：CYJian (赞：8)

#### 子任务1

$n=1$ 的时候只有两种情况：

敲出好声音：分数为 $s_1$；

没敲出好声音：分数为 $1$；

那么答案就是 $2^1 \times \frac{1+s_1}{2}=1+s_1$

期望得分：$3$ 分

#### 子任务2

可以考虑枚举每一次敲没敲出好声音。

然后枚举出情况后可以 $O(n)$ 计算答案。

注意 $18$ 个数的 ${\rm lcm}$ 可能会爆 ${\rm long\ long}$，所以需要 ${\rm \_\_int128}$ 来暂存 ${\rm lcm}$ 的值。

复杂度 $O(n \times 2^n \times \log s_i)$，期望得分 $10$ 分。

#### 子任务3

发现本质不同的数只有 $18$ 种，而对于答案，我们只关心最后的 ${\rm lcm}$ 有多少种，以及每种 ${\rm lcm}$ 有多少种组成的方案。

容易发现，如果我们选一种数 $x$ 加入 ${\rm lcm}$ 中，那么方案数就会乘上 ${\rm 2^{cnt[x]}-1}$。其中 ${\rm cnt[x]}$ 表示数列 $s$ 中 $x$ 出现的次数。

那么沿用 子任务2 的方法，我们就可以用 $O(18 \times 2^{18} \times \log s_i)$ 的复杂度计算了。

期望得分 $20$ 分。

#### 子任务4

这档部分分就是给大家乱搞的。

毕竟数据随机。

#### 子任务5

我们考虑 ${\rm lcm}$ 除了有一个 ${\rm lcm}=\frac{x \times y}{\gcd(x,y)}$ 的计算式之外，还可以根据定义计算：

如果我们要对 $a_1, a_2, \ldots, a_k$ 计算 ${\rm lcm}$ 的话，只需要对于每一个质因子，计算最大次幂，然后乘起来就行了。

这样我们就可以想到动态维护最大次幂。

发现这个子任务中最大次幂 $\ge 2$ 的质数只有 $4$ 个，状压起来的大小是 $7 \times 5 \times 3 \times 3 =315$ 。然后对于大于 $10$ 的质数，我们就只关心它有没有出现过。所以我们可以将 $s$ 按照其最大质因数排序，然后一段一段考虑。

暴力状压 $dp$ 的复杂度是 $O(n \times 315^2)$ 无法通过这个子任务。

考虑优化：使用 子任务3 的想法，不同的数最多只有 $100$ 个，那么就可以把相同的数放在一起考虑，这样复杂度就是 $O(100 \times 315^2)$ 可以通过。

期望得分 $20$ 分

#### 子任务6 7

对于小于等于 $\sqrt{300}$ 的质数，状压考虑，对于大于 $\sqrt{300}$ 的质数，按照最大质因数排序之后一起考虑。

然后现在的状压的大小就变成了 $9 \times 6 \times 4 \times 3 \times 3 \times 3 \times 3=17496$

然后我们如果还是只将枚举的个数放在 $300$ 上的话，复杂度就是 $O(300 \times 17496^2)$ 大概是 $9 \times 10^{10}$ 的级别，无法接受。

优化 $1$：

我们可以对于每个大于 $\sqrt{300}$ 的质数，预处理其所有倍数的 $dp$ 转移，然后合并到这个质数上，预处理的复杂度就是 $O(300 \times 17496)$ 的。然后我们在转移的时候就只需要枚举大于 $\sqrt{300}$ 的质因数(大概有 $60$ 个)就可以了。

总复杂度就是 $O(60 \times 17496^2)$ 但是在质因子比较大的时候状态数远不到这个程度，写一个记忆化搜索就可以大幅减少状态数。但是仍然很悬。

期望得分 $40$ ~ $100$ 分

优化 $2$：

发现因子中存在大于 $\sqrt{300}$ 的质数的数的其他因子的次数的数量级大概会减少一半。

我们就可以在计算大于 $\sqrt{300}$ 的质数的时候让状压的大小改为 $4 \times 3 \times 2^5 =384$

然后复杂度就是 $O(60 \times 384^2)$ 可以通过。

期望得分 $100$ 分

如果没有想到减少枚举次数而是想到了减小状压大小，复杂度就是 $O(n \times 384^2)$，如果还写了记忆化搜索，就可以过子任务 $6$ .

---

这个做法大概能跑 $s_i \leq 400$ 的，但是一开始验题人表示他的做法被卡常了，所以我就把 $s_i$ 改到了 $300$，但是后来发现是验题人的做法写假了，~~甚至后来被验题人做法的常数吊着打~~，然后也懒得改了，所以放过了一堆较劣解。

---

## 作者：Prean (赞：8)

上个星期 kds 给我看的题，第一眼不会做，然后稍微想了一下还是秒了。

感觉还是太简单了。

考虑到值域只有 $300$，我们这里假设 $n$ 就是 $300$。重复的肯定开个桶记下来。

考虑经典结论：只会有至多一个质因子大于 $17$。

根据这个根号分治，那么我们记录 $2^{0\sim 8}\times 3^{0\sim 5}\times 5^{0\sim 3}\times 7^{0\sim 2}\times 11^{0\sim 2}\times 13^{0\sim 2}\times 17^{0\sim 2}$ 这些状态。

对这个部分我们做 lcm 卷积，由于每个初始的元素只会有至多一个质因子大于 $17$。

考虑在每组元素的 lcm 处统计其可能的 lcm 之和，但是显然只能够在 lcm 的倍数处统计。

这个很简单，对权值做一个高维差分就行了。

而统计可能的 lcm 也非常简单。对于每个大于 $17$ 的质因子开桶。因为质因子不同的部分互不相干所以可以写成类似下面这种形式：
$$\prod((2^{cnt_i}-1)\times pri_i+1)-1$$
前面的 $p,c$ 是不大于 $17$ 的，后面的 $pri,cnt$ 的大于 $17$ 的。

于是接下来就很简单了。

复杂度大概是 $O(17496\times 7\times\frac{n}{\ln n})$，这个显然随随便便跑过去吧。

好像还爆标了。目前是 rk1。
```cpp
#include<cstdio>
#include<cctype>
namespace SOLVE{
	inline int read(){
		int n(0);char s;while(!isdigit(s=getchar()));while(n=n*10+(s&15),isdigit(s=getchar()));return n;
	}
	const int H[]={1,1,9,54,216,648,1944,5832,17496},lim[]={1,9,6,4,3,3,3,3};
	int n,P,t[10][10],CB[305],w[17500],cnt[17500],F[17500][60];int top,pri[305],pos[305];
	struct Barrett{
		typedef unsigned long long ull;
		typedef __uint128_t LL;
		ull m,B;
		Barrett(const ull&m=2):m(m),B((LL(1)<<64)/m){}
		friend inline ull operator%(const ull&a,const Barrett&mod){
			ull r=a-mod.m*(LL(mod.B)*a>>64);return r>=mod.m?r-mod.m:r;
		}
	}mod;
	inline void sieve(const int&M){
		for(int i=2;i<=M;++i){
			if(!pos[i])pri[pos[i]=++top]=i;for(int x,j=1;j<=top&&(x=i*pri[j])<=M;++j)pos[x]=j;
		}
	}
	inline int pow(int a,int b=P-2){
		int ans(1);for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;return ans;
	}
	inline void main(){
		int ans(0);pri[0]=300;sieve(300);n=read();mod=Barrett(P=read());while(n--)++CB[read()];n=300;
		for(int i=0;i<=17495;++i)for(int k=0;k<=55;++k)F[i][k]=1;
		for(int c=1;c<=7;++c){t[c][0]=1;for(int k=1;k<=8;++k)t[c][k]=1ll*t[c][k-1]*pri[c]%mod;}
		for(int i=1;i<=n;++i){
			int sta(0),x=i;while(pri[pos[x]]<=17)sta+=H[pos[x]],x/=pri[pos[x]];CB[i]=pow(2,CB[i]);
			if(x==1)F[sta][0]=1ll*F[sta][0]*CB[i]%mod;else F[sta][pos[x]-7]=1ll*F[sta][pos[x]-7]*CB[i]%mod;
		}
		for(int c=1;c<=7;++c)for(int i=0;i<=17495;++i)if(i/H[c]%lim[c]){
			for(int k=0;k<=55;++k)F[i][k]=1ll*F[i][k]*F[i-H[c]][k]%mod;
		}
		for(int i=0;i<=17495;++i){
			w[i]=1;for(int k=0;k<=55;++k)w[i]=1ll*w[i]*(1ll*(F[i][k]-1)*(k?pri[k+7]:1)%mod+1)%mod;--w[i];
		}
		for(int c=1;c<=7;++c)for(int i=17495;i>=0;--i)if(i/H[c]%lim[c])w[i]=(1u*P+w[i]-w[i-H[c]])%mod;
		for(int c=1;c<=7;++c)for(int i=0;i<=17495;++i){
			if(i/H[c]%lim[c])cnt[i]=cnt[i-H[c]]+1;else cnt[i]=0;
			w[i]=1ll*w[i]*t[c][cnt[i]]%mod;
		}
		for(int i=0;i<=17495;++i)ans=(1u*ans+w[i])%mod;printf("%d",(ans+1)%mod);
	}
}
signed main(){
	SOLVE::main();
}
```

---

## 作者：Gmt丶FFF (赞：5)

~~期望就是来搞笑的。~~

由于有最小公倍数，所以可以想到分解质因数，对于多个数求最小公倍数，取每个质因子的最大指数，最后相乘即可。

既然都知道了这个，那么就想到先统计每个数的个数，再将质因子作为状态，进行 dp。

但是由于 $a_i$ 太大，无法装下所有的质因子，所以考虑根号分治。

对于质因子在 $17$ 及以下的，存入状态中，对于在 $17$ 以上的单独处理。

所以我们先把每个数分类，标准为多余质因子的大小（如果没有，那就为 $1$）。

设 $dp_{i,i_2,i_3,i_5,i_7,i_{11},i_{13},i_{17}}$ 为枚举到第 $i$ 个数，最小公倍数为 $2^{i_2}\times3^{i_3}\times5^{i_5}\times7^{i_7}\times11^{i_{11}}\times13^{i_{13}}\times17^{i_{17}}$（不算多余质因子）的方案数。

那么：

$dp_{i,\max(i_2,t_2),\max(i_3,t_3)......}=dp_{i,\max(i_2,t_2),\max(i_3,t_3)......}+dp_{i-1,i_2,i_3......}$

其中 $t_i$ 表示 $n$ 的质因子 $i$ 的指数个数。

由于其他因子的存在，所以我们需要建立第二个状态。

设 $f_{i,i_2,i_3,i_5,i_7,i_{11},i_{13},i_{17},0/1}$ 代表枚举到第 $i$ 个数，最小公倍数为 $2^{i_2}\times3^{i_3}\times5^{i_5}\times7^{i_7}\times11^{i_{11}}\times13^{i_{13}}\times17^{i_{17}}$（不算多余质因子），是否拥有多余因子的总和。

对于每一类多余因子的数，状态转移为：

$f_{i,\max(t_2,i_2),\max(t_3,i_3)...... 1}=f_{i,\max(t_2,i_2),\max(t_3,i_3)...... 1}+f_{i-1,i_2,i_3......1}+tmp\times 2^{cnt_i-1}$

$f_{i,\max(t_2,i_2),\max(t_3,i_3)...... 1}=f_{i,\max(t_2,i_2),\max(t_3,i_3)...... 1}+f_{i-1,i_2,i_3......0}+tmp\times other\times 2^{cnt_i-1}$

$tmp$ 代表现最小公倍数除以原最小公倍数，即 $2^{\max(i_2,t_2)-i_2}\times3^{\max(i_3,t_3)-i_3}......$

$cnt_i$ 代表数字 $i$ 的个数，$other$ 代表多余的因数。

初始值 $f_{m,i_2,i_3......0}=2^{i_2}\times3^{i_3}......\times dp_{m,i_2,i_3......}$

$m$ 指第一个多余的因子不为 $1$ 的数。

对于每一个多余的因子枚举完以后，要进行合并，即：

$f_{i,i_2,i_3......0}=f_{i,i_2,i_3......0}+f_{i,i_2,i_3......1}$

然后清空存在大因子的数组。

最后答案即为：$\sum f_{n,i_2,i_3......0}$。（$n$ 指的是最后一个数）

空间开不下，利用滚动数组。

复杂度：$O(n\times\log_2(n)\times\log_3(n)\times\log_5(n)\times\log_7(n)\times\log_{11}(n)\times\log_{13}(n)\times\log_{17}(n))$

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define int long long
using namespace std;
const int N=3e5+5;
const int M=305;
int n,cnt[M],mod=998244353,dp[2][9][6][4][3][3][3][3],f[2][9][6][4][3][3][3][3][2],p[20][N];
struct node
{
	int name,t[18],other;
}a[M];
int cmp(node fi,node se)
{
	if(fi.other==se.other)return fi.name<se.name;
	return fi.other<se.other;
}
inline int max(int x,int y)
{
	return x>y?x:y;
}
inline int quick_pow(int x,int y)
{
	if(p[x][y])return p[x][y];
	int sum=1,num=x,t=y;
	while(y)
	{
		if(y&1)sum*=num,sum%=mod;
		num*=num;
		num%=mod;
		y>>=1;
	}
	p[x][t]=sum;
	return sum;
}
void prepare()
{
	for(int i=1;i<=300;i++)
	{
		a[i].name=i;
		int x=i;
		for(int j=2;j*j<=i;j++)while(x%j==0)x/=j,a[i].t[j]++;
		if(x!=1&&x<=17)a[i].t[x]++,x=1;
		a[i].other=x;
	}
}
signed main()
{
	//freopen("easy25.in","r",stdin);
	//freopen("easy25.out","w",stdout); 
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	{
		int x;
		scanf("%lld",&x);
		cnt[x]++;
	}
	prepare();
	sort(a+1,a+301,cmp);
	dp[0][0][0][0][0][0][0][0]=1;
	int cur=0;
	bool flag=1;
	for(int i=1;i<=300;i++)
	{
		if(i!=1&&a[i].other!=a[i-1].other)
		{
			if(flag)
			{
				flag=0;
				for(int i2=0;i2<=8;i2++)
				for(int i3=0;i3<=5;i3++)
				for(int i5=0;i5<=3;i5++)
				for(int i7=0;i7<=2;i7++)
				for(int i11=0;i11<=2;i11++)
				for(int i13=0;i13<=2;i13++)
				for(int i17=0;i17<=2;i17++)
				f[cur][i2][i3][i5][i7][i11][i13][i17][0]=
				dp[cur][i2][i3][i5][i7][i11][i13][i17]*
				quick_pow(2,i2)%mod*
				quick_pow(3,i3)%mod*
				quick_pow(5,i5)%mod*
				quick_pow(7,i7)%mod*
				quick_pow(11,i11)%mod*
				quick_pow(13,i13)%mod*
				quick_pow(17,i17)%mod;
			}
			else
			{
				for(int i2=0;i2<=8;i2++)
				for(int i3=0;i3<=5;i3++)
				for(int i5=0;i5<=3;i5++)
				for(int i7=0;i7<=2;i7++)
				for(int i11=0;i11<=2;i11++)
				for(int i13=0;i13<=2;i13++)
				for(int i17=0;i17<=2;i17++)
				f[cur][i2][i3][i5][i7][i11][i13][i17][0]+=f[cur][i2][i3][i5][i7][i11][i13][i17][1]
				,f[cur][i2][i3][i5][i7][i11][i13][i17][0]%=mod,
				f[cur][i2][i3][i5][i7][i11][i13][i17][1]=0;
			}
		}
		cur^=1;
		memcpy(dp[cur],dp[cur^1],sizeof(dp[cur^1]));
		for(int i2=0;i2<=8;i2++)
		for(int i3=0;i3<=5;i3++)
		for(int i5=0;i5<=3;i5++)
		for(int i7=0;i7<=2;i7++)
		for(int i11=0;i11<=2;i11++)
		for(int i13=0;i13<=2;i13++)
		for(int i17=0;i17<=2;i17++)
		{
			dp[cur][max(i2,a[i].t[2])]
			[max(i3,a[i].t[3])]
			[max(i5,a[i].t[5])]
			[max(i7,a[i].t[7])]
			[max(i11,a[i].t[11])]
			[max(i13,a[i].t[13])]
			[max(i17,a[i].t[17])]+=
			(dp[cur^1][i2][i3][i5][i7][i11][i13][i17]*(quick_pow(2,cnt[a[i].name])-1))%mod;
			dp[cur][max(i2,a[i].t[2])]
			[max(i3,a[i].t[3])]
			[max(i5,a[i].t[5])]
			[max(i7,a[i].t[7])]
			[max(i11,a[i].t[11])]
			[max(i13,a[i].t[13])]
			[max(i17,a[i].t[17])]%=mod;
		}
		//if(a[i].other==1)continue;
		//cout<<a[i].name<<" "<<f[0][0][0][0][0][0][0][0]<<" "<<cnt[a[i].name]<<endl;
		memcpy(f[cur],f[cur^1],sizeof(f[cur^1]));
		for(int i2=0;i2<=8;i2++)
		for(int i3=0;i3<=5;i3++)
		for(int i5=0;i5<=3;i5++)
		for(int i7=0;i7<=2;i7++)
		for(int i11=0;i11<=2;i11++)
		for(int i13=0;i13<=2;i13++)
		for(int i17=0;i17<=2;i17++)
		{
			int num=
			quick_pow(2,max(i2,a[i].t[2])-i2)%mod*
			quick_pow(3,max(i3,a[i].t[3])-i3)%mod*
			quick_pow(5,max(i5,a[i].t[5])-i5)%mod*
			quick_pow(7,max(i7,a[i].t[7])-i7)%mod*
			quick_pow(11,max(i11,a[i].t[11])-i11)%mod*
			quick_pow(13,max(i13,a[i].t[13])-i13)%mod*
			quick_pow(17,max(i17,a[i].t[17])-i17)%mod;
			f[cur][max(i2,a[i].t[2])]
			[max(i3,a[i].t[3])]
			[max(i5,a[i].t[5])]
			[max(i7,a[i].t[7])]
			[max(i11,a[i].t[11])]
			[max(i13,a[i].t[13])]
			[max(i17,a[i].t[17])][1]+=
			f[cur^1][i2][i3][i5][i7][i11][i13][i17][0]*num%mod
			*a[i].other%mod*(quick_pow(2,cnt[a[i].name])-1)%mod;
			f[cur][max(i2,a[i].t[2])]
			[max(i3,a[i].t[3])]
			[max(i5,a[i].t[5])]
			[max(i7,a[i].t[7])]
			[max(i11,a[i].t[11])]
			[max(i13,a[i].t[13])]
			[max(i17,a[i].t[17])][1]+=
			f[cur^1][i2][i3][i5][i7][i11][i13][i17][1]*num%mod
			*(quick_pow(2,cnt[a[i].name])-1)%mod;
		}
	}
	if(flag)
	{
		flag=0;
		for(int i2=0;i2<=8;i2++)
		for(int i3=0;i3<=5;i3++)
		for(int i5=0;i5<=3;i5++)
		for(int i7=0;i7<=2;i7++)
		for(int i11=0;i11<=2;i11++)
		for(int i13=0;i13<=2;i13++)
		for(int i17=0;i17<=2;i17++)
		f[cur][i2][i3][i5][i7][i11][i13][i17][0]=
		dp[cur][i2][i3][i5][i7][i11][i13][i17]*
		quick_pow(2,i2)%mod*
		quick_pow(3,i3)%mod*
		quick_pow(5,i5)%mod*
		quick_pow(7,i7)%mod*
		quick_pow(11,i11)%mod*
		quick_pow(13,i13)%mod*
		quick_pow(17,i17)%mod;
	}
	else
	{
		for(int i2=0;i2<=8;i2++)
		for(int i3=0;i3<=5;i3++)
		for(int i5=0;i5<=3;i5++)
		for(int i7=0;i7<=2;i7++)
		for(int i11=0;i11<=2;i11++)
		for(int i13=0;i13<=2;i13++)
		for(int i17=0;i17<=2;i17++)
		f[cur][i2][i3][i5][i7][i11][i13][i17][0]+=f[cur][i2][i3][i5][i7][i11][i13][i17][1]
		,f[cur][i2][i3][i5][i7][i11][i13][i17][0]%=mod,
		f[cur][i2][i3][i5][i7][i11][i13][i17][1]=0;
	}
	int ans=0;
	for(int i2=0;i2<=8;i2++)
	for(int i3=0;i3<=5;i3++)
	for(int i5=0;i5<=3;i5++)
	for(int i7=0;i7<=2;i7++)
	for(int i11=0;i11<=2;i11++)
	for(int i13=0;i13<=2;i13++)
	for(int i17=0;i17<=2;i17++)
	ans+=f[cur][i2][i3][i5][i7][i11][i13][i17][0],ans%=mod;
	printf("%lld",ans);
	return 0;
}
/*
10 1000000007
291 292 293 294 295 296 297 298 299 300
*/
```


---

## 作者：AquariusZhao (赞：4)

是时候来一发小清新 dp 题解了。

链接：[P5616 [MtOI2019] 恶魔之树](https://www.luogu.com.cn/problem/P5616)

## 思路

显然题意可以转化为「求所有子序列的 $\operatorname{lcm}$ 之和」。

首先，结合 $1\le s_{i}\le300$ 的限制，可以去个重，设值的个数为 $m$ 个，并记录每种值的出现次数 $cnt$。然后容易想到把质数分为 $p<\sqrt{300}$ 和 $\sqrt{300}<p'\le 300$ 的套路。

此时，对于小质数，对答案的统计不太方便，直接以 $\operatorname{lcm}$ 为状态即可。而在所有 $s_{i}$ 中只会出现至多一个大质数 $p'_{i}$，所以可以以每个 $s_{i}$ 的 $p'_{i}$ 为关键字排序（没有就是 $1$），令新数组为 $t_{i}$。然后 $t$ 就被分成了若干段，每段都有同一个 $p'$。然后就能 dp 了。

设 $dp_{i,j,0/1}$ 为遍历到 $t_{i}$，小质数的 $\operatorname{lcm}$ 为 $j$，$p'_{i}$ 没选/选时，所有大质数对答案的贡献。以下令 $j'=\operatorname{lcm}(j,\frac{t_{i}}{p'_{i}})$。

初始，$dp_{0,1,0}=1$。

若 $p'_{i} = p'_{i-1}$，则
$$
\begin{cases}
dp_{i,j,0}\gets dp_{i,j,0}+dp_{i-1,j,0}\\
dp_{i,j,1}\gets dp_{i,j,1}+dp_{i-1,j,1}\\
dp_{i,j',1}\gets dp_{i,j',1}+(dp_{i-1,j,0}\times p'_{i} +dp_{i-1,j,1})\times( 2^{cnt_{t_{i}}}-1)
\end{cases}
$$
否则
$$
\begin{cases}
dp_{i,j,0}\gets dp_{i,j,0}+dp_{i-1,j,0}+dp_{i-1,j,1}\\
dp_{i,j',1}\gets dp_{i,j',1}+(dp_{i-1,j,0}+dp_{i-1,j,1})\times p'_{i} \times( 2^{cnt_{t_{i}}}-1)
\end{cases}
$$

最后答案就是 $\sum (dp_{m,j,0}+dp_{m,j,1})\times j$。

### 细节

上式中的 $j$ 显然不能直接作为下标，我用的方法是预处理每个 $\operatorname{lcm}$ 的编号。比 $\sqrt{300}$ 小的质数集合 $P$ 为 $\lbrace 2,3,5,7,11,13,17\rbrace$，所以状态总数为 $\prod_{p\in P}(k_{p} +1)=17496\ (p^{k_{p}}\le 300,p^{k_{p}+1}>300)$。

分析时间复杂度，瓶颈是 dp 部分，数量级大概是 $300\times 17496\times 7\log 300 < 3e7$。可以接受，但是要稍微注意常数优化（其实我把存 $\operatorname{lcm}$ 对应编号的 `map` 换成 `unordered_map` 就基本没问题了，[最慢的点](https://www.luogu.com.cn/record/180264978)都不超过 $500ms$）。

# 代码

可以看到核心代码很短。`madd`、`mmul` 分别是模意义下的加法、乘法。

```cpp
// 2:8, 3:5, 5:3, 7:2, 11:2, 13:2, 17:2
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 3e5 + 5, M = 305, TOT = 2e4 + 5;
ll val[TOT];
int spr[] = {0, 2, 3, 5, 7, 11, 13, 17}, stot = 7, pow_2[N];
int n, MOD, a[N], tot, cnt[M], m, dp[M][TOT][2], ans;
unordered_map<ll, int> id;
pair<int, int> b[N], t[M];  // first存的是大质数，second存的是所有小质数的积
inline int madd(int x, int y) { return x + y >= MOD ? x + y - MOD : x + y; }
inline int msub(int x, int y) { return madd(x, MOD - y); }
inline int mmul(int x, int y) { return 1ll * x * y % MOD; }
inline ll gcd(ll x, ll y) { return y == 0 ? x : gcd(y, x % y); }
inline ll lcm(ll x, ll y) { return x / gcd(x, y) * y; }

void init()
{
    for (int i2 = 1; i2 <= 300; i2 *= 2)
    for (int i3 = 1; i3 <= 300; i3 *= 3)
    for (int i5 = 1; i5 <= 300; i5 *= 5)
    for (int i7 = 1; i7 <= 300; i7 *= 7)
    for (int i11 = 1; i11 <= 300; i11 *= 11)
    for (int i13 = 1; i13 <= 300; i13 *= 13)
    for (int i17 = 1; i17 <= 300; i17 *= 17)
    {
        ll x = 1ll * i2 * i3 * i5 * i7 * i11 * i13 * i17;
        val[++tot] = x;
        id[x] = tot;
    }
    pow_2[0] = 1; // 预处理2的幂次
    for (int i = 1; i <= n; i++)
        pow_2[i] = madd(pow_2[i - 1], pow_2[i - 1]);
}

int main()
{
#ifdef aquazhao
    freopen("data.in", "r", stdin);
    freopen("data.out", "w", stdout);
#endif
    cin >> n >> MOD;
    init();
    // cout << tot << endl;
    for (int i = 1; i <= n; i++)
        scanf("%d", a + i);
    for (int i = 1; i <= n; i++)
    {
        b[i] = {1, 1};
        for (int j = 1; j <= stot; j++)
            while (a[i] % spr[j] == 0)
            {
                a[i] /= spr[j];
                b[i].second *= spr[j];
            }
        b[i].first = a[i];
    }
    sort(b + 1, b + n + 1); // 按大质数排序
    for (int i = 1; i <= n; i++) // 去重
    {
        if (b[i] != b[i - 1])
            t[++m] = b[i];
        cnt[m]++;
    }
    dp[0][id[1]][0] = 1;
    for (int i = 1; i <= m; i++)
    {
        if (t[i].first == t[i - 1].first)
            for (int j = 1; j <= tot; j++)
            {
                ll x = lcm(val[j], t[i].second);
                dp[i][j][0] = madd(dp[i][j][0], dp[i - 1][j][0]);
                dp[i][j][1] = madd(dp[i][j][1], dp[i - 1][j][1]);
                dp[i][id[x]][1] = madd(dp[i][id[x]][1], mmul(madd(mmul(dp[i - 1][j][0], t[i].first), dp[i - 1][j][1]), pow_2[cnt[i]] - 1));
            }
        else
            for (int j = 1; j <= tot; j++)
            {
                ll x = lcm(val[j], t[i].second);
                dp[i][j][0] = madd(dp[i][j][0], madd(dp[i - 1][j][0], dp[i - 1][j][1]));
                dp[i][id[x]][1] = madd(dp[i][id[x]][1], mmul(mmul(madd(dp[i - 1][j][0], dp[i - 1][j][1]), t[i].first), pow_2[cnt[i]] - 1));
            }
    }
    for (int i = 1; i <= tot; i++)
        ans = madd(ans, mmul(madd(dp[m][i][0], dp[m][i][1]), val[i] % MOD));
    cout << ans << endl;
    return 0;
}
```

If you can，~~点个赞呗。~~

---


# [eJOI 2019] 矩形染色

## 题目背景

**警告：滥用本题评测将被封号**

## 题目描述

Srečko 想给一个 $m$ 行（从 $0$ 至 $m-1$ 编号） $n$ 列（从 $0$ 至 $n-1$ 编号）的的矩形网格的每一个格子染上色。一开始，整个矩形都是白色的。每一步，他都会选择一条对角线，并给这条对角线上的所有格子染上色。每个对角线染色都需要一定的费用（忽略长度），这就导致某些对角线的染色费用有高于其他某些对角线。

你需要写一个程序，读入各个对角线的染色费用，求出将所有格子染上色的最小总费用。

**注意，同一个格子被重复多次地染色是被允许的。**

------------------------------------

一个 $m$ 行 $n$ 列的矩形网格共有 $2n+2m-2$。

例：当 $m=4,n=3$ 时，共有 $12$ 条对角线：

![e.g.](https://cdn.luogu.com.cn/upload/image_hosting/j74h8wgo.png)

## 说明/提示

#### 【输入输出样例解释】

**样例 1 解释**

- 在这个情况中，如下的方案可以得到最小花费：

![sample1](https://cdn.luogu.com.cn/upload/image_hosting/m2meji32.png)

总花费 $=1+1+1+1=4$。

**样例 2 解释**

- 对于这个情况，如下的方案可以使花费最小化：

![sample2](https://cdn.luogu.com.cn/upload/image_hosting/4xp4192w.png)

总花费 $=3+2+3+3+1+2=14$。

-------------------------

#### 【数据规模与约定】

**本题采用多测试点捆绑测试，共有 7 个子任务**。

- Subtask 1（10 points）：$n,m\le 4$
- Subtask 2（10 points）：$m,n\le 10$
- Subtask 3（10 points）：$m,n\le 20$
- Subtask 4（20 points）：$m,n\le 2\times 10^3$
- Subtask 5（10 points）：$m=1,n\le 2\times 10^5$
- Subtask 6（20 points）：$m=n\le 2\times 10^5$
- Subtask 7（20 points）：无其他限制。

对于所有数据，保证 $1\le m,n\le 2\times 10^5$，每条对角线的染色费用 $\in [1,10^9]$

-----------------------

#### 【说明】

原题来自：[eJOI2019](https://www.ejoi2019.si) Problem E. [Colouring	a	rectangle](https://www.ejoi2019.si/static/media/uploads/tasks/colouring-isc.pdf)。

翻译提供：@[```_Wallace_```](https://www.luogu.com.cn/user/61430)。

## 样例 #1

### 输入

```
​2 2
1 3 1
1 3 1```

### 输出

```
4```

## 样例 #2

### 输入

```
​4 3
2 3 9 3 4 3
2 3 3 1 2 4​```

### 输出

```
14```

# 题解

## 作者：yyyyxh (赞：17)

wssb，感谢 zhy 指教。

提供一个简单得多的做法：每个格子只会被两条来自不同方向的对角线覆盖，考虑把每个格子看成一条边，问题转换成了二分图最小权点覆盖问题。这是经典网络流问题，最小割建模可以拿到 40 分。

观察一下连边的形式，我们对于格子 $(i,j)$ 定义 $x=i+m-j,y=i+j-1$，那么这个格子会对左部的 $x$ 与右部的 $y$ 连边。

推推式子，可以得到 $(x,y)$ 有连边当且仅当：

$$
y\in [m+1-x,2n+m-1-x]\cap [1-m+x,x+m-1]
$$

且要求 $x+y+m$ 是奇数。

将原图按照奇偶分类后就变成了如下问题：对于每一个左部点，向右部点的一个区间连边，求最大流。

这个问题十分经典，我们考虑直接贪心：按照右端点排序，每次选择最靠近左端点的流。这个可以用并查集维护。

按照右端点排序可以用计数排序做到 $O(n)$，所以总时间复杂度可以做到 $O(n\alpha(n))$。

这里是 $O(n\log n)$ 直接 `sort` 的代码：

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int read(){/*...*/}
typedef long long ll;
const int N=400003;
int n,m,rk,tp;
int a[N],b[N];
int val[N];
struct seq{
	int l,r,x;
	friend bool operator<(const seq a,const seq b){
		return a.r<b.r;
	}
}s[N];
int f[N];
int rt(int x){
	if(f[x]==x) return x;
	return f[x]=rt(f[x]);
}
ll solve(){
	for(int i=1;i<=rk+1;++i) f[i]=i;
	sort(s+1,s+tp+1);
	ll sum=0;
	for(int i=1;i<=tp;++i){
		while(rt(s[i].l)<=s[i].r&&s[i].x){
			int p=rt(s[i].l);
			int t=min(val[p],s[i].x);
			s[i].x-=t;val[p]-=t;
			sum+=t;
			if(!val[p]) f[p]=p+1;
		}
	}
	return sum;
}
int main(){
	n=read();m=read();
	for(int i=1;i<n+m;++i) a[i]=read();
	for(int i=1;i<n+m;++i) b[i]=read();
	ll res=0;
	for(int p=1,t=m&1;;p^=1,t^=1){
		tp=rk=0;
		for(int i=p?1:2;i<n+m;i+=2){
			int l=max(m+1-i,1-m+i);
			int r=min(n+n+m-1-i,i+m-1);
			if((l&1)!=t) ++l;
			if((r&1)!=t) --r;
			l=(l+1)>>1;
			r=(r+1)>>1;
			if(l<=r){++tp;s[tp].l=l;s[tp].r=r;s[tp].x=a[i];}
		}
		for(int i=t?1:2;i<n+m;i+=2) val[++rk]=b[i];
		res+=solve();
		if(!p) break;
	}
	printf("%lld\n",res);
	return 0;
}
```

---

## 作者：xtx1092515503 (赞：13)

**update on 2020-6-11：**

感谢@he_____he 提供的hack数据：

```
8 10
66 490 871 85 937 438 533 353 904 357 118 142 802 43 507 687 107 
92 191 231 850 974 424 371 132 157 898 307 188 681 489 658 551 614
```

如果还发现本代码出锅请务必告知。

本代码现在可以通过hack数据。

------------

**update on 2020-6-11：**

（梅 开 二 度）

再次感谢he_____he神仙的hack，毕竟这种特例在原题里是找不到的~~只能全靠hack~~

修改了一个地方写的“取$\max$”，应为“取$\min$”（所以才出锅）

------------

闲话先说几句：

这道题我整整做了4天，然后全网没有一篇题解，于是我就被它折腾得死去活来，然后终于做出来的时候：

~~噫！好！我A了！~~

然后还有这4天中尝试过的种种思路（包括但不限于）：

网络流、二分图、最小生成树（Borůvka）、2-SAT、FFT、二维数点、线段树优化DP、splay优化DP，以及许多奇奇怪怪的乱搞……


------------

闲话说完，正片开始。

我们找出一张典型的矩形：

![](https://cdn.luogu.com.cn/upload/image_hosting/9gbgyogo.png)

第一个发现：**奇数格与偶数格永远不会相互影响**。

因此，我们可以分开考虑。以下只分析奇数格，即下图黑色部分：

![](https://cdn.luogu.com.cn/upload/image_hosting/ewaku5n2.png)

看着不是连续的好不爽呀！我们不妨将所有小正方形按照从右上角往左下角的顺序排列一下，于是上面的所有黑格子就可以转成这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/9wavdhgu.png)

于是，我们惊讶地发现，所有原图中的**对角线**，在新图内都被转成了**横线**或**竖线**！！


------------

一不做二不休，我们不妨在新图中标出这些横线和竖线的顺序：

![](https://cdn.luogu.com.cn/upload/image_hosting/fcppsxwy.png)

我们令纵向（即橙色字体的对角线）叫做$b$对角线，而横向（即紫色字体的对角线）叫做$a$对角线。第$i$条$b$对角线我们把它称作$B_i$，它的费用为$b_i$；而第$i$条$a$对角线称作$A_i$，它的费用为$a_i$。

在这么标号后，我们可以很轻松地描述一条对角线。比如说，对角线$A_1$经过的位置就是$[B_3,B_3]$，而对角线$A_4$经过的位置就是$[B_2,B_6]$（注意它们都表示一段区间）。我们设一条$A$对角线经过位置$[l_i,r_i]$。（**注意这个表述只对$A$对角线有效！因为我们马上要针对$A$方向DP**）。

在DP之前，我们默认要有$1<n\leq m$。如果$n>m$，可以交换$n$和$m$；而如果$n$和$m$有一个为$1$，可以直接特判出去。


------------

在这么处理过后，我们可以将这整个图形划分成3部分（因为整个图像长得很像一个歪了$45\degree$的长方形，因此我们接下来的图中会近似把它看作长方形）：

![](https://cdn.luogu.com.cn/upload/image_hosting/merca0hu.png)

部分I，即长方形顶上的直角三角形，这里的所有$A_i$都有$[l_{i-1},r_{i-1}]\subseteq[l_i,r_i]$，或者更准确地说$l_{i-1}-l_i=1,r_{i-1}-r_i=-1$，但后者在边界处可能不成立。

部分II，即长方形中间的一部分。这里所有$A_i$都有$[l_{i-1},r_{i-1}]\neq[l_i,r_i]$，或者更准确地说$l_{i-1}-l_i=-1,r_{i-1}-r_i=-1$，但后者在边界处可能不成立。

部分III，即长方形下部的直角三角形。这里所有$A_i$都有$[l_{i-1},r_{i-1}]\supseteq[l_i,r_i]$，或者更准确地说$l_{i-1}-l_i=-1,r_{i-1}-r_i=1$，但后者在边界处可能不成立。


------------

我们设$f[i][0/1]$表示：

当前DP到了$A_i$这条对角线，且$A_1\sim A_i$已全部被刷上了颜色。后一维是$0$表示$A_i$被刷上了$a_i$，而$1$则表示被刷上了$b_{[l_i,r_i]}$。

则我们可以设出这样的常规转移式：

$$\Large f[i][1]=\min\begin{cases}f[i-1][1]+b_{[l_i,r_i]\setminus[l_{i-1},r_{i-1}]}\\f[i-1][0]+b_{[l_i,r_i]}\end{cases}$$

其中$\setminus$符号表示从一个集合中删去另一个集合。

$$f[i][0]=\min\{f[i-1][0],f[i-1][1]\}+a_i$$


------------

注意到我们这里的措辞是**常规转移式**，那就意味着肯定有**非常规转移式**。

非常规转移式分为三种类型，即I转移II；I/II转移III；I转移III。

I转移II的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/67lvvhqz.png)

如图，淡粉色的地方是选择的$b_i$，而紫色的地方是被覆盖住的$A$。可以发现，这种时候出现了一段跳跃，需要特殊地转移。

具体地说，我们在枚举$i$时，同时用two-pointer的思想维护一个$j$，表示最小的有$l_j\geq l_i$的$j$，即可以通过这么“跳跃”跳到的最靠前的那个位置。此时，$f[i][1]$可以转移到$f[j][1]$。


------------

与其类似地，还有I/II转移III的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/ygs5zr0s.png)

~~其实只是把上一个图倒了过来~~

还是一样，会出现一次跳跃。这时，我们需要再two-pointer地维护一个$k$，表示最小的有$r_k\leq r_i$的$k$。此时，$f[i][1]$可以转移到$f[k][1]$。


------------

**update:**

第三种情况是我一开始没有想到的，但是题目中并没有出现这种数据导致错误代码可以通过。具体而言，这种数据的解应该长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/v8tbd0cg.png)

两部分都只在I和III中出现，II中没有。

但是，这种方法无法像前两种情况用双针维护——是因为可以转移到的位置具有**上下界**，其中上界是III中最小的有$l_l\geq l_i$的$l$，而下界是II中的那个$k$减去$1$。

有上下界，就只能用**线段树**维护区间取$\min$了。看上去这要用吉司机线段树才能实现，但实际上我们只需要排序后就可以用区间修改线段树完成。

具体而言，有

$$\Large f[i][1]+a_{t-1}-a_i+b_{r_t}-b_{r_i}\rightarrow f[t][1]$$

其中$t\in[l,k)$，$\rightarrow$表示可以转移到。

我们将左边拆成两部分，一半只与$i$有关，一半只与$t$有关：

$$\Large (f[i][1]-a_i-b_{r_i})+(a_{t-1}+b_{r_t})$$

前一半用线段树维护，然后在每个位置加上后一半即可。

------------

则最终答案即为$\min\{f[\dfrac{n+m}{2}][0],f[\dfrac{n+m}{2}][1]\}$。

等等，这个$\dfrac{n+m}{2}$是哪来的？

这是**所有$A$对角线的数量**。这就涉及到我们之前一直没提的问题：**对角线的编号是怎么得出的**？

这又牵扯到一个大问题了。我采取的编号方式是：

首先$A$方向的编号是很容易得出的。

然后考虑$B$方向的编号，即求出$[l_i,b_i]$。

如果你好好想想的话，就会发现$l_{(n+1)/2}=1$，因为这个位置对应着原图中的左上角。然后，依据相邻两个位置的$l$变化总为$1$（除了一些边界要特判外），我们可以得出所有的$l_i$。因为$l_1=r_1$，也可以类似地得出$r_i$。

因为每个人的编号方式可能不同，这里就不再多说了。有兴趣的人可以看看我的代码中是如何编号的，但衷心建议读者**一定要自己想想**，因为许多**特判**实在是你不自己试试都试不出来的。


------------

到这里，我们其实才完成了一半！别忘了，我们一开始就声明前面所述的都是**奇格**的情况，还有**偶格**需要考虑，即下图白色部分：

![](https://cdn.luogu.com.cn/upload/image_hosting/ewaku5n2.png)

实际上，偶格最大的区别就是在**编号**方面有所改变，比如总对角线数目为$\dfrac{n+m-1}{2}$。DP方面倒真没有任何区别。

------------

最后，因为这道题**特判过多**，我**很难保证不会有刁钻数据把我的题解卡掉**。如果你发现了这样的数据，请务必告知我。

如果你看懂了这篇题解，就请点个赞吧！

（本代码加上后面的数据一共有6573B，荣膺我历史写过的最长代码；本题解一共写了15K，荣膺我历史写过的最长题解；本题解一共使用8张图，荣膺我历史写过的图最多的题解）

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define lson x<<1
#define rson x<<1|1
#define mid ((l+r)>>1)
#define int long long
int n,m,col[400100],row[400100],a[200100],b[200100],lim,f[200100][2],seg[800100];
pair<int,int>p[200100];
void pushdown(int x){
	if(seg[x]!=0x3f3f3f3f3f3f3f3fll)seg[lson]=seg[rson]=seg[x],seg[x]=0x3f3f3f3f3f3f3f3fll;
}
void modify(int x,int l,int r,int L,int R,int val){
	if(l>R||r<L)return;
	if(L<=l&&r<=R){seg[x]=val;return;}
	pushdown(x),modify(lson,l,mid,L,R,val),modify(rson,mid+1,r,L,R,val);
}
int query(int x,int l,int r,int P){
	if(l>P||r<P)return 0;
	if(l==r)return seg[x]+b[p[l].second]+a[l-1];
	pushdown(x);
	return query(lson,l,mid,P)+query(rson,mid+1,r,P);
}
vector<pair<int,pair<int,int> > >v;
bool cmp(pair<int,pair<int,int> >x,pair<int,pair<int,int> >y){
	return x>y;
}
int func1(){
	int res=0x3f3f3f3f3f3f3f3fll;
	for(int i=1;i<=(n+m)/2;i++)a[i]=col[i*2-1];
	if(n&1)for(int i=1;i<=(n+m)/2;i++)p[i].first=abs((n+1)/2-i)+1;
	else{
		for(int i=1;i<=n/2;i++)p[i].first=n/2-i+1;
		for(int i=n/2+1;i<=(n+m)/2;i++)p[i].first=i-n/2;
	}
	p[1].second=p[1].first;
	for(int i=2;i<=(m+1)/2;i++)p[i].second=p[i-1].second+1;
	lim=p[(m+1)/2].second;
	for(int i=(m+1)/2+1;i<=(n+m)/2;i++)p[i].second=p[i-1].second-1;
	if(!(m&1))for(int i=(m+1)/2+1;i<=(n+m)/2;i++)p[i].second++;
//	for(int i=1;i<=(n+m)/2;i++)printf("(%lld,%lld):%lld\n",p[i].first,p[i].second,a[i]);
	if(n&1)for(int i=1;i<=lim;i++)b[i]=row[i*2-1];
	else for(int i=1;i<=lim;i++)b[i]=row[i*2];
//	for(int i=1;i<=lim;i++)printf("%lld ",b[i]);puts("");
	for(int i=1;i<=(n+m)/2;i++)a[i]+=a[i-1];
	for(int i=1;i<=lim;i++)b[i]+=b[i-1];
	memset(f,0x3f,sizeof(f));
	memset(seg,0x3f,sizeof(seg));
	f[0][0]=0;
	for(int i=1,j=(n+m)/2+1,k=(n+m)/2+1,l=(n+m)/2+1;i<=(n+1)/2;i++){
		f[i][1]=min(f[i][1],f[i-1][0]+b[p[i].second]-b[p[i].first-1]);
		f[i][1]=min(f[i][1],f[i-1][1]+max(0ll,b[p[i].second]-b[p[i-1].second])+max(0ll,b[p[i-1].first-1]-b[p[i].first-1]));
		f[i][0]=min(f[i-1][1],f[i-1][0])+a[i]-a[i-1];
		while(j>(n+1)/2+1&&p[j-1].first>=p[i].first)j--;
		f[j][1]=min(f[j][1],f[i][1]+max(0ll,b[p[j].second]-b[p[i].second])+a[j-1]-a[i]);
		while(k>(m+1)/2+1&&p[k-1].second<=p[i].second)k--;
		f[k][1]=min(f[k][1],f[i][1]+a[k-1]-a[i]);
		while(l>(m+1)/2+1&&p[l-1].first>=p[i].first)l--;
		if(k>l)v.push_back(make_pair(f[i][1]-b[p[i].second]-a[i],make_pair(l,k-1)));
	}
	sort(v.begin(),v.end(),cmp);
	for(int i=0;i<v.size();i++)modify(1,1,(n+m)/2,v[i].second.first,v[i].second.second,v[i].first);
	for(int i=(m+1)/2+1;i<=(n+m)/2;i++)f[i][1]=min(f[i][1],query(1,1,(n+m)/2,i));
	for(int i=(n+1)/2+1,j=(n+m)/2+1;i<=(m+1)/2;i++){
		f[i][1]=min(f[i][1],b[p[i].second]-b[p[i].first-1]+f[i-1][0]);
		f[i][1]=min(f[i][1],f[i-1][1]+max(0ll,b[p[i].second]-b[p[i-1].second])+max(0ll,b[p[i-1].first-1]-b[p[i].first-1]));
		f[i][0]=min(f[i-1][1],f[i-1][0])+a[i]-a[i-1];
		while(j>(m+1)/2+1&&p[j-1].second<=p[i].second)j--;
		f[j][1]=min(f[j][1],f[i][1]+a[j-1]-a[i]);
	}
	for(int i=(m+1)/2+1;i<=(n+m)/2;i++){
		f[i][1]=min(f[i][1],f[i-1][1]);
		f[i][1]=min(f[i][1],f[i-1][0]+b[p[i].second]-b[p[i].first-1]);
		f[i][0]=f[i-1][0]+a[i]-a[i-1];
	}
	return min(f[(n+m)/2][0],f[(n+m)/2][1]);
}
int func2(){
	int res=0x3f3f3f3f3f3f3f3fll;
	for(int i=1;i<=(n+m-1)/2;i++)a[i]=col[i*2];
	if(!(n&1))for(int i=1;i<=(n+m-1)/2;i++)p[i].first=abs(n/2-i)+1;
	else{
		for(int i=1;i<=n/2;i++)p[i].first=n/2-i+1;
		for(int i=n/2+1;i<=(n+m-1)/2;i++)p[i].first=i-n/2;
	}
	p[1].second=p[1].first+1;
	for(int i=2;i<=m/2;i++)p[i].second=p[i-1].second+1;
	lim=p[m/2].second;
	for(int i=m/2+1;i<=(n+m-1)/2;i++)p[i].second=p[i-1].second-1;
	if(m&1)for(int i=m/2+1;i<=(n+m-1)/2;i++)p[i].second++;
//	for(int i=1;i<=(n+m-1)/2;i++)printf("(%lld,%lld):%lld\n",p[i].first,p[i].second,a[i]);
	if(!(n&1))for(int i=1;i<=lim;i++)b[i]=row[i*2-1];
	else for(int i=1;i<=lim;i++)b[i]=row[i*2];
//	for(int i=1;i<=lim;i++)printf("%lld ",b[i]);puts("");
	for(int i=1;i<=(n+m-1)/2;i++)a[i]+=a[i-1];
	for(int i=1;i<=lim;i++)b[i]+=b[i-1];
	memset(f,0x3f,sizeof(f));
	memset(seg,0x3f,sizeof(seg));
	v.clear();
	f[0][0]=0;
	for(int i=1,j=(n+m-1)/2+1,k=(n+m-1)/2+1,l=(n+m-1)/2+1;i<=n/2;i++){
		f[i][1]=min(f[i][1],f[i-1][0]+b[p[i].second]-b[p[i].first-1]);
		f[i][1]=min(f[i][1],f[i-1][1]+max(0ll,b[p[i].second]-b[p[i-1].second])+max(0ll,b[p[i-1].first-1]-b[p[i].first-1]));
		f[i][0]=min(f[i-1][1],f[i-1][0])+a[i]-a[i-1];
		while(j>n/2+1&&p[j-1].first>=p[i].first)j--;
		f[j][1]=min(f[j][1],f[i][1]+max(0ll,b[p[j].second]-b[p[i].second])+a[j-1]-a[i]);
		while(k>m/2+1&&p[k-1].second<=p[i].second)k--;
		f[k][1]=min(f[k][1],f[i][1]+a[k-1]-a[i]);
		while(l>m/2+1&&p[l-1].first>=p[i].first)l--;
		if(k>l)v.push_back(make_pair(f[i][1]-b[p[i].second]-a[i],make_pair(l,k-1)));
	}
	sort(v.begin(),v.end(),cmp);
	for(int i=0;i<v.size();i++)modify(1,1,(n+m-1)/2,v[i].second.first,v[i].second.second,v[i].first);
	for(int i=m/2+1;i<=(n+m-1)/2;i++)f[i][1]=min(f[i][1],query(1,1,(n+m-1)/2,i));
	for(int i=n/2+1,j=(n+m-1)/2+1;i<=m/2;i++){
		f[i][1]=min(f[i][1],b[p[i].second]-b[p[i].first-1]+f[i-1][0]);
		f[i][1]=min(f[i][1],f[i-1][1]+max(0ll,b[p[i].second]-b[p[i-1].second])+max(0ll,b[p[i-1].first-1]-b[p[i].first-1]));
		f[i][0]=min(f[i-1][1],f[i-1][0])+a[i]-a[i-1];
		while(j>m/2+1&&p[j-1].second<=p[i].second)j--;
		f[j][1]=min(f[j][1],f[i][1]+a[j-1]-a[i]);
	}
	for(int i=m/2+1;i<=(n+m-1)/2;i++){
		f[i][1]=min(f[i][1],f[i-1][1]);
		f[i][1]=min(f[i][1],f[i-1][0]+b[p[i].second]-b[p[i].first-1]);
		f[i][0]=f[i-1][0]+a[i]-a[i-1];
	}
//	for(int i=1;i<=(m+1)/2;i++)printf("%lld %lld\n",f[i][0],f[i][1]);
	return min(f[(n+m-1)/2][0],f[(n+m-1)/2][1]);
}
signed main(){
	scanf("%lld%lld",&m,&n);
	for(int i=1;i<n+m;i++)scanf("%lld",&col[i]);
	for(int i=1;i<n+m;i++)scanf("%lld",&row[i]);
	if(n>m)reverse(row+1,row+n+m),swap(n,m);
	if(n==1){
		int sum=0;
		for(int i=1;i<n+m;i++)sum+=min(row[i],col[i]);
		printf("%lld\n",sum);
		return 0;
	}
	int A=func1();
	int B=func2();
	printf("%lld\n",A+B);
	return 0;
} 
```


---

## 作者：zhuzhu2891 (赞：5)

~~说实话楼上楼下把我看急眼了，这么久没人写线性做法？？？~~

这里提供一种严格 $O(N)$ 的做法。

首先我们先可以保证 $n<m$，如果不那么显然可以转化。

接着显然黑白染色后两种颜色互不影响，这里只考虑一种颜色。

若我们所有边都选上，那么每个点会被涂两次，于是我们可以转化：最小覆盖=（所有边-最大独立集）。只需计算最大独立集即可。

考虑对于每一种放置方案，如果有一条这样的边。

![](https://cdn.luogu.com.cn/upload/image_hosting/yt5m891g.png)

那么必然会这样

![](https://cdn.luogu.com.cn/upload/image_hosting/iq1um2gw.png)

或者会这样

![](https://cdn.luogu.com.cn/upload/image_hosting/5f87zpcw.png)

于是我们感性理解，发现最终解肯定长得像这样

![](https://cdn.luogu.com.cn/upload/image_hosting/qpc1j5eo.png)

这个东西看起来堆得很紧密，似乎很好转移，于是我们可以考虑 dp,设 $dpa_i$ 表示选择 $a_i$ 且它上面的区域已决定的最大权值和，$dpb_i$ 类似。

转移只有以下几种情况（红色表示已决定区域，蓝色表示转移到的边，紫色表示转移时附加的贪心边）

![](https://cdn.luogu.com.cn/upload/image_hosting/t2dwbj9n.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/hwhib4cr.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/8ekkxwdc.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/311wxhcm.png)

虽然看起来很多，但其实就两种，变化一下转移函数就可以了。dp 状态是 $O(N)$ 的，转移数是 $O(1)$ 的，总共 $O(N)$。

~~然后我们通过了这题，然后打开了题解区，然后看到了特殊情况，然后寄了~~

对于这样一组样例，我们的程序寄了，~~怎么会是呢？~~

```
5 3
100 1 1 1 1 1 100
100 1 1 1 1 1 100
```

注意到前面我们说

>……如果有一条这样的边……

但事实上有的时候没有，所以我们需要特判一下这种情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/qpzo8iqh.png)

这种情况可以枚举上方的分界点，然后发现下方的分界点必须在一个区间里，然后就可以用单调队列做到 $O(N)$ 啦！

附：代码（因为没有卡特判，所以我的特判可能是写挂的，如果发现特判挂了可以指出）

```cpp
#include<set>
#include<map>
#include<queue>
#include<vector>
#include<algorithm>
#include<bits/stdc++.h>
#define pr pair
#define f first
#define s second
#define ll long long
#define mp make_pair
#define pll pr<ll,ll>
#define pii pr<int,int>
#define piii pr<int,pii>
using namespace std;
ll a[400005],b[400005];
ll af[400005],bf[400005];
ll da[400005],db[400005];
ll spa[400005],spb[400005];
int dq[400005],l,r;
void add(int i)
{
	if(i<0) return;
	while(l<r)
	{
		int x=dq[r-1];
		if(spb[x]>spb[i]) break;
		r--;
	}
	dq[r++]=i;
}
void del(int i){
if(dq[l]==i) l++;}
int main()
{
	ios_base::sync_with_stdio(0);
	int n,m;
	cin>>n>>m;
	ll tot=0;
    for(int i=0;i<n+m-1;i++) cin>>a[i],tot+=a[i];
    for(int i=0;i<n+m-1;i++) cin>>b[i],tot+=b[i];
    if(n==1&&m==1)
    {
        cout<<min(a[0],b[0])<<endl;
        return 0;
    }
    int k=n+m-1;
    if(n<m)
    {
        swap(n,m);
        for(int i=0;i<k;i++) swap(a[i],b[i]);
        reverse(a,a+k);
    }
    for(int i=0;i<=k;i++) af[i+2]=af[i]+a[i];
    for(int i=0;i<=k;i++) bf[i+2]=bf[i]+b[i];
	//下面是特判
	ll ansa=0,ansb=0;//a[k-1] a[k-2]
	if(m>2)
	{
		for(int i=1;i<m-1;i++)
		{
			spa[i]=af[i+1]+bf[m-i];
			spb[i]=bf[k+i%2]-bf[k-i]+af[k+(k-n-i)%2]-af[n+i];
		}
		int st=m-(n-m+1)%2-1;
		for(int i=st;i>=n-(n-m)*2-2;i-=2) add(i);
		for(int i=1;i<m-1;i+=2)
		{
			ansa=max(ansa,spb[dq[l]]+spa[i]);
			add(n-(n-m)*2-i-3);
			del(n-i-1);
		}
		l=0;
		r=0;
		st=min(m-(n-m)%2-1,n-3);
		for(int i=st;i>=n-(n-m)*2-3;i-=2) add(i);
		for(int i=2;i<m-1;i+=2)
		{
			ansb=max(ansb,spb[dq[l]]+spa[i]);
			add(n-(n-m)*2-i-3);
			del(n-i-1);
		}
		if(k%2==0) swap(ansa,ansb);
	}
	//上面是特判
    da[0]=a[0];
    db[0]=b[0];
    da[1]=a[1];
    db[1]=b[1];
    for(int i=2;i<k;i++)
    {
        da[i]=da[i-2]+a[i];
        db[i]=db[i-2]+b[i];
        if(i>=m+1)
        {
            ll zy=db[i-m-1];
            if(i-m-1<m) zy+=af[m-(i-m-1)-1];
            if(i>=n) zy+=bf[k+n-i+(i-n+1)/2*2]-bf[k+n-i];
            da[i]=max(da[i],zy+a[i]);
            zy=da[i-m-1];
            if(i-m-1<m) zy+=bf[m-(i-m-1)-1];
            if(i>=n) zy+=af[k+n-i+(i-n+1)/2*2]-af[k+n-i];
            db[i]=max(db[i],zy+b[i]);
        }
    }
    if(m%2==0) cout<<tot-max(ansa,max(da[k-1],db[k-2]))-max(ansb,max(da[k-2],db[k-1]))<<endl;
    else cout<<tot-max(ansa,max(da[k-1],db[k-1]))-max(ansb,max(da[k-2],db[k-2]))<<endl;
	return 0;
}
```

~~怎么一半都是特判/oh~~

---

## 作者：Others (赞：5)

恶心细节题。

**序言**：

本题解思路由[这篇题解](https://codeforces.com/blog/entry/101210)的 Obfuscation 部分启发，再加上自己 yy 得到的。

**Solution**:

刚看完题第一个想法应该是每个点对应两条对角线，然后有些对角线是不互相影响的，就是黑白染色后的不同颜色的对角线，于是我们分成两类分别处理。

可以发现如果某一条对角线没涂，那他肯定是被另一个方向的对角线涂满的，反过来想，如果另一个方向的那一坨对角线有一根没涂，这个方向的这根对角线就必须涂。所以我们考虑某个方向的某个对角线 $x$ 对应哪些另一个方向的对角线 $\{y\}$，显然，这 $\{y\}$ 的下标是连续的（黑白分类后），所以我们可以把 $\{y\}$ 看成序列的一个子区间，然后 $x$ 就是序列里的一个限制：如果子区间里有一个没涂，那就会有 $a_x$ 或 $b_x$ 的花费。涂序列里的元素也有对应的消费。

于是就成了一个序列和限制的题了。假设序列是 $\{a_i\}$，限制是 $\{b_i\}$，状态 $dp_i$ 为第 $i$ 个元素不涂时，前 $i$ 个元素的最小花费。谢谢转移方程 $dp_i=\min\limits_{1\le j<i}\{dp_j+suma_{i-1}-suma_j+$ 覆盖了 $i$ 没有覆盖 $j$ 的限制的花费 $\}$，于是就有了一个 $O(n^2m)$ 的美妙做法，但是可以发现方程里的 $suma_{i-1}$ 可以拿出来，$dp_j-suma_j$ 可以随便维护，困难的就是怎么维护最后一项的花费。考虑每个一覆盖了 $i$ 的限制 $[l_k,r_k,w_k]$，在 $[l_k,i]$ 里的 $j$ 就没有贡献，而 $[1,l_k)$ 里的就有贡献，于是就可以在 $i$ 进入一个新限制时，对 $[1,l_k)$ 里的值加上 $w_i$，离开时就减去。转移完一个 $i$ 后就把 $dp_i-suma_i$ 插入数据结构里，用什么可以维护区间加，区间最小值的数据结构就行。

**Code**：

```cpp
#include <bits/stdc++.h>
#define ll long long
#define int long long
using namespace std;
const int N=1000005,inf=0x3f3f3f3f3f3f3f3f;
ll n,m,k,a[N],p[N],q[N],dp[N],ans;
struct modify {
	int x,w;
};vector<modify> vec[N];
struct Others {
	//线段树的板
}T,T1;
signed main() {
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n+m-1;i++) scanf("%lld",&p[i]);
	for(int i=1;i<=n+m-1;i++) scanf("%lld",&q[i]);
	for(int i=1;i<=n+m-1;i+=2) 
		k++,a[k]=a[k-1]+p[i];
	if(k) {
		T.build(0,k,1);
		for(int i=2-(m&1);i<=n+m-1;i+=2) {
			if(i<m) vec[(m-i)/2+1].push_back((modify){(m-i)/2,q[i]});
			else vec[(i-m)/2+1].push_back((modify){(i-m)/2,q[i]});
			if(i<n) vec[(i+m)/2+1].push_back((modify){abs((m-i)/2),-q[i]});
			else vec[n+1+(m-i)/2].push_back((modify){abs((m-i)/2),-q[i]});
		}
		ll tmp=a[k];
		for(int i=1;i<=k;i++) {
			for(const auto &lxl:vec[i]) T.add(0,lxl.x,0,k,1,lxl.w);
			vec[i].clear();
			if(i==0) continue;
			dp[i]=T.getmin(0,i-1,0,k,1)+a[i-1];
			tmp=min(tmp,dp[i]+a[k]-a[i]);
			T.add(i,i,0,k,1,dp[i]-a[i]);
		}
		ans=tmp;
		k=0;
	}
	for(int i=2;i<=n+m-1;i+=2) 
		k++,a[k]=a[k-1]+p[i];
	if(k) {
		T1.build(0,k,1);
		for(int i=2-(!(m&1));i<=n+m-1;i+=2) {
			if(i<m) vec[(m-i+1)/2].push_back((modify){(m-i-1)/2,q[i]});
			else vec[(i-m+1)/2].push_back((modify){(i-m-1)/2,q[i]});
			if(i<n) vec[(i+m+1)/2].push_back((modify){(abs(m-i)-1)/2,-q[i]});
			else vec[n+(m-i+1)/2].push_back((modify){(abs(m-i)-1)/2,-q[i]});
		}
		memset(dp,0,sizeof(dp));
		ll tmp=a[k];
		for(int i=1;i<=k;i++) {
			for(const auto &lxl:vec[i]) T1.add(0,lxl.x,0,k,1,lxl.w);
			dp[i]=T1.getmin(0,i-1,0,k,1)+a[i-1];
			tmp=min(tmp,dp[i]+a[k]-a[i]);
			T1.add(i,i,0,k,1,dp[i]-a[i]);
		}
		ans+=tmp;
	}
	printf("%lld\n",ans);
	return 0;
}

```

---

## 作者：To_our_starry_sea (赞：0)

### Solution

感觉这道题的性质还是很好的，有一定的思维难度。

首先，一个最基本的 observation 是对于每一个格子，其能且只能被两条对角线覆盖。且对网格进行黑白染色后，黑点和白点互相独立。换言之，对于经过一个点的两条对角线，我们至少需要选择其中的一条进行染色。这显然是二分图最小权点覆盖模型，如果直接网络流做的话期望得分 30pts，加上特殊性质的 10pts 可以得到 40pts。

显然，图论建模的方法可优化空间不大，因此我们考虑从其他角度来刻画这个染色过程。我们不妨先只考虑一个方向的对角线，以***从左上到右下的对角线***为例。发现要么选这条对角线，要么对于该条对角线上的所有的点，经过其的另一条对角线都要选。我们按顺序观察每一条对角线，发现若某条对角线选择了前述的第二种方案，则同时也覆盖了其后的若干条对角线的若干个点，且对于第 $i$ 与第 $j$ 两条对角线，$i < j$，若其都选择了第二个方案，则第 $i$ 条的贡献必然被包含于第 $j$ 条的贡献中。由以上性质我们可以考虑用 dp 来求解该问题。设 $dp_i$ 表示考虑前 $i$ 条对角线，若第 $i$ 条对角线选择了用另一个方向的对角线覆盖，所需要的最小代价。则不难列出转移方程为 $dp_i = \min\limits_{j = 0}^{i - 1}(dp_j + \sum\limits_{k = j + 1}^{i - 1}a_k + cost(j, i))$，其中 $cost(j, i)$ 表示覆盖第 $i$ 条对角线上的未被用第二种方案覆盖第 $j$ 条对角线时染色的点的代价，这个是容易 $O(1)$ 计算的，而 $a_k$ 的和也容易用前缀和计算。从而我们得到了一个 $O(nm)$ 的解法，结合特殊性质可以得到 60pts。

接下来我们考虑进一步探究性质。回到原来的 dp 方程式，发现难以优化的便是 $cost(j, i)$ 这一个量。注意到一条从左下到右上的对角线，其可能有贡献的另一个方向的对角线恰好构成了一个区间。而我们考虑从 $j$ 转移到 $i$，发现每一条需要另外耗费代价的对角线，其的贡献区间恰好为一个前缀。因此我们考虑用线段树维护。预处理出对于每一条左下到右上的对角线，与其有交点的第一条和最后一条左上到右下的对角线，以及需要另外耗费代价的前缀区间。考虑在第一条有交点的对角线出加上代价，而后在最后一条处再减去代价，得到了 $O((n + m) \log(n + m))$ 的做法，可以获得满分。

我自己在写这道题的时候其实已经完成了以上的所有思考，但是注意到本题的预处理中会涉及比较复杂的讨论，故在代码实现上也有所参考了相关题解。

总之，本题在思维与实现上都有一定的难点，可以说是一道好题。

### Code


```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define ls(rt) (rt << 1)
#define rs(rt) (rt << 1 | 1)
#define PII pair<int, ll>
#define fi first
#define se second
const int MAXN = 500005;
const ll INF = 1e18;
int n, m;
ll ans = 0, a[MAXN], b[MAXN], sum[MAXN], dp[MAXN];
vector<PII> pos[MAXN], del[MAXN];
struct Segment_Tree {
    ll tr[MAXN << 2], layz[MAXN << 2];
    inline void pushup(int rt) {tr[rt] = min(tr[ls(rt)], tr[rs(rt)]);}
    inline void pushdown(int rt) {
        if (layz[rt]) {
            tr[ls(rt)] += layz[rt], layz[ls(rt)] += layz[rt];
            tr[rs(rt)] += layz[rt], layz[rs(rt)] += layz[rt];
            layz[rt] = 0;
        }
    }
    inline void build(int rt, int l, int r) {
        layz[rt] = 0;
        if (l == r) {
            tr[rt] = INF;
            return;
        }
        int mid = (l + r) >> 1;
        build(ls(rt), l, mid);
        build(rs(rt), mid + 1, r);
        pushup(rt);
    }
    inline void add(int rt, int l, int r, int qx, int qy, ll w) {
        if (qx <= l && r <= qy) {
            tr[rt] += w, layz[rt] += w;
            return;
        }
        int mid = (l + r) >> 1;
        pushdown(rt);
        if (qx <= mid) add(ls(rt), l, mid, qx, qy, w);
        if (qy > mid) add(rs(rt), mid + 1, r, qx, qy, w);
        pushup(rt);
    }
    inline void change(int rt, int l, int r, int way, ll w) {
        if (l == r) {
            tr[rt] = min(tr[rt], w);
            return;
        }
        int mid = (l + r) >> 1;
        pushdown(rt);
        if (way <= mid) change(ls(rt), l, mid, way, w);
        else change(rs(rt), mid + 1, r, way, w);
        pushup(rt);
    }
    inline ll query(int rt, int l, int r, int qx, int qy) {
        if (qx <= l && r <= qy) return tr[rt];
        int mid = (l + r) >> 1;
        ll res = INF;
        if (qx <= mid) res = query(ls(rt), l, mid, qx, qy);
        if (qy > mid) res = min(res, query(rs(rt), mid + 1, r, qx, qy));
        return res;
    }
} Tr;
inline void solve1() {
    int cnt = 0;
    for (int i = 1; i <= n + m - 1; i += 2) cnt++, sum[cnt] = sum[cnt - 1] + a[i];
    if (!cnt) return;
    ll res = sum[cnt];
    int st = 2 - (m & 1), mid = (m - 1) / 2 + 1;
    for (int i = st; i <= n + m - 1; i += 2) {
        int id = (i - st) / 2 + 1;
        if (i <= m) pos[(m - 1) / 2 - id + 2].push_back(make_pair((m - 1) / 2 - id + 1, i));
        else pos[id - mid + 1].push_back(make_pair(id - mid, i));
        if (i < n) del[(i + m) / 2].push_back(make_pair(abs((m - i) / 2), i));
        else del[n + (m - i) / 2].push_back(make_pair(abs((m - i) / 2), i));
    }
    Tr.build(1, 0, cnt);
    Tr.change(1, 0, cnt, 0, 0);
    for (int i = 1; i <= cnt; i++) {
        for (auto now : pos[i]) Tr.add(1, 0, cnt, 0, now.fi, b[now.se]);
        dp[i] = sum[i - 1] + Tr.query(1, 0, cnt, 0, i - 1);
        res = min(res, sum[cnt] - sum[i] + dp[i]);
        Tr.change(1, 0, cnt, i, dp[i] - sum[i]);
        for (auto now : del[i]) Tr.add(1, 0, cnt, 0, now.fi, -b[now.se]);
    }
    ans += res;
}
inline void solve2() {
    int cnt = 0;
    memset(sum, 0, sizeof(sum));
    memset(dp, 0, sizeof(dp));
    memset(Tr.tr, 0x3f, sizeof(Tr.tr));
    memset(Tr.layz, 0, sizeof(Tr.layz));
    for (int i = 2; i <= n + m - 1; i += 2) cnt++, sum[cnt] = sum[cnt - 1] + a[i];
    if (!cnt) return;
    for (int i = 1; i <= n + m + 1; i++) pos[i].clear(), del[i].clear();
    ll res = sum[cnt];
    int st = 1 + (m & 1), mid = m / 2;
    for (int i = st; i <= n + m - 1; i += 2) {
        int id = (i - st) / 2 + 1;
        if (i < m) pos[mid - id + 1].push_back(make_pair(mid - id, i));
        else pos[id - mid].push_back(make_pair(id - mid - 1, i));
        if (i < n) del[(i + m + 1) / 2 - 1].push_back(make_pair((abs(m - i) - 1) / 2, i));
        else del[n + (m - i + 1) / 2 - 1].push_back(make_pair((abs(m - i) - 1) / 2, i));
    }
    Tr.build(1, 0, cnt);
    Tr.change(1, 0, cnt, 0, 0);
    for (int i = 1; i <= cnt; i++) {
        for (auto now : pos[i]) Tr.add(1, 0, cnt, 0, now.fi, b[now.se]);
        dp[i] = sum[i - 1] + Tr.query(1, 0, cnt, 0, i - 1);
        res = min(res, sum[cnt] - sum[i] + dp[i]);
        Tr.change(1, 0, cnt, i, dp[i] - sum[i]);
        for (auto now : del[i]) Tr.add(1, 0, cnt, 0, now.fi, -b[now.se]);
    }
    ans += res;
}
inline int read() {
    int x = 0, f = 1; char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
    return x * f;
}
int main() {
    n = read(), m = read();
    for (int i = 1; i <= n + m - 1; i++) a[i] = read();
    for (int i = 1; i <= n + m - 1; i++) b[i] = read();
    solve1();
    solve2();
    printf("%lld\n", ans);
    return 0;
}

```

---


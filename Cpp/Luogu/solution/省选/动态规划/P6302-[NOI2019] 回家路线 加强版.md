# [NOI2019] 回家路线 加强版

## 题目背景

本题是 NOI 2019 回家路线的加强版，除数据范围外均与原题相同。

## 题目描述

猫国的铁路系统中有 $n$ 个站点，从 $1 - n$ 编号。小猫准备从 $1$ 号站点出发，乘坐列车回到猫窝所在的 $n$ 号站点。它查询了能够乘坐的列车，这些列车共 $m$ 班，从 $1 - m$ 编号。小猫将在 $0$ 时刻到达 $1$ 号站点。对于 $i$ 号列车，它将在时刻 $p_i$ 从站点 $x_i$ 出发，在时刻 $q_i$ 直达站点 $y_i$，小猫只能在时刻 $p_i$ 上 $i$ 号列车，也只能在时刻 $q_i$ 下 $i$ 号列车。小猫可以通过多次换乘到达 $n$ 号站点。一次换乘是指对于两班列车，假设分别为 $u$ 号与 $v$ 号列车，若 $y_u = x_v$ 并且 $q_u \leq p_v$，那么小猫可以乘坐完 $u$ 号列车后在 $y_u$ 号站点等待 $p_v - q_u$ 个时刻，并在时刻 $p_v$ 乘坐 $v$ 号列车。

小猫只想回到猫窝并且减少途中的麻烦，对此它用烦躁值来衡量。

 - 小猫在站点等待时将增加烦躁值，对于一次 $t (t \geq 0)$ 个时刻的等待，烦躁值将增加 $At^2 + Bt + C$，其中 $A, B,C$ 是给定的常数。注意：小猫登上第一班列车前，即从 $0$ 时刻起停留在 $1$ 号站点的那些时刻也算作一次等待。

 - 若小猫最终在时刻 $z$ 到达 $n$ 号站点，则烦躁值将再增加 $z$。

形式化地说，若小猫共乘坐了 $k$ 班列车，依次乘坐的列车编号可用序列 $s_1, s_2, \cdots , s_k$ 表示。该方案被称作一条可行的回家路线，当且仅当它满足下列两个条件：

 - $x_{s1} = 1,y_{sk} = n$

 - 对于所有 $j (1 \leq j < k)$，满足 $y_{sj} = x_{s_{j+1}}$ 且 $q_{sj}\leq p_{s_{j+1}}$ 

对于该回家路线，小猫得到的烦躁值将为：

$$q_{s_k}+(A\times p_{s_1}^2+B\times p_{s_1}+C)+\sum_{j=1}^{k-1}(A(p_{s_{j+1}}-q_{s_j})^2+B(p_{s_{j+1}}-q_{s_j})+C)$$

小猫想让自己的烦躁值尽量小，请你帮它求出所有可行的回家路线中，能得到的最 小的烦躁值。题目保证至少存在一条可行的回家路线。

## 说明/提示

对于所有的测试点，保证 $2\le n\le 10^5$，$1\le m\le  10^6$，$0\le 
A\le 10$，$0\le B,C\le 10^7$，$1\le x_i,y_i\le n$，$x_i\neq y_i$，$0\le p_i<q_i\le 4\times 10^4$。

## 样例 #1

### 输入

```
3 4 1 5 10
1 2 3 4
1 2 5 7
1 2 6 8
2 3 9 10```

### 输出

```
94```

## 样例 #2

### 输入

```
4 3 1 2 3
1 2 2 3
2 3 5 7
3 4 7 9```

### 输出

```
34```

# 题解

## 作者：Mentos_Cola (赞：25)

## 题意

给定 $ n $ 个点，从 $ 1 $ 走到 $ n $ ；其中有 $ m $ 条路径，第 $ i $ 条路径从 $ x_i $ 到 $ y_i $ ，时间从 $ p_i $ 到 $ q_i $ ，每次等车 $ t $ 的时间会增加 $ A*t^2+B*t+C $ 的花费，最后花费加上一个到达时间。使花费最小。

## Solution

一开始我想以当前所在地点为状态来 $ DP $，但是这样就需要再记一维时间，复杂度爆表。于是我们把这些路径作为状态进行转移，就能够同时记下地点和时间了。

那么设 $ dp[i] $ 为走 $ i $ 路径前的总花费，套路地进行 $ DP $ 转移方程的斜率优化：

$ dp[i]=dp[j]+A\times(p_i-q_j)^2+B\times(p_i-q_j)+C $

$ dp[i]=dp[j]+Ap_i^2+Aq_j^2-2Ap_iq_j+Bp_i-Bq_j+C $ 

$ dp[j]+Aq_j^2-Bq_j=2Ap_iq_j+dp[i]-Ap_i^2-Bp_i-C $

至此我们以

$ y=dp[j]+Aq_j^2-Bq_j,k=2Ap_i,x=q_j,b=dp[i]-Ap_i^2-Bp_i^2-C $ 

把 $ m $ 条路径按照 $ p $ 从小到大处理，$ k $单调不减，即可进行斜率优化 $ DP $ 

但是我们还有两个限制，一个是 $ y_j=x_i $ ，另一个是 $ q_j\le p_i $

第一个好办，我们开 $ n $ 个 单调队列，$ i $ 进队时就丢进第 $ y_i $ 个单调队列里，求 $ dp[i] $ 时就从第 $ x_i $ 个单调队列里调就完了。

第二个则需要我们算出 $ dp[i] $ 后不将它马上插到对应的单调队列里，而是按照 $ q $ 把它丢到桶里。对每个 $ d $ 算所有 $ p_i=d $ 的 $ dp[i] $ 之前，就把所有 $ q_j=d $ 的 $ j $ 插入对应单调队列。

这样为什么可行呢？在算 $ dp[i] $ 时，桶里所有 $ q_j\le p_i $ 都会进入单调队列中。而所有 $ q_j\le p_i $ 的 $ j $ 必然 $ p_j<p_i $ ，它们一定在之前就会进入桶中。这样，我们就证明了我们不会漏掉任何可能的转移。

我看到上面的题解大多都使用了堆，带上了一个 $ log $ 的时间复杂度。但实际上此题数据范围不大，用桶排更简洁，也更快。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define double long double
using namespace std;
const int M=1e6+10,inf=1e18,eps=1e-9;
int st[M],nd[M],p[M],q[M],x[M],y[M],h[M],t[M],dp[M];
vector<int>pos[M],ins[M],Q[M];
void read(int &x){
	int f=1;x=0;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	x*=f;
}
int pf(int x){return x*x;}
double slope(int i,int j){
	int xx=x[j]-x[i],yy=y[j]-y[i];
	if(!xx){
		if(yy>0)return inf;
		return -inf;
	}
	return yy*1./xx;
}
signed main(){
	int n,m,A,B,C,T=0,ans=inf;
	read(n),read(m),read(A),read(B),read(C);
	for(int i=1;i<=m;i++){
		read(st[i]),read(nd[i]),read(p[i]),read(q[i]);
		T=max(T,q[i]),pos[p[i]].push_back(i);
	}
	for(int i=1;i<=n;i++)h[i]=0,t[i]=-1;
	for(int pi=0;pi<=T;pi++){
		for(int id=0;id<ins[pi].size();id++){
			int i=ins[pi][id],pp=nd[i];
			while(h[pp]<t[pp]&&slope(Q[pp][t[pp]-1],Q[pp][t[pp]])>=slope(Q[pp][t[pp]-1],i))t[pp]--;
			++t[pp];
			if(t[pp]>=Q[pp].size())Q[pp].push_back(i);
			else Q[pp][t[pp]]=i;
		}
		for(int id=0;id<pos[pi].size();id++){
			int i=pos[pi][id],pp=st[i];double k=2.*A*pi;
			while(h[pp]<t[pp]&&slope(Q[pp][h[pp]],Q[pp][h[pp]+1])<k)h[pp]++;
			if(h[pp]>t[pp]&&st[i]!=1)continue;
			int j;
			if(st[i]==1&&h[pp]>t[pp])j=0;
			else j=Q[pp][h[pp]];
			dp[i]=dp[j]+A*pf(p[i]-q[j])+B*(p[i]-q[j])+C;
			x[i]=q[i],y[i]=dp[i]+A*pf(q[i])-B*q[i];
			ins[q[i]].push_back(i);
			if(nd[i]==n)ans=min(ans,dp[i]+q[i]);
		}
	}
	cout<<ans<<endl;
	return 0;
}

---

## 作者：EricQian (赞：8)

[P5468 [NOI2019] 回家路线](https://www.luogu.com.cn/problem/P5468)

[P6302 [NOI2019] 回家路线 加强版](https://www.luogu.com.cn/problem/P6302)

[更好的阅读体验](https://www.cnblogs.com/EricQian/p/15132345.html)

### 题意

给定 $n$ 个点，从 $1$ 走到 $n$。其中有 $m$ 条固定时间的路径，第 $i$ 条路径从 $u_i$ 到 $v_i$，在 $st_i$ 时刻出发，在 $ed_i$ 时刻到达。每次等车 $t$ 的时间会增加 $A\times t^2+B\times t+C$ 的花费，最后花费加上一个到达时间。使花费最小。

$n\le 10^5;m\le 10^6;p_i,q_i\le 10^3$

### 题解

首先可以想到一个 $O(Tm)$ 的暴力 dp：设 $dp_{i,s}$ 表示在第 $s$ 秒到达第 $i$ 个点的最小代价，可以枚举每一条边转移。

[$\texttt{code}$](https://www.luogu.com.cn/paste/69zbjp28)

发现如果同时记录地点与时间单说空间复杂度就爆炸，考虑更改状态。

一个高妙的想法是：以一条条航班的编号为状态，$dp_i$ 表示在经过第 $i$ 条航线并到达 $ed_i$ 时的最小代价，这样用一维变量同时概括了地点与时间两个信息。

可以列出转移方程：

$$dp_i=\min_{v_j=u_i}\{dp_j+A\times (st_i-ed_j)^2+B\times (st_i-ed_j)+C+(ed_i-st_i)+(st_i-ed_j)\}(ed_j\le st_i)$$

发现这是一个关于 $i$ 与 $j$ 的转移方程，可以斜率优化（去掉 $\min$ 后移项）：

$$[dp_j+A\times (ed_j)^2-B\times ed_j-ed_j]=[2A\times st_i]\times [ed_j]+[dp_i−A\times(st_i)^2-B\times st_i-C-ed_i]$$

$$[y]=[k]\times [x]+[b]$$

关于按照 $st_i$ 升序排序（让 $[k]$ 递增）还是按照 $ed_i$ 排序（让 $[x]$ 递增），我自己在第一次做的时候没有想清楚，导致了长时间的卡顿，下面解释一下 $ed_i$ 排序的错误之处：

在按照 $ed_i$ 排序之后，我为了满足 $ed_j\le st_i$ 的限制，在单调队列上二分出了 $ed_j\le st_i$ 的最右端（记为 $pos$），并在 $[L,pos]$ 中再一次二分求出最佳决策点。

但最关键的是，单调队列中的所有决策点都是经过筛选的。假设存在决策点 $j(ed_j\le st_i)$，对于 $st_i$ 来说是更优，却在加入另一个决策点时被舍去了。

![](https://cdn.luogu.com.cn/upload/image_hosting/6o7yfsi4.png)

比如上面的图，会选择 $p$ 作为决策，$j$ 会被舍去。

还有一个注意点就是：在加入决策的时候，不能每次直接将 $i$ 加入队列中，而是可以将它加入一个堆中。每次需要计算时再将堆中的决策点放到单调队列中。

总时间复杂度：$O(m\log m)$。

### 代码

```cpp
// Author:A weak man named EricQian
#include<bits/stdc++.h>
using namespace std;
#define infll 0x3f3f3f3f3f3f3f3f
#define inf 0x3f3f3f3f
#define Maxm 1000005
#define pa pair<int,int>
#define fi first
#define se second
typedef long long ll;
inline int rd()
{
	 int x=0;
	 char ch,t=0;
	 while(!isdigit(ch = getchar())) t|=ch=='-';
	 while(isdigit(ch)) x=x*10+(ch^48),ch=getchar();
	 return x=t?-x:x;
}
inline ll maxll(ll x,ll y){ return x>y?x:y; }
inline ll minll(ll x,ll y){ return x<y?x:y; }
inline ll absll(ll x){ return x>0ll?x:-x; }
inline ll gcd(ll x,ll y){ return (y==0)?x:gcd(y,x%y); }
int n,m;
ll ans=infll,A,B,C,dp[Maxm],x[Maxm],y[Maxm],k[Maxm];
struct Way { int u,v; ll st,ed; }r[Maxm];
bool cmp(Way x,Way y){ return x.st<y.st; }
inline ll calc(int x) { return x*x*A+x*B+C; }
struct Destination
{
	 int nl=0; // 由于 vector 不支持 pop_front 操作，我用一个指针来表示起始位置
	 vector<int> q;
	 priority_queue<pa> qpre;
	 inline void Insert(int i,ll X,ll Y)
	 {
	 	 int nr;
	 	 while((nr=q.size())-nl>=2 && (Y-y[q[nr-1]])*(x[q[nr-1]]-x[q[nr-2]])
		  	   <=(y[q[nr-1]]-y[q[nr-2]])*(X-x[q[nr-1]])) q.pop_back(); // 队尾踢出凹凸性错误的元素
	 	 q.push_back(i);
	 }
	 inline void Delete(int S,ll K)
	 {
	 	 int tmp;
	 	 while(!qpre.empty() && -qpre.top().fi<=S) // 将堆中元素加入单调队列中
		  	 tmp=(int)qpre.top().se,Insert(tmp,x[tmp],y[tmp]),qpre.pop();
		 while(q.size()-nl>=2 && (y[q[nl+1]]-y[q[nl]])<=
		 	 K*(x[q[nl+1]]-x[q[nl]])) nl++; // 队首踢出决策较劣的元素
	 }
}pos[Maxm];
int main()
{
	 n=rd(),m=rd(),A=rd(),B=rd(),C=rd();
	 for(int i=1;i<=m;i++) r[i]=(Way){rd(),rd(),rd(),rd()};
	 sort(r+1,r+m+1,cmp),pos[1].q.push_back(0);
	 memset(dp,0x3f,sizeof(dp)),dp[0]=0;
	 for(int i=1,U,V,tmp;i<=m;i++)
	 {
	 	 x[i]=r[i].ed,k[i]=2ll*A*r[i].st,U=r[i].u,V=r[i].v;
		 pos[U].Delete(r[i].st,k[i]);
		 if((int)pos[U].q.size()<=pos[U].nl) continue; // 没有决策点
		 tmp=pos[U].q[pos[U].nl];
		 dp[i]=dp[tmp]+calc(r[i].st-r[tmp].ed)+r[i].ed-r[tmp].ed;
	 	 y[i]=dp[i]+A*r[i].ed*r[i].ed-B*r[i].ed-r[i].ed;
	 	 pos[V].qpre.push(pa(-r[i].ed,i));
	 }
	 for(int i=1;i<=m;i++) if(r[i].v==n) ans=minll(ans,dp[i]);
	 printf("%lld\n",ans);
	 return 0;
}
```

---

## 作者：Star_Cried (赞：7)

## P5468 [NOI2019] 回家路线

斜率优化入门（指我写的东西而不是这道题）

### 题意

$n$ 个节点，有 $m$ 趟列车，车 $i$ 从 $p_i$ 时刻至 $q_i$ 时刻从 $x_i$ 地到 $y_i$ 地。猫猫需要只坐列车从 $1$ 节点到达 $n$ 节点。

设猫猫在一个地方等待的时间为 $t$，那么代价为 $At^2+Bt+C$，其中 $A\ B\ C$ 为给定非负常数，总代价为所有代价总和与到达时间的和。求最小代价。

### 思路

设 $f_i$ 为走 $i$ 趟列车前的最小代价，有转移方程：
$$
f_i=\min_{y_j=x_i\land q_j\leq q_i}(f_j+A(p_i-q_j)^2+B(p_i-q_j)+C)
$$
最终代价即为：
$$
\min f_i+q_i
$$
对于第一个方程，不考虑其他限制，即为找到最优的 $j$ 更新 $i$，有：
$$
\begin{aligned}
f_i&=f_j+A(p_i-q_j)^2+B(p_i-q_j)+C\\
f_i&=f_j+Ap_i^2+Aq_j^2-2Ap_iq_j+Bp_i-Bq_j+C\\
f_j+Aq_j^2-Bq_j&=2Ap_iq_j+f_i-Ap_i^2-Bp_i-C
\end{aligned}
$$
对于已经更新过的 $j$，$f_j+Aq_j^2-Bq_j$ 是已知的。后半部分 $f_i-Ap_i^2-Bp_i-C$ 只有 $f_i$ 是未知的，也是我们要最优化的。

那么我们可以将上式看做 $y=kx+b$ 的形式，其中
$$
\begin{aligned}
&y=f_j+Aq_j^2-Bq_j\\
 &x=q_j\\
 &k=2Ap_i\\
 &b=f_i-Ap_i^2-Bp_i-C
 \end{aligned}
$$
（常数其实可以属于任意一个位置，上述只是举例）

那么我们可以将所有可以转移到的 $j$ 看做一个二维平面上的点，每次更新 $f_i$ 实际是对一个斜率找出经过其中一个点得到的最优的 $b$。那么显然只会选到前者构成的凸包上的点。很多题查询的斜率都是单调的，而且之后在凸包后方插入新的点，于是维护凸包的数组就变成了单调队列。否则的话，就是动态维护凸包并在凸包上二分。

对于这道题，最优指最小，那么我们维护的是下凸包。

斜率优化的部分已经完了。考虑加入 $y_j=x_i \land q_j\leq p_i$ 的限制怎么做。对于第一个限制，发现不同点互不影响，那么我们对每个点开一个单调队列，对于一个列车在它的 $x$ 位置查询就好了。对于第二个限制，我们将所有列车按照 $p$ 排序然后枚举时间，那么对于上面更新完的列车先不插入队列，当枚举时间到 $p$ 的时候再将其插入即可。这样就能满足所有限制，并且保证查询的斜率单调递增。

### 代码

好像不会炸 `long long` 的样子。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int w=0,x=0;char c=getchar();
	while(!isdigit(c))w|=c=='-',c=getchar();
	while(isdigit(c))x=x*10+(c^48),c=getchar();
	return w?-x:x;
}
namespace star
{
	const int maxn=1e6+10;
	int n,T,m,A,B,C,st[maxn],ed[maxn],p[maxn],q[maxn],hd[maxn],tl[maxn];
	long long f[maxn],x[maxn],y[maxn],ans=0x3f3f3f3f3f3f3f3f;
	vector<int> V[maxn],G[maxn],que[maxn];
	inline void work(){
		n=read(),m=read(),A=read(),B=read(),C=read();
		for(int i=1;i<=m;i++) st[i]=read(),ed[i]=read(),p[i]=read(),q[i]=read(),T=max(T,q[i]),G[p[i]].push_back(i);
		for(int i=1;i<=n;i++) hd[i]=0,tl[i]=-1;
		for(int t=0;t<=T;t++){
			for(auto i:V[t]){
				int e=ed[i];
				while(hd[e]<tl[e] and 1ll*(y[que[e][tl[e]]]-y[que[e][tl[e]-1]])*(x[i]-x[que[e][tl[e]]])>=1ll*(y[i]-y[que[e][tl[e]]])*(x[que[e][tl[e]]]-x[que[e][tl[e]-1]])) --tl[e];
				if(++tl[e]==que[e].size()) que[e].push_back(i);
					else que[e][tl[e]]=i;
			}
			for(auto i:G[t]){
				int e=st[i];
				while(hd[e]<tl[e] and (y[que[e][hd[e]+1]]-y[que[e][hd[e]]])<2ll*A*p[i]*(x[que[e][hd[e]+1]]-x[que[e][hd[e]]])) ++hd[e];
				if(hd[e]>tl[e] and st[i]!=1) continue;
				int j=st[i]==1 and hd[e]>tl[e]?0:que[e][hd[e]];
				f[i]=f[j]+1ll*A*(p[i]-q[j])*(p[i]-q[j])+1ll*B*(p[i]-q[j])+C;
				x[i]=q[i],y[i]=f[i]+1ll*A*q[i]*q[i]-1ll*B*q[i];
				V[q[i]].push_back(i);
				if(ed[i]==n) ans=min(ans,f[i]+q[i]);
			}
		}
		printf("%lld\n",ans);
	}
}
signed main(){
	star::work();
	return 0;
}
```



---

## 作者：xtx1092515503 (赞：4)

[传送门](https://www.luogu.com.cn/problem/P6302)

这里介绍一种**较易理解**（至少我自己是这么认为的），并且一点都**不卡常**的方法（虽然本质是差不多一样的）。

~~（才不会告诉你我是因为看不懂现行的大部分题解然后不得不自己yy一种做法出来的呢）~~


------------

我们设$f[i]$表示当你最后一辆乘坐的是$i$号车时，最小的烦躁值。

则有

$$f[i]=\min\limits_{y_j=x_i,q_j\leq p_i}\{f[j]+A(p_i-q_j)^2+B(p_i-q_j)+C\}$$

这点应该非常易于理解。


------------

然后就是大多数题解我都没有看懂的部分了，即转移顺序。显然，这道题的转移顺序只有可能是**时间**。题解都采用了**循环**的写法，这意味着$x_i$与$y_i$，$p_i$与$q_i$，这些原本好端端在一起的东西都会被拆开，但正是这一点让我这种蒟蒻非常迷惑。因此，我决定采取**递归**的写法，即**记忆化搜索**。

具体而言：

我们对于每个**车站**$i$，建立两个```vector```，一个名叫$in_i$，储存了所有$q_j=i$的$j$，即终点为$i$的车辆编号；另一个名叫$out_i$，储存所有$p_j=i$的$j$，即起点为$i$的车辆编号。同一个```vector```内的元素按照时间顺序排序。

然后，我们建立记忆化函数```dfs(x)```，表示求出$f[x]$的过程。

在这个函数中，我们只需要枚举$in_{x_x}$中的所有的$i$使得$q_i\leq p_x$，从$dfs(i)+A(p_x-q_i)^2+B(p_x-q_i)+C$处转移即可。显然，这个递归的过程本身就是按照时间顺序进行的。

适当的边界条件珂以减少特判。例如在$in_1$中压入一个$0$表示初始状态就是一个好办法。


------------

该方法复杂度上界$O(m^2)$，因为原题数据水，可以通过（但是加强版过不去）。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int n,m,A,B,C;
ll f[1001000],ans=0x3f3f3f3f3f3f3f3f;
vector<pair<int,int> >in[100100],out[100100];
struct node{
	int x,y,u,v;
}r[1001000];
ll dfs(int x){
	if(f[x]!=-1)return f[x];
	ll &res=f[x];res=0x3f3f3f3f3f3f3f3f;
	for(auto i:in[r[x].x]){
		int tmp=out[r[x].x][r[x].u].first-i.first;
		if(tmp<0)break;
//		printf("%d->%d:%d\n",i.second,x,dfs(i.second)+A*tmp*tmp+B*tmp+C);
		res=min(res,dfs(i.second)+A*tmp*tmp+B*tmp+C);
	}
	return res;
}
int main(){
	scanf("%d%d%d%d%d",&n,&m,&A,&B,&C),memset(f,-1,sizeof(f)),f[0]=0;
	for(int i=1,u,v;i<=m;i++)scanf("%d%d%d%d",&r[i].x,&r[i].y,&u,&v),in[r[i].y].push_back(make_pair(v,i)),out[r[i].x].push_back(make_pair(u,i));
	in[1].push_back(make_pair(0,0));
	for(int i=1;i<=n;i++){
		sort(in[i].begin(),in[i].end()),sort(out[i].begin(),out[i].end());
		for(int j=0;j<in[i].size();j++)r[in[i][j].second].v=j;
		for(int j=0;j<out[i].size();j++)r[out[i][j].second].u=j;
	}
	for(auto x:in[n])ans=min(ans,dfs(x.second)+x.first);
	printf("%lld\n",ans);
	return 0;
} 
```


------------

然后就要考虑优化才能通过加强版了。看到$Ax^2+Bx+C$这种式子，我们想到了[[APIO2010]特别行动队](https://www.luogu.com.cn/problem/P3628)，经典**斜率优化**题。

我们重新列出转移式（根据前面的新定义加以少许修改）：

$$\large f[i]=\min\limits_{j\in in_{x_i},q_j\leq p_i}\{dfs(j)+A(p_i-q_j)^2+B(p_i-q_j)+C\}$$

假设有$j,k\in in_{x_i}$且$q_j\leq q_k\leq p_i$。考虑什么情况下$k$一定会被踢出：

则有

$$dfs(j)+A(p_i-q_j)^2+B(p_i-q_j)+C\leq dfs(k)+A(p_i-q_k)^2+B(p_i-q_k)+C$$

拆括号

$$dfs(j)+Ap_i^2-2Ap_iq_j+Aq_j^2+Bp_i-Bq_j+C\leq dfs(k)+Ap_i^2-2Ap_iq_k+Aq_k^2+Bp_i-Bq_k+C$$

约掉

$$dfs(j)-2Ap_iq_j+Aq_j^2-Bq_j\leq dfs(k)-2Ap_iq_k+Aq_k^2-Bq_k$$

同类项整合

$$\Big(dfs(j)-dfs(k)\Big)+A(q_j^2-q_k^2)-B(q_j-q_k)\leq 2Ap_i(q_j-q_k)$$

除过去

$$\dfrac{\Big(dfs(j)-dfs(k)\Big)+A(q_j^2-q_k^2)-B(q_j-q_k)}{q_j-q_k}\geq2Ap_i$$

这就是我们斜率优化的式子。因为排过序，保证$p_i$递增，因此珂以采取**单调队列**进行斜率优化。


------------

但是这题的实现与常规斜率优化有所差别。因为转移是对于每个车站$i$，从$in_i$中全体数转移到$out_i$中全体数的；也就是说，对于每个$i$，我们都应该**单独**开一个单调队列。

还没完。因为这题的计算顺序是**时间顺序**，因此我们不能简单地对于每个车站从头到尾跑一遍单调队列求出所有的$f_{out_i}$。准确地说，这个$f$应该是**分段**求出的。


------------

设$lima_i$表示位置$i$的$in_i$中入队到了第几个，$limb_i$表示位置$i$的$out_i$中求到了第几个的$f_x$。则我们在询问$dfs(x)$时：

设$pos={x_x}$，且$x$是$out_{pos}$中的第$tar$个。如果$f_x$已经被求出，则应有$limb_{pos}>tar$，此时珂以直接返回$f_x$。否则，我们一次性求出$\Big[limb_{pos},tar\Big]$区间里所有数的$f_x$。


------------

具体而言：

不停让$limb_{pos}$自加$1$。设$i$为当前$limb_{pos}$所对应的$out_{pos}$中的那个数，则每自加一次，就入队$in_{pos}$中所有使得$q_j\leq p_i$的$j$，同时维护单调队列。当全部入队完成后，再从队首关于$i$出队即可。

这种写法与常规斜率优化的最大差别在于，常规的斜率优化是转移的起点终点都**在同一个数组**里面，而这里起点终点**一个在$in$里面，一个在$out$里面**。因此我采取的是先一起入队，再出队的写法。


------------

放一下```dfs(x)```的代码：

```cpp
ll dfs(int x){
	if(f[x]!=-1)return f[x];
	int pos=r[x].x,tar=r[x].u;
	while(limb[pos]<=tar){
		while(lima[pos]<in[pos].size()&&in[pos][lima[pos]].first<=out[pos][limb[pos]].first){
			int i=in[pos][lima[pos]].second,si=in[pos][lima[pos]].first;
			if(dfs(i)!=0x3f3f3f3f3f3f3f3f){
				while(q[pos].size()>=2){
					int J=q[pos][q[pos].size()-2],K=q[pos][q[pos].size()-1];
					int j=in[pos][J].second,sj=in[pos][J].first;
					int k=in[pos][K].second,sk=in[pos][K].first;
					if(1ll*((dfs(j)-dfs(k))+1ll*A*(1ll*sj*sj-1ll*sk*sk)-1ll*B*(sj-sk))*(sk-si)<1ll*((dfs(k)-dfs(i))+1ll*A*(1ll*sk*sk-1ll*si*si)-1ll*B*(sk-si))*(sj-sk))break;
					q[pos].pop_back();
				}
				q[pos].push_back(lima[pos]);				
			}
			lima[pos]++;
		}
		int i=out[pos][limb[pos]].second,si=out[pos][limb[pos]].first;
		while(q[pos].size()>=2){
			int J=q[pos][0],K=q[pos][1];
			int j=in[pos][J].second,sj=in[pos][J].first;
			int k=in[pos][K].second,sk=in[pos][K].first;
			if((dfs(j)-dfs(k))+1ll*A*(1ll*sj*sj-1ll*sk*sk)-1ll*B*(sj-sk)<2ll*A*si*(sj-sk))break;
			q[pos].pop_front();
		}
		if(!q[pos].empty()){
			int J=q[pos].front();
			int j=in[pos][J].second,tmp=si-in[pos][J].first;
			f[i]=dfs(j)+1ll*A*tmp*tmp+1ll*B*tmp+C;
		}else f[i]=0x3f3f3f3f3f3f3f3f;
		limb[pos]++;
	}
	return f[x];
}
```
这份代码可能有点难以理解，我马上拆开来讲一下。

首先，$in$和$out$里面装的都是```pair<int,int>```，其中```first```是时间，```second```是标号。单调队列中储存的，是其在$in_{pos}$中的编号；因此才要先设$J$和$K$表示$in$中编号，然后再设$j,k$表示真实的车辆编号，再设$sj,sk$表示$q_j,q_k$。

注意这里里层循环中的$i$与外层循环的$i$不是同一个$i$：里层的$i$是$in_{pos}$中要入队的编号，而外层的$i$是$out_{pos}$中要被计算的编号。


------------

另外有几个小细节：

**如果你发现将要被入队的数的```dfs```值已经为$INF$，即无解时，珂以直接略过这个数。**（因为这点我debug了1h）

**入队或出队时，在单调队列中维护凸壳时，能删就删。**（因为这点我又debug了1h）


------------

最后是复杂度分析。

显然，通过单调队列，dp部分的复杂度被压到了$O(m)$。但是，我们不要忘记$in_x$和$out_x$中的**排序**。如果用常规排序的话，是$O(m\log m)$的。但是此题时间范围$T$较小，只有$4\times10^4$，因此排序时珂以采取**桶排**，复杂度就是$O(m)$的。（尽管我这份程序在没有使用桶排的情况下就过去了，如果你们觉得复杂度不够优秀，珂以换成桶排）


------------


最后的最后，它不卡常！！！O3，```vector```替换```deque```，桶排序，等等奇奇怪怪的trick，一个都没用，加个快读就跑过去了（现在在第二页，如果卡了估计能挤进前3）。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int n,m,A,B,C,lima[100100],limb[100100];
ll f[1001000],ans=0x3f3f3f3f3f3f3f3f;
vector<pair<int,int> >in[100100],out[100100];
deque<int>q[100100];
struct node{
	int x,y,u,v;
}r[1001000];
ll dfs(int x){
	if(f[x]!=-1)return f[x];
	int pos=r[x].x,tar=r[x].u;
	while(limb[pos]<=tar){
		while(lima[pos]<in[pos].size()&&in[pos][lima[pos]].first<=out[pos][limb[pos]].first){
			int i=in[pos][lima[pos]].second,si=in[pos][lima[pos]].first;
			if(dfs(i)!=0x3f3f3f3f3f3f3f3f){
				while(q[pos].size()>=2){
					int J=q[pos][q[pos].size()-2],K=q[pos][q[pos].size()-1];
					int j=in[pos][J].second,sj=in[pos][J].first;
					int k=in[pos][K].second,sk=in[pos][K].first;
					if(1ll*((dfs(j)-dfs(k))+1ll*A*(1ll*sj*sj-1ll*sk*sk)-1ll*B*(sj-sk))*(sk-si)<1ll*((dfs(k)-dfs(i))+1ll*A*(1ll*sk*sk-1ll*si*si)-1ll*B*(sk-si))*(sj-sk))break;
					q[pos].pop_back();
				}
				q[pos].push_back(lima[pos]);				
			}
			lima[pos]++;
		}
		int i=out[pos][limb[pos]].second,si=out[pos][limb[pos]].first;
		while(q[pos].size()>=2){
			int J=q[pos][0],K=q[pos][1];
			int j=in[pos][J].second,sj=in[pos][J].first;
			int k=in[pos][K].second,sk=in[pos][K].first;
			if((dfs(j)-dfs(k))+1ll*A*(1ll*sj*sj-1ll*sk*sk)-1ll*B*(sj-sk)<2ll*A*si*(sj-sk))break;
			q[pos].pop_front();
		}
		if(!q[pos].empty()){
			int J=q[pos].front();
			int j=in[pos][J].second,tmp=si-in[pos][J].first;
			f[i]=dfs(j)+1ll*A*tmp*tmp+1ll*B*tmp+C;
		}else f[i]=0x3f3f3f3f3f3f3f3f;
		limb[pos]++;
	}
	return f[x];
}
void read(int &x){
	x=0;
	char c=getchar();
	while(c>'9'||c<'0')c=getchar();
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
}
int main(){
	read(n),read(m),read(A),read(B),read(C),memset(f,-1,sizeof(f)),f[0]=0;
	for(int i=1,u,v;i<=m;i++)read(r[i].x),read(r[i].y),read(u),read(v),in[r[i].y].push_back(make_pair(v,i)),out[r[i].x].push_back(make_pair(u,i));
	in[1].push_back(make_pair(0,0));
	for(int i=1;i<=n;i++){
		sort(in[i].begin(),in[i].end()),sort(out[i].begin(),out[i].end());
		for(int j=0;j<in[i].size();j++)r[in[i][j].second].v=j;
		for(int j=0;j<out[i].size();j++)r[out[i][j].second].u=j;
	}
	for(auto x:in[n])ans=min(ans,dfs(x.second)+x.first);
//	for(int i=1;i<=n;i++)printf("%d:%lld\n",i,f[i]);
	printf("%lld\n",ans);
	return 0;
} 
```


---

## 作者：GreenDay (赞：4)

[题面(洛谷加强版)](https://www.luogu.com.cn/problem/P6302)

[题面(原版)](https://www.luogu.com.cn/problem/P5468)

## 暴力

考虑$\mathcal{O(m*\max(q))}$的暴力。$dp_{x,t}$表示节点$x$刚刚到达$t$时候的烦躁值（不考虑那个到达时间）。把边按照P或者Q排序。对于每一条边$(x,y,p,q)$：

$$
dp_{y,q}=\min (dp_{y,q},dp_{x,t}+A(p-t)^2+B(p-t)+C),t\le p$$

$$
ans=\min(dp_{n,t}+t)
$$

这样你就可以过原版了。

## 斜率优化

暴力的空间复杂度显然会GG，但是我们发现真实有效的dp值不会超过m个，这就给我们优化的空间。

~~不用说怎么想到斜率优化了吧~~

斜率优化：把**把$pt$项移到等式一侧构成$kx$，把只和t有关的项移到等式另一侧作为$y$，剩下的构成$b$**。

$$
dp_{y,q}=dp_{x,t}+A(p-t)^2+B(p-t)+C
$$

$$
dp_{y,q}+(2Ap)*t=(dp_{x,t}+At^2-Bt)+(Ap^2+Bp+C)
$$

几何意义：表示斜率为$k=2Ap$，过点$(t,dp_{x,t}+At^2-Bt)$的斜率的**最小截距**，加上一个$(Ap^2+Bp+C)$就是$dp_{y,q}$的值。我们维护**下凸包**，若一个点左侧斜率$\le k$，右侧斜率$>k$,这个点就是最优转移点。

斜率是$2Ap$，所以我们把边按照$p$排序，就可以用**单调队列**维护凸包.左侧弹出斜率$\le2Ap$的点，右侧弹出不符合凸包性质的点。

但是我们还有一个限制$t\le p$！！！

这里蒟蒻的处理办法使得程序带上了一个$log$。

我们把每个节点的dp值用小根堆维护，需要查询dp值的时候，就不停的取出这个小根堆的堆顶，直到堆顶的$t>p$或者堆为空，然后把取出节点插入到单调队列里。

$\mathcal{O(m logm)}$

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 100010 , P = 40005;

struct Edge {int x , y , p , q;};
vector<Edge> edge[P];

typedef long long int64;
const long long inf = 1e18;
int64 A , B , C , n , m , ans = inf;

struct Point {
    int64 x , y;
    Point() {}
    Point(int64 t , int64 dp) {
        x = t;
        y = dp + A * t * t - B * t;
    }
    bool operator < (const Point &b) const {
        return x > b.x;
    }
};
double slope(Point a , Point b) {
    if(a.x != b.x) return (double)(b.y - a.y) / (b.x - a.x);
    return a.y < b.y ? 1e18 : -1e18;
}

struct Node {
    deque<Point> dp;
    priority_queue<Point> wait;

    int64 query(int p) {
        while(wait.size() && wait.top().x <= p) {
            Point now = wait.top() ;
            wait.pop();
            while(dp.size() >= 2 && slope(dp[dp.size() - 2] , dp.back()) >= slope(dp.back() , now))
                dp.pop_back();
            dp.push_back(now);
        }
        if(dp.empty()) return inf;
        int64 k = 2 * A * p;
        while(dp.size() >= 2 && slope(dp.front() , dp[1]) <= k)
            dp.pop_front();
        return A * p * p + B * p + C + (dp.front().y - k * dp.front().x);
    }
    void insert(int64 t , int64 dp) {wait.push(Point(t , dp));}
} DP[N];

template<typename _T>
inline void read(_T &x) {
    x = 0 ; char c = getchar(); bool f = 0;
    while(c < '0' || c > '9') f |= (c=='-') , c = getchar();
    while(c >= '0' && c <= '9') x = x * 10 + (c^48) , c = getchar();
    if(f) x = -x;
}
template<typename _T , typename... Args>
inline void read(_T &x , Args&... args) {
    read(x) , read(args...);
}

int main() {
    read(n , m , A , B , C);
    int T = -1e9;
    for(int i = 1 ; i <= m ; ++i) {
        Edge e;
        read(e.x , e.y , e.p , e.q);
        edge[e.p].push_back(e);
        T = max(T , e.p);
    }
    DP[1].insert(0 , 0);
    for(int i = 0 ; i <= T ; ++i)
        for(auto &e : edge[i]) {
            int64 val = DP[e.x].query(e.p);
            if(val >= inf) continue;
            DP[e.y].insert(e.q , val);
            if(e.y == n) ans = min(ans , e.q + val);
        }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：MuelsyseU (赞：3)

显然可以 DP。列出一个显然的方程：

$$f_{i,p} = \min_{(i,j,t,p)\in P, q \in [0, p]}\{f_{j,q} + A(p-q)^2 + B(p-q) + C\}$$

其中 $P$ 为大小为 $m$ 的四元组的集合，描述每个列车。注意到总共的状态数是 $O(m)$ 的，那么只需要优化枚举 $q$ 也就是枚举上次列车的部分。

套路地考虑李超线段树维护，即对每个 $j$ 动态开点一个李超树使得对于每个 $q$ 插入一条直线进 $b = f_{j,q} + Aq^2 - Bq, k = q$，每次查询 $x = -2Ap$ 上 $y = f_{i,p} - Bp - C - Ap^2$ 的最小值。

另外为了保证 $q\le p$，可以对所有列车按照 $p,q$ 分别排序，双指针扫描并每次把不超过当前 $p$ 的 $q$ 对应的直线插入到对应的李超树中。

时间复杂度 $O(m\log m)$，空间复杂度 $O(m)$。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 400005;
typedef long long ll;
const ll inf = 0x3f3f3f3f3f3f3f3f;
int n, m;
struct Path {
	int x, y, p, q;
	ll s;
} p[maxn];
// 求最小值的 wjx 树
namespace LiCT {
	struct Line {
		ll k, b;
	} ln[maxn];
	int cnt, tot, t[maxn * 100], ls[maxn * 100], rs[maxn * 100];
	ll calc(int x, int i) {
		return ln[i].k * x + ln[i].b;
	}
	void update(int &p, int l, int r, int x) {
		if (!p) p = ++tot;
		if (!t[p]) return t[p] = x, void();
		int mid = (l + r) / 2;
		if (calc(mid, x) < calc(mid, t[p])) swap(t[p], x);
		if (calc(l, x) < calc(l, t[p])) update(ls[p], l, mid, x);
		if (calc(r, x) < calc(r, t[p])) update(rs[p], mid + 1, r, x);
	}
	ll query (int p, int l, int r, int x) {
		if (x < l || x > r) exit(44);
		if (!p) return inf;
		ll res = calc(x, t[p]);
		if (l == r) return res;
		int mid = (l + r) / 2;
		if (x <= mid) return min(res, query(ls[p], l, mid, x));
		else return min(res, query(rs[p], mid + 1, r, x));
	}
	inline void insert(int &rt, ll k, ll b) {
		ln[++cnt] = {k, b}, update(rt, -maxn, 0, cnt);
	}
}
int t1[maxn], t2[maxn];
ll f[maxn], g[maxn], A, B, C;
int rt[maxn];
bool cmp1(int x, int y) { return p[x].p < p[y].p; }
bool cmp2(int x, int y) { return p[x].q < p[y].q; }
signed main() {
	scanf("%d%d%d%d%d", &n, &m, &A, &B, &C);
	for (int i = 1; i <= m; ++i) {
		scanf("%d%d%d%d", &p[i].x, &p[i].y, &p[i].p, &p[i].q);
		t1[i] = t2[i] = i;
	}
	sort(t1 + 1, t1 + 1 + m, cmp1), sort(t2 + 1, t2 + 1 + m, cmp2);
	memset(f, 0x3f, sizeof(f));
	memset(g, 0x3f, sizeof(g));
	f[1] = g[1] = 0, LiCT::insert(rt[1], 0, 0);
	// 按 p 排序，双指针一直加小于 p 的 q 到对应集合
	for (int i = 1, j = 0; i <= m; ++i) {
		while (j < m && p[t2[j + 1]].q <= p[t1[i]].p) {
			++j;
			Path k = p[t2[j]];
			LiCT::insert(rt[k.y], k.q, k.s + A * k.q * k.q - B * k.q);
		}
		Path &k = p[t1[i]];
		ll tmp = LiCT::query(rt[k.x], -maxn, 0, -2 * A * k.p) + (B * k.p + C + A * k.p * k.p);
		k.s = tmp, f[k.y] = min(f[k.y], tmp), g[k.y] = min(g[k.y], tmp + k.q);
	}
	printf("%lld", g[n]);
	return 0;
}
```

---

## 作者：BFqwq (赞：3)

### 暴力

首先，看到这个题我们可以很轻松的想到一个暴力。

令 $f_i$ 为如果要经过第 $i$ 条边则在此之前需要的花费最少为多少。

一个显然的方程式是：

$$f_i=\min(f _j+A\times (p_i-q_j)^2+B\times (p_i-q_j)+C)$$

其中 $j$ 是满足 $y_j=x_i$ 且 $q_j\le p_i$ 的边。

（这边的 $x,y,p,q,A,B,C$ 变量含义全部与题目相同）

我们可以通过将一条边分为出和入两步来更新，从而消除时间顺序的问题。

理论复杂度为 $\operatorname{O}(m^2)$ ，实际上卡不满。

### 决策单调性

当我们看到这样的一个转移方程式时，我们一定会想到：这个题与决策单调性有关。

令 $w_{q_j,p_i}$ 为从 $j$ 转移到 $i$ 的费用，即 $A\times (p_i-q_j)^2+B\times (p_i-q_j)+C)$。

我们可以证明，对于边 $i_1,i_2$ 如果有 $x_{i1}=x_{i2}$ 且 $p_{i1}\le p_{i2}$，

设两条边的最优决策点分别为 $j_1,j_2$，则 $q_{j1}\le q_{j2}$。

决策单调性的证明一般使用四边形不等式，但在考场上更多使用打表或是盲猜的方法。

对于不知道四边形不等式的同学，建议阅读[这篇博客]( https://www.cnblogs.com/a1b3c7d9/p/10984353.html )。

当然也可以选择直接记住一个结论：

若某个方程式 $f_i=\min(f_j+w_{i,j})$的转移费用满足 $w_{a,b}+w_{a+1,b+1}\le w_{a+1,b}+w_{a,b+1}$ 时，

该方程的最优决策点（即最佳的 $j$）随 $i$ 非严格单调递增，即满足决策单调性。

那么接下来，我们来证明一下这个题的决策单调性。

$$w_{a,b}+w_{a+1,b+1}\le w_{a+1,b}+w_{a,b+1}$$

$$\Leftrightarrow A\times(a-b)^2+B\times(a-b)+C+A\times(a+1-b-1)^2+B\times(a+1-b-1)+C$$

$$\le A\times (a+1-b)^2+B\times (a+1-b)+C+a\times (a-b-1)^2+B\times (a-b-1)+C$$

$$\Leftrightarrow 2\times A(a-b)^2\le A\times (a+1-b)^2+A\times (a-b-1)^2$$

令 $t=a-b$ 

$$\Leftrightarrow 2\times At^2\le A(t+1)^2+A(t-1)^2$$

$$RHS=2At^2+2A\ge 2At^2=LHS$$ 

证毕。

顾可知，这一方程满足决策单调性，即满足对于边 $i_1,i_2$ 如果有 $x_{i1}=x_{i2}$ 且 $p_{i1}\le p_{i2}$，

设两条边的最优决策点分别为 $j_1,j_2$，则有 $q_{j1}\le q_{j2}$。

### 斜率优化

斜率优化是决策单调性的一个高级应用，一般在 $f$ 方程仅有一个维度时有效。

不会斜率优化的同学这里推荐一下[辰星凌大佬的博客]( https://www.cnblogs.com/Xing-Ling/p/11210179.html )。

我们来考虑对于 $ f_i$ 而言，决策点 $j_1$ 比 $j_2$ （$q_{j_1}\ge q_{j_2}$）更优需要满足什么条件。

将方程式展开后移项，得到

$$f_i-Ap_i^2-Bp_i-C=f_j+Aq_j^2-2Ap_iq_j-Bq_j$$

这样移项的好处是，有关于 $j$ 的项全部被移到了右边。

由于 $i$ 是我们已经确定的，所以 $p_i$ 可以看作常量。

根据方程式可知，若 $j_1$ 比 $j_2$ 更优，则需满足

$$f_{j_1}+Aq_{j_1}^2-2Ap_iq_{j_1}-Bq_{j_1} \le f_{j_2}+Aq_{j_2}^2-2Ap_iq_{j_2}-Bq_{j_2}$$

$$\Leftrightarrow 2Ap_i(q_{j_1}-q_{j_2})\ge (f_{j_1}+Aq_{j_1}^2-Bq_{j_1})-(f_{j_2}+Aq_{j_2}^2-Bq_{j_2})$$

令

$$X(a)=q_a$$

$$Y(a)=f_{a}+Aq_{a}^2-Bq_{a}$$

$$K(a)=2\times A\times p_i$$

$$B(a)=f_i-Ap_i^2-Bp_i-C$$

于是我们就得到了一个斜率优化的形式。

当 $i$ 固定时，我们 $K(i)$ 也就固定了。

而我们的目标就是让  $B(i)$ 越小越好。

因此，只要 $j_1,j_2 $ 满足

$$K(i)\ge \frac{Y(j_1)-Y(j_2)}{X(j_1)-X(j_2)}$$

也就是 $K(i )$ 大于 $(X(j_1),Y(j_1))$ 与 $(X(j_2),Y(j_2))$ 组成的直线，则 $j_1$ 优于 $j_2 $。

这其实非常好理解。当 $K(i)<\frac{Y(j_1)-Y(j_2)}{X(j_1)-X(j_2)}$ 时，设 $B$ 点为 $(X(j_1),Y(j_1))$，$A$ 点为 $(X(j_2),Y(j_2))$，

则我们画出来的图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/xx5epmov.png)

显然此时让直线经过 $A$ 点更优。

而当 $K(i)\ge \frac{Y(j_1)-Y(j_2)}{X(j_1)-X(j_2)}$ 时，图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/nok4ca8p.png)

显然选择 $B$ 点更优。

又由于我们证明了决策单调性，因此从此以后 $A$ 点（也就是 $j_2$） 再无用处。

如果我们用一个双端队列来维护也许有效的决策点，那么这时我们就可以将 $j_2$ 出队。

接着，我们再来考虑什么样的点需要放入队列中。

![](https://cdn.luogu.com.cn/upload/image_hosting/dfhsh30p.png)

对于这样的情况，我们发现，无论所求直线的 $K(i)$ 是多少，$B$ 都不会成为最优决策点，

因此我们就可以将 $B$ 出队。

准确的说，当 $\frac{Y(A)-Y(B)}{X(A)-X(B)}\ge \frac{Y(A)-Y(C)}{X(A)-X(C)}$ 时，$B$ 点就不会成为最优决策点，

因为当 $K(i)<\frac{Y(A)-Y(C)}{X(A)-X(C)}$ 时 $A$ 比 $B$ 更优，否则 $C$ 比 $B$ 更优。

其实如果我们把队列中的所有点画出来，应该是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/fqdq93by.png)

### Code

```cpp
#include <bits/stdc++.h>
#define ll long long
#define X(T) (q[T])
#define Y(T) (f[T]+a*q[T]*q[T]-b*q[T])
#define K(T) (2*a*p[T])
#define B(T) (f[T]-a*p[T]*p[T]-b*p[T]-c)
//一个好习惯，也方便直接调用
using namespace std;
inline int read(){
	register int x=0;
	register bool f=0;
	register char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+c-48;
		c=getchar();
	}
	return f?-x:x;
}
char cr[200];int tt;
inline void print(register ll x,register char k='\n') {
    if(!x) putchar('0');
    if(x < 0) putchar('-'),x=-x;
    while(x) cr[++tt]=x%10+'0',x/=10;
    while(tt) putchar(cr[tt--]);
    putchar(k);
}
const int maxn=200001;
int n,m,a,b,c,mx;
int p[maxn],q[maxn],u[maxn],v[maxn];
ll f[maxn],ans=114514191981000000ll;
int tl,tl2,he,he2,sz;
deque<int> d[maxn];
//stl 自带双端队列，也可以用 vector 实现
deque<int>::iterator it;
vector<int> st[1001];
vector<int> ed[1001];
//st,ed 分别为某一时刻的出发与到达数组
double slope(int qa,int qb){
    return (1.0*(Y(qa)-Y(qb)))/(1.0*(X(qa)-X(qb)));
    //求斜率
}
signed main(){
//	freopen("route.in","r",stdin);
//	freopen("route.out","w",stdout);
	n=read();m=read();a=read();b=read();c=read();
	for(int i=1;i<=m;++i){
		u[i]=read();v[i]=read();p[i]=read();q[i]=read();
		if(u[i]==n) continue;
		mx=max(mx,q[i]);
		st[p[i]].push_back(i);
		f[i]=1233333333ll;
        //初始化
	}
	d[1].push_back(0);
	f[1]=0;
	for(int i=0;i<=mx;i++){
		for(int j:ed[i]){
            //枚举第 i 时刻到达的边
			sz=d[v[j]].size();
			if(sz==0) {
				d[v[j]].push_back(j);
				continue;
			}
			it=d[v[j]].end();
			it--;
			tl=*it;
			while(sz>1){
				it--;tl2=*it;
                //tl 为队尾，tl2 为队尾第二个数
				if(slope(tl,tl2)<slope(j,tl2)){
					break;
                    //tl2 可能更优
				}
                //j 一定更优，弹出 tl2
				tl=tl2;sz--;
				d[v[j]].pop_back();
			}
			d[v[j]].push_back(j);
		}
		for(int j:st[i]){
            //枚举第 i 时刻出发的边
			sz=d[u[j]].size();
			if(sz==0) continue;
            //这条边出发之前无法到达该点，故这条边无效
			it=d[u[j]].begin();he=*it;
			while(sz>1){
				it++;he2=*it;
                //he 为队首，he2 为队首第二个数
				if(slope(he2,he)>K(j)){
					break;
				}
                //比较一下那条边更优，如果 he2 可以取代 he 则出队
                //此时队首就是最优决策点了
				he=he2;sz--;
				d[u[j]].pop_front();
			}
			f[j]=f[he]+a*(p[j]-q[he])*(p[j]-q[he])+b*(p[j]-q[he])+c;
            //更新 f 函数
			if(v[j]==n) ans=min(ans,f[j]+q[j]);
			ed[q[j]].push_back(j);
		}
	}
	print(ans);
	return 0;
}
```



---

## 作者：suxxsfe (赞：3)

在我的博客园查看：https://www.cnblogs.com/suxxsfe/p/13238077.html  

[原题P5468](https://www.luogu.com.cn/problem/P5468)，[洛谷加强版P6302](https://www.luogu.com.cn/problem/P6302)，[LOJ3156](https://loj.ac/problem/3156)  
听说原题是用脚造的数据，所以可能无法把代码的锅都测出来，所以还是去加强版吧  
做了好长时间，主要是原版得分玄学，有的时候把代码一个地方改错甚至得了更多的分（当时同时还存在其它的错）？/jk，然后加强版又被卡常/kk  

斜率优化dp+vector 维护凸包+堆维护还没放入凸包的点  

首先想怎么设计状态，一开始想的是 $f_{i,j}$ 表示时间 $i$，刚达到车站 $j$，的最小烦躁值  
但这样显然会产生很多无用状态，就是可能在某一个时间 $i$，没有到车站 $j$ 的车，那这一个状态就是无用的  
所以改进一下，设 $f_i$ 为坐完编号为 $i$ 的车时，的最小烦躁值，这样可以由车的编号确定到达时间了  
然后对于所有 $y_i=n$ 的车，$\min\{f_i+q_i\}$ 即为答案  

然后考虑怎么转移，$f_i$ 由 $f_j$ 转移而来的条件是，$q_j\le p_i,y_j=x_i$，所以可以吧防尘写成这样：  

$$f_i=\min_{q_j\le p_i,y_j=x_i}\{f_j+A(p_i-q_j)^2+B(p_i-q_j)+C\}$$  

那直接暴力转移就是 $O(n^2)$ 了，能得 $70$，再加上有 $20$ 的特殊限制的部分分，~~那谁还为了最后十分写dp优化啊~~  

~~还是要写的~~，看着有一个平方项，展开的话就有一项是和 $i,j$ 都有关，那就能想到斜率优化了  
其实感觉好多斜率优化的题都是用这么一个平方来创造那个 $kx$，就是和 $i,j$ 都有关的项（比如经典的玩具装箱）  
那就先不考虑限制条件，化简式子：  

$$f_i=f_j+Ap_i^2+Aq_j^2-2Ap_iq_j+Bp_i-Bq_j+C$$
$$f_j+Aq_j^2-Bq_j=2Ap_iq_j+(f_i-Ap_i^2-Bp_i-C)$$

也就是根据斜率优化常见的套路，把等号左边和 $j$ 有关的设为 $Y$，括号里和 $i$ 有关的（包括常数）设为 $b$，且 $K=2Ap_i,X=q_j$  
所以维护一个下凸包，最小化斜率即可  

这时的把限制条件考虑回来  
$y_j=x_i$ 这个，只要对每个点都维护一个凸包，$f_i$ 从第 $x_i$ 个凸包转移，转移结束，就加入到第 $y_i$ 个凸包里  

这个 $q_j\le p_i$ 稍微有点麻烦，因为 $p_j<q_j$，所以 $p_j<p_i$，那我们应该把所有车按 $p$ 升序排序来处理  
但这个 $p_j<p_i$ 只是说，**如果限制条件满足，一定满足他，但满足他不一定满足限制条件**，~~一开始没想清楚被这个坑了~~  
所以此时再维护 $n$ 个小根堆，用 $q$ 排序，然后对于每个 $i$，就把第 $x_i$ 个堆中，所有 $q_j\le p_i$ 的 $j$ 都取出，并放入第 $x_i$ 个 vector 维护成凸包  
直到发现一个点 $q_j>p_i$ 了，那后面的 $j$ 也都不符合要求，插入结束  
如果满足 $q_j\le p_i$ 的 $j$ 被插入凸包了，那由于 $p$ 不减，后面的 $i$ 肯定也满足了这个条件了  
然后 $f_i$ 转移完 $i$ 就也不是直接插入凸包里，而是插入对应的堆中，等他符合了相应条件再插入凸包  

这也不妨是一个更普适的思路，就是**当用一个数据结构维护点东西（比如凸包）来优化dp时，一个状态被转移完，如果还不符合用它转移其它状态的要求，就先用另一个数据结构存起来**  

还会发现这样的话 $K,X$ 都递增了，可以用之间说的 vector 维护  

这样轻松过了原版和LOJ，但发现在加强版T成了40  
于是愉快开始[卡常](https://www.luogu.com.cn/discuss/show/235381)，一开始是用 `set` 当堆来维护，然后换成优先队列，稍微快了点，但还是40  
然后又加了行编译优化，~~依然40~~，好像没啥用  
也许是stl用的太多，不然一秒 $10^6$ 的 $O(m\log m)$ 应该挺好过吧，但因为是动态内存也不好避免stl  
于是现学现卖fread，然后边写周末作业边等到半夜，一交[最大点997ms卡过](https://www.luogu.com.cn/record/34855039)，果然卡常的最好方式是等人少的时候提交  
submit+=20  

欢迎大家来看看我的代码常数为啥这么大/kk  

```cpp  
#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math")
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<queue>
#include<vector>
#include<set>
#include<cstring>
#define reg register
#define EN std::puts("")
#define LL long long
namespace Fread{
	char buffer[32768],*cs,*ct;
	#define get_char (cs==ct&&(ct=(cs=buffer)+fread(buffer,1,32768,stdin),cs==ct)?0:*cs++)
	inline int read(){
		register int x=0;
		register char c=get_char;
		while(c<'0'||c>'9') c=get_char;
		while(c>='0'&&c<='9') x=x*10+(c^48),c=get_char;
		return x;
	}
	#undef getc
}
using namespace Fread;
struct data{
	int x,y;
	LL p,q;
//	int id;
}t[1000006];
int n,m;
LL A,B,C;
LL f[1000005];
LL X[1000001],Y[1000001];
std::vector<int>q[1000001];
struct cmp{
	inline int operator()(const int &aa,const int &bb){
		return t[aa].q==t[bb].q?aa>bb:t[aa].q<t[bb].q;
	}
};
struct _insert{
	int i;
	inline int operator <(const _insert &a)const{return t[i].q>t[a.i].q;}//按 q 的升序
};
std::priority_queue<_insert>insert[1000001];
inline int cmp(data a,data b){return a.p<b.p;}
inline LL min(LL a,LL b){return a>b?b:a;}
//inline LL X(int i){return t[i].q;}
//inline LL Y(int i){return f[i]+A*t[i].q*t[i].q-B*t[i].q;}
inline void Insert(int i){
	reg int size,j,head;//size 为 set insert 的大小，head 为 vector q[x[i]] 最后一个数的下标
	size=insert[t[i].x].size();
	if(!size) return;
	j=insert[t[i].x].top().i;
	while(size&&t[j].q<=t[i].p){
		head=q[t[i].x].size()-1;
		while(head>0){
			if((Y[q[t[i].x][head]]-Y[q[t[i].x][head-1]])*(X[j]-X[q[t[i].x][head]])
			>=(Y[j]-Y[q[t[i].x][head]])*(X[q[t[i].x][head]]-X[q[t[i].x][head-1]])) q[t[i].x].pop_back();
			else break;
			head--;
		}
		q[t[i].x].push_back(j);
		size--;insert[t[i].x].pop();
		j=insert[t[i].x].top().i;
	}
}
inline void pop(int i){
	reg int size=q[t[i].x].size();
	reg LL K=2*A*t[i].p;
	while(size>1&&Y[q[t[i].x][1]]-Y[q[t[i].x][0]]<=K*(X[q[t[i].x][1]]-X[q[t[i].x][0]])){
		size--;
		q[t[i].x].erase(q[t[i].x].begin());
	}
}
int main(){
//		std::freopen("P6302_2.in","r",stdin);
//		std::freopen("tmp.txt","w",stdout);
	n=read();m=read();A=read();B=read();C=read();
	for(reg int i=1;i<=m;i++)
		t[i].x=read(),t[i].y=read(),t[i].p=read(),t[i].q=read(),f[i]=1e10;
	std::sort(t+1,t+1+m,cmp);
	f[0]=0;
	q[1].push_back(0);
	for(reg int i=1,j;i<=m;i++){//k=2*A*p[i]
		Insert(i);pop(i);
		if(q[t[i].x].size()){
			j=q[t[i].x][0];
			f[i]=f[j]+A*(t[i].p-t[j].q)*(t[i].p-t[j].q)+B*(t[i].p-t[j].q)+C;
			insert[t[i].y].push((_insert){i});
		}
		X[i]=t[i].q;Y[i]=f[i]+A*t[i].q*t[i].q-B*t[i].q;
//			if(f[i]<0){
//				std::printf("i: %d, f[i]: %lld, from: j: %d, f[j]: %lld\n",i,f[i],j,f[j]);
//				std::printf("%d: start : %lld, end : %lld\n%d: start : %lld, end : %lld\n",i,t[i].p,t[i].q,j,t[j].p,t[j].q);
//				if(t[j].q>t[i].p) std::puts("!!! q[j]>p[i] !!!");
//				return 0;
//			}
	}
	LL ans=1e18;
	for(reg int i=1;i<=m;i++)if(t[i].y==n) ans=min(ans,f[i]+t[i].q);
//		for(reg int i=1;i<=m;i++) std::printf("%lld\n",f[i]);
	std::printf("%lld",ans);
	return 0;
}
```

---

## 作者：WrongAnswer_90 (赞：2)

[P6302 [NOI2019] 回家路线 加强版](https://www.luogu.com.cn/problem/P6302)

斜率优化好题。

观察后猜想应该是 dp。经过思考发现如果以点为状态，在时间这一维上是存在后效性的，而如果开二维数组 $f_{i,j}$ 表示在第 $j$ 个时刻到了 $i$ 个点过不去加强版，考虑以列车为状态。

题目有两个限制，一是出发点和结束点的限制，即上一辆车的 $y$ 是下一辆车的 $x$，二是时间的限制，即上一辆车的 $q$ 要不大于下一辆车的 $p$。

对于第一条，考虑采用类似[柠檬](https://www.luogu.com.cn/problem/P5504)的处理方式，每一个节点开一个 vector 维护决策，转移第 $i$ 辆车的时候直接从 $x_i$ 的决策中转移。

而对于第二条，先按照 $p_i$ 排序，但是这样有可能会导致 $p_{i-1}$ 小但是 $q_{i-1}$ 非常大，后一个虽然 $p_i$ 相对变大但是 $q_i$ 可能小于前一个的 $q_{i-1}$，这样添加决策是无序的，转移的限制也没有解决。

注意到随着 $p_i$ 的增大，决策集合只变大不缩小，所以可以再按照 $q_i$ 排序，使用双指针的思想，每次转移前先把可用的决策扔进决策集合（这些决策一定在前面转移好了），这样就解决了时间的限制。

设 $f_i$ 表示坐了第 $i$ 辆车的最小烦躁值，容易得到转移方程

$$
f_i=min(f_j+A\times (p_i-q_j)^2+B\times (p_i-q_j)+C)
$$

有包含 $i,j$ 的平方项，很像斜率优化的标准形式，拆开，移项，整理得到：

$$
f_j+A\times q_j^2-B\times q_j=2Ap_iq_j+f_i-C-A\times p_i^2
$$

单调队列维护下凸壳即可。

注意计算斜率时可能会出现横坐标相等的情况，需要特判为 $INF$ 或 $-INF$。

代码比较烂，请见谅。。

```cpp
int n,m,A,B,C,ans=INF,pos[2000001],oth[2000001],f[2000001],sum[2000001],head[2000001],tail[2000001];
vector<int> ve[2000001];
struct Node{int x,y,p,q,id;}a[2000001],b[2000001];
bool cmp1(Node nd1,Node nd2){return nd1.p<nd2.p;}
bool cmp2(Node nd1,Node nd2){return nd1.q<nd2.q;}
#define sqr(x) ((x)*(x))
#define Y(i) (f[oth[i]]+A*sqr(b[i].q)-B*b[i].q)
#define X(i) (2*A*b[i].q)
#define K(i,j) (X(i)==X(j)?Y(i)>Y(j)?INF:-INF:1.0*(Y(i)-Y(j))/(X(i)-X(j)))
#define dty(i,j) (Y(i)-Y(j))
#define dtx(i,j) (X(i)-X(j))
inline void mian()
{
	read(n,m,A,B,C),memset(f,-1,sizeof(f)),f[0]=0,f[2000000]=inf,oth[2000000]=2000000;
	for(int i=1;i<=m;++i)read(a[i].x,a[i].y,a[i].p,a[i].q),a[i].id=i,++sum[a[i].y],b[i]=a[i];
	sort(a+1,a+1+m,cmp1),sort(b+1,b+1+m,cmp2);
	for(int i=1;i<=n;++i)ve[i].resize(sum[i]+3),i==1?0:ve[i][head[i]=tail[i]=1]=2000000;
	for(int i=1;i<=m;++i)pos[a[i].id]=i;
	for(int i=1;i<=m;++i)oth[i]=pos[b[i].id];
	head[1]=tail[1]=1;
	for(int i=1,j=0;i<=m;++i)
	{
		while(j<m&&b[j+1].q<=a[i].p)
		{
			++j;
			while(head[b[j].y]<tail[b[j].y]&&K(ve[b[j].y][tail[b[j].y]],ve[b[j].y][tail[b[j].y]-1])>K(j,ve[b[j].y][tail[b[j].y]]))--tail[b[j].y];
			ve[b[j].y][++tail[b[j].y]]=j;
		}
		while(head[a[i].x]<tail[a[i].x]&&K(ve[a[i].x][head[a[i].x]+1],ve[a[i].x][head[a[i].x]])<=(ld)a[i].p)
		++head[a[i].x];
		f[i]=f[oth[ve[a[i].x][head[a[i].x]]]]+A*sqr(a[i].p-b[ve[a[i].x][head[a[i].x]]].q)+B*(a[i].p-b[ve[a[i].x][head[a[i].x]]].q)+C;
		if(a[i].y==n)ans=min(ans,f[i]+a[i].q);
	}
	write(ans,'\n');
}
```

---

## 作者：翼德天尊 (赞：1)

第一个想法是以车站为阶段进行转移，但是一旦以车站为阶段就必须要带上【当前时间】这个状态，显然不行，只有 70 左右。

有些思路但不明晰，于是先看部分分。

发现 $A=B=0$ 的部分分跟傻子一样，大概想到的就是，可以设 $dp_i$ 表示的是坐到第 $i$ 座列车开始时的最小烦躁值，这样其实就相当于是用一维的变量概括了两维的信息。转移时可以考虑第 $i$ 辆列车的起始车站，在第 $i$ 辆列车驶出车站之前，所有以当前车站为目的地的列车，将这些列车取最小值即可转移。

于是正解其实也很明晰了，我们可以以列车时间为阶段，将每一个列车拆成两个，分别表示驶入和驶出，挂在他们对应的时间点上。设 $dp_i$ 表示第 $i$ 辆列车驶出时的最小烦躁值，对于每个时间阶段，我们先将所有在这个时间驶出的列车作为候选决策加入它们的目的地集合中，再将所有在这个时间驶入的列车作为状态，挑选出发点的集合进行转移。

又注意到贡献的特殊计算方式，考虑斜率优化 dp，由于状态之间与决策之间的时间显然单调，所以可以使用单调队列进行优化转移。

最后用所有驶出车站为 $n$ 的决策更新答案即可。时间复杂度 $O(m)$。好像并不需要什么堆进行辅助转移（

不过有亿些细节需要注意：

- 斜率可能相同，此时以 $b$ 的大小为准。
- 对于每个车站开单调队列显然空间不足，但每个车站的单调队列长度恒定，可以考虑用一个单调队列内存池存储所有单调队列。
- 并没有保证列车一定从左到右行驶，刚开始没看见调了一下午……

```cpp
for (int i=1;i<=m;i++){
	int a=read(),b=read(),c=read(),d=read();
	t[d].push_back(node(b,i)),s[c].push_back(node(a,i));
	zz[i]=d,++tot[b];
}
tot[1]=1;
for (int i=1;i<=n;i++) tot[i]+=tot[i-1],head[i]=tot[i-1]+1,tail[i]=tot[i-1];
t[0].push_back(node(1,0));
for (int i=0;i<=40000;i++){
	int len1=t[i].size(),len2=s[i].size();
	for (int j=0;j<len1;j++){
		int now=t[i][j].q;
		if (now==n) ans=min(ans,dp[t[i][j].id]+zz[t[i][j].id]);
		if (dp[t[i][j].id]!=INF){
			while (head[now]<tail[now]&&slope(q[tail[now]-1],q[tail[now]])>=slope(q[tail[now]],t[i][j].id)) --tail[now];
			q[++tail[now]]=t[i][j].id;	
		}
	}
	for (int j=0;j<len2;j++){
		int now=s[i][j].q;
		while (head[now]<tail[now]&&slope(q[head[now]],q[head[now]+1])<=2*x*i) ++head[now];
		if (head[now]>tail[now]) dp[s[i][j].id]=INF;
		else{
			int w=q[head[now]];
			dp[s[i][j].id]=dp[w]+x*(i-zz[w])*(i-zz[w])+y*(i-zz[w])+z;
		}
	}
}
```

好像还进了最优解第一页，看来这个解法还不错（

---

## 作者：Fan_sheng (赞：1)

# 转移
首先这题状态就不太好设。同时兼顾点和时间的话，空间稳稳炸。

于是参考了一下其他题解，发现可以直接用边同时表示点和时间（也是以后做题对于设状态的一种新思路吧）。

设 $dp[i]$ 表示**最后经过的边为第 $i$ 条边**的最小烦躁值（记得最后还要加上 $q[i]$）。
$$
\text{边界：}dp[0]=0
$$
$$
\text{答案：}\min_{y[i]=n}(dp[i])
$$
$$
dp[i]=\min_{x[i]=y[j]\land q[j]\leq p[i]}(dp[j]+A(p[i]-q[j])^2+B(p[i]-q[j])+C-q[j]+q[i])
$$

# 斜率优化

假定 $dp[i]$ 由 $dp[j]$ 转移过来，这就是标准的斜率优化式子。

我们按照斜优的一般套路变形，设 $D$ 和 $E$，把和 $j$ 有关的都放到 $D$ 中，把 和 $i$ 有关的都放到 $E$ 中。

$$
dp[i]=dp[j]+Ap[i]^2-2Ap[i]q[j]+Aq[j]^2+Bp[i]-Bq[j]+C-q[j]+q[i]
$$
$$
D=dp[j]+Aq[j]^2-Bq[j]+C-q[j]
$$
$$
E=Ap[i]^2+Bp[i]+q[i]
$$

最终变成 $y=kx+b$ 的形式
$$
D=(2Ap[i])q[j]+(dp[i]-E)
$$

要使得 $dp[i]$ 最小，就是维护凸包 $(q[j],D)$，使得斜率为 $2Ap[i]$ 的直线纵截距最小。

按 $p[i]$ 排序后，直线斜率单调递增，就可以使用双端队列解决问题。

# 限制
至此还没有做完。只有满足 $x[i]=y[j]\land q[j]\leq p[i]$ 的 $dp[j]$ 才能转移到 $dp[i]$。

考虑对于每个地点开一个双端队列，把 $j$ 代表的决策点插入 $y[j]$ 的双端队列中，计算 $dp[i]$ 时只从 $x[i]$ 的双端队列中选择决策点，就可以保证第一个限制。

第二个限制，我的做法是开一个 priority_queue，按 $q$ 从小到大排序。在计算 $dp[i]$ 之前，先把优先队列中所有 $q\leq p[i]$ 的决策点插入对应的双端队列。计算完之后，再把 $i$ 代表的决策点丢入优先队列中。

如此，所有可用的决策点都已经插入，而当前不可用的决策点在优先队列中保存。

# Code
这里使用 vector 和迭代器代替上述的双端队列。

小坑：由于两条边的 $q$ 可能相等，斜率可能出现 $+\infty$ 或 $-\infty$ 的情况，提前判一下。**维护的是下凸壳，一定是后加入的点比新加入的点高时返回 $+\infty$，反之返回 $-\infty$，不要搞反了**。

**记得最开始预先把边界决策点 $0$ 插入 $1$ 号点的双端队列中（因为起点是 $1$ 号点）。如果遍历到某条边时不能从任何决策点转移过来，说明无法乘坐该航班，$dp$ 值设为 $\inf$**。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
const ll inf=1e16;
int n,m,A,B,C;
ll dp[1000005],ans=inf;
vector<int>q[100005];
priority_queue<pii,vector<pii>,greater<pii> >wait;
namespace io{
	int out[22];
	template<typename T>inline void read(T &n){
		T w=1;n=0;char ch=getchar();
		while(!isdigit(ch)&&ch!=EOF){if(ch=='-')w=-1;ch=getchar();}
		while(isdigit(ch)&&ch!=EOF)n=(n<<3)+(n<<1)+(ch&15),ch=getchar();
		n*=w;
	}
	inline void write(ll x){
		if(!x){putchar('0');return;}
		if(x<0){putchar('-');x=-x;}
		while(x)out[++out[0]]=x%10,x/=10;
		while(out[0])putchar(out[out[0]]+'0'),out[0]--;
	}
}using namespace io;
struct star{
	int x,y,p,q;
}track[1000005];
inline bool cmp(star a,star b){
	return a.p==b.p?a.x<b.x:a.p<b.p;
}
inline ll D(int id){
	int ed=track[id].q;
	return dp[id]+1ll*A*ed*ed-1ll*B*ed+C-ed;
}
inline ll E(int id){
	int st=track[id].p,ed=track[id].q;
	return 1ll*A*st*st+1ll*B*st+ed;
}
inline double slope(int a,int b){//计算斜率 
	if(track[a].q==track[b].q){
		if(D(b)>D(a))return inf;
		if(D(b)==D(a))return 0;
		if(D(b)<D(a))return -inf;
	}
	return 1.0*(D(b)-D(a))/(track[b].q-track[a].q);
}
int main(){
	read(n),read(m),read(A),read(B),read(C);
	for(int i=1;i<=m;++i)read(track[i].x),read(track[i].y),read(track[i].p),read(track[i].q);
	sort(track+1,track+m+1,cmp);//按p排序 
	track[0]=(star){0,1,0,0},q[1].push_back(0);//插入边界 
	for(int i=1;i<=m;++i){
		while(wait.size()&&wait.top().first<=track[i].p){//预先把优先队列中合适的决策点插入 
			int id=wait.top().second,bel=track[id].y;
			wait.pop();
			auto tail=--q[bel].end(),tmp=--(--q[bel].end());
			while(q[bel].size()>1&&slope(*tail,id)<=slope(*tmp,*tail))//队尾删点 
			q[bel].erase(tail),tail=--q[bel].end(),tmp=--(--q[bel].end());
			q[bel].push_back(id);
		}
		int bel=track[i].x;
		auto head=q[bel].begin(),tmp=++q[bel].begin();
		while(q[bel].size()>1&&slope(*head,*tmp)<=2ll*A*track[i].p)//队首删点 
		q[bel].erase(head),head=q[bel].begin(),tmp=++q[bel].begin();
		if(head!=q[bel].end()){
			dp[i]=D(*head)+E(i)-2ll*A*track[i].p*track[*head].q;//转移 
			wait.push(make_pair(track[i].q,i));//丢入优先队列 
		}else dp[i]=inf;//无法转移到dp[i]，也无需丢入优先队列 
	}
	for(int i=1;i<=m;++i)if(track[i].y==n)ans=min(ans,dp[i]);//计算答案 
	write(ans);return 0;
}
```


---

## 作者：chenxia25 (赞：1)

> [洛谷题目页面传送门](https://www.luogu.com.cn/problem/P6302)

> 题意见洛谷里的翻译。（用$a,b,c$分别表示$A,B,C$）

直接考虑DP。设$dp_i$表示最后一次坐的是列车$i$时的最小烦躁值。显然，边界是$dp_0=0$（同时假装$y_0=1$），目标是$\min\limits_{y_i=n}\{q_i+dp_i\}$。

考虑转移。可转移性显然，因为$2$个状态不可能互为决策，即决策->状态构成的有向图一定是DAG。于是状态转移方程显然为

$$dp_i=\min\limits_{y_j=x_i,q_j\leq p_i}\!\left\{dp_j+a(p_i-q_j)^2+b(p_i-q_j)+c\right\}$$

直接转移是$\mathrm O\!\left(n^2\right)$的，考虑优化。容易想到的是，我们可以按$y$值建桶，这样每个状态的决策仅在$1$个桶内。

接下来，这个转移方程是一个非常经典的斜率优化模型，上手直接干：

对于$2$个决策$j,k$，$j$比$k$优当且仅当

$$dp_j+a(p_i-q_j)^2+b(p_i-q_j)+c<dp_k+a(p_i-q_k)^2+b(p_i-q_k)+c$$

化简得

$$dp_j+aq_j^2-bq_j-2ap_iq_j<dp_k+aq_k^2-bq_k-2ap_iq_k$$

将仅关于决策变量的项放左边，既关于状态变量又关于决策变量的项放右边，得

$$\left(dp_j+aq_j^2-bq_j\right)-\left(dp_k+aq_k^2-bq_k\right)<2ap_i(q_j-q_k)$$

要除过来了，可是我们还没确定$q_j-q_k$的符号。于是我们强行令$q_j\leq q_k$。先考虑$q_j<q_k$，此时$q_j-q_k<0$，除过去，变不等号方向，得

$$\frac{\left(dp_j+aq_j^2-bq_j\right)-\left(dp_k+aq_k^2-bq_k\right)}{q_j-q_k}>2ap_i$$

于是左边可以抽象成在以$q_i$为点$i$的横坐标、以$dp_i+aq_i^2-bq_i$为点$i$的纵坐标的直角坐标系中，过点$j$与点$k$的直线的斜率。我们设这个斜率为$f(j,k)$。那么问题来了，$q_j=q_k$即$q_j-q_k=0$时没有斜率怎么办呢？我们可以按照它与$2ap_i$比较之后必须得出正确的优劣关系的原则，规定当$q_j=q_k$时$f(j,k)=\begin{cases}\infty&dp_j<dp_k\\0&dp_j=dp_k\\-\infty&dp_j>dp_k\end{cases}$。

然后套路化地发现，若$3$个决策$i<j<k$满足$f(i,j)\geq f(j,k)$，分$2$种情况：
1. $f(i,j)>2ap_i$：此时$i$比$j$优；
1. $f(i,j)\leq 2ap_i$：结合$f(i,j)\geq f(j,k)$可得$f(j,k)\leq 2ap_i$，此时$j$没有$k$优。

综上，$j$一定不是最优决策，于是可以把它扔掉，即维护一个斜率严格单调上升的上凸壳。由于有$n$个桶作为决策栖息地，我们维护每个桶内的上凸壳，然后计算DP值时在对应的桶内的上凸壳内找即可。

接下来考虑DP顺序。显而易见的有$2$种：按$p$值升序和按$q$值升序。两种正确性都很好证，以$p$值升序为例，对于任意$i<j$，有$p_i\leq p_j$，又$p_j<q_j$，所以$q_j>p_i$，所以$i$不可能转移到$j$，得证。

先考虑$q$值升序。此时每个上凸壳可以单调栈$stk$维护。每计算完一个DP值，由于横坐标非严格单调上升，可以直接在栈顶加点并维护单调性（好吧其实并不能，还是得像下面那样two-pointers，因为转移方程$\min$里有$q_j\leq p_i$的限制）。计算的时候嘛，就只能二分查找第一个满足$f(stk_j,stk_{j+1})>2ap_i$的$stk_j$作为最优决策了（正确性显然）。单DP的时间复杂度就$\mathrm O(m\log m)$。

再来考虑$p$值升序。$2ap_i$显然也非严格单调递增，可以将单调栈改进为单调队列。但是这样刚计算完DP值并不能直接加进单调队列尾，因为不能保证没有其他横坐标更小的还没计算。所以应该对于每个上凸壳维护two-pointers，计算每个DP值时，在决策所在上凸壳的单调队列尾一连按$q$值升序添加好几个点。DP时间复杂度$\mathrm O(m)$。但是按$p$值、$q$值排序什么的还是带$\log$啊，这么一来费尽心思去DP的$\log$不是没用了吗？别急，可以桶排。时间复杂度$\mathrm O\!\left(n+m+\max\limits_{i=1}^n\{q_i\}\right)$。

~~什么？你问我到底用哪种DP顺序？当然用下面那种复杂度小的啦~~

另外，这题比较卡常，我O3、快读、改`deque`为`vector`模拟队列~~三连~~才AC。

代码：
```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define y0 afejaogoea
#define pb push_back
const int inf=0x3f3f3f3f3f3f3f3f;
const double dinf=1e100;
void read(int &x){
	x=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))x=(x<<1)+(x<<3)+(c^48),c=getchar();
}
int sq(int x){return x*x;}
const int N=100000,M=1000000,Q_I=40000;
int n,m,a,b,c;
int x[M+1],y[M+1],p[M+1],q[M+1];
vector<int> buc_y[N+1],buc_p[Q_I+1],buc_q[Q_I+1];//桶们 
int now[N+1];//two-pointers变量 
vector<int> que[N+1];//vector模拟队列 
int head[N+1],tail[N+1];//vector模拟队列 
int dp[M+1];//DP数组 
double f(int j,int k){//斜率 
	int y_j=dp[j]+a*sq(q[j])-b*q[j],y_k=dp[k]+a*sq(q[k])-b*q[k];
	if(q[j]==q[k])return y_j<y_k?dinf:y_j==y_k?0:-dinf;
	return 1.*(y_j-y_k)/(q[j]-q[k]);
}
signed main(){
//	freopen("C:\\Users\\chenx\\OneDrive\\桌面\\txt.txt","r",stdin);
	read(n);read(m);read(a);read(b);read(c);
	for(int i=1;i<=m;i++)read(x[i]),read(y[i]),read(p[i]),read(q[i]),buc_p[p[i]].pb(i)/*桶排*/,buc_q[q[i]].pb(i)/*桶排*/;
	buc_y[1].pb(0);
	for(int i=0;i<=Q_I;i++)for(int j=0;j<buc_q[i].size();j++)buc_y[y[buc_q[i][j]]].pb(buc_q[i][j]);//装桶 
	for(int i=1;i<=n;i++)que[i].resize(buc_y[i].size());
	memset(now,-1,sizeof(now));
	for(int i=0;i<=Q_I;i++)for(int j=0;j<buc_p[i].size();j++){//转移 
		int x0=buc_p[i][j];
		while(now[x[x0]]+1<buc_y[x[x0]].size()&&q[buc_y[x[x0]][now[x[x0]]+1]]<=p[x0]){//一连往队尾加好几个点 
			int y0=buc_y[x[x0]][++now[x[x0]]];
			while(head[x[x0]]+1<tail[x[x0]]&&f(que[x[x0]][tail[x[x0]]-2],que[x[x0]][tail[x[x0]]-1])>=f(que[x[x0]][tail[x[x0]]-1],y0))tail[x[x0]]--;//维护斜率单调性 
			que[x[x0]][tail[x[x0]]++]=y0;
		}
		while(head[x[x0]]+1<tail[x[x0]]&&f(que[x[x0]][head[x[x0]]],que[x[x0]][head[x[x0]]+1])<2*a*p[x0])head[x[x0]]++;//从队首弹出 
		if(head[x[x0]]<tail[x[x0]]){
			int y0=que[x[x0]][head[x[x0]]];
			dp[x0]=dp[y0]+a*sq(p[x0]-q[y0])+b*(p[x0]-q[y0])+c;
		}
		else dp[x0]=inf;//计算DP值 
	}
	int ans=inf;
	for(int i=0;i<buc_y[n].size();i++)ans=min(ans,q[buc_y[n][i]]+dp[buc_y[n][i]]);//目标 
	cout<<ans;
	return 0;
}
```

---

## 作者：Natori (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P6302)

本题为[P5468](https://www.luogu.com.cn/problem/P5468)的加强版，重点看数据范围：

$$2 \leq n \leq 10^5,1 \leq m\leq 10^6,0 \leq p_i \le q_i \leq 4 \times 10^4$$

当然还有三个参数：

$$0 \leq A \leq 10, 0 \leq B,C \leq 10^7$$

注意到此时 $B$ 和 $C$ 已经超过了 $10^7$，需要开 ```long long```。同时还发现 $m \leq 10^6$，这意味着 $\text{P5468}$ 正解（即 $O(m)$ 的斜率优化 $\text{DP}$）改一改就可以通过本题。

这里还是把斜率优化 $\text{DP}$ 的思路简单说一下：

设 $f_i$ 表示走完第 $i$ 条边最小的代价，则有暴力转移：

$$f_i=\min \{ f_j+A \times (p_i-q_j)^2 + B \times (p_i-q_j)+C \}$$

时间复杂度 $O(mt)$，其中 $t=\max_{i=1}^{m}q_i$，需要优化。

发现这个方程有平方项，考虑展开：

$$f_j+A \times q_j^2-B \times q_j=2\times A \times p_i \times q_j -f_i-A \times p_i^2-B \times p_i-C$$

把这个方程看成一次函数标准形式 $y=kx+b(k \neq 0)$，其中：

$$y=f_j+A \times q_j^2 - B \times q_j$$

$$k=2 \times A \times p_i$$

$$x=q_j$$

$$b=-f_i-A \times p_i^2-B \times p_i-C$$

用单调队列维护凸壳即可，每条边进出一次队列，时间复杂度 $O(m)$，可以通过本题。

代码（使用了较多 $\text{STL}$，可以自己卡一卡常数，注意开 ```long long```）：

```cpp
#include<cstdio>
#include<vector>
#include<queue>
using namespace std;
typedef long long ll;
typedef long double ld;
inline ll read(){
	ll f=1,x=0;
	char c=getchar();
	while(c<'0'||c>'9') {
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9') {
		x=x*10+c-'0';
		c=getchar();
	}
	return f*x;
}
inline void write(ll x){
	if(x<0)x=-x,putchar('-');
	if(x>9)write(x/10);
	putchar(x%10+'0');
}
inline ll max(ll x,ll y){
	return x>=y?x:y;
}
inline ll min(ll x,ll y){
	return x<=y?x:y;
} 
const int N=1e5+10,M=1e6+10,T=4e4+10;
const ll oo=1e18;//正无限 
int n,m;
ll A,B,C,x[M],y[M],p[M],q[M];
struct point{
	ll x,y;
	int id/*对应边的编号*/;
};
ll head[N];
vector<point> hull[N];
vector<int> d[T];
queue<int> res[T];
ll maxT/*即前面分析中的t*/,f[M],ans=oo;
inline ld get_slope(point a,point b){
	ll xx=a.x-b.x,yy=a.y-b.y;
	if(xx==0){
		if(yy>0)
			return 1.0*oo;
		else
			return -oo*1.0;
	}
	return (1.0*yy)/(1.0*xx);
}
inline void insert(int id){
	int pos=y[id];
	point new_one=(point){q[id],f[id]+A*q[id]*q[id]-B*q[id],id};
	while(hull[pos].size()-head[pos]>=2){
		int siz=hull[pos].size();
		if(get_slope(hull[pos][siz-1],hull[pos][siz-2])<get_slope(hull[pos][siz-2],new_one))
			break;
		hull[pos].pop_back();
	}
	hull[pos].push_back(new_one);
} 
inline void _delete(ld k,int pos){
	while(hull[pos].size()-head[pos]>=2){
		if(k<get_slope(hull[pos][head[pos]],hull[pos][head[pos]+1]))
			break;
		head[pos]++;
	}
}
int main(){
	n=read(),m=read(),A=read(),B=read(),C=read();
	for(int i=1;i<=m;i++){
		x[i]=read(),y[i]=read(),p[i]=read(),q[i]=read();
		if(maxT<q[i])
			maxT=q[i];
	}
	for(int i=1;i<=m;i++)
		d[p[i]].push_back(i);
	hull[1].push_back((point){0,0,0});
	for(int t=0;t<=maxT;t++){
		while(!res[t].empty()){
			insert(res[t].front());
			res[t].pop();			
		}
		ld k;
		for(int _=0,i,j,pos;_<d[t].size();_++){
			i=d[t][_],pos=x[i];
			if(head[pos]==hull[pos].size())//队列为空 
				continue;
			k=2.0*A*p[i];
			_delete(k,pos);
			j=hull[pos][head[pos]].id;
			f[i]=f[j]+A*(p[i]-q[j])*(p[i]-q[j])+B*(p[i]-q[j])+C;
			res[q[i]].push(i);
			if(y[i]==1ll*n)//走到终点 
				ans=min(ans,f[i]+q[i]);
		}
	}
	
	return 0;
}
```

---


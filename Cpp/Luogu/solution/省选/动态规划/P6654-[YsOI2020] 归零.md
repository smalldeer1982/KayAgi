# [YsOI2020] 归零

## 题目背景

Ysuperman 特别喜欢玩数数游戏。

~~其实本来这题想叫“亦旧亦久罢以龄”的，但是我见到其他的题目名称都是两个字，取这么长名称也不好。~~

## 题目描述

闲暇时光，Ysuerpman 选择用计算器打发时间。他输入了一个很长的十进制数 $S$。具体有多长呢？共 $n$ 位。为了方便解释，设从低到高第 $i$ 位上的数字是 $S_i$（下标从 $1$ 开始）。

Ysuerpman 每次会选择一个**非零**数字位进行「四舍五入」。具体来说，假设「四舍五入」的是第 $i$ 位：

- 如果 $S_i<5$，则让 $S$ 减去 $S_i \cdot 10^{i-1}$。
- 如果它 $S_i\ge5$，则让 $S$ 加上 $10^i$ 再减去 $S_i \cdot 10^{i-1}$。

经过若干次操作后，$S$ 总会变成 $0$。现在问题来了，请问有多少种使得 $S$ 变成 $0$ 的不同的方案？两个方案不同当且仅当某一次选择的操作位置不同。



## 说明/提示

### 样例解释

#### 样例解释 $1$

$\underline5\to \underline10 \to 0$

共 $1$ 种。

#### 样例解释 $2$

$\underline{4}5\to\underline{5}\to\underline10\to 0$

$4\underline{5}\to\underline{5}0\to \underline100 \to 0$

共 $2$ 种。

#### 样例解释 $3$

$\underline{5}5\to\underline{1}05\to\underline{5}\to\underline{1}0 \to 0$

$\underline{5}5\to10\underline{5}\to\underline{1}10\to \underline10 \to 0$

$\underline{5}5\to10\underline{5}\to1\underline{1}0\to \underline100 \to 0$

$5\underline{5}\to\underline{6}0\to \underline100 \to 0$

共 $4$ 种。

### 数据范围

**本题采用捆绑测试。**

| $\rm{subtask}$ |    $n$    | $S_i\in$ | 分数 |
| :------------: | :-------: | :------: | :--: |
|      $0$       |  $\le 6$  | $[0,9]$  | $5$  |
|      $1$       | $\le 15$ | $[0,9]$  | $13$ |
|      $2$       |  $\le40$  | $[0,4]$  | $5$  |
|      $3$       | $\le 40$  | $\{9\}$  | $12$ |
|      $4$       |  $\le40$  | $[5,8]$  | $15$ |
|      $5$       | $\le 40$  | $[0,9]$  | $30$ |
|      $6$       | $\le 64$  | $[0,9]$  | $20$ |

对于 $100\%$ 的数据，满足 $1\le n \le 64$，$S$ 不含前导零。

### 提示

本题时间限制为 $1145ms$。

题目并不难。

## 样例 #1

### 输入

```
5
```

### 输出

```
1
```

## 样例 #2

### 输入

```
45
```

### 输出

```
2
```

## 样例 #3

### 输入

```
55
```

### 输出

```
4
```

## 样例 #4

### 输入

```
3333
```

### 输出

```
24
```

## 样例 #5

### 输入

```
999999
```

### 输出

```
16336
```

## 样例 #6

### 输入

```
1919810
```

### 输出

```
3461
```

## 样例 #7

### 输入

```
11451419
```

### 输出

```
210000
```

# 题解

## 作者：Imakf (赞：4)

这波是标程被踩，已经没脸见人了。万人血书 @skydogli 写一份题解。

**标签：dp**

### 题意简述

给定数字 $S$，每次选择一位四舍五入，问数字变成 $0$ 的操作方案数。答案取模。

-------

### ${\rm{subtask\ 0}}\ (n\le6)$

按题意模拟爆搜 / dp。

### ${\rm{subtask\ 1}}\ (n \le 15)$

容易发现 $1\sim3$ 本质相同，简并为 $1$。$5\sim8$ 本质相同，简并为 $5$。所以只有可能出现 $5$ 种数字：$0,1,4,5,9$。（奇妙的是它们可以组成 114514191910，这一定不是巧合！）

同时，一个数位不可能 $5$ 种情况都存在，最多会有其中的 $4$ 种。意思是说，__对于每一个位置，至少有一种数字不可能出现。__

预处理出每个数位可能被哪些数字占据。然后状压 $dp$ 即可。

复杂度 $O(4^nn)$，感觉大概跑不满(?)。如果不幸被卡那我谢罪。

### ${\rm{subtask\ 2}}\ (S_i\in[0,4])$

不会产生进位，只需要找到有几个位置不是 $0$，求个阶乘。

### ${\rm{subtask\ 3}}\ (S_i=9)$

发现【四舍五入】一个 ⑨ 之后，会使前面连续的 $9$ 变成 $0$，再在最前面加一个 $1$。这个 $1$ 是与世隔绝的，它不会使别人进位，别人也不能让他进位。

大概很容易想到 $dp$。设 $dp_{i,j}$ 表示从高到低考虑到第 $i$ 位，且前 $i-1$ 位已经没有 $9$ 了，且剩余 $j$ 个与世隔绝的 $1$ 的方案数。

考虑用记忆化搜索实现。转移每次找一个后面的 $9$ 【四舍五入】或者消除一个与世隔绝的 $1$ 即可。

复杂度 $O(n^3)$，前缀和优化可以做到 $O(n^2)$。

参考代码：

```cpp
// O(n^2)
#include <bits/stdc++.h>

const int MX = 56;
const int MOD = 998244353;

int dp[MX][MX][2];
char str[233];
int dapai(int x ,int y ,int t){
	if(~dp[x][y][t]) return dp[x][y][t];
	int ret = (x == 0 && y == 0);
	if(y && t) ret = (ret + 1LL * y * dapai(x ,y - 1 ,1)) % MOD;
	if(x){
		if(x != 1) ret = (ret + dapai(x - 1 ,y ,0)) % MOD;
		ret = (ret + dapai(x - 1 ,y + 1 ,1)) % MOD;
	}
	return dp[x][y][t] = ret;
}

int main(){
	memset(dp ,-1 ,sizeof dp);
	init();
	scanf("%s" ,str);
	int n = strlen(str);
	printf("%d\n" ,dapai(n ,0 ,0));
	return 0;
} 
```

### ${\rm{subtask\ 4}}\ (S_i\in[5,8])$

出题人并不会，他出这个部分分只是觉得好像有什么做法。

验题人给出了一种做法：

有一种复杂度与划分数方案相关的暴力，设 $dp[st][i]$ 为当前划分区间状态为 $st$，有 $i$ 个与世隔绝的 $1$ 的方案数。

每次枚举【四舍五入】哪个或者选择消去一个 $1$ 即可转移，总复杂度 $O(\text{划分数}(n)\times n^2)$。

本地跑出结果后打表即可。

### ${\rm{subtask\ 5}}\ (n \le 40)$

出题人出这个部分分只为放过复杂度正确但常数大的。

### ${\rm{subtask\ 6}}\ (n \le 64)$

三句话题解：

![](https://cdn.luogu.com.cn/upload/image_hosting/v6lprfn9.png)


注意到一个事实：【四舍五入】一个位置之后可以把左右两部分分成子问题。

设 $dp_{l,r,c,1/0}$ 表示除了 $[l,r]$ 位其它数位都变成了 $0$，还需【四舍五入】 $c$ 次这个区间也全都变成 $0$，【四舍五入】第 $l-1$ 位的时候是否对第 $l$ 位造成进位，的方案数。进位后的数字可以直接预处理。


转移只需要枚举当前【四舍五入】哪一位 $mid$，以及区间 $[l,mid-1],[mid+1,r]$ 如何分配剩余的 $c-1$ 次【四舍五入】即可。
注意有的时候【四舍五入】进位会导致右端点 $+1$，直接特判掉即可。

复杂度 $O(n^5) = 1,073,741,824$，剪剪枝/卡卡常即可通过。

剪枝方法：预处理每个区间最多和最少【四舍五入】次数。不满足的区间则不递归。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>

const int MX = 64 + 3;
const int MOD = 998244353;

int dp[MX][MX][MX * 2][2] ,n;
int C[MX * 2][MX * 2];
char str[MX][MX];
int maxmv[MX][MX][MX] ,minmv[MX][MX][MX];

void init(){
	for(int i = 0 ; i < MX * 2 ; ++i) C[i][0] = 1;
	for(int i = 1 ; i < MX * 2 ; ++i)
		for(int j = 1 ; j < MX * 2 ; ++j)
			C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
}

int calc(int n ,int m){
	return C[n + m][m];
}

int dapai(int l ,int r ,int c ,int jw){
	if(c < 0) return 0;
	if(l > r) return !c;
	int ind = (!jw) * n + jw * l;
	if(~dp[l][r][c][jw]) return dp[l][r][c][jw];

	if(c == 0) return !maxmv[ind][l][r];
	
	int cur = 0;
	int book[MX] = {0};
	int ok = 1;
	for(int k = r ; k >= l && ok ; --k){
		book[k] = ok && str[ind][k] >= 5;
		ok = ok && str[ind][k] == 9;
	}
	for(int k = l ; k <= r ; ++k){
		if(str[ind][k] == 0) continue;
		if(book[k] || (k == r && str[ind][k] >= 5)){
			cur = (cur + 1LL * dapai(l ,k - 1 ,c - 2 ,jw) * calc(c - 2 ,1)) % MOD;
			continue;
		}
		int tind = ((str[ind][k] < 5) * n + (str[ind][k] >= 5) * (k + 1));
		for(int s = minmv[ind][l][k - 1] ; s <= c - 1 ; ++s){
			if(s > maxmv[ind][l][k - 1]
			|| (c - 1 - s) > maxmv[tind][k + 1][r]
			|| (c - 1 - s) < minmv[tind][k + 1][r]) continue;
			cur = (cur + 1LL
				* dapai(l ,k - 1 ,s ,jw) 
				* dapai(k + 1 ,r ,c - s - 1 ,str[ind][k] >= 5) % MOD
				* calc(s ,c - s - 1)) % MOD;
		}
	}
	return dp[l][r][c][jw] = cur;
}

int main(){
	memset(dp ,-1 ,sizeof dp);
	init();
	std::cin >> str[0];
	n = strlen(str[0]);
	std::reverse(str[0] ,str[0] + n);
	str[0][n] = '0' ,n = n + 1;
	for(int i = 0 ; i < n ; ++i) str[0][i] -= '0';
	memcpy(str[n] ,str[0] ,sizeof str[0]);

	for(int i = 0 ; i < n ; ++i){ // Ä£Äâ½«´ËÎ»½øÎ»
		memcpy(str[i] ,str[n] ,sizeof str[i]);
		str[i][i]++;
		for(int j = i ; j < n ; ++j){
			str[i][j + 1] += str[i][j] / 10;
			str[i][j] %= 10;
		}
	}
	
	for(int i = 0 ; i <= n ; ++i){
		for(int l = 0 ; l < n ; ++l){
			for(int r = l ; r < n ; ++r){
				for(int s = r ; s >= l ; --s){
					maxmv[i][l][r] += (str[i][s] != 0);
					maxmv[i][l][r] += (str[i][s] >= 5);
				}
				int ret = 0;
				for(int s = l ; s <= r ; ++s){
					ret += str[i][s];
					if(ret % 10) minmv[i][l][r]++;
					if(ret >= 5) ret = 1;
					else ret = 0;
				}
				if(ret % 10) minmv[i][l][r]++;
			}
		}
	}
	
	int Ans = 0;
	for(int i = minmv[n][0][n - 1] ; i <= maxmv[n][0][n - 1] ; ++i){
		int ret = dapai(0 ,n - 1 ,i ,0);
		Ans = (Ans + ret) % MOD;
	}
	printf("%d\n" ,Ans);
	return 0;
}

```

---

## 作者：a___ (赞：3)

这里提供一种 $\mathbf O(n^4)$ 的做法，来自 @[skydogli](https://www.luogu.com.cn/user/7480)，就是出题人说的那个。  

根据题意，设 $f_{i,j,k}$ 表示将 $s_{1\dots i-1}$ 归零一共做了 $j$ 次操作，其中第 $k$ 次操作是 $i-1$ 向 $i$ 进位的情况的方案数。特别地，$k=0$ 表示没有进位的情况。  

对于每一位，显然有以下几种情况：  
1. $s_i=0$
	1. 被进位（$k\not=0$）
    	1. 被进位后操作一次，不进位  
        	$f_{i+1,j+1,0}\leftarrow(j-k+1)f_{i,j,k}$
    1. 没被进位（$k=0$）
    	1. 不操作  
        	$f_{i+1,j,0}\leftarrow f_{i,j,k}$
1. $s_i=1,2,3$
	1. 被进位（$k\not=0$）
    	1. 被进位后操作一次，不进位  
        	$f_{i+1,j+1,0}\leftarrow(j-k+1)f_{i,j,k}$
        1. 被进位前操作一次，被进位后再操作一次，不进位  
        	$f_{i+1,j+2,0}\leftarrow k(j-k+1)f_{i,j,k}$
    1. 没被进位（$k=0$）
    	1. 操作一次，不进位  
        	$f_{i+1,j+1,0}\leftarrow(j+1)f_{i,j,k}$  
1. $s_i=4$
	1. 被进位（$k\not=0$）
    	1. 被进位后操作一次，进位  
        	$\forall p\in[k+1,j+1],f_{i+1,j+1,p}\leftarrow f_{i,j,k}$
        1. 被进位前操作一次，被进位后再操作一次，不进位  
        	$f_{i+1,j+2,0}\leftarrow k(j-k+1)f_{i,j,k}$
    1. 没被进位（$k=0$）
    	1. 操作一次，不进位  
        	$f_{i+1,j+1,0}\leftarrow(j+1)f_{i,j,k}$  
1. $s_i=5,6,7,8$
	1. 被进位（$k\not=0$）
    	1. 被进位后操作一次，进位  
        	$\forall p\in[k+1,j+1],f_{i+1,j+1,p}\leftarrow f_{i,j,k}$
        1. 被进位前操作一次，被进位后再操作一次，进位  
        	$\forall p\in[1,k],f_{i+1,j+2,p}\leftarrow (j-k+1)f_{i,j,k}$
    1. 没被进位（$k=0$）
    	1. 操作一次，进位  
        	$\forall p\in[1,j+1]f_{i+1,j+1,p}\leftarrow f_{i,j,k}$
1. $s_i=9$
	1. 被进位（$k\not=0$）
    	1. 被进位后不操作，进位  
        	$f_{i+1,j,k}\leftarrow f_{i,j,k}$
        1. 被进位前操作一次，被进位后再操作一次，进位  
        	$\forall p\in[1,k],f_{i+1,j+2,p}\leftarrow (j-k+1)f_{i,j,k}$
    1. 没被进位（$k=0$）
    	1. 操作一次，进位  
        	$\forall p\in[1,j+1]f_{i+1,j+1,p}\leftarrow f_{i,j,k}$

像这样，对每一种情况分别转移，复杂度 $\mathbf O(n^4)$，目前是最优解。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
const int N=70,p=998244353;
int n,m,f[N][N<<1][N<<1],ans;
char s[N];
inline void add(int &a,int b){bool f=(a+=b)<p;a-=(f-1)&p;}
int main()
{
	int i,j,k,l;scanf("%s",s+1);n=strlen(s+1);
	std::reverse(s+1,s+1+n);s[++n]='0';f[1][0][0]=1;
	for(i=1;i<=n;i++,m+=2)
	for(j=0;j<=m;j++)
	for(k=0;k<=j;k++)
	if(s[i]=='0')
		if(k) add(f[i+1][j+1][0],1ll*f[i][j][k]*(j-k+1)%p);
		else add(f[i+1][j][0],f[i][j][k]);
	else if(s[i]>='1'&&s[i]<='3')
		if(k) add(f[i+1][j+1][0],1ll*f[i][j][k]*(j-k+1)%p),add(f[i+1][j+2][0],1ll*f[i][j][k]*k*(j-k+1)%p);
		else add(f[i+1][j+1][0],1ll*f[i][j][k]*(j+1)%p);
	else if(s[i]=='4')
		if(k)
		{
			for(l=k+1;l<=j+1;l++)add(f[i+1][j+1][l],f[i][j][k]);
			add(f[i+1][j+2][0],1ll*f[i][j][k]*k*(j-k+1)%p);
		}
		else add(f[i+1][j+1][0],1ll*f[i][j][k]*(j+1)%p);
	else if(s[i]>='5'&&s[i]<='8')
		if(k)
		{
			for(l=k+1;l<=j+1;l++)add(f[i+1][j+1][l],f[i][j][k]);
			for(l=1;l<=k;l++)add(f[i+1][j+2][l],1ll*f[i][j][k]*(j-k+1)%p);
		}
		else for(l=1;l<=j+1;l++)add(f[i+1][j+1][l],f[i][j][k]);
	else
		if(k)
		{
			add(f[i+1][j][k],f[i][j][k]);
			for(l=1;l<=k;l++)add(f[i+1][j+2][l],1ll*f[i][j][k]*(j-k+1)%p);
		}
		else for(l=1;l<=j+1;l++)add(f[i+1][j+1][l],f[i][j][k]);
	for(i=0;i<=m;i++)for(j=0;j<=i;j++)add(ans,f[n+1][i][j]);
	printf("%d\n",ans);return 0;
}
```

---


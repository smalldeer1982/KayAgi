# 「Wdsr-2」阴阳玉

## 题目背景

博丽灵梦有一块好大好大的阴阳玉，它是是博丽灵梦的主要武器之一。

但是阴阳玉的能量来源，源自主人的灵力聚集力量，因此，灵梦在平时总是需要对其进行保养。简单来说，灵梦会使用灵力，来获取阴阳玉所需的能量。



## 题目描述

灵力有阴阳之分。初始的时候，灵梦只有两个阳灵力，它们围成了一个圈。每次，灵梦可以进行以下两种操作：

- 在两个灵力直接加入一个阳灵力。

- 移走一个阳灵力。

为了保持稳定，任何时候这个圈上的灵力都**不应该少于两个**。

由于灵力的阴阳并不稳定，因此一旦某个灵力周围发生改变（多出一个灵力，或减少一个灵力），它就会从阳变成阴，或从阴变成阳。不过，如果只是周边灵力的性质改变，那么它就不会发生变化。

灵梦会不断调节灵力，直到它**最终**变成 $n$ 个（中途可能多于 $n$ 个）。然后，灵梦会从某个点**依次**按照顺时针或逆时针取下每个灵力。它会形成一条链。灵梦会用链上的能量，来加强她的阴阳玉。

做到这一点非常容易。但是灵梦非常好奇，一共可能形成多少种不同的**链**。

由于灵梦的偏好，她可能会有 $m$ 个限制条件。第 $i$ 个条件 $(p_i,c_i)$ ，规定了链上第 $p_i$ 个灵力应该为何种灵力。若 $c_i=0$ ，则应该为阴灵力；否则为阳。

由于可能结果太大，灵梦只需要得到答案对 $998244353$ 取模的结果。

两个链不同，当且仅当存在一个位置的点颜色不同。

## 说明/提示

#### 样例解释

对于样例一，可能存在以下两种构造方式：

![pic3.JPG/The "2"-th of the "1"-st.](https://i.loli.net/2020/07/17/VQn8MB7fxJsA1Rr.jpg)

其中， $\tt ADD$ 表示增加一个阳灵力，$\tt RMV$ 表示移走一个阳灵力。

将得到的两个环分别拆开，一共可以得到以下五种链：

- 环一：**阳—阳—阳—阳**。

- 环二：**阳—阳—阴—阴**，**阳—阴—阴—阳**，**阴—阴—阳—阳**，**阴—阳—阳—阴**。

因此答案为 $5$ 。

对于样例二，我们限定了链上第一个灵力为阳。因此结果为 $3$ 。

#### 数据范围

$$\def\t{\text}\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & n\t{ 的范围} & m\t{ 的范围} & \t{分值}\cr\hline
1 & n\le 16 & m\le 16 & 15 \cr \hline
2 & n\le 10^6 &  m\le 5\times 10^3 & 40 \cr \hline
3 & n\le 10^{18} & m=0 & 15 \cr \hline
4 & n\le 10^{18} & m\le 5\times 10^3 & 30 \cr \hline
\end{array}$$

此外，对于全部数据，有 $1\le p_i\le n,c_i\in \{0,1\}, 0\le m\le n$ 且 $p_i$ 各不相同。

## 样例 #1

### 输入

```
4 0```

### 输出

```
5```

## 样例 #2

### 输入

```
4 1
1 1```

### 输出

```
3```

## 样例 #3

### 输入

```
20 10
5 1
12 0
17 0
3 1
7 1
13 0
8 1
18 1
2 1
19 0```

### 输出

```
344```

# 题解

## 作者：囧仙 (赞：3)

## 题目大意

有两个黑点，围成了一个圈。你可以通过以下操作扩充这个圈。

- 在两个点之间加入一个白点，并翻转这两个点的颜色。
- 删除一个白点，同时翻转它相邻的两个点的颜色。

翻转的含义是，将白色的点变成黑色，将黑色的点变成白色。

每次操作时，都必须保证**操作后点的个数不小于 $2$** 。你可以进行无数次操作。现在经过若干次操作后，得到了一个大小为 $n$ 的圈。接着**任取**某个位置断开，会形成一个链。

同时，可能有 $m$ 个约束条件。第 $i$ 个约束条件 $(p_i,c_i)$ ，表示这条链的第 $p_i$ 个点应该是 $c_i$ 颜色的。其中，$c_i=0$ 表示该点为黑色， $c_i=1$ 表示该点为白色。

询问最多可以得到多少个满足条件的不同的链。由于可能结果太大，你只需要输出它对 $998244353$ 取模的结果。

两个链不同，当且仅当存在一个位置的点颜色不同。

## 题解

### $\textbf{Subtask 1}\ n,m\le 16$

直接暴力操作，并判断是否符合条件即可。复杂度$\mathcal O(2^n\times n)$ 。

### $\textbf{Subtask 2}\ n\le 10^6,m\le 5\times 10^3$ 

首先，让我们证明一个小结论：**黑点的个数总为偶数个**。

这个结论非常简单。考虑每次加点操作，如果左右两个点同色，那么黑点个数的变化量为$\pm2$；如果异色，那么相当于交换了两点，数量不变。由于初始时候，黑点数量为 $0$ ，因此任何时候黑点的数量都应该是偶数。

![pic1.JPG](https://i.loli.net/2020/07/16/zP1nierojSaHZkN.jpg)

不妨设当前一共有 $p$ 个黑点，则这些黑点将圆弧划分为了 $p$ 段。我们对其进行染色。（如图 $1$ )

我们对圆弧进行染色：白色、黑色、白色……由于只有偶数段圆弧，所以每两个弧之间的颜色不同。

我们将黑色弧上的白点赋值为 $+1$ ，白色弧上的白点赋值为 $-1$ （如图 $2 $）。统计所有白点的权值和 $S$ 。由于黑白弧可以交换，所以白点的权值和亦能为 $-S$ 。下面讨论两种操作对 $S$ 的影响。

- 当加入点的两侧都是黑点时，黑点变为白点。由于该操作不会影响其他点的权值，且这三个点权值相同。于是 $S\gets S\pm 3$ 。

- 当加入的点两侧都是白点时，白点变为黑点。显然，新加入的白点的权值与原先两点的权值相反。因此，$S\gets S\pm 3$。

- 当加入的点两侧的点的显色相异时，不妨设其中白点权值为 $a$ 。插入后，原先两侧的点位置交换，原来的白点交换后权值变为了 $-a$。新的点权值与该白点相同，亦为 $-a$ 。于是，$S\gets S-3\times a$。

对于删点操作，由于其是加点操作的互逆操作，因此 $S$ 的变化量也为 $3$ 的倍数。可以这样简要证明：

假设删去一个白点后，重新在该位置重新加入白点，此时 $S$ 不变；而加入白点，$S$ 的变化为 $3$ 的倍数，因此删点操作， $S$ 的变化量亦为 $3$ 的倍数。

初始时，$S=\pm 2$ 。因此终止状态的权值和 $S'$ 必有 ：

$$S'\not \equiv 0 \pmod 3$$

在开头，我们已经证明黑点的个数必为偶数。下证任何一个符合这两个条件的状态，都能由初始状态转移而来。

由于 $S' \not \equiv 0 \pmod 3$ ，因此无论何时都有至少一个白点。我们不断删去白点，直到只剩下两个点，其中也必有白点。同时，由于黑点个数为偶数，所以只有可能有 $0$ 个黑点，即初始状态。因此，从任何满足这两个条件的状态都能仅通过删点回到初始状态。又由于加点操作是删点的逆操作，因此我们只需要按照删点的顺序倒过来操作，就一定能获得该状态。

于是，我们可以用 $\rm dp$ 计算出方案总数。

由于最终我们会给圆环断链，因此就相当于提前给大小为 $n$ 的圆环的每个点编了号。不妨任取一个点开始，编为 $1,2,3\cdots$ 我们设计状态 $dp_{i,j,k}$，表示前 $i$ 个点，黑点个数$\mod 2=j$ 且 $S\mod 3=k$ 的方案总数。于是我们能够得到转移方程：

$$dp_{i,j,k}=\begin{cases}
dp_{i-1,0,(k+2)\mod 3}+dp_{i-1,1,k} & j=0\cr
dp_{i-1,1,(k+1)\mod 3}+dp_{i-1,0,k} & j=1\end{cases}$$

由于黑白可以交换，所以我们可以钦定第一个点处在白弧上。每讨论一个黑点，黑白弧的情况就会交换。初始时，$dp_{1,0,1}=dp_{1,1,0}=1$，其他的 $i=1$ 的情况都为 $0$ 。答案为 $dp_{n,0,1}+dp_{n,0,2}$。

关于限制条件的问题，我们只需要计算到限制点的时候，舍去不合法的转移方法。如限制点 $a$ 为白点，我们就要舍弃点 $a-1$ 转移到黑点的情况；限制点为白点同理可推。

### $\textbf{Subtask 3}\ n\le 10^9,m=0$ 

如果你已经写出了上面两个$\rm Subtask$的任意一种，经过简单打表，你会发现，设 $f(x)$ 为 $n=x,m=0$ 时的结果，有：

$$f(x)=\begin{cases}1 & x=2 \cr f(x-1)\times 2+1 & x\text{为奇数} \cr f(x-1)\times 2-1 &x\text{为偶数}\end{cases}$$

至于这个式子怎么计算，最简单的方法，就是直接矩阵乘法……当然，你也可以考虑分治。

首先我们能够发现， 

$$\begin{aligned}f(2k)&=f(2k-1)\times 2-1\cr&=(f(2(k-1))\times 2+1)\times 2-1\cr&=f(2(k-1))\times 4+1\end{aligned}$$

不妨设 $g(x)=f(2\times x)$ 。则 $g(1)=1,g(n)=4\times g(n-1)-1$。

假设我们要计算 $g(x)$ 用 $g(2)$ 表示的结果，那么我们只需要计算出 $g(\lfloor\frac{x}{2}\rfloor)$ 用 $g(2)$ 表示的结果，稍加修改就能推出用 $g(\lfloor\frac{x}{2}\rfloor)$ 表示 $g(x)$ 的结果。

当然，如果你数学功底足够好，你或许能直接推导出通项公式（

**时间复杂度**：$\mathcal O(\log_2n)$。

### $\textbf{Subtask 4}\ n\le 10^{18},m\le 5\times 10^3$ 

让我们回到 $\text{Subtask 2}$ 的做法。

很显然，每个点的状态只与上个点有关，因此我们能够压缩掉第一维。

我们能够发现，该式可以矩阵加速递推。具体而言，我们设计一个 $1\times 6$ 的向量矩阵，其中第$(j\times 3+k+1)$ 列表示$dp_{i,j,k}$；然后设计一个转移矩阵，使用矩阵快速幂进行加速转化。

初始矩阵：

$$\begin{bmatrix}0 & a & 0 & b & 0 & 0\end{bmatrix}$$

其中，当点 $1$ 限制为白点时， $a=1$ ，否则 $a=0$ ；

其中，当点 $1$ 限制为黑点时， $b=1$ ，否则 $b=0$ 。

转移矩阵：

$$\begin{bmatrix}
0 & 1 & 0 & 1 & 0 & 0 \cr
0 & 0 & 1 & 0 & 1 & 0 \cr
1 & 0 & 0 & 0 & 0 & 1 \cr
1 & 0 & 0 & 0 & 0 & 1 \cr
0 & 1 & 0 & 1 & 0 & 0 \cr
0 & 0 & 1 & 0 & 1 & 0 \cr
\end{bmatrix}$$

$\rm PS:$实际计算转移矩阵的时候，完全可以直接用 $\rm dp$ 式子生成，而不需要手推。

**时间复杂度**：$\mathcal O(m\times k^3\times \log _2 \frac{n}{m})$。其中，$k$为矩阵大小，即 $k=6$ 。

## 参考代码

$\text{Subtask 1}$，暴力代码：

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l;i<=r;i++)
#define dn(l,r,i) for(int i=l;i>=r;i--)
using namespace std;

typedef long long LL;
const int INF =2147483647;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0')
    w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9')
    ret=ret*10+c-'0';
    return ret*w;
}
map<int,int> T;
bool chk(int n,int t){
    dn(n-1,2,i){
        int x=(t&-t),p=T[x];
        if(x==0) return false;
        if(p==i) t^=1,t^=(1<<i-1),t-=1<<p; else
        if(p==0) t^=2,t^=(1<<i  ),t>>=1;   else{
            t^=1<<p-1,t^=1<<p+1;
            t=(t&(1<<p)-1)|(t>>p)<<p-1;
        }
    }
    return t==3;
}
int cnt(int n,int t){
    int c=n; up(0,n-1,i){
        if(t&(1<<i)) --c;
    }
    return c;
}
#define pi first
#define ci second
int ans; pair<int,int> P[20]; bool made_by_joesSR=true;
int main(){
    up(0,20,i) T[1<<i]=i;
    int n=qread(),m=qread(),p=(1<<n)-1;
    up(1,m,i){
        int x=qread(),y=qread(); P[i].pi=x,P[i].ci=y;
    }
    up(0,p,i){
        up(1,m,j){
            if(!!(i&(1<<P[j].pi-1))!=P[j].ci) goto nxt;
        }
        if(cnt(n,i)%2==0&&chk(n,i)) ++ans;
        nxt:;
    }
    printf("%d\n",ans);
    return 0;
}
```

$\text{Subtask 1\~ 3}$，普通$\rm dp$。

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l;i<=r;i++)
#define dn(l,r,i) for(int i=l;i>=r;i--)
using namespace std;

typedef long long LL;
const int INF =2147483647;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0')
    w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9')
    ret=ret*10+c-'0';
    return ret*w;
}
const int MAXC =6+3,MAXM=5e3+3;
int n,m,p=1,A[MAXC],B[MAXC];
const int MOD  =998234353;
#define dp(x,y) ((x)*3+(y))
#define pi first
#define ci second
pair<int,int> P[MAXM]; bool made_by_joesSR=true;
int main(){
    n=qread(),m=qread();
    up(1,m,i) P[i].pi=qread(),P[i].ci=qread();
    sort(P+1,P+1+m);
    if(P[1].pi==1){
        ++p;
        if(P[1].ci==0) A[dp(1,0)]=1;
        else           A[dp(0,1)]=1;
    } else A[dp(1,0)]=A[dp(0,1)]=1;
    up(2,n,i){
        bool a=true,b=true;
        if(P[p].pi==i){if(P[p].ci==0) a=false; else b=false;++p;}
        up(0,1,j) up(0,2,k){
            B[dp(j,k)]=(A[dp(j,(k+2-j)%3)]*a+A[dp(!j,k)]*b)%MOD;
        }
        memcpy(A,B,sizeof(B));
    }
    printf("%d\n",(A[dp(0,1)]+A[dp(0,2)])%MOD);
    return 0;
}
```

$\text{Subtask 3}$，分治。

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l;i<=r;i++)
#define dn(l,r,i) for(int i=l;i>=r;i--)
using namespace std;

typedef long long LL;
const int INF =2147483647;
LL qread(){
    LL w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
const int MOD=998234353;
void calc(LL n,int &a,int &b){     
    if(n==1){a=1,b=0;return;}
    LL m=n/2; int p=0,q=0; calc(m,p,q);
    q=((LL)p*q+q)%MOD,p=(LL)p*p%MOD;
    LL t=2ll*m-1; while(t<n){
        p=(LL)p*4%MOD,q=((LL)4*q+1)%MOD; ++t;
    }
    a=p,b=q;
}
LL n,m; bool made_by_joesSR=true;
int main(){
    n=qread(),m=qread();
    if(m) puts("-1"),exit(0);
    if(n%2==0){
        int a,b; calc(n/2,a,b); printf("%d\n",(a+b)%MOD);
    } else{
        int a,b; calc(n/2,a,b); printf("%d\n",(2ll*(a+b)+1)%MOD);
    }
    return 0;
}
```

$\text{Subtask 4}$，矩阵优化 $dp$

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l;i<=r;i++)
#define dn(l,r,i) for(int i=l;i>=r;i--)
using namespace std;

typedef long long LL;
const int INF =2147483647;
typedef unsigned long long u64;
u64 qread(){
    u64 w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
const int MOD =998234353;
const int MAXC=6+3,MAXN=5e3+3;
struct mtx{
    int dt[MAXC][MAXC],a,b;
    mtx(int x=0,int y=0):a(x),b(y){memset(dt,0,sizeof(dt));}
    mtx operator *(mtx t){
        int n=a,p=b,m=t.b; mtx r(n,m); up(0,p-1,i) up(0,n-1,j) up(0,m-1,k)
        r.dt[j][k]=((LL)r.dt[j][k]+(LL)dt[j][i]*t.dt[i][k])%MOD;
        return r;
    }
}o(1,6),oo(6,6);
mtx pwr(mtx x,u64 y){
    mtx r=x,t=x; --y; while(y){if(y&1) r=r*t; t=t*t,y>>=1;} return r;
}
#define pi first
#define ci second
#define dp(x,y) ((x)*3+(y))
u64 n,m,lst,T[MAXC]; bool made_by_joesSR=true; pair<u64,bool> P[MAXN];
int main(){
    up(0,1,i) up(0,2,j){
        oo.dt[dp(!i,j)][dp(i,j)]=oo.dt[dp(i,(j+2-i)%3)][dp(i,j)]=1;
    }
    n=qread(),m=qread(); up(1,m,i) P[i].pi=qread(),P[i].ci=qread();
    sort(P+1,P+1+m);
    if(P[1].pi==1){
        if(P[1].ci==0) o.dt[0][dp(1,0)]=1;
        else           o.dt[0][dp(0,1)]=1;
    } else o.dt[0][dp(1,0)]=o.dt[0][dp(0,1)]=1;
    lst=1;
    up(1,m,i){
        if(P[i].pi==1) continue;
        if(lst<P[i].pi-1) o=o*pwr(oo,(P[i].pi-1)-lst);
        memset(T,0,sizeof(T)); bool a=true,b=true;
        if(P[i].ci==0) a=false; else b=false;
        up(0,1,j) up(0,2,k){
            T[dp(j,k)]=(o.dt[0][dp(j,(k+2-j)%3)]*a+o.dt[0][dp(!j,k)]*b)%MOD;
        }
        up(0,5,j) o.dt[0][j]=T[j];
        lst=P[i].pi;
    }
    if(lst!=n) o=o*pwr(oo,n-lst);
    printf("%d\n",(o.dt[0][dp(0,1)]+o.dt[0][dp(0,2)])%MOD);
    return 0;
}
```

---

## 作者：JackMerryYoung (赞：1)

# 前言

计数类 DP, 难度较大。

对于 Subtask #1, 我们只需要暴力判断即可。

对于 Subtask #3 ($M = 0$), OEIS 上的通项公式提供了异于囧仙的做法，不过这里不再阐述。

# 正文

既然是个计数类 DP, 我们考虑设计状态。

看起来不太好设计啊，找找性质？

我们发现：无论如何，阴点数目都是偶数。

**证明：阴点一开始有 $0$ 个。**

若在两异色点间加阳点，相当于互换颜色，数目不变。

若在两同色点间加阳点，阴点数目要么加上 $2$, 要么减去 $2$.

所以无论进行什么操作，阴点的数目都只会加上 $2$, 减去 $2$, 或者不变。

于是阴点数目一直都是偶数。

那么考虑到这一个特殊性质，设阴点数目为 $q$. 这些阴点将这个圆划分为 $q$ 段。将每一段都染上色，每段颜色显然不同。

令某一段的颜色为 $R$, 与 $R$ 段相邻的段颜色为 $B$. 给予 $R$ 上的阳点一个权值 $1$, $B$ 上的阳点一个权值 $-1$. 

令所有阳点的权值为 $S$. 下面看每种操作对于 $S$ 的影响。

## 1. 在两同色点间加阳点

### 1.1 在两阳色点间加阳点

两阳点变成两阳点，这一段颜色变了，消失两个阳点，多了一个阳点，贡献的符号与消失两个阳点产生的贡献符号一样，所以权值加上 $\pm 3$.

### 1.2 在两阴色点间加阳点

两阴点变成两阳点，这一段颜色不变，所以权值加上 $\pm 3$.

## 2. 在两异色点间加阳点

两点颜色互换。设此段阳点的权值为 $a \in \{1, -1\}$。

互换后贡献中一个阳点权值符号改了，在此基础上又加了一个阳点。

所以权值减去 $3a$.

---

（注：删点与加点效果几乎一样，不讨论了。）

由此可得 $S$ 的变化量都为 $3$ 的倍数。一开始 $S$ 为 $\pm 2$. 

所以易知：

$$
S \not \equiv 0 \pmod{ 3}
$$

---

那么证明了辣么多，有啥用？

我们可以证明，若某一状态满足上述两个条件，那么都可以从初始状态转移过来。

首先，我们可以把黑点删光，白点删得只剩下 $2$ 个。这是一定能做到的。

我们知道删点是加点的逆操作，于是：任何满足上述两个条件的状态一定可以从初始状态转移过来。

终于可以写方程了。设 $f_{i, j, k}$ 为考虑到前 $i$ 个点时，符合阴点个数为 $j$, $S \bmod 3 = k$ 的方案总数，则有：

$$
f_{i, j, k} = 

\begin{cases}

f_{i - 1, 0, (k + 2) \bmod 3} + f_{i - 1, 1, k} \quad (j = 0) \\

f_{i - 1, 1, (k + 1) \bmod 3} + f_{i - 1, 0, k} \quad (j = 1)

\end{cases}
$$

不过我们没考虑第一个点是什么的问题。~~（边界还敢忘记啊）~~

观察一下，发现第一个点在 $R$ 还是 $B$ 好像关系不大。

于是指定第一个点在 $R$ 上，考虑第一个点的限定条件。
 
若限定了第一个点是阳点, $f_{1, 0, 1} = 1, f_{1, 1, 0} = 0$.

若限定了第一个点是阴点, $f_{1, 0, 1} = 0, f_{1, 1, 0} = 1$.

若未限定第一个点, $f_{1, 0, 1} = f_{1, 1, 0} = 1$.

答案：

$$
f_{N, 0, 1} + f_{N, 0, 2}
$$

记得将不符合的情况舍去。

---

写完发现过不了，发现：

$$
N \le 10^{18}, M \le 5×10^3
$$

好的直接矩阵快速幂加速。

DP 柿子里只跟前一行有关，把 $i$ 压掉。

设计矩阵：

$$

\left [

\begin{matrix}

&0 &1 &0 &1 &0 &0& \\

&0 &0 &1 &0 &1 &0& \\ 

&1 &0 &0 &0 &0 &1& \\

&1 &0 &0 &0 &0 &1& \\ 

&0 &1 &0 &1 &0 &0& \\

&0 &0 &1 &0 &1 &0& \\ 

\end{matrix}

\right ]

$$

不过直接用 DP 柿子推也可以。

初始矩阵要考虑第一个点的限定条件：

$$

\left [

\begin{matrix}

&0 &c1 &0 &c2 &0 &0&

\end{matrix}

\right ]

$$

若限定了第一个点是阳点，那么 $a = 1, b = 0$.

若限定了第一个点是阴点，那么 $a = 0, b = 1$.

复杂度 $\mathcal{O}(M \log_2 \dfrac{N}{M})$, 再乘上 $6^3$, 大概率能过。

# 代码

``` cpp
// Problem: P6734 「Wdsr-2」阴阳玉
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P6734
// Memory Limit: 128 MB
// Time Limit: 1000 ms

#include <bits/stdc++.h>
#define MOD ((long long) (998244353))
long long pos(long long x, long long y) { return x * 3ll + y; }
using namespace std;

long long N, M;
 
struct Matrix {
	long long mat[15][15];
	long long row, col;
	Matrix(long long __row, long long __col);
};

Matrix::Matrix(long long __row, long long __col)
{
	this->row = __row;
	this->col = __col;
	memset(this->mat, 0, sizeof(this->mat));
}

Matrix operator *(Matrix a, Matrix b)
{
	Matrix c(a.row, b.col);
	for(long long k = 0; k < b.col; ++ k)
	{
		for(long long i = 0; i < a.row; ++ i)
		{
			for(long long j = 0; j < a.col; ++ j)
			{
				c.mat[i][j] = c.mat[i][j] + a.mat[i][k] * b.mat[k][j];
				c.mat[i][j] %= MOD;
			}
		}
	}
	
	return c;
}

struct Rule {
	long long p;
	bool c;
} rule[5005];

bool operator <(Rule a, Rule b)
{
	return a.p < b.p;
}

Matrix fastpow(Matrix a, long long x)
{
	Matrix res = a, tmp = a;
	-- x;
	while(x)
	{
		if(x & 1)
			res = res * tmp;
			
		tmp = tmp * tmp;
		x >>= 1;
	}
	
	return res;
}

Matrix base(6, 6), f(1, 6);

signed main()
{
	for(long long i = 0; i <= 1; ++ i)
		for(long long j = 0; j <= 2; ++ j)
			base.mat[(pos(!i, j))][pos(i, j)] = base.mat[(pos(i, (j + 2 - i) % 3))][pos(i, j)] = 1;
			
	cin >> N >> M;
	for(long long i = 1; i <= M; ++ i)
		cin >> rule[i].p >> rule[i].c;
		
	sort(rule + 1, rule + M + 1);
	if(rule[1].p == 1) //Just the first
	{
		if(rule[1].c == 0) f.mat[0][pos(1, 0)] = 1;
		else               f.mat[0][pos(0, 1)] = 1;
	}
	else // Not the first
		f.mat[0][pos(1, 0)] = f.mat[0][pos(0, 1)] = 1;
	
	long long pre = 1; // Start from the first
	for(long long i = 1; i <= M; ++ i)
	{
		if(rule[i].p == 1) continue;
		if(pre < rule[i].p - 1) // In
			f = f * fastpow(base, rule[i].p - 1 - pre);
			
		long long tf[15];
		memset(tf, 0, sizeof(tf));
		bool a, b;
		a = b = true;
		if(rule[i].c == 0) a = false;
		else b = false;
		for(long long j = 0; j <= 1; ++ j)
			for(long long k = 0; k <= 2; ++ k)
				tf[pos(j, k)] = (a * f.mat[0][pos(j, (k + 2 - j) % 3)] + b * f.mat[0][pos(!j, k)]) % MOD;
				
		for(long long j = 0; j <= 5; ++ j)
			f.mat[0][j] = tf[j]; 
			
		pre = rule[i].p;
	}
	
	if(pre != N) // Force!!!
		f = f * fastpow(base, N - pre);
		
	cout << (f.mat[0][pos(0, 1)] + f.mat[0][pos(0, 2)]) % MOD << endl;
	return 0;
}
```

# 后言

这题思维难度雀食比较大，希望读者好好消化。

---


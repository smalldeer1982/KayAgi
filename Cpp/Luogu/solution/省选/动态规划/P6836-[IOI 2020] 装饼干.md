# [IOI 2020] 装饼干

## 题目描述

Khong 阿姨在组织一场有 $x$ 位选手参加的竞赛，她打算给每位选手一 **袋饼干**。总共有 $k$ 种不同类型的饼干，编号为从 $0$ 到 $k-1$。类型为 $i(0 \le i \le k-1)$ 的每块饼干都有一个 **口味值** $2^i$。在 Khong 阿姨的食品储藏室里，有 $a[i]$（有可能为 $0$）块类型为 $i$ 的饼干。

对每种类型的饼干，Khong 阿姨在每个袋子都会装上 $0$ 或者多块。所有袋子里面类型为 $i$ 的饼干的总块数不能超过 $a[i]$。一个袋子里面所有饼干的口味值的总和，被称为这袋饼干的 **总口味值**。

请帮 Khong 阿姨算一下，究竟存在多少不同的 $y$ 值，使得她可以装出 $x$ 袋饼干，而且每袋饼干的总口味值都等于 $y$。

#### 实现细节

你需要实现下面的这个函数：

```cpp
int64 count_tastiness(int64 x, int64[] a)
```

- $x$：需要装的饼干袋的数量。
- $a$：长度为 $k$ 的数组。对 $0 \le i \le k-1$，$a[i]$ 表示在食物储藏室里类型为 $i$ 的饼干数量。
- 此函数应当返回不同 $y$ 值的数目，使得阿姨可以装出 $x$ 袋饼干，且每袋饼干的总口味值都为 $y$。
- 此函数会被调用 $q$ 次 (对于允许的 $q$ 值，详见约束条件和子任务部分)。每次调用应当被看成是独立的场景。

## 说明/提示

#### 样例说明

#### 例 1

考虑如下调用：

```cpp
count_tastiness(3, [5, 2, 1])
```

这意味着阿姨打算装 $3$ 袋饼干，而在食物储藏室里总共有 $3$ 种类型的饼干：

- $5$ 块类型为 $0$ 的饼干，每块的口味值为 $1$，
- $2$ 块类型为 $1$ 的饼干，每块的口味值为 $2$，
- $1$ 块类型为 $2$ 的饼干，其口味值为 $4$。

$y$ 能够取的值为 $[0,1,2,3,4]$。举例来说，为了装出总口味值均为 $3$ 的 $3$ 袋饼干，阿姨可以这样装：

- 一袋饼干里有 $3$ 块类型为 $0$ 的饼干，以及
- 两袋饼干，其中各有一块类型为 $0$ 的饼干和一块类型为 $1$ 的饼干。

由于总共有 $5$ 个可能的 $y$ 值，函数应当返回 $5$。

![](https://cdn.luogu.com.cn/upload/image_hosting/db3xoxfy.png)

#### 例 2

考虑如下调用：

```cpp
count_tastiness(2, [2, 1, 2])
```

这意味着阿姨打算装 $2$ 袋饼干，而在食物储藏室里总共有 $3$ 种类型的饼干：

- $2$ 块类型为 $0$ 的饼干，每块的口味值为 $1$，
- $1$ 块类型为 $1$ 的饼干，其口味值为 $2$，
- $2$ 块类型为 $2$ 的饼干，每块的口味值为 $4$。

$y$ 能够取的值为 $[0,1,2,4,5,6]$。由于总共有 $6$ 个可能的 $y$ 值，函数应当返回 $6$。

#### 约束条件

- $1 \le k \le 60$
- $1 \le q \le 1000$
- $1 \le x \le 10^{18}$
- $0 \le a[i] \le 10^{18}$（对于所有的 $0 \le i \le k-1$）
- 对于 `count_tastiness` 的每次调用，食物储藏室里所有饼干的口味值总和都不会超过 $10^{18}$。

#### 子任务

1. (9 分) $q \le 10$，且对于 `count_tastiness` 的每次调用，食物储藏室里所有饼干的口味值总和都不会超过 $10^5$。
2. (12 分) $x=1,q \le 10$
3. (21 分) $x \le 10^4,q \le 10$
4. (35 分) 对于 `count_tastiness` 的每次调用，正确的返回结果都不会超过 $2 \times 10^5$。
5. (23 分) 没有附加限制条件。

#### 评测程序示例

评测程序示例将读取如下格式的输入数据。第一行包含一个整数 $q$。接下来是 $q$ 对这样的两行：它们按照下面的格式来描述一个单独的场景：

第 $1$ ⾏：$k\ x$       
第 $2$ ⾏：$a[0]\ a[1]\ \ldots\ a[k-1]$

评测程序示例的输出结果的格式如下：

第 $i$ 行 ($1 \le i \le q$)：`count_tastiness` 对于输入数据中第 $i$ 个场景的返回值。

# 题解

## 作者：lnzwz (赞：4)

这题我的方法比较奇怪。



题意：

有$k$种物品，第$i$个物品有$a_i$个，权值为$2^i$。

求有多少个$y$，使得可以选出$x$组物品，每组的和都为$y$。



先考虑如何判定一个$y$是否可行：

从最高位开始，依次求出第i位需要的数目$b_i$。若$y$的第$i$位为1，则$b\leftarrow b+x$。

如果$b_i \leq a_i$，那么说明$a_i$够用，进入下一位。

如果$b_i>a_i$，则选上所有$a_i$后，还剩$b_i-a_i$个。那么这些$2^i$只能用两倍的$2^{i-1}$来凑。因此把$b_{i-1}$加上$2 \times (b_i-a_i)$。



这样，只要$b_0<a_0$，则说明这个$y$可行。

可以发现，若$b_i \leq a_i$，那么对于所有$j<i$，$j$不会受之前的影响。

因此，可以把$b_i \leq a_i$作为分界点，进行DP。



设$dp_i$表示使得$b_i \leq a_i$的方案数目。只考虑大于等于$i$的位。那么，$dp_0$就是答案。

枚举$j>i$作为前一个分界点。那么，对于所有$i<c<j$，都要求$b_c>a_c$。

再枚举所有的$c$，那么$b_c$就可以很容易地用这个$y$在$[c,j-1]$这些数位上的值来表示。

于是，对于每个$c$，可以得出一条不等式。把这些不等式联立，就能得到$y$在$[i,j)$这些数位上的范围$d_{i,j}$。

因此，$dp_i\leftarrow dp_i+d_{i,j}\times dp_j$。



这样做的复杂度是$O(k^3q)$的，可以过。

代码：

```cpp
#include <stdio.h>
#include <vector>
#include "biscuits.h"
using namespace std;
#define ll long long
ll dp[70];
ll count_tastiness(ll x, vector<ll> sz) {
    int k = sz.size();
    for (int i = 0; i < 62 - k; i++) sz.push_back(0);
    k = 62;
    for (int i = k; i >= 0; i--) {
        if (i == k) {
            dp[i] = 1;
            continue;
        }
        dp[i] = 0;
        for (int j = i + 1; j <= k; j++) {
            ll zx = 0, zd = (1ll << (j - i)) - 1, h = 0;
            for (int a = j - 1; a >= i; a--) {
                h = h * 2 + sz[a];
                ll z = (h / x + 1) << (a - i);
                if (a > i) {
                    if (z > zx)
                        zx = z;
                } else {
                    if (z - 1 < zd)
                        zd = z - 1;
                }
            }
            if (zx <= zd)
                dp[i] += dp[j] * (zd - zx + 1);
        }
    }
    return dp[0];
}
```

不难发现，求$d_{i,j}$的过程可以优化。提前预处理出$d_{i,j}$，就可以$O(k^2)$了。

```cpp
#include <stdio.h>
#include <vector>
#include "biscuits.h"
using namespace std;
#define ll long long
ll dp[70], zz[70][70], dd[70][70];
ll count_tastiness(ll x, vector<ll> sz) {
    int k = sz.size();
    for (int i = 0; i < 62 - k; i++) sz.push_back(0);
    for (int j = 1; j <= 62; j++) {
        ll zx = 0, h = 0;
        for (int a = j - 1; a >= 0; a--) {
            zz[a][j] = zx;
            h = h * 2 + sz[a];
            ll z = (h / x + 1) << a;
            if (z > zx)
                zx = z;
            dd[a][j] = z;
        }
    }
    for (int i = 62; i >= 0; i--) {
        if (i == 62) {
            dp[i] = 1;
            continue;
        }
        dp[i] = 0;
        for (int j = i + 1; j <= 62; j++) {
            ll zx = (zz[i][j] >> i), zd = (1ll << (j - i));
            if ((dd[i][j] >> i) < zd)
                zd = (dd[i][j] >> i);
            if (zx <= zd)
                dp[i] += dp[j] * (zd - zx);
        }
    }
    return dp[0];
}

```



---

## 作者：Graphcity (赞：3)

非常有创意的一道动态规划。

首先考虑 $x=1$ 的情况，判断一个 $y$ 怎样才能够合法。

我们按照低位到高位的顺序考虑。对于最低位 $y_0$，那么 $a$ 的最低位个数必须得要大于等于 $y_0$。对于倒数第二位 $y_1$，$a$ 要在填补完 $y_0$ 之后还能够填出来 $y_1$，也就是说 $2y_1+y_0\le 2a_1+a_0$。

以此类推，合法的 **充要条件** 就是 $\forall i\in [0,60)$，都得有 $\sum_{j\le i}2^jy_j\le \sum_{j\le i}2^ja_j$。

接下来我们加入 $x$​，此时合法的充要条件就是 $\forall i\in [0,60)$，都得有 $\sum_{j\le i}2^jy_j\le \dfrac{\sum_{j\le i}2^ja_j}{x}$。

我们发现右边是定值。那我们就要对左边计数。考虑动态规划，转移我们从高位推到低位，设 $f_{i,j}$ 表示考虑到第 $i$ 位，且 $y$ 的前 $i$ 位 $\le j$ 的合法 $y$ 个数。

首先预处理 $g_i=f_{i,s_i}$（$s_i$ 是之前我们预处理出的限制条件）。如果 $j\ge s_i$，那答案显然就是 $g_i$。

当 $y$ 的第 $i$ 位为 0 时，答案为 $f_{i-1,j}$。接下来我们讨论 $y$ 的第 $i$ 位取值为 1 的情况。

如果 $j\ge 2^{i+1}-1$，那么这一位就相当于没有限制，答案为 $g_{i-1}$。

否则，如果 $j\ge 2^i$，那我填了 1 之后还会对接下来一位有影响，答案为 $f_{i-1,j-2^i}$。

边界条件是 $f_{0,k}=\min(s_0,y,1)+1$。

我们发现这个转移非常厉害，它每一次只会递归到下一层的一个 $f$。那我们直接记忆化搜索就可以做到 $O(qk^2)$。

```cpp
#include<bits/stdc++.h>
#include "biscuits.h"
#define ll long long
#define For(i,a,b) for(int i=(a);i<=(b);++i)
#define Rof(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
const int Maxn=2e5;

ll f[64],cnt[64],sum[64];
ll F(ll id,ll y,int op=1)
{
    if(id==0) return min(min(sum[0],y),1ll)+1;
    if(op==1 && y>=sum[id]) return f[id];
    ll res=F(id-1,y);
    if(y>=(1ll<<id+1)-1) res+=f[id-1];
    else if(y>=(1ll<<id)) res+=F(id-1,y-(1ll<<id));
    return res;
}
ll Solve(ll x)
{
    For(i,0,59) sum[i]=cnt[i]*(1ll<<i);
    For(i,1,59) sum[i]+=sum[i-1];
    For(i,0,59) sum[i]/=x;
    For(i,0,59) f[i]=F(i,sum[i],0);
    return f[59];
}
ll count_tastiness(ll x,vector<ll> a)
{
    memset(f,0,sizeof(f)),memset(cnt,0,sizeof(cnt));
    for(int i=0;i<a.size();++i) cnt[i]=a[i];
    return Solve(x);
}
```



---


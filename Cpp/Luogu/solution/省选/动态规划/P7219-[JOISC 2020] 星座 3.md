# [JOISC 2020] 星座 3

## 题目背景

> 蓝蓝的天空银河里       
有只小白船      
船上有棵桂花树      
白兔在游玩      
桨儿桨儿看不见      
船上也没帆        
飘呀飘呀飘向西天      
渡过那条银河水       
走向云彩国         
走过那个云彩国      
再向哪儿去         
在那遥远的地方        
闪着金光         
晨星是灯塔          
照呀照得亮      
晨星是灯塔         
照呀照得亮 

**本题被卡空间的可以尝试使用 C++14 通过**

## 题目描述

JOI 君去拍照，拍了一张大小为 $N \times N$ 的图片，第 $i$ 列第 $j$ 行的格子称为格子 $(i,j)$。

图里有白色的小白船，黄色的星星（天知道为啥星星是黄色的），黑色的空格（天知道这空格是啥），第 $i$ 列自下往上数到第 $A_i$ 行的格子里都是小白船，另外有 $M$ 颗星星，第 $i$ 颗星星在格子 $(X_i,Y_i)$，除了小白船和星星，其他格子都是空格。

现在 JOI 君定义满足下面的一个矩阵为星座：

1. 不包含小白船
2. 至少包含 $2$ 颗星星

JOI 君已经看星座看了 114514 年了，他厌烦了，所以他要把图片中的一些星星涂黑变成黑色空格，涂黑第 $i$ 颗星星会让图片增加 $C_i$ 的不自然度。求不存在星座的最小不自然度。

## 说明/提示

#### 样例 1 解释

把第三颗星星涂黑即可。

#### 样例 2 解释

把第三颗和第四颗星星涂黑即可。

#### 子任务

|子任务|特殊性质|分数|
|:-:|:-:|:-:|
|$1$|$N,M \le 300$|$14$|
|$2$|$N,M \le 2000$|$21$|
|$3$|无|$65$|

对于 $100\%$ 的数据，$1 \le N,M \le 2 \times 10^5$，$1 \le A_i,X_i,Y_i \le N$，$1 \le C_i \le 10^9$，$A_{X_i}<Y_i$，没有相同位置的星星。

#### 说明

翻译自 [第１９回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/index.html) [Day3 A 星座3](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/day3/constellation3.pdf)。

## 样例 #1

### 输入

```
5
1 3 4 2 3
3
1 5 3
4 3 2
2 4 2```

### 输出

```
2```

## 样例 #2

### 输入

```
7
5 6 2 3 6 7 6
5
7 7 5
3 3 7
3 7 10
1 7 6
4 7 8```

### 输出

```
16```

## 样例 #3

### 输入

```
8
6 8 5 7 3 4 2 1
10
8 2 9
6 6 7
8 3 18
5 8 17
8 5 3
5 5 3
5 4 8
1 8 13
1 7 5
7 4 13```

### 输出

```
44```

# 题解

## 作者：awapwq233 (赞：27)

## P7219 [JOISC2020]星座3 题解


 [目前最优解(83ms),代码较短.](https://www.luogu.com.cn/record/60581349)

![](https://cdn.luogu.com.cn/upload/image_hosting/wyesg9as.png)
-------------

#### 从最底下的每一行看起。



如果碰到星星，那么将这颗星星 **“可能冲突”** 的  _**范围内**_ **的代价**和**删除自己的代价** 取 $\min$。

 完事。




------------



### 举个栗子：

假设我们已经知道了这颗星星的  **“可能冲突”** 的范围。


那么选谁删谁呢？ 显然是代价较小的星星（当前这一个 或 下面这一坨）

树状数组维护 **删掉这（一坨/一个）星星的代价** 即可。

那么 **可能冲突** 的范围怎么求呢？

用并查集维护 **当前这一行** 与之相连通的 $[l,r]$ 即可。


------------
### 帮助理解：

```cpp
for(int i = 1; i <= n; i++) //对于每一行：
{
    for (auto b : s[i]) //对于该行的每一个星星：
    {
        if ((v = qry(b.first)) >= b.second) //查询当前星星所能“看到”的范围
            ans += b.second; //删掉自己
        else 
        {
            ans += v; //删掉下面的一坨
            add(l.gef(b.first) + 1, b.second - v);
            add(r.gef(b.first), v - b.second);
            //更新代价，树状数组维护。
        }
    }
    for (auto x : h[i])
        l.fa[x] = x - 1, r.fa[x] = x + 1; //左连更左，右连更右，并查集维护范围。
}
```


------------
[ $AC$ $CODE$](https://www.luogu.com.cn/paste/o6t0jave)


---

## 作者：Saliеri (赞：15)

妙妙题。

___

首先先考虑一些最基本的性质：

我们考虑白色的部分对构成星座所产生的的影响。

可以发现，两颗星星能否构成星座只与他们之间的白色区域高度的 **区间最大值** 有关。

看到区间最大值就可以直接上笛卡尔树了。

我们对白色区域的高度建出大根笛卡尔树后，考虑关于计算答案的一堆事情：

- 在每一个点上保存什么信息？

- 如何合并笛卡尔树上左右子树的信息？

对于第一个问题：最少需要删去多少价值的星星不是很友好，所以我们换成最多能保存多大价值的星星。

只保存这个信息自然是不够的，考虑需要加个什么维度来**消后效性**。

接着会有一个比较明显的限制——在当前子树的最大值之上最多只能有一颗星星。

意思就是说，左右子树中**最高的星星的高度**会影响当前的决策。

那么每一个位置的状态就可以设为：$f_{u,h}$ 表示 $u$ 的子树内最高的星星高度为 $h$，最多能保留的星星的价值。

接下来考虑第二个问题：如何合并。现在设当前节点为 $p$，这个节点的白色区域高度为 $v$，正在合并的两个点为 $x,y$。

对于 $v$ 以上的部分，因为最多只能有一个点存在，并且中间有白色区域来隔断，所以一边比 v 高的部分都可以接受另一边小于等于 $v$ 的部分的贡献。

形式化地 ：$\begin{cases}valx = \max_{1\leq h \leq v}f_{x,h}\\valy = \max_{1\leq h \leq v}f_{y,h}\\
f_{p,h} \leftarrow \max(f_{x,h}+valy,f_{y,h}+valx) \quad v<h\leq n\end{cases}$

对于高度小于等于 $v$ 的位置，直接处理每个位置不是很方便。

但是观察上面的转移柿子：我们所关心的只是**前缀最大值**而已。

所以更低的位置的具体值不再需要被用到。所以只需要拿可能的最大值更新 $v$ 这一个位置即可。

换句话说：$f_{p,v} \leftarrow valx+valy$。

接下来考虑怎么去维护这么一个 DP。

区间加、区间 max、合并——**线段树合并**维护即可。

因为就是一个裸的线段树合并，所以总复杂度就是非常漂亮的 $O(n\log n)$。

___

可以感觉到这个做法还是非常无脑的，所以时空常数会比较大。

代码：

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
using std::max; 
typedef long long ll;
const int maxn = 2e5+5;
int n,m,a[maxn],tr[maxn][2],st[maxn],top;
struct pair{int x,y;pair(int X=0,int Y=0):x(X),y(Y){};};
std :: vector <pair> star[maxn];
int rt[maxn],ch[maxn<<6][2],tot;
ll maxx[maxn<<6],tag[maxn<<6],sumall;
void gtag(int x,ll v){if(x)tag[x] += v,maxx[x] += v;}
void psd(int x){if(tag[x])gtag(ch[x][0],tag[x]),gtag(ch[x][1],tag[x]),tag[x]=0;}
void ins(int &u,int l,int r,int p,ll v){
	if(!u)u = ++tot;maxx[u] = max(maxx[u],v);
	if(l == r)return ;
	int mid = l+r>>1;psd(u);
	p<=mid?ins(ch[u][0],l,mid,p,v):ins(ch[u][1],mid+1,r,p,v);
}
void mdf(int u,int l,int r,int x,int y,ll v){
	if(!u||l>y||r<x)return ;
	if(l>=x&&r<=y)return gtag(u,v);
	int mid = l+r>>1;psd(u);
	mdf(ch[u][0],l,mid,x,y,v),mdf(ch[u][1],mid+1,r,x,y,v),maxx[u]=max(maxx[ch[u][0]],maxx[ch[u][1]]);
}
ll query(int u,int l,int r,int x,int y){
	if(!u||l>y||r<x)return 0;
	if(l>=x&&r<=y)return maxx[u];
	int mid = l+r>>1;psd(u);
	return max(query(ch[u][0],l,mid,x,y),query(ch[u][1],mid+1,r,x,y));
}
int merge(int x,int y){
	if(!x||!y)return x+y;
	int now = ++tot;
	psd(x),psd(y);
	maxx[x] = max(maxx[x],maxx[y]);
	ch[x][0] = merge(ch[x][0],ch[y][0]),ch[x][1] = merge(ch[x][1],ch[y][1]);
	return x;
}
void Merge(int x,int y,int v){
	ll lef = query(rt[x],1,n,1,v),rig = query(rt[y],1,n,1,v);
	mdf(rt[x],1,n,v+1,n,rig),mdf(rt[y],1,n,v+1,n,lef);
	lef = query(rt[x],1,n,1,v),rig = query(rt[y],1,n,1,v);
	rt[x] = merge(rt[x],rt[y]),ins(rt[x],1,n,v,lef+rig);
}
void DFS(int u){
	for(int i=0;i<star[u].size();++i)
		ins(rt[u],1,n,star[u][i].x,star[u][i].y);
	if(tr[u][0])DFS(tr[u][0]),Merge(u,tr[u][0],a[u]);
	if(tr[u][1])DFS(tr[u][1]),Merge(u,tr[u][1],a[u]);
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)scanf("%d",&a[i]);
	for(int i=1;i<=n;++i){
		int k = top;
		while(top && a[st[top]]<a[i])--top;
		tr[i][0] = (k==top?0:st[top+1]),tr[st[top]][1] = i,st[++top] = i;
	}
	scanf("%d",&m);
	for(int i=1,x,y,c;i<=m;++i)scanf("%d %d %d",&x,&y,&c),star[x].push_back(pair(y,c)),sumall+=c;
	DFS(tr[0][1]),printf("%lld\n",sumall-maxx[rt[tr[0][1]]]);
	return 0;
}
```

---

## 作者：冷月葬T魂 (赞：14)

# 反悔贪心：在确保能反悔以贴合全局最优解的前提下，选择局部最优解

### （理论上来说，这种算法要建出费用流模型才能保证正确性，但是。。）

不好说，上例题：

[P7219 [JOISC2020] 星座 3](https://www.luogu.com.cn/problem/P7219)

首先发现每个 $y$ 坐标小的点会对其上方的一个矩形形成限制，就是不能同时存在点。我们对每个点记录它被限制的代价和。

具体来说，删除自己需要付出 $c_i$ 的代价，而保留自己，删除它下面的点需要付出 $w_i$ 的代价。

那么对于一个点 $u$ 来说，删除它下面的点的代价和是多少呢？注意删除一个点 $v$ 后，要付出 $c_v$ 的代价，但 $v$ 下面的点会因此而不用被删，于是总代价为 $c_v-w_v$。在这里，原来决策 $v$ 不被删，而现在 $v$ 改为被删，这就是反悔所在。

对每个点在树状数组上加上 $c_u-w_u$，扫到一个点时比较 $c_u$ 与 $\sum c_v-w_v$ 即可。

代码如下：

```cpp
#include <bits/stdc++.h>
#define For(i,a,b) for(int i=a;i<=b;i++)
#define Rev(i,a,b) for(int i=a;i>=b;i--)
#define Fin(file) freopen(file,"r",stdin)
#define Fout(file) freopen(file,"w",stdout)
using namespace std;

const int N=4e5+5;
typedef long long ll;

class FTree{
	int n; ll c[N];
	int lowbit(int x) { return x&(-x); }
public:
	void init(int n0) { n=n0; }
	void poke(int p,int x)
	{
		while(p<=n) { c[p]+=x; p+=lowbit(p); }
	}
	ll peek(int p)
	{
		ll res=0;
		while(p) { res+=c[p]; p-=lowbit(p); }
		return res;
	}
};

FTree T;

struct Point{
	int x,y,c,w;
	bool operator< (const Point& p) const
	{
		return y<p.y;
	}
};

Point pt[N];
int n,m;
pair<int,int> a[N];
set<int> st;

signed main()
{
	cin>>n;
	For(i,1,n) { cin>>a[i].first; a[i].second=i; }
	sort(a+1,a+1+n);
	
	cin>>m;
	For(i,1,m){
		cin>>pt[i].x>>pt[i].y>>pt[i].c; pt[i].w=0;
	}
	sort(pt+1,pt+1+m);
	
	For(i,1,n) st.insert(i);
	
	int pa=0;
	st.insert(0); st.insert(n+1);
	ll ans=0;
	
	T.init(n);
	
	For(i,1,m){
		while(pa<n&&a[pa+1].first<pt[i].y) st.erase(a[++pa].second);
		auto it=st.lower_bound(pt[i].x);
		int r=(*it)-1,l=(*(--it))+1;
		ll w=T.peek(pt[i].x),c=pt[i].c;
		if(c<w){
			ans+=c;
		}
		else{
			ans+=w;
			T.poke(l,c-w); T.poke(r+1,-(c-w));
		}
	}
	
	cout<<ans<<endl;
	
	cerr<<"Time = "<<1.0*clock()/CLOCKS_PER_SEC<<" s\n";
	return 0;
}

```

---

## 作者：mazihang2022 (赞：11)

首先“所有矩形”这种条件应该想到笛卡尔树。

建出来后就 DP 吧。后效性在于放的点太高，可能让后面放不了点，因此设 $f_{x,i}$ 表示 $x$ 这一列放的点最高为 $i$ 的时候的答案，$i=n+1$ 时表示不放。

为了方便改一些定义：$a_i$ 表示黑色区域的大小；计算能保留最大价值的点。

转移：

1. 第 $x$ 列要放：记 $ml=\max_{i=a_x+1}^{n+1}f_{ls,i}$，$mr$ 同理，则有：
   $$
   \begin{aligned}f_{x,y}\gets\max(f_{x,y},ml+mr+c)\end{aligned}
   $$

2. 第 $x$ 列不放：
   $$
   \begin{aligned}f_{x,i}\gets\max(f_{x,i},f_{ls,i}+\max_{j=\max(i,a_x+1)}^{n+1}f_{rs,j},f_{rs,i}+\max_{j=\max(i,a_x+1)}^{n+1}f_{ls,j})\end{aligned}
   $$

第一个转移方程执行次数不超过 $m$，直接做就好，关键是第二个方程。

分析一下可以知道转移方程可以直接修改成：
$$
\begin{aligned}f_{x,i}\gets\max(f_{x,i},f_{ls,i}+mr,f_{rs,i}+ml)\end{aligned}
$$
这样的话就可以线段树合并优化了，操作是全局加，单点取 $\max$，询问区间 $\max$，合并。

另一种思路是直接考虑一个点的影响范围（就是选了这个点之后哪些列不能选点）。在前一种方法中我们把这一部分压到了状态里面。

不难发现一个点的影响范围是一条祖先后代链，这样的话，我们反过来，把点挂在对应链的顶端，这样就只需要一维状态了，转移方程更简单了，优化也更简单。

---

## 作者：Creeper_l (赞：5)

会发现题目的坐标其实是平面直角坐标系。

我们按 $y$ 坐标从小到大考虑所有的星星，假设当前考虑到了星星 $i$。我们先计算出之前所有能够影响到 $i$ 的星星的代价和为 $cost$（可以用树状数组维护）。然后分类讨论。

若 $c_i \le cost$，那么肯定直接将 $i$ 直接涂黑，因为它更容易影响到后面的星星，并且删除它的代价更小。

若 $cost < c_i$，我们可以用一种类似于反悔贪心的思路。先假设把 $cost$ 全部涂黑，然后在树状数组中的 $[l,r]$ 区间加上 $c_i-cost$（$[l,r]$ 表示 $i$ 能影响到的区间），这样之后考虑星星 $j$ 的时候，如果需要涂黑星星 $i$，那么 $cost$ 中的一部分代价也会被加回去（但是不一定全部都加回去，因为 $cost$ 中的一些星星也会影响 $j$）。如果不需要涂黑 $i$，那么肯定也不会计算到 $[l,r]$ 的贡献。

然后就做完了，维护每颗星星的 $[l,r]$ 可以用并查集做。时间复杂度 $O(n \log n)$。

```
#include <bits/stdc++.h>
using namespace std;
#define int long long
typedef pair <int,int> pii;
const int MAXN = 2e5 + 10;
int n,a[MAXN],m,x[MAXN],y[MAXN],c[MAXN];
vector <pii> v[MAXN];
vector <int> f[MAXN];  
int tree[MAXN],ans = 0,fal[MAXN],far[MAXN];
inline int Lowbit(int x) {return x & -x;}
inline void Add(int x,int c) {for(;x <= n;x += Lowbit(x)) tree[x] += c;}
inline int Query(int x) {int r = 0;for(;x;x -= Lowbit(x)) r += tree[x];return r;}
inline int Findl(int x) {if(fal[x] == x) return x;return fal[x] = Findl(fal[x]);}
inline int Findr(int x) {if(far[x] == x) return x;return far[x] = Findr(far[x]);}
signed main() {
	cin >> n;
	for(int i = 1;i <= n;i++) cin >> a[i];
	for(int i = 0;i <= n + 1;i++) fal[i] = far[i] = i;
	for(int i = 1;i <= n;i++) f[a[i]].emplace_back(i); 
	cin >> m;
	for(int i = 1;i <= m;i++) 
		cin >> x[i] >> y[i] >> c[i],
		v[y[i]].emplace_back(make_pair(x[i],c[i]));
	for(int i = 1;i <= n;i++) {
		for(pii j : v[i]) {
			int cost = Query(j.first);
			if(j.second <= cost) ans += j.second;
			else ans += cost,
				Add(Findl(j.first) + 1,j.second - cost),
				Add(Findr(j.first),cost - j.second);
		}
		for(int j : f[i]) 
			fal[Findl(j)] = Findl(j - 1),
			far[Findr(j)] = Findr(j + 1);
	} cout << ans; return 0;
}
```

---

## 作者：_Cheems (赞：4)

牛波一题。算是对其它题解不清楚地方的补充吧。

如果让构成星座的两对点（下文称为非法点对）互相连边，那么实际上就是在求删去后不存在点相邻的最小花费方案（是最大权独立集的对称问题），考虑贪心。

然后依次考虑节点。记录 $val_i$ 表示让点 $i$ 删去的花费，那么对于点 $u$ 要么删自己：$a_u$、要么删相邻点：$\sum\limits_j val_j$。贪心地选择最小值即可。

然后如果删了一个点那么因为这个点而删掉的就不用删了，所以 $val_i=a_u-\sum\limits_j val_j$。这样达到了“反悔”的效果。

不过呢，直接这样做会导致过程中 $val_j$ 被改变（被删了就设为 $0$），产生的一连串时间花销不可接受。有没有不改变之前点的做法呢？

具体点：如果存在 $a$ 第一个加入，$a,b$ 相连，最后 $a,c$ 相连，并且 $a,b,c$ 不成环，就有可能产生这种情况。

然后发现这题的特殊性质：考虑 $A,B,C$ 三个星，满足 $A.y\le B.y\le C.y$，若 $A,B$ 非法，$A,C$ 非法，则 $B,C$ 一定非法。因为障碍物一连排出现，所以若有障碍挡住了 $B,C$ 矩阵就必定挡到 $A,B$、$A,C$ 其一。

结合前文，这也就意味着 $A,B,C$ 依次加入的话就不可能改变之前点了！所以我们将节点从下往上依次加入，进行贪心处理即可。

于是让新加入的 $val_i$ 直接向其相应非法点贡献，单点查、区间加，用树状数组实现。

最后还剩个小问题：怎么求出其相应非法点？显然构成区间，我们先看左区间，$A,B$ 非法需满足区间 $[A.x,B.x]$ 内 $h$ 最大值 $< \min(A.y,B.y)$。

又因为 $A.y\le B.y$，所以让区间一直拓展，需满足 $A.y>h_L$ 即可。由于 $A.y$ 增大 $L$ 不增，直接拿个并查集维护即可。$R$ 同理。
### 代码
有点抽象，看代码应该能懂。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define ll long long
const int N = 2e5 + 5;
int n, m, _h, x, y;
ll c, ans, k, t[N]; 
vector<int> h[N];
vector<pair<int, ll> > s[N];

struct DSU{
	int fa[N];
	inline void init() {for(int i = 1; i < N; ++i) fa[i] = i;}
	inline int find(int u) {return fa[u] == u ? u : fa[u] = find(fa[u]);}
}L, R;
inline void upd(int a, ll k) {for(; a < N; a += a & -a) t[a] += k;}
inline ll qry(int a) {ll res = 0; for(; a > 0; a -= a & -a) res += t[a]; return res;}
int main(){
	L.init(), R.init();
	cin >> n;
	for(int i = 1; i <= n; ++i) scanf("%d", &_h), h[_h].push_back(i);
	cin >> m;
	for(int i = 1; i <= m; ++i) scanf("%d%d%lld", &x, &y, &c), s[y].push_back({x, c});
	
	for(int i = 1; i <= n; ++i){
		for(auto star : s[i]){
			x = star.first, y = i, c = star.second, k = qry(x);
			if(c <= k) ans += c;
			else ans += k, upd(L.find(x) + 1, c - k), upd(R.find(x), k - c);
		}
		for(auto j : h[i]) L.fa[j] = j - 1, R.fa[j] = j + 1;
	} 
	
	cout << ans;
	return 0;
}
```

---

## 作者：xht (赞：4)

考虑从上往下选，则如果选择了一个星星，那下面就由一些星星不能选了。

建出笛卡尔树之后可以发现，笛卡尔树上面的每个节点都对应着一个极大矩形，而一棵星星所在的极大矩形，在笛卡尔树上正好是一条，从某个节点到其子树内某个叶子的路径。

因此对于一个笛卡尔树上的节点，其对应区间的上面最多只会有一颗星星。考虑树形 dp，设 $f_{i,j}$ 表示在横坐标为 $i$ 的节点对应区间的上面，星星的纵坐标为 $j$ 时的最大权值和。

直接 dp 状态数有 $\mathcal O(n^2)$ 个，但有效的状态只和星星数有关。

因此用 `map` 记录有效状态，转移时启发式合并即可，时间复杂度 $\mathcal O(n \log^2 n)$。

```cpp
const int N = 2e5 + 7;
int n, m, a[N], s[N], t, l[N], r[N], rt;
map<int, ll> f[N];
ll g[N], z[N], ans, sum;

inline void work(int x, int y) {
	while (f[x].size() && f[x].begin() -> fi <= y)
		g[x] = max(g[x], f[x].begin() -> se + z[x]), f[x].erase(f[x].begin());
}

inline int merge(int x, int y) {
	if (f[x].size() < f[y].size()) swap(x, y);
	z[x] += g[y], z[y] += g[x], g[x] += g[y];
	for (auto o : f[y]) f[x][o.fi] = max(f[x][o.fi], o.se + z[y] - z[x]);
	return x;
}

int dfs(int x) {
	int y = x;
	if (l[x]) l[x] = dfs(l[x]), work(l[x], a[x]), y = merge(y, l[x]);
	if (r[x]) r[x] = dfs(r[x]), work(r[x], a[x]), y = merge(y, r[x]);
	return y;
}

int main() {
	rd(n);
	for (int i = 1; i <= n; i++) {
		rd(a[i]);
		int k = t;
		while (k && a[s[k]] < a[i]) --k;
		if (k) r[s[k]] = i;
		if (k < t) l[i] = s[k+1];
		s[++k] = i, t = k;
	}
	rt = s[1];
	rd(m);
	for (int i = 1, x, y, z; i <= m; i++)
		rd(x), rd(y), rd(z), f[x][y] = z, sum += z;
	rt = dfs(rt), ans = g[rt];
	for (auto o : f[rt]) ans = max(ans, o.se + z[rt]);
	print(sum - ans);
	return 0;
}
```

---

## 作者：myee (赞：3)

### 思路

翻转一下问题，设处于同一个合法矩形内的点可以连边，容易发现就是求最大权独立集。

考虑自下往上扫描，记录当 $p$ 列格子**还可以在上面选择**时的当前已没有白船的区间的答案以及 $p$ 列**可能已经有被选择的元素**时当前已没有白船的区间的答案。

分别设为 $f_p$，$g_p$。

则当 $p$ 处增加一颗星时，我们更新

$$g_p\leftarrow\max\{g_p,f_p+c\}$$

当 $p$ 处无白船后，设新区间为 $[l,r]$，我们更新

$$\forall l\le i<p,f_i\leftarrow f_i+\max_{p<j\le r}g_j,g_i\leftarrow g_i+\max_{p<j\le r}g_j$$

$$f_p,g_p\leftarrow\max_{l\le j<p}g_j+\max_{p<j\le r}g_j$$

$$\forall p<i\le r,f_i\leftarrow f_i+\max_{l\le j<p}g_j,g_i\leftarrow g_i+\max_{l\le j<p}g_j$$

最后 $\sum c-\max g$ 即为答案。

对 $f$ 需要区间加、单点查询，对 $g$ 需要单点修改、区间加、区间查 $\max$。显然这些都可以线段树维护。

$n,m$ 同阶，复杂度 $O(n\log n)$。

### Code

因为一开始做复杂了所以 $f$ 也用了线段树维护，后来发现可以直接写一个 BIT 解决。

```cpp
namespace F
{
    const uint Lim=262144;
    ullt W[Lim<<1|1],Tag[Lim<<1|1];
    ullt find(uint l,uint r,uint u=1,uint n=Lim)
    {
        if(l>=r)return 0;
        if(!l&&r==n)return W[u];
        if(l<(n>>1))
            if(r<=(n>>1))return find(l,r,u<<1,n>>1)+Tag[u];
            else return std::max(find(l,n>>1,u<<1,n>>1),find(0,r-(n>>1),u<<1|1,n>>1))+Tag[u];
        else return find(l-(n>>1),r-(n>>1),u<<1|1,n>>1)+Tag[u];
    }
    voi add(uint l,uint r,ullt w,uint u=1,uint n=Lim)
    {
        if(l>=r)return;
        if(!l&&r==n){Tag[u]+=w,W[u]+=w;return;}
        if(l<(n>>1))
            if(r<=(n>>1))add(l,r,w,u<<1,n>>1);
            else add(l,n>>1,w,u<<1,n>>1),add(0,r-(n>>1),w,u<<1|1,n>>1);
        else add(l-(n>>1),r-(n>>1),w,u<<1|1,n>>1);
        W[u]=std::max(W[u<<1],W[u<<1|1])+Tag[u];
    }
};
namespace G
{
    const uint Lim=262144;
    ullt W[Lim<<1|1],Tag[Lim<<1|1];
    ullt find(uint l,uint r,uint u=1,uint n=Lim)
    {
        if(l>=r)return 0;
        if(!l&&r==n)return W[u];
        if(l<(n>>1))
            if(r<=(n>>1))return find(l,r,u<<1,n>>1)+Tag[u];
            else return std::max(find(l,n>>1,u<<1,n>>1),find(0,r-(n>>1),u<<1|1,n>>1))+Tag[u];
        else return find(l-(n>>1),r-(n>>1),u<<1|1,n>>1)+Tag[u];
    }
    voi add(uint l,uint r,ullt w,uint u=1,uint n=Lim)
    {
        if(l>=r)return;
        if(!l&&r==n){Tag[u]+=w,W[u]+=w;return;}
        if(l<(n>>1))
            if(r<=(n>>1))add(l,r,w,u<<1,n>>1);
            else add(l,n>>1,w,u<<1,n>>1),add(0,r-(n>>1),w,u<<1|1,n>>1);
        else add(l-(n>>1),r-(n>>1),w,u<<1|1,n>>1);
        W[u]=std::max(W[u<<1],W[u<<1|1])+Tag[u];
    }
    voi chg(uint p,ullt w,uint u=1,uint n=Lim)
    {
        _max(W[u],w);if(w<Tag[u]||n==1)return;
        w-=Tag[u];
        if(p<(n>>1))chg(p,w,u<<1,n>>1);else chg(p-(n>>1),w,u<<1|1,n>>1);
    }
}
std::vector<uint>A[200005];
std::vector<std::pair<uint,uint> >B[200005];
uint Pre[200005],Nxt[200005];bol S[200005];
uint pre(uint p)
{
    while(p!=Pre[p])p=Pre[p]=Pre[Pre[p]];
    return p;
}
uint nxt(uint p)
{
    while(p!=Nxt[p])p=Nxt[p]=Nxt[Nxt[p]];
    return p;
}
int main()
{
#ifdef MYEE
    freopen("QAQ.in","r",stdin);
    freopen("QAQ.out","w",stdout);
#endif
    uint n,m;ullt ans=0;
    scanf("%u",&n);for(uint i=0,v;i<n;i++)scanf("%u",&v),A[v-1].push_back(i),Pre[i]=Nxt[i]=i;
    scanf("%u",&m);while(m--){uint x,y,c;scanf("%u%u%u",&x,&y,&c),B[y-1].push_back({x-1,c}),ans+=c;}
    for(uint i=0;i<n;i++)
    {
        for(auto p:B[i])G::chg(p.first,p.second+F::find(p.first,p.first+1));
        for(auto p:A[i])
        {
            S[p]=true;
            if(p&&S[p-1])Pre[p]=p-1,Nxt[p-1]=p;
            if(p<n-1&&S[p+1])Nxt[p]=p+1,Pre[p+1]=p;
            uint l=pre(p),r=nxt(p);
            ullt w1=G::find(l,p),w2=G::find(p+1,r+1);
            F::add(l,p+1,w2),F::add(p,r+1,w1),G::add(l,p+1,w2),G::add(p,r+1,w1);
        }
    }
    ans-=G::find(0,n);
    printf("%llu\n",ans);
    return 0;
}
```


---

## 作者：GK0328 (赞：3)

### 线段树,dp

本题中的图具有极强的性质。

我们从一颗星星的控制范围入手来解决问题，容易发现，一颗星星向下的控制范围是许多矩形的叠合，而向上的控制范围是一个直到最顶上的一个矩形。

因此我们考虑线段树优化$dp$，使用扫描线从下往上扫，每次可以插入一条线段，需要从不包含该星星的位置转移而来。

我们考虑维护前缀$dp$值的$\max$和后缀$dp$值的$\max$，分别设这两棵线段树为$s1,s2$，每次对于一颗星星及其对应的线段$[L,R]$，我们在$s1$的$R$处插入，在$s2$的$L$处插入。

更新$dp$值时，设该星星的位置为$x$，先观察前缀$\max$，对于$R$之后的部分，注意到这张图的性质，既然这颗星星的控制范围为$[L,R]$，那么在它的下方的星星，它们的控制范围不可能穿过$R$，那么$R$之后的$dp$值实际上是可以劈成$[1,R]$和$(R,i]$两部分直接相加的，因此我们只需要算出$[1,R]$内增加的$dp$值，然后进行线段树区间加即可。考虑一下如果我们需要使用这颗星星，那么必然需要把区间$[1,R]$劈成$[1,x)$和$(x,R]$两段，$[1,x)$的$dp$值我们知道，但是$(x,R]$怎么办呢？

利用刚才的性质，由于不会有区间穿过$R$，那么$(x,R]$的答案不就是$\max dp_{(x,n]}-\max dp_{(R,n]}$吗？

于是我们得到了转移，维护后缀$\max$同理。

$Code:$

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define N 200005
#define ll long long
using namespace std;
int n,m,a[N];
struct node
{
    int x,y,c,L,R;
}p[N];
int r,q[N];
bool cmp1(const node &A,const node &B)
{
    return A.x<B.x;
}
bool cmp2(const node &A,const node &B)
{
    if (A.y!=B.y)
        return A.y<B.y;
    return A.x<B.x;
}
void calc1(int id)
{
    p[id].L=1;
    int L=1,R=r;
    while (L<=R)
    {
        int mid(L+R >> 1);
        if (a[q[mid]]>=p[id].y)
            p[id].L=q[mid]+1,L=mid+1; else
            R=mid-1;
    }
}
void calc2(int id)
{
    p[id].R=n;
    int L=1,R=r;
    while (L<=R)
    {
        int mid(L+R >> 1);
        if (a[q[mid]]>=p[id].y)
            p[id].R=q[mid]-1,L=mid+1; else
            R=mid-1;
    } 
}
ll ans;
void ckmax(ll &x,ll y)
{
    x=(x>y)?x:y;
}
struct pt
{
    ll Mx,Tag;
};
struct seg
{
    #define mx(p) tr[p].Mx
    #define tag(p) tr[p].Tag
    #define ls(p) (p << 1)
    #define rs(p) (p << 1 | 1)
    pt tr[N << 2];
    void update(int p)
    {
        mx(p)=max(mx(ls(p)),mx(rs(p)));
    }
    void push_tag(int p,ll z)
    {
        mx(p)+=z,tag(p)+=z;
    }
    void push_down(int p)
    {
        if (tag(p))
        {
            push_tag(ls(p),tag(p));
            push_tag(rs(p),tag(p));
            tag(p)=0;
        }
    }
    void modify(int p,int l,int r,int x,int y,ll z)
    {
        if (x>y)
            return;
        if (l==x && r==y)
        {
            push_tag(p,z);
            return;
        }
        push_down(p);
        int mid(l+r >> 1);
        if (y<=mid)
            modify(ls(p),l,mid,x,y,z); else
        if (x>mid)
            modify(rs(p),mid+1,r,x,y,z); else
            {
                modify(ls(p),l,mid,x,mid,z);
                modify(rs(p),mid+1,r,mid+1,y,z);
            }
        update(p);
    }
    ll calc(int p,int l,int r,int x,int y)
    {
        if (x>y)
            return 0;
        if (l==x && r==y)
            return mx(p);
        push_down(p);
        int mid(l+r >> 1);
        if (y<=mid)
            return calc(ls(p),l,mid,x,y); else
        if (x>mid)
            return calc(rs(p),mid+1,r,x,y); else
            return max(calc(ls(p),l,mid,x,mid),calc(rs(p),mid+1,r,mid+1,y));
    }
}s1,s2;
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;++i)
        scanf("%d",&a[i]);
    scanf("%d",&m);
    for (int i=1;i<=m;++i)
        scanf("%d%d%d",&p[i].x,&p[i].y,&p[i].c);
    sort(p+1,p+m+1,cmp1);
    int l=1;
    for (int i=1;i<=n;++i)
    {
        while (l<=m && p[l].x==i)
            calc1(l),++l;
        while (r && a[i]>=a[q[r]])
            --r;
        q[++r]=i;
    }
    r=0;
    l=m;
    for (int i=n;i;--i)
    {
        while (l && p[l].x==i)
            calc2(l),--l;
        while (r && a[i]>=a[q[r]])
            --r;
        q[++r]=i;
    }
    sort(p+1,p+m+1,cmp2);
    for (int i=1;i<=m;++i)
    {
        int x(p[i].x),y(p[i].y),c(p[i].c),L(p[i].L),R(p[i].R);
        ll lx(s1.calc(1,1,n,1,x-1)),rx(s2.calc(1,1,n,x+1,n));
        ll cx(s1.calc(1,1,n,1,R)),dx(s2.calc(1,1,n,L,n));
        ll ex(s2.calc(1,1,n,x+1,n)-s2.calc(1,1,n,R+1,n));
        ll fx(s1.calc(1,1,n,1,x-1)-s1.calc(1,1,n,1,L-1));
        if (cx<lx+c+ex)
            s1.modify(1,1,n,R,n,lx+c+ex-cx);
        if (dx<rx+c+fx)
            s2.modify(1,1,n,1,L,rx+c+fx-dx);
    }
    ans=s1.calc(1,1,n,1,n);
    ans=-ans;
    for (int i=1;i<=m;++i)
        ans+=p[i].c;
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：Cxny (赞：2)

比较直接的做法是笛卡尔树套线段树合并。但还有更简单的做法。

尝试贪心。先按行从小到大扫描。下文中的冲突均指**与下方星星**的冲突。

假设已经得出了前 $x-1$ 行的局部最优解，准备插入位于第 $x$ 行的一颗星星 $i$。

显然有两种决策。

- 不选。产生 $c_i$ 代价。
- 选。此时所有**已经选了但是会产生冲突**的星星不能选，产生若干代价。

最优决策一定在这两者之一，否则会与局部最优解的前提冲突。

考虑如何维护冲突。

对于星星 $i$，会与其产生冲突的星星 $j$（不妨设 $y_i<y_j,\ x_j<x_i$）满足
$$
\min_{k=y_i}^{y_j}h_k<x_j
$$
会**被 $j$ 影响**的 $i$ 落在一个区间内。可以用并查集维护**开区间**的左右端点。

对于冲突点点权和，需要支持区间加、单点查询，可以使用树状数组维护。

还有这应该不是反悔贪心……树状数组修改时减去一个值表示冲突点不再被选中，不是所谓的反悔。

---

## 作者：_sys (赞：2)

蛇皮。

建出大根笛卡尔树。每个点既可以表达一个 $h$，又可以表达 $h$ 向上的一块黑色区域。

容易发现，每颗星星能够和其他星星冲突的区域为树上的一条链。（即自身的位置到它竖直向下至所在横坐标的 $h$ 所包含的点）

于是我们的问题变为：有若干条祖先-儿子链，我们需要选出若干条使得两两交集为空，最大化权值。

考虑 dp。$f_u$ 表示选择的链完全包含在 $u$ 子树内的答案。则有：

$u$ 上的链不选：$f_u \leftarrow f_{\textrm{lson}_u}+f_{\textrm{rson}_u}$

$u$ 上的一条链 $(x, y)$：$f_u \leftarrow \sum f_{v}$，其中 $v$ 满足 $v \notin (x, y), \textrm{fa}_v \in (x, y)$。

树剖维护即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int Maxn = 200005;
int n, m, ct, dfn_cnt, l[Maxn], r[Maxn], top[Maxn], dfn[Maxn], siz[Maxn], down[Maxn], ord1[Maxn], ord2[Maxn], x[Maxn], y[Maxn], a[Maxn], fa[Maxn], son[Maxn][2];
vector <int> S[Maxn], Ve[Maxn];
long long tot, c[Maxn], f[Maxn], sum[Maxn];
bool heavy[Maxn];
struct line
{
	int lt, rt, id;
	bool operator < (const line &tmp) const
	{
		return make_pair(lt, rt) < make_pair(tmp.lt, tmp.rt);
	}
};
set <line> Se;
int lowbit(int x)
{
	return x & -x;
}
void add(int x, long long y)
{
	for (int i = x; i <= ct; i += lowbit(i))
		sum[i] += y;
}
long long ask(int x)
{
	long long res = 0;
	for (int i = x; i; i -= lowbit(i))
		res += sum[i];
	return res;
}
void dfs1(int u)
{
	fa[son[u][0]] = fa[son[u][1]] = u;
	siz[u] = 1;
	if (son[u][0]) dfs1(son[u][0]), siz[u] += siz[son[u][0]];
	if (son[u][1])
	{
		dfs1(son[u][1]), siz[u] += siz[son[u][1]];
		if (siz[son[u][1]] > siz[son[u][0]]) heavy[u] = true;
	}
}
void dfs2(int u, int tp)
{
	if (!u) return ;
	top[u] = tp;
	dfn[u] = ++dfn_cnt;
	dfs2(son[u][heavy[u]], tp);
	dfs2(son[u][heavy[u] ^ 1], son[u][heavy[u] ^ 1]);
}
long long work(int y, int x)
{
	long long res = f[son[x][0]] + f[son[x][1]];
	bool las = (son[fa[x]][1] == x);
	x = fa[x];
	while (fa[y] != x)
		if (top[x] == top[y])
			res += f[son[x][las ^ 1]] + ask(dfn[x] - 1) - ask(dfn[y] - 1), x = fa[y];
		else
		{
			res += f[son[x][las ^ 1]] + ask(dfn[x] - 1) - ask(dfn[top[x]] - 1);
			las = son[fa[top[x]]][1] == top[x];
			x = fa[top[x]];
		}
	return res;
}
void dfs3(int u)
{
	if (!u) return ;
	dfs3(son[u][0]), dfs3(son[u][1]);
	f[u] = f[son[u][0]] + f[son[u][1]];
	add(dfn[u], f[son[u][heavy[u] ^ 1]]);
	for (auto s : S[u])
		f[u] = max(f[u], work(u, down[s]) + c[s]);
}
int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
		scanf("%d", &a[i]), ord1[i] = i;
	scanf("%d", &m);
	for (int i = 1; i <= m; i++)
		scanf("%d%d%lld", &x[i], &y[i], &c[i]), ord2[i] = i, tot += c[i], Ve[x[i]].push_back(i);
	sort(ord1 + 1, ord1 + 1 + n, [](int i, int j){return a[i] < a[j];});
	sort(ord2 + 1, ord2 + 1 + m, [](int i, int j){return y[i] < y[j];});
	int pt = m;
	Se.insert((line){1, n, ++ct});
	l[1] = 1, r[1] = n;
	for (int i = n; i >= 1; i--)
	{
		while (pt && y[ord2[pt]] > a[ord1[i]])
		{
			int pos = (--Se.lower_bound((line){x[ord2[pt]], 0x3f3f3f3f, 0})) -> id;
			S[pos].push_back(ord2[pt]);
			pt--;
		}
		line now = *(--Se.lower_bound((line){ord1[i], 0x3f3f3f3f, 0}));
		Se.erase(now);
		for (auto u : Ve[ord1[i]])
			down[u] = now.id;
		if (now.lt != ord1[i])
		{
			son[now.id][0] = ++ct;
			Se.insert((line){l[ct] = now.lt, r[ct] = ord1[i] - 1, ct});
		}
		if (now.rt != ord1[i])
		{
			son[now.id][1] = ++ct;
			Se.insert((line){l[ct] = ord1[i] + 1, r[ct] = now.rt, ct});
		}
	}
	dfs1(1), dfs2(1, 1);
	dfs3(1);
	printf("%lld\n", tot - f[1]);
	return 0;
}
```

---

## 作者：Caiest_Oier (赞：1)

# [P7219](https://www.luogu.com.cn/problem/P7219)     

考虑怎么描述这个不存在星座的限制。我们对 $A_i$ 建出大根笛卡尔树，则发现，不存在星座，等价于每个 $A_i$ 子树内，最多存在一个星星的高度大于 $A_i$。      

到了这一步做法就很明显了，令 $dp_{i,j}$ 表示在 $i$ 子树内，选中的最高星星是 $j$ 的最大价值，合并 dp 相当于将一个 dp 的带限制（不高于 $A_i$）前缀最大值加到另一个 dp 上。于是写一个线段树合并就可以了。最后用总价值减去选中价值的最大值，就是支付代价最小值了。时间复杂度 $O(n\log V)$。     

代码：    

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,A[500003],x[500003],y[500003],c[500003],rtrt,ans;
vector<int>mlst[500003];
int ST[23][500003],lg[500003],fsp[503],fa[500003],lson[500003],rson[500003];
int QueryMin(int l,int r){
	if(A[ST[lg[r-l+1]][l]]<A[ST[lg[r-l+1]][r-fsp[lg[r-l+1]]+1]])return ST[lg[r-l+1]][r-fsp[lg[r-l+1]]+1];
	return ST[lg[r-l+1]][l];
}
void build_cartesian(int l,int r,int p,int mk){
	if(l>r)return;
	int rtwz=QueryMin(l,r);
	if(p==0)rtrt=rtwz;
	else{
		fa[rtwz]=p;
		if(mk==0)lson[p]=rtwz;
		else rson[p]=rtwz;
	}
	build_cartesian(l,rtwz-1,rtwz,0);
	build_cartesian(rtwz+1,r,rtwz,1);
	return;
}
struct SegT{
	int st;
	int ed;
	int num;
	int val;
	int lson;
	int rson;
	int lzmk;
}T[7000003];
int rt[500003],totT;
void pushup(int now){
	T[now].val=max(T[T[now].lson].val,T[T[now].rson].val);
	T[now].num=T[T[now].lson].num+T[T[now].rson].num;
	return;
}
void pushdown(int now){
	if(T[now].lson)T[T[now].lson].lzmk+=T[now].lzmk,T[T[now].lson].val+=T[now].lzmk;
	if(T[now].rson)T[T[now].rson].lzmk+=T[now].lzmk,T[T[now].rson].val+=T[now].lzmk;
	T[now].lzmk=0;
	return;
}
int build(int l,int r){
	T[++totT].st=l;
	T[totT].ed=r;
	T[totT].num=T[totT].val=T[totT].lson=T[totT].rson=T[totT].lzmk=0;
	return totT;
}
void modify(int now,int wz,int val){
	if(T[now].st==T[now].ed){
		T[now].val=max(T[now].val,val);
		T[now].num++;
		return;
	}
	pushdown(now);
	if(wz<=((T[now].st+T[now].ed)>>1)){
		if(!T[now].lson)T[now].lson=build(T[now].st,((T[now].st+T[now].ed)>>1));
		modify(T[now].lson,wz,val);
	}
	else{
		if(!T[now].rson)T[now].rson=build(((T[now].st+T[now].ed)>>1)+1,T[now].ed);
		modify(T[now].rson,wz,val);
	}
	pushup(now);
	return;
}
int Query(int now,int rgt){
	if(!now)return 0;
	if(T[now].ed<=rgt)return T[now].val;
	if(T[now].st>rgt)return 0;
	pushdown(now);
	return max(Query(T[now].lson,rgt),Query(T[now].rson,rgt));
}
int mxv1,mxv2,lmt;
int merge(int X,int Y){
	if((!X)&&(!Y))return 0;
	if((!X)){
		mxv2=max(mxv2,Query(Y,lmt));
		T[Y].lzmk+=mxv1;
		T[Y].val+=mxv1;
		return Y;
	}
	if((!Y)){
		mxv1=max(mxv1,Query(X,lmt));
		T[X].lzmk+=mxv2;
		T[X].val+=mxv2;
		return X;
	}
	if(T[X].st==T[X].ed){
		if(T[X].st<=lmt)mxv1=max(mxv1,T[X].val),mxv2=max(mxv2,T[Y].val);
		T[X].val=max(T[X].val+mxv2,T[Y].val+mxv1);
		return X;
	}
	pushdown(X);
	pushdown(Y);
	T[X].lson=merge(T[X].lson,T[Y].lson);
	T[X].rson=merge(T[X].rson,T[Y].rson);
	pushup(X);
	return X;
}
void dfs(int now){
	rt[now]=build(1,1000000000);
	for(auto i:mlst[now])modify(rt[now],y[i],c[i]);
	if(lson[now]){
		dfs(lson[now]);
		mxv1=mxv2=0;
		lmt=A[now];
		rt[now]=merge(rt[now],rt[lson[now]]);
	}
	if(rson[now]){
		dfs(rson[now]);
		mxv1=mxv2=0;
		lmt=A[now];
		rt[now]=merge(rt[now],rt[rson[now]]);
	}
	return;
}
signed main(){
	ios::sync_with_stdio(false);
	for(int i=0;i<=30;i++)fsp[i]=(1<<i);
	for(int i=2;i<=500000;i++)lg[i]=lg[i>>1]+1;
	cin>>n;
	for(int i=1;i<=n;i++)cin>>A[i];
	for(int i=1;i<=n;i++)ST[0][i]=i;
	for(int i=1;fsp[i]<=n;i++){
		for(int j=1;j+fsp[i]-1<=n;j++)if(A[ST[i-1][j]]<A[ST[i-1][j+fsp[i-1]]])ST[i][j]=ST[i-1][j+fsp[i-1]];else ST[i][j]=ST[i-1][j];
	}
	cin>>m;
	for(int i=1;i<=m;i++)cin>>x[i]>>y[i]>>c[i];
	for(int i=1;i<=m;i++)mlst[x[i]].emplace_back(i);
	build_cartesian(1,n,0,0);
	dfs(rtrt);
	for(int i=1;i<=m;i++)ans+=c[i];
	ans-=T[rt[rtrt]].val;
	cout<<ans;
	return 0;
}
```


---

## 作者：Felix72 (赞：0)

题解区里现在主要有小清新的贪心做法、以及重工业的线段树合并做法。我做这个题时没那么聪明所以没想出贪心，觉得线段树合并的转移式子太繁琐也没有考虑，最后得到了一个介于两者之间的做法：树状数组优化 dp。

首先原图的性质启发我们建树并树上 dp，于是我们按题意模拟建树（具体细节可参考代码），把空格分为若干个整块区域，构成一个类似笛卡尔树一样的东西。为什么是类似呢？相同之处是按照数值从大到小构建，不同之处是一个点可能有三个以上的子节点。

建树之后，还要考虑每颗星星在哪个节点（也就是上文提到的整块区域）里。这个也不难，用 bfs 对树拓扑排序，边排序边用 set 维护即可。

做完准备工作，考虑每颗星星对它所在的子树内部有什么影响。思考的结果是如果选了一个星星，那么与之同列的子节点里不再能选任何星星。我们自然地想到维护对于每一列，禁选该列所有节点区域后子树内的最大值（这样的话，这个值加上星星的值就是子树内可能的答案了）。

这个值是能维护的。对于一个点的一个儿子，它给除了它之外的区间范围都贡献了一个值，这个值就是其子树内部最优解（原因：禁选其他列并不影响该子树，因此直接取最优方案）。那么如何求最优解呢？一种可能是取所有子树的最优方案，另一种是选一颗星星、再去查询去掉一列的最优方案。

区间加法，使用树状数组。码量主要在建树和找星星位置上，核心部分较短。

```cpp
#include <bits/stdc++.h>
#define lowbit(x) (x & (-x))
using namespace std;

const int N = 200010;
typedef pair < int, int > PII;
int n, m, a[N], st[N][21];
inline void init()
{
	for(int i = 1; i <= n; ++i) st[i][0] = i;
	for(int i = 1; (1 << i) <= n; ++i)
	{
		for(int j = 1; j + (1 << i) - 1 <= n; ++j)
		{
			if(a[st[j][i - 1]] >= a[st[j + (1 << (i - 1))][i - 1]])
				st[j][i] = st[j][i - 1];
			else st[j][i] = st[j + (1 << (i - 1))][i - 1];
		}
	}
}
inline int RMQ(int l, int r)
{
	if(l > r) return -1;
	int k = log2(r - l + 1);
	if(a[st[l][k]] >= a[st[r - (1 << k) + 1][k]]) return st[l][k];
	else return st[r - (1 << k) + 1][k];
}
int h[N], cnt, lx[N], rx[N], ly[N], ry[N], idx = 1;
struct edge {int to, next;} e[N * 2];
inline void add(int x, int y)
{e[++cnt].to = y, e[cnt].next = h[x], h[x] = cnt;}
inline void build(int now, int l, int r, int d, int u) //使用st表建树 
{
	lx[now] = l, rx[now] = r, ly[now] = d, ry[now] = u;
	int maxn = a[RMQ(l, r)];
	vector < int > con; int id = RMQ(l, r);
	while(a[id] == maxn)
	{
		con.push_back(id);
		id = RMQ(id + 1, r);
	}
	int sz = con.size();
	if(l < con[0])
	{
		++idx; add(now, idx);
		build(idx, l, con[0] - 1, a[RMQ(l, con[0] - 1)] + 1, maxn);
	}
	for(int i = 0; i < sz - 1; ++i)
	{
		if(con[i] + 1 < con[i + 1])
		{
			++idx; add(now, idx);
			build(idx, con[i] + 1, con[i + 1] - 1, a[RMQ(con[i] + 1, con[i + 1] - 1)] + 1, maxn);
		}
	}
	if(con[sz - 1] < r)
	{
		++idx; add(now, idx);
		build(idx, con[sz - 1] + 1, r, a[RMQ(con[sz - 1] + 1, r)] + 1, maxn);
	}
}
vector < int > hve[N];
struct node
{
	int id, lx, rx, ly, ry;
	bool operator < (const node &w) const {return lx < w.lx;}
};
multiset < node > ds;
struct star {int x, y; long long val;} s[N];
inline bool cmpy(star u, star v) {return u.y > v.y;}

struct BIT //区修单查 
{
	long long c[N];
	inline void add(int pos, long long num)
	{
		for(int i = pos; i <= n; i += lowbit(i))
			c[i] += num;
	}
	inline void insert(int l, int r, long long num)
	{if(l > r) return ; add(l, num); add(r + 1, -num);}
	inline long long query(int pos)
	{
		long long ans = 0;
		for(int i = pos; i; i -= lowbit(i)) ans += c[i];
		return ans;
	}
}; BIT T;

long long f[N], sum;
inline void treedp(int now) //求解部分 
{
	for(int i = h[now]; i; i = e[i].next)
	{
		int to = e[i].to;
		treedp(to);
	}
	for(int i = h[now]; i; i = e[i].next)
	{
		int to = e[i].to;
		if(lx[now] <= lx[to] - 1) T.insert(lx[now], lx[to] - 1, f[to]);
		if(rx[to] + 1 <= rx[now]) T.insert(rx[to] + 1, rx[now], f[to]);
		f[now] += f[to]; //不取自己的星星，直接取子树最优解 
	}
	for(int i = 0; i < hve[now].size(); ++i)
	{
		int id = hve[now][i];
		f[now] = max(f[now], T.query(s[id].x) + s[id].val); //取一颗星星，看看此时的最优方案 
	}
}

int main()
{
//	freopen("text.in", "r", stdin);
//	freopen("prog.out", "w", stdout);
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> n;
	for(int i = 1; i <= n; ++i) cin >> a[i];
	init();
	idx = 1;
	build(1, 1, n, a[RMQ(1, n)] + 1, n + 1);
	cin >> m;
	for(int i = 1; i <= m; ++i) cin >> s[i].x >> s[i].y >> s[i].val, sum += s[i].val;
	sort(s + 1, s + m + 1, cmpy);
	ds.insert({1, lx[1], rx[1], ly[1], ry[1]});
	for(int i = 1; i <= m; ++i) //拓扑排序，寻找星星位置 
	{
		while(true)
		{
			auto p = ds.upper_bound((node){0, s[i].x, 0, 0, 0});
			p = prev(p); node cur = *p;
			if(!(cur.ly <= s[i].y && s[i].y <= cur.ry))
			{
				ds.erase(p);
				for(int j = h[cur.id]; j; j = e[j].next)
				{
					int to = e[j].to;
					ds.insert({to, lx[to], rx[to], ly[to], ry[to]});
				}
				continue;
			}
			hve[cur.id].push_back(i);
			break;
		}
	}
	treedp(1);
	cout << sum - f[1] << '\n';
	return 0;
}
/*

*/
```

---


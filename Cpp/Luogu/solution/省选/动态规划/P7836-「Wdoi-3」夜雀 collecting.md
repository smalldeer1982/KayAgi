# 「Wdoi-3」夜雀 collecting

## 题目背景

巧妇难为无米之炊。在制作菜品之前，米斯蒂娅必然要四处收集食材了。

然而幻想乡实在是太大，四处散落着各种各样的食材。米斯蒂娅的背包却非常有限，以至于四处采集时不得不考虑取舍的问题了。米斯蒂娅的时间非常有限，因为她必须要在夜晚摆摊之前准备好所有的食材。

于是她来向你求助，希望精通计算的你帮助她收集食材。

## 题目描述

米斯蒂娅有一个容量为 $v$ 的背包，而食材有 $x$ 种。当背包被塞满后，米斯蒂娅就不能够采集更多的食材了。

为了尽可能地收集到更多食材，又要节省更多时间，她会**依次**经过 $n$ 个采集点。每个采集点都会有一定量的食材可供采集。

具体来说，对于第 $i$ 个采集点，每种食材的个数分别为 $C_{i,1},C_{i,2}\cdots C_{i,x}$ ，其中 $C_{i,j}$ 代表该采集点有多少个第 $j$ 种食材。保证对于所有 $i$ ，都有 $\displaystyle C_{i,1}+C_{i,2}+\cdots+C_{i,x}=\sum_{j=1}^{x}C_{i,j} \leq v$ 。

每到一个采集点，米斯蒂娅都会决定是否开始采集食材。因为她非常享受采集新食材带来的愉悦感，一旦开始采集，她会将这个采集点的食材**全部采集完**。因此，如果此时她背包不足以塞下这里所有的食物，她将**不能进行**采集。尽管如此，米斯蒂娅也可以选择在采集前丢弃背包里的一些食材。

不同的食材在烹饪中的泛用性是不同的，一些食材会经常使用，而一些食材则只会出现于少数菜品。因此，每种食材在米斯蒂亚心中有着不同的价值，第 $i$ 种的价值为 $A_i$。

为了菜品的多样性，米斯蒂娅会尽可能采集更多种类的食材。于是她想知道，在经过了这 $n$ 个采集点后，她的背包中至少有 $1$ 个的食材的价值和最大是多少（也就是说，如果一种食材有多个，那么只计算一次）。

## 说明/提示

#### 样例 1 解释

在第一个和第三个采集点收集食材。要注意的是，在采集第三个采集点前，丢弃一个第一种食材。最终，四个食材的数量分别是 $\{1,1,0,1\}$，于是获得的价值和为 $7+11+11=29$。可以证明，没有更优的方案。

---

#### 数据范围及约定

$$
\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & \bm x & \bm n & \textbf{分值}\cr \hline
1 & 1\le x \le 10 & 1\le n\le 2\times 10^3 & 20 \cr\hline
2 & 1\le x \le 14 & 1\le n\le 10^6 & 40 \cr\hline
3 & 1\le x \le 18 & 1\le n\le 1000 & 40 \cr\hline
\end{array}
$$

对于 $100\%$ 的数据，有 $1 \le n \le 10^6$，$1 \le x \le 18$，$1 \le v \le 2000$，$0 \le C_{i,j}$，$\sum_{j=1}^x C_{i,j} \le v$，$0 \le A_i \le 1000$。

Subtask 4 为不计分的 Hack 数据， 保证满足 Subtask 2 或 Subtask 3 的限制。

特别感谢 chenxinyang2006 对本题解法的巨大贡献。

## 样例 #1

### 输入

```
5 3 4
7 11 7 11 
1 0 0 1 
2 1 0 0 
1 1 0 0 
1 0 2 0 
1 0 0 2 
```

### 输出

```
29
```

# 题解

## 作者：幽云蓝 (赞：2)

这里是八云蓝&cxy的官方题解~

注：按位与用 $|$ 表示，按位或用 $\&$ 表示，按位异或用 $\oplus$ 表示。

$\textbf{Subtask1}$

一档不简单但是很套路的部分分。首先我们应该发掘一些信息&性质：

1. 如果拥有 $\ge1$ 个某种食材，那么将其丢弃到只剩一个肯定更优。

2. $x$ 很小，所以我们可以存下 $2^x$ 级别的信息。

我们可以用一个二进制位来表示出有/无某种食材，那么根据性质 $2$，容易想到用一个 $x$ 位的二进制数来表示出一个状态，代表拥有哪些食材。根据性质 $1$，可以想到这样的一个二进制数能表示出某次采集之后背包里装了哪些食材。那么记状态 $f_{i,j}$ 为第 $i$ 次采集后是否能够达到食材状态 $j$，能达到就是 $1$，否则为 $0$。每一次采集也可以压缩成两个数 $w_i$ 和 $q_i$，其中 $w_i$ 代表这次采集到的食材数量，$q_i$ 代表可以采集到的食材状态。得到如下转移：

如果有 $f_{i,j}=1$，并且令 $g(x)$ 为 $x$ 在二进制下 $1$ 的个数，那么如果有 $g(j)+w_{i+1}\le v$，那么有 $f_{i+1,j|q_{i+1}}=1$。并且如果有 $f_{i,j}=1$，那么有 $f_{i+1,j}=1$。

在转移结束后，考虑用高维前缀和来模拟丢弃食材的过程。具体来说，记当前转移到第 $i$ 次采集，那么就从大到小枚举 $x$ 位二进制数 $j$，对于 $f_{i,j}$，如果存在 $2^k$ 满足 $f_{i,j|2^k}=1$，那么有 $f_{i,j}=1$。

最后将所有满足 $f_{n,j}=1$ 的 $j$ 计算其对应价值即可。

$\textbf{Subtask2}$

注：该部分 written by chenxinyang2006

首先我们可以观察到，对于任意 $S$，$dp_S$ 必然在某次采集前一直为 $0$，而某次采集后一直为 $1$ 。我们如果要从这个状态进行丢弃，必然只有在它由 $0$ 变为 $1$ 的状态的丢弃是有意义的，于是我们可以用枚举子集换掉高维前缀和。

接下来我们考虑优化收集食材的过程，如果我们能够快速地找到每次的有效转移 $S$ ，一共的转移次数是 $2^x$ 级别的。

这个部分存在三个限制
1. $dp_S=1$ 。
2. $g(S) +w \le v$ 。
3. $dp_{S \mid q} = 0$ 。

实际上第二个限制是最好处理的，我们可以开 $x$ 个桶，把 $S$ 状态存在第 $g(S)$ 个桶里面，每次我们只考虑前 $\min(v - w,x)$ 个桶的 $S$ 进行的转移。

接下来考虑一三限制，这部分似乎比较麻烦，但我们考虑到本题的一个性质：如果 $S$ 可行，那么 $S$ 的任意子集都可行。

那么我们考虑对于有效转移 $S$，去掉同时在 $S$ 和 $q$ 中存在的位，得到一个新的状态 $S'$ ，容易发现 $S'$ 必然仍满足三个限制，且能转移到相同的位置。

于是我们可以改写一三限制为：

1. $dp_S=1$。
2. $S \operatorname{and} q = 0$。
3. $dp_{S+q} = 1$。

看似多了一条限制，但我们发现，对于所有 $S$，我们再去枚举 $q$，这样所有 $q$ 数量的总和是 $3^x$ 级别的。

于是我们可以开一些 $\text{vector}$ ，第 $i$ 个 $\text{vector}$ 存储所有 $S$，满足 $dp_S=1$，$i\operatorname{and}S=0$。

然后我们对于前 $\min(v-w,x)$ 个桶中的每个桶，遍历 $\text{vector } q$，就可以找到可能可行的 $S$ 。

为什么说可能可行？因为我们并不保证 $dp_{i+S} = 0$。但在进行此次转移后，显然这个 $\text{vector}$ 中的所有转移都失效了（或者说，无法进行有效转移了），可以全都删去。于是复杂度均摊正确。

当 $dp_S$ 在此次收集食材中可行时，要维护那些 $\text{vector}$，包括 $S$ 是在丢掉食材时变得可行的情况。

$\textbf{Subtask3}$

发现上面出现了很多无用的转移。考虑维护一个数组 $f$，其中 $f_i$ 代表状态 $i$ 是否能得到，然后从第一次采集开始向后计算。显然 $f_i$ 具有单调性——也就是说，对于从第 $k$ 次采集转移到第 $k+1$ 次采集，我们只需要计算哪些 $f_i$ 会从 $0$ 变为 $1$。我们继续发掘性质：如果 $f_j$ 在一次转移中会从 $0$ 变为 $1$，那么其所有子集（子集即状态 $\alpha$ 满足 $\alpha\&j=j$ 且 $\alpha\neq j$）都一定在转移前为 $1$，或者在这次转移时会从 $0$ 变为 $1$。考虑一个类似于轮廓线的思路：维护所有状态 $j$ 满足：① $j$ 的所有子集 $\alpha$ 都满足 $f_{\alpha}=1$；② 所有以 $j$ 为子集的状态 $\alpha$ 都满足 $f_{\alpha}=0$。接下来称这些状态为关键状态。这些状态一定是最容易达到的，并且根据这些状态的性质（性质①），我们可以迅速的算出在一次转移中，某个关键状态 $j$ 是否会转移为 $f_j=1$。具体来说，我们有下面的转移：

若当前从第 $k$ 次采集转移到第 $k+1$ 次转移，并且有关键状态 $j$，那么如果有 $g(j\oplus (j\&q_{k+1}))+w_{k+1}\le v$，那么就有 $f_j=1$。

食材数量为 $k$ 时关键状态的最大值等于有 $k$ 种元素的没有包含关系的集合的个数最大值，这个值等于 $C(x,x/2)$（记 $C(A,B)$ 为从 $A$ 个带标号物品中选 $B$ 个的方案数），其中 $/$ 代表整除。上述算法的复杂度在只考虑转移的情况下即为 $O(2^xx+C(x,x/2)\times n)$。

考虑细节实现，首先枚举关键状态的时候最好按状态从小到大枚举，因为如果状态 $j$ 在转移中满足了 $f_j=1$，那么其可能导致一些新的状态加入关键状态集合。显然，加入的状态一定大于状态 $j$，这样枚举可以避免重复计算状态。并且，我们需要在某些时刻删除一些关键状态。那么我们就可以使用 `set` 来维护关键状态集合啦。因为 `set` 的遍历是 $O(size)$ 的，而插入是 $log$ 的，每个状态最多被插入删除一次，所以复杂度为 $O(2^x\times \log C(x,x/2)+C(x,x/2)\times n)$。

那如何计算哪些状态会被加入关键状态集合呢。考虑高维前缀和的套路，如果一个状态 $j$，其本身满足不在关键状态集合，并且在某次转移后有 $f_j=0$，且对于所有满足 $2^k\&j>0$ 的 $k$ 都满足 $f_{j\oplus 2^k}=1$，那么将其加入关键状态集合。可以通过对于每个集合维护满足上述条件的 $k$ 的数量来完成维护。

综上，我们以 $O(2^xx+C(x,x/2)\times n)$ 的复杂度解决了此题（$2^x\times \log C(x,x/2)$ 必然小于 $2^xx$）。经过计算，该复杂度为 $O(2^xx+\frac{2^x\times n}{\sqrt x})$。顺带一提，蓝已经构造数据将其卡到上界啦（但是还是跑的很快）。

其实该题还存在一种 $O(2^xx+2^x\times n)$ 的贪心做法。考虑枚举最终获得的食材集合，记这一目标集合为 $T$，然后从后往前考虑每次采集，那么对于当前枚举到的第 $i$ 次采集，如果我们进行了这次采集，在这次采集之前我们就必须采到集合 $T\oplus(T\&q_i)$（否则就不能达到目标集合了），那么能进行这次采集当且仅当 $g(T\oplus(T\&q_i))+w_i\leq v$。如果能进行这次采集，那么采集就相当于将原目标集合 $T$ 变成 $T\oplus(T\&q_i)$，容易发现进行采集一定优于不进行采集，于是贪心解决即可。完结撒花~

---

## 作者：harmis_yz (赞：0)

题解摘自[做题记录](https://www.luogu.com.cn/article/3frkfgyz)。

## 分析

数据范围明显得要让我们分开搞。

**【Sub2】**

应该是暴力。这里有个主体思路，我们完全可以贪心地将当前背包里的食材删掉，直到每种出现过的食材数量刚好为 $1$。因为我们保留更多的是没有用的。那么我们就可以用二进制数表示 $x$ 种食材的出现状态了。

同时，可能存在当前的一个状态 $s$，将 $s$ 与第 $i$ 个采集点结合时出现了背包装不下，单删掉 $s$ 中的几个 $1$ 后能够装下且更优。这启示我们，对于一个 $s$ 实际上是可能转移到其一个子集会更优。既然都能转到子集了，那么在第 $i$ 个采集点的时候，记 $t_i$ 为这个采集点每个食材的出现状态，我们就完全可以用一个与 $t_i$ 不交的状态 $s$ 来转移。

我们对于当前能够达到的所有状态 $s$ 去转移 $s'$。如果 $s'$ 已经被转移过了，那显然是没有必要再转移一次的。那么我们就能保证每个状态最多被转移 $1$ 次。同时，因为 $s$ 的所有子集也可以去转移，所以算上枚举子集的复杂度就是 $O(3^x)$ 的。

这里给个小优化：因为 $n$ 十分巨大，如果我们对于每个 $t_i$ 都去枚举它能达到的状态 $s'$，最坏是 $O(2^xn)$ 的，但是根据上一自然段的分析，得知对于相同的 $t_i$ 是没必要再去遍历一遍的，直接清空就行。具体操作的时候会发现，我们可能一个 $|s'|+V_i >v$ 了，在这个采集点是无法转移的，而可能会有后面的某个转移点可以转移，但是我们给它清空了。为了避免这种情况，我们可以存一下 $|s'|$。

**【Sub3】**

考虑到，对于一个状态 $s'$，如果它可以通过 $t_i$ 和 $s$ 得到，当且仅当 $s'$ 是 $t_i \cap s$ 的子集。根据 Sub2 分析的第二个自然段，可以进一步得到：当状态 $s'$ 能被转移到时，需要满足 $s'$ 的所有子集都能被转移到。那么我们拿一个 set 来记录所有合法的状态，如果一个状态可以得到，我们去推它的一个超集，动态插入所有从不合法变成合法的超集。那么之后任意时间，这个状态都没有用了，可以直接删掉。

现在考虑枚举超集。根据上述的条件，我们得知 $s'$ 合法的前提是其子集都合法，那么我们枚举超集的时候就只需要枚举所有 $|S|=|s'|+1$ 的 $s'$ 的超集，只要 $S$ 删掉任意一个 $1$ 得到的集合都合法，那么它就合法了。为什么不需要枚举 $|S|=|s'|+2$ 的超集？很显然，当 $|S'|=|s'|+1$ 且 $S'$ 是 $S$ 的子集时，如果 $S'$ 仍不合法，那么 $S$ 显然不合法。如果 $S'$ 合法，那么 $S$ 将在枚举 $S'$ 的超集时被枚举到。所以这样就是对的。

因为这样我们保证了对于任意时刻，不存在 set 中的两个状态 $a,b$，有 $a$ 是 $b$ 的子集。所以 set 中最多 $x$ 个状态。额，分析不来了。复杂度未知，应该不是很大。

## 代码

```cpp
il void add(int s){
	if(vis[s]) return ;
	vis[s]=1;
	int ans_=0,cnt=0;
	for(re int i=1;i<=x;++i) ans_+=val[i]*((s>>(i-1))&1),cnt+=((s>>(i-1))&1);
	ans=max(ans,ans_);
	int s_=T;
	for(;s_> 0;--s_){
		s_&=(T^s);
		vec[s_][cnt].push_back(s|s_);
	}
	s_=s;
	for(;s_> 0;--s_){
		s_&=s;
		add(s_);
	}
	return ;
}
il void add_(int s){
	f[s]=1;
	for(re int i=1;i<=x;++i)
	if(!((s>>(i-1))&1)){
		int s_=(s+(1ll<<(i-1)));
		++Cnt[s_];
		if(Cnt[s_]==popc[s_]) f[s_]=1,st.insert(s_);
	}
	return ;
}

il void solve(){
	n=rd,v=rd,x=rd,T=(1ll<<x)-1;
	for(re int i=1;i<=x;++i) val[i]=rd;
	for(re int i=1;i<=n;++i)
	for(re int j=1;j<=x;++j){
		int c=rd;
		if(!c) continue;
		V[i]+=c,t[i]|=(1ll<<(j-1));
	}
	if(x<=14){
		add(0);
		for(re int i=1;i<=n;++i)
		for(re int j=0;j<=min(x,v-V[i]);++j){
			for(auto x:vec[t[i]][j])
			if(j+V[i]<=v) add(x);
			vec[t[i]][j].clear();
		}
		printf("%lld\n",ans);
		return ;
	}
	for(re int i=0;i<(1ll<<x);++i){
		int u=i;
		while(u) popc[i]+=(u&1),u>>=1;
	}
	add_(0),st.erase(0),st.insert(-1);
	for(re int i=1;i<=n;++i)
	for(auto u=st.begin();u!=st.end();++u){
		int s_=(*u);
		if(s_>0&&popc[s_&(s_^t[i])]+V[i]<=v&&(s_&t[i]))
			add_(s_),--u,st.erase(s_);
	}
	for(re int i=0;i<(1ll<<x);++i){
		if(!f[i]) continue;
		int ans_=0;
		for(re int j=1;j<=x;++j) ans_+=val[j]*((i>>(j-1))&1);
		ans=max(ans,ans_);
	}
	printf("%lld\n",ans);
	return ;
}
```

---

## 作者：xie_lzh (赞：0)

感觉是很有意思的一个题。

#### 题意简述

给你 $n$ 个位置，每个位置有一些种类的物品，每种物品有若干个。

你有一个大小为 $v$ 的背包，你将输入顺序遍历所有位置。在每个位置，你可以选择丢掉背包里的一些物品并且拿走当前位置的所有物品或什么也不做。

每种物品有一权值 $w_i$。求最终在背包中至少被保留一个物品的所有种类的权值和。

首先可以想到记录每种物品的个数没啥太大用，定义 $W_i$ 表示该位置物品总数，$S_i$ 表示该位置至少有一个的物品集合。

注意到物品种类数很少，这启发我们状压。两个 $subtask$ 不包含，显然应分开考虑。

### Sub2

较少的物品数目使得我们可以使用一些比较暴力的方法。

考虑设 $f_S$ 表示存在一种方式使得背包中恰好有集合 $S$ 中的物品。注意到我们可以丢物品，所以 $S$ 可以转移到它的所有子集。状态数是 $\Theta(2^x)$ 的，转移子集也可以通过记忆化做到 $\Theta(2^xx)$。

考虑如何转移到其他位置。

容易想到暴力的转移是对于每次扫到的位置，暴力遍历所有满足 与 $S_i$ 不交并且 $|T|+W_i \le v$ 的集合 $T$。我们发现这样会有很多重复的转移，所以我们可以考虑去重来使得复杂度均摊正确。

考虑对于一个集合 $T$，所有与它不相交的集合从它这里转移后，一定不会再从它转移。于是我们可以对于每个已经合法的集合，向所有与它无交的集合的转移集合中插入它。转移时枚举当前集合的转移集合，转移完后清空。

这样我们的转移复杂度均摊就是 $\Theta(3^x)$。可以通过该子任务。

### Sub3

注意到 $n$ 不大，我们可以想一个与 $n$ 有关的复杂度。

考虑枚举 $n$，对于每个位置考虑会如何转移。

我们可以发现一个性质，一个集合能够转移当且仅当它的所有子集都能转移，证明应该比较好证。

这样我们可以考虑当前所有子集都已经转移的集合 $T$ 有哪些，然后遍历他们尝试从当前位置转移。由于所有子集都已经合法，所以只要当前位置的 $S_i$ 与 $T$ 有交，并且 $|T\&(S\oplus T)|+W_i \le v$ 那么当前位置就是合法的。然后我们再动态的尝试插入所有现在可能能够转移的集合。

分析一下发现，所有能够转移的集合没有包含关系，所以大小不超过 $C_{x}^{\frac{x}{2}}$ 所以总复杂度为 $\Theta(C_{x}^{\frac{x}{2}}n)$ 。
当 $x=18$ 时，$C_{x}^{\frac{x}{2}}$ 仅有 $48620$ 可以通过。

事实上，这个也能过 $Sub2$。

```cpp
#include<bits/stdc++.h>
using namespace std;
// #define int long long
const int N=3005,MAXN=1e6+5;
int n,v,x,C[MAXN][19],S[MAXN],W[MAXN],V[1<<19],A[20],ans,all;
bool vis[1<<19],insed[1<<19];
int sd[1<<19];
vector<int> vec[1<<14][20];
void ins(int x)
{
	if(vis[x]) return ;
	int sum=0; vis[x]=1;
	for(int ns=x;ns;ns-=(1<<__lg(ns)))
		sum+=A[__lg(ns)];
	ans=max(ans,sum);
	int ps=(all^x),nt=__builtin_popcount(x);
	for(int ns=ps;ns;ns=(ns-1)&ps)
		vec[ns][nt].push_back(x);
	for(int ns=x;ns;ns-=1<<__lg(ns))
		ins(x^(1<<__lg(ns)));
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	cin>>n>>v>>x;
	for(int i=0;i<x;i++) cin>>A[i];
	for(int i=1;i<=n;i++)
	{
		for(int c,j=0;j<x;j++)
		{
			cin>>c; W[i]+=c;
			if(c>0) S[i]|=(1<<j);
		}
	}
	if(x<=14)
	{
		all=(1<<x)-1;
		for(int i=1;i<=all;i++) vec[i][0].push_back(0); vis[0]=1;
		for(int i=1;i<=n;i++)
		{
			for(int j=0;j<=v-W[i];j++)
			{
				for(int p:vec[S[i]][j])
					ins(p|S[i]);
				vec[S[i]][j].clear();
			}
		}
		cout<<ans<<'\n';
	}
	else if(n<=1000000)
	{
		vector<int> vec; all=(1<<x)-1;
		for(int i=0;i<x;i++) vec.push_back(1<<i),insed[1<<i]=1;
		int ans=0;
		for(int i=1;i<=n;i++)
		{
			for(int j=0;j<vec.size();j++)
			{
				if(!(vec[j]&S[i])) continue;
				int p=vec[j],res=(p^(p&S[i])),nv=__builtin_popcount(res);
				if(nv+W[i]<=v)
				{
					vis[p]=1; int nxt;
					for(int ns=(all^p);ns;ns-=(1<<__lg(ns)))
					{
						nxt=p|(1<<__lg(ns)); 
						sd[nxt]++;
						if(sd[nxt]==__builtin_popcount(nxt))  vec.push_back(nxt),insed[nxt]=1;
					}
					swap(vec[j],vec.back()); vec.pop_back();
					j--;
					int sum=0;
					for(int ns=p;ns;ns-=(1<<__lg(ns)))
						sum+=A[__lg(ns)];
					ans=max(ans,sum);
				}
			}
		}
		cout<<ans<<'\n';
		//   8868
		// cout<<8504<<'\n';
	}
	else
	{
	}
}
```

---


# [NOIP2021] 方差

## 题目描述

给定长度为 $n$ 的非严格递增正整数数列 $1 \le a_1 \le a_2 \le \cdots \le a_n$。每次可以进行的操作是：任意选择一个正整数 $1 < i < n$，将 $a_i$ 变为 $a_{i - 1} + a_{i + 1} - a_i$。求在若干次操作之后，该数列的方差最小值是多少。请输出最小值乘以 $n^2$ 的结果。

其中方差的定义为：数列中每个数与平均值的差的平方的平均值。更形式化地说，方差的定义为 $D = \frac{1}{n} \sum_{i = 1}^{n} {(a_i - \bar a)}^2$，其中 $\bar a = \frac{1}{n} \sum_{i = 1}^{n} a_i$。

## 说明/提示

**【样例解释 #1】**

对于 $(a_1, a_2, a_3, a_4) = (1, 2, 4, 6)$，第一次操作得到的数列有 $(1, 3, 4, 6)$，第二次操作得到的新的数列有 $(1, 3, 5, 6)$。之后无法得到新的数列。

对于 $(a_1, a_2, a_3, a_4) = (1, 2, 4, 6)$，平均值为 $\frac{13}{4}$，方差为 $\frac{1}{4}({(1 - \frac{13}{4})}^2 + {(2 - \frac{13}{4})}^2 + {(4 - \frac{13}{4})}^2 + {(6 - \frac{13}{4})}^2) = \frac{59}{16}$。

对于 $(a_1, a_2, a_3, a_4) = (1, 3, 4, 6)$，平均值为 $\frac{7}{2}$，方差为 $\frac{1}{4} ({(1 - \frac{7}{2})}^2 + {(3 - \frac{7}{2})}^2 + {(4 - \frac{7}{2})}^2 + {(6 - \frac{7}{2})}^2) = \frac{13}{4}$。

对于 $(a_1, a_2, a_3, a_4) = (1, 3, 5, 6)$，平均值为 $\frac{15}{4}$，方差为 $\frac{1}{4} ({(1 - \frac{15}{4})}^2 + {(3 - \frac{15}{4})}^2 + {(5 - \frac{15}{4})}^2 + {(6 - \frac{15}{4})}^2) = \frac{59}{16}$。

**【数据范围】**

| 测试点编号 | $n \le$ | $a_i \le$ |
|:-:|:-:|:-:|
| $1 \sim 3$ | $4$ | $10$ |
| $4 \sim 5$ | $10$ | $40$ |
| $6 \sim 8$ | $15$ | $20$ |
| $9 \sim 12$ | $20$ | $300$ |
| $13 \sim 15$ | $50$ | $70$ |
| $16 \sim 18$ | $100$ | $40$ |
| $19 \sim 22$ | $400$ | $600$ |
| $23 \sim 25$ | ${10}^4$ | $50$ |

对于所有的数据，保证 $1 \le n \le {10}^4$，$1 \le a_i \le 600$。

## 样例 #1

### 输入

```
4
1 2 4 6
```

### 输出

```
52
```

## 样例 #2

### 输入

```
见附件中的 variance/variance2.in```

### 输出

```
见附件中的 variance/variance2.ans```

## 样例 #3

### 输入

```
见附件中的 variance/variance3.in```

### 输出

```
见附件中的 variance/variance3.ans```

## 样例 #4

### 输入

```
见附件中的 variance/variance4.in```

### 输出

```
见附件中的 variance/variance4.ans```

# 题解

## 作者：MoYuFang (赞：134)

本文起笔于```2021.11.25```。

[P7962 [NOIP2021] 方差](https://www.luogu.com.cn/problem/P7962)

答案化简为：
$$
n\cdot\sum_{i=1}^{n}a_i^2-\left(\sum_{i=1}^{n}a_i\right)^2
$$
看一组数 $a,b,c,d$，对第而个数操作后变成 $a,a+c-b,c,d$，而两组数的差分分别为 $b-a,c-b,d-c$ 和 $c-b,b-a,d-c$。

于是容易证明，该操作对数列的影响就是交换差分。

设 $d_i=a_{(i+1)}-a_{i}$，对答案做些变换：
$$
\begin{aligned}
n\cdot\sum_{i=1}^{n}a_i^2-\left(\sum_{i=1}^{n}a_i\right)^2
&=n\cdot\sum_{i=1}^{n}(a_i-a_1)^2-\left(\sum_{i=1}^{n}(a_i-a_1)\right)^2\\
&=n\cdot\sum_{i=1}^{n-1}\left(\sum_{j=1}^{i}d_j\right)^2-\left(\sum_{i=1}^{n-1}\sum_{j=1}^{i}d_j\right)^2\\
&=n\cdot\sum_{i=1}^{n-1}\sum_{j=1}^{i}\sum_{k=1}^{i}d_j\cdot d_k-\left(\sum_{j=1}^{n-1}d_j\cdot(n-j)\right)^2\\
&=n\cdot\sum_{j=1}^{n-1}\sum_{k=1}^{n-1}d_j\cdot d_k\cdot(n-\max\{j,k\})-\sum_{j=1}^{n-1}\sum_{k=1}^{n-1}d_j\cdot d_k\cdot(n-j)(n-k)\\
&=\sum_{j=1}^{n-1}\sum_{k=1}^{n-1}d_j\cdot d_k\cdot(-n\cdot\max\{j,k\}+n\cdot(j+k)-j\cdot k)\\
&=\sum_{j=1}^{n-1}\sum_{k=1}^{n-1}d_j\cdot d_k\cdot(n\cdot\min\{j,k\}-j\cdot k)\\
&=
	\sum_{i=1}^{n-1}d_i^2\cdot i\cdot(n-i)+
	2\sum_{j=1}^{n-1}\sum_{k=j+1}^{n-1}d_j\cdot d_k\cdot(n-j)\cdot k\\
\end{aligned}
$$
通过看最后一个式子可以看出答案最小时差分应该是呈现单谷，即答案最小时差分值先减后增。

所以可以考虑将所有差分从小到大排序后，然后设计一个 $\text{dp}$ 决策每个差分值该放在单谷的左边还是右边。

转化过后的式子不好 $\text{dp}$，还是用原先的式子较容易 $\text{dp}$ 。
$$
n\cdot\sum_{i=1}^{n}a_i^2-\left(\sum_{i=1}^{n}a_i\right)^2
$$
设 $f(i,x)$ 表示已经考虑完前 $i-1$ 个差分值，此时的 $a$ 的和为 $x$ 时最小的平方和，设 $s_i=\sum_{j=1}^{i}d_i$ 。

则现在要考虑 $d_i$ 放在单谷的左边还是单谷的右边。

放左边：
$$
f(i,x)+2\cdot x\cdot d_i + i\cdot d_i^2\rightarrow f(i+1,x+i\cdot d_i)
$$
放右边：
$$
f(i,x)+s_i^2\rightarrow f(i+1, x+s_i)
$$
边界条件：
$$
f(1,0)=0,\ \ f(i,x)=+\infty\ \ ((i,x)\neq(1,0))
$$
答案为：
$$
ans=\min_{x=0}^{mx}\{n\cdot f(n,x)-x^2\}
$$
其中 $mx$ 为 $\text{dp}$ 中得到的最大的 $a$ 的和。

考虑到所有差分值 $d_i\geq 0$ 所以这个 $\text{dp}$ 很容易用类似背包的方法把第一维空间给优化掉，而第二维的范围是 $O(n\cdot a)$，所以空间可以承受。

时间复杂度为 $O(n\cdot n\cdot a)$，这过不了。

再加一个小优化，考虑到 $\min\{n,a\}$ 不会很大，所以 $d_i$ 不为 $0$ 的时刻不会很多，$d_i$ 为 $0$ 的时候不会发生任何转移，故可跳过，经过这一优化时间复杂度变成 $O(\min\{n,a\}\cdot n\cdot a)$，可以过。

注意要开 ```long long```。

 ```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <iostream>
#include <assert.h>
using namespace std;

#define re register
#define sf scanf
#define pf printf
#define nl() putchar('\n')
#define ll long long
#define _for(i, a, b) for(re int (i) = (a); (i) < (b); ++(i))
#define _rfor(i, a, b) for(re int (i) = (a); (i) <= (b); ++(i))
#define inf 0x7ffffffffffffffll
#define maxn 10005
#define maxx 500005

int rdnt(){
	re int x = 0, sign = 1;
	re char c = getchar();
	while (c < '0' || c > '9') { if (c == '-') sign = -1; c = getchar(); }
	while (c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (c ^ 48), c = getchar();
	return x * sign;
}

ll  a[maxn], d[maxn], s[maxn], f[maxx];

inline void ud(re ll &x, re ll y){ if (y < x) x = y; }

int main(){
	#ifndef ONLINE_JUDGE
	freopen("variance.in", "r", stdin);
	freopen("variance.out", "w", stdout);
	#endif

	re int n = rdnt(), rg = 0; re ll mx = 0, ma = a[1] = rdnt();
	_rfor(i, 2, n) d[i-1] = (a[i] = rdnt())-a[i-1], ma = max(ma, a[i]);
	_rfor(x, 1, ma*n) f[x] = inf; f[0] = s[0]= 0;
	sort(d+1, d+n);
	_for(i, 1, n){
		s[i] = s[i-1] + d[i];
		if (d[i] == 0) continue;
		for(re int x = mx; x >= 0; --x){
			if (f[x] == inf) continue;
			ud(f[x+i*d[i]], f[x] + 2*x*d[i] + i*d[i]*d[i]);
			ud(f[x+s[i]], f[x] + s[i]*s[i]);
			mx = max(mx, max(x+i*d[i], x+s[i]));
			f[x] = inf;
		}
	}
	re ll ans = inf;
	_rfor(x, 0, mx) if (f[x] < inf) ud(ans, n*f[x] - (ll)x*x);
	pf("%lld\n", ans);

	return 0;
}
 ```



---

## 作者：pigstd (赞：113)

以下均为赛时想法。

---

首先这个变换是显然的：每次操作就是交换差分，那么相当于差分可以随便重排。

化一下这个方差的式子，就是 $n \times \sum a_i^2- (\sum a_i)^2$。

然后 $a$ 同时减小某个数对答案是没有影响的，那么可以钦定 $a_1=0$。

---

然后卡了很久，尝试去猜结论，发现样例它的差分是 `2 1 2`，可以猜测到这个差分是先减小后递增的，打了个暴力确实如此，具体的证明不会，但是感性理解应该是不难的（这样数就会尽可能的“均匀”）。

---

然后就容易想到做法了：首先把差分重排，从小到大考虑，那么每个差分要么插在首要么插在尾，但是两个想减的东西很难维护，那么可以想当把一维放到状态里去，经过一些尝试后发现就是 $\sum a_i$，即 $dp_{i,j}$ 表示处理到前 $i$ 个差分，这 $i$ 个差分还原出来的 $a_i$ 的序列的和是 $j$，在这个情况下的 $\sum a_i^2$ 的最小值，然后你发现无论是插头上还是尾巴上都是可以快速算出新的 $\sum a_i$ 和 $\sum a_i^2$ 的。

---

这样子的复杂度貌似是 $\mathcal{O}(n^2 \times \max a_i )$ 的，怎么办呢？发现很多差分都是 $0$，不为 $0$ 的差分只有 $\max a_i$ 个，为 $0$ 的转移是无意义的根本不用管，那么就可以做到 $\mathcal{O}(n \times (\max a_i)^2)$ 的复杂度，需要滚动数组。[赛时代码](https://www.luogu.com.cn/paste/dfg1yjdm)。

---

这种题大家肯定都会做，我又垫底了。

---
---
---

过了你谷民间数据，应该没假吧。

---

upd：过了。

---

## 作者：jia_shengyuan (赞：64)

## 前言

考场上T1脑抽花了1h，导致这题没时间观察性质，没发现交换方差，只能写了个朴素退火，$100\to40$。

这是一篇****纯模拟退火****的题解，相较于其他题解应该是很简洁的。

#### $40\ pts$ 做法

按题目要求每次随机一个数进行操作，模拟退火即可。

#### $80\ pts$ 做法

首先观察性质，$a_i=a_{i-1}+a_{i+1}-a_i$ 的实质就是交换相邻两项的差分，而通过若干次操作我们可以将原差分序列重新排列成任意我们想要的顺序。

观察到交换差分的性质后，无论是推样例还是数感，都不难感觉到方差最小时，差分应该先减后增（你可以认为是让尽可能多的数集中，从而减小方差）。

因此，我们可以先构造出一种差分先减后增的初始解，之后每次随机两个位置并交换差分，在此基础上再模拟退火，即可获得 $80\ pts$ 的好成绩。

#### $100\ pts$ 做法

我们可以把交换差分改为随机把一个差分插入到另一个地方。观察到许多插入操作的最优方案是****一定****的。例如对于差分序列 `3 1 0 2 4`，若要移动最左测的 $3$，则放到 $2,4$ 中间一定是最优的。

因此，我们每次可以随机一个值，并把它放到差分拐点的另一侧，使得差分序列仍然满足先减后增的性质，在此基础上模拟退火，并调出较好的参数，即可通过本题。

由于涉及到插入与删除，且有吸氧，我们不妨使用STL的 `deque` 简化代码。

我们可以用样例 $4$ 进行测试，以获得较好的参数。实际上我的代码在样例 $4$ 上的出解率也只有 $80\%$，然而交了几次都能过掉这题，希望能出hack数据。（刚交的题解发现有问题……然后就再交了一次，希望不会导致管理看到好几篇吧）

```cpp
#include <algorithm>
#include <climits>
#include <cstdio>
#include <random>
#include <deque>
#include <ctime>
#include <cmath>
#include <cassert>
#define ll long long
// #define err printf
#define err(...)

const int maxn = 1e4+9;
using namespace std;
typedef deque<int>::iterator iter;

int a[maxn],b[maxn],mini=INT_MAX,n;
deque<int> cf;//差分
iter lpt,rpt;
ll ans;
mt19937 rnd(time(0));

void Read(){
    scanf("%d",&n);
    for(int i=0; i<n; i++){
        scanf("%d",&a[i]);
        a[i]*=n; // 为防止出现小数，开始时把每一项乘以n即可
    }
    for(int i=0; i<n-1; i++){
        b[i]=a[i+1]-a[i];
    }
}
void Init(){
    sort(b,b+n-1);
    bool f=0;
    // 构造初始解
    for(int i=0; i<n-1; i++){
        mini = min(mini,b[i]);
        if(f) cf.push_front(b[i]);
        else cf.push_back(b[i]);
        f = !f;
    }
    // 计算最小值有几个，用于退火时判断当前数在拐点左侧还是右侧
    f=0;
    for(int i=0; i<n-1; i++){
        if(cf[i]==mini){
            if(!f){
                lpt = cf.begin()+i;
                rpt = cf.begin()+i;
                f=1;
            } else {
                rpt = cf.begin()+i;
            }
        }
    }
}

ll pf(ll x) { return x*x; }
// 计算方差。由于整体加减不影响方差，我们默认第一项是0
ll calc(){
    ll sum=0,cur=0,pj,fc;
    for(int solo : cf){
        cur += solo;
        sum += cur;
    }
    pj = sum/n;
    fc = pf(pj);//a[0]的贡献
    cur = 0;
    for(int solo : cf){
        cur += solo;
        fc += pf(cur-pj);
    }
    return fc/n;
}
void SA(){
    double T = 2e5;//实测这个初温有很好的出解率
    ll now=ans,newans,de;
    int rndsize = n-1-(rpt-lpt+1),val,len=rpt-lpt+1;
    iter p1;
    while(T>1e-5){
        // 处理拐点区域
        for(int i=0; i<n-1; i++){
            if(cf[i] == mini){
                lpt = cf.begin()+i;
                rpt = lpt+len-1;
                break;
            }
        }
        deque<int> tmp = cf;
        // 随机选一个数插入到别的地方
        p1 = cf.begin()+(rnd()%rndsize);
        if(p1 >= lpt){ //从右侧插入到左侧
            p1 += len;
            val = *p1;
            cf.erase(p1);
            iter now = cf.begin();
            while(*now > val) now++;
            cf.insert(now,val);
        } else { // 从左侧插入到右侧
            val = *p1;
            cf.erase(p1);
            iter now = cf.end();
            while(*(now-1) > val) {
                now--;
            }
            cf.insert(now,val);
        }
        // 更新答案
        newans = calc(); de=newans-now;
        if(de<0 || exp(-de/T)*UINT_MAX>rnd()) {
            ans = min(ans,newans);
            now = newans;
            
        } else cf = tmp;
        T*=0.97;
    }
}

int main(){
    Read();
    Init();
    ans = calc();
    if(rpt-lpt+1 == n-1){ //如果差分全一样，直接输出防止诡异错误
        printf("%lld",ans);
    } else {
        // 退火时尽可能把时间用满，增加出解率
        clock_t s = clock();
        SA();
        clock_t len = clock()-s, limit = CLOCKS_PER_SEC*0.975;
        while(clock()+len < limit) SA();
        printf("%lld",ans);
    }
    return 0;
}
```


---

## 作者：syksykCCC (赞：36)

记 $S = \sum_{i=1}^{n}a_i$，先把答案式子化开：

$$
\begin{aligned}
& n\sum_{i=1}^{n}(a_i - \frac{1}{n} S)^2 \\
= & n (\sum_{i=1}^{n} (a_i^2 + \frac{1}{n^2}S^2 - \frac{2}{n}a_iS)) \\
= & n\sum_{i=1}^{n}a_i^2 +S^2 - 2S \sum_{i=1}^{n}a_i \\
= & n\sum_{i=1}^{n}a_i^2 - (\sum_{i=1}^{n} a_i)^2
\end{aligned}
$$

接下来试图理解一次操作的本质，不难发现，对于一次操作，原来相邻两个数的差为 $a_{i} - a_{i - 1}, a_{i + 1} - a_{i}$，现在变为了 $a_{i + 1} - a_{i}, a_{i} - a_{i - 1}$。

也就是说，一次操作是在**交换差分数组的相邻两项**，而我们可以任意交换差分数组得到一个新的差分排列。

注意到给定的 $a$ 单调递增，所以差分数组里面的项都是 $\ge 0$ 的。

一个至关重要的结论是，最有情况下，这个新的差分排列必然是一个**单谷序列**。

感性上这很容易理解，因为我们要让数列趋向于平均值。严谨证明考虑邻值调整法并不难。

于是，我们将差分数组 $b$ 从小到大排序，然后依次考虑每一项，要么插在当前最左边，要么插在当前最右边。

钦定 $a_0 = 0$，设 $f(i, s)$ 表示考虑了前 $i$ 个数，当前 $\sum a_i = s$ 的情况下，最小的 $\sum a_i^2$ 是多少。

如果放在最右边，那么有 $f(i-1,s) + (\sum_{j=1}^{i}b_j)^2 \to f(i, s + (\sum_{j=1}^{i}b_j))$。

如果放在最左边，那么有 $f(i-1,s) + i\times b_i^2 + 2b_i\times s \to f(i, b_i \times i + s)$。

因为 $s$ 是 $O(na)$ 的，所以直接暴力这样 dp 可以做到 $O(n^2a)$ 的复杂度。

注意到差分数组中非 $0$ 项至多 $O(a)$ 个，而对于 $b_i = 0$ 毕竟排在最前面，无论放左放右都是一样的，所以直接铺开就行了，于是时间复杂度就能做到 $O(na^2)$。

---

## 作者：shenxinge (赞：32)

$Update$ : 2022/01/21 感谢 @一念之间、、指出来的关于 $d$ 的优先讨论。 

### 想法

首先列一个数轴，手玩一把数据，容易发现变化后的点到左边的点的距离等于原先的点到右边的距离，可以看出操作的实质就是将**差分数组交换**。

然后求最后答案的公式：

$$n \times \sum_{i=1}^{n}{(a_i-\overline{a})^2}=n \times \sum_{i=1}^{n}{(a_i^2-2 \times a_i \times \overline{a}+\overline{a}^2)}$$


$$=n \times \sum_{i=1}^{n}a_i^2-2 \times (\sum_{i=1}^{n}a_i)^2+(\sum_{i=1}^{n}a_i)^2$$


$$=n \times \sum_{i=1}^{n}a_i^2-(\sum_{i=1}^{n}a_i)^2$$

有一个重要的性质，那么就是**交换后的差分数组成单谷**。

### 证明单谷

从感性的角度很好理解，但我们还是要从理性去证明。

考虑一项 $a_i$ 增加了 $d$ 之后的变化。

我们令 $n \times \sum_{i=1}^{n}a_i^2$ 为 $T$ ， $\sum_{i=1}^{n}a_i$ 为 $S$ ， 则:

$$T \rightarrow T+n \times (2 \times a_i \times d+d^2) $$

$$S^2 \rightarrow (S+d)^2 =S^2+2 \times S \times d+d^2$$

$T$ 的增量为 $n \times (2 \times a_i \times d+d^2)$ ，$S$ 的增量为 $2 \times S \times d+d^2$

要满足改变后的结果减小，必须保证

$$n \times (2 \times a_i \times d+d^2) < 2 \times S \times d+d^2 $$

把 $S$ 的值化开，因为是不等式，所以要讨论 $d$ 的正负。

考虑交换两个相邻数组的差分值，即 $d=d_{i+1}-d_i$

考虑当 $d > 0$ 时，也即是 $d_{i+1} > d_i $ 时，两边同除以 $n \times d$  , 原式就化为 ：
$$2 \times a_i+d < 2 \times \overline{a} + \frac{d}{n} $$

这个时候因为 $d > 0 $ , 要满足这个柿子成立再交换，很明显有 $a_i > \overline{a} $ 才满足这个式子不成立，即在最优情况不交换，也即是在 $\overline{a}$ 之后的所有 $a_i$ 的最优结构即是单调递增的。
 

考虑当 $d < 0$ 时，也即是 $d_{i+1} < d_i $ 时 , 两边同除以 $n \times d$  , 原式就化为 ：
$$2 \times a_i+d > 2 \times  \overline{a} + \frac{d}{n} $$

这个时候因为 $d < 0 $ , 要满足这个柿子成立再交换，很明显有 $a_i < \overline{a} $ 才满足这个式子不成立，即在最优情况不交换，也即是在 $\overline{a}$ 之前的所有 $a_i$ 的最优结构即是单调递减的。

注意这个时候的 $\overline{a}$ 指的是原本的 $\overline{a}$ ,在其调整后会变化，但调整前此刻的大小不变，这很好的告诉了我们：

最优解的差分数组必定是成单谷状的。

## 做法

证明了这样的一个优秀的性质之后，一切都变得好办了。

然后考虑维护单谷，先对差分数组进行排序，也即是每一个 $dif_i$ 可以插到现单谷的最前面或者最后面，这样就完美地维护了单谷的性质。

然后发现这玩意儿可以直接 $dp$ ，我们令 $dp_{i,s}$ 为排序后前 $i$ 个差分数组交换，$a_i$的和为 $s$ 的最小平方和，于是我们就有:

后插柿子：

$$ \mathit{dp}_{i,s+\sum_{j=1}^{i}dif_j} = min(\mathit{dp}_{i-1,s} + \sum_{j=1}^{i}dif_j \times \sum_{j=1}^{i}dif_j)$$

前插柿子：

$$ \mathit{dp}_{i,s+dif_i*i} = min(\mathit{dp}_{i-1,s} + 2 \times s \times dif_i +i \times dif_i \times dif_i) $$

这两个柿子还是比较好理解的。

同时我们发现下一个 $dif_i$ 的插入只与上一维的 $dp$ 值有关，于是就可以直接滚动起来，对于后插柿子可以直接用前缀和维护。

但是这样的时间复杂度不就是 $O(n^2*V)$ 的了么？？？

但仔细想想，我们可以对前面多个 $dif_i==0$ 进行调整，那么这个时候原本剩下的数只剩下了 $V$ 的大小，也即是第一维只用遍历 $V$ 次，时间复杂度也即是 $O(n*V^2)$ 的。

于是就写出了代码，巨好写：
```cpp
#include<bits/stdc++.h>
#define int long long
#define Debug if(false) 
#define rnt register int
using namespace std;
const int maxn=10100,inf=2e9;
inline int read()
{
	int x=0,f=1;char c;
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-f;
	for(;isdigit(c);c=getchar()) x=(x<<1)+(x<<3)+(c^48);
	return x*f;
}
int a[maxn],dif[maxn],sum[maxn],n=read();
int dp[2][500010],maxa;
signed main()
{
	for(rnt i=1;i<=n;i++) a[i]=read();
	for(rnt i=1;i<n;i++) dif[i]=a[i+1]-a[i];
	sort(dif+1,dif+n),maxa=a[n];int cnt0=1;
	for(rnt i=1;i<n;i++) if(!dif[i]) cnt0++;
	for(rnt i=1;i<n;i++) sum[i]=sum[i-1]+dif[i];
	int now=0,las=1,lim=maxa*n;
	for(rnt i=0;i<=lim;i++) dp[now][i]=inf; //初始全都设为inf 
	dp[now][dif[cnt0]]=dif[cnt0]*dif[cnt0]; //首值放尾 
	dp[now][dif[cnt0]*cnt0]=dif[cnt0]*dif[cnt0]*cnt0; //首值放头 
	for(rnt i=cnt0+1;i<n;i++)
	{
		now^=1,las^=1;
		for(rnt s=0;s<=lim;s++) dp[now][s]=inf;
		for(rnt s=0;s<=lim;s++)
		{
			if(dp[las][s]==inf) continue;
			dp[now][s+dif[i]*i]=min(dp[now][s+dif[i]*i],dp[las][s]+2*s*dif[i]+dif[i]*dif[i]*i); //放头
			dp[now][s+sum[i]]=min(dp[now][s+sum[i]],dp[las][s]+sum[i]*sum[i]); //放尾 
		}
	}
	int ans=inf;
	for(rnt i=0;i<=maxa*n;i++)
		if(dp[now][i]!=inf) ans=min(ans,n*dp[now][i]-i*i);
	cout << ans << endl;
	return 0;
}
```

### 总结

首先想到差分必须有一定的手玩技巧。其次就是重要的性质单谷。

这道题想到单谷可能很简单，但是在证明的时候总是差那么一点。我认为此题的思维难度还是比较高的，至少对于我这种菜鸡来说。


---

## 作者：WeLikeStudying (赞：26)

- 多写题解从我做起。
- 勿做斜杠青年从我做起。
- 希望作者不要爆零。

**题意**
- [题目链接](https://www.luogu.com.cn/problem/P7962)。
- 给定长度为 $n$ 的非严格递增正整数数列，$a_1,a_2,\cdots,a_n$。
- 每次可以选定一个 $1< i< n$，把 $a_i$ 变成 $a_{i-1}+a_{i+1}-a_i$。
- 可以进行无限次操作，求可能的数列方差的最小值乘 $n^2$ 的结果。
- $1\le n\le 10^4,1\le a_i\le 600$。
- 后面记 $a_i$ 的最大值为 $A$。

**思路**
- 看到这么多限制就要想结论。
- 首先有一个被强调千万次的结论：设 $\overline{x^2}$ 为 $a_1^2,a_2^2,\cdots ,a_n^2$ 的平均值，$\overline{x}$ 为 $a_1,a_2,\cdots,a_n$ 的平均值，则 $s^2=\overline{x^2}-\overline{x}^2$。
- 具体可以在[这道题](https://www.luogu.com.cn/problem/P1471)中得到解释。
- 然后容易发现特殊性质：设 $a_i'$ 为变化后的，$a_i$ 为变化前的，则：
$$a_i'-a_{i-1}=a_{i-1}+a_{i+1}-a_i-a_{i-1}=a_{i+1}-a_i$$
$$a_{i+1}-a_i'=a_{i+1}-(a_{i-1}+a_{i+1}-a_i)=a_i-a_{i-1}$$
- 也就是本质上相当于交换差分数组，也就是设 $b_i=a_{i+1}-a_i$，相当于求任意交换 $b_i$ 后还原出 $a_i$ 的方差最小值。
- 有一个 $O(n!)$ 的暴力可以立刻打出来。
- [暴力实现](https://www.luogu.com.cn/paste/kfkulzju)。
- 然后下一步就是思考。
- 忽然想起：方差是和中心偏离的程度，用来衡量一批数据的波动大小。
- 于是我们思考，数据会长什么样子，使得它趋近于某个值。
- 由于数列 $a$ 始终是递增的，情况并不难想。
- 我们发现，当差分数组是这样的时候：（也就是存在 $b_i$ 使得 $b_1\ge b_2\ge \cdots b_i$ 且 $b_i\le b_{i+1}\le\cdots\le b_{n-1}$）
![](https://cdn.luogu.com.cn/upload/image_hosting/5htbojdz.png)
- 因为这个时候，整个 $a$ 数列长这样（即趋近于中间的某个数）：
![](https://cdn.luogu.com.cn/upload/image_hosting/s6a3tnh5.png)
- 因为其它情况显然没有这个集中。
- 就是暴力也能弄出一个 $O(n\cdot 2^n)$ 的算法吧。
- [基于性质的暴力实现](https://www.luogu.com.cn/paste/npfqqs5j)。
- 不过这道题值域这么小找到性质就可以进行动态规划了。
- 先将差分数组排好序。
- 设 $f(i,u,v,S)$ 为使用 $b_1,b_2,\cdots b_i$ 的差分数组，以中间为 $0$ 计算，左边已经下降到 $-u$ 右边已经上升到 $v$，总和为 $S$ 的情况下的平方和最小值。
- 有初始状态： $f(0,0,0,0)=0$。
- 有转移状态：
$$f(i,u,v,S)+(v+b_{i+1})^2\rightarrow f(i+1,u,v+b_{i+1},S+v+b_{i+1})$$
$$f(i,u,v,S)+(u+b_{i+1})^2\rightarrow f(i+1,u+b_{i+1},v,S-u-b_{i+1})$$
- 不过很容易发现这是不好的，比如 $S<0$，难以维护，发现只要 $v-u$ 相等可以一起算，比较好一点的做法是：
- 设 $f(i,j,S)$ 为使用 $b_1,b_2,\cdots b_i$ 的差分数组，以左侧为 $0$ 计算，右边已经上升到了 $j$，且数组总和为 $S$ 的数据平方和最小值。
- 有初始状态 $f(0,0,0)=0$。
- 有转移状态：
$$f(i,j,S)+(j+b_{i+1})^2\rightarrow f(i+1,j+b_{i+1},S+j+b_{i+1})$$
$$f(i,j,S)+2\times b_{i+1}\times S+b_{i+1}^2\times(i+1)
\rightarrow f(i+1,j+b_{i+1},S+b_{i+1}\times (i+1))$$
- 然后惊喜地发现第二维可以消掉，设 $s(x)=\sum_{i=0}^xb_i$，设 $f(i,S)$ 为使用 $b_1,b_2,\cdots b_i$ 的差分数组，以左侧为 $0$ 计算，数据总和为 $S$ 的数据平方和最小值，~~别笑，我真滴是这样一步步推的~~。
- 有初始状态：$f(0,0)=0$。
- 有转移状态：
$$f(i,S)+s^2(i+1)\rightarrow f(i,S+s(i+1))$$
$$f(i,S)+2\times b_{i+1}\times S+b_{i+1}^2\times(i+1)\rightarrow f(i,S+b_{i+1}\times (i+1))$$
- 发现 $S\le n\cdot A$ 恒成立，因此时间复杂度和空间复杂度都是 $O(n^2\cdot A)$ 。
- 而 $f(i,S)$ 中的 $S$ 开到 $i\cdot s(i)$ 即可。
- [代码实现](https://www.luogu.com.cn/paste/poezm4da)。
- 滚动数组可以优化一维使得空间不太紧张。
- [代码实现](https://www.luogu.com.cn/paste/3mk0760c)。
- 就这么 AC 了，测试数据也太水了……吗？
- 思考一下当 $n>A$ 的时候，$b_i$ 数组的前面会有一大堆 $0$，实际有效的转移个数不会超过 $A$。
- 所以更精确的时间复杂度是 $O(n\cdot \min(n,A)\cdot A)$，空间复杂度是 $O(n\cdot A)$，可以通过本题。
- 加了这个细节，出题者还算用心。

---

## 作者：OMG_wc (赞：24)

首先需要知道方差公式为**平方的平均数减去平均数的平方** ，即 $D=\frac{\sum a_i^2}{n}-(\frac{\sum a_i}{n})^2$ ，乘以 $n^2$ 后为 $n\sum a_i^2-(\sum a_i)^2$，这样都可以在 `long long` 的整数范围内计算。

这题突破口是把  $a_{i+1}+a_{i-1}-a_i \rightarrow a_i$ 这个操作和差分联系起来，不然会觉得操作可以执行无限次，很难有一个最终的目标。

记差分数组 $d_i=a_i-a_{i-1}$，观察到对 $a_x$ 进行操作后，其差分仅 $d_x$ 和 $d_{x+1}$ 发生了改变，具体为：

$d_x'=(a_{x+1}+a_{x-1}-a_x)-a_{x-1}=a_{x+1}-a_{x}=d_{x+1}$

$d_{x+1}'=a_{x+1}-(a_{x+1}+a_{x-1}-a_x)=a_{x}-a_{x-1}=d_{x}$

可以发现一次操作仅仅是改变了相邻的两个差分，原数组的差分 $d_1$ 是固定不变的，除此之外的 $d_2\sim d_n$ 显然都可以随便换位置，也就一共有 $(n-1)!$ 种可能。那么全排列一下能骗 $20$ 分。

可以`shuffle`一些初始情况，然后每次随机交换两个数，检查一下是否方差更小，若不是则不交换，这样直到方差到极值为止。

这种方法可以骗到 72 分，代码如下：

```c++
int a[N], d[N], n;
LL ans = INF;
LL cal() {
    for (int i = 1; i <= n; i++) {
        a[i] = a[i - 1] + d[i];
    }
    LL now = 0, s1 = 0, s2 = 0;
    for (int i = 1; i <= n; i++) s1 += a[i], s2 += a[i] * a[i];
    now = -s1 * s1 + s2 * n;
    return now;
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]), d[i] = a[i] - a[i - 1];

    int wc = 2000;
    mt19937 g(114514);
    uniform_int_distribution<int> u1(2, n);
    while (wc--) {
        shuffle(d + 2, d + n + 1, g);
        int t = 0;
        LL now = INF;
        while (t < 300) {
            int x = u1(g), y = u1(g);
            if (x != y) {
                swap(d[x], d[y]);
                LL tmp = cal();
                if (tmp < now) {
                    t = 0;
                    now = tmp;
                } else {
                    swap(d[x], d[y]);
                    t++;
                }
            }
        }
        ans = min(ans, now);
    }
    cout << ans << endl;
    return 0;
}
```

正解的话需要知道一个性质：方差最小时，$d$ 数组一定是先递减后递增。

也就是把差分数组从小到大排序后，考虑存在一个 **核心** 不停往左右两边扩展，一个个地安排每个 $d_i$ 的位置（放当前的最左边或者最右边），每次有两种选择，这样是可以 DP 的。

为什么这样是对的呢？可以用微扰法简单说明下，假设当前的差分排列是符合先递减后递增的，如果在平均数的右边（左边同理）把两个相邻不等的差分 $d_x$ 和 $d_{x+1}$ 交换一下，显然只会让 $a_x$ 变大，而不会改变其他值。这样 $a_x$ 更偏离了平均数，会导致方差变大。

这样解释其实很不严谨，因为平均数也变大了，其实只要YY一下：$a_x$ 本身就属于大的那部分，大的那部分再变大显然会导致整体的差异变大即方差变大。

再回到答案的式子 $n\sum a_i^2-(\sum a_i)^2$，我们用 $f[i][j]$  表示考虑完前 $i$ 小的差分后，当前总和 $\sum a_i=j$ 时，$\sum a_i^2$ 的最小值。



- 若把 $d_i$ 放到当前核心的右端，记 $t=\sum\limits_{k=1}^i d_k$  ，新的 $a_i=t$，之前核心里的所有数都不会变化，转移为 $f[i][j]\Leftarrow f[i-1][j-t]+t\times t$。
- 若把 $d_i$ 放到当前核心的左端，这 $i$ 个数都加上了 $d_i$ （包括新加进去的 $a_i$ ，初始看成 $0$），这样总和是加了 $i\times d_i$，平方和变化为 $\sum (x_k+d_i)^2-\sum x_k^2=\sum2x_kd_i+\sum d_i^2=2d_i(j-i*d_i)+i\cdot d_i^2$，
转移为  $f[i][j]\Leftarrow f[i-1][j-i*d_i]+2d_i(j-i*d_i)+i\cdot d_i^2$。



上述 DP 总状态数有 $n^2a$ 个，每个状态都是 $O(1)$ 转移，空间需要用滚动数组来优化，最终答案只需代入 $n\sum a_i^2-(\sum a_i)^2$ 取个最小值即可。

注意到 $23\sim 25$ 这三个点的 $n$ 特别大，但 $a_i$ 只有 $50$ ，似乎上面的 DP 通过不了。仔细想想这种情况下，一定会有大量的差分 $0$ ，而这些差分 $0$ 其实是不用抉择的，一开始只要集中在核心处就好了。 

这样时间复杂度 $O(\min(n,a)\times na)$，代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL INF = 1e18;
const LL mod = 1e9 + 7;
const int N = 10005;

int a[N], d[N];
LL f[2][500005];

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    int m = n - 1;
    for (int i = 1; i <= m; i++) {
        d[i] = a[i + 1] - a[i];
    }
    sort(d + 1, d + m + 1);
    int s = 0;
    for (int i = 1; i <= n; i++) s += d[i] * i;
    int now = 0, u = 0;
    for (int j = 0; j <= s; j++) f[u][j] = INF;
    f[0][0] = 0;
    for (int i = 1; i <= m; i++) {
        if (d[i] == 0) continue;
        u ^= 1;
        now += d[i];
        for (int j = 0; j <= s; j++) {
            f[u][j] = INF;
            int k = j - i * d[i];
            if (k >= 0) f[u][j] = min(f[u][j], f[u ^ 1][k] + (LL)i * d[i] * d[i] + (LL)2 * k * d[i]);
            k = j - now;
            if (k >= 0) f[u][j] = min(f[u][j], f[u ^ 1][k] + now * now);
        }
    }
    LL ans = INF;
    for (int j = 0; j <= s; j++) {
        if (f[u][j] < INF)
            ans = min(ans, n * f[u][j] - (LL)j * j);
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：Renshey (赞：23)

这里提出一种**非正解**但在官方数据下能够通过的做法。

首先不难证明差分单谷，这一部分可以参考其它题解。

接下来不难想到按顺序搜索每种差分在两边放几个。可能很多人以为这个算法效率是很劣的，但实际上我们可以用一个简单的 dp 来计算这种算法的效率。

下面我们严格证明上述算法能够取得至少 $84$ 分。

记 $a_i$ 的最大值为 $m$，不妨设 $a_1=1$。设 $b_i=\sum_{j=1}^n [a_j=i]$，即 $b_i$ 表示权值为 $i$ 的差分个数，显然有 $\sum_{i=1}^{m-1} i\times b_i= m-1$。

在上述搜索算法中，显然 $0$ 一定在最中间因此无需考虑。因此上述算法的效率为 $O(\prod_{i=1}^{m-1} (b_i+1))$。

考虑 dp：设 $f_{i,j}$ 表示前 $i$ 种差分的权值，和为 $j$，即 $\sum_{k=1}^i k\times b_k=j$ 时，$\prod_{k=1}^i (b_k+1)$ 的最大值。

则转移为：

$$f_{i,j}=\max\limits_{k=0}^{\lfloor \frac{j}{i} \rfloor}\{f_{i-1,j-k\times i}\times (k+1)\}$$

初始化为 $f_{0,0}=1$，答案即为 $f_{m-1,m-1}$。

当 $m\le 50$ 时，$f_{m-1,m-1}\le 3600$。因此对于测试点 $1\sim 8,16\sim 18,23\sim 25$，效率为 $O(3600n)$，能够通过。

对于测试点 $9\sim 12$，不难证明最低效率为 $O(2^{20})$，能够通过。

对于测试点 $13\sim 15$，计算可得 $f_{m-1,m-1}\le 30000$，因此效率为 $O(30000n)$，也能够通过。

因此上述搜索至少能取得 $84$ 分，并且笔者在考场上实现的也是上述做法（包括用于计算效率的 dp），最终在官方数据下取得了 $100$ 分的好成绩。

---

## 作者：Alex_Wei (赞：18)

> [题目传送门](https://www.luogu.com.cn/problem/P7962)。
>
> 一个比较奇怪，复杂度不同但好想的做法。

结合方差的定义猜出差分数组的单谷性并推出 $n\sum_i a_i^2-\left(\sum_{\\i} a_i\right)^2$ 的柿子，这部分同其他题解差不多，略去。

首先，我们由于**不关心 $a_i$ 具体值而是它们的相对大小**（方差的性质），因此固定原数组中某个位置 $a_p=0$，并向其左 / 右添加差分值。

根据单谷性质将所有差分值从小到大排序并定义如下 DP：设 $f_{i,j,k}$ 表示当前考虑到第 $i$ 个差分值，放到 $p$ 左边的差分值之和为 $j$ 且已经确定下来的 $\sum a$ 等于 $k$ 时 $\sum a_i^2$ 的最小值。转移非常直观：放到左边，新的 $a$ 就是 $-j-d_i$，放到右边就是 $-j+\sum_{\\q=1}^i d_q$。

问题在于为了保证正确性 $k$ 这一维应开到 $V^2$ 级别，但感性理解由于 $a_i$ 的正负抵消，$|k|$ 在任何时候不会很大。考场上开了 $12V$ 过了，实际上开 $2V$ 即 $[-V,V]$ 都可以通过，所以猜测上界是线性的~~但不会证明~~，如果有神仙证出来了还请不吝赐教。由于合法的差分值数量为 $\min(n,V)$，故总复杂度为 $\mathcal{O}(\min(n,V)V^2)$。最后一档部分分的时间复杂度是非常优秀的 $V^3$。 

```cpp
#include <bits/stdc++.h>
using namespace std;

#define uint unsigned int
#define mem(x, v, s) memset(x, v, sizeof(x[0]) * (s))

const int N = 1e4 + 5;
const int V = 300 + 5;
const uint inf = 4294967295u;

void cmin(int &x, int y) {if(x > y) x = y;}
void cmin(uint &x, uint y) {if(x > y) x = y;}

int n, a[N], s[N], ss[N];
uint f[2][V][V << 2];

int main() {
	cin >> n;
	for(int i = 1; i <= n; i++) cin >> a[i];
	uint ori = n, ans = inf;
	for(int i = 1; i < n; i++) s[i] = a[i + 1] - a[i];
	sort(s + 1, s + n);
	for(int i = 1, nn = 0; i < n; i++) {
		if(s[i]) s[++nn] = s[i];
		if(i == n - 1) n = nn;
	}
	for(int i = 1; i <= n; i++) ss[i] = ss[i - 1] + s[i];
	mem(f, 0xff, 2), f[0][0][V << 1] = 0;
	for(int i = 1, p = 0, q = 1; i <= n; i++, swap(p, q)) {
		mem(f[q], 0xff, min(V, ss[i] + 1));
		for(int j = 0; j <= min(V - 1, ss[i - 1]); j++)
			for(int k = 0; k < V << 2; k++) {
				uint v = f[p][j][k];
				if(v < inf) {
					int lft = -j - s[i], rt = ss[i - 1] - j + s[i];
					if(k + lft >= 0 && j + s[i] < V) cmin(f[q][j + s[i]][k + lft], v + lft * lft);
					if(k + rt < V << 2) cmin(f[q][j][k + rt], v + rt * rt);
				}
			}
	}
	for(int i = 0; i < V; i++)
		for(int j = 0; j < V << 2; j++) if(f[n & 1][i][j] < inf) {
			int rj = j - (V << 1);
			cmin(ans, ori * f[n & 1][i][j] - rj * rj);
		}
	cout << ans << endl;
	return 0;
}
```



---

## 作者：KaguyaH (赞：11)

提供一种乱搞。

显然可以转为交换差分数组相邻两项。而一个直观的结论是差分数组单谷。

考虑搜索差分数组中每种取值中分别有多少在谷两侧。

这个做法的时间上限应为 $\max_p \prod (p_i + 1)$，其中 $p_i$ 为差分数组中值为 $i$ 的元素数。显然，$p$ 是 $n - 1$ 的一个划分且大小小于 $\min(n, o(\sqrt{\max a_i}))$；易得 $p$ 中必存在一元素至少为 $n - 1 - \max a_i$。

时间复杂度待证明，大概与 $\sqrt {\max a_i}$ 有关。但可以确定的是可以通过 $n \le 20$（时间复杂度至多为 $O(2^n \cdot n)$）。

不进行任何剪枝，大概可以得到 $60 \mathrm{pts}$。

考虑一种较优解：维护一个初始为空的序列，自小向大枚举出现在差分数组中的元素，轮流填在序列左右，并计算序列答案。

考虑用这种较优解作为初始答案，然后朴素搜索 $900 \mathrm{ms}$。

可以优化搜索顺序或进行剪枝，但由于比较不显然，并没有进行任何对搜索的优化。

洛谷民间数据 $84 \mathrm{pts}$，官方数据 $100 \mathrm{pts}$。

值得一提的是，虽然可以通过全部官方数据，但是本做法无法通过样例 4。经测试，在官方数据下，搜索 $400 \mathrm{ms}$ 即可得到正确答案。

```cpp
namespace Main { namespace Main {
  static constexpr const hu nmx(10000), aimx(600);
  static hu n, a[nmx + 1], d[nmx + 1];
  namespace Solve1 {
    // Subtask 1 / 2 / 3 / 4.
    static constexpr const hu nmx(20);
    static inline bool check() { return n <= nmx; }
    static llu ans(ULLONG_MAX);
    static inline void main() {
      sort(d + 2, d + n + 1);
      for (lu i{}; i < 1ul << (n + 1); i += 4) {
        static hu _a[nmx + 1]; hu* p(_a + 2);
        for (hu j(n); j > 1; --j) if (i bitand 1 << j) *p++ = d[j];
        for (hu j(2); j <= n; ++j) if (not(i bitand 1 << j)) *p++ = d[j];
        llu s{}; for (hu j(2); j <= n; ++j) s += (_a[j] = _a[j] + _a[j - 1]);
        llu res{}; for (hu j(1); j <= n; ++j) res = res + 1ull * n * _a[j] * _a[j]; res = res - s * s;
        amin(ans, res);
      }
      put(ans, '\n');
    }
  }
  namespace Solve2 {
    // Subtask 5 / 6 / 8.
    static constexpr const hu aimx(600);
    static inline bool check() { return a[n] <= aimx; }
    static vector<pair<hu, hu>> diff; static hu c[aimx]; static llu ans(ULLONG_MAX);
    static inline void init() {
      deque<hu> t; for (hu i(2); i <= n; ++i) (i & 1 ? t.push_back(d[i]) : t.push_front(d[i]));
      static hu a[nmx + 1]; for (hu i(2); i <= n; ++i) a[i] = a[i - 1] + t[i - 2];
      llu s{}, res{}; for (hu i(1); i <= n; ++i) s += a[i], res += 1ull * n * a[i] * a[i]; res -= s * s;
      amin(ans, res);
    }
    static inline void solve(const hu p = 0) {
      // fprintf(stderr, "%hu\n", p);
      if (clock() >= CLOCKS_PER_SEC * 0.9) return;
      if (p == diff.size()) {
        static hu a[nmx + 1]; hu *q(a + 2);
        for (auto i(diff.crbegin()); i not_eq diff.crend(); ++i) for (hu j{}; j < c[i->first]; ++j) *q++ = i->first;
        for (auto i(diff. cbegin()); i not_eq diff. cend(); ++i) for (hu j{}; j < i->second - c[i->first]; ++j) *q++ = i->first;
        llu s{}; for (hu i(2); i <= n; ++i) s += (a[i] = a[i] + a[i - 1]);
        llu res{}; for (hu j(1); j <= n; ++j) res = res + 1ull * n * a[j] * a[j]; res = res - s * s;
        amin(ans, res);
        return;
      }
      for (c[diff.at(p).first] = 0; c[diff.at(p).first] <= diff.at(p).second; ++c[diff.at(p).first]) solve(p + 1);
    }
    static inline void main() {
      sort(d + 2, d + n + 1); for (hu i(2); i <= n; ++i) { if (diff.empty() or diff.back().first != d[i]) diff.emplace_back(d[i], 0); ++diff.back().second; }
      init(), solve(), put(ans, '\n');
    }
  }
  static inline void main() {
    /*my_fo(my_file);*/ get(n); for (hu i(1); i <= n; ++i) get(a[i]); for (hu i(n); i > 1; --i) d[i] = a[i] - a[i - 1];
    Solve1::check() ? Solve1::main() : Solve2::main();
  }
}}
```

---

## 作者：unputdownable (赞：8)

复杂度 $O(na^2)$，大致是正解了？

首先观察到进行一次操作实际上是将差分数组上两个数互换。

考虑到方差的性质，最优数组的差分必然是大小大的一个趋势，

将差分数组排序，从小到大确定位置，容易发现只可能放在两端。

于是我们开始 DP。

拆分方差，

$$n^2D=n\sum a_i^2-(\sum a_i)^2$$

设 $dp_i$ 表示当前确定的图像表示数组 $\sum a_i=i$ 时，$\sum a_i^2$ 的最小值，同时维护一个确定的值 $s$ 表示已插入差分的和。

假设现在要插入一个 $x$。

$x$ 如果插入在后，那么相当于在数组后跟上一个 $s+x$，有：

$$dp_{i+s+x}=dp_i+(s+x)^2$$

$x$ 如果插入在前，相当于所有数 $+x$ 并在前跟上一个 $0$，有：

$$dp_{i+cnt \times x}=dp_i+ cnt \times x^2 + 2 \times i \times x$$

两者都可以很好维护。

由于已插入数的数量 $c$ 和 $s$ 对于每个插入过程都是确定的，所以不用记录在状态里。

最后的答案就是 $\min(n \times dp_i -i^2)$

暴力来看是要做 $n$ 次的，但是所有的 $0$ 由于排在最前所以都没有贡献，所以最多做 $a$ 次插入，每次至多转移 $n \times a$ 次，所以复杂度是 $O(na^2)$。

同时从大往小枚举转移可以避免开二维数组（因为只会向更大的位置转移）。

**Code:**

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read() {
    int x=0,sgn=1;
    char c=getchar();
    while(c<'0'||'9'<c) {if(c=='-') sgn=0; c=getchar();}
    while('0'<=c&&c<='9') {x=x*10+c-'0'; c=getchar();}
    return sgn ? x : -x;
}
void write(int x) {
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10),x%=10;
    putchar('0'+x);
}
const int LIM=500000;
const int Inf=1e14;
int n;
int a[10004],d[10004];
namespace Sub1 { //n<=10  20pts
    int a[11];
    int Res=Inf;
    inline int calc(void) {
        int sum=0,sum2=0;
        for(int i=1; i<n; ++i) {
            a[i+1]=a[i]+d[i];
            sum+=a[i+1];
            sum2+=a[i+1]*a[i+1];
        }
        return n*sum2-sum*sum;
    }
    int work() {
        sort(d+1,d+n);
        do {
            Res=min(Res,calc());
        } while(next_permutation(d+1,d+n));
        write(Res); puts("");
        return 0;
    }
}
int dp[500005],sum,lim,Ans;
inline void upd(int& x,int y) { x=min(x,y); }
inline int sqr(int x) {return x*x; }
signed main() {
    freopen("variance.in","r",stdin);
    freopen("variance.out","w",stdout);
    n=read();
    for(int i=1; i<=n; ++i) {
        a[i]=read();
    }
    for(int i=1; i< n; ++i) {
        d[i]=a[i+1]-a[i];
    }
    if(n<=10) return Sub1::work();
    sort(d+1,d+n);
    for(int i=1; i<=LIM; ++i) dp[i]=Inf;
    for(int i=1; i< n; ++i) {
        int x=d[i];
        if(x==0) continue;
        for(int s=lim; s>=0; --s) {
            if(dp[s]>=Inf) continue;
            upd(dp[s+sum+x],dp[s]+sqr(sum+x));
            upd(dp[s+i*x]  ,dp[s]+i*x*x+2*s*x);
            dp[s]=Inf;
        }
        lim+=max(sum+x,i*x); sum+=x;
    }
    Ans=Inf;
    for(int i=0; i<=lim; ++i) {
        if(dp[i]>=Inf) continue;
        Ans=min(Ans,n*dp[i]-i*i);
    }
    write(Ans); puts("");
    return 0;
}
```

---

## 作者：nosexynomoney (赞：5)

既然要求最优解，那就可以搞模拟退火。

不难发现题目中给的这个奇奇怪怪的操作的本质就是交换差分数组中相邻的两个项，这样对差分数组中的任意两个位置进行交换都是合法的操作。所以就可以通过模拟退火随机化来求最优解。在参数调的比较好的情况下，可以拿到60~90pts [评测记录](https://www.luogu.com.cn/record/64090702)

那么怎么AC呢?

我们发现样例中的最优解的差分数组为2,1,2,猜想最优解可能有单谷的性质。通过打表可以确认这个性质。

只需在初始时给它排成单谷，就可以给出一个较优的答案，减少大部分的无用交换，大大降低了复杂度。

完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define maxn 10005
inline int fr() {
	int x = 1,t = 0;
	char a = getchar();
	while(!isdigit(a)) {
		if(a == '-') x = -1;
		a = getchar();
	}
	while(isdigit(a)) {
		t = (t<<3)+(t<<1)+a-'0';
		a = getchar();
	}
	return x*t;
}
int n;
int p[maxn];
int c[maxn];
int tmp[maxn];
inline int sq(int x) {
	return x*x;
}
int D() {
	int sum = 0,res = 0;
	for(int i = 2; i<=n; i++) {
		p[i] = p[i-1] + c[i];
	}
	for(int i = 1; i<=n; i++) {
		sum+=p[i];
	}
	for(int i = 1; i<=n ; i++) {
		res +=sq(p[i]*n-sum);
	}
	return res/n;
}
int ansd = LONG_LONG_MAX;
int sum;
void sa() {
	for(double t = 1000;t>1e-6;t*=0.940) {
		if((double)clock()/CLOCKS_PER_SEC>=0.99){
			cout<<ansd;
			exit(0);
		}
		int resx  = rand()%(n-1)+2;
		int resy = rand()%(n-1)+2;
		swap(c[resx],c[resy]);
		int n = D();
		if(n<ansd) {
			ansd = n;
		} else if(exp((double)(ansd-n)/t)*RAND_MAX<=rand()) {
			swap(c[resx],c[resy]);
		}
	}

}
void check() {
	while(1) {
		sa();
	}
}
bool cmp(int a,int b){
	return a>b;
}
signed main() {
	srand(time(0));
	//freopen("variance4.in","r",stdin);
	n = fr();
	for(int i = 1; i<=n; i++) {
		p[i] = fr();
		c[i] = p[i] - p[i-1];
	}
	sort(c+2,c+n/2+1,cmp);
	sort(c+n/2+1,c+n+1);
	check();
}
```
当然随机化算法还是比较吃运气，运气不好的情况下还是会有1~2个点WA，但是最大的点可以过了。

---

## 作者：pomelo_nene (赞：5)

写完了好歹少个挂念哈哈。

乱搞法似乎不一样，没用退火，官方数据大概可以稳过……但是卡也是比较好卡的……希望手下留情。

将原序列差分，记做 $d$。$d_1$ 不变且显然没有意义，挪开。注意到原操作相当于交换 $d_i,d_{i+1}$，原问题就是重排 $d$ 之后，再重构 $a$，使得 $a$ 的方差最小。

没有想法啊？？？怎么办。

先写个 $O(n!)$ 暴力并输出原来的 $d$ 和对应的最优秀的 $d
$。[暴力代码](https://www.luogu.com.cn/paste/jqgxk2hb)，[造数据代码](https://www.luogu.com.cn/paste/49kohn96)。

我们拿 $n = 10,a_i \leq 100$ 的数据观察这个 $d$，不难发现这个 $d$ 是单峰的。再测试几组，可以确定最小值一定放在第 $6$ 位，也就是后面 $9$ 位的正中间。

注意到我们输出的方案有很多类似的，可以发现最优的情况下，翻转后面 $n-1$ 位也是最优的。于是再测试几组 $n=9$ 的也可以发现类似的规律，最小值一定在中间，至于是具体哪个位置随便，反正可以翻转。

得出性质，$d$ 的最小值在正中间，且 $d$ 呈单峰。

发现两边的数非常的相近，并且交换一个左边的数和一个右边的数之后答案不会更优秀，那么猜测最优的情况下是，$d$ 的最小值在正中间，$d$ 呈单峰并且 $d$ 左右两边的 $d$ 之和（不含 $d_1$）差绝对值在所有情况中最小。

但是这种情况可能有很多啊 \>\_<，我们随机吧。

具体做法是，每次重排一遍后面的 $d$，然后开变量 `L`，表示单峰左边的数的值之和；`R` 同理。然后将放左边的数从大到小排序，右边的数从小到大排序，带回去再算一遍就好了……莫名的这个正确性不会很低。再具体的实现看代码就好了。

实际实现的时候还可以加优化，也就是 $0$ 必定放中间，不将其加入 `SL,SR` 就好了。

下面的代码是考场代码小修（没错说的就是你傻逼 `chrono`，你怎么这么长啊呜呜）。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
char buf[1<<21],*p1=buf,*p2=buf;
#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<18,stdin),p1==p2)?EOF:*p1++)
int read()
{
	int x=0;
	char c=getchar();
	while(c<'0' || c>'9')	c=getchar();
	while(c>='0' && c<='9')	x=(x<<1)+(x<<3)+(c^'0'),c=getchar();
	return x;
}
void write(int x)
{
	if(x>9)	write(x/10);
	putchar(x%10+'0');
}
int a[10005],n,d[10005],td[10005];
void makeD()
{
	int L=0,R=0;
	vector<int> SL,SR,Z;
	for(int i=2;i<=n;++i)
	{
		if(td[i]==0)
		{
			Z.push_back(0);
			continue;
		}
		if(L<=R)
		{
			L+=td[i];
			SL.push_back(td[i]);
		}
		else
		{
			R+=td[i];
			SR.push_back(td[i]);
		}
	}
	sort(SL.begin(),SL.end(),greater<int>());
	sort(SR.begin(),SR.end());
	int cnt=1;
	for(auto st:SL)	d[++cnt]=st;
	for(auto st:Z)	d[++cnt]=st;
	for(auto st:SR)	d[++cnt]=st;
}
int pt[105];
int main(){
	n=read();
	int up=0;
	for(int i=1;i<=n;++i)	up=max(up,a[i]=read());
	for(int i=1;i<=n;++i)	td[i]=a[i]-a[i-1];
	chrono::system_clock::time_point now=chrono::system_clock::now();
	chrono::nanoseconds dst=now.time_since_epoch();
	chrono::microseconds mcrosec=chrono::duration_cast<chrono::microseconds>(dst);
	default_random_engine e(mcrosec.count());
	LL ans=2e18;
	int uO=(n>400?3000:(n<=20?400000:100000));
	for(int Case=1;Case<=uO;++Case)
	{
		shuffle(td+2,td+1+n,e);
		d[1]=td[1];
		makeD();
		LL sum=0,ret=0,sm=0;
		for(int i=1;i<=n;++i)
		{
			sum+=(n-i+1)*d[i];
			sm+=d[i];
			ret+=sm*sm;
		}
		ret*=n;
		ret-=sum*sum;
		ans=min(ans,ret);
	}
	write(ans);
	return 0;
}
```

---

## 作者：Demoe (赞：4)

[$\large\text{题目传送门}$](https://www.luogu.com.cn/problem/P7962)

## $\text{Description}$

- 给定一个长度为 $n$ 的单调不降数列，每次可使 $a_i=a_{i-1}+a_{i+1}-a_i(1<i<n)$，问最后序列方差最小值是多少，输出它乘上 $n^2$ 的值。
- 注意 $n,a_i$ 数据范围。

## $\text{Solution}$

这个操作显然是交换差分。所以我们相当于可以任意转换差分。

考虑方差定义为 $\dfrac{1}{n}\sum\limits_{i=1}^n(a_i-\bar a)^2$。

一看就要把答案拆开来。

$\begin{aligned}n\sum\limits_{i=1}^n(a_i-\bar a)^2&=n^2\bar a ^2+n\sum\limits_{i=1}^na_i^2-2n\sum\limits_{i=1}^na_i\bar a \\ & = (\sum\limits_{i=1}^na_i)^2+n\sum\limits_{i=1}^na_i^2-2(\sum\limits_{i=1}^na_i)^2 \\  & =n\sum\limits_{i=1}^na_i^2-(\sum\limits_{i=1}^na_i)^2 \end{aligned}$ 

如果你继续拆，你还可以得到一个关于差分的式子。

令 $b_i=a_{i+1}-a_i$。

上式 $=\sum\limits_{i=1}^{n-1}i(n-i)b_i^2+\sum\limits_{i<j}2i(n-j)b_ib_j$。

然后你通过调整法能搞出来**差分单谷**，或者看这个关于差分的式子很容易感性理解出差分单谷。

然后我们考虑 dp。

通过单谷我们可以知道每次加入最小的差分，我们只需要考虑加在左边还是右边。

我们给 $\{b_i\}$ 从小到大排个序。

由上面第二个式子可得答案与 $a_i$ 具体值无关，那么我们令当前的序列第一个数为 $0$，以便存储 dp 状态。

把第一个式子压掉一维 dp。

令 $f_{i,j}$ 为加了 $i$ 个差分后 $\sum\limits_{k=1}^{i+1}a_k=j$ 时，$\sum\limits_{k=1}^{i+1}a_k^2$ 的最小值。

这样我们去除了原式的后效性。

考虑转移方程：

- 加到左边时，新的数成了 $0$，后面依次顺移 $b_i$，那么有 $f_{i,j+i\times b_i}=\min\{f_{i,j+i\times b_i},f_{i-1,j}+i\times b_i^2+2j\times b_i]\}$。
- 加到右边时，新的数就是 $\sum_{i=1}^i b_i$，那么有 $f_{i,j+\sum_{i=1}^i b_i}=\min\{f{i,j+\sum_{i=1}^i b_i},f_{i-1,j}+{i,j+(\sum_{i=1}^i b_i})^2\}$。

然后直接大力滚动掉一维数组 dp 就有一个 $O(n^2a)$ 的优秀复杂度。

显然过不了。（

那么考虑到值域十分的小，我们再考虑到实际上 $b_i=0$ 的是无用的，那么我们可以把它忽略掉，这样 dp 就是 $O(na\min\{n,a\})$ 的，十分快。

好题，把我这种傻逼区分了。

## $\text{Code}$

```cpp
const int N=1e4+5,M=6e5+5;
const ll INF=1e18;
int n,a[N],b[N],s[N];
ll f[M][2],sum,ans=INF;

// ----------  ---------- //

int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
//	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	rd(n);
	for(re i=1;i<=n;++i) rd(a[i]);
	for(re i=1;i<n;++i) b[i]=a[i+1]-a[i];
	sort(b+1,b+n);
	for(re i=1;i<n;++i) s[i]=s[i-1]+b[i];
	int st=1;
	while(st<n&&!b[st]) ++st;
	for(re i=1;i<M;++i) f[i][0]=INF;
	for(re i=st;i<n;++i){
		for(re j=0;j<M;++j) f[j][i&1]=INF;
		for(re j=0;j<=sum;++j) f[j+i*b[i]][i&1]=min(f[j+i*b[i]][i&1],f[j][(i&1)^1]+1ll*i*b[i]*b[i]+2ll*j*b[i]),f[j+s[i]][i&1]=min(f[j+s[i]][i&1],f[j][(i&1)^1]+1ll*s[i]*s[i]);
		sum+=i*b[i];
	}
	for(re i=0;i<=sum;++i){
		if(f[i][(n&1)^1]>INF/n) continue;
		ans=min(ans,f[i][(n&1)^1]*n-1ll*i*i);
	}
	wr(ans);puts("");
	return 0;
}

// ---------- Main ---------- //
```

---

## 作者：monstersqwq (赞：4)

upd:官方数据极端憨批 $x=14$ 过了。

首先发现给出的条件实质上是差分数组交换两个数，于是换成差分数组上的前缀和的方差。

经过一些拆式子之后得到了答案为 $\sum\limits_{i=1}^{n-1}a_i(n-i)((\sum\limits_{i=1}^j2ja_j)-ia_i)$，我们的目标是让这个东西最小。

写出一个爆搜之后你会发现有最优解的排布一定是先降再升高，于是就会有一个 $O(n2^n)$ 的约 48pts 的做法。

以 $a_i$ 为主元，发现是个二次多项式，二次项系数是 $(n-i)i$，一次项系数是 $2((n-i)\sum\limits_{j=1}^{i-1}ja_j+i\sum\limits_{i=j+1}^{n-1}(n-j)a_j)$。

然后如果你依照刚才 48 的思路，从两边往中间填数，实际上每个数的贡献就是二次项系数统计上在加上一次项系数中已经填的数的贡献，然后你枚举它往左边加数还是右边加数，就得到了一个 $O(n)$ 的牛逼做法！

显然是错的，样例二都跑不明白。

使用大眼观察法，发现错在了差分数组左右两侧的大数上。

然后，进行一个结合，先爆搜一下两边数，有那么一二十个吧，然后再贪心填中间的，如果设你搜的个数为 $x$ 复杂度大约是 $O(2^xn)$，考场上我取 $x=19$，$18$ 会在最后一个大样例上错掉，$20$ 常数翻倍可能要跑到两三秒，而 $19$ 差不多考场垃圾机子没吸氧只跑了一点五秒。

乱搞，确定性算法，不同于随机化，你值得拥有

---

## 作者：I_am_Accepted (赞：3)

### Analysis

方差的 $n^2$ 倍就是

$$n\times sos-sum^2$$

其中 $sos$ 是平方和。

所以只要开 `long long` 即可，无精度问题。

我们先看看能改变啥，操作为将 $a_i$ 变成 $a_{i-1}+a_{i+1}-a_i$，画一画，发现只是将两个相邻的差分 swap 而已。

就是说题目问你，**如何将差分序列排序，使得原序列的方差最小**。

当你一头雾水时，就有 NB 的性质出现：

**使得方差最小化的差分序列一定是先单调不增，后单调不减的。**

理解一下：

![](https://cdn.luogu.com.cn/upload/image_hosting/9mc9bgqi.png)

方差不会随着整个序列整体加减而改变，所以先固定一个数为 $0$，再将差分序列排序（从小到大）后顺序插入当前的前面或后面。

然而暴搜放前面还是后面是会挂的，所以想到 DP。

状态 $f_{i,j}$ 表示当前加入了 $i$ 个差分使得原序列（共 $i+1$ 项）的和为 $j$，原序列平方和的最小值。（默认第一项为 $0$）

转移（$ckmn(a,b)$ 为 $a:=\min(a,b)$）：

$$\begin{aligned}
1&:\quad ckmn(f_{i,j+b_i},f_{i-1,j}+b_i^2)
\\
2&:\quad ckmn(f_{i,j+ia_i},f_{i-1,j}+ia_i^2+2ja_i)
\end{aligned}$$

$$$$

其中 $\{a\}$ 为排序后的差分序列，$b_k=\sum\limits_{i=1}^ka_i$。

![](https://cdn.luogu.com.cn/upload/image_hosting/s2sj2w8f.png)

随后就可以用开头的公式计算方差的最小值了。

### Detail

发现这样空间和时间都是 $O(n^2V)$ 的，~~双喜临门~~。

优化：

可以用滚动数组优化掉空间第一维度。

可以将 $\{a\}$ 中前几项为 $0$ 的先 $O(1)$ 计算，发现 $\{a\}$ 中这样只剩 $O(V)$ 个元素了（即原序列中只有 $O(V)$ 个不同的元素）。

这样时间就是 $O(nV^2)$，可以通过。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define IOS ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)
#define ckmn(a,b) a=min(a,b)
#define linf 0x3f3f3f3f3f3f3f3f
#define N 10010
#define M 6600000
#define ll long long
#define For(i,j,k) for(register ll i=j;i<=k;i++)
ll n,a[N],b[N],lim;
ll f[M],g[M]; 
signed main(){
	IOS;
	cin>>n;
	For(i,1,n) cin>>a[i]; 
	lim=n*a[n];
	For(i,1,n-1) a[i]=a[i+1]-a[i];
	sort(a+1,a+n);
	For(i,1,n-1) b[i]=a[i]+b[i-1];
	
	For(i,0,lim) f[i]=linf;
	ll pos=1;
	while(a[pos]==0) pos++;
	f[a[pos]]=a[pos]*a[pos]; 
	f[pos*a[pos]]=pos*a[pos]*a[pos];
	For(i,pos+1,n-1){
		For(j,0,lim) g[j]=linf;
		For(j,0,lim){
			if(f[j]==linf) continue;
			ckmn(g[j+b[i]],f[j]+b[i]*b[i]);
			ckmn(g[j+i*a[i]],f[j]+a[i]*a[i]*i+2*a[i]*j);
		}
		For(j,0,lim) f[j]=g[j];
	}
	ll ans=linf;
	For(i,0,lim) if(f[i]<linf) ckmn(ans,n*f[i]-i*i);
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：TCTLST (赞：3)

转述一下，本人水平不够并没有代码实现，但是 @AThousandMoon 场上用这个做法过了，应该没有大问题。

首先注意到操作相当于交换差分数组的相邻两项。自己推一推，很好懂。

设差分数组为 $b_1,\dots,b_{n-1}$，不需要知道原序列第一项就可以算出方差。

方差（题目要求 $n^2$ 倍，以下将其称为 $ans$）计算公式为：

$$ans=n\sum_{i=1}^na_i^2-(\sum_{i=1}^na_i)^2$$

由于 $a_1$ 没用，直接认为 $a_i$ 为 $b_1$ 至 $b_{i-1}$ 的和即可。

经过大力拆括号可以推出：

$$ans=\sum_{i=1}^{n-1}b_i^2i(n-i+1)+\sum_{i=1}^{n-1}\sum_{j=i+1}^{n-1}b_ib_ji(n-j+1)$$

现在可以重排序列 $b$ 使得此式最小。

首先注意到最优的 $b$ 必然是先降后增。应该可以调整法~~或感性理解~~之类证明。

那么最小的那 $i$ 个数一定是形成一个长度为 $i$ 的区间。假设 $[l,r]$ 内填了最小的 $r-l+1$ 个数。

接下来考虑在 $l-1$ 或者 $r+1$ 选一个位置填入第 $r-l+2$ 小的数。可以发现新增的贡献只和已经填入的 $\sum b_ii$ 有关。

所以可以设 $f_{l,r,s}$ 表示填了 $[l,r]$，这里面的 $\sum b_ii=s$，式子的最小值。

转移大概是（其中 $x$ 为第 $r-l+2$ 小的数，$p_i$ 为前 $i$ 小的数的和）：

$$f_{l-1,r,s+(l-1)x}\leftarrow f_{l,r,s}+x^2(l-1)(n-l+1)+2x(l-1)(np_{r-l+1}-s)$$

$$f_{l,r+1,s+(r+1)x}\leftarrow f_{l,r,s}+x^2(r+1)(n-r-1)+2x(n-r-1)s$$

这个转移式子的意义，就是考虑和式中新出现的每一对 $i,j$ 的贡献（也即 $i,j$ 一个在 $[l,r]$ 内一个为新加的）。

第三维的大小至多为 $n\sum b_i=na_n$。此时时间复杂度 $O(n^3a)$，期望得分 72 分，如果实现优秀可以期望得分 84 分。

~~应该是大多数人的标准结局？~~

本人只保留被访问到的位置进行 DP，场上大样例只用了 0.5s，最终官方数据得分 100 分。然而各个地方自测都是 84 分，所以考虑更优秀的做法。

~~CCF 你数据比随机数据还水真的有点厉害~~

再次审视一下这个转移式子，可以发现固定 $[l,r]$ 时，只有在下凸包上的点 $(s,f_{l,r,s})$ 有用。如果不在下凸包上，用将其覆盖住的那条凸包上线段的两个端点代替 $[l,r]$ 内的决策（保持 $[l,r]$ 外决策不变），至少有一个比现在优。

证明应该不难，就考虑这三个方案中，$i,j$ 均在 $[l,r]$ 外的贡献都一样，恰一个在 $[l,r]$ 内的贡献是个关于 $s$ 的正比例函数加上只关于 $l,r$ 以及 $[l,r]$ 外部的方案的定值，均在 $[l,r]$ 内的贡献就是 $f_{l,r,s}$。

所以只保留凸包上的点进行转移即可。

据 @AThousandMoon 所说，考场上大样例满足每个凸包的点数都是 $O(1)$，不知道这是数据水了还是可以证明某些东西。

若看作凸包点数为 $O(1)$，则时间复杂度为 $O(n^2)$。

最后同样需要用 $b$ 中至多 $a_n$ 个非零数的结论，将前面等于零的放在一起考虑，少了很多状态，时间复杂度 $O(\min(n,a)^2)$ 至 $O(n\min(n,a))$，取决于实现。

若有证明（或证伪）欢迎在评论区讨论。

---

## 作者：Illusory_dimes (赞：2)

[不知道更好还是更坏的阅读体验](https://www.cnblogs.com/Illusory-dimes/p/15642316.html)

（哈哈，考场想的已经七七八八了但是感觉复杂度不太行就弃了，考后发现基本就是正解的思路了，哈哈）

## Analysis

从两个角度出发，一个是公式本身，另一个是操作本身。

## Solution

### 公式本身

先是公式本身，比较自然的，去拆解式子：

$$
D = \frac{1}{n} \cdot \sum_{i = 1}^{n}(a_i - \bar a) ^ 2
$$

$$
= \frac{1}{n} \cdot \sum_{i = 1}^{n}(a_i ^ 2 - 2 \cdot a_i \cdot \bar a + \bar a ^ 2)
$$

$$
= \frac{1}{n}\sum_{i = 1}^{n}a_i ^ 2 + \frac{-2 \cdot \bar a}{n} \cdot \sum_{i = 1}^{n}a_i + \bar a ^ 2
$$

$$
= \frac{1}{n}\sum_{i = 1}^{n}a_i ^ 2 + \frac{-2 \cdot \bar a}{n} \cdot n \cdot \bar a + \bar a ^ 2
$$

$$
= \frac{1}{n}\sum_{i = 1}^{n}a_i ^ 2 - \bar a ^ 2
$$

因为答案要乘上 $n ^ 2$ ，所以式子就变成了：

$$
= n \cdot \sum_{i = 1}^{n}a_i ^ 2 - (\sum_{i = 1}^{n}a_i) ^ 2
$$

因为众所周知这玩意不受数的实际大小的影响，所以就先钦定数组内最小的数为 $0$ 。

嗯，好看很多了，主要是算的时候方便了很多，因为这两项是彼此独立的。

------------

### 操作本身

大概就是可以把一个数变成边上两个数的和减去自己。

画个图，看一下这个操作干了什么：

![](https://cdn.luogu.com.cn/upload/image_hosting/bfl9iuqm.png)

我们学过两个数的平均值是 $\bar x = (a + b)/2$ ，那么其实很容易理解操作本质上是是**让中间的数按边上两个数的平均值对称**得到了新数。

所以显然，对同一个数做两次操作就变回原来的数了。

好像还是没什么用。。

那这个对称还有什么好性质吗？？

还真有，差分数组 $d_i$ ，这个不就是所有数的间距，那操作一次不就相当于交换一下相邻的两个间距嘛。

那既然操作次数是若干，那就相当于所有间距的排列顺序可以由我们自己定。

------------

那至此题面上两个我们能挖掘的信息已经搞定了。

手玩一段时间发现没有什么快速的填法，然后注意到数据范围不是很大，考虑直接暴力 DP 。

现在跟答案有关的只有三项：**填了多少个间距**，**目前的 $a_i$ 总和**，**目前的 $a_i$ 总平方和**，注意到我们是应该让总和尽可能大，总平方和尽可能小。

由于前两者范围更小一些，那就塞进数组里面：

$dp_{i, S}$ 表示填了 $i$ 个间距，数组总和为 $S$ 的总平方和的最小值。

那么对于一个还未填入的间距，我们可以选择放到最前面或是最后面。

------------

放到最后面的话：

首先总和的话加上了 $\sum d_j$ ，这样的话才会得到新的 $a_i$ ，其次总平方和就就是加上了 $a_i ^ 2$ 。

式子的话就是：

$$
dp_{i, S + \sum d_j} = \min \big(dp_{i - 1, S} + (\sum d_j) ^ 2 \big)
$$

------------

放到最前面的话：

这个比较看起来麻烦，因为后面所有数都因此加上了了一个 $d_j$ ，总和的话问题不大，只是加了 $i$ 次 $d_j$ ，但是总平方和有点麻烦，所以还得稍微推推式子：

$$
\sum (a_i + d_j) ^ 2 - \sum a_i ^ 2
$$

$$
= \sum (a_i ^ 2 + 2 \cdot a_i \cdot d_j + d_j ^ 2) - \sum a_i ^ 2
$$

$$
= \sum (2 \cdot a_i \cdot d_j + d_j ^ 2)
$$

$$
= 2 \cdot d_j \cdot \sum a_i + i \cdot d_j ^ 2
$$

所以只要实时记录一下 $Sum = \sum a_i$ 就可以了。

式子大概就是：

$$
dp_{i, S + i \cdot d_j} = \min \big(dp_{i - 1, S} + 2 \cdot d_j \cdot Sum + i \cdot d_j ^ 2 \big)
$$

------------

时间复杂度 $O(n \cdot n \cdot a_i)$ （后面两项就是总和大小）极限在 $5\cdot 10 ^ 9$ 左右，不太能过。

时间瓶颈在我们枚举的 $S$ ，考虑还有什么可以优化的。

发现每次数列总和只会有两种加法： $\sum d_j$ 和 $i * d_j$ 。那实际上我们只要把 $d_j$ 从小到大排序，这样保证了 $\sum d_j < i * d_j$ ，那么每次我们枚举 $S$ 的上限就只需要加一个 $i \cdot d_j$ 就行。

虽然这样的话时间本质上还是 $O(n \cdot n \cdot a_i)$ 的，但是考虑到值域相较于正常题来说小太多了，**这导致有大量的间距实际上是 $0$ ，那么真正有效果的间距最多只有值域大小个**。所以时间复杂度来到了 $O(n \cdot a_i \cdot a_i)$ ，可以通过此题。

刚刚只看了时间问题，但实际上空间也开不下，所以还需要滚动数组。

## Code

```cpp
/*
*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e4 + 10, A = 606;
const ll INF = 1e16;
int n, a[N], tmp;
ll var[N], sum, lim;
ll mor, f[2][N * A], ans;
inline int read() {
	char ch = getchar();
	int s = 0, w = 1;
	while (ch < '0' || ch > '9') {if (ch == '-') w = -1; ch = getchar();}
	while (ch >= '0' && ch <= '9') {s = (s << 3) + (s << 1) + ch - '0'; ch = getchar();}
	return s * w;
}
int main() {
//	freopen("variance.in", "r", stdin);
//	freopen("variance.out", "w", stdout);
	n = read();
	for (int i = 1; i <= n; ++i) {
		a[i] = read();
		if (a[i] != 1) var[i - 1] = a[i] - a[i - 1];
	}
	sort(var + 1, var + n);
	for (int j = 0; j <= 600000; ++j) {
		f[0][j] = f[1][j] = INF;
	}
	f[0][0] = 0;
	for (int i = 1; i < n; ++i) {
		tmp ^= 1;
		int now = tmp, pre = tmp ^ 1;
		sum += var[i]; lim += i * var[i];
		for (ll j = 0; j <= lim; ++j) f[now][j] = INF;
		for (ll j = 0; j <= lim; ++j) {
			if (j + sum <= lim) f[now][j + sum] = min(f[now][j + sum], f[pre][j] + sum * sum);
			mor = (2 * j + i * var[i]) * var[i];
			if (j + i * var[i] <= lim) f[now][j + i * var[i]] = min(f[now][j + i * var[i]], f[pre][j] + mor);
		}
	}
	ans = INF;
	for (ll j = 0; j <= 600000; ++j) {
		ans = min(ans, n * f[tmp][j] - j * j);
	}
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：Coros_Trusds (赞：2)

[更好的阅读体验](https://www.cnblogs.com/Coros-Trusds/p/15659339.html)

前置知识：CF1110E。

可以看看写的 [$\texttt{\color{black}{题解}}$](https://www.luogu.com.cn/blog/_post/393661)。

# 题目大意

给定长度为 $n$ 的非严格递增正整数数列 $1 \le a_1 \le a_2 \le \cdots \le a_n$。每次可以进行的操作是：任意选择一个正整数 $1 \lt i \lt n$，将 $a_i$ 变为 $a_{i - 1} + a_{i + 1} - a_i$。求在若干次操作之后，该数列的方差最小值是多少。请输出最小值乘以 $n^2$ 的结果。

其中方差的定义为：数列中每个数与平均值的差的平方的平均值。更形式化地说，方差的定义为 $D = \frac{1}{n} \sum_{i = 1}^{n} {(a_i - \bar a)}^2$，其中 $\bar a = \frac{1}{n} \sum_{i = 1}^{n} a_i$。

# 题目分析

前置知识中提到：

令 $c$ 为差分数组，且 $c_i=a_{i+1}-a_i(1\le i\lt n)$。

则一次操作 $a_i=a_{i-1}+a_{i+1}-a_i$ 等价于交换 $c_i$ 和 $c_{i+1}$，那么问题转换为：

给出长度为 $n$ 的序列，重组原序列的差分数组，将得到的差分数组再求出 $a$ 数组。求 $n^2\times\min\{\dfrac{1}{n}\sum\limits_{i=1}^{n}(a_i-\bar a)^2\}$。

显然可以 $\operatorname{O}(N!)$ 枚举。

----

有一个重要的性质：答案差分数组一定先递减再递增。

于是可以随机化乱搞，$84$ 分到手。

----
理一理式子：

$$n^2\times \dfrac{1}{n}\sum\limits_{i=1}^{n}(a_i-\bar a)^2$$

$$=n\times [(a_1-\bar a)^2+(a_2-\bar a)^2+\cdots+(a_n-\bar a)^2]$$

$$=n\times (a_1^2+a_2^2+\cdots+a_n^2+n\times {\bar a}^2-(2a_1\bar a+2a_2\bar a+\cdots+2a_n\bar a))$$

$$=n\times[(a_1^2+a_2^2+\cdots+a_n^2)+n\times {\bar a}^2-2\bar a\times(a_1+a_2+\cdots+a_n)]$$

发现 $(a_1+a_2+\cdots+a_n)$ 就是 $n\times\bar a$，于是：

$$=n\times(\sum\limits_{i=1}^n a_i^2-n\times \bar a^2)$$

$$=n\times\sum\limits_{i=1}^n a_i^2-n^2\times\bar a^2$$

由于 $n^2\times \bar a^2$ 等于 $(n\times \bar a)^2$，即 $(\sum\limits_{i=1}^n a_i)^2$，故有：

$$=n\times\sum\limits_{i=1}^n a_i^2-(\sum\limits_{i=1}^n a_i)^2$$

-----

令 $m=n-1$，$dp[i][j]$ 表示当前考虑了差分数组的前 $i$ 个时的 $\sum\limits_{i=1}^n a_i$。

这样转移会很方便，因为我们要想让 $a$ 数组满足先减再增的性质，故只需要从小到大排序，然后依次考虑放左边还是放右边就好了。

$c_i$ 放在右边时：

令 $now=\sum\limits_{j=1}^i c_j$，则 $a_i=now$（差分的性质）。

方程为 $dp[i][j]\gets dp[i-1][j-now]+now^2$。

$c_i$ 放在左边时：

$a$ 数组中这 $i$ 个数都会加上 $c_i$，总共加了 $i\times c_i$。此时平方和的**变化量**为 

$$\sum\limits_{j=1}^i (a_j+c_i)^2-\sum\limits_{j=1}^i a_j^2$$

$$=\sum\limits_{j=1}^i c_i^2+\sum\limits_{j=1}^i(2\times a_j\times c_i)$$

$$=2\times c_i\times \sum\limits_{j=1}^i a_j+\sum\limits_{j=1}^i c_i^2$$

设此时（转移之前）$dp$ 数组的第二个状态为 $p$。

$$=2\times c_i\times p+i\times c_i^2$$

方程为 $dp[i][j]\gets dp[i-1][j-i\times c_i]+2\times c_i\times (j-i\times c_i)+i\times c_i^2$。

# 代码

```cpp
//2021/12/4

//2021/12/6

//2021/12/7

#define _CRT_SECURE_NO_WARNINGS

#include <iostream>

#include <cstdio>

#include <climits>//need "INT_MAX","INT_MIN"

#include <algorithm>

#include <cstring>

#define int long long

#define enter() putchar(10)

#define debug(c,que) cerr<<#c<<" = "<<c<<que

#define cek(c) puts(c)

#define blow(arr,st,ed,w) for(register int i=(st);i<=(ed);i++)cout<<arr[i]<<w;

#define speed_up() cin.tie(0),cout.tie(0)

#define endl "\n"

#define Input_Int(n,a) for(register int i=1;i<=n;i++)scanf("%d",a+i);

#define Input_Long(n,a) for(register long long i=1;i<=n;i++)scanf("%lld",a+i);

#define mst(a,k) memset(a,k,sizeof(a))

namespace Newstd
{
	inline int read()
	{
		int x=0,k=1;
		char ch=getchar();
		while(ch<'0' || ch>'9')
		{
			if(ch=='-')
			{
				k=-1;
			}
			ch=getchar();
		}
		while(ch>='0' && ch<='9')
		{
			x=(x<<1)+(x<<3)+ch-'0';
			ch=getchar();
		}
		return x*k;
	}
	inline void write(int x)
	{
		if(x<0)
		{
			putchar('-');
			x=-x;
		}
		if(x>9)
		{
			write(x/10);
		}
		putchar(x%10+'0');
	}
}

using namespace Newstd;

using namespace std;

const int INF=0x3f3f3f3f3f3f3f3f;

const int ma=500005;

int a[ma],b[ma];

int dp[2][ma];

int n,sum;

#undef int

int main(void)
{
	#define int long long

	n=read();
	
	for(register int i=1;i<=n;i++)
	{
		a[i]=read();
	}
	
	for(register int i=1;i<n;i++)
	{
		b[i]=a[i+1]-a[i];
	}
	
	sort(b+1,b+n);
	
	for(register int i=1;i<n;i++)
	{
		sum+=b[i]*i;
	}
	
	mst(dp[0],0x3f);
	
	dp[0][0]=0;
		
	int now(0),idx(0);
	
	for(register int i=1;i<n;i++)
	{
		if(b[i]==0)
		{
			continue;
		}
		
		idx^=1ll;
		
		mst(dp[idx],0x3f);
		
		now+=b[i];
		
		for(register int j=0;j<=sum;j++)
		{
			if(j-i*b[i]>=0)
			{
				dp[idx][j]=min(dp[idx][j],dp[idx^1ll][j-i*b[i]]+i*b[i]*b[i]+2*b[i]*(j-i*b[i]));
			}
			
			if(j-now>=0)
			{
				dp[idx][j]=min(dp[idx][j],dp[idx^1ll][j-now]+now*now);
			}
		}
	}
	
	int ans=INF;
	
	for(register int i=0;i<=sum;i++)
	{
		if(dp[idx][i]<INF)
		{
			ans=min(ans,n*dp[idx][i]-i*i);
		}
	}
	
	printf("%lld\n",ans);
	
	return 0;
}
```

---

## 作者：Helenty (赞：1)

### 前言

本篇题解绝对是所有入门组选手都可以看的懂的题解，会将剪枝讲的很详细！

### 再次看题

给定长度为 $n$ 的非严格递增正整数数列 $1 \le a_1 \le a_2 \le \cdots \le a_n$。每次可以进行的操作是：任意选择一个正整数 $1 < i < n$，将 $a_i$ 变为 $a_{i - 1} + a_{i + 1} - a_i$。求在若干次操作之后，该数列的方差最小值是多少。请输出最小值乘以 $n^2$ 的结果。

其中方差的定义为：数列中每个数与平均值的差的平方的平均值。更形式化地说，方差的定义为 $D = \frac{1}{n} \sum_{i = 1}^{n} {(a_i - \bar a)}^2$，其中 $\bar a = \frac{1}{n} \sum_{i = 1}^{n} a_i$。

数据保证：$1 \le n \le {10}^4$，$1 \le a_i \le 600$。

### 解题思路

首先，需要发现方差跟差分序列有关，不然就只能获得 $12\sim40$ 分了。

接着，根据常识或者方差的性质可知，各个数字尽量接近平均数，方差会更小。因此，我们可以用“差分序列两边大中间小”的规则进行爆搜，这样可得 $48$ 分。

具体做法是：将差分序列从小到大排序，第一个放中间，其他的依次放两边，爆搜放左边还是放右边，对于每种排列计算答案并记录最优值。

最后，认真思考发现更多性质，用于剪枝提高效率。如数字很多但数值范围很小，差分序列范围更小。假设有 $n$ 个数字，数字大小不超过 $m$，那么差分序列约 $\sqrt{m}$ 种差值（差值加起来达到 $m$ 了），而且有很多重复，差值为 $0$ 的更多，差值不为 $0$ 的不超过 $m$ 个。

如何利用这些性质进行剪枝？

- 差值为 $0$ 的，放左边和放右边，效果是一样的，我们统一放左边，这样就只需要爆搜差值不为 $0$ 的部分，时间复杂度由 $O(2^n)$ 降低到了 $O(2^m)$。
- 对于差值 $c$，如果有 $k$ 个，他们放左边和放右边是顺序无关的，我们可以指定顺序，先放左边，再放右边，避免重复，这样每一种差值的爆搜复杂度，由 $O(2^k)$ 降低到了 $O(k)$。

然后你就可以 AC 了。

### 解题代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=10005;
int n, m, i, j, k, a[N], c[N], q[N<<1];
long long ans=1e18;

void dfs(int k, int l, int r){
    if(k >= n){
        long long i, s=a[1], c=a[1]*a[1]*n;
        for(i=2; i<=n; i++){
            a[i] = a[i-1] + q[l+i-2];
            s += a[i], c += a[i]*a[i]*n;
        }
        c -= s * s;
        if(c < ans) ans = c;
    } //根据差分序列计算序列a和方差
    else{
        if(!c[k]){
            q[l-1] = c[k];
            dfs(k+1, l-1, r);
        } //差为0放左放右无所谓
        else{ //优先放左边
            if(c[k] != q[r]){
                q[l-1] = c[k];
                dfs(k+1, l-1, r);
            } //右边放过左边不再放
            q[r+1] = c[k];
            dfs(k+1, l, r+1);
        }
    }
}

int main(){
    scanf("%d", &n);
    for(i=1; i<=n; i++){
        scanf("%d", &a[i]);
    }
    for(i=1; i<n; i++){
        c[i] = a[i+1] - a[i];
    } //按照差排序
    sort(c+1, c+n);
    q[N] = c[1];
    dfs(2, N, N); //爆搜差的排列
    printf("%lld\n", ans);
    return 0;
}
```


### 小结

不会做就爆搜，复杂度不过关就剪枝，剪枝超时就记忆化，记忆化还超时就改倒搜、广搜或者 DP。不要小看搜索算法，围棋程序 AlphaGo 也是用的蒙特卡洛树搜索！

---

## 作者：crn1 (赞：1)

## 题意
给定长度为 $n$ 的序列 $a$，每次操作可以将 $a_i$ 替换为 $a_{i-1}+a_{i+1}-a_i$，求序列的方差的最小值乘 $n^2$。

## 题解
此为模拟退火题解（虽然是退火，但准确率高，写完一遍过），想看 dp 正解的可以看其他的题解。

令序列 $b$ 为序列 $a$ 的差分序列，即 $b_i=a_{i+1}-a_i$。将一次操作转化为差分形式：
$$b_i=a_{i+1}-(a_{i-1}+a_{i+1}-a_i)=a_i-a_{i-1}=b_{i-1}$$
$$b_{i-1}=(a_{i-1}+a_{i+1}-a_i)-a_{i-1}=a_{i+1}-a_i=b_i$$
所以原序列上的一次操作就是交换差分序列中相邻两个元素。

有了这个性质，就该考虑差分序列在什么情况下可以使原序列的方差最小，但是并不太好思考，所以有了以下暴力程序（20 pts）
```cpp
#include <cstdio>
#include <vector>
#include <map>

const int N = 105;
int n, ans = 0x3f3f3f3f;
std::vector<int> avec;
std::map<std::vector<int>, bool> mp;

int calc(std::vector<int> vec) { // 计算方差的 n^2 倍
	int s = 0;
	for (int i = 0; i < n; ++i)
		s += vec[i];
	int ret = s * s;
	for (int i = 0; i < n; ++i)
		ret += vec[i] * (n * vec[i] - s * 2);
	return ret;
}

void dfs(std::vector<int> vec) { // 爆搜所有可能
	mp[vec] = 1;
	int res = calc(vec);
	if (res < ans)
		ans = res, avec = vec; // 记录答案
	for (int i = 1; i < n - 1; ++i) {
		int x = vec[i];
		vec[i] = vec[i - 1] + vec[i + 1] - vec[i];
		if (!mp[vec]) dfs(vec); // 搜过的就不搜了
		vec[i] = x;
	}
}

int main(void) {
	std::vector<int> vec;
	scanf("%d", &n);
	for (int i = 1, x; i <= n; ++i) {
		scanf("%d", &x);
		vec.push_back(x);
	}
	dfs(vec);
	printf("%d\n", ans);
	for (int i = 0; i < n - 1; ++i)
		printf("%d ", avec[i + 1] - avec[i]); // 输出对应差分序列
	return 0;
}
```
以下为样例 2 的输入和输出


输入：
```
10
6 19 34 35 56 63 82 82 83 99
```
输出：
```
59865
21 16 7 1 1 0 13 15 19
```

大胆猜测，方差最小时，差分序列呈单谷，依此写出暴力代码（考场代码 48 pts）
```cpp
#include <algorithm>
#include <cstdio>
#define int long long

const int N = 10005;
int a[N], b[N], c[N], d[N];

signed main(void) {
	int n; scanf("%lld", &n);
	for (int i = 1; i <= n; i++) scanf("%lld", a + i);
	for (int i = 1; i < n; i++) b[i] = a[i + 1] - a[i];
	int m = n - 1; std::sort(b + 1, b + n); d[1] = a[1];
	int ans = 0x3f3f3f3f3f3f3f3f;
	for (int s = 0; s < 1 << m; s++) { // 枚举每个元素放左边还是右边
		int k = __builtin_popcount(s), p = 0, p_ = 0;
		for (int i = 0; i < m; i++) // 根据状态还原差分
			if (s & 1 << i) c[k - (p++)] = b[i + 1];
			else c[k + (++p_)] = b[i + 1];
		int t = d[1];
		for (int i = 2; i <= n; i++) // 根据差分还原序列
			d[i] = d[i - 1] + c[i - 1], t += d[i];
		int v = t * t;
		for (int i = 1; i <= n; i++) // 计算序列方差 n^2 倍
			v += d[i] * (n * d[i] - 2 * t);
		ans = std::min(ans, v);
	}
	printf("%lld", ans);
	return 0;
}
```

和枚举每一种可能情况的 20 pts 暴力对拍确实是正确的。

其实有了差分单谷性质后，就可以退火了（考场上一开始没想到性质时试了下退火但是正确率低就放弃了，然而在发现性质后没想起来退火），退火时维护两个 vector（之所以用 vector 是因为插入和删除元素方便且常数小），每次随机一个位置，将它从原 vector 删除并放到另一个 vector 中，然后就 AC 了。

## 代码
```cpp
#include <algorithm>
#include <cstdio>
#include <ctime>
#include <cmath>
#include <cstdlib>
#include <vector>
#define i64 long long

const int N = 10005;
int n, m, a[N], b[N], c[N]; i64 ans;
std::vector<int> v1, v2, v3, v4, t1, t2;

i64 calc() {
	int s = c[1], p = 2;
	for (int i = v1.size() - 1; ~i; --i, ++p)
		c[p] = c[p - 1] + v1[i], s += c[p];
	for (int i = 0; i < (int)v2.size(); ++i, ++p)
		c[p] = c[p - 1] + v2[i], s += c[p];
	i64 ret = (i64)s * s;
	for (int i = 1; i <= n; ++i)
		ret += (i64)c[i] * (n * c[i] - s * 2);
	ans = std::min(ans, ret);
	return ret;
}

void sa() {
	v1 = t1 = v3, v2 = t2 = v4;
	i64 cur = ans;
	for (long double T = 2e5; T > 1e-12; T *= 0.99999) {
		if (clock() > CLOCKS_PER_SEC * 0.98) { // 卡时，不过 980ms 才停还是有点冒险
			printf("%lld", ans);
			exit(0);
		}
		int x = rand() % m + 1; // 随机位置
		t1 = v1, t2 = v2; // 复制一份，如果劣解没被接受方便恢复
		if (x <= (int)v1.size()) { // 放入另一个 vector
			int y = v1[x - 1];
			v1.erase(v1.begin() + x - 1);
			v2.insert(std::lower_bound(v2.begin(), v2.end(), y), y);
		} else {
			x -= v1.size(); int y = v2[x - 1];
			v2.erase(v2.begin() + x - 1);
			v1.insert(std::lower_bound(v1.begin(), v1.end(), y), y);
		}
		i64 nE = calc(), dE = nE - cur;
		if (dE < 0 /* 解更优 */ || exp(-dE / T) * RAND_MAX > rand() /* 概率接受 */) cur = nE;
		else v1 = t1, v2 = t2; // 恢复
	}
}

int main(void) {
	srand(19260817); // 好种子
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
	c[1] = a[1];
	m = n - 1; for (int i = 1; i <= m; ++i) b[i] = a[i + 1] - a[i];
	std::sort(b + 1, b + n);
	for (int i = 1; i <= m; i += 2) v1.push_back(b[i]); // 初始化两个 vector
	for (int i = 2; i <= m; i += 2) v2.push_back(b[i]);
	v3 = v1, v4 = v2; // 复制一份方便恢复（其实没必要）
	ans = calc();
	for (;;) sa(); // 不停退火（不过其实一次就够，因为按照我设置的参数就算是最小的测试数据也跑不完一次）
	return 0;
}
```

---

## 作者：raincity (赞：1)

## 分析

观察出一次操作相当于交换差分数组的相邻两项，操作相当于重排差分数组。

拆开题目求的式子得到答案是 $n\times\sum a_i^2-(\sum a_i)^2$。

一个比较重要的结论：最优的方案中，差分数组一定是单谷的。

不太会证，但是意识到答案和差分有关系后写个爆搜打表出来大概可以发现（大雾）。

所以，可以看作是把差分数组从小到大加入，每一次只能放最前面或者最后面。

设 $f(i,s)$ 表示加入最小的 $i$ 个差分，此时 $\sum a_i=s$，$\sum a_i^2$ 的最小值是多少。

插入在前：$f(i,s)+i\times d^2+2s\times d\to f(i,s+i\times d)$。

插入在后：$f(i,s)+sd^2\to f(i+1,s+sd)$。

其中 $d$ 为当前考虑的差分，$sd$ 为考虑过（包括当前的）的差分的和。

这样 DP 是 $O(n^2a)$ 的。

注意到另一个性质：差分数组的和为 $a_n-a_1$，故非 0 的 $d$ 至多只有 $a$ 个。

优化：最小的 $d$ 都是 0，插在哪一边其实无所谓，从非 0 的 $d$ 开始 DP 即可。

时间复杂度 $O(na^2)$。

## 解决

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>
#define int long long

using namespace std;

const int N = 1e4 + 5, NA = 5e5 + 5, INF = 0x3f3f3f3f3f3f3f3f;
int n, a[N], d[N], f[NA], g[NA];

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i < n; i++) d[i] = a[i + 1] - a[i];
    sort(d + 1, d + n), memset(f + 1, 0x3f, n * a[n] * 8);
    for (int i = upper_bound(d + 1, d + n + 1, 0) - d, sd = 0; i < n; i++) {
        sd += d[i], memcpy(g, f, (n * a[n] + 1) * 8),
            memset(f, 0x3f, (n * a[n] + 1) * 8);
        for (int j = 0; j <= n * a[n]; j++) {
            if (g[j] == INF) continue;
            f[j + i * d[i]] =
                min(f[j + i * d[i]], g[j] + i * d[i] * d[i] + 2 * d[i] * j);
            f[j + sd] = min(f[j + sd], g[j] + sd * sd);
        }
    }
    int ans = INF;
    for (int i = 0; i <= n * a[n]; i++)
        if (f[i] != INF) ans = min(ans, n * f[i] - i * i);
    return cout << ans << endl, 0;
}
```

---


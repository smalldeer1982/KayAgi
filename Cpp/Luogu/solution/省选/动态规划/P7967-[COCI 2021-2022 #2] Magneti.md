# [COCI 2021/2022 #2] Magneti

## 题目描述

给定 $n$ 个磁铁和 $l$ 个空位，其中相邻空位之间的距离为 $1$，每个空位可放置一个磁铁。所有 $n$ 个磁铁都必须被放置。每个磁铁可以吸引距离小于 $r_i$ 的其它磁铁。

求所有磁铁互不吸引的方案总数对 $10^9+7$ 取模的结果。

## 说明/提示

**【样例 2 解释】** 四个磁铁的所有排列都符合题意。

**【样例 3 解释】**

用 $\texttt{1,2,3}$ 表示磁铁，$\texttt \_$ 表示空位，则所有方案为：$\texttt{13\_2}$、$\texttt{31\_2}$、$\texttt{2\_13}$ 和 $\texttt{2\_31}$。

**【数据规模与约定】**

**本题采用子任务捆绑测试。**

- Subtask 1（10 pts）：$r_1=r_2=\cdots=r_n$。
- Subtask 2（20 pts）：$1 \le n \le 10$。
- Subtask 3（30 pts）：$1 \le n \le 30$，$n \le l \le 300$。
- Subtask 4（50 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n \le 50$，$n \le l \le 10000$，$1 \le r_i \le l$。

**【提示与说明】**

**题目译自 [COCI 2021-2022](https://hsin.hr/coci/) [CONTEST #2](https://hsin.hr/coci/contest2_tasks.pdf) _Task 4 Magneti_。**

**本题分值按 COCI 原题设置，满分 $110$。**

## 样例 #1

### 输入

```
1 10
10```

### 输出

```
10```

## 样例 #2

### 输入

```
4 4
1 1 1 1```

### 输出

```
24```

## 样例 #3

### 输入

```
3 4
1 2 1```

### 输出

```
4```

# 题解

## 作者：EuphoricStar (赞：30)

## 思路

dp。

先将所有磁铁按 $r_i$ 从小到大排序，然后令 $f_{i,j,k}$ 表示考虑了前 $i$ 个磁铁，分为 $j$ 组，占用的空位数为 $k$ 的方案数。

那么我们有三个转移：

- 第 $i$ 个磁铁单独成为了一个新组：$f_{i,j,k} \to f_{i-1,j-1,k-1}$。

- 第 $i$ 个磁铁接在前面 $j$ 个组的端点：$f_{i,j,k} \to f_{i,j,k} + f_{i-1,j,k-a_i} \times j \times 2$（$k \ge a_i$）

- 第 $i$ 个磁铁连接前面 $j+1$ 个组的两个：$f_{i,j,k} \to f_{i,j,k} + f_{i-1,j+1,k-2 \times a_i+1} \times j \times (j+1)$（$k \ge 2 \times a_i - 1$）。

最后我们得到了所有磁铁分为 $1$ 组长度为 $i$ 的方案数，那么它对答案的贡献为 $f_{n,1,i} \times \binom{l-i+n}{n}$（根据插板法易得）。

那么这题就做完了，时间复杂度 $O(n^2 \times l)$。

## 代码

[code](https://paste.ubuntu.com/p/HfYmgx7dMx/)

---

## 作者：MoYuFang (赞：24)

PS：这题做得真是一波三折。

为了方便 $\text{dp}$ 先让半径 $r_i$ 减一，即 $r_i := r_i-1$，因为这样两个相邻的磁铁 $r_i,r_j$ 为了互不吸引，之间的最小空位数就是 $\max\{r_i,r_j\}$，下文默认磁铁的半径指的是减一后的半径。

考虑现在固定磁铁们的一个排列，使得第 $i$ 个磁铁的半径为 $s_i$，所以 $\{s_i\}$ 是 $\{r_i\}$ 的重排，并设
$$
S=\sum_{i=1}^{n-1}\max\{s_i,s_{i+1}\}
$$
那么这样的排列至少要占据 $S+n$ 个空位，我们还剩 $l-(S+n)$ 个空位可以随意插入到这 $n$ 个磁铁之间的缝隙和两侧之中，经过一些组合技巧可以算出方案数为 ${l-S\choose n}$，而这个式子中的变量只有 $S$，于是一个基本的思路就是想办法算出每一种 $S$ 有多少排列，记为 $g(S)$，则最终答案为
$$
ans=\sum_{k=0}^{l-n}{l-k\choose n}\cdot g(k)
$$
接下来称某一磁铁排列的 $S$ 为该磁铁排列的直径。

#### 算法一、状压dp

用状压 $\text{dp}$ 处理排列数是一个很常见的套路

设 $f(t,i,k)$ 表示当前排列中的磁铁集合为 $t$，最后一个是第 $i$ 个磁铁，且目前磁铁排列的直径为 $k$ 时的方案数，则转移方程是
$$
f(t,i,k)=\sum_{j\in t\wedge j\neq i} f(t-\{i\},j,k-\max\{r_j,r_i\})
$$
则有
$$
g(k)=\sum_{t}\sum_{i\in t}f(t,i,k)
$$
总时间复杂度为 $O(l\cdot n^2\cdot 2^n)$。

#### 算法二、容斥优化dp

状压 $\text{dp}$ 时间复杂度高的关键在于其状态中包含了一个集合信息，用来表征哪些元素已经使用过，不能再使用了。

一种优化思路是想办法把这个限制去掉，也就是把集合这一信息去掉，但是这样 $\text{dp}$ 的话就会出现元素重复使用的非法排列，但可以用容斥技巧来将非法排列去掉，只留下每个元素仅使用一次的合法方案。

具体做法是，现在我们只使用集合 $T$ （$T$ 为磁铁全集的某个子集）中的磁铁（可重复使用）去占据排列中的 $n$ 个位置，然后得到磁铁排列的直径为某值下的方案数。

于是在只使用集合 $T$ 中的磁铁的情况下，设 $f_T(d,j,k)$ 表示现在排列中有 $d$ 个磁铁，最末尾的磁铁是第 $i$ 个磁铁（一定满足 $i\in T$），当前排列的直径为 $k$ 时的方案数，则有转移
$$
f_T(d,i,k)=\sum_{j\in T} f_T(d-1,j,k-\max\{r_i,r_j\})
$$
对于单个 $T$，时间复杂度为 $O(l\cdot n\cdot|T|^2)$。

利用容斥原理则有
$$
g(k)=\sum_{T}(-1)^{|T|}\sum_{i\in T}f_T(n,i,k)
$$
然而我们仍然需要以  $O(2^n)$ 枚举集合 $T$，所以总时间复杂度为 $O(l\cdot n^3\cdot 2^n)$，反而更差了，这个技巧失败。

这个技巧的来源：[P3349 [ZJOI2016]小星星](https://www.luogu.com.cn/problem/P3349)。

#### 算法三、从插入的角度处理排列

首先考虑 $n$ 个元素的排列的种类数 $n!$ 是怎么来的，设 $f(i)$ 表示使用元素 $1$ 到 $i$ 所组成的排列数，则每次加入新的元素时，新的元素可以插入到这 $i$ 个元素之间的缝隙和两侧，一共 $(i-1)+2$ 个可插入的位置，所以转移方程为
$$
f(i+1)=f(i)\cdot (i+1)
$$
因为是将元素以一定顺序依次插入，所以不需要已使用元素的集合信息，也不需要容斥。

于是不妨试试从插入的角度看看有什么突破口，插入的顺序一般有从小到大，也有从大到小，根据这题的性质，半径大的磁铁的 $r$ 一定会覆盖半径小的磁铁的 $r$，插入半径大的磁铁时不必考虑半径小的磁铁的半径具体是多少，所以我们选择将磁铁按照半径从小到大插入，于是程序的一开始我们可以对 $r_i$ 进行排序使得 $r_{i-1}\le r_i$。

设 $f(i,k)$ 表示已经插入了前 $i$ 个磁铁，且当且磁铁排列的直径为 $k$ 的方案数。

假设现在的排列已经有了 $i-1$ 个磁铁，当前要插入的磁铁是第 $i$ 个磁铁。

如果选择插入在两侧，则磁铁排列的直径的增加量一定是 $r_i$，这时候就容易转移。
$$
2f(i-1,k)\rightarrow f(i,k+r_i)
$$
然而在选择插入到 $i-1$ 个磁铁之间的间隙时我们又遇到了困难，设插入的间隙两边的磁铁分别为 $r_j$ 和 $r_k$，则磁铁排列的直径不单单会增加 $r_i$，还会减少 $\max\{r_j,r_k\}$，这又涉及到具体信息了，所以这个 $\text{dp}$ 还是太 $\text{naive}$ 了。

这就代表这个技巧一定失败了吗？未必，在哪遇到什么困难就努力解决什么困难，我们想办法设计一个不会引起磁铁排列直径减少的 $\text{dp}$。

设 $f(i,j,k)$ 表示当前已经插入了前 $i$ 个磁铁，且这些磁铁组成了 $j$ 个团（每个团都是一个磁铁排列），且当前不同团的磁铁排列的直径之和为 $k$ 时的方案数。

考虑在插入第 $i$ 个磁铁时转移 $f(i-1,j,k)$，有三种转移方式：

（1）从 $j$ 个团中选一个团，并把第 $i$ 个磁铁加入到团的两侧。
$$
2j\cdot f(i-1,j,k)\rightarrow f(i,j,k+r_i)
$$
（2）第 $i$ 个磁铁独立成团。
$$
f(i-1,j,k)\rightarrow f(i,j+1,k)
$$
（3）从 $j$ 个团中合并两个团，第 $i$ 个磁铁用来缝合。
$$
2{j\choose 2}\cdot f(i-1,j,k)\rightarrow f(i,j-1,k+2r_i)
$$
其中乘 $2$ 是因为这两个被选择的团之间的顺序也要考虑到。

于是转移方程可以写成
$$
f(i,j,k)=\sum\left\{\begin{aligned}
&2f(i-1,j,k-r_i)&(k\ge r_i\wedge j\le i-1)\\
&f(i-1,j-1,k)&(j>1)\\
&2(j+1)j\cdot f(i-1,j+1,k-2r_i)&(k\ge 2r_i\wedge j+1\le i-1)\\
\end{aligned}\right.
$$
边界条件为
$$
f(1,1,0) = 1,\quad f(1,j,k)=0\ ((j,k)\neq (1,0))\\
$$
则有
$$
g(k)=f(n,1,k)
$$
总时间复杂度为 $O(l\cdot n^2)$，空间上可以用滚动数组优化掉第一维，空间复杂度为 $O(l\cdot n)$。

这个技巧的来源：[P5825 排列计数](https://www.luogu.com.cn/problem/P5825)。

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
using namespace std;

#define re register
#define sf scanf
#define pf printf
#define nl() putchar('\n')
#define ms(x, val) memset(x, val, sizeof(x))
#define ll long long
#define _for(i, a, b) for(re int (i) = (a); (i) < (b); ++(i))
#define _rfor(i, a, b) for(re int (i) = (a); (i) <= (b); ++(i))
#define maxn 53
#define maxm 10005 
#define mod 1000000007ll

int iv[maxm], ivf[maxm], fct[maxm], f[2][maxn][maxm], r[maxm];

int C(re int n, re int m){ return (ll)fct[n]*ivf[m]%mod*ivf[n-m]%mod; }

void init(re int n){
	ms(f, 0); f[0][1][0] = 1;
	iv[1] = fct[0] = fct[1] = ivf[0] = ivf[1] = 1;
	_rfor(i, 2, n){
		iv[i] = (ll)iv[mod%i]*(mod-mod/i)%mod;
		fct[i] = (ll)fct[i-1]*i%mod;
		ivf[i] = (ll)ivf[i-1]*iv[i]%mod;
	}
}

int main(){
	#ifndef ONLINE_JUDGE
	freopen("sample.in", "r", stdin);
	//freopen("sample.out", "w", stdout);
	#endif
	
	re int n, l;
	sf("%d %d", &n, &l);
	_rfor(i, 1, n) sf("%d", r[i]), --r[i];
	sort(r+1, r+n+1);
	init(l);
	
	re int cur = 0;
	_rfor(i, 2, n){
		_rfor(j, 1, i) _rfor(k, 0, l-n){
			f[cur^1][j][k] = (
				(j <= i-1 && k >= r[i] ? (ll)2*j*f[cur][j][k-r[i]] : 0ll) + 
				(j > 1 ? f[cur][j-1][k] : 0ll) +
				(j+1 <= i-1 && k >= 2*r[i] ? (ll)(j+1)*j*f[cur][j+1][k-2*r[i]] : 0ll)
			)%mod;
		}
		cur ^= 1;
	}
	
	re int ans = 0;
	_rfor(k, 0, l-n) if (f[cur][1][k])
		ans = (ans + (ll)C(l-k, n)*f[cur][1][k])%mod;
	pf("%d\n", ans);

	return 0;
}
```

---

## 作者：chroneZ (赞：15)

> 在此给出笔者所作的[《浅谈一类状态转移依赖邻项的排列计数问题：连续段 dp》](https://www.cnblogs.com/chroneZ/p/17938137)供感兴趣的读者更系统地学习。

记**覆盖区间**表示磁铁经过放置，最左端磁铁和最右端的磁铁的位置组成的区间。

我们先做一个转化：考虑对于一种磁铁的排列顺序 $p$，我们求出其极小的覆盖区间长度（i.e. **将所有磁铁尽可能紧凑地放置**后，覆盖区间的长度），记该长度为 $D(p)$，则剩余的 $l - D(p)$ 个空位可以在磁铁之间及被覆盖区间之外任意放置，组合数学算得方案数为 $\binom{l - D(p) + n}{n}$。记 $g(x)$ 表示有多少个排列 $p$ 满足 $D(p) = x$，答案显然为 $\sum \binom{l - i + n}{n}g(i)$，考虑如何求 $g$。

首先注意到对于两相邻磁铁 $i, j$，若 $r_i < r_j$，则只需考虑 $r_j$ 的限制，因此我们按 $r_i$ 从小到大插入元素。记当前覆盖区间长度为 $k$，显然我们需要维护这个 $k$ 才能进行状态转移。当我们在两端插入磁铁时，可以直接令 $k \gets k + r_i$，但若在两相邻磁铁 $x, y$ 之间插入，需要令 $k \gets k + 2r_i - \max(r_x, r_y)$，用到了已插入元素的具体信息。面对这种插入位置在端点便于维护，在相邻元素之间难以维护的时候，想到连续段 dp。

记 $f_{i, j, k}$ 表示插入了前 $i$ 个元素，形成 $j$ 个连续段，目前覆盖区间长度为 $k$ 的方案数。

- 插入至已有连续段的一端：$f_{i, j, k} \times 2j \to f_{i + 1, j, k + r_{i + 1}}$

- 作为新的连续段插入：$f_{i, j, k} \times (j + 1) \to f_{i + 1, j + 1, k + 1}$

- 合并两连续段：$f_{i, j, k} \times (j - 1) \to f_{i + 1, j - 1, k + 2r_{i + 1} - 1}$，新元素会对 $k$ 产生 $2r_{i + 1} - 1$ 的贡献。

> 可能有的读者还是会对 $k$ 的转移感到疑惑，其实连续段 dp 过程中，我们更多地会将“连续段”视作“子问题”，连续段之间互相独立，只有在合并时才会互相产生影响。上文中 $k$ 统计的只是每个“子问题”中覆盖区间长度的总和，因此当我们新建，插入，合并的时候 $k$ 通过如上方式转移。

最终有 $g(i) = f_{n, 1, i}$，按此前得到的式子计算即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;
constexpr int N = 50 + 5, L = 10000 + 100, MOD = 1e9 + 7;

int f[N][N][L], r[N], g[L];

inline void pl(int& x, int y) {x += y; if(x >= MOD) x -= MOD;}

i64 fact[L], invfact[L];
inline i64 ksm(i64 a, i64 b){
	i64 r = 1;
	while(b){
		if(b & 1) r = r * a % MOD;
		a = a * a % MOD; b >>= 1;
	}
	return r;
}
inline i64 binom(int n, int m) {return fact[n] * invfact[m] % MOD * invfact[n - m] % MOD;}

int main(){
	ios::sync_with_stdio(false); 
	cin.tie(nullptr); cout.tie(nullptr);
	
	fact[0] = invfact[0] = 1;
	for(int i = 1; i < L; i++)
		fact[i] = fact[i - 1] * i % MOD, invfact[i] = ksm(fact[i], MOD - 2);
	
	int n, l; cin >> n >> l;
	for(int i = 1; i <= n; i++)
		cin >> r[i];
	sort(r + 1, r + n + 1);
	f[0][0][0] = 1;
	for(int i = 0; i < n; i++) for(int j = 0; j <= i; j++)
		for(int k = 0; k < l; k++){
			if(k + r[i + 1] <= l)
				pl(f[i + 1][j][k + r[i + 1]], 1ll * f[i][j][k] * j * 2 % MOD);
			if(k + r[i + 1] * 2 - 1 <= l && j >= 2)
				pl(f[i + 1][j - 1][k + r[i + 1] * 2 - 1], 1ll * f[i][j][k] * (j - 1) % MOD);
			pl(f[i + 1][j + 1][k + 1], 1ll * f[i][j][k] * (j + 1) % MOD);
		}
	for(int i = 0; i <= l; i++)
		g[i] = f[n][1][i];

	int ans = 0;
	for(int i = 0; i <= l; i++)
		pl(ans, binom(l - i + n, n) * g[i] % MOD);
	cout << ans << "\n";
}
```


---

## 作者：Lazy_Labs (赞：5)

# 前言
这篇题解是对 @zlttql 的巨佬思路的补充
# 分析
首先我们知道如果 $r_i< r_j$ 那么如果 $r_j$ 这一个约束条件满足了则 $r_i$ 则不需要满足。

那么我们可以从小到大排序，每次插入一个磁铁。
# DP 状态
$f_{i,j,k}$ 表示插入前 $i$ 个磁铁，已经分成 $j$ 个连通块，其中还有 $k$ 个空位没有被占有的情况。

这里我们需要解释一下“联通块”的意义：

“连通块”指几个磁铁通过“制约”连成的联通块，且“连通块”的两端没有“制约”（因为是按照从小到大插入的，所以两端的只需要满足大的能插进来就行了）

上图片：（黑色代表磁铁，红色代表磁铁的范围，橙色代表连通块）

此时 $r_1=2$ 即能吸引半径 $1$ 以内的磁铁，但是联通块只有黑色的那一块

![](https://i.bmp.ovh/imgs/2022/03/aa5e449e7cb8666e.png)

此时加入一个 $r_2=3$ 即能吸引半径 $2$ 以内的磁铁的磁铁，并且使它们形成“连通块”。因为要连成“连通块”，那么就必须“挨在一起”，如下图。

![](https://i.bmp.ovh/imgs/2022/03/b9154b4511d9eb0f.png)

则因为第 $2$ 块磁铁加入满足制约那么第 $1$ 块磁铁就一定满足，所以没必要记第一块磁铁的“制约”。即“连通块”只需要满足最左和最右不会被“吸引”即可。

DP 状态如楼上。

我们有三个转移：

第 $i$ 个磁铁单独成为了一个新组： $f_{i,j,k} \to f_{i-1,j-1,k-1}$

第 $i$ 个磁铁接在第 $j$ 个组的端点： $f_{i,j,k} \to f_{i,j,k} + f_{i-1,j,k-r_i} \times j \times 2 (k \ge r_i)$ 

第 $i$ 个磁铁把两个“连通块”接了起来：$f_{i,j,k} \to f_{i,j,k} + f_{i-1,j+1,k-2 \times r_i+1} \times j \times (j+1) (k \ge 2\times r_i+1)$

至于那两个接起来其实无所谓，只需要记下 $i,j,k$ 的个数有多少即可。

最后运用插板法知答案为 $\sum^l_{i=1}f_{n,1,i} \times \binom{l-i+n}{n}$。

---

## 作者：Tsawke (赞：2)

# COCI2021-2022 Contest1 T4题解

[TOC]

## [更好的阅读体验戳此进入](http://blog.monkey-hyx.tech?t=COCI-2021-2022-Contest2)

（建议您从上方链接进入我的个人网站查看此 Blog，在 Luogu 中图片会被墙掉，部分 Markdown 也会失效）

## [原题面链接](https://hsin.hr/coci/contest2_tasks.pdf)

## [Luogu题面](https://www.luogu.com.cn/problem/list?keyword=COCI2021-2022%232&page=1)

## T4 Magneti

### 题意

给你 $ n $ 个磁铁，第 $ i $ 个磁铁都能吸引两侧距离小于 $ r_i $ 的磁铁，要求将这 $ n $ 个磁铁全部放置于 $ l $ 个两两距离为 $ 1 $ 的空位中，使得任意两个磁铁都不会被相互吸引，求总方案数，对 $ 10^9 + 7 $ 取模。

* Subtask 1（10 pts）：$ r_1=r_2=\cdots=r_n $。
* Subtask 2（20 pts）：$ 1 \le n \le 10 $。
* Subtask 3（30 pts）：$ 1 \le n \le 30 $，$ n \le l \le 300 $。
* Subtask 4（50 pts）：无特殊限制。

对于 $ 100\% $ 的数据，$ 1 \le n \le 50 $，$ n \le l \le 10000 $，$ 1 \le r_i \le l $。

### Solution

首先我们可以考虑对于有特殊性质的磁铁，当 $ r $ 均相等时，我们可以考虑先将所有磁铁挨着放在 $ n $ 个空位中的方案，然后将剩下的 $ l - n $ 个空位，即 $ l - n $ 个球，可以空闲地分布在 $ n $ 个磁铁之间即两侧，也就是 $ n + 1 $ 个盒子，也就是标准球盒问题，用隔板法求解，即：
$$
A_n^n \times \binom{l}{n}
$$
然后我们可以考虑通过这个性质来思考这道题的思路。

首先我们思考之前的性质，我们先是确定了一部分长度中磁铁如何排列，然后用隔板法计算方案数。所以对于这道题我们的思路也可以去考虑所有的磁铁的合法排列，然后统计总方案数。

我们会发现如果按照每个磁铁输入顺序考虑，并没有什么好的性质，而我们又考虑，对于两个磁铁互相吸引时，显然会优先因为吸引半径更大的磁铁而不合法，所以可以考虑按照吸引半径升序排序，并从每次插入新的磁铁的角度来考虑。

这道题的 $ \texttt{DP} $ 还是很显然的，我们可以考虑如何设计状态。

考虑定义一个连通块为一段一定不可能被插入磁铁的区间，且以磁铁开头并以磁铁结尾，显然当两个磁铁，或者更进一步地，两个连通块的吸引区域有重合，或紧挨着，则两个连通块变为同一连通块。

![COCI-2021-2022-Contest2_1.png](http://monkey-hyx.tech/Images/Blog/COCI-2021-2022-Contest2_1.png)

如图，三个正方形为磁铁，线段为磁铁的吸引半径，大长方形即为连通块。

为什么要这样设计连通块？因为我们在每次插入一个新的磁铁的时候都要考虑如何放置，而因为升序的原因，我们只需要考虑新插入的磁铁的吸引半径，所以对于每个连通块左右的吸引半径可以忽略。

可以考虑令 $ dp(i, j, k) $ 表示已经插入了 $ i $ 个磁铁（或正在插入第 $ i $ 个磁铁），已经形成了 $ j $ 个连通块，占用了 $ k $ 个空位的方案数，需要注意我们这里考虑的只是哪些磁铁在同一连通块内的方案数，而未考虑排列顺序，即我们记录的 $ \texttt{DP} $ 是组合数。

然后我们考虑转移，对于新插进来的一个磁铁，显然有如下三种可能性，即我们要将 $ dp(i, j, k) $ 加上如下几种情况的方案数。

upd - Tips: 注意因为我们的目的是求出来排列方案数然后按照隔板法求，所以我们插入一个新的连通块的时候应该去贪心地让新的磁铁尽可能地挨着原来的连通块。

#### 单独形成一个连通块

显然会使连通块多一个，剩余空位少一个，即：
$$
dp(i - 1, j - 1, k - 1)
$$

#### 连接在某一个连通块的前端或后端

因为升序排列，所以只考虑我们插入的这个磁铁会占用 $ r_i - 1 + 1 $ 的空位。

而一共有 $ j $ 个连通块可以选择，前端后端均可选择，即：
$$
dp(i - 1, j, k - r_i) \times j \times 2
$$

#### 在两个连通块之间，将两个连通块连接起来

这里需要注意一个点，我们考虑的是磁铁之间的组合而非排列，所以任意两个块之间都可以被连结，且两者之间不同的顺序也是不同的方案。

与第二种情况类似，因为升序排列，只需要考虑插入的这个磁铁，为了连结，会在左右两侧各自占用 $ r_i - 1 $ 的空位，自己又会占用 $ 1 $ 的空位，且连通块减少一个，即：
$$
dp(i - 1, j + 1, k - r_i \times 2 + 1) \times A_{j + 1}^{2}
$$

#### 方案的计算

$ \texttt{DP} $ 之后我们显然可知，要求的每一个合法方案都应该是连通块的个数为 $ 1 $ 的方案，即：
$$
\sum_{i = 1}^{l}dp(N, 1, i) \times \binom{l + n - i}{n}
$$

### Code

```cpp
#define _USE_MATH_DEFINES
#include <bits/stdc++.h>

#define PI M_PI
#define E M_E
#define npt nullptr
#define MOD 1000000007//(int)(1e9 + 7)

/******************************
abbr

******************************/

using namespace std;

mt19937 rnd(random_device{}());
int rndd(int l, int r){return rnd() % (r - l + 1) + l;}

typedef unsigned int uint;
typedef unsigned long long unll;
typedef long long ll;

ll qpow(ll a, ll b){
    ll ret(1), mul(a);
    while(b){
        if(b & 1)ret = ret * mul % MOD;
        b >>= 1;
        mul = mul * mul % MOD;
    }
    return ret;
}
ll frac[11000], inv[11000];
void Init(int N){
    frac[0] = 1;
    for(int i = 1; i <= N; ++i)frac[i] = frac[i - 1] * i % MOD;
    inv[N] = qpow(frac[N], MOD - 2);
    for(int i = N - 1; i >= 0; --i)inv[i] = inv[i + 1] * (i + 1) % MOD;
}
ll C(int n, int m){
    if(m > n)return 0;
    return frac[n] * inv[m] % MOD * inv[n - m] % MOD;
}
template<typename T = int>
inline T read(void);

int N, L;
int r[110];
ll dp[55][55][11000];
int main(){
    N = read(), L = read();
    Init(10100);
    for(int i = 1; i <= N; ++i)r[i] = read();
    sort(r + 1, r + N + 1);
    dp[0][0][0] = 1;
    for(int i = 1; i <= N; ++i)
        for(int j = 1; j <= i; ++j)
            for(int k = 1; k <= L; ++k){
                dp[i][j][k] = dp[i - 1][j - 1][k - 1];
                if(k >= r[i])dp[i][j][k] += dp[i - 1][j][k - r[i]] * j % MOD * 2 % MOD;
                if(k >= r[i] * 2 - 1)dp[i][j][k] += dp[i - 1][j + 1][k - r[i] * 2 + 1] * (j + 1) % MOD * (j + 1 - 1) % MOD;
                dp[i][j][k] %= MOD;
            }
    ll ans(0);
    for(int i = 1; i <= L; ++i)ans += dp[N][1][i] * C(L - i + 1 + N - 1, N + 1 - 1) % MOD;
    printf("%lld\n", ans % MOD);
    fprintf(stderr, "Time: %.6lf\n", (double)clock() / CLOCKS_PER_SEC);
    return 0;
}



template<typename T>
inline T read(void){
    T ret(0);
    short flag(1);
    char c = getchar();
    while(c != '-' && !isdigit(c))c = getchar();
    if(c == '-')flag = -1, c = getchar();
    while(isdigit(c)){
        ret *= 10;
        ret += int(c - '0');
        c = getchar();
    }
    ret *= flag;
    return ret;
}
```

## UPD

2022_09_05 完成 T1 - T3 及 T4 一部分

2022_09_06 初稿

2022_09_07 修改了 T3 T4 的一些存在的错误

---

## 作者：_Vix_ (赞：1)

[原题链接](https://www.luogu.com.cn/problem/P7967)

竟然是连续段 DP ！？赶紧记录一下套路。

## 分析

先对题目做一个小转化。将 $n$ 个磁铁尽可能紧密的排列在一起，同时这个排列的长度是 $k$（最左端磁铁与最右端磁铁的距离），那么还剩下 $l-k$ 个空位，所以这个磁铁排列的贡献就是 $\binom{l-k+n}{n}$。现在我们只需要求长度为 $k$ 的磁铁排列有多少个。

按照连续段 DP 的思想设计状态，$f_{i,j,k}$ 表示考虑前 $i$ 个磁铁，形成了 $j$ 个连续段，长度为 $k$ 的方案数，答案就是 $\sum f_{n,1,i} \times \binom{l-i+n}{n}$。

对于两个磁铁 $i,j$，若 $r_i<r_j$ 则只需要考虑 $r_j$ 的限制，因此要将 $r$ 排序。转移考虑三种操作：（注意箭头方向）
 
 1. 新建段：$f_{i,j,k} \times (j+1) \rightarrow f_{i+1,j+1,k+1}$
 2. 合并段：$f_{i,j,k} \times (j-1) \rightarrow f_{i+1,j-1,k+2r_{i+1}-1}$
 3. 扩展段：$f_{i,j,k} \times 2j \rightarrow f_{i+1,j,k+r_{i+1}}$

代码里将数组开大一点就不用讨论越界的问题了（偷懒）

## Code
```cpp
int main() {
	init(20000);
	scanf("%d%d", &n, &l);
	for (int i = 1; i <= n; i++) scanf("%d", &r[i]);
	sort(r + 1, r + n + 1);
	f[0][0][0] = 1;
	for (int i = 0; i < n; i++)
		for (int j = 0; j <= i; j++)
			for (int k = 0; k < l; k++) {
				//New
				add(f[i + 1][j + 1][k + 1], (ll)f[i][j][k] * (j + 1) % mod);
				//Merge
				add(f[i + 1][j - 1][k + 2 * r[i + 1] - 1], (ll)f[i][j][k] * (j - 1) % mod);
				//Extend
				add(f[i + 1][j][k + r[i + 1]], (ll)f[i][j][k] * j * 2 % mod);
			}
	int ans = 0;
	for (int i = 1; i <= l; i++) add(ans, (ll)f[n][1][i] * C(l - i + n, n) % mod);
	printf("%d", ans);
	return 0;
}
```


---

## 作者：_ZSR_ (赞：1)

### [P7967 [COCI2021-2022#2] Magneti](https://www.luogu.com.cn/problem/P7967)

为了方便，我们先把 $r_i$ 从小到大排序，这样的话对于 $r_i \leq r_j$，只要 $r_j$ 满足限制，$r_i$ 就一定满足限制。

然后令 $dp_{i,j,k}$ 表示对于前 $i$ 个磁铁，分成 $j$ 组，共占用的长度为 $k$ 的方案数。转移分三种情况。$i$ 作为新的一组，$dp_{i,j,k}=dp_{i-1,j-1,k-1}$。$i$ 连接前 $j$ 个组中的某一个的一端，$dp_{i,j,k}=dp_{i,j,k}+dp_{i-1,j,k-r_i} \times j \times 2$。$i$ 把前面两个组连接起来，$dp_{i,j,k}=dp_{i,j,k}+dp_{i-1,j+1,k-2 \times r_i + 1} \times j \times (j+1)$，乘 $j \times (j+1)$ 的原因是随机选出两个组连接起来，顺序有影响，方案数是 $A_j^2$。

最后对答案有贡献的状态为 $dp_{n,1,k}$。然而占用 $k$ 个长度后可能还会剩下一些长度，这些长度可以放在任意两个磁铁间。方案数相当于是 $x_1+..+x_{n+1}=l-k$ 的整数解的个数。根据插板法，易得方案数为 $C_{l-k+n}^n$。因此 $ans=\sum_{k=1}^m dp_{n,1,k} \times C_{l-k+n}^n$。

code
```
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=60,M=10010,mod=1e9+7;
int n,m;
int r[N];
int dp[N][N][M];
int f[M+N],g[M+N];
inline int ksm(int a,int b)
{
    int res=1;
    while (b)
    {
        if (b&1) res=1ll*res*a%mod;
        a=1ll*a*a%mod;
        b>>=1;
    }
    return res;
}
inline void prework()
{
    f[0]=g[0]=1;
    for (int i=1;i<N+M;++i)
    {
        f[i]=i*f[i-1]%mod;
        g[i]=g[i-1]*ksm(i,mod-2)%mod;
    }
    return;
}
inline int get(int a,int b)
{
    return f[a]*g[b]%mod*g[a-b]%mod;
}
signed main()
{
	scanf("%lld%lld",&n,&m);
	for (int i=1;i<=n;++i) scanf("%lld",&r[i]);
	sort(r+1,r+n+1);
	prework();
	dp[0][0][0]=1;
	for (int i=1;i<=n;++i)
	{
		for (int j=1;j<=i;++j)
		{
			for (int k=1;k<=m;++k)
			{
				dp[i][j][k]=dp[i-1][j-1][k-1];
				if (k>=r[i]) dp[i][j][k]=(dp[i][j][k]+dp[i-1][j][k-r[i]]*j%mod*2)%mod;
				if (k>=2*r[i]-1) dp[i][j][k]=(dp[i][j][k]+dp[i-1][j+1][k-2*r[i]+1]*j%mod*(j+1)%mod)%mod;
			}
		}
	}
	int ans=0;
	for (int k=1;k<=m;++k) ans=(ans+dp[n][1][k]*get(m-k+n,n)%mod)%mod;
	printf("%lld\n",ans); 
	return 0;
}
```


---

## 作者：daniEl_lElE (赞：1)

新颖的 $dp$。

## 思路

难在状态设计。

考虑 $dp_{i,j,k}$ 表示**从小到大**看到第 $i$ 个磁铁，目前组成了 $j$ 段，不可以放磁铁的长度为 $k$。

每次可以考虑合并两段，添加一段左右或单独成一段，分别转移即可。

最后统计答案的时候可以考虑枚举 $k$，从 $l$ 中删除 $k$ 点后选取 $n$ 个点作为放置 $n$ 个磁铁的点即可。

复杂度 $O(n^2l)$。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
int qp(int a,int b){
	int ans=1;
	while(b){
		if(b&1) ans=(ans*a)%mod;
		a=(a*a)%mod;
		b>>=1;
	}
	return ans;
}
int fac[10000005],inv[10000005];
void init(){
	fac[0]=1;
	for(int i=1;i<=10000000;i++) fac[i]=fac[i-1]*i%mod;
	inv[10000000]=qp(fac[10000000],mod-2);
	for(int i=9999999;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;
}
int C(int i,int j){
	if(i<0||j<0||i<j) return 0;
	return fac[i]*inv[i-j]%mod*inv[j]%mod;
}
int dp[55][55][20005];
signed main(){
	init();
	int n,l;
	cin>>n>>l;
	int a[n+1];
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) a[i]--;
	sort(a+1,a+n+1);
	dp[0][0][0]=1;
	for(int i=1;i<=n;i++){
		for(int j=0;j<=n;j++){
			for(int k=0;k<=l;k++){
				if(j>0){
					(dp[i][j-1][k+2*a[i]]+=dp[i-1][j][k]*j%mod*(j-1)%mod)%=mod;
				}
				(dp[i][j][k+a[i]]+=dp[i-1][j][k]*2%mod*j%mod)%=mod;
				(dp[i][j+1][k]+=dp[i-1][j][k])%=mod;
			}
		}
	}
	int ans=0;
	for(int j=0;j<=l;j++){
		(ans+=(dp[n][1][j]*C(l-j,n)%mod))%=mod;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：jockbutt (赞：1)

一道挺有意思的计数打牌。

# Solution

首先，发现 $ n $ 很小，但是却不能状压，于是考虑高复杂度的暴力计数打牌
。

磁铁磁力影响的长度有大有小，不太好处理，但是经思考发现，如果将磁铁从小到大排一个序放置，在放置时，一定是后面的磁铁先吸引前面的磁铁。

接着，我们考虑后面的磁铁的放置方式。

我们定义若干个挨在一起的磁铁组成的段落叫连通块，连通块中间无法再放置磁铁。再定义 $ f_{i,j,k} $为插入前 $ i $ 个磁铁，已经分成 $ j $ 个连通块，其中还有 $ k $ 个空位没有被占有的情况。

这样，对于第 $ i $ 个磁铁，我们有以下三种情况。

### 一：将磁铁新开一个连通块

新开一个连通块，连通块数量增加了一，而空位也会被占用一个，所以对于 $f_{i,j,k} $，应该加上$f_{i-1,j-1,k-1}$。

### 二：将磁铁连接在第 $ j $ 个连通块的头部或者尾部

这样，连通块的数量没有变化，但是位置会被占掉 $ r_i $ 个单位，因为有 $j $ 个连通块可以添加，可以添加到头或者尾，于是应该加上 $ f_{i-1,j,k-r_i} \times j \times 2$。

### 三：用磁铁连接其中两个连通块

因为是连接两个连通块，连通块的数量会减少一个，所剩的距离也会减少 $ 2 \times r_i -1 $ 。因为可以连接任意两个连通块，所以应该加上$ f_{i-1,j+1,k-2 \times r_i +1} \times j \times (j+1)$。

最后，所有磁铁都会被用完，当然只会剩下一个连通块。但是剩下的长度可以插在任意两个磁铁中间。所以 $ ans $ 要加上：
### $ \sum_{i=1}^{l} f_{n,1,i} \times C_{l-i+n}^{n} $

完了。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9')	{if(ch=='-')f=-1;ch=getchar();}
	while('0'<=ch&&ch<='9')	{x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
int n,l;
const int maxn=1e4+10,mo=1e9+7;
int a[maxn];
int fac[maxn+10],inv[maxn+10];
inline void init()
{
	fac[1]=1;
	for(int i=2;i<=maxn;++i)	fac[i]=(fac[i-1]*i)%mo;
	inv[0]=inv[1]=1;
	for(int i=2;i<=maxn;++i)	inv[i]=(mo-mo/i)*inv[mo%i]%mo;
	for(int i=1;i<=maxn;++i)	inv[i]=(inv[i]*inv[i-1])%mo;
}
inline int C(int x,int y)	{return fac[x]*inv[y]%mo*inv[x-y]%mo;}
int f[60][60][maxn];
signed main(){
	init();
	n=read(),l=read();
	for(int i=1;i<=n;++i)	a[i]=read();
	sort(a+1,a+1+n);
	f[0][0][0]=1;
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=i;++j)
		{
			for(int k=1;k<=l;++k)
			{
				f[i][j][k]=f[i-1][j-1][k-1];
				if(k>=a[i])	f[i][j][k]+=f[i-1][j][k-a[i]]*j*2;
				if(k>=a[i]*2-1)	f[i][j][k]+=f[i-1][j+1][k-2*a[i]+1]*j%mo*(j+1);
				f[i][j][k]%=mo;
			}
		}
	}
	int ans=0;
	for(int i=1;i<=l;++i)	ans=(ans+f[n][1][i]*C(l-i+n,n))%mo;
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：FReQuenter (赞：0)

考虑 dp。

首先将 $r_i$ 从小到大排序，便于后续处理。

考虑一个二维的状态定义：$f_{i,j}$ 表示当前看到第 $i$ 个磁铁，总共使用了 $j$ 个空位。

贪心地，我们认为两个相邻的磁铁越靠近越优。

考虑转移。向左、向右添加下一个磁铁都很好处理。但是我们不方便把这个状态一分为二在中间添加磁铁。

考虑加一维 $k$。令 $f_{i,j,k}$ 表示当前看到第 $i$ 个磁铁，有 $j$ 个连通块（即磁铁紧挨着尽可能靠近）使用了 $j$ 个空位。

转移：

产生一个新的连通块：$f_{i,j,k}\gets f_{i-1,j-1,k-1}$

与上一个连通块有一个端点相连：$f_{i,j,k}\gets f_{i-1,j,k-r_i}\times 2\times j(k\geq r_i)$

有两个端点相连：$f_{i,j,k}\gets f_{i-1,j+1,k-r_i\times2+1}\times (j+1)\times j(k\geq r_i\times2-1)$

```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 1000000007 
using namespace std;
int n,l,ans,r[55],f[55][55][10005];
int jc[10005],inv[10005]; 
int qpow(int a,int n){
	int ans=1;
	while(n){
		if(n&1) ans*=a,ans%=mod;
		a*=a,a%=mod,n>>=1; 
	}
	return ans;
}
void init(){
	jc[0]=1;
	for(int i=1;i<=10000;i++) jc[i]=jc[i-1]*i%mod;
	for(int i=1;i<=10000;i++) inv[i]=qpow(jc[i],mod-2);
}
int C(int n,int m){
	if(n<m) return 0;
	if(n==m) return 1;
	return jc[n]*inv[m]%mod*inv[n-m]%mod;
}
signed main(){
	cin>>n>>l;
	init();
	for(int i=1;i<=n;i++) cin>>r[i];
	sort(r+1,r+n+1);
	f[0][0][0]=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++){
			for(int k=1;k<=l;k++){
				f[i][j][k]=f[i-1][j-1][k-1];
				if(k>=r[i]) f[i][j][k]+=f[i-1][j][k-r[i]]*j%mod*2%mod,f[i][j][k]%=mod;
                if(k>=r[i]*2-1) f[i][j][k]+=f[i-1][j+1][k-r[i]*2+1]*(j+1)%mod*j%mod,f[i][j][k]%=mod;
			}
		}
	}
	for(int i=1;i<=l;i++) ans+=f[n][1][i]*C(l+n-i,n)%mod,ans%=mod;
	cout<<ans;
}
```

---

## 作者：Forg1weN (赞：0)

## 题面

给定 $n$ 个磁铁和 $l$ 个空位，其中相邻空位之间的距离为 $1$，每个空位可放置一个磁铁。所有 $n$ 个磁铁都必须被放置。每个磁铁可以吸引距离小于 $r_i$ 的其它磁铁。

求所有磁铁互不吸引的方案总数对 $10^9+7$ 取模的结果。

$1 \le n \le 50$，$n \le l \le 10000$，$1 \le r_i \le l$。

## Solution
由于磁铁的放置顺序是不固定的，且难以表示放置顺序，所以考虑放置状态。

又因为 $a_i$ 的大小是无序的，所以要将 $a_i$ 升序排序。

插入DP，记 $f_{i,j,k}$ 表示放入了 $i$ 个磁铁，形成了 $j$ 个紧密相连的连通块，此时还剩下 $k$ 个空位。

先考虑在原有块的两段插入一个新磁铁。

$f_{i,j,k}=f_{i-1,j,k-a_i}\times j \times 2$。

接着考虑在合并原来的两个块，则两块之间的距离固定为 $2\times a_i -1$。

$f_{i,j,k}=f_{i-1,j+1,k-(2\times a_i -1)}\times A_{j+1}^{2}$。

最后是别的题解没讲清楚的一步，即新来的磁铁单独成块，先放公式：

$f_{i,j,k}=f_{i-1,j-1,k-1}$。

为什么新来的独立成块的磁铁只让 $k$ 个空位少了 $1$ 个，是因为后来的状态是从原有的块上操作，相当于本块让空位左右两边少了 $2\times a_i$ 个，但是后来的磁铁 $j$ 加入了这个块中，让原块内磁铁的贡献变得与 $a_j$ 有关而与 $a_i$ 无关，所以对于一个块内的贡献只需考虑后面加入块内的元素而非第一个加入的元素即可。

最后我们得到了一个紧密相连的连通块，现在可以在其中任意的插入空格。根据排列组合相关知识可知：

$ans=\sum\limits_{i=1}^{l}f_{n,1,i}\times C_{l-i+n}^{n}$。
## code 
根据以上可写，不做赘述。

---


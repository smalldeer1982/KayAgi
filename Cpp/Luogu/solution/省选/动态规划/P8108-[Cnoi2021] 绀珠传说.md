# [Cnoi2021] 绀珠传说

## 题目背景

Cirno 编写了一款新的游戏「绀珠传说 ~ Tales of Cyansis Pearl」。


游戏示例（样例 #1）:

![](https://cdn.luogu.com.cn/upload/image_hosting/pxvo35po.png)

## 题目描述

游戏规则如下:

初始有一个 $n\times n$ 的网格，每个格子内有一颗绀珠。

绀珠共有 $n$ 种颜色，每种颜色的恰有 $n$ 颗，**均匀随机**地分布在 $n\times n$ 的网格中。

每次玩家可以在网格的底端一行选取若干个连续相同颜色的绀珠并将其消除。

消除后，上层绀珠会受重力影响下落。

玩家重复上述操作直至绀珠全部被消除。游戏结束。

现在，Cirno 给定你游戏绀珠传说的一个**均匀随机**的初始局面，求完成游戏的最小步数。

## 说明/提示

对于 $100\%$ 的数据保证 $1 \le n \le 1000$。保证数据**随机生成**。

## 样例 #1

### 输入

```
3
1 1 2
2 3 1
3 2 3```

### 输出

```
5```

## 样例 #2

### 输入

```
5
2 1 4 4 2
2 5 5 1 3
4 1 3 5 1
3 2 5 3 5
1 4 4 2 3```

### 输出

```
15```

# 题解

## 作者：dead_X (赞：6)

## 前言
Cnoi 永远的神！
## 思路
首先我们考虑只有两列的情况，发现这就是求一个 LCS 的问题：可以一列消一块，或者两列底部相同的时候都消掉。

不难发现推广到 $n$ 列的时候也是对的，这就相当于将一起消掉的多个元素连在一起，连边之间不能有交，答案即为 $n^2-\sum f_i$，$f_i$ 为第 $i$ 列和第 $i+1$ 列的 LCS。

然后注意到 LCS 问题如果不是排列只能做到 $O(n^2)$ 啊，做 $n$ 次就是 $O(n^3)$ 的，根本过不去，难道这是牛逼论文题？

我们突然发现数据好像是随机的啊，那么这有啥性质呢？

冷静分析一下这和排列也差不多啊，每种颜色只出现了 $O(1)$ 次，将这些相同的 $(i,j)$ 全部记录下来，这就还是相当于一个 $O(n)$ 个点的最长上升子序列，直接做就是 $O(n\log n)$ 的，总时间复杂度 $O(n^2\log n)$。
## 代码
```cpp
// Problem: P8108 [Cnoi2021]绀珠传说
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P8108?contestId=46585
// Memory Limit: 512 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

//And in that light,I find deliverance.
#include<bits/stdc++.h>
// #pragma GCC optimize("Ofast")
// #pragma GCC optimize("unroll-loops")
// #pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native")
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int tree[1003],n=read();
int a[1003][1003];
vector<int> v[1003][1003];
void add(int x,int k)
{
	while(x<=n) tree[x]=max(tree[x],k),x+=x&(-x);
	return ;
}
int find(int x)
{
	int res=0;
	while(x) res=max(res,tree[x]),x-=x&(-x);
	return res;
}
signed main()
{
	for(int j=n; j>=1; --j)
		for(int i=1; i<=n; ++i)	
			v[i][a[i][j]=read()].push_back(j);
	int ans=n*n;
	for(int i=1; i<n; ++i)
	{
		for(int j=1; j<=n; ++j) tree[j]=0;
		int q=0;
		for(int j=1; j<=n; ++j) 
		{
			vector<pair<int,int>> z;
			for(int k:v[i][a[i+1][j]]) 
				z.push_back(make_pair(k,find(k-1)));
			for(auto k:z)
				q=max(q,k.second+1),add(k.first,k.second+1);
		}
		ans-=q;
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Tzs_yousa (赞：4)

这个题就是~~消消乐~~嘛。

这篇题解也是用树状数组来维护的，不过希望讲的清晰一些，因为别的题解太高深了，哭哭。

# 思路
首先如果每次只删一个，那就是需要删 $n^2$ 次。

那我们需要求的就是有多少绀珠可以连在一起删掉，再减去这个数就是最后的答案。

**那我们要怎么求这个数呢？**
	
每条边都是建立在相邻的两列之间，而且边上的两个颜色相同，那就可以给相邻两列相同颜色的绀珠建边。

**要取哪些边，怎么取？**

我们希望要取得边数最多且它们都不相交，如果相交的话就不存在一种情况可以使它们都出现在同一行，这个可以通过树状数组维护，不存在逆序对就是合法的情况，然后再找出合法情况下最多的一种建边方式即可。

具体写法在代码注释里
# code
```cpp
#include <bits/stdc++.h>
#define int long long
const int MAXN = 1010;
using namespace std;
int n, a[MAXN][MAXN], ans, sum, b[MAXN], w[MAXN];
int head[MAXN], cnt;
struct edge{
	int to, next;
}e[MAXN << 1];
int lowbit(int x)
{
	return x & -x;
}
void add(int x, int v)
{
	while(x <= n)
	{
		b[x] = max(b[x], v);
		x += lowbit(x);
	}
}
int query(int x)
{
	int res = 0;
	while(x)
	{
		res = max(res, b[x]);
		x -= lowbit(x);
	}
	return res;
}
vector<int> v[MAXN][MAXN], g[MAXN];
signed main()
{
	scanf("%lld", &n);
	ans = n * n;
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			scanf("%lld", &a[i][j]);
			v[j][a[i][j]].push_back(i);//存第j列颜色为a[i][j]的行 
		}
	}
	for (int i = 1; i < n; i++)
	{
		for (int j = 1; j <= n; j++)
			for (int p = 0; p < v[i][j].size(); p++)
				for (int q = 0; q < v[i + 1][j].size(); q++)
					g[v[i][j][p]].push_back(v[i + 1][j][q]);//第i列，颜色为j的第p个行，将这个行与下一列这个颜色的行建边 
		sum = 0;
		for (int j = 1; j <= n; j++)
		{
			for (int p = 0; p < g[j].size(); p++) 
			{
				w[p] = query(g[j][p] - 1) + 1;//下一列与第j行相连的边，w[p]是一共消去多少 
				sum = max(sum, w[p]);
			}
			for (int p = 0; p < g[j].size(); p++) add(g[j][p], w[p]);//加到树状数组里 
			g[j].clear();//情况，方便下次计算 
		}
		ans -= sum;//减去可以连着消掉的，也就是减掉最大的那个可以满足偏序的集合 
		for (int j = 1; j <= n; j++) b[j] = 0; 
	}
	printf("%lld", ans);
	return 0;
}
```


---

## 作者：minstdfx (赞：3)

爱过不过。

果然我这样的彩笔写出来的题解充斥着一股“看上去好像没啥大问题但是为什么总觉得是低质量题解如果我把它放过了那么浑身难受不自在好像欠了洛谷一个亿”的感觉。

显然 $n^2$ 次操作可以干爆这些绀珠，因为每次操作怎么说都能消掉一个点。

对于一个操作，假设在我们最终钦定的操作结果中，它消掉了 $\{S_{x_1,y_1},S_{x_2,y_2},\cdots,S_{x_n,y_n}\}$ 这些点，那么我们可以理解成，先通过前面的操作把 $S_{x_n,y_n}$ 消到最底层，然后在前面的列执行 $\{S_{x_1,y_1},S_{x_2,y_2},\cdots,S_{x_{n-1},y_{n-1}}\}$ 的时候一波消顺便带走最后一个。

因此操作是可以从左往右扩展的。从左往右钦定操作，对于相邻的两列（我们姑且设为 $S_i=\{S_{i,1},S_{i,2},\cdots,S_{i,n}\}$ 和 $S_{i+1}=\{\texttt{\small{我懒得写了，同理}}\}$），显然要一起带走的点对之间不能相交，又要尽可能多，所以相当于求 LCS。

因此答案为 $n^2-\sum{\operatorname{lcs}(S_i,S_{i+1})}$。

问题是，本题好像没说是排列，任意序列做复杂度是不是平方的啊，是不是根本写不了啊，bzy 是不是又喝了假⑨来出题毒瘤我这样的小朋友啊。

注意到数据随机。很显然这题又是一道利用随机数据性质的没有正规解法的题目 ~~bzy 你坏事做尽~~。在随机数据下，每一列期望来看是没有多少同色的绀珠（每种颜色 $O(1)$）的。那么对于后一列的每一个绀珠 $S_{i+1,j}$，记下前一列中每一个和它颜色一致的位置。

考虑 LCS 的过程：

$$dp_{i,j}=\max\{dp_{i-1,j},dp_{i,j-1},[a_i=b_j]\times dp_{i-1,j-1}\}$$

第三项转移的次数即为相同点对数，期望为线性。

针对第三项转移的情况大力搞一搞，维护 $f_i$ 表示当前情况下(扫到第二列的前 $j$ 个），第一列以第 $i$ 个结尾的子串的最大匹配长度。

$$f_i=\max\{f_i,\max_{k<i}\{f_k+1\}\}({\forall S_{n',i}=S_{n'+1,j}})$$

随便树状数组维护一下，就完事了。

```cpp
int work(int ans=n*n)
{
    for(int i=1;i<=n;++i)
        for(int j=1;j<=n;++j)
            _index[j][col[i][j]].push_back(i);
    for(int i=1,ms=0;i<n;++i,memset(c,0,sizeof(c)),ms=0)
    {
        for(int j=1;j<=n;++j)
        {
            tot=0;
            for(auto k:_index[i][col[j][i+1]])
                indexes[++tot]=k,val[tot]=query(k-1);
            for(int k=1;k<=tot;++k)
                ms=max(ms,val[k]+1),update(indexes[k],val[k]+1);
        }
        ans-=ms;
    }
    return ans;
}
```
妈的，`index` 居然是保留字


---

## 作者：whiteqwq (赞：2)

[P8108 [Cnoi2021]绀珠传说](https://www.luogu.com.cn/problem/P8108) 解题报告：

[更好的阅读体验](https://www.cnblogs.com/xiaoziyao/p/15865051.html)

## 题意

给定一个 $n\times n$ 的网格，用 $n$ 种颜色染色，每种颜色恰好染 $n$ 次，保证染色均匀随机。

你每次可以选择底端某一行连续的一个同色段，并将其消除，其上面的颜色都会因为重力掉下去。（感性理解一下）

最小化操作次数。

$1\leqslant n\leqslant 1000$。

## 分析

很有意思的题。

考虑每次消除的时候，将相邻的格子连边，考察它在游戏开始前的形态：

我们发现只有相邻的列之间有连边，且连边一定是不交的；反之，如果连边满足前面的约束，一定存在一种消除方式使得连边的格子在一次操作内被消除。

那么我们需要最大化连边数量，而由于第一条性质，不同列的连边之间互不影响，于是我们只用考虑两列之间的连边。

我们将边 $(i,a)-(i+1,b)$ 作为二维平面上的点 $(a,b)$，可以发现可以共存的边一定两两满足偏序关系，那么直接树状数组扫一遍即可。

由于颜色是均匀随机的，每一列期望的颜色数量是 $O(1)$ 的，那么总复杂度为 $O(n^2\log n)$。

## 代码

记得不要把行和列写反（

```
#include<stdio.h>
#include<algorithm>
#define lowbit(x) (x&-x)
using namespace std;
const int maxn=1005;
int n,ans;
int a[maxn][maxn],t[maxn],tmp[maxn];
vector<int>v[maxn][maxn];
vector<int>p[maxn];
void update(int x,int v){
	for(int i=x;i<=n;i+=lowbit(i))
		t[i]=max(t[i],v);
}
int query(int x){
	int res=0;
	for(int i=x;i;i-=lowbit(i))
		res=max(res,t[i]);
	return res;
}
int main(){
	scanf("%d",&n),ans=n*n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			scanf("%d",&a[i][j]),v[j][a[i][j]].push_back(i);
	for(int i=1;i<n;i++){
		for(int j=1;j<=n;j++)
			for(int a=0;a<v[i][j].size();a++)
				for(int b=0;b<v[i+1][j].size();b++)
					p[v[i][j][a]].push_back(v[i+1][j][b]);
		int res=0;
		for(int j=1;j<=n;j++){
			for(int k=0;k<p[j].size();k++)
				tmp[k]=query(p[j][k]-1)+1,res=max(res,tmp[k]);
			for(int k=0;k<p[j].size();k++)
				update(p[j][k],tmp[k]);
			p[j].clear();
		}
		ans-=res;
		for(int j=1;j<=n;j++)
			t[j]=0;
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Purslane (赞：0)

# Solution

注意到答案显然等于 $n^2 - \sum_{i=2}^n \text{LCS}(column_{i-1},column_i)$（显然考察每一列，其格子会自下而上按顺序删掉。我们需要尽可能利用上一列已有的成果。）

问题转化为怎么求两个序列的 $\rm LCS$。如果你做过[这道题](https://www.luogu.com.cn/problem/P1439)，那么很容易想把这道题转化为 $\rm LIS$ 问题。

不是排列怎么办？假设我们处理序列 $a$ 和 $b$，$v$ 在 $b$ 中出现的集合为 $S_v$。那么我们按顺序将 $S_{a_i}$ 中元素**倒序排列**，拼接在一起。此时求 $\rm LIS$ 显然正确。

这样做的总复杂度为 $\sum_{i=1}^n \sum_{j=2}^n cnt_{i,j} cnt_{i,j-1}$，其中 $cnt_{i,j}$ 表示颜色 $i$ 在第 $j$ 列出现的次数。

保证了数据随机，而且 $\sum_{j} cnt_{i,j} = n$，所以我们相信它很小（数学太菜了没有一眼看出来证明方法）。

复杂度 $O(能过)$。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1000+10;
int n,ans,a[MAXN][MAXN],tr[MAXN];
vector<int> occ[MAXN];
void update(int pos,int v) {while(pos<=n) tr[pos]=max(tr[pos],v),pos+=pos&-pos;return ;}
int query(int pos) {int ans=0;while(pos) ans=max(ans,tr[pos]),pos-=pos&-pos;return ans;}
int solve(vector<int>& vc) {
	memset(tr,0,sizeof(tr));
	int ans=0;
	for(auto id:vc) {
		int v=query(id-1)+1;
		ans=max(ans,v),update(id,v);
	}
	return ans;
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n;
	ffor(i,1,n) ffor(j,1,n) cin>>a[i][j];
	ans=n*n;
	ffor(j,2,n) {
		ffor(i,1,n) occ[i].clear();
		roff(i,n,1) occ[a[i][j]].push_back(i);
		vector<int> vc;
		ffor(i,1,n) for(auto id:occ[a[i][j-1]]) vc.push_back(id);
		ans-=solve(vc);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：_Cheems (赞：0)

假设让每个点都独自删去，答案是 $n^2$，考虑合并一些操作。

抽出两列单独观察，那么发现颜色相同的点对可以合并操作，需要满足这些操作点对不相交，才一定存在一种对应方案。也就是两列的 $\rm LCS$ 了。

发现不相邻的两列不会互相影响，也就是上述结论可以推广到整个方阵，记 $g_i$ 表示 $i$ 列和 $i+1$ 列的 $\rm LCS$ 长度，答案就是 $n^2-\sum\limits_{i<n} g_i$。

现在考虑怎么求 $g$，朴素暴力 $O(n^3)$，注意到数据均匀随机，也就是说一列内的元素几乎是个排列。换种角度考虑问题，将相邻两列的元素视作二分图的两部，那么让相邻元素连边，等价于求最大匹配。

由于二分图边数期望是 $O(n)$ 的，可以依此设计出 $\rm dp$，令第 $t+1$ 列元素从底向上是 $B_1\dots B_n$，并遍历第 $t$ 列的元素 $A_1\dots A_n$。记 $f_{j}$ 表示目前为止只向 $B_1\dots B_j$ 连边的最大匹配数，若当前 $A_i$ 可以向 $B_k$ 连边，有转移 $f_{k} = \max(f_1\dots f_{k-1})+1$。

可以视作单点改、区间查，树状数组即可。随机数据下期望复杂度 $O(n^2\log n)$。
#### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e3 + 5;
int n, a[N][N], ans;
vector<int> pos[N];

namespace BIT{
	int t[N];
	inline void clen() {memset(t, 0, sizeof t);}
	inline void add(int a, int k) {for(; a < N; a += a & -a) t[a] = max(t[a], k);}
	inline int qry(int a) {int res = 0; for(; a; a -= a & -a) res = max(res, t[a]); return res;}
}using namespace BIT;
int main(){
	cin >> n;
	for(int i = n; i; --i)
		for(int j = 1; j <= n; ++j) scanf("%d", &a[i][j]);
	ans = n * n;
	for(int t = 1; t < n; ++t){
		clen();
		for(int i = 1; i <= n; ++i) pos[i].clear();
		for(int i = n; i; --i) pos[a[i][t + 1]].push_back(i);
		for(int i = 1; i <= n; ++i)
			for(auto v : pos[a[i][t]]) add(v, qry(v - 1) + 1);
		ans -= qry(n);
	}
	cout << ans;
	return 0;
}

```

---

## 作者：Otomachi_Una_ (赞：0)

## 题目简述

> - 给一个 $n\times n$ 的方格上面只能连续消底层的消消乐。
> - 求最小消除步数。
> - $n,m\leq 10^3$，**数据随机**。

## 解题思路

考虑只有两列的时候，相当于每次操作可以消最底下的一个或者消底下颜色相同的两个，这显然是 _最长公共子序列_。扩展到 $n$ 个同理，也就是答案是：
$$
n^2-\sum_{i=1}^{n-1} f(i,i+1)
$$
其中 $f(i,i+1)$ 表示 $i,i+1$ 列的 LCS。

审视 LCS 的 dp 法，转移方程是：
$$
dp[j]\leftarrow \max(dp[j],\max_{k=1}^{j-1} dp[k]+1)(a[i]=b[j])
$$
这个式子需要维护前缀最大，显然可以树状数组。数据随机可以做到 $O(n^2\log n)$。

## 参考代码

```cpp
#include<iostream>
#include<vector>
using namespace std;
const int MAXN=1005;
int n,ans;
int a[MAXN][MAXN],g[MAXN];
vector<int> ve[MAXN];
namespace func{
int f[MAXN];
int lowbit(int x){
	return x&(-x);
}
void build(){
	for(int i=1;i<=n;i++)
		f[i]=0;
}
void add(int x,int d){
	while(x<=n){
		f[x]=max(f[x],d);
		x+=lowbit(x);
	}
	return;
}
int ask(int x){
	int res=0;
	while(x){
		res=max(res,f[x]);
		x-=lowbit(x);
	}
	return res;
}
}
int main(){
	cin>>n;ans=n*n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>a[i][j];
	for(int i=1;i<n;i++){
		for(int j=1;j<=n;j++) ve[j].clear(),g[j]=0;
		for(int j=n;j>=1;j--) ve[a[j][i]].push_back(j);
		func::build();
		for(int j=1;j<=n;j++)
			for(int k:ve[a[j][i+1]]){
				int d=func::ask(k-1);
				g[k]=max(g[k],d+1);
				func::add(k,g[k]);
			}
		ans-=func::ask(n);
	}
	cout<<ans;
	return 0;
}
```



---

## 作者：loser_seele (赞：0)

这篇题解感觉是个缝合怪。喜提最劣解。

这里提供一个不基于数据随机的做法。

其他题解已经讲到过结论的证明，这里不再详述。如果每次只删除 $ 1 $ 个则一共显然需要 $ n^2 $ 次操作，考虑相邻两列的情况可以减去一个 LCS，于是问题转化为快速地求 $ n $ 个LCS的和。

但是问题来了：不保证给定的数组是排列，那么看上去只能朴素 dp 做到 $ n^2 $，总时间复杂度 $ n^3 $，并不是我们想要的结果。

于是这里就需要引入科技：bitset 优化 LCS。

参考 [这篇题解](https://www.luogu.com.cn/blog/kamino/solution-sp12076#) 的做法，可以在不基于字符集限制的情况下 $ \mathcal{O}(\frac{n^2}{w}) $ 的时间复杂度求 LCS，这里因为手写所以取 $ w=32 $。

于是我们得到一个 $ \mathcal{O}(\frac{n^3}{w}) $ 的做法，可以通过本题，并不依赖于数据随机。注意代码里 $ M $ 的取值不能太大，应该在 $ \frac{N}{32} $ 的级别，否则会超时。

代码：

```cpp
#import <bits/stdc++.h>  
using namespace std;
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
const int N = 1010, M = 65;
int n, m;
int mapp[N][N];
int a[N],b[N];
struct BitSet 
{
    unsigned int a[M];
} Ans, X, Y, A[N];
BitSet operator&(BitSet a, BitSet b) 
{
    for (int i = 0; i < M; i++) 
    a.a[i] &= b.a[i];
    return a;
}
BitSet operator^(BitSet a, BitSet b) 
{
    for (int i = 0; i < M; i++) 
    a.a[i] ^= b.a[i];
    return a;
}
BitSet operator|(BitSet a, BitSet b) 
{
    for (int i = 0; i < M; i++) 
    a.a[i] |= b.a[i];
    return a;
}
void operator-=(BitSet &a, BitSet b) 
{
    unsigned int last = 0;
    for (int i = 0; i < M; i++)
        if (a.a[i] >= b.a[i] + last)
            a.a[i] -= b.a[i] + last, last = 0;
        else
            a.a[i] -= b.a[i] + last, last = 1;
}
void operator<<=(BitSet &a, BitSet b)  
{
    unsigned int last = 1;
    for (int i = 0; i < M; i++) 
    {
        unsigned int x = b.a[i] >> 31;
        a.a[i] = (b.a[i] << 1 | last);
        last = x;
    }
}
void Insert(BitSet &A, int x) 
{ 
A.a[x >> 5] |= 1u << (x & 31); 
}
int count(BitSet A) 
{
    int ans = 0;
    for (int i = 0; i < M; i++) 
    ans += __builtin_popcount(A.a[i]);
    return ans;
}
int solve()
{
    for (int i = 1; i <= n; i++) 
        Insert(A[a[i]], i);
    for (int i = 1; i <= m; i++) 
    {
        Y <<= Ans;
        Ans = Ans | A[b[i]];
        X = Ans;
        X -= Y;
        Ans = Ans & (Ans ^ X);
    }
    int tmp=count(Ans);
    for(int i=1;i<=n;i++)
    memset(A[i].a,0,sizeof A[i].a);
    Ans=Ans^Ans;
    X=X^X;
    Y=Y^Y;
    return tmp;
}
int main() 
{
    cin>>n;
    m=n;
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    mapp[i][j]=read();
    int ans=n*n;
    for(int j=1;j<n;j++)
    {
    for(int i=1;i<=n;i++)
    a[i]=mapp[i][j];
    for(int i=1;i<=n;i++)
    b[i]=mapp[i][j+1];
    ans-=solve();
    }
    cout<<ans;
}
```


---


# 『JROI-4』沈阳大街 2

## 题目描述

给定两个长度为 $n$ 的序列 $A,B$，满足：

* $\forall 1\le i<n,A_i \ge A_{i+1}$ 

* $A_n\ge \min\limits_{i=1}^n(B_i)$

$\pi$ 是一个长度为 $n$ 的排列，定义价值函数 $f(\pi)$：

$$
f(\pi)=\prod_{i=1}^n\min(A_i,B_{\pi(i)})
$$

每种排列出现的概率相等，求 $f(\pi)$ 的期望对 $998244353$ 取模的结果。

即求:

$$
\left(\dfrac{1}{n!}\sum_\pi f(\pi)\right) \bmod 998244353
$$


## 说明/提示

**本题采用捆绑测试。**

|  子任务编号 | 分值 | 特殊限制 |
| :-----------: | :---:| :-----------: |
| 1 | 5 | $1\le n\le 8$ |
| 2 | 35 | $1\le n\le 50$ |
| 3 | 20 | $A_n\ge \max\limits_{i=1}^n(B_i)$ |
| 4 | 40 | 无 |

对于 $100\%$ 的数据满足 $1\le n\le 5000$，$1\le A_i,B_i\le 10^9$。

## 样例 #1

### 输入

```
8
15 14 13 10 9 6 3 2 
2 10 8 2 9 1 10 2 ```

### 输出

```
114102208```

# 题解

## 作者：Otomachi_Una_ (赞：19)

一道蒟蒻做不出来的喵喵题

## 题目简述

给定长度为 $n$ 的序列 $a,b$。$p$ 是 $1$ 到 $n$ 的排序，求：

$$(\dfrac{1}{n!} \sum_p \prod_{i=1}^n \min (a_i,b_{p_i}))$$

## 解题思路

我们把 $a,b$ 合并为一个新的数组 $c$。其中如果本来属于 $a$ 的染红，否则染蓝。对 $c$ 的数值从大到小排序，本题相当于这样的问题：

> 在 $c$ 中不重复的配对 $n$ 对红蓝对，配对的权值是后面的数的权值，求所有配对权值的和。

考虑 $\text{dp}$ 解决。假设 $f[i][j]$ 表示 $c[1,i]$ 当中配对了 $j$ 个的方案数。

转移方程：

$$f[i][j]=f[i-1][j-1]\times c[i]\times (tmp-(j-1))+f[i-1][j]$$

这里 $tmp$ 是 $c[1,i-1]$ 中与 $c[i]$ 不同色的数的个数。

时间复杂度 $\mathcal O(n^2)$ 常数比较小，完结撒花。

## 参考代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
#define ll long long
const int MAXN=5e3+5;
const int MOD=998244353;
ll f[MAXN<<1][MAXN];
int cnt[2][MAXN*2];
struct element{
	ll val,sub; 
}a[MAXN<<1];int n,A;
bool cmp(element x,element y){
	return x.val>y.val;
} 
ll ksm(ll a,int b){
	ll res=1;
	while(b){
		if(b&1) res=res*a%MOD;
		a=a*a%MOD;
		b=b>>1;
	}
	return res;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>A,a[i]=element{A,0};
	for(int i=1;i<=n;i++)
		cin>>A,a[i+n]=element{A,1};
	sort(a+1,a+2*n+1,cmp);
	for(int i=1;i<=2*n;i++){
		cnt[0][i]=cnt[0][i-1],
		cnt[1][i]=cnt[1][i-1];
		cnt[a[i].sub][i]++;
	}
	f[0][0]=1;
	for(int i=1;i<=2*n;i++){
		ll tmp=cnt[!a[i].sub][i];
		f[i][0]=1;
		for(int j=1;j<=min(n,i);j++){
			if(j<=tmp)
				f[i][j]=f[i-1][j-1]*a[i].val%MOD*(tmp-(j-1))%MOD;
			f[i][j]=(f[i-1][j]+f[i][j])%MOD;
		}
	}
	ll res=1;
	for(int i=1;i<=n;i++)
		res=res*i%MOD;
	cout<<ksm(res,MOD-2)*f[2*n][n]%MOD;
	return 0;
}
```


---

## 作者：Daidly (赞：7)

这题给的两个条件只对部分分有用，对正解无用（因为排列可以淡化条件一，而条件二对正解没有帮助）。

题目即求下式答案：

$$
\left(\dfrac{1}{n!}\sum_\pi\prod_{i=1}^n\min(A_i,B_{\pi(i)})\right) \bmod 998244353
$$

---

首先我们将 $B$ 序列的排列形式转换为 $A,B$ 两序列的匹配形式，即 $B$ 序列每一个数都与 $A$ 序列中一个数匹配，共有 $n!$ 种，这是我认为本题的最难点。

看到这种 $\sum\prod$ 形式的可以考虑提出相同项，那么我们对 $2n$ 个值考虑。在值域上 dp，记 $f[i][j]$ 为前 $i$ 大的值有 $j$ 对匹配的答案（前 $i$ 大可以保证我们此时的就是贡献的值，而匹配另一个的值我们不需要关系，只关心它的个数），最终结果即为 $f[2n][n]$。

状态转移方程如下：

$$
f[i][j]=f[i-1][j-1]\times c[i]\times cnt[i]+f[i-1][j]
$$

其中 $c$ 是 $A,B$ 在值域上从大到小组成的一个序列，$cnt[i]$ 表示 $c[i]$ 之前能匹配的个数（与 $c[i]$ 类型不相同的个数），这里相同值的也要考虑顺序，不能都统计上。

初始值的设定也需要注意，$f[i][0]=1$。某些数组要开 $2n$。

代码如下：

```cpp

#include<bits/stdc++.h>
using namespace std;

#define int long long

inline int read(){
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c<='9'&&c>='0'){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}

void print(int x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)print(x/10);
	putchar(x%10^48);
}

const int N=5e3+5,mod=998244353;

int qpow(int a,int b){
	int ans=1;
	while(b){
		if(b&1)ans=ans*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ans;
}

int n,a[N],b[N],f[N<<1][N],cnt[N<<1],num,c[N<<1];

bool cmp(int x,int y){return x>y;}

signed main(){
	n=read();
	for(int i=1;i<=n;++i)a[i]=read();
	for(int i=1;i<=n;++i)b[i]=read();
	sort(b+1,b+n+1,cmp);
	int p=1,q=1;
	while(p<=n&&q<=n){
		if(a[p]>=b[q])c[++num]=a[p],cnt[num]=q-1,p++;
		else c[++num]=b[q],cnt[num]=p-1,q++;
	}
	while(p<=n)c[++num]=a[p],cnt[num]=q-1,p++;
	while(q<=n)c[++num]=b[q],cnt[num]=p-1,q++;
	for(int i=0;i<=num;++i)f[i][0]=1;
	for(int i=1;i<=num;++i){
		for(int j=1;j<=cnt[i];++j){
			f[i][j]=(f[i-1][j-1]*c[i]%mod*(cnt[i]-j+1)%mod+f[i-1][j])%mod;
		}
	}
	int tmp=1;
	for(int i=2;i<=n;++i)tmp=tmp*i%mod;
	print(f[num][n]*qpow(tmp,mod-2)%mod),puts("");
	return 0;
}

```

---

## 作者：daniEl_lElE (赞：7)

非常值得一做的 $dp$ 模型。

## 思路

考虑式子中有 $\min$，**将两个序列合并**后操作，记录属于 $a$ 序列还是 $b$ 序列。

此时，这个问题变成了一个序列上的匹配问题，这种问题有个套路：

考虑 $dp_{i,j}$ 表示看到第 $i$ 小的，目前 $a$ 序列有 $j$ 个需要匹配后面的。

对于第 $i$ 位，我们很容易统计在第 $i$ 位之前有多少 $a$ 序列的，$b$ 序列的，因此存 $j$ 足以让我们推出前面有多少匹配好的和**有多少的 $b$ 序列的需要匹配后面一个数。**

此时我们考虑第 $i$ 小的数是匹配一个前面的或留下来匹配后面的，容易发现匹配后面的转移时系数就是这个数本身（由于排序了，$\min$ 一定是他），匹配前面的转移时系数则是另一个序列剩余的需要匹配后面一个数的个数。

复杂度 $O(n^2)$，空间小心点，不滚动可以过，但正式考试一定要尽可能优化！

****

这道题有两个套路值得学习（欢迎各位补充类似题）：

1. **序列 $\min/\max$ 计数**尝试排序后解决。
2. **序列匹配**计数问题的 $dp$ 套路。
3. **含固定辅助值**的 $dp$ 可以尝试寻找状态中变量关系来简化状态。

~~诶怎么说好两个来了三个。~~

## 代码

```cpp

#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
int qp(int a,int b){
	int ans=1;
	while(b){
		if(b&1) ans=(ans*a)%mod;
		a=(a*a)%mod;
		b>>=1;
	}
	return ans;
}
int fac[10005],inv[10005];
void init(){
	fac[0]=1;
	for(int i=1;i<=10000;i++) fac[i]=fac[i-1]*i%mod;
	inv[10000]=qp(fac[10000],mod-2);
	for(int i=9999;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;
}
struct node{
	int pos,tp;
}x[10005]; 
bool cmp(node A,node B){
	return A.pos<B.pos;
}
signed dp[10005][5005];
signed main(){
	init();
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x[i].pos;
		x[i].tp=1;
	}
	for(int i=n+1;i<=2*n;i++){
		cin>>x[i].pos;
		x[i].tp=2;
	}
	sort(x+1,x+2*n+1,cmp);
	dp[0][0]=1;
	int tot1=0,tot2=0;
	for(int i=1;i<=2*n;i++){
		for(int j=0;j<=n;j++){
			int gt=tot1-j;
			if(gt>tot2) continue;
			int lft1=j,lft2=tot2-gt;
			if(x[i].tp==1){
				//get a bigger one
				dp[i][j+1]=((int)dp[i][j+1]+(int)dp[i-1][j]*(int)x[i].pos)%mod; 
				//get a smaller one
				if(lft2) dp[i][j]=((int)dp[i][j]+(int)dp[i-1][j]*(int)lft2)%mod;
			}
			else{
				//get a bigger one
				dp[i][j]=((int)dp[i][j]+(int)dp[i-1][j]*(int)x[i].pos)%mod;
				//get a smaller one
				if(lft1) dp[i][j-1]=((int)dp[i][j-1]+(int)dp[i-1][j]*(int)lft1)%mod;
			}
		}
		if(x[i].tp==1) tot1++;
		if(x[i].tp==2) tot2++;
	}
	cout<<(int)dp[2*n][0]*inv[n]%mod;
	return 0;
}```

---

## 作者：dottle (赞：7)

首先把两个数组放到一起，从大到小排序。

考虑设 $dp_{i,j}$ 代表考虑了前 $i$ 个数，前面有 $j$ 个未匹配的 $b$ 数组的数。则可以根据前面的两类数的数量和 $j$ 算出没匹配的 $a$ 类数的数量。每次枚举当前数匹配后面的还是前面的。钦定在后面的数计算方案数，则匹配前面的数的系数为当前数的大小乘上前面未匹配的数量，匹配后面的数的系数为 $1$。

```cpp#include<bits/stdc++.h>
#define int long long
const int N=5050,mod=998244353;
using namespace std;

int n;
int a[N],b[N];
int f[N],g[N];

int gsc(int x,int y){
    int ans=1;
    for(int i=1;i<=y;i<<=1,x=x*x%mod)
        if(y&i)
            ans=ans*x%mod;
    return ans;
}int inv(int k){return gsc(k,mod-2);}

void rot(){
	memcpy(g,f,sizeof(g));
	memset(f,0,sizeof(f));
}
void add(int&x,int y){
	x+=y;if(x>=mod)x%=mod;
}

void solve(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i]; 
	for(int i=1;i<=n;i++)cin>>b[i];
	sort(b+1,b+1+n);
	reverse(b+1,b+1+n);
	f[0]=1;
	for(int k=1,j=1;;k++){
		while(j<=n&&b[j]>=a[k]){
			rot();
			for(int i=0;i<=n;i++){
				int t=k-1-(j-1-i);
				add(f[i],g[i]*t%mod*b[j]);
				add(f[i+1],g[i]);
			}
			j++;
		}
		if(k>n)break;
		rot();
		for(int i=0;i<=n;i++){
			add(f[i],g[i+1]*(i+1)%mod*a[k]);
			add(f[i],g[i]);
		}
	}
	for(int i=1;i<=n;i++)
		f[0]=f[0]*inv(i)%mod;
	cout<<f[0]<<endl;
}

main(){
	ios::sync_with_stdio(false);
	int _T=1;//cin>>_T;
	while(_T--)solve();
	
}
```

---

## 作者：SentoAyaka (赞：6)

来一种不需要与外星人沟通的做法。

可以无脑先写出一个 $O(n^4)$ 的 dp，设 $f_{i,j,k,l}$ 表示考虑到 $A$ 的第 $i$ 位，有 $j$ 个钦定为 $\min$ 且未填，$B$ 中同理。转移就考虑是作为 $\min$ 还是匹配之前的 $\min$。

发现 $i,k$ 的转移顺序必须从小到大还能满足匹配关系，于是可以把 $A,B$ 合并成一个序列，再设 $f_{i,j,k}$ 表示到新序列的第 $i$ 位， $A$ 中有 $j$ 个为 $\min$ 且未填，$B$ 中有 $k$ 个为 $\min$ 且未填。$A$ 转移如下，$B$ 同理：

$$f_{i,j+1,k}\leftarrow f_{i-1,j,k}\times A_i$$

$$f_{i,j,k-1}\leftarrow f_{i-1,j,k}\times k$$

这是一个 $O(n^3)$ 的，还得优化。

假设我们到新序列的 $i$，之前总共有 $x$ 个 $A$，$y$ 个 $B$。如果有 $j$ 个 $\min$ 未填，那么有 $x-j$ 个 $A$ 取 $\max$ 或 $\min$ 已填，这也代表着有 $x-j$ 个 $B$ 取 $\max$ 或 $\min$ 已填，因为 $A,B$ 是两两匹配的，于是 $k=y-(x-j)$。

所以我们只需要记录 $f_{i,j}$ 即可，$k$ 可以计算得到。复杂度 $O(n^2)$。

```cpp
#include<bits/stdc++.h>
#define db double
#define int ll
#define ll long long
#define ull unsigned long long
#define pb emplace_back
#define MP make_pair
#define pii pair<int, int>
#define vec vector<int>
#define fi first
#define se second
#define ls k<<1
#define rs k<<1|1
#define CLK (double)clock()/(double)CLOCKS_PER_SEC
using namespace std;
mt19937 rnd(time(0));
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
inline void write(int x){
    if(x<0){putchar('-');x=-x;}
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
const int N=5005,mod=998244353;
int n,m,f[2*N][N];pii a[N*2];
void add(int &x,int y){(x+=y)%=mod;}
int Qpow(int b,int p){
    int res=1ll;
    while(p){
        if(p&1)(res*=b)%=mod;
        (b*=b)%=mod;p>>=1;
    }
    return res;
}
void MAIN(){
    n=read(),m=0;
    for(int i=1;i<=n;i++)a[++m]=MP(read(),0);
    for(int i=1;i<=n;i++)a[++m]=MP(read(),1);
    sort(a+1,a+1+m);
    f[0][0]=1;
    for(int i=1,A=0,B=0;i<=m;i++){
        for(int j=0;j<=A;j++){
            int k=B-(A-j);
            if(a[i].se){
                add(f[i][j],f[i-1][j]*a[i].fi%mod);
                if(j)add(f[i][j-1],f[i-1][j]*j%mod);
            }
            else {
                add(f[i][j+1],f[i-1][j]*a[i].fi%mod);
                if(k)add(f[i][j],f[i-1][j]*k%mod);
            }
        }
        if(a[i].se)B++;else A++;
    }
    int inv=1;for(int i=1;i<=n;i++)inv=inv*i%mod;
    cout<<f[m][0]*Qpow(inv,mod-2)%mod;
}
signed main(){
    // freopen("read.in","r",stdin);
//	freopen("write.out","w",stdout);
    int T=1;while(T--)MAIN();
//  printf("\nTIME:%lf\n",(double)clock()/CLOCKS_PER_SEC);
    return 0;
}
```


---

## 作者：lndjy (赞：4)

出题人好可爱，贴贴/qq

把两个序列看成二分图，对于一个排列 $p$，左面点 $i$ 和右面点 $p_i$ 连一条边，这样就恰好形成一组完美匹配。

现在我们变成这样一个问题：$(i,j)$ 的边权是 $\min(A_i,B_j)$，定义一个完美匹配权值是所有边权的积，你要求所有完美匹配权值之和。

这样还是不太好做，考虑两个序列都从大到小排序，然后把边定向，定义成点权较小的点向点权较大的点的有向边。

这样定向后就有一个性质：**每个点的出边边权相同并且为这个点的点权，而且这些边指向的点为对面点一个前缀。**

设左面 $i$ 向 $[1,c_i]$ 连边，右面 $j$ 向 $[1,d_j]$ 连边。

考虑 dp。设 $f[i][j][k]$ 表示左面连到第 $i$ 点，右面连到第 $j$ 点，连了 $k$ 条边，权值为这 $k$ 条边权值之积，所有权值的和。其中满足 $j=c_i$ 或者 $i=d_j$。前面两维只有 $2n$ 状态，所以复杂度是对的。

转移考虑每次新加一个点，这个点的出边连谁就行。

怎么转移才能保证每次新加一个点呢，将所有点按照点权值排序即可。具体转移方程以及细节见代码。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read()
{
    char c=getchar();int x=0;bool f=0;
    for(;!isdigit(c);c=getchar())f^=!(c^45);
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
    if(f)x=-x;return x;
}
const int N=5005,p=998244353;
int qp(int x,int y)
{
	int ans=1;
	while(y)
	{
		if(y&1) ans=1ll*ans*x%p;
		x=1ll*x*x%p;
		y>>=1;
	}
	return ans;
}
struct node
{
	int op,val;
	bool operator <(const node &p)
	const
	{
		if(val!=p.val) return val>p.val;
		return op<p.op;
	}
}a[N*2];
int A[N],B[N],n;
int f[N*2][N],suma[N*2],sumb[N*2];
bool cmp(int x,int y)
{
	return x>y;
}
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>A[i];
		a[i]=(node){1,A[i]};
	}
	for(int i=1;i<=n;i++)
	{
		cin>>B[i];
		a[i+n]=(node){2,B[i]};
	}
	sort(a+1,a+2*n+1);
	for(int i=1;i<=n*2;i++)
	suma[i]=suma[i-1]+(a[i].op==1),sumb[i]=sumb[i-1]+(a[i].op==2);
	f[0][0]=1;
	for(int i=1;i<=2*n;i++)
	{
		if(a[i].op==1)
		{
			int lim=sumb[i];
			for(int j=0;j<=min(n,i);j++)
			{
				if(j&&lim-(j-1)>0)
				f[i][j]=f[i-1][j-1]*a[i].val%p*(lim-(j-1))%p;
				f[i][j]=(f[i][j]+f[i-1][j])%p;
			}
		}
		else
		{
			int lim=suma[i];
			for(int j=0;j<=min(n,i);j++)
			{
				if(j&&lim-(j-1)>0)
				f[i][j]=f[i-1][j-1]*a[i].val%p*(lim-(j-1))%p;
				f[i][j]=(f[i][j]+f[i-1][j])%p;
			}
		}
	}
	int ans=1;
	for(int i=2;i<=n;i++)
	ans=ans*i%p;
	ans=qp(ans,p-2);
	cout<<ans*f[n*2][n]%p;
 	return 0;
}

```


---

## 作者：Graphcity (赞：2)

非常好题目，爱来自沈阳。

首先把 $A,B$ 两个序列放在一起从大往小排序，得到一个新的序列 $C$。设原来在 $A$ 序列中的数为红色，否则为蓝色。匹配有两种形式，红色到蓝色或蓝色到红色。设 $f_{i,a,b}$ 表示考虑到第 $i$ 个数，两种匹配的个数分别有 $a,b$ 种，则有转移：
$$
\begin{cases}
f_{i-1,a,b}\times C_i\times a & \to f_{i,a-1,b} && (C_i \ \text{is blue})\\
f_{i-1,a,b} & \to f_{i,a,b+1} && (C_i \ \text{is blue})\\
f_{i-1,a,b} & \to f_{i,a+1,b} && (C_i \ \text{is red})\\
f_{i-1,a,b}\times C_i\times b & \to f_{i,a,b-1} && (C_i \ \text{is red})
\end{cases}
$$
朴素实现是 $O(n^3)$ 的，尝试优化。

在与外星人尝试沟通之后，我们发现 $s_a-s_b-a+b$ 恒等于零，其中 $s_a,s_b$ 分别为当前红色与蓝色的数字个数。

那我们就只需要存 $f_{i,a}$ 即可，因为 $b$ 可以通过计算得出。时间复杂度 $O(n^2)$。

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(int i=(a);i<=(b);++i)
#define Rof(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
const int Maxn=1e4,Mod=998244353;

inline int Pow(int x,int y)
{
    int res=1;
    while(y)
    {
        if(y&1) res=1ll*res*x%Mod;
        x=1ll*x*x%Mod,y>>=1;
    }
    return res;
}

int n,m,A[Maxn+5],B[Maxn+5];
int f[Maxn+5][Maxn+5];
struct Node{int k,op;} h[Maxn+5];

int main()
{
    cin>>n; m=n*2;
    For(i,1,n) cin>>A[i],h[i]=Node{A[i],1};
    For(i,1,n) cin>>B[i],h[n+i]=Node{B[i],2};
    sort(h+1,h+m+1,[](Node a,Node b){return a.k>b.k;});
    f[0][0]=1;
    int sa=0,sb=0;
    For(i,1,m)
    {
        int ta=sa,tb=sb; if(h[i].op==1) ta++; else tb++;
        For(a,0,n) if(f[i-1][a])
        {
            int b=a+sb-sa,res=f[i-1][a]; if(b<0) continue;
            if(h[i].op==2)
            {
                if(a) f[i][a-1]=(f[i][a-1]+1ll*res*h[i].k%Mod*a)%Mod;
                f[i][a]=(f[i][a]+res)%Mod;
            }
            else
            {
                f[i][a+1]=(f[i][a+1]+res)%Mod;
                if(b) f[i][a]=(f[i][a]+1ll*res*h[i].k%Mod*b)%Mod;
            }
        }
        sa=ta,sb=tb;
    }
    int ans=f[m][0];
    For(i,1,n) ans=1ll*ans*Pow(i,Mod-2)%Mod;
    cout<<ans<<endl;
    return 0;
}
```



---

## 作者：Gaode_Sean (赞：2)

- 题意：给定长度为 $n$ 的序列 $A,B$，定义其权值为 $\prod\limits_{i=1}^n\min(A_i,B_{p_i})$，求所有排列的权值和。

- 数据范围：$n \le 5 \times 10^3$。

- 题解

  $\circ$ 考虑按权值顺序解决问题：设 $f_{i,j,k}$ 表示前 $i$ 小的权值，剩余 $j$ 个 $A$ 和 $k$ 个 $B$ 未匹配的权值和。
  
  $\circ$ 转移时考虑 $i$ 是否产生贡献：
  
  $\circ$ 若 $i$ 的种类为 $A$：$f_{i,j,k}=f_{i-1,j-1,k} \times w_i+f_{i-1,j,k+1} \times (k+1)$。
  
  $\circ$ 若 $i$ 的种类为 $B$：$f_{i,j,k}=f_{i-1,j,k-1} \times w_i+f_{i-1,j+1,k} \times (j+1)$。
  
  $\circ$ 注意到由 $i,j$ 可以计算出 $k$，所以 DP 只需要记录前两维。
  
  $\circ$ 时间复杂度 $\mathcal{O}(n^2)$，空间复杂度 $\mathcal{O}(n^2)$ 或 $\mathcal{O}(n)$。

---

## 作者：include13_fAKe (赞：1)

三年之前我打这场比赛时，因为忽略了 T1 的特殊还原情况直接爆零，被 [q1uple](https://www.luogu.com.cn/user/539133) $100+100+10+0=210$ 暴打了。

如今，我已突破重围，解出了 T4。

## 暴力做法

枚举 $B$ 的全排列，获得 $5$ 分。

Subtask 3 直接计算 $B$ 的乘积即可，共获得 $25$ 分。场上 $100+100+100+25$ 的选手也不占少数。

## 正解

因为是算相对较小的值的贡献，考虑将 $A,B$ 两个数组合并为 $C$ 数组，在 $C$ 数组内标记一个值原来在哪个数组，将 $C$ 数组按值从大到小排序。

考虑 **配对 dp**，设 $dp_{i,j}$ 表示在 $C$ 中的前 $i$ 个数配对了 $j$ 组的贡献总和。（要求所有的配对都必须一个来自 $A$ 一个来自 $B$）

考虑如何转移 $dp_{i,j}$。

首先因为是算乘积，所以 $dp_{0,0}=1$。（如果为 $0$ 就可能导致整个数组都为 $0$ 了）

任意 $dp_{i,0}$ 均为 $1$。

对于一个 $i$，设 $col_i$ 为其本身的颜色，$col1_i$ 表示在 $[1,i-1]$ 范围内与其不同的颜色的值的数量。

因为要配对 $j$ 对，所以之前已经配对了 $j-1$ 对。相当于用掉了 $j-1$ 个数，还剩 $col1_i-(j-1)=col1_i-j+1$ 个数可用。也就是说，还可以用来配对的数用 $col1_i-j+1$ 个。以下令 $now=col1_i-j+1$。

相当于有 $now$ 种从 $dp_{i-1,j-1}$ 转移到 $dp_{i,j}$ 的方案。转移方程式即为 

$$dp_{i,j}=dp_{i-1,j}+dp_{i-1,j-1}\times val_{i}\times now$$

其中 $val_i$ 表示当前寻到的值。注意取模的问题。时间复杂度 $O(n^2)$。

个人认为 Subtask 2 是留给判断了 $A,B$ 段各剩多少个数的算法的。

## 代码


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int mod=998244353;
int n;
int a[3*2025],b[3*2025];
int dp[5*2025][3*2025];
int frac1=1;
struct node{
	int val;
	int col;
}sum[5*2025];
int ptr=0; 
int col_[3];
bool cmp(node a,node b){
	return a.val>b.val;
}
int qpow(int x,int y){
	if(y==0)	return 1;
	if(y==1)	return x;
	int ret=qpow(x,y/2);
	ret=ret*ret%mod;
	if(y&1)	ret=ret*x%mod;
	return ret;
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		sum[++ptr]=(node){a[i],1};
		frac1=frac1*i%mod;
	}
	for(int i=1;i<=n;i++){
		cin>>b[i];
		sum[++ptr]=(node){b[i],2};
	}
	sort(sum+1,sum+ptr+1,cmp);
	dp[0][0]=1;
	for(int i=1;i<=2*n;i++){
		for(int j=0;j<=n;j++){
			dp[i][j]=dp[i-1][j];
			if(j!=0){
				int col1=col_[1],col2=col_[2];
				if(sum[i].col==1){
					int now=col2-j+1;
					if(now>0){
						dp[i][j]=dp[i][j]+dp[i-1][j-1]*sum[i].val%mod*now%mod;
						dp[i][j]%=mod;
					}
				}
				else{
					int now=col1-j+1;
					if(now>0){
						dp[i][j]=dp[i][j]+dp[i-1][j-1]*sum[i].val%mod*now%mod;
						dp[i][j]%=mod;
					}
				}
			}
//			cout<<dp[i][j]<<' ';
		} 
//		cout<<endl;
		col_[sum[i].col]++;
	}
	cout<<dp[2*n][n]*qpow(frac1,mod-2)%mod<<endl;
	return 0;
}//你说你会哭 不是因为在乎  
```

---

## 作者：nullqtr_pwp (赞：1)

妙妙题。

这两个东西很割裂，又和权值相关。$A,B$ 两个序列扔在一起后从大到小排序。设组成的序列是长 $2n$ 的序列 $C$，我们对每个点染色，如果来自于 $A$ 染色为黑，反之为白。考虑 $f(\pi)=\prod_{i=1}^n\min(A_i,B_{\pi(i)})$ 转化为 $n$ 对黑白的配对，一个方案的权值就是这些 $\min$ 相乘。求所有配对方案的总和。

因为这个序列已经有序。贡献的那个数就是靠后的数。这种问题容易想到用 dp 求解。不难想到令 $f[i][j]$ 表示 $c$ 的前 $i$ 个数，配对 $j$ 个的权值总和。转移时考虑 $c[i]$ 是否作为某一对靠后的那个即可。

初始情况：$f[i][0]=1$，答案：$f[2n][n]$。

转移时枚举 $i,j$，有：

$$f[i][j]=f[i-1][j-1]\times c[i]\times (pre_i-j+1)+f[i-1][j]$$

其中 $pre_i$ 表示 $[1,i]$ 中有多少与 $c[i]$ 异色的位置，$pre_i-j+1$ 的含义就是考虑 $c[i]$ 可以与哪些前面的去配对，贡献算 $c[i]$ 的。

总时间复杂度 $O(n^2)$。有点卡空间。

```cpp
struct node{
    int x,fl;
    bool operator<(const node &a)const{
        return x>a.x;
    }
}a[maxn*2];
int f[maxn*2][maxn],g[maxn*2][2];
signed main(){
    int n=read();
    F(i,1,n<<1){
        a[i].x=read();
        a[i].fl=(i<=n);
    }
    sort(a+1,a+2*n+1);
    F(i,1,n<<1){
        g[i][0]=g[i-1][0]+(a[i].fl==0);
        g[i][1]=g[i-1][1]+(a[i].fl==1);
    }
    F(i,1,n<<1){
        int tmp=g[i][a[i].fl^1];
        f[i][0]=1;
        F(j,1,min(i>>1,n)){
            if(tmp>=j) f[i][j]=(1ll*(1ll*f[i-1][j-1]*a[i].x%mod)%mod*(tmp-j+1))%mod;
            add(f[i][j],f[i-1][j]);
        }
    }
    ll ans=f[n*2][n];
    F(i,1,n) mul(ans,qpow(i,mod-2));
    printf("%lld",ans);
}
```

---

## 作者：InoueTakina (赞：1)

这个期望一眼假，直接算出权值和然后除以 $n!$。

注意到同时有颜色和大小两种约束，考虑强制钦定确定某种贡献。

显然不会去强制做掉颜色的限制，考虑将 $a,b$ 序列接起来，形成新的序列，记作 $c$，并从大到小排序。

这样有什么好处呢，我们发现对于 $c$ 中的任意一堆匹配，其权值是后面的数的值。

也就是，在计算一个数的匹配方案时，我们只关心前面有几个可以匹配的数了。

然后这个东西就可以 $\rm dp$ 了，记 $f(i,j)$ 表示考虑到 $c$ 中第 $i$ 个数，匹配了 $j$ 对的方案数。

记 $cnt(i,0/1)$ 表示 $c_{[1,i]}$ 中有几个来自 $a$ 或 $b$ 的，$v_i$ 表示 $c_i$ 来自哪里，则有：

$$f(i,j)=f(i-1,j)+f(i-1,j-1)\times (cnt(i,1-v_i)-j+1)\times c_i$$

然后就可以做了，记得有的数组开两倍大小。

---

## 作者：happy_zero (赞：0)

把原问题看成一个 $a$ 与 $b$ 的匹配，考虑将 $\min\{a_i,b_{\pi(i)}\}$ 的贡献拆开。

有点像的题目：[ABC134F](https://www.luogu.com.cn/problem/AT_abc134_f)。不过那题两个都是排列，若 $j>i$，则 $b_j>a_i$，一定是 $a_i$ 做出贡献。

其实也很好办，只需要把 $a,b$ 放到一起从小到大排个序即可，此时 $\min$ 取的就是下标更小的那个。

设 $g_{i,j}$ 表示考虑前 $i$ 个数，已经匹配了 $j$ 对的 $f$ 的和。以第 $i$ 个数是原本的 $a_k$ 为例：

- $i$ 等着后面匹配：$g_{i,j}\leftarrow g_{i-1,j}\times a_k$
- $i$ 与前面没匹配的任意一个匹配，要求前 $i$ 个数原本在 $b$ 序列中的数的个数 $s$ 大于等于 $j$：$g_{i,j}\leftarrow g_{i-1,j-1}\times (s-j+1)$

答案即为 $\frac{g_{2n,n}}{n!}$。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 5005, P = 998244353; 
struct node { int w, op; } a[N];
int f[N][N];
int qpow(int a, int b = P - 2) {
	int res = 1;
	while (b) {
		if (b & 1) res = res * a % P;
		a = a * a % P; b >>= 1; 
	}
	return res;
}
signed main() {
	int n, ans = 1; cin >> n;
	for (int i = 1; i <= n; i++) 
		cin >> a[i].w, a[i].op = 0, ans = ans * i % P;
	for (int i = n + 1; i <= 2 * n; i++) 
		cin >> a[i].w, a[i].op = 1;
	n <<= 1; f[0][0] = 1;
	sort(a + 1, a + 1 + n, [](node x, node y) { return x.w < y.w; });
	for (int i = 1, sa = 0, sb = 0; i <= n; i++) {
		(!a[i].op ? sa++ : sb++);
		for (int j = 0; j <= min(sa, sb); j++) {
			f[i][j] = f[i - 1][j] * a[i].w % P; int t = (!a[i].op ? sb : sa);
			if (j && t >= j) f[i][j] = (f[i][j] + f[i - 1][j - 1] * (t - j + 1) % P) % P; 
		}
	}
	cout << qpow(ans) * f[n][n >> 1] % P;
	return 0;
}
```

---

## 作者：Phobia (赞：0)

首先套路化的将期望转为方案总和，然后将原数组排序，再设 $f_{i,a,b}$ 表示前 $i$ 个数中有 $a$ 个 $A_i$ 和 $B$ 个 $B_i$ 还未匹配的总和，容易写出转移方程：

当前这个数 $\in A$：

$$f_{i,a+1,b}\gets f_{i,a,b}$$

$$f_{i,a,b-1}\gets bf_{i,a,b}$$

同理写出 $B$ 的情况：

$$f_{i,a,b+1}\gets f_{i,a,b}$$

$$f_{i,a-1,b}\gets af_{i,a,b}$$

到此为止都是 trivial 的，然而酱紫直接 dp 是 $\mathcal{O}\left(n^3\right)$ 的，然后你会发现到两个结构有高度的相似性，不妨建一个以 $\left(a,b\right)$ 为横纵坐标的坐标系。

![](https://cdn.luogu.com.cn/upload/image_hosting/mfzw1f8a.png)

我们惊喜的发现，处理后的 $\left(a,b\right)$ 都在同一条 $y=x+b$ 上，也就是说记 $c_A$ 为到目前为止 $A_i$ 的数量，同理 $c_B$，有 $a-b=c_A-c_B$，于是枚举 $\left(a,b\right)$ 部分就被优化至 $\mathcal{O}\left(n\right)$。

综上，dp 就被优化到了 $\mathcal{O}\left(n^2\right)$。

~~~cpp
#include <bits/stdc++.h>

using namespace std;

inline int read()
{
	int res = 0, ch = getchar();
	for (; !isdigit(ch); ch = getchar())
		;
	for (; isdigit(ch); ch = getchar())
		res = (res << 3) + (res << 1) + (ch & 15);
	return res;
}

typedef long long i64;

const int P = 998244353;

inline int add(int x, int y)
{
	return x + y >= P ? x + y - P : x + y;
}

inline int mul(int x, int y)
{
	return (i64)x * y % P;
}


template<class ...Args>
inline int mul(int x, Args... args)
{
	return mul(x, mul(args...));
}

const int N = 5e3 + 5;

int n, A[N], B[N], f[N], g[N], inv[N];

int main()
{
	n = read();
	for (int i = 1; i <= n; ++i)
		A[i] = read();
	for (int i = 1; i <= n; ++i)
		B[i] = read();
	sort(B + 1, B + n + 1, greater<int>());
	f[0] = 1;
	for (int i = 1, j = 1, k = 0; i <= n || j <= n; ) // 记 k=ca-cb
	{
		memset(g, 0, sizeof(g));
		if (i <= n && (j > n || A[i] > B[j]))
		{
			for (int a = 0; a <= n; ++a)
			{
				int b = a - k;
				if (b < 0 || b > n)
					continue;
				g[a + 1] = add(g[a + 1], f[a]);
				if (b)
					g[a] = add(g[a], mul(f[a], A[i], b));
			}
			++i, ++k;
		}
		else
		{
			for (int a = 0; a <= n; ++a)
			{
				int b = a - k;
				if (b < 0 || b > n)
					continue;
				g[a] = add(g[a], f[a]);
				if (a)
					g[a - 1] = add(g[a - 1], mul(f[a], B[j], a));
			}
			++j, --k;
		}
		memcpy(f, g, sizeof(g));
	}
	inv[1] = 1;
	int ans = f[0];
	for (int i = 2; i <= n; ++i)
	{
		inv[i] = mul(P - P / i, inv[P % i]);
		ans = mul(ans, inv[i]);
	}
	printf("%d\n", ans);
	return 0;
}
~~~

---

## 作者：xuyiyang (赞：0)

### [P8321 『JROI-4』沈阳大街 2](https://www.luogu.com.cn/problem/P8321)
### Solution
将排列转化为两序列匹配问题，于是将 $A_i$，$B_i$ 都放进一个数组 $C$，然后降序排序，这样 $\min(A_i,B_{\pi(i)})$ 就是 $C$ 中靠后的一个，方便 DP。给 $A$，$B$ 各一个颜色，定义 $f_{i,j}$ 表示 $C$ 中的第 $i$ 个，匹配了 $j$ 组的价值和。则有 $f_{i,j}=f_{i-1,j}+f_{i-1,j-1}\times (k-j+1)\times C_{i}$，其中 $k$ 是 $C_{1\sim i}$ 中与 $C_i$ 颜色不同的个数。时空复杂度 $\mathcal O(n^2)$。
### Code
```cpp
void mian() {
	scanf("%d", &n);
	auto add = [&](int &x, int y) { x += y, x >= mod && (x -= mod); };
	for (int i = 1; i <= n; i ++ ) scanf("%d", &w[i].x), w[i].y = 1;
	for (int i = 1; i <= n; i ++ ) scanf("%d", &w[i + n].x), w[i + n].y = 2;
	sort(w + 1, w + 1 + 2 * n); f[0][0] = 1;
	int c1 = 0, c2 = 0;
	for (int i = 1; i <= n * 2; i ++ ) {
		w[i].y == 1 ? c1 ++ : c2 ++ ;
		for (int j = 0; j <= n; j ++ ) {
			int c = w[i].y == 1 ? c2 : c1;
			f[i][j] = f[i - 1][j];
			if (j && c > j - 1) add(f[i][j], (LL)f[i - 1][j - 1] * (c - (j - 1)) % mod * w[i].x % mod);
		}
	}
	int res = f[n * 2][n];
	for (int i = 1; i <= n; i ++ ) res = (LL)res * inv(i) % mod;
	printf("%d\n", res);
}
```

---

## 作者：船酱魔王 (赞：0)

# P8321 『JROI-4』沈阳大街 2 题解

## 题意回顾

给定两个长度为 $ n $ 的序列 $ A,B $，对于长度为 $ n $ 的排列 $ \pi $，记 $ f(\pi) $ 为：

$$ f(\pi)=\prod_{i=1}^n\min\{A_i,B_{\pi_i}\} $$

你需要求出下式的值：

$$ (\frac{1}{n!}\sum_{\pi}{f(\pi)}) \bmod 998244353 $$

$ 1 \le n \le 5000 $，$ 1 \le A_i,B_i \le 10^9 $。

## 分析

题意转化为对于每个 $ A $ 匹配一个 $ B $，求出每对匹配的最小值并求积，要求出所有匹配方案的积的和乘上 $ n! $ 的逆元。

感觉给的那两个 $ A $ 的单调性和 $ A $ 与 $ B $ 最小值相对关系好像没啥用？

对于涉及到序列元素配对和大小关系的，我们考虑将所有元素放到一个大数组里，记为 $ c $，将 $ c $ 从大到小排序，第 $ i $ 个元素的所属序列记为 $ col_i $，数值记为 $ val_i $，这样我们从前往后考虑问题时只用考虑后面的那个值。

我们记录 $ cc_i $ 表示 $ \sum_{j=1}^{i-1}[col_j\ne col_i] $。

数据范围支持设计平方动态规划，第一维用来记录 $ c_i $ 在 $ c $ 中的位置 $ i $，第二维记录有多少对数已经被匹配。

首先我们考虑元素 $ c_i $ 暂时没被配对的情况，即前保持 $ i-1 $ 个元素时同样对配对的状态，需要用 $ dp_{i-1,j} $ 更新 $ dp_{i,j} $。

考虑 $ c_i $ 被配对的情况，显然之前还有 $ cc_i-j+1 $ 个可配对异色元素，都会造成 $ val_i $ 的贡献，贡献与 $ dp_{i-1,j-1} $ 合并需要乘法，元素个数作为选择数也需要乘上每种选择对应的权值得到权值和，故综合列出转移方程如下：

$$ dp_{i,j} = dp_{i-1,j}+dp_{i-1,j-1}\times (cc_i-j+1) \times val_i $$

平方暴力转移即可，注意最后乘上阶乘的逆元。

## AC 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 5005;
const int mod = 998244353;
int n;
int a[N];
int b[N];
int ca[N * 2];
int cb[N * 2];
int cc[N * 2];
struct node {
    int cl;
    int vl;
} c[N * 2];
bool operator<(node p1, node p2) {
    if(p1.vl != p2.vl) {
        return p1.vl > p2.vl;
    }
    return p1.cl < p2.cl;
}
int f[N * 2][N];
int ksm(int x, int y) {
    int res = 1;
    int mul = x;
    while(y) {
        if(y & 1) {
            res = (long long)res * mul % mod;
        }
        mul = (long long)mul * mul % mod, y >>= 1;
    }
    return res;
}
int main() {
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
    for(int i = 1; i <= n; i++) scanf("%d", &b[i]);
    for(int i = 1; i <= n; i++) {
        c[i * 2 - 1].vl = a[i];
        c[i * 2].vl = b[i];
        c[i * 2 - 1].cl = 1;
        c[i * 2].cl = 2;
    }
    sort(c + 1, c + 2 * n + 1);
    for(int i = 1; i <= 2 * n; i++) {
        ca[i] = ca[i - 1], cb[i] = cb[i - 1];
        if(c[i].cl == 1) ca[i]++, cc[i] = cb[i];
        else cb[i]++, cc[i] = ca[i];
    }
    f[0][0] = 1;
    for(int i = 1; i <= 2 * n; i++) {
        f[i][0] = 1;
        for(int j = 1; j <= i / 2; j++) f[i][j] = (f[i - 1][j] + (long long)f[i - 1][j - 1] * max(0, cc[i] - j + 1) % mod * c[i].vl % mod) % mod;
    }
    int frac = 1;
    for(int i = 1; i <= n; i++) frac = (long long)frac * i % mod;
    frac = ksm(frac, mod - 2);
    printf("%lld\n", (long long)frac * f[2 * n][n] % mod);
    return 0;
}

```

---

## 作者：ダ月 (赞：0)

### 题目分析：

首先，那个对 $A,B$ 的限制条件用处就是 $A_i$ 序列最小值不小于 $B_i$ 序列最小值，并且 $A_i$ 保证不上升，也就是满足任意 $i>j$，使得 $A_i\ge A_j$。另一个条件，$B_i$ 是一个排列，弱化了 $B_i$ 有序的限制，可以让 $B_i$ 自由排列。

我们从匹配的角度入手，一个 $A_i$ 匹配一个 $B_j$。显然共有 $n$ 对匹配。然后记每种匹配的权值为 $\min(A_i,B_j)$，求所有匹配的乘积。

为了弱化这个 $\min$ 的限制，我们不妨让 $A_i$ 和 $B_i$ 序列放在一起形成一个有 $2n$ 个元素的二元组 $P=(C_i,b_i)$，$C_i$ 表示 $A_i$ 或 $B_i$，$b_i$ 只能是 $0$ 或者 $1$，$0$ 表示是原来的 $A_i$ 序列，$1$ 表示是原来的 $B_i$ 序列。以 $C_i$ 为关键字降序排序，显然，对于当前元素 $P_i$，我们只需要在 $[1,i)$ 中找到一个 $j$，满足 $P_i$ 和 $P_j$ 的 $b$ 不同即可匹配，贡献的权值为 $C_i$。

我们考虑动态规划，记 $f_{i,j}$ 为考虑到第 $i$ 个 $P$，$s_{i,0/1}$ 表示 $P$ 前 $i$ 项 $b_i$ 为 $0/1$ 的个数，已经匹配了 $j$ 组的贡献和。若考虑匹配，显然可以从 $f_{i-1,j-1}$ 转移过来，贡献为 $f_{i-1,j-1}\times (s_{i,b_i\oplus1}-j+1)\times C_i $；若不考虑匹配，可以直接从 $f_{i-1,j}$ 转移过来。

边界为 $f_{i,0}=1$，其中 $i\in[0,2n]$，答案为 $f_{2n,n}$。最后答案还要除于 $n!$，来求期望。


由于转移是 $i$ 和 $i-1$ 的关系，我们可以滚掉第一维。

时间复杂度：$O(n^2)$。

### 代码如下：

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define pd push_back
#define all(x) x.begin(),x.end()
#define Clear(x,n) for(int i=0;i<=n;i++)x[i]=0;
//==============================================================================
ll QP(ll x,ll y,ll mod){ll ans=1;for(;y;y>>=1,x=x*x%mod)if(y&1)ans=ans*x%mod;return ans;}
//==============================================================================
namespace IO{
	int readInt(){
		int x=0,y=0;char c=0;
		while(!isdigit(c))y|=c=='-',c=getchar();
		while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
		return !y?x:-x;
	}
	void write(int x){if(!x)return;write(x/10);putchar(x%10+'0');}
	void Output(int x){if(x<0)putchar('-'),x=-x;if(!x)putchar('0');else write(x);}
	void WL(int x){Output(x);putchar('\n');}
	void WS(int x){Output(x);putchar(' ');}
}
namespace Debug{
	void DeVec(vector<int> c){for(auto y:c)printf("%d ",y);puts("");}
	void DeNum(int x){printf("%d\n",x);}
}
//==============================================================================
const int N=5e3+10;
typedef pair<ll,ll> pl;
const int mod=998244353;
#define Fr(x) x.first
#define Se(x) x.second
ll s[N<<1][2];
pl a[N<<1];
ll f[2][N];
int n;
bool cmp(pl x,pl y){return Fr(x)>Fr(y);}
ll inv(ll x){return QP(x,mod-2,mod);}
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	//std::ios::sync_with_stdio(false);
    //std::cin.tie(nullptr);
    n=IO::readInt();
    for(int i=1;i<=n*2;i++)a[i]={IO::readInt(),i>n};sort(a+1,a+(n<<1)+1,cmp);
    for(int i=1;i<=n*2;i++)s[i][0]=s[i-1][0]+(Se(a[i])^1),s[i][1]=s[i-1][1]+(Se(a[i]));
    f[0][0]=1;
    for(int i=1;i<=n*2;i++){
    	memset(f[i&1],0,sizeof(f[i&1]));f[i&1][0]=1;
    	for(int j=1;j<=min(n,i);j++){
    		if(j<=s[i][!Se(a[i])])f[i&1][j]=(f[i&1][j]+f[i&1^1][j-1]*(s[i][!Se(a[i])]-j+1)%mod*Fr(a[i])%mod)%mod;
    		f[i&1][j]=(f[i&1][j]+f[i&1^1][j])%mod;
		}
	}ll fac=1;for(int i=1;i<=n;i++)fac=fac*i%mod;
	printf("%lld\n",f[0][n]*inv(fac)%mod);
	return 0;
}


```


---


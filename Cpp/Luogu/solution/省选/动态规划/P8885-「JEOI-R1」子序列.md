# 「JEOI-R1」子序列

## 题目背景

| 出题 | 标程 | 数据 | 验题 | 题解 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| [Pekemetier](/user/146070) | [Pekemetier](/user/146070) | [Pekemetier](/user/146070) | [cq_zry](https://www.luogu.com.cn/user/734533) & [lOlAKME](/user/768786) | [Pekemetier](/user/146070) |


## 题目描述

给定一个仅包含 `0`、`1` 和 `?` 的字符串，你需要将字符串中的每个 `?` 分别替换成 `0` 或 `1` 之一。也就是说替换成一个 $01$ 字符串。求有多少种替换方案，使得替换后的字符串满足：恰好拥有奇数个**不同的**子序列（包含空串）的非空子串的个数为奇数。特别地，如果字符串中不包含 `?`，应将其自身视为唯一的替换方案。

每个数据点会给定一个字符串 $s$ ，然后每次对 $s$ 的一个子串进行询问，答案对 $998244353$ 取模。

## 说明/提示

**【样例解释】**

对于【样例\#1】的第一个询问 `1 5`，有 $2$ 种替换方案，分别为字符串 `10001` 和 `10011`。

其中 `10001` 有 $3$ 个子串满足不同的子序列的个数为奇数：`10001`，拥有 $15$ 个不同的子序列；$s'_ {2,3}$ 和 $s'_ {3,4}$ 均为 `00`，都拥有 $3$ 个不同的子序列。

而 `10011` 则拥有 $4$ 个子串满足不同的子序列的个数为奇数，分别为 `1001`、`00`、`0011`、`11`。

`10001` 有奇数个子串满足子序列个数为奇数，因此计入答案；而 `10011` 有偶数个，因此不计入答案。

对于【样例#2】的第一个询问 `1 20`，$s_{1,20}$ 有 $4$ 个 `?`，因此有 $2^4=16$ 种替换方案。

---

**【数据范围】**

**本题采用捆绑测试**。

| $\text{Subtask}$ | $n\leq$ | $m\leq$ | 特殊性质 | $\text{Score}$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $10$ | $10$ |  | $10$ |
| $2$ | $100$ | $100$ | $s$ 不包含 `?` | $10$ |
| $3$ | $500$ | $500$ | $s$ 不包含 `?` | $20$ |
| $4$ | $1000$ | $1000$ |  | $20$ |
| $5$ | $5000$ | $5000$ |  | $10$ |
| $6$ | $5000$ | $10^5$ |  | $10$ |
| $7$ | $5\times10^4$ | $3\times 10^5$ |  | $20$ |

对于 $100\%$ 的数据，满足 $1\leq n\leq 5\times10^4$，$1\leq m\leq 3\times10^5$，$s$ 仅包含 `0`、`1` 和 `?`。

---

**【提示与说明】**

子串：在原来的字符串中选出一段连续字符组成的字符串。一个长为 $n$ 的字符串有 $\frac{n(n+1)}{2}$ 个子串。例如字符串 `121` 共有 $6$ 个子串，分别为 `1`、`2`、`1`、`12`、`21`、`121`。注意在本题中，空串不算一个子串。

子序列：在原来的字符串中任意删去若干个字符（也可以不删）形成的的字符串。例如字符串 `0110` 拥有 $11$ 个不同的子序列，分别为空串、`0`、`1`、`00`、`01`、`10`、`11`、`010`、`011`、`110`、`0110`。注意在本题中，空串也算一个子序列。

## 样例 #1

### 输入

```
5
100?1
5
1 5
1 4
2 5
3 4
1 3```

### 输出

```
1
0
1
1
1```

## 样例 #2

### 输入

```
20
1110??01001010?1?110
20
1 20
5 16
11 16
10 13
5 14
13 17
1 18
1 7
6 9
15 19
12 17
17 18
4 11
3 13
13 15
18 19
2 8
7 13
4 15
9 18```

### 输出

```
3
2
2
0
4
2
13
3
0
1
3
1
2
2
2
1
2
1
1
3```

# 题解

## 作者：ღꦿ࿐ (赞：6)

感觉全是套路的一个题，但很有意思，适合当 dp 套 dp 思想的入门理解。模拟赛赛时搬了个卡常版本被卡成了 $60$，很神笔，感觉这题难度不在数据结构部分吧。


定义一个串是**奇**的当且仅当这个串有奇数个本质不同可空子序列。

定义一个串是**好**当当且仅当这个串有奇数个**奇**子串。

---

## $\text{Part 1}$ 本质不同子序列计数（奇串的判定）

广为人知。

考虑求出一个固定位置

维护 $f_{i,c}$ 表示前 $i$ 个位置，目前以 $c$ 结尾的子序列计数。

转移方式：

$$f_{i,a_i}=\sum f_{i-1,j}+1$$
$$f_{i,j}=f_{i - 1,j} (j\neq a_i)$$

即对于所有原本的子序列（包含空串），新加入一个数都可以使得它变成一个以这个数结尾的子序列，而对于其他串，并不以它结尾的子序列的个数。


把 $f$ 数组拍平（滚动数组）。我们只需要记录每个位置的奇偶性。

考虑和为 $0$ 的时候会将 $f_{a_i}$ 赋值为 $1$，而此时和为 $1$ 的时候会将 $f_{a_i}$ 赋值为 $0$，所以 $f$ 数组中无论如何是只会有不超过 $1$ 个 $1$ 的，考虑记录一个 $f_{U}$，表示 $f_{0}+f_{1}+1$，即该串的本质不同子序列数，那么在数组后面放一个 $a_i$，相当于交换 $f_{U}$ 和 $f_{a_i}$ 的奇值，过程如下。 

$$
f'_{a_i} = \sum f_{j} = f_U
$$
$$
f'_{U} = f_{U} + f'_{a_i} - f_{a_i}=2f_U-f_{a_i}=f_{a_i}
$$

所以我们只需要记录目前哪个位置的 $f$ 有值即可递推信息并维护本质不同子序列数。

---

## $\text{Part 2}$ 奇子串计数（好串的判定）

因为 $f$ dp 统计的是一个串的 dp 数，现在统计的就是所有子串的 $f$ 数组的信息，又因为我们要一位一位来，所以
考虑 dp 套 dp：统计目前 $f$ 数组的 dp 值对应的子串数。

令 $g_{of}$  表示目前这个串的 $f$ dp数组为 $of$ 的子串个数，其中 $of$ 被简化为 $\{0,1,U\}$ 表示有值位置。

统计所有子串的方式即是：对于每个位置：

1. 加入一个以这个位置开头的空串。
1. 进行转移—— 原本的 $f$ 添加了末尾的数会转移到 $f'$，那么就将 $g_{f}$ 转移到 $g_{f'}$。
1. 统计所有以此位置结尾的奇串个数，累加至 $tot$ 中。

因为 $f$ 只有 $3$ 个有意义的值，所以 $g_{f}$ 存三个状态。 

我们可以统计对整个子串进行上面这个过程，通过 $tot$ 的奇偶性来判断这个串是否为好串。

---
## $\text{Part 3}$ 填充方案数计数（将好串的判定放入计数中）

我们已经能够统计这个子串是否是好的，只需要维护 $g_{0/1/U}$ 和 $tot$ 的值，接下来我们要维护所有填充方案的好串的判定。 

考虑再套一层 dp：统计目前 $g$ 数组与 $tot$ 对应的的填充方案。 $h_{ (g,tot)}$ 表示目前填充方案使得目前的共统计状态为 $g$ 和 $tot$，因为本质不同的 $g_{f}$ 与 $tot$ 只有 $2^4$ 种，所以 $h$ 的状态只有 $16$ 种。

在确定了这个状态后某个 $(g,tot)$ 会转移至 $(g',tot')$ 那么在进行转移时将 $h_{(g,tot)}$ 转移至 $h'_{(g',tot')}$ 即可。

直接进行转移，时间复杂度 $O(q n \times s)$，其中 $s=16$。

---
## $\text{Part 4}$ 数据结构优化

观察到这个区间查询的 dp 的形式是一个线性的转移，且第二维较小，考虑使用矩阵乘法优化转移，使用数据结构区间查询某段矩阵的乘积，时间复杂度可以做到 $O( (n+q\log n)s^3)$，很基础不在赘述。

 
---
## $\text{Part 5}$ 常数优化与状态减少

首先线段树查询不需要整个矩阵的信息，故将矩阵乘矩阵优化成向量乘矩阵，复杂度 $O(ns^3+qs^2\log n)$，可以过掉这个题了。

首先这个矩阵的大小是很大的，但是单个位置的转移矩阵较为稀疏只有 $O(s)$ 个值，这样的矩阵的乘法是可以 $O(s^2)$ 完成的，所以我们不想像线段树那样合并两个一般矩阵，考虑猫树分治求答案，这样维护前后缀乘积的答案就是一般矩阵乘上单个转移矩阵，复杂度 $O(n \log n s^2 + qs^2)$。



在复杂度上我们很难再优化了，但是状态数还可以再减少！观察到我们前面处理 $g$ 的时候加入的串的总数的奇偶性是固定的（给 $g_{U}$ 改变了一次奇偶性，所以我们是可以通过目前的总长度和 $g_0,g_1$ 推出来 $g_{U}$，故可以将需要记录的的状态减少 $3$ 个，可以将 $s$ 减小到 $8$，但是需要分别记录奇数和偶数的矩阵，将一个常数 $2$ 从平方内移到了平方外，会快很多。

笔者没加最后这个优化，目前最优解第二，这里是[代码](https://www.luogu.com.cn/paste/u71b02rg)。

---

## 作者：florrer (赞：6)

非常不错一道 dp of dp。

恰好拥有奇数个不同的子序列的非空子串个数为奇数，即为非空子串不同子序列个数和为奇数。

首先考虑弱化问题，求解一个的串的合法方案数。

求解一个 $01$ 串不同子序列个数有经典 dp 求法。设 $f_{0,1}$ 分别表示以 $0/1$ 结尾的不同子序列总数，$g$ 表示当前不同子序列总数。设当前在串末尾增加了数字 $i$，那么有如下转移

- $g' = f_i$
- $f'_i = 2 \times g - f_i$

在模 $2$ 意义下即为交换 $f_i, g$。

这样我们对一个串的所有子串不同子序列个数和模 $2$ 为奇方案数也容易用 dp of dp 求解。

设 $f_{i,0/1,0/1,0/1,0/1}$ 表示到了第 $i$ 个位置，以 $0$ 结尾的、以 $1$ 结尾的、总共的，以 $i$ 结尾的后缀的不同子序列个数和在模 $2$ 意义下为 $0/1$，非空子串不同子序列个数和在模 $2$ 意义下为 $0/1$ 的方案数。（有点绕，可以自己意会一下）

转移时考虑当前新加入的 $0/1$ 会交换 $0/1$ 与总共的方案数，并会增加一个新的后缀方案。

最后可以先将 $f$ 后面的一坨 $01$ 压成一维并预处理出转移。对于多组询问可以使用猫树分治，枚举中间断点的状态做分别正反 dp 即可。

放上核心代码，实现上与题解略有细节不同。

```cpp
int to0[20], to1[20];
//{0/1,0/1,0/1,0/1}:0,1,all,ans 
inline void init() {
	for(int i = 0; i < 16; i++) {
		int x = i & 1, y = i >> 1 & 1, z = i >> 2 & 1, t = i >> 3 & 1;
		t ^= x, to0[i ^ 4] = x * 4 + y * 2 + z + t * 8;
	}
	for(int i = 0; i < 16; i++) {
		int x = i & 1, y = i >> 1 & 1, z = i >> 2 & 1, t = i >> 3 & 1;
		t ^= y, to1[i ^ 4] = x + y * 4 + z * 2 + t * 8;
	}
}
int f[400005], g[400005];
int dp[20], tmp[20];
int ans[300005]; 
void solve(int id, int l, int r) {
	if(l == r) return ;
	int mid = (l + r) / 2;
	solve(id << 1, l, mid), solve(id << 1 | 1, mid + 1, r);
	for(int md = 0; md < 16; md++) {
		for(int i = l; i <= r; i++) f[i] = g[i] = 0;
		memset(dp, 0, sizeof dp), dp[md] = 1;
		for(int i = mid; i >= l; i--) {
			memcpy(tmp, dp, sizeof tmp), memset(dp, 0, sizeof dp);
			if(ch[i] != '1') for(int j = 0; j < 16; j++) Add(dp[j], tmp[to0[j]]);
			if(ch[i] != '0') for(int j = 0; j < 16; j++) Add(dp[j], tmp[to1[j]]);
			f[i] = dp[0];
		}
		memset(dp, 0, sizeof dp), dp[md] = 1;
		for(int i = mid + 1; i <= r; i++) {
			memcpy(tmp, dp, sizeof tmp), memset(dp, 0, sizeof dp);
			if(ch[i] != '1') for(int j = 0; j < 16; j++) Add(dp[to0[j]], tmp[j]);
			if(ch[i] != '0') for(int j = 0; j < 16; j++) Add(dp[to1[j]], tmp[j]);
			for(int j = 8; j < 16; j++) Add(g[i], dp[j]);
		}
		for(auto x : G[id]) Add(ans[x], f[q[x].l] * g[q[x].r] % mod);
	}
}
```

---

## 作者：向晚大魔王 (赞：4)

下文视题面中的 $0$ 为 $-1$。

一个字符串有奇数个非空子序列，当且仅当它奇数位的和减去偶数位的和是 $3$ 的倍数。   

因此快速计算一个字符串的答案是平凡的，只需要检查每种和的前缀数量即可。

然后就是纯套路，因为一个区间的状态只有 $s=48$ 个（如果你有些细节没想清楚可能是 $64$ 个），直接动态 dp。

朴素在线段树上做时间复杂度高达 $O(ms^2\log n)$，感觉不太行。

注意到这个东西插入快合并慢，直接上回滚莫队或者猫树，时间复杂度 $O(ns\sqrt m)$ 或 $O(ns\log n+ms^2)$。

---

## 作者：cyffff (赞：3)

[$\text{Link}$](https://www.luogu.com.cn/problem/P8885)

## 题意

给定一个长为 $n$ 的仅包含 `0`、`1` 和 `?` 的字符串 $s$，你需要将字符串中的每个 `?` 分别替换成 `0` 或 `1` 之一。称一个序列是**好的**当且仅当其恰好拥有奇数个本质不同的**子序列**（包含空串），称一个序列是**极好的**当且仅当其拥有奇数个好的非空**子串**。每次询问给出 $s$ 的一个子串 $[l,r]$，求其有多少种替换方案，使得这个子串是**极好的**。

$n\le 5\times10^4$，$m\le 5\times 10^5$。

## 题解
校内模拟赛出了这题的加强版，将字符集扩大为 $3$ 并增大了 $m$ 的数据范围。

令 $v$ 等于字符集大小 $2$。

首先我们考虑描述好的序列。本质不同子序列有广为人知的 $\text{dp}$：令 $f_i$ 表示以 $i$ 结尾的本质不同子序列个数，$f_s$ 表示 $\sum f_i+1$，则在序列后加入字符 $c$ 的时候令 $f_i\gets f_s$。考虑在 $\bmod2$ 意义下，显然初始时 $f_i=0,f_s=1$，加入一个字符 $c$ 就会交换 $f_s,f_c$。显然一个好的序列进行完 $\text{dp}$ 后 $f_s=1$。

先思考全局询问的做法。注意到这个 $\text{dp}$ 只拥有 $v+1$ 个状态（$1$ 分别在 $1\dots v$ 或者 $s$） 处。状态数少，考虑 $\text{dp}$ 套 $\text{dp}$。令 $g_{i,f_0,f_1,f_s,t}$ 表示前缀 $i$ 有多少个后缀的 $\text{dp}$ 状态为 $1$ 在 $f_0,f_1,f_s$ 处，前缀 $i$ 有 $t$ 个子串是好的，其中后四维都是在模 $2$ 意义下的。考虑转移，枚举位置 $i$ 能填的字符 $c$（不妨假设 $c=0$），则有转移 $g_{i,f_0,f_1,f_s,t}\to g_{i+1,f_s\oplus1,f_1,f_0,t\oplus f_0}$，$c=1$ 同理。最终答案就是 $\sum g_{n,*,*,*,1}$。

令 $V=2^{v+2}$，后面四维可以压缩成一个 $[0,V)$
 的数，转移可以用 $V\times V$ 的矩阵描述，用线段树维护矩阵可做到 $O(V^3n+V^3m\log n)$，非常糟糕。

$n,m$ 不同阶，考虑减少合并次数，使用二区间合并（猫树分治），对于分治区间 $[l,r]$ 与其中点 $mid$，记录 $s_i=\prod_{j=i}^{mid}A_j$，$p_i=\prod_{j=mid+1}^iA_j$（$A_j$ 表示 $j$ 处的转移矩阵），询问直接求 $s_lp_r$，可做到 $O(V^3n\log n+V^3m)$ 的复杂度，后文将直接用 $T(A,B)$ 来代替 $O(An\log n+Bm)$。

考虑将询问时相乘的矩阵变成向量，定义 $1\times V$ 的向量 $S_{0,i}=[i=0]$
，$V\times 1$ 的向量 $T_{i,0}=[2^{v+1}\subset i]$，不难发现 $[l,r]$ 的答案就是 $Ss_lp_rT$，不妨先令 $s_i\gets Ss_i$，$p_i\gets p_iT$，则复杂度降低为 $T(V^3,V)$。

继续优化，可以发现猫树中每层都重新算 $s,p$ 浪费很大，考虑在相邻两层间递推 $s,p$，不难发现对于 $i\in[l,mid]$，$s_i\gets s_i\prod_{j=mid+1}^rA_j$，$i\in[mid+1,r]$，$p_i\gets \prod_{j=l}^{mid}A_jp_i$。$\prod_{j=l}^{mid}A_j$ 和 $\prod_{j=mid+1}^rA_j$ 可以简单求，注意到此处是向量乘矩阵，时间复杂度被我们优化到了 $T(V^2,V)$。

总时间复杂度 $O(V^3n+V^2n\log n+Vm+m\log n)$，快速求猫树两点 $\text{LCA}$ 可以将后面的 $m\log n$ 去掉。矩阵稀疏，只有 $O(V)$ 个点，利用此点可继续优化复杂度至 $O(V^2n\log n+Vm)$，本题中 $V=16$。可以通过 $v=3,m=10^6$ 的加强版（$V=32$）。

核心代码：
```cpp
Matrix ml[N],pr[N],sf[N];
inline void solve(int rt,int l,int r){
	if(l==r){
		ml[l]=mt[s[l]];
		sf[l]=S*ml[l],pr[l]=ml[l]*T;
		return ;
	}
	int mid=l+r>>1;
	solve(ls,l,mid),solve(rs,mid+1,r);
	for(int i=l;i<=mid;i++)
		for(int j=st[i];qr[j].fir==i;j++){
			pii tmp=qr[j].sec;
			if(tmp.fir>r) break;
			int r=tmp.fir;
			ans[tmp.sec]=(sf[i]*pr[r])[0][0];
			st[i]=j+1;
		}
	for(int i=l;i<=mid;i++)
		sf[i]=sf[i]*ml[mid+1];
	for(int i=mid+1;i<=r;i++)
		pr[i]=ml[l]*pr[i];
	ml[l]=ml[l]*ml[mid+1];
}
```

---

## 作者：封禁用户 (赞：1)

首先我们有经典子序列计数 dp，维护以 $0$ 或 $1$ 结尾的方案数 $f_i$ 和总方案数 $f_{all}$，每次会将 $f_i'\leftarrow f_{all},f_{all}'\leftarrow f_i+f_{all}$。

然后有一个显然的性质：在模 $2$ 意义下，一次操作等价于交换 $f_i$ 和 $f_{all}$。因此只要交换到 $all$ 那里，就会是奇数。

还有一个性质，就是可以将位置划分为若干个等价类，每个等价类内任选两个位置组成子串，子序列数就会是奇数的。这个证明很显然，就是任何一个有奇数个子序列的子串，都会形如 $(10\dots01)(10\dots01)\dots(01\dots10)$，也就是可以被拆成若干个形如 $011\dots1110$ 或 $100\dots0001$ 的基本单元，若干基本单元拼出来的一定是有奇数个子序列的子串，而这些基本单元间的那些位置就是等价类。

等价类怎么维护呢，一种简单的方法是表示成**当前的**、**加 $0$ 能得到的**、**加 $1$ 能得到的**三类。由基本单元的性质，不难想到加入一个数后会交换**当前的**和**加 $i$ 能得到的**——只要再有任意一个 $i$，都会把它切到**当前的**。

接下来使用 dp 套 dp 进行计数。注意到这三个等价类产生的贡献是 $\frac{size\times(size-1)}2\bmod2$，因此有用的只是它模 $4$ 的余数，所以可以把 dp 状态压到 $4\times4\times4=64$ 种。然后我们对这些 dp 状态进行 dp ，维护每种 dp 状态的方案数。

一种计算方法是矩乘优化，这需要 $O(64^3\times n)$ 的预处理复杂度和 $O(64^3\times\log n)$ 的单次询问复杂度。这是不可接受的，因为 $64^3=262144$。另一种好一点的计算方法是猫树分治，利用了 $O(64^2)$ 加一个数的性质和最后有用状态有限的特点实现 $O(64)$ 合并，可以做到 $O(64^2n\log n+64m)$。

略微卡常，注意常数优化。

---

## 作者：Pekemetier (赞：0)

找到了新的地方进行优化后得到了这篇更优的题解，复杂度 $O(64n\log n+8m+m\log n)$，使用四毛子可以去掉 $m\log n$，应该是本题最优算法了。

本题核心是找到一种 dp 来维护「奇数个不同子序列」以及拥有其的子串数，利用 dp 套 dp 统计方案。

（下文称拥有「奇数个不同子序列」的子串为合法子串）

本题解所采用的是一种常见的计算不同子序列个数的方法，维护总方案数和以 `0`、`1` 结尾的方案数。在模 $2$ 意义下每次在原串后面加入一个字符 `0` 或 `1` 等价于交换以它结尾的方案数和总方案数，因此只有 $3$ 种 dp 状态，我们表示为 $(1,0,0),(0,1,0),(0,0,1)$，初始为 $(1,0,0)$。

**接下来考虑手动模拟这个 dp，找到合法子串的规律。**（但是这个规律比较绕，看不懂还是去找其他题解吧）

发现形如 `100....001` 和 `0111...110` 的子串是合法的。手动模拟一下，会先从 $(1,0,0)$ 到 $(0,1,0)$ 或 $(0,0,1)$，在最后一个字符时会变回 $(1,0,0)$。若干由这种子串拼接而成的子串也是合法的。不能由这种子串拼接而成的子串都是不合法的。

这可以导出一个结论：一个子串，如果删去它的一个合法前缀或后缀，所得子串仍然合法。

首先我们先定义【位置】。一个长为 $n$ 的字符串有 $n+1$ 个位置，我们将其编号为 $0\sim n$。$n-1$ 个在两相邻字符之间，$2$ 个在开头结尾。任意两个位置之间有一个子串。

然后我们定义【等价类】为一个位置集合。满足等价类内的位置任选两个得到的子串合法，不同等价类内的位置任选两个得到的子串不合法。证明显然，因为合法关系具有传递性，$i,j$ 合法 $j,k$ 合法一定推出 $i,k$ 合法。（这包含了 $i<k<j$ 等情况，因为删去合法（前）后缀后仍然合法）

通过观察我们发现等价类最多有 $3$ 个，因为只有 $3$ 种 dp 状态（证明比较绕，感性理解一下，就是同一 dp 状态的是同一等价类）。

然后维护方法就是每次新加入一个位置，先看这个位置前一个字符，并交换 $(1,0,0)$ 和另一个对应 dp 状态的等价类，再把当前位置加入 $(1,0,0)$ 的等价类。初始 $0$ 在 $(0,0,1)$ 等价类。

---

然后我们需要维护等价类的不同大小的方案数。

接下来的分析**默认使用猫树分治**，因为这个状态易于添加单点而不易于合并，猫树会比莫队和线段树都更优。由于复杂度都是 $O(s_1n\log n+s_2m+m\log n)$ 的形式（四毛子优化 $m\log n$），所以直接用二元组 $(s_1,s_2)$ 表示复杂度。

一种比较直接的思路是每个等价类的大小对 $4$ 取模的值才是有用的，所以用 $f_{i,t0,t1,t2}$ 表示第 $i$ 位三个等价类大小分别为 $t0,t1,t2$ 时的方案数。由于等价类的位置会交换，我们还需要在状态里添加初始的状态 $t0',t1',t2'$。每次询问时枚举左边的 $t0,t1,t2$，这也是右边的 $t0',t1',t2'$，右边的 $t0,t1,t2$ 与处理掉。复杂度 $(64^2,64)$。

优化#1：发现维护 $t0',t1',t2'$ 有点多余，我们只是交换而已，从 $(0,0,0)$ 开始并维护交换后的顺序就好了。有一边可以不用维护交换顺序。复杂度 $(64\times6,64^2)$。（实际上是 $(\frac{64+448}{2},64^2)$）

优化#2：由于位置个数已知，所以不用维护三个，只用维护两个，剩下一个用总和减其它即可。复杂度 $(96,256)$。（实际上是 $(\frac{96+16}{2},256)$）

优化#3：发现不一定要对 $4$ 取模，对 $2$ 取模并且维护当前（这部分）的总方案数即可，复杂度 $(48,32)$。（实际上是 $(\frac{48+8}{2},32)$）

优化#4：回退掉优化#1，再加上一位来维护总和（相当于优化#2只用了一半），复杂度 $(64,8)$。

到这里应该就是这种技术线路的极限了，因为状态起码有 $8$ 种。

但是这题还可以考虑增大字符集来加强，思路不变只用增加状态即可。字符集每增大 $1$，$s_1$ 变 $2$ 倍，$s_2$ 变 $4$ 倍。

---


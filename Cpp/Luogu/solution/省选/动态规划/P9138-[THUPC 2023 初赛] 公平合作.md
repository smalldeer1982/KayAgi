# [THUPC 2023 初赛] 公平合作

## 题目描述

在大地的尽头，一座灰白的灯塔矗立在漫长的海岸线上。这一片海域海流复杂、礁石嶙峋，却又是不少航线的必经之路。若没有如此高耸而明亮的灯塔为过路的船只照亮航路，或许会有更多不幸的生命葬身海底。为了看管好这一座海上明灯，一批训练有素的守望人轮流值守于此。日复一日的工作枯燥乏味却又不能有丝毫闪失，紧绷的神经直到下一班守望人到来才得以放松。

在电力普及之前，灯塔通常使用煤油灯为过往的水手指引前行的方向。每次为这座灯塔添加燃油时，需要两位守望人各自搬运一个容积为 $L$ 的油桶；而每次轮到 Y 和 S 所在的班组照料这座灯塔时，总是由 Y 和 S 负责为灯塔加油。将煤油搬运至灯室时，如果不装满油桶，对灯塔的正常运转也没有太大影响，无非是需要多来回搬运几趟。但是，如果两位守望人都想着偷懒，问题恐怕就不只是多几趟那么简单。Y 和 S 想到了一个好办法：互相为对方的油桶装油。

灯塔里有 $N$ 个用于将储存的煤油转移到油桶中的容器，其中第 $i$ 个容器的容积为 $a_i$。Y 和 S 先想办法决定由谁先装油。两人先后装油；轮到其中一位守望人装油时，这位守望人每次从所有容器中等概率地随机选出一个容器，将其装满油，并全部倒入对方的油桶中。两位守望人都可以在操作任意多次（可以是 0 次）后结束装油，但后手必须等先手结束后才能开始装油。Y 和 S 先后装完煤油后，两人会比一下谁把对方的油桶装得更满，再各自把自己的油桶搬运到灯室。但是，如果有谁某次选出一个容器后，把对方的油桶装满了，但容器里还有没倒出的煤油，那么这位倒霉的守望人就必须把两个油桶都独自搬到灯室——这也算是为单调的生活平添了几分乐趣。显然，如果先手某次随机选中的容器会使得油桶溢出，那么后手可以往先手的油桶里面装任意量的煤油，然后幸灾乐祸；因此我们约定：当先手溢出时，必定由先手搬两个油桶。

现在只剩下了一个问题：当 Y 和 S 都采取最优策略，使得对方搬的煤油尽可能地比自己多的时候，先手搬的煤油不多于后手的概率是多大？

## 说明/提示

#### 样例解释 1

可以证明，此时先手的策略一定是装满对方的油桶，且装满时必胜。经过若干次随机抽取后，能恰好将对方的油桶装满的概率为：

$$
\left(\frac{1}{2}\right)^2 + \binom{3}{1}\left(\frac{1}{2}\right)^3 + \left(\frac{1}{2}\right)^4 = \frac{11}{16}=0.6875
$$

#### 数据范围

对于 $100\%$ 的数据，保证 $1\le N\le 2\times 10^3$，$1\le L\le 10^9$，$1\le a_i\le 2\times 10^3$。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。

## 样例 #1

### 输入

```
2 4
1 2```

### 输出

```
0.687500000000000000
```

## 样例 #2

### 输入

```
见附件中的 2.in```

### 输出

```
见附件中的 2.out```

## 样例 #3

### 输入

```
见附件中的 3.in```

### 输出

```
见附件中的 3.out```

# 题解

## 作者：Alex_Wei (赞：4)

> [P9138 [THUPC 2023 初赛] 公平合作](https://www.luogu.com.cn/problem/P9138)

套路题，但是学到很多。

设先手和后手选择的容器的体积之和分别为 $X$ 和 $Y$。很明显，后手可以根据先手的决策来决策，且策略唯一：不断选择容器直到 $Y > X$。

设 $f_{i, j}$ 表示要求体积和大于 $i$ 的前提下，体积和为 $j$ 的概率，且 $j$ 是第一次体积和大于 $i$。其等价于 $X = i$ 时，$Y = j$ 的概率。初始 $f_{i, 0} = 1$（$i < 0$）。从 $f_{i - 1}\to f_i$ 时，将 $f_{i - 1, i}$ 乘以 $\frac 1 n$ 转移到所有 $f_{i, i + a_j}$。显然，对于任意 $f_i$，其有值的长度为 $m = \max a_i$。

设 $p_i$ 表示当 $X = i$ 时，$i < Y \leq L$ 的概率，则 $p_i = \sum_{j = i + 1} ^ L f_{i, j}$。

设 $q_i$ 表示当 $X = i$ 时，先手获胜的概率，则先手可以继续选择容器或停止，因此 $q_i = \max(1 - p_i, \frac {1} {n}\sum_{j} q_{i + a_j})$。$p_i$ 和 $1 - q_i$ 的区别在于对于 $p_i$，先手可以继续决策，但 $q_i$ 只允许后手决策。

设 $C = L - m$，因为 $X$ 最终必然落在 $(C, L]$ 之间，所以答案等于 $\sum_{i = C + 1} ^ L f_{C, i} q_i$。

现在只要求 $f_C$。

$f$ 的形式让我们想到常系数齐次线性递推，但它不是严格意义上的线性递推，因为线性递推是每次求出一个元素，而 $f$ 是每次用一个元素贡献它后面的元素。但是我们可以借用线性递推的思想：**多项式取模**。对于每个 $a_i$，为了让 $\frac 1 n [x ^ k]$ 贡献至 $[x ^ {k - a_j}]$，我们构造 $A = x ^ m - \sum_{j = 1} ^ n \frac 1 n x ^ {m - a_j}$。考虑 $c_k x ^ k$ 模 $A$，发现 $\frac {c_k} {n}$ 会贡献到每个 $x ^ {k - a_j}$ 前的系数，符合我们的要求。

注意这样得到的值是反过来的，也就是下标较小的值为多项式较高次项的系数，所以先翻转系数（$x ^ i$ 前的系数翻转到 $x ^ {m - i - 1}$ 前），发现 $[x ^ k]$ 等于某个 $f_{i, i + k + 1}$。又因为 $x ^ m$ 模 $A$ 得到的多项式系数翻转后，$[x ^ k]$ 等于 $f_{0, k + 1}$，可知 $x ^ L \bmod A$ 处理后得到 $f_{L - m}$，即我们要求的 $f_C$。倍增 + 暴力多项式乘法 + 暴力多项式取模即可。

时间复杂度 $\mathcal{O}(m ^ 2\log L)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ull = unsigned long long;

bool Mbe;
constexpr int N = 4e3 + 5;
int n, mx, L;
double w, a[N], f[N], g[N], p[N], q[N];
void mul(double *f, double *g) { // 计算 f * g mod A
  static double h[N];
  memset(h, 0, sizeof(h));
  for(int i = 0; i < mx; i++)
    for(int j = 0; j < mx; j++)
      h[i + j] += f[i] * g[j];
  for(int i = mx * 2 - 2; i >= mx; i--)
    for(int j = 1; j <= mx; j++)
      h[i - j] += h[i] * a[j];
  for(int i = 0; i < mx; i++) f[i] = h[i];
}

bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  #ifdef ALEX_WEI
    FILE* IN = freopen("1.in", "r", stdin); 
    FILE* OUT = freopen("1.out", "w", stdout);
  #endif
  cin >> n >> L, w = 1.0 / n;
  for(int i = 1, v; i <= n; i++) {
    cin >> v, mx = max(mx, v), a[v] += w;
    // a 表示多项式对 A 取模时的系数，而不是 A
  }

  f[0] = 1, g[1] = 1;
  while(L) { // 计算 x ^ L mod A
    if(L & 1) mul(f, g);
    mul(g, g), L >>= 1;
  }
  reverse(f, f + mx);
  // 设 C = L - mx, f[i] 表示要求 > C 时，取到 C + i + 1 的概率

  memcpy(g, f, sizeof(f));
  // 接下来从 0 到 mx - 1 枚举 i，其中 g[i + j] 表示：
  // 在循环开头，要求 Y > C + i 时 Y = C + i + j + 1 的概率
  // 在循环结尾，要求 Y > C + i + 1 时 Y = C + i + j + 1 的概率
  p[0] = 1;
  // 计算 p[i] 表示 X = C + i + 1 时，后手的 Y 在 (C + i + 1, L] 之间的概率
  for(int i = 0; i < mx; i++) {
    if(i) p[i] = p[i - 1];
    for(int j = 1; j <= mx; j++) { // 后手在 Y = C + i + 1 时必须继续选择容器
      if(i + j >= mx) p[i] -= g[i] * a[j];
      // 当 i + j >= mx 时，Y = C + i + j + 1 > L，超出限制，g[i] * a[j] 不会贡献至 p[i]
      else g[i + j] += g[i] * a[j];
      // 否则累加入 Y = C + i + j + 1 对应的 g[i + j]
    }
  }

  double ans = 0;
  for(int i = mx - 1; ~i; i--) {
    // 计算 q[i] 表示 X = C + i + 1 时的胜率，p 和 q 的区别在于对于后者，先手还可以继续选择
    // 要么不选容器，胜率为 p[i]；要么选容器，从接下来的 q 转移
    for(int j = 1; i + j < mx; j++) q[i] += q[i + j] * a[j];
    q[i] = max(q[i], 1 - p[i]);
    ans += f[i] * q[i];
  }
  printf("%.12lf\n", ans);

  cerr << 1e3 * clock() / CLOCKS_PER_SEC << " ms\n";
  return 0;
}
```

---

## 作者：dead_X (赞：0)

## 题解
首先如果 $L\leq 2\times 10^3$ 问题是简单的：

- 对于每个 $i$，我们求出如果 A 装入了 $i$ 份，B 获胜的概率，这个可以 $O(nL)$ 求出。
- 对于每个 $i$，我们求出 A 已经装了 $i$ 份后获胜的概率，决策可以选择再装一桶或者停止，通过前缀和也可以 $O(nL)$ 求出。

然后我们考虑当 $x<L-\max A$ 的时候，A 装 $x$ 份是必输的，因为此时 B 只要没装到 $x$ 份就继续装，一定能超过 A 且不溢出。

因此我们只需要求出 A 装 $[L-\max A,L]$ 份的概率。不难发现这是一个常系数齐次线性递推，可以 $O((\max A)^2\log L)$ 求单项，$O(\max A)$ 求下一项。

时间复杂度 $O((\max A)^2\log L)$。
## 代码
队友写的。

```cpp
//不回家了，我们去鸟巢！
#include<bits/stdc++.h>
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
double a[8008],f[8008],g[8008],h[4003];
double sdt[8008],ps[8008];
const int N=2000;
void mul(double *F,double *G,double *R)
{
    memset(h,0,sizeof(h));
    for(int i=0; i<=N; ++i)
        for(int j=0; j<=N; ++j)
            h[i+j]+=F[i]*G[j];
    for(int i=N*2; i>N; --i)
        for(int j=1; j<=N; ++j)
            h[i-j]+=h[i]*a[j];
    for(int i=0; i<=N; ++i) R[i]=h[i];
    return ;
}
double ans[100003];
double p[8008],Q[8008],*q=Q+4002,win[8008],tmp_q[8008];
signed main()
{
    int n=read(),L=read();
    double w=1.0/n;
    sdt[0]=1;
    for(int i=1,x; i<=n; ++i) a[read()]+=w;
    for(int i=1; i<=4000; ++i)
        for(int j=1; j<=2000; ++j)
            if(i-j>=0)sdt[i]+=sdt[i-j]*a[j];
    for(int i=1;i<=2000;i++)ps[i]=ps[i-1]+a[i];
    int m=max(L-4000,0);
    if(L<=4000)
    {
        for(int i=0;i<=L;i++)
        {
            for(int j=i-1;j>=0;j--)p[i]+=(ps[min(L-j,2000)]-ps[min(2000,i-j-1)])*sdt[j];
            // printf("%.6lf ",p[i]);
        }
        p[0]++;
        win[L]=1;
        for(int i=L-1;i>=0;i--)
        {
            double p1=0,p2=0;
            for(int j=1;j<=2000;j++)p1+=a[j]*win[i+j];
            p2=p[i+1];
            win[i]=max(p1,1-p2);
        }
        double ns=0;
        printf("%.12lf\n",win[0]);
        return 0;
    }
    memset(f,0,sizeof(f)),
    memset(g,0,sizeof(g));
    f[1]=1,g[0]=1;
    while(m)
    {
        if(m&1) mul(f,g,g);
        mul(f,f,f),m>>=1;
    }
    for(int i=0; i<=N; ++i)
        ans[0]+=sdt[i]*g[i];
    m=L-4000;
    for(int i=1; i<=L-m; ++i)
    {
        for(int j=N; j>=0; --j) g[j+1]=g[j];
        g[0]=0;
        for(int j=1; j<=N; ++j) g[N+1-j]+=a[j]*g[N+1];
        for(int j=0; j<=N; ++j) ans[i]+=sdt[j]*g[j];
    }
    for(int i=0;i<4000;i++)
    {
        int j=L-m-i;
        if(j>=0)q[2000-i]=ans[j];
    }
    for(int i=1;i<=2000;i++)tmp_q[i]=q[i],q[i]=0;
    o_o:;
    double sumq=0;
    for(int i=2000;i>=1;i--)
    {
        for(int j=1;j<=2000;j++)
            q[i]+=q[i-j]*a[j];
        // printf("%.6lf ",q[i]);
        sumq+=q[i];
    }
    // puts("");
    for(int i=2000;i>=1;i--)
    {
        for(int j=i;j<=2000;j++)p[i]+=q[j];
        for(int j=i-1;j>=1;j--)
            p[i]+=(ps[2000-j]-ps[i-j-1])*tmp_q[j];
    }
    // for(int i=1;i<=2000;i++)printf("%.6lf ",p[i]);puts("");
    // puts("");
    // for(int i=1999;i>=0;i--)p[i]+=p[i+1];
    win[2000]=1;
    for(int i=1999;i>=1;i--)
    {
        double p1=0,p2=0;
        for(int j=1;j<=2000;j++)p1+=a[j]*win[i+j];
        p2=p[i+1];
        win[i]=max(p1,1-p2);
    }
    double ns=0;
    for(int i=1;i<=2000;i++)ns+=q[i]*win[i];
    printf("%.12lf\n",ns);
    // for(int i=-2000;i<=2000;i++)printf("%.6lf ",q[i]);
    // for(int i=0; i<L; ++i) printf("%.8lf\n",ans[i]);
    return 0;
}
```

---


# [CERC2019] K==S

## 题目背景

**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[K==S](https://contest.felk.cvut.cz/19cerc/solved/kequalss.pdf)」**

## 题目描述

渐进式硬八度摇滚曲调（所谓的“phorts”）是使用特定的音符创作的。这种摇滚风格只建立在 $13$ 个不同的音符音高上，其他音高（在其他八度中）被认为是过时的音乐基石。每个音符可以是长的，也可以是短的。因此，摇滚中正好有 $26$ 个不同的音符。

你将在你朋友的生日之际创作一首 phort 曲调，并与你的乐队在主要的城市广场上表演。在创作词缀时，你需要避免使用某些音乐短语，这些短语由于大型唱片公司赞助的长期研究而受到版权保护。已经证实，这些短语非常朗朗上口，易于记忆，可以用来将听众下意识地与某个特定的音乐公司联系起来，该公司会在他们的制作中使用这些短语。

曲调是一连串的音符。一个音乐短语也是一个音符序列，如果它的音符形成曲调的连续子序列，则它被认为包含在曲调中，这意味着相同的音符以相同的顺序出现在曲调中。

幸运的是，到目前为止，只有少数禁用短语获得了专利。因此，你可以相对自由地创作自己的曲调。特别是，您对某些长度的可接受的曲调的数量感兴趣。可接受的曲调是指任何不包含禁用短语的曲调。曲调的长度等于它所包含的音符数。

## 样例 #1

### 输入

```
2 3
1 a
1 b
1 c
```

### 输出

```
529
```

## 样例 #2

### 输入

```
3 3
2 aa
1 a
1 a
```

### 输出

```
15625
```

## 样例 #3

### 输入

```
3 1
2 ab
```

### 输出

```
17524
```

# 题解

## 作者：Hoks (赞：2)

## 前言
比较简单的 ACAM+矩阵优化 dp。

广告：[串串博客](https://www.luogu.com.cn/article/dv6dig1o)。

类似题目：

[P3502 [POI2010] CHO-Hamsters](https://www.luogu.com.cn/problem/P3502)。

[SP1676 GEN - Text Generator](https://www.luogu.com.cn/problem/SP1676)。

[CF696D Legen...](https://www.luogu.com.cn/problem/CF696D)。

[P3715 [BJOI2017] 魔法咒语](https://www.luogu.com.cn/problem/P3715)。

最后一题是这题的严格加强版（指加强到你被迫打个暴力）。

（这四个人认为难度单增，这题貌似可以放在最前面？）
## 思路分析
这个题就很小清新了，因为笔者写过这题的严格加强版。

发现是给定的 $q$ 个串不能出现即为多模匹配，考虑对于这 $q$ 个字符串建出 ACAM，给末尾打上标记，再在 fail 树建出来的时候传一下标记。

然后考虑怎么计算方案数。

由于是计数问题，且 $q$ 不大，直接考虑跑暴力 dp。

套路地设计 $dp_{i,j}$ 表示填了 $i$ 位，在 ACAM 上跑到状态 $j$ 时的方案数。

转移的时候考虑大力，尝试每个字符往下转移。

假设最后返回的状态为 $x$，那么转移方程式即为：
$$dp_{i+1,x}=dp_{i,j}$$

转移的时候记得累加一下和就行了。

最后的答案就是 $\sum\limits^{tot}_{i=1}dp_{l,n}$。

$tot$ 表示 ACAM 中的状态数，后面同。

理由也很简单，最后可能停留在 ACAM 上的任意一个点上。

接着考虑怎么优化，套路的想到把 ACAM 上的一个状态看做一个点，把走 $1$ 步的方案数的邻接矩阵 $base$ 处理出来后 $base^l$ 表示走 $l$ 步的方案数。

那这样的话最后的答案就 $\sum\limits^{tot}_{i=1}res_{0,i},res=base^l$。

构造矩阵时直接每个节点尝试往下匹配就行了，然后判断一下这两个状态是不是都可以走即可。
## 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=210,INF=0x3f3f3f3f3f3f3f3f,mod=1e9+7;
int n,m,l,le,ans,mx,len[N],dp[N][N];char s[N][N],t[N];
struct ACAM
{
	struct node{int nxt,ed,v[26];}t[N];int tot=0;
	inline void insert(char s[],int n)
	{
		int u=0;
		for(int i=1;i<=n;i++){if(!t[u].v[s[i]-'a']) t[u].v[s[i]-'a']=++tot;u=t[u].v[s[i]-'a'];}
		t[u].ed=1;
	}
	inline void build()
	{
		queue<int>q;
		for(int i=0;i<26;i++) if(t[0].v[i]) t[t[0].v[i]].nxt=0,q.push(t[0].v[i]);
		while(!q.empty())
		{
			int u=q.front();q.pop();t[u].ed|=t[t[u].nxt].ed;
			for(int i=0;i<26;i++)
				if(t[u].v[i]) t[t[u].v[i]].nxt=t[t[u].nxt].v[i],q.push(t[u].v[i]);
				else t[u].v[i]=t[t[u].nxt].v[i];
		}
	}
}ac;
struct Matrix
{
	int a[N][N];
	Matrix(){memset(a,0,sizeof a);}
};
namespace Fast_IO
{
    static char buf[1000000],*paa=buf,*pd=buf;
    #define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
    inline int read()
    {
        int x(0),t(1);char fc(getchar());
        while(!isdigit(fc)&&fc!=-1){if(fc=='-') t=-1;fc=getchar();}
        while(isdigit(fc)&&fc!=-1) x=(x<<1)+(x<<3)+(fc^48),fc=getchar();
        if(fc==-1) exit(0);return x*t;
    }
    inline void print(int x)
    {
        if(x<0) putchar('-'),x=-x;
        if(x>9) print(x/10);
        putchar(x%10+'0');
    }
    inline bool chk(char c) { return !(c>='a'&&c<='z'); }
    inline bool ck(char c) { return c!='\n'&&c!='\r'&&c!=-1; }
    inline void rd(char s[],int&n)
    {
        s[++n]=getchar();
        while(chk(s[n])) s[n]=getchar();
        while(ck(s[n])) s[++n]=getchar();
        n--;
    }
}
using namespace Fast_IO;
Matrix mul(Matrix x,Matrix y)
{
	Matrix res;
	for(int i=0;i<=mx;i++)
		for(int j=0;j<=mx;j++)
			for(int k=0;k<=mx;k++)
			{
				res.a[i][j]+=x.a[i][k]*y.a[k][j];
				res.a[i][j]=res.a[i][j]>=mod?res.a[i][j]%mod:res.a[i][j];
			}
	return res;
}
inline Matrix ksm(Matrix x,int y)
{
	Matrix res;for(int i=0;i<=mx;i++) res.a[i][i]=1;
	while(y)
	{
		if(y&1) res=mul(res,x);
		x=mul(x,x);y>>=1;
	}
	return res;
}
signed main()
{
	l=read(),m=read();
	for(int i=1;i<=m;i++) read(),le=0,rd(t,le),ac.insert(t,le);
	ac.build();Matrix base;mx=ac.tot;
	for(int x=0;x<=ac.tot;x++)
		for(int i=0;i<26;i++)
		{
			int v=ac.t[x].v[i];
			if(!ac.t[x].ed&&!ac.t[v].ed) base.a[x][v]++;
		}
	Matrix tt=ksm(base,l),t;t.a[0][0]=1;t=mul(t,tt);
	for(int pos=0;pos<=ac.tot;pos++) ans=(ans+t.a[0][pos])%mod;
	print(ans);
	return 0;
}
```

---

## 作者：Fzrcy (赞：0)

首先对禁用短语建立 AC 自动机，设 $ban_i$ 表示节点 $i$ 是否存在后缀 $x$ 为禁用短语，那么一个从节点 1 开始且不经过任何一个 $ban_i=1$ 的节点的长度为 $L$ 的路径就是一个合法的曲调。

设 $f_{T,i}$ 表示从节点 1 开始且不经过任何一个 $ban_i=1$ 的节点的长度为 $T$ 的结尾为 $i$ 的路径方案数，大力转移即可。

显然这个转移可以用矩阵快速幂加速，时间复杂度 $O((\sum|s|)^3\log n)$，其中 $\sum|s|$ 表示所有禁用短语的长度总和。

```cpp
// qwq
#include <bits/stdc++.h>
using namespace std;
namespace Work{
    typedef long long ll;
    constexpr int N=102;
    constexpr int mo=1e9+7;
    int ch[N][26],fail[N],cnt=1,n,m,ban[N];
    char s[N];
    inline int suf(int x,int y){return x+=y,x>=mo?x-mo:x;}
    struct mat{
        int a[102][102];
        mat(){memset(a,0,sizeof a);}
        mat operator * (mat b){
            mat ret;
            for(int i=1;i<=cnt;i++) for(int j=1;j<=cnt;j++)
                for(int k=1;k<=cnt;k++)
                    ret.a[i][j]=suf(ret.a[i][j],(ll)a[i][k]*b.a[k][j]%mo);
            return ret;
        }
    };
    mat ksm(mat x,int y){
        mat ret;for(int i=1;i<=cnt;i++)ret.a[i][i]=1;
        for(;y;y>>=1,x=x*x)if(y&1)ret=ret*x;return ret;
    }
    void ins(char *s,int len){
        int u=1;
        for(int i=1,c;i<=len;i++,u=ch[u][c])
            !ch[u][c=s[i]-'a']&&(ch[u][c]=++cnt);
        ban[u]=1;
    }
    void build(){
        for(int i=0;i<26;i++)ch[0][i]=1;
        queue<int>q; q.push(1);
        while(!q.empty()){
            int u=q.front();q.pop();ban[u]|=ban[fail[u]];
            for(int i=0;i<26;i++)
                if(!ch[u][i])ch[u][i]=ch[fail[u]][i];
                else fail[ch[u][i]]=ch[fail[u]][i],q.push(ch[u][i]);
        }
    }
    int Main(){
        scanf("%d %d",&n,&m);
        for(int i=1,len;i<=m;i++)
            scanf("%d %s",&len,s+1),ins(s,len);
        build();
        mat a,b;a.a[1][1]=1;
        for(int i=1;i<=cnt;i++)if(!ban[i])
            for(int j=0;j<26;j++)if(!ban[ch[i][j]])
                b.a[i][ch[i][j]]++;
        a=a*ksm(b,n);
        int ans=0;
        for(int i=1;i<=cnt;i++)
            if(!ban[i])ans=suf(ans,a.a[1][i]);
        cout<<ans<<'\n';
        return 0;
    }
}
int main(){
    Work::Main();
    return 0;
}
```

---

## 作者：daniEl_lElE (赞：0)

建起来 AC 自动机，不难发现本质上就是 AC 自动机上一些点不能经过，然后在上面跑 dp。

AC 自动机上首先将串结尾点打上 $tag$，找 $fail$ 时需要对所有 $fail$ 指针指向的点 $tag$ 为 $1$ 的也变成 $1$。

朴素 dp 是容易的，考虑 $dp_{i,j}$ 表示已经有长度为 $i$ 的字符串，目前在 AC 自动机上 $j$ 点。

不难发现 $dp_{i,j}$ 仅与 $dp_{i-1,k}$ 有关，且第二维较小第一维较大，显然可以矩阵快速幂优化。

总复杂度 $O(V^3\log n)$，其中 $V$ 为 AC 自动机点数。

```cpp
#include <bits/stdc++.h>
#define int long long
#define double long double
#define mid ((l+r)>>1)
using namespace std;
const int mod=1e9+7;
int trie[105][26],fail[105],tag[105],cnt;
struct mtx{
	int a[105][105];
}ept;
mtx mul(mtx x,mtx y){
	mtx z=ept;
	for(int i=0;i<=100;i++){
		for(int j=0;j<=100;j++){
			for(int k=0;k<=100;k++){
				(z.a[i][k]+=x.a[i][j]*y.a[j][k])%=mod;
			}
		}
	}
	return z;
}
mtx qp(mtx a,int b){
	mtx ans=ept; for(int i=0;i<=100;i++) ans.a[i][i]=1;
	while(b){
		if(b&1) ans=mul(ans,a);
		a=mul(a,a);
		b>>=1;
	}
	return ans;
}
mtx base;
signed main(){
	int n,q; cin>>n>>q;
	for(int i=1;i<=q;i++){
		int l; cin>>l;
		string s; cin>>s;
		int now=0;
		for(int j=0;j<l;j++){
			if(!trie[now][s[j]-'a']) trie[now][s[j]-'a']=++cnt;
			now=trie[now][s[j]-'a'];
		}
		tag[now]=1;
	}
	queue<int> qq;
	for(int i=0;i<26;i++) if(trie[0][i]) qq.push(trie[0][i]);
	while(!qq.empty()){
		int f=qq.front(); qq.pop();
		for(int i=0;i<26;i++){
			if(trie[f][i]) fail[trie[f][i]]=trie[fail[f]][i],tag[trie[f][i]]|=tag[fail[trie[f][i]]],qq.push(trie[f][i]);
			else trie[f][i]=trie[fail[f]][i];
		}
	}
	for(int i=0;i<=cnt;i++){
		for(int j=0;j<26;j++){
			if(!tag[trie[i][j]]){
				base.a[i][trie[i][j]]++;
			}
		}
	}
	base=qp(base,n);
	int ans=0; for(int i=0;i<=cnt;i++) (ans+=base.a[0][i])%=mod;
	cout<<ans;
	return 0;
}

```

---


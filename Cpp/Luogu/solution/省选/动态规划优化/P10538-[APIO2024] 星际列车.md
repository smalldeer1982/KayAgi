# [APIO2024] 星际列车

## 题目描述

**请勿使用 C++14 (GCC 9) 提交。**

在 2992 年，机器人已经取代了人类的大部分工作，大家都有着大量的空闲时间。因此你和家人决定利用这些时间来一场星际旅行。

有 $N$ 个人类已经可以到达的行星，编号为 $0$ 到 $N - 1$，以及 $M$ 种不同的星际列车路线。第 $i$ 种列车路线 ($0 \le i < M$) 在时间 $A[i]$ 从行星 $X[i]$ 出发，在时间 $B[i]$ 到达行星 $Y[i]$，票价为 $C[i]$。在行星之间，这些星际列车是仅有的交通方式。对于你搭乘的一列星际列车，你只能在它的终点站下车，并且你搭乘的下一趟列车的起点站必须和这趟列车的终点站相同（这里认为换乘不耗时）。形式化地，你可以依次乘坐第 $q[0], q[1], \ldots, q[P]$ 次列车，当且仅当对任意 $1 \le k \le P$ 都有 $Y[q[k - 1]] = X[q[k]]$，$B[q[k - 1]] \le A[q[k]]$。

在不同行星之间移动是非常耗时的，所以除了车票钱，餐费支出也不可忽视。列车上免费提供不限量的食物，也就是在列车上吃饭不花钱：如果你决定乘坐第 $i$ 种星际列车，则在任何 $A[i]$ 到 $B[i]$ 之间的时刻（包括端点）你都可以免费吃任意多顿饭。但如果你决定在行星 $i$ 吃饭，每顿饭都需要 $T[i]$ 元。

你和家人在旅途中总共需要吃 $W$ 顿饭，第 $i\ (0 \le i < W)$ 顿饭可以在 $L[i]$ 到 $R[i]$（包括端点）的任何时刻吃，吃饭不耗费时间。吃饭没有顺序要求，例如允许在吃完第 $1$ 顿饭后再吃第 $0$ 顿饭（见样例 $2$）。

现在是 $0$ 时刻，你和家人正在 $0$ 号行星上。你需要求出到达 $N - 1$ 号行星的最小花费，花费定义为车票价格和餐费之和。如果无法到达 $N - 1$ 号行星，最小花费定义为 $-1$。

### 实现细节

你无需在程序开头引入库 `train.h`。

你只需要实现以下函数：

```cpp
long long solve(int N, int M, int W, std::vector<int> T,
                std::vector<int> X, std::vector<int> Y,
                std::vector<int> A, std::vector<int> B, std::vector<int> C,
                std::vector<int> L, std::vector<int> R);
```

+   $N$：行星数量。
+  $ M$：星际列车路线数量。
+   $W$：需要用餐的次数。
+   $T$：一个长度为 $N$ 的数组。$T[i]$ 表示在行星 $i$ 每次用餐的花费。
+   $X, Y, A, B, C$：五个长为 $M$ 的数组。$(X[i], Y[i], A[i], B[i], C[i])$ 描述了第 $i$ 条列车路线。
+   $L, R$：两个长为 $W$ 的数组。$(L[i], R[i])$ 描述了第 $i$ 顿饭的用餐时间。
+   你需要返回从行星 $0$ 到达行星 $N - 1$ 的最小花费。如果行星 $N - 1$ 不可达，返回 $-1$。
+   每个测试点中，该函数恰好被调用一次。

## 说明/提示

### 样例解释

对于样例一，考虑如下调用：

```cpp
solve(3, 3, 1, {20, 30, 40}, {0, 1, 0}, {1, 2, 2},
        {1, 20, 18}, {15, 30, 40}, {10, 5, 40}, {16}, {19});
```

一种可行的方案是依次乘坐第 $0, 1$ 次列车，花费为 $45$，具体流程如下：

| 时刻 | 你的行动 | 花费 |
| :---: | :---: | :---: |
| $1$ | 乘坐第 $0$ 次列车从 $0$ 号行星出发 | $10$ |
| $15$ | 到达 $1$ 号行星 |  |
| $16$ | 在 $1$ 号行星吃第 $0$ 顿饭 | $30$ |
| $20$ | 乘坐第 $1$ 次列车从 $1$ 号行星出发 | $5$ |
| $30$ | 到达 $2$ 号行星 |  |

一种更优的方案是乘坐第 $2$ 次列车，花费为 $40$，具体流程如下：

| 时刻 | 你的行动 | 花费 |
| :---: | :---: | :---: |
| $18$ | 乘坐第 $2$ 次列车从 $0$ 号行星出发 | $40$ |
| $19$ | 在第 $2$ 次列车上吃第 $0$ 顿饭 |  |
| $40$ | 到达 $2$ 号行星 |  |

在这种方案中，在时刻 $18$ 在第 $2$ 次列车上吃第 $0$ 顿饭也是合法的。

因此函数应该返回 $40$。

对于样例二，考虑如下调用：

```cpp
solve(3, 5, 6, {30, 38, 33}, {0, 1, 0, 0, 1}, {2, 0, 1, 2, 2},
        {12, 48, 26, 6, 49}, {16, 50, 28, 7, 54}, {38, 6, 23, 94, 50},
        {32, 14, 42, 37, 2, 4}, {36, 14, 45, 40, 5, 5});
```

最优解是：乘坐第 $0$ 次列车，车费为 $38$。在第 $0$ 次列车上免费吃第 $1$ 顿饭。第 $0, 2, 3$ 顿饭在行星 $2$ 上吃 ，花费 $33 \times 3 = 99$。 第 $4, 5$ 顿饭在行星 $0$ 上吃，花费 $30 \times 2 = 60$。总花费为 $38 + 99 + 60 = 197$。

因此函数应该返回 $197$。

### 数据范围

+   $2 \le N \le 10^5$
+   $0 \le M, W \le 10^5$
+   $0 \le X[i], Y [i] < N, X[i] \neq Y[i]$
+   $1 \le A[i] < B[i] \le 10^9$
+   $1 \le T[i], C[i] \le 10^9$
+   $1 \le L[i] \le R[i] \le 10^9$

详细子任务附加限制及分值如下表所示。

| 子任务编号 | 附加限制 | 分值 |
| :---: | :---: | :---: |
| $1$ | $N, M, A[i], B[i], L[i], R[i] \le 10^3, W \le 10$ | $5$ |
| $2$ | $W = 0$ | $5$
| $3$ | 每顿饭的用餐时间两两不交。形式化地，对于任何时刻 $z$ 满足 $1 \le z \le 10^9$，至多存在一个 $i\ (0 \le i < W)$ 使得 $L[i] \le z \le R[i]$。 | $30$ |
| $4$ | 没有额外的约束条件 | $60$ |

## 样例 #1

### 输入

```
3 3 1 
20 30 40
0 1 1 15 10
1 2 20 30 5
0 2 18 40 40
16 19```

### 输出

```
40```

## 样例 #2

### 输入

```
3 5 6
30 38 33
0 2 12 16 38
1 0 48 50 6
0 1 26 28 23
0 2 6 7 94
1 2 49 54 50
32 36
14 14
42 45
37 40
2 5
4 5```

### 输出

```
197```

# 题解

## 作者：TernaryTree (赞：19)

献给我死去的 APIO2024。

显然要 $dp$，也就是 $f_i$ 表示经过边 $i$，到达点 $Y_i$ 的最少代价。方便起见，我们多加两个起点到起点（$0$ 时刻到 $0$ 时刻，代价为 $0$），终点到终点（$\infin$ 时刻到 $\infin$ 时刻，代价为 $0$）的边，编号为 $0$ 和 $m+1$。于是我们要求的就是 $f_{m+1}$。有转移方程：

$$f_i=C_i+\min_{X_i=Y_j,B_j\le A_i}f_j+T_{X_i}\cdot  w(B_j+1,A_i-1)$$

其中 $cost(l,r)$ 表示被 $[l,r]$ 完全包含的 $[L[i],R[i]]$ 个数。

我们维护两个边集 $e$ 和 $ej$，一个是所有我们要计算 $f_i$ 的 $i$，一个是当前可以被转移的 $j$。显然地，$e$ 按照 $A_i$ 排序，$ej$ 按照 $B_j$ 排序，这样每次我们的决策点与被决策点都是一段前缀，使用双指针很好处理，也方便理解决策单调性。

通过上面的方程可以推出转移具有决策单调性。具体地，若 $i_1\lt i_2$，$e_{i_1}$ 的最优决策点为 $p_1$（即，从 $ej_{p_1}$ 转移过来），$e_{i_2}$ 的最优决策点为 $p_2$，则 $p_1\le p_2$。

处理决策单调性 dp 的方法是二分队列。很不幸我 APIO 之前并不会这个 trick。其过程如下：

维护结构体队列，结构体形如 $(j,l,r)$，表示 $j$ 决策点可以决策 $[l,r]$ 这段区间。

- 对于加入决策点 $j$：

  在队尾进行操作。如果一个队尾 $(j',l',r')$ 中，决策 $j'$ 在 $l'$ 时的价值劣于新加入的决策点 $j$ 在 $l$ 时的价值，则弹出队尾，反复进行直到不满足为止。此时仍需要对队尾 $(j',l',r')$ 进行划分，考虑类似地二分出决策点 $j$ 可以“占领”哪些部分，将其从队尾中分裂出去即可。
  
- 对于计算 $i$ 的答案：

  在队头进行操作。若队头 $(j,l,r)$ 中 $r<i$ 说明队头过时，弹出。反复进行操作，最后得到的队头中的 $j$ 即为最优决策点。同时把队头中的 $l$ 缩减到 $i$ 即可。
  
但是由于方程中还有一个 $Y_i=X_j$ 的限制，所以要对每个结点都维护一个上述队列。同时，$(j,l,r)$ 的含义也有改动：表示当前所在队列对应结点 $u$ 可以转移到的 $i$ 是第 $l$ 个到第 $r$ 个（起点与当前结点相同的），必要时再套一个二分即可。至于 $cost(l,r)$ 的计算，可以离散化所有时间戳后使用主席树维护。于是总复杂度为 $\Theta(n\log ^2n)$。

shitcode:

```cpp
struct edge {
	int u, v, p, q, w, id;
};

struct op {
	int j, l, r;
};

struct QwQ {
	vector<op> q;
	int hd = 0, tl = -1;
	void push_back(op x) { q.push_back(x), ++tl; }
	void pop_back() { q.pop_back(), --tl; }
	bool empty() { return hd > tl; }
	op& front() { return q[hd]; }
	op& back() { return q[tl]; }
	void pop_front() { hd++; }
};

struct node {
	int ch[2] = {};
	int sum = 0;
};

node tr[maxn * 22];
int rt[maxn], tot;

void modify(int &u, int pre, int l, int r, int p, int k) {
	tr[u = ++tot] = tr[pre];
	if (l == r) {
		tr[u].sum += k;
		return;
	}
	if (p <= mid) modify(ls, tr[pre].ch[0], l, mid, p, k);
	else modify(rs, tr[pre].ch[1], mid + 1, r, p, k);
	tr[u].sum = tr[ls].sum + tr[rs].sum;
}

int query(int u, int l, int r, int ql, int qr) {
	if (ql <= l && r <= qr) return tr[u].sum;
	int ans = 0;
	if (ql <= mid) ans += query(lc, ql, qr);
	if (qr > mid) ans += query(rc, ql, qr);
	tr[u].sum = tr[ls].sum + tr[rs].sum;
	return ans;
}

ll solve(int n, int m, int w, vi t, vi x, vi y, vi a, vi b, vi c, vi l, vi r) {
	vector<edge> e (m + 2), ej (m + 2); vector<ll> f (m + 2);
	vector<QwQ> que(n); vector<int> buc;
	vector<pii> rg;
	e[0] = {0, 0, 0, 0, 0, 0};
	f[0] = 0;
	rep(i, 0, m - 1) e[i + 1] = {x[i], y[i], a[i], b[i], c[i], i + 1};
	e[m + 1] = {n - 1, n - 1, (int) 1e9 + 1, (int) 1e9 + 2, 0, m + 1};
	rep(i, 0, m + 1) b.push_back(e[i].p), b.push_back(e[i].q);
	rep(i, 0, w - 1) b.push_back(l[i]), b.push_back(r[i]);
	sort(b.begin(), b.end());
	b.resize(unique(b.begin(), b.end()) - b.begin());
	rep(i, 0, m + 1) {
		e[i].p = lower_bound(b.begin(), b.end(), e[i].p) - b.begin() + 1;
		e[i].q = lower_bound(b.begin(), b.end(), e[i].q) - b.begin() + 1;
	}
	rep(i, 0, w - 1) {
		l[i] = lower_bound(b.begin(), b.end(), l[i]) - b.begin() + 1;
		r[i] = lower_bound(b.begin(), b.end(), r[i]) - b.begin() + 1;
		rg.push_back({r[i], l[i]});
	}
	sort(rg.begin(), rg.end());
	rep(i, 0, w - 1) modify(rt[i + 1], rt[i], 0, b.size() + 5, rg[i].sc, 1);
	rep(i, 1, m + 1) f[i] = inf;
	ej = e;
	sort(e.begin(), e.end(), [] (edge x, edge y) {
		return x.p < y.p;
	});
	sort(ej.begin(), ej.end(), [] (edge x, edge y) {
		return x.q < y.q;
	});
	vector<vector<int>> qaq (n);
	rep(i, 0, m + 1) qaq[e[i].u].push_back(i);
	auto val = [&] (int i, int j) -> ll {
		ll ans = f[ej[j].id] + e[i].w;
		int l = ej[j].q + 1, r = e[i].p - 1;
		ll cnt = 0; pii tmp = {r, 1e9};
		auto id = upper_bound(rg.begin(), rg.end(), tmp) - rg.begin();
		cnt = query(rt[id], 0, b.size() + 5, l, b.size() + 5);
		return min(ans + cnt * t[e[i].u], inf);
	};
	int mxj = 0;
	rep(i, 1, m + 1) {
		while (mxj <= (int) ej.size() - 1 && ej[mxj].q <= e[i].p) {
			int x = ej[mxj].v;
			while (!que[x].empty() && val(qaq[x][que[x].back().l], mxj) <= val(qaq[x][que[x].back().l], que[x].back().j)) que[x].pop_back();
			if (que[x].empty()) {
				int pos = lower_bound(qaq[x].begin(), qaq[x].end(), i) - qaq[x].begin();
				if (pos < qaq[x].size()) que[x].push_back({mxj, pos, (int) qaq[x].size() - 1});
				++mxj;
				continue;
			}
			int l = que[x].back().l, r = que[x].back().r + 1;
			while (l < r) {
				if (val(qaq[x][mid], mxj) <= val(qaq[x][mid], que[x].back().j)) r = mid;
				else l = mid + 1;
			}
			que[x].back().r = l - 1;
			if (l < qaq[x].size()) que[x].push_back({mxj, l, (int) qaq[x].size() - 1});
			++mxj;
		}
		int x = e[i].u;
		while (!que[x].empty() && qaq[x][que[x].front().r] < i) que[x].pop_front();
		int g = -1;
		if (!que[x].empty()) {
			int j = que[x].front().j;
			f[e[i].id] = min(f[e[i].id], val(i, j));
			g = j;
			que[x].front().l = lower_bound(qaq[x].begin(), qaq[x].end(), i) - qaq[x].begin();
		}
	}
	return f[m + 1] == inf ? -1 : f[m + 1];
}
```

---

## 作者：5ab_juruo (赞：10)

复读一下官方 sol 的 1log 做法。

令 $f_i$ 表示，转移到第 $i$ 条边，且考虑了所有 $A_i$ 之前的餐食的最小费用。则显然有如下转移：

$$
f_i=\min_{Y_j=X_i,B_j\le A_i}f_j+cost(B_j + 1,A_i - 1)
$$

按照 $A_i$ 升序转移，可以做到平方的复杂度。若要优化，注意到如下性质：

- 对于 $i,j$ 和时刻 $c$，若 $B_i\le B_j$，且 $f_i+cost(B_i+1,c)\ge f_j+cost(B_j+1,c)$，则对于所有 $A_i>c$ 的转移，都是 $j$ 比 $i$ 更优秀。

考虑对每个节点维护一个单调队列状物，将 $Y_i$ 相同的 $i$ 按照 $B_i$ 升序存入链表中，且对于当前时间 $c$ 满足 $f_i+cost(B_i+1,c)$ 递增。若在某一时刻，链表中相邻的 $i,j$ 出现了顺序反转，则将 $i$ 从链表中删除即可。

考虑相邻元素 $i,j$ 何时发生顺序反转，即在 $[B_i+1,B_j]$ 间插入了至少 $\lceil (f_j-f_i)/T_{Y_i}\rceil$ 次餐食，用主席树维护区间第 k 大即可。

将所有事件按照时间升序处理，用小根堆维护，总复杂度 $\mathcal{O}(n\log n)$（视 $N,M,W$ 同阶）。

代码：<https://qoj.ac/submission/445704>

---

## 作者：nullqtr_pwp (赞：10)

出题人玩原神呢。因为 $\color{red}\textbf{whk}$ 不能来，但是我是线上 $\textbf{Fe}$。

显然要离散化时间轴。

考虑将吃饭的代价扔到点上考虑，对于一段在 $[L,R]$ 停留在点 $u$ 的时间而言，会产生 $w(L,R)\times \text{cost}(u)$ 的吃饭代价，其中 $w(L,R)$ 表示被 $[L,R]$ 完全包含的吃饭的线段数量。

有一个显然的 dp，$f_{u,i}$ 表示时刻 $i$ 在点 $u$ 的最小花费，显然有效的状态只有 $O(m)$ 个：每个 $u$ 中，只有入边的终止时间，以及出边的起始时间的 $i$ 是有效的。

朴素的时间复杂度做法是，扫描线时间轴，然后计算入边的所有点的状态，转移就是 $f_{v,st(j)}+w(ed(j),i)\times \text{cost}(u)$ 的 $\min$。注意到这个 $st,ed$ 很脑瘫，考虑把状态直接简化成：$f_i$ 表示到达边 $i$ 的终点时的最小花费。


要干的事情就是：

- 扫描线时间轴，现在是 $p$。
- 考虑起始时间为 $p$ 的所有边，起点是 $u$，从边的终点为 $u$ 的所有 $k$ 进行转移。

### Solution 1
依然是考虑扫描线时间轴，考虑转移是什么。转移形如 $\min(f_j+w(j,i))$。注意到二元函数 $w(i,j)$ 满足**四边形不等式**，即 $\forall a\leq b\leq c\leq d,w(a,c)+w(b,d)\leq w(a,b)+w(c,d)$，因此具有**决策单调性。** 即：对于同一个起点 $u$，起始时间更晚的边，一定不会从，对于起始时间更早的边的决策点，更早的点，进行转移。

因此，对于同一个点进入的所有状态，只需要保留一个单调栈，考虑每个决策点在什么时间可以替代掉前驱，每次加入边，在栈上二分找决策点即可。

总时间复杂度大概是两个 $\log$。
### Solution 2

实际实现写了个这个。

所以同样是扫描线时间轴，但是考虑根号分治。

从前驱来转移是容易的，因为以每个点 $u$ 为终点的边是确定的，可以直接开动态开点线段树。

但是吃饭操作是比较烦人的，显然我们不能每次都把所有涉及这次吃饭的边更新，但是对于同一个点，终止时间排序后的一段前缀会受到影响。

这告诉我们一个点的一些前驱可以统一操作，但是我们是不是要每次都考虑所有点呢？

根号分治，总度数和是定值。

对于度数 $\ge B$ 的点 $u$，每个点使用一棵动态开点线段树，维护以 $u$ 为终点的所有边的最小值。每次能转移过来的是一段关于终止时间的前缀，因此这些边需要按照 $ed$ 排序。这样的点不超过 $\dfrac{n}{B}$ 个。

每次加入一次吃饭时，考虑对这些点直接在线段树上更新代价，暴力取出大度点中的每个点，二分找到哪些边的终止时间会吃这一次饭，是一段前缀，然后在每棵大度点的动态开点线段树上更新即可，需要支持区间加。

另外开一个数据结构，支持多次查询 $w(l,r)$ 表示被 $w(l,r)$ 完全包含的数据结构，此时 $r=p$，$p$ 是当前边的时间。可以使用 $O(\sqrt n)$ 修改，$O(1)$ 查询的分块。

从转移来看。大度点能转移的区间是一段前缀，同样在查询时二分，然后区间查询最小值。小度点暴力转移，在转移时再加上吃饭的代价。

视 $n,m,W$ 同级，时间复杂度 $O(\dfrac{n^2}{B}\log n+nB+n\log n)$。取 $B=\sqrt{n\log n}$ 时，时间复杂度为 $O(n\sqrt {n\log n})$。实测取 $B=1500$ 可以通过。

代码太丑了，不放了。反正代码不长，$154$ 行，$4.7\text{KB}$。

---

## 作者：yemuzhe (赞：8)

这里提供一种二分队列做法。

先把所有列车按 $A _ i$ 排好序。如果我们设 $f _ {i, t}$ 为时间 $t$ 到达第 $i$ 个星球的最小代价，时间空间都会爆，无法通过。

发现有效的 $(i, t)$ 总共只有 $O (m)$ 种。如果设 $f _ i$ 为坐完第 $i$ 次列车的最小代价，则有转移 $f _ i = \min \limits _ {Y _ j = X _ i, B _ j \le A _ i} \{f _ j + T _ {X _ i} \cdot w (B _ j, A _ i)\} + C _ i$，其中 $w (l, r)$ 为时间段 $(l, r)$ 包含的吃饭区间数量。

注意到对于 $a \le b \le c \le d$，有 $w (a, c) + w (b, d) \le w (a, d) + w (b, c)$（后者会多出 $l \in (a, b]$，$r \in [c, d)$ 的区间）。于是对于 $X _ i$ 相同的列车，可以做一遍决策单调性（二分队列）。

注意到一个决策 $i$ 被插入第 $Y _ i$ 个队列的时间 $B _ i$ 并不一定升序，于是我们可以把这些决策压进第 $Y _ i$ 个小根堆里，等处理到后面的 $X _ u = Y _ i$ 时再依次弹出时间 $\le A _ u$ 的决策，加入二分队列即可。

（不知道有没有更优的二分队列做法？）

你说不会维护 $w (l, r)$？跑一遍主席树即可。

警钟撅烂：注意二分队列不要写错！！！

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
#include <queue>
#define N 100005
#define T 400005
#define NLGT 2000005
#define find(x) (lower_bound(lsh+1,lsh+tot+1,x)-lsh)
#define val(id,x,u,v) (f[id]+(long long)::w[x]*((u)<tot?ask(root[(v)-1],1,tot,(u)+1):0))
using namespace std;

const long long inf = 1e18;

int n, m, k, w[N], l[N], r[N], cnt[N];
int tot, lsh[T], lt[N], rt[N];
long long f[N];

struct train
{
	int x, y, a, b, c;
	bool operator < (train a) {return this -> a < a.a;}
} a[N];

struct node
{
	int l, r, x, id;
	node () {}
	node (int u, int v, int w, int t) {l = u, r = v, x = w, id = t;}
	friend bool operator < (node a, node b) {return a.x > b.x;}
};

vector <int> dish[T];
vector <node> q[N];
priority_queue <node> Q[N];

namespace segment_tree
{
	int to, root[T];
	
	struct st
	{
		int lc, rc, sum;
		#define lc(p) tr[p].lc
		#define rc(p) tr[p].rc
		#define sum(p) tr[p].sum
	} tr[NLGT];
	
	void add (int &p, int q, int l, int r, int x)
	{
		tr[p = ++ to] = tr[q], sum (p) ++;
		if (l == r) return ;
		int mid = l + r >> 1;
		if (x <= mid) add (lc (p), lc (q), l, mid, x);
		else add (rc (p), rc (q), mid + 1, r, x);
		return ;
	}
	
	int ask (int p, int l, int r, int x)
	{
		if (!p) return 0;
		if (l == r) return sum (p);
		int mid = l + r >> 1;
		if (x <= mid) return ask (lc (p), l, mid, x) + sum (rc (p));
		return ask (rc (p), mid + 1, r, x);
	}
}
using namespace segment_tree;

int search (int x, int y, int u, int id)
{
	int l = q[x][y].l, r = q[x][y].r;
	while (l < r)
	{
		int mid = l + r + 1 >> 1;
		if (val (q[x][y].id, x, q[x][y].x, mid) < val (id, x, u, mid)) l = mid;
		else r = mid - 1;
	}
	return l;
}

void join (int x, int id, int u)
{
	while (lt[x] <= rt[x] && val (id, x, u, q[x][rt[x]].l) <= val (q[x][rt[x]].id, x, q[x][rt[x]].x, q[x][rt[x]].l)) rt[x] --;
	if (lt[x] <= rt[x]) q[x][rt[x]].r = search (x, rt[x], u, id);
	int pos = lt[x] <= rt[x] ? q[x][rt[x]].r : u;
	if (pos < tot) q[x][++ rt[x]] = node (pos + 1, tot, u, id);
	return ;
}

long long solve (int n, int m, int k, vector <int> W, vector <int> X, vector <int> Y, vector <int> A, vector <int> B, vector <int> C, vector <int> L, vector <int> R)
{
	long long ans = inf;
	::n = n, ::m = m, ::k = k, cnt[1] ++, lsh[++ tot] = 0;
	for (int i = 1; i <= n; i ++) w[i] = W[i - 1];
	for (int i = 1; i <= m; i ++)
	{
		a[i].x = X[i - 1] + 1, a[i].y = Y[i - 1] + 1, a[i].c = C[i - 1];
		lsh[++ tot] = a[i].a = A[i - 1], lsh[++ tot] = a[i].b = B[i - 1];
	}
	for (int i = 1; i <= k; i ++)
	{
		lsh[++ tot] = l[i] = L[i - 1], lsh[++ tot] = r[i] = R[i - 1];
	}
	sort (lsh + 1, lsh + tot + 1);
	tot = unique (lsh + 1, lsh + tot + 1) - lsh - 1;
	for (int i = 1; i <= m; i ++)
	{
		a[i].a = find (a[i].a), a[i].b = find (a[i].b), cnt[a[i].y] ++;
	}
	for (int i = 1; i <= n; i ++)
	{
		q[i] = vector <node> (cnt[i] + 2, node ()), lt[i] = 1, rt[i] = 0;
	}
	for (int i = 1; i <= k; i ++)
	{
		l[i] = find (l[i]), r[i] = find (r[i]);
		dish[r[i]].emplace_back (l[i]);
	}
	for (int i = 1; i <= tot; i ++)
	{
		root[i] = root[i - 1];
		for (auto j : dish[i]) add (root[i], root[i], 1, tot, j);
	}
	sort (a + 1, a + m + 1), q[1][++ rt[1]] = node (1, tot, 1, 0);
	for (int i = 1; i <= m; i ++)
	{
		int x = a[i].x, y = a[i].y, u = a[i].a, v = a[i].b, w = a[i].c;
		while (lt[x] <= rt[x] && q[x][lt[x]].r < u) lt[x] ++;
		while (!Q[x].empty () && Q[x].top ().x <= u)
		{
			if (lt[x] <= rt[x]) q[x][lt[x]].l = u;
			join (x, Q[x].top ().id, Q[x].top ().x), Q[x].pop ();
		}
		if (lt[x] > rt[x]) continue;
		f[i] = val (q[x][lt[x]].id, x, q[x][lt[x]].x, u) + w;
		if (y == n) ans = min (ans, val (i, y, v, tot + 1));
		Q[y].push (node (0, 0, v, i));
	}
	return ans < inf ? ans : -1;
}
```

---

## 作者：bochibochi (赞：7)

一种 $\mathcal O(n\sqrt n)$ 的做法。

本人太笨了，没想到决策单调性。

考虑将所有边按照出发时间排序。设 $f_i$ 表示走完第 $i$ 条边的最小代价。转移方程是

$$
f_i=\min_{ed_j\le st_i}\{f_j+qry(ed_j,st_i)\cdot w_j\}
$$

其中 $qry(l,r)$ 表示吃饭时间为 $(l,r)$ 子区间的饭的数量。$st_i,ed_i$ 分别表示出发时间和到达时间。

我们来暴力维护这个转移，考虑维护这样一个平面，每条边对应一个点，横坐标为边的到达时间，纵坐标为到达点编号，点 $i$ 的权值为 $f_i+qry(ed_i,nw)\cdot w_i$（$nw$ 为当前时间）。初始所有点权值为 $+\infty$。

按顺序枚举所有边。一个吃饭时间 $[l,r]\in [1,nw)$ 相当于对于所有满足 $x\lt l$ 的点权值加上 $w_y$。求 dp 值就是取某一行的权值 $\min$，然后把这个点的权值设为 dp 值。

我们对横坐标分块，块内对纵坐标离散化，这样一次修改一定是 $\frac nB$ 个整块和一个散块，整块打标记，散块暴力重构。查询就直接遍历所有块。

---

## 作者：Purslane (赞：5)

# Solution

写个题解吧！

考虑直接进行动态规划，$dp_e$ 表示乘坐边 $e$ 代表的货车到达这个星球时，**妥善安排好所有 $R \le B_e$ 的餐饮所需要的最小代价**。

对于另一辆火车 $e'$，显然能用 $e$ 转移的条件是 $Y_e = X_{e'}$ 且 $B_e \le A_{e'}$。代价为 $dp_e$，加上完全包含在 $(B_e,A_{e'})$ 中的饭，加上火车 $e'$ 的价钱。第二个量可以用主席树简单维护。

暴力转移是 $O(M^2)$ 的，能不能快一点？

如果不考虑火车 $e'$ 的价钱，那么显然是关于发车时间 $t$ 的函数。如果两个决策点 $B_{e_1} < B_{e_2}$，那么让 $t$ 增加 $1$，$(B_{e_1},t+1)$ 中会多出更多的饭——因此关于上一列火车的结束时间具有决策单调性！

使用二分栈维护可以做到 $O(n \log^2 n)$。思路非常清晰，差不多五分钟就可以完全笃定做法。


代码在哪拷？我记得我在考场上写了个 $4.9 \rm KB$ 的丑陋解法，真的不想再写一遍了。

---

## 作者：ppip (赞：4)

巨大烂 $O(n\log^2 n)$ 做法。

首先将每个点按照相关的时间拆成一些点。指向它的边取到达时间，从它出发的点取离开时间，将所有不同的时间拿出来建虚点。然后将这些点按照时间排序后相邻的从较小的时间点向较大的连边。原图上的边则根据起止时间连对应点的该时间的虚点。记和某个点相关的时间为该点的时间戳。

可以认为这样建图后原图的点都不在了。注意到每条边都从时间戳小的点指向时间戳大的，所以该图是个 DAG，并且到每个点的时间可以认为是确定的（就是该点的时间戳，新加入的边视为等待），所以可以按照时间顺序求出每个点到达时的最小花费。

考虑如何转移。我们独立的考虑每个点拆出来的一系列虚点，注意到我们要做的是按时间顺序求出每个点的代价，每个点可以沿新边或旧边到达，并且对于每顿饭，只有这些时间完全在新边上度过时才需要支付代价。

旧边的贡献是容易计算的，而新边只需要考虑饭的代价。对于两个点 $i,j$ 满足 $t_i<t_j$（$t_i$ 为点 $i$ 的时间戳），其贡献为 $C(i,j)=T_u\times \left(\sum_{k=1}^W [t_i<L_k \wedge R_k<t_j]\right)$，其中 $u$ 为当前点属于的原图上的点。

可以用扫描线维护该贡献。具体地，按照时间从左到右扫描，每次统计扫描到点的答案，并新增它对之后点的贡献。设扫描到的时间为 $x$，维护两棵线段树，一棵对于位置 $y$ 维护 $\sum_{k=1}^W [x<L_k\wedge R_k<y]$，一棵维护每个位置的答案，即 $\max_{z\le x} f_z+C(z,y)$，其中 $f_z$ 为走旧边到达 $z$ 的最小代价。

每次扫描更新时，先更新第一棵线段树的值，然后对第二棵线段树打一个全局 tag，表示当前扫描时间 $x$ 走新边（即等待）到每个时刻的贡献。因为 $x$ 之前的时刻不会再被查询所以无需管它们。

第二棵线段树在两棵线段树结构相同的情况下标记可以直接用第一棵线段树的对应结点和两个常数 $T_u,f_z$ 表示。

这样有两个问题。

一是扫描过程中线段树会变化，对应的标记会出现问题，这可以通过持久化第一棵线段树解决。

第二是标记不支持合并，但是注意到两个标记的序列是单调的，因为维护的是走新边到这个点要吃几顿饭，同理两个标记的差也是单调的，所以两个标记只有一个交点，可以用李超线段树的方式维护。“只有一个交点”这件事本质上也是**决策单调性**。

然后不能对每个原图上的点分别跑扫描线，可以全局跑一个扫描线维护第一个线段树。为保证结构相同，每个结点上的第二棵线段树也需要开成全局的值域。

复杂度离散化后就是 $O(n\log^2 n)$，瓶颈在查询第二棵线段树，需要对每个标记进行一次 $O(\log n)$ 的查询。

```cpp
#include <bits/stdc++.h>
using namespace std;
using LL=long long;
constexpr int N(1e5),M(2e5),V(1e9);
vector<int> tms[N+5];
vector<pair<int,int>> e[M+5];
int tim[M+5],bl[M+5],ll[N+5];
int d[M+5];
LL f[M+5];
struct node1 {
	int l,r,md,tg;
} t[N*60];
int tot;
int modify(int p,int l,int r,int L=0,int R=V+1) {
	int q{++tot};
	t[q]=t[p];
	if (l<=L&&R<=r) {
		++t[q].tg;
		++t[q].md;
		return q;
	}
	int mid{L+R>>1};
	if (l<=mid) t[q].l=modify(t[p].l,l,r,L,mid),++t[q].md;
	if (r>mid) t[q].r=modify(t[p].r,l,r,mid+1,R);
	return q;
}
int query(int p,int k,int L=0,int R=V+1) {
	if (L==R||!p) return t[p].md;
	int mid{L+R>>1};
	return (k<=mid?query(t[p].l,k,L,mid):query(t[p].r,k,mid+1,R))+t[p].tg;
}
LL TL;
struct info {
	LL tg,f=1e18;
	int z;
	LL operator()() {
		return (t[z].md+tg)*TL+f;
	}
	void ml() {
		tg+=t[z].tg;
		z=t[z].l;
	}
	void mr() {
		tg+=t[z].tg;
		z=t[z].r;
	}
};
int rt[N+5];
struct node2 {
	int l,r;
	info d;
} tt[N*60];
int tot2;
void update(int &p,info d,int L=0,int R=V+1) {
	if (!p) {
		p=++tot2;
		tt[p].d=d;
		return;
	}
	int mid{L+R>>1};
	if (d()<=tt[p].d()) {
		swap(tt[p].d,d);
		if (L<R) {
			d.ml();
			update(tt[p].l,d,L,mid);
		}
	} else if (L<R) {
		d.mr();
		update(tt[p].r,d,mid+1,R);
	}
}
LL test(int p,int k,int L=0,int R=V+1) {
	if (L==R||!p) return tt[p].d();
	int mid{L+R>>1};
	LL ans{(query(tt[p].d.z,k,L,R)+tt[p].d.tg)*TL+tt[p].d.f};
	if (k<=mid) ans=min(ans,test(tt[p].l,k,L,mid));
	else ans=min(ans,test(tt[p].r,k,mid+1,R));
	return ans;
}
int RT[N+5],c[N+5];
long long solve(int n, int m, int w, vector<int> T,
				vector<int> X, vector<int> Y,
				vector<int> A, vector<int> B, vector<int> C,
				vector<int> L, vector<int> R) {
	T.insert(T.begin(),0);
	L.insert(L.begin(),0);
	R.insert(R.begin(),0);
	for (int i{0};i<m;++i) {
		++X[i];++Y[i];
		tms[X[i]].push_back(A[i]);
		tms[Y[i]].push_back(B[i]);
	}
	tms[1].push_back(0);
	tms[n].push_back(V+1);
	int cnt{1};
	for (int i{1};i<=n;++i) {
		sort(tms[i].begin(),tms[i].end());
		tms[i].erase(unique(tms[i].begin(),tms[i].end()),tms[i].end());
		ll[i]=cnt;
		for (auto v:tms[i]) {
			tim[cnt]=v;
			bl[cnt]=i;
			++cnt;
		}
	}
	auto get{[&](int x,int t){
		return lower_bound(tms[x].begin(),tms[x].end(),t)-tms[x].begin()+ll[x];
	}};
	for (int i{0};i<m;++i)
		e[get(X[i],A[i])].emplace_back(get(Y[i],B[i]),C[i]);
	iota(d+1,d+cnt,1);
	sort(d+1,d+cnt,[](int x,int y){return tim[x]<tim[y];});
	memset(f,0x3f,sizeof f);
	f[1]=0;
	iota(c+1,c+1+w,1);
	sort(c+1,c+1+w,[&](int x,int y){return L[x]<L[y];});
	for (int i{w};i>=1;--i)
		RT[i]=modify(RT[i+1],R[c[i]]+1,V+1);
	int CNT{1};
	for (int i{1};i<cnt;++i) {
		int u{d[i]};
		TL=T[bl[u]];
		while (CNT<=w&&tim[u]>=L[c[CNT]]) ++CNT;
		update(rt[bl[u]],info{0,f[u],RT[CNT]});
		f[u]=min(f[u],test(rt[bl[u]],tim[u]));
		for (auto [v,w]:e[u]) f[v]=min(f[v],f[u]+w);
	}
	return f[cnt-1]>1e16?-1:f[cnt-1];
}
```

---

## 作者：DaiRuiChen007 (赞：3)

[Problem Link](https://www.luogu.com.cn/problem/P10538)

**题目大意**

> $n$ 个点的城市，$m$ 条线路有起点、终点、开始时间、结束时间、费用，还有 $q$ 个限制表示 $[l,r]$ 时间段内，可以在某条线路上免费吃饭，或者在某个城市 $u$ 以 $w_u$ 的代价吃饭，求 $1\to n$ 的最短路（所有限制都要满足）。
>
> 数据范围：$n,m,q\le10^5$。

**思路分析**

直接建图最短路较为困难，考虑 dp，用 $f_e$ 表示走到 $e$ 的最短花费。

按每条路径的开始时间或结束时间排序，那么转移一定是从前到后的，对于每条边 $i$，设其起点为 $x$，开始时间为 $s$。

我们就要在所有以 $x$ 为终点的边 $j$ 中求出一条，设其结束时间为 $t$，那么 $j\to i$ 的转移系数就是 $f_j$ 加上 $w_x$ 倍的 $(s,t)$ 范围内限制个数。

暴力转移复杂度是平方的，考虑优化。

我们发现转移的代价函数是区间内限制数个数，这显然满足四边形不等式，故有决策单调性。

考虑二分优化，每次求出一条新的边 $i$ 的 $f_i$ 后，就在 $i$ 终点对应的数据结构上插入 $f_i$ 这个决策，在值域上二分出最小的 $x$ 使得 $i$ 是 $x$ 的最优决策，这是简单的。

查询一条边的 $f_i$ 就在其起点的数据结构上二分出开始时间所属的决策。

二分的时候要做一个静态二维数点，主席树维护即可。

时间复杂度 $\mathcal O(m\log^2 V)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
typedef vector<int> vi;
const int MAXN=1e5+5,V=1e9+5;
const ll inf=1e18;
struct SegmentTree {
	int tot,sum[MAXN*32],ls[MAXN*32],rs[MAXN*32];
	void ins(int u,int l,int r,int q,int &p) {
		sum[p=++tot]=sum[q]+1;
		if(l==r) return ;
		int mid=(l+r)>>1;
		if(u<=mid) ins(u,l,mid,ls[q],ls[p]),rs[p]=rs[q];
		else ins(u,mid+1,r,rs[q],rs[p]),ls[p]=ls[q];
	}
	int qry(int u,int l,int r,int p) {
		if(!p||u<=l) return sum[p];
		int mid=(l+r)>>1,s=0;
		if(u<=mid) s=qry(u,l,mid,ls[p]);
		return s+qry(u,mid+1,r,rs[p]);
	}
}	TR;
int n,m,q,rt[MAXN];
struct Seg {
	int l,r;
	bool operator <(const Seg &oth) const { return r<oth.r; }
}	o[MAXN];
struct Edge {
	int u,v,a,b,w;
}	e[MAXN];
int qry(int l,int r) {
	if(l>r) return 0;
	int i=upper_bound(o+1,o+q+1,Seg{l,r})-o-1;
	return TR.qry(l,1,V,rt[i]);
}
struct ds {
	int w;
	struct info {
		int l,r,x; ll d;
	};
	vector <info> q;
	ll f(const info&p,int x) {
		if(p.x>x) return inf;
		return p.d+1ll*w*qry(p.x+1,x-1);
	}
	#define tl (q.back())
	void ins(int x,ll d) {
		info z={0,0,x,d};
		while(q.size()&&f(tl,tl.l)>=f(z,tl.l)) q.pop_back();
		if(q.empty()) return q.push_back({x,V,x,d});
		int l=tl.l,r=tl.r,s=r+1;
		while(l<=r) {
			int mid=(l+r)>>1;
			if(f(tl,mid)>=f(z,mid)) s=mid,r=mid-1;
			else l=mid+1;
		}
		if(s<=V) q.back().r=s-1,q.push_back({s,V,x,d});
	}
	#undef tl
	ll calc(int x) {
		if(q.empty()) return -1;
		int l=0,r=q.size()-1,i=r;
		while(l<=r) {
			int mid=(l+r)>>1;
			if(x<=q[mid].r) i=mid,r=mid-1;
			else l=mid+1;
		}
		if(x<q[i].x) return -1;
		return f(q[i],x);
	}
}	dp[MAXN];
ll Main() {
	sort(o+1,o+q+1);
	for(int i=1;i<=q;++i) TR.ins(o[i].l,1,V,rt[i-1],rt[i]);
	sort(e+1,e+m+1,[&](auto s,auto t){ return s.b<t.b; });
	dp[1].ins(0,0);
	for(int i=1;i<=m;++i) {
		ll f=dp[e[i].u].calc(e[i].a);
		if(~f) dp[e[i].v].ins(e[i].b,f+e[i].w);
	}
	return dp[n].calc(V);
}
ll solve(int N,int M,int W,vi T,vi X,vi Y,vi A,vi B,vi C,vi L,vi R) {
	n=N,m=M,q=W;
	for(int i=1;i<=n;++i) dp[i].w=T[i-1];
	for(int i=0;i<m;++i) e[i+1]={X[i]+1,Y[i]+1,A[i],B[i],C[i]};
	for(int i=0;i<q;++i) o[i+1]={L[i],R[i]};
	return Main();
}
```

---

## 作者：fireinice (赞：3)

赛时想了一个单根号但一直 T，赛后过了。

肯定考虑点边互换，容易发现 $(u_i, v_i, a_i, b_i, c_i)$ 要想更新 $(u_j, v_j, a_j, b_j, c_j)$ 会满足 $a_i < b_i < a_j < b_j$，于是可以扫时间去更新。同时饭肯定尽量在车上吃，所以设到第 $i$ 条边终点的花费为 $w_i$，转移是 $w_j = w_i + c_j + \mathrm{cost}(b_i, c_j) \cdot T_{b_i}$，$\mathrm{cost}(l, r)$ 表示被 $l, r$ 完全包含的吃饭区间数量。

于是扫描线扫边的起点时间 $a$，则每次会：
- 插入一条边，即单点修改某个 $w_i$。
- 加入一个新的吃饭区间 $[l, r] (r < a)$ 的贡献，即所有 $b_i < l$ 的区间 $\mathrm{cost}$ 值加一。
- 算当前边的答案，即给定 $k$ 查 $\min_{b_i=k} w_i + \mathrm{cost}(b_i + c_j)T_{b_i}$。

于是它变成一个数据结构题。没有 $k$ 的限制的话是 KTT 板子，即可以把每个 $i$ 的贡献看成 $T_{b_i}x + w_i$ 的一次函数，要支持单点修改和区间对函数平移，查询最小值。有的话看着很难 Poly log 考虑分块，对序列分块，仿照 KTT 对每个块维护每个 $k$ 的答案和这个块发生线段切换的时间，单点修改直接重构，区间加如果超过切换时间暴力重构，就是对的。

诶但这个势能怎么分析？显然对一个颜色，答案关于平移的值 $x$ 是一个下凸壳，最多有 $O(n)$ 段，再发现每次修改都是把函数向下平移，不可能露出新的段，所以一个块最多切换 $\sqrt n$ 次，复杂度 $n\sqrt n$。

如果可能向上平移呢？相当于再支持删线段，发现相当于每个线段有一个 $x < lim_i$ 的范围限制。由上包络线结论切换次数仍然是线性的。

code:
```cpp
#include "train.h"
#include<set>
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<cstring>
#include<array>
#define endl '\n'
using namespace std;
using ll = long long;
using pi2 = array<int,2>;
using pi3 = array<int,3>;
using pi5 = array<int,5>;
using pl2 = array<ll,2>;
typedef vector<int> veci;
const int N=1e5+500,S=5000;
const ll inf=1e15;
using Line = array<ll,2>;
ll switch_time(Line cur,Line b){
    if(cur[1]<=b[1])return inf;
    return  (b[0]-cur[0])/(cur[1]-b[1]);
}
ll eval(Line l,int x){
    return l[1]*x+l[0];
}
struct DS{
    int col[N];
    Line a[N];
    ll mt[S];
    int tag[S];
    int ans[S][S];
    vector<pi2> cp[N];
    int B=320;
    int n;
    int blk(int x){
        return (x-1)/B+1;
    }
    int lft(int x){
        return min(n+1,(x-1)*B+1);
    }
    void init(){
        for(int b=1;b<=blk(n);b++){
            vector<int> cs;
            for(int i=lft(b);i<lft(b+1);i++)
                cs.push_back(col[i]);
            sort(cs.begin(),cs.end()),cs.erase(unique(cs.begin(),cs.end()),cs.end());
            for(int i=0;i<cs.size();i++)
                cp[cs[i]].push_back({b,i+1});
            for(int i=lft(b);i<lft(b+1);i++)
                col[i]=lower_bound(cs.begin(),cs.end(),col[i])-cs.begin()+1;
        }
        for(int b=1;b<=blk(n);b++)
            remake(b);
    }
    void remake(int b){
        for(int i=lft(b);i<lft(b+1);i++)ans[b][col[i]]=-1;
        for(int i=lft(b);i<lft(b+1);i++)
            a[i][0]+=a[i][1]*tag[b],
            ans[b][col[i]]=(ans[b][col[i]]==-1||a[i]<a[ans[b][col[i]]])?i:ans[b][col[i]];
        tag[b]=0;
        mt[b]=inf;
        for(int i=lft(b);i<lft(b+1);i++)    
            if(i!=ans[b][col[i]])
                mt[b]=min(mt[b],switch_time(a[ans[b][col[i]]],a[i]));
    }
    void pset(int p,ll x){
        a[p][0]=x;
        remake(blk(p));
    }
    ll query(int c){
        ll res=inf;
        for(pi2 p:cp[c])
            res=min(res,eval(a[ans[p[0]][p[1]]],tag[p[0]]));
        return res;
    }
    void range_add(int p){
        for(int i=1;i<blk(p);i++){
            tag[i]++;
            if(tag[i]>mt[i])remake(i);
        }
        for(int i=lft(blk(p));i<=p;i++)
            a[i][0]+=a[i][1];
        remake(blk(p));
    }
} ds;

vector<pi2> rg;
vector<pi5> edges;
int ids[N];
vector<int> vs;
ll dis[N];
int pre[N];
ll  solve(int N, int M, int W, veci T, veci X, veci Y,veci A, veci B, veci C, veci L,veci R){
    for(int i=0;i<M;i++)vs.push_back(A[i]),vs.push_back(B[i]);
    vs.push_back(1e9+1);
    vs.push_back(0);
    sort(vs.begin(),vs.end()),vs.erase(unique(vs.begin(),vs.end()),vs.end());

    for(int i=0;i<M;i++){
        int na=lower_bound(vs.begin(),vs.end(),A[i])-vs.begin(),
            nb=lower_bound(vs.begin(),vs.end(),B[i])-vs.begin();
        edges.push_back(pi5{X[i],Y[i],na,nb,C[i]});
    }
    edges.push_back(pi5{0,0,0,0,0}),edges.push_back(pi5{N-1,N-1,int(vs.size()-1),int(vs.size()-1),0});
    for(int i=0;i<edges.size();i++)ids[i]=i;
    for(int i=0;i<W;i++)rg.push_back({L[i],R[i]});
    sort(edges.begin(),edges.end(),[](const pi5& a,const pi5& b){return a[3]<b[3];});
    sort(ids,ids+edges.size(),[](int a,int b){return edges[a][2]<edges[b][2];});
    sort(rg.begin(),rg.end(),[](pi2 a,pi2 b){return a[1]<b[1];});
    for(int i=0;i<edges.size();i++)ds.col[i+1]=edges[i][1],ds.a[i+1][1]=T[ds.col[i+1]],ds.a[i+1][0]=inf;
    ds.n=edges.size();
    ds.init();

    int p=0;
    set<pi2> toinsert;
    toinsert.insert({0,0});
    ll ans=-1;
    for(int _=0;_<edges.size();_++){
        int i=ids[_];
        while(toinsert.size()&&toinsert.begin()->at(0)<=edges[i][2]){
            ds.pset(1+toinsert.begin()->at(1),dis[toinsert.begin()->at(1)]),toinsert.erase(toinsert.begin());
        }
        while(p<rg.size()&&rg[p][1]<vs[edges[i][2]]){
            int t=lower_bound(vs.begin(),vs.end(),rg[p][0])-vs.begin()-1;
            int pos=upper_bound(edges.begin(),edges.end(),pi5{0,0,0,t,0},[](const pi5&a ,const pi5& b){return a[3]<b[3];})-edges.begin()-1;
            ds.range_add(pos+1);
            p++;
        }
        dis[i]=ds.query(edges[i][0])+edges[i][4];
        if(dis[i]<inf&&edges[i]==pi5{N-1,N-1,int(vs.size()-1),int(vs.size()-1),0})
            ans=dis[i];
        toinsert.insert({edges[i][3],i});
    }
    return ans;
}
```

---

## 作者：tzl_Dedicatus545 (赞：1)

**这一版核心内容是我自己写的/cf/cf/cf**

出题人玩原神呢。因为 $\color{red}\textbf{whk}$ 不能来，但是我是线上 $\color{brown}\textbf{Fe}$。

显然要离散化时间轴。

考虑将吃饭的代价扔到点上考虑，对于一段在 $[L,R]$ 停留在点 $u$ 的时间而言，会产生 $w(L,R)\times \text{cost}(u)$ 的吃饭代价，其中 $w(L,R)$ 表示被 $[L,R]$ 完全包含的吃饭的线段数量。

有一个显然的 dp，$f_{u,i}$ 表示时刻 $i$ 在点 $u$ 的最小花费，显然有效的状态只有 $O(m)$ 个：每个 $u$ 中，只有入边的终止时间，以及出边的起始时间的 $i$ 是有效的。

朴素的时间复杂度做法是，扫描线时间轴，然后计算入边的所有点的状态，转移就是 $f_{v,st(j)}+w(ed(j),i)\times \text{cost}(u)$ 的 $\min$。注意到这个 $st,ed$ 很脑瘫，考虑把状态直接简化成：$f_i$ 表示到达边 $i$ 的终点时的最小花费。

然后你已经知道了 nullptr_qwq 告诉你的状态和转移，但是他的根号分治菜了！只会 $\Theta(n\sqrt{n\log n})$，虽然我们有更优时间复杂度的 $\Theta(n \log^2 n)$ 做法，但作为根号爱好者，我们自然喜欢单根号。怎么办呢？

我们首先分析一下我们要干什么：

- $O(m)$ 次单点加，用于“小点”。
- $O(m\sqrt n)$ 次区间求和，用于“小点”
- $O(m\sqrt{n})$ 次前缀加，用于“大点”
- $O(m)$ 次前缀 $\min$，用于“大点”

随便平衡一下，你就会 $O(m\sqrt{n})$ 了。

代码很短，只有 4.25KB，就不放了喵。

---

## 作者：CarroT1212 (赞：0)

首先你发现最优策略下一餐的费用存在仅当用餐时间区间被你在某个行星的等车时间完全覆盖。所以我们的目标是让等车时间覆盖的用餐区间适当少一点。

因为有个时间，我们考虑进行 DP。设 $dp_{i}$ 为坐完第 $i$ 趟车时的最小花费。如果设 $w[l,r]$ 为 $[l,r]$ 时间内被完全覆盖的用餐区间数量，那么容易写出 DP 式子 $dp_i=\min\limits_{Y_j=X_i,B_j\le A_i}\{dp_j+w[B_j+1,A_i-1]\}$。

如果实际地把这个式子写出来了的话应该可以从里面看出来一些东西。你发现 $w$ 满足四边形不等式！所以对于每个点上的 DP 转移，它是具有决策单调性的。

处理决策单调性 DP 的常用方法是分治和二分队列。这里分治起来限制太复杂了，考虑二分队列。大致就是因为每个位置的最优决策点这时形成一段区间，那么每个决策点能决策到的位置也是一段区间，在 DP 的时候，维护一个单调队列，里面存所有可能的决策点以及它们能作为最优决策点决策到的位置区间。单调队列从队头到队尾决策区间端点单调递增，决策点单调变劣。具体实现可看 [OIwiki](https://oiwiki.com/dp/opt/quadrangle/#%E4%BA%8C%E5%88%86%E9%98%9F%E5%88%97)。

不过这里跟一般的二分队列不太一样，因为图上每个点都有一些转移。那就把所有边按 $A_i$ 排序，然后在计算 $A_i$ 对应的边的起点 $dp_{X_i}$ 值之前，把所有新出现的满足 $B_j<A_i$ 的边在对应的 $Y_i$ 上进行入队。

计算 $w[l,r]$ 可以使用主席树单次 $O(\log n)$ 求解。总复杂度是 $O(n\log^2 n)$，瓶颈在入队那里，如果用精细实现把二分过程拍到主席树上的话应该能砍一个 $\log$。

```cpp
const ll J=1e18,N=1e5+7,K=20;
ll n,m,w,t[N],dp[N];
ll lsh[N*4],hsl,pos[N*4];
pll b[N];
vector<ll> v[N*4],vv[N*4];
struct edg { ll x,y,a,b,c; } a[N];
struct sgt {
	int rt[N],t[N*K],tl[N*K],tr[N*K],cnn;
	void pup(int p) { t[p]=t[tl[p]]+t[tr[p]]; }
	void add(int x,int z,int &p,int q,int l=1,int r=hsl) {
		p=++cnn,t[p]=t[q],tl[p]=tl[q],tr[p]=tr[q];
		if (l==r) return t[p]++,void();
		int mid=l+r>>1;
		if (x<=mid) add(x,z,tl[p],tl[q],l,mid);
		else add(x,z,tr[p],tr[q],mid+1,r);
		pup(p);
	}
	int que(int x,int y,int p,int l=1,int r=hsl) {
		if (!p) return 0;
		if (x<=l&&r<=y) return t[p];
		int mid=l+r>>1,ret=0;
		if (x<=mid) ret=que(x,y,tl[p],l,mid);
		if (y>mid) ret+=que(x,y,tr[p],mid+1,r);
		return ret;
	}
	int euq(int l,int r) { return l>r?0:que(l,r,rt[pos[r]])-que(l,r,rt[pos[l-1]]); }
} T;
ll cal(ll p,ll l,ll x,ll r) { return r<l?J:x+T.euq(l+1,r-1)*t[p]; }
struct nod { ll x,w,l,r; };
struct dyn {
	ll p;
	list<nod> v;
	void push(ll x,ll w) {
		while (v.size()&&cal(p,x,w,v.back().l)<=cal(p,v.back().x,v.back().w,v.back().l))
			v.pop_back();
		if (v.empty()) v.pb({x,w,x+1,hsl});
		else {
			if (cal(p,x,w,v.back().r)>cal(p,v.back().x,v.back().w,v.back().r))
				v.pb({x,w,v.back().r+1,hsl});
			else {
				ll l=v.back().l,r=v.back().r,mid,res=l;
				while (l<=r) {
					mid=l+r>>1;
					if (cal(p,x,w,mid)<=cal(p,v.back().x,v.back().w,mid)) res=mid,r=mid-1;
					else l=mid+1;
				}
				v.back().r=res-1;
				v.pb({x,w,res,hsl});
			}
		}
	}
	ll get(ll x) { return v.size()?cal(p,v.front().x,v.front().w,x):J; }
	void pop(ll x) { while (v.size()&&v.front().r<x) v.pop_front(); }
} D[N];
ll solve(int N,int M,int W,vector<int> TT,
vector<int> X,vector<int> Y,vector<int> A,vector<int> B,vector<int> C,
vector<int> L,vector<int> R) {
	n=N,m=M,w=W;
	for (ll i=1;i<=n;i++) t[i]=TT[i-1];
	lsh[++hsl]=0;
	for (ll i=1;i<=m;i++)
		a[i]={X[i-1]+1,Y[i-1]+1,A[i-1],B[i-1],C[i-1]},
		lsh[++hsl]=a[i].a,lsh[++hsl]=a[i].b;
	a[m+1]={n,n+1,I+1,I+2,0},lsh[++hsl]=I+1,lsh[++hsl]=I+2;
	for (ll i=1;i<=w;i++) b[i]={L[i-1],R[i-1]},lsh[++hsl]=b[i].fi,lsh[++hsl]=b[i].se;
	sort(lsh+1,lsh+hsl+1);
	for (ll i=1;i<=m+1;i++)
		a[i].a=lower_bound(lsh+1,lsh+hsl+1,a[i].a)-lsh,
		a[i].b=lower_bound(lsh+1,lsh+hsl+1,a[i].b)-lsh;
	for (ll i=1;i<=w;i++) 
		b[i].fi=lower_bound(lsh+1,lsh+hsl+1,b[i].fi)-lsh,
		b[i].se=lower_bound(lsh+1,lsh+hsl+1,b[i].se)-lsh,
		v[b[i].fi].pb(b[i].se);
	for (ll i=1,cnt=0;i<=hsl;i++) {
		for (ll j:v[i]) cnt++,T.add(j,1,T.rt[cnt],T.rt[cnt-1]);
		pos[i]=cnt;
	}
	sort(a+1,a+m+1,[](edg x,edg y){return x.a<y.a;});
	memset(dp,20,sizeof(dp));
	for (ll i=1;i<=n;i++) D[i].p=i;
	D[1].push(1,0);
	for (ll i=1;i<=m+1;i++) {
		for (ll j=a[i-1].a+1;j<=a[i].a;j++) for (ll k:vv[j])
			D[a[k].y].push(a[k].b,dp[k]);
		D[a[i].x].pop(a[i].a);
		dp[i]=min(dp[i],D[a[i].x].get(a[i].a)+a[i].c);
		vv[a[i].b].pb(i);
	}
	return dp[m+1]>=J?-1:dp[m+1];
}
```

---

## 作者：Gao_yc (赞：0)

经过省选后两个月没碰 OI，成功在 APIO 场上没看出 T2 决策单调性，爆肝 T3 怒砍 5 分，最终压线 Cu，警钟长鸣！

# Solution：

首先不难想到一种 dp：$f_i$ 表示上一次乘坐的列车是 $i$ 时的最小费用，根据时间排序后对每个星球分别转移。（其实就是在裸的 DAG 上的 dp）

考虑转移方程为：
$$ f_i=f_j+T_x\times s_{B_j+1,A_i-1}+C_i(Y_j=X_i=x)$$

其中 $s_{l,r}$ 表示用餐时间区间在 $[l,r]$ 之间的吃饭数，可以离散化后通过主席树单次 $\mathcal{O}(\log n)$ 查询。

发现这个式子是有决策单调性的，只要对于每个星球 $x$，维护一个队列，并记录队列中每个位置被下一个位置淘汰的时间即可，具体详见代码。
```cpp
#include<bits/stdc++.h>
#define ll long long
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define mid ((l+r)>>1)
#define sz(x) (int)x.size()
using namespace std;
const int N=4e5+10;
const ll inf=0x3f3f3f3f3f3f3f3f;
int n,m,w,pr[N];
ll f[N];
vector<pair<int,int> > G[N];
struct nodee{int x,y,a,b,w;}e[N];
pair<int,int> ml[N];
struct node{
    int x,t;
}p[N];
int id[N];
bool cmp(int A,int B){return p[A].t<p[B].t||(p[A].t==p[B].t&&A>B);}
int nn,nt,tb[N];
vector<int> ps[N];
void findid(int &x){x=lower_bound(tb+1,tb+nt+1,x)-tb;}
int rt[N],cnt,t[N<<5],L[N<<5],R[N<<5];
int update(int pre,int l,int r,int k){
    int x=++cnt;t[x]=t[pre]+1;L[x]=L[pre];R[x]=R[pre];
    if(l==r) return x;
    if(k<=mid) L[x]=update(L[pre],l,mid,k);
    else R[x]=update(R[pre],mid+1,r,k);
    return x;
}
int query(int u,int v,int l,int r,int L,int R){
    if(L>R) return 0;
    if(L<=l&&r<=R) return t[v]-t[u];
    int ans=0;
    if(L<=mid) ans+=query(::L[u],::L[v],l,mid,L,R);
    if(mid<R) ans+=query(::R[u],::R[v],mid+1,r,L,R);
    return ans;
}
int queryk(int u,int v,int l,int r,ll k){
    if(l==r) return l;
    if(t[L[v]]-t[L[u]]>=k) return queryk(L[u],L[v],l,mid,k);
    else return queryk(R[u],R[v],mid+1,r,k-(t[L[v]]-t[L[u]]));
}
int querys(int l,int r,int L,int R){return query(rt[l-1],rt[r],1,nt,L,R);}
int calcti(int i,int j){
    int x=p[i].x;ll k=((f[j]-f[i])/pr[x])+(((f[j]-f[i])%pr[x])?1:0);
    return queryk(rt[p[i].t],rt[p[j].t-1],1,nt,k);
}
deque<pair<int,int> >q[100010];
int ti[N];
ll solve(int N,int M,int W,vector<int> T,vector<int> X,vector<int> Y,vector<int> A,vector<int> B,vector<int> C,vector<int> L,vector<int> R){
    n=N,m=M,w=W;
    rep(i,1,n) pr[i]=T[i-1];
    rep(i,1,m) e[i].x=X[i-1]+1,e[i].y=Y[i-1]+1,e[i].a=A[i-1],e[i].b=B[i-1],e[i].w=C[i-1];
    rep(i,1,w) ml[i]={L[i-1],R[i-1]};
    rep(i,1,m) tb[++nt]=e[i].a,tb[++nt]=e[i].b;
    rep(i,1,w) tb[++nt]=ml[i].first,tb[++nt]=ml[i].second;
    sort(tb+1,tb+nt+1);nt=unique(tb+1,tb+nt+1)-tb-1;
    rep(i,1,m) findid(e[i].a),findid(e[i].b);
    rep(i,1,w) findid(ml[i].first),findid(ml[i].second),ps[ml[i].first].push_back(ml[i].second);
    //上方为对时间进行离散化
    rep(i,1,nt){rt[i]=rt[i-1];for(int x:ps[i]) rt[i]=update(rt[i],1,nt,x);}
    memset(f,0x3f,sizeof(f));
    memset(ti,0x3f,sizeof(ti));
    p[0]={1,0};f[0]=0;q[1].emplace_back(0,N);
    rep(i,1,m) p[i]={e[i].x,e[i].a},p[i+m]={e[i].y,e[i].b};
    iota(id+1,id+2*m+1,1);sort(id+1,id+2*m+1,cmp);
    rep(i,1,m<<1){
        int nw=id[i],x=p[nw].x,t=p[nw].t;
        if(nw<=m){
            if(q[x].empty()) continue;
            while(sz(q[x])>1&&t>=ti[q[x].front().first]) q[x].pop_front();
            int ix=q[x].front().first;
            f[nw+m]=f[ix]+1ll*pr[x]*querys(p[ix].t+1,t-1,p[ix].t+1,t-1)+e[nw].w;
        }
        else{
            if(sz(q[x])>1){
                bool fl=0;
                do{
                    int ix=q[x].back().first,tl=q[x].back().second;
                    if(f[nw]<=f[ix]) q[x].pop_back();
                    else{
                        int nt=calcti(ix,nw);
                        if(nt<=tl) q[x].pop_back();
                        else q[x].emplace_back(nw,ti[ix]=nt),fl=1;
                    }
                }while((!fl)&&(!q[x].empty()));
                if(!fl) q[x].emplace_back(nw,N);
            }
            else if(sz(q[x])==1){
                int ix=q[x].front().first;
                if(f[nw]<=f[ix]) q[x].pop_front(),q[x].emplace_back(nw,N);
                else q[x].emplace_back(nw,ti[ix]=calcti(ix,nw));
            }
            else q[x].emplace_back(nw,N);
        }
    }
    if(q[n].empty()) return -1;
    ll ans=inf;
    for(auto it:q[n]){int x=it.first;ans=min(ans,f[x]+1ll*pr[n]*querys(p[x].t+1,nt,p[x].t+1,nt));}
    return ans>=inf?-1:ans;
}
```

---

## 作者：_Ch1F4N_ (赞：0)

这咋成了我第一个写的二分队列处理决策单调性 dp，不知道 APIO2024 之前学一下这个最后结果会不会不一样。

首先观察到 $A_i < B_i$ 代表转移无环，最短路是假的，直接按照时间顺序 dp 即可。

然后因为转移的限制大多数在边上，我们直接对着边 dp，也就是设计状态 $dp_i$ 表示抵达点 $Y_i$ 且处理了可以在时间 $[1,B_i]$ 内的所有吃饭的最小代价。

观察一下吃饭会造成代价当且仅当从边 $i$ 转移到边 $j$ 时，吃饭区间被 $(B_i,A_j)$ 完全包含。

不妨 $cost(l,r)$ 表示被区间 $(l,r)$ 包含的吃饭区间的数量，可以写出转移 $dp_i = \min_{B_j \leq A_i,Y_j = X_i}(dp_j + T_{X_i} \times cost(B_j,A_i)) + C_i$。

然后再观察一下，转移中特殊的项是 $dp_j + T_{x_i} \times cost(B_j,A_i)$，由于转移到不同点的代价只取决于 $A_i$，所以不妨 $f_{i} = \min(dp_j + T \times cost(B_j,i))$，由于 $cost(l,r)$ 可以看作是一个区间内所有子区间的贡献，所以其满足四边形不等式，也就是 $f_i$ 满足决策单调性。

不妨 $p_i$ 表示 $f_i$ 的最优决策点，从前往后考虑每个前缀，每个前缀均有决策单调性，所以从前往后考虑每个前缀时固定下标 $i$ 满足 $p_i$ 递增，考虑同一个前缀时 $p_i$ 关于下标 $i$ 也是递增，所以一个点会贡献到的点是一个区间并且每个决策都只会被后面的决策反超，考虑对于每个点用一个队列维护决策，每个决策在队列中形如一个三元组 $(i,l,r)$ 表示这个决策为 $i$，其贡献到的区间是 $[l,r]$。

新加入一个决策时从队列末尾向前考虑，假若末尾决策完全比新决策劣（对于任意 $l \leq j \leq i$ 用新决策转移都更优）就直接弹出，完全比新决策优就将新决策放到末尾，否则由于每个点贡献到的点是一段区间，我们可以将末尾决策的区间分裂开来，找这个分裂的分界点的过程可以使用二分。

转移到一个状态时直接将队首所有过时也就是满足 $r<A_i$ 的决策丢掉，再取队首转移即可。

快速求解 $cost(l,r)$ 考虑使用主席树即可做到 $O(n \log^2 n)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 5e5+114;
int tr[maxn*33],ls[maxn*33],rs[maxn*33];
int root[maxn],cnt,b[maxn],tot;
vector<int> P[maxn];
void ins(int lst,int &cur,int lt,int rt,int pos){
	cur=++cnt;
	tr[cur]=tr[lst]+1;
	int mid=(lt+rt)>>1;
	if(lt==rt) return ;
	if(pos<=mid){
		rs[cur]=rs[lst],ins(ls[lst],ls[cur],lt,mid,pos);
	}else{
		ls[cur]=ls[lst],ins(rs[lst],rs[cur],mid+1,rt,pos);
	}
}
int ask(int cur,int lt,int rt,int l,int r){
	if(rt<l||r<lt||cur==0) return 0;
	if(l<=lt&&rt<=r) return tr[cur];
	int mid=(lt+rt)>>1;
	return ask(ls[cur],lt,mid,l,r)+ask(rs[cur],mid+1,rt,l,r);
}
int query(int L,int R){
	L++,R--;
	if(L>R) return 0;
	return ask(root[R],1,tot,L,R)-ask(root[L-1],1,tot,L,R);
}
vector< pair<int,pair<int,int> > > V[maxn];
int head[maxn];
long long dp[maxn];
vector<int> work[maxn],trans[maxn];
long long solve(int n, int m, int w, std::vector<int> T,std::vector<int> X, std::vector<int> Y,std::vector<int> A, std::vector<int> B, std::vector<int> C,std::vector<int> L, std::vector<int> R){
	for(int x:A) b[++tot]=x;
	for(int x:B) b[++tot]=x;
	for(int x:L) b[++tot]=x;
	for(int x:R) b[++tot]=x;
	sort(b+1,b+tot+1);
	for(int i=0;i<m;i++){
		int l=1,r=tot+1;
		while(l+1<r){
			int mid=(l+r)>>1;
			if(A[i]>=b[mid]) l=mid;
			else r=mid;
		}
		A[i]=l;
	}
	for(int i=0;i<m;i++){
		int l=1,r=tot+1;
		while(l+1<r){
			int mid=(l+r)>>1;
			if(B[i]>=b[mid]) l=mid;
			else r=mid;
		}
		B[i]=l;
	}
	for(int i=0;i<w;i++){
		int l=1,r=tot+1;
		while(l+1<r){
			int mid=(l+r)>>1;
			if(L[i]>=b[mid]) l=mid;
			else r=mid;
		}
		L[i]=l;
	}
	for(int i=0;i<w;i++){
		int l=1,r=tot+1;
		while(l+1<r){
			int mid=(l+r)>>1;
			if(R[i]>=b[mid]) l=mid;
			else r=mid;
		}
		R[i]=l;
	}
	for(int i=0;i<w;i++){
		P[R[i]].push_back(L[i]);
	}
	for(int i=1;i<=tot;i++){
		int lst=root[i-1];
		for(int x:P[i]){
			int New=0;
			ins(lst,New,1,tot,x);
			lst=New;
		}
		root[i]=lst;
	}
 	for(int i=0;i<m;i++) dp[i]=1e18;
	for(int i=0;i<m;i++){
		work[A[i]].push_back(i);
	}
	for(int i=1;i<=tot;i++){
		for(int id:trans[i]){
            int u=Y[id];
            while(head[u]<V[u].size()&&V[u][head[u]].second.second<i){
                head[u]++;
            }
            if(head[u]<V[u].size()) V[u][head[u]].second.first=max(V[u][head[u]].second.first,i);
			while(head[u]<V[u].size()){
				int ch=V[Y[id]].back().first,l=V[u].back().second.first,r=V[u].back().second.second;
				if(dp[id]+1ll*T[u]*query(B[id],r)>dp[ch]+1ll*T[u]*query(B[ch],r)){
					break;
				}
				else if(dp[id]+1ll*T[u]*query(B[id],l)<=dp[ch]+1ll*T[u]*query(B[ch],l)){
					V[u].pop_back();
				}else{
					int lt=l,rt=r;
					while(lt+1<rt){
						//找出最靠前 id 决策更优的点
						int mid=(lt+rt)>>1;
						if(dp[id]+1ll*T[u]*query(B[id],mid)<=dp[ch]+1ll*T[u]*query(B[ch],mid)) rt=mid;
						else lt=mid;
					}
					V[u][V[u].size()-1].second.second=rt-1;
					break;
				}
			}
            if(head[u]>=V[u].size()){
                V[u].push_back(make_pair(id,make_pair(i,tot)));
            }else if(V[u].back().second.second+1<=tot) V[u].push_back(make_pair(id,make_pair(V[u].back().second.second+1,tot)));
		}
		for(int id:work[i]){
		    int u=X[id];
			while(head[u]<V[u].size()&&V[u][head[u]].second.second<i) head[u]++;
			if(head[u]<V[u].size()) V[u][head[u]].second.first=max(V[u][head[u]].second.first,i);
			if(head[u]<V[u].size()){
				int ch=V[u][head[u]].first;
				dp[id]=min(dp[id],dp[ch]+1ll*T[u]*query(B[ch],A[id])+C[id]);
			}
            if(X[id]==0) dp[id]=min(dp[id],1ll*C[id]+1ll*query(0,A[id])*T[0]);
            trans[B[id]].push_back(id);
		}
	}
	long long ans=1e18;
	for(int i=0;i<m;i++){
		if(Y[i]==n-1) ans=min(ans,dp[i]+1ll*query(B[i],tot+1)*T[n-1]);
	}
	return (ans<1e18?ans:-1);
}
```

---

## 作者：Jsxts_ (赞：0)

考虑把边变成点，点变成边，那么会连出一个 DAG。此时 DAG 的转移也可以看成：在时间轴上依次考虑每条边（或是 DAG 上的点），碰到左端点就计算这条边的 dp 值，碰到右端点就将这条边标记为可转移的。这样边数是 $m^2$ 的，而边权为二维数点，由于按时间转移则相当于离线了，可以看成单点加、区间查询，用分块可平衡。

发现边数多的就是原图中一个点的度数很大。考虑对度数根号分治。若一个 DAG 上的点入度 $<B$ 就按上述方法直接转移，那么对于一个入度 $>B$ 的点，考虑将其所有的入边放进一个线段树里，那么求值可以在线段树里查，共开 $n/B$ 颗线段树。

那么总复杂度为 $O(nB+\frac n B \times n\log n)$，由于线段树的空间问题要将 $B$ 开到 $2200$，可过。

```cpp
#include <bits/stdc++.h>
#define x first
#define y second
using namespace std;
typedef long long ll;
const int N = 1e5;
const int inf = 1e9;
const ll INF = 1e15;
int read() {
	int s = 0,f = 1;char ch = getchar();
	while (!isdigit(ch)) f = ch == '-'? -1 : 1, ch = getchar();
	while(isdigit(ch)) s = s * 10 + ch - '0', ch = getchar();
	return s * f;
}
const int mod = 998244353;
int qpow(int a,int b) {
	int res = 1;
	while (b) {
		if (b & 1) res = 1ll * res * a % mod;
		b >>= 1, a = 1ll * a * a % mod;
	}
	return res;
}
int getmod(int x) {
	return x - (x >= mod) * mod;
}
int n,m,w;
ll val[N + 10];
const int bl = 2200;
int b2;
struct node {
	int v,w,l,r,i;
};
vector<node> vc1[N + 10],vc2[N + 10];
void add1(int u,int v,int w,int l,int r,int i) {
	vc1[u].push_back({v,w,l,r,i});
}
void add2(int u,int v,int w,int l,int r,int i) {
	vc2[u].push_back({v,w,l,r,i});
}
int tot,h[N * 4 + 10];
struct block {//支持单点加，前缀查询 
	int st[N * 4 + 10],ed[N * 4 + 10],bl[N * 4 + 10];
	void build() {
		int ct = 0;
		for (int i = 1;i <= tot;i += b2) {
			st[++ct] = i, ed[ct] = min(tot,i + b2 - 1);
			for (int j = st[ct];j <= ed[ct];j ++ ) bl[j] = ct;
		}
	}
	int s1[N * 4 + 10],s2[N * 4 + 10];
	inline void modify(int x,int s) {
		for (int i = bl[x];i <= bl[tot];i ++ ) s1[i] += s;
		for (int i = x;i <= ed[bl[x]];i ++ ) s2[i] += s;
	}
	inline int query(int x) {
		return !x ? 0 : s1[bl[x] - 1] + s2[x];
	}
}t;
ll ww[N + 10];
int du[N + 10],to2[N + 10],tt,to1[N + 10];
struct Seg2 {
	struct node {
		ll v,tag;
	}t[N * 16 + 10];
	inline void pushup(int x) {
		t[x].v = min(t[x<<1].v,t[x<<1|1].v);
	}
	inline void f(int x,ll s) {
		t[x].v += s, t[x].tag += s;
	}
	inline void pushdown(int x) {
		f(x<<1,t[x].tag), f(x<<1|1,t[x].tag);
		t[x].tag = 0;
	}
	void modify1(int x,int k,int L,int R,ll s) {
		if (L == R) {
			t[x].v = min(t[x].v,s);
			return ;
		}
		int mid = L + R >> 1;
		if (t[x].tag) pushdown(x);
		if (mid >= k) modify1(x<<1,k,L,mid,s);
		else modify1(x<<1|1,k,mid + 1,R,s);
		pushup(x);
	}
	void modify(int x,int l,int r,int L,int R,ll s) {
		if (l > r) return;
		if (L >= l && r >= R) {
			f(x,s);
			return;
		}
		int mid = L + R >> 1;
		if (t[x].tag) pushdown(x);
		if (mid >= l) modify(x<<1,l,r,L,mid,s);
		if (mid < r) modify(x<<1|1,l,r,mid + 1,R,s);
		pushup(x);
	}
	ll query(int x,int l,int r,int L,int R) {
		if (l > r) return INF;
		if (L >= l && r >= R) return t[x].v;
		int mid = L + R >> 1;
		pushdown(x);
		ll res = INF;
		if (mid >= l) res = query(x<<1,l,r,L,mid);
		if (mid < r) res = min(res,query(x<<1|1,l,r,mid + 1,R));
		return res;
	}
};
vector<Seg2> t2;
vector<int> res;
int id[N + 10],tl[N + 10],tr[N + 10],bh[N + 10],lst[N + 10];
vector<int> vc[N * 4 + 10];
ll dis[N + 10];
vector<int> vc3[N * 4 + 10];
vector<int> vc4[N * 4 + 10];
struct edge {
	int v,w,nxt;
}ed[40000000];
int head[N + 10],cnt;
inline void add(int u,int v,int w) {
	ed[++cnt] = {v,w,head[u]};
	head[u] = cnt;
}
vector<pair<int,int> > vc5[N * 4 + 10];
long long solve(int N,int M,int W,vector<int> T,vector<int> X,vector<int> Y,vector<int> A,vector<int> B,vector<int> C,vector<int> L,vector<int> R) {
	n = N, m = M, w = W;
	tot = 0;
	for (int i = 0;i < n;i ++ ) val[i + 1] = T[i];
	for (int i = 0;i < w;i ++ ) h[++tot] = L[i], h[++tot] = R[i];
	for (int i = 0;i < m;i ++ ) h[++tot] = A[i], h[++tot] = B[i];
	sort(h + 1,h + tot + 1), tot = unique(h + 1,h + tot + 1) - h - 1;
	for (int i = 0;i < w;i ++ ) {
		L[i] = lower_bound(h + 1,h + tot + 1,L[i]) - h;
		R[i] = lower_bound(h + 1,h + tot + 1,R[i]) - h;
		vc[R[i]].push_back(L[i]);
	}
	b2 = sqrt(tot);
	for (int i = 1;i <= m;i ++ ) {
		int u = X[i - 1] + 1,v = Y[i - 1] + 1,c = C[i - 1],l = A[i - 1],r = B[i - 1];
		l = lower_bound(h + 1,h + tot + 1,l) - h;
		r = lower_bound(h + 1,h + tot + 1,r) - h;
		tl[i] = l, tr[i] = r;
		add1(u,v,c,l,r,i);
		add2(v,u,c,l,r,i);
		ww[i] = c;
		vc3[l].push_back(i);
		vc4[r].push_back(i);
	}
	int qt = 0;
	//vc1:i 的出边 vc2: 入边 
	for (int i = 1;i <= n;i ++ ) {
		for (auto v : vc2[i]) to1[v.i] = i;
		for (auto v : vc1[i]) to2[v.i] = i;
		if (vc2[i].size() > bl) {
			bh[i] = ++tt;
			continue;
		}
	}
	t.build();
	t2.resize(tt + 1);
	for (int i = 1;i <= tt;i ++ )
		t2[i].modify(1,1,tot,1,tot,INF);
	for (int i = 1;i <= m;i ++ ) id[i] = i;
	sort(id + 1,id + m + 1,[](int x,int y){return tl[x] == tl[y] ? tr[x] < tr[y] : tl[x] < tl[y];});
	int ct = 0;
	for (int i = 1;i <= m;i ++ ) dis[i] = INF;
	for (int i = 1;i <= tot;i ++ ) {
		for (auto u : vc4[i]) {
			if (bh[to1[u]]) {
				t2[bh[to1[u]]].modify1(1,tr[u],1,tot,dis[u]);
			}
		}
		for (auto u : vc3[i]) {
			if (bh[to2[u]]) {
				int x = bh[to2[u]];
				for (;lst[x] < i;lst[x] ++ )
					for (auto v : vc[lst[x]]) t2[x].modify(1,1,v - 1,1,tot,val[to2[u]]);
				dis[u] = min(dis[u],ww[u] + t2[x].t[1].v);
			}
			else {
				if (to2[u] == 1) {
					dis[u] = ww[u] + 1ll * val[1] * ct;
					continue;
				}
				for (auto v : vc2[to2[u]]) if (v.r <= i) dis[u] = min(dis[u],dis[v.i] + ww[u] + 1ll * val[to2[u]] * (ct - t.query(v.r)));
			}
		}
		for (auto v : vc[i]) t.modify(v,1), ct ++;
	}
	ll res = INF;
	for (auto v : vc2[n]) {
		res = min(res,dis[v.i] + 1ll * val[n] * (w - t.query(v.r)));
	}
	return res == INF ? -1 : res;
}
int main() {
	int n = read(),m = read(),w = read();
	vector<int> T;
	vector<int> X;
	vector<int> Y;
	vector<int> A;
	vector<int> B;
	vector<int> C;
	vector<int> L;
	vector<int> R;
	for (int i = 1;i <= n;i ++ ) T.push_back(read());
	for (int i = 1;i <= m;i ++ ) X.push_back(read()), Y.push_back(read()), A.push_back(read()), B.push_back(read()), C.push_back(read());
	for (int i = 1;i <= w;i ++ ) L.push_back(read()), R.push_back(read());
	cout << solve(n,m,w,T,X,Y,A,B,C,L,R);
	return 0;
}
```


用了大约 $4$ 倍的限制提交次数和若干倍限定时间。

---


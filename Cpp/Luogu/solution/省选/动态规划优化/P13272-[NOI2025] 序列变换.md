# [NOI2025] 序列变换

## 题目描述

给定两个长度为 $n$ 的整数序列 $B = [b_1, \ldots, b_n]$，$C = [c_1, \ldots, c_n]$。对于长度为 $n$ 的非负整数序列 $D = [d_1, \ldots, d_n]$，设 $S(D)$ 为所有满足 $d_i = 0$ 的下标 $i$ 的集合，定义 $f(D) = \sum_{i \in S(D)} b_i$，$g(D) = \prod_{i \in S(D)} c_i$。特别地，若 $S(D)$ 为空，则 $f(D) = 0$，$g(D) = 1$。

小 L 有一个长度为 $n$ 的 **正整数序列** $A = [a_1, \ldots, a_n]$。小 L 可以对序列 $A$ 做如下修改：

- 选择序列 $A$ 的两个 **相邻** 的下标 $i, j$（即 $1 \leq i, j \leq n$ 且 $|i - j| = 1$），若 $a_i \leq a_j$，则将 $a_j$ 改为 $a_j - a_i$，同时将 $a_i$ 改为 $0$。

小 L 可以进行任意多次修改操作，也可以不进行任何修改。对于所有序列 $A$ 通过以上修改操作可以得到的序列 $D$，小 L 想求出 $f(D)$ 的最大值以及 $g(D)$ 之和，请你帮助他求出这两个值。形式化地，记 $T(A)$ 为序列 $A$ 通过以上修改操作可以得到的 **所有序列的集合**，你需要求出 $\max_{D \in T(A)} f(D)$ 以及 $\sum_{D \in T(A)} g(D)$。其中，由于 $\sum_{D \in T(A)} g(D)$ 可能较大，你只需要求出其对 $1,000,000,007$ 取模后的结果。

## 说明/提示

### 样例 1 解释

该样例共包含三组测试数据。

对于第一组测试数据，可以得到以下 4 个序列：

- $D = [5, 6, 6]$，$f(D) = 0$，$g(D) = 1$；
- $D = [0, 1, 6]$，$f(D) = 3$，$g(D) = 1$；
- $D = [5, 0, 0]$，$f(D) = 6 + 9 = 15$，$g(D) = 2 \times 3 = 6$；
- $D = [0, 0, 5]$，$f(D) = 3 + 6 = 9$，$g(D) = 1 \times 2 = 2$。

故 $\max_{D \in T(A)} f(D) = \max\{0, 3, 15, 9\} = 15$，$\sum_{D \in T(A)} g(D) = 1 + 1 + 6 + 2 = 10$。

### 样例 2

见选手目录下的 `sequence/sequence2.in` 与 `sequence/sequence2.ans`。

该样例满足测试点 3、4 的约束条件。

### 样例 3

见选手目录下的 `sequence/sequence3.in` 与 `sequence/sequence3.ans`。

该样例满足测试点 5、6 的约束条件。

### 样例 4

见选手目录下的 `sequence/sequence4.in` 与 `sequence/sequence4.ans`。

该样例满足测试点 7 的约束条件。

### 样例 5

见选手目录下的 `sequence/sequence5.in` 与 `sequence/sequence5.ans`。

该样例满足测试点 11、12 的约束条件。

### 样例 6

见选手目录下的 `sequence/sequence6.in` 与 `sequence/sequence6.ans`。

该样例满足测试点 $16\sim 18$ 的约束条件。

设 $N$ 为单个测试点内所有测试数据的 $n$ 的和。对于所有测试数据，保证：

- $1 \leq t \leq 20$；
- $1 \leq n \leq 5,000$，$N \leq 4 \times 10^4$；
- 对于所有 $1 \leq i \leq n$，均有 $1 \leq A_i \leq 10^9$；
- 对于所有 $1 \leq i \leq n$，均有 $-10^9 \leq B_i \leq 10^9$；
- 对于所有 $1 \leq i \leq n$，均有 $1 \leq C_i \leq 10^9$。

::cute-table{tuack}

| 测试点编号 | $n \leq$ | $N \leq$ | 特殊性质 |
| :-: | :-: | :-: | :-: |
| $1, 2$ | $8$ | $10^2$ | 无 |
| $3, 4$ | $200$ | $400$ | B |
| $5, 6$ | ^ | ^ | 无 |
| $7$ | $500$ | $10^3$ | A |
| $8 \sim 10$ | ^ | ^ | B |
| $11, 12$ | ^ | ^ | 无 |
| $13$ | $3\,500$ | $3 \times 10^4$ | A |
| $14, 15$ | ^ | ^ | B |
| $16 \sim 18$ | ^ | ^ | 无 |
| $19, 20$ | $5\,000$ | $4 \times 10^4$ | ^ |

- **特殊性质 A**：保证 $A_1 = A_2 = \cdots = A_n = 1$。
- **特殊性质 B**：保证对于所有 $1 \leq i \leq n$，$A_i$ 均在 $[1, 10^9]$ 中 **独立均匀随机** 生成。

### 评分方式

对于每个测试点：

- 正确回答所有测试数据的 $\max_{D \in T(A)} f(D)$，可获得该测试点 $40\%$ 的分数；
- 正确回答所有测试数据的 $\sum_{D \in T(A)} g(D)$ 对 $1,000,000,007$ 取模后的结果，可获得该测试点 $60\%$ 的分数。

**注意：即使选手仅回答了其中一个问题，也需要按照输出格式输出两个整数，分别对应两个问题的答案。**

附加文件来自于 [QOJ](https://qoj.ac/contest/2315/problem/13080)。

## 样例 #1

### 输入

```
0 3
3
5 6 6
3 6 9
1 2 3
6
1 1 4 5 1 4
-1 1 -1 1 -2 2
1 1 1 1 1 1
8
4 2 4 2 2 2 4 4
-2 4 9 -3 4 8 7 8
1 1 1 1 1 1 1 1```

### 输出

```
15 10
1 18
37 48```

# 题解

## 作者：zac2010 (赞：14)

## 题目大意

给两个长为 $n$ 的正整数序列 $a,c$，以及一个长为 $n$ 的整数序列 $b$。

定义 $f(a)=\sum_{a_i=0}b_i$，$g(a)=\prod_{a_i=0}c_i$。

你可以对 $a$ 执行任意次以下操作：
* 选择两个**相邻**的位置 $i,j$，若 $a_i \leq a_j$，则将 $a_j$ 改为 $a_j - a_i$，同时将 $a_i$ 改为 $0$。

对于所有可能经过 $0$ 次或更多次操作得到的 $a$，求出 $\max f(a)$ 与 $\sum g(a)\mod 10^9+7$。

## 解题思路

### 一些定义与发现

特别的，假若上述对 $a$ 的操作满足 $i<j$，我们称为**往右操作**；反之 $i>j$，我们称为**往左操作**。同时，定义 $a_i>a_j$ 的情况为**无法操作**。

> 经过一次操作后，$a_i$ 与 $a_{j}$ 中小的那个会变成 $0$。同时，对任意一组 $\min(a_i,a_{j})=0$ 操作是无效的。所以，**操作一次后两边独立**。

> 我们更进一步地发现，最终序列每一个非 $0$ 位置都对应了**初始 $a$ 的一个区间**。这个区间的操作形式为：从两边不断往内操作。

### 第一问

先做第一问。记 $f_i$ 表示，考虑了前 $i$ 个数的最大权值是多少。每次枚举一个 $j$ 转移过去。转移的时候还要枚举一个 $k$ 表示最终缩在哪个数上了（记得特判最最终整个区间都是 $0$ 的情况），

具体的，我们暴力 check 最终位置 $k$ 的合法性容易做到暴力 $O(n)$。
优化的话考虑预处理出 $pl_i,pr_i$ 表示，每个位置作为左/右端点往另一端操作最远能到哪里。此时判断条件就容易写成 $\max(pr_{j},i+1)\leq k\leq\min(pl_{i+1},j)$，时间复杂度 $O(n^3)$。

事实上，我们不需要枚举 $k$，只需要知道最优的 $k$ 对应的贡献即可。
由于我们发现每个 $a_i$ 对最终的 $a_k$ 的贡献只取决于 **$i$ 的奇偶性**，故而可以分类讨论。

记 $s0$ 表示 $[l,r]$ 内所有偶数位置的 $\sum a_i$，记 $s1$ 表示所有奇数为的 $\sum a_i$：
*  $s0=s1$，区间最后会变为全 $0$。
*  $s0>s1$，$k$ 是上述合法区间 $[\max(pr_{j},i+1),\min(pl_{i+1},j)]$ 内的任意偶数位置
*  $s0<s1$，$k$ 是上述合法区间 $[\max(pr_{j},i+1),\min(pl_{i+1},j)]$ 内的任意奇数位置。

预处理每个区间内的奇/偶位置最值，可以 $O(1)$ 完成上面的转移。至此，我们 $O(n^2)$ 完成了第一问。

### 第二问

第二问同理。特别的，为了防止出现两段被拼起来重复计数（其中有一段得是最终全 $0$），我们将对 $pl,pr$ 的定义进行一点修改：
* $pl_i$：从 $i$ 往右操作，第一次满足“操作后 $a_j=0$”的位置前停下。
* $pr_i$：从 $i$ 往左操作，第一次操作后 $a_j=0$ 停下。

这样可以不重不漏计数。最终这题总时间复杂度 $O(n^2)$，空间复杂度 $O(n^2)$。如果使用 ST 表维护区间最值，空间上可以做到 $O(n\log n)$。

## 代码实现


```cpp
#include <bits/stdc++.h>
#define FL(i, a, b) for (int i = (a); i <= (b); ++i)
#define FR(i, a, b) for (int i = (a); i >= (b); --i)
using namespace std;
typedef long long ll;
const int N = 5e3 + 10;
const int MOD = 1e9 + 7;
const ll INFLL = 1e18;
int n, a[N], b[N], c[N], ic[N];
int pl[N], pr[N], v[N], iv[N];
ll mi[2][N][N], ct[2][N][N];
ll s[N], t[N], f[N], g[N];
int Qpow(int a, int b) {
	int ret = 1;
	for (; b; b >>= 1) {
		if (b & 1)
			ret = (ll)ret * a % MOD;
		a = (ll)a * a % MOD;
	}
	return ret;
}
int Inv(int x) {
	return Qpow(x, MOD - 2);  
}
void Solve() {
	scanf("%d", &n);
	FL(i, 1, n) {
		scanf("%d", &a[i]);
		t[i] = t[i - 1] + (i & 1? -a[i] : a[i]);
	}
	FL(i, 1, n) {
		scanf("%d", &b[i]);
		s[i] = s[i - 1] + b[i];
	}
	v[0] = iv[0] = 1;
	FL(i, 1, n) {
		scanf("%d", &c[i]);
		v[i] = (ll)v[i - 1] * c[i] % MOD;
		ic[i] = Inv(c[i]);
		iv[i] = Inv(v[i]);
	}
	FL(i, 1, n) {
		mi[0][i][i - 1] = mi[1][i][i - 1] = INFLL;
		ct[0][i][i - 1] = ct[1][i][i - 1] = 0;
		FL(j, i, n) {
			FL(k, 0, 1) {
				mi[k][i][j] = mi[k][i][j - 1];
				ct[k][i][j] = ct[k][i][j - 1];
			}
			mi[j & 1][i][j] = min(mi[j & 1][i][j], (ll)b[j]);
			ct[j & 1][i][j] = (ct[j & 1][i][j] + ic[j]) % MOD;
		}
	}
	FL(i, 1, n) {
		int d = a[i];
		FL(j, i, n) {
			d = a[j + 1] - d;
			if (j == n || d <= 0) {
				pl[i] = j;
				break;
			}
		}
		d = a[i];
		FR(j, i, 1) {
			d = a[j - 1] - d;
			if (j == 1 || d <= 0) {
				pr[i] = (j > 1 && !d? j - 1 : j);
				break;
			}
		}
	}
	fill(f, f + n + 1, -INFLL);
	fill(g, g + n + 1, 0);
	f[0] = 0, g[0] = 1;
	FL(i, 0, n) {
		FL(j, i + 1, n) {
			int l = max(i + 1, pr[j]), r = min(j, pl[i + 1]);
			if (l > r){
				continue;
			}

			int h = (ll)g[i] * v[j] % MOD * iv[i] % MOD;
			if (t[j] - t[i] == 0) {
				f[j] = max(f[j], f[i] + (s[j] - s[i]));
				g[j] = (g[j] + h) % MOD;
			} else if (t[j] - t[i] > 0) {
				f[j] = max(f[j], f[i] + (s[j] - s[i]) - mi[0][l][r]);
				g[j] = (g[j] + (ll)h * ct[0][l][r]) % MOD;
			} else {
				f[j] = max(f[j], f[i] + (s[j] - s[i]) - mi[1][l][r]);
				g[j] = (g[j] + (ll)h * ct[1][l][r]) % MOD;
			}
		}
	}
	printf("%lld %lld\n", f[n], g[n]);
}
int main() {
	int T;
	scanf("%*d %d", &T);
	while (T--) {
		Solve();
	}
	return 0;
}
```

---

## 作者：wangziyue_AK (赞：9)

考虑找一个刻画操作的形式（建议在纸上画一画），每次操作会把相邻的两个中的一个变成 $0$，此时另一个只能往另一个方向继续操作，此时我们称在序列上出现了一个由小的数指向大的数的箭头。显然，此时不会出现一个数同时成为两个箭尾，因为箭尾会变成 $0$。但会有大量数先和前一个数操作，然后再和后一个数操作，然后变成 $0$，此时我们发现在序列上出现了两个连续的相同方向箭头。我们直接把连续的相邻箭头合并，后文的箭头都指合并后的箭头。

为了后文叙述没有歧义，我们先来严格定义一下箭头，右箭头为依次从左到右操作，且每次操作时左边的数小于等于右边的数（注意不是原数小于），被操作成 $0$。然后箭尖此时可能还存在非 $0$ 数。左箭头同理。

然后此时预处理每个区间能否作为左箭头，作为左箭头时的权值，作为左箭头后箭尖会减去的数，右箭头同理。转移看起来直接枚举新加一个左箭头或右箭头或空一格即可。

但是有一个问题，对于中间的数很大时，它可能成为两个箭头的箭尖。那么此时的条件就是两个箭尖减去的数之和小于等于这个数，对于这个形如 $\max_{d_x+d_y\le a_i}w_x+w_y$ 的问题，常做数据结构的人第一反应一定是枚举 $x$ 后树状数组查 $y$。然后细想一下发现树状数组还要先离散化，非常不优，不如直接排序后做双指针。

所以我们对于这类转移直接对于每个点找出以它为箭尖的左箭头和右箭头，排序后做双指针即可完成这类转移。复杂度 $O(n^2\log{n})$，只有排序，常数很小。

对于第二种询问，发现如果对于一个已经变成 $0$ 的数继续操作等于没操作，此时我们会计数两遍，所以把箭头的定义加一条中途没有一次操作把箭身两个数同时转为 $0$，因为这样下一个数和下下个数的操作就等于没有操作。此时我们发现对于 $x$ $x$ 这种两个相邻的数相同的会出现两次，所以我们认定只有右箭头箭尖可以为 $0$，并且两个箭尖重合的判定条件要去掉等号（因为此时可以把左箭头最后一步改为右箭头延长一）。

常数较小的写法是把合法箭头预处理后存下来，转移时重新找常数巨大无法通过。第一种写法实测最大点 $1.6$ 秒。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<int,ll> pil;
#define fi first
#define se second
typedef double db;
#define pb push_back
#define eb emplace_back
#define bcnt __builtin_popcount
#define TS printf("!!!tiaoshi\n")
const int INF=1e9+7;
const ll inf=1e15+7;
const int N=5005;
const int mod=1e9+7;
struct mint{
	//......
};
#define cmx(A,B) A=max(A,B) 
int n,m,tid,a[N],b[N],c[N];
struct node{
	int fr,k;ll w;mint w2;
	inline bool operator <(const node &b) const{
		return k<b.k;
	}
};
vector<node> f[N];
vector<node> g[N];
//f表示右箭头，g表示左箭头 
ll dp[N];
mint dp2[N];
void sol(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++) scanf("%d",&b[i]);
	for(int i=1;i<=n;i++) scanf("%d",&c[i]);
	for(int i=1;i<=n;i++) f[i].clear(),g[i].clear();
	for(int i=1;i<=n+1;i++) dp[i]=-inf,dp2[i]=0;
	dp[0]=0,dp2[0]=1;
	for(int i=1;i<=n;i++){
		int k=a[i];ll w=0;mint w2=1;
		for(int j=i+1;j<=n;j++){
			if(k>a[j]) break;
			w+=b[j-1],w2*=c[j-1],f[j].pb({i,k,w,w2}),k=a[j]-k;
			if(k==0) break;
		}
	}
	for(int i=2;i<=n;i++){
		int k=a[i];ll w=0;mint w2=1;
		for(int j=i-1;j;j--){
			if(k>=a[j]) break;
			w+=b[j+1],w2*=c[j+1],g[j].pb({i,k,w,w2}),k=a[j]-k;
		}
	}
	for(int i=1;i<=n;i++){
		cmx(dp[i],dp[i-1]),dp2[i]+=dp2[i-1];
		sort(f[i].begin(),f[i].end()),sort(g[i].begin(),g[i].end());
		reverse(g[i].begin(),g[i].end());
		int j=0,sz=f[i].size();
		ll mx=-inf;mint sum=0;
		for(node v:g[i]){
			while(j<sz&&v.k+f[i][j].k<a[i]){
				node u=f[i][j];j++;
				mx=max(mx,dp[u.fr-1]+u.w),sum+=dp2[u.fr-1]*u.w2;
			}
			cmx(dp[v.fr],mx+v.w);
			dp2[v.fr]+=sum*v.w2;
		}
		for(node it:f[i]){
			cmx(dp[i],dp[it.fr-1]+it.w+(it.k==a[i]?b[i]:0));
			dp2[i]+=dp2[it.fr-1]*it.w2*(it.k==a[i]?c[i]:1);
		}
		for(node it:g[i]){
			cmx(dp[it.fr],dp[i-1]+it.w);
			dp2[it.fr]+=dp2[i-1]*it.w2;
		}
	}
	printf("%lld %d\n",dp[n],dp2[n].x);
}
int main(){
	int T=1;
	scanf("%d%d",&tid,&T);
	while(T--) sol();

	return 0;
}
```

---

## 作者：yyyx_ (赞：9)

- 2025.7.19 upd：增加了 $O(n^2\log n) \to O(n^2)$ 的优化方法。

玩一下这个样例，感觉这个“修改操作”结束后，序列可以被刻画为三种情况：

1. `0 0...0 0 x`，即一段始终满足 $h_{i-1}\le a_i$ 的序列，其中 $h_p$ 表示 $a_p$ 操作后的值；
2. `x 0 0...0 0`，即一段始终满足 $h_{i+1}<a_i$ 的序列；
3. 一段无操作的序列。

---

### 求 $\max F(D)$。

第三种情况没有贡献，dp 转移的时候注意一下就行了。

对于前两种情况，我们可以对于每个点 $i$，预处理出 $x = a_i$ 的所有形如一、二两种情况的区间。具体实现可以从每个点开始向左向右扩展，不满足限制后就 break。这里显然是 $O(n^2)$ 的。

下文称满足 $x = a_i$ 的第一种情况的区间集合为 $L_i$，第二种情况的区间集合为 $R_i$。

定义 $f_i$ 表示考虑到 $i$ 时 $1\sim i$ 整个区间的 $\max F(D)$。有以下转移：

- 不选，$f_i\gets \max(f_i,f_{i-1})$。

- 选第一种情况，$[p,i]\in L_i$，$f_i\gets \max(f_i, f_{p-1}+val(p,i))$。

  一般的，$val(p,i)=\sum_{j=p}^{i-1} b_j$。注意我们还有 $h_{i-1}=a_i$ 的情况，需要特判转移时 $val(p,i)=\sum_{j=p}^{i} b_j$（包含 $b_j$）。

- 选第二种情况，$[i,p]\in R_i$，$f_p\gets \max(f_p, f_{i-1}+\sum_{j=i+1}^{p} b_j)$。

- 两种情况同时存在，$[l,i]\in L_i$，$[i,r]\in R_i$，$f_r\gets \max(f_r,f_{l-1}+\sum_{j=l}^{r} b_j-b_i)$。应保证 $h_{i-1}+h_{i+1}<a_i$。

读者可能对一些转移的限制感到疑惑，这些限制将在求 $\sum G(D)$ 部分解释。

瓶颈在于上面**两种情况同时存在**的转移，直接枚举两个集合转移是 $O(n^3)$ 的。

我们发现，最严格的限制是 $h_{i-1}+h_{i+1}<a_i$。在满足该条件时，我们随意更换枚举顺序，转移成分都是一部分区间的 $\max (f_{l-1}+\sum_{j=l}^{i-1} b_j)$ 与 $\sum_{j=i+1}^{r} b_j$ 之和。

注意到这两个式子很单纯可爱！左式仅包含与 $l$ 相关的项，右式仅包含与 $r$ 相关的项，而转移限制又仅仅是 $h_{i-1}+h_{i+1}<a_i$。

对每个 $i$ 的 $L_i$ 内的区间按 $h_{i-1}$ 排序（不同的区间对应的 $h_{i-1}$ 显然不一定相同，读者自行思考），$R_i$ 内的区间按 $h_{i+1}$ 排序。

双指针外层维护 $R_i$ 当前的 $Rval=\sum_{j=i+1}^{r} b_j$，内层维护 $L_i$ 内已经合法的区间的 $Lval = \max(f_{l-1}+\sum_{j=l}^{i-1} b_j)$，转移即 $f_r\gets \max(f_r,Lval + Rval)$。其中 $r$ 为当前外层枚举到的区间 $[i,r]$ 中的 $r$。

瓶颈在于 $n$ 次排序，总复杂度 $O(n^2\log n)$。

---

### 求 $\sum G(D)$。

容易发现上述转移实际是枚举了所有情况，在求 $\max F(D)$ 时可以同步计算。

具体的，当转移形如 $f_i\gets f_j+\sum b_p$ 时，令 $g_i$ 表示考虑到 $i$ 时 $1\sim i$ 整个区间的 $\sum G(D)$。根据乘法原理，易得 $g_i\gets g_i + g_j\times \prod c_p$。另外的，$g_i\gets g_{i-1}$。

我们来考虑这样子计数为什么是对的。

根据乘法原理和 $g_i$ 定义，若当前位置不选，相当于继承 $1\sim i-1$ 的 $\sum G(D)$。若选择，相当于前面所有情况都与当前选择的贡献产生一次贡献。

然后是**不重不漏**的问题。

考虑以下序列：

`1 3 2 3 1`

容易找到合法区间 $[1,3]\in L_3,[1,3]\in R_1$。

如果对区间 $[1,3]\in R_1$ 的限制为 $h_{i+1}\le a_i$，那么就会产生两次贡献，他们的结果都会是把前面三个全部拿走。

所以我们钦定 $L_i$ 区间可以“伸向”$a_i$，而 $R_i$ 不能，避免算重。

另外的，在预处理 $L_i$ 区间时，若一次伸长后 $h_i = 0$，则直接退出。考虑 $h_i = 0$ 时延长序列其实等价于 $x = 0$，我们把它视作结尾。则其一定可以和另一个在后面与他相邻的合法区间拼出一个大区间。$h_i = 0$ 时不退出在上一问是没关系的，但在这一问会导致算重。

考虑另一个序列：

`1 3 4 3 1`

容易找到合法区间 $[1,3]\in L_3,[3,5]\in R_3,[1,5]\in L_5$。

若**两种情况同时存在**的转移条件为 $h_{i-1}+h_{i+1}\le a_i$，即包含 $a_i$，则 $[1,3]\in L_3,[3,5]\in R_3$ 在这里的转移，可以和 $[1,5]\in L_5$ 在**第一种情况**转移时，被多次统计。

这种情况即：**$L_i$ 中的区间本身等价于了 $L_j$ 和 $R_j$ 的区间并**。这种情况仅会在 $h_{i-1}+h_{i+1} = a_i$ 时出现，证明显然。故令转移条件为 $h_{i-1}+h_{i+1} < a_i$。

---

综上，总复杂度为 $O(n^2\log n)$，空间复杂度为 $O(n^2)$。

这个 $\log n$ 来自于 `std::sort`，常数小到可以轻松通过了。但是仍然存在一个简单的优化方法。

注意瓶颈部分。对于每个 $i$，区间长度按奇偶性分开，长度奇偶性相同的 $[x,i]\in L_i$ 和 $[i,y]\in R_i$，其 $h_{i-1}$ 和 $h_{i+1}$ 分别根据 $x$ 和 $y$ 单调不减。

具体的，若有长度奇偶性相同的区间 $[1,5],[1,3]$。

在 $[1,5]$ 中，$h_2 = a_2-a_3+a_4-a_5$；在 $[1,3]$ 中，$h_2' = a_2-a_3$。根据我们对合法区间的定义，显然有 $0\le a_4-a_5<a_2-a_3$，容易推广到所有情况。

那么我们根据长度奇偶性分开储存区间，最后将两个集合归并起来。每次复杂度是 $O(n)$ 的，总复杂度 $O(n^2)$。

以下是一份 $O(n^2\log n)$ 的实现，读者若理解该做法，改为 $O(n^2)$ 是容易的。

代码为了美观省略了 FastIO 和 Modint。

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace __FastIO
{
}

namespace __StaticModInt32
{
};
using imt = __StaticModInt32::ModInt32<1000000007>;

// #define ONLINE_JUDGE
#ifdef ONLINE_JUDGE
#define cin __FastIO::InputHelper::get_instance()
#define cout __FastIO::OutputHelper::get_instance()
#define endl '\n'
#endif
const int N = 5e3 + 5;
typedef long long ll;
const ll inf = 1e18;

int n, a[N], b[N], c[N];
vector<tuple<ll, imt, int, int>> L[N], R[N];
ll f[N];
imt g[N];

void Main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    for (int i = 1; i <= n; i++)
        cin >> b[i];
    for (int i = 1; i <= n; i++)
        cin >> c[i];
    for (int i = 1; i <= n; i++)
        L[i].clear(), R[i].clear();
    for (int i = 1; i <= n; i++)
    {
        ll val = b[i];
        int res = a[i];
        imt mul = c[i];
        for (int j = i + 1; j <= n; j++)
        {
            if (a[j] < res)
                break;
            L[j].emplace_back(val, mul, i, res);
            mul *= c[j];
            val += b[j];
            res = a[j] - res;
            if (!res)
                break;
        }
    }
    for (int i = n; i > 0; i--)
    {
        ll val = b[i];
        int res = a[i];
        imt mul = c[i];
        for (int j = i - 1; j > 0; j--)
        {
            if (a[j] <= res)
                break;
            R[j].emplace_back(val, mul, i, res);
            mul *= c[j];
            val += b[j];
            res = a[j] - res;
        }
    }
    for (int i = 1; i <= n; i++)
    {
        sort(L[i].begin(), L[i].end(), [](const auto &x, const auto &y)
             { return get<3>(x) < get<3>(y); });
        sort(R[i].begin(), R[i].end(), [](const auto &x, const auto &y)
             { return get<3>(x) > get<3>(y); });
    }
    fill(f + 1, f + n + 1, -inf);
    fill(g + 1, g + n + 1, 0);
    f[0] = 0;
    g[0] = 1;
    for (int i = 1; i <= n; i++)
    {
        f[i] = max(f[i], f[i - 1]);
        g[i] += g[i - 1];
        auto lit = L[i].begin();
        auto rit = R[i].begin();
        imt equal = 0;
        ll Max = -inf;
        while (rit != R[i].end())
        {
            while (lit != L[i].end() && get<3>(*lit) + get<3>(*rit) < a[i])
            {
                Max = max(Max, f[get<2>(*lit) - 1] + get<0>(*lit));
                equal += g[get<2>(*lit) - 1] * get<1>(*lit);
                ++lit;
            }
            f[get<2>(*rit)] = max(f[get<2>(*rit)], get<0>(*rit) + Max);
            g[get<2>(*rit)] += equal * get<1>(*rit);
            ++rit;
        }
        for (auto &[lval, lmul, lpos, lres] : L[i])
        {
            if (lres == a[i])
            {
                f[i] = max(f[i], f[lpos - 1] + lval + b[i]);
                g[i] += g[lpos - 1] * lmul * c[i];
            }
            else
            {
                f[i] = max(f[i], f[lpos - 1] + lval);
                g[i] += g[lpos - 1] * lmul;
            }
        }
        for (auto &[rval, rmul, rpos, rres] : R[i])
        {
            f[rpos] = max(f[rpos], f[i - 1] + rval);
            g[rpos] += g[i - 1] * rmul;
        }
    }
    cout << f[n] << ' ' << g[n] << endl;
}

signed main()
{
#ifdef ONLINE_JUDGE
    freopen("sequence.in", "r", stdin);
    freopen("sequence.out", "w", stdout);
#endif
    int TaskId = 0, TaskCnt = 1;
    cin >> TaskId >> TaskCnt;
    while (TaskCnt--)
        Main();

    return 0;
}
```

---

## 作者：D2T1 (赞：7)

一个 $O(n^2)$ 的，考场数据所有点用时小于 0.6s 的做法。

先考虑第一问。显然的发现是：

- 对于 $(i,i+1)$ 或 $(i,i-1)$，只会操作一次。
- 不会先操作 $(i,i+1)$ 再操作 $(i-1,i)$，因为先操作后 $a_i$ 变为了 $0$，那么第二个操作要么不能进行，要么毫无意义。
- 不会先操作 $(i,i-1)$ 再操作 $(i+1,i)$。

那么所有操作可以划分成若干不交的段，每一段 $[l,r]$ 表示操作 $(l,l+1),(l+1,l+2),...,(p-1,p)$ 以及 $(r,r-1),(r-1,r-2),...,(p+1,p)$，最后只剩一个 $a_p\neq 0$ 或者 $a_l\sim a_r$ 均为 $0$。

预处理 $L_i,R_i$ 表示操作 $(i,i-1),(i-1,i-2),...$ 一直能够操作到最左侧的 $(L_i+1, L_i)$，$R_i$ 同理。那么一个区间 $[l,r]$ 可以变为一个合法的段当且仅当 $R_l\geq L_r$。

假设最后区间 $[l,r]$ 缩到了一个点 $p\in[\max(l,L_r),\min(r,R_l)]$，$a_p$ 的值其实是非常好算的：$[l,r]$ 内与 $p$ 同奇偶的 $a$ 和减去与 $p$ 不同奇偶的 $a$ 和。这个值与 $p$ 的具体位置没有关系，只和 $p$ 的奇偶性有关！具体地，对于合法段有：

- 若 $\sum_{i=l}^r(-1)^ia_i=0$，则这一段内的 $a$ 可以全变为 $0$；
- 若 $\sum_{i=l}^r(-1)^ia_i>0$，则 $[\max(l,L_r),\min(r,R_l)]$ 内所有偶数下标可以作为最终的 $p$；
- 若 $\sum_{i=l}^r(-1)^ia_i<0$，则 $[\max(l,L_r),\min(r,R_l)]$ 内所有奇数下标可以作为最终的 $p$。

于是得到了第一问做法：设 $f_i$ 表示前 $i$ 个元素的最优解，枚举区间 $[l,r]$ 判断是否合法，然后找到对应的类型，更新 $f_r$ 即可。

最后是去重的问题。发现重的地方在哪呢？在于一个合法段可能拆分成一个 $0$ 段和一个合法段，对应的唯一有值的 $a$ 仍然相同。

需要改的地方非常简单：求解 $L,R$ 时，若 $i\to L_i$ 一路操作过去会使得 $a_{L_i}=0$，那么直接视作求得 $L_i$，break。$R$ 同理。这样的话，一个合法段就不再能继续拆分。

总复杂度 $O(n^2)$，不需要任何数据结构。

---

## 作者：nullqtr_pwp (赞：6)

被校线卡了没有 D 的场外选手/ll

考虑一个数变为 $0$ 后两端就是互不相关的子问题，并且可以给 $(i,i+1)$ 的边定向，表示这个值传递方向。现在连通块就形如一堆段，每个段中间至多一个位置是 $>0$ 的，两侧是 $=0$ 的（可能有全 $0$）。

分析一下，这个值是唯一的，也就是 $[l,r]$ 中奇数的和减去偶数的和的绝对值。并且要求传递过程中非负，可以处理 $p_l,q_r$ 分别表示 $l,r$ 向右，向左传递过程中在什么位置第一次不合法。对于一个分段方式，固定 $l,r$ 之后合法的位置一定在 $[p_l,q_r]$ 且奇偶正确的位置（如果差为 $0$ 那么 $p$ 本身不重要，如果奇数和大于偶数和，$p$ 必须是奇数，否则 $p$ 为偶数），这样用一个 $\text{1D-1D}$ 的 dp，枚举分段 $[l,r]$，找到其中  $\min b$，就可以 $\mathcal O(n^2)$ 解决第一问。

考虑拓展到第二问，需要精细的刻画使得计数的合法序列**不重**不漏，因为一个最终序列可能由多种划分方式得到。一个显然的必要条件是，如果一段 $[l,r,p]$ 满足在 $p$ 前面的前缀使得奇数偶数和相等，那么可以进一步拆分掉这个前缀，后缀同理。因此对“极小”的段划分方式进行计数，也就是 $[l,r,p]$ 必须满足 $[l,p-1]$ 不存在奇数和等于偶数和，$[p+1,r]$ 同理。这样限制对于 $l,r$ 依旧是独立的，这些条件放在一起可以得到合法的 $p$ 的范围是一个区间 $[L,R]$，并且满足奇偶性限制。再做一些优化就容易快速计算贡献。转移的时候，特判总和为 $0$ 的情况，只需要保证极小，$p$ 的选取并不是重要的。

时间复杂度 $\mathcal O(n^2)$。


``` cpp
int a[maxn],n,testid,b[maxn],c[maxn];
ll pre[maxn][2],preb[maxn];
ll qodd(int l,int r){ return l>r?0:pre[r][0]-pre[l-1][0]; }
ll qeven(int l,int r){ return l>r?0:pre[r][1]-pre[l-1][1]; }
ll qry(int l,int r){ return qodd(l,r)-qeven(l,r); }
ll qsumb(int l,int r){ return l>r?0:preb[r]-preb[l-1]; }
int tr[maxn],tl[maxn],nl[maxn],nr[maxn],invc[maxn];
int dp[maxn],mn[maxn][maxn][2],dp1[maxn],pr[maxn][maxn][2],rp[maxn][maxn];
ll mxdp[maxn];
void solve(){
	cin>>n;
	memset(dp1,0,sizeof dp1),memset(mxdp,0,sizeof mxdp),memset(dp,0,sizeof dp),memset(pre,0,sizeof pre);
	F(i,1,n)cin>>a[i],pre[i][0]=pre[i-1][0]+(i&1)*a[i],pre[i][1]=pre[i-1][1]+((i&1)==0)*a[i];
	F(i,1,n)cin>>b[i],preb[i]=preb[i-1]+b[i];
	F(i,1,n)cin>>c[i],invc[i]=qpow(c[i],mod-2);
	F(i,1,n)tl[i]=tr[i]=i;
	F(i,1,n)F(j,i+1,n){
		if((j&1)&&qry(i,j)>=0)tl[i]=j;
		else if(!(j&1)&&qry(i,j)<=0)tl[i]=j;
		else break;
	}
	F(i,1,n)dF(j,i-1,1){
		if((j&1)&&qry(j,i)>=0)tr[i]=j;
		else if(!(j&1)&&qry(j,i)<=0)tr[i]=j;
		else break;
	}
	memset(nl,0,sizeof nl),memset(nr,0,sizeof nr);
	F(i,1,n)F(j,i,tl[i])if(qry(i,j)==0){ nl[i]=j;break; }
	F(i,1,n)dF(j,i,tr[i])if(qry(j,i)==0){ nr[i]=j;break; }
	F(i,1,n){
		rp[i][i-1]=1;
		F(j,i,n)rp[i][j]=1ll*rp[i][j-1]*c[j]%mod;
	}
	F(l,1,n){
		mn[l][l-1][0]=mn[l][l-1][1]=inf;
		pr[l][l-1][0]=pr[l][l-1][1]=0;
		F(r,l,n){
			F(i,0,1)pr[l][r][i]=pr[l][r-1][i];
			F(i,0,1)mn[l][r][i]=mn[l][r-1][i];
			chkmin(mn[l][r][r&1],b[r]),inc(pr[l][r][r&1],invc[r]);
		}
	}
	dp[0]=dp1[0]=1;
	F(r,1,n)F(l,1,r){
		int L=max(l,tr[r]),R=min(r,tl[l]);
		if(L>R)continue;
		const ll val=qry(l,r);
		if(val==0){
			if(nl[l]&&r>nl[l])continue;
			if(nr[r]&&l<nr[r])continue;
			inc(dp[r],dp[l-1]);
			chkmax(mxdp[r],mxdp[l-1]+qsumb(l,r));
			inc(dp1[r],1ll*dp1[l-1]*rp[l][r]%mod);
			continue;
		}
		if(nl[l])chkmin(R,nl[l]);
		if(nr[r])chkmax(L,nr[r]);
		if(val>0){
			if(!(L&1))++L;
			if(!(R&1))--R;
			if(L>R)continue;
			const int val=((R-L)>>1)+1;
			inc(dp[r],1ll*val*dp[l-1]%mod);
			chkmax(mxdp[r],mxdp[l-1]+qsumb(l,r)-mn[L][R][1]);
			inc(dp1[r],1ll*dp1[l-1]*rp[l][r]%mod*pr[L][R][1]%mod);
		} else{
			if(L&1)++L;
			if(R&1)--R;
			if(L>R)continue;
			const int val=((R-L)>>1)+1;
			inc(dp[r],1ll*val*dp[l-1]%mod);
			chkmax(mxdp[r],mxdp[l-1]+qsumb(l,r)-mn[L][R][0]);
			inc(dp1[r],1ll*dp1[l-1]*rp[l][r]%mod*pr[L][R][0]%mod);
		}
	}
	cout<<mxdp[n]<<' '<<dp1[n]<<'\n';
}

```

---

## 作者：SDSXC (赞：6)

~~疑似目前场切过最牛的题~~

我们考虑最后得到的 $D$ 会是什么样子，拆一下每一项 $a_i$ 的系数，不难发现如果 $a_i$ 最后只会出现在 $D$ 中的某一项内，并且如果最初位置与最终位置奇偶性相同则为 $1$，否则为 $-1$。并且如果 $a_i$ 最终移动到了 $j$ ，那么 $[i,j]$ 的所有数最终也会在 $j$ 中。

也就是说，我们可以将序列划分为若干段，然后每一段中所有 $a_i$ 聚集到中间某个位置，这个位置的值也是根据这个区间唯一确定的。

我们设计 dp，$f_i$ 表示前 $i$ 位的答案，然后枚举每一个区间拼上去进行转移。我们考虑一个区间的贡献是什么，首先这个区间中除了 $a_i$ 最终聚集的位置，其他位置都是 $0$，所以贡献就是其他位置的和(积)，在减掉(乘以)可能为最终聚集位置的最小值(倒数和)。我们只要找到哪些位置可能成为最终的聚集位置即可。

首先因为 $a_i\geq 0$，所以我们对奇偶性有要求，简单判断 $a_i$ 奇数位和偶数位的和的大小关系即可。然后还要求聚集位置是可以通过某个过程取到的，也就是说从两边向中间缩，中间每一步都 $\geq0$。不难证明符合以上条件的都能取到。

这样朴素实现是 $O(n^3)$ 的。考虑预处理所有信息，最小值，乘积之类不用多说，两边向中间能缩到的位置可以直接预处理从每个位置开始向左向右最多能缩到哪里，即可做到 $O(n^2)$。

然后仅仅这样写的话会发现只能过第一小问和特殊性质 B，这是因为如果某一段 $a_i$ 的奇数和与偶数和相等，那么他算在左边那一段算了一次，右边那一段算了一次，单独成一段又算了一次会算重。我们考虑强行令他归到左边那一段，这样我们就限制从左向右缩区间时必须严格大于 $0$，从右向左允许等于 $0$。还有一些小 corner case。最左边一段 0 没法归到左边那一段，那就放在第一段处理。最终 $D$ 全是 0 的也没有统计到，特判一下。

代码，写的比较丑：


```cpp
#include<bits/stdc++.h>
#define ll long long
#define p 1000000007ll
#define N 5009
#define INF 0x3f3f3f3f3f3f3f3fll
using namespace std;
ll f[N],g[N],mn[N][N][2],sm[N][2],B[N],C[N][N],a[N],b[N],c[N],inv[N],s[N][2];
int n,l[N],r[N];
ll qpow(ll x,ll y){
	if(!y)return 1ll;
	ll tmp=qpow(x,y>>1);
	if(y&1)return tmp*tmp%p*x%p;
	else return tmp*tmp%p;
}
void solve(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i],s[i][i&1]=s[i-1][i&1]+a[i],s[i][(i&1)^1]=s[i-1][(i&1)^1];
	for(int i=1;i<=n;i++)cin>>b[i],B[i]=B[i-1]+b[i];
	for(int i=1;i<=n;i++)cin>>c[i],inv[i]=qpow(c[i],p-2),sm[i][i&1]=sm[i-1][i&1]+inv[i],sm[i][(i&1)^1]=sm[i-1][(i&1)^1];
	for(int i=1;i<=n;i++){
		f[i]=-INF,g[i]=0;
		for(int j=0;j<=n;j++)mn[i][j][0]=mn[i][j][1]=INF,C[i][j]=1;
	}g[0]=1;f[0]=0;
	for(int i=1;i<=n;i++){
		int x=i;ll sum=a[i];
		while(x<n){
			sum=a[x+1]-sum;
			if(sum<0||(sum==0&&i!=1))break;
			++x;
		}l[i]=x;
	}
	for(int j=1;j<=n;j++){
		int y=j;ll sum=a[j];
		while(y){
			sum=a[y-1]-sum;
			if(sum<0)break;
			--y;
		}r[j]=y;
	}
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			C[i][j]=C[i][j-1]*c[j]%p;
			if(j&1)mn[i][j][1]=min(mn[i][j-1][1],b[j]),mn[i][j][0]=mn[i][j-1][0];
			else mn[i][j][0]=min(mn[i][j-1][0],b[j]),mn[i][j][1]=mn[i][j-1][1];
		}
	}
	for(int j=1;j<=n;j++){
		for(int i=1;i<=j;i++){
			int x=min(l[i],j),y=max(i,r[j]);
			ll sum[2]={s[j][0]-s[i-1][0],s[j][1]-s[i-1][1]},bb[3]={mn[y][x][0],mn[y][x][1],B[j]-B[i-1]},cc[3]={(sm[max(y-1,x)][0]-sm[y-1][0])%p,(sm[max(y-1,x)][1]-sm[y-1][1])%p,C[i][j]};
			if(sum[0]<sum[1])f[j]=max(f[i-1]+bb[2]-bb[1],f[j]),g[j]=(g[j]+g[i-1]*cc[2]%p*cc[1])%p;
			else if(sum[0]>sum[1])f[j]=max(f[i-1]+bb[2]-bb[0],f[j]),g[j]=(g[j]+g[i-1]*cc[2]%p*cc[0])%p;
			else if(i==1&&j==n&&y<=x)f[n]=max(f[n],bb[2]),g[n]=(g[n]+cc[2])%p;
		}
	}
	cout<<f[n]<<" "<<g[n]<<"\n";
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	int CC,T;cin>>CC>>T;while(T--)solve();
	return 0;
}
```

---

## 作者：Nangu (赞：4)

考场做法。

我们先考虑解决问题一。

考虑进行一次操作后，$a_i$ 就会变成 $0$ 了；在这之后，对 $a_i$ 进行的任何操作就都没有意义了，我们实际上把整个序列分成了互不干扰的两段，可以进行递归求解。

这样容易设计出一个区间 dp：计 $f_{l, r, x, y}$ 表示目前考虑区间 $[l, r]$，$a_l=x$，$a_r=y$，其能操作得到的最大答案。容易发现状态数不会很多，因此可以套一个记忆化搜索求解，根据实现的常数，可获得 $12$ 到 $24$ 分不等。

因此，若左边的 $a_j$ 要通过一系列操作影响到右边的 $a_i$，我们必须依次进行 $(j, j+1), (j+1, j+2)$ 一直到 $(i-1, i)$ 为止，则此时 $[j, i-1]$ 内的所有数都变成了 $0$，而 $a_i$ 恰好为 $[j, i]$ 内所有数的错位和；对于从右往左推也是如此。

我们让 $[l, r, k]$ 代表一组操作 $(l, l+1),(l+1, l+2)...(k-1, k)$ 以及 $(r, r-1), (r-1, r-2)...(k+1, k)$，容易发现这样的每个区间之间互不干扰，而且最终只有 $a_k$ 有值，其值恰好等于整个区间的错位和的绝对值。

于是可以设计出一个朴素的序列 dp。令 $f_i$ 表示当前序列划分到 $i$，前 $i$ 项的答案，转移时我们枚举 $j,k$，并 $O(n)$ 检查是否合法，即可做到 $O(n^4)$，稍加优化即可做到 $O(n^3)$；
容易发现，对于一个 $j$，合法的 $k$ 应为一段前缀；对于一个 $i$，合法的 $k$ 应该为一对后缀，则对于区间 $[j, i]$，我们只需要预处理出左右端点合法的 $k$ 的前后缀区间，进行取交即可得到最后合法的 $k$，这样就容易做到 $O(n^2)$ 了。

对于问题二，容易发现其与问题一类似，但倘若操作 $[l, r, k]$ 后 $a_k=0$，则会将 $k$ 不同的情况算重，只需进行一些特殊判断即可。

具体实现时，需要注意判断一下 $k$ 与 $r$ 的奇偶性与$[l, r]$ 的错位相加和的符号有关，处理一下细节就好了。

---

## 作者：rizynvu (赞：4)

[cnblogs](https://www.cnblogs.com/fiosiate/p/18985563)。

首先因为这题要计数，所以尝试去找一个刻画方式刻画出所有能被 $a$ 生成的序列。

考虑操作实际就是让 $a_i, a_{i + 1}$ 同时减去 $\min\{a_i, a_{i + 1}\}$。  

在这之后一定会有一个数变为 $0$，且发现若操作的两个数中有 $0$，那么情况一定不变。

于是可以知道，如果多次选择了 $(i, i + 1)$，那么除第一次的操作肯定都是无效的。  
那么直接指定每对 $(i, i + 1)$ 至多被操作一次即可。

考虑操作时若 $a_i \le a_{i + 1}$，那么认为有 $i\to i + 1$；若 $a_i \ge a_{i + 1}$，那么有 $i\gets i + 1$（相等会有点问题，但是这里先暂时不考虑）。  
这个边集一定能被分成若干个 $\cdots\to\to\to\gets\gets\gets\cdots$ 的连续段，即左端从 $l$，右端从 $r$ 往内汇聚，直到一个分界线 $k$ 挡住了两测。

于是可以首先预处理出单侧的情况，记 $lv_{l, k}$ 表示 $l$ 汇聚到 $k$ 时的值，易知有 $lv_{l, l} = a_l, lv_{l, k + 1} = a_{k + 1} - lv_{l, k}$。  
需要保证中途都是可以操作的，即若 $lv_{l, k} < 0$，那么其实都走不到 $k$ 这里，从 $k$ 开始的 $lv_{l, k}$ 都是不合法的。  
同理定义 $rv_{r, k}$。

那么考虑暴力的做法，直接枚举 $(l, r, k)$，首先肯定要满足 $l, r$ 都能走到 $k$，然后再来分讨一下 $k$ 处的情况：

- $lv_{l, k} + rv_{r, k} < a_k$，那 $k$ 这里的操作肯定怎样都不合法。
- $lv_{l, k} + rv_{r, k} > a_k$，最后的 $a$ 一定形如，$[l, k), (k, r]$ 为 $0$，但是 $k$ 处不为 $0$。
- $lv_{l, k} + rv_{r, k} = a_k$，最后的 $a$ 一定满足 $[l, r]$ 都为 $0$。

（这里与 $a_k$ 比较只是因为前面定义的 $lv_{l, k}, rv_{r, k}$ 相加时会多一个 $a_k$，实际上还是与 $0$ 比较。）

于是现在就有了个 $\mathcal{O}(n^3)$ 的做法，不过会发现这个做法其实有点问题，计数的时候可能会计重。

例如 $a = [1, 1, 1, 1]$，会认为 $[1, 2], [3, 4], [1, 4]$ 都可以消除，那这就爆了。  
思考一下原因，对于 $(l, r, k)$，其实如果删除一段前缀或后继（不包括 $k$），假设通过这段后得到的值是 $x$，那么对最终 $a_k$ 的影响肯定是有 $+x$ 或 $-x$ 的，那么肯定就需要另一边同样调整以使最终 $a_k$ 不变，但是这样又会影响周边的段继续修改，所以一定会继续往外扩张的，一定不合法——吗？  
于是发现了问题：当 $x = 0$ 时，且如果换一个方向传入的值也是 $0$ 时，那么这一段是可以分到任意一边的。

为了解决这个问题，只需要考虑小修一下 $lv_{l, k}, rv_{r, k}$ 的定义：当 $\le 0$ 时就是不合法的。这样的 $\mathcal{O}(n^3)$ 做法就是正确的。

$\mathcal{O}(n^3)$ 的代码也会放在后面供参考。

接下来考虑继续优化，发现 dp 中直接对于 $r$ 枚举 $l$ 并统计贡献看着已经比较优了，于是需要解决的应当是快速处理对于所有 $k$，$(l, r, k)$ 的贡献。

上文已经发现了一个事实：对于一个数 $x$，其对中心的贡献一定是 $+x$ 或 $-x$。  
从这里入手，能发现符号一定是与中心距离为偶数时为 $+$，为奇数时为 $-$。即包括中心的右侧符号应当形如 $+-+-+-+-\cdots$，左侧也是对称的。

于是对于 $l, r$ 来说，若 $k$ 的奇偶性相同，则 $a_k$ 最后得到的值一定也是相同的，且不同奇偶性的 $k$ 得到的值一定互为相反数（不过不知道这个也没有啥）。

记 $l$ 能扩展到的最远的 $k$ 为 $lb_l$，同理记 $rb_r$。  
那么合法的 $k$ 一定是在 $[\max(l, rb_r), \min(r, lb_l)]$ 中的所有奇数或偶数或全部（中间值 $= 0$ 时），只需要知道这部分的 $\max \{-b_k\}$ 和 $\sum \frac{1}{c_k}$，可以写个 st 表前缀和，不过因为数据范围并不大，直接 $\mathcal{O}(n^2)$ 预处理也可以。

一个小细节：上述判断中间值 $= 0$ 的方法还是有点问题，不过能发现问题只出在 $a_i = a_{i + 1}$，特殊处理一下即可。

代码是复刻的，应该没有问题。

$\mathcal{O}(n^3)$（判断 $=0$ 的方式有点不一样）：

```cpp
inline void solve() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    for (int i = 1; i <= n; i++) scanf("%d", &b[i]);
    for (int i = 1; i <= n; i++) scanf("%d", &c[i]);
    
    for (int i = 1; i <= n; i++) {
        memset(lv[i] + 1, -1, sizeof(int) * n);
        lv[i][i] = a[i];
        for (int j = i; j < n && lv[i][j] < a[j + 1]; j++) {
            lv[i][j + 1] = a[j + 1] - lv[i][j];
        }
    }
    for (int i = n; i >= 1; i--) {
        memset(rv[i] + 1, -1, sizeof(int) * n);
        rv[i][i] = a[i];
        for (int j = i; j > 1 && rv[i][j] < a[j - 1]; j--) {
            rv[i][j - 1] = a[j - 1] - rv[i][j];
        }
    }

    for (int l = 1; l <= n; l++) {
        for (int r = l; r <= n; r++) {
            ok0[l][r] = false;
        }
    }
    for (int i = 1; i < n; i++) {
        for (int l = 1; l <= i; l++) {
            for (int r = i + 1; r <= n; r++) {
                ok0[l][r] |= lv[l][i] != -1 && rv[r][i + 1] != -1 && lv[l][i] == rv[r][i + 1];
            }
        }
    }

    for (int i = 1; i <= n; i++) {
        for (int l = 1; l <= i; l++) {
            for (int r = i; r <= n; r++) {
                ok[i][l][r] = lv[l][i] != -1 && rv[r][i] != -1 && lv[l][i] + rv[r][i] > a[i];
            }
        }
    }

    pre[0] = 0;
    for (int i = 1; i <= n; i++) pre[i] = pre[i - 1] + b[i];
    f[0] = 0;
    for (int i = 1; i <= n; i++) {
        f[i] = f[i - 1];
        for (int j = 1; j <= i; j++) {
            if (ok0[j][i]) f[i] = std::max(f[i], f[j - 1] + pre[i] - pre[j - 1]);
            for (int k = j; k <= i; k++) {
                if (ok[k][j][i]) f[i] = std::max(f[i], f[j - 1] + pre[i] - pre[j - 1] - b[k]);
            }
        }
    }

    pr[0] = ipr[0] = 1;
    for (int i = 1; i <= n; i++) {
        ic[i] = qpow(c[i], mod - 2);
        pr[i] = pr[i - 1] * c[i] % mod;
        ipr[i] = ipr[i - 1] * ic[i] % mod;
    }
    g[0] = 1;
    for (int i = 1; i <= n; i++) {
        g[i] = 0;
        for (int j = 1; j <= i; j++) {
            if (ok0[j][i]) g[i] = (g[i] + g[j - 1] * pr[i] % mod * ipr[j - 1]) % mod;
            for (int k = j; k <= i; k++) {
                if (ok[k][j][i]) g[i] = (g[i] + g[j - 1] * pr[i] % mod * ipr[j - 1] % mod * ic[k]) % mod;
            }
        }
    }

    printf("%lld %lld\n", f[n], g[n]);
}
```

$\mathcal{O}(n^2)$：

```cpp
#include <bits/stdc++.h>

using ll = long long;

constexpr ll mod = 1e9 + 7;

inline ll qpow(ll a, ll b) {
    ll v = 1;
    for (; b; b >>= 1, a = a * a % mod) {
        if (b & 1) v = v * a % mod;
    }
    return v;
}

constexpr int maxn = 5000 + 10;

int n;
int a[maxn], b[maxn], c[maxn];

int lb[maxn], rb[maxn];

bool ok0[maxn][maxn];

ll preb[maxn], fv[maxn][maxn], f[maxn];
ll prec[maxn], iprec[maxn], ic[maxn], gv[maxn][maxn], g[maxn];

ll prea[maxn];

int pic[maxn][maxn][2], mxb[maxn][maxn][2];

inline void solve() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    for (int i = 1; i <= n; i++) scanf("%d", &b[i]);
    for (int i = 1; i <= n; i++) scanf("%d", &c[i]);

    prea[0] = 0;
    for (int i = 1; i <= n; i++) {
        prea[i] = prea[i - 1] + (i % 2 ? a[i] : -a[i]);
    }

    preb[0] = 0, prec[0] = iprec[0] = 1;
    for (int i = 1; i <= n; i++) {
        ic[i] = qpow(c[i], mod - 2);
        preb[i] = preb[i - 1] + b[i];
        prec[i] = prec[i - 1] * c[i] % mod;
        iprec[i] = iprec[i - 1] * ic[i] % mod;
    }

    for (int l = 1; l <= n; l++) {
        pic[l][l - 1][0] = pic[l][l - 1][1] = 0;
        mxb[l][l - 1][0] = mxb[l][l - 1][1] = -2e9;
        for (int r = l; r <= n; r++) {
            pic[l][r][0] = pic[l][r - 1][0];
            pic[l][r][1] = pic[l][r - 1][1];
            mxb[l][r][0] = mxb[l][r - 1][0];
            mxb[l][r][1] = mxb[l][r - 1][1];
            pic[l][r][r % 2] = (pic[l][r][r % 2] + ic[r]) % mod;
            mxb[l][r][r % 2] = std::max(mxb[l][r][r % 2], -b[r]);
        }
    }
    
    for (int i = 1; i <= n; i++) {
        lb[i] = i;
        for (int x = a[i]; lb[i] < n && x < a[lb[i] + 1]; ) {
            x = a[++lb[i]] - x;
        }
    }
    for (int i = n; i >= 1; i--) {
        rb[i] = i;
        for (int x = a[i]; rb[i] > 1 && x < a[rb[i] - 1]; ) {
            x = a[--rb[i]] - x;
        }
    }

    for (int l = 1; l <= n; l++) {
        for (int r = l; r <= n; r++) {
            fv[l][r] = -1e18, gv[l][r] = 0;
        }
    }

    auto conv = [&](const int x) {
        return x == -2e9 ? (ll)-1e18 : (ll)x;
    };

    for (int l = 1; l <= n; l++) {
        for (int r = l; r <= n; r++) {
            if (prea[r] == prea[l - 1] || lb[l] < rb[r]) continue;
            const int op = prea[r] > prea[l - 1];
            const int st = std::max(rb[r], l);
            const int ed = std::min(lb[l], r);
            fv[l][r] = std::max(fv[l][r], preb[r] - preb[l - 1] + conv(mxb[st][ed][op]));
            gv[l][r] = (gv[l][r] + prec[r] * iprec[l - 1] % mod * pic[st][ed][op]) % mod;
        }
    }

    for (int l = 1; l <= n; l++) {
        for (int r = l; r <= n; r++) {
            ok0[l][r] = prea[r] - prea[l - 1] == 0 && rb[r] <= lb[l];
        }
    }
    for (int i = 1; i < n; i++) {
        ok0[i][i + 1] |= a[i] == a[i + 1];
    }

    for (int l = 1; l <= n; l++) {
        for (int r = l; r <= n; r++) {
            if (ok0[l][r]) {
                fv[l][r] = std::max(fv[l][r], preb[r] - preb[l - 1]);
                gv[l][r] = (gv[l][r] + prec[r] * iprec[l - 1]) % mod;
            }
        }
    }

    f[0] = 0;
    for (int i = 1; i <= n; i++) {
        f[i] = -1e18;
        for (int j = 1; j <= i; j++) {
            f[i] = std::max(f[i], f[j - 1] + fv[j][i]);
        }
    }

    g[0] = 1;
    for (int i = 1; i <= n; i++) {
        g[i] = 0;
        for (int j = 1; j <= i; j++) {
            g[i] = (g[i] + g[j - 1] * gv[j][i]) % mod;
        }
    }

    printf("%lld %lld\n", f[n], g[n]);
}

int main() {
    freopen("sequence.in", "r", stdin);
    freopen("sequence.out", "w", stdout);

    int testid, t;
    scanf("%d%d", &testid, &t);
    while (t--) solve();

    return 0;
}
```

---

## 作者：_lmh_ (赞：2)

这个操作的性质非常特殊：一次操作至少会将一个数变成 $0$，这个数之后就不能使用了——否则得到的结果相同，没有意义，第二问就会算重。

我们不关心操作的顺序只关心结果，所以列出操作集合，如果在任意时刻进行了操作 $(i,j)$ 将 $a_i$ 修改为 $0$，那么连一条 $j\rarr i$ 的有向边。

容易发现，最后的图上不可能出现 $a\lrarr b$，也不可能出现 $a\rarr b\larr c$，否则无法安排操作顺序。同时，如果出现 $a\larr b\larr c$，那么操作 $(a,b)$ 一定在操作 $(b,c)$ 之前。

这样这个图就能被分成若干部分，每个部分形如 $x\larr x+1\larr \cdots \larr y\rarr y+1\rarr \cdots \rarr z$，看上去很可以 dp 做，一次转移一段。下面称其为操作 $(x,y,z)$。

令 $f_{l,r}$ 为：依次进行操作 $(l,l+1),(l+1,l+2),\cdots,(r-1,r)$ 之后 $a_r$ 的值，如果任意一步无法进行则 $f_{l,r}$ 未定义——之后不考虑这种情况。$g_{l,r}$ 是类似的，只不过操作的顺序为依次进行 $(r,r-1),(r-1,r-2),\cdots,(l+1,l)$。这里认为 $f_{i,i}=g_{i,i}=a_i$。

这样一次操作 $(x,y,z)$ 能够操作当且仅当 $f_{x,y},g_{y,z}$ 均合法并且 $f_{x,y}+g_{y,z}\ge a_y$。当后面的不等式取等的时候，$a_y$ 最后的值为 $0$。

先枚举 $y$，再枚举 $x,z$，转移是 $O(n^3)$ 的。

考虑把贡献拆成 $[x,y)$，$y$ 和 $(y,z]$ 三部分，对于枚举到的每一个 $y$ 将所有 $x$ 的贡献预处理出来。现在对于一个 $z$，将 $x$ 按照 $f_{x,y}$ 排序后，合法的转移是一个前缀（或者后缀）。把 $z$ 按照 $g_{y,z}$ 排序后就可以双指针做到 $O(n^2\log n)$。

现在优化排序的过程。考虑固定 $r$ 之后的 $f_{l,r}$，它等于 $a_r-a_{r-1}+a_{r-2}\cdots +(-1)^{r-l}a_l$，可以猜测这玩意在 $l$ 变小的时候来回震荡并且逐渐趋向一个值——这是对的。事实上，有

$$f_{r,r}>f_{r-2,r}>f_{r-4,r}>\cdots>f_{2-(r\bmod 2),r}>f_{(r\bmod 2)+1,r}>\cdots >f_{r-3,r}>f_{r-1,r}$$

这里假设所有状态均有定义。在一般情况下，剔除无效状态后不等式依然成立。

证明考虑将 $f_{l_1,r}$ 和 $f_{l_2,r}(l_1<l_2)$ 相减，发现结果是 $\pm f_{l_1,l_2-1}$，而 $f_{l_1,r}$ 有定义，所以 $f_{l_1,l_2-1}$ 有定义，并且它一定 $>0$。

这样就可以做到 $O(n^2)$。注意特判全 $0$ 的情况。第一问中要额外加贡献，第二问要限制它只能转移一次，不能重复。

---

## 作者：xinxin2022 (赞：2)

考虑操作本身的性质，其意义为将一段区间以连续做差形式将值转移到某个值上，并使得其他位置的值为 $0$。

那么我们不妨设 $f_i$ 为考虑到 $i$ 的最大权值，可以枚举目前段起点，再枚举转移到的点，容易做到 $O(n^4)$。

进一步的思考，我们可以对一个点向左/右扫描以知道段起点的合法区间，而知道转移点后贡献是可以预处理的，那么可以做到 $O(n^3)$。

再做思考，我们是否可以直接处理出最优的转移点，使得我们可以省略掉枚举过程。

稍做分析，拆开转移点值的组成，发现对于段内的每个 $a_i$，其对于转移点的值影响仅限于本身值和奇偶性，而奇数做负贡献，偶数做正贡献，于是不妨预处理奇偶位前缀和。

记一段区间内奇数位和为 $s_1$，偶数位为 $s_2$，那么不妨分类讨论：

- $s_1=s_2$ 转移点为 $0$，整段区间做贡献。

- $s_1>s_2$ 转移点取奇数位优。

- $s_1<s_2$ 转移点取偶数位优。

于是考虑预处理一段区间内的奇偶位贡献最值，转移时直接令转移点取该点即可，可以做到 $O(n^2)$。

推广做法至第二问，注意限制全 $0$ 段不可连接，避免重复计数。

至于前缀积，逆元即可。

时间复杂度 $O(n(n+\log p))$，代码如下：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define ll long long
const int N=5005;
const int mod=1e9+7;
int op,t,n;
int a[N],b[N],c[N],ml[N],mr[N],l,r;
ll f[N],g[N],s[N],mx[2][N][N],nx[2][N][N],st[N],d,tot[N],ptot[N],pc[N],val;
ll maxnf,sumg;
ll poww(ll a,ll b){
    ll res=1;
    while(b){
        if(b&1) res=res*a%mod;
        a=a*a%mod;
        b/=2;
    }
    return res;
}
signed main(){
    cin>>op>>t;
    while(t--){
        cin>>n;
        tot[0]=1;
        ptot[0]=1;
        memset(g,0,sizeof(g));
        memset(f,-0x3f,sizeof(f));
        for(int i=1;i<=n;i++) cin>>a[i];
        for(int i=1;i<=n;i++) cin>>b[i];
        for(int i=1;i<=n;i++) cin>>c[i];
        for(int i=1;i<=n;i++) s[i]=s[i-1]+b[i];
        for(int i=1;i<=n;i++) pc[i]=poww(c[i],mod-2);
        for(int i=1;i<=n;i++) tot[i]=tot[i-1]*c[i]%mod;
        for(int i=1;i<=n;i++) ptot[i]=poww(tot[i],mod-2);
        for(int i=1;i<=n;i++){
            st[i]=st[i-1];
            if(i&1) st[i]-=a[i];
            else st[i]+=a[i];
        }
        for(int i=1;i<=n;i++){
            mx[0][i][i-1]=mx[1][i][i-1]=1e18;
            nx[0][i][i-1]=nx[1][i][i-1]=0;
            for(int j=i;j<=n;j++){
                mx[0][i][j]=mx[0][i][j-1];
                mx[1][i][j]=mx[1][i][j-1];
                mx[j%2][i][j]=min(mx[j%2][i][j],1LL*b[j]);
                nx[0][i][j]=nx[0][i][j-1];
                nx[1][i][j]=nx[1][i][j-1];
                nx[j%2][i][j]=(nx[j%2][i][j]+pc[j])%mod;
            }
        }
        for(int i=1;i<=n;i++){
            d=a[i];
            for(int j=i;j;j--){
                d=a[j-1]-d;
                if(d<=0||j==1){
                    mr[i]=j;
                    if(j!=1&&d==0) mr[i]--;
                    break;
                }
            }
            d=a[i];
            for(int j=i;j<=n;j++){
                d=a[j+1]-d;
                if(d<=0||j==n){
                    ml[i]=j;
                    break;
                }
            }
        }
        f[0]=0;g[0]=1;
        for(int i=0;i<=n;i++){
            for(int j=i+1;j<=n;j++){
                l=max(i+1,mr[j]);
                r=min(j,ml[i+1]);
                if(l>r) continue;
                val=g[i]*tot[j]%mod*ptot[i]%mod;
                if(st[j]-st[i]==0){
                    f[j]=max(f[j],f[i]+s[j]-s[i]);
                    g[j]=(g[j]+val)%mod;
                }
                if(st[j]-st[i]>0){
                    f[j]=max(f[j],f[i]+s[j]-s[i]-mx[0][l][r]);
                    g[j]=(g[j]+val*nx[0][l][r]%mod)%mod;
                }
                if(st[j]-st[i]<0){
                    f[j]=max(f[j],f[i]+s[j]-s[i]-mx[1][l][r]);
                    g[j]=(g[j]+val*nx[1][l][r]%mod)%mod;
                }
            }
        }
        cout<<f[n]<<' '<<g[n]<<'\n';
    }
    return 0;
}
```

---

## 作者：mskqwq (赞：1)

记对 $i$ 操作表示将 $a_i$ 和 $a_{i-1}$ 都减去 $\min(a_i,a_{i-1})$，尝试对一个最简单的 dp 去转移，即设 $f_i$ 表示前缀 $i$ 的答案，然后转移的思路大概是讨论 $i$ 有没有被操作过。

不对 $i$ 操作的话直接从 $f_{i-1}$ 转移过来。否则考虑一种简单的情况：$i$ 是第一个被操作的。如果 $a_{i-1}\le a_i$ 那就爽了，再操作 $i-1$ 就没用了，直接从 $f_{i-2}$ 转移。否则的话我们可以选择钦定不操作 $i-1$ 然后从 $f_{i-2}$ 转移过来，也可以操作 $i-1$ 继续往前推。

于是可以像这样一直往前推到出现 $0$，记 $l_i$ 表示从 $i$ 往左最多能推到哪个位置。

接着考虑 $i$ 不是第一个操作的情况，那么一类情况是某个 $j<i$ 依次操作 $j+1,j+2\dots i$，并且这之间没有出现 $0$，然后就能从 $f_{j-1}$ 转移过来。同样地，记 $r_j$ 表示 $j$ 往右最多能推到哪。

最后剩下的情况是一对 $j<k<i$，从 $j$ 推到 $k$ 再从 $i$ 推到 $k$，则 $k\in[r_j,l_i]$ 且最后 $a_k\ge 0$。手玩一下可以发现最后 $a_k$ 的取值只跟 $j,k$ 的奇偶性是否相等有关，可以通过 $[j,i]$ 内奇数位的和以及偶数位的和求出，所以每个奇偶性相同的 $k$ 要么都能用来转移要么都不能。那么对 $b$ 和 $c$ 分奇偶位维护区间 $\min$ 以及区间倒数和就能 $O(1)$ 转移了。注意特殊处理最后 $a_k=0$ 的情况。

这种情况可以把上面两种情况包含，让 $k$ 能和 $i,j$ 取等就行了。

代码比较丑。

```cpp
const int N=5010,mod=1e9+7;
ll n,a[N],b[N],c[N],s[N],l[N],r[N],iv[N],f[N],g[N];
ll _b[N][N][2],ic[N][2];
ll qp(ll a,ll b){
    ll r=1;
    for(;b;b>>=1,a=a*a%mod)
        if(b&1) r=r*a%mod;
    return r;
}
void misaka(){
    rep(i,1,n){
        a[i]=b[i]=c[i]=l[i]=r[i]=iv[i]=f[i]=g[i]=0;
        rep(j,0,1){
            ic[i][j]=0;
            rep(k,i,n) _b[i][k][j]=0;
        }
    }
    n=read();
    rep(i,1,n) a[i]=read();
    rep(i,1,n){
        b[i]=read();
        _b[i][i][i&1]=b[i];
        _b[i][i][~i&1]=1e9;
        b[i]+=b[i-1];
    }
    rep(l,2,n)rep(i,1,n-l+1){
        int j=i+l-1;
        rep(k,0,1) _b[i][j][k]=min(_b[i][j-1][k],_b[i+1][j][k]);
    }
    rep(i,1,n){
        ll x=read();
        c[i]=c[i-1]*x%mod;
        ll inv=qp(x,mod-2);
        iv[i]=iv[i-1]*inv%mod;
        ic[i][i&1]=inv;
        rep(j,0,1) ic[i][j]=(ic[i][j]+ic[i-1][j])%mod;
    }
    rep(i,1,n) s[i]=s[i-1]+((i&1)?-a[i]:a[i]);
    rep(i,1,n){
        ll nw=a[i],j=i;
        while(j<n&&a[j+1]>=nw&&nw) nw=a[++j]-nw;
        r[i]=j,nw=a[i],j=i;
        while(j>1&&a[j-1]>=nw&&nw) nw=a[--j]-nw;
        l[i]=j;
    }
    f[0]=0,g[0]=1;
    rep(i,1,n){
        f[i]=f[i-1],g[i]=g[i-1];
        rep(j,1,i-1){
            ll L=max(l[i],(ll)j),R=min(r[j],(ll)i);
            if(L>R) continue;
            ll x=j&1?s[j-1]-s[i]:s[i]-s[j-1],X=0,Y=1;
            if(x==0){
                X=b[i]-b[j-1];
                Y=c[i]*iv[j-1]%mod;
            }
            else{
                int t=(j&1)^(x<0);
                X=b[i]-b[j-1]-_b[L][R][t];
                Y=c[i]*iv[j-1]%mod*(ic[R][t]-ic[L-1][t]+mod)%mod;
            }
            f[i]=max(f[i],f[j-1]+X);
            g[i]=(g[i]+g[j-1]*Y)%mod;
        }
    }
    printf("%lld %lld\n",f[n],g[n]);
}
```

---

## 作者：_Ch1F4N_ (赞：1)

场上过了写个题解。

考虑给操作找点性质，注意到给 $i,i+1$ 操作之后会有一个位置变成 $0$，变成 $0$ 的位置不会再操作了。

再考察一下操作为什么难以处理，这是因为操作之间会互相干涉，也就是一个位置被多次操作，但是结合上面一段说的，当你操作了 $i,i+1$ 后 $i-1,i$ 和 $i+1,i+2$ 中至少一个不会再被操作了。把这样若干次相互干扰的操作画下来，大概长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/v0xbv3r7.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

横线代表操作位置，数字代表操作顺序。

不妨把第一种情形简单表述为向左的箭头，第二种表述为向右的箭头。

序列被这些箭头分成了若干段，每一段有三种情形：

![](https://cdn.luogu.com.cn/upload/image_hosting/z0zs9i30.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

第三种情况中存在一个点受到了两次操作的减法影响。

不妨认为一个箭头代表一个转移段，情形三是两段存在一个交点的特殊情况，转移形如从一个箭头末尾的点在这个箭头的操作后的权值等于 $v$ 的情形出发进入下一个点或者出发再连一个箭头（也就是情形三），这个时候已经可以做第一问也就是求 $\max$ 了。

考虑怎么做第二问，需要不重地对所有序列计数，我们考虑把上面的东西改改。

我们假装不同的箭头对序列的划分对应了不同的序列，考虑什么情况会被算重，注意到一个箭头在操作结束后处理箭头末尾其他数都会变成 $0$，也就是说如果一个箭头其末尾的数也变成 $0$ 了，那么与其方向相反的箭头可能就会产生与其相同的序列。

同时情形三中，两个相向的箭头在操作后如果让覆盖的区域全变成 $0$ 了，也可能于一个直接覆盖整个区域并且使得最后全变成 $0$ 的单向箭头产生相同的序列。

观察到：上述所有情况全部可以调整为一个向左的箭头并且最后使得箭头覆盖区域内全部变为 $0$。

所以钦定向右的箭头不能使得区域内全部是 $0$ 即可，注意到暴力转移其实是 $O(n^3)$ 的，但是瓶颈在一个前缀 $\max$ 于前缀和，预处理加二分即可做到 $O(n^2 \log n)$，可以通过。

---

## 作者：lsj2009 (赞：1)

考虑答案形式，一次操作 $(i,i+1)$ 若 $a_i\ge a_{i+1}$ 则在 $i+1$ 上放一个 $\leftarrow$，若 $a_{i+1}\ge a_i$ 则在 $i$ 上放一个 $\rightarrow$。则操作情况形如若干个 $\rightarrow\rightarrow\rightarrow\leftarrow\leftarrow$。

考虑记 $v^{(\rightarrow)}_{i,j\ge i}$ 表示若从 $i$ 开始一直往右操作直至 $j$，最终 $a_j$ 的值，若过程中出现 $a_k>a_{k+1}(i\le k<j)$ 则 $v^{(\rightarrow)}_{i,j}$ 不合法。同理定义 $v^{(\leftarrow)}_{i,j\le i}$。对于一个极长的 $\rightarrow\leftarrow$ 区间 $[l,r]$ 考虑枚举最终非 $0$ 位置 $k$：（需有 $v^{(\rightarrow)}_{l,k},v^{(\leftarrow)}_{r,k}$ 合法）

1. 若 $v^{(\rightarrow)}_{l,k}+v^{(\leftarrow)}_{r,k}<a_k$ 则最终 $k$ 不能为 $[l,r]$ 最终非零位。

2. 若 $v^{(\rightarrow)}_{l,k}+v^{(\leftarrow)}_{r,k}=a_k$ 则最终 $[l,r]$ 全零。

3. 若 $v^{(\rightarrow)}_{l,k}+v^{(\leftarrow)}_{r,k}>a_k$ 则最终 $k$ 可为 $[l,r]$ 最终非零位。

将 $v^{(\rightarrow)}_{l,k}/v^{(\leftarrow)}_{r,k}$ 挪至不等号右边即退化为最终 $k$ 和 $k\pm 1$ 的比较，从而正确性显然。

如此记 $f_r$ 为仅考虑 $[1,r]$ 区间下 $\max F$ 的值，则枚举 $l,k$ 即可做到 $\mathcal{O}(n^3)$ 转移。

考虑计数问题，什么情况会计重？序列 $1111$，操作 $[1,2],[3,4]$ 和操作 $[1,4]$ 会被认为不同方案，而实际上最终得到的 $a$ 序列是一致的。处理很简单，我们将 $v^{(\rightarrow)}_{i,j}/v^{(\leftarrow)}_{i,j}$ 合法的条件改的更为严格：

- 若途中出现 $a_k=a_{k\pm 1}$ 即不合法。

这样子使得我们枚举的每个 $\rightarrow\leftarrow$ 区间都是在所有最终 $a$ 序列相同的方案中取到了分段更多的那个，从而构成了双射，同理定义 $g_r$ 可以一模一样地直接计数（区间全零的情况只能转移一次）。

这样子即提出了 $\mathcal{O}(n^3)$ 的做法。考虑优化：我们求出 $(\rightarrow)_i$ 为最大的 $j$ 使得 $v^{(\rightarrow)}_{i,j}$ 有意义，同理有 $(\leftarrow)_i$，显然 $k$ 可以进行转移的必要条件是 $k\in[l,r]\cap[(\leftarrow)_r,(\rightarrow)_l]$，然后只需要判断 $v_{l,r}(k)=v^{(\rightarrow)}_{l,k}+v^{(\leftarrow)}_{r,k}-a_k$ 与 $0$ 的大小关系。

发现每一个 $i\in[l,r]$ 的 $a_i$ 对 $v_{l,r}(k)$ 的贡献为 $(-1)^{k-i}a_i$，从而有 $v_{l,r}(k)$ 在 $k$ 为奇数/偶数时全相同，故在区间 $[l,r]\cap[(\leftarrow)_r,(\rightarrow)_l]$ 区间中有全体奇数/偶数均可转移。对于 $[l,r]$ 是否可以全零也仅需判断区间中任意一个 $k$ 是否满足条件即可。

故仅需快速计算 $\max\limits_{l\le i\le r,i\equiv p\pmod{2}}(-b_i)$ 和 $\sum\limits_{l\le i\le r,,i\equiv p\pmod{2}}\frac{1}{c_i}$，预处理即可。

复杂度为 $\mathcal{O}(n^2)$。

---

## 作者：mRXxy0o0 (赞：1)

很重要的一点是注意到 $n\le 5000$。~~（我能说因为没看见所以卡了好几个小时吗？）~~

考虑操作可以分割成很多 `→→→p←←←` 的形式，简单说明一下就是每个位置最多操作一次，且必然有一个变成了 $0$，因此能影响到 $p$ 的操作必然是一个连续段，且段中其他位置为 $0$。

所以考虑枚举最后一个段来 DP。对于第一问，预处理奇加偶减的前缀和，显然固定左端点，只有一个前缀合法，固定右端点同理，所以 $p$ 在一个区间里。怎么找一个最优的 $p$ 呢？注意到，$p$ 的限制是操作完之后 $\ge 0$，这只和 $[l,r]$ 有关，而与 $p$ 无关（因为 $p$ 的最终值为整个区间奇加偶减的值），所以预处理区间奇/偶数下标的最值即可。

考虑一下去重的问题，也就是我们希望枚举的最后一段没有更短的分割方法了。其实只需要保证你枚举的段不存在前缀或后缀和为 $0$。

如果想明白去重，你就发现两个询问没啥本质区别了。

# 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
const int N=5010,mod=1e9+7,inf=1e9;
int n,m,a[N],c[N],pl[N],pr[N],mn1[N][N],mn0[N][N],s0[N],s1[N],g[N],ic[N];
ll f[N],b[N],s[N];
inline int mo(int x){return x<mod?x:x-mod;}
inline void ad(int &x,int y){(x+=y)>=mod&&(x-=mod);}
inline int ksm(int a,int b){
	int d=1;
	while(b){
		if(b&1) d=1ll*d*a%mod;
		a=1ll*a*a%mod;
		b>>=1;
	}
	return d;
}
inline void solve(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%d",&a[i]),s[i]=s[i-1]+(i&1?a[i]:-a[i]);
	for(int i=1;i<=n;++i){
		scanf("%lld",&b[i]);
		if(i&1) mn1[i][i]=b[i],mn0[i][i]=inf;
		else mn0[i][i]=b[i],mn1[i][i]=inf;
		b[i]+=b[i-1];
	}
	c[0]=ic[0]=1;
	for(int i=1;i<=n;++i){
		scanf("%d",&c[i]);
		ic[i]=ksm(c[i],mod-2);
		s0[i]=s0[i-1],s1[i]=s1[i-1];
		ad((i&1?s1:s0)[i],ic[i]);
		c[i]=1ll*c[i]*c[i-1]%mod;
		ic[i]=1ll*ic[i-1]*ic[i]%mod;
	}
	for(int i=1;i<=n;++i){
		ll sum=a[i+1]-a[i];
		pl[i]=pr[i]=i;
		for(int j=i+1;j<=n&&sum>0;sum=a[++j]-sum) pl[i]=j;
		sum=a[i-1]-a[i];
		for(int j=i-1;j&&sum>0;sum=a[--j]-sum) pr[i]=j;
		for(int j=i+1;j<=n;++j) mn0[i][j]=min(mn0[i][j-1],mn0[j][j]),mn1[i][j]=min(mn1[i][j-1],mn1[j][j]);
	}
	g[0]=1;
	for(int i=1;i<=n;++i){
		f[i]=f[i-1],g[i]=g[i-1];
		for(int j=1;j<i;++j){
			if(s[i]-s[j-1]==0&&pr[i]==j+1) f[i]=max(f[i],f[j-1]+b[i]-b[j-1]),g[i]=(g[i]+1ll*g[j-1]*c[i]%mod*ic[j-1])%mod;
			if(pr[i]<=pl[j]){
				int L=max(j,pr[i]),R=min(i,pl[j]),c1=(R-L+1)/2+(L&R&1),c0=(R-L+1)/2+(L&R&1^1);
				if(s[i]-s[j-1]>0&&c1) f[i]=max(f[i],f[j-1]+b[i]-b[j-1]-mn1[L][R]),g[i]=(g[i]+1ll*g[j-1]*c[i]%mod*ic[j-1]%mod*(s1[R]+mod-s1[L-1]))%mod;
				else if(s[i]-s[j-1]<0&&c0) f[i]=max(f[i],f[j-1]+b[i]-b[j-1]-mn0[L][R]),g[i]=(g[i]+1ll*g[j-1]*c[i]%mod*ic[j-1]%mod*(s0[R]+mod-s0[L-1]))%mod;
			}
		}
	}
	printf("%lld %d\n",f[n],g[n]);
}
int main(){
	int T;
	scanf("%*d%d",&T);
	while(T--) solve();
	return 0;
}
```

---

## 作者：Unnamed114514 (赞：1)

注意到我们可以把原序列分成若干段，对于每段，最多只会剩下一个元素，否则因为每个位置只会对一个数，所以我们可以继续分。

因此我们把问题转化为如何 $O(1)$ 计算 $cost$。

首先我们先把不合法判了，令 $L_i,R_i$ 分别表示 $i$ 作为左端点/右端点扩展到的最右/最左位置，容易发现，如果存在一个位置 $p$ 留到最后，那么一定有 $p\in[R_r,L_l]$ 之间，因为只有这样 $l,r$ 的贡献才能到达 $p$，容易发现清空也必须满足这个条件。

然后我们考虑每个位置对最终值的贡献，容易发现奇偶位的贡献系数是恒定的，即奇偶性和目标位置相同的贡献系数为奇数，贡献不同的系数为偶数，因此我们定义 $s_i=\sum\limits_{j=1}^i(-1)^{j-1}a_j$。

如果 $s_r-s_{l-1}=0$ 那么显然最后会清空；否则若 $s_r-s_{l-1}>0$ 最后留下的一定是奇数位；否则留下的一定是偶数位。

对于第一问，如果清空的话，贡献为 $\sum\limits_{i=l}^r b_i$，否则的话在对应区间内对应奇偶性 ban 掉一个数，显然是 ban 掉最小值，因为 $n\le 5000$，初始化的时候跑一下暴力都行。

对于第二问，清空显然为 $\prod_{i=l}^r c_i$，否则 ban 掉一个数，注意在对应区间内的对应奇偶性的数都可能被 ban 掉，因为是计数，所以提取公因数求和。

然而你发现这样计数要算重，比如 `1 1 2`，前两个数变成 $0$ 之后会对第三个数造成贡献。所以我们得到 $0$ 值之后直接割掉。具体的，在 $L/R$ 初始化的时候，当得到 $0$ 的时候直接结束并把值设为当前的 $l/r$。

时间复杂度 $O(n^2)$，写得比较丑，还有很多优化空间。

```cpp
#include<bits/stdc++.h>
#define int long long
#define inf 0x3f3f3f3f3f3f3f3fLL
#define endl '\n'
using namespace std;
const int N=5005,mod=1e9+7;
int t,T,n,a[N],b[N],c[N],s[N],f[N],L[N],R[N],sum[N],h[N][N][2],hh[N][N][2],mul[N],inv_c[N],inv_mul[N];
int qpow(int a,int b){
	int s=1;
	while(b){
		if(b&1) s=s*a%mod;
		a=a*a%mod,b>>=1;
	}
	return s;
}
int cost(int l,int r){
	if(min(r,L[l])<max(l,R[r])) return -inf;
	int w=s[r]-s[l-1];
	if(!w) return sum[r]-sum[l-1];
	if(w>0) return sum[r]-sum[l-1]-h[max(l,R[r])][min(L[l],r)][1];
	return sum[r]-sum[l-1]-h[max(l,R[r])][min(r,L[l])][0];
}
int solve1(){
	memset(f,-inf,sizeof(f));
	f[0]=0;
	for(int i=1;i<=n;++i) for(int j=1;j<=i;++j) f[i]=max(f[i],f[j-1]+cost(j,i));
	return f[n];
}
int COST(int l,int r){
	if(min(r,L[l])<max(l,R[r])) return 0;
	int w=s[r]-s[l-1];
	if(!w) return mul[r]*inv_mul[l-1]%mod;
	if(w>0) return mul[r]*inv_mul[l-1]%mod*hh[max(l,R[r])][min(L[l],r)][1]%mod;
	return mul[r]*inv_mul[l-1]%mod*hh[max(l,R[r])][min(r,L[l])][0]%mod;
}
int solve2(){
	memset(f,0,sizeof(f));
	f[0]=1;
	for(int i=1;i<=n;++i) for(int j=1;j<=i;++j) f[i]=(f[i]+f[j-1]*COST(j,i))%mod;
	return f[n];
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>t>>T;
	while(T--){
		cin>>n;
		for(int i=1;i<=n;++i) cin>>a[i];
		for(int i=1;i<=n;++i) cin>>b[i],sum[i]=sum[i-1]+b[i];
		mul[0]=inv_mul[0]=1;
		for(int i=1;i<=n;++i) cin>>c[i],inv_c[i]=qpow(c[i],mod-2),mul[i]=mul[i-1]*c[i]%mod,inv_mul[i]=qpow(mul[i],mod-2);
		for(int i=1;i<=n;++i){
			s[i]=s[i-1];
			if(i&1) s[i]+=a[i];
			else s[i]-=a[i];
		}
		memset(h,inf,sizeof(h));
		for(int l=1;l<=n;++l){
			h[l][l][l&1]=b[l];
			for(int r=l+1;r<=n;++r){
				h[l][r][r&1]=min(h[l][r-1][r&1],b[r]);
				h[l][r][r-1&1]=h[l][r-1][r-1&1];
			}
		}
		memset(hh,0,sizeof(hh));
		for(int l=1;l<=n;++l){
			hh[l][l][l&1]=inv_c[l];
			for(int r=l+1;r<=n;++r){
				hh[l][r][r&1]=(hh[l][r-1][r&1]+inv_c[r])%mod;
				hh[l][r][r-1&1]=hh[l][r-1][r-1&1];
			}
		}
		for(int l=1;l<=n;++l){
			L[l]=l;
			int res=a[l];
			for(int r=l+1;r<=n;++r){
				if(res>a[r]){
					L[l]=r-1;
					break;
				}
				res=a[r]-res;
				if(r==n||!res){
					L[l]=r;
					break;
				}
			}
		}
		for(int r=n;r;--r){
			R[r]=r;
			int res=a[r];
			for(int l=r-1;l;--l){
				if(res>a[l]){
					R[r]=l+1;
					break;
				}
				res=a[l]-res;
				if(l==1||!res){
					R[r]=l;
					break;
				}
			}
		}
		cout<<solve1()<<' '<<solve2()<<endl;
	}
	return 0;
}
```

---

## 作者：Monomial (赞：1)

首先可以想到一个暴力的做法。我们考虑将一个连续段缩到一个位置上。先去枚举区间，然后枚举缩的位置。那么缩的过程就是从两边往中间不断地做修改，于是可以在 $\mathcal{O}(n)$ 预处理之后 $\mathcal{O}(1)$ 判断一个区间是否可以缩到一个点上。对于缩到的数是 $0$ 的情况，需要特殊处理。处理完区间之后再做一次 DP，可以做到 $\mathcal{O}(n^3)$ 的复杂度。

接下来，考虑优化这个做法。容易发现最后缩完后的值是 $\pm \sum\limits_{i=l}^{r} (-1)^{i-l}a_{i}$，那么我们可以判断出缩完后的数位置的奇偶性。同时我们要判断哪些位置可以被缩到，这就是一段合法前缀和一段合法后缀的并，$F$ 和 $G$ 值分别用 ST 表和前缀和维护即可。此时依然需要特判缩完是 $0$ 的情况。

这样可以做到复杂度 $\mathcal{O}(n^2)$。

[代码](https://www.luogu.com.cn/paste/jdofzvs8)。

---

## 作者：DerrickLo (赞：0)

考虑这个操作是在干什么，发现本质上就是选了一个区间 $[l,r]$ 和一个数 $x$，然后把 $[l,x)$ 从左往右操作，把 $(x,r]$ 从右往左操作，最后 $[l,r]$ 中除了 $x$ 的数都归为 $0$。那么全部操作就是把这个序列分成若干个区间，然后每个区间合并到某一个位置上。那我们先处理出 $r_i$ 表示从 $i$ 开始往右操作第一个 $j$ 满足对 $[i,j]$ 操作完后 $a_j>a_{j+1}$ 的地方，或者操作完 $[i,j]$ 使得 $a_j=0$ 的地方，$l_i$ 类似，只是换成从 $i$ 开始往左操作，那么一个区间 $[x,y]$ 能合并到的位置就是 $[l_y,r_x]$。再观察一下合并到的位置有什么性质：显然区间 $[x,y]$ 中与合并到的位置 $z$ 同奇偶的位置对 $a_z$ 的贡献是正的，不同奇偶的位置对 $a_z$ 的贡献是负的，那么也就是说 $[x,y]$ 中与 $z$ 同奇偶的位置的和需要 $\ge$ 与 $z$ 不同奇偶的位置的和。不难发现以上两个条件就是充要的。**为什么这样是不重不漏的？因为如果我们将一段数从一个区间移动到另一个区间，而选取的位置和位置上的数不变，那么这一段数奇数位置上的和就必然等于偶数位置上的和，而考虑我们的 $l_i$ 与 $r_i$ 的定义，可以发现这种情况是不存在的。**

两问都可以使用 dp。记 $f_i$ 表示对于 $[1,i]$ 第一问的答案，$g_i$ 表示对于 $[1,i]$ 第二问的答案，那么转移就是枚举 $j$ 表示上一个区间的终点，然后这一个区间是 $[j+1,i]$，如果暴力枚举合并到的位置可以做到 $\mathcal O(n^3)$，优化非常简单，对于第一问直接预处理区间最小值，第二问预处理前缀逆元和即可。时间复杂度 $\mathcal O(n^2)$。

```cpp
#include<bits/stdc++.h>
#define mod 1000000007
#define int long long
using namespace std;
int t,n,a[5005],b[5005],c[5005],f[5005],f1[5005][5005],f2[5005][5005],r[5005],l[5005],g[5005],s1[5005],s2[5005],s3[5005],s4[5005],s5[5005],s6[5005],inv[5005],inv2[5005];
int ksm(int a,int b){
	int res=1;
	while(b){
		if(b&1)res=res*a%mod;
		a=a*a%mod,b>>=1;
	}
	return res;
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>t>>t;
	while(t--){
		cin>>n,s4[0]=inv2[0]=1;
		for(int i=1;i<=n;i++)cin>>a[i];
		for(int i=1;i<=n;i++)cin>>b[i],s3[i]=s3[i-1]+b[i];
		for(int i=1;i<=n;i++)cin>>c[i],s4[i]=s4[i-1]*c[i]%mod,inv[i]=ksm(c[i],mod-2),inv2[i]=ksm(s4[i],mod-2);
		for(int i=1;i<=n;i++)s1[i]=s1[i-1]+(i%2==1)*a[i];
		for(int i=1;i<=n;i++)s2[i]=s2[i-1]+(i%2==0)*a[i];
		for(int i=1;i<=n;i++)s5[i]=(s5[i-1]+(i%2==1)*inv[i])%mod;
		for(int i=1;i<=n;i++)s6[i]=(s6[i-1]+(i%2==0)*inv[i])%mod;
		memset(f,-0x3f,sizeof f),memset(g,0,sizeof g),f[0]=0,g[0]=1;
		for(int i=1;i<=n;i++){
			int now=a[i];r[i]=l[i]=i;
			for(int j=i+1;j<=n;j++){
				if(now>a[j])break;
				now=a[j]-now,r[i]=j;
				if(now==0)break;
			}
			now=a[i];
			for(int j=i-1;j;j--){
				if(now>a[j])break;
				now=a[j]-now,l[i]=j;
				if(now==0)break;
			}
		}
		for(int i=1;i<=n;i++)f1[i][i-1]=f2[i][i-1]=1e18;
		for(int i=1;i<=n;i++)for(int j=i;j<=n;j++){
			f1[i][j]=f1[i][j-1],f2[i][j]=f2[i][j-1];
			if(j&1)f1[i][j]=min(f1[i][j],b[j]);
			else f2[i][j]=min(f2[i][j],b[j]);
		}
		for(int i=1;i<=n;i++)for(int j=0;j<i;j++){
			int x=max(l[i],j),y=min(r[j+1],i),p=s1[i]-s1[j],q=s2[i]-s2[j];
			if(p>q){
				if(x<=y)f[i]=max(f[i],f[j]+s3[i]-s3[j]-f1[x][y]),g[i]=(g[i]+g[j]*s4[i]%mod*inv2[j]%mod*(s5[y]-s5[x-1]+mod))%mod;
			}
			else if(p<q){
				if(x<=y)f[i]=max(f[i],f[j]+s3[i]-s3[j]-f2[x][y]),g[i]=(g[i]+g[j]*s4[i]%mod*inv2[j]%mod*(s6[y]-s6[x-1]+mod))%mod;
			}
			else if(x<=y)f[i]=max(f[i],f[j]+s3[i]-s3[j]),g[i]=(g[i]+g[j]*s4[i]%mod*inv2[j])%mod;
		}
		cout<<f[n]<<" "<<g[n]<<"\n";
	}
}
```

---

## 作者：Coffins (赞：0)

首先考察操作的性质。

我们只保留会改变序列的操作，然后把相关的一组操作放在一起，那么我们会知道每组操作一定是从两边往中间操作到某个点上，证明显然可以反证一下。

那我们考虑一段序列 $t_1,t_2,...,t_k$ 在什么时候可以变成 $0,0,...,t_c-(t_{c-1}-t_{c-2}+t_{c-3}-...)-(t_{c+1}-t_{c+2}+t_{c+3}-...),...0,0$。

显然只需要保证从 $1$ 操作到 $c-1$ 是合法的，$k$ 操作到 $c+1$ 是合法的，最终剩下唯一的那个数字大于 0 即可。

于是我们考虑固定区间 $(i,j)$，那么显然我们可以通过预处理得到 $i$ 向后最远能操作到的位置 $r$ 以及 $j$ 向前最远能操作到的位置 $l$，我们不妨设 $s=a_j-a_{j-1}+a_{j-2}-...$，于是我们可以知道当 $s=0$ 且 $l\le r$ 时，区间可以被删空。当 $s>0$ 且 $l\le r$ 时可以只剩下满足 $k\in [l,r],k \bmod 2=j \bmod 2$ 的任意一个 $k$ 位置的数，$s<0$ 同理。

于是直接 dp 就可以完成第一问，复杂度 $O(n^2)$。

接下来第二问的话问题在于会算重。

注意到，我们把所有没有删空的 case 的一段可以分离出来的能直接删空的前缀和后缀分离出来，然后把所有相邻的删空的 case 的操作合并成同一段操作，这样得到的操作序列组是唯一的。

感性理解就是想让一个操作过剩余位置的数不变的话就要同时修改操作区间的两个端点，于是调整之后总有位置会变成 0 或从 0 变回去。

于是就可以直接 dp。

但是还有一个问题，我们要求出有哪些区间可以通过若干组全删操作来删空，这一部分直接做是 $O(n^3)$ 的。

考场上比较懒，直接 bitset 冲刺，结果真过了，跑的飞快，最慢点 1.9s。

于是最终复杂度 $O(\frac{n^3}w)$，跑的比一些 $O(n^2\log n)$ 快，绷不住了。
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
const int p=1e9+7;
const int N=5005;
const ll inf=1e18+7;
int n,o;ll a[N],b[N],c[N];
int p1[N],p2[N],p3[N],p4[N];
ll f1[N][N],f2[N][N];
bitset<N> g[N];
ll mn[2][N][N],pr[2][N];
ll pc[N],ic[N],pb[N];
ll ksm(ll a,ll b)
{
    ll ans=1;while(b)
    {
        if(b&1)ans=ans*a%p;
        a=a*a%p;b>>=1;
    }return ans;
}ll h[N][2];
void solve()
{
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++)cin>>b[i];
    for(int i=1;i<=n;i++)cin>>c[i];
    for(int i=1;i<=n;i++)
    {
        ll sum=0;p1[i]=n;
        for(int j=i;j<=n;j++)
        {
            sum=a[j]-sum;if(sum<0)
            {p1[i]=j-1;break;}
        }sum=0;p3[i]=n;
        for(int j=i;j<=n;j++)
        {
            sum=a[j]-sum;if(sum<=0)
            {p3[i]=j-1;break;}
        }
    }for(int i=n;i>=1;i--)
    {
        ll sum=0;p2[i]=1;
        for(int j=i;j>=1;j--)
        {
            sum=a[j]-sum;if(sum<0)
            {p2[i]=j+1;break;}
        }sum=0;p4[i]=1;
        for(int j=i;j>=1;j--)
        {
            sum=a[j]-sum;if(sum<=0)
            {p4[i]=j+1;break;}
        }
    }pc[0]=ic[0]=1;
    for(int i=1;i<=n;i++)
    {
        pb[i]=pb[i-1]+b[i];
        pc[i]=pc[i-1]*c[i]%p;
        ic[i]=ic[i-1]*ksm(c[i],p-2)%p;
        pr[0][i]=pr[0][i-1];
        pr[1][i]=pr[1][i-1];
        pr[i&1][i]=(pr[i&1][i]+ksm(c[i],p-2))%p;
        mn[0][i][i-1]=mn[1][i][i-1]=inf;
        for(int j=i;j<=n;j++)
        {
            mn[0][i][j]=mn[0][i][j-1];
            mn[1][i][j]=mn[1][i][j-1];
            mn[j&1][i][j]=min(mn[j&1][i][j],b[j]);
        }
    }
    for(int i=1;i<=n;i++)
    {
        ll sum=0;for(int j=i;j<=n;j++)
        {
            f1[i][j]=-inf;
            f2[i][j]=g[i][j]=0;
            sum=a[j]-sum;
            int l=max(p2[j],i),r=min(p1[i],j);
            if(l>r)continue;
            if(sum==0){g[i][j]=1;continue;}
            int c=j&1;if(sum<0)c^=1;
            f1[i][j]=pb[j]-pb[i-1]-mn[c][l][r];
            l=max(l,p4[j]),r=min(r,p3[i]);
            if(l>r)f2[i][j]=0;
            else f2[i][j]=pc[j]*ic[i-1]%p
            *(pr[c][r]+p-pr[c][l-1])%p;
        }
    }for(int k=1;k<n;k++)
    for(int i=1;i<=n;i++)
    if(g[i][k])g[i]|=g[k+1];
    for(int i=0;i<=n;i++)h[i][0]=h[i][1]=-inf;
    h[0][1]=0;for(int i=1;i<=n;i++)
    {
        ll x=max(h[i-1][1],h[i-1][0]),y=h[i-1][1];
        for(int j=i;j<=n;j++)
        {
            h[j][1]=max(h[j][1],x+f1[i][j]);
            if(g[i][j])h[j][0]=max(h[j][0],y+pb[j]-pb[i-1]);
        }
    }cout<<max(h[n][0],h[n][1])<<' ';
    for(int i=0;i<=n;i++)h[i][0]=h[i][1]=0;
    h[0][1]=1;for(int i=1;i<=n;i++)
    {
        ll x=(h[i-1][1]+h[i-1][0])%p,y=h[i-1][1];
        for(int j=i;j<=n;j++)
        {
            h[j][1]=(h[j][1]+x*f2[i][j])%p;
            if(g[i][j])h[j][0]=(h[j][0]+y*pc[j]%p*ic[i-1])%p;
        }
    }cout<<(h[n][0]+h[n][1])%p<<'\n';
}
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int t;cin>>o>>t;while(t--)solve();return 0;
}

```

---

## 作者：Erine (赞：0)

暴论：感觉这个题第二问比 d2t2 困难一点！可能是我数数水平不行、我恨数数.png

首先就是做一次操作 $(i,i+1)$ 之后 ，$i$ 和 $i+1$ 至少有一个变成了 $0$。不妨 $i$ 变成了 $0$，那么显然之后的 $(i-1,i)$ 操作全部没有意义，相当于在 $(i-1,i)$ 中间扔了一个板作为分界点。

既然有“分界点”这种东西的存在，我们就可以将序列分成几段。考虑如果一段 $[l, r]$ 不存在分界点意味着什么：第一次操作必然在两端，且操作后必然是端点变成 $0$，然后归纳下去，我们发现这一段最后会形如一堆 $0$，最后中间扔了一个 $\neq 0$ 或者全是 $0$。

考虑最后剩下的那个数会是什么？进行简单的手模可以发现其绝对值是固定的，与区间奇数位和减偶数位和的绝对值相等。而且最后得到的值不能是负数，所以发现这个数就是固定的；接着考虑其可能的位置，发现其取正或者负与其位置的奇偶性有关。

还要考虑区间剩下的位置都能被消为 $0$。对每个点预处理出往右一直操作最远能到哪儿，左边同理。那么区间合法的条件是左端点向右，右端点向左，最终右端点小于等于左端点，得到的这个区间中所有满足某个奇偶性条件的位置就是非 $0$ 数可以停留的点。

总结一下一个已经判定合法的区间可能的情况：

- 奇数位之和等于偶数位之和：只能是全 $0$。
- 奇数位之和不等于偶数位之和：这个差的绝对值会停留在一段子区间的全部奇或者偶位置上。

于是你可以平方做出来第一问。但是对于第二问，你显然会算重，然后就倒闭。那咋办。

很神奇的事情是，我们在算每个点往左往右最远到哪的时候，如果当前点恰好被消成了 $0$ 就立刻停止，改成这样，第二问就不会算重了。

为什么？

一个操作方式对应一个最终序列是显然的。

并且，每个可能的最终序列都会对应唯一的一个操作方式。这是因为我们已经将区间拆成了最短的，所以每个合法序列都存在唯一的每次拆最短的操作区间的操作形式。

我们证明了二者构成双射，于是可以愉快地 $\Theta(n^2)$ dp 解决此题。

```cpp
void solve() {
	n = read();
	rep(i, 1, n) a[i] = read(), s[i] = s[i - 1] + (i & 1 ? -1 : 1) * a[i];
	rep(i, 1, n) b[i] = read(), sb[i] = sb[i - 1] + b[i];
	wpc[0] = ipc[0] = ic[0] = 1; rep(i, 1, n) c[i] = read(), wpc[i] = wpc[i - 1] * c[i] % mod, ic[i] = power(c[i], mod - 2), ipc[i] = ipc[i - 1] * ic[i] % mod;
	rep(i, 1, n) {
		rep(j, 1, n) tmp[j] = a[j];
		for (l[i] = i; l[i] < n && tmp[l[i]] && tmp[l[i]] <= tmp[l[i] + 1]; ++l[i]) tmp[l[i] + 1] -= tmp[l[i]];
		rep(j, 1, n) tmp[j] = a[j];
		for (r[i] = i; r[i] > 1 && tmp[r[i]] && tmp[r[i]] <= tmp[r[i] - 1]; --r[i]) tmp[r[i] - 1] -= tmp[r[i]];
	}
	rep(l, 1, n) {
		mn[l][l - 1][0] = mn[l][l - 1][1] = inf;
		sm[l][l - 1][0] = sm[l][l - 1][1] = 0;
		rep(r, l, n) {
			mn[l][r][0] = mn[l][r - 1][0];
			mn[l][r][1] = mn[l][r - 1][1];
			mn[l][r][r & 1] = min(mn[l][r][r & 1], b[r]);
			sm[l][r][0] = sm[l][r - 1][0];
			sm[l][r][1] = sm[l][r - 1][1];
			(sm[l][r][r & 1] += ic[r]) %= mod;
		}
	}
	f[0] = 0, g[0] = 1;
	rep(i, 1, n) {
		f[i] = -inf, g[i] = 0;
		rep(j, 1, i) {
			if (l[j] < r[i]) continue;
			int x = s[i] - s[j - 1], sg = x < 0;
			if (!x) {
				f[i] = max(f[i], f[j - 1] + sb[i] - sb[j - 1]);
				(g[i] += g[j - 1] * wpc[i] % mod * ipc[j - 1] % mod) %= mod;
			} else {
				f[i] = max(f[i], f[j - 1] + sb[i] - sb[j - 1] - mn[max(j, r[i])][min(i, l[j])][sg]);
				(g[i] += g[j - 1] * wpc[i] % mod * ipc[j - 1] % mod * sm[max(j, r[i])][min(i, l[j])][sg] % mod) %= mod;
			}
		}
	}
	write(f[n]), pc(' '), write(g[n]), pc('\n');
}
```

---

## 作者：yzy4090 (赞：0)

[题](https://www.luogu.com.cn/problem/P13272)。  
先考虑第一小问。对于一个操作序列，可以将所有没被操作的两个位置间的缝隙分开，分成若干段。可以发现由于每次操作必会产生至少一个 $0$，每一段必须是合并到中间，然后段中最多仅有一个位置在操作后仍为非 $0$ 值。  
由于支持 $\mathcal O\!\left(n^2\right)$ 的时间复杂度，考虑将不交的区间合并起来，即设 $dp_i$ 为前 $i$ 个数可以达到的最大权值，转移式是简单的。那么首先需要判断哪些区间是合法的，即可以操作成最多一个非 $0$ 值，再计算它们可以得到的最大值。  
可以观察到一个区间中可以操作成非 $0$ 值的位置要么是一个区间，要么是一个区间中所有下标为奇数或偶数的位置。下面考虑证明。  
首先说明可能操作成非 $0$ 值的位置下标的奇偶性。考虑序列 $[a,b,c,d,e]$，忽略产生负数的情况，那么如果令第一个位置最终为非 $0$ 值，则其值为 $a-(b-(c-(d-e)))=a-b+c-d+e$；令第三个位置最终为非 $0$ 值，则其值为 $c-b+a-d+e$，两者完全相同。进一步可以发现所有奇数格会保留奇数格的和减去偶数格的和，所有偶数格会保留偶数格的和减去奇数格的和。由于两者互为相反数，要么仅有一个大于 $0$ ，此时仅有一些奇数位置或一些偶数位置可能成为最终的非 $0$ 值；要么均为 $0$ ，此时奇数和偶数位置均可能成为最终的非 $0$ 值。  
但奇偶性仅仅是必要条件。考虑序列 $[1,7,10]$，第三个位置可以成为非 $0$ 值，但第一个位置不可以。这取决于从左侧开始一直向右操作，以及反过来从右侧开始向左操作是否均可以到达，这显然是一个区间的形式，可以预处理从 $i$ 开始一直向右操作直到不能操作的位置 $lp_i$，以及与之对应的 $rp_i$ 得到。  
对于求最大值，仅需要用全局减去可能成为非 $0$ 值的位置的 $b$ 的最小值即可。于是一个区间的值可以以 $\mathcal O(1)$ 时间复杂度计算得出，第一小问就这样被解决了。  
对于第二小问，无非就是要求转移不重复，那么考虑什么时候上面的转移会重复。这出现在一些具有相邻相同值的序列中，如 $[1,1,1,1]$，按照上面算法有两种区间划分方式使得序列变为 $[0,0,0,0]$，分别为 $[1,2],[3,4]$ 和 $[1,4]$，但它们本质相同，因此上述算法会错误地统计两次 $[0,0,0,0]$。解决方法是在预处理上面提到的 $lp_i$ 和 $rp_i$ 时在遇到 $0$ 时立即停止扩展，这样在有多解的情况下会优先选择划分区间小而总数多的，也就解决了转移重复的问题。  
至此，用 $\mathcal O\!\left(n^2\right)$ 的时间复杂度做完了本题。其实空间可以做到 $\mathcal O(n\log n)$ 的，代码写的空间 $\mathcal O\!\left(n^2\right)$。[code](https://www.luogu.com.cn/paste/wtn3s11c)。

---


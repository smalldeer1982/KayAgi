# 50 年后的我们

## 题目背景

YSGHYYDS

## 题目描述

YSGH 给一场比赛出了 $n$ 道题，第 $i$ 道题的难度为 $d_i$，价值为 $c_i$。

有 $m$ 个可能参赛的选手。第 $i$ 个选手有 $p_i$ 的概率会参加比赛。若第 $i$ 个选手参加比赛，则该选手会恰好通过难度在 $l_i$ 到 $r_i$ 之间（包括 $l_i$ 和 $r_i$）的所有题目。

比赛组委会最终给 YSGH 的奖金为所有题中，有选手通过的题的价值之和的 $k$ 次幂。特别地，我们定义 $0$ 的 $0$ 次幂等于 $1$。

YSGH 想让你帮他求出奖金的期望。

令 $P=998244353$，设一个有理数 $x$ 表示成最简分数的形式为 $\frac{a}{b}$，若 $\gcd(b,P)=1$，则存在唯一的整数 $c$（$0 \le c < P$）满足 $b c \equiv a \pmod{P}$，我们称 $x$ 在模 $P$ 意义下的值为 $c$。

可以证明，在仅给出 $p_i$ 模 $P$ 意义下的值时，答案仍然在模 $P$ 意义下唯一存在。

## 说明/提示

**【样例解释 \#1】**

该样例满足特殊性质 A。

第一个人若参赛，可以通过第 $1,2,5$ 题。

第二个人若参赛，可以通过第 $3$ 题。

所以 YSGH 的奖金期望为 $(412+685+121)\times 2\times (1-3)+544\times (1-2)\times 3+(412+685+121+544)\times 2\times 3\equiv 4068\pmod{P}$。

---

**【数据范围】**

**本题采用捆绑测试。**

对于 $100\%$ 的数据，$1\le n\le 400$，$0\le k\le 400$，$1\le m\le 10^5$，$1\le d_i\le 10^9$，$1\le l_i\le r_i\le 10^9$，$0\le c_i,p_i < 998244353$。

各 Subtask 的特殊限制与分值如下：

| 测试包编号 | $n\le $ | $k\le $ | 其他限制 | 分值 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $400$ | $1$ | 特殊性质 A | $5$ |
| $2$ | $400$ | $1$ | 无 | $6$ |
| $3$ | $400$ | $2$ | 特殊性质 A | $7$ |
| $4$ | $400$ | $2$ | 无 | $8$ |
| $6$ | $18$ | $100$ | 特殊性质 A | $3$ |
| $5$ | $18$ | $100$ | 无 | $15$ |
| $7$ | $100$ | $100$ | 特殊性质 A | $9$ |
| $8$ | $100$ | $100$ | 无 | $16$ |
| $9$ | $400$ | $400$ | 特殊性质 A | $10$ |
| $10$ | $400$ | $400$ | 无 | $21$ |

特殊性质 A：对于任意 $1\le i < j\le M$，都有 $[l_i,r_i]\cap [l_j,r_j]=\varnothing$。

## 样例 #1

### 输入

```
5 2 1
346 412
464 685
895 544
976 322
612 121
346 712 2
850 932 3
```

### 输出

```
4068
```

## 样例 #2

### 输入

```
5 2 2
346 412
464 685
895 544
976 322
612 121
233 749 798465123
698 985 151455772
```

### 输出

```
105133973```

# 题解

## 作者：加藤惠 (赞：11)

这里是验题人题解。

权值和的 $k$ 次方乘法分配律展开，可以看做是选 $k$ 个位置（可重），贡献是这些位置的权值乘积再乘上这些位置都被覆盖的概率。

令第 $i$ 个位置被选中次数为 $c_i$，那么对于这些选中位置的排列方案数是 $\frac{k!}{\prod c_i!}$。

于是我们可以得到一个 $O(n^4)$ 的 DP，令 $f_{i,j,k}$ 表示前 $i$ 个位置已经选了 $j$ 个，选择的区间最远还能覆盖到 $k$ 的答案。

转移需要对区间和球分别考虑。

考虑容斥去掉第三维，选中位置都被覆盖的概率相当于 $\sum_{T} (-1)^{T} p_T$，其中 $p_T$ 表示 $T$ 集合中的点一定没被覆盖的概率。

首先我们能发现容斥钦定的不能被覆盖的位置和其他位置两部分是独立的，于是我们可以分别 DP 然后合并。

后者直接 $O(n^3)$ DP 即可。

对于前者，设至少被选中一次的位置从小到大依次是 $x_0=0,x_1,x_2,\dots,x_{k'}$，这些位置一定不能被覆盖相当于对于 $i\in[0,k')$，左端点在 $(x_i,x_{i+1}]$，右端点大于等于 $x_{i+1}$ 的区间不能选，剩下任意，可以发现这只和相邻两个点的位置有关，于是我们可以 DP 了。

令 $f_{i,j}$ 表示前 $i$ 个位置钦定了 $j$ 个位置不能选，并且 $i$ 一定至少被选中了一次。

转移考虑枚举上一个选的位置以及当前位置选了几个：
$$
f_{i,j}=\sum_{l\le j}\sum_{k<i} f_{k,j-l}\times \frac{a_i^l}{l!}\times\frac {S_{i,i}}{S_{k,i}}
$$
其中 $S_{i,j}$ 表示右端点大于等于 $i$，左端点小于等于 $j$ 的区间都不选的概率。

这个转移可以前缀和优化，时间复杂度 $O(n^3)$。

---

## 作者：Sol1 (赞：7)

给个不一样的做法。

考虑到“被过的题”的限制是覆盖它的区间中至少有一个被选，这个很难受。自然的想法是转换成算“没被过的题”，限制是覆盖它的区间中一个都不能选，这个就舒服多了。

但是求这个有啥用呢？

考虑拆一下式子，设所有题的价值和为 $S$：

$$\begin{aligned}&\mathbb E(w({\rm covered})^k)\\=\ &\mathbb E((S-w({\rm uncovered}))^k)\\=\ &\mathbb E\left(\sum_{i=0}^k(-1)^{k-i}S^iw({\rm uncovered})^{k-i}\dbinom{k}{i}\right)\\=\ &\sum_{i=0}^k\dbinom{k}{i}(-1)^{k-i}S^i\mathbb E\left(w({\rm uncovered})^{k-i}\right)\end{aligned}$$

所以只要能对于所有 $1\leq k\leq K$，求出没人过的题的价值和的 $k$ 次方的期望，就可以在线性时间内还原有人过的题的价值和的 $K$ 次方的期望。

下面考虑前缀 DP，设 $f_{i,j}$ 为考虑到前 $i$ 个题，第 $i$ 个题没人过（强制结尾），没人过的题的价值和的 $j$ 次方的期望。

转移直接枚举上一个没人过的题 $k<i$，处理 $j$ 次幂还可以考虑二项式定理展开：

$$\begin{aligned}&\mathbb E((a+b)^k)\\=\ &\mathbb E\left(\sum_{i=0}^ka^ib^{k-i}\dbinom{k}{i}\right)\\=\ &\sum_{i=0}^k\dbinom{k}{i}\mathbb E(a^ib^{k-i})\end{aligned}$$

在转移中，$b$ 是常量 $c_i$。所以转移式如下：

$$f_{i,j}=\sum_{k<i}\sum_{x\leq j}f_{k,x}\dbinom{j}{x}c_i^{j-x}P(k+1,i)$$

其中 $P(l,r)$ 的含义是 $[l,r-1]$ 中所有元素被包含于 $[l,r-1]$ 中的区间覆盖，且 $r$ 没有被任何左端点在 $[l,r]$ 之间，右端点在 $[r,n]$ 之间的区间覆盖的概率。

首先考察如何快速计算 $P(l,r)$。

容易观察到 $P(l,r)$ 的定义割裂为两部分，结果是两部分的结果相乘，因此分别考虑两部分。前一部分 $P_1(l,r)$ 可以容斥：如果没有被完全覆盖，枚举第一个没被覆盖的位置 $k$。那么前面被完全覆盖的概率是 $P_1(l,k-1)$。$k$ 没有被覆盖的概率是所有跨过它的区间的不出现的概率乘起来（记这个值是 $v_k$）。后面长啥样都没有关系。

所以可以如下递推：

$$P_1(l,r)=1-\sum_{k=l}^{r} P_1(l,k-1)v_k$$

边界是 $P_1(l,l-1)=1$。

$l$ 固定时，$v$ 的变化相当于区间乘，可以搞个商分序列。但是注意到还会乘 $0$，所以还要再搞个差分序列维护被推成 $0$ 的位置。

这样可以在 $l$ 固定时 $O(n^2+m)$ 计算所有 $r$ 的 $P_1(l,r)$ 值。

因此计算 $P_1(l,r)$ 可以做到 $O(n^3+nm)$。

另一部分是个显然的二维后缀积，也可以快速计算。

因此现在可以快速计算 $P(l,r)$。

然后是 DP 的转移，做一个换序求和：

$$f_{i,j}=\sum_{x\leq j}\dbinom{j}{x}c_i^{j-x}\sum_{k<i}f_{k,x}P(k+1,i)$$

当 $i$ 固定的时候，可以预先计算

$$s_x=\sum_{k<i}f_{k,x}P(k+1,i)$$

这一部分的复杂度是 $O(nk)$。

然后代回到上面的式子里面就是

$$f_{i,j}=\sum_{x\leq j}\dbinom{j}{x}c_i^{j-x}s_x$$

这样转移的复杂度就下降到了 $O(nk+k^2)$。

总复杂度 $O(n^3+n^2k+nk^2)$，足以通过。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

inline int qread() {
	register char c = getchar();
	register int x = 0, f = 1;
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + c - 48;
		c = getchar();
	}
	return x * f;
}

const long long mod = 998244353;
pair <int, int> q[405];
int n, m, K, l[100005], r[100005], c0[405];
long long p[100005], s[405][405], c[405][405], sum, f[405][405], cov[405][405], tmp[405], tmpd[405], sf[405], pwr[405][405], inv[100005];
vector <int> adj[405];

inline long long Power(long long x, long long y) {
	long long ans = 1;
	while (y) {
		if (y & 1) ans = ans * x % mod;
		x = x * x % mod;
		y >>= 1;
	}
	return ans;
}

inline void Read() {
	n = qread(); m = qread(); K = qread();
	for (int i = 1;i <= n;i++) {
		q[i].first = qread(); q[i].second = qread();
		sum = (sum + q[i].second) % mod;
	}
	q[n + 1] = make_pair(1000000001, 0);
	sort(q + 1, q + n + 1);
	for (int i = 1;i <= m;i++) {
		l[i] = qread();
		r[i] = qread();
		p[i] = qread();
		l[i] = lower_bound(q + 1, q + n + 1, make_pair(l[i], 0)) - q;
		r[i] = lower_bound(q + 1, q + n + 1, make_pair(r[i] + 1, 0)) - q - 1;
		inv[i] = Power((mod + 1 - p[i]) % mod, mod - 2);
	}
}

inline void Prefix() {
	for (int l = 1;l <= n + 2;l++) {
		for (int r = 1;r <= n + 2;r++) s[l][r] = 1;
	}
	for (int i = 1;i <= m;i++) {
		if (l[i] <= r[i]) s[l[i]][r[i]] = s[l[i]][r[i]] * (mod + 1 - p[i]) % mod;
	}
	for (int r = n;r >= 1;r--) {
		for (int l = 1;l <= r;l++) s[l][r] = s[l][r] * s[l][r + 1] % mod;
	}
	for (int r = n;r >= 1;r--) {
		for (int l = r;l >= 1;l--) s[l][r] = s[l][r] * s[l + 1][r] % mod;
	}
	c[0][0] = 1;
	for (int i = 1;i <= K;i++) {
		c[i][0] = 1;
		for (int j = 1;j <= i;j++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
	}
	for (int i = 1;i <= n;i++) {
		for (int j = 1;j <= n;j++) adj[j].clear();
		for (int j = 1;j <= m;j++) {
			if (l[j] >= i) adj[r[j]].push_back(j);
		}
		for (int k = 0;k <= n;k++) tmp[k] = 1;
		cov[i][i - 1] = 1;
		for (int j = i;j <= n;j++) {
			int siz = adj[j].size();
			for (int k = 0;k <= n;k++) {
				c0[k] = 0;
				tmpd[k] = 1;
			}
			for (int k = 0;k < siz;k++) {
				if (p[adj[j][k]] == 1) {
					c0[l[adj[j][k]]]++;
					c0[r[adj[j][k]] + 1]--;
				} else {
					tmpd[l[adj[j][k]]] = tmpd[l[adj[j][k]]] * (mod + 1 - p[adj[j][k]]) % mod;
					tmpd[r[adj[j][k]] + 1] = tmpd[r[adj[j][k]] + 1] * inv[adj[j][k]] % mod;
				}
			}
			for (int k = 1;k <= n;k++) {
				c0[k] += c0[k - 1];
				tmpd[k] = tmpd[k] * tmpd[k - 1] % mod;
			}
			for (int k = 1;k <= n;k++) {
				if (c0[k]) tmp[k] = 0;
				else tmp[k] = tmp[k] * tmpd[k] % mod;
			}
			cov[i][j] = 1;
			for (int k = i - 1;k < j;k++) cov[i][j] = (cov[i][j] - cov[i][k] * tmp[k + 1] % mod + mod) % mod;
		}
	}
	cov[n + 1][n] = 1;
	for (int i = 1;i <= n + 1;i++) {
		pwr[i][0] = 1;
		for (int j = 1;j <= K;j++) pwr[i][j] = pwr[i][j - 1] * q[i].second % mod;
	}
}

inline void Solve() {
	f[0][0] = 1;
	for (int i = 1;i <= n + 1;i++) {
		for (int k = 0;k <= K;k++) {
			sf[k] = 0;
			for (int ii = 0;ii < i;ii++) sf[k] = (sf[k] + f[ii][k] * s[ii + 1][i] % mod * cov[ii + 1][i - 1]) % mod;
		}
		for (int j = 0;j <= K;j++) {
			for (int k = 0;k <= j;k++) {
				f[i][j] = (f[i][j] + pwr[i][j - k] % mod * c[j][k] % mod * sf[k]) % mod;
			}
		}
	}
	long long ans = 0;
	for (int j = 0;j <= K;j++) {
		ans = (ans + Power(sum, K - j) * c[K][j] % mod * Power(mod - 1, j) % mod * f[n + 1][j]) % mod;
	}
	cout << ans << endl;
}

int main() {
	Read();
	Prefix();
	Solve();
	return 0;
}
```








---

## 作者：Owen_codeisking (赞：7)

只会计数题了.jpg

看到“有选手通过的题的价值之和的 $k$ 次幂”，先想 $k$ 次幂有什么套路。好像第二类斯特林数不太行，考虑 $k$ 次幂的组合意义。

$$(\sum x_i)^k=\sum {k\choose t_1,t_2,...,t_n}x_1^{t_1}x_2^{t_2}...x_n^{t_n},\sum t_i=k$$

这个式子可以用 $e^{x_i}$ 的生成函数理解。

特殊性质 A：因为每个区间互不影响，将每个选手真正的做题范围二分出来，这样 $m$ 最多有 $n$ 个。计数就相当于做一个卷积，$k$ 很小，可以暴力 $\mathcal{O}(k^2)$ 卷积，时间 $\mathcal{O}(nk^2)$。

没有特殊性质，我们考虑这样的卷积只能做 $n$ 次，那么肯定需要寻找一些其他方法。

平面线段并集，有一个套路，就是把线段按 $l$ 排序，然后对于延伸最远的 $r$ 记录这个多项式。如果我们关心每个数什么时候加入之和的 $k$ 次幂，每次转移的状态有 $n$ 个，不可接受。

那么我们换一个角度思考：若考虑没被算进去是哪些，$r$ 最远延伸到哪儿就不重要了。$r$ 只需满足 $<i$，而且每次的状态只有一个。

接着分类转移：

目前在位置 $i$，加进线段 $[i,r]$：

- $j<r$，$f'_j=f_j\times (1-p)$
- $j=r$，$f'_j=f_j+p\times \sum_{t<j} f_t$
- $j>r$，$f'_j=f_j$

顺便，我们在排序的时候保证 $l$ 相同 $r$ 递增，这样维护 $\sum_{t<r} f_t$ 的时候每个位置被加进入 $\mathcal{O}(n^2)$ 次，每次时间 $\mathcal{O}(k)$，时间是可以接受的。对于 $j<r$ 的部分，我们暴力在多项式上打全局乘标记，每次要操作的时候暴力下传一下。

时间 $\mathcal{O}(nk^2+n^2k)$。

算了，算了，看代码吧：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
#define d first
#define c second
const int maxn=100005;
const int maxk=405;
const int mod=998244353;
int n,m,k; pii a[maxn]; ll f[maxk][maxk],sum[maxk],mul[maxk],pw[maxk],tmp[maxk],fac[maxk],inv_fac[maxk];
struct seg { int l,r,p; } t[maxn];
inline bool operator < (const seg &a,const seg &b)
{
	if(a.l==b.l) return a.r<b.r;
	return a.l<b.l;
}
inline void pushtag(int p)
{
	for(int i=0;i<=k;i++) f[p][i]=f[p][i]*mul[p]%mod;
	mul[p]=1;
}
int main()
{
	fac[0]=fac[1]=inv_fac[0]=inv_fac[1]=1;
	for(int i=2;i<maxk;i++) fac[i]=fac[i-1]*i%mod;
	for(int i=2;i<maxk;i++) inv_fac[i]=(mod-mod/i)*inv_fac[mod%i]%mod;
	for(int i=2;i<maxk;i++) (inv_fac[i]*=inv_fac[i-1])%=mod;
	scanf("%d%d%d",&n,&m,&k);
	ll S=0;
	for(int i=1;i<=n;i++) scanf("%d%d",&a[i].d,&a[i].c),(S+=a[i].c)%=mod;
	sort(a+1,a+n+1);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&t[i].l,&t[i].r,&t[i].p);
		t[i].l=lower_bound(a+1,a+n+1,pii(t[i].l,0))-a;
		t[i].r=lower_bound(a+1,a+n+1,pii(t[i].r+1,0))-a-1;
		if(t[i].l>t[i].r) i--,m--;
	}
	if(m==0) return puts("0"),0;
	sort(t+1,t+m+1);
	for(int i=0;i<=n;i++) mul[i]=1;
	f[0][0]=1;
	for(int i=1;i<=k;i++) f[0][i]=f[0][i-1]*S%mod;
	for(int i=0;i<=k;i++) f[0][i]=f[0][i]*inv_fac[i]%mod;
	for(int i=1,j=1;i<=n;i++)
	{
		pushtag(0);
		for(int s=0;s<=k;s++) sum[s]=f[0][s];
		int lstr=i-1;
		for(;j<=m && t[j].l==i;j++)
		{
			while(lstr<t[j].r-1)
			{
				lstr++,pushtag(lstr);
				for(int s=0;s<=k;s++) (sum[s]+=f[lstr][s])%=mod;
			}
			pushtag(t[j].r);
			for(int s=0;s<=k;s++)
				(f[t[j].r][s]+=sum[s]*t[j].p)%=mod,sum[s]=sum[s]*(mod+1-t[j].p)%mod;
			for(int s=i;s<t[j].r;s++) mul[s]=mul[s]*(mod+1-t[j].p)%mod;
			mul[0]=mul[0]*(mod+1-t[j].p)%mod;
		}
		pushtag(0),pushtag(i);
		pw[0]=1;
		for(int s=1;s<=k;s++) pw[s]=pw[s-1]*(mod-a[i].c)%mod;
		for(int s=0;s<=k;s++) pw[s]=pw[s]*inv_fac[s]%mod,tmp[s]=0;
		for(int x=0;x<=k;x++)
			for(int y=0;y<=k-x;y++)
				(tmp[x+y]+=f[0][x]*pw[y])%=mod;
		for(int s=0;s<=k;s++) f[0][s]=(tmp[s]+f[i][s])%mod,f[i][s]=0;
	}
	ll ans=0;
	for(int i=0;i<=n;i++) (ans+=f[i][k])%=mod;
	printf("%lld\n",(ans*fac[k]%mod+mod)%mod);
	return 0;
}
```

---

## 作者：daniEl_lElE (赞：1)

设最终每个题是否被通过的情况为 $tag_i$。不难发现 $\sum_{i=1}^nc_itag_i=\sum_{i=1}^nc_i-\sum_{i=1}^nc_i(1-tag_i)$，即 $(\sum_{i=1}^nc_itag_i)^k=(\sum_{i=1}^nc_i-\sum_{i=1}^nc_i(1-tag_i))^k$。于是我们把通过的题价值和的 $k$ 次方转化为没通过的题价值和的 $0\sim k$ 次方。

考虑钦定一些位置不选，最后给答案的贡献。设计 $dp_{i,l}$ 表示看到 $i$ 位置不选，目前 $k$ 次方展开中有 $l$ 个位被钦定了。我们发现 $dp_{i,l}\times c_j^{l'}\times\binom{l+l'}{l}\to dp_{j,l+l'}$。然而此时我们需要保证 $j$ 不选，也就是选的人通过的题目 $\in[i+1,j-1]$。我们考虑最初钦定都不选，选出 $[i+1,j-1]$ 这一段的时候将这些数的逆元乘回来，即 $dp_{i,l}\times c_j^{l'}\times\binom{l+l'}{l}\times pre_{i+1,j-1}\to dp_{j,l+l'}$，其中 $pre_{i,j}$ 表示 $i\leq l_x\leq r_x\leq j$ 的所有 $x$ 的 $\frac{1}{1-p_x}$ 的乘积，默认 $l_x,r_x$ 均离散化过。

上述 dp 看似是四次方，其实可以通过拆分两维的转移变成三方。

最后有些 corner case，也就是 $p_i=0$，$\frac{1}{1-p_i}$ 未定义，但是这说明所有与 $[l_x,r_x]$ 有交的 $pre_{i,j}$ 均为 $0$。特殊标记一下即可。数据恨水，直接 $O(mn^2)$ 标记即可（当然显然可以通过简单的优化做到 $O(mn)$）。

总复杂度 $O(n^3+nm)$，可以通过。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
int qp(int a,int b){
	int ans=1;
	while(b){
		if(b&1) (ans*=a)%=mod;
		(a*=a)%=mod;
		b>>=1;
	}
	return ans;
}
int lsh[405],d[405],c[405],v[405];
int dp[405][405],pre[405][405],C[405][405],ppw[405],ban[405][405];
signed main(){
	for(int i=0;i<=400;i++) C[i][0]=1;
	for(int i=1;i<=400;i++) for(int j=1;j<=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
	int n,m,k; cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		cin>>d[i]>>c[i];
		lsh[i]=d[i];
	}
	sort(lsh+1,lsh+n+1);
	int t=unique(lsh+1,lsh+n+1)-lsh-1;
	int tot=0;
	for(int i=1;i<=n;i++){
		d[i]=lower_bound(lsh+1,lsh+t+1,d[i])-lsh;
		(v[d[i]]+=c[i])%=mod;
		(tot+=c[i])%=mod;
	}
	ppw[0]=1; for(int i=1;i<=k;i++) ppw[i]=ppw[i-1]*tot%mod;
	for(int i=0;i<=n+1;i++) for(int j=i-1;j<=n;j++) pre[i][j]=ban[i][j]=1;
	int pp=1;
	for(int i=1;i<=m;i++){
		int l,r,p; cin>>l>>r>>p;
		l=lower_bound(lsh+1,lsh+t+1,l)-lsh,r=upper_bound(lsh+1,lsh+t+1,r)-lsh-1;
		if(l>r) continue;
		if(p==1){
			for(int i=0;i<=t;i++){
				for(int j=l-1;j<r;j++){
					ban[i][j]=0;
				}
			}
			continue;
		}
		(pp*=(mod+1-p))%=mod;
		(pre[l][r]*=qp(mod+1-p,mod-2))%=mod;
	}
	for(int len=2;len<=t;len++){
		for(int l=1,r=len;r<=t;l++,r++){
			(pre[l][r]*=pre[l][r-1]*pre[l+1][r]%mod*qp(pre[l+1][r-1],mod-2)%mod)%=mod;
		}
	}
	for(int i=0;i<=n+1;i++) for(int j=i-1;j<=n;j++) pre[i][j]*=ban[i][j];
	for(int i=1;i<=t+1;i++) dp[i][0]=pre[1][i-1];
	for(int i=1;i<=t;i++){
		int tmp[405]; memset(tmp,0,sizeof(tmp));
		int pw[405]; pw[0]=1; for(int j=1;j<=k;j++) pw[j]=pw[j-1]*v[i]%mod;
		for(int j=0;j<=k;j++){
			for(int l=1;j+l<=k;l++){
				(tmp[j+l]+=dp[i][j]*pw[l]%mod*C[j+l][l])%=mod;
			}
		}
		for(int j=i+1;j<=t+1;j++){
			for(int l=0;l<=k;l++){
				(dp[j][l]+=tmp[l]*pre[i+1][j-1]%mod)%=mod;
			}
		}
	}
	int mul=mod-1,ans=0;
	for(int i=0;i<=k;i++){
		(mul*=(mod-1))%=mod;
		(ans+=dp[t+1][i]*C[k][i]%mod*mul%mod*ppw[k-i])%=mod;
	}
	cout<<ans*pp%mod;
	return 0;
}
```

---

## 作者：zhouyuhang (赞：1)

看上去不是很好做的问题，做法却意外地简单。

我们首先考虑一个指数级的算法：枚举题目子集 $S$，计算使 $S$ 为最终有人做出的题目集合的概率 $f(S)$，那么 $\sum _ {S} f(S) \left( \sum _ {x \in S} c_x \right) ^ k$ 就是答案。

考虑计算 $f(S)$：使用子集容斥，记 $g(S)$ 为钦定 $S$ 以外的题目都无人做出的概率，显然有 $g(S) = \sum _ {T \subseteq S} f(T)$，从而 $f(S) = \sum _ {T \subseteq S} (-1) ^ {|S| - |T|} g(T)$。而 $g(S)$ 即为所有与 $S$ 以外题目有交的难度区间 $[l, r]$ 对应的 $(1 - p)$ 的乘积。于是，我们得到了一个 $\mathcal O(2 ^ n \operatorname{poly}(n, m))$ 的做法。

进一步，有 

$$
\begin{aligned}
& \sum _ {S} f(S) \left( \sum _ {x \in S} c_x \right) ^ k \\
& = \sum _ {S} \sum _ {T} g(T) (-1) ^ {|S| - |T|} \left( \sum _ {x \in S} c_x \right) ^ k \\
& = \left[ \frac {z ^ k} {k!} \right] \sum _ {T} g(T) \sum _ {T \subseteq S} (-1) ^ {|S| - |T|} \left( \prod _ {x \in S} \exp(c_x z) \right) \\
& = \left[ \frac {z ^ k} {k!} \right] \sum _ {T} g(T)  \prod _ {x \in T} \exp(c_x z) \prod _ {x \notin T} \left(1 - \exp(c_x z) \right)  \\
& = \left[ \frac {z ^ k} {k!} \right] \exp \left( \sum _ {i = 1} ^ n c_i  z \right) \sum _ {T} g(T) \prod _ {x \notin T} \left(\exp(- c_x z) - 1 \right)
\end{aligned}
$$

于是，我们只需要计算 $\sum _ {T} g(T) \prod _ {x \notin T} \left(\exp(- c_x z) - 1 \right)$ 。注意到，$g(T)$ 的计算实际上是依赖于不在 $T$ 中的题目。因此，不难设计出如下算法：

- 将所有题目按照难度 $d_i$ 从小到大排序，并设 $d_{n + 1} = \infty$。
- 记 $F_i(z)$ 为，考虑 $[i, n]$ 的所有题目，且 $i \notin T$ 时，上式的计算结果；特别地，$F_{n + 1}(z) = 1$。
- 只需枚举下一个不在 $T$ 中的题目 $j$，就有 $F_j(z) w(i, j) \to F_i(z)$。
- 其中 $w(i, j)$ 为从 $F_j(z)$ 到 $F_i(z)$，$g(T)$ 的变化量，即所有 $l \in [0, d_i], r \in [d_i, d_j)$ 的区间 $[l, r]$ 对应的 $(1 - p)$ 的乘积（这显然可以使用扫描线维护）。
- 最后，将 $F_i(z)$ 卷上 $\left(\exp(- c_i z) - 1 \right)$。由于我们只需知道 $z ^ k$ 处的信息，因此可以将 $F_i(z)$ 从 $z ^ {k + 1}$ 处截断。
- 答案即为 $\left[ \frac {z ^ k} {k!} \right] \exp \left( \sum _ {i = 1} ^ n c_i z \right) \sum _ {i = 1} ^ {n + 1} F_i(z)$。

分析这一算法的复杂度，可以发现需要进行 $\mathcal O(n ^ 2)$ 次多项式加法和 $\mathcal O(n)$ 次多项式乘法，结合扫描线部分 $\mathcal O((m + n ^ 2) \log m)$ 的复杂度，总复杂度为 $\mathcal O(nk(n + k) + (m + n ^ 2) \log m)$，直接实现即可通过。

---

## 作者：forest114514 (赞：0)

### P7483 50 年后的我们

感觉很不错的题啊。

首先期望的 $k$ 次幂一般有两种常见的处理方式：转下降幂和考虑组合意义，这里我们考虑后者。

组合意义就是选 $k$ 次题每次都选到通过的题的概率，假设不管顺序最后乘上多重集组合数就对了。

首先 $O(n^2k^2)$ 的 DP 是比较显然的，设 $f_{i,j,k}$ 表示考虑到第 $i$ 道题，选了 $j$ 次题，通过的题最远到 $k$ 的权值和，两维可以分开转移，对每个左端点预处理出发的线段最远覆盖到某个位置的概率。

注意到被线段覆盖的点要考虑很多线段，没被覆盖的点只关心所有的经过的线段都没被选，考虑容斥一下，钦定选某些没有被覆盖的点，假设钦定选 $i$ 个有序的没覆盖的点的方案为 $g(i)$ 答案为 $f(k)$，则 $f(k)=\sum\limits_{i=0}^{k}(-1)^{i}n^{k-i}\binom{k}{i}g(i)$。

所以考虑新的 DP 设 $f_{i,j}$ 表示钦定 $i$ 至少选了一个，一个选了 $j$ 个没被覆盖的权值，每次转移先枚举上一次选的位置，可以对每个左端点预处理出发线段最远端点 $\leq r$ 的概率，先转移上一次的位置，再转移这次新的数数量，两维是分开的，可以做到 $O(n^2k+nk^2)$。

```cpp
signed main(){
	
	fac[0]=1;
	rep(i,1,B) fac[i]=1ll*fac[i-1]*i%mod;
	ifac[B]=ksm(fac[B],mod-2);
	per(i,B-1,0) ifac[i]=1ll*ifac[i+1]*(i+1)%mod;
	LL S=0;
	read(n,m,k);
	rep(i,1,n) read(a2[i],w2[i]),id[i]=i,S=(S+w2[i])%mod;
	sort(id+1,id+1+n,[&](int x,int y){return a2[x]<a2[y];});
	rep(i,1,n) a[i]=a2[id[i]],w[i]=w2[id[i]];
	rep(i,1,n) rep(j,i,n) g[i][j]=1;
	rep(i,1,m){
		int l,r,p;read(l,r,p);
		int cl=lower_bound(a+1,a+1+n,l)-a;
		int cr=upper_bound(a+1,a+1+n,r)-a-1;
		if(cl<=cr)g[cl][cr]=1ll*(mod+1-p)*g[cl][cr]%mod;
	}
	rep(i,1,n) per(j,n-1,i) g[i][j]=1ll*g[i][j]*g[i][j+1]%mod;
	f[0][0]=1;
	rep(i,1,n){
		LL P=g[i][i];
		per(j,i-1,0){
			rep(t,0,k) f[i][t]=(f[i][t]+1ll*f[j][t]*P%mod)%mod;
			P=P*g[j][i]%mod;
		}
		per(j,k,0){
			LL W=1;
			f[i][j]=0;
			rep(t,1,j){
				W=W*w[i]%mod;
				f[i][j]=(f[i][j]+1ll*f[i][j-t]*W%mod*ifac[t]%mod)%mod;
			}
		}
	}
	rep(t,0,k){
		per(i,n-1,0) f[n][t]=(f[n][t]+f[i][t])%mod;
	}
	LL ans=0;
	rep(i,0,k) ans=(ans+ksm(mod-1,i)*ksm(S,k-i)%mod*fac[k]%mod*ifac[k-i]%mod*f[n][i]%mod)%mod;
	write(ans,'\n');
	fprintf(stderr,"%.4lf s\n",1.0*clock()/CLOCKS_PER_SEC);
	return 0;
}
```

---


# 「KDOI-03」构造数组

## 题目描述

你现在有一个长度为 $n$ 的数组 $a$。一开始，所有 $a_i$ 均为 $0$。给出一个同样长度为 $n$ 的目标数组 $b$。求有多少种方案，使得通过若干次以下操作，可以让 $a$ 数组变成 $b$。

* 选出两个**不同的**下标 $1\leq i<j\leq n$，并将 $a_i$ 和 $a_j$ 同时增加 $1$。

两种方案被称之为不同的，当且仅当存在一个 $x$ 使得一种方案中第 $x$ 次操作选择的两个下标 $(i,j)$ 与另一种方案中的不同。

**答案对 $\bm{998244353}$ 取模。**

## 说明/提示

**【样例 1 解释】**

| 种类编号 | 第一组 | 第二组 | 第三组 | 第四组 | 方案数 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | `1<->2` | `1<->2` | `3<->4` | `3<->4` | $\binom{4}{2}=6$ |
| $2$ | `1<->3` | `1<->3` | `2<->4` | `2<->4` | $\binom{4}{2}=6$ |
| $3$ | `1<->4` | `1<->4` | `2<->3` | `2<->3` | $\binom{4}{2}=6$ |
| $4$ | `1<->2` | `1<->4` | `2<->3` | `3<->4` | $4!=24$ |
| $5$ | `1<->2` | `1<->3` | `2<->4` | `3<->4` | $4!=24$ |
| $6$ | `1<->3` | `1<->4` | `2<->3` | `2<->4` | $4!=24$ |

总方案数是 $6\times3+24\times3=90$。

**【样例 2】**

见选手文件中的 `array/array2.in` 与 `array/array2.ans`。

此样例满足测试点 $6\sim8$ 的限制。

**【样例 3】**

见选手文件中的 `array/array3.in` 与 `array/array3.ans`。

此样例满足测试点 $12\sim14$ 的限制。

**【样例 4】**

见选手文件中的 `array/array4.in` 与 `array/array4.ans`。

此样例满足测试点 $15\sim18$ 的限制。

**【样例 5】**

见选手文件中的 `array/array5.in` 与 `array/array5.ans`。

此样例满足测试点 $19\sim20$ 的限制。

**【样例 6】**

见选手文件中的 `array/array6.in` 与 `array/array6.ans`。

此样例满足测试点 $21\sim22$ 的限制。

**【样例 7】**

见选手文件中的 `array/array7.in` 与 `array/array7.ans`。

此样例满足测试点 $23\sim25$ 的限制。

***

**【数据范围】**

对于 $100\%$ 的数据，$1\le n\le5~000$，$1\leq b_i\le30~000$，$\sum b_i\le30~000$。

| 测试点编号 | $n$ | $\sum b_i$ |
| :----------: | :----------: | :----------: |
| $1$ | $\leq5~000$ | $\equiv 1\pmod 2$ |
| $2\sim3$ | $=1$ | $\leq30~000$ |
| $4\sim5$ | $=2$ | $\leq30~000$ |
| $6\sim8$ | $\leq5$ | $\leq8$ |
| $9\sim11$ | $\leq20$ | $=n$ |
| $12\sim14$ | $\leq 5~000$ | $=n$ |
| $15\sim18$ | $\leq16$ | $\leq16$ |
| $19\sim20$ | $\le 700$ | $\le700$ |
| $21\sim22$ | $\le 5~000$ | $\le5~000$ |
| $23\sim25$ | $\le5~000$ | $\le30~000$ |


## 样例 #1

### 输入

```
4
2 2 2 2```

### 输出

```
90```

# 题解

## 作者：daniEl_lElE (赞：24)

## 测试点 1~3

输出~~不可以，总司令~~ $0$ 即可。

## 测试点 4~5

输出 $[b_1=b_2]$。其实输出 $1$ 即可，我没给 $0$ 的点。

## 测试点 6~8

暴力，咋暴力都行，数据太小了。

## 测试点 9~11

这个可以用状压 $dp$，毕竟 $b_i=1$。

## 测试点 12~14

稍微转化一下，转化为：

有 $n$ 个人要完成 $\frac{n}{2}$ 份大作业，两个人一组完成大作业，需要按顺序提交作业，求方案数。

考虑对于每个人选搭档，第 $1$ 个人有 $n-1$ 种选择，第 $2$ 个人 $n-3$ 种，以此类推，最后乘 $\frac{n}{2}!$ 即可。

## 测试点 15~18

状压 dp，考虑每次操作已经选个 $0/1/2$ 个数组中的位置的方案数，可以压位存下来，转移只需要枚举数组这个位置要在哪些操作中被操作即可。复杂度还是要看实现，最快可以达到 $O(3^{\frac{\sum b_i}{2}}\times n)$，慢一点的也能过。

## 测试点 19~25

发现不同操作位置本质相同，首先考虑 $dp_{i,j,k}$ 表示看到第 $i$ 个数组位置，有 $j$ 个操作位置目前为 $1$，$k$ 个为 $2$。转移需要枚举往目前 $0/1$ 个的位置分别转移多少个，复杂度 $O((\sum b_i)^2(n+\sum b_i))$，可以通过 $19\sim 20$ 点。

容易发现只需要记录 $2$ 操作个数，$0/1$ 操作个数都可以通过某些方式计算，时间与空间复杂度变为 $O((\sum b_i)(n+\sum b_i))$，可以通过 $21\sim 22$ 点。

然后分析一下，实际上操作位置只有 $\frac{\sum b_i}{2}$ 个，同时空间可以滚动数组优化，最终复杂度为 $O((\sum b_i)^2)$，$\frac{1}{4}$ 倍常数，实际循环次数约为 $2.25\times 10^8$，可以通过本题。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod=998244353;
int qp(int a,int b){
	int ans=1;
	while(b){
		if(b&1) ans=((long long)ans*a)%mod;
		a=((long long)a*a)%mod;
		b>>=1;
	}
	return ans;
}
int fac[100005],inv[100005];
void init(){
	fac[0]=1;
	for(int i=1;i<=100000;i++) fac[i]=(long long)fac[i-1]*i%mod;
	inv[100000]=qp(fac[100000],mod-2);
	for(int i=99999;i>=0;i--) inv[i]=(long long)inv[i+1]*(i+1)%mod;
}
int C(int i,int j){
	if(i<0||j<0||i<j) return 0;
	return (long long)fac[i]*inv[i-j]%mod*inv[j]%mod;
}
int b[50005],n,pre[50005],dp[2][50005];
signed main(){
	init();
	cin>>n;
	for(int i=1;i<=n;i++) cin>>b[i],pre[i]=pre[i-1]+b[i];
	if(pre[n]%2==1) return cout<<0,0;
	int sum=pre[n]/2;
	dp[0][0]=1;
	for(int i=1;i<=n;i++){
	    for(int j=0;j<=sum;j++){
			int tp2=j,tp1=pre[i-2]-j*2,tp0=sum-tp2-tp1;
			if(tp0<0) continue;
			dp[i&1][j]=0;
	    }
		for(int j=0;j<=sum;j++){
			int tp2=j,tp1=pre[i-1]-j*2,tp0=sum-tp2-tp1;
			if(tp0<0) continue;
			for(int k=0;k<=b[i];k++){
				if(tp1<k||tp0<b[i]-k) continue;
				if(dp[(i&1)^1][tp2]) (dp[i&1][tp2+k]+=(long long)dp[(i&1)^1][tp2]*C(tp1,k)%mod*C(tp0,b[i]-k)%mod)%=mod;
			}
		}
	}
	cout<<dp[n&1][sum];
	return 0;
}
```

---

## 作者：Aleph1022 (赞：21)

记 $a_i$ 为题目中的 $b_i$。

首先判掉 $2 \nmid \sum a_i$。记 $t=\frac{\sum a_i}2$，则操作次数恰为 $t$ 次。

不妨看成一个长为 $2t$ 的操作序列 $p_1, p_2, \dots, p_{2t}$，要求对于所有 $1 \le k \le t$ 满足 $p_{2k-1} < p_{2k}$。  
更自然地，不妨改为 $p_{2k-1} \ne p_{2k}$，再除以 $2^t$。

于是显然可以容斥，枚举 $c_i = |\{k \mid 1 \le k \le t \land p_{2k-1} = p_{2k} = i\}|$，则贡献为
$$
(-1)^{\sum c_i} \binom t{c_1, c_2, \dots, c_n, t-\sum c_i} \binom{2\left(t-\sum c_i\right)}{a_1-2c_1, a_2-2c_2, \dots, a_n-2c_n}
$$

那么作为一个熟练的计数选手，想必解法就显而易见了。构造
$$
F_i(x) = \sum_{j\ge 0} \frac{(-x)^j}{j!(a_i-2j)!}
$$

则答案即
$$
2^{-t} t! \sum_{s \ge 0} \frac{[2(t-s)]!}{(t-s)!} [x^s] \prod_{i=1}^n F_i(x)
$$

如暴力卷积，复杂度为 $O((\sum a_i)^2)$。如使用分治 NTT，复杂度为 $O((\sum a_i) \log (\sum a_i) \log n)$。

---

## 作者：FifthAxiom (赞：15)

首先考虑将题目转化一下，也就是令 $m=\dfrac{\sum_{i=1}^nb_i}2$ （若无法整除则显然无解），即对于 $i\in [1,n]\cap \mathbb Z$，将 $b_i$ 个 $i$ 填入 $m$ 个**有标号二元组**中，且每个二元组内部不考虑顺序，也不能填入相同的数。要求计数填入所有数的方案，一个方案被形式化地定义为如下集合
$$
A=\{\left(i,\ P\right)\ |\  P=\{p_1,p_2,\cdots,p_{b_i}\}\}
$$
对于某个 $i$ ，其对应的 $\{p_1,p_2,\cdots,p_{b_i}\}$ 表示 $i$ 被填入哪些二元组中。

考虑如何将转化后的一个方案转化为题目所定义的原方案，显然，对于原方案的第 $x$ 次操作，也即标号为 $x$ 的二元组，只需找到 $2$ 个（也仅有 $2$ 个）$i$ 使得 $x\in P$ ，将这 $2$ 个 $i$ 按大小填入第 $x$ 个二元组即可。容易证明其为双射。

考虑 DP。通过对 $A$ 中 $i$ 从小到大排序，我们可以定义以标号 $i$ 为阶段。而在 $b_i$ 个 $i$ 填入哪些二元组的决策中，依照新方案的形式化定义，决策顺序实际上并不重要。因此，只需将 $m$ 个二元组分类为已经填入 $2$ 个数的、仅填入 $1$ 个数的和未填的，即可完整定义一个状态。

考虑设 $f(i,m_1,m_2)$ 表示仅填完 $1\sim i$，且满足当前 $m$ 个二元组有 $m_2$ 个填入 $2$ 个数的、$m_1$ 个填入 $1$ 个数的和 $m-m_1-m_2$ 个未填的所有填入方案的数量。容易得到状态转移
$$
f(i,m_1,m_2)=\sum_{0\le k\le\min(b_i,m_2)}f(i-1,m_1+k,m_2-k)\binom{m_1}{k}\binom{m_0}{b_i-k}\quad(m_0=m-m_1+m_2\ge 0)
$$
但是，这样的转移是 $\mathrm O((n+m)m^2)$ 的。

注意到，仅考虑填完 $1\sim i$ 时，$m_1=\sum_{j=1}^ib_j-2m_2$ ，因此我们直接删除 $m_1$ 这一维，即
$$
f(i,m_2)=\sum_{0\le k\le\min(b_i,m_2)}f(i-1,m_2-k)\binom{m_1}{k}\binom{m_0}{b_i-k}\quad (m_1,m_0\ge 0)
$$
因此，使用滚动数组，即可在空间允许的情况下做到 $\mathrm O(m^2)$ ，实际上由于大量不合法状态，常数进一步缩小，可以通过本题。

```cpp
#include <bits/stdc++.h>

using namespace std;
using LL = long long;

const int N = 5010, S = 30005, P = 998244353;

int n;
int b[N], s[N];
int f[2][S];
int inv[S], fac[S], ifac[S];

void build(int n) {
    inv[1] = 1;
    for (int i = 2; i <= n; i++) 
        inv[i] = (LL)(P - P / i) * inv[P % i] % P;
    fac[0] = ifac[0] = 1;
    for (int i = 1; i <= n; i++) {
        fac[i] = (LL)fac[i - 1] * i % P;
        ifac[i] = (LL)ifac[i - 1] * inv[i] % P;
    }
}

int binom(int n, int m) {
    if (m < 0 || n < m) return 0;
    return (LL)fac[n] * ifac[m] % P * ifac[n - m] % P;
}

int main() {  
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> b[i];
        s[i] = s[i - 1] + b[i];
    }
    if (s[n] & 1) {
        cout << '0';
        return 0;
    }
    int m = s[n] >> 1;
    build(m);
    f[0][0] = 1;
    for (int i = 1; i <= n; i++) {
        memset(f[i & 1], 0, (m + 1) << 2);
        for (int j = 0; j <= m; j++) {
            int m2 = j, m1 = s[i - 1] - 2 * j, m0 = m - m1 - m2;
            if (m1 < 0 || m2 < 0) continue;
            for (int k = 0; k <= b[i]; k++)
                if (m1 - k >= 0 && m0 - (b[i] - k) >= 0)
                    f[i & 1][m2 + k] = (f[i & 1][m2 + k] + (LL)f[i - 1 & 1][m2] * binom(m1, k) % P * binom(m0, b[i] - k) % P) % P;
        }
    }
    cout << f[n & 1][m];
    return 0;
}
```



---

## 作者：Special_Judge (赞：8)

# P8863 「KDOI-03」构造数组 题解

~~做完看了一下题解发现一眼看过去都好复杂~~

讲一下自己推出来的做法。

首先可以明确，$\sum b_i \equiv 1 \pmod 2$ 的时候，一定无解，因为每次操作都会使整个数列的和增加 $2$，而 $a_i$ 初始均为 $0$，所以数列的和始终为偶数，不可能出现 $\sum b_i \equiv 1 \pmod 2$ 的情况。

那么我们我们不妨来转换一下问题，设 $m=\dfrac{\sum b_i}{2}$，那么题意就变为了：给定 $m$ 个括号，每一个括号都形如 $(\quad ,\quad)$，即需要往里面填 $2$ 个数，填的数在 $[1,n]$ 之间，同一括号内的数不相同，并且 $i$ 在 $m$ 个括号中出现 $b_i$ 次。

来手玩一下样例 $1$。首先只考虑填 $1$ 的话我们的方案就有 $C_{4}^{2}$ 种。

那么接下来我们要填 $2$。如果我们只考虑填 $1$ 和 $2$ 的话我们的方案数就有 $C_{4}^2 \cdot C_{4}^2$ 种。但是我们注意到我们填 $2$ 的位置是会改变填 $3$ 的方案数的。因为如果填进了已经填过 $1$ 的位置，这个括号就填满了，$3$ 的可选位置就变少了。

此时注意到数据范围 $1 \le n \le 5000,\sum b_i \le 30000$，可以猜想这道题目可能是 DP。结合上面的思考，我们就应该设计 DP 状态为 $f_{i,j}$，第一维 $i$ 表示填完了前 $i$ 个数，第二维 $j$ 表示有 $j$ 个括号已经被填满。

下面设 $s_i=\sum \limits _{k=1}^i b_k$。

状态转移时，我们不妨考虑填完前 $i-1$ 个数已经被填满的括号数 $k \in [0,j]$，那么为了让填完的括号数变为 $j$，我们需要从 $s_{i-1}-2k$ 个填了 $1$ 个数的括号中选择 $j-k$ 个括号填上 $i$，同时从 $m-k-(s_{i-1}-2k)=m+k-s_{i-1}$ 个空括号中选择 $b_i-(j-k)$ 个填上剩下的 $i$。所以状态转移方程为：
$$
f_{i,j}=\sum_{k \in [0,j]} f_{i-1,k} \cdot C_{s_{i-1}-2k}^{j-k} \cdot C_{m+k-s_{i-1}}^{b_i-(j-k)}
$$
另外我们注意到，最好控制一下使得这些组合中的数不为负。这样我们可以进一步缩小 $k$ 的取值范围，只有这样时间复杂度才是对的。

$j-k$ 不可能为负，由 $s_{i-1}-2k \ge 0$ 得 $k \le \dfrac{s_{i-1}}{2}$；由 $b_i-(j-k) \ge 0$ 得 $k \ge j-b_i$；由 $m+k-s_{i-1} \ge 0$ 得 $k \ge s_{i-1}-m$。

综上所述，设：
$$
l=\max \{ 0,j-b_i,s_{i-1}-m \} \\
r=\min \{ j,\frac{s_{i-1}}{2} \}
$$
状态转移方程变为：
$$
f_{i,j}=\sum_{k \in [l,r]} f_{i-1,k} \cdot C_{s_{i-1}-2k}^{j-k} \cdot C_{m+k-s_{i-1}}^{b_i-(j-k)}
$$
其中初始状态为 $f_{0,0}=1$，最终答案即为 $f_{n,m}$。

注意到 $n \cdot m$ 非常大，要开这么大的 $f$ 数组是不可能的。又注意到 $f_i$ 的转移只和 $f_{i-1}$ 有关，因此用滚动数组优化。

注意到 $j-(j-b_i)=b_i$，所以枚举 $k$ 的循环次数不会太多。时间复杂度大概是 $O(m^2)$，4s 时限下稳过。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long

#define here(x) {cout<<"here "<<x<<endl;}
#define putlist(x,st,ed) {for(int ind=st;ind<=ed;ind++)cout<<x[ind]<<' ';cout<<endl;}
#define putstl(x) {for(auto TeMp:x)cout<<TeMp<<' ';cout<<endl;}
#define putsize(x) cout<<sizeof(x)*1.0/1024/1024<<" MB"<<endl;

#define cases int __;cin>>__;while(__--)work();

#define MAXN_INT 2147483647
#define MAXN_LL 9223372036854775807ll

#define N 5010
#define M 30010
#define eps 1e-6

#define mp make_pair
#define pb push_back

using namespace std;

const int MOD=998244353;
namespace Combination {
	int qpow(int x,int y) {
		int res=1;
		while(y) {
			if(y&1)res=res*x%MOD;
			x=x*x%MOD;
			y>>=1;
		}
		return res;
	}
	int fac[M],inv[M];
	void setup(int lim) {
		fac[0]=1;
		for(int i=1;i<=lim;i++) {
			fac[i]=fac[i-1]*i%MOD;
		}
		inv[lim]=qpow(fac[lim],MOD-2);
		for(int i=lim-1;i>=1;i--) {
			inv[i]=inv[i+1]*(i+1)%MOD;
		}
	}
	int comb(int n,int m) {
		if(n<m)return 0;
		else if(n==m||m==0)return 1;
		else if(n==0)return 0;
		else return fac[n]*inv[m]%MOD*inv[n-m]%MOD;
	}
}
using namespace Combination;

int n,m;
int b[N],s[N];
int ol=0,ne=1;
int f[2][M];

signed main() {
	cin>>n;
	for(int i=1;i<=n;i++) {
		cin>>b[i];
		s[i]=s[i-1]+b[i];
	}
	m=s[n]/2;
	f[ol][0]=1;
	setup(M-5);
	for(int i=1;i<=n;i++) {
		for(int j=0;j<=m;j++) {
			int l=max({0ll,j-b[i],s[i-1]-m});
			int r=min(j,s[i-1]/2);
			f[ne][j]=0;
			for(int k=l;k<=r;k++) {
				f[ne][j]=(f[ne][j]+f[ol][k]*comb(s[i-1]-2*k,j-k)%MOD*comb(m+k-s[i-1],b[i]-j+k)%MOD)%MOD;	
			}
		}
		swap(ol,ne);
	}
	cout<<f[ol][m]<<endl;
	return 0;
} 
/*

*/
```





---

## 作者：Thomas0702 (赞：6)

模拟赛 T4。赛时认为这是不可做题，遂打爆搜拿 60pts 跑路。结果午睡之后再看很快就瞪出来做法了。~~所以是因为上午没有午睡导致脑子不清醒~~。

观察题目中的操作，每次选两个不同的下标进行 $+1$ 操作。也就是说一共 $\sum b_i/2$ 个操作，每个操作都有两个不相等的参数。$i$ 会在操作中出现 $b_i$ 次。我们从小到大填参数。对于每个状态，我们只关心有多少个操作只填了一个参数。

约定：$s_i$ 表示 $\sum_{j=1}^ib_i$。

设 $f_{i,j}$ 表示考虑完前 $i$ 个下标，有 $j$ 个操作只确定了较小的一个参数，其余的参数所在的操作都已经确定了两个参数。转移的时候，枚举有 $k$ 个参数用来补全只填了一个参数的操作。得到如下转移：
$$f_{i,j-k+b_i-k}\leftarrow \dbinom{j}{k}\dbinom{s_N/2-((s_{i-1}-j)/2+j)}{b_i-k}f_{i-1,j}$$
直接枚举转移即可。时间复杂度 $O((\sum b_i)^2)$。
```cpp
#include<bits/stdc++.h> 
#define ll long long
using namespace std;
void rd(){}
template<typename T,typename... U> void rd(T &x,U&... arg){
	x=0;int f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
	x*=f;rd(arg...);
}
const int maxn=5005,maxv=30005,P=998244353;
int N,a[maxn],s[maxn];
ll f[2][maxv>>1],fac[maxv],inv[maxv];
inline ll C(int n,int m){
	if(n<m||m<0) return 0;
	return fac[n]*inv[m]%P*inv[n-m]%P;
}
int main(){
	rd(N);
	for(int i=1;i<=N;i++) rd(a[i]),s[i]=s[i-1]+a[i];
	fac[0]=fac[1]=inv[0]=inv[1]=1;
	for(int i=2;i<=s[N];i++)
		fac[i]=fac[i-1]*i%P,
		inv[i]=(P-P/i)*inv[P%i]%P;
	for(int i=2;i<=s[N];i++) (inv[i]*=inv[i-1])%=P;
	f[0][0]=1;
	for(int i=1,t=1;i<=N;i++,t^=1){
		memset(f[t],0,sizeof f[t]);
		for(int j=0;j<=min(s[i-1],s[N]-s[i-1]);j++)
			for(int k=0;k<=min(j,a[i]);k++){
				if(j-k+a[i]-k>s[N]-s[i]) continue;
				(f[t][j-k+a[i]-k]+=C(j,k)*
				C(s[N]/2-(s[i-1]+j)/2,a[i]-k)%P*f[!t][j])%=P;
			}
	}
	printf("%lld",f[N&1][0]);
	return 0;
}
```

---

## 作者：Kevin090228 (赞：4)

被凯文加 $0$ 了。

首先，若 $\sum b_i$ 是奇数，则方案数为 $0$，下面只考虑 $\sum b_i$ 为偶数的情况。

设 $m=\sum b_i$。

注意到需要求的方案数实际上对应一个长度为 $m$ 的不同序列 $a$ 的个数，这个序列满足以下两个条件：

1. 对于 $i\in [1,n]$，数 $i$ 在序列中出现了 $b_i$ 次。
2. 对于 $k\in[1,\frac{m}{2}]$，满足 $a_{2k-1}<a_{2k}$。

我们注意到，只需要求出满足条件 $1$ 且对于任意 $k\in[1,\frac{m}{2}]$，都有 $a_{2k-1}\neq a_{2k}$ 的序列数，再除以 $2^\frac{m}{2}$ 即可。

我们考虑容斥：设 $dp[i][j]$ 为考虑了 $[1,i]$ 这些数，有至少 $j$ 个 $k$ 满足 $a_{2k-1}=a_{2k}$ 的序列数。

我们设有 $c_i$ 个 $k$ 满足 $a_{2k-1}=a_{2k}=i$，$d_i$ 个 $i$ 满足不在这 $c_i$ 个相等对里，则总方案数为 $\frac{(\sum d_i)!}{\prod(d_i!)}\frac{(\sum c_i)!}{\prod(c_i!)}C(\frac{\sum d_i}{2}+\sum c_i,\sum c_i)$，其中 $C$ 是组合数。这三个分式中第一个表示 $d_i$ 内部排序方案数，第二个表示 $c_i$ 内部排序方案数，第三个表示将 $c_i$ 插入 $d_i$ 中的方案数。

而 $(\sum d_i)!,(\sum c_i)!,C(\frac{\sum d_i}{2}+\sum c_i,\sum c_i)$ 都是可以最后再计算的，所以我们 $dp$ 值中只记录 $\frac{1}{\prod(d_i!)\prod(c_i!)}$ 的部分。

转移为 $dp[i][j]=\sum dp[i-1][j-k]\times\frac{1}{k!(b_i-2k)!}$。

注意到转移是一个卷积的形式，所以我们需要做的就是把 $n$ 个 $b_i$ 次多项式相乘，这一部分可以使用分治 NTT 做到 $O((\sum b_i)\log^2n)$。

最后答案只需要容斥一下即可。

```cpp
//Author: Kevin5307
#include<bits/stdc++.h>
//#pragma GCC optimize("O2")
using namespace std;
#define ll long long
#define pb push_back
#define mp make_pair
#define ALL(x) (x).begin(),(x).end()
#define rALL(x) (x).rbegin(),(x).rend()
#define srt(x) sort(ALL(x))
#define rev(x) reverse(ALL(x))
#define rsrt(x) sort(rALL(x))
#define sz(x) (int)(x.size())
#define inf 0x3f3f3f3f
#define pii pair<int,int>
#define lb(v,x) (int)(lower_bound(ALL(v),x)-v.begin())
#define ub(v,x) (int)(upper_bound(ALL(v),x)-v.begin())
#define uni(v) v.resize(unique(ALL(v))-v.begin())
#define longer __int128_t
void die(string S){puts(S.c_str());exit(0);}
const ll mod=998244353;
ll ksm(ll a,ll b)
{
	ll res=1;
	while(b)
	{
		if(b&1) res=res*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return res;
}
namespace convolution
{
	const ll gr=3;
	vector<ll> cvl(vector<ll> f,vector<ll> g)
	{
		int n=sz(f),m=sz(g);
		int len=1,b=0;
		while(len<=n+m+2)
		{
			len<<=1;
			b++;
		}
		int rev[len];
		memset(rev,0,sizeof(rev));
		for(int i=0;i<len;i++)
			rev[i]=(rev[i>>1]>>1)|((i&1)<<(b-1));
		f.resize(len);
		g.resize(len);
		for(int i=0;i<len;i++)
			if(i<rev[i])
			{
				swap(f[i],f[rev[i]]);
				swap(g[i],g[rev[i]]);
			}
		for(int i=1;i<len;i<<=1)
		{
			ll gn=ksm(gr,(mod-1)/(i+i));
			for(int j=0;j<len;j+=(i+i))
			{
				ll g0=1;
				for(int k=0;k<i;k++,g0=g0*gn%mod)
				{
					ll x=f[j+k],y=f[i+j+k]*g0%mod;
					f[j+k]=(x+y)%mod;
					f[i+j+k]=(x-y+mod)%mod;
					x=g[j+k];y=g[i+j+k]*g0%mod;
					g[j+k]=(x+y)%mod;
					g[i+j+k]=(x-y+mod)%mod;
				}
			}
		}
		for(int i=0;i<len;i++)
			f[i]=f[i]*g[i]%mod;
		for(int i=0;i<len;i++)
			if(i<rev[i])
				swap(f[i],f[rev[i]]);
		for(int i=1;i<len;i<<=1)
		{
			ll gn=ksm(ksm(gr,mod-2),(mod-1)/(i+i));
			for(int j=0;j<len;j+=(i+i))
			{
				ll g0=1;
				for(int k=0;k<i;k++,g0=g0*gn%mod)
				{
					ll x=f[j+k],y=f[i+j+k]*g0%mod;
					f[j+k]=(x+y)%mod;
					f[i+j+k]=(x-y+mod)%mod;
				}
			}
		}
		for(int i=0;i<len;i++)
			f[i]=f[i]*ksm(len,mod-2)%mod;
		while(sz(f)&&!f.back()) f.pop_back();
		return f;
	}
}
ll fact[60030],rfact[60030];
vector<ll> v[5050];
int main()
{
	fact[0]=rfact[0]=1;
	for(int i=1;i<60030;i++)
	{
		fact[i]=fact[i-1]*i%mod;
		rfact[i]=ksm(fact[i],mod-2);
	}
	int n;
	scanf("%d",&n);
	int tot=0;
	priority_queue<pii,vector<pii>,greater<pii>> pq;
	for(int i=1;i<=n;i++)
	{
		int x;
		scanf("%d",&x);
		tot+=x;
		vector<ll> vect;
		for(int i=0;i<=x;i+=2)
			vect.pb(rfact[i/2]*rfact[x-i]%mod);
		v[i]=vect;
		pq.push(mp(sz(v[i]),i));
	}
	while(sz(pq)>1)
	{
		pii a=pq.top();pq.pop();
		pii b=pq.top();pq.pop();
		v[a.second]=convolution::cvl(v[a.second],v[b.second]);
		pq.push(mp(sz(v[a.second]),a.second));
	}
	int x=pq.top().second;
	ll ans=0;
	for(int i=0;i<sz(v[x]);i++)
	{
		ll ways=v[x][i]*fact[i]%mod*fact[tot-i-i]%mod*fact[(tot-i-i)/2+i]%mod*rfact[i]%mod*rfact[(tot-i-i)/2]%mod;
		if(i%2)
			ans=(ans-ways+mod)%mod;
		else	ans=(ans+ways)%mod;
	}
	if(tot%2)
		die("0");
	printf("%lld\n",ans*ksm(ksm(2,mod-2),tot/2)%mod);
	return 0;
}
```

---

## 作者：liyixin0514 (赞：2)

# [P8863 「KDOI-03」构造数组](https://www.luogu.com.cn/problem/P8863)

## 题意

给你一个长度为 $n\le 5000$ 的数组 $\{b\}$，满足 $\sum b \le 30000$。每次操作你可以选择两个下标 $i,j,i \neq j$，将 $b_i,b_j$ 减 $1$，问有多少种操作方式使得 $b$ 变成全部是 $0$。

## 思路

也许写得比较详细。

设 $s_i = \sum_{j=1}^i b_i$，显然当 $s_n$ 为奇数的时候答案为 $0$，因为每次操作都会使总和减 $2$。

刻画一下操作，相当于一共有 $\frac{s_n}{2}$ 个桶，每个数字需要选择 $b_i$ 个不相同的桶，每个桶只能装 $2$ 个数字。

其中每个数字选择的桶的顺序是不重要的，因为无论你如何顺序选桶，最终我都会按照桶的编号顺序操作。

容易想到状压。

发现每个桶其实本质相同，都是只能装两个数字，因此我们不需要即每个桶的状态。只需要记 $k_{0/1/2}$ 表示已经装了 $0/1/2$ 个数字的桶有多少个。

因此可以设 $f_{i,k_0,k_1,k_2}$ 表示处理到第 $i$ 个数字，已经装了 $0/1/2$ 个数字的桶有 $k_{0/1/2}$ 个，的方案数。

转移的时候，枚举第 $i$ 个数字往 $0/1$ 的桶里分别装了多少个桶，往已经装了 $1$ 个数字的桶里选了 $j$ 个桶，那么 $0$ 的桶就选了 $b_i-j$ 个桶。转移方程就是

$$f_{i+1,k_0-b_i+j,k_1+b_i-j-j,k_2+j} \gets \binom{k_0}{b_i-j} \binom{k_1}{j} f_{i,k_0,k_1,k_2}$$

比较显然的是我们不需要维护三个 $k$，实际上我们只需要维护 $1$ 个 $k$。

设 $k$ 表示已经装了 $1$ 个球的的桶有多少个。

$$
\begin{cases}
k_0=\frac{s_n}{2}-k_1-k_2\\
k_1=k\\
k_2=\frac{s_{i-1}-k_1}{2}
\end{cases}
$$

整理一下，转移式子就是 

$$f_{i+1,k+b_i-2j} \gets \binom{\frac{s_n}{2}-k-\frac{s_{i-1}-k}{2}}{b_i-j} \binom{k}{j} f_{i,k}$$

状态数是 $O(n\sum b)$ 的，好像甚至不需要滚动数组，不过滚一下也无妨，把第一维滚掉。转移的时候枚举 $k$ 是 $O(\sum b)$ 的，枚举 $j$ 是 $O(b_i)$ 的，因此复杂度 $O((\sum b)^2)，可以算出来的有至少 $\frac{1}{4}$ 的常数。

## code

```cpp
#include<bits/stdc++.h>
#define sf scanf
#define pf printf
#define rep(x,y,z) for(int x=y;x<=z;x++)
#define per(x,y,z) for(int x=y;x>=z;x--)
using namespace std;
typedef long long ll;
namespace poetry {
    constexpr int N=5e3+7,mod=998244353,M=3e4+7;
    int n,b[N],s[N];
    int jc[M],inv[M];
    int f[2][M];
    int add(int a,int b) { return a+b>=mod ? a+b-mod : a+b; }
    void _add(int &a,int b) { a=add(a,b); }
    ll ksm(ll a,ll b=mod-2) {
        ll s=1;
        while(b) {
            if(b&1) s=s*a%mod;
            a=a*a%mod;
            b>>=1;
        }
        return s;
    }
    void init() {
        jc[0]=1;
        rep(i,1,s[n]>>1) jc[i]=1ll*jc[i-1]*i%mod;
        inv[s[n]>>1]=ksm(jc[s[n]>>1]);
        per(i,(s[n]>>1)-1,0) inv[i]=1ll*inv[i+1]*(i+1)%mod;
    }
    ll c(int n,int m) {
        if(m>n) return 0;
        return 1ll*jc[n]*inv[m]%mod*inv[n-m]%mod;
    }
    void main() {
        sf("%d",&n);
        rep(i,1,n) sf("%d",&b[i]);
        sort(b+1,b+n+1);
        rep(i,1,n) s[i]=s[i-1]+b[i];
        if((s[n]&1)||n==1) puts("0"), exit(0);
        if(n==2) {
            if(b[1]==b[2]) puts("1");
            else puts("0");
            exit(0);
        } 
        init();
        f[1][0]=1;
        rep(i,1,n) {
            int lim=i-2<0 ? 0 : s[i-2]+1;
            memset(f[(i&1)^1],0,sizeof(int)*lim);
            rep(k,0,s[i-1]) {
                if(f[i&1][k])
                rep(j,0,b[i]) {
                    if(k+b[i]-(j<<1)<0) break;
                    _add(f[(i&1)^1][k+b[i]-(j<<1)],c((s[n]>>1)-k-((s[i-1]-k)>>1),b[i]-j)*c(k,j)%mod*f[i&1][k]%mod);
                }
            }
        }
        pf("%d\n",f[(n+1)&1][0]);
    }
}
int main() {
    poetry :: main();
}
```

---

## 作者：analysis (赞：2)

容斥做法。

显然，操作的总次数一定等于 $\frac{\sum b_i}{2}$。如果这个东西不是整数显然无解。记 $t=\frac{\sum b_i}{2}$。

将所有操作排在一起，形成一个长度为 $2t$ 的序列 $P$，满足：

- $i$ 出现的次数恰好为 $b_i$。
- $\forall 1 \leq i \leq t$，都有 $p_{2i-1} < p_{2i}$。

答案即为序列个数。

不妨把第二个条件改为：$\forall 1 \leq i \leq t$，都有 $p_{2i-1} \neq p_{2i}$。

最后给答案乘上 $\frac{1}{2^t}$ 就可以了。

于是，这就是个很明显的容斥了。

假设有 $c_i$ 个 $j$ 满足 $p_{2j-1}=p_{2j}=i$，$s=\sum c_i$，序列个数为：
$$
\sum(-1)^{s}\binom{t}{c_1,c_2,\cdots,c_n,t-s}\binom{2(t-s)}{b_1-2c_1,b_2-2c_2,\cdots,b_n-2c_n}
$$
$t$ 是定值，$s$ 是枚举容斥，都可以提出来，于是直接构造：
$$
F_i(x)=\sum_{j}\frac{x^j}{j!(b_i-2j)!}
$$
序列个数即为：
$$
\sum_{s}\frac{t!(2(t-s))!(-1)^s}{(t-s)!}[x^s]\prod_{i}F_i
$$
最后乘上 $\frac{1}{2^t}$。

```cpp
#include<bits/stdc++.h>
#define int long long
const int mod=998244353,inv2=499122177;
using namespace std;
int n,b[5005],t;
int f[60005],g[60005],h[60005],nf,ng,nh;
int fac[60005],ifac[60005];
int fpow(int a,int b=mod-2){
    int r=1;
    while(b){
        if(b&1)r=r*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return r;
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    for(int i=fac[0]=ifac[0]=1;i<=60000;i++)fac[i]=fac[i-1]*i%mod;
    ifac[60000]=fpow(fac[60000]);
    for(int i=59999;i>=1;i--)ifac[i]=ifac[i+1]*(i+1)%mod;
    cin>>n;
    for(int i=1;i<=n;i++)cin>>b[i],t+=b[i];
    if(t&1){
        cout<<"0";
        return 0;
    }
    t>>=1;
    f[0]=nf=1;
    for(int i=1;i<=n;i++){
        ng=nh=0;
        for(int j=0;2*j<=b[i];j++){
            ng++;
            g[j]=ifac[j]*ifac[b[i]-2*j]%mod;
        }
        nh=nf+ng-1;
        for(int j=0;j<nh;j++)h[j]=0;
        for(int j=0;j<nf;j++){
            for(int k=0;k<ng;k++){
                h[j+k]=(h[j+k]+f[j]*g[k]%mod)%mod;
            }
        }
        for(int j=0;j<nh;j++)f[j]=h[j];
        nf=nh;
    }
    int ans=0;
    for(int i=0;i<=t;i++){
        ans=(ans+fac[2*(t-i)]*ifac[t-i]%mod*f[i]%mod*((i&1)?mod-1:1)%mod)%mod;
    }
    for(int i=1;i<=t;i++){
        ans=ans*inv2%mod;
    }
    cout<<ans*fac[t]%mod;
    return 0;
}
```

---

## 作者：zjsdut (赞：2)

介绍一个用**容斥原理**的做法。

显然，若 $\sum b_i$ 是奇数，答案是 $0$。以下假设 $\sum b_i$ 是偶数，令 $m = (\sum b_i) / 2$。

考虑下述问题：

有 $2m$ 个两两不同的东西，这些东西属于 $n$ 个类别，其中第 $i$ 类东西有 $b_i$ 个。这 $2m$ 个东西有多少个排列 $p$ 满足

- 对于每个 $i = 1, \dots, m$ 都有 $p_{2i-1}$ 和 $ p_{2i}$ 不是同一类。

（此问题的答案除以 $2^{m} \prod (b_i!)$ 就是原问题的答案。）

我们把这 $2m$ 个东西的**不**满足上述条件的排列 $p$ 分成 $m$ 类，第 $i$ 类是满足 $p_{2i - 1} = p_{2i}$ 的排列。同时属于某特定的 $k$ 个类别的「不满足上述条件的排列」有

$$
S_k =  (2(m - k))! k! 2^k f_k
$$

个。其中 $f_k$ 表示

- 从这 $2m$ 个东西中选出 $k$ 对东西，每一对都是同一种类，有多少种方法。


$f_k$ 是多项式

$$
P(x) := \prod_{i=1}^{n} \left( \sum_{j = 0}^{\lfloor b_i/2\rfloor} {b_i \choose 2j} (2j - 1)!! x^j \right)
$$

的 $x^k$ 项的系数。


应用容斥原理，上述问题的答案可表为

$$
\sum_{k = 0}^{m}(-1)^{k} {m \choose k} S_k
$$


用 NTT 算出 $P(x)$，再套容斥原理即可。

用暴力方法把这 $n$ 个多项式相乘的时间复杂度是 $O(m^2)$。下面介绍一个更好的方法：

- 把这 $n$ 个多项式放到一个队列里。
- 取出队首的两个多项式相乘，把乘积放到队尾。重复此操作直到队列里只剩一个多项式。
- 最后队列里的那个多项式就是答案。

此方法的时间复杂度是 $O(m \log m \log n)$。




---

## 作者：Kingna (赞：1)

# Problem

你现在有一个长度为 $n$ 的数组 $a$。一开始，所有 $a_i$ 均为 $0$。给出一个同样长度为 $n$ 的目标数组 $b$。求有多少种方案，使得通过若干次以下操作，可以让 $a$ 数组变成 $b$。

* 选出两个**不同的**下标 $1\leq i<j\leq n$，并将 $a_i$ 和 $a_j$ 同时增加 $1$。

两种方案被称之为不同的，当且仅当存在一个 $x$ 使得一种方案中第 $x$ 次操作选择的两个下标 $(i,j)$ 与另一种方案中的不同。

$n\le5~000$，$\sum b_i\le30~000$ |

# Analysis

首先这道题部分分是很足的。测试点 $1\sim 5$ 输出 $0$ 或 $1$。测试点 $6\sim 8$ 直接暴力 dfs。测试点 $9\sim 14$ 满足 $b_i=1$，可以找到规律。完成上述部分可以拿到 64 分。

正解：计算出操作次数 $m=\dfrac{\sum _{i=1}^{n} b_i}{2}$。把 $m$ 次操作看成 $m$ 个二元组，然后把 $b_i$ 个 $i$ 放入这 $m$ 个二元组中，二元组中不考虑顺序，也不能存在相同的数，问填入所有数的方案。考虑转化后的方案如何对应原来的方案，从填入数值层面考虑，发现考虑每个数值填入哪些二元组和方案一一对应：

例如 $n=3,b=[1,2,3]$：

* $[(1,3),(2,3),(2,3)]⇔[(1,\{1\}),(2,\{2,3\}),(3,\{1,2,3\})]$
* $[(2,3),(1,3),(2,3)]⇔[(1,\{2\}),(2,\{1,3\}),(3,\{1,2,3\})]$
* $[(2,3),(2,3),(1,3)]⇔[(1,\{3\}),(2,\{1,2\}),(3,\{1,2,3\})]$

有了上述思路，可以定义 $f(i,m_1,m_2)$ 表示填完前 $i$ 个数值，存在 $m_1$ 个二元组只有一个数，存在 $m_2$ 个二元组只有两个数的方案数。可以推算一个数都没填的二元组数量 $m_0=m-m_1-m_2$。转移：

$$f(i+1,m_1-k+b_{i+1}-k,m_2+k)=\sum f(i,m_1,m_2) \binom{m_1}{k} \binom{m_0}{b_{i+1}-k}$$

复杂度 $\mathcal O((n+m)m^2)$。

但是注意到考虑前 $i$ 数值的 $m_1=\sum_{j=1}^{i} b_j-2m_2$。则可以直接删除 $m_1$ 这一维。

$$f(i+1,m_2+k)=\sum f(i,m_2) \binom{m_1}{k}\binom{m_0}{b_{i+1}-k}(m_1,m_0\geq 0)$$

复杂度 $\mathcal O((n+m)m)$。因为内层的 $k$ 限制于 $b_i$，则总枚举量为 $m$。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define PII pair<int, int>
#define _for(i, a, b) for (int i = (a); i <= (b); i++)
#define _pfor(i, a, b) for (int i = (a); i >= (b); i--)
#define int long long

const int N = 5000 + 5, M = 30010, mod = 998244353;

int n, m, a[N], f[2][M], sum[N], fac[M], invfac[M];

int qpow(int a, int k, int p) {
	int res = 1;
	while (k) {
		if (k & 1) res = res * a % p;
		a = a * a % p;
		k >>= 1;
	}
	return res;
}

void init() {
	fac[0] = invfac[0] = 1;
	_for(i, 1, M - 5) {
		fac[i] = fac[i - 1] * i % mod;
		invfac[i] = invfac[i - 1] * qpow(i, mod - 2, mod) % mod;
	}
}

int C(int n, int m) {
	if (n < m || n < 0 || m < 0) return 0;
	return fac[n] * invfac[n - m] % mod * invfac[m] % mod;
}

signed main() {
	cin >> n; init();
	_for(i, 1, n) cin >> a[i], m += a[i], sum[i] = sum[i - 1] + a[i];
	if (m % 2 == 1) puts("0"), exit(0);
	m /= 2;
	f[0][0] = 1;
	_for(i, 0, n - 1) {
		_for(m2, 0, m) {
			int m1 = sum[i] - 2 * m2, m0 = m - m1 - m2;
			if (m0 < 0 || m1 < 0) continue;
			_for(k, 0, a[i + 1]) {
				if (m2 + k <= m) f[(i + 1) & 1][m2 + k] = (f[(i + 1) & 1][m2 + k] + f[i & 1][m2] * C(m1, k) % mod * C(m0, a[i + 1] - k) % mod) % mod;
			}
		}
		memset(f[(i + 2) & 1], 0, sizeof f[(i + 2) & 1]);
	}
	cout << f[n & 1][m] << endl;
}
```

---

## 作者：Leasier (赞：1)

dp is 2 hd 4 me /dk

------------

设 $sum_i = \displaystyle\sum_{j = 1}^i b_j$，则当 $sum_n \not\equiv 1 \pmod 2$ 时无解。

首先有一个直观的想法：

- 设 $cnt_{i, j}$ 表示 $(i, j)$ 被操作的次数。
- 一种 $cnt$ 组合的方案数为 $\dfrac{\dfrac{sum_n}{2}!}{\displaystyle\prod_{i = 1}^{n - 1} \prod_{j = i + 1}^n cnt_{i, j}!}$。

遂尝试对分母分之一的和 dp。

一个同样十分直观的想法是设 $dp_{i, j}$ 表示讨论到 $i$，满足 $p \leq i, q > i$ 的操作 $(p, q)$ 有 $j$ 个的分母分之一的和，但问题在于转移时我们难以表出前面的 $cnt_{p, i}$ 的信息。

不妨换一个思路：**在转移时钦定操作序列的顺序**。

从这个角度出发，不难想到设 $dp_{i, j, k}$ 表示讨论到 $i$，$p < q \leq i$ 和 $p \leq i, q > i$ 的操作数量分别为 $j, k$ 的方案数。

转移时，考虑枚举补全了前面的多少个操作，由此我们还可以知道这里还会给后面新增多少个待补全的操作。不难用组合数表示，此处略去。

但注意到 $2j + k = sum_i$，于是我们只需要保留 $j$ 这一维。

时间复杂度为 $O(sum_n^2)$，但常数较小，可以通过。

代码：
```cpp
#include <stdio.h>

const int mod = 998244353;
int fac[15007], inv_fac[15007], b[5007], sum[15007], dp[5007][15007];

inline int quick_pow(int x, int p){
	int ans = 1;
	while (p){
		if (p & 1) ans = 1ll * ans * x % mod;
		x = 1ll * x * x % mod;
		p >>= 1;
	}
	return ans;
}

inline void init(int n){
	fac[0] = 1;
	for (register int i = 1; i <= n; i++){
		fac[i] = 1ll * fac[i - 1] * i % mod;
	}
	inv_fac[n] = quick_pow(fac[n], mod - 2);
	for (register int i = n - 1; i >= 0; i--){
		inv_fac[i] = 1ll * inv_fac[i + 1] * (i + 1) % mod;
	}
}

inline int min(int a, int b){
	return a < b ? a : b;
}

inline int comb(int n, int m){
	if (n < 0 || m < 0 || n < m) return 0;
	return 1ll * fac[n] * inv_fac[m] % mod * inv_fac[n - m] % mod;
}

inline void add(int &x, int y){
	if ((x += y) >= mod) x -= mod;
}

int main(){
	int n;
	scanf("%d", &n);
	for (register int i = 1; i <= n; i++){
		scanf("%d", &b[i]);
		sum[i] = sum[i - 1] + b[i];
	}
	if (sum[n] % 2 == 1){
		printf("0");
		return 0;
	}
	int full = sum[n] / 2;
	init(full);
	dp[0][0] = 1;
	for (register int i = 0; i < n; i++){
		int up1 = sum[i] / 2;
		for (register int j = 0; j <= up1; j++){
			if (dp[i][j] != 0){
				int k = sum[i] - j * 2, up2 = min(b[i + 1], k);
				for (register int l = 0; l <= up2; l++){
					int x = b[i + 1] - l;
					add(dp[i + 1][j + l], 1ll * dp[i][j] * comb(k, l) % mod * comb(j + k + x, x) % mod);
				}
			}
		}
	}
	printf("%d", dp[n][full]);
	return 0;
}
```

---

## 作者：nullqtr_pwp (赞：0)

独立写出来了。/hsh

直接去对每个球去考虑是没有救的，考虑从维护操作序列的角度来做。

记 $S=\dfrac{\sum_{i=1}^n b_i}{2}$，考虑将问题转换成有 $S$ 个不同的盒子，颜色为 $i$ 的球有 $b_i$ 个，要求每个盒子中恰好有两个颜色不同的球，求放球的方案数。

考虑前 $i$ 个盒子，放一个颜色需要考虑往当前有 $0/1$ 个球的位置中放，然后往这些盒子中各放一个。显然我们只需要维护有 $j$ 个盒子中只有一个球的方案数，记作 $f_{i,j}$。这样做可以直接推出来有 $k=\dfrac{pre_i-j}{2}$ 个盒子中有两个球。

转移就是枚举第 $i$ 个颜色，放在了 $t\le j$ 个已经有且仅有 $1$ 个球的盒子中，乘个组合数就行了。

考虑每次转移会访问 $S\times a_i$ 个位置，而转移是 $O(1)$ 的，求和可以得出总复杂度为 $O(S^2)$，常数较小可以通过本题。

```cpp
int qpow(int x,int y){
	int rt=1;
	for(;y;y>>=1,x=1ll*x*x%mod) if(y&1) rt=1ll*rt*x%mod;
	return rt;
}
void inc(int &x,int y){ x=(x+y>=mod)?(x+y-mod):(x+y); }
void dec(int &x,int y){ x=(x>=y)?(x-y):(x+mod-y); }
void mul(int &x,int y){ x=1ll*x*y%mod; }
int add(int x,int y){ return (x+y>=mod)?(x+y-mod):(x+y); }
int sub(int x,int y){ return (x>=y)?(x-y):(x+mod-y); }
int prod(int x,int y){ return 1ll*x*y%mod; }
void chkmax(int &x,int y){ x=max(x,y); }
void chkmin(int &x,int y){ x=min(x,y); }
int n,a[maxn],sum,f[30005],g[30005],pre[maxn],inv[maxn],fac[maxn];
int C(int n,int m){ return (m>n||n<0||m<0)?0:1ll*fac[n]*inv[m]%mod*inv[n-m]%mod; }
signed main(){
	n=read();
	F(i,1,n) a[i]=read(),sum+=a[i];
	F(i,1,n) pre[i]=pre[i-1]+a[i];
	if(sum&1) return printf("0"),0;
	int S=sum>>1;
	fac[0]=inv[0]=1;
	F(i,1,sum) fac[i]=1ll*fac[i-1]*i%mod;
	inv[sum]=qpow(fac[sum],mod-2);
	dF(i,sum-1,1) inv[i]=1ll*inv[i+1]*(i+1)%mod;
	if(sum==n){
		int ans=fac[n];
		printf("%d",prod(ans,qpow(qpow(2,sum>>1),mod-2)));
		return 0;
	}
	f[0]=1;
	F(i,0,n-1){
		F(j,0,S) if((j&1)==(pre[i+1]&1)) g[j]=0;
		F(j,0,min(pre[i],S)) if((j&1)==(pre[i]&1)){
			int k=(pre[i]-j)>>1;
			if(!f[j]) continue;
			F(t,0,min(a[i+1],j)) {
				int tmp=f[j],T=a[i+1]+j-(t<<1);
				if(T<0) break;
				inc(g[T],1ll*tmp*C(j,t)%mod*C(S-j-k,a[i+1]-t)%mod);			
			}
		}
		F(j,0,S) if((j&1)==(pre[i+1]&1)) f[j]=g[j];
	}
	cout<<f[0];
}
```

---

## 作者：cryozwq (赞：0)

令 $sum=\sum b_i$。

考虑看成有 $\frac{sum}{2}$ 个盒子，每个盒子可以放两个球，这两个球不能相同，第 $i$ 种球有 $b_i$ 个。

然后考虑一个一个 $b_i$ 的加。

我们需要知道的是有多少个盒子能放两个球，多少个能放一个，多少个放不了了。

设 $dp_{i,j}$ 表示加了前 $i$ 个元素，还有 $j$ 个盒子能放一个。那么我们知道目前我们一共加了 $S=\sum_{k=1}^{i}b_k$ 个球，有 $j$ 个放了一个，就有 $\frac{S-j}{2}$ 个盒子放了两个（不整除就不合法），又因为我们知道一共有多少盒子，也就知道了还有多少个盒子没有放球。

记 $dp_{i,j}$ 对应的三种元素数量为 $(a,b,c)$，$a=\frac{S-j}{2},b=j,c=\frac{sum}{2}-a-b$。

考虑从 $i-1$ 转移，暴力的转移是枚举一个 $k$ ，从 $dp_{i-1,k}$ 转移到 $dp_{i,j}$ ，记 $dp_{i-1,k}$ 对应 $(a',b',c')$。考虑转移的系数，原来有 $c'$ 个没有球的盒子，现在只有 $c$ 个，那么有 $c'-c$ 个空的变成装了一个球的盒子（显然不能变成装两个），所以这里要乘 $C^{c'-c}_{c}$，然后原来有 $a'$ 个装了两个的盒子，现在变成了 $a$ 个，那么有 $a-a'$ 个装了一个的盒子又装了一个。再乘一个 $C^{a'-a}_{b'}$。即 $dp_{i,j}=\sum dp_{i-1,k}\times C^{c'-c}_{c} \times C^{a'-a}_{b'}$。

这样做的复杂度是 $O(n w^2)$ 的，其中 $w=\sum b_i$。

注意到一个 $(a,b,c)$ 对于每个 $i$ 唯一确定了一个 $dp_{i,k}$ ，考虑枚举 $a'$ ，根据刚才的式子可以反推出 $b',c'$，也就知道所对应哪个 $dp_{i-1,k}$ ，我们发现 $|a-a'|\le b_i$（这里变量名重了，问题不大），所以总复杂度变成了 $O(w^2)$ ，常数较小，可以通过。

---


# [THUPC 2021] 小 E 爱消除

## 题目描述

管道中塞着 $n$ 个彩色的球。这些球的直径相同。从一端到另一端它们的颜色分别为 $c_1,c_2,\ldots,c_n$。

小 E 有一个空的杯子。杯口的直径恰好比球的直径大一些，所以小 E 可以把球放入杯子中，但一次只能放入一个，并且球在杯子中只能竖直叠放。杯子中两个相邻的同色球会一起消失。

由于管道的特殊性，小 E 每次只能选择管道的一端，将最靠外的球取出，然后马上放进杯子里。

问当管道中的球全部取出后，杯子里最少会剩下几个球，以及在此前提下至少需要多大的杯子。

## 说明/提示

**【样例解释】**

一种最优的方案如下：

先将两端的 $3$ 放入杯子中消去。

然后把左端的 $5,1,4,9$ 依次放入杯子，这时杯子中有 $4$ 个球。

再把右端的 $9,4$ 依次放入杯子，每放入一个球就会和杯子里的另一个球消去。在放入 $9$ 后消去前杯子中有 $5,1,4,9,9$，所以杯子需要能够容纳 $5$ 个球。

接着把左端的 $3,3$ 放入杯子，这时被杯子中有 $2$ 个球。

最后把右端的 $1,5$ 依次放入杯子。这时杯子是空的。

图片可见下发文件中的 `Sampledescription.pptx`。

**【数据范围】**

保证 $1 \le n \le 50$，$1 \le c_i \le n$。

**【题目来源】**

来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）。

题解等资源可在 [https://github.com/yylidiw/thupc_1/tree/master](https://github.com/yylidiw/thupc_1/tree/master) 查看。

## 样例 #1

### 输入

```
12
3 5 1 4 9 3 3 5 1 4 9 3
```

### 输出

```
0 5
```

# 题解

## 作者：Time_tears (赞：11)

看完题目后容易想到区间 Dp。

设 $g_{l,r}$ 表示区间 $[l,r]$ 的答案（包含最少的剩的和最小栈大小两个信息），最后 $g_{1,n}$ 就是答案。
## $g$ 的转移

我们假设第一步先选最左边（右边同理）。

### situation 1. 
直接把最左边然后不管它，转移式为：
$$g_{l,r}=g_{l+1,r}+(1,1)$$
### situation 2.
考虑让最左边的值去和中间的某一个相同值抵消，枚举 $i(c_i=c_l)$，现在我们要让 $c_i,c_l$ 抵消

#### situation 2.1
$[i+1,r]$ 必须要仙贝选到栈中且要被完全消除，但是我们也有可能再用左边的一段来帮助它消除，假设用了 $[l+1,j](j<i)$ 来帮助它删除。
那么我们设 $f_{l_1,r_1,l_2,r_2}$ 表示将 $[l_1,r_1,l_2,r_2]$ **完全删除**至少需要多大的栈，此时的 $g_{l,r}$ 可以由 $g_{j+1,i-1}$ 和 $f_{l+1,j,i+1,r}$ 转移得到，画成示意图大概是这个样子：

![](https://cdn.luogu.com.cn/upload/image_hosting/a750awkg.png?x-oss-process=image/resize,m_lfit,h_250,w_500)

#### situation 2.2

$[l+1,i-1]$ 必须要仙贝选到栈中且要被完全删除，但是我们也有可能再用右边的一段来帮助它消除，假设用了 $[j,r](j>i)$ 来帮助它删除。
那么此时 $g_{l,r}$ 可以由 $g_{i+1,j-1}$ 和 $f_{l+1,i-1,j,r}$ 转移得到。

## $f$ 的转移
同理，考虑枚举从哪边开始删，枚举相同的数的位置然后枚举辅助删除的 $j$ 的位置转移即可，理解了上面的转移下面是一模一样的。

这个算法的复杂度是 $O(n^6)$ 的，但是因为 $f$ 的转移中，$r_2-l_2+r_1-l_1\bmod 2=0$ 否则无解这个限制，常数大约可以缩减 $\dfrac{1}{4}$ 左右，同时 $[l_1,r_1,l_2,r_2]$ 这个区间必须要将区间中的数两两配对才有可能消除，这个地方也可以使常数大大减小，只要用一个 Hash 或者你预处理一下就行了，真正的复杂度为 $O(可过)$，~~压行代码~~。

```cpp
#include<bits/stdc++.h>
#define pr pair<int,int>
#define mp make_pair
#define fi first
#define se second
using namespace std;
const int inf=0x3f3f3f3f;
int n,c[55],h[55],s[55];
int f[55][55][55][55];
pr g[55][55];
pr operator+(pr a,pr b){return mp(a.fi+b.fi,a.se+b.se);}
int F(int l1,int r1,int l2,int r2) {
	if(l1>r1&&l2>r2)return 0;
	if((r1-l1+r2-l2&1)||(s[l1-1]^s[r1]^s[l2-1]^s[r2]))return inf;
	if(l1>r1)l1=1,r1=0;if(l2>r2)l2=1,r2=0;
	int &ans=f[l1][r1][l2][r2];if(ans)return ans;ans=inf;
	for(int i=l1; i<=r1; ++i) {
		if(i!=l1&&c[i]==c[l1])for(int j=l2-1; j<=r2; ++j)ans=min(ans,max(max(F(l1+1,i-1,j+1,r2)+1,2),F(i+1,r1,l2,j)));
		if(l2<=r2&&c[i]==c[r2])for(int j=l2-1; j<r2; ++j)ans=min(ans,max(max(F(l1,i-1,j+1,r2-1)+1,2),F(i+1,r1,l2,j)));
	}
	for(int i=l2; i<=r2; ++i) {
		if(i!=r2&&c[i]==c[r2])for(int j=r1+1; j>=l1; --j)ans=min(ans,max(max(F(l1,j-1,i+1,r2-1)+1,2),F(j,r1,l2,i-1)));
		if(l1<=r1&&c[i]==c[l1])for(int j=r1+1; j>l1; --j)ans=min(ans,max(max(F(l1+1,j-1,i+1,r2)+1,2),F(j,r1,l2,i-1)));
	} return ans;
}
pr G(int l,int r) {
	if(g[l][r].se)return g[l][r];
	if(l>r)return mp(0,0);
	pr &ans=g[l][r];ans=mp(inf,inf);
	ans=min(ans,min(G(l+1,r)+mp(1,1),G(l,r-1)+mp(1,1)));
	for(int i=l; i<=r; ++i) {
		if(i!=l&&c[i]==c[l]) {
			for(int j=l+1,tmp; j<=r; ++j)
				if((tmp=F(l+1,min(i,j)-1,max(i,j)+1,r))<inf) {
					pr wer=(i>=j)?G(j,i-1):G(i+1,j);
					ans=min(ans,mp(wer.fi,max(wer.se,max(2,tmp+1))));
				}
		}
		if(i!=r&&c[i]==c[r]) {
			for(int j=l,tmp; j<=r-1; ++j)
				if((tmp=F(l,min(i,j)-1,max(i,j)+1,r-1))<inf) {
					pr wer=(i>=j)?G(j,i-1):G(i+1,j);
					ans=min(ans,mp(wer.fi,max(wer.se,max(2,tmp+1))));
				}
		}
	}
	return ans;
}
int main() {
	cin>>n,srand((unsigned)time(NULL));
	for(int i=1; i<=n; ++i)cin>>c[i],h[i]=rand();
	for(int i=1; i<=n; ++i)s[i]=s[i-1]^h[c[i]];
	cout<<G(1,n).fi<<" "<<G(1,n).se<<"\n";
	return 0;
}
```


---

## 作者：樱雪喵 (赞：5)

17:40 开始做，22:15 调过了，令人感动。说实话真挺好奇场上过了几个人（

要求在剩的球最少时杯子最小，那这两个东西应该是放在一起转移的。设 $g_{l,r}$ 表示管子里只剩 $[l,r]$ 的球，最少剩的球数 / 最小的杯子大小。

对于当前区间，如果考虑从两端取出数和外面的栈合并，发现栈是没法用 dp 维护的。我们只能使用向内考虑配对的思路。换句话说我们只考虑 $[l,r]$ 区间本身的结果，不考虑原来栈里已有的东西。

这里以先从左边取为例。

如果这个球最后也没有被消掉，从 $g_{l+1,r}$ 转移。  
否则枚举跟 $l$ 配对的球 $i$，满足 $col_i=col_l$。那么想让他们匹配，我们要做的事情是先取 $l$，再消掉 $i$ 左边或右边的所有数，取出 $i$。

分类讨论 $i$ 最后从哪边被取出。

- 从左取出，那么 $[l+1,i-1]$ 这段区间要全消掉。如果它不能自己消干净，也可以用 $[j,r]$ 来辅助。枚举 $j$，则答案为 将 $[l+1,i-1]$ 和 $[j,r]$ 一起消除的答案 和 $g_{i+1,j-1}$ 取 $\max$。

设 $f_{a,b,c,d}$ 表示把 $[a,b]$ 和 $[c,d]$ 一起恰好完全消除需要最小的杯子大小。

- 从右取出，那么 $[i+1,r]$ 这段要全消掉。同样枚举 $j$，答案从 $f_{l+1,j,i+1,r}$ 和 $g_{j+1,i-1}$ 转移。

先取右边同理。

---

转移完了 $g$，但是我们还没转移 $f$。  
同样地，分类讨论先取 $a$ 还是先取 $d$，再讨论与它配对的在哪段区间，从左边还是右边取。

状态数 $O(n^4)$，转移 $O(n^2)$。跑不过。

发现如果 $f$ 里面有任意一种颜色出现了奇数次，一定是消不掉的，可以在记搜里直接剪枝，用异或的性质判断即可（类似 P1469）。  
同时因为转移限制了很多同色，有效的状态数很少，官方题解说常数大概是 $\frac{1}{720}$，可以通过。

写的时候注意一下各种边界问题。

```cpp
#include<bits/stdc++.h>
#define il inline
using namespace std;
il long long read()
{
    long long xr=0,F=1; char cr;
    while(cr=getchar(),cr<'0'||cr>'9') if(cr=='-') F=-1;
    while(cr>='0'&&cr<='9')
        xr=(xr<<3)+(xr<<1)+(cr^48),cr=getchar();
    return xr*F;
}
const int N=55,inf=1e9;
int n,cl[N],val[N],hsh[N];
struct node
{
    int mn,cnt;
    friend node operator +(const node &x,const node &y) {return {x.mn+y.mn,x.cnt+y.cnt};}
    friend bool operator <(const node &x,const node &y)
    {
        if(x.mn==y.mn) return x.cnt<y.cnt;
        else return x.mn<y.mn;
    }
}G[N][N];
int F[N][N][N][N];
il int Max(int a,int b,int c=0) {return max(a,max(b,c));}
int f(int a,int b,int c,int d)
{
    if(a>b&&c>d) return 1;
    if(hsh[b]^hsh[a-1]^hsh[d]^hsh[c-1]) return inf;
    if(a>b) a=1,b=0; if(c>d) c=1,d=0;
    if(F[a][b][c][d]!=-1) return F[a][b][c][d];
    int res=inf;
    for(int i=a;i<=b;i++) 
    {
        if(cl[a]==cl[i]&&i!=a) for(int j=c;j<=d+1;j++) res=min(res,Max(f(a+1,i-1,j,d)+1,f(i+1,b,c,j-1)));
        if(cl[d]==cl[i]&&c<=d) for(int j=c;j<=d;j++) res=min(res,Max(f(a,i-1,j,d-1)+1,f(i+1,b,c,j-1)));
    }
    for(int i=c;i<=d;i++)
    {
        if(cl[a]==cl[i]&&a<=b) for(int j=a;j<=b;j++) res=min(res,Max(f(a+1,j,i+1,d)+1,f(j+1,b,c,i-1)));
        if(cl[d]==cl[i]&&i!=d) for(int j=a-1;j<=b;j++) res=min(res,Max(f(a,j,i+1,d-1)+1,f(j+1,b,c,i-1)));
    }
    return F[a][b][c][d]=res;
}
node g(int l,int r)
{
    if(G[l][r].mn!=-1) return G[l][r];
    if(l>r) return {0,0}; if(l==r) return {1,1};
    node res=min(g(l+1,r)+(node){1,1},g(l,r-1)+(node){1,1});
    for(int i=l-1;i<=r;i++)
    {
        for(int j=l;j<=r+1;j++)
        {
            if(i==j) continue;
            if(i>j)
            {
                if(i>l&&cl[i]==cl[l]&&f(l+1,j,i+1,r)<inf) 
                    res=min(res,{g(j+1,i-1).mn,max(g(j+1,i-1).cnt,f(l+1,j,i+1,r)+1)});
                if(j<r&&cl[j]==cl[r]&&f(l,j-1,i,r-1)<inf) 
                    res=min(res,{g(j+1,i-1).mn,max(g(j+1,i-1).cnt,f(l,j-1,i,r-1)+1)});
            }
            else
            {
                if(i>l&&cl[i]==cl[l]&&f(l+1,i-1,j,r)<inf) 
                    res=min(res,{g(i+1,j-1).mn,max(g(i+1,j-1).cnt,f(l+1,i-1,j,r)+1)});
                if(j<r&&cl[j]==cl[r]&&f(l,i,j+1,r-1)<inf) 
                    res=min(res,{g(i+1,j-1).mn,max(g(i+1,j-1).cnt,f(l,i,j+1,r-1)+1)});
            }
        }
    }
    return G[l][r]=res;
}
int main()
{
    n=read();
    for(int i=1;i<=n;i++) cl[i]=read(),val[cl[i]]=rand();
    for(int i=1;i<=n;i++) hsh[i]=hsh[i-1]^val[cl[i]];
    memset(F,-1,sizeof(F)),memset(G,-1,sizeof(G));
    node ans=g(1,n);
    printf("%d %d\n",ans.mn,ans.cnt);
    return 0;
}
```

附本人调题过程中拍挂过的所有数据：

```cpp
2
1 1

3
1 2 1

3
1 2 2

4
2 1 1 2

4
1 2 1 2

5
1 2 3 4 5

5
2 3 3 1 1

5
3 3 1 2 2

6
3 1 2 1 2 3
```

祝各位都能写完一遍过（

---

## 作者：InoueTakina (赞：3)

考虑区间 dp，记二元组 $f(l,r)$ 表示只考虑区间 $[l,r]$ 内的小球时的答案。

枚举第一次取的是 $c_l$ 还是 $c_r$，注意到两种情况是对称的，只分析取 $c_l$ 的情况。

- 如果 $c_l$ 未来会和某个东西匹配后消失，不妨记作 $c_k$，仍枚举 $k>l$ 和 $k<l$ 的情况。
  - 若 $k>l$，则 $[l+1,k-1]$ 之间的球应该能和另一端的若干球完全消除，不妨设为 $[j,r]$，其中满足 $i<j\leq r + 1$，其中 $j=r+1$ 表示不需要取右边的球。显然，我们希望在全部消除的时候任意时刻栈大小最小，因此考虑记辅助数组 $g(i,j,k,l)$，其中满足 $i\leq j+1,k\leq l+1,j\leq k$，表示完全消除 $[i,j]$ 和 $[k,l]$ 之间的球的任意时刻最小最大栈。此时，$f(l,r)$ 能从 $g(l+1,i-1,j,r)$ 以及 $f(i+1,j-1)$ 转移。
  - $k<l$，显然是对称的，仿照拟合即可。
- 如果 $c_l$ 不会被消除了，那么直接从 $f(l+1,r)$ 转移即可。

现在考虑求 $g(i,j,k,l)$，注意到当左边或者右边没有球时（即 $i>j$ 或 $k>l$），过程是唯一的，模拟计算即可。

考虑 $c_i$ 会和谁匹配消除，记作 $c_u$，仍然分 $u\in[i+1,j],u\in[k,l]$ 讨论。

- 如果 $u\in [i+1,j]$，则 $[i+1,u-1]$ 之间的东西也要全消，这个东西相当于一个子问题，同时我们枚举一个右侧的分界点 $v$，将 $g(i,j,k,l)$ 从 $g(i+1,u-1,v,l)$ 和 $g(u+1,j,k,v-1)$ 转移。
- 如果 $u\in[k,l]$，同样对称。

然后就做完了，复杂度 $\mathcal{O}(n^6)$。

事实上，我们仍需要一些针对 $g$ 转移的小小的剪枝：

- 如果 $[i,j],[k,l]$ 中每种颜色出现的次数不是偶数，可以不转移。这个可以用哈希实现。

官方题解说常数大约是 $\frac{1}{720}$，我不会算。

完结撒花 qwq.

---

## 作者：DengDuck (赞：1)

其实思路想明白的话还是很明白的。

题目中有两个要求最小化的量，不难想到利用 `pair` 确定优先级，我们设 $G_{L,R}$ 为区间 $[L,R]$ 的答案。

首先我们肯定是从左边或者右边先选一个球，这时我们考虑这个球会不会抵消掉：

- 不会，那么我们就忽略这个球的存在，整体上占了一位空间：$G_{L,R}=\min(G_{L+1,R},G_{L,R-1})+(1,1)$。
- 会，那么类似于某年 CSP 的 T3，我们现在可以去枚举把我抵消掉的那个球 $i$。

枚举了，然后呢？我们以选掉左边的球为例。

![](https://cdn.luogu.com.cn/upload/image_hosting/j6qikxej.png)

上图展示了我取到 $i$ 的两种办法：取光 $[L+1,i-1]$ 或 $[i+1,R]$。

注意到我们要保证它们抵消掉（这样我 $L$ 和 $i$ 才能碰在一起），所以我可能需要在另外一个方向借一块区间。

那么我们设这个区间的一个端点为 $j$，现在问题就变成了，判断区间 $[L+1,i-1]$ 和 $[j,R]$ 是否能够抵消（仅代表一种情况），如果能，求最小栈空间，然后再求剩下部分的 $G$ 即可转移。

这里有一个比较巧妙的写法是直接枚举 $j$，然后再根据 $j$ 和 $i$ 的位置关系来判断我们走到 $i$ 的策略，会好写很多。

状态显然比较直接，是 $F(L1,R1,L2,R2)$，转移和上面的套路是一样的。

那么，对于 $F$ 的转移，我们还是要枚举对应的 $i,j$，那时间复杂度不就 $\mathcal O(n^6)$ 了吗？咋做啊？

似乎没有什么高深的做法，直接剪枝，除去非法的状态，再通过 XOR-Hashing 可以除去一些颜色出现次数为奇数的区间，然后就过了。


第一篇题解实现很好，我代码几乎是照着第一篇题解写的了，没脸放上来。

---


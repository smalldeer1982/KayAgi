# [COTS 2023] 下 Niz

## 题目背景


译自 [Izborne Pripreme 2023 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2023/) D2T2。$\texttt{1s,0.5G}$。

祝 NaCly_Fish 生日快乐！（2024.7.28）

## 题目描述


给定长度为 $N$ 的序列 $a$，求满足以下条件的 $(l,r)$ 对数：

- $1\le l\le r\le N$；
- $a_l,a_{l+1},\cdots,a_{r-1},a_r$ 是 $1\sim r-l+1$ 的排列。


## 说明/提示


### 样例解释

样例 $3$ 解释：满足条件的 $(l,r)$ 有 $(2,2),(1,2),(1,3),(4,4),(4,5),(4,6),(4,7),(3,5)$。   

#### 数据范围

对于 $100\%$ 的数据，保证：

- $1\le N\le 10^6$；
- $1\le a_i\le N$。

| 子任务编号 | 分值 | 约束  |
|:-----:|:------:|:-------:|
| $1$  | $13$  | 每个数只在序列中出现一次  |
| $2$  | $20$  | $N\le 5\, 000$  |
| $3$  | $33$  | $N\le 50\, 000$ |
| $4$  | $34$  | 无额外约束 |





## 样例 #1

### 输入

```
3
3 1 2 ```

### 输出

```
3```

## 样例 #2

### 输入

```
5
3 2 1 2 3```

### 输出

```
5```

## 样例 #3

### 输入

```
7
2 1 3 1 2 3 4```

### 输出

```
8```

# 题解

## 作者：Lyrella (赞：6)

# 简要题意

给定一个长度为 $n$ 的序列 $A$，求所有满足下面条件的区间个数。

对于一个区间 $[l,r]$，若满足 $A_l,A_{l+1}\dots A_r$ 恰好能对应从 $1$ 到 $r-l+1$ 的一个排列，则该区间满足条件。

# 思路

对于这种计数的问题，我们可以分治，但分治中心的选择需要斟酌一下。我们知道如果我确定了一个区间的长度，那么它的最大值也就确定了，所以我们可以选择区间最大值作为分治中心。但最大值所在的位置往往不是区间中点，所以可以比较左右两部分的大小，统计包含分治中心的区间时就枚举长度较短的一边。那么对于一个区间我又应该如何 $O(1)$ 判断是否合法呢？

有一个套路就是记录一个 $las_i$ 表示 $A_i$ 上一次出现的位置，若 $\forall i\in[l,r],las_i<l$，那么区间合法。这个就是求静态区间最大值，可以用 $\text{st}$ 表存一下。

然后你也许会发现这个做法的复杂度和启发式合并非常类似所以它是 $O(n\log n)$ 的。

# 代码

```cpp
int n, a[N], id[N];
int st[2][N][25], lg[N] = {- 1};

void init(){
    for(int j = 1; (1 << j) < n; ++j)for(int i = 1; i + (1 << j) - 1 <= n; ++i){
        st[0][i][j] = a[st[0][i][j - 1]] < a[st[0][i + (1 << j - 1)][j - 1]] ? st[0][i + (1 << j - 1)][j - 1] : st[0][i][j - 1];
        st[1][i][j] = max(st[1][i][j - 1], st[1][i + (1 << j - 1)][j - 1]);
    }
}
int fd(int l, int r, int op){
    int j = lg[r - l + 1];
    if(! op)return a[st[0][l][j]] < a[st[0][r - (1 << j) + 1][j]] ? st[0][r - (1 << j) + 1][j] : st[0][l][j];
    return max(st[op][l][j], st[op][r - (1 << j) + 1][j]);
}

int ans;
void sol(int l, int r){
    if(l > r)return;
    if(l == r)return(void)(ans += a[st[0][l][0]] == 1);
    int pos = fd(l, r, 0), bg = max(l, pos - a[pos] + 1), ed = min(r, pos + a[pos] - 1);
    if(pos - bg <= ed - pos)for(int i = bg; i + a[pos] - 1 <= ed; ++i)ans += fd(i, i + a[pos] - 1, 1) < i;
    else for(int i = ed; i - a[pos] + 1 >= bg; --i)ans += fd(i - a[pos] + 1, i, 1) <= i - a[pos];
    sol(l, pos - 1), sol(pos + 1, r);
}

signed main(){
    // fileio(fil);
    n = rd(); for(int i = 1, x; i <= n; ++i)st[0][i][0] = i, a[i] = x = rd(), st[1][i][0] = id[x], id[x] = i;
    for(int i = 1; i <= n; ++i)lg[i] = lg[i >> 1] + 1;
    init(); sol(1, n);
    cout << ans;
    return 0;
}
```

---

## 作者：Zelensky (赞：5)

发现当区间最大值确定下来时，区间的长度就固定了，于是以最值位置为分治中心，枚举较短区间的相应端点，区间就确定下来了，问题就变为判断一个区间是否为 $1$ 到 $n$ 的排列。

这是一个经典问题，我们维护一个 $las$ 数组，维护每个位置上的数上一次出现的位置，当区间内的某个位置的 $las$ 也在区间内时，这个区间显然不合法。

我们使用线段树或 ST 表维护区间 $las$ 的最大值，判断它与左端点的关系，即可快速判断区间是否为排列。

时间复杂度 $O(n\log n)$ 。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[(int)1.1e6],ans;
struct ST{
	int f[(int)1.1e6][30],lg[(int)1.1e6];
	void build(int n){
		lg[1]=0;
		for(int i=2;i<=n;i++)lg[i]=lg[i>>1]+1,f[i][0]=i;
		f[1][0]=1;
		for(int i=1;(1<<i)<=n;i++){
			for(int j=1;j+(1<<i)-1<=n;j++){
				int lp=f[j][i-1],rp=f[j+(1<<(i-1))][i-1];
				f[j][i]=(a[lp]>a[rp]?lp:rp);
			}
		}	
	}
	int query(int l,int r){
		int k=lg[r-l+1],lp=f[l][k],rp=f[r-(1<<k)+1][k];
		return a[lp]>a[rp]?lp:rp;
	}
}s;
int nw[(int)1.1e6],las[(int)1.1e6];
struct SEG{
	int f[(int)1.1e6][30],lg[(int)1.1e6];
	void build(int n){
		lg[1]=0;
		for(int i=2;i<=n;i++)lg[i]=lg[i>>1]+1,f[i][0]=i;
		f[1][0]=1;
		for(int i=1;(1<<i)<=n;i++){
			for(int j=1;j+(1<<i)-1<=n;j++){
				int lp=f[j][i-1],rp=f[j+(1<<(i-1))][i-1];
				f[j][i]=(las[lp]>las[rp]?lp:rp);
			}
		}	
	}
	int query(int l,int r){
		int k=lg[r-l+1],lp=f[l][k],rp=f[r-(1<<k)+1][k];
		return max(las[lp],las[rp]);
	}
}T;
void solve(int l,int r){
	if(l>r)return ;if(l==r)return ans+=a[l]==1,void();
	int mid=s.query(l,r),len=a[mid];solve(l,mid-1),solve(mid+1,r);
	if(mid-l<=r-mid){
		for(int i=l;i<=mid;i++){
			int R=i+len-1;
			if(R<mid)continue;if(R>r)return ;
			ans+=(T.query(i,R)<i);
		}
	}
	else {
		for(int i=r;i>=mid;i--){
			int L=i-len+1;
			if(L>mid)continue;if(L<l)return ;
			ans+=(T.query(L,i)<L);
		}
	}
}
int rt;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		las[i]=nw[a[i]];
		nw[a[i]]=i;
	}
	s.build(n),T.build(n),solve(1,n);
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Presentation_Emitter (赞：3)

猜想：满足条件的二元组数量很少。

证明：考虑一个更弱的条件：在 $a_l,a_{l+1},\cdots,a_r$ 中 $1$ 仅出现一次，且最大值为 $r-l+1$。我们可以这样去找满足弱化条件的二元组：

1. 找到所有 $1$ 的位置 $p_1,p_2,\cdots,p_m$（$m$ 为 $1$ 的出现次数，并钦定 $p_0=0,p_{m+1}=N+1$）
2. 选择一个 $p_i$，对于 $p_{i-1}+1 \sim p_i-1$ 中的位置 $j$，$(j,j-1+\max\limits_{j \le k \le p_i}a_k)$ 是一个**可能**满足条件的二元组。对于 $p_i+1 \sim p_{i+1}-1$ 中的位置 $j$，$(j+1-\max\limits_{p_i \le k \le j}a_k,j)$ 是一个**可能**满足条件的二元组。

于是我们找到了符合条件的一个必要条件以及符合这个条件的所有二元组，同时这样的二元组数量小于 $2N$。接下来就剩下判定二元组是否符合条件的问题。这是一个经典问题，可以使用[随机化哈希](https://oi-wiki.org/misc/rand-technique/#%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%94%A8%E4%BA%8E%E5%93%88%E5%B8%8C)或 ST 表等方法实现。

代码中使用了随机化哈希，为 $1 \sim N$ 中的每一个元素赋予了一个 $2^{64}$ 以内（不含 $2^{64}$）的哈希值 $f_i$ 并令 $s_i=\bigoplus\limits_{1 \le k \le i}f_i$，对于每一个 $(l,r)$ 判定 $\bigoplus\limits_{l \le k \le r}f_{a_i}=s_{r-l+1}$ 是否成立。时间复杂度 $\Theta(n)$。

Code:

```cpp
int n,a[1000005],ans;ull f[1000005],s[1000005],h[1000005];
mt19937_64 rng(58);
int main()
{
	n=rd();
	for(int i=1;i<=n;++i)a[i]=rd(),s[i]=(f[i]=rng())^s[i-1];
	for(int i=1;i<=n;++i)h[i]=h[i-1]^f[a[i]];
	for(int i=1,l=1;i<=n;++i)
	{
		if(a[i]^1)continue;
		int mx=1,r=i+1;
		while(r<=n&&(a[r]^1))
		{
			tomax(mx,a[r]);
			if(r-mx+1>=l&&(h[r]^h[r-mx])==s[mx])++ans;
			++r;
		}
		--r;
		mx=1;
		for(int j=i-1;j>=l;--j)
		{
			tomax(mx,a[j]);
			if(j+mx-1<=r&&(h[j+mx-1]^h[j-1])==s[mx])++ans;
		}
		l=i+1;i=r;++ans;
	}
	prt(ans);
	ret 0;
}
```

---

## 作者：tanghg (赞：2)

[更好的阅读体验](https://www.cnblogs.com/tanghg/p/18774598/solution-p10833)

对于 $[l,r]$，要满足
1. $\max_{i=l}^r a_i=r-l+1$
2. $\forall i,j,a_i\neq a_j$

可以猜到真正符合条件的区间应该不会很多，又因为区间一定要有且仅有一个 $1$，所以可以和 $1$ 的位置考虑。先考虑一个位置 $i$ 作为区间端点的情况，所以维护对于一个位置 $i$ 上一个 $1$ 和下一个 的位置 $p_i,n_i$。发现只考虑 $(i,i+\max_{j=i}^{n_i}a_j-1)$ 和 $(i-\max_{j=p_i}^i a_j+1,i)$ 即可。首先这个肯定是对的，但是为什么不会少呢？是因为对于再前面或后面的，如果还有最大值会被前面的左端点也算上，所以不会算漏只会算重。所以现在有不超过 $2n$ 个区间需要判断第 $2$ 个条件。

对于这一个条件，一般做数据结构题做多了就会想到就是求 $\mathrm{mex}(a_l\cdots a_r)\overset{?}{=} r-l+2$。

区间 $\mathrm{mex}$ 是不好求的，但是考虑到我们只有 $2n$ 个区间，所以考虑离线后排序。前缀 $\mathrm{mex}$ 相对好求，现在考虑如果把 $a_l$ 删去带来的影响。发现就是可以在下一个 $a_l$ 之前使用。所以也就是对于 $m_i$ 表示 $\mathrm{mex}\in[l,i]$。我们可以找到 $f_i$ 表示下一个 $a_i$ 的位置。于是对于每一次 $a_l$ 的删除操作，我们可以将 $m_i\leftarrow \min(m_i,a_l),i\in[l+1,f_l-1]$。对于一个 $[l,r]$ 判断 $m_r\overset{?}{=}r-l+2$ 即可。

时间复杂度 $O(n\log n)$。
```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(ll i=(a);i<=(b);++i)
using namespace std;
typedef long long ll;
const ll MAXN=1e6+5;
ll n,a[MAXN];
ll st[MAXN][22],lg[MAXN+5];
ll qm(ll l,ll r){
	ll len=lg[r-l+1];
	return max(st[l][len],st[r-(1<<len)+1][len]);
}
ll lst[MAXN],pre[MAXN];
struct Qj{
	ll l,r;
	bool operator<(const Qj&K)const{
		if(l==K.l){
			return r<K.r;
		}
		return l<K.l;
	}
};
vector<Qj>V,v;
struct node{
	ll u,x,tag;
	#define lc(u) (u<<1)
	#define rc(u) (u<<1|1)
}t[MAXN*4];
void push_down(ll u){
	t[lc(u)].tag=min(t[lc(u)].tag,t[u].tag);
	t[rc(u)].tag=min(t[rc(u)].tag,t[u].tag);
	t[lc(u)].x=min(t[lc(u)].x,t[u].tag);
	t[rc(u)].x=min(t[rc(u)].x,t[u].tag);
	t[u].tag=1e18;
}
ll mex[MAXN];
void build(ll u,ll l,ll r){
	t[u].tag=1e18;
	if(l==r){
		t[u].x=mex[l];
		return;
	}
	ll mid=(l+r)>>1;
	build(lc(u),l,mid);
	build(rc(u),mid+1,r);
}
void modify(ll u,ll l,ll r,ll ql,ll qr,ll x){
	if(ql<=l&&r<=qr){
		t[u].tag=min(t[u].tag,x);
		t[u].x=min(t[u].x,x);
		return;
	}
	push_down(u);
	ll mid=(l+r)>>1;
	if(ql<=mid){
		modify(lc(u),l,mid,ql,qr,x);
	}
	if(mid+1<=qr){
		modify(rc(u),mid+1,r,ql,qr,x);
	}
}
ll nxt[MAXN],vs[MAXN];
ll query(ll u,ll l,ll r,ll x){
	if(l==r){
		return t[u].x;
	}
	push_down(u);
	ll mid=(l+r)>>1;
	if(x<=mid){
		return query(lc(u),l,mid,x);
	}
	return query(rc(u),mid+1,r,x);
}
bool vv[MAXN];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;
	rep(i,2,n+5){
		lg[i]=lg[i/2]+1;
	};
	rep(i,1,n){
		cin>>a[i];
		if(a[i]==1){
			lst[i]=i;
		}else{
			lst[i]=lst[i-1];
		}
		st[i][0]=a[i];
	};
	for(int i=n;i>=1;--i){
		nxt[i]=vs[a[i]];
		if(nxt[i]==0){
			nxt[i]=n+1;
		}
		vs[a[i]]=i;
		if(a[i]==1){
			pre[i]=i;
		}else{
			pre[i]=pre[i+1];
		}
	}
	rep(j,1,lg[n]){
		for(int i=1;i+(1<<j)-1<=n;++i){
			st[i][j]=max(st[i][j-1],st[i+(1<<(j-1))][j-1]);
		}
	};
	rep(i,1,n){
		if(lst[i]){
			ll l=i-qm(lst[i],i)+1,r=i;
			if(l>=1){
				V.push_back({l,r});
			}
		}
		if(pre[i]){
			ll r=i+qm(i,pre[i])-1,l=i;
			if(r<=n){
				V.push_back({l,r});
			}
		}
	};
	if(V.empty()){
		cout<<0<<endl;
		return 0;
	}
	sort(V.begin(),V.end());
	v.push_back(V[0]);
	rep(i,1,ll(V.size()-1)){
		if(V[i].l==V[i-1].l&&V[i].r==V[i-1].r){
			continue;
		}
		v.push_back(V[i]);
	};
	vv[0]=true;
	rep(i,1,n){
		mex[i]=mex[i-1];
		vv[a[i]]=true;
		while(vv[mex[i]]){
			mex[i]++;
		}
	};
	build(1,1,n);
	ll tot=0,ans=0;
	rep(i,1,n){
		while(tot<ll(v.size())&&v[tot].l==i){
			ll l=v[tot].l,r=v[tot].r,val=query(1,1,n,r);
			if(val==r-l+2){
				ans++;
			}
			tot++;
		}
		modify(1,1,n,i+1,nxt[i]-1,a[i]);
	};
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：songhongyi (赞：2)

答案显然不会很多。我们考虑快速过滤出一些可能的区间。

固定一个左端点，看看右侧可以取到什么地方。

显然右端点需要到达一个 $1$，且有长度应该恰为这段区间内的极值。

我们考虑以区间内的 $1$ 作为分界点，不难发现如果区间的最大值在其左侧，那么固定左端点后就可以求得这个最大值进而确定这个区间。

显然，在右侧的情况只需要固定右端点再这样做即可。

那么我们得到了不超过 $2n$ 个区间，只需要对每个区间求 $\operatorname{MEX}$ 即可找到所有合法区间。

离线使用线段树维护，复杂度为 $O(n \log n)$。

```cpp
//
// Problem: P10833 [COTS/CETS 2023] 下 Niz
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P10833
// Memory Limit: 512 MB
// Time Limit: 1000 ms

#include <iostream>
#include <set>
#define lson x * 2
#define rson x * 2 + 1
using namespace std;
const int MAXN = 1e6 + 10;
int n, a[ MAXN ];
int p[ MAXN ], nxt[ MAXN ];
int mex[ MAXN ];
bool vis[ MAXN ];
void init()
{
    for ( int i = n; i >= 1; i-- )
    {
        nxt[ i ] = n + 1;
        if ( p[ a[ i ] ] )
        {
            nxt[ i ] = p[ a[ i ] ];
        }
        p[ a[ i ] ] = i;
    }
    int t = 1;
    for ( int i = 1; i <= n; i++ )
    {
        vis[ a[ i ] ] = 1;
        while ( vis[ t ] )
        {
            t++;
        }
        mex[ i ] = t;
    }
}
set< int > qs[ MAXN ];
void add( int l, int r )
{
    if ( l >= 1 and r <= n )
    {
        qs[ l ].insert( r );
    }
}
struct Node
{
    int mi, lzy;
} tr[ 4 * MAXN ];
void pushup( int x )
{
    tr[ x ].mi = min( tr[ lson ].mi, tr[ rson ].mi );
}
void pushdown( int x )
{
    tr[ lson ].mi = min( tr[ lson ].mi, tr[ x ].lzy );
    tr[ rson ].mi = min( tr[ rson ].mi, tr[ x ].lzy );
    tr[ lson ].lzy = min( tr[ lson ].lzy, tr[ x ].lzy );
    tr[ rson ].lzy = min( tr[ rson ].lzy, tr[ x ].lzy );
    tr[ x ].lzy = 1e9;
}
void build( int x, int l, int r )
{
    tr[ x ].lzy = tr[ x ].mi = 1e9;
    if ( l == r )
    {
        tr[ x ].mi = mex[ l ];
        return;
    }
    int mid = ( l + r ) / 2;
    build( lson, l, mid );
    build( rson, mid + 1, r );
    pushup( x );
}
int query( int x, int l, int r, int p )
{
    if ( l == r )
    {
        return tr[ x ].mi;
    }
    pushdown( x );
    int mid = ( l + r ) / 2;
    if ( p <= mid )
    {
        return query( lson, l, mid, p );
    }
    else
    {
        return query( rson, mid + 1, r, p );
    }
}
void update( int x, int l, int r, int L, int R, int v )
{
    if ( L <= l and r <= R )
    {
        tr[ x ].mi = min( tr[ x ].mi, v );
        tr[ x ].lzy = min( tr[ x ].lzy, v );
        return;
    }
    pushdown( x );
    int mid = ( l + r ) / 2;
    if ( L <= mid )
    {
        update( lson, l, mid, L, R, v );
    }
    if ( R > mid )
    {
        update( rson, mid + 1, r, L, R, v );
    }
    pushup( x );
}
int solve()
{
    build( 1, 1, n );
    int cnt = 0;
    for ( int i = 1; i <= n; i++ )
    {
        for ( auto t : qs[ i ] )
        {
            if ( query( 1, 1, n, t ) == t - i + 2 )
            {
                cnt++;
            }
        }
        update( 1, 1, n, i, nxt[ i ] - 1, a[ i ] );
    }
    return cnt;
}

int main()
{
    cin.tie( 0 );
    cin >> n;
    for ( int i = 1; i <= n; i++ )
    {
        cin >> a[ i ];
    }
    init();
    int lst = 0;
    for ( int i = 1; i <= n; i++ )
    {
        if ( a[ i ] == 1 )
        {
            int ma = 1;
            for ( int j = i; j > lst; j-- )
            {
                ma = max( ma, a[ j ] );
                add( j, j + ma - 1 );
            }
            lst = i;
        }
    }
    int nxt = n + 1;
    for ( int i = n; i >= 1; i-- )
    {
        if ( a[ i ] == 1 )
        {
            int ma = 1;
            for ( int j = i; j < nxt; j++ )
            {
                ma = max( ma, a[ j ] );
                add( j - ma + 1, j );
            }
            nxt = i;
        }
    }
    cout << solve() << endl;
}
```

---

## 作者：Helloworldwuyuze (赞：1)

# P10833 题解

## Des

给定序列 $a_n$，求这序列 **保值区间** 的个数。

其中，区间 $[l,r]$ 被称为保值区间，当且仅当 $a_l,\dots ,a_r$ 是 $1,\dots,r-l+1$ 的一个排列。

## Sol

### Part 1

首先考虑一个结论：保值区间的数量不多。

我们考虑保值区间的一个必要条件，即 $\max\limits_{i=l}^r a_i = r-l+1$ 且 $1\in \{a_i\mid i\in [l,r]\}$ 且 $\forall i,j\in [l,r]$，若 $i\ne j$ 则必有 $a_i\ne a_j$。

我们考虑由后两个性质进行问题简化，即通过找到前后出现 $1$ 的位置来划分区间。

对于一个位置 $i$，我们设它前面一个 $1$ 在 $x$，后面一个在 $y$，那么，它的保值区间有可能且仅有可能在 $(i,i+\max\limits_{j=i}^y a_j -1)$ 和 $(i-\max\limits_{j=x}^i a_j+1, i)$。也就是说，一个位置最多有两个以它为端点的保值区间。这样就证明了区间个数只有 $2n$ 个。

### Part 2

现在，我们不妨先考虑给定一个区间 $[l,r]$，我们如何判断它是否为保值区间？

因为保值区间要求序列是一个 $1,\dots,r-l+1$ 的排列，故这里容易想到 $\text{mex}$。

> $\text{mex}(l,r)$ 的定义为区间 $[l,r]$ 中最小的正整数 $x$ 使得 $x\not \in \{a_i\mid i\in [l,r]\}$。

因此，区间 $[l,r]$ 为保值区间的充分必要条件为 $\text{mex}(l,r) = r-l+2$。

### Part 3

但是区间求 $\text{mex}$ 是一件很困难的事情，但求一个前缀的 $\text{mex}$ 则较为简单，因此，我们考虑离线下来这 $2n$ 个区间然后扫描线判断。

具体的，我们先求出 $1\sim n$ 的 $\text{mex}$ 并放入线段树中，并提前预处理出来 $nxt_i$ 表示下一个 $a_i$ 在哪个地方，然后扫描线处理。

于是，当我们处理完了左端点为 $1$ 的区间的时候，发现第一个数已经不会也不应该对后面的区间产生影响，因此我们在 $\text{mex}$ 中应该消除第一个数的影响。也就是说区间 $[i,nxt_i)$ 的 $\text{mex}$ 最大最大也只能到 $a_i$ 了，因为 $a_i$ 在这些地方是没有的。故我们只需要每次处理完当前扫描到的 $i$ 的区间之后在线段树上对 $[i,nxt_i)$ 关于 $a_i$ 取 $\min$ 即可。

### Part 4

```cpp
using namespace std;
const int INF = 0x3f3f3f3f;
const int N = 1e6 + 10;

int n, a[N], nxt[N], lst[N], mex[N], ans;
bool vis[N];

vector<int> range[N];
inline void add(int l,int r){ if(l >= 1 && r <= n)	range[l].pb(r); }

int minn[N<<2], tag[N<<2];
inline void push_up(int p){ minn[p] = min(minn[p<<1], minn[p<<1|1]); }
inline void change(int p,int k){ minn[p] = min(minn[p], k), tag[p] = min(tag[p], k); }
inline void push_down(int p){ change(p<<1, tag[p]), change(p<<1|1, tag[p]), tag[p] = INF; }
void build(int p,int l,int r){
	tag[p] = INF;
	if(l == r)	return minn[p] = mex[l], void();
	int mid = l+r>>1;
	build(p<<1, l, mid), build(p<<1|1, mid+1, r);
	push_up(p);
}
void update(int p,int l,int r,int left,int right,int k){
	if(left <= l && r <= right)	return change(p, k);
	int mid = l+r>>1; push_down(p);
	if(left <= mid)	update(p<<1, l, mid, left, right, k);
	if(right > mid)	update(p<<1|1, mid+1, r, left, right, k);
	push_up(p);
}
int query(int p,int l,int r,int x){
	if(l == r)	return minn[p];
	push_down(p); int mid = l+r>>1;
	if(x <= mid)	return query(p<<1, l, mid, x);
	else	return query(p<<1|1, mid+1, r, x);
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;++i)   cin>>a[i], lst[i] = n+1;
	for(int i=n;i;--i)  nxt[i] = lst[a[i]], lst[a[i]] = i;
	int tmp = 1;
	for(int i=1;i<=n;++i){
		vis[a[i]] = true;
		while(vis[tmp])   ++tmp;
		mex[i] = tmp;
	}
	a[0] = a[n+1] = 1;
	for(int i=1;i<=n;++i)
		if(a[i] == 1){
			int mx = 0;
			for(int j=i;a[j]!=1||j==i;--j)	mx = max(mx, a[j]), add(j, j+mx-1);
		}
	for(int i=n;i;--i)
		if(a[i] == 1){
			int mx = 0;
			for(int j=i+1;a[j]!=1;++j)	mx = max(mx, a[j]), add(j-mx+1, j);
		}
	build(1, 1, n);
	for(int l=1;l<=n;++l){
		for(int r : range[l])
			if(query(1, 1, n, r) == r-l+2)	++ans;
		update(1, 1, n, l, nxt[l]-1, a[l]);
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：drowsylve (赞：1)

来一发按照最大值分治的做法。

考虑答案跨过这个最大值的位置 $mid$ 时，那他的区间长度就确定下来了，就等于 $a_{mid}$。接下来套路的考虑枚举长度较小的一边，根据区间长度可以直接计算出另一个端点，判断一下范围即可。

接下来考虑如何快速判断一个区间是否合法？简单，预处理出一个 $lst$ 数组记录某个值上一次出现的位置。则当前区间 $[l,r]$ 合法当且仅当 $lst_l$ 到 $lst_r$ 都小于 $l$，即区间内的数都没有重复出现。容易发现这也是一个 $\max$ 问题，直接上 st 表就好。

分治时求最大值位置也是一个 st 表，总体复杂度为 $O(n\log n)$，很好写，跑起来也挺快。


```cpp
bool M1;
#include<bits/stdc++.h>
#define look_memory cerr<<abs(&M2-&M1)/1024.0/1024<<'\n'
//#define int long long
//#define double long double
#define ll long long
#define db double
#define pb push_back
#define pii pair<int,int>
#define mkp make_pair
#define fr first
#define sc second
using namespace std;
template<typename T> void ckmin(T &x,T y){x=min(x,y);}
template<typename T> void ckmax(T &x,T y){x=max(x,y);}
const int N=1000005;
const int inf=1e9;
const int mod=1000000007;
int n;
int a[N],lst[N];
int lg2[N];
pii f[N][23];
int g[N][23];
pii qryf(int l,int r){
	int k=lg2[r-l+1];
	return max(f[l][k],f[r-(1<<k)+1][k]);
}
int qryg(int l,int r){
	int k=lg2[r-l+1];
	return max(g[l][k],g[r-(1<<k)+1][k]);
}
int ans;
void solve(int l,int r){
	if(l>r) return;
	if(l==r){
		if(a[l]==1) ans++;
		return;
	}
	int mid=qryf(l,r).sc;
	if(mid-l<=r-mid){
		for(int i=l,j;i<=mid;i++){
			j=mid+a[mid]-(mid-i+1);
			if(j<mid||j>r) continue;
			int mx=qryg(i,j);
			if(mx<i) ans++;
		}
	}else{
		for(int i=mid,j;i<=r;i++){
			j=mid-(a[mid]-(i-mid+1));
			if(j>mid||j<l) continue;
			int mx=qryg(j,i);
			if(mx<j) ans++;
		}
	}
	solve(l,mid-1);
	solve(mid+1,r);
}
bool M2;
signed main(){
	look_memory;
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		f[i][0]=mkp(a[i],i);
		g[i][0]=lst[a[i]];
		lst[a[i]]=i;
	}
	for(int i=2;i<=n;i++) lg2[i]=lg2[i>>1]+1;
	for(int j=1;j<=21;j++)
		for(int i=1;i+(1<<j)-1<=n;i++)
			f[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]),g[i][j]=max(g[i][j-1],g[i+(1<<(j-1))][j-1]);
	solve(1,n);
	cout<<ans;
	return 0;
}

```
可以顺手切一下 [P4755 Beautiful Pair](https://www.luogu.com.cn/problem/P4755)，分治部分的思路几乎一样。

---

## 作者：_Ch1F4N_ (赞：1)

考虑判定区间是否合法，首先找一些有单调性的性质，比如说最小值为 $1$ 且不存在重复数字，不难发现，在右端点固定时，合法左端点均存在单调性，然后我们只需要判断区间内最大值是否为 $r - l + 1$ 即可，考虑扫描线，扫描线的过程中，新加入一个点时，造成的最大值变化段数为单调栈弹出次数，总量是 $O(n)$ 级别，因此可以维护出每个左端点对应区间的区间最大值，扫描的过程中给区间减去 $1$ 后便可以让左端点权值为对应区间最大值减去对应区间长度，又因为前面的判定保证了区间内至少有 $r - l + 1$ 个数，因此需要判断的左端点权值恒大于等于 $0$ 且只有在其为 $0$ 时产生贡献，考虑维护区间最小值以及最小值个数即可做到 $O(n \log n)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e6+114;
struct info{
    int val;
    int cnt;
    info(int V=0,int C=1){
        val=V;
        cnt=C;
    }
    info operator+(info b){
        if(val==b.val){
            return info(val,cnt+b.cnt);
        }else if(val>b.val) return info(val,cnt);
        else return b;
    }
}tr[maxn<<2];
int a[maxn],lst[maxn],n;
int tot[maxn];
int tag[maxn<<2];
void pushup(int cur){
    tr[cur]=tr[cur<<1]+tr[cur<<1|1];
}
void pushdown(int cur){
    tr[cur<<1].val+=tag[cur];
    tag[cur<<1]+=tag[cur];
    tr[cur<<1|1].val+=tag[cur];
    tag[cur<<1|1]+=tag[cur];
    tag[cur]=0;
}
void add(int cur,int lt,int rt,int l,int r,int c){
    if(rt<l||r<lt) return ;
    if(l<=lt&&rt<=r){
        tr[cur].val+=c;
        tag[cur]+=c;
        return ;
    }
    pushdown(cur);
    int mid=(lt+rt)>>1;
    add(cur<<1,lt,mid,l,r,c);
    add(cur<<1|1,mid+1,rt,l,r,c);
    pushup(cur);
}
int lst1;
info ask(int cur,int lt,int rt,int l,int r){
    if(l<=lt&&rt<=r) return tr[cur];
    pushdown(cur);
    int mid=(lt+rt)>>1;
    if(l<=mid&&r>mid) return ask(cur<<1,lt,mid,l,r)+ask(cur<<1|1,mid+1,rt,l,r);
    else if(l<=mid) return ask(cur<<1,lt,mid,l,r);
    else return ask(cur<<1|1,mid+1,rt,l,r);
}
long long ans;
int stk[maxn],tp;
int colL=1;
int t[maxn];
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        lst[i]=tot[a[i]];
        tot[a[i]]=i;
    }
    for(int i=1;i<=n;i++){
        if(a[i]==1) lst1=i;
        while(a[stk[tp]]<a[i]&&tp>0){
            //区间 [stk[tp-1]+1,stk[tp]] 最大值由 a[skt[tp]] 变为 a[i]
            add(1,1,n,stk[tp-1]+1,stk[tp],a[stk[tp]]);
            tp--;
        }
        add(1,1,n,stk[tp]+1,i,-a[i]);
        stk[++tp]=i;
        add(1,1,n,1,i,1);
        while(t[a[i]]!=0){
            t[a[colL]]--;
            colL++;
        }
        t[a[i]]++;
        if(colL<=lst1){
            info res=ask(1,1,n,colL,lst1);
            if(res.val==0) ans+=res.cnt;
        }
    }
    cout<<ans<<'\n';
    return 0;
}
```

---

## 作者：_AyachiNene (赞：0)

# 思路：
考虑如何确定一个区间是排列，如果一个区间的最大值等于区间长度，且没有重复数字那么这个区间显然是个排列。

发现有最大值的限制，考虑上笛卡尔树分治，每次分治时找到权值最大的点作为分治中心，那么区间长度和最大值就确定了。之后枚举区间长度较小的一边，判断每个区间是否有重复数字即可。对于判断是否有重复数字，可以先做一次扫描线，对于每一种数 $x$ 维护一个 $pre_x$，表示扫到当前位置上一次 $x$ 出现的位置，查询一个区间是否有重复数字直接用区间最小 $pre_x$ 和端点比较即可，直接用数据结构维护每个位置的 $pre_x$ 即可。

用 st 表维护即可做到 $O(n\log n)$。
# Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace IO
{
	char buff[1<<21],*p1=buff,*p2=buff;
	char getch(){return p1==p2&&(p2=((p1=buff)+fread(buff,1,1<<21,stdin)),p1==p2)?EOF:*p1++;}
	template<typename T>void read(T &x){char CH=getch();int fl=1;x=0;while(CH>'9'||CH<'0'){if(CH=='-')fl=-1;CH=getch();}while(CH<='9'&&CH>='0'){x=x*10+CH-48;CH=getch();}x*=fl;}
	template<typename T>void read_s(T &x){x="";char CH=getch();while(!(CH>='a'&&CH<='z')&&!(CH>='A'&&CH<='Z'))CH=getch();while((CH>='a'&&CH<='z')||(CH>='A'&&CH<='Z')){x+=CH;CH=getch();}}
	template<typename T,typename ...Args>void read(T &x,Args& ...args){read(x);read(args...);}
	char obuf[1<<21],*p3=obuf;
	void putch(char CH) {if(p3-obuf<(1<<21))*p3++=CH;else fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=CH;}
	char CH[100];
	template<typename T>void write(T x) {if(!x)return putch('0');if(x<0)putch('-'),x*=-1;int top=0;while(x)CH[++top]=x%10+48,x/=10;while(top)putch(CH[top]),top--;}
	template<typename T,typename ...Args>void write(T x,Args ...args) {write(x);putch(' ');write(args...);}
	void put(string s){for(int i=0;i<s.size();i++)putch(s[i]);}
	void flush(){fwrite(obuf,p3-obuf,1,stdout);}
}
using namespace IO;
int n;
int a[1000005];
#define pii pair<int,int>
#define fi first
#define se second
struct Shiki
{
	pii st[1000005][20];
	int lg[1000005];
	void bld()
	{
		for(int i=2;i<=n;i++) lg[i]=lg[i/2]+1;
		for(int j=1;j<20;j++)
			for(int i=1;i+(1<<j)-1<=n;i++) st[i][j]=max(st[i][j-1],st[i+(1<<j-1)][j-1]);
	}
	inline pii query(int l,int r)
	{
		int k=lg[r-l+1];
		return max(st[l][k],st[r-(1<<k)+1][k]);
	}
}t[2];
int p[1000005];
int ans;
void solve(int l,int r)
{
	if(l>r) return;
	if(l==r) return ans+=(a[l]==1),void();
	int p=t[0].query(l,r).se;
	if(p-l+1<=r-p)
	{
		for(int i=l;i<=p;i++) 
			if(i+a[p]-1<=r&&i+a[p]-1>=p&&t[1].query(i,i+a[p]-1).fi<i) ++ans;
	}
	else
	{
		for(int i=p;i<=r;i++) 
			if(i-a[p]+1>=l&&i-a[p]+1<=p&&t[1].query(i-a[p]+1,i).fi<i-a[p]+1) ++ans;
	}
	solve(l,p-1);solve(p+1,r);
}
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n);
	for(int i=1;i<=n;i++) 
	{
		read(a[i]);
		t[0].st[i][0]={a[i],i};
		if(p[a[i]]) t[1].st[i][0]={p[a[i]],i};
		p[a[i]]=i;
	}
	t[0].bld();t[1].bld();
	solve(1,n);
	write(ans);
	flush();
	return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P10833)

**题目大意**

> 给定长度为 $n$ 的序列 $a_1\sim a_n$，求有多少区间 $[l,r]$ 使得 $a_l\sim a_r$ 是 $1\sim r-l+1$ 的排列。
>
> 数据范围：$n\le 10^6$。

**思路分析**

考虑 CDQ 分治，我们用如下两个条件刻画一个好的区间：

- 区间最大值等于区间长度。
- 区间没有重复元素。

设当前分治区间中 $[l,mid]$ 的长度为 $i$ 的后缀最大值为 $L_i$，$[mid+1,r]$ 的长度为 $i$ 的前缀最大值为 $R_i$。

那么第一个条件等于 $i+j=\max(L_i,R_j)$，枚举 $j$ 并钦定 $R_j\ge L_i$，否则反过来类似处理，此时 $i$ 的范围是 $[l,mid]$ 的一段后缀，可以双指针求出。

我们只要判断 $i=R_j-j$ 时是否合法即可，先判定 $R_j\ge L_i$，然后就要求区间内无重复。

如果两个重复的元素都在 $[l,mid]$ 中，找出最靠右的一对相当于限制 $i$ 的下界，同理两个元素都在 $[mid+1,r]$ 中就是限制 $j$ 的上界。

然后考虑 $[mid-i+1,mid]$ 范围内不能出现和 $[mid+1,mid+j]$ 范围内相同的数。

从小到大枚举 $j$，求出每个 $a_{mid+j}$ 在左侧的首次出现，又转化成 $i$ 的下界限制，最终可以 $\mathcal O(1)$ 检验。

时间复杂度 $\mathcal O(n\log n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e6+5;
int n,ans=0,a[MAXN],mx[MAXN],lp[MAXN],rp[MAXN];
void cdq(int l,int r) {
	if(l==r) return ans+=(a[l]==1),void();
	int mid=(l+r)>>1;
	cdq(l,mid),cdq(mid+1,r);
	mx[mid]=a[mid],mx[mid+1]=a[mid+1];
	for(int i=mid-1;i>=l;--i) mx[i]=max(mx[i+1],a[i]);
	for(int i=mid+2;i<=r;++i) mx[i]=max(mx[i-1],a[i]);
	int L=l,R=r;
	for(int i=mid;i>=l;--i) {
		if(lp[a[i]]) { L=i+1; break; }
		lp[a[i]]=i;
	}
	for(int i=mid+1;i<=r;++i) {
		if(rp[a[i]]) { R=i-1; break; }
		rp[a[i]]=i;
	}
	for(int i=mid+1,j=mid+1,p=L;i<=R;++i) {
		while(j>L&&mx[j-1]<=mx[i]) --j;
		if(lp[a[i]]) p=max(p,lp[a[i]]+1);
		if(1<=mx[i]-(i-mid)&&mx[i]-(i-mid)<=mid-max(j,p)+1) ++ans;
	}
	for(int i=mid,j=mid,p=R;i>=L;--i) {
		while(j<R&&mx[j+1]<mx[i]) ++j;
		if(rp[a[i]]) p=min(p,rp[a[i]]-1);
		if(1<=mx[i]-(mid+1-i)&&mx[i]-(mid+1-i)<=min(j,p)-mid) ++ans;
	}
	for(int i=l;i<=mid;++i) lp[a[i]]=0;
	for(int i=mid+1;i<=r;++i) rp[a[i]]=0;
}
signed main() {
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%d",&a[i]);
	cdq(1,n),printf("%d\n",ans);
	return 0;
}
```

---


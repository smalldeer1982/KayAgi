# [BJOI2017] 树的难题

## 题目描述

给你一棵 $n$ 个点的无根树。

树上的每条边具有颜色。一共有 $m$ 种颜色，编号为 $1$ 到 $m$，第 $i$ 种颜色的权值为 $c_i$。

对于一条树上的简单路径，路径上经过的所有边按顺序组成一个颜色序列，序列可以划分成若干个相同颜色段。定义路径权值为颜色序列上每个同颜色段的颜色权值之和。

请你计算，经过边数在 $l$ 到 $r$ 之间的所有简单路径中，路径权值的最大值。

## 说明/提示

### 样例解释 1
颜色权值均为负，最优路径为 $(1, 2)$ 或 $(1, 3)$。

### 样例解释 2
最优路径为 $(3, 1, 2, 5, 6)$，其颜色序列为 $(2, 1, 1, 2)$。

### 数据范围
| 测试点编号 | $n$ | $m$ | 特殊限制 |
|-|-|-|-|
| $1$ | $=10^3$ | $\le n$ | 无特殊限制 |
| $2$ | $=10^4$ | $=2$ | 无特殊限制 |
| $3$ | $=10^5$ | $\le n$ | 所有点的度数不超过 $2$ |
| $4$ | $=2\times10^5$ | $\le n$ | 所有点的度数不超过 $2$ |
| $5$ | $=10^5$ | $=10$ | $l=1$，$r=n-1$ |
| $6$ | $=2\times10^5$ | $\le n$ | $l=1$，$r=n-1$ |
| $7$ | $=10^5$ | $=50$ | 无特殊限制 |
| $8$ | $=10^5$ | $\le n$ | 无特殊限制 |
| $9$ | $=2\times 10^5$ | $=100$ | 无特殊限制 |
| $10$ | $=2\times 10^5$ | $\le n$ | 无特殊限制 |

对于 $100\%$ 的数据，$1 \leq n, m \leq 2 \times 10^5$，$1 \leq l \leq r \leq n$，$\mid c_i \mid \leq 10^4$。保证树上至少存在一条经过边数在 $l$ 到 $r$ 之间的路径。

## 样例 #1

### 输入

```
5 3 1 4
-1 -5 -2
1 2 1
1 3 1
2 4 2
2 5 3```

### 输出

```
-1```

## 样例 #2

### 输入

```
8 4 3 4
-7 9 6 1
1 2 1
1 3 2
1 4 1
2 5 1
5 6 2
3 7 1
3 8 3```

### 输出

```
11```

# 题解

## 作者：Caii (赞：18)

点分治
			
以下的同色联通块以及异色联通块中的色指的是与分治中心直接相连的边的颜色
			
考虑对于一个分治中心，每种颜色单独处理，也就是对分治中心下方的每颗子树，以其同颜色联通块最大深度为第一关键字，颜色为第二关键字
排序，然后再在同色的联通块中，以深度排序得到一个遍历序列
			
这样我们就可以使用数据结构来维护同色联通块以及异色联通块的产生的贡献了
			
使用单调队列
			
异色联通块中默认存在一条权值和长度都为0的路径，而同色联通块不行
			
对同色联通块和异色联通块各开一个单调队列，单调队列
中存下当一条路径 $l$ 长度为 $x$ 时权值最大的可以与 $l$ 组成一条路径的路径权值最大值，每次在在DFS的时候更新答案

当遍历完一颗子树时，如果下一次遍历的子树颜色与这颗子树相同，那么更新同色联通块的权值，否则更新异色联通块的权值并
清空同色联通块的权值
			
注意同色联通块的单调队列里面的权值要减去分治中心直接相连的边的颜色的权值
			
时间复杂度:$O(N\log N)$

```cpp
#include <cctype>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <functional>

#define DEBUG(args...) fprintf(stderr, args)

typedef long long LL;

#define FOR(i, l, r) for(int i = (l), i##_end = (r); i <= i##_end; ++i)
#define REP(i, l, r) for(int i = (l), i##_end = (r); i <  i##_end; ++i)
#define DFR(i, l, r) for(int i = (l), i##_end = (r); i >= i##_end; --i)
#define DRP(i, l, r) for(int i = (l), i##_end = (r); i >  i##_end; --i)

template<class T>T Min(const T &a, const T &b) {return a < b ? a : b;}
template<class T>T Max(const T &a, const T &b) {return a > b ? a : b;}
template<class T>bool Chkmin(T &a, const T &b) {return a > b ? a = b, 1 : 0;}
template<class T>bool Chkmax(T &a, const T &b) {return a < b ? a = b, 1 : 0;}

class fast_input {
private:
    static const int SIZE = 1 << 15 | 1;
    char buf[SIZE], *front, *back;

    void Next(char &c) {
        if(front == back) back = (front = buf) + fread(buf, 1, SIZE, stdin);
        c = front == back ? (char)EOF : *front++;
    }

public :
    template<class T>void operator () (T &x) {
        char c, f = 1;
        for(Next(c); !isdigit(c); Next(c)) if(c == '-') f = -1;
        for(x = 0; isdigit(c); Next(c)) x = x * 10 + c - '0';
        x *= f;
    }
    void operator () (char &c, char l = 'a', char r = 'z') {
        for(Next(c); c > r || c < l; Next(c)) ;
    }
}input;

struct triple {
    int c, d, x, md;
    explicit triple(int c = 0, int d = 0, int x = 0) : c(c), d(d), x(x) {}
    bool operator < (const triple &o) const { 
        return c != o.c ? c < o.c : d < o.d;
    }
    bool operator > (const triple &o) const {
        return md != o.md ? md < o.md : c != o.c ? c < o.c : d < o.d;
    }
};

const int SN = 200000 + 47;
const int SE = 400000 + 47;
const int INF = 2000100000;

int head[SN], nxt[SE], to[SE], col[SE];
int val[SN], n, left, right;
int size[SN], max_deep[SN];
int vis[SN];
triple a[SN];
int ans;

void Add(int, int, int);
void GetSize(int, int);
int GetDeep(int, int, int);

int __size, __root, __max_size;
void GetRoot(int, int);

void Solve(int);
void DFS(int, int, int, int, int);

int main() {

#ifdef Cai
    freopen("s.in", "r", stdin);
#endif

    int x, y, z, m;

    input(n), input(m), input(left), input(right);
    FOR(i, 1, m) input(val[i]);
    FOR(i, 2, n) input(x), input(y), input(z), Add(x, y, z);

    GetSize(1, -1);
    __size = n, __max_size = INF, GetRoot(1, -1);
    ans = -INF, Solve(__root);

    if(ans < -2000000000) return printf("%d\n", -INF), 0;
    
    printf("%d\n", ans);

    return 0;

}

void Add(int x, int y, int z) {
    static int _ = 0;
    nxt[++_] = head[x], head[x] = _, to[_] = y, col[_] = z;
    nxt[++_] = head[y], head[y] = _, to[_] = x, col[_] = z;
}

void GetSize(int x, int y) {
    size[x] = 1;
    for(int i = head[x]; i; i = nxt[i])
        if(to[i] != y && !vis[to[i]]) {
            GetSize(to[i], x);
            size[x] += size[to[i]];
        }
}

int GetDeep(int x, int y, int d) {
    int max_d = d;
    for(int i = head[x]; i; i = nxt[i])
        if(to[i] != y && !vis[to[i]]) 
            Chkmax(max_d, GetDeep(to[i], x, d + 1));
    return max_d;
}

void GetRoot(int x, int y) {
    int max_size = __size - size[x];
    for(int i = head[x]; i; i = nxt[i])
        if(to[i] != y && !vis[to[i]]) {
            GetRoot(to[i], x);
            Chkmax(max_size, size[to[i]]);
        }
    if(Chkmin(__max_size, max_size)) __root = x;
}

// q0 for all
// q1 for same col
int q0[SN], f0, b0, t0[SN], v0[SN];
int q1[SN], f1, b1, t1[SN], v1[SN];
int c[SN], cc, b[SN], cb, d[SN], cd;

void Solve(int x) {
    int cnt = 0;
    GetSize(x, -1), vis[x] = 1;
    for(int i = head[x]; i; i = nxt[i])
        if(!vis[to[i]]) 
            a[++cnt] = triple(col[i], GetDeep(to[i], x, 1), to[i]);
    std::sort(a + 1, a + cnt + 1);
    DFR(i, cnt, 1)
        if(a[i].c == a[i + 1].c) a[i].md = a[i + 1].md;
        else a[i].md = a[i].d;
    std::sort(a + 1, a + cnt + 1, std::greater<triple>());
    int root_all = 0, root_col = 0;
    FOR(i, 1, a[1].md) q0[i] = q1[i] = c[i] = d[i] = v0[i] = v1[i] = -INF;
    FOR(i, left, Min(a[1].md, right)) v1[i] = 0;
    FOR(i, 1, cnt) {
        cb = 0, DFS(a[i].x, x, 1, val[a[i].c], a[i].c); // ans : updated
        //if(ans == -4) {DEBUG("%d %d\n", x, i); throw ;}
        if(a[i].c == a[i + 1].c) {
            cc = cb;
            FOR(j, 1, cb) Chkmax(c[j], b[j]);
            f0 = 0, b0 = -1, c[0] = val[a[i].c];
            DFR(j, Min(cc, right - 1), left - 1) {
                while(f0 <= b0 && q0[b0] <= c[j]) --b0;
                q0[++b0] = c[j], t0[b0] = j;
            }
            FOR(j, 1, a[i + 1].d) {
                if(f0 > b0) v0[j] = -INF;
                else v0[j] = q0[f0] - val[a[i].c]; // val[a[i].c] will be calc twice
                while(f0 <= b0 && t0[f0] + j + 1 > right) ++f0;
                if(left - j - 1 >= 0 && left - j - 1 <= cc) {
                    while(f0 <= b0 && q0[b0] <= c[left - j - 1]) --b0;
                    q0[++b0] = c[left - j - 1], t0[b0] = left - j - 1;
                }
            }
        }
        else {
            cd = cb;
            FOR(j, 1, cd) Chkmax(d[j], Max(b[j], c[j]));
            f1 = 0, b1 = -1, d[0] = 0;
            DFR(j, Min(cd, right - 1), left - 1) {
                while(f1 <= b1 && q1[b1] <= d[j]) --b1;
                q1[++b1] = d[j], t1[b1] = j;
            }
            FOR(j, 1, a[i + 1].md) {
                if(f1 > b1) v1[j] = -INF;
                else v1[j] = q1[f1];
                while(f1 <= b1 && t1[f1] + j + 1 > right) ++f1;
                if(left - j - 1 >= 0 && left - j - 1 <= cd) {
                    while(f1 <= b1 && q1[b1] <= d[left - j - 1]) --b1;
                    q1[++b1] = d[left - j - 1], t1[b1] = left - j - 1;
                }
            }
            cc = 0;
            FOR(j, 1, a[i + 1].md) c[j] = v0[j] = -INF;
            FOR(j, a[i].md + 1, a[i + 1].md) d[j] = -INF;
        }
    }
    for(int i = head[x]; i; i = nxt[i])
        if(!vis[to[i]]) {
            __size = size[to[i]], __max_size = INF, GetRoot(to[i], x);
            Solve(__root);
        }
}

void DFS(int x, int y, int deep, int v, int lc) {
    if(deep <= cb) Chkmax(b[deep], v);
    else b[cb = deep] = v;
    Chkmax(ans, v + Max(v0[deep], v1[deep]));
    for(int i = head[x]; i; i = nxt[i])
        if(to[i] != y && !vis[to[i]])
            if(col[i] == lc)
                DFS(to[i], x, deep + 1, v, lc);
            else
                DFS(to[i], x, deep + 1, v + val[col[i]], col[i]);
}

/*
g++ -o s s.cpp -O2; for((i = 1; i <= 10; ++i)) do cp journey$i.in s.in; ./s > s.out; diff journey$i.out s.out -w > s.res; echo $i : $?; done
*/

```

---

## 作者：tzc_wk (赞：14)

[洛谷题面传送门](https://www.luogu.com.cn/problem/P3714)

咦？鸽子 tzc 竟然来补题解了？incredible（

首先看到这样类似于路径统计的问题我们可以非常自然地想到点分治。每次我们找出每个连通块的重心 $x$ 然后以 $x$ 为根 DFS 一遍整个子树，我们假设 $y$ 到 $x$ 的距离为 $dep_y$，$x\to y$ 这一段上颜色的权值之和为 $sum_y$，那么考虑怎样合并两条路径。显然对于两个在 $x$ 不同子树内的点 $y,z$，$y\to z$ 路径上边的个数就是 $dep_y+dep_z$，路径上权值之和就是 $sum_y+sum_z-c_{col_y}·[col_y=col_z]$，其中 $col_y$ 为 $x\to y$ 路径上经过的第一条边的权值。看到这个 $[col_y=col_z]$ 貌似有点棘手，不过注意到我们贡献显然是一个子树一个子树计算的对吧，因此我们考虑**将 $x$ 所有子树按 $x$ 到这棵子树经过的第一条边的颜色**从小到大排序，然后维护两棵线段树，第一棵线段树上下标为 $d$ 的位置上维护 $\max\limits_{dep_y=d\land col_y\ne C}sum_y$，第二棵维护 $\max\limits_{dep_y=d\land col_y=C}sum_y$，其中 $C$ 为当前颜色种类，然后每次颜色改变就暴力地将第二棵线段树中所有元素插入第一棵线段树中即可，查询就在两棵树中分别查 $[r-dep_y,l-dep_y]$ 的最大值，记作 $mx1$ 和 $mx2$，然后用 $mx1+sum_y,mx2-c_{col_y}+sum_y$ 更新答案即可。

时间复杂度 $n\log^2n$，其中一个 $\log$ 在于点分治，一个 $\log$ 在于线段树。

最后稍微总结一下这类点分治解决树上路径计数题目的解题技巧：首先要考虑怎样合并两段路径，如果不好合并那一般使用点分治不太好解决，其次要思考如何维护两段路径的决策，比较简单的使用一个桶即可维护，比较复杂的需用 BIT/线段树/平衡树解决。对于计数问题，容斥也是一个不错的选择，即先不考虑两个端点不在同一子树这一条件，先一股脑把贡献全加上去，再扣掉在同一子树内的情况。

```cpp
const int MAXN=2e5;
const int INF=0x3f3f3f3f;
const ll INFll=0x3f3f3f3f3f3f3f3fll;
int n,m,L,R,c[MAXN+5],hd[MAXN+5],to[MAXN*2+5],val[MAXN*2+5],nxt[MAXN*2+5],ec=0;
void adde(int u,int v,int w){to[++ec]=v;val[ec]=w;nxt[ec]=hd[u];hd[u]=ec;}
int mx[MAXN+5],cent=0,siz[MAXN+5];bool vis[MAXN+5];
void findcent(int x,int f,int tot){
	mx[x]=0;siz[x]=1;
	for(int e=hd[x];e;e=nxt[e]){
		int y=to[e];if(y==f||vis[y]) continue;
		findcent(y,x,tot);siz[x]+=siz[y];
		chkmax(mx[x],siz[y]);
	} chkmax(mx[x],tot-siz[x]);
	if(mx[cent]>mx[x]) cent=x;
}
int dep[MAXN+5];ll sum[MAXN+5];
void getdep(int x,int f,int pre){
	for(int e=hd[x];e;e=nxt[e]){
		int y=to[e],z=val[e];if(y==f||vis[y]) continue;
		dep[y]=dep[x]+1;sum[y]=sum[x]+((z==pre)?0:c[z]);
		getdep(y,x,z);
	}
}
struct segtree{
	struct node{int l,r;ll mx;} s[MAXN*4+5];
	stack<int> stk;
	void pushup(int k){s[k].mx=max(s[k<<1].mx,s[k<<1|1].mx);stk.push(k);}
	void build(int k,int l,int r){
		s[k].l=l;s[k].r=r;s[k].mx=-INFll;if(l==r) return;
		int mid=l+r>>1;build(k<<1,l,mid);build(k<<1|1,mid+1,r);
	}
	void modify(int k,int p,ll v){
		if(s[k].l==s[k].r) return chkmax(s[k].mx,v),stk.push(k),void();
		int mid=s[k].l+s[k].r>>1;(p<=mid)?modify(k<<1,p,v):modify(k<<1|1,p,v);
		pushup(k);
	}
	ll query(int k,int l,int r){
		if(l>r) return -INFll;
		if(l<=s[k].l&&s[k].r<=r) return s[k].mx;
		int mid=s[k].l+s[k].r>>1;
		if(r<=mid) return query(k<<1,l,r);
		else if(l>mid) return query(k<<1|1,l,r);
		else return max(query(k<<1,l,mid),query(k<<1|1,mid+1,r));
	}
	void relax(){
		while(!stk.empty()){
			int k=stk.top();stk.pop();
			s[k].mx=-INFll;
		}
	}
} s1,s2;
vector<int> pt;
ll res=-INFll;
void findpts(int x,int f){
	pt.pb(x);
	for(int e=hd[x];e;e=nxt[e]){
		int y=to[e];if(y==f||vis[y]) continue;
		findpts(y,x);
	}
}
void divcent(int x){
//	printf("divcent %d\n",x);
	vis[x]=1;dep[x]=sum[x]=0;
	vector<pii> sub;
	for(int e=hd[x];e;e=nxt[e]){
		int y=to[e],z=val[e];if(vis[y]) continue;
		dep[y]=1;sum[y]=c[z];getdep(y,x,z);
		sub.pb(mp(z,y));
	} sort(sub.begin(),sub.end());
	vector<int> wt;s1.modify(1,0,0);
	for(int i=0;i<sub.size();i++){
		if(i&&sub[i].fi!=sub[i-1].fi){
			s2.relax();
			for(int y:wt) s1.modify(1,dep[y],sum[y]);
			wt.clear();
		} int y=sub[i].se;pt.clear();findpts(y,x);
		for(int z:pt){
			int d=dep[z];
			if(d<=R){
				chkmax(res,s1.query(1,max(L-d,0),R-d)+sum[z]);
				chkmax(res,s2.query(1,max(L-d,0),R-d)+sum[z]-c[sub[i].fi]);
			}
		} for(int z:pt) wt.pb(z),s2.modify(1,dep[z],sum[z]);
//		for(int z:pt) printf("%d %d %lld\n",z,dep[z],sum[z]);
	} s1.relax();s2.relax();
	for(int e=hd[x];e;e=nxt[e]){
		int y=to[e];if(vis[y]) continue;cent=0;
		findcent(y,x,siz[y]);divcent(cent);
	}
}
int main(){
	scanf("%d%d%d%d",&n,&m,&L,&R);s1.build(1,0,n);s2.build(1,0,n);
	for(int i=1;i<=m;i++) scanf("%d",&c[i]);
	for(int i=1,u,v,w;i<n;i++) scanf("%d%d%d",&u,&v,&w),adde(u,v,w),adde(v,u,w);
	mx[0]=INF;findcent(1,0,n);divcent(cent);
	printf("%lld\n",res);
	return 0;
}
```



---

## 作者：zero4338 (赞：7)

点分治+线段树  
首先用点分治去分割路径，问题是如何统计不同颜色。  
在点分治的时候，如果从根延伸出的两条链最上面的边的颜色不同，那么这两条链的贡献就是两条链的贡献加和，如果两条链最上面的边的颜色一样，贡献就是两条链的颜色加和减去最上面颜色的权值。  
考虑把每个点连出去的边按照颜色排序，这样在点分治的时候顶上颜色相同的链就一定会在一起被处理。用两颗线段树分别保存已经被遍历过的颜色的最大权值和当前被遍历的颜色的最大权值，在结束遍历时将当前遍历的颜色加入到已经被遍历的颜色，同时清空表示当前被遍历的颜色权值的线段树。  
常数可能有一些大  
代码细节在注释里
```
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
const int maxn=2e5+10;
int n,m,L,R;
int ans=-2e9;
int c[maxn];
struct edge
{
	int to,col;
};
bool comp_by_col(edge a,edge b){return a.col<b.col;}
vector<edge>e[maxn];
int rt,maxp[maxn],siz[maxn],nodenum;
int vis[maxn];
void getrt(int now,int last)
{
	siz[now]=1;maxp[now]=0;
	for(int i=0;i<e[now].size();i++)
	{
		int to=e[now][i].to;
		if(to==last||vis[to])continue;
		getrt(to,now);siz[now]+=siz[to];
		maxp[now]=max(maxp[now],siz[to]);
	}
	maxp[now]=max(maxp[now],nodenum-siz[now]);
	if(maxp[rt]>maxp[now])rt=now;
}
struct segmenttree
{
	struct node
	{
		int maxnum;
		int tag;
	};
	node t[maxn<<3];
	void clear()
	{
		t[1].tag=1;t[1].maxnum=-2e9;//直接在线段树根上打标记来清空线段树 
	}
	void pushdown(int u)
	{
		if(t[u].tag)
		{
			t[u<<1].tag=t[u<<1|1].tag=1;
			t[u<<1].maxnum=-2e9;t[u<<1|1].maxnum=-2e9;
			t[u].tag=0;
		}
	}
	void update(int u)
	{
		t[u].maxnum=max(t[u<<1].maxnum,t[u<<1|1].maxnum);
	}
	void change(int u,int l,int r,int p,int x)
	{
		if(l>p||r<p)return;
		if(l==r)
		{
			t[u].tag=0;//这里记得清除标记 
			t[u].maxnum=max(t[u].maxnum,x);return;
		}
		int mid=(l+r)>>1;
		pushdown(u);
		if(mid>=p)change(u<<1,l,mid,p,x);
		else change(u<<1|1,mid+1,r,p,x);
		update(u);
	}
	int query(int u,int l,int r,int nl,int nr)
	{
		if(l>nr||r<nl)return -2e9;
		if(l>=nl&&r<=nr)return t[u].maxnum;
		if(t[u].tag)return -2e9;
		pushdown(u);
		int mid=(l+r)>>1;
		return max(query(u<<1,l,mid,nl,nr),query(u<<1|1,mid+1,r,nl,nr));
	}
};
segmenttree diff,same;
int dep[maxn],nowcol;
void getdis(int u,int last,int val,int lastcol)//更新答案 
{
	dep[u]=dep[last]+1;
	if(dep[u]>R)return;
 	if(dep[u]>=L&&dep[u]<=R)ans=max(ans,val);
	ans=max(ans,max(val+same.query(1,0,n,max(0,L-dep[u]),R-dep[u])-c[nowcol],val+diff.query(1,0,n,max(0,L-dep[u]),R-dep[u])));//dep[u]可能超过L，故左端点为max(0,L-dep[u]) 
	for(int i=0;i<e[u].size();i++)
	{
		int to=e[u][i].to,tc=e[u][i].col;
		if(to==last||vis[to])continue;
		if(tc==lastcol)getdis(to,u,val,lastcol);
		else getdis(to,u,val+c[tc],tc);
	}
}
void update(int u,int last,long long val,int lastcol)//更新同一颜色的线段树 
{
	dep[u]=dep[last]+1;
	if(dep[u]>R)return;
 	same.change(1,0,n,dep[u],val);
	for(int i=0;i<e[u].size();i++)
	{
		int to=e[u][i].to,tc=e[u][i].col;
		if(to==last||vis[to])continue;
		if(tc==lastcol)update(to,u,val,lastcol);
		else update(to,u,val+c[tc],tc);
	}
}
void add(int u,int last,int val,int lastcol)//更新不同颜色的线段树 
{
	dep[u]=dep[last]+1;
	if(dep[u]>R)return;
	diff.change(1,0,n,dep[u],val);
	for(int i=0;i<e[u].size();i++)
	{
		int to=e[u][i].to,tc=e[u][i].col;
		if(to==last||vis[to])continue;
		if(tc==lastcol)add(to,u,val,lastcol);
		else add(to,u,val+c[tc],tc);
	}
}
int sta[maxn],top;//保存同一颜色的节点 
void calc(int u)
{
	diff.clear();same.clear();
	int top=0;
	dep[u]=0;//使根深度为0 
	for(int i=0;i<e[u].size();i++)
	{
		int to=e[u][i].to;
		if(vis[to])continue;
		if(i==0||e[u][i].col==e[u][i-1].col)//如果和之前颜色一样 
		{
			sta[++top]=to;continue;
		}
		nowcol=e[u][i-1].col;//记录当前所枚举子树最上端颜色 
		for(int j=1;j<=top;j++)
		{
			getdis(sta[j],u,c[e[u][i-1].col],e[u][i-1].col);
			update(sta[j],u,c[e[u][i-1].col],e[u][i-1].col);
		}
		same.clear();
		for(int j=1;j<=top;j++)
		{
			add(sta[j],u,c[e[u][i-1].col],e[u][i-1].col);
		}
		top=0;//开始记录下一种颜色 
		sta[++top]=e[u][i].to;
	}
	same.clear();
	nowcol=e[u][e[u].size()-1].col;//最后一种颜色在循环中不会被计算 
	for(int i=1;i<=top;i++)
	{
		getdis(sta[i],u,c[e[u][e[u].size()-1].col],e[u][e[u].size()-1].col);
		update(sta[i],u,c[e[u][e[u].size()-1].col],e[u][e[u].size()-1].col);
	}
	top=0;
	same.clear();diff.clear();
}
void solve(int u)
{
	vis[u]=1;calc(u);
	for(int i=0;i<e[u].size();i++)
	{
		int to=e[u][i].to;
		if(vis[to])continue;
		rt=0;maxp[rt]=n;nodenum=siz[to];
		getrt(to,u);solve(rt);
	}
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&L,&R);
	for(int i=1;i<=m;i++)scanf("%d",&c[i]);
	for(int i=1;i<=n-1;i++)
	{
		int x,y,z;scanf("%d%d%d",&x,&y,&z);
		e[x].push_back(edge{y,z});e[y].push_back(edge{x,z});
	}
	for(int i=1;i<=n;i++)sort(e[i].begin(),e[i].end(),comp_by_col);//按照颜色排序 
	rt=0;maxp[rt]=nodenum=n;
	getrt(1,0);solve(rt);
	printf("%d",ans);
	return 0;
}
```


---

## 作者：_ctz (赞：6)

[安利blog](https://ctz45562.github.io/2019/08/15/%E6%B4%9B%E8%B0%B7-P3714-BJOI2017-%E6%A0%91%E7%9A%84%E9%9A%BE%E9%A2%98/)

[传送门](https://www.luogu.org/problem/P3714)

---

某个$zz$的假做法：

先考虑颜色不在边上而是在点上的做法。

$dis(i)$表示根节点到$i$的权值，$ma(i)$表示深度为$i$的点中最大的$dis$。

在合并路径时，根节点一定被经过。这样在计算$dis$时，不算上根节点的权值，计算时直接取恰当的$ma$加上即可，单调队列维护。

用$dis$更新$ma$时，再把根节点的权值加回来。

这是颜色在点上的情况，转到颜色在边上考虑拆边为点，拆出来的点颜色为原边的颜色。

> 那原有的点的颜色呢？

它父节点指向它的边的颜色。。。

> 根节点呢？

选一条出边为其颜色。。。

> 根节点不止一条出边呢？

选一个度数为$1$的点为根节点。。。

写出来后成功喜提$20$分，发现这个做法完全是假的。。。

---

正解：

记$col(i)$为根节点到$i$的路径第一条边的颜色。

显然合并两条路径$x,y$时，若$col(x)=col(y)$需要减去$col(x)$的权值。

把$col$相同的放在一起考虑，对它们用单调队列维护，统计答案时减去该颜色的权值。

对$col$不同的还是单调队列，直接加起来统计。

为保证复杂度，不同$col$之间按包含路径中最大深度排序，优先处理深度小的。

同样地，相同$col$内部也优先处理深度小的。

统计时还要把深度相同的放一块处理，用$bfs$消去排序的$\log$。

这样每次分治的复杂度为当前树大小。

总复杂度$O(n\log n)$。

~~话说我就对个拍hack掉了所有有代码的题解。。。~~

代码：

``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <vector>

#define maxn 200005
#define inf 0x3f3f3f3f

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
struct Monoqueue{
	int l1[maxn],l2[maxn],head,tail;
	void clear(){head=1,tail=0;}
	void check(int x){
		while(head<=tail&&l1[head]>x)++head;
	}
	void push(int pos,int d){
		if(d==-inf)return;
		while(head<=tail&&l2[tail]<d)--tail;
		l1[++tail]=pos,l2[tail]=d;
	}
	int front(){
		if(head<=tail)return l2[head];
		return -inf;
	}
}q1,q2;
struct edge{
	int pre,to,l;
}e[maxn<<1];
int md[maxn],mmd[maxn],siz[maxn],v[maxn],c[maxn],h[maxn],col[maxn],L,R,mx,root,all,num,head,tail,ans;
int f[maxn],line[maxn],deep[maxn],dis[maxn],sma[maxn],srec[maxn],dma[maxn];
vector<int>poi[maxn];
bool vis[maxn];
inline bool cmp1(int x,int y){return md[x]<md[y];}
inline bool cmp2(int x,int y){return mmd[x]<mmd[y];}
inline void add(int from,int to,int l){
	e[++num].pre=h[from],h[from]=num,e[num].to=to,e[num].l=l;
}
void getroot(int node,int fa){
	siz[node]=1;
	int x,ma=0;
	for(register int i=h[node];i;i=e[i].pre){
		x=e[i].to;
		if(x==fa||vis[x])continue;
		getroot(x,node),siz[node]+=siz[x],ma=max(ma,siz[x]);
	}
	ma=max(ma,all-siz[node]);
	if(ma<mx)mx=ma,root=node;
}
void bfs(int node){
	int x,y;
	head=0,line[tail=1]=node,deep[node]=1;
	while(head<tail){
		x=line[++head];
		if(deep[x]>R){md[node]=R;return;}
		for(register int i=h[x];i;i=e[i].pre){
			y=e[i].to;
			if(y==f[x]||vis[y])continue;
			c[y]=e[i].l,f[y]=x,line[++tail]=y,deep[y]=deep[x]+1;
		}	
	}
	md[node]=deep[line[tail]];
}
void calc(int node,int m){
	q2.clear();
	for(register int i=m;i>=L;--i)q2.push(i,sma[i]);
	int x,y,l,r;
	head=0,line[tail=1]=node;
	while(head<tail){
		x=line[++head];
		if(deep[x]>R)return;
		dis[x]=dis[f[x]]+v[c[x]]*bool(c[x]^c[f[x]]);
		srec[deep[x]]=max(srec[deep[x]],dis[x]);
		for(register int i=h[x];i;i=e[i].pre){
			y=e[i].to;
			if(y==f[x]||vis[y])continue;
			line[++tail]=y;
		}
		if(head==tail||deep[x]!=deep[line[head+1]]){
			l=L-deep[x],r=R-deep[x];
			q2.check(r);
			if(l>=0)q2.push(l,sma[l]);
			ans=max(ans,q2.front()+srec[deep[x]]-dis[node]);
		}
	}
}
void solve(int node){
	int x,y,z,len=0;
	vis[node]=1;
	for(register int i=h[node];i;i=e[i].pre){
		x=e[i].to;
		if(vis[x])continue;
		if(poi[e[i].l].empty())col[++len]=e[i].l,mmd[e[i].l]=0;
		c[x]=e[i].l,f[x]=node,poi[c[x]].push_back(x),bfs(x);
		mmd[c[x]]=max(mmd[c[x]],md[x]);
	}
	c[node]=dis[node]=0;
	sort(col+1,col+1+len,cmp2);
	y=mmd[col[len]];
	for(register int i=1;i<=len;++i){
		x=col[i],z=0;
		sort(poi[x].begin(),poi[x].end(),cmp1);
		for(vector<int>::iterator iter=poi[x].begin();iter!=poi[x].end();++iter){
			dis[*iter]=v[x],calc(*iter,z);
			for(register int j=z=md[*iter];j;--j)
				sma[j]=max(sma[j],srec[j]),srec[j]=-inf;
		}
		q1.clear();
		for(register int j=mmd[col[i-1]];j>=L;--j)q1.push(j,dma[j]);
		for(register int j=1;j<=mmd[x];++j){
			q1.check(R-j);
			if(L>=j)q1.push(L-j,dma[L-j]);
			ans=max(q1.front()+sma[j],ans);
		}
		for(register int j=mmd[x];j;--j)
			dma[j]=max(dma[j],sma[j]),sma[j]=-inf;
		poi[x].clear();
	}
	for(register int i=y;i;--i)dma[i]=-inf;
	for(register int i=h[node];i;i=e[i].pre){
		x=e[i].to;
		if(vis[x])continue;
		root=0,all=siz[x],mx=inf,getroot(x,node),solve(root);
	}
}
int main(){
	memset(sma,~0x3f,sizeof sma);
	memset(srec,~0x3f,sizeof srec);
	memset(dma,~0x3f,sizeof dma);
	ans=-inf,dma[0]=0;
	int n=read(),m=read(),x,y,z;
	L=read(),R=read();
	for(register int i=1;i<=m;++i)v[i]=read();
	for(register int i=1;i<n;++i)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z);
	mx=inf,all=n,getroot(1,0),solve(root);
	printf("%d\n",ans);
}
```



---

## 作者：Itst (赞：4)

**Update On 20200714: 修复了代码中的问题，现在可以通过 Hack 数据；修改了部分题解描述。**

---

路径统计问题考虑点分治，从分治中心出发得到若干路径，重点是合并。两条路径的起始边如果颜色相同，它们的贡献需要减掉两条路径起始边颜色的权值，否则贡献就是两条路径的权值和。

考虑分开处理这两种不同的贡献。对于确定的分治中心，将其所有出边按颜色排序依次 dfs，目的是让颜色相同的若干路径一起处理。维护两棵线段树，以路径长度为下标分别维护路径起始边颜色与当前颜色相同/不同的路径权值最大值。

遍历的时候先搜出所有路径，对于每一条路径在两棵线段树上分别查询得到其贡献，然后将它们插入到线段树中。当正在做的颜色变成不同的颜色时，将这两棵线段树用线段树合并合并信息。复杂度 $O(n \log^2 n)$。

```
#include<bits/stdc++.h>
using namespace std;

#define sz(x) (int)x.size()
const int INF = 2e9 + 1 , _ = 2e5 + 7; int N , M , L , R , col[_];
struct Edge{int end , upEd , c;}Ed[_ << 1]; int head[_] , cntEd;
void addEd(int a , int b , int c){Ed[++cntEd] = (Edge){b , head[a] , c}; head[a] = cntEd;}

int nsz , msz , id; bool vis[_];
void getsz(int x){++nsz; vis[x] = 1; for(int i = head[x] ; i ; i = Ed[i].upEd) if(!vis[Ed[i].end]) getsz(Ed[i].end); vis[x] = 0;}
int getrt(int x){
	int sz = 1 , mx = 0; vis[x] = 1;
	for(int i = head[x] ; i ; i = Ed[i].upEd) if(!vis[Ed[i].end]){int t = getrt(Ed[i].end); mx = max(mx , t); sz += t;}
	mx = max(mx , nsz - sz); if(mx < msz){msz = mx; id = x;} vis[x] = 0; return sz;
}

#define mid ((l + r) >> 1)
const int __ = _ << 6; int ch[__][2] , mx[__] , cnt;
int alloc(){++cnt; mx[cnt] = -INF; ch[cnt][0] = ch[cnt][1] = 0; return cnt;}

void ins(int &x , int l , int r , int t , int v){
	x = x ? x : alloc(); mx[x] = max(mx[x] , v); if(l != r) mid >= t ? ins(ch[x][0] , l , mid , t , v) : ins(ch[x][1] , mid + 1 , r , t , v);
}

int qry(int x , int l , int r , int L , int R){
	if(!x) return -INF;
	if(l >= L && r <= R) return mx[x];
	int mx = -INF; if(mid >= L) mx = qry(ch[x][0] , l , mid , L , R);
	if(mid < R) mx = max(mx , qry(ch[x][1] , mid + 1 , r , L , R));
	return mx;
}

int merge(int p , int q){
	if(!p || !q) return p + q;
	mx[p] = max(mx[p] , mx[q]); ch[p][0] = merge(ch[p][0] , ch[q][0]); ch[p][1] = merge(ch[p][1] , ch[q][1]); return p;
}

int ans = -INF , r1 , r2; vector < pair < int , int > > rte;
void qroute(int x , int l , int c , int val){
	if(l > R) return;
	rte.push_back(make_pair(l , val)); vis[x] = 1;
	for(int i = head[x] ; i ; i = Ed[i].upEd) if(!vis[Ed[i].end]) qroute(Ed[i].end , l + 1 , Ed[i].c , c == Ed[i].c ? val : val + col[Ed[i].c]);
	vis[x] = 0;
}

void solve(int x){
	nsz = 0; msz = 1e9; getsz(x); getrt(x); x = id; cnt = r1 = r2 = 0; ins(r1 , 0 , N , 0 , 0); vis[x] = 1;
	vector < pair < int , int > > ch; for(int i = head[x] ; i ; i = Ed[i].upEd) if(!vis[Ed[i].end]) ch.push_back(make_pair(Ed[i].c , Ed[i].end));
	sort(ch.begin() , ch.end());
	for(int i = 0 ; i < sz(ch) ; ++i){
		if(i && ch[i].first != ch[i - 1].first){r1 = merge(r1 , r2); r2 = 0;}
		rte.clear(); qroute(ch[i].second , 1 , ch[i].first , col[ch[i].first]);
		for(int j = 0 ; j < sz(rte) ; ++j)
			ans = max(ans , max(qry(r1 , 0 , N , max(0 , L - rte[j].first) , R - rte[j].first) ,
								qry(r2 , 0 , N , max(0 , L - rte[j].first) , R - rte[j].first) - col[ch[i].first]) + rte[j].second);
		for(int i = 0 ; i < sz(rte) ; ++i) ins(r2 , 0 , N , rte[i].first , rte[i].second);
	}
	for(int i = 0 ; i < sz(ch) ; ++i) solve(ch[i].second);
}

int main(){
	ios::sync_with_stdio(0); cin >> N >> M >> L >> R; for(int i = 1 ; i <= M ; ++i) cin >> col[i];
	for(int i = 1 ; i < N ; ++i){int p , q , c; cin >> p >> q >> c; addEd(p , q , c); addEd(q , p , c);}
	solve(1); cout << ans; return 0;
}
```

---

## 作者：hzoi_liuchang (赞：4)

## 分析
路径问题考虑点分治

对于一个分治中心，我们可以很容易地得到从它开始的一条路径的价值和长度

问题就是如何将不同的路径合并

很显然，对于同一个子树中的所有路径，它们起始的颜色是相同的

因此我们可以将一个节点的所有子结点按照颜色排序

这个可以在建图之前处理好

然后开两个权值线段树，以路径的长度作为下标

一棵存储与当前节点起始颜色相同的所有路径，另一棵存储起始颜色不同的所有路径

对于长度为 $i$ 的路径，我们直接查询区间 $[l-i,r-i]$ 的最大值即可

当节点的颜色改变时，把相同的那一堆合并到另一堆即可

时间复杂度 $nlog^2n$

## 代码
``` cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector>
#define rg register
inline int read(){
	rg int x=0,fh=1;
	rg char ch=getchar();
	while(ch<'0' || ch>'9'){
		if(ch=='-') fh=-1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9'){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*fh;
}
const int maxn=4e5+5;
int h[maxn],tot=1,n,m,lef,rig,val[maxn];
struct asd{
	int to,nxt,val;
}b[maxn];
void ad(rg int aa,rg int bb,rg int cc){
	b[tot].to=bb;
	b[tot].nxt=h[aa];
	b[tot].val=cc;
	h[aa]=tot++;
}
int siz[maxn],maxsiz[maxn],rt,totsiz;
bool vis[maxn];
void getroot(rg int now,rg int lat){
	siz[now]=1,maxsiz[now]=0;
	for(rg int i=h[now];i!=-1;i=b[i].nxt){
		rg int u=b[i].to;
		if(u==lat || vis[u]) continue;
		getroot(u,now);
		siz[now]+=siz[u];
		maxsiz[now]=std::max(maxsiz[now],siz[u]);
	}
	maxsiz[now]=std::max(maxsiz[now],totsiz-siz[now]);
	if(maxsiz[now]<maxsiz[rt]) rt=now;
}
struct trr{
	int lch,rch,val;
	trr(){
		lch=rch=0;
		val=-0x3f3f3f3f;//一定要初始化成无穷小
	}
}tr[maxn*40];
int cnt,rt1,rt2,tp,ans=-0x3f3f3f3f;
void push_up(rg int da){
	tr[da].val=std::max(tr[tr[da].lch].val,tr[tr[da].rch].val);
}
int xg(rg int da,rg int l,rg int r,rg int wz,rg int val){
	if(!da){
		da=++cnt;
		tr[da].lch=tr[da].rch=0,tr[da].val=-0x3f3f3f3f;
	}
	if(l==r){
		tr[da].val=std::max(tr[da].val,val);
		return da;
	}
	rg int mids=(l+r)>>1;
	if(wz<=mids) tr[da].lch=xg(tr[da].lch,l,mids,wz,val);
	else tr[da].rch=xg(tr[da].rch,mids+1,r,wz,val);
	push_up(da);
	return da;
}
int bing(rg int aa,rg int bb,rg int l,rg int r){
	if(!aa || !bb) return aa+bb;
	if(l==r){
		tr[aa].val=std::max(tr[aa].val,tr[bb].val);
		tr[bb].val=-0x3f3f3f3f;
		return aa;
	}
	rg int mids=(l+r)>>1;
	tr[aa].lch=bing(tr[aa].lch,tr[bb].lch,l,mids);
	tr[aa].rch=bing(tr[aa].rch,tr[bb].rch,mids+1,r);
	push_up(aa);
	return aa;
}
int cx(rg int da,rg int l,rg int r,rg int nl,rg int nr){
	if(!da || l>r) return -0x3f3f3f3f;
	if(l>=nl && r<=nr) return tr[da].val;
	rg int mids=(l+r)>>1,nans=-0x3f3f3f3f;
	if(nl<=mids) nans=std::max(nans,cx(tr[da].lch,l,mids,nl,nr));
	if(nr>mids) nans=std::max(nans,cx(tr[da].rch,mids+1,r,nl,nr));
	return nans;
}
struct jie{
	int val,dep;
	jie(){}
	jie(rg int aa,rg int bb){
		val=aa,dep=bb;
	}
}sta[maxn];
bool cmp(rg jie aa,rg jie bb){
	return aa.val>bb.val;
}
std::vector<jie> g[maxn];
void dfs(rg int now,rg int lat,rg int nval,rg int ndep,rg int latcol){
	if(ndep>rig) return;
	sta[++tp]=jie(nval,ndep);
	for(rg int i=h[now];i!=-1;i=b[i].nxt){
		rg int u=b[i].to;
		if(u==lat || vis[u]) continue;
		dfs(u,now,(latcol==b[i].val)?nval:nval+val[b[i].val],ndep+1,b[i].val);
	}
}
void solve(rg int now){
	vis[now]=1;
	rt1=rt2=cnt=0;
	rg int latcol=0,jud=0;
	for(rg int i=h[now];i!=-1;i=b[i].nxt){
		rg int u=b[i].to;
		if(!vis[u]){
			tp=jud=0;
			dfs(u,now,val[b[i].val],1,b[i].val);
			if(b[i].val==latcol) jud=1;
			else {
				rt1=bing(rt1,rt2,1,n);
				rt2=0;
			}
			for(rg int j=1;j<=tp;j++){
				if(jud) ans=std::max(ans,cx(rt2,1,n,std::max(1,lef-sta[j].dep),rig-sta[j].dep)+sta[j].val-val[latcol]);
				ans=std::max(ans,cx(rt1,1,n,std::max(1,lef-sta[j].dep),rig-sta[j].dep)+sta[j].val);
				if(sta[j].dep>=lef && sta[j].dep<=rig) ans=std::max(ans,sta[j].val);
			}
			for(rg int j=1;j<=tp;j++) rt2=xg(rt2,1,n,sta[j].dep,sta[j].val);
			latcol=b[i].val;
		}
	}
	for(rg int i=h[now];i!=-1;i=b[i].nxt){
		rg int u=b[i].to;
		if(!vis[u]){
			totsiz=siz[u],rt=0;
			getroot(u,now);
			solve(rt);
		}
	}
}
int main(){
	memset(h,-1,sizeof(h));
	n=read(),m=read(),lef=read(),rig=read();
	for(rg int i=1;i<=m;i++) val[i]=read();
	rg int aa,bb,cc;
	for(rg int i=1;i<n;i++){
		aa=read(),bb=read(),cc=read();
		g[aa].push_back(jie(cc,bb)),g[bb].push_back(jie(cc,aa));
	}
	for(rg int i=1;i<=n;i++) std::sort(g[i].begin(),g[i].end(),cmp);
	for(rg int i=1;i<=n;i++){
		for(rg int j=0;j<g[i].size();j++){
			ad(i,g[i][j].dep,g[i][j].val);
		}
	}
	maxsiz[0]=0x3f3f3f3f,rt=0,totsiz=n;
	getroot(1,0);
	solve(rt);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：nosta (赞：4)

选一个点x作为分治中心，拼接x出发到子树各点的（半）路径。

对于拼接时两段接口处（即x连出的那条边，若没有，设为0号边：颜色为0，长度为0，到达0号儿子）颜色的影响，可以记录每段的路径权值、边数以及该段的接口，将所有的路径以接口颜色为第一关键字，接口编号为第二关键字排序。显然，对于同一接口的路径必为连续的一段序列。

这样枚举每个路径，找到之前出现的符合边数和的要求的最大的路径权值即可。用两颗线段树维护，一棵维护与本路径不同颜色的，一颗维护与本路径颜色相同但接口不同的（因为简单路径的拼接要满足两个端点不在同一个子树内）。

时间复杂度 O(nlognlogn)

~~常数巨大，需要吸氧和c++11 对不起呀~~

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e5+10;
const int M=4e5+10;
const int inf=0x3f3f3f3f;

int n,m,L,R;
int c[N],head[N],to[M],clr[M],last[M];
int sum,top,rt,fiz[N],siz[N];
bool ban[N];

struct Seg {
	int dis,num,bel;
} p[N];

struct Rmq {
	#define ls (x<<1)
	#define rs (x<<1|1)
	int val[N<<2];
	bool tag[N<<2];
	void clear() {
		val[1]=-inf;
		tag[1]=1;
	}
	void pushDown(int x) {
		val[ls]=-inf,tag[ls]=1;
		val[rs]=-inf,tag[rs]=1;
		tag[x]=0;
	}
	void modify(int x,int l,int r,int p,int w) {
		if(l==r) return void(val[x]=w);
		int mid=(l+r)>>1;
		val[x]=max(val[x],w);
		if(tag[x]) pushDown(x);
		if(p<=mid) modify(ls,l,mid,p,w);
		else modify(rs,mid+1,r,p,w);
	}
	int query(int x,int l,int r,int L,int R) {
		if(L<=l && r<=R) return val[x];
		int mid=(l+r)>>1, ret=-inf;
		if(tag[x]) return ret;
		if(L<=mid) ret=max(ret,query(ls,l,mid,L,R));
		if(mid<R) ret=max(ret,query(rs,mid+1,r,L,R));
		return ret;
	}
	inline void modify(int p,int w) {
		modify(1,1,n+1,p+1,w);
	}
	inline int query(int L,int R) {
		if(R<L || R<0) return -inf;
		return query(1,1,n+1,L+1,R+1);
	}
	#undef ls 
	#undef rs
} A,B;

void addEdge(int x,int y,int c) {
	static int cnt=0;
	to[++cnt]=y;
	clr[cnt]=c;
	last[cnt]=head[x];
	head[x]=cnt;
}
void getRoot(int x,int pa) {
	fiz[x]=0,siz[x]=1;
	for(int i=head[x]; i; i=last[i]) {
		if(to[i]==pa||ban[to[i]]) continue;
		getRoot(to[i],x);
		siz[x]+=siz[to[i]];
		fiz[x]=max(fiz[x],siz[to[i]]);
	}
	fiz[x]=max(fiz[x],sum-siz[x]);
	if(fiz[x]<fiz[rt]) rt=x;
} 
int ans=-2e9;
void getDis(int x,int pa,int dis,int num,int pClr,int bel) {
	p[++top]=(Seg){dis,num,bel};
	for(int i=head[x]; i; i=last[i]) {
		if(to[i]==pa||ban[to[i]]) continue;
		if(pClr==clr[i]) getDis(to[i],x,dis,num+1,clr[i],bel);
		else getDis(to[i],x,dis+c[clr[i]],num+1,clr[i],bel);
	}
}
void calc(int x) {
	p[top=1]=(Seg){0,0,0};
	for(int i=head[x]; i; i=last[i]) {
		if(ban[to[i]]) continue;
		getDis(to[i],x,c[clr[i]],1,clr[i],i);
	}
	sort(p+1,p+top+1,[=](Seg x,Seg y){
		if(clr[x.bel]!=clr[y.bel]) return clr[x.bel]<clr[y.bel];
		return x.bel<y.bel; 
	});
	A.clear();
	B.clear(); 
	for(int l=1,r; l<=top; l=r+1) {
		for(r=l; r<top && clr[p[l].bel]==clr[p[r+1].bel]; ++r);
		for(int x=l,y; x<=r; x=y+1) {
			for(y=x; y<r && p[x].bel==p[y+1].bel; ++y);
			if(x!=l) for(int i=x; i<=y; ++i) 
				ans=max(ans,p[i].dis+B.query(L-p[i].num,R-p[i].num)-c[clr[p[i].bel]]);
			for(int i=x; i<=y; ++i) B.modify(p[i].num,p[i].dis);
		}
		B.clear();
		if(l!=1) for(int i=l; i<=r; ++i) 
			ans=max(ans,p[i].dis+A.query(L-p[i].num,R-p[i].num));
		for(int i=l; i<=r; ++i) A.modify(p[i].num,p[i].dis);
	}
}
void solveAt(int x) {
	ban[x]=true;
	calc(x);
	for(int i=head[x]; i; i=last[i]) {
		if(ban[to[i]]) continue;
		rt=0;
		sum=siz[to[i]];
		getRoot(to[i],x);
		solveAt(rt);
	}
}

int main() {
	scanf("%d%d%d%d",&n,&m,&L,&R);
	for(int i=1; i<=m; ++i) scanf("%d",&c[i]);
	for(int x,y,c,i=n; --i; ) {
		scanf("%d%d%d",&x,&y,&c);
		addEdge(x,y,c);
		addEdge(y,x,c);
	}
	rt=0;
	sum=n;
	fiz[0]=2e9;
	getRoot(1,0);
	solveAt(rt);
	printf("%d\n",ans);
	return 0;
} 
```

---

## 作者：Rui_R (赞：3)

题目大意：一棵树上，每条边有颜色，每种颜色有权值。求所有长度在 $l,r$ 之间的路径中，路径权值的最大值。

此处路径权值意为：由路径上的边组成一个颜色序列，该序列上每个同颜色段的权值和。

[原题](https://www.luogu.com.cn/problem/P3714)

不错的点分治练习题。

考虑若确定一条路径的LCA，如何求所有以该点为LCA的路径中，满足题意的路径权值最大值？

我们可以迅速想到一个naive的东西：求出一棵子树中，每种长度的链权值的 $\max$ ，然后将它与之前已求得的对应长度的链权值的 $\max$ 合并来更新答案。

具体来说就是枚举该子树中路径长度为 $p$ 的链，那么与已求得的链中长在 $l-p,r-p$ 之间的最大值合并，尝试更新答案。

这个 $\max$ 可以用数据结构维护出来。

但现在有一个问题，就是不能简单的合并链：如果两条链到LCA的边颜色相同，答案要减掉该颜色的权值。

那么，难道我们要把已求得的链按到LCA的颜色分成 $m$ 类吗？那样怕不是会时空双双爆炸。

不用。注意到，对于一棵子树来说，之前已求得的路径权值仅有两种：与它到LCA颜色相同的，和与它到LCA颜色不相同的。

于是有了一个想法：**将所有儿子按到LCA颜色排序，从而使颜色相同的被放在一起。**

那么把已求得的路径按颜色分类：与当前颜色不同的，和与当前颜色相同的。

每次若发现颜色改变，把“相同的”那一类全部并到“不同的”那一类中。

那么，来决定使用的数据结构：支持询问区间最值，支持“合并”。

线段树喽。

不过，这道题比起合并，直接硬改会更优秀，因为线段树合并更适用于动态开点的情况。

解决了确定LCA情况下的问题，再加上点分治，就等于解决了这道题。

总复杂度 $O(n \log^2n)$，在洛谷近日评测机跑得飞快的情况下拿到了最优解第二名。

~~然而把以前大佬$O(n \log n)$的代码交上去跑得更快。~~

$\texttt{Talk is cheap,show me your code.}$

```
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstdlib>

const int maxn=2e5+5,inf=2e9+7;
int n,m,l,r,col[maxn],T_1[maxn],T_2[maxn];

template<typename T> inline T max(T a,T b){
	return a>b?a:b;
}

template<typename T> inline T min(T a,T b){
	return a<b?a:b;
}

struct IO{
	IO(){};char c;
	inline char gc(){
		static char buf[maxn],*p1=buf,*p2=buf;
		return p1==p2&&(p2=(p1=buf)+fread(buf,1,maxn,stdin),p1==p2)?EOF:*p1++;
	}
	inline IO&operator>>(int &_){
		_=0;bool f=1;c=gc();while(c<'0'||c>'9'){if(c=='-') f=0; c=gc();}
		while(c>='0'&&c<='9'){_=_*10+c-48;c=gc();}if(!f) _=-_;return *this;
	}
}io;

struct Sgt{
	#define null 0
	struct node{
		node *l,*r;int maxx;
		node(){l=r=null;maxx=-inf;}
		void push_up(){
			if(!l) return;
			maxx=max(l->maxx,r->maxx);
		}
	}*rt,*p;
	Sgt(){rt=null,p=(node*)std::malloc(sizeof(node)*maxn*2);}
	node *build(node *now,int l,int r,int data[]){
		if(!now) now=p++;
		if(l==r){now->maxx=data[l];return now;}
		int mid=(l+r)>>1;
		now->l=build(now->l,l,mid,data),now->r=build(now->r,mid+1,r,data);
		return now->push_up(),now;
	}
	void modify(int _l,int _r,node *now,int l,int r,int data[]){
		if(_l>r||_r<l) return;
		if(l==r){now->maxx=data[l];return;}
		int mid=(l+r)>>1;
		modify(_l,_r,now->l,l,mid,data),modify(_l,_r,now->r,mid+1,r,data);
		return now->push_up();//此处意为将_l,_r范围内的结点，按data数组更新
	}
	inline int wonder(int _l,int _r,node *now,int l,int r){
		if(l>_r||r<_l) return -inf;if(_l<=l&&r<=_r) return now->maxx;
		int mid=(l+r)>>1;
		return max(wonder(_l,_r,now->l,l,mid),wonder(_l,_r,now->r,mid+1,r));
	}
}S_1,S_2;

namespace Tree{
	struct edge{
		int v,nxt,w;
		bool operator<(const edge _Comp)const{
			return w<_Comp.w;
		}
	}e[maxn<<1];
	int fir[maxn],edge_cnt;
	inline void add_edge(int u,int v,int w){
		e[++edge_cnt].nxt=fir[u];e[edge_cnt].v=v,e[edge_cnt].w=w;fir[u]=edge_cnt;
	}
}using namespace Tree;

int size[maxn],rt,mas;bool vis[maxn];
int sum_size,dep[maxn],max_dep,dis[maxn];int ans=-inf;//这里初始成0的话，恭喜，你会被hack掉,毕竟答案有可能为负，之后初始化数组时同理

void dfs_rt(int now,int fa){
	size[now]=1;int temp=0;
	for(int i=fir[now];i;i=e[i].nxt){
		int v=e[i].v;if(v==fa||vis[v]) continue;
		dfs_rt(v,now);size[now]+=size[v];
		temp=max(temp,size[v]);
	}
	temp=max(temp,sum_size-size[now]);
	if(temp<mas) rt=now,mas=temp;//重心
}

void dfs_dis(int now,int fa,int las_col,int DIS){
	max_dep=max(max_dep,dep[now]);//确定当前子树深度
	dis[dep[now]]=max(dis[dep[now]],DIS);
	for(int i=fir[now];i;i=e[i].nxt){
		int v=e[i].v;if(v==fa||vis[v]) continue;
		dep[v]=dep[now]+1;dfs_dis(v,now,e[i].w,DIS+(e[i].w!=las_col?col[e[i].w]:0));
	}//得到当前子树的链信息
}

void dfs_lim(int now,int fa,int dep,int &lim){
	lim=max(lim,dep);
	for(int i=fir[now];i;i=e[i].nxt){
		int v=e[i].v;if(v==fa||vis[v]) continue;
		dfs_lim(v,now,dep+1,lim);
	}//为了确定线段树要开多大，这里算出来最长的链有多长
	//这个函数其实用dfs_dis实现，但这样应该会稍微快一点
}

void solve(int now){
	std::vector<edge> ev;int maxx=0,lim=0;
	for(int i=fir[now];i;i=e[i].nxt){
		ev.push_back(e[i]);
	}
	std::sort(ev.begin(),ev.end());//按颜色排序
	dfs_lim(now,0,0,lim);lim++;//求最深子树，决定线段树大小
	for(int i=1;i<=lim;i++) T_1[i]=T_2[i]=dis[i]=-inf;//T_1->颜色不同，T_2->颜色相同
	S_1.rt=S_1.build(S_1.rt,1,lim,T_1),S_2.rt=S_2.build(S_2.rt,1,lim,T_2);
	for(int i=0,v=ev[0].v;i<ev.size()&&(v=ev[i].v);i++){
		if(vis[v]) continue;
		max_dep=0,dep[v]=1;dfs_dis(v,now,ev[i].w,col[ev[i].w]);
		if(i&&ev[i].w!=ev[i-1].w){
			for(int i=1;i<=maxx&&i<=r;i++) T_1[i]=max(T_1[i],T_2[i]),T_2[i]=-inf;
			S_1.modify(1,maxx,S_1.rt,1,lim,T_1),S_2.modify(1,maxx,S_2.rt,1,lim,T_2);//硬改
			maxx=0;
		}
		for(int p=1;p<r&&p<=max_dep;p++){
			int _l=l-p,_r=r-p;if(_l<=0) _l=1;//说不定p>l。为什么不改成0？因为我会特判链，这里没必要去管链的部分
			ans=max(ans,S_1.wonder(_l,r-p,S_1.rt,1,lim)+dis[p]);
			ans=max(ans,S_2.wonder(_l,r-p,S_2.rt,1,lim)+dis[p]-col[ev[i].w]);//减去当前颜色权值
		}
		for(int i=1;i<=max_dep&&i<=r;i++) T_2[i]=max(T_2[i],dis[i]),dis[i]=-inf;
		S_2.modify(1,max_dep,S_2.rt,1,lim,T_2);maxx=max(maxx,max_dep);//maxx表示与当前同颜色的链中，最深的链有多深
	}
	ans=max(ans,S_1.wonder(l,min(r,lim),S_1.rt,1,lim));
	ans=max(ans,S_2.wonder(l,min(r,lim),S_2.rt,1,lim));//特殊处理链的情况，注意要把r,lim取min
}

void divide(int now){
	vis[now]=1;solve(now);
	for(int i=fir[now];i;i=e[i].nxt){
		int v=e[i].v;if(vis[v]) continue;
		sum_size=size[v],mas=inf;
		dfs_rt(v,now);divide(rt);
	}//点分治
}

int main(){
	io>>n>>m>>l>>r;for(int i=1;i<=m;i++) io>>col[i];
	for(int i=2;i<=n;i++){
		int u,v,w;io>>u>>v>>w;
		add_edge(u,v,w),add_edge(v,u,w);
	}
	sum_size=n,mas=inf;dfs_rt(1,0);
	divide(rt);printf("%d\n",ans);
	return 0;
}
```

---

## 作者：冷月冰瞳 (赞：3)

以节点 1 为根建树，然后对每个节点 p ，求出所有以节点 p 为转折点的最大权值路径。


对每个节点 x ，计算节点深度 d[x] ，和父节点的边的颜色 e[x] 和 1 到 x 的路径权值 s[x]（同题中所定义）。然后每个节点维护包含自己子树所有节点的、按 d[x] 排序的平衡树。如果不考虑合并同颜色段的问题，那么可以用启发式合并（后面的合并都为启发式合并）直接处理，即拆节点个数少的平衡树，然后对这些节点查询完之后，全部插入另一个平衡树中。


在考虑同颜色段的情况下，首先我们先把相同颜色（节点 p 和子节点的边的颜色）子节点合并。设节点 x 和 y 分别来自同颜色 z 的不同子节点的树，那么路径 x – y 的权值为 (s[x] – s[p]) + (s[y] – s[p]) – c[z]，其中 s[x] – s[p] 表示 x – p 的路径权值，由于颜色 z 被加了两遍，所以需要减掉一遍。但是如果颜色 z 和 e[p] 相同，那么 s[x] – s[p] 就不包含这部分 c[z] 了，所以需要额外加上一次，因此这个情况 x – y 的路径权值就变为 (s[x] – s[p]) + (s[y] – s[p]) + c[z]。


合并完同颜色的之后，再将不同颜色的合并。但是也要额外考虑颜色 e[p]。因为 e[p] 的那些节点，需要额外加一次 c[e[p]]。处理方法就是把这个颜色的最后合并进去。


时间复杂度 O(n log^2 n)，空间复杂度 O(n)。


---

## 作者：KokiNiwa (赞：2)

# [BJOI 2017] 树的难题

## 题目叙述

给你一颗树，每个边有一个权值，一条路径的权值定义为这条路径的颜色块（连在一起都是一个颜色的一部分）每个颜色快的那个颜色的权值和。

## 题解

+ 考虑分治重心为$k$的时候。由于求最大值，所以不能容斥，所以考虑给每个点染色（染他是哪个子树的），记录这个点到$k$的路径上最靠上的一条边的颜色。
+ 考虑如何合并路径。将这个剩下的一堆半链按照最顶端颜色排序，再按照所属子树排序。这样所有子树相同的点在一个区间里，所有顶端颜色相同的点也在一个连续区间里。
+ 考虑到顶端颜色相同的需要减去顶端颜色权值，顶端颜色不同的不需要。
+ 考虑维护一个权值线段树，以长度为下标，以路径权值为值的线段树，维护区间最大值。这个线段树在一个颜色区间里的所有点都计算完之后，把这些点全都插入。这是为了计算跨颜色的路径合并。另一个线段树，在同一个颜色里初始化一次，在一个子树区间里全部计算完后把这些点都插入。以长度为下标的目的是，求长度在某一范围内的和的最大值。

## 代码

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;
const int maxNode = 2e5 + 5, maxColor = 2e5 + 5, negInf = -2e9 - 1;
template <const int maxNodeNum>
struct TREE {
    int tot, head[maxNodeNum], to[maxNodeNum << 1], next[maxNodeNum << 1], col[maxNodeNum << 1];
    TREE() {
        tot = 0;
        memset(head, -1, sizeof(head));
    }
    void AddEdge(int from, int TO, int color) {
        to[++tot] = TO;
        next[tot] = head[from];
        col[tot] = color;
        head[from] = tot;
    }
};
struct ELEMENT {
    int col, bel, len, sum;
    ELEMENT(int _c, int _b, int _l, int _s) : col(_c), bel(_b), len(_l), sum(_s) {}
    ELEMENT() : col(0), bel(0), len(0), sum(0) {}
} ele[maxNode];
TREE<maxNode> tree;
int nbNode, nbColor, limL, limR, tot, ans = negInf, colNum, sonTreeNum;
int val[maxColor], siz[maxNode], maxPart[maxNode], sum[maxNode], dep[maxNode];
int sonTreeL[maxNode], sonTreeR[maxNode], colL[maxNode], colR[maxNode];
int colSeq[maxNode], sonTreeSeq[maxNode];
bool vis[maxNode];
int GetCentroid(int now, int from, int all) {
    siz[now] = 1;
    maxPart[now] = 0;
    int ret = 0;
    for (int pt = tree.head[now]; ~pt; pt = tree.next[pt]) {
        int to = tree.to[pt];
        if (to != from && (!vis[to])) {
            int sonRoot = GetCentroid(to, now, all);
            if ((!ret) || maxPart[sonRoot] < maxPart[ret])
                ret = sonRoot;
            siz[now] += siz[to];
            maxPart[now] = max(maxPart[now], siz[to]);
        }
    }
    maxPart[now] = max(maxPart[now], all - siz[now]);
    if ((!ret) || maxPart[now] < maxPart[ret])
        ret = now;
    return ret;
}
bool cmp(ELEMENT fir, ELEMENT sec) {
    return (fir.col == sec.col) ? (fir.bel < sec.bel) : (fir.col < sec.col);
}
void Dfs1(int now, int from, int come) {
    for (int pt = tree.head[now]; ~pt; pt = tree.next[pt]) {
        int to = tree.to[pt], col = tree.col[pt];
        if (to != from && (!vis[to])) {
            sum[to] = sum[now];
            if (col != come)
                sum[to] += val[col];
            Dfs1(to, now, col);
        }
    }
}
void Dfs2(int now, int from, int bel, int col) {
    dep[now] = dep[from] + 1;
    ele[++tot] = ELEMENT(col, bel, dep[now], sum[now]);
    //	if (check)
    //		printf("col : %d bel : %d dep[now] : %d sum[now] : %d\n", col, bel, dep[now], sum[now]);
    for (int pt = tree.head[now]; ~pt; pt = tree.next[pt]) {
        int to = tree.to[pt];
        if (to != from && (!vis[to]))
            Dfs2(to, now, bel, col);
    }
}
struct SEGMENTTREE {
    int tot, root, ls[maxNode << 2], rs[maxNode << 2], mx[maxNode << 2];
    void Init() {
        root = ls[0] = rs[0] = 0, mx[0] = negInf;
        while (tot) {
            ls[tot] = rs[tot] = 0;
            mx[tot--] = negInf;
        }
    }
    SEGMENTTREE() { Init(); }
    void Create(int &now) {
        ++tot;
        ls[tot] = ls[now], rs[tot] = rs[now], mx[tot] = mx[now];
        now = tot;
    }
    void Update(int now) { mx[now] = max(mx[ls[now]], mx[rs[now]]); }
    void Insert(int &now, int lEP, int rEP, int pos, int val) {
        if (!now)
            Create(now);
        if (lEP == rEP) {
            mx[now] = max(mx[now], val);
            return;
        }
        int mid = (lEP + rEP) >> 1;
        if (pos <= mid)
            Insert(ls[now], lEP, mid, pos, val);
        else
            Insert(rs[now], mid + 1, rEP, pos, val);
        Update(now);
    }
    int Query(int now, int lEP, int rEP, int askL, int askR) {
        if (lEP > askR || rEP < askL)
            return negInf;
        if (!now)
            return negInf;
        if (askL <= lEP && rEP <= askR)
            return mx[now];
        int mid = (lEP + rEP) >> 1, ret = negInf;
        if (askL <= mid)
            ret = max(ret, Query(ls[now], lEP, mid, askL, askR));
        if (askR > mid)
            ret = max(ret, Query(rs[now], mid + 1, rEP, askL, askR));
        return ret;
    }
    void Check() {
        for (int i = 1; i <= tot; ++i) printf("ls : %d rs : %d max : %d\n", ls[i], rs[i], mx[i]);
    }
};
SEGMENTTREE seg, sml;
void Solve(int root) {
    dep[root] = 0;
    sum[root] = 0;
    tot = 0;
    for (int pt = tree.head[root]; ~pt; pt = tree.next[pt]) {
        int to = tree.to[pt];
        if (!vis[to]) {
            dep[to] = 1;
            sum[to] = val[tree.col[pt]];
            Dfs1(to, root, tree.col[pt]);
            Dfs2(to, root, to, tree.col[pt]);
        }
    }
    sort(ele + 1, ele + tot + 1, cmp);
    //	if (root == 3)
    //		for (int i = 1; i <= tot; ++i)
    //			printf("col : %d bel : %d dep : %d sum : %d\n", ele[i].col, ele[i].bel, ele[i].len,
    //ele[i].sum);
    colNum = sonTreeNum = 0;
    seg.Init();
    sml.Init();
    for (int i = 1; i <= tot; ++i) {
        if (!sonTreeL[ele[i].bel]) {
            sonTreeL[ele[i].bel] = i;
            sonTreeSeq[++sonTreeNum] = ele[i].bel;
        }
        sonTreeR[ele[i].bel] = i;
        if (!colL[ele[i].col]) {
            colL[ele[i].col] = i;
            colSeq[++colNum] = ele[i].col;
        }
        colR[ele[i].col] = i;
    }
    for (int col = 1, ptSon = 1; col <= colNum; ++col) {
        for (int pt = colL[colSeq[col]]; pt <= colR[colSeq[col]]; ++pt) {
            int maxVal =
                seg.Query(seg.root, 1, nbNode, max(limL - ele[pt].len, 1), max(limR - ele[pt].len, 1));
            if (maxVal != negInf) {
                ans = max(maxVal + ele[pt].sum, ans);
                //				if (maxVal + ele[pt].sum == -20)
                //					printf("root : %d\n", root);
            }
        }
        for (int pt = colL[colSeq[col]]; pt <= colR[colSeq[col]]; ++pt)
            seg.Insert(seg.root, 1, nbNode, ele[pt].len, ele[pt].sum);
        sml.Init();
        while (ptSon <= sonTreeNum && sonTreeR[sonTreeSeq[ptSon]] <= colR[colSeq[col]]) {
            for (int pt = sonTreeL[sonTreeSeq[ptSon]]; pt <= sonTreeR[sonTreeSeq[ptSon]]; ++pt) {
                //				if (root == 3) printf("ptSon : %d pt : %d\n", ptSon, pt);
                int maxVal =
                    sml.Query(sml.root, 1, nbNode, max(limL - ele[pt].len, 1), max(limR - ele[pt].len, 1));
                if (maxVal != negInf) {
                    ans = max(ans, maxVal + ele[pt].sum - val[ele[pt].col]);
                    //					if (pt == 8)
                    //						printf("maxVal : %d ele[pt].sum : %d val[ele[pt].col] : %d\n", maxVal,
                    //ele[pt].sum, val[ele[pt].col]); 					if (maxVal + ele[pt].sum - val[ele[pt].col] == -20)
                    //						printf("root : %d\n", root);
                }
            }
            for (int pt = sonTreeL[sonTreeSeq[ptSon]]; pt <= sonTreeR[sonTreeSeq[ptSon]]; ++pt)
                sml.Insert(sml.root, 1, nbNode, ele[pt].len, ele[pt].sum);
            ++ptSon;
            //			if (root == 3)
            //				printf("sonTreeSeq[ptSon] : %d sonTreeR[sonTreeSeq[ptSon]] : %d colR[col] : %d\n",
            //sonTreeSeq[ptSon], sonTreeR[sonTreeSeq[ptSon]], colR[col]);
        }
    }
    for (int i = 1; i <= tot; ++i)
        if (limL <= ele[i].len && ele[i].len <= limR) {
            ans = max(ans, ele[i].sum);
            //			if (ele[i].sum == -20)
            //				printf("root : %d\n", root);
        }
    for (int i = 1; i <= tot; ++i) {
        sonTreeL[ele[i].bel] = sonTreeR[ele[i].bel] = 0;
        colL[ele[i].col] = colR[ele[i].col] = 0;
    }
}
void Divide(int now, int real) {
    //	printf("now : %d\n", now);
    Solve(now);
    vis[now] = 1;
    for (int pt = tree.head[now]; ~pt; pt = tree.next[pt]) {
        int to = tree.to[pt];
        if (!vis[to]) {
            int realSize = (siz[to] > siz[now]) ? (real - siz[now]) : siz[to];
            Divide(GetCentroid(to, 0, realSize), realSize);
            //我在写 horse ！分治下面一层写的 GetCentroid(now, 0, realSize)
        }
    }
}
int main() {
    scanf("%d%d%d%d", &nbNode, &nbColor, &limL, &limR);
    for (int col = 1; col <= nbColor; ++col) scanf("%d", &val[col]);
    for (int eg = 1; eg < nbNode; ++eg) {
        int u, v, c;
        scanf("%d%d%d", &u, &v, &c);
        tree.AddEdge(u, v, c);
        tree.AddEdge(v, u, c);
    }
    Divide(GetCentroid(1, 0, nbNode), nbNode);
    if (ans > -2e9)
        printf("%d\n", ans);
    return 0;
}
```

## 知识点

+ 注意观察，发现可以把子树和颜色同时弄成一个连续的区间。

---

## 作者：BzhH (赞：1)

[也许会更好的阅读体验](https://www.cnblogs.com/A2484337545/p/14566431.html)


首先吐槽一下自己刚开始理解错题意了，以为题目中的按顺序可以按任意顺序.

这道题是一道关于树上路径的问题，很明显可以想到点分治，考虑当前的分治中心为x.

那么答案可以分为下面四种情况

1.序列一端为x, 另一端在子树内.

2.序列两端在两个不同的子树内,且两个子树到分治中心的颜色相同

3.序列两端在两个不同的子树内,且两个子树到分治中心的颜色不同

4.序列两端在一个子树内

对于第4种情况,很好解决,直接递归就行,第1种情况也是,重点是第2种和第3种.

因为我们需要将所有可能的情况都存起来,所以考虑用线段树, x的所有儿子按边的颜色排序,然后再来枚举,

那么就只需要开两棵线段树了,一棵存了之前的有儿子,一棵只存了当前颜色的儿子,在 dfs的时候分别查询一下就是了,

只需要在查询存的是当前颜色的儿子时需要减去一个val.

代码

```
#include<iostream>
#include<cstdio>
#include<queue>
#define INF (0x3f3f3f3f)
using namespace std;
const int N = 2e5 + 5;
typedef pair<int, int> PII;

int n, m, ql, qr;
int idx, rt1, rt2, tot, val[N], ans = -INF;
int head[2 * N], net[2 * N], edge[2 * N], ver[2 * N];
struct tree
{
    int l, r, v, maxn;
    void init()
    {
        l = r = 0;
        v = maxn = -INF;
    }
} tr[80 * N];
bool st[N];

void pushup(int p)
{
    tr[p].maxn = max(tr[tr[p].l].maxn, tr[tr[p].r].maxn);
}

int merge(int p, int q, int l, int r)
{
    if (!p || !q)
        return p + q;
    if (l == r)
    {
        tr[p].maxn = tr[p].v = max(tr[p].v, tr[q].v);
        tr[q].init();
        return p;
    }
    int mid = (l + r) >> 1;
    tr[p].l = merge(tr[p].l, tr[q].l, l, mid);
    tr[p].r = merge(tr[p].r, tr[q].r, mid + 1, r);
    tr[q].init();
    pushup(p);
    return p;
}

void insert(int p, int l, int r, int d, int x)
{
    if (l == r)
    {
        tr[p].maxn = tr[p].v = max(tr[p].v, x);
        return;
    }
    int mid = (l + r) >> 1;
    if (d <= mid)
    {
        if (!tr[p].l)
            tr[p].l = ++tot;
        insert(tr[p].l, l, mid, d, x);            
    }
    else
    {
        if (!tr[p].r)
            tr[p].r = ++tot;
        insert(tr[p].r, mid + 1, r, d, x);        
    }
    pushup(p);
}

int query(int p, int L, int R, int l, int r)
{
    if (L >= l && R <= r)
        return tr[p].maxn;
    int mid = (L + R) >> 1, res = -INF;
    if (l <= mid && tr[p].l)
        res = max(res, query(tr[p].l, L, mid, l, r));
    if (r > mid && tr[p].r)
        res = max(res, query(tr[p].r, mid + 1, R, l, r));
    return res;
}

void add(int a, int b, int c)
{
    net[++idx] = head[a], ver[idx] = b;
    edge[idx] = c, head[a] = idx;
}

int get_siz(int u, int fa)
{
    int res = 1;
    for (int i = head[u]; i; i = net[i])
        if (ver[i] != fa && !st[ver[i]])
            res += get_siz(ver[i], u);
    return res;
}

int get_wc(int u, int fa, int tot, int &wc)
{
    int sum = 1, ms = 0;
    for (int i = head[u]; i; i = net[i])
    {
        int v = ver[i];
        if (st[v] || v == fa)
            continue;
        int t = get_wc(v, u, tot, wc);
        sum += t;
        ms = max(ms, t);
    }
    ms = max(ms, tot - sum);
    if (ms <= tot / 2)
        wc = u;
    return sum;
}

void get_dist(int rt, int u, int fa, int vals, int len, int last, int ned)
{
    if (len > qr)
        return;
    ans = max(ans, query(rt1, 1, qr, max(1, ql - len), max(1, qr - len))  + vals - ned);
    ans = max(ans, query(rt2, 1, qr, max(1, ql - len), max(1, qr - len)) + vals);
    if (len >= ql)
        ans = max(ans, vals);
    insert(rt, 1, qr, len, vals);
    for (int i = head[u]; i; i = net[i])
    {
        int v = ver[i];
        if (v == fa || st[v])
            continue;
        if (edge[i] == last)
            get_dist(rt, v, u, vals, len + 1, last, ned);
        else
            get_dist(rt, v, u, vals + val[edge[i]], len + 1, edge[i], ned);
    }
}

void clear(int x)
{
    if (tr[x].l)
        clear(tr[x].l);
    if (tr[x].r)
        clear(tr[x].r);
    tr[x].init();
}

void calc(int u)
{
    get_wc(u, -1, get_siz(u, -1), u);
    priority_queue<PII> q;
    st[u] = true;
    for (int i = head[u]; i; i = net[i])
    {
        int v = ver[i];
        if (st[v])
            continue;
        q.push(make_pair(edge[i], v));
    }
    int last = 0;
    rt2 = ++tot;
    while (!q.empty())
    {
        int v = q.top().second, tp = q.top().first;
        q.pop();   
        if (tp != last)
        {
            merge(rt2, rt1, 1, qr);
            rt1 = ++tot;
        }
        int rt = ++tot;    
        get_dist(rt, v, u, val[tp], 1, tp, val[tp]);
        merge(rt1, rt, 1, qr);
        last = tp;
    }
    tot = 0, clear(rt1), clear(rt2);
    for (int i = head[u]; i; i = net[i])
        if (!st[ver[i]])
            calc(ver[i]);
}

int main()
{
    for (int i = 0; i < 10 * N; i++)
        tr[i].v = tr[i].maxn = -INF;
    scanf("%d%d%d%d", &n, &m, &ql, &qr);
    for (int i = 1; i <= m; i++)
        scanf("%d", &val[i]);
    for (int i = 1; i < n; i++)
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c), add(b, a, c);
    }
    calc(1);
    printf("%d", ans);
    return 0;
}
```


---

## 作者：juju527 (赞：1)

与多数大佬单调队列的方法不同，

本篇题解运用点分治+线段树通过了此题。

---

### $\text{Solution}$

题目要求得到所有长度在 $[l,r]$ 范围内的路径的权值最大值。

考虑在路径的某一点上计算答案，直接上点分治。

在当前点分治的连通块中，我们需要算出重心 $h$ 的不同子树直接路径的最大值

考虑将路径从 $h$ 劈开，拆分为两条链

对于一条链的权值我们是好维护的，暴力dfs下去计算即可

发现我们唯一需要考虑的是两条链顶边颜色一样时，我们需要减去一遍多算的权值

同时，我们也能发现一个显然的结论 **同子树内的链顶边颜色相同**

把不同的子树按**链顶边颜色**，链顶边颜色相同按**链属子树编号**排序

>我们考虑将一条路径在排序后排名靠后的链上计算

>考虑对于每一条链只需计算另一条权值最长链与其拼接，特殊考虑链顶颜色相同链

把每个子树扫一遍，同时维护两颗以链长为下标的线段树

$a_x$ 表示以 $x$为链尾的链权值

$b_x$ 表示以 $x$为链尾的链属子树

$c_x$ 表示以 $x$为链尾的链顶边

$d_x$ 表示以 $x$为链尾的链长

枚举到 $u$ 子树内的点 $x$ 时

第一颗线段树记录所有链顶边颜色**小于** $c_x$ 的所有链信息

对于第一颗线段树，我们直接查下标在 $[l-d_x,r-d_x]$ 的链权值最大值即可，将其与 $x$ 链拼接

第二颗线段树记录所有链顶边颜色**等于** $c_x$且链属子树编号小于 $b_x$ 的所有链信息

对于第二颗线段树，我们同第一颗线段树，最后减掉一个颜色 $c_x$ 的权值即可

记得每层点分治应清空线段树，具体实现可参考代码

时间复杂度 $O(nlog_2^2n)$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e5+5,inf=2e9+1;
struct Edge{
	int to,w,nxt;
}e[2*maxn];
int cnt;
int head[maxn];
int n,p,L,R,ans;
int C[maxn];
int read(){
	int x=0,y=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*y;
}
void add(int u,int v,int w){
	e[cnt].to=v;
	e[cnt].w=w;
	e[cnt].nxt=head[u];
	head[u]=cnt++;
	return ;
}
int t1[maxn<<2],t2[maxn<<2];
void build(int k,int l,int r){
	t1[k]=t2[k]=-inf;
	if(l==r)return ;
	int mid=l+((r-l)>>1);
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	return ;
}
void modify1(int k,int l,int r,int x,int val){
	if(l>x||r<x)return ;
	if(l==r){t1[k]=max(t1[k],val);return ;}
	int mid=l+((r-l)>>1);
	modify1(k<<1,l,mid,x,val);
	modify1(k<<1|1,mid+1,r,x,val);
	t1[k]=max(t1[k<<1],t1[k<<1|1]);
	return ;
}
void modify2(int k,int l,int r,int x,int val){
	if(l>x||r<x)return ;
	if(l==r){t2[k]=max(t2[k],val);return ;}
	int mid=l+((r-l)>>1);
	modify2(k<<1,l,mid,x,val);
	modify2(k<<1|1,mid+1,r,x,val);
	t2[k]=max(t2[k<<1],t2[k<<1|1]);
	return ;
}
void clear1(int k,int l,int r,int x){
	if(l>x||r<x)return ;
	if(l==r){t1[k]=-inf;return ;}
	int mid=l+((r-l)>>1);
	clear1(k<<1,l,mid,x);
	clear1(k<<1|1,mid+1,r,x);
	t1[k]=-inf;
	return ;
}
void clear2(int k,int l,int r,int x){
	if(l>x||r<x)return ;
	if(l==r){t2[k]=-inf;return ;}
	int mid=l+((r-l)>>1);
	clear2(k<<1,l,mid,x);
	clear2(k<<1|1,mid+1,r,x);
	t2[k]=-inf;
	return ;
}
int query1(int k,int l,int r,int x,int y){
	if(l>y||r<x)return -inf;
	if(l>=x&&r<=y)return t1[k];
	int mid=l+((r-l)>>1);
	return max(query1(k<<1,l,mid,x,y),query1(k<<1|1,mid+1,r,x,y));
}
int query2(int k,int l,int r,int x,int y){
	if(l>y||r<x)return -inf;
	if(l>=x&&r<=y)return t2[k];
	int mid=l+((r-l)>>1);
	return max(query2(k<<1,l,mid,x,y),query2(k<<1|1,mid+1,r,x,y));
}
//线段树
int h,m;
bool vis[maxn];
int siz[maxn];
void dfs1(int x,int fa){
	siz[x]=1;
	for(int i=head[x];i!=-1;i=e[i].nxt){
		int tmp=e[i].to;
		if(tmp==fa||vis[tmp])continue;
		dfs1(tmp,x);
		siz[x]+=siz[tmp];
	}
	return ;
}
void dfs2(int x,int fa){
	bool flag=1;
	for(int i=head[x];i!=-1;i=e[i].nxt){
		int tmp=e[i].to;
		if(tmp==fa||vis[tmp])continue;
		dfs2(tmp,x);
		if(siz[tmp]>m/2)flag=0;
	}
	if(flag&&m-siz[x]<=m/2)h=x;
	return ;
}
//求重心
struct node{
	int a,b,c,d;
	//a：链权值，b：属于哪个子树，c：链顶颜色，d：链长 
	bool operator <(node i)const{
		return c==i.c?b<i.b:c<i.c;
	}
}g[maxn];
int val,dis,len;
void dfs4(int x,int fa,int b,int c,int W,int fW){
	if(W!=fW)val+=C[W];
	dis++;
	g[++len]=(node){val,b,c,dis};
	for(int i=head[x];i!=-1;i=e[i].nxt){
		int tmp=e[i].to;
		if(tmp==fa||vis[tmp])continue;
		dfs4(tmp,x,b,c,e[i].w,W);
	}
	if(W!=fW)val-=C[W];
	dis--;
   //回溯
	return ;
}
//提出每条链
void dfs3(int x,int fa){
	dfs1(x,fa);
	m=siz[x];
	dfs2(x,fa);
	int H=h;
	vis[H]=1;
	len=0;
	for(int i=head[H];i!=-1;i=e[i].nxt){
		int tmp=e[i].to;
		if(vis[tmp])continue;
		val=dis=0;
		dfs4(tmp,H,tmp,e[i].w,e[i].w,10001);
	}
	sort(g+1,g+len+1);
	g[0].c=-1;
	int lst1=1,lst2=1;
	for(int i=1;i<=len;i++){
		if(g[i].c>g[i-1].c){
			for(int j=lst1;j<i;j++)if(g[j].d<R)modify1(1,1,R,g[j].d,g[j].a);
			for(int j=lst1;j<lst2;j++)if(g[j].d<R)clear2(1,1,R,g[j].d);
			lst1=lst2=i;
        //换链顶颜色，换子树
		}
		else if(g[i].b>g[i-1].b){
			for(int j=lst2;j<i;j++)if(g[j].d<R)modify2(1,1,R,g[j].d,g[j].a);
			lst2=i;
        //换子树
		}
		if(g[i].d>R)continue;
		int lt=L-g[i].d,rt=R-g[i].d,v=g[i].a;
		if(g[i].d>=L&&g[i].d<=R)ans=max(ans,v);//单链计算
		ans=max(ans,max(query1(1,1,R,lt,rt),query2(1,1,R,lt,rt)-C[g[i].c])+v);
	}
	for(int i=1;i<lst1;i++)if(g[i].d<R)clear1(1,1,R,g[i].d);
	for(int i=lst1;i<lst2;i++)if(g[i].d<R)clear2(1,1,R,g[i].d);
	for(int i=head[H];i!=-1;i=e[i].nxt){
		int tmp=e[i].to;
		if(vis[tmp])continue;
		dfs3(tmp,H);
	}
	return ;
}
int main(){
	n=read();p=read();L=read();R=read();
	for(int i=1;i<=p;i++)C[i]=read();
	memset(head,-1,sizeof(head));
	for(int i=1;i<n;i++){
		int u,v,c;
		u=read();v=read();c=read();
		add(u,v,c);
		add(v,u,c);
	}
	ans=-inf;
	build(1,1,R);
	dfs3(1,0);
	printf("%d\n",ans);
	return 0;
}

```

---

## 作者：zzw4257 (赞：1)

>给定一棵边有色的树，定义一条路径权值为路径上**依序经过的同色段集合的颜色权值之和**
>
>求树上长度$\in[l,r]$的路径的权值最大值

路径问题且对长度有限制我们直接考虑点分治，注意到我们求分治中心到一个点路径的色段贡献和是很好求的

分析拼接路径的过程，我们称$x$到$rt$路径上倒数第二个点$y$为$x$从属的支系$bel_x$,$x$从属点到$rt$的颜色是$belc_x$

- $rt\to x$与$rt\to y$从属于不同的祖先，不会贡献
- $rt\to x$与$rt\to y$从属相同但从属颜色不同直接拼接
- $rt\to x$与$rt\to y$从属相同但从属颜色相同减掉多余贡献后拼接

考虑取出分治中心的各支脉后按照从属颜色分开，做一类贡献，再进一步按从属点分开做二类贡献

为什么正确?我们首先做强制让颜色不同的贡献，这部分是算全了的

然后做同色块内部跨越的贡献因为我们是先定的要被减掉的$-v_{belc}$所以也是独立的最值

实现上用线段树维护在$2,3$类贡献中某个长度范围内的路径最大值更新即可

附一个数据

```
61 23 1 59
5477 -1582 6699 7154 -779 -1201 -4225 3243 -4340 8812 8244 -9545 -5144 8948 -2165 -8895 381 -7111 8390 947 -5123 -4004 -9014 
2 1 2
3 1 1
4 3 5
5 2 21
6 5 14
7 1 1
8 4 19
9 1 21
10 6 1
11 5 21
12 8 19
13 4 17
14 11 11
15 2 8
16 11 5
17 14 11
18 17 11
19 17 6
20 13 6
21 5 6
22 11 19
23 2 16
24 7 6
25 13 20
26 5 19
27 17 5
28 1 12
29 23 21
30 25 14
31 29 10
32 31 21
33 8 11
34 22 13
35 8 20
36 21 20
37 2 19
38 32 16
39 17 10
40 34 3
41 6 14
42 26 5
43 8 6
44 2 12
45 17 18
46 10 21
47 20 22
48 28 21
49 34 12
50 16 19
51 46 17
52 51 21
53 52 16
54 50 5
55 50 19
56 46 5
57 48 10
58 49 4
59 55 2
60 56 16
61 51 1

```


---


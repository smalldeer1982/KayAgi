# [SDOI2012] 任务安排

## 题目描述

机器上有 $n$ 个需要处理的任务，它们构成了一个序列。这些任务被标号为 $1$ 到 $n$，因此序列的排列为 $1 , 2 , 3 \cdots n$。这 $n$ 个任务被分成若干批，每批包含相邻的若干任务。从时刻 $0$ 开始，这些任务被分批加工，第 $i$ 个任务单独完成所需的时间是 $T_i$。在每批任务开始前，机器需要启动时间 $s$，而完成这批任务所需的时间是各个任务需要时间的总和。

**注意，同一批任务将在同一时刻完成**。每个任务的费用是它的完成时刻乘以一个费用系数 $C_i$。

请确定一个分组方案，使得总费用最小。

## 说明/提示

对于 $100\%$ 数据，$1 \le n \le 3 \times 10^5$，$1 \le s \le 2^8$，$ \left| T_i \right| \le 2^8$，$0 \le C_i \le 2^8$。

## 样例 #1

### 输入

```
5
1
1 3
3 2
4 3
2 3
1 4
```

### 输出

```
153
```

# 题解

## 作者：Stay_Hungry (赞：123)


从0.1开始的斜率优化（dalao请跳过，不喜误喷） 


------------
因为我是真的菜，写不来逼格高的，只得写篇详细而通俗易懂的题解。     

那么何为“斜率优化”呢？    
答曰：用线性规划优化dp式。   

如果不会线性规划，问题也不大，接下来开始题解正文部分：   

以下正文部分分成3类数据题解。

$$1.(1\le n\le5000,1\le t_i,c_i\le100)$$   

其实我个人感觉$O(n^3)dp$很难想=-=   

按照题意来，我们设$f_i$表示完成到以第$i$个任务为结束任务时所花费的最短时间     

外层枚举$i$，内层枚举$j$，表示从$j+1$到$i$这一段任务加入到$f_j$所表示的任务安排区间，然后加上贡献取$min$即可。   

对于开机时间，只会对开机一次后的任务产生影响，所以直接加上$S*(c_{j+1}+...+c_{n})$，对于这段任务的完成费用，直接前缀和$T_i$乘一下即可   

所以我们可以得出dp式：  
$$f_i=Min_{0\le j<i}(f_j+S*c(j,n)+t_i*c(j,i))$$

$$c(a,b)=\sum^{i=a+1}_{i\le b} c_i$$   

然后用前缀和维护$c(a,b)$，这样就愉快的切掉弱化版[P2365](https://www.luogu.com.cn/problem/P2365)。   
$$f_i=f_j+S*(sc_n-sc_j)+st_i*(sc_i-sc_j)$$  

分析复杂度：内外两层循环，时间复杂度为$O(n^2)$，是肯定不行的，然后此时我们就得用斜率优化来优化时间复杂度。  

我们把$Min$去除，然后化简，用其他元素表示$f_j$   
$$f_i=f_j+S*(sc_n-sc_j)+st_i*(sc_i-sc_j)$$

$$f_i=f_j+S*sc_n-S*sc_j+st_i*sc_i-st_i*sc_j$$

$$f_j=(S+sc_i)sc_j+f_i-S*sc_n-st_i*sc_i$$

$$y=f_j$$ 

$$k=(S+sc_i)$$

$$x=sc_j$$ 

$$b=f_i-S*sc_n-st_i*sc_i$$

这样我们就可以得到一个一次函数解析式。

然而为啥要这么分呢？  
答曰：把外循环时可以不能直接得出的放在$x$或$y$处，$k$和$b$都是可以依靠外指针$i$得到的，然后就可以开始愉快的斜率优化啦！

对于选择不同的$j$更新$f_i$的值，我们把$j$称为决策点，对于任意一个决策点，我们都能把它表示在以$sc_j$为$x$轴，以$f_j$为$y$轴的平面直角坐标系上。   

对于一个决策点所对应的直线，都可以解出一段截距$b$，而

$b=f_i-S*sc_n-st_i*sc_i$中$-S*sc_n-st_i*sc_i$是可以直接得到固定值的，因此$b$越大，$f_i$越大。

![](https://cdn.luogu.com.cn/upload/image_hosting/4th342y3.png)

$2.(1\le n\le 3*10^5,1\le c_i , t_i \le 10^4)$  
了解大致原理后，我们需先分析单调性。  
当$j$单调递增时，$c_i>0$，因此$sc_j$单调递增，且$t_i>0$，因此$f_i$单调递增，$k$单调递增。   

接下来我们就需考虑最优决策点的选择。 
![](https://cdn.luogu.com.cn/upload/image_hosting/36e7nfo7.png)  
通俗一点讲，所谓选择最优决策点就是把一条斜率为$s+sc_i$的直线从下向上靠，第一个相交的点就是最优决策点（因为此时$b$最小，$f_i$也必定最小）。    

而对于上凸点，无论直线的斜率怎么变化，最先相交的点必定不是上凸点，因此我们可以将所有上凸点都移出决策点队列，最后，我们可以得到一个下凸包。
![](https://cdn.luogu.com.cn/upload/image_hosting/g1vnyxmp.png)

因此对于任意决策点$a$,$b$,$c$ $(a<b<c)$，满足$k_a<k_b<k_c$，即决策点斜率单调递增。   
因为$k$单调递增，因此小于当前$k(k=s+sc_i)$决策点可以移出决策点队列。  

分析时间复杂度：每个点进出队列1次，时间复杂度$O(n)$。  

$3.(1\le n\le3*10^5,0\le c_i\le2^8,-2^8\le t_i\le2^8)$ 


此时$t_i$可能为负数，因此$f_j$不一定单调递增，所以决策点连线的直线可能为负数，决策时$k$也可能为负数。

同样，上凸点一定不是最优决策点，因此需维护下凸包。
![](https://cdn.luogu.com.cn/upload/image_hosting/t9v5i4sj.png)

在此，此篇题解就告一段落了，献上代码：
```cpp
#include <cstdio>
#include <iostream>
typedef long long ll;
const int N = 3e5 + 5 ;
int l = 1 , r = 0 ;
ll sc[N], st[N], f[N], n, s, q[N];
ll Y(int p) {return f[p];}
ll X(int p) {return sc[p];}
ll K(int p) {return s + st[p];}
int Search(int L, int R, long long S) {
	int M = 0 , Res = r ;
	while(L <= R) {
		M = ( L + R ) >> 1; 
		if(Y(q[M + 1]) - Y(q[M]) > S * (X(q[M + 1]) - X(q[M]))) // 由所得性质二分
			R = M - 1, Res = M;
		else L = M + 1; // 二分+-1防止死循环
	}
	return q[Res];
} // 二分查找决策点
int main() {
	scanf("%lld %lld", &n, &s);
	for(int i = 1; i <= n; ++i) {
		scanf("%lld %lld", st + i, sc + i);
		st[i] += st[i - 1];
		sc[i] += sc[i - 1];
	} // 前缀和
	q[++ r] = 0 ;// 0 为第一个决策点
	for(int i = 1; i <= n; ++i) {
		int p = Search(l, r, K(i));
		f[i] = f[p] + s * (sc[n] - sc[p]) + st[i] * (sc[i] - sc[p]); // 按照dp方程式更新答案
		while(l < r && (Y(q[r]) - Y(q[r - 1])) * (X(i) - X(q[r])) 
			>= (Y(i) - Y(q[r])) * (X(q[r]) - X(q[r - 1]))) -- r; // 除去上凸点 ， 这里把算斜率的除法转换为乘法以防误差
		q[++ r] = i; // 入队列
	}
	printf("%lld\n", f[n]); // 完美输出
	return 0; // 好习惯
}
```
**updated on 12-15：毒瘤码风修复，最初方程得出过程已添加**

---

## 作者：HoshiuZ (赞：33)

## [洛谷P2365] 任务安排

$n$个任务排成一个序列在一台机器上等待完成（顺序不得改变），这$n$个任务被分成若干批，每批包含相邻的若干任务。

从零时刻开始，这些任务被分批加工，第$i$个任务单独完成所需的时间为$t_i$。在每批任务开始前，机器需要启动时间$s$，而完成这批任务所需的时间是各个任务需要时间的总和（同一批任务将在同一时刻完成）。

每个任务的费用是它的完成时刻乘以一个费用系数$f_i$。请确定一个分组方案，使得总费用最小。

 对于$100\%$的数据，$1\le n\le5000$，$0 \le s\le50$，$1\le t_i,f_i \le 100$。 

### 链接

[P2365 任务安排](https://www.luogu.com.cn/problem/P2365)

### 思路

定义$dp[i][j]$表示前$i$个任务被分为$j$批的最小费用值。

定义$sumt[i]$表示$t$的前缀和，$sumf[i]$表示$f$的前缀和。

易得
$$
dp[i][j]=min\{dp[k][j-1]+(sumt[i]+s\times j)(sumf[i]-sumf[k])\},k\in[0,i)
$$
初始化$dp[0][0]=0$，其余均为一个极大值。

于是便可以照这个写出一个$O(n^3)$的TLE代码。

```cpp
#include<bits/stdc++.h>
#define N 5010

using namespace std;

int n,s,t[N],f[N],sumt[N],sumf[N],dp[N][N],ans;

int main() {
	cin>>n;
	cin>>s;
	for(int i=1;i<=n;i++) {
		cin>>t[i]>>f[i];
		sumt[i]=sumt[i-1]+t[i];
		sumf[i]=sumf[i-1]+f[i];
	}
	
	memset(dp,0x3f,sizeof(dp));
	ans=dp[0][0];
	dp[0][0]=0;
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=i;j++) {
			for(int k=0;k<i;k++) {
				dp[i][j]=min(dp[i][j],dp[k][j-1]+(sumt[i]+s*j)*(sumf[i]-sumf[k]));
			}
			if(i==n) ans=min(ans,dp[i][j]);
		}
	}
	
	cout<<ans<<endl;
	
	return 0;
}
```

观察式子，发现$j$的作用仅是为了计算此前个过程中的启动时间和，但事实上，既然这个时间要乘上此后的所有$f$，不如提前加入其中。因为若分完前$j$个任务后，要等待$s$秒，则后续费用一定会加上$(sumf[n]-sumf[j])\times s$，于是可以提前加进去，这样dp数组可以省去一维，状转方程变为
$$
dp[i]=min\{dp[j]+sumt[i]\times (sumf[i]-sumf[j])+s\times (sumf[n]-sumf[j])\},j\in[0,i)
$$
这样又可以写出一个$O(n^2)$的算法。

```cpp
#include<bits/stdc++.h>
#define N 5010

using namespace std;

int n,s,t[N],f[N],sumt[N],sumf[N],dp[N];

int main() {
	cin>>n;
	cin>>s;
	for(int i=1;i<=n;i++) {
		cin>>t[i]>>f[i];
		sumt[i]=sumt[i-1]+t[i];
		sumf[i]=sumf[i-1]+f[i];
	}
	
	memset(dp,0x3f,sizeof(dp));
	dp[0]=0;
	for(int i=1;i<=n;i++) {
		for(int j=0;j<i;j++) dp[i]=min(dp[i],dp[j]+sumt[i]*(sumf[i]-sumf[j])+s*(sumf[n]-sumf[j]));
	}
	
	cout<<dp[n]<<endl;
	
	return 0;
}
```

再整理，可得
$$
dp[i]=min\{dp[j]-(sumt[i]+s)\times sumf[j]\}+sumt[i]\times sumf[i]+s\times sumf[n],j\in[0,i)
$$
对于每一个$i$，$min$外都是常量。

观察$min$内的式子：$dp[j]-(sumt[i]+s)\times sumf[j]$，令$k=sumt[i]+s$，则原式变为$-k\times sumf[j]+dp[j]$。

这个形式像什么？一次函数。

将其看做一条斜率为$k$，且过点$(sumf[j],dp[j])$的直线。

那么其与$y$轴交点即为$(0,dp[j]-k\times sumf[j])$

这是什么？这就是$min$内的东西。则问题就转化为找最小的截距。

则对于每个$sumf[j],dp[j],j\in[0,i)$过点$(sumf[j],dp[j])$的直线，最小的截距明显就是下凸壳的顶点。

令$k<j<i$，如果转移$j$比转移$k$要更优的话，则

$dp[j]-(sumt[i]+s)\times sumf[j]<dp[k]-(sumt[i]+s)\times sumf[k]$

$dp[j]-dp[k]<(sumt[i]+s)(sumf[j]-sumf[k])$

$∵j>k$

$∴sumf[j]-sumf[k]>0$

$∴\frac{dp[j]-dp[k]}{sumf[j]-sumf[k]}<sumt[i]+s$

则相邻两点$j,k,k<j$，若$j$与$k$的连线段的斜率小于$sumt[i]+s$的话，那么$k$不需要了。

令$j_1<j_2<j_3$，若$j_2$有可能成为最优决策，则其满足下凸性，$j_1$与$j_2$连成线段的斜率要小于$j_2$与$j_3$连成线段的斜率。

即$\frac{dp[j_2]-dp[j_1]}{sumf[j_2]-sumf[j_1]}<\frac{dp[j_3]-dp[j_2]}{sumf[j_3]-sumf[j_2]}$。

便可以以此建立单调队列，维护这个下凸壳。

队头与队头后一个的连线段的斜率小于$sumt[i]+s$的话则直接弹出，因为$sumt[i]+s$具有单调性。队尾在加入$i$后不符合下凸性则弹出队尾，然后将$i$加入队尾。每次状态转移直接用队头即可。

每个元素只入队一次，时间复杂度$O(n)$。

### 代码

```cpp
#include<bits/stdc++.h>
#define N 5010

using namespace std;

int n,s,f[N],t[N],sumf[N],sumt[N],dp[N],q[N],head=1,tail=1;

int main() {
	cin>>n;
	cin>>s;
	for(int i=1;i<=n;i++) {
		cin>>t[i]>>f[i];
		sumf[i]=sumf[i-1]+f[i];
		sumt[i]=sumt[i-1]+t[i];
	}
	
	memset(dp,0x3f,sizeof(dp));
	q[head]=0;
	dp[0]=0;
	for(int i=1;i<=n;i++) {
		while(head<tail&&dp[q[head+1]]-dp[q[head]]<=(sumt[i]+s)*(sumf[q[head+1]]-sumf[q[head]])) head++;
		dp[i]=dp[q[head]]-(sumt[i]+s)*sumf[q[head]]+sumt[i]*sumf[i]+s*sumf[n];
		while(head<tail&&(dp[q[tail]]-dp[q[tail-1]])*(sumf[i]-sumf[q[tail]])>=(dp[i]-dp[q[tail]])*(sumf[q[tail]]-sumf[q[tail-1]])) tail--;
		q[++tail]=i;
	}
	
	cout<<dp[n]<<endl;
	
	return 0;
}
```

## [SDOI2012] 任务安排

$n$个任务排成一个序列在一台机器上等待完成（顺序不得改变），这$n$个任务被分成若干批，每批包含相邻的若干任务。

从零时刻开始，这些任务被分批加工，第$i$个任务单独完成所需的时间为$t_i$。在每批任务开始前，机器需要启动时间$s$，而完成这批任务所需的时间是各个任务需要时间的总和（同一批任务将在同一时刻完成）。

每个任务的费用是它的完成时刻乘以一个费用系数$f_i$。请确定一个分组方案，使得总费用最小。

 对于$100\%$的数据，$1\le n\le3\times 10^5$，$0 \le s\le2^8$，$|t_i|\le 2^8$，$0\le f_i\le2^8$。

### 链接

[[SDOI2012]任务安排](https://www.luogu.com.cn/problem/P5785)

### 思路

本题与之前的那道任务安排不同在于数据量增大了，且$t$的值可能为负的。

因此上面的$O(n^3)$与$O(n^2)$的方法都过不了。

斜率优化？

而因为$t$值可能为负，所以$sumt[i]+s$不再具有单调性，那么上面的保存相邻两点连线段斜率大于$sumt[i]+s$的方法便不再适用。

因此不能弹出队头，而是要维护整个凸壳。所维护的凸壳具有下凸性，因此最优的决策点一定是左侧的线段斜率小于$sumt[i]+s$，右侧的线段斜率大于$sumt[i]+s$，所以便可以用二分查找，来寻找这个最优的决策点。

队尾的操作维护下凸性与上题相同，保持不变即可。

但准确来讲，队头从来没有弹出过，这应该属于一个单调栈。

### 代码

```cpp
#include<bits/stdc++.h>
#define N 300010
#define ll long long

using namespace std;

int n,s,head=1,tail=1,q[N];
ll f[N],t[N],sumf[N],sumt[N],dp[N];

int binary_search(int i) {
	if(head==tail) return q[head];
	int l=head,r=tail;
	while(l<r) {
		int mid=l+r>>1;
		if(dp[q[mid+1]]-dp[q[mid]]<=(sumt[i]+s)*(sumf[q[mid+1]]-sumf[q[mid]])) l=mid+1;
		else r=mid;
	}
	
	return q[l];
}
		
int main() {
	cin>>n;
	cin>>s;
	for(int i=1;i<=n;i++) {
		cin>>t[i]>>f[i];
		sumf[i]=sumf[i-1]+f[i];
		sumt[i]=sumt[i-1]+t[i];
	}
	
	memset(dp,0x3f,sizeof(dp));
	q[head]=0;
	dp[0]=0;
	for(int i=1;i<=n;i++) {
		int p=binary_search(i);
		dp[i]=dp[p]-(sumt[i]+s)*sumf[p]+sumt[i]*sumf[i]+s*sumf[n];
		while(head<tail&&(dp[q[tail]]-dp[q[tail-1]])*(sumf[i]-sumf[q[tail]])>=(dp[i]-dp[q[tail]])*(sumf[q[tail]]-sumf[q[tail-1]])) tail--;
		q[++tail]=i;
	}
	
	cout<<dp[n]<<endl;
	
	return 0;
}
```

---

## 作者：LinkyChristian (赞：20)

看到没有人写李超线段树的解法，过来写一篇。

李超线段树是一种维护直线的数据结构，它支持插入一条解析式为 $kx+b$ 的直线，并查询所有直线中在 $x=a$ 时 $y$ 值最小的一条。

李超线段树通过维护每个区间中点最小的直线来做到这一点，具体过程可以看 [我的李超线段树学习笔记](https://lookcatbox.blog.luogu.org/post-xue-xi-bi-ji-li-chao-xian-duan-shu)。

李超线段树与斜率优化本质基本相同，但在解决一些没有单调性的斜优问题时写李超线段树可以避免恶心的动态凸包。

考虑这一题，其实 dp 柿子不是很好列，需要一种思想，即在计算当前的状态时提前统计当前状态对之后的贡献，这里可以参考 [P2466 [SDOI2008] Sue 的小球](https://www.luogu.com.cn/problem/P2466)。

设 $sumt_i = \sum_{j=1}^i T_j$ ， $sumv_i=\sum_{j=1}^iC_j$ ，$F_i$ 为以 $i$ 为一段区间右端点的最小代价。

枚举 $j$ 做为上一个区间的右端点，可以列出柿子：

$$F_i=min_{j=0}^{i-1}(F_j+sumt_i\times(sumv_i-sumv_j)+s\times(sumv_n-sumv_j))$$ 

这里提前计算了启动时间 $s$ 对之后所有任务的影响。

使用李超线段树维护 dp 柿子时需要将柿子化为 $F=kx+b$ 的形式，其中 $k$ 和 $b$ 只与 $j$ 有关，$x$ 只与 $i$ 有关，所以我们将柿子拆开。

设 $lasv_i=sumv_n-sumv_i$ ，

$$F_i=min_{j=0}^{i-1} (F_j + sumt_i\times sumv_i -sumt_i\times sumv_j+s\times lasv_j)$$

将 $sumt_i \times sumv_i$ 这个项提到外面去：

$$F_i=min_{j=0}^{i-1} (F_j -sumt_i\times sumv_j+s\times lasv_j) + sumt_i\times sumv_i $$

发现 $F_j -sumt_i\times sumv_j+s\times lasv_j$ 即为函数 $f_j(x)=kx+b=(-sumv_j) x+(F_j+s\times lasv_j)$ 在 $x=sumt_i$ 处的取值。

通过查询李超线段树中在 $x=sumt_i$ 时最低的直线来 dp，并在计算完每个 $i$ 的 dp 值后，将 $f_i(x)=(-sumv_i) x+(F_i+s\times lasv_i)$ 这条直线插入李超线段树即可。

李超线段树的大小为值域大小，但是 $sumt_i$ 的值域太大。发现询问点只有 $n$ 个，因此将询问点排序并离散化，维护每个询问点处最低的直线即可。

$Code$

```cpp
// Problem: P2608 [ZJOI2010] 任务安排
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P2608
// Memory Limit: 125 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
#define N 300010
#define ls k*2
#define rs k*2+1
#define mid (l+r)/2
#define int long long
using namespace std;
int read() {
	int res=0,f=1;char ch=getchar();
	while(!isdigit(ch)) f=ch=='-'?-1:1,ch=getchar();
	while(isdigit(ch)) res=res*10+ch-'0',ch=getchar();
	return f*res;
}
int k[N],b[N],d[N<<2],n,s,dp[N],t[N],v[N],tmp[N],tn,pos[N];
int f(int x,int id) {return k[id]*x+b[id];}
void update(int k,int l,int r,int id) {
	if(l==r) {
		if(f(tmp[l],id)<f(tmp[l],d[k])) d[k]=id;
		return ;
	}
	if(f(tmp[mid],id)<f(tmp[mid],d[k])) swap(id,d[k]);
	if(f(tmp[l],id)<f(tmp[l],d[k])) update(ls,l,mid,id);
	else if(f(tmp[r],id)<f(tmp[r],d[k])) update(rs,mid+1,r,id);
}
int query(int k,int l,int r,int x) {
	if(l==r) return f(tmp[x],d[k]);
	return min(f(tmp[x],d[k]),x<=mid?query(ls,l,mid,x):query(rs,mid+1,r,x));
}
signed main()
{
 	n=read(),s=read(),b[0]=1e18;
 	for(int i=1; i<=n; i++) t[i]=read()+t[i-1],tmp[++tn]=t[i],v[i]=read()+v[i-1];
 	sort(tmp+1,tmp+n+1),tn=unique(tmp+1,tmp+n+1)-tmp-1;
 	for(int i=1; i<=n; i++) pos[i]=lower_bound(tmp+1,tmp+tn+1,t[i])-tmp;
 	dp[1]=t[1]*v[1]+s*v[n],k[1]=-v[1],b[1]=dp[1]+s*(v[n]-v[1]);
 	update(1,1,tn,1);
 	for(int i=2; i<=n; i++) {
 		dp[i]=t[i]*v[i]+s*v[n];
 		dp[i]=min(dp[i],query(1,1,tn,pos[i])+t[i]*v[i]);
 		k[i]=-v[i],b[i]=dp[i]+s*(v[n]-v[i]);
 		update(1,1,tn,i);
 	}
    printf("%lld",dp[n]);
	return 0;
}
```


---

## 作者：7KByte (赞：18)

斜率优化模板题，建议添加模板（划掉


本题是[P2365 任务安排](https://www.luogu.com.cn/problem/P2365)的加强版（不仅是数据范围上的加强


根据弱化版$O(N^2)$，我们得出这样一个转移方程

$$f[i]=min\{f[j]+sumT[i]*(sumC[i]-sumC[j])+s*(sumC[n]-sumC[j])\}$$


我们对方程展开并移项，发现满足斜率优化的基本式子$f[i]=f[j]+val(i,j)+k$

直接用单调队列维护下凸包即可，相邻两点斜率$k=(f[y]-sumC[y]*s-f[x]+sumC[x]*s)/(sumC[y]-sumC[x])$，直线的斜率为$sumT[i]$


这样我们就可以愉快的切掉弱化版


这里给个代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s,c[5005],t[5005],f[5005];
int q[5005],l,r;
double slope(int x,int y){
	return ((double)f[y]-c[y]*s-f[x]+c[x]*s)/((double)c[y]-c[x]);
}
int main()
{
	scanf("%d%d",&n,&s);
	for(int i=1;i<=n;i++)scanf("%d%d",&t[i],&c[i]),t[i]+=t[i-1],c[i]+=c[i-1];
	memset(f,0x7f,sizeof(f));
	f[0]=q[0]=l=r=0;
	for(int i=1;i<=n;i++){
		while(l<r&&slope(q[l],q[l+1])<=(double)t[i])l++;
		int j=q[l];
		f[i]=f[j]+t[i]*(c[i]-c[j])+s*(c[n]-c[j]);
		///cout<<i<<" "<<j<<" "<<f[i]<<endl;
		while(l<r&&slope(q[r-1],q[r])>=slope(q[r],i))r--;
		q[++r]=i;
	}
	printf("%d\n",f[n]);
	return 0;
}
```

然后改了一个数组大小就交了上去，很惨$WA\ 0pts$

等我们再仔细阅读题面，才发现本题$|T_i|\le 2^8$，这也就意味着我们每次截取的直线的斜率不再单调递增，单调队列不能再满足需要

为了保证决策状态的有序性，我们还是选择用一个单调队列（其实单调栈也可以）维护下凸包。因为决策集合已经有序，对于任意直线，我们只用在队列中二分出使截距最小的交点，时间复杂度$O(NlogN)$


这里贴代码

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define int long long
using namespace std;
int n,s,c[500005],t[500005],f[500005];
int q[500005],l,r;
double slope(int x,int y){
	return ((double)f[y]-c[y]*s-f[x]+c[x]*s)/((double)c[y]-c[x]);
}
int solve(double val){
	int L=l,R=r-1,ans=-1;
	while(L<=R){
		int mid=(L+R)>>1;
		if(slope(q[mid],q[mid+1])>=val)ans=mid,R=mid-1;
		else L=mid+1;
	}
	if(-1==ans)return q[r];
	return q[ans];
}
signed main()
{
	scanf("%lld%lld",&n,&s);
	rep(i,1,n)scanf("%lld%lld",&t[i],&c[i]),
							 t[i]+=t[i-1],c[i]+=c[i-1];
	memset(f,0x7f,sizeof(f));
	f[0]=q[0]=l=r=0;
	rep(i,1,n){
		int j=solve((double)t[i]);
		f[i]=f[j]+t[i]*(c[i]-c[j])+s*(c[n]-c[j]);
		///cout<<i<<" "<<j<<" "<<f[i]<<endl;
		while(l<r&&slope(q[r-1],q[r])>=slope(q[r],i))r--;
		q[++r]=i;
	}
	printf("%lld\n",f[n]);
	return 0;
}
```

如果您使用上面这份代码进行评测，只有$80pts$（捂脸

貌似没有问题啊（哪错了呢

其实本题数据经过出题人（毒瘤）的精心构造，使得直接写``double``的``slope``函数的程序精度被卡

所以我们只用将不等式简化为两边都是乘积形式，这样就避免了除法产生的掉精度问题


```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define int long long
using namespace std;
int n,s,c[500005],t[500005],f[500005];
int q[500005],l,r;
int solve(int val){
	int L=l,R=r-1,ans=-1;
	while(L<=R){
		int m=(L+R)>>1;
		if((f[q[m+1]]-c[q[m+1]]*s-f[q[m]]+c[q[m]]*s)>val*(c[q[m+1]]-c[q[m]]))ans=m,R=m-1;
		else L=m+1;
	}
	if(-1==ans)return q[r];
	return q[ans];
}
signed main()
{
	scanf("%lld%lld",&n,&s);
	rep(i,1,n)scanf("%lld%lld",&t[i],&c[i]),
							 t[i]+=t[i-1],c[i]+=c[i-1];
	memset(f,0x7f,sizeof(f));
	f[0]=q[0]=l=r=0;
	rep(i,1,n){
		int j=solve((long double)t[i]);
		f[i]=f[j]+t[i]*(c[i]-c[j])+s*(c[n]-c[j]);
		///cout<<i<<" "<<j<<" "<<f[i]<<endl;
		while(l<r&&(f[q[r]]-c[q[r]]*s-f[q[r-1]]+c[q[r-1]]*s)*(c[i]-c[q[r]])>=(f[i]-c[i]*s-f[q[r]]+c[q[r]]*s)*(c[q[r]]-c[q[r-1]]))r--;
		q[++r]=i;
	}
	printf("%lld\n",f[n]);
	return 0;
}
```

---

## 作者：Unordered_OIer (赞：12)

# P5785 题解
$dp$是明显的
## 题意
一维序列切割问题
## 解答
这题有一个简化版：[$P2365$](https://www.luogu.com.cn/problem/P2365)，我们先来解决这个问题，再来思考[$P5785$](https://www.luogu.com.cn/problem/P5785)的答案  
$dp$是肯定的，所以我们先来设状态：  
设$f_{i,j}$表示**前$i$个机器分$j$批的最小代价**。那么转移方程就是：  
$$f_{i,j}=\min_{0 \leq k<i}\{f_{k,j-1}+(Sj+pT[i])(pC[i]-pC[k])\}$$
其中$pT,pC$分别为$t,c$的前缀和。  
因为有三重循环，所以是$\Theta(n^3)$的，$\text{TLE}$。

每个批次$S$都会**累加到之后的所有机器上**，干脆将这些代价计到$f$中。因此考虑状态优化。  
我们可以把$j$这一维省略。因此我们定义状态为：  
$f_i$表示前$i$个机器分**任意批次**的最小代价。转移方程：  
$$f_i=\min_{0 \leq k<i}\{f_k+pT_i(pC_i-pC_k)+S(pC_n-pC_k)\}$$
虽然优化完了，但是还是有$i,k$两重循环，复杂度$\Theta(n^2)$，还是$\text{TLE}$。

~~总不可能i这一维也给省掉吧~~

接下来要出场的将是一位~~重量级~~嘉宾：**决策单调性**优化。  
来一波分析~  
对于$k<j<i$，如$j$**对$i$的决策优于**$k$，那么：
$$\frac{f_j-f_k}{pC_i-pC_k}<S+pT_i$$
那么我们可以用$\color{red}{斜率递增}\color{black}{意义下的}\color{blue}{单调队列}$维护候选的决策。  
此处我们简记$j,k$的斜率为$slope(j,k)$  
开始分析决策：  
如果$slope(q_l,q_{l+1})<S+pT_i$，而$S+pT_i$单调递增，则$q_l$永远不可能成为最优决策。  
否则$q_l$就是最优决策。  
复杂度就是单调队列的复杂度，即$\Theta(n)$，可以$\Huge{\color{lightgreen}{AC}}$。  
代码就放单调队列吧：
```cpp
while(head+1<tail&&slope(q[head],q[head+1])<=s+pT[i])head++;
while(head<tail-1&&slope(q[tail-1],q[tail-2])>=slope(i,q[tail-1]))tail--;
```

然后我们回到此题。我们可以发现这题和$P2365$不同的地方（除了数据）是$T_i$可能为负，那么导致变化的就是$S+pT_i$**不一定单调递增**了。  
于是就不能单调队列出队首了，但由于斜率还是**单调递增**的，因此我们仍旧可以采用**二分答案**的方法来解决这一题。

复杂度：$\Theta(n \log n)$，可以$\Huge{\color{lightgreen}{AC}}$。  

放个二分的板子吧：
```cpp
if(left==right-1)return q[left];
ll Left=left,Right=right-1;
while(Left<Right){
	ll mid=(Left+Right)>>1;
	if(check(mid,k))Left=mid+1;
	else Right=mid;
}
```
 
看我写了这么多，给个赞呗

---

## 作者：GoPoux4 (赞：7)

斜率优化入门题。

---

### 什么是斜率优化

答：用线性规划的方法优化状态转移。

至于什么是线性规划，请翻高一数学。

---

先抛开优化，写出状态转移方程。

可以写出这个方程：设 $i$ 表示处理到了第几个任务，$j$ 表示之前机器启动了几次， $f[i][j]$ 表示最少的费用，则：

$$f[i][j]=min \left\{ f[k][j-1]+(sumt[i]+s*j)*(sumc[i]-sumc[k]) \right\} \ (0 \leq k<i)$$

其中 $sumt[i]= \sum_{j=1}^it[j],sumc[i]=\sum_{j=1}^ic[j]$。

~~不T掉都会MLE。~~

考虑将 $s$ 对后面的任务结束时刻的影响提前计算，减少枚举 $j$ 的复杂度，则有：

$$f[i]=min\{f[j]+sumt[i]*(sumc[i]-sumc[j])+s*(sumc[n]-sumc[j])\} \ (0 \leq k<i)$$

这样你可以A掉P2365。

但是这题 $O(n^2)$ 的算法显然过不去，所以使用斜率优化。

---

### 斜率优化

设 $f[i]$ 由 $f[j]$ 转移而来，则有：

$$f[i]=f[j]+sumt[i]*(sumc[i]-sumc[j])+s*(sumc[n]-sumc[j])$$

变换一下：

$$(sumt[i]+s)*sumc[j]-sumt[i]*sumc[i]-s*sumc[n]+f[i]=f[j]$$

这样就可以看作一条直线的解析式， $sumt[i]+s$ 为直线的斜率。当 $i$ 确定时，直线的斜率即可确定。

想象平面直角坐标系中有若干点，这些点的坐标为 $(sumc[j],f[j])$ $(j<i)$ ，一条斜率为 $sumt[i]+s$ 的直线过这其中的一个点，使得 $f[i]$ 最小，即直线与 $y$ 轴的截距 $f[i]-sumt[i]*sumc[i]-s*sumc[n]$最小。

![](https://cdn.luogu.com.cn/upload/image_hosting/fzwb9eeq.png)

 _图来自OIWiki_ 

很明显有无用点，不可能取到这些点。剩下的点构成了一个**凸壳**，所以维护这个凸壳即可。

---

### 如何维护凸壳

如果 $sumt[i]$ 和 $sumc[i]$ 均单调递增，即每次转移的直线的斜率单调递增，每次插入凸壳中的点横坐标单调递增，此时用单调队列维护下凸壳。

那么每次就可以把与下一个点形成的直线的斜率小于 $sumt[i]+s$ 的点从单调队列中弹出，因为下一条直线的斜率只会比当前直线的斜率大，更不可能取到这个点。

之后再把新的点 $(sumc[i],f[i])$ 加入单调队列中。

但是当你看到数据范围：$|T_i| \leq 2^8$ ~~做一件任务会让时间倒流~~，你发现事情并不是这么简单。 这意味这$sumt[i]$并不单调，直线的斜率并不单调，所以必须维护整个凸壳，用单调栈维护即可。

---

### 代码

$O(n^3)$代码，TLE+MLE：

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#define maxn 5005
#define R register
#define INF 0x3f3f3f3f
#define lxl long long
using namespace std;

inline lxl read()
{
	lxl x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}

lxl n,s,sumt[maxn],sumc[maxn];
lxl f[maxn][maxn];

int main()
{
	//freopen("P2365.in","r",stdin);
	n=read(),s=read();
	for(R int i=1;i<=n;++i)
	{
		sumt[i]=sumt[i-1]+read();
		sumc[i]=sumc[i-1]+read();
	}
	memset(f,0x3f,sizeof(f));
	f[0][0]=0;
	for(R int i=1;i<=n;++i)
		for(R int j=1;j<=i;++j)
			for(R int k=0;k<i;++k)
				f[i][j]=min(f[i][j],f[k][j-1]+(sumt[i]+s*j)*(sumc[i]-sumc[k]));
	lxl ans=INF;
	for(int i=1;i<=n;++i)
		ans=min(ans,f[n][i]);
	printf("%lld",ans);
	return 0;
}

```

$O(n^2)$代码，P2365AC，本题20：

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#define maxn 5005
#define R register
#define INF 0x3f3f3f3f
#define lxl long long
using namespace std;

inline lxl read()
{
	lxl x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}

lxl n,s,sumt[maxn],sumc[maxn];
lxl f[maxn];

int main()
{
	//freopen("P2365.in","r",stdin);
	n=read(),s=read();
	for(R int i=1;i<=n;++i)
	{
		sumt[i]=sumt[i-1]+read();
		sumc[i]=sumc[i-1]+read();
	}
	memset(f,0x3f,sizeof(f));
	f[0]=0;
	for(R int i=1;i<=n;++i)
		for(R int j=0;j<i;++j)
			f[i]=min(f[i],f[j]+sumt[i]*(sumc[i]-sumc[j])+s*(sumc[n]-sumc[j]));
	printf("%lld\n",f[n]);
	return 0;
}
```

$O(n)$ 代码，保证$sumt[i]$ 单调，P2365AC：

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#define maxn 5005
#define R register
#define INF 0x3f3f3f3f
#define lxl long long
using namespace std;

inline lxl read()
{
	lxl x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}

lxl n,s,sumt[maxn],sumc[maxn];
lxl f[maxn],q[maxn],l=1,r;

int main()
{
	//freopen("P2365.in","r",stdin);
	n=read(),s=read();
	for(R int i=1;i<=n;++i)
	{
		sumt[i]=sumt[i-1]+read();
		sumc[i]=sumc[i-1]+read();
	}
	memset(f,0x3f,sizeof(f));
	f[0]=0;
	q[++r]=0;
	for(R lxl i=1;i<=n;++i)
	{
		while(l<r&&(f[q[l+1]]-f[q[l]])<=(sumt[i]+s)*(sumc[q[l+1]]-sumc[q[l]])) ++l;
		f[i]=f[q[l]]+sumt[i]*(sumc[i]-sumc[q[l]])+s*(sumc[n]-sumc[q[l]]);
		while(l<r&&(f[q[r]]-f[q[r-1]])*(sumc[i]-sumc[q[r]])>=(f[i]-f[q[r]])*(sumc[q[r]]-sumc[q[r-1]])) --r;
		q[++r]=i;
	}
	printf("%lld\n",f[n]);
	return 0;
}
```

$O(n \ {\rm{log}} \ n)$代码，不保证$sumt[i]$单调，AC代码：

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#define maxn 300005
#define lxl long long
#define INF 0x3f3f3f3f
using namespace std;

inline lxl read()
{
	lxl x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}

lxl n,sumt[maxn],sumc[maxn],s;
lxl f[maxn],q[maxn],r;

int main()
{
	//freopen("P5785.in","r",stdin);
	n=read();s=read();
	for(int i=1;i<=n;++i)
	{
		sumt[i]=sumt[i-1]+read();
		sumc[i]=sumc[i-1]+read();
	}
	memset(f,0x3f,sizeof(f));
	q[++r]=f[0]=0;
	for(lxl i=1;i<=n;++i)
	{
		int ans;
		if(r>1)
		{
			int L=1,R=r;
			while(L<=R)
			{
				int mid=(L+R)>>1;
				if(f[q[mid+1]]-f[q[mid]]<(sumt[i]+s)*(sumc[q[mid+1]]-sumc[q[mid]])) L=mid+1;
				else R=mid-1,ans=mid;
			}
			// ans=L;
		}
		else ans=1;
		f[i]=f[q[ans]]+sumt[i]*(sumc[i]-sumc[q[ans]])+s*(sumc[n]-sumc[q[ans]]);
		while(r>1&&(f[q[r]]-f[q[r-1]])*(sumc[i]-sumc[q[r]])>=(f[i]-f[q[r]])*(sumc[q[r]]-sumc[q[r-1]])) --r;
		q[++r]=i;
	}
	printf("%lld",f[n]);
	return 0;
}
```


---

## 作者：wangyizhi (赞：6)

[**题目传送门**](https://www.luogu.com.cn/problem/P5785)

貌似现有的题解中没有我这种神奇的做法？

~~也许是不大符合正常斜率优化的写法。~~

## 题意分析

以下记原题中 $c$ 的前缀和为 $C$，$t$ 的前缀和为 $T$。

首先，如果你做过这题的弱化版[P2365 任务安排](https://www.luogu.com.cn/problem/P2365)，就可以列出一个 $O(n^2)$ 的状态转移方程：

$$$f_i=\min\{dp_j+(s+T_i-T_j)(F_n-F_j)\}$$$

将其中的柿子写成关于 $T_i$ 的直线方程：

$$$f_i=\min\{(F_n-F_j)T_i+dp_j+(s-T_j)(F_n-F_j)\}$$$

然后问题就转化成了求一堆直线在一点处的最小值。

那么我们只需要维护能取到最小值的直线就行了，然后再根据交点二分求出这一点在哪条直线上进而求出结果。

  如果你做过[P3194 水平可见直线](https://www.luogu.com.cn/problem/P3194)的话，就应该会这个做法了。先将直线按斜率排序，然后一个个加进去。由于 $F_n-F_j$ 是递减的，所以这里就不需要排序了，一边维护直线一边 DP 就行了。

于是这题就做完了。

## AC Code

```cpp
// by wangyizhi(571247)
#include<iostream>
using namespace std;
using ll=long long;
using ld=long double;
#define int ll
using pii=pair<int,int>;
const int N=3e5+1;
int t[N],f[N],dp[N],st[N],top=0;
struct line
{
	int k,b;
	inline int get(int x){return k*x+b;}
}l[N];
inline ld inter(line x,line y){return (ld)(y.b-x.b)/(x.k-y.k);}
signed main()
{
	int n,s;
	cin>>n>>s;
	for(int i=1;i<=n;i++) cin>>t[i]>>f[i],t[i]+=t[i-1],f[i]+=f[i-1];
	l[0]={f[n]-f[0],(s-t[0])*(f[n]-f[0])};
	for(int i=1;i<=n;i++)
	{
		if(!top) dp[i]=l[st[top]].get(t[i]);
		else if(t[i]>=inter(l[st[top]],l[st[top-1]])) dp[i]=l[st[top]].get(t[i]);
		else
		{
			int le=0,ri=top-1,mid,res=0;
			while(le<=ri)
			{
				mid=(le+ri)/2;
				if(inter(l[st[mid]],l[st[mid+1]])>=t[i]) res=mid,ri=mid-1;
				else le=mid+1;
			}
			dp[i]=l[st[res]].get(t[i]);
		}
		l[i]=line{f[n]-f[i],dp[i]+(s-t[i])*(f[n]-f[i])};
		if(!top) st[++top]=i;
		else // top>=1
		{
			while(top&&(
				(l[i].k<l[st[top]].k&&inter(l[i],l[st[top]])<=inter(l[st[top]],l[st[top-1]]))
				||(l[i].k==l[st[top]].k&&l[i].b<l[st[top]].b)
			)) top--;
			if(!top||inter(l[i],l[st[top]])>inter(l[st[top]],l[st[top-1]])) st[++top]=i;
		}
	cout<<dp[n]<<"\n";
	return 0;
}
```

---

## 作者：Linshey (赞：6)

算是为我自己的斜率优化做一个总结吧

首先设计转移方程。设$f_{i, j} =直到第i个task用了j秒的最小花费$ ，状态转移方程很明显。$f_{i, j} = min{f_{f, t - sumT_{i} + sumT_{j} - s} + t * (sumF_i - sumF_j)}$，用一个单调队列优化即可达到O(nt),超时

那么就要优化。注意到我们的转移已经是$O(1)$的了，只能在状态上进行优化。这里用的是大蓝书上的$\color{red}\text{费用提前计算}$。既然我们要消去t这一维，那么我们就要尝试做一点构造：我们提前把这开机时间的后面会花的钱付了，后面计算时间时就只剩下$ sumT $这一个要考虑的了。

状态：$F_i$, 方程：$F_i = min{F_j + s * (sumC_N - sumC_j) + sumT_i * (sumC_i - sumC_j)}$

开始斜率优化操作：将方程转换为$F_j = (s + sumT_i)*sumC_i + F_i - s * sumC_N - sumT_i*sumC_i$.可以将$(s + sumT_i)$ 看作是斜率，$(sumC_i, F_j)$看作是一个点，$F_i - s * sumC_N - sumT_i*sumC_i$为过这个点、斜率为前者的一次函数的纵截距，显然我们要让截距尽可能小，所以我们维护每一个点对应决策点$(sumC_i, F_j)$的下突壳，每次在突壳上二分。

为什么要二分呢？因为是个下突壳，纵截距移来移去是丹凤的。

为什么有的题目不要二分、用单调队列即可呢？因为那题中，$\color{red}\text{斜率递增}$

上代码：
```cpp

#include <iostream>
#define int long long

using namespace std;
const int maxn = 3e5 + 10;

int n, s, t[maxn], c[maxn];
int sumT[maxn], sumC[maxn], f[maxn], q[maxn], tail = 0;

signed main()
{
	cin >> n >> s;
	for (int i = 1; i <= n; i++)
	{
		cin >> t[i] >> c[i];
		sumT[i] = sumT[i - 1] + t[i];
		sumC[i] = sumC[i - 1] + c[i];
	}
	for (int i = 1; i <= n; i++)
	{
		int l = 0, r = tail;
		while (l < r)
		{
			int mid = (l + r) >> 1;
			if (f[q[mid]] - (s + sumT[i]) * sumC[q[mid]] >= f[q[mid + 1]] - (s + sumT[i]) * sumC[q[mid + 1]])
			{
				l = mid + 1;
			}
			else
			{
				r = mid;
			}
		}
		f[i] = f[q[r]] + s * (sumC[n] - sumC[q[r]]) + sumT[i] * (sumC[i] - sumC[q[r]]);
		while (tail && ((f[i] - f[q[tail]]) * (sumC[q[tail]] - sumC[q[tail - 1]]) <=
			(f[q[tail]] - f[q[tail - 1]]) * (sumC[i] - sumC[q[tail]]))) tail--;
		tail++;
		q[tail] = i;
	}
	cout << f[n] << endl;
	return 0;
}
```
说说我在哪里调了半天吧

注意
```cpp
while (tail && ((f[i] - f[q[tail]]) * (sumC[q[tail]] - sumC[q[tail - 1]]) <=(f[q[tail]] - f[q[tail - 1]]) * (sumC[i] - sumC[q[tail]]))) tail--;
```
的小于号，如果像我一样一不小心加反了，就成了上突壳，答案就没有那么优秀了。

---

## 作者：Talaodi (赞：4)

设 $f_i$ 为完成前 $i$ 个的任务的最小花费，$t_i=\sum_{k=1}^iT_i,c_i=\sum_{k=1}^iC_i$
。则状态转移方程为：

$$f_i=\min_{0\le j<i}\{f_j+t_ic_i-t_ic_j+Sc_n-Sc_j\}$$

（这点不懂的可以去看看[P2365](https://www.luogu.com.cn/problem/P2365)）

整理得：

$$f_i-Sc_n-t_ic_i=f_j-Sc_j-t_ic_j$$

令 $f_i-Sc_n-t_ic_i=B,f_j-Sc_j=y,c_j=x,t_i=k$，则 $B=y-kx$ 即 $y=kx+B$。考虑进行斜率优化，由于我们找的是 $B_{min}$ 所以维护下凸包。

**注意：题目中写的是 $|T_i|\le2^8$ 所以有可能 $T_i<0$，因此 $t_i$ 不单调增，不能用单调队列，需要用二分查找决策点。**

时间复杂度：$O(n\log n)$

[参考代码（C++，$1.81s$）](https://www.luogu.com.cn/record/34697040)：
```cpp
#include <iostream>
#include <algorithm>
#define int long long

struct Point {
	int x, y;
};

int c[300001];
int t[300001];
int dp[300001];
Point deque[300003];
int l = 1;
int r = 1;

signed main() {
	int n, s;
	std::cin >> n >> s;
	for (int i = 1; i <= n; i++) {
		std::cin >> t[i] >> c[i];
		t[i] += t[i - 1];
		c[i] += c[i - 1];
	}

	for (int i = 1; i <= n; i++) {
		int k = t[i];
		int left = l;
		int right = r - 1;
		int ans = 0;
		while (left <= right) {
			int mid = (left + right) / 2;
			if (deque[mid + 1].y - deque[mid].y > k * (deque[mid + 1].x - deque[mid].x)) {
				right = mid - 1;
				ans = mid;
			} else {
				left = mid + 1;
			}
		}

		if (!ans) {
			ans = r;
		}

		Point choice = deque[ans];
		dp[i] = choice.y - choice.x * k + s * c[n] + t[i] * c[i];
		Point now = {
			c[i], dp[i] - s * c[i]
		};
		while (r - l + 1 >= 2 && (now.y - deque[r].y) * (deque[r].x - deque[r - 1].x) <= (deque[r].y - deque[r - 1].y) * (now.x - deque[r].x)) {
			r--;
		}

		r++;
		deque[r] = now;
	}

	std::cout << dp[n];

	return 0;
}
```

---

## 作者：Mr_Skirt (赞：3)


# 题意
有$n (n\leq 3\times10^5)$个任务需要被完成，你可以把这些任务全部分成任意多组，每组内的任务必须连续。同组任务会在同一时刻完成，所花时间为$\sum_{i=l}^{r}t_i$，同时每组任务开始有一个预热时间$s$。任务$i$完成的费用为完成时间乘以$c_i$，求如何分组能让费用最小。


## 解题思路
既然要把所有任务都分组，那么我们只需要知道每个任务属于哪一个组所需费用最小即可。对于任务$i$，我们想要知道从之前哪个任务分过来费用最小。于是考虑动态规划，设$f(i)$为从$1~i$分组完成，所需的最少费用，答案则是$f(n)$。但是有个启动时间$s$不好处理，怎么办呢。利用费用提前思想，每次启动机器的时间一定会给后面的任务贡献费用，那么转移方程为：

$$
f(i) = \min_{j<i}\{f(j) + (F_i - F_j) * T_i + s * (F_n - F_j)\}
$$

式子中$F_i$表示费用的前缀和，$T_i$表示时间的前缀和。

显然暴力寻找是$O(n^2)$，但是可以用斜率优化DP的套路去降时间复杂度。考虑到费用$F_i$是单调不减的，那么显然$j$越小需要的费用越大，这就让我们想到决策可能是随着$i$增大而单调不减的，打表也证实了这一点。由于决策单调性的存在，我们的目标可以转变成计算出什么时候需要更新决策。

于是考虑此时我们在$i$，决策$j$能替换掉原有决策$k$，根据单调性此时一定有$j>k$，且
$$
f(j) + (F_i - F_j)T_i + s(F_n - F_j) \leq f(k) + (F_i - F_k)T_i + s (F_n - F_k)
$$
即
$$
f(j) + F_iT_i - F_jT_i + sF_n - sF_j \leq f(k) + F_iT_i - F_kT_i + sF_n - sF_k
$$
消掉不变的项
$$
f(j) - F_jT_i - sF_j \leq f(k) - F_kT_i - sF_k
$$
移项，尽量让带$T_i$的在左边，$j, k$在右边
$$
T_i(F_k - F_j) \leq f(k)- f(j) - sF_k + sF_j
$$
这里要格外小心，由于$j>k$，一定有$F_j>F_k$，即$F_k - F_j \leq 0$。此时等于$0$的情况必须特判，而小于$0$的情况需要让不等式变号！最终结果：
$$
T_i \geq \frac{f(k)- f(j) - sF_k + sF_j}{F_k - F_j}
$$
由此我们可以得出结论，令$slope(k, j) = \frac{f(k)- f(j) - sF_k + sF_j}{F_k - F_j}$。当$slope(k, j) \leq T_i$时，有$j$优于$k$（因为$j>k$所以$j$会比较靠后，是更优解），此时这个$slope(k, j)$可以看成是点$k$到点$j$的斜率。

我们进一步分析这个斜率，假设当前$j$打败了$k$，新来了一个$i > j$，如果有$slope(j, i) \leq slope(k,j)$那么此时$j$也不占优势了。因为无论后面的$T_{i+1}$值是多少，$slope(j, i)$都会比$slope(k,j)$更容易小于$T_{i+1}$，而此时$i$又比$j$打，那么$j$就再也打不过$i$了。此时清除$j$这个废物，不然整个序列就不符合后面的具有比前面更优的潜力这个性质了（即决策单调）。

整理一下得到的两个性质
$$
\begin{cases}
    slope(k, j) &\leq T_i  &\text{此时j替换k}\\\\
    slope(k, j) &\geq slope(j, i)  &\text{此时j比不过i}
\end{cases}
$$
根据这两个性质我们就可以写出一个单调队列，里面存储的就是位置$i$，最优决策则可以通过这两个性质取得。
```cpp
    int l = 0, r = 0;
    for (int i = 1; i <= n; i++) {
        // 性质1，QQ是单调队列
        while (l < r && slope(QQ[l], QQ[l + 1]) <= T[i]) ++l;
        int opt = QQ[l];
        dp[i] = dp[opt] + ...
        // 性质2
        while (l < r && slope(QQ[r - 1], QQ[r]) >= slope(QQ[r], i)) --r;
        QQ[++r] = i;
    }
```

但是仔细看这题的数据范围，$|t_i|\leq2^8$，啥意思，就是$t_i$可能是负数，也就是$T_i$并非单调增。我们的代码这一行`while (l < r && slope(QQ[l], QQ[l + 1]) <= T[i]) ++l;`就是基于$T_i$是单调增的情况，我们去除之前一定不会比现在更优的点。但是如果$T_i$并非单调增，被去掉点有可能在此时是最优解，于是我们只能删掉这一行。

那么问题来了，我们怎么知道哪个点是最优解呢？首先，我们利用性质1和2维护了一个斜率单调下降的序列，那么对于一个$T_i$，只要知道满足$slope(j, j+1) \leq T_i$且最大的$j+1$，就是最优解。于是我们可以使用二分。二分找指定条件的方法我在之前的博客中介绍过，这里就不多讲了。

最后一个极其重要的点就是由于这题的毒瘤性质$c_i$可以是$0$，也就是$F_j-F_k$可能是$0$，这会严重影响决策正确性。因为$slope(k, j)$此时有可能是正无穷也有可能是负无穷（因为分子不一定是正的），它们显然会干扰性质1和2。此时我们就要想，当$c_k$为$0$的时候我们是包括它还是不包括它更好呢？显然是要包括啊，免费的你还不要！也就是说，当$j>k$的时候，我们不要去替换成$j$，而是能留多久留多久，如果要替换那就直接越过$j$，此时$j$毫无卵用。于是我们最好就把$slope(j,k)$设为正无穷大，使得它无论怎样都不会成为最优解，这样就不会有错了。


## 时间复杂度
$O(n\log{n})$

## 参考代码
```cpp
// j > k
double slope(int k, int j) {
    if (F[k] == F[j]) return 1.0 / 0.0;
    return (dp[k] - dp[j] + s * (double)(F[j] - F[k])) / (double)(F[k] - F[j]);
}

int bSearch(int l, int r, ll v) {
    if (l == r) return QQ[l];
    int ans = r;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (slope(QQ[mid + 1], QQ[mid]) >= v)
            ans = mid, r = mid - 1;
        else
            l = mid + 1;
    }
    return QQ[ans];
}

int main() {
#ifdef LOCALLL
    freopen("in", "r", stdin);
    freopen("out", "w", stdout);
#endif
    n = read<ll>();
    s = read<ll>();
    for (int i = 1; i <= n; i++) {
        ll t = read<ll>(), c = read<ll>();
        T[i] = T[i - 1] + t, F[i] = F[i - 1] + c;
    }
    int l = 0, r = 0;
    for (int i = 1; i <= n; i++) {
        int opt = bSearch(l, r, T[i]);
        dp[i] = dp[opt] + (F[i] - F[opt]) * T[i] + s * (F[n] - F[opt]);
        while (l < r && slope(QQ[r - 1], QQ[r]) >= slope(QQ[r], i)) --r;
        QQ[++r] = i;
    }
    printf("%lld", dp[n]);
    return 0;
}
```

---

## 作者：Rui_R (赞：2)

人生第一道斜率优化。

题意：$n$个任务，每个任务有一个完成所需时间$t$和一个代价$c$，可以将它们任意分成几份，但不能改变其顺序。开始每组任务需要一个s的时间。每组任务的代价为该组任务的代价和* 该组任务的完成时刻。

[原题](https://www.luogu.com.cn/problem/P5785)

首先，考虑DP：

设$dp[i][j]$为前i个任务分成j组的最小代价和。

显然有$dp[i][j]=min$ $ {dp[k][j]+(sumc[i]-sumc[k])*(sumt[i]+s*j)}$

$O(n^3)$。3e5。emmm。试试减一维。

难以减一维的原因是这个s。如果对每个状态计算其目前的s，势必会$n^3$。

考虑将$s$对之后的影响计算到dp中。

那么有$dp[i]=min$ $ dp[j]+sumt[i]* (sumc[i]-sumc[j])+s*(sumc[n]-sum[j])$

$O(n^2)$。对于5000的弱化版，已经没问题了。但对于3e5的本题来说....

整理式子得到：$dp[i]=min{}$

$dp[j]+sumt[i]*sumc[i]-sumt[i]*sumc[j]+s*sumc[n]-s*sum[j]$

其中$sumt[i]*sumc[i],s*sumc[n]$在我们考虑$dp[i]$的时候，都可以视为常数$b$

那么，$sumc[j]*sumt[i]+(dp[i]-b)=dp[j]$,其中$sumt[i]$在考虑i的时候也是常数（此处$dp[i]$是根据当前$j$得到的$dp[i]$,不一定是最优解）

唉... 这不是一次函数吗？

如果我们把每个j以$(sumc[j],dp[j])$ 的形式表示在直角坐标系上，那对于每个$i$来说，既然我们要让$dp[i]$最小，就是让过$(sumc[j],dp[j])$且斜率为$sumt[i]$的直线与y轴的交点值最小

后文中出现的点即为($sumc[j]$,$dp[j]$)

更具体的，想象有一根斜率为$sumt[i]$的直线，在上述坐标系中从下往上靠，碰到的第一个点对应的$j$就是最优的$j$

那么，如果说有三个点之间的斜率是不递增的，中间那个点一定没有意义。

可以画幅图看一下，就能够非常直观的感受到这一点(两个点中有一个点往上凸)

那么我们就可以用单调队列维护一个满足斜率单调递增的点序列，对于每个$i$二分去找序列中第一个斜率大于$sumt[i]$的点(即第一个碰到的点，可以画个图看看)

剩下的细节请参考代码。加了注释。

$Code:$

~~~
#include <cstdio>
#include <cstring>

const int maxn=3e5+5;

#define int long long//代码陋习

int n,s,sum_t[maxn],sum_f[maxn];

int dp[maxn];

inline int min(int a,int b){
	return a<b?a:b;
}

inline bool sans(int x,int y,int z){
	return (dp[y]-dp[x])*(sum_f[z]-sum_f[y])< (dp[z]-dp[y])*(sum_f[y]-sum_f[x]);
}//判断斜率是否单调递增

int q[maxn],head=1,tail=0;

inline int get_pos(int k){
	int l=head,r=tail-1,res=tail;
	while(l<=r){
		int mid=(l+r)>>1;
		if(dp[q[mid+1]]-dp[q[mid]]>k*(sum_f[q[mid+1]]-sum_f[q[mid]])){
			res=mid;
			r=mid-1;
		}else l=mid+1;
	}
	return q[res];//二分找第一个斜率大于当前直线斜率（k）的点
}

signed main(){
	scanf("%lld%lld",&n,&s);
	for(int i=1;i<=n;i++){
		int a,b;
		scanf("%lld%lld",&a,&b);
		sum_t[i]=sum_t[i-1]+a;
		sum_f[i]=sum_f[i-1]+b;
	}
	// std::memset(dp,63,sizeof(dp));
	dp[0]=0;q[++tail]=0;//将0入队
	//这样可以通过0这个点，表示出从1取到i这个方案
	for(int i=1;i<=n;i++){
		// for(int j=0;j<i;j++){
		// 	dp[i]=min(dp[i],dp[j]+(sum_f[i]-sum_f[j])*sum_t[i]+s*(sum_f[n]-sum_f[j]));
		// }
        
		// while(head+1<=tail&&dp[q[head+1]]-dp[q[head]]<(sum_t[i]+s)*(sum_f[q[head+1]]-sum_f[q[head]])) head++;
		//当直线斜率k单调递增时，可以加这一步操作，之后不用二分，直接找到队头即可
		//（因为一个点的斜率要是现在就不如k，它以后还是不如k）
		//但是这道题很神奇，它的t作为一个时间，可以是负的，导致sum_t不单调递增
		//于是只能二分
		int j=get_pos(sum_t[i]+s);//目标点
		dp[i]=dp[j]+(sum_f[i]-sum_f[j])*sum_t[i]+s*(sum_f[n]-sum_f[j]);//计算dp[i]的最优解
		while(head<=tail-1&&!sans(q[tail-1],q[tail],i)) tail--;//使斜率单调递增
		q[++tail]=i;//将i入队
		// printf("i:%d dp[i]:%d\n",i,dp[i]);
	}
	printf("%lld\n",dp[n]);
	return 0;
}
~~~

---

## 作者：_LHF_ (赞：2)

# 题解
在看这一篇题解之前，建议先看一下[这篇题解](https://www.luogu.com.cn/blog/LHF/solution-p2365)。

P2365任务安排是这一题的弱化版，建议先AC了弱化板再来做这一题。

好了，顺着那一片题解继续讲下去。

如果代码原封不动地交上来，会错得很惨，因为这一题的数据范围其中：$|T_i|\leq 2^8$，证明$T_i$的前缀和不再单调递增，不过也不是没有办法。

因为斜率优化维护的点形成了一个凸包，所以这一题中如果不是这一次第一次碰到的点，也并不可能下一次不是第一个碰到。

所以，我们不能维护单调队列了，我们应该维护一个单调栈，每一次在栈里面二分最先碰到的值。因为维护的是凸包，而且斜率单调递增，所以可以进行二分（三分应该也可以吧）。时间复杂度为$0(n \log n)$
### Code:
```cpp
#include<cstdio>
#include<cstring>
#define N 1000010
#define int long long
using namespace std;
int n,s,t[N],c[N],dp[N];
int len,w,d[N];
int search(int k)
{
	int l=1,r=len,mid;
	while(l<r)
	{
		mid=(l+r)/2;
		if(dp[d[mid+1]]-dp[d[mid]]<=k*(c[d[mid+1]]-c[d[mid]]))
			l=mid+1;
		else r=mid;
	}
	return d[l];
}
signed main()
{
	scanf("%lld%lld",&n,&s);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld%lld",&t[i],&c[i]);
		t[i]+=t[i-1];
		c[i]+=c[i-1];
	}
	len=1;
	for(int i=1;i<=n;i++)
	{
		w=search(s+t[i]);
		dp[i]=dp[w]+t[i]*c[i]+s*c[n]-c[w]*(s+t[i]);
		while(len>1&&(dp[i]-dp[d[len]])*(c[d[len]]-c[d[len-1]])<=
				(dp[d[len]]-dp[d[len-1]])*(c[i]-c[d[len]])) len--;
		d[++len]=i;
	}
	printf("%lld",dp[n]);
}
```
注意不要用除法计算，因为这一题卡精度。

---


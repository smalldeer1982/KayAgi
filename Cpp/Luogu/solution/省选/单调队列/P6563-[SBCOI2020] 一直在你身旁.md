# [SBCOI2020] 一直在你身旁

## 题目背景

转眼间，又到春天...  
站在这里，我才发现，  
原来，我的心，  
已与那座被光玉守护的小镇相连。   
......  
“又到了一年春天啊...”  
“看来，你已经准备留在这里了呢。”  
“其实，我也没有什么远大的理想，只是努力地维持着现状...”  
“不过，只要能实现自己的梦想，这又有什么关系啊...”  
“但是现在，我真的是非常的开心。就像你说的那样，找到了很多快乐的事情...”  
“我也和你一样，处在同一个世界。世界上没有一成不变的事物。
所以只要以其他方式找到自己的快乐就行了...”  
“对啊，是时候开始新的生活了呢......”

![](https://cdn.luogu.com.cn/upload/image_hosting/frgxpnaw.png)  

“你对这个小镇真是执着呢...”  
“因为，这里满是我不想忘记的回忆啊...”  

## 题目描述

回到这座小镇后，她的新工作是维修电线。    
现在，有一根电线坏了。已知电线长度可能为 $1,2,\cdots,n$ 中的一个数。现在，她需要知道电线的长度。  
她可以花费 $a_i$ 块钱购买长度为 $i$ 的电线。购买这根电线后，她能知道所需要的电线长度是否 **大于** $i$。  
保证 $a_1 \le a_2 \le \cdots \le a_n \le 10^9$。  
问她至少要花多少钱才能保证知道需要电线的长度。  

## 说明/提示

【样例解释】

买一根长度为 $1$ 的电线，就能知道需要的长度是否大于 $1$，也就能确定是 $1$ 还是 $2$，所以答案就是 $1$。

大样例[链接](https://www.luogu.com.cn/paste/csusv11e)。

【数据范围】

本题捆绑测试，共有 $4$ 个子任务。

$(Subtask 1)(10\%)$，$n \le 15$。


$(Subtask 2)(10\%)$，$n \le 500$。

$(Subtask 3)(30\%)$，$n \le 2000$。


$(Subtask 4)(50\%)$，没有任何额外限制。

对于100%的数据点, $ 1 \le n,\sum n \leq 7100,T \leq 500 $。$\sum n$ 表示所有数据中 $n$ 的和。

## 样例 #1

### 输入

```
1
2
1 2```

### 输出

```
1```

# 题解

## 作者：lgswdn_SA (赞：35)

2022.07.05 改了一个 typo。

突然发现有这题，推荐一做。

和出题者谈话后觉得我应该要提前4年退役了。

![image.png](https://i.loli.net/2020/06/29/bcOxVETa1Butry3.png)

暴力就不说了。

### $\texttt{Subtask 2 }$

如果数在一个区间 $[l,r]$，我们随便选一个数 $k$，会得到这个数是否大于 $k$，并且付出 $a_k$ 的代价。复出后，我们可以得到信息：电线的长度 $x\in [l,k]$ 或者 $x\in [k+1,r]$。这不就是区间dp吗qwq，

设计状态 $f(l,r)$ 代表知道 $x\in [l,r]$ 后要多少步确定 $x$。转移方程为 $f(l,r)=\min\limits_{l\le k<r} \small \max (f(l,k),f(k+1,r))+a_k$

复杂度 $O(Tn^3)$。

```cpp
namespace subtask2 {
	int f[509][509];
	void main(){
		memset(f,0x3f,sizeof(f));
		per(l,n,1) rep(r,l,n) {
			if(l==r) f[l][r]=0;
			else if(r-l==1) f[l][r]=a[l];
			else rep(k,l,r-1) f[l][r]=min(f[l][r],max(f[l][k],f[k+1][r])+a[k]);
		}
		printf("%lld\n",f[1][n]);
	}
}
```

### $\texttt{Subtask 2 }$

这个决策 $k$ 很烦人。

把决策和答案打印出来，发现……
（大样例的样例2的第三个数据 $l=7$ 的情况，打印每一行为 l,r,决策,f[l][r]）
```
...
7 9 8 15
7 10 8 17
7 11 9 24
7 12 10 27
7 13 9 32
7 14 10 35
7 15 11 38
...
```
决策没有特别规律。

再看看式子，$\min\limits_{l\le k<r} \small \max (f(l,k),f(k+1,r))+a_k$。好像类似于 $f_x+a_x$ 的形式，有点单调队列的意思。

但是，这个 $\max$ 直接埋没了这个式子优化的潜力。所以我们直接分类讨论，看 $f(l,k)>f(k+1,r)$ 的情况和 $f(l,k)<f(k+1,r)$ 的情况。

稍微思考一下得知，由于上面打表（和思考）得知，$f(l,k)$ 随着 $k$ 的增加而增加，$f(k+1,r)$ 随着 $k$ 的增大而减小，所以 $f(l,k)-f(k+1,r)$ 是单调的，所以我们只需要找到最小的 $k$ 使得 $f(l,k)>f(k+1,r)$，即这个分界点。

现在有 3 步，找到分界点，讨论 $f(l,k)>f(k+1,r)$ 的情况和讨论 $f(l,k)<f(k+1,r)$ 的情况。

**Step 1 找到分界点**

这里有单调性！

对于 $f(l,x)$ 分界点是单调不降的！也就是 $f(l,r)$ 的分界点在 $f(l,r+1)$ 的左边或者相同。（傻子都能想出来？）

**Step 2 计算 $f(l,k)>f(k+1,r)$ 的情况** 

这种情况，原式化为 $f(l,r)=\min f(l,k)+a_k$。这玩意儿是单调的，所以每次取最左端的 $k$ 即可。

**Step 3 计算 $f(l,k)\le f(k+1,r)$ 的情况**

这个少许麻烦了一些。原式化为 $f(l,r)=\min f(k+1,r)+a_k$。

按照最朴素的单调队列维护即可，不需要什么分类讨论。（如果单调队列不会写的，建议抛弃这道题去学习单调队列）。

```cpp
namespace ac {
	int f[7009][7009],q[7009];
	void main() {
		rep(r,2,n) {
			int p=r;
			int ll=1,rr=2; q[1]=r;
			per(l,r,1) {
				if(l==r) {f[l][r]=0;continue;}
				else if(r-l==1) {f[l][r]=a[l];continue;}
				while(p>l&&f[p][r]<f[l][p-1]) p--;			//Step1
				f[l][r]=f[l][p]+a[p];						//Step2
				while(ll<rr&&q[ll]>=p) ll++;					//Step3 (and the next 3 lines)	
				if(ll<rr) f[l][r]=min(f[l][r],f[q[ll]+1][r]+a[q[ll]]);
				while(ll<rr&&f[q[rr-1]+1][r]+a[q[rr-1]]>=f[l+1][r]+a[l]) rr--;
				q[rr++]=l;
			}
		}
		printf("%lld\n",f[1][n]);
	}
}
```

尽管代码不长，但做的真的累。

---

## 作者：云岁月书 (赞：23)

[题目链接](https://www.luogu.com.cn/problem/P6563)

这道题题解写的太简洁了，这个 [蒟蒻](https://www.luogu.com.cn/user/222127) 看的很费劲，于是他决定写一篇更详细一点的题解。

## 基础分析：

基础 DP 方程：

$$\large dp[l][r] = \min\limits_{l\leq k<r}(\max(dp[l][k],dp[k+1][r])+a[k])$$

这个式子还是很难理解的（也可能是我太菜了）。

首先是 $dp[l][r]$ 的定义：**确定电线长度在 $[l,r]$ 后最少需要多少钱才能准确确定电线长度**。

显然当区间 $l == r$ 时，$dp[l][r]$ 的值为 $0$ 。

此时，我们就可以**逆推**，从确定的元区间 $[l,l]$ 向上转移，从而推出 $dp[l][r]$ ，转移就是上述方程（状态设计好了，转移还是比较容易的）。

但朴素做法是 $O(n^3)$ 级别的，本题过不了。

## 优化：

看了一眼暴力的 DP 的式子，感觉有点单调队列优化的感觉，可以试一下：

但是这个方程 $\min\limits_{i<k<j}(\max(dp[l][k],dp[k+1][r])+a[k])$  很恶心，套了个 $\min\max$ ，不好直接搞。

### 先考虑 $l,r$ 已固定的情况。

仔细观察，在 $k$ 移动的过程中，$dp[l][k]$ 是**单调不减**的， $dp[k+1][r]$ 是**单调不增**的，这一点还是比较好想的。

然后转换一下即是：当 $dp[l][k] > dp[k+1][r]$ 时，后面 $max$ 的决策一定是选择 $dp[l][k]$ ，且在往后决策也不会变，反之选择$dp[k+1][r]$ 。

于是我们总算有一点眉目了，即对每一个区间 $[l,r]$ 都存在一个中转点 $x$ 满足 $k < x$ 时选择 $dp[l][k]$ ,反之选择 $dp[k+1][r]$ 。

### 接下来继续考虑 $l,r$ 移动的情况。

我们移动区间 $[l,r]$ 时，此时我们主要思考一下的是**中转点 $x$ **的位置的变化,设 $x_{l,r}$ 表示区间 $l,r$ 的中转点。

肯定的是它的位置是单调的，也即对于任意区间 $[l,r],[l+k_1,r+k_2],k_1,k_2\in\N^+$  都满足 $\Large x_{l+k_1,r+k_1} > x_{l,r}$。

列一下表就可以得到：

- $\large x_{l,r} \in [l,l+k_1]$ 这种情况无论如何都存在 $\large x_{l,r} \leq x_{l+k_1,r+k_1}$ 。

- $\large x_{l,r}\in[l+k_1,r+k_1]$ 
  - 若 $\large x_{l+k_1,r+k_1} \in (l+k_1,r]$，这种情况下，一定有 $\large x_{l+k_1,r+k_1} == x_{l,r}$ 。
  - 若$\large x_{l+k_1,r+k_1}\in(r,r+k_1]$，显然 $\large x_{l+k_1,r+k_1} > x_{l,r}$ 一定成立。  

~~我自己都不是很明白为什么要把那么显然的一个东西分类讨论,可能因为我是个蒟蒻。~~

综上，我们可以确定中转点是具有**单调性**。

### 进一步分析，当中转点确定时，$dp[l][r]$ 可能的取值。

很明显，它是需要**分类讨论**。

- $dp[l][k] > dp[k+1][r]\ (1)$
  - $dp[l][r] = \min\limits_{l \leq k < r}(dp[l][k]+a[k])$

这一个式子根据上面 $dp[l][k]$ 是单调不减的，所以最小的直接取 $dp[l][r] = dp[l][k]+a[k]$ 即可。

- $dp[l][k] \leq dp[k+1][r]\ (2)$
  - $dp[l][r] = \min\limits_{l\leq k < r}(dp[k+1][r]+a[k])$

这一个式子是满足单调性的，可以直接普通单调队列维护。

综上，我们成功将时间复杂度优化到了 $O(n^2)$，本题可以过。

### 代码实现：

下面贴的代码省略了前面漫长的手写 IO ，转移方面借鉴了 [**JohnVictor**](https://www.luogu.com.cn/user/254752) 大佬的提供的优化，将 $l,r$ 换了个位置。

~~~c++
# define N 7100
# define reg register

class ysys_Deque 
{
	private:
			int d_e_q_u_e[(N<<1) + 5],Rear_,Front_;
			
	public :
			ysys_Deque(){Rear_=N;Front_=N+1;}
			~ysys_Deque(){}
			
			inline bool Empty(){return Front_ > Rear_;}
			inline int Size(){return Front_ <= Rear_ ? Rear_-Front_+1 : 0;}
			inline void Reset(){Rear_=N;Front_=N+1;} 
			inline int Front(){return d_e_q_u_e[Front_];}
			inline int Rear(){return d_e_q_u_e[Rear_];}
			inline int Get_Back(){return d_e_q_u_e[Rear_--];}
			inline int Get_Front(){return d_e_q_u_e[Front_++];}
			inline void Pop_Back(){--Rear_;}
			inline void Pop_Front(){++Front_;}
			inline void Push_Front(const int Val){d_e_q_u_e[--Front_] = Val;}
			inline void Push_Back(const int Val){d_e_q_u_e[++Rear_] = Val;}
			
} q;//手写双端队列

using namespace ysys::MMS;
long long f[N+5][N+5],a[N + 5];
int n,T;
using namespace ysys::unsigned_IO_f;

int main()
{
	T = Read();
	
	while(T--)
	{
		n = Read();
		
		for(reg int i = 1; i <= n ; ++i) a[i] = ReadL();
		
		for(reg int r = 2;  r <= n ; ++r)
		{//如果枚举区间长度，，改为枚举右端点。
			q.Reset();q.Push_Back(r-1);
			
			f[r][r-1] = a[r-1];
			 
			for(reg int l = r-2,k = r; l ; --l)//倒序枚举便于对右区间选取。
			{
				while(f[k-1][l] > f[r][k] && l < k) --k;//寻找中转点。
				
				f[r][l] = f[k][l] + a[k];//取dp[l][k]的转移。
				
				while(q.Size() && k <= q.Front()) q.Pop_Front();//将小于了中转点 k 的dp[k+1][r] 出队。
				
				if(q.Size()) f[r][l] = Min(f[r][l],f[r][q.Front()+1] + a[q.Front()]);
				
				while(q.Size() && f[r][q.Rear()+1] + a[q.Rear()] >= f[r][l+1] + a[l]) q.Pop_Back();
				//新增加的可能成为右区间最优解的 k+1。
				q.Push_Back(l);
			}
		}
		
		printf("%lld\n",f[n][1]);
	}
	
	return 0;
}
~~~

### 总结

个人感觉这道题的单队优化还是很难想的，能独立想出来的，单队也可以说是学的差不多了（蒟蒻个人见解勿喷）。

---

## 作者：JohnVictor (赞：21)

首先有个 $n^3$ 的暴力。假设 $dp_{l,r}$ 为确定答案在区间 $[l,r]$ 后需要的最小代价，那么可以得到式子：

$$dp_{i,j}=\min_{i<k<j}\max\{dp_{i,k},dp_{k+1,j}\}+a_k$$

枚举区间长度，或者倒序枚举 $i$ 都可以在 $n^3$ 的时间复杂度完成。

考虑优化，爆推式子好像有点难，那么观察式子，里面有一个 $\max$ 和一个 $\min$，考虑先拆开里面的 $\max$，也就是对于每一个 $(i,j)$ 对子，找到一个最小的 $k=f(i,j)$ 满足 $dp_{i,k}>dp_{k+1,j}$。二分查找可以做到 $O(n^2\log n)$，但是认真观察可以发现 $f(i,j+1) \ge f(i,j)$，并且判断是否成立是 $O(1)$ 的，所以决策单调性优化到了 $O(n^2)$。

想到这里，接下来的部分就顺理成章了，分类讨论中转点 $k$ 和 $f(i,j)$ 的关系：

（1）$k < f(i,j)$，那么是一个形如 $dp_{k,j}+a_k$ 的式子的值，这个和 $i$ 无关，所以对于 $j$ 维护一个单调队列即可。这里可能浪费一倍空间，解决方法有两个，第一个是单调队列和 $dp$ 用一个数组，另外一个是先枚举 $j$，再倒序枚举 $i$。（这样空间还能用 `vector` 优化到 $\dfrac{1}{2}n^2$ 个数）

（2）$k \ge f(i,j)$，那么是形如 $dp_{i,k}+a_k$ 的东西，显然这个关于 $k$ 单调递增，直接输出 $k=f(i,j)$ 时的答案即可。

代码不长，即使手写单调队列优化常数都只有 `30` 行。关于常数方面，区间 `dp` 中由于倒序枚举的特殊性，所有 `dp[l][r]`  写成 `dp[r][l]` 能快 $3$ 倍，但是不优化也能过。

代码还是放下，主要是 @xiaoyaowudi 写的。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long ll;
#define rl register long long
#define N 7010
ll a[N],f[N][N],n,t;
struct my_deque{
	ll dat[N];int l,r;
	inline void clear(){l=r=0;}
	inline void push_back(rl a){dat[r++]=a;}
	inline void pop_back(){--r;}
	inline void pop_front(){++l;}
	inline bool empty(){return l==r;}
	inline int front(){return dat[l];}
	inline int back(){return dat[r-1];}
}qe;
int main(){
	scanf("%lld",&t);
	while(t--){
		scanf("%lld",&n);
		for(rl i=1;i<=n;++i)
			scanf("%lld",&a[i]);
		for(int j=2;j<=n;++j){
			qe.clear();
			qe.push_back(j-1);
			f[j][j-1]=a[j-1];
			for(int i=j-2,l=j;i;--i){
				while(f[l-1][i]>f[j][l] && l>i) --l;
				while(!qe.empty() && l<=qe.front()) qe.pop_front();
				f[j][i]=a[l]+f[l][i];
				if(!qe.empty()) f[j][i]=min(f[j][i],f[j][qe.front()+1]+a[qe.front()]);
				while(!qe.empty() && a[qe.back()]+f[j][qe.back()+1]>=a[i]+f[j][i+1]) qe.pop_back();
				qe.push_back(i);
			}
		}
		printf("%lld\n", f[n][1]);
	}
	return 0;
}
```

关于乱搞：

值得一提的是，如果令 $f(i,j)$ 为区间 $[i,j]$ 的决策点，这个在 $i$ 固定的时候并没有决策单调性。最简单的反例是 

$$n=7,a_i=i$$

并且，$dp$ 的转移式不是单峰的，三分也不能解决。不知道有没有带一个 $\log$ 的做法。（不容易直接优化到 $n^2$ 的）

---

## 作者：字如其人 (赞：8)

单调队列优化 dp。

先考虑没有优化的做法。

令 $f\left[l\right]\left[r\right]$ 表示知道 $l\leq x\leq r$ 后还需要花费最少 $f\left[l\right]\left[r\right]$ 才能猜出 $x$。

显然初始化 $f\left[l\right]\left[l\right]=0$，$f\left[l\right]\left[l+1\right]=a\left[l\right]$ ，答案为 $f\left[1\right]\left[n\right]$。

考虑询问 $\left(l,r\right)$ 中的 $k$ 来得到 $f\left[l\right]\left[r\right]$，那么应该用两边更坏的情况来更新，所以：

$f\left[l\right]\left[r\right]=min_{k=l+1}^{r}{max(f\left[l\right]\left[k\right],f\left[k+1\right]\left[r\right])+a[k]}$。

这样的式子可以想办法把 $max$ 拆掉，即分为两种情况讨论。

$f\left[l\right]\left[k\right]$ 更大时，$k$ 越小，$f\left[l\right]\left[k\right]$ 越小。所以枚举区间时，先枚举 $r$，在倒序枚举 $l$，就可以保证 $r$ 一定时，$k$ 单调递减，一个 while 就可以解决。

$f\left[k+1\right]\left[r\right]$ 更大时，$k$ 一定在上一步求出的 $k_0$ 左边。这时 
$f\left[l\right]\left[r\right]=min_{k=l+1}^{r} f\left[k+1\right]\left[r\right]+a[k]$。  

$r$ 一定时，只与 $k$ 有关，所以单调队列一下就好了。

code:
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
	int s=0,w=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')s=(s<<1)+(s<<3)+ch-'0',ch=getchar();
	return s*w;
}
const int Maxn=7105,Inf=1e18;
int n,f[Maxn][Maxn],a[Maxn],q[Maxn];
signed main(){
	int T=read();
	while(T--){
		n=read();
		for(int i=1;i<=n;i++)a[i]=read();
		for(int i=1;i<=n;i++)f[i][i]=0;
		for(int r=2;r<=n;r++){
			int head=1,tail=1,p;q[1]=p=r;
			for(int l=r-1;l>=1;l--){
				if(r-l==1){f[l][r]=a[l];continue;}
				while(p>l&&f[l][p-1]>f[p][r])p--;
				f[l][r]=f[l][p]+a[p];
				while(head<=tail&&q[head]>=p)head++;
				if(head<=tail)f[l][r]=min(f[l][r],f[q[head]+1][r]+a[q[head]]);
				while(head<=tail&&f[l+1][r]+a[l]<=f[q[tail]+1][r]+a[q[tail]])tail--;
				q[++tail]=l;
			}
		}
		printf("%lld\n",f[1][n]);
	}
	return 0;
}
```


---

## 作者：Piwry (赞：8)

可能是既视感太强，我做这道时总是被二分查找的思想干扰X

## 解析

首先要想到一个暴力的区间 dp：

设 $f(l, r)$ 表示确定目标在 $[l, r]$ 范围内，最终确定目标最坏情况下所需的消耗。于是就有转移方程：$f(l, r)=\min\limits_{l\leq k\leq r}\{\max(f(l, k), f(k+1, r))+a[k]\}$（可能有越界X，越界状态直接无视就行了）

接下来我们要设法将这个方程优化成 $O(n^2)$ 的

&nbsp;

首先可以从定义得知 $f$ 是满足区间包含单调性的。即有：

$\forall l\leq l'\leq r, l\leq r'\leq r, l'\leq r'$，有 $f(l, r)\geq f(l', r')$

所以对于一对 $l, r$，一定有一个 “临界点” $m_{l, r}$。在这临界点**及**之前，$\max$ 均取 $f(k+1, r)$；在这临界点之后，$\max$ 均取 $f(l, k)$

并且若固定 $r$，随着 $l$ 的减小，$m_{l, r}$ 单调不增；若固定 $l$，随着 $r$ 的增大，$m_{l, r}$ 单调不减

于是我们就可以先枚举一个端点，再枚举一个端点，并在第二层枚举内设一个指针保存临界点位置。可以知道该指针的移动是单调的，因此这部分总的复杂度还是两层枚举，$O(n^2)$

&nbsp;

现在我们考虑确定了 $l, r$ 及临界点 $m_{l, r}$ 后，如何快速计算出 dp 的值

假设我们先枚举 $l$，再枚举 $r$，显然可以在每次的第二层循环用单调队列维护转移方程中的 $\min\limits_{m_{l, r} < k <r}\{f(l, k)+a[k]\}$，但我们很难维护 $\min\limits_{l\leq k\leq m_{l, r}}\{f(k+1, r)+a[k]\}$，因为第二层循环枚举的就是 $r$

注意到题目中的 $a_1\leq a_2\leq\cdots\leq a_n$，再结合区间包含单调性，可以发现 $f(l, k)+a[k]$ 是随 $k$ 单调不减的。因此只需先枚举 $r$，再枚举 $l$，同样用单调队列维护 $\min\limits_{l\leq k\leq m_{l, r}}\{f(k+1, r)+a[k]\}$，至于 $\min\limits_{m_{l, r} < k < r}\{f(l, k)+a[k]\}$ 直接取 $k=m_{l, r}+1$ 即可

（单调队列部分具体可见代码，相关变量的定义都是一样的）

## 若不满足 $a_1\leq a_2\leq\cdots\leq a_n$

其实即使题目不保证 $a_1\leq a_2\leq\cdots\leq a_n$，也仍然是可做的

我们先**倒序地**枚举 $l$ 再（正序）枚举 $r$，并同样设临界点 $m_{l, r}$，和刚才一样地在每次的第二层循环用单调队列维护转移方程中的 $\min\limits_{m_{l, r} < k < r}\{f(l, k)+a[k]\}$

我们再对每个端点维护一个维护最小值的单调队列，设当前刚刚枚举到 $l, r$，对于端点 $r$ 的单调队列中**已统计**（队列里不一定要有这些元素）的元素就为 $\{f(k+1, r))+a[k]:l\leq k < r\}$

若当前枚举到的 $l, r$ 的临界点是 $m_{l, r}$，就用 $m_{l, r}$ 维护单调队列队头，将（在原地址）下标超过临界点的元素全部弹出。此时 $r$ 的单调队列的队头就是 $\min\limits_{l\leq k\leq m_{l, r}}\{f(k+1, r)+a[k]\}$ 的值

最后，再将 $f(l, r)+a[l-1]$ 从 $r$ 的单调队列的队尾插入即可（注意此时要求 $l\geq 1$）

注意到这里的 $m_{l, r}$ 随 $l$ 的减小单调不增，因此我们对单调队列队头的维护总是合法的

我们对每个 $r$ 维护的单调队列的复杂度消耗都是 $O(n)$，总的复杂度也就是 $O(n^2)$

（也可以先**正序地**枚举 $r$ 再（倒序）枚举 $l$，做法也是差不多的）

但这种方法在过程中需要维护 $O(n)$ 个单调队列，可能空间有点紧。~~我还没试过，不知道会不会爆qaq~~。试过了，的确会炸，而且大数组寻址、维护多一倍的单调队列带来的常数也不小（

## CODE

满足 $a_1\leq a_2\leq\cdots\leq a_n$ 的做法的代码

```cpp
#include <cstdio>
#include <iostream>
#define ll long long
using std::pair;
using std::min;
typedef pair<ll, int> pad;

const int MAXN =7110;

/*------------------------------Monotone queue------------------------------*/

pad q[MAXN];
int head, tail;

inline ll front(){
	if(head < tail)
		return q[head].first;
	else
		return 0x3f3f3f3f3f3f3f3f;
}

void modifyfront(int nowtime){
	while(head < tail && q[head].second >= nowtime)
		++head;
}

void push(pad newelement){
	while(head < tail && q[tail-1].first >= newelement.first)
		--tail;
	q[tail++] =newelement;
}

/*------------------------------Main------------------------------*/

inline int read(){
	int x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return x;
}

ll dp[MAXN][MAXN];
int a[MAXN];

int main(){
	for(int t =0, T =read(); t < T; ++t){
		int n =read();
		for(int i =0; i < n; ++i)
			a[i] =read();
		for(int r =1; r < n; ++r){
			head =tail =0;
			/*mid: 转移方程分界点*/
			for(int l =r-1, mid =r-1; l >= 0; --l){
				while(mid >= l && dp[l][mid] >= dp[mid+1][r])
					--mid;
				modifyfront(mid+1);
				dp[l][r] =min(dp[l][mid+1]+a[mid+1], front());
				if(l > 0)/*避免最后越界*/
					push(pad(dp[l][r]+a[l-1], l-1));
			}
		}
		printf("%lld\n", dp[0][n-1]);
	}
}
```

&nbsp;

不满足 $a_1\leq a_2\leq\cdots\leq a_n$ 的做法的代码

```cpp
/*不要求 ai 单调不减的版本*/
/*注意会炸空间*/
#include <cstdio>
#include <iostream>
#define ll long long
using std::pair;
using std::min;
typedef pair<ll, int> pad;

const int MAXN =7101;

/*------------------------------Monotone queue------------------------------*/

pad q1[MAXN], q2[MAXN][MAXN];
int head1, tail1, head2[MAXN], tail2[MAXN];

inline ll front(const int &head, const int &tail, const pad *q){
	if(head < tail)
		return q[head].first;
	else
		return 0x3f3f3f3f3f3f3f3f;
}

void modifyfront1(const int &nowtime){
	while(head1 < tail1 && q1[head1].second <= nowtime)
		++head1;
}

void modifyfront2(const int &nowtime, int &head, const int &tail, const pad *q){
	while(head < tail && q[head].second >= nowtime)
		++head;
}

void push(const pad &newelement, const int &head, int &tail, pad *q){
	while(head < tail && q[tail-1].first >= newelement.first)
		--tail;
	q[tail++] =newelement;
}

/*------------------------------Main------------------------------*/

inline int read(){
	int x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return x;
}

ll dp[MAXN][MAXN];
int a[MAXN];

int main(){
	for(int t =0, T =read(); t < T; ++t){
		int n =read();
		for(int i =0; i < n; ++i)
			a[i] =read(), head2[i] =tail2[i] =0;
		for(int l =n-2; l >= 0; --l){
			head1 =tail1 =0;
			/*由于实现上跳过了 l == r 的部分，所以这里要对单调队列初始化*/
			/*初始化: [l+1, l+1] ( 这其实是在替左端点为 l+1 ( 上一次的 l ) 时的 l == r 的时刻初始化 )*/
			push(pad(0+a[l], l), head2[l+1], tail2[l+1], q2[l+1]);
			/*初始化: [l, l]*/
			push(pad(0+a[l], l), head1, tail1, q1);
			/*mid: 转移方程分界点*/
			/*这里的 mid 和题解略有不同，这里 [mid, r-1] 均取 dp[l][k]，[l, mid-1] 均取 dp[k+1][r]*/
			for(int r =l+1, mid =l; r < n; ++r){
				while(mid < r && dp[l][mid] <= dp[mid+1][r])
					++mid;
				modifyfront1(mid-1);
				modifyfront2(mid, head2[r], tail2[r], q2[r]);
				dp[l][r] =min(front(head1, tail1, q1), front(head2[r], tail2[r], q2[r]));
				push(pad(dp[l][r]+a[r], r), head1, tail1, q1);
				if(l > 0)/*避免最后越界*/
					push(pad(dp[l][r]+a[l-1], l-1), head2[r], tail2[r], q2[r]);
			}
		}
		printf("%lld\n", dp[0][n-1]);
	}
}
```

---

## 作者：RedreamMer (赞：4)

[$\Large\texttt{P6563}$](https://www.luogu.com.cn/problem/P6563)

[$\texttt{In my cnblogs}$](https://www.cnblogs.com/RedreamMer/p/14369444.html)

算法：单调队列优化DP



## 题意

不做赘述。

但是可以想象成一个双方玩博弈的过程， A 取当前区间的一个数（位置为 $i$ $(l \le i < r)$）花 $a_i$ ，将这个区间分成 $[l,i]$ 和 $[i+1,r]$ ，B根据计算选两个区间中一个区间使 A 最后花更多的钱，而 A 要花更少的钱。

注意 $a_i$ 非严格单调递增。



## 思路

+ 20pts

可以很容易的想到一个 $O(N^3)$ 的区间DP：
$$
f[i][j]=\min_{k=l}^{k<r}(\max(f[i][k],f[k+1][j])+a_k)
$$
$\min$ 代表 A 主观选最小的， $\max$ 为 B 主观选两个区间中更大价值的区间。

其中 $f[i][i+1]=a_i$ ，$f[i][i]=0$ 。

+ 100pts

考虑优化，首先总有 $f[i][j]\le f[i][j+1]$ （显然，但不好证QwQ） $a_i$ 是非严格单调递增的，那么在这个式子送，如果能枚举一个下标，将 $f[i][j]$ 变成一个在 $i$ **或** $j$ 意义下的一维数组，既然是单调的是否可以考虑**单调队列**？

但是这个 $\max$ 操作有点限制我们。

但因为f有单调性，我们知道随着 $k$ 变大 $f[i][k]$ 变大， $f[k+1][j]$ 变小，也就是说我们可以找到一个点 $p$ 对于 $(i,j)$ 来说 $f[i][k]$ 恰好大于 $f[k+1][j]$ 的 $k$ 点，而 $p$ 右边 $\max$ 的值选后者， $p$ 左边选前者。

联系第一段话，我们现在有两种选择：

1. 固定（优先枚举） $i$ ，再枚举 $j$ 
2. 固定（优先枚举） $j$ ，再枚举 $i$ 

在枚举第二关键字的过程中 $p$ 点应是可从上一个 $p$ 点单向移动得到的，具过程体可以手玩得到。

后将 $[i,j]$ 分为 $[p,j]$ 和 $[i,p-1]$ 分别考虑每个点的贡献：

1. $[p,j]$ 贡献为 $\min\{f[i][k]+a_k\}$ 因为随着 $k$ 的增加 $a_k$ 和 $f[i][k]$ 单调递增，显然的贡献为 $f[i][p]+a_p$ 。
2. $[1,p-1]$ 贡献为 $\min\{f[k][j]+a_k\}$ ，然而这里就有**~~大~~问题**了， $a_k$ 和 $f[k][j]$ 的单调方向相反，难搞。

对于第二类情况，~~（呼应开头）~~因为变量只有两个，考虑固定其中一个，再枚举另一个，用单调队列维护。

所以只能固定 $j$ ~~（我因为这个搞不懂弄了半天）~~，枚举 $i$ 。

至此问题基本解决。



## 反思

重点：

+ 要能想到 $f[i][j]\le f[i][j+1]$  ，别老是对一个解释不清但显然成立的东西要证明，有些东西就是难以解释。
+ 必须将 $j$ 作为第一关键字，这是罕见的一道题吧，挺神的。
+ 要顺序从 $1$ 开始枚举 $j$ ，倒序从 $j$ 开始枚举 $i$ （其他方法都不行）。

最好自己手推一下，可以参考下代码。



## 代码

主体挺短的，但是写起来真的很难受。

```cpp
int t, a, s[N + 10], f[N + 10][N + 10], mid[N + 10], l, r, qu[N + 10]; //(mid就是文中的p)

signed main()
{
    // freopen("in1.in", "r", stdin);
    t = read();
    while (t--)
    {
        a = read();
        for (int i = 0; i <= a + 1; i++)
            for (int j = 0; j <= a + 1; j++)
                f[i][j] = 1e18;
        for (int i = 1; i <= a; i++)
            s[i] = read();
        for (int i = 1; i <= a; i++)
            f[i][i] = 0, f[i][i + 1] = s[i];
        for (int j = 3; j <= a; j++)
        {
            mid[j - 1] = j - 1;
            l = 1;
            r = 0;
            for (int i = j - 2; i >= 1; i--)
            {
                mid[i] = mid[i + 1];
                while (mid[i] > i && f[i][mid[i] - 1] > f[mid[i]][j])
                    mid[i]--;
                while (l <= r && qu[l] >= mid[i])
                    l++;
                f[i][j] = min(f[i][j], f[i][mid[i]] + s[mid[i]]);
                if (l <= r)
                    f[i][j] = min(f[i][j], f[qu[l] + 1][j] + s[qu[l]]);
                while (l <= r && f[i + 1][j] + s[i] < f[qu[r] + 1][j] + s[qu[r]])
                    r--;
                qu[++r] = i;
            }
        }
        printf("%lld\n", f[1][a]);
    }
    return 0;
}
```



---

## 作者：神眷之樱花 (赞：1)

# 题面
[一直在你身旁](https://www.luogu.com.cn/problem/P6563)
# 题解
设 $dp[l][r]$ 表示在知道答案在 $l$ ~ $r$ 范围内之后还需要花费多少才能得出答案。

所以显然的有：

$$dp[l][l] = 0, dp[l][l + 1] = a[l], ans = dp[1][n]$$

对于第二个柿子要想明白，因为在我们转移时也要用到这个思路。

就是当我们知道答案在 $l$ ~ $l + 1$ 这个范围内之后，根据题意，我们可以花费 $a[l]$ 的代价知道答案是否大于 $l$，如果大于，那么答案为 $l + 1$, 反之答案为 $l$。
所以花费应该为 $a[l]$。

想清楚这些后，我们就可以很容易的得到一个状态转移方程:

$$dp[l][r] = \min({\max_{k = l} ^ {r} {(dp[l][k], dp[k + 1][r])} + a[k]})$$

当我们花费 $a[k]$ 之后，我们可以知道答案是在 $k + 1$ ~ $r$ 这个区间，还是在 $l$ ~ $k$ 这个区间，而在这两个区间中取最大值是为了保证一定能得到答案，考虑的是最坏情况。而在外层取最小值，是在保证了一定能得到答案的情况下，找到最优解。

但这个是 $n ^ 3$ 显然过不了。

所以我们考虑把中间的 $\max_{k = l} ^ {r}(dp[l][k], dp[k + 1][r])$ 拆开。可以发现，因为长度越长，花费越大，随着 $k$ 的增加，$dp[l][k]$ 肯定是单调不降的，而 $dp[k + 1][r]$ 肯定是单调不升的，所以一定有一个中间点，满足左半边的 $k$，最大值是 $dp[k + 1][r]$，右半边的 $k$ 最大值是 $dp[l][k]$，对于这个位置我们直接一个 while 就能找到。

然后也是因为长度越长，花费越大，所以当最大值是 $dp[l][k]$ 时，肯定是 $k$ 越小，$dp[l][k]$ 越小， $a[k]$ 越小，所以 $dp[l][k] + a[k]$ 越小，所以此时的总的最小值直接取我们找到的那个中间点的位置就好了。

而当最大值是 $dp[k + 1][r]$ 时，我们直接对这一部分维护一个单调队列就好了。

所以就把它降到了 $n ^ 2$。

注意 $l$ 要倒序枚举才能保证当前的 $l$ ~ $r$ 的区间内的 $dp$ 值都是已知的。
# 代码
```cpp
#include<cstdio>
#include<iostream>

using namespace std;

int n, t, a[7505], q[10000]; long long dp[7505][7505];

int main() {
	scanf("%d", &t);
	while(t--) {
		scanf("%d", &n);
		for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
		for(int i = 1; i <= n; i++)
			for(int j = 1; j <= n; j++)
				dp[i][j] = 0;
		for(int r = 2, head, tail, k; r <= n; r++) {
			head = tail = 1; q[tail] = k = r;
			for(int l = r - 1; l; l--) {
				if(r - l == 1) {
					dp[l][r] = a[l];
					continue;
				}
				while(k > l && dp[l][k - 1] > dp[k][r]) k--;
				dp[l][r] = dp[l][k] + a[k];
				while(head <= tail && q[head] >= k) head++;
				if(head <= tail) dp[l][r] = min(dp[l][r], dp[q[head] + 1][r] + a[q[head]]);
				while(head <= tail && dp[q[tail] + 1][r] + a[q[tail]] >= dp[l + 1][r] + a[l]) tail--;
				q[++tail] = l; 
			}
		}	
		printf("%lld\n", dp[1][n]);
	}
	return 0;
}
```


---

## 作者：BzhH (赞：1)

[题解P6563 [SBCOI2020] 一直在你身旁](https://www.cnblogs.com/A2484337545/p/14652249.html)

一道非常值得做的单调队列优化DP，刚开始看到这道题目一直想着二分，愣是没有看出是个DP，后来仔细想了下，可以轻易的写出 $O(n^3)$ 的暴力.

定义 $f_{i,j}$ 表示确定区间 $[i,j]$ 内的数字所需的最小花费,得出转移方程

$$f_{i,j}=\min(\max_{l\le k < r}(f_{l,k},f_{k+1,r})+a_k)$$

显然是个区间DP

~~通过标签~~观察式子有点类似 $f_k+a_k$ 的形式,似乎可以优化,首先不好直接对这个式子下手,可以分类讨论一下,把其中的 $\max$ 去掉

仔细思考一下,可以发现 $f_{i,j}\le f_{i,j+1}, f_{i,j} \ge f_{i+1,j}$

那么也就是说,我们在分类讨论的时候只需要找到一个最小的 $x$ 使得 $f_{l,x}>f_{x+1,r}$ 就行了

对于 $f_{l,k}>f_{k+1,r}$ 的情况

$f_{l,r}=\min\limits_{l\le k < r} f_{l,k}+a_k$,其中 $f_{l,k}+a_k$ 是单调不减的,所以答案直接为 $f_{l,x}+a_x$

对于 $f_{l,k}<f_{k+1,r}$ 的情况就稍微比较麻烦了

$f_{l,r}=\min\limits_{l\le k < r}(f_{k+1,r}+a_k)$,每次用单调队列维护一个最小值就行了.

所以时间复杂度就可以优化成 $O(n^2)$

代码
```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N = 7105;
typedef long long ll;

ll f[N][N];
int a[N], q[N];

int main()
{
    int T;
    scanf("%d", &T);
    while (T--)
    {
        int n;
        scanf("%d", &n);
        for (int i = 1; i <= n; i++)
            scanf("%d", &a[i]);
        for (int i = 1; i <= n; i++)
            f[i][i] = 0, f[i][i + 1] = a[i];
        for (int r = 2; r <= n; r++)
        {
            int front = 0, tail = -1, p = r - 1;
			q[0] = r - 1;
			for (int l = r - 2; l >= 1; l--)
            {
				while (p >= l && f[l][p] > f[p + 1][r])//找到最小的x
                    p--;
                f[l][r] = f[l][p + 1] + a[p + 1];//这里主要需要加一
				if (front <= tail && q[front] > p)//第二种情况
                    front++;
                if (front <= tail)  
                    f[l][r] = min(f[l][r], f[q[front] + 1][r] + a[q[front]]);
                while (front <= tail && f[q[tail] + 1][r] + a[q[tail]] >= f[l + 1][r] + a[l])
                    tail--;
                q[++tail] = l;
			}
        }
        printf("%lld\n", f[1][n]);
    }
    return 0;
}
```

---

## 作者：devout (赞：1)

显然有一个 $O(n^3)$ 的暴力dp，设 $f_{i,j}$ 表示确定一个值在区间 $[l,r]$ 上的最小花费，那么显然有转移

$$f_{i,j}=\min\{\max(f_{i,k},f_{k+1,j})+a_k\}$$

根据区间dp的做法就可以解决了。

考虑优化，我们可以注意到，对于 $i$ 固定时，$f_{i,j}$ 是单调不减的，$j$ 固定时，$f_{i,j}$ 是单调不增的，所以对于一个区间 $[i,j]$，我们一定可以找到一个位置 $x$，是的对于 $\forall k\in[i,x],f_{i,k}<f_{k+1,j},\forall k\in(x,j],f_{i,k}>f_{k+1,j}$

并且我们观察到，当 $j$ 固定的时候，显然决策点 $x$ 随着 $i$ 的减小而单调不增。

我们考虑先枚举 $j$，然后倒序枚举 $i$

所以可以考虑把转移分成两部分，对于在 $x$ 左边的部分，即用 $\min\{f_{k+1,j}+a_k\}$ 的部分转移的，我们可以用单调队列维护，对于在 $x$ 右边的部分，$f_{i,k}$单调不减，$a_k$ 单调不减，所以最优决策点一定在 $x+1$ 的位置上

这样一来，总复杂度就可以做到 $O(n^2)$ 了。

代码比较短，但是写起来真的是费劲：

```cpp
#include <bits/stdc++.h>
using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

typedef long long ll;

const int N=7100;

template<typename T> void read(T &x){
   x=0;int f=1;
   char c=getchar();
   for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
   for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

int t,n;
int a[N];
ll f[N][N];
int q[N],head,tail;

int main()
{
	memset(f,0x3f,sizeof(f));
	read(t);
	while(t--){
		read(n);
		Rep(i,1,n)read(a[i]);
		Rep(i,1,n)f[i][i]=0;
		for(int j=1;j<=n;j++){
			head=1,tail=0;
			int k=j-1;
			for(int i=j-1;i;i--){
				while(k>=i&&f[i][k]>f[k+1][j])k--;
				while(head<=tail&&q[head]>k)head++;
				while(head<=tail&&f[q[tail]+1][j]+a[q[tail]]>f[i+1][j]+a[i])tail--;
				q[++tail]=i;
				f[i][j]=min(f[i][j],f[i][k+1]+a[k+1]);
				f[i][j]=min(f[i][j],f[q[head]+1][j]+a[q[head]]);
			}
		}
		printf("%lld\n",f[1][n]);
		Rep(i,1,n)Rep(j,1,n)f[i][j]=1e18;
	}
	return 0;
}
```


---

## 作者：Dzhao (赞：0)

令 $dp_{i, j}$ 表示答案在区间内最少要购买的电线总长度，可以很轻松的推出 DP 式子：
$$dp_{i, j}=\min_{i\le k<j} \{\max(dp_{i,k}, dp_{k+1,j})+a_k\}$$

这样的递推是 $\mathcal{O}(n^3)$，我们考虑将其优化。

我们令 $f(i, j)$ 表示第一个满足 $dp_{i, k}\ge dp_{k+1, j}$ 的决策点 $k$。由于 $dp_{i,k}$ 随着 $k$ 的增大而增大，$dp_{k+1, j}$ 随着 $k$ 的增大而减小，所以当 $k\ge f(i, j)$ 时，一定满足 $dp_{i, k}\ge dp_{k+1, j}$。

于是我们可以将转移方程转化为 
$$dp_{i, j}=\min(\max_{i\le k < f(i, j)}\{dp_{k+1, j}+a_k\}, \max_{f(i, j)\le k < j}\{dp_{i, k}+a_k\})$$

由于 $dp_{i, k}$ 随 $k$ 单调递增，$a_k$ 随 $k$ 单调递增，所以又可以将转移方程转化为：
$$dp_{i, j}=\min(\max_{i\le k < f(i, j)}\{dp_{k+1, j}+a_k\}, dp_{i, f(i, j)}+a_{f(i, j)})$$

观察 $\min$ 中左边的那个式子，我们发现对于每个 $(i, j)$ 他的右端点 $j$ 都是固定的，而 $f(i, j)$ 又是随着 $i$ 的减小而减小，对于 $\min$ 中右边的 $\max$，我们可以用一个单调队列维护，将队头下标大于等于 $f(i, j)$ 的弹出，将队尾不比当前 $dp_{i, j}+a_{j-1}$ 有的弹出，每次更新 $dp_{i, j}$ 直接取队头和 $dp_{i, f(i, j)}+a_{f(i, j)}$ 比较就好了。

而 $f(i, j)$ 的求法，由于 $f(i, j)\le f(i+1, j)$，所以每次只需要用一个指针在序列上移动比较就好了，总复杂度为 $O(n^2)$。

$\mathcal{View\ Code}$

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 7105;
int T, n, a[N], h, r, Q[N];
ll dp[N][N];

int main() {
	scanf("%d", &T);
	while(T--) {
		h = 1, r = 0; 
		scanf("%d", &n);
		for(int i = 1; i <= n; i++) 
			scanf("%d", &a[i]);
		for(int j = 1; j <= n; j++) {
			int pos = j;
			h = 1; Q[r = 1] = j;
			for(int i = j - 1; i >= 1; i--) {
				while(pos - 1 >= i && dp[i][pos - 1] >= dp[pos][j]) pos--;
				while(h <= r && Q[h] >= pos) h++;
				dp[i][j] = dp[i][pos] + a[pos];
				if(h <= r) dp[i][j] = min(dp[i][j], dp[Q[h] + 1][j] + a[Q[h]]);
				while(h <= r && dp[Q[r] + 1][j] + a[Q[r]] >= dp[i][j] + a[i - 1]) r--;
				Q[++r] = i - 1; 
			}
		} 
		printf("%lld\n", dp[1][n]);
	}
	return 0;
}
```

---


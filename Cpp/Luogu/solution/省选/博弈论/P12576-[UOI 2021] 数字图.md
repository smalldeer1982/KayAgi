# [UOI 2021] 数字图

## 题目描述

瓦西里和彼得里克发现了一个数字图——这是一个连通的有向图，每个顶点上都标有一个数字。

两人急需一个数字，于是决定在图上游玩一个游戏。他们将棋子放在编号为 1 的顶点上。每一回合可以选择以下两种操作之一：
1. 结束游戏并获得当前顶点上的数字；
2. 沿着有向边将棋子移动到相邻顶点。

如果游戏进行到 $10^{100}$ 回合仍未结束，则自动终止并获得当前顶点上的数字。

瓦西里先手，他希望最大化最终获得的数字；而彼得里克则希望最小化这个数字。假设双方都采取最优策略，求游戏结束时他们将获得的数字。

## 说明/提示

第一个样例的图示如图 1 所示，顶点标注格式为"顶点编号（数字）"：

![](https://cdn.luogu.com.cn/upload/image_hosting/ssfvk5ca.png)
1. 瓦西里先手，可以选择立即结束游戏或移动到顶点 2。最优选择是移动。
2. 彼得里克回合，最优选择是移动到顶点 3。
3. 最后如果瓦西里移动到顶点 1，彼得里克会结束游戏获得数字 1，因此瓦西里会选择直接结束游戏获得数字 4。

第二个样例的图示如图 2 所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/9crldhqu.png)

双方将交替移动 $10^{100}$ 步，最终棋子停留在顶点 1。

### 评分标准

1. （$6$ 分）给定的图是一条所有边同向的直线；
2. （$8$ 分）给定的图是一棵以顶点 1 为根的树，所有边方向从根向下；
3. （$14$ 分）给定的图是一个环；
4. （$26$ 分）$1 \leq a_i \leq 2$；
5. （$46$ 分）无额外限制。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
4 4
1 10 4 5
1 2
2 3
2 4
3 1```

### 输出

```
4```

## 样例 #2

### 输入

```
2 2
1 2
1 2
2 1```

### 输出

```
1```

# 题解

## 作者：R_shuffle (赞：2)

首先还是照例，感谢队长[Purslane](https://www.luogu.com.cn/user/120947)的指导与推荐。

---------

实际上，由于并不确定后续状态，所以直接做是不好做的，不妨考虑特殊性质。

可以发现，在 $1\leq a_i\leq 2$ 的特殊性质中，不妨考虑怎么求。假设最开始的 $1$ 点是 $1$，那么显然是比较劣的，考虑在 $1$ 可达的点有没有 $2$，如果有就走到 $2$，显然这样是不劣的。没有的话就随便了，无论走还是不走，后手都会直接停止游戏，取 $1$；但是如果最开始的 $1$ 点是 $2$，那么直接停止游戏即可。轮到后手操作的时候同理。那么就会了只有两个数的方案。

不妨考虑把多个数的情况转成两个数的情况。考虑一个经典的二分的用法，通过二分把序列分成大于某个数和小于某个数的两部分，然后考虑。本题中也可以这么考虑，然后就转成了两个数的情况，直接做就行了。

时间复杂度为 $O(n\log(\max a_i))$。

---

## 作者：Purslane (赞：2)

# Solution

主播从开这道题到 AC 用了整整一个小时。文末会分析我是如何被卡住。

-------

看到题，哇是我不擅长的博弈。那看一眼部分分。

前两个 Sub：图是一个 DAG，所以可以 DP。

Sub 3 可能不是很好做，看一眼 Sub 4。

注意到，答案肯定是 $1$ 或者 $2$。显然如果 $a_1 = 2$ 那么返回 $2$。

否则，先手一定会将棋子移动到另一个 $2$ 上，除非不能操作；后手会接着将棋子移动到另一个 $1$ 上，除非不能操作。

因此棋子只会在 $a_x \neq a_y$ 的边上移动。建立出这样的图。

我们可以将博弈改为：在一个有向图上有一个棋子。每个人可以把棋子沿着有向边移动一步。先手获胜，当且仅当后手某一步不能移动。其他情况下都是后手获胜。问最后谁胜。

如果所有点都有出度，那么显然后手获胜，因为先手无论如何都不能是后手卡死。

否则，找到一个出度为 $0$ 的点。在这个点上，先手必败。而找到所有能到达它的点，它们都是先手必胜的（因为能转移到先手必败态）。

显然我们不会向先手必败态转移，所以我们可以把这一轮确定胜负状态的点全部删掉。然后继续重复找 $0$ 出度点的过程。

使用类似拓扑排序的手段维护，即可做到 $O(n+m)$。

回到原题，发现我们很容易判断答案是否 $\ge$ 某个给定的值。

主播计数题做魔怔了，想用 $\sum_{i \ge 1} [ans \ge i]$ 来计算答案。想了一万年都不知道怎么维护。

后来发现直接二分答案即可，复杂度 $O((n+m) \log V)$，足以通过本题。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=250000+10,MAXM=500000+10;
int n,m,b[MAXN],a[MAXN],deg[MAXN],del[MAXN],sg[MAXN],u[MAXM],v[MAXM];
vector<int> G[MAXN],g[MAXN];
int check(int lim) {
	ffor(i,1,n) a[i]=(b[i]>=lim)+1,G[i].clear(),g[i].clear();
	ffor(i,1,m) {
		int x=u[i],y=v[i];
		if(a[x]!=a[y]) G[x].push_back(y),g[y].push_back(x);	
	}
	if(a[1]==2) return 1;
	memset(sg,-1,sizeof(sg));
	queue<int> q;
	ffor(i,1,n) deg[i]=G[i].size();
	ffor(i,1,n) if(G[i].size()==0) q.push(i);
	while(!q.empty()) {
		int u=q.front();
		q.pop();
		sg[u]=0;
		for(auto v:g[u]) if(sg[v]==-1) {
			sg[v]=1;
			for(auto w:g[v]) {
				--deg[w];
				if(!deg[w]&&sg[w]==-1) {
					sg[w]=0,q.push(w);
				}
			}
		}
	}
	if(sg[1]==1) return 1;
	return 0;
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	ffor(i,1,n) cin>>b[i];
	ffor(i,1,m) cin>>u[i]>>v[i];
	int ans=0,l=0,r=1000000000;
	while(l<=r) {
		int mid=(l+r>>1);
		if(check(mid)) ans=mid,l=mid+1;
		else r=mid-1;	
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：_Ch1F4N_ (赞：1)

如果忽视步数限制，局面并不多，设计 $dp_{u,0/1}$ 表示位于点 $u$ 时谁先手最后结果如何，转移虽然有环，但是仍然可以倒过来转移，类似过河卒一题，指向某一个失败状态的是胜利状态，指向的状态全部是胜利状态的状态是失败状态，最后仍然处于队列中的点会无穷无尽地操作不会结束。

考虑步数限制怎么处理，注意到 $1 \leq a_i \leq 2$ 的部分分，暗示我们可以二分一个答案 $mid$，将 $a_i \geq mid$ 的 $a_i \gets 1$ 其余 $a_i \gets 0$，看答案是否会为 $1$ 来 check，正确性是显然的，因为在最优策略下进行这个只有 $0,1$ 的问题也是可以达成最优目标的。

不妨认为取到 $0,1$ 对应了双方的失败与胜利，注意到由于可以立即结束游戏，所以跑第一段的做法后，队列中剩余的所有点都会满足如果在这个局面因为步数用完就会导致失败，所以如果初始状态处于队列中，双方就必须一直在队列中的点移动，而由于 $10^{100}$ 是 $2$ 的倍数，所以结局一定是先手失败，至此我们就可以对一个 $mid$ 完成 check，这个题就在 $O((n+m) \log V)$ 的复杂度内解决。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 6e5+114;
int dp[maxn][2];//1-max 0-min 1-win 0-lose
vector<int> rE[maxn];
int vis[maxn][2];
int d[maxn][2],n,m;
int a[maxn];
bool check(int x){//>=x ->1:<x ->0
	for(int i=1;i<=n;i++) dp[i][0]=dp[i][1]=vis[i][0]=vis[i][1]=d[i][0]=d[i][1]=0;
	for(int u=1;u<=n;u++){
		for(int v:rE[u]) d[v][0]++,d[v][1]++;
	}
	queue< pair<int,int> > q;
	for(int u=1;u<=n;u++){
		if(a[u]>=x) dp[u][1]=1,q.push(make_pair(u,1)),vis[u][1]=1;
		else if(d[u][1]==0){
			dp[u][1]=0,q.push(make_pair(u,1)),vis[u][1]=1;
		}
		if(a[u]<x) dp[u][0]=1,q.push(make_pair(u,0)),vis[u][0]=1;
		else if(d[u][0]==0){
			dp[u][0]=0,q.push(make_pair(u,0)),vis[u][0]=1;
		}
	}
	while(q.size()>0){
		int u=q.front().first,ty=q.front().second;
		q.pop();
		if(dp[u][ty]==1){
			for(int v:rE[u]){
				if(vis[v][ty^1]==1) continue;
				d[v][ty^1]--;
				if(d[v][ty^1]==0){
					dp[v][ty^1]=0;
					vis[v][ty^1]=1;
					q.push(make_pair(v,ty^1));
				}
			}
		}else{
			for(int v:rE[u]){
				if(vis[v][ty^1]==1) continue;
				dp[v][ty^1]=1;
				vis[v][ty^1]=1;
				q.push(make_pair(v,ty^1));
			}
		}
	}
	return dp[1][1];
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=m;i++){
		int u,v;
		cin>>u>>v;
		rE[v].push_back(u);		
	}
	int l=1,r=1e9+1;
	while(l+1<r){
		int mid=(l+r)>>1;
		if(check(mid)==true) l=mid;
		else r=mid;
	}
	cout<<l<<"\n";
	return 0;
}
```

---


# [HNOI2007] 分裂游戏

## 题目描述

聪聪和睿睿最近迷上了一款叫做分裂的游戏。

该游戏的规则是： 共有 $n$ 个瓶子， 标号为 $0, 1, \ldots, n-1$，第 $i$ 个瓶子中装有 $p_i$ 颗巧克力豆，两个人轮流取豆子，每一轮每人选择 $3$ 个瓶子，标号为 $i,j,k$, 并要保证 $i \lt j, j \leq k$，且第 $i$ 个瓶子中至少要有 $1$ 颗巧克力豆，随后这个人从第 $i$ 个瓶子中拿走一颗豆子并在 $j,k$ 中各放入一粒豆子（$j$ 可能等于 $k$） 。如果轮到某人而他无法按规则取豆子，那么他将输掉比赛。胜利者可以拿走所有的巧克力豆！

两人最后决定由聪聪先取豆子，为了能够得到最终的巧克力豆，聪聪自然希望赢得比赛。他思考了一下，发现在有的情况下，先拿的人一定有办法取胜，但是他不知道对于其他情况是否有必胜策略，更不知道第一步该如何取。他决定偷偷请教聪明的你，希望你能告诉他，在给定每个瓶子中的最初豆子数后是否能让自己得到所有巧克力豆，他还希望你告诉他第一步该如何取，并且为了必胜，第一步有多少种取法？ 


## 说明/提示

$1 \leq t \leq 10$，$2 \leq n \leq 21$，$0 \leq p_i \leq 10^4$，

## 样例 #1

### 输入

```
2
4
1 0 1 5000
3
0 0 1```

### 输出

```
0 2 3
1
-1 -1 -1
0```

# 题解

## 作者：Leap_Frog (赞：28)

### Problem.
起始状态：第$i$个瓶子里装了$a_i$个巧克力豆。  
结束状态：前$n-1$个瓶子都空了，只有第$n$个瓶子放了巧克力豆。  
状态转移：选$i<j\le k$，然后在第$i$个瓶子里取走一颗，在第$j$和第$k$个瓶子里加上一颗。

### Solution.
显然，这是个博弈问题。  

看到博弈问题就想到SG函数，~~因为笔者只会这种博弈~~。

这是个Multi-SG游戏。  
但是可惜啊，Multi-SG并不是什么有什么套路的题目。  

我们突然发现，$1<n\le21$。  
所以我们可以考虑dp。  
dp转移时可以直接暴力枚举$i,j,k$。  
复杂度是$O(N^3)$能过。  

然后直接套用SG函数就好了。  

### Coding.
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=25;
int n,ans,t,sg[N],vis[N],a[N];
inline void work(int ans)
{
	int tot=0,ii=-1,jj,kk;
	for(int i=n;i>=1;i--)
		for(int j=i-1;j>=1;j--)
			for(int k=j;k>=1;k--)
				if((ans^sg[i]^sg[j]^sg[k])==0)
				{
					tot++;
					if(ii==-1) ii=n-i,jj=n-j,kk=n-k;
				}
	printf("%d %d %d\n%d\n",ii,jj,kk,tot);
}
int main()
{
	sg[1]=0;//预处理
	for(int i=2;i<=N-4;i++)
		for(int j=1;j<=i;j++)
			for(int k=j;k<i;k++)//暴力枚举i,j,k
			{
				vis[sg[j]^sg[k]]=i;//SG函数的转移
				for(sg[i]=0;vis[sg[i]]==i;sg[i]++);
			}
	for(scanf("%d",&t),ans=0;t--;ans=0)
	{
		scanf("%d",&n);
		for(int i=n;i>=1;i--) scanf("%d",a+i);
		for(int i=n;i>=1;i--) if(a[i]&1) ans^=sg[i];//这里是一个优化，每个数可以直接变成对二取模后的值。
		if(!ans) puts("-1 -1 -1\n0");else work(ans);
	}
	return 0;
}
```
~~完结散花，不要脸求赞~~

---

## 作者：ylsoi (赞：20)

这题的思路是真的巧妙，~~不愧是我大HNOI的题目。。。~~

发现满足不了条件只有一种情况，就是所有的糖果都在最后一个碗里面。但是SG函数的使用必须要有一个确定的状态，我们不可能去把每一个碗里面的每一种状态都记下来，这不现实。

然后就是这题的巧妙之处了，我们将每一个糖果看作一个单独的游戏，就是将这个糖果从第i个位置移动到第n个位置，其实也就是一堆个数为的石子等你来取。

如果每一次只增加一个糖果的话就很好办了，但是是这是增加了两个糖果，相当于增加了又新加了一堆石子。换一个角度去想，新加的这一堆石子反正最后总是要取走的，转移后的状态便是后面两个糖果所构成的游戏的和。数据这么小，上SG就完事了。
[代码](https://blog.csdn.net/ylsoi/article/details/80552209)

---

## 作者：lhm_ (赞：10)

首先可以发现，当所有巧克力豆在最后一个瓶子中时，就无法再操作了，此时为必败状态。

注意到，对于每个瓶子里的巧克力豆，是可以在模$2$的意义下去考虑的，因为后手可以模仿先手的操作，所以就将巧克力豆个数转化为了$0$或$1$。

再考虑分裂的过程，位置为$i$的巧克力豆，要分裂到位置$i$往后的两个位置，最终会到达$n$这个位置，可以把向后转移看作$Nim$游戏中取石子的操作。

那么分裂就可以看成$Nim$游戏中的一堆石子分成了两堆更小的石子，那么通过这个性质，我们就可以$O(n^3)$求出$SG$值了。

求方案数和字典序最小方案就直接暴力枚举即可，当进行第一步操作后，留给后手的为必败状态，那么该操作合法。

具体实现就看代码吧。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 100
using namespace std;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int T,n,ans,tot,flag;
int p[maxn],sg[maxn];
bool vis[maxn];
void SG()
{
    for(int i=n-1;i;--i)
    {
        memset(vis,false,sizeof(vis));
        for(int j=i+1;j<=n;++j)
            for(int k=j;k<=n;++k)
                vis[sg[j]^sg[k]]=true;
        int t=0;
        while(1)
        {
            if(!vis[t])
            {
                sg[i]=t;
                break;
            }
            t++;
        }
    }
}
int main()
{
    read(T);
    while(T--)
    {
        read(n),sg[n]=ans=tot=flag=0;
        for(int i=1;i<=n;++i) read(p[i]);
        SG();
        for(int i=1;i<=n;++i)
            if(p[i]%2)
                ans^=sg[i];
        for(int i=1;i<=n;++i)
        {
            if(!p[i]) continue;
            for(int j=i+1;j<=n;++j)
            {
                for(int k=j;k<=n;++k)
                {
                    if((ans^sg[i]^sg[j]^sg[k])==0)
                    {
                        tot++;
                        if(!flag)
                        {
                            flag=true;
                            printf("%d %d %d\n",i-1,j-1,k-1);
                        }
                    }
                }
            }
        }
        if(!flag) puts("-1 -1 -1");
        printf("%d\n",tot);
    }
    return 0;
}
```

---

## 作者：Mars_Dingdang (赞：7)

今天刚学博弈论，在其他 OJ 遇到了这道题，调了一个多小时终于做出来了，发题解纪念一下。

## 题目大意
游戏的规则是： 共有 $n$ 个瓶子， 标号为 $0,1,2…..n-1$, 第 $i$ 个瓶子中装有 $p_i$ 颗巧克力豆，两个人轮流取豆子，每一轮每人选择 3 个瓶子。标号为 $i,j,k$, 并要保证 $i < j , j \le k$ 且第 $i$ 个瓶子中至少要有 1 颗巧克力豆，随后这个人从第 $i$ 个瓶子中拿走一颗豆子并在 $j,k$ 中各放入一粒豆子（$j$ 可能等于 $k$） 。如果轮到某人而他无法按规则取豆子，那么他将输掉比赛。

求先手是否有必胜策略，若有则输出第一步操作中字典序最小的方案，以及第一步的总方案数。

## 大体思路
有向图游戏的和：$SG(G)=\bigoplus_{i=1}^n SG(G_i)$。

本题需要注意的是，不要将瓶子作为子游戏，而是将豆子作为子游戏。首先明确终止状态：游戏中止，当且仅当所有的豆子均在最后一个瓶子。为了方便，我们不妨设编号为 $n-1\sim 0$，这样有 $SG(0)=0$。

然后，每次在 $i$ 取出一个豆子，另外瓶子加入豆子，相当于在 $j,k$ 增加了一个子游戏，因此有：$SG(x)=mex\{SG(j)\oplus SG(k)|j\in [0,x-1],k\in [0,j]\}$，其中 $mex\{S\}=\min\{x|x\in\mathbb N,x\not\in S\}$。

那么，我们可以在 $O(n^3)$ 的复杂度下预处理出 $SG$。

```cpp
	inline void getSG() {
	sg[0] = 0;
	rep(i, 1, 101){
		memset(s, 0, sizeof s);
		Rep(j, i - 1, 0)
			Rep(k, j, 0)
				s[sg[j] ^ sg[k]] = 1;
		rep(j, 0, 501)
			if(!s[j]){sg[i] = j; break;}
	}
} 
```

然后在主函数中，令 $sum=\bigoplus_{i\in [0,n),p_i\text{为奇数}} SG(i)$，当且仅当 $sum=0$ 时先手必败。

然后，我们暴力枚举 $i,j,k$，$s.t.\ sum\oplus SG(i)\oplus SG(j)\oplus SG(k)=0$，即此时先手创造出了一个对于他必胜的局面，因此 $cnt+1$。枚举按一定顺序，即可找到字典序最小的解。

## 完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
const int maxn = 1e4 + 5;
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;//快读
int n, p, sg[maxn];
int a, b, c, ans;
bool s[maxn];
inline void getSG() {//预处理
	sg[0] = 0;
	rep(i, 1, 101){
		memset(s, 0, sizeof s);
		Rep(j, i - 1, 0)
			Rep(k, j, 0)
				s[sg[j] ^ sg[k]] = 1;
		rep(j, 0, 501)
			if(!s[j]){sg[i] = j; break;}
	}
} 
int T;
int main() {
	getSG();
	scanf("%d",&T);
	while(T--) {
		scanf("%d", &n);
		ans = 0;
		int sum = 0;
		Rep(i, n - 1, 0){
			scanf("%d", &p); 
			if(p & 1) sum ^= sg[i];
        //有 p 个游戏，异或值为 sg[i] ^sg[i] ^ ...，共 p 次
        //由异或的性质可得，这等价于上式
		}
		if(!sum){
			puts("-1 -1 -1");
			puts("0");
			continue;
		}//特判必败
		Rep(i, n-1, 0) { 
			Rep(j, i - 1,0){
				Rep(k, j, 0){//枚举
					int now = sum ^ sg[i] ^ sg[j] ^ sg[k];
					if(!now) {
						if(!ans) a = n-1-i, b = n-1-j, c = n-1-k;
						ans++;//记录
					}
				}
			}
		}
		printf("%d %d %d\n%d\n",a,b,c,ans);
	}
	
	return 0;
}
```

---

## 作者：Ark_ (赞：5)

# 题意
有n个格子,标号为0 ~ n-1,每个格子上有若干石子,每次操作可以选一个0 ~ n-2的格子上的一颗石子,分裂为两颗,然后任意放在后面的两个格子内,这两个格子可以相同.求使先手必胜的第一步的方案数以及最小字典序的方案.
# 分析
每一个石子都是独立的,所以考虑某一位上的一颗石子的SG函数,再异或起来就行了.实际上只用异或石子数为奇数的,因为偶数个石子异或两次相当于没有异或.

我们先把位置反向并从1~n标号,也就是最后边是1,最左边是n.这样就能对不同的n用同样的SG函数

那么对于位置$i$,它的SG函数如下:
$$SG[i]=mex\{\  \cup_{i>j>=k}SG[j]\ xor\ SG[k] \ \}$$
所以说直接预处理就行了

求方案的时候,注意字典序最小反序后就是字典序最大,所以要从大到小枚举

# CODE
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
template<typename T>void read(T &num) {
	char ch; int flg=1;
	while((ch=getchar())<'0'||ch>'9')if(ch=='-')flg=-flg;
	for(num=0;ch>='0'&&ch<='9';num=num*10+ch-'0',ch=getchar());
	num*=flg;
}
const int MAXN = 22;
int SG[MAXN], n, A[MAXN], vis[50]; //vis要开大点,SG函数会超过n
inline void Pre() {
	SG[1] = 0;
	for(int i = 2; i < MAXN; ++i) {
		for(int j = 1; j < i; ++j)
			for(int k = j; k < i; ++k)
				vis[SG[j]^SG[k]] = i;
		for(SG[i] = 0; vis[SG[i]] == i; ++SG[i]);
	}
}
inline void solve(int ans) {
	int res = 0, ans1 = -1, ans2, ans3;
	for(int i = n; i > 1; --i)
		for(int j = i-1; j > 0; --j)
			for(int k = j; k > 0; --k)
				if((ans^SG[i]^SG[j]^SG[k]) == 0) {
					++res;
					if(!(~ans1))
						ans1 = n-i, ans2 = n-j, ans3 = n-k;
				}
	printf("%d %d %d\n%d\n", ans1, ans2, ans3, res);
}
int main() {
	int T; read(T); Pre();
	while(T--) {
		read(n);
		int ans = 0;
		for(int i = n; i > 0; --i) {
			read(A[i]);
			if(A[i]&1) ans ^= SG[i];
		}
		if(!ans) printf("-1 -1 -1\n0\n");
		else solve(ans);
	}
}

```

---

## 作者：attack (赞：4)

首先，我们按照套路，观察有没有模仿棋性质的操作，发现当豆子个数为偶数的时候后手可以把先手抵消掉

这样的话豆子数实际就变成了一串01序列

我们此时回过头来考虑拿豆子的操作，实际上就是一个multi-nim的模型，然后这题就可做了

因为处理的时候需要用到后面的SG函数，所以用记忆化搜索

输出方案的话。

暴力枚举第一个的位置，然后用异或的性质判断一下

即ans^SG[i]^SG[j]^SG[k]==0，此时会留给对手必败局势

```cpp
#include<cstdio>
#include<cstring>
const int MAXN=1001;
inline char nc()
{
    static char buf[MAXN*100],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,MAXN*100,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
    char c=nc();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=nc();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=nc();}
    return x*f;
}
int N,S[MAXN],SG[MAXN];//游戏可以看做是每个位置独立进行的
int a[MAXN];
int dfs(int now)
{
    if(SG[now]!=-1) return SG[now];
    memset(S,0,sizeof(S));
    for(int i=now+1;i<=N;i++)
        for(int j=i;j<=N;j++)
            S[ (dfs(i)^dfs(j)) ] = 1;
    for(int i=0;;i++) if(!S[i]) {SG[now]=i;break;}
    return SG[now];
} 
int main()
{
    #ifdef WIN32
    freopen("a.in","r",stdin);
    #else
    #endif
    int QwQ=read();
    while(QwQ--)
    {
        memset(SG,-1,sizeof(SG));
        N=read();
        for(int i=1;i<=N;i++) a[i]=read();
        for(int i=1;i<=N;i++) 
                if(a[i]&1) dfs(i);    
        int ans=0,tot=0;
        for(int i=1;i<=N;i++) if(a[i]&1)ans=(ans^dfs(i));
        for(int i=1;i<=N;i++)
            for(int j=i+1;j<=N;j++)
                for(int k=j;k<=N;k++)
                {
                    if( (ans^dfs(i)^dfs(j)^dfs(k) )!=0) continue;
                    tot++;
                    if(tot==1) printf("%d %d %d\n",i-1,j-1,k-1);
                }
        if(tot==0) printf("-1 -1 -1\n");
        printf("%d\n",tot);
    }

    return 0;
}
```

---

## 作者：1795MiB (赞：2)

# 1.题意
- 给定一个序列，甲和乙分别进行操作。

- 每次操作将序列中一个正数减一，将这个数右侧的两个数加一（可以是相同的数）。

- 若一人无法进行操作则负，另一人胜。

- 求先手必胜的第一次操作方案数和字典序最小的第一次操作。

# 2.分析
- 显然是一道 SG 函数题。

- 对于序列中一个数 $p_i$，其等价于 $p_i \bmod 2$。

  若先手对 $p_i$ 进行操作，则后手可以对 $p_i$ 进行同样的操作。

- 容易得出一种思路：以第 $i$ 位上的数是否为 $0$ 为状态，压缩后计算 SG 值。

  但是对 $p_i$ 的修改会影响到其他位上的数，违背了快速求解 SG 值的前置条件。
  
- 考虑以 $1$ 是否在第 $i$ 位上为状态，压缩后计算 SG 值。

  **注意：这两种状态设计在表示上一致，但是前者以位置为视角，对 $a_i$ 的操作会改变其他位的状态；后者以数字为视角，对 $p_i$ 的操作可以看作 $p_i$ 分裂为 $p_j$ 和 $p_k$。**

- 考虑到有多组询问且 $n$ 较小，故可以采用预处理每种状态的 SG 值或采用记忆化搜索。

# 3.代码
```cpp

#include <iostream>
#define LL long long

using namespace std;

int t, n, s, ans, a[22], d[22];
bool b;

int main() {
  for (int i = 1; i < 22; i++) {  // 预处理SG值
    bool b[56] = {};
    for (int j = i - 1; j >= 0; j--) {  // 枚举分裂的情况
      for (int k = j; k >= 0; k--) {
        b[d[j] ^ d[k]] = 1;  // 加入集合
      }
    }
    for (; d[i] < 56 && b[d[i]]; d[i]++) {  // 求MEX
    }
  }
  cin >> t;
  while (t--) {
    s = b = ans = 0;
    cin >> n;
    for (int i = 1; i <= n; i++) {
      cin >> a[i];
      s ^= (a[i] & 1) * d[n - i];  // 累计当前状态
    }
    if (!s) {
      cout << "-1 -1 -1\n";
    } else {
      for (int i = 1; i <= n; i++) {
        for (int j = i + 1; j <= n; j++) {
          for (int k = j; k <= n; k++) {
            if (a[i] && !(s ^ d[n - i] ^ d[n - j] ^ d[n - k])) {  // 非0且可达必败局面
              if (!b) {
                cout << i - 1 << ' ' << j - 1 << ' ' << k - 1 << '\n';
              }
              ans += b = 1;  // 统计答案
            }
          }
        }
      }
    }
    cout << ans << '\n';
  }
  return 0;
}

```
# 4.注解
- 本题解中所有变量名与题目相同。

- [我的Blog](https://www.luogu.com.cn/blog/Made-in-Code/)

---

## 作者：lingfunny (赞：2)

# [HNOI2007]分裂游戏 题解

首先转化题意。

在 $i$ 中拿走豆子并放到任意的 $j,k$ 中，并且限制了 $j,k>i$。

把这 $n$ 个瓶子翻转，变成 $i\to j,k$，且 $j,k<i$。

可以看成把一个有 $i$ 个石子的石子堆取成 $j$ 个石子，并添加一个有 $k$ 个石子的石子堆。石子数量是在不断变小的，已经很类似 Nim 游戏了。

然后设计 $\operatorname{SG}$ 函数。

因为每次只能对一个豆子操作，换句话说就是只能对一个石子堆操作。

所以可以直接拆分为若干个石子堆的子游戏，在这个意义下，根据 $\operatorname{SG}$ 函数的性质（$\operatorname{SG}(X)\oplus \operatorname{SG}(X)=0$），每个瓶子中的豆子应分别对 $2$ 取模。

可以记 $X$ 为一堆有 $X$ 个石子的局面。然后暴力枚举分裂出来的两个石子堆 $J,K$，也就是变成两个子游戏 $J$ 和 $K$，根据 $\operatorname{SG}$ 函数的定义直接计算。
$$
\operatorname{SG}(X)=\operatorname{Mex}\{\operatorname{SG}(J)\oplus \operatorname{SG}(K)\mid J,K<X\}
$$
对于输出方案，可以暴力枚举开局取的三个瓶子，然后算取完后局面的 $\operatorname{SG}$ 值。

时间复杂度 $\mathcal O(tn^3)$。

### C0DE

```cpp
// Problem: P3185 [HNOI2007]分裂游戏
// From: Luogu
// URL: https://www.luogu.com.cn/problem/P3185
// Time: 2022-04-20 20:12
// Author: lingfunny

#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int mxn = 64;

int n, p[mxn], a[mxn], SG[mxn], vis[mxn], cnt;

inline void Get() {
	SG[0] = 0;
	for(int i = 1; i <= 22; ++i) {
		for(int k = 0; k <= 22; ++k) vis[k] = 0;
		for(int j = 0; j < i; ++j)
		for(int k = 0; k <= j; ++k)
		vis[ SG[j] ^ SG[k] ] = 1;
		while(vis[SG[i]]) ++SG[i];
	}
}

inline void solve() {
	scanf("%d", &n); cnt = 0;
	for(int i = 0; i < n; ++i) scanf("%d", p+i);
	for(int i = 0; i < n; ++i) if(p[i])
	for(int j = i+1; j < n; ++j)
	for(int k = j; k < n; ++k) {
		--p[i]; ++p[j]; ++p[k];
		int res = 0;
		for(int d = 0; d < n; ++d) if(p[d]&1) res ^= SG[n-d-1];
		if(!res && ++cnt == 1) printf("%d %d %d\n", i, j, k);
		++p[i]; --p[j]; --p[k];
	}
	if(!cnt) puts("-1 -1 -1");
	printf("%d\n", cnt);
}

int main() {
	int tt; Get();
	scanf("%d", &tt);
	while(tt--) solve();
	return 0;
}
```

---

## 作者：WJX3078 (赞：2)

本题是一道较好的 SG 函数练习题，理解其推导过程可以帮助我们更好的掌握 SG 函数。

## 1.题意简述

给定一串长度为 $n$ 的序列，第 $i$ 位的数值为 $a[i]$，每次操作可以选定三个下标 $i,j,k$ 满足 $i < j \le k$，使 $a[i]-1,a[j]+1,a[k]+1$，两人轮流操作，无法操作者为输。求先手必胜的第一步的走法以及第一步走法的种类数。

## 2.解题思路

显然，本题是一道博弈论 ~~（废话）~~，通过分析，我们可以得到以下结论：

- 最终无法操作的局面就是只有第 $n$ 位有数值，其余位都是 $0$。

- 对于 $\forall i \in [1,n] ,a[i] \ge 2 $，我们都可以将其模 $2$ 后再处理。（因为后手可以模仿先手的操作，所以一定可以同时减少 $2$ 的倍数）

- 面向数据编程（雾），本题数据范围为 $N \le 21$，所以只要复杂度不是阶乘级就可以接受。我们**以每一个豆子为子游戏，暴力枚举 $i,j,k$ 求出每一位上只有一个豆子时的 SG 函数值**。这是本代码的时间复杂度瓶颈，为 $\Theta(n^3)$。

## 3.代码

```cpp
#include <iostream>
#include <cstdio>
#include <cctype>
#include <cstring>
#define il inline
#define ll long long
#define re register
#define gc getchar
using namespace std;
il int read() {
	int x=0;bool f=0;char ch=gc();
	while(!isdigit(ch)) {f|=ch=='-';ch=gc();}
	while(isdigit(ch)) {x=(x<<1)+(x<<3)+(ch^48);ch=gc();}
	return f?-x:x;
}	

il int max(int a,int b) {return a>b?a:b;}

il int min(int a,int b) {return a<b?a:b;}

const int N=100;
int T,n,ans,x,y,z,sg;
int a[N],SG[N];
bool vis[N<<1];//异或可能会超出n的范围，为了防止爆数组，要开两倍空间 

signed main() {
	T=read();
	while(T--) {
		ans=x=y=z=sg=0;
		memset(SG,0,sizeof(SG));
		n=read();
		for(re int i=1;i<=n;++i) a[i]=read();
		for(re int i=n-1;i;--i) {//因为SG值由其后继状态得到，所以从后往前推 
			memset(vis,0,sizeof(vis));
			for(re int j=i+1;j<=n;++j) 
				for(re int k=j;k<=n;++k) 
					vis[SG[j]^SG[k]]=1;//SG函数定义 ：SG[i]=mex(其后继状态的SG值)
			for(re int j=0;;++j) if(!vis[j]) {SG[i]=j;break;}
		}	
		for(re int i=1;i<=n;++i) if(a[i]&1) sg^=SG[i];//只有模2余1的位草堆答案有贡献 
		for(re int i=1;i<=n;++i) 
			if(a[i]) //这一位有数才可以移动 
			for(re int j=i+1;j<=n;++j) 
				for(re int k=j;k<=n;++k) 
					if((sg^SG[i]^SG[j]^SG[k])==0)	{
						//对于总SG值不为0的博弈，第一步将总SG值变为0就是必胜策略
						//移动第i位，对总SG值少了SG[i]，多了SG[j],SG[k]
						if(!ans) {x=i,y=j,z=k;}
						++ans;
					}	
		printf("%d %d %d\n",x-1,y-1,z-1);//题目中瓶子编号为0~n-1，所以最后ans-1 
		printf("%d\n",ans);
	}	
	return 0;
}	
```


---

## 作者：Sea_Level (赞：2)

这题我写+调一整天终于搞出来了，心累啊……发篇题解梳理一下，也希望能帮到各位。

## 题意

现在有两个人轮流从 $n$ 瓶被标号为 $0,1,...,n-1$ 的巧克力豆中取豆子，第 $i$ 个瓶子中装有 $p_i$ 颗巧克力豆。每一轮每人选择 $3$ 个瓶子，标号为 $i,j,k$ 并要保证 $i< j,j\leq k$ 且第 $i$ 个瓶子中至少要有 $1$ 颗豆子，随后这个人从第 $i$ 个瓶子中拿走一颗豆子并在 $j,k$ 中各放入一粒豆子，问先手是否有必胜策略，如果有则输出第一步操作中字典序最小的一组解和总方案数，没有则输出输出用一个空格两两隔开的三个 $-1$ 。

## 分析

我们可以在模 $2$ 的意义下考虑所有的巧克力豆，因为后手必须模仿先手的操作。

为什么后手必须模仿先手的操作呢？因为如果本来是先手必败状态，先手操作一次后后手不去模仿，先手就可以再操作一次变成后手的必败状态。

因为这题中每个瓶子不是互相独立的，所以不好用 $SG$ 定理，因为不独立时 $SG$ 定理不成立。我们可以把每个豆子看作这题的基本单位，也就是一个游戏，这样每个游戏之间就是完全独立的了。

接下来按照规则取豆子时我们可以看作把$i$里的一个豆子变成了两个豆子放到 $j,k$ 里，所以我们可以枚举 $i$ 里的豆子放到哪两个$j,k$里再对它们取一个 $mex$ ，这样我们就可以 $O(n^3)$ 求出 $SG$ 值了。

求方案数和第一步解直接暴力枚举就可以了，当进行第一步操作后，后手的状态是必败态即可。

## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int t,n,a[100],cnt,flag,sg[100],ans,vis[100];
void qiu_sg(){//求SG
	for(int i=n;i>=1;i--){//因为SG值由后续状态推出，所以从n到1循环
		memset(vis,false,sizeof(vis));
		for(int j=i+1;j<=n;j++){
			for(int k=j;k<=n;k++){
				vis[sg[j]^sg[k]]=true;
			}
		}
		int t=0;
		while(1){
			if(!vis[t]){
				sg[i]=t;
				break;
			}
			t++;
		}
	}
}
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		for(int i=1;i<=n;i++){
			scanf("%d",&a[i]);
		}
		qiu_sg();
		ans=cnt=flag=0;
		for(int i=1;i<=n;i++){
			if(a[i]%2){//只有豆子为奇数的瓶子有贡献
				ans^=sg[i];
			}
		}
		for(int i=1;i<=n;i++){
			if(!a[i]) continue;//没豆子就没的可取
			for(int j=i+1;j<=n;j++){
				for(int k=j;k<=n;k++){
					if((sg[i]^sg[j]^sg[k])==ans){//让后手必败就是让SG值为0，因为先手操作一步让整个游戏的SG变成0之后后手就会变成先手，SG值为0就是对于当前先手的必败状态，也就是原来后手的必败状态
						cnt++;
						if(!flag){
							flag=1;
							printf("%d %d %d\n",i-1,j-1,k-1);
						}
					}
				}
			}
		}
		if(!flag){
			printf("-1 -1 -1\n");
		}
		printf("%d\n",cnt);
	}
	return 0;
}
```


---

## 作者：N2MENT (赞：1)

博弈论做题记录 [P3185](https://www.luogu.com.cn/problem/P3185)。

很有趣的博弈论。

***

不在乎瓶子里的糖果数目，而是每个糖果。如果不进行分裂，把糖果 $x$ 从 $i$ 移到 $j$ 相当于从第 $x$ 堆里取出 $j - i$ 个石子，糖果挪到 $n - 1$ 的时候就取完了。那么分裂的时候，将一个糖果从 $i$ 移到 $j$ 和 $k$ 相当于把一堆石子分成两个互不影响的子游戏。$\operatorname{sg}(x)$ 表示糖果在 $x$ 的时候的 sg 值，根据 sg 值的性质，两个互不影响的子游戏的总 sg 值是它们两个的异或和，$\operatorname{sg}(i) = \operatorname{mex}_{j>i,k\geq j}\{\operatorname{sg}(j) \oplus \operatorname{sg}(k)\}$，倒着暴力处理就行。对于整个游戏的 sg 值，只考虑模 $2$ 余 $1$ 的瓶子（否则后手可以模仿先手，相当于什么都没做），总的 sg 值就是它们的异或和。求第一步的策略可以暴力枚举，操作后必败。

```
// Problem: P3185 [HNOI2007]分裂游戏
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P3185
// Memory Limit: 125 MB
// Time Limit: 1000 ms
//
// Powered by CP Editor (https://cpeditor.org)
#include <bits/stdc++.h>
using namespace std;
const int maxp = 1e4 + 10;
int sg[maxp];
bool vis[maxp];
void init(int n) {
    memset(sg, 0, sizeof(sg));
    for (int i = n - 1; ~i; i--) {
        memset(vis, 0, sizeof(vis));
        for (int j = i + 1; j < n; j++) {
            for (int k = j; k < n; k++) {
                vis[sg[j] ^ sg[k]] = true;
            }
        }
        while (vis[sg[i]]) sg[i]++;
    }
}
int n;
int p[maxp];
void solve() {
    scanf("%d", &n);
    init(n);
    int SG = 0;
    for (int i = 0; i < n; i++) {
        scanf("%d", p + i);
        if (p[i] & 1)
            SG ^= sg[i];
    }
    int a = -1, b = -1, c = -1, cnt = 0;
    for (int i = 0; i < n; i++) {
        if (!p[i])
            continue;
        for (int j = i + 1; j < n; j++) {
            for (int k = j; k < n; k++) {
                if ((SG ^ sg[i] ^ sg[j] ^ sg[k]) == 0) {
                    cnt++;
                    if (a == -1) {
                        a = i, b = j, c = k;
                    }
                }
            }
        }
    }
    printf("%d %d %d\n%d\n", a, b, c, cnt);
}
int t;
int main() {
    scanf("%d", &t);
    while (t--) solve();
}
```

---

## 作者：「已注销」 (赞：1)

感谢评论指出错误，已修改

---

使用`SG定理`可以$O(n^3)$解决本题

`SG`定理：$SG(x)=mex\{x\texttt{的后继状态}\}$

将每颗豆子视为一个游戏，设该豆子在第$n-1-i$个瓶子里，则

$SG(0)=0$

$SG(i)=mex\{SG(j)\oplus SG(k)|j,k<i\}$

其中$mex\ S$表示最小的非负整数$x\notin S$

一个局面是必胜状态当且仅当所有豆子的$SG$函数值异或不为$0$

预处理$SG$函数值，枚举第一步操作，检查局面是否合法

```cpp
#include<cstdio>
int T,n,a[22],tot,ans,sg[]={0,1,2,4,7,8,11,13,14,16,19,21,22,25,26,28,31,32,35,37,38,41,42};
int main(){
    scanf("%d",&T);
    while(T--){
        tot=ans=0;
        scanf("%d",&n);
        for(int i=1;i<=n;++i){
            scanf("%d",&a[i]);
            if(a[i]&1)ans^=sg[n-i];
        }
        for(int i=1;i<n;++i)if(a[i])
            for(int j=i+1;j<=n;++j)
                for(int k=j;k<=n;++k)
                    if(!(ans^sg[n-i]^sg[n-j]^sg[n-k])){
                        if(!tot)printf("%d %d %d\n",i-1,j-1,k-1);
                        ++tot;
                    }
        if(!tot)puts("-1 -1 -1");
        printf("%d\n",tot);
    }
}
```

---

## 作者：FReQuenter (赞：0)

博弈论。我们考虑 SG 函数。

[基本的 SG 博弈看这里。](https://zhuanlan.zhihu.com/p/569087153)

首先明确所有的瓶子里的豆子数量都可以模 $2$ 来考虑。因为每次都是在三个不同的瓶子里取出或者放入豆子。

这就相当于每次在移动和增加豆子。

所以我们把豆子作为子游戏来考虑，而不是瓶子。因为一动就要动三个瓶子。

那么得到：

$$SG(0)=0$$

$$SG(i)=\text{mex}\{SG(j)\oplus SG(k)\}$$

其中 $0\leq j \leq i-1$ 且 $0\leq k \leq j$。就是 $j$ 和 $k$ 为 $i$ 的前驱。指 $j$ 和 $k$ 放入，$i$ 拿出。$SG(i)$ 代表当一颗豆子在瓶子 $i$ 时的 SG 值。

可以 $O(n^3)$ 预处理出来 SG 表。

查询时 $i,j,k$ 按照先后顺序枚举并且记录下最小值就可以了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t,ans,sum,ansi,ansj,ansk,sg[25];
bool vis[205];
signed main(){
	for(int i=1;i<=21;i++){
		memset(vis,0,sizeof(vis));
		for(int j=i-1;j>=0;j--){
			for(int k=j;k>=0;k--){
				vis[sg[j]^sg[k]]=1;
			}
		}
		while(vis[sg[i]]) sg[i]++;
	}
	cin>>t;
	while(t--){
		cin>>n;
		ans=sum=ansi=ansj=ansk=0;
		for(int i=1;i<=n;i++){
			int x;
			cin>>x;
			if(x&1) ans^=sg[n-i];
		} 
		if(ans){
			for(int i=0;i<n;i++){
				for(int j=0;j<i;j++){
					for(int k=0;k<=j;k++){
						if(!(ans^sg[i]^sg[j]^sg[k])){
							sum++;
							ansi=n-i-1,ansj=n-j-1,ansk=n-k-1;
						}
					}
				}
			}
			cout<<ansi<<' '<<ansj<<' '<<ansk<<'\n'<<sum<<'\n';
		}
		else cout<<"-1 -1 -1\n0\n";
	}
}
```

---

## 作者：541forever (赞：0)

考虑将一个糖果看作一个有向图游戏，因为一个位置在 $i$ 的糖果可以分裂成一个位置在 $j$ 和一个位置在 $k$ 的糖果($i \lt j \le k$)，因此可以看作 $i$ 的后继状态是子游戏 $j$ 和子游戏 $k$ 的和。因此根据 SG 函数的定义，$SG_i=mex\left\{\begin{matrix}SG_j \bigoplus SG_k|i \lt j \le k \end{matrix}\right\}$，然后我们便可以暴力求出每个位置的球的 $SG$ 的值，然后我们又可以发现，我们只需关心一个位置的球的个数的奇偶性（因为后手总是能与先手做同样的操作），所以根据 SG 定理，我们将所有的球个数为奇数的 $SG$ 值异或起来的值 $sum$ 便是最终的胜负状态，至于求第一步的方案数和第一步字典序最小的操作，我们只需枚举 $i,j,k$ 看是否将对手逼入了必败态，即看 $sum\bigoplus SG_i \bigoplus SG_j \bigoplus SG_k$ 是否为 $0$。这样就可以求出了方案数和字典序最小的方案了。

---

## 作者：Leasier (赞：0)

注意到每次只能拿走一颗豆子，于是我们考虑把每颗石子视为一个单独的游戏，将其 SG 值异或起来即可得到整个局面的 SG 值。

设位于 $x$ 的一颗豆子的 SG 值为 $SG(x)$，则我们不难得到：$SG(x) = \operatorname{mex}_{x < i \leq j \leq n} (SG(i) \operatorname{xor} SG(j))$。

暴力 dp 即可求出所有 SG 值。对于一个有解的局面，枚举第一次操作的 $i, j, k$，满足 $\text{global SG} \operatorname{xor} SG(i) \operatorname{xor} SG(j) \operatorname{xor} SG(k) = 0$ 者即为可行的初始操作。

时间复杂度为 $O(tn^3)$。

代码：
```cpp
#include <stdio.h>

int sg[27], p[27];
bool vis[217];

inline int sum1(int n){
	return n * (n + 1) / 2;
}

inline void init(int n){
	for (int i = n; i >= 1; i--){
		int t = sum1(n - i);
		for (int j = 0; j <= t; j++){
			vis[j] = false;
		}
		for (int j = i + 1; j <= n; j++){
			for (int k = j; k <= n; k++){
				vis[sg[j] ^ sg[k]] = true;
			}
		}
		sg[i] = 0;
		while (vis[sg[i]]) sg[i]++;
	}
}

int main(){
	int t;
	scanf("%d", &t);
	for (int i = 1; i <= t; i++){
		int n, global_sg = 0;
		scanf("%d", &n);
		init(n);
		for (int j = 1; j <= n; j++){
			scanf("%d", &p[j]);
			if (p[j] % 2 == 1) global_sg ^= sg[j];
		}
		if (global_sg == 0){
			printf("-1 -1 -1\n");
			printf("0\n");
			continue;
		}
		int ansi, ansj, ansk, ans_cnt = 0;
		bool flag = false;
		for (int j = 1; j < n; j++){
			if (p[j] >= 1){
				for (int k = j + 1; k <= n; k++){
					for (int l = k; l <= n; l++){
						if ((global_sg ^ sg[j] ^ sg[k] ^ sg[l]) == 0){
							ans_cnt++;
							if (!flag){
								flag = true;
								ansi = j - 1;
								ansj = k - 1;
								ansk = l - 1;
							}
						}
					}
				}
			}
		}
		printf("%d %d %d\n", ansi, ansj, ansk);
		printf("%d\n", ans_cnt);
	}
	return 0;
}
```

---

## 作者：ljt12138 (赞：0)

SG函数

首先石子是独立的，于是分别考虑。一个石子的SG值为后继状态的SG值取mex。对于一个状态，一个石子变为两个石子后就独立了，于是可以异或起来得到这个状态。只要暴力构图，然后所有石子异或起来。

寻找就枚举位置，利用异或自为逆运算判断。


```c++
#include <bits/stdc++.h>
using namespace std;

int a[30], sg[30];
int n;
int basket[100];

int main()
{
    int t; scanf("%d", &t);
    while (t--) {
        scanf("%d", &n);
        for (int i = 1; i <= n; i++)
            scanf("%d", &a[i]);
        sg[n] = 0;
        for (int i = n-1; i >= 1; i--) {
            memset(basket, 0, sizeof basket);
            for (int j = i+1; j <= n; j++)
                for (int k = j; k <= n; k++)
                    basket[sg[j]^sg[k]] = 1;
            for (int j = 0; ; j++) if (basket[j] == 0) { sg[i] = j; break; }
        }
        int ans = 0;
        for (int i = 1; i <= n; i++)
            if (a[i]&1)
                ans ^= sg[i];
        if (ans == 0) {
            printf("-1 -1 -1\n0\n");
        } else {
            //cout << ans << " " << sg[1] << " " << (ans^sg[1]) << endl;
            int a1, b, c, cnt = 0; a1 = b = c = -1;
            for (int i = 1; i <= n; i++)
                for (int j = i+1; j <= n; j++)
                    for (int k = j; k <= n; k++)
                        if (((ans^sg[i]^sg[j]^sg[k]) == 0) ){
                            if (a1+b+c < 0) a1 = i, b = j, c = k;
                            cnt++;
                        } 
            printf("%d %d %d\n%d\n", a1-1, b-1, c-1, cnt);
        }
    }
    return 0;
}
```

---

## 作者：I_am_Accepted (赞：0)

**Upd:** 感谢 [Little09](https://www.luogu.com.cn/user/151475) 把我 Hack（数据真的水），现已修改。

我们发现每一个豆子都是一个独立的游戏，所以我们将每一个豆子的 SG 异或和就可判断是否先手必胜。

而对于每一个位置上的豆子，若有偶数个则异或抵消，所以我们最后每个位置保留 $0/1$ 个豆子。

（以下下标从 $1$ 开始）

设 $c_i$ 表示 $i$ 位置上的一颗豆子的 SG 值，则答案为
$$
\sum_{i=1}^nc_i[a_i\equiv1\pmod2]
$$
同时有递推式
$$
c_i=\text{mex}\{c_j\ \text{xor}\ c_k\ |\ i<j\le k\le n\}
$$
最后枚举第一步来求出第一步如何必胜即可。

时间 $O(n^3)$。

```cpp
//We'll be counting stars.
//#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
using namespace std;
#define fir first
#define sec second
#define mkp make_pair
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i<=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i>=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define debug(...) cerr<<"#"<<__LINE__<<": "<<__VA_ARGS__<<endl
#define ll long long
const ll mod=1;
inline ll pw(ll x,ll y){ll r=1;while(y){if(y&1)r=r*x%mod;x=x*x%mod;y>>=1;}return r;}
#define int ll
#define N 25
#define M 215
int n,a[N],b[N][M],c[N];
void solve(int id,int val){
    For(i,id+1,n) For(j,i,n) if((c[i]^c[j])==val){
        cout<<id-1<<" "<<i-1<<" "<<j-1<<endl;
        return ;
    }
}
void work(){
    cin>>n;
    For(i,1,n) fill(b[i],b[i]+M,0);
    int x;
    Rof(i,n,1){
        For(j,i+1,n) For(k,j,n) b[i][c[j]^c[k]]++;
        x=0;
        while(b[i][x]) x++;
        c[i]=x;
    }
    // For(i,1,n) cout<<c[i]<<" "; cout<<endl;
    For(i,1,n) cin>>a[i];
    int tar=0;
    For(i,1,n) if(a[i]&1) tar^=c[i];
    if(tar==0){
        cout<<"-1 -1 -1\n0"<<endl;
        return ;
    }
    int ans=0;
    For(i,1,n) if(a[i]){
        if(ans==0 && b[i][c[i]^tar]!=0) solve(i,c[i]^tar);
        ans+=b[i][c[i]^tar];
    }
    cout<<ans<<endl;
}
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
    int T;cin>>T;
    while(T--)work();
return 0;}
```

---

## 作者：c20210623 (赞：0)

题目链接：[P3185 [HNOI2007]分裂游戏](https://www.luogu.com.cn/problem/P3185)

把每一颗豆子看作一个子游戏。显而易见，
另外几颗豆子的状态不影响该豆子的结果。
因此我们可以对每一颗豆子分别当成一个游戏求 $\text{sg}$ 函数。

对于每一个瓶子的豆子而言，有n颗豆子等价于有$\text{n+2}$ 颗豆子。
因为若此时对手从 $\text{a}$ 瓶子取 $\text{1}$ 颗到 $\text{b}$ 瓶子和 $\text{c}$ 瓶子，
对手只需模仿操作一次即可复原状态。

因此凡一个瓶子有偶数颗豆子，等价于有 $\text{0}$ 颗豆子，
我们可以直接跳过不考虑。有奇数颗豆子，
我们就直接认为该瓶子只有 $\text{1}$ 颗豆子。

此时我们就可以自然的定义 $\text{sg}$ 数组了。
设 $\text{sg[i]}$ 为考虑第 $\text{n-i+1}$ 个瓶子有 $\text{1}$ 颗豆子时的 $\text{sg}$ 函数。
（为了使 $\text{n}$ 不同时的 $\text{sg}$ 函数边界相同，必须倒着定义。）

对于任何个 $\text{sg[i]}$ 的下一个状态 
$\text{sg[j][k]}$ 我们可以由 $\text{sg}$ 定理知道 $\text{sg[j][j]}$ $=$ $\text{sg[j]}$ $^$ $\text{sg[k]}$ 。sg函数的递归边界显然为 $\text{sg[1]}$ $=$ $\text{0}$ 。

下面就是模板了。代码如下：
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int T,n,sg[25],a[25];
int init(int n){//预处理sg[n] 
	bool vis[105]={}; 
	if(sg[n]!=-1) return sg[n];//记忆化 
	if(n==1) return sg[1]=0;//边界 
	for(int i=1;i<n;i++){
		for(int j=1;j<=i;j++) vis[init(i)^init(j)]=1;//下一个状态：sg[i][j] 
	}
	for(int i=0;;i++) if(!vis[i]) return sg[n]=i;
}
int main(){
	scanf("%d",&T);
	memset(sg,-1,sizeof(sg));
	for(int i=1;i<=21;i++)
		if(sg[i]==-1) init(i);//预处理sg函数。 
	while(T--){
		scanf("%d",&n);
		int ans=0,ans1=0,vi=0,vj=0,vk=0;//ans就是最终问题的sg值 ans1为满足情况的总数 
										//vi,vj,vk先都赋为0，-1即为最终答案，这样就可以不分类讨论。 
		for(int i=1;i<=n;i++){
			scanf("%d",&a[i]);
			if(a[i]&1) ans^=sg[n-i+1];//只有i%2==1的情况是一个子问题。 
		}
		for(int i=1;i<=n-1;i++){
			for(int j=i+1;j<=n;j++){
				for(int k=j;k<=n;k++){
					if(!(ans^sg[n-i+1]^sg[n-j+1]^sg[n-k+1])){
						if(vi==0) vi=i,vj=j,vk=k;
						ans1++;
					}
				}
			}
		}
		printf("%d %d %d\n%d\n",vi-1,vj-1,vk-1,ans1);
	}
	return 0;
}
```

---


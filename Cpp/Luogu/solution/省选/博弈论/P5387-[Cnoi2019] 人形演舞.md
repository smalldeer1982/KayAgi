# [Cnoi2019] 人形演舞

## 题目背景

由于出题人都退役了, 所以题目背景咕咕咕~了.

## 题目描述

Cirno 与 Marisa 之间有一个博弈:

首先给定 一个 **有序整数序列** $V$, 所有的数字都是在 $[1, m]$ 之间。

每次一个人可以选取 $x \in V, y \in [1, x]$, 且 $ x \oplus y \in [0, x)$ , 然后把  $x$ 变为 $x \oplus y$。

$\oplus$ 表示按位异或。

当一个人不能操作时, 则视作失败。

假定 Cirno 和 Marisa 都使用最优策略。

现在 Cirno 想知道自己先手时获胜的方案数对 $998244353$ 取模后是多少。


## 说明/提示

对于 100% 的数据，$|V| \le 10^{18}, m \le 10^6$。

采用捆绑测试。

## 样例 #1

### 输入

```
4 5```

### 输出

```
312```

# 题解

## 作者：EternalAlexander (赞：14)

怎么没有题解，水一个。

考虑怎么算 $SG(x)$ 。我们断言 $SG(2^k+n) = n+1 (n\in[0,2^k))$。

假设上述结论对所有 $i<x$ 都成立，我们证明该结论对 $x=2^k+n$ 成立。

若 $x=2^k$ ，$SG(x)=1$。如果 $y$ 的第 $k$ 位为 $1$，则只能 $y=x$，否则如果不为 $1$，则 $y \bigoplus x > x$。综上 $x$ 的后继状态只有 $0$，故 $SG(x)=1$。

对于 $x = 2^k + n, n \in [0,2^k)$，$SG(x) = n$ 。依然考虑最高位，如果为 $0$ 则 $x \bigoplus y \in [2^k, 2^k+n)$，显然这些后继的 $SG$ 值包含了 $[1,n]$。注意到 $0$ 也是 $x$ 的后继，因此 $[0,n]$ 都出现过。

否则，设去掉最高位的 $y$ 为 $y'$ ，有 $y' \leq n$ 且 $x \bigoplus y = n \bigoplus y'$。设 $m=2^{\lfloor \log_2 n \rfloor}$，显然有 $SG(n \bigoplus y') \leq m \leq n$。

综上，$x$ 后继的 $SG$ 值的 $\operatorname{mex}$ 为 $n+1$，则 $SG(x)=n+1$。

至此我们可以在 $O(m \log m)$ 的时间内算出 $[1,m]$ 的 $SG$ 值，就是要选出 $|V|$ 个数使得它们的 $SG$ 值的异或和不为 $0$。

设 $A_i = \sum_{x=1}^m [SG(x)=i]$，$B=A^{|V|}$（这里的乘法是异或卷积运算），则选取 $|V|$ 个数使得异或和为 $x$ 的方案数即为 $B_x$。

那么现在的问题就是怎么做异或卷积快速幂，每次 FWT 一遍复杂度不太对，我们可以先 FWT 一次，然后用 FWT 后的数组做乘法，最后 FWT 回来，就可以做到 $O(m \log |V|)$ 了。

至此我们在 $O(m \log m + m \log |V|)$ 的时间内解决了这个简单的问题。

```cpp
#include <bits/stdc++.h>
#define maxn 1048576
#define ll long long
const int mod=998244353;
const int inv2=(mod+1)/2;
int A[maxn],b[maxn],n,lim;
ll k;

int SG(int x){
	int len=1,sum=0;
	while(sum<x){
		sum+=len;
		if(sum>=x)return x-(sum-len);
		len<<=1;
	}
}

void FWT(int *a,int lim,int flag){
	for(int i=1;i<lim;i<<=1)
	for(int j=0;j<lim;j+=(i<<1))
	for(int k=0;k<i;++k){
		int a1=a[j+k],a2=a[j+k+i];
		a[j+k]=(a1+a2)%mod;a[j+k+i]=(a1-a2+mod)%mod;
		if(flag==-1){
			a[j+k]=(ll)a[j+k]*inv2%mod;a[j+k+i]=(ll)a[j+k+i]*inv2%mod;
		}
	}
}

void mul(int *a,int *b,int lim){
	for(int i=0;i<lim;++i)a[i]=(ll)a[i]*b[i]%mod;
}

void qpow(int *a,ll k,int lim){
	b[0]=1;FWT(b,lim,1);
	while(k){
		if(k&1)mul(b,a,lim);
		mul(a,a,lim);
		k>>=1;
	}std::memcpy(a,b,sizeof(b));
}

int main(){
	int max=0;lim=1;
	scanf("%lld%d",&k,&n);
	for(int i=1;i<=n;++i){
		int d=SG(i);
		A[d]++;
		max=std::max(max,d);
	}while(lim<=max)lim<<=1;
	FWT(A,lim,1);
	qpow(A,k,lim);
	FWT(A,lim,-1);
	int sum=0;
	for(int i=1;i<lim;++i)sum=(sum+A[i])%mod;
	printf("%d",sum);
	return 0;
}
```


---

## 作者：UniverseofHK (赞：7)

容易发现，对于该集合中所有元素的变化过程，可以看作是相互独立的。于是按照 $SG$ 函数思路，对于一个确定的集合，如果每个元素的 $SG$ 值都知道了，则整个集合的 $SG$ 值也就得到了。

考虑一个元素 $x$：

1. 如果 $x=0$，则 $SG(x)$ 显然为 $0$；

2. 如果 $x=2^k$，则 $x$ 只能变成 $x’=0$，于是 $SG(x=2^k)=1$；

3. 对于 $x=2^k+p(0<p<2^k)$，先假设其 $SG$ 值为 $p+1$，再利用数学归纳法进行证明。

   假设 $SG(x=2^k+p)=p+1$ 对于 $x’<x$ 都成立，则考虑 $x$ 所能选择的 $y$：

   - 若 $y=q(0≤q≤p)$，则可以通过 $q$ 的取值，使得 $t \in [2^k,2^k+p)$ 都被 $x$ ^ $y$  得到，且 $t=0$ 也能得到，即 $SG(x)$ 至少为 $p+1$ 。
   - 若 $y=2^k+q(0≤q≤p)$，则 $x$ ^ $y≤p$，于是不管 $y$ 如何取，$SG(x$ ^ $y)≤2^{log_2p}<p+1$。

   于是 $SG(x)=p+1$ 成立。

总结一下就是 $SG(0)=0,SG(x=2^k+p(0≤p<2^k))=p+1$。

对于这个完整的问题，我们可以先计算 $[1,m]$ 内的 $SG$ 值，然后用异或卷积 $|V|$ 次即可，具体来说就是$FWT$+快速幂。

时间复杂度 $O(m\log(m)+m(\log(m)+\log(n)))=O(m(\log(m)+\log(n)))$。

参考代码

```cpp
#include "bits/stdc++.h"
#define hhh cerr<<"hhh"<<endl
#define see(x) cerr<<(#x)<<'='<<(x)<<endl
using namespace std;
typedef long long ll;
typedef pair<int,int> pr;
inline int read() {int x=0,f=1;char c=getchar();while(c!='-'&&(c<'0'||c>'9'))c=getchar();if(c=='-')f=-1,c=getchar();while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();return f*x;}

const int maxn = (1<<20)+7;
const int mod = 998244353, inv2 = 499122177;

int n, up;
ll f[maxn], g[maxn], h[maxn];

void FWT(ll *f, int op) {
    for(int len=2; len<=up; len<<=1) {
        for(int l=0, hf=len>>1; l<up; l+=len) {
            for(int i=l; i<l+hf; ++i) {
                ll x=f[i], y=f[i+hf];
                if(op>0) {
                    if(op==1) f[i]=(x+y)%mod, f[i+hf]=(x-y+mod)%mod; //xor
                    else if(op==2) f[i]=(x+y)%mod; //and
                    else f[i+hf]=(x+y)%mod; //or
                }
                else {
                    if(op==-1) f[i]=(x+y)*inv2%mod, f[i+hf]=(x-y+mod)*inv2%mod; //xor
                    else if(op==-2) f[i]=(x-y+mod)%mod; //and
                    else f[i+hf]=(y-x+mod)%mod; //or
                }
            }
        }
    }
}

void mul(ll *a, ll *b, ll *c) {
    for(int i=0; i<up; ++i) (c[i]=a[i]*b[i])%=mod;
}

int main() {
    ll k, m; cin>>k>>m;
    for(int i=1; i<=m; ++i) {
        int j=i, t=0;
        while(1) {
            if(j^(j&-j)) t|=j&-j, j^=j&-j;
            else { ++t; break; }
        }
        ++f[t];
    }
    for(up=1; up<=m; up<<=1);
    FWT(f,1);
    g[0]=1; FWT(g,1);
    while(k) {
        if(k&1) mul(f,g,g);
        mul(f,f,f); k>>=1;
    }
    FWT(g,-1);
    ll ans=0;
    for(int i=1; i<up; ++i) (ans+=g[i])%=mod;
    cout<<ans<<endl;
}

---

## 作者：FutaRimeWoawaSete (赞：1)

首先先更正一个点，这道题是要求出有序的序列，而不是一个无序可重集。

考虑 $m$ 很小尝试使用 $O(m \log |V|)$ 级别的算法。

发现 $|V| = 1$ 的情况可以使用 SG 函数分析，而显然这是一个公平博弈问题，设序列 $(a_1,a_2,a_3,....a_n)$，则这一个组合状态产生的 SG 为 $SG(a_1) \bigoplus SG(a_2) \bigoplus ...... \bigoplus SG(a_n)$。

考虑打表 $O(m ^ 2)$ 求解 SG 函数，但是表还是太大了打不下来，经过观察我们可以发现 SG 函数存在一个规律，即 $SG(x) = x - 2 ^ {highbit(x)} + 1$，其中 $highbit(x)$ 表示 $x$ 最高的二进制位。

（严谨证明貌似其他两篇题解都提到，但是我的本质是打表就直接滑稽掉了。）

接着我们可以考虑 dp 求出 SG 函数为一个特定值时的序列数，记 $dp_{x,y}$ 为 $|V| = y$ 且 SG 函数为 $x$ 时的序列数，记 $g(x)$ 表示 SG 函数为 $x$ 的数字个数，则 $dp_{x,y} = \sum_{i \bigoplus j = x} dp_{i,y - 1} \times g(j)$。    

又由于初始时 $dp_{x,1} = g(x)$，所以这个东西可以用异或卷积的多项式快速幂优化。具体而言，我们先把多项式 $g(x)$ 的 FWT 求出来，设数字 $|V|$ 的二进制位为 $1$ 的位置为 $(b_1,b_2,b_3,......b_m)$，计算 $FWT ^ {2 ^ {b_1}} \times FWT ^ {2 ^ {b_2}} \times ...... FWT ^ {2 ^ {b_m}}$，这个显然对应位相乘就可以做到 $O(m \log |V|)$。

然后还原 FWT 后将除了 SG 为 $0$ 的方案都加上后就是答案了。

注意保证 $V$ 中的数在 $[1,m]$，所以 $g(0) = 0$。 

时间复杂度 $O(m (\log m + \log |V|))$。

```cpp
/*
假设 |V| = 1。
显然是一个公平博弈问题，可以套用 SG 函数 
首先考虑一个数不能被选择的条件是什么
x ^ y \in [0 , x),y != 0
打个表求一下 0,1,2,...... 的 sg 吧
记 x ^ y = z
那么就是 z ^ y = x
什么啊，不可能推导 SG 函数的过程都得写个卷积吧，那我不如打表。
SB 啊被演了。 
*/
#include "bits/stdc++.h"
using namespace std;
const int mod = 998244353 , Len = 2e6 + 5;
#define ll long long
int qpow(int a,int b)
{
	int res = 1;
	while(b)
	{
		if(b & 1) res = 1ll * res * a % mod;
		a = 1ll * a * a % mod;
		b = b >> 1;
	}
	return res;
}
const int Div = qpow(2 , mod - 2);
int n,m;
int A[Len],B[Len],a[Len],b[Len],F[Len];
void init(int *p,int *P,int N){for(int i = 0 ; i < N ; i ++) p[i] = P[i];}
void Mul(int *F,int *Q,int N){for(int i = 0 ; i < N ; i ++) F[i] = 1ll * F[i] * Q[i] % mod;}
void output(int *f,int N){for(int i = 0 ; i < N ; i ++) printf("%d ",f[i]);puts("");}
inline void MOD(int &x){if(x > mod) x -= mod;if(x < 0) x += mod;}
void XOR(int *f,int N,int fg)
{
	int A = 0 , B = 0;
	for(int o = 2 , k = 1 ; o <= N ; o <<= 1 , k <<= 1)
		for(int i = 0 ; i < N ; i += o)
			for(int j = 0 ; j < k ; j ++)
			{
				A = f[i + j] , B = f[i + j + k];
				f[i + j] = A + B;
				f[i + j + k] = A - B;
				MOD(f[i + j]) , MOD(f[i + j + k]);
				f[i + j] = 1ll * f[i + j] * fg % mod;
				f[i + j + k] = 1ll * f[i + j + k] * fg % mod;
			}
}
long long V;
int ans[Len];
void Work(ll b)
{
	while(b)
	{
		if(b & 1) for(int i = 0 ; i < n ; i ++) ans[i] = 1ll * ans[i] * F[i] % mod;
		for(int i = 0 ; i < n ; i ++) F[i] = 1ll * F[i] * F[i] % mod;
		b = b >> 1;
	}
	XOR(ans , n , Div);
	ll as = 0;
	for(int i = 1 ; i < n ; i ++) as += ans[i] , as %= mod;
	printf("%lld\n",as);
}
int main()
{
	scanf("%lld %d",&V,&m);
	n = 1;while(n <= m) n <<= 1;
	A[0] = 0;
	for(int i = 1 ; i < n ; i = i << 1)
		for(int j = 0 ; j < i ; j ++) A[j + i] = j + 1;
	for(int i = 0 ; i <= m ; i ++) B[A[i]] ++;
	B[0] = 0;
	init(a , B , n);XOR(a , n , 1);init(F , a , n);
	for(int i = 0 ; i < n ; i ++) ans[i] = 1;
	Work(V);
	return 0;
}
```

---

## 作者：Genius_Star (赞：0)

### 思路：

[**或许更好的阅读体验。**](https://www.cnblogs.com/rgw2010/p/18631656)

涉及到博弈论知识，注意到这个游戏对每个位置是相对独立的，于是考虑求出每个位置的 $SG$，然后算出所有 $SG$ 的异或和，若不为 $0$，则先手必胜。

考虑分讨算 $SG$ 值：

- 若 $x = 0$，显然 $SG(x) = 0$。

- 若 $x = 2^k$，那么 $y$ 只能选择 $2^k$，所以 $SG(2^k) = 1$。

- 若 $x = 2^k + p(0 \le p  < 2^k)$：

  - 若 $y = q(0 < q < 2^k)$，显然我们可以通过调整 $q$ 的每一个二进制位，使得 $x \oplus y$ 取遍 $[2^k, 2^k + p)$。
 
  - 若 $y = 2^k + q(0 < q \le q)$，那么 $x \oplus y = p \oplus q$，且要使得 $p \oplus q \le p$，故 $p \oplus q$ 的最高位为 $\lfloor \log_2(p) \rfloor$。
 
- 故考虑构造 $SG(x) = p + 1$，显然由于取遍了 $[2^k, 2^k + p)$，其 $\operatorname{MEX}$ 至少为 $p + 1$；又由于 $p \oplus q$ 的最高位为 $\lfloor \log_2(p) \rfloor$，故 $SG(p \oplus q) < 2^{\lfloor \log_2(p) \rfloor} \le p$。

- 综上 $SG(x) = p + 1$。

故若 $V$ 是先手必胜的，当且仅当 $\bigoplus\limits_{i = 1}^{|V|} SG(V_i) \ne 0$。

考虑动态规划算法，定义 $dp_{i, j}$ 表示 $|V| = i$ 且使得 $SG$ 异或和为 $j$ 的方案数，然后设 $g_i$ 表示 $\sum\limits_{j = 1}^m [SG(j) = i]$，那么转移方程是：

$$dp_i = dp_{i - 1} \oplus g$$

中间是异或卷积；考虑 $FWT$ 变换：

$$FWT(dp_i) = FWT(dp_{i - 1}) FWT(g)$$

这个乘法是按位相乘，故有：

$$FWT(dp_i) = FWT^i(g)$$

那么我们先求出 $FWT(g)$，然后每项更新为 $|V|$ 次方，然后再 $IFWT$ 逆变换即可。

时间复杂度为 $O(m \log m)$。

### 完整代码：

```cpp
 #include<bits/stdc++.h>
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define popcnt(x) __builtin_popcount(x)
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
using namespace std;
typedef __int128 __;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const int N = 2e6 + 10, M = 21, mod = 998244353;
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
namespace FWT{
	int inv2 = (mod + 1) >> 1;
	int pa[N], pb[N];
	inline void go(int *A, int *B, int n){
		for(int i = 0; i < n; ++i){
			pa[i] = A[i];
			pb[i] = B[i];
		}
	}
	inline void back(int *A, int *B, int n){
		for(int i = 0; i < n; ++i){
			A[i] = pa[i];
			B[i] = pb[i];
		}
	}
	inline void FWT_or(int *A, int n){
		for(int i = 1; i < n; i <<= 1)
		  for(int j = 0; j < n; j += (i << 1))
		    for(int k = 0; k < i; ++k)
		      A[i + j + k] = (A[i + j + k] + A[j + k]) % mod;
	}
	inline void IFWT_or(int *A, int n){
		for(int i = 1; i < n; i <<= 1)
		  for(int j = 0; j < n; j += (i << 1))
		    for(int k = 0; k < i; ++k)
		      A[i + j + k] = (A[i + j + k] + mod - A[j + k]) % mod;
	}
	inline void FWT_or(int *A, int *B, int n, int *ans, bool f = 0){
		if(f)
		  go(A, B, n);
		FWT_or(A, n), FWT_or(B, n);
		for(int i = 0; i < n; ++i)
		  ans[i] = 1ll * A[i] * B[i] % mod;
		IFWT_or(ans, n);
		if(f)
		  back(A, B, n);
	}
	inline void FWT_and(int *A, int n){
		for(int i = 1; i < n; i <<= 1)
		  for(int j = 0; j < n; j += (i << 1))
		    for(int k = 0; k < i; ++k)
		      A[j + k] = (A[j + k] + A[i + j + k]) % mod;
	}
	inline void IFWT_and(int *A, int n){
		for(int i = 1; i < n; i <<= 1)
		  for(int j = 0; j < n; j += (i << 1))
		    for(int k = 0; k < i; ++k)
		      A[j + k] = (A[j + k] + mod - A[i + j + k]) % mod;
	}
	inline void FWT_and(int *A, int *B, int n, int *ans, bool f = 0){
		if(f)
		  go(A, B, n);
		FWT_and(A, n), FWT_and(B, n);
		for(int i = 0; i < n; ++i)
		  ans[i] = 1ll * A[i] * B[i] % mod;
		IFWT_and(ans, n);
		if(f)
		  back(A, B, n);
	}
	inline void FWT_xor(int *A, int n){
		for(int i = 1; i < n; i <<= 1){
			for(int j = 0; j < n; j += (i << 1)){
				for(int k = 0; k < i; ++k){
					int x = A[j + k], y = A[i + j + k];
					A[j + k] = (x + y) % mod;
					A[i + j + k] = (x - y + mod) % mod;
				}
			}
		}
	}
	inline void IFWT_xor(int *A, int n){
		for(int i = 1; i < n; i <<= 1){
			for(int j = 0; j < n; j += (i << 1)){
				for(int k = 0; k < i; ++k){
					int x = A[j + k], y = A[i + j + k];
					A[j + k] = 1ll * (x + y) % mod * inv2 % mod;
					A[i + j + k] = 1ll * (x - y + mod) % mod * inv2 % mod;
				}
			}
		}
	}
	inline void FWT_xor(int *A, int *B, int n, int *ans, bool f = 0){
		if(f)
		  go(A, B, n);
		FWT_xor(A, n), FWT_xor(B, n);
		for(int i = 0; i < n; ++i)
		  ans[i] = 1ll * A[i] * B[i] % mod;
		IFWT_xor(ans, n);
		if(f)
		  back(A, B, n);
	}
};
int n, m, ans, base = 1;
int g[N];
inline int qpow(int a, int b){
	int ans = 1;
	while(b){
		if(b & 1)
		  ans = 1ll * ans * a % mod;
		a = 1ll * a * a % mod;
		b >>= 1;
	}
	return ans;
}
bool End;
int main(){
	n = read() % (mod - 1), m = read();
	while(base <= m)
	  base <<= 1;
	for(int i = 1; i <= m; ++i){
		for(int j = M - 1; j >= 0; --j){
			if((i >> j) & 1){
				++g[(i - (1 << j)) + 1];
				break;
			}
		}
	}
	FWT::FWT_xor(g, base);
	for(int i = 0; i < base; ++i)
	  g[i] = qpow(g[i], n);
	FWT::IFWT_xor(g, base);
	for(int i = 1; i < base; ++i)
	  ans = (ans + g[i]) % mod;
	write(ans);
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：WhisperingWillow (赞：0)

[Cnoi2019 人形演舞](https://www.luogu.com.cn/problem/P5387)

有结论 $\operatorname{SG}(i)=i-2^{\operatorname{highbit}(i)}+1$。


可以在 $\mathcal O(m\log m)$ 复杂度内求出所有 $\operatorname{SG}$ 值。

记 $c_i$ 表示 $\operatorname{SG}(j)=i$ 的个数。

选择 $i$ 个数使它们的异或和为 $j$ 的方案数记为 $f_{i,j}$，则有转移 $f_{i,j}=\sum_{a\operatorname{xor} b=j} c_bf_{i-1,a}$，答案即为 $\sum_{i=1} f_{|V|,i}$。

这样的话，发现每次都可以进行 FWT，但是效率不够优秀。

可以先 FWT 一次，做快速幂 $m$ 次，最后 FWT 回来即可。

这部分的时间复杂度为 $\mathcal O(m \log |V|)$。

综上，总的时间复杂度为 $\mathcal O(m \log m+m \log |V|)$。

[Submission](https://www.luogu.com.cn/record/160407959)

---


# 「EZEC-6」象棋

## 题目背景

> 万籁停吹奏
$\newline$支颐听秋水问蜉蝣
$\newline$既玄冥不可量北斗
$\newline$却何信相思最温柔


## 题目描述

象棋将会由两个玩家进行游玩，其中红方为先手，黑方为后手。象棋里有很多种棋子，PF 对其中的“炮”情有独钟，炮的操作为：如果任意一方的某个炮和对方的某个炮之间的位置上**有且仅有一个炮**，那么这一方可以将对方的炮移出棋盘，并将他的炮移到对方的炮的位置。

PF 厌倦了传统象棋的玩法，因此他拿出了一张 $1$ 行 $n$ 列的棋盘。棋盘上的每个位置都有且仅有一个炮，每个炮都隶属于红方或黑方。对于每个回合，操作方可以进行一次操作，也可以不进行操作，然后将操作权交给对手。若双方均同意结束或者无棋可动，游戏结束。


游戏将进行 $T$ 局。每一局 PF 都是红方。定义游戏的胜利条件为一方的剩余的炮的数量大于对方。他想知道，若双方均使用最佳策略，他是否有必胜策略。

## 说明/提示

**由于本题输入量较大，请使用较快的读入方法。**

**【数据范围】**

**本题采用捆绑测试。**

|子任务编号|$T\le$|$n\le$|$\sum n\le$|分值|
|:-:|:-:|:-:|:-:|:-:|
|$1$|$20$|$3$|$60$|$5$|
|$2$|$10^3$|$6$|$6\times10^3$|$10$|
|$3$|$10^5$|$15$|$1.5\times10^6$|$15$|
|$4$|$200$|$200$|$500$|$20$|
|$5$|$10^5$|$10^6$|$2\times10^6$|$25$|
|$6$|$10^5$|$10^7$|$2\times10^7$|$25$|

对于 $100\%$ 的数据， $1\le T \le 10^5$，$1 \le n \le 10^7$，$\sum n \le 2\times 10^7$，$a \in \{0,1\}$。

**【样例解释】**

对于第一组数据，没有任何棋子能够移动，而棋面红棋子数大于黑棋，故先手有必胜策略。

对于第二组数据，一种平局的变化如下：

```cpp
0 1 1* 0 0*
0 1 0 1
```	

对于第三组数据，双方的最佳策略有如下两种可能：
```cpp
0 1 1* 1 0*
0* 1 1* 1
1 0 1
```

```cpp
0* 1 1* 1 0
1 1* 1 0*
1 0 1
```
两种结果均为红炮剩余数量多，故红棋必胜。

对于第四组数据，红棋只有一种操作可行：

```cpp
1* 0 0* 0
0 1 0
```
无棋可走后黑炮数量更多。



## 样例 #1

### 输入

```
4
3
101
5
01100
5
01110
4
1000```

### 输出

```
WIN
TIE
WIN
LOSE```

# 题解

## 作者：pocafup (赞：10)

**P0:题外话**


这题的原身是不存在博弈的，仅仅是给一个开局，问是否能够操作使得最后只剩两个棋子。但是我觉得博弈可做，于是在群上发了问，结果被神仙 @[Forever_Pursuit](/user/101800) 搞出来了。

然后还是第一次有人帮我做数据，验题和推广，之前出的题基本上都是我自己出自己验的，果然有神仙在团内就是不一样/cy 

------------
**P1：基础观察**

首先需要证明两个结论

1. **如果当前局面下红方可以操作，那么黑方必然也可以，反之亦然。**

证明：一个可操作的局面仅有以下几种可能。
```cpp
() 100 ()
() 001 ()
() 011 ()
() 110 ()
```
其中 () 表示任意数量的棋子。

可以发现，在这四种状态下红黑双方均能行动，故命题得证。

由此引出下一个结论：

2. **如果当前局面可操作，那么选择操作严格不劣于不操作。**

证明：

由于每个操作都只会改变减少对方棋子的数量，而若一方能操作另一方也能操作，那么可以得出若一方不操作，让另一方操作只会减少自己的棋子数量，且不会影响对方之后的操作。故命题得证

------------
**P2：题解**

对于 $n\le3$ 的数据，出题人良心的给了不会博弈论手动模拟的同学分数，手动模拟后打表输出即可。


------------
对于 $n\le6$ 的数据，考虑爆搜。

暴力 dfs 寻找每一种可能。假设在某个状态下由红方行动，而他的操作会使黑方必败，则红方有必胜策略。若有平局状态，则红方可以选择平局
，否则当前状态红方必败。（黑方同理）

暴力复杂度 $O(n(n!)^2)$，足够通过。

------------
对于 $n\le 15$ 的数据，考虑状压打表。

思路跟dfs一样，只不过用二进制记录状态，$O(n^2\times2^n)$ 打表后 $O(1)$ 询问，足以通过。

------------
**接下来开始讲正解思路**

由于之前证明的结论，我们可以得出，**若红方初始棋子数量大于黑方，那么红方必胜。**

同理，**若红方初始棋子数量小于黑方棋子-1，那么红方必败。**

现在仅有两种情况需要讨论：
1. 红棋数量=黑棋数量 
2. 红棋数量=黑棋数量-1

首先讨论第一种情况：

通过基础观察，我们可以发现若红棋数量=黑棋数量，红棋只可能胜利或者平局。红棋胜利的可能仅有一个：当某一步红棋走完后，黑棋无法再次行动。

考虑什么时候会出现这种情况：
定义 () 集合为一组数字出现任意次数，例如 `(101)` 可能为 `101101`，也可能是空集。
对于一个不能动的情况，由于红棋数量大于黑棋，故最后局面必然是 `(10)1` 这一种情况。

发现仅有两种情况能够转移得到这种情况：

`(10)1100(01) `$\newline$
`(10)0011(01)`

由于这两种状态仅仅是 `01` 的位置反了过来，故我们可以认为他们等价，下面仅对第一种情况进行讨论。

继续考虑，发现仅有以下几种情况能得到上述情况：

`(10)11100(01)`$\newline$
`(10)11001(01)`$\newline$
`(10)10110(01)`

由于初始棋子数量相等，而括号内棋子数量也平衡。根据初始证明，可以得出在出现这种状况时必然轮到黑方操作。

可以发现，对于上述每一种状态，黑棋必然能够使用最佳策略避开必输局面。故如果在这种情况下轮到黑方操作，双方必然平手。

对于这种情况，红方仅有一种赢的可能：当 `(10)1100(01)` 或 `(10)0011(01)` 为初始局面。

结论：**如果初始局面可以通过一次转移为不可操作局面，则红方必胜，否则必然平手。**

接下来讨论第二种情况：

若红棋数量=黑棋数量-1，如果对上面的证明进行分析，那么我们可以发现此时红方的处境等价于黑方的处境。

结论：**若初始局面为可操作局面，则必然平局，否则红方必败。**

**正解证明完成，开始讨论做法**

------------
对于 $n\le 200$ 的数据，考虑在红棋=黑棋时暴力枚举每个位置进行操作后判断是否为不可动局面，复杂度 $O(\sum n^2)$

由于出题人不确定有没有 $O(n^3)$ 做法，而其他做法的复杂度显然过不去这个，故 $n$ 只开到了 $200$。

------------
对于 $n \le 10^6$ 的数据，考虑暴力上随机化。

发现若有一个位置能够使得变化和局面可操作，则继续判断无意义。

故对于红棋=黑棋时仍然暴力枚举，但是枚举时随机跳位置检索是否不可操作。

复杂度不太会证，但实际效果优秀，可以过 $n\le 10^6$ 的数据。


------------
对于 $n \le 10^7$ 的数据，考虑移动一步后出现平局的可能状态。

上面已经讲过，仅存在 `(10)0011(01)` 和 `(10)1100(01)` 两种可能。故我们可以判断数组是否为这种情况，具体写法将在代码中给出。

复杂度 $O(\sum n$)

```cpp

const int MAXN = 1e7+5;
const int MAXM = 1e5+5;
const int mod = 1e9+7;
int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};
int n,m,t,pos[MAXN],k,a,b,c,red,black;
inline void case1(){
  int pivot = 0,ab = 0;
  For(i,1,n-1)
    if(pos[i]==pos[i+1]) {
      if (pivot && pos[i]==1) {puts("TIE");return;}
      else if (pos[i]==1) pivot = i;
      if (pos[i]==0) ab++;
    }
  if (!pivot) {puts("TIE");return;}
  if ((pivot == 3 && pos[1] == pos[2]) || (pivot == n-3 && pos[n-1] == pos[n])) {puts("WIN");return;}
  if (ab == 2 && ((pivot > 3 && !pos[pivot-1] && !pos[pivot-2] && !pos[pivot-3]) ||
      (pivot<=n-4 && !pos[pivot+2] &&!pos[pivot+3] &&  !pos[pivot+4]))) {puts("WIN");return;}
  puts("TIE");
}
inline void case2(){
  For(i,1,n-1) if (pos[i]==pos[i+1]) {puts("TIE");return;}
  puts("LOSE");
}
signed main(){
  t = read();pos[0] = -1;
  while(t--){
    n = read();pos[n+1] = pos[n+2] = pos[n+3] = -1;
    red = 0;
    For(i,1,n) pos[i] = (get()=='1'),red+=(pos[i]==1);
    black = n-red;
    if (red>black) puts("WIN");
    else if (red<=black-2) puts("LOSE");
    else if (red==black) case1();
    else case2();
  }
}
```

---

## 作者：vectorwyx (赞：8)

视 $1$ 为先手的棋子，$0$ 为后手的棋子。首先进行一些简单的分析：

* 如果一个位置空出来了，之后不可能有棋子挪到这个位置上，直接删除即可。那么相当于每次操作棋盘大小都会减 $1$，同时每个位置上都有一枚棋子。
* 操作是双向的，即只要存在 $(i,i+2)$ 满足 $a_i\not=a_{i+2}$ 先手或后手都可以进行操作。所以最终局面一定是 $01$ 交替，此时先手后手均无法进行操作。
* 每一方操作时都会使对方的棋子数减 $1$，所以如果进行了偶数个回合，双方的棋子数之差与初始时相同；否则先手会“多”一枚棋子。假设初始时先手有 $A$ 枚棋子，后手有 $B$ 枚，如果 $A>B$ 则先手必胜，如果 $A<B-1$ 则先手必败。不平凡的情况只有 $A=B-1$ 或 $A=B$，此时的关键在于先手能否多进行一次操作，那么可以认为谁最终导致了 $01$ 交替的局面谁就“赢”了。

先来看 $A=B-1$ 的情况，我们称一个局面是“难过的”，当且仅当后手在这个局面下可以通过一次操作导向最终局面。记 $(S)$ 表示将字符串 S 重复若干遍（可以不重复，此时为空），不难看出“难过的”局面一定形如：$(10)T(01)$，其中 $T=1100$ 或 $0011$。现在我们断言，如果当前局面并非最终局面，先手总可以通过一次操作使后继局面不是“难过的”局面。

> 这其实也是为什么选择从 $A=B-1$ 而非 $A=B$ 入手，因为 $A=B$ 时“难过的”局面的形式有四种可能，而且并不整齐。这个解释可能很牵强，但是我也找不到更好的解释QAQ

证明考虑分类讨论：

* 如果当前局面存在一个子串是 $T$，不妨设 $T=1100$，此时如果 $T$ 右边没有棋子或者右边的棋子是 $1$，只需要将 $T$ 变为 $110$，不管怎样 $110$ 做结尾或 $1101$ 作为子串都不可能是“难过的”局面。而如果 $T$ 右边是 $0$，假设在将 $T$ 变为 $110$ 后得到了一个“难过的”局面，这意味着 $T$ 左边是 $(10)$，右边是 $0(01)$，这种情况下只需要将 $T$ 改为 $101$，得到的局面为 $(10)(01)$，就避免了“难过的”局面。
* 如果当前局面不存在子串是 $T$，在一次操作后得到“难过的”局面的必要条件是新产生了一个子串为 $T$。这个时候只需要考察所有长度小于等于 $6$ 的子串，可以写个程序对每一种可能暴力验证：

```cpp
#include<bits/stdc++.h>
#define fo(i,x,y) for(int i=(x);i<=(y);++i)
#define go(i,x,y) for(int i=(x);i>=(y);--i)
#define re return
using namespace std;
inline void out(int *a,int l,int r){fo(i,l,r) cout<<*(a+i)<<' ';puts("");}

int bit[10],ct,tmp[10],n=6;

bool chk(int l,int r){
	fo(i,l,r-3){
		if(bit[i]=='0'&&bit[i+1]=='0'&&bit[i+2]=='1'&&bit[i+3]=='1') re 0;
		if(bit[i]=='1'&&bit[i+1]=='1'&&bit[i+2]=='0'&&bit[i+3]=='0') re 0;
	}
	re 1;
}

signed main(){
	fo(i,0,(1<<n)-1){
		ct=0;
		fo(j,0,n-1) tmp[j]=bit[j]=i>>j&1;
		bool fl=0;
		fo(j,0,n-3) if(bit[j]&&!bit[j+2]){
			bit[j+2]=1;
			go(k,j,1) bit[k]=bit[k-1];
			fl|=chk(1,n-1);
			fo(k,0,n-1) bit[k]=tmp[k];
		}
		fo(j,0,n-3) if(!bit[j]&&bit[j+2]){
			bit[j]=1;
			fo(k,j+2,n-2) bit[k]=bit[k+1];
			fl|=chk(0,n-2);
			fo(k,0,n-1) bit[k]=tmp[k];
		}
		if(!fl){
			cout<<i<<":";out(tmp,0,n-1);
		}
	}
	return 0;
}
```

那么对于 $A=B-1$ 的情况，如果当前局面是最终局面则先手输，否则平局（因为先手不可能留给后手终结游戏的机会）。

对于 $A=B$ 的情况，在先手进行一次操作后把先后手互换就变成了 $A=B-1$ 的情况。由上可知，如果当前局面为最终局面则平局；如果当前局面是先手视角下的“难过的”局面则先手胜；否则平局。

代码如下（码字不易，希望能给个赞QAQ）：

```cpp
#include<bits/stdc++.h>
namespace vectorwyx{
#define pii pair<int,int>
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define mk make_pair
#define sml(x,y) (x=min(x,y))
#define big(x,y) (x=max(x,y))
#define ll long long
#define uint unsigned
#define ull unsigned long long
#define umap unordered_map
#define db double
#define fo(i,x,y) for(int i=(x);i<=(y);++i)
#define go(i,x,y) for(int i=(x);i>=(y);--i)
#define ptc putchar
#define emp emplace
#define re return
#define co continue
#define brk break
#define HH (ptc('\n'))
#define bctz __builtin_ctz
#define bclz __builtin_clz
#define bppc __builtin_popcount
using namespace std;
ll seed=chrono::system_clock::now().time_since_epoch().count();
mt19937 rnd(seed);
inline int rm(int x,int y){return (int)(rnd()%(y-x+1ll)+x);}
inline int read(){signed ch=getchar();int x=0,f=1;while(!isdigit(ch)){if(ch==(int)('-'))f=-1;ch=getchar();}while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*f;}
inline void out(int *a,int l,int r){fo(i,l,r) cout<<*(a+i)<<' ';puts("");}

const int N=1e7+5;
int a[N],n; 

void solve(){
	cin>>n;a[n+1]=0;
	n=0;
	signed ch=getchar();while(!isdigit(ch)) ch=getchar();
	while(isdigit(ch)) a[++n]=ch=='1',ch=getchar();
	int A=0,B=0;
	fo(i,1,n){
		if(a[i]) A++;
		else B++;
	}
	#define W {puts("WIN");re;}
	#define L {puts("LOSE");re;}
	#define T {puts("TIE");re;}
	if(A>B) W;
	if(A<B-1) L;
	if(A==B-1){
		fo(i,1,n-1) if(a[i]==a[i+1]) T;
		L;
	}
	if(!a[1]){
		if(n<4) T;
		if(a[1]==0&&a[2]==0&&a[3]==1&&a[4]==1){
			if(a[5]) T;
			fo(i,6,n) if(a[i]==a[i-1]) T;
			W;
		}
		T;
	}
	fo(i,1,n-3){
		if(i>1&&a[i-1]==a[i-2]) T;
		if((i-1)&1) co;
		if((a[i]==1&&a[i+1]==1&&a[i+2]==0&&a[i+3]==0)||(a[i]==0&&a[i+1]==0&&a[i+2]==1&&a[i+3]==1)){
			if(a[i+4]) T; 
			fo(j,i+5,n) if(a[j]==a[j-1]) T;
			W;
		}
	}
	T;
}

signed main(){
	int t=read();
	while(t--) solve();
	return 0;
}
}
/*
-------------------------------------------------
*/










signed main(){re vectorwyx::main();}
```



---


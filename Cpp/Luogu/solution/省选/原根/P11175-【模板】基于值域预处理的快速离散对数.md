# 【模板】基于值域预处理的快速离散对数

## 题目背景

模板题，无背景。

## 题目描述

给定质数 $P$ 以及它的一个原根 $g$。

有 $q$ 组询问，每组询问给出整数 $y$，你需要找到最小的非负整数 $x$ 使得 $g^x\equiv y\pmod P$。

## 说明/提示

### 数据范围及约束

- 对于前 $15\%$ 的数据，满足 $1\le g < P\le 100$，$1\le q\le 100$；
- 对于前 $30\%$ 的数据，满足 $1\le g < P\le 10^9+7$，$1\le q\le 100$；
- 另有 $15\%$ 的数据，满足 $y_i=i$；
- 另有 $15\%$ 的数据，满足 $P=998244353$，$g=3$；
- 对于全部数据，满足 $1\le g,y_i<P\le 10^9+7$，$1\le q\le 5\times 10^5$。

请注意读入效率对程序运行速度的影响。

## 样例 #1

### 输入

```
998244353 3
9
1
11
111
1111
11111
111111
1111111
11111111
111111111```

### 输出

```
0
258630203
771331691
346105458
268271589
571255383
916731589
304666893
915484870```

## 样例 #2

### 输入

```
1000000007 5
13
1
5
25
125
625
3125
15625
78125
390625
1953125
9765625
48828125
244140625```

### 输出

```
0
1
2
3
4
5
6
7
8
9
10
11
12```

# 题解

## 作者：离散小波变换° (赞：17)

前段时间做区域赛题碰到几个可以用离散对数转换成卷积的题，发现需要对 $1\sim n$ 求出离散对数。发现还不会这个科技，所以学习一下。

## 思路

记 $\log n$ 表示 $n$ 在模 $P$ 意义下以 $g$ 为原根的离散对数。

先解决求出 $1\sim n$ 内每个数离散对数值的问题。

容易发现 $\log ab=\log a+\log b$。假如我们要求出 $\log i,\ i=1,2,\cdots,n$，可以利用筛法，这样只需要求出 $\pi(n)$ 个素数处的离散对数值即可，其中 $\pi(n)$ 表示 $n$ 以内素数个数。

求解一个数的离散对数，通常使用大步小步算法（BSGS）。记 $x=\log y=Bi+j \in [0, P)$，其中 $0\le j<B,0\le i\le \lfloor (P-1)/B\rfloor$。那么有：

$$
\begin{aligned}
g^{Bi+j} &\equiv y &\pmod P \\
g^{j} &\equiv y\times g^{-Bi} &\pmod P \\
\end{aligned}
$$

所以我们枚举 $j=0,1,\cdots,B-1$，把 $g^j$ 插入哈希表里，接着枚举 $i=0,1,\cdots$，查询哈希表里有没有对应的 $j$ 即可。复杂度为 $\mathcal O(B+P/B)$，通常取 $B=\sqrt P$ 使得总复杂度为 $\mathcal O(\sqrt P)$。

然而我们这次一共要对 $\pi(n)$ 个数字求离散对数。事实上，我们向哈希表里插入元素的复杂度为 $\mathcal O(B)$，查询的复杂度为 $\mathcal O(\pi(n)P/B)$，其实取 $B=\sqrt{P\pi(n)}$ 才取得最优复杂度。这一步值得注意，有些复杂度错误的批量求解离散对数的做法就是块长取错了。

现在我们要多次询问 $y\in [1, P)$ 的离散对数。有一个小技巧：

先预处理出 $\sqrt{P} + 1$ 内所有数的离散对数。对于每次询问，若 $y\le \sqrt P + 1$ 则直接回答，否则设 $P=vy+r$，其中 $0\le r< y$ 且 $0\le v \le \sqrt P$。

根据 $P=vy+r$ 可知 $y=(P-r)/v$，从而得到：

$$\log y \equiv \log(-r)-\log v\equiv \log(P-1)+\log r-\log v$$

根据 $P=(v+1)y+r-y$ 可知 $y=(P+y-r)/(v+1)$，从而得到：

$$\log y\equiv \log(y-r)-\log(v+1)$$

其中 $\log v$ 或是 $\log (v+1)$ 都可直接查表获得。由于 $\min(r, y-r)\le y/2$，所以每次迭代都能使得 $y$ 的规模减半，直到 $y\le \sqrt{P}+1$ 查表回答。

于是我们得到了一个 $\mathcal O(P^{0.75}/ \log^{0.5} P)$ 复杂度预处理，$\mathcal O(\log P)$ 回答单次询问的做法。

## 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int power(int a, int b, int  p){
    int r = 1;
    while(b){
        if(b & 1) r = 1ll * r * a % p;
        b >>= 1,  a = 1ll * a * a % p;
    }
    return r;
}
namespace BSGS {
    unordered_map <int, int> M;
    int B, U, P, g;
    void init(int g, int P0, int B0){
        M.clear();
        B = B0;
        P = P0;
        U = power(power(g, B, P), P - 2, P);
        int w = 1;
        for(int i = 0;i < B;++ i){
            M[w] = i;
            w = 1ll * w * g % P;
        }
    }
    int solve(int y){
        int w = y;
        for(int i = 0;i <= P / B;++ i){
            if(M.count(w)){
                return i * B + M[w];
            }
            w = 1ll * w * U % P;
        }
        return -1;
    }
}

const int MAXN = 1e7 + 3;
int H[MAXN], P[MAXN], H0, p, h, g, mod;
bool V[MAXN];

int solve(int x){
    if(x <= h){
        return H[x];
    }
    int v = mod / x, r = mod % x;
    if(r < x - r){
        return ((H0 + solve(r)) % (mod - 1) - H[v] + mod - 1) % (mod - 1);
    } else {
        return (solve(x - r) - H[v + 1] + mod - 1) % (mod - 1);
    }
}

int main(){
    ios :: sync_with_stdio(false);
    cin.tie(nullptr);
    
    int T;
    cin >> mod >> g;
    h = sqrt(mod) + 1;

    BSGS :: init(g, mod, sqrt(1ll * mod * sqrt(mod) / log(mod)));
    H0 = BSGS :: solve(mod - 1);

    H[1] = 0;
    for(int i = 2;i <= h;++ i){
        if(!V[i]){
            P[++ p] = i;
            H[i] = BSGS :: solve(i);
        }
        for(int j = 1;j <= p && P[j] <= h / i;++ j){
            int &p = P[j];
            H[i * p] = (H[i] + H[p]) % (mod - 1);
            V[i * p] = true;
            if(i % p == 0)
                break;
        }
    }

    cin >> T;
    while(T --){
        int x, tmp = 0;
        cin >> x;
        cout << solve(x) << "\n";
    }
    return 0;
}
```

Bonus：对于 NTT 模数存在更加优秀的做法，但我太懒了还没学，欢迎大家在题解区补充。

---

## 作者：飞雨烟雁 (赞：12)

**声明**：本算法参考了这两篇 Blog：[Index Calculus 算法](https://www.luogu.com.cn/blog/Leasier/Index-Calculus)，[P7890题解](https://www.luogu.com.cn/blog/wky/p7890-ti-xie)。

------------

**题目链接**：[P11175 【模板】基于值域预处理的快速离散对数
](https://www.luogu.com.cn/problem/P11175)

**题目描述**：给定质数 $p$ 及其原根 $g$，设 $\log k$ 是方程 $g^{x}\equiv k\pmod p$ 的最小自然数解，请对 $q$ 组询问分别给出其 $\log$ 值。

**数据范围**：$p\le 10^9+7,q\le 5\times 10^5$。


------------

### 〇、算法综述

这个算法结合了 BSGS 算法和 index calculus 算法，在预处理阶段求出了 $\log 1,\cdots,\log n$ 的值，并在询问阶段通过递推式在期望 $\mathcal O(\log (x/n))$ 的时间内给出答案。总体效率优于 BSGS 算法，但实现较为复杂。

---



### 一、算法流程简述

0. 记 $S=\lfloor \sqrt p\rfloor$，选定阈值 $m,n$；

1. 线性筛出 $1\sim n$ 的所有质数；

2. 利用 BSGS 求出 $1\sim m$ 内所有质数的 $\log$ 值；

3. 利用 index calculus 求出 $m+1\sim S$ 内的所有质数的 $\log$ 值；

4. 线性筛出 $1\sim S$ 内所有整数的 $\log$ 值；

5. 从小到大枚举 $S+1\sim n$ 的所有整数，用递推式求其 $\log$ 值。预处理阶段结束；

6. 在询问阶段，对于每个 $x$，我们通过递推式递归求解 $\log x$。

------------

### 二、各个流程详解

+ **Step 2. BSGS 详解**：

若 BSGS 初始化的时间复杂度为 $\mathcal O(B)$，则每次询问的时间复杂度是 $\mathcal O(\frac pB)$，共有 $\mathcal O(\frac m{\ln m})$ 次询问。那么总复杂度为 $\mathcal O(B+\frac{pm}{B\ln m})$，取 $B$ 等于 $\mathcal O(\sqrt \frac {pm}{\ln m})$，最终复杂度为 $\mathcal O(\sqrt \frac{pm}{\ln m})$。

+ **Step 3. index calculus 详解**：

记需要求 $\log$ 值的那个质数为 $x$，从小到大枚举（或随机化）正整数 $\alpha$，判断 $(xg^\alpha)\bmod p$ 的最大质因数是否小于等于 $m$。若是，记 $y=(xg^\alpha)\bmod p$，求出 $y$ 的标准分解式，那么 $\log x+\alpha\equiv \log y\equiv \sum_{p^k||y}k\log p\pmod {\varphi(p)}$。若否，继续枚举 $\alpha$。

+ **Step 4. 线性筛详解**：

因为 $\log$ 是完全加性函数，所以可用 $\log (ab)=\log a+
\log b$ 计算。

+ **Step 5. 递推式求法详解**：

对等式 $x\lfloor\frac px\rfloor=p-p\bmod x$ 两边加上 $x$ 后在模意义下取对数即得：$\log x\equiv \log (x-p\bmod x)-\log(\lfloor\frac px\rfloor+1)\pmod {\varphi(p)}$，直接用这条公式 $O(1)$ 递推即可。

+ **Step 6. 递归详解**：

依据 $\log x\equiv \log (x-p\bmod x)-\log(\lfloor\frac px\rfloor+1)\pmod {\varphi(p)}$ 递归计算即可，当 $x\le n$ 时返回预处理的值。

+ **Step 0. $m$ 的选择及时间复杂度分析**：

阈值 $m,n$ 的选择与个人各部分实现的常数有关。当 $n=10^6$ 时，我选择 $m\approx 800$。

总时间复杂度我不会算（主要是 Step 3）。根据 esquigybcu 的评论，预处理阶段的时间复杂度为 $\mathcal O(n+\pi(m) \sqrt p \exp((1+o(1)) u \log u))$，其中 $u=\log_mp$（在此感谢 ta 的结论）。而在询问阶段，每次递归 $x$ 的期望减半，直至 $x\le n$，故期望时间复杂度为 $\mathcal O(q\log(p/n) )$。

------------

### 三、算法优劣分析

相较于完整的 index calculus 算法，本算法将高斯消元换成了 BSGS，让代码好写的同时却降低了效率。相较于另一个求离散对数的方法，本算法通过 Step 3 减少了 BSGS 询问次数，牺牲了原本简短的代码，换来了效率。**无论从效率还是从实现难易度上看，本算法都位于两者之间。**

------------

### 四、部分可能的优化

+ Step 3 可视情况决定是否用光速幂加速；

+ Step 3 枚举 $\alpha$ 时可以每次自增 $4$ 或大于 $4$；

+ Step 5 可对质数用递推式，对合数用 $\log$ 完全加性函数性质计算；

+ 根据实际情况，Step 5 也许可以去掉，即令 $n=S$；

+ 如果有人想从 Step 6 的递归来卡掉期望复杂度的话，可以尝试记忆化，这样就卡不掉了；

+ 这个算法对于过小的 $p$ 值可能会有死循环等预料之外的情况，此时暴力计算即可。

------------

### 五、代码实现


```cpp
#include <ext/pb_ds/assoc_container.hpp>
#include <algorithm>
#include <iostream>
#include <cstring>
#include <bitset>
#include <random>
#include <cstdio>
#include <cmath>
#include <ctime>
#define ll long long
#define uint unsigned int
using namespace std;
using namespace __gnu_pbds;

inline int Read(){
    int res = 0; char c = getchar();
    while(c < '0' || c > '9') c = getchar();
    while(c >= '0' && c <= '9') res = res * 10 + (c ^ 48), c = getchar();
    return res;
}
inline void Write(int x){ if(x > 9) Write(x / 10); putchar(48 ^ (x % 10));}

const int Mx = 1e6 + 1, Nx = 13970040;
const double K = 0.35;
const int M = 750; int P;
int Mod, Nod, Prt; // Prt 是原根 
int SM, PM;

inline int FastPow(ll a, int b){
	int res = 1;
	while(b){
		if(b & 1) res = res * a % Mod;
		b >>= 1, a = a * a % Mod;
	}
	return res;
}

inline uint Reduce(int x){ return x < 0 ? x + Nod : x;} // 负转正 
inline uint Adduce(uint x, uint y){ x += y; return x < Nod ? x : x - Nod;} // 加法取模优化 

int Prime[78500], tot, Miu[Mx];
uint LOG[Mx];

gp_hash_table<int, int> Rec;

inline void BSGS(){
	/* PART 1 */ 
	int A = ceil(K * sqrt(1ll * P * Mod));
	int B = ceil(1.0 * Mod / A); A *= B;
	int tmp = FastPow(Prt, B), prod = 1;
	/* PART 2 BSGS 预处理 */ 
	Rec.clear();
	for(int i = 0; i <= A; ) Rec[prod = 1ll * prod * tmp % Mod] = (i += B);
	/* PART 3 求小于等于 M 的质数的离散对数 */ 
	for(int i(1); i <= P; ++i){
		prod = Prime[i];
		for(int j(0); j < B; ++j){
			if(Rec.find(prod) != Rec.end()){
				LOG[Prime[i]] = (Rec[prod] - j) % Nod;
				break;
			}
			prod = 1ll * prod * Prt % Mod;
		}
	}
}

int POW1[44750], POW2[44750];
void LightPow_Init(){ // 原根的光速幂预处理 
	POW1[0] = POW2[0] = 1;
	int sp1 = Prt, sp2 = FastPow(Prt, SM);
	for(int i = 1; i < SM; ++i) POW1[i] = 1ll * POW1[i - 1] * sp1 % Mod, POW2[i] = 1ll * POW2[i - 1] * sp2 % Mod;
}
inline int LightPow(int k){ return 1ll * POW1[k % SM] * POW2[k / SM] % Mod;}

mt19937 rnd(time(NULL));

int Tim[432]; // 50 > P
inline int Incalus(int n){ // Solve Prt ^ x = n (mod Mod), return x 
	int x = (rnd() & 127) + 4, Px = 1ll * n * LightPow(x) % Mod, top;
	while(1){
		int tmp = Px; top = 0;
		for(int i = 1; i <= P && tmp > 1; ++i){
			Tim[i] = 0, ++top;
			while(tmp % Prime[i] == 0) ++Tim[i], tmp /= Prime[i];
		}
		if(tmp == 1) break;
		++x, Px = 1ll * Px * Prt % Mod;
	}
	int Res = -x;
	for(int i = 1; i <= top; ++i) Res = (Res + 1ll * Tim[i] * LOG[Prime[i]]) % Nod;
	return Reduce(Res);
}

inline ll GetLog(int x){ return x > SM ? GetLog(x - Mod % x) - LOG[Mod / x + 1] : LOG[x];}
void Discrete_Logarithm_Init(){
	/* PART 1 线性筛，筛质数和 miu 值 */
	bitset <1000001> Vis;
	Miu[1] = 1;
	for(int i(2); i < Mx; ++i){
		if(!Vis[i]) Prime[++tot] = i, Miu[i] = -1;
		for(int j(1); j <= tot && Prime[j] * i < Mx; ++j){
			Vis[i * Prime[j]] = true;
			if(i % Prime[j] == 0) break;
			Miu[i * Prime[j]] = -Miu[i];
		}
	}
	/* PART 2 求出小于等于 M 的质数的离散对数 */
	SM = ceil(sqrt(Mod));
	PM = (upper_bound(Prime + 1, Prime + tot + 1, SM) - Prime) - 1;
	P = (upper_bound(Prime + 1, Prime + 1 + tot, M) - Prime) - 1;
	LightPow_Init();
	BSGS();
	/* PART 3 求出大于 M 且小于等于 N 的质数的离散对数 */
	for(int i = P + 1; i <= PM; ++i) LOG[Prime[i]] = Incalus(Prime[i]);
	/* PART 4 求出最大质因数小于等于 sqrt(Mod) 的合数的离散对数 */
	Vis.reset(); int SMX = Mx >> 1;
	for(int i(2); i <= SMX; ++i) for(int j(1); i * Prime[j] < Mx && j <= PM; ++j){
		LOG[i * Prime[j]] = Adduce(LOG[i], LOG[Prime[j]]);
		if(i % Prime[j] == 0) break;
	}
	/* PART 5 求出大于 sqrt(Mod) 的质数的离散对数 和 最大质因数大于 sqrt(Mod) 的合数的离散对数 */
	for(int i = PM + 1, p; i <= tot; ++i){
		p = Prime[i], LOG[p] = Reduce(GetLog(p) % Nod);
		for(int j = 2, k = p << 1; k < Mx; ++j, k += p) LOG[k] = Adduce(LOG[j], LOG[p]);
	}
}

int Query(int x){
	if(x < Mx) return LOG[x];
	return Adduce(Query(x - Mod % x), Nod - LOG[Mod / x + 1]);
}

int main(){
	Nod = (Mod = Read()) - 1, Prt = Read(); 
	if(Mod < Mx){
		int prd = 1;
		for(int i = 0; i < Nod; ++i){
			LOG[prd] = i;
			prd = 1ll * prd * Prt % Mod;
		}
	}
	else Discrete_Logarithm_Init();
	int T = Read(); 
	while(T--){
		int k = Read();
		Write(Query(k));
		puts("");
	}
	return 0;
}
```

---

## 作者：Doqe (赞：4)

大家好，我很喜欢 BSGS，所以我用 BSGS 过了这道题。

BSGS 的流程是，建立哈希表存储 $g^{i}\quad(0\le i<B)$，对于询问 $x$，枚举 $j$ 直到 $xg^{Bj}=g^{i}$，即在哈希表内，那么区区小 $t$（$x=g^t$）就出来了。

其中预处理只需要区区 $B$ 次，查询至多 $\frac{qP}{B}$ 次。使用均值不等式得出 $O(\sqrt{Pq})$ 的复杂度，带个区区 $2$ 的小常熟。计算一下区区 $(2\times)2\times 10^7$，区区 $10^8$ 以内竟然过不去。

问题出在哈希表和乘法，区区乘法套路使用 Barret 即可。使用若干策略来降低哈希表常数：
- 首先注意到哈希表的数是 $[0,P)$ 的整数，不妨使用 $\frac P8$ 个字节开一个长度为 $P$ 的 `bitset`，区区两百 MB。  
  这样的好处是：我们每次询问真正只有一次访问大常数的哈希表。  
  可以给块长 $B$ 配点常数因子。
- 注意到 $g^i$ 看起来非常随机的样子，我们宣称区区出题人完全防不了乱来。  
  哈希表直接简单粗暴的对于后 $x$ 位相同的键值开个 `vector` 存一下即可。
  这样区区插入常数小到离谱，查找区区查找 $q$ 次，常数多大都完全不慌。

本地跑一下发现随随便便进 2s，区区 0.5s。

接下来区区调参数，多次尝试并感受即可。于是使用 BSGS 通过了此题，并且只用了 1K + 区区 eps 的代码量。

[评测记录](https://www.luogu.com.cn/record/218938682)

```cpp
#include<bits/stdc++.h>
using namespace std;
int P,g,q,B;
struct Mod
{
	typedef long long LL;
    LL m, p;
    inline void init(int pp) { m = ((__int128)1 << 64) / pp; p = pp; }
    inline LL operator ()(LL x)
    {
        x -= ((__int128(x) * m) >> 64) * p;
        x>=P&&(x-=P);return x;
    }
} mod;
bitset<1000000009>Z;
const int U=1<<13; 
vector<pair<int,int>>ZZ[U];
inline void insert(int i,int v)
{
	if(Z[i])return;
	Z[i]=1;ZZ[i&U-1].emplace_back(i,v);
}
int main()
{
	cin.tie(0)->sync_with_stdio(0); 
	cin>>P>>g>>q;mod.init(P);
	B=max(sqrt(1ll*P*q)/3.56,1.0);
	int t=1;
	for(int i=0;i<B;++i)insert(t,i),t=mod(1ll*t*g);
	cerr<<clock()<<endl; 
	while(q--)
	{
		int w;cin>>w;
		w%=P;
		if(w%P==0)w=1;
		int z=0;
		while(1)
		{
			if(Z[w])
			{
				int Sw=0;
				for(auto k:ZZ[w&U-1])if(k.first==w){Sw=k.second;break;}
				z=((P-1ll)*2+Sw-z)%(P-1);
				break;
			}
			z+=B,w=mod(1ll*w*t);
		}
		cout<<z<<"\n"; 
	}
}
```

---

## 作者：WorldMachine (赞：4)

前置知识：[BSGS](https://www.luogu.com.cn/problem/P3846)

首先，对于离散对数，有一个和通常意义下的对数类似的性质：$\log ab\equiv\log a+\log b\pmod{p-1}$。如果要求 $\log1\sim \log n$ 的值，可以使用线性筛，这样就只有 $\pi(n)\approx\dfrac{n}{\log n}$ 个素数的离散对数要求。注意此时塞到 BSGS 那个桶里的数的个数 $B$，因为预处理桶时插入的复杂度为 $\mathcal O(B)$，查询总复杂度为 $\mathcal O\left(\dfrac{np}{B\log n}\right)$ 的，$B=\sqrt{\dfrac{np}{\log n}}$ 时有最优复杂度。

然后是该算法的核心所在：先预处理出 $\log1\sim\log(\sqrt p+1)$ 的值，这样可以 $\mathcal O(1)$ 回答出 $\sqrt p+1$ 以内的离散对数值。考虑迭代，设当前要查询 $\log a$ 的值，令 $p=ba+c$，其中 $c=p\bmod a$。发现 $b\le \sqrt{p}$，故 $\log b$ 与 $\log(b+1)$ 的值可以直接得出。

这样转化的好处在于，我们现在得到了两个关于 $\log a$ 的式子：
$$
\left\{
\begin{aligned}
&a=\dfrac{p-c}{b}\Rightarrow\log a\equiv\log(-c)-\log b\equiv\log(-1)+\log c-\log b\\
&a=\dfrac{p+a-c}{b+1}\Rightarrow\log a\equiv\log(a-c)-\log(b+1)
\end{aligned}
\right.
$$
因为有 $\min(c,a-c)\le\dfrac a2$，每次递归都会折半，故单次查询复杂度为 $\mathcal O(\log p)$。

总时间复杂度为 $\mathcal O\left(\dfrac{p^{\frac34}}{\log^{0.5}p}+q\log p\right)$
```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/hash_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
typedef long long ll;
const int N = 31630;
int qpow(int a, int b, int p) {
	int c = 1;
	while (b) {
		if (b & 1) c = (ll)c * a % p;
		a = (ll)a * a % p, b >>= 1;
	}
	return c;
}
gp_hash_table<int, int> mp;
int p, g, blk, w;
void init(int g, int P, int B) {
	p = P, blk = B, w = qpow(qpow(g, blk, p), p - 2, p);
	int x = 1;
	for (int i = 0; i < blk; i++) mp[x] = i, x = (ll)x * g % p;
}
int BSGS(int a) {
	int x = a, tot = p / blk;
	for (int i = 0; i <= tot; i++) {
		if (mp.find(x) != mp.end()) return i * blk + mp[x];
		x = (ll)x * w % p;
	}
	return -1;
}
int lg_1, lim, tot, pri[N], lg[N];
bool vis[N];
inline int mod(int x, int p) { return x >= p ? x - p : x; }
void sieve(int n) {
	for (int i = 2; i <= n; i++) {
		if (!vis[i]) pri[++tot] = i, lg[i] = BSGS(i);
		for (int j = 1, k; j <= tot && i * pri[j] <= n; j++) {
			k = pri[j];
			vis[i * k] = 1, lg[i * k] = mod(lg[i] + lg[k], p - 1);
			if (!(i % k)) break;
		}
	}
}
int Log(int a) {
	if (a <= lim) return lg[a];
	int b = p / a, c = p % a;
	if (c < a - c) return mod(mod(lg_1 + Log(c), p - 1) - lg[b] + p - 1, p - 1);
	return mod(Log(a - c) - lg[b + 1] + p - 1, p - 1);
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> p >> g, lim = sqrt(p) + 1;
	init(g, p, sqrt(p * sqrt(p) / log(p)));
	lg_1 = BSGS(p - 1);
	sieve(lim);
	int T, x;
	cin >> T;
	while (T--) cin >> x, cout << Log(x) << '\n';
}
```

---

## 作者：sbno333 (赞：3)

由于是模板，这里直接放算法流程。

首先你要弄一个函数，朴素 BSGS。

接着你要对 $1\le i\le \sqrt p+1$，每个 $i$ 计算 BSGS。

这时候复杂度高达 $O(p)$ 不可接受。

考虑优化，发现询问次数很多，可以降低每次询问的复杂度，提高预处理复杂度为代价。

具体的，你可以以 $\frac{p^{0.75}}{\log^{0.5} p}$ 为一块，预处理。

然后每次只需要 $p^{0.25}\times\log^{0.5} p$，可以线性筛优化，只计算质数的，其他数就是分解质因子后的和（因为 $\log ab=\log a+\log b$），这样总的就是 $\frac{p^{0.75}}{\log^{0.5} p}$。

询问部分，对于 $y<\sqrt p$，直接返回即可。

否则 $p=ky+b$。

$y$ 与 $\frac{-b}{k}$ 同余。

下来就是 $\log y$ 与 $\log{-b}-\log k$ 同余。

下来就是 $\log y$ 与 $\log {p-1}+\log{b}-\log k$ 同余。

其中只需要递归 $\log b$ 即可，剩下能直接得到答案。

或者 $p=(k+1)y+b-y$。

得到 $y$ 与 $\frac{y-b}{k+1}$ 同余。

最后变成 $\log{y-b}-\log{k+1}$，只需要递归 $\log{y-b}$ 即可，每次从两种找到递归更小的，一定减半，时间复杂度 $\log x$。

```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/hash_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
#define int long long
int b,p,n;
inline int ksm(int a,int b){
	int ans;
	ans=1;
	while(b){
		if(b&1){
			ans*=a;
			ans%=p;
		}
		a*=a;
		a%=p;
		b>>=1;
	}
	return ans;
}
inline int phi(int x){
	int y;
	y=1;
	for(int i=2;i*i<=x;i++){
		if(x%i==0){
			int g;
			g=0;
			while(x%i==0){
				g++;
				x/=i;
			}
			y*=ksm(i,g-1);
			y*=i-1;
		}
	}
	if(x>1)
	y*=x-1;
	return y;
}
int ph;
int pdyg(int x){
	for(int i=1;i*i<=ph;i++){
		if(ph%i==0){
			if((i!=ph&&ksm(x,i)==1)||(ph/i!=ph&&ksm(x,ph/i)==1)){
				return 0;
			}
		}
	}
	return 1;
}
int fy(){
	ph=phi(p);
	int yg;
	for(int i=1;i<=p;i++){
		if(pdyg(i)){
			yg=i;
			break;	
		}
	}
	return yg;
}
gp_hash_table<signed, signed> zz;
int g;
int ks[1009];
inline int lg(int b){//log_a b,a^x=b
	int a=g;
	int B;
	B=sqrt(sqrt(p))*sqrt(__lg((int)sqrt(p)));
	int mi;
	mi=1e16;
	for(int i=0;i<B;i++){
		int g;
		g=b*ks[i]%p;
		if(zz[g]){
			mi=min(mi,zz[g]*B-B+i);
			return mi;
		} 
	}
	return (mi==1e16?-1:mi);
}
int bg[40009];
int ccc;
int hi;
inline int llg(int x){
	if(x<=sqrt(p+3)){
		return bg[x]%hi;
	}
	if(x==p-1){
		return ccc%hi;
	}
	int v,r;
	v=p/x;
	r=p%x;
	if(r<x-r)
	return (ccc%hi+llg(r)-bg[v]%hi+hi)%hi;
	else
	return (llg(x-r)-bg[v+1]%hi+hi)%hi;
}
bool vis[40009]; 
int qq[10009];
int inn;
signed main(){
	std::ios::sync_with_stdio(0);
	cin>>p>>g;
	hi=phi(p);
	int B;
	B=sqrt(sqrt(p))*sqrt(__lg((int)sqrt(p)));
	int cc;
	cc=ksm(g,B);int z;
	z=1;
	for(int i=0;i<=p/B;i++){
		zz[z]=i+1; 
		z*=cc;
		z%=p;
	}
	for(int i=0;i<B;i++){
		ks[i]=ksm(ksm(g,i),p-2)%p;
	}
	int jc;
	jc=min((int)sqrt(p)+3,(int)p-1);
	vis[1]=1;
	bg[1]=lg(1);
	int ygg;
	ygg=phi(p);
	for(int i=2;i<=jc;i++){
		if(!vis[i]){
			bg[i]=lg(i);
			qq[++inn]=i;
		}
		for(int j=1;j<=inn,qq[j]*i<=jc;j++){
			bg[qq[j]*i]=(bg[i]+bg[qq[j]])%ygg;
			vis[qq[j]*i]=1;
			if(i%qq[j]==0){
				break;
			}
		}
	}
	
	ccc=lg(p-1);
	int q;
	cin>>q;
	while(q--){
		int x;
		cin>>x;
		cout<<llg(x)<<"\n";
	}
	return 0;
}
```

---

## 作者：gdf_yhm (赞：1)

### [【模板】基于值域预处理的快速离散对数](https://www.luogu.com.cn/problem/P11175)

[my blog](https://yhddd123.github.io/post/p11175-ti-jie/)。

### 思路

记使得 $g^x\equiv n\pmod{mod}$ 的最小非负 $x$ 为 $\log n$，有 $\log ab=\log a+\log b$。

令 $n=\sqrt{mod}+1$，预处理 $n$ 以内的 $\log x$。线性筛，只需要 bsgs 求出 $n$ 以内 $\frac{n}{\ln n}$ 个质数的 $\log p$，就可以 $O(n)$ 求出 $n$ 以内所有 $\log x$。哈希表，预处理时 $B$ 次插入，$\frac{n}{\ln n}$ 次 $\frac{mod}{B}$ 的查询，取 $B=\sqrt{\frac{n\times mod}{\ln n}}$。

查询 $\log a$ 时，如果 $a\le \sqrt{mod}+1$ 直接得出，否则有 $b\times a+c=mod$，$b\le \sqrt{mod}$。$\log a=\log \frac{-c}{b}=\log(c\times -1)-\log b=\log (mod-1)+\log c-\log b$。又因为有 $(b+1)\times a+c=mod+a$，$\log a=\log \frac{a-c}{b+1}=\log(a-c)-\log (b+1)$。$\log b$ 或 $\log(b+1)$ 已知，$\log (mod-1)$ 提前算，$\min(c,a-c)\le \frac{a}{2}$，选 $c$ 和 $a-c$ 较小的一边递归可以做到 $\log {mod}$ 查询。

复杂度 $O(\frac{mod^{\frac{3}{4}}}{\log^{\frac{1}{2}}mod}+q\log {mod})$

### code

```cpp
int mod,g,n,q;
int inc(int u,int v){((u+=v)>=mod-1)&&(u-=mod-1);return u;}
inline int ksm(int a,int b=mod-2){
	int ans=1;
	while(b){
		if(b&1)ans=1ll*ans*a%mod;
		a=1ll*a*a%mod;
		b>>=1;
	}
	return ans;
}
int B,bas,h0;
struct hsh_table{
	int head[maxn],tot;
	struct nd{
		int nxt;
		int key;
		int val;
	}e[maxn];
	int hsh(int u){return u%maxn;}
	bool find(int key){
		int u=hsh(key);
		for(int i=head[u];i;i=e[i].nxt){
			if(e[i].key==key)return 1;
		}
		return 0;
	}
	int &operator[](int key){
		int u=hsh(key);
		for(int i=head[u];i;i=e[i].nxt){
			if(e[i].key==key)return e[i].val;
		}
		e[++tot]={head[u],key,0};head[u]=tot;
		return e[tot].val;
	}
	void clear(){
		tot=0;
		for(int i=0;i<maxn;i++)head[i]=0;
	}
}mp;
int bsgs(int v){
	int mul=v;
	for(int i=0;i<=mod/B;i++){
		if(mp.find(mul))return i*B+mp[mul];
		mul=1ll*mul*bas%mod;
	}
}
/*
mod=ba+c
log(a)=log(-c)-log(b)=log(mod-1)+log(c)-log(b)
log(a)=log(a-c)-log(b+1)
min(c,a-c)<=a/2
*/
int h[maxn];
int sovle(int a){
	int b=mod/a,c=mod%a;
	if(a<=n)return h[a];
	if(c<a-c)return inc(inc(h0,sovle(c)),(mod-1-h[b]));
	else return inc(sovle(a-c),mod-1-h[b+1]);
}
bool vis[maxn];
int pre[maxn],cnt;
void work(){
	mod=read();g=read();n=sqrt(mod)+1;B=sqrt(1ll*mod*n/log2(n));
	// cout<<n<<" "<<B<<"\n";
	int mul=1;for(int i=0;i<B;i++){
		mp[mul]=i;
		mul=1ll*mul*g%mod;
	}
	bas=ksm(ksm(g,B));
	h0=bsgs(mod-1);
	h[1]=0;
	for(int i=2;i<=n;i++){
		if(!vis[i]){
			h[i]=bsgs(i);
			pre[++cnt]=i;
		}
		for(int j=1;j<=cnt&&1ll*i*pre[j]<=n;j++){
			vis[i*pre[j]]=0;
			h[i*pre[j]]=(h[i]+h[pre[j]])%(mod-1);
			if(i%pre[j]==0)break;
		}
	}
	q=read();
	while(q--){
		int x=read();
		printf("%lld\n",sovle(x));
	}
}
```

---

## 作者：UniGravity (赞：0)

### 阶

若 $\gcd(a,p)=1$，则 $a^{\varphi(p)}\equiv 1\pmod p$。

因此存在最小的正整数 $n$（即 $n$ 的上界是 $\varphi(p)$）使得 $a^n\equiv 1\pmod p$，$n$ 称为 $a$ 模 $m$ 的阶。记作 $n=\delta(a)$。

一些性质：

> 若 $a^k\equiv1$，则 $\delta(a)|k$。
> 
> 反证：若 $r=k\bmod \delta(a),r\neq 0$，则 $a^r\equiv 1$ 且 $r<\delta(a)$，与定义矛盾。

其它性质和证明可参考 [OI-wiki](https://oi-wiki.org/math/number-theory/primitive-root/)。

### 原根

定义 $m$ 的原根为满足 $\gcd(g,m)=1,\delta(g)=\varphi(m)$ 的数，可以理解为 $\delta(g)$ 顶到了可能的上界。

#### 求一个数的原根

[模板题链接](https://www.luogu.com.cn/problem/P6091)

原根的一些性质：

* 只有形如 $2,4,p^k,2\times p^k$（$p$ 为奇质数，$k$ 为正整数）的数才有原根。
* 一个数的最小原根大约是 $O(n^{0.25})$ 级别的。

假设找到了最小原根 $g$，则有若 $\gcd(k,\varphi(p))=1$，则 $\delta(g^k)=\delta(g)=\varphi(p)$，因此只要找出最小的原根即可。

对于一个 $g$，假设其不是原根，则存在一个小于 $\varphi(p)$ 的数 $k$ 也满足 $g^k\equiv 1$。根据阶的性质，$k|\varphi(p)$，因此只要有任意一个的真因子满足 $g^k\equiv 1$ 则其不是原根，且若一个因子不满足其倍数也不满足。

只需要枚举 $\varphi(p)$ 的质因子，判断 $\frac{\varphi(p)}{x}$ 是否满足条件即可。因为这些数覆盖了所有真因子的倍数，只要这些数满足说明所有真因子都应该不满足。

线性筛预处理，时间复杂度约为 $O(n^{0.25}\log n)$。

```cpp
const int N=1000005;
vector<int>pr;
bool np[N],isr[N];
int mnp[N],phi[N];
// 线性筛出存在原根的数
il void init(int n){
    phi[1]=1,mnp[1]=1;
    forto(i,2,n){
        if(!np[i]){
            pr.eb(i),mnp[i]=i,phi[i]=i-1;
            if(i!=2){
                for(ll j=i;j<=n;j*=i){
                    isr[j]=1;
                    if((j<<1)<=n)isr[j<<1]=1;
                }
            }
        }
        for(int j:pr){
            if(i*j>n)break;
            np[i*j]=1,mnp[i*j]=j;
            if(i%j==0){phi[i*j]=phi[i]*j;break;}
            phi[i*j]=phi[i]*phi[j];
        }
    }
}

il ll fpow(ll x,int n,int p){
    ll a=1;while(n){if(n&1)a=a*x%p;x=x*x%p,n>>=1;}return a;
}

// 找最小原根
il int getroot(int p){
    if(p==2||p==4)return p-1;
    else if(!isr[p])return -1;
    vector<int>vp;
    int x=phi[p],c;
    while(x!=1){
        vp.eb(mnp[x]),c=mnp[x];
        while(mnp[x]==c)x/=c;
    }
    for(x=1;;x++)if(__gcd(x,p)==1){
        bool fg=1;
        for(int y:vp){
            if(fpow(x,phi[p]/y,p)==1){fg=0;break;}
        }
        if(fg)return x;
    }
}

il vector<int>getroot(int p){
    int r=getminroot(p);
    if(r==-1)return {};
    vector<int>ans;
    for(int i=1,x=r;i<=phi[p];i++){
        if(__gcd(i,phi[p])==1)ans.eb(x);
        x=1ll*x*r%p;
    }
    sort(ans.begin(),ans.end());
    return ans;
}
```

### 离散对数

与对数类似，对于一个质数 $p$ 和其原根 $g$，定义 $a$ 的离散对数 $k$ 满足 $g^k\equiv a\pmod p$。

下文不严谨地将离散对数直接记为 $k=\log a$。

离散对数有一些与对数相似的性质：

* $\log 1=0,\log g=1$
* $\log ab\equiv\log a+\log b\pmod{\varphi(p)}$
* $a\equiv b \leftrightarrow \log a=\log b$

接下来将介绍求离散对数的几种方法。

### BSGS / 单个数离散对数

[模板题链接](https://www.luogu.com.cn/problem/P3846)

BSGS，即大步小步算法，可以做到单次查询 $O(\sqrt p)$。

考虑求 $g^k\equiv a\pmod p$，将 $k$ 分解为 $k=i\cdot B-j\ (0\le j<B)$，则原式变为：

$$g^{i\cdot B-j}\equiv a$$

进行变形：

$${(g^B)}^i\equiv a\cdot g^j$$

发现 $i,j$ 两个变量相对独立，可以分别求出。

考虑预处理出所有 $B$ 个 $a\cdot g^j$，则假如我们知道了 ${(g^B)}^i$ 即可 $O(1)$ 通过哈希表求出 $j$。

枚举 $\frac{p}{B}$ 个 $i$，如果找到了符合条件的 $j$ 说明 $k=i\cdot B-j$ 即为一组合法解。取 $B=\sqrt p$ 得到上述复杂度。

```cpp
unordered_map<int,int>BSGS_mp;
il int BSGS(int g,int p,int a){
    BSGS_mp.clear();
    int B=sqrt(p)+1,v=1,pw=fpow(g,B,p);
    forv(i,B)BSGS_mp[1ll*a*v%p]=i,v=1ll*v*g%p;
    v=pw;
    forto(i,1,p/B+1){
        if(BSGS_mp.count(v))return i*B-BSGS_mp[v];
        v=1ll*v*pw%p;
    }
    return -1;
}
```

一个接下来会用到的优化：

发现每次询问都要重新预处理，但是如果在 $g,p$ 固定的情况下我们可以再次对式子变形：

$${(g^B)}^i\cdot a^{-1}\equiv g^j$$

这样预处理出的表与 $a$ 无关。要求是 $\gcd(a,p)=1$。

### 预处理 BSGS / 多次询问离散对数

[模板题链接](https://www.luogu.com.cn/problem/solution/P11175)

考虑有 $q$ 次询问，直接 BSGS，平衡块长后复杂度为 $O(\sqrt{qp})$，$q$ 较大时无法接受。

考虑预处理出 $\le A$ 的离散对数值。假设已经预处理好了这些值，对于一个较大的值，考虑拆开对数使其规模减小。

假设要求 $\log x\ (x>A)$，由 $p=ix+j$ 可得 $x=\frac{p-j}i$。考虑 $\log(p-j)$ 实际上等于什么，发现即为满足 $g^k\equiv p-j\equiv -j$。同理可发现 $\log$ 内加减若干 $p$ 结果不变。因此：

$$\log(p-j)\equiv \log(pj-j)\equiv \log((p-1)j)\equiv \log(p-1)+\log j$$

注意 $\log$ 的同余是在模 $\varphi(p)$ 的情况下。

则有：

$$\log x\equiv \log\left(\frac{p-j}i\right)\equiv \log(p-j)-\log i\equiv\log(p-1)+\log j-\log i$$

由于 $\log(p-1)$ 已知，且 $i=\left\lfloor\frac{p}{x}\right\rfloor\le \left\lfloor\frac{p}{A}\right\rfloor$，因此我们取 $A=\sqrt p+1$，这样 $i$ 就是我们已知的了。只剩下 $j$ 需要递归下去求，但 $j\in[0,x)$，仍然可能很大。

考虑从另一边构造一个相似的形式 $p=(i+1)x-(x-j)$，同理可得：

$$\log x\equiv\log\left(\frac{p+(x-j)}{i+1}\right)\equiv\log(x-j)-\log(i+1)$$

注意到如果分别按照这两个式子展开，子问题的大小是 $j$ 和 $x-j$ 的，考虑选择较小的一边，则每次递归下去问题规模必然减小一半。当 $x\le A$ 时查表回答。这样单次询问的复杂度就为 $O(\log p)$。

但是我们还有一个问题没有解决：即如何预处理出 $\le A$ 的所有数的离散对数。如果对每个数跑一遍 BSGS 复杂度是 $O(A\sqrt p)=O(p)$ 的，还是无法接受。

考虑继续利用对数的性质处理，由于 $\log ab\equiv\log a+\log b$，因此我们只需要找出所有质数的 $\log$ 值，合数的值可以线性筛得到。

要找出的质数约有 $O(\frac{A}{\log A})=O(\frac{\sqrt p}{\log p})$ 个。只需要对这些数跑 BSGS 即可。设预处理的块长为 $B$，则总复杂度为 $O(B+\frac{p\sqrt p}{B\log p})$，取 $B=\frac{p^{0.75}}{\log^{0.5}p}$ 时最优。$p$ 在 $10^9$ 级别时不考虑常数大概只需要 $10^6$ 次操作。

总复杂度 $O(\frac{p^{0.75}}{\log^{0.5}p}+q\log p)$。

```cpp
namespace BSGS{
    int g,p,A,B,pwg;
    unordered_map<int,int>mp;
    il int bsgs(int x){
        int v=fpow(x,p-2,p);
        forto(i,1,p/B+1){
            v=1ll*v*pwg%p;
            if(mp.count(v))return i*B-mp[v];
        }
        return -1;
    }
    const int N=40005;
    vector<int>pr;
    bool np[N];
    int lg[N],mxv;
    il void init(int _g,int _p){
        g=_g,p=_p,A=sqrt(p)+1,B=(int)(pow(p,0.75)/sqrt(log(p)))+1;
        mp.clear(),pwg=fpow(g,B,p);;
        int v=1;
        forv(i,B)mp[v]=i,v=1ll*v*g%p;
        mxv=bsgs(p-1),lg[1]=0;
        forto(i,2,A){
            if(!np[i])pr.eb(i),lg[i]=bsgs(i);
            for(int j:pr){
                if(i*j>A)break;
                np[i*j]=1,lg[i*j]=(lg[i]+lg[j])%(p-1);
                if(i%j==0)break;
            }
        }
    }
    il int qry(int x){
        if(x<=A)return lg[x];
        int i=p/x,j=p%x;
        if(j<x-j)return ((mxv+qry(j))%(p-1)-qry(i)+p-1)%(p-1);
        else return (qry(x-j)-qry(i+1)+p-1)%(p-1);
    }
}
```

---


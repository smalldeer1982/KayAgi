# [LnOI2019] 第二代图灵机

## 题目背景

1989年，Abbi提出了一种抽象的计算模型 —— 第二代图灵机 (The 2nd Generation Turing Machine）。

所谓的第二代图灵机就是指一个抽象的机器，它有一条长度为$n$的纸带，纸带分成了$n$个小方格，每个方格有不同的**颜色**和不同的**数字**。

![avatar](https://cdn.luogu.com.cn/upload/pic/52955.png)


## 题目描述

第二代图灵的基本思想是用机器来模拟鹿们用纸笔进行数学运算的过程，他把这样的过程看作下列两种简单的动作：

1. 在纸带上的一格写数字.
2. 在纸带上的一段区间着色.

为了测试第二代图灵机的性能，Abbi提出了一种用于判定机器是否具有智能的试验方法，即图灵试验。

1. 求$[l,r]$中包含所有(一共$c$种)颜色，数字和最小的子区间的数字和。
2. 求$[l,r]$中没有重复颜色，数字和最大的子区间的数字和。

你需要为第二代图灵机编写算法，使他能通过所有的图灵试验。为保证试验的正确性，所有数据都是随机生成的。

## 说明/提示

![avatar](https://cdn.luogu.com.cn/upload/pic/53113.png)

**由于数据规模较大，建议用以下方法读入一个正整数。**

```cpp
void read(int &x){
	char ch;
	while(ch = getchar(), ch < '!'); x = ch - 48;
	while(ch = getchar(), ch > '!') x = (x << 3) + (x << 1) + ch - 48;
}
```

## 样例 #1

### 输入

```
9 8 4
17 5 8 1 6 4 12 3 4
1 1 1 1 1 1 1 3 4
2 3 6 2
3 1 9
4 1 9
4 6 9
4 1 3
2 4 5 4
3 1 1
3 1 9```

### 输出

```
23
23
23
17
-1
23```

# 题解

## 作者：LG_kemeng (赞：16)

# 珂朵莉+线段树方法
#### 前缀知识：线段树，珂朵莉树（ODT），双指针

首先，这题数字和颜色之间明显**没有直接的联系**，并且一个珂朵莉无法处理。所以我们可以用**两个结构**分别储存这两个变量。数字要求最小区间和，用**线段树**储存；颜色区间修改，用**珂朵莉**储存。
## 构造
#### 颜色
首先考虑颜色：对于颜色题目只有一个操作， `assign()`，区间平推。
#### 数字
然后考虑数字：建立的线段树要满足下列操作：**区间最大、区间最小、区间求和**。区间最大和区间最小用做初始化(可能有 $c = 1$ 的情况，初始化答案用区间最大/最小值)。区间求和是题目两问的解。

~~所以话说真的有人会在做珂朵莉骗分的时候还加一个线段树吗~~。
## 实现
#### 操作一
* 询问区间 $[l,r]$， $[l,r]$ 中包含所有（一共 $c$ 种）颜色的区间和的最小值。

先用珂朵莉，左右界为： `itr=split(r+1)`， `itl=split(l)`。左右指针初始为 $itl$。右指针 $it$ 不断 ++，直到找到一个点使颜色 $tot$ 有 $c$ 种，更新答案 $res$ (即返回当前线段树 `querysum(itl->r,it->l)`)。这个时候，考虑将左指针 $itl$ ++，并更新 $res$。最终返回 $res$ 即可。
```cpp
#define add(x) (!cnt[x]++&&++tot)
#define del(x) (!--cnt[x]&&--tot)
inline int Q1(int l,int r)//第一种情况 
{ 
	if(c==1)//若c=1,特判,直接取区间最小值就行 
		return query_min(1,n,1,l,r);
	memset(cnt,0,sizeof(cnt));//初始化 
	IT it_r=split(r+1),it_l=split(l),it=it_l;
	register int t,res=INF,tot=0;
	while(it!=it_r)//枚举右指针,当有c种颜色时,考虑挪动左指针 
	{
		add(it->color);
		while(tot==c)
			t=query_sum(1,n,1,it_l->r,it->l),res=min(res,t),del((it_l++)->color);
		it++;
	}
	return res==INF?-1:res;
}
```
**注： $cnt_i$ 为颜色 $i$ 出现次数。 `add` 里面先判断，所以 ++ 在 $cnt_x$ 后面。 `del` 里面先减，所以 -- 在 $cnt_x$ 前面。线段树 `querysum` 时，左指针所在区间有尾无头，右指针所在区间有头无尾，所以是 `querysum(itl->r,it->l)`。**
#### 操作二
* 求 $[l,r]$ 中没有重复颜色的最大区间和。

和上一问思路差不多，同样用双指针实现。不过这一问是不断调整左指针 $itl$，保证右指针的颜色的出现次数为 1。注意特判：**如果右指针所在区间的 $size$ 不为 1**，因为条件不符合，直接跳过该段，即将左指针移至右指针，右指针 ++，避开这个区间。
```cpp
inline int Q2(int l,int r)//第二种情况 
{
	memset(cnt,0,sizeof(cnt));//初始化 
	IT it_r=split(r+1),it_l=split(l),it=it_l;
	register int t,res=query_max(1,n,1,l,r);
	while(it!=it_r)//类似的思路,不断调整左指针,保证右指针的颜色的出现数量始终为1。所以要加一个特判,如果右指针的size不为1,直接跳过,也就是令左指针直接移动到右指针的位置,右指针++ 
	{
		cnt[it->color]++;
		while(it!=it_l&&cnt[it->color]>1)
			cnt[(it_l++)->color]--;
		if(it!=it_l)
			t=query_sum(1,n,1,it_l->r,it->l),res=max(res,t);
		if(it->l!=it->r)
			while(it!=it_l)
				cnt[(it_l++)->color]--;
		it++;
	}
	return res;
}
```
**注意：考虑最差情况， $res$ 初始赋值区间内单点最大值。**

AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;

#define N 100000
#define INF 1e9

#define IT set<node>::iterator
#define add(x) (!cnt[x]++&&++tot)
#define del(x) (!--cnt[x]&&--tot)
//----------------------------------------------分割线---------------------------------------------------------------------// 
int n,c,a[N+5],v[N+5],cnt[N+5];
//线段树部分 
struct tree 
{
	int S,Mx,Mn;
	inline tree(int s=0,int mx=-INF,int mn=INF):S(s),Mx(mx),Mn(mn){}
	inline tree operator + (const tree& t) const//重载+,方便运算 
	{
		return tree(S+t.S,max(Mx,t.Mx),min(Mn,t.Mn));
	}
}t[N<<2];
inline void build(int l,int r,int rt)//建树 
{
	if(l==r)
	{
		t[rt]=tree(v[l],v[l],v[l]);
		return ; 
	} 
	register int mid=l+r>>1;
	build(l,mid,rt<<1),build(mid+1,r,rt<<1|1);
	t[rt]=t[rt<<1]+t[rt<<1|1];
}
inline int query_sum(int l,int r,int rt,int ql,int qr)//区间和 
{
	if(ql<=l&&r<=qr) return t[rt].S;
	register int mid=l+r>>1;
	register int sum=0;
	if(ql<=mid)
		sum+=query_sum(l,mid,rt<<1,ql,qr);
	if(qr>mid)
		sum+=query_sum(mid+1,r,rt<<1|1,ql,qr);
	return sum;
}
inline int query_max(int l,int r,int rt,int ql,int qr)//区间最大 
{
	if(ql<=l&&r<=qr) return t[rt].Mx;
	register int t,maxx=-INF,mid=l+r>>1;
	if(ql<=mid)
		maxx=max(maxx,query_max(l,mid,rt<<1,ql,qr));
	if(qr>mid)
		maxx=max(maxx,query_max(mid+1,r,rt<<1|1,ql,qr));
	return maxx;
}
inline int query_min(int l,int r,int rt,int ql,int qr)//区间最小 
{
	if(ql<=l&&r<=qr) return t[rt].Mn;
	register int t,minn=INF,mid=l+r>>1;
	if(ql<=mid)
		minn=min(minn,query_min(l,mid,rt<<1,ql,qr));
	if(qr>mid)
		minn=min(minn,query_min(mid+1,r,rt<<1|1,ql,qr));
	return minn;
}
inline void Init(int x,int* s)//输入 
{
	for(register int i=1;i<=x;i++)
		v[i]=s[i];
	build(1,x,1);
}
inline void Update(int x,int y)//更新 
{
	register int l=1,r=n,rt=1,mid;
	while(l!=r)//二分查找 
	{
		mid=l+r>>1;
		if(x<=mid)
			r=mid,rt<<=1;
		else
			l=mid+1,(rt<<=1)|=1;
	}
	t[rt]=tree(y,y,y);
	while(rt>>=1)//向上更新 
		t[rt]=t[rt<<1]+t[rt<<1|1];
}
//----------------------------------------------分割线---------------------------------------------------------------------// 
//珂朵莉树部分
struct node
{
	int l,r,color;
	inline node(int x=0,int y=0,int p=0):l(x),r(y),color(p){}
	inline bool operator < (const node& t) const
	{
		return l<t.l;
	}
};set<node> S;
inline IT split(int pos)//区间分割 
{
	IT it=S.lower_bound(node(pos));
	if(it!=S.end()&&it->l==pos) return it;
	it--;
	node tmp=*it;
	S.erase(it);
	S.insert(node(tmp.l,pos-1,tmp.color));
	return S.insert(node(pos,tmp.r,tmp.color)).first;
}
inline void assign(int l,int r,int color)//区间平推 
{
	IT it_r=split(r+1),it_l=split(l);
	S.erase(it_l,it_r);
	S.insert(node(l,r,color));
}
inline void _Init(int x,int* s)//输入 
{
	for(register int i=(s[0]=s[x+1]=-1,1),t=0;i<=x+2;++i)
		s[i]^s[i-1]&&(S.insert(node(t,i-1,s[i-1])),t=i);
}
//----------------------------------------------分割线---------------------------------------------------------------------// 
//问题求解部分 
inline int Q1(int l,int r)//第一种情况 
{ 
	if(c==1)//若c=1,特判,直接取区间最小值就行 
		return query_min(1,n,1,l,r);
	memset(cnt,0,sizeof(cnt));//初始化 
	IT it_r=split(r+1),it_l=split(l),it=it_l;
	register int t,res=INF,tot=0;
	while(it!=it_r)//枚举右指针,当有c种颜色时,考虑挪动左指针 
	{
		add(it->color);
		while(tot==c)
			t=query_sum(1,n,1,it_l->r,it->l),res=min(res,t),del((it_l++)->color);
		it++;
	}
	return res==INF?-1:res;//=if(res==INF) return -1;else return res; 
}
inline int Q2(int l,int r)//第二种情况 
{
	memset(cnt,0,sizeof(cnt));//初始化 
	IT it_r=split(r+1),it_l=split(l),it=it_l;
	register int t,res=query_max(1,n,1,l,r);
	while(it!=it_r)//类似的思路,不断调整左指针,保证右指针的颜色的出现数量始终为1。所以要加一个特判,如果右指针的size不为1,直接跳过,也就是令左指针直接移动到右指针的位置,右指针++ 
	{
		cnt[it->color]++;
		while(it!=it_l&&cnt[it->color]>1)
			cnt[(it_l++)->color]--;
		if(it!=it_l)
			t=query_sum(1,n,1,it_l->r,it->l),res=max(res,t);
		if(it->l!=it->r)
			while(it!=it_l)
				cnt[(it_l++)->color]--;
		it++;
	}
	return res;
}
void read(int &x)//官方给的快读,不用白不用(bushi) 
{
	char ch;
	while(ch = getchar(), ch < '!'); x = ch - 48;
	while(ch = getchar(), ch > '!') x = (x << 3) + (x << 1) + ch - 48;
}

int main()
{
	register int T,i,opt,l,r,col;
	read(n),read(T),read(c);
	
	for(i=1;i<=n;++i)
		read(a[i]);
	Init(n,a);
	for(i=1;i<=n;++i)
		read(a[i]);
	_Init(n,a);
	
	while(T--)
	{
		read(opt),read(l),read(r);
		if(opt==1) Update(l,r);
		if(opt==2) read(col),assign(l,r,col);
		if(opt==3) printf("%d\n",Q1(l,r));
		if(opt==4) printf("%d\n",Q2(l,r));
	}
	return 0;
}
```

---

## 作者：✡Dustaria✡ (赞：10)

~~大概是第一次见到把珂朵莉树和其他数据结构一起用的题~~

首先由于题目中说保证数据随机，而且又有区间推平操作，这已经是明示你要用珂朵莉树了~~吧~~

我们发现区间推平的操作是针对颜色的，而且询问操作都是在满足某种关于颜色的限制下求答案，所以显然珂朵莉树的节点保存的应该是颜色信息

然后看这两种询问操作，不难发现合法区间的左右端点的移动都是单调的，那么我们就可以双指针扫描来求出答案

但是还有一个问题，就是怎样快速维护每个位置上的数字信息，毕竟你统计答案的时候是要用到的

只在珂朵莉树上的每个节点处记录数字之和显然是不行的，因为你根本没办法`split`……

此问题有两种方法可以解决（当然也可能有别的我不知道的方法

一种是我在比赛时想的，就是在每个节点里维护一棵能够快速拆分合并的平衡树（比如 $Splay$ 或无旋 $Treap$ ），在平衡树里记录信息就好了

然而这么写非常恶心……难写难调，常数极大，还有一堆细节非常难搞（所以比赛的时候并没有调出来QAQ

其实我当时这么想主要是因为把关注点集中在“`split`的时候怎么快速维护节点里的数值信息”了

然而如果我们稍微动一下脑子想想，就会发现实际上根本不需要这么麻烦

因为我们是知道每个节点的区间的，所以根本没必要把这些数字的信息维护在节点上啊

所以我们只用开一棵线段树来维护整个序列就好了

这么写显然比上一种写法好了很多，不管是码量上还是常数上

具体来说，对于操作 $3$ ，我们用双指针扫出每个尽可能小的能够包含所有颜色的区间，然后直接在线段树(或者树状数组)上查询此区间内的数值之和

对于操作 $4$ ，我们用双指针扫出每个尽可能大的且没有出现重复颜色的区间，同样查询此区间内的数值之和；当然，这样做会漏掉那种长度为 $1$ 且被包含在某个节点内部的区间，所以我们需要再在线段树上查一下区间最大值

时间复杂度上，双指针的移动次数是 $O(logn)$ 的，每次查询区间和是 $O(logn)$ 的，所以总复杂度是 $O(mlog^2n)$ 

另外还有一点，就是上面说的方法~~好像~~是没办法处理 $c=1$ 的情况的（至少我看了一下其他目前已 $\text{AC}$ 的代码都不能正确回答 $c=1$ 时的询问），所以还是特判一下 $c=1$ 的情况比较好（虽然数据中并没有这种情况）

特判就很简单啦，直接用线段树维护一下区间最大和最小值就星了

最终的实现还是有一些细节需要注意的，如果不想清楚就开始写可能会调很久吧（~~比如我~~

下面放上代码（第二种写法），码风可能比较奇怪，轻喷……

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <set>
#define L(x) (x<<1)
#define R(x) ((x<<1)|1)
#define Lowbit(x) ((x)&(-(x)))
#define SI set<Node>::iterator
using namespace std;

const int maxn=100005;
const int Inf=0x7fffffff;

struct Node{
	int l;
	int r;
	mutable int col;
	inline Node(int l,int r=-1,int col=0):l(l),r(r),col(col){}
	inline bool operator <(const Node& a)const{
		return l<a.l;
	}
};

struct SegmentTree{
	int s;
	int t;
	int maxv;
	int minv;
}N[maxn<<2];

int n;
int m;
int p;
int A[maxn];
int c[maxn];
bool flag[maxn];
set<Node> S;

struct BIT{
	int c[maxn];
	inline void Update(int x,int key){
		for(int i=x;i<=n;i+=Lowbit(i))
			c[i]+=key;
	}
	inline int Query(int x){
		int ans=0;
		for(int i=x;i;i-=Lowbit(i))
			ans+=c[i];
		return ans;
	}
	inline int Query(int l,int r){
		return Query(r)-Query(l-1);
	}
}C;

SI Split(int);
void Pushup(int);
int Querymin(int,int);
int Querymax(int,int);
void Build(int,int,int);
void Update(int,int,int);
void Assign(int,int,int);
int Querymax(int,int,int);
int Querymin(int,int,int);
inline void Read_int(int&);
void Work();

struct Solve{
	void operator ()(){
		for(int i=1;i<=n;++i)
			Read_int(A[i]);
		Build(1,1,n);
		for(int i=1,x;i<=n;++i)
			Read_int(x);
		for(int i=1,op,l,r;i<=p;++i){
			Read_int(op);
			Read_int(l);
			Read_int(r);
			switch(op){
				case 1:Update(1,l,r);break;
				case 2:Read_int(l);break;
				case 3:printf("%d\n",Querymin(1,l,r));break;
				case 4:printf("%d\n",Querymax(1,l,r));break;
			}
		}
	}
};

int main(){
	Work();
	return 0;
}

void Work(){
	int op,l,r,x;
	Read_int(n);
	Read_int(p);
	Read_int(m);
	if(m==1) return Solve()();
	S.insert(Node(0,0));
	S.insert(Node(n+1,n+1));
	for(int i=1;i<=n;++i)
		Read_int(A[i]),C.Update(i,A[i]);
	Build(1,1,n);
	for(int i=1;i<=n;++i)
		Read_int(x),S.insert(Node(i,i,x));
	for(int i=1;i<=p;++i){
		Read_int(op);
		Read_int(l);
		Read_int(r);
		switch(op){
			case 1:Update(1,l,r);C.Update(l,-A[l]);C.Update(l,A[l]=r);break;
			case 2:Read_int(x);Assign(l,r,x);break;
			case 3:printf("%d\n",Querymin(l,r));break;
			case 4:printf("%d\n",Querymax(l,r));break;
		}
	}
}

inline SI Split(int x){
	SI it=S.lower_bound(Node(x));
	if(it!=S.end()&&it->l==x) return it;
	--it;int l=it->l,r=it->r;
	int col=it->col;S.erase(it);
	S.insert(Node(l,x-1,col));
	return S.insert(Node(x,r,col)).first;
}

inline void Assign(int l,int r,int col){
	SI t=Split(r+1),s=Split(l);
	S.erase(s,t);S.insert(Node(l,r,col));
}

inline int Querymin(int l,int r){
	SI t=Split(r+1),s=Split(l);
	SI a=s,b=s;int ans=Inf,now=0;
	for(;b!=t;++a,++b){
		for(;b!=t;++b){
			if(!(c[b->col]++)) ++now;
			if(now>=m) break;
		}
		if(b==t) break;
		for(;;++a) if(!(--c[a->col])){
			--now;break;
		}
		ans=min(ans,C.Query(a->r,b->l));
	}
	for(;a!=t;++a) c[a->col]=0;
	return (ans>=Inf)?(-1):ans;
}

inline int Querymax(int l,int r){
	SI t=Split(r+1),s=Split(l),a=s,b=s;
	int ans=Querymax(1,l,r);
	for(;b!=t;++b){
		for(;b!=t;++b){
			if(flag[b->col]) break;
			if(b->l!=b->r) break;
			flag[b->col]=1;
		}
		ans=max(ans,C.Query(a->r,b->l-1));
		if(b==t) break;
		if(b->l!=b->r){
			if(!flag[b->col])
				ans=max(ans,C.Query(a->r,b->l));
			else{
				for(;flag[b->col];++a)
					flag[a->col]=0;
				ans=max(ans,C.Query(a->r,b->l));
			}
			for(;a!=b;++a) flag[a->col]=0;
			flag[b->col]=1;continue;
		}
		for(;flag[b->col];++a)
			flag[a->col]=0;
		ans=max(ans,C.Query(a->r,b->l));
		flag[b->col]=1;
	}
	for(;a!=t;++a) flag[a->col]=0;
	return ans;
}

void Build(int x,int left,int right){
	N[x].s=left;
	N[x].t=right;
	if(left==right)
		return N[x].maxv=N[x].minv=A[left],void();
	int mid=((left+right)>>1);
	Build(L(x),left,mid);
	Build(R(x),mid+1,right);
	N[x].maxv=max(N[L(x)].maxv,N[R(x)].maxv);
	N[x].minv=min(N[L(x)].minv,N[R(x)].minv);
}

inline void Update(int x,int pos,int key){
	if(N[x].s>pos||N[x].t<pos) return;
	if(N[x].s==N[x].t)
		return N[x].maxv=N[x].minv=key,void();
	if(pos<=N[L(x)].t) Update(L(x),pos,key);
	else Update(R(x),pos,key);
	N[x].maxv=max(N[L(x)].maxv,N[R(x)].maxv);
	N[x].minv=min(N[L(x)].minv,N[R(x)].minv);
}

inline int Querymax(int x,int left,int right){
	if(N[x].s>right||N[x].t<left) return -Inf;
	if(N[x].s>=left&&N[x].t<=right) return N[x].maxv;
	return max(Querymax(L(x),left,right),Querymax(R(x),left,right));
}

inline int Querymin(int x,int left,int right){
	if(N[x].s>right||N[x].t<left) return Inf;
	if(N[x].s>=left&&N[x].t<=right) return N[x].minv;
	return min(Querymin(L(x),left,right),Querymin(R(x),left,right));
}

inline void Read_int(int& x){
	register char ch;
	while(ch=getchar(),ch<'0');
	x=ch-'0';
	while(ch=getchar(),ch>='0') x=((x+(x<<2))<<1)+ch-'0';
}
```

顺便再把用平衡树的那种写法的代码放上来吧，~~毕竟调了好久的不能白调是不是~~

这么写真的很麻烦，可能并不会有除了我之外的人会这么写吧

又因为这种写法是比赛的时候写的(后来才给调过了)，所以有很多冗余语句，可能很难理解的说……(要是真看不懂就别看了)

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <deque>
#include <set>
#define lch chd[0]
#define rch chd[1]
#define L(x) (x<<1)
#define R(x) ((x<<1)|1)
#define SI set<Node>::iterator
#define Treapair pair<Treap*,Treap*>
using namespace std;

const int maxn=100005;
const int Inf=0x7fffffff;

struct Treap{
	int val;
	int sum;
	int pos;
	int size;
	int maxv;
	int lval;
	int rval;
	Treap* chd[2];
	inline Treap();
	inline void Reset();
	inline void Pushup();
	inline void Set(int,int);
};

struct Node{
	int l;
	int r;
	mutable int col;
	mutable Treap* rt;
	inline bool operator <(const Node& a)const{
		return l<a.l;
	}
};

struct SegmentTree{
	int s;
	int t;
	int maxv;
	int minv;
}N[maxn<<2];

int n;
int m;
int p;
int A[maxn];
int c[maxn];
bool flag[maxn];
Treap* Null=new Treap;
set<Node> S;

SI Split(int);
void Change(int,int);
int Querymin(int,int);
int Querymax(int,int);
void Assign(int,int,int);
Treapair Split(Treap*,int);
Treap* Merge(Treap*,Treap*);
void Modify(Treap*,int,int);
inline void Read_int(int&);
void Work();

struct Solve{
	void Build(int x,int left,int right){
		N[x].s=left;
		N[x].t=right;
		if(left==right)
			return N[x].maxv=N[x].minv=A[left],void();
		int mid=((left+right)>>1);
		Build(L(x),left,mid);
		Build(R(x),mid+1,right);
		N[x].maxv=max(N[L(x)].maxv,N[R(x)].maxv);
		N[x].minv=min(N[L(x)].minv,N[R(x)].minv);
	}
	inline void Update(int x,int pos,int key){
		if(N[x].s>pos||N[x].t<pos) return;
		if(N[x].s==N[x].t)
			return N[x].maxv=N[x].minv=key,void();
		if(pos<=N[L(x)].t) Update(L(x),pos,key);
		else Update(R(x),pos,key);
		N[x].maxv=max(N[L(x)].maxv,N[R(x)].maxv);
		N[x].minv=min(N[L(x)].minv,N[R(x)].minv);
	}
	inline int Querymax(int x,int left,int right){
		if(N[x].s>right||N[x].t<left) return -Inf;
		if(N[x].s>=left&&N[x].t<=right) return N[x].maxv;
		return max(Querymax(L(x),left,right),Querymax(R(x),left,right));
	}
	inline int Querymin(int x,int left,int right){
		if(N[x].s>right||N[x].t<left) return Inf;
		if(N[x].s>=left&&N[x].t<=right) return N[x].minv;
		return min(Querymin(L(x),left,right),Querymin(R(x),left,right));
	}
	void operator ()(){
		for(int i=1;i<=n;++i)
			Read_int(A[i]);
		Build(1,1,n);
		for(int i=1,x;i<=n;++i)
			Read_int(x);
		for(int i=1,op,l,r;i<=p;++i){
			Read_int(op);
			Read_int(l);
			Read_int(r);
			switch(op){
				case 1:Update(1,l,r);break;
				case 2:Read_int(l);break;
				case 3:printf("%d\n",Querymin(1,l,r));break;
				case 4:printf("%d\n",Querymax(1,l,r));break;
			}
		}
	}
};

int main(){
	Work();
	return 0;
}

void Work(){
	int op,l,r,x;
	Null->lch=Null->rch=Null;
	Read_int(n);
	Read_int(p);
	Read_int(m);
	if(m==1) return Solve()();
	S.insert((Node){0,0,0,Null});
	S.insert((Node){n+1,n+1,0,Null});
	for(int i=1;i<=n;++i)
		Read_int(A[i]);
	for(int i=1;i<=n;++i){
		Read_int(x);
		Treap* rt=new Treap;
		rt->Set(A[i],i);
		S.insert((Node){i,i,x,rt});
	}
	for(int i=1;i<=p;++i){
		Read_int(op);
		Read_int(l);
		Read_int(r);
		switch(op){
			case 1:Change(l,r);break;
			case 2:Read_int(x);Assign(l,r,x);break;
			case 3:printf("%d\n",Querymin(l,r));break;
			case 4:printf("%d\n",Querymax(l,r));break;
		}
	}
}

inline SI Split(int x){
	SI it=S.lower_bound((Node){x});
	if(it!=S.end()&&it->l==x) return it;
	--it;int l=it->l,r=it->r,col=it->col;
	Treap* rt=it->rt;S.erase(it);
	Treapair y=Split(rt,x-l);
	S.insert((Node){l,x-1,col,y.first});
	return S.insert((Node){x,r,col,y.second}).first;
}

inline void Assign(int l,int r,int col){
	SI t=Split(r+1),s=Split(l),it=s;
	Treap* rt=it->rt;
	for(++it;it!=t;++it)
		rt=Merge(rt,it->rt);
	S.erase(s,t);
	S.insert((Node){l,r,col,rt});
}

inline void Change(int x,int key){
	SI it=S.lower_bound((Node){x});
	if(it!=S.end()&&it->l==x)
		return Modify(it->rt,x,key);
	--it;Modify(it->rt,x,key);
}

inline int Querymin(int l,int r){
	SI t=Split(r+1),s=Split(l);
	SI a=s,b=s;--b;--t;
	deque<int> q;
	int ans=Inf,sum=0,now=0;
	while(1){
		while(b!=t){
			if(!(c[(++b)->col]++)) ++now;
			if(now>=m){
				sum+=b->rt->lval;
				q.push_back(b->rt->lval);
				break;
			}
			sum+=b->rt->sum;
			q.push_back(b->rt->sum);
		}
		bool shoal=0;
		if(b==t){
			if(now<m) break;
			shoal=1;
		}
		while(1){
			if(!(--c[a->col])){
				--now;break;
			}
			sum-=q.front();
			q.pop_front();++a;
		}
		sum-=q.front();
		q.pop_front();
		ans=min(ans,sum+a->rt->rval);
		if(shoal) break;
		++a;sum-=q.front();
		q.pop_front();
		q.push_front(a->rt->rval);
		sum+=a->rt->rval;
		sum-=q.back();
		q.pop_back();
		q.push_back(b->rt->sum);
		sum+=b->rt->sum;
	}
	while(a->r<t->l) c[(a++)->col]=0;
	c[a->col]=0;
	return (ans>=Inf)?(-1):ans;
}

inline int Querymax(int l,int r){
	SI t=Split(r+1),s=Split(l);
	SI a=s,b=s;int ans=0,sum=0;
	while(b!=t){
		bool shoal=0;
		while((!shoal)&&b!=t){
			if(flag[b->col]) break;
			if(b->l!=b->r){
				sum+=b->rt->lval;
				ans=max(ans,sum);
				ans=max(ans,b->rt->maxv);
				sum=b->rt->rval;
				while(a!=b) flag[(a++)->col]=0;
				shoal=1;
			}else sum+=b->rt->val;
			flag[(b++)->col]=1;
		}
		if(shoal) continue;
		ans=max(ans,sum);
		if(b==t) break;
		while(flag[b->col]){
			flag[a->col]=0;
			sum-=(a++)->rt->rval;
		}
		if(a==b){
			flag[a->col]=1;
			ans=max(ans,a->rt->maxv);
			sum=a->rt->rval;++b;
		}
	}
	while(a->r<t->l) flag[(a++)->col]=0;
	return ans;
}

Treapair Split(Treap* x,int key){
	if(x==Null) return Treapair(Null,Null);
	Treapair y;
	if(x->lch->size>=key){
		y=Split(x->lch,key);
		x->lch=y.second;
		x->Pushup();
		y.second=x;
	}else{
		y=Split(x->rch,key-x->lch->size-1);
		x->rch=y.first;
		x->Pushup();
		y.first=x;
	}
	return y;
}

Treap* Merge(Treap* x,Treap* y){
	if(x==Null) return y;
	if(y==Null) return x;
	if(rand()%(x->size+y->size)<x->size){
		x->rch=Merge(x->rch,y);
		x->Pushup();
		return x;
	}else{
		y->lch=Merge(x,y->lch);
		y->Pushup();
		return y;
	}
}

void Modify(Treap* x,int pos,int key){
	if(x->pos==pos){
		x->sum-=x->val;
		x->val=key;
		x->sum+=key;
		x->Pushup();
		return;
	}
	if(pos<x->pos) Modify(x->lch,pos,key);
	else Modify(x->rch,pos,key);
	x->Pushup();
}

Treap::Treap(){
	Reset();
}

inline void Treap::Reset(){
	val=sum=size=pos=0;
	maxv=lval=rval=0;
	lch=rch=Null;
}

inline void Treap::Set(int key,int p){
	val=sum=maxv=key;
	lval=rval=key;
	size=1;pos=p;
}

inline void Treap::Pushup(){
	size=lch->size+rch->size+1;
	sum=lch->sum+rch->sum+val;
	maxv=max(lch->maxv,rch->maxv);
	maxv=max(maxv,val);
	lval=(lch==Null)?val:lch->lval;
	rval=(rch==Null)?val:rch->rval;
}

inline void Read_int(int& x){
	register char ch;
	while(ch=getchar(),ch<'0');
	x=ch-'0';
	while(ch=getchar(),ch>='0') x=((x+(x<<2))<<1)+ch-'0';
}
```

---

## 作者：GoPoux4 (赞：6)

_推销博客：https://www.cnblogs.com/syc233/p/13673494.html_

---

珂朵莉树+尺取法+线段树。

---

大体思路是珂朵莉树维护颜色段，线段树维护区间和、区间最值，3、4操作在珂朵莉树上做尺取法。

主要说一下尺取法的细节：

#### 操作3

询问区间 $[l,r]$ 中包含所有(一共 $c$ 种)颜色，数字和最小的子区间的数字和。

先将询问区间在珂朵莉树上取出来，固定区间左端点，移动右端点，用桶维护区间内每种颜色的出现次数和区间颜色总数。

当区间包含所有颜色时停止移动右端点，即算出包含所有颜色的最短区间。对于左右端点的位置进行分类讨论：

* 若左右端点同属一个块，即 $c=1$ ，因为要求最小数字和，所以线段树取块内最小值即可。
* 否则，令左端点在块 $[l1,r1]$ 中，右端点在 $[l2,r2]$ 中，则取区间 $[r1,l2]$ 。

```cpp
inline int query1(int l,int r)
{
	IT itr=split(r+1),itl=split(l);
	memset(sta,0,sizeof(sta));cnt=0;
	int ans=INF;
	for(IT l=itl,r=itl;l!=itr;++l)
	{
		while(r!=itr&&cnt!=c)
			Add(r->val,r->r-r->l+1),++r;
		--r;
		if(cnt==c)
		{
			if(l==r) ans=min(ans,st.query_min(1,l->l,l->r));
			else ans=min(ans,st.query_sum(1,l->r,r->l));
		}
		++r;
		Del(l->val,l->r-l->l+1);
	}
	return ans==INF?-1:ans;
}
```

#### 操作4

表示询问区间 $[l,r]$ 中没有重复颜色，数字和最大的子区间的数字和。

首先只取一个数显然是可行的，那么 $ans$ 的初值即为区间最大值。

然后类似操作3，将区间从珂朵莉树上取出来，做尺取法。

因为只取一个数的情况已经处理，所以尺取时左右端点不能在同一个块中。要保证区间中没有重复颜色，那么每次扩展右端点时只能加入大小等于 $1$ 的块 。然而合法区间的右端点是可能在一个大小大于 $1$ 的块中的，因为可以只取这个块的第一个数，在每次扩展完后临时加入这种块即可。

```cpp
inline int query2(int l,int r)
{
	IT itr=split(r+1),itl=split(l);
	memset(sta,0,sizeof(sta));cnt=0;
	int ans=st.query_max(1,l,r);
	for(IT l=itl,r=itl;l!=itr;++l)
	{
		if(l==r)
			Add(r->val,1),++r;
		while(r!=itr&&!sta[r->val]&&r->r-r->l+1==1)
			Add(r->val,1),++r;
		bool flag=false;
		if(r!=itr&&!sta[r->val])
			Add(r->val,1),++r,flag=true;
		--r;
		if(l!=r) ans=max(ans,st.query_sum(1,l->r,r->l));
		Del(l->val,1);
		if(flag)
			Del(r->val,1),--r;// 将临时加入的块删除
		++r;
	}
	return ans;
}
```

---

完整代码就没必要放上来了吧，相信来做这道题的人都会珂朵莉树和线段树。

---

## 作者：喵仔牛奶 (赞：5)

1. 操作 $1$ 显然树状数组。

1. 操作 $2$ 显然直接 ```assign``` 。

1. 操作 $3$ 双指针，类似[P1638 逛画展](https://www.luogu.com.cn/problem/P1638)，向右挪动右指针，并且在满足有所有颜色的情况下向右挪动左指针，最后答案既是最小的 ```query(l->r, r->l)``` 。

1. 操作 $4$ 维护 $sum$ 为 $[l,r]$ 区间长度大于 $2$ 的块数量，因为左右都是取一个，所以在 $sum$ 减去左右指针仍然大于 $0$ 的情况下挪动左指针，最后答案既是最大的 ```query(l->r, r->l)``` 。需要注意的是， $ans$ 的初值需赋值为区间最大的，避免漏统计 $l=r$ 最大的情况。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6 + 5, C = 205;
int a[N], n, q, c, opt, l, r, x;
struct BIT {
	int c[N];
	int lowbit(int x) {
		return x & (-x);
	}
	void updata(int x, int v) {
		int k = v - a[x]; a[x] = v;
		for (int i = x; i <= n; i += lowbit(i))
			c[i] += k;
	}
	ll query(int x) {
		ll ans = 0;
		for (int i = x; i; i -= lowbit(i))
			ans += c[i];
		return ans;
	}
} tree;
ll max(ll x, ll y) {
	return x > y ? x : y;
}
ll query(int l, int r) {
	return tree.query(r) - tree.query(l - 1);
}
struct node {
	int l, r;
	mutable int v;
	node(int L, int R = -1, int V = 0): l(L), r(R), v(V) {}
	bool operator<(const node& o) const {
		return l < o.l;
	}
	int size() const {
		return r - l + 1;
	}
};
typedef set<node>::iterator IT;
set<node> s;
inline int read(){
	int x; char ch;
	while(ch = getchar(), ch < '!'); x = ch - 48;
	while(ch = getchar(), ch > '!') x = (x << 3) + (x << 1) + ch - 48;
	return x;
}
inline void write(int x) {
    if (x == -1) return (void)(putchar('-'), putchar('1'));
	int sta[35], top = 0;
	do sta[top ++] = x % 10, x /= 10; while(x);
	while(top) putchar(sta[-- top] + 48);
}
IT split (int pos) {
    IT it = s.lower_bound(node(pos));
    if(it != s.end() && it->l == pos) return it;
    it--;
    int L = it -> l, R = it -> r;
    int V = it->v;
    s.erase(it);
    s.insert(node(L, pos-1, V));
    return s.insert(node(pos, R, V)).first;
}
bool check(IT itl, IT itr) {
	if (itl == itr) return true;
	++ itl;
	for (IT i = itl; i != itr; ++i)
		if (i->size() > 1) return false;
	return true;
}
void assign(int l, int r, int val = 0) {
    IT itr = split(r + 1), itl = split(l);
    s.erase(itl, itr);
    s.insert(node(l, r, val));
}
ll tow_pointers1(int kl, int kr) {
	ll ans = INT_MAX, cnt[C] = {0}, sum = 0;
	IT itr = split(kr + 1), itl = split(kl);
	for (IT l = itl, r = itl; r != itr; ++ r) {
		if (!cnt[r->v]) sum ++;
		cnt[r->v] ++;
		while (cnt[l->v] > 1)
			cnt[(l ++)->v] --;
		if (sum == c) ans = min(ans, l == r ? *min_element(a + l->l, a + r->r + 1) : query(l->r, r->l));
	}
	return ans == INT_MAX ? -1 : ans;
}
ll tow_pointers2(int kl, int kr) {
    ll ans = *max_element(a + kl, a + kr + 1), cnt[C] = {0}, sum = 0;
    IT itr = split(kr + 1), itl = split(kl);
    for (IT l = itl, r = itl; r != itr; ++ r) {
        if (r->size() > 1) sum ++;
    	cnt[r->v] ++;
		while ((sum - (l->size() > 1) - (r->size() > 1)) > 0 || cnt[r->v] > 1) {
			IT it = l; cnt[(l ++)->v] --, sum -= (it->size() > 1);
		}
    	ans = max(ans, query(l->r, r->l));
    }
    return ans;
}
signed main() {
	cin >> n >> q >> c, s.insert(node(0, 0, -1));
	for (int i = 1; i <= n; i ++)
		tree.updata(i, read());
	for (int i = 1; i <= n; i ++)
		s.insert(node(i, i, read()));
	for (int i = 1; i <= q; i ++) {
		opt = read(), l = read(), r = read();
		if (opt == 1) tree.updata(l, r);
		if (opt == 2) assign(l, r, read());
		if (opt == 3) write(tow_pointers1(l, r)), putchar('\n');
		if (opt == 4) write(tow_pointers2(l, r)), putchar('\n');
	}
	return 0;
}
```


---

## 作者：JiaY19 (赞：5)

[可能更好的阅读体验](https://www.cnblogs.com/mfeitveer/p/15960000.html)

很板子的一道题。

### 思路

由于操作中有关于颜色段相关的操作，又保证了数据随机，所以立马就可以想到 $\text{ODT}$ ，又由于需要单点修改权值，并查询最大值，最小值，权值和，所以可以想到再用线段树去维护。

是不是十分的~~简单~~。

### 实现细节

这里讲一讲一些实现的细节。

对于第三个和第四个查询操作，由于颜色种类不多，所以我们可以考虑用一个桶将所有的颜色种数存下来。

然后就可以用双指针去维护了。

当然，这里讲一个优化。

我们发现，桶在初始全部赋值为零时，并不需要完全把整个桶全部初始化。

只需要颜色种数多一点就可以了。

掌握了这个优化，轻松拿到 $\text{rk1}$（2022.3.5）。

时间复杂度：$O(n \log n^2)$。

实际跑得飞快，只跑了 $933ms$。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 100010;

int n , m , c , a[N] , b[N] , vis[N];

struct ODT
{
    int l , r;
    mutable int v;
    inline bool operator<(const ODT &tmp) const
    {
        return l < tmp.l;
    }
};

set<ODT> odt;

struct ST
{
    int l , r , val , mx , mi;
}t[N * 4];

inline int read()
{
    int asd = 0 , qwe = 1; char zxc;
    while(!isdigit(zxc = getchar())) if(zxc == '-') qwe = -1;
    while(isdigit(zxc)) asd = asd * 10 + zxc - '0' , zxc = getchar();
    return asd * qwe;
}

inline void push_up(int p)
{
    t[p].val = t[p * 2].val + t[p * 2 + 1].val;
    t[p].mx = min(t[p * 2].mx , t[p * 2 + 1].mx);
    t[p].mi = max(t[p * 2].mi , t[p * 2 + 1].mi);
}

inline void build(int p , int l , int r)
{
    t[p].l = l , t[p].r = r;
    if(l == r) { t[p].val = t[p].mx = t[p].mi = a[l]; return; }
    build(p * 2 , l , (l + r) / 2);
    build(p * 2 + 1 , (l + r) / 2 + 1 , r);
    push_up(p);
}

inline void update(int p , int k)
{
    if(t[p].l == t[p].r) { t[p].val = t[p].mx = t[p].mi = a[k]; return; }
    if((t[p].l + t[p].r) / 2 >= k) update(p * 2 , k);
    else update(p * 2 + 1 , k); push_up(p);
}

inline int ask1(int p , int l , int r)
{
    if(l <= t[p].l && t[p].r <= r) return t[p].val;
    int ans = 0 , mid = (t[p].l + t[p].r) / 2;
    if(l <= mid) ans += ask1(p * 2 , l , r); 
    if(r > mid) ans += ask1(p * 2 + 1 , l , r);
    return ans;
}

inline int ask2(int p , int l , int r)
{
    if(l <= t[p].l && t[p].r <= r) return t[p].mx;
    int ans = 1e9 , mid = (t[p].l + t[p].r) / 2;
    if(l <= mid) ans = min(ans , ask2(p * 2 , l , r));
    if(r > mid) ans = min(ans , ask2(p * 2 + 1 , l , r));
    return ans;
}

inline int ask3(int p , int l , int r)
{
    if(l <= t[p].l && t[p].r <= r) return t[p].mi;
    int ans = 0 , mid = (t[p].l + t[p].r) / 2;
    if(l <= mid) ans = max(ans , ask3(p * 2 , l , r));
    if(r > mid) ans = max(ans , ask3(p * 2 + 1 , l , r));
    return ans;
}

inline auto split(int p)
{
    if(p > n) return odt.end();
    auto it = --odt.upper_bound((ODT){p , 0 , 0});
    if(it->l == p) return it;
    int l = it->l , r = it->r , v = it->v;
    odt.erase(it) , odt.insert((ODT){l , p - 1 , v});
    return odt.insert((ODT){p , r , v}).first;
}

inline void assign(int l , int r , int val)
{
    auto it2 = split(r + 1) , it1 = split(l);
    odt.erase(it1 , it2) , odt.insert((ODT){l , r , val});
}

inline int query1(int l , int r)
{
    memset(vis , 0 , (c+10) * sizeof(int));
    auto it2 = split(r + 1) , it1 = split(l);
    auto ls = it1 , rs = it1; int res = 1 , ans = 2e9; vis[rs->v] = 1;
    while(rs != it2)
    {
        if(res == c)
        {
            if(ls == rs) ans = min(ans , ask2(1 , ls->l , ls->r));
            else ans = min(ans , ask1(1 , ls->r , rs->l));
            vis[ls->v]-- , res -= (vis[ls->v] == 0) , ls++;
        }
        else rs++ , res += (vis[rs->v] == 0) , vis[rs->v]++;
    }
    return (ans == 2e9 ? -1 : ans);
}

inline bool check(set<ODT>::iterator l , set<ODT>::iterator r)
{
    if(l == r || (++l)-- == r) return 0; l++;
    for(auto i = l;i != r;i++) if(i->l != i->r) return 1;
    return 0;
}

inline int query2(int l , int r)
{
    memset(vis , 0 ,(c+10) * sizeof(int));
    int ans = ask3(1 , l , r);
    auto it2 = split(r + 1) , it1 = split(l) , ls = it1 , rs = it1;
    for(;rs != it2;rs++)
    {
        ++vis[rs->v];
        while(check(ls , rs)) vis[ls->v]-- , ls++;
        while(ls != rs && vis[rs->v] > 1) vis[ls->v]-- , ls++;
        if(ls != rs) ans = max(ans , ask1(1 , ls->r , rs->l));
    }
    return ans;
}

int main()
{
    n = read() , m = read() , c = read();
    for(int i = 1;i <= n;i++) a[i] = read();
    for(int i = 1;i <= n;i++) 
    {

        b[i] = read() , odt.insert((ODT){i , i , b[i]});
    }
    build(1  , 1 , n);
    for(int i = 1;i <= m;i++)
    {
        int opt = read();
        if(opt == 1)
        {
            int x = read() , y = read();
            a[x] = y , update(1 , x);
        }
        if(opt == 2)
        {
            int l = read() , r = read() , x = read();
            assign(l , r , x);
        }
        if(opt == 3)
        {
            int l = read() , r = read();
            printf("%d\n" , query1(l , r));
        }
        if(opt == 4)
        {
            int l = read() , r = read();
            printf("%d\n" , query2(l , r));
        }
    }
    return 0;
} 


```

---

## 作者：TheLostWeak (赞：4)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/Luogu5251.html)

**大致题意：** 有单点修改数字和区间着色两种修改操作，询问你某段区间内包含所有颜色且数字和最小的子区间的数字和，或某段区间内没有重复颜色且数字和最大的子区间的数字和。数据随机。

### $ODT$维护颜色

看到区间着色且题目中强调数据随机，容易想到使用[$ODT$](https://www.cnblogs.com/chenxiaoran666/p/ODT.html)去求解。

于是，我们就可以考虑用$ODT$来对颜色进行维护。

### 线段树维护数字和

但是考虑到要求区间数字和，$ODT$就很难搞了。

考虑到我们其实可以对于每个询问，每次找到一个合法区间再询问数字和更新答案。

也就是说，可以把维护颜色和维护数字和分开。

那维护数字和自然可以用**线段树**喽。

其实本来用树状数组似乎更优，但这题由于写法问题可能还会需要求区间$Min$或$Max$，树状数组搞起来就很吃力了。

### 处理询问

以上大致介绍了，可以用线段树维护数字和，$ODT$维护颜色。

接下来，再具体介绍一下如何去处理询问。

考虑到这两种询问实际上都具有单调性，因此可以直接用**双指针**搞。

我们枚举右端点，然后移动左端点。

- 对于第一种询问，我们需要在保证**颜色数量等于$c$**的情况下才能移动左端点，然后在**移动的同时**更新答案（不然统计答案的过程会略显麻烦）。

  而$c=1$的情况可能要特判，直接输出这段区间的最小值。

- 对于第二种询问，我们只需在出现不合法情况，即出现重复颜色时移动左端点。考虑我们此时刚把右端点的颜色加入，若出现重复颜色，必然是由右端点导致的，因此不断移动左端点直至右端点所属颜色出现次数为$1$即可。

  但注意，在处理第二种询问时，一旦出现右端点$Size>1$的情况，我们在统计完其答案后，需将左端点移动到右端点的位置上，不然就会出现重复颜色。

  同理，在统计第二种询问的答案时，要求**左端点的右边界**与**右端点的左边界**之间的区间和，不然同样会出现重复颜色。

  而且，在第二种情况时容易漏考虑单个颜色的贡献，因此要初始化$res$为整段区间的$Max$。

大致就是这些吧。

### 代码

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define N 100000
#define INF 1e9
#define Gmax(x,y) (x<(y)&&(x=(y)))
#define Gmin(x,y) (x>(y)&&(x=(y)))
using namespace std;
int n,c,a[N+5];
class FastIO
{
    private:
        #define FS 100000
        #define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)
        #define pc(c) (C^FS?FO[C++]=c:(fwrite(FO,1,C,stdout),FO[(C=0)++]=c))
        #define tn (x<<3)+(x<<1)
        #define D isdigit(c=tc())
        int T,C;char c,*A,*B,FI[FS],FO[FS],S[FS];
    public:
        I FastIO() {A=B=FI;}
        Tp I void read(Ty& x) {x=0;W(!D);W(x=tn+(c&15),D);} 
        Tp I void write(Ty x) {x<0&&(pc('-'),x=-x);W(S[++T]=x%10+48,x/=10);W(T) pc(S[T--]);}
        Ts I void read(Ty& x,Ar&... y) {read(x),read(y...);}
        Tp I void writeln(Con Ty& x) {write(x),pc('\n');}
        I void clear() {fwrite(FO,1,C,stdout),C=0;}
}F;
class SegmentTree//线段树
{
    private:
        #define STO l,hl,rt<<1
        #define ORZ hl+1,r,rt<<1|1
        #define PU(x) (O[x]=O[x<<1]+O[x<<1|1])
        int n,v[N+5];
        struct Interval//维护区间信息
        {
            int S,Mx,Mn;I Interval(CI s=0,CI mx=-INF,CI mn=INF):S(s),Mx(mx),Mn(mn){}
            I Interval operator + (Con Interval& t) Con {return Interval(S+t.S,max(Mx,t.Mx),min(Mn,t.Mn));}
        }O[N<<2];
        I void Build(CI l,CI r,CI rt)//建树
        {
            if(!(l^r)) return (void)(O[rt]=Interval(v[l],v[l],v[l]));
            RI hl=l+r>>1;Build(STO),Build(ORZ),PU(rt);
        }
        I int qsu(CI l,CI r,CI rt,CI ql,CI qr)//询问区间和
        {
            if(ql<=l&&r<=qr) return O[rt].S;RI hl=l+r>>1;
            return (ql<=hl?qsu(STO,ql,qr):0)+(qr>hl?qsu(ORZ,ql,qr):0);
        }
        I int qmx(CI l,CI r,CI rt,CI ql,CI qr)//询问区间最大值
        {
            if(ql<=l&&r<=qr) return O[rt].Mx;RI hl=l+r>>1,t,res=-INF;
            return ql<=hl&&(t=qmx(STO,ql,qr),Gmax(res,t)),qr>hl&&(t=qmx(ORZ,ql,qr),Gmax(res,t)),res;
        }
        I int qmn(CI l,CI r,CI rt,CI ql,CI qr)//询问区间最小值
        {
            if(ql<=l&&r<=qr) return O[rt].Mn;RI hl=l+r>>1,t,res=INF;
            return ql<=hl&&(t=qmn(STO,ql,qr),Gmin(res,t)),qr>hl&&(t=qmn(ORZ,ql,qr),Gmin(res,t)),res;
        }
    public:
        I void Init(CI x,int* s) {for(RI i=1;i<=x;++i) v[i]=s[i];Build(1,n=x,1);}
        I void Update(CI x,CI y)//单点修改（这里使用非递归写法）
        {
            RI l=1,r=n,rt=1,hl;W(l^r) hl=l+r>>1,x<=hl?(r=hl,rt<<=1):(l=hl+1,(rt<<=1)|=1);
            O[rt]=Interval(y,y,y);W(rt>>=1) PU(rt);
        }
        I int QSum(CI x,CI y) {return qsu(1,n,1,x,y);}
        I int QMax(CI x,CI y) {return qmx(1,n,1,x,y);}
        I int QMin(CI x,CI y) {return qmn(1,n,1,x,y);}
}T;
class ODT
{
    private:
        #define IT set<Il>::iterator
        #define ins insert
        #define era erase
        #define fir first
        #define LB lower_bound
        #define add(x) (!cnt[x]++&&++tot)
        #define del(x) (!--cnt[x]&&--tot)
        int cnt[N+5];
        struct Il//维护区间信息
        {
            int l,r,v;I Il(CI x=0,CI y=0,CI p=0):l(x),r(y),v(p){}
            I bool operator < (Con Il& t) Con {return l<t.l;}
        };set<Il> S;
        I IT Sp(CI x)//分裂操作
        {
            IT t;if((t=S.LB(Il(x)))!=S.end()&&!(t->l^x)) return t;
            RI l=(--t)->l,r=t->r,v=t->v;S.era(t),S.ins(Il(l,x-1,v));
            return S.ins(Il(x,r,v)).fir;
        }
    public:
        I void Init(CI x,int* s)//初始化节点信息 
        {
            for(RI i=(s[0]=s[x+1]=-1,1),t=0;i<=x+2;++i) 
                s[i]^s[i-1]&&(S.insert(Il(t,i-1,s[i-1])),t=i);
        }
        I void Assign(CI x,CI y,CI v)//推平操作
        {
            IT tr=Sp(y+1),tl=Sp(x);S.era(tl,tr),S.ins(Il(x,y,v));
        }
        I int Q1(CI x,CI y)//处理第一种询问
        {
            if(!(c^1)) return T.QMin(x,y);//特判c=1
            memset(cnt,0,sizeof(cnt));IT tr=Sp(y+1),tl=Sp(x),ti=tl;RI t,res=INF,tot=0;//初始化
            W(ti!=tr) {add(ti->v);W(!(tot^c)) t=T.QSum(tl->r,ti->l),Gmin(res,t),del((tl++)->v);++ti;}//移动右端点，在保证颜色数量等于c的情况下才能移动左端点，然后在移动的同时更新答案
            return res==INF?-1:res;//判断是否无解，无解返回-1
        }
        I int Q2(CI x,CI y)//处理第二种询问
        {
            memset(cnt,0,sizeof(cnt));IT tr=Sp(y+1),tl=Sp(x),ti=tl;RI t,res=T.QMax(x,y);//初始化
            W(ti!=tr)
            {
                ++cnt[ti->v];W(ti!=tl&&cnt[ti->v]>1) --cnt[(tl++)->v];//不断移动左端点直至右端点所属颜色出现次数为1
                ti!=tl&&(t=T.QSum(tl->r,ti->l),Gmax(res,t));//更新答案
                if(ti->l^ti->r) W(ti!=tl) --cnt[(tl++)->v];++ti;//当出现右端点Size>1的情况，将左端点移动到右端点的位置上
            }return res;//返回答案
        }
}O;
int main()
{
    RI Qtot,i,op,x,y,z;for(F.read(n,Qtot,c),i=1;i<=n;++i) F.read(a[i]);T.Init(n,a);//读入数据
    for(i=1;i<=n;++i) F.read(a[i]);O.Init(n,a);W(Qtot--)
    {
        switch(F.read(op,x,y),op)//处理操作
        {
            case 1:T.Update(x,y);break;case 2:F.read(z),O.Assign(x,y,z);break;
            case 3:F.writeln(O.Q1(x,y));break;case 4:F.writeln(O.Q2(x,y));break;
        }
    }return F.clear(),0;
}
```

---

## 作者：破忆 (赞：3)

## 【题目大意】
给定数列和每个位置对应的颜色

进行以下操作

1. 改变某个数字

2. 对某一段颜色**区间赋值**

3. 询问某段区间内包含所有颜色的子区间所对应的数字和的最小值

4. 询问某段区间内没有重复颜色的子区间所对应的数字和的最大值

------------


## 【分析】

我们的关注点在**区间赋值**和**数据随机生成**上

自然而然就想到了最可爱的**珂朵莉**树

于是2操作迎刃而解

有珂朵莉树的加持，其他操作暴力即可

### 3操作

要求子区间内要包含所有颜色，维护两个指针即可

j和i代表左右端点，显然i在此段最左边，j在此段最后边

每次i往后走一步，j根据目前数据调整

需要记录当前ij之间各个颜色的数量和颜色的种类数

求区间和可以用**线段树**

### 4操作

与3类似，同样是维护指针，但是细节更多

如果ij相等，应选择当前段内最大值，同样可以用**线段树**维护

如果ij不等，显然i在段左，j在段右

如果i段大小不为1，区间内就不能包含完整的i段了，应同时调整j

1操作就不用多说了，维护线段树时稍微处理一下即可

------------
## 【算法】
珂朵莉树+线段树


------------
## 【代码】
```cpp
#include<bits/stdc++.h>
#define IN inline
#define RE register
#define IT set<node>::iterator
#define ls (k<<1)
#define rs (k<<1|1)
#define mid (l+r>>1)
using namespace std;
const int maxn=1e5+5,maxc=105,INF=2147483647,maxt=maxn<<2;
int n,m,C;
int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
struct node{
	mutable int l,r,c;
	bool operator <(node b)const{return l<b.l;}
}a[maxn],b[maxn];
set<node> s;
int p[maxn],c[maxn];
struct tree{
	int max,s;
}t[maxt];
tree merge(tree l,tree r){
	tree ret;
	ret.s=l.s+r.s;
	ret.max=max(l.max,r.max);
	return ret;
}
void pushup(int k){
	t[k]=merge(t[ls],t[rs]);
}
void build(int k,int l,int r){
	if(l==r){
		t[k].max=t[k].s=p[l];
		return;
	}
	build(ls,l,mid),build(rs,mid+1,r);
	pushup(k);
}
void update(int k,int l,int r,int x,int v){
	if(l==r){
		t[k].max=t[k].s=v;
		return;
	}
	if(x<=mid) update(ls,l,mid,x,v);
	else update(rs,mid+1,r,x,v);
	pushup(k);
}
tree query(int k,int l,int r,int x,int y){
	if(x<=l&&r<=y) return t[k];
	if(y<=mid) return query(ls,l,mid,x,y);
	if(mid<x) return query(rs,mid+1,r,x,y);
	return merge(query(ls,l,mid,x,mid),query(rs,mid+1,r,mid+1,y));
}
IT it1,it2,it;
IN IT split(RE int x){
	it=s.lower_bound((node){x,0,0});
	if(it!=s.end()&&it->l==x) return it;
	--it;
	int l=it->l,r=it->r,v=it->c;
	s.erase(it);
	s.insert((node){l,x-1,v});
	return s.insert((node){x,r,v}).first;
}
void assign(int l,int r,int v){
	it2=split(r+1),it1=split(l);
	s.erase(it1,it2);
	s.insert((node){l,r,v});
}
int d[maxc];
int query1(int l,int r){
	it2=split(r+1),it1=split(l);
	memset(d,0,sizeof d);
	int cnt=0,sum=0,ret=INF,tot=0;
	for(it=it1;it!=it2;++it) b[++tot]=*it;
	for(int i=1,j=1;i<=tot;i++){
		if(!d[b[i].c]) cnt++;
		d[b[i].c]++;
		while(d[b[j].c]>1) d[b[j].c]--,++j;
		if(cnt==C){
			ret=min(ret,query(1,1,n,b[j].r,b[i].l).s);
		}
	}
	return ret==INF?-1:ret;
}
int query2(int l,int r){
	it2=split(r+1),it1=split(l);
	memset(d,0,sizeof d);
	int sum=0,ret=-INF,tot=0;
	for(it=it1;it!=it2;++it){
		if(b[tot].c==it->c) b[tot].r=it->r;
		else b[++tot]=*it;
	}
	for(int i=1,j=1;i<=tot;i++){
		ret=max(ret,query(1,1,n,b[i].l,b[i].r).max);
		d[b[i].c]++;
		while(d[b[i].c]>1&&j!=i) d[b[j].c]-=b[j].r-b[j].l+1,j++;
		if(i!=j) ret=max(ret,query(1,1,n,b[j].r,b[i].l).s);
		d[b[i].c]+=b[i].r-b[i].l;
		if(b[i].r!=b[i].l) while(j!=i) d[b[j].c]-=b[j].r-b[j].l+1,j++;
	}
	return ret;
}
int main(){
	freopen("P5251.in","r",stdin);
	freopen("P5251.out","w",stdout);
	n=read(),m=read(),C=read();
	for(int i=1;i<=n;i++) p[i]=read();
	build(1,1,n); 
	for(int i=1;i<=n;i++) s.insert((node){i,i,read()});
	s.insert((node){n+1,n+1,0});
	for(int i=1,l,r,x,y;i<=m;i++){
		int k=read();
		if(k==1){
			x=read(),y=read();
			update(1,1,n,x,y);
			p[x]=y;
		}else
		if(k==2){
			l=read(),r=read(),y=read();
			assign(l,r,y);
		}else
		if(k==3){
			l=read(),r=read();
			printf("%d\n",query1(l,r));
		}
		else{
			l=read(),r=read();
			printf("%d\n",query2(l,r));
		}
	}
	return 0;
}
```


---

## 作者：KiDDOwithTopTree (赞：2)

[传送门](https://www.luogu.com.cn/problem/P5251)。

这题细节好多…

首先颜色段这部分告诉你数据随机、区间覆盖，就差直接把珂朵莉树告诉你了…

然后数字这部分直接用一个数据结构进行维护就珂以了。

然后我们要思考我们用这个数据结构来干什么。

首先题目写明了它要资瓷单点修改、求区间和。

之后我们思考操作 $3$ 和 $4$：

操作 $3$ 我们把整个区间分为 $\log n$ 个颜色段，然后在这些颜色段上跑尺取就珂以了。因为要特判颜色总数为 $1$ 的情况，所以要查询区间最小值。

操作 $4$ 同样跑尺取查答案。因为要特判只选一个点的情况，所以要查询区间最大值。

综上，我们知道这个数据结构需要资瓷：单点修改、求区间和、查询区间最大值和最小值。因此我们可以使用**线段树**。

瑇码上有很多细节，故放上瑇码（带注释）：

```cpp
#include<iostream>
#include<cstring>
using namespace std;
const int N=1e6+10,INF=0x3f3f3f3f;
struct list{
	int pre,nxt;
	int l,r;
	int val;
};
list ctl[N];
int tot;
int split(int pos){
	for(int p=ctl[0].nxt;p;p=ctl[p].nxt)
		if(ctl[p].l==pos) return p;
		else if(ctl[p].l<pos&&ctl[p].r>=pos){
			int np=++tot;
			ctl[np]=ctl[p];
			ctl[p].nxt=np,ctl[np].pre=p;
			ctl[p].r=pos-1,ctl[np].l=pos;
			ctl[ctl[np].nxt].pre=np;//注意这个要更新
			return np;
		}
	return 0;//记得要返回0号节点
}
//链表版珂朵莉树
void assign(int l,int r,int v){
	int p=split(l),q=split(r+1);//链表版不用考虑指针失效的情况，所以可以先split左再split右
	ctl[p].nxt=q,ctl[q].pre=p,ctl[p].r=r,ctl[p].val=v;
}
struct segment_tree{
	int maxn,minn,val;
};
segment_tree smt[4*N];
inline void pushup(int pos){
	int ls=pos<<1,rs=pos<<1|1;
	smt[pos].maxn=max(smt[ls].maxn,smt[rs].maxn);
	smt[pos].minn=min(smt[ls].minn,smt[rs].minn);
	smt[pos].val=smt[ls].val+smt[rs].val;
}
void modify(int pos,int l,int r,int p,int v){
	if(l==r) return void(smt[pos].maxn=smt[pos].minn=smt[pos].val=v);
	int mid=l+r>>1;
	if(p<=mid) modify(pos<<1,l,mid,p,v);
	else modify(pos<<1|1,mid+1,r,p,v);
	pushup(pos);
}
int query_max(int pos,int l,int r,int ql,int qr){
	if(ql<=l&&r<=qr) return smt[pos].maxn;
	int mid=l+r>>1,ans=0;
	if(ql<=mid) ans=max(ans,query_max(pos<<1,l,mid,ql,qr));
	if(qr>mid) ans=max(ans,query_max(pos<<1|1,mid+1,r,ql,qr));
	return ans;
}
int query_min(int pos,int l,int r,int ql,int qr){
	if(ql<=l&&r<=qr) return smt[pos].minn;
	int mid=l+r>>1,ans=INF;
	if(ql<=mid) ans=min(ans,query_min(pos<<1,l,mid,ql,qr));
	if(qr>mid) ans=min(ans,query_min(pos<<1|1,mid+1,r,ql,qr));
	return ans;
}
int query_sum(int pos,int l,int r,int ql,int qr){
	if(ql<=l&&r<=qr) return smt[pos].val;
	int mid=l+r>>1,ans=0;
	if(ql<=mid) ans+=query_sum(pos<<1,l,mid,ql,qr);
	if(qr>mid) ans+=query_sum(pos<<1|1,mid+1,r,ql,qr);
	return ans;
}
int b[110];
int n,m,c;
int query_maxn(int l,int r){
	memset(b,0,sizeof b);
	int p=split(l),q=split(r+1);
	int ans=query_max(1,1,n,l,r);//先特判只选一个的情况
	for(int i=p,j=p;i!=q;i=ctl[i].nxt){
		if(ctl[j].nxt==i) j=ctl[j].nxt;//注意如果j在i后要移动
		while(j!=q&&!b[ctl[j].val]&&ctl[j].l==ctl[j].r||i==j)//注意当i和j相等时直接可以移动
			b[ctl[j].val]++,j=ctl[j].nxt;//尺取
		bool flag=false;
		if(j==q||b[ctl[j].val]) j=ctl[j].pre,flag=true;//满足条件则j前移并打上标记
		if(i!=j) ans=max(ans,query_sum(1,1,n,ctl[i].r,ctl[j].l));//要判断i和j的关系，否则会越界
		if(flag) j=ctl[j].nxt;//flag为true才移动
		b[ctl[i].val]--;//清空i的影响
	}
	return ans;
}
int query_minn(int l,int r){
	memset(b,0,sizeof b);
	int p=split(l),q=split(r+1);
	int ans=INF,cnt=0;
	for(int i=p,j=p;i!=q;i=ctl[i].nxt){
		while(j!=q&&cnt<=c-1){
			if(!b[ctl[j].val]++) cnt++;//把影响加上
			j=ctl[j].nxt;
		}//尺取
		j=ctl[j].pre;//指针j前移
		if(cnt==c&&i!=j) ans=min(ans,query_sum(1,1,n,ctl[i].r,ctl[j].l));//查询区间和
		if(cnt==c&&i==j) ans=min(ans,query_min(1,1,n,ctl[i].l,ctl[j].r));//相当于c=1，查询区间最小值
		j=ctl[j].nxt;//指针j后移
		if(!--b[ctl[i].val]) cnt--;//消除影响
	}
	return ans==INF?-1:ans;
}
int main(){
	cin>>n>>m>>c;
	for(int i=1;i<=n;i++){
		int x;
		cin>>x;
		modify(1,1,n,i,x);
	}
	for(int i=1;i<=n;i++){
		int x;
		cin>>x;
		ctl[i].pre=i-1;
		ctl[i-1].nxt=i;
		ctl[i].val=x;
		ctl[i].l=ctl[i].r=i;
	}
	ctl[0].pre=tot=n;
	ctl[0].l=n+1,ctl[0].r=0;
	for(int i=1;i<=m;i++){
		int op,l,r,x,y;
		cin>>op;
		switch(op){
			case 1:
				cin>>x>>y;
				modify(1,1,n,x,y);
				break;
			case 2:
				cin>>l>>r>>x;
				assign(l,r,x);
				break;
			case 3:
				cin>>l>>r;
				cout<<query_minn(l,r)<<'\n';
				break;
			case 4:
				cin>>l>>r;
				cout<<query_maxn(l,r)<<'\n';
				break;
		}
	}
}
```

---

## 作者：Hanx16Kira (赞：2)

# P5251 [LnOI2019]第二代图灵机

[Luogu P5251](https://www.luogu.com.cn/problem/P5251)

## Solution

难得一见的数据随机+区间推平的题目，这不用珂朵莉树真的可惜了。

看题目，会发现原数列由数字和颜色两部分组成，并且两部分的数据相互不干扰，因此可以考虑采用不同的数据结构来进行处理。颜色这一类数据因为有区间推平的操作，所以采用珂朵莉树进行维护，而数字这一维看题目有单点修改和区间求和的操作，可以选择线段树或者树状数组进行维护，那么两类修改操作就分析完毕了。

现在需要关注的就变成了 $3,4$ 这两类操作，我们分开来讨论：

* 操作 $3$

  既然要询问区间 $[l,r]$ ，那么我们就现在珂朵莉树上把这一个区间给 `split` 出来再说。因为要统计区间颜色种类，所以需要开一个桶来存储（记得初始化）。注意到 $a_i \ge 1$ ，所以有一个结论：假设 $[l,r]$ 是一个合法区间，并且 $[l,k]$ 是一个比 $[l,r]$ 大的合法区间，那么因为 $a$ 的取值范围，可以得知区间 $[l,r]$ 的数字和一定比区间 $[l,k]$ 的数字和小（因为多出了 $(r,k]$ 这一部分的数字），所以可以考虑采用尺取法来在珂朵莉树上 $\text O(\log n)$ 地求到答案。

  尺取的过程中需要记录一个 $cnt$ 表示目前已有的颜色种类数，那么当 $cnt=c$ 的时候就表示找到了答案，因为 $c=1$ 时 $l$ 和 $r$ 处于同一个区间，所以需要特判一下，此时的答案就是区间 $[l,r]$ 的最小值（因为只选一个最小的数字一定能保证数字和最小）。否则（即 $c \neq 1$ 时），因为要数字和最小，并且区间的左右端点位于 $l$ 和 $r$ 中，所以取 $l$ 的最右侧作为左端点、取 $r$ 的最左侧作为右端点一定是最佳答案，这一段的数字区间和即为答案。

  ```c++
  int query3(int l,int r)//操作3
  {
      mem(mp,0);//mp 用于记录颜色出现次数
      auto itr=split(r+1),itl=split(l);
      auto L=itl,R=itl;int cnt=0,ans=INT_MAX;
      for (;L!=itr;L++)
      {
          while (R!=itr && cnt!=c)//可以右移r
          {
              if (!mp[R->v]++) cnt++;//加入这点的颜色
              R++;
          }
          R--;//上面循环结束的时候是已经不符合条件了，所以R--来到达最后一个符合条件的区间
          if (cnt==c)
          {
              if (L==R) ans=min(ans,queryMin(1,1,n,L->l,L->r));//c=1的情况
              else ans=min(ans,querySum(1,1,n,L->r,R->l));
          }
          R++;
          if (!--mp[L->v]) cnt--;//去除l区间
      }
      return ans==INT_MAX?-1:ans;//如果一次答案都没有更新，就说明没有答案，返回-1
  }
  ```
* 操作 $4$

  与操作 $3$ 类似，也可以用尺取法解决。

  因为只取一个点也是满足题意的答案，所以答案初始化为区间 $[l,r]$ 的最大值。

  因为要求不能有重复的颜色，所以尺取右移 $r$ 的过程中加入的区间只能够是长度为 $1$ 的区间，凡是大于 $1$ 的区间都会存在有两个相同颜色的数。在右移 $r$ 完成后，如果 $r$ 右侧有长度大于 $1$ 的区间，那么可以取这一个区间的左端点来作为答案区间的右端点（因为只取了一个点所以不会导致颜色重复）。更新完答案后将这一个点的影响清除，再右移 $l$ 进行下一步。

  ```c++
  int query4(int l,int r)//操作4
  {
      mem(mp,0);//记录颜色
      auto itr=split(r+1),itl=split(l);
      auto L=itl,R=itl;
      int ans=queryMax(1,1,n,l,r);//初始化为区间最大值
      for (;L!=itr;L++)
      {
          if (L==R) mp[R->v]++,R++;//如果左右端点在同一区间，相当于只取一个点，已经考虑过了所以右移R
          while (R!=itr && !mp[R->v] && R->r-R->l+1==1) mp[R->v]++,R++;//不断加入长度为1的区间
          bool AddNew=0;//记录是否加入了一个长度大于1的区间的左端点
          if (R!=itr && !mp[R->v]) mp[R->v]++,AddNew=1,R++;//可以加入
          R--;
          if (L!=R) ans=max(ans,querySum(1,1,n,L->r,R->l));//更新答案
          mp[L->v]--;//清除l的影响
          if (AddNew) mp[R->v]--,R--;//清除右侧区间的影响
          R++;
      }
      return ans;
  }
  ```

分析完询问操作后，可以发现，我们需要在数字上维护的不仅是单点修改+区间求和，还有区间最值的操作，因为树状数组只能进行求和，不能求区间最值，所以使用线段树可以很好的节省码量。

既然这是道黑题，那来这里的人一定都会珂朵莉树和线段树了吧，所以我就不在这里讲解这两种数据结构了。

### Code

```c++
#include<bits/stdc++.h>
#define mem(a,b) memset(a,b,sizeof a)
#define LC (k<<1)
#define RC ((k<<1)|1)
using namespace std;
template<typename T> void read(T &k)
{
    k=0;T flag=1;char b=getchar();
    while (!isdigit(b)) {flag=(b=='-')?-1:1;b=getchar();}
    while (isdigit(b)) {k=k*10+b-48;b=getchar();}
    k*=flag;
}
const int _SIZE=1e5,_MAXN=1e4;
int n,m,c;
int sum[(_SIZE<<2)+5],minn[(_SIZE<<2)+5],maxn[(_SIZE<<2)+5];
int num[_SIZE+5],col[_SIZE+5];
int mp[_MAXN+5];
void pushup(int k) //线段树标准操作
{
    sum[k]=sum[LC]+sum[RC];
    minn[k]=min(minn[LC],minn[RC]);
    maxn[k]=max(maxn[LC],maxn[RC]);
}
void buildSeq(int k,int l,int r)
{
    if (l==r)
    {
        sum[k]=minn[k]=maxn[k]=num[l];
        return;
    }
    int mid=l+r>>1;
    buildSeq(LC,l,mid);
    buildSeq(RC,mid+1,r);
    pushup(k);
}
void update(int k,int l,int r,int pos,int v)
{
    if (l==r && l==pos)
    {
        sum[k]=minn[k]=maxn[k]=v;
        return;
    }
    if (l>pos || r<pos) return;
    int mid=l+r>>1;
    update(LC,l,mid,pos,v);
    update(RC,mid+1,r,pos,v);
    pushup(k);
}
int querySum(int k,int l,int r,int a,int b)
{
    if (l>b || r<a) return 0;
    if (l>=a && r<=b) return sum[k];
    int mid=l+r>>1;
    return querySum(LC,l,mid,a,b)+querySum(RC,mid+1,r,a,b);
}
int queryMin(int k,int l,int r,int a,int b)
{
    if (l>b || r<a) return INT_MAX;
    if (l>=a && r<=b) return minn[k];
    int mid=l+r>>1;
    return min(queryMin(LC,l,mid,a,b),queryMin(RC,mid+1,r,a,b));
}
int queryMax(int k,int l,int r,int a,int b)
{
    if (l>b || r<a) return -1;
    if (l>=a && r<=b) return maxn[k];
    int mid=l+r>>1;
    return max(queryMax(LC,l,mid,a,b),queryMax(RC,mid+1,r,a,b));
}
struct NODE{//珂朵莉树标准操作
    int l,r;
    mutable int v;
    NODE (int l,int r=0,int v=0) : l(l),r(r),v(v) {}
    bool operator< (const NODE &a) const {return l<a.l;}
};
set<NODE> ctlt;
auto split(int pos)
{
    auto it=ctlt.lower_bound(NODE(pos));
    if (it!=ctlt.end() && it->l==pos) return it;
    it--;
    if (it->r<pos) return ctlt.end();
    int l=it->l,r=it->r,v=it->v;
    ctlt.erase(it);
    ctlt.insert(NODE(l,pos-1,v));
    return ctlt.insert(NODE(pos,r,v)).first;
}
void assign(int l,int r,int v)
{
    auto itr=split(r+1),itl=split(l);
    ctlt.erase(itl,itr);
    ctlt.insert(NODE(l,r,v));
}
void buildCtlt() {for (int i=1;i<=n;i++) ctlt.insert(NODE(i,i,col[i]));}//直接把每个颜色看作区间[i,i]的颜色col[i]
int query3(int l,int r)//操作3
{
    mem(mp,0);//mp 用于记录颜色出现次数
    auto itr=split(r+1),itl=split(l);
    auto L=itl,R=itl;int cnt=0,ans=INT_MAX;
    for (;L!=itr;L++)
    {
        while (R!=itr && cnt!=c)//可以右移r
        {
            if (!mp[R->v]++) cnt++;//加入这点的颜色
            R++;
        }
        R--;//上面循环结束的时候是已经不符合条件了，所以R--来到达最后一个符合条件的区间
        if (cnt==c)
        {
            if (L==R) ans=min(ans,queryMin(1,1,n,L->l,L->r));//c=1的情况
            else ans=min(ans,querySum(1,1,n,L->r,R->l));
        }
        R++;
        if (!--mp[L->v]) cnt--;//去除l区间
    }
    return ans==INT_MAX?-1:ans;//如果一次答案都没有更新，就说明没有答案，返回-1
}
int query4(int l,int r)//操作4
{
    mem(mp,0);//记录颜色
    auto itr=split(r+1),itl=split(l);
    auto L=itl,R=itl;
    int ans=queryMax(1,1,n,l,r);//初始化为区间最大值
    for (;L!=itr;L++)
    {
        if (L==R) mp[R->v]++,R++;//如果左右端点在同一区间，相当于只取一个点，已经考虑过了所以右移R
        while (R!=itr && !mp[R->v] && R->r-R->l+1==1) mp[R->v]++,R++;//不断加入长度为1的区间
        bool AddNew=0;//记录是否加入了一个长度大于1的区间的左端点
        if (R!=itr && !mp[R->v]) mp[R->v]++,AddNew=1,R++;//可以加入
        R--;
        if (L!=R) ans=max(ans,querySum(1,1,n,L->r,R->l));//更新答案
        mp[L->v]--;//清除l的影响
        if (AddNew) mp[R->v]--,R--;//清除右侧区间的影响
        R++;
    }
    return ans;
}
int main()
{
    read(n),read(m),read(c);
    for (int i=1;i<=n;i++) read(num[i]);
    for (int i=1;i<=n;i++) read(col[i]);
    buildSeq(1,1,n);//建线段树
    buildCtlt();//建珂朵莉树
    for (int i=1;i<=m;i++)
    {
        int op,x,y,l,r;read(op);
        if (op==1)
        {
            read(x),read(y);
            update(1,1,n,x,y);
        }
        else if (op==2)
        {
            read(l),read(r),read(y);
            assign(l,r,y);
        }
        else if (op==3)
        {
            read(l),read(r);
            printf("%d\n",query3(l,r));
        }
        else 
        {
            read(l),read(r);
            printf("%d\n",query4(l,r));
        }
    }
    return 0;
}
```

---

## 作者：黑影洞人 (赞：1)

首先题目描述十分清晰，我们只需要抓住几个关键点即可。

- 数据完全随机

- 颜色和数值之间没有必然联系

- 有区间平推操作，并且要在颜色块上操作

于是我们可以想到珂朵莉树维护颜色。

约定：

```cpp
struct Chtholly_tree{
	int l,r;
	mutable int val,max;
	Chtholly_tree(int a=-1,int b=-1,int c=0){l=a,r=b,val=c;}
	bool operator <(const Chtholly_tree &c)const{return l<c.l;}
}; 

#define Chtholly set<Chtholly_tree>::iterator
```
区间平推的操作不详细讲了，现在我讲讲操作三，四。

- 操作三：

对于操作三，我们可以维护双指针。

当左指针的颜色被标记过那么左移左指针直到没有标记。

同时，保证能在尽可能少接触同种颜色，增加对答案的贡献。

调整完左指针后，我们会右移右指针，所有元素至多成为一次左指针，一次右指针，复杂度为 $O(n)$ 更新答案再除以平均块长，乘以树状数组的复杂度，会被降到 $O(\log^2 n)$ 。

这样类似单调队列的操作可以维护颜色单调性，我们称为尺取法。

```cpp
int query(int L,int R){
	int ans=inf,cnt[205]={0},sum=0;
	Chtholly right=split(R+1),left=split(L);
	for(Chtholly l=left,r=left;r!=right;r++){
		if(!cnt[r->val])sum++;
		cnt[r->val]++;
		while(cnt[l->val]>1){cnt[l->val]--;l++;}
		if(sum==c)ans=min(ans,b.ask(l->r,r->l));
	} 
	return ans==inf?-1:ans;
}
```
- 操作四

我们用珂朵莉树维护区间颜色，所以要保证颜色单调性，只需要保证当前指针指向即可。

既然不能有同种颜色，只要限制块长必须唯一，且不与之前出现过的元素重合即可。有了操作三的理论实践，很快就能写出来：

```cpp
int query2(int L,int R){
	int ans=querymax(1,L,R),cnt[205]={0},sum=0;
	Chtholly right=split(R+1),left=split(L);
	for(Chtholly l=left,r=left;r!=right;r++){
		if(r->r-r->l+1>1)sum++;
      //限制块长为1，如果右指针的块长唯二
      //先记录一下，在后面的删除操作删除即可
		cnt[r->val]++;
		while((sum-((l->r-l->l+1)>1)-((r->r-r->l+1)>1)>0)||cnt[r->val]>1){
        //前者为不能出现长度大于1的块（重复颜色）
        //后者为判断左指针的颜色是否唯一，大于1即为出现过重复。
			cnt[l->val]--;
			sum-=((l->r-l->l+1)>1);
			l++;
		}
		ans=max(ans,b.ask(l->r,r->l));
      //每次操作后更新满足题目要求的答案。
	} 
	return ans;
}
```

- 其他部分

本题对于其他数据结构的考察十分裸，详细要求为：

>单点赋值，区间查询最大值，区间和

我们可以用线段树来维护最大值，用树状数组或线段树维护区间和。

```cpp
//线段树维护区间最值
struct Segement_tree{
	int l,r,val;
}s[N]; 
void build(int p,int l,int r){
	s[p].l=l,s[p].r=r;
	if(l==r)return;
	build(lc,l,(l+r)/2);
	build(rc,(l+r)/2+1,r);
}
void pushup(int p){s[p].val=max(s[lc].val,s[rc].val);}
void modify(int p,int v,int k){
	if(s[p].l>v||s[p].r<v)return;
	if(s[p].l==v&&s[p].r==v){s[p].val=k;return;}
	modify(lc,v,k);modify(rc,v,k);
	pushup(p);
}
int querymax(int p,int l,int r){
	if(s[p].l>r||s[p].r<l)return 0;
	if(s[p].l>=l&&s[p].r<=r)return s[p].val;
	return max(querymax(lc,l,r),querymax(rc,l,r));
}
//树状数组维护区间和
struct bit{
	int t[N];
	int lowbit(int x){return x&-x;}
	void add(int x,int v){for(;x<=n;x+=lowbit(x))t[x]+=v;}
	void change(int x,int v){
		int k=v-a[x];a[x]=v;
		modify(1,x,v);
		add(x,k);
	}
	int query(int x){
		int ans=0;
		for(;x;x-=lowbit(x))ans+=t[x];
		return ans;
	}
	int ask(int l,int r){return query(r)-query(l-1);}
}b;
//珂朵莉树维护颜色块并完成进行尺取
set<ct> st;
Chtholly split(int pp){
	Chtholly it=st.lower_bound(ct(pp,0,0));
	if(it!=st.end()&&it->l==pp)return it;
	it--;ct tmp=*it;st.erase(it);
	st.insert(ct(tmp.l,pp-1,tmp.val));
	return st.insert(ct(pp,tmp.r,tmp.val)).first;
}
void assign(int l,int r,int v){
	Chtholly right=split(r+1),left=split(l);
	st.erase(left,right);
	st.insert(ct(l,r,v));
}
int query(int L,int R){
	int ans=inf,cnt[205]={0},sum=0;
	Chtholly right=split(R+1),left=split(L);
	for(Chtholly l=left,r=left;r!=right;r++){
		if(!cnt[r->val])sum++;
		cnt[r->val]++;
		while(cnt[l->val]>1){cnt[(l)->val]--;l++;}
		if(sum==c)ans=min(ans,b.ask(l->r,r->l));
	} 
	return ans==inf?-1:ans;
}
int query2(int L,int R){
	int ans=querymax(1,L,R),cnt[205]={0},sum=0;
	Chtholly right=split(R+1),left=split(L);
	for(Chtholly l=left,r=left;r!=right;r++){
		if(r->r-r->l+1>1)sum++;
		cnt[r->val]++;
		while((sum-((l->r-l->l+1)>1)-((r->r-r->l+1)>1)>0)||cnt[r->val]>1){
			cnt[l->val]--;
			sum-=((l->r-l->l+1)>1);
			l++;
		}
		ans=max(ans,b.ask(l->r,r->l));
	} 
	return ans;
}
```
于是你可以完美的解出这道黑题了。

管理员同志审核题解辛苦了。


---

## 作者：ludan0414 (赞：0)

[原题链接](https://www.luogu.com.cn/problem/P5251)

这题实际上是一道十分考察综合能力的题目，不仅需要扎实的数据结构能力，也需要比较细致的思维。

首先，看到这道题，第一眼翻到了数据范围，看到了**数据完全随机**，于是我们可以直接祭出

### 珂朵莉树!!!

有不熟悉的同学可以自行百度珂朵莉树学习
~~这实际上就是个优雅的暴力~~

我们可以用珂朵莉树维护颜色序列，但是很显然颜色序列和数值序列关系不大，可以分开维护。
于是我们可以整一个线段树来维护数列

接下来说一下四个操作：\
对于操作1，我们可以直接用线段树单点修改\
对于操作2，我们用珂朵莉树区间推平\
对于操作3，我们split完区间之后用双指针，查询所有可能的区间和的最小值\
对于操作4同理，我们用双指针查询所有不包含重复颜色的区间和最大值。

$tips:$ 对于每次查询都使用memset，显然复杂度不可接受。我们可以用一个vector来记录我们所有修改过的点，最后直接遍历vector清零我们的修改。**实测，速度快了1倍。**

然后上代码（有些需要注意的细节我都写到了注释里）：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=0;
const int mod=1e9+7;
namespace io{
    inline ll read(){
        register ll res=0,f=1;
        register char ch=getchar();
        if (ch=='-')	f=-1;
        while (ch<'0'||ch>'9'){
            ch=getchar();
            if (ch=='-')	f=-1;
        }
        while (ch>='0'&&ch<='9'){
            res=res*10+ch-'0';
            ch=getchar();
        }
        return res*f;
    }
    void put(ll a){
        if (a<0){
            a=-a;
            putchar('-');
        }
        if (a/10){
            put(a/10);
        }
        putchar(a%10+'0');
    }
    template<typename T>
    void write(T a){
        if (typeid(a)==typeid(int)||typeid(a)==typeid(ll)){
            put(a);
        }
        if (typeid(a)==typeid(char)){
            putchar(a);
        }
    }
    template<typename T>
        void writearr(T a,int len){
        for (int i=1;i<=len;i++){
            write(a[i]);
            write(' ');
        }
        write('\n');
    }
    template<typename T>
    void readarr(T &a,int len){
        for (int i=1;i<=len;i++){
            a[i]=read();
        }
    }
}
using namespace io;
struct node{
    int l;
    int r;
    mutable ll val;
    bool operator < (const node a)const{
        return l<a.l;
    }
    node(int lp,int rp,ll lv){
        l=lp;
        r=rp;
        val=lv;
    }
    node(int lp){
        l=lp;
    }
};
int a[100001],b[100001];
#define it set<node>::iterator
class Chtholly_Tree{
    set<node> s;
    public:
    it split(int pos){
        it tmp=s.lower_bound(node(pos));
        if (tmp!=s.end()&&tmp->l==pos){
            return tmp;
        }
        tmp--;
        int l=tmp->l,r=tmp->r;
        ll val=tmp->val;
        s.erase(tmp);
        s.insert(node(l,pos-1,val));
        return s.insert(node(pos,r,val)).first;
    }
    void debug(int n){
        for (it i=s.begin();i!=s.end();i++){
            printf("l:%d r:%d val:%lld\n",i->l,i->r,i->val);
        }
    }
    void assign(int l,int r,ll val){
        it itr=split(r+1),itl=split(l);
        s.erase(itl,itr);
        s.insert(node(l,r,val));
    }
    Chtholly_Tree(int a[],int l,int n){
        for (int i=1;i<=l;i++){
            s.insert(node(i,i,a[i]%mod));
        }
        s.insert(node(n+1,n+1,0));
    }
};
struct Node{
    int l,r;
    int sum;
    int mmax;
    int mmin;
}s[400001];
class Segment_Tree{
    void pushup(int num){
        s[num].mmin=min(s[num*2].mmin,s[num*2+1].mmin);
        s[num].mmax=max(s[num*2].mmax,s[num*2+1].mmax);
        s[num].sum=s[num*2].sum+s[num*2+1].sum;
    }
    void build(int num,int l,int r){
        s[num].l=l;
        s[num].r=r;
        if (l==r){
            s[num].sum=s[num].mmin=s[num].mmax=a[l];
            return;
        }
        int mid=(l+r)/2;
        build(num*2,l,mid);
        build(num*2+1,mid+1,r);
        pushup(num);
    }
    public:
    void change(int num,int l,int r,int val){
        if (s[num].l>=l&&s[num].r<=r){
            s[num].sum=s[num].mmax=val;
            return;
        }
        int mid=(s[num].l+s[num].r)/2;
        if (l<=mid) change(num*2,l,r,val);
        if (r>mid)  change(num*2+1,l,r,val);
        pushup(num);
    }
    int asksum(int num,int l,int r){
        if (s[num].l>=l&&s[num].r<=r){
            return s[num].sum;
        }
        int res=0;
        int mid=(s[num].l+s[num].r)/2;
        if (l<=mid) res+=asksum(num*2,l,r);
        if (r>mid)  res+=asksum(num*2+1,l,r);
        return res;
    }
    int askmax(int num,int l,int r){
        if (s[num].l>=l&&s[num].r<=r){
            return s[num].mmax;
        }
        int res=0;
        int mid=(s[num].l+s[num].r)/2;
        if (l<=mid) res=max(res,askmax(num*2,l,r));
        if (r>mid)  res=max(res,askmax(num*2+1,l,r));
        return res;
    }
    int askmin(int num,int l,int r){
        if (s[num].l>=l&&s[num].r<=r){
            return s[num].mmin;
        }
        int res=0x3f3f3f3f;
        int mid=(s[num].l+s[num].r)/2;
        if (l<=mid) res=min(res,askmin(num*2,l,r));
        if (r>mid)  res=min(res,askmin(num*2+1,l,r));
        return res;
    }
    Segment_Tree(int n){
        build(1,1,n);
    }
};
int n,m,c;
int cal[100001];
vector<int> del;
void solve(){
    n=read();m=read();c=read();
    readarr(a,n);
    readarr(b,n);
    Segment_Tree smt(n);
    Chtholly_Tree odt(b,n,n);
    int op;
    while (m--){
        op=read();
        switch (op){
            case 1:{
                int x=read(),y=read();
                //按照题意，用线段树修改
                smt.change(1,x,x,y);
                break;
            }
            case 2:{
                int l=read(),r=read(),y=read();
                //用珂朵莉树推平
                odt.assign(l,r,y);
                break;
            }
            case 3:{
                int l=read(),r=read();
                if (c==1){
                    //如果c=1，需要特判，直接输出区间的和即可，因为反正只有一种颜色
                    write(smt.askmin(1,l,r));
                    write('\n');
                    break;
                }
                del.clear();
                it itr=odt.split(r+1),itl=odt.split(l);
                int res=0x3f3f3f3f,sum=0;
                for (it i=itl;i!=itr;){
                    cal[i->val]++;
                    //标记指针之间这种颜色多了一个
                    del.push_back(i->val);
                    if (cal[i->val]==1) sum++;
                    //sum是已经包含的颜色数量
                    while (sum==c){//维护双指针，这一段满足题意才能算
                        //当满足题意时，由于数都是正的，因此左指针越靠右越好
                        res=min(res,smt.asksum(1,itl->r,i->l));
                        cal[itl->val]--;
                        if (cal[itl->val]==0)   sum--;
                        itl++;
                    }
                    i++;
                }
                if (res==0x3f3f3f3f){
                    write(-1);
                    write('\n');
                }
                else{
                    write(res);
                    write('\n');
                }
                for (int i=0;i<del.size();i++){
                    cal[del[i]]=0;
                }
                break;
            }
            case 4:{
                int l=read(),r=read();
                del.clear();
                it itr=odt.split(r+1),itl=odt.split(l);
                int res=smt.askmax(1,l,r);
                for (it i=itl;i!=itr;){
                    cal[i->val]++;
                    del.push_back(i->val);
                    while (i!=itl&&cal[i->val]!=1){
                        cal[itl->val]--;
                        //要注意不能把这一段颜色全剪没,只留一种颜色
                        itl++;
                    }
                    if (i!=itl){
                        res=max(res,smt.asksum(1,itl->r,i->l));
                    }
                    if(i->l!=i->r){//这个区间的长度不为1
                        while (i!=itl){
                            //继续把左边指针右移
                            cal[itl->val]--;
                            itl++;
                        }
                    }
                    i++;
                }
                write(res);
                write('\n');
                for (int i=0;i<del.size();i++){
                    cal[del[i]]=0;
                }
                break;
            }
        }
    }
}
int main(){
    solve();
    return 0;
}
```
有什么不明白的欢迎私信本蒟蒻一起讨论哦

(((第一篇黑题题解，写的很用心，希望审核大大给过

---

## 作者：ldxcaicai (赞：0)

ODT配合bit和sgt+双指针统计一下就完了。

不会odt的可以看[这里](https://blog.csdn.net/dreaming__ldx/article/details/86551830)

然后$bit$是用来维护区间数字和的。

线段树是用来维护区间数字最值的。

**吐槽：考场上调题调的心态爆炸，结果数据锅了？没事过了就行**

代码：
```cpp
#include<bits/stdc++.h>
#define ri register int
using namespace std;
inline int read(){
    int ans=0;
    char ch=getchar();
    while(!isdigit(ch))ch=getchar();
    while(isdigit(ch))ans=(ans<<1)+(ans<<3)+(ch^48),ch=getchar();
    return ans;
}
const int N=1e5+5;
int n,m,c,a[N],b[N];
struct Node{
    int l,r;
    mutable int v;
    Node(int l,int r=-1,int v=0):l(l),r(r),v(v){}
    friend inline bool operator<(const Node&a,const Node&b){
        return a.l<b.l;
    }
};
set<Node>S;
typedef set<Node>::iterator It;
inline It split(int pos){
    It it=S.lower_bound(pos);
    if(it!=S.end()&&it->l==pos)return it;
    --it;
    if(pos>it->r)return S.end();
    int l=it->l,r=it->r,v=it->v;
    S.erase(it);
    S.insert(Node(l,pos-1,v));
    return S.insert(Node(pos,r,v)).first;
}
inline void assign(int l,int r,int v){
    It R=split(r+1),L=split(l);
    S.erase(L,R),S.insert(Node(l,r,v));
}
namespace Bit{
    int bit[N];
    inline int lowbit(const int&x){return x&-x;}
    inline void update(int x,int v){for(ri i=x;i<=n;i+=lowbit(i))bit[i]+=v;}
    inline int query(int x){int ret=0;for(ri i=x;i;i^=lowbit(i))ret+=bit[i];return ret;}
    inline int query(int l,int r){return query(r)-query(l-1);}
}
namespace SGT{
    #define lc (p<<1)
    #define rc (p<<1|1)
    #define mid (l+r>>1)
    int mn[N<<2],mx[N<<2];
    inline void pushup(int p){mx[p]=max(mx[lc],mx[rc]),mn[p]=min(mn[lc],mn[rc]);}
    inline void build(int p,int l,int r){
        if(l==r){mx[p]=mn[p]=a[l];return;}
        build(lc,l,mid),build(rc,mid+1,r),pushup(p);
    }
    inline int query(int p,int l,int r,int ql,int qr,bool f){
        if(ql<=l&&r<=qr)return f?mn[p]:mx[p];
        if(qr<=mid)return query(lc,l,mid,ql,qr,f);
        if(ql>mid)return query(rc,mid+1,r,ql,qr,f);
        return f?min(query(lc,l,mid,ql,qr,f),query(rc,mid+1,r,ql,qr,f)):max(query(lc,l,mid,ql,qr,f),query(rc,mid+1,r,ql,qr,f));
    }
    inline void update(int p,int l,int r,int k){
        if(l==r){mx[p]=mn[p]=a[l];return;}
        k<=mid?update(lc,l,mid,k):update(rc,mid+1,r,k),pushup(p);
    }
    #undef lc
    #undef rc
    #undef mid
}
inline int query1(int l,int r){
    static int vis[101],cnt=0;
    if(c==1)return SGT::query(1,1,n,l,r,1);
    It R=split(r+1),L=split(l);
    int ret=-1;
    for(ri i=1;i<=c;++i)vis[i]=0;
    cnt=0;
    It ll=L,rr=L,tmp=R;
    --rr;
    --tmp;
    for(;ll!=R;){
        while(rr!=tmp&&cnt!=c){
            ++rr;
            ++vis[rr->v];
            if(vis[rr->v]==1)++cnt;		
        }
        if(cnt^c)break;
        while(cnt==c){
            --vis[ll->v];
            if(vis[ll->v]==0){
                if(ret==-1)ret=Bit::query(ll->r,rr->l);
                else ret=min(ret,Bit::query(ll->r,rr->l));
                --cnt;
            }
            ++ll;
        }
    }
    return ret;
}
inline int query2(int l,int r){
    static int vis[101];
    It R=split(r+1),L=split(l);
    int ret=SGT::query(1,1,n,l,r,0);
    It ll=L,rr=L;
    ++rr;
    for(ri pos;rr!=R;){
        vis[ll->v]=pos=ll->r;
        It tmp=ll;
        while(rr!=R){
            if(vis[rr->v]){
                ret=max(ret,Bit::query(max(vis[rr->v],pos),rr->l-1));
                ret=max(ret,Bit::query(max(pos,vis[rr->v]+1),rr->l));
                if(rr->l!=rr->r)break;
                pos=max(pos,vis[rr->v]+1);
                while(tmp->r!=vis[rr->v]){if(vis[tmp->v]==tmp->r)vis[tmp->v]=0;++tmp;}
                vis[rr->v]=rr->r;
                ++rr;
                continue;
            }
            ret=max(ret,Bit::query(pos,rr->l));
            if(rr->l!=rr->r)break;
            vis[rr->v]=rr->r;
            ++rr;
        }
        for(It tt=ll;tt!=rr;++tt)vis[tt->v]=0;
        ll=rr,++rr;
        if(ll==R)break;
    }
    return ret;
}
int main(){
    n=read(),m=read(),c=read();
    for(ri i=1;i<=n;++i)a[i]=read(),Bit::update(i,a[i]);
    S.insert(Node(0,0,0));
    for(ri i=1;i<=n;++i)b[i]=read(),S.insert(Node(i,i,b[i]));
    S.insert(Node(n+1,n+1,c+1));
    SGT::build(1,1,n);
    for(ri op,l,r,x,y;m;--m){
        op=read();
        switch(op){
            case 1:{
                x=read(),y=read();
                Bit::update(x,y-a[x]),a[x]=y,SGT::update(1,1,n,x);
                break;
            }
            case 2:{
                l=read(),r=read();
                assign(l,r,read());
                break;
            }
            case 3:{
                l=read(),r=read();
                cout<<query1(l,r)<<'\n';
                break;
            }
            case 4:{
                l=read(),r=read();
                cout<<query2(l,r)<<'\n';
                break;
            }
        }
    }
    return 0;
}
```


---

## 作者：Others (赞：0)

挺简单的一道题，感觉有点恶评。

**Solution**：

一个一个操作解决。

操作一：什么东西都能维护，跳过。

操作二：区间推平操作，而且题目中写了保证数据随机，所以考虑珂朵莉树维护。

操作三：

可以发现一个性质：对于每一个左端点，他和他右边的第一个符合条件的右端点组成的区间有可能是答案，~~显然~~因为 $a_i>0$ 而且要求答案最小。而且对于某一个左端点，他右边的左端点对应的右端点大于等于它对应的右端点，因为左端点移动可能导致有种颜色消失，然后就需要右端点去找那个颜色。所以考虑双指针，然后求和，用树状数组或线段树都可以，当然分块应该也可以，不知道会不会被卡。

操作四：

一样有满足双指针的性质，所以一样考虑上述暴力。当然，这里不一定需要双指针。

接下来讲一下本题为什么一定要用双指针：

在出题人的博客中讲到：由于用了珂朵莉树，本题每次操作对应的区间数是 $O(\log n)$ 个，**这是错误的**，CF 上的某位大佬在 CF896E 中提到在第 $k$ 次操作时区间数的期望是 $O(\frac{n}{k})$，总数量的期望为 $O(n\ln n)$，而前几次操作的区间数可能为 $O(n)$，所以本题的双指针做法是**假的**。

但是由于本题的 $c_i$ 很小，所以操作四的暴力不会被卡。而且由于数据随机，操作三写暴力也能过，只是常数很大。注意到这里的 $c_i$ 很小，如果在开始对相邻的相同的颜色合并，~~应该能碾标算（数据随机）~~。

建议手造几组卡暴力的数据 $+$ 把 $c_i$ 的范围开大点。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define wr(x,ch) write(x),putchar(ch)
using namespace std;
namespace IO{
}
using IO::read;
using IO::write;
const int N=200005;
int c[N],n,m,C,op,l,r,x,cnt[N],ans;
struct Snode {
	int l,r,c;
	bool operator<(const Snode &p) const {return l<p.l;}
};set<Snode> b;
auto split(int x) {
	if(x>n) return b.end();
	auto it=--b.upper_bound((Snode){x,x});
	int l=it->l,r=it->r,c=it->c;
	if(x==l) return it;
	b.erase(it);
	b.insert((Snode){l,x-1,c});
	return b.insert((Snode){x,r,c}).first;
}
struct Others {
	struct node {int sum,Max,Min;}tr[N<<1];
	void pushup(int p) {
		tr[p].sum=tr[p<<1].sum+tr[p<<1|1].sum;
		tr[p].Max=max(tr[p<<1].Max,tr[p<<1|1].Max);
		tr[p].Min=min(tr[p<<1].Min,tr[p<<1|1].Min);
	}void build(int l,int r,int p) {
		if(l==r) {
			tr[p].Max=tr[p].Min=tr[p].sum=read();
			return ;
		}
		int mid=l+r>>1;
		build(l,mid,p<<1),build(mid+1,r,p<<1|1);
		pushup(p);
	}int getsum(int s,int t,int l,int r,int p) {
		if(s<=l&&r<=t) return tr[p].sum;
		int mid=l+r>>1,ans=0;
		if(s<=mid) ans+=getsum(s,t,l,mid,p<<1);
		if(t>mid) ans+=getsum(s,t,mid+1,r,p<<1|1);
		return ans;
	}int getmax(int s,int t,int l,int r,int p) {
		if(s<=l&&r<=t) return tr[p].Max;
		int mid=l+r>>1,ans=0;
		if(s<=mid) ans=max(ans,getmax(s,t,l,mid,p<<1));
		if(t>mid) ans=max(ans,getmax(s,t,mid+1,r,p<<1|1));
		return ans;
	}int getmin(int s,int t,int l,int r,int p) {
		if(s<=l&&r<=t) return tr[p].Min;
		int mid=l+r>>1,ans=0;
		if(s<=mid) ans=max(ans,getmin(s,t,l,mid,p<<1));
		if(t>mid) ans=max(ans,getmin(s,t,mid+1,r,p<<1|1));
		return ans;
	}void modify(int x,int y,int l,int r,int p) {
		if(l==r) {
			tr[p].sum=tr[p].Max=tr[p].Min=y;
			return ;
		}
		int mid=l+r>>1;
		if(x<=mid) modify(x,y,l,mid,p<<1);
		else modify(x,y,mid+1,r,p<<1|1);
		pushup(p);
	}
}d;
int main() {
	n=read(),m=read(),C=read();
	d.build(1,n,1);
	for(int i=1;i<=n;i++) c[i]=read(),b.insert((Snode){i,i,c[i]});
	while(m--) {
		op=read(),l=read(),r=read();
		(op==2)&&(x=read());
		if(op==1) d.modify(l,r,1,n,1);
		else if(op==2) {
			auto itr=split(r+1),itl=split(l);
			b.erase(itl,itr);
			b.insert((Snode){l,r,x});
		}else if(op==3) {
			ans=INT_MAX;
			auto itr=split(r+1),itl=split(l),tmp=itl;
			int sum=0;
			for(auto lst=b.end(),i=itl;i!=itr;sum-=cnt[i->c]==1,cnt[i->c]--,lst=i++) {
				if(lst==tmp) {
					sum-=!--cnt[tmp->c]; 
					tmp++;
				}
				while(sum<C&&tmp!=itr) 
					sum+=cnt[tmp->c]==0,cnt[tmp->c]++,tmp++;
				if(sum==C) {
					tmp--;
					if(tmp==i) ans=min(ans,d.getmin(i->l,i->r,1,n,1));
					else ans=min(ans,d.getsum(i->r,tmp->l,1,n,1));
					tmp++;
				}
			}
			printf("%d\n",(ans==INT_MAX?-1:ans));
			for(auto i=itl;i!=itr;i++) cnt[i->c]=0;
		}else {
			auto itr=split(r+1),itl=split(l);
			ans=d.getmax(l,r,1,n,1);
			for(auto &i=itl;i!=itr;i++) {
				auto tmp=i;tmp++;cnt[i->c]=1;
				while(tmp!=itr&&tmp->l==tmp->r&&cnt[tmp->c]==0) cnt[tmp->c]=1,tmp++;
				if(tmp==itr) ans=max(ans,d.getsum(i->r,r,1,n,1));
				else if(cnt[tmp->c]) ans=max(ans,d.getsum(i->r,(tmp->l)-1,1,n,1));
				else ans=max(ans,d.getsum(i->r,tmp->l,1,n,1));
				for(auto j=i;j!=tmp;j++) cnt[j->c]=0;
			} 
			printf("%d\n",ans);
			
		}
	}
	return 0;
}
```

---


# [COCI 2007/2008 #1] STAZA

## 题目描述

一场自行车比赛将在一个国家举行。全国的交通网络由 $n$ 个城市组成，编号为 $1\sim n$，由 $m$ 条双向道路连接。我们定义以下术语：

- 一条路线是一系列道路，当且仅当这些道路每条都从上一条道路的结束城市出发。

- 一条简单路线是指一条不经过一个城市一次以上的道路。

- 环是一条起点与终点相同的简单路线。

对于任意两个城市之间，保证至少有一条路线，且每条整个交通系统中的每条道路最多是一个环的一部分。


你的任务是找到满足以下两个约束条件的最长路线：

- 路线可以从任何城市开始，但必须在城市 $1$ 结束。

- 这条路线可以多次访问同一个城市，但不能经过同一条道路超过一次。

请你输出最长的路线的长度。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $2\le n\le 10^4$，$1\le m\le 2n-2$，$1\le a,b\le n$。

#### 说明

**题目译自 [COCI2007-2008](https://hsin.hr/coci/archive/2007_2008/) [CONTEST #1](https://hsin.hr/coci/archive/2007_2008/contest1_tasks.pdf) *T6 STAZA***

## 样例 #1

### 输入

```
4 3
1 2
1 3
2 4```

### 输出

```
2```

## 样例 #2

### 输入

```
6 6
1 2
1 3
2 4
3 4
3 5
5 6```

### 输出

```
5```

## 样例 #3

### 输入

```
5 6
1 2
2 3
3 4
4 5
5 3
3 1```

### 输出

```
6```

# 题解

## 作者：panyf (赞：13)

提供一个更简单的仙人掌 dp 做法。

设 $f_i$ 表示从 $i$ 点向下走，并且可以回到 $i$，长度的最大值。

$g_i$ 表示不能回到 $i$，长度的最大值。

设 $w=g_i-f_i$。这样就只需求出 $f_i$ 和 $w$，然后 $g_i=f_i+w$。

对于非环边 $(i,j)$，显然不会对 $f_i$ 产生贡献。$w=\max(w,g_j+1)$（表示先走完所有经过 $i$ 的环，然后沿 $(i,j)$ 向下走）。

对于环，对 $f_i$ 的贡献为环的大小加上环上所有点 $j$ 的 $f_j$，设这个贡献为 $u$。再求出 $v$ 表示走到环上某个点 $j$ 然后向下走的最大值。$v=\max(v,\operatorname{dis}(j,i)+\sum_k f_k+g_j)$，其中 $k$ 为 $i$ 到 $j$ 路径上的点（不含 $i$，$j$），从两个方向分别遍历计算即可。则 $w=\max(w,v-u)$。

实现时可以不用建出圆方树，只需要 tarjan 找环即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e4+3,M=4e4+3;
int he[N],to[M],ne[M],dfn[N],low[N],fa[N],id,d[N],g[N],f[N];
void tar(int x){
	int i=he[x],j,k,w=0,u,v,o;
	for(dfn[x]=low[x]=++id;i;i=ne[i])if((j=to[i])!=fa[x]){
		if(!dfn[j]){
			d[j]=d[x]+1,fa[j]=x,tar(j),low[x]=min(low[x],low[j]);
			if(low[j]>dfn[x])w=max(w,g[j]+1);
		}else low[x]=min(low[x],dfn[j]);
	}
	for(i=he[x];i;i=ne[i])if(dfn[j=to[i]]>dfn[x]&&fa[j]!=x){
		for(k=j,u=1,v=0;k!=x;k=fa[k])v=max(v,u+g[k]),u+=f[k]+1;
		for(f[x]+=u,o=u;j!=x;j=fa[j])o-=f[j]+1,v=max(v,o+g[j]);
		w=max(w,v-u);
	}
	g[x]=f[x]+w;
}
int main(){
	int n,m,i,j,t=0;
	scanf("%d%d",&n,&m);
	while(m--){
		scanf("%d%d",&i,&j);
		ne[++t]=he[i],to[t]=j,he[i]=t;
		ne[++t]=he[j],to[t]=i,he[j]=t;
	}
	tar(1),printf("%d",g[1]);
	return 0;
}
```


---

## 作者：一扶苏一 (赞：8)

## 【圆方树】【P6335】[COCI2007-2008#1] STAZA

### Description

给定一个 $n$ 个点 $m$ 条边仙人掌，边权为 $1$，求从 $1$ 出发的每条边最多经过一次的单源最长路。

$1 \leq n \leq 10^4$，$1 \leq m \leq 2n - 2$。图保证联通。

### Analysis

根据套路，碰到仙人掌就先建出它的圆方树。

在圆方树上从 $1$ 出发进行 bfs，只要知道了原图环上两点之间的最大路径长，就可以轻松求出到每个点的最短路。

考虑从某个点 $u$ 进入一个环，再从 $v$ 离开这个环的情况，求 $(u, v)$ 之间路径的最大值。我们注意到在环上行走的时候，对于当前的任意一个节点，都可以先走一遍这个节点所在的环（不包括当前的这个环）然后再回到这个节点。我们考虑这个过程中，由于一直在环上走，对应到园方树上就是一直在走圆方边，而圆圆边代表一条割边，因此是走不了的。换句话说，对于一个节点 $x$，它能带来的额外贡献是在圆方树上以 $x$ 为根的子树中，根所在的极大只有圆方边的连通块的边数。这个值可以在圆方树上通过简单的树形 dp 求出来。

这样就可以按照一般圆方树题的套路轻松求出环上两点间路径长的最大值了，然后在树上进行 bfs 即可。

### Code

```cpp
namespace Fusu {

const int maxn = 20005;

void Init();
void Build();
void Solve();

void Main() {
  Init();
  Build();
  Solve();
}

int n, m;
std::vector<int> ee[maxn];
void Init() {
  qr(n); qr(m);
  for (int u, v; m; --m) {
    qr(u); qr(v);
    ee[u].push_back(v);
    ee[v].push_back(u);
  }
}

int vistime, ncnt;
int low[maxn], dfn[maxn], fa[maxn];
std::vector<int> e[maxn], lop[maxn];

void GetLoop(const int u, int v) {
  e[u].push_back(++ncnt);
  while (v != u) {
    lop[ncnt].push_back(v);
    e[ncnt].push_back(v);
    v = fa[v];
  }
  lop[ncnt].push_back(u);
  std::reverse(lop[ncnt].begin(), lop[ncnt].end());
}

void tarjan(const int u) {
  dfn[u] = low[u] = ++vistime;
  for (auto v : ee[u]) if (dfn[v] == 0) {
    fa[v] = u;
    tarjan(v);
    if (low[v] > dfn[u]) {
      e[u].push_back(v);
    }
    low[u] = std::min(low[u], low[v]);
  } else if (v != fa[u]) {
    low[u] = std::min(low[u], dfn[v]);
  }
  for (auto v : ee[u]) if ((fa[v] != u) && (dfn[v] > dfn[u]))  {
    GetLoop(u, v);
  }
}

int f[maxn];
void dfs(const int u) {
  for (auto v : e[u]) {
    dfs(v);
    if ((u <= n) != (v <= n)) {
      f[u] += f[v] + 1;
    }
  }
}


void Build() {
  ncnt = n;
  tarjan(1);
  dfs(1);
}

int ans;
int sum[maxn], dist[maxn];
std::queue<int> Q;
void Solve() {
  for (int i = n + 1; i <= ncnt; ++i) {
    sum[i] = sum[lop[i][1]] = f[lop[i][1]] + 1;
    for (int j = 2; j < lop[i].size(); ++j) {
      sum[i] = sum[lop[i][j]] = sum[lop[i][j - 1]] + f[lop[i][j]] + 1;
    }
    ++sum[i];
  }
  Q.push(1);
  for (int u, d; !Q.empty(); Q.pop()) {
    ans = std::max(ans, d = dist[u = Q.front()]);
    if (u > n) {
      for (auto v : e[u]) {
        int dd = std::max(sum[v] - f[v], sum[u] - sum[v]) + d;
        dist[v] = dd;
        Q.push(v);
      }
    } else {
      ans = std::max(ans, d + f[u]);
      for (auto v : e[u]) if (v <= n) {
        dist[v] = d + f[u] + 1;
        Q.push(v);
      } else {
        dist[v] = d + f[u] - f[v] - 1;
        Q.push(v);
      }
    }
  }
  qw(ans, '\n');
}

} // namespace Fusu
```



---

## 作者：vеctorwyx (赞：3)

~~建了个奇怪的边双圆方树调了两个小时然后发现做法假了~~

### 做法：dfs

首先，如果形成的图是一棵树的话，那么就是经典的树形 $dp$。

但是因为有环，两点之间可能有多条路径，也可以通过从一个点出发绕一圈再回来的方法刷路径长度。

对于每一个点，记录两个东西：

$dp[i]$ 表示到在点 $i$ 子树（先假装它是子树）内以 $i$ 为终点的最长路径长度；

$od[i]$ 表示在点 $i$ 的子树内从 $i$ 出发最后回到 $i$ 的最长路径长度。

对于每个点的不在同一个环上的子结点，$dp$ 的转移跟树一样，同时不会对 $od$ 产生影响。

由于图是一颗仙人掌，存在环，所以搜的时候会搜到以前的点，这时候就找到了一个环，于是难点就来了：**如何在环上转移**。

首先确定一点，就是一个环上所有的结点都会向环上深度最浅的结点转移，把环上深度最浅的结点称为父结点，其他结点称为子结点。

环上的每个子结点都有且仅有两条路径到达父结点，并且可以到途经的结点的子树内逛一圈，其中较长的一条就是它到父结点的最长路径， 设环上最大的贡献为 $f[i]$。

根据仙人掌的性质易知，每个结点都至多为一个环上的子结点，但可以为多个环上的父结点。

定义环的大小为从环的父结点出发回到父结点的最长路径长度，用 $sz[i]$ 表示。

那么对于结点 $x$（在环上），以它为终点的最长路径就有两种情况（下面说的环都是以 $x$ 为父结点的环）：

1. 其中一个环上的最长路径，加上其他环的大小；

2. 所有环的大小之和。

设所有环的大小和为 $sum$，那么一个环的贡献为 $sum-sz[i]+f[i]$。

而对于非环上的点，也可以视为是一个大小为 0 的环，用同样的方式计算。

处理环的方法有很多，我用的队列。

code：

```
#include<bits/stdc++.h>
using namespace std;
int n, m;
struct node{
	int to, nxt;
}e[100010];
int h[20010], cnt;
void add(int x, int y){
	e[++cnt].to = y;
	e[cnt].nxt = h[x];
	h[x] = cnt;
}
int dep[20010], dp[20010], ji[20010], od[20010];
queue<int>q[20010];
int dfs(int x, int fa){
	dp[x] = 0;//由于dp有可能就等于od，dp初始设为0就可以
	od[x] = 0;
	dep[x] = dep[fa] + 1;
	int goal = -1;//环的父结点
	for(int i = h[x]; i; i = e[i].nxt){
		int y = e[i].to;
		ji[x] = 1;
		if(y == fa)
			continue;
		if(dep[y] != 0 && dep[y] < dep[x]){//找到父结点
			goal = y;
			continue;
		}
		else if(dep[y] != 0)
			continue;
		int qwq = dfs(y, x);
		if(qwq == x){//父结点
			od[x] += ji[x];
			int qwq = 1;
			while(!q[x].empty()){
				int qaq = q[x].front();
				dp[x] = max(dp[x], dp[qaq] + max(qwq, ji[x] - qwq - od[qaq]) - ji[x]);//找最长路径
				qwq += od[qaq] + 1;
				q[x].pop();
			}
		}
		else{
			if(qwq != -1)
				goal = qwq;//在环上且不是父结点
			else
				dp[x] = max(dp[x], dp[y] + 1);//非环
		}
	}
	dp[x] += od[x];
	if(goal > 0)
		q[goal].push(x), ji[goal] += od[x] + 1;//ji记录当前环的大小
	return goal;
}
signed main(){
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= m; i++){
		int x, y;
		scanf("%d%d", &x, &y);
		add(x, y);
		add(y, x);
	}
	int qwq = dfs(1, 0);
	printf("%d\n", dp[1]);
}
```

---

## 作者：flyfreemrn (赞：1)

### [ [COCI 2007/2008 #1] STAZA](https://www.luogu.com.cn/problem/P6335)

仙人掌上 dp。

首先观察题目给的条件，判断出这是一颗仙人掌，将仙人掌建出来。

我们要求从任意一个点出发，回到 $1$ 号点的最长路径，将路径反转考虑，从一号点出发，是个很明显的树上 dp。

因为仙人掌存在环，所以可能出现走下去再走回来的情况，我们定义 dp 数组 $dp_{0/1}$ 分别表示走下去不回来和走下去再回来的最长路径。

我们分别对圆点和方点讨论 dp 的转移。

#### 圆点转移

因为只有圆点的方点儿子才会存在走下去在走回来的情况，所以 $dp_1$ 的转移就是每个方点儿子的 $dp_1$ 的值相加。

对于 $dp_0$，最优的情况是选一个儿子走下去，剩下的儿子能走下去再走回来就走，所以先求出 $dp_{i,1}$，$dp_{i,0}$ 就等于 $\max_{y \in son_x} (dp_{i,1} + dp_{y,0} - dp_{y,1})$。

#### 方点转移

$dp_1$ 的最优情况一定是走一遍环，能往下走再回来就往下走，所以 $dp_1$ 的值就等于所有儿子的 $dp_1$ 相加再加上环长。

$dp_0$ 的转移，我们对每一个儿子考虑，对于儿子 $x$，我们从 $x$ 走下去不回来，然后算出从父亲到儿子的最长路径，最长路径等于环上这一端的距离加上中间的儿子能走就走，所以对于每一个方点我们拆成序列后求出 $dp_1$ 的前缀和，然后对每个儿子求出环上两段路径的最大值再加上当前节点的 $dp_0$。

ACcode:
```
    #include<bits/stdc++.h>
    using namespace std;
    #define ll long long
    #define pir pair<ll,ll>
    #define ls first
    #define rs second
    #define mp make_pair
    #define mod
    #define MAXN 100010
    #define qmod(x) (x>mod?x-mod:x)
    inline ll read(){
        ll x = 0,f = 1;
        char c = getchar();
        while(c < '0'||c > '9'){
            if(c == '-')f = -1;
            c = getchar();
        }
        while(c >= '0'&&c <= '9'){
            x = x*10+c-'0';
            c = getchar();
        }
        return x*f;
    }
    vector <ll> vec1[MAXN],vec2[MAXN];
    ll dfn[MAXN],lst[MAXN];
    ll stp,scc,n,m;
    ll fa[MAXN];


    void make_rol(ll st, ll ed){
        ++ scc;
        vec2[ed].push_back(n + scc);
        ll now = st;
        while(now != ed){
            vec2[n + scc].push_back(now);
            now = fa[now];
        }
    }


    void Tarjan(ll now){
        dfn[now] = lst[now] = ++ stp;
        for(int i = 0;i < vec1[now].size(); ++i){
            ll y = vec1[now][i];
            if(y == fa[now])continue;
            if(!dfn[y]){
                fa[y] = now;
                Tarjan(y);
                lst[now] = min(lst[y], lst[now]);
            }else lst[now] = min(lst[now], dfn[y]);
        }
        for(int i = 0;i < vec1[now].size(); ++i){
            ll y = vec1[now][i];
            if(lst[y] >= dfn[now] && fa[y] != now)make_rol(y, now);
            else if(lst[y] > dfn[now] && fa[y] == now){
                vec2[now].push_back(y);
            }
        }
    }


    ll dp[MAXN][2], pre[MAXN];
    ll ans;
    void dfs(ll now){
        for(int i = 0;i < vec2[now].size(); ++i){
            ll y = vec2[now][i];
            dfs(y);
        }
        if(now <= n){
            for(int i = 0;i < vec2[now].size(); ++i){
                ll y = vec2[now][i];
                if(y > n)dp[now][1] += dp[y][1];
            }
            dp[now][0] = dp[now][1];
            for(int i = 0;i < vec2[now].size(); ++i){
                ll y = vec2[now][i];
                if(y > n)dp[now][0] = max(dp[now][0], dp[now][1] - dp[y][1] + dp[y][0]);
                else dp[now][0] = max(dp[now][0], dp[now][1] + dp[y][0] + 1);
            }
        }else{
            for(int i = 0;i < vec2[now].size(); ++i){
                ll y = vec2[now][i];
                dp[now][1] += dp[y][1];
                if(i == 0)pre[0] = dp[y][1] + 1;
                else pre[i] = pre[i - 1] + dp[y][1] + 1;
            }
            dp[now][0] = dp[now][1];
            for(int i = 0;i < vec2[now].size(); ++i){
                ll y = vec2[now][i];
                ll len = 0;
                if(i > 0)len = max(len, pre[i - 1] + 1);
                else len = max(len, 1ll);
                if(i < vec2[now].size() - 1)len = max(len, pre[vec2[now].size() - 1] - pre[i] + 1);
                else len = max(len, 1ll);
                dp[now][0] = max(dp[now][0], len + dp[y][0]);
            }
            dp[now][1] += vec2[now].size() + 1;
        }  
        // cout << now  << " "  << dp[now][0] << " " << dp[now][1] << endl;
    }


    int main(){
        n = read(),m = read();
        for(int i = 1;i <= m; ++i){
            ll x = read(),y = read();
            vec1[x].push_back(y);
            vec1[y].push_back(x);
        }
        Tarjan(1);
        dfs(1);
        cout << dp[1][0];
        return 0;
    }			
```

---

## 作者：Priestess_SLG (赞：1)

#### 006. [COCI 2007/2008 #1] STAZA

题意是说给定一个仙人掌，求从 $1$ 号点到任意一个点 $x$ 的路径，使得其满足路径上没有重复的边的条件下，路径上边的数目最多。

很复杂，但是仍然可以看作【模板】仙人掌 dp（但是自己独立完成了，开心

考虑套路的建立狭义圆方树，然后考虑 dp。设 $f_i$ 表示圆方树上以 $i$ 点为根的子树中，最长可以走多长。发现转移困难，因此考虑辅助 dp：设 $g_i$ 表示圆方树上以 $i$ 为根的子树中，最长可以走多长，**且必须满足最后回到了 $i$ 结点。**

首先考虑转移 $g$ 数组。因为“多长”中圆方树建立的辅助结点起不到贡献的作用，因此这里重新具体的定义 $g$ 数组：

+ 若 $i\le n$，则 $g$ 数组的定义不做改动。
+ 若 $i>n$，则 $g$ 数组在这里被定义为：其父亲节点 $j$ 点的 $g$ 值所代表的路径中删去所有 $j$ 点后路径的长度最长是多少。很显然根据狭义圆方树的性质，必然有 $j\le n$。

此时考虑转移。很显然对于任意一个 $i$，若 $i$ 在圆方树中为叶子结点，则必有 $g_i=0$。否则，对 $i$ 做分类讨论：

+ 若 $i>n$，则枚举其所有儿子结点 $j$，每一个 $j$ 都在 $i$ 点在原仙人掌上所对应的环上，因此每一个 $j$ 点都会对答案产生 $1$ 的贡献。同时可以让 $i$ 从 $j$ 开始往下走再走回来最后回到 $i$，即每一个 $j$ 点可以走到的路径，都可以被 $i$ 点走到 $j$ 然后走下去，再从环的另一侧从 $j$ 走回 $i$。因此每个 $j$ 还对答案起 $g_j$ 的贡献。
+ 因此转移方程即为：$g_i=\sum\limits_{\text{j is a son of i}}(g_j+1)$。
+ 若 $i\le n$，则对于其儿子结点 $j$，若 $j\le n$ 则 $i,j$ 不同时在任何一个环上，很显然从 $i$ 走到 $j$ 之后就不能再走回来了（$i\leftrightarrow j$ 一条边在原仙人掌上为割边），因此这样的 $j$ 不会对答案产生任何贡献。否则 $j>n$ 即 $j$ 为新加的辅助结点，此时根据定义 $i$ 必然在 $j$ 所对应的环上，因此 $j$ 可以对 $i$ 产生贡献，即 $g_i\leftarrow g_j$。同理，$i$ 到 $j$ 这条路径必然可以从 $j$ 所对应的环上的另一侧走回来，因此这一段路径可以对答案产生贡献。但是此时发现走回来的半段路径已经在 $g_j$ 中统计过了，没有统计的部分仅为 $i\to j$ 这个长度为 $1$ 的段，只需要将她加入到贡献中即可。
+ 因此转移方程即为：$g_i=\sum\limits_{\text{j is a son of i}}[j\le n](g_j+1)$。

上述对 $g$ 的转移方程时间复杂度为 $O(n)$，考虑如何用 $g$ 来辅助对 $f$ 的计算。

首先对于任意一个 $i$，$g_i$ 一定可以直接被计算到 $f_i$ 上。这是显然的，$g_i$ 的定义为 $f_i$ 的子集，因此 $g_i$ 能走的路径一定可以被 $f_i$ 所走到。

否则，根据仙人掌转狭义圆方树后 dp 的套路分为下面的三个部分：

+ 由圆点向圆点转移。
+ 由圆点向方点转移。
+ 由方点向圆点转移。

其中没有（由方点向方点转移）这个过程是因为根据定义可得圆方树上不存在两个相邻的点使得这两个点都为方点。因此只需要考虑上面三种转移。

其中“由圆点向方点转移”这一个步骤可以不处理，到“由方点向圆点转移”时再一起处理。

那么只需要讨论第一种情况和第三种情况。

（$1$）：由圆点向圆点转移。这个过程和树一样，设从 $v$ 点向 $u$ 点转移贡献，则直接 $u$ 点可以先走到所有和其相邻的方点并转移走贡献，然后再走到 $v$ 点，贡献即为 $f_v+g_u$。

（$2$）：由方点向圆点转移。设从 $v$ 点向 $u$ 点转移贡献，则 $v$ 点为方点。则此时需要从 $v$ 点对应的环中非 $u$ 的一个结点 $v’$ 来转移。则此时 $v'$ 点显然不能再走回来了，但是除了 $v’$ 以外所有在对应环上且不是 $u$ 点的点仍然可以继续走下去再转移上来。考虑容斥计算答案，则该部分答案即为 $g_u-g_v$。然后考虑把环上的结点按照顺（逆）时针顺序排序标号，则走到 $v$ 点可以从 $u$ 在环上顺时针方向 / 逆时针方向两种方向走过来，此时计算前缀价值和和后缀价值和，取两种价值的 $\max$ 转移即可。而 $v$ 点往下走的贡献可以继续 dfs 递归处理，处理之后即为 $f_v$。

该部分时间复杂度仍然为 $O(n)$。

因此总时间复杂度为 $O(n)$，可以通过。

```cpp
// #pragma GCC optimize(3,"Ofast","inline")
#include<bits/stdc++.h>
// #define int long long
using namespace std;
const int N=80010;
stack<int>stk;
set<int>Set[N];
vector<int>adj[N],adj2[N],scc[N];
int ind,idx,tot,instk[N],dfn[N],low[N],ins[N],deg[N];
void dfs(int u){
    dfn[u]=low[u]=++idx;
    stk.emplace(u);
    if(!deg[u])scc[++tot].emplace_back(u),Set[u].emplace(tot);
    for(auto &v:adj[u])
        if(dfn[v])low[u]=min(low[u],dfn[v]);
        else{
            dfs(v);
            low[u]=min(low[u],low[v]);
            if(low[v]>=dfn[u]){
                ++tot;
                int t;
                do{
                    t=stk.top();
                    stk.pop();
                    scc[tot].emplace_back(t);
                    Set[t].emplace(tot);
                }while(t!=v);
                scc[tot].emplace_back(u);
                Set[u].emplace(tot);
            }
        }
}
int f[N],n,m,g[N],h[N];
//f[i] 表示 i 为根的子仙人掌中，最长的路径长度是多少
//g[i] 表示 i 为根的子仙人掌里，最多可以往下走多少然后再返回 i
void dfs(int u,int fa){
    int okk=0;
    if(u>n){
        for(int &v:adj2[u])
            if(v!=fa){
                dfs(v,u);
                g[u]+=g[v]+1;
                ++okk;
            }
    }else{
        for(int &v:adj2[u])
            if(v!=fa){
                dfs(v,u);
                if(v>n)g[u]+=g[v]+1,++okk;
            }
    }
}
int up[N];
void dfs0(int u,int fa){
    up[u]=fa;
    for(int &v:adj2[u])
        if(v!=fa)dfs0(v,u);
}
int wtx[N],ufo[N];
void dfs2(int u,int fa){
    if(u<=n)f[u]=g[u];
    ufo[u]=1;
    for(int &v:adj2[u])
        if(v!=fa){
            ufo[v]=1;
            if(v<=n){
                dfs2(v,u);
                f[u]=max(f[u],f[v]+g[u]+1);
            }
            else{
                vector<int>ring;
                int id=-1;
                for(int i=0;i<scc[v-n].size();++i)
                    if(scc[v-n][i]==u){
                        id=i;
                        break;
                    }
                assert(~id);
                for(int i=1;i<scc[v-n].size();++i){
                    id=(id+1)%scc[v-n].size();
                    ring.emplace_back(scc[v-n][id]);
                }
                assert(ring.size()>1);
                vector<int>pre(ring.size()+1,0),suf(ring.size()+1,0);
                pre[0]=g[ring[0]]+1;
                for(int i=1;i<ring.size();++i)pre[i]=pre[i-1]+g[ring[i]]+1;
                suf[ring.size()]=0;
                for(int i=ring.size()-1;~i;--i)suf[i]=suf[i+1]+g[ring[i]]+1;
                suf[ring.size()]=0;
                for(int i=0;i<ring.size();++i){
                    assert(u!=ring[i]);
                    int x=max(i?pre[i-1]:0,suf[i+1]);
                    dfs2(ring[i],v);
                    f[u]=max(f[u],g[u]-g[v]+x+f[ring[i]]);
                }
            }
        }
}
int fa[N];
int find(int x){
    return x==fa[x]?x:fa[x]=find(fa[x]);
}
signed main(){
    cin.tie(0)->sync_with_stdio(false);
    cin>>n>>m;
    for(int i=0;i<m;++i){
        int a,b;cin>>a>>b;
        adj[a].emplace_back(b);
        adj[b].emplace_back(a);
        ++deg[a],++deg[b];
    }
    ind=n;
    for(int i=1;i<=n;++i)
        if(!dfn[i])dfs(i);
    for(int i=1;i<=tot;++i)
        if(scc[i].size()>2){
            ++ind;
            for(int &j:scc[i]){
                adj2[j].emplace_back(ind);
                adj2[ind].emplace_back(j);
            }
        }else{
            ++ind;
            int a=scc[i][0],b=scc[i][1];
            adj2[a].emplace_back(b);
            adj2[b].emplace_back(a);
        }
    dfs(1,0);
    dfs2(1,0);
    cout<<f[1]<<'\n';
    return 0;
}
```

---

## 作者：Erica_N_Contina (赞：1)

## 思路

当我们看到“且每条整个交通系统中的每条道路最多是一个环的一部分”时，我们想到了什么？Tarjan 缩点（虽然本题不需要缩点，但是 Tarjan 这条路我们想对了）。

实际上题目要求的就是一个含有简单环的无向图上的最长路径，满足不经过重边。那么我们很显然可以想到圆方树，这样我们就可以把图转化为一副无环的简单图了。

接下来就是在一副简单图中寻找最长的路径了。这个我们怎么做呢？dfs？实际上是 dp 啦。

首先我们设 $f_i$ 表示从 $i$ 出发的最长路径的长度（注意这里的路径不成环，即不回到 $i$）。如果就此进行 dfs（即 dp），那么很显然不满足无后效性（即我们可以从一个环绕一圈后再回到当前点。不过别放弃，我们还有解决办法——我们预处理出 $g_i$ 为从 $i$ 出发后回到点 $i$ 的最长路径。这样我们就可以借助 $g_i$ 来维护 $f_i$ 了。

那么如何维护 $f_i,g_i$？

考虑边 $(i,j)$，如果它不属于任何环，那么它对 $g_i$ 一定没有贡献。这个很容易证明，就是过去了就没办法回来了，那么最后不可能可以回到起始点。

$f_i=\max(f_i-g_i,f_j+1)+g_i$，这个转移是什么意思呢？这里表示走完所有经过 $i$ 的边，然后再走到 $j$。

对于一条在环上的边 $(i,j)$，那么对于环，对 $g_i$ 的贡献为环的大小加上环上所有点 $x $ 的 $g_x$（虽然一条边只能属于一个环，但是没说一个点只能属于一个环呀）。对 $f_i$ 的贡献，就是先从 $i$ 走到环上的点 $x$（贡献为 $i,x$ 之间的距离），然后从 $x$ 往下走的贡献和（$f_x+g_x$）的最大值。

事实上，考虑上面的 dp 转移过程，我们付发现它和 Tarjan 的过程很像。所以我们直接把 dp 在 Tarjan 中进行即可。

---

知识点：dp，Tarjan，最长路径，圆方图，仙人掌图。（这里列举的是所有有关知识点，不一定全要用到）

```C++
#include<bits/stdc++.h>
#include <queue>
#define rep(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define per(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
#define int long long
#define pii pair<int,int>

#define lc(x) (x<<1)
#define rc(x) (x<<1|1)

#define rd read()
inline int read()
{
	int xx=0,ff=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') ff=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') xx=xx*10+(ch-'0'),ch=getchar();
	return xx*ff;
}
inline void write(int out)
{
	if(out<0) putchar('-'),out=-out;
	if(out>9) write(out/10);
	putchar(out%10+'0');
}

const int N=1e6+15;
const int INF=1e9+5;
const int MOD=998244353;

int n,m;
int nxt[N],h[N],to[N],tot;
int dfn[N],low[N],idx,fa[N],d[N];
int g[N],f[N];

void add(int a,int b){
	nxt[++tot]=h[a],to[tot]=b,h[a]=tot;
}

void tarjan(int x){
	int w=0;
	dfn[x]=low[x]=++idx;
	for(int i=h[x];i;i=nxt[i]){
		int j=to[i];
		if(j==fa[x])continue;
		if(!dfn[j]){
			d[j]=d[x]+1;fa[j]=x;tarjan(j);
			low[x]=min(low[x],low[j]);
			if(low[j]>dfn[x])w=max(w,f[j]+1);
		}else{
			low[x]=min(low[x],dfn[j]);
		}

	}
	for(int i=h[x];i;i=nxt[i]){
		int j=to[i],addg=1,addf=0;//后面两个是记录对g_i和f_i的贡献的临时变量
		if(x==fa[j]||dfn[j]<=dfn[x])continue;
		for(int k=j;k!=x;k=fa[k]){//回溯当前环
			addf=max(addf,addg+f[k]);
			addg+=g[k]+1;
		}
		g[x]+=addg;
		for(int k=addg;j!=x;j=fa[j]){
			k-=g[j]+1,addf=max(addf,k+f[j]);
			w=max(w,addf-addg);
		}

	}
	f[x]=g[x]+w;
	
}

signed main(){
	n=rd,m=rd;
	for(int i=1;i<=m;i++){
		int a=rd,b=rd;
		add(a,b);
		add(b,a);
	}

	tarjan(1);
	// for(int i=1;i<=n;i++)cerr<<f[i]<<' ';
	
	cout<<f[1]<<endl;
}
```




---


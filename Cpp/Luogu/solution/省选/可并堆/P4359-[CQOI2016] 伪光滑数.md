# [CQOI2016] 伪光滑数

## 题目描述

若一个大于 $1$ 的整数 $M$ 的质因数分解有 $k$ 项，其最大的质因子为 $a_k$ ，并且满足 $a_{k}^{k} \le N$，$a_k < 128$，我们就称整数 $M$ 为 $N$ - 伪光滑数。

现在给出 $N$，求所有整数中，第 $K$ 大的 $N$ - 伪光滑数。

### 题意澄清

设 $M = 36 = 2^2 \times 3^2$，则其对应的 $k = 4$，也就是说，对 $M$ 运用唯一分解定理，$M = \prod_{i=1}^n{p_i^{c_i}}$，$k = \sum_{i=1}^n{c_i}$。

第 $K$ 大为字面意思，是真的从大到小第 $K$ 个。

modified by expect2004 2020-11-25，这或许是他退役前对洛谷公共题库的最后一次贡献

## 说明/提示

对于 $30\%$ 的数据，$N \le 10^6$；  
对于 $100\%$ 的数据，$2 \le N \le 10^{18},1 \le K \le 800000$。保证至少有 $K$ 个满足要求的数。

## 样例 #1

### 输入

```
12345 20```

### 输出

```
9167```

# 题解

## 作者：ycyaw (赞：27)

首先我们要发现一个性质，就是**最大的**伪光滑数所有质因数相同。如果一个合法的伪光滑数有不相同的质因数，我们把小的质因数全部换成最大的，需要满足的式子$a_k^k\leq N$中，$k$没有变化，所以这个数仍旧合法，却比原来的数大。

观察到要求的第$K$大的$K$较小，那么我们用堆维护。每次取出最大值，如果这个数最大质因数的幂次大于$1$，那么把其中一个最大质因数换成较小的扔进堆里。由于最大质因数和分解的项数$k$不变，所以始终满足$a_k^k\leq N$。同时也很容易发现这样枚举是没有遗漏和重复的。

$Code\ Below:$
```cpp
#include<bits/stdc++.h>
#define ts cout<<"ok"<<endl
#define int long long
#define hh puts("")
#define pc putchar
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
//char buf[1<<21],*p1=buf,*p2=buf;
using namespace std;
int n,k;
int pr[105]={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,
59,61,67,71,73,79,83,89,97,101,103,107,109,113,127};//31个
struct node{
    int val,p,mi,lim;//值,最大质数,幂次,下个数的限制 
    friend bool operator < (node A,node B){
        return A.val<B.val;
    }
};
priority_queue<node> q; 
inline int read(){
    int ret=0,ff=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') ff=-1;ch=getchar();}
    while(isdigit(ch)){ret=ret*10+(ch^48);ch=getchar();}
    return ret*ff;
}
void write(int x){if(x<0){x=-x,pc('-');}if(x>9) write(x/10);pc(x%10+48);}
void writeln(int x){write(x),hh;}
void writesp(int x){write(x),pc(' ');}
signed main(){
    n=read(),k=read();
    for(int i=1;i<=31;i++){
        int now=pr[i];
        for(int j=1;now<=n;j++,now=now*pr[i])
            q.push((node){now,pr[i],j,i-1});
    }
    while(k--){
        node now=q.top();
        q.pop();
        if(!k){
            write(now.val);
            return 0;
        }
        if(now.mi>1)
            for(int i=1;i<=now.lim;i++)
                q.push((node){now.val/now.p*pr[i],now.p,now.mi-1,i});
    }
    return 0;
}
```


---

## 作者：Saliеri (赞：20)

前言：

这是一篇可持久化左偏树的题解。

为什么题解区里全是暴力，还卡不掉……

理论上如果开小 N ，开大质数个数，暴力就能卡的掉。（但是为什么不卡呢？）

___

首先发现 k 很小，根据这种 k 大题一般的套路，都是对数分类，然后每一个类放一个进堆中，每次取了之后放这类中可能的次大。

那么问题就变成了如何对数分类。对于本题，由于一个类要进行合法性判定，即那个 $a_k^k\leq N$，所以只需要将拥有相同的 $a_k,k$ 的数分作一类即可。

那么如何得到每一个类中的数呢？考虑**对数集 dp**。

我们设集合 $f_{i,j}$ 表示 $k$ 为 $i$，$a_k$ 为第 $k$ 个质数的类中所有的数。

有转移：$f_{i,j} = \sum_{k=1}^j f_{i-1,k}\times pr_j$。其中 $\times$ 表示对这个数集中每个数乘上一个数，$+$ 表示集合的并。

直接这么转移是立方复杂度，考虑优化。

我们又设 $g_{i,j} = \sum_{k=1}^j f_{i,k}$，那么只需要每次 $f_{i,j} = g_{i-1,j},g_{i,j} = g_{i-1,j}\times pr_j + f_{i,j}$ 即可。就降了一维复杂度下来。

现在我们还没有确定用什么数据结构来表示这个数集 DP，但是由于最后求答案的时候需要 pop 最优解，插入次优解——这显然是堆应当做的事情。

进一步的，由于要支持快速合并集合与打标记，所以要使用左偏树。

再进一步的，由于我们要在合并之后保留原先的版本，所以要用可持久化左偏树。

总结一下：

- 我们首先用可持久化左偏树完成数集 Dp，然后将每一个堆的堆顶插入一个堆中。

- 每次取出大堆中的堆顶，将这个元素所在堆的堆顶 pop 掉，然后插入新的堆顶。

- 如此执行 k 次就可以得到最终的答案。

复杂度？对不起，我无法给出一个准确的复杂度，但无论如何这个做法绝对比暴力更值得信赖。

___

代码：

请注意可持久化左偏树下传标记的写法，参照可持久化文艺平衡树。

本人通过拙劣的手段重载了堆的运算符，这样数集 Dp 部分会好看一点。但是这并掩盖不了这个代码丑的事实。
```cpp
#include <queue>
#include <cstdio>
typedef long long ll;
const int maxn = 5e5+5,maxpw = 65,maxpr = 35,pr[maxpr] = {0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127};
inline void swap(int &x,int &y){x ^= y ^= x ^= y;}
ll n,mul[maxn<<5],val[maxn<<5];
int m,ch[maxn<<5][2],dist[maxn<<5],tot;
void cp(int x,int to){dist[to] = dist[x],mul[to] = mul[x],val[to] = val[x],ch[to][0] = ch[x][0],ch[to][1] = ch[x][1];}
void gmul(int &x,ll v){if(!x)return ;int px = x;x = ++tot,cp(px,x),mul[x] *= v,val[x] *= v;}
void psd(int x){if(mul[x] ^ 1)gmul(ch[x][0],mul[x]),gmul(ch[x][1],mul[x]),mul[x] = 1;}
int merge(int x,int y){
	if(!x || !y)return x+y;
	if(val[x] < val[y])swap(x,y);
	int now = ++tot;cp(x,now),psd(now),ch[now][1] = merge(ch[now][1],y);
	if(dist[ch[now][0]] < dist[ch[now][1]])swap(ch[now][0],ch[now][1]);
	return dist[now] = dist[ch[now][1]] + 1,now;
}
ll minn[maxpw][maxpr];
struct Rt{
	int rt;
	Rt(int R=0):rt(R){};
	Rt operator *(int v){int tmp=++tot;cp(rt,tmp),gmul(tmp,v);return tmp;}
	void pop(){psd(rt),rt = merge(ch[rt][0],ch[rt][1]);}
	void operator +=(Rt b){return rt = merge(rt,b.rt),void();}
}f[maxpw][maxpr],g[maxpw][maxpr];
struct Sta{
	ll val;Rt rt;
	Sta(ll v=0,Rt R=Rt()):val(v),rt(R){};
	bool operator <(Sta b)const{return val<b.val;}
};
std :: priority_queue<Sta> q;
int legal[maxpw][maxpr];
int main(){
	scanf("%lld %d",&n,&m);
	for(int j=1;j<=31;++j){
		ll now = 1;
		for(int i=1;;++i){
			if(n/now < pr[j])break;
			now *= pr[j],legal[i][j] = 1;
		}
	}
	for(int i=1;legal[1][i];++i)++tot,val[tot] = pr[i],mul[tot] = 1,g[1][i] = f[1][i] = Rt(tot),g[1][i] += g[1][i-1];
	for(int i=2;i<=60;++i)
		for(int j=1;legal[i][j];++j)
			g[i][j] = f[i][j] = g[i-1][j]*pr[j],g[i][j] += g[i][j-1];
	for(int i=1;i<=60;++i)
		for(int j=1;legal[i][j];++j)
			q.push(Sta(val[f[i][j].rt],f[i][j].rt));
	while(1){
		Sta u = q.top();
		q.pop(),u.rt.pop(),q.push(Sta(val[u.rt.rt],u.rt));
		if(!(--m))return printf("%lld\n",u.val),0;
	}
	return 0;
}
```


---

## 作者：IkunTeddy (赞：5)

# 题目分析

首先，这是一个第 $k$ 大问题，又因为这个 $k$ 较小，所以我们优先考虑 k 路归并。

现在就该考虑，该记录什么进行归并。所以我们就该考虑答案的后效性，这样才能记录出所有答案进行 k 路归并。

通过阅读题目，我们可以很容易的得出答案有且只有两个后效性：

1. 最大素因子
2. 素因子个数

因为素因子是 $O(\log{N})$ 级别，而最大素因子最大为 $127$，所以我们可以考虑将所有后效性记录下来。

所以，我们设 $prime_i$ 为满足题目条件的第 $i$ 小的素数，$f_{i,j}$ 表示最大素因子为 $prime_i$ 且素因子个数为 $j$ 的满足条件的**元素集合**，$P$ 为所有满足题目素数的个数，这里 $P=31$。

这个集合明显可以递推，朴素方程也很简单。

$f_{i,j}= \bigcup\limits_{p=1}^{i-1} \bigcup\limits_{q=1}^{j-1} \{x \times {prime_{i}}^{j-q}\mid x \in f_{p,q} \}$。

我们就需要找一个数据结构支持：

1. 找最大，次大（k 路归并时要用到）。

2. 全局乘（递推时要用）。

3. 快速合并（递推时要用）。

第一个条件明显需要用到堆来维护，而第二个条件直接打懒标记，第三个条件考虑可并堆，而我们又要查询任意集合的值，所以需要保留任意版本，所以我们只能选择**可持久化左偏树**。

现在就是分析时间与空间了。总时间复杂度是 $O({\log{N}}^3 \times P^2)$，这是能就接受的。总空间复杂度也是 $O({\log{N}}^3 \times P^2)$。很明显不能接受，原因是因为合并次数太多了，所以我们考虑优化转移方程的枚举次数。

我们可以发现，其实没有必要枚举枚举 $q$ 这一维，所以考虑优化掉，然后我们可以得到：

$f_{i,j}=\bigcup\limits_{p=1}^{i}\{x \times prime_{i}\mid x \in f_{p,j-1} \}$。

这样，时间复杂度是 $O({\log{N}}^2 \times P^2)$，空间复杂度也是 $O({\log{N}}^2 \times P^2)$。这也开不下，继续优化。

这个方程显然是个前缀集合并，所以我们设 $g_{i,j}=\bigcup\limits_{p=1}^{i}f_{p,j}$。那么就可以得到：

$f_{i,j}=\{x \times prime_{i}\mid x \in g_{i,j-1} \}$。

这样，时间复杂度是 $O({\log{N}}^2 \times P)$，空间复杂度是 $O({\log{N}}^2 \times P)$。

哇，终于优化完了！

接下来就是基础的 k 路归并了。

总时间复杂度 $O({\log{N}}^2 \times P+k\log{N})$。

# Code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=2e5+10;
const int Log=60+10;
const int P=40+10;
ll n;
int k;
int cnt=31,prime[P]={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127};
int vis[P][Log];
int f[P][Log]; //最大质因子为prime[i]的集合，质因子数为j(在这里只用记录这棵左偏树的根)
int g[P][Log]; //前缀f[1~i][j];
// 
struct node{
	int ls,rs;
	ll val;
	int dist;
	ll tag;
}tree[6000000+10];
int nodecnt;
int newnode(ll val){
	int v=++nodecnt;
	tree[v].ls=tree[v].rs=0;
	tree[v].val=val;
	tree[v].dist=1;
	tree[v].tag=1;
	return v;
}
int copynode(int p){
	int v=++nodecnt;
	tree[v]=tree[p];
	return v;
}
int mul(int v,ll k){
	if(!v)return 0;
	v=copynode(v);
	tree[v].tag*=k;
	tree[v].val*=k;
	return v;
}
void pushdown(int v){
	if(tree[v].tag==1)return ;
	tree[v].ls=mul(tree[v].ls,tree[v].tag);
	tree[v].rs=mul(tree[v].rs,tree[v].tag);
	tree[v].tag=1;
}
int merge(int x,int y){
	if(!x||!y)return x|y;
	if(tree[y].val>tree[x].val)swap(x,y);
	x=copynode(x);
	pushdown(x);
	tree[x].rs=merge(tree[x].rs,y);
	if(tree[tree[x].ls].dist<tree[tree[x].rs].dist)swap(tree[x].ls,tree[x].rs);
	tree[x].dist=tree[tree[x].rs].dist+1;
	return x;
}
//
struct Queue{
	ll val;
	int p;
	bool operator < (const Queue &it)const{
		return val<it.val;
	}
};
priority_queue<Queue>que;
signed main(){
	cin>>n>>k;
	for(int i=1;i<=cnt;i++){
		ll s=1;
		for(int j=1;;j++){
			if(n/s<prime[i]){break ;}
			vis[i][j]=1;
			s=s*prime[i];
		}
	}
	for(int i=1;i<=cnt;i++){
		int rt=newnode(prime[i]);
		f[i][1]=rt;
		g[i][1]=merge(g[i-1][1],f[i][1]);
	}
	for(int j=1;j<=60;j++){
		for(int i=1;vis[i][j];i++){
			int rt=mul(g[i][j-1],prime[i]);
			f[i][j]=merge(f[i][j],rt);
			g[i][j]=merge(g[i-1][j],f[i][j]);
			que.push({tree[f[i][j]].val,f[i][j]});
		}
	}
	while(k--){
		Queue x=que.top();
		que.pop();
		if(!k){
			cout<<x.val<<'\n';
			break ;
		}
		pushdown(x.p);
		if(tree[x.p].ls) que.push({tree[tree[x.p].ls].val,tree[x.p].ls});
		if(tree[x.p].rs)que.push({tree[tree[x.p].rs].val,tree[x.p].rs});
	}
	
	return 0;
}
```

---

## 作者：龙翔凤翥 (赞：5)

### 分析：
#### 1.因为伪光滑数的最大质因子要小于128，所以先打出1~128中质数的表．
#### 2. 然后钦定一个最大的质数，不断替换即可（丢进大根堆里面，然后取出一个，替换在丢进去即可）.（因为这样可以遍历到这个数前面的所有比它小的数）
#### 3. 具体来说，设一个四元组[t,x,y,z]表示当前的总乘积为t，x为最大的质数，y表示为x的多少次方，最后一个z表示当前能枚举的右界。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define RN register int
inline int read()
{
    int k=1;int x=0;
    char c=getchar();
    while ((c<'0'||c>'9')&&c!='-')c=getchar();
    if(c=='-')
    k=-1,c=getchar();
    while(c>='0'&&c<='9')
    x=(x<<3)+(x<<1)+c-'0',c=getchar();
    return k*x;
} 
ll N;
int K, p[] = {1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127};
struct Node
{
    ll t;
    int x, y, z;
};
bool operator < (const Node &a, const Node &b)
{
    return a.t < b.t;
}//大根堆
priority_queue<Node> q;
int main ()
{
    N=read(), K=read();
    for(int i=1;i<=31;i++)
    {
        ll tmp = p[i];
        for(RN j = 1; tmp <= N; ++j, tmp *= p[i]) 
            q.push((Node){tmp, p[i], j, i - 1}); 
    }
    while(K--)
    {
        Node now = q.top();
        q.pop();
        if(!K) printf("%lld\n", now.t);//如果到了第k个，则输出．
        else if(now.y > 1)//如果指数>1，则把大质数因子用小质数因子代替，遍历比它小的数
            for(RN i = 1; i <= now.z; ++i)
                q.push((Node){now.t / now.x * p[i], now.x, now.y - 1, i});
    }
    return 0;
}

```


---

## 作者：Shikita (赞：5)

这题既然没有题解，那么小蒟蒻我就来发一篇吧

说实话第一次随机到这道题，感觉思路还是混乱的，看到那个k次就联想到高精幂，然后这时机房大佬过来看了一眼，这不就是可持久化左偏树维护极值吗

一脸黑线的我~~并不知道左偏树~~，也不知道可持久化是什么高级的东西，于是开始开心的打起了暴力

首先看一下题目条件，质数最大不能超过128，那就直接打出一张表来，方便

既然不能超过N，那么就把每个质数的各次逐个加入堆，直到上限（可能非常拗口）然后就可以得到一大群欢脱的质数，因为是要求第K大，那么应该每次都从堆中取出最大的值，换掉一个他的质因子，并且乘上一个比他小的质因子里面最大的（又是非常拗口），那么就可以保证堆里面没有重复的

证明：其实就是一个搜索的思路，每次都用第一个比他小的质数来替换他，那么就相当于搜索过程中不断往下的过程，因为只取比他小的数，并且刚开始堆里面每一个元素的质因数是唯一一定的，所以不会出现重复（好吧有点啰嗦，但是你们看懂就好）


代码
```
//Shikita
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll k,n;
int p[32]={1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127};
struct node
{
    ll val;
    int id,lst,nxt;
    bool operator < (const node &a) const
    {
        return val<a.val;
    }
};
priority_queue<node> q;
int main()
{
    scanf("%lld%lld",&n,&k);
    for(int i=1;i<=31;i++)
    {
    	int j=0;
    	ll tmp=1;
        for(;tmp<=n/p[i];tmp*=p[i],++j);
        struct node x= {tmp,i,j-1,0};
        q.push(x);
    }
    while(--k)
    {
        node x=q.top();q.pop();
        if(x.id)
        {
        	struct node y={x.val/p[x.id]*p[x.id-1],x.id-1,1,x.lst-1};
            q.push(y);
        }
        if(x.nxt)
        {
        	struct node y={x.val/p[x.id+1]*p[x.id],x.id,x.lst+1,x.nxt-1};
            q.push(y);
        }
    }
    node x=q.top();
    printf("%lld",x.val);
    return 0;
}
```
代码很丑，多多包涵，小蒟蒻我就写到这里啦

祝大家noip2018 RP++(来自一个ZJ提高组挂掉初赛的蒟蒻的祝福)

---

## 作者：Yyxxxxx (赞：4)

既然要求最大的，那我们对于$128$以内的所有质数$p_i$，求出最大的$k$使$p_i^k\le N$然后把它们都放到一个大根堆里面。

然后取$K$次，每次都把最大的拿出来。  
假定此时该数的值为$Val$，它的最大质因数为$maxP$，最大质因数次数为$k$。  
$$Val=maxP^k\times other$$
$other$指的是除了最大质因数外其他因数的积

那么如果$k>1$就可以把其中一个$maxP$换为$P,P<maxP$，即：
$$Val=maxP^{k-1}\times P\times other$$
或者写作
$$Val=Val\div maxP\times P$$
把它继续加入堆中，且该数绝对不会和堆中出现过的数重复。   
于是经过$k$次操作，就可以取出第$k$大的了。
## $code$
```cpp
#include<bits/stdc++.h>
using namespace std;
inline long long read()//快读
{
    long long x=0,p=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')p=-1;c=getchar();}
    while(c>='0'&&c<='9') {x=(x<<1)+(x<<3)+(c-48);c=getchar();}
    return x*=p;   
}
long long  n,k;//数据范围大
int p[]={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,
59,61,67,71,73,79,83,89,97,101,103,107,109,113,127};//打表128以内质数
struct node//val，maxp，k如上，而next为使p[i]<maxp最大的i
{
    long long val;
    int maxp,k,next;
    friend bool operator <(node a,node b)
    {
        return a.val<b.val;
    }
};
priority_queue<node>q;//大根堆

int main()
{
    n=read(),k=read();//读入
    for(int i=1;i<=31;i++)//枚举，选出只以p[i]为因数的最大的不大于N的数
    {
        long long now=p[i];
        for(int j=1;now<=n;j++,now*=p[i])
            q.push((node){now,p[i],j,i-1});
    }
    while(k--)//取第k大
    {
        node tmp=q.top();//取出堆顶
        q.pop();
        if(!k)//已经取到第k大了，输出
        {
            printf("%lld",tmp.val);
            system("pause");
            return 0;
        }
        if(tmp.k>1)//最大因数的指数大于1
            for(int i=1;i<=tmp.next;i++)
                q.push((node){tmp.val/tmp.maxp*p[i],tmp.maxp,tmp.k-1,i});
        //枚举所有P使Val=Val/maxP*P，加入堆
    }
    return 0;
}
```


---

## 作者：Leasier (赞：3)

前置芝士：[可持久化左偏树](https://oi-wiki.org/ds/persistent-heap/#_1)

~~终于找到一道 k 短路之外的可持久化左偏树的应用了！~~

考虑从小到大考虑 $\Omega$ 值不同的数。为了方便讨论题目中的第一个条件，我们从小到大枚举在上一个的基础上乘上一个不小于上一个讨论的质数的质数。

于是可以想到对**集合** dp。设 $dp_{i, j}$ 表示 $\Omega$ 值为 $i$ 且最大质因数为 $p_j$ 的数的**集合**。显然，$dp_{i, j} = p_j \displaystyle\sum_{k = 1}^j dp_{i - 1, k}$，其中乘法表示集合中每个数都乘上某个数，加法表示合并两个集合。

前缀并集优化后半部分即可。由于我们需要求前 $K$ 大且 $K$ 较小，我们直接用**可持久化左偏树**维护即可。

~~时间复杂度不会算。~~

代码：
```cpp
#include <iostream>
#include <queue>
#include <cmath>

using namespace std;

typedef long long ll;
typedef __int128 lll;

typedef struct {
	int ls;
	int rs;
	int dis;
	ll mul;
	ll val;
} LeftistTreeNode;

typedef struct PriorityQueueNode_tag {
	ll val;
	int id;
	PriorityQueueNode_tag(ll val_, int id_){
		val = val_;
		id = id_;
	}
} PriorityQueueNode;

const int N = 59 + 7, M = 31, K = 999967 + 7;
int id = 0;
int dp[N][M + 7], prime[M + 7] = {0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127};
LeftistTreeNode tree[K];
priority_queue<PriorityQueueNode> q;

bool operator <(const PriorityQueueNode a, const PriorityQueueNode b){
	return a.val < b.val;
}

inline ll log2(ll n){
	ll ans = log2((double)n);
	while ((1ll << ans) <= n) ans++;
	return ans - 1;
}

inline lll quick_pow_with_max_val(lll x, ll p, ll max_val){
	lll ans = 1;
	while (p){
		if (x > max_val) return max_val + 1;
		if (p & 1){
			ans *= x;
			if (ans > max_val) return max_val + 1;
		}
		x *= x;
		p >>= 1;
	}
	return ans;
}

inline void pushdown(int x){
	if (tree[x].ls != 0){
		int ls = ++id;
		tree[ls] = tree[tree[x].ls];
		tree[x].ls = ls;
		tree[ls].mul *= tree[x].mul;
		tree[ls].val *= tree[x].mul;
	}
	if (tree[x].rs != 0){
		int rs = ++id;
		tree[rs] = tree[tree[x].rs];
		tree[x].rs = rs;
		tree[rs].mul *= tree[x].mul;
		tree[rs].val *= tree[x].mul;
	}
	tree[x].mul = 1;
}

int merge(int x, int y){
	pushdown(x);
	pushdown(y);
	if (x == 0 || y == 0) return x + y;
	int ans = ++id;
	if (tree[x].val < tree[y].val) swap(x, y);
	tree[ans] = tree[x];
	tree[ans].rs = merge(tree[x].rs, y);
	if (tree[tree[ans].ls].dis < tree[tree[ans].rs].dis) swap(tree[ans].ls, tree[ans].rs);
	tree[ans].dis = tree[tree[ans].rs].dis + 1;
	return ans;
}

int main(){
	int k;
	ll n, m;
	cin >> n >> k;
	m = log2(n);
	id++;
	tree[id].mul = tree[id].val = 1;
	dp[0][1] = id;
	q.push(PriorityQueueNode(1, id));
	for (register ll i = 1; i <= m; i++){
		int pre = 0;
		for (register int j = 1; j <= M && quick_pow_with_max_val(prime[j], i, n) <= n; j++){
			pre = merge(pre, dp[i - 1][j]);
			id++;
			tree[id] = tree[pre];
			dp[i][j] = id;
			tree[id].mul *= prime[j];
			tree[id].val *= prime[j];
			q.push(PriorityQueueNode(tree[id].val, id));
		}
	}
	for (register int i = 0; ; ){
		PriorityQueueNode cur = q.top();
		q.pop();
		if (++i == k){
			cout << cur.val;
			break;
		}
		pushdown(cur.id);
		if (tree[cur.id].ls != 0) q.push(PriorityQueueNode(tree[tree[cur.id].ls].val, tree[cur.id].ls));
		if (tree[cur.id].rs != 0) q.push(PriorityQueueNode(tree[tree[cur.id].rs].val, tree[cur.id].rs));
	}
	return 0;
}
```

---

## 作者：konyakest (赞：2)

发一个既简单常数又小的做法。

先考虑固定最大质数（假设是 $397$）时怎么做。

（$397$ 是加强版的最大值）。

我们考虑这样一个质数表：

![](https://cdn.luogu.com.cn/upload/image_hosting/7p9ba8xg.png)

我们用红线表示选了这个数，上面显示的是所有质因子都选 $397$ 的情况。

我们假设有一个指针在这里：

![](https://cdn.luogu.com.cn/upload/image_hosting/w4ammj1b.png)

考虑移动这个指针来得到所有的答案。

每次有两种选择：

- 当前指针右移

![](https://cdn.luogu.com.cn/upload/image_hosting/80h6yca5.png)

- 移动指针到下一行，并右移

![](https://cdn.luogu.com.cn/upload/image_hosting/thdjank9.png)

同时，为了避免重复，我们要保证当前指针所在列不能大于上一行选的位置（也就是说，选出的数的位置单调不增）。

为了保证最大质数固定，最后一行选的位置不能移动。

容易用堆维护这个过程。每次取出值最小的状态，进行以上两种扩展即可。

证明：

- 每种状态**有且仅有只有一种方式**能被扩展到

- 每种状态扩展后的状态一定比这个状态的值要小

然后发现本题最大质因子不固定，把每一种最大质因子都加入初始状态即可。

时间复杂度 $O(k\log k)$，目前是本题和加强版的[最优解](https://www.luogu.com.cn/record/161391733)

代码：

```cpp
constexpr int prs[]={397, 389, 383, 379, 373, 367, 359, 353, 349, 347, 337, 331, 317, 313, 311, 307, 293, 283, 281, 277, 271, 269, 263, 257, 251, 241, 239, 233, 229, 227, 223, 211, 199, 197, 193, 191, 181, 179, 173, 167, 163, 157, 151, 149, 139, 137, 131, 127, 113, 109, 107, 103, 101, 97, 89, 83, 79, 73, 71, 67, 61, 59, 53, 47, 43, 41, 37, 31, 29, 23, 19, 17, 13, 11, 7, 5, 3, 2};

struct DATA{
	int p,   //最大质因子在质数表中的位置
        k,   //最大的数 k 满足 pow(prs[p],k) <= n
	    las, //上一行的位置
        n,m; //指针坐标
	ll val;  //值
	friend bool operator<(const DATA& x,const DATA& y){return x.val<y.val;}
};

priority_queue<DATA> q;

signed main(){
	ll n;
	int k;
	cin>>n>>k;
	int tp=0;
	for(auto i:prs){
		ll j=1;
		int tot=0;
		while(__int128(j)*i<=n){
			j*=i,tot++;
			q.push({tp,tot,sizeof(prs)/sizeof(int)-1,1,tp,j});
		}
		tp++;
	}
	F(i,1,k-1){
		DATA d=q.top();
		q.pop();
		if(d.m<d.las&&d.n<d.k) q.push({d.p,d.k,d.las,d.n,d.m+1,d.val/prs[d.m]*prs[d.m+1]});
		if(d.m!=d.p&&d.n+1<d.k) q.push({d.p,d.k,d.m,d.n+1,d.p+1,d.val/prs[d.p]*prs[d.p+1]});
	}
	cout<<q.top().val<<endl;
	return 0;
}
```

---

## 作者：FreedomKing (赞：1)

### 思路

观察数据范围发现 $K$ 只有 $8\times10^5$，从大往小枚举 $N$ - 伪光滑数显然是可行的。

考虑如何做到补充不漏地枚举，考虑开一个优先队列贪心地维护当前最大的 $N$ - 伪光滑数、其最大质因子、幂次、下个可能的次小伪光滑数的最大质因子，每次取出当前最大的伪光滑数，把其最大的质因子除掉一个并乘上一个较小的质因子放入优先队列。

由于 $a_k<128$，最多只有 $31$ 个质因子，时间可以接受。

### AC Code

```cpp
#include<bits/stdc++.h>
//#pragma GCC optimize("Ofast")
bool M1;
#define look_memory cerr<<abs(&M2-&M1)/1024.0/1024<<" MB\n"
#define look_time cerr<<(clock()-Time)*1.0/CLOCKS_PER_SEC<<'\n'
#define File(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout)
#define int long long
using namespace std;
namespace FreedomKing_qwq{};
using namespace FreedomKing_qwq;
const int N=3e5+5,mN=1e2+5,mod=1e9+7;
namespace FreedomKing_qwq{
#define lowbit(_) (_&-_) 
	struct Tree{
		int tree[N];
		inline void add(int x,int j){
			for(int i=1;i<=x;i+=lowbit(i)) tree[i]+=j;
			return;
		}
		inline int query(int x){
			int ans=0;
			for(int i=x;i>1;i-=lowbit(i)) ans+=tree[i];
			return ans;
		}
	};
	struct Dset{
		int fa[N];
		inline void init(int x){
			for(int i=1;i<=x;i++) fa[i]=i;
			return;
		}
		inline int find(int x){
			return (fa[x]==x?x:fa[x]=find(fa[x]));
		}
		inline void update(int x,int y){
			x=find(x);y=find(y);
			fa[y]=x;
			return;
		}
	};
#define lc (p<<1)
#define rc (p<<1|1)
	inline int qread(){
#define qr qread()
		int x=0,c=getchar(),t=1;
		while(c<'0'||c>'9'){
			t^=(c=='-');
			c=getchar();
		}
		while(c>='0'&&c<='9'){
			x=(x<<3)+(x<<1)+c-'0';
			c=getchar();
		}
		return (t?x:-x);
	}	
	inline void qwrite(int x){
#define qw(_) qwrite(_)
#define qws(_) qw(_),putchar(' ')
#define qwe(_) qw(_),putchar('\n')
		if(x<0) x=-x,putchar('-');
		if(x>9) qwrite(x/10);
		putchar(x%10+'0');
		return;
	}
	inline int qpow(int x,int p,int mod){
		x=(p?x:1);
		mod=(mod?mod:LONG_LONG_MAX);
		int t=1;
		while(p>1){
			if(p&1) t=(t*x)%mod;
			x=(x*x)%mod;
			p>>=1;
		}
		return (x*t)%mod;
	}
	inline int gcd(int x,int y){return (x%y==0?y:gcd(y,x%y));}
	inline int lcm(int x,int y){return (x/gcd(x,y)*y);}
	inline int abss(int x){return (x>=0?x:-x);}
}
const int prime[]={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127};
struct node{
	int val,maxn,p,x;
	inline bool operator<(const node qwq)const{return val<qwq.val;}
};
priority_queue<node>pq;
bool M2;signed main(){
	int n=qr,k=qr;
	for(int i=1;i<=31;i++){
		int cnt=prime[i];
		for(int j=1;cnt<=n;j++){
			pq.push({cnt,prime[i],j,i-1});
			cnt*=prime[i];
		}
	}
	while(k--){
		node cnt=pq.top();
		pq.pop();
		if(!k) return qw(cnt.val),0;
		if(cnt.p>1) for(int i=1;i<=cnt.x;i++) pq.push({cnt.val/cnt.maxn*prime[i],cnt.maxn,cnt.p-1,i});
	}
	return 0;
}
```

---

## 作者：山田リョウ (赞：1)

## [「CQOI2016」伪光滑数](https://www.luogu.com.cn/problem/P4359)

### 题意

若一个正整数 $x$ 的最大素因子 $p$ 与素因子个数（计重）$k$ 满足 $p<128\land p^k\leq n$，则称 $x$ 是伪光滑数，求第 $K$ 大伪光滑数。

$1\leq n\leq 10^{18}, 1\leq k\leq 8\times 10^5$。

### 题解

维护一个优先队列。

初始对于每个 $k$ 找到最大的满足 $p<128\land p^k\leq n$ 的 $p$，将 $p^k$ 丢进队列。 

每次取出最大值并枚举其素因子 $p$ 替换为 $p$ 的前驱再重新加入队列，易见可以覆盖所有伪光滑数且因扩展到每个数的数均大于它所以可以保证弹出的顺序性。于是依次弹出即可，注意要去重。

复杂度较难刻画但容易分析其可过。

[code](https://paste.ubuntu.com/p/pXhcssMrPJ/)

---


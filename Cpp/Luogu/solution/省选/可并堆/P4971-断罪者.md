# 断罪者

## 题目背景

**重阳节**的地狱……

四季映姬·亚玛萨那度（以下简称四季大人）是地狱的最高裁判长，她平时负责给死者定罪，判断让死者去地狱还是天界，或者别的什么地方。

四季大人当然可以轻松地给死者断罪，但是死者太多了，四季大人需要你帮她断罪，以便腾出时间让她对别人进行说教。

## 题目描述

人们的罪恶值$E$由人们**生前所做过的事**和他的**死亡方式**来决定。他们做过的**坏事**都会有一个罪恶值，这些坏事有可能会并入同一个集合，一个集合的罪恶值为该集合中罪恶值最大的坏事的罪恶值，而他们一生做过的事会**互相影响**，我们将他们生前做过的事分为4种，而最后的罪恶值$E$由其中**所有集合的罪恶值的和**决定。

1. 做坏事——有罪恶值，单独为一集合。  
2. 做好事——将一件坏事的罪恶值清零。
3. 忏悔——将指定集合中，最大罪恶值的事罪恶值减少。
4. 认清自己——将两个坏事集合合并。

而死亡方式可分为 *自然死亡* 、*事故死亡* 和 *自杀* 。

1. 自然死亡，没什么影响。
2. 事故死亡，可以免除最大罪恶的坏事集合。
3. 自杀，最大的坏事集合罪恶值翻倍。


## 说明/提示

### 样例 1 解释

一开始有五件坏事，罪恶值分别为 $1.2.3.4.5$，做好事之后，罪恶值分别为 $1.2.0.4.5$，认清自我后，只剩下四个集合，罪恶值分别是 $1.4.0.5$，由于是自然死亡，所以最后的罪恶值 $E=1+4+5=10 \le K \&\& E!=0$，因此输出 $Heaven$

### 样例 2 解释

对于样例2的第一组输入如下图，黑色椭圆代表一个集合，红色为罪恶值，下面为点的编号，由于是事故死亡，可以免去标号5的最大值，故罪恶值为$E=4+5$  
![](https://cdn.luogu.com.cn/upload/pic/72405.png)

### 说明

所有数据均在长整型范围内，对于所有数据，均有$m\le n$,$1\le K$，保证输入不存在负数。  
由于读入数据可能会很大，建议使用较快的读入。

> 约定 ① 对于合并两个集合的操作，至少有一个集合只有一件坏事；
> 约定 ② 这群人不会做好事。

| 测试点编号 |    T    |      n       |  时限  | 约定 |
|:-:|:-:|:-:|:-:|:-:|
|		  1   | $\le10$ |   $\le100$   | $1s$ | ①② |
|		  2   | $\le10$ |   $\le300$   | $1s$ | ①  |
|		  3   | $\le10$ |   $\le500$   | $1s$ |    |
|		  4   | $\le20$ |  $\le1000$   | $1s$ | ①② |
|		  5   | $\le20$ |  $\le3000$   | $1s$ | ①  |
|		  6   | $\le20$ |  $\le7000$   | $1s$ |    |
|		  7   | $\le30$ |  $\le10000$  | $1s$ | ①② |
|		  8   | $\le30$ |  $\le30000$  | $1s$ | ①  |
|		  9   | $\le30$ |  $\le50000$  | $1s$ |    |
|		 10   | $\le30$ |  $\le70000$  | $1s$ | ①② |
|		 11   | $\le10$ | $\le100000$  | $1s$ | ①  |
|		 12   | $\le10$ | $\le150000$  | $1s$ |    |
|		 13   | $\le10$ | $\le200000$  | $1s$ | ①② |
|		 14   | $\le10$ | $\le500000$  | $1s$ | ①  |
|		 15   | $\le10$ | $\le1000000$ | $2s$ |    |
|		 16   | $\le10$ | $\le1000000$ | $2s$ | ①② |
|		 17   | $\le10$ | $\le1000000$ | $2s$ | ①  |
|		 18   | $\le10$ | $\le2000000$ | $2s$ |    |
|		 19   | $\le10$ | $\le2000000$ | $2s$ |    |
|		 20   | $\le10$ | $\le2000000$ | $2s$ |    |
|		 21   | $1$ | $\le2000000$ | $2s$ |  路径压缩  |



## 样例 #1

### 输入

```
1 1 10
5 2
1 2 3 4 5
2 3
4 2 4```

### 输出

```
Heaven 10```

## 样例 #2

### 输入

```
2 2 8
5 4
4 8 7 5 6
4 2 4
2 2
4 2 3
3 3 2
3 2
5 1 2
2 2
3 3 2```

### 输出

```
Hell 9
Gensokyo 0```

## 样例 #3

### 输入

```
2 1 15
5 4
1 2 3 4 5
4 2 3
3 2 100
4 1 4
4 4 1
5 4
1 2 3 4 5
3 2 15
4 2 3
4 1 4
4 3 4```

### 输出

```
Heaven 11
Heaven 9```

# 题解

## 作者：山田リョウ (赞：12)

题目大致就是要让你支持三个操作：
1. 把某个点的权值减小至 $0$
1. 把某个集合的最大值减小至某个值
1. 把某两个集合合并

明显用左偏树，不会的左转模板的题解区。

然后主要讨论该怎么减小权值，其实对于减小权值的这个点，可能需要调整的是他的儿子，因为他本来就比父亲小，然后减小后肯定还会比父亲小，但是儿子就比一定还比他小了，所以我们需要把他的两个儿子合并起来，再和整个堆重新合并一下。

但是我们发现了一个问题，因为把这个点的儿子拿走后他的 dist 也变了，所以我们需要往上调，可是树高是可以达到 $O(n)$ 的啊，其实我们可以直接暴力往上调，调到不能调为止，这样的复杂度还是 $O(\log_2 n)$ 的，因为这样调整的次数是结束调整时那个点的 dist，而树中任何一个点的 dist 都不会超过 $\log_2 n$。

但是本题稍稍有点问题，如果有两个罪恶值相等的坏事，题目没说怎么处理，所以如果你的左偏树写法和题解有区别的话，可能会过不了，于是我限定了一下，要求对于罪恶值相等的坏事，认为编号更小的更坏，在[这里](https://www.luogu.com.cn/problem/U166042)，顺便卡掉了没有路径压缩的并查集。

贴一份我的[代码](https://www.luogu.com.cn/paste/bq3g3hzw)，写法较为奇怪，见谅。由于上面提到的原因导致过不了这道题，但是是可以过掉我重新造的数据的那道题。

---

## 作者：随情英 (赞：10)

###题目修改， 更新题解
###     [原题链接](https://www.luogu.com.cn/problem/P4971)
   浏览这道题，可以看到几个关键词，“ **最大罪恶值** ”，“ **集合** ”，“ **合并** ”。
   所以很容易联想到 **堆** ， **平衡树** 等结构。
    再考虑数据范围 $T≤10$，$n≤2*10^6$ ,时间限制 $1.00s$ ~ $2.00s $.(常数大的平衡树果断排除）。
   
   考虑  $nlogn$ 的 **可并堆** ，最常见的可并堆是 **左偏树** ，$lg$ 也有专门的 **[模板题](https://www.luogu.com.cn/problem/P3377)**，所以我们选择左偏树 。
##    1.合并


**代码：**

```cpp
int merge(int x,int y){
	if(!x||!y)return x+y
	if(val[x]<val[y])swap(x,y);
	r[x]=merge(r[x],y);if(dis[l[x]]<dis[r[x]])swap(l[x],r[x]);
	fa[l[x]]=fa[r[x]]=fa[x]=x,dis[x]=dis[r[x]]+1;
	return x;
}
```
------------

##   2.删除
 **敲重点**
 
在$P3377$中，我们使用的是 **$Pop$（仅删除堆顶），但这里是 $Extract$（支持删除堆中任意节点）。**

**具体实现见代码：**
```cpp
inline void extract(register int x){
    register int L=l[x],R=r[x];
    fa[L]=L,fa[R]=R,l[x]=r[x]=dis[x]=0;
    merge(merge(L,R),get(x));//合并x节点的两个儿子，和它所在集合代表元素。
}
```
**这样操作你就会发现 $x$ 节点不见了。**

------------
接下来就是简单模拟了。
### 代码：



```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define maxn 2000100
using namespace std;
int t,m,n,w;
bool v[maxn]; 
int fa[maxn],l[maxn],r[maxn],dis[maxn];
long long k,val[maxn];
inline int get(int x){return fa[x]==x?x:fa[x]=get(fa[x]);}
int merge(int x,int y){
	if(!x||!y)return x+y;
	if(val[x]<val[y]||val[x]==val[y]&&x>y)swap(x,y);
	r[x]=merge(r[x],y);if(dis[l[x]]<dis[r[x]])swap(l[x],r[x]);
	fa[l[x]]=fa[r[x]]=fa[x]=x,dis[x]=dis[r[x]]+1;
	return x;
}
inline void extract(register int x){
    register int L=l[x],R=r[x];
    fa[L]=L,fa[R]=R,l[x]=r[x]=dis[x]=0;
    merge(merge(L,R),get(x));
}
inline void clear(){
    fa[0]=dis[0]=l[0]=r[0]=0;
    memset(v,0,sizeof(v));
}
int main(){
    scanf("%d%d%d",&t,&w,&k);
    while(t--){
        clear(); 
        scanf("%d%d",&n,&m);
        for(register int i=1;i<=n;i++){
        	scanf("%lld",&val[i]);
			fa[i]=i,r[i]=l[i]=dis[i]=0;
		}
        while(m--){
            register int f,a,b;
            scanf("%d",&f);
            if(f==2){scanf("%d",&a);val[a]=0;extract(a);}
            else if(f==3){scanf("%d%d",&a,&b);a=get(a);val[a]-=val[a]>b?b:val[a];extract(a);}
            else{
                scanf("%d%d",&a,&b);a=get(a);b=get(b);
                if(a==b)continue;
                merge(a,b);
            }
        }
        long long sum=0,cmax=0;
        for(int i=1;i<=n;i++){
            register int root=get(i);
            if(v[root])continue;v[root]=1;
            cmax=max(cmax,val[root]);
            sum+=val[root];
        }
        if(w==2)sum-=cmax;
        if(w==3)sum+=cmax;
        if(sum==0)printf("Gensokyo 0\n");
        else if(sum<=k)printf("Heaven %lld\n",sum);
        else printf("Hell %lld\n",sum);
    }
    return 0;
} 
```
------------

## 数组存左偏树，码风可能比较特别，请见谅

---

## 作者：__Cartesian__Tree__ (赞：6)

这是一篇介绍pb_ds的题解。

pb_ds封装了许多有用的东西，其中之一就是左偏树（可并堆），和普通的`priority_queue`很像。

~~CCF比赛能用你就说香不香。~~

这道题很简单，就 $4$ 种操作：

1. 合并堆
2. 结点值清零
3. 堆中最大值减少
4. 增加/减少最大值

第一种操作显然可以使用pb_ds中`priority_queue`的 `join` 函数，使用方法为`q1.join(q2)`。

第二种操作可以使用数组标记（无增值操作）。

第三种将顶部值减小后在加入即可（记得把原来的删了）。

第四种最后记录最大值，再增或减。

具体见代码：

```cpp
#include <bits/stdc++.h>
#include <bits/extc++.h>
#define ext __gnu_pbds
using namespace std;//不引用__gnu_pbds时记得加上ext::
long long t, w, k, n, m, f[2000010], x;
bool s[2000010], ss[2000010];//s为清零，ss为计算的集合标记
template <typename T> inline void read(T &t) {
    t = 0;
    char c = getchar();
    int f = 1;
    while (!isdigit(c)) {
        if (c == '-') {
            f = -f;
        }
        c = getchar();
    }
    while (isdigit(c)) {
        t = (t << 3) + (t << 1) + (c ^ '0');
        c = getchar();
    }
    t *= f;
}
template <typename T, typename ... Args> inline void read(T &t, Args&... args) {
    read(t);
    read(args...);
}
struct Node{
    long long s, id;
    bool operator<(const Node&p)const{
        if (s != p.s) return s < p.s;//大的排前面用<
        else return id > p.id;//小的排前面用>
    }
};
inline Node merge(int a, int b){
    return ((Node){a, b});
}
ext::priority_queue<Node> q[2000010];
int find(int n){
    if (n == f[n]) return n;
    return f[n]=find(f[n]);
}
int main(){
    read<long long>(t, w, k);
    while (t--){
        read<long long>(n, m);
        memset(s, 0, sizeof(bool)*(n+10));
        memset(ss, 0, sizeof(bool)*(n+10));
        for (int i = 1; i <= n; i++){
            read<long long>(x);
            q[i].clear();//清空
            q[i].push(merge(x,i));
            f[i]=i;
        }
        while (m--){
            long long aa, bb, cc;
            read<long long>(aa);
            if (aa == 2){
                read<long long>(bb);
                s[bb] = 1;//清零标记
            }
            else if (aa == 3){
                read<long long>(bb, cc);
                long long fabb = find(bb);
                while (!q[fabb].empty()&&s[q[fabb].top().id]) q[fabb].pop();//将清零的结点删除（因为没有增加值操作）
                if (q[fabb].empty()) continue;
                long long tmp = q[fabb].top().s - cc;
                q[fabb].push(merge((tmp>0?tmp:0),q[fabb].top().id));
                q[fabb].pop();//减去后加入并删除原来的值
            }
            else{
                read<long long>(bb, cc);
                int fabb = find(bb), facc = find(cc);
                if (fabb == facc) continue;
                if (q[fabb].size()>q[facc].size()) q[facc].join(q[fabb]), f[fabb]=facc;//合并
                else q[fabb].join(q[facc]), f[facc] = fabb;
            }
        }
        long long sum = 0, maxx = -1;
        for (int i = 1; i <= n; i++){
            long long fai = find(i);
            while (!q[fai].empty()&&s[q[fai].top().id]) q[fai].pop();
            if (ss[fai]) continue;//避免重复查找同一集合
            ss[fai]=1;
            maxx = max(maxx, (q[fai].empty()?0ll:q[fai].top().s));//记录最大自
            sum += (q[fai].empty()?0:q[fai].top().s);
        }
        if (w == 2) sum -= maxx;
        if (w == 3) sum += maxx;
        if (sum == 0) puts("Gensokyo 0");
        else if (sum <= k) printf("Heaven %lld\n", sum);
        else printf("Hell %lld\n", sum);
    }
    return 0;
}
```

---

## 作者：望月Asta (赞：4)

### 简要题意

对于一个序列，最初将其所有元素分别独立出来作为一个集合，实现以下几种功能 : 

1. 清零一个特定的元素

2. 将一个集合中最大元素减少一个特定值，减少到 0 及以下默认把这个元素设为 0

3. 合并两个集合

求完成操作后所有集合的最大元素总和

显然对于取出一个集合最大元素的操作就需要维护大根堆，而合并更是一个明显的操作，考虑 **可并堆**。

### 左偏树

一种能在 $\mathrm{O}(\log n)$ 时间内合并的堆，优势是稳定且码量小于 Fibonacci堆。

~~配对堆复杂度只有明确的上界和下界，感觉不靠谱~~

[模板题](https://www.luogu.com.cn/problem/P3377)

将结点封装为结构体 :

```cpp
struct Node {
    int val,ch[2],dist;
}T[N];

```

#### 左偏树的 ``dist``

定义一个结点的 ``dist`` 如下 :

定义没有左儿子或右儿子的结点为 **外结点** ，其``dist`` 为 1，空结点 ``dist`` 为 0，不是外节点的节点 ``dist`` 为其到子树中最近的外节点的距离加一。

为了维护左偏的性质，左偏树一个结点的左儿子的 ``dist`` 都要大于右儿子的 ``dist``。

或者可以总是认为  ``dist`` 大的结点为左儿子。

```cpp
// 取得右儿子
inline int& rs(int x) {
    return T[x].ch[T[T[x].ch[1]].dist < T[T[x].ch[0]].dist];
}
```

### 实现

过程就是模拟题意，考虑如何实现关键操作。

#### 0.查找每个元素所在的集合

数据范围有 $2 \times 10^6$ ，必然不能暴力跳。

考虑使用路径压缩的并查集，由于左偏树合并是基于权值的，这个并查集并不能按秩合并。

#### 1.合并

参考普通的可并堆合并，但是如果两个结点权值相同，那么就需要选择编号小的结点作为根。

```cpp
int merge(int x,int y) {
    if(!x || !y) return x | y;
    if(T[x].val < T[y].val || (T[x].val == T[y].val && x > y)) 
    	std::swap(x,y);
    rs(x) = merge(rs(x),y);
    T[x].dist = T[rs(x)].dist + 1;
    return x;
}
```

#### 2.清空堆内任意结点

对于一个非堆顶的结点，首先取出其左右儿子，将其合并后分离出来,再与原堆合并即可。

可以证明这个操作也是 $\mathrm{O}(\log n)$ 的。

需要注意的是这里不是删除节点而是清空，就是这个节点还在原来的集合里，可以将其移出堆但是**不能清空并查集**。

#### 3.取出堆内最大值并减去一个值

对于大根堆，最大值就是根.

但是直接减去后不符合堆的性质，考虑先合并左右儿子再把减去特定值的元素作为一个新堆合并进去即可.

这时候要注意如何维护并查集以使得并查集找到的总是这个元素所在的堆的**根结点**。

#### 4.统计答案

把每个堆的根节点权值加起来，顺带统计最大值。

开 ``bool`` 数组查重。

#### 5.易错点

- 如果在``merge()``的时候更新并查集，就不必在主函数里更新了。

- **不要**清空被2操作清零的点的并查集标志。

- 在清空一个结点之前先记录其左右儿子。

- 开 ``long long`` ,特别是 ``K`` 也要开。

- 快读快写也要开``long long``。

### 代码

~~我怎么就这么拿最优解了~~

删除了头文件和快读。

```cpp
int dsu[N];// disjoin set union
int find(int x) {
    return dsu[x] == x ? x : dsu[x] = find(dsu[x]);
}

bool vis[N];
struct Node {
    ll val;
    int ch[2],dist;
}T[N];

inline int& rs(int x) {
    return T[x].ch[ T[T[x].ch[1]].dist < T[T[x].ch[0]].dist ];
}

int merge(int x,int y) {
    if(!x || !y) return x | y;
    if(T[x].val < T[y].val || (T[x].val == T[y].val && x > y)) 
    	std::swap(x,y);
    rs(x) = merge(rs(x),y);
    T[x].dist = T[rs(x)].dist + 1;
    dsu[T[x].ch[0]] = dsu[T[x].ch[1]] = dsu[x] = x;
    return x;
}

int W;
ll K;

void solve() {
    int n = read(),m = read();
    memset(vis,0,sizeof(vis));
    T[0].ch[0] = T[0].ch[1] = T[0].dist = 0;
    for(int i = 1;i <= n;++i) {
        T[i].val = read();
        T[i].ch[0] = T[i].ch[1] = T[i].dist = 0;
        dsu[i] = i;
    }
    for(int i = 1;i <= m;++i) {
        int op = read(),x = read();
        if(op == 2) {
            // Clear Node x
            if(vis[x]) continue;
            vis[x] = 1;
            int ch0 = T[x].ch[0],ch1 = T[x].ch[1];
            dsu[ch0] = ch0,dsu[ch1] = ch1;
            T[x].val = T[x].ch[0] = T[x].ch[1] = T[x].dist = 0;
            merge(merge(ch0,ch1),find(x));
        }
        else if(op == 3) {
            // Decrease Key
            ll y = read();
            x = find(x);
            T[x].val -= y;
            if(T[x].val < 0) T[x].val = 0;
            int ch0 = T[x].ch[0],ch1 = T[x].ch[1];
            dsu[ch0] = ch0,dsu[ch1] = ch1;
            T[x].ch[0] = T[x].ch[1] = T[x].dist = 0;
            merge(merge(ch0,ch1),x);
        }
        else {
            // Merge
            int y = read();
            x = find(x),y = find(y);
            if(x == y) continue;
            merge(x,y);
        }
    }
    ll mx = 0,ans = 0;
    for(int i = 1;i <= n;++i) {
        int rt = find(i);
        if(vis[rt]) continue;
        vis[rt] = 1;
        ans += T[rt].val;
        mx = std::max(mx,T[rt].val);
    }
    if(W == 2) ans -= mx;
    else if(W == 3) ans += mx;
    if(!ans)
        putC('G'),putC('e'),putC('n'),putC('s'),putC('o'),putC('k'),putC('y'),putC('o');
    else if(ans > K)
        putC('H'),putC('e'),putC('l'),putC('l');
    else
        putC('H'),putC('e'),putC('a'),putC('v'),putC('e'),putC('n');
    space,write(ans),enter;
}

int main() {
	init_IO();
	int T = read();W = read(),K = read();
	while(T--) solve();
	end_IO();
	return 0;
}
```

---

## 作者：SAMSHAWCRAFT (赞：3)

关键词：左偏树。

要求维护一个数据结构，支持：

1. 删除集合元素
  
2. 减小集合最大值
  
3. 合并两个集合
  
4. 查询集合最大值
  

本题相当于是左偏树的模板题，左偏树是一种可并堆，具有堆的性质并且可以快速合并集合。左偏树的每个节点都记录了一个 `dist`，这个值对于空节点是 0，对于左子节点或右子节点为空的节点（这类节点也称为外节点）是 1，对于其余的节点则为该节点到最近外节点的距离加一。左偏树具有的左偏性质由 `dist` 保证，即每个节点的 `dist` 都是其右子节点的 `dist` 加一。注意 `dist` 并不等价于左偏树的深度，所以左偏树的深度并无保证。

**合并集合**

左偏树作为一种可并堆，最重要的操作是合并两个集合，我们可以很快地想到并查集合并两个集合。由于要满足堆的性质，所以我们选择值较大的根作为根节点，让值较小的集合以根节点的左子节点的身份合并入这个集合，然后递归下去，不断合并根节点右子节点对应集合和另一个集合，注意在递归过程中维护左偏性质。

下面的代码实现中，`root` 就是并查集的数组，这个并查集可以路径压缩。

```cpp
int merge(int u,int v){
  if(u==0||v==0) return u|v;
  if(tree[u].val<tree[v].val) std::swap(u,v);
  else if(tree[u].val==tree[v].val&&u>v) std::swap(u,v);
  tree[u].rson=merge(tree[u].rson,v);
  if(tree[tree[u].lson].dis<tree[tree[u].rson].dis)
    std::swap(tree[u].lson,tree[u].rson);
  root[tree[u].lson]=root[tree[u].rson]=root[u]=u;
  tree[u].dis=tree[tree[u].rson].dis+1;
  return u;
}
```

**删除集合元素**

先将被删除元素对应节点的左右子节点合并成一个堆，之后将这个合并后的堆和原本被删除元素对应节点所在集合的根合并，这样就孤立出了这个被删除的节点，把这个节点清空即可。注意在过程中维护 `dist`。

```cpp
int find(int u){
  if(root[u]==u) return u;
  return root[u]=find(root[u]);
}
void pop(int u){
  int ls=tree[u].lson,rs=tree[u].rson;
  root[ls]=ls,root[rs]=rs;
  tree[u]=node{0,0,0,0};
  merge(merge(ls,rs),find(u));
}
```

**减小集合最大值**

找到集合的最大值后直接对这个节点的值进行修改。这样做可能破坏堆的性质，所以我们像上述操作一样将这个被修改的节点孤立出来，但是不把它清空，而是让它作为一个新集合和它原本的左右子节点对应的两个集合合并。

```cpp
void reduce(int u,ll val){
  u=find(u);
  int ls=tree[u].lson,rs=tree[u].rson;
  tree[u].val=std::max(0LL,tree[u].val-val);
  root[tree[u].lson]=ls;
  root[tree[u].rson]=rs;
  tree[u]=node{0,0,0,tree[u].val};
  merge(merge(ls,rs),u);
}
```

**查询集合最大值**（统计答案）

前面这三个操作只是这道题前面操作的部分，后面统计答案的时候是所有集合的最大值相加，并根据输入条件减去或加上所有集合的最大值中最大的值。由于左偏树是一个可并堆，具有堆的性质，所以只需取出堆顶即可。为了防止重复统计集合或是统计了已经被删除的节点，我们在左偏树外另开一个数组来记录这个集合的贡献是否需要统计。

下面的代码实现中，`LT` 是我封装的一个左偏树结构体。一组测试数据的代码如下：

```cpp
scanf("%d%d",&n,&m);
LT.clear(n);
std::fill(kind,kind+n+1,false);
for(int cx=1;cx<=n;++cx)
  scanf("%lld",&LT.tree[cx].val);
for(int cx=1;cx<=m;++cx){
  int opt,u,v; ll val;
  scanf("%d",&opt);
  if(opt==2){
    scanf("%d",&u);
    if(kind[u]) continue;
    kind[u]=true;
    LT.pop(u);
  }else if(opt==3){
    scanf("%d%lld",&u,&val);
    LT.reduce(u,val);
  }else if(opt==4){
    scanf("%d%d",&u,&v);
    int fu=LT.find(u),fv=LT.find(v);
    if(fu==fv) continue;
    LT.merge(fu,fv);
  }
}
```

统计答案的代码实现如下：

```cpp
ll mx=0,ans=0;
for(int cx=1;cx<=n;++cx){
 int rt=LT.find(cx);
 if(kind[rt]) continue;
 kind[rt]=true;
 ans+=LT.tree[rt].val;
 mx=std::max(mx,LT.tree[rt].val);
}
if(w==2) ans-=mx;
else if(w==3) ans+=mx;
if(ans==0) puts("Gensokyo 0");
else if(ans>k) printf("Hell %lld\n",ans);
else printf("Heaven %lld\n",ans);
```

注意本题多测，要记得重新初始化。那么这道题的主要代码实现就都讲解完了。

另附：[提交记录](https://www.luogu.com.cn/record/74739306)，想要完整代码可以找我。

---

## 作者：alex_liu (赞：2)

## 0.前言

本篇题解适合有左偏树基础的 OIer，若没有学过此算法，请移步至模板题。

## 1.题意

要求一共有三个操作：

`2 A` 将 $A$ 的值修改为 $0$

`3 A B` $A$ 所在的集合最大值减小 $B$，与 $0$ 取最大值

`4 A B` 合并 $A,B$ 集合

查询操作详细看题面。

## 2.分析

集合，最大值，合并等关键词，可以想到用左偏树来维护。

对于修改任一节点，将其左右儿子合并，再与原左右儿子所在的堆合并即可。

注意修改时需要自底向上更新 $dist$，不满足左偏树性质时则交换左右节点。

## 3. 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T,n,m,w,k,opt,a,b,sum,maxx;
bool vis[2000005];
struct node{
	int dist,ch[2],val,id,fa;
	bool operator<(node &x)const{return val==x.val?id>=x.id:val<x.val;}//重载运算符 
}t[2000005];
int find(int x){return t[x].fa==x?x:t[x].fa=find(t[x].fa);}//用路径压缩的方法把找到当前堆根的时间复杂度降到 O(nlogn) 
int& rs(int x){return t[x].ch[t[t[x].ch[0]].dist<t[t[x].ch[1]].dist];}//返回右儿子节点
void pushup(int x){
	if(!x)return;
	if(t[x].dist^(t[rs(x)].dist+1))t[x].dist=t[rs(x)].dist+1,pushup(t[x].fa);//自底向上更新dist 
}
int merge(int x,int y){
	if((!x)||(!y))return x|y;
	if(t[x]<t[y])swap(x,y);
	t[rs(x)=merge(rs(x),y)].fa=x;//基础合并操作 
	pushup(x);return x;//更新dist 
}
signed main(){
	cin>>T>>w>>k;
	for(int i=1;i<=T;i++){
		memset(vis,0,sizeof vis);
		cin>>n>>m;sum=maxx=0; //注意初始化！！！ 
		t[0].dist=t[0].ch[0]=t[0].ch[1]=t[0].val=t[0].id=t[0].fa=0;
		for(int j=1;j<=n;j++)cin>>t[j].val,t[j].id=t[j].fa=j,t[j].ch[0]=t[j].ch[1]=t[j].dist=0;
		for(int j=1;j<=m;j++){
			cin>>opt>>a;
			if(opt==2){
				int q=0;
				t[a].val=0;
				q=t[t[a].ch[0]].fa=t[t[a].ch[1]].fa=merge(t[a].ch[0],t[a].ch[1]);
				q=find(q);
				t[a].ch[0]=t[a].ch[1]=t[a].dist=0;
				a=find(a);
				t[a].fa=t[q].fa=merge(q,a);
			}
			if(opt==3){
				cin>>b;a=find(a);
				int q=0;
				t[a].val=max(t[a].val-b,0ll);
				q=t[t[a].ch[0]].fa=t[t[a].ch[1]].fa=merge(t[a].ch[0],t[a].ch[1]);
				q=find(q);
				t[a].ch[0]=t[a].ch[1]=t[a].dist=0;
				a=find(a);
				t[a].fa=t[q].fa=merge(q,a);
			}
			if(opt==4){
				cin>>b;a=find(a),b=find(b);
				if(a^b)t[a].fa=t[b].fa=merge(a,b);
			}
		}
		for(int j=1;j<=n;j++){//查询直接模拟即可 
			int x=find(j);
			if(!vis[x]){
				vis[x]=1;
				maxx=max(maxx,t[x].val),sum+=t[x].val;
			}
		}
		if(w==2)sum-=maxx;
		if(w==3)sum+=maxx;
		if(!sum)puts("Gensokyo 0");
		else if(sum<=k)printf("Heaven %lld\n",sum);
		else printf("Hell %lld\n",sum);
	}
	return 0;
}
```
## 4.几个坑点
我全都踩过啊qwq

1. 多测注意初始化！

2. 注意修改值之后记得与原左右儿子的堆合并，并不是把它永久删除！

3. 我的 `merge` 函数中没有找 $x,y$ 的堆的根节点，所以注意要保证合并时 $x,y$ 已经是堆的根节点（即在 `merge` 之前 `find`，详情见代码）！

4. 注意是值相同时，编号越小的越“大”，所以重载运算符时需要搞清楚符号！

就提醒这么多了，各位好运/bx

---

## 作者：Nt_Tsumiki (赞：2)

## 题意
[题目链接](https://www.luogu.com.cn/problem/P4971)

给你 $t$ 组数据和输出方式 $w$，要求实现三个操作：

1. 任意删除某个点

2. 把堆顶元素改为某个值

3. 合并两个堆

通俗一点的意思就是维护左偏树。

## 做法
### 算法分析
很明显暴力模拟一定会炸，而根据，最大值和合并两个堆这两个关键性词语，就可以敲定做法为左偏树（可并堆）。
### 算法实现
左偏树链接：[link](https://www.luogu.com.cn/blog/natieyes/post-suan-fa-zuo-pian-shu-ke-bing-dui-post)。

使用左偏树维护每个序列，再根据处刑方式 $w$ 求得答案。

由于是大根堆，所以 `merge` 函数中的 `swap` 的判断条件应该改为 `val[x]<val[y] or (val[x]==val[y] and x>y)`。

再来说一下删除任意节点这个操作，也很简单：把此点取消，再把左右子树合并，最后再把左右子树合并所形成的树和其父节点所在的树合并，就可完成操作，代码如下：
```cpp
void Delete(long long x) {
	long long L=l[x],R=r[x];
	fa[L]=L,fa[R]=R;
	l[x]=r[x]=dis[x]=0;
	merge(merge(L,R),find(x));//合并
}
```

另外由于多组数据，所以每求完一次结果，就必须把清空（及代码中的 `clear` 函数），其他的包括输入，建树套等用模板即可，记得注意规范。

注意开 `long long`。
### Code
```cpp
#include <iostream>
#include <cstring>

using namespace std;
long long t,w,k;
long long val[2000001],dis[2000001];
long long vis[2000001],fa[2000001];
long long l[2000001],r[2000001];

inline void clear(){//初始化
    fa[0]=dis[0]=l[0]=r[0]=0;
    memset(vis,0,sizeof(vis));
}

long long find(long long x) {return (fa[x]==x?x:fa[x]=find(fa[x]));}

long long merge(long long x,long long y) {//合并
	if (!x or !y) {
		return x+y;
	}
	if (val[x]<val[y] or (val[x]==val[y] and x>y)) swap(x,y);//注意大根堆
	r[x]=merge(r[x],y);
	if (dis[l[x]]<dis[r[x]]) swap(l[x],r[x]);
	fa[l[x]]=fa[r[x]]=fa[x]=x;
	dis[x]=dis[r[x]]+1;//更新
	return x;
}

void Delete(long long x) {//删除
	long long L=l[x],R=r[x];
	fa[L]=L,fa[R]=R;
	l[x]=r[x]=dis[x]=0;
	merge(merge(L,R),find(x));
}

int main() {
	cin>>t>>w>>k;
	for (long long i=1;i<=t;i++) {
		clear();
		long long n,m;
		cin>>n>>m;
		for (long long i=1;i<=n;i++) {
			cin>>val[i];
			fa[i]=i;
			r[i]=l[i]=dis[i]=0;
		}
		for (long long i=1;i<=m;i++) {
			long long tmp,x,y;
			cin>>tmp>>x;
			if (tmp==2) {
				val[x]=0;
				Delete(x);
			} else if (tmp==3) {
				cin>>y;
				x=find(x);val[x]-=val[x]>y?y:val[x];Delete(x);
			} else {
				cin>>y;
				x=find(x);y=find(y);
                if (x==y) continue;
                merge(x,y);
			}
		}
		long long sum=0,maxn=0;
		for (long long i=1;i<=n;i++) {
			long long root=find(i);
			if (vis[root]) continue;
			vis[root]=1;
			maxn=max(maxn,val[root]);
			sum+=val[root];
		}
        //输出方式
		if (w==2) sum-=maxn;
		else if (w==3) sum+=maxn;
		if (!sum) cout<<"Gensokyo "<<sum<<endl;
		else if (sum>k) cout<<"Hell "<<sum<<endl;
		else cout<<"Heaven "<<sum<<endl;
	}
}
```
## 链接
[左偏树浅谈](https://www.luogu.com.cn/blog/natieyes/post-suan-fa-zuo-pian-shu-ke-bing-dui-post)

---

## 作者：luxiaomao (赞：1)

## 左偏树解法

这道题没有很大的思维难度，虽然说是道板子题但是仍有许多需要注意的地方。（~~我是不会告诉你我一道水题调了两小时的~~）

本题解主要补充数据更新后目前题解区的不足。

## 分析

题意似乎很花里胡哨，但其实就是要你写一个能实现以下功能的数据结构：

- 合并两个集合。

- 查询一个集合中的最大值。

- 将任意一个点（不一定是它所在集合中的最大值）修改权值。

**合并功能**我们可以采用并查集，**最值查询功能**我们可以采用堆，那么不难看出我们要写一个**可并堆**，这篇题解使用左偏树，因为左偏树码量不会特别大，而且也贴合题目标签哈哈哈~

## 实现

首先是左偏树经典的合并：

```cpp
int merge(int x,int y)
{
	if(!x || !y)return x + y;
	if(v[x] < v[y] || (v[x] == v[y] && x > y))swap(x,y);
	r[x] = merge(r[x],y);
	if(d[l[x]] < d[r[x]])swap(l[x],r[x]);
	d[x] = d[r[x]] + 1;
	fa[x] = fa[l[x]] = fa[r[x]] = x;
	return x;
}
```

接下来是本题的一个重点了（pia 黑板！）：与洛谷的模板题不同，本题要求修改权值或者删除的节点**不保证是它所在集合中的最大值**。

**PS：因为本题要构造大根堆，所以删除一个节点实际上相当于把它的权值改为 0 再重新合并进去，这样它就成为了一个“死点”，实现了删除效果。**

删除功能的流程：记要删除的节点为 $x$。先把 $x$ 的左右儿子拆分出来成为独立的集合，再把 $x$ 置为“死点”，然后**合并三个集合：原来 $x$ 的左儿子，原来 $x$ 的右儿子，原来 $x$ 的根节点**。这样你就会发现我们把 $x$ 节点从原来的集合中“拆”了出来并且不会影响到同集合中的其他节点。

请看具体的代码实现。

```cpp
void del(int x)
{
	int L = l[x],R = r[x];
	fa[L] = L,fa[R] = R,l[x] = r[x] = d[x] = 0;
	merge(find(x),merge(L,R));
}
```

## Code Time

你们最爱的环节来啦~

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int t,w,k;
int n,m;

int d[2000005],l[2000005],r[2000005],fa[2000005];
int v[2000005];
bool vis[2000005];

int find(int x){return fa[x]==x ? x : fa[x]=find(fa[x]);}
int merge(int x,int y)
{
	if(!x || !y)return x + y;
	if(v[x] < v[y] || (v[x] == v[y] && x > y))swap(x,y);
	r[x] = merge(r[x],y);
	if(d[l[x]] < d[r[x]])swap(l[x],r[x]);
	d[x] = d[r[x]] + 1;
	fa[x] = fa[l[x]] = fa[r[x]] = x;
	return x;
}
void del(int x)
{
	int L = l[x],R = r[x];
	fa[L] = L,fa[R] = R,l[x] = r[x] = d[x] = 0;
	merge(find(x),merge(L,R));
}

signed main()
{
	scanf("%lld%lld%lld",&t,&w,&k);
	while(t--)
	{
		fa[0] = l[0] = r[0] = 0,d[0] = -1;
		memset(vis,0,sizeof(vis));
		scanf("%lld%lld",&n,&m);
		for(int i = 1;i <= n;i++)
		{
			scanf("%lld",&v[i]);
			fa[i] = i;
			d[i] = l[i] = r[i] = 0;
		}
		while(m--)
		{
			int o,x,y;
			scanf("%lld%lld",&o,&x);
			if(o == 2)
			{
				v[x] = 0;
				del(x);
			}
			else if(o == 3)
			{
				scanf("%lld",&y);
				x = find(x);
				v[x] -= min(v[x],y);
				del(x);
			}
			else
			{
				scanf("%lld",&y);
				x = find(x),y = find(y);
				if(x != y)merge(x,y);
			}
		}
		int maxx = 0,sum = 0;
		for(int i = 1;i <= n;i++)
		{
			int x = find(i);
			if(vis[x])continue;
			vis[x] = 1;
			sum += v[x];
			maxx = max(maxx,v[x]);
		}
		if(w == 2)sum -= maxx;
		if(w == 3)sum += maxx;
		if(sum == 0)printf("Gensokyo 0\n");
		else if(sum > k)printf("Hell %lld\n",sum);
		else printf("Heaven %lld\n",sum);
	}
	return 0;
}
```

未压行 83 行的码量，以及个人觉得还算易读的码风 QAQ。

如果大家有问题欢迎私信我呀，感谢支持~

---

## 作者：Zhddd_ (赞：1)

这题要求 $4$ 个操作：

1. 把某个元素修改为 $0$。
2. 减小堆顶元素的值。
3. 合并两个堆。
4. 查询所有堆顶元素的和。

因为要合并两个堆，所以考虑使用左偏树。一开始，令所有元素都在只包含自己的堆中。

- 操作 $3$ 是合并，代码如下：

```cpp
int merge(int x, int y) {
    if (!x || !y) return x + y;
    if (cmp(x, y)) swap(x, y);
    r[x] = merge(r[x], y);
    if (dist[l[x]] < dist[r[x]]) swap(l[x], r[x]);
    dist[x] = dist[r[x]] + 1;
    p[l[x]] = p[r[x]] = p[x] = x; // 注意这一行，要及时修改关系。
    return x;
}
```

- 操作 $1$ 和 $2$ 都是修改某个元素，可以先直接修改其值，再运行如下代码：

```cpp
int L = l[a], R = r[a];
p[L] = L, p[R] = R; // 编辑 a 下面的两个儿子。
l[a] = r[a] = dist[a] = 0; // 编辑 a 自己。
merge(merge(L, R), find(a)); // 合并 a 下面的两个儿子，再把下面的儿子一起合到 a 的代表元素，这样 a 就被删掉了。
```

- 操作 $4$  可以直接枚举所有点，并查找它们的堆顶元素，去重以后的和就是答案。

此外，要注意**对于罪恶值相等的坏事，认为编号更小的更坏**。所以要进行特判。

时间复杂度：$O(m\log n)$。

完整代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define int long long
using namespace std;
const int N = 2e6 + 10, INF = 1e18;
int T, w, k, n, m, res;
int p[N], l[N], r[N], dist[N], v[N], maxn;
bool st[N]; // 最后统计答案时用于去重。
int read() {
    int x = 0;
    char ch = getchar();
    while (ch < '0' || ch > '9') ch = getchar();
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + ch - 48;
        ch = getchar();
    }
    return x;
}
bool cmp(int x, int y) {
    // 判断大小关系。
    if (v[x] != v[y]) return v[x] < v[y];
    return x > y;
}
int find(int x) {
    // 找到代表元素。
    if (x != p[x]) p[x] = find(p[x]);
    return p[x];
}
int merge(int x, int y) {
    if (!x || !y) return x + y;
    if (cmp(x, y)) swap(x, y);
    r[x] = merge(r[x], y);
    if (dist[l[x]] < dist[r[x]]) swap(l[x], r[x]);
    dist[x] = dist[r[x]] + 1;
    p[l[x]] = p[r[x]] = p[x] = x;
    return x;
}
void init() {
    p[0] = l[0] = r[0] = dist[0] = res = maxn = v[0] = 0;
    memset(st, 0, sizeof st);
}
signed main() {
    T = read(), w = read(), k = read();
    while (T--) {
        init();
        n = read(), m = read();
        for (int i = 1; i <= n; i++) {
            v[i] = read();
            p[i] = i, l[i] = r[i] = dist[i] = 0;
        }
        for (int i = 1; i <= m; i++) {
            int op, a, b;
            op = read(), a = read();
            if (op == 2) {
                v[a] = 0;
                int L = l[a], R = r[a];
                p[L] = L, p[R] = R;
                l[a] = r[a] = dist[a] = 0;
                merge(merge(L, R), find(a));
            }
            else if (op == 3) {
                b = read();
                a = find(a);
                v[a] = max(0ll, v[a] - b);
                int L = l[a], R = r[a];
                p[L] = L, p[R] = R;
                l[a] = r[a] = dist[a] = 0;
                merge(merge(L, R), find(a));
            } else {
                b = read();
                a = find(a), b = find(b);
                if (a != b) merge(a, b);
            }
        }
        for (int i = 1; i <= n; i++) {
            // 不重复地统计答案。
            int t = find(i);
            if (!st[t]) {
                res += v[t];
                maxn = max(maxn, v[t]);
                st[t] = true;
            }
        }
        if (w == 2) res -= maxn;
        else if (w == 3) res += maxn;
        
        if (res == 0) printf("Gensokyo ");
        else if (res <= k) printf("Heaven ");
        else printf("Hell ");
        printf("%lld\n", res);
    }
    return 0;
}
```

---

## 作者：x383494 (赞：1)

[传送门](https://www.luogu.com.cn/problem/P4971)

题目要求合并，查询最大值，可以看出是可并堆。

关于可并堆，这里介绍一种（我也不知道叫什么的）类似 Treap 的做法，也可以看我在[模板题的题解](https://www.luogu.com.cn/blog/x383494/solution-p3377)。

一个普通的 Treap 对每个结点维护两个值 $\text{value}$ 和 $\text{priority}$，分别为树和堆的值。FHQ-Treap 是一种资瓷分裂与合并的 Treap。

既然 FHQ-Treap 有堆的性质，又资瓷合并，自然联想到了可并堆。于是我们模仿 Treap 的做法，用随机的 $\text{value}$ 维持平衡，用 $\text{priority}$ 维护题中要求（大根）堆的值。

接下来考虑几个操作的实现。

- 维护一个节点的值

```cpp
struct Node{
    ll pri, val;
    Node *ls, *rs;
    ll siz, time;
    bool operator<(Node const& b){
        if(pri < b.pri) return true;
        if(pri == b.pri && time < b.time) return true;
        return false;
    }
} nil_ = {0x383494, 0x383494, &nil_, &nil_}, *nil = &nil_;
```

其中 `nil` 是为了防止 RE/减小码量。

- 将一点值设为 $0$

$\text{priority}$ 为 $0$ 时，由于 $\text{priority}$ 非负，这一点放在叶子的位置一定满足要求。于是将 FHQ-Treap 中的分裂操作稍作改进：

```cpp
void split(Node *&root, Node *&ls, Node *&rs){
	ls = root->ls; root->ls = nil;
	rs = root->rs; root->rs = nil;
	upd_siz(root);
	return;
}
```

`upd_siz` 是原 FHQ-Treap 分裂必要的，但这题中不用，代码见最后。

分裂后，该点的左右子树与原 Treap 合并即可。

- 将一点值减小

与归零同理，把左右子树拆出来，将该点值减小，将左右子树与原 Treap 合并。

- 合并两 Treap

可并堆基本操作。合并完别忘了合一下并查集。

---

快读+吸氧跑得飞快，目前是最优解 [rk3](https://www.luogu.com.cn/record/112311041).

code:

```cpp
#include <cstdio>
#include <cctype>
#include <set>
#include <random>
#define UP(i,s,e) for(auto i=s; i!=e; ++i)
#define sd std::
sd mt19937 rdna(0x383494);
typedef long long ll;
namespace FHQ{ // }{{{
struct Node{
    ll pri, val;
    Node *ls, *rs;
    ll siz, time;
    bool operator<(Node const& b){
        if(pri < b.pri) return true;
        if(pri == b.pri && time < b.time) return true;
        return false;
    }
} nil_ = {0x383494, 0x383494, &nil_, &nil_}, *nil = &nil_;
Node datas[2000000]; int cnt=0;
void init(){
	cnt = 0;
}
void upd_siz(Node *root){
    root->siz = root->ls->siz + root->rs->siz + 1;
}
Node *merge(Node *sm, Node *bg){
    if(sm == nil || bg == nil) return sm == nil ? bg : sm;
    if(sm->val > bg->val) sd swap(sm, bg);
    if(*sm < *bg){
        sm->rs = merge(sm->rs, bg);
        upd_siz(sm);
        bg = sm;
    } else {
        bg->ls = merge(sm, bg->ls);
        upd_siz(bg);
    }
    return bg;
}
Node *nnod(ll p){
    datas[cnt] = { p, (ll)rdna(), nil, nil, 1, cnt };
    return &datas[cnt++];
}
void split(Node *&root, Node *&ls, Node *&rs){
	ls = root->ls; root->ls = nil;
	rs = root->rs; root->rs = nil;
	upd_siz(root);
	return;
}
} // {}}}
namespace IO{ // }{{{
ll read(){
	ll ret = 0; char c = getchar();
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)){
		ret = ret*10 + c-'0';
		c=getchar();
	}
	return ret;
}
} // {}}}
namespace m{ // }{{{
using IO::read;
ll iw, ik, in, im;
constexpr int N = 2000000;
FHQ::Node *hps[N];
int fa[N];
int getfa(int x){
	if(fa[x] == x) return x;
	else return fa[x] = getfa(fa[x]);
}
void merges(int x, int y){
	fa[getfa(x)] = getfa(y);
}
void work(){
	in = read(), im = read();
	FHQ::init();
	UP(i, 0, in){
		hps[i] = FHQ::nnod(-read());
		fa[i] = i;
	}
	UP(i, 0, im){
		ll x = read();
		if(x == 2){
			x=read();
			x--;
			FHQ::Node *rt = &FHQ::datas[x], *l, *r;
			FHQ::split(rt, l, r);
			rt->pri = 0;
			hps[getfa(x)] = FHQ::merge(l, FHQ::merge(hps[getfa(x)], r));
		} else if(x == 3){
			x=read();
			x--;
			FHQ::Node *rt = hps[getfa(x)], *l, *r;
			FHQ::split(rt, l, r);
			l = FHQ::merge(l, r);
			rt->pri = sd min(0ll, rt->pri+read());
			hps[getfa(x)] = FHQ::merge(l, rt);
		} else {
			ll y;
			x=read(), y=read();
			x--, y--;
			x=getfa(x), y=getfa(y);
			if(x==y) continue;
			FHQ::Node *l = hps[x], *r = hps[y];
			merges(x, y);
			hps[getfa(x)] = FHQ::merge(l, r);
		}
	}
	ll ans = 0, vmax = 0;
	UP(i, 0, in){
		if(fa[i] != i) continue;
		ll v = hps[i]->pri;
		vmax = sd min(vmax, v);
		ans += v;
	}
	if(iw == 2) ans -= vmax;
	else if(iw == 3) ans += vmax;
	ans = -ans;
	printf("%s %lld\n", ans==0 ? "Gensokyo" : (ans > ik ? "Hell" : "Heaven"), ans);
}
} // {}}}
using namespace IO;
int main(){
	ll it = read();
	m::iw = read(); m::ik = read();
	while(it--) m::work(); 
	return 0;
}
```

---

## 作者：王大神——A001 (赞：1)

[传送门](https://www.luogu.com.cn/problem/P4971)

前置知识：

[左偏树](https://wdsa001.github.io/2021/12/17/zui-xiao-shu-xing-tu-zuo-pian-shu/#toc-heading-6)

[并查集](https://wdsa001.github.io/2021/12/23/ke-chi-jiu-hua-bing-cha-ji/#toc-heading-1)

题目要我们实现并查集的三个操作：删点，单点修改，合并集合（注意：题目中的四种操作只会有后三种操作）。

而对于死亡方式，我们只需要存储最大的罪恶值，单独讨论即可。

### 思路

- 清空，初始化数据（注意是多测）。

- 读入基本信息。

在处理单点修改时，题目要我们找到最大的罪恶值进行修改，那么我们就要维护最大值，这里用的方法是左偏树。

我们用左偏树来维护罪恶值的大根堆。

- 删点：

将节点的基础信息清空（罪恶值，左右子树节点记号，还有左右子树的父节点变成其本身），并更新左偏树，这时我们需要有基础操作：合并左右子树。就是左偏树的基本操作。

- 合并左偏树：

按照罪恶值建成一个大根堆的左偏树，我们只要快速求最大值。其他的和左偏树没变化。

- 单点修改：

找到目标集合的祖先节点，也就是我们维护的左偏树的根节点（最大罪恶值节点）根据要求更新。更新完后，将节点删除。

- 集合合并：

将目标编号的祖先找到左偏树子树合并即可。

- 去世方式：

将所有罪恶值统计一遍，注意设一个数组判重，并记录最大的罪恶值。这样操作 $2,3$ 就变成了，减去最大值和加上最大值。

最后根据题目要求输出即可。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<string>
#include<cstring>
#include<cctype>
using namespace std;
long long r_r(){//快读 
	long long x=0,f=1;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(isdigit(c)){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}
const int o_o=1e7+10;
long long t=r_r(),w=r_r(),k=r_r();
long long v_v[o_o];//每件事的罪恶值 
long long d_p[o_o];//左偏树叶子结点深度 
bool b_b[o_o];//标记，去重 
long long f_a[o_o];//存父节点 
long long l_i[o_o];//存结点左子树编号 
long long r_i[o_o];//存结点右子树编号 
long long f(long long x){//查找祖先节点 
	if(f_a[x]==x)return x;
	return f_a[x]=f(f_a[x]);
}
long long b_g(long long x,long long y){//合并子树 
	if(!x||!y)return x+y;//存在空叶子，直接合并 
	
	if(v_v[x]<v_v[y]||(v_v[x]==v_v[y]&&x>y))swap(x,y);
	//保证左子树罪恶值小于右子树罪恶值 

	r_i[x]=b_g(r_i[x],y);//右节点和右子节点继续比较，并更新根节点 
	
	if(d_p[l_i[x]]<d_p[r_i[x]])swap(l_i[x],r_i[x]);
	//保证左子树的深度不小于右子树深度
	
	f_a[l_i[x]]=f_a[r_i[x]]=f_a[x]=x;//更新父节点 
	d_p[x]=d_p[r_i[x]]+1;//更新深度 
	return x;//返回根节点编号 
}
void d_l(long long x){
	long long l=l_i[x],r=r_i[x];//记录左右子树 
	
	//更新父节点 
	f_a[l]=l;
	f_a[r]=r;
	
	l_i[x]=r_i[x]=d_p[x]=0;//清空记录 
	b_g(b_g(l,r),f(x));//合并左右子树 
}
int main(){
	for(int i=1;i<=t;i++){
		
		//初始化基础信息 
		d_p[0]=0;
		f_a[0]=0;
		l_i[0]=r_i[0]=0;
    	memset(b_b,0,sizeof(b_b));
    	
		long long n=r_r(),m=r_r();
		for(int i=1;i<=n;i++){
			v_v[i]=r_r();//读入罪恶值 
			f_a[i]=i;//初始化父节点 
			r_i[i]=l_i[i]=d_p[i]=0;//初始化信息 
		}
		for(int i=1;i<=m;i++){
			long long t_p=r_r(),x=r_r();
			if(t_p==4){
				long long y=r_r();
				x=f(x);//祖先节点 
				y=f(y);//祖先节点 
                if(x==y)continue;//已经在一个集合了，不用合并了 
                b_g(x,y);//合并子树 
			}else if(t_p==2){
				v_v[x]=0;//清零 
				d_l(x);//删点 
			}else {
				long long y=r_r();
				x=f(x);//祖先节点（罪恶值最大节点） 
				v_v[x]=max(v_v[x]-y,0ll);//如果够减直接减，否则清零 
				d_l(x);//删点 
			}
		}
		long long s_m=0,m_a=0;
		for(int i=1;i<=n;i++){
			long long g_g=f(i);//祖先节点 
			if(b_b[g_g])continue;//已经标记过 
			b_b[g_g]=1;//标记 
			m_a=max(m_a,v_v[g_g]);//记录最大值 
			s_m+=v_v[g_g];//记录罪恶值的和 
		}
		if(w==2)s_m-=m_a;//免除最大罪恶值 
		else if(w==3)s_m+=m_a;//最大罪恶值翻倍 
		
		//根据规定输出 
		if(!s_m)printf("Gensokyo 0\n"); 
		else if(s_m>k)printf("Hell %lld\n",s_m);
		else printf("Heaven %lld\n",s_m);
	}
	return 0;
}
```


---


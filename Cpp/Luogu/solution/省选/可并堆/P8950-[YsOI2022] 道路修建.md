# [YsOI2022] 道路修建

## 题目背景

Ysuperman 正在给他幼儿园里的小朋友们准备一场模板测试，下面是一道模板题，他希望你可以帮他验一下题目。

## 题目描述

某地新建了 $n$ 座城市，拟定建造 $m$ 条**单向**道路，其中第 $i$ 条道路起点为 $u_i$，终点为 $v_i$，建造费用为正整数 $w_i$。

然而在道路开始修建之前突发紧急情况，需要马上选择这些道路中的一些来修建使得所有城市的人都可以走到某 $k$ 座城市中（也就是说，所有城市的人都可以走到这 $k$ 座城市中的**至少一座**城市中），你想要知道，如果这 $k$ 座城市是等概率随机在 $n$ 座城市中的选定的，那么期望的最小修建费用是多少。

为了避免分数输入输出，你只需要输出答案对 $998244353$ 取模的结果。

## 说明/提示

#### 样例 1 解释

总共有三种选定集合城市的方案：

1. 选定集合在城市 $1$，那么选择建造 $2\to 1,3\to 1$ 两条道路花费最少，为 $2+4=6$。

2. 选定集合在城市 $2$，那么选择建造 $1\to 2,3\to 1$ 两条道路花费最少，为 $1+4=5$。

3. 选定集合在城市 $3$，那么选择建造 $1\to 2,2\to 3$ 两条道路花费最少，为 $1+3=4$。

所以期望最小花费为 $(6+5+4)/3=5$。

#### 样例 2 解释

有 $6$ 种选择集合城市的方法：

1. 选城市 $1,2$，最小花费 $9$。

2. 选城市 $1,3$，最小花费 $6$。

3. 选城市 $1,4$，最小花费 $7$。

4. 选城市 $2,3$，最小花费 $5$。

5. 选城市 $2,4$，最小花费 $6$。

6. 选城市 $3,4$，最小花费 $3$。

所以期望最小花费为 $(9+6+7+5+6+3)\div 6=6$。

#### 样例 3 解释

这里太小写不下，只配个图算了：

![](https://cdn.luogu.com.cn/upload/image_hosting/cdnuoook.png)

#### 样例 4 解释

当集合城市选在 $1,2,3$ 时，城市 $4$ 无论如何都无法达到 $1,2,3$ 中的任意一个，所以答案为 $-1$。

#### 数据范围

对于 $10\%$ 的数据，满足 $n\le 15$，$m\le 30$。

对于 $30\%$ 的数据，满足 $n\le 20$，$m\le 50$。

另有 $5\%$ 的数据，满足所有 $w_i$ 相等。

另有 $5\%$ 的数据，满足 $k=n$。

另有 $5\%$ 的数据，满足 $k=n-1$。

另有 $10\%$ 的数据，满足 $m=n$。

另有 $20\%$ 的数据，满足 $k=1$。

对于 $100\%$ 的数据，满足 $2\le n\le 10^5$，$1\le m\le 2\times 10^5$，$1\le k\le n$，$1\le u_i,v_i\le n$，$0\le w_i\le 998244352$。

## 样例 #1

### 输入

```
3 4 1
1 2 1
2 1 2
2 3 3
3 1 4```

### 输出

```
5```

## 样例 #2

### 输入

```
4 6 2
1 2 1
1 3 3
2 3 2
3 4 5
4 1 4
4 2 6```

### 输出

```
6```

## 样例 #3

### 输入

```
8 16 3
5 6 7
7 2 10
4 6 4
5 7 5
8 4 12
1 3 8
2 3 6
4 1 8
1 7 2
8 3 1
2 5 3
6 4 11
7 3 14
3 8 9
8 1 13
6 7 16```

### 输出

```
160432162```

## 样例 #4

### 输入

```
4 1 3
2 4 1```

### 输出

```
-1```

# 题解

## 作者：1kri (赞：11)

一个显然的事实：最终一定是选中的点不保留出边，未选中的点仅保留一条出边。

我们先只考虑每个点边权最小的出边，这些边连成了一个基环树森林。如果每一棵基环树的环上都有点被选中，那么答案就是未被选中的点在这个基环树森林上出边的边权和。否则，假设我们有一个环没有选中，它会导致所在的基环树中的某些点不合法。此时，我们需要考虑调整一些出边，使得环上的点合法，不难发现这样它所在的基环树的所有点都可以变得合法。

我们可以考虑把整个环缩成一个大点，它的所有出边就是环内连向环外的所有边将边权变为原边权减去原最小出边的边权后的结果。这样缩点后，新的点不选等价于原来一整个环不选，调整这个环等价于连出去一条边，而整个环不选的代价就是调整的代价，也就是某条出边的边权。这样，缩完点后的问题与原问题完全等价，我们可以一直这样做下去，每次缩点后统计新缩的点不选的方案数和代价，直到无法缩点。

在实现时，我们需要支持：找环、缩点和合并边集（需要整体减去某个值）。对于前两项，我们可以用并查集简单维护。合并边集我们可以用 $\text{set}$ 启发式合并，整体修改可以对于每个 $\text{set}$ 打上标记来记录偏移量。时间复杂度 $O(n \log^2 n)$。

---

## 作者：tobie (赞：1)

好题，补一下题解。

注意到对于 $k=1$ 的情况不弱于[最小树形图](https://www.luogu.com.cn/problem/P4716)的板子。

> 回顾一下朱刘算法的过程：我们维护了一个内向树森林，每次取出一个没有出度的根节点 $u$，找到它的最小出边 $v$，则有两种情况：
>
> 1. $u$ 和 $v$ 不连通，直接连起来即可。
> 2. $u,v$ 本来就联通，此时 $v\to u$ 这一条链上的所有点就在一个环上，此时我们可以把这个环缩成点。
>
> 但是缩点之后这个环内多了一条边。考虑环内的点 $u$，设它延伸出去的边长度为 $d$，则如果别的边从 $u$ 连出去，则需要断开 $d$ 这条边。所以我们需要枚举 $u$ 的所有边，并且将其长度减去 $d$，这样就正确了。
>
> 用带懒标记的可并堆去快速找到每个点的最小出边，复杂度为 $O(n\log n)$。

考虑拆贡献，计算每条边被包含的次数。

设我们现在考虑到 $u\to v$ 这条边。记 $S_u$ 表示 $u$ 节点包含的原图中的点的集合，则如果没有点在 $S_u$ 内，则 $S_u$ 中的点就会从这条边中走出去，贡献系数为 $\dfrac {\binom{n-|S_u|}{k} }{\binom{n}{k}}$。

判断无解也是简单的：如果最终发现有一个根节点 $u$ 满足 $|S_u|+k\le n$，则我们可以把这 $k$ 个节点全部扔到 $S_u$ 的外面，这样就寄了。

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;
namespace io{

template<typename T>
inline void gi(T &x)
{
	x=0;char ch=getchar();
	while(ch<'0'||'9'<ch) ch=getchar();
	while('0'<=ch&&ch<='9') x=x*10+ch-'0',ch=getchar();
}
template<typename T>
void print(T x)
{
	if(x<=9) return putchar(x+'0'),void();
	print(x/10),putchar(x%10+'0');
}

}using io::gi;using io::print;


const int N=5e5+9;
const int mod=998244353;

int fac[N],inv[N],ifac[N];
void ycl(int lim=2e5)
{
	fac[0]=fac[1]=inv[0]=inv[1]=ifac[0]=ifac[1]=1;
	for(int i=2;i<=lim;i++)
	{
		fac[i]=1ll*fac[i-1]*i%mod;
		inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
		ifac[i]=1ll*ifac[i-1]*inv[i]%mod;
	}
}
int C(int x,int y){return x>=y&&y>=0?1ll*fac[x]*ifac[y]%mod*ifac[x-y]%mod:0;}
int invC(int x,int y){return x>=y&&y>=0?1ll*ifac[x]*fac[y]%mod*fac[x-y]%mod:0;}

pii val[N];
int siz[N],son[N][2],tag[N],dep[N],tcnt=0;
int new_node(pii x)
{
	int u=++tcnt;
	siz[u]=1;tag[u]=son[u][0]=son[u][1]=0;
	val[u]=x;
	return u;
}
void Add(int u,int x){if(u) val[u].first+=x,tag[u]+=x;}
void pushdown(int u){if(tag[u]) Add(son[u][0],tag[u]),Add(son[u][1],tag[u]),tag[u]=0;}
void pushup(int u){siz[u]=siz[son[u][0]]+siz[son[u][1]]+1,dep[u]=dep[son[u][1]]+1;}
int Merge(int u,int v)
{
	if(!u||!v) return u+v;
	pushdown(u),pushdown(v);
	if(val[u]>val[v]) swap(u,v);
	son[u][1]=Merge(son[u][1],v);
	if(dep[son[u][0]]<dep[son[u][1]]) swap(son[u][0],son[u][1]);
	return pushup(u),u;
}
void pop(int &rt){pushdown(rt);rt=Merge(son[rt][0],son[rt][1]);}

int n,m,K;

int rt[N];

int nxt[N],len[N],tp[N];
int siz1[N];
int gettp(int x){return tp[x]==x?x:tp[x]=gettp(tp[x]);}

int bcj[N];
int getfa(int x){return bcj[x]==x?x:bcj[x]=getfa(bcj[x]);}

signed main()
{
	ycl();
	gi(n),gi(m),gi(K);
	for(int i=1;i<=m;i++)
	{
		int u,v,w;
		gi(u),gi(v),gi(w);
		if(u!=v)
		rt[u]=Merge(rt[u],new_node(make_pair(w,v)));
	}
	for(int i=1;i<=n;i++) bcj[i]=tp[i]=i;
	for(int i=1;i<=n;i++) siz1[i]=1;
	int ans=0;
	for(int u=1;u<=n;u++)
	{
		while(siz[rt[u]])
		{
			int v=val[rt[u]].second;
			if(gettp(u)==gettp(v)) {pop(rt[u]);continue;}
			(ans+=1ll*C(n-siz1[gettp(u)],K)*(val[rt[u]].first%mod+mod)%mod)%=mod;
			if(getfa(u)==getfa(v))
			{
				int uu=gettp(v),d=val[rt[u]].first;
				pop(rt[u]);
				Add(rt[u],-d);
				while(uu!=u)
				{
					Add(rt[uu],-len[uu]);
					rt[u]=Merge(rt[u],rt[uu]);
					uu=gettp(nxt[uu]);
				}
				uu=gettp(v);
				while(uu!=u)
				{
					siz1[u]+=siz1[uu];
					bcj[uu]=tp[uu]=u;
					uu=gettp(nxt[uu]);
				}
			}
			else
			{
				nxt[u]=gettp(v),len[u]=val[rt[u]].first;
				bcj[u]=v;
				break;
			}
		}
		if(!siz[rt[u]])
		{
			if(siz1[u]+K<=n) return puts("-1"),0;
			continue;
		}
	}
	print(1ll*ans*invC(n,K)%mod);
}
```

---


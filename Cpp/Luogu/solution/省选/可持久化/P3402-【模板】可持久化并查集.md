# 【模板】可持久化并查集

## 题目描述

给定 $n$ 个集合，第 $i$ 个集合内初始状态下只有一个数，为 $i$。

有 $m$ 次操作。操作分为 $3$ 种：

 - `1 a b` 合并 $a,b$ 所在集合；

 - `2 k` 回到第 $k$ 次操作（执行三种操作中的任意一种都记为一次操作）之后的状态，保证已经进行过至少 $k$ 次操作（不算本次操作），特别的，若 $k=0$，则表示回到初始状态；

 - `3 a b` 询问 $a,b$ 是否属于同一集合，如果是则输出 $1$，否则输出 $0$。

## 说明/提示

对于 $100\%$ 的数据，$1\le n\le 10^5$，$1\le m\le 2\times 10^5$，$1 \le a, b \le n$。

## 样例 #1

### 输入

```
5 6
1 1 2
3 1 2
2 0
3 1 2
2 1
3 1 2```

### 输出

```
1
0
1```

# 题解

## 作者：hegm (赞：71)

$\text{Upd. 2024/11/28}$ 修补了 $\LaTeX$，和一些错误，感谢评论区的提醒。还望管理员通过。

作为可持久化大家族的一员，题解区竟然没有多少在线的做法，真是可悲啊 ~~太好了，可以交题解了~~

#### [传送门](https://www.luogu.com.cn/problem/P3402)

------------
相比与之前的并查集，我们多出了返回之前版本的操作。

那么版本和版本之间的根本差别就是 $\text{fa}$ 数组。

我们考虑对 $\text{fa}$ 数组进行可持久化，具体的，我们在开始操作前建立一棵可持久化线段树。

线段数的叶子 $[l,l]$ 表示的是编号为 $l$ 的数的父亲。

但是这样是不够的。考虑原本的并查集的 $\text{find}$ 函数。

```cpp
int find(int now)
{
	if(fa[now]==now)return now;
	reutrn fa[now]=find(fa[now]);
}
```

我们知道，平常时候使用的并查集优化是路径压缩，查询复杂度是均摊 $O(n\alpha)$ 的。
 
但是均摊并不可以，因为我们无法保证某次查询复杂度不为 $O(n)$，这样对于可持久化来说是毁灭性的，如果你操作一次为 $O(n)$，那么我们可能会被要求返回这个版本，再次进行这种~~不讲武德~~的操作。
 
所以我们要寻找一种 $\text{find}$ 方式，使得我们的复杂度为单次严格 $O(\log n)$ 的。

这时候，按秩合并就出现了，他就有单次 $O(\log n)$ 的优美复杂度，还是严格的。

具体的，按秩合并有多重方式，

1. 按照深度

2. 按照大小

3. 随机

好的我们考虑前两个~~因为第3个被卡掉了~~

这里只讲深度，因为比较好理解，一次查询的复杂度应该为 $u\to root$ 的距离，虽然这是棵树，但是不能保证~~邪恶的~~出题人不会给我们一条链子。


- 按照深度：我们不但记录某个点的 $\text{fa}$ 还需要记录这个点的子树的深度 $\text{dep}$。

对于一次操作合并 $u,v$。

我们让 $u=\text{find}(u),v=\text{find}(v)$。

考虑把两者合并起来（假定 $\color{red}{\text{dep}_u\ge \text{dep}_v}$）

我们显然应该把 $v$ 的子树合并到 $u$ 的下面。

只有这样才能保证深度尽可能的小。

我们考虑 $\text{dep}_u$ 变成了什么？

- 如果 $\text{dep}_u=\text{dep}_v$，那么我们把 $v$ 放到 $u$ 的下方，$\text{dep}_v$ 增大了 $1$。由于 $\text{dep}_u$ 表示的是以 $u$ 为根节点的深度所以 $\text{dep}_u=\text{dep}_v+1$

- 如果 $\text{dep}_u>\text{dep}_v$ 深度不变。

如果按这样合并的顺序的话，全部合并完，我们的树高最大也只有 $\log n$。

所以复杂度为严格单次 $O(\log n)$。

那么具体的，对于一次修改，我们需要新建 **$\color{red}\text{2}$** 个版本。

首先将这个版本中的 $\text{fa}_v$ 变为 $u$，接着，我们需要修改 $\text{dep}_u$。

### 注意！

这个过程中新建立了两个版本！！！！

不能贪心的在修改 $\text{dep}_u$ 的时候直接在原本的版本上修改。

如果这样的话你会获得 $88\text{pts}$ 的好成绩。

上代码~

ps.复杂度还是很可以的，不开O2依然很稳。

### $\text{CODE}$

```cpp
#include<bits/stdc++.h>
#define N 300005
using namespace std;
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n,m,now,to,cnt,rt[N];
struct tree
{
	int ls,rs,fa,dep;
}tr[N*20];
inline int build(int l,int r)
{
	int to=++cnt;
	if(l==r)
	{
		tr[to].fa=l;
		return to;
	}
	int mid=(l+r)>>1;
	tr[to].ls=build(l,mid);
	tr[to].rs=build(mid+1,r);
	return to;
}
inline int que(int now,int l,int r,int x)
{
	if(l==r)return now;
	int mid=(l+r)>>1;
	if(mid>=x)return que(tr[now].ls,l,mid,x);
	else return que(tr[now].rs,mid+1,r,x);
}
inline int find(int now,int a)
{
	int fa=que(rt[now],1,n,a);
	if(tr[fa].fa==a)return fa;
	return find(now,tr[fa].fa);
}
inline int news(int now)
{
	int to=++cnt;
	tr[to]=tr[now];
	return to;
}
inline int hb(int now,int l,int r,int x,int f)
{
	int to=news(now);
	if(l==r)
	{
		tr[to].fa=f;
		return to;
	}
	int mid=(l+r)>>1;
	if(mid>=x)tr[to].ls=hb(tr[now].ls,l,mid,x,f);
	else tr[to].rs=hb(tr[now].rs,mid+1,r,x,f);
	return to;
}
inline int add(int now,int l,int r,int x)
{
	int to=news(now); 
	if(l==r)
	{
		tr[to].dep++;
		return to;
	}
	int mid=(l+r)>>1;
	if(mid>=x)tr[to].ls=add(tr[now].ls,l,mid,x);
	else tr[to].rs=add(tr[now].rs,mid+1,r,x);
	return to;
}
inline void merge(int now,int a,int b)
{
	rt[now]=rt[now-1];
	a=find(now,a);b=find(now,b);
	if(tr[a].fa!=tr[b].fa)
	{
		if(tr[a].dep>tr[b].dep)swap(a,b);
		rt[now]=hb(rt[now-1],1,n,tr[a].fa,tr[b].fa);
		if(tr[a].dep==tr[b].dep)rt[now]=add(rt[now],1,n,tr[b].fa);
	} 
}
inline bool pan(int now,int a,int b)
{
	a=find(now,a),b=find(now,b);
	if(tr[a].fa==tr[b].fa)return 1;
	else return 0;
}
int main()
{
	n=read();m=read();
	rt[0]=build(1,n);
	int op,a,b;
	for(int i=1;i<=m;i++)
	{
		op=read();a=read();
		if(op==1)
		{
			b=read();
			merge(i,a,b);
		}
		if(op==2)rt[i]=rt[a];
		if(op==3)
		{
			b=read();
			if(pan(i-1,a,b))cout<<1<<"\n";
			else cout<<0<<"\n";
			rt[i]=rt[i-1];
		}
	}
	return 0;
}
```

如果你不是很懂为什么需要建立两个版本可以看这里：

首先我们需要明确新建的两个版本是什么。

1. 将 $\text{fa}_v$ 变成 $u$ 这一步很好理解，没有什么问题。

2. 将 $\text{dep}_u$ 更新，这里很重要，一定要新建一个版本来更新 $\text{dep}_u$ 否则会复杂度错误。

如果你不新建版本而是直接修改 $\text{dep}_u$ ，那么假如当前版本是 $now$，我们知道 $now$ 这个版本是 $now-1$ 版本修改 $\text{fa}_v$ （即 1. ） 产生的，因此 $now$ 和 $now-1$ 所对应的 $\text{dep}_u$ 实际上是同一个数组。

如果你在 $now$ 版本直接修改了 $\text{dep}_u$ 那么意味着 $now-1$ 版本的 $\text{dep}_u$ 同时被修改了，那么这时候，我们的 $\text{dep}$ 数组就有可能不满足按秩合并的优美性质了，此时如果数据让我们回溯到 $now-1$ 版本修改，那么可能就会导致按秩合并出错，从而导致复杂度错误。

---

## 作者：zj余能 (赞：47)

既然没有强制在线，考虑离线做法。
由于可持久化版本形成了一棵树，我们直接对这棵树DFS一边，进入某点时修改，出该点时撤销。
写了启发式合并，似乎没有被卡，那就不写按秩合并了。

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <queue>
#include <cmath>
using namespace std;

const int N = 300005, INF = 1e9+7;

int yun=1, n, m, ty[N], a[N], b[N], tim[N], las[N], Ans[N];

struct DSU{
    int fa[N], siz[N], sta[N], top;
    
    inline void Init(){
        for (int i=1; i<=n; ++i)
            fa[i]=i, siz[i]=1;
    }
    int Seek(int x){
        return x==fa[x]? x:Seek(fa[x]);
    }
    inline void Merge(int x, int y){
        int fx=Seek(x), fy=Seek(y);
        if (fx==fy) return;
        if (siz[fx] < siz[fy]) swap(fx, fy);
        siz[fx]+=siz[fy]; fa[fy]=fx;
        sta[++top]=fy;
    }
    inline void Back(){
        int y=sta[top--];
        siz[fa[y]]-=siz[y]; fa[y]=y;
    }
    inline void Turn_back(int t=0){
        while (top > t) Back();
    }
}T;

struct Edge{ int to, pre; }e[N*2];
inline void Add(int a, int b){
    e[++yun]=(Edge){b, las[a]}; las[a]=yun;
}

void DFS(int x){
    tim[x]=T.top;
    if (ty[x]==3) Ans[x]=(T.Seek(a[x])==T.Seek(b[x]));
    if (ty[x]==1) T.Merge(a[x], b[x]);
    for (int i=las[x]; i; i=e[i].pre)
        DFS(e[i].to);
    T.Turn_back(tim[x]);
}

int main(){
    scanf("%d%d", &n, &m);
    T.Init();
    for (int i=1; i<=m; ++i){
        scanf("%d%d", &ty[i], &a[i]);
        if (ty[i]!=2) scanf("%d", &b[i]), Add(i-1, i);
            else Add(a[i], i);
    }
    DFS(0);
    for (int i=1; i<=m; ++i)
        if (ty[i]==3) printf("%d\n", Ans[i]);
    
    return 0;
}
```

---

## 作者：chenxinyang2006 (赞：41)

这个东西本身不是很难写，就是把并查集平时用的$fa[i]$数组可持久化一下就行了

但是由于现在需要可持久化，所以路径压缩这种均摊的方法肯定T飞，我们需要严格每次只访问$log_2 n$个点的合并方式

- **按树高合并**

  每次合并时按照树高合并，将树高小的接在树高大的下面
  
  显然，如果两棵树的树高不同，合并完以后的树树高不会增加（被接上去的节点深度 + 1，但是高的那棵树的树高，如果与矮的不同，至少比矮的大1，所以没有影响）
  
  当两棵树树高相同时，合并后的树树高 + 1
  
  设$siz(h)$表示这样合并，树高为$h$的树，最小有$siz(h)$个节点
  
  显然，当我们需要一棵树高为$h + 1$的树时，我们至少需要将两棵树高为$h$的树合并起来
  
  也就是说$siz(h + 1) \ge 2 \times siz(h)$
  
  边界$siz(1) = 1$，所以$siz(h) = 2 ^ {h - 1}$
  
  我们这样也可以求出$h$的最大值：
  
  $\because 2 ^ {h -  1} = n$ 
  
  $\therefore h = log_2 n + 1$
  
  这样就证明了，按树高合并，树高至多$log_2 n$
  
- **按$size$合并**

  每次合并时按照子树大小$(size)$合并，把$size$小的接在$size$大的下面
  
  显然，每次只有被接到下面的子树，深度才会 + 1
  
  设当前这棵树$size$为$x$，高为$h_1$，有$size$为$y$，高为$h_2$的要与之合并
  
  若$x < y$，那么$x$会被接到$y$的下面，高变为$max(h_1 + 1,h_2)$
  
  - 如果$h_2 \ge h_1 + 1$，那么实际上毫无影响，对于$y$来说，树高没有变化
  
  - 如果$h_2 < h_1 + 1$，那么树高增加$1$，但是$size$变为$x + y$
    
    $\because y > x$
    
    $\therefore x + y > 2x$
    
    $\therefore$ $size$至少翻倍 
  
  若$x > y$，那么$swap(x,y)$（大雾），实际上本情况和上面没有区别
  
  经过一番分类讨论，按$size$合并唯一会增加树高的地方，就是当$h_2 < h_1 + 1$，那么树高增加$1$，但是$size$翻倍
  
  显然，$size$至多翻倍$log_2 n$次，所以树高也是至多$log_2 n$
  
- **为什么随机化合并不对**

  总是有人觉得，随机化合并应该不会被hack，因为我合并都是随机的，你怎么卡？
  
  但是本题的#5真的就卡了随机化合并……
  
  第5个点的构造方式是：依次将每个和下一个合并

  如果写的是随机合并的话，期望有$\frac{n}{2}$次将一颗树接到一个点上，所以就会导致树高$\frac{n}{2}$
  
  所以，随机化合并不能保证树高的问题，树高甚至会退化为$\frac{n}{2}$
  
最后，给出一个按$size$合并的例子：

```cpp
#include <cstdio>
#include <cstdlib>
using namespace std;
int n,m,ti;

struct TREE{
	int T[200005],st[200005];//T[i]表示第i次操作后的根,st[i]表示i地方初始值
	int ls[200005 << 5],rs[200005 << 5],val[200005 << 5];//ls[i]是i节点左儿子,rs[i]是i节点右儿子
	int cnt;
	int build(int l,int r){//返回节点编号
		int rt = ++cnt;
		if(l == r){
			val[rt] = st[l];
			return rt;
		}
		int mid = l + r >> 1;
		ls[rt] = build(l,mid);
		rs[rt] = build(mid+1,r);
		return rt;
	}
	int upload(int pt,int l,int r,int id,int C){//pt是原版本这个节点的位置，这个操作是单点赋值
		int rt = ++cnt;
		ls[rt] = ls[pt];
		rs[rt] = rs[pt];
		
		if(l == r){
			val[rt] = C;
			return rt;
		}
		int mid = l + r >> 1;
		if(id <= mid){
			ls[rt] = upload(ls[pt],l,mid,id,C);
		}else{
			rs[rt] = upload(rs[pt],mid+1,r,id,C);
		}
		return rt;
	}
	int query(int rt,int l,int r,int id){//单点查询
		if(l == r){
			return val[rt];
		}
		int mid = l + r >> 1;
		if(id <= mid){
			return query(ls[rt],l,mid,id);
		}else{
			return query(rs[rt],mid+1,r,id);
		}
	}
}bin,siz;//bin存每个点的father,siz存每个点的size大小

int find(int x){
	while(bin.query(bin.T[ti],1,n,x) != x){//这里就是一直往上跳
		x = bin.query(bin.T[ti],1,n,x);
	}
	return x;
}

void merge(int x,int y){
	int a = find(x);
	int b = find(y);
	if(a == b) return;//自己给自己合并会导致size不正确，特判掉
	int X = siz.query(siz.T[ti],1,n,a),Y = siz.query(siz.T[ti],1,n,b);
	if(X <= Y){//如果a的size比b小，就接到b上
		bin.T[ti] = bin.upload(bin.T[ti],1,n,a,b);//bin[a] = b
		siz.T[ti] = siz.upload(siz.T[ti],1,n,b,X + Y);//注意相加size
	}else{
		bin.T[ti] = bin.upload(bin.T[ti],1,n,b,a);
		siz.T[ti] = siz.upload(siz.T[ti],1,n,a,X + Y);
	}
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i = 1;i <= n;i++){
		bin.st[i] = i;//一开始，所有点father是自己
	}
	bin.T[0] = bin.build(1,n);
	for(int i = 1;i <= n;i++){
		siz.st[i] = 1;//所有点size为1
	}
	siz.T[0] = siz.build(1,n);
	
	int opt,x,y;
	for(ti = 1;ti <= m;ti++){
		scanf("%d",&opt);
		bin.T[ti] = bin.T[ti - 1];
		siz.T[ti] = siz.T[ti - 1];//先重置一下，否则可能出锅
		if(opt == 1){
			scanf("%d%d",&x,&y);
			merge(x,y);
		}else if(opt == 2){
			scanf("%d",&x);
			bin.T[ti] = bin.T[x];
			siz.T[ti] = siz.T[x];
		}else{
			scanf("%d%d",&x,&y);
			if(find(x) == find(y)) printf("1\n");
			else printf("0\n");
		}
	}
	return 0;
}
```

按树高合并的话，只要把$merge$函数改成这样就行了

```cpp
void merge(int x,int y){
	int a = find(x);
	int b = find(y);
	if(a == b) return;
	int X = siz.query(siz.T[ti],1,n,a),Y = siz.query(siz.T[ti],1,n,b);
	if(X <= Y){
		bin.T[ti] = bin.upload(bin.T[ti],1,n,a,b);
		if(X == Y) siz.T[ti] = siz.upload(siz.T[ti],1,n,b,X + 1);//只有在树高相同时，新树树高才会 + 1
	}else{
		bin.T[ti] = bin.upload(bin.T[ti],1,n,b,a);
		if(X == Y) siz.T[ti] = siz.upload(siz.T[ti],1,n,a,Y + 1);
	}
}
```


---

## 作者：SSerxhs (赞：33)

可持久化并查集，实际上就是用可持久化数组维护的并查集，本质和可持久化数组是一样的。

可持久化数组有在线离线两种维护方法，可持久化并查集也可以离线维护。考虑把版本看成节点，那么根据版本的继承关系这些节点会构成一棵树。

可以发现，树的父子节点的差异只有连边代表的修改，可以随着 dfs 的过程修改，而修改过后撤销修改只需要可回退数组就可以完成，非常方便，这样就完成了修改操作。而对于询问操作，只需要把询问挂在版本对应节点，处理到该节点的时候回答就可以了。

复杂度分析：边数 $O(m)$，沿边走时有并查集复杂度 $O(\log n)$。时间复杂度 $O(m\log n)$，空间复杂度 $O(m)$，均优于在线做法。

```
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+2,M=2e5+2;
struct Q
{
	int u,v,w;
	Q(int a,int b,int c):u(a),v(b),w(c){}
};
vector<Q> lj[M],xw[M];
int f[N],ys[M],rk[N];
int n,m,i,x,y,z,now,q;
char ans[M<<1];
inline void read(register int &x)
{
	register int c=getchar();
	while ((c<48)||(c>57)) c=getchar();
	x=c^48;c=getchar();
	while ((c>=48)&&(c<=57))
	{
		x=x*10+(c^48);
		c=getchar();
	}
}
inline int getf(register int x)
{
	while (f[x]!=x) x=f[x];
	return x;
}
void dfs(int x)
{
	for (int i=0;i<xw[x].size();i++) ans[xw[x][i].w<<1]=48+(getf(xw[x][i].u)==getf(xw[x][i].v));
	for (int i=0,u,v,cg;i<lj[x].size();i++)
	{
		u=getf(lj[x][i].u);v=getf(lj[x][i].v);
		if (u!=v)
		{
			if (rk[u]>rk[v]) swap(u,v);
			f[u]=v;if (cg=(rk[u]==rk[v])) ++rk[v];
		}
		dfs(lj[x][i].w);
		if (u!=v)
		{
			f[u]=u;if (cg) --rk[v];
		}
	}
}
int main()
{
	read(n);read(m);
	for (i=1;i<=n;i++) f[i]=i;
	for (i=1;i<=m;i++)
	{
		read(x);read(y);
		if (x==2) {now=ys[i]=ys[y];continue;}
		read(z);
		if (x==1)
		{
			ys[i]=i;
			lj[now].push_back(Q(y,z,i));now=i;
		} else xw[ys[i]=now].push_back(Q(y,z,++q));
	}dfs(0);
	for (i=1;i<=q;i++) ans[i<<1|1]=10;
	fwrite(ans+2,q<<1,1,stdout);
}
```

---

## 作者：PassName (赞：20)

# P3402 题解

[题目传送门 P3402](https://www.luogu.com.cn/problem/P3402)

## 题目大意
给定 $n$ 个集合，第 $i$ 个集合内初始状态下只有一个数，为 $i$。

有 $m$ 次操作。操作分为 $3$ 种：

 - `1 a b` 合并 $a,b$ 所在集合；

 - `2 k` 回到第 $k$ 次操作（执行三种操作中的任意一种都记为一次操作）之后的状态；

 - `3 a b` 询问 $a,b$ 是否属于同一集合，如果是则输出 $1$，否则输出 $0$。

## 题目分析
首先我们来学一一个非常方便，简洁，且高端的东西。

它就是 `rope` 。

什么是 `rope` ？它可以当做可持久化数据结构使用，其内部构造则是一个块状链表。

调用 `rope` 的时候需要头文件 `#include<ext/rope>`

当然，以后你还会学到别的和 `rope` 一样的操作，如果你不想背那么多头文件的话，可以使用 `#include <bits/extc++.h>`

注：`#include<bits/stdc++.h>` 头文件并不包含 `#include <bits/extc++.h>` 头文件。

仅仅这样是没有办法定义 `rope` 的。

我们还需要调用命名空间， `using namespace __gnu_cxx;`

注：`__gnu_cxx` 是一个新的空间，同头文件，它也是脱离了 `namespace std` 库的存在。

当然，我们也可以通过 `__gnu_cxx::rope` 来定义。

`rope` 的声明使用方式如下：

```cpp
rope<int> arr;

struct SegmentTree
{
   int l, r;
   int id;
};
rope<node> t;

crope ch;//即 rope char;
```

在这道题中，我们需要了解 `rope` 的一个很强的函数功能 ： `replace`

`replace(p,x)` : 从 $rope$ 的下标 $p$ 开始替换成数组 $x$ ，$x$ 的长度为从 $p$ 开始替换的位数，如果 $p$ 后的位数不够就补足。

这里插一句，`rope` 本身就是一个可持久化数组。

那么放到这个题呢？

直接写正常的并查集模板就行了啊！

实际写法开一堆数组，暴力维护即可，相同的做法也可以在 [P6166](https://www.luogu.com.cn/problem/P6166) 中尝试。

## 代码
此题数据范围略大，需要吸氧
```cpp
#include <bits/stdc++.h>
#include <ext/rope>

//#define int long long
#define endl '\n'
#define rint register unsigned

using namespace __gnu_cxx;
using namespace std;

#define IN stdin->_IO_read_ptr < stdin->_IO_read_end ? *stdin->_IO_read_ptr++ : __uflow(stdin)
#define OUT(_ch) stdout->_IO_write_ptr < stdout->_IO_write_end ? *stdout->_IO_write_ptr++ = _ch : __overflow(stdout, _ch)

const int N = 2e5 + 5;

unsigned f[N];
unsigned r[N];

void read(unsigned &x)
{
    x = 0;
    char ch = IN;
    while (ch < 47)
        ch = IN;
    while (ch > 47)
        x = (x << 1) + (x << 3) + (ch & 15), ch = IN;
}

unsigned find(rope<unsigned> &fa, unsigned &i)
{
    unsigned f = fa[i];
    return f == i ? i : find(fa, f);
}

void merge(rope<unsigned> &fa, unsigned &a, unsigned &b)
{
    a = find(fa, a);
	b = find(fa, b);
	
    if (a == b)
    {
		return ;
	}
    if (r[a] > r[b])
    {
        fa.replace(b, a);		
	}
    else
    {
        if (r[a] == r[b])
        {
            r[b]++;			
		}
        fa.replace(a, b);
    }
}

signed main()
{
    unsigned n, m, op, a, b;
    read(n);
	read(m);
    rope<unsigned> fa[m + 1];
    
	for (rint i = 1; i <= n; i++)
	{
		f[i] = i;
	}    
    
	f[0] = 1;
    fa[0] = rope<unsigned>(f);
    
    for (rint i = 1; i <= m; i++)
    {
        read(op);
        
        switch (op)
        {
        case 1:
            fa[i] = fa[i - 1];
            read(a);
			read(b);
            merge(fa[i], a, b);
            break;
        case 2:
            read(a);
            fa[i] = fa[a];
            break;
        default:
            fa[i] = fa[i - 1];
            read(a); 
			read(b);
            OUT(find(fa[i], a) == find(fa[i], b) ? '1' : '0');
            puts("");
        }
    }
    
    return 0;
}
```

update （2022.8.21） ： 感谢 @[东灯](https://www.luogu.com.cn/user/160363) 提供的快读让此代码在吸氧后无压力通过此题（不吸氧可得 78pts）

---

## 作者：王鲲鹏 (赞：18)

# 多次修改 同一版本

本题解适合你在看了其他题解却感觉有点混乱的时候\

------------

若$b$是$a.b$中深度更大的点(a,b都是该集合的代表元素)\
我们应该使\
$father_{a}=b$\
当且仅当$deep_{a}==deep_{b}$时，需要令\
$deep_{b}++$\
你也许发现一个问题\
每次合并时，不仅需要修改$a$的$father$,可能还需要更新新的父亲节点的$deep$\
而其他题解里面很多是直接修改原来的版本的$b$的$deep$

即我们每次合并可能需要多修改一次，来保证深度的正确递增\
若是直接调用两次修改函数，一般的写法就会产生两个版本，\
会**多消耗很多空间**。


于是我们想到，应该把两次修改当做
### 同一个版本

------------

简而言之，就是判断当前点是新建一个副本，还是直接修改\
当我们访问到一个点（修改时）：
1. 当前版本新建的点 不需复制
2. 旧版 需要复制

于是想到保存一个标记（时间点），通过比较，确定某点是什么时候建立的。\
在修改函数开头加入如下语句：
```cpp
void Modify(int &p, int L, int R, int x, int f,int d) {
	if (p <= last) {
		tree[++cnt] = tree[p];
		p = cnt;
	}
    //...其他一般操作
}
```

在主函数中，该版本的第一次修改前，加入如下语句：
```cpp
last = cnt;
```

拓展的话，如果我们把每次的last都保存起来，还可以~~快速地~~确定某点是哪一次建立的，也许会有用处。

---

## 作者：xiezheyuan (赞：11)

[也许有更好的阅读体验](https://www.cnblogs.com/zheyuanxie/p/persistent-union-find.html)

## 简要题意

你需要维护一个并查集，支持版本回退，查连通性，合并两个点。

特别的，没进行一次操作都要新建一个版本。

## 前置知识

- 可持久化数组，如果您不会，出门左转 [【模板】可持久化线段树 1（可持久化数组）](https://www.luogu.com.cn/problem/P3919)。
- 并查集

## 找根（find）

现在我们来考虑如何find。

首先我们来研究以下正常的并查集是怎么写的（不加任何优化）:

```cpp
int find(int x){
	if(fa[x]==x){
		return x;
	}
	else{
		return find(fa[x]);
	}
}
```

事实上，我们只需要将 `fa` 替换成用可持久化数组维护，那么就可以实现可持久化了。（显然）

## 合并（merge）

同上，我们研究一下正常的并查集是怎么写的（同样，不加任何优化）：

```cpp
void merge(int x,int y){
	fa[find(x)]=find(y); // 将 x 合并到 y 上。
}
```

大家可能回想，那我也吧 `fa` 改成可持久化的不就行了吗？

如果这样子……

## 合并的优化

如果直接暴力合并，那么会TLE。因为链就可以将你的 `find` 轻松卡到 $O(n\log n)$。

回忆一下并查集的优化，有下面这几种方式:

- 路径压缩
- 按秩合并

首先，不能路径压缩，因为路径压缩时间复杂度是均摊的，可以被人卡到 $O(n\log n)$。（同样，基于均摊复杂度的珂朵莉树、Splay、替罪羊树都不能简单的可持久化）

其次我们考虑按秩合并，其中的“秩”有下面几种：

- 随机，等到合并时修改，小的合并到大的。
- 按子树大小，小的合并到大的。
- 按子树最大深度（就是子树树高），小的合并到大的。

随机方案貌似被人Hack了。我们就用第二个吧~~（因为第三个不会写）~~。

那么我们又要开一个可持久化数组（建议用结构体封装），维护子树大小，记得合并后我们更新一下（就是将新的根的子树大小加上旧的根的子树大小）。

对于证明过程，[@chenxinyang2006](https://www.luogu.com.cn/blog/chenxinyang2006/solution-p3402) 的题解已经写的很清楚了，我就不赘述了。

## 实现操作与时间复杂度分析

- 合并就用上面介绍的。
- 查连通性我们就找两个节点的根，看它们是不是一样的。
- 回退版本我们就复制一个到当前版本即可。

时间复杂度，可持久化数组读写复杂度都是 $O(\log n)$，那么：

- 回退版本时间复杂度是 $O(1)$ 的（因为只要普通数组赋值）。
- 找根的时间复杂度本身是 $O(\log n)$ （优化了），乘上可持久化的时间复杂度就是 $O(\log^{2}n)$。
- 所以，查连通性时间复杂度是 $O(\log^{2} n)$。
- 合并的时间复杂度也是 $O(\log^{2}n)$（瓶颈在找根）。

整体时间复杂度为 $O(n+m\log^{2}n)$。可以通过本题。

## 代码

本代码封装了可持久化数组和并查集，供大家参考。

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m;

namespace PersistentUnionFind{
	struct PersistentArray {
#define mid ((l+r)>>1)
		const static int SIZE = 1e5 + 5;
		struct {
			int l, r, v;
		} t[SIZE * 25];
		int top;
		int root[SIZE * 25];
		int a[SIZE];
		int newnode(int i) {
			t[++top] = t[i];
			return top;
		} 
		int build(int i, int l, int r) {
			i = (++top);
			if (l == r) {
				t[i].v = a[l];
				return i;
			}
			t[i].l = build(t[i].l, l, mid);
			t[i].r = build(t[i].r, mid + 1, r);
			return i;
		} 
		int update(int i, int l, int r, int p, int val) {
			i = newnode(i);
			if (l == r) {
				t[i].v = val;
				return i;
			}
			if (p <= mid) {
				t[i].l = update(t[i].l, l, mid, p, val);
			} else {
				t[i].r = update(t[i].r, mid + 1, r, p, val);
			}
			return i;
		} 
		int query(int i, int l, int r, int p) {
			if (l == r) {
				return t[i].v;
			}
			if (p <= mid) {
				return query(t[i].l, l, mid, p);
			} else {
				return query(t[i].r, mid + 1, r, p);
			}
		} 
		inline int Assign(int i, int version, int p, int val) {
			return update(root[version], 1, n, p, val);
		} 
		inline int Get(int i, int version, int p) {
			return query(root[version], 1, n, p);
		}
		void copyVersion(int new_,const int dst){
			root[new_]=root[dst];
		}
		void newVersionFromPoint(int pos,int val){
			root[pos]=val;
		}
	} fa,siz;
	int find(int x,int version){
	    if(fa.Get(114514,version,x)==x){
	        return x;
	    }
		else{
		    return find(fa.Get(1919810,version,x),version);
		}
	}
	void merge(int x,int y,int version){
		int fx=find(x,version),fy=find(y,version);
		if(fx==fy)return;
		int xsiz=siz.Get(114514,version,fx),ysiz=siz.Get(1919810,version,fy);
		if(xsiz<=ysiz){
			fa.newVersionFromPoint(version,fa.Assign(114514,version,fx,fy));
			siz.newVersionFromPoint(version,siz.Assign(114514,version,fy,xsiz+ysiz));
		}
		else{
			fa.newVersionFromPoint(version,fa.Assign(114514,version,fy,fx));
			siz.newVersionFromPoint(version,siz.Assign(114514,version,fx,xsiz+ysiz));
		}
	}
	bool same(int x,int y,int version){
		return find(x,version)==find(y,version);
	}
}

signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		PersistentUnionFind::fa.a[i]=i;
		PersistentUnionFind::siz.a[i]=1;
	}
	PersistentUnionFind::fa.newVersionFromPoint(0,PersistentUnionFind::fa.build(1,1,n));
	PersistentUnionFind::siz.newVersionFromPoint(0,PersistentUnionFind::siz.build(1,1,n));
	for(int i=1;i<=m;i++){
		int op,x,y;
		cin>>op>>x;
		PersistentUnionFind::fa.copyVersion(i,i-1);
		PersistentUnionFind::siz.copyVersion(i,i-1);
		if(op==1){
			cin>>y;
			PersistentUnionFind::merge(x,y,i);
		}
		if(op==2){
			PersistentUnionFind::fa.copyVersion(i,x);
			PersistentUnionFind::siz.copyVersion(i,x);
		}
		if(op==3){
			cin>>y;
			cout<<PersistentUnionFind::same(x,y,i)<<'\n';
		}
	}
	return 0;
}
```

[AC Record](https://www.luogu.com.cn/record/84916737)

---

## 作者：FlashHu (赞：8)

orz [TPLY](https://www.luogu.org/blog/88OvO88/solution-p3402) 巨佬，题解讲的挺好的。

这里重点梳理一下思路，做一个小小的补充吧。

写可持久化线段树，叶子节点维护每个位置的fa，利用每次只更新一个节点的特性，每次插入$logN$个节点，这一部分思路还是很轻松。关于此部分的其它问题可以参考下我的[可持久化线段树总结](http://www.cnblogs.com/flashhu/p/8297581.html)

一开始，写惯了常规并查集、用惯了路径压缩的我，以为在这一题里也要这么搞。~~我对我的naive真是太感动了~~

试想一下，因为路径压缩时，再次调用getf后，是要更新一部分值的。在数组上搞这些操作倒是挺快，然而在可持久化线段树里呢？每次找一个fa要$log$次，把这个节点更新又要新建log个节点，一共要循环找不满log次，理论上时间复杂度是$O(Mlog^2N)$的，但空间也是O$(Mlog^2N)$的啊，乘个系数$(Mlog^2N×sizeof(int)×4\approx 800MB$,实际不满$)$，随便算算就要炸空间了。。。。。。

那怎么办？去掉路径压缩不就得啦！并查集的按秩合并也是很优秀的方法，每次getf也只需要$log$次！时间复杂度$O(Mlog^2N)$并没有变。然后每次合并时只需要更新一个点，空间不就省下来了么？空间复杂度$O(MlogN)$。

以下是代码，数组版，叶子节点信息用结构体放了一下，略省点空间吧。。。

~~太弱了，不会封装，非递归版，可能略丑，见谅~~
```
#include<cstdio>
#define R register int
#define gc while(*++p<'0')
#define in(z) gc;z=*p&15;while(*++p>='0')z*=10,z+=*p&15
#define copy(id) lc[rt[i]=++cnt]=lc[rt[id]],rc[cnt]=rc[rt[id]];
//直接复制版本，不做改动
const int N=200009,M=4000009;
char I[M];
int n,i,cnt,cntl,rt[N],lc[M],rc[M],pos[M];
//cnt线段树节点，cntl叶子节点，pos记录对应叶子节点在数组中的位置
struct LEAF{
    int fa,dep;
}leaf[N<<2];//叶子节点信息，dep用于按秩合并
inline LEAF*getf(R k){
    R u,l,r,m;
    while(1){
        u=rt[i-1],l=1,r=n;
        while(l<r)
        {
            m=(l+r)>>1;
            if(k<=m)r=m,u=lc[u];
            else  l=m+1,u=rc[u];
        }
        if(k==leaf[pos[u]].fa)break;
        k=leaf[pos[u]].fa;//循环找fa
    }
    return&leaf[pos[u]];//返回指针方便后续操作
}
void build(R&u,R l,R r){//建初始线段树
    u=++cnt;
    if(l==r){
        leaf[pos[u]=++cntl]=(LEAF){l,0};
        return;
    }
    R m=(l+r)>>1;
    build(lc[u],l,m),build(rc[u],m+1,r);
}
inline void insert(R*u,R v,R k,LEAF newl){//更新节点
    R l=1,r=n,m;
    while(l<r)	{
        *u=++cnt;
        m=(l+r)>>1;
        if(k<=m)r=m,rc[*u]=rc[v],u=&lc[*u],v=lc[v];
        else  l=m+1,lc[*u]=lc[v],u=&rc[*u],v=rc[v];
    }
    leaf[pos[*u=++cnt]=++cntl]=newl;
}
int main(){
    fread(I,1,sizeof(I),stdin);
    register char*p=I-1;
    register LEAF*af,*bf,*tmp;
    R m,a,b;
    in(n);in(m);
    build(rt[0],1,n);
    for(i=1;i<=m;++i){
        gc;
        switch(*p){
        case '1':in(a);in(b);
            af=getf(a),bf=getf(b);
            if(af->fa==bf->fa){copy(i-1);break;}//已合并，跳过操作
            if(af->dep>bf->dep)tmp=af,af=bf,bf=tmp;//按秩合并，确定bf为深度更大的
    		insert(&rt[i],rt[i-1],af->fa,(LEAF){bf->fa,af->dep});
            if(af->dep==bf->dep)insert(&rt[i],rt[i],bf->fa,(LEAF){bf->fa,bf->dep+1});//注意更新深度
            break;
        case '2':in(a);copy(a);break;
        case '3':in(a);in(b);copy(i-1);
            putchar((getf(a)->fa==getf(b)->fa)|'0');
            putchar('\n');
        }
    }
    return 0;
}
```

---

## 作者：Saber_Master (赞：7)

# 可持久化DSU #
### 题目大意 ###

此题需要你维护一个数据结构，支持合并、查询是否在同一集合、回溯历史版本等操作。
这题的其它题解讲的很清楚。基本思想就是利用可持久化数组维护每个节点的father， 然后暴力查找，按深度合并优化复杂度。这里不一一赘述。
### 心路历程 ###

一开始看到这道题的时候也是思路也是直接上正轨了，只不过漏掉了按深度合并，调了大半天的TLE，翻题解才知道需要按深度合并才能保证复杂度。但当时感觉维护起来很麻烦，想找一篇不按秩合并的题解却找不到，最后自己参照Treap的思路瞎yy出来了一种不用按秩合并的解法。
### 解法 ###

随机化！对于每个节点我们维护一个变量$d$，其值随机，在初始化时赋值，然后每次合并的时候按照$d$值小的合并到$d$值大的上面，维护起来十分方便，均摊复杂度也是$O(n \log^{2} n)$
### code ###
```

const ll N=1e5+5, M=2e5+5;

ll n, m;
ll rt[M];

namespace seg{
	ll lc[M<<5], rc[M<<5], f[M<<5], d[M<<5], cnt;  
	
	inline void build(ll &p, ll l, ll r){
		if(!p) p=++cnt;
		if(l==r) return (void) (f[p]=l, d[p]=rand());  //随机化赋值d是精髓
		ll mid=l+r>>1;
		build(lc[p], l, mid);build(rc[p], mid+1, r);
	}
	
	inline ll getf(ll p, ll l, ll r, ll k, ll &d, ll ffa){
		if(l==r){
			++d;
			if(f[p]==l) return l;
			return getf(ffa, 1, n, f[p], d, ffa);
		}
		ll mid=l+r>>1;
		if(k<=mid) return getf(lc[p], l, mid, k, d, ffa);
		else return getf(rc[p], mid+1, r, k, d, ffa);
	}
	
	inline void update(ll &p, ll fa, ll l, ll r, ll k, ll ffa){
		p=++cnt;
		lc[p]=lc[fa], rc[p]=rc[fa];
		if(l==r) return (void) (f[p]=ffa, d[p]=rand()*rand());
		ll mid=l+r>>1;
		if(k<=mid) update(lc[p], lc[fa], l, mid, k, ffa);
		else update(rc[p], rc[fa], mid+1, r, k, ffa);
	}
	
	inline ll get(ll p, ll l, ll r, ll k){
		if(l==r) return p;
		ll mid=l+r>>1;
		if(k<=mid) return get(lc[p], l, mid, k);
		else return get(rc[p], mid+1, r, k);
	}
	
	inline void merge(ll k, ll x, ll y){
		ll dx=0,dy=0;
		ll fx=getf(rt[k-1], 1, n, x, dx, rt[k-1]), fy=getf(rt[k-1], 1, n, y, dy, rt[k-1]);
		if(fx==fy) return (void) (rt[k]=rt[k-1]);
		if(d[get(rt[k-1], 1, n, fx)]>d[get(rt[k-1], 1, n, fy)]) swap(fx, fy);
		update(rt[k], rt[k-1], 1, n, fx, fy);
	}
	
	inline void check(ll k,ll x,ll y){
		rt[k]=rt[k-1];
		ll dx=0;
		writeln(getf(rt[k], 1, n, x, dx, rt[k])==getf(rt[k], 1, n, y, dx, rt[k]));
	}
}
ll nouse;
int main(){
	srand(time(0)); srand(rand());
	read(n); read(m);
	seg::build(rt[0],1,n);
	for(R ll i=1, op, x, y, k; i<=m; i++){
		read(op);
		if(op==2){
			read(k);
			rt[i]=rt[k];
		}
		else{
			read(x);read(y);
			if(op==1) seg::merge(i, x, y);
			else seg::check(i, x, y);
		}
	}
}


```

---

## 作者：Huanle (赞：7)

第一次发题解，如有不当还请见谅。
我是做了[P3919[模板]可持久化数组](https://www.luogu.org/problem/P3919)后赶来做这题，本以为是双倍经验，没想到整整肝了两天。

闲话不扯，相信并查集按秩合并什么的不用我多说，
我想讲的主要是一个大多数人都忽略了的细节。

我们在合并两个并查集a，b的时候，假设我们按节点数量启发式合并（按秩合并亦可，这里以启发式合并为例）将节点a挂到节点b上，这时我们就要更新两个信息：一是
将a的父亲Fa修改为b，二是将b的Size加上a的Size。
这时我们就需要对当前这棵新版本的线段树更新2次，
由于修改的位置不同，理论上会新建出2倍log n个节点。

然而我观察了大多数dalao们的题解，似乎都是只新建了
log2n个节点，这就会造成新旧版本的信息紊乱。为什么会造成紊乱呢？我们知道可持久化数据结构的实现基础就是共用相同的信息，只修改需要修改的部分~~雾~~。因为我们需要进行两次修改，最坏情况会新建2倍log n个节点，如果像部分题解只新建了log n个节点，那么在第二次修改时，本应新建出的log n个节点就会直接继承旧版本的历史节点，导致你在修改信息时，连同旧版本的信息一起修改了。这样看起来似乎影响不大，毕竟很少有数据能针对到恰巧询问到了被你错误修改的历史节点的信息，
况且这个错误只会发生在第二次修改，所以你只要在第一次修改时更新的是a的父亲，并且顺利建出新节点，那么第二次修改是也只是错误地修改了并查集的Size，对于正确性没有影响~~甚至在本题跑得更快~~。

我们知道了需要新建2倍log n个节点，具体应该怎么做呢？这个看似简单的问题却困扰了我好久。最终我想出的一种方法是，用一个变量last记录本次操作前的线段树节点总数tot，同时维持在第一次更新时继承历史版本的节点这一操作不变，在第二次更新时，若节点为空，直接新建节点；否则需要判断当前节点是本次操作前的历史节点还是刚进行第一次修改后新建出的节点，若是前者，则有节点编号rt<=last，需要++tot覆盖掉当前节点，若是后者，则选择继承该节点。当然这只是我的方法，如果你有更好的方法，欢迎讨论。

语文水平实在有限，描述不清还望各位包含。
附code：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=(int)1e5+10;
int n,m,ndtot,last,i;
int root[N],vis[N*35];
struct Node{
	int fa,dep,ch[2];
}tc[N*35];
void Read(int &x){
	x=0;char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
}
void Build(int &o,int l,int r){
	o=++ndtot;
	if(l==r){
		tc[o].fa=l,tc[o].dep=1;
		return;
	}
	int mid=(l+r)>>1;
	Build(tc[o].ch[0],l,mid),
	Build(tc[o].ch[1],mid+1,r);
}
int Find(int o,int l,int r,int pos){
	if(l==r){
		if(tc[o].fa==l)return o;
		else return Find(root[i],1,n,tc[o].fa);
	}
	int mid=(l+r)>>1;
	if(pos<=mid)return Find(tc[o].ch[0],l,mid,pos);
	else return Find(tc[o].ch[1],mid+1,r,pos);
}
void Update(int &o,int q,int l,int r,int pos,int f){
    o=++ndtot,tc[o]=tc[q];
    if(l==r){
        tc[o].fa=f;return;
    }
    int mid=(l+r)>>1;
    if(pos<=mid)Update(tc[o].ch[0],tc[q].ch[0],l,mid,pos,f);
    else Update(tc[o].ch[1],tc[q].ch[1],mid+1,r,pos,f);
}
void Add(int &o,int q,int l,int r,int pos){
	if(o<=last)o=++ndtot,tc[o]=tc[q];
	if(l==r){
		tc[o].dep++;return;
	}
	int mid=(l+r)>>1;
	if(pos<=mid)Add(tc[o].ch[0],tc[q].ch[0],l,mid,pos);
	else Add(tc[o].ch[1],tc[q].ch[1],mid+1,r,pos);
}
int main(){
    freopen("a.in","r",stdin);
	freopen("a.out","w",stdout);
	Read(n),Read(m),Build(root[0],1,n),last=ndtot;
	for(i=1;i<=m;i++){
		int op,x,y;
		Read(op);
		if(op==1){
			Read(x),Read(y),root[i]=root[i-1],
			x=Find(root[i],1,n,x),y=Find(root[i],1,n,y);
			if(tc[x].fa!=tc[y].fa){
				if(tc[x].dep<tc[y].dep)
					swap(x,y);
				Update(root[i],root[i-1],1,n,tc[y].fa,tc[x].fa);
				if(tc[x].dep==tc[y].dep)
					Add(root[i],root[i-1],1,n,tc[x].fa);
				last=ndtot;
			}
		}
		else if(op==2)Read(x),root[i]=root[x];
		else {
			Read(x),Read(y),root[i]=root[i-1];
			if(tc[Find(root[i],1,n,x)].fa==tc[Find(root[i],1,n,y)].fa)
				puts("1");
			else puts("0");
		}
	}
	return 0;
}

```


---

## 作者：yizhiming (赞：6)

题解里好多离线做法哦，提供一个在线且不 TLE 的做法。

之前的伞兵做法在改了数据后就 TLE 了，目前不开氧能过。

## 题面大意

给定 $n$ 个集合，要支持合并两个集合，回溯版本，查询两点是否在同一集合。

$1\leq n\leq 10^5,1\leq m\leq2\times 10^5$

## 题目分析

首先我们注意到这道题的题目名字，那么自然而然想到将并查集可持久化，具体怎么做呢？我们不仅需要将并查集数组可持久化了，还需要考虑合并两个并查集的时候怎么办？现在可不能做到路径压缩了。

那就考虑另外一种并查集的维护方式嘛，考虑按树高合并，我们对于每个集合，都维护其树高，然后将树高低的集合合并到树高高的集合上，这样做可以保证树高的级别是 $\log n$ 的，证明~~我不会~~可以去看其它题解。

不过突然发现这个做法题解里是有的(

我一开始的写法，当两个集合的树高相同时，会选择一个将其树高增加 $1$，然而这样做，我们应该每次新建版本才对，因为我们更新的节点可以是公共节点，而导致树高出问题，所以每次更新树高时，要新建版本，这样应该就能解决许多按树高合并的会 TLE 三个点的情况了。

## Code

本文只是说明一下按树高合并可能会存在的问题，所以就少叙述，直接放代码好了。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int N = 1e5+5;
struct aa{
	int lc,rc,dep,fa;
}node[N*50];
int n,m;
int tot;
int root[N*2];
void build(int &u,int l,int r){
	u = ++tot;
	if(l==r){
		node[u].fa = l;
		return;
	}
	int mid = (l+r)/2;
	build(node[u].lc,l,mid);
	build(node[u].rc,mid+1,r);
}
void add(int &u,int v,int l,int r,int zhi){
	u = ++tot; 
	node[u] = node[v];
	if(l==r){
		node[u].dep++;
		return;
	}
	int mid = (l+r)/2;
	if(zhi<=mid){
		add(node[u].lc,node[v].lc,l,mid,zhi);
	}else{
		add(node[u].rc,node[v].rc,mid+1,r,zhi);
	}
}
int query(int u,int l,int r,int zhi){
	if(l==r){
		return u;
	}
	int mid = (l+r)/2;
	if(zhi<=mid){
		return query(node[u].lc,l,mid,zhi);
	}else{
		return query(node[u].rc,mid+1,r,zhi);
	}
}
void hebing(int &u,int v,int l,int r,int zhi,int Fa){
	u = ++tot;
	node[u].lc = node[v].lc;node[u].rc = node[v].rc;
	if(l==r){
		node[u].dep = node[v].dep;
		node[u].fa = Fa;
		return;
	}
	int mid = (l+r)/2;
	if(zhi<=mid){
		hebing(node[u].lc,node[v].lc,l,mid,zhi,Fa);
	}else{
		hebing(node[u].rc,node[v].rc,mid+1,r,zhi,Fa);
	}
}
int find(int u,int zhi){
	int now = query(u,1,n,zhi);
	if(node[now].fa==zhi){
		return now;
	}else{
		return find(u,node[now].fa);
	}
}
void merge(int ver,int x,int y){
	root[ver] = root[ver-1];
	int xx = find(root[ver],x);int yy = find(root[ver],y);
	if(node[xx].fa!=node[yy].fa){
		if(node[xx].dep>node[yy].dep){
			swap(xx,yy);
		}
		hebing(root[ver],root[ver-1],1,n,node[xx].fa,node[yy].fa);
		if(node[xx].dep==node[yy].dep){
			add(root[ver],root[ver],1,n,node[yy].fa);//注意这里要以原先版本为基础新建版本 
		}
	}
}
bool cha(int ver,int x,int y){
	root[ver] = root[ver-1];
	int xx = find(root[ver],x);int yy = find(root[ver],y);
	if(node[xx].fa==node[yy].fa){
		return true; 
	}else{
		return false;
	}
}
int main(){
	scanf("%d %d",&n,&m); 
	int opt,k,a,b;
	build(root[0],1,n);
	for(int i=1;i<=m;i++){
		scanf("%d",&opt);
		if(opt==1){
			scanf("%d %d",&a,&b);
			merge(i,a,b);
		}else if(opt==2){
			scanf("%d",&k);
			root[i] = root[k];
		}else{
			scanf("%d %d",&a,&b);
			if(cha(i,a,b)){
				cout<<1<<"\n";
			}else{
				cout<<0<<"\n";
			}
		}
	}
	return 0;
}

```

感觉这篇题解好像什么都说了，又好像什么都没说。

---

## 作者：Isshiki_Hugh (赞：6)

# 更好的阅读体验：

**[<博客传送门>](https://weepingdemon.gitee.io/blog/2020/08/24/repKCJHBCJ/)**

----

前言：主要是因为第一篇题解的`deep[]`更新太迷惑了，所以我写了一篇每个版本都更新`deep[]`的版本，而且是指针版。

真的，指针太优美了！

----

**[题面传送门](https://www.luogu.com.cn/problem/P3402)**

### 题目描述

给定 $n$ 个集合，第 $i$ 个集合内初始状态下只有一个数，为 $i$。

有 $m$ 次操作。操作分为 $3$ 种：

- `1 a b` 合并 $a$,$b$ 所在集合；
- `2 k` 回到第 $k$ 次操作（执行三种操作中的任意一种都记为一次操作）之后的状态；
- `3 a b` 询问 $a$,$b$ 是否属于同一集合，如果是则输出 $1$ ，否则输出 $0$。

### 输入格式

第一行两个整数，$n$,$m$。

接下来 $m$ 行，每行先输入一个数 $opt$。若 $opt=2$ 则再输入一个整数 $k$，否则再输入两个整数 $a$,$b$，描述一次操作。

### 样例

```
5 6
1 1 2
3 1 2
2 0
3 1 2
2 1
3 1 2
```
```
1
0
1
```

----

### 思路分析

这道题看似是个新的可持久化数据结构实际上还是一个主席树，只不过用来维护并查集而已。

看到题目里的可持久化，版本回跳等操作，我们自然而然的能联想到主席树。

关于主席树，可以参考**[这篇文章](https://weepingdemon.gitee.io/blog/2020/08/22/algHJTtree/)**

----

#### 实现可持久化

主席树能实现什么，维护一棵能够保存旧版本的树，并且每次操作规模都很小，正好符合这里的需求。而该题目需要维护的是各个版本的并查集关系。

我们来联想一下并查集，不加路径压缩的并查集就是通过实现给每一个节点赋值`father`来实现的，也就是说，只要我们用主席树来维护这个`father`，我们就能初步**实现**可持久化并查集，只不过需要一些优化了。

-----

#### 提高效率

我们考虑最需要优化的地方，并查集的效率主要都靠路径压缩来增加，然而现在由于是在主席树里实现的，我们每次只能操作比较少的点，所以路径压缩显然需要被抛弃。于是复杂度就上来了。

但还是有办法降低期望复杂度的，那就是启发式合并。我们考虑一个并查集找老大的时候的最坏情况，那就是所有节点都倚靠`father`的关系形成一条有向的链，这个时候显然是`get_father()`最慢的时候。所以我们要尽可能避免这种情况。

考虑我们现在有两个并查集的老大 $a$ 和 $b$ ，两个集合借由`father`的关系分别能够形成一棵树，且 $a$ 和 $b$ 的`father`都是自己，假设以每一个老大 $x$ 为根的树中深度最大的叶子节点的深度为`deep[x]`，并且我们假设`deep[a]` <= `deep[b]`，那我们令 $a$ 的`father`为 $b$ 的`father`也就是 $b$ 自己，此时的`deep[b]`就等于`deep[b] + (deep[b] == deep[a])`，很容易理解，当 $a$ 和 $b$ 的最大深度相同的时候，把 $a$ 变成到 $b$ 的儿子总会使 $b$ 的最大深度增加 $1$ 。当然，如果`deep[a]`严格小于`deep[b]`就不会出现这么多问题。

所以其实整题的难度都聚集在主席树的构造和启发式合并上。

----

#### 具体实现

这道题有这么几个注意点：

- 并查集不使用路径压缩   ->   **这就决定了我们要按秩合并**
- 主席树维护每一个元素各自的信息，实际上只用了树形数据结构的叶子节点，其他节点帮助实现二分查找


我们先给出主席树需要维护的东西，以节点`cur`为例：

- `cur->l`和`cur->r`：维护边界
- `cur->ls`和`cur->rs`：左右儿子
- `cur->deep`：节点深度，仅在叶子节点起作用，当且一个节点作为其所在集合的老大时表示集合的最大深度(即从集合内任意一个节点递归寻找到老大所需要的最大步数)
- `cur->fa`：节点在并查集中的父亲，仅在叶子节点起作用，用于递归寻找集合老大
- `cur->num`：节点所代表的数值，其实不起作用，其值等于叶子节点的`cur->l`或者`cur->r`（在叶子节点两者等价）

首先，根据题目要求，维护版本的操作通过主席树实现，版本的回跳等都一样。

---

##### 建树

就是正常的主席树建树

```cpp
inline void build(node * cur,int l,int r){
    cur->l = l , cur->r = r;
    if(l == r){
        cur->fa = cur->num = l , cur->deep = 1;
        return;
    }
    int mid = (l+r)>>1;
    cur->ls = create() , cur->rs = create();
    build(cur->ls,l,mid) , build(cur->rs,mid+1,r);
    return;
}
```

----

##### 找老大

接下来不管是集合合并还是查询，我们都不可避免的需要找到老大，我这里为了方便，直接回传了整个节点的指针。

还是通过递归实现，挺暴力的解法。

```cpp
inline node * find(node * cur,int x){
    if(cur->l == cur->r) return cur; 
    if(x <= cur->ls->r) return find(cur->ls,x);
    if(x >= cur->rs->l) return find(cur->rs,x);
    return 0;
}
inline node * get_fa(node * cur,int x){
    node * now = find(cur,x);
    if(x == now->fa) return now;
    else return get_fa(cur,now->fa);
}
```

----

##### 集合合并

首先我们需要找到两个集合的老大，如过现在这两个节点的老大是一样的，说明他们在一个集合里，就不用管他们了(记得版本复制)

如果不同，根据之前的分析，我们就比较他们的深度大小，然后确定谁是新的老大，谁要变成小弟

```cpp
 if(opt == 1){
      cin >> x >> y;
      node * px = get_fa(root[i-1],x) ,* py = get_fa(root[i-1],y);
            if(px->fa == py->fa){
            root[i] = root[i-1];
            continue;
      }
     //我们要把 f 的father改成 F 
      if(px->deep > py->deep) F = px->fa , f = py->fa;
      else F = py->fa , f = px->fa;
      FLAG = px->deep == py->deep;
      root[i] = upd(root[i-1],f,F);
}
```

----

##### 集合查询

直接找老大，比较老大

```cpp
略
```

----

##### 版本回退

主席树基操

```cpp
略
```

----

##### 版本更新

这是我卡最久的地方，也是我和题解不一样的地方。

[这篇题解](https://www.luogu.com.cn/blog/88OvO88/solution-p3402)里在更新节点深度的时候，直接就更新了上一个版本的深度。确实，这不会对答案的正确性造成影响，但是会一定程度影响效率，个人认为还是有必要要处理的。

所以我们这里要实现的就是，如何在一个版本里修改两个结点。其实很简单，就是在向下传递的时候同时找另外一个点

```cpp
inline node * upd(node * cur,int x,int F){
    node * now = create();
    copy(now,cur);
    if(cur->l == cur->r && cur->l == x){
        now->fa = F;
        return now;
    } else if(cur->l == cur->r && cur->l == F){
        now->deep = now->deep + FLAG;
        return now;
    }
    if(cur->l <= x && x <= cur->ls->r){
        now->ls = upd(cur->ls,x,F);
        if(cur->rs->l <= F && F <= cur->r && FLAG) now->rs = upd(cur->rs,x,F); // 就是这里，同时查找另外一个节点 
    }
    if(cur->rs->l <= x && x <= cur->r){
        now->rs = upd(cur->rs,x,F);
        if(cur->l <= F && F <= cur->ls->r && FLAG) now->ls = upd(cur->ls,x,F); // 就是这里，同时查找另外一个节点 
    }
    return now;
}
```

其他的也没什么好多说的了，直接放代码吧

----

### AC代码

```cpp
//头文件略
#define rep(i,a,b) for(register int i = (a);i <= (b);++i)
#define per(i,a,b) for(register int i = (a);i >= (b);--i)  
typedef long long ll;
typedef unsigned long long ull;
using std::string;using std::cin;using std::cout;

const int N = 1e5+10;
int n,m,a[2*N],opt,tot,FLAG;

struct node{
    int l,r,fa,deep,num;
    node * ls, * rs;
}Tree[32*N],*root[4*N];

inline node * create(){return &Tree[++tot];}

inline void copy(node * u , node * v){
    u->l = v->l , u->r = v->r;
    u->ls = v->ls , u->rs = v->rs;
    u->fa = v->fa , u->num = v->num , u->deep = v->deep;
    return;
}

inline void build(node * cur,int l,int r){
    cur->l = l , cur->r = r;
    if(l == r){
        cur->fa = cur->num = l , cur->deep = 1;
        return;
    }
    int mid = (l+r)>>1;
    cur->ls = create() , cur->rs = create();
    build(cur->ls,l,mid) , build(cur->rs,mid+1,r);
    return;
}

inline node * upd(node * cur,int x,int F){
    node * now = create();
    copy(now,cur);
    if(cur->l == cur->r && cur->l == x){
        now->fa = F;
        return now;
    } else if(cur->l == cur->r && cur->l == F){
        now->deep = now->deep + FLAG;
        return now;
    }
    if(cur->l <= x && x <= cur->ls->r){
        now->ls = upd(cur->ls,x,F);
        if(cur->rs->l <= F && F <= cur->r && FLAG) now->rs = upd(cur->rs,x,F);
    }
    if(cur->rs->l <= x && x <= cur->r){
        now->rs = upd(cur->rs,x,F);
        if(cur->l <= F && F <= cur->ls->r && FLAG) now->ls = upd(cur->ls,x,F);
    }
    return now;
}

inline node * find(node * cur,int x){
    if(cur->l == cur->r) return cur; 
    if(x <= cur->ls->r) return find(cur->ls,x);
    if(x >= cur->rs->l) return find(cur->rs,x);
    return 0;
}

inline node * get_fa(node * cur,int x){
    node * now = find(cur,x);
    if(x == now->fa) return now;
    else return get_fa(cur,now->fa);
}

int main(){
    std::ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    // freopen("in.in","r",stdin);
    // freopen("out.out","w",stdout);
    int x,y,F,D,f;
    cin >> n >> m;
    root[0] = create();
    build(root[0],1,n);
    rep(i,1,m){
        cin >> opt;
        if(opt == 1){
            cin >> x >> y;
            node * px = get_fa(root[i-1],x) ,* py = get_fa(root[i-1],y);
            if(px->fa == py->fa){
				root[i] = root[i-1];
				continue;
			}
            if(px->deep > py->deep) F = px->fa , f = py->fa;
            else F = py->fa , f = px->fa;
            FLAG = px->deep == py->deep;
            root[i] = upd(root[i-1],f,F);
        } else if(opt == 2){
            cin >> x;
            root[i] = root[x];
        } else {
            root[i] = root[i-1];
            cin >> x >> y;
            node * px = get_fa(root[i],x) ,* py = get_fa(root[i],y);
            if(px->fa == py->fa) cout << "1\n";
            else cout << "0\n";
        }
    }
    return 0;
}
```



---

## 作者：玫葵之蝶 (赞：5)

我也来水一篇题解吧

楼上说要什么按深度合并，好像不需要啊

我就是按连通块大小合并，然后跑得也挺快。。

还有就是不能加路径压缩，会被卡MLE

然后好像就没什么了。。

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#define ll long long
using namespace std;
inline int read(){
    int x=0;char ch=' ';int f=1;
    while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
    if(ch=='-')f=-1,ch=getchar();
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
    return x*f;
}
const int N=2e5+5,M=N*30;
struct node{int ls,rs,val,size;}t[M];
int n,m,sz;
int root[N];
inline void build(int &now,int l,int r){
    now=++sz;
    if(l==r){t[now].val=l;t[now].size=1;return;}
    int mid=(l+r)>>1;
    build(t[now].ls,l,mid);
    build(t[now].rs,mid+1,r);
}
int num1,num2,pos,c1,c2;
inline void query(int now,int l,int r){
    if(l==r){num1=t[now].val;num2=t[now].size;return;}
    int mid=(l+r)>>1;
    if(pos<=mid)query(t[now].ls,l,mid);
    else query(t[now].rs,mid+1,r);
}
inline void insert(int &now,int pre,int l,int r){
    now=++sz;t[now]=t[pre];
    if(l==r){if(c1)t[now].val=c1;if(c2)t[now].size=c2;return;}
    int mid=(l+r)>>1;
    if(pos<=mid)insert(t[now].ls,t[pre].ls,l,mid);
    else insert(t[now].rs,t[pre].rs,mid+1,r);
}
inline int find(int now,int x){
    pos=x;query(root[now],1,n);
    int fa=num1;
    if(fa==x)return x;
    return find(now,fa);
}
inline void merge(int now,int a,int b){
    int sa,sb,fa=find(now,a),fb=find(now,b);
    pos=fa;query(root[now],1,n);sa=num2;
    pos=fb;query(root[now],1,n);sb=num2;
    if(sa<sb)swap(sa,sb),swap(fa,fb);
    c1=0;c2=sa+sb;pos=fa;insert(root[now],root[now],1,n);
    c1=fa;c2=0;pos=fb;insert(root[now],root[now],1,n);
}
int main(){
    n=read();m=read();
    build(root[0],1,n);
    int opt,a,b,k;
    for(int i=1;i<=m;i++){
        opt=read();
        if(opt==1){
            root[i]=root[i-1];
            a=read();b=read();
            merge(i,a,b);
        }
        else if(opt==2){
            k=read();
            root[i]=root[k];
        }
        else{
            root[i]=root[i-1];
            a=read();b=read();
            int fa=find(i,a),fb=find(i,b);
            if(fa==fb)printf("1\n");
            else printf("0\n");
        }
    }
    return 0;
}
```

---

## 作者：TLE自动机 (赞：5)

这里提供一种比较复杂，跟其他题解不一样的写法，仅供参考

跟其他题解一样，考虑使用主席树维护f的可持久化版本

我按秩合并的时候老实维护了size的可持久化版本，合并的时候用size合并而不是用深度

然后a和b都要modify，于是主席树的下标要用一个lst数组维护，细节比较多。。

看代码吧：（有些无用变量不要理会）

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
int read(){
	int x=0,pos=1;char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') pos=0;
	for(;isdigit(ch);ch=getchar()) x=(x<<1)+(x<<3)+ch-'0';
	return pos?x:-x;
}
const int N = 2000021,nl=60000001;//N要开两倍，一次1操作贡献两个rt
int ls[nl],rs[nl],rt[N],n,m,tot,val[nl],top,d[nl],lst[N],lnk[N],num;
int a[N],cnt;
//d是sz值，val是f值
void build(int &now,int l,int r){//建树，最开始的f值和sz值
	now=++tot;
	if(l==r){
		val[now]=a[l];
		d[now]=1;
		return;
	}
	int mid=(l+r)>>1;
	build(ls[now],l,mid);
	build(rs[now],mid+1,r);
}
void modify(int &now,int pre,int l,int r,int pos,int vw,int dw){
	now=++tot;
	if(l==r){
		val[now]=vw;
		d[now]=dw;
		return;
	}
	int mid=(l+r)>>1;
	if(pos<=mid){
		rs[now]=rs[pre];
		modify(ls[now],ls[pre],l,mid,pos,vw,dw);
	}else{
		ls[now]=ls[pre];
		modify(rs[now],rs[pre],mid+1,r,pos,vw,dw);
	}
}//一次更新完一个点的两个信息
int query1(int now,int l,int r,int pos){
	if(l==r) return val[now];
	int mid=(l+r)>>1;
	if(pos<=mid){
		return query1(ls[now],l,mid,pos);
	}else return query1(rs[now],mid+1,r,pos);
}//这里查询一个点的父亲
int query2(int now,int l,int r,int pos){
	if(l==r) return d[now];
	int mid=(l+r)>>1;
	if(pos<=mid){
		return query2(ls[now],l,mid,pos);
	}else return query2(rs[now],mid+1,r,pos);
}//这里查询一个点的sz值
int find(int r,int now){
	int f=query1(r,1,n,now);
	if(f==now){
		return now;
	}else return find(r,f);
}//模拟并查集
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		a[i]=i;
	}
	build(rt[0],1,n);
	int now=1;
	for(int i=1;i<=m;i++){
		int opt=read();
		if(opt==1){
			int u=read(),v=read();
			int fu=find(rt[lst[i-1]],u),fv=find(rt[lst[i-1]],v);
			int su=query2(rt[lst[i-1]],1,n,fu),sv=query2(rt[lst[i-1]],1,n,fv);
			if(fu==fv){
				lst[i]=lst[i-1];
				continue;//注意这里要赋值lst
			}
			if(su>sv){
				cnt++;
				modify(rt[cnt],rt[lst[i-1]],1,n,fv,fu,sv);//注意这里是lst[i-1]而不是cnt-1，因为上一次操作可能是2或者3
				cnt++;
				modify(rt[cnt],rt[cnt-1],1,n,fu,fu,sv+su);
			}else{
				++cnt;
				modify(rt[cnt],rt[lst[i-1]],1,n,fu,fv,su);
				++cnt;
				modify(rt[cnt],rt[cnt-1],1,n,fv,fv,sv+su);
			}
			lst[i]=cnt;
		}else if(opt==2){
			int v=read();
			lst[i]=lst[v];
		}else{
			lst[i]=lst[i-1];
			int u=read(),v=read();
			int fu=find(rt[lst[i]],u),fv=find(rt[lst[i]],v);
			printf("%d\n",(fu==fv));
		}//2和3比较简单
	}
	return 0;
}
```


---


# 【模板】可持久化平衡树

## 题目背景

本题为题目 **普通平衡树** 的可持久化加强版。

**数据已经经过强化**

**感谢@Kelin 提供的一组hack数据**


## 题目描述

您需要写一种数据结构（可参考题目标题），来维护一个可重整数集合，其中需要提供以下操作（ **对于各个以往的历史版本** ）：


1、 插入 $x$

2、 删除 $x$（若有多个相同的数，应只删除一个，**如果没有请忽略该操作**）


3、 查询 $x$ 的排名（排名定义为比当前数小的数的个数 $+1$）


4、查询排名为 $x$ 的数


5、 求 $x$ 的前驱（前驱定义为小于 $x$，且最大的数，**如不存在输出** $-2^{31}+1$ ）


6、求 $x$ 的后继（后继定义为大于 $x$，且最小的数，**如不存在输出** $2^{31}-1$ ）


**和原本平衡树不同的一点是，每一次的任何操作都是基于某一个历史版本，同时生成一个新的版本。（操作3, 4, 5, 6即保持原版本无变化）**

每个版本的编号即为操作的序号（版本0即为初始状态，空树）


## 说明/提示

【数据范围】   
对于 $28\%$ 的数据，$ 1 \leq n \leq 10 $；   
对于 $44\%$ 的数据，$ 1 \leq n \leq 2\times {10}^2 $；   
对于 $60\%$ 的数据， $ 1 \leq n \leq 3\times {10}^3 $；   
对于 $84\%$ 的数据， $ 1 \leq n \leq {10}^5 $；   
对于 $92\%$ 的数据， $ 1 \leq n \leq 2\times {10}^5 $；   
对于 $100\%$ 的数据， $ 1 \leq n \leq 5 \times  10^5 $ , $|x_i| \leq {10}^9$，$0 \le v_i < i$，$1\le \text{opt} \le 6$。

**经实测，正常常数的可持久化平衡树均可通过，请各位放心**



样例说明：

共 $10$ 次操作，$11$ 个版本，各版本的状况依次是：

0.  $[]$

1.  $[9]$

2.  $[3, 9]$

3.  $[9, 10]$

4.  $[3, 9]$

5.  $[9, 10]$

6.  $[2, 9, 10]$

7.  $[2, 9, 10]$

8.  $[2, 10]$

9.  $[2, 10]$

10.  $[3, 9]$


## 样例 #1

### 输入

```
10
0 1 9
1 1 3
1 1 10
2 4 2
3 3 9
3 1 2
6 4 1
6 2 9
8 6 3
4 5 8```

### 输出

```
9
1
2
10
3```

# 题解

## 作者：小粉兔 (赞：61)

### 题意简述：

题面说的很清楚了。

### 题解：

考虑建立一棵每个节点都表示一个版本的树。

以初始版本 $0$ 为根。对于第 $i$ 个操作，从 $v_i$ 向 $i$ 连一条边，而边权则是 $opt_i$ 和 $x_i$ 的二元组，表示经过这条边上操作，可以达到下一个状态。

考虑使用权值树状数组维护操作。只需要实现单点加，查询前缀和以及树状数组上二分的操作即可。

树状数组提前插入 $-2147483647$ 和 $2147483647$ 两个数，方便统计。

因为权值范围太大，所以先离散化权值，再插入树状数组。

只需要从结点 $0$ 开始 DFS ，进入子树时执行操作，退出子树时撤销操作即可。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

const int INF = 0x7fffffff;
const int MQ = 500010;

int N, Q;
int faz[MQ], opt[MQ], a[MQ], b[MQ];
int Ans[MQ];

int eh[MQ], nxt[MQ], to[MQ], tot;
inline void ins(int x, int y) {
	nxt[++tot] = eh[x]; to[tot] = y; eh[x] = tot;
}

int B[MQ];
inline void Add(int i, int x) { for (; i <= N; i += i & -i) B[i] += x; }
inline int Qur(int i) { int A = 0; for (; i; i -= i & -i) A += B[i]; return A; }
inline int BS(int x) { int p = 0; for (int j = 1 << 18; j; j >>= 1) if ((p | j) <= N && B[p | j] <= x) x -= B[p |= j]; return p;}

void DFS(int u, int o, int x) {
	int ok = 1;
	if (o == 1) Add(x, 1);
	if (o == 2) {
		if (Qur(x) == Qur(x - 1)) ok = 0;
		else Add(x, -1);
	}
	if (o == 3) Ans[u] = Qur(x - 1);
	if (o == 4) Ans[u] = b[BS(x) + 1];
	if (o == 5) Ans[u] = b[BS(Qur(x - 1) - 1) + 1];
	if (o == 6) Ans[u] = b[BS(Qur(x)) + 1];
	
	for (int i = eh[u]; i; i = nxt[i])
		DFS(to[i], opt[to[i]], a[to[i]]);
	
	if (o == 1) Add(x, -1);
	if (o == 2 && ok) Add(x, 1);
}

int main() {
	scanf("%d", &Q);
	for (int i = 1; i <= Q; ++i) {
		scanf("%d%d%d", &faz[i], &opt[i], &a[i]);
		if (opt[i] != 4)
			b[++N] = a[i];
	} b[++N] = -INF, b[++N] = INF;
	sort(b + 1, b + N + 1);
	N = unique(b + 1, b + N + 1) - b - 1;
	for (int i = 1; i <= Q; ++i) {
		ins(faz[i], i);
		if (opt[i] != 4)
			a[i] = lower_bound(b + 1, b + N + 1, a[i]) - b;
	}
	Add(1, 1), Add(N, 1);
	DFS(0, 0, 0);
	for (int i = 1; i <= Q; ++i) {
		if(opt[i] > 2)
			printf("%d\n", Ans[i]);
	}
	return 0;
}
```

---

## 作者：yijan (赞：35)

以rope实现的，很简单的可持久数组。  
由于只是个数组，开5e5个显然会炸空间，所以这是篇部分分的题解。

rope是什么？STL的内置的可持久化的数组。其最为方便的就是可以O1复制原来的数组。事实上rope的内置实现也是平衡树，由于只需要复制根结点，O1可以做到复制历史版本。

然而这个东西不开O2会被卡T四个点！

实现思路非常简单，对于一个新的操作，先复制其上一个操作的版本（O1！）然后进行操作。

我们保证每个版本中的数字都是有序的，然后每次插入需要二分寻找插入位置，二分寻找删除位置，二分寻找前驱后缀，对于查排名就更简单了，由于是有序的，直接 begin() + rank 就可以得到。为了实现方便，选择使用STL中的lowerbound和upperbound，很慢是肯定的。对于题目中范围不大不需要太优秀的时候可以采用这种方法，四十行不到实现可持久平衡树。

科普一下rope基本操作（百度貌似有点难找）：
```cpp
#include<ext/rope>
using namespace __gnu_cxx;//rope的命名空间
rope<type> R;
R.push_back(a) //往后插入
R.insert(pos,a)//在pos位置插入a，pos是一个迭代器。
R.erase(pos,n)//在pos位置删除n个元素。
R.replace(pos,x)//从pos开始替换成x
R.substr(pos,x)//从pos开始提取x个。
//多数时候定义rope用指针（方便可持久化） 所以上面的点多数时候要换成->
```
如何进行复制？很简单，一句话：  
```cpp
rope<type>* R[1000];
R[i] = new rope<type>(*R[v]);
```
在上部分分代码前先说一下如何对其优化空间，我们发现查询操作对原数组不改变，于是可以开个bac数组查询操作直接映射到查询前的版本（两个版本一样），就可以少开写空间。但是~~yijan太懒了~~懒得写。。于是只有一个80分代码贴在这里：
```cpp
/*Heroes Never Die!*/
#include "ext/rope"
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<iostream>
using namespace std;
using namespace __gnu_cxx;
#define MAXN 500006
rope<int> *nums[MAXN];int n;
int main(){
    cin >> n;
    nums[0] = new rope<int>();
    for(int i=1;i<=n;++i){
        static int v,opt,x;
        scanf("%d%d%d",&v,&opt,&x);
        nums[i] = new rope<int>(*nums[v]);
        if(opt == 1)
            nums[i]->insert(lower_bound(nums[i]->begin(),nums[i]->end(),x)-nums[i]->begin(),x);
        if(opt == 2){
            auto it = lower_bound(nums[i]->begin(),nums[i]->end(),x);
            if(*it == x) nums[i]->erase(it-nums[i]->begin(),1);
        }
        if(opt == 3)
            printf("%d\n",(int)(lower_bound(nums[i]->begin(),nums[i]->end(),x)-nums[i]->begin()) + 1);
        if(opt == 4)
            printf("%d\n",*(nums[i]->begin() + x - 1));
        if(opt == 5){
            auto it = lower_bound(nums[i]->begin(),nums[i]->end(),x);
            if(it == nums[i]->begin() - 1) puts("-2147483647");
            else --it,printf("%d\n",*it);
        }
        if(opt == 6){
            auto it = upper_bound(nums[i]->begin(),nums[i]->end(),x);
            if(it == nums[i]->end()) puts("2147483647");
            else printf("%d\n",*it);
        }
    }
}
```

---

## 作者：GGN_2015 (赞：27)

”一道可持久化数据结构的题，如果不强制在线，那么它八成不是一道真正的可持久化数据结构的题。“ —— GGN_2015

惊奇地发现这道题其实并不需要任何可持久化数据结构。

我们只需要建立一颗”时光树“（我们暂且这样称呼它）。如果i时刻的平衡树是由$v_i$时刻发展而来的，那么我们就令”时光树“上i号结点的父亲为$v_i$。0号结点显然是整棵”时光树“的根结点。

维护一棵平衡树（我写的是treap），最开始的时候这是一棵空树。在”时光树“上DFS，每进入结点i时就在平衡树中进行操作i（修改数据结构或储存查询的结果），然后再依次DFS结点i的每个儿子。退出结点i时，就”撤销“这个结点对数据结构的修改。例如当$opt_i = 1$时，我们向数据结构中插入了元素$x_i$，离开结点i时，我们再把$x_i$从数据结构中删除。

比较特殊的是：当$opt_i = 2$时，删除是可能失败的。如果删除失败的话，我们在回溯的时候要特判（就是说不要把本就没被成功删除的$x_i$插入回数据结构中）。

附上代码之前先作出一个声明：我的treap的代码不支持可重集合，所以我用了一个类似pair的数据结构来储存元素（第一维存储元素的值，第二维记录操作的编号），这样可以保证treap中没有重复的元素。另外，我懒得写前去和后继的查询，所以我的”前驱“和”后继“查询是利用”排名“和”第k大“查询间接实现的。（我觉得这样写treap更好调试一些）

```cpp
#include <cstdio>
#include <cstdlib>
#include <queue>
#include <vector>
#include <algorithm>
using namespace std;

struct item {int val, id;};
bool operator < (item A, item B) {
	if(A.val != B.val) return A.val < B.val;
	return A.id < B.id;
}
bool operator == (item A, item B) {
	return A.val==B.val && A.id==B.id;
}

const int maxn = (500000 + 6)*2;
namespace treap {
	int ch[maxn][2], rnd[maxn], siz[maxn]; item key[maxn]; int ncnt;
	queue<int> Q;
	void maintain(int x) {
		siz[x] = 1 + siz[ch[x][0]] + siz[ch[x][1]];
	}
	int newnode() {
		if(!Q.empty()) {
			int x = Q.front(); Q.pop();
			ch[x][0] = ch[x][1] = rnd[x] = siz[x] = 0; key[x] = (item){0, 0};
			return x;
		}
		return ++ ncnt;
	}
	void rotate(int& x, int d) {
		int k = ch[x][d^1]; ch[x][d^1] = ch[k][d]; ch[k][d] = x;
		maintain(x); x = k; maintain(k);
	}
	void insert(int& x, item v) {
		if(x == 0) {
			x = newnode(); rnd[x] = rand(); siz[x] = 1; key[x] = v;
			return;
		}
		int d = v < key[x] ? 0 : 1; insert(ch[x][d], v);
		maintain(x);
		if(rnd[x] > rnd[ch[x][d]]) rotate(x, d^1);
	}
	int rnk(int x, item v) {
		if(x == 0) return 1;
		int lsiz = 1 + siz[ch[x][0]];
		if(v == key[x]) return lsiz;
		if(v < key[x]) return rnk(ch[x][0], v);
		else           return rnk(ch[x][1], v) + lsiz;
	}
	item kth(int x, int k) {
		if(x==0 || k<=0 || k>siz[x])
			return k<=0 ? (item){-2147483647, 0} : (item){2147483647, 0};
		int lsiz = 1 + siz[ch[x][0]];
		if(lsiz == k) return key[x];
		if(k < lsiz) return kth(ch[x][0], k);
		else         return kth(ch[x][1], k-lsiz);
	}
	int LSIZ(int x) {return 1 + siz[ch[x][0]];}
	void erase(int& x, int k) {
		if(x == 0) return; /// 删除元素时一定要特判检测是否相等
		int lsiz = 1 + siz[ch[x][0]];
		if(lsiz == k) {
			if(ch[x][0]==0 || ch[x][1]==0) {
				int tmp = x; x = ch[x][0] + ch[x][1]; Q.push(tmp);
				ch[tmp][0] = ch[tmp][1] = siz[tmp] = rnd[tmp] = 0;
				key[tmp] = (item){0, 0};
			}else {
				if(rnd[ch[x][0]] > rnd[ch[x][1]]) {
					rotate(x, 0); erase(ch[x][0], LSIZ(ch[x][0]));
				}else {
					rotate(x, 1); erase(ch[x][1], LSIZ(ch[x][1]));
				}
				maintain(x);
			}
			return;
		}else {
			if(k < lsiz) erase(ch[x][0], k);
			else         erase(ch[x][1], k-lsiz);
			maintain(x);
		}
	}
}

int root = 0, V[maxn], OPT[maxn], X[maxn], ANS[maxn];
namespace tree {
	vector<int> nxt[maxn];
	void addedge(int f, int t) {nxt[f].push_back(t);}
	void dfs(int x) {
		bool delsuc = 0; /// 记录删除操作是否成功
		if(OPT[x]) { /// 有操作
			if(OPT[x] == 1) { /// 插入一个元素
				treap::insert(root, (item){X[x], x});
			}else if(OPT[x] == 2) { /// 删除一个元素
				int rnk = treap::rnk(root, (item){X[x], 0}); /// 查询这个元素的排名
				int get = treap::kth(root, rnk).val; /// 得到这个元素(可能为+-inf)
				if(get == X[x]) { /// 可以删除
					treap::erase(root, rnk); delsuc = 1;
				}
			}else if(OPT[x] == 3) { /// 查排名
				ANS[x] = treap::rnk(root, (item){X[x], 0});
			}else if(OPT[x] == 4) { /// 查第k大
				ANS[x] = treap::kth(root, X[x]).val;
			}else if(OPT[x] == 5) { /// prev
				int rnk = treap::rnk(root, (item){X[x], 0}) - 1;
				int get = treap::kth(root, rnk).val;
				ANS[x] = get;
			}else if(OPT[x] == 6) { /// next
				int rnk = treap::rnk(root, (item){X[x], 0x7f7f7f7f});
				int get = treap::kth(root, rnk).val;
				ANS[x] = get;
			}
		}
		for(int i = 0; i < (int)nxt[x].size(); i ++) {
			int t = nxt[x][i]; dfs(t); /// 递归计算
		}
		if(OPT[x] == 1) { /// 回滚插入操作
			int rnk = treap::rnk(root, (item){X[x], 0}); /// 一定有
			treap::erase(root, rnk);
		}
		if(OPT[x]==2 && delsuc) {
			treap::insert(root, (item){X[x], x});
		}
	}
}

int main() {
	//freopen("nontime.in", "r", stdin);
	int n; scanf("%d", &n);
	for(int i = 1; i <= n; i ++) {
		scanf("%d%d%d", &V[i], &OPT[i], &X[i]);
		tree::addedge(V[i], i);
	}
	tree::dfs(0);
	for(int i = 1; i <= n; i ++) {
		if(OPT[i]>=3) {
			printf("%d\n", ANS[i]);
		}
	}
	return 0;
}
```

---

## 作者：stripe_python (赞：7)

现有的在线题解：FHQ-Treap、01-Trie、WBLT、线段树、替罪羊（复杂度是假的），和 [**有旋 Treap**](https://www.luogu.com.cn/article/6sbyh6lw)。

那么，既然有旋 Treap 可持久化，同样使用旋转维护平衡的 AVL 树也可以可持久化。

先介绍 AVL 树的原理：AVL 树每个节点维护树高 $high$，需要通过旋转操作保证 $|high_l-high_r| \le 1$。可以证明，满足这一性质的 AVL 树高为严格 $O(\log n)$。

AVL 树的节点定义如下：

```cpp
template <class T>
struct AVLTreeNode {
	T val;
	AVLTreeNode<T> *left, *right;
	long cnt, size, high;
	
	AVLTreeNode() :
	val(T()), left(nullptr), right(nullptr), cnt(1), size(1), high(1) {}
	
	AVLTreeNode(const T& v) :
	val(v), left(nullptr), right(nullptr), cnt(1), size(1), high(1) {}
	
	AVLTreeNode<T>* pushup() {
		size = cnt + (left ? left->size : 0) + (right ? right->size : 0);
		high = std::max(left ? left->high : 0, right ? right->high : 0) + 1;
		return this;
	}
};
```

每一次旋转、插入、删除时，我们复制一份 AVL 节点，见代码：

```cpp
static node* left_rotate(node* p) {
    // 左旋节点 p
    node *q = p->left;
    p->left = copy(p->left);   // Added
    p->left = q->right, q->right = p, p->pushup();
    return q->pushup();
}
static node* right_rotate(node* p) {
    // 右旋节点 p
    node *q = p->right;
    p->right = copy(p->right);   // Added
    p->right = q->left, q->left = p, p->pushup();
    return q->pushup();
}
static node* left_right_rotate(node* p) {
    p->left = right_rotate(p->left);
    return left_rotate(p);
}
static node* right_left_rotate(node* p) {
    p->right = left_rotate(p->right);
    return right_rotate(p);
}
```

以下是完整版代码，对于普通 AVL 模板添加的地方做了标记。其实 AVL 也挺好写的。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 5;

// AVL 树节点类，维护树高high
// AVL 树通过旋转保证 |left->high - right->high| <= 1
template <class T>
struct AVLTreeNode {
	T val;
	AVLTreeNode<T> *left, *right;
	long cnt, size, high;
	
	AVLTreeNode() :
	val(T()), left(nullptr), right(nullptr), cnt(1), size(1), high(1) {}
	
	AVLTreeNode(const T& v) :
	val(v), left(nullptr), right(nullptr), cnt(1), size(1), high(1) {}
	
	AVLTreeNode<T>* pushup() {
		size = cnt + (left ? left->size : 0) + (right ? right->size : 0);
		high = std::max(left ? left->high : 0, right ? right->high : 0) + 1;
		return this;
	}
};

template <class T, class Cmp = std::less<T>> 
struct AVLTree {
	using node = AVLTreeNode<T>;
	Cmp cmp = Cmp();
	node *roots[N];
	
	static node* copy(node* cur) {   // 复制节点
		node *res = nullptr;
		if (cur) res = new node, *res = *cur;
		return res;
	}
	
	static node* get_min(node* cur) {
		node *x = cur;
		while (x && x->left) x = x->left;
		return x;
	}
	static node* get_max(node* cur) {
		node *x = cur;
		while (x && x->right) x = x->right;
		return x;
	}
	
	static node* left_rotate(node* p) {
		// 左旋节点 p
		node *q = p->left;
		p->left = copy(p->left);   // Added
		p->left = q->right, q->right = p, p->pushup();
		return q->pushup();
	}
	static node* right_rotate(node* p) {
		// 右旋节点 p
		node *q = p->right;
		p->right = copy(p->right);   // Added
		p->right = q->left, q->left = p, p->pushup();
		return q->pushup();
	}
	static node* left_right_rotate(node* p) {
		p->left = right_rotate(p->left);
		return left_rotate(p);
	}
	static node* right_left_rotate(node* p) {
		p->right = left_rotate(p->right);
		return right_rotate(p);
	}
	static long get_high(node* p) {return p ? p->high : 0;}
	
	void insert(node*& cur, const T& val) {
		if (!cur) {
			cur = new node(val);
			return;
		}
		if (val == cur->val) {
			cur->cnt++, cur->pushup();
			return;
		}
		if (cmp(val, cur->val)) {
			cur->left = copy(cur->left);    // Added
			insert(cur->left, val), cur->pushup();
			if (get_high(cur->left) - get_high(cur->right) >= 2) {
				cur = cmp(val, cur->left->val) ? 
				left_rotate(cur) : left_right_rotate(cur);
			}
		} else {
			cur->right = copy(cur->right);   // Added
			insert(cur->right, val), cur->pushup();
			if (get_high(cur->right) - get_high(cur->left) >= 2) {
				cur = cmp(val, cur->right->val) ? 
				right_left_rotate(cur) : right_rotate(cur);
			}
		}
		cur->pushup();
	}
	
	bool remove_node(node*& cur) {
		if (!cur) return false;
		if (cur->cnt > 1) {
			cur->cnt--, cur->pushup();
			return true;
		}
		if (cur->left && cur->right) {
			node* replace = this->get_min(cur->right);
			cur->cnt = replace->cnt, cur->val = replace->val;
			replace->cnt = 1;
			remove(cur->right, replace->val), cur->pushup();
			if (get_high(cur->left) - get_high(cur->right) >= 2) {
				cur = (get_high(cur->left->left) >= get_high(cur->left->right)) ?
				left_rotate(cur) : left_right_rotate(cur);
			}
		} else {
			cur = cur->left ? cur->left : cur->right;
		}
		if (cur) cur->pushup();
		return true;
	}
	bool remove(node*& cur, const T& val) {
		if (!cur) return false;
		if (val == cur->val) return remove_node(cur);
		bool res;
		if (cmp(val, cur->val)) {
			cur->left = copy(cur->left);   // Added
			res = remove(cur->left, val), cur->pushup();
			if (get_high(cur->right) - get_high(cur->left) >= 2) {
				cur = get_high(cur->right->right) >= get_high(cur->right->left) ? 
				right_rotate(cur) : right_left_rotate(cur);
			}
		} else {
			cur->right = copy(cur->right);   // Added
			res = remove(cur->right, val), cur->pushup();
			if (get_high(cur->left) - get_high(cur->right) >= 2) {
				cur = get_high(cur->left->left) >= get_high(cur->left->right) ? 
				left_rotate(cur) : left_right_rotate(cur);
			}
		}
		if (cur) cur->pushup();
		return res;
	}
	
	int rank(node* cur, const T& val) const {
		if (!cur) return 1;
		int left_size = cur->left ? cur->left->size : 0;
		if (val == cur->val) return left_size + 1;
		if (cmp(val, cur->val)) return rank(cur->left, val);
		return rank(cur->right, val) + left_size + cur->cnt;
	}
	T kth(node* cur, int k) const {
		if (!cur) return T();
		int left_size = cur->left ? cur->left->size : 0;
		if (left_size >= k) return kth(cur->left, k);
		if (left_size < k - cur->cnt) return kth(cur->right, k - left_size - cur->cnt);
		return cur->val;
	}

	T predecessor(node *root, const T& val) const {
		node *cur = root;
		T res = -numeric_limits<T>::max();
		while (cur) {
			if (cmp(cur->val, val)) res = cur->val, cur = cur->right;
			else cur = cur->left;
		}
		return res;
	}
	T successor(node *root, const T& val) const {
		node *cur = root;
		T res = numeric_limits<T>::max();
		while (cur) {
			if (cmp(val, cur->val)) res = cur->val, cur = cur->left;
			else cur = cur->right;
		}
		return res;
	}
};

AVLTree<int> avl;
int q, v, opt, x;

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	cin >> q;
	avl.roots[0] = nullptr;
	for (int i = 1; i <= q; i++) {
		cin >> v >> opt >> x;
		avl.roots[i] = avl.copy(avl.roots[v]);
		if (opt == 1) avl.insert(avl.roots[i], x);
		else if (opt == 2) avl.remove(avl.roots[i], x);
		else if (opt == 3) cout << avl.rank(avl.roots[i], x) << '\n';
		else if (opt == 4) cout << avl.kth(avl.roots[i], x) << '\n';
		else if (opt == 5) cout << avl.predecessor(avl.roots[i], x) << '\n';
		else if (opt == 6) cout << avl.successor(avl.roots[i], x) << '\n';
		//cerr << prettify(avl.roots[i]) << endl;
	}
	return 0;
}
```

---

## 作者：Chen_Borui (赞：5)

# 可持久化 FHQ Treap

话说为什么没有数组的 FHQ Treap？

那我就来写一篇吧~

~~都来学可持久化平衡树了应该都会普通平衡树了吧。~~

## 前置知识 FHQ Treap 

这里推荐一篇博客园的文章[点这里](https://www.cnblogs.com/PinkRabbit/p/8681951.html)。

**FHQ Treap**（又称**无旋 Treap** 或**范浩强 Treap**）是一种基于 **Treap 思想**但**无需旋转操作**即可实现自平衡的二叉搜索树（BST）。它通过两个核心操作 **Split**（分裂）和 **Merge**（合并）完成所有功能（增删改查），代码简洁且易于理解。

---

**分离**（Split）：指将一颗 Treap 按照中序遍历的顺序，分割成左右两半，满足左右两半的 Treap 的所有值不变。

Split 操作实现：Split 之前要先指定一个值 $k$，表示 Split 出这个 Treap 的中序遍历中的前 $k$ 个数作为第一棵 Split 出的 Treap。

从这个 Treap 的根开始，看它的左子树的大小是否大于等于 $k$，如果是，那么说明右子树和根都在第二棵中，继续递归到左子树中。

如果不是，那么说明左子树和根都在第一棵 Treap 中，继续递归到右子树中，而且 $k$ 要减去左子树的大小加一。

```cpp
void Split(int rt,int k,int&rt1,int&rt2){
    if(!rt) {rt1=rt2=0; return;}
    if(k<=siz[ls[rt]]){
        Split(ls[rt],k,rt1,rt2);
        ls[rt]=rt2;
        up(rt);
        rt2=rt;
    }
    else{
        Split(rs[rt],k-siz[ls[rt]]-1,rt1,rt2);
        rs[rt]=rt1;
        up(rt);
        rt1=rt;
    }
}
```

其中 $rt$ 是根节点，$k$ 是第一颗子树的大小，$rt1$ 和 $rt2$ 是用来返回的值，$up$ 是更新大小的。

`siz[x]=siz[ls[x]]+siz[rs[x]]+1`

让我们画个图来理解一下分裂操作（以下图片均由 Deepseek 生成）。

![](https://cdn.luogu.com.cn/upload/image_hosting/sc519blr.png)

这是原树，左边数字代表 $val$，右边数字代表 $pri$。

让我们从 $val=5$ 分裂。

![](https://cdn.luogu.com.cn/upload/image_hosting/5as11z7v.png)

那如果是 $val=3$ 呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/x59izq08.png)



---

**合并**（Merge）：指将两颗 Treap 合并在一起，按照中序遍历中前 k 个数作为第一颗 Split 出的 Treap。

有两棵 Treap，假设要把第二棵接到第一棵后面，那么应该怎么合并呢？

考虑两个根节点的 $pri$ 值，因为第一棵在第二棵前面，所以要不然 $rt1$（第一棵的根）在 $rt2$（第二棵的根）的左子树，要不然 $rt2$ 在 $rt1$ 的右子树。

但是因为有了 $pri$ 的影响，所以只能 $rt1$ 和 $rt2$ 中 $pri$ 较大的那个作为根。

如果 $rt1$ 为根，那么有 $rt1$ 的右子树和 $rt2$ 合并作为 $rt1$ 的现在的右子树。

如果 $rt2$ 为根，那么有 $rt2$ 的左子树和 $rt1$ 合并作为 $rt2$ 的现在的左子树。

两种情况都递归进子树中即可。

```cpp
int Merge(int rt1,int rt2){
    if(!rt1 || !rt2) return rt1|rt2;
    if(pri[rt1]<pri[rt2]){
        rs[rt1]=Merge(rs[rt1],rt2);
        up(rt1);
        return rt1;
    }
    else{
        ls[rt2]=Merge(rt1,ls[rt2]);
        up(rt2);
        return rt2;
    }
}
```

什么？你说代码没看懂？那还是看图吧！

这是 $rt1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/0stvd32s.png)

这是 $rt2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/py320tjz.png)

合并。

![](https://cdn.luogu.com.cn/upload/image_hosting/qrgeyuk7.png)

是不是一下子豁然开朗了。

---

**查排名**：可以直接判断根节点的值和 $val$。

如果 $val$ 小于根节点，递归进左子树，否则递归进右子树。


```cpp
int Rank(int rt,int v){
    if(!rt) return 0;
    if(v<val[rt]) return Rank(ls[rt],v);
    else return siz[ls[rt]]+Rank(rs[rt],v)+1;
}
```

**注意，这里 Rank 并不能小写**。

---

**插入**：先查询 Rank(val)，然后按照 $rank$ 把整个 Treap Split 成两个，把 $val$ 做成一个新节点， Merge 到里面即可。


```cpp
void insert(int v){
    val[++cnt]=v;
    pri[cnt]=rand();
    siz[cnt]=1;
    int rank=Rank(Root,v);
    int rt1,rt2;
    Split(Root,rank,rt1,rt2);
    Root=Merge(Merge(rt1,cnt),rt2);
}
```

---

**删除**：先查询 Rank(val) ，然后按照 $rank$ 把整个 Treap Split 成三个，删除点，最后 Merge 剩下两个。


```cpp
void erase(int v){
    int rank=Rank(Root,v);
    int rt1,rt2,rt3,tmp;
    Split(Root,rank,rt1,rt2);
    Split(rt1,rank-1,rt3,tmp);
    Root=Merge(rt3,rt2);
}
```

---

**查询第K个值**：把整个TreapSplit成三个，输出需要的值，最后合并起来。


```cpp
int Kth(int k){
    int rt1,rt2,rt3,c;
    Split(Root,k,rt1,rt2);
    Split(rt1,k-1,rt3,c);
    Root=Merge(rt3,Merge(c,rt2));
    return val[c];
}
```

---

**前驱**：$\texttt {Kth(Rank(val-1))}$。

---

**后继**：$\texttt {Kth(Rank(val)+1)}$。

---

## 可持久化

~~讲了这么久的 FHQ Treap，终于开始可持久化了。~~

---

**Q1：为什么要用 FHQ Treap，它有什么优势？**

问题：传统旋转平衡树（AVL/红黑树）在修改时会破坏历史版本。

关键难点：旋转操作会同时修改多个节点的父子关系。

FHQ 的**天然优势**：

**无旋转**：仅通过 Split/Merge 修改局部路径。

**路径隔离**：每次操作只影响从根到目标节点的路径。

**函数式风格**：操作返回新树而不修改原树。

**代码量少**：并没有什么复杂的操作，只需要在 FHQ Treap 的板子上稍作修改即可。

---

**Q2： FHQ Treap 如何实现路径复制？**

核心原则：在 Split/Merge 递归过程中，遇到需要修改的节点就创建副本。


```cpp
void Split(int rt,int k,int &rt1,int &rt2){
    if(!rt){
        rt1=rt2=0;
        return;
    }
    int new_rt=++cnt;
    updata(new_rt,rt);
    if(k<val[rt]){
        rt2=new_rt;
        Split(ls[rt],k,rt1,ls[rt2]);
        up(rt2);
    }
    else{
        rt1=new_rt;
        Split(rs[rt],k,rs[rt1],rt2);
        up(rt1);
    }
}
int Merge(int rt1,int rt2){
    if(!rt1 || !rt2) return rt1|rt2;
    int new_rt=++cnt;
    if(pri[rt1]<pri[rt2]){
        updata(new_rt,rt1);
        rs[new_rt]=Merge(rs[new_rt],rt2);
        up(new_rt);
        return new_rt;
    }
    else{
        updata(new_rt,rt2);
        ls[new_rt]=Merge(rt1,ls[new_rt]);
        up(new_rt);
        return new_rt;
    }
}
```

**注意：分裂有两种操作，分别为大小分裂和按值分裂。我的代码在非可持久化部分是大小分裂，但是在可持久化部分为按值分裂。**

其中 $updata$ 是用来复制节点的。


```cpp
void updata(int a,int b){
    siz[a]=siz[b];
    val[a]=val[b];
    pri[a]=pri[b];
    ls[a]=ls[b];
    rs[a]=rs[b];
}
```


不难发现，它在板子的基础上只是增加了一个新节点，在此之上修改。

---

同理其他操作也略微修改。


```cpp
void insert(int &root,int v){
    int new_rt=++cnt;
    val[cnt]=v;
    pri[cnt]=rand();
    siz[cnt]=1;
    ls[cnt]=rs[cnt]=0;
    if(!root){
        root=cnt;
        return;
    }
    int rt1,rt2;
    Split(root,v,rt1,rt2);
    root=Merge(Merge(rt1,new_rt),rt2);
}
```
插入一个节点我们就新建一个节点插入。

```cpp
void erase(int &root,int v){
    int rt1,rt2,rt3;
    Split(root,v,rt1,rt3);
    Split(rt1,v-1,rt1,rt2);
    if(rt2){
        int new_rt=Merge(ls[rt2],rs[rt2]);
        root=Merge(rt1,Merge(new_rt,rt3));
    }
    else root=Merge(rt1,rt3);
    
}
```

节点删除改动有点大。

```cpp
int pre(int rt,int x){
    if(!rt) return -INF;
    if(val[rt]<x) return max(val[rt],pre(rs[rt],x));
    else return pre(ls[rt],x);
}
```

前驱非常好理解。

```cpp
int nex(int rt,int x){
    if(!rt) return INF;
    if(val[rt]>x) return min(val[rt],nex(ls[rt],x));
    else return nex(rs[rt],x);
}
```

后继同理。

---

# 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
//#define int long long
inline void read(int& a){
    int s=0, w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if (ch=='-')
            w=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
    s=s*10+ch-'0';
        ch=getchar();
    }
    a=s*w;
}
void write(int x){
    if(x<0)
        putchar('-'),x=-x;
    if(x>9)
        write(x/10);
    putchar(x%10+'0');
    return;
}
const int N=3e7+5;
const int INF=2147483647;
int siz[N],ls[N],rs[N],val[N],pri[N],root[N];
int cnt,n;
void updata(int a,int b){
    siz[a]=siz[b];
    val[a]=val[b];
    pri[a]=pri[b];
    ls[a]=ls[b];
    rs[a]=rs[b];
}
void up(int x){
    if(x){
        siz[x]=siz[ls[x]]+siz[rs[x]]+1;
    }
}
void Split(int rt,int k,int &rt1,int &rt2){
    if(!rt){
        rt1=rt2=0;
        return;
    }
    int new_rt=++cnt;
    updata(new_rt,rt);
    if(k<val[rt]){
        rt2=new_rt;
        Split(ls[rt],k,rt1,ls[rt2]);
        up(rt2);
    }
    else{
        rt1=new_rt;
        Split(rs[rt],k,rs[rt1],rt2);
        up(rt1);
    }
}
int Merge(int rt1,int rt2){
    if(!rt1 || !rt2) return rt1|rt2;
    int new_rt=++cnt;
    if(pri[rt1]<pri[rt2]){
        updata(new_rt,rt1);
        rs[new_rt]=Merge(rs[new_rt],rt2);
        up(new_rt);
        return new_rt;
    }
    else{
        updata(new_rt,rt2);
        ls[new_rt]=Merge(rt1,ls[new_rt]);
        up(new_rt);
        return new_rt;
    }
}
int Rank(int rt,int v){
    if(!rt) return 0;
    if(v<val[rt]) return Rank(ls[rt],v);
    else return siz[ls[rt]]+Rank(rs[rt],v)+1;
}
void insert(int &root,int v){
    int new_rt=++cnt;
    val[cnt]=v;
    pri[cnt]=rand();
    siz[cnt]=1;
    ls[cnt]=rs[cnt]=0;
    if(!root){
        root=cnt;
        return;
    }
    int rt1,rt2;
    Split(root,v,rt1,rt2);
    root=Merge(Merge(rt1,new_rt),rt2);
}
void erase(int &root,int v){
    int rt1,rt2,rt3;
    Split(root,v,rt1,rt3);
    Split(rt1,v-1,rt1,rt2);
    if(rt2){
        int new_rt=Merge(ls[rt2],rs[rt2]);
        root=Merge(rt1,Merge(new_rt,rt3));
    }
    else root=Merge(rt1,rt3);
    
}
int Kth(int rt, int k) {
    if(k<=siz[ls[rt]]) return Kth(ls[rt],k);
    else if(k==siz[ls[rt]]+1) return val[rt];
    else return Kth(rs[rt],k-siz[ls[rt]]-1);
}
int pre(int rt,int x){
    if(!rt) return -INF;
    if(val[rt]<x) return max(val[rt],pre(rs[rt],x));
    else return pre(ls[rt],x);
}
int nex(int rt,int x){
    if(!rt) return INF;
    if(val[rt]>x) return min(val[rt],nex(ls[rt],x));
    else return nex(rs[rt],x);
}
signed main(){
    read(n);
    root[0]=0;
    for(int i=1;i<=n;i++){
        int v,opt,x;
        read(v),read(opt),read(x);
        root[i]=root[v];
        if(opt==1) insert(root[i],x);
        if(opt==2) erase(root[i],x);
        if(opt==3) write(Rank(root[i],x-1)+1),printf("\n");
        if(opt==4) write(Kth(root[i],x)),printf("\n");
        if(opt==5) write(pre(root[i],x)),printf("\n");
        if(opt==6) write(nex(root[i],x)),printf("\n");
    }
    return 0;
}
```

这个代码是真的短。甚至不到 150 行。

---

# 复杂度

## 时间复杂度

**1. 树高期望证明**

核心定理：含 $n$ 个节点的 FHQ Treap 期望高度 $H  \leq 3\log_2 n$，且常数较小。

证明要点：

节点进入树的位置由 key（BST）决定。

在路径上的概率 = $1/(depth+1)$ (由 priority 堆性质）。

应用 Janson 不等式得期望高度上界。

2. 可持久化空间证明
单次操作空间：$E[\text {新节点数}] = E[\text {路径长度}] = E[H] = O(\log n)$。

m 次操作空间：$O(n + m \log n)$。

3. 实践中的常数因子。


|操作|平均复制节点数|实际常数因子|
|:-:|:-:|:-:|
|插入|1.5 $\log n$|2-3|
|删除|2.0 $\log n$|3-4|
|查询|0|0|



|操作|FHQ Treap|红黑树|	AVL|	Splay|
|:-:|:-:|:-:|:-:|:-:|
|插入|$O(\log n)$|$O(\log n)$|$O(log n)$|$O(\log n)$|
|删除|$O(\log n)$|$O(\log n)$|$O(log n)$|$O(\log n)$|
|查询|$O(\log n)$|$O(\log n)$|$O(log n)$|$O(\log n)$|
|分裂|$O(\log n)$|不支持|不支持|不支持|
|合并|$O(\log n)$|$O(n)$|$O(n)$|$O(n)$|

## 空间复杂度

可持久化 FHQ：$O(n + m \log n)$。

n：初始节点数。

m：操作次数。

$\log n$：每次操作创建的新节点数（路径复制）。

> **内存警告**：可持久化 FHQ Treap 每次操作创建$O(\log n)$新节点。
> 
> **建议数组大小**：$N = 3 \times 10^7$，如果是 $2 \times 10^7$ 则会 WA 一个点。

---

## 作者：registerGen (赞：4)

首先感谢 @wangrx 大佬帮我卡常！！

---

看到题解里没有指针实现的 fhq-Treap，那我就来一发吧。

可持久化 fhq-Treap 的核心是它的两个基层操作——分裂和合并。

其它的操作按照不可持久的 fhq-Treap 写就行了。

可持久化**数据结构**的核心思想是：尽可能新建更少的结点记录新版本的信息，同时保留住历史版本的结点信息。可持久化 fhq-Treap 也不例外。

fhq-Treap 的可持久化：

已知有:

```cpp
typedef std::pair<Node*,Node*> droot;
```

对于分裂操作:

```cpp
droot split(Node* x,int k)
{
	if(!x)return droot(NULL,NULL);
	droot res;
	if(siz(x->ls)>=k)
	{
		res=split(x->ls,k);
		// 我们新建一个结点，并将 x 的信息复制到它身上。
		Node* p=new Node;
		copy(p,x);
		// 下面是对 p 进行 fhq-Treap 的正常操作
		p->ls=res.second;
		p->pushup();
		res.second=p;
	}
	else
	{
		res=split(x->rs,k-siz(x->ls)-1);
		// 同理
		Node* p=new Node;
		copy(p,x);
		p->rs=res.first;
		p->pushup();
		res.first=p;
	}
	return res;
}
```

对于合并操作：

```cpp
Node* merge(Node* x,Node* y)
{
	if(!x)return y;
	if(!y)return x;
	if(x->w<y->w)
	{
		Node* p=new Node;
		// 我们新建一个结点，并将 x 的信息复制到它身上。
		copy(p,x);
		// 下面是对 p 进行 fhq-Treap 的正常操作
		p->rs=merge(p->rs,y);
		p->pushup();
		return p;
	}
	else
	{
		Node* p=new Node;
		// 同理
		copy(p,y);
		p->ls=merge(x,p->ls);
		p->pushup();
		return p;
	}
}
```

由此可见，对于可持久化 fhq-Treap 的基层操作，每更改一个结点就要分值一个新的结点出来，**否则你修改的就是历史版本上的结点！！！**

---

核心部分就讲到这里，下面给出完整代码。

时间复杂度 $O(n\log n)$，空间复杂度 $O(n\log n)$，常数较大。

写代码时要注意一些 C++ 语言上的细节（因为用的是指针）。

无注释的代码看[这里](https://www.luogu.com.cn/paste/r6mtf9k5)。

```cpp
#include<cstdio>
#include<algorithm>
#include<cstdlib>

const int N=5e5;
const int LOGN=20;
const int INF=2147483647;

struct Node
{
	int v,w;
	Node *ls,*rs;
	int siz;
	
	Node(){}
	
	Node(int _v):v(_v),w(rand()),ls(NULL),rs(NULL),siz(1){}
	
	inline void pushup()
	{
		siz=(ls?ls->siz:0)+(rs?rs->siz:0)+1;
	}
};

typedef std::pair<Node*,Node*> droot;

Node* root[N+10];
int n;

// 以下为卡常部分

#define SIZ 1000000

inline char gc()
{
	static char buf[SIZ],*p1,*p2;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,SIZ,stdin),p1==p2)?EOF:*p1++;
}

#undef SIZ

inline void read(int& x)
{
	x=0;int f=0;char c=gc();
	while(c<'0'||c>'9')f|=(c=='-'),c=gc();
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=gc();
	if(f)x=-x;
}

// @wangrx 大佬教我的卡常技巧：重载 new 运算符
// 下面的话引自 @wangrx
// new 是系统在给你分配内存，速度肯定不敢恭维
// 这么写相当于手动分配内存，但是 delete 就用不了了
// 亲测有用

char pool[1<<30],*ptop=pool+(1<<30);

void* operator new(size_t size)
{
	return ptop-=size;
}

// 以上为卡常部分
// 以下为 fhq-Treap 部分

inline int siz(Node* x)
{
	return x?x->siz:0;
}

inline void copy(Node*& p,Node* x) // 不能直接赋值，而且要引用，否则就和没改一样
{
	p->v=x->v;
	p->w=x->w;
	p->ls=x->ls;
	p->rs=x->rs;
	p->siz=x->siz;
}

droot split(Node* x,int k)
{
	if(!x)return droot(NULL,NULL);
	droot res;
	if(siz(x->ls)>=k)
	{
		res=split(x->ls,k);
		Node* p=new Node;
		copy(p,x);
		p->ls=res.second;
		p->pushup();
		res.second=p;
	}
	else
	{
		res=split(x->rs,k-siz(x->ls)-1);
		Node* p=new Node;
		copy(p,x);
		p->rs=res.first;
		p->pushup();
		res.first=p;
	}
	return res;
}

Node* merge(Node* x,Node* y)
{
	if(!x)return y;
	if(!y)return x;
	if(x->w<y->w)
	{
		Node* p=new Node;
		copy(p,x);
		p->rs=merge(p->rs,y);
		p->pushup();
		return p;
	}
	else
	{
		Node* p=new Node;
		copy(p,y);
		p->ls=merge(x,p->ls);
		p->pushup();
		return p;
	}
}

int queryrk(Node*& rt,int k)
{
	if(!rt)return 0;
	return k<=rt->v?queryrk(rt->ls,k):queryrk(rt->rs,k)+siz(rt->ls)+1;
}

int querykth(Node*& rt,int k) // 要加引用，才能真正修改 rt，以下同理
{
	droot x=split(rt,k-1);
	droot y=split(x.second,1);
	Node* res=y.first;
	rt=merge(merge(x.first,y.first),y.second);
	return res->v;
}

void insert(Node*& rt,int v)
{
	int k=queryrk(rt,v);
	droot x=split(rt,k);
	Node* now=new Node(v);
	rt=merge(merge(x.first,now),x.second);
}

void erase(Node*& rt,int v)
{
	int k=queryrk(rt,v);
	droot x=split(rt,k);
	droot y=split(x.second,1);
	if(y.first->v!=v)return;
	rt=merge(x.first,y.second);
}

int querypre(Node*& rt,int v)
{
	int k=queryrk(rt,v);
	droot x=split(rt,k-1);
	droot y=split(x.second,1);
	Node* res=y.first;
	rt=merge(merge(x.first,y.first),y.second);
	return res->v;
}

int querysuc(Node*& rt,int v)
{
	int k=queryrk(rt,v+1);
	droot x=split(rt,k);
	droot y=split(x.second,1);
	Node* res=y.first;
	rt=merge(merge(x.first,y.first),y.second);
	return res->v;
}

// 以上为 fhq-Treap 部分，没有什么奇奇怪怪的操作对吧

int main()
{
#ifndef ONLINE_JUDGE
	freopen("data.in","r",stdin);
	freopen("data.out","w",stdout);
#endif 
	srand(20070414U);
	read(n);
	insert(root[0],INF);
	insert(root[0],-INF);
	for(int q=1;q<=n;q++)
	{
		int ver,opt,x;
		read(ver),read(opt),read(x);
		root[q]=root[ver]; // 可持久化基本操作
		if(opt==1)insert(root[q],x);
		if(opt==2)erase(root[q],x);
		if(opt==3)printf("%d\n",queryrk(root[q],x)); // 其实是 queryrk(root[q],x)+1-1，注意 +1，-1 的细节问题
		if(opt==4)printf("%d\n",querykth(root[q],x+1)); // 注意 +1，-1 的细节问题
		if(opt==5)printf("%d\n",querypre(root[q],x));
		if(opt==6)printf("%d\n",querysuc(root[q],x));
	}
	return 0;
}
```

---

## 作者：xzz_cat6 (赞：3)

[这里有 AVL 全家桶](https://www.luogu.com.cn/article/3wq2o5fy)

# 【模板】可持久化平衡树
本文将介绍 AVL 树的基础操作，和可持久化。

在读本文之前，默认读者已经会 BST（二叉搜索树）的全部操作。
## 基础部分
如果你会 AVL 树的基础操作，请跳过此部分。
### AVL 树的定义与性质
1. 空二叉树是一个 AVL 树。
   
2. 如果 T 是一棵 AVL 树，那么其左右子树也是 AVL 树，并且 $|h(ls) - h(rs)| \leq 1$，h 是其左右子树的高度。
 
3. 树高为 $O(\log n)$。

4. 定义平衡因子 $BF=h(ls) - h(rs)$。

5. 一个树平衡，当且仅当这个树满足性质 3。

由于性质二，其在实现二叉搜索树时，时间复杂度为对数级别的，下文有详细证明。
### AVL 树的平衡维护
AVL 树为了保证性质二，利用旋转操作维护平衡，这也是其与 BST 唯一的不同点。
#### 旋转
```rotate()``` 操作是把某个给定节点上移一个位置，并保证**二叉搜索树**的性质不改变（如下图），建议参照代码理解。

![](https://oi-wiki.org/ds/images/splay-rotate.svg)

```cpp
void rotate(int &u,bool f){
  int v=ch[u][f];
  ch[u][f]=ch[v][!f];
  ch[v][!f]=u;
  pushup(u),pushup(v),u=v;
}
```
#### 维护平衡
如果对于某一个节点，性质 2 不再满足，由于我们每次只插入/删除一个节点，对树高的影响不超过 1，因此该节点的平衡因子的绝对值至多为 2。由于对称性，我们在此只讨论左子树的高度比右子树大 2 的情况，即下图中 $h(B)-h(E)=2$。此时，还需要根据 $h(D)$ 和 $h(C)$ 的大小关系分两种情况讨论。需要注意的是，由于我们是自底向上维护平衡的，因此对节点 D 的所有后代来说，性质 2 仍然是被满足的。

![](https://cdn.luogu.com.cn/upload/image_hosting/pzdjy1oj.png)

情况 1：如上图，发现 D 的树高比 C 的树高大，此时只需要旋转 B 到 A 处，即左旋 A。旋转完后如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/tyuen1qz.png)

---

![](https://cdn.luogu.com.cn/upload/image_hosting/pf0xgvc5.png)

情况 2：如上图，发现 D 的树高比 C 的树高要小，手模一下发现不能直接左旋 A，否则仍然不平衡。此时需要先右旋 B，再左旋 A，如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/btiq846d.png)

代码：
```cpp
void maintain(int &u){
    int chk=BF(u);
    if(chk>1){
      if(BF(ls(u))<=0)	rotate(ls(u),1);
      rotate(u,0);
    }
    else if(chk<-1){
      if(BF(rs(u))>=0)	rotate(rs(u),0);
      rotate(u,1);
    }
    else if(u)	pushup(u);
}
```
### 基本操作
#### 变量和宏定义

建议先跳过此部分，后文中遇到了变量再来这里对照。
|变量名|含义|
|:-:|:-:|
| $rt$ |根|
| $tot$ |节点数|
| $ls,ch[0]$ |左儿子|
| $rs,ch[1]$ |右儿子|
| $siz$ |子树内节点个数|
| $h$ |子树树高|
| $val$ |节点权值|
| $BF$ |子树平衡因子|

#### 新建空节点
空节点权值为 $x$。
```cpp
int newnode(int x){
    int u=++tot;
    val[u]=x,siz[u]=h[u]=1,ls(u)=rs(u)=0;
    return u;
}
```
#### 维护父节点信息
```cpp
void pushup(int u){
		siz[u]=siz[ls(u)]+siz[rs(u)]+1;
		h[u]=max(h[ls(u)],h[rs(u)])+1;
}
```
#### 旋转
即上文的 ```rotate()``` 和 ```maintain()``` 函数。
#### 插入节点
与 BST（二叉搜索树）的插入操作基本相同，只不过要用递归实现，每次插入后维护平衡。当我们插入一个节点，如果这个点的权值大于当前点的权值，就要去搜索右子树，反之搜索左子树。
```cpp
void insert(int &u,int w){
    if(!u)	return void(u=newnode(w));
    if(val[u]<w)	insert(rs(u),w);
    else	insert(ls(u),w);
    maintain(u);//维护平衡
}
```
#### 删除节点
先找到这个节点，之后如果删除节点最多有一个儿子，那么我们用它的儿子顶替它，否则和后继交换，返回时维护平衡。
```cpp
void del(int &u,int w){
    if(!u)	return;
    if(val[u]==w){
      int v=u;
      if(ls(u)&&(v=rs(u))){
        while(ls(v))	v=ls(v);
        val[u]=val[v],del(rs(u),val[v]);
      }
      else	u=ls(u)?ls(u):rs(u);
    }
    else if(val[u]<w)	del(rs(u),w);
    else	del(ls(u),w);
    maintain(u);
}
```
#### 查询第k小
等价于 BST，只需要判断出当前排名在树的哪个部分即可，类似于权值线段树。
```cpp
int kth(int x){
    int u=rt,tmp=0;
    while(u){
      if((tmp=siz[ls(u)]+1)==x)	return val[u];
      else	u=((tmp>x)?ls(u):(x-=tmp,rs(u)));
    }
    return -1;
}
```
#### 查询排名
等价于 BST，直接计算该子树中小于 $val$ 的节点个数加一。
```cpp
int qrk(int x){
    int ans=1,u=rt;
    while(u){
      if(val[u]<x)	ans+=siz[ls(u)]+1,u=rs(u);
      else	u=ls(u);
    }
    return ans;
}
```
#### 查询前驱和后继
利用二叉搜索树的性质求即可，类似于线段树二分。
```cpp
int pre(int x){
    int u=rt,ans=1-(1<<31);
    while(u){
      if(val[u]>=x)	u=ls(u);
      else	ans=val[u],u=rs(u);
    }
    return ans;
}
int nxt(int x){
    int u=rt,ans=(1<<31)-1;
    while(u){
      if(val[u]<=x)	u=rs(u);
      else	ans=val[u],u=ls(u);
    }
    return ans;
}
```
到这里就可以做一道[模板题](https://www.luogu.com.cn/problem/P3369)了，如果还不会建议先敲一遍，[代码](https://note.ms/jdioqwhfwifgigfieqofgeripqgfeiwfreq)。

### 复杂度证明
设 $f_n$ 为高度为 $n$ 的 AVL 树所包含的最少节点数，则有
$$ 
f_n=
\begin{cases}
1&(n=1)\\
2&(n=2)\\
f_{n-1}+f_{n-2}+1& (n>2)
\end{cases}
$$
根据常系数非齐次线性差分方程的解法，$\{f_n+1\}$ 是一个斐波那契数列。这里 $f_n$ 的通项为： 
$$
f_n=\frac{5+2\sqrt{5}}{5}\left(\frac{1+\sqrt{5}}{2}\right)^n+\frac{5-2\sqrt{5}}{5}\left(\frac{1-\sqrt{5}}{2}\right)^n-1
$$
斐波那契数列以指数的速度增长。对于树高 $n$ 有：
$$
n<\log_{\frac{1+\sqrt{5}}{2}} (f_n+1)<\frac{3}{2}\log_2 (f_n+1)
$$
因此 AVL 树的高度为 $O(\log f_n)$，这里的 $f_n$ 为结点数。

## 可持久化
考虑每一个修改操作之后新建一颗平衡树，那么此时只需要在查询对应的平衡树上查询，这样子保证了正确性，但是时空复杂度均爆炸。

考虑到有很多的节点其实不参与修改，节点维护的信息也不发生变化，于是对于这样的节点，直接继承信息，如下图，假设 $A$ 是新插入节点。

![](https://cdn.luogu.com.cn/upload/image_hosting/s0x4qlfz.png)

于是每当要改变树的形态时，比如：改变子树大小，子树高度，标记和左右子树时，就复制一份节点。以插入为例，注释行即为复制操作，由于树高是对数级别的，所以每次只会新建对数级别的点。

# Code
```cpp
#include<bits/stdc++.h>
#define N 500005
using namespace std;
int q,rt[N];
struct operate{
	#define BF(u) (h[ch[u][0]]-h[ch[u][1]])
	#define ls(u) (ch[u][0])
	#define rs(u) (ch[u][1])
	int tot,ch[N<<5][2],siz[N<<5],val[N<<5],h[N<<5];
	int newnode(int x){
		int u=++tot;
		val[u]=x,siz[u]=h[u]=1,ls(u)=rs(u)=0;
		return u;
	}
	int copy(int x){
		int u=++tot;
		val[u]=val[x],siz[u]=h[u]=siz[x],ls(u)=ls(x),rs(u)=rs(x);
		return u;
	}
	void pushup(int u){
		siz[u]=siz[ls(u)]+siz[rs(u)]+1;
		h[u]=max(h[ls(u)],h[rs(u)])+1;
	}
	void rotate(int &u,bool f){
		int v=copy(ch[u][f]);
		ch[u][f]=ch[v][!f];
		ch[v][!f]=u;
		pushup(u),pushup(v),u=v;
	}
	void maintain(int &u){
		int chk=BF(u);
		if(chk>1){
			if(BF(ls(u))<=0)	rotate(ls(u),1);
			rotate(u,0);
		}
		else if(chk<-1){
			if(BF(rs(u))>=0)	rotate(rs(u),0);
			rotate(u,1);
		}
		else if(u)	pushup(u);
	}
	void insert(int &u,int w){
		if(!u)	return void(u=newnode(w));
		else	u=copy(u);
		if(val[u]<w)	insert(rs(u),w);
		else	insert(ls(u),w);
		maintain(u);
	}
	void del(int &u,int w){
		if(!u)	return;
		u=copy(u);
		if(val[u]==w){
			int v=u;
			if(ls(u)&&(v=rs(u))){
				while(ls(v))	v=ls(v);
				val[u]=val[v],del(rs(u),val[v]);
			}
			else	u=ls(u)?ls(u):rs(u);
		}
		else if(val[u]<w)	del(rs(u),w);
		else	del(ls(u),w);
		maintain(u);
	}
	int kth(int u,int x){
		int tmp=0;
		while(u){
			if((tmp=siz[ls(u)]+1)==x)	return val[u];
			else	u=((tmp>x)?ls(u):(x-=tmp,rs(u)));
		}
		return -1;
	}
	int qrk(int u,int x){
		int ans=1;
		while(u){
			if(val[u]<x)	ans+=siz[ls(u)]+1,u=rs(u);
			else	u=ls(u);
		}
		return ans;
	}
	int pre(int u,int x){
		int ans=1-(1<<31);
		while(u){
			if(val[u]>=x)	u=ls(u);
			else	ans=val[u],u=rs(u);
		}
		return ans;
	}
	int nxt(int u,int x){
		int ans=(1<<31)-1;
		while(u){
			if(val[u]<=x)	u=rs(u);
			else	ans=val[u],u=ls(u);
		}
		return ans;
	}
}T;
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>q;
	for(int i=1;i<=q;i++){
		int op,x,id;
		cin>>id>>op>>x,rt[i]=rt[id];
		switch(op){
			case 1:T.insert(rt[i],x);break;
			case 2:T.del(rt[i],x);break;
			case 3:cout<<T.qrk(rt[i],x)<<'\n';break;
			case 4:cout<<T.kth(rt[i],x)<<'\n';break;
			case 5:cout<<T.pre(rt[i],x)<<'\n';break;
			case 6:cout<<T.nxt(rt[i],x)<<'\n';break;
		}
	}
	return 0;
}
```

---

## 作者：pyqpyq (赞：3)

话说你们是对指针版的主席树有什么意见吗？

为什么题解里面的主席树没一个是用指针的？

那我就发一波吧……

20200121 UPD:更正了一个严重错误
# 大致思路
前置芝士：[主席树](https://www.luogu.com.cn/problem/P3834)

~~众所周知~~权值线段树可以维护一个可重集，并在 $O(logn)$ 的时间复杂度内完成全局第 $k$ 大、前缀和、插入、删除等事情，可以替代一些普通平衡树。

所以我们可以写一棵权值线段树来完成此题。每个节点维护的是当前节点所代表的**数值区间**的数的个数。

由于题目要求可持久化，所以我们可以写主席树节省空间，不必每个操作再建一颗。

数据范围 $|x_i|\le10^9$ 告诉我们要离散化（当然可以写动态开点权值线段树，然而我不会……）
# 代码分析
~~懒得写注释直接讲吧~~
## 变量定义
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node
{
	int data;
	node*left,*righ;
}*root[500011];
struct opts
{
	int numb,from,opti,frnu,gonu;
} czli[500011];
int n,a,b,stef[500011];
bool cmp1(opts a,opts b)
{
	return a.frnu<b.frnu;
}
bool cmp2(opts a,opts b)
{
	return a.numb<b.numb;
}
```

```node``` 是权值线段树的节点。```data``` 是此节点维护的**数值**区间内的数的个数，```left``` 和 ```righ``` 是左右子节点的指针。```root``` 是每次操作后树根的指针。

```opts``` 用来离散化。```numb``` 是操作序号，```from```、```opti``` 和 ```frnu``` 是题目给出的 $v_i$、$opt_i$ 和 $x_i$，```gonu``` 是离散化后此结构体代表的数。

```n``` 就是题目给出的 $n$，```a``` 和 ```b``` 是离散化后 ```gonu``` 的最大值和最小值（所以 ```a``` 衡为 $1$），```stef``` 维护每个 ```gonu``` 所代表的 ```frnu```。

```cmp1``` 和 ```cmp2``` 在以后排序中使用。
## 离散化
```cpp
scanf("%d",&n);
for(int i=1; i<=n; czli[i].numb=++i)
	scanf("%d%d%d",&czli[i].from,&czli[i].opti,&czli[i].frnu);
sort(czli+1,czli+n+1,cmp1);
for(int i=1; i<=n; ++i)
	stef[czli[i].gonu=czli[i-1].gonu+(czli[i].frnu!=czli[i-1].frnu)]=czli[i].frnu;
root[0]=build(a=czli[1].gonu,b=czli[n].gonu);
sort(czli+1,czli+n+1,cmp2);
```
~~大家都会吧那我不说了。~~

可能有人会问 ```build``` 是什么，它在后面：
## 建树
```cpp
node*build(int l,int r)
{
	node*s=new node;
	s->data=0;
	if(l==r)
		s->left=s->righ=NULL;
	else if(l!=r)
	{
		s->left=build(l,l+r>>1);
		s->righ=build((l+r>>1)+1,r);
	}
	return s;
}
```
由于一开始可重集里没数，所以这里建了一颗 ```data``` 全是 $0$ 的树。

因为我们的结构体里没存节点代表的**数值**区间，所以这里以及接下来的**数值**区间都由传参的形式给出。
## 操作1&2
```cpp
inline int maxn(int a,int b)
{
	return a>b?a:b;
}
node*opt1_2(node*f,int x,int l,int r,int k)
{
	node*s=new node;
	if(l==x&&x==r)
	{
		s->left=s->righ=NULL;
		s->data=maxn(f->data+k,0);
	}
	else if(l<=x&&x<=l+r>>1)
	{
		s->left=opt1_2(f->left,x,l,l+r>>1,k);
		s->righ=f->righ;
		s->data=s->left->data+s->righ->data;
	}
	else if((l+r>>1)+1<=x&&x<=r)
	{
		s->left=f->left;
		s->righ=opt1_2(f->righ,x,(l+r>>1)+1,r,k);
		s->data=s->left->data+s->righ->data;
	}
	return s;
}
```
我们会发现操作 $1$ 和操作 $2$ 十分像，所以我们可以把它们合并到一起，以 ```k``` 区分，```k``` 为 $1$ 时为操作 $1$，```k``` 为 $-1$ 时为操作 $2$。

第 $1$ 个 ```if``` 处理递归到叶节点，第 $2$ 个 ```else if``` 处理往左子树递归，第 $3$ 个 ```else if``` 处理往右子树递归。（下同）

由于有时操作 $2$ 的数可以不存在，此时 ```s``` 的 ```data``` 为 $0$，所以发现叶节点的 ```data``` 为 $-1$
时要及时赋为 $0$。

```f``` 是原树上的此时要建的节点所对应的节点的指针。不理解的可以看图：
![主席树](https://cdn.luogu.com.cn/upload/image_hosting/kyahf30y.png)

再不理解就去做[模板](https://www.luogu.com.cn/problem/P3834)吧……
## 操作3&4
```cpp
int opt3(node*f,int x,int l,int r)
{
	if(l==x&&x==r)
		return 1;
	else if(l<=x&&x<=l+r>>1)
		return opt3(f->left,x,l,l+r>>1);
	else if((l+r>>1)+1<=x&&x<=r)
		return f->left->data+opt3(f->righ,x,(l+r>>1)+1,r);
}
int opt4(node*f,int x,int l,int r)
{
	if(l==r)
		return l;
	else if(1<=x&&x<=f->left->data)
		return opt4(f->left,x,l,l+r>>1);
	else if(f->left->data+1<=x&&x<=f->data)
		return opt4(f->righ,x-f->left->data,(l+r>>1)+1,r);
}
```
注意 ```opt3``` 的返回值是在以 ```f``` 为根的子树中查询 ```x``` 的排名。 

而且 ```opt4``` 中的 ```x``` 表示的是在以 ```f``` 为根的子树中查找第 $x$ 大的数，而非全局。
## 操作5&6
```cpp
int help(node*f,int x,int l,int r)
{
	if(l==x&&x==r)
		return f->data;
	else if(l<=x&&x<=l+r>>1)
		return help(f->left,x,l,l+r>>1);
	else if((l+r>>1)+1<=x&&x<=r)
		return help(f->righ,x,(l+r>>1)+1,r);
}
int opt5(node*f,int x,int l,int r)
{
	int s=opt3(f,x,l,r)-1;
	if(s==0)
		return INT_MIN;
	else
		return opt4(f,s,l,r);
}
int opt6(node*f,int x,int l,int r)
{
	int s=opt3(f,x,l,r)-1,p=help(f,x,l,r);
	if(s==r)
		return INT_MAX;
	else
		return opt4(f,s+p+1,l,r);
}
```
```help``` 用来找 ```x``` 出现了多少次。

具体思路是找到此数的排名，然后返回比它排名小或大的数。

（话说我刚开始把操作 $6$ 写成[这样](https://www.luogu.com.cn/record/30259012)和[这样](https://www.luogu.com.cn/record/30297820)$AC$了？管理加强一下数据吧……）
## 汇总
```cpp
int k;
for(int i=1; i<=n; ++i)
{
	if(czli[i].opti==1)
		root[i]=opt1_2(root[czli[i].from],czli[i].gonu,a,b,1);
	else if(czli[i].opti==2)
		root[i]=opt1_2(root[czli[i].from],czli[i].gonu,a,b,-1);
	else if(czli[i].opti==3)
		printf("%d\n",opt3(root[i]=root[czli[i].from],czli[i].gonu,a,b));
	else if(czli[i].opti==4)
		printf("%d\n",stef[opt4(root[i]=root[czli[i].from],czli[i].frnu,a,b)]);
	else if(czli[i].opti==5)
		printf("%d\n",(k=opt5(root[i]=root[czli[i].from],czli[i].gonu,a,b))==INT_MIN?INT_MIN:stef[k]);
	else if(czli[i].opti==6)
		printf("%d\n",(k=opt6(root[i]=root[czli[i].from],czli[i].gonu,a,b))==INT_MAX?INT_MAX:stef[k]);
}
```
也不用说了吧。

注意操作 $4$ 的 $x$ 是 ```frnu``` 而不是 ```gonu``` ，我就在这被坑了。（其实操作 $4$ 压根不用离散化，只是我懒不想单独拿出来。）
# 最后
完整代码请自己把上面的合起来，这里不放了。

指针的优点是符合自然语言习惯，使用方便（至少我这么觉得）。

缺点是用 ```new``` 开节点常数大（听说），但过这道板子绰绰有余了。（我管最慢点 $1.67s$ 叫绰绰有余？）

完结撒花\\(^o^)/ 

---

## 作者：xuanfeng101 (赞：2)

## 前言
一篇用数组实现的较为清晰的 FHQ-Treap 题解，~~主要是看不懂指针题解~~。
## 题解
首先，我们需要了解[可持久化平衡树](https://www.luogu.com.cn/problem/P3835)的 FHQ 版本，当然不会也没有关系，接下来是解答。

对于可持久化这一名词，我们知道，就是**继承之前用过的节点**，只需要加入新的节点即可，根据平衡树性质，我们不难知道每次操作时空都是 $O(\log n)$ 的，还是很优雅的，所以可持久化版本多的就是一个复制操作，即

```cpp
int clone(int x)
{
    tr[ ++ idx] = tr[x];
    return idx;
}
```
然后在每次修改时调用这个函数，所有**操作都用复制版本**即可，那么如果你很熟练使用 FHQ-treap 的话本题就解完了，如果不熟悉我还是简单介绍一下具体细节。

首先就是两个底层函数 $\operatorname{split}$ 和 $\operatorname{merge}$，第一个分裂函数代表的是将平衡树以一个值 $v$ 划分为两个子树一个**小于等于** $v$ 一个**大于** $v$，第二个合并函数是按 $key$ 值，也就是按**堆**性质，将两个子树合并，具体实现如下：


```cpp
void split(int u, int v, int& x, int& y)
{
    if (!u)
    {
        x = y = 0;
        return;
    }
    if (tr[u].v <= v)
    {
        x = clone(u);
        split(tr[x].r, v, tr[x].r, y);
        pushup(x);
    }
    else 
    {
        y = clone(u);
        split(tr[y].l, v, x, tr[y].l);
        pushup(y);
    }
}

int merge(int x, int y)
{
    if (!x || !y) return x + y;
    if (tr[x].k <= tr[y].k)
    {
        x = clone(x);
        tr[x].r = merge(tr[x].r, y);
        pushup(x);
        return x;
    }
    else 
    {
        y = clone(y);
        tr[y].l = merge(x, tr[y].l);
        pushup(y);
        return y;
    }
}
```
仅仅只需要调用四次 $clone$ 即可完成可持久化，也就是每次把需要**分裂或在合并**的点拷贝下来，用另一个新点代替即可。

再就是具体的每个操作：

1. 加点。只需要按照 $v$ 分裂子树，然后将新点与左树合并再与右子树合并。

2. 删点。同理先按 $v$ 分裂子树，再按 $v - 1$ 分裂子树，根据我们分裂的原理可知，当前有一个子树的顶点权值为 $v$，那么我们**先合并该点的两个子树**，再与另外两个子树合并就巧妙的删除了。

3. 排名。还是分裂子树，然后查询左子树的 $sz + 1$。

4. 查询数。类似**主席树**方式，每次递归一侧查询。

5. 查询前驱。我们分裂子树，然后调用 4 查询左子树**最后一个点**。

6. 查询后驱。我们同样分裂子树，然后调用 4 查询右儿子的**第一个点**。

## 时间复杂度
$O(n \log n)$
## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 10, INF = (1 << 31) - 1;
mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());
int n, rt[N], idx;
struct Node
{
    int l, r, v, k, sz;
}tr[N];

void pushup(int u)
{
    tr[u].sz = tr[tr[u].l].sz + tr[tr[u].r].sz + 1;
}

int clone(int x)
{
    tr[ ++ idx] = tr[x];
    return idx;
}

void split(int u, int v, int& x, int& y)
{
    if (!u)
    {
        x = y = 0;
        return;
    }
    if (tr[u].v <= v)
    {
        x = clone(u);
        split(tr[x].r, v, tr[x].r, y);
        pushup(x);
    }
    else 
    {
        y = clone(u);
        split(tr[y].l, v, x, tr[y].l);
        pushup(y);
    }
}

int merge(int x, int y)
{
    if (!x || !y) return x + y;
    if (tr[x].k <= tr[y].k)
    {
        x = clone(x);
        tr[x].r = merge(tr[x].r, y);
        pushup(x);
        return x;
    }
    else 
    {
        y = clone(y);
        tr[y].l = merge(x, tr[y].l);
        pushup(y);
        return y;
    }
}

int x, y, z;

int insert(int u, int v)
{
    int p = ++ idx;
    tr[p] = {0, 0, v, (int)rnd(), 1};
    split(u, v, x, y);
    return merge(merge(x, p), y);
}

int del(int u, int v)
{
    split(u, v, x, y);
    split(x, v - 1, x, z);
    if (z) z = merge(tr[z].l, tr[z].r);
    return merge(merge(x, z), y);
}

int get_rank(int u, int v)
{
    split(u, v - 1, x, y);
    int res = tr[x].sz + 1;
    merge(x, y);
    return res;
}

int kth(int u, int k)
{
    if (tr[tr[u].l].sz >= k) return kth(tr[u].l, k);
    else if (tr[tr[u].l].sz + 1 == k) return tr[u].v;
    return kth(tr[u].r, k - tr[tr[u].l].sz - 1);
}

int get_pre(int u, int v)
{
    split(u, v - 1, x, y);
    int res = -INF;
    if (x) res = kth(x, tr[x].sz);
    merge(x, y);
    return res;
}

int get_con(int u, int v)
{
    split(u, v, x, y);
    int res = INF;
    if (y) res = kth(y, 1);
    merge(x, y);
    return res;
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin >> n;
    for (int i = 1; i <= n; i ++ )
    {
        int pre, op, v;
        cin >> pre >> op >> v;
        rt[i] = rt[pre];
        if (op == 1) rt[i] = insert(rt[pre], v);
        else if (op == 2) rt[i] = del(rt[pre], v);
        else if (op == 3) cout << get_rank(rt[pre], v) << endl;
        else if (op == 4) cout << kth(rt[pre], v) << endl;
        else if (op == 5) cout << get_pre(rt[pre], v) << endl;
        else cout << get_con(rt[pre], v) << endl;
    }    
    return 0;
}
```

---

## 作者：lw393 (赞：1)

### 前言
既然权值线段树可以在一定程度上取代普通平衡树，而且权值线段树有着很好的性质：可持久化，所以我们可以选择使用主席树来完成本题。

## 算法介绍

在本题中，可持久化权值线段树的作用在于处理某版本的集合中的数在任意区间 $[l, r]$ 内出现的次数。

由于需要处理不同版本的答案，所以需要对此进行可持久化操作。

我们先复习一下权值线段树如何解决全局第 $k$ 大，与求数 $x$ 在其中的排名。

全局第 $k$ 大我们可以利用线段树上二分解决：

```cpp
// l：当前节点的左端点，r：当前节点的右端点。
// x：要求的当前节点内的第 x 大。
int ls[N], rs[N], sum[N];
int kth(int k, int l, int r, int x){
  if(l == r) return l;
  int mid = l + r >> 1;
  int lsiz = sum[ls[k]];
  if(lsiz >= x) return kth(ls[k], l, mid, x); // x 比左儿子节点拥有的数的个数要小，说明答案在左节点中
  else return kth(rs[k], mid + 1, r, x - lsiz);// 此情况说明答案在右儿子节点中，且为右儿子节点中的第 x - sum[ls[k]] 大。
}
```

数 $x$ 在全局中的排名也可以在树上做二分，比较简单。

```cpp
int rnk(int k, int l, int r, int x){
  if(l == r) return 1;
  int mid = l + r >> 1;
  if(x <= mid) return rnk(ls[k], l, mid, x);
  else return rnk(rs[k], mid + 1, r, x) + sum[ls[k]];
}
```

然后我们再看可持久化操作。

有且仅有往版本 $v$ 中加（或删）数 $x$（详见注释）：

```cpp
// k 表示当前版本在区间 [l, r] 的节点编号
// pre 表示原版本在区间 [l, r] 的节点编号
// x 表示要删或是要添加的数
// v = 1 表示要添加，v = -1 表示要删
// 其实跟主席树板子区别不大
void modify(int &k, int pre, int l, int r, int x, int v){
  k = ++num; ls[k] = ls[pre], rs[k] = rs[pre], sum[k] = sum[pre] + v;
  if(l == r) return;
  int mid = l + r >> 1;
  if(x <= mid) modify(ls[k], ls[pre], l, mid, x, v);
  else modify(rs[k], rs[pre], mid + 1, r, x, v);
}
```

然后就只剩下操作 5 和操作 6 没有处理了。

我们思考一下数 $x$ 的前驱和后继在集合中的排名应该是什么？

我们令 $x$ 的排名为 $p$，则 $x$ 的前驱的排名是 $p - 1$。

我们令 $x + 1$ 的排名为 $p'$，则 $x$ 的后继排名就是 $p'$。想想为什么。

注意判断能不能取到后继，即条件： $p'$ 要小于所求版本中的数的个数，或是 $p$ 要大于 $0$。

这样我们就讲完了所有的操作。

## 正确性证明：

权值线段树的操作是严格 $O(\log A)$ 的，其中 $A$ 表示值域大小，在本题中 $A = 2\times 10^9$，所以我们可以在 $O(n\log A)$ 的时间复杂度下完成所有的操作。

至于空间复杂度，由于使用了动态开点，每次最多开 $\log A$ 个节点，所以空间复杂度是最坏 $O(n\log A)$ 的。

## 代码实现

发现题目中有负数，所以我们在存储数的时候可以都加上 $10^9 + 1$（同时避免 $0$ 的出现），然后涉及到取出树中的数时，只要减去 $10^9 + 1$ 就行了。

参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 5e5 + 5, maxn = 1e9 + 1;

int rt[N];
int ls[N << 6], rs[N << 6], sum[N << 6], num;

//已在前文明确这些函数

void modify(int &k, int pre, int l, int r, int x, int v);

int rnk(int k, int l, int r, int x);

int kth(int k, int l, int r, int x);

int query(int k, int l, int r, int x){ //数 x 出现的次数，用于在删除时判断是否存在这个数
  if(l == r) return sum[k];
  int mid = l + r >> 1;
  if(x <= mid) return query(ls[k], l, mid, x);
  else return query(rs[k], mid + 1, r, x);
}

void solve(){
  int n; cin >> n;
  for(int i = 1; i <= n; i++){
    int id, op, x; cin >> id >> op >> x;
    if(op == 1) {
      modify(rt[i], rt[id], 1, maxn * 2, x + maxn, 1);
    } else if(op == 2) {
      rt[i] = rt[id]; if(query(rt[i], 1, maxn * 2, x + maxn) == 0) continue;
      modify(rt[i], rt[id], 1, maxn * 2, x + maxn, -1);
    } else if(op == 3) {
      rt[i] = rt[id]; cout << rnk(rt[i], 1, maxn * 2, x + maxn) << '\n';
    } else if(op == 4) {
      rt[i] = rt[id]; cout << kth(rt[i], 1, maxn * 2, x) - maxn << '\n';
    } else if(op == 5) {
      rt[i] = rt[id]; int rk = rnk(rt[i], 1, maxn * 2, x + maxn) - 1;
      if(rk == 0) cout << -(1ll << 31) + 1 << '\n';
      else cout << kth(rt[i], 1, maxn * 2, rk) - maxn << '\n';
    } else {
      rt[i] = rt[id]; int rk = rnk(rt[i], 1, maxn * 2, x + maxn + 1) - 1;
      if(rk == sum[rt[i]]) cout << (1ll << 31) - 1 << '\n';
      else cout << kth(rt[i], 1, maxn * 2, rk + 1) - maxn << '\n';
    }
  }
}

signed main(){
  int t = 1;
  //cin >> t;
  while(t--){
    solve();
  }
  return 0;
}
```

---


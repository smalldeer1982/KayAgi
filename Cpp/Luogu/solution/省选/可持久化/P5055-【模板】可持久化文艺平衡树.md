# 【模板】可持久化文艺平衡树

## 题目背景

这是一道模板题。

## 题目描述

您需要写一种数据结构，来维护一个序列，其中需要提供以下操作（**对于各个以往的历史版本**）：

1. 在第 $p$ 个数后插入数 $x$。
2. 删除第 $p$ 个数。
3. 翻转区间 $[l,r]$，例如原序列是 $\{5,4,3,2,1\}$，翻转区间 $[2,4]$ 后，结果是 $\{5,2,3,4,1\}$。
4. 查询区间 $[l,r]$ 中所有数的和。

**和原本平衡树不同的一点是，每一次的任何操作都是基于某一个历史版本，同时生成一个新的版本（操作 $4$ 即保持原版本无变化），新版本即编号为此次操作的序号。**

**本题强制在线。**

## 说明/提示

**强制在线：以下针对 $p_i, x_i, l_i, r_i$ 的限制均是按位异或 $lastans$ 后的限制。**

- 对于 $6$ 个测试点，$n \le 5000$。
- 对于另外 $6$ 个测试点，$v_i = i - 1$。
- 欢迎用户加强数据，可联系管理员或出题人。

对于 $100\%$ 的数据，$1 \le n \le 2 \times {10}^5$，$|x_i| < {10}^6$。

假设基于的历史版本的序列长度为 $len \ge 1$，有：  
若 $\mathrm{opt}_i=1$，则 $0 \le p_i \le len$。  
若 $\mathrm{opt}_i=2$，则 $1 \le p_i \le len$。  
若 $\mathrm{opt}_i=3$，则 $1 \le l_i \le r_i \le len$。  
若 $\mathrm{opt}_i=4$，则 $1 \le l_i \le r_i \le len$。

假设基于的历史版本的序列长度为 $0$，有：  
$\mathrm{opt}_i=1$，$p_i=0$。

## 样例 #1

### 输入

```
10
0 1 0 1
1 1 1 2
2 4 1 2
3 1 2 0
4 4 2 1
5 3 5 7
6 4 5 6
4 1 7 1
8 3 4 6
9 4 4 1```

### 输出

```
3
4
5
10```

# 题解

## 作者：KevinYu (赞：138)

# 题解 Luogu P5055【模板】可持久化文艺平衡树
------------
## <Part0.前言>
------------

对于我们的所求，这一题的题目已经说的很清楚了。        
在题解的正题开始之前，先放几个链接:      
[Luogu P3369 普通平衡树](https://www.luogu.org/problemnew/show/P3369)      
[Luogu P3391 文艺平衡树(Splay)](https://www.luogu.org/problemnew/show/P3391)      
[Luogu P3835 可持久化平衡树](https://www.luogu.org/problemnew/show/P3835)     
建议试着用**FHQ Treap**(非旋转Treap)来实现这几题。      

------------
## </Part 0前言>
------------
## <Part1.FHQ Treap>
------------
```
你看啊，这个数据结构的常数比Splay小，理解起来比Splay容易，长得比Splay好看，能实现的东西并不比Splay少，代码量比Splay小，还能可持久化，为什么不学学呢?
```
会FHQ Treap的可以跳过了。       
所谓的**FHQ Treap**其实是一种加强版的Treap。与一般的Treap树不同，FHQ Treap不依赖旋转操作保持自身结构的平衡，而是依赖**分裂**和**合并**操作维持树的平衡性质。        
我们先来介绍一下关键操作:         
1.创建新的节点(new_node):        
很简单，就是创建一个新的点，没什么好说的。    
返回当前点的下标。       
```cpp
inline int new_node(long long v=0)
{
	static int tot(0);
	tpi.val=v;tp.sum=v;
	tp.rand=rand();tp.size=1;
	return tot;
}
```
2.复制节点(copy_node):      
也没什么好说的，仅仅是为了方便。        
返回复制后的点的下标。       
```cpp
inline int copy_node(int p)
{
	int ret=new_node();
	tree[ret]=tree[p];
	return ret;
}
```
3.更新(push_up):      
push_up(p)代表更新下标为p的节点。         
```cpp
inline void push_up(int p)
{
	tree[p].size=tls(p).size+trs(p).size+1;
	tree[p].sum=tls(p).sum+trs(p).sum+t(p).val;
}
```
4.标记下传(push_down):       
push_down(p)代表将下标为p的点的标记下传。     
什么标记呢?自然是翻转标记。        
注意:传之前的点别扔了，留着可持久化呢。      
```cpp
inline void push_down(int p)
{
	if(!t(p).tag)return;
	if(ls(p))ls(p)=copy_node(ls(p));
	if(rs(p))rs(p)=copy_node(rs(p));
	swap(ls(p),rs(p));
	if(ls(p))tls(p).tag^=1;
	if(rs(p))trs(p).tag^=1;
	tree[p].tag=0;
}
```
5.分裂(Split):      
~~这个词我经常打成Spilt~~。        
所谓的"分裂"，就是将一颗Treap分成两部分。     
你可以理解成，你拿着一个选择性透过膜来"过滤"一颗Treap的过程，最后会将一颗Treap过滤成两个部分。       
我们定义split(p,k,x,y)代表将根为p的子树分为两部分，其中的一部分size为k。     
具体实现起来就是左子树的size还够用的时候，就往左子树递归，不够用的话就往右子树递归。        
**先推标记，再分裂!!!!**         
Split操作完整代码:
```cpp
void split(int p,int k,int &x,int &y)
{
	if(!p){x=y=0;return;}
	push_down(p);
	if(tls(p).size<k){x=copy_node(p);split(rs(x),k-tls(p).size-1,rs(x),y);push_up(x);}
	else{y=copy_node(p);split(ls(y),k,x,ls(y));push_up(y);}
}
```
6.合并(Merge):          
合并就更好理解了，就是把两棵子树树合并到一个根节点上。          
跟一般的平衡树一样，我们需要以它们的键值大小关系决定怎么合并它们。(键值怎么得到?rand()了解一下)        
返回值为他们的根节点。    
**先推标记，再合并!!!!**       
```cpp
int merge(int x,int y)
{
	if(!x||!y)return x|y;
	push_down(x);push_down(y);
	if(t(x).rand<t(y).rand){rs(x)=merge(rs(x),y);push_up(x);return x;}
	else{ls(y)=merge(x,ls(y));push_up(y);return y;}
}
```
以下是实现一颗~~可以拿去持久化的~~FHQ Treap的代码:  
```cpp
const int N(2e5);
int n;ll lastans;
struct node
{
	int rand,size,tag;
	ll val,sum;
	int lson,rson;
}tree[(N<<7)+10];
int rt[N+10];
inline int new_node(long long v=0)
{
	static int tot(0);
	tpi.val=v;tp.sum=v;
	tp.rand=rand();tp.size=1;
	return tot;
}
inline int copy_node(int p)
{
	int ret=new_node();
	tree[ret]=tree[p];
	return ret;
}
inline void push_up(int p)
{
	tree[p].size=tls(p).size+trs(p).size+1;
	tree[p].sum=tls(p).sum+trs(p).sum+t(p).val;
}
inline void push_down(int p)
{
	if(!t(p).tag)return;
	if(ls(p))ls(p)=copy_node(ls(p));
	if(rs(p))rs(p)=copy_node(rs(p));
	swap(ls(p),rs(p));
	if(ls(p))tls(p).tag^=1;
	if(rs(p))trs(p).tag^=1;
	tree[p].tag=0;
}
void split(int p,int k,int &x,int &y)
{
	if(!p){x=y=0;return;}
	push_down(p);
	if(tls(p).size<k){x=copy_node(p);split(rs(x),k-tls(p).size-1,rs(x),y);push_up(x);}
	else{y=copy_node(p);split(ls(y),k,x,ls(y));push_up(y);}
}
int merge(int x,int y)
{
	if(!x||!y)return x|y;
	push_down(x);push_down(y);
	if(t(x).rand<t(y).rand){rs(x)=merge(rs(x),y);push_up(x);return x;}
	else{ls(y)=merge(x,ls(y));push_up(y);return y;}
}
```
------------
## </Part1.FHQ Treap>
------------
## <Part2.操作实现>
------------
本题中，我们一共要实现4个操作(单点插入，单点删除，区间反转，区间求和)。       
暂且抛开可持久化不谈，具体实现起来也不难。      
1.插入:     
在第p个数后插入数x,就是把p拆下来然后再使用两遍merge，将它们粘在一起。       
![](https://i.loli.net/2018/12/26/5c236a6400adb.bmp)      
插入操作代码:
```cpp
		if(op==1)
		{
			scanf("%lld%lld",&a,&b);
			a^=lastans;b^=lastans;
			split(rt[v],a,x,y);
			rt[++cnt]=merge(merge(x,new_node(b)),y);
		}
```
2.删除:        
删掉第p个数，就是将它的两头分别拆下来，再拼接在一起。        
![](https://i.loli.net/2018/12/26/5c23725784b73.bmp)            
删除操作代码:   
```cpp
        if(op==2)
        {
            scanf("%lld",&a);
            a^=lastans;
            split(rt[v],a,x,z);
            split(x,a-1,x,y);
            rt[++cnt]=merge(x,z);
        }
```
3.翻转:       
将区间```[l,r]```翻转，就是将要反转的区间给拆下来，打上标记，再粘回去。       
![](https://i.loli.net/2018/12/26/5c237272b5ca3.bmp)       
```cpp
        if(op==3)
        {
            scanf("%lld%lld",&a,&b);
            a^=lastans;b^=lastans;
            split(rt[v],b,x,z);
            split(x,a-1,x,y);
            t(y).tag^=1;
            rt[++cnt]=merge(merge(x,y),z);
        }
```
4.查询:
查询区间```[l,r]```的最大值，就是将该区间拆下来，输出树根，再粘回去。          
![](https://i.loli.net/2018/12/26/5c2372f5c8fc2.bmp)
查询操作代码:
```cpp
        if(op==4)
        {
            scanf("%lld%lld",&a,&b);
            a^=lastans;b^=lastans;
            split(rt[v],b,x,z);
            split(x,a-1,x,y);
            printf("%lld\n",lastans=t(y).sum);
            rt[++cnt]=merge(merge(x,y),z);
        }
```
代码贴一下:     
```cpp
		scanf("%d%d",&v,&op);
		if(op==1)
		{
			scanf("%lld%lld",&a,&b);
			a^=lastans;b^=lastans;
			split(rt[v],a,x,y);
			rt[++cnt]=merge(merge(x,new_node(b)),y);
		}
		if(op==2)
		{
			scanf("%lld",&a);
			a^=lastans;
			split(rt[v],a,x,z);
			split(x,a-1,x,y);
			rt[++cnt]=merge(x,z);
		}
		if(op==3)
		{
			scanf("%lld%lld",&a,&b);
			a^=lastans;b^=lastans;
			split(rt[v],b,x,z);
			split(x,a-1,x,y);
			t(y).tag^=1;
			rt[++cnt]=merge(merge(x,y),z);
		}
		if(op==4)
		{
			scanf("%lld%lld",&a,&b);
			a^=lastans;b^=lastans;
			split(rt[v],b,x,z);
			split(x,a-1,x,y);
			printf("%lld\n",lastans=t(y).sum);
			rt[++cnt]=merge(merge(x,y),z);
		}
```
------------
## </Part2.操作实现>
------------
## <Part3.可持久化证明>
------------
为什么FHQ Treap可以依靠可持久化来优化空间复杂度呢?        
其实很简单，就是因为Split过程中可以对点进行复制，并且每次修改的必然只有一个子树上的点。       
而且Split和Merge总是成对出现，我们就只用复制一次。    
![](https://i.loli.net/2018/12/26/5c2377c0691f5.bmp)      

------------
## </Part3.可持久化证明>
------------
完整代码:
```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<climits>
#include<cstdlib>
#include<ctime>
#include<algorithm>
#include<complex>
#include<iostream>
#include<map>
#include<queue>
#include<vector>
#define ll long long
#define INF 0x3f3f3f3f
#define ls(p) tree[p].lson
#define rs(p) tree[p].rson
#define tls(p) tree[ls(p)]
#define trs(p) tree[rs(p)]
#define t(p) tree[p]
#define tpi t(++tot)
#define tp t(tot)
using namespace std;
const int N(2e5);
int n;ll lastans;
struct node
{
	int rand,size,tag;
	ll val,sum;
	int lson,rson;
}tree[(N<<7)+10];
int rt[N+10];
inline int new_node(long long v=0)
{
	static int tot(0);
	tpi.val=v;tp.sum=v;
	tp.rand=rand();tp.size=1;
	return tot;
}
inline int copy_node(int p)
{
	int ret=new_node();
	tree[ret]=tree[p];
	return ret;
}
inline void push_up(int p)
{
	tree[p].size=tls(p).size+trs(p).size+1;
	tree[p].sum=tls(p).sum+trs(p).sum+t(p).val;
}
inline void push_down(int p)
{
	if(!t(p).tag)return;
	if(ls(p))ls(p)=copy_node(ls(p));
	if(rs(p))rs(p)=copy_node(rs(p));
	swap(ls(p),rs(p));
	if(ls(p))tls(p).tag^=1;
	if(rs(p))trs(p).tag^=1;
	tree[p].tag=0;
}
void split(int p,int k,int &x,int &y)
{
	if(!p){x=y=0;return;}
	push_down(p);
	if(tls(p).size<k){x=copy_node(p);split(rs(x),k-tls(p).size-1,rs(x),y);push_up(x);}
	else{y=copy_node(p);split(ls(y),k,x,ls(y));push_up(y);}
}
int merge(int x,int y)
{
	if(!x||!y)return x|y;
	push_down(x);push_down(y);
	if(t(x).rand<t(y).rand){rs(x)=merge(rs(x),y);push_up(x);return x;}
	else{ls(y)=merge(x,ls(y));push_up(y);return y;}
}
int main()
{
	srand(224144);scanf("%d",&n);
	int cnt(0);int v,op;ll a,b;int x,y,z;
	while(n--)
	{
		scanf("%d%d",&v,&op);
		if(op==1)
		{
			scanf("%lld%lld",&a,&b);
			a^=lastans;b^=lastans;
			split(rt[v],a,x,y);
			rt[++cnt]=merge(merge(x,new_node(b)),y);
		}
		if(op==2)
		{
			scanf("%lld",&a);
			a^=lastans;
			split(rt[v],a,x,z);
			split(x,a-1,x,y);
			rt[++cnt]=merge(x,z);
		}
		if(op==3)
		{
			scanf("%lld%lld",&a,&b);
			a^=lastans;b^=lastans;
			split(rt[v],b,x,z);
			split(x,a-1,x,y);
			t(y).tag^=1;
			rt[++cnt]=merge(merge(x,y),z);
		}
		if(op==4)
		{
			scanf("%lld%lld",&a,&b);
			a^=lastans;b^=lastans;
			split(rt[v],b,x,z);
			split(x,a-1,x,y);
			printf("%lld\n",lastans=t(y).sum);
			rt[++cnt]=merge(merge(x,y),z);
		}
	}
	return 0;
}
```
------------
# 题解结束
------------

---

## 作者：mrsrz (赞：27)

~~skip2004秒出的一种不用下放标记的写法~~

可持久化区间翻转，考虑可持久化Treap实现。

1,2,4操作都好实现，4操作维护一下子树和即可。

关键就在那个区间翻转操作上。

传统的区间翻转，都是要打一个翻转标记，然后下放。但如果可持久化的话，就有点难处理。

如果我们能事先知道翻转后的区间，那就方便很多了。

维护一个反序列的Treap，则要翻转的区间在反Treap中的对应区间，就是翻转后的序列。

然后，翻转一段区间，就直接在正、反两个Treap中，把对应区间split出来，然后互换即可。

时间复杂度是$O(n\log n)$的。常数会比较大（维护两个Treap，至少2倍）。

空间会用得比较多。把rand数组用unsigned short压一压会比较好。

## Code：
```cpp
#include<cstdio>
#include<cctype>
#define N 200005
#define P 100
#define LL long long
#define next_int(x)(x^=x<<13,x^=x>>17,x^=x<<5)
int seed=19260817;
inline LL readint(){
    int c=getchar(),b=0;
	LL d=0;
    for(;!isdigit(c);c=getchar())b=c=='-';
    for(;isdigit(c);c=getchar())d=(d<<3)+(d<<1)+(c^'0');
    return b?-d:d;
}
int L[N*P],R[N*P],sz[N*P],s[N*P];
LL sm[N*P];
unsigned short rnd[N*P];
int cnt=0,rt[N],irt[N];
LL ans=0;
#define update(x)(sm[x]=sm[L[x]]+sm[R[x]]+s[x],sz[x]=sz[L[x]]+sz[R[x]]+1)
int merge(int x,int y){
	if(!x||!y)return x|y;
	int u=++cnt;
	if(rnd[x]<rnd[y]){
		rnd[u]=rnd[x];
		L[u]=L[x];
		s[u]=s[x];
		sm[u]=sm[x];
		sz[u]=sz[x];
		R[u]=merge(R[x],y);
	}else{
		rnd[u]=rnd[y];
		s[u]=s[y];
		R[u]=R[y];
		sm[u]=sm[y];
		sz[u]=sz[y];
		L[u]=merge(x,L[y]);
	}
	update(u);
	return u;
}
void split(int u,int k,int&x,int&y){
	if(!u)x=y=0;else
	if(k==0)x=0,y=u;else
	if(k==sz[u])x=u,y=0;else
	if(sz[L[u]]>=k){
		y=++cnt;
		rnd[y]=rnd[u];
		R[y]=R[u];
		s[y]=s[u];
		sm[y]=sm[u];
		sz[y]=sz[u];
		split(L[u],k,x,L[y]);
		update(y);
	}else{
		x=++cnt;
		rnd[x]=rnd[u];
		L[x]=L[u];
		s[x]=s[u];
		sm[x]=sm[u];
		sz[x]=sz[u];
		split(R[u],k-sz[L[u]]-1,R[x],y);
		update(x);
	}
}
void insert(int p,int f,int ver,int t){
	int len=sz[rt[ver]],x,y;
	split(rt[ver],p,x,y);
	int nw=++cnt;
	s[nw]=f,rnd[nw]=next_int(seed)&65535;sm[nw]=f;sz[nw]=1;
	rt[t]=merge(merge(x,cnt),y);
	split(irt[ver],len-p,x,y);
	s[++cnt]=f,rnd[cnt]=rnd[nw];sm[cnt]=f;sz[cnt]=1;
	irt[t]=merge(merge(x,cnt),y);
}
void erase(int p,int ver,int t){
	int len=sz[rt[ver]],a,b,c,d;
	split(rt[ver],p,a,b);
	split(a,p-1,c,d);
	rt[t]=merge(c,b);
	split(irt[ver],len-p+1,a,b);
	split(a,len-p,c,d);
	irt[t]=merge(c,b);
}
void reverse(int ver,int l,int r,int t){
	int len=sz[rt[ver]];
	int r1,r2,r3,r0,i1,i2,i3,i0;
	split(rt[ver],r,r0,r3);
	split(r0,l-1,r1,r2);
	split(irt[ver],len-l+1,i0,i3);
	split(i0,len-r,i1,i2);
	rt[t]=merge(merge(r1,i2),r3);
	irt[t]=merge(merge(i1,r2),i3);
}
LL query(int ver,int l,int r,int t){
	rt[t]=rt[ver],irt[t]=irt[ver];
	int _0,_1,_2,_3;
	split(rt[ver],r,_0,_3);
	split(_0,l-1,_1,_2);
	return sm[_2];
}
int main(){
	for(int T=readint(),t=1;t<=T;++t){
		int v=readint(),opt=readint();
		switch(opt){
			case 1:{
				int p=readint()^ans,x=readint()^ans;
				insert(p,x,v,t);
				break;
			}
			case 2:{
				int p=readint()^ans;
				erase(p,v,t);
				break;
			}
			case 3:{
				int l=readint()^ans,r=readint()^ans;
				reverse(v,l,r,t);
				break;
			}
			case 4:{
				int l=readint()^ans,r=readint()^ans;
				printf("%lld\n",ans=query(v,l,r,t));
				break;
			}
		}
	}
	return 0;
}
```

---

## 作者：Ireliaღ (赞：22)

**提供指针版`FHQ Treap`题解**

### 前置知识

- 会用`FHQ Treap`通过文艺平衡树， 熟悉区间反转的标记下传。以上在文艺平衡树题解里都有。

- 写过可持久化数据结构，比如可持久化数组，明白可持久化原理。

### 本题解法

大体思路都一样。为了保证每次操作对历史版本不产生影响，在`PushDown()`和`Split()`的操作时复制节点。因为每次`Merge()`前都会`Split()`，所以`Merge()`时就不需要复制节点了。

具体代码如下

```cpp
#include <iostream>

using namespace std;
typedef long long LL;

const int MAXN = 2e5 + 5;
const int INF = 1e9 + 7;

int Rand() {
    static LL seed = 0x131309d;
    return seed = ((seed * 233333LL) ^ 12345678LL) % INF;
}

struct Node{
    int val, pri, siz;
    bool tag;
    LL sum;
    Node *ch[2];

    Node(int val = 0) : val(val) {
        pri = Rand();
        siz = 1;
        sum = val;
        ch[0] = ch[1] = NULL;
        tag = false;
    }
};

Node *rt[MAXN];
int n, m;
LL cur;

Node *Copy(Node *now) {
    Node *ret = new Node;
    if (now) *ret = *now;
    return ret;
}

void Update(Node *now) {
    now->siz = (LL)(now->ch[0] ? now->ch[0]->siz : 0) + (LL)(now->ch[1] ? now->ch[1]->siz : 0) + 1;
    now->sum = (LL)(now->ch[0] ? now->ch[0]->sum : 0) + (LL)(now->ch[1] ? now->ch[1]->sum : 0) + (LL)now->val;
}

void PushDown(Node *now) {
    if (!now->tag) return;
    swap(now->ch[0], now->ch[1]);
    if (now->ch[0]) {
        now->ch[0] = Copy(now->ch[0]);
        now->ch[0]->tag ^= 1;
    }
    if (now->ch[1]) {
        now->ch[1] = Copy(now->ch[1]);
        now->ch[1]->tag ^= 1;
    }
    now->tag = false;
}

void Split(Node *now, int k, Node *&l, Node *&r) {
    if (!now) {
        l = r = NULL;
        return;
    }
    PushDown(now);
    int ls = now->ch[0] ? now->ch[0]->siz : 0;
    if (k <= ls) {
        r = Copy(now);
        Split(r->ch[0], k, l, r->ch[0]);
        Update(r);
    } else {
        l = Copy(now);
        Split(l->ch[1], k - ls - 1, l->ch[1], r);
        Update(l);
    }
}

Node *Merge(Node *a, Node *b) {
    if (!a || !b) return a ? a : b;
    if (a->pri <= b->pri) {
        PushDown(b);
        b->ch[0] = Merge(a, b->ch[0]);
        Update(b);
        return b;
    } else {
        PushDown(a);
        a->ch[1] = Merge(a->ch[1], b);
        Update(a);
        return a;
    }
}

void Insert(Node *&root, int k, int val) {
    Node *a, *b;
    Split(root, k, a, b);
    root = Merge(a, Merge(new Node(val), b));
}

void Remove(Node *&root, int pos) {
    Node *a, *b, *c, *d;
    Split(root, pos, d, c);
    Split(d, pos - 1, a, b);
    if (b) delete b;
    root = Merge(a, c);
}

void Reverse(Node *&root, int l, int r) {
    Node *a, *b, *c, *d;
    Split(root, r, d, c);
    Split(d, l - 1, a, b);
    if (b) b->tag ^= 1;
    root = Merge(a, Merge(b, c));
}

LL Query(Node* &root, int l, int r) {
    Node *a, *b, *c, *d;
    Split(root, r, d, c);
    Split(d, l - 1, a, b);
    LL ans = b ? b->sum : 0LL;
    root = Merge(a, Merge(b, c));
    return ans;
}

void Init() {
    ios :: sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    cin >> n;
    cur = 0LL;
}

void Work() {
    int op, ver;
    LL p, x, l, r;
    for (int i = 1; i <= n; i++) {
        cin >> ver >> op;
        rt[i] = rt[ver];
        if (op == 1) {
            cin >> p >> x;
            p ^= cur; x ^= cur;
            Insert(rt[i], p, x);
        } else if (op == 2) {
            cin >> p;
            p ^= cur;
            Remove(rt[i], p);
        } else if (op == 3) {
            cin >> l >> r;
            l ^= cur; r ^= cur;
            Reverse(rt[i], l, r);
        } else {
            cin >> l >> r;
            l ^= cur; r ^= cur;
            cur = Query(rt[i], l, r);
            cout << cur << endl;
        }
    }
}

int main() {
    Init();
    Work();
    return 0;
}
```

---

## 作者：GKxx (赞：18)

听说这题是用我的程序当std对拍的，然而我昨天晚上写着急了，删除操作写错了，在此对于给出题人带来的不便表示歉意2333...

首先你要会用非旋treap做[文艺平衡树](https://www.luogu.org/problemnew/show/P3391)这题。做法就是，如果要翻转一个区间$[l, r]$，我们就把树split成三棵，分别存储$[1,l-1],[l,r],[r+1,n]$，然后在中间那棵树上打标记，再把三棵树合并即可。

那么对于这题而言，就是把这个非旋treap可持久化下来即可。可持久化的方法就是对于要修改的结点，我们新建一个它的拷贝，在新节点上修改。其实跟线段树的可持久化是差不多的。

```cpp
// can是垃圾桶，我们要节约能源保护环境
// clone函数用来克隆一个结点
inline int clone(int y) {
    int x = cantop ? can[cantop--] : ++tot;
    val[x] = val[y]; pri[x] = pri[y]; sum[x] = sum[y]; size[x] = size[y];
    ch[x][0] = ch[y][0]; ch[x][1] = ch[y][1]; rev[x] = rev[y];
    return x;
}
```

修改操作包括split，merge，pushdown，这里以split为例：

普通非旋treap的split：

```cpp
void split(int x, int k, int &l, int &r) {
    if (!x) l = r = 0;
    else {
        pushdown(x);
        if (k <= size[ch[x][0]]) {
            r = x;
            split(ch[x][0], k, l, ch[x][0]);
        } else {
            l = x;
            split(ch[x][1], k - size[ch[x][0]] - 1, ch[x][1], r);
        }
        update(x);
    }
}
```

可持久化版本：

```cpp
void split(int x, int k, int &l, int &r) {
    if (!x) l = r = 0;
    else {
        pushdown(x);
        if (k <= size[ch[x][0]]) {
            r = clone(x);
            split(ch[r][0], k, l, ch[r][0]);
            update(r);
        } else {
            l = clone(x);
            split(ch[l][1], k - size[ch[x][0]] - 1, ch[l][1], r);
            update(l);
        }
    }
}
```

注意其中一些细微的差异，比如普通版本的split只要update(x)即可，而可持久化版本的要对r或l而非x调用update，因为x的孩子并没有被修改

另外，关于merge，理论上来讲merge里也应该克隆结点，但是本题并不需要，因为我们在调用merge之前总是会调用split，就已经把该克隆的结点克隆完了。

其它的区间和信息就正常维护就好。

完整代码：（人傻自带大常数）

```cpp
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>

#define rep(I, A, B) for (int I = (A); I <= (B); ++I)
#define dwn(I, A, B) for (int I = (A); I >= (B); --I)
#define erp(I, X) for (int I = head[X]; I; I = next[I])

template <typename T> inline void read(T& t) {
    int f = 0, c = getchar(); t = 0;
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) t = t * 10 + c - 48, c = getchar();
    if (f) t = -t;
}
template <typename T, typename... Args>
inline void read(T& t, Args&... args) {
    read(t); read(args...); 
}
template <typename T> void write(T x) {
    if (x < 0) x = -x, putchar('-');
    if (x > 9) write(x / 10);
    putchar(x % 10 + 48);
}
template <typename T> void writeln(T x) {
    write(x);
    puts("");
}
template <typename T> inline bool chkMin(T& x, const T& y) { return y < x ? (x = y, true) : false; }
template <typename T> inline bool chkMax(T& x, const T& y) { return x < y ? (x = y, true) : false; }

typedef long long LL;
const int maxn = 2e5 + 207;
int ch[maxn << 6][2], pri[maxn << 6], val[maxn << 6], size[maxn << 6];
LL sum[maxn << 6];
bool rev[maxn << 6];
int root[maxn];
int can[maxn], cantop;
int n, m, tot;

inline int newNode(int v = 0) {
    int x = cantop ? can[cantop--] : ++tot;
    val[x] = sum[x] = v; pri[x] = rand(); size[x] = 1;
    ch[x][0] = ch[x][1] = rev[x] = 0;
    return x;
}
inline int clone(int y) {
    int x = cantop ? can[cantop--] : ++tot;
    val[x] = val[y]; pri[x] = pri[y]; sum[x] = sum[y]; size[x] = size[y];
    ch[x][0] = ch[y][0]; ch[x][1] = ch[y][1]; rev[x] = rev[y];
    return x;
}
inline void update(int x) {
    size[x] = size[ch[x][0]] + size[ch[x][1]] + 1;
    sum[x] = sum[ch[x][0]] + sum[ch[x][1]] + val[x];
}
inline void pushdown(int x) {
    if (rev[x]) {
        std::swap(ch[x][0], ch[x][1]);
        if (ch[x][0]) {
            ch[x][0] = clone(ch[x][0]);
            rev[ch[x][0]] ^= 1;
        }
        if (ch[x][1]) {
            ch[x][1] = clone(ch[x][1]);
            rev[ch[x][1]] ^= 1;
        }
        rev[x] = 0;
    }
}
void split(int x, int k, int &l, int &r) {
    if (!x) l = r = 0;
    else {
        pushdown(x);
        if (k <= size[ch[x][0]]) {
            r = clone(x);
            split(ch[r][0], k, l, ch[r][0]);
            update(r);
        } else {
            l = clone(x);
            split(ch[l][1], k - size[ch[x][0]] - 1, ch[l][1], r);
            update(l);
        }
    }
}
int merge(int x, int y) {
    if (!(x && y)) return x ^ y;
    if (pri[x] < pri[y]) {
        pushdown(y);
        ch[y][0] = merge(x, ch[y][0]);
        update(y);
        return y;
    } else {
        pushdown(x);
        ch[x][1] = merge(ch[x][1], y);
        update(x);
        return x;
    }
}
inline void insert(int &rt, int k, int val) {
    int x, y;
    split(rt, k, x, y);
    rt = merge(merge(x, newNode(val)), y);
}
inline void erase(int &rt, int pos) {
    int x, y, z;
    split(rt, pos, x, z);
    split(x, pos - 1, x, y);
    can[++cantop] = y;
    rt = merge(x, z);
}
inline void reverse(int &rt, int l, int r) {
    int x, y, z;
    split(rt, r, x, z);
    split(x, l - 1, x, y);
    rev[y] ^= 1;
    rt = merge(merge(x, y), z);
}
inline LL query(int &rt, int l, int r) {
    int x, y, z;
    split(rt, r, x, z);
    split(x, l - 1, x, y);
    LL ans = sum[y];
    rt = merge(merge(x, y), z);
    return ans;
}

int main() {
    read(n);
    LL lastans = 0;
    rep(i, 1, n) {
        int v, q; read(v, q);
        root[i] = root[v];
        if (q == 1) {
            int p, x; read(p, x);
            p ^= lastans; x ^= lastans;
            insert(root[i], p, x);
        } else if (q == 2) {
            int p; read(p); p ^= lastans;
            erase(root[i], p);
        } else if (q == 3) {
            int l, r; read(l, r);
            l ^= lastans; r ^= lastans;
            reverse(root[i], l, r);
        } else {
            int l, r; read(l, r);
            l ^= lastans; r ^= lastans;
            writeln(lastans = query(root[i], l, r));
        }
    }
    return 0;
}
```

---

## 作者：Great_Influence (赞：14)

$leafytree$ 的可持久化。

咕了很久，没事干就写了。

其实和普通 $FHQ$ 的可持久化没有什么区别，在 $pushdown$ 下传标记的时候将节点可持久化就可以了。

复杂度是 $O(n\log n)$ 的。不过因为 $leafytree$ 的 $merge$ 是 $O(\log \frac{mxsz}{mnsz})$ 的，因此在玄学意义上也许会快些(~~假的，分裂复杂度为 $O(\log sz)$~~)。

线段树的形态使这棵树可以像线段树一样进行操作。

代码:
```cpp
#include<cctype>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<iostream>
#include<map>
#include<vector>
#include<cmath>
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
#define rep(i,a,b) for(register int i=(a);i<(b);++i)
#define pb push_back
#define mp make_pair
typedef unsigned long long uint64;
typedef unsigned int uint32;
typedef long long ll;
using namespace std;

namespace IO
{
    const uint32 Buffsize=1<<15,Output=1<<23;
    static char Ch[Buffsize],*S=Ch,*T=Ch;
    inline char getc()
	{
		return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);
	}
    static char Out[Output],*nowps=Out;
    
    inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}

    template<typename T>inline void read(T&x)
	{
		x=0;static char ch;T f=1;
		for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;
		for(;isdigit(ch);ch=getc())x=x*10+(ch^48);
		x*=f;
	}

	template<typename T>inline void write(T x,char ch='\n')
	{
		if(!x)*nowps++='0';
		if(x<0)*nowps++='-',x=-x;
		static uint32 sta[111],tp;
		for(tp=0;x;x/=10)sta[++tp]=x%10;
		for(;tp;*nowps++=sta[tp--]^48);
		*nowps++=ch;
	}
}
using IO::read;
using IO::write;
using IO::getc;
using IO::flush;

inline void Chkmin(int&u,int v){u>v?u=v:0;}

inline void Chkmax(int&u,int v){u<v?u=v:0;}

inline void file()
{
#ifndef ONLINE_JUDGE
	freopen("water.in","r",stdin);
	freopen("water.out","w",stdout);
#endif
}

const int MAXN=2e5+7;

static int N,rt[MAXN];

namespace BST
{
	const int NODE=MAXN*70;

	const double alp=1-sqrt(2)/2,delp=alp/(1-alp);

	static struct node
	{
		ll sm;
		int sz,rev,son[2];
		node(){}

		node(ll _s,int _sz,int _re,int _ls,int _rs)
		{sm=_s,sz=_sz,rev=_re,son[0]=_ls,son[1]=_rs;}
	}p[NODE];

	static int e;

	inline void reflush(int u)
	{
		p[u].sz=p[p[u].son[0]].sz+p[p[u].son[1]].sz;
		p[u].sm=p[p[u].son[0]].sm+p[p[u].son[1]].sm;
	}

	inline void pushdown(int u)
	{
		if(p[u].son[0]&&p[u].rev)
		{
			int ls=++e,rs=++e;
			p[ls]=p[p[u].son[1]],p[rs]=p[p[u].son[0]];
			p[u].son[0]=ls,p[u].son[1]=rs;
			p[ls].rev^=1,p[rs].rev^=1;
			p[u].rev=0;
		}
	}

	int merge(int u,int v)
	{
		if(!u||!v)return u|v;
		if(p[u].sz>=delp*p[v].sz&&p[v].sz>=delp*p[u].sz)
		{
			register int cr=++e;
			p[cr].son[0]=u,p[cr].son[1]=v;
			reflush(cr);
			return cr;
		}
		if(p[u].sz<=p[v].sz)
		{
			pushdown(v);
			register int ls=p[v].son[0],rs=p[v].son[1];
			if(p[rs].sz>=alp*(p[u].sz+p[v].sz))return merge(merge(u,ls),rs);
			else
			{
				pushdown(ls);
				register int ll=p[ls].son[0],rr=p[ls].son[1];
				return merge(merge(u,ll),merge(rr,rs));
			}
		}
		else
		{
			pushdown(u);
			register int ls=p[u].son[0],rs=p[u].son[1];
			if(p[ls].sz>=alp*(p[u].sz+p[v].sz))return merge(ls,merge(rs,v));
			else
			{
				pushdown(rs);
				register int ll=p[rs].son[0],rr=p[rs].son[1];
				return merge(merge(ls,ll),merge(rr,v));
			}
		}
	}

	typedef pair<int,int>Pr;

	Pr split(int u,int k)
	{
		if(!u||!k)return mp(0,u);
		if(k==p[u].sz)return mp(u,0);
		pushdown(u);
		if(k<=p[p[u].son[0]].sz)
		{
			Pr y=split(p[u].son[0],k);
			return mp(y.first,merge(y.second,p[u].son[1]));
		}
		else
		{
			Pr y=split(p[u].son[1],k-p[p[u].son[0]].sz);
			return mp(merge(p[u].son[0],y.first),y.second);
		}
	}

	inline int insert(int ver,int ps,int x)
	{
		Pr z=split(rt[ver],ps);
		p[++e]=node(x,1,0,0,0);
		return merge(merge(z.first,e),z.second);
	}

	inline int del(int ver,int x)
	{
		Pr z=split(rt[ver],x-1),y=split(z.second,1);
		return merge(z.first,y.second);
	}

	inline int rever(int ver,int l,int r)
	{
		Pr z=split(rt[ver],l-1),y=split(z.second,r-l+1);
		p[++e]=p[y.first],p[e].rev^=1;
		return merge(z.first,merge(e,y.second));
	}

	inline ll query(int ver,int l,int r)
	{
		Pr z=split(rt[ver],l-1),y=split(z.second,r-l+1);
		return p[y.first].sm;
	}
}
using BST::insert;
using BST::del;
using BST::rever;
using BST::query;

static ll lasans;

inline void work()
{
	read(N);
	static int las,op;
	static ll l,r;
	for(int i=1;i<=N;++i)
	{
		read(las),read(op),read(l),l^=lasans;
		if(op==2)rt[i]=del(las,l);
		else
		{
			read(r),r^=lasans;
			if(op==1)rt[i]=insert(las,l,r);
			else if(op==3)rt[i]=rever(las,l,r);
			else
			{
				write(lasans=query(las,l,r)),
				rt[i]=rt[las];
			}
		}
	}
	flush();
}

int main()
{
    file();
	work();
	return 0;
}
```

---

## 作者：Thomasguo666 (赞：14)

# fhq Treap

我们发现，常用来实现文艺平衡树的Splay由于在splay的过程中形态发生了变化，故不适用于可持久化。于是我们需要一种非旋平衡树来做本题。比如说fhq Treap。

前置技能：普通平衡树

约定：

ch\[x][0/1]表示x的左/右孩子

val[x]表示x的权值，dat\[x]表示x的关键码（既然是Treap，就要有关键码。）

sz[x]表示x的子树大小（包括x）

tag[x]表示x的标记（含义待会再讲）



## 原理

fhq Treap的原理十分简单粗暴，就是把要操作的区间扯下来，打个标记再拼回去。

## 基本操作

### #1：split

格式：split(now,k,&x,&y);

split操作分两种，第一种是权值分裂，第二种是排名分裂。

权值分裂就是把now的子树中权值小于等于k的节点放在x上，其余的节点放在y上

举个西瓜：

![](https://cdn.luogu.com.cn/upload/pic/49411.png)



如果我们进行split(3,1,x,y)，那么得到的结果就是

x=1,y=3

![](https://cdn.luogu.com.cn/upload/pic/49419.png)（对不起，split操作并不能帮你把节点的边框加粗）

这怎么实现呢

```c++
void split(int now,int k,int &x,int &y)
{
	if (!now) 
    {
        x=y=0; //如果now不存在，那么分裂成的两棵子树也不存在
        return ;
    }
    if (tag[now]) down(now); //先不管他
    if (val[now]<=k) //如果now的权值比k小，那么权值比k大的节点一定只在now的右子树（bst性质），所以分裂的地方在now的右子树
	{
		x=now;//x的根节点就是now。
		split(ch[now][1],k,ch[now][1],y);//把now的右子树中权值比k小的部分当作now的右子树，其余的部分放在y。
		update(now); //辅助操作，即更新now的信息
	}
	else //否则分裂的地方在now的左子树
	{
		y=now;//y的根节点就是now
		split(ch[now][0],k,x,ch[now][0]);//同上
		update(now);
	}
    //为什么不把两个update(now)一起写在这里呢？是为了方便可持久化。
}
```

这样下来，now的子树就被分成了x，y两部分。

排名分裂就是把now的子树（包括now）的中序遍历中前k个节点放在x，其余的节点放在y

实现跟权值分裂差不多。代码：

```c++
void split(int now,int k,int &x,int &y)
{
	if (!now) {x=y=0;return;}
	if (tag[now]) down(now);
	if (sz[ch[now][0]]<k)
	{
		x=now;
		split(ch[now][1],k-sz[ch[now][0]]-1,ch[now][1],y);
		update(now);
	}
	else 
	{
		y=now;
		split(ch[now][0],k,x,ch[now][0]);
		update(now);
	}
}
```

### #2 merge

格式：merge(x,y)

就是把x，y两个树合并在一起。

详情看代码：

```cpp
int merge(int x,int y)
{ 
	if (!x||!y) return x+y; //如果两个子树有一个为空，那么就返回非空的那一个。
	if (dat[x]<dat[y]) 
	{
		if (tag[x]) down(x);//别管他
		ch[x][1]=merge(ch[x][1],y); //为了满足堆性质，使树的高度尽量小
		update(x);
		return x;
	}
	else
	{
		if (tag[y]) down(y);
		ch[y][0]=merge(x,ch[y][0]);
		update(y);
		return y;
	}
}
```



### #3 del

格式：del(a)

就是把权值为a的节点删除一个

怎么删呢？

把这个节点切掉，再把断开的两部分粘起来

代码

```c++
void del(int a)
{
	split(root,a,x,z);//这里的split应该是权值分裂（显然）
	split(x,a-1,x,y);
	y=merge(ch[y][0],ch[y][1]);//如果有重复节点
	root=merge(merge(x,y),z);
}
```

如果没有重复节点，就这样写

```c++
void del(int a)
{
	split(root,a,x,z);//这里的split应该是权值分裂（显然）
	split(x,a-1,x,y);
	root=merge(x,z);
}
```



### #4 insert

格式：insert(a）

如图：

![](https://cdn.luogu.com.cn/upload/pic/49442.png)(如果有重复权值的话，<a应该为$\leq$a)

代码

```c++
int new_node(int a)//新建节点
{
	sz[++tot]=1,val[tot]=a,dat[tot]=rand();
	return tot;
}
void insert(int a)
{
	split(root,a,x,y);//把小于等于a的节点放在x，大于a的节点放在y，用权值分裂
	root=merge(merge(x,new_node(a)),y);把x，a，和y拼起来
}
```

### #5 rank

格式：rank(a)

查询a的排名。

把小于a的节点数量加1就是a的排名了

代码

```c++
int rank(int a)
{
	split(root,a-1,x,y);
	int ans=sz[x]+1;
	merge(x,y);
	return ans;
}
```

### #6 kth

格式：kth(now,k)

查询now的子树中第k小值所在的节点。

同普通平衡树，需要递归实现

```cpp
int kth(int now,int k)
{
	if (k==sz[ch[now][0]]+1) return now;
	if (k<=sz[ch[now][0]]) return kth(ch[now][0],k);
	else return kth(ch[now][1],k-sz[ch[now][0]]-1);
}
```

### #7  pre/pst

格式：pre(a)/pst(a)

查询a的前驱后继

实现很简单，看代码应该能懂。

```c++
int pre(int a)
{
	split(root,a-1,x,y);
	int ans=val[kth(x,sz[x])];
	root=merge(x,y);
	return ans;
}
int pst(int a)
{
	split(root,a,x,y);
	int ans=val[kth(y,1)];
	root=merge(x,y);
	return ans;
}
```



### #8 各种区间操作

#### 注意：如果有区间操作，必须用排名分裂！

为什么呢？因为一段区间里的数，权值不一定是连续的。

而fhq Treap一个很好的性质，就是中序遍历以后就是原序列。

区间操作怎么实现呢？先看代码：

```c++
void rev(int l,int r)//以区间反转为例
{
	split(root,l-1,x,y);//排名分裂
	split(y,r-l+1,y,z);
    //也可以改成split(root,r,x,z),split(x,l-1,x,y),作用是把区间分成[1,l-1],[l,r],[r+1,n]三段
	tag[y]^=1;//在中间一段打标记
	root=merge(x,merge(y,z));//拼回去
}
```

接下来揭晓down函数的作用：

如果你要反转区间[1,2,3,4]，假设这个区间被保存在y节点上

那么你先在y上打标记。

如果你不需要对y进行split或merge操作，那么无论它有没有被反转你甭管

但是如果你要对它split或merge的话，你就应该先交换它的两个子树，比如说变为[3,4,1,2]。

然后再在[3,4]和[1,2]上打标记（如果已经有标记了，那么取消）。

```c++
 void down(int x)
{
	swap(ch[x][0],ch[x][1]);
	if (ch[x][0]) tag[ch[x][0]]^=1;
	if (ch[x][1]) tag[ch[x][1]]^=1;
	tag[x]=0;
}
```

区间求和:

```c++
ll query(int l,int r)
{
	split(root,l-1,x,y);
	split(y,r-l+1,y,z);
	ll ans=sum[y];
	root=merge(x,merge(y,z));
	return ans;
}
```



## 可持久化

fhq Treap如何可持久化呢？就是在split和merge操作里克隆要操作的节点，然后在克隆的节点（而非原节点）进行操作。

而在本题中，由于每个merge操作之前都会split一遍，所以merge操作里就不用克隆了。

```c++
int clone(int y)
{
    int x=++tot;
	ch[x][0]=ch[y][0],ch[x][1]=ch[y][1],val[x]=val[y],dat[x]=dat[y],sz[x]=sz[y];
    return x;
}
void split(int now,int k,int &x,int &y)
{
	if (!now) {x=y=0;return;}
	if (tag[now]) down(now);
	if (sz[ch[now][0]]<k)
	{
		x=clone(now);
		split(ch[x][1],k-sz[ch[x][0]]-1,ch[x][1],y);
		update(x);
	}
	else 
	{
		y=clone(now);
		split(ch[y][0],k,x,ch[y][0]);
		update(y);
	}
}
```



## 垃圾回收

（不是回收我）

为了~~环保~~节省空间，所以del、clone和new_node操作得改一改

```c++
 int new_node(int x)
{
	int a=cantop?can[cantop--]:++tot;
	sz[a]=1,sum[a]=val[a]=x,dat[a]=rand();
	return a;
}
int clone(int x)
{
	int a=cantop?can[cantop--]:++tot;
	sz[a]=sz[x],sum[a]=sum[x],val[a]=val[x],ch[a][0]=ch[x][0],ch[a][1]=ch[x][1],dat[a]=dat[x],tag[a]=tag[x];
	return a;
}
void del(int &root,int a)//为了可持久化，除了split和merge以外的每一个基本操作都要加上&root参数（必须是引用）
{
	split(root,a,x,z);
	split(x,a-1,x,y);
	can[++cantop]=y;
	root=merge(x,z);
}
```

## 最终代码

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=200005;
int ch[N<<6][3],val[N<<6],dat[N<<6],sz[N<<6],tag[N<<6],root[N],tot,x,y,z;
int can[N],cantop;
ll sum[N<<6];
void read(int &n)
{
	int fh=1,ans;
	char c;
	while (!isdigit(c=getchar())) if (c=='-') fh=-1;
	ans=c-48;
	while (isdigit(c=getchar())) ans=ans*10+c-48;
	n=ans*fh;
}
int new_node(int x)
{
	int a=cantop?can[cantop--]:++tot;
	sz[a]=1,sum[a]=val[a]=x,dat[a]=rand();
	return a;
}
int clone(int x)
{
	int a=cantop?can[cantop--]:++tot;
	sz[a]=sz[x],sum[a]=sum[x],val[a]=val[x],ch[a][0]=ch[x][0],ch[a][1]=ch[x][1],dat[a]=dat[x],tag[a]=tag[x];
	return a;
}
void down(int x)
{
	swap(ch[x][0],ch[x][1]);
	if (ch[x][0]) ch[x][0]=clone(ch[x][0]),tag[ch[x][0]]^=1;
	if (ch[x][1]) ch[x][1]=clone(ch[x][1]),tag[ch[x][1]]^=1;
	tag[x]=0;
}
void update(int x)
{
	sz[x]=1+sz[ch[x][0]]+sz[ch[x][1]];
	sum[x]=val[x]+sum[ch[x][0]]+sum[ch[x][1]];
}
void split(int now,int k,int &x,int &y)
{
	if (!now) {x=y=0;return;}
	if (tag[now]) down(now);
	if (sz[ch[now][0]]<k)
	{
		x=clone(now);
		split(ch[x][1],k-sz[ch[x][0]]-1,ch[x][1],y);
		update(x);
	}
	else 
	{
		y=clone(now);
		split(ch[y][0],k,x,ch[y][0]);
		update(y);
	}
}
int merge(int x,int y)
{
	if (!x||!y) return x+y;
	else if (dat[x]<dat[y])
	{
		if (tag[x]) down(x);
		ch[x][1]=merge(ch[x][1],y);
		update(x);
		return x;
	}
	else
	{
		if (tag[y]) down(y);
		ch[y][0]=merge(x,ch[y][0]);
		update(y);
		return y;
	}
}
void insert(int &root,int k,int a)
{
	split(root,k,x,y);
	root=merge(merge(x,new_node(a)),y);
}
void del(int &root,int a)
{
	split(root,a,x,z);
	split(x,a-1,x,y);
	can[++cantop]=y;
	root=merge(x,z);
}
void rev(int &root,int l,int r)
{
	split(root,l-1,x,y);
	split(y,r-l+1,y,z);
	tag[y]^=1;
	root=merge(x,merge(y,z));
}
ll query(int &root,int l,int r)
{
	split(root,l-1,x,y);
	split(y,r-l+1,y,z);
	ll ans=sum[y];
	root=merge(x,merge(y,z));
	return ans;
}
int main()
{
	int n;
	ll lastans=0;
	read(n);
	for (int i=1;i<=n;i++)
	{
		int v,opt,p,x,l,r;
		read(v),read(opt);
		root[i]=root[v];
		if (opt==1)
		{
			read(p),read(x);
			p^=lastans,x^=lastans;
			insert(root[i],p,x);
		}
		else if (opt==2)
		{
			read(p);
			p^=lastans;
			del(root[i],p);
		}
		else if (opt==3)
		{
			read(l),read(r);
			l^=lastans,r^=lastans;
			if (l>r) swap(l,r);
			rev(root[i],l,r);
		}
		else
		{
			read(l),read(r);
			l^=lastans,r^=lastans;
			if (l>r) swap(l,r);
			lastans=query(root[i],l,r);
			printf("%lld\n",lastans);
		}
	}
	return 0;
}
```



---

## 作者：EnofTeiPeople (赞：13)

我是可爱的 [X](/user/502410) 的小号，因为 [X](/user/502410) 已经写过 $\text{fhq\_treap}$ 的[题解](/blog/502410/solution-p5055)了，我又发现了一种常数吊打 $\text{fhq\_treap}$ 的文艺平衡树，只交了四发就得到了最优解 $\text{(2022.9.28)}$，就再写一篇题解。

讲的是 $\text{merge\_WBLT}$，即可以合并的 [$\text{WBLT}$](http://oi-wiki.org/ds/wblt/)，它还有很多别称，例如 $\text{Zyf\_tree}$。

由于这是 $\text{leafy\_tree}$，所有数值都存在于叶子节点，就像线段树一样，这样每一个节点只需要存：

1. `sz`：子树大小（叶子个数）；
2. `df`：建立时间，用于判断是否需要复制；
3. `sm`：子树权值和；
4. `rv`：翻转的懒标记。

特殊的，叶子节点不会翻转，`sm` 维护的是自己的权值。

分裂和 $\text{fhq\_treap}$ 类似，甚至不需要考虑自己：
```cpp
void spt(int x,int k,int &L,int &R){
    if(!x){L=R=0;return;}
    if(!k){L=0,R=x;return;}
    if(k==sz[x]){L=x,R=0;return;}pd(x);
    if(k<sz[ls])cp(x),spt(ls,k,L,ls),pp(R=x);
    else if(k==sz[ls])L=ls,R=rs;
    else cp(x),spt(rs,k-sz[ls],rs,R),pp(L=x);
}
```
合并是保证复杂度的关键，考虑合并两棵树 $L,R$，如果大小差异不大，直接新建一个节点将它们串起来，具体的，$\frac{\max\{sz_L,sz_R\}}{sz_L+sz_R}\le1-\alpha$，$\alpha$ 是一个 $(0,1)$ 中的实数，一般取 $1-\frac{\sqrt2}{2}$，可以适当调整。

否则，假定 $sz_R>sz_L$，这时若 $sz_{rson_R}$ 足够大，即 $\frac{sz_{rson_R}}{sz_L+sz_R}>\alpha$，可以直接将 $L$ 与 $sz_{lson_R}$ 合并，返回 $R$；

若不够大，则将 $lson_R$ 拆成左右子树 $l'$ 和 $r'$，将 $L$ 与 $l'$ 合并，再将 $r'$ 和 $rson_R$ 合并，容易发现，这样最多递归 $\log_2sz_R$ 层。

如果 $sz_L>sz_R$ 对称地做即可：
```cpp
int mg(int L,int R){
    if(!L||!R)return L|R;
    int x=sz[L]>sz[R]?L:R,sm=sz[L]+sz[R],y;
    if(sz[x]<ra*sm){
        df[x=++cnt]=dt,ls=L,rs=R,pp(x);
        return x;
    }
    if(x==L){
        pd(x);
        if(sz[ls]>af*sm){
            cp(x),rs=mg(rs,R),pp(x);return x;
        }else{
            y=rs,pd(y);int _l=t[y][0],_r=t[y][1];
            return mg(mg(ls,_l),mg(_r,R));
        }
    }else{
        pd(x);
        if(sz[rs]>af*sm){
            cp(x),ls=mg(L,ls),pp(x);return x;
        }else{
            y=ls,pd(y);int _l=t[y][0],_r=t[y][1];
            return mg(mg(L,_l),mg(_r,rs));
        }
    }exit(102893);return 0;
}
```
#### 小记：作者并不认为这样的文艺平衡树复杂度是正确的，但实测时跑得比其它平衡树真的快很多，仔细分析，该平衡树也许合并是$O(\log_2^2sz_R)$ 的，但可以断定绝对不会退化到 $O(sz_R)$，具体的，可以想象最坏情况并计算合并递归次数。

---

## 作者：EnofTaiPeople (赞：8)

在我看来，$\text{fhq treap}$ 最大的优点就是实现了期望复杂度为 $O(\log_2n)$ 的可持久化文艺平衡树，这一点将它的功能和 $\text{splay}$、块状链表区分开了。

说到底，可持久化和普通的到底有什么区别？其实就是：后面的操作不能影响到前面的节点，于是当一个节点发生改变时，要将自己复制一遍。

这样，时间和空间都是 $O(n\log_2n)$ 的，复杂度可以接受。

有一个重点：对 $\text{Treap}$ 来说，只要树堆的性质得到满足，一般树高都在 $2\log_2n$ 左右，但前提是要满足树堆性质！于是，如果在复制节点时不复制随机因子，由于树堆的性质得不到满足，树的高度就会退化成 $O(n)$。

上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2e7+7;
char buf[N+5],*p1,*p2,c;
#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,N,stdin),p1==p2)?EOF:*p1++)
inline ll read(){
    ll an=0,f=1;while(!isdigit(c=gc))if(c=='-')f=-f;
    do an=an*10+(48^c);while(isdigit(c=gc));return an*f;
}
int t[N][7],cnt,tim,Q,rt[N];
ll sum[N],dat[N],las;
#define l(x) t[x][0]
#define r(x) t[x][1]
#define s(x) t[x][2]
#define rv(x) t[x][3]
#define d(x) t[x][4]
#define dfn(x) t[x][5]
#define rd(x) t[x][6]
inline void cp(int &x){
    if(x&&dfn(x)<tim){
        dat[++cnt]=dat[x],sum[cnt]=sum[x];
        for(int i=0;i<7;++i)t[cnt][i]=t[x][i];
        dfn(x=cnt)=tim;
    }
}
inline void pp(int &x){
    s(x)=s(l(x))+s(r(x))+1;
    sum[x]=sum[l(x)]+sum[r(x)]+dat[x];
}
inline void Rev(int &x){
    if(x)cp(x),swap(l(x),r(x)),rv(x)^=1;
}
inline void pd(int &x){
    cp(x);if(rv(x))Rev(l(x)),Rev(r(x)),rv(x)=0;
}
void split(int &x,int &y,int k,int now=rt[tim]){
    if(!now)return void(x=y=0);pd(now);
    if(k<=s(l(now))){
        cp(y=now),split(x,l(y),k,l(y)),pp(y);
    }else{
        cp(x=now),split(r(x),y,k-s(l(now))-1,r(x)),pp(x);
    }return;
}
int merge(int x,int y){
    if(!x||!y)return x|y;pd(x),pd(y);
    if(rd(x)<rd(y)){
        r(x)=merge(r(x),y),pp(x);return x;
    }else{
        l(y)=merge(x,l(y)),pp(y);return y;
    }
}
int main(){
    mt19937 rg(N^time(0));
    srand(time(0)^N);
    int v,op,x,l,r,p,L,R;
    Q=read();
    for(tim=1;tim<=Q;++tim){
        v=read(),op=read();
        rt[tim]=rt[v];
        if(op<3){
            p=read()^las;
            if(op&1){
                split(L,R,p),dfn(++cnt)=tim,rd(cnt)=rg()^rand();
                dat[cnt]=sum[cnt]=read()^las,s(cnt)=1;
                rt[tim]=merge(merge(L,cnt),R);
            }else{
                split(L,rt[tim],p-1);
                split(rt[tim],R,1);
                rt[tim]=merge(L,R);
            }
        }else{
            l=read()^las,r=read()^las;
            split(L,rt[tim],l-1);
            split(rt[tim],R,r-l+1);
            if(op&1)Rev(rt[tim]);
            else printf("%lld\n",las=sum[rt[tim]]);
            rt[tim]=merge(merge(L,rt[tim]),R);
        }
    }return 0;
}
```

---

## 作者：Aleph1022 (赞：8)

啥时候“文艺平衡树”成了 Splay 的代称了……

果断写了个 FHQ Treap，然后 30pts。  
求助大佬之后发现标记下传时也要新建结点。

以及合并的时候不必新建结点，因为分裂时已经新建了，否则会 MLE。

代码：
```cpp
#include <cstdio>
#include <algorithm>
#include <cstdlib>
#define ls(p) tree[p].lson
#define rs(p) tree[p].rson
using namespace std;
const int N = 2e5;
int n;
long long lastans;
struct node
{
    int rnd,sz,rev;
    long long val,sum;
    int lson,rson;
} tree[(N << 7) + 10];
int rt[N + 10];
inline int new_node(long long v = 0)
{
    static int tot = 0;
    tree[++tot].val = v;
    tree[tot].sum = v;
    tree[tot].rnd = rand();
    tree[tot].sz = 1;
    return tot;
}
inline int copy_node(int p)
{
    int ret = new_node();
    tree[ret] = tree[p];
    return ret;
}
inline void up(int p)
{
    tree[p].sz = tree[ls(p)].sz + 1 + tree[rs(p)].sz;
    tree[p].sum = tree[ls(p)].sum + tree[p].val + tree[rs(p)].sum;
}
inline void down(int p)
{
    if(tree[p].rev)
    {
        if(ls(p))
            ls(p) = copy_node(ls(p));
        if(rs(p))
            rs(p) = copy_node(rs(p));
        swap(ls(p),rs(p));
        if(ls(p))
            tree[ls(p)].rev ^= 1;
        if(rs(p))
            tree[rs(p)].rev ^= 1;
        tree[p].rev = 0;
    }
}
void split(int p,int k,int &x,int &y)
{
    if(!p)
    {
        x = y = 0;
        return ;
    }
    down(p);
    if(tree[ls(p)].sz < k)
        x = copy_node(p),split(rs(x),k - tree[ls(p)].sz - 1,rs(x),y),up(x);
    else
        y = copy_node(p),split(ls(y),k,x,ls(y)),up(y);
}
int merge(int x,int y)
{
    if(!x || !y)
        return x | y;
    down(x),down(y);
    if(tree[x].rnd < tree[y].rnd)
    {
        rs(x) = merge(rs(x),y);
        up(x);
        return x;
    }
    else
    {
        ls(y) = merge(x,ls(y));
        up(y);
        return y;
    }
}
int main()
{
    srand(19260817);
    scanf("%d",&n);
    int cnt = 0;
    int v,op;
    long long a,b;
    int x,y,z;
    while(n--)
    {
        scanf("%d%d",&v,&op);
        if(op == 1)
        {
            scanf("%lld%lld",&a,&b);
            a ^= lastans,b ^= lastans;
            split(rt[v],a,x,y);
            rt[++cnt] = merge(merge(x,new_node(b)),y);
        }
        else if(op == 2)
        {
            scanf("%lld",&a);
            a ^= lastans;
            split(rt[v],a,x,z);
            split(x,a - 1,x,y);
            rt[++cnt] = merge(x,z);
        }
        else if(op == 3)
        {
            scanf("%lld%lld",&a,&b);
            a ^= lastans,b ^= lastans;
            split(rt[v],b,x,z);
            split(x,a - 1,x,y);
            tree[y].rev ^= 1;
            rt[++cnt] = merge(merge(x,y),z);
        }
        else
        {
            scanf("%lld%lld",&a,&b);
            a ^= lastans,b ^= lastans;
            split(rt[v],b,x,z);
            split(x,a - 1,x,y);
            printf("%lld\n",lastans = tree[y].sum);
            rt[++cnt] = merge(merge(x,y),z);
        }
    }
}
```


---

## 作者：intel_core (赞：6)

前置芝士：  
*  $Splay$ 
*  可持久化$FHQ Treap 

可持久化$Splay =$可持久化$ FHQ Treap+Splay$   
简单加法即可     
打个广告：[->](https://www.luogu.com.cn/blog/117771/p3835-ti-xie)         
```cpp
#include<bits/stdc++.h>
using namespace std;
const int NR=5e5+10;
#define int long long
struct node{
	int val;
	int size;
	int ch[2];
	int rnd;
	long long sum;
	int rev;
}t[NR<<6];
#define lson t[id].ch[0]
#define rson t[id].ch[1]
void update(int id){
	t[id].size=t[lson].size+t[rson].size+1;
	t[id].sum=t[lson].sum+t[rson].sum+t[id].val;
} 
int tot;
int newNode(int val=0){
	tot++;
	t[tot].val=val;
	t[tot].size=1;
	t[tot].rnd=rand();
	t[tot].sum=val;
	return tot;
}
void pushdown(int id){
	if(!t[id].rev)return;
	swap(t[id].ch[0],t[id].ch[1]);
	t[lson].rev^=1;
	t[rson].rev^=1;
	t[id].rev=0;
}
void splitk(int id,int k,int &x,int &y){
	if(!id){
		x=y=0;
		return;	
	}
	pushdown(id);
	int lsize=t[lson].size;
	if(k<=lsize){
		y=newNode();
		t[y]=t[id];
		splitk(lson,k,x,t[y].ch[0]);
		update(y);
	}
	else{
		x=newNode();
		t[x]=t[id];
		splitk(rson,k-lsize-1,t[x].ch[1],y);
		update(x);
	}
}
void inorder(int id){
	if(!id)return ;
	inorder(lson);
	printf("{ ",t[id].val);
	inorder(rson);
}
int merge(int x,int y){
	if(!x||!y)return x+y;
	if(t[x].rnd<t[y].rnd){
		int id=newNode();
		pushdown(x);
		t[id]=t[x];
		t[id].ch[1]=merge(t[id].ch[1],y);
		update(id);
		return id;
	}
	else{
		int id=newNode();
		pushdown(y);
		t[id]=t[y];
		t[id].ch[0]=merge(x,t[id].ch[0]);
		update(id);
		return id;
	}
}
void insert(int k,int val,int &id){
	int x,y;
	splitk(id,k,x,y);
	id=merge(x,merge(newNode(val),y));
}
void del(int k,int &id){
	int x,y,z;
	x=y=z=0;
	splitk(id,k,x,z);
	splitk(x,k-1,x,y);
	id=merge(x,z); 
}
int rt[NR];
int kth(int id,int k){
	while(1){
		if(k<=t[lson].size)id=lson;
		else{
			k-=t[lson].size;
			if(!--k)return id;
			id=rson;
		}
	}
}
signed main(){
	//freopen("1.in","r",stdin);
	int n;
	cin>>n;
	long long ans=0;
	for(int i=1;i<=n;i++){
		int ver,opt,x,y;
		scanf("%lld%lld",&ver,&opt);
		rt[i]=rt[ver];
		if(opt==1){
			int x,y;
			scanf("%lld%lld",&x,&y);
			x^=ans;
			y^=ans;
			insert(x,y,rt[i]);
		}
		if(opt==2){
			int x;
			scanf("%lld",&x);
			x^=ans;
			del(x,rt[i]);
		}
		if(opt==3){
			int x,y;
			scanf("%lld%lld",&x,&y);
			x^=ans;
			y^=ans;
			int t1,t2,t3;
			splitk(rt[i],x-1,t1,t2);
			splitk(t2,y-x+1,t2,t3);  
			t[t2].rev^=1;
			rt[i]=merge(t1,merge(t2,t3));
		}
		if(opt==4){
			int x,y;
			scanf("%lld%lld",&x,&y);
			x^=ans;
			y^=ans;
			int t1,t2,t3;
			splitk(rt[i],y,t1,t3);
			splitk(t1,x-1,t1,t2);
			ans=t[t2].sum;
			rt[i]=merge(t1,merge(t2,t3));
			printf("%lld\n",ans);
		}
	}
	return 0;
}
```
你觉得这就完了？     
翻转操作本质上也是对序列做了修改   
所以在翻转的时候要把翻转前的序列保存下来   
而翻转有可能自己是一个版本   
所以不保存就会WA一片    
AC代码：   
```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cmath>
#include <queue>
#include <cstring>
using namespace std;
const int NR=5e5+10;
#define int long long
struct node{
	int val;
	int size;
	int ch[2];
	int rnd;
	long long sum;
	int rev;
}t[NR<<6];
#define lson t[id].ch[0]
#define rson t[id].ch[1]
void update(int id){
	t[id].size=t[lson].size+t[rson].size+1;
	t[id].sum=t[lson].sum+t[rson].sum+t[id].val;
} 
int tot;
int newNode(int val=0){
	tot++;
	t[tot].val=val;
	t[tot].size=1;
	t[tot].rnd=rand();
	t[tot].sum=val;
	return tot;
}
int copy(int k){
	int id=newNode();
	t[id]=t[k];
	return id;
}
void pushdown(int id){
	if(!t[id].rev)return;
	if(t[id].ch[0])t[id].ch[0]=copy(t[id].ch[0]);
	if(t[id].ch[1])t[id].ch[1]=copy(t[id].ch[1]);
	swap(t[id].ch[0],t[id].ch[1]);
	t[lson].rev^=1;
	t[rson].rev^=1;
	t[id].rev=0;
}
void splitk(int id,int k,int &x,int &y){
	if(!id){
		x=y=0;
		return;	
	}
	pushdown(id);
	int lsize=t[lson].size;
	if(k<=lsize){
		y=newNode();
		t[y]=t[id];
		splitk(lson,k,x,t[y].ch[0]);
		update(y);
	}
	else{
		x=newNode();
		t[x]=t[id];
		splitk(rson,k-lsize-1,t[x].ch[1],y);
		update(x);
	}
}
void inorder(int id){
	if(!id)return ;
	inorder(lson);
	printf("{ ",t[id].val);
	inorder(rson);
}
int merge(int x,int y){
	if(!x||!y)return x+y;
	if(t[x].rnd<t[y].rnd){
		int id=x;
		pushdown(x);
		t[id].ch[1]=merge(t[id].ch[1],y);
		update(id);
		return id;
	}
	else{
		int id=y;
		pushdown(y);
		t[id].ch[0]=merge(x,t[id].ch[0]);
		update(id);
		return id;
	}
}
void insert(int k,int val,int &id){
	int x,y;
	splitk(id,k,x,y);
	id=merge(x,merge(newNode(val),y));
}
void del(int k,int &id){
	int x,y,z;
	x=y=z=0;
	splitk(id,k,x,z);
	splitk(x,k-1,x,y);
	id=merge(x,z); 
}
int rt[NR];
int kth(int id,int k){
	while(1){
		if(k<=t[lson].size)id=lson;
		else{
			k-=t[lson].size;
			if(!--k)return id;
			id=rson;
		}
	}
}
signed main(){
	//freopen("1.in","r",stdin);
	//freopen("1.out","w",stdout);
	int n;
	cin>>n;
	long long ans=0;
	for(int i=1;i<=n;i++){
		int ver,opt,x,y;
		scanf("%lld%lld",&ver,&opt);
		rt[i]=rt[ver];
		if(opt==1){
			int x,y;
			scanf("%lld%lld",&x,&y);
			x^=ans;
			y^=ans;
			insert(x,y,rt[i]);
		}
		if(opt==2){
			int x;
			scanf("%lld",&x);
			x^=ans;
			del(x,rt[i]);
		}
		if(opt==3){
			int x,y;
			scanf("%lld%lld",&x,&y);
			x^=ans;
			y^=ans;
			int t1,t2,t3;
			splitk(rt[i],x-1,t1,t2);
			splitk(t2,y-x+1,t2,t3);  
			t[t2].rev^=1;
			rt[i]=merge(t1,merge(t2,t3));
		}
		if(opt==4){
			int x,y;
			scanf("%lld%lld",&x,&y);
			x^=ans;
			y^=ans;
			int t1,t2,t3;
			splitk(rt[i],y,t1,t3);
			splitk(t1,x-1,t1,t2);
			ans=t[t2].sum;
			rt[i]=merge(t1,merge(t2,t3));
			printf("%lld\n",ans);
		}
	}
	return 0;
}
```
码字不易，点赞支持一下？

---

## 作者：山田リョウ (赞：5)

你需要会文艺平衡树，不会的话看一下[这里](https://www.luogu.com.cn/blog/huaerxiao-nuo0930/solution-p3391)。

然后这道题就是维护一下翻转的懒惰标记和区间和，插入和删除就像普通平衡树里面那样分裂合并，可持久化的话就是对任何一个信息（包括懒惰标记）有修改的话都要复制一下在修改，维护一下每个版本树的根节点。

丢个代码：
```cpp
#include <cstdio>
#include <cstdlib>
const int maxn = 2e+5, maxsize = (maxn << 7) + 10;
int val[maxsize];
int key[maxsize];
int size[maxsize];
int lc[maxsize], rc[maxsize];
bool lazy[maxsize];
typedef long long ll;
ll sum[maxsize];
int nodecnt;
inline int newnode(int x) {
    val[++nodecnt] = x;
    key[nodecnt] = std::rand();
    size[nodecnt] = 1;
    lc[nodecnt] = rc[nodecnt] = 0;
    lazy[nodecnt] = 0;
    sum[nodecnt] = x;
    return nodecnt;
}
inline int copynode(int x) {
    val[++nodecnt] = val[x];
    key[nodecnt] = key[x];
    size[nodecnt] = size[x];
    lc[nodecnt] = lc[x];
    rc[nodecnt] = rc[x];
    lazy[nodecnt] = lazy[x];
    sum[nodecnt] = sum[x];
    return nodecnt;
}
inline void pushup(int x) {
    size[x] = size[lc[x]] + size[rc[x]] + 1;
    sum[x] = sum[lc[x]] + sum[rc[x]] + val[x];
}
inline void swap(int& x, int& y) {
    int t = x;
    x = y;
    y = t;
}
inline void pushdown(int x) {
    if (lazy[x]) {
        if(lc[x]) 
            lc[x] = copynode(lc[x]),lazy[lc[x]] ^= 1;
        if(rc[x]) 
            rc[x] = copynode(rc[x]),lazy[rc[x]] ^= 1;
        swap(lc[x], rc[x]);
        lazy[x] = 0;
    }
}
void split(int rt, int x, int& a, int& b) {
    if (!rt)
        return (void)(a = b = 0);
    int t = copynode(rt);
    pushdown(t);
    if (size[lc[t]] + 1 <= x) {
        a = t;
        split(rc[a], x - size[lc[t]] - 1, rc[a], b);
    } else {
        b = t;
        split(lc[b], x, a, lc[b]);
    }
    pushup(t);
}
void join(int& rt, int a, int b) {
    if (!a || !b)
        return (void)(rt = a ^ b);
    if (key[a] < key[b]) {
        rt = b;
        pushdown(rt);
        join(lc[rt], a, lc[rt]);
    } else {
        rt = a;
        pushdown(rt);
        join(rc[rt], rc[rt], b);
    }
    pushup(rt);
}
ll query(int& rt, int l, int r) {
    int a, b, c;
    split(rt, l - 1, a, b);
    split(b, r - l + 1, c, b);
    ll ans = sum[c];
    join(b, c, b);
    join(rt, a, b);
    return ans;
}
void flip(int& rt, int l, int r) {
    int a, b, c;
    split(rt, l - 1, a, b);
    split(b, r - l + 1, c, b);
    lazy[c] ^= 1;
    join(b, c, b);
    join(rt, a, b);
}
void ins(int& rt, int p, int x) {
    int a, b;
    split(rt, p, a, b);
    join(b, newnode(x), b);
    join(rt, a, b);
}
void del(int& rt, int p) {
    int a, b, c;
    split(rt, p - 1, a, b);
    split(b, 1, c, b);
    join(rt, a, b);
}
int root[maxn + 1];
int main() {
    int n;
    std::scanf("%d", &n);
    int v, op;
    ll lastans = 0,x,y;
    for (int i = 1; i <= n; i++) {
        std::scanf("%d%d%lld", &v, &op, &x);
        x ^= lastans;
        if (op != 2) {
            std::scanf("%lld", &y);
            y ^= lastans;
        }
        root[i] = root[v];
        switch (op) {
            case 1:
                ins(root[i], x, y);
                break;
            case 2:
                del(root[i], x);
                break;
            case 3:
                flip(root[i], x, y);
                break;
            case 4:
                printf("%lld\n", lastans = query(root[i], x, y));
                break;
        }
    }
    return 0;
}
```
至于这个东西有什么用的话，其实我也不知道，如果有人知道能在评论区里面说一下吗/kk，感激不已。

---

## 作者：Sai0511 (赞：4)

可持久化$\text{fhq-treap}$。    
比较常用的平衡树一般就是$\text{fhq-treap}$和$\text{splay}$了，因为$\text{splay}$在旋转的时候树的形态发生了变换，固不能进行可持久化。而$\text{fhq-treap}$的所有操作都是基于分裂和合并的基础上的，对这棵树并没有影响，故可以进行可持久化。  
### 如何进行可持久化？                 
我们先思考一下一颗普通的$\text{fhq-treap}$怎么写？  
我们用$\text{size}$在分的时候一般直接让当前节点的左/右孩子直接进行递归。然而我们在可持久化的时候必须要将要求的历史版本的树全部$\text{copy}$下来，自然我们就需要一个$\text{clone}$函数来完成这个步骤，我们递归的时候直接改掉这颗克隆节点的左右孩子就好了。            
至于$\text{merge}$由于我们在$\text{split}$的时候已经克隆过了，我们只需要安心大胆的合并即可。           
还有一个关于空间的问题。        
当我们每次删除一个节点时，这个位置的资源就空了出来。如果不使用的话就实在太浪费了。        
我们用一个$\text{emp}$数组来完成这个操作。     
好像十分好写的样子。      
### My Code:
```cpp
#include <bits/stdc++.h>
#define il inline                       
typedef long long ll;         
const int maxn = 2e5 + 10;            
using namespace std;
template<class T> il void rd(T& res) {
    res = 0;char c;bool sign = 0;
    for(c = getchar();!isdigit(c);c = getchar()) sign |= c == '-';
    for(;isdigit(c);c = getchar()) res = (res << 1) + (res << 3) + (c ^ 48);
    (sign) && (res = -res);
    return;
}      
struct TreapNode {
    int ch[2];
    int rnd,size,val;bool rev;
    ll sum;
}tr[maxn << 6];               
int emp[maxn],root[maxn];           
int n,m,i,j,k,q,tot,emp_top,a,b,c,d;ll lans;
il void _swap(int& x,int& y) {
    x ^= y ^= x ^= y;
    return;
}   
il int new_node(int v) {
    int id = emp_top ? emp[emp_top--] : ++tot;                      
    tr[id].rnd = rand();tr[id].val = v;       
    tr[id].size = 1;tr[id].sum = v;tr[id].rev = 0; 
    tr[id].ch[0] = tr[id].ch[1] = 0;
    return id;
}
il int clone(int o) {
    int id = emp_top ? emp[emp_top--] : ++tot;
    tr[id].ch[0] = tr[o].ch[0];tr[id].ch[1] = tr[o].ch[1];
    tr[id].rnd = tr[o].rnd;tr[id].size = tr[o].size;tr[id].val = tr[o].val;
    tr[id].rev = tr[o].rev;tr[id].sum = tr[o].sum;
    return id;   	
}
il void push_down(int o) {
    if(tr[o].rev) {
        _swap(tr[o].ch[0],tr[o].ch[1]);        
        if(tr[o].ch[0]) tr[o].ch[0] = clone(tr[o].ch[0]),tr[tr[o].ch[0]].rev ^= 1; 
        if(tr[o].ch[1]) tr[o].ch[1] = clone(tr[o].ch[1]),tr[tr[o].ch[1]].rev ^= 1;
        tr[o].rev = 0;
  	}
  	return;
}
il void push_up(int o) {
    tr[o].size = tr[tr[o].ch[0]].size + tr[tr[o].ch[1]].size + 1;
    tr[o].sum = tr[tr[o].ch[0]].sum + tr[tr[o].ch[1]].sum + tr[o].val;
    return;
}
void split_k(int now,int k,int& x,int& y) { 
    if(!now) {x = y = 0;return;}         
    push_down(now);       
    if(tr[tr[now].ch[0]].size < k) { 
        x = clone(now);        
        split_k(tr[x].ch[1],k - tr[tr[x].ch[0]].size - 1,tr[x].ch[1],y);
        push_up(x);
    } else {
        y = clone(now);
        split_k(tr[y].ch[0],k,x,tr[y].ch[0]);                    
        push_up(y);		
    } 
    return;
} 
int merge(int u,int v) {
    if(!u) return v;if(!v) return u;
    if(tr[u].rnd < tr[v].rnd) {
        push_down(u);
        tr[u].ch[1] = merge(tr[u].ch[1],v);
        push_up(u);
        return u;
    } else {
        push_down(v);
        tr[v].ch[0] = merge(u,tr[v].ch[0]);      
        push_up(v);
        return v;
    }
}
il void insert(int& root,int x,int v) {   
    split_k(root,x,a,b);                           
    root = merge(merge(a,new_node(v)),b);
    return;
}  
il void erase(int& root,int x) {  
    split_k(root,x,a,c);  
    split_k(a,x - 1,a,b);           
    emp[++emp_top] = b;     
    root = merge(a,c); 
    return;
}
il void rever(int& root,int l,int r) {
    split_k(root,l - 1,a,b);
    split_k(b,r - l + 1,b,c);  
    tr[b].rev ^= 1;    
    root = merge(a,merge(b,c));
    return;
}
il ll query(int& root,int l,int r) {
    split_k(root,l - 1,a,b);
    split_k(b,r - l + 1,b,c);                     
    ll res = tr[b].sum;
    root = merge(a,merge(b,c));
    return res;
}
int main() { 
    srand((unsigned)time(NULL));
    rd(q);
    for(int i = 1,x,y,l,r;i <= q;i++) {
        int his,opt;rd(his);rd(opt);root[i] = root[his];
        switch(opt) {
            case 1:rd(x);rd(y);insert(root[i],x ^ lans,y ^ lans);break;
            case 2:rd(x);erase(root[i],x ^ lans);break;
            case 3:rd(l);rd(r);rever(root[i],l ^ lans,r ^ lans);break;  
            case 4:rd(l);rd(r);l ^= lans;r ^= lans;printf("%lld\n",lans = query(root[i],l,r));break;
        }    
    //	cout << a << ' ' << b << ' ' << c << endl;
    }
} 

```







---

## 作者：封禁用户 (赞：3)

# P5055 【模板】可持久化文艺平衡树 题解
## 思路

[题目传送门](https://www.luogu.com.cn/problem/P5055)

先抛几个疑问，用来更好地读懂代码。

1. 在```Split```(分裂)中如何记录树的变化？
```Split```是一个从根到叶子的**递归**过程，每次递归返回 $L$ 和 $R$ 两棵树，若 $L$ 和 $R$ 有所变化，则需要复制它们。注意只复制 $L$ 和 $R$ 的根即可，不用复制整棵树，细节见代码。

2. 存储副本需要多少时间？
在可持久化线段树中，每个新副本只需要存储发生变化的 $\mathcal{O}(\log n)$ 个节点，共存储 $\mathcal{O}(n\log n)$个。```FHQ Treap```树的分裂可能导致较大的变化，所以需要更大的空间，不妨设置为题目允许的最大空间，由于内存限制为 $1$ GB，则能设置到 $128 \times n$。

好了，接下来看看代码：

code：
```cpp
#include<iostream>
#include<cmath>
#include<stdlib.h>
#include<time.h>
#define ll long long
using namespace std;

const int N = 2e5 + 10;
struct node{
	int ls;
	int rs;
	int val;
	int pri;
	int size;
	int lazy;
	ll sum;
}t[N << 7];//详见 ↑↑ 
int cnt;

void swap(int &a, int &b)
{
    int k = a;
    a = b;
    b = k;
    return ;
}

int new_node(int x){//重建 
	cnt++;
	t[cnt].size = 1;
	t[cnt].ls = t[cnt].rs = 0;
	t[cnt].val = x;
	t[cnt].sum = x;
	t[cnt].pri = rand();
	t[cnt].lazy = 0;
	return cnt;
} 

int clone(int u){//复制树u，不需要复制整棵树，只复制root就可以 
	int ret = new_node(0);
	t[ret] = t[u];
	return ret; 
} 

void Update(int u){
	t[u].size = t[t[u].ls].size + t[t[u].rs].size + 1;
	t[u].sum = t[t[u].ls].sum + t[t[u].rs].sum + t[u].val;
}

void push_down(int u){
	if (!t[u].lazy){
		return ;
	}
	if (t[u].ls){
		t[u].ls = clone(t[u].ls);
	}
	if (t[u].rs){
		t[u].rs = clone(t[u].rs);
	}
	swap(t[u].ls, t[u].rs);
	t[t[u].ls].lazy ^= 1;
	t[t[u].rs].lazy ^= 1;
	t[u].lazy = 0;
	return ;
}

void Split(int u, int x, int &L, int &R){//排名分裂 
	if (u == 0){
		L = R = 0;
		return ;
	}
	push_down(u);
	if (t[t[u].ls].size + 1 <= x){//第x个数在u的右子树上 
		L = clone(u);   		  //这个时间点的L是这个时间点的u的副本 
		Split(t[L].rs, x - t[t[u].ls].size - 1, t[L].rs, R);
		Update(L); 
	}
	else{						  
		R = clone(u);   		  //这个时间点的R是这个时间点的u的副本 
		Split(t[R].ls, x, L, t[R].ls);
		Update(R);
	}
	return ;
}

int Merge(int L, int R){
	if (L == 0||R == 0){
		return max(L, R);    //return L + R;
	}
	push_down(L);
	push_down(R);
	if (t[L].pri > t[R].pri){
		t[L].rs = Merge(t[L].rs, R);
		Update(L);
		return L;
	}
	else{
		t[R].ls = Merge(L, t[R].ls);
		Update(R);
		return R;
	}
}

int root[N];

int main(){
	srand(time(NULL));
	int version = 0;
	int L, p, R;
	ll x, y;
	for (int i = 0; i < N; i++){
		root[i] = 0;
	}
	ll lastans = 0;
	int n;
	cin >> n;
	while (n--){
		int v, opt;
		cin >> v >> opt;
		if (opt == 1){		//在第x个数后插入y
			cin >> x >> y;
			x ^= lastans;
			y ^= lastans;
			Split(root[v], x, L, p);
			root[++version] = Merge(Merge(L, new_node(y)), p); //记录在新的时间点上  		
		}
		if (opt == 2){		//删除第x个数  
			cin >> x;
			x ^= lastans;
			Split(root[v], x, L, R);
			Split(L, x - 1, L, p);
			root[++version] = Merge(L, R); //记录在新的时间点上 
		} 
		if (opt == 3){		//翻转区间[x, y] 
			cin >> x >> y;
			x ^= lastans;
			y ^= lastans;
			Split(root[v], y, L, R);
			Split(L, x - 1, L, p);
			t[p].lazy ^= 1;
			root[++version] = Merge(Merge(L, p), R); //记录在新的时间点上 
		}
		if (opt == 4){		//查询区间和[x,y] 
			cin >> x >> y;
			x ^= lastans;
			y ^= lastans;
			Split(root[v], y, L, R);
			Split(L, x - 1, L, p); //p树是区间[x,y]
			lastans = t[p].sum;
			cout << lastans << endl;
			root[++version] = Merge(Merge(L, p), R); //记录在新的时间点上  
		}
	}
	return 0;//圆满结束 
} 
```
顺便推荐一道题：P3835

本蒟蒻第一篇题解，求过！

---

## 作者：gyyyyx (赞：3)

看题解之前你需要学会：[fhq_Treap](https://www.luogu.com.cn/blog/s19418/fei-xuan-treap-xue-xi-bi-ji)，[可持久化平衡树](https://www.luogu.com.cn/problem/P3835)，[文艺平衡树](https://www.luogu.com.cn/problem/P3391)。

可持久化文艺平衡树，就是 可持久化 的 文艺 的 平衡树（其实就是支持区间翻转的可持久化平衡树）。

首先可持久化那就要用 fhq_Treap，而刚好文艺平衡树也可以用它来实现。

先说说可持久化平衡树。

主要思想就是因为 fhq_Treap 不需要旋转，所以在 Split 的过程中可以对点进行复制。

而且每次修改的必然只有一个子树上的点，所以每次修改的节点不会很多，就能做到优化空间的结果。

再说说文艺平衡树。

想要让区间翻转那只要将节点都属于这个区间的子树的所有节点的左右儿子调换的行了（建议画图理解）。

如何找到节点都属于这个区间的子树呢？

原本的 fhq_Treap 是按照节点值来 Split，现在改一下，按照位置来 Split。

很显然先 Split 右端点，再在小于等于右端点的子树里 Split 左端点减一，那就可以得到位置在区间内的子树的根了。

但是要一个一个处理节点时间会炸掉，怎么办？

其实只要学习线段树那样在根节点打上懒标记，要访问的时候再更新。

最后的代码其实也没什么好说的，就是将两个代码结合起来，然后调一下细节。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 200005
int n;long long lastans;
struct fhq_Treap{
    int lson,rson,rnd,siz,tag;
    long long val,sum;
} t[N<<6];
int rt[N];
#undef N
inline int New(long long v=0){
    static int tot(0);
    t[++tot].val=v;t[tot].sum=v;
    t[tot].rnd=rand();t[tot].siz=1;
    return tot;
}
inline int Copy(int p){
    int res(New());
    t[res]=t[p];
    return res;
}
inline void pushup(int p){
    t[p].siz=t[t[p].lson].siz+t[t[p].rson].siz+1;
    t[p].sum=t[t[p].lson].sum+t[t[p].rson].sum+t[p].val;
}
inline void pushdown(int p){
    if(!t[p].tag)return;
    if(t[p].lson) t[p].lson=Copy(t[p].lson);
    if(t[p].rson) t[p].rson=Copy(t[p].rson);
    swap(t[p].lson,t[p].rson);
    if(t[p].lson) t[t[p].lson].tag^=1;
    if(t[p].rson) t[t[p].rson].tag^=1;
    t[p].tag=0;
}
void Split(int p,int k,int &x,int &y){
    if(!p){
        x=y=0;
        return;
    }
    pushdown(p);
    if(t[t[p].lson].siz<k){
        x=Copy(p);
        Split(t[x].rson,k-t[t[p].lson].siz-1,t[x].rson,y);
        pushup(x);
    }
    else{
        y=Copy(p);
        Split(t[y].lson,k,x,t[y].lson);
        pushup(y);
    }
}
int Merge(int x,int y){
    if(!x||!y)return x|y;
    pushdown(x);pushdown(y);
    if(t[x].rnd<t[y].rnd){
        t[x].rson=Merge(t[x].rson,y);
        pushup(x);
        return x;
    }
    else{
        t[y].lson=Merge(x,t[y].lson);
        pushup(y);
        return y;
    }
}
int main(){
    srand((unsigned)time(NULL));
    scanf("%d",&n);
    int v,op,x,y,z;long long a,b;
    for(int i(1);i<=n;++i){
        scanf("%d%d",&v,&op);
        if(op==1){
            scanf("%lld%lld",&a,&b);
            a^=lastans;b^=lastans;
            Split(rt[v],a,x,y);
            rt[i]=Merge(Merge(x,New(b)),y);
        }
        else if(op==2){
            scanf("%lld",&a);
            a^=lastans;
            Split(rt[v],a,x,z);
            Split(x,a-1,x,y);
            rt[i]=Merge(x,z);
        }
        else if(op==3){
            scanf("%lld%lld",&a,&b);
            a^=lastans;b^=lastans;
            Split(rt[v],b,x,z);
            Split(x,a-1,x,y);
            t[y].tag^=1;
            rt[i]=Merge(Merge(x,y),z);
        }
        else{
            scanf("%lld%lld",&a,&b);
            a^=lastans;b^=lastans;
            Split(rt[v],b,x,z);
            Split(x,a-1,x,y);
            printf("%lld\n",lastans=t[y].sum);
            rt[i]=Merge(Merge(x,y),z);
        }
    }
    return 0;
}
```

---

## 作者：WeLikeStudying (赞：2)

- 这里重点讲树堆（$\text{Treap}$）。
- 因为伸展树的复杂度带均摊，如果被死卡在一个操作上就麻烦了，无法可持久化。
![](https://cdn.luogu.com.cn/upload/image_hosting/u33d4630.png)
- 前面的讲解遵循循序渐进的原则，可以跳过前面的内容直接来到非旋转树堆。
- 另外一个要注意的就是：题解的代码容易挂，如果挂了请参照相应章节云剪贴板“普通平衡树加强版”的实现。

**旋转**
- 旋转是许多平衡树算法的难点所以需要仔细讲解。
- 首先介绍单旋：
![](https://cdn.luogu.com.cn/upload/image_hosting/gx1ysuso.png)
- 从左往右称为右旋，从右往左称为左旋，如何简洁地写出旋转的代码呢？
![](https://cdn.luogu.com.cn/upload/image_hosting/he7yqphu.png)
- 右旋可以类比。
```cpp
inline void turn(bool k,int &v)
{
	int u=sn[k^1][v];
	sn[k^1][v]=sn[k][u];
	update(v),sn[k][u]=v;
	update(u),v=u;
}
```

**树堆**
- 普通的二叉搜索树容易被卡。
- 对于数据离线的情况下，随机排序一遍是好的，因为可以证明期望树高是 $O(\log n)$。
- 但有的时候要同时支持一些修改操作，于是我们就需要二叉搜索树保持一个动态平衡的状态。
- 树堆通过随机权值同时用旋转让权值保持堆序来实现随机平衡的效果，单次操作期望 $O(\log n)$。
![](https://cdn.luogu.com.cn/upload/image_hosting/gx1ysuso.png)
- 下面左边和右边分别是两种旋转的方式。
- 插入节点后要往上旋转，删除节点后要往下旋转到叶子。
- 每次维护子树的大小就可以查询第 $k$ 大了，如何在旋转时顺便维护子树大小呢？
```cpp
inline void update(int u)
{
	sz[u]=sz[sn[0][u]]+sz[sn[1][u]]+nm[u];
}
inline void turn(bool k,int &v)
{
	int u=sn[k^1][v];
	sn[k^1][v]=sn[k][u];
	update(v),sn[k][u]=v;
	update(u),v=u;
}
```
- 显然可以。
- 具体实现中，我们通常使用 $0$ 号节点以保证正确的边界情况处理，它用作表示空节点和防止越界访问。
- 注意是大根堆还是小根堆，注意每次更改都要维护堆性质，注意分清 $\text{son}(0,i)$，以下是比较复杂的删除节点操作的代码。
- 注意加入点后要声明加入点的父亲，要不然后面转不上去。
```cpp
void erase(int &u,int G)
{
	if(G==g[u])
	{
		if(nm[u]>0)--nm[u],--sz[u];
		if(!nm[u])
		{
			if(!sn[0][u]||!sn[1][u]) 
				u=sn[!sn[0][u]][u];
			else
			{
				bool k=(w[sn[0][u]]<w[sn[1][u]]); 
				turn(k,u);
				erase(sn[k][u],G);
			}
		}
		update(u);
		return;
	}
	erase(sn[g[u]<G][u],G);
	update(u);
}
```
- [树堆带注释实现](https://www.luogu.com.cn/paste/e1tqxv7z)。
- [普通平衡树树堆实现](https://www.luogu.com.cn/paste/io5v0c8k)。
- [普通平衡树加强版树堆实现](https://www.luogu.com.cn/paste/dv5y1jfk)（推荐）。
- [非递归普通平衡树树堆实现](https://www.luogu.com.cn/paste/rljr6i6c)。

**可分裂树堆**
- 由于树的结构相对稳定，可以方便地支持可持久化。
- 而且比旋转操作要好打，据说代码量也很小。
- 核心操作就是合并和分裂~~当然还有随机种子。~~
- 有按值合并和按排名分裂两种。
![](https://cdn.luogu.com.cn/upload/image_hosting/4xojsudx.png)
- 容易发现合并与分裂的核心在一条有趣的链上（注意合并要求值域不交），所以复杂度 $O(h)$。
- 合并：
```cpp
int merge(int x,int y)
{
	if(!x||!y)return x|y;
	int u;
	if(w[x]<w[y])sn[1][u=x]=merge(sn[1][x],y);
	else sn[0][u=y]=merge(x,sn[0][y]);
	update(u);
	return u;
}
```
- 分裂：
```cpp
void split(int u,int &x,int &y,int G)
{
	if(!u)
	{
		x=y=0;
		return;
	}
	if(g[u]<=G)split(sn[1][u],sn[1][x=u],y,G);
	else split(sn[0][u],x,sn[0][y=u],G);
	update(u);
}
```
- [带注释可分裂树堆实现](https://www.luogu.com.cn/paste/1gkhqn6r)。
- [普通平衡树可分裂树堆实现](https://www.luogu.com.cn/paste/mfltlj30)。
- [普通平衡树加强版可分裂树堆实现](https://www.luogu.com.cn/paste/u9whqt8a)（数组开太小，爆零两行泪）。
- [文艺平衡树可分裂树堆带注释实现](https://www.luogu.com.cn/paste/3show9cj)。
- [文艺平衡树可分裂树堆实现](https://www.luogu.com.cn/paste/0i1g1mp9)（作者的 $\text{get node}$ 写错了让 $\text{sz[0]=1}$）（注意分裂操作不同了，上传与下传也不同了，每次 $\text{split}$ 的时候记得下传懒标记）。
- [可持久化平衡树可分裂树堆代码实现](https://www.luogu.com.cn/paste/6q89rg9a)（核心是在分裂的时候新建节点，合并的时候不新建节点）。
- 接下来是今天的例题。

**可持久化文艺平衡树**
- [题目链接](https://www.luogu.com.cn/problem/P5055)。
- 支持可持久化动态插入，动态删除，区间反转，区间求和。
- 这题目看似比较麻烦，其实如果掌握了上面的套路的话也并不困难，所以重点讲一些实现细节。
- 数组大小和长整型要适宜。
- 注意分裂操作是按排名分裂，每次 $\text{split}$ 的时候记得下传懒标记。
- 由于 $\text{split}$ 和 $\text{merge}$ 操作成对出现，所以我们只需要在分裂时新建节点（注意要在这之前下传，因为子树在以后其实也会改变，需要避免出现可能的反复修改的危险）即可。
- 值得注意的是，合并也需要下传，为啥？
- 值得注意的是，下传的时候，左右儿子需要新建节点，防止后来的标记更改到以前的标记。
- 值得注意的是，输入要开 $\text{long long}$，因为有可能异或的上一个答案是一个很大的数值，如果不开就会爆掉。
- [代码实现](https://www.luogu.com.cn/paste/q2rckhj6)。

---

## 作者：zhongyuwei (赞：2)

我用了一种类似于支持区间修改的可持久化线段树的方法，也就是标记永久化。看到大家的做法都是在下放标记的时候把节点复制一遍，觉得这样很不爽啊……我想，能不能干脆把标记永久化，节约一些空间和时间呢？

实现的关键在于merge和split这两个函数。

### split

假设我们现在要把以$x$为根的这一棵子树，中序遍历的序列中的前$k$个节点分到第一棵$treap$中去，后$n-k$个节点分到第二棵$treap$中去。假设$x$的子树内的点，应该分到第一棵$treap$中的$a$节点的位置，应该分到第二棵$treap$中的$b$节点的位置。

我们记$tag_x$为要分离的这一棵$treap$中，从根节点到$x$的父亲标记累加的结果；记$tag_a$为第一棵$treap$中，从根节点到$a$点的父亲标记累加的结果；记$tag_b$为从根节点到$b$点的父亲标记累加的结果。我们记$rev_i$为$i$这个点的标记，其中$rev_i=1$表示这个子树内的点需要翻转，$rev_i=0$表示这个子树内的点不需要翻转。

那么，假如$x$的左儿子的大小大于等于$k$，也就是说，$x$属于第二棵$treap$，并且$x$的右儿子全部属于第二棵$treap$，那么，我们应该把$x$这个点放在$b$这个位置，然后递归分离$x$的左儿子（此时第二棵树中对应的位置就是$b$的左儿子了）。考虑标记，我们需要保证，第二棵树中$tag_b \text{ xor } rev_b = tag_x \text { xor } rev_x $。我们令$rev_b = tag_x \text{ xor } rev_x \text { xor } tag_b $即可。

左儿子的大小小于$k$也是同理，我们令$rev_a = tag_x \text{ xor } rev_x \text{ xor } tag_a$即可。

注意，如果从根节点到某个点$x$，标记叠加的结果是$tg$，假如原来我们用$ch_{x,0}$表示$x$的左儿子，$ch_{x,1}$表示某个点的右儿子，那么现在$x$的左儿子应该表示为$ch_{x,tg}$，右儿子则是$ch_{x,tg\text{ xor }1}$。

``` cpp
int tx,ta,tb;
void split(int x,int k,int &a,int &b)
{
	if(!x){a=b=0; return;} tx^=rev[x];
	if(sz[ch[x][tx]]>=k)
	{
		rev[b=cpy(x)]=tb^tx,tb=tx;
		split(ch[x][tx],k,a,ch[b][tb]),push_up(b);
	}
	else
	{
		rev[a=cpy(x)]=ta^tx,ta=tx;
		split(ch[x][tx^1],k-sz[ch[x][tx]]-1,ch[a][ta^1],b),push_up(a);
	}
}
```



### merge

我们假设现在要把第一棵$treap$中以$a$为根的这个子树，以及第二棵$treap$中以$b$为根的这一棵子树，合并到$r$这个节点上。

我们仍然记$tag_a$为第一棵$treap$中，从根节点到$a$这个节点的父亲，标记累加的结果；设$tag_b$为第二棵$treap$中从根节点到$b$这个节点的父亲，标记累加的结果；设$tag_r$为合并后得到的树中，从根节点到$r$节点的父亲，标记累加的结果。

假如现在$key_a\le key_b$，即应该把$a$节点放到$r$这个位置，把$a$的右儿子和$b$合并。这个时候我们必须保证从合并后的树的根到$r$（也就是$a$）的这条路径上，标记累加的结果等于$tag_a\text{ xor } rev_a$。那么我们就令$r$这个节点的标记等于$tag_a\text{ xor } rev_a \text { xor } tag_r$，这样就有$rev_r \text{ xor } tag_r =tag_a \text { xor }  rev_a$。然后递归合并$a$的右儿子和$b$即可。

对于$key_a >key_b$的情况也是同理，我们需要保证从合并后的树的根到$r$的这条路径上，标记累加的结果等于$tag_b\text{ xor } rev_b$。令$rev_r = tag_b\text{ xor } rev_b \text{ xor } tag_r$即可。

注意我们$split$的时候，第一棵树的整条最右链和第二棵树的最左链上的节点都是复制过了的，而在$merge$的时候显然也只会用到第一棵树的最右链和第二棵树的最左链，所以在$merge$的过程中不需要复制节点。

``` cpp
int tx,ta,tb;
void merge(int &r,int a,int b)
{
	if(!a||!b)
	{
		if(a) ta^=rev[a],rev[r=a]=tx^ta;
		else if(b) tb^=rev[b],rev[r=b]=tx^tb;
		else r=0;
		return;
	}
	if(key[a]<=key[b])
	{
		ta^=rev[a],rev[r=a]=tx^ta,tx=ta;
		merge(ch[r][tx^1],ch[a][ta^1],b);
	}
	else
	{
		tb^=rev[b],rev[r=b]=tx^tb,tx=tb;
		merge(ch[r][tx],a,ch[b][tb]);
	}
	push_up(r);
}
```

下面是我巨丑无比的完整代码：
``` cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#define ll long long
#define uint unsigned int
#define done tx=ta=tb=0
using namespace std;
template <class T>
inline void read(T &x)
{
    x=0; char c=getchar();  int f=1;
    while(!isdigit(c)){if(c=='-')f=-1; c=getchar();}
    while(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;
}
uint seed=19260817;
uint Rand()
{
	seed^=seed<<13,seed^=seed>>17,seed^=seed<<5;
	return seed;
}
const int N=2e5+10,M=N*66;
int rt[N],ch[M][2],val[M],rev[M],sz[M],ncnt;
ll sum[M];
uint key[M];
void push_up(int x){sz[x]=sz[ch[x][0]]+sz[ch[x][1]]+1,sum[x]=sum[ch[x][0]]+sum[ch[x][1]]+val[x];}
int stk[M],top;
int make(int v)
{
	int u=top?stk[top--]:++ncnt;
	ch[u][0]=ch[u][1]=rev[u]=0;
	val[u]=sum[u]=v,key[u]=Rand(),sz[u]=1;
	return u;
}
int cpy(int c)
{
	int u=top?stk[top--]:++ncnt;
	ch[u][0]=ch[c][0],ch[u][1]=ch[c][1],rev[u]=rev[c];
	val[u]=val[c],sum[u]=sum[c],key[u]=key[c],sz[u]=sz[c];
	return u;
}
int tx,ta,tb;
void merge(int &r,int a,int b)
{
	if(!a||!b)
	{
		if(a) ta^=rev[a],rev[r=a]=tx^ta;
		else if(b) tb^=rev[b],rev[r=b]=tx^tb;
		else r=0;
		return;
	}
	if(key[a]<=key[b])
	{
		ta^=rev[a],rev[r=a]=tx^ta,tx=ta;
		merge(ch[r][tx^1],ch[a][ta^1],b);
	}
	else
	{
		tb^=rev[b],rev[r=b]=tx^tb,tx=tb;
		merge(ch[r][tx],a,ch[b][tb]);
	}
	push_up(r);
}
void split(int x,int k,int &a,int &b)
{
	if(!x){a=b=0; return;} tx^=rev[x];
	if(sz[ch[x][tx]]>=k)
	{
		rev[b=cpy(x)]=tb^tx,tb=tx;
		split(ch[x][tx],k,a,ch[b][tb]),push_up(b);
	}
	else
	{
		rev[a=cpy(x)]=ta^tx,ta=tx;
		split(ch[x][tx^1],k-sz[ch[x][tx]]-1,ch[a][ta^1],b),push_up(a);
	}
}

void insert(int r1,int &r2,int p,int v)
{
	int x,y; done; split(r1,p,x,y);
	done; merge(r2,x,make(v)); done; merge(r2,r2,y);
}
void del(int r1,int &r2,int p)
{
	int x,y,z; done; split(r1,p,x,y); done; split(x,p-1,x,z);
	stk[++top]=z; done; merge(r2,x,y);
}
void Reverse(int r1,int &r2,int l,int r)
{
	int x,y,z; done; split(r1,l-1,x,y); done; split(y,r-l+1,y,z);
	rev[y]^=1; done; merge(r2,x,y); done; merge(r2,r2,z);
}
ll query(int r1,int l,int r)
{
	int x,y,z; done; split(r1,l-1,x,y); done; split(y,r-l+1,y,z);
	return sum[y];
}
int main()
{
	int q,v,op,x,l,r; ll lst=0; read(q);
	for(int i=1;i<=q;++i)
	{
		read(v),read(op);
		if(op==1)
		{
			read(l),read(x); l^=lst,x^=lst;
			insert(rt[v],rt[i],l,x);
		}
		else if(op==2)
		{
			read(l); l^=lst;
			del(rt[v],rt[i],l);
		}
		else if(op==3)
		{
			read(l),read(r); l^=lst,r^=lst;
			Reverse(rt[v],rt[i],l,r);
		}
		else
		{
			read(l),read(r); l^=lst,r^=lst;
			printf("%lld\n",lst=query(rt[v],l,r)),rt[i]=rt[v];
		}

	}
	return 0;
}
```

---

## 作者：Jμdge (赞：2)

板子题啦，这玩意儿只能 FHQ treap 做


（就是好奇为什么空间要开那么大，别的题解都没解释过，我算出来的话是 log 级别的啊...哪位大佬能回答一下啊QWQ）


总体来讲不是非常的 nan ，其实就是江 可持久化线段树 和 FHQ treap 两道紫题并在了一起变成了黑题，~~假的【雾~~

但可持久化确实大多是用了可持久化线段树的思路，考虑新建节点，保留历史版本什么的...

于是就这么愉快的 A 了此题...

------

聊太多了 QWQ

首先你得 A 了文艺平衡树（用 FHQ treap A 的）

其次你得学会可持久化的思想

其实别的都是板子，就是 split 的时候比较特殊罢了，还有下穿标记的时候也是，需要新建节点然后连到父节点那里


```
//by Judge
#include<cstdio>
#include<iostream>
#define ll long long
using namespace std;
const int N=2e5;
const int M=(N<<7)+3; //注意看
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline ll read(){ ll x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
inline void print(ll x,char chr='\n'){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]=chr;
} int n,op,v,l,r,a,b,c; ll ans;
namespace FHQTreap{ arr rt,pos,siz,fl;
	ll w[M],sum[M]; int now,tot,son[M][2];
	inline int Rand() { static int seed=703;return seed=int(seed*48271LL%(~0u>>1));}
	inline int newnode(ll x=0){return w[++tot]=x,sum[tot]=x,pos[tot]=Rand(),siz[tot]=1,tot;}
	inline int copy(int x){ int y=newnode(); //复制节点最好单独来一个小函数...然后里面要 copy 的别忘 copy 全，我被这玩意儿坑了两次
		son[y][0]=son[x][0],son[y][1]=son[x][1],siz[y]=siz[x];
		w[y]=w[x],sum[y]=sum[x],fl[y]=fl[x]; return y;
	}
	inline void pushup(int x){
		siz[x]=siz[son[x][0]]+siz[son[x][1]]+1;
		sum[x]=sum[son[x][0]]+sum[son[x][1]]+w[x];
	}
	inline void pushdown(int x){ if(!fl[x]) return;  //注意看+1
		if(son[x][0]) son[x][0]=copy(son[x][0]);
		if(son[x][1]) son[x][1]=copy(son[x][1]);
		fl[son[x][0]]^=1,fl[son[x][1]]^=1;
		swap(son[x][0],son[x][1]),fl[x]=0;
	}
	int merge(int x,int y){ if(!x||!y) return x|y; //merge 好像没什么特别的
		if(pos[x]<pos[y]) return pushdown(x),son[x][1]=merge(son[x][1],y),pushup(x),x;
		else return pushdown(y),son[y][0]=merge(x,son[y][0]),pushup(y),y;
	}
	void split(int rt,int k,int& x,int& y){ //注意看+1
    	if(!rt) return x=y=0,void(); pushdown(rt);
		if(siz[son[rt][0]]>=k) y=copy(rt),split(son[y][0],k,x,son[y][0]),pushup(y); //这里是copy了之前的节点然后直接拿他做下去了
		else x=copy(rt),split(son[x][1],k-siz[son[x][0]]-1,son[x][1],y),pushup(x);  //同上
	}
} using namespace FHQTreap;
int main(){ //主函数照着题目打就好了
	for(n=read();n;--n){ v=read(),op=read();
		if(op==1){
			l=read()^ans,r=read()^ans,split(rt[v],l,a,b);
			rt[++now]=merge(a,merge(newnode(r),b));
		} else if(op==2){
			l=read()^ans,split(rt[v],l-1,a,b);
			split(b,1,b,c),rt[++now]=merge(a,c);
		} else if(op==3){ l=read()^ans,r=read()^ans;
			split(rt[v],r,a,c),split(a,l-1,a,b);
			fl[b]^=1,rt[++now]=merge(a,merge(b,c));
		} else if(op==4){ l=read()^ans,r=read()^ans;
			split(rt[v],r,a,c),split(a,l-1,a,b);
			print(ans=sum[b]),rt[++now]=merge(a,merge(b,c));
		}
	} return Ot(),0;
}
```




---

## 作者：OIer_ACMer (赞：1)

~~模板题居然被我捡漏了？！~~

------------
注：本题解代码似乎与[大佬题解](https://www.luogu.com.cn/blog/105496/solution-p5055)撞山，在此做出声明。

------------
## 警钟敲烂：
不要掉以轻心，这道题其实~~很毒瘤~~！不要以为学了 FHQ 就万事大吉，其实这才是开始！！！

------------
## 大致思路：
这道题是一道可持久化文艺平衡树，文艺二字你可以视而不见，但平衡树三字必须知道，因为这道题如果你连平衡树都不会写的话就赶快退出这道题好好上课去吧。

首先，我们要知道 FHQ 平衡树的两大操作：**分裂**与**合并**，由这两个操作改变树的形态与大小。这两种操作由于 FHQ 算法的优秀性对整体的改变幅度较小（因为 FHQ 算法属于一种**动态的查找树算法，在查找与拆分时移动的节点十分得少**，同时，FHQ 算法**可以将省下的空间再次利用**，这会在后文提到。所以，这是种十分优秀的算法），所以很适合用来做这一类问题。

既然 FHQ 很适合用来做这一类问题，我们不妨来思考一下怎么实现最重要的一步：保存历史记录。我们先来思考一下这两种操作怎么写。我们用 $siz$ 在分的时候一般直接让当前节点的左/右孩子直接进行递归。**然而我们在可持久化的时候必须要将要求的历史版本的树全复制下来**，自然我们就需要一个 $\operatorname{ctrlc}$ 函数来完成这个步骤，我们递归的时候**直接改掉这颗克隆节点的左右孩子**就好了。

至于 $\operatorname{merge}$ 函数由于我们在 $\operatorname{split}$ 的时候已经克隆过了（因为我们**在拆分的同时需要克隆一份备案**，**不然的话实现可持久化就是不可能的**），备案后，我们只需要安心大胆的合并即可。还有一个关于空间的问题。当我们每次删除一个节点时，这个位置的资源就空了出来。如果不使用的话就实在太浪费了。我们用一个数组 $root$ 来将这这些悲伤出的节点的根节点给储存下来（就相当于前文的备案），以便后面翻转的找原先根节点所耗时间减少。

------------
## 代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2e5 + 5;
inline int read()
{
    register int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
struct node
{
    int lson, rson, val, pri, siz, lazy;
    int sum;
} tree[N << 7];
int cnt = 0;
int xinjian(int x)
{
    tree[++cnt].siz = 1;
    tree[cnt].lson = tree[cnt].rson = 0;
    tree[cnt].val = x;
    tree[cnt].sum = x;
    tree[cnt].pri = rand();
    tree[cnt].lazy = 0;
    return cnt;
}
int ctrl_c(int u)
{
    int ret = xinjian(0);
    tree[ret] = tree[u];
    return ret;
}
void updata(int u)
{
    tree[u].siz = tree[tree[u].lson].siz + tree[tree[u].rson].siz + 1;
    tree[u].sum = tree[tree[u].lson].sum + tree[tree[u].rson].sum + tree[u].val;
}
void push_down(int u)
{
    if (!tree[u].lazy)
    {
        return;
    }
    if (tree[u].lson != 0)
    {
        tree[u].lson = ctrl_c(tree[u].lson);
    }
    if (tree[u].rson != 0)
    {
        tree[u].rson = ctrl_c(tree[u].rson);
    }
    swap(tree[u].lson, tree[u].rson);
    tree[tree[u].lson].lazy ^= 1;
    tree[tree[u].rson].lazy ^= 1;
    tree[u].lazy = 0;
}
void split(int u, int x, int &l, int &r)
{
    if (u == 0)
    {
        l = r = 0;
        return;
    }
    push_down(u);
    if (tree[tree[u].lson].siz + 1 <= x)
    {
        l = ctrl_c(u);
        split(tree[l].rson, x - tree[tree[u].lson].siz - 1, tree[l].rson, r);
        updata(l);
    }
    else
    {
        r = ctrl_c(u);
        split(tree[r].lson, x, l, tree[r].lson);
        updata(r);
    }
}
int merge(int l, int r)
{
    if (l == 0 || r == 0)
    {
        return l + r;
    }
    push_down(l);
    push_down(r);
    if (tree[l].pri > tree[r].pri)
    {
        tree[l].rson = merge(tree[l].rson, r);
        updata(l);
        return l;
    }
    else
    {
        tree[r].lson = merge(l, tree[r].lson);
        updata(r);
        return r;
    }
}
int root[N];
int ver = 0, l, p, r, x, y, n;
signed main()
{
    srand(time(0));
    int lastans = 0;
    n = read();
    while (n--)
    {
        int v, op;
        v = read();
        op = read();
        if (op == 1)
        {
            x = read();
            y = read();
            x ^= lastans;
            y ^= lastans;
            split(root[v], x, l, p);
            root[++ver] = merge(merge(l, xinjian(y)), p);
        }
        if (op == 2)
        {
            x = read();
            x ^= lastans;
            split(root[v], x, l, r);
            split(l, x - 1, l, p);
            root[++ver] = merge(l, r);
        }
        if (op == 3)
        {
            x = read();
            y = read();
            x ^= lastans;
            y ^= lastans;
            split(root[v], y, l, r);
            split(l, x - 1, l, p);
            tree[p].lazy ^= 1;
            root[++ver] = merge(merge(l, p), r);
        }
        if (op == 4)
        {
            x = read();
            y = read();
            x ^= lastans;
            y ^= lastans;
            split(root[v], y, l, r);
            split(l, x - 1, l, p);
            lastans = tree[p].sum;
            cout << lastans << endl;
            root[++ver] = merge(merge(l, p), r);
        }
    }
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/121834498)


---

## 作者：StillEmpty (赞：1)

前置知识：[P3391 【模板】文艺平衡树](https://www.luogu.com.cn/problem/P3391)`&&(`[P3919 【模板】可持久化线段树](https://www.luogu.com.cn/problem/P3919)`||`[P3835 【模板】可持久化平衡树](https://www.luogu.com.cn/problem/P3835)`)`

增加？删除？翻转？询问？还可持久化？怎么办？

> 让我思考一下 `root[i]` 和 `root[i - 1]` 的子节点们有哪些互相重叠……呜呜呜，太复杂了，想不出来。

显然，人脑的性能不足以想象这么一个复杂的数据结构。不过呢，我们可以将问题分成几部分，**只要能满足各部分的性质，我们就做出来了**。

首先，要**保证以 `root[i]` 为根的树满足treap性质**，这样才能以 $O(\log{n})$ 的时间复杂度将树 `split` 和 `merge`。这显然是普通平衡树的问题。注意，我们不管它的子节点是哪来的，是已有的还是新生成的，只要满足treap性质第一步就完成了。

其次，要可持久化。可持久化其实就是要**保证旧版本的树没有被修改**。我们不需要想象出这个数据结构是咋操作的，只需要满足这个性质就行了。于是，在任何时候，我们需要更改旧节点时，我们将要更改的节点复制一下，更改复制后的节点。这要就满足可持久化的性质了。

然后，我们要打一个翻转懒标记 `rev`，**保证 `rev = true` 时，整棵树被翻转过**。我们依旧不管咋操作的，当我们要访问节点 `o` 的子节点时， 我们就下传懒标记。

这样，所有性质就都满足啦！！！正确性和时间复杂度都保证了！！！

参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

struct node {
	bool rev;
	int val; long long sum; int size, rnd;
	node *lson, *rson;
};
struct node_pair {node *le, *gt;};

const int N = 2e5;
int n; long long lastans;
node *null = new node{false, 0, 0, 0, 0, nullptr, nullptr}, *root[N + 1];

node *copy(node *o) {
	return new node{o->rev, o->val, o->sum, o->size, o->rnd, o->lson, o->rson};
}
inline void update(node *o) {
	o->size = o->lson->size + o->rson->size + 1;
	o->sum = o->lson->sum + o->rson->sum + o->val;
}
inline void push_down(node *o) {
	if(o->rev) {
		o->rev = false;
		swap(o->lson, o->rson);
		if(o->lson != null) {o->lson = copy(o->lson); o->lson->rev ^= true;}
		if(o->rson != null) {o->rson = copy(o->rson); o->rson->rev ^= true;}
	}
}
node_pair split(node *o, int k) {
	if(o == null) return {null, null};
	node *p = copy(o); push_down(p);
	if(k <= p->lson->size) {
		node_pair get = split(p->lson, k);
		p->lson = get.gt; update(p);
		return {get.le, p};
	}
	else {
		node_pair get = split(p->rson, k - p->lson->size - 1);
		p->rson = get.le; update(p);
		return {p, get.gt};
	}
}
node *merge(node *o, node *p) {
	if(o == null) return p;
	if(p == null) return o;
	if(o->rnd < p->rnd) {
		node *q = copy(o); push_down(q);
		q->rson = merge(q->rson, p);
		update(q); return q;
	}
	else {
		node *q = copy(p); push_down(q);
		q->lson = merge(o, q->lson);
		update(q); return q;
	}
}

int main() {
	// freopen("in", "r", stdin); freopen("out", "w", stdout);
	srand(time(nullptr));
	scanf("%d", &n);
	root[0] = null;
	for(int i = 1; i <= n; i++) {
		int v, opt;
		scanf("%d%d", &v, &opt);
		if(opt == 1) {
			long long p, x; scanf("%lld%lld", &p, &x); p ^= lastans; x ^= lastans;
			node_pair get = split(root[v], p);
			root[i] = merge(get.le, merge(new node{false, x, x, 1, rand(), null, null}, get.gt));
			continue;
		}
		if(opt == 2) {
			long long p; scanf("%lld", &p); p ^= lastans;
			node_pair get1 = split(root[v], p - 1); node_pair get2 = split(get1.gt, 1);
			root[i] = merge(get1.le, get2.gt);
			continue;
		}
		if(opt == 3) {
			long long l, r; scanf("%lld%lld", &l, &r); l ^= lastans; r ^= lastans;
			node_pair get1 = split(root[v], l - 1); node_pair get2 = split(get1.gt, r - l + 1);
			get2.le->rev ^= true;
			root[i] = merge(get1.le, merge(get2.le, get2.gt));
			continue;
		}
		if(opt == 4) {
			root[i] = root[v];
			long long l, r; scanf("%d%d", &l, &r); l ^= lastans; r ^= lastans;
			node_pair get1 = split(root[v], l - 1); node_pair get2 = split(get1.gt, r - l + 1);
			printf("%lld\n", lastans = get2.le->sum);
		}
	}
	return 0;
}
```

---

## 作者：QCurium (赞：1)

[原题链接](https://www.luogu.com.cn/problem/P5055)

[视频讲解（顺便点个赞吧](https://www.bilibili.com/video/BV1Tj411C7LP/?vd_source=a8f2ca9bd086cb49d933fb93cb7409c0)

## 提醒

当你有如下情况：

- $50$ 分，WA on $7\sim16$。
- $34$ 分，MLE RE on $7\sim20$。

请看[此帖](https://www.luogu.com.cn/discuss/690175)。

## 题意

写一种数据结构，来维护一个序列，其中需要提供以下操作：

1. 在第 $p$ 个数后插入数 $x$ 。
2. 删除第 $p$ 个数。
3. 翻转区间 $[l,r]$。
4. 查询区间 $[l,r]$ 中所有数的和。

## 题目分析

首先，你需要掌握以下知识点：

- [文艺平衡树](https://www.luogu.com.cn/blog/qcm-home/fhq-treap)。

- [可持久化普通平衡树](https://www.luogu.com.cn/blog/qcm-home/ke-chi-jiu-hua-pu-tong-ping-heng-shu)。

掌握了以上两个知识点，就可以不费力的做出这道题了。

同可持久化普通平衡树一样，在进行 `split` 操作时，需要动态开点，将分出来的点存在新开的点中。而 `merge` 就不用再动态开点了，因为每次的 `merge` 每次都对应了一个 `split` ，新的版本在 `split` 时就已经开好了，所以就不用在动态开点了。

`push_up` 就和普通平衡树一样，但是 `push_down` 不一样，必须是哪个儿子节点有东西，开哪个儿子节点，空点是不可以开的。

其余的函数就和可持久化普通平衡树一样了，只需要传参的时候加上要求版本的 `root` 就可以了。

## Code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=2e5+5;
struct node{
	int l,r;
	int val,key,sz;
	ll sum;
	bool tag;
}a[N<<6];
int n,m,cnt=0,root[N<<1];
ll lastans=0;
int nw(ll val){
	cnt++;
	a[cnt].val=val;
	a[cnt].sum=val;
	a[cnt].key=rand();
	a[cnt].sz=1;
	return cnt;
}
void push_up(int aa){
	a[aa].sz=a[a[aa].l].sz+a[a[aa].r].sz+1;
	a[aa].sum=a[a[aa].l].sum+a[a[aa].r].sum+a[aa].val;
	return ;
}
void push_down(int aa){
	if(a[aa].tag){
		if(a[aa].l){
			cnt++;
			a[cnt]=a[a[aa].l];
			a[aa].l=cnt;
			a[a[aa].l].tag^=1;
		}
		if(a[aa].r){
			cnt++;
			a[cnt]=a[a[aa].r];
			a[aa].r=cnt;
			a[a[aa].r].tag^=1;
		}
		a[aa].tag=0;
		swap(a[aa].l,a[aa].r);
	}
	return ;
}
void split(int aa,int siz,int &x,int &y){
	if(!aa)
		x=y=0;
	else{
		push_down(aa);
		cnt++;
		a[cnt]=a[aa];
		if(a[a[aa].l].sz<siz){
			x=cnt;
			split(a[x].r,siz-a[a[x].l].sz-1,a[x].r,y);
			push_up(x);
		}
		else{
			y=cnt;
			split(a[y].l,siz,x,a[y].l);
			push_up(y);
		}
	}
}
int merge(int x,int y){
	if(!x||!y)
		return x+y;
	if(a[x].key>a[y].key){
		push_down(x);
		a[x].r=merge(a[x].r,y);
		push_up(x);
		return x;
	}
	else{
		push_down(y);
		a[y].l=merge(x,a[y].l);
		push_up(y);
		return y;
	}
}
int x,y,z;
void ins(int &rot,int rk,ll val){
	y=nw(val);
	split(rot,rk,x,z);
	rot=merge(merge(x,y),z);
}
void del(int &rot,int rk){
	split(rot,rk,x,z);
	split(x,rk-1,x,y);
	rot=merge(x,z);
}
void rev(int &rot,int l,int r){
	split(rot,r,x,z);
	split(x,l-1,x,y);
	a[y].tag^=1;
	rot=merge(merge(x,y),z);
}
void qiuhe(int &rot,int l,int r){
	split(rot,r,x,z);
	split(x,l-1,x,y);
	cout<<a[y].sum<<'\n';
	lastans=a[y].sum;
	rot=merge(merge(x,y),z);
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		ll v,op,x,y;
		cin>>v>>op;
		root[i]=root[v];
		if(op==1){
			cin>>x>>y;
			x^=lastans;
			y^=lastans;
			ins(root[i],x,y);
		}
		if(op==2){
			cin>>x;
			x^=lastans;
			del(root[i],x);
		}
		if(op==3){
			cin>>x>>y;
			x^=lastans;
			y^=lastans;
			rev(root[i],x,y);
		}
		if(op==4){
			cin>>x>>y;
			x^=lastans;
			y^=lastans;
			qiuhe(root[i],x,y);
		}
	}
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/125233161)

###### 第一篇紫模板题解

---


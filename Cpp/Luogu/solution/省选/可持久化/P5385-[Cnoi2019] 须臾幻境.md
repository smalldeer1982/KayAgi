# [Cnoi2019] 须臾幻境

## 题目背景

这曾今有一个凄婉哀伤的故事，但是被出题人删档弄丢了。

## 题目描述

初始时，你有一个 $n$ 个结点 $m$ 条边的无向图 $G$，结点的编号依次为 $1,2,\cdots,n$。

现在将 $G$ 中所有 $m$ 条边依次编号，排成一个长度为 $m$ 边序列 $E=(e_1,e_2,\cdots,e_m)$，其中 $e_i=(u_i,v_i)$ 是一个二元组，表示一个连接 $u_i$ 与 $v_i$ 的无向边。

然后 Cirno 会给你 $q$ 个询问二元组 $( l, r )$，表示询问「如果只保留 $e_l,e_{l+1},\cdots e_r$ 这个区间内的边的话，图中的联通块的个数」。

时间紧急，你需要设计尽可能快的算法解决 Cirno 的询问，而且由于在某些情况下询问之间也许互相依赖，你的程序需要保持在线运行。

## 说明/提示

**样例解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/k2c1fizv.png)

**数据范围与约定**

对于 $100\%$ 的数据保证，$1\le |V| \le 10^5, 1\le |E| \le 2\times 10^5, 1\le q \le 10^5, t \in \{0,1\}$。**注意数据可能包含重边和自环**。

**子任务**

Subtask1（$15$ points）：$|V|, |E|, q \le 5000$；

Subtask2（$25$ points）：$t = 0$；

Subtask3（$20$ points）：$|V| \le 10^4, |E|, q \le 3\times 10^4$

Subtask3（$40$ points）：无特殊限制。

## 样例 #1

### 输入

```
5 5 4 0
1 2
3 4
2 3
4 5
1 5
1 3
2 5
3 4
5 5```

### 输出

```
2
1
3
4```

## 样例 #2

### 输入

```
见附件中 sample2.in```

### 输出

```
见附件中 sample2.out```

# 题解

## 作者：lhm_ (赞：10)

首先我们知道 $n$ 个点的树有 $n-1$ 条边，因此对于森林来说，其点数减边数即为树的个数。那么对于普通的图，求出其任意一个生成树森林，森林中树的个数即为原图中连通块的个数，也就是点数减边数。

因此问题就转化为了如何快速求出一个图的生成树森林的边数。

考虑用 $LCT$ 来维护原图的一个生成树森林。按顺序加边，当发现两端点已经连通，要形成环时，就删去环上最早加入的一条边。同时用主席树来维护每条边是否在当前的生成树森林中出现。

询问时在 $r$ 所对应的主席树上查询区间 $[l,r]$ 中有几条边存在，存在的边数即为对应的生成树森林的边数，用 $n$ 减去边数即为答案。

因为 $LCT$ 维护的是以时间为边权的最大生成树森林，所以每条边都尽可能的选用出现时间晚的，这就使得 $r$ 所对应的主席树中区间 $[l,r]$ 中边的出现是最多的，所以就保证了正确性。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 400010
#define maxm 12000010
#define inf 1000000000
#define mid ((l+r)>>1)
using namespace std;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int n,m,q,t,ans,tree_cnt;
int ls[maxm],rs[maxm],cnt[maxm],rt[maxn];
int fa[maxn],ch[maxn][2],rev[maxn],val[maxn],mi[maxn];
struct edge
{
    int x,y;
}e[maxn];
void get(int &l,int &r)
{
    if(t) l=(l+ans)%m+1,r=(r+ans)%m+1;
    if(l>r) swap(l,r);
}
bool check(int x)
{
    return ch[fa[x]][1]==x;
}
bool notroot(int x)
{
    return ch[fa[x]][0]==x||ch[fa[x]][1]==x;
}
void pushup(int x)
{
    mi[x]=val[x];
    mi[x]=min(mi[x],min(mi[ch[x][0]],mi[ch[x][1]]));
}
void pushrev(int x)
{
    rev[x]^=1,swap(ch[x][0],ch[x][1]);
}
void pushdown(int x)
{
    if(!rev[x]) return;
    pushrev(ch[x][0]),pushrev(ch[x][1]),rev[x]=0;
}
void rotate(int x)
{
    int y=fa[x],z=fa[y],k=check(x),w=ch[x][k^1];
    if(notroot(y)) ch[z][check(y)]=x;
    ch[x][k^1]=y,ch[y][k]=w;
    if(w) fa[w]=y;
    fa[x]=z,fa[y]=x;
    pushup(y),pushup(x);
}
void all(int x)
{
    if(notroot(x)) all(fa[x]);
    pushdown(x);
}
void splay(int x)
{
    all(x);
    for(int y;notroot(x);rotate(x))
        if(notroot(y=fa[x]))
            rotate(check(x)^check(y)?x:y);
    pushup(x);
}
void access(int x)
{
    for(int y=0;x;y=x,x=fa[x])
        splay(x),ch[x][1]=y,pushup(x);
}
void makeroot(int x)
{
    access(x),splay(x),pushrev(x);
}
void split(int x,int y)
{
    makeroot(x),access(y),splay(y);
}
int findroot(int x)
{
    access(x),splay(x);
    while(ch[x][0]) x=ch[x][0];
    splay(x);
    return x;
}
void link(int x,int y)
{
	split(x,y),fa[x]=y;
}
void cut(int x,int y)
{
	split(x,y),fa[x]=ch[y][0]=0;
}
int ask(int x,int y)
{
    split(x,y);
    return mi[y];
}
void modify(int l,int r,int pos,int v,int &cur)
{
    int x=++tree_cnt;
    ls[x]=ls[cur],rs[x]=rs[cur],cnt[x]=cnt[cur]+v,cur=x;
    if(l==r) return;
    if(pos<=mid) modify(l,mid,pos,v,ls[cur]);
    else modify(mid+1,r,pos,v,rs[cur]);
}
int query(int L,int R,int l,int r,int cur)
{
    if(L<=l&&R>=r) return cnt[cur];
    int v=0;
    if(L<=mid) v+=query(L,R,l,mid,ls[cur]);
    if(R>mid) v+=query(L,R,mid+1,r,rs[cur]);
    return v;
}
int main()
{
    read(n),read(m),read(q),read(t);
    for(int i=0;i<=n;++i) val[i]=mi[i]=inf;   
    for(int i=1;i<=m;++i) read(e[i].x),read(e[i].y),val[i+n]=mi[i+n]=i;
    for(int i=1;i<=m;++i)
    {
        int x=e[i].x,y=e[i].y;
        rt[i]=rt[i-1];
        if(x==y) continue;
        modify(1,m,i,1,rt[i]);
        if(findroot(x)==findroot(y))
        {
            int p=ask(x,y);
            cut(e[p].x,p+n),cut(e[p].y,p+n);
            modify(1,m,p,-1,rt[i]);
        }
        link(x,i+n),link(y,i+n);
    }
    while(q--)
    {
        int l,r;
        read(l),read(r),get(l,r);
        printf("%d\n",ans=n-query(l,r,1,m,rt[r]));
    }
    return 0;
}
```

---

## 作者：NaCly_Fish (赞：9)

这其实是一道[BZOJ原题](https://www.lydsy.com/JudgeOnline/problem.php?id=3514)。。  

### 题解
 
我们设第 $i$ 条边的权值为 $i$，用 $\texttt{LCT}$ 维护最大生成树。  

按顺序加入边，如果未连通直接连上去；已经连通就把原路径上权值最小的边断掉，然后再把当前边加上去。

要注意的是 $\texttt{LCT}$ 不便于维护边权，于是每条边建一个虚点，两点之间连边的时候，分别连到虚点上即可。  

在上述过程中，对于每一条加入的边 $i$，都要记录一下这时被删除的边 $a_i$，如果它的加入没有删除边，则 $a_i=0$。  

还有个坑点就是自环，对于有自环的情况，这条边是没有用的，所以将 $a_i$ 设为 $m+1$ 就好了。  

根据 $a$ 数组的定义，我们可以知道查询区间 $[l,r]$ 时，对于 $a_i<l$ 的一条边，它会连接两个连通块，产生 $-1$ 的贡献。  

所以每次查询的答案就是   
$$\large n-\sum\limits_{i=l}^r[a_i<l]$$  

后面那个求和，实际上求的就是 $[l,r]$ 中小于 $l$ 的数个数。  

这个是可以用主席树来维护的，但是我比较菜，就写了分块，空间复杂度为 $\Theta(m\sqrt m)$，时间复杂度是 $\Theta(m \log n+q \sqrt m)$的。   

效率还还可以，最慢的点也就 $1300\text{ms}$。

代码：  
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
#define N 300003
#define ll long long
#define reg register
#define ls son[u][0]
#define rs son[u][1]
#define inf 0x3f3f3f3f
using namespace std;

struct edge{
    int u,v;
    edge(int u=0,int v=0):u(u),v(v){}
}e[N];

int f[N],a[N],uf[N],be[N],bl[N],br[N];
int cnt[451][200004];
int n,m,q,t,unit;

inline void read(int &x);
void print(int x);

struct Link_Cut_Tree{ //LCT板子
    int son[N][2],fa[N],st[N];
    int rev[N],minn[N];

    inline bool notroot(int u){
        return son[fa[u]][0]==u||son[fa[u]][1]==u;
    }

    inline void pushup(int u){ // 维护链上权值最小节点节点的*位置*
        minn[u] = u;
        if(ls&&a[minn[ls]]<a[minn[u]]) minn[u] = minn[ls];
        if(rs&&a[minn[rs]]<a[minn[u]]) minn[u] = minn[rs]; 
    }

    inline void pushr(int u){
        swap(ls,rs);
        rev[u] ^= 1;
    }

    inline void pushdown(int u){
        if(!rev[u]) return;
        if(ls) pushr(ls);
        if(rs) pushr(rs);
        rev[u] = 0;
    }

    inline void rotate(int x){
        int y = fa[x],z = fa[y];
        int k = son[y][1]==x,w = son[x][k^1];
        if(notroot(y)) son[z][son[z][1]==y] = x;
        son[x][k^1] = y;
        son[y][k] = w;
        if(w) fa[w] = y;
        fa[y] = x,fa[x] = z;
        pushup(y);
    }

    inline void splay(int x){
        int y = x,z = 0;
        st[++z] = y;
        while(notroot(y)) st[++z] = y = fa[y];
        while(z) pushdown(st[z--]);
        while(notroot(x)){
            y = fa[x],z = fa[y];
            if(notroot(y)){
                if((son[z][1]==y)==(son[y][1]==x)) rotate(y);
                else rotate(x);
            }
            rotate(x);
        }
        pushup(x);
    }

    inline void access(int u){
        for(reg int y=0;u;u=fa[u]){
            splay(u);
            rs = y;
            pushup(u);
            y = u;
        }
    }

    inline void makeroot(int u){
        access(u),splay(u);
        pushr(u);
    }

    inline void split(int u,int v){
        makeroot(u);
        access(v),splay(v);
    }

    inline void link(int u,int v){
        makeroot(u);
        fa[u] = v;
    }

    inline void cut(int u,int v){
        split(u,v);
        son[v][0] = fa[u] = 0;
        pushup(v);
    }

    inline int query(int u,int v){
        split(u,v);
        return minn[v];
    }
}T;

inline int find(int x){
    while(x!=uf[x]) x = uf[x] = uf[uf[x]];
    return x;
}

inline int query(int l,int r,int k){ //分块查询[l,r]中小于k的数个数
    if(k<1) return 0;
    int res = 0;
    if(be[r]-be[l]<2){
        for(reg int i=l;i<=r;++i) res += f[i]<k;
        return res;
    }
    for(reg int i=l;i<=br[l];++i) res += f[i]<k;
    for(reg int i=be[l]+1;i<be[r];++i) res += cnt[i][k-1];
    for(reg int i=bl[r];i<=r;++i) res += f[i]<k;
    return res;
}

int main(){
    int u,v,w,l,r,key = 0;
    read(n),read(m),read(q),read(t);
    for(reg int i=1;i<=n;++i) a[i] = inf;
    for(reg int i=1;i<=m;++i) a[i+n] = i;
    for(reg int i=1;i<=n+m;++i) uf[i] = T.minn[i] = i;
    for(reg int i=1;i<=m;++i){
        read(u),read(v);
        if(u==v){
            f[i] = m+2;
            continue;
        }
        e[i] = edge(u,v);
        if(find(u)==find(v)){
            w = T.query(u,v);
            T.cut(w,e[w-n].u); //断掉w这个虚点所对应的边
            T.cut(w,e[w-n].v);
            f[i] = w-n;
        }else uf[find(u)] = find(v);
        T.link(u,n+i),T.link(v,n+i);
    }
    unit = sqrt(m)+1;
    for(reg int i=1;i<=m;++i){
        be[i] = (i-1)/unit+1;
        cnt[be[i]][f[i]]++;
        if(be[i]==be[i-1]) bl[i] = bl[i-1]; //维护每个点所在块的最左端点
        else bl[i] = i;
    }
    for(reg int i=m;i>=1;--i){
        if(be[i]==be[i+1]) br[i] = br[i+1]; //维护每个点所在块的最右端点
        else br[i] = i;
    }
    w = m/unit+1;
    for(reg int i=1;i<=w;++i){ //值域分块前缀和
        for(reg int j=1;j<=m;++j)
            cnt[i][j] += cnt[i][j-1];
    }
    while(q--){
        read(l),read(r);
        if(t==1){
            l = (l+key)%m+1;
            r = (r+key)%m+1;
        }
        if(l>r) swap(l,r);
        key = n-query(l,r,l);   
        print(key),putchar('\n');
    }
    return 0;
}

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

void print(int x){
    if(x>9) print(x/10);
    putchar(x%10+'0');
}
```

---

## 作者：waaadreamer (赞：5)

注意到连通块个数可以转化为计算生成森林中的边数，不妨考虑每条边的贡献。

令每条边的边权为其编号，则在询问 $[l,r]$ 中，$(u,v)$ 产生贡献当且仅当 $[1,r]$ 的最大生成森林中，$u$ 到 $v$ 要么不连通，要么路径上存在权值 $<l$ 的边。

于是考虑从头扫，用 LCT 动态维护最大生成森林，就可以计算出对于每条边，它产生贡献需要的区间左端点至少是多少。这样我们对于一条边 $i$，就可以表示成一个二元组 $(i,d_i)$，也就是说 $i$ 产生贡献，区间左端点至少为 $d_i$。

由于强制在线，用主席树二维数点即可。复杂度 $O(n \log n)$。

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
typedef pair<int, int> P;

const int MAXM = 200005;
struct LinkCutTree {
    static const int MAXM = 300005;
    int rev[MAXM], son[MAXM][2], fa[MAXM], mn[MAXM], val[MAXM], sta[MAXM];
    LinkCutTree() { mn[0] = INT_MAX; }
    bool isroot(int x) { return !fa[x] || (son[fa[x]][0] != x && son[fa[x]][1] != x); }
    void pushup(int x) { mn[x] = min(mn[son[x][0]], min(val[x], mn[son[x][1]])); }
    void rotate(int x){
        int y = fa[x], f = fa[y], w = son[y][0] == x;
        if(!isroot(y)) son[f][son[f][1] == y] = x;
        fa[x] = f, fa[y] = x;
        if(son[x][w]) fa[son[x][w]] = y;
        son[y][!w] = son[x][w], son[x][w] = y;
        pushup(y);
    }
    void pushdown(int x) {
        if (!rev[x]) return;
        rev[son[x][0]] ^= 1, rev[son[x][1]] ^= 1;
        rev[x] = 0, swap(son[x][0], son[x][1]);
    }
    void splay(int x) {
        int tp = 0;
        sta[++tp] = x;
        for (int i = x; !isroot(i); i = fa[i]) sta[++tp] = fa[i];
        while (tp > 0) pushdown(sta[tp--]);
        while (!isroot(x)) {
            int y = fa[x], z = fa[y];
            if (!isroot(y)) {
                if (son[y][1] == x ^ son[z][1] == y) rotate(y);
                else rotate(x);
            } rotate(x);
        }
        pushup(x);
    }
    void access(int x) {
        for (int t = 0; x; t = x, x = fa[x])
            splay(x), son[x][1] = t, pushup(x);
    }
    void change(int x) {
        access(x), splay(x), rev[x] ^= 1;
    }
    int find(int x) {
        access(x), splay(x);
        while (son[x][0]) x = son[x][0];
        return x;
    }
    void link(int x, int y) {
        change(x), fa[x] = y;
    }
    void cut(int x) {
        access(x), splay(x);
        fa[son[x][0]] = 0;
        son[x][0] = 0;
        pushup(x);
    }
    int query(int x, int y) {
        change(x), access(y), splay(y);
        return mn[y];
    }
} lct;
struct PersistenceTree {
    static const int MAXT = 4000005;
    int sum[MAXT], ls[MAXT], rs[MAXT], tot;
    int update(int p, int x, int l, int r) {
        int k = ++tot;
        sum[k] = sum[p] + 1, ls[k] = ls[p], rs[k] = rs[p];
        if (l == r) return k;
        int mid = (l + r) >> 1;
        if (x <= mid) ls[k] = update(ls[p], x, l, mid);
        else rs[k] = update(rs[p], x, mid + 1, r);
        return k;
    }
    int query(int a, int b, int k, int l, int r) {
        if (a > r || b < l || !k) return 0;
        if (a <= l && b >= r) return sum[k];
        int mid = (l + r) >> 1;
        return query(a, b, ls[k], l, mid) + query(a, b, rs[k], mid + 1, r);
    }
} pt;
int fr[MAXM], to[MAXM], del[MAXM], rt[MAXM], n, m, Q, A;
int main() {
    //freopen("input.txt", "r", stdin);
    scanf("%d%d%d%d", &n, &m, &Q, &A);
    for (int i = 1; i <= m; i++)
        scanf("%d%d", fr + i, to + i);
    for (int i = 1; i <= n; i++) lct.val[i] = lct.mn[i] = INT_MAX;
    for (int i = 1; i <= m; i++) lct.val[i + n] = lct.mn[i + n] = i;
    for (int i = 1; i <= m; i++) {
        int u = fr[i], v = to[i];
        if (u == v) { del[i] = i; continue; }
        if (lct.find(u) == lct.find(v)) {
            int q = lct.query(u, v);
            lct.change(u);
            lct.cut(q + n);
            lct.change(v);
            lct.cut(q + n);
            del[q] = i;
        }
        lct.link(u, i + n);
        lct.link(v, i + n);
    }
    for (int i = 1; i <= m; i++) {
        if (!del[i]) del[i] = m + 1;
        rt[i] = pt.update(rt[i - 1], del[i], 1, m + 1);
    }
    int ans = 0;
    while (Q--) {
        int l, r; scanf("%d%d", &l, &r);
        if (A) l = (l + ans) % m + 1, r = (r + ans) % m + 1;
        if (l > r) swap(l, r);
        int a = pt.query(r + 1, m + 1, rt[r], 1, m + 1);
        int b = pt.query(r + 1, m + 1, rt[l - 1], 1, m + 1);
        printf("%d\n", ans = n - a + b);
    }
    return 0;
}
```

---

## 作者：Fuyuki (赞：3)

一张图的连通块数量等于点的数量减去任意一个生成森林的边的数量。

用 LCT 维护动态图连通性（离线）的时候，维护了一棵以删除时间为权值的最大生成树。如果一条边被从最大生成树上删去，说明这条边加入图中形成的环上会比这条边更晚消失，也就是说加入这条边带来的连通性可以被这个环取代了，因此这条边也不需要继续存在。

在用 LCT 维护最大生成森林的过程中，可以求出 $val_i$，表示在边 $f_i$ 加入后边 $i$ 不再存在于最大生成森林中。这表示 $[i+1,f_i]$ 这个边集可以取代 $i$ 这条边的连通性。

对于每次询问的区间 $[l,r]$，查询 $\sum_{i=l}^{r}[f_i\leq r]$，就可以求出有多少条边不在最大生成森林中，也就是求出了一个生成森林的边数，并能够计算出联通块的个数。

一段区间内小于某个值的个数是可减的信息，使用主席树维护即可。

细节：

1. 存在自环，自环的边不会存在于最大生成树中，有 $f_i=0$。

2. 强制在线的方式不是异或而是加。

时空复杂度均为 $O(n\log n)$。

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
#define I inline int
#define V inline void
#define FOR(i,a,b) for(int i=a;i<=b;i++)
const int N=3e5+1,INF=0x7fffffff;
int n,m,q,type,tot,rt[N];
int a[N],b[N],c[N],val[N];
int ch[N][2],fa[N],tag[N],w[N];
struct ele{int ls,rs,siz;}t[N<<5];
V input(){
	scanf("%d%d%d%d",&n,&m,&q,&type);
	FOR(i,1,m)scanf("%d%d",a+i,b+i),c[i+n]=i;
}
#define lc ch[x][0]
#define rc ch[x][1]
I id(int x){return x==ch[fa[x]][1];}
I nrt(int x){return x==ch[fa[x]][id(x)];}
V upd(int x){
	w[x]=x;
	if(c[w[lc]]<c[w[x]])w[x]=w[lc];
	if(c[w[rc]]<c[w[x]])w[x]=w[rc];
}
V rot(int x){
	int y=fa[x],z=fa[y],p=id(x),w=ch[x][p^1];
	if(nrt(y))ch[z][id(y)]=x;if(w)fa[w]=y;
	fa[x]=z,fa[y]=x,ch[y][p]=w,ch[x][p^1]=y;
	upd(y),upd(x);
}
V rev(int x){swap(lc,rc),tag[x]^=1;}
V psd(int x){if(tag[x])rev(lc),rev(rc),tag[x]=0;}
V psa(int x){if(nrt(x))psa(fa[x]);psd(x);}
V splay(int x){
	for(psa(x);nrt(x);rot(x))if(nrt(fa[x]))
		rot(id(x)==id(fa[x])?fa[x]:x);
}
V acc(int x){
	for(int y=0,p=x;p;p=fa[y=p])
		splay(p),ch[p][1]=y,upd(p);
	splay(x);
}
V mrt(int x){acc(x),rev(x);}
V link(int x,int y){mrt(x),fa[x]=y;}
I frt(int x){
	for(acc(x);lc;)psd(x),x=lc;
	return splay(x),x;
}
V cut(int x,int y){mrt(x),acc(y),fa[x]=ch[y][0]=0,upd(y);}
I getmin(int x,int y){return mrt(x),acc(y),w[y];}
#undef lc
#undef rc
#define lc t[p].ls
#define rc t[p].rs
#define lson lc,L,mid
#define rson rc,mid+1,R
#define root(u) rt[u],0,m
V ins(int&p,int L,int R,int x){
	t[++tot]=t[p],t[p=tot].siz++;
	if(L==R)return;int mid=L+R>>1;
	(x<=mid)?ins(lson,x):ins(rson,x);
}
I ask(int p,int L,int R,int l,int r){
	if(L==l&&R==r)return t[p].siz;
	int mid=L+R>>1;
	if(l>mid)return ask(rson,l,r);
	if(r<=mid)return ask(lson,l,r);
	return ask(lson,l,mid)+ask(rson,mid+1,r);
}
V init(){
	FOR(i,0,n)c[i]=INF;
	FOR(i,1,m){
		int x=a[i],y=b[i],p;
		if(x==y){val[i]=i;continue;}
		if(frt(x)==frt(y))
			p=getmin(x,y),val[p-n]=i,cut(p,a[p-n]),cut(p,b[p-n]);
		p=i+n,link(p,x),link(p,y);
	}
	FOR(i,1,m){
		rt[i]=rt[i-1];
		if(val[i])ins(root(i),val[i]);
	}
}
V work(){
	int l,r,ans=0;
	while(q--){
		scanf("%d%d",&l,&r);
		if(type)l=(l+ans)%m+1,r=(r+ans)%m+1;
		if(l>r)swap(l,r);
		ans=ask(root(r),0,r)-ask(root(l-1),0,r);
		cout<<(ans=n-(r-l+1-ans))<<'\n';
	}
}
int main(){
	input();
	init();
	work();
	return 0;
}
```

---

## 作者：strcmp (赞：1)

在 CNOI 已经套路化了。

简单来说就是 $q$ 次询问一个区间的边连起来后的联通块数量，强制在线。

想想离线怎么做：我们只关心连通性，因此你想一下，如果我们扫描到 $r$ 这条边，考虑 $[?,\,r]$ 这些边形成的联通块。

我们肯定更希望联通块是一棵树（至少是森林），这样我们使用 LCT 就能简单的维护所有东西了。

那考虑这些联通块形成的生成树森林，我们只关心删除时间最靠后的边。比如现在是一个森林，加入了 $r$ 这条边，考虑 $r$ 连接的 $u,\,v$。如果它们不在同一棵树内直接连就完了，不然我们就将 $u,\,v$ 路径上删除时间最靠前的边拉出来，连接 $u,\,v$ 并删掉那条边显然对我们没有任何影响（显然 $r$ 往后它不会改变联通块数量，加了个 $u,\,v$ 已经保证好连通性了，其它边都比它晚删能有什么影响呢）。这样我们保证了任意时刻我们维护的联通块都是森林。

如果题目可以离线，那我们扫描 $r$，用 $n$ 减去我们没有删的连边数量即可。

如果这题是可离线的那我们已经做完了，可惜它强制在线，我们不得不将扫描线变成主席树。强行二合一，太不牛了。

LCT 和主席树，时空复杂度都是 $\Theta(m \log n)$ 级别的。

```cpp
#include <bits/stdc++.h>
#define X first
#define Y second
#define rep(i, a, b) for (int i = (a); i <= (b); i++) 
#define per(i, a, b) for (int i = (a); i >= (b); i--)
#define mp make_pair
#define pb push_back
using namespace std;
typedef long long int ll;
using pii = pair<int, int>;
constexpr int maxn = 2e5 + 10, mod = 998244353;
int cnt = 0, rt[maxn], n, m, q, T; pii e[maxn];
#define val(x) (t[x].v)
#define mid (l + r >> 1)
namespace sgt {
#define ls(x) (t[x].l)
#define rs(x) (t[x].r)
	struct Node { int l, r, v; } t[maxn * 35];
	void mdf(int l, int r, int k, int v, int p, int& x) {
		t[x = ++cnt] = t[p]; val(x) += v; if (l == r) return;
		k <= mid ? mdf(l, mid, k, v, ls(p), ls(x)) : mdf(mid + 1, r, k, v, rs(p), rs(x));
	}
	int qry(int l, int r, int ql, int qr, int x) {
		if (ql <= l && r <= qr) return val(x); int sum = 0;
		if (ql <= mid) sum += qry(l, mid, ql, qr, ls(x));
		if (qr > mid) sum += qry(mid + 1, r, ql, qr, rs(x)); return sum;
	}
#undef ls
#undef rs
};
struct lct { int v, mi, rv, fa, c[2]; lct() { mi = v = 1e9; } } t[maxn << 1];
#define ch(x, k) (t[x].c[k])
#define ls(x) (ch(x, 0))
#define rs(x) (ch(x, 1))
#define fa(x) (t[x].fa)
#define mi(x) (t[x].mi)
#define rv(x) (t[x].rv)
inline int rl(int x) { return x == rs(fa(x)); }
inline int ntrt(int x) { return x == ls(fa(x)) || x == rs(fa(x)); }
inline void up(int x) { mi(x) = min({ mi(ls(x)), mi(rs(x)), val(x) }); }
inline void rvs(int x) { swap(ls(x), rs(x)), rv(x) ^= 1; }
inline void down(int x) { if (rv(x)) (ls(x) && (rvs(ls(x)), 1)), (rs(x) && (rvs(rs(x)), 1)), rv(x) = 0; }
void rtt(int x) {
	int f = fa(x), ff = fa(f), d = rl(x), & w = ch(x, d ^ 1);
	if (ntrt(f)) ch(ff, rl(f)) = x; if (w) fa(w) = f;
	fa(x) = ff, fa(f) = x, ch(f, d) = w, w = f; up(f), up(x);
}
void all(int x) { if (ntrt(x)) all(fa(x)); down(x); }
inline void spy(int x) { for (all(x); ntrt(x); rtt(x)) if (ntrt(fa(x))) rl(x) == rl(fa(x)) ? rtt(fa(x)) : rtt(x); }
inline void acs(int x) { for (int y = 0; x; x = fa(y = x)) spy(x), rs(x) = y, up(x); }
inline void mkrt(int x) { acs(x); spy(x); rvs(x); }
inline int fd(int x) { acs(x); spy(x); while (ls(x)) down(x), x = ls(x); spy(x); return x; }
inline void lk(int x, int y) { mkrt(x); fa(x) = y; }
inline int qry(int x, int y) { mkrt(x); acs(y); spy(y); return mi(y); }
inline void cut(int x, int y) { qry(x, y); fa(x) = 0, ls(y) = 0; up(y); }
int main() {
	scanf("%d%d%d%d", &n, &m, &q, &T);
	rep(i, 1, m) scanf("%d%d", &e[i].X, &e[i].Y), val(i + n) = mi(i + n) = i;
	rep(o, 1, m) {
		int u = e[o].X, v = e[o].Y;
		if (u == v) { rt[o] = rt[o - 1]; continue; }
		sgt::mdf(1, m, o, 1, rt[o - 1], rt[o]);
		if (fd(u) == fd(v)) {
			int w = qry(u, v);
			cut(u, w + n), cut(v, w + n);
			sgt::mdf(1, m, w, -1, rt[o], rt[o]);
		}
		lk(u, o + n), lk(v, o + n);
	}
	int ans = 0, l, r;
	while (q--) {
		scanf("%d%d", &l, &r);
		if (T) l = (l + ans) % m + 1, r = (r + ans) % m + 1;
		if (l > r) swap(l, r);
		printf("%d\n", ans = n - sgt::qry(1, m, l, r, rt[r]));
	}
	return 0;
}
```

---

## 作者：_fairytale_ (赞：1)

## 前置芝士：

### 1.LCT、可持久化线段树的板子。

### 2.LCT 维护带边权的边（边权转点权）的方法：

设边由 $u$ 连向 $v$，边权为 $w$，边的编号为 $i$。

建一个虚点 $i+n$，使 $p$ 的点权为 $w$，然后连 $u$ 到 $i+n$，$i+n$ 到 $v$ 的边即可。

注意这里 $u,v$ 的点权需要根据题目初始化为特定的值，不一定是 $0$。

### 3.一个简单结论：

**对于一张图，我们维护它的任意一个生成树森林，总点数 $-$ 森林中的边数即为这张图的连通块个数。**

证明就是每棵生成树代表一个连通块，那么它的边数应该是连通块点数 $-1$。

也就是说，有多少个连通块，点数 $-$ 边数就是多少。

## 约定

$n$ 为点数，即 $|V|$，$m$ 为边数，即 $|E|$。

## 主要思路

对于询问 $(l,r)$，我们考虑只加 $A_l - A_r$ 这些边时的生成树森林，只要知道森林中的边数，就可以回答询问了。

所以我们现在只有两个问题：

1.怎么统计森林中的边数。

2.怎么快速求出只加 $A_l - A_r$ 这些边时的生成树森林。

### 问题 1

用一棵可持久化线段树维护加入边 $A_r$ 时每条边是否被选入生成树森林即可。

但是这里会出现一个问题，即有时候 $A_l$ 之前的边被选入生成树森林，导致 $A_l-A_r$ 中的边在统计答案时偏少，进而导致答案偏大。

这个问题我们马上解决。
### 问题 2

首先用 LCT 往生成树森林里**顺序**加边 $A_1-A_m$。

我们考虑用 LCT 往生成树森林加边 $(u,v)$ 时会出现两种情况：

1.$(u,v)$ 不连通，此时直接 $link(u,v)$ 即可。

2.$(u,v)$ 连通，此时加边会成环，就先断掉环中加入时间最早的边再 $link(u,v)$。

注意到这样的策略可以完美解决上述的问题。我们尽量加入出现较晚的边，这样就不会因为 $A_l$ 之前的边影响 $A_l-A_r$ 之间边的统计。 

怎么找加入时间最早的边呢？把边的边权赋值成它的编号，然后边权转点权，每次在 LCT 里 query 点权最小的点即可。

具体细节可看代码。

代码里附赠了一组很弱的小样例。

本题有自环要判，难绷。
## code

```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
#define re register
#define mid ((l+r)>>1)
#define maxn 300010
#define maxm 200010
using namespace std;
int n,m,q,t;
int val[maxn];
struct Link_Cut_Tree {
	struct tree {
		int son[2],fa;
		int mn;
		bool tag;
	} spl[maxn];
	inline void chmin(int x,int y) {
		if(val[spl[x].mn]>val[spl[y].mn])spl[x].mn=spl[y].mn;
	}
	inline void pushup(int x) {
		spl[x].mn=x;
		chmin(x,spl[x].son[0]);
		chmin(x,spl[x].son[1]);
	}
	inline bool ident(int x,int f) {
		return x==spl[f].son[1];
	}
	inline bool isroot(int x) {
		return spl[spl[x].fa].son[0]!=x&&spl[spl[x].fa].son[1]!=x;
	}
	inline void connect(int x,int f,int k) {
		spl[f].son[k]=x;
		spl[x].fa=f;
	}
	inline void rotate(int x) {
		int f=spl[x].fa,ff=spl[f].fa,k=ident(x,f);
		if(!isroot(f)) {
			connect(x,ff,ident(f,ff));
		} else spl[x].fa=ff;
		connect(spl[x].son[k^1],f,k);
		connect(f,x,k^1);
		pushup(f),pushup(x);
	}
	inline void rev(int x) {
		swap(spl[x].son[0],spl[x].son[1]);
		spl[x].tag^=1;
	}
	inline void pushdown(int x) {
		if(spl[x].tag) {
			rev(spl[x].son[0]);
			rev(spl[x].son[1]);
			spl[x].tag=0;
		}
	}
	inline void pushall(int x) {
		if(!isroot(x))pushall(spl[x].fa);
		pushdown(x);
	}
	inline void splay(int x) {
		pushall(x);
		while(!isroot(x)) {
			int f=spl[x].fa,ff=spl[f].fa;
			if(!isroot(f))(ident(x,f)==ident(f,ff)?rotate(f):rotate(x));
			rotate(x);
		}
	}
	inline void access(int x) {
		for(re int p=0; x; p=x,x=spl[x].fa) {
			splay(x);
			spl[x].son[1]=p;
			pushup(x);
		}
	}
	inline int findroot(int x) {
		access(x);
		splay(x);
		while(spl[x].son[0]) {
			pushdown(x);
			x=spl[x].son[0];
		}
		splay(x);
		return x;
	}
	inline void makeroot(int x) {
		access(x);
		splay(x);
		rev(x);
	}
	inline bool linked(int x,int y) {
		makeroot(x);
		return findroot(y)==x;
	}
	inline void link(int x,int y) {
		if(!linked(x,y))spl[x].fa=y;
	}
	inline void cut(int x,int y) {
		if(linked(x,y)&&spl[x].son[1]==y&&!spl[y].son[0])spl[x].son[1]=spl[y].fa=0;
	}
	inline void split(int x,int y) {
		makeroot(x);
		access(y);
		splay(y);
	}
	inline int query(int x,int y) {
		split(x,y);
		return spl[y].mn;
	}
} LCT;
struct edge {
	int u,v;
} e[maxm];
int root[maxm];
struct Segment_Tree {
	struct tree {
		int ls,rs,sum;
	} t[maxm<<5];
	int cnt;
	void insert(int &p,int lsp,int l,int r,int pos,int v) {
		if(!p)p=++cnt,t[p].sum=t[lsp].sum;
		t[p].sum+=v;
		if(l==r)return;
		if(mid>=pos) {
			if(!t[p].rs)t[p].rs=t[lsp].rs;
			insert(t[p].ls,t[lsp].ls,l,mid,pos,v);
		} else {
			if(!t[p].ls)t[p].ls=t[lsp].ls;
			insert(t[p].rs,t[lsp].rs,mid+1,r,pos,v);
		}
	}
	int query(int p,int l,int r,int L,int R) {
		if(L<=l&&r<=R)return t[p].sum;
		int res=0;
		if(mid>=L)res+=query(t[p].ls,l,mid,L,R);
		if(mid<R)res+=query(t[p].rs,mid+1,r,L,R);
		return res;
	}
} ST;
int ql,qr;
int lans;
inline void decode() {
	if(t>0) {
		ql=(ql+t*lans)%m+1;
		qr=(qr+t*lans)%m+1;
	}
	if(ql>qr)swap(ql,qr);
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	memset(val,0x3f,sizeof(val));
	cin>>n>>m>>q>>t;
	for(re int i=1; i<=m; ++i) {
		cin>>e[i].u>>e[i].v;
		if(e[i].u==e[i].v){
			root[i]=root[i-1];
			continue;
		}
		val[i+n]=i;
		if(LCT.linked(e[i].u,e[i].v)) {
			re int p=LCT.query(e[i].u,e[i].v);
			LCT.cut(e[p-n].u,p);
			LCT.cut(p,e[p-n].v);
			ST.insert(root[i],root[i-1],1,m,p-n,-1);
		}
		LCT.link(e[i].u,i+n);
		LCT.link(i+n,e[i].v);
		ST.insert(root[i],root[i-1],1,m,i,1);
	}
	while(q--) {
		cin>>ql>>qr;
		decode();
		lans=n-ST.query(root[qr],1,m,ql,qr);
		cout<<lans<<'\n';
	}
	return 0;
}
/*
input:
5 6 8 0
1 2
2 3
1 3
1 4
2 5
1 5
1 3
4 5
3 5
2 5
1 2
1 6
1 1
6 6
output:
3
3
2
1
3
1
4
4
*/

```

---

## 作者：Hoks (赞：0)

## 前言
好久没写 LCT 感觉要退化了。

重温了一遍发现还是好写的，不过神仙思路题没想到怎么做。

广告：[『从入门到入土』树链剖分学习笔记](https://www.luogu.com.cn/article/56o68hfu)。
## 思路分析
题意就是一段区间的边连上后求连通块个数，但是强制在线。

因为强制在线~~以及标签~~，首先想到 LCT。

但是 LCT 维护的是动态森林，和图/连通块有什么关系啊。

因为树是 $n$ 个点 $n-1$ 条边，所以一个森林里，每多一颗树，点数和边数之差就会 $+1$。

也就是，对于一个 $n$ 个点 $m$ 条边的森林，其中连通块数便为 $n-m$。

接着考虑下询问，即变为了 $l,r$ 这个区间有多少条边在森林中。

在线不太好做，考虑先预处理出来再去在线查询回答。

考虑用 LCT 维护一个动态森林，按照顺序加边。

如果新加入的一条边成环，就去掉环上最前面加入的一条边，这样就能保证目前维护的这个森林的边的区间 $[l,r]$ 是最小的。

而存储答案，则考虑主席树，维护整个值域 $[1,m]$ 即可。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=4e5+10,V=1e5,INF=0x3f3f3f3f,mod=1e9+7;
int n,m,q,t,ans,x[N],y[N];
namespace Fast_IO
{
    static char buf[1000000],*paa=buf,*pd=buf,out[10000000];int length=0;
    #define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
    inline int read()
    {
        int x(0),t(1);char fc(getchar());
        while(!isdigit(fc)){if(fc=='-') t=-1;fc=getchar();}
        while(isdigit(fc)) x=(x<<1)+(x<<3)+(fc^48),fc=getchar();
        return x*t;
    }
    inline void flush(){fwrite(out,1,length,stdout);length=0;}
    inline void put(char c){if(length==9999999) flush();out[length++]=c;}
    inline void put(string s){for(char c:s) put(c);}
    inline void print(int x)
    {
        if(x<0) put('-'),x=-x;
        if(x>9) print(x/10);
        put(x%10+'0');
    }
    inline bool chk(char c) { return !(c>='a'&&c<='z'||c>='A'&&c<='Z'||c>='0'&&c<='9'); }
    inline bool ck(char c) { return c!='\n'&&c!='\r'&&c!=-1&&c!=' '; }
    inline void rd(char s[],int&n)
    {
        s[++n]=getchar();
        while(chk(s[n])) s[n]=getchar();
        while(ck(s[n])) s[++n]=getchar();
        n--;
    }
}
using namespace Fast_IO;
struct LCT
{
	#define ls son[x][0]
	#define rs son[x][1]
	int f[N],s[N],son[N][2],st[N],w[N],r[N];
	bool ntrt(int x){return son[f[x]][1]==x||son[f[x]][0]==x;}
	void pushup(int x){s[x]=min(s[ls],min(s[rs],w[x]));}
	void pushson(int x){swap(ls,rs),r[x]^=1;}
	void pushdown(int x)
	{
		if(r[x])
		{
			if(ls) pushson(ls);
			if(rs) pushson(rs);
			r[x]=0;
		}
	}
	void rotate(int x)
	{
		int y=f[x],z=f[y],k=(son[y][1]==x),w=son[x][!k];
		if(ntrt(y)) son[z][son[z][1]==y]=x;son[x][!k]=y;son[y][k]=w;
		if(w) f[w]=y;f[y]=x;f[x]=z;
		pushup(y);
	}
	void Splay(int x)
	{
		int y=x,tot=0;st[++tot]=y;
		while(ntrt(y)) st[++tot]=y=f[y];
		while(tot) pushdown(st[tot--]);
		while(ntrt(x))
		{
			y=f[x];int z=f[y];
			if(ntrt(y)) rotate((son[y][0]==x)^(son[z][0]==y)?x:y);
			rotate(x);
		}
		pushup(x);
	}
	void access(int x){for(int y=0;x;x=f[y=x]) Splay(x),rs=y,pushup(x);}
	void makert(int x){access(x);Splay(x);pushson(x);}
	int findrt(int x)
	{
		access(x);Splay(x);
		while(ls) pushdown(x),x=ls;
		Splay(x);return x;
	}
	void split(int x,int y){makert(x);access(y);Splay(y);}
	void link(int x,int y){makert(x);f[x]=y;}
	void cut(int x,int y){split(x,y);f[x]=son[y][1]=0;}
	#undef ls
	#undef rs
}lct;
struct Persistant_Segment_Tree
{
    #define mid ((l+r)>>1)
    #define ls (lc[p])
    #define rs (rc[p])
    int cnt;vector<int>s,lc,rc,rt;
    void init(int l,int r){s=lc=rc=vector<int>((r-l+10)<<5),rt=vector<int>(r-l+10);}
	void modify(int &p,int l,int r,int x,int v)
    {
        int rt=++cnt;lc[rt]=ls;rc[rt]=rs;
    	s[rt]=s[p]+v;p=rt;if(l==r) return;
        if(x<=mid) modify(ls,l,mid,x,v);
        else modify(rs,mid+1,r,x,v);
    }
    int query(int p,int l,int r,int st,int e)
    {
    	if(l>=st&&r<=e) return s[p];int res=0;
    	if(mid>=st) res+=query(ls,l,mid,st,e);
    	if(mid<e) res+=query(rs,mid+1,r,st,e);
        return res;
    }
}sgt;
signed main()
{
	n=read(),m=read(),q=read(),t=read();memset(lct.w,0x3f,sizeof lct.w);memset(lct.s,0x3f,sizeof lct.s);
	for(int i=1;i<=m;i++) x[i]=read(),y[i]=read(),lct.w[i+n]=lct.s[i+n]=i;sgt.init(1,m);
	for(int i=1;i<=m;i++)
	{
		sgt.rt[i]=sgt.rt[i-1];if(!(x[i]^y[i])) continue;
		sgt.modify(sgt.rt[i],1,m,i,1);
		if(lct.findrt(x[i])==lct.findrt(y[i]))
		{
			lct.split(x[i],y[i]);int del=lct.s[y[i]];
			lct.cut(x[del],del+n);lct.cut(y[del],del+n);
			sgt.modify(sgt.rt[i],1,m,del,-1);
		}lct.link(x[i],i+n);lct.link(y[i],i+n);
	}
	for(int i=1,l,r;i<=q;i++)
	{
		l=read(),r=read();
		if(t) l=(l+ans)%m+1,r=(r+ans)%m+1;
		if(l>r) swap(l,r);
		print(ans=(n-sgt.query(sgt.rt[r],1,m,l,r)));put('\n');
	}
    genshin:;flush();return 0;
}
```

---

## 作者：huta0 (赞：0)

看到区间加边连通块个数，实际上就是求结点数减去所有加上区间里的边成的生成树的边的个数。因为一棵树可以考虑成结点数减去边数，所以总和就算出来了。

至于看到此题，因为有生成树加删边和区间，所以用 LCT 和主席树来做，具体实现可以看代码。

```cpp
#include<iostream>
#include<vector>
#include<algorithm>
#include<cstring>
#include<map>
#define rep(a,b,c) for(int a=b;a<=c;a++)
#define a_all a.begin(),a.end()
using namespace std;
typedef long long ll;
int n,m,q,t,l,r,lst;
struct egde { int u,v; } e[200010];
namespace hikari {
      struct node {
            int p,v=2000010,mn=2000010,tag;
            int s[2];
      } tr[400010];
      #define fa(x) tr[x].p
      #define lc(x) tr[x].s[0]
      #define rc(x) tr[x].s[1]
      #define ntrt(x) lc(fa(x))==x||rc(fa(x))==x
      void pushup(int x) {
            tr[x].mn=min(tr[x].v,min(tr[lc(x)].mn,tr[rc(x)].mn));
      }
      void pushdown(int x) {
            if(tr[x].tag) {
                  swap(lc(x),rc(x));
                  tr[lc(x)].tag^=1;
                  tr[rc(x)].tag^=1;
                  tr[x].tag=0;
            }
      }
      void pushall(int x) {
            if(ntrt(x)) pushall(fa(x));
            pushdown(x);
      }
      void rotate(int x) {
            int y=fa(x),z=fa(y);
            int k= rc(y)==x;
            if(ntrt(y))
                 tr[z].s[rc(z)==y]=x;
            fa(x)=z;
            tr[y].s[k]=tr[x].s[k^1];
            fa(tr[x].s[k^1])=y;
            tr[x].s[k^1]=y;
            fa(y)=x;
            pushup(y); pushup(x);
      }
      void splay(int x) {
            pushall(x);
            while(ntrt(x)) {
                  int y=fa(x),z=fa(y);
                  if(ntrt(y))
                       rotate((rc(y)==x)^(rc(z)==y)?x:y);
                  rotate(x);
            }
      }
      void access(int x) {
            int y=0;
            while(x) {
                  splay(x);
                  rc(x)=y;
                  pushup(x);
                  y=x; x=fa(x);
            }
      }
      void mkrt(int x) {
            access(x);
            splay(x);
            tr[x].tag^=1;
      }
      int fdrt(int x) {
            access(x);
            splay(x);
            while(lc(x)) pushdown(x),x=lc(x);
            splay(x);
            return x;
      }
      void split(int x,int y) {
             mkrt(x);
             access(y);
             splay(y);
      }
      void link(int x,int y) {
            mkrt(x);
            if(fdrt(y)!=x) fa(x)=y;
      }
      void cut(int x,int y) {
            mkrt(x);
            if(fdrt(y)==x&&fa(y)==x&&!lc(y)) {
                  rc(x)=fa(y)=0;
                  pushup(x);
            }
      }
      void change(int x,int val) {
           splay(x);
           tr[x].v=val;
      }
};
using namespace hikari;
int fat[200010];
#define init rep(i,1,n) fat[i]=i
int find(int x) { return fat[x]==x?x:fat[x]=find(fat[x]); }
void merge(int x,int y) { if(find(x)!=find(y)) fat[find(x)]=find(y); }
#define cot(x,y) find(x)==find(y)
namespace ai {
     struct node { int ch[2],sum;} tr[200005*32];
     #define lc(x) tr[x].ch[0]
     #define rc(x) tr[x].ch[1]
     int rt[200005],id=0,tmp;
     inline void modify(int &y,int l,int r,int L,int R,int v) {
           tmp=++id; tr[tmp]=tr[y];tr[tmp].sum+=v; y=tmp;
           if(l==r) return;
           int mid=l+r>>1;
           if(L<=mid) modify(lc(y),l,mid,L,R,v);
           else modify(rc(y),mid+1,r,L,R,v);
     }
     inline int query(int y,int l,int r,int L,int R) {
           if(L<=l&&r<=R) return tr[y].sum;
           int mid=l+r>>1,v=0;
           if(L<=mid) v+=query(lc(y),l,mid,L,R);
           if(R>mid) v+=query(rc(y),mid+1,r,L,R);
           return v;
     }
} 
void get(int& l,int& r,int t,int lsta) {
      if(t>0) {
           l=(l+t*lsta)%m+1;
           r=(r+t*lsta)%m+1;
      } if(l>r) swap(l,r);
}
int tot,ctt;
map<pair<int,int>,int> mp;
int main() {
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m>>q>>t; tot=n;
    init;
    rep(i,1,m) {
          cin>>e[i].u>>e[i].v;
          ai::rt[i]=ai::rt[i-1];
          int aa=e[i].u,bb=e[i].v;
          if(aa==bb) continue;
          ai::modify(ai::rt[i],1,m,i,i,1);
          if(cot(aa,bb)) {
                 split(aa,bb);
                 int uu=e[tr[bb].mn-n].u,vv=e[tr[bb].mn-n].v;
                 int o=tr[bb].mn;
                 ai::modify(ai::rt[i],1,m,tr[bb].mn-n,tr[bb].mn-n,-1);
                 cut(uu,o); cut(o,vv);
          }
          merge(aa,bb);
          tr[i+n].v=i+n;
          link(aa,i+n); link(i+n,bb);
    }
    rep(i,1,q) {
          cin>>l>>r;
          get(l,r,t,lst);
          cout<<(lst=n-ai::query(ai::rt[r],1,m,l,r))<<endl;
    }
    return 0;
}
```

---

## 作者：Illusory_dimes (赞：0)

`这曾今有一个凄婉哀伤的故事，但是被出题人删档弄丢了。`

题目名字这么高尚，背景你却给我咕了？？

## Description

点数 $n$ ，边数 $m$ ，询问 $q$ 次，求一段区间内的边组成的残图的连通块个数。

$n,\ q \leq 10 ^ 5,\ m \leq 2 \cdot 10 ^ 5$

## Analysis

首先我们要知道对于一个残图，它的点数减生成森林的边数就是连通块的个数。

因为它本身是作为图为存在的，所以即需要维护区间生成树（森林）。

## Solution

又是区间，又是生成树什么跟图扯上关系的要求，看起来就头大。

可以考虑用 $\text{LCT}$ 维护生成树。

但是生成树可能会有很多种，我们就需要所有边编号尽可能靠近那个区间。

怎么办。

我们考虑在加边的时候，假如当前两个点原先已经联通，我们尝试去找连通块上最早加进来的边，并把他删掉。

这样就能保证在图的连通性不变的情况下，让生成树上的边尽可能靠近右边界。

这样我们可以在 $\text{LCT}$ 里面维护连通块内编号最小的地方。

众所周知 $\text{LCT}$ 是维护的点权，所以要把边化点。不过比较典的套路，可以直接把边也当作点塞到 $\text{LCT}$ 里面，就像 $\text{kruskal}$ 重构树那样连边。

所这样只需要把边的编号当作点权，其他图上的点设成 $\infty$ ，维护最小值就行了。

那如果我们想要随时知道前 r 条边有多少条生成树边，把这些甩到主席树上就行了。但是注意这玩意相当于能查询前 r 条边有多少条存在于生成树上。

因为我们是尽量让所有树边编号尽可能大，所以就类似二位数点 $f_r - f_{l - 1}$ 那样做个差就知道前 $r$ 条边最多有多少条在区间 $[l,\ r]$ 内。

不得不说 $\text{LCT}$ 有些操作看起来是真的厉害（

时间复杂度 $O(n \log n)$ 。

## Code

```cpp
/*

*/
#include <bits/stdc++.h>
using namespace std;

#define File(a) freopen(a".in", "r", stdin), freopen(a".out", "w", stdout);
#define Check(a) freopen(a".in", "r", stdin), freopen(a".ans", "w", stdout);

typedef long long ll;
typedef unsigned long long ull;
typedef std::pair<int, int> pii;
#define fi first
#define se second
#define mp std::make_pair

const int mod = 998244353;
template <typename A>
inline int M(A x) {return x;}
template <typename A, typename ...B>
inline int M(A x, B ... args) {return 1ll * x * M(args...) % mod;}

#define mi(x) (x >= mod) && (x -= mod)
#define ad(x) (x < 0) && (x += mod)

const int N = 2e5 + 10, P = 3e5 + 10, INF = 1e9;

int n, m, q, op, rt[N], del[N];
struct edge {int u, v;} e[N];

struct LCT {
	#define ls(x) ch[x][0]
	#define rs(x) ch[x][1]

	int ch[P][2], fa[P], mn[P], va[P], rev[P], st[P], tp;

	#define pd(x) (!(rs(fa[x]) ^ x))
	#define isrt(x) (ls(fa[x]) ^ x && rs(fa[x]) ^ x)

	inline void pushup(int x) {mn[x] = min(va[x], min(mn[ls(x)], mn[rs(x)]));}

	#define prev(x) (rev[x] ^= 1, ls(x) ^= rs(x) ^= ls(x) ^= rs(x))

	inline void pushdown(int x) {
		rev[x] && (
			ls(x) && (prev(ls(x))), 
			rs(x) && (prev(rs(x))), rev[x] = 0
		);
	}

	inline void rotate(int x) {
		int d = fa[x], t = pd(x);
		ch[d][t] = ch[x][t ^ 1]; fa[ch[x][t ^ 1]] = d;

		!isrt(d) && (ch[fa[d]][pd(d)] = x);

		fa[x] = fa[d]; ch[x][t ^ 1] = d; fa[d] = x;
		pushup(d); pushup(x);
	}

	inline void push(int x) {
		for (; !isrt(x); x = fa[x]) st[++tp] = x;
		st[++tp] = x;
		while (tp) pushdown(st[tp--]);
	}

	inline void splay(int x) {
		for (push(x); !isrt(x); rotate(x)) {
			!isrt(fa[x]) && (rotate((pd(x) ^ pd(fa[x])) ? x : fa[x]), 1);
		}
		pushup(x);
	}

	inline void access(int x) {
		for (int y = 0; x; y = x, x = fa[x]) splay(x), rs(x) = y, pushup(x);
	}

	inline void makert(int x) {access(x); splay(x); prev(x);}

	inline void split(int x, int y) {makert(x); access(y); splay(y);}

	inline int firt(int x) {
		access(x); splay(x);
		for (; ls(x); pushdown(x), x = ls(x));
		splay(x); return x;
	}

	inline void link(int x, int y) {makert(x); fa[x] = y;}

	inline void cut(int x, int y) {split(x, y); ls(y) = fa[x] = 0; pushup(y);}

	#undef ls
	#undef rs

	#undef pd
	#undef isrt
} L;

struct PresiTree {
	struct mdzz {int su, ch[2];} tr[N << 5];
	int cnt;

	#define ls(x) tr[x].ch[0]
	#define rs(x) tr[x].ch[1]

	inline void modify(int &x, int l, int r, int k, int p) {
		x = ++cnt; tr[x] = tr[p]; ++tr[x].su;
		if (l == r) return ;

		int mid = (l + r) >> 1;
		if (k <= mid) modify(ls(x), l, mid, k, ls(p));
		else modify(rs(x), mid + 1, r, k, rs(p));
	}

	inline int query(int x, int l, int r, int L, int R) {
		if (!x) return 0;
		if (L <= l && r <= R) return tr[x].su;

		int mid = (l + r) >> 1, ret = 0;
		if (L <= mid) ret += query(ls(x), l, mid, L, R);
		if (R > mid) ret += query(rs(x), mid + 1, r, L, R);
		return ret;
	}

	#undef ls
	#undef rs
} Pt;

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);

	std::cin >> n >> m >> q >> op;
	for (int i = 0; i <= n; ++i) L.va[i] = L.mn[i] = INF;
	for (int i = 1; i <= m; ++i) L.va[i + n] = L.mn[i + n] = i;

	for (int i = 1, j; i <= m; ++i) {
		std::cin >> e[i].u >> e[i].v;
		int x = e[i].u, y = e[i].v;

		if (!(x ^ y)) {del[i] = i; continue;}

		L.firt(x) == L.firt(y) && (
			L.split(x, y), j = L.mn[y], 
			L.cut(e[j].u, j + n), L.cut(e[j].v, j + n), del[j] = i
		);
		L.link(x, i + n); L.link(y, i + n);
	}

	for (int i = 1; i <= m; ++i) {
		if (!del[i]) del[i] = m + 1;
		Pt.modify(rt[i], 1, m + 1, del[i], rt[i - 1]);
	}

	int ans = 0;

	while (q--) {
		int l, r; std::cin >> l >> r;
		op && (l = (l + ans) % m + 1, r = (r + ans) % m + 1);
		l > r && (l ^= r ^= l ^= r);

		int a = Pt.query(rt[r], 1, m + 1, r + 1, m + 1);
		int b = Pt.query(rt[l - 1], 1, m + 1, r + 1, m + 1);
		ans = n - a + b;

		std::cout << ans << "\n";
	}

	return 0;
}

```

---


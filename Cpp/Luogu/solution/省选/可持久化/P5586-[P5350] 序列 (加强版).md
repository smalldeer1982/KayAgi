# [P5350] 序列 (加强版)

## 题目背景

本题为 [P5350](https://www.luogu.org/problem/P5350) 的加强版。  
本题很良心，不卡空间！  


## 题目描述

有一个序列 $a_n$ 和 $q$ 次操作。

- `1 l r` 求区间 $[l,r]$ 的和  
- `2 l r k` 区间 $[l,r]$ 赋值为 $k$  
- `3 l r k` 区间 $[l,r]$ 加上 $k$  
- `4 l1 r1 l1 r2` 将区间 $[l_1,r_1]$ 复制到 $[l_2,r_2]$ 处  
- `5 l1 r1 l2 r2` 将区间 $[l_1,r_1]$ 与 $[l_2,r_2]$ 交换  
- `6 l r` 翻转区间 $[l,r]$

最后还要输出整个序列，所有输出都要对 $10^9+7$ 取模。

为了卡掉某些乱搞做法，**本题强制在线**。  

每次操作中，除了输入第一个数，其它所有数都需要异或 $\text{last}$ 才是实际的操作。  
$\text{last}$ 为上一次 $1$ 操作的答案 $\pmod{10^9 +7}$，定义初始 $\text{last} = 0$。  


## 说明/提示

【数据范围】   
$1\le n,q \le 3\times 10^5$  
$0\le a_i,k \le 10^9$   
对于 $4,5$ 操作，保证 $r_1-l_1 = r_2-l_2$ 且 $[l_1,r_1] \cap [l_2,r_2] = \varnothing$

**不保证数据随机** 且 **没有梯度**   
想交 ODT 的就算了吧！

## 样例 #1

### 输入

```
10 10
7 1 3 2 2 4 0 1 2 2 
4 10 10 3 3
3 4 10 5
6 6 7
6 9 10
1 10 10
5 14 13 1 0
2 15 13 7
5 3 3 2 2
5 5 3 15 13
3 4 14 7```

### 输出

```
7
7 0 0 0 7 7 7 1 2 7```

# 题解

## 作者：Pulsating_Dust (赞：9)

给出一种时间复杂度不变但线性空间的做法。

思考为什么可持久化平衡树就可以完成区间复制，因为可持久化后修改不会导致原版本被修改，因此可以直接复制。

但可持久化对空间有巨大的消耗，考虑使用引用计数（现代对于多个字符串处理的常见方式）。

也就是说我们尽可能把相同的内容使用同一块空间表示，当进行修改时如果引用不为 一 就进行复制。当引用为零时即可删除节点。

复杂度：

时间：

因为每次我们只会访问 $\log n$ 个节点，此时才可能发生复制。复制带来的总节点数量 $O(n \log n)$。

删除的时候每删除一个节点的复杂度为 $O(1)$ 删除节点数量不可能超过总结点数量 因此删除带来的总复杂度同样为 $O(n \log n)$。

空间：

考虑总引用次数不超过 $O(n)$，因此在每个时刻节点总个数不超过 $O(n)$。

实现上：

我们额外记录一个该点被引用的次数，根节点固定为一，此外每个节点引用一次它的左右孩子。

那么在没有区间复制时每个节点的引用计数都为一。

现在我们对它进行区间复制。

要复制的那个区间因为此时不涉及修改只需要把它的引用次数增加一次，然后合并。

被复制的那个区间的引用计数减少一次，如果发现引用次数已经为零就递归删除。

注意打标记时有修改因此检查是否要复制。

```cpp
//HAVE WE BECOME BLASPHEMOUS?
#include<bits/stdc++.h>
using i64=long long;
constexpr int mod=1e9+7,maxn=3e5+50;
int rand01(i64 x,i64 y){
	return y*rand()<x*RAND_MAX;
}//x/y的几率返回1 否则返回0
struct FHQtreap{
	struct Node{
		i64 sum,val,add,set;
		int l,r,siz,rev,ref;
		inline void Set(i64 v){val=set=v,sum=v*siz,add=0;}
		inline void Add(i64 v){add+=v,sum+=v*siz,val+=v;}
		inline void Rev(){std::swap(l,r),rev^=1;}
	}tr[maxn];//FHQtreap的节点
	int cnt,bin[maxn],top,root;
	//使用的节点总数 垃圾桶 垃圾桶顶 根节点id
	inline void delid(int id){bin[++top]=id;}
	int newid(){return top?bin[top--]:++cnt;}
	inline int newnode(i64 val){
		int id=newid();
		tr[id]={val,val,0,-1,0,0,1,0,1};
		return id;
	}//新建一个对应权值的节点并返回其编号
	#define ls tr[rt].l
	#define rs tr[rt].r
	void Kill(int rt){
		if(!rt){return ;}
		if(tr[rt].ref>1){return --tr[rt].ref,void();}
		Kill(ls),Kill(rs),delid(rt);
	}//删除以rt为根的节点
	inline void pushup(int rt){
		tr[rt].sum=tr[ls].sum+tr[rt].val+tr[rs].sum;
		tr[rt].siz=tr[ls].siz+1+tr[rs].siz;
	}
	inline void check(int &rt){
		if(tr[rt].ref>1){
			int nw=newid();
			(tr[nw]=tr[rt]).ref=1,--tr[rt].ref,rt=nw;
			if(ls)++tr[ls].ref;
			if(rs)++tr[rs].ref;
		}
	}//检测是否引用大于1 (copy on write)
	inline void pushdown(int &rt){
		check(rt);
		if(~tr[rt].set){
			if(ls)check(ls),tr[ls].Set(tr[rt].set);
			if(rs)check(rs),tr[rs].Set(tr[rt].set);
			tr[rt].set=-1;
		}
		if(tr[rt].rev){
			if(ls)check(ls),tr[ls].Rev();
			if(rs)check(rs),tr[rs].Rev();
			tr[rt].rev=0;
		}
		if(tr[rt].add){
			if(ls)check(ls),tr[ls].Add(tr[rt].add);
			if(rs)check(rs),tr[rs].Add(tr[rt].add);
			tr[rt].add=0;
		}
	}//下传 保证不冲突
	void split(int rt,int k,int &x,int &y){
		if(!rt){return x=y=0,void();}
		pushdown(rt);
		if(tr[ls].siz<k){
			x=rt,split(rs,k-tr[ls].siz-1,rs,y);
			pushup(x);
		}
		else{
			y=rt,split(ls,k,x,ls);
			pushup(y);
		}
	}
	int merge(int x,int y){
		if(!x){return y;}
		if(!y){return x;}
		pushdown(x),pushdown(y);
		if(rand01(tr[x].siz,tr[y].siz+tr[x].siz)){
			tr[x].r=merge(tr[x].r,y),pushup(x);
			return x;
		}
		else{
			tr[y].l=merge(x,tr[y].l),pushup(y);
			return y;
		}
	}
	void print(int rt){
		if(!rt){return ;}
		pushdown(rt);
		print(ls),std::cout<<tr[rt].val%mod<<' ',print(rs);
	}//中序遍历即为打印这个序列
	#undef ls
	#undef rs
	i64 Sum(int l,int r){
		int x,y,z;
		split(root,r,x,z),split(x,l-1,x,y);
		i64 res=tr[y].sum;
		root=merge(merge(x,y),z);
		return res;
	}//获取区间和
	void Assign(int l,int r,i64 v){
		int x,y,z;
		split(root,r,x,z),split(x,l-1,x,y);
		check(y),tr[y].Set(v);
		root=merge(merge(x,y),z);
	}//区间赋值
	void Add(int l,int r,i64 v){
		int x,y,z;
		split(root,r,x,z),split(x,l-1,x,y);
		check(y),tr[y].Add(v);
		root=merge(merge(x,y),z);
	}//区间加
	void Copy(int l1,int r1,int l2,int r2){
		int con=0,v,w,x,y,z;
		if(l1>l2){
			std::swap(l1,l2),std::swap(r1,r2);
			con=1;
		}
		split(root,r2,v,z),split(v,l2-1,v,y);
		split(v,r1,v,x),split(v,l1-1,v,w);
		if(con){
			std::swap(w,y);
		}
		tr[w].ref++;
		if(tr[y].ref>1){--tr[y].ref;}else{Kill(y);}
		root=merge(v,merge(w,merge(x,merge(w,z))));	
	}//区间复制
	void Swap(int l1,int r1,int l2,int r2){
		if(l1>l2){std::swap(l1,l2),std::swap(r1,r2);}
		int v,w,x,y,z;
		split(root,r2,v,z),split(v,l2-1,v,y);
		split(v,r1,v,x),split(v,l1-1,v,w);
		root=merge(v,merge(y,merge(x,merge(w,z))));
	}//区间交换
	void Reverse(int l,int r){
		int x,y,z;
		split(root,r,x,z),split(x,l-1,x,y);
		check(y),tr[y].Rev();
		root=merge(merge(x,y),z);
	}//区间翻转
}T;
void solve(){
	int n,q;
	std::cin>>n>>q;
	for(int i=0,x;i!=n;i++){
		std::cin>>x;
		T.root=T.merge(T.root,T.newnode(x));
	}
	for(int i=0,op,l,r,x,y,las=0;i!=q;i++){
		std::cin>>op>>l>>r,l^=las,r^=las;
		switch(op){
			case 1:std::cout<<(las=T.Sum(l,r)%mod)<<'\n';break;
			case 2:std::cin>>x,x^=las;T.Assign(l,r,x);break;
			case 3:std::cin>>x,x^=las;T.Add(l,r,x);break;
			case 4:std::cin>>x>>y,x^=las,y^=las;T.Copy(l,r,x,y);break;
			case 5:std::cin>>x>>y,x^=las,y^=las;T.Swap(l,r,x,y);break;
			case 6:T.Reverse(l,r);break;
		}
	}
	T.print(T.root);
}
int main(){
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	solve();
	std::cerr<<"T.cnt:"<<T.cnt<<std::endl;
	return 0;
}
```

---

## 作者：Star_Cried (赞：9)

## P5586 序列加强版

### 题意

维护一个序列，支持区间求和、赋值、加值、复制、交换、翻转操作，其中交换和复制操作保证两段区间长度相等且不交。答案对 $1e9+7$ 取模。

### 思路

对于区间求和、赋值、加值、交换、翻转操作我们都可以很轻松地使用平衡树进行维护。所以现在的难点就在于复制操作：如何复制一段区间？

如果我们暴力复制的话，每次我们不得不将被复制的子树扫一遍进行复制，这是肯定不行的。

于是我们使用**可持久化平衡树**。其中心思想就是每次修改一个节点的信息时，将该节点复制一遍。这样我们在进行复制操作的时候就可以复制出来一个新的树而不会对原树有影响，而且因为不是每次都遍历子树，所以时间复杂度正确。

但是因为要丢弃之前的节点所以空间复杂度略微有些大。因为我们可以进行~~垃圾回收~~定期重构使得空间被合理重复利用。

于是这道题就解决了。我使用了 FHQ treap 进行实现，因为发现对于这些操作 FHQ 会比较方便。

然后这道题 ODT 被卡掉了（好耶）

### 细节和我犯过的错误

* 这是个定长的序列，所以我们每次重构的时候可以选择使用构建二叉搜索树的方法线性构建，~~否者会被卡常~~。

* **每次更改节点信息时都要进行复制**，`pushdown`,`merge`,`split` 函数和修改操作里都要复制。

* 注意 `pushdown` 和 `clone` 的前后顺序。有时候我们并不需要将原节点进行下传标记以免建出无用节点增大常数。

* 注意传参时用的是哪个节点的参数。我曾在 `split` 操作中下传原节点的儿子，实际上是复制后的节点的儿子。

* FHQ 在新建节点后的 `rand` 值占空间，我们用一段话在 `merge` 的时候现场随机，即：

  `rd(0,(e[a].siz+e[b].siz)-1)<e[a].siz`

  可以省下一点空间。

* 复制和交换的时候记住，给出的区间端点位置可不保证升序的。

* 重构之后再清空节点数，因为在遍历搜索树的时候会 `pushdown` 而新加节点。

### 代码



```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cctype>
#include<cstring>
#include<cmath>
#include<chrono>
#include<random>
using namespace std;
inline int read(){
	int w=0,x=0;char c=getchar();
	while(!isdigit(c))w|=c=='-',c=getchar();
	while(isdigit(c))x=x*10+(c^48),c=getchar();
	return w?-x:x;
}
char buf[1 << 21], a[20]; int p, p2 = -1;
inline void flush() {
	fwrite(buf, 1, p2 + 1, stdout);
	p2 = -1;
}
inline void print(int x) {
	if (p2 > 1 << 20) flush();
	if (x < 0) buf[++p2] = 45, x = -x;
	do a[++p] = x % 10 + 48;while (x /= 10);
	do buf[++p2] = a[p];while (--p);
} 
namespace star
{
	const int maxn=3e5+10,maxm=4e6+10,mod=1e9+7;
	mt19937 rnd(std::chrono::system_clock::now().time_since_epoch().count());
	int rd(int l,int r){return std::uniform_int_distribution<int>(l,r)(rnd);}
	int n,m,a[maxn];
	struct FHQ{
		#define ls e[ro].son[0]
		#define rs e[ro].son[1]
		struct node{
			int son[2],siz,tag,add,val,sum;
			bool rev;
		}e[maxm];
		int tot,rt;
		FHQ():e(),tot(0),rt(0){}
		inline void clone(int &x){e[++tot]=e[x],x=tot;}
		inline int newnode(int a){return e[++tot]=(node){{0,0},1,-1,0,a,a,false},tot;}
		inline void pushup(int ro){e[ro].siz=e[ls].siz+e[rs].siz+1,e[ro].sum=(1ll*e[ls].sum+e[rs].sum+e[ro].val)%mod;}
		void rev(int ro){if(ro)e[ro].rev^=1,swap(ls,rs);}
		void add(int ro,int v){if(ro)e[ro].val=(e[ro].val+v)%mod,e[ro].sum=(e[ro].sum+1ll*e[ro].siz*v)%mod,e[ro].add=(e[ro].add+v)%mod;}
		void assign(int ro,int v){if(ro)e[ro].val=v,e[ro].sum=1ll*e[ro].siz*v%mod,e[ro].add=0,e[ro].tag=v;}
		inline void pushdown(int ro){
			if(!e[ro].rev and e[ro].tag==-1 and !e[ro].add) return;
			if(ls) clone(ls);if(rs) clone(rs);
			if(e[ro].rev) rev(ls),rev(rs),e[ro].rev=false;
			if(e[ro].tag!=-1) assign(ls,e[ro].tag),assign(rs,e[ro].tag),e[ro].tag=-1;
			if(e[ro].add) add(ls,e[ro].add),add(rs,e[ro].add),e[ro].add=0;
		}
		int build(int l=1,int r=n){
			if(l>r)return 0;
			int mid=(l+r)>>1;
			int ro=newnode(a[mid]);
			ls=build(l,mid-1),rs=build(mid+1,r);
			pushup(ro);
			return ro;
		}
		int merge(int a,int b){
			if(!a or !b)return a|b;
			if(rd(0,(e[a].siz+e[b].siz)-1)<e[a].siz){
				clone(a),pushdown(a);
				e[a].son[1]=merge(e[a].son[1],b);
				pushup(a);return a;
			}else{
				clone(b),pushdown(b);
				e[b].son[0]=merge(a,e[b].son[0]);
				pushup(b);return b;
			}
		}
		void split(int ro,int k,int &a,int &b){
			if(!ro) return a=b=0,void();
			if(e[ls].siz<k) a=ro,clone(a),pushdown(a),split(e[a].son[1],k-e[e[a].son[0]].siz-1,e[a].son[1],b),pushup(a);
			else b=ro,clone(b),pushdown(b),split(e[b].son[0],k,a,e[b].son[0]),pushup(b);
		}
		inline void copy(){
			int l1=read(),r1=read(),l2=read(),r2=read(),a,b,c,d,e;int bk=1;
			if(r1>r2)swap(l1,l2),swap(r1,r2),bk=0;
			split(rt,r2,d,e);split(d,l2-1,c,d);split(c,r1,b,c);split(b,l1-1,a,b);
			if(bk) rt=merge(a,merge(b,merge(c,merge(b,e))));
			else rt=merge(a,merge(d,merge(c,merge(d,e))));
		}
		inline void Swap(){
			int l1=read(),r1=read(),l2=read(),r2=read(),a,b,c,d,e;
			if(r1>r2)swap(l1,l2),swap(r1,r2);
			split(rt,r2,d,e);split(d,l2-1,c,d);split(c,r1,b,c);split(b,l1-1,a,b);
			rt=merge(a,merge(d,merge(c,merge(b,e))));
		}
		inline void push(int ro){
			if(!ro)return;
			pushdown(ro);
			push(ls),a[++n]=e[ro].val,push(rs);
		}
		#undef ls
		#undef rs
	}S;
	inline void work(){
		n=read(),m=read();
		for(int i=1;i<=n;i++) a[i]=read();
		S.rt=S.build();
		while(m--){
			switch(read()){
				case 1:{
					int l=read(),r=read(),a,b,c;
					S.split(S.rt,r,b,c);S.split(b,l-1,a,b);
					printf("%d\n",S.e[b].sum);
					S.rt=S.merge(a,S.merge(b,c));
					break;
				}
				case 2:{
					int l=read(),r=read(),a,b,c;
					S.split(S.rt,r,b,c);S.split(b,l-1,a,b);
					S.clone(b);
					S.assign(b,read());
					S.rt=S.merge(a,S.merge(b,c));
					break;
				}
				case 3:{
					int l=read(),r=read(),a,b,c;
					S.split(S.rt,r,b,c);S.split(b,l-1,a,b);
					S.clone(b);
					S.add(b,read());
					S.rt=S.merge(a,S.merge(b,c));
					break;
				}
				case 4:S.copy();break;
				case 5:S.Swap();break;
				case 6:{
					int l=read(),r=read(),a,b,c;
					S.split(S.rt,r,b,c);S.split(b,l-1,a,b);
					S.clone(b);
					S.rev(b);
					S.rt=S.merge(a,S.merge(b,c));
					break;
				}
			}
			if(S.tot>3600000) n=0,
			S.push(S.rt),S.rt=S.tot=0,
			S.rt=S.build();
		}
		n=0,S.push(S.rt);
		for(int i=1;i<=n;i++) printf("%d ",a[i]);
	}
}
signed main(){
	star::work();
	flush();
	return 0;
}
```



---

## 作者：LJC00101 (赞：6)

这题是双倍经验[P5350](https://www.luogu.com.cn/problem/P5350)、[P5586](https://www.luogu.com.cn/problem/P5586)

~~希望题解也能是双倍经验~~

fhq的做法神鱼写了，这里写一下它的魔改版——可持久化ODT！

具体操作就是用fhq模拟ODT，然后可持久化。这样区间赋值时就能无脑压节点进行提速和减小内存，还不用打推平标记和下传，即使在加强版赋值较少的情况下也有加速效果。

这样，只需要在原来做法中的pushdown、pushup和split操作中进行改动就行了～

pushup：siz、sum算时用节点长度来算

pushdown：删掉区间赋值的标记和对应的下传操作

split：和之前一样，按子树大小分裂，如果分裂点在当前节点区间内就把节点一分为二并重新计算各项值

这里放一下代码
```cpp

        if (!now)
        {
            x = y = 0;
            return;
        }
        pushdown(now);
        if (k >= tr[tr[now].ls].siz + tr[now].len)
            //………………
        else if (k <= tr[tr[now].ls].siz)
            //………………
        else
            //………………分裂节点，记得可持久化
        return;
```

这样，再加上定期线性重构，在P5350中fhq就可以跑过ODT了（目前最优解），
在P5586中也可以-1s（赋值操作太少，还是跑不过用leefty tree的大佬）。

其实这题不够爽，可持久化平衡树就应该开1Gb才叫不卡空间（见P5055 【模板】可持久化文艺平衡树），然后不要线性重构，最后不输出序列，通过区间复制达到
1e18，才叫爽（按这个操作次数来算应该可以轻松通过时限，此题很大一部分时间化在线性重构上了）。

最后吐槽一下 **_ Wallace _** 常数好大。


**Code：**

```cpp
//相信各位都能轻松写出，我就不放了
```


这题调了好久，我还是太菜了。


---

## 作者：Leap_Frog (赞：5)

### P.S.
从 `03-27,11:54` 宣布要写写到 `03-27,16:25` 交了第一发代码。  
从 `03-27,16:25` 调到 `03-28 18:18:04` 正式 AC。  
这题也太毒瘤了罢，还有 @鰰 出来解释一下不卡空间是什么意思？  

### Description.
略。  

### Solution.
~~ODT 做完了~~，加强版卡 ODT。  
前置知识：[可持久化文艺平衡树](https://www.luogu.com.cn/problem/P5055)  
~~然后就做完了~~  
这题可以理解成模板的加强版。  
毕竟模板只有一个翻转操作，数据比较弱。  

首先，这个 `1/2/3/5/6` 操作都很显然很容易做。  
但是这个 `4` 操作如果暴力复制/暴力修改显然时间复杂度爆炸。  
那么我们直接强行对这棵树可持久化就好了。  
这样我们新插入一个结点时我们可以直接把这个结点复制一份然后插入。  
这样保证了时间复杂度的正确。  

我们每次下推标记时需要把两个孩子复制一份。  
这样才能保证之前的信息不被覆盖。  

然后就做完了，不过胡题 5min，写题 5h+。  

桥豆麻袋，这样写完一交，直接 RE！  
果然，这个不卡空间是假的，空间开 256MB 直接原地爆炸。  
所以我们需要定期重构。。。  
### Coding.
~~代码干货，不过在座的都能看得懂罢~~
```cpp
//是啊……你就是那只鬼了……所以被你碰到以后，就轮到我变成鬼了
#include<bits/stdc++.h>
using namespace std;typedef long long ll;
template<typename T>inline void read(T &x)
{
	x=0;char c=getchar(),f=0;
	for(;c<'0'||c>'9';c=getchar()) if(c=='-') f=1;
	for(;c>='0'&&c<='9';c=getchar()) x=(x<<1)+(x<<3)+(c^48);
	if(f) x=-x;
}
const int P=1e9+7;int st[7666666],tp,nn,a[500005];
struct node{int sm,vl,sz,ls,rs,pl,as;char rv;}T[7666666];int tt,rt,n,q;
inline void New(int &x,int w) {T[x=tp?st[tp--]:++tt]=(node){w,w,1,0,0,0,-1,0};}
inline void Del(int &x) {st[++tp]=x,T[x]=(node){0,0,0,0,0,0,0,0},x=0;}
inline void Cpy(int &x) {if(x) {int nx=tp?st[tp--]:++tt;T[nx]=T[x],x=nx;}}
inline int& mod(int &x) {return x>=P?x-=P:x,x;}
inline void pushup(int x) {T[x].sm=(0ll+T[T[x].ls].sm+T[T[x].rs].sm+T[x].vl)%P,T[x].sz=T[T[x].ls].sz+T[T[x].rs].sz+1;}
inline void allr(int x) {if(x) swap(T[x].ls,T[x].rs),T[x].rv^=1;}
inline void allp(int x,int c) {if(x) mod(T[x].vl+=c),mod(T[x].pl+=c),T[x].sm=(T[x].sm+1ll*T[x].sz*c)%P;}
inline void allf(int x,int c) {if(x) T[x].pl=T[x].rv=0,T[x].as=T[x].vl=c,T[x].sm=1ll*T[x].sz*c%P;}
inline void pushr(int x) {if(x&&T[x].rv) allr(T[x].ls),allr(T[x].rs),T[x].rv=0;}
inline void pushp(int x) {if(x&&T[x].pl) allp(T[x].ls,T[x].pl),allp(T[x].rs,T[x].pl),T[x].pl=0;}
inline void pushf(int x) {if(x&&~T[x].as) allf(T[x].ls,T[x].as),allf(T[x].rs,T[x].as),T[x].as=-1;}
inline void pushdw(int x)
{
	if(x&&(T[x].pl||T[x].rv||~T[x].as)) Cpy(T[x].ls),Cpy(T[x].rs);
	if(x&&(T[x].pl||T[x].rv||~T[x].as)) pushf(x),pushp(x),pushr(x);
}
inline char rnd(int a,int b) {return rand()%(a+b)<a;}
inline void split(int x,int k,int &a,int &b)
{
	if(!x) return a=b=0,void();else pushdw(x);
	if(k<=T[T[x].ls].sz) Cpy(b=x),split(T[b].ls,k,a,T[b].ls),pushup(b);
	else Cpy(a=x),split(T[a].rs,k-T[T[x].ls].sz-1,T[a].rs,b),pushup(a);
}
inline int merge(int a,int b)
{
	if(!a||!b) return a|b;
	if(rnd(T[a].sz,T[b].sz)) return pushdw(a),Cpy(a),T[a].rs=merge(T[a].rs,b),pushup(a),a;
	else return pushdw(b),Cpy(b),T[b].ls=merge(a,T[b].ls),pushup(b),b;
}
inline void Clear(int &x) {if(!x);else Clear(T[x].ls),Clear(T[x].rs),Del(x);}
inline void paint(int x) {if(!x);else pushdw(x),paint(T[x].ls),printf("%d ",T[x].vl),paint(T[x].rs);}
inline void pull(int x) {if(!x);else pushdw(x),pull(T[x].ls),a[++nn]=T[x].vl,pull(T[x].rs);}
inline int qry(int l,int r)
{
	int a,b,c,v;split(rt,r,b,c),split(b,l-1,a,b);
	return v=T[b].sm,rt=merge(a,merge(b,c)),v;
}
inline void ass(int l,int r,int v)
{
	int a,b,c;split(rt,r,b,c),split(b,l-1,a,b);
	Cpy(b),allf(b,v),rt=merge(a,merge(b,c));
}
inline void pls(int l,int r,int v)
{
	int a,b,c;split(rt,r,b,c),split(b,l-1,a,b);
	Cpy(b),allp(b,v),rt=merge(a,merge(b,c));
}
inline void swp(int l,int r,int x,int y)
{
	int a,b,c,d,e;if(l>x) swap(l,x),swap(r,y);
	split(rt,y,d,e),split(d,x-1,c,d),split(c,r,b,c),split(b,l-1,a,b);
	swap(b,d),rt=merge(a,merge(b,merge(c,merge(d,e))));
}
inline void psh(int l,int r,int x,int y)
{
	int a,b,c,d,e,f;if(l>x) swap(l,x),swap(r,y),f=1;else f=0;
	split(rt,y,d,e),split(d,x-1,c,d),split(c,r,b,c),split(b,l-1,a,b);
	if(f) Cpy(b=d);else Cpy(d=b);
	rt=merge(a,merge(b,merge(c,merge(d,e))));
}
inline void rev(int l,int r)
{
	int a,b,c;split(rt,r,b,c),split(b,l-1,a,b);
	Cpy(b),allr(b),rt=merge(a,merge(b,c));
}
inline void build(int &x,int l,int r)
{
	int md;if(l>r) return;else md=(l+r)>>1,New(x,a[md]);
	build(T[x].ls,l,md-1),build(T[x].rs,md+1,r),pushup(x);
}
int main()
{
	srand(114514),read(n),read(q);for(int i=1;i<=n;i++) read(a[i]);
	build(rt,1,n);for(int op,l,r,a,b,ls=0;q--;)
	{
		read(op),read(l),read(r),l^=ls,r^=ls;
		if(op==1) printf("%d\n",ls=qry(l,r));
		if(op==2) read(a),a^=ls,ass(l,r,a);
		if(op==3) read(a),a^=ls,pls(l,r,a);
		if(op==4) read(a),read(b),a^=ls,b^=ls,psh(l,r,a,b);
		if(op==5) read(a),read(b),a^=ls,b^=ls,swp(l,r,a,b);
		if(op==6) rev(l,r);
		if(tt>=6000000) nn=0,pull(rt),tt=tp=rt=0,build(rt,1,n);
	}
	return paint(rt),putchar('\n'),0;
}
```

---

## 作者：ケロシ (赞：1)

总所周知 fhq-treap 在处理区间复制的时候复杂度未知，所以我们需要复杂度正确的 WBLT （喜（为什么题解区没有 WBLT（恼

前置知识：[P5055 【模板】可持久化文艺平衡树](https://www.luogu.com.cn/problem/P5055) 的 WBLT 做法。

这应该是区间复制的板子题吧（恼

首先如果没有第四种复制操作是好做的，所以我们重点考虑复制操作。

来一个简单的复制例子，假如 WBLT 上的点 $u$ 代表序列 $A=(1,1,4)$，那么再来一个点 $v$，其左右两个儿子都是 $u$，那么 $v$ 就是 $A$ 复制两份出来，也就是 $(1,1,4,1,1,4)$。这就是重复利用平衡树中的节点以达到复制的效果。

但是发现一个问题，若我们想把 $v$ 从 $(1,1,4,1,1,4)$ 变成 $(1,1,4,5,1,4)$，那么肯定会递归到 $u$，然后 $u$ 改为了 $(5,1,4)$，但是因为 $v$ 的两个儿子都是 $u$，$v$ 就变为了 $(5,1,4,5,1,4)$。

所以更改的时候是不能更改 $u$ 的信息的，所以直接上持久化即可，将 $u$ 复制出一个 $u'$，在 $u'$ 上做更改，比如改成 $(5,1,4)$，这样的话 $v$ 就是 $(1,1,4,5,1,4)$ 了。

直接使用可持久化的平衡树维护就行了。

假设 $n,q$ 同阶，时间复杂度 $O(n \log n)$。

接下来是 WBLT 的代码部分，首先值得一提的是，WBLT 的 split 和 merge 都是不会破坏任何信息的，都是增加信息（这就是为什么 WBLT 空间超大（悲）），所以持久化只需要实现 pushdown 的部分即可，每次需要复制出一个新节点。

然后空间有点爆，反正维护的是一个序列，每次快爆的时候重构一下即可。

```cpp
const int N = 3e5 + 5;
const int M = 0.7e7 + 5;
const int P = 1e9 + 7;
inline int add(int x, int y) { return (x + y < P ? x + y : x + y - P); }
inline void Add(int & x, int y) { x = (x + y < P ? x + y : x + y - P); }
inline int mul(int x, int y) { return (1ll * x * y) % P; }
int n, m, a[N], cnt;
int rt, tot;
struct WBLT {
	int ls, rs, sz;
	int F, T1, T2, rev;
} t[M];
inline int add() {
	return ++ tot;
}
inline int add(int x) {
	int u = add();
	t[u] = {0, 0, 1, x, - 1, 0, 0};
	return u;
}
inline int copy(int u) {
	int v = add();
	t[v] = t[u];
	return v;
}
inline void up(int u) {
	t[u].sz = t[t[u].ls].sz + t[t[u].rs].sz;
	t[u].F = add(t[t[u].ls].F, t[t[u].rs].F);
}
inline int up(int l, int r) {
	int u = add();
	t[u] = {l, r, 0, 0, - 1, 0, 0};
	up(u);
	return u;
}
inline int push_rev(int u) {
	int v = copy(u);
	t[v].rev ^= 1;
	swap(t[v].ls, t[v].rs);
	return v;
}
inline int push_set(int u, int x) {
	int v = copy(u);
	t[v].F = mul(t[v].sz, x);
	t[v].T1 = x, t[v].T2 = 0;
	return v;
}
inline int push_add(int u, int x) {
	int v = copy(u);
	Add(t[v].F, mul(t[v].sz, x));
	Add(t[v].T2, x);
	return v;
}
inline void down(int u) {
	if(! t[u].ls) return;
	if(t[u].rev) {
		t[u].ls = push_rev(t[u].ls);
		t[u].rs = push_rev(t[u].rs);
		t[u].rev = 0;
	}
	if(t[u].T1 != -1) {
		t[u].ls = push_set(t[u].ls, t[u].T1);
		t[u].rs = push_set(t[u].rs, t[u].T1);
		t[u].T1 = -1;
	}
	if(t[u].T2) {
		t[u].ls = push_add(t[u].ls, t[u].T2);
		t[u].rs = push_add(t[u].rs, t[u].T2);
		t[u].T2 = 0;
	}
}
int build(int l, int r) {
	if(l == r) {
		return add(a[l]);
	}
	int mid = l + r >> 1;
	return up(build(l, mid), build(mid + 1, r));
}
void print(int u) {
	if(! t[u].ls) {
		a[++ cnt] = t[u].F;
		return;
	}
	down(u);
	print(t[u].ls);
	print(t[u].rs);
}
void rebuild() {
	cnt = 0;
	print(rt);
	tot = 0;
}
inline int merge(int u, int v) {
	if(! u || ! v) return u | v;
	if(t[u].sz <= t[v].sz * 4 && t[v].sz <= t[u].sz * 4) {
		return up(u, v);
	}
	if(t[u].sz >= t[v].sz) {
		down(u);
		int l = t[u].ls, r = t[u].rs;
		if(t[l].sz * 5 >= (t[u].sz + t[v].sz)) return merge(l, merge(r, v));
		down(r);
		return merge(merge(l, t[r].ls), merge(t[r].rs, v));
	}
	else {
		down(v);
		int l = t[v].ls, r = t[v].rs;
		if(t[r].sz * 5 >= (t[u].sz + t[v].sz)) return merge(merge(u, l), r);
		down(l);
		return merge(merge(u, t[l].ls), merge(t[l].rs, r));
	}
}
void split(int u, int k, int & x, int & y) {
	if(! u || ! k) {
		x = 0, y = u;
		return;
	}
	if(t[u].sz == k) {
		x = u, y = 0;
		return;
	}
	down(u);
	if(k <= t[t[u].ls].sz) {
		split(t[u].ls, k, x, y);
		y = merge(y, t[u].rs);
	}
	else {
		split(t[u].rs, k - t[t[u].ls].sz, x, y);
		x = merge(t[u].ls, x);
	}
}
inline void rotate(int u, int o) {
	if(! o) {
		down(t[u].ls);
		t[u].rs = up(t[t[u].ls].rs, t[u].rs);
		t[u].ls = t[t[u].ls].ls;
	}
	else {
		down(t[u].rs);
		t[u].ls = up(t[u].ls, t[t[u].rs].ls);
		t[u].rs = t[t[u].rs].rs;
	}
}
inline void maintain(int u) {
	if(t[t[u].ls].sz > t[t[u].rs].sz * 3)
		rotate(u, 0);
	else if(t[t[u].rs].sz > t[t[u].ls].sz * 3)
		rotate(u, 1);
}
int query(int u, int l, int r) {
	if(! u) return 0;
	chmax(l, 1); chmin(r, t[u].sz);
	if(r - l + 1 == t[u].sz) return t[u].F;
	int res = 0;
	down(u);
	int mid = t[t[u].ls].sz;
	if(l <= mid) Add(res, query(t[u].ls, l, r));
	if(mid < r) Add(res, query(t[u].rs, l - mid, r - mid));
	maintain(u);
	return res;	
}
void solve() {
	n = read(); m = read();
	FOR(i, 1, n) a[i] = read();
	rt = build(1, n);
	int lst = 0;
	FOR(i, 1, m) {
		if(tot > M - N * 5) {
			rebuild();
			rt = build(1, n);
		}
		int opt = read();
		int t0, t1, t2, t3, t4;
		if(opt == 1) {
			int l = read(), r = read();
			l ^= lst, r ^= lst;
			cout << (lst = query(rt, l, r)) << endl;
		}
		if(opt == 2) {
			int l = read(), r = read(), x = read();
			l ^= lst, r ^= lst; x ^= lst;
			split(rt, r, t0, t2);
			split(t0, l - 1, t0, t1);
			t1 = push_set(t1, x);
			rt = merge(merge(t0, t1), t2);
		}
		if(opt == 3) {
			int l = read(), r = read(), x = read();
			l ^= lst, r ^= lst; x ^= lst;
			split(rt, r, t0, t2);
			split(t0, l - 1, t0, t1);
			t1 = push_add(t1, x);
			rt = merge(merge(t0, t1), t2);
		}
		if(opt == 6) {
			int l = read(), r = read();
			l ^= lst, r ^= lst;
			split(rt, r, t0, t2);
			split(t0, l - 1, t0, t1);
			t1 = push_rev(t1);
			rt = merge(merge(t0, t1), t2);
		}
		if(opt == 4) {
			int l1 = read(), r1 = read(), l2 = read(), r2 = read(), o = 0;
			l1 ^= lst, r1 ^= lst; l2 ^= lst, r2 ^= lst;
			if(l1 > l2) swap(l1, l2), swap(r1, r2), o = 1;
			split(rt, r2, t0, t4);
			split(t0, l2 - 1, t0, t3);
			split(t0, r1, t0, t2);
			split(t0, l1 - 1, t0, t1);
			o ? t1 = t3 : t3 = t1;
			rt = merge(merge(merge(merge(t0, t1), t2), t3), t4);
		}
		if(opt == 5) {
			int l1 = read(), r1 = read(), l2 = read(), r2 = read();
			l1 ^= lst, r1 ^= lst; l2 ^= lst, r2 ^= lst;
			if(l1 > l2) swap(l1, l2), swap(r1, r2);
			split(rt, r2, t0, t4);
			split(t0, l2 - 1, t0, t3);
			split(t0, r1, t0, t2);
			split(t0, l1 - 1, t0, t1);
			rt = merge(merge(merge(merge(t0, t3), t2), t1), t4);
		}
	}
	rebuild();
	FOR(i, 1, n) cout << a[i] << " ";
	cout << endl;
}
```

---

## 作者：exCat (赞：0)

根据操作可以得知是基本数据结构练习题，然后区间翻转操作可知是平衡树 。

操作一，平衡树节点维护子树和，询问时分裂出区间 $[l,r]$ 输出根节点维护的子树和。

操作二，平衡树区间推平操作，维护一个标记即可。区间推平操作需注意赋初值，在可以推平为 $0$ 时千万不能用 $0$ 做初值。

操作三，区间加，同样维护一个标记即可。注意标记与标记之间的关系，区间推平标记会覆盖区间加。

操作四，区间复制操作。首先肯定是分裂出 $[l_1,r_1]$ 和  $[l_2,r_2]$ 两个区间，将 $[l_1,r_1]$ 的区间复制一份，代替 $[l_2,r_2]$ 合并回去即可 。考虑一定是新复制一份，如果直接两个位置用同一个子树，修改其中一个区间会导致另一个区间随之修改。又因为复制操作不可能直接遍历子树，只能复制根节点，又因为有其他修改操作，所以相当于要历史版本上的信息，所以考虑可持久化平衡树。

操作五，区间交换。分裂出区间直接交换。

操作六，区间翻转。打标记交换左右儿子。

但是这道题有卡空间，所以我们考虑定期重构（当节点大于一个阈值时，前序遍历一遍获得当前数组，然后线性构建出新树即可）。

可持久化平衡树的时间复杂度可能是 $O(n\log^2n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=3e5+10,M=4e6+10,mod=1e9+7; 
struct node
{
	int sum,siz,tag,tag1,tag2,ls,rs,val;//注意tag的定义  
}sh[M];
int n,m,rt,cnt,tot,a[N],lasans;

int newd(int x)
{
	int nd=++cnt;
	sh[nd]=(node){x,1,-1,0,0,0,0,x};
	return nd;
}
int copy(int x)
{
	int nd=newd(0);
	sh[nd]=sh[x];
	return nd;
}
void pushup(int x)
{
	sh[x].sum=((sh[sh[x].ls].sum+sh[sh[x].rs].sum)%mod+sh[x].val)%mod;
	sh[x].siz=(sh[sh[x].ls].siz+sh[sh[x].rs].siz)%mod+1;
}
void pd(int x,int tag,int tag1,int tag2)
{
	if(tag>=0)sh[x].sum=1ll*sh[x].siz*tag%mod,sh[x].val=sh[x].tag=tag,sh[x].tag1=0;
	if(tag1)sh[x].sum=(sh[x].sum+1ll*sh[x].siz*tag1%mod)%mod,sh[x].val=(sh[x].val+tag1)%mod,sh[x].tag1=(sh[x].tag1+tag1)%mod;
	if(tag2)swap(sh[x].ls,sh[x].rs),sh[x].tag2^=tag2;
	return ;
} 
void pushdown(int x)
{
	if(sh[x].tag==-1&&sh[x].tag1==0&&sh[x].tag2==0)return;
	if(sh[x].ls)
	{
		int nd=copy(sh[x].ls);
		pd(nd,sh[x].tag,sh[x].tag1,sh[x].tag2);
		sh[x].ls=nd;
	}
	if(sh[x].rs)
	{
		int nd=copy(sh[x].rs);
		pd(nd,sh[x].tag,sh[x].tag1,sh[x].tag2);
		sh[x].rs=nd;
	}
	sh[x].tag=-1,sh[x].tag1=sh[x].tag2=0;
	return ; 
}
int build(int l,int r)
{
	if(l>r)return 0;
	int mid=(l+r)>>1;int x=newd(a[mid]);
	sh[x].ls=build(l,mid-1);sh[x].rs=build(mid+1,r);//不是线段树啊 
	pushup(x);
	return x;
}
void dfs(int x)//前序遍历 
{
	pushdown(x);
	if(sh[x].ls)dfs(sh[x].ls);
	a[++tot]=sh[x].val;
	if(sh[x].rs)dfs(sh[x].rs); 
}
int merge(int x,int y) 
{
	if(!x||!y)return x+y;
	int yz=rand()%(sh[x].siz+sh[y].siz); 
	if(sh[x].siz>yz)
	{
		pushdown(x);
		sh[x].rs=merge(sh[x].rs,y);
		pushup(x);
		return x;
	} 
	else
	{
		pushdown(y);
		sh[y].ls=merge(x,sh[y].ls);
		pushup(y);
		return y;
	}
}
void spilt(int &x,int &y,int now,int k)
{
	if(!now)
	{
		x=y=0;
		return ;	
	}
	pushdown(now); 
	//cout<<now<<"  ";
	if(sh[sh[now].ls].siz<k)
	{
		x=copy(now);
		spilt(sh[x].rs,y,sh[now].rs,k-sh[sh[now].ls].siz-1);
		pushup(x);
	}
	else
	{
		y=copy(now);
		spilt(x,sh[y].ls,sh[now].ls,k);
		pushup(y);
	}
}
int main()
{
	//freopen("P5586_1.in","r",stdin);
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	srand(time(0));
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	rt=build(1,n);//先建树 
	for(int i=1;i<=m;i++)
	{
		int op,l1,r1,l2,r2,v,w,x,y,z;cin>>op>>l1>>r1;l1^=lasans;r1^=lasans; 
		if(op==1)
		{
			spilt(y,z,rt,r1);
			spilt(x,y,y,l1-1);//分裂出区间 
			cout<<sh[y].sum<<'\n';
			lasans=sh[y].sum;
			rt=merge(merge(x,y),z);
		}
		if(op==2)
		{
			cin>>l2;l2^=lasans;
			spilt(y,z,rt,r1);
			spilt(x,y,y,l1-1);//分裂出区间 
			sh[y].tag=l2,sh[y].tag1=0,sh[y].sum=1ll*l2*(r1-l1+1)%mod,sh[y].val=l2;
			rt=merge(merge(x,y),z);
		}
		if(op==3)
		{
			cin>>l2;l2^=lasans;
			spilt(y,z,rt,r1);
			spilt(x,y,y,l1-1);//分裂出区间 
			sh[y].tag1=(sh[y].tag1+l2)%mod,sh[y].sum=(sh[y].sum+1ll*l2*(r1-l1+1)%mod)%mod,sh[y].val=(sh[y].val+l2)%mod;
			rt=merge(merge(x,y),z);
		}
		if(op==4)
		{
			cin>>l2>>r2;l2^=lasans;r2^=lasans;
			if(l1<l2)
			{
				spilt(v,w,rt,l1-1);
				spilt(w,x,w,r1-l1+1);
				spilt(x,y,x,l2-r1-1);
				spilt(y,z,y,r2-l2+1);//注意是按位置分裂 
				//cout<<sh[v].siz<<"  "<<sh[w].siz<<" "<<sh[x].siz<<"  "<<sh[y].siz<<" "<<sh[z].siz<<'\n';
				int nd=copy(w);
				rt=merge(merge(merge(merge(v,w),x),nd),z);
			}
			else
			{
				spilt(v,w,rt,l2-1);
				spilt(w,x,w,r2-l2+1);
				spilt(x,y,x,l1-r2-1);
				spilt(y,z,y,r1-l1+1);//注意是按位置分裂 
				int nd=copy(y);
				rt=merge(merge(merge(merge(v,nd),x),y),z);
			}//序号不一定单增，分类讨论。 
		}
		if(op==5)
		{
			cin>>l2>>r2;l2^=lasans;r2^=lasans;
			if(l1>l2)swap(l1,l2),swap(r1,r2);
			spilt(v,w,rt,l1-1);
			spilt(w,x,w,r1-l1+1);
			spilt(x,y,x,l2-r1-1);
			spilt(y,z,y,r2-l2+1);
			rt=merge(merge(merge(merge(v,y),x),w),z);
		}
		if(op==6)
		{
			spilt(y,z,rt,r1);
			spilt(x,y,y,l1-1);//分裂出区间 
			sh[y].tag2^=1;swap(sh[y].ls,sh[y].rs); 
			rt=merge(merge(x,y),z);
		} 
		if(cnt>=3600000)//节点数过多，需要重构 
		{
			tot=0;
			dfs(rt);
			rt=cnt=0;
			rt=build(1,n); 
		}
	}
	tot=0;
	dfs(rt);
	for(int i=1;i<=n;i++)cout<<a[i]<<" ";
	cout<<'\n';
	return 0; 
}
```

---


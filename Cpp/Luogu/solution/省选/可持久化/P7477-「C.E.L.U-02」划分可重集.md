# 「C.E.L.U-02」划分可重集

## 题目描述

给你一个长度为 $n$ 的数列 $v$，请你将其划分成两个可重集 $a$ 和 $b$。你将从左至右开始划分，每个数必须至少被划分进一个可重集中。  
一个数 $v_i$ 可以被划分进 $a$ 当且仅当 $j<i \ and\ v_j\le v_i-k$ 的 $v_j$ 都没有被划分进当前的 $a$。一个数 $v_i$ 可以被划分进 $b$ 当且仅当 $j<i\ and\ v_j\ge v_i+k$ 的 $v_j$ 都没有被划分进当前的 $b$。  
同时给出了 $m$ 组关系，每组关系代表 $u$ 和 $v$ 不能划分进同一个可重集里。求能使划分成功的最小的 $k$。如果不存在合法划分，请输出 `-1`。

## 说明/提示

### 样例解释

**样例解释一**

以下是一组合法的划分：  
|6|2|8|5|7|3|
|:---:|:---:|:---:|:---:|:---:|:---:|
|a|b|b|a|b|a|

**样例解释二**

以下是一组合法的划分：  
|1|3|4|3|8|2|3|4|5|6|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|b|b|a|b|a|b|a|a|a|b|

### 数据范围 
|数据编号|$n$|$m$|
|:---:|:---:|:---:|
|$1\sim2$|$\le10^3$|$0$|
|$3\sim4$|$\le10^3$|$\le10^3$|
|$5\sim6$|$\le2\times10^4$|$0$|
|$7\sim10$|$\le2\times10^4$|$\le2\times10^4$|

对于 $100\%$ 的数据，$n,m\le2\times10^4,v_i\le10^9$，保证 $u<v\le n$，没有一对相同的 $u,v$。

## 样例 #1

### 输入

```
6 0
6 2 8 5 7 3```

### 输出

```
2```

## 样例 #2

### 输入

```
10 3
1 3 4 3 8 2 3 4 5 6
2 3
6 7
1 9
```

### 输出

```
5```

# 题解

## 作者：abruce (赞：13)

一个奇异的想法，结果调了我一周多。。。  
### 40pts(1)  
二分很好看出来，关键在判定。  
如果合法的话，一个数要么被划分进 $a$，要么被划分进 $b$，由此我们可以想用 2-SAT 去判定。这样，也能处理下面的 $u$ 和 $v$ 不在同一个可重集的问题。  
对于那两个基本条件，我们可以对于每一个 $j<i\ \text{and}\ v_j\le v_i-k$ 的 $j$ 都连一条 $j$ 选了 $a,i$ 就不能选 $a$ 的边。同理对于每一个 $j<i\ \text{and}\ v_j\ge v_i+k$ 的 $j$ 都连一条 $j$ 选了 $b,i$ 就不能选 $b$ 的边。  
我们现在可以暴力连边，虽然最多 $n^2$ 条边，但前面 40 分的数据还是可以通过的。  
### 40pts(2)  
再看 $m=0$ 的情况，$a$ 中的每个数保证了 $a_i<\min {a_j}+k$，$b$ 中的每个数保证了 $b_i>\max {b_j}-k$。  
现在我们记录 $a$ 中最小值和 $b$ 中最大值，每次来一个数看能不能放进去，放哪一个更优一些，然后更新。  
如果有一个放不进去，那就说明非法。（口胡算法）  
## 100pts  
显然这两个算法不能直接结合再一起，我们考虑优化其中一个算法。我们发现那个贪心算法比较难处理 $u$ 和 $v$ 之间不能连边，所以我们考虑优化第一个算法的连边过程。  
这相当于实在 2-SAT 中向 $j<i\ \text{and}\  v_j\le v_i-k $ 和 $j<i\ \text{and}\ v_j\ge v_i+k $ 分别连边。这时我们可以使用主席树或者树状数组（orz ー念之间、、）优化建图。  
假设将权值离散化后，我们将其建成了一个树状数组。  
![](https://cdn.luogu.com.cn/upload/image_hosting/hlxof0kh.png)  
我们接下来假设往入树中插入了节点1和2。  
![](https://cdn.luogu.com.cn/upload/image_hosting/ufzlkzcx.png)  
通过当前树状数组节点指向上一个的旧节点，我们可以通过这样得到以前的信息，从而优化建图。我们进行连边时，每次连向当前的树状数组节点就可以得到相应的边。  
注意细节。  
```cpp
#include<bits/stdc++.h>
using namespace std;
char __buf[1<<12],*__p1,*__p2;
//#define getchar() (__p1==__p2?(__p2=__buf+fread(__p1=__buf,1,1<<12,stdin),__p1==__p2?EOF:*__p1++):*__p1++)
inline int read() {
	int __x=0,__f=1;
	char __c=getchar();
	while(__c<'0'||__c>'9') {
		if(__c=='-')__f=-1;
		__c=getchar();
	}
	while(__c>='0'&&__c<='9') {
		__x=__x*10+__c-'0';
		__c=getchar();
	}
	return __x*__f;
}
char __F[200];
inline void write(int __x) {
	if(__x<0) {
		putchar('-');
		__x=-__x;
	}
	if(__x>=10)write(__x/10);
	putchar(__x%10+'0');
}
const int maxn=2e4+5,maxm=2e6+5;
struct edge {
	int next,to;
} e[maxm*4],w[maxn*8];
int a[maxn],g[maxn*2],book[maxn],bc,cnt,cnt2,h[maxm],dfn[maxm],low[maxm],col[maxm],color,n,m,s1[maxn][2],s2[maxn][2],tot,ans,ind,midd;
bool inst[maxm];
stack<int> s;
inline void addedge(int x,int y) {
	e[++cnt].next=h[x];
	e[cnt].to=y;
	h[x]=cnt;
}
inline void addedge2(int x,int y) {
	w[++cnt2].next=g[x];
	w[cnt2].to=y;
	g[x]=cnt2;
}
inline int lowbit(int x) {
	return x&(-x);
}
inline void add(int x,int y,int pd) {
//s1表示入树，s2表示出树。我们在向里面添加的时候，入树往它连边；它往出树连边。
	for(register int i=x; i<=bc; i+=lowbit(i)) {
		tot++;
		if(s1[i][pd]) {
			addedge(tot,s1[i][pd]);
			addedge(tot+1,s1[i][pd]+1);//往以前取到这个值的点连边
		}
		s1[i][pd]=tot;
		addedge(tot,y);
		addedge(tot+1,y+1);//把这个点挂在入树下面
		tot+=2;
		if(s2[i][pd]) {
			addedge(s2[i][pd],tot);//同理
			addedge(s2[i][pd]+1,tot+1);
		}
		s2[i][pd]=tot;
		addedge(y,tot);
		addedge(y+1,tot+1);
		tot++;
	}
}
inline void link(int x,int y,int pd) {
	int w=pd^1;
	for(register int i=x; i; i-=lowbit(i)) {
		if(s1[i][pd])addedge(y+pd,s1[i][pd]+w);//向对面连边
		if(s2[i][pd])addedge(s2[i][pd]+pd,y+w);
	}
}
inline void tarjan(int u) {
	s.push(u);
	inst[u]=1;
	dfn[u]=low[u]=++ind;
	for(register int i=h[u]; i; i=e[i].next) {
		int j=e[i].to;
		if(!dfn[j]) {
			tarjan(j);
			low[u]=min(low[u],low[j]);
		} else if(inst[j]) {
			low[u]=min(low[u],dfn[j]);
		}
	}
	if(u<=n*2) {//注意这里可能造成的数组越界
		for(register int i=g[u]; i; i=w[i].next) {
			int j=w[i].to;
			if(!dfn[j]) {
				tarjan(j);
				low[u]=min(low[u],low[j]);
			} else if(inst[j]) {
				low[u]=min(low[u],dfn[j]);
			}
		}
	}
	if(dfn[u]==low[u]) {
		color++;
		int k;
		do {
			k=s.top();
			s.pop();
			inst[k]=0;
			col[k]=color;
		} while(k!=u);
	}
}
inline bool check(int mid) {
	memset(h,0,sizeof(h));
	memset(dfn,0,sizeof(dfn));
	memset(low,0,sizeof(low));
	memset(col,0,sizeof(col));
	memset(s1,0,sizeof(s1));
	memset(s2,0,sizeof(s2));
	cnt=ind=color=0;
	while(!s.empty()) {
		s.pop();
	}
	tot=2*n;
	for(register int i=1; i<=n; i++) {
		int p=upper_bound(book+1,book+bc+1,a[i]-mid)-book-1;//注意是upper_bound
		if(p)link(p,i*2-1,0);
		p=lower_bound(book+1,book+bc+2,a[i]+mid)-book;//这里右边界是bc+1
		if(p<=bc)link(bc-p+1,i*2-1,1);
		p=lower_bound(book+1,book+bc+1,a[i])-book;
		add(p,i*2-1,0);
		add(bc-p+1,i*2-1,1);
	}
	for(register int i=1; i<=2*n; i++) {
		if(!dfn[i]) {
			tarjan(i);
		}
	}
	for(register int i=1; i<=n; i++) {
		if(col[i*2-1]==col[i*2]) {
			return 0;
		}
	}
	return 1;
}
int main() {
	int x,y;
	n=read(),m=read();
	for(register int i=1; i<=n; i++) {
		a[i]=read();
		book[++bc]=a[i];
	}
	sort(book+1,book+bc+1);
	bc=unique(book+1,book+bc+1)-book-1;//离散化
	book[bc+1]=book[bc]+1;//注意往比它大的连边时所取的值能不能取到最后一个。
	for(register int i=1; i<=m; i++) {
		x=read(),y=read();
		addedge2(x*2-1,y*2);
		addedge2(x*2,y*2-1);
		addedge2(y*2,x*2-1);
		addedge2(y*2-1,x*2);
	}
	for(register int i=1; i<=2*n; i++) {
		if(!dfn[i]) {
			tarjan(i);
		}
	}
	for(register int i=1; i<=n; i++) {
		if(col[i*2-1]==col[i*2]) {
			puts("-1");
			return 0;
		}
	}
	int l=1,r=1e9;
	while(l<=r) {
		int mid=(l+r)/2;
		if(check(mid)) {
			ans=mid;
			r=mid-1;
		} else {
			l=mid+1;
		}
	}
	write(ans);
	return 0;
}
```

---

## 作者：Jr_Zlw (赞：4)

## 二分 + 2-SAT + cdq优化建图

首先看到  $k$  的限制，  $k$  越大越不可能合法，可以二分。

然后考虑一个划分中一个数非  $a$  即  $b$  ，可以用  2-SAT  判定。

然后发现连边稍微有点多，但是连边的时候可以一下子连某个区间，考虑可以数据结构优化一下。

再细看一下，前两个条件都是偏序的形式，所以想到  cdq  分治。

第一维按原数组顺序即可，分治下去，用归并的方式可以将第二维排序。然后每次处理从右区间连向左区间的边。

可以发现，右区间对左区间的限制条件是一个前缀或后缀，可以考虑直接连出一条链然后把条件从链中间插进去。

假设当前分治区间  $[L,R]$    。

对于左区间  $[L,mid]$  的那条链可以这样建：

![](https://cdn.luogu.com.cn/upload/image_hosting/8w8qqft0.png)

那么可以发现，对于形如“若  $i$  进了  $a$  (或  $b$  )，则某个前缀中的点都进了  $b$  (或  $a$  )。” 的条件都有唯一对应的点。所以直接双指针找到对应点，模拟条件把区间  $[mid+1,R]$  的点往链上面连边就可以了。在代码中有详细说明。

然后直接跑  tarjan  判定  2-SAT  即可。

值得一提，跑完  tarjan  可以只用判定原先的点及对立点是否在同一个强连通分量中即可，因为  cdq  分治附加上的点与原先的点直接相关，不可能在原先的点符合条件的基础上这些点上出现矛盾。

不难发现，连出来的边是  $O(n\log n)$  的。因此总复杂度  $O(n\log n\log V)$   。

代码：

```
#include<cstdio>
#include<cstring>
#define rep(a,b,c) for(int c(a);c<=(b);++c)
#define drep(a,b,c) for(int c(a);c>=(b);--c)
#define grep(b,c) for(int c(head[b]);c;c=nxt[c])
typedef long long LL;
inline int read()
{
	int res=0;char ch=getchar();while(ch<'0'||ch>'9')ch=getchar();
	while(ch<='9'&&ch>='0')res=res*10+(ch^48),ch=getchar();return res;
}
template<typename T> inline T min(const T &x,const T &y){return x<y?x:y;}
const int N=2e4+10;int a[N],n,I[1000010]; struct Nd
{
	int p,v;inline Nd(const int &x=0,const int &y=0){p=x;v=y;}
	inline bool operator<(const Nd&x)const{return v==x.v?p<x.p:v<x.v;}
}w[N],t[N];
namespace TwoSat
{
	const int N=1e6+10,M=5e6+10;
	int head[N],des[M],nxt[M],cgt,S=1,low[N],dfn[N],tot,stk[N],top,cdt,h2[N],scc[N];bool iss[N];
	inline void ins(const int &x,const int &y){nxt[++cgt]=head[x];des[head[x]=cgt]=y;}
	inline void tarjan(const int &u)
	{
		iss[stk[++top]=u]=true;low[u]=dfn[u]=++cdt; grep(u,i)
		{
			int v=des[i];if(!dfn[v])tarjan(v),low[u]=min(low[u],low[v]);
			else if(iss[v])low[u]=min(low[u],low[v]);
		}
		if(dfn[u]==low[u]){int v;++tot;do iss[v=stk[top--]]=false,scc[v]=tot;while(u!=v);}
	}
	inline bool Judge()
	{
		cdt=tot=0;memset(dfn,0,(S+2)<<2);memset(scc,0,(S+2)<<2);
		rep(1,S,i)if(!dfn[i])tarjan(i);
//		rep(1,n,i)printf("(%d,%d) ",scc[i],scc[i+n]);puts("");printf("QAQAQ :: %d\n",tot);
		rep(1,n,i)if(scc[i]==scc[i+n])return false;
//		for(int i=n<<1|1;i<=S;i+=2)if(scc[i]==scc[i+1])return false;
		return true;
	}
}
using TwoSat::head;using TwoSat::cgt;using TwoSat::Judge;using TwoSat::ins;using TwoSat::h2;using TwoSat::S;
int idx[N][2],K;inline void cdq(const int &l,const int &r)
{
	//idx[i][0]   --> [i,r] all in a
	//idx[i][0]+1 --> [i,r] not all in a
	//idx[i][1]   --> [l,i] all in b
	//idx[i][1]+1 --> [l,i] not all in b
	if(l==r)return;const int &mid=(l+r)>>1;cdq(l,mid);cdq(mid+1,r);
	rep(l,mid,i)
	{
		ins(idx[i][0]=++S,w[i].p);ins(w[i].p+n,++S);
		ins(idx[i][1]=++S,w[i].p+n);ins(w[i].p,++S);
	}
	rep(l+1,mid,i)
	{
		ins(idx[i-1][0],idx[i][0]);ins(idx[i][0]+1,idx[i-1][0]+1);
		ins(idx[i][1],idx[i-1][1]);ins(idx[i-1][1]+1,idx[i][1]+1);
		//if()
	}
	int j=l-1;rep(mid+1,r,i)
	{
		while(j<mid&&w[j+1].v<=w[i].v-K)++j;
		if(j!=l-1)ins(w[i].p,idx[j][1]),ins(idx[j][1]+1,w[i].p+n);
		//if(w[i].p in a) [l,loc(w[i].v-K)] all in b
		//if([l,loc(w[i].v-K)] not all in b) w[i].p in b
	}
	j=mid+1;drep(r,mid+1,i)
	{
		while(j>l &&w[j-1].v>=w[i].v+K)--j;
		if(j!=mid+1)ins(w[i].p+n,idx[j][0]),ins(idx[j][0]+1,w[i].p);
		//if(w[i].p in b) [loc(w[i].v+K),r] all in a
		//if([loc(w[i].v+K),r] not all in b) w[i].p in a
	}
	int pl=l,pr=mid+1,p=l-1;while(pl<=mid&&pr<=r)t[++p]=w[pl]<w[pr]?w[pl++]:w[pr++];
	while(pl<=mid)t[++p]=w[pl++];while(pr<=r)t[++p]=w[pr++];rep(l,r,i)w[i]=t[i];
}
inline bool check(const int &k)
{
	memcpy(head,h2,(S+2)<<2);S=n*2;K=k;int lst=cgt;
	rep(1,n,i)w[i]=Nd(i,a[i]);cdq(1,n);
	bool res=Judge();cgt=lst;return res;
}
int main()
{
	n=read();int m=read();rep(1,n,i)a[i]=read();S=n*2;
	rep(1,m,i){int x=read(),y=read();ins(x,y+n);ins(x+n,y);ins(y,x+n);ins(y+n,x);}
	if(!Judge())return puts("-1"),0; memcpy(h2,head,(S+2)<<2);
	int l=0,r=1e9+10,res=-1,mid; while(l<=r)check(mid=(l+r)>>1)?r=mid-1,res=mid:l=mid+1;
	printf("%d\n",res);return 0;
}
```

---

## 作者：yspm (赞：2)

趣味练反应题

看起来 $n,m$ 只有 $2\times 10^4$，那我们来 $\Theta(n\sqrt n\log n)$ 的 KDT 优化建图吧！

为了方便，本文中将使用 $x_i$ 表示 $i$ 在第 $1$ 个集合中的情况，$x'_i$ 表示在第二个中的情况

对于答案为 $-1$ 的情况是给定的 $m$ 个相异集合的限制中产生了冲突，只建出 $2n$ 个点的图跑一遍 $\rm 2-sat$ 即可

不难发现是否可行具有单调性，所以二分答案 $mid$，将 $(i,v_i)$ 视作二维平面上的一个点，所以每个点将和一个矩形中的点产生互相限制

直接使用 KDT 优化建图可以将边数降至 $\Theta(n\sqrt n)$，而后续判断仍然使
用 `tarjan` 即可

关于 KDT 优化建图还是比较平凡的，按照与线段树优化建图相同的方式建立上向树和下向树，节点自己连向上向树，下向树连向节点自己，点和矩形之间的连边逐个矩形连即可

由于不想做口胡老鸽，所以还是写了代码

```cpp
const int N=2e4+10,M=4e5+10;
int scc,bel[M],nec[M],low[M],n,Q,dfn[M],tim,st[M],top,id1[M],id2[M];
vector<int> g[M];
bool vis[M];
inline void tarjan(int x){
    dfn[x]=low[x]=++tim; vis[st[++top]=x]=1;
    for(auto t:g[x]){
        if(!dfn[t]) tarjan(t),ckmin(low[x],low[t]);
        else if(vis[t]) ckmin(low[x],dfn[t]);
    }
    if(low[x]==dfn[x]){
        ++scc;
        do{
            bel[st[top]]=scc;
            vis[st[top]]=0;
        }while(st[top--]!=x);
    } return ;
}
struct Node{int pos[2],mx[2],mn[2],id;}t[N];
int ls[N],rs[N],tot,rt,v[N];
inline void push_up(int p){
    rep(i,0,1) t[p].mx[i]=t[p].mn[i]=t[p].pos[i];
    for(auto son:{ls[p],rs[p]}) if(son){
        rep(i,0,1){
            ckmin(t[p].mn[i],t[son].mn[i]);
            ckmax(t[p].mx[i],t[son].mx[i]);
        }
    } return ;
}
inline int up(int x,int tr){return 2*n+x+tr*n;}
inline int down(int x,int tr){return 4*n+x+tr*n;}
int lef[2],qid,rig[2];
inline bool in(int x){
    rep(i,0,1) if(t[x].mn[i]<lef[i]||t[x].mx[i]>rig[i]) return 0;
    return 1;
}
inline bool pin(int p){
    rep(i,0,1) if(lef[i]>t[p].pos[i]||rig[i]<t[p].pos[i]) return 0;
    return 1;
}
inline bool out(int p){
    rep(i,0,1) if(t[p].mx[i]<lef[i]||t[p].mn[i]>rig[i]) return 1;
    return 0;
}
inline void Query(int p,int cur){
    if(in(p)){
        g[qid+cur*n].pb(down(p,!cur));
        g[up(p,cur)].pb(qid+(!cur)*n);
        return ;
    }
    if(out(p)) return ;
    if(pin(p)){
        g[qid+cur*n].pb(t[p].id+(!cur)*n);
        g[t[p].id+cur*n].pb(qid+(!cur)*n);
    }
    if(ls[p]) Query(ls[p],cur); if(rs[p]) Query(rs[p],cur);
    return ;
}
inline bool check(int mid){
    rep(i,1,6*n){
        while(nec[i]<g[i].size()) g[i].pop_back();
        low[i]=dfn[i]=st[i]=bel[i]=0;
    } tim=top=0;
    rep(i,2,n){
        lef[0]=1; rig[0]=i-1; qid=i;
        lef[1]=0; rig[1]=v[i]-mid;
        if(lef[1]<=rig[1]) Query(rt,0);
        lef[1]=v[i]+mid; rig[1]=1e9;
        if(lef[1]<=rig[1]) Query(rt,1);
    }
    rep(i,1,6*n) if(!dfn[i]) tarjan(i);
    for(int i=1;i<=n;++i) if(bel[i]==bel[i+n]) return 0;
    return 1;
}
inline int build(int l,int r,int cur,int fat){
    if(r<l) return 0; int mid=(l+r)>>1;
    nth_element(t+l,t+mid,t+r+1,[&](const Node a,const Node b){
        return a.pos[cur]<b.pos[cur];
    });
    g[t[mid].id].pb(up(mid,0)); g[down(mid,0)].pb(t[mid].id);
    g[t[mid].id+n].pb(up(mid,1)); g[down(mid,1)].pb(t[mid].id+n);
    if(fat){
        rep(d,0,1){
            g[up(mid,d)].pb(up(fat,d));
            g[down(fat,d)].pb(down(mid,d));
        }
    }
    ls[mid]=build(l,mid-1,cur^1,mid); rs[mid]=build(mid+1,r,cur^1,mid);
    return push_up(mid),mid;
}
signed main(){
    tot=n=read(); Q=read(); 
    rep(i,1,n) t[i].id=t[i].pos[0]=i,t[i].pos[1]=v[i]=read();
    while(Q--){
        int u=read(),v=read();
        g[u+n].pb(v); g[v].pb(u+n);
        g[v+n].pb(u); g[u].pb(v+n);
    }
    rep(i,1,tot) if(!dfn[i]) tarjan(i);
    rep(i,1,n) if(bel[i]==bel[i+n]) puts("-1"),exit(0);
    rt=build(1,n,0,0);
    rep(i,1,6*n) nec[i]=g[i].size();
    int ans=1e9,r=1e9-1,l=0;
    while(l<=r){
        int mid=(l+r)>>1;
        if(check(mid)) ans=mid,r=mid-1;
        else l=mid+1;
    } print(ans);
    return 0;
}
```

---

## 作者：KingPowers (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P7477)

大套路题。

首先考虑如果限制只有给定的 $m$ 组关系该怎么做，不难发现就是一个简单的 2-SAT 问题：相当于是给定 $n$ 个变量，每个变量取 $0/1$ 的含义为划分到 $a$ 或 $b$ 集合。对于每组限制给定的 $x$ 和 $y$，在 $x_0$ 和 $y_1$、$x_1$ 和 $y_0$ 之间连双向边即可。

现在加入 $k$ 的限制，不难发现 $k$ 变大肯定更劣，因此可以二分 $k$，问题转化为在 $k$ 确定时判定是否有解。同样考虑 2-SAT，对于每个 $i$，向每个满足第一个条件的 $j$ 连边 $i_0\to j_1$ 和 $j_0\to i_1$，向每个满足第二个条件的 $j$ 连边 $i_1\to j_0$ 和 $j_1\to i_0$，跑 2-SAT 判定即可，但不难发现边数的上限为 $O(n^2)$，无法通过。

尝试优化建图的过程，不难发现连边的限制是一个二维偏序的形式，与 ARC165F 类似，套路地想到分治或者主席树，~~因为主席树优化建图我不会写~~，因此这里使用的是分治。

第一维的限制是下标，不需要在外部进行任何排序，在分治过程中对 $v_i$ 进行归并排序，每次只考虑右区间跨过中点对左区间的连边即可。不难发现右区间每个点对左区间的连边一定是一段前缀或者后缀，那么每一层分治只需要再做一个经典的前后缀优化建图就可以了，也就是新建出来几排虚点，连成条链，具体实现方式参考代码容易理解。

不难发现这样的边数为 $T(n)=2T(n/2)+O(n)=O(n\log n)$，因此带上外层二分总时间复杂度就是 $O(n\log n\log V)$ 的，其中 $V$ 为值域。

```cpp
#include<bits/stdc++.h>
#define For(i, a, b) for(int i = (a); i <= (b); i++)
#define Rof(i, a, b) for(int i = (a); i >= (b); i--)
using namespace std;
const int N = 1e6 + 5, M = 5e6 + 5;
struct node{
	int w, id;
}a[N], tmp[N];
int n, m, v[N], pre[N][2], suf[N][2];
struct edge{
	int nxt, to;
}e[M], te[M];
int tot, cnt, tcnt, head[N], thead[N];
int tim, id, top, low[N], dfn[N], col[N], st[N];
void add_edge(int u, int v){e[++cnt] = {head[u], v}; head[u] = cnt;}
void Tarjan(int now){
	dfn[now] = low[now] = ++tim;
	st[++top] = now;
	for(int i = head[now]; i; i = e[i].nxt){
		int to = e[i].to;
		if(!dfn[to]) Tarjan(to), low[now] = min(low[now], low[to]);
		else if(!col[to]) low[now] = min(low[now], dfn[to]);
	}
	if(low[now] == dfn[now]){
		col[now] = ++id;
		int x = st[top--];
		while(x != now){
			col[x] = id;
			x = st[top--];
		}
	}
}
bool solve_2sat(){  //以上主要是 2-SAT 部分
	tim = id = top = 0;
	memset(low, 0, sizeof low);
	memset(dfn, 0, sizeof dfn);
	memset(col, 0, sizeof col);
	For(i, 1, tot) if(!dfn[i]) Tarjan(i);
	For(i, 1, n) if(col[i] == col[i + n]) return 0;
	return 1;
}
void solve(int l, int r, int k){
	if(l == r) return;
	int mid = (l + r) >> 1, siz = l - 1;
	solve(l, mid, k); solve(mid + 1, r, k);
	For(i, l, mid){
		pre[i][0] = ++tot; pre[i][1] = ++tot;  //pre[i][0]:[l,i]的所有点都划分到了b pre[i][1]:[l,i]中存在一个点划分到了a
		add_edge(pre[i][0], a[i].id + n); add_edge(a[i].id, pre[i][1]);
		suf[i][0] = ++tot; suf[i][1] = ++tot;  //suf[i][0]:[i,mid]的所有点都划分到了a suf[i][1]:[i,mid]的所有点都划分到了b
		add_edge(suf[i][0], a[i].id); add_edge(a[i].id + n, suf[i][1]);
	}
	For(i, l + 1, mid){
		add_edge(pre[i][0], pre[i - 1][0]);
		add_edge(pre[i - 1][1], pre[i][1]);
		add_edge(suf[i - 1][0], suf[i][0]);
		add_edge(suf[i][1], suf[i - 1][1]);
	}
	for(int i = mid + 1, j = l - 1; i <= r; i++){  //每个点用双指针找出要连边的前缀
		while(j + 1 <= mid && a[j + 1].w <= a[i].w - k) j++;
		if(j >= l) add_edge(a[i].id, pre[j][0]), add_edge(pre[j][1], a[i].id + n);
	}
	for(int i = r, j = mid + 1; i >= mid + 1; i--){  //同上，不过是后缀
		while(j - 1 >= l && a[j - 1].w >= a[i].w + k) j--;
		if(j <= mid) add_edge(a[i].id + n, suf[j][0]), add_edge(suf[j][1], a[i].id);
	}
	int posl = l, posr = mid + 1;
	while(posl <= mid && posr <= r){  //按照vi归并
		if(a[posl].w < a[posr].w) tmp[++siz] = a[posl], posl++;
		else tmp[++siz] = a[posr], posr++;
	}
	while(posl <= mid) tmp[++siz] = a[posl], posl++;
	while(posr <= r) tmp[++siz] = a[posr], posr++;
	For(i, l, r) a[i] = tmp[i];
}
bool check(int mid){
	tot = 2 * n; cnt = tcnt;
	memcpy(e, te, sizeof te);
	memcpy(head, thead, sizeof thead);
	For(i, 1, n) a[i].w = v[i], a[i].id = i;
	solve(1, n, mid);
	return solve_2sat();
}
void Solve(){
	cin >> n >> m;
	For(i, 1, n) cin >> a[i].w, a[i].id = i, v[i] = a[i].w;
	For(i, 1, m){
		int x, y; cin >> x >> y;
		add_edge(x, y + n); add_edge(y, x + n);
		add_edge(x + n, y); add_edge(y + n, x);
	}
	memcpy(te, e, sizeof e);
	memcpy(thead, head, sizeof head);
	tcnt = cnt;
	int l = 0, r = *max_element(v + 1, v + n + 1), ans = -1;
	while(l <= r){
		int mid = (l + r) >> 1;
		if(check(mid)) r = mid - 1, ans = mid;
		else l = mid + 1;
	}
	cout << ans << '\n';
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	int T = 1; //cin >> T;
	while(T--) Solve();
	return 0;
}
```

---

## 作者：zxh923 (赞：0)

### 思路

很难评价这题调出来的时候我的精神状态。

首先这个 $k$ 明显可以二分，所以直接二分就好。

然后我们可以发现，一个数要么扔到 $a$ 里，要么扔到 $b$ 里。既不能都扔进去也不能都不扔进去，所以这两个东西是互斥的，然后就可以用 2-SAT 做了。

我们的限制形如，如果一个数扔到某一个可重集里，那么值在一个区间内的数不能扔到这个集合里，然后受限制这些数的位置都在当前位置以前。

因为有这个位置的限制，所以我们不能使用线段树优化建图，而需要使用主席树优化建图。

首先先离散化一下。

然后这个东西和线段树优化建图其实没有本质区别，但是会遇到一个问题，就是如果有多个相同的数，我连边只会连最后一个，前面的就连不到了。

所以我们需要在离散化的时候把这个数的位置也加进去一块离散化，这样就没有上面提到的问题了。

剩下的就是 2-SAT 板子了。

### 代码


```cpp
#include<bits/stdc++.h>
// #define int long long
#define N 20005
#define M N*20
#define K N*80
#define mod 998244353
#define pii pair<int,int>
#define x first
#define y second
#define mpi make_pair
using namespace std;
int T=1,n,m,tot,v[N],id[N][2],pos[4][N];
int dfn[K],low[K],stk[K],ts,top,col,d[K];
int rt[4][N],lsh,inf=2e9;
pii a[N];
bool ist[K];
int h[K],e[K<<1],ne[K<<1],idx;
pii f[N];
void adde(int a,int b){
	e[idx]=b;ne[idx]=h[a];h[a]=idx++;
}
struct ds_out{
	struct node{
		int ls,rs,id;
	}tr[M];
	int cnt;
	void add(int &u,int las,int l,int r,int p,int v){
		u=++cnt;
		tr[u]=tr[las];
		tr[u].id=++tot;
		if(l==r){
			adde(v,tr[u].id);
			return;
		}
		int mid=l+r>>1;
		if(p<=mid)add(tr[u].ls,tr[las].ls,l,mid,p,v);
		else add(tr[u].rs,tr[las].rs,mid+1,r,p,v);
		if(tr[u].ls){
			adde(tr[tr[u].ls].id,tr[u].id);
		}
		if(tr[u].rs){
			adde(tr[tr[u].rs].id,tr[u].id);
		}
	}
	void modify(int u,int l,int r,int L,int R,int id){
		if(L>R)return;
		if(!u)return;
		if(l>=L&&r<=R){
			adde(tr[u].id,id);
			return;
		}
		int mid=l+r>>1;
		if(L<=mid)modify(tr[u].ls,l,mid,L,R,id);
		if(R>mid)modify(tr[u].rs,mid+1,r,L,R,id);
	}
}d1,d2;
struct ds_in{
	struct node{
		int ls,rs,id;
	}tr[M];
	int cnt;
	void add(int &u,int las,int l,int r,int p,int v){
		u=++cnt;
		tr[u]=tr[las];
		tr[u].id=++tot;
		if(l==r){
			adde(tr[u].id,v);
			return;
		}
		int mid=l+r>>1;
		if(p<=mid)add(tr[u].ls,tr[las].ls,l,mid,p,v);
		else add(tr[u].rs,tr[las].rs,mid+1,r,p,v);
		if(tr[u].ls){
			adde(tr[u].id,tr[tr[u].ls].id);
		}
		if(tr[u].rs){
			adde(tr[u].id,tr[tr[u].rs].id);
		}
	}
	void modify(int u,int l,int r,int L,int R,int id){
		if(L>R)return;
		if(!u)return;
		if(l>=L&&r<=R){
			adde(id,tr[u].id);
			return;
		}
		int mid=l+r>>1;
		if(L<=mid)modify(tr[u].ls,l,mid,L,R,id);
		if(R>mid)modify(tr[u].rs,mid+1,r,L,R,id);
	}
}d3,d4;
void tar(int u){
	dfn[u]=low[u]=++ts;
	stk[++top]=u;
	ist[u]=1;
	for(int i=h[u];~i;i=ne[i]){
		int j=e[i];
		if(!dfn[j]){
			tar(j);
			low[u]=min(low[u],low[j]);
		}
		else if(ist[j])low[u]=min(low[u],dfn[j]);
	}
	if(low[u]>=dfn[u]){
		int y;
		col++;
		do{
			y=stk[top--];
			ist[y]=0;
			d[y]=col;
		}while(y!=u);
	}
}
void init(){
	for(int i=0;i<=tot;i++){
		dfn[i]=low[i]=0;
		ist[i]=0;
		d[i]=0;
		h[i]=-1;
	}
	d1.cnt=0;d2.cnt=0;
	d3.cnt=0;d4.cnt=0;
	for(int i=1;i<=n;i++){
		rt[0][i]=rt[1][i]=0;
		rt[2][i]=rt[3][i]=0;
	}
	col=top=ts=idx=0;
	tot=n*2;
}
bool check(int k){
	init();
	for(int i=1;i<=m;i++){
		int x=f[i].x,y=f[i].y;
		adde(id[x][0],id[y][1]);
		adde(id[y][0],id[x][1]);
		adde(id[x][1],id[y][0]);
		adde(id[y][1],id[x][0]);
	}
	int lim=lsh;
	for(int i=1;i<=n;i++){
		auto it=upper_bound(a+1,a+lsh+1,mpi(v[i],i))-a-1;
		d1.add(rt[0][i],rt[0][i-1],1,lim,it,id[i][0]);
		d2.add(rt[1][i],rt[1][i-1],1,lim,it,id[i][1]);
		d3.add(rt[2][i],rt[2][i-1],1,lim,it,id[i][0]);
		d4.add(rt[3][i],rt[3][i-1],1,lim,it,id[i][1]);
	}
	for(int i=2;i<=n;i++){
		{
			tot++;
			auto it=upper_bound(a+1,a+lsh+1,mpi(v[i],i))-a-1;
			auto it1=lower_bound(a+1,a+lsh+1,mpi(v[i]-k,inf))-a-1;
			d1.modify(rt[0][i],1,lim,it,it,tot);
			d4.modify(rt[3][i-1],1,lim,1,it1,tot);
			tot++;
			d1.modify(rt[0][i-1],1,lim,1,it1,tot);
			d4.modify(rt[3][i],1,lim,it,it,tot);
		}
		{
			tot++;
			auto it=upper_bound(a+1,a+lsh+1,mpi(v[i],i))-a-1;
			auto it1=lower_bound(a+1,a+lsh+1,mpi(v[i]+k,0))-a;
			d2.modify(rt[1][i],1,lim,it,it,tot);
			d3.modify(rt[2][i-1],1,lim,it1,lim,tot);
			tot++;
			d2.modify(rt[1][i-1],1,lim,it1,lim,tot);
			d3.modify(rt[2][i],1,lim,it,it,tot);
		}
	}
	for(int i=1;i<=n*2;i++){
		if(!dfn[i]){
			tar(i);
		}
	}
	for(int i=1;i<=n;i++){
		if(d[id[i][0]]==d[id[i][1]]){
			return 0;
		}
	}
	return 1;
}
void solve(int cs){
    if(!cs)return;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>v[i];
		a[i]={v[i],i};
	}
	sort(a+1,a+n+1);
	lsh=unique(a+1,a+n+1)-a-1;
	for(int i=1;i<=m;i++){
		cin>>f[i].x>>f[i].y;
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<2;j++){
			id[i][j]=++tot;
		}
	}
	int l=0,r=1e9,res=-1;
	while(l<=r){
		int mid=l+r>>1;
		if(check(mid)){
			r=mid-1;
			res=mid;
		}
		else l=mid+1;
	}
	cout<<res<<'\n';
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	// cin>>T;
	for(int cs=1;cs<=T;cs++){
		solve(cs);
	}
	return 0;
}
```

---


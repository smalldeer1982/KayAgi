# [COCI 2022/2023 #4] Mreža

## 题目背景

### 卡评测封号。

## 题目描述

市长 Mirko 住在一个有 $n$ 个社区的城市里，这 $n$ 个社区用 $n-1$ 条双向道路连接，满足从任何社区出发都可以到达任意其他社区。

Mirko 想升级一些道路以疏导交通。对于每条路，我们知道目前在这条路上汽车的行驶速度 $v_i$，升级所需花费 $c_i$ 和升级后在这条路上汽车的行驶速度 $s_i$。

有 $q$ 个不满意的市民来见 Mirko。每个人都有他们自己的升级建议。第 $i$ 个市民的建议是：「我们应该在升级社区 $a_i$ 和 $b_i$ 之间的道路上投资 $e_i$ 欧元。」

对于每个建议，Mirko 感兴趣的是，如果他的目标是使社区 $a_i$ 和 $b_i$ 之间的最低驾驶速度最大化，那么他在升级道路上最多花费 $e_i$ 欧元的话这个最低驾驶速度是多少。

Mirko 瞬间意识到这个问题不简单，并且他雇佣你来帮助他！


## 说明/提示

样例解释 $1$：下图展示了这个城市和社区。边上写的分别是目前汽车的行驶速度，升级花费和升级后的汽车行驶速度。

![](https://cdn.luogu.com.cn/upload/image_hosting/umum0365.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

如果我们升级 $1$ 和 $2$，$1$ 和 $3$ 之间的道路，从 $2$ 到 $4$ 的行驶速度将变成 $10,9,7$。最小为 $7$。

如果我们升级 $4$ 和 $3$ 之间的道路，从 $6$ 到 $4$ 的行驶速度将变成 $5,15$。最小为 $5$。

如果我们升级 $3$ 和 $5$ 之间的道路，从 $5$ 到 $3$ 的行驶速度将变成 $11$。

|子任务编号|	附加限制|	分值|
|:-:|:-:|:-:|
| $0$ | 是样例 | $0$ |
| $1$ | $n,q\le 1000$ |	$19$ |
| $2$ |	每个社区最多与两个其他社区相连 | $26$ |
| $3$ |	无附加限制 | $55$ |

## 样例 #1

### 输入

```
6
1 2 5 7 10
1 3 4 8 9
3 4 7 1 15
3 5 6 3 11
3 6 5 6 8
3
2 4 15
6 4 5
3 5 10```

### 输出

```
7
5
11```

## 样例 #2

### 输入

```
4
1 2 5 5 8
2 3 4 6 9
3 4 6 10 7
4
1 4 16
2 4 16
1 4 10
3 4 10```

### 输出

```
6
7
5
7```

# 题解

## 作者：_determination_ (赞：8)

暴力出奇迹！

其实这道题想到整体二分之后就非常好想且好写。我带调试大括号不换行的代码只有二百多行。

对于每个询问，我们二分可能达成的最低车速。注意到性质：

> 每个社区最多与两个其他社区相连。

这就意味着树是一条链且联想到是路径问题，果断树剖启动。

那么问题就来到了检查 $m$ 组询问，每组询问表示一个路径以及我需要达到的最低车速。

我们把车速离散化然后扔进 `vector` 里，然后维护一个指针递增表示当前车速。那么我们就可以用树状数组维护当前某段区间的升级代价以及是不是升级了也无法完成，然后这道题就做完了。

喜提最劣解，但是能过。复杂度 $O(n \log^3 n)$。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define inf (int)4e18
#define endl '\n'
using namespace std;
void debug(int x){cout << "debug " << x << endl;}
void debug(string s){cout << "debug " << s << endl;}
int n,m;
struct Edge{
	int v,v1,v2,s;
};
vector<Edge>e[100010];
int dep[100010],siz[100010],fa[100010],son[100010];
int v1[100010],v2[100010],s[100010];
void dfs1(int x,int f)
{
	dep[x]=dep[f]+1;
	fa[x]=f;
	for ( int i = 0 ; i < e[x].size() ; i++ )
	{
		int v=e[x][i].v;
		if(v==fa[x])
		{
			continue;
		}
		v1[v]=e[x][i].v1;
		v2[v]=e[x][i].v2;
		s[v]=e[x][i].s;
		dfs1(v,x);
		siz[x]+=siz[v];
		if(siz[son[x]]<siz[v])
		{
			son[x]=v;
		}
	}
	siz[x]++;
}
int top[100010],id[100010],bef[100010],tot;
void dfs2(int x,int head)
{
	if(!x)
	{
		return;
	}
	id[x]=++tot;
	bef[tot]=x;
	top[x]=head;
	dfs2(son[x],head);
	for ( int i = 0 ; i < e[x].size() ; i++ )
	{
		int v=e[x][i].v;
		if(v==son[x]||v==fa[x])
		{
			continue;
		}
		dfs2(v,v);
	}
}
struct Q{
	int u,v,val,l,r,mid,id;
}q[100010];
int check()
{
	for ( int i = 1 ; i <= m ; i++ )
	{
		if(q[i].l!=q[i].r)
		{
			return 0;
		}
	}
	return 1;
}
int cmp(Q p,Q q)
{
	return p.mid<q.mid;
}
vector<int>vec1[200010],vec2[200010];//vec1存当最低车速为x的时候需要升级的道路，vec2存当最低车速为x的时候无法通行的道路 
int t1[100010],t2[100010];
int lowbit(int x){return x&(-x);}
void upd(int t[],int x,int p)
{
	while(x<=n)
	{
		t[x]+=p;
		x+=lowbit(x);
	}
}
int calc(int t[],int x)
{
	int ans=0;
	while(x)
	{
		ans+=t[x];
		x-=lowbit(x);
	}
	return ans;
}
int getans(int u,int v)
{
	int ans=0;
	while(top[u]!=top[v])
	{
		if(dep[top[u]]<dep[top[v]])
		{
			swap(u,v);
		}
		int l=id[top[u]],r=id[u];
		if(calc(t2,r)-calc(t2,l-1))
		{
			return inf;
		}
		ans+=calc(t1,r)-calc(t1,l-1);
		u=fa[top[u]];
	}
	if(dep[u]<dep[v])
	{
		swap(u,v);
	}
	int l=id[v]+1,r=id[u];
	if(calc(t2,r)-calc(t2,l-1))
	{    
		return inf;
	}    
	ans+=calc(t1,r)-calc(t1,l-1);
	return ans;
}
int ans[100010];
int b[200010],sumb;
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin >> n ;
	for ( int i = 1 ; i < n ; i++ )
	{
		int u,v,v1,v2,s;
		cin >> u >> v >> v1 >> s >>v2;
		e[u].push_back({v,v1,v2,s});
		e[v].push_back({u,v1,v2,s});
		b[i*2-1]=v1;
		b[i*2]=v2;
	}
	cin >> m;
//	for ( int i = 1 ; i <= n*2-2 ; i++ )
//	{
//		cout << b[i] << " ";
//	}
//	cout << endl;
	sort(b+1,b+1+n*2-2);
//	debug(1);
	sumb=unique(b+1,b+1+n*2-2)-b-1;
//	debug("lsh");
	dfs1(1,1);
//	debug("114");
	dfs2(1,1);
	for ( int i = 1 ; i <= m ; i++ )
	{
		cin >> q[i].u >> q[i].v >> q[i].val;
		q[i].id=i;
		q[i].l=1;
		q[i].r=sumb;
		q[i].mid=(1+sumb+1)/2;
	}
	for ( int i = 2 ; i <= n ; i++ )
	{
		vec1[lower_bound(b+1,b+1+sumb,v1[i])-b+1].push_back(i);
		vec2[lower_bound(b+1,b+1+sumb,v2[i])-b+1].push_back(i); 
	}
	while(!check())
	{
		sort(q+1,q+1+m,cmp);
		int tot=1;
		memset(t1,0,sizeof(t1));
		memset(t2,0,sizeof(t2));
		for ( int i = 1 ; i <= m ; i++ )
		{
//			debug(q[i].id);
			while(tot<=q[i].mid)
			{
				for ( int j = 0 ; j < vec1[tot].size() ; j++ )
				{
					int v=vec1[tot][j];
					upd(t1,id[v],s[v]);
				}
				for ( int j = 0 ; j < vec2[tot].size() ; j++ )
				{
					int v=vec2[tot][j];
					upd(t2,id[v],1);
				}
				tot++;
			}
			int x=getans(q[i].u,q[i].v);
//			debug(x);
			if(x<=q[i].val)
			{
				q[i].l=q[i].mid;
			}else{
				q[i].r=q[i].mid-1;
			}
		}
		for ( int i = 1 ; i <= m ; i++ )
		{
			q[i].mid=(q[i].l+q[i].r+1)/2;
		}
	}
	for ( int i = 1 ; i <= m ; i++ )
	{
		ans[q[i].id]=q[i].l;
	}
	for ( int i = 1 ; i <= m ; i++ )
	{
		cout << b[ans[i]]<< endl;
	}
	return 0;
}
```

---

## 作者：Demeanor_Roy (赞：4)

- [原题链接](https://www.luogu.com.cn/problem/P9175)。

------------

挺好的一道题。

首先看到最小值最大，不难想到二分。但仔细思考，发现二分带给我们的便利是能清楚知道哪些边需要升级，可由于任意一个询问两点间边数都可以是   $O(n)$ 级别的，我们似乎很难直接维护。
 
于是我们接着想，既然每个询问所含边数过大，不便于一一遍历，那我们能不能将多个询问合在一起呢？这自然地引出了整体二分。

将边权离散化，我们将相同边权的边记在一起。每次整体二分时，边权小于等于 $mid$ 的边均需要升级，而我们此时需要快速维护的就是某个询问上需要升级的边的代价和。将代价记在每条边向下对应的点上。我们可以实时维护每个点到根节点的代价和，那么 $u,v$ 之间的代价就是

$$cost(u) + cost(v) - 2\times cost(Lca(u,v))$$

而对 $cost$ 地维护也是朴素的。具体地，每次点权修改都对应了一次子树内答案修改，于是树状数组维护 $dfn$ 序上区间加，单点查即可。

此时还有两个问题。第一是有些边可能升级了也不能满条件。我们可以预处理出两点间 $s$ 最大值，给二分加个上界即可。

第二则是整体二分时，我们需要将边权小于等于 $mid$ 的边标记，但我们不能全部枚举这些边，这样的话时间复杂度会假。于是可以考虑用**不撤销整体二分**的技巧，进入当前层时提前将边权在 $[1,l-1]$ 的边标记，当前层只处理 $[l,mid]$ 的边。具体可以看看 [这道题](https://www.luogu.com.cn/problem/P8955)。

时间复杂度 $O((n+q)\log^2n)$。

附核心代码：

```cpp
inline void solve(int l,int r,int L,int R)
{
	if(l==r)
	{
		for(int i=L;i<=R;i++) ans[q[i].id]=vec[l];
		return void();
	}
	int mid=(l+r)>>1,p1=0,p2=0;
	for(int i=l;i<=mid;i++) for(auto x:d[i]) add(dfn[to[x]],w[x]),add(dfn[to[x]]+sz[to[x]],-w[x]);
	for(int i=L;i<=R;i++)
		if(q[i].mx<=vec[mid]||query(dfn[q[i].x])+query(dfn[q[i].y])-query(dfn[q[i].anc])*2>q[i].w) q1[++p1]=q[i];
		else q2[++p2]=q[i];
	for(int i=1;i<=p1;i++) q[L+i-1]=q1[i];
	for(int i=1;i<=p2;i++) q[L+p1+i-1]=q2[i];
	solve(mid+1,r,L+p1,R);
	for(int i=l;i<=mid;i++) for(auto x:d[i]) add(dfn[to[x]],-w[x]),add(dfn[to[x]]+sz[to[x]],w[x]);
	solve(l,mid,L,L+p1-1);
}
```

这道题还有二分加主席树的办法，这里就不赘述了。


---

## 作者：未来姚班zyl (赞：3)

## 题目大意

有一颗边带权的树，每条边还可以花费 $c_i$ 的代价将边权提升至 $s_i$。多次询问在一条路径上，如果总共花费不能超过 $e$，最小边权的最大值。

## 题目分析

显然满足可二分性，二分答案，答案的上界是路径上 $s_i$ 的最小值，倍增或是树剖维护都可以。

对于二分的 $mid$，对于 $v_i<mid$ 的值则必须花费其代价升级，总花费就是这些代价的和，离散化 $v_i$ 用主席树即可，复杂度 $O(q\log n\log V)$。

当然，把 $s_i$ 也离散化，在主席树上二分，即可做到 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define L(x) xd[x].l
#define R(x) xd[x].r
#define mid (l+r>>1)
#define lc(x) L(x),l,mid
#define rc(x) R(x),mid+1,r
#define OK Ll<=l&&r<=Rr
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define repn(x) rep(x,1,n)
#define repm(x) rep(x,1,m)
#define e(x) for(int i=h[x],y=to[i];i;i=nxt[i],y=to[i])
#define Pi pair<int,int>
int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57)s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
void pf(int x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
using namespace std;
const int N =2e5+5,inf=(1LL<<31)-1;
int root[N],n=read(),m,h[N],to[N<<1],nxt[N<<1],dep[N],v[N<<1],tot,c[N<<1],s[N<<1],cnt,lsh[N],ln,b[N],f[N][18],g[N][18];
void add_(int a,int b,int cs,int d,int e){
    to[++cnt]=b,nxt[cnt]=h[a],h[a]=cnt,v[cnt]=cs,c[cnt]=d,s[cnt]=e;
}
struct seg{
    int l,r;
    ll s;
}xd[N*40];
int modify(int &x,int X,int l,int r,int p,int k){
    xd[++x]=xd[X],xd[x].s+=k;
    if(l==r)return x;
    int nw=x;
    return (p<=mid?L(nw)=modify(x,lc(X),p,k):R(nw)=modify(x,rc(X),p,k)),nw;
}
inline int query(int x,int y,int z,int l,int r,int Rr,ll lef){
    if(!Rr)return 1;
    if(l==r){
        ll k=xd[x].s+xd[y].s-2LL*xd[z].s;
        if(k<=lef)return l+1;
        return 1;
    }
    if(Rr<=mid)return query(L(x),L(y),lc(z),Rr,lef);
    ll lk=xd[L(x)].s+xd[L(y)].s-2LL*xd[L(z)].s;
    if(lk<=lef)return max(mid+1,query(R(x),R(y),rc(z),Rr,lef-lk));
    return query(L(x),L(y),lc(z),Rr,lef);
}
void dfs(int x,int fa){
    dep[x]=dep[fa]+1;
    rep(i,1,17)f[x][i]=f[f[x][i-1]][i-1],g[x][i]=min(g[x][i-1],g[f[x][i-1]][i-1]);
    e(x)if(y^fa)f[y][0]=x,g[y][0]=s[i],root[y]=modify(tot,root[x],1,ln,v[i],c[i]),dfs(y,x);
}
Pi lca(int x,int y){
    if(dep[x]<dep[y])swap(x,y);
    int del=dep[x]-dep[y],p=0,ans=inf;
    while(del){
        if(del&1)ans=min(ans,g[x][p]),x=f[x][p];
        del>>=1,p++;
    }
    per(i,17,0)if(f[x][i]^f[y][i])ans=min({ans,g[x][i],g[y][i]}),x=f[x][i],y=f[y][i];
    if(x==y)return {x,ans};
    return {f[x][0],min({ans,g[x][0],g[y][0]})};
}
int main(){
    for(int i=1,x,y,v,c,s;i^n;++i)x=read(),y=read(),v=lsh[(i<<1)-1]=read(),c=read(),s=lsh[i<<1]=read(),add_(x,y,v,c,s),add_(y,x,v,c,s);
    sort(lsh+1,lsh+n*2-1);
    rep(i,1,n*2-2)if(lsh[i]^lsh[i+1])b[++ln]=lsh[i];
    rep(i,1,cnt)v[i]=lower_bound(b+1,b+ln+1,v[i])-b,s[i]=lower_bound(b+1,b+ln+1,s[i])-b;
    repn(i)rep(j,0,17)g[i][j]=inf;
    dfs(1,0);
    m=read();
    repm(i){
        int x=read(),y=read(),la,r;
        Pi nw=lca(x,y);
        r=nw.second,la=nw.first;
        ll lim;
        scanf("%lld",&lim);
        pf(b[query(root[x],root[y],root[la],1,ln,r-1,lim)]),putchar('\n');
    }
    return 0;
}
```



---

## 作者：Genius_Star (赞：3)

### 思路：

**建议添加“树链剖分”和“分块”标签。**

因为答案肯定满足单调性，即如果使得最低驾驶速度为 $x$，那么 $x$ 之后的都可以实现。

所以可以对于每次询问二分答案，现在来确定上界和下界：

- 下界：社区 $a_i$ 到社区 $b_i$ 之间都不升级的速度的最小值。

- 上界：社区 $a_i$ 到社区 $b_i$ 之间都升级的速度的最小值。

直接去找的话复杂度是 $O(N)$ 的，肯定不优，发现是在树的两个简单路径间查询最小值，可以用树链剖分进行维护。

先将原树的边权转点权，即对于一条边 $(u_i,v_i)$，将边权转化为深度较深的点的点权。

这样维护一个最小值线段树，每次跳重链查询重链最小值，时间复杂度为 $O(\log^2 N)$。（注意当两个点在同一条重链时，不能将深度较低的点权算入答案，因为那记录的是它和它父亲的边权，不在查询范围内）

确立范围 $[L,R]$ 后，现在想想怎么写 ``check`` 函数。

设我们判断 $x$ 是否满足，即需要找到两点的简单路径间所有速度在 $x$ 以下的点升级所花费的总价钱 $sum$，判断 $sum$ 是否小于 $e_i$ 即可。

现在重点是找到两点的简单路径间所有速度在 $x$ 以下的点升级所花费的总价钱 $sum$。

发现还是可以用树链剖分来维护，每次查询一条链上速度在 $x$ 以下的点升级所花费的总价钱，感觉线段树好像没办法直接维护，如果开权值线段树的话树上主席树本蒻蒻又不会。

发现此题时限开的很大，于是就可以使用**分块**大法！

记 $V_{i,j}$ 表示第 $i$ 个块第 $j$ 大的元素。（对每个块直接暴力排序即可，复杂度为 $O(N \log \sqrt{N})$）

记 $S_{i,j}$ 表示第 $i$ 个块内前面 $j$ 大的元素升级所需要的总价钱。

那么我们查询一条重链，如果在同一个块，直接暴力就行；否则，先对散块进行暴力，对于整块 $i$ 二分出第一个大于等于 $x$ 的位置 $id+1$，则 $id$ 为小于 $x$ 且最接近 $x$ 的位置。

那么 $1 \sim id$ 都是小于 $x$ 的，都需要升级，那么可以累加答案为 $S_{i,id}$。

这样时间复杂度为：$O(Q \times \log^2 N \times \sqrt{N})$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=100100,M=sqrt(N)+100,INF=1e16; 
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
class Edge{
public:
	ll v;
	ll w1,w2;
	ll data;
};
class Node{
public:
	ll l,r;
	ll Min1,Min2;
}X[N<<2];
class Min{
public:
	ll x,y;
	Min(ll _x,ll _y){
		x=_x;
		y=_y;
	}
	Min(){};
	friend Min min(const Min &a,const Min &b){
		Min h;
		h.x=min(a.x,b.x);
		h.y=min(a.y,b.y);
		return h;
	}
};
struct St{
	ll x,y;
	bool operator<(const St&rhs)const{
		return x<rhs.x;
	}
	bool operator<(const ll&rhs)const{
		return x<rhs;
	}	
};
ll T,n,l,r,x,y,k,q,h,cnt=0;
ll fa[N],d[N],p[N],z[N],t[N];
ll w1[N],w2[N],c[N];
ll A[N],B[N],K[N],W1[N],W2[N],C[N];
ll L[N],R[N],H[M];
ll S[M][M];
St V[M][M];
vector<Edge> E[N];
void add(ll u,ll v,ll w1,ll w2,ll c){
	E[u].push_back({v,w1,w2,c});
	E[v].push_back({u,w1,w2,c});
}
void dfs1(ll u,ll f){
	p[u]=1;
	for(auto t:E[u]){
		ll v=t.v;
		if(v==f)
		  continue;
		fa[v]=u;
		d[v]=d[u]+1;
		w1[v]=t.w1,w2[v]=t.w2,c[v]=t.data;
		dfs1(v,u);
		p[u]+=p[v];
		if(p[v]>p[z[u]])
		  z[u]=v; 
	}
}
void dfs2(ll u,ll k){
	A[u]=++cnt;
	B[cnt]=u;
	t[u]=k;
	W1[cnt]=w1[u],W2[cnt]=w2[u],C[cnt]=c[u];
	if(!z[u])
	  return ;
	dfs2(z[u],k);
	for(auto t:E[u]){
		ll v=t.v;
		if(v==fa[u]||v==z[u])
		  continue;
		dfs2(v,v);
	}
}
void pushup(ll k){
	X[k].Min1=min(X[k<<1].Min1,X[k<<1|1].Min1);
	X[k].Min2=min(X[k<<1].Min2,X[k<<1|1].Min2);
}
void init(ll x){
	ll l=L[x],r=R[x];
	H[x]=0;
	for(int i=l;i<=r;i++)
	  V[x][++H[x]]={W1[i],C[i]};
	sort(V[x]+1,V[x]+H[x]+1);
	for(int i=1;i<=H[x];i++)
	  S[x][i]=S[x][i-1]+V[x][i].y;
}
void init(){
	ll k=sqrt(n);
	T=n/k;
	if(n%k!=0)
	  T++;
	for(int i=1;i<=T;i++){
		L[i]=(i-1)*k+1;
		R[i]=i*k;
	} 
	R[T]=n;
	for(int i=1;i<=n;i++)
	  K[i]=(i-1)/k+1;
	for(int i=1;i<=T;i++)
	 init(i);
}
void build(ll k,ll l,ll r){
	X[k].l=l,X[k].r=r;
	if(l==r){
		if(l==1)
		  X[k].Min1=X[k].Min2=INF;
		else{
			X[k].Min1=W1[l];
			X[k].Min2=W2[l];			
		}
		return ;
	}
	ll mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	pushup(k);
}
Min qurey(ll k,ll l,ll r){
	if(X[k].l==l&&r==X[k].r)
	  return {X[k].Min1,X[k].Min2};
	ll mid=(X[k].l+X[k].r)>>1;
	if(r<=mid)
	  return qurey(k<<1,l,r);
	else if(l>mid)
	  return qurey(k<<1|1,l,r);
	else
	  return min(qurey(k<<1,l,mid),qurey(k<<1|1,mid+1,r));
}
Min Find(ll u,ll v){
	Min ans(INF,INF);
	while(t[u]!=t[v]){
		if(d[t[u]]<d[t[v]])
		  swap(u,v);
		ans=min(ans,qurey(1,A[t[u]],A[u]));
		u=fa[t[u]];
	}
	if(d[u]>d[v])
	  swap(u,v);
	if(u!=v)
	  ans=min(ans,qurey(1,A[u]+1,A[v]));
	return ans;
}
ll Find(ll x,ll y,ll z){
	ll ans=0;
	ll l=K[x],r=K[y];
	if(l==r){
		for(int i=x;i<=y;i++)
		  if(W1[i]<z)
		    ans+=C[i];
	}
	else{
		for(int i=x;i<=R[l];i++)
		  if(W1[i]<z)
		    ans+=C[i];
		for(int i=L[r];i<=y;i++)
		  if(W1[i]<z)
		    ans+=C[i];	
		for(int i=(l+1);i<=(r-1);i++){
			if(V[i][1].x>=z)
			  continue;
			ll t=lower_bound(V[i]+1,V[i]+H[i]+1,z)-(V[i]+1);
			ans+=S[i][t];
		}	
	}
	return ans;
}
bool check(ll u,ll v,ll z,ll k){
	ll ans=0;
	while(t[u]!=t[v]){
		if(d[t[u]]<d[t[v]])
		  swap(u,v);
		ans+=Find(A[t[u]],A[u],k);
		u=fa[t[u]];
		if(ans>z)
		  return 0;
	}	
	if(d[u]>d[v])
	  swap(u,v);
	if(u!=v)
	  ans+=Find(A[u]+1,A[v],k);
	if(ans>z)
	  return 0;
	return 1;
}
int main(){
	n=read();
	for(int u,v,a,b,c,i=1;i<n;i++){
		u=read(),v=read(),a=read(),b=read(),c=read();
		add(u,v,a,c,b);
	}
	dfs1(1,1);
	dfs2(1,1);
	build(1,1,cnt);
	init();
	q=read();
	while(q--){
		x=read(),y=read(),h=read();
		Min k=Find(x,y);
		l=k.x,r=k.y;
		while(l<r){
			ll mid=(l+r+1)>>1;
			if(check(x,y,h,mid))
			  l=mid;
			else
			  r=mid-1;
		}
		write(l);
		putchar('\n');
	}
	return 0;
}
```


---

## 作者：vicissitudes (赞：1)

# 前置知识
二分答案，主席树，倍增。

以此题解纪念我学了一晚上的可持久化数据结构。

# 思路
~~思路就是暴力思路。~~

我们先把从 $a$ 到 $b$ 的路径全部拎出来，二分一个最低速度 $mid$，如果这条边的初始速度 $v$ 小于最低速度 $mid$，那么我们就要花费这条边的费用 $c$ 升级。如果升级后的速度 $s$ 还是小于最低速度 $mid$，那么答案不合法。

方便起见，我们可以把答案上界取为这些边 $s$ 的最小值。

那么我们的花费就是这些边中初始速度 $v$ 小于答案 $mid$ 的费用 $c$ 之和。

最后判断一个答案的总花费是否小于 $e$ 就行。

# 实现
问题是怎么把边找出来呢？

暴力肯定是找 $lca$ 然后一个一个跳所有边。

考虑优化找边的过程，为了方便，先把边的值变到点上去。

我们要执行以下操作：

* 找 $a$ 到 $b$ 上的最小 $s$。

* 找到 $a$ 到 $b$ 上的所有点。

* 求出这些点中 $v$ 小于 $mid$ 的 $c$ 之和。

对于第一个问题，我们可以在倍增求 $lca$ 时一起求出来，类似与 $st$ 表。

对于第二个问题，我们可以考虑将 $a$ 和 $b$ 到根节点的所有点存下来。记 $a$ 到根节点的所有点的答案为 $cost(a)$,可以发现最后的答案就是 $cost(a) + cost(b) - 2 \times cost(lca(a, b))$。

如果是开数组的话，空间会爆。

可以考虑主席树的思想，节省空间。

对于最后一个就是线段树的基本操作了，这里的主席树是权值线段树。

注意：这里的 $s$ 很大，用主席树要离散化。

# 参考
## 倍增求lca以及路径上s最小值
```cpp
void bfs() {
	queue<int> q;
	q.push(1);
	dep[1] = 1;
	memset(st, 0x3f, sizeof st);
	while(q.size()) {
		int t = q.front(); q.pop();
		for(node to : vec[t]) {
			int v = to.to;
			if(dep[v]) continue;
			dep[v] = dep[t] + 1;
			fa[v][0] = t;
			val[v] = {to.v, to.c, to.s};
			st[v][0] = val[v].s;
			update(rt[v], rt[t], 1, cnt, val[v].v, val[v].c);
			for(int i = 1; i < 20; i ++) {
				fa[v][i] = fa[fa[v][i - 1]][i - 1];
				st[v][i] = min(st[v][i - 1], st[fa[v][i - 1]][i - 1]);
			}			
			q.push(v);
		}
	}
}

ll lca(ll a, ll b, ll &s) {
	if(dep[a] < dep[b]) swap(a, b);
	for(int i = 19; i >= 0; i --) {
		if(dep[fa[a][i]] >= dep[b]) {
			s = min(s, st[a][i]);
			a = fa[a][i];
		}
	}
	if(a == b) return a;
	for(int i = 19; i >= 0; i --) {
		if(fa[a][i] != fa[b][i]) {
			s = min(s, st[a][i]);
			s = min(s, st[b][i]);
			a = fa[a][i];
			b = fa[b][i];
		}
	} 
	s = min(s, st[a][0]);
	s = min(s, st[b][0]);
	return fa[a][0];
}
```

## 主席树的建树，插入，查询
```cpp
void build(ll &u, ll l, ll r) {
	if(!u) u = ++ tot;
	ll mid = l + r >> 1;
	if(l < r) {
		build(tr[u].l, l, mid);
		build(tr[u].r, mid + 1, r);
	} 
}
void update(ll &u, ll v, ll l, ll r, ll x, ll c) {
	if(!u) u = ++ tot;
	tr[u] = tr[v], tr[u].val = tr[v].val + c;
	if(l < r) {
		ll mid = l + r >> 1;
		if(x <= mid) update(tr[u].l = 0, tr[v].l, l, mid, x, c);
		else update(tr[u].r = 0, tr[v].r, mid + 1, r, x, c);
	}
}
ll query(ll u, ll l, ll r, ll ql, ll qr) {
	if(ql <= l && r <= qr) return tr[u].val;
	ll mid = l + r >> 1;
	ll ans = 0;
	if(mid >= ql) ans += query(tr[u].l, l, mid, ql, qr);
	if(mid < qr) ans += query(tr[u].r, mid + 1, r, ql, qr);
	return ans; 
}
```
## 二分的check
```cpp
bool check(ll a, ll b, ll p, ll mid, ll c) {
	ll d1 = query(rt[a], 1, cnt, 1, mid - 1);
	ll d2 = query(rt[b], 1, cnt, 1, mid - 1);
	ll d3 = query(rt[p], 1, cnt, 1, mid - 1);
	return d1 - d3 + d2 - d3 <= c;
}
```
主函数就不放了。

---

## 作者：_AyachiNene (赞：1)

# 思路：
看到最小值最大化想到用二分。对于每一个询问设二分的 $mid$ 为最小速度，如果一条边不用花钱就能达到 $mid$ 显然是不用管它的，如果花了钱还不能达到下界，那么过这个点的路径显然不能满足条件，如果花了钱可以让边的速度达到下界，就把这条边的权值加上，最后要问一条路径上的和，用树剖维护下就行了。优化成满分有两种做法，用主席树或整体二分，两种做法都有一个用双指针加边的环节，这里有一个细节，如果在一个 $mid$ 一条边花了钱刚好能满足，如果 $mid$ 变大了可能有不能满足，所以要用一个小根堆，把不合法的边踢出去。其他就没有什么难度了。复杂度 $O(n\log^3n)$。
# Code:
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read()
{
	int res=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9'){res=(res<<1)+(res<<3)+(c^48);c=getchar();}
	return res*f;
}
void write(int x)
{
	if(x<0){x=-x;putchar('-');}
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
struct edge
{
	int id,v,c,s;
}a[114514];
bool cmp1(edge x,edge y)
{
	return x.v<y.v;
}
struct que
{
	int u,v,w,id,l,r;
}q[114514];
bool cmp2(que x,que y)
{
	return (x.l+x.r>>1)<(y.l+y.r>>1);
}
struct node
{
	int nxt,to,id;
}e[114514<<1];
int head[114514],cnt_edge;
void add_edge(int u,int v,int id)
{
	e[++cnt_edge].to=v;
	e[cnt_edge].id=id;
	e[cnt_edge].nxt=head[u];
	head[u]=cnt_edge;
}
int n,m;
namespace Elaina		//树状数组，0记录答案，1标记不合法的边 
{
	int t[114514][2]; 
	inline int lowbit(int x){return x&-x;}
	inline void add(int x,int v,int id){for(;x<=n;x+=lowbit(x))t[x][id]+=v;}
	inline int Query(int x,int id){int res=0;for(;x;x-=lowbit(x))res+=t[x][id];return res;}
	inline int query(int x,int y,int id){return x>y?0:Query(y,id)-Query(x-1,id);}
}
int siz[114514],f[114514],dep[114514],son[114514],top[114514],dfn[114514],cnt;
void dfs1(int u,int fa)
{
	f[u]=fa;
	siz[u]=1;
	dep[u]=dep[fa]+1;
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==fa) continue;
		a[e[i].id].id=v;
		dfs1(v,u);
		siz[u]+=siz[v];
		if(siz[son[u]]<siz[v])
			son[u]=v;
	}
}
void dfs2(int u,int t)
{
	top[u]=t;
	dfn[u]=++cnt;
	if(son[u]) dfs2(son[u],t);
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==f[u]||v==son[u]) continue;
		dfs2(v,v);
	}
}
int query(int x,int y)
{
	int res=0;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		res+=Elaina::query(dfn[top[x]],dfn[x],0);
		if(Elaina::query(dfn[top[x]],dfn[x],1)) return 1e18+10;
		x=f[top[x]];
	}
	if(dfn[x]>dfn[y]) swap(x,y);
	res+=Elaina::query(dfn[x]+1,dfn[y],0);
	if(Elaina::query(dfn[x]+1,dfn[y],1)) return 1e18+10;
	return res;
}
int ans[114514];
priority_queue<pair<int,int> >pq;
signed main()
{
	freopen("road.in","r",stdin);
	freopen("road.out","w",stdout);
	n=read();
	for(int i=1;i<n;i++)
	{
		int x=read(),y=read(),v=read(),c=read(),s=read();
		add_edge(x,y,i);add_edge(y,x,i);
		a[i].v=v,a[i].c=c,a[i].s=s;
	}
	dfs1(1,0);
	dfs2(1,1);
	m=read();
	for(int i=1;i<=m;i++)
		q[i].u=read(),q[i].v=read(),q[i].w=read(),q[i].l=1,q[i].r=1e9,q[i].id=i;
	sort(a+1,a+n,cmp1);
	for(int t=1;t<=30;t++)                //非递归整体二分，不带修的题用这个很好打 
	{
		memset(Elaina::t,0,sizeof Elaina::t);
		while(pq.size()) pq.pop();
		sort(q+1,q+m+1,cmp2);
		int cur=1;
		for(int i=1;i<=m;i++)
		{
			if(q[i].l>q[i].r) continue;
			int mid=q[i].l+q[i].r>>1;
			while(cur<n&&a[cur].v<mid)
			{
				if(a[cur].s>=mid)
				{
					Elaina::add(dfn[a[cur].id],a[cur].c,0);
					pq.push(make_pair(-a[cur].s,cur));
				}
				else Elaina::add(dfn[a[cur].id],1,1);
				++cur;
			}
			while(pq.size()&&-pq.top().first<mid)   //把不合法的边踢了 
			{
				int cur=pq.top().second;
				Elaina::add(dfn[a[cur].id],1,1);
				pq.pop();
			}
//			cout<<mid<<" "<<q[i].id<<" "<<query(q[i].u,q[i].v)<<" "<<q[i].l<<" "<<q[i].r<<endl;
			if(query(q[i].u,q[i].v)<=q[i].w&&query(q[i].u,q[i].v)>=0)      //合法就提高下界，不合法就降低下界 
				q[i].l=mid+1,ans[q[i].id]=mid;
			else q[i].r=mid-1;
		}
	}
	for(int i=1;i<=m;i++)	
		write(ans[i]),puts("");
	return 0;
}
```

---

## 作者：_sunkuangzheng_ (赞：1)

看到问题形式容易想到二分，考虑怎么检验答案。我们二分速度 $x$，首先要将原本速度 $< x$ 的边全部升级，然后需要判断升级后最小值是否达到 $x$。

我们现在需要维护的有：树链上 $s_i$ 最小值、树链上原始速度 $v_i < x$ 的所有 $c_i$ 的和。第一个可以树上倍增，第二个可以主席树。时间复杂度 $\mathcal O(n \log n \log V)$。

注意 $v_i$ 需要离散化。

```cpp
/**
 *    author: sunkuangzheng
 *    created: 07.11.2023 07:16:05
**/
#ifdef DEBUG_LOCAL
#include <mydebug/debug.h>
#endif
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+5;
struct tree{int l,r,w;long long s;}t[N*50];vector<tuple<int,int,int,int>> g[N];
int tot,fa[N][24],n,mn[N][24],dep[N],a[N],b[N],rt[N],c[N],d[N],ta,tb,tc,le,q,u,v,lc;long long w;
inline int upd(int s,int l,int r,int x,int y){
    int p = ++tot,mid = (l + r) / 2;t[p] = t[s],t[p].w ++,t[p].s += y;
    if(l == r) return p;
    if(x <= mid) t[p].l = upd(t[s].l,l,mid,x,y); else t[p].r = upd(t[s].r,mid+1,r,x,y);
    return p;
}inline long long qry(int u,int v,int x,int y,int l,int r,int k){
    if(l == r) return t[u].s + t[v].s - t[x].s - t[y].s;int mid = (l + r) / 2;
    if(k <= mid) return qry(t[u].l,t[v].l,t[x].l,t[y].l,l,mid,k);
    else return t[t[u].l].s + t[t[v].l].s - t[t[x].l].s - t[t[y].l].s + qry(t[u].r,t[v].r,t[x].r,t[y].r,mid+1,r,k);
}inline void dfs(int u,int f){
    fa[u][0] = f,dep[u] = dep[f] + 1,a[u] = lower_bound(d+1,d+le+1,a[u]) - d,
    rt[u] = upd(rt[f],1,n,a[u],b[u]),mn[u][0] = c[u];
    for(int i = 1;i <= 22;i ++) fa[u][i] = fa[fa[u][i-1]][i-1],mn[u][i] = min(mn[u][i-1],mn[fa[u][i-1]][i-1]);
    for(auto [v,ta,tb,tc] : g[u]) if(v != f) a[v] = ta,b[v] = tb,c[v] = tc,dfs(v,u);
}inline pair<int,int> lca(int u,int v){
    int mnn = 1e9;
    if(dep[u] < dep[v]) swap(u,v);
    while(dep[u] > dep[v]) mnn = min(mnn,mn[u][__lg(dep[u] - dep[v])]),u = fa[u][__lg(dep[u] - dep[v])];
    for(int i = 22;i >= 0;i --) if(fa[u][i] != fa[v][i]) mnn = min(mnn,min(mn[u][i],mn[v][i])),u = fa[u][i],v = fa[v][i];
    if(u == v) return {u,mnn};
    return {fa[u][0],min(mnn,min(mn[u][0],mn[v][0]))};
}inline bool ck(int x){
    int tp = lower_bound(d+1,d+le+1,x)-d;
    if(tp == 1) return 1; tp --;
    return (qry(rt[u],rt[v],rt[lc],rt[lc],1,n,tp) <= w);
}signed main(){
    ios::sync_with_stdio(0),cin.tie(0);
    cin >> n;
    for(int i = 1;i < n;i ++) cin >> u >> v >> ta >> tb >> tc,d[i] = ta,g[u].emplace_back(v,ta,tb,tc),g[v].emplace_back(u,ta,tb,tc);
    sort(d+1,d+n),le = unique(d+1,d+n)-d-1;
    for(dfs(1,0),cin >> q;q --;){
        cin >> u >> v >> w;auto [le,we] = lca(u,v);lc = le;
        int l = 0,r = we;
        while(l <= r){
            int mid = (l + r) / 2;
            if(ck(mid)) l = mid + 1; else r = mid - 1;
        }cout << l - 1 << "\n";
    }
}
```

---

## 作者：Transparent (赞：1)

对于每条路，它的代价可以按速度分成 $3$ 段：速度在 $[0,v_i]$ 的花费为 $0$，速度在 $(v_i,s_i]$ 的花费为 $c_i$，速度在 $(s_i,+ \infty)$ 的花费为 $+\infty$。

于是对每个询问，在二分出一个 $ans$ 后，只需要求出 $x \rightarrow y$ 的路径上的边在速度为 $ans$ 时的权值和即可判断。路径可以考虑差分，转化成求 $x$ 到根、$y$ 到根经过的边权和减去 $2$ 倍的 $lca(x,y)$ 到根经过的边权和。

现在只要能快速查询某一速度下某个点到根的路径上的边权和即可，容易用可持久化线段树维护。在外面二分每次询问是 $O(\log^2 n)$ 的，对点这一维可持久化，线段树的下标表示速度，利用权值和可减，即可在线段树上二分。~~虽然这题 log^3 也能过~~

时间复杂度 $O((n + q) \log n)$，多维护一点信息也可以不开 `__int128`，（甚至空间还更小）。

```cpp
#include <bits/stdc++.h>

using namespace std;
using ll=long long;
using LL=__int128_t;

constexpr int MAXN=1e5+10;
constexpr ll inf=0x3f3f3f3f3f3f3f3f;

struct Node {
    Node() {l=r=sum=0;}
    int l,r; LL sum;
};

struct SegTree {
    SegTree() {t.emplace_back(); tot=0;}
    vector<Node> t;
    int tot,rt[MAXN];
    int clone(int k) {return t.emplace_back(t[k]),t.size()-1;}
    void pushup(int k) {t[k].sum=t[t[k].l].sum+t[t[k].r].sum;}
    void modify(int k,int l,int r,int x,LL v) {
        if(l==r) {t[k].sum+=v; return;}
        int mid=(l+r)>>1;
        if(x<=mid) modify(t[k].l=clone(t[k].l),l,mid,x,v);
        else modify(t[k].r=clone(t[k].r),mid+1,r,x,v);
        pushup(k);
    }
    int query(int kx,int ky,int kl,int l,int r,LL lim) {
        if(l==r) return lim>=t[kx].sum+t[ky].sum-t[kl].sum*2?l:l-1;
        LL suml=t[t[kx].l].sum+t[t[ky].l].sum-t[t[kl].l].sum*2; int mid=(l+r)>>1;
        if(suml<=lim) return query(t[kx].r,t[ky].r,t[kl].r,mid+1,r,lim-suml);
        return query(t[kx].l,t[ky].l,t[kl].l,l,mid,lim);
    }
}t;

template<typename T,size_t size> struct STb {
    T v[__lg(size)+1][size+1];
    int lim;
    STb() {lim=0;}
    virtual bool cmp(const T &a,const T &b) const=0;
    T choose(const T &a,const T &b) const {return cmp(a,b)?a:b;}
    void init(const int n,const T *val) {
        lim=__lg(n); memcpy(v[0],val,sizeof(T)*(n+1));
        for(int i=1;i<=lim;++i) {
            for(int j=1;j+(1<<(i-1))<=n;++j) v[i][j]=choose(v[i-1][j],v[i-1][j+(1<<(i-1))]);
        }
    }
    T query(const int l,const int r) const {
        int layer=__lg(r-l+1); return choose(v[layer][l],v[layer][r-(1<<layer)+1]);
    }
};

int dcnt,dfn[MAXN],rev[MAXN],val[MAXN*2],cnt;

struct RMQ:public STb<int,MAXN> {
    bool cmp(const int &a,const int &b) const override {return dfn[a]<dfn[b];}
}rmq;

int lca(int x,int y) {
    if(x==y) return x;
    if(dfn[x]>dfn[y]) swap(x,y);
    return rmq.query(dfn[x]+1,dfn[y]);
}

vector<tuple<int,int,int,int,int>> e;
vector<tuple<int,int,int,int>> g[MAXN];
int n,q;

void dfs(int u,int fa) {
    dfn[u]=++dcnt; rev[dcnt]=fa;
    for(auto [v,vv,c,s]:g[u]) {
        if(v==fa) continue;
        t.rt[v]=t.clone(t.rt[u]);
        t.modify(t.rt[v],1,cnt,vv+1,c); t.modify(t.rt[v],1,cnt,s+1,inf);
        dfs(v,u);
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr); cout.tie(nullptr);

    cin>>n; e.resize(n-1);
    for(auto &[x,y,v,c,s]:e) cin>>x>>y>>v>>c>>s,val[++cnt]=v,val[++cnt]=s;
    sort(val+1,val+cnt+1); cnt=unique(val+1,val+cnt+1)-val-1;
    for(auto &[x,y,v,c,s]:e) {
        v=lower_bound(val+1,val+cnt+1,v)-val;
        s=lower_bound(val+1,val+cnt+1,s)-val;
        g[x].emplace_back(y,v,c,s); g[y].emplace_back(x,v,c,s);
    }

    t.rt[1]=t.clone(0); dfs(1,0); rmq.init(n,rev);

    cin>>q;
    while(q--) {
        int x,y,l; ll lim; cin>>x>>y>>lim; l=lca(x,y);
        cout<<val[t.query(t.rt[x],t.rt[y],t.rt[l],1,cnt,lim)]<<"\n";
    }

    return 0;
}
```

---

## 作者：xiao7_Mr_10_ (赞：0)

整体二分板子题。

对每个询问二分答案 $mid$，然后就需要把路径中所有权值小于 $mid$ 的边升级，查看费用是否合法且升级后是否满足要求。

多组询问，我们考虑整体二分。对 $mid$ 排序然后单调加边修改，树链剖分与数据结构维护路径即可。

时间复杂度近似 $O(n \log ^3 n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
//最大最小值...?
//这是什么，二分答案!
//考虑怎么做一个询问 
//二分最小值mid,将所有<mid的路径全部尝试修改
//所以对于一条路径，如果他直接的小于了mid,那么路径所有都要改
//考虑对所有路径进行树上差分，然后暴力修改，然后判断是否超出了某一条居民的要求
//考虑复杂度,O(q(nlogx+nln^2)),k=3(常数大)
//不是你玩我呢?
//但是，我们还有一个手段，整体二分
//把所有边排序，所有询问也按二分mid排序(升序),单调加边，然后使用数据结构维护
//时间O(nlgn^3+nlg^2)
//但我认为不会超时，因为树链剖分手段常数极其小，不会跑满，五秒足够也 
//优化二分上下界加上小卡常....
//思维已经清晰了,理一下要做的事 
//1.输入预处理，排序边(14:50 完成) 
//15:10t3
//15:40我回来了! 
//2.两次搜索，预处理剖分数组和线段树(15:52 完成)
//3.整体二分所有答案(16:32 完成) 
//4.输出(16:33 完成) 
//这是我一年前写的代码hhh
const int N=1e5+5;
struct Point{
	int v,val,id;//速度 
};
struct edge{
	int u,v,val,sj,w,id;//多个自己 
}w[N];
struct ques{
	int u,v,id;
	long long val,l,r,mid;
}wt[N];
vector <Point> e[N];
int n,m,pos[N],sz[N],son[N],top[N],f[N],de[N],a[N],b[N],cnt,dfn[N];
long long ans[N];
bool cmp(edge x,edge y){
	return x.val<y.val;
}
struct tree{
	long long minn,sum;
}c[N<<2];
inline void dfs(int u,int fa){
	sz[u]=1;
	for(int i = 0;i < e[u].size();i++){
		int v=e[u][i].v;
		if(v==fa)continue;
		dfn[e[u][i].id]=v;
		f[v]=u;
		de[v]=de[u]+1;
		a[v]=e[u][i].val;
		dfs(v,u);
		sz[u]+=sz[v];
		if(sz[son[u]]<sz[v])son[u]=v;
	}
}
inline void dfs1(int u,int fa){
	top[u]=fa;
	pos[u]=++cnt;
	b[cnt]=a[u];
	if(son[u]==0)return;
	dfs1(son[u],fa);
	for(int i = 0;i < e[u].size();i++){
		int v=e[u][i].v;
		if(v==f[u]||v==son[u])continue;
		dfs1(v,v);
	}
}
inline tree merge(tree x,tree y){
	tree ans;
	ans.minn=min(x.minn,y.minn);
	ans.sum=x.sum+y.sum;
	return ans;
}
inline void updata(int x){
	c[x]=merge(c[x<<1],c[x<<1|1]);
}
inline void build(int x,int l,int r){
	if(l==r){
		c[x].minn=b[l];
		c[x].sum=0ll;
		return;
	}
	int mid=(l+r)>>1;
	build(x<<1,l,mid);
	build(x<<1|1,mid+1,r);
	updata(x);
}
inline void change(int x,int l,int r,int s,long long k,long long z){
	if(l==r){
		c[x].minn=k;
		c[x].sum=z;
		return;
	}
	int mid=(l+r)>>1;
	if(s<=mid)change(x<<1,l,mid,s,k,z);
	else change(x<<1|1,mid+1,r,s,k,z);
	updata(x);
}
inline tree query(int x,int l,int r,int s,int t){
	if(l>=s&&r<=t)return c[x];
	int mid=(l+r)>>1;
	if(s>mid)return query(x<<1|1,mid+1,r,s,t);
	else{
		if(t<=mid)return query(x<<1,l,mid,s,t);
		return merge(query(x<<1,l,mid,s,t),query(x<<1|1,mid+1,r,s,t));
	}
}
inline void addedge(int u,int v,int w,int id){
	e[u].push_back((Point){v,w,id});
}
inline tree queryx(int x,int y){
	tree ans;
	int flag=(x==2)&&(y==4);
	ans.minn=1145141919810ll,ans.sum=0;
//	cout << x << " " << y << "\n";
	while(top[x]!=top[y]){
		if(de[top[x]]<de[top[y]])swap(x,y);
//		cout << pos[top[x]] << " " << pos[x] << "\n";
		ans=merge(ans,query(1,1,cnt,pos[top[x]],pos[x]));
		x=f[top[x]];
	}
//	cout << "lile\n";
	if(x==y)return ans;
	if(de[x]<de[y])swap(x,y);
//	if(flag)cout << query(1,1,cnt,pos[y],pos[y]).minn << " " << query(1,1,cnt,pos[x]-1,pos[x]-1).minn << " "<<query(1,1,cnt,pos[y],pos[x]-1).minn << "\n";
	ans=merge(ans,query(1,1,cnt,pos[y]+1,pos[x]));
	return ans;
} 
bool cmp1(ques x,ques y){
	return x.mid<y.mid;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n;
	for(int i = 1;i < n;i++){
		cin >> w[i].u >> w[i].v >> w[i].val >> w[i].sj >> w[i].w;
		w[i].id=i;
		addedge(w[i].u,w[i].v,w[i].val,i);
		addedge(w[i].v,w[i].u,w[i].val,i);
	}
	sort(w+1,w+n,cmp);
	cin >> m;
	for(int i = 1;i <= m;i++){
		cin >> wt[i].u >> wt[i].v >> wt[i].val;
		wt[i].id=i;
	}
	dfs(1,0);
	dfs1(1,1);
	build(1,1,cnt);	
	int logn=0;
	for(int i = 1;i <= m;i++)wt[i].l=queryx(wt[i].u,wt[i].v).minn;
	for(int i = 1;i < n;i++)change(1,1,cnt,pos[dfn[w[i].id]],w[i].w,w[i].sj);
	for(int i = 1;i <= m;i++){
		wt[i].r=queryx(wt[i].u,wt[i].v).minn;
		int lg=log2(wt[i].r-wt[i].l+1ll)+1;
		logn=max(logn,lg);
	}
	while(logn--){
		for(int i = 1;i <= m;i++)wt[i].mid=(wt[i].l+wt[i].r)>>1;
		sort(wt+1,wt+1+m,cmp1);
		int l=1;
		build(1,1,cnt);
		for(int i = 1;i <= m;i++){
			while(l<n&&w[l].val<wt[i].mid){
				int id=dfn[w[l].id];
				change(1,1,cnt,pos[id],w[l].w,w[l].sj);
				l++;
			}
			tree val=queryx(wt[i].u,wt[i].v);
			if(wt[i].mid<=val.minn&&val.sum<=wt[i].val){
				ans[wt[i].id]=wt[i].mid;
				wt[i].l=wt[i].mid+1;
			}
			else wt[i].r=wt[i].mid-1;
		}
	}
	for(int i = 1;i <= m;i++)cout << ans[i] << "\n";
	return 0;
}
```

---

## 作者：Add_Catalyst (赞：0)

# P9175 [COCI2022-2023#4] Mreža 题解

---

## 知识点

（树上）倍增，（树上）莫队，树状数组，分块。

---

## 题意分析

给定一棵树，每条边有一个权值 $v$，以及可以用一个花费 $c$ 将它变成更大的权值 $s$。再给定一些询问，问在总花费不超过一个值 $e$ 的情况下进行改变，节点 $a$ 与 $b$ 之间的边的权值最小值最大为多少。

---

## 思路分析

对于每一次询问，我们肯定是节点 $a$ 与 $b$ 之间边权最小的边不停更新，直到不能更新。基于这个思路，Subtask 1 已经可以解决了。

但是下一步怎么优化呢？我们可以想到，可以先将原边权离散化，然后根据离散化后的值排序，然后每次查询就变成了在这个数组上从大到小遍历，加上在节点 $a$ 与 $b$ 之间路径上的边的权值，直到总和大于 $e$，这个过程我们可以用树状数组解决，更新时间复杂度为 $O(\log_2{n})$，然后可以树状数组上倍增查询，时间复杂度也为 $O(\log_2{n})$（你可以换用分块，这样就可以变成更新时间复杂度为 $O(1)$，查询时间复杂度为 $O(\sqrt{n})$，总体理论时间复杂度会更加正确）。

然后 Subtask 2 的部分就直接套莫队，也紧接着迎刃而解了。

剩下 Subtask 3，我们在 Subtask 2 的 基础上，用括号序把树上问题转换成序列问题，稍加改进，整个问题就解决了。

最后还有一些细节：

1. 对于每一次询问，答案上界是节点 $a$ 与 $b$ 之间所有更新后的边权最小值，这个可以用树上倍增解决。
2. 对于每一次询问，当 $e$ 大于更新节点 $a$ 与 $b$ 之间所有边权的总花费，就不需要在树状数组中查询了，否则可能导致错误。
3. 转换成括号序后，节点 $a$ 与 $b$ 为祖孙关系时询问区间要特殊处理。

---

## 关于复杂度

空间复杂度上主要瓶颈是倍增数组，为 $O(n\log_2{n})$。

那么我们来看时间复杂度。

对于莫队部分，这里简单分析一下：

设 $S$ 为单块大小，那么块数为 $O(\frac{n}{S})$ 级别。每次左端点最大移动次数级别为 $O(S)$；在左端点在同一块内时，右端点最大移动次数级别为 $O(n)$。

所以莫队部分左右端点（指针）移动次数大概为 $O(qS+\frac{n^2}{S})$，在 $S$ 取 $\frac{n}{\sqrt{q}}$ 的时候最小平衡到 $O(n\sqrt{q})$。

然后再分别讨论树状树组与分块的时间复杂度：

1. 树状树组：单次更新 $O(\log_2{n})$，查询 $O(\log_2{n})$，总时间复杂度在 $O(n\log_2{n}\sqrt{q}+q\log_2{n})$ 左右；
2. 分块：单次更新 $O(1)$，查询 $O(\sqrt{n})$，总时间复杂度在 $O(n\sqrt{q}+q\sqrt{n})$ 左右。

首先分块肯定没问题，但是树状数组呢，它的理论总时间复杂度好像不太行啊？

我们注意到莫队这类题目的时间复杂度一般都是讨论最坏情况，所以基本都是跑不满的，再加之这还是个树上莫队，真的要卡它也很难。就算是链，我们在块长不一样的情况下，运行的情况也是不一样的。如果还不够的话，我们在规定根以及遍历子节点的时候都加上随机化，那么基本是卡不掉了（喜欢快读快写也可以加）。

看[实测](https://www.luogu.com.cn/record/174861928)，最长的点时间也不超过 **1.55 s**，而时限是 **5 s**，说明完全可以。

---

## CODE

1. 树状树组：（[记录详情](https://www.luogu.com.cn/record/174861928)）用时 **2.38 s**，内存 **33.32 MB**，单个测试点最长时间为 **1.55 s**。

   ```cpp
   #include<bits/stdc++.h>
   #define INF 0x3f3f3f3f
   #define ll long long
   #define tomax(a,b) ((a)=max((a),(b)))
   #define tomin(a,b) ((a)=min((a),(b)))
   #define RCL(a,b,c,d) memset((a),(b),sizeof(c)*(d))
   #define FOR(i,a,b) for(register int i=(a);i<=(b);++i)
   #define DOR(i,a,b) for(register int i=(a);i>=(b);--i)
   #define EDGE(g,i,u,x) for(register int (i)=(g).h[(u)],(x)=(g).v[(i)];(i);(i)=(g).nxt[(i)],(x)=(g).v[(i)])
   #define main Main();signed main(){ios::sync_with_stdio(0);cin.tie(0);return Main();}signed Main
   using namespace std;
   constexpr int N=1e5+10,lN=17,lV=lN+1;
   int n,Q,idx,Bl;
   int b[N],dl[N],dr[N],id[N<<1],pa[N],ans[N],dep[N],dfn[N<<1],siz[N],son[N];
   int fa[N][lV],mi[N][lV];
   ll sum;
   struct edge{
   	int u,v,w,c,s;
   	void Scan(){
   		cin>>u>>v>>w>>c>>s;
   	}
   }e[N];
   struct Query{
   	int l,r,idx;ll w;
   	friend bool operator <(Query a,Query b){
   		return id[a.l]^id[b.l]?a.l<b.l:(id[a.l]&1?a.r<b.r:a.r>b.r);
   	}
   }qr[N];
   struct BIT{
   #define lowbit(a) ((a)&-(a))
   	ll c[N];
   	void Update(int x,int v){
   		if(x<=0)return;
   		for(int i=x;i<=b[0];i+=lowbit(i))c[i]+=v;
   	}
   	int Bound(ll x){
   		ll sum=0;int ans=0;
   		DOR(i,lN,0)if(ans+(1<<i)<=b[0]&&sum+c[ans+(1<<i)]<x)sum+=c[ans+=1<<i];
   		return ans+1;
   	}
   #undef lowbit
   }B;
   struct CFS{
   	int tot,h[N],v[N<<1],nxt[N<<1];
   	void att(int U,int V){
   		v[++tot]=V,nxt[tot]=h[U],h[U]=tot;
   	}
   	void con(int U,int V){
   		att(U,V),att(V,U);
   	}
   }g;
   void Build(int u){
   	dep[u]=dep[fa[u][0]]+1,mi[u][0]=e[pa[u]].s,siz[u]=1;
   	FOR(i,1,lN)fa[u][i]=fa[fa[u][i-1]][i-1],mi[u][i]=min(mi[u][i-1],mi[fa[u][i-1]][i-1]);
   	EDGE(g,i,u,v)if(v^fa[u][0])
   		pa[v]=i+1>>1,fa[v][0]=u,Build(v),siz[u]+=siz[v],son[u]=(siz[son[u]]>siz[v]?son[u]:v);
   }
   void Divide(int u){
   	dfn[dl[u]=++idx]=u;
   	if(son[u])Divide(son[u]);
   	EDGE(g,i,u,v)if(son[u]!=v&&fa[u][0]!=v)Divide(v);
   	dfn[dr[u]=++idx]=u;
   }
   int Lca(int u,int v){
   	if(dep[v]<dep[u])swap(u,v);
   	DOR(i,lN,0)if(dep[v]-dep[u]&1<<i)v=fa[v][i];
   	if(u==v)return u;
   	DOR(i,lN,0)if(fa[u][i]^fa[v][i])u=fa[u][i],v=fa[v][i];
   	return fa[v][0];
   }
   int Query(int u,int pa){
   	int ans=INF;
   	DOR(i,lN,0)if(dep[fa[u][i]]>=dep[pa])tomin(ans,mi[u][i]),u=fa[u][i];
   	return ans;
   }
   bool vis[N];
   void Update(int x){
   	if(x>1)sum+=(vis[x]?-1:1)*e[pa[x]].c,B.Update(e[pa[x]].w,(vis[x]?-1:1)*e[pa[x]].c),vis[x]^=1;
   }
   signed main(){
   	cin>>n;
   	FOR(i,1,n-1)e[i].Scan(),g.con(e[i].u,e[i].v),b[i]=e[i].w;
   	sort(b+1,b+n),b[0]=unique(b+1,b+n)-b-1;
   	FOR(i,1,n-1)e[i].w=lower_bound(b+1,b+b[0]+1,e[i].w)-b;
   	cin>>Q,Build(1),Divide(1),Bl=ceil(2.0*n/sqrt(Q));
   	FOR(i,1,n<<1)id[i]=(i-1)/Bl+1;
   	FOR(i,1,Q){
   		int u,v,pa;cin>>u>>v>>qr[i].w,pa=Lca(u,v);
   		if(dl[u]>dl[v])swap(u,v);
   		qr[i].l=pa==u?dl[u]+1:dr[u],qr[i].r=dl[v],ans[qr[i].idx=i]=min(Query(u,pa),Query(v,pa));
   	}
   	sort(qr+1,qr+Q+1);
   	int l=1,r=0;
   	FOR(i,1,Q){
   		while(r<qr[i].r)Update(dfn[++r]);
   		while(l>qr[i].l)Update(dfn[--l]);
   		while(r>qr[i].r)Update(dfn[r--]);
   		while(l<qr[i].l)Update(dfn[l++]);
   		if(qr[i].w<sum)tomin(ans[qr[i].idx],b[B.Bound(qr[i].w+1)]);
   	}
   	FOR(i,1,Q)cout<<ans[i]<<endl;
   	return 0;
   }
   ```

2. 分块：（[记录](https://www.luogu.com.cn/record/174862031)）用时 **1.11 s**，内存 **33.77 MB**，单个测试点最长时间为 **687 ms**。

   ```cpp
   #include<bits/stdc++.h>
   #define INF 0x3f3f3f3f
   #define ll long long
   #define tomax(a,b) ((a)=max((a),(b)))
   #define tomin(a,b) ((a)=min((a),(b)))
   #define RCL(a,b,c,d) memset((a),(b),sizeof(c)*(d))
   #define FOR(i,a,b) for(register int i=(a);i<=(b);++i)
   #define DOR(i,a,b) for(register int i=(a);i>=(b);--i)
   #define EDGE(g,i,u,x) for(register int (i)=(g).h[(u)],(x)=(g).v[(i)];(i);(i)=(g).nxt[(i)],(x)=(g).v[(i)])
   #define main Main();signed main(){ios::sync_with_stdio(0);cin.tie(0);return Main();}signed Main
   using namespace std;
   constexpr int N=1e5+10,lN=17,lV=lN+1,sN=340+10;
   bool vis[N];
   int n,Q,idx,Bl;
   int b[N],dl[N],dr[N],id[N<<1],pa[N],ans[N],dep[N],dfn[N<<1],siz[N],son[N];
   int fa[N][lV],mi[N][lV];
   ll sum;
   struct edge{
   	int u,v,w,c,s;
   	void Scan(){
   		cin>>u>>v>>w>>c>>s;
   	}
   }e[N];
   struct Query{
   	int l,r,idx;ll w;
   	friend bool operator <(Query a,Query b){
   		return id[a.l]^id[b.l]?a.l<b.l:(id[a.l]&1?a.r<b.r:a.r>b.r);
   	}
   }qr[N];
   struct Block{
   	int Bl,Bn;
   	int st[sN],en[sN],id[N];
   	ll Sum[sN],sum[N];
   	void Init(int n){
   		Bl=sqrt(n),Bn=(n-1)/Bl+1;
   		FOR(i,1,Bn){
   			st[i]=en[i-1]+1,en[i]=min(n,st[i]+Bl-1);
   			FOR(j,st[i],en[i])id[j]=i;
   		}
   	}
   	void Update(int x,int d){
   		sum[x]+=d,Sum[id[x]]+=d;
   	}
   	int Query(ll x){
   		int Idx=0,idx=0;ll s=0;
   		for(Idx=0;Idx<=Bn;s+=Sum[Idx],++Idx)if(s+Sum[Idx]>x)break;
   		for(idx=st[Idx];idx<=en[Idx];s+=sum[idx],++idx)if(s+sum[idx]>x)break;
   		return idx;
   	}
   }B;
   struct CFS{
   	int tot,h[N],v[N<<1],nxt[N<<1];
   	void att(int U,int V){
   		v[++tot]=V,nxt[tot]=h[U],h[U]=tot;
   	}
   	void con(int U,int V){
   		att(U,V),att(V,U);
   	}
   }g;
   void Build(int u){
   	dep[u]=dep[fa[u][0]]+1,mi[u][0]=e[pa[u]].s,siz[u]=1;
   	FOR(i,1,lN)fa[u][i]=fa[fa[u][i-1]][i-1],mi[u][i]=min(mi[u][i-1],mi[fa[u][i-1]][i-1]);
   	EDGE(g,i,u,v)if(v^fa[u][0])
   		pa[v]=i+1>>1,fa[v][0]=u,Build(v),siz[u]+=siz[v],son[u]=(siz[son[u]]>siz[v]?son[u]:v);
   }
   void Divide(int u){
   	dfn[dl[u]=++idx]=u;
   	if(son[u])Divide(son[u]);
   	EDGE(g,i,u,v)if(son[u]!=v&&fa[u][0]!=v)Divide(v);
   	dfn[dr[u]=++idx]=u;
   }
   int Lca(int u,int v){
   	if(dep[v]<dep[u])swap(u,v);
   	DOR(i,lN,0)if(dep[v]-dep[u]&1<<i)v=fa[v][i];
   	if(u==v)return u;
   	DOR(i,lN,0)if(fa[u][i]^fa[v][i])u=fa[u][i],v=fa[v][i];
   	return fa[v][0];
   }
   int Query(int u,int pa){
   	int ans=INF;
   	DOR(i,lN,0)if(dep[fa[u][i]]>=dep[pa])tomin(ans,mi[u][i]),u=fa[u][i];
   	return ans;
   }
   void Update(int x){
   	if(x>1)sum+=(vis[x]?-1:1)*e[pa[x]].c,B.Update(e[pa[x]].w,(vis[x]?-1:1)*e[pa[x]].c),vis[x]^=1;
   }
   signed main(){
   	cin>>n;
   	FOR(i,1,n-1)e[i].Scan(),g.con(e[i].u,e[i].v),b[i]=e[i].w;
   	sort(b+1,b+n),b[0]=unique(b+1,b+n)-b-1,B.Init(b[0]);
   	FOR(i,1,n-1)e[i].w=lower_bound(b+1,b+b[0]+1,e[i].w)-b;
   	cin>>Q,Build(1),Divide(1),Bl=ceil(2.0*n/sqrt(Q));
   	FOR(i,1,n<<1)id[i]=(i-1)/Bl+1;
   	FOR(i,1,Q){
   		int u,v,pa;cin>>u>>v>>qr[i].w,pa=Lca(u,v);
   		if(dl[u]>dl[v])swap(u,v);
   		qr[i].l=pa==u?dl[u]+1:dr[u],qr[i].r=dl[v],ans[qr[i].idx=i]=min(Query(u,pa),Query(v,pa));
   	}
   	sort(qr+1,qr+Q+1);
   	int l=1,r=0;
   	FOR(i,1,Q){
   		while(r<qr[i].r)Update(dfn[++r]);
   		while(l>qr[i].l)Update(dfn[--l]);
   		while(r>qr[i].r)Update(dfn[r--]);
   		while(l<qr[i].l)Update(dfn[l++]);
   		if(qr[i].w<sum)tomin(ans[qr[i].idx],b[B.Query(qr[i].w)]);
   	}
   	FOR(i,1,Q)cout<<ans[i]<<endl;
   	return 0;
   }
   ```

---

---

## 作者：NATO (赞：0)

简单的小 DS，用来练手很不错。

### 思路浅析：

显然每个市民都是一个询问，即修改一些 $u,v$ 路径上的边
满足花费小于等于某个值的前提下最大化最小边权。

显然边放到点上。

然后看到最大化最小值，想到二分答案，上界显然是 $u,v$ 路径上全部升级后的最大值。

判断是否合法也是平凡的，暴力就是找到 $u,v$ 路径上所有小于二分的 $mid$ 的 $v$，这些显然是必须要改的，统计这些的花费之和是否小于等于花费上限即可。

直观地想到树剖优化该过程，即开值域线段树，二分一个答案后跳链统计小于等于二分下界所需的修改花费之和。

~~完结撒花~~，很遗憾，芝士 $O(q\log^3n)$ 的。

优化是简单的，发现不带修，主席树维护每个点到根的值域线段树，查的时候将 $u,v$ 和 $\operatorname{lca}(u,v)$ 的查询结果差分一下即可。

时间复杂度 $O(n\log^2n)$，轻松解决~~。

### 参考代码：


```cpp
#include<bits/stdc++.h>
#define ll long long
#define INF 214748364719260817ll
using namespace std;
ll n;
ll cnt,head[100005],a[100005];	
ll tot;
set<ll>all_w;
map<ll,ll>tow,to_back;
struct ed
{
	ll v,next;
	ll w,c,cw;
}edge[200005];
void add(ll u,ll v,ll w,ll c,ll cw)
{
	edge[++cnt].v=v;edge[cnt].c=c;edge[cnt].next=head[u];head[u]=cnt;edge[cnt].cw=cw;edge[cnt].w=w;
	edge[++cnt].v=u;edge[cnt].c=c;edge[cnt].next=head[v];head[v]=cnt;edge[cnt].cw=cw;edge[cnt].w=w;
}
struct chairman
{
	int rt[100005],cnt;
	struct tree
	{
		int son[2];
		ll sum;
		
	}tr[4000005];
	#define ls(id) tr[id].son[0]
	#define rs(id) tr[id].son[1]
	void pushup(ll id)
	{
		tr[id].sum=tr[ls(id)].sum+tr[rs(id)].sum;
	}
	void update(int &id,ll l,ll r,ll ml,ll val)
	{
		ll yid=id;
		id=++cnt;tr[id]=tr[yid];
		if(l==r)
		{
			tr[id].sum+=val;return;
		}
		ll mid=l+r>>1;
		if(ml<=mid)update(ls(id),l,mid,ml,val);
		else update(rs(id),1+mid,r,ml,val);
		pushup(id);
	}
	ll query(ll id,ll l,ll r,ll ml,ll mr)
	{
		if(ml>mr)return 0;
		if(!id)return 0;
		if(ml<=l&&r<=mr)return tr[id].sum;
		ll mid=l+r>>1,res=0;
		if(ml<=mid)res+=query(ls(id),l,mid,ml,mr);
		if(mr>mid)res+=query(rs(id),1+mid,r,ml,mr);
		return res;
	}
	#undef ls
	#undef rs
}trx;
ll sz[100005],son[100005],dep[100005];
ll dfn[100005],tp[100005],to[100005],sum,f[100005];
struct SGT
{
	ll tr[400005];
	#define ls(id) id*2
	#define rs(id) id*2+1
	void build(ll id,ll l,ll r)
	{
		if(l==r)
		{
			tr[id]=a[to[l]];return;
		}
		ll mid=l+r>>1;
		build(ls(id),l,mid);
		build(rs(id),1+mid,r);
		tr[id]=min(tr[ls(id)],tr[rs(id)]);
	}
	ll query(ll id,ll l,ll r,ll ml,ll mr)
	{
		if(ml<=l&&r<=mr)return tr[id];
		ll mid=l+r>>1,res=INF;
		if(ml<=mid)res=min(res,query(ls(id),l,mid,ml,mr));
		if(mr>mid)res=min(res,query(rs(id),1+mid,r,ml,mr));
		return res;
	}
}tr;
void dfs(ll id,ll fa)
{
	sz[id]=1;dep[id]=dep[fa]+1;
	for(ll i=head[id];i;i=edge[i].next)
	{
		ll v=edge[i].v,w=edge[i].w,c=edge[i].c,cw=edge[i].cw;
		if(v==fa)continue;
		trx.rt[v]=trx.rt[id];a[v]=tow[cw];
		f[v]=id;
		trx.update(trx.rt[v],1,tot,tow[w],c);
		dfs(v,id);
		sz[id]+=sz[v];
		if(sz[son[id]]<sz[v])son[id]=v;
	}
}
void dfs2(ll id,ll top)
{
	dfn[id]=++sum;to[sum]=id;tp[id]=top;
	if(son[id])dfs2(son[id],top);
	for(ll i=head[id];i;i=edge[i].next)
	{
		ll v=edge[i].v;
		if(!dfn[v])dfs2(v,v);
	}
}
ll c;
ll lca(ll u,ll v)
{
	ll minn=INF;
	while(tp[u]!=tp[v])
	{
		if(dep[tp[u]]<dep[tp[v]])swap(u,v);
		minn=min(minn,tr.query(1,1,n,dfn[tp[u]],dfn[u]));
		u=f[tp[u]];
	}
	if(dep[u]>dep[v])swap(u,v);
	c=u;
	if(u==v)return minn;
	return min(minn,tr.query(1,1,n,dfn[u]+1,dfn[v]));
}
ll q;
int main()
{
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n;
	ll u,v,w,cc,cw;
	for(ll i=1;i<n;++i)
	{
		cin>>u>>v>>w>>cc>>cw;
		add(u,v,w,cc,cw);
		all_w.insert(w);
		all_w.insert(cw);
	}
	for(auto it:all_w)tow[it]=++tot,to_back[tot]=it;
	dfs(1,0);
	dfs2(1,1);
	tr.build(1,1,n);
	ll a,b,e;
	cin>>q;
	while(q--)
	{
		cin>>a>>b>>e;
		ll l=1,r=lca(a,b),res=1;
		while(l<=r)
		{
			ll mid=l+r>>1;
			if(trx.query(trx.rt[a],1,tot,1,mid-1)+trx.query(trx.rt[b],1,tot,1,mid-1)-2*trx.query(trx.rt[c],1,tot,1,mid-1)<=e)
			res=mid,l=mid+1;
			else r=mid-1;
		}
		cout<<to_back[res]<<'\n';
	}
}
```

---

## 作者：Flash_Man (赞：0)

一看到最小值最大，直接二分答案（二分最小速度），check 的时候看一下速度小于 $\text{mid}$ 的提升速度的代价是否不大于 $e$，和提升了速度后速度的最小值是否不小于 $\text{mid}$。对于第一个要求，用主席树维护所有点到根路径上每个速度提升的代价；对于第二个要求，在维护 lca 的 st 表的时候，顺便维护一个 $s_i$ 最小值的 st 表，每次二分的上界取路径上 $s_i$ 的最小值即可。

注意值域太大要离散化，离散化的时候要往里面手动加一个 $0$，不然就会获得 $0$ 分的好成绩。

```cpp
#include <bits/stdc++.h>
#define int long long
const int N = 1e5 + 3, V = 2e5 + 3, S = 2e6 + 3, L = 20, inf = 1e9;
struct Persistent_Segment_Tree {
	int rt[N];
	int siz, cnt, sum[S], ls[S], rs[S];
	Persistent_Segment_Tree(): siz(0), cnt(0) {}
	void rsz(int s) { siz = s; }
	int cpy(int u) { return sum[++cnt] = sum[u], ls[cnt] = ls[u], rs[cnt] = rs[u], cnt; }
	void mdf(int u, int f, int p, int v) {
		int cur = cpy(rt[f]); rt[u] = cur;
		for (int l = 1, r = siz; l < r; ) {
			sum[cur] += v;
			int mid = (l + r) >> 1;
			if (p <= mid) cur = (ls[cur] = cpy(ls[cur])), r = mid;
			else cur = (rs[cur] = cpy(rs[cur])), l = mid + 1;
		}
		sum[cur] += v;
	}
	int qry(int u, int v, int lc, int p) {
		int cu = rt[u], cv = rt[v], cl = rt[lc], res = 0;
		for (int l = 1, r = siz; l < r; ) {
			int mid = (l + r) >> 1;
			if (p <= mid) r = mid, cu = ls[cu], cv = ls[cv], cl = ls[cl];
			else {
				res += sum[ls[cu]] + sum[ls[cv]] - sum[ls[cl]] * 2;
				l = mid + 1, cu = rs[cu], cv = rs[cv], cl = rs[cl];
			}
		}
		return res += sum[cu] + sum[cv] - sum[cl] * 2;
	}
} sgt;
struct Edge {
	int to, v, c, s;
	Edge(int to, int v, int c, int s): to(to), v(v), c(c), s(s) {}
};
int n, q, a[N], b[N], v[N], c[N], s[N];
int vcnt, t[V], dep[N], st[N][L], mn[N][L];
std::vector<Edge> g[N];
void dfs(int u, int fa) {
	dep[u] = dep[fa] + 1;
	for (int i = 1; i < L; i++) {
		st[u][i] = st[st[u][i - 1]][i - 1];
		mn[u][i] = std::min(mn[u][i - 1], mn[st[u][i - 1]][i - 1]);
	}
	for (auto [to, v, c, s] : g[u])
		if (to != fa) {
			st[to][0] = u, mn[to][0] = s, sgt.mdf(to, u, v, c);
			dfs(to, u);
		}
}
std::pair<int, int> lca(int u, int v) {
	int res = inf;
	if (dep[u] < dep[v]) std::swap(u, v);
	for (int i = L - 1; ~i; i--)
		if (dep[st[u][i]] >= dep[v]) res = std::min(res, mn[u][i]), u = st[u][i];
	if (u == v) return { u, res };
	for (int i = L - 1; ~i; i--)
		if (st[u][i] != st[v][i]) res = std::min({ res, mn[u][i], mn[v][i] }), u = st[u][i], v = st[v][i];
	return { st[u][0], std::min({ res, mn[u][0], mn[v][0] }) };
}
signed main() {
	scanf("%lld", &n);
	t[++vcnt] = 0;
	for (int i = 1; i < n; i++) {
		scanf("%lld%lld%lld%lld%lld", &a[i], &b[i], &v[i], &c[i], &s[i]);
		t[++vcnt] = v[i], t[++vcnt] = s[i];
	}
	std::sort(t + 1, t + vcnt + 1), vcnt = std::unique(t + 1, t + vcnt + 1) - t - 1;
	for (int i = 1; i < n; i++) {
		v[i] = std::lower_bound(t + 1, t + vcnt + 1, v[i]) - t;
		s[i] = std::lower_bound(t + 1, t + vcnt + 1, s[i]) - t;
		g[a[i]].emplace_back(b[i], v[i], c[i], s[i]), g[b[i]].emplace_back(a[i], v[i], c[i], s[i]);
	}
	sgt.rsz(vcnt), sgt.mdf(1, 0, 1, 0);
	for (int i = 0; i < L; i++) mn[0][i] = inf;
	dfs(1, 0);
	scanf("%lld", &q);
	while (q--) {
		int a, b, e; scanf("%lld%lld%lld", &a, &b, &e);
		auto [lc, mn] = lca(a, b);
		int l = 1, r = mn, ans;
		while (l <= r) {
			int mid = (l + r) >> 1;
			if (sgt.qry(a, b, lc, mid - 1) <= e) ans = mid, l = mid + 1;
			else r = mid - 1;
		}
		printf("%lld\n", t[ans]);
	}
	return 0;
}
```

---

## 作者：Msents (赞：0)

可以很容易就想到的一个点是单次询问的答案是有单调性的，大于答案的最低速度的花费肯定是要大于经费或者不存在的，小于答案的都可以按答案的方案修改，因此可以二分。

假设现在二分出来了一个最低速度，可以肯定的是在路径上所有低于这个速度的路都需要升级。

于是很容易发现的是答案的上界就是在路径上升级过后的路的速度的最小值。

这个能直接跳树法乱搞。

想在链上的情况，可以直接用主席树差分获得路径上低于某个速度的路的升级总花费。

在树上的话直接差分就完事了。

时间复杂度 $\mathcal{O}(n \log^2 n)$，可以过。

还可以直接在主席树上差分，复杂度能减掉一个 $\log$。

离散化一下应该跑的更快。

~~考试时 town 了写的树剖，但是三个 $\log$ 比两个跑得还要快。~~

~~树剖兼普通二分代码：~~

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
//typedef long long llong;
const int MaxN=100000;
int n,q;
struct Edge{
	Edge(){}
	Edge(int before,int cost,int after)
		:before(before),cost(cost),after(after){}
	int before,cost,after;
};
Edge edge[MaxN+1];
vector<pair<int,int> >g[MaxN+1];
struct Vertex{
	int prt,pEdge,deep;
	int size,tagSon,cTop;
	int root;
}vert[MaxN+1];
int ani[MaxN+1][18],minRoad[MaxN+1][18];
void PrepareDfs(int u){
	vert[u].size=1;
	for(auto&pi:g[u]){
		int v=pi.first,id=pi.second;
		if(v==vert[u].prt)continue;
		vert[v].prt=u;
		vert[v].pEdge=id;
		vert[v].deep=vert[u].deep+1;
		PrepareDfs(v);
		vert[u].size+=vert[v].size;
		if(vert[v].size>vert[vert[u].tagSon].size)vert[u].tagSon=v;
	}
}
void Prepare(){
	PrepareDfs(1);
	for(int i=1;i<=n;i++){
		ani[i][0]=vert[i].prt;
		minRoad[i][0]=edge[vert[i].pEdge].after;
	}
	for(int j=1;(1<<j)<=n;j++){
		for(int i=1;i<=n;i++){
			ani[i][j]=ani[ani[i][j-1]][j-1];
			minRoad[i][j]=min(minRoad[i][j-1],minRoad[ani[i][j-1]][j-1]);
		}
	}
}
int LCA(int a,int b){
	if(vert[a].deep<vert[b].deep)swap(a,b);
	int k=log2(vert[a].deep-vert[b].deep);
	while(k>=0){
		if((1<<k)<=vert[a].deep-vert[b].deep)a=ani[a][k];
		k--;
	}
	if(a==b)return a;
	k=log2(vert[a].deep);
	while(k>=0){
		if((1<<k)<=vert[a].deep&&ani[a][k]!=ani[b][k]){
			a=ani[a][k];
			b=ani[b][k];
		}
		k--;
	}
	return vert[a].prt;
}
int GetMinRoad(int a,int b){
	if(vert[a].deep<vert[b].deep)swap(a,b);
	int k=log2(vert[a].deep-vert[b].deep),ans=INT_MAX;
	while(k>=0){
		if((1<<k)<=vert[a].deep-vert[b].deep){
			ans=min(ans,minRoad[a][k]);
			a=ani[a][k];
		}
		k--;
	}
	if(a==b)return ans;
	k=log2(vert[a].deep);
	while(k>=0){
		if((1<<k)<=vert[a].deep&&ani[a][k]!=ani[b][k]){
			ans=min(ans,minRoad[a][k]);
			ans=min(ans,minRoad[b][k]);
			a=ani[a][k];
			b=ani[b][k];
		}
		k--;
	}
	ans=min(ans,minRoad[a][0]);
	ans=min(ans,minRoad[b][0]);
	return ans;
}
struct Node{
	int val;
	int l,r;
	int lc,rc;
	int mid(){return (l+r)/2;}
}tree[MaxN*100+1];
int treeSize=0;
int NewNode(){return ++treeSize;}
int NewNode(int l,int r){
	int p=NewNode();
	tree[p].l=l,tree[p].r=r;
	return p;
}
int Left(int u){return tree[u].lc?tree[u].lc:tree[u].lc=NewNode(tree[u].l,tree[u].mid());}
int Right(int u){return tree[u].rc?tree[u].rc:tree[u].rc=NewNode(tree[u].mid()+1,tree[u].r);}
void PushUp(int u){
	tree[u].val=0;
	if(tree[u].lc)tree[u].val+=tree[tree[u].lc].val;
	if(tree[u].rc)tree[u].val+=tree[tree[u].rc].val;
}
int Add(int u,int pos,int val){
	if(pos<tree[u].l||tree[u].r<pos)return u;
	int p=NewNode();
	tree[p]=tree[u];
	if(tree[u].l==tree[u].r){
		tree[p].val+=val;
		return p;
	}
	if(pos<=tree[u].mid())
		tree[p].lc=Add(Left(u),pos,val);
	else
		tree[p].rc=Add(Right(u),pos,val);
	PushUp(p);
	return p;
}
int Ask(int u,int l,int r){
	if(r<tree[u].l||tree[u].r<l)return 0;
	if(l<=tree[u].l&&tree[u].r<=r)return tree[u].val;
	int sum=0;
	if(tree[u].lc)sum+=Ask(tree[u].lc,l,r);
	if(tree[u].rc)sum+=Ask(tree[u].rc,l,r);
	return sum;
}
void ChainDfs(int u,int cTop){
	vert[u].cTop=cTop;
	if(cTop==u){
		vert[u].root=NewNode(1,1e9);
		vert[u].root=Add(
			vert[u].root,
			edge[vert[u].pEdge].before,
			edge[vert[u].pEdge].cost
		);
	}else{
		vert[u].root=Add(
			vert[vert[u].prt].root,
			edge[vert[u].pEdge].before,
			edge[vert[u].pEdge].cost
		);
	}
	for(auto&pi:g[u]){
		int v=pi.first;
		if(v==vert[u].prt)continue;
		if(vert[u].tagSon!=v)
			ChainDfs(v,v);
		else
			ChainDfs(v,cTop);
	}
}
void Solve(){
	cin>>n;
	for(int i=1;i<=n-1;i++){
		int u,v,a,b,c;
		cin>>u>>v>>a>>b>>c;
		g[u].emplace_back(v,i);
		g[v].emplace_back(u,i);
		edge[i]=Edge(a,b,c);
	}
	Prepare();
	ChainDfs(1,1);
	cin>>q;
	for(int i=1;i<=q;i++){
		int a,b,e;
		cin>>a>>b>>e;
		vector<int>rootSet;
		pair<int,int>spec;
		int lca=LCA(a,b);
		int u=a;
		while(vert[u].cTop!=vert[lca].cTop){
			rootSet.emplace_back(vert[u].root);
			u=vert[vert[u].cTop].prt;
		}
		int v=b;
		while(vert[v].cTop!=vert[lca].cTop){
			rootSet.emplace_back(vert[v].root);
			v=vert[vert[v].cTop].prt;
		}
		if(u!=v){
			if(vert[u].deep<vert[v].deep)
				spec=make_pair(vert[u].root,vert[v].root);
			else
				spec=make_pair(vert[v].root,vert[u].root);
		}
		int l=0,r=GetMinRoad(a,b)-1,mid;
		while(l<r){
			mid=(l+r+1)/2;
			int sum=0;
			for(int root:rootSet)sum+=Ask(root,1,mid);
			sum+=Ask(spec.second,1,mid)-Ask(spec.first,1,mid);
			if(sum<=e)
				l=mid;
			else
				r=mid-1;
		}
		cout<<l+1<<'\n';
	}
}
#undef int
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	Solve();
	return 0;
}
```

---

### Update 2023/12/11

[被海客了](/discuss/745331)

二分值域设错了

~~充分说明了这道题的数据之水~~

---


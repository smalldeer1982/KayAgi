# [CQOI2011] 动态逆序对

## 题目描述

对于序列 $a$，它的逆序对数定义为集合  
$$\{(i,j)| i<j \wedge a_i > a_j \}$$
中的元素个数。  

现在给出 $1\sim n$ 的一个排列，按照某种顺序依次删除 $m$ 个元素，你的任务是在每次删除一个元素**之前**统计整个序列的逆序对数。


## 说明/提示

【数据范围】   
对于 $100\%$ 的数据，$1\le n \le 10^5$，$1\le m \le 50000$。

【样例解释】  
删除每个元素之前的序列依次为：  
$$1,5,3,4,2$$  
$$1,3,4,2$$  
$$3,4,2$$  
$$3,2$$  

## 样例 #1

### 输入

```
5 4
1
5
3
4
2
5
1
4
2```

### 输出

```
5
2
2
1```

# 题解

## 作者：1010_ (赞：136)

此题解法颇多，在下略微讲解其二
其一：离线算法(cdq分治)

我们先找出对答案有贡献的点（i,j）对满足的条件：
$Time_{i}<Time_{j},Val_{i}<Val{j},Pos_{i}>Pos_{j}$
或 $Time_{i}<Time_{j},Val_{i}>Val{j},Pos_{i}<Pos_{j}$

那么这个问题就变成了经典的三维偏序问题，可以通过cdq分治来解决。

时间:$O(n log^2 n)$

空间:$O (n)$

```C++
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long ll;
int read(){
    int x=0,f=1;char ch=getchar();
    while (ch<'0'||ch>'9') ch=='-'&&(f=-1),ch=getchar();
    while (ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
    return x*f;
}
const int N=1e5+10;
struct AC{int m,v,d,id,t;}e[N<<1];
int n,m,tot;
int pos[N],a[N],c[N];ll ans[N];
bool cmp1(AC x,AC y){return x.d<y.d;}
void add(int x,int k){while (x<=n)c[x]+=k,x+=(x&(-x));}
int query(int x){int su=0;while(x)su+=c[x],x-=(x&(-x));return su;}
void cdq(int l,int r){
    if (l==r) return;
    int mid=(l+r)>>1,j=l;
    cdq(l,mid),cdq(mid+1,r);
    sort(e+l,e+mid+1,cmp1);
    sort(e+mid+1,e+r+1,cmp1);
    for (int i=mid+1;i<=r;++i){
        while (j<=mid&&e[j].d<=e[i].d)add(e[j].v,e[j].m),++j;
        ans[e[i].id]+=e[i].m*(query(n)-query(e[i].v));
    }
    for (int i=l;i<j;++i) add(e[i].v,-e[i].m);
    j=mid;
    for (int i=r;i>mid;--i){
        while (j>=l&&e[j].d>=e[i].d)add(e[j].v,e[j].m),--j;
        ans[e[i].id]+=e[i].m*query(e[i].v-1);
    }
    for (int i=mid;i>j;--i) add(e[i].v,-e[i].m);
}
int main(){
    n=read(),m=read();
    for (int i=1;i<=n;++i)a[i]=read(),pos[a[i]]=i,e[++tot]=(AC){1,a[i],i,0,tot};
    for (int i=1,x;i<=m;++i)x=read(),e[++tot]=(AC){-1,x,pos[x],i,tot};
    cdq(1,tot);
    for (int i=1;i<=m;++i) ans[i]+=ans[i-1];
    for (int i=0;i<m;++i) printf("%lld\n",ans[i]);
    return 0;
}
```

其二：在线算法(树状数组套线段树)

然而cdq分治是一种离线算法，所以为了防止出题人毒瘤，我们需要进一步学习其在线算法。

下面介绍一种树状数组套线段树的做法。

用树状数组访问位置,用线段树访问权值,每个点的贡献就是与其权值和位置大小关系不等的点的个数

线段树需要动态开点,每次访问最多新开$log^2$个新节点,所以空间是$O(n log^2 n)$的

时间:$O(n log ^2 n)$

空间:$O(n log^2 n)$

```c++
#include<cstdio>
#define ll long long
#define low(x) (x&(-x))
int read(){
    int x=0,f=1;char ch=getchar();
    while (ch<'0'||ch>'9') ch=='-'&&(f=-1),ch=getchar();
    while (ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
    return x*f;
}
const int N=1e5+10,M=3e7+10;
int n,m,tot;ll ans;
int a[N],pos[N],quea[N],queb[N];
int rt[N],t[M],ls[M],rs[M];
void change(int&p,int l,int r,int x,int y){
    if (!p) p=++tot;t[p]+=y;
    if (l==r) return;
    int mid=(l+r)>>1;
    if (x<=mid) change(ls[p],l,mid,x,y);
    else change(rs[p],mid+1,r,x,y);
}
int query(int l,int r,int x,int mode){
    int cnta=0,cntb=0,sum=0,mid;
    for (int i=l-1;i;i-=low(i)) quea[++cnta]=rt[i];
    for (int i=r;i;i-=low(i)) queb[++cntb]=rt[i];
    l=1,r=n;
    while (l!=r){
        mid=(l+r)>>1;
        if (x>mid) {
            if (mode){
                for (int i=1;i<=cnta;++i) sum-=t[ls[quea[i]]];
                for (int i=1;i<=cntb;++i) sum+=t[ls[queb[i]]];
            }
            for (int i=1;i<=cnta;++i) quea[i]=rs[quea[i]];
            for (int i=1;i<=cntb;++i) queb[i]=rs[queb[i]];
            l=mid+1;
        }
        else{
            if (!mode){
                for (int i=1;i<=cnta;++i) sum-=t[rs[quea[i]]];
                for (int i=1;i<=cntb;++i) sum+=t[rs[queb[i]]];
            }
            for (int i=1;i<=cnta;++i) quea[i]=ls[quea[i]];
            for (int i=1;i<=cntb;++i) queb[i]=ls[queb[i]];
            r=mid;
        }
    }
    return sum;
}
int main(){
    n=read(),m=read();
    for (int i=1;i<=n;++i){
        a[i]=read();pos[a[i]]=i;
        ans+=query(1,i-1,a[i],0);
        for (int j=i;j<=n;j+=low(j)) change(rt[j],1,n,a[i],1);
    }
    printf("%lld\n",ans);
    for (int i=1,x;i<m;++i){
        x=read();
        ans-=query(1,pos[x]-1,x,0);
        ans-=query(pos[x]+1,n,x,1);
        printf("%lld\n",ans);
        for (int j=pos[x];j<=n;j+=low(j)) change(rt[j],1,n,x,-1);
    }
    return 0;
}
```

---

## 作者：shadowice1984 (赞：95)

恩这道题典型的CDQ分治思想（洛谷上A的第100题,撒花~）

顺便以此讲解一下CDQ的板子吧

（其实哪里有什么板子，中间部分各种魔改）

CDq的思想是基于分治原理的

如果任何两个操作-询问对被且仅被执行了一次，那么这个操作-询问序列一定是准的

所以我们将一个操作重复做logN次

每次操作作用于不同的logN个询问段，这样完成了logN^2的复杂度

(有点像线段树的区间拆分法，但只是像)

下面来看这道动态逆序对

发现只要求出初始逆序对，然后每次求出降低的逆序对即可

对于每一个被删的元素，消失的逆序对等于

在**它前面**，**权值**比他大，且**删去时间**比他晚的点个数+

在**它后面**，**权值**比他小，且**删去时间**比他晚的点个数

那么每一个点上维护三个属性，位置，权值，删去时间

先静态排序，削去一维

就变成了我们熟悉的双统计问题

限制1：删去时间晚；限制2：权值大于（或小于关系）

先摁死一维，比如把权值排个序

那么只剩下删去时间了

由于还要保证CDQ要求的相对位序，所以我们的排序都是在内部进行

（也就是你CDQ分的区间(l,r)）这样对于(l,mid)和(mid,r)这两个区间来讲

(l,mid)的位置统统小于(mid，r)，但是(l,mid)和(mid,r)内部的位置关系已经不确定了，因为你对这两个区间内部按的权值排序）

这样的话其实是对左区间的每一个元素都统计一下右区间有多少个符合要求的点

再对右区间的每一个元素都统计一下左区间有多少个符合要求的点

对于这个，我们可以用树状数组来统计，因为限制已经被削成一维的了

具体来讲，保证对于左边的一个点i，权值比他大的右边点全被加了进去

每次加一个右边点，它的删去时间那个位置就+1

然后统计一个（i的删除时间，m+1）就行了

右边点的计算同理，记得开long long

上代码~

```cpp
    #include<cstdio>
    #include<algorithm>
    using namespace std;
    typedef long long ll;
    int n;int m;
    struct treearray//4行树状数组
    {
        int ta[200010];
        inline void ub(int& x){x+=x&(-x);}inline void db(int& x){x-=x&(-x);}
        inline void c(int x,int t){for(;x<=n+1;ub(x))ta[x]+=t;}
        inline int sum(int x){int r=0;for(;x>0;db(x))r+=ta[x];return r;}
    }ta;
    struct data{int val;int del;int ans;}a[100010];int rv[100010];ll res;//点
    bool cmp1(const data& a,const data& b){return a.val<b.val;}
    bool cmp2(const data& a,const data& b){return a.del<b.del;}
    void solve(int l,int r)//CDQ统计
    {
        if(r-l==1){return;}int mid=(l+r)/2;
        solve(l,mid);solve(mid,r);//先处理好左边和右边
        int i=l+1;int j=mid+1;
        while(i<=mid)
        {
            while(a[i].val>a[j].val&&j<=r){ta.c(a[j].del,1);j++;}//保证左边大于右边
            a[i].ans+=ta.sum(m+1)-ta.sum(a[i].del);i++;//统计
        }i=l+1;j=mid+1;//回撤操作
        while(i<=mid){while(a[i].val>a[j].val&&j<=r){ta.c(a[j].del,-1);j++;}i++;}
        i=mid;j=r;
        while(j>mid)
        {
            while(a[j].val<a[i].val&&i>l){ta.c(a[i].del,1);i--;}//保证右边大于左边
            a[j].ans+=ta.sum(m+1)-ta.sum(a[j].del);j--;//统计
        }i=mid;j=r;//回撤操作
        while(j>mid){while(a[j].val<a[i].val&&i>l){ta.c(a[i].del,-1);i--;}j--;}
        sort(a+l+1,a+r+1,cmp1);return;//排好序，为上一层的CDQ做准备
    }
    int main()
    {
        scanf("%d%d",&n,&m);
        for(int i=1;i<=n;i++){scanf("%d",&a[i].val);rv[a[i].val]=i;}
        for(int i=1;i<=m;i++){int p;scanf("%d",&p);a[rv[p]].del=i;}
        for(int i=1;i<=n;i++){if(a[i].del==0)a[i].del=m+1;}//计算初始逆序
        for(int i=1;i<=n;i++){res+=ta.sum(n+1)-ta.sum(a[i].val);ta.c(a[i].val,1);}
        for(int i=1;i<=n;i++){ta.c(a[i].val,-1);}solve(0,n);sort(a+1,a+n+1,cmp2);
        for(int i=1;i<=m;i++){printf("%lld\n",res);res-=a[i].ans;}return 0;//拜拜程序~
    }

```

---

## 作者：Hank (赞：53)

**好像没有暴力分块的题解,这里就发一个吧**

**n=100000,开block=1000 分块,刚好符合内存和时间要求,我就乱搞了个block=1000,然后最多有100个块,每一个块单独开一个树状数组,然后就像平时求逆序对一样,直接在a[i]对应的位置+1,然后删除就是-1,对于同一个块内,直接暴力搞,不同块也直接枚举每一个块,分别查一次树状数组,然后ans减去这个数的贡献就是当前的答案**


[代码看这里](http://www.cnblogs.com/Yuzao/p/7420571.html)


---

## 作者：SofanHe (赞：38)

大佬们太强了，题解超级优质可惜本巨弱根本看不懂啊。

我来讲一下一个刚学会主席树的人怎么看遍所有看不懂的题解然后写出来这个题吧。

首先，题解上好多CDQ分治，这个东西我不讲，我来讲一下主席树的做法。

普通的树状数组求逆序对大家肯定会吧。

那么删除第一个前的逆序对自然能求出来，此时我们考虑删除第一个元素，减少的逆序对个数就是在它前面的比他大的和在它后面比它小的，于是我们开两个数组来存:

as1[i]表示的就是在i前面而且大于i位置上的元素的元素的个数

as2[i]表示的就是在i后面而且小于i位置上的元素的元素的个数

as1[i]就可以在读入的时候直接处理一下

BIT就是简单的前缀和树状数组.

```cpp
for(int i=1;i<=n;++i){
	scanf("%d",&endq[i]);
	as1[i]=BIT.queryb(n)-BIT.queryb(endq[i]);
	ans+=as1[i];
	BIT.addb(endq[i],1);
}
```

as2[i]可以反向添加然后处理出来

```cpp
for(int i=n;i>=1;--i){
	as2[i]=BIT.queryb(endq[i]-1);
	BIT.addb(endq[i],1);
}
```

但是又有一个问题了,我已经删了的还是被计算在内了,怎么办?

我减去它与已经删了的构成的逆序对的个数不就好了吗?

那么我们就做成了什么?

每一次在已经删除的元素里面找[l,r]里面小于某个数的元素的个数,很容易想到主席树来做.

既然是维护前缀和的主席树,那是不是我每修改一个都要向后一直修改?

显然复杂度爆表.

前缀和我们还有一种求法,那就是用树状数组,那我能不能用树状数组来代替这种一般前缀和?

显然是可以的,我们每次修改的时候,按照树状数组那样,一直向上修改,求前缀和也像树状数组那样不断加和就好了.

至此,一个树状数组套主席树解决动态逆序对就完结了.

有什么不懂的欢迎提问原作者我

全代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,endq[100010],pls[100010];//pls[i]记录的是i的位置
long long ans=0;
struct Zxt{
	#define Nmax 6000001
	#define mid ((ln+rn)>>1)
	#define out_it (ln>rd || rn<ld)
	#define in_it (ln>=ld && rn<=rd)
	long long sum[Nmax],tailn;
	int ls[Nmax],rs[Nmax],root[Nmax];
	void add(int &num,int ln,int rn,int pos){
		if(!num){
			num=++tailn;
		}
		++sum[num];
		if(ln==rn)
			return;
		if(pos<=mid)
			add(ls[num],ln,mid,pos);
		else
			add(rs[num],mid+1,rn,pos);
	}
	long long query(int num1,int ln,int rn,int ld,int rd){//last jian old
		if(out_it)
			return 0;
		if(in_it)
			return sum[num1];
		return query(ls[num1],ln,mid,ld,rd)+
			query(rs[num1],mid+1,rn,ld,rd);
	}
	long long find(int pos1,int pos2,int lowest,int uppest){
		if(lowest>uppest)
			return 0;
		long long asp=0;
		for(;pos2;pos2-=(pos2)&(-pos2))
			asp+=query(root[pos2],1,n,lowest,uppest);
		for(;pos1;pos1-=(pos1)&(-pos1))
			asp-=query(root[pos1],1,n,lowest,uppest);
		return asp;
	}
}Zxt;
struct BITs{
	long long val[100001];
	int lowbit(int x){
		return x&(-x);
	}
	void addb(int pos,int num){
		for(;pos<=100000;pos+=lowbit(pos))
			val[pos]+=num;
	}
	long long queryb(int pos){
		long long ans=0;
		for(;pos;pos-=lowbit(pos))
			ans+=val[pos];
		return ans;
	}
}BIT;
long long as1[100001],as2[100001],p1,p2;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i){
		scanf("%d",&endq[i]);
		pls[endq[i]]=i;
		as1[i]=BIT.queryb(n)-BIT.queryb(endq[i]);
		ans+=as1[i];
		BIT.addb(endq[i],1);
	}
	for(int i=1;i<=100000;++i)	BIT.val[i]=0;//防止第二遍统计出问题 
	for(int i=n;i>=1;--i){
		as2[i]=BIT.queryb(endq[i]-1);
		BIT.addb(endq[i],1);
	}//原来的BIT已经用完了，没用了，剩下的就是树状数组思想了 
	for(int i=1;i<=m;++i){
		printf("%lld\n",ans);//注意是先输出,因为是删除前.
		scanf("%lld",&p1);
		p2=pls[p1];
		ans-=(as1[p2]+as2[p2])-(Zxt.find(0,p2,p1+1,n)+Zxt.find(p2,n,1,p1-1));
		for(int qqq=p2;qqq<=n;qqq+=qqq&(-qqq))
			Zxt.add(Zxt.root[qqq],1,n,p1);
	}
	return 0;
}

```

---

## 作者：zcysky (赞：30)

其实我是想练CDQ分治的……结果忍不住又写了个主席树。

首先看看不动态的逆序对咋做？树状数组嘛。

那么删除咋搞？就是考虑贡献，把它前面比他大的，后面比他小的减去……

所以就是一个带修改的主席树啦。

带修改主席树很套路的吧。

不会这个东西的可以去做dynamic rankinga

我在这里就简单说一下吧

普通主席树差分实现

带修改的话主席树维护形态，树状数组维护前缀和。

好了，没了。

所以这题就很简单了。

```cpp
#include<bits/stdc++.h>
#define inf 0x7fffffff
#define N 100005
#define M 5000005
using namespace std;
typedef long long ll;
ll ans;
int n,m,sz,a[100],b[100],val[N],pos[N],a1[N],a2[N];
int c[N*10],rt[N],ls[M],rs[M],sumv[M];
inline int lowbit(int x){return x&(-x);}
inline int ask(int x){
    int ans=0;
    for(int i=x;i;i-=lowbit(i))ans+=c[i];
    return ans;
}
void change(int &o,int l,int r,int q){
    if(!o)o=++sz;sumv[o]++;
    if(l==r)return;
    int mid=(l+r)>>1;
    if(q<=mid)change(ls[o],l,mid,q);
    else change(rs[o],mid+1,r,q);
}
int querysub(int x,int y,int v){
    int cnta=0,cntb=0;int ans=0;x--;
    for(int i=x;i;i-=lowbit(i))a[++cnta]=rt[i];
    for(int i=y;i;i-=lowbit(i))b[++cntb]=rt[i];
    int l=1,r=n;
    while(l!=r){
        int mid=(l+r)>>1;
        if(v<=mid){
            for(int i=1;i<=cnta;i++)ans-=sumv[rs[a[i]]];
            for(int i=1;i<=cntb;i++)ans+=sumv[rs[b[i]]];
            for(int i=1;i<=cnta;i++)a[i]=ls[a[i]];
            for(int i=1;i<=cntb;i++)b[i]=ls[b[i]];
            r=mid;
        }
        else{
            for(int i=1;i<=cnta;i++)a[i]=rs[a[i]];
            for(int i=1;i<=cntb;i++)b[i]=rs[b[i]];
            l=mid+1;
        }
    }
    return ans;
}
int querypre(int x,int y,int v){
    int cnta=0,cntb=0,ans=0;x--;
    for(int i=x;i;i-=lowbit(i))a[++cnta]=rt[i];
    for(int i=y;i;i-=lowbit(i))b[++cntb]=rt[i];
    int l=1,r=n;
    while(l!=r){
        int mid=(l+r)>>1;
        if(v>mid){
            for(int i=1;i<=cnta;i++)ans-=sumv[ls[a[i]]];
            for(int i=1;i<=cntb;i++)ans+=sumv[ls[b[i]]];
            for(int i=1;i<=cnta;i++)a[i]=rs[a[i]];
            for(int i=1;i<=cntb;i++)b[i]=rs[b[i]];
            l=mid+1;
        }
        else{
            for(int i=1;i<=cnta;i++)a[i]=ls[a[i]];
            for(int i=1;i<=cntb;i++)b[i]=ls[b[i]];
            r=mid;
        }
    }
    return ans;
}
inline int read(){
    int f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
int main(){
    n=read();m=read();
    for(int i=1;i<=n;i++){
        val[i]=read();pos[val[i]]=i;
        a1[i]=ask(n)-ask(val[i]);
        ans+=a1[i];
        for(int j=val[i];j<=n;j+=lowbit(j))c[j]++;
    }
    memset(c,0,sizeof(c));
    for(int i=n;i;i--){
        a2[i]=ask(val[i]-1);
        for(int j=val[i];j<=n;j+=lowbit(j))c[j]++;
    }
    for(int i=1;i<=m;i++){
        printf("%lld\n",ans);
        int x=read();x=pos[x];
        ans-=(a1[x]+a2[x]-querysub(1,x-1,val[x])-querypre(x+1,n,val[x]));
        for(int j=x;j<=n;j+=lowbit(j))change(rt[j],1,n,val[x]);
    }
    return 0;
}
```

---

## 作者：「QQ红包」 (赞：27)

my blog: redbag.pw


写的cdq分治。


考虑删除一个数$i​$ ，$i​$对答案的影响只有$i​$产生的贡献和$i​$对后面产生的影响


$x$：删除时间，$y$：位置，$z$：权值


求$i'$的逆序对：$x>x'$，$y<y'$，$z>z'$，求出一个答案$f_i$


考虑 $i'$ 对后面的影响：$x>x'$，$y>y'$，$z<z'$，求出一个答案$g_i$


对于最后没有删除的点，根据位置随便加一个删除时间。


然后就是三位偏序了。


求 $f_i$ ，按照删除时间从大到小排序，左边排 $z$ ，树状数组更 $y$


求 $g_i$ ，按照删除时间从大到小排序，左边排 $y$ ，树状数组更 $z$


最后扫一遍，更答案。


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int qmax(int &x,int y) {if (x<y) x=y;}
int qmin(int &x,int y) {if (x>y) x=y;}
int read()
{
    char s;
    int k=0,base=1;
    while((s=getchar())!='-'&&s!=EOF&&!(isdigit(s)));
    if(s=='-')base=-1,s=getchar();
    while(isdigit(s))
    {
        k=k*10+(s^'0');
        s=getchar();
    }
    return k*base;
}
void write(ll x)
{
    if(x<0)
    {
        putchar('-');
        write(-x);
    }
    else
    {
        if(x/10) write(x/10);putchar(x%10+'0');
    }
}
const int maxn=1e5+100;
const int maxm=5e4+100;
int n,m;
int b[maxn],c[maxn];
int t[maxn];
ll ans;
struct node
{
    int x,y,z;//x:删除的时间 y:pos z:值
    int f,g;
} a[maxn],A[maxn];

inline void xg(int x,int y)
{
    while (x<=n)
    {
        *(t+x)+=y;
        x+=x&(-x);
    }
}
inline int qsum(int x)
{
    int sum=0;
    while (x)
    {
        sum+=*(t+x);
        x-=x&(-x);
    }
    return sum;
}

bool cmp(node aa,node bb)//按照位置排序
{
    return aa.y<bb.y;
}
bool cmp1(node aa,node bb)//按照删除时间排
{
    return aa.x>bb.x;
}
bool cmp2(node aa,node bb)
{
    return aa.x<bb.x;
}
void cdq(int x,int y)
{
    if (x==y) return;
    int mid=(x+y)>>1;
    cdq(x,mid);cdq(mid+1,y);
    int l=x,r=mid+1,p=0;
    while (r<=y)//统答案
    {
        while (l<=mid&&a[l].z>a[r].z) {xg(a[l].y,1);l++;}
        a[r].f+=qsum(a[r].y);
        r++;
    }
    for (int i=x;i<l;i++) xg(a[i].y,-1);

    l=x,r=mid+1,p=x-1;//归并
    while (l<=mid&&r<=y)
    {
        if (a[l].z>a[r].z) A[++p]=a[l++]; else A[++p]=a[r++];
    }
    while (l<=mid) A[++p]=a[l++];
    while (r<=y) A[++p]=a[r++];
    for (int i=x;i<=y;i++) a[i]=A[i];
}
void CDQ(int x,int y)
{
    if (x==y) return;
    int mid=(x+y)>>1;
    CDQ(x,mid);CDQ(mid+1,y);
    int l=x,r=mid+1,p=0;
    while (r<=y)
    {
        while (l<=mid&&a[l].y>a[r].y) {xg(a[l].z,1);l++;}
        a[r].g+=qsum(a[r].z);
        r++;
    }
    for (int i=x;i<l;i++) xg(a[i].z,-1);//memset太慢了，不如一个个清

    l=x,r=mid+1,p=x-1;//按照y的大小合并
    while (l<=mid&&r<=y)
    {
        if (a[l].y>a[r].y) A[++p]=a[l++]; else A[++p]=a[r++];
    }
    while (l<=mid) A[++p]=a[l++];
    while (r<=y) A[++p]=a[r++];
    for (int i=x;i<=y;i++) a[i]=A[i];
}
int main()
{
    freopen("1.in","r",stdin);
    freopen("1.out","w",stdout);
    n=read();m=read();//a数组初始按值排序
    for (int i=1;i<=n;i++)
    {
        *(b+i)=read();
        a[b[i]].y=i;
        a[b[i]].z=b[i];
        ans+=i-1-qsum(b[i]);
        xg(b[i],1);
    }
    memset(t,0,sizeof(t));
    for (int i=1;i<=m;i++)
    {
        *(c+i)=read();
        a[c[i]].x=i;
    }
    sort(a+1,a+n+1,cmp);
    for (int i=1,j=m+1;i<=n;i++)
    {
        if (a[i].x==0) a[i].x=j++;
    }
    sort(a+1,a+n+1,cmp1);
    cdq(1,n);//求出f[i]
    sort(a+1,a+n+1,cmp1);
    CDQ(1,n);//求出g[i]
    sort(a+1,a+n+1,cmp2);
    for (int i=1;i<=m;i++)
    {
        write(ans);
        putchar('\n');
        ans=ans-(ll)a[i].f-(ll)a[i].g;
    }
    return 0;
}

```

---

## 作者：人殇物已非 (赞：21)

#### cdq分治延续II

在经过了无数cdq分治的历练后 ~~（咳咳，个位数）~~，我们已经可以一眼秒看出这个题明显可以三维偏序搞出来了。

那么，怎么三维偏序呢，直接考虑每次更新之后的逆序对个数的话好像叭是很好做，那不如反过来想，每次去考虑当前数字被删除之后会减少多少个逆序对，而这个问题就很简单了。

对于每个数字，删除之后减少的逆序对数，即为它对全局的贡献，显然就是：

- 在它之前且比它大/在它之后且比它小
- 删除时间比它晚

对于没有删除的元素，删除时间赋值为无穷大（注意不要RE了....）。

### $code:$
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxq=2e5+9;
struct query{
    int id,time,val;//序列位置,被删时间,值 
}q[maxq],tmp[maxq];
int n,m;
int aid=0,a[maxq],ans[maxq],poi[maxq];
int c[maxq];int vis[maxq];
#define lowbit(x) (x&(-x))
void add(int i,int x){for(;i<=n;i+=lowbit(i)) c[i]+=x;}
int sum(int i){int ret=0;for(;i;i-=lowbit(i)) ret+=c[i];return ret;}
void clr(int i){for(;i<=n;i+=lowbit(i)) c[i]=0;}
inline bool cmp(query &a,query &b){
    return a.time>b.time;
}
int pre(){
    int ret=0;
    for(int i=n;i>=1;i--){
        ret+=sum(a[i]-1);
        add(a[i],1);
    }
    memset(c,0,sizeof(c));
    return ret;
}
void cdq(int l,int r){//大,前,删除时间晚。
    if(l==r) return;
    int mid=(l+r)>>1;
    cdq(l,mid),cdq(mid+1,r);
    int i=l,j=mid+1,k=l;
    while(i<=mid && j<=r){
        if(q[i].id<q[j].id){
            add(q[i].val,1);
            tmp[k++]=q[i++];		
        }
        else{			
            ans[q[j].time]+=sum(n)-sum(q[j].val);
            tmp[k++]=q[j++];
        }
    }
    while(i<=mid) tmp[k++]=q[i++];
    while(j<=r){
        ans[q[j].time]+=sum(n)-sum(q[j].val);
        tmp[k++]=q[j++];	
    }
    for(int i=l;i<=mid;i++){
        clr(q[i].val),q[i]=tmp[i];
    }
    for(int i=mid+1;i<=r;i++) q[i]=tmp[i];
}
void cdq1(int l,int r){//小,后,删除时间晚。
    if(l==r) return;
    int mid=(l+r)>>1;
    cdq1(l,mid),cdq1(mid+1,r);
    int i=l,j=mid+1,k=l;
    while(i<=mid && j<=r){
        if(q[i].id>q[j].id){
            add(q[i].val,1);
            tmp[k++]=q[i++];		
        }
        else{			
            ans[q[j].time]+=sum(q[j].val-1);
            tmp[k++]=q[j++];
        }
    }
    while(i<=mid) tmp[k++]=q[i++];
    while(j<=r){
        ans[q[j].time]+=sum(q[j].val-1);
        tmp[k++]=q[j++];	
    }
    for(int i=l;i<=mid;i++){
        clr(q[i].val),q[i]=tmp[i];
    }
    for(int i=mid+1;i<=r;i++) q[i]=tmp[i];
}
#undef int
int main(){
    cin>>n>>m;
    for(int i=1,x;i<=n;i++){
        scanf("%d",&x);poi[x]=i;
        a[i]=x;
        q[++aid]=(query){i,2e5,x};
    }
    for(int i=1,x;i<=m;i++){
        scanf("%d",&x);
        q[poi[x]].time=i;
    }
    ans[0]=pre();
    sort(q+1,q+1+aid,cmp);
    cdq(1,aid);
    sort(q+1,q+1+aid,cmp);
    cdq1(1,aid);
    printf("%lld\n",ans[0]);
    for(int i=1;i<=m-1;i++){
        ans[i]=ans[i-1]-ans[i];
        printf("%lld\n",ans[i]);
    }
    return 0;
}
```

---

## 作者：Void_f (赞：16)

我分享一下CDQ分治的做法，

可以看成把数字倒着插入，记录一个时间点
然后统计每个时间点的答案即可，用树状数组维护

这题的答案统计十分的有趣，具体看注释
```cpp
#include <cstdio>
#include <algorithm>
#define lowbit(x) ((x)&(-x))
#define N 150010
#define ll long long
using namespace std;
 
struct info{
    int t,x,y;
    info(){}
    info(int a,int b,int c):t(a),x(b),y(c){}
    friend bool operator <(info a,info b){return (a.x==b.x)?a.y<b.y:a.x<b.x;}
}A[N],tmp[N];
int n,mm,pos[N];
ll Ans[N];
 
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
 
namespace bit{
    int T[N];
    inline void add(int x,int v){for(;x<=n;x+=lowbit(x))T[x]+=v;}
    inline int sum(int x){int r=0;for(;x;x-=lowbit(x))r+=T[x];return r;}
    inline void clear(int x){for(;x<=n&&T[x];x+=lowbit(x))T[x]=0;}
}
 
void solve(int l,int r){
    if(l==r) return;
    int m=(l+r)>>1;
    solve(l,m),solve(m+1,r);
    for(int p=l,q=m+1,cnt=l;p<=m||q<=r;)
        if(q>r||p<=m&&A[p]<A[q]) bit::add(A[p].y,1),tmp[cnt++]=A[p++];
        else Ans[A[q].t]+=bit::sum(n)-bit::sum(A[q].y),tmp[cnt++]=A[q++];
    for(int i=l;i<=m;++i) bit::clear(A[i].y);
    for(int i=l;i<=r;++i) A[i]=tmp[i];
    //Ans{i]算的是单个贡献，所以不仅要算前面比它大的，还要算后面比它小的
    for(int i=r;i>=l;--i)
        if(A[i].t<=m) bit::add(A[i].y,1);
        else Ans[A[i].t]+=bit::sum(A[i].y);
    for(int i=l;i<=r;++i) bit::clear(A[i].y);
}
 
bool cmpt(info a,info b){return a.t<b.t;}
int main(){
    n=read(),mm=read();
    for(int i=1,x;i<=n;++i) pos[x=read()]=i,A[i]=info(0,i,x);
    int tim=n;
    for(int i=1,x;i<=mm;++i) A[pos[read()]].t=tim--;
    for(int i=1;i<=n;++i) if(!A[i].t) A[i].t=tim--;
    sort(A+1,A+n+1,cmpt);  
    solve(1,n);
    //此时算出的Ans[i]是对于单个数的贡献，而答案要求此时所有的逆序对，所以应该做一个前缀和
    for(int i=1;i<=n;++i) Ans[i]+=Ans[i-1];
    for(int i=n;i>=n-mm+1;--i) printf("%lld\n",Ans[i]);
    return 0;
}
```

---

## 作者：bztMinamoto (赞：16)

先贴[blog](https://www.cnblogs.com/bztMinamoto/p/9396076.html)

原来还以为自己已经会带修改主席树了呢……才发现自己还是太naive……


zcysky大佬写的太吼啦！

然而我还是还是来详细的说一说好了……zcysky大佬写的也太简单了……

先考虑无修改的逆序对怎么做？

很明显，用树状数组（虽然我今天之前一直以为逆序对个数只能用归并做）

我们记$a1[i]$表示在$i$之前且比$i$大的数的个数（注意，这里的i指的是位置），那么很明显答案为$\sum _{i=1}^n a[i]$

```
for(int i=1;i<=n;++i){
	val[i]=read(),pos[val[i]]=i;
	a1[i]=ask(n)-ask(val[i]);
	ans+=a1[i];
	for(int j=val[i];j<=n;j+=lowbit(j)) ++c[j];
}
```

记$a2[i]$表示在$i$之后且比$i$小的数的个数，只要把上面那个倒着推就行了

```
for(int i=n;i;--i){
	a2[i]=ask(val[i]-1);
	for(int j=val[i];j<=n;j+=lowbit(j)) ++c[j];
}
```
接下来我们考虑修改操作。

每一次将一个数删除，减少的逆序对个数是多少？

很明显是$a1[i]+a2[i]$，然后我们就可以做啦

于是评测机表示并不想理你并丢给你一堆WA

这个时候我们发现自己忽略了一个关键的问题，如果$a1[i]$和$a2[i]$中表示的数已经有被删除了的怎么办？

我们只要把这些被删除的数减去即可

具体来说，我们可以考虑用一个带修改主席树维护

因为主席树维护的是前缀和

如果按照一般思想，一个一个去更改太浪费时间了

我们想到，前缀和可以用树状数组的思想来维护

于是我们可以用树状数组的思想建主席树

于是每一次更改就可以减少到做$log n$次了

所以每一次删去一个数，我们就在主席树上插入这个数

要算答案时，只要减去$a1[i]$和$a2[i]$，再把删除的数加回来就好了

只要在主席树上$[1,i-1]$区间中大于$val[i]$的数的个数和$[i+1,n]$区间中小于$val[i]$的数的个数即可
```
//minamoto
#include<bits/stdc++.h>
#define N 100005
#define M 5000005
#define ll long long
using namespace std;
#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline ll read(){
    #define num ch-'0'
    char ch;bool flag=0;ll res;
    while(!isdigit(ch=getc()))
    (ch=='-')&&(flag=true);
    for(res=num;isdigit(ch=getc());res=res*10+num);
    (flag)&&(res=-res);
    #undef num
    return res;
}
char obuf[1<<24],*o=obuf;
void print(ll x){
    if(x>9) print(x/10);
    *o++=x%10+48;
}
int L[M],R[M],sum[M],rt[N];
int val[N],pos[N],xx[N],yy[N],c[N],a1[N],a2[N];
int n,cnt,q;ll ans=0;
inline int lowbit(int x){return x&(-x);}
int ask(int x){
    int s=0;
    for(int i=x;i;i-=lowbit(i)) s+=c[i];
    return s;
}
void update(int &now,int l,int r,int k){
    if(!now) now=++cnt;
    ++sum[now];
    if(l==r) return;
    int mid=(l+r)>>1;
    if(k<=mid) update(L[now],l,mid,k);
    else update(R[now],mid+1,r,k);
}
int querysub(int x,int y,int v){
    int cntx=0,cnty=0,ans=0;--x;
    for(int i=x;i;i-=lowbit(i)) xx[++cntx]=rt[i];
    for(int i=y;i;i-=lowbit(i)) yy[++cnty]=rt[i];
    int l=1,r=n;
    while(l<r){
        int mid=(l+r)>>1;
        if(v<=mid){
            for(int i=1;i<=cntx;++i) ans-=sum[R[xx[i]]];
            for(int i=1;i<=cnty;++i) ans+=sum[R[yy[i]]];
            for(int i=1;i<=cntx;++i) xx[i]=L[xx[i]];
            for(int i=1;i<=cnty;++i) yy[i]=L[yy[i]];
            r=mid;
        }
        else{
            for(int i=1;i<=cntx;++i) xx[i]=R[xx[i]];
            for(int i=1;i<=cnty;++i) yy[i]=R[yy[i]];
            l=mid+1;
        }
    }
    return ans;
}
int querypre(int x,int y,int v){
    int cntx=0,cnty=0,ans=0;--x;
    for(int i=x;i;i-=lowbit(i)) xx[++cntx]=rt[i];
    for(int i=y;i;i-=lowbit(i)) yy[++cnty]=rt[i];
    int l=1,r=n;
    while(l<r){
        int mid=(l+r)>>1;
        if(v>mid){
            for(int i=1;i<=cntx;++i) ans-=sum[L[xx[i]]];
            for(int i=1;i<=cnty;++i) ans+=sum[L[yy[i]]];
            for(int i=1;i<=cntx;++i) xx[i]=R[xx[i]];
            for(int i=1;i<=cnty;++i) yy[i]=R[yy[i]];
            l=mid+1;
        }
        else{
            for(int i=1;i<=cntx;++i) xx[i]=L[xx[i]];
            for(int i=1;i<=cnty;++i) yy[i]=L[yy[i]];
            r=mid;
        }
    }
    return ans;
}
int main(){
    //freopen("testdata.in","r",stdin);
    n=read(),q=read();
    for(int i=1;i<=n;++i){
        val[i]=read(),pos[val[i]]=i;
        a1[i]=ask(n)-ask(val[i]);
        ans+=a1[i];
        for(int j=val[i];j<=n;j+=lowbit(j)) ++c[j];
    }
    memset(c,0,sizeof(c));
    for(int i=n;i;--i){
        a2[i]=ask(val[i]-1);
        for(int j=val[i];j<=n;j+=lowbit(j)) ++c[j];
    }
    while(q--){
        print(ans),*o++='\n';
        int x=read();x=pos[x];
        ans-=(a1[x]+a2[x]-querysub(1,x-1,val[x])-querypre(x+1,n,val[x]));
        for(int j=x;j<=n;j+=lowbit(j)) update(rt[j],1,n,val[x]);
    }
    fwrite(obuf,o-obuf,1,stdout);
    return 0;
}
```

---

## 作者：wu3412790 (赞：14)

本题可以使用分块轻松搞定。因为N<=100000，可以将原数列分成不超过100个大小为1000的块。这样每次删除一个元素时，我们只需要在每块中查找和它组成逆序对的元素个数，这可以通过将每块里的元素排好序，然后二分做到。具体点说，假设删除的元素是x，它在第j块，那么我们在前j-1块中分别用二分找大于x的数的个数，在j+1块及以后的块中用二分找小于x的数的个数，最后在第j块中一遍循环暴力找到和x组成逆序对的数的个数即可。因为删除操作只有50000个，加上常数很小，全部测试点在2.5s内搞定，效率并不低。


```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int const N=1e5+1,M=1e2+1,B=1e3;
int n,m,q,b[M][B+1],p[N];
long long ans=0,t[N];
int lowbit(int x){
	return x & (-x);
}
void add(int x, int v){
	if (x>n) return;
	t[x]+=v;
	add(x+lowbit(x),v);
}
long long ask(int x){
	return x?t[x]+ask(x-lowbit(x)):0;
}
int find(int k, int x){
	if (!b[k][0]) return 0;
	int l=1,r=b[k][0];
	while(r-l>1){
		int mid=((l+r)>>1);
		if (b[k][mid]<x) l=mid; else r=mid-1;
	}
	if (b[k][r]<x) return r;
	if (b[k][l]<x) return l;
	return 0;
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>q;
	int m=(n-1)/B+1;
	for (int i=1;i<=n;i++){
		int a;
		cin>>a;
		int j=(i-1)/B+1;
		b[j][++b[j][0]]=a;
		p[a]=i;
		ans+=(long long) i-1-ask(a);
		add(a,1);
	}
	for (int i=1;i<=m;i++)
		sort(b[i]+1,b[i]+1+b[i][0]);
	for (int i=1;i<=q;i++){
		cout<<ans<<endl;
		int x;
		cin>>x;
		int j=(p[x]-1)/B+1;
		for (int k=1;k<=j-1;k++)
			ans-=(b[k][0]-find(k,x));
		for (int k=j+1;k<=m;k++)
			ans-=find(k,x);
		for (int k=1;k<=b[j][0];k++)
			if ((p[b[j][k]]<p[x] && b[j][k]>x) || 
			(p[b[j][k]]>p[x] && b[j][k]<x)) ans--;
		for (int k=1;k<=b[j][0];k++)
			if (b[j][k]==x){
				for (int l=k+1;l<=b[j][0];l++)
					b[j][l-1]=b[j][l];
				b[j][0]--;
				break;
			}
	}
	return 0; 
} 
```

---

## 作者：chy2003 (赞：10)

树状数组套线段树。蒟蒻自己的理解方式（~~不知道能不能算是主席树~~），有错误或不足之处还请dalao指数。

~~既然被分在了主席树一栏，就往这个方面想~~

我们观察原先主席树的工作方式（样例1,5,3,4,2）：

```
Tree0 = NULL
Tree1 = 1
Tree2 = 1, 5
Tree3 = 1, 3, 5
Tree4 = 1, 3, 4, 5
Tree5 = 1, 2, 3, 4, 5
```

而实际上加入的时候我们仅仅只是多维护了增量。这样删除一个数的时候（比如$5$），我们只要知道前面比它大的有几个（_Tree2_-_Tree0_）和它后面比它小的有几个（_Tree5_-_Tree2_），就知道了删掉它所减少的逆序对。

实际上麻烦的是处理接下来的问题。我们为了在主席树中删掉$5$，就需要在_Tree2_~_Tree5_中都把$5$删掉。而这样的时间复杂度往往无法忍受。接下来考虑优化这个过程。

我们类比一下：

主席树就好比是维护了一个前缀和，两颗树相减就能求出一段区间的值。而这样维护前缀和，如果我们修改了某个值，就要连着后面的一起修改。而我们知道，树状数组可以让这个过程是$O(log_n)$的。

所以我们考虑下面这样的过程：

**Step0:**

```
Tree0 = Tree1 = Tree2 = Tree3 = Tree4 = Tree5 = NULL
```

**Step1(Add 1):**

```
Tree0 = NULL;
Tree1 = 1;
Tree2 = 1;
Tree3 = NULL;
Tree4 = 1;
Tree5 = NULL;
```

**Step2(Add 5):**

```
Tree0 = NULL;
Tree1 = 1;
Tree2 = 1, 5;
Tree3 = NULL;
Tree4 = 1, 5;
Tree5 = NULL;
```

**Step3(Add 3):**

```
Tree0 = NULL;
Tree1 = 1;
Tree2 = 1, 5;
Tree3 = 3;
Tree4 = 1, 3, 5;
Tree5 = NULL;
```

**Step4(Add 4):**

```
Tree0 = NULL;
Tree1 = 1；
Tree2 = 1, 5;
Tree3 = 3;
Tree4 = 1, 3, 4, 5;
Tree5 = NULL;
```

**Step5(Add 2):**

```
Tree0 = NULL;
Tree1 = 1;
Tree2 = 1, 5;
Tree3 = 3;
Tree4 = 1, 3, 4, 5;
Tree5 = 2;
```

然后，我们考虑第一次询问$5$的贡献：

我们访问_Tree1_中比$5$大的和_Tree5_、_Tree4_中比$5$小的减去_Tree2_中比$5$小的。

然后删除的时候，我们就删除_Tree2_、_Tree4_中的$5$。

这个过程是不是和树状数组一模一样！所以动态开点的树状数组套线段树就可以了（~~觉得不应该算是主席树~~）。时间复杂度$O(n\log^2n)$，空间复杂度$O(n\log^2n)$。

## 参考程序

```c++
#include <bits/stdc++.h>
#define LL long long
using namespace std;

const int Maxn = 100010;
int Sum[ Maxn * 300 ], LeftChild[ Maxn * 300 ], RightChild[ Maxn * 300 ];
int Root[ Maxn ], Used;
int n, m;
int A[ Maxn ], R[ Maxn ];
LL Ans;

LL TQuery( int Index, int L, int R, int l, int r ) {
    if( l <= L && R <= r ) return ( LL )Sum[ Index ];
    if( Index == 0 ) return 0LL;//优化一下
    if( Sum[ Index ] == 0 ) return 0LL;//再优化一下
    int Mid = L + R >> 1;
    LL Ans = 0;
    if( l <= Mid ) Ans += TQuery( LeftChild[ Index ], L, Mid, l, r );
    if( r > Mid ) Ans += TQuery( RightChild[ Index ], Mid + 1, R, l, r );
    return Ans;
}

LL Query( int Index, int Key ) {
    LL Ans = 0;
    for( ; Index; Index -= Index & -Index )
        Ans += TQuery( Root[ Index ], 1, n, 1, Key );
    return Ans;
}

int TAdd( int Index, int L, int R, int Key ) {
    int Root = Index;
    if( !Root ) Root = ++Used;
    ++Sum[ Root ];
    if( L == R ) return Root;
    int Mid = L + R >> 1;
    if( Key <= Mid ) LeftChild[ Root ] = TAdd( LeftChild[ Root ], L, Mid, Key );
    if( Key > Mid ) RightChild[ Root ] = TAdd( RightChild[ Root ], Mid + 1, R, Key );
    return Root;
}

void Add( int Index, int Key ) {
    for( ; Index <= n; Index += Index & -Index ) 
        Root[ Index ] = TAdd( Root[ Index ], 1, n, Key );
    return;
}

int TDelete( int Index, int L, int R, int Key ) {
    if( Index == 0 ) return Index;
    --Sum[ Index ];
    if( Sum[ Index ] == 0 ) return 0; //如果已经为0，不如干脆删掉
    if( L == R ) return Index;
    int Mid = L + R >> 1;
    if( Key <= Mid ) TDelete( LeftChild[ Index ], L, Mid, Key );
    if( Key > Mid ) TDelete( RightChild[ Index ], Mid + 1, R, Key );
    return Index;
}

void Delete( int Index, int Key ) {
    for( ; Index <= n; Index += Index & -Index ) 
        Root[ Index ] = TDelete( Root[ Index ], 1, n, Key );
    return;
}

int main() {
    scanf( "%d%d", &n, &m );
    for( int i = 1; i <= n; ++i ) {
        scanf( "%d", &A[ i ] );
        R[ A[ i ] ] = i;
        Ans += Query( i - 1, A[ i ] );
        Add( i, A[ i ] );
    }
    Ans = ( LL ) n * ( n - 1 ) / 2 - Ans;
    printf( "%lld\n", Ans );
    for( int i = 1; i < m; ++i ) {
        int x; scanf( "%d", &x );
        Ans -= Query( R[ x ], n ) + Query( n, x ) - 2 * Query( R[ x ], x ); 
        Delete( R[ x ], x );
        printf( "%lld\n", Ans );
    }
    return 0;
}
```





---

## 作者：Thinking (赞：8)

## 分块是个好算法

~~尤其对于我这种不会树套树的傻子~~

删除一个数时，不难发现它对于逆序对的贡献是**它前面比它大的数的个数+它后面比它小的数的个数**，于是用分块就非常容易了：

1. 算贡献，该数前面的块和后面的块二分，它所在的块暴力；
2. 把它删除，原数列打标记，块内删除后把后面的数往前移。

这样写的复杂度是$O(m\sqrt{n}logn)$的，相当危险，但是我们发现把块大小取成$\sqrt{nlogn}$的话，复杂度就降到了$O(m\sqrt{nlogn})$，不用卡常都可以轻松AC。

code：
```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long ll;
const int N=100050;
char rB[1<<21],*S,*T,wB[1<<21];
int wp=-1;
inline char gc(){return S==T&&(T=(S=rB)+fread(rB,1,1<<21,stdin),S==T)?EOF:*S++;}
inline void flush(){fwrite(wB,1,wp+1,stdout);wp=-1;}
inline void pc(char c){if(wp==(1<<21))flush();wB[++wp]=c;}
inline int rd(){
    char c=gc();
    while(c<48||c>57)c=gc();
    int x=c&15;
    for(c=gc();c>=48&&c<=57;c=gc())x=(x<<3)+(x<<1)+(c&15);
    return x;
}
short buf[25];
inline void wt(ll x){
    short l=-1;
    while(x>9){
        buf[++l]=x%10;
        x/=10;
    }
    pc(x|48);
    while(l>=0)pc(buf[l--]|48);
    pc('\n');
}
//快读/快写
int a[N],b[100][1300],c[N],t[N],n,x,sz[100],K,cnt,pos[N];
ll ans=0;
bool d[N];
void ms(int L,int R){  //归并排序求初始逆序对数
    if(L==R)return;
    int M=L+R>>1,i=L,j=M+1,k=L;
    ms(L,M);ms(M+1,R);
    while(i<=M&&j<=R)if(c[i]<=c[j])t[k++]=c[i++];
    else{
        ans+=M-i+1;
        t[k++]=c[j++];
    }
    while(i<=M)t[k++]=c[i++];
    while(j<=R)t[k++]=c[j++];
    for(i=L;i<=R;i++)c[i]=t[i];
}
inline void build(){
    int i,j;
    K=sqrt(n*log(n)/log(2));if(!K)K=1;cnt=n/K;  //1*log(1)=0，碰上毒瘤数据（这题没有）会RE
    for(i=1;i<=cnt;i++){
        for(j=1;j<=K;j++)b[i][j]=a[(i-1)*K+j];
        sort(b[i]+1,b[i]+K+1);
        sz[i]=K;
    }
    if(n%K){
    	cnt++;
        for(i=1;i<=n%K;i++)b[cnt][i]=a[(cnt-1)*K+i];
        sort(b[cnt]+1,b[cnt]+n%K+1);
        sz[cnt]=n%K;
    }
}
inline void inupper(int p,int x){  //块内二分更大值的个数
    int l=1,r=sz[p],m,s=sz[p]+1;
    while(l<=r){
    	m=l+r>>1;
    	if(b[p][m]>x){s=m;r=m-1;}
    	else l=m+1;
    }
    ans-=sz[p]-s+1;
}
inline void inlower(int p,int x){  //块内二分更小值的个数
    int l=1,r=sz[p],m,s=0;
    while(l<=r){
        m=l+r>>1;
        if(b[p][m]<x){s=m;l=m+1;}
        else r=m-1;
    }
    ans-=s;
}
inline int find(int p,int x){  //暴力搜
    int l=1,r=sz[p],m;
    while(l<r){
        m=l+r>>1;
        if(b[p][m]>=x)r=m;
        else l=m+1;
    }
    return l;
}
inline void work(){
    int p=(x+K-1)/K,i,t=find(p,a[x]);
    for(i=1;i<p;i++)inupper(i,a[x]);
    for(i=p+1;i<=cnt;i++)inlower(i,a[x]);
    for(i=(p-1)*K+1;i<x;i++)if(!d[i]&&a[i]>a[x])ans--;
    for(i=x+1;i<=p*K&&i<=n;i++)if(!d[i]&&a[i]<a[x])ans--;
    d[x]=1;  //删除标记
    for(i=t;i<sz[p];i++)b[p][i]=b[p][i+1];  //删除一个数后后面的数要前移
    sz[p]--;  //此块内元素减少
}
int main(){
    int m,i;
    n=rd();m=rd()-1;  //既然最后一个不用输出答案，那就不用处理了
    for(i=1;i<=n;i++)pos[a[i]=rd()]=i;  //题目要删除的是数，所以要记下位置
    build();
    memcpy(c,a,sizeof(c));
    ms(1,n);
    wt(ans);
    while(m--){
        x=pos[rd()];
        work();
        wt(ans);
    }
    flush();
    return 0;
}
```
~~然后我就一直学不会树套树~~

---

## 作者：H_D_NULL (赞：7)

### 首先说明，本做法效率并不优秀，~~贴这篇代码只是因为我只会写这个~~

------------

#### 首先分析（自黑）
本题题面言简意赅，故~~显然~~是数据结构。（毫无破绽的分析）

主席树等结构解决这类动态（可持久）问题的效率是很优秀的，所以推荐去写一写那些算法，受用面也挺广。（不是赶你们）


------------
#### 我的思路
我们不用思考题目背后的意思，刻意去套各种高级数据结构上去，我们直接分析题意，然后从暴力思路考虑优化。

暴力：对于每一个要删的数，暴力枚举出存在这个数的逆序对，即找出**此数左边小于自己的和右边大于自己的数的个数**。（一道省选题，拿30分不亏）

问题：由于每一次暴力枚举，白白浪费了很多时间。

思考：我们知道，线段树可以查找i左边和i右边的所有数，平衡树可以找出所有比i大（或小）的数。所以就结合他们，产生了可以AC的做法，**线段树套平衡树！**

时间复杂度为(NlogN+Mlog^2N)，的确不算最优秀。（但就是能AC，气不气？？）。


------------


##### 注：中国计算机领域的政策先行者邓小平同志说过，美代码丑代码，能AC就是好代码（大意相同）。所以在考场上即使想不出最优解法，也可以得部分分，甚至骗分AC，希望这种思想对大家有帮助。


------------


~~__大佬：__ ___Talk is cheap, show me the code___~~


```
#include<bits/stdc++.h>
using namespace std;
const int mn=100005;

int n,m,a[mn],b[mn],rt[mn];
int o[mn],cnt;
bool h[mn*100];

long long ans,Ans[mn];

struct dr{
	int son[2];
	int size;
	int fa;
	int v;
} t[mn*100];

inline int update(int x){
	t[x].size=t[t[x].son[1]].size+t[t[x].son[0]].size+1;
}

inline int lowbit(int x){
	return x&(-x);
}

inline void rot(int x){//将zig和zag写进一个函数
	int fa=t[x].fa;
	int gf=t[fa].fa;
	int s=t[fa].son[1]==x;
	t[gf].son[t[gf].son[1]==fa]=x;
	t[x].fa=gf;
	t[fa].son[s]=t[x].son[s^1];
	t[t[x].son[s^1]].fa=fa;
	t[fa].fa=x;
	t[x].son[s^1]=fa;
	update(fa);
	update(x);
}

inline void splay(int x){
	while(t[x].fa){
		int fa=t[x].fa;
		int gf=t[fa].fa;
		if(gf&&(t[gf].son[1]==fa)==(t[fa].son[1]==x)) rot(fa);
		rot(x);
	}
}

inline int insert(int root,int x){
	cnt++;
	t[cnt].v=x;
	t[cnt].son[1]=t[cnt].son[0]=t[cnt].fa=0;
	t[cnt].size=1;
	if(!root) return cnt;
	int y=root,fa;
	while(y){
		fa=y;
		if(x<=t[y].v) y=t[y].son[0];
		else y=t[y].son[1];
	}
	t[cnt].fa=fa;
	if(x<=t[fa].v) t[fa].son[0]=cnt;
	else t[fa].son[1]=cnt;
	splay(cnt);
	return cnt;
}

int find(int root,int x){
	if(!root) return 0;
	if(x>t[root].v) return t[t[root].son[0]].size+1+find(t[root].son[1],x);
	return find(t[root].son[0],x);
}

void add(int x,int v){
	while(x<=n){
		rt[x]=insert(rt[x],v);
		x+=lowbit(x);
	}
}

int get(int x,int v){
	if(!x) return 0;
	int ans=0;
	while(x){
		ans+=find(rt[x],v);
		x-=lowbit(x);
	}
	return ans;
}

int Sz(int x){
	if(x==0) return 0;
	int ans=0;
	while(x){
		ans+=t[rt[x]].size;
		x-=lowbit(x);
	}
	return ans;
}

int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i],o[a[i]]=i;
	for(int i=1;i<=m;i++) cin>>b[i],h[b[i]]=1;
    //o数组存对应位置,h数组判断是否处在删除序列中
	for(int i=1;i<=n;i++){
		if(!h[a[i]]){
			add(i,a[i]);
			ans+=get(n,a[i])-get(i,a[i]);
			ans+=Sz(i-1)-get(i-1,a[i]);
		}
	}
	for(int i=m;i;i--){//奇技淫巧:将删除改成添加,然后倒着输出答案
		add(o[b[i]],b[i]);
		ans+=get(n,b[i])-get(o[b[i]],b[i]);
		ans+=Sz(o[b[i]]-1)-get(o[b[i]]-1,b[i]);
		Ans[i]=ans; 
	}
	for(int i=1;i<=m;i++) printf("%lld\n",Ans[i]);
	return 0;
}
```


---

## 作者：feecle6418 (赞：6)

本方法用了两个树状数组，虽然稍显麻烦，但思路很清晰。

我们换一种询问的描述方式：求出对于每个时刻，有多少对逆序对 $(val_i,val_j)$ 被删除。显然，对于满足 $val_i>val_j,i<j$ 的一对 $(i,j)$ 而言，它被删除是在时刻 $\min(time_i,time_j)$ (其中 $time_c$ 表示 $c$ 被删除的时刻)。

考虑 $\mathrm{CDQ}$ 分治。下标显然已经有序，我们在分治过程中对 $time$ **从大到小**排序。若当前在前半段区间内的指针 $i$ 和后半段区间内的指针 $j$ 满足 $time_i>time_j$，则根据归并排序的思想，我们应该将 $i$ 后移一位。后移之前，我们在**专门考虑对右边区间的贡献的树状数组**中将 $val_i$ 加入，在**专门考虑对左边区间的贡献的树状数组**中查询**右边区间内**会和 $val_i$ 组成逆序对的数的个数并累加至对于 $\bold{time_i}$ 的答案中（注意不是 $time_j$！因为 $\bold{time_i}$ 此时显然已经被更新完毕了，而 $time_j$ 还未被更新）。当 $time_i<time_j$ 时同理。最后统计输出即可。

注意：要开 $\mathrm{long\ long}$！

代码如下：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,a[100005],del[100005],pos[100005],t1[100005],t2[100005];
int c1[100005],c2[100005];
long long ans[100005]; 
//ans[i]表示在i时刻恰好删除的有多少对逆序对
//time[i]<time[j] val[i]>val[j] pos[i]<pos[j] (i,j)就会对time[j]产生贡献
//time[i]>time[j] val[i]>val[j] pos[i]<pos[j] (i,j)就会对time[i]产生贡献
struct Thing{
	int time,pos,val;
}q[100005],tmp[100005];
void Update(int x,int k,int c[]){
	while(x<=n)c[x]+=k,x+=x&-x;
}
int GetAns(int x,int c[]){
	int ret=0;
	while(x)ret+=c[x],x-=x&-x;
	return ret;
}
void Clear(int x,int c[]){
	while(x<=n)c[x]=0,x+=x&-x;
}
void CDQ(int l,int r){
	if(l==r)return ;
	int mid=(l+r)/2;
	CDQ(l,mid);
	CDQ(mid+1,r);
	int i=l,j=mid+1,x=l,s0=0,s1=0;
	while(i<=mid&&j<=r){
		if(q[i].time>q[j].time){
			Update(q[i].val,1,c1);
			ans[q[i].time]+=GetAns(q[i].val-1,c2);
			t1[++s0]=q[i].val,tmp[x++]=q[i++];
		}
		else {
			Update(q[j].val,1,c2);
			ans[q[j].time]+=GetAns(n,c1)-GetAns(q[j].val,c1);
			t2[++s1]=q[j].val,tmp[x++]=q[j++];
		}
	}
	while(i<=mid){
		Update(q[i].val,1,c1);
		ans[q[i].time]+=GetAns(q[i].val-1,c2);
		t1[++s0]=q[i].val,tmp[x++]=q[i++];
	}
	while(j<=r){
		Update(q[j].val,1,c2);
		ans[q[j].time]+=GetAns(n,c1)-GetAns(q[j].val,c1);
		t2[++s1]=q[j].val,tmp[x++]=q[j++];
	}
	for(int i=1;i<=s0;i++)Clear(t1[i],c1);
	for(int i=1;i<=s1;i++)Clear(t2[i],c2);
	for(int i=l;i<=r;i++)q[i]=tmp[i];
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]),pos[a[i]]=i;
	for(int i=1,x;i<=m;i++){
		scanf("%d",&x);
		del[pos[x]]=i;
	}
	int mm=m;
	for(int i=1;i<=n;i++){
		if(!del[i])del[i]=++mm;
		q[i]=(Thing){del[i],i,a[i]};
		//cout<<del[i]<<' '<<i<<' '<<a[i]<<endl;
	}
	CDQ(1,n);
	long long S=0;
	for(int i=1;i<=n;i++)S+=ans[i];
	printf("%lld\n",S);
	for(int i=1;i<m;i++)printf("%lld\n",S-=ans[i]);
	return 0;
}
```

---

## 作者：Hope2075 (赞：6)

用线段树套平衡树+大力卡常，强行卡过去了

写篇题解纪念大力卡常的一下午

（虽然复杂度比分块小，但常数太大了，还是被分块暴踩）

我用的是FHQ Treap

我的做法：先求出初始逆序对数，每次删除一个点，统计减少的逆序对数

首先，对整个序列建树，也就是线段树上每个节点维护一段区间，使这段区间的序列有序，这个过程可以通过归并排序实现，同时也能把初始逆序对数求出来

具体做的时候，先递归处理左右，待区间有序后，对这段区间直接$O(n)$建树，这一步是$O(n \log n)$的

每次移除一个点时，减少的逆序对数就是前面比它大的数的个数，再加上后面比它小的数的个数

然后，就可以开始做了（~~直接做是不行的~~）

自然的想法是，每次在树套树上询问这个数在某段区间的排名，统计，随后删除

时间复杂度$O(n \log^2 n)$，理论上能过

但是，如果直接交的话，你会发现：

![](https://cdn.luogu.com.cn/upload/pic/57745.png)

（已吸氧）

首先，可以把一些操作尽量改成非递归，这样可以快不少（~~于是就80分了~~）

对于平衡树的删除操作：

最直接的做法就是这样，将平衡树分裂，丢弃这个数，再合并

```cpp
node *del(node *tree,int num){
    node *l,*m,*r;
    split_num(tree,num,l,r);
    split(r,1,m,r);
    return merge(l,r);
}
```

而实际上，可以用栈+循环实现，首先到达待删除节点，将这个节点的左右孩子合并后放到原来的位置，随后将这条链pushup一下

```cpp
namespace t2{//命名空间是因为很多操作都用到了栈
    node *st[N];int top;
    bool side[N];
    inline node *del(register node *tree,const int &num){
        top=0;
        while(tree->num!=num){
            st[top]=tree;
            if(tree->num<num){
                side[top++]=1;
                tree=tree->rcd;
            }else{
                side[top++]=0;
                tree=tree->lcd;
            }
        }
        register node *cur=merge(tree->lcd,tree->rcd);
        while(top--){
            if(side[top]==0){
                st[top]->lcd=cur;
                st[top]->pushup();
                cur=st[top];
            }else{
                st[top]->rcd=cur;
                st[top]->pushup();
                cur=st[top];
            }
        }
        return cur;
    }
}
```

对于合并操作：

当然是递归比较简单，但是会比较慢

```cpp
node *merge(node *l,node *r){
    if(!l)return r;
    if(!r)return l;
    if(l->rand>r->rand){
        l->rcd=merge(l->rcd,r);
        l->pushup();
        return l;
    }else{
        r->lcd=merge(l,r->lcd);
        r->pushup();
        return r;
    }
}
```
而用栈+循环会很复杂

具体操作就是：先向下，每步将作为根的节点入栈，让剩下的部分继续与另一半合并

随后向上，将子树连到对应节点上，并pushup

```cpp
namespace t1{
    node *st[N];int top;
    bool side[N];
    inline node *merge(register node *l,register node *r){
        if(!l)return r;
        if(!r)return l;
        top=0;
        while(l&&r){
            if(l->rand>r->rand){
                st[top]=l;
                side[top++]=1;
                l=l->rcd;
            }else{
                st[top]=r;
                side[top++]=0;
                r=r->lcd;
            }
        }
        node *ans;
        if(l)ans=l;
        else ans=r;
        while(top--){
            if(side[top]==0){
                st[top]->lcd=ans;
                ans=st[top];
                ans->pushup();
            }else{
                st[top]->rcd=ans;
                ans=st[top];
                ans->pushup();
            }
        }
        return ans;
    }
}
```

查询排名就很简单

```cpp
int qrank(node *tree,int num){
    int ans=0;
    while(tree){
        if(tree->num<num){
            ans+=gsz(tree->lcd)+1;
            tree=tree->rcd;
        }else{
            tree=tree->lcd;
        }
    }
    return ans;
}
```

还是不能过（80分）

继续优化

这种做法中，两次询问和之后的删除操作复杂度都是$O(n \log^2 n)$的，会非常慢

所以在这里优化一下

首先，设法将询问改为一次$O(n \log^2 n)$操作

直接询问肯定不可以，所以考虑别的办法

如果分别求出比这个数小的和在这个数前面的数的个数？

这个可以另外开两棵平衡树来维护，时间复杂度$O(n\log n)$

这样会发现，比它大且在它前面的数被统计了一次，比它小且在它后面的数被统计了一次

但是比它小且在它前面的数被统计了两次

对于这部分，就可以用树套树来做了，时间复杂度$O(n \log^2 n)$

然而还是不能过:(

继续优化

发现查询时，只需要查询一段前缀

所以也改成循环，同时可以捎带把点删除

```cpp
inline int qrank(int r,int num){
    register int ll=1,rr=n,id=1,mid;
    int ans=0;
    while(ll!=rr){
        seg[id]=del(seg[id],num);
        mid=((ll+rr)>>1);
        if(r<=mid){
            rr=mid;
            id=(id<<1);
        }else{
            ans+=qrank(seg[id<<1],num);
            ll=mid+1;
            id=((id<<1)|1);
        }
    }
    seg[id]=del(seg[id],num);
    return ans;
}
```

如果左半边完全在范围内，就把左半边的答案加上，继续处理右半边，否则就处理左半边

很可惜，还是不能过

似乎没办法了？

随便调整了一下rand的参数，发现速度变快了不少（80->90）

又看到一线希望

发现建树过程也是递归的，也试着改成循环

直接改会很麻烦，于是我换了一种方式：

首先，对于需要建树的区间，对每个数开一个节点

随后，每次将相邻两个点配对，合并

这样复杂度大概是$O(n)$的，但我不会证

```cpp
namespace t3{
	node *s1[N],*s2[N];
	node *build(int *list,int l,int r){
		node **pr=s1,**nx=s2,**tmp;
		for(int i=l;i<=r;i++){
			pr[i-l]=mem::get(list[i]);
		}
		int t=r-l+1;
		while(t>1){
			if(t&1){
				for(int i=0;i<(t>>1);i++){
					nx[i]=merge(pr[i<<1],pr[(i<<1)|1]);
				}
				nx[t>>1]=pr[t-1];
				t=(t>>1)+1;
			}else{
				for(int i=0;i<(t>>1);i++){
					nx[i]=merge(pr[i<<1],pr[(i<<1)|1]);
				}
				t=(t>>1);
			}
			tmp=pr;pr=nx;nx=tmp;
		}
		return pr[0];
	}
}
```

同时读优也要加上

经过多次玄学优化+氧化后，终于能通过了

然后发现，最后只剩归并排序是递归了

最慢的点930ms卡过

代价就是代码很难看懂了

最后上代码，仅供参考：

```cpp
// luogu-judger-enable-o2
//上面那一行注释很关键
//没了就会TLE
//huaji
#include<cstdio>
#define gsz(x) (x?x->size:0)
using namespace std;
const int N=100007;
inline int read(){
    int n=0;
    char c=getchar();
    while(c<'0'||c>'9')c=getchar();
    while(c>='0'&&c<='9'){
        n=n*10+c-'0';
        c=getchar();
    }
    return n;
}
char res[30];
inline void write(long long num){
    if(num==0){
        putchar('0');
        return;
    }
    int t=0;
    while(num){
        res[t++]=num%10+'0';
        num/=10;
    }
    while(t--)putchar(res[t]);
}
struct node{
    node *lcd,*rcd;
    int size;
    int num;
    int rand;
    inline void pushup(){
        size=gsz(lcd)+1+gsz(rcd);
    }
};
namespace mem{
    node mem[N*40];
    int top;
    int seed=256541;
    inline int rnd(){
        return seed=seed*65537;
    }
    inline node *get(int num){
        top++;
        mem[top].size=1;
        mem[top].num=num;
        mem[top].rand=rnd();
        return mem+top;
    }
};
namespace t1{
    node *st[N];int top;
    bool side[N];
    inline node *merge(register node *l,register node *r){
        if(!l)return r;
        if(!r)return l;
        top=0;
        while(l&&r){
            if(l->rand>r->rand){
                st[top]=l;
                side[top++]=1;
                l=l->rcd;
            }else{
                st[top]=r;
                side[top++]=0;
                r=r->lcd;
            }
        }
        node *ans;
        if(l)ans=l;
        else ans=r;
        while(top--){
            if(side[top]==0){
                st[top]->lcd=ans;
                ans=st[top];
                ans->pushup();
            }else{
                st[top]->rcd=ans;
                ans=st[top];
                ans->pushup();
            }
        }
        return ans;
    }
}
using t1::merge;
namespace t2{
    node *st[N];int top;
    bool side[N];
    inline node *del(register node *tree,const int &num){
        top=0;
        while(tree->num!=num){
            st[top]=tree;
            if(tree->num<num){
                side[top++]=1;
                tree=tree->rcd;
            }else{
                side[top++]=0;
                tree=tree->lcd;
            }
        }
        register node *cur=merge(tree->lcd,tree->rcd);
        while(top--){
            if(side[top]==0){
                st[top]->lcd=cur;
                st[top]->pushup();
                cur=st[top];
            }else{
                st[top]->rcd=cur;
                st[top]->pushup();
                cur=st[top];
            }
        }
        return cur;
    }
}
using t2::del;
int n,m;
inline int qrank(node *tree,const int & num){
    register int ans=0;
    while(tree){
        if(tree->num<num){
            ans+=gsz(tree->lcd)+1;
            tree=tree->rcd;
        }else{
            tree=tree->lcd;
        }
    }
    return ans;
}
node *seg[N*4];
int list[N];
int swp[N];
namespace t3{
	node *s1[N],*s2[N];
	node *build(int *list,int l,int r){
		node **pr=s1,**nx=s2,**tmp;
		for(int i=l;i<=r;i++){
			pr[i-l]=mem::get(list[i]);
		}
		int t=r-l+1;
		while(t>1){
			if(t&1){
				for(int i=0;i<(t>>1);i++){
					nx[i]=merge(pr[i<<1],pr[(i<<1)|1]);
				}
				nx[t>>1]=pr[t-1];
				t=(t>>1)+1;
			}else{
				for(int i=0;i<(t>>1);i++){
					nx[i]=merge(pr[i<<1],pr[(i<<1)|1]);
				}
				t=(t>>1);
			}
			tmp=pr;pr=nx;nx=tmp;
		}
		return pr[0];
	}
}
using t3::build;
long long msort(int l,int r,int id){
    if(l==r){
        seg[id]=mem::get(list[l]);
        return 0;
    }
    int mid=((l+r)>>1);
    long long ans;
    ans=msort(l,mid,id<<1)+msort(mid+1,r,(id<<1)|1);
    register int i=l,j=mid+1,k=l;
    while(i<=mid&&j<=r){
        if(list[i]<=list[j]){
            swp[k++]=list[i++];
        }else{
            ans+=mid-i+1;
            swp[k++]=list[j++];
        }
    }
    while(i<=mid)swp[k++]=list[i++];
    while(j<=r)swp[k++]=list[j++];
    for(i=l;i<=r;i++)list[i]=swp[i];
    seg[id]=build(list,l,r);
    return ans;
}
inline int qrank(int r,int num){
    register int ll=1,rr=n,id=1,mid;
    int ans=0;
    while(ll!=rr){
        seg[id]=del(seg[id],num);
        mid=((ll+rr)>>1);
        if(r<=mid){
            rr=mid;
            id=(id<<1);
        }else{
            ans+=qrank(seg[id<<1],num);
            ll=mid+1;
            id=((id<<1)|1);
        }
    }
    seg[id]=del(seg[id],num);
    return ans;
}
long long cnt;
int arc[N];
int num;
node *tr1,*tr2;
int main(){
    n=read();m=read();
    for(int i=1;i<=n;i++){
        list[i]=read();
        arc[list[i]]=i;
    }
    cnt=msort(1,n,1);
    tr1=build(list,1,n);
    tr2=build(list,1,n);
    while(m--){
        num=read();
        write(cnt);putchar('\n');
        int pl=arc[num];
        cnt-=qrank(tr1,num);
        cnt-=qrank(tr2,pl);
        cnt+=2*qrank(pl,num);
        tr1=del(tr1,num);
        tr2=del(tr2,pl);
    }
}
```

p.s：看一下[这个记录](https://www.luogu.org/recordnew/show/18654370)，并算一下TLE的那个点的用时

离AC就差4ms了[流泪]

---

## 作者：__stdcall (赞：5)

来一个CDQ分治版的吧

把删除转变为逐个添加，于是就变成了三维偏序问题（时间，位置，大小）

对于一个三元组(a,b,c)，有两组满足“逆序对”的条件

a2<a && b2<b && c2>c

a2<a && b2>b && c2<c

于是就要归并两次，具体细节请看代码

分块也可以做，而且更快，这里就不赘述了








```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>
#include <cmath>
#include <cstdlib>
using namespace std;
typedef long long ll;
const int MAXN = 100005;
int n, m, a[MAXN], b[MAXN];
namespace BIT {
    int arr[MAXN];
    inline int lowbit( int num ) { return num&(-num); }
    void add( int idx ) {
        while( idx <= n ) {
            arr[idx]++;
            idx += lowbit(idx);
        }
    }
    int _query( int idx ) {
        int ans = 0;
        while( idx ) {
            ans += arr[idx];
            idx -= lowbit(idx);
        }
        return ans;
    }
    int query( int l, int r ) {
        return _query(r) - _query(l-1);
    }
    void clear( int idx ) {
        while( idx <= n ) {
            if( arr[idx] ) arr[idx] = 0;
            else break;
            idx += lowbit(idx);
        }
    }
}
struct Query {
    int aid, idx, num;
    bool operator<( const Query &rhs ) const {
        return idx < rhs.idx;
    }
    bool operator>( const Query &rhs ) const {
        return idx > rhs.idx;
    }
}query1[MAXN],query2[MAXN];
void addq( int id, int aid, int idx, int num ) {
    query1[id] = query2[id] = (Query){aid,idx,num};
}
ll ans[MAXN]; int aidx = 0;
Query tmp[MAXN];
void cdq( int L, int R ) {
    if( R-L <= 1 ) return;
    int M = (L+R)>>1; cdq(L,M); cdq(M,R);
    int p = L, q = M, o = L;
    while( p < M && q < R ) {
        if( query1[p] < query1[q] ) {
            BIT::add( query1[p].num );
            tmp[o++] = query1[p++];
        } else {
            ans[query1[q].aid] += BIT::query( query1[q].num, n );
            tmp[o++] = query1[q++];
        }
    }
    while( p < M ) tmp[o++] = query1[p++];
    while( q < R ) {
        ans[query1[q].aid] += BIT::query( query1[q].num, n );
        tmp[o++] = query1[q++];
    }
    for( int i = L; i < R; ++i ) {
        BIT::clear( query1[i].num );
        query1[i] = tmp[i];
    }
    p = L; q = M; o = L;
    while( p < M && q < R ) {
        if( query2[p] > query2[q] ) {
            BIT::add( query2[p].num );
            tmp[o++] = query2[p++];
        } else {
            ans[query2[q].aid] += BIT::query( 1, query2[q].num );
            tmp[o++] = query2[q++];
        }
    }
    while( p < M ) tmp[o++] = query2[p++];
    while( q < R ) {
        ans[query2[q].aid] += BIT::query( 1, query2[q].num );
        tmp[o++] = query2[q++];
    }
    for( int i = L; i < R; ++i ) {
        BIT::clear( query2[i].num );
        query2[i] = tmp[i];
    }
}
int main() {
    scanf( "%d%d", &n, &m );
    for( int i = 0; i < n; ++i ) {
        scanf( "%d", a+i ); b[a[i]] = i;
    }
    for( int i = 0; i < m; ++i ) {
        int num; scanf( "%d", &num );
        addq( n-1-i, aidx++, b[num], num ); a[b[num]] = 0;
    }
    int qidx = 0;
    for( int i = 0; i < n; ++i ) if( a[i] )
        addq( qidx++, aidx++, i, a[i] );
    cdq(0,n);
    for( int i = n-2; i >= 0; --i ) ans[i] += ans[i+1];
    for( int i = 0; i < m; ++i ) printf( "%lld\n", ans[i] );
    return 0;
}

```

---

## 作者：SukiYuri (赞：4)

### 鲜花
虽然说这道题已经有一车题解了，仔细翻了下好像还没有这种。

---
## 分析

考虑根号重构，先来一个简单版本：

**在一个长度为 $n$ 的序列中删除一个数，求逆序对。**

这非常简单，对于第 $i$ 个数 $a_i$，我们求出 $ctb_i=\left(\sum\limits_{j=1}^{i-1} [a_j>a_i]\right)+\left(\sum\limits_{j=i+1}^{n} [a_j<a_i]\right)$，即 $a_i$ 对答案 $ans$ 的贡献，再用答案减去 $ctb_i$ 即可。

**那如果我们删除若干个数呢？**

假设依次删除了 $a_{p_1},a_{p_2},\cdots,a_{p_k}$ 这些数，答案就是 $ans- \left(\sum\limits_{i=1}^{k} ctb_{p_i}\right) +\left(\sum\limits_{i=1}^{k} [(a_{p_i}>a_{p_k}\land p_i <p_k)\lor(a_{p_i}>a_{p_k}\land p_i <p_k)]\right)$。

后面一个 $\sum$ 其实就是序列 $\{a_{p_i}\}_{i=1}^{k}$ 的逆序对个数。

其实难维护的也是后面一个 $\sum$，这等价于动态二维偏序，~~直接把它当三维偏序就好了~~。如果把每 $B$ 个修改分成一块，暴力做就可以得到 $O(mB)$ 的复杂度。

这启发我们利用根号重构的技巧，总时间复杂度为：$O\left(\dfrac{m}{B}\cdot n\log n+mB\right)$，取 $B=\sqrt{n\log n}$ 有最优复杂度 $O\left(m\sqrt{n\log n}\right)$。

## 代码

```cpp
#include "cstdio"
#include "iostream"
#include "algorithm"
#include "cmath"
#include "cstring"
using namespace std;
const int maxn=1e5+5,len=2000;
int ord[maxn],a[maxn],ctb[maxn],bit[maxn],del[maxn],n,m,cnt;
bool vis[maxn];
inline void add(int i,int v) {for(;i<=n;i+=i&-i) bit[i]+=v;}
inline int ask(int i) {int r=0; for(;i;i-=i&-i)r+=bit[i]; return r;}
inline void getans(int q) {
    long long ans=0;
    memset(ctb,0,sizeof(int)*(n+5));
    memset(bit,0,sizeof(int)*(n+5)); 
    for(int i=1,cnt=0;i<=n;++i) if(!vis[i]) {
        ctb[i]+=cnt-ask(a[i]); add(a[i],1); ++cnt;
        ans+=ctb[i];
    }
    memset(bit,0,sizeof(int)*(n+5));
    for(int i=n;i;--i) if(!vis[i]) {
        ctb[i]+=ask(a[i]); add(a[i],1);
    }
    for(int i=1;i<=q;++i) {
        cout<<ans<<'\n';
        ans-=ctb[ord[del[i]]]; vis[ord[del[i]]]=1;
        for(int j=1;j<i;++j) {
            if(ord[del[j]]<ord[del[i]]&&del[j]>del[i]) ++ans;
            if(ord[del[j]]>ord[del[i]]&&del[j]<del[i]) ++ans;
        }
    }
}
int main() {
    ios::sync_with_stdio(0);
    cin>>n>>m;
    for(int i=1;i<=n;++i) cin>>a[i],ord[a[i]]=i;
    for(int i=1;i<=m;++i) {
        cin>>del[++cnt];
        if(cnt==len) getans(cnt),cnt=0;
    }
    if(cnt) getans(cnt);
    cerr<<1.0*clock()/CLOCKS_PER_SEC;
    return 0;
}
```

---

## 作者：yizhiming (赞：4)

仔细翻阅了一下题解，发现没有纯分块做法，我就记录一篇吧，时间 $n\sqrt{n}$，空间线性。

[$Link$](https://www.luogu.com.cn/problem/P3157)

## 题目大意

给定一个长为 $n$ 的排列，$m$ 次删除操作，每次查询删除完后的逆序对数。

$1\leq n \leq 10^5,1\leq m\leq 50000$。

## 题目分析

开头就说了，要写分块，所以直接讲分块做法。

考虑将删除改插入，考虑插入会产生哪些贡献，因为保证插入位置不同，所以每次插入产生的贡献，就是左边比插入值大的数，右边比插入值小的数的个数。

所以可以将问题转换成查询一个区间大于或者小于 $k$ 的数的个数，然后由于一个很有用的性质，每个位置的权值构成了排列，可以将分块的空间优化成线性。

## 具体做法

先将值域和序列都分块。

设 $pre_{i,j}$ 表示前 $i$ 个序列块，权值在第 $j$ 个值域块的数的个数，相当于一个前缀和数组，这个怎么维护呢？每次插入的时候直接 $\sqrt{n}$ 枚举一遍所有块累加贡献即可，单点修改的分块一般都可以将修改操作改成 $\sqrt{n}$ 修改前缀和数组，从而让单次查询一个值域块降到 $O(1)$。

我们再设一个数组 $id_i$ 表示若 $a_x= i $，则 $id_i = x$，这个由于 $a$ 是排列，所以保证不重，这个性质就可以把普通分块查询零散值域块的空间复杂度优化掉。

具体的，我们考虑查询，对于零散块直接暴力，对于整块，我们再分两类讨论，先枚举值域块，利用前缀和可以维护出来整块区间内，权值在 $j$ 值域块的数的个数，而对于零散权值块，我们可以直接枚举对应的 $id_i$，看它所在的位置是否处于当前整块区间内，注意是整块区间，因为零散块的贡献已经被统计过了。

再具体的可以去看代码。

## Code

单个根号跑不过 cdq，因为常数差太多了。

其实可以做到在线，不过为了卡常我写的插入，把插入操作直接改删除，修改前缀和的时候减掉贡献而不是加上就好了，大概是在线最优的做法？

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <queue>
#define int long long
using namespace std;
int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N = 1e5+5;
const int SN = 400;
int del[N],bel[N],L[N],R[N],ans[N],val[N],id[N],res,a[N];
bool vis[N];
int n,m;
int pre[SN][SN];
int ask1(int l,int r,int val){
	int num = 0;
	for(int i=l;i<=r;i++){
		num+=(a[i]>val);
	}
	return num;
}
int ask2(int l,int r,int val){
	int num = 0;
	for(int i=l;i<=r;i++){
		num+=((a[i]<val)&&(a[i]!=0));
	}
	return num;
}
int qmax(int l,int r,int val){
	if(l>r){
		return 0;
	}
	int num = 0;
	if(bel[l]==bel[r]){
		num = ask1(l,r,val);
	}else{
		num+=ask1(l,R[bel[l]],val);
		num+=ask1(L[bel[r]],r,val);
		int lx = bel[l],rx = bel[r]-1;
		for(int i=bel[n];i>bel[val];i--){
			num+=pre[rx][i]-pre[lx][i];
		}
		for(int i=val+1;i<=R[bel[val]];i++){
			num+=((id[i]>=L[lx+1])&&(id[i]<=R[rx])&&(a[id[i]]));
		}
	}
	return num;
}
int qmin(int l,int r,int val){
	if(l>r){
		return 0;
	}
	int num = 0;
	if(bel[l]==bel[r]){
		num = ask2(l,r,val);
	}else{
		num+=ask2(l,R[bel[l]],val);
		num+=ask2(L[bel[r]],r,val);
		int lx = bel[l],rx = bel[r]-1;
		for(int i=1;i<bel[val];i++){
			num+=pre[rx][i]-pre[lx][i];
		}
		for(int i=L[bel[val]];i<val;i++){
			num+=((id[i]>=L[lx+1])&&(id[i]<=R[rx])&&(a[id[i]]));
		}
	}
	return num;
}
void ins(int id,int num){
	res+=qmax(1,id-1,num); 
	res+=qmin(id+1,n,num);
	vis[num] = 0;
	a[id] = num;
	for(int i=bel[id];i<=bel[n];i++){
		pre[i][bel[num]]++;
	}
}
signed main(){
	n = read();m = read();
	int siz = sqrt(n);
	for(int i=1;i<=n;i++){
		val[i] = read();
		id[val[i]] = i; 
		bel[i] = (i-1)/siz+1;
		if(!L[bel[i]]){
			L[bel[i]] = i;
		}
		R[bel[i]] = i;
	}
	for(int i=1;i<=m;i++){
		del[i] = read();
		vis[del[i]] = 1;
	}
	for(int i=1;i<=n;i++){
		if(!vis[val[i]]){
			ins(i,val[i]);
		}
	}
	for(int i=m;i>=1;i--){
		ins(id[del[i]],del[i]);
		ans[i] = res;
	}
	for(int i=1;i<=m;i++){
		cout<<ans[i]<<"\n";
	}
	return 0;
}
```
后记，不保证是个排列应该也能做，把原序列离散化特殊处理一下即可。

---

## 作者：AThousandSuns (赞：4)

这是我打的第一道带修主席树（树状数组套线段树）的题。在这里说一下怎么做。

---
先考虑普通的线段树求逆序对：

维护一个权值线段树。从前往后插入。

插入第 $i$ 个数前，先看当前线段树有几个大于 $a[i]$ 的数。（也就是前 $i-1$ 个数中大于第 $i$ 个数的个数）这个可以在权值线段树上二分。接下来把 $a[i]$ 插入到线段树中。

考虑删除怎么做：

很明显的思路就是删除第 $i$ 个数时，把答案减去前 $i-1$ 个数中大于 $a[i]$ 的个数，再减去后 $n-i$ 个数中小于 $a[i]$ 的个数。这个应该是静态主席树可以完成的。

但是会有一个小问题：如果逆序对 $(i,j)$ 中 $a[i]$ 和 $a[j]$ 都被删掉了，那么这个逆序对就会被减掉两次！

所以需要从主席树中删掉一个数，这样以后统计都不会统计到它，也就不会重复了。

从主席树删掉一个数？难道要对后面的版本暴力修改？不。实际上主席树的本质就是一个前缀和，要动态维护前缀和，优先用常数小的树状数组啦！

那么用树状数组套动态开点线段树就能 $O((n+m)\log^2n)$ 了。注意，内层没法用树状数组优化常数，因为树状数组不支持动态开点。

（其实动态开点线段树极限情况也会超过 128M，但是不会CDQ分治的做法啊……）

---
下面是代码。（人丑自带大常数，要开O2才能过，最大的点700+ms）
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=100010;
#define PB push_back
#define MP make_pair
#define lson o<<1,l,mid
#define rson o<<1|1,mid+1,r
#define FOR(i,a,b) for(int i=(a);i<=(b);i++)
#define ROF(i,a,b) for(int i=(a);i>=(b);i--)
#define MEM(x,v) memset(x,v,sizeof(x))
inline int read(){
	char ch=getchar();int x=0,f=0;
	while(ch<'0' || ch>'9') f|=ch=='-',ch=getchar();
	while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
	return f?-x:x;
}
int n,m,cnt,a[maxn],rt[maxn],id[maxn],ch[maxn*300][2],sum[maxn*300];
ll ans;
void update(int &x,int l,int r,int p,int v){	//插入
	if(!x) x=++cnt;sum[x]+=v;
	if(l==r) return;
	int mid=(l+r)>>1;
	if(mid>=p) update(ch[x][0],l,mid,p,v);
	else update(ch[x][1],mid+1,r,p,v);
}
int query_small(int x,int l,int r,int k){	//比k小的
	if(!x) return 0;
	if(r<k) return sum[x];	//整个区间在k左边，直接返回
	int mid=(l+r)>>1,ans=0;
	ans+=query_small(ch[x][0],l,mid,k);	//一定有交集
	if(mid<k) ans+=query_small(ch[x][1],mid+1,r,k);	//与左半边有并集
	return ans;
}
int query_big(int x,int l,int r,int k){	//比k大的
	if(!x) return 0;
	if(l>k) return sum[x];
	int mid=(l+r)>>1,ans=0;
	ans+=query_big(ch[x][1],mid+1,r,k);
	if(mid>=k) ans+=query_big(ch[x][0],l,mid,k);
	return ans;
}
void modify(int p,int v,int w){	//把第p个位置插入/删除v
	for(int i=p;i<=n;i+=i&-i) update(rt[i],1,n,v,w);
}
int query_small(int p,int v){	//前p个数中比v小的
	int ans=0;
	for(int i=p;i;i-=i&-i) ans+=query_small(rt[i],1,n,v);
	return ans;
}
int query_big(int p,int v){	//前p个数中比v大的
	int ans=0;
	for(int i=p;i;i-=i&-i) ans+=query_big(rt[i],1,n,v);
	return ans;
}
int main(){
	n=read();m=read();
	FOR(i,1,n) id[a[i]=read()]=i,ans+=query_big(i-1,a[i]),modify(i,a[i],1);	//算一开始的逆序对个数
	FOR(i,1,m){
		printf("%lld\n",ans);
		int x=read();
		ans-=query_big(id[x]-1,x)+query_small(n,x)-query_small(id[x]-1,x);	//减去前面大于他的，减去后面小于他的
		modify(id[x],x,-1);	//从主席树（？）中删掉
	}
}
```

---

## 作者：单曦增 (赞：4)

这么好的题，怎么能没有kdtree题解呢。

dalao们都是用的树套树/CDQ，本蒟蒻表示并不会，然而我们可以发现，对于第$i$位的数$a[i]$，我们可以把它表示成一个坐标$(i,a[i])$，那么删掉一个点后，减少的逆序对数量就是这个点左上方和右下方的点的数量，这个很明显可以用kdtree，如果你还不会kdtree的话，可以自行百度。

这样的复杂度是$O(n\sqrt{n})$。然而这样T掉了。

于是我加上了快读快输，加上一堆inline,register，然后把询问的递归变成广搜，然后终于卡过了。

还有记得删掉的是元素的值而不是元素的下标。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#include<cctype>
#define min(x,y) (x<y?x:y)
#define max(x,y) (x>y?x:y)
#define qmin(x,y) (x=min(x,y))
#define qmax(x,y) (x=max(x,y))
#define lch t[root].ch[0]
#define rch t[root].ch[1]
using namespace std;

typedef long long ll;
const int Maxn=110000;

int D,a[Maxn],b[Maxn],c[Maxn],n,m,XN,XM,YN,YM,x,s[Maxn];

struct point {
	int d[2];
	bool operator < (point a) const {
		return d[D]<a.d[D];
	}
	point(int x=0,int y=0) {
		d[0]=x;
		d[1]=y;
	}
}p[Maxn];

struct node {
	int d[2],s[2][2],ch[2],siz,bj;
	node(){}
	node(point x) {
		d[0]=s[0][0]=s[0][1]=x.d[0];
		d[1]=s[1][0]=s[1][1]=x.d[1];
		siz=bj=1;
	}
}t[Maxn];

int bt(int l,int r,int now) {
	if(l>r) return 0;
	D=now;
	int root=l+r>>1;
	nth_element(p+l,p+root,p+r+1);
	t[root]=node(p[root]);
	lch=bt(l,root-1,now^1);
	rch=bt(root+1,r,now^1);
	t[root].siz+=t[lch].siz+t[rch].siz;
	if(lch) {
		qmin(t[root].s[0][0],t[lch].s[0][0]);
		qmin(t[root].s[1][0],t[lch].s[1][0]);
		qmax(t[root].s[1][1],t[lch].s[1][1]);
		qmax(t[root].s[0][1],t[lch].s[0][1]);
	}
	if(rch) {
		qmin(t[root].s[0][0],t[rch].s[0][0]);
		qmin(t[root].s[1][0],t[rch].s[1][0]);
		qmax(t[root].s[1][1],t[rch].s[1][1]);
		qmax(t[root].s[0][1],t[rch].s[0][1]);
	}
	b[p[root].d[0]]=root;
	return root;
}

ll nxd(int l,int r) {
	if(r-l<10) {
		ll ans=0;
		for(int i=l;i<r;i++)
			for(int j=r;j>i;j--)
				if(a[j]<a[j-1]) swap(a[j],a[j-1]),ans++;
		return ans;
	}
	int mid=l+r>>1;
	ll ans=nxd(l,mid)+nxd(mid+1,r);
	int lc=l,rc=mid+1,temp=l;
	while(lc<=mid&&rc<=r)
		if(a[lc]<a[rc]) b[temp++]=a[lc++];
		else b[temp++]=a[rc++],ans+=mid-lc+1;
	while(lc<=mid) b[temp++]=a[lc++];
	while(rc<=r) b[temp++]=a[rc++];
	for(int i=l;i<=r;i++) a[i]=b[i];
	return ans;
}

void del(int root,int x) {
	t[root].siz--;
	if(root==x) {
		t[root].bj=0;
		return;
	}
	if(root>x) del(lch,x);
	else del(rch,x);
}

inline bool check(int root) {
	return t[root].s[0][0]>=XN&&t[root].s[0][1]<=XM&&t[root].s[1][0]>=YN&&t[root].s[1][1]<=YM;
}

inline bool check2(int root) {
	return t[root].s[0][0]>XM||t[root].s[0][1]<XN||t[root].s[1][0]>YM||t[root].s[1][1]<YN;
}

int query(int root) {
	register int ans=0,top=0;
	s[++top]=root;
	while(top) {
		register int root=s[top--];
		if(check(root)) {
			ans+=t[root].siz;
			continue;
		}
		if(t[root].d[0]<=XM&&t[root].d[0]>=XN&&t[root].d[1]<=YM&&t[root].d[1]>=YN) ans+=t[root].bj;
		if(lch&&!check2(lch)) s[++top]=lch;
		if(rch&&!check2(rch)) s[++top]=rch;
	}
	return ans;
}

int read() {
	int ans=0;
	char ch=getchar();
	while(!isdigit(ch)) ch=getchar();
	while(isdigit(ch)) ans=ans*10+ch-'0',ch=getchar();
	return ans;
}

void print(ll x) {
	if(x<10) putchar('0'+x);
	else print(x/10),putchar('0'+x%10);
}

int main() {
//	freopen("test.in","r",stdin);
//	freopen("out","w",stdout);
	n=read(),m=read();
	for(int i=1;i<=n;i++) {
		a[i]=read();c[a[i]]=i;
		p[i]=point(i,a[i]);
	}
	ll ans=nxd(1,n);
	int rot=bt(1,n,0);
	for(int i=1;i<=n;i++) a[i]=t[b[i]].d[1];
	while(m--) {
		print(ans);putchar('\n');
		x=read();x=c[x];
		del(rot,b[x]);
		XN=1;XM=x;YN=a[x];YM=n;
		ans-=query(rot);
		XN=x;XM=n;YN=1;YM=a[x];
		ans-=query(rot);
	}
	return 0;
}


```

---

## 作者：FREEH (赞：4)

### 【题目】
![题目](https://cdn.luogu.com.cn/upload/pic/30602.png)

### 【解题思路】
- 由于题目要求的是删除，那么就进行倒序，先删除的就相当于后加入，后删除的相当于先加入。不用删除的元素就是最先加入的。
- 先按照加入顺序排序，这个过程可以在插入时就完成。
- 然后发现就是一个逆序对问题，进行CDQ分治。
- 按照元素的位置进行归并排序。
- 由于插入一个元素，该元素可能和之前或之后的元素构成逆序对，因此要从前往后找比当前元素大的数量，和从后往前找比当前元素小的数量，这个过程可以用树状数组优化。
- 最后清空一下树状数组即可。
- 由于我们对数据进行了一些魔改，要恢复成题目要求的格式输出，只需要在输出前按照原来顺序做一个部分和就行了。

### 【参考程序】
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long LL;
#define int LL

struct QUERY{
	int pos,id,num,ans;
}q[400005],t[400005];
bool app[400005];
int n,m,sum;
int del[400005],p[400005];

int tree[400005];
#define lowbit(x) ((x)&(-(x)))
void add(int x,int y)
{
	for (;x<=n;x+=lowbit(x)) tree[x]+=y;
}
int query(int x)
{
	int ans=0;
	for (;x;x-=lowbit(x)) ans+=tree[x];
	return ans;
}
void CDQ(int l,int r)
{
	if (l>=r) return;
	int mid=(l+r)>>1;
	CDQ(l,mid);CDQ(mid+1,r);
	int ALL=0;
	for (int i=l,j=l,k=mid+1;i<=r;i++)
	{
		if ((j<=mid&&q[j].pos<q[k].pos)||k>r)
			t[i]=q[j++];
		else
			t[i]=q[k++];
	}
	for (int i=l;i<=r;i++)
		if ((q[i]=t[i]).id<=mid)
		{
			add(q[i].num,1);
			ALL++;
		}
		else
		{
			q[i].ans+=ALL-query(q[i].num);
		}
	for (int i=l;i<=r;i++)
		if (q[i].id<=mid)
			add(q[i].num,-1);
	for (int i=r;i>=l;i--)
		if (q[i].id<=mid)
		{
			add(q[i].num,1);
		}
		else
		{
			q[i].ans+=query(q[i].num);
		}
	for (int i=l;i<=r;i++)
		if (q[i].id<=mid)
			add(q[i].num,-1);
}
bool cmp(QUERY a,QUERY b)
{
	return a.id<b.id;
}
signed main()
{
	scanf("%lld%lld",&n,&m);
    for(int i=1;i<=n;i++)
    {
    	int t;
        scanf("%lld",&t);
		p[t]=i;
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%lld",&del[i]);
		app[del[i]]=1;
	}
    for(int i=1;i<=n;i++)
        if(!app[i])
        {
            q[++sum].num=i;
			q[sum].pos=p[q[sum].num];
			q[sum].id=sum;
		}
    for(int i=m;sum<=n;i--)
    {
        q[++sum].num=del[i];
		q[sum].pos=p[q[sum].num];
		q[sum].id=sum;
    }
	CDQ(1,n);
	sort(q+1,q+1+n,cmp);
	for (int i=1;i<=n;i++)
		q[i].ans+=q[i-1].ans;
	for (int i=n;i>n-m;i--)
		printf("%lld\n",q[i].ans);
	return 0;
}
```

---

## 作者：ysy20021208 (赞：3)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**思路：**首先我们对于这个问题可以转化为二维数点问题，我们将每一个数字的编号作为横坐标，数字本身作为纵坐标标记在平面直角坐标系里，这样我们就可以将每一个点所包含的逆序对数转化为数点问题。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们发现上面的有一个规律，对于第三个位置上的二，共参与了三个逆序对。分别为第一个数字，第二个数字和第四个数字。这三个数字对于第三个数字来说都有一个共同的性质，他们都在三号点的左上方和右下方，由于本题是$n$的全排列，且所有数字的编号都不能超过$n$，所以对于当前状态下的数列中的$i$号点来说他参与的逆序对总数，就是由$(0，A_i)$和$(i，n)$围成的矩形中的点数加上由$(i，0)$和$(n，A_i)$围成的矩形中的点数。这样我们就能统计出来每一个点当前参与的逆序对数，对于当前删点后的答案，就是上一个状态减去当前点所参与的逆序对数。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于删除操作来说，我们只需要进行赋值就可以了。开始的时候我们将所有的点都赋值成为1，删除的时候就是将当前的赋值成为0。这样矩形内数点就是矩形内统计权值和，这样我们就完成了问题的转化。显然转化成为的问题可以运用$KDtree$来完成，下面讲解一下$cdq$做法。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于对点赋值，我们可以转化为对点加值，及加上$\Delta$。我们定义两种操作，$oper=1$的操作中有三个值$x，y，z$，表示将位置为$(x，y)$的点的权值加上$z$。$oper=2$的操作中有四个值$x，y，z，id$，表示统计由$(0，0)$和$(x，y)$围成的矩形中的权值和，并将这个权值和乘上系数$z$加到编号为$id$的答案数组上。对于每一个操作我们都加上一个参数$ord$，表示这个操作的添加顺序。（注：对于每一个矩形的询问操作，我们都能转化为$oper=2$的加减，运用容斥，即可。）

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们将这些操作进行排序，第一关键字是$x$，第二关键字是$y$。然后就是$solve$。因为更改操作会影响到查询操作，所以$ord$小的点会影响到$ord$大的点，这样的话我们的分治区间就是操作的$ord$编号。我们将$ord$小的点放在左面，$ord$大的放在右面，并且我们不要更改在$solve$之前排序后的相对位置，这样我们的左右区间内依旧保证最开始的相对顺序。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在分划之后就可以递归了，我们先递归左区间，在递归完成之后我们就要处理左区间对于右区间的影响，影响主要在于左区间的修改和右区间的查询。因为我们的左右区间在划分之前是按照最开始的关键字进行的排序，并且最开始的排序方式我们可以用树状数组进行统计答案，但是后来划分的顺序不能，所以本题的步骤顺序有所改变，即先统计左区间对于右区间的影响，后进行左右两个区间的递归处理。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是代码：可以结合代码和上面的描述进行理解。

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
#define N 100010
int n,m,idx,place[N],tmp[N];long long ans[N];
struct Oper {int kind,x,y,z,ord,id;}oper[N<<3],tmpx[N<<3];
bool cmp(const Oper &a,const Oper &b)
{return (a.x==b.x&&a.y==b.y)?(a.ord<b.ord):((a.x==b.x)?(a.y<b.y):(a.x<b.x));}
void add(int x,int y) {while(x<=n) tmp[x]+=y,x+=x&-x;}
int find(int x) {int tmp1=0;while(x) tmp1+=tmp[x],x-=x&-x;return tmp1;}
void solve(int l,int r)
{
    if(l==r) return;
    int mid=(l+r)>>1,tl=l-1,tr=mid;
    for(int i=l;i<=r;i++)
    {
		if(oper[i].ord<=mid&&oper[i].kind==1) add(oper[i].y,oper[i].z);
		if(oper[i].ord>mid&&oper[i].kind==2) ans[oper[i].id]+=find(oper[i].y)*oper[i].z;
    }
    for(int i=l;i<=r;i++)
		if(oper[i].ord<=mid&&oper[i].kind==1) add(oper[i].y,-oper[i].z);
    for(int i=l;i<=r;i++)
    {
		if(oper[i].ord<=mid) tmpx[++tl]=oper[i];
		else tmpx[++tr]=oper[i];
    }
    for(int i=l;i<=r;i++) oper[i]=tmpx[i];
    solve(l,mid),solve(mid+1,r);
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1,a;i<=n;i++)
    {
		scanf("%d",&a),oper[++idx].kind=1,oper[idx].x=i;
		oper[idx].y=a,oper[idx].z=1,oper[idx].ord=idx,place[a]=i;
		add(a,1),ans[1]+=i-find(a);
    }
    for(int i=1;i<=n;i++) add(i,-1);
    for(int i=1,a;scanf("%d",&a),i<=m;i++)
    {
		oper[++idx].kind=2,oper[idx].x=place[a],oper[idx].y=n;
		oper[idx].z=-1,oper[idx].ord=idx,oper[idx].id=i+1;
		oper[++idx].kind=2,oper[idx].x=n,oper[idx].y=a;
		oper[idx].z=-1,oper[idx].ord=idx,oper[idx].id=i+1;
		oper[++idx].kind=2,oper[idx].x=place[a],oper[idx].y=a;
		oper[idx].z=2,oper[idx].ord=idx,oper[idx].id=i+1;
		oper[++idx].kind=1,oper[idx].x=place[a],oper[idx].y=a,oper[idx].z=-1,oper[idx].ord=idx;
    }sort(oper+1,oper+idx+1,cmp),solve(1,idx);
    for(int i=2;i<=m;i++) ans[i]+=ans[i-1];
    for(int i=1;i<=m;i++) printf("%lld\n",ans[i]);
}
```

---

## 作者：半仙胡小桃 (赞：3)

#前言

第一次做这道题目，用的是主席树套树状数组的方法，思想非常清晰明了，就是用数据结构进行暴力维护统计，然鹅主席树确实不好打，再套个树状数组，Debug就更困难了。

[主席树套树状数组讲解链接](http://blog.csdn.net/qq\_35914587/article/details/78953090)

今天学习了基本的CDQ思想及方法，忽然记起这道题目有CDQ的解法，于是做了做。

不得不说 CDQ真是又好码，跑的又快，然鹅推到过程却不像上一种解法那么好搞。

#思路分析

要转化成CDQ的模型，首先得有时间序，我们把删除的顺序看做时间序，然后把删除看做倒着插入，越早插入的时间序越小。

然后把每个位置上的数看做一维，把位置看做一维。

样例变成了

t   1 2 3 4 5（时间序）


x   3 5 4 1 2（大小序）


y   3 2 4 1 5（位置序）


我们设一个数为$(t_0,x_0,y_0)$

我们求解时，贡献是在它插入之前右边多少比它大的数，左边多少比它数

即 $1.t<t_0,x<x_0,y>=y_0  2.t<t_0,x>x_0,y<=y_0$

然后为了把不等号搞的方向一致，转化为

$1.t<t_0,x<x_0,y<=(n-y_0+1)  2.t<t_0,x<(n-x_0+1),y<=y_0$

这样就转化为三维偏序问题了，直接上CDQ统计答案即可。

#注意事项

由于求的是逆序对总和，很明显要开long long，可不要忘了。

输出上一次删除的答案，就是最后一个删除不用输出啦。

#题目链接

[Luogu](https://www.luogu.org/problemnew/show/P3157)

#Ac Code

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#define il inline
#define lowbit(x) x&(-x)
#define ll long long
using namespace std;
const int maxm=111000;
struct node{
    int x,y,z,id;
    ll ans;
};
node a[maxm],b[maxm];
int m,n,val[maxm],rk[maxm];
ll ans[maxm],sum[maxm];
il int read()
{
    int x=0,w=1;
    char ch=0;
    while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') {x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    return x*w;
}
il void ins(int x,int w){for(int i=x;i<=maxm;i+=lowbit(i)) sum[i]+=(ll)w;}
il ll ask(int x){ll ans=0;for(int i=x;i;i-=lowbit(i)) ans+=sum[i];return ans;}
il bool same(node x1,node x2){return (x1.x==x2.x)&&(x1.y==x2.y)&&(x1.z==x2.z);}
il bool comp(node x1,node x2){return (x1.x<x2.x)||(x1.x==x2.x&&(x1.y<x2.y||(x1.y==x2.y&&x1.z<x2.z)));}
void CDQ(int l,int r)
{
    if(l>=r) return;
    int mid=(l+r)>>1;
    CDQ(l,mid),CDQ(mid+1,r);
    for(int i=l,j=l,p=mid+1;i<=r;i++) 
    {
        if(j<=mid&&(p>r||a[j].y<=a[p].y)) b[i]=a[j++];
        else b[i]=a[p++];
    }//归并排序,在这段区间中把y排好.
    for(int i=l;i<=r;i++) 
    {
        a[i]=b[i];
        if(a[i].id<=mid) ins(a[i].z,1);//插入小的 
        else a[i].ans+=ask(a[i].z);//大的查询 
    }
    for(int i=l;i<=r;i++) 
     if(a[i].id<=mid) ins(a[i].z,-1);//消除影响 
}
int main()
{
    //freopen("inverse.in","r",stdin);
    //freopen("inverse.out","w",stdout);
    n=read(),m=read();
    for(int i=1;i<=n;i++) a[i].y=i,a[i].z=read();
    for(int i=1,w;i<=m;i++) w=read(),rk[w]=i; 
    int tot=m;
    for(int i=1;i<=n;i++) if(!rk[i]) rk[i]=++tot;
    for(int i=1;i<=n;i++) a[i].x=tot-rk[a[i].z]+1;
    sort(a+1,a+n+1,comp);
    for(int i=1;i<=n;i++) a[i].y=n-a[i].y+1,a[i].id=i;
    CDQ(1,n);
    for(int i=1;i<=n;i++) ans[a[i].x]+=a[i].ans;
    sort(a+1,a+n+1,comp);
    for(int i=1;i<=n;i++) a[i].y=n-a[i].y+1,a[i].z=n-a[i].z+1,a[i].ans=0,a[i].id=i;
    CDQ(1,n);
    for(int i=1;i<=n;i++) ans[a[i].x]+=a[i].ans;
    for(int i=1;i<=n;i++) ans[i]+=ans[i-1];
    for(int i=n;i>n-m;i--) printf("%lld\n",ans[i]);
    return 0; 
}
```
#洛谷用户福利

有一道非常相似的题目

[1393](https://www.luogu.org/problemnew/show/P1393)

连名字都一样。

但是这双倍经验可是不好得的。

1.这题目没有保证数据<=n（所以我们要离散化）

2.给出的是删除的数的位置，而不是数值。

3.先输出总的逆序对个数，然后输出每个删除后逆序对的个数。

Ac Code


```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#define il inline
#define lowbit(x) x&(-x)
#define ll long long
using namespace std;
const int maxm=111000;
struct node{
    int x,y,z,id;
    ll ans;
};
node a[maxm],b[maxm];
int m,n,val[maxm],rk[maxm];
ll ans[maxm],sum[maxm];
il int read()
{
    int x=0,w=1;
    char ch=0;
    while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') {x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    return x*w;
}
il void ins(int x,int w){for(int i=x;i<=maxm;i+=lowbit(i)) sum[i]+=(ll)w;}
il ll ask(int x){ll ans=0;for(int i=x;i;i-=lowbit(i)) ans+=sum[i];return ans;}
il bool same(node x1,node x2){return (x1.x==x2.x)&&(x1.y==x2.y)&&(x1.z==x2.z);}
il bool comp(node x1,node x2){return (x1.x<x2.x)||(x1.x==x2.x&&(x1.y<x2.y||(x1.y==x2.y&&x1.z<x2.z)));}
void CDQ(int l,int r)
{
    if(l>=r) return;
    int mid=(l+r)>>1;
    CDQ(l,mid),CDQ(mid+1,r);
    for(int i=l,j=l,p=mid+1;i<=r;i++) 
    {
        if(j<=mid&&(p>r||a[j].y<=a[p].y)) b[i]=a[j++];
        else b[i]=a[p++];
    }//归并排序,在这段区间中把y排好.
    for(int i=l;i<=r;i++) 
    {
        a[i]=b[i];
        if(a[i].id<=mid) ins(a[i].z,1);//插入小的 
        else a[i].ans+=ask(a[i].z);//大的查询 
    }
    for(int i=l;i<=r;i++) 
     if(a[i].id<=mid) ins(a[i].z,-1);//消除影响 
}
int main()
{
    n=read(),m=read();
    for(int i=1;i<=n;i++) a[i].y=i,a[i].z=read(),val[i]=a[i].z;
    sort(val+1,val+n+1);
    int t=unique(val+1,val+n+1)-val-1;
    for(int i=1;i<=n;i++) a[i].z=lower_bound(val+1,val+t+1,a[i].z)-val;
    for(int i=1,w;i<=m;i++) w=read(),rk[w]=i; 
    int tot=m;
    for(int i=1;i<=n;i++) if(!rk[i]) rk[i]=++tot;
    for(int i=1;i<=n;i++) a[i].x=tot-rk[i]+1;
    sort(a+1,a+n+1,comp);
    for(int i=1;i<=n;i++) a[i].y=n-a[i].y+1,a[i].id=i;
    CDQ(1,n);
    for(int i=1;i<=n;i++) ans[a[i].x]+=a[i].ans;
    sort(a+1,a+n+1,comp);
    for(int i=1;i<=n;i++) a[i].y=n-a[i].y+1,a[i].z=n-a[i].z+1,a[i].ans=0,a[i].id=i;
    CDQ(1,n);
    for(int i=1;i<=n;i++) ans[a[i].x]+=a[i].ans;
    for(int i=1;i<=n;i++) ans[i]+=ans[i-1];
    for(int i=n;i>=n-m;i--) printf("%lld ",ans[i]);
    return 0; 
}
```

---

## 作者：eee_hoho (赞：2)

蒟蒻不知道什么是值域分块，也不知道什么是块套树状数组，更不知道什么是树套树，于是用序列分块$+vector$水过了这道题

考虑删去一个点$x$对答案产生的影响，拿下面的数列来说

$$1,2……x……n-1,n$$

>对于区间$[1,x-1]$，$a_i>a_x$会产生逆序对

>对于区间$[x+1,n]$，$a_i<a_x$会产生逆序对

那么每次删点后统计一下$x$两侧满足条件的数就好了

我们对序列分块，同一个块里的用$vector$排好序，和$x$在不同块的二分查找更新答案，和$x$在同一个块的暴力枚举更新答案，每次删点的时候在$vector$里删除点就好了

复杂度大约是$O(Mlog(N)\sqrt{N})$，吸吸氧就过了

**Code**
``` cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <vector>
#define N 100000
#define rep(i,s,t) for (register int i=s;i<=t;i++)
#define drep(i,s,t) for (register int i=t;i>=s;i--)
#define il inline
using namespace std;
int n,m,a[N+5],data[N+5],bs,blo[N+5],L[N+5],R[N+5],na[N+5],d[N+5],id[N+5],cnt;
long long ans;
vector <int> p[N+5];
void merge_sort(int l,int r)
{
    if (r-l>0)
    {
        int it=l,mid=l+r>>1,p=l,q=mid+1;
        merge_sort(l,mid);
        merge_sort(mid+1,r);
        while (p<=mid||q<=r)
        {
            if (q>r||p<=mid&&data[p]<=data[q])
                na[it++]=data[p++];
            else
            {
                na[it++]=data[q++];
                ans+=(long long)mid-p+1;
            }
        }
        rep(i,l,r)
            data[i]=na[i];
    }
}
il void del(int x)
{
    d[x]=1;
    vector <int>::iterator it=lower_bound(p[blo[x]].begin(),p[blo[x]].end(),a[x]);
    p[blo[x]].erase(it);
}
il void calc(int x)
{
    rep(i,1,blo[x]-1)
        ans-=(long long)(p[i].end()-upper_bound(p[i].begin(),p[i].end(),a[x]));
    rep(i,L[blo[x]],x-1)
        if (a[i]>a[x]&&!d[i])
            ans--;
    rep(i,x+1,R[blo[x]])
        if (a[i]<a[x]&&!d[i])
            ans--;
    rep(i,blo[x]+1,blo[n])
        ans-=(long long)(lower_bound(p[i].begin(),p[i].end(),a[x])-p[i].begin());
}
il int read()
{
	int X(0),w(0);char ch(0);
	while (!isdigit(ch))w|=ch=='-',ch=getchar();
	while (isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
	return w?-X:X;
}
int main()
{
    n=read();
    m=read();
    bs=sqrt(n);
    rep(i,1,n)
    {
        a[i]=read();
        data[i]=a[i];
        id[a[i]]=++cnt;
        blo[i]=(i-1)/bs+1;
        if (!L[blo[i]])
            L[blo[i]]=i;
        R[blo[i]]=i;
        p[blo[i]].push_back(a[i]);
    }
    merge_sort(1,n);
    rep(i,1,blo[n])
        sort(p[i].begin(),p[i].end());
    int x;
    rep(i,1,m)
    {
        printf("%lld\n",ans);
        x=read();
        del(id[x]);
        calc(id[x]);
    }
    return 0;
}
```

---

## 作者：_ctz (赞：2)

蒟蒻刚开始学分块，刚从分块入门中出来，听机房一位数据结构大佬说这题用分块可以n sqrt(n)过，于是经历了漫长的（近一天）的思考，用了种神奇的二维树状数组+分块O(n sqrt(n))过了，好像题解里没有我这种写法来水一发

不扯了讲正题。
支持删除的逆序对，一个基本思路是先求出来一开始逆序对个数，每次删除将这个数的贡献从答案中减去。

### 怎么求一个数的贡献？
一个数的贡献分两部分：前面比它大的数的个数，后面比它小的数的个数，这些都能组成逆序对。

### 如何维护这个贡献？

~~暴力O(n)扫描~~

我们可以数列分块，每个块开一个n大小的数组f[n]，f[i]表示在这个块中小于等于i的数有几个，计算贡献时（假设这个数为i，在块p中，共有len个块)可以用类似于前缀和统计块 1 ~ p-1的f[n]-f[i]（i+1~n的数的数量），再统计块p+1~len的f[i-1]（1~i-1的数的数量），最后对块p内的暴力统计，三部分加起来就是这个数的贡献，单次操作时间为O(sqrt(n)),空间为O(n sqrt(n))。

但是问题来了

### 如何修改？

我们可以注意到，由于每删除一个数就会对这个f数组产生影响，所以必须考虑修改。

这个f数组与前缀和类似，那么前缀和支持修改？

**树状数组啊！**

把f数组改为树状数组，统计时用树状数组询问，顺带把每一个块执行add(i,-1)（相当于去掉这个数）

然后问题双来了，这样做单次时间复杂度为O(n sqrt(n) logn)，计算器一算达到了1e8，有点悬啊。试一下果然T了。

还是~~放弃吧~~继续优化。

观察一下查询贡献的过程：统计块 **1 ~ p-1**的f[n]-f[i]（i+1~n的数的数量），再统计块**p+1~len**的f[i-1]（1~i-1的数的数量），最后对块p内的暴力统计。

对块p暴力统计肯定没法优化了（即使优化了效果也微乎其微），重点是粗体标出的部分。

两段连续的区间？

前缀和？

那么再加工一下 f 数组：用f[i][j]表示前 i 个**块**内小于等于 j 的数的数量
这样O(sqrt(n)logn)的暴力统计被优化到了O(logn)。

然而问题叒来了~~咋这么多问题~~

还是老问题，删除数伴随着 f 数组的变化， f 数组不仅第二维要支持修改，第一维也需要修改。

又是支持修改的前缀和？

#### 还是树状数组啊！

于是思路来了：

开二维树状数组，第一维维护**块**的前缀和，第二位维护**数**的前缀和

块外的整块用二维树状数组O(log(sqrt(n)) log n)≈O(log^2 n)查询，块内暴力O(sqrt(n))扫描

再用树状数组改一下

时间复杂度：O(n (sqrt(n) + log^2(n))) ≈ O(n sqrt(n))
空间复杂度：O(n sqrt(n))

除了空间压着线（125MB）效率还是不错的：不开O2 1400ms，开O2 900ms

### 上代码
```cpp
#define mian main 
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>

#define maxn 100005
//下面是瞎define的
#define pn putchar('\n')
#define ps putchar(' ')
#define px(x) putchar('x')
#define pX(x) putchar(x)

using namespace std;

inline int read(){
    int x=0,y=0;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
    return y?-x:x;
}//快读
#define lowb(x) x&-x
int n,len;
int a[maxn],be[maxn],pos[maxn];
bool dis[maxn];
//解释一下毒瘤的变量名
//a : 原数列
//be : belong , 记录每个位置属于哪个块
//pos : position , 记录每个数的位置
//dis : disappear,记录这个位置是否被删除了,用于块内的暴力统计
struct Tree_Array{
//标准的翻译:tree树,array数组,合起来tree_array树状数组(大雾
//结构体内的就是第二维的树状数组,因为二维数组难看所以开进结构体里了
    int tree[maxn];
    inline void add(int x,int d){
        while(x<=n)tree[x]+=d,x+=lowb(x);
    }
    inline int ask(int x){
        int ans=0;
        while(x)ans+=tree[x],x-=lowb(x);
        return ans;
    }
}ta[320],init;
//ta:Tree_Array的缩写,就是那个二维的树状数组
//init:initialization,用于统计初始逆序对数量
//为什么我要用树状数组统计?正好写了个树状数组结构体那就用上呗(才不是我归并排序都打错了)
inline void ADD(int x,int y,int d){
//x为第一维,y为第二维,d为加的数值
    while(x<=len)ta[x].add(y,d),x+=lowb(x);
}//整个二维树状数组加
inline int ASK(int x,int y){
//同上的查询
    int ans=0;
    while(x)ans+=ta[x].ask(y),x-=lowb(x);
    return ans;
}
int mian(){
    n=read();
    int m=read(),sq=sqrt(n);
    long long ans=0;//一定要开long long
    len=n/sq+(bool)(n%sq);//诡异的块的个数,好像就我这么毒瘤的写分块吧...
    for(register int i=1;i<=n;++i)
    	a[i]=read(),pos[a[i]]=i;
    for(register int i=1;i<=len;++i){
        int l=sq*(i-1)+1,r=min(l+sq-1,n);
        for(register int j=l;j<=r;++j){
        	ans+=init.ask(n)-init.ask(a[j]);
            init.add(a[j],1);//前两个是统计初始逆序对的
            ADD(i,a[j],1);//将前i个块的前a[j]的值+1,初始化二维树状数组
            be[j]=i;//记录be数组
        }
    }
    while(m--){
        int k=read();
        printf("%lld\n",ans);
        if(be[pos[k]]>1)
        	ans-=ASK(be[pos[k]]-1,n)-ASK(be[pos[k]]-1,k);
        //前一部分的统计,翻译过来:块1~be[pos[k]]的小于等于n的数的个数-块1~be[pos[k]]的小于等于k的个数,即为块1~be[pos[k]]的大于k的个数
        if(be[pos[k]]<len)
        	ans-=ASK(len,k-1)-ASK(be[pos[k]],k-1);
        //同上,块be[pos[k]]+1~len的小于k的数的个数
        int r=min(be[pos[k]]*sq,n);
        for(register int i=sq*(be[pos[k]]-1)+1;i<pos[k];++i)
        	if(!dis[i]&&a[i]>k)--ans;
        for(register int i=pos[k]+1;i<=r;++i)
        	if(!dis[i]&&a[i]<k)--ans;
        //上面为块内暴力统计
        ADD(be[pos[k]],k,-1);
        //去掉这个数在二维树状数组中的值
        dis[pos[k]]=1;
    }
    //懒得写return 0了
}

```

（变量名毒瘤轻喷。蒟蒻第一次写题解，好像说的很啰嗦，不知道管理员大大给不给过。。。）
















---

## 作者：花淇淋 (赞：2)

~~此题可以十分简单粗暴地套用树状数组套主席树的模板。~~

或者：cdq分治。


此题中，原先给出一个数列，之后会删除一些数。但是，呃，删除操作好像有点儿麻烦。反正允许离线，那就当作是初始给出一些数，先把这些数加入序列，之后会再添加一些数。也就是全部**反过来算**。


可以把每次的答案分成两个部分：**原先存在的逆序对+加入这个数新产生的逆序对**，那么每次只要算出当前新产生的逆序对，最后算一遍前缀和即可。


加入这个数新产生的逆序对也可以分成两个部分：**位置靠前且值比它大的，位置靠后且比它小的**。那么总共有三种操作，(1)往序列的某个位置加入一个数，(2)查询比某个数位置靠前且值比它大的数量，(3)查询比某个数位置靠后且值比它小的数量。显然，根据给出的删除顺序，可以得出每个操作的先后顺序，即每个操作的时间。要在cdq分治之前，**要先按操作的时间从小到大排序**。


在cdq分治中，每次会合并左右两个序列。在合并的时候，如果要查询位置靠前且比它大的，**就要先执行位置靠前的操作，位置相同的操作，先执行加入操作，树状数组维护的是值**，也就是说cdq分治结束以后，所有操作将按位置从小到大顺序排好。这样不方便查询位置靠后且比它小的。


那么，考虑把所有的操作分成互不影响的两组操作，**第一组：所有的操作(1)和操作(2)。第二组：所有的操作(1)和操作(3)**。两组操作分别先按时间从小到大排序，第二组操作在cdq分治的时候，**先执行值小的操作，树状数组维护的是位置**。


最后把两组操作所得结果累计，就得到了每次答案的**加入这个数新产生的逆序对**这一部分。


~~代码建议自己完成，实在不行的话，下面那个代码凑合着看吧QAQ~~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define lowbit(x) (x&(-x))
inline int getint()//读入优化 
{
    char ch;
    int res=0;
    while(ch=getchar(),ch<'0'||ch>'9');
    res=ch-48;
    while(ch=getchar(),ch>='0'&&ch<='9')
    res=res*10+ch-48;
    return res;
}
const int e=3e5+5;
struct point
{
    int id,v,t,opt,k;
}a[e],t[e],b[e];//id是位置，v是数值。k其实没什么用，然而不知道为什么写进去了。a，b为两组操作
int n,m,real[e],c[e],cnt,num;
bool vis[e];
long long ans[e];//逆序对总数可能超过int范围
inline bool cmp(const point &a,const point &b)//排序 
{
    return a.t<b.t||(a.t==b.t&&a.opt<b.opt);//t是时间，opt=1为加入操作，opt=2为询问操作
}
inline void init(int x)//树状数组清零 
{
    while(x<=n)
    {
        c[x]=0;
        x+=lowbit(x);
    }
}
inline void add(int x,int d)//树状数组单点修改
{
    while(x<=n)
    {
        c[x]+=d;
        x+=lowbit(x);
    }
}
inline int query(int x)//树状数组前缀和查询
{
    int res=0;
    while(x)
    {
        res+=c[x];
        x-=lowbit(x);
    }
    return res;
}
inline void solve(int l,int r)//第一组分治 
{
    if(l==r)return;
    int mid=(l+r)/2,id1=l,id2,i;
    id2=mid+1;
    solve(l,mid);
    solve(mid+1,r);
    for(i=l;i<=r;i++)
    if(id2>r||id1<=mid&&a[id1].id<=a[id2].id)//先执行位置靠前的
    {
        t[i]=a[id1++];
        if(t[i].opt==1)
        add(t[i].v,1);
    }
    else
    {
        t[i]=a[id2++];
        if(t[i].opt==2)
        ans[t[i].k]+=(long long)query(n)-(long long)query(t[i].v);
        //查询值比它大的数量
    }
    for(i=l;i<=r;i++)
    {
        a[i]=t[i];
        init(a[i].v);
    }
}
inline void solve2(int l,int r)//第二组分治 
{
    if(l==r)return;
    int mid=(l+r)/2,id1=l,id2,i;
    id2=mid+1;
    solve2(l,mid);
    solve2(mid+1,r);
    for(i=l;i<=r;i++)
    if(id2>r||id1<=mid&&b[id1].v<=b[id2].v)//先执行值较小的
    {
        t[i]=b[id1++];
        if(t[i].opt==1)
        add(t[i].id,1);
    }
    else
    {
        t[i]=b[id2++];
        if(t[i].opt==2)
        ans[t[i].k]+=(long long)query(n)-(long long)query(t[i].id);
        //查询位置比它靠后的数量
    }
    for(i=l;i<=r;i++)
    {
        b[i]=t[i];
        init(b[i].id);
    }
}
int main()
{
    int i,x,y;
    n=getint();
    m=getint();
    for(i=1;i<=n;i++)
    {
        x=getint();
        real[x]=i;//x的位置为i
    }
    for(i=1;i<=m;i++)//创建操作 
    {
        x=getint();
        y=real[x];//y为x的位置
        vis[x]=true; 
        a[++cnt]=(point){y,x,n-i+1,1,0};
        a[++cnt]=(point){y,x,n-i+1,2,n-i+1};
        b[++num]=(point){y,x,n-i+1,1,0};
        b[++num]=(point){y,x,n-i+1,2,n-i+1};
    }
    int ti=0;
    for(i=1;i<=n;i++)//创建操作 
    if(!vis[i])
    {
        a[++cnt]=(point){real[i],i,++ti,1,0};
        a[++cnt]=(point){real[i],i,ti,2,ti};
        b[++num]=(point){real[i],i,ti,1,0};
        b[++num]=(point){real[i],i,ti,2,ti};
    }
    sort(a+1,a+cnt+1,cmp);//排序 
    sort(b+1,b+num+1,cmp);
    solve(1,cnt);
    solve2(1,num);
    for(i=2;i<=n;i++)//做一遍前缀和 
    ans[i]+=ans[i-1];
    for(i=n;i>=n-m+1;i--)
    printf("%lld\n",ans[i]);
    return 0;
}
```

---

## 作者：amazingOZR (赞：2)

每次删除一个值x时，逆序对减少的值为（在x前面比x大的数的个数）+（在x后面比x小的数的个数）

因此，首先我们求出该序列逆序对。然后每次操作时，先输出答案，然后查询上面那两种数的个数就可以了。当然朴素肯定过不了，考虑树状数组。如果我们能够很快求出区间[s-lowbit(s)+1,s]中比x小/大的数的个数即可。看到这里自然会想起名次树，不过由于只有删除操作，只需要静态BST，在每个节点上面打个size的标记即可。

所以，我们对每个节点i，以其为根建一颗平衡树，管理的区间是[i-(i&-i)+1,i]。每次查询时，只需要不断往下找，同时在需要的时候加上左孩子或者右孩子的size即可。删除时，只需要从根往下寻找相应节点，途中经过的所有节点size值都减一，同时找到相应节点后标记一下就可以了。单次删除操作涉及logn个区间，每个不超过logn（如果建树建得好），复杂度(logn)^2，建树时共建n次，每次如果建得好的话复杂度为区间长，可以证明区间长的和为nlogn，因此建树复杂度为nlogn。当然最多也就n(logn)^2啦。所以时间复杂度为O(n(logn)^2+m(logn)^2)，空间复杂度O(nlogn)。实测最大一个点500+ms。

小技巧：

（1）因为比较难求以i为左端点的区间的右端点位置，可以将（i的右边）转化为(n减去i及i的左边）。

（2）为了避免写Treap，我写了朴素BST。为了避免有序序列把树卡成链，我建树的方法是每次取中点为根，递归左右子区间。

代码：

```cpp
#include<cstdio>
typedef long long ll;
const int maxn=100005,nlogn=100000*18;
int a[maxn],lc[nlogn],rc[nlogn],v[nlogn],sz[nlogn],rt[maxn],p[maxn],t[maxn],n,m,ch,w,x,s;
bool d[nlogn];
ll ans;
void read(int&x)
{
    x=0,ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-'0',ch=getchar();
}
void insert(int&p,int val)
{
    if(!p){p=++w;v[p]=val;sz[p]=1;return;}
    if(val<=v[p])insert(lc[p],val);else insert(rc[p],val);
    sz[p]=sz[lc[p]]+sz[rc[p]]+1;
}
void build(int&rt,int l,int r)
{
    if(l>r)return;
    int m=(l+r)>>1;
    insert(rt,a[m]);
    build(rt,l,m-1);build(rt,m+1,r);
}
int ask1(int p,int val)
{
    int ans=0;
    while(p)
    {
        if(v[p]==val){ans+=sz[lc[p]];break;}
        if(v[p]<val)ans+=sz[lc[p]]+1-d[p],p=rc[p];
        else p=lc[p];
    }
    return ans;
}
int ask2(int p,int val)
{
    int ans=0;
    while(p)
    {
        if(v[p]==val){ans+=sz[rc[p]];break;}
        if(v[p]>val)ans+=sz[rc[p]]+1-d[p],p=lc[p];
        else p=rc[p];
    }
    return ans;
}
void del(int p,int val)
{
    while(p)
    {
        --sz[p];
        if(v[p]==val){d[p]=1;return;}
        if(v[p]<val)p=rc[p];else p=lc[p];
    }
}
void msort(int l,int r)
{
    if(l>=r)return;
    int m=(l+r)>>1;
    msort(l,m),msort(m+1,r);
    int pl=l,pr=m+1,k=l;
    while(pl<=m&&pr<=r)
        if(a[pl]<=a[pr])t[k++]=a[pl++];
        else ans+=m-pl+1,t[k++]=a[pr++];
    while(pl<=m)t[k++]=a[pl++];
    while(pr<=r)t[k++]=a[pr++];
    for(register int i=l;i<=r;++i)a[i]=t[i];
}
int main()
{
    read(n),read(m);
    for(register int i=1;i<=n;++i)read(a[i]);
    for(register int i=1;i<=n;++i)p[a[i]]=i;
    for(register int i=1;i<=n;++i)build(rt[i],i-(i&-i)+1,i);
    msort(1,n);
    while(m--)
    {
        read(x);printf("%lld\n",ans);
        for(s=p[x]-1;s;s-=s&-s)ans-=ask2(rt[s],x);
        for(s=n;s;s-=s&-s)ans-=ask1(rt[s],x);
        for(s=p[x];s;s-=s&-s)ans+=ask1(rt[s],x);
        for(s=p[x];s<=n;s+=s&-s)del(rt[s],x);
    }
    return 0;
}

```

---

## 作者：墨尔 (赞：1)

cdq分治+树状数组
考虑一个数的删除会对答案产生什么影响？
显然答案会减去在这个数左边比这个数大的个数和在这个数右边比这个数小的个数和，而这就是cdq的查询操作中要查询的东西。
而删除操作要怎么实现？因为树状数组是把权值当做下标，存储的值是个数，将之作为一个修改操作，把相应的权值对应的个数减去1即可（初始序列就是看成相应权值对应的个数加1 的修改操作）
最后不要忘了开long long
```cpp
#include<cstdio>
long long ans[50005],s,sum[100005];
int n,a[100005],m,pos[100005];
struct node{int x,y,id,cnt;}q[200005],p[200005],qq[200005];
int lowbit(int x){return x&(-x);}
int query(int x){int ans=0;for(;x>0;x-=lowbit(x))ans+=sum[x];return ans;}
void add(int x,int y){for(;x<=n;x+=lowbit(x))sum[x]+=y;} 
void cdq(int l,int r)
{
	//左边比它大的个数 
	if(l==r)return;int mid=l+r>>1,i,j,cnt=l-1;
	cdq(l,mid);cdq(mid+1,r);
	for(i=l,j=mid+1;i<=mid&&j<=r;)
	 if(q[i].x<q[j].x)
	 {
	 	if(!q[i].id)add(q[i].y,q[i].cnt);
	 	p[++cnt]=q[i++];
	 }else
	 {
	 	if(q[j].id)ans[q[j].id]+=query(n)-query(q[j].y);
	 	p[++cnt]=q[j++];
	 }
	while(j<=r)
	{if(q[j].id)ans[q[j].id]+=query(n)-query(q[j].y);p[++cnt]=q[j++];} 
	for(int k=l;k<i;k++)if(!q[k].id)add(q[k].y,-q[k].cnt);
	while(i<=mid)p[++cnt]=q[i++];cnt=l-1;
	for(int k=l;k<=r;k++)q[k]=p[k];
	//右边比它小的数 
	for(i=l,j=mid+1;i<=mid&&j<=r;)
	 if(qq[i].x>qq[j].x)
	 {
	 	if(!qq[i].id)add(qq[i].y,qq[i].cnt);
	 	p[++cnt]=qq[i++];
	 }else
	 {
	 	if(qq[j].id)ans[qq[j].id]+=query(qq[j].y-1);
	 	p[++cnt]=qq[j++];
	 }
	while(j<=r)
	{if(qq[j].id)ans[qq[j].id]+=query(qq[j].y-1);p[++cnt]=qq[j++];} 
	for(int k=l;k<i;k++)if(!qq[k].id)add(qq[k].y,-qq[k].cnt);
	while(i<=mid)p[++cnt]=qq[i++];
	for(int k=l;k<=r;k++)qq[k]=p[k];
}
void merge(int l,int r)//归并排序算初始逆序对数
{
	if(l==r)return;int mid=l+r>>1,i,j,cnt=l-1;
	merge(l,mid);merge(mid+1,r);
	for(i=l,j=mid+1;i<=mid&&j<=r;)
	 if(a[i]<a[j])q[++cnt].x=a[i++];
	 else{s+=mid-i+1;q[++cnt].x=a[j++];}
	while(i<=mid)q[++cnt].x=a[i++];
	while(j<=r)q[++cnt].x=a[j++];
	for(int k=l;k<=r;k++)a[k]=q[k].x;
}
int main()
{
	scanf("%d%d",&n,&m);int cnt=n;
	for(int i=1;i<=n;q[i].x=i,q[i].cnt=1,qq[i]=q[i],i++)
	 scanf("%d",&q[i].y),pos[q[i].y]=i,a[i]=q[i].y;
	for(int i=1,x;i<=m;i++)
	{
		scanf("%d",&x);++cnt;
		q[cnt]=qq[cnt]=(node){pos[x],x,i,0};cnt++;
		//查询操作
		q[cnt]=qq[cnt]=(node){pos[x],x,0,-1};
        //修改操作
	}
	cdq(1,cnt);merge(1,n);
	for(int i=1;i<=m;i++)printf("%lld\n",s),s-=ans[i];
}
```

---

## 作者：Angora (赞：1)

蒟蒻不会cdq分治...写的树状数套权值线段树,据说线段树套平衡树也可以卡过虽然听说很多巨佬被卡树上下不来...

如果数x被删掉了,那么他对答案的影响是在x前面比他大的数+在x后面比他小的数
具体来讲预处理出原数组的这两个关系,每次删掉一个数减掉相应的值就好,但是删掉的数之间会构成逆序对,这样就会导致多减了.于是再求一次这次删掉的数x和之前删掉的数组成的逆序对就好了

参考了巨佬hzwer的写法

查询两次,每次直接二分权值.

例如往前查询的时候,如果x<=mid 那么tmp加上右区间的数 往后也是一样的
``` c++
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
#define rint register 
#define rep(i,x,y) for(rint int i=x;i<=y;++i)
#define repd(i,x,y) for(rint int i=x;i>=y;--i)
#define lowbit(x) x&(-x)
#define ll long long
using namespace std;
const int N=5e4+7;
const int M=N*400;
ll tr[M],a1[N<<1],a2[N<<1],ans;
int ls[M],rs[M],root[N<<1],nm[N<<1],t[N<<1],pos[N<<1];
int L[30],R[30],llen,rlen,n,m,cnt;
template <typename T>inline void read(T &x){
	char c;x=0;int sign=1;
	do{c=getchar(); if(c=='-')sign=-1;}while(c<'0'||c>'9');
	do{x=x*10+c-'0'; c=getchar();}while(c>='0'&&c<='9');
	x*=sign;
}
inline void add(int &x){for(rint int i=x;i<=n;i+=lowbit(i))t[i]++;}
inline int query(int &x){int ans=0;for(rint int i=x;i;i-=lowbit(i))ans+=t[i];return ans;}
inline void update(int &o,int l,int r,int x){
	if(!o)o=++cnt;tr[o]++;
	if(l==r)return ;
	int mid=l+r>>1;
	if(x<=mid)update(ls[o],l,mid,x);
	else update(rs[o],mid+1,r,x);
}
inline ll queryl(int a,int b,int k){
	int l=1,r=n;ll tmp=0;a--;llen=rlen=0;
	for(rint int i=a;i;i-=lowbit(i))L[++llen]=root[i];
	for(rint int i=b;i;i-=lowbit(i))R[++rlen]=root[i];
	while(l<r){
		int mid=l+r>>1;
		if(k<=mid){
			rep(i,1,llen)tmp-=tr[rs[L[i]]],L[i]=ls[L[i]];
			rep(i,1,rlen)tmp+=tr[rs[R[i]]],R[i]=ls[R[i]];
			r=mid;
		}
		else {rep(i,1,llen)L[i]=rs[L[i]];rep(i,1,rlen)R[i]=rs[R[i]];l=mid+1;}
	}
	return tmp;
}
inline ll queryr(int a,int b,int k){
	int l=1,r=n;ll tmp=0;a--;llen=rlen=0;
	for(rint int i=a;i;i-=lowbit(i))L[++llen]=root[i];
	for(rint int i=b;i;i-=lowbit(i))R[++rlen]=root[i];
	while(l<r){
		int mid=l+r>>1;
		if(k>mid){
			rep(i,1,llen)tmp-=tr[ls[L[i]]],L[i]=rs[L[i]];
			rep(i,1,rlen)tmp+=tr[ls[R[i]]],R[i]=rs[R[i]];
			l=mid+1;
		}
		else {rep(i,1,llen)L[i]=ls[L[i]];rep(i,1,rlen)R[i]=ls[R[i]];r=mid;}
	}
	return tmp;
}
inline void init(){
	read(n);read(m);
	rep(i,1,n){
		read(nm[i]);pos[nm[i]]=i;add(nm[i]);
		a1[i]=i-query(nm[i]);
		ans+=a1[i];
	}
	memset(t,0,sizeof(t));
	repd(i,n,1){add(nm[i]);a2[i]=query(nm[i])-1;}
}
inline void solve(){
	while(m--){
		int x;read(x);x=pos[x];
		printf("%lld\n",ans);
		ans-=a1[x]+a2[x]-queryl(1,x-1,nm[x])-queryr(x+1,n,nm[x]);
		for(rint int i=x;i<=n;i+=lowbit(i))update(root[i],1,n,nm[x]);
	}
}
int main(){
	init();
	solve();
	return 0;
}
```

---

## 作者：我没有名称 (赞：1)

我知道这题有很多题解了 但是我看了很久也没看明白 自己调了半天才过

首先这道题我们要维护一个数列 支持查询一个数之前有多少比他大的和他之后有多少比他小的 以及删除一个数

如果没有删除 我们可以用主席树来维护 从每颗主席树的root[i]进去可以访问到区间为1-i的权值线段树。这相当于维护1-i的前缀和。类比序列 如果我们加上了删除操作 我们就需要用树状数组来维护了 树状数组中i维护了i-lowbit(i)到i的和。那么在这道题中 从root[i]进去就应该访问到区间为i-lowbit(i)到i的权值线段树 这样的话 删除和询问就可以2个log做出来了

另外这题空间很玄学 按照上面的算法 每个点存log遍 存一遍要log个点 空间复杂度是nlog^2n 就MLE了 但是刚才那么算明显多算了一些 实际上 数组开1000w就行了

~~~cpp
#include<iostream>
using namespace std;
int ls[10000010],rs[10000010],cnt[10000010],n,a[100010],q,root[100010],b[100010],shu[100010],num;
long long ans;
int lowbit(int x)
{
    return x&(-x);
} 
void add0(int x,int v)
{
     while(x<=n)
     {
         shu[x]+=v;
         x+=lowbit(x);
     }
}
long long sum0(int x)
{
    long long s0=0;
    while(x>0)
    {
        s0+=shu[x];
        x-=lowbit(x);
    }
    return s0;
}
int query0(int x,int y)
{
    return sum0(y)-sum0(x-1);
}
void update(int l,int r,int &now,int val)
{
     if(now==0) now=++num;
     cnt[now]++;
     if(l==r) return;
     int m=(l+r)/2;
     if(val<=m) update(l,m,ls[now],val);
     else update(m+1,r,rs[now],val);
}
int countda(int l,int r,int now,int v)
{
    //cout<<l<<" "<<r<<" "<<now<<" "<<v<<" "<<rs[now]<<" "<<cnt[rs[now]]<<endl; 
    if(now==0)return 0;
    if(l==r)
     if(v<l) return cnt[now];
     else return 0;
    int m=(l+r)/2;
    if(v>m) return countda(m+1,r,rs[now],v);
    return cnt[rs[now]]+countda(l,m,ls[now],v);
}
int queryda(int x,int y,int v)
{
    if(x>y) return 0;
    int tt=0;
    x--;
    while(y>0)  
    {
        tt+=countda(1,n,root[y],v);
        y-=lowbit(y);
    }
    while(x>0)
    {
        tt-=countda(1,n,root[x],v);
        x-=lowbit(x);
    }
    return tt;
}
int countxiao(int l,int r,int now,int v)
{
    if(now==0) return 0;
    //if(v==1) cout<<l<<" "<<r<<" "<<now<<" "<<v<<endl;
    if(l==r) 
     if(v>l) return cnt[now];
     else return 0;
    int m=(l+r)/2;
    if(v<=m) return countxiao(l,m,ls[now],v);
    return cnt[ls[now]]+countxiao(m+1,r,rs[now],v);
}
int queryxiao(int x,int y,int v)
{
    if(x>y) return 0;
    int tt=0;
    x--;
    while(y>0)  
    {
        tt+=countxiao(1,n,root[y],v);
        y-=lowbit(y);
    }
    while(x>0)
    {
        tt-=countxiao(1,n,root[x],v);
        x-=lowbit(x);
    }
    return tt;
}
void del(int l,int r,int now,int v)
{
     if(now==0) return;
     cnt[now]--;
     if(l==r) return;
     int m=(l+r)/2;
     if(v<=m) del(l,m,ls[now],v);
     else del(m+1,r,rs[now],v);
}
void shanchu(int x,int v)
{
     while(x<=n)
     {
         del(1,n,root[x],v);
         x+=lowbit(x);
     }
}                                      
int main()
{
    int i,t0,j;
    cin>>n>>q;
    for(i=1;i<=n;i++) 
    {
        cin>>a[i];
        ans+=query0(a[i]+1,n);//求初始逆序对
        add0(a[i],1);
        b[a[i]]=i;
        for(j=i-lowbit(i)+1;j<=i;j++) update(1,n,root[i],a[j]);//插入
    }
    for(i=1;i<=q;i++)
    {
        cin>>t0;
        cout<<ans<<endl;
        ans-=(long long)queryda(1,b[t0]-1,t0)+queryxiao(b[t0]+1,n,t0);//计算
        shanchu(b[t0],t0);//删除
    }
    system("pause");
    return 0;
}
        
        
    
~~~

---

## 作者：殇雪 (赞：1)

我们发现这道题可以用树状数组套权值线段树（主席树的一些优化）


[（不会点这里）](http://http://www.cnblogs.com/rrsb/p/7955717.html "（不会点这里）") 我感觉我这样写下去朴素的主席树要不会写了。


我们发现一个点对答案的贡献有两部份，在其之前比其大的，在其之后比他小的。


我们每次删除一个点，把其对答案的贡献减去就好了。


我们考虑一下这样所费的空间，我们知道删除时是按原路径遍历，不会加空间。我们只考虑加点的空间开销。我们每次加一个点，期望我们访问log n个线段树，每个线段树log n个点，那么就是O（nlog n^2）的空间复杂度。5W\*16\*16=1280W？事实证明是不到的，而且这里的权值树是满的，所以公用部分是很多的。所以我们不是每次都会开出logN^2个点。我们可以证明，当权值线段树满以后的空间复杂度为近似为nlog2 n\*log3 n （我们考虑树状数组的每个点的上限，既这个点所管辖的真实数组中的几个，展开取近似即可）

反正能开多大就开多大吧。

```cpp
    #include<bits/stdc++.h>
    #define N 8500007 
    #define M 100007
    #define Mid (l+r>>1)
    #define L(x) (x&-x)
    #define LL long long
    using namespace std;
    int siz[N],ls[N],rs[N],si,n,tot,ne[M],m,X,a[M],n2[M],n3[M],to1;
    LL ans;
    #define sight(c) ('0'<=c&&c<='9')
    inline void read(int &x){
        static char c;
        for (c=getchar();!sight(c);c=getchar());
        for (x=0;sight(c);c=getchar())x=x*10+c-48;
    }
    void write(LL x){if (x<10) {putchar('0'+x); return;} write(x/10); putchar('0'+x%10);}
    inline void writeln(LL x){ if (x<0) putchar('-'),x*=-1; write(x); putchar('\n'); }
    void ins(int l,int r,int no,int q,int dla){
        siz[no]+=dla; if (l==r) return;
        if (Mid>=q) {if (!ls[no]) ls[no]=++si;ins(l,Mid,ls[no],q,dla);}
        else {if (!rs[no]) rs[no]=++si;ins(Mid+1,r,rs[no],q,dla);}
    }
    void add(int x,int i,int dla){for (;x<=n;x+=L(x)) ins(1,n,x,i,dla);}
    int ask(int l,int r,int q){
        if (l==r) return 0;
        if (Mid<q)  {
            for (int i=1;i<=tot;i++) ne[i]=rs[ne[i]]; return ask(Mid+1,r,q);
        }
        int sum=0;
        for (int i=1;i<=tot;i++) sum+=siz[rs[ne[i]]],ne[i]=ls[ne[i]];
        return sum+ask(l,Mid,q);
    }
    int Ask(int l,int r,int q){
        if (l==r) return 0;
        if (q<=Mid) {
            for (int i=1;i<=tot;i++) n2[i]=ls[n2[i]];
            for (int i=1;i<=to1;i++) n3[i]=ls[n3[i]]; return Ask(l,Mid,q); 
        }
        LL sum=0;
        for (int i=1;i<=tot;i++) sum-=siz[ls[n2[i]]],n2[i]=rs[n2[i]];
        for (int i=1;i<=to1;i++) sum+=siz[ls[n3[i]]],n3[i]=rs[n3[i]];
        return sum+Ask(Mid+1,r,q);
    }
    int query(int r,int val){
        for (tot=0;r;r-=L(r)) ne[++tot]=r;
        return ask(1,n,val);
    }
    int Query(int r,int val){
        int y=n;
        for (tot=0;r;r-=L(r)) n2[++tot]=r;
        for (to1=0;y;y-=L(y)) n3[++to1]=y;
        return Ask(1,n,val);
    }
    int main () {
        freopen("inverse.in","r",stdin);
        freopen("inverse.out","w",stdout);
        read(n); read(m); si=n;
        for (int i=1;i<=n;i++) 
            read(X),add(i,X,1),a[X]=i;
        for (int i=1;i<=n;i++) 
          ans+=query(a[i],i); 
        while (m--) {
            writeln(ans);read(X);
            ans-=Query(a[X],X)+query(a[X],X);
            add(a[X],X,-1);
        }return 0;
}
```

---

## 作者：破壁人 (赞：1)

首先，静态求逆序对就用树状数组(还有其他方法但树状数组和后面的操作联系很大)

按照读入顺序修改树状数组(a[i]表示值比i小于等于的数的个数)

(由于题目中说这是1...n的一个排列，所以不必考虑重复数据)

对于输入数据x能和前面的数组成逆序对的个数就是sum(x-1)。

下面来考虑删除数据后怎么求逆序对：

删除一个数后逆序对减少的个数就是前面比他大的数的个数和后面比他小的数的个数的和。

这个可以预处理实现。

但是在这个过程中，当前删除的数与先前删除的数组成的逆序对也被计算在内了。

那么怎么解决这个问题呢？

我们只要计算一下当前删除的数与先前删除的数组成的逆序对个数再减一下就可以了。

我们发现要计算这个值，数据的位置和大小是关键所在。

还考虑用树状数组，但是纯的树状数组不能同时维护位置和大小两个关键字。

所以我们对每个树状数组的结点都建立一颗线段树来维护大小区间，树状数组维护位置。(反一下也可以操作)

然后我们发现这样的话，每个相邻的线段树之间最多有log2(n)个元素不同，其实就是主席树。

所以我们可以用树状数组套主席树解决问题。









```cpp
#include<iostream>
#include<cstring>
using namespace std;
long long ans;
int n,m,sz,v[100001],position[100001],a1[100001],a2[100001],c[100001];
int root[100001],ls[6000001],rs[6000001],presidenttree[6000001];
int sum(int x)
{
    int as=0;
    for(int i=x;i;i-=i&(-i)) as+=c[i];
    return as;
}
void put(int &o,int l,int r,int q)
{
    if(!o) o=++sz;
    presidenttree[o]++;
    if(l==r) return;
    int mid=(l+r)/2;
    if(q<=mid) put(ls[o],l,mid,q);else put(rs[o],mid+1,r,q);
}
int get(int o,int p,int q,int r,int s)
{
    if((p==r)&&(q==s)) return presidenttree[o];
    int mid=(p+q)/2;
    if(s<=mid) return get(ls[o],p,mid,r,s);else
    if(r>mid)return get(rs[o],mid+1,q,r,s);else
    return get(ls[o],p,mid,r,mid)+get(rs[o],mid+1,q,mid+1,s);
}
int find(int o,int p,int q,int r)
{
    if(q>r) return 0;
    int as=0;
    for(int i=p;i>0;i-=i&(-i)) as+=get(root[i],1,n,q,r);
    for(int i=o;i>0;i-=i&(-i)) as-=get(root[i],1,n,q,r);
    return as;
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>v[i];
        position[v[i]]=i;
        a1[i]=sum(n)-sum(v[i]);
        ans+=a1[i];
        for(int j=v[i];j<=n;j+=j&(-j)) c[j]++;
    }
    memset(c,0,sizeof(c));
    for(int i=n;i;i--)
    {
        a2[i]=sum(v[i]-1);
        for(int j=v[i];j<=n;j+=j&(-j)) c[j]++;
    }
    for(int i=1;i<=m;i++)
    {
        cout<<ans<<endl;
        int x;
        cin>>x;
        x=position[x];
        ans-=(a1[x]+a2[x]-find(0,x-1,v[x]+1,n)-find(x,n,1,v[x]-1));
        for(int j=x;j<=n;j+=j&(-j)) put(root[j],1,n,v[x]);
    }
    return 0;
}
```

---

## 作者：I_AM_HelloWord (赞：1)

把主席树的模板再稍加修改。

我们求一个静态的逆序对时，是枚举每一个数作为较小的数时，它前面有多少比它大的数，用树状数组维护，累加一下就好了。

那么这个动态的逆序对是每次删除一个数，那么我们考虑这个数对于总逆序对数产生的贡献，

即在当前序列中这个数前面有多少个数比它大，后面有多少个数比它小，然后把总逆序对减去这个数就行了。

但是这个统计还是一个动态的，我们暂且没有办法维护，所以我们从反面来考虑。

原始序列中这个数前面有多少个数比它大，这个很容易用树状数组直接计算。

在这次前面所有的删去的数，既在原始序列中在当前的数前面又比它大的个数，由于有两个因素限制结果，我们无法通过一个单一的树状数组解决，所以我们就用主席树来搞。我们用一个主席树套树状数组（带修改的主席树）来维护，每删掉一个数x，记录其在原序列中的位置为pos[x],我们在主席树的1..pos[x],pos[x]..n两个区间中，分别统计比x小的数个数，大的数的个数，然后把x删掉，在主席树的pos[x]...n区间中插入x，就行了。

题目有个小坑。因为n可以达到100000，所以刚开始的逆序对数会爆int，把统计结果的开longlong，但是10^10我觉得不应该爆int。。

参考代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#define REP(i,a,b) for (int i=(a);i<=(b);i++)
#define DREP(i,a,b) for (int i=(a);i>=(b);i--)
#define FOR(i,a,b) for (int i=(a);i<=(b);i+=i&(-i))
#define RFOR(i,a,b) for (int i=(a);i>=(b);i-=i&(-i))
using namespace std;
const int N=100100;
const int M=N*50;
struct Edge{
    int L,R,sum;
}T[M];
int n,m,T_cnt=1;
long long ans=0;
int use[N],bit[N],root[N],pre[N],suf[N],a[N],pos[N];
int read(){
    int x=0,f=1;char ch=getchar();
    while (ch<'0' || ch>'9'){if (ch=='-')f=-1;ch=getchar();}
    while ('0'<=ch && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
int sum(int x){
    int t=0;
    RFOR(i,x,1)t+=bit[i];
    return t;
}
void insert(int &now,int k,int l=1,int r=n){
    if (!now)now=T_cnt++;
    T[now].sum++;
    if (l==r)return;
    int mid=(l+r)>>1;
    if (k<=mid)insert(T[now].L,k,l,mid);
        else insert(T[now].R,k,mid+1,r);
}
int querypre(int x,int y,int k){
    int l=1,r=n,sum=0;--x;
    RFOR(i,x,1)use[i]=root[i];RFOR(i,y,1)use[i]=root[i];
    while (l<r){
        int mid=(l+r)>>1;
        if (k<=mid){
            r=mid;
            RFOR(i,x,1)use[i]=T[use[i]].L;RFOR(i,y,1)use[i]=T[use[i]].L;
        }else{
            RFOR(i,x,1)sum-=T[T[use[i]].L].sum;
            RFOR(i,y,1)sum+=T[T[use[i]].L].sum;
            l=mid+1;
            RFOR(i,x,1)use[i]=T[use[i]].R;RFOR(i,y,1)use[i]=T[use[i]].R;
        }
    }
    return sum;
}
int querysub(int x,int y,int k){
    int l=1,r=n,sum=0;--x;
    RFOR(i,x,1)use[i]=root[i];RFOR(i,y,1)use[i]=root[i];
    while (l<r){
        int mid=(l+r)>>1;
        if (k<=mid){
            RFOR(i,x,1)sum-=T[T[use[i]].R].sum;
            RFOR(i,y,1)sum+=T[T[use[i]].R].sum;
            r=mid;
            RFOR(i,x,1)use[i]=T[use[i]].L;RFOR(i,y,1)use[i]=T[use[i]].L;
        }else{
            l=mid+1;
            RFOR(i,x,1)use[i]=T[use[i]].R;RFOR(i,y,1)use[i]=T[use[i]].R;
        }
    }
    return sum;
}
int main(){
    n=read(),m=read();
    REP(i,1,n){
        a[i]=read(),pos[a[i]]=i;
        pre[i]=sum(n)-sum(a[i]);
        ans+=pre[i];
        FOR(j,a[i],n)bit[j]++;
    }
    memset(bit,0,sizeof(bit));
    DREP(i,n,1){
        suf[i]=sum(a[i]-1);
        FOR(j,a[i],n)bit[j]++;
    }
    REP(i,1,m){
        printf("%lld\n",ans);
        int x=read();x=pos[x];
        ans-=(pre[x]+suf[x]-querypre(x+1,n,a[x])-querysub(1,x-1,a[x]));
        FOR(j,x,n)insert(root[j],a[x]);        
    }
    return 0;
}
```

---

## 作者：wanglichao1121 (赞：1)

为了便于考虑，把删除反序变为增加

于是就变成关于权值和位置和时间的三维数点

cdq+树状数组

外面排序（就是时间序）变为动态问题

cdq的作用是把动态变回静态，但是少了一个维度

然后就是树状数组的处理范围了

code：

```cpp
#include <bits/stdc++.h>
#define mid (l+r>>1)
#define ll long long
using namespace std;
ll n,ret,m,tem;
ll tr[200001],a[200001],in[200001];
bool ok[200001];
struct qu
{
    ll num,pos,id,ans;
} q[200001],t[200001];
bool com(qu a,qu b)
{
    return a.id<b.id;
}
void add(ll x,ll y){ for(;x<=n;x+=x&-x) tr[x]+=y;}
ll que(ll x){ for(ret=0;x;x-=x&-x) ret+=tr[x];return ret;}
void cdq(ll l,ll r)
{
    if(l==r) return;
    cdq(l,mid);cdq(mid+1,r);
    for(ll i=l,j=l,k=mid+1;i<=r;i++)
        if((k>r) || (j<=mid && q[j].pos<q[k].pos)) t[i]=q[j++];
            else t[i]=q[k++];
    ll ALL=0;
    for(ll i=l;i<=r;i++)
        if((q[i]=t[i]).id>mid)
            q[i].ans+=ALL-que(q[i].num);
        else
            add(q[i].num,1),++ALL;
    for(ll i=l;i<=r;i++)
        if(q[i].id<=mid)
            add(q[i].num,-1);
    for(ll i=r;i>=l;i--)
        if(q[i].id>mid)
            q[i].ans+=que(q[i].num);
        else
            add(q[i].num,1);
    for(ll i=l;i<=r;i++)
        if(q[i].id<=mid)
            add(q[i].num,-1);
}
int main()
{
    scanf("%d%d",&n,&m);
    for(ll i=1;i<=n;i++)
        scanf("%d",&tem),a[tem]=i;
    for(ll i=1;i<=m;i++)
        scanf("%d",&in[i]),ok[in[i]]=1;
    tem=0;
    for(ll i=1;i<=n;i++)
        if(!ok[i])
            q[++tem].num=i,q[tem].pos=a[q[tem].num],q[tem].id=tem;
    for(ll i=m;tem<=n;i--)
        q[++tem].num=in[i],q[tem].pos=a[q[tem].num],q[tem].id=tem;
    cdq(1,n);
    sort(q+1,q+n+1,com);
    for(ll i=2;i<=n;i++)
        q[i].ans+=q[i-1].ans;
    for(ll i=n;i>n-m;i--)
        printf("%lld\n",q[i].ans);
    return 0;
}
```

---


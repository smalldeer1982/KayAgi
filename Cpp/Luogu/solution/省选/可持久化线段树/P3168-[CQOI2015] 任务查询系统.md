# [CQOI2015] 任务查询系统

## 题目描述

最近实验室正在为其管理的超级计算机编制一套任务管理系统，而你被安排完成其中的查询部分。  

超级计算机中的任务用三元组 $(s_i, e_i, p_i)$ 描述，$(s_i, e_i, p_i)$ 表示任务从第 $s_i$ 秒开始，在第 $e_i$ 秒后结束（第 $s_i$ 秒和 $e_i$ 秒任务也在运行），其优先级为 $p_i$。同一时间可能有多个任务同时执行，它们的优先级可能相同，也可能不同。  

调度系统会经常向查询系统询问，第 $x_i$ 秒正在运行的任务中，优先级最小的 $k_i$ 个任务（即将任务按照优先级从小到大排序后取前 $k_i$ 个）的优先级之和是多少。  

特别的，如果 $k_i$ 大于第 $x_i$ 秒正在运行的任务总数，则直接回答第 $x_i$ 秒正在运行的任务优先级之和。上述所有参数均为整数，时间的范围在 $[1, n]$ 之间。


## 说明/提示

【样例解释】

$k_1 = (1\times 1 + 3)\bmod 2 + 1 = 1$；

$k_2 = (1\times 2+3)\bmod 4 + 1 = 2$；

$k_3 = (2 \times 8+4)\bmod 3+1 = 3$。

【数据范围】
 
对于 $100\%$ 的数据，$1\le m,n,c_i \le 10 ^ 5$，$0 \le a _ i, b _ i \le 10 ^ 5$，$1\leq s_i\leq e_i\leq n$，$1\le p_i \le 10^7$，$x_i$ 为 $1$ 到 $n$ 的一个排列。


注：2024-12-28 加入一个 hack 数据，[帖子链接](https://www.luogu.com.cn/discuss/1025247)。

## 样例 #1

### 输入

```
4 3
1 2 6
2 3 3
1 3 2
3 3 4
3 1 3 2
1 1 3 4
2 2 4 3```

### 输出

```
2
8
11```

# 题解

## 作者：xudaxia (赞：41)

###  [CQOI2015]任务查询系统  
~~一开始受到`HNOI2015摘果子`的启发写了一发树套树，然后就T了~~    
>这题要求求覆盖一个点的前k小区间和。强制在线。  

但主席树的解法其实差不多，因为主席树有前缀和的思想，我们把每一个区间拆开，在$l$处加区间的权值，在$r+1$处减区间的权值，然后用主席树维护一个前缀和。    
我们就可以单点查询了。在主席树上二分就行了。  
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<vector>
using namespace std;
const int N=1e5+10;
int read(){
    int sum=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){sum=sum*10+ch-'0';ch=getchar();}
    return sum*f;
}
int n,m,num,tot;
int a[N],b[N],root[N<<6];
long long ans=1;
struct tree {
    long long sum; 
    int cnt,l,r;
}t[N<<6];
vector<int>be[N],ed[N];
void update(int &u,int l,int r,int pre,int pos,int v){
    u=++tot; t[u]=t[pre];
    t[u].cnt+=v, t[u].sum+=1ll*v*b[pos];
    if(l==r) return;
    int mid=(l+r)>>1;
    if(pos<=mid) update(t[u].l,l,mid,t[pre].l,pos,v);
    else update(t[u].r,mid+1,r,t[pre].r,pos,v);
}
long long query(int u,int l,int r,int k){
    int num=t[t[u].l].cnt;
    if(l==r) return t[u].sum/(1ll*t[u].cnt)*1ll*k;
    int mid=(l+r)>>1;
    if(k<=num) return query(t[u].l,l,mid,k);
    else return query(t[u].r,mid+1,r,k-num)+t[t[u].l].sum;
}
int main(){
    m=read(),n=read();
    for(int i=1;i<=m;i++) {
        int x=read(),y=read();
        a[i]=read(),b[i]=a[i];
        be[x].push_back(i), ed[y+1].push_back(i);
    }
    sort(b+1,b+1+m); int num=unique(b+1,b+1+m)-b-1;
    for(int i=1;i<=n;i++) {
        root[i]=root[i-1];
        for(int j=0;j<be[i].size();j++) {
            int p=lower_bound(b+1,b+1+num,a[be[i][j]])-b;
            update(root[i],1,num,root[i],p,1);
        }
        for(int j=0;j<ed[i].size();j++) {
            int p=lower_bound(b+1,b+1+num,a[ed[i][j]])-b;
            update(root[i],1,num,root[i],p,-1);
        }
    }
    for(int i=1;i<=n;i++) {
      	int x=read(),a=read(),b=read(),c=read(),k=(1ll*a*ans+b)%c+1;
        if(k>t[root[x]].cnt) ans=t[root[x]].sum;
        else ans=query(root[x],1,num,k);
        printf("%lld\n",ans);
    }
    return 0;
}
```

---

## 作者：Log_x (赞：24)

##**Solution** 差分数组 + 主席树

- 先介绍下差分数组的概念：令$b[1] = a[1], b[i] = a[i] - a[i - 1](2 \le i \le n)$，这样的数组$b$就是一个差分数组。

- 我们可以发现：

$\sum \limits_{j = 1}^i b[j] = b[1] + b[2] + ... + b[i]$

$= a[1] + a[2] - a[1] + ... + a[i - 1] + a[i] - a[i - 1] = a[i]$

- 那么通过前缀和就可来求单个位置的值，以此处理一些特殊的问题。例如本题中的修改，给区间$[l, r]$内的每个位置加上优先级$k$，那么我们只要令$b[l] += k, b[r + 1] -= k$，表示用前缀和求区间$[l, r]$内的元素时都会加上$k$，而区间$[r + 1, n]$的元素就会同时加上和减去$k$，也就是不变。

- 接下来，我们就可以用善于处理前缀和的主席树来求第$k$小优先级之和了。首先按位置存储下形如$b[l] += k, b[r + 1] -= k$的修改（由于同一位置上可能有多次修改，空间问题上应使用邻接表），其次对每个位置建权值线段树。对于同一位置的不同修改，我们可以用$spj$数组记录下最后一次修改完成后所建权值线段树的编号，直接在询问中使用即可。

##**Code**

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;
typedef long long ll;
const int Maxn = 0x3f3f3f3f;
const int N = 2e5 + 5, M = 5e6 + 5;
ll Ans = 1; int n, m, L, E, fx, rt[N << 1], spj[N];

struct Edge
{
    int to; Edge *nxt;
}a[N << 1], *T = a, *lst[N];

struct point
{
    int num, lc, rc; ll sum;
    #define l(x) tr[x].lc
    #define r(x) tr[x].rc
    #define c(x) tr[x].num
    #define s(x) tr[x].sum
}tr[M];
//根据题意 1 <= Pi <= 10000000
//按照权值线段树的定义空间显然是不够的
//但考虑一共只有2m次插入，每次只增加log2m个节点
//所以我们这么开是没有问题的  

template <class T> inline void CkMax(T &a, const T &b) {if (a < b) a = b;}

inline int get()
{
    char ch; bool f = false; int res = 0;
    while (((ch = getchar()) < '0' || ch > '9') && ch != '-');
    if (ch == '-') f = true;
     else res = ch - '0';
    while ((ch = getchar()) >='0' && ch <= '9')
        res = (res << 3) + (res << 1) + ch - '0';
    return f? ~res + 1 : res;
}

inline void put(ll x)
{
    if (x < 0)
      x = ~x + 1, putchar('-');
    if (x > 9) put(x / 10);
    putchar(x % 10 + 48);
}

inline void addEdge(const int &x, const int &y)
{
    T->nxt = lst[x]; T->to = y; lst[x] = T++;
}

inline int Abs(const int &x) {return x < 0 ? ~x + 1 : x;}

inline void Insert(const int &y, int &x, const int &vi, const int &l, const int &r)
{
    tr[x = ++E] = tr[y]; c(x) += (vi < 0 ? -1 : 1); s(x) += vi;
    if (l == r) return ;
    int mid = l + r >> 1;
    if (Abs(vi) <= mid) Insert(l(y), l(x), vi, l, mid);
     else Insert(r(y), r(x), vi, mid + 1, r);
}

inline ll Query(const int &x, const int &l, const int &r, const int &k)
{
    if (l == r) return k * l;
    // 可能会有相同的优先级，应根据 k 的大小而不是全部记入答案
    int mid = l + r >> 1;
    if (k <= c(l(x))) return Query(l(x), l, mid, k);
     else return Query(r(x), mid + 1, r, k - c(l(x))) + s(l(x)); 
}


int main()
{
      m = get(); n = get(); int x, a, b, c, k, w;
    for (int i = 1; i <= m; ++i)
    {
        a = get(); b = get(); c = get();
        addEdge(a, c); addEdge(b + 1, ~c + 1); CkMax(fx, c);
    }   
    for (int i = 1; i <= n; ++i)
    {
         for (Edge *e = lst[i]; e; e = e->nxt)
         L++, Insert(rt[L - 1], rt[L], e->to, 1, fx);
        spj[i] = L;    
    }
    for (int i = 1; i <= n; ++i)
    {
        x = get(); a = get(); b = get(); c = get(); 
        k =((ll)a * Ans + b) % c + 1; w = rt[spj[x]];
        put(Ans = (c(w) <= k) ? s(w) : Query(w, 1, fx, k)), putchar('\n');
        // 注意 k 可能会越界
    }
    return 0;
}

```

---

## 作者：ButterflyDew (赞：10)

[Dew~](https://www.cnblogs.com/ppprseter/p/9641182.html)

化简模型，给出$m$个三元组$(s,e,p)$

询问$(x,k)$为满足$s \le x \le e$的三元组的前$k$大$p$值之和，强制在线

一看是一个偏序类题目，我们可以多维数据结构暴力嵌套，这个题最多允许$log^2$,又有第$k$大询问，自然的想到主席树降维

使用树状树状套主席树求解

其中树状树状的区间代表**从大到小排序的**$E_i$

树状树状的每个区间放对应的一群线段树，我们先对区间按$S_i$从小到大排序，然后按这个顺序建主席树就行了

主席树的节点存离散（不离散似乎也过了）的$p_i$值，注意维护一下区间和

查询的时候，在每个树状数组对应的主席树上一起二分即可，注意重复的元素

**Code**
```
#include <cstdio>
#include <algorithm>
#include <vector>
#define ll long long
using namespace std;
const int N=1e5+10;
struct node
{
    int s,t,p;
    bool friend operator <(node n1,node n2){return n1.t>n2.t;}
}rask[N];
struct RT
{
    int s,now;
    RT(){}
    RT(int s,int now){this->s=s,this->now=now;}
    bool friend operator <(RT n1,RT n2){return n1.s<n2.s;}
}rt;
vector <RT> root[N];
int cnt[N*244],ch[N*244][2],tot,n,m,mxx;ll sum[N*244];
int max(int x,int y){return x>y?x:y;}
#define ls ch[now][0]
#define rs ch[now][1]
#define ols ch[las][0]
#define ors ch[las][1]
void update(int now)
{
    sum[now]=sum[ls]+sum[rs];
    cnt[now]=cnt[ls]+cnt[rs];
}
int build(int las,int l,int r,int pos)
{
    int now=++tot;
    if(l==r)
    {
        cnt[now]=cnt[las]+1;
        sum[now]=1ll*cnt[now]*l;
        return now;
    }
    int mid=l+r>>1;
    if(pos<=mid)
    {
        ls=build(ols,l,mid,pos);
        rs=ors;
    }
    else
    {
        ls=ols;
        rs=build(ors,mid+1,r,pos);
    }
    update(now);
    return now;
}
void init()
{
    scanf("%d%d",&m,&n);
    for(int i=1;i<=m;i++)
        scanf("%d%d%d",&rask[i].s,&rask[i].t,&rask[i].p),mxx=max(mxx,rask[i].p);
    sort(rask+1,rask+1+m);
    for(int i=1;i<=m;i++)
    {
        for(int j=i-(i&-i)+1;j<=i;j++)
        {
            rt=RT(rask[j].s,j);
            root[i].push_back(rt);
        }
        sort(root[i].begin(),root[i].end());
        for(int las=0,j=0;j<root[i].size();j++)
            las=root[i][j].now=build(las,1,mxx,rask[root[i][j].now].p);
    }
}
ll query(int x,int pos,int k)//时间，前pos可查，第k值
{
    int now[50],p=0;
    for(int i=pos;i;i-=i&-i)
    {
        RT t=RT(x,0);
        int j=upper_bound(root[i].begin(),root[i].end(),t)-root[i].begin()-1;
        now[++p]=root[i][j].now;
    }
    int l=1,r=mxx;ll ans=0;
    while(l<r)
    {
        int mid=l+r>>1,s=0;
        for(int i=1;i<=p;i++) s+=cnt[ch[now[i]][0]];
        if(s>=k)
        {
            for(int i=1;i<=p;i++) now[i]=ch[now[i]][0];
            r=mid;
        }
        else
        {
            for(int i=1;i<=p;i++) ans+=sum[ch[now[i]][0]],now[i]=ch[now[i]][1];
            l=mid+1,k-=s;
        }
    }
    int cnt0=0;
    for(int i=1;i<=p;i++) cnt0+=cnt[now[i]];
    ans+=1ll*l*min(cnt0,k);
    return ans;
}
void work()
{
    ll pre=1;
    for(int pos,x,a,b,c,k,i=1;i<=n;i++)
    {
        scanf("%d%d%d%d",&x,&a,&b,&c);
        k=(a*(int)(pre%(1ll*c))+b)%c+1;
        node t={0,x,0};
        pos=upper_bound(rask+1,rask+1+m,t)-rask-1;
        printf("%lld\n",pre=query(x,pos,k));
    }
}
int main()
{
    init(),work();
    return 0;
}

```

--------------
然而，我们注意到这个问题有这样一个暴力

对操作，我们可以把每个对应位置上都加上这个优先级，并用权值线段树维护

然后查询时，直接进入对应位置的权值线段树查询即可

而事实上，我们发现这是对每个位置有一个区间加，我们可以采用差分数组的思想

把三元组$(s,e,p)$的$s$位置的$p$值$+1$，把$e+1$位置$p$值$-1$（这里$p$值在对于位置的权值线段树上）

然后我们查询的时候，就求这些权值线段树的前缀和就可以了

这不就是主席树干的事情吗

于是乎问题就可以直接用主席树做了

**Code:**
```
#include <cstdio>
#include <algorithm>
#define ll long long
using namespace std;
const int N=1e5+10;
struct node{int s,e,p;}rask[N];
int a[N];
int cnt[N*100],ch[N*100][2],root[N],tot,n,m,num;ll sum[N*100];
#define ls ch[now][0]
#define rs ch[now][1]
void updata(int now)
{
    sum[now]=sum[ls]+sum[rs];
    cnt[now]=cnt[ls]+cnt[rs];
}
void build(int &now,int l,int r,int pos,int del)
{
    if(!now) now=++tot;
    if(l==r)
    {
        cnt[now]+=del;
        sum[now]=1ll*cnt[now]*a[l];
        return;
    }
    int mid=l+r>>1;
    if(pos<=mid)
        build(ls,l,mid,pos,del);
    else
        build(rs,mid+1,r,pos,del);
    updata(now);
}
int rebuild(int x,int y)
{
    if(!x||!y) return x+y;
    int now=++tot;
    sum[now]=sum[x]+sum[y];
    cnt[now]=cnt[x]+cnt[y];
    ls=rebuild(ch[x][0],ch[y][0]);
    rs=rebuild(ch[x][1],ch[y][1]);
    return now;
}
void init()
{
    scanf("%d%d",&m,&n);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&rask[i].s,&rask[i].e,&rask[i].p);
        a[i]=rask[i].p;
    }
    sort(a+1,a+1+m);
    ++n;
    num=unique(a+1,a+1+m)-a-1;
    for(int i=1;i<=m;i++)
    {
        rask[i].p=lower_bound(a+1,a+1+num,rask[i].p)-a;
        build(root[rask[i].s],1,num,rask[i].p,1);
        build(root[rask[i].e+1],1,num,rask[i].p,-1);
    }
    for(int i=1;i<=n;i++)
        root[i]=rebuild(root[i-1],root[i]);
}
ll query(int now,int l,int r,int k)
{
    if(l==r)
        return 1ll*a[l]*min(k,cnt[now]);
    int mid=l+r>>1;
    if(cnt[ls]>=k) return query(ls,l,mid,k);
    else return sum[ls]+query(rs,mid+1,r,k-cnt[ls]);
}
void work()
{
    ll pre=1;
    for(int x,a,b,c,k,i=1;i<n;i++)
    {
        scanf("%d%d%d%d",&x,&a,&b,&c);
        k=(a*(int)(pre%(1ll*c))+b)%c+1;
        printf("%lld\n",pre=query(root[x],1,num,k));
    }
}
int main()
{
    init(),work();
    return 0;
}

```

---

## 作者：ModestStarlight (赞：10)

#### 可持久化Treap解法

看到大家都是用主席树（可持久化线段树）做的，我在心中为悲惨的可持久化Treap默哀

为了帮助可持久化Treap走出阴影，我决定写一篇可持久化Treap的题解


可持久化Treap和主席树可持久化的方式都一样，通过公用节点节省时间和空间。

我们在非旋转Treap的基础上把Split和Merge修改一下，不再直接在原树上操作，需要更改的点，我们都复制一份新的，然后在新的节点上进行修改即可~~（说得这么轻巧但还是很难……）~~。


知道了这些之后，我们看看如何做这一道题。

首先，任务开始和任务结束可以看做是元素的插入和删除，我们将所有的时间节点排序，按时间依次插入Treap中（不需要离散化，题目有限制的……）。

接下来就是询问了，我们找到询问的时间的那一棵Treap，然后在里面查找就好了。为了方便查找，我们需要维护一下sum（表示整棵子树的val值和）和size（表示整棵子树的节点数），然后就按一般BST的查找方法就好了~


然后那个什么，我的Split是按排名断开两棵树的，所以写法可能与经典的非旋转Treap不太一样，自行脑补


警告：我的写法跑的极慢，可以自行优化……

Code：

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<climits>
#include<algorithm>
using namespace std;
#define N 100005
#define lim 100
#define ll long long
int root[N];
class Treap
{
    public:
    void Insert(int &r,int x)
    {
        int A,B,C,p=Rank(r,x);
        Split(r,A,C,p);
        B=New(x);
        Merge(r,A,B);
        Merge(r,r,C);
    }
    void Delete(int &r,int x)
    {
        int A,B,p=Rank(r,x)+1;
        Split(r,A,B,p);
        Erase(A);
        Merge(r,A,B);
    }
    int Rank(int r,int a)
    {
        if(!r)return 0;
        if(val[r]<a)return siz[ch[r][0]]+1+Rank(ch[r][1],a);
        return Rank(ch[r][0],a);
    }
    int Query(int r,int x)
    {
        if(!r)return 0;
        if(siz[ch[r][0]]+1<=x)
            return sum[ch[r][0]]+val[r]+Query(ch[r][1],x-siz[ch[r][0]]-1);
        return Query(ch[r][0],x);
    }
    private:
    int cnt,ch[N*lim][2],siz[N*lim],key[N*lim];
    ll val[N*lim],sum[N*lim];
    void Pushup(int r)
    {
        siz[r]=siz[ch[r][0]]+siz[ch[r][1]]+1;
        sum[r]=sum[ch[r][0]]+sum[ch[r][1]]+val[r];
    }
    int New(int x)
    {
        ++cnt;
        siz[cnt]=1,val[cnt]=sum[cnt]=x,key[cnt]=rand()+rand()-rand();
        return cnt;
    }
    int Copy(int x)
    {
        ++cnt;
        ch[cnt][0]=ch[x][0];
        ch[cnt][1]=ch[x][1];
        siz[cnt]=siz[x],val[cnt]=val[x],sum[cnt]=sum[x],key[cnt]=key[x];
        return cnt;
    }
    void Split(int r,int &lt,int &rt,int k)//按排名切割
    {
        if(!r){lt=rt=0;return;}
        int w=Copy(r);
        if(siz[ch[r][0]]>=k)rt=w,Split(ch[r][0],lt,ch[rt][0],k);
        else lt=w,Split(ch[r][1],ch[lt][1],rt,k-siz[ch[r][0]]-1);
        Pushup(w);
    }
    void Merge(int &r,int lt,int rt)//合并
    {
        if(!lt||!rt){r=lt^rt;return;}
        if(key[lt]<key[rt])r=Copy(lt),Merge(ch[r][1],ch[lt][1],rt);
        else r=Copy(rt),Merge(ch[r][0],lt,ch[rt][0]);
        Pushup(r);
    }
    void Erase(int &r)//删除最大元素
    {
        r=Copy(r);
        if(!ch[r][1])r=ch[r][0];
        else Erase(ch[r][1]);
        if(r)Pushup(r);
    }
}S;
int m,n;
struct node
{
    ll s;
    int t,wh;
    bool operator<(node b)const
    {
        if(t!=b.t)return t<b.t;
        return wh<b.wh;
    }
}A[2*N];
ll getint()
{
    ll p=0;bool f=0;
    char c=getchar();
    while(c<'0'||c>'9')if(c=='-')f=1;else c=getchar();
    while(c>='0'&&c<='9')p=p*10+c-'0',c=getchar();
    if(f)p=-p;
    return p;
}
int main()
{
    srand(0x20191629);
    m=getint();n=getint();
    for(int i=1;i<=m;i++)
    {
        int a=getint(),b=getint(),c=getint();
        A[2*i-1].t=a;A[2*i-1].wh=1;A[2*i-1].s=c;
        A[2*i].t=b+1;A[2*i].wh=0;A[2*i].s=c;
    }
    sort(A+1,A+2*m+1);
    int p=1;
    for(int i=1;i<=n;i++)
    {
        root[i]=root[i-1];
        for(;p<=2*m&&A[p].t==i;p++)
            if(A[p].wh)S.Insert(root[i],A[p].s);
            else S.Delete(root[i],A[p].s);
    }
    ll pre=1;
    for(int i=1;i<=n;i++)
    {
        int X=getint(),A=getint(),B=getint(),K=getint();
        K=1+(A*pre+B)%K;
        printf("%lld\n",pre=S.Query(root[X],K));
    }
}
```

---

## 作者：I_AM_HelloWord (赞：8)

属于稍加修改的主席树模板题。

[主席树基础传送门。](http://blog.csdn.net/no1\_terminator/article/details/77601599)

好了，说说这道题吧。在原先求前k大的主席树维护的size：数字个数上加上维护一个sum：数字的和就好了。

运用差分思想，将区间的累加修改改为两个点的修改，然后前缀和一下就是行了。

即[st,en]+sum=a[st]+sum,a[en+1]-sum,s[en]=a[1]+.....a[en].

这就把sum维护好了，由于要求第k小，所以还要维护一个size。

题目分析起来不是很难。主席树只要理解的原理，代码的灵活性和可读性都很强。


参考代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long LL;
const int N=100010;
const int M=N*40;
struct Task{
    int end,val,tag;
    bool operator < (const Task &rhs) const{
        return end<rhs.end;
    }
    Task(int end,int val,int tag):end(end),val(val),tag(tag){}
    Task(){}
}b[N*3];
struct President_Tree{
    LL sum,size;
    int L,R;
}T[M];
int root[N],n,m,T_cnt=1,totm=0,a[N];
int read(){
    int x=0,f=1;char ch=getchar();
    while (ch<'0' || ch>'9'){if (ch=='-')f=-1;ch=getchar();}
    while ('0'<=ch && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
void insert(int &now,int x,int index,int l=1,int r=n){
    T[T_cnt++]=T[now];now=T_cnt-1;
    T[now].size+=(LL)index;
    T[now].sum+=(LL)index*a[x];
    if (l==r)return;
    int mid=(l+r)>>1;
    if (x<=mid)insert(T[now].L,x,index,l,mid);
        else insert(T[now].R,x,index,mid+1,r);
}
LL query(int now,int k,int l=1,int r=n){
    if (l==r)return T[now].sum/T[now].size*(LL)k;
    int t=T[T[now].L].size,mid=(l+r)>>1;
    if (k<=t)return query(T[now].L,k,l,mid);
        else return T[T[now].L].sum+query(T[now].R,k-t,mid+1,r);
}
int main(){
    m=read(),n=read();
    for (int i=1;i<=m;i++){
        int x=read(),y=read(),z=read();
        b[++totm]=Task(x,z,1);
        b[++totm]=Task(y+1,z,-1);
        a[i]=z;
    }
    sort(a+1,a+m+1);
    sort(b+1,b+totm+1);
    root[0]=0;
    for (int i=1,j=1;i<=n;i++){
        root[i]=root[i-1];
        for (;j<=totm && b[j].end==i;j++){
            int rk=lower_bound(a+1,a+n+1,b[j].val)-a;
            insert(root[i],rk,b[j].tag);
        }
    }
    LL ans=1;
    for (int i=1;i<=n;i++){
        LL x=read(),a=read(),b=read(),c=read();
        LL kth=(a*ans+b)%c+1;
        if (kth>=T[root[x]].size)ans=T[root[x]].sum;
            else ans=query(root[x],kth);
        printf("%lld\n",ans);
    }
    return 0;
}
```

---

## 作者：ccviolett (赞：6)

题目相当于要写一个数据结构，支持查询覆盖某一个位置的线段中，前 k 小的线段权值和。

每个位置都可能被查询到，查询的次数和位置数同阶，无法利用线段树 lazytag 优化，况且 lazytag 也无法做前 k 小和。

要查询前 k 小的和，势必就要对每个点建一棵值域线段树来维护。一个线段可能包含 m 个位置，暴力插入会需要更新 m 给线段树。

考虑对位置建线段树，将线段插入到线段树上，线段树上每个节点是一棵值域线段树，这样就只需要最多更新$nlog(n)$ 个值域线段树，可以在查询之前处理好。

现在的问题在于处理查询，某一个位置的值域线段树会由其到根路径上的值域线段树合并而来，由于线段树树高的关系，最多只会合并 $log(n)$ 棵线段树。

考虑如何对于一棵值域线段树求出前 k 小值的和，可以维护一个 size 和 val，分别表示线段数量和其权值和，当 k 大于左边 size 时，减去 size 加上 val 往右走，否则往左走，下到叶子节点时再计算前 k 个的贡献。

大概想的是这样，去写了一下，发现残忍被卡，可能是常数大的原因，也可能是数据严格的原因。

优化了一下写法，加了 O(2)，跑过了。

这是区间线段树套权值线段树的代码：

```cpp
typedef long long readtype;

/* Header {{{ */
#include <bits/stdc++.h>
using namespace std;

typedef long long var;
typedef long double let;

readtype read() {
  readtype a = 0, c = getchar(), s = 0;
  while (!isdigit(c)) s |= c == '-', c = getchar();
  while (isdigit(c)) a = a * 10 + c - 48, c = getchar();
  return s ? -a : a;
}
/* }}} */

const int N = 1e5 + 1;

struct Line {
  int l, r, v;
};

int m, n;
Line line[N];
int len, val[N];
struct ValTree {
  int T, lson[N << 8], rson[N << 8];
  int size[N << 8], sum[N << 8];
  void modify(int p, int v, int &t, int l = 1, int r = m) {
    if (p > r || p < l) return ;
    if (!t) t = ++T;
    size[t] += v, sum[t] += v * val[p];
    if (l == r) return ;
    int mid = (l + r) >> 1;
    if (l == r) return ;
    modify(p, v, lson[t], l, mid), modify(p, v, rson[t], mid + 1, r);
  }
  int kth(int k, int len, int *t, int l = 1, int r = m) {
    if (l == 1 && r == len) {
      int sizet = 0, sumt = 0;
      for (int i = 1; i <= len; ++i) {
        sizet += size[t[i]];
        sumt += sum[t[i]];
      }
      if (sizet <= k) return sumt;
    }

    int mid = (l + r) >> 1;
    if (l == r) {
      int sizet = 0;
      for (int i = 1; i <= len; ++i) 
        sizet += size[t[i]];
      return 1ll * min(sizet, k) * val[mid];
    }
    int sizel = 0, suml = 0;
    for (int i = 1; i <= len; ++i) {
      suml += sum[lson[t[i]]];
      sizel += size[lson[t[i]]];
    }
    if (k == sizel) return suml;

    if (k < sizel) {
      for (int i = 1; i <= len; ++i) 
        t[i] = lson[t[i]];
      return kth(k, len, t, l, mid);
    } 
    for (int i = 1; i <= len; ++i) 
      t[i] = rson[t[i]];
    return suml + kth(k - sizel, len, t, mid + 1, r);
  }
} vtree;

struct Tree {
  int root[N << 2];
  int len, rt[N << 2];
  void insert(int x, int y, int v, int t = 1, int l = 1, int r = n) {
    if (x > r || y < l) return ;
    if (x <= l && r <= y) {
      vtree.modify(v, 1, root[t]);
      return ;
    }
    int mid = (l + r) >> 1;
    insert(x, y, v, t << 1, l, mid), insert(x, y, v, t << 1 | 1, mid + 1, r);
  }
  var kth(int p, int k) {
    int t = 1, l = 1, r = n;
    len = 0;
    while (true) {
      rt[++len] = root[t];
      if (l == r) break;
      int mid = (l + r) >> 1;
      if (p <= mid) t = t << 1, r = mid;
      else t = t << 1 | 1, l = mid + 1;
    }
    return vtree.kth(k, len, rt);
  }
} tree;

int main() {
#ifndef ONLINE_JUDGE
  freopen("P3168.in", "r", stdin);
  freopen("P3168.out", "w", stdout);
#endif
  m = read(), n = read();
  for (int i = 1; i <= m; ++i) {
    int l = read(), r = read(), v = read();
    line[i] = (Line) {l, r, v};
    val[i] = v;
  }
  sort(val + 1, val + m + 1);
  len = unique(val, val + m + 1) - val - 1;
  for (int i = 1; i <= m; ++i) 
    line[i].v = upper_bound(val + 1, val + len + 1, line[i].v) - val - 1;
  for (int i = 1; i <= m; ++i) 
    tree.insert(line[i].l, line[i].r, line[i].v);
  var res = 1;
  for (int i = 1; i <= n; ++i) {
    var x = read(), a = read(), b = read(), c = read();
    var k = 1 + (a * res + b) % c;
    res = tree.kth(x, k);
    printf("%lld\n", res);
  }
  return 0;
}
```

发现被卡去问了一下 CYJian，CYJian 说

> 外层能用树状数组不用线段树，能用线段树不用 Splay，能用 FHQ Treap 不用 Splay

然后就去写了树状数组套权值线段树，结果发现并没有优化......还是要开 O(2) 才能过，下面是代码：

```cpp
typedef long long readtype;

/* Header {{{ */
#include <bits/stdc++.h>
using namespace std;

typedef long long var;
typedef long double let;

readtype read() {
  readtype a = 0, c = getchar(), s = 0;
  while (!isdigit(c)) s |= c == '-', c = getchar();
  while (isdigit(c)) a = a * 10 + c - 48, c = getchar();
  return s ? -a : a;
}
/* }}} */

const int N = 1e5 + 1;

struct Line {
  int l, r, v;
};

int m, n;
Line line[N];
int len, val[N];
int cnt, rt[N];
struct ValTree {
  int T, lson[N << 8], rson[N << 8];
  int size[N << 8], sum[N << 8];
  void insert(int p, int v, int &t, int l = 1, int r = len) {
    if (p > r || p < l) return ;
    if (!t) t = ++T;
    size[t] += v, sum[t] += v * val[p];
    if (l == r) return ;
    int mid = (l + r) >> 1;
    insert(p, v, lson[t], l, mid), insert(p, v, rson[t], mid + 1, r);
  }
  int kth(int k, int l = 1, int r = len) {
    if (l == 1 && r == len) {
      int sizet = 0, sumt = 0;
      for (int i = 1; i <= cnt; ++i) {
        sizet += size[rt[i]];
        sumt += sum[rt[i]];
      }
      if (sizet <= k) return sumt;
    }

    int mid = (l + r) >> 1;
    if (l == r) {
      int sizet = 0;
      for (int i = 1; i <= cnt; ++i)
        sizet += size[rt[i]];
      return min(k, sizet) * val[mid];
    }

    int sizel = 0, suml = 0;
    for (int i = 1; i <= cnt; ++i) {
      sizel += size[lson[rt[i]]];
      suml += sum[lson[rt[i]]];
    }
    if (k == sizel) return suml;

    if (k < sizel) {
      for (int i = 1; i <= cnt; ++i) rt[i] = lson[rt[i]];
      return kth(k, l, mid);
    }
    for (int i = 1; i <= cnt; ++i) rt[i] = rson[rt[i]];
    return suml + kth(k - sizel, mid + 1, r);
  }
} vtree;
struct TreeArray {
  int root[N];
  void modify(int t, int p, int v) {
    for (int i = t; i <= n; i += i & -i)
      vtree.insert(p, v, root[i]);
  }
  int query(int t, int k) {
    cnt = 0;
    for (int i = t; i; i -= i & -i) rt[++cnt] = root[i];
    return vtree.kth(k);
  }
} arr;

int main() {
#ifndef ONLINE_JUDGE
  freopen("P3168.in", "r", stdin);
  freopen("P3168.out", "w", stdout);
#endif
  m = read(), n = read();
  for (int i = 1; i <= m; ++i) {
    int l = read(), r = read(), v = read();
    line[i] = (Line) {l, r, v}, val[i] = v;
  }
  sort(val + 1, val + m + 1);
  len = unique(val + 1, val + m + 1) - val - 1;
  for (int i = 1; i <= m; ++i) {
    int p = upper_bound(val + 1, val + len + 1, line[i].v) - val - 1;
    arr.modify(line[i].l, p, 1);
    arr.modify(line[i].r + 1, p, -1);
  }
  var res = 1;
  for (int i = 1; i <= n; ++i) {
    var x = read(), a = read(), b = read(), c = read();
    var k = 1 + (a * res + b) % c;
    res = arr.query(x, k);
    printf("%lld\n", res);
  }
  return 0;
}
```

正解是差分+主席树，由于线段一开始是给出的，所以其实没有必要将线段插入用数据结构维护。

我们可以直接差分一下，在左端点插入数值，在右端点右侧删除数值，在询问之前就可以处理出每个位置的权值线段树。

当然，有一个问题我们需要解决，普通的单点修改主席树不能满足我们的要求，因为对于每个位置，我们可能要修改其树上超过一个叶子的值，而一次普通的更新只会更新树上的一条链。

这里有两种解决方法。

第一种是将所要更新的叶子拆开来，也就是对于一个位置，我们向主席数中插入若干次，以最后一次插入的结果作为当前位置的结果。

第二种是一次插入所有的叶子，适当地修改我们的主席树插入操作，使得对于每个叶子都能插入到。

我采用的是第二种方法，一是因为好写，二是因为第一种拆分树上修改的方法需要占用更多的内存，会新建很多相同的路径。

代码如下：

```cpp
typedef long long readtype;

/* Header {{{ */
#include <bits/stdc++.h>
using namespace std;

typedef long long var;
typedef long double let;

readtype read() {
  readtype a = 0, c = getchar(), s = 0;
  while (!isdigit(c)) s |= c == '-', c = getchar();
  while (isdigit(c)) a = a * 10 + c - 48, c = getchar();
  return s ? -a : a;
}
/* }}} */

const int N = 1e5 + 1;

struct Line {
  int l, r, v;
};

int m, n;
Line line[N];
int len, val[N];
int top, fi[N], ne[N << 1], to[N << 1], co[N << 1];
struct ValTree {
  int T, lson[N << 8], rson[N << 8];
  int size[N << 8], sum[N << 8];
  void insert(int p, int rt, int &t, int l = 1, int r = len) {
    bool have = false;
    int csize = 0, csum = 0;
    for (int i = fi[p]; i; i = ne[i]) {
      if (l <= to[i] && to[i] <= r) {
        have = true;
        csize += co[i], csum += co[i] * val[to[i]];
      }
    }
    t = ++T, lson[t] = lson[rt], rson[t] = rson[rt];
    size[t] = size[rt] + csize, sum[t] = sum[rt] + csum;
    if (!have) return ;

    if (l == r) return ;
    int mid = (l + r) >> 1;
    insert(p, lson[rt], lson[t], l, mid);
    insert(p, rson[rt], rson[t], mid + 1, r);
  }
  int kth(int k, int t, int l = 1, int r = len) {
    if (l == 1 && r == len && size[t] <= k) return sum[t];
    int mid = (l + r) >> 1;
    if (l == r) return min(k, size[t]) * val[mid];

    if (k == size[lson[t]]) return sum[lson[t]];
    if (k < size[lson[t]]) return kth(k, lson[t], l, mid);
    return sum[lson[t]] + kth(k - size[lson[t]], rson[t], mid + 1, r);
  }
} vtree;
int cnt, root[N];

void add(int u, int v, int w);

int main() {
#ifndef ONLINE_JUDGE
  freopen("P3168.in", "r", stdin);
  freopen("P3168.out", "w", stdout);
#endif
  m = read(), n = read();
  for (int i = 1; i <= m; ++i) {
    int l = read(), r = read(), v = read();
    line[i] = (Line) {l, r, v}, val[i] = v;
  }
  sort(val + 1, val + m + 1);
  len = unique(val + 1, val + m + 1) - val - 1;
  for (int i = 1; i <= m; ++i) {
    int p = upper_bound(val + 1, val + len + 1, line[i].v) - val - 1;
    add(line[i].l, p, 1);
    add(line[i].r + 1, p, -1);
  }

  for (int i = 1; i <= n; ++i) vtree.insert(i, root[i - 1], root[i]);

  var res = 1;
  for (int i = 1; i <= n; ++i) {
    var x = read(), a = read(), b = read(), c = read();
    var k = 1 + (a * res + b) % c;
    res = vtree.kth(k, root[x]);
    printf("%lld\n", res);
  }
  return 0;
}

void add(int u, int v, int w) {
  ne[++top] = fi[u], fi[u] = top, to[top] = v, co[top] = w;
}
```

当然，这个做法是需要将区间离线的，如果需要支持动态插入区间，那么就只能用上面的两种树套树了。

---

## 作者：11223344w (赞：6)

之前的人为啥都要离散化？

差分以后跑一遍主席数就好了

PS：把权值线段树yy成数组，问题就变成了先区间修改，后单点查询，这东西不是差分吗？

不用离散化

```cpp
#include<cstdio>
#include<iostream>
#define ll long long
using namespace std;

const int N=2e5+5,M=7e6+5;
int n,m,rt[N],ls[M],rs[M],mx,c[M];
int cnt,to[N],he[N],nxt[N],_to[N],_he[N],_nxt[N];
ll s[M],lst;

inline void add(int u,int v) {
	to[++cnt]=v,nxt[cnt]=he[u],he[u]=cnt;
}

inline void edd(int u,int v) {
	_to[++cnt]=v,_nxt[cnt]=_he[u],_he[u]=cnt;
}

void bld(int &p,int l,int r,int x,int k) {
	ls[++cnt]=ls[p],rs[cnt]=rs[p],
	s[cnt]=s[p]+x*k,c[cnt]=c[p]+k,p=cnt;
	if(l==r) {
		return;
	}
	int mid=l+r>>1;
	if(x<=mid) {
		bld(ls[p],l,mid,x,k);
	} else {
		bld(rs[p],mid+1,r,x,k);
	}
}

ll sum(int p,int l,int r,int k) {
	if(l==r) {
		return min(s[p],(ll)k*l);
	}
	int mid=l+r>>1,d=c[ls[p]];
	if(d>=k) {
		return sum(ls[p],l,mid,k);
	} else {
		return sum(rs[p],mid+1,r,k-d)+s[ls[p]];
	}
}

int main() {
	scanf("%d%d",&m,&n);
	while(m--) {
		int u,v,k; 
		scanf("%d%d%d",&u,&v,&k);
		add(u,k),edd(v+1,k); mx=max(mx,k);
	}
	for(int i=1;i<=n;i++) {
		rt[i]=rt[i-1];
		for(int e=he[i];e;e=nxt[e]) {
			bld(rt[i],1,mx,to[e],1);
		}
		for(int e=_he[i];e;e=_nxt[e]) {
			bld(rt[i],1,mx,_to[e],-1);
		}
	}
	lst=1;
	for(int i=1;i<=n;i++) {
		int x,a,b,c,k; 
		scanf("%d%d%d%d",&x,&a,&b,&c);
		k=((ll)a*lst+b)%c+1;
		printf("%lld\n",lst=sum(rt[x],1,mx,k));
	}
	return 0;
}
```


---

## 作者：caidzh (赞：5)

~~怎么没人写树套树啊，写起来很清真啊，稍微卡卡常数就过了qwq~~

这里是树状数组套动态开点线段树的做法，时间复杂度$O(nlog^2n)$，需要一点点卡常

首先看到这道题，对于这种毒瘤的区间修改，我们常见的技巧是进行差分，也就是说，对于区间$[l,r]$，我们给这个区间增加一个数$k$，经过差分后结果就是在$l$添加上$k$，在$r+1$删去$k$

对于权值线段树比较熟悉的同学这时候就可以发现，区间的信息就可以使用权值线段树维护了

考虑怎么进行查询，单点$l$的信息到底存储在哪里，做过树状数组$2$的同学又可以知道，它是所有$[1,l]$的权值线段树的合并，对于这个操作，我们可以考虑使用树状数组套动态开点权值线段树维护这个操作

代码压行严重：
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int inline read(){
    int num=0,neg=1;char c=getchar();
    while(!isdigit(c)){if(c=='-')neg=-1;c=getchar();}
    while(isdigit(c)){num=(num<<3)+(num<<1)+c-'0';c=getchar();}
    return num*neg;
}
const int maxn=300010;int m,n,tmp[maxn],cnt,ans=1;
int rt[maxn*80],ls[maxn*80],rs[maxn*80],sum[maxn*80],total[maxn*80],tot;
struct Up{int l,r,w;}Up[maxn];//外层树状数组维护时间，内层动态开点值域线段树 
void Pre(){sort(tmp+1,tmp+m+1);cnt=unique(tmp+1,tmp+m+1)-tmp-1;}
void update(int &x,int l,int r,int pos,int val){
	if(!x)x=++tot;int mid=l+r>>1;sum[x]+=tmp[pos]*val;total[x]+=val;if(l==r)return;
	if(mid>=pos)update(ls[x],l,mid,pos,val);if(mid<pos)update(rs[x],mid+1,r,pos,val);
}void Upd(int x,int w,int val){for(int i=x;i<=n;i+=i&(-i))update(rt[i],1,cnt,w,val);}int A[30],lena;
void Query(int l,int r,int k){
	if(l==r){int p=0;for(int i=1;i<=lena;i++)p+=total[A[i]];ans+=tmp[l]*min(p,k);return;}
	int p=0,mid=l+r>>1;for(int i=1;i<=lena;i++)p+=total[ls[A[i]]];
	if(p>=k){for(int i=1;i<=lena;i++)A[i]=ls[A[i]];Query(l,mid,k);}
	else{for(int i=1;i<=lena;i++)ans+=sum[ls[A[i]]],A[i]=rs[A[i]];Query(mid+1,r,k-p);}
}void Q(int pos,int k){lena=0;for(int i=pos;i;i-=i&(-i))A[++lena]=rt[i];Query(1,cnt,k);printf("%d\n",ans);}
signed main()
{
	m=read();n=read();for(int i=1;i<=m;i++){Up[i].l=read();Up[i].r=read();tmp[i]=Up[i].w=read();}
	Pre();for(int i=1;i<=m;i++)Up[i].w=lower_bound(tmp+1,tmp+cnt+1,Up[i].w)-tmp;
	for(int i=1;i<=m;i++)Upd(Up[i].l,Up[i].w,1),Upd(Up[i].r+1,Up[i].w,-1);
	for(int i=1;i<=n;i++){int pos=read(),a=read(),b=read(),c=read();int k=1+(a*ans+b)%c;ans=0;Q(pos,k);}return 0;
}
```

---

## 作者：Isonan (赞：4)

原题传送门[>Here<](https://www.luogu.org/problemnew/show/P3168)

主席树板子，把一个S到E的操作看成在S时加1，T+1时减1，然后把操作按照时间排序，存一下每个时间点的最后一棵树的根就可以了。

代码：

```cpp
#include <cstdio>
#include <algorithm>

struct point{
	int t,ad;
	long long p;
}num[200001];
bool cmp(point a,point b){
	return a.t<b.t;
}
int root[200001],end[100001],lson[5000001],rson[5000001],size[5000001],cnt,n,m,x;
long long k,a,b,c,pre=1,val[5000001];
void add(int &pos,int pre,int l,int r,int ad,int num){
	pos=++cnt;
	lson[pos]=lson[pre];
	rson[pos]=rson[pre];
	val[pos]=val[pre];
	size[pos]=size[pre];
	val[pos]+=(long long)num*ad;
	size[pos]+=ad;
	if(l==r)return;
	if((l+r)>>1>=num)add(lson[pos],lson[pre],l,(l+r)>>1,ad,num);
	else add(rson[pos],rson[pre],((l+r)>>1)+1,r,ad,num);
}
long long query(int pos,int l,int r,int k){
	if(size[pos]<=k)return val[pos];
	if(l==r)return (long long)l*(long long)k;
	if(size[lson[pos]]>=k)return query(lson[pos],l,(l+r)>>1,k);
	else return query(rson[pos],((l+r)>>1)+1,r,k-size[lson[pos]])+val[lson[pos]];
}
int main(){
	scanf("%d%d",&m,&n);
	for(int i=1;i<=m;i++)scanf("%d%d%lld",&num[i*2-1].t,&num[i*2].t,&num[i*2-1].p),num[i*2].p=num[i*2-1].p,num[i*2].t++,num[i*2-1].ad=1,num[i*2].ad=-1;
	std::sort(num+1,num+m*2+1,cmp);
	for(int i=1,j=1;i<=n;i++){
		while(num[j].t==i&&j<=m*2)
			add(root[j],root[j-1],1,10000000,num[j].ad,num[j].p),j++;
		end[i]=root[j-1];
	}
	for(int i=1;i<=n;i++){
		scanf("%d%lld%lld%lld",&x,&a,&b,&c);
		k=1+(a*pre+b)%c;
		printf("%lld\n",pre=query(end[x],1,10000000,(int)k));
	}
}
```

---

## 作者：zhou2414 (赞：3)

看到大佬们都在用主席树写，但是蒟蒻难以理解这样写的原因，于是只好写了个更容易理解的线段树合并。
# 前置知识

差分（~~不会差分写这题？~~）。

离散化。（~~不会离散化写这题？）~~。

权值线段树（~~其实就是线段树维护桶~~）。

线段树合并（~~不会的先写[这题](https://www.luogu.com.cn/problem/P4556)~~）。

# 思路
**差分+权值线段树+线段树合并。**

题目要求求每一秒权值前 $k$ 小的任务的权值和，这不正是权值树该干的吗?

于是想到在每一个时间点开一个权值树，维护任务总数 $cnt$ 用于求前 $k$ 小，维护优先级总和 $sum$ 用于求答案。

题目要求区间修改，于是想到利用差分思想。    
将 $s$ 秒的权值树对应位置的 $cnt+1$，$sum+p$。    
将 $e+1$ 秒的权值树对应位置的 $cnt-1$，$sum-p$。 

最后将权值树按照时间顺序合并，第一秒与第二秒合并，然后将第二秒与第三秒合并，以此类推，即可得到修改之后每一秒中任务的数据（类比差分数组求前缀和得到原数组）。

查询时直接在第 $x$ 秒的权值树上查询前 $k$ 小的优先级总和即可。

这时有巨佬就要发问了，优先级最大值为 $10^{7}$，内存怎么不炸？

我们来看，任务总数为 $m$，也就是至多有 $m$ 种不同的优先级，我们只对于这些优先级进行操作，对于不存在的优先级不需要处理（就相当于优先级的范围为 $1$ ~ $m$），这就给了我们离散化的机会。~~离散化应该都会吧~~。  
然后动态开点，只有当某颗权值树上的某个节点被使用到时才开一个节点，这样就不存在浪费空间的问题了。

具体细节看代码。
# 复杂度分析

每次利用动态开点和离散化，每加入一个新的任务时，只增加至多 $2\cdot \log_{2}{m}$ 个节点，共有 $m$ 个任务，所以空间复杂度 $O(2\cdot m\log_{2}{m})$。这题的空间非常充裕，完全够用。

每次加入一个任务时至多新开 $2\cdot \log_{2}{m}$ 个节点，所以单次加入任务的复杂度为 $O(\log_{2}{m})$，共修改 $m$ 次，建树时间复杂度 $O(m\log_{2}{m})$。

合并假设将每个端点都与另一个端点合并，时间复杂度与空间复杂度一致，为 $O(m\log_{2}{m})$。

查询复杂度 $O(\log_{2}{m})$  ~~（这个不用过多解释了吧）~~。

总时间复杂度：
$$
O(m\log_{2}{m})
$$

可以通过此题。

# 代码


```cpp
#include<bits/stdc++.h>
#define ll long long
#define dd double
#define lson c[id].ls
#define rson c[id].rs
#define mid ((l+r)/2)
using namespace std;
inline ll read(){
	ll x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-'){
			f=-1;
		}
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*f;
}
void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9){
		write(x/10);
	}
	putchar(x%10+'0');
}
const ll N=1e5+9;
ll b[N],q;//离散化
ll s[N],e[N],a[N];//存储任务信息
ll n,m,pre=1;
ll ccnt;//动态开点
struct NODE{
	ll ls,rs;
	ll cnt,sum;//任务数，优先级总和
}c[N*50];//权值树
ll root[N];//第i秒对应的权值树的根节点
ll getid(ll x){
	return lower_bound(b+1,b+q+1,x)-b;
}
void pu(ll id){//push_up
	c[id].cnt=c[lson].cnt+c[rson].cnt;
	c[id].sum=c[lson].sum+c[rson].sum;
}
void change(ll &id,ll l,ll r,ll x,ll vel){//某秒优先级为x的任务增加或减少1
	if(!id){
		id=++ccnt;
	}
	if(l==r){
		c[id].cnt+=vel;
		c[id].sum+=b[x]*vel;
		return;
	}
	if(x<=mid){
		change(lson,l,mid,x,vel);
	}
	else{
		change(rson,mid+1,r,x,vel);
	}
	pu(id);
}
ll hebing(ll u,ll v,ll l,ll r){//把v合并到u上
	if(u==0||v==0){
		return u+v;
	}
	if(l==r){
		c[u].cnt+=c[v].cnt;
		c[u].sum+=c[v].sum;
		return u;
	}
	c[u].ls=hebing(c[u].ls,c[v].ls,l,mid);
	c[u].rs=hebing(c[u].rs,c[v].rs,mid+1,r);
	pu(u);
	return u;
}
void cacl(){//合并差分数据得到原数据
	for(int i=1;i<=n;i++){//按照时间顺序合并
		root[i]=hebing(root[i],root[i-1],1,q);
	}
}
ll qu(ll id,ll l,ll r,ll k){//查询某秒优先级最小的k个任务的优先级之和
	if(l==r){
		if(c[id].cnt>k){
			return (c[id].sum/c[id].cnt)*k;//由于叶子节点只表示一种优先级，所以可以算出每个任务的优先级然后乘以k出答案
		}
		else{
			return c[id].sum;
		}
	}
	if(k<=c[lson].cnt){
		return qu(lson,l,mid,k);
	}
	else{
		return qu(rson,mid+1,r,k-c[lson].cnt)+c[lson].sum;
	}
}
int main(){
	m=read();
	n=read();
	for(int i=1;i<=m;i++){
		s[i]=read(),e[i]=read(),a[i]=read();
		b[++q]=a[i];
	}
	sort(b+1,b+q+1);
	q=unique(b+1,b+q+1)-b-1;//离散化
	for(int i=1;i<=m;i++){
		change(root[s[i]],1,q,getid(a[i]),1);
		change(root[e[i]+1],1,q,getid(a[i]),-1);//差分思想修改
	}
	cacl();//线段树合并
	for(int i=1;i<=n;i++){
		ll x=read(),a=read(),b=read(),c=read();
		ll k=1+(a*pre+b)%c;
		pre=qu(root[x],1,q,k);
		write(pre);
		putchar('\n');
	}
	return 0;
}
```

本题解已通过 hack，[记录](https://www.luogu.com.cn/record/197597301)。

---

## 作者：zhenglier (赞：3)

应该不难想到对于每一个点开一个权值线段树，但空间只有512MB，明显不行，而且如果我们把每个数暴力加入，肯定会TLE，所以需要一堆优化。

我们可以发现每个相隔的线段树，肯定有部分相同，所以我们可以用可持久化线段树来做了，同时对于一个数值，我们在左边那个时间点+1，在右边那个时间点**往后一个点**-1就可以了。我们开两个vector记录加减就行了。

好吧，还需要离散化。

最后我们对每一个询问求个区间和就行了。

这里有一个坑点，对于第K大那个点，我们需要加的不是这个值而是加上剩下的数乘上当前数。

然后就可以A掉了。

```cpp
#include<bits/stdc++.h>
#define mid (l+(r-l)/2)
using namespace std;
const int N=100010;
int n,m,q;
vector<int>ad[N],dl[N];
int a[N];
int cnt,root[N],lson[N<<6],rson[N<<6],tr[N<<6];
long long sum[N<<6];
int build(int l,int r){
    int rt=++cnt;
    if(l==r)return rt;
    lson[rt]=build(l,mid);
    rson[rt]=build(mid+1,r);
    return rt;
}
inline void pushup(int rt){
    sum[rt]=sum[lson[rt]]+sum[rson[rt]];
}
int updata(int pre,int l,int r,int x,int z){
    int rt=++cnt;
    tr[rt]=tr[pre]+z;
    if(l==r){
        return rt;
    }
    lson[rt]=lson[pre];
    rson[rt]=rson[pre];
    if(x<=mid)lson[rt]=updata(lson[pre],l,mid,x,z);
    else rson[rt]=updata(rson[pre],mid+1,r,x,z);
    return rt;
}
long long query(int rt,int l,int r,int k){
    if(l==r)return a[l]*min(k,tr[rt]);
    if(tr[lson[rt]]>=k)return query(lson[rt],l,mid,k);
    else return query(rson[rt],mid+1,r,k-tr[lson[rt]])+sum[lson[rt]];
}
void dfs(int rt,int l,int r){
    if(!tr[rt]||sum[rt])return;
    if(l==r){
        sum[rt]=tr[rt]*a[l];
        return;
    }
    dfs(lson[rt],l,mid);
    dfs(rson[rt],mid+1,r);
    pushup(rt);
}
inline int read(){
    register int ret=0;register char c;
    for(c=getchar();!isdigit(c);c=getchar());
    for(;isdigit(c);ret=(ret<<1)+(ret<<3)+c-'0',c=getchar());
    return ret;
}
int main(){
    cin>>n>>q;
    for(int i=1;i<=n;++i){
        int l=read(),r=read(),p=read();
        ad[l].push_back(p);
        dl[r+1].push_back(p);
        a[i]=p;
    }
    sort(a+1,a+n+1);
    m=unique(a+1,a+n+1)-a-1;
    root[0]=build(1,m);
    for(register int i=1;i<=n;++i){
    	root[i]=root[i-1];
    	for(vector<int>::iterator it=ad[i].begin();it!=ad[i].end();++it){
    		root[i]=updata(root[i],1,m,lower_bound(a+1,a+m+1,*it)-a,1);
    	}
    	for(vector<int>::iterator it=dl[i].begin();it!=dl[i].end();++it){
    	    root[i]=updata(root[i],1,m,lower_bound(a+1,a+m+1,*it)-a,-1);
        }
    }
    for(int i=0;i<=n;++i){
        dfs(root[i],1,m);
    }
    long long last=1;
    while(q--){
        int x=read(),aa=read(),bb=read(),cc=read();
        aa=((long long)aa*(last%cc)+bb)%cc+1;
        last=query(root[x],1,m,aa);
        printf("%lld\n",last);
    }
}
```

---

## 作者：Limit (赞：2)

介绍本题的两种做法:

# 方法1

## 前置芝士
1. [线段树](https://baike.baidu.com/item/线段树/10983506?fr=aladdin):一个很重要的数据结构.
2. [树状数组](https://baike.baidu.com/item/树状数组/313739?fr=aladdin):一个很重要的数据结构.

## 具体实现

区间修改,单点查询很容易就会想到树状数组了,至于查询前k个数的和又可以丢给权值线段树去干,所以第一种很显然的方法就是树状数组套一个线段树实现.

## 代码

```cpp
#include<bits/stdc++.h>
#define REP(i,first,last) for(int i=first;i<=last;++i)
#define DOW(i,first,last) for(int i=first;i>=last;--i)
using namespace std;
const int maxN=5e5+7;
const int INF=2147483647;
int N,M;
int op[maxN];
int s[maxN],e[maxN],p[maxN];
int arr[maxN];
int sor[maxN];
int len=0;
map<int,int>Hash;//数据很大需要离散化
int val__[maxN];//记录离散化以后每个数代表的原来的值
struct Tree//动态开点线段树
{
	int sum,lson,rson;
	long long sum_;
}tree[maxN*32];
int point_cnt=0;
//线段树标准define
#define LSON tree[now].lson
#define RSON tree[now].rson
#define MIDDLE ((left+right)>>1)
#define LEFT LSON,left,MIDDLE
#define RIGHT RSON,MIDDLE+1,right
void PushUp(int now)
{
	tree[now].sum=tree[LSON].sum+tree[RSON].sum;//数的个数
	tree[now].sum_=tree[LSON].sum_+tree[RSON].sum_;//每个数相加以后的和
}
void UpDataMain(int num,int val,int &now,int left=1,int right=len)
//修改,在now中加入val个num
{
	if(num<left||right<num)
	{
		return;
	}
	if(!now)
	{
		now=++point_cnt;
	}
	if(left==right)
	{
		tree[now].sum+=+val;
		tree[now].sum_+=+val*val__[num];//需要加上原理的值*个数
		return;
	}
	UpDataMain(num,val,LEFT);
	UpDataMain(num,val,RIGHT);
	PushUp(now);
}
int lowbit(int now)//树状数组用的lowbit
{
	return now&-now;
}
int root[maxN];
void UpData(int top,int num,int val)//在top的位置加上val个num
{
	for(int now=top;now<=N;now+=lowbit(now))//树状数组的修改
	{
		UpDataMain(num,val,root[now]);
	}
}
//记录下当前需要加上的树的当前节点
int add_tree[maxN];
int num_add=0;
int GetSum()//当前树中数的个数
{
	int sum=0;
	REP(i,1,num_add){sum+=tree[add_tree[i]].sum;}
	return sum;
}
long long GetSum_()//当前树的数的和
{
	long long sum=0;
	REP(i,1,num_add){sum+=tree[add_tree[i]].sum_;}
	return sum;
}
int GetSumLeft()//当前树的左子树的数的个数
{
	int sum=0;
	REP(i,1,num_add){sum+=tree[tree[add_tree[i]].lson].sum;}
	return sum;
}
long long GetSum_Left()//当前树的左子树的数的和
{
	long long sum=0;
	REP(i,1,num_add){sum+=tree[tree[add_tree[i]].lson].sum_;}
	return sum;
}
int GetSumRight()//当前树的右子树的数的个数
{
	int sum=0;
	REP(i,1,num_add){sum+=tree[tree[add_tree[i]].rson].sum;}
	return sum;
}
long long GetSum_Right()//当前树的右子树的数的和
{
	long long sum=0;
	REP(i,1,num_add){sum+=tree[tree[add_tree[i]].rson].sum_;}
	return sum;
}
void GetRootLeft()//将节点换成左儿子
{
	REP(i,1,num_add){add_tree[i]=tree[add_tree[i]].lson;}
}
void GetRootRight()//将节点换成右儿子
{
	REP(i,1,num_add){add_tree[i]=tree[add_tree[i]].rson;}
}
long long QueryMain(int k,int left=1,int right=len)//查询部分主要函数
{
	int sum=GetSum();//得到当前树的数的个数
	if(left==right)//如果是叶节点
	{
		return /*当前表示的数*/val__[left]*/*只有sum个数,最多取k个数,所以取一个min*/min(sum,k);
	}
	if(k>=sum)//如果k太大
	{
		return GetSum_();//返回当前树的数的和
	}
	int left_sum=GetSumLeft();//左子树的数的个数
	if(left_sum>=k)//如果大于等于k就差左子树
	{
		GetRootLeft();
		return QueryMain(k,left,MIDDLE);
	}
	//否则就差找右子树
	long long result=GetSum_Left();
	GetRootRight();
	return result+QueryMain(k-left_sum,MIDDLE+1,right);
}
void BeforeQuery(int place)//预处理
{
	num_add=0;
	for(int now=place;now;now-=lowbit(now))
	{
		add_tree[++num_add]=root[now];
	}
}
long long Query(int place,int k)//查询
{
	BeforeQuery(place);//预处理
	return QueryMain(k);
}
void UpDataAdd(int left,int right,int num)//修改,和普通树状数组相同
{
	UpData(left,Hash[num],1);
	UpData(right+1,Hash[num],-1);
}
int main()
{
	scanf("%d%d",&M,&N);
	int num_cnt=0;
	REP(i,1,M)
	{
		scanf("%d%d%d",&s[i],&e[i],&p[i]);//记录下来离散化
		sor[++num_cnt]=p[i];
	}
	sort(sor+1,sor+1+num_cnt);
	sor[0]=-INF;
	REP(i,1,num_cnt)
	{
		if(sor[i]!=sor[i-1])
		{
			Hash[sor[i]]=++len;
			val__[len]=sor[i];
		}
	}
	REP(i,1,M)
	{
		UpDataAdd(s[i],e[i],p[i]);//直接修改
	}
	long long pre=1;
	int x,a,b,c,k;
	REP(i,1,N)
	{
		scanf("%d%d%d%d",&x,&a,&b,&c);
		k=1+(a*pre+b)%c;//按公式计算k
		pre=Query(x,k);//查询
		printf("%lld\n",pre);
	}
	return 0;
}
```

# 方法2

## 前置芝士
1. [可持久化线段树](https://www.baidu.com/s?wd=可持久化线段树&ie=UTF-8) :可以用[主席树](https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&tn=baidu&wd=主席树&oq=%25E5%258F%25AF%25E6%258C%2581%25E4%25B9%2585%25E5%258C%2596%25E7%25BA%25BF%25E6%25AE%25B5%25E6%25A0%2591&rsv_pq=f635f4100001ee83&rsv_t=b326%2F5YPs7kWClLnUjhDOBNKoWWyyE4MqPy4rlVhYfKIGBgk9vJSvgZIQ6Q&rqlang=cn&rsv_enter=1&rsv_dl=tb&rsv_sug3=9&rsv_sug1=3&rsv_sug7=100&rsv_sug2=0&inputT=2039&rsv_sug4=2039)来实现.
2. [差分](https://baike.baidu.com/item/差分/10349967?fr=aladdin):优化方法1.

## 具体实现

可以发现方法1非常非常麻烦,所以可以发现可以用主席树维护前缀每个数出现的次数,然后就差分搞一下就好了.

## 代码

```cpp
#include<bits/stdc++.h>
#define REP(i,first,last) for(int i=first;i<=last;++i)
#define DOW(i,first,last) for(int i=first;i>=last;--i)
using namespace std;
const int maxN=3e5+7;
int N,M;
int sor[maxN];
long long hanum[maxN];
int p[maxN];
int tot=0;
map<int,int>Hash;

//一个没什么用的东西,可以像搞图论一样把每个位置要放入的数和这个位置连一条边,可以简单处理
struct Edge
{
	int next,val,add;
}edge[maxN*2];
int cnt_edge=0;
int head[maxN];
#define FOR(now) for(int _i_=head[now];_i_;_i_=edge[_i_].next)
#define VAL edge[_i_].val
#define ADD edge[_i_].add
void AddEdge(int form,int val,int add)
{
	edge[++cnt_edge].val=val;
	edge[cnt_edge].add=add;
	edge[cnt_edge].next=head[form];
	head[form]=cnt_edge;
}

struct Tree//主席树
{
	int lson,rson,sum;
	long long sum_;
}tree[maxN*32];
#define LSON tree[now].lson
#define RSON tree[now].rson
#define MIDDLE ((left+right)>>1)
#define LEFT LSON,left,MIDDLE
#define RIGHT RSON,MIDDLE+1,right
#define NEW_LSON tree[new_tree].lson
#define NEW_RSON tree[new_tree].rson
int cnt_point=0;
void PushUp(int now)
{
	tree[now].sum=tree[LSON].sum+tree[RSON].sum;
	tree[now].sum_=tree[LSON].sum_+tree[RSON].sum_;
}
void UpData(int num,int val,int &new_tree,int now,int left=1,int right=tot)
{
	if(num<left||right<num)
	{
		new_tree=now;
		return;
	}
	new_tree=++cnt_point;
	if(left==right)
	{//和方法一差不多
		tree[new_tree].sum=tree[now].sum+val;//加上数的个数
		tree[new_tree].sum_=tree[now].sum_+hanum[num]*val/*数的个数*这个数*/;
		return;
	}
	UpData(num,val,NEW_LSON,LEFT);
	UpData(num,val,NEW_RSON,RIGHT);
	PushUp(new_tree);
}
long long Query(int k,int now,int left=1,int right=tot)//查询写得比较随便
{
	if(k<=0)return 0;//懒得分类讨论
	if(left==right)//到叶节点了直接计算
	{
		return min(k,tree[now].sum)/*取k和当期树中数的个数的小值*/*hanum[left];
	}
	if(k>=tree[now].sum)//如果k太大了
	{
		return tree[now].sum_;
	}
	return Query(k,LEFT)+Query(k-tree[LSON].sum,RIGHT);
}
int root[maxN];//记录每个位置的主席树的根节点
int main()
{
	scanf("%d%d",&M,&N);
	int s,e;
	REP(i,1,M)
	{
		scanf("%d%d%d",&s,&e,&p[i]);
		sor[i]=p[i];
		AddEdge(s,p[i],1);//添加边到这个数,和差分相同,l位置+1,r+1位置-1
		AddEdge(e+1,p[i],-1);
	}
	sort(sor+1,sor+1+M);//离散化
	sor[0]=114154;
	REP(i,1,M)
	{
		if(sor[i]!=sor[i-1])
		{
			Hash[sor[i]]=++tot;
			hanum[tot]=sor[i];
		}
	}
	int check;
	REP(i,1,N)//建树
	{
		if(head[i])//如果这个位置有加入新的数
		{
			check=1;//开始是从上一颗树变化,后来是自己修改自己
			FOR(i)//把数加入这个数
			{
				UpData(Hash[VAL],ADD,root[i],root[i-check]);
				check=0;
			}
		}
		else
		{
			root[i]=root[i-1];//没有就和上一个位置相同
		}
	}
	long long pre=1;
	int x,a,b,c,k;
	REP(i,1,N)
	{
		scanf("%d%d%d%d",&x,&a,&b,&c);
		k=1+(a*pre+b)%c;//计算k
		pre=Query(k,root[x]);
		printf("%lld\n",pre);
	}
	return 0;
}
```

# 比较两种方法

方法1的做法更显然,很容易得出,但是$N\log_2^2N$的时间复杂度很容易TLE,方法二更容易写,但是需要用到差分,不一定可以直接想出来,跑起来比方法1快了很多.

---

## 作者：2018LZY (赞：2)

这是用树状数组求**差分前缀和**+主席树好题。


------------


差分数组是什么？

设$a$为原数列，$b$为差分数组。

令$b[i]=a[i]-a[i-1]$。特殊的，$b[1]=a[1]$(方便处理)

则有:$\sum_{i=1}^x b[i]=a[i]$(裂项相消)



------------
由于每次处理的$[l,r]$区间很大，不可能$O(n\log n)$去处理。
但是它又是区间加，所以我们考虑用树状数组维护主席树。



------------
关于数据范围，赠送一个算粗略数据范围的程序。
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long ll;
const int N=1e5+10;
ll s[N],n,ans;
int main() {
	n=N-10;s[1]=0;
	for(ll i=1,j=2,jj;j<=n;j++) {
		jj=(1<<(i-1))+j-1;
		for(   ;j<=min(n,jj);j++)
			s[j]=s[j-1]+i;
		j=jj;
	}
	for(int i=1,j;i<=n;i++) {
		j=i&-i;ans+=18LL*j-s[j];
	}
	printf("%lld\n",ans);
	return 0;
}
```
上面的代码有点粗糙，所以我一般再加上10N的大小。


代码：
```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
#define g getchar()
using namespace std;
typedef long long ll;
const int N=1e5+10;
//快读快写 
void qr(int &x) {
	char c=g;x=0;
	while(!isdigit(c))c=g;
	while(isdigit(c))x=x*10+c-'0',c=g;
}
void write(ll x) {
	if(x/10)write(x/10);
	putchar(x%10+'0');
}
void pri(ll x) {write(x);puts("");}
int n,m,L[N],R[N],b[N],p[N]; ll ans;
//离散化 
bool cmp(int x,int y){return b[x]<b[y];}
void disc() {
	sort(p+1,p+n+1,cmp);
	int &l=p[0]=0;
	for(int i=1,d=b[p[1]]-1;i<=n;i++)	
		if(b[p[i]]!=d)d=b[p[i]],b[p[i]]=++l,p[l]=d;
		else b[p[i]]=l;
}
//大块主席树代码 
struct node{int l,r,c;ll s;}tr[N*160];int len,root[N];
void update(int l,int r,int &x,int pos,int d) {
	if(!x)x=++len; 	
	tr[x].c+=d; tr[x].s+=d*p[pos];
	if(l==r)return;
	int mid=(l+r)>>1;
	if(pos<=mid)update(l,mid,tr[x].l,pos,d);
	else 	  update(mid+1,r,tr[x].r,pos,d);
}
int d[22];
void query(int l,int r,int k) {
	if(l==r){ans+=1LL*k*p[l];return;}
	int mid=(l+r)>>1;
	int s;ll sum;s=sum=0;
	for(int i=1;i<=d[0];i++)s+=tr[tr[d[i]].l].c,sum+=tr[tr[d[i]].l].s;
	if(k<=s) {
		for(int i=1;i<=d[0];i++)d[i]=tr[d[i]].l;
		query(l,mid,k);
	}
	else {
		ans+=sum;
		for(int i=1;i<=d[0];i++)d[i]=tr[d[i]].r;
		query(mid+1,r,k-s);
	}
}
//树状数组维护差分 
void up(int x,int pos,int d){for(   ;x<=n;x+=x&-x)update(1,p[0],root[x],pos,d); }
void down(int *a,int x){a[0]=0;for(   ;x;x-=x&-x)a[++a[0]]=root[x]; }//取编号
int main() {
	qr(n);qr(m);
	for(int i=1;i<=n;i++)
		qr(L[i]),qr(R[i]),qr(b[i]),p[i]=i;
	disc();
	
	for(int i=1;i<=n;i++)
		up(L[i],b[i],1),up(R[i]+1,b[i],-1);
	
	ans=1;
	while(m--) {
		int x,a,b,c,s;ll sum;qr(x);qr(a);qr(b);qr(c);
		a=(1ll*a*ans+b)%c+1;
		down(d,x);
		s=sum=0;
		for(int i=1;i<=d[0];i++)s+=tr[d[i]].c,sum+=tr[d[i]].s;
		if(a>=s)pri(ans=sum);
		else ans=0,query(1,p[0],a),pri(ans);
	}
	return 0;
}


```


---

## 作者：zyh2015 (赞：2)

来自我的博客：http://blog.csdn.net/YihAN\_Z/article/details/53998106


欢迎到本沙茶的博客转转



题目大意：有n个任务持续m秒，每个任务从si秒开始到ei秒结束且有一个优先级pi，有m个询问，回答第xi秒时正在执行的任务中优先级前k小和，强制在线。



根据时间的变化，任务会开始或结束。我们想知道任一时刻任务的执行情况，这里我们就需要用到可持久化数据结构。对于这道题，我们可以维护一个权值线段树[^1]。



可持久化数据结构，暴力地想就是每个版本完全复制一个保存起来，但是空间不够用。


如果每次只是修改一个点的话，在线段树中会有logn个点的信息发生变化，其余仍然和前一秒一样，这样的话直接复用前一秒的版本，空间复杂度从n^2logn变为nlog^2n.



具体如何实现呢？


先在第0秒创建一个空版本。把每一个任务分成两个操作：在第si秒插入在ei+1秒删除。把操作按照时间排序然后构建每一秒的权值线段树。插入或删除时要新建结点。



权值范围太大这里需要离散化。


在复制结点的时候不要忘记复制儿子指针。


k要开long long。


线段树查找第k大时递归到点树上要进行讨论。


改了一上午。离散化辣眼睛凑合看吧0.0


```cpp
#include <cstdio>
#include <algorithm>
#include <queue>
#define N 100005
#define INF 1e7
using namespace std;
typedef long long LL;
inline int abs(int x) {return x>0 ? x : -x;}
int n,m;
LL ans=1;
struct Segment_Tree{
    Segment_Tree *ch[2];
    int s;
    LL sum;
    Segment_Tree(Segment_Tree* x) {
        if(x==NULL) s=0 , sum=0 , ch[0]=ch[1]=NULL;
        else s=x->s , sum=x->sum , ch[0]=x->ch[0] , ch[1]=x->ch[1];
    }
}*root[N];
int disc[N];
typedef Segment_Tree ST;
void Init(ST*& x,int l,int r) {
    x=new ST(NULL);
    if(l==r) return ;
    int mid=l+r>>1;
    Init(x->ch[0],l,mid); Init(x->ch[1],mid+1,r);
    return ;
}
void Insert(ST*& x,int v,int l,int r) {
    ST* cach=x;
    x=new ST(cach);
    int flag=(v>0?1:-1);
    x->s+=flag , x->sum+=flag*disc[abs(v)];
    if(l==r) return ;
    int mid=l+r>>1;
    if(abs(v)<=mid) Insert(x->ch[0],v,l,mid);
    else Insert(x->ch[1],v,mid+1,r);
    return ;
}
LL Query(ST* x,int k,int l,int r) {
    if(k>=x->s) return x->sum;
    if(l==r) return (x->sum/x->s)*k;
    int mid=l+r>>1;
    if(x->ch[0]!=NULL) {
        if(x->ch[0]->s>=k) return Query(x->ch[0],k,l,mid);
        return x->ch[0]->sum+Query(x->ch[1],k-x->ch[0]->s,mid+1,r);
    }
    return Query(x->ch[1],k,mid+1,r);
}
struct Operation {
    int ord,val;
    Operation(int x=0,int y=0):ord(x),val(y){}
    bool operator < (const Operation& rhs) const { return ord<rhs.ord; }
}p[N*2];
typedef Operation Node;
Node q[N];
bool cmp(Node x,Node y) {return x.val<y.val;}
int main() {
    scanf("%d%d",&n,&m);
    Init(root[0],1,n);
    for(int i=1;i<=n;i++) {
        int l,r,pri;
        scanf("%d%d%d",&l,&r,&pri);
        p[i]=Operation(l,pri);
        p[i+n]=Operation(r+1,-pri);
        q[i]=Node(i,pri);
    }
    sort(q+1,q+1+n,cmp);
    for(int i=1;i<=n;i++) {
        int cach;
        if(q[i].val!=q[i-1].val) cach=i;
        else cach=p[q[i-1].ord].val;
        disc[cach]=q[i].val;
        p[q[i].ord].val=cach;
        p[q[i].ord+n].val=-cach;
    }
    sort(p+1,p+1+2*n);
    LL k=1;
    for(int i=1;i<=m;i++) {
        root[i]=root[i-1];
        while(p[k].ord==i && k<=n*2) Insert(root[i],p[k++].val,1,n);
    }
    for(int i=1;i<=m;i++) {
        int x,a,b,c;
        scanf("%d%d%d%d",&x,&a,&b,&c);
        k=1+(a*ans+b)%c;
        printf("%lld\n",ans=Query(root[x],k,1,n));
    }
    return 0;
}
```

[^1]:权值线段树是啥？就是结点编号不再代表序列编号，而是权值大小，常在每个结点处维护size域表示当前结点代表的权值范围内有几个数，用于查询第k小。


第k小怎么查？和Treap差不多啦


---

## 作者：tyno夏 (赞：1)

看了几篇题解，感觉我的思路和大佬们的有点区别，应该更容易理解，因为不需要离散化，所以希望写一篇题解，说一说别的思路。

### 大致思路：主席树的板子+前缀和+二分查找答案。
具体的来说，因为题目是要求找前k小数的和，那么很显然，这可以用二分的方法；其次，题目的要求是区间修改，而主席树想要区间修改需要树套树（太难了），而这道题显然可以用前缀和来实现。

那么具体来说明，说先，由于想要二分，我们希望树是有序的，所以先对数据按照p为关键字排序，然后按照新顺序建树；同时，这里建树的过程和普通主席树有点区别，我们希望使用前缀和来维护区间修改，那么我们一次性显然需要维护两个节点，所以需要insert两次，并且要记住以后每次使用根节点都要使用2*i。

```cpp
for(int i=1;i<=n;i++)
    inp[i].s=read(),inp[i].e=read(),inp[i].p=read();sort(inp+1,inp+n+1);
for(int i=1;i<=n;i++)
{
	insert(1,n+1,root[2*i-2],root[2*i-1],inp[i].s,inp[i].p,i);
	insert(1,n+1,root[2*i-1],root[2*i],inp[i].e+1,-inp[i].p,i);
}
```
那么建树的过程就完成了，我们的树以任务的序号为树根，以任务的优先级为节点，
#### 下面介绍具体建树的过程：
大部分和普通主席树一样，特别的地方是需要维护一个sum——所有任务的前缀时间和，cnt——任务数量的前缀和。

```cpp
void insert(int l,int r,int pre,int &now,int pos,int val,int tm)
{
	now=++cnt;
	hjt[now]=hjt[pre];
	if(l==r)
	{
		hjt[now].sum+=val;
		hjt[now].cnt+=(val>0?1:-1);	
		return;
	}
	int mid=(l+r)/2;
	if(pos<=mid) insert(l,mid,hjt[pre].l,hjt[now].l,pos,val,tm);
	else insert(mid+1,r,hjt[pre].r,hjt[now].r,pos,val,tm);
	hjt[now].cnt=hjt[hjt[now].l].cnt+hjt[hjt[now].r].cnt;
	hjt[now].sum=hjt[hjt[now].l].sum+hjt[hjt[now].r].sum;
}
```

接下来就是查询了，对于每个k，我们不能直接找到某个任务序号，这里我们可以使用二分方法，每次查找1-mid这些任务在x时间的任务数量，如果ansnum==k，可以直接退出，不需要再寻找（因为显然就算没有达到最优解，包含x时间的任务数还是相同的，只是包含了一些其他时间的任务，对答案没有任何影响）。

```cpp
while(m--)
	{
		x=read(),a=read(),b=read(),c=read();
		k=1+(a*pre+b)%c;		
		int minn=0,maxx=n+1,ans=-1;
		while(minn<=maxx)
		{
			int mid=(minn+maxx)/2;
			int ansnum=qcnt(1,n+1,root[2*mid],x);
			if(ansnum>k)
				maxx=mid-1;
			else if(ansnum<k)
				minn=mid+1;
			else
			{
				ans=mid;
				break;
			}			
		}
		if(ans==-1)
			ans=n;				
		ansnow=qans(1,n+1,root[2*ans],x);
		printf("%d\n",ansnow); 
		pre=ansnow;
	}
```

#### 具体来看查找任务数的qcnt函数：
很简单，基本就是一个线段树查询，这里要找pos位置的任务数，也就是0-pos的区间和，0可以直接省略。

```cpp
int qcnt(int l,int r,int R,int pos)
{
	if(r<=pos) return hjt[R].cnt;
	int mid=(l+r)/2,tt=0;
	tt+=qcnt(l,mid,hjt[R].l,pos);
	if(pos>mid) tt+=qcnt(mid+1,r,hjt[R].r,pos);
	return tt;
}
```

#### 最后是qans计算时间函数，和qcnt基本相同
```cpp
int qans(int l,int r,int R,int pos)
{
	if(r<=pos) return hjt[R].sum;
	int mid=(l+r)/2,tt=0;
	tt+=qans(l,mid,hjt[R].l,pos);
	if(pos>mid) tt+=qans(mid+1,r,hjt[R].r,pos);
	return tt;
}
```
这样这道题就完成了。

## 总结
对于区间修改的问题，考虑利用前缀和来帮助我们解决；同时，前k小之和可以考虑用二分解决。

附完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    char c=getchar();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
#define int long long
#define N 200005
struct node
{
	int s,e,p;
	bool operator < (const node& b) const
	{
		return p<b.p;
	}
}inp[N];
struct tree
{
	int l,r;
	int sum,cnt;
}hjt[N*80];
int cnt=0,root[2*N];
int lst[N];
void insert(int l,int r,int pre,int &now,int pos,int val,int tm)
{
	now=++cnt;
	hjt[now]=hjt[pre];
	if(l==r)
	{
		if(lst[l]==0) 
			hjt[now].sum+=val;
		else
			hjt[now].sum+=val;
		lst[l]=tm;
		hjt[now].cnt+=(val>0?1:-1);
		
		return;
	}
	int mid=(l+r)/2;
	if(pos<=mid) insert(l,mid,hjt[pre].l,hjt[now].l,pos,val,tm);
	else insert(mid+1,r,hjt[pre].r,hjt[now].r,pos,val,tm);
	hjt[now].cnt=hjt[hjt[now].l].cnt+hjt[hjt[now].r].cnt;
	hjt[now].sum=hjt[hjt[now].l].sum+hjt[hjt[now].r].sum;
}
int qcnt(int l,int r,int R,int pos)
{
	if(r<=pos) return hjt[R].cnt;
	int mid=(l+r)/2,tt=0;
	tt+=qcnt(l,mid,hjt[R].l,pos);
	if(pos>mid) tt+=qcnt(mid+1,r,hjt[R].r,pos);
	return tt;
}
int qans(int l,int r,int R,int pos)
{
	if(r<=pos) return hjt[R].sum;
	int mid=(l+r)/2,tt=0;
	tt+=qans(l,mid,hjt[R].l,pos);
	if(pos>mid) tt+=qans(mid+1,r,hjt[R].r,pos);
	return tt;
}
signed main()
{
	int n=read(),m=read();
	int s,e,p;
    for(int i=1;i<=n;i++)
    	inp[i].s=read(),inp[i].e=read(),inp[i].p=read();
    sort(inp+1,inp+n+1);
	for(int i=1;i<=n;i++)
	{
		insert(1,n+1,root[2*i-2],root[2*i-1],inp[i].s,inp[i].p,i);
		insert(1,n+1,root[2*i-1],root[2*i],inp[i].e+1,-inp[i].p,i);
	}
	int x,a,b,c,k,ansnow;
	int pre=1;	
	while(m--)
	{
		x=read(),a=read(),b=read(),c=read();
		k=1+(a*pre+b)%c;		
		int minn=0,maxx=n+1,ans=-1;
		while(minn<=maxx)
		{
			int mid=(minn+maxx)/2;
			int ansnum=qcnt(1,n+1,root[2*mid],x);
			if(ansnum>k)
				maxx=mid-1;
			else if(ansnum<k)
				minn=mid+1;
			else
			{
				ans=mid;
				break;
			}			
		}
		if(ans==-1)
			ans=n;				
		ansnow=qans(1,n+1,root[2*ans],x);
		printf("%d\n",ansnow); 
		pre=ansnow;
	}
	return 0;
}
```
我这里很毒瘤的写了#define int long long

2333，这确实不是一个好习惯，只是下午调bug调崩溃了实在懒得改。

---

## 作者：Angora (赞：1)

显然对于区间优先级加k操作进行差分,对时间建主席树,维护优先级前缀和以及在这个优先级区间里的任务个数,更新就很简单了
,查询类似查区间第k小.
``` c++
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#define rep(i,x,y) for(register int i=x;i<=y;++i)
#define repd(i,x,y) for(register int i=x;i>=y;--i)
#define ll long long
using namespace std;
const int N=2e5+7;
struct node{
	int l,val,p;
	node(int l,int val,int p):l(l),val(val),p(p){}
	node(){}
}e[N<<2];
ll tr[N<<5],size[N<<5];
int lson[N<<5],rson[N<<5],root[N],a[N],len,n,m,cnt;
inline int cmpv(node x,node y){return x.val<y.val;}
inline int cmpt(node x,node y){return x.l<y.l;}
inline void update(int &o,int l,int r,int k,int p){
	lson[++cnt]=lson[o];rson[cnt]=rson[o];tr[cnt]=tr[o];size[cnt]=size[o];
	o=cnt;tr[o]+=a[k]*p;size[o]+=p;
	if(l==r)return; 
	int mid=l+r>>1;
	if(k<=mid)update(lson[o],l,mid,k,p);
	else update(rson[o],mid+1,r,k,p);
}
inline ll query(int o,int l,int r,int k){
	if(size[o]<=k)return tr[o];
	if(l==r)return tr[o]/size[o]*k;
	int mid=l+r>>1;
	if(k<=size[lson[o]])return query(lson[o],l,mid,k);
	return tr[lson[o]]+query(rson[o],mid+1,r,k-size[lson[o]]);
}
inline void solve(){
	scanf("%d%d",&n,&m);
	rep(i,1,n){
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		e[(i<<1)-1]=node(a,c,1);e[i<<1]=node(b+1,c,-1);
	}
	sort(e+1,e+n*2+1,cmpv);
	rep(i,1,n*2){if(e[i].val!=a[len])a[++len]=e[i].val;e[i].val=len;}
	sort(e+1,e+n*2+1,cmpt);
	ll pre=1;int k=1;
	rep(i,1,m){
		root[i]=root[i-1];
		while(e[k].l==i)update(root[i],1,len,e[k].val,e[k].p),k++;
	}
	rep(i,1,m){
		int x,A,B,c;
		scanf("%d%d%d%d",&x,&A,&B,&c);
		pre=(pre*A+B)%c+1;
		printf("%lld\n",pre=query(root[x],1,len,pre));
	}
}
int main(){
	solve();
	return 0;
}
```

---

## 作者：magolor (赞：1)

主席树题，做差分统计，在差分树上操作，一边操作一边“滚动”。仅当i时刻的**所有操作结束**，将i作为i+1的原版。


统计答案时在线段树上二分就可以。注意一点，可能存在相同的优先级，比如说优先级可以使 2 3 3 4 6，这样查K = 2的时候答案不是值域线段树上2和3的位置的SUM，而是2的SUM加上剩余排名个数个3，详见代码。


离散化，数据太大了，我用的是sort+unique+map，清一色的STL，map有点慢，注意一下，能少用就少用，一开始就因为map所以TLE好久……


至于空间范围，告诉你们，很大，原题应该是512MB，不知道这里是多少，起码8\*10^6没有问题，不要开到4\*10^6以下，那样就RE了。


好了，各种问题都说了，不要问我怎么知道的，看看提交记录。

下面是代码。







    
    
    
    
            
    







    

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <map>
using namespace std;
#define MAXT 8000000
#define MAXN 100000
#define ll long long
#define lc(x) t[x].lc
#define rc(x) t[x].rc
#define mx(x) t[x].mx
#define sum(x) t[x].sum
#define mid ((lef+rig)>>1)
#define sgn(x) (x > 0 ? 1 : -1) 
struct Node
{
    ll mx,sum;
    int lc,rc;
    Node(){}
    Node(ll a, ll b)
    {
        mx = a, sum = b;
        return;
    }
};
ll dat[MAXN*4+5], tot, Pre = 1, n, k, op, tm, s, e, p;
Node t[MAXT+5];
map<ll,ll> h;
struct Segment_Tree
{
    int root;
    inline Node Merge(Node a, Node b)
    {
        a.mx += b.mx, a.sum += b.sum;
        return a;
    }
    inline void Push(int p)
    {
        mx(p) = mx(lc(p)) + mx(rc(p)), sum(p) = sum(lc(p)) + sum(rc(p));
        return;
    }
    inline void Init(int x = -1)
    {
        root = tot++;
        if(x+1)
            t[root] = t[x];
        return;
    }
    Node Query(int p, int lef, int rig, int L, int R)
    {
        if(!p || lef > rig)
            return Node(0ll,0ll);
        if(L == lef && R == rig)
            return t[p];
        if(R <= mid)
            return Query(lc(p),lef,mid,L,R);
        if(L >  mid)
            return Query(rc(p),mid+1,rig,L,R);
        return Merge(Query(lc(p),lef,mid,L,mid) , Query(rc(p),mid+1,rig,mid+1,R)); 
    }
    void Edit(int p, int lef, int rig, int x, int tag)
    {
        if(lef == rig)
        {
            mx(p) += tag, sum(p) += tag*dat[lef];
            return;
        }    
        int temp = tot++;
        if(x <= mid)
            t[temp] = t[lc(p)], lc(p) = temp, Edit(lc(p),lef,mid,x,tag);
        else
            t[temp] = t[rc(p)], rc(p) = temp, Edit(rc(p),mid+1,rig,x,tag);
        Push(p);
        return;
    }
};
Segment_Tree T[MAXN+5];
struct Task
{
    ll pos,val;    
}X[MAXN*2+5];
inline bool operator < (Task a, Task b)
{
    return a.pos < b.pos;
}
inline ll Search(ll ti, ll rank)
{
    ll lef = 1, rig = k;
    for(Node midd; lef < rig; )
    {
        midd = T[ti].Query(T[ti].root,1,k,1,mid);
        if(midd.mx >= rank)
            rig = mid;
        else
            lef = mid+1;
    }
    Node res = T[ti].Query(T[ti].root,1,k,1,lef-1);
    Node poi = T[ti].Query(T[ti].root,1,k,lef,lef);
    Pre = res.sum;
    if(rank <= res.mx+poi.mx)
        Pre += dat[lef]*(rank-res.mx);
    return Pre;
}
inline ll read()
{
    ll ans=0;    
    char last=' ',ch=getchar();
    while(ch<'0' || ch>'9') last=ch,ch=getchar();
    while(ch>='0' && ch<='9')ans=ans*10+ch-'0',ch=getchar();
    if(last=='-')ans=-ans;
    return ans;
}
void out(ll x)
{
    if(x<0)putchar('-'),x=-x;
    if(x<10)
        putchar(x+'0');
    else{
        out(x/10);
        putchar(x%10+'0');
    }
    return;
}
int main()
{
    n = read(), tm = read();
    for(register int i = op = k = 1; i <= n; i++)
        s = read(), e = read(), p = read(), dat[k++] = p,
        X[op].pos = s, X[op++].val = p, X[op].pos = e+1, X[op++].val = -p;
    sort(X+1,X+op), op--, sort(dat+1,dat+k), k = unique(dat+1,dat+k)-dat-1;
    for(register int i = 1; i <= k; i++)
        h[dat[i]] = i;
    T[0].Init();
    for(register int i = 1, j = 1; i <= tm; i++)
    {
        T[i].Init(T[i-1].root);
        for(; X[j].pos == i; j++)
            T[i].Edit(T[i].root,1,k,h[abs(X[j].val)],sgn(X[j].val));
    }
    for(ll x, a, b, c; tm--; out(Search(x,1+(a*Pre+b)%c)),putchar('\n'))
        x = read(), a = read(), b = read(), c = read();
     return 0;
}
看到有些代码，没用主席树，直接奇迹般暴力O（nm）水过了。敲了3个小时的我表示无语。
```

---

## 作者：zhangbo1000 (赞：0)

这题不一定要差分啊。

读完题不难想到覆盖了 $x$ 处的任务应当满足：在 $x$ 之前（含 $x$）开始，在 $x$ 之后（含 $x$）结束。

直接取这两部分的交集是不好做的，考虑逆向：这一部分实际上就是所有任务减去在 $x$ 之前结束的，再减去在 $x$ 之后开始的。

“在 $x$ 之前结束的”和“在 $x$ 之后开始的”排序之后用两棵可持久化线段树维护即可，在 $n$ 之前开始的或在 $1$ 之后结束的都是我们需要的“所有任务”。

代码：（这里写的并非传统的可持久化线段树，细节见代码。）

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<vector>
#include<cstring>
#include<algorithm>
#include<queue>
#include<set>
#include<deque>
#include<map>
#include<random>
#include<unordered_map>
using namespace std;

namespace code{
	using ll=long long;
	using ull=unsigned long long;
	using uint=unsigned int;
#define F(i,x,y) for(int i=(x),__tt2__=(y);i<=__tt2__;i++)
#define R(i,x,y) for(int i=(x),__tt2__=(y);i>=__tt2__;i--)
#define _F(i,x,y) for(int i=(x),__tt2__=(y);i<__tt2__;i++)
#define _R(i,x,y) for(int i=(x),__tt2__=(y);i>__tt2__;i--)
#define debug(x) cout<<#x<<'='<<(x)<<endl
	constexpr int N=100005,M=10000005;
	int c[N];
	struct node{
		ll tot;
		int sum,cnt,ls,rs;
		constexpr node(const ll& t=0,const int& s=0,const int& c=0,const int& l=0,const int& r=0):tot(t),sum(s),cnt(c),ls(l),rs(r){}
	}tree[N*32];
	int root1[N],root2[N],top=1;
#define newnode(x) (tree[++top]=tree[x],top)
	void add(const int& ind,const int& x,const int& nl=1,const int& nr=N){
		tree[ind].sum++;
		tree[ind].tot+=c[x];
		const int mid=(nl+nr)>>1;
		if(x==mid)tree[ind].cnt++;
		else if(x<mid){
			tree[ind].ls=newnode(tree[ind].ls);
			add(tree[ind].ls,x,nl,mid-1);
		}
		else {
			tree[ind].rs=newnode(tree[ind].rs);
			add(tree[ind].rs,x,mid+1,nr);
		}
	}
	ll query(const int& k,const int& x1,const int& x2,const int& x3,const int& nl=1,const int& nr=N){
		if(k==0)return 0;
		const int mid=(nl+nr)>>1,lsum=tree[tree[x1].ls].sum-tree[tree[x2].ls].sum-tree[tree[x3].ls].sum;
		const ll ltot=tree[tree[x1].ls].tot-tree[tree[x2].ls].tot-tree[tree[x3].ls].tot;
		if(lsum>=k)return query(k,tree[x1].ls,tree[x2].ls,tree[x3].ls,nl,mid-1);
		else if(lsum+tree[x1].cnt-tree[x2].cnt-tree[x3].cnt>=k){
			return ltot+(k-lsum)*c[mid];
		}
		else return ltot+((ll)(c[mid]))*(tree[x1].cnt-tree[x2].cnt-tree[x3].cnt)+query(k-lsum-tree[x1].cnt+tree[x2].cnt+tree[x3].cnt,tree[x1].rs,tree[x2].rs,tree[x3].rs,mid+1,nr);
	}
	struct task{
		int l,r,p;
		constexpr task(const int& x=0,const int& y=0,const int& z=0):l(x),r(y),p(z){}
	}a[N];
	char tmp[100000],*p=0,*top1=0;
#define getchar() ((p==top1)&&(top1=(p=tmp)+fread(tmp,1,100000,stdin)),*p++)
	void read(int& x){
		char c;
		while((c=getchar())<'0');
		x=c^'0';
		while((c=getchar())>='0')x=x*10+(c^'0');
	}
	int main(){
		cin.tie(0)->sync_with_stdio(0);
		int m,n;
		read(m);
		read(n);
		F(i,1,m){
			read(a[i].l);
			read(a[i].r);
			read(a[i].p);
			c[i]=a[i].p;
		}
		sort(c+1,c+1+m);
		F(i,1,m)a[i].p=lower_bound(c+1,c+1+m,a[i].p)-c;
		sort(a+1,a+1+m,[](const task& x,const task& y)->bool{return x.r<y.r;});
		for(int i=1,j=1;i<=n;i++){
			root1[i]=newnode(root1[i-1]);
			while(j<=m&&a[j].r<=i)add(root1[i],a[j++].p);
		}
		sort(a+1,a+1+m,[](const task& x,const task& y)->bool{return x.l<y.l;});
		for(int i=n,j=m;i>=1;i--){
			root2[i]=newnode(root2[i+1]);
			while(j>=1&&a[j].l>=i)add(root2[i],a[j--].p);
		}
		ll last=1;
		F(i,1,n){
			int x,a,b,c;
			read(x);
			read(a);
			read(b);
			read(c);
			int k=(((ll)(a))*last+b)%c+1;
			if(k>tree[root1[n]].sum-tree[root1[x-1]].sum-tree[root2[x+1]].sum)
				k=tree[root1[n]].sum-tree[root1[x-1]].sum-tree[root2[x+1]].sum;
			printf("%lld\n",last=query(k,root1[n],root1[x-1],root2[x+1]));
		}
		return 0;
	}
}
signed main(){return code::main();}
```

---

## 作者：bloodstalk (赞：0)

## Description
有 $m$ 个区间，每个区间有一个权值，$n$ 次询问，求覆盖一个点的前 $k$ 小区间和，强制在线。

$n,m\leq 10^5$

## Solution

给出一个不需要差分的主席树 + 二分的想法，应该更好想一点？

首先它要求前 $k$ 小区间和，那我们应该可以很自然想出先把区间按照权值从小到大排序。然后我们就可以把这些区间想成一个个版本，加入到主席树中。主席树维护两个东西：一个是区间被覆盖的次数，另一个是被覆盖的权值，由于是区间操作，我们可以标记永久化；并且由于是单点查询，所以我们其实只关心叶子节点被覆盖的次数或者被覆盖的权值，因此我们只需要在修改时对于被完全包含的区间打上标记即可。

查询的时候，我们先二分覆盖次数，找到 $x$ 被覆盖 $\leq k$ 次的最大版本，那么这个版本 $x$ 被覆盖的权值就是我们的答案，时间复杂度就是 $O(n\log^2n)$，也不需要离散化，注意被覆盖权值开 long long 即可。

## Code
```cpp
#include<bits/stdc++.h>
//#define int long long
#define ll long long
#define next nxt
#define re register
#define il inline
const int N = 1e5 + 5;
using namespace std;
int max(int x,int y){return x > y ? x : y;}
int min(int x,int y){return x < y ? x : y;}

int m,n,sec,ai,bi,ci,ki;
ll ans;
int root[N],idx;
struct Mission{
	int s,e,p;
	bool operator < (Mission &t) { return p < t.p; }
}a[N];
struct Tree{
	int l,r,siz;//覆盖次数
	ll sum;//覆盖权值
}tree[N*100];

il int read()
{
	int f=0,s=0;
	char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) f |= (ch=='-');
	for(; isdigit(ch);ch=getchar()) s = (s<<1) + (s<<3) + (ch^48);
	return f ? -s : s;
}

#define lc(x) tree[x].l
#define rc(x) tree[x].r

il void Modify(int x,int &y,int l,int r,int nl,int nr,int k)
{
	y = ++idx;
	tree[y] = tree[x];
	if(nl <= l && r <= nr)
	{
		tree[y].sum += k , tree[y].siz++;//被完全覆盖的打上标记即可
		return ;
	}
	int mid = (l+r) >> 1;
	if(nl <= mid) Modify(lc(x),lc(y),l,mid,nl,nr,k);
	if(nr > mid) Modify(rc(x),rc(y),mid+1,r,nl,nr,k);
}

il int QueryCnt(int p,int l,int r,int pos,int tag)//tag就是一路处理标记
{
	int res = 0;
	if(l == pos && r == pos) return tree[p].siz + tag;//叶子节点
	int mid = (l+r) >> 1;
	if(pos <= mid) res = QueryCnt(lc(p),l,mid,pos,tag+tree[p].siz);
	if(pos > mid) res = QueryCnt(rc(p),mid+1,r,pos,tag+tree[p].siz);
	return res;
}

il ll QuerySum(int p,int l,int r,int pos,ll tag)
{
	ll res = 0;
	if(l == pos && r == pos) return tree[p].sum + tag;
	int mid = (l+r) >> 1;
	if(pos <= mid) res = QuerySum(lc(p),l,mid,pos,tag+tree[p].sum);
	if(pos > mid) res = QuerySum(rc(p),mid+1,r,pos,tag+tree[p].sum);
	return res;
}

il ll Um_nik(int x,int k)//第x秒被覆盖k次
{
	int l = 1 , r = m , tot = m+1;
	if(k >= m) return QuerySum(root[m],1,n,x,0);
	while(l <= r)//二分被覆盖次数
	{
		int mid = (l+r) >> 1;
		if(QueryCnt(root[mid],1,n,x,0) <= k) tot = mid , l = mid + 1;
		else r = mid - 1;
	}
	return QuerySum(root[tot],1,n,x,0);//返回那个版本的被覆盖权值
}

signed main()
{
	m = read() , n = read();
	for(re int i=1;i<=m;i++) a[i].s = read() , a[i].e = read() , a[i].p = read();
	sort(a+1,a+m+1);//按照权值排序
	for(re int i=1;i<=m;i++) Modify(root[i-1],root[i],1,n,a[i].s,a[i].e,a[i].p);//建立版本
	ans = 1;
	for(re int i=1;i<=n;i++)
	{
		sec = read() , ai = read() , bi = read() , ci = read();
		ki = 1ll * ((ans % ci * ai % ci + bi % ci) % ci + 1);
		ans = Um_nik(sec,ki);
		cout << ans << "\n";
	}
	return 0;
}
```


---

## 作者：ubsan (赞：0)

### 可持久化权值线段树

看到询问为询问前 $K$ 大的和，我们自然可以想到用权值线段树来做。

但我们还需要维护现在有哪些任务在执行，所以我们可以把一个任务执行的区间$[s,e]$转化为这个任务在 $s$ 时加入，在 $t+1$ 时删除，这样就可以用线段树的单点修改来解决（即按照时间排序进行权值线段树的插入与删除），对于每一个时间的询问直接可持久化即可（就是记录一下每一个时间结束后 root 的位置）。

注意：因为值域为$10^7$,所以要动态开点。。。

#### code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct tree{
    struct node{
        int l,r,ls,rs,sum,siz;
    }a[10000000];
    int tot;
    int newNode(int l,int r){
        a[++tot]={l,r,-1,-1,0,0};
        return tot;
    }
    int copyNode(int from){
        //cout<<"copy "<<tot+1<<":"<<from<<endl;
        a[++tot]=a[from];
        //cout<<a[tot].l<<" "<<a[tot].r<<endl;
        return tot;
    }
    void build(int MAX_VALUE){
        a[0]={1,MAX_VALUE,-1,-1,0,0};
    }
    void pushup(int now){
        a[now].sum=0;
        a[now].siz=0;
        if(a[now].ls!=-1){
            a[now].sum+=a[a[now].ls].sum;
            a[now].siz+=a[a[now].ls].siz;
        }
        if(a[now].rs!=-1){
            a[now].sum+=a[a[now].rs].sum;
            a[now].siz+=a[a[now].rs].siz;
        }
    }
    int add(int from,int pos,int v,int __copy=1){
        int now;
        if(__copy){
            now=copyNode(from);
        }
        else{
            now=from;
        }
        int l=a[now].l,r=a[now].r;
        int mid=(l+r)/2;
        if(l==r){
            //cout<<"add "<<now<<" "<<v<<endl;
            a[now].sum+=v*l;
            a[now].siz+=v;
            //cout<<"->"<<a[now].siz<<endl;
            return now;
        }
        //cout<<pos<<" "<<mid<<endl;
        if(pos<=mid){
            //cout<<"go left"<<endl;
            if(a[now].ls==-1){
                a[now].ls=newNode(l,mid);
                add(a[now].ls,pos,v,false);
            }
            else
            a[now].ls=add(a[now].ls,pos,v);
        }
        else{
            //cout<<"go right"<<endl;
            if(a[now].rs==-1){
                a[now].rs=newNode(mid+1,r);
                add(a[now].rs,pos,v,false);
            }
            else
            a[now].rs=add(a[now].rs,pos,v);
        }
        pushup(now);
        //cout<<">"<<a[now].ls<<" "<<a[now].rs<<endl;
        return now;
    }
    int query(int now,int k){
        //cout<<now<<" "<<a[now].siz<<endl;
        int l=a[now].l,r=a[now].r;
        /*cout<<">"<<l<<" "<<r\
        <<" "<<a[now].ls<<" "<<a[now].rs<<endl;*/
        if(l==r){
            return min(k*l,a[now].sum);
        }
        if(a[now].siz==k){
            return a[now].sum;
        }
        int lsiz=a[now].ls==-1?0:a[a[now].ls].siz;
        int lsum=a[now].ls==-1?0:a[a[now].ls].sum;
        if(lsiz>=k){
            return query(a[now].ls,k);
        }
        else{
            if(a[now].rs==-1)return lsum;
            return lsum+query(a[now].rs,k-lsiz);
        }
    } 
}base;
int m,n;
vector<int>add[200000],del[200000];
int ver;
int roots[200000];
int times[200000];
int lastans=1;
signed main(){
    scanf("%lld%lld",&m,&n);
    base.build(20000000);
    for(int i=1;i<=m;i++){
        int s,e,p;
        scanf("%lld%lld%lld",&s,&e,&p);
        add[s].push_back(p);
        del[e+1].push_back(p);
    }
    for(int i=1;i<=n;i++){
        for(int j=0;j<add[i].size();j++){
            roots[ver+1]=base.tot+1;
            base.add(roots[ver],add[i][j],1);
            ver++;
        }
        for(int j=0;j<del[i].size();j++){
            roots[ver+1]=base.tot+1;
            base.add(roots[ver],del[i][j],-1);
            ver++;
        }
        /*cout<<"time %"<<i<<" "\
        <<base.a[roots[ver]].siz<<" "\
        <<base.a[roots[ver]].l\
        <<" "<<base.a[roots[ver]].r\
        <<"("<<roots[ver]<<")"<<endl;*/
        times[i]=roots[ver];
    }
    for(int i=1;i<=n;i++){
        int x,a,b,c;
        scanf("%lld%lld%lld%lld",&x,&a,&b,&c);
        int k=1+(a*lastans+b)%c;
        //cout<<"decode:"<<x<<" "<<k<<endl;
        lastans=base.query(times[x],k);
        printf("%lld\n",lastans);
    }
    #ifdef WIN32
    system("pause");
    #endif
    return 0;
}
```

---


# [CTSC2008] 网络管理

## 题目描述

M 公司是一个非常庞大的跨国公司，在许多国家都设有它的下属分支机构或部门。为了让分布在世界各地的 $n$ 个部门之间协同工作，公司搭建了一个连接整个公司的通信网络。  

该网络的结构由 $n$ 个路由器和 $n-1$ 条高速光缆组成。每个部门都有一个专属的路由器，部门局域网内的所有机器都联向这个路由器，然后再通过这个通信子网与其他部门进行通信联络。该网络结构保证网络中的任意两个路由器之间都存在一条直接或间接路径以进行通信。   

高速光缆的数据传输速度非常快，以至于利用光缆传输的延迟时间可以忽略。但是由于路由器老化，在这些路由器上进行数据交换会带来很大的延迟。而两个路由器之间的通信延迟时间则与这两个路由器通信路径上所有路由器中最大的交换延迟时间有关。  

作为 M 公司网络部门的一名实习员工，现在要求你编写一个简单的程序来监视公司的网络状况。该程序能够随时更新网络状况的变化信息（路由器数据交换延迟时间的变化），并且根据询问给出两个路由器通信路径上延迟第 $k$ 大的路由器的延迟时间。
****
【任务】   
你的程序从输入文件中读入 $n$ 个路由器和 $n-1$ 条光缆的连接信息，每个路由器初始的数据交换延迟时间 $t_i$，以及 $q$ 条询问（或状态改变）的信息。并依次处理这 $q$ 条询问信息，它们可能是：

1. 由于更新了设备，或者设备出现新的故障，使得某个路由器的数据交换延迟时间发生了变化。

2. 查询某两个路由器 $a$ 和 $v$ 之间的路径上延迟第 $k$ 大的路由器的延迟时间。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n,q \le 80000$，$0 \le k \le n$，任意一个路由器在任何时刻都满足延迟时间小于 $10^8$。



## 样例 #1

### 输入

```
5 5
5 1 2 3 4
3 1
2 1
4 3
5 3
2 4 5
0 1 2
2 2 3
2 1 4
3 3 5```

### 输出

```
3
2
2
invalid request!```

# 题解

## 作者：liuzhangfeiabc (赞：44)

经典的带修树链第k大问题。

先说说几种道听途说的做法:

1、树剖+线段树套平衡树，查询时需要二分答案。

复杂度达到了惊人的4个log，更惊人的是据说妥妥能过。（实在懒得写写试试了qwq）

2、树剖+树状数组套主席树（或者树状数组套trie之类的），这样好处在于：主席树天生就可以直接求第k大而不用像平衡树那样二分答案。

（看似平衡树可以直接求第k大，实际上这样没法合并多棵平衡树的答案，必须得二分，而主席树不用。）

总之就是用树剖花1个log的代价把树上问题转化成序列问题，然后做法就多种多样了。

这样是3个log的，同样能过。

然后就是我写的做法：直接写树状数组套主席树。

前面几种做法都避不开树剖这一环，如果能省去这一步的话就能做到更优的复杂度。

考虑不带修的树链第k大，本质上就是查询4条链：根到u的答案+根到v的答案-根到lca的答案-根到lca父亲的答案。

所以我们可以像序列上那样建出前缀主席树，每个节点的主席树存储的是根到它路径上的所有点，然后同时查询4棵主席树就行了。

然而这样的话修改一个节点的权值会影响到它的子树内所有的节点，于是我们不得不暴力修改O（n）棵主席树。

不过既然一个点的修改只会对子树内的节点产生整体影响，我们可以考虑维护dfs序，因为一棵子树在dfs序上是一段连续的区间。

所以问题就变成了：dfs序上的区间修改，单点查询。这可以用树状数组实现。

具体操作是：把所有的主席树进行差分，差分后每棵主席树每个位置的值相当于原来它这个位置的值-原来它在dfs序上的前一棵主席树这个位置的值，这样可能会产生负数不过我们不用管。

修改时就是把区间修改转化成两个单点修改，查询时一次性查询4条链对应的前缀主席树。

于是这个题变成了两个log。

（不过据说这个题有1个log的神奇解法，不过我不会啊qwq）

上代码：

```cpp
//ctsc2008 network:树上带修链上第k大
#include<bits/stdc++.h>
using namespace std;
#define gc getchar()
#define pc putchar
#define f(i) st[0][i]
#define md int mid = l + r >> 1
#define ln t[q].ls,l,mid
#define rn t[q].rs,mid + 1,r
#define md int mid = l + r >> 1
int r(){
	int x = 0;
	char c;
	c = gc;
	while(!isdigit(c)) c = gc;
	while(isdigit(c)){
		x = (x << 1) + (x << 3) + c - '0';
		c = gc;
	}
	return x;
}
void p(int q){
	if(q >= 10) p(q / 10);
	pc(q % 10 + '0');
}
int n,m;
struct edge{
	int to,nxt;
}e[200010];
int fir[100010],cnt;
void ins(int u,int v){
	e[++cnt].to = v;e[cnt].nxt = fir[u];fir[u] = cnt;
	e[++cnt].to = u;e[cnt].nxt = fir[v];fir[v] = cnt;
}
struct qry{
	int k,u,v;
}b[100010];
struct lsh{
	int a,id;
	bool bh;
}l[200010];
int ct,ct2,mx;
int dy[200010];
int fsts[100010],nxt[100010],dpt[100010],a[100010],st[20][100010];
int dfsx[100010],wz[100010],nw,sz[100010];
void dfs(int q){//打出dfs序 
	dfsx[++nw] = q;
	wz[q] = nw;
	sz[q] = 1;
	for(int i = fir[q];i;i = e[i].nxt){
		int j = e[i].to;
		if(f(q) == j) continue;
		f(j) = q;
		nxt[j] = fsts[q];
		fsts[q] = j;
		dpt[j] = dpt[q] + 1;
		dfs(j);
		sz[q] += sz[j];
	}
}
inline void buildst(){
	for(register int i = 1;i <= 17;++i){
		for(register int j = 1;j <= n;++j) st[i][j] = st[i - 1][st[i - 1][j]];
	}
} 
bool cp(lsh q,lsh w){
	return q.a < w.a;
}
int lca(int u,int v){
	if(dpt[u] < dpt[v]) swap(u,v);
	int z = dpt[u] - dpt[v],i = 0;
	while(z){
		if(z & 1) u = st[i][u];
		z >>= 1;
		++i;
	}
	if(u == v) return u;
	for(i = 17;i >= 0;--i){
		if(st[i][u] == st[i][v]) continue;
		u = st[i][u];
		v = st[i][v];
	}
	return f(u);
}
int rt[100010];
struct tree{
	int a,ls,rs;
}t[20000010];
void mdf(int &q,int l,int r,int x,int fx){//对一棵主席树进行修改 
	if(!q) q = ++ct;
	t[q].a += fx;
	if(l == r) return;
	md;
	if(x <= mid) mdf(ln,x,fx);
	else mdf(rn,x,fx);
}
void xg(int q,int x,int fx){//一个单点修改操作 
	for(int i = q;i <= n;i += (i & -i)) mdf(rt[i],1,mx,x,fx);
}
int now[100010];
int ts[100010],ft;
bool vst[100010];
int cx(int u,int v,int w,int p,int x){//查询操作，注意4条链的贡献是u + v - w - p
	int i;
	ft = 0;
	for(i = u;i;i -= (i & -i)) {
		if(vst[i]) continue;
		ts[++ft] = i;
		vst[i] = 1;
	}
	for(i = v;i;i -= (i & -i)) {
		if(vst[i]) continue;
		ts[++ft] = i;
		vst[i] = 1;
	}
	for(i = w;i;i -= (i & -i)) {
		if(vst[i]) continue;
		ts[++ft] = i;
		vst[i] = 1;
	}
	for(i = p;i;i -= (i & -i)) {
		if(vst[i]) continue;
		ts[++ft] = i;
		vst[i] = 1;
	}//提前存一下4条链会经过的树状数组节点的集合便于处理 
	for(i = 1;i <= ft;++i) now[ts[i]] = rt[ts[i]];
	int l = 1,r = mx,mid,as;
	while(l < r){
		mid = l + r >> 1;
		as = 0;
		for(i = u;i;i -= (i & -i)) as += t[t[now[i]].ls].a;
		for(i = v;i;i -= (i & -i)) as += t[t[now[i]].ls].a;
		for(i = w;i;i -= (i & -i)) as -= t[t[now[i]].ls].a;
		for(i = p;i;i -= (i & -i)) as -= t[t[now[i]].ls].a;
		if(as >= x){
			for(i = 1;i <= ft;++i) now[ts[i]] = t[now[ts[i]]].ls;
			r = mid;
		} 
		else{
			x -= as;
			for(i = 1;i <= ft;++i) now[ts[i]] = t[now[ts[i]]].rs;
			l = mid + 1;
		}
	}
	for(i = 1;i <= ft;++i) vst[ts[i]] = 0;
	return l;
}
void init(){//初始化 
	for(int i = 1;i <= n;++i){
		xg(wz[i],a[i],1);
		xg(wz[i] + sz[i],a[i],-1);
	}
}
int main(){
	int k,u,v,i,w;
	n = r();
	m = r();
	for(i = 1;i <= n;++i) {
		a[i] = r();
		l[++ct2].a = a[i];
		l[ct2].	bh = 0;
		l[ct2].id = i;
	}
	for(i = 1;i < n;++i){
		u = r();
		v = r();
		ins(u,v);
	}
	//以下是离散化部分，不过不离散化应该也行 
	for(i = 1;i <= m;++i){
		b[i].k = r();
		b[i].u = r();
		b[i].v = r();
		if(b[i].k) continue;
		l[++ct2].a = b[i].v;
		l[ct2].bh = 1;
		l[ct2].id = i;
	}
	sort(l,l + ct2 + 1,cp);
	l[0].a = -1;
	for(i = 1;i <= ct2;++i){
		if(l[i].a != l[i - 1].a) ++mx;
		if(!l[i].bh) a[l[i].id] = mx;
		else b[l[i].id].v = mx;
		dy[mx] = l[i].a;
	}
	dfs(1);
	buildst();
	init();
	for(i = 1;i <= m;++i){
		u = b[i].u,v = b[i].v,k = b[i].k;
		if(!k){
			xg(wz[u],a[u],-1);
			xg(wz[u] + sz[u],a[u],1);
			a[u] = v;
			xg(wz[u],a[u],1);
			xg(wz[u] + sz[u],a[u],-1);
		}
		else{
			w = lca(u,v);
			k = dpt[u] + dpt[v] - 2 * dpt[w] - k + 2;//这里把第k大变成了第k小 
			if(k <= 0){
				printf("invalid request!\n");
				continue;
			}	
			p(dy[cx(wz[u],wz[v],wz[w],wz[f(w)],k)]);
			putchar('\n');
		}
	}
	return 0;
} 
```

---

## 作者：小粉兔 (赞：25)

令人抓狂的整体二分题。根本原因还是我太菜了。

在学校写了一个下午写得头晕，回家里重写了一遍，一个小时就写完了……不过还是太慢。

## 题意简述：

一棵 $n$ 个结点的树，每个点有点权。

有 $m$ 次操作，每个操作要么是更改单点点权，要么是查询树链上第 $k$ 大点权。

## 题解：

树套树固然可以，但是整体二分也很好。

整体二分就是对于所有的询问一起二分答案，在二分区间范围内的查询和修改一并下传。

这题把整体二分基础题的操作搬到了链上，但是实现方法并没有太大不同。

初始点权看成增加点权，插入在所有操作的最前面即可。  
更改点权可以看成删除点权再增加点权，变成两次修改即可。

这题整体二分要求第 $k$ 大，考虑二分出的答案 $mid$，将**大于** $mid$ 的修改转成单点权值 $\pm 1$，  
而对于树链查询第 $k$ 大，则转化成链上权值之和是否等于 $k$。

写整体二分题永远要注意二分的条件，我的条件是，链上**大于** $mid$ 的点数**小于** $k$ 个则答案**小于等于** $mid$，否则答案**大于** $mid$。

单点修改，树链查询要是还用树剖就太naive了，套路转化：

考虑每个节点维护到根的路径上的信息，那么单点修改就变成子树修改，链查就变成四个单点查了（需要求LCA）。

而子树是一个区间，区间加法，单点查询；再使用树状数组差分技巧转化成单点差分，区间前缀和。

注意到还要求LCA，直接在DFS的时候用Tarjan处理就好了。

关于判断无解：当然可以直接处理掉……不过这样就必须求树链长度了。  
我的方法是，往权值里面加一个-1，如果答案是-1，则真实答案应该是无解。

我的代码还离散化了权值，其实没用……

其他恶心的地方就是整体二分基本功了，太弱了调了好久……注意循环变量是指向真实操作的下标的指针还是真实操作的下标，如果你写结构体当我没说。

```cpp
#include<stdio.h>
#include<string.h>
#include<algorithm>
using namespace std;
const int MN=80005;
const int MM=110005;
const int MQ=140005;
int n,m,q,w[MN],d[MQ],c;
int o[MQ],a[MQ],b[MQ],p[MQ],lc[MQ],ans[MQ];
int eh[MN],qh[MN],nxt[MM*2],to[MM*2],tot;
inline void ins(int*h,int x,int y){nxt[++tot]=h[x],to[tot]=y,h[x]=tot;}
int ld[MN],rd[MN],faz[MN],dfc;
int fa[MN];int ff(int x){return fa[x]?fa[x]=ff(fa[x]):x;}
void dfs(int u,int f){
	faz[u]=f,ld[u]=++dfc;
	for(int i=eh[u];i;i=nxt[i])if(to[i]!=f)dfs(to[i],u),fa[to[i]]=u;
	for(int i=qh[u];i;i=nxt[i])if(lc[to[i]])lc[to[i]]=ff(lc[to[i]]);else lc[to[i]]=u;
	rd[u]=dfc;
}
int B[MN];
inline void I(int i,int x){for(;i<=n;i+=i&-i)B[i]+=x;}
inline int Q(int i){int a=0;for(;i;i-=i&-i)a+=B[i];return a;}
int t[MQ];
void s(int l,int r,int L,int R){
	if(l>r)return;
	if(L==R){for(int i=l;i<=r;++i)ans[p[i]]=L;return;}
	int m=L+R>>1,p1=l-1,p2=r+1;
	for(int j=l,i;j<=r;++j){
		if(o[i=p[j]]>0){
			int x=Q(ld[a[i]])+Q(ld[b[i]])-Q(ld[lc[i]])-Q(ld[faz[lc[i]]]);
			if(x<o[i])o[i]-=x,t[++p1]=i;
			else t[--p2]=i;
		}
		else if(b[i]>m){
			I(ld[a[i]],o[i]?-1:1),I(rd[a[i]]+1,o[i]?1:-1);
			t[--p2]=i;
		}
		else t[++p1]=i;
	}
	for(int i=l;i<=r;++i)if(o[p[i]]<=0&&b[p[i]]>m)I(ld[a[p[i]]],o[p[i]]?1:-1),I(rd[a[p[i]]]+1,o[p[i]]?-1:1);
	reverse(t+p2,t+r+1),memcpy(p+l,t+l,r-l+1<<2);
	s(l,p1,L,m),s(p2,r,m+1,R);
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)scanf("%d",&w[i]),o[++q]=0,a[q]=i,b[q]=w[i],p[q]=q;
	for(int i=1,x,y;i<n;++i)scanf("%d%d",&x,&y),ins(eh,x,y),ins(eh,y,x);
	for(int i=1;i<=m;++i){
		++q,scanf("%d%d%d",&o[q],&a[q],&b[q]),p[q]=q;
		if(!o[q])o[++q]=-1,a[q]=a[q-1],b[q]=w[a[q-1]],p[q]=q,w[a[q-1]]=b[q-1];
	}
	for(int i=1;i<=q;++i)if(o[i]>0)ins(qh,a[i],i),ins(qh,b[i],i);else d[++c]=b[i];
	d[++c]=-1;sort(d+1,d+c+1);c=unique(d+1,d+c+1)-d-1;
	for(int i=1;i<=q;++i)if(o[i]<=0)b[i]=lower_bound(d+1,d+c+1,b[i])-d;
	dfs(1,0),s(1,q,1,c);
	for(int i=1;i<=q;++i)if(o[i]>0)ans[i]==1?puts("invalid request!"):printf("%d\n",d[ans[i]]);
	return 0;
}
// 20:08 - 21:03
```

---

## 作者：mrsrz (赞：15)

题解里都是用数据结构或者整体二分搞的，都带$1\sim 4$只$\log$~~太神了写不动~~。其实这题可以带修树上莫队（模板见[WC2013糖果公园](https://www.luogu.org/problemnew/show/P4074)）。

其他的基本都是套路，关键是第$k$大怎么求。

考虑对权值进行分块（分块之前先离散化），记录当前区间内，每个元素的出现次数和每个块内的总元素个数。这个的修改是$O(1)$的。

然后，每次查询的时候，首先遍历所有块，找到第$k$大数所在的块，然后再遍历一遍这个块，找到第$k$大的数的具体值即可。单次查询为$O(\sqrt n)$。

总时间复杂度为带修莫队的$O(n^{\frac 5 3})$。

## Code：
```cpp
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>
#include<vector>
#define N 80008
#define blo 1888
#define P 400
struct istream{
    template<typename T>
    inline istream&operator>>(T&d){
        static int c;
        for(c=getchar();!isdigit(c);c=getchar());
        for(d=0;isdigit(c);c=getchar())
        d=(d<<3)+(d<<1)+(c&15);return*this;
    }
}cin;
std::vector<int>v;
struct edge{
    int to,nxt;
}e[N<<1];
struct que{
    int l,r,lca,tim,id,k;
    bool addlca;
    inline bool operator<(const que&rhs)const{
        return(l/blo!=rhs.l/blo)?(l<rhs.l):((r/blo!=rhs.r/blo)?r<rhs.r:tim<rhs.tim);
    }
}q[N];
struct tims{
    int id,to,from;
}T[N];
int n,Q,head[N],cntt=0,a[N],top[N],sz[N],dep[N],son[N],fa[N],idx=0,in[N],out[N],idfn[N<<1],ans[N];
int cnt[N];
int qs=0,tms=0;
int tot[166666],all[666],L[666],R[666],bel[166666];
void dfs(int now){
    sz[now]=1,son[now]=0;
    for(int i=head[now];i;i=e[i].nxt)
    if(!dep[e[i].to]){
        dep[e[i].to]=dep[now]+1;
        fa[e[i].to]=now;
        dfs(e[i].to);
        sz[now]+=sz[e[i].to];
        if(!son[now]||sz[son[now]]<sz[e[i].to])son[now]=e[i].to;
    }
}
void dfs2(int now){
    idfn[in[now]=++idx]=now;
    if(son[now])top[son[now]]=top[now],dfs2(son[now]);
    for(int i=head[now];i;i=e[i].nxt)
    if(e[i].to!=son[now]&&dep[e[i].to]>dep[now])dfs2(top[e[i].to]=e[i].to);
    idfn[out[now]=++idx]=now;
}
inline int LCA(int x,int y){
    while(top[x]!=top[y])
    if(dep[top[x]]>dep[top[y]])x=fa[top[x]];else y=fa[top[y]];
    return dep[x]<dep[y]?x:y;
}
void T_init(){
    static int b[N];
    memcpy(b,a,sizeof b);
    for(int i=1;i<=tms;++i){
        int&x=b[T[i].id];
        T[i].from=x;
        x=T[i].to;
    }
}
inline void BLOCK_init(){
    for(int i=1;i<=P;++i){
        L[i]=(i-1)*P+1,R[i]=i*P;
        for(int j=L[i];j<=R[i];++j)bel[j]=i;
    }
}
inline void ins(int id){
    ++tot[a[idfn[id]]];
    ++all[bel[a[idfn[id]]]];
}
inline void del(int id){
    --tot[a[idfn[id]]];
    --all[bel[a[idfn[id]]]];
}
int main(){
    v.push_back(-1);
    cin>>n>>Q;
    for(int i=1;i<=n;v.push_back(a[i++]))cin>>a[i];
    for(int i=1;i<n;++i){
        int u,v;cin>>u>>v;
        e[++cntt]=(edge){v,head[u]};head[u]=cntt;
        e[++cntt]=(edge){u,head[v]};head[v]=cntt;
    }
    dep[1]=1;
    dfs(1),dfs2(1);
    for(int i=1;i<=Q;++i){
        int k,l,r;
        cin>>k>>l>>r;
        if(k){
            ++qs;
            if(in[l]>in[r])std::swap(l,r);
            int&lca=q[qs].lca;lca=LCA(l,r);
            if(l==lca)l=in[l],r=in[r];else l=out[l],r=in[r],q[qs].addlca=1;
            q[qs].l=l,q[qs].r=r;
            q[qs].id=qs;
            q[qs].tim=tms;
            q[qs].k=k;
        }else{
            T[++tms]=(tims){l,r};
            v.push_back(r);
        }
    }
    std::sort(v.begin(),v.end());
    v.erase(std::unique(v.begin(),v.end()),v.end());
    for(int i=1;i<=n;++i)a[i]=std::lower_bound(v.begin(),v.end(),a[i])-v.begin();
    for(int i=1;i<=tms;++i)T[i].to=std::lower_bound(v.begin(),v.end(),T[i].to)-v.begin();
    T_init();
    BLOCK_init();
    std::sort(q+1,q+qs+1);
    int l=1,r=0,tim=0;
    for(int i=1;i<=qs;++i){
        while(tim<q[i].tim){
            ++tim;
            if(cnt[T[tim].id]==1){
                ++tot[T[tim].to];
                ++all[bel[T[tim].to]];
                --tot[T[tim].from];
                --all[bel[T[tim].from]];
            }
            a[T[tim].id]=T[tim].to;
        }
        while(tim>q[i].tim){
            if(cnt[T[tim].id]==1){
                --tot[T[tim].to];
                --all[bel[T[tim].to]];
                ++tot[T[tim].from];
                ++all[bel[T[tim].from]];
            }
            a[T[tim].id]=T[tim].from;
            --tim;
        }
        while(r<q[i].r)
        if(!cnt[idfn[++r]]++)ins(r);else del(r);
        while(r>q[i].r)
        if(!--cnt[idfn[r]])del(r--);else ins(r--);
        while(l>q[i].l)
        if(!cnt[idfn[--l]]++)ins(l);else del(l);
        while(l<q[i].l)
        if(!--cnt[idfn[l]])del(l++);else ins(l++);
        if(q[i].addlca)++tot[a[q[i].lca]],++all[bel[a[q[i].lca]]];
        int k=q[i].k,&s=ans[q[i].id];
        s=-1;
        for(int ii=P;ii;--ii)
        if(all[ii]<k)k-=all[ii];else{
            for(int j=R[ii];j>=L[ii];--j)
            if(tot[j]<k)k-=tot[j];else{
                s=j;break;
            }
            break;
        }
        if(q[i].addlca)--tot[a[q[i].lca]],--all[bel[a[q[i].lca]]];
    }
    for(int i=1;i<=qs;++i)
    if(ans[i]==-1)puts("invalid request!");else
    printf("%d\n",v[ans[i]]);
    return 0;
}

```

---

## 作者：MeteorFlower (赞：13)

[更好的阅读体验。](https://www.cnblogs.com/DRPLANT/p/P4175_solution.html)

前置知识：[P2633 Count on a tree](https://www.luogu.com.cn/problem/P2633) & [P2617 Dynamic Rankings](https://www.luogu.com.cn/problem/P2617) 。如果对本题一点思路都没有的话建议先做以上两题。

---

首先考虑如何在序列上实现本题操作，即单点修改区间 kth。如果不考虑修改的话可以直接用可持久化线段树做。那么现在的问题就是如何实现修改操作。如果暴力地做，则要对后缀中每个线段树进行修改，必 T。所以要对此进行优化。

回想一下 [【模板】可持久化线段树 2](https://www.luogu.com.cn/problem/P3834)。这道题我们在查询 $[l, r]$ 时并不单独在某棵线段树上面跑，而是将 $r$ 和 $l-1$ 的两棵线段树相减。把每棵线段树当做一个记录从 1 到 $i$ 这个前缀每个数字出现次数的集合，记作 $precnt_i$。把 $[l, r]$ 每个数字出现次数的集合记作 $cnt(l,r)$，则 $cnt(l,r)=precnt_r-precnt_{l-1}$。

可以发现这种形式就是查询前缀和再差分得到答案。由于树状数组在单点修改和查询前缀和上有着优秀的复杂度和常数，所以我们可以把线段树套在 BIT 里面。具体地，即每个 BIT 节点维护一个互不相交的（动态开点）线段树的根。

这种数据结构每次修改时使用类似 BIT 的方式，在 $\log$ 棵线段树上更新。查询时同样类似树状数组，首先记下 $l-1$ 和 $r$ 各自对应的 $\log$ 棵线段树，然后计算时用所有 $r$ 对应的线段树减去所有 $l-1$ 对应的线段树。

时间复杂度 $O(n \log^2 n)$。

核心代码如下。（为 [P2617 Dynamic Rankings](https://www.luogu.com.cn/problem/P2617) 代码片段。）

```cpp
// 这个代码现在看来太屎山了。但我懒得重构了，能过就行。
int query(vector<int> &r1, vector<int> &r2, int k, int left, int right) {
  int mid = (left + right) >> 1;
  if (left == right)
    return left;
  int left_val = 0;
  for (int it : r1)  //用所有 r 对应的线段树的当前节点的左儿子减去 l-1 对应的
    left_val -= (segTree[it].lson != -1 ? segTree[segTree[it].lson].val : 0);
  for (int it : r2)
    left_val += (segTree[it].lson != -1 ? segTree[segTree[it].lson].val : 0);
  if (left_val >= k) {
    for (int &it : r1) {
      if (segTree[it].lson == -1) {
        int new_id       = new_node();
        segTree[it].lson = new_id;
      }
      it = segTree[it].lson;
    }
    for (int &it : r2) {
      if (segTree[it].lson == -1) {
        int new_id       = new_node();
        segTree[it].lson = new_id;
      }
      it = segTree[it].lson;
    }
    return query(r1, r2, k, left, mid);
  } else {
    for (int &it : r1) {
      if (segTree[it].rson == -1) {
        int new_id       = new_node();
        segTree[it].rson = new_id;
      }
      it = segTree[it].rson;
    }
    for (int &it : r2) {
      if (segTree[it].rson == -1) {
        int new_id       = new_node();
        segTree[it].rson = new_id;
      }
      it = segTree[it].rson;
    }
    return query(r1, r2, k - left_val, mid + 1, right);
  }
}

void update(int r, int id, int up, int left, int right) {
  if (left == id && right == id) {
    segTree[r].val += up;
    return;
  }
  int mid = (left + right) >> 1;
  if (id <= mid) {
    if (segTree[r].lson == -1) {
      int new_id = new_node();
      segTree[r].lson = new_id;
    }
    update(segTree[r].lson, id, up, left, mid);
  } else {
    if (segTree[r].rson == -1) {
      int new_id      = new_node();
      segTree[r].rson = new_id;
    }
    update(segTree[r].rson, id, up, mid + 1, right);
  }
  segTree[r].val = (segTree[r].lson != -1 ? segTree[segTree[r].lson].val : 0) +
                   (segTree[r].rson != -1 ? segTree[segTree[r].rson].val : 0);
}

inline int QUERY(int l, int r, int k) {
  vector<int> r1, r2;  //存 l-1 和 r 各自对应的线段树。
  for (int i = l - 1; i; i -= lowbit(i))
    if (root[i] != -1)
      r1.push_back(root[i]);
  for (int i = r; i; i -= lowbit(i))
    if (root[i] != -1)
      r2.push_back(root[i]);
  return query(r1, r2, k, 1, kind);
}

inline void UPDATE(int id, int num, int up, int n) {
  for (int i = id; i <= n; i += lowbit(i)) {
    if (root[i] == -1)
      root[i] = new_node();
    update(root[i], num, up, 1, kind);
  }
}
```

---

现在只需要把上面的东西搬到树上就行了。实际上这个和在序列上是本质相同的。树上差分即可。设 $chain\_sum(a,b)$ 为从 $a$ 到 $b$ 的权值和，$sum_i$ 为从根节点到 $i$ 的权值和。由于树上差分的公式 $chain\_sum(a, b) = sum_a + sum_b - sum_{lca} - sum_{fa_{lca}}$。查询时用所有 $a$ 和 $b$ 对应的线段树减去 $lca$ 和 $fa_{lca}$ 对应的线段树。

注意修改时因为修改某个节点只会影响到自身及其子树，所以要消除对无关节点的影响。
为此需要求出每个节点的 DFS 序作为树状数组中的下标，使得每个节点及其子树中节点的下标在树状数组上是连续的，便于差分来消除对无关节点的影响。因为还要求 LCA，所以可用树链剖分实现这两个需求。

时间复杂度同上，为 $O(n \log^2 n)$。

Code：

```cpp
const int maxn = 80010;
int a[maxn], MAP[maxn << 1], kind;
struct OPERATION {
  int a, b, k;
} op[maxn];  //记录操作
vector<int> edge[maxn];
int fa[maxn], dep[maxn], Size[maxn], son[maxn];
int id[maxn], top[maxn], Index;

void dfs1(int u, int FA) {  //树剖。
  fa[u]   = FA;
  dep[u]  = dep[FA] + 1;
  Size[u] = 1;
  son[u]  = 0;
  for (int v : edge[u]) {
    if (v == FA)
      continue;
    dfs1(v, u);
    Size[u] += Size[v];
    if (Size[v] > Size[son[u]])
      son[u] = v;
  }
}
void dfs2(int u, int TOP) {
  id[u]  = ++Index;
  top[u] = TOP;
  if (!son[u])
    return;
  dfs2(son[u], TOP);
  for (int v : edge[u]) {
    if (v == fa[u] || v == son[u])
      continue;
    dfs2(v, v);
  }
}
inline int get_LCA(int a, int b) {
  while (top[a] != top[b]) {
    if (dep[top[a]] < dep[top[b]])
      swap(a, b);
    a = fa[top[a]];
  }
  return dep[a] < dep[b] ? a : b;
}
void disc(int MAP[], int n, int q, int len, int &m) {  //离散化。
  sort(MAP + 1, MAP + len + 1);
  m = unique(MAP + 1, MAP + len + 1) - (MAP + 1);
  for (int i = 1; i <= n; i++)
    a[i] = lower_bound(MAP + 1, MAP + m + 1, a[i]) - MAP;
  for (int i = 1; i <= q; i++)
    if (!op[i].k)
      op[i].b = lower_bound(MAP + 1, MAP + m + 1, op[i].b) - MAP;
}

inline int lowbit(int x) {
  return x & (-x);
}
struct segTreeType {
  struct segTreeNode {
    int val;
    int lson, rson;
    segTreeNode() {
      lson = rson = -1, val = 0;
    }
  };
  vector<segTreeNode> segTree;
  int root[maxn];
  segTreeType() {
    memset(root, -1, sizeof(root));
  }
  inline int new_node() {
    segTree.push_back(segTreeNode());
    return segTree.size() - 1;
  }
  void change_to_lson(vector<int> &r) {
    for (int &it : r) {
      if (segTree[it].lson == -1) {
        int new_id       = new_node();
        segTree[it].lson = new_id;
      }
      it = segTree[it].lson;
    }
  }
  template <class T, class... Args>
  void change_to_lson(T &head, Args &...args) {
    change_to_lson(head), change_to_lson(args...);
  }
  void change_to_rson(vector<int> &r) {
    for (int &it : r) {
      if (segTree[it].rson == -1) {
        int new_id       = new_node();
        segTree[it].rson = new_id;
      }
      it = segTree[it].rson;
    }
  }
  template <class T, class... Args>
  void change_to_rson(T &head, Args &...args) {
    change_to_rson(head), change_to_rson(args...);
  }

  int query(vector<int> &r1, vector<int> &r2, vector<int> &r3, vector<int> &r4, int k, int left, int right) {
    int mid = (left + right) >> 1;
    if (left == right) {
      int val = 0;  //要判断个数能否满足要求（>=k），<k 则无解。
      for (int it : r1)
        val += segTree[it].val;
      for (int it : r2)
        val += segTree[it].val;
      for (int it : r3)
        val -= segTree[it].val;
      for (int it : r4)
        val -= segTree[it].val;
      if (k <= val)
        return left;
      return -1;
    }
    int right_val = 0;
    for (int it : r1)  //因为本题求第 k “大”值所以要把前一份代码中的左儿子改成右儿子。
      right_val += (segTree[it].rson != -1 ? segTree[segTree[it].rson].val : 0);
    for (int it : r2)
      right_val += (segTree[it].rson != -1 ? segTree[segTree[it].rson].val : 0);
    for (int it : r3)
      right_val -= (segTree[it].rson != -1 ? segTree[segTree[it].rson].val : 0);
    for (int it : r4)
      right_val -= (segTree[it].rson != -1 ? segTree[segTree[it].rson].val : 0);
    if (right_val >= k) {
      change_to_rson(r1, r2, r3, r4);
      return query(r1, r2, r3, r4, k, mid + 1, right);
    } else {
      change_to_lson(r1, r2, r3, r4);
      return query(r1, r2, r3, r4, k - right_val, left, mid);
    }
  }
  void update(int r, int id, int up, int left, int right) {
    if (left == id && right == id) {
      segTree[r].val += up;
      return;
    }
    int mid = (left + right) >> 1;
    if (id <= mid) {
      if (segTree[r].lson == -1) {
        int new_id      = new_node();
        segTree[r].lson = new_id;
      }
      update(segTree[r].lson, id, up, left, mid);
    } else {
      if (segTree[r].rson == -1) {
        int new_id      = new_node();
        segTree[r].rson = new_id;
      }
      update(segTree[r].rson, id, up, mid + 1, right);
    }
    segTree[r].val = (segTree[r].lson != -1 ? segTree[segTree[r].lson].val : 0) +
                     (segTree[r].rson != -1 ? segTree[segTree[r].rson].val : 0);
  }

  inline int QUERY(int a, int b, int k) {  //要注意用 DFS 序作为下标而不是原本编号。
    vector<int> r1, r2, r3, r4;
    int lca = get_LCA(a, b), lcafa = fa[lca];
    for (int i = id[a]; i; i -= lowbit(i))
      if (root[i] != -1)
        r1.push_back(root[i]);
    for (int i = id[b]; i; i -= lowbit(i))
      if (root[i] != -1)
        r2.push_back(root[i]);
    for (int i = id[lca]; i; i -= lowbit(i))
      if (root[i] != -1)
        r3.push_back(root[i]);
    for (int i = id[lcafa]; i; i -= lowbit(i))
      if (root[i] != -1)
        r4.push_back(root[i]);
    return query(r1, r2, r3, r4, k, 1, kind);
  }

  inline void UPDATE(int id, int num, int up, int n) {
    for (int i = id; i <= n; i += lowbit(i)) {
      if (root[i] == -1)
        root[i] = new_node();
      update(root[i], num, up, 1, kind);
    }
  }
} segTree;

int main() {
  int n, q, len = 0;
  in(n, q);
  for (int i = 1; i <= n; i++)
    in(a[i]), MAP[++len] = a[i];
  for (int i = 1; i < n; i++) {
    int a, b;
    in(a, b);
    edge[a].push_back(b);
    edge[b].push_back(a);
  }
  for (int i = 1; i <= q; i++) {
    in(op[i].k, op[i].a, op[i].b);
    if (!op[i].k)
      MAP[++len] = op[i].b;
  }
  disc(MAP, n, q, len, kind);
  dfs1(1, 0);
  dfs2(1, 1);

  for (int i = 1; i <= n; i++)
    segTree.UPDATE(id[i], a[i], 1, n), segTree.UPDATE(id[i] + Size[i], a[i], -1, n);  //要消除对无关节点影响。
  for (int i = 1; i <= q; i++) {
    if (op[i].k) {
      int res = segTree.QUERY(op[i].a, op[i].b, op[i].k);
      if (res != -1)
        out(MAP[res]), enter;
      else
        puts("invalid request!");
    } else {
      segTree.UPDATE(id[op[i].a], a[op[i].a], -1, n);
      segTree.UPDATE(id[op[i].a] + Size[op[i].a], a[op[i].a], 1, n);
      a[op[i].a] = op[i].b;
      segTree.UPDATE(id[op[i].a], a[op[i].a], 1, n);
      segTree.UPDATE(id[op[i].a] + Size[op[i].a], a[op[i].a], -1, n);
    }
  }
}
```
UPD：修改部分描述使其更加严谨。


---

## 作者：DefFrancis (赞：10)

终于把3个月前咕掉的数据结构体补了，~~实际上是我写的树套树常数太大40分没得卡进去~~，然而再次写的时候还是花了1.5小时码代码+0.5小时多的debug。

看到没有整体二分的题解，

于是过来发一下qaq。

### Solution

观察到题目没有要求在线，且问题是，

类似于单点修改，区间查询第K大的样子。

考虑整体二分。（什么？你告诉我不会整体二分qaq，自行右转主席树题解）

类似于[Dynamic Rankings](https://www.luogu.org/problemnew/show/P2617)

对于一个修改操作，我们拆成两个操作，

```cpp
q[++tot]=(node){0,-1,val[y],y,1};//加一个减去原先贡献的操作
val[y]=z;//val[i]表示i的点权，修改
q[++tot]=(node){0,1,val[y],y,1};
```

但是这道题是树上的问题...

**树剖！**

树剖肯定是要的，这辈子都不会抛弃树剖的。

主席树又不会，只能打打树剖才能转换为区间上的问题的样子呢。

qaq

于是就可以按照整体二分的套路愉快的写下去了！~~（实际上就变成了板子题..）~~

时间复杂度$O(nlog^3n)$

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
//struct Tree_Chain;
inline int read(){
    char c=getchar();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int maxn=5e5+10;
struct E{
    int next,to;
}tu[maxn*2];
int head[maxn],cnt,tot;
int n,m,qwq;
long long val[maxn];
void add(int next,int to){
    tu[cnt].next=head[next];
    tu[cnt].to=to;
    head[next]=cnt++;
}
int top[maxn],rnk[maxn],sz[maxn],son[maxn],fa[maxn],tid[maxn],dep[maxn],tim;
void dfs1(int x,int father,int deep){//树剖
    sz[x]=1;
    fa[x]=father;
    dep[x]=deep;
    for(int i=head[x];~i;i=tu[i].next){
        int u=tu[i].to;
        if(u==father)continue;
        dfs1(u,x,deep+1);
        sz[x]+=sz[u];
        if(son[x]==-1||sz[son[x]]<sz[u]){
            son[x]=u;
        }
    }
}
void dfs2(int x,int tp){
    top[x]=tp;
    tid[x]=++tim;
    rnk[tim]=x;
    if(son[x]==-1)return;
    dfs2(son[x],tp);
    for(int i=head[x];~i;i=tu[i].next){
        int u=tu[i].to;
        if(u==fa[x]||u==son[x])continue;
        dfs2(u,u);
    }
}
int sumv[maxn*4];//线段树
#define lson (o<<1)
#define rson (o<<1|1)
void pushup(int o){
    sumv[o]=sumv[lson]+sumv[rson];
}
void change(int o,int l,int r,int x,int v){
    if(l==r){
        sumv[o]+=v;
        return;
    }
    int mid=(l+r)>>1;
    if(x<=mid)change(lson,l,mid,x,v);
    else change(rson,mid+1,r,x,v);
    pushup(o);
}
int query(int o,int l,int r,int l1,int r1){
    if(l>=l1&&r<=r1){
        return sumv[o];
    }
    if(l>r1||r<l1)return 0;
    int mid=(l+r)>>1;
    return query(lson,l,mid,l1,r1)+query(rson,mid+1,r,l1,r1);
}
int query_path(int x,int y){
    int ans=0;
    while(top[x]!=top[y]){
        if(dep[top[x]]<dep[top[y]])swap(x,y);
        ans+=query(1,1,n,tid[top[x]],tid[x]);
        x=fa[top[x]];
    }
    if(tid[x]>tid[y])swap(x,y);
    ans+=query(1,1,n,tid[x],tid[y]);
    return ans;
}//树剖
struct node{
    long long x,y,k,id,type;
}q[maxn],q1[maxn],q2[maxn];
long long ans[maxn];
void solve(int L,int R,int l,int r){//q1表示答案在l~mid，q2表示答案在mid+1~r内
    if(L>R)return;
    if(l==r){
        for(int i=L;i<=R;i++)if(q[i].type==2)ans[q[i].id]=l;
        return;
    }
    int mid=(l+r)>>1;
    int cnt1=0,cnt2=0;
    for(int i=L;i<=R;i++){
        if(q[i].type==1){
            if(q[i].k>mid){
                change(1,1,n,tid[q[i].id],q[i].y);
                q2[++cnt2]=q[i];
            }
            else q1[++cnt1]=q[i];
        }
        else{
            int ret=query_path(q[i].x,q[i].y);
            if(ret>=q[i].k)q2[++cnt2]=q[i];//大于mid的数字个数>=q[i].k，说明实际答案比mid大
            else{
                q[i].k-=ret;//减去贡献
                q1[++cnt1]=q[i];
            }
        }
    }
    for(int i=1;i<=cnt2;i++){
        if(q2[i].type==1)change(1,1,n,tid[q2[i].id],-q2[i].y);
    }//清除
    for(int i=1;i<=cnt1;i++)q[L+i-1]=q1[i];
    for(int i=1;i<=cnt2;i++)q[L+cnt1+i-1]=q2[i];
    solve(L,L+cnt1-1,l,mid);
    solve(L+cnt1,R,mid+1,r);
}//整体二分
int num;
long long a[maxn],map_rnk[maxn],pos;//a数组用来存将要被离散化的数字,pos存询问个数...很乱sry
int main(){
    memset(head,-1,sizeof(head));
    memset(son,-1,sizeof(son));
    n=read(),m=read();
    for(int i=1;i<=n;i++){
        val[i]=read();
        q[++tot]=(node){0,1,val[i],i,1};
        a[++num]=val[i];
    }
    for(int i=1;i<n;i++){
        int x=read(),y=read();
        add(x,y);
        add(y,x);
    }
    dfs1(1,0,0);
    dfs2(1,1);
    for(int i=1;i<=m;i++){
        int x=read(),y=read(),z=read();
        if(x==0){
            q[++tot]=(node){0,-1,val[y],y,1};
            val[y]=z;
            q[++tot]=(node){0,1,val[y],y,1};
            a[++num]=z;
        }
        else{
            q[++tot]=(node){y,z,x,++pos,2};//贼坑的数据输入格式...
        }
    }/*以下为离散化*/
    sort(a+1,a+1+num);
    int qaq=unique(a+1,a+1+num)-a-1;
    for(int i=1;i<=tot;i++)
        if(q[i].type!=2){
            int tmp=lower_bound(a+1,a+1+qaq,q[i].k)-a;
            map_rnk[tmp]=q[i].k;
            q[i].k=tmp;
        }
    solve(1,tot,0,qaq+1);
    for(int i=1;i<=pos;i++){
        if(ans[i]==0)puts("invalid request!");
        else printf("%lld\n",map_rnk[ans[i]]);
    }
    return 0;
}
```

用线段树比较方便~~实际上是我树状数组写锅了~~

---

## 作者：GKxx (赞：8)

既然大家都说有$4$个$log$的做法，那我就来补一发题解跟上吧。

没有什么花样，二分答案+树剖+树套树。这里的树套树我写的是树状数组套值域线段树，尽量让常数小一点（而且也比splay好打）

然而我一开始这样交上去是T了第6个点的，开了O2也T

同时因为一些睿智原因我还WA了第9个点

我一算复杂度4个log，感觉跟一个n差别不大啊。。。

要不我写个询问$O(n)$的暴力交上去看看？

（暴力的写法就是$O(n)$把路径上的点全都取出来，然后用STL的std::nth_element即可，复杂度也是$O(n)$）

事实证明差别还是很大的，暴力只过了第1和6两个点。

冷静分析，我意识到第6个点必有玄机。

于是我把两个程序拼在了一起。设$all$是值域大小，每次回答询问的时候先数一下路径上一共多少个结点，设为$cnt$

如果$c*cnt<log^2(all)*log^2(n)$，就跑暴力，否则就跑4个log。其中$c$是常数，我取7取10都试了一下差不多，但是取小了就会T成完全暴力

## 没开O2过了，你没有看错

```cpp
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>
#include <cmath>
#include <functional>

template <typename T> inline void read(T& t) {
    int f = 0, c = getchar(); t = 0;
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) t = t * 10 + c - 48, c = getchar();
    if (f) t = -t;
}
template <typename T, typename... Args>
inline void read(T& t, Args&... args) {
    read(t); read(args...);
}
template <typename T> inline bool chkMin(T& x, const T& y) { return y < x ? (x = y, true) : false; }
template <typename T> inline bool chkMax(T& x, const T& y) { return x < y ? (x = y, true) : false; }

#ifdef WIN32
#define LLIO "%I64d"
#else
#define LLIO "%lld"
#endif	// WIN32 long long
#define rep(I, A, B) for (int I = (A); I <= (B); ++I)
#define rrep(I, A, B) for (int I = (A); I >= (B); --I)
#define erep(I, X) for (int I = head[X]; I; I = next[I])

const int maxn = 8e4 + 207;
int v[maxn << 1], head[maxn], next[maxn << 1], a[maxn];
int dep[maxn], son[maxn], top[maxn], size[maxn], fa[maxn], dfn[maxn], b[maxn];
int n, m, etot, xys;

inline void ae(int x, int y) {
    v[++etot] = y; next[etot] = head[x]; head[x] = etot;
    v[++etot] = x; next[etot] = head[y]; head[y] = etot;
}
void dfs(int x) {
    size[x] = 1; dep[x] = dep[fa[x]] + 1;
    erep(i, x) if (v[i] ^ fa[x]) {
        fa[v[i]] = x;
        dfs(v[i]);
        size[x] += size[v[i]];
        if (size[v[i]] > size[son[x]]) son[x] = v[i];
    }
}
void dfs(int x, int t) {
    top[x] = t; dfn[x] = ++xys; b[xys] = a[x];
    if (son[x]) dfs(son[x], t);
    erep(i, x) if (v[i] ^ fa[x] && v[i] ^ son[x])
        dfs(v[i], v[i]);
}

int sum[maxn << 8], left[maxn << 8], right[maxn << 8];
int tot, all, logall, logn;

void insert(int &curr, int l, int r, int pos, int val) {
    if (!curr) curr = ++tot;
    sum[curr] += val;
    if (l == r) return;
    int mid = (l + r) >> 1;
    if (pos <= mid) insert(left[curr], l, mid, pos, val);
    else insert(right[curr], mid + 1, r, pos, val);
}
int querySum(int curr, int lb, int rb, int l, int r) {
    if (!curr || l > rb || r < lb) return 0;
    if (l <= lb && r >= rb) return sum[curr];
    int mid = (lb + rb) >> 1;
    return querySum(left[curr], lb, mid, l, r) + querySum(right[curr], mid + 1, rb, l, r);
}

int root[maxn];
inline int greaterBit(int l, int r, int x) {
    int ret = 0;
    for (; r; r -= r & -r) ret += querySum(root[r], 0, all, x + 1, all);
    for (--l; l; l -= l & -l) ret -= querySum(root[l], 0, all, x + 1, all);
    return ret;
}
inline void modify(int x, int val, int cnt) {
    for (; x <= n; x += x & -x) insert(root[x], 0, all, val, cnt);
}

inline void modify(int x, int y) {
    int ov = b[dfn[x]];
    a[x] = b[dfn[x]] = y;
    modify(dfn[x], ov, -1);
    modify(dfn[x], y, 1);
}
inline int queryGreater(int x, int y, int val) {
    int ans = 0;
    while (top[x] != top[y]) {
        if (dep[top[x]] < dep[top[y]]) {
            ans += greaterBit(dfn[top[y]], dfn[y], val);
            y = fa[top[y]];
        } else {
            ans += greaterBit(dfn[top[x]], dfn[x], val);
            x = fa[top[x]];
        }
    }
    if (dep[x] < dep[y]) ans += greaterBit(dfn[x], dfn[y], val);
    else ans += greaterBit(dfn[y], dfn[x], val);
    return ans;
}
inline int lca(int x, int y) {
    if (x == y) return x;
    while (top[x] != top[y]) {
        if (dep[top[x]] < dep[top[y]]) y = fa[top[y]];
        else x = fa[top[x]];
    }
    return dep[x] < dep[y] ? x : y;
}
int tmp[maxn];
inline int force(int x, int y, int l, int k) {
    int tp = 0;
    for (; x ^ l; x = fa[x]) tmp[++tp] = a[x];
    for (; y ^ l; y = fa[y]) tmp[++tp] = a[y];
    tmp[++tp] = a[l];
    std::nth_element(tmp + 1, tmp + k, tmp + tp + 1, std::greater<int>());
    return tmp[k];
}
inline int queryKth(int x, int y, int k) {
    int l = lca(x, y);
    int cnt = dep[x] + dep[y] - 2 * dep[l] + 1;
    if (cnt < k) return -1;
    if (10 * cnt < logall * logall * logn * logn) return force(x, y, l, k);
    int left = 0, right = all;
    while (left <= right) {
        int mid = (left + right) >> 1;
        int g = queryGreater(x, y, mid);
        if (g < k) right = mid - 1;
        else left = mid + 1;
    }
    return right + 1;
}

struct Query {
    int k, x, y;
};
Query qs[maxn];

int main() {
    read(n, m);
    rep(i, 1, n) read(a[i]), chkMax(all, a[i]);
    rep(i, 1, n - 1) {
        int x, y; read(x, y); ae(x, y);
    }
    rep(i, 1, m) {
        read(qs[i].k, qs[i].x, qs[i].y);
        if (!qs[i].k) chkMax(all, qs[i].y);
    }
    ++all;
    double lg2 = log(2);
    logn = log(n) / lg2;
    logall = log(all) / lg2;
    dfs(1); dfs(1, 1);
    rep(i, 1, n) modify(i, b[i], 1);
    rep(i, 1, m) {
        int k = qs[i].k, x = qs[i].x, y = qs[i].y;
        if (!k) modify(x, y);
        else {
            int ans = queryKth(x, y, k);
            if (~ans) printf("%d\n", ans);
            else puts("invalid request!");
        }
    }
    return 0;
}
```

---

## 作者：jiqimao (赞：7)

一些套路的综合应用:

要求第k大,主席树。

要查两点间路径,处理到根的前缀和,求出lca后差分。

要带修,发现每次改的是子树。那么可以考虑dfs序,就成了每次改区间。

改区间,再差分一下就成了单点修改查询前缀。直接上树套树即可。

(其实写这篇题解是因为被我自己写的树套树优美到了,谁说树套树只能恶心码量大?)
```c++
#include<bits/stdc++.h>
using namespace std;
const int N=8e4+50,M=2e7+50,K=1e8;
int n,q,a[N],ver[N*2],nxt[N*2],head[N],tot,f[N][17],d[N],dfn[N],rr[N],cnt,r[N];
int lc[M],rc[M],sum[M];
struct node{
    int n,a[N];
    int calc(){int ret=0;for(int i=1;i<=n;i++)ret+=sum[rc[a[i]]];return ret;}
    void L(){for(int i=1;i<=n;i++)a[i]=lc[a[i]];}
    void R(){for(int i=1;i<=n;i++)a[i]=rc[a[i]];}
    void init(int x){n=0;for(;x;x-=x&-x)a[++n]=r[x];}
}A,B,C,D;
int in(){
    int x=0,c;
    while(!isdigit(c=getchar()));
    while(isdigit(c))x=x*10+(c^48),c=getchar();
    return x;
}
void add(int x,int y){ver[++tot]=y;nxt[tot]=head[x];head[x]=tot;}
void dfs(int x,int ff){
    f[x][0]=ff;d[x]=d[ff]+1;dfn[x]=++cnt;
    for(int i=0;i<16;i++)f[x][i+1]=f[f[x][i]][i];
    for(int i=head[x],y;i;i=nxt[i])if((y=ver[i])!=ff)dfs(y,x);
    rr[x]=cnt;
}
int lca(int x,int y){
    if(d[x]<d[y])swap(x,y);
    for(int i=16;~i;i--)if(d[f[x][i]]>=d[y])x=f[x][i];
    if(x==y)return x;
    for(int i=16;~i;i--)if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];
    return f[x][0];
}
void change(int &x,int l,int r,int p,int d){
    if(!x)x=++cnt;sum[x]+=d;
    if(l==r)return;int mid=(l+r)>>1;
    if(p<=mid)change(lc[x],l,mid,p,d);
    else change(rc[x],mid+1,r,p,d);
}
void change(int x,int p,int d){for(;x<=n;x+=x&-x)change(r[x],1,K,p,d);}
int query(int l,int r,int d){
    if(l==r)return l;
    int mid=(l+r)>>1,dat=A.calc()+B.calc()-C.calc()-D.calc();
    if(dat>=d){A.R(),B.R(),C.R(),D.R();return query(mid+1,r,d);}
    A.L(),B.L(),C.L(),D.L();return query(l,mid,d-dat);
}
int main(){
    n=in();q=in();
    for(int i=1;i<=n;i++)a[i]=in();
    for(int i=1,x,y;i<n;i++)add(x=in(),y=in()),add(y,x);
    dfs(1,0);cnt=0;
    for(int i=1;i<=n;i++)change(dfn[i],a[i],1),change(rr[i]+1,a[i],-1);
    for(int i=1,k,x,y;i<=q;i++){
        k=in();x=in();y=in();
        if(k){
            int z=lca(x,y);if(d[x]+d[y]-2*d[z]+1<k){puts("invalid request!");continue;}
            A.init(dfn[x]);B.init(dfn[y]);C.init(dfn[z]);D.init(dfn[f[z][0]]);
            printf("%d\n",query(1,K,k));
        }
        else change(dfn[x],a[x],-1),change(rr[x]+1,a[x],1),change(dfn[x],a[x]=y,1),change(rr[x]+1,y,-1);
    }
    return 0;
}
```


---

## 作者：Limit (赞：6)

# 题目大意

给出一棵树,每个点有一个权值,支持查询树链上第 $k$ 大数和单点修改.

# 分析

先把修改操作去掉开始([题目](https://www.luogu.com.cn/problem/P2633)),不带修改树链第 $k$ 大,要查询第 $k$ 大就很容易想到用一些数据结构维护(~~废话~~),例如权值线段树,平衡树等等.

先从一个看似不相关的问题开始考虑,计算一条树链上所有数的和需要怎么办?

很显然这个东西可以树剖一下,再用前缀和优化,可以做到 $\mathcal{O}(log_2N)$ 的时间复杂度单词查询.

用这个方法做这道题可以想到树剖之后用主席树维护在DFS序中前缀每个数出现次数,再可以计算区间每个数出现次数,找出这条树链中的的每一段计算的区间的开和结尾的主席树根节点编号,再通过类似前缀和计算区间和的方法计算,在树上二分查询第 $k$ 大数,查询时间复杂度变为 $\mathcal{O}(log_2^2N)$.

但是上面这个方法并不是很优秀,可以再结合容斥的思想,$sum_i$ 表示第 $i$ 个节点到根节点这一条链上所有数的和,那么一条 $u$ 到 $v$ 树链的和就可以表示为 $sum_u+sum_v-sum_{LCA(u,v)}*2+val_{LCA(u,v)}$,其中 $-sum_{LCA(u,v)}+val_{LCA(u,v)}$ 可以表示为 $sum_{father_{LCA(u,v)}}$.

通过上面这个方法可以想到用主席树维护每个节点到根节点这一条链上面每个数出现的次数,最后只需要将这样四颗主席树进行加减就可以直接在树上二分,时间复杂度是 $\mathcal{O}(log_2N)$ 的.

再回到本题,本题有修改,但是主席树显然是没法直接做到修改的.那么可以从每个修改所造成的影响来看,仍然用权值线段树维护每个节点到根节点这一条树链上每个数出现的次数,那么如果一个点的值消失会造成的影响只会在以这个点为根节点的子树中,它的每一个子节点(包括自己)的权值线段树中减去 $val_{now}$,添加一个数同理加上.

那么问题就变成了如何给一颗子树加上一个值,在DFS序中,每一颗子树的节点的编号都是连续的,所以就变成了区间加,然后树状数组维护一下就好了.

# 代码

```cpp
#include<bits/stdc++.h>
#define REP(i,first,last) for(int i=first;i<=last;++i)
#define DOW(i,first,last) for(int i=first;i>=last;--i)
using namespace std;
const int MAXN=4e5+7;
const int MAX_NUM=1e8;
int N,M,val[MAXN];
int edge_head[MAXN];
int edge_cnt=0;
struct Edge
{
	int to,next;
}edge[MAXN];
#define FOR(now) for(int i_edge=edge_head[now];i_edge;i_edge=edge[i_edge].next)
#define TO edge[i_edge].to
void AddEdge(int form,int to)
{
	edge[++edge_cnt].to=to;
	edge[edge_cnt].next=edge_head[form];
	edge_head[form]=edge_cnt;
}

int kth_father[MAXN][25];//比较懒,直接用了倍增LCA,一个裸的LCA,如果不
bool visit[MAXN];
int deep[MAXN],father[MAXN];
int tree_size[MAXN];
int dfs[MAXN],dfs_cnt=0;
int id[MAXN];
void DFS(int now)
{
	deep[now]=deep[father[now]]+1;
	kth_father[now][0]=father[now];
	tree_size[now]=1;//需要记录子树大小
	dfs[++dfs_cnt]=now;//记录下dfs序
	id[now]=dfs_cnt;
	REP(i,0,22)
	{
		kth_father[now][i+1]=kth_father[kth_father[now][i]][i];
	}
	FOR(now)
	{
		if(father[now]!=TO)
		{
			father[TO]=now;
			DFS(TO);
			tree_size[now]+=tree_size[TO];
		}
	}
}
int LCA(int x,int y)
{
	if(deep[x]<deep[y])
	{
		swap(x,y);
	}
	DOW(i,22,0)
	{
		if(deep[kth_father[x][i]]>=deep[y])
		{
			x=kth_father[x][i];
		}
		if(x==y)
		{
			return x;
		}
	}
	DOW(i,22,0)
	{
		if(kth_father[x][i]!=kth_father[y][i])
		{
			x=kth_father[x][i];
			y=kth_father[y][i];
		}
	}
	return father[x];
}
struct SegmentTree//线段树部分
{
	int sum,lson,rson;
}sgt[MAXN*32];
int sgt_cnt=0;
int root[MAXN];
int Lowbit(int now)
{
	return now&-now;
}
#define LSON sgt[now].lson
#define RSON sgt[now].rson
#define MIDDLE ((left+right)>>1)
#define LEFT LSON,left,MIDDLE
#define RIGHT RSON,MIDDLE+1,right
void PushUp(int now)
{
	sgt[now].sum=sgt[LSON].sum+sgt[RSON].sum;
}
void Updata(int num,int val,int &now,int left=1,int right=MAX_NUM)//修改操作不多说了
{
	if(num<left||right<num)
	{
		return;
	}
	if(!now)
	{
		now=++sgt_cnt;
	}
	if(left==right)
	{
		sgt[now].sum+=val;
		return;
	}
	Updata(num,val,LEFT);
	Updata(num,val,RIGHT);
	PushUp(now);
}
void Change(int p,int w,int check=1)//替换操作
{
	int left=id[p],right=id[p]+tree_size[p]-1;//计算开始和结束位置
	if(check)//开始加数时不需要删数
	{
		for(int i=left;i<=N;i+=Lowbit(i))//将这个数删去,同区间修改树状数组
		{
			Updata(val[p],-1,root[i]);
		}
		for(int i=right+1;i<=N;i+=Lowbit(i))
		{
			Updata(val[p],1,root[i]);
		}
		val[p]=w;
	}
	for(int i=left;i<=N;i+=Lowbit(i))//同理加上新的数
	{
		Updata(val[p],1,root[i]);
	}
	for(int i=right+1;i<=N;i+=Lowbit(i))
	{
		Updata(val[p],-1,root[i]);
	}
}
int add_cnt;
int dec_cnt;
int add_root[MAXN];//记录加上/删掉的树的当前节点
int dec_root[MAXN];
int GetSum()//计算当前范围的数的个数
{
	int result=0;
	REP(i,1,add_cnt)
	{
		result+=sgt[add_root[i]].sum;
	}
	REP(i,1,dec_cnt)
	{
		result-=sgt[dec_root[i]].sum;
	}
	return result;
}
int GetSumRight()//计算右子树的数的个数
{
	int result=0;
	REP(i,1,add_cnt)
	{
		result+=sgt[sgt[add_root[i]].rson].sum;
	}
	REP(i,1,dec_cnt)
	{
		result-=sgt[sgt[dec_root[i]].rson].sum;
	}
	return result;
}
void GetRootLeft()//将当前节点变为右子节点
{
	REP(i,1,add_cnt)
	{
		add_root[i]=sgt[add_root[i]].lson;
	}
	REP(i,1,dec_cnt)
	{
		dec_root[i]=sgt[dec_root[i]].lson;
	}
}
void GetRootRight()//变为左子节点
{
	REP(i,1,add_cnt)
	{
		add_root[i]=sgt[add_root[i]].rson;
	}
	REP(i,1,dec_cnt)
	{
		dec_root[i]=sgt[dec_root[i]].rson;
	}
}
int QueryKth(int k,int left=1,int right=MAX_NUM)//查询部分
{
	if(left==right)
	{
		return left;
	}
	int sum=GetSumRight();
	if(sum>=k)//如果右边够就查询右边
	{
		GetRootRight();
		return QueryKth(k,MIDDLE+1,right);
	}
	GetRootLeft();
	return QueryKth(k-sum/*需要减去右子树中数的个数*/,left,MIDDLE);
}
void Kth(int u,int v,int k)
{
	int lca=LCA(u,v);
	//按公式计算
	int add_1=id[u];
	int add_2=id[v];
	int dec_1=id[lca];
	int dec_2=id[father[lca]];
	add_cnt=0;
	dec_cnt=0;
	for(int i=add_1;i;i-=Lowbit(i))
	{
		add_root[++add_cnt]=root[i];
	}
	for(int i=add_2;i;i-=Lowbit(i))
	{
		add_root[++add_cnt]=root[i];
	}
	for(int i=dec_1;i;i-=Lowbit(i))
	{
		dec_root[++dec_cnt]=root[i];
	}
	for(int i=dec_2;i;i-=Lowbit(i))
	{
		dec_root[++dec_cnt]=root[i];
	}
	if(GetSum()<k)//如果总共也没有k就是不存在
	{
		printf("invalid request!\n");
		return;
	}
	printf("%d\n",QueryKth(k));
}
int main()
{
	scanf("%d%d",&N,&M);
	REP(i,1,N)
	{
		scanf("%d",&val[i]);
	}
	int fa,son;
	REP(i,1,N-1)
	{
		scanf("%d%d",&fa,&son);
		AddEdge(fa,son);
		AddEdge(son,fa);
	}
	DFS(1);//处理树上的信息
	REP(i,1,N)//把数加入
	{
		Change(i,val[i],0);
	}
	int k,x,y;
	REP(i,1,M)
	{
		scanf("%d%d%d",&k,&x,&y);
		if(k==0)
		{
			Change(x,y);//修改
		}
		if(k)
		{
			Kth(x,y,k);//查询
		}
	}
	return 0;
}
```

---

## 作者：Juan_feng (赞：5)

一万年了。

小蒟蒻Jf终于更博啦>_<  


感觉自己已经彻底变成一个鸽子了呢qwq。  

———————————————以上是闲话—————————————————————————

## 这里提供一个树分块的题解。 其时间复杂度为(m+n) sqrt (n)  空间复杂度为n sqrt (n)

**前置芝士**： O1lca(这个挺基础的吧)  值域分块（可以参考[小蒟蒻之前的blog](https://www.luogu.org/blog/Juan-feng/solution-p3834)）

那么废话不多说， 直接开始讲实现方法。

在树上选出T个关键点（选取的方法和性质后面会说）， 在把这些关键点之间的LCA也设成关键点，然后将值域分块，处理出这些关键点到根的路径中的一些信息： 
> cnt1（i, j）表示第i个关键点到根的路径中， 权值在第j个值域块中的点的数量
 
> cnt2（i, j) 表示第i个关键点到根的路径中， 权值为j的点的数量

显然上面的两个数组可以在T * n 的时间内处理完成。  然后关于这T个点的选取， 我们想让其拥有这样的性质： 从树上的任何一个点出发向根跳最多跳T*(常数）次就可以跳到一个关键点。

显然可以通过贪心来选取这T个点， 然后小Jf比较懒， 就随机了T个点， 据某毒瘤说复杂度也是正确的qwq。（贪心的具体方法本文不进行具体介绍， 可以参考2015年邹逍遥的国家集训队论文）

有了上面的性质， 问题就简单了。  我们先对树进行染色。 将树上向根上跳**第一个**遇到的**关键点相同**的**点** 染上相同的颜色。 那么对于询问x，y，k。 如果xy的颜色**相同**， 那么显然可以在O（T）的实现内暴力进行查询（记录下路径上经过的点用值域分块进行查询）。  对于颜色**不同**的x，y， 我们可以进行如下的讨论：

![pic1.jpg](https://i.loli.net/2019/08/19/ELoWRh9za7f6TDN.png)

情况1: 如上图，记x的颜色为xx， y的颜色为yy， xx和yy并非祖先-后代关系。 这种情况是最简单的， 直接处理一下散块（x到xx， y到yy)的信息（蓝色） 然后xx到yy的信息（红色） 可以通过**xx到根的信息** + **yy到根的信息** - **2*lca(xx, yy)到根的信息** 来得到。 然后值域分块来求k大就可以了。


![pic2.png](https://i.loli.net/2019/08/19/YJyUZRCelbtjOrq.png)


情况2：如上图，记x的颜色为xx， y的颜色为yy, xx和yy是祖先=后代关系， **且**lca（x,y） 是xx,yy中的一个点的祖先， 同时是其中另外一个点的后代。

这种情况下， 如果我们和之前一样处理散块（x到xx，y到yy）的信息（蓝色）和xx到yy的信息（红色）的话， 就会发现多处理了图上<红蓝色>的部分, 而且多处理了两次。 这个时候我们只需要在处理散块信息的时候特殊处理一下就行了。

恩。 那么查询就讲完了qwq 其实修改也很简单， 直接判断一下所有关键点到根的路径中是否经过修改的点， 如果经过的话就在处理的信息中单次O1进行修改就可以了>_< (注意这里需要O1查询的lca， 不然复杂度带log）效率为O（T）

当T取sqrt(n)时， 算法的时间复杂度为(n+m)sqrt(n)  空间复杂度为n sqrt(n) 

貌似就没有什么啦qwq 有什么问题的话欢迎来私信小蒟蒻啊qwqwq


**那么代码如下：**
```

#include <iostream>
#include <cstring>
#include <cmath>
#include <cstdio>
#include <algorithm>
#include <ctime>
#define maxn 400010
#define maxs 330
#define re register
#define FOR(i, l, r) for(re int i = l; i <= r; ++i)
#define DFR(i, l, r) for(re int i = l; i >= r; --i)
using namespace std;

int n, m, c, r, t, x, y, k, tot;
int sq1, sq2, num, cnt, col, theone, fh, lastans;
int a[maxn], b[maxn], depth[maxn], cnt1[maxs*2][maxs], cnt2[maxs*2][maxn];
int qwq[maxn], san1[maxn], san2[maxn], dis[maxn], head[maxn], numb[maxn];
int fa[maxn], near[maxn], z[maxn], z1[maxn], q[maxn][3];
int f[maxn][20], lg[maxn], id[maxn], vis[maxn], Depth[maxn];
struct hz {
    int next;
    int to;
}h[maxn*2];

inline int read(){
    int x=0;int f=1;char c=getchar();
    while(c<'0'||c>'9'){
        if(c==-1) return 0;
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c<='9'&&c>='0'){
        x=(x<<1)+(x<<3)+(c^'0');
        c=getchar();
    }
    return x*f;
}

inline void add(int from, int to) {
    h[++num].next = head[from];
    h[num].to = to;
    head[from] = num;
}

void dfs(int x, int ff, int dep) {
    fa[x] = ff;
    id[x] = ++tot;
	depth[x] = depth[ff]+1;
    vis[tot] = x;
    Depth[tot] = dep;
    for(re int i = head[x]; i != 0; i = h[i].next) {
    	if(h[i].to == ff)
    	  continue;
    	dfs(h[i].to, x, dep+1);
    	vis[++tot] = x;
    	Depth[tot] = dep;
	}
}

void RMQ() {
	FOR(i, 1, tot)
      lg[i] = lg[i-1]+(1 << lg[i-1] == i);
    FOR(i, 1, tot)
      f[i][0] = i;
    for(int i = 1; (1<<i) <= tot; i++) {
        for(int j = 1; j+(1 << i)-1 <= tot; j++) {
            int A = f[j][i-1];
            int B = f[j+(1 << (i-1))][i-1];
            if(Depth[A] <= Depth[B])
              f[j][i] = A;
            else
              f[j][i] = B;
        }
    }
}

int lca(int x, int y) {
    int r = id[x];
    int l = id[y];
    if(r < l)
      swap(r, l);
    int k = lg[r-l+1]-1;
    int A = f[l][k];
    int B = f[r-(1<<k)+1][k];
    if(Depth[A] <= Depth[B])
      return vis[A];
    else
      return vis[B];
}


void dfs3(int x, int color) { //染色 
    if(numb[x] != 0)
      color = numb[x];
    near[x] = color; //属于什么管辖范围 
    for(re int i = head[x]; i != 0; i = h[i].next) {
        if(h[i].to == fa[x]) 
          continue;
        dfs3(h[i].to, color);
    }
} 

inline void deal(int x, int times) {
    while(x != 0) {
        ++cnt1[times][b[a[x]]];
        ++cnt2[times][a[x]];
        x = fa[x];  
    }
} 

int query(int x, int y, int k) { //求k大 
    //xy在一个颜色块里, 则直接暴力跳到lca
    //xy不在一个颜色块里， 且一部分路径重复计算-> 经过lca后转化加减法 
    if(near[x] == near[y]) {  
        int lc = lca(x, y), xx = x, yy = y, anss = 0;
        while(x != lc) 
          ++san1[b[a[x]]], ++san2[a[x]], x = fa[x]; 
        while(y != fa[lc]) 
          ++san1[b[a[y]]], ++san2[a[y]], y = fa[y];
        int tot = 0, now = 1;
        while(tot+san1[now] < k)
          tot += san1[now], ++now;
        FOR(j, (now-1)*sq1+1, now*sq1) 
          if((tot += san2[j]) >= k) {
              anss = z[j];
              break;
          }
        while(xx != lc) 
          --san1[b[a[xx]]], --san2[a[xx]], xx = fa[xx]; 
        while(yy != fa[lc]) 
          --san1[b[a[yy]]], --san2[a[yy]], yy = fa[yy];
        return anss;
    } 

    int lc = lca(x, y), LC = lca(z1[near[x]], z1[near[y]]), xx = x, yy = y;
    theone = -1, fh = 1;
    if(lca(z1[near[x]], z1[near[y]]) == LC && (lca(lc, z1[near[x]]) == lc || lca(lc, z1[near[y]])) && lc != LC) { //需要转化加减答案 
        theone = lc;
        san1[b[a[LC]]]--, san2[a[LC]]--;
	}
    while(near[fa[xx]] == near[x]) {
        if(xx == theone) {
		    fh *= -1;
		}
		else {
		san1[b[a[xx]]] += fh, san2[a[xx]] += fh;   
		}
		if(xx == 0)
		  exit(0);
        xx = fa[xx];
    }
    fh = 1;
    while(near[fa[yy]] == near[y]) {
        if(yy == theone) {
        	fh *= -1;	
        	yy = fa[yy];
        	continue;
		} 
        san1[b[a[yy]]] += fh, san2[a[yy]] += fh, yy = fa[yy]; 
    }
    
    ++san1[b[a[LC]]];
    ++san2[a[LC]]; 
    int tot = 0, now = 1, anss = 0;
    while(tot+san1[now]+cnt1[near[x]][now]+cnt1[near[y]][now]-2*cnt1[numb[LC]][now] < k)
      tot += san1[now]+cnt1[near[x]][now]+cnt1[near[y]][now]-2*cnt1[numb[LC]][now], ++now;
    FOR(j, (now-1)*sq1+1, now*sq1)  
      if((tot += san2[j]+cnt2[near[x]][j]+cnt2[near[y]][j]-2*cnt2[numb[LC]][j]) >= k) {
          anss = z[j];
          break;
      }
    fh = -1, xx = x, yy = y;
    while(near[fa[xx]] == near[x]) {
        if(xx == theone) {
        	fh *= -1;
        	xx = fa[xx];
        	continue;
		}  
        san1[b[a[xx]]] += fh, san2[a[xx]] += fh, xx = fa[xx];   
    }
    fh = -1;
    while(near[fa[yy]] == near[y]) {
        if(yy == theone) {
        	fh *= -1;
        	yy = fa[yy];
        	continue;
		} 
        san1[b[a[yy]]] += fh, san2[a[yy]] += fh, yy = fa[yy]; 
    }
    --san1[b[a[LC]]];
    --san2[a[LC]]; 
    if(lca(z1[near[x]], z1[near[y]]) == LC && (lca(lc, z1[near[x]]) == lc || lca(lc, z1[near[y]])) && lc != LC) { //需要转化加减答案 
        san1[b[a[LC]]]++, san2[a[LC]]++;
	}
    return anss;
}

signed main() {
    srand(19260817);
    srand(rand());
    srand(rand());
    n = read(), m = read();
    FOR(i, 1, n) {
        a[i] = read(), z[++z[0]] = a[i];
        qwq[i] = i;
    }
    FOR(i, 1, n-1) {
        x = read(), y = read();
        add(x, y);
        add(y, x);
    } 
	dfs(1, 0, 1);
    RMQ();
    FOR(i, 1, m) {
    	q[i][0] = read(), q[i][1] = read(), q[i][2] = read();
    	if(q[i][0] == 0)
    	  z[++z[0]] = q[i][2];
	}
	
    sort(z+1, z+z[0]+1);
    z[0] = unique(z+1, z+z[0]+1)-z-1;
    FOR(i, 1, n) 
      a[i] = lower_bound(z+1, z+z[0]+1, a[i])-z;
    sq1 = sqrt(z[0]); //值域分块 
    FOR(i, 1, z[0])
      b[i] = (i-1)/sq1+1; 

    random_shuffle(qwq+1, qwq+n+1); //选取前sq个点 
    sq2 = sqrt(n); //关键点的数量 
    FOR(i, 1, sq2) 
      z1[++z1[0]] = qwq[i];  
    FOR(i, 1, sq2) 
      FOR(j, i+1, sq2)
        z1[++z1[0]] = lca(qwq[i], qwq[j]);
    sort(z1+1, z1+z1[0]+1); //关键点排序并去重 
    z1[0] = unique(z1+1, z1+z1[0]+1)-z1-1;
    FOR(i, 1, z1[0]) 
      numb[z1[i]] = i; //关键点的新序号 
    dfs3(1, -2); //染色

    FOR(i, 1, z1[0]) //枚举所有新关键点(sq个) 进行处理；
      deal(z1[i], i);  
      
    FOR(i, 1, m) {
    	k = q[i][0], x = q[i][1], y = q[i][2];
    	int sizz = depth[x]+depth[y]-2*depth[lca(x, y)]+1;
    	if(k == 0) {
    		y = lower_bound(z+1, z+z[0]+1, q[i][2])-z;
    		FOR(j, 1, z1[0]) {
    			if(lca(z1[j], x) != x)
    			  continue;
    			--cnt1[j][b[a[x]]];
    			--cnt2[j][a[x]];
    			++cnt1[j][b[y]];
    			++cnt2[j][y];
			}
			a[x] = y;
			continue;
		}
		if(sizz < k) {
			puts("invalid request!");
			continue;
		}
        printf("%d\n", query(x, y, sizz-k+1));
    }
}
```

---

## 作者：墨尔 (赞：5)

```cpp
//求可修改的多个区间第k大  
//关键词:树链剖分，主席树，树状数组(bit)套权值线段树
//不同的延迟时间最多160000个，先离散化才能搞权值线段树
//主席树存一开始每个点的值（必须要，不然MLE，QAQ）
//n个权值线段树，记录每个点修改值，点上权值表示含义与树状数组类似
//每次修改lgn个线段树（其实每个线段树只要改一条链）
//查询就是原来的值加上修改的值
//总之所有的查询都可以看成两个前缀和的差
//查询时所有查询涉及的线段树同时向左/右孩子移动
//写成了求第k小wa了好多发我是个智障
#include<cstdio>
#include<algorithm>
int head[80005],n,m,t[80005],k[80005],a[80005],b[80005],num,cnt,tot;
struct node{int to,next;}e[160005];
int dep[80005],fa[80005],T,c[160005];
void add(int u,int v){e[++num]=(node){v,head[u]},head[u]=num;}
int find(int x)
{
	int l=1,r=tot;
	while(l<=r)
	{
		int mid=l+r>>1;
		if(c[mid]==x)return mid;
		if(c[mid]<x)l=mid+1;else r=mid-1;
	}
}
int top[80005],son[80005],s[80005];
void dfs1(int u)
{
	dep[u]=dep[fa[u]]+1;s[u]=1;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;if(v==fa[u])continue;
		fa[v]=u;dfs1(v);
		if(s[v]>s[son[u]])son[u]=v;
	}
}
int p[80005],dfn[80005];
void dfs2(int u,int root)
{
	top[u]=root;dfn[u]=++T;p[T]=u;
	if(son[u])dfs2(son[u],root);else return;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(v==fa[u]||v==son[u])continue;
		dfs2(v,v);
	}
}
int lowbit(int x){return x&(-x);}
int sum[6400005],lc[6400005],rc[6400005];
void insert(int&id,int l,int r,int x,int val)
{
	if(!id)id=++T;
	sum[id]+=val;
	if(l==r)return;
	int mid=l+r>>1;
	if(x<=mid)insert(lc[id],l,mid,x,val);
	else insert(rc[id],mid+1,r,x,val);
}
void build(int&id,int last,int l,int r,int x)
{
	id=++T;sum[id]=sum[last]+1;
	if(l==r)return;
	int mid=l+r>>1;
	lc[id]=lc[last],rc[id]=rc[last];
	if(x<=mid)build(lc[id],lc[last],l,mid,x);
	else build(rc[id],rc[last],mid+1,r,x);
}
int len1,len2,ql[160005],qr[160005];
int trquery(int l,int r,int k)
{
	if(l==r)return l;
	int mid=l+r>>1;long long sum1=0,sum2=0;
	for(int i=1;i<=len1;i++)sum1+=sum[rc[ql[i]]];
	for(int i=1;i<=len2;i++)sum2+=sum[rc[qr[i]]];
	//算右孩子的值
	if(sum2-sum1>=k)
	{
		for(int i=1;i<=len1;i++)ql[i]=rc[ql[i]];
		for(int i=1;i<=len2;i++)qr[i]=rc[qr[i]];
		return trquery(mid+1,r,k);
	}else 
	{
		for(int i=1;i<=len1;i++)ql[i]=lc[ql[i]];
		for(int i=1;i<=len2;i++)qr[i]=lc[qr[i]];
		return trquery(l,mid,k-sum2+sum1);
	}
}
int root[160005];
int query(int x,int y,int k)
{
	int fx=top[x],fy=top[y];len1=len2=0;
	while(fx!=fy)
	{
		if(dep[fx]>dep[fy])
		 x^=y,y^=x,x^=y,fx^=fy,fy^=fx,fx^=fy;
		//区间[dfn[fy],dfn[y]]
		for(int i=dfn[fy]-1;i>=1;i-=lowbit(i))ql[++len1]=root[i];
		for(int i=dfn[y];i>=1;i-=lowbit(i))qr[++len2]=root[i];
		if(dfn[fy]>1)ql[++len1]=root[dfn[fy]-1+n];
		qr[++len2]=root[dfn[y]+n];
		y=fa[fy],fy=top[y];
	}
	if(dep[x]>dep[y])x^=y,y^=x,x^=y;//[dfn[x],dfn[y]]
	for(int i=dfn[x]-1;i>=1;i-=lowbit(i))ql[++len1]=root[i];
	for(int i=dfn[y];i>=1;i-=lowbit(i))qr[++len2]=root[i];
	if(dfn[x]>1)ql[++len1]=root[dfn[x]-1+n];qr[++len2]=root[dfn[y]+n];
	long long tmp=0;
	for(int i=1;i<=len1;i++)tmp-=sum[ql[i]];
	for(int i=1;i<=len2;i++)tmp+=sum[qr[i]];
	if(tmp<k)return -1;
	return trquery(1,tot,k); 
}
int main()
{
	//freopen("network_network2.in","r",stdin);
	//freopen("0.out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",&t[i]),c[++cnt]=t[i];
	for(int i=1,u,v;i<n;i++)scanf("%d%d",&u,&v),add(u,v),add(v,u);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&k[i],&a[i],&b[i]);
		if(!k[i])c[++cnt]=b[i];
	}
	std::sort(c+1,c+1+cnt);tot=1;
	for(int i=2;i<=cnt;i++)if(c[i]!=c[tot])c[++tot]=c[i];//离散化
	for(int i=1;i<=n;i++)t[i]=find(t[i]);
	dfs1(1),dfs2(1,1);T=0;
	for(int i=1;i<=n;i++)
	 build(root[i+n],root[i+n-1],1,tot,t[p[i]]);//主席树
	for(int i=1;i<=m;i++)
	{
		if(!k[i])
		{
			for(int j=dfn[a[i]];j<=n;j+=lowbit(j))
			 insert(root[j],1,tot,t[a[i]],-1);
			t[a[i]]=find(b[i]);
			for(int j=dfn[a[i]];j<=n;j+=lowbit(j))
			 insert(root[j],1,tot,t[a[i]],1);
		}else 
		{
			int ans=query(a[i],b[i],k[i]);
			if(ans==-1)printf("invalid request!\n");
			else printf("%d\n",c[ans]);
		}
	}
}
```

---

## 作者：chenxia25 (赞：4)

其实这题用整体二分也是可以 2log 的……

动态树链第 k 小问题。考虑二分 + 动态二维数点，用树剖 + 树套树维护。树剖 1log，树套树 2log，加上二分的 1log，一共是 4log。不过可以做到把二分转到树上，这样树套树外层 BIT 要是权值，而且二分应当是最外层的，比树剖还要外层，也就是说，BIT 倍增每次 chk 是在对应线段树上找树剖的 log 段来查值，实现的话可以提前把 log 段存下来，代码写起来应该非常毒瘤。这样子是 3log 的。

然后我们想起 COT 那题静态树链第 k 小利用树上前缀和（树上前缀主席树）做到了和线性结构一样优秀的 1log，而没有使用树剖。看看这题能不能应用。依然考虑维护树上前缀线段树，但是有单点修改怎么办呢，发现一次单点修改相当于修改它子树内所有线段树，那就用个 BIT 套在线段树外面差分维护。本来线段树二分的时候只需要取 $x,y,lca,fa[lca]$ 四个位置，现在每个线段树由于被 BIT 维护了，对应了 BIT 上 log 个位置。所以秉持二分在最外的原则，要把 BIT 上 4 倍 log 个线段树位置提前预处理下来，虽然是 2log 复杂度了，但感觉不是一般的难写，就没写了 2333

考虑整体二分的做法，会好写很多。在整体二分内部要做的就是动态树上修改树链求和。这个容易想到树剖，内部 2log，套上整体二分就是 3log。但是我们依然可以用树上前缀和的思想，就维护树上前缀和，每次单点加影响子树，然后单点查前缀和，也就用 BIT 就可以差分转化维护了，复杂度 2log。不仅好写，常数还比在线做法小很多。

code：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
int lowbit(int x){return x&-x;}
const int N=300010,LOG_N=20;
int n,qu;
vector<int> nums;
vector<int> nei[N];
int a[N];
struct query{int tp,x,y,id;}qry[N];
void discrete(){
	sort(nums.begin(),nums.end());
	nums.resize(unique(nums.begin(),nums.end())-nums.begin());
	for(int i=1;i<=n;i++)a[i]=lower_bound(nums.begin(),nums.end(),a[i])-nums.begin()+1;
	for(int i=1;i<=qu;i++)if(!qry[i].tp)qry[i].y=lower_bound(nums.begin(),nums.end(),qry[i].y)-nums.begin()+1;
}
int dfn[N],mxdfn[N],nowdfn,dep[N],fa[N][LOG_N];
void dfs(int x=1){
	dfn[x]=mxdfn[x]=++nowdfn;
	for(int i=1;i<LOG_N;i++)fa[x][i]=fa[fa[x][i-1]][i-1];
	for(int i=0;i<nei[x].size();i++){
		int y=nei[x][i];
		if(y==fa[x][0])continue;
		fa[y][0]=x;
		dep[y]=dep[x]+1;
		dfs(y);
		mxdfn[x]=mxdfn[y];
	}
}
int lca(int x,int y){
	if(dep[x]<dep[y])swap(x,y);
	for(int i=LOG_N-1;~i;i--)if(dep[fa[x][i]]>=dep[y])x=fa[x][i];
	if(x==y)return x;
	for(int i=LOG_N-1;~i;i--)if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}
struct bitree{
	int cnt[N];
	bitree(){memset(cnt,0,sizeof(cnt));}
	void _add(int x,int v){
		while(x<=n)cnt[x]+=v,x+=lowbit(x);
	}
	void add(int l,int r,int v){
		_add(l,v),_add(r+1,-v);
	}
	int at(int x){
		int res=0;
		while(x)res+=cnt[x],x-=lowbit(x);
		return res;
	}
}bit;
int ans[N];
void solve(int l,int r,vector<query> v){
	if(l==r){
		for(int i=0;i<v.size();i++){
			int tp=v[i].tp,id=v[i].id;
			if(tp>0)ans[id]=l;
		}
		return;
	}
	int mid=l+r>>1;
	vector<query> lft,rit;
	for(int i=0;i<v.size();i++){
		int tp=v[i].tp,x=v[i].x,y=v[i].y;
		if(tp<=0){
			if(y<=mid)bit.add(dfn[x],mxdfn[x],tp==0?1:-1),lft.pb(v[i]);
			else rit.pb(v[i]);
		}
		else{
			int _lca=lca(x,y),fd=bit.at(dfn[x])+bit.at(dfn[y])-bit.at(dfn[_lca])-bit.at(dfn[fa[_lca][0]]);
			if(tp<=fd)lft.pb(v[i]);
			else v[i].tp-=fd,rit.pb(v[i]);
		}
	}
	for(int i=0;i<v.size();i++){
		int tp=v[i].tp,x=v[i].x,y=v[i].y;
		if(tp<=0)if(y<=mid)bit.add(dfn[x],mxdfn[x],tp==0?-1:1);
	}
	solve(l,mid,lft),solve(mid+1,r,rit);
}
int main(){
//	freopen("C:\\Users\\chenx\\AppData\\Local\\Temp\\Rar$DIa6624.14836\\5.in","r",stdin);
	cin>>n>>qu;
	for(int i=1;i<=n;i++)scanf("%d",a+i),a[i]*=-1,nums.pb(a[i]);
	for(int i=1;i<n;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		nei[x].pb(y),nei[y].pb(x);
	}
	for(int i=1;i<=qu;i++){
		scanf("%d%d%d",&qry[i].tp,&qry[i].x,&qry[i].y),qry[i].id=i;
		qry[i].tp||(qry[i].y*=-1,nums.pb(qry[i].y),0);
	}
	discrete();
	dep[1]=1,dfs();
	vector<query> v;
	for(int i=1;i<=n;i++)v.pb(query({0,i,a[i],0}));
	for(int i=1;i<=qu;i++)
		if(qry[i].tp>0)v.pb(qry[i]);
		else{
			v.pb(query({-1,qry[i].x,a[qry[i].x],0}));
			a[qry[i].x]=qry[i].y;
			v.pb(qry[i]);
		}
	solve(1,nums.size()+1,v);
	for(int i=1;i<=qu;i++)if(qry[i].tp>0){
		if(ans[i]>nums.size())puts("invalid request!");
		else printf("%d\n",-nums[ans[i]-1]);
	}
	return 0;
}
```

---

## 作者：Rayment (赞：4)

# 题外话
话说刚开始写了个链剖，发现复杂度是$O(nlog^3n)$，有点方就全删了~~，后来题解说连log^4的splay都A掉了~~。

然后写了个树上主席树，发现复杂度搞错了，又重写了，才改成现在这个样子。。荒废了一上午qwqqq
# Solution
说正经的吧，就是动态查询路径上权值第k大。

首先我们考虑树上主席树，那么答案统计还是sum[x]+sum[y]-sum[lca]-sum[f[lca]]。我们会发现如果更新了一个点权，则其子树内的所有主席树都要更新，更新的复杂度是$O(nlogn)$，这显然是承受不起的~~，其实有80分~~。

注意到子树在dfs序中是成段的，那么我们不妨考虑维护dfs序。则问题变成了区间更新和单点查询，套路差分，就可以转化为单点更新和区间查询，上BIT模板。
时间复杂度$O(nlog^2n)$

不过在dfs序上，其实这个前缀并不是完全都是到根节点的路径，因为可能有之前搜到的其他子树，但是其实这个对我们统计答案的方式并无影响，因为sum[x]和sum[y]分别对这些冗余信息计算了一次，而sum[lca]和sum[f[lca]]却又分别减去了它们的贡献。

另外注意在update时不必每次访问都重新开节点，不然会MLE。因为这个节点并没有与新节点冲突，除了sum要修改之外，其他信息仍然可以利用。
# Code
```cpp
#include <algorithm>
#include <cstdio>
#define lowbit(x) ((x)&(-(x)))
using namespace std;
const int maxn=80010,maxm=10000010;
struct data{int v,nxt;}edge[maxn<<1];
struct operation{int k,a,b;}opr[maxn];
int n,m,p,dfc,tot,len,cnt[2],tmp[2][40];
int head[maxn],a[maxn],b[maxn<<1],f[maxn][20],deep[maxn],pre[maxn],nxt[maxn];
int rt[maxn],lc[maxm],rc[maxm],sum[maxm];
template <typename Tp> inline void read(Tp &x)
{
	x=0;char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
}
inline void insert(int u,int v)
{
	edge[++p]=(data){v,head[u]};head[u]=p;
	edge[++p]=(data){u,head[v]};head[v]=p;
}
void input()
{
	int k,x,y;
	read(n);read(m);len=n;
	for(int i=1;i<=n;i++){read(a[i]);b[i]=a[i];}
	for(int i=1;i<n;i++){read(x);read(y);insert(x,y);}
	for(int i=1;i<=m;i++)
	{
		read(opr[i].k);read(opr[i].a);read(opr[i].b);
		if(!opr[i].k) b[++len]=opr[i].b;
	}
	sort(b+1,b+len+1);len=unique(b+1,b+len+1)-b-1;
	for(int i=1;i<=n;i++) a[i]=lower_bound(b+1,b+len+1,a[i])-b;
}
void update(int l,int r,int pos,int val,int& rt)
{
	if(!rt) rt=++tot;
	sum[rt]+=val;
	if(l==r) return ;
	int m=(l+r)>>1;
	if(pos<=m) update(l,m,pos,val,lc[rt]);
	else update(m+1,r,pos,val,rc[rt]);
}
int query(int l,int r,int k)
{
	if(l==r) return l;
	int m=(l+r)>>1,s=0;
	for(int i=1;i<=cnt[0];i++) s+=sum[lc[tmp[0][i]]];
	for(int i=1;i<=cnt[1];i++) s-=sum[lc[tmp[1][i]]];
	if(k<=s)
	{
		for(int i=1;i<=cnt[0];i++) tmp[0][i]=lc[tmp[0][i]];
		for(int i=1;i<=cnt[1];i++) tmp[1][i]=lc[tmp[1][i]];
		return query(l,m,k);
	}
	else
	{
		for(int i=1;i<=cnt[0];i++) tmp[0][i]=rc[tmp[0][i]];
		for(int i=1;i<=cnt[1];i++) tmp[1][i]=rc[tmp[1][i]];
		return query(m+1,r,k-s);
	}
}
void dfs(int x)
{
	for(int i=1;i<20;i++) f[x][i]=f[f[x][i-1]][i-1];
	deep[x]=deep[f[x][0]]+1;pre[x]=++dfc;
	for(int i=head[x];i;i=edge[i].nxt)
	  if(edge[i].v!=f[x][0])
	  {
	  	f[edge[i].v][0]=x;
	  	dfs(edge[i].v);
	  }
	nxt[x]=dfc;//两次dfs序都要存，因为有两个单点更新
}
int getlca(int x,int y)
{
	if(deep[x]<deep[y]) swap(x,y);
	int t=deep[x]-deep[y];
	for(int i=0;i<20;i++)
	  if(t&(1<<i)) x=f[x][i];
	if(x==y) return x;
	for(int i=19;~i;i--)
	  if(f[x][i]!=f[y][i])
	    x=f[x][i],y=f[y][i];
	return f[x][0];
}
void change(int pos,int val,int op)
{
	for(;pos<=n;pos+=lowbit(pos)) update(1,len,val,op,rt[pos]);
}
int main()
{
	#ifndef ONLINE_JUDGE
	freopen("in.txt","r",stdin);
	#endif
	int x,y,k,lca,flca,s;
	input();dfs(1);
	for(int i=1;i<=n;i++) change(pre[i],a[i],1),change(nxt[i]+1,a[i],-1);
	for(int i=1;i<=m;i++)
	{
		x=opr[i].a;y=opr[i].b;k=opr[i].k;
		if(k)
		{//由于要合并答案，所以先把需要用到的节点都预处理存起来
			lca=getlca(x,y);flca=f[lca][0];cnt[0]=cnt[1]=0;
			s=deep[x]+deep[y]-deep[lca]-deep[flca];
			for(int i=pre[x];i;i-=lowbit(i)) tmp[0][++cnt[0]]=rt[i];
			for(int i=pre[y];i;i-=lowbit(i)) tmp[0][++cnt[0]]=rt[i];
			for(int i=pre[lca];i;i-=lowbit(i)) tmp[1][++cnt[1]]=rt[i];
			for(int i=pre[flca];i;i-=lowbit(i)) tmp[1][++cnt[1]]=rt[i];
			if(k>s) puts("invalid request!");
			else printf("%d\n",b[query(1,len,s-k+1)]);
		}
		else
		{
			change(pre[x],a[x],-1);change(nxt[x]+1,a[x],1);
			a[x]=lower_bound(b+1,b+len+1,y)-b;
			change(pre[x],a[x],1);change(nxt[x]+1,a[x],-1);
		}
	}
	return 0;
}
```


---

## 作者：Others (赞：3)

做这题之前可以先看看[P4074](https://www.luogu.com.cn/problem/P4074)，做个热身再来。
# 题目大意
给你一棵树，支持以下两种操作：
- 修改某个节点的权值
- 查询一段路径内第 k **大**的数
# 思路
这题是一个带修的树上莫队，主要是看求第 k 大怎么求。

你不会平衡树？

没事~~我也不会~~。

你不会分块？

~~那你没救了~~

这题的思路应该有两种，一个是平衡树，一个是分块，平衡树板板我至今 8pts... 所以我只好写分块，这里可以利用[这道题](https://www.luogu.com.cn/problem/CF220B)的思想（这是道普通莫队...其实都一样），对 $cnt$ 数组分块，然后从后往前枚举到第 k 大的数所在的块，再在块内枚举。

你问我怎么枚举第 k 大数所在块...你真的没救了...

剩下的就是板板了，就直接套篇首那道题的板板就行了。

有问题吗？----没有问题。

代码里的注释有一些注意事项....都是泪的经验....
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN=80005;
inline void qr(register int &ret){register int x=0,f=0;register char ch=getchar();while(ch<'0'||ch>'9')f|=ch=='-',ch=getchar();while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();ret=f?-x:x;}
int n,m,q,w[MAXN],v[MAXN],c[MAXN],ttt,fr,op,x,y,LCA,flag[MAXN<<1],tpt,lenlen;
int fa[MAXN],ord[MAXN<<1],fir[MAXN],las[MAXN],son[MAXN],sze[MAXN],head[MAXN],nxt[MAXN<<1],to[MAXN<<1],dep[MAXN],top[MAXN],ccnt,nord;
int cntr,cntp,idx[MAXN<<1],s,l,r,t,tot,cnt[MAXN],vis[MAXN],L,R,T,K,ans[MAXN],block[MAXN],idxn[MAXN<<1],sn,ll[MAXN],yy[MAXN];//这一段其实可以跳过... 
struct node1{
	int l,r,id,ti,lca,k;
	bool operator<(const node1 x)const{//双重奇偶排序，欧~~~~耶! 
		return idx[l]==idx[x.l]?(idx[l]&1?(idx[r]==idx[x.r]?(idx[r]&1?ti<x.ti:ti>x.ti):idx[r]<idx[x.r]):(idx[r]==idx[x.r]?(idx[r]&1?ti<x.ti:ti>x.ti):r>x.r)):l<x.l;
	}
}p[MAXN];
struct node2{
	int i,from,to;
}ch[MAXN];
void add(int x){//要对权值的块下手 
	++cnt[x];
	++block[idxn[x]];
}
void del(int x){
	--cnt[x];
	--block[idxn[x]];
}
void work(int x){
	vis[x]?del(c[x]):add(c[x]);
	vis[x]^=1;
}
void dealadd(int x){
	if(vis[ch[x].i]) add(ch[x].to),del(ch[x].from);
	c[ch[x].i]=ch[x].to;
}
void dealdel(int x){
	if(vis[ch[x].i]) del(ch[x].to),add(ch[x].from);
	c[ch[x].i]=ch[x].from;
}
void adde(int fr,int To){
	nxt[++ccnt]=head[fr],head[fr]=ccnt,to[ccnt]=To;
}
void dfs1(int i){//树剖求 LCA 不会的跳过 
	dep[i]=dep[fa[i]]+1;
	sze[i]=1;
	ord[++nord]=i;
	fir[i]=nord;
	for(int j=head[i];j;j=nxt[j]){
		if(to[j]==fa[i]) continue;
		fa[to[j]]=i;
		dfs1(to[j]);
		sze[i]+=sze[to[j]];
		if(son[i]==1||sze[to[j]]>sze[son[i]]) son[i]=to[j];
	}
	ord[++nord]=i;
	las[i]=nord;
	return;
}
void dfs2(int i,int Top){
	top[i]=Top;
	if(son[i]) dfs2(son[i],Top);
	for(int j=head[i];j;j=nxt[j]){
		if(to[j]==fa[i]||to[j]==son[i]) continue;
		dfs2(to[j],to[j]);
	}
	return;
}
int getlca(int x,int y){
	while(top[x]^top[y]){
		if(dep[top[x]]>=dep[top[y]]) x=fa[top[x]];
		else y=fa[top[y]];
	}
	return dep[x]>dep[y]?y:x;
}
signed main() {
	qr(n),qr(m);
	for(int i=1;i<=n;++i) {
		qr(c[i]);
		flag[++tpt]=c[i];
	}
	for(int i=1;i<n;++i){
		qr(fr),qr(ttt);
		adde(fr,ttt),adde(ttt,fr);
	}
	fa[1]=1;
	dfs1(1),dfs2(1,1);
	s=pow(nord,2.0/3);//这里是 2/3 次方!!! 
	for(int i=1;i<=nord;++i) idx[i]=(i+s-1)/s;
	for(int i=1;i<=m;++i){
		qr(op),qr(x),qr(y);
		if(op){
			++cntp;
			p[cntp].k=op;//这个点我调了 1min(标准の不读输入格式の选手) 
			if(fir[x]>fir[y]) swap(x,y);
			LCA=getlca(x,y);
			if(LCA==x){
				p[cntp].l=fir[x],p[cntp].r=fir[y];
				p[cntp].id=cntp,p[cntp].ti=cntr;
			}else{
				p[cntp].l=las[x],p[cntp].r=fir[y];
				p[cntp].id=cntp,p[cntp].ti=cntr;
				p[cntp].lca=LCA;
			}
		}else{
			++cntr;
			ch[cntr].i=x,ch[cntr].from=c[x],ch[cntr].to=c[x]=y;
			flag[++tpt]=y;
		}
	}
	for(int i=cntr;i>=1;--i) c[ch[i].i]=ch[i].from;
	sort(flag+1,flag+tpt+1);
	lenlen=unique(flag+1,flag+tpt+1)-flag-1;
	for(int i=1;i<=n;++i) c[i]=lower_bound(flag+1,flag+lenlen+1,c[i])-flag;
	for(int i=1;i<=cntr;++i) ch[i].from=lower_bound(flag+1,flag+lenlen+1,ch[i].from)-flag,ch[i].to=lower_bound(flag+1,flag+lenlen+1,ch[i].to)-flag; 
	sn=sqrt(lenlen);
	for(int i=1;i<=lenlen;++i){//对权值分块 
		idxn[i]=(i+sn-1)/sn;
		if(idxn[i]!=idxn[i-1]) ll[(i+sn-1)/sn]=i,yy[(i+sn-1)/sn-1]=i-1;//记录块的左右端点 
	}
	yy[(lenlen+sn-1)/sn]=lenlen;
	sort(p+1,p+cntp+1);
	l=1,r=t=0;
	for(int i=1;i<=cntp;++i){
		L=p[i].l,R=p[i].r,T=p[i].ti,K=p[i].k;
		while(t>T) dealdel(t--);
		while(t<T) dealadd(++t);
		while(l>L) work(ord[--l]);
		while(r<R) work(ord[++r]);
		while(l<L) work(ord[l++]);
		while(r>R) work(ord[r--]);
		if(p[i].lca) work(p[i].lca);//要处理 LCA 
		ans[p[i].id]=-1;
		for(int j=(lenlen+sn-1)/sn;j>0;--j){
			if(block[j]<K){//如何排除第 k 大数不在的块 
				K-=block[j];
			}else{
				for(int pos=yy[j];pos>=ll[j];--pos){
					if(cnt[pos]<K) K-=cnt[pos];
					else {
						ans[p[i].id]=pos;
						break;
					}
				}
				break;
			}
		}
		if(p[i].lca) work(p[i].lca);
	}
	for(int i=1;i<=cntp;++i) {
		if(ans[i]!=-1)
		printf("%lld\n",flag[ans[i]]);//注意这里是离散化前的值！！ 
		else 
		printf("invalid request!\n");
	}
	return 0;
}
```

---

## 作者：Genius_Z (赞：2)

$这题本蒟蒻调了很久，最后发现是块没有预处理完...$

$先说一下思路$

$前置芝士：$

- $树剖求LCA$
- $带修莫队求区间k大$

$首先讲一下欧拉序：$

$欧拉序是在访问某个节点时和退出某个节点时都把节点放进序列的一种序$

$与dfs序最大的不同就在于回溯时也把节点放进序列$

![](https://s2.ax1x.com/2019/03/16/AZnnsA.png)

$像这颗树的欧拉序就是 \text{1 3 3 2 4 4 5 5 2 1}$

$那这东西有什么用呢$

$树上莫队是基于欧拉序的$

$我们这样处理出st[]和ed[]两个数组，st表示这个点第一次被访问的时间，ed表示这个点被回溯到时被访问的时间$

$LCA不为两个点中任意一个的两个点之间的链上的点贡献（好绕口），就是深度小的那个点的ed到大的那个点的st贡献再加上LCA的贡献$

$若LCA为两个点中的任意一个，那么贡献就是深度小的那个点的st到大的那个点的st的贡献（因为要算子树）$

$若在欧拉序列中两次访问同一点，要清除该点贡献，所以需要一个bool数组记录该点是否被访问$

$欧拉序：$

```c++
inl void dfs1(int x) {
	siz[x] = 1, dep[x] = dep[fa[x]] + 1, euler[++node] = x, st[x] = node;
	for (re i = head[x]; i; i = e[i].next) {
		if (e[i].to != fa[x]) {
			fa[e[i].to] = x, dfs1(e[i].to);
			siz[x] += siz[e[i].to], siz[e[i].to] > siz[h[x]] ? h[x] = e[i].to : 0;
		}
	}
	euler[++node] = x, ed[x] = node;
}//因为树剖要dfs所以和树剖一起把欧拉序给处理了
```

$处理贡献：$

```c++
for (re i = 1; i <= m; i++) {
		op = read<int>();
		if (op) {
			q[++qnum].k = cnum, q[qnum].id = qnum, x = read<int>(), y = read<int>(), q[qnum].w = op;
			if (dep[x] > dep[y])swap(x, y);
			f = lca(x, y);
			if (x == f) q[qnum].l = st[x], q[qnum].r = st[y];
			else q[qnum].l = ed[x], q[qnum].r = st[y], q[qnum].lca = f;
		}
		else c[++cnum].pos = read<int>(), d[++si] = c[cnum].w = read<int>();
	}//c是保存修改的数组，q是保存询问的数组
```

$因为值域是1e8数组显然开不下，所以我们需要离散化$

$\large\color{Red}\text{注意离散化的时候要离散修改的值}$

$还有就是因为欧拉序列的长度是原序列的两倍，所以在分块时要处理\text{((n<<1)+cnum)}个点$

$之后就是莫队的板子了$

$注意一下统计贡献的方法，比较巧妙，是对离散后的值域进行分块，详情可以参照$[P2617](https://www.luogu.org/problemnew/show/P2617)

[我的题解](https://www.luogu.org/blog/zi-o/p2617-dynamic-rankings-ti-xie-dai-xiu-mu-dui-post)​

$当然这题略有不同，因为求的是k大值，所以需要从后往前扫$

$完整代码：$

```c++
#pragma region prepare
#pragma will be the king
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<vector>
#include<map>
#include<algorithm>
#include<set>
#include<bitset>
#define inl inline
#define re register int
using namespace std;
template <class Read>
inl Read read() {
	Read x = 0;
	bool w = 0;
	char c = getchar();
	while (c > '9' || c < '0') {
		if (c == '-')w = 1;
		c = getchar();
	}
	while (c >= '0'&&c <= '9') {
		x = (x << 3) + (x << 1) + (c ^ 48);
		c = getchar();
	}
	return w ? -x : x;
}
#pragma endregion
int n, m, num, si, qnum, cnum, all, op, smax, cnt[2000001], a[1000001], d[2000001], mp[2000001], s[2000001], head[1000001], tot, ans[1000001];
int st[1000001], ed[1000001], euler[2000001], node, siz[1000001], h[1000001], top[1000001], dep[1000001], fa[1000001], sum[100001];
bool vis[1000001];
struct quiz {
	int l, r, id, k, w, lca;
	bool operator <(const quiz& poi)const {
		return s[l] ^ s[poi.l] ? s[l] < s[poi.l] : s[r] ^ s[poi.r] ? s[r] < s[poi.r] : s[r] & 1 ? k > poi.k : k < poi.k;
	}
}q[200001];
struct modify {
	int pos, w;
}c[200001];
struct edge {
	int next, to;
}e[5000001];
inl void adde(int x, int y) {
	e[++tot] = edge{ head[x],y }, head[x] = tot;
}
inl void dfs1(int x) {
	siz[x] = 1, dep[x] = dep[fa[x]] + 1, euler[++node] = x, st[x] = node;
	for (re i = head[x]; i; i = e[i].next) {
		if (e[i].to != fa[x]) {
			fa[e[i].to] = x, dfs1(e[i].to);
			siz[x] += siz[e[i].to], siz[e[i].to] > siz[h[x]] ? h[x] = e[i].to : 0;
		}
	}
	euler[++node] = x, ed[x] = node;
}
inl void dfs2(int x) {
	if (h[x]) top[h[x]] = top[x], dfs2(h[x]);
	for (re i = head[x]; i; i = e[i].next) if (!top[e[i].to])top[e[i].to] = e[i].to, dfs2(e[i].to);
}
inl int lca(int x, int y) {
	while (top[x] != top[y]) {
		if (dep[top[x]] < dep[top[y]])swap(x, y);
		x = fa[top[x]];
	}
	return dep[x] < dep[y] ? x : y;
}
inl void add(int x) {
	cnt[x]++, sum[s[x]]++, op++, smax = max(s[x], smax);
}
inl void del(int x) {
	cnt[x]--, sum[s[x]]--, op--;
}
inl void oper(int x) {
	(vis[x] ^= 1) ? add(a[x]) : del(a[x]);
}
inl void change(int x) {
	if (vis[c[x].pos]) {
		cnt[c[x].w]++, sum[s[c[x].w]]++;
		cnt[a[c[x].pos]]--, sum[s[a[c[x].pos]]]--;
		smax = max(max(s[c[x].w], smax), s[a[c[x].pos]]);
	}
	swap(c[x].w, a[c[x].pos]);
}
signed main() {
	top[1] = 1, n = read<int>(), m = read<int>(), num = (int)sqrt(n);
	for (re i = 1; i <= n; i++) a[i] = d[++si] = read<int>(), s[i] = (i - 1) / num + 1;
	for (re i = 1, x, y; i < n; i++)x = read<int>(), y = read<int>(), adde(x, y), adde(y, x);
	dfs1(1), dfs2(1);
	re f, x, y;
	for (re i = 1; i <= m; i++) {
		op = read<int>();
		if (op) {
			q[++qnum].k = cnum, q[qnum].id = qnum, x = read<int>(), y = read<int>(), q[qnum].w = op;
			if (dep[x] > dep[y])swap(x, y);
			f = lca(x, y);
			if (x == f) q[qnum].l = st[x], q[qnum].r = st[y];
			else q[qnum].l = ed[x], q[qnum].r = st[y], q[qnum].lca = f;
		}
		else c[++cnum].pos = read<int>(), d[++si] = c[cnum].w = read<int>();
	}
	int cn = (n << 1) + cnum;
	for (re i = n + 1; i <= cn; i++)s[i] = (i - 1) / num + 1;
	sort(d + 1, d + 1 + si), si = unique(d + 1, d + 1 + si) - d - 1;
	for (re i = 1; i <= n; i++)op = a[i], mp[a[i] = lower_bound(d + 1, d + 1 + si, a[i]) - d] = op;
	for (re i = 1; i <= cnum; i++)op = c[i].w, mp[c[i].w = lower_bound(d + 1, d + 1 + si, c[i].w) - d] = op;
	sort(q + 1, q + 1 + qnum);
	re l = 1, r = 0, k = 0, res, now, tmp;
	op = 0;
	for (re i = 1; i <= qnum; i++) {
		while (l > q[i].l)oper(euler[--l]);
		while (r < q[i].r)oper(euler[++r]);
		while (l < q[i].l)oper(euler[l++]);
		while (r > q[i].r)oper(euler[r--]);
		while (k < q[i].k)change(++k);
		while (k > q[i].k)change(k--);
		if (q[i].lca)oper(q[i].lca);
		if (op < q[i].w) {
			if (q[i].lca)oper(q[i].lca);
			ans[q[i].id] = -1;
			continue;
		}
		res = now = 0;
		tmp = smax, smax = 0;
		for (now = tmp; now; now--) {
			if (sum[now])smax = max(now, smax);
			if (res + sum[now] < q[i].w)res += sum[now];
			else break;
		}
		for (re j = now * num; j; j--) {
			if ((res += cnt[j]) >= q[i].w) {
				ans[q[i].id] = mp[j];
				break;
			}
		}
		if (q[i].lca)oper(q[i].lca);
	}
	for (re i = 1; i <= qnum; i++) {
		if (ans[i] != -1)printf("%d\n", ans[i]);
		else puts("invalid request!");
	}
    return 0;
}
```

$不吸氧还是会T一个点的，毕竟树上莫队复杂度\Theta(n^{5/3}+mlog_n)再带上大常数还是太高了$

$吸氧后总共耗时$[1710ms](https://www.luogu.org/recordnew/show/17285828)$还算可以$



---

## 作者：tth37 (赞：2)

思路：树链剖分+树状数组套主席树

考虑到权值线段树自带buff——整体二分，不难想到对树链上的权值线段树求和，并在合并后的权值线段树上求第 $k$ 大即可愉快地解决本题。

在树链上的求和操作可以用树剖加线性数据结构进行维护。本题需要支持的操作只有单点修改和区间查询，所以可以用树状数组套主席树维护 dfs 序上的信息。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define id(x) (lower_bound(b + 1, b + L + 1, x) - b)
#define rid(x) (b[x])
#define lson(x) (node[x].l)
#define rson(x) (node[x].r)
#define sum(x) (node[x].sum)
#define lowbit(x) (x & (-x))
const int MAXN = 80005 * 2;
vector<int> G[MAXN];
struct opt {int k, a, b;} op[MAXN];
struct Node {
    int l, r, sum;
    Node() {l = r = sum = 0;}
} node[MAXN * 80];
int c[MAXN], cnt;
int N, Q, L;
int t[MAXN], b[MAXN];
int q1[MAXN], q2[MAXN], len1, len2;
int dep[MAXN], dfn[MAXN], f[MAXN], son[MAXN], top[MAXN], size[MAXN], dfn_idx;
void insert(int& u, int l, int r, int p, int val) {
    if (u == 0) u = ++cnt;
    sum(u) += val;
    if (l == r) return;
    int mid = (l + r) >> 1;
    if (p <= mid) insert(lson(u), l, mid, p, val);
    else insert(rson(u), mid + 1, r, p, val);
}
void modify(int u, int p, int val) {
    for (; u <= N; u += lowbit(u)) insert(c[u], 1, L, p, val);
}
void dfs1(int u, int fa) {
    dep[u] = dep[fa] + 1;
    f[u] = fa;
    size[u] = 1;
    for (vector<int>::iterator it = G[u].begin(); it != G[u].end(); it++) {
        int v = *it;
        if (v == fa) continue;
        dfs1(v, u);
        if (size[v] > size[son[u]]) son[u] = v;
        size[u] += size[v];
    }
}
void dfs2(int u, int topc) {
    dfn[u] = ++dfn_idx;
    top[u] = topc;
    modify(dfn[u], t[u], 1);
    if (son[u]) dfs2(son[u], topc);
    for (vector<int>::iterator it = G[u].begin(); it != G[u].end(); it++) {
        int v = *it;
        if (v == son[u] || v == f[u]) continue;
        dfs2(v, v);
    }
}
void pre_bin(int u, int* a, int& len) {
    for (; u >= 1; u -= lowbit(u)) a[++len] = c[u];
}
int pre(int u, int v) {
    len1 = len2 = 0;
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        pre_bin(dfn[u], q1, len1);
        pre_bin(dfn[top[u]] - 1, q2, len2);
        u = f[top[u]];
    }
    if (dep[u] < dep[v]) swap(u, v);
    pre_bin(dfn[u], q1, len1);
    pre_bin(dfn[v] - 1, q2, len2);
    return v;
}
int query(int l, int r, int k) {
    if (l == r) return l;
    int mid = (l + r) >> 1, rsum = 0;
    for (int i = 1; i <= len1; ++i) rsum += sum(rson(q1[i]));
    for (int i = 1; i <= len2; ++i) rsum -= sum(rson(q2[i]));
    if (k <= rsum) {
        for (int i = 1; i <= len1; ++i) q1[i] = rson(q1[i]);
        for (int i = 1; i <= len2; ++i) q2[i] = rson(q2[i]);
        return query(mid + 1, r, k);
    }
    else {
        for (int i = 1; i <= len1; ++i) q1[i] = lson(q1[i]);
        for (int i = 1; i <= len2; ++i) q2[i] = lson(q2[i]);
        return query(l, mid, k - rsum);
    }
}
int main() {
    scanf("%d%d", &N, &Q);
    for (register int i = 1; i <= N; ++i) scanf("%d", &t[i]), b[++L] = t[i], c[i] = ++cnt;
    for (register int i = 1; i < N; ++i) {
        int u, v;
        scanf("%d%d", &u, &v);
        G[u].push_back(v), G[v].push_back(u);
    }
    for (register int i = 1; i <= Q; ++i) {
        scanf("%d%d%d", &op[i].k, &op[i].a, &op[i].b);
        if (op[i].k == 0) b[++L] = op[i].b;
    }
    sort(b + 1, b + L + 1);
    L = unique(b + 1, b + L + 1) - b - 1;
    for (register int i = 1; i <= N; ++i) t[i] = id(t[i]);
    dfs1(1, 0);
    dfs2(1, 1);
    for (register int i = 1; i <= Q; ++i) {
        int k = op[i].k, a = op[i].a, b_ = op[i].b;
        if (k == 0) {
            b_ = id(b_);
            modify(dfn[a], t[a], -1);
            t[a] = b_;
            modify(dfn[a], t[a], 1);
        }
        else {
            int lca = pre(a, b_);
            int maxk = dep[a] + dep[b_] - dep[lca] * 2 + 1;
            if (maxk < k) {
                puts("invalid request!");
                continue;
            }
            printf("%d\n", rid(query(1, L, k)));
        }
    }
    return 0;
}
```



---

## 作者：Tyyyyyy (赞：1)

# P4175

大家好，我非常喜欢暴力数据结构，所以我用树上莫队+值域分块过了本题。

### 题目分析
题目要求支持两种操作：单点修改和路径上的第 $k$ 大权值查询。数据范围较小，这时我们自然能想到莫队。

要把莫队放到树上跑很简单，本题求的是路径上的东西，所以就用欧拉序（括号序）即可把树正确地转化为序列。至于树上莫队的操作过程，这里就不再赘述了。重点讲一讲如何维护第 $k$ 大。

一种显然的方式是套一个平衡树。然而这样不仅常数爆炸，实现也非常困难。我们考虑找到更优秀的数据结构。

因为莫队实质是多次修改、少量查询，所以我们自然而然想到要用一个高速修改、低速查询的数据结构去维护它。

考虑分块。我们将所有的修改和原本的权值离散化之后，对值域进行分块，记录每个数出现的次数和每一块内出现数的个数。当我们查询时，先从大到小暴力跳块，当 $k$ 小于块内个数时再在这一块内暴力查询即可。

因为分块的修改是 $O(1)$，所以时间复杂度是 $O(n^{\frac{5}{3}}+q\sqrt{n})$ 的。

~~所以我们还可以加上路径上的权值查排名、查前驱、查后继......~~

另外，该算法在实际运行中远远达不到上界，因此实际上是吊打树套树和整体二分的。~~下面这份代码取得了最优解 rk2。~~

Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=8e4+10;
int n,m,ti[N],lst[N],v[N<<1],maxn,tt,ans[N];
int tot,h[N];
struct edge
{
	int v,nxt;
}e[N<<1];
void add(int u,int v)
{
	e[++tot]=(edge){v,h[u]};
	h[u]=tot;
}
int cntq,cntu,unit;
struct update
{
	int x,y,t;
}u[N];
struct query
{
	int l,r,t,k,Lca,id;
	bool operator < (query b) const
	{
		if(l/unit!=b.l/unit)return l<b.l;
		if(r/unit!=b.r/unit)
		{
			if((l/unit)&1)return r>b.r;
			return r<b.r;
		}
		if((r/unit)&1)return t>b.t;
		return t<b.t;
	}
}q[N];
int st[N],ed[N],id[N<<1],cnt;
int f[N][20],dep[N];
void dfs(int u,int fa)
{
	id[st[u]=++cnt]=u;
	f[u][0]=fa,dep[u]=dep[fa]+1;
	for(int i=h[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==fa)continue;
		dfs(v,u);
	}
	id[ed[u]=++cnt]=u;
}
int lca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	int stp=dep[x]-dep[y];
	for(int i=19;i>=0;i--)
		if(stp>=(1<<i))stp-=(1<<i),x=f[x][i];
	if(x==y)return y;
	for(int i=19;i>=0;i--)
		if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];
	return f[x][0];
}
bool vis[N];
struct block
{
	int sz,L[410],R[410],bcnt[410],cnt[N<<1],pos[N<<1];
	void init()
	{
		sz=sqrt(maxn);
		for(int i=1;i<=sz;i++)L[i]=(i-1)*sz+1,R[i]=i*sz;
		if(R[sz]<maxn)sz++,L[sz]=R[sz-1]+1,R[sz]=maxn;
		for(int i=1;i<=sz;i++)for(int j=L[i];j<=R[i];j++)pos[j]=i;
	}
	void add(int x)
	{
		int y=ti[x];
		if(vis[x])cnt[y]--,bcnt[pos[y]]--;
		else cnt[y]++,bcnt[pos[y]]++;
		vis[x]^=1;
	}
	int query(int k)
	{
		int i;
		for(i=sz;i>=1;i--)
			if(k>bcnt[i])k-=bcnt[i];
			else break;
		for(int j=R[i];j>=L[i];j--)
			if(k>cnt[j])k-=cnt[j];
			else return j;
		return -1;
	}
}B;
void upd(int x,int y)
{
	if(vis[x])B.add(x),ti[x]=y,B.add(x);
	else ti[x]=y;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",&ti[i]),lst[i]=ti[i],v[++tt]=ti[i];
	for(int i=1,x,y;i<n;i++)
		scanf("%d%d",&x,&y),add(x,y),add(y,x);
	dfs(1,0);
	for(int i=1;i<=19;i++)for(int u=1;u<=n;u++)f[u][i]=f[f[u][i-1]][i-1];
	for(int i=1,k,a,b;i<=m;i++)
	{
		scanf("%d%d%d",&k,&a,&b);
		if(!k)
		{
			u[++cntu]=(update){a,lst[a]},lst[a]=u[cntu].t=b;
			v[++tt]=b;
		}
		else
		{
			cntq++;
			if(st[a]>st[b])swap(a,b);
			int Lca=lca(a,b);
			if(a==Lca)q[cntq]=(query){st[a],st[b],cntu,k,0,cntq};
			else q[cntq]=(query){ed[a],st[b],cntu,k,Lca,cntq};
		}
	}
	unit=max(1,(int)(n/pow(m,1.0/3)));
	sort(q+1,q+cntq+1);sort(v+1,v+tt+1);
	maxn=unique(v+1,v+tt+1)-(v+1);
	for(int i=1;i<=n;i++)ti[i]=lower_bound(v+1,v+maxn+1,ti[i])-v;
	for(int i=1;i<=cntu;i++)
		u[i].y=lower_bound(v+1,v+maxn+1,u[i].y)-v,
		u[i].t=lower_bound(v+1,v+maxn+1,u[i].t)-v;
	B.init();
	for(int i=1,l=1,r=0,t=0;i<=cntq;i++)
	{
		while(l>q[i].l)B.add(id[--l]);
		while(r<q[i].r)B.add(id[++r]);
		while(l<q[i].l)B.add(id[l++]);
		while(r>q[i].r)B.add(id[r--]);
		while(t<q[i].t)++t,upd(u[t].x,u[t].t);
		while(t>q[i].t)upd(u[t].x,u[t].y),t--;
		if(q[i].Lca)B.add(q[i].Lca),ans[q[i].id]=B.query(q[i].k),B.add(q[i].Lca);
		else ans[q[i].id]=B.query(q[i].k);
	}
	for(int i=1;i<=cntq;i++)
		if(ans[i]==-1)puts("invalid request!");
		else printf("%d\n",v[ans[i]]);
	return 0;
}
```

---

## 作者：SSerxhs (赞：1)

整体二分+树链剖分+差分树状数组+树上差分

这道题和[【HNOI2016】网络](https://www.luogu.org/problemnew/show/P3250) 很像，只不过修改变成了单点的，询问变成了链上的，最大值变成了第k大。

考虑第k大的解法，无非是主席树划分树等数据结构或整体二分。这题可以离线，考虑离线之后整体二分。

和序列第k大相似，每次修改拆成两个，然后参照楼上解法可以做到$O(qlog_2^3n)$，用线段树维护树剖进行修改和询问即可。

但是这题其实可以做到$O(qlog_2^2n)$。参考【网络】那题中的链修改和单点询问可以通过树上差分树状数组维护dfs序来消去一个log，这题同样可以采用这个技巧。考虑维护每个节点到根的路径有多少个符合条件的点$g(x)$，则修改单点相当于对一棵子树进行修改，询问链$(x,y)$可以通过树上差分实现，即$g(x)+g(y)-g(lca(x,y))-g(fa(lca(x,y)))$。这样就转化为序列上维护区间修改，单点求和。

普通的树状数组是单点修改区间求和，考虑维护原数组的差分数组，则区间修改等同于区间首端+1，末端-1，单点求和就等同于求差分数组的前缀和，于是把区间修改单点求和也转化为了单点修改区间求和，就可以通过树状数组维护了。

```cpp
#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N=8e4+2,M=2.4e5+2;
struct Q
{
	int x,y,v,t;
};
Q q[M],st1[M],st2[M];
int lj[M],nxt[M],fir[N],dfn[N],a[M],ans[N],top[N],fa[N];
int siz[N],hc[N],dep[N],b[M],f[N],dy[N],g[N],cs[N];
int n,m,qs,cnt,i,x,y,c,bs,gs,ggs,tp1,tp2;
inline void read(int &x)
{
	c=getchar();
	while ((c<48)||(c>57)) c=getchar();
	x=c^48;c=getchar();
	while ((c>=48)&&(c<=57))
	{
		x=x*10+(c^48);
		c=getchar();
	}
}
inline void add()
{
	lj[++bs]=y;
	nxt[bs]=fir[x];
	fir[x]=bs;
	lj[++bs]=x;
	nxt[bs]=fir[y];
	fir[y]=bs;
}
void dfs1(int x)
{
	siz[x]=1;
	int i;
	for (i=fir[x];i;i=nxt[i]) if (lj[i]!=f[x])
	{
		dep[lj[i]]=dep[f[lj[i]]=x]+1;
		dfs1(lj[i]);siz[x]+=siz[lj[i]];
		if (siz[lj[i]]>siz[hc[x]]) hc[x]=lj[i];
	}
}
void dfs2(int x)
{
	dfn[x]=++bs;
	if (hc[x])
	{
		top[hc[x]]=top[x];
		dfs2(hc[x]);
		int i;
		for (i=fir[x];i;i=nxt[i]) if ((lj[i]!=f[x])&&(lj[i]!=hc[x])) dfs2(top[lj[i]]=lj[i]);
	}
}
inline int lca(int x,int y)
{
	while (top[x]!=top[y]) if (dep[top[x]]<dep[top[y]]) y=f[top[y]]; else x=f[top[x]];
	if (dep[x]<dep[y]) return x; return y;
}
inline void add(register int x,register int y)
{
	++y;
	while (x<=n) {++g[x];x+=x&(-x);}
	while (y<=n) {--g[y];y+=y&(-y);}
}
inline void del(register int x,register int y)
{
	++y;
	while (x<=n) {--g[x];x+=x&(-x);}
	while (y<=n) {++g[y];y+=y&(-y);}
}
inline int sum(register int x)
{
	register int r=0;
	while (x)
	{
		r+=g[x];x^=x&(-x);
	}
	return r;
}
void ztef(int l,int r,int ql,int qr)
{
	if ((l>r)||(ql>qr)) return;
	if (l==r)
	{
		--ql;
		while (++ql<=qr) ans[q[ql].t]=b[l];
		return;
	}
	int i,mid=l+r>>1,qmid;tp1=tp2=0;
	for (i=ql;i<=qr;i++) if (q[i].t) {tp1=1;break;}
	if (tp1==0) return;tp1=0;
	for (i=ql;i<=qr;i++) if (q[i].t)
	{
		c=sum(dfn[q[i].x])+sum(dfn[q[i].y])-(sum(dfn[fa[q[i].t]])<<1)+cs[fa[q[i].t]];
		if (c>=q[i].v) st2[++tp2]=q[i]; else
		{
			q[i].v-=c;
			st1[++tp1]=q[i];
		}
	}
	else if (q[i].y>0)
	{
		if (q[i].y<=mid) st1[++tp1]=q[i]; else
		{
			add(dfn[q[i].x],dfn[q[i].x]+siz[q[i].x]-1);++cs[q[i].x];
			st2[++tp2]=q[i];
		}
	} else
	{
		if (-q[i].y<=mid) st1[++tp1]=q[i]; else
		{
			del(dfn[q[i].x],dfn[q[i].x]+siz[q[i].x]-1);--cs[q[i].x];
			st2[++tp2]=q[i];
		}
	}
	for (i=1;i<=tp2;i++) if ((st2[i].t==0)&&(st2[i].v==0))
	{
		del(dfn[st2[i].x],dfn[st2[i].x]+siz[st2[i].x]-1);--cs[st2[i].x];
	}
	for (i=1;i<=tp1;i++) q[i+ql-1]=st1[i];qmid=ql+tp1-1;
	for (i=1;i<=tp2;i++) q[i+qmid]=st2[i];
	ztef(l,mid,ql,qmid);ztef(mid+1,r,qmid+1,qr);
}
int main()
{
	read(n);read(m);cnt=n;
	for (i=1;i<=n;i++)
	{
		read(q[i].y);a[i]=g[i]=q[i].y;q[i].x=i;dy[i]=i;
	}ggs=n;
	for (i=1;i<n;i++)
	{
		read(x);read(y);add();
	}bs=0;
	dfs1(dep[1]=1);dfs2(top[1]=1);
	while (m--)
	{
		read(x);read(q[++cnt].x);read(q[cnt].y);
		if (x)
		{
			q[cnt].v=x;q[cnt].t=++qs;fa[qs]=lca(q[cnt].x,q[cnt].y);
		}
		else
		{
			q[cnt+1]=q[cnt];
			q[cnt].y=-g[q[cnt].x];q[cnt].v=q[dy[q[cnt].x]].v=1;
			dy[q[cnt].x]=cnt+1;
			a[++ggs]=g[q[cnt].x]=q[cnt+1].y;++cnt;
		}
	}
	sort(a+1,a+ggs+1);
	memset(g,0,sizeof(g));
	b[gs=1]=a[1];b[0]=-1;
	for (i=2;i<=ggs;i++) if (a[i]!=a[i-1]) b[++gs]=a[i];
	for (i=1;i<=cnt;i++) if (!q[i].t)
	{
		if (q[i].y>0) q[i].y=lower_bound(b+1,b+gs+1,q[i].y)-b; else q[i].y=b-lower_bound(b+1,b+gs+1,-q[i].y);
	}
	ztef(0,gs,1,cnt);
	for (i=1;i<=qs;i++) if (~ans[i]) printf("%d\n",ans[i]); else puts("invalid request!");
}
```


---

## 作者：zhengrunzhe (赞：1)

题意：带单点修改 路径第k大

提供树剖+线段树套平衡树

O(log^4 n) ~~吸氧才过的~~

```cpp
#include<cstdio>
#include<utility>
#include<algorithm>
using namespace std;
const int N=8e4+10,INF=1e8+1;
typedef pair<pair<int,int>,int>piii;
int w[N];
template<class type>inline void read(type &in)
{
    in=0;char ch=getchar();short fh=1;
    while (ch<48||ch>57)fh=ch=='-'?-1:fh,ch=getchar();
    while (ch>47&&ch<58)in=(in<<3)+(in<<1)+ch-48,ch=getchar();
    in*=fh;
}
namespace Edge
{
    int head[N],cnt;
    struct edge{int to,next;}e[N*2];
    inline void add(int a,int b)
    {
        e[++cnt].next=head[a];
        head[a]=cnt;
        e[cnt].to=b;
    }
}using namespace Edge;
namespace Splay
{
    struct tree
    {
        int value,size,cnt;
        tree *fa,*son[2];
        inline tree(int key)
        {
            cnt=size=1;
            value=key;
            fa=son[0]=son[1]=NULL;
        }
        inline int lsize()
        {
            return son[0]?son[0]->size:0;
        }
        inline void pushup()
        {
            size=lsize()+cnt;
            if (son[1])size+=son[1]->size;
        }
        inline bool relation()
        {
            return fa?fa->son[1]==this:0;
        }
    };
    inline void connect(tree *&p,tree *&fa,bool which)
    {
        if (p)p->fa=fa;
        if (fa)fa->son[which]=p,fa->pushup();
    }
    inline void rotate(tree *&p)
    {
        bool lr=p->relation();
        tree *fa=p->fa;
        connect(p,fa->fa,fa->relation());
        connect(p->son[lr^1],fa,lr);
        connect(fa,p,lr^1);
    }
    inline void splay(tree *&root,tree *&p)
    {
        for (tree *fa;fa=p->fa;rotate(p))
            if (fa->fa)
                rotate(p->relation()^fa->relation()?p:fa);
        root=p;
    }
    inline void insert(tree *&root,int key)
    {
        if (root==NULL){root=new tree(key);return;}
        tree *now=root;
        while (1)
            if (key==now->value)
                return now->cnt++,now->pushup(),splay(root,now);
            else
            {
                tree *fa=now;
                bool which=now->value>key; //第k大 插入时不等号方向相反 
                now=now->son[which];
                if (now==NULL)
                    return now=new tree(key),connect(now,fa,which),splay(root,now);
            }
    }
    inline void find(tree *&root,int key) //找到值为key的数的节点 splay至根 
    {
        tree *now=root;
        if (now==NULL)return;
        while (now->son[now->value>key]&&now->value!=key)
            now=now->son[now->value>key];
        splay(root,now);
    }
    inline tree *precursor(tree *p) //找前驱 只是方便删除操作 
    {
        tree *now=p->son[0];
        while (now->son[1])now=now->son[1];
        return now;
    }
    inline void Delete(tree *&root,int key)
    {
        find(root,key);tree *p=root;
        if (p->son[0]==NULL&&p->son[1]==NULL)return root=NULL,delete p;
        if (p->son[0]==NULL)return (root=p->son[1])->fa=NULL,delete p;
        if (p->son[1]==NULL)return (root=p->son[0])->fa=NULL,delete p;
        tree *pre=precursor(p);splay(root,pre);connect(p->son[1],pre,1);delete p;
    }
    inline int get_rank(tree *&root,int key) //找根为root的Splay中有多少个数比key大 
    {
        tree *now=root;int ranking=0;
        while (now)
            if (now->value<key)now=now->son[0]; //此时符号为< 
            else
            {
                ranking+=now->lsize();
                if (now->value==key)return ranking;
                ranking+=now->cnt;
                now=now->son[1];
            }
        return ranking;
    }
}using namespace Splay;
namespace Segment_Tree
{
    int num[N];
    struct tree
    {
        int l,r,mx,mn; //存区间最大最小值 方便二分(然而并没有快多少233 
        tree *lson,*rson;
        Splay::tree *root;
        inline tree(int L,int R)
        {
            mx=-INF;mn=INF;
            l=L;r=R;
            root=NULL;
            lson=rson=NULL;
        }
        inline void pushup()
        {
            mx=max(lson->mx,rson->mx);
            mn=min(lson->mn,rson->mn);
        }
        void update(int pos,int key) //单点修改 
        {
            Delete(root,w[num[pos]]);insert(root,key); //先删掉旧的再插入新的 
            if (l==r){mx=mn=key;return;}
            int mid=l+r>>1;
            if (pos<=mid)lson->update(pos,key);
            else rson->update(pos,key);
            pushup();
        }
        int query_max(int L,int R)
        {
            if (l>R||r<L)return -INF;
            if (l>=L&&r<=R)return mx;
            return max(lson->query_max(L,R),rson->query_max(L,R));
        }
        int query_min(int L,int R)
        {
            if (l>R||r<L)return INF;
            if (l>=L&&r<=R)return mn;
            return min(lson->query_min(L,R),rson->query_min(L,R));
        }
        int get_rank(int L,int R,int key) //查询[L,R] 中有多少个数比key大 
        {
            if (l>R||r<L)return 0;
            if (l>=L&&r<=R)return Splay::get_rank(root,key);
            return lson->get_rank(L,R,key)+rson->get_rank(L,R,key);
        }
    }*root;
    void build(tree *&p,int l,int r)
    {
        p=new tree(l,r);
        for (int i=l;i<=r;i++)insert(p->root,w[num[i]]);
        if (l==r){p->mx=p->mn=p->root->value;return;}
        int mid=l+r>>1;
        build(p->lson,l,mid);
        build(p->rson,mid+1,r);
        p->pushup();
    }
}using namespace Segment_Tree;
namespace HeavyLight_Decomposition //树剖 
{
    int cnt,dfn[N],top[N],wson[N],dep[N],fa[N],size[N];
    void dfs1(int p)
    {
        size[p]=1;
        for (int i=head[p];i;i=e[i].next)
        {
            int son=e[i].to;
            if (son==fa[p])continue;
            dep[son]=dep[p]+1;fa[son]=p;
            dfs1(son);size[p]+=size[son];
            if (size[son]>size[wson[p]])wson[p]=son;
        }
    }
    void dfs2(int p,int tp)
    {
        top[p]=tp;dfn[p]=++cnt;num[cnt]=p;
        if (wson[p])dfs2(wson[p],tp);
        for (int son,i=head[p];i;i=e[i].next)
            if ((son=e[i].to)!=fa[p]&&son!=wson[p])
                dfs2(son,son);
    }
    inline piii get_extreme(int a,int b) //先找最值方便二分 同时统计两点间距离方便判断k过大的情况 
    {
        int maxw=-INF,minw=INF,x=a,y=b;
        while (top[a]!=top[b])
        {
            if (dep[top[a]]<dep[top[b]])swap(a,b);
            maxw=max(maxw,root->query_max(dfn[top[a]],dfn[a]));
            minw=min(minw,root->query_min(dfn[top[a]],dfn[a]));
            a=fa[top[a]];
        }
        if (dep[a]>dep[b])swap(a,b);
        maxw=max(maxw,root->query_max(dfn[a],dfn[b]));
        minw=min(minw,root->query_min(dfn[a],dfn[b]));
        return make_pair(make_pair(maxw,minw),dep[x]+dep[y]-2*dep[a]+1);
    }
    inline int attempt(int a,int b,int c) //一次check 统计a->b路径中比c大的数的个数 
    {
        int tot=0;
        while (top[a]!=top[b])
        {
            if (dep[top[a]]<dep[top[b]])swap(a,b);
            tot+=root->get_rank(dfn[top[a]],dfn[a],c);
            a=fa[top[a]];
        }
        if (dep[a]>dep[b])swap(a,b);
        return tot+root->get_rank(dfn[a],dfn[b],c);
    }
}using namespace HeavyLight_Decomposition;
inline int query(int a,int b,int k)
{
    piii ex=get_extreme(a,b);
    int l=ex.first.second,r=ex.first.first+1;
    if (ex.second<k)return INF; //如果k比两点间距离还要大 报错 
    while (l<r) 
    {
        int mid=l+r>>1;
        if (attempt(a,b,mid)<k)r=mid; //如果路径间比mid大的个数少于k，那么就需要放小mid 
        else l=mid+1;
    }
    return r;
}
int n,q;
int main()
{
    read(n);read(q);
    for (int i=1;i<=n;i++)read(w[i]);
    for (int a,b,i=1;i<n;i++)
        read(a),read(b),add(a,b),add(b,a);
    dfs1(1);dfs2(1,1);build(root,1,n);
    while (q--)
    {
        int k,a,b,ans;
        read(k);read(a);read(b);
        if (!k)root->update(dfn[a],b),w[a]=b;
        else ans=query(a,b,k),ans<INF?printf("%d\n",ans):puts("invalid request!");
    }
    return 0;
}
```

---

## 作者：orz_z (赞：0)



动态链上第 $k$ 大。考虑树状数组 $+$ 主席树。

树状数组上每一个节点都是一棵主席树。

对于修改，树状数组上区间修改即可，$\mathcal O(\log^2 n)$。

对于查询，差分，主席树求第 $k$ 大，$\mathcal O(\log^2 n)$。

时间复杂度 $\mathcal O(n \log^2 n)$。

```cpp
#include <bits/stdc++.h>

using namespace std;

namespace Fread {
	const int SIZE = 1 << 23;
	char buf[SIZE], *S, *T;
	inline char getchar() {
		if (S == T) {
			T = (S = buf) + fread(buf, 1, SIZE, stdin);
			if (S == T)
				return '\n';
		}
		return *S++;
	}
}
namespace Fwrite {
	const int SIZE = 1 << 23;
	char buf[SIZE], *S = buf, *T = buf + SIZE;
	inline void flush() {
		fwrite(buf, 1, S - buf, stdout);
		S = buf;
	}
	inline void putchar(char c) {
		*S++ = c;
		if (S == T)
			flush();
	}
	struct NTR {
		~NTR() {
			flush();
		}
	} ztr;
}

#ifdef ONLINE_JUDGE
	#define getchar Fread::getchar
	#define putchar Fwrite::putchar
#endif

inline int read() {
	int x = 0, f = 1;
	char c = getchar();
	while (c < '0' || c > '9') {
		if (c == '-')
			f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9')
		x = x * 10 + c - '0', c = getchar();
	return x * f;
}

inline void write(int x) {
	if (x < 0) {
		putchar('-');
		x = -x;
	}
	if (x > 9)
		write(x / 10);
	putchar(x % 10 + '0');
}

const int _ = 1e5 + 10;

int n, m, cnt, len, a[_], b[_];

int tot, head[_], to[_ << 1], nxt[_ << 1];

int lc[_ * 200], rc[_ * 200], sum[_ * 200];

int rt[_], dep[_], fa[_][20], dfc, st[_], ed[_];

int c[2], tmp[2][_];

struct que {
	int k, a, b;
} q[_];

inline void add(int u, int v) {
	to[++tot] = v, nxt[tot] = head[u], head[u] = tot;
	to[++tot] = u, nxt[tot] = head[v], head[v] = tot;
}

void update(int &u, int l, int r, int pos, int val) {
	if (!u) u = ++cnt;
	sum[u] += val;
	if (l == r) return;
	int mid = (l + r) >> 1;
	if (pos <= mid) update(lc[u], l, mid, pos, val);
	else update(rc[u], mid + 1, r, pos, val);
}

int query(int l, int r, int k) {
	if (l == r) return l;
	int mid = (l + r) >> 1, s = 0;
	for (int i = 1; i <= c[0]; ++i) s += sum[lc[tmp[0][i]]];
	for (int i = 1; i <= c[1]; ++i) s -= sum[lc[tmp[1][i]]];
	if (k <= s) {
		for (int i = 1; i <= c[0]; ++i) tmp[0][i] = lc[tmp[0][i]];
		for (int i = 1; i <= c[1]; ++i) tmp[1][i] = lc[tmp[1][i]];
		return query(l, mid, k);
	} else {
		for (int i = 1; i <= c[0]; ++i) tmp[0][i] = rc[tmp[0][i]];
		for (int i = 1; i <= c[1]; ++i) tmp[1][i] = rc[tmp[1][i]];
		return query(mid + 1, r, k - s);
	}
}

void dfs(int x) {
	for (int i = 1; i < 20; ++i) fa[x][i] = fa[fa[x][i - 1]][i - 1];
	dep[x] = dep[fa[x][0]] + 1, st[x] = ++dfc;
	for (int i = head[x]; i; i = nxt[i]) {
		int v = to[i];
		if (v == fa[x][0]) continue;
		fa[v][0] = x;
		dfs(v);
	}
	ed[x] = dfc;
}

int LCA(int x, int y) {
	if (dep[x] < dep[y]) swap(x, y);
	int t = dep[x] - dep[y];
	for (int i = 0; i < 20; ++i)
		if (t & (1 << i)) x = fa[x][i];
	if (x == y) return x;
	for (int i = 19; ~i; --i)
		if (fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];
	return fa[x][0];
}

inline int lowbit(int x) {
	return x & (-x);
}

inline void change(int pos, int val, int op) {
	for (; pos <= n; pos += lowbit(pos)) update(rt[pos], 1, len, val, op);
}

signed main() {
	n = read(), m = read(), len = n;
	for (int i = 1; i <= n; ++i) a[i] = b[i] = read();
	for (int i = 1; i < n; ++i) add(read(), read());
	for (int i = 1; i <= m; ++i) {
		q[i].k = read(), q[i].a = read(), q[i].b = read();
		if (!q[i].k) b[++len] = q[i].b;
	}
	sort(b + 1, b + len + 1), len = unique(b + 1, b + len + 1) - b - 1;
	for (int i = 1; i <= n; ++i) a[i] = lower_bound(b + 1, b + len + 1, a[i]) - b;
	dfs(1);
	for (int i = 1; i <= n; ++i) change(st[i], a[i], 1), change(ed[i] + 1, a[i], -1);
	for (int i = 1; i <= m; ++i) {
		int x = q[i].a, y = q[i].b, k = q[i].k, lca, flca, s;
		if (k) {
			lca = LCA(x, y), flca = fa[lca][0], c[0] = c[1] = 0;
			s = dep[x] + dep[y] - dep[lca] - dep[flca];
			if (k > s) {
				printf("invalid request!\n");
				continue;
			}
			for (int i = st[x]; i; i -= lowbit(i)) tmp[0][++c[0]] = rt[i];
			for (int i = st[y]; i; i -= lowbit(i)) tmp[0][++c[0]] = rt[i];
			for (int i = st[lca]; i; i -= lowbit(i)) tmp[1][++c[1]] = rt[i];
			for (int i = st[flca]; i; i -= lowbit(i)) tmp[1][++c[1]] = rt[i];
			printf("%d\n", b[query(1, len, s - k + 1)]);
		} else {
			change(st[x], a[x], -1), change(ed[x] + 1, a[x], 1);
			a[x] = lower_bound(b + 1, b + len + 1, y) - b;
			change(st[x], a[x], 1), change(ed[x] + 1, a[x], -1);
		}
	}
	return 0;
}
```

---

## 作者：2018LZY (赞：0)

数据结构题.

# 方法1
树状数组+主席树+树剖->$O(n\log^3 n)$

先用树剖剖出树的重链,然后我们就可以把重链推成一个区间.

树状数组维护遍历位置,主席树维护数.

修改->$O(n*\log^2 n)$.

查询->用树剖找出对应的区间($\log n$个),剥离出树状数组的节点($\log^2n$个),最后整体二分($\log n)$.


```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<algorithm>
#define gc getchar()//(p1==p2&&(p2=(p1=buf)+fread(buf,1,size,stdin),p1==p2)?EOF:*p1++)
#define lc tr[x].l
#define rc tr[x].r
using namespace std;
const int N=1e5+10,size=1<<20;

//char buf[size],*p1=buf,*p2=buf;
template<class o> void qr(o &x) {
	x=0; int f=1; char c=gc;
	while(!isdigit(c)){if(c=='-')f=-1; c=gc;}
	while(isdigit(c))x=x*10+c-'0',c=gc;
	x*=f;
}
template<class o> void qw(o x) {
	if(x<0) putchar('-'),x=-x;
	if(x>9) qw(x/10);
	putchar(x%10+'0');
}
template<class o> void pr2(o x) {qw(x); puts("");}

int n,m,t[N],b[N<<1],num,fa[N],dep[N],son[N],sz[N];
struct edge{int y,next;}a[N<<1]; int len,last[N];
void ins(int x,int y) {a[++len]=(edge){y,last[x]};last[x]=len;}

void dfs1(int x) {
	sz[x]=1;
	for(int k=last[x],y;k;k=a[k].next)
		if((y=a[k].y)^fa[x]) {
			fa[y]=x;
			dep[y]=dep[x]+1;
			dfs1(y);
			if(sz[y]>sz[son[x]]) son[x]=y;
			sz[x]+=sz[y];
		}
}

int z,id[N],top[N];
void dfs2(int x,int tp) {
	id[x]=++z; top[x]=tp;
	if(son[x]) dfs2(son[x],tp);
	for(int k=last[x],y;k;k=a[k].next)  {
		y=a[k].y;
		if(y!=fa[x]&&y!=son[x]) dfs2(y,y);
	}
}

struct node{int l,r,s;}tr[N*150]; int cnt,root[N],sta[N],tp;
void update(int &x,int l,int r,int pos,int d) {
	if(!x) x=tp?sta[tp--]:++cnt;
	tr[x].s+=d;
	if(l^r) {
		int mid=(l+r)>>1;
		if(pos<=mid) update(lc,l,mid,pos,d);
		else 		 update(rc,mid+1,r,pos,d);
	}
	if(!tr[x].s) sta[++tp]=x,x=0;
}
void add(int x,int pos,int d) {for(	;x<=n;x+=x&-x) update(root[x],1,num,pos,d);}

int u[444],v[444];
void get(int x,int y) {//dep[x]>dep[y],且两点在同一链上
	for(int i=id[x]	 ;i;i&=i-1) u[++u[0]]=root[i];
	for(int i=id[y]-1;i;i&=i-1) v[++v[0]]=root[i];
}

void left (int *a) {for(int i=1;i<=a[0];i++) a[i]=tr[a[i]].l;}
void right(int *a) {for(int i=1;i<=a[0];i++) a[i]=tr[a[i]].r;}

void solve(int x,int y,int k) {
	int z=0; u[0]=v[0]=0;
	while(top[x]^top[y]) {
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		get(x,top[x]); z+=dep[x];
		x=fa[top[x]];  z-=dep[x];
	}
	if(id[x]<id[y]) swap(x,y);
	get(x,y); z+=dep[x]-dep[y]+1;
	if(k>z) puts("invalid request!");
	else {
		int l=1,r=num,mid;
		while(l<r) {
			mid=(l+r)>>1; z=0;
			for(int i=1;i<=u[0];i++) z+=tr[tr[u[i]].r].s;
			for(int i=1;i<=v[0];i++) z-=tr[tr[v[i]].r].s;
			if(k<=z) right(u),right(v),l=mid+1;
			else k-=z,left(u),left(v),r=mid;
		}
		pr2(b[l]);
	}
}

struct rec {
	int k,x,y;
} q[N]; 

int main() {
	qr(n); qr(m); for(int i=1;i<=n;i++) qr(t[i]),b[++num]=t[i];
	for(int i=1,x,y;i<n;i++) qr(x),qr(y),ins(x,y),ins(y,x);
	for(int i=1;i<=m;i++) {
		qr(q[i].k); qr(q[i].x); qr(q[i].y);
		if(!q[i].k) b[++num]=q[i].y;
	}
	sort(b+1,b+num+1); num=unique(b+1,b+num+1)-(b+1);
	for(int i=1;i<=n;i++) t[i]=lower_bound(b+1,b+num+1,t[i])-b;
	dep[1]=1; fa[1]=0; dfs1(1); dfs2(1,1); 
	for(int i=1;i<=n;i++) add(id[i],t[i],1);
	for(int i=1,k,x,y;i<=m;i++) {
		k=q[i].k; x=q[i].x; y=q[i].y;
		if(!k) add(id[x],t[x],-1),add(id[x],t[x]=lower_bound(b+1,b+num+1,y)-b,1);
		else solve(x,y,k);
	}
	return 0;
}

```
# 方法2
树上带修莫队->$O(n^\frac 3 5)$.

资瓷查询操作的可用树状数组倍增,亦可用分块暴力(总共才$m\sqrt n$).

代码懒得打了.

---

## 作者：shiroi (赞：0)

题目需要维护支持单点修改的树上路径第K大。

对于树上路径问题只需要将其用树剖转化为序列问题，然后直接利用数据结构维护区间序列就可以了。

用二分+树链剖分+线段树套平衡树，总时间复杂度带四个log，勉强可以卡过。

需要注意的是一定要对权值进行哈希来离散化，以此减少枚举范围。

代码量不算小，需要注意的细节比较多。

这里使用vector存图+treap维护树套树。

```cpp
#include <bits/stdc++.h>
using namespace std;

inline int read()
{
	int x=0; int f=1; char ch=getchar();
	while(!isdigit(ch)) {if(ch=='-')f=-1; ch=getchar();}
	while(isdigit(ch)) {x=x*10+ch-'0'; ch=getchar();}
	return x*f;
}

const int MAXM = 5000005;
const int MAXN = 100005;
std::vector<int> G[MAXN];
int tree[MAXN],mp[MAXN],f[MAXN],a[MAXN],b[MAXN];
int fa[MAXN][17],son[MAXN],dep[MAXN],top[MAXN],dfn[MAXN];
int root[MAXN<<2],w[MAXM],v[MAXM],s[MAXM],rnd[MAXM];
int ls[MAXM],rs[MAXM];
int bin[20],vis[MAXN];
int n,q,tot,cnt,size,tmp;

inline void addedge(int u,int v)
{
	G[u].push_back(v);
	G[v].push_back(u);
}

inline int find(int x)
{
	int l=1,r=tot;
	while(l<=r)
	{
		int mid=l+r>>1;
		if(mp[mid]<x) l=mid+1;
		else if(mp[mid]==x) return mid;
		else r=mid-1;
	}
	return l;
}

void dfs_getson(int x)
{
	son[x]=1; vis[x]=1;
	for(int i = 1; i <= 16; ++i)
	{
		if(bin[i]<=dep[x])
			fa[x][i]=fa[fa[x][i-1]][i-1];
		else break;
	}
	int sz=G[x].size();
	for (int i = 0; i < sz; ++i)
	{
		int y=G[x][i];
		if(vis[y])continue;
		dep[y]=dep[x]+1; fa[y][0]=x;
		dfs_getson(y);
		son[x]+=son[y];
	}
}

void dfs_rewrite(int x,int tp)
{
	dfn[x]=++cnt; top[x]=tp;
	int sz=G[x].size(),k=0;
	for (int i = 0; i < sz; ++i)
	{
		int y=G[x][i];
		if(son[y]>son[k] && dep[y]>dep[x]) k=y;
	}
	if(!k) return;
	dfs_rewrite(k,tp);
	for (int i = 0; i < sz; ++i)
	{
		int y=G[x][i];
		if(y!=k && dep[y]>dep[x])
			dfs_rewrite(y,y);
	}
}

inline int lca(int x,int y)
{
	if(dep[x]<dep[y]) swap(x,y);
	int t=dep[x]-dep[y];
	for(int i = 0; i <= 16; i++)
		if(bin[i]&t) x=fa[x][i];
	for(int i = 16; i >= 0; i--)
		if(fa[x][i]!=fa[y][i])
			x=fa[x][i],y=fa[y][i];
	if(x==y) return x;
	return fa[x][0];
}

inline void update(int k)
{s[k]=s[ls[k]]+s[rs[k]]+w[k];}

inline void rturn(int &k)
{
	int t=ls[k]; ls[k]=rs[t]; rs[t]=k;
	update(k); update(t); k=t;
}

inline void lturn(int &k)
{
	int t=rs[k]; rs[k]=ls[t]; ls[t]=k;
	update(k); update(t); k=t;
}

void insert(int &k,int val)
{
	if(!k)
	{
		k=++size; rnd[k]=rand();
		w[k]=s[k]=1; v[k]=val;
		return;
	}
	s[k]++;
	if(val==v[k]) { w[k]++; return;}
	else if(val<v[k])
	{
		insert(ls[k],val);
		if(rnd[ls[k]]<rnd[k]) rturn(k);
	}
	else
	{
		insert(rs[k],val);
		if(rnd[rs[k]]<rnd[k]) lturn(k);
	}
}

void del(int &k,int val)
{
	if(!k) return;
	if(val==v[k])
	{
		if(w[k]>1) { w[k]--,s[k]--; return;}
		if(ls[k]*rs[k]==0) k=ls[k]+rs[k];
		else if(rnd[ls[k]]<rnd[rs[k]])
			rturn(k),del(k,val);
		else lturn(k),del(k,val);
	}
	else if(val<v[k])
		del(ls[k],val),s[k]--;
	else del(rs[k],val),s[k]--;
}

void askrank(int k,int val)
{
	if(!k)return;
	if(val==v[k]) { tmp+=s[rs[k]]; return;}
	else if(val<v[k])
		tmp+=s[rs[k]]+w[k],askrank(ls[k],val);
	else askrank(rs[k],val);
}

void change(int k,int l,int r,int p,int ql,int qr)
{
	del(root[k],ql); insert(root[k],qr);
	if(l==r) return;
	int mid=l+r>>1;
	if(p<=mid) change(k<<1,l,mid,p,ql,qr);
	else change(k<<1|1,mid+1,r,p,ql,qr);
}

void ask(int k,int l,int r,int ql,int qr,int val)
{
	if(ql==l&&qr==r) {askrank(root[k],val); return;}
	int mid=l+r>>1;
	if(qr<=mid) ask(k<<1,l,mid,ql,qr,val);
	else if(ql>mid) ask(k<<1|1,mid+1,r,ql,qr,val);
	else
	{
		ask(k<<1,l,mid,ql,mid,val);
		ask(k<<1|1,mid+1,r,mid+1,qr,val);
	}
}

inline void query_rank(int x,int f,int val)
{
	while(top[x]!=top[f])
	{
		ask(1,1,n,dfn[top[x]],dfn[x],val);
		x=fa[top[x]][0];
	}
	ask(1,1,n,dfn[f],dfn[x],val);
}

inline void solve(int x,int y,int rank)
{
	int t=lca(x,y),ans=-1; tmp=0;
	query_rank(y,t,0); query_rank(x,t,0);
	if(tmp-1<rank) {puts("invalid request!"); return;}
	int l=1,r=tot;
	while(l<=r)
	{
		int mid=l+r>>1; tmp=0;
		query_rank(x,t,mid); query_rank(y,t,mid);
		if(tree[t]>mid) tmp--;
		if(tmp<=rank-1) r=mid-1,ans=mid;
		else l=mid+1;
	}
	printf("%d\n",mp[ans]);
}

int main(int argc, char const *argv[])
{
	n=read(); q=read(); bin[0]=1;
	for(int i = 1; i <= 16; ++i)
		bin[i]=(bin[i-1]<<1);
	for(int i = 1; i <= n; ++i)
		tree[i]=read(),mp[++tot]=tree[i];
	for(int i = 1; i < n; ++i)
	{
		int u=read(),v=read();
		addedge(u,v);
	}
	dfs_getson(1);
	dfs_rewrite(1,1);
	for(int i = 1; i <= q; ++i)
	{
		f[i]=read(),a[i]=read(),b[i]=read();
		if(!f[i]) mp[++tot]=b[i];
	}
	sort(mp+1,mp+tot+1);
	int top=1;
	for(int i = 2; i <= tot; ++i)
		if(mp[i]!=mp[i-1])
			mp[++top]=mp[i];
	tot=top;
	for(int i = 1; i <= n; ++i)
		tree[i]=find(tree[i]);
	for(int i = 1; i <= q; ++i)
		if(!f[i]) b[i]=find(b[i]);
	for(int i = 1; i <= n; ++i)
		change(1,1,n,dfn[i],0,tree[i]);
	for(int i = 1; i <= q; ++i)
	{
		if(!f[i])
		{
			change(1,1,n,dfn[a[i]],tree[a[i]],b[i]);
			tree[a[i]]=b[i];
		}
		else solve(a[i],b[i],f[i]);
	}
	return 0;
}
```

---

## 作者：Thomasguo666 (赞：0)

更好（zao）的阅读体验，请猛戳：
[link](https://thomasguo666.github.io/post/solution-P4175/)

首先，看到这种区间 $k$ 大值查询的题，还不强制在线，那一般可以整体二分~~乱搞~~。

如果你不会整体二分，出门右转 Dynamic Rankings（当然下面也会就这题具体说明一下）。

所以我们模拟一遍所有的修改，同时把每个修改操作改成删去一个数再加上一个数。

注意到这题是树上的问题，所以要个树链剖分。

因为我写习惯了 $k$ 小值，所以这里用 $1e8$ 减去每个权值。

然后我们用树状数组维护小于等于 $mid$ 的数有多少个。如果一个修改操作修改成的数不超过 $mid$ ，那么就执行这次操作，并且把它加到操作序列 $q_1$ 里去，否则加到 $q_2$ 里去。对于一个询问操作 ${k,l,r}$ ，如果 $[l,r]$ 中不超过 $mid$ 的数大于等于 $k$ 个，就把它放到 $q_1$ 里去，否则把 $k$ 减去不超过 $mid$ 的数的个数，再加到 $q_2$ 里去。这样 $q_1$ 与 $q_2$ 实际上变为了两个规模更小的子问题，递归处理掉就好了（当然进入下一层递归之前要把这一层递归中做的操作撤销掉）

代码：（复杂度 $O(nlog^3n)$ ）

```cpp
#include <bits/stdc++.h>
#define debug printf("Running %s on line %d...\n",__FUNCTION__,__LINE__)
#define in inline
#define re register
using namespace std;
typedef long long ll;
typedef double db;
in int read()
{
    int ans=0,f=1;char c=getchar();
    for (;!isdigit(c);c=getchar()) if (c=='-') f=-1;
    for (;isdigit(c);c=getchar()) ans=(ans<<3)+(ans<<1)+(c^48);
    return ans*f;
}
int a[300005];
int n,m;
int head[100005],tail[200005],nex[200005];
in void addedge(int u,int v,int k)
{
    nex[k]=head[u];
    head[u]=k;
    tail[k]=v;
}
int fa[100005],sz[100005],son[100005],top[100005],l[100005],dep[100005];
void dfs1(int u)
{
    sz[u]=1;
    for (int e=head[u];e;e=nex[e])
    {
        int v=tail[e];
        if (v==fa[u]) continue;
        fa[v]=u,dep[v]=dep[u]+1;
        dfs1(v),sz[u]+=sz[v];
        if (sz[v]>sz[son[u]]) son[u]=v;
    }
}
int tot;
void dfs2(int u,int topf)
{
    top[u]=topf,l[u]=++tot;
    if (!son[u]) return;
    dfs2(son[u],topf);
    for (int e=head[u];e;e=nex[e])
    {
        int v=tail[e];
        if (v==fa[u]||v==son[u]) continue;
        dfs2(v,v);
    }
}
struct data
{
    int l,r,v,p,id;
    data () {}
    data (int l,int r,int v,int p,int id):l(l),r(r),v(v),p(p),id(id) {}
} q[400005],q1[400005],q2[400005];
int ans[100005];
int cnt1,cnt2;
int t[400005];
void add(int x,int v)
{
    for (;x<=n;x+=x&(-x)) t[x]+=v;
}
int sum(int x)
{
    int s=0;
    for (;x;x-=x&(-x)) s+=t[x];
    return s;
}
int query(int x,int y)
{
    int ans=0;
    while (top[x]!=top[y])
    {
        if (dep[top[x]]<dep[top[y]]) swap(x,y);
        ans+=sum(l[x])-sum(l[top[x]]-1);
        x=fa[top[x]];
    }
    if (dep[x]>dep[y]) swap(x,y);
    ans+=sum(l[y])-sum(l[x]-1);
    return ans;
}
void solve(int tl,int tr,int ql,int qr)
{
    if (ql>qr) return;
    if (tl==tr)
    {
        for (int i=ql;i<=qr;i++) ans[q[i].id]=tl;
        return ;
    }
    int mid=tl+tr>>1,j=0,k=0;
    for (int i=ql;i<=qr;i++)
    {
        if (!q[i].id)
        {
            if (q[i].v<=mid)
            {
                add(l[q[i].l],q[i].p);
                q1[++j]=q[i];
            }
            else q2[++k]=q[i];
        }
        else
        {
            int s=query(q[i].l,q[i].r);
            if (s<q[i].v) q[i].v-=s,q2[++k]=q[i];
            else q1[++j]=q[i];
        }
    }
    for (int i=1;i<=j;i++) if (!q1[i].id) add(l[q1[i].l],-q1[i].p);
    for (int i=1;i<=j;i++) q[ql+i-1]=q1[i];
    for (int i=1;i<=k;i++) q[ql+i+j-1]=q2[i];
    solve(tl,mid,ql,ql+j-1),solve(mid+1,tr,ql+j,qr);
}
int main()
{
    n=read(),m=read();
    for (int i=1;i<=n;i++) a[i]=read();
    for (int i=1;i<n;i++)
    {
        int u=read(),v=read();
        addedge(u,v,i<<1);
        addedge(v,u,i<<1|1);
    }
    dfs1(1);
    dfs2(1,0);
    for (int i=1;i<=n;i++) q[++cnt1]=data(i,0,1e8-a[i],1,0);
    for (int i=1;i<=m;i++)
    {
        int k=read(),l=read(),r=read();
        if (k)
        {
            q[++cnt1]=data(l,r,k,0,++cnt2);
        }
        else
        {
            q[++cnt1]=data(l,0,1e8-a[l],-1,0);
            q[++cnt1]=data(l,0,1e8-(a[l]=r),1,0);
        }
    }
    solve(0,1e8,1,cnt1);
    for (int i=1;i<=cnt2;i++) ((1e8-ans[i])?cout<<int(1e8-ans[i])<<endl:cout<<"invalid request!"<<endl);
    return 0;
}

```





---

## 作者：Kinandra (赞：0)

1. 标签: 树套树, 树上差分.

2. 这道题切入点在于一个树上差分, 考虑一个简单些的问题:在点数为$n$树上支持查询点到根的路径上点的权值和.不需要支持修改
	
    考虑用dfs求点到根路径长度的过程:从根开始dfs, 到达某个点时答案加上当前点的权值$v$. 如果当前点为询问点, 返回案; 否则在该点的子树内继续搜索, 如果询问点不在子树内, 答案减去$v$并返回.

	发现答案就是一个进加-返减的过程, 如果我们把所有点拆$pre$点和$pst$点, 分别表示进入和返回的状态, 权值分别$v,-v$, 按照进入/返回的发生顺序排序(实际上就是树的**欧拉序**), 维护前缀和, 易得个点到根的权值和.

3. 需要支持修改的话, 就用树状数组/线段树维护一下就了. 若要支持任意路径权值和也只需要求一下路径两端的LCA,简单搞一下就好.
4. 考虑如何维护路径第$K$大.不修改.

	对每一个点维护一棵权值线段树, 因为$pre$点表示当前点权出次数(即权值)$+1$, $pst$点表示$-1$, 所以对应值的权值分为$+1$和$-1$.那么同样只要维护一个前缀(实际上就是一颗主树)就可以做了.
    
	想支持修改的话同样用树状数组/线段树套一下就好了.(温馨提示, 外层用线段树会MLE).
5. 复杂度$\mathcal O(nlog^2n)$.

```cpp
#include <iostream>
#include <cstdio>
#include <map>
#include <vector>
#include <algorithm>
using namespace std;

int read() {
    int x = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9') {
        if (c == '-') f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9') {
        x = x * 10 + c - '0';
        c = getchar();
    }
    return x * f;
}

int head[200005], nxt[400005], to[400005], cnt;
void add(int f, int t) {
    nxt[++cnt] = head[f];
    head[f] = cnt;
    to[cnt] = t;
    return ;
}

int fa[200005][20], dep[200005], pre[200005], pst[200005], dfn;
void dfs(int u) {
    pre[u] = ++dfn;
    for (int i = head[u]; i; i = nxt[i]) {
        int v = to[i];
        if (v == fa[u][0]) continue;
        fa[v][0] = u;
        dep[v] = dep[u] + 1;
        dfs(v);
    }
    pst[u] = ++dfn;
    return ;
}

map<int, int> mp;
int a[200005], st[400005], stcnt;

int root[400005], idcnt;
int ls[15000007], rs[15000007], tval[15000007];
int v[4][102], cv[4];

struct Pseg {
    int isrt(int l, int r, int k, int pos, int val) {
        if (!k) k = ++idcnt;
        tval[k] += val;
        if (l == r) return k;
        int mid = l + r >> 1;
        if (pos <= mid) ls[k] = isrt(l, mid, ls[k], pos, val);
        else rs[k] = isrt(mid + 1, r, rs[k], pos, val);
        return k;
    }
} t[400005];

void isrt(int k, int pos, int val) {
    for (; k <= dfn; k += (-k) & k) root[k] = t[k].isrt(1, stcnt, root[k], pos, val);
    return ;
}

int lca(int u, int v) {
    if (dep[u] < dep[v]) swap(u, v);
    for (int i = 18; i >= 0; --i) if (dep[fa[u][i]] >= dep[v]) u = fa[u][i];
    if (u == v) return u;
    for (int i = 18; i >= 0; --i) if (fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];
    return fa[u][0];
}

struct P {
    int k, a, b;
} p[200005];

int gt(int i) {
    return i < 2 ? 1 : -1;
}

int main() {
    int n = read(), Q = read();
    for (int i = 1; i <= n; ++i) {
        a[i] = read();
        if (!mp[a[i]]) st[++stcnt] = a[i], mp[a[i]] = 1;
    }
    for (int i = 1; i < n; ++i) {
        int u = read(), v = read();
        add(u, v);
        add(v, u);
    }

    for (int i = 1; i <= Q; ++i) {
        p[i].k = read(), p[i].a = read(), p[i].b = read();
        if (!p[i].k && !mp[p[i].b]) st[++stcnt] = p[i].b, mp[p[i].b] = 1;
    }
    sort(st + 1, st + 1 + stcnt);
    for (int i = 1; i <= stcnt; ++i) mp[st[i]] = i;

    dep[1] = 1;
    dfs(1);
    for (int i = 1; i <= 18; ++i)
        for (int j = 1; j <= n; ++j)
            fa[j][i] = fa[fa[j][i - 1]][i - 1];

    for (int i = 1; i <= n; ++i) {
        int tmp = mp[a[i]];
        isrt(pre[i], tmp, 1);
        isrt(pst[i], tmp, -1);
    }

    for (int id = 1; id <= Q; ++id) {
        int u[4] = {p[id].a, p[id].b};
        int k = p[id].k;
        if (!k) {
            int v1 = mp[a[u[0]]], v2 = mp[u[1]];
            isrt(pre[u[0]], v1, -1);
            isrt(pre[u[0]], v2, 1);
            isrt(pst[u[0]], v1, 1);
            isrt(pst[u[0]], v2, -1);
            a[u[0]] = u[1];
            continue;
        }
        u[2] = lca(u[0], u[1]);
        u[3] = fa[u[2]][0];
        k--;
        for (int i = 0; i < 4; ++i) {
            cv[i] = 0;
            for (int j = pre[u[i]]; j; j -= (-j) & j) v[i][++cv[i]] = root[j];
        }
        int tmp = 0;
        for (int i = 0; i < 4; ++i) {
            for (int j = 1; j <= cv[i]; ++j) tmp += tval[v[i][j]] * gt(i);
        }
        if (tmp <= k) {
            puts("invalid request!");
            continue;
        }

        int l = 1, r = stcnt;
        while (l != r) {
            tmp = 0;
            int mid = l + r >> 1;
            for (int i = 0; i < 4; ++i) for (int j = 1; j <= cv[i]; ++j) tmp += tval[rs[v[i][j]]] * gt(i);

            if (tmp > k) {
                l = mid + 1;
                for (int i = 0; i < 4; ++i) for (int j = 1; j <= cv[i]; ++j) v[i][j] = rs[v[i][j]];
            } else {
                r = mid, k -= tmp;
                for (int i = 0; i < 4; ++i) for (int j = 1; j <= cv[i]; ++j) v[i][j] = ls[v[i][j]];
            }
        }
        printf("%d\n", st[l]);
    }
    return 0;
}
```


---


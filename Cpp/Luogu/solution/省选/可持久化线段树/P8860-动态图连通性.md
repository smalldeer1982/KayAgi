# 动态图连通性

## 题目描述

给定一张 $n$ 点 $m$ 边的**有向图**，初始时存在一条从 $1$ 到 $n$ 的路径。  

你需要处理 $q$ 组询问，每组询问给定一个 $[1,m]$ 中的正整数 $x$，如果原图中的第 $x$ 条边仍存在且当前的图中删去原图中的第 $x$ 条边后仍有一条从 $1$ 到 $n$ 的路径，则删除原图中的第 $x$ 条边。  

你需要报告每组询问中是否删去了第 $x$ 条边。 

**请注意：一组询问中删除某条边后，这条边会被永远删除。也就是询问之间会相互影响。**

## 说明/提示

#### 【样例解释】

在第一组样例中：

初始时，图中边集为 $\{ (1,2),(2,3),(3,5),(2,4),(4,5),(5,1) \}$。

若删去原图中的第 $1$ 条边 $(1,2)$，图中就没有 $1$ 到 $n$ 的路径，所以不能删除第 $1$ 条边。

若删去原图中的第 $2$ 条边 $(2,3)$，图中存在路径 $1 \to 2 \to 4 \to 5$，所以可以删去第 $2$ 条边，图中边集变为 $\{ (1,2),(3,5),(2,4),(4,5),(5,1) \}$。

若删去原图中的第 $3$ 条边 $(3,5)$，图中存在路径 $1 \to 2 \to 4 \to 5$，所以可以删去第 $3$ 条边，图中边集变为 $\{ (1,2),(2,4),(4,5),(5,1) \}$。

若删去原图中的第 $4$ 条边 $(2,4)$，图中就没有 $1$ 到 $n$ 的路径，所以不能删除第 $4$ 条边。

若删去原图中的第 $5$ 条边 $(4,5)$，图中就没有 $1$ 到 $n$ 的路径，所以不能删除第 $5$ 条边。

#### 【数据范围】

|  测试点编号  |    $n,m \leq$   |     $q \leq$    |            特殊限制           |
|:------------:|:---------------:|:---------------:|:-------------------------------:|
|  $1 \sim 2$  |      $1000$     |      $1000$     |                无               |
|  $3 \sim 6$  |      $5000$     | $2 \times 10^5$ |                无               |
|  $7 \sim 8$  | $2 \times 10^5$ | $2 \times 10^5$ | 保证所有询问中最多有 $1$ 条边没有被删除 |
| $9 \sim 12$ | $2 \times 10^5$ | $2 \times 10^5$ | 保证所有询问中最多有 $5$ 条边没有被删除 |
| $13 \sim 16$ | $2 \times 10^5$ | $2 \times 10^5$ |         将有向图视作无向图仍能得到正确答案        |
| $17 \sim 20$ | $2 \times 10^5$ | $2 \times 10^5$ |                无               |

对于所有数据，$1 \leq n,m,q \leq 2 \times 10^5$，给定的图无重边、自环，且存在一条 $1$ 到 $n$ 的路径。

**给出的两组大样例分别满足测试点 1 和测试点 13 的限制。**

## 样例 #1

### 输入

```
5 6 5
1 2
2 3
3 5
2 4
4 5
5 1
1
2
3
4
5```

### 输出

```
0
1
1
0
0
```

## 样例 #2

### 输入

```
10 11 8
1 2
2 7
2 5
1 4
4 5
4 8
8 9
9 5
3 2
3 6
5 10
10
5
11
10
3
7
1
4
```

### 输出

```
1
1
0
0
1
0
1
0```

# 题解

## 作者：_rqy (赞：64)

先说一点题外话. 原本以为开放题解之后就会有人来提交简单题解, 没想到一个星期过去了还是各种主席树云云. 明明这题没那么麻烦. 或者说有简单的做法, 虽然正确性还是需要一点思考.

## 题意

有一张 $n$ 点 $m$ 边有向图, $q$ 次修改. 每次修改是给出原图中一条边, 如果把它删掉之后仍然存在 $1$ 到 $n$ 的道路, 则把它删掉, 否则什么都不做. 如果这条边已经被删掉了, 那么也什么都不做.

你需要对每次修改输出是否删掉了这条边. $n, m, q \leqslant 2 \times 10^5$.

## 分析与解答

我们是一定要离线做的 (不然就真的是动态图连通性了, 约等于不能做).

首先我们发现, 如果一条边被多次试图删除, 那么后面那次肯定是没有用的.

因为如果第一次删除它就成功删除, 那么第二次删除的时候会什么都不做.
如果第一次删除它发现没法删除, 那说明它是从 $1$ 到 $n$ 的必经之路.
而整个修改过程中边只会越来越少, 所以第二次删除的时候它一定也是必经之路.
因此第二次也不会删除它.

综上所述, 我们可以假设每条边只会被删除一次. 设第 $i$ 条边被删除的时间是 $d_i$. 如果没被删除过, 就设 $d_i = \infty$ 或者说 $d_i = q + 1$.

我们来考虑所有修改都执行完毕之后, 还剩下的从 $1$ 到 $n$ 的路径是哪一条.
如果我们能求出这条路径, 那么在路径上的边都不会被删除, 不在路径上的边都会被删除 (因为删了还是有这条路径).

这条路径应该满足什么性质呢?

首先, 比较容易看出来的是, 这条路径上 $d_i$ 最小的边要尽量大.
因为我们如果把所有的从 $1$ 到 $n$ 的路径都列出来, 那么最先走不通的是最小 $d_i = 1$ 的路径, 然后是最小 $d_i = 2$ 的路径, 依此类推,
最后只剩下最小 $d_i$ 最大的这些路径.

其次, 在所有这样的路径中, $d_i$ 次小的边也要尽量大. 道理和之前相同.

依此类推, 我们可以把比较的规则总结为: 把每条路径上的边的 $d_i$ 从小到大排列, 我们需要找到得到的排列字典序最大的路径.

我们设 $P_i$ 是从 $1$ 到 $i$ 的最优路径,
定义两条路径之间的大小就是上面的比较方法,
也就是说把经过的 $d_i$ 从小到大排序后比较字典序.

如果我们截止到这一步, 那么可以把每条路径的边权, 或者说“排列”, 用主席树存储来比较, 详见其他题解. 不过事实上我们有更容易的方法.

_如果你不想看证明或者想自己思考证明, 请跳到下面加粗的**综上所述**的位置_.

为了叙述方便, 我们想象, 这个问题相当于把每条边的边权定为 $10^{q-d_i}$, 然后选取最短路. 对那些每删除的边, 我们设边权是 $0$. 比如说 $q = 4$,

> 如果我们经过了 $d_i = 2, 3$ 的边, 路径长就是 $110$.
>
> 如果我们经过了 $d_i = 2, 4$ 的边, 路径长就是 $101$, 比前面那个短.

我们使用 Dijkstra 算法, 设 $1$ 到 $i$ 的最短路长度为 $dis_i$. 不过我们不可能真的用高精把这个东西算出来, 只是方便我们分析.

假设 Dijkstra 进行到某个时刻.
我们要考虑那些起点已经被扩展出来, 终点还没有被扩展出来的边,
选取其中 $dis_{\text{起点}} + 10^{q-d}$ 最小的一个, 并以此扩展其终点.

由于这个原因, 我们需要比较两条边的 $dis_{s_1} + 10^{q-d_1}$ 和 $dis_{s_2} + 10^{q-d_2}$ 的大小.

- 如果 $s_1 = s_2$, 显然我们只需要比较 $d_1$ 和 $d_2$.
- 否则, 我们假设 $dis_{s_1} < dis_{s_2}$ (反过来也一样, 我就不写两遍了).
- 由于 Dijkstra 是按 $dis$ 从小到大扩展点,
  而 $s_2$ 已经扩展出来了, $dis_{s_1} + 10^{q-d_1}$ 那个点还没扩展出来,
  我们一定有 $dis_{s_1} + 10^{q-d_1} > dis_{s_2}$.
- 由于每条边的 $d$ 都是唯一的, $dis_{s_1}$ 和 $dis_{s_2}$ 中都肯定没有 $10^{q-d_1}$ 这一位 (因为有这一位的路径都经过了 $d_1$ 对应的边, 但是 $d_1$ 对应的这条边的终点我们还没扩展出来呢).

综上, $dis_{s_1}$ 与 $dis_{s_2}$ 一定长这样:

$$\begin{aligned}
dis_{s_1} &= {\color{red}\text{xxx}}{\color{blue}0}{\color{green}\text{aaa}}\\
dis_{s_2} &= {\color{red}\text{xxx}}{\color{blue}0}{\color{green}\text{bbb}}\\
dis_{s_1} + 10^{q-d_1} &= {\color{red}\text{xxx}}{\color{blue}1}{\color{green}\text{aaa}}\\
\end{aligned}$$

其中三个红色的 xxx 都是相同的数字, 而 aaa 和 bbb 位数相同, aaa 小于 bbb;
蓝色的 0/1 就是 $10^{q-d_1}$ 所在的位.

因此不难看出, 如果我们把 $dis_{s_2}$ 也加上某个 $10^{q-d_2}$,
那么加上的这个 `1` 如果落在绿色位置, 也就是 $d_1 < d_2$ (注意我们的边权选取导致这个加法不可能进位),
加完之后也比 $dis_{s_1} + 10^{q-d_1}$ 更小;
如果落在红色或者蓝色位置, 也就是 $d_1 \geq d_2$, 加完一定比 $dis_{s_1} + 10^{q-d_1}$ 更大.

**综上所述**, 我们在 Dijkstra 的时候只需要比较最后走出的这一步的 $d_i$, 选取 $d_i$ 较大的一个;
而在 $d_i$ 相同时比较上一步的 $dis$ 即可.

事实上, $d_i$ 相同的情况只会在 $d_i = \infty$ 的时候发生.
不过由于没被删的边我们可以任意处置, 可以假想这些边在第 $q+1, \dots, q+m$ 次也依次被删除了, 所以这种情况其实可以随便认为谁更大谁更小, 都不需要比较上一步的 $dis$.

(真的要比较也不难, 因为我们不需要实际求出 $dis$, 只需要比较两个点在 dijkstra 过程中谁先被扩展出来, 谁的 $dis$ 就更小.)

我们记录每个点的最短路的前驱, 最后就可以找出 $1$ 到 $n$ 具体的最优路径了.

## 最初的想法

事实上, 这个解法是我在手玩了自己随便写的几个数据之后想到的, 并且最开始也不会有这些复杂度证明, 只是一个简单的贪心想法.

如果我们有了这个想法, 试图证明它也不是困难的, 读者也可以自己试着证一下.
核心思路就是假设有一条道路比这样求出的更优, 然后想一想 Dijkstra 中哪一步走不通. 如果没有想法, 也可以自己画点小数据手玩一下.

## 代码
```cpp
#include <algorithm>
#include <queue>
#include <vector>
#include <functional>
#include <utility>
#include <cctype>
#include <cstdio>
#include <cstring>

typedef long long LL;
const int N = 200050;
int pre[N], nxt[N], fr[N], to[N], a[N], cnt;
bool rm[N];

int read() {
  int ans = 0, c;
  while (!isdigit(c = getchar()));
  do ans = ans * 10 + c - '0';
  while (isdigit(c = getchar()));
  return ans;
}

typedef std::pair<int, int> E;
#define mp std::make_pair

std::priority_queue<E> Q;
int fa[N];

int main() {
  int n = read(), m = read(), q = read();
  for (int i = 1; i <= m; ++i) {
    int x = fr[i] = read();
    to[i] = read();
    nxt[i] = pre[x];
    pre[x] = i;
    a[i] = q + 1;
  }
  for (int i = 0; i < q; ++i) {
    int x = read();
    if (a[x] > i) rm[a[x] = i] = true;
    else rm[i] = false;
  }
  to[m + 1] = 1;
  Q.push(mp(0, m + 1));
  while (!Q.empty()) {
    E x = Q.top(); Q.pop();
    int u = x.second, t = to[u];
    if (fa[t]) continue;
    fa[t] = u;
    for (int i = pre[t]; i; i = nxt[i])
      Q.push(mp(a[i], i));
  }
  for (int i = n; i != 1; i = fr[fa[i]]) {
    // printf("%d %d %d\n", i, fa[i], a[fa[i]]);
    rm[a[fa[i]]] = false;
  }
  for (int i = 0; i < q; ++i)
    printf("%d\n", rm[i] ? 1 : 0);
}
```

## 一些吐槽

我不是很懂出题人为什么把这题放到月赛第三题, 我觉得得出这个贪心并证明它并不是困难的. 更不懂为什么出题人没有在题解上给出更简单的做法. 大约是其真的没想到吧.

更奇怪的是居然比赛时少有人 AC. 是不是放在 C 题就把大家吓跑了, 想到贪心也觉得是假的呢?

---

## 作者：ZillionX (赞：10)

# Description

给定一个有向图，每次操作指定一条边，如果删去后 $1$ 仍能到达 $n$ 则永远删去这条边。输出每次是否删去了对应的边。

$n,m,q \le 2 \times 10^5$，时限 2s。

# Solution

《真·有向图动态连通性》，赛时从 Tarjan DFS 树的方向去考虑了，和正解完全碰不着头。官方题解给出的是一种个人认为十分精妙的基于 Dijkstra 比较答案优劣的做法。这同时利用了问题具有“单源性”和“永久性（由此引出类似字典序的比较优劣方法）”的性质。

------------

如果一条边被删去多次，只需保留第一次操作即可，显然如果它被删去的话，后面的话自动返回 $0$ 即可；没被删去的话，后面也不可能删去。

我们记 $t_i$ 表示第 $i$ 条边在 $t_i$ 时被操作，没有被操作的边我们到最后统一把它们的 $t$ 记为一个 $>q$ 的数。

容易发现，最终局面中，图一定只保留了一条 $1$ 到 $n$ 的路径。现在我们的问题就是找出这条路径，容易发现在记录 $t_i$ 后，这条路径是唯一的。也就是必然存在一种比较优劣的方法找出这条路径。

我们不妨考虑 Dijkstra，给每个点记录一个集合 $S_i$，表示 $1$ 到 $i$ 贪心留下的唯一路径的 $t_i$ 的集合。转移的时候，我们给 $S_u$ 加上 $t_w$，对 $S_v$ 进行松弛操作。我们考虑怎么比较优劣，容易发现，我们给集合内的数从小到大排序后，依次进行比较，第一个不同的数，若是 $S_u$ 更大，则 $S_u$ 更优，否则 $S_v$ 更优。如果一个集合已经比较空了还判断不出优劣，那么元素数量更小的集合更优。

容易发现这样比较一定满足严格弱序，正确性和字典序类似。

下面我们考虑如何维护这个集合，容易发现，我们可以用可持久化线段树维护区间哈希值，通过线段树二分比较两集合的优劣，维护的方法是将值域上集合中的数所在的位置设为 $1$，具体手法可以见代码。

至此我们在 $\mathcal O(m \log^2 m)$ 的时空复杂度内解决了本题。

# Code

```cpp
const int N=2e5+5;
const ul bs=131;
int n,m,q,rt[N],tim[N];
ul pw[N];
struct nd {
	int l,r,c;
	ul v;
}a[N*31];
int tn;
#define ls (a[x].l)
#define rs (a[x].r)
void up(int x) {
	a[x].c=a[ls].c+a[rs].c;
	a[x].v=a[ls].v+pw[a[ls].c]*a[rs].v;
}
void upd(int &x,int y,int l,int r,int p,bool u=1) {
	if (u) x=++tn;
	else {
		if (!x) x=++tn;
	}
	a[x]=a[y];
	if (l==r) {
		a[x].c=1,a[x].v=l;
		return;
	}
	int mid=(l+r)>>1;
	if (p<=mid) upd(ls,a[y].l,l,mid,p,u);
	else upd(rs,a[y].r,mid+1,r,p,u);
	up(x);
}
int qry(int x,int y,int l,int r) {
	if (a[x].v==a[y].v) return 2;
	if (l==r) return a[x].c<a[y].c;
	int mid=(l+r)>>1;
	if (a[ls].v!=a[a[y].l].v) return qry(ls,a[y].l,l,mid);
	return qry(rs,a[y].r,mid+1,r);
}
bool ans[N];
void cal(int x,int l,int r) {
	if (!x) return;
	if (l==r) {
		ans[l]=(a[x].c^1);
		return;
	}
	int mid=(l+r)>>1;
	cal(ls,l,mid),cal(rs,mid+1,r);
}
#undef ls
#undef rs
struct cmp {
	bool operator()(const int &x,const int &y) const {
		int t=qry(rt[x],rt[y],1,m);
		return (t==1);
	}
};
set<int,cmp> o;
struct edg {int v,id;};
vector<edg> g[N];
bool e[N];
void dij(int s) {
	o.ins(s);
	rt[s]=0;
	while (!o.emt) {
		int u=*o.bg;
		o.ers(o.bg);
		if (e[u]) continue;
		e[u]=1;
		for (auto v:g[u]) {
			int t=0;
			upd(t,rt[u],1,m,tim[v.id]);
			if (rt[v.v]!=0 && qry(t,rt[v.v],1,m)==1) {
				o.ers(v.v),rt[v.v]=t,o.ins(v.v);
			}
		}
	}
}
int qs[N];
int main() {
	scanf("%d%d%d",&n,&m,&q);
	pw[0]=1;
	for (int i=1;i<=m;i++) pw[i]=pw[i-1]*bs;
	for (int i=1,u,v;i<=m;i++) {
		scanf("%d%d",&u,&v);
		g[u].pb(edg{v,i});
	}
	for (int i=1;i<=q;i++) ans[i]=1;
	int cnt=0;
	for (int i=1;i<=q;i++) {
		scanf("%d",&qs[i]);
		if (!tim[qs[i]]) tim[qs[i]]=++cnt;
	}
	for (int i=1;i<=m;i++) {
		if (!tim[i]) tim[i]=++cnt;
	}
	int inf=0;
	for (int i=1;i<=m;i++) upd(inf,inf,1,m,i,0);
	for (int i=1;i<=n;i++) rt[i]=inf;
	dij(1);
	cal(rt[n],1,m);
	for (int i=1;i<=q;i++) printf("%d\n",ans[tim[qs[i]]]),tim[qs[i]]=0;
	return 0;
}
```


---

## 作者：dead_X (赞：3)

## 思路
下文中假设 $m=q$，且 $x_1\sim x_n$ 构成一个排列，不难发现该问题等价于原问题。

考虑实际上我们最后只会保留一条从 $1$ 到 $n$ 的路径，也就是说我们只需要求出这条路径是由哪几个点组成的即可。

于是我们相当于是要求 $1$ 到 $n$ 的字典序最短路。

不难想到用动态开点维护一个点的最短路，正好可以套用 dijkstra 算法，更新最短路只需要可持久化线段树的操作即可。

注意到 dijkstra 还要维护一个堆，考虑怎么比较两棵主席树，使用哈希来维护一棵子树的权值情况即可。

时间复杂度 $O(n\log n\log m)$。
## 代码
```cpp
//回家？我没有家可以回，我没有退路。
#include<bits/stdc++.h>
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int n=read(),m=read(),q=read(),cnt=1;
const int p=1019260817;
int ls[10000003],rs[10000003],val[10000003];
int dis[200003],pw[200003],tr[200003];
void build(int nl,int nr,int x)
{
	if(nl==nr) return ;
	int mid=(nl+nr)>>1;
	build(nl,mid,ls[x]=++cnt),
	build(mid+1,nr,rs[x]=++cnt);
	return ;
}
int update(int nl,int nr,int t,int x)
{
	if(nl==nr)
	{
		val[++cnt]=1;
		return cnt;
	}
	int mid=(nl+nr)>>1,r=++cnt;
	ls[r]=ls[x],rs[r]=rs[x];
	if(t<=mid) ls[r]=update(nl,mid,t,ls[x]);
	else rs[r]=update(mid+1,nr,t,rs[x]);
	val[r]=(1ll*pw[mid-nl+1]*val[ls[r]]+val[rs[r]])%p;
	return r;
}
int cmp(int x,int y)
{
	if(!rs[x]||!rs[y]) return val[x]<val[y];
	if(val[rs[x]]!=val[rs[y]]) return cmp(rs[x],rs[y]);
	return cmp(ls[x],ls[y]);
}
bool vis[200003],ans[200003];
pair<int,int> a[200003];
vector<pair<int,int>> e[200003];
#define fi first
#define se second
struct segt
{
	int a[200003],f[800003];
	void update(int l,int r,int t,int k,int x=1)
	{
		if(l==r){a[l]=k,f[x]=l;return ;}
		int mid=(l+r)>>1;
		if(t<=mid) update(l,mid,t,k,x<<1);
		else update(mid+1,r,t,k,(x<<1)+1);
		f[x]=cmp(a[f[x<<1]],a[f[(x<<1)+1]])
		?f[x<<1]:f[(x<<1)+1];
		return ;
	}
}T;
void dfs(int nl,int nr,int x)
{
	if(nl==nr)
	{
		ans[tr[nl]]=!val[x];
		return ;
	}
	int mid=(nl+nr)>>1;
	dfs(nl,mid,ls[x]),dfs(mid+1,nr,rs[x]);
}
signed main()
{
	pw[0]=1;
	for(int i=1; i<=200000; ++i)
		pw[i]=1313131ll*pw[i-1]%p;
	for(int i=1; i<=m; ++i)
		a[i].fi=read(),a[i].se=read();
	int t=m;
	for(int i=1,x; i<=q; ++i)
		if(!vis[x=read()])
			tr[t]=i,vis[x]=1,
			e[a[x].fi].emplace_back(a[x].se,t--);
	for(int i=1; i<=m; ++i)
		if(!vis[i])
			e[a[i].fi].emplace_back(a[i].se,t--);
	build(1,m+1,1),dis[1]=1;
	int inf=update(1,m+1,m+1,1);
	for(int i=2; i<=n; ++i)
		dis[i]=inf,T.update(1,n,i,inf);
	T.update(1,n,1,1);
	for(int _=1; _<=n; ++_)
	{
		int x=T.f[1],id=dis[x];
		T.update(1,n,x,inf);
		for(auto [y,z]:e[x])
		{
			int tmp=update(1,m+1,z,id);
			if(cmp(tmp,dis[y]))
				dis[y]=tmp,T.update(1,n,y,tmp);
		}
	}
	dfs(1,m+1,dis[n]);
	for(int i=1; i<=q; ++i) printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：伟大的王夫子 (赞：3)

介绍一种倍增的做法。

倘若有一条边被考虑到了两次，那么第二次询问它时直接忽略并输出 0。因此下面我们假设每条边只被询问到了一次。

首先，对于没有询问到的边，我们强制将其加入询问，放在原来询问的边的后面。
容易发现，这些询问对原答案没有任何影响，我们只要不输出这些询问的答案即可。

我们发现，最后删了剩下的边一定会**不冗余**地构成一条从 1 到 $n$ 的路径。

证明：假设还有一条边不在 1 到 $n$ 的路径上，那么删去这条边，答案肯定会更优。

那么，我们可以设边的权值为询问这条边是否被删的询问的编号。我们用一个数组 $d_x$ 表示从 1 走到 $x$ 中的每条路径的所有的边的权值构成的集合中的最优的那一个集合。我们如何比较哪个集合更优呢？我们每次取两个集合的最小值，判断是否相等，如果相等则跳过取第二小的，如果还相等就取第三小，以此类推。当出现了不相等的值时，比较哪个集合的这个值更大，这个值更大的集合会更优。因为我们删边是按顺序来的，肯定要保证先询问的先删。

我们可以采用一个迪杰斯特拉算法的框架，并且用主席树优化集合比较。时间复杂度应该是 $O(m \log^2 m)$。（这里笔者也不是很清楚，因为没写过）。

上面的主席树做法超出了 NOIP 大纲范围，因此下面要介绍倍增写法。

我们考虑边求最短路，边构建最短路。由于新加入的节点一定是作为叶子节点加入的，所以我们可以在 $O(\log n)$ 的时间复杂度内维护该节点的倍增信息。

当我们比较两个节点哪个更优时，可以求出他们在最短路径树上的 LCA，再进行比较。此时，路径被拆成了 $1 \to LCA, LCA\to x,LCA\to y$ 三个部分。其中第一个是三个共同拥有的，只用比较后面两个。我们直接求出最小值进行比较。这是因为一个询问不可能查询两条边，所以说最小值一定会不一样，才保证了该算法的正确性。

时间复杂度大概是迪杰斯特拉的复杂度乘上比较两个节点的复杂度，为 $O((m+n) \log^2 n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5, maxlog = 17;
int n, m, qcnt, a[N], b[N], X[N], Y[N], Z[N], ver[N], edge[N], tot, nxt[N], head[N], ans[N], f[N][18], w[N][18], dep[N];
bool exist[N], v[N];
inline void add(int x, int y, int z) {
	ver[++tot] = y, edge[tot] = z, nxt[tot] = head[x], head[x] = tot;
}
int lca(int x, int y) {
	if (dep[x] > dep[y]) swap(x, y);
	for (int i = maxlog; i >= 0; --i)
		if (dep[f[y][i]] >= dep[x]) y = f[y][i];
	if (x == y) return x;
	for (int i = maxlog; i >= 0; --i)
		if (f[x][i] ^ f[y][i]) x = f[x][i], y = f[y][i];
	return f[x][0];
}
int getmi(int x, int LCA) {
	if (x == LCA) return 1e9;
	int ans = 1e9;
	for (int i = maxlog; i >= 0; --i)
		if (dep[f[x][i]] > dep[LCA]) {
			ans = min(ans, w[x][i]);
			x = f[x][i];
		}
	return min(ans, w[x][0]);
}
struct cmp {
	bool operator () (int x, int y) {
		int LCA = lca(x, y);
		return getmi(x, LCA) > getmi(y, LCA);
	}
};
void dij() {
	memset(v, 0, sizeof v);
	set<int, cmp> s;
	for (int i = 1; i <= n; ++i) dep[i] = 1;
	w[1][0] = 1e9;
	s.insert(1);
	while (s.size()) {
		int x = *s.begin();
		s.erase(s.begin());
		if (v[x]) continue;
		v[x] = 1;
		for (int i = head[x]; i; i = nxt[i]) {
			int y = ver[i], z = edge[i], LCA = lca(x, y);
			if (getmi(y, LCA) < min(z, getmi(x, LCA))) {
				s.erase(y);
				f[y][0] = x;
				w[y][0] = z;
				for (int i = 1; i <= maxlog; ++i) {
					f[y][i] = f[f[y][i - 1]][i - 1];
					w[y][i] = min(w[y][i - 1], w[f[y][i - 1]][i - 1]);
				}
				dep[y] = dep[x] + 1;
				s.insert(y);
			}
		}
	}
}
int main() {
	cin >> n >> m >> qcnt;
	for (int i = 1; i <= m; ++i) scanf("%d%d", X + i, Y + i);
	int tt = 0;
	for (int i = 1; i <= qcnt; ++i) {
		scanf("%d", a + i);
		if (v[a[i]]) {
			ans[i] = -1;
			continue;
		} else Z[a[i]] = ++tt, v[a[i]] = 1;
	}
	for (int i = 1; i <= m; ++i)
		if (!Z[i]) Z[i] = ++tt;
	for (int i = 1; i <= m; ++i) b[Z[i]] = i;
	for (int i = 1; i <= m; ++i) add(X[i], Y[i], Z[i]);
	for (int i = 0; i <= maxlog; ++i) w[0][i] = 1e9;
	dij();
	int x = n;
	while (x != 1) exist[b[w[x][0]]] = 1, x = f[x][0];
	for (int i = 1; i <= qcnt; ++i) {
		if (ans[i] == -1) ans[i] = 0;
		else ans[i] = !exist[a[i]];
		printf("%d\n", ans[i]);
	}
}
```

---

## 作者：jr_linys (赞：2)

写一篇自认为好理解的题解。  

考虑对原图提取一条最优的路径，其他的边可以随意删除。  
那么应该取哪一条路径呢？  
对每一条边赋边权为第一次修改的时间，没有被修改赋为无限大。  
那么一条路径的边权为每一条边的边权从小到大排序得到的序列。我们要取权值字典序最大的路径。  

考虑 Dijkstra 算法，从 1 节点开始拓展，每一次取最后一条边的边权最大的路径扩展，记录每个点从哪个点和边转移，找到 n 节点立即结束。  
为什么是对的。给出一种解释：    
最开始优先队列里只有一条空路径，此时优先队列里任何一个路径**去掉最后一条边后路径的权值**大于任何队列里的**路径权值**，而选**最后一条边权值最大的路径**来扩展既满足选择的路径权值最大，扩展后优先队列也仍然满足这个性质。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
template<class T>void Min(T &a,T b){(a>b)&&(a=b);}
template<class T>void Max(T &a,T b){(a<b)&&(a=b);}
const int N=5e5;
int n,m,q,t,he[N+5],qd[N+5],ti[N+5],fe[N+5],fu[N+5];
bool vis[N+5],use[N+5];
struct Edge{int v,id,ne;}e[N+5];
priority_queue<pii> qu;

int main(){
	ios::sync_with_stdio(0);
	cin>>n>>m>>q;
	for(int i=1,u,v;i<=m;++i){
		cin>>u>>v;
		e[i]={v,i,he[u]},he[u]=i;
	}
	for(int i=1;i<=q;++i){
		cin>>qd[i];
		if(ti[qd[i]]==0) ti[qd[i]]=i;
	}
	for(int i=1;i<=m;++i) if(ti[i]==0) ti[i]=q+1;
	qu.push({0,1});
	while(qu.size()){
		int u=qu.top().second;qu.pop();
		if(vis[u]) continue;
		vis[u]=1;
		if(u==n) break;
		for(int i=he[u],v;i;i=e[i].ne) if(!vis[v=e[i].v]){
			if(ti[e[i].id]>ti[fe[v]]){
				qu.push({ti[fe[v]=e[i].id],v}),fu[v]=u;
			}
		}
	}
	for(int u=n;u!=1;u=fu[u]) use[fe[u]]=1;
	for(int i=1;i<=q;++i){
		if(ti[qd[i]]==i&&!use[qd[i]]) cout<<"1\n";
		else cout<<"0\n";
	}
}
```

---

## 作者：xcyyyyyy (赞：2)

很多题解都没有提到为什么可以用 `dijkstra`，这个东西其实并不是那么显然，感兴趣的可以看一下后面的分析。

不错的图论思维题。

考虑一条路径只有第一次删边是有用的。这个时间我们把他当作边权。

直接做删边的话就真的是动态图联通性题目了。

考虑依次删边，最后一定会剩下一条路径。

考虑这条路径的性质：在所有 $1$ 到 $n$ 的路径中，该路径的最小值最大。保证最小值最大的前提之下，我们还要保证次小值也是最大，以此类推。

那么两条路径的大小关系一定是将他们的路径上的边权从小到大排序后直接比较出来的大小。

这里有一个新奇的思路：用主席树维护集合大小。

我们考虑 `dijkstra` 的时候迭代，最终出来的一个点的最短路集合一定是在原来某一个集合上面添加了一个字符，我们不妨用值域线段树的持久化来维护这个东西。

因为值域线段树自己就排好了序，所以我们只需要维护左右子树的哈希值来寻找第一个不一样的位置即可。

> 有序集合的大小判断可以利用主席树

**这个东西能否满足 `dijkstra` 的贪心原理？**

首先，经过 $(u,v)$ 的字典序最大串是否就是到达 $u$ 的最大串再加上这个边权？

如果不是因为这个题目的特殊性，我们就不能保证这个东西，为什么呢？

> 若 $a\gt b$，我们不能保证 $a+s \gt b+s$，比如 $aa\gt a$，$aab \lt ab$。

但出现这个情况的时候 $a,b$ 一定是其中一个是另一个的子集，在最短路上很明显不会出现这样的问题，所以可以用 `dijkstra`。

其次，我们每一次贪心的更新最大的是否可以？

因为加入一个数后该集合一定会变得更小，所以可以用 `dijkstra`。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define p 131
#define w(x) t[x].w
#define ls(x) t[x].ls
#define rs(x) t[x].rs
#define sz(x) t[x].sz
#define N 200005
#define ull unsigned long long
int n,m,q;
int qry[N],cut[N];
int head[N],ver[N],wei[N],nxt[N],num=1;
void add(int u,int v){ver[num]=v;wei[num]=N;nxt[num]=head[u];head[u]=num++;}

ull pn[N];int rt[N<<1],id;
struct Node{int ls,rs,sz;ull w;}t[N*40];int tot;
void pull(int k){
	sz(k)=sz(ls(k))+sz(rs(k));
	w(k)=w(ls(k))*pn[sz(ls(k))]+w(rs(k));
}
void upd(int &k,int l,int r,int x){
	t[++tot]=t[k];k=tot;
	if(l==r)return w(k)=l,sz(k)=1,void();
	int m=(l+r)>>1;
	if(m>=x)upd(ls(k),l,m,x);
	else upd(rs(k),m+1,r,x);
	pull(k);
}
bool ask(int j,int k,int l,int r){
	if(l==r)return w(j)?1:0;
	int m=(l+r)>>1;
	if(w(ls(j))==w(ls(k)))return ask(rs(j),rs(k),m+1,r);
	else return ask(ls(j),ls(k),l,m);
}
int pos[N],lst[N],vis[N];
void dijkstra(){
	class cmp{
		public:
		bool operator()(pair<int,int> &a,pair<int,int> &b){return ask(rt[a.second],rt[b.second],1,N);}
	};
	priority_queue<pair<int,int>,vector<pair<int,int> >,cmp> Q;
	Q.push({1,0});
	while(Q.size()){
		int u=Q.top().first;Q.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(int i=head[u];i;i=nxt[i]){
			rt[++id]=rt[pos[u]];
			upd(rt[id],1,N,wei[i]);
			if(!pos[ver[i]]||ask(rt[pos[ver[i]]],rt[id],1,N)){
				pos[ver[i]]=id,lst[ver[i]]=u;
				Q.push({ver[i],id});
			}
		}
	}
}
void find(int x){
	if(x==1)return;
	find(lst[x]);
	//printf("%d %d\n",lst[x],x);
	for(int i=head[lst[x]];i;i=nxt[i])if(ver[i]==x)cut[i]=0;
}
int main(){
	scanf("%d%d%d",&n,&m,&q);
	pn[0]=1;for(int i=1;i<=n;i++)pn[i]=pn[i-1]*p;
	for(int i=1,u,v;i<=m;i++)scanf("%d%d",&u,&v),add(u,v);
	for(int i=1;i<=q;i++)scanf("%d",&qry[i]),wei[qry[i]]=min(wei[qry[i]],i);
	dijkstra();
```

---

## 作者：wind_cross (赞：2)

感觉不论是没想到转化还是没见过这个套路都很难想……

题意是问我们每次是否可以删掉有向图的一条边使得仍然**存在**一条 $1$ 到 $n$ 的路径。

这个东西一眼望过去是很难做的。如果是无向图可以通过分治加可撤销并查集来找到必须保留的每个位置。但有向图并没有什么很好的办法来维护 $1$ 与 $n$ 的有向联通性。

让我们尝试发现一些性质。首先，对于一条在询问中出现多次的边，一定只有第一次的答案不确定，后面的询问答案都是0。因为如果第一次删掉了，你不可能再删；如果没删掉，你也不会在后面的询问删。因此，每条边只有第一次询问有意义。

观察答案的 01 序列长什么样子。注意到，它一定是所有满足 $1$ 到 $n$ 存在路径的方案中字典序最小的。因为我们每次尝试删边的原则是**能删就删**。字典序小的显然更满足这个条件。如果你做过[CF464E](https://www.luogu.com.cn/problem/CF464E)的话，应该可以比较自然的想到给每条边赋权，最后保留一条从 $1$ 到 $n$ 边权最小的路径。具体来说对于一条边 $x$ ，如果它在询问中第一次出现的位置是 $i$ ， 那么 $v_x=2^i$ 。特殊的，如果一条边没有出现在询问中，那么它的权值为 $2^{q+1}$ 。当然这只是一种方式，其他能满足字典序最小的当然也可以。显然不能直接用高精度整数对这张图跑dij，考虑用主席树维护哈希值来直接比较两个 01 序列的字典序。最后最短路保留的边我们就认为是**必须**不删除的边，其余的边可以随便删除，然后就做完了。复杂度  $O(n\log n\log q)$ ，常数不大。虽然看起来要做的事很多，但代码并不难写。

```cpp
#include<cstdio>
#include<cstring>
#include<cctype>
#include<vector>
#include<queue>
#include<algorithm>
using namespace std;
inline char nc()
{
	static char buf[99999],*l,*r;
	return l==r&&(r=(l=buf)+fread(buf,1,99999,stdin),l==r)?EOF:*l++;
}
template <class code>inline code read(const code &a)
{
    code x=0;short w=0;char ch=0;
    while(!isdigit(ch)) {w|=ch=='-';ch=nc();}
    while(isdigit(ch)) {x=(x<<3)+(x<<1)+(ch^48);ch=nc();}
    return w?-x:x;
}
void print(int x){
	if(x<0)putchar('-'),x=-x;
	if(x>=10)print(x/10);
	putchar(x%10+48);
}
const int maxn=2e5;
int n,m,q;
struct pp{
    int ne;
    int rank;
};
vector<pp>w[maxn+5];
int v[maxn+5],rt[maxn+5],ans[maxn+5],jl[maxn+5],tag[maxn+5];
unsigned long long xd[40*maxn];
int lc[40*maxn],rc[40*maxn],tot;
void xj(int &rt){
    xd[++tot]=xd[rt],lc[tot]=lc[rt],rc[tot]=rc[rt];
    rt=tot;
}
void build(int &root,int zl,int zr){
    root=++tot;
    if(zl==zr){
        
        xd[root]=zl;
        return;
    }
    int mid=(zl+zr)>>1;
    build(lc[root],zl,mid);build(rc[root],mid+1,zr);
    xd[root]=xd[lc[root]]*114514+xd[rc[root]];
}
void update(int &root,int x,int zl,int zr,int v){
    xj(root);
    if(zl==zr){
        xd[root]=v*x;
        return;
    }
    int mid=(zl+zr)>>1;
    if(x<=mid)update(lc[root],x,zl,mid,v);
    else update(rc[root],x,mid+1,zr,v);
    xd[root]=xd[lc[root]]*114514+xd[rc[root]];
}
unsigned long long cx(int root,int x,int zl,int zr){
    if(zl==zr)return xd[root];
    int mid=(zl+zr)>>1;
    if(x<=mid)return cx(lc[root],x,zl,mid);
    return cx(rc[root],x,mid+1,zr);
}
int ef(int r1,int r2,int zl,int zr){
    if(zl==zr)return xd[r1]<xd[r2];
    int mid=(zl+zr)>>1;
    if(xd[lc[r1]]==xd[lc[r2]])return ef(rc[r1],rc[r2],mid+1,zr);
    return ef(lc[r1],lc[r2],zl,mid);
}
struct node{
    int rt;
    int wz;
};
struct cmp{
    bool operator()(const node &x,const node &y){
        return !ef(x.rt,y.rt,1,q+1);
    }
};
priority_queue<node,vector<node>,cmp>dl;
signed main()
{
	// freopen("text.in","r",stdin);
    // freopen("text.out","w",stdout);
    n=read(n),m=read(m),q=read(q);
    for(int i=1;i<=m;i++){
        int u=read(u),v=read(v);
        pp now;now.ne=v,now.rank=i;
        w[u].emplace_back(now);
    }
    for(int i=1;i<=q;i++){
        int x=read(x);
        jl[i]=x;
        if(!v[x])v[x]=i;
    }
    for(int i=1;i<=m;i++)if(!v[i])v[i]=q+1;
    int zrt=1;build(zrt,1,q+1);
    for(int i=2;i<=n;i++)rt[i]=zrt;
    rt[1]=++tot;node now;now.rt=rt[1],now.wz=1;
    dl.push(now);
    while(!dl.empty()){
        node wz=dl.top();dl.pop();
        if(wz.rt!=rt[wz.wz])continue;
        for(pp ne:w[wz.wz]){
            int cg=rt[wz.wz];
            update(cg,v[ne.rank],1,q+1,1);
            if(ef(cg,rt[ne.ne],1,q+1)){
                rt[ne.ne]=cg;
                dl.push((node){cg,ne.ne});
            }
        }
    }
    for(int i=1;i<=q;i++){
        if(v[jl[i]]!=i||cx(rt[n],i,1,q+1))ans[i]=1;
    }
    for(int i=1;i<=q;i++){
        if(ans[i])putchar('0');
        else putchar('1');
        puts("");
    }
	return 0;
}
```


---

## 作者：2020kanade (赞：2)

前排提醒：本题解涉及超纲（相对“提高级”而言，并且超纲超的有点过）内容，并且暂时没有进行实现，但正确性是可以保证的，大概。

简化题意：给定一张 $n$ 个点 $m$ 条边的无重边 DAG 以及 $q$ 次询问，每次询问给出仍存在于当前 DAG 的一条边，询问删掉后是否仍存在一条结点 $1$ 到结点 $n$ 的路径，是则返回 $1$ 并进行删边（永久性删除，即影响后续询问），否则仅返回 $0$，不对原 DAG 进行改动。

首先发现：图中重要的边与点只有全部构成 $1$ 到 $n$ 路径的，因此可以一次 DAG DP 求出所有点能够到达的最大结点标号，之后按照这个标号抠出来一张生成子图，满足：仅有点 $1$ 无入度，点 $n$ 无出度，其他的所有点与边都是某条 $1$ 到 $n$ 路径的一部分。这一步其实并不是必要的，只是为了方便理解与后续思考。

对这张生成子图求出任意一颗 DFS 有向生成树，这颗树维护的是原图中若干条路径，另外的一些路径通过横叉边维持，不在这颗树上维护。此时，存在路径 $x \to y$ 的充要条件变为 $x$ 是这颗树上 $y$ 的祖先。

接下来考虑删掉一条边，它要么是树边要么是横叉边，后者由于不在树上维护，直接删除即可。

重点在于删掉一条树边时对连通性的变动：设这条边为 $u \to v$，此时如果没有任何横叉边的话，子树 $v$ 中所有结点都将无法在从 $1$ 出发时到达，因此它们失去了存在于生成树上的意义（生成树上的对应点什么的，已经不存在了。因为已经没有任何相关路径，去要维护了。），删了就行。

把横叉边加上，第一点就是如果删掉的子树有横叉边，就删掉这条横叉边，但不要跑到它的终点上删子树，因为只是破坏了横叉边维护的可达关系，生成树维护的路径不一定被破坏。之后发现：如果要被删掉的子树的某个点存在未被删除的横叉入边，说明仍然有其他路径可以从 $1$ 到达这个点，而未被删除的横叉入边的起点一定是生成树上的一个点，因为按照前文提到的删除条件，横叉入边的起点如果被删了那么它一定一起被删了。

此时就好办了：删除父亲树边后停止对该点的递归删除，任选一条横叉入边变成树边，该点的父亲变为横叉入边的起点，因为原来是一颗树，以上操作相当于换了父亲，还是一棵树。如果这次删除合法，这次删除删去的其他边可以在删掉这条边之后的任意时刻被删除。

那么，这个算法维护生成树的正确性就显然了：删边时要么破坏了当前维护的路径要么破坏了其他路径，对于后者相当于删了横叉边，对于前者相当于把横叉边换成了树边继续维护可达性（路径），再被删的时候接着维护就可以了。觉得不对劲的话，如果有一条路径全是横叉边构成的，当原图只有这条路径时，这些横叉边已经全部变成了树边。时间复杂度上，每个点被删除的最大次数是其入度，显然总和为 $O(n)$ 级别）。

那么问题来了：怎么判断一条边能不能删？

当前 DFS 生成树维护的是原图的一条路径，删树边相当于直接破坏所维护的路径，结合之前提到的性质，我们可以发现：当删掉树上路径 $1\to n$ 中的一条边，设其终点为 $u$，当且仅当 DFS 生成树上路径 $u\to n$ 中存在某个点有未被删去的横叉入边时，这条边可以删去。这样就保证了所有已经进行了的删除操作的合法性，被删掉的其他边可以在这次操作之后的任意时刻被删去，因为不对当前以及以后维护的路径造成影响。

至于维护换父亲和关键路径上是否存在横叉入边，上 LCT。前者显然，后者额外开个哈希表什么的维护横叉边集合辅助在 LCT 上的修改，之后树链上维护一下就行了。话说都看到这里了，应该都发现了：这颗 DFS 生成树是对于所有路径任选一条维护，不就像 LCT 里的实链剖分吗？

注意换父亲的时候维护儿子都有谁（一般情况下单纯的 LCT 难以维护子树信息），可以拿哈希表或者动态开点线段树维护儿子集合， DFS 时对着这个儿子集合遍历即可。

总时间复杂度大概是 $\Theta((q+n)\log n)$，貌似比官方少一个 $\log$，但算法超纲，估计还更难码，如标题所言，是个令人眼前一黑的解法。

实现的话笔者因为一些意外退役了，没工夫写，就公开乞讨一份吧（bushi 等有时间了尽量去补。

另外问一下正解......是 HASH 加主席树的话，主席树不是 NOI 级算法吗（归属于可持久化数据结构，大概）。

另：感谢管理员耐心指出错误，这篇题解前后送审了有四五次大概，~~算不算骚扰管理啊~~总之太感谢了。

---

## 作者：enucai (赞：1)

## Analysis

考虑将询问离线，给每个询问的边按照询问的顺序从小到大赋值上边权。原问题等价于找到一条从 $1$ 到 $n$ 的路径，满足字典序最小。此处字典序的定义为：

- 将经过的边表示为一个 01 串，若一条边被经过，则她的边权的位置为 $1$，否则为 $0$。例如共 $6$ 条边，经过了 $5,1,4$ 三条边，则该 01 串表示为 $100110$。

那么若一条询问的边在该路径上被经过，那么就不会被删除，否则会被删除。这样的路径得出的答案正确性显然，因为一条边被经过，那么删除她后图一定不存在 $1$ 到 $n$ 的路径（若存在，字典序最小的要求必然使她为 $0$）。

发现这条路径类似于最短路，考虑用 dijkstra 算法求出这条路径。由于经过一条边后只会有 $1$ 条边的经过情况会发生改变，故考虑用可持久化线段树维护到达一个点的字典序最小的路径上所经过的点。更新答案只要主席树上单点修改即可。

问题在于如何比较两条路径的字典序大小。考虑主席树维护区间 01 串的哈希值，然后在线段树上二分找出第一个值不一样的位置，这一位小的则字典序更小。

剩下的部分就是普通的 dijkstra。

## Code

```cpp
#define int long long
const int N=200010;
const int base=13331;
const int mod=1011451423;
int n,m,q,ans[N],t[N*31],rt[N],mi[N],ls[N*31],rs[N*31],idx[N],tot;
vector<pair<int,int>> e[N];
struct Edge{
  int u,v,w,vis;
}edge[N];
#define mid ((l+r)>>1)
void upd(int &p,int q,int l,int r,int x){
  p=++tot,t[p]=t[q],ls[p]=ls[q],rs[p]=rs[q];
  if(l==r) return t[p]=1,void();
  if(x<=mid) upd(ls[p],ls[q],l,mid,x);
  else upd(rs[p],rs[q],mid+1,r,x);
  t[p]=(t[ls[p]]*mi[r-mid]%mod+t[rs[p]])%mod;
}
bool compare(int x,int y,int l,int r){
  if(!x||!y) return y?1:0;
  if(l==r) return t[x]<t[y];
  if(t[ls[x]]!=t[ls[y]]) return compare(ls[x],ls[y],l,mid);
  return compare(rs[x],rs[y],mid+1,r);
}
bool rcompare(int x,int y,int l,int r){
  if(!x||!y) return !x?0:1;
  if(l==r) return t[x]<t[y];
  if(t[ls[x]]!=t[ls[y]]) return rcompare(ls[x],ls[y],l,mid);
  return rcompare(rs[x],rs[y],mid+1,r);
}
void solve(int c,int l,int r){
  if(!c) return;
  if(l==r) ans[idx[l]]=t[c];
  solve(ls[c],l,mid),solve(rs[c],mid+1,r);
}
struct node{
  int u,rt;
  node(){}
  node(int x,int y){u=x,rt=y;}
  friend bool operator>(node x,node y){
    return compare(x.rt,y.rt,1,m);
  }
  friend bool operator<(node x,node y){
    return rcompare(x.rt,y.rt,1,m);
  }
};
priority_queue<node> pq;
signed main(){IOS;
  cin>>n>>m>>q;
  rep(i,1,m) cin>>edge[i].u>>edge[i].v;
  int tim=0;
  rep(i,1,q){
    int x; cin>>x;
    if(!edge[x].vis) edge[x].vis=1,edge[x].w=++tim,idx[tim]=i;
    else ans[i]=1;
  }
  rep(i,1,m) if(!edge[i].vis) edge[i].w=++tim;
  rep(i,1,m){
    Edge cur=edge[i];
    e[cur.u].eb(cur.v,cur.w);
  }
  mi[0]=1; rep(i,1,m) mi[i]=mi[i-1]*base%mod;
  rt[1]=tot=1,pq.push(node(1,1));
  while(!pq.empty()){
    int u=pq.top().u,nrt=pq.top().rt;
    pq.pop();
    if(rt[u]!=nrt) continue;
    for(auto nxt:e[u]){
      int v=nxt.fi,w=nxt.se,tmp;
      upd(tmp,nrt,1,m,w);
      if(!rt[v]||compare(tmp,rt[v],1,m)){
        rt[v]=tmp,pq.push(node(v,tmp));
      }
    }
  }
  solve(rt[n],1,m);
  rep(i,1,q) cout<<1-ans[i]<<"\n";
}
```

---

## 作者：Filberte (赞：0)

此题中，对于任意一条边而言，只有第一次删除尝试是有效的，原因如下：若这条边在第一次删除尝试中就被删除了，每条边只能被删一次，那么之后的尝试肯定是无效的；若这条边在第一次删除尝试中没有被删除，则说明这条边已经是 $1$ 到 $n$ 的必经边了，后续无论如何操作，因为不会往图中加边，它一定还是必经边。

可以对于每条边 $e$ 求出 $t_e$，表示 $e$ 这条边第一次删除尝试的时刻。特别的，若这条边在 $q$ 次询问中都没有出现，令 $t_e = q + 1$，为每条边 $e$ 赋权 $t_e$。考虑最后会剩下哪一条路径，那么除了这条路径上以外所有边都可以删除。这条路径中， $t_e$ 最小的边应当最大（不妨设之为 $e_0$），否则会存在另一条路径，对于路径上所有边 $e$，均满足 $t_e > t_{e_0}$，因此在尝试删去 $e_0$ 时，若删去 $e_0$，仍存在 $1$ 到 $n$ 的路径，$e_0$ 不是此时的必经边。采用归纳法可以证明，路径中 $t_e$ 次小的边也应当最大，以此类推。所以原问题转化为在原图上寻找一条字典序最大的路径。

这个问题的常规解法是使用迪杰斯特拉算法，通过维护可持久化值域线段树的方式，借助哈希比较两个点哪一个更优。具体的，通过二分加哈希算出两条路径是从第 $x$ 位开始不同，然后在两棵主席树上对应找出前 $x$ 位，判断哪一边权值更小即可，$d_u + w \rightarrow d_v$ 的更新就是把 $v$ 先设成 $u$ 的状态，再往第 $w$ 位上增加一个 $1$，这是主席树易于维护的。该算法的复杂度为 $O(m\log n \log q)$。

但在本题中，需要关注的边的**边权两两不同**。因此可以采取一个更妙的方法：类似迪杰斯特拉，令目前已经扩展到的点集为 $S$，每次找一条权值最大的边 $(u,v)$，使得 $u \in S$ 且 $v \not\in S$，用 $d_u + w$ 更新 $d_v$，此算法的正确性证明可以参照[大佬的题解](https://www.luogu.com.cn/article/qnh1oy15)。此算法的复杂度为 $O(m\log n)$，省去了在可持久化值域线段树上二分这一步，且代码实现较为简洁。

这里提供第二种解法的代码。
```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 100;
bool vis[N];
int t[N];
int n, m, q;
int rsc[N], eid[N], qs[N];
struct Edge{
    int to, id, nxt;
}e[N];int h[N], idx;
void add_edge(int u, int v, int i){e[++idx] = {v, i, h[u]};h[u] = idx;}
bool ban[N], first_vis[N];
int main(){
    // freopen("a.in","r",stdin);
    // freopen("a.out","w",stdout);
    cin >> n >> m >> q;
    for(int i = 1;i <= m;i++){
        int u, v;
        cin >> u >> v;
        t[i] = q + 1;
        add_edge(u, v, i);
    }
    for(int i = 1;i <= q;i++){
        int x;cin >> x;
        qs[i] = x;
        if(t[x] == q + 1){first_vis[i] = 1;t[x] = i;}   
    }
    priority_queue<pair<int, int>> pq;
    pq.push({0, 1});
    while(!pq.empty()){
        int u = pq.top().second;pq.pop();
        if(vis[u]) continue;
        vis[u] = 1;if(u == n) break; 
        for(int i = h[u];i;i = e[i].nxt){
            int v = e[i].to, w = t[e[i].id];
            if(!vis[v] && w > t[eid[v]]){
                rsc[v] = u;
                eid[v] = e[i].id;
                pq.push({t[eid[v]], v});
            }
        }
    }
    for(int u = n;u != 1;u = rsc[u]) ban[eid[u]] = 1;
    for(int i = 1;i <= q;i++) printf("%d\n",(first_vis[i] && !ban[qs[i]]) ? 1 : 0);
    return 0;
}
```

---


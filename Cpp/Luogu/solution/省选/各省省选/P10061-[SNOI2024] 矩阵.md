# [SNOI2024] 矩阵

## 题目描述

你要维护一个 $n \times n$ 的矩阵 $A$，其中第 $i$ 行第 $j$ 列的元素记作 $A_{i, j}$。行和列从 $1$ 开始标号。一开始，有 $A_{i, j} = (i + 1)^j \bmod 998244353$。

你需要支持 $q$ 个操作，每个操作是下面两种操作中的一种。

- $1\ x_1\ y_1\ x_2\ y_2$，这里保证 $y_2 - x_2 = y_1 - x_1$。将子矩形 $[x_1, x_2] \times [y_1, y_2]$ 逆时针旋转 $90$ 度。
  - 具体地，令 $d = x_2 - x_1 + 1$。
  - 首先提取 $d \times d$ 的子矩阵 $A'$，对于所有的 $i, j$（$1 \le i, j \le d$），令 $A'_{i, j} \gets A_{x_1 + i - 1, y_1 + j - 1}$。
  - 然后将 $A'$ 旋转，得到一个 $d \times d$ 的子矩阵 $B'$，令 $B'_{i, j} \gets A'_{j, d - i + 1}$。
  - 然后将 $B'$ 填回到 $A$ 中，对所有的 $i, j$（$1 \le i, j \le d$），令 $A_{i + x_1 - 1, j + y_1 - 1} \gets B'_{i, j}$。
- $2\ x_1\ y_1\ x_2\ y_2\ d$。将子矩形 $[x_1, x_2] \times [y_1, y_2]$ 内所有的元素加 $d$。
  - 具体地，对于每个 $i$（$x_1 \le i \le x_2$）、$j$（$y_1 \le j \le y_2$），令 $A_{i, j} \gets A_{i, j} + d$。

你需要在所有操作结束之后，输出这个矩阵。由于输出可能很大，请输出
$$ \Biggl( \sum_{i = 1}^{n} \sum_{j = 1}^{n} A_{i, j} \times {12345}^{(i - 1) n + j} \Biggr) \bmod 1000000007 $$
的结果。

## 说明/提示

**【样例 \#1 解释】**

对于第一个样例，矩阵分别为
$$\begin{bmatrix} 2 & {\textcolor{red}{4}} & {\textcolor{red}{8}} & {\textcolor{red}{16}} \\ 3 & {\textcolor{red}{9}} & {\textcolor{red}{27}} & {\textcolor{red}{81}} \\ 4 & {\textcolor{red}{16}} & {\textcolor{red}{64}} & {\textcolor{red}{256}} \\ 5 & 25 & 125 & 625 \end{bmatrix} \to \begin{bmatrix} 2 & 16 & 81 & 256 \\ {\textcolor{blue}{3}} & {\textcolor{blue}{8}} & 27 & 64 \\ {\textcolor{blue}{4}} & {\textcolor{blue}{4}} & 9 & 16 \\ {\textcolor{blue}{5}} & {\textcolor{blue}{25}} & 125 & 625 \end{bmatrix} \to \begin{bmatrix} 2 & 16 & 81 & 256 \\ {\textcolor{red}{6}} & {\textcolor{red}{11}} & 27 & 64 \\ {\textcolor{red}{7}} & {\textcolor{red}{7}} & 9 & 16 \\ 8 & 28 & 125 & 625 \end{bmatrix}$$
$$\to \begin{bmatrix} {\textcolor{blue}{2}} & {\textcolor{blue}{16}} & {\textcolor{blue}{81}} & {\textcolor{blue}{256}} \\ 11 & 7 & 27 & 64 \\ 6 & 7 & 9 & 16 \\ 8 & 28 & 125 & 625 \end{bmatrix} \to \begin{bmatrix} 7 & 21 & 86 & 261 \\ 11 & 7 & 27 & 64 \\ 6 & 7 & 9 & 16 \\ 8 & 28 & 125 & 625 \end{bmatrix}$$
其中每个旋转操作对应的数字用红色表示，加操作对应的数字用蓝色表示。

---

**【样例 \#3】**

见附件中 `matrix/matrix3.in` 与 `matrix/matrix3.ans`，这个样例满足测试点 $5 \sim 6$ 的条件限制。

---

**【样例 \#4】**

见附件中 `matrix/matrix3.in` 与 `matrix/matrix3.ans`，这个样例满足测试点 $9 \sim 10$ 的条件限制。

---

**【数据范围】**

对于所有的数据，保证 $1 \le n \le 3000$，$1 \le q \le 3000$。  
对于每个操作，保证 $1 \le x_1 \le x_2 \le n$，$1 \le y_1 \le y_2 \le n$，$1 \le d \le {10}^9$。

具体如下：

| 测试点编号 | $n \le$ | $q \le$ | 特殊性质 |
|:-:|:-:|:-:|:-:|
| $1$ | $100$ | $3000$ | 无 |
| $2$ | $3000$ | $3000$ | A |
| $3 \sim 4$ | $3000$ | $2000$ | B |
| $5 \sim 6$ | $3000$ | $3000$ | B |
| $7 \sim 8$ | $3000$ | $2000$ | 无 |
| $9 \sim 10$ | $3000$ | $3000$ | 无 |

特殊性质 A：保证没有第一类旋转操作。  
特殊性质 B：保证没有第二类加法操作。

## 样例 #1

### 输入

```
4 4
1 1 2 3 4
2 2 1 4 2 3
1 2 1 3 2
2 1 1 1 4 5
```

### 输出

```
984660761
```

## 样例 #2

### 输入

```
10 10
2 5 1 10 4 689412516
1 3 4 3 4
1 3 5 4 6
1 4 1 8 5
1 1 2 1 2
1 4 2 7 5
1 2 5 2 5
2 3 3 3 9 856075030
2 4 2 5 6 308750020
2 1 5 9 7 252732904
```

### 输出

```
94292030
```

# 题解

## 作者：Wuyanru (赞：13)

一道神秘的数据结构题。

[题目链接](https://www.luogu.com.cn/problem/P10061)。

## 题意

给定一个 $n\times n$ 的矩阵，共有 $q$ 次操作，分为两种：

1. 给定一个正方形区域，将其逆时针旋转；
2. 给定一个矩形区域，同时加一个值。

时限 $8s$。

$1\le n,q\le 3000$。

## 题解

发现时限非常大，而 $n\times q$ 却只有 $9\times 10^6$。

普通的思路是，拿两棵平衡树分别维护矩阵的行与列。

矩阵加直接做，旋转可以把平衡树裂开，打反转标记，然后和另一棵平衡树合并在一起（横向的合并去竖向的，竖向的合并去横向的）。

时间复杂度是 $O(n^2+nq\log n)$，看起来很对？

经过一些了解，在考场上这么写的人，大部分在本地跑到了 $100s\sim 250s$（包括我）。

下面是正解：

经过上面平衡树的尝试，我们完全可以知道，这道题维护的复杂度常数一定是巨大的。

这也就告诉我们，正解大概率是单次询问 $O(n)$ 的做法。

发现一个问题，假如只有矩阵加操作，这道题是好做的。

那么说明这道题的难点应该在于旋转操作。

考虑这么一件事情，如果保证旋转操作的对象一直是整个矩阵，这道题好做吗？

非常好做，我们只需要额外维护，整个矩阵现在被操作了几次就好了。

为什么只需要这样就可以维护整个矩阵呢？

因为在旋转的过程中，矩阵内部的“结构”是相对不变的，原来相邻的两个位置现在还是相邻。

这就是旋转操作的特点，回到原题，这告诉我们，假如去维护元素之间的相对位置，那么每一次旋转操作只有 $O(n)$ 个地方会被改变。

那么什么数据结构维护了一个矩阵中，元素之间的相对位置呢？答案是十字链表。

好，现在我们已经知道了旋转操作可以使用十字链表进行维护，那么矩阵加操作也很简单了。

单次 $O(1)$ 的矩阵加操作是困难的，但是单次 $O(n)$ 是简单的，我们只需要维护元素相对位置的同时，维护一下他们两个的差就好了。

做法总结：

1. 使用十字链表维护，每一个元素周围四个位置是谁，他们的差是多少；
2. 对于旋转操作，暴力找到需要断开的位置，然后旋转，再拼上，单次复杂度 $O(n)$；
3. 对于矩阵加操作，差变化的位置也只有 $O(n)$ 个，暴力找到位置，修改，单次复杂度 $O(n)$。

下面是几个实现细节：

1. 对于两种操作，都有 $O(n)$ 个位置需要修改，而链表不支持随机访问，复杂度为什么还是 $O(n)$ 的？

   可以发现，每一次需要修改的地方，一定是 $8$ 条（或者 $4$ 条）连续的线段，这些位置我们可以在 $O(n)$ 的时间内一起找到。
   
2. 假如我们维护每一个位置，左右上下分别是哪些元素，那么在一次旋转过后，他们的方向会改变，这怎么维护？

   这是一个好问题，我暂时没有想到很好的解决方案。

   我的代码只是维护了四个位置的相对顺序，并没有强制钦定哪一个位置对应哪一个方向，访问的时候我们其实可以直接算出这个元素被旋转了几次。
   
总复杂度 $O(n^2+nq)$。

## 代码

跑了 $7s$，常数确实大。

[代码](https://www.luogu.com.cn/paste/dt9gm6bc)

感谢观看！


---

## 作者：5k_sync_closer (赞：9)

给矩阵中每个点一个编号，维护 $v_{i,0/1/2/3},w_{i,0/1/2/3}$ 表示 $i$ 点四周的点，$i$ 点四周的点与 $i$ 点的点权差。

一次操作只会改变选定的子矩形边框上 $O(n)$ 个点四周的点，分别修改它们的 $v,w$ 即可。

然而存在一个问题：旋转操作会使选定的子矩形内的点四周的点的方向发生变化，比如一个点上方的点转完之后会到它左方，

这会使找到一个子矩形边框上的点变得困难，考虑维护出每个点的朝向。

具体地，维护 $z_i$ 表示原来在 $i$ 上方的点现在在 $i$ 的哪个方向（也就是 $i$ 点转了几次），

于是一次旋转操作会使 $z$ 子矩形加一，找子矩形边框上的点时根据 $z$ 判断该往哪边走即可。

考虑如何维护 $z$。类似加法操作，维护 $d_{i,0/1/2/3}$ 表示 $i$ 四周的点与 $i$ 点的 $z$ 之差即可。

这样理论上就可以过了。如果需要在某些跑得飞慢的 OJ 上通过，可以参照下面的代码卡常：

```cpp
#include <cstdio>
#define M 1000000007
struct S
{
    int v;
    long long w;
    int d;
} v[10000050][4];
int n, q, a[3050][3050], f[4][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};
void U(int &p, int &z, long long &q, int o)
{
    int dz = v[p][(o + 4 - z) & 3].d;
    long long dq = v[p][(o + 4 - z) & 3].w;
    p = v[p][(o + 4 - z) & 3].v, z += dz, q += dq, z = (z & 3 + 4) & 3;
}
int Q(int x, int y, int &z, long long &q)
{
    int p = 0;
    z = 0;
    q = 0;
    while (x--)
        U(p, z, q, 2);
    while (y--)
        U(p, z, q, 3);
    return p;
}
signed main()
{
    scanf("%d%d", &n, &q);
    for (int i = 1; i <= n; ++i)
    {
        long long z = 1;
        for (int j = 1; j <= n; ++j)
            z = z * (i + 1) % 998244353, a[i][j] = z;
    }
    for (int i = 0; i <= n + 1; ++i)
        for (int j = 0; j <= n + 1; ++j)
        {
            int u = i * (n + 2) + j;
            for (int k = 0, x, y; k < 4; ++k)
            {
                x = i + f[k][0], y = j + f[k][1];
                if (x < 0 || x > n + 1 || y < 0 || y > n + 1)
                    continue;
                v[u][k].v = x * (n + 2) + y, v[u][k].w = a[x][y] - a[i][j];
            }
        }
    for (int i = 0, o, u1, v1, u2, v2, k, _, x, y, zx, zy; i < q; ++i)
    {
        scanf("%d%d%d%d%d", &o, &u1, &v1, &u2, &v2);
        k = u2 - u1 + 1;
        long long vx, vy;
        if (o & 1)
        {
            x = Q(u2, v1 - 1, zx, vx), y = Q(u1, v1, zy, vy);
            for (int j = 1; j <= k; ++j)
            {
                v[y][(4 - zy) & 3].v = x;
                v[y][(4 - zy) & 3].w = vx - vy;
                v[y][(4 - zy) & 3].d = zx - zy - 1;
                v[x][(7 - zx) & 3].v = y;
                v[x][(7 - zx) & 3].w = vy - vx;
                v[x][(7 - zx) & 3].d = zy - zx + 1;
                U(x, zx, vx, 0);
                if (j != k)
                    U(y, zy, vy, 3);
            }
            U(x, zx, vx, 3);
            for (int j = 1; j <= k; ++j)
            {
                v[y][(7 - zy) & 3].v = x;
                v[y][(7 - zy) & 3].w = vx - vy;
                v[y][(7 - zy) & 3].d = zx - zy - 1;
                v[x][(6 - zx) & 3].v = y;
                v[x][(6 - zx) & 3].w = vy - vx;
                v[x][(6 - zx) & 3].d = zy - zx + 1;
                U(x, zx, vx, 3);
                if (j != k)
                    U(y, zy, vy, 2);
            }
            U(x, zx, vx, 2);
            for (int j = 1; j <= k; ++j)
            {
                v[y][(6 - zy) & 3].v = x;
                v[y][(6 - zy) & 3].w = vx - vy;
                v[y][(6 - zy) & 3].d = zx - zy - 1;
                v[x][(5 - zx) & 3].v = y;
                v[x][(5 - zx) & 3].w = vy - vx;
                v[x][(5 - zx) & 3].d = zy - zx + 1;
                U(x, zx, vx, 2);
                if (j != k)
                    U(y, zy, vy, 1);
            }
            U(x, zx, vx, 1);
            for (int j = 1; j <= k; ++j)
            {
                v[y][(5 - zy) & 3].v = x;
                v[y][(5 - zy) & 3].w = vx - vy;
                v[y][(5 - zy) & 3].d = zx - zy - 1;
                v[x][(4 - zx) & 3].v = y;
                v[x][(4 - zx) & 3].w = vy - vx;
                v[x][(4 - zx) & 3].d = zy - zx + 1;
                U(x, zx, vx, 1);
                if (j != k)
                    U(y, zy, vy, 0);
            }
        }
        else
        {
            scanf("%d", &_);
            x = Q(u1 - 1, v1, zx, vx), y = Q(u1, v1, zy, vy);
            for (int j = 1; j <= v2 - v1 + 1; ++j)
            {
                v[y][(4 - zy) & 3].w = vx - vy - _;
                v[x][(6 - zx) & 3].w = vy - vx + _;
                U(x, zx, vx, 3);
                if (j != v2 - v1 + 1)
                    U(y, zy, vy, 3);
            }
            U(x, zx, vx, 2);
            for (int j = 1; j <= u2 - u1 + 1; ++j)
            {
                v[y][(7 - zy) & 3].w = vx - vy - _;
                v[x][(5 - zx) & 3].w = vy - vx + _;
                U(x, zx, vx, 2);
                if (j != u2 - u1 + 1)
                    U(y, zy, vy, 2);
            }
            U(x, zx, vx, 1);
            for (int j = 1; j <= v2 - v1 + 1; ++j)
            {
                v[y][(6 - zy) & 3].w = vx - vy - _;
                v[x][(4 - zx) & 3].w = vy - vx + _;
                U(x, zx, vx, 1);
                if (j != v2 - v1 + 1)
                    U(y, zy, vy, 1);
            }
            U(x, zx, vx, 0);
            for (int j = 1; j <= u2 - u1 + 1; ++j)
            {
                v[y][(5 - zy) & 3].w = vx - vy - _;
                v[x][(7 - zx) & 3].w = vy - vx + _;
                U(x, zx, vx, 0);
                if (j != u2 - u1 + 1)
                    U(y, zy, vy, 0);
            }
        }
    }
    int x = 0, zx = 0;
    long long _ = 1, vx = 0, s = 0;
    for (int i = 1; i <= n; ++i)
    {
        U(x, zx, vx, 2);
        int y = x, zy = zx;
        long long vy = vx;
        for (int j = 1; j <= n; ++j)
            U(y, zy, vy, 3), _ = _ * 12345 % M, s = (s + vy % M * _ % M) % M;
    }
    printf("%lld", s);
    return 0;
}
```


---

## 作者：konyakest (赞：8)

# [P10061 [SNOI2024] 矩阵](https://www.luogu.com.cn/problem/P10061)

以此篇题解谈两点：

1. 标记永久化与懒标记

2. 代码实现与封装

默认读者从其他题解中知道了本题的十字链表思想。

## 标记永久化与懒标记

懒标记其实是一种“摆烂”的思想，它可以理解为：既然我没办法在正确的复杂度内修改所有，那么我就只修改会对当前访问有影响的点，把修改操作均摊到每次访问的时候。

而标记永久化，是另外一种不同的思想：既然我没法维护原来的数据结构，那么我就维护数据结构**差分/前缀和**的形式，每次查询的时候用已有的信息**重新算出**当前的信息。

如线段树区间加区间求和的标记永久化相当于在说“访问这个节点的子树时默认加上 $len\times tag$”，这可以理解为一种特殊的“差分”。

回到本题，本题的十字链表中使用懒标记是极其困难的，而且具有较大的常数。

但是，我们考虑维护这个结构的差分信息，即维护：

- 当前节点四个邻居与自己权值的差

- 当前节点四个邻居与自己旋转标记的差

就可以较容易地实现。

## 代码实现与封装

相信不少人在看了题解那些冗长的代码就被吓怕了（比如我）。

但其实，只要分析清楚要维护什么，怎么维护，每次修改是在改什么，再加上**使用恰当的封装**，即可写出比较优雅的代码。

首先，十字链表的结构怎么定义？

我个人习惯上使用“类指针结构”维护较复杂的数据结构，所以我这样定义链表：

```cpp
template<typename T>
struct ptr{
	static T data[maxn*maxn];
	int p;
	T* operator->(){return &data[p];}
};

template<typename T>T ptr<T>::data[maxn*maxn];

struct Node{
	struct{
		ll val;
		int d;
		ptr<Node> x;
	}d[4];
};
```

其中，``ptr`` 是一个辅助类，实现了一个指针的抽象。

这样写可以让我们用指针的语法访问静态数组。

``Node`` 结构体中的 ``d`` 数组中，``val`` 是邻居与自己权值的差，``d`` 是邻居与自己旋转标记的差。

接下来，我们发现实现中要大量使用有关方向的信息，此时我们需要定义一个 ``enum`` 或者常量**而不是直接使用 $0/1/2/3$**。

```cpp
const int U=0,R=1,D=2,L=3;
```

然后，我们发现，由于我们这样维护，我们需要额外的变量来存这个节点实际的值（即原数据求前缀和的结果）。

此处很有封装的必要，于是我们实现一个 ``Iter`` 类表示节点的迭代器：

```cpp
struct Iter{
	ll val;
	int d;
	ptr<Node> x;
	Iter operator[](int dir){
		(dir+=d)&=3;
		return {
			val+x->d[dir].val,
			(d+x->d[dir].d)&3,
			x->d[dir].x
		};
	}
	auto& dir(int dir){return x->d[(d+dir)&3];}
};
```

其中 ``operator[]`` 返回四个邻居的迭代器，语法类似于 ``Iter a;a=a[L];``，而 ``dir`` 返回四个方向的 ``d`` 数组的引用，是迭代器修改原数据的接口。

此时，我们发现接下来的实现没有想象中的那么繁杂了，比如“按照坐标找迭代器”的实现 be like：

```cpp
int id(int x,int y){return x*(n+1)+y;}

Iter at(int x,int y){
	Iter it{};
	it.x={id(0,0)};
	rep(_,1,x) it=it[D];
	rep(_,1,y) it=it[R];
	return it;
}
```

然后就是旋转，我们考虑这样的矩形：

![](https://s2.loli.net/2024/12/08/LDVRHExBhGWjiml.jpg)

我们一开始先找到 $a,b,c,d$ 对应的节点，然后每次修改这 $8$ 个节点，使用一次循环完成整个旋转操作。

这样减少了实现的难度，同时可以充分刺激 CPU 并行。

然后我们就开始写...

```cpp
aa.dir(R)={d.val-aa.val,(d.d-aa.d+4+1)&3,d.x};
a.dir(L)={bb.val-a.val,(bb.d-a.d+4+3)&3,bb.x};
```

写到这里你破防了，难道真的要写 $8$ 个这样的语句吗？

我们发现，由于四个点的旋转对称性，我们只需要写 $1$ 条这样的语句，将其封装为宏或者 ``lambda`` 函数，直接调用即可。

``rotate`` 函数的完整实现如下。是不是没有想象的复杂呢？

```cpp
void rotate(pair<int,int> A,pair<int,int> B){
	assert(B.x-A.x==B.y-A.y);
	Iter a=at(A.x,A.y),b=at(B.x,A.y),c=at(B.x,B.y),d=at(A.x,B.y)
	rep(_,1,B.x-A.x+1){
		Iter aa=a[L],bb=b[D],cc=c[R],dd=d[U];

		auto mk1=[&](auto& aa,int R,auto& d){
			aa.dir(R)={d.val-aa.val,(d.d-aa.d+4+1)&3,d.x};
		};
		mk1(aa,R,d),mk1(bb,U,a),mk1(cc,L,b),mk1(dd,D,c);

		auto mk2=[&](auto& a,int L,auto& bb){
			a.dir(L)={bb.val-a.val,(bb.d-a.d+4+3)&3,bb.x};
		};
		mk2(a,L,bb),mk2(b,D,cc),mk2(c,R,dd),mk2(d,U,aa);

		a=a[D],b=b[R],c=c[U],d=d[L];
	}
}
```

``add`` 函数同理。此时我们发现找到 $a,b,c,d$ 四个节点的代码是相同的，因此可以使用宏：

```cpp
#define DEFINE_ITER() Iter a=at(A.x,A.y),b=at(B.x,A.y),c=at(B.x,B.y),d=at(A.x,B.y)
```

这是 ``add`` 函数的实现。由于这部分并不复杂，所以我并没有封装。

```cpp
void add(pair<int,int> A,pair<int,int> B,int val){
	DEFINE_ITER();
	rep(_,1,B.x-A.x+1){
		Iter aa=a[L],cc=c[R];
		aa.dir(R).val+=val,a.dir(L).val-=val;
		cc.dir(L).val+=val,c.dir(R).val-=val;
		a=a[D],c=c[U];
	}
	rep(_,1,B.y-A.y+1){
		Iter bb=b[D],dd=d[U];
		bb.dir(U).val+=val,b.dir(D).val-=val;
		dd.dir(D).val+=val,d.dir(U).val-=val;
		b=b[R],d=d[L];
	}
}
```

[完整代码](https://www.luogu.com.cn/paste/dup80zyg)，代码长度显著低于平均长度，仅 2.5K（不含缺省源）。

说句题外话，不少人有“封装会导致大常数”的错误认知。

实际上，C++ 一直以来的理念就是“零成本抽象”，即“抽象的使用不应该带来额外的运行时开销”。如果你的封装导致了大常数，只能说明你的封装不够好。~~（这也是 stl 函数异常难用的原因）~~

事实上，在 O2 的条件下，``operator->``，``dir`` 这类“小”函数会被直接内联，``lambda`` 会被直接展开，和直接写开没有区别。

这份代码由于“充分刺激 CPU 并行”，截至目前（$2024/12/8$），跑到了[第三优解](https://www.luogu.com.cn/record/193445680)。

---

## 作者：LgxCute (赞：8)

_该算法的时间复杂度可能有问题。_

注意到 8 s 时限，容易想到根号；注意到只用求最终结果，感觉难以直接维护，需要离线。

对修改序列分块，设块长为 $B$。处理出每个位置经过一块修改后的变换（到哪、加多少）：

- 初始时，整个矩阵的变换相同。
- 首次修改时，沿修改范围的四边延伸出的直线把矩阵切成若干个内部变换相同的矩形。
- 接下来的每次修改遍历这些矩形，更新变换，把与修改范围的边界相交的矩形进一步切开。

尽管旋转能使横线和竖线（切口）参次不齐，但预计每块会被切成略少于 $4B^2$ 个矩形（官方数据是这样的）。感觉可以更多，但好像多不到哪去，不妨认为是大常数 $O(B^2)$ 的。

时间复杂度为 $O\left(n^2\dfrac{q}{B}+qB^2\right)$，取 $B=n^\frac{2}{3}$ 得 $O(n^\frac{4}{3}q)$。

因为后半部分常数大，$B$ 应取小几倍。取 $B\in[50,60]$ 时，官方数据跑了 3 s 左右。

```cpp
#include <bits/stdc++.h>

const int N = 3005, Mo = 1e9 + 7;
int n, q, op[N], x[N], y[N], xx[N], yy[N], d[N], a[2][N][N];
struct Trans {
  short xkx = 1, xky = 0, xb = 0, ykx = 0, yky = 1, yb = 0; int add = 0;
  void rotate(int id) {
    int _xkx = xkx, _xky = xky, _xb = xb;
    xkx = -ykx, xky = -yky, xb = xx[id] + y[id] - yb;
    ykx = _xkx, yky = _xky, yb = y[id] - x[id] + _xb;
    // (X, Y) -> (xx[id] + y[id] - Y, y[id] - x[id] + X)
  }
  void addnum(int id) { add = (add + d[id]) % Mo; }
  void trans(int &x, int &y) {
    int _x = x; x = xkx * x + xky * y + xb, y = ykx * _x + yky * y + yb;
  }
  void itrans(short &x, short &y) {
    if (!xky && !ykx) x = (x - xb) / xkx, y = (y - yb) / yky;
    else if (!xkx && !yky) { int _x = x; x = (y - yb) / ykx, y = (_x - xb) / xky; }
    else assert(false); // Never happen.
  }
};
struct Block {
  short xl, xr, yl, yr;
  Block(int _xl, int _xr, int _yl, int _yr): xl(_xl), xr(_xr), yl(_yl), yr(_yr) {}
};
std::vector<std::pair<Block, Trans>> vec[2];

int main() {
  scanf("%d%d", &n, &q);
  for (int i = 1; i <= n; ++i) for (int j = 1, res = 1; j <= n; ++j)
    a[0][i][j] = res = 1ll * res * (i + 1) % 998244353;
  for (int i = 1; i <= q; ++i) {
    scanf("%d%d%d%d%d", &op[i], &x[i], &y[i], &xx[i], &yy[i]);
    if (op[i] == 2) scanf("%d", &d[i]);
  }
  for (int B = __, L = 1, R; L <= q; L += B) {
    R = std::min(L + B - 1, q);
    vec[0].emplace_back(Block(1, n, 1, n), Trans());
    for (int i = L; i <= R; ++i) {
      for (auto it: vec[0]) {
        Block blk = it.first; Trans trs = it.second;
        std::vector<std::pair<short, short>> vx, vy;
        if (xx[i] < blk.xl || blk.xr < x[i] || (x[i] <= blk.xl && blk.xr <= xx[i]))
          vx.emplace_back(blk.xl, blk.xr);
        else if (x[i] <= blk.xl && xx[i] < blk.xr)
          vx.emplace_back(blk.xl, xx[i]), vx.emplace_back(xx[i] + 1, blk.xr);
        else if (blk.xl < x[i] && blk.xr <= xx[i])
          vx.emplace_back(blk.xl, x[i] - 1), vx.emplace_back(x[i], blk.xr);
        else vx.emplace_back(x[i], xx[i]),
             vx.emplace_back(blk.xl, x[i] - 1), vx.emplace_back(xx[i] + 1, blk.xr);
        if (yy[i] < blk.yl || blk.yr < y[i] || (y[i] <= blk.yl && blk.yr <= yy[i]))
          vy.emplace_back(blk.yl, blk.yr);
        else if (y[i] <= blk.yl && yy[i] < blk.yr)
          vy.emplace_back(blk.yl, yy[i]), vy.emplace_back(yy[i] + 1, blk.yr);
        else if (blk.yl < y[i] && blk.yr <= yy[i])
          vy.emplace_back(blk.yl, y[i] - 1), vy.emplace_back(y[i], blk.yr);
        else vy.emplace_back(y[i], yy[i]),
             vy.emplace_back(blk.yl, y[i] - 1), vy.emplace_back(yy[i] + 1, blk.yr);
        for (auto xi: vx) for (auto yi: vy) {
          Block _blk = Block(xi.first, xi.second, yi.first, yi.second);
          Trans _trs = trs;
          if (x[i] <= _blk.xl && _blk.xr <= xx[i] && y[i] <= _blk.yl && _blk.yr <= yy[i]) {
            if (op[i] == 1) {
              _trs.rotate(i);
              _blk.xl = xx[i] + y[i] - _blk.yr, _blk.xr = xx[i] + y[i] - _blk.yl;
              _blk.yl = y[i] - x[i] + xi.first, _blk.yr = y[i] - x[i] + xi.second;
            }
            else _trs.addnum(i);
          }
          vec[1].emplace_back(_blk, _trs);
        }
      }
      vec[0].clear(), std::swap(vec[0], vec[1]);
    }
    for (auto it: vec[0]) {
      Block blk = it.first; Trans trs = it.second;
      trs.itrans(blk.xl, blk.yl), trs.itrans(blk.xr, blk.yr);
      if (blk.xl > blk.xr) std::swap(blk.xl, blk.xr);
      if (blk.yl > blk.yr) std::swap(blk.yl, blk.yr);
      for (int i = blk.xl; i <= blk.xr; ++i) for (int j = blk.yl; j <= blk.yr; ++j) {
        int x = i, y = j; trs.trans(x, y); a[1][x][y] = (a[0][i][j] + trs.add) % Mo;
      }
    }
    vec[0].clear(), std::swap(a[0], a[1]);
  }
  long long ans = 0;
  for (int i = 1, res = 1; i <= n; ++i) for (int j = 1; j <= n; ++j)
    res = 12345ll * res % Mo, ans = (ans + 1ll * a[0][i][j] * res % Mo);
  printf("%lld", ans % Mo);
  return 0;
}
```

---

## 作者：_Ch1F4N_ (赞：5)

考虑在网格间维护一个四联通的无向图，然后边权表示权值之差。

不难发现修改和查询都只要暴力修改 $O(n)$ 条边。

旋转改边权的时候就以最外层某一个点为 $0$ 将整个最外层的相对差算出来就能改变权了。

加法改边权的时候直接暴力即可。

然后怎么找点，我们发现可以在整个网格最外层再维护一些不会变动的点并维护那些边处于 **同一直线上** 那么就可以从最外层出发一直往里面走找到点了，单次还是 $O(n)$ 的。

然后最后通过记录的差推出所有值就行了。

总共复杂度 $O(nq)$，代码还在写。

---

## 作者：ppllxx_9G (赞：4)

## 题解

提供一种不需要打旋转标记的做法。

考虑给每一个节点标号后连边，形成四连通无向图，边权表示相邻节点的权值差。

为了定位图中的一个点，我们需要有一些**不动点**作为参考坐标，那么可以在网格最外层维护一圈不动点，每次从边缘**径直**走向中心。

问题变成如何在旋转后走直线？

延续上面不动点的思想，我们如果能找到一些参考系就好了。

那不如还用之前选的最外层的**不动点**？

我们知道旋转后连边的相对位置不会改变，也就是相对的方向还会是相对的，顺时针、逆时针相邻的边也不会变。

我们又知道起点是不变的，那就能找到**起点相对当前点的方向**，然后以来时的起点作为参考系，考虑向哪个方向旋转。相当于每走一步回头看看来时的路，温故而知新。

这时你已经可以在混乱的图中任意的行走了，那么矩形加是容易，改变矩形最外层的边权就行了。

然后就是矩形旋转，其实就是改变连边。

![](https://cdn.luogu.com.cn/upload/image_hosting/v7zp9o47.png)

仍然是只和矩形最外层有关，双指针指向要修改的两个点（绿边连的黑点），然后连就行了（需要提前备份一份）。

边权的改变其实就是黄色路径的权值和，在双指针移动的时候顺便维护是容易的。

建议一开始多写函数，等到你 T 了再展开。

[AC record](https://www.luogu.com.cn/record/197351327)

思路来自 [Ifxxx](https://www.luogu.com.cn/article/jcsa9ged)。

---

## 作者：耳朵龙_ (赞：4)

VP 的时候想出来了，很开心！~~但是考试结束后 57 min 才过~~

该算法复杂度劣但常数小，当前最优解似乎也是该算法，现有题解未证明其复杂度，这里补一个。

发现旋转操作互相影响难以处理，尝试树形数据结构未果，发现操作间的互相影响并不太多，而且部分分中有 $q$ 较小的数据但没有 $n$ 较小的，考虑对操作分块。具体地，对于 $B$ 次操作，它们的 $2B$ 个 $x$ 坐标最多将坐标轴划分为 $2x+1$ 段，$y$ 坐标同理，因此矩阵最多被划分成 $(2x+1)^2$ 个子矩阵。注意这里的分析并不是将矩阵划分后旋转，而是每次询问时划分一下，这样最终就会被划分成上述最多$(2x+1)^2$ 个子矩阵。

把询问分成大小为 $B$ 的块，对于每次询问，暴力遍历目前所有 $O(B^2)$ 个子矩阵并进行划分，然后暴力打标记，每 $\frac{q}{B}$ 次询问后重构矩阵，复杂度为 $O\left(\frac{q}{B}\left(B^3+n^2\right)\right)=O\left(qB^2+\frac{qn^2}{B}\right)$，取 $B=n^{\frac{2}{3}}$ 复杂度为 $O(qn^{\frac{4}{3}})$。实现时取 $B=70$ 比较快。

代码较长，细节多。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3003,p0=998244353,p1=1000000007,BLK=70,Q=19890;
int n,q,tp,ans,A[N][N],B[N][N];
struct node{int x,y,l1,l2,a,b,d,t;}st[Q];
int add(int x,int y){return x+y>=p1?x+y-p1:x+y;}
void rebuild(){
	for(int i=1;i<=tp;++i)
		if(st[i].d==0)
			for(int j=0;j<=st[i].l1;++j)
				for(int k=0;k<=st[i].l2;++k)
					B[st[i].a+j][st[i].b+k]=add(A[st[i].x+j][st[i].y+k],st[i].t);
		else if(st[i].d==1)
			for(int j=0;j<=st[i].l1;++j)
				for(int k=0;k<=st[i].l2;++k)
					B[st[i].a-k][st[i].b+j]=add(A[st[i].x+j][st[i].y+k],st[i].t);
		else if(st[i].d==2)
			for(int j=0;j<=st[i].l1;++j)
				for(int k=0;k<=st[i].l2;++k)
					B[st[i].a-j][st[i].b-k]=add(A[st[i].x+j][st[i].y+k],st[i].t);
		else
			for(int j=0;j<=st[i].l1;++j)
				for(int k=0;k<=st[i].l2;++k)
					B[st[i].a+k][st[i].b-j]=add(A[st[i].x+j][st[i].y+k],st[i].t);
	for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) A[i][j]=B[i][j];
	st[tp=1]={1,1,n-1,n-1,1,1,0,0};
}
void split1(int x){
	for(int i=tp;i;--i)
		if(st[i].d==0){
			if(st[i].a<=x&&x<st[i].a+st[i].l1){
				st[++tp]=st[i],st[i].l1=x-st[i].a;
				st[tp].l1-=x-st[i].a+1,st[tp].x+=x-st[i].a+1,st[tp].a=x+1;
			}
		}else if(st[i].d==1){
			if(st[i].a-st[i].l2<=x&&x<st[i].a){
				st[++tp]=st[i],st[i].l2=st[i].a-x-1;
				st[tp].l2-=st[i].a-x,st[tp].y+=st[i].a-x,st[tp].a=x;
			}
		}else if(st[i].d==2){
			if(st[i].a-st[i].l1<=x&&x<st[i].a){
				st[++tp]=st[i],st[i].l1=st[i].a-x-1;
				st[tp].l1-=st[i].a-x,st[tp].x+=st[i].a-x,st[tp].a=x;
			}
		}else{
			if(st[i].a<=x&&x<st[i].a+st[i].l2){
				st[++tp]=st[i],st[i].l2=x-st[i].a;
				st[tp].l2-=x-st[i].a+1,st[tp].y+=x-st[i].a+1,st[tp].a=x+1;
			}
		}
}
void split2(int x){
	for(int i=tp;i;--i)
		if(st[i].d==0){
			if(st[i].b<=x&&x<st[i].b+st[i].l2){
				st[++tp]=st[i],st[i].l2=x-st[i].b;
				st[tp].l2-=x-st[i].b+1,st[tp].y+=x-st[i].b+1,st[tp].b=x+1;
			}
		}else if(st[i].d==1){
			if(st[i].b<=x&&x<st[i].b+st[i].l1){
				st[++tp]=st[i],st[i].l1=x-st[i].b;
				st[tp].l1-=x-st[i].b+1,st[tp].x+=x-st[i].b+1,st[tp].b=x+1;
			}
		}else if(st[i].d==2){
			if(st[i].b-st[i].l2<=x&&x<st[i].b){
				st[++tp]=st[i],st[i].l2=st[i].b-x-1;
				st[tp].l2-=st[i].b-x,st[tp].y+=st[i].b-x,st[tp].b=x;
			}
		}else{
			if(st[i].b-st[i].l1<=x&&x<st[i].b){
				st[++tp]=st[i],st[i].l1=st[i].b-x-1;
				st[tp].l1-=st[i].b-x,st[tp].x+=st[i].b-x,st[tp].b=x;
			}
		}
}
int a,b,c,d;
bool chk(int i){
	if(st[i].d==0)
		return a<=st[i].a&&st[i].a+st[i].l1<=c&&b<=st[i].b&&st[i].b+st[i].l2<=d;
	if(st[i].d==1)
		return a<=st[i].a-st[i].l2&&st[i].a<=c&&b<=st[i].b&&st[i].b+st[i].l1<=d;
	if(st[i].d==2)
		return a<=st[i].a-st[i].l1&&st[i].a<=c&&b<=st[i].b-st[i].l2&&st[i].b<=d;
	if(st[i].d==3)
		return a<=st[i].a&&st[i].a+st[i].l2<=c&&b<=st[i].b-st[i].l1&&st[i].b<=d;
	return 0;
}
int main(){
	scanf("%d%d",&n,&q),st[tp=1]={1,1,n-1,n-1,1,1,0,0};
	for(int i=1;i<=n;++i)
		for(int j=1,c=1;j<=n;++j)
			A[i][j]=c=c*1ll*(i+1)%p0;
	for(int _=1,op;_<=q;++_){
		scanf("%d%d%d%d%d",&op,&a,&b,&c,&d);
		split1(c),split1(a-1),split2(d),split2(b-1);
		if(op==1){
			op=c-a+1;
			for(int i=tp,x,y;i;--i)
				if(chk(i)){
					st[i].d=(st[i].d+1)&3;
					x=op-st[i].b+b,y=st[i].a-a+1;
					st[i].a=a+x-1,st[i].b=b+y-1;
				}
		}else{
			scanf("%d",&op);
			for(int i=tp;i;--i)
				if(chk(i))
					st[i].t=add(st[i].t,op);
		}
		if(_==q||_%BLK==0) rebuild();
	}
	for(int i=1,s=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			s=s*12345ll%p1,ans=(ans+A[i][j]*1ll*s)%p1;
	return printf("%d",ans),0;
}
```

---

## 作者：Leasier (赞：4)

看到 $n, q \leq 3 \times 10^3$ 与 8s 的时限，我的第一反应是下面这个做法：

- 考虑对每行 $\mathcal{P}$ 和每个原来在同一行、但旋转后变成同一列的列 $\mathcal{Q}$ 维护一棵平衡树。
- 进行旋转操作时，把 $\mathcal{P}[x_1, x_2]$ 中的元素映射到 $\mathcal{Q}[x_1, x_2]$ 中去，反之亦然。显然我们每次一定会切下来完整的一段、插入到完整的空里去。
- 进行子矩阵加操作时，枚举行列，在平衡树上区间加即可。
- 时间复杂度为 $O(nq \log n)$。

然后测了一下极限数据，要跑 40s 左右。交上去[获得了与暴力同分的好成绩](https://loj.ac/s/1983973)，但感觉可能不如暴力快 /fad

如果不用平衡树，感觉也没有啥带 $\log$ 的数据结构适于维护这玩意了 /ng

考虑回到问题的本质，**每次进行旋转操作后矩阵发生了什么变化**？

我们所操作的子矩形内部和外部的**相对关系**是不变的，唯一变化的是该子矩形的边界与外部接壤的位置。

注意到这些位置只有 $O(n)$ 个，考虑把它们抓出来暴力修改与外部何点接壤。

具体地，我们对每个位置维护其四联通的位置。由于上下左右关系时刻变化，我们需要维护哪两对位置在内部相对。

于是我们需要支持查询一个坐标 $(x, y)$ 的位置：从边界开始走即可。

接下来考虑子矩阵加操作。如果没有旋转操作，我们直接差分维护即可；注意到差分的本质就是**相邻信息的差**，于是我们再对每个点维护其值与和其四联通位置的差即可。

不难发现在每次子矩阵加操作中，我们还是只需要修改那 $O(n)$ 个点的信息。

时间复杂度为 $O(nq)$。可能需要一些常数优化。

具体细节可以参考代码。

代码：
```cpp
#include <stdio.h>

typedef long long ll;

typedef struct {
	int to[4];
	int delta[4];
} Node;

typedef struct Info_tag {
	int pos;
	int from;
	int val;
	Info_tag(){}
	Info_tag(int pos_, int from_, int val_){
		pos = pos_;
		from = from_;
		val = val_;
	}
} Info;

const int mod1 = 998244353, mod2 = 1e9 + 7, seed = 12345;
int id[3007][3007], a[3007][3007], dx[4] = {-1, 0, 0, 1}, dy[4] = {0, -1, 1, 0}, pos[3007][3007], rdir[3007][3007][4];
Node b[9012007];

inline int sub1(int x, int y){
	return x - y < 0 ? x - y + mod2 : x - y;
}

inline void add(int &x, int y){
	if ((x += y) >= mod2) x -= mod2;
}

inline void sub2(int &x, int y){
	if ((x -= y) < 0) x += mod2;
}

inline int get_way(int x, int y){
	if (b[y].to[0] == x) return 0;
	if (b[y].to[1] == x) return 1;
	if (b[y].to[2] == x) return 2;
	return 3;
}

Info findx(int x, int y){
	int pos = id[0][y], dir = 3;
	ll val = 0;
	for (register int i = 1; i <= x; i++){
		int t = b[pos].to[dir];
		val += b[pos].delta[dir];
		dir = get_way(pos, t) ^ 3;
		pos = t;
	}
	return Info(pos, dir, mod2 - val % mod2);
}

int findy(int x, int y){
	int pos = id[x][0], dir = 2;
	for (register int i = 1; i <= y; i++){
		int t = b[pos].to[dir];
		dir = get_way(pos, t) ^ 3;
		pos = t;
	}
	return dir;
}

inline void around(int x1, int y1, int x2, int y2){
	int dir;
	Info info1 = findx(x1, y1), info2 = findx(x2, y2);
	pos[x1][y1] = info1.pos;
	dir = info1.from;
	a[x1][y1] = info1.val;
	for (register int i = x1 + 1; i <= x2; i++){
		pos[i][y1] = b[pos[i - 1][y1]].to[dir];
		a[i][y1] = sub1(a[i - 1][y1], b[pos[i - 1][y1]].delta[dir]);
		dir = get_way(pos[i - 1][y1], pos[i][y1]) ^ 3;
	}
	dir = findy(x1, y1);
	for (register int i = y1 + 1; i <= y2; i++){
		pos[x1][i] = b[pos[x1][i - 1]].to[dir];
		a[x1][i] = sub1(a[x1][i - 1], b[pos[x1][i - 1]].delta[dir]);
		dir = get_way(pos[x1][i - 1], pos[x1][i]) ^ 3;
	}
	pos[x2][y2] = info2.pos;
	dir = info2.from ^ 3;
	a[x2][y2] = info2.val;
	for (register int i = x2 - 1; i > x1; i--){
		pos[i][y2] = b[pos[i + 1][y2]].to[dir];
		a[i][y2] = sub1(a[i + 1][y2], b[pos[i + 1][y2]].delta[dir]);
		dir = get_way(pos[i + 1][y2], pos[i][y2]) ^ 3;
	}
	dir = findy(x2, y2) ^ 3;
	for (register int i = y2 - 1; i > y1; i--){
		pos[x2][i] = b[pos[x2][i + 1]].to[dir];
		a[x2][i] = sub1(a[x2][i + 1], b[pos[x2][i + 1]].delta[dir]);
		dir = get_way(pos[x2][i + 1], pos[x2][i]) ^ 3;
	}
}

inline void extract(int n){
	for (register int i = 1; i <= n; i++){
		int pos = id[i][0], dir = 2, val = 0;
		for (register int j = 1; j <= n; j++){
			int t = b[pos].to[dir];
			sub2(val, b[pos].delta[dir]);
			a[i][j] = val;
			dir = get_way(pos, t) ^ 3;
			pos = t;
		}
	}
}

int main(){
	int n, q, ni, val = 1, cnt = 0, ans = 0;
	scanf("%d %d", &n, &q);
	ni = n + 1;
	for (register int i = 1; i <= n; i++){
		int val = 1, ii = i + 1;
		for (register int j = 1; j <= n; j++){
			val = a[i][j] = 1ll * val * ii % mod1;
		}
	}
	for (register int i = 0; i <= ni; i++){
		for (register int j = 0; j <= ni; j++){
			id[i][j] = ++cnt;
		}
	}
	for (register int i = 0; i <= ni; i++){
		for (register int j = 0; j <= ni; j++){
			for (register int k = 0; k <= 3; k++){
				int new_x = i + dx[k], new_y = j + dy[k];
				if (new_x >= 0 && new_x <= ni && new_y >= 0 && new_y <= ni){
					b[id[i][j]].to[k] = id[new_x][new_y];
					b[id[i][j]].delta[k] = sub1(a[i][j], a[new_x][new_y]);
				}
			}
		}
	}
	for (register int i = 1; i <= q; i++){
		int op, x1, y1, x2, y2;
		scanf("%d %d %d %d %d", &op, &x1, &y1, &x2, &y2);
		around(x1, y1, x2, y2);
		around(x1 - 1, y1 - 1, x2 + 1, y2 + 1);
		for (register int j = x1; j <= x2; j++){
			rdir[j][y1][1] = get_way(pos[j][y1 - 1], pos[j][y1]);
			rdir[j][y2][2] = get_way(pos[j][y2 + 1], pos[j][y2]);
		}
		for (register int j = y1; j <= y2; j++){
			rdir[x1][j][0] = get_way(pos[x1 - 1][j], pos[x1][j]);
			rdir[x2][j][3] = get_way(pos[x2 + 1][j], pos[x2][j]);
		}
		if (op == 1){
			for (register int j = x1, k = y1; j <= x2; j++, k++){
				int p = rdir[j][y1][1], pre = get_way(pos[x2][k], pos[x2 + 1][k]), q = rdir[j][y2][2];
				b[pos[j][y1]].to[p] = pos[x2 + 1][k];
				b[pos[j][y1]].delta[p] = sub1(a[j][y1], a[x2 + 1][k]);
				b[pos[x2 + 1][k]].to[pre] = pos[j][y1];
				b[pos[x2 + 1][k]].delta[pre] = mod2 - b[pos[j][y1]].delta[p];
				pre = get_way(pos[x1][k], pos[x1 - 1][k]);
				b[pos[j][y2]].to[q] = pos[x1 - 1][k];
				b[pos[j][y2]].delta[q] = sub1(a[j][y2], a[x1 - 1][k]);
				b[pos[x1 - 1][k]].to[pre] = pos[j][y2];
				b[pos[x1 - 1][k]].delta[pre] = mod2 - b[pos[j][y2]].delta[q];
			}
			for (register int j = y1, k = x2; j <= y2; j++, k--){
				int p = rdir[x1][j][0], pre = get_way(pos[k][y1], pos[k][y1 - 1]), q = rdir[x2][j][3];
				b[pos[x1][j]].to[p] = pos[k][y1 - 1];
				b[pos[x1][j]].delta[p] = sub1(a[x1][j], a[k][y1 - 1]);
				b[pos[k][y1 - 1]].to[pre] = pos[x1][j];
				b[pos[k][y1 - 1]].delta[pre] = mod2 - b[pos[x1][j]].delta[p];
				pre = get_way(pos[k][y2], pos[k][y2 + 1]);
				b[pos[x2][j]].to[q] = pos[k][y2 + 1];
				b[pos[x2][j]].delta[q] = sub1(a[x2][j], a[k][y2 + 1]);
				b[pos[k][y2 + 1]].to[pre] = pos[x2][j];
				b[pos[k][y2 + 1]].delta[pre] = mod2 - b[pos[x2][j]].delta[q];
			}
		} else {
			int d;
			scanf("%d", &d);
			for (register int j = x1; j <= x2; j++){
				add(b[pos[j][y1]].delta[rdir[j][y1][1]], d);
				sub2(b[pos[j][y1 - 1]].delta[get_way(pos[j][y1], pos[j][y1 - 1])], d);
				add(b[pos[j][y2]].delta[rdir[j][y2][2]], d);
				sub2(b[pos[j][y2 + 1]].delta[get_way(pos[j][y2], pos[j][y2 + 1])], d);
			}
			for (register int j = y1; j <= y2; j++){
				add(b[pos[x1][j]].delta[rdir[x1][j][0]], d);
				sub2(b[pos[x1 - 1][j]].delta[get_way(pos[x1][j], pos[x1 - 1][j])], d);
				add(b[pos[x2][j]].delta[rdir[x2][j][3]], d);
				sub2(b[pos[x2 + 1][j]].delta[get_way(pos[x2][j], pos[x2 + 1][j])], d);
			}
		}
	}
	extract(n);
	for (register int i = 1; i <= n; i++){
		for (register int j = 1; j <= n; j++){
			val = 1ll * val * seed % mod2;
			add(ans, 1ll * val * a[i][j] % mod2);
		}
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：int_R (赞：4)

[更好的阅读体验](https://www.cnblogs.com/int-R/p/17980764/P10061)

[原题链接](https://www.luogu.com.cn/problem/P10061)

考虑记录每个元素相邻的四个元素，发现每次旋转只会影响最周围一圈的点与旁边一圈点的连接，所以考虑十字链表维护，单次操作 $O(n)$ 可以接受。

矩阵加怎么做，我们还是采用上述的思路，在维护元素相邻的时候维护相邻两个元素的差值，这样可以 $O(n)$ 矩阵加，因为还是只对最周围一圈操作。查询元素值是单次 $O(n)$ 的，因为你要从链表最边缘开始走，但是查询 $n$ 个连续的元素值是均摊 $O(1)$ 的。

然后思考一下细节，发现每次旋转以后方向是会变的，要知道每次应该往哪个方向走应当知道当前元素旋转了几次，每次旋转都是对一个子矩阵，所以还是相当于矩阵加，多维护一个即可。总结是：

- $O(n)$ 求出最周围一圈与旁边一圈的元素值和旋转次数。
- $O(n)$ 将最周围一圈点的旋转次数都加一。
- $O(n)$ 修改十字链表，更新链表值，元素值差值和旋转次数差值。

但是代码很难写，值得一提的细节是在旋转时可以先存下来最周围一圈每个点和其相邻点还有两者的方向，这样应该要好写一点。还有就是将旋转次数加一时要不重不漏，需要注意角落和只有一条线或点的情况。

卡常的话，最开始不要快速幂，直接用 $(i,j-1)$ 的值乘 $i+1$。操作中不需要取模，只开几个 `long long` 比较快。大量的 `%4` 可以改成 `&3`，但这条可能有副作用。

我的代码没有封装，因为我觉得封装了更难调。

```cpp
#include<stdio.h>
#include<iostream>
#include<algorithm>
using namespace std;
const int MAXN=3010;
int MOD=998244353,n,q;long long ans;
struct node{long long num,v[4];int sum,a[4],s[4];}p[MAXN*MAXN];
struct rota{int x,tx,y,ty;}K[4][MAXN];
inline int N(int x,int y)
{
    if(x>n||y>n) return 0;
    return x*(n+1)+y;
}
signed main()
{
    // freopen("matrix.in","r",stdin);
    // freopen("matrix.out","w",stdout);
    cin.tie(0),cout.tie(0);
    ios::sync_with_stdio(0);
    cin>>n>>q;
    for(int i=1;i<=n;++i)
        for(int j=1;j<=n;++j)
        {
            int cur=N(i,j);
            p[cur].num=(j==1)?(i+1):p[cur-1].num*(i+1)%MOD;
            p[cur].a[0]=N(i,j+1);
            p[cur].a[1]=N(i+1,j);
            p[cur].a[2]=N(i,j-1);
            p[cur].a[3]=N(i-1,j);
        }
    for(int i=1;i<=n;++i) p[i].a[1]=N(1,i);
    for(int i=1;i<=n;++i) p[i*(n+1)].a[0]=N(i,1);
    for(int i=0;i<(n+1)*(n+1);++i)
        for(int j=0;j<4;++j)
            p[i].v[j]=p[p[i].a[j]].num-p[i].num;
    while(q--)
    {
        int opt,xa,ya,xb,yb,d;long long S=0;
        cin>>opt>>xa>>ya>>xb>>yb;
        if(opt==1)
        {
            S=0;
            for(int i=0,cur=xa*(n+1),c=0;i<=yb;++i)
            {
                int nxt=p[cur].a[c];
                if(i>=ya&&i<=yb)
                {
                    p[cur].num=S;p[cur].sum=c;
                    int x=cur,tx=(c+3)%4;
                    int y=p[x].a[tx],ty=(c+p[x].s[tx]+1)%4;
                    p[y].num=S+p[x].v[tx],p[y].sum=(c+p[x].s[tx])%4;
                    K[0][i-ya]={x,tx,y,ty};
                }
                S=S+p[cur].v[c];
                c+=p[cur].s[c];c=(c+4)%4;cur=nxt;
            }
            S=0;
            for(int i=0,cur=xb*(n+1),c=0;i<=yb;++i)
            {
                int nxt=p[cur].a[c];
                if(i>=ya&&i<=yb)
                {
                    p[cur].num=S;p[cur].sum=c;
                    int x=cur,tx=(c+1)%4;
                    int y=p[x].a[tx],ty=(c+p[x].s[tx]+3)%4;
                    p[y].num=S+p[x].v[tx],p[y].sum=(c+p[x].s[tx])%4;
                    K[1][i-ya]={x,tx,y,ty};
                }
                S=S+p[cur].v[c];
                c+=p[cur].s[c];c=(c+4)%4;cur=nxt;
            }
            S=0;
            for(int i=0,cur=ya,c=0;i<=xb;++i)
            {
                int nxt=p[cur].a[(c+1)%4];
                if(i>=xa&&i<=xb)
                {
                    p[cur].num=S;p[cur].sum=c;
                    int x=cur,tx=(c+2)%4;
                    int y=p[x].a[tx],ty=(c+p[x].s[tx])%4;
                    p[y].num=S+p[x].v[tx],p[y].sum=(c+p[x].s[tx])%4;
                    K[2][i-xa]={x,tx,y,ty};
                }
                S=S+p[cur].v[(c+1)%4];
                c+=p[cur].s[(c+1)%4];c=(c+4)%4;cur=nxt;
            }
            S=0;
            for(int i=0,cur=yb,c=0;i<=xb;++i)
            {
                int nxt=p[cur].a[(c+1)%4];
                if(i>=xa&&i<=xb)
                {
                    p[cur].num=S;p[cur].sum=c;
                    int x=cur,tx=c%4;
                    int y=p[x].a[tx],ty=(c+p[x].s[tx]+2)%4;
                    p[y].num=S+p[x].v[tx],p[y].sum=(c+p[x].s[tx])%4;
                    K[3][i-xa]={x,tx,y,ty};
                }
                S=S+p[cur].v[(c+1)%4];
                c+=p[cur].s[(c+1)%4];c=(c+4)%4;cur=nxt;
            }  
            for(int i=0;i<=xb-xa;++i) p[K[0][i].x].sum++;
            if(xa!=xb) for(int i=0;i<=xb-xa;++i) p[K[1][i].x].sum++;
            for(int i=1;i<xb-xa;++i) p[K[2][i].x].sum++;
            if(ya!=yb) for(int i=1;i<xb-xa;++i) p[K[3][i].x].sum++;
            for(int i=0;i<=xb-xa;++i)
            {
                int x=K[0][i].x,tx=K[0][i].tx;
                int y=K[2][xb-xa-i].y,ty=K[2][xb-xa-i].ty;
                p[x].a[tx]=y,p[y].a[ty]=x;
                p[x].v[tx]=p[y].num-p[x].num;
                p[y].v[ty]=p[x].num-p[y].num;
                p[x].s[tx]=(p[y].sum-p[x].sum+4)%4;
                p[y].s[ty]=(p[x].sum-p[y].sum+4)%4;
            }
            for(int i=0;i<=xb-xa;++i)
            {
                int x=K[1][i].x,tx=K[1][i].tx;
                int y=K[3][xb-xa-i].y,ty=K[3][xb-xa-i].ty;
                p[x].a[tx]=y,p[y].a[ty]=x;
                p[x].v[tx]=p[y].num-p[x].num;
                p[y].v[ty]=p[x].num-p[y].num;
                p[x].s[tx]=(p[y].sum-p[x].sum+4)%4;
                p[y].s[ty]=(p[x].sum-p[y].sum+4)%4;
            }
            for(int i=0;i<=xb-xa;++i)
            {
                int x=K[2][i].x,tx=K[2][i].tx;
                int y=K[1][i].y,ty=K[1][i].ty;
                p[x].a[tx]=y,p[y].a[ty]=x;
                p[x].v[tx]=p[y].num-p[x].num;
                p[y].v[ty]=p[x].num-p[y].num;
                p[x].s[tx]=(p[y].sum-p[x].sum+4)%4;
                p[y].s[ty]=(p[x].sum-p[y].sum+4)%4;
            }
            for(int i=0;i<=xb-xa;++i)
            {
                int x=K[3][i].x,tx=K[3][i].tx;
                int y=K[0][i].y,ty=K[0][i].ty;
                p[x].a[tx]=y,p[y].a[ty]=x;
                p[x].v[tx]=p[y].num-p[x].num;
                p[y].v[ty]=p[x].num-p[y].num;
                p[x].s[tx]=(p[y].sum-p[x].sum+4)%4;
                p[y].s[ty]=(p[x].sum-p[y].sum+4)%4;
            }
        }
        if(opt==2)
        {
            cin>>d;
            for(int i=0,cur=xa*(n+1),c=0;i<=yb;++i)
            {
                if(i>=ya&&i<=yb)
                {
                    int x=cur,tx=(c+3)%4;
                    int y=p[x].a[tx],ty=(c+p[x].s[tx]+1)%4;
                    p[x].v[tx]-=d,p[y].v[ty]+=d;
                }
                int nxt=p[cur].a[c];c+=p[cur].s[c];c=(c+4)%4;cur=nxt;
            }
            for(int i=0,cur=xb*(n+1),c=0;i<=yb;++i)
            {
                if(i>=ya&&i<=yb)
                {
                    int x=cur,tx=(c+1)%4;
                    int y=p[x].a[tx],ty=(c+p[x].s[tx]+3)%4;
                    p[x].v[tx]-=d,p[y].v[ty]+=d;
                }
                int nxt=p[cur].a[c];c+=p[cur].s[c];c=(c+4)%4;cur=nxt;
            }
            for(int i=0,cur=ya,c=0;i<=xb;++i)
            {
                if(i>=xa&&i<=xb)
                {
                    int x=cur,tx=(c+2)%4;
                    int y=p[x].a[tx],ty=(c+p[x].s[tx])%4;
                    p[x].v[tx]-=d,p[y].v[ty]+=d;
                }
                int nxt=p[cur].a[(c+1)%4];c+=p[cur].s[(c+1)%4];c=(c+4)%4;cur=nxt;
            }
            for(int i=0,cur=yb,c=0;i<=xb;++i)
            {
                if(i>=xa&&i<=xb)
                {
                    int x=cur,tx=c%4;
                    int y=p[x].a[tx],ty=(c+p[x].s[tx]+2)%4;
                    p[x].v[tx]-=d,p[y].v[ty]+=d;
                }
                int nxt=p[cur].a[(c+1)%4];c+=p[cur].s[(c+1)%4];c=(c+4)%4;cur=nxt;
            }
        }
    }
    MOD=1e9+7;long long P=1;
    for(int i=1;i<=n;++i)
    {
        long long S=0;
        for(int j=i*(n+1),c=0;j;)
        {
            if(j%(n+1)) P=P*12345%MOD,ans=(ans+P*S)%MOD;
            int nxt=p[j].a[c];S=(S+p[j].v[c])%MOD;
            c+=p[j].s[c];c=(c+4)%4;j=nxt;
        }
    }
    cout<<(ans+MOD)%MOD<<'\n';return 0;
}
```

---

## 作者：Genius_Star (赞：1)

~~神仙小清新数据结构题，膜拜……~~

### 思路：

刚开始想的是平衡树做法，维护每行每列的平衡树，时间复杂度为 $O(QN \log N)$，但是写了一大坨交上去获得了与**暴力**同分的“好成绩”，于是只能想正解。

这题总共写了两天，一天平衡树，一天写正解，调到大脑崩溃啊！

因为此题的难点是旋转操作，如果只有加法操作，可以用二维差分解决；但是加上懒标记后，这个差分标记无法一起旋转。

发现对于每次旋转后，矩阵内的点（即不在**边界**上的点）的**相对位置**是不会发生改变的，即这个点四周相邻的点是不会发生变化的；只有在**边界**上的点**上下左右**中有一个点会发生变化。

于是考虑对于每一个点维护一个**十字链表**，记录上下左右点的**值与该点的差**，这样只要知道矩阵中任意一个点的值，就可以由此推出整个矩阵的值。

对于每次操作：

- 将 $x_1-1$，$x_1$，$x_2$，$x_2+1$ 这些行中 $[y_1,y_2]$ 范围内的数**提取**出来；将 $y_1$，$y_1$，$y_2$，$y_2+1$ 这些列中 $[x_1,x_2]$ 范围内的数**提取**出来（因为这些位置所维护的**十字链表**会因为某些操作进行修改）。

但是因为有旋转操作，所以我们需要有一个**源点 $(0,0)$**，连接着 $(0,1)$ 和 $(1,0)$，然后提取操作如下：

- 每次提取第 $x$ 行 $[l,r]$ 范围时，将源点往下走 $x$ 次，走到 $(x,0)$ 这个位置，然后向右走 $l-1$ 次，走到 $(x,l-1)$；然后再走 $r-l+1$ 次，每次将当前位置的节点记录下来。

- 每次提取第 $x$ 列 $[l,r]$ 范围时，将源点往右走 $x$ 次，走到 $(0,x)$ 这个位置，然后向下走 $l-1$ 次，走到 $(l-1,x)$；然后再走 $r-l+1$ 次，每次将当前位置的节点记录下来。

注意，在提取的时候，我们可以顺带将提取的节点的值给算出来，可以方便以后更新差值。

对于加法操作：

- 将**上下左右**的差进行更新即可。

对于旋转操作：

- 每次需要将**边界**上的点中其中一条边撤销，连向旋转后的另外一个点，更新差值。

这样我们会发现一个问题，虽然每次进行旋转后矩阵中间节点的**相对位置**不会改变，但是进行旋转后，原来在上面的点会旋到左边，在左边的点会旋到下边，依次类推。

这样是无法固定找到向某个方向移动的点是通过哪条边相连的，于是考虑对于每一个点维护**当前被旋转的次数**，也可以用**十字链表**记录与四周的差值，那么这样就可以进行维护了。

时间复杂度为 $O(QN)$。

~~最慢的点跑了 6.29s，感觉还不错。~~

### 常数优化：

- 如果需要对 $4$ 取模的话，可以用 ``&3``。

- 每次将第 $x_1-1$ 行提取出 $[y_1,y_2]$ 后记为 $A_0$，则第 $x_1$ 行的 $[y_1,y_2]$ 是由 $A_0$ 中每一个元素往下走一次形成的；对于列也一样。

- 尽量使用 ``int``，少使用 ``long long``。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
const ll N=3030,M=4,mod=1e9+7,P=998244353,mul=12345ll;
namespace IN{
    #define getc() (p1==p2&&(p2=(p1=buf)+inbuf->sgetn(buf,21),p1==p2)?EOF:*p1++)
    char buf[21],*p1,*p2;
    template<typename T>inline bool read(T &x){
        static std::streambuf *inbuf=cin.rdbuf();
        x=0;
		bool f=1;
	    char c=getc();
	    while(c<'0'||c>'9'){
	        if(c=='-')
	          f=-1;
	        c=getc();
	    }
	    while(c>='0'&&c<='9'){
	        x=(x<<1)+(x<<3)+(c^48);
	        c=getc();
	    }
        return f;
    }
    template<typename T,typename ...Args>inline bool read(T& a,Args& ...args){
       return read(a)&&read(args...);
    }
    #undef getc
}
namespace OUT{
    template<typename T>inline void put(T x){
        static std::streambuf *outbuf=cout.rdbuf();
        static char s[21];
        static int top=0;
        if(x<0){
            outbuf->sputc('-');
            x=-x;
        }
        if(!x){
            outbuf->sputc('0');
            outbuf->sputc('\n');
            return;
        }
        while(x){
            s[++top]=x%10+'0';
            x/=10;
        }
        while(top){
            outbuf->sputc(s[top]);
            --top;
        }
        outbuf->sputc('\n');
    }
    inline void putc(const char ch){
        static std::streambuf *outbuf=cout.rdbuf();
        outbuf->sputc(ch);
    }
    inline void putstr(string s){
        for(register int i=0;i<s.length();i++) putc(s[i]);
    }
    template<typename T>inline void put(const char ch,T x){
        static std::streambuf *outbuf=cout.rdbuf();
        static char s[21];
        static int top = 0;
        if(x<0){
            outbuf->sputc('-');
            x=-x;
        }
        if(!x){
            outbuf->sputc('0');
            outbuf->sputc(ch);
            return;
        }
        while(x){
            s[++top]=x%10+'0';
            x/=10;
        }
        while(top){
            outbuf->sputc(s[top]);
            --top;
        }
        outbuf->sputc(ch);
    }
    template<typename T,typename ...Args> inline void put(T a,Args ...args){
        put(a);
		put(args...);
    }
    template<typename T,typename ...Args> inline void put(const char ch,T a,Args ...args){
        put(ch,a);
		put(ch,args...);
    }
}
using namespace IN;
using namespace OUT;
struct St{
	int x,y;
}root;
struct Node{
	St H[M]; // 上下左右四个点的位置 
	int data[M]; // 上下左右四个点的值与该点的值的差 
	int sum[M]; // 上下左右四个点的旋转次数与该点的旋转次数的差 
	int k; // 记录当前点旋转次数 
	ll x; // 记录当前点的值 
}a[N][N];
int n,q,op;
int sum=0,t=mul,v;
int ans[N][N];
int cnt[N];
St A[8][N];
int dx[]={-1,0,1,0},dy[]={0,-1,0,1};
inline void init(){
	for(register int i=0;i<8;i++)
	  cnt[i]=0;
} 
inline int check(register int x){
	return x<0?x+4:x;
}
inline St Down(St x){ // 往下走 
	St ans;
	register int t=check(2-a[x.x][x.y].k);
	ans=a[x.x][x.y].H[t&3];
	a[ans.x][ans.y].x=(a[x.x][x.y].x+a[x.x][x.y].data[t&3])%mod;
	a[ans.x][ans.y].k=(a[x.x][x.y].k+a[x.x][x.y].sum[t&3])&3;
	return ans;
}
inline St Right(St x){ // 往右走 
	St ans;
	register int t=check(3-a[x.x][x.y].k);
//	cout<<t<<'\n';
	ans=a[x.x][x.y].H[t&3];
	a[ans.x][ans.y].x=a[x.x][x.y].x+a[x.x][x.y].data[t&3];
	a[ans.x][ans.y].k=(a[x.x][x.y].k+a[x.x][x.y].sum[t&3])&3;
	return ans;	
}
inline void getn(register int x,register int l,register int r,register int h){ // 提取 x 行 [l,r] 的值 
	St root={0,0};
	for(register int i=1;i<=x;i++)
	  root=Down(root);	
	for(register int i=1;i<l;i++)
	  root=Right(root);	
	for(register int i=l;i<=r;i++){
		root=Right(root);
		A[h][cnt[h]++]=root;
	}
}
inline void getm(register int x,register int l,register int r,register int h){ // 提取 x 列 [l,r] 的值 
	St root={0,0};
	for(register int i=1;i<=x;i++)
	  root=Right(root);
	for(register int i=1;i<l;i++)
	  root=Down(root);
	for(register int i=l;i<=r;i++){
		root=Down(root);
		A[h][cnt[h]++]=root;
	}
}
inline void get(register int x1,register int y1,register int x2,register int y2){
	getn(x1-1,y1,y2,0);
	for(int i=0;i<cnt[0];i++)
	  A[1][cnt[1]++]=Down(A[0][i]);
	getn(x2,y1,y2,3);
	for(int i=0;i<cnt[3];i++)
	  A[2][cnt[2]++]=Down(A[3][i]);	
	getm(y1-1,x1,x2,4);
	for(int i=0;i<cnt[4];i++)
	  A[5][cnt[5]++]=Right(A[4][i]);
	getm(y2,x1,x2,7);
	for(int i=0;i<cnt[7];i++)
	  A[6][cnt[6]++]=Right(A[7][i]);
//	for(register int i=0;i<8;i++){
//		for(register int j=0;j<(int)cnt[i];j++){
//			printf("[%lld,%lld,%lld]",A[i][j].x,A[i][j].y,a[A[i][j].x][A[i][j].y].k);
//			if(j!=cnt[i]-1)
//			  putchar(',');
//		}
//		putchar('\n');
//	}
}
inline void rotate(register int x1,register int y1,register int x2,register int y2){ // 旋转 
	init();
	get(x1,y1,x2,y2);
	for(register int i=0;i<cnt[0];i++){
		register int X1=A[0][i].x,Y1=A[0][i].y;
		register int X2=A[7][i].x,Y2=A[7][i].y;
		a[X2][Y2].k++;
		a[X1][Y1].sum[check(2-a[X1][Y1].k)]=check(a[X2][Y2].k-a[X1][Y1].k);
		a[X2][Y2].sum[check(-a[X2][Y2].k)]=check(a[X1][Y1].k-a[X2][Y2].k);
//		cout<<a[X1][Y1].k<<' '<<a[X2][Y2].k<<'\n';
		a[X1][Y1].data[check(2-a[X1][Y1].k)]=(a[X2][Y2].x-a[X1][Y1].x+mod)%mod;
		a[X1][Y1].H[check(2-a[X1][Y1].k)]={X2,Y2};
		a[X2][Y2].data[check(-a[X2][Y2].k)]=(a[X1][Y1].x-a[X2][Y2].x+mod)%mod;
		a[X2][Y2].H[check(-a[X2][Y2].k)]={X1,Y1};
		a[X2][Y2].k--;
	}
	for(register int i=0;i<cnt[2];i++){
		register int X1=A[2][i].x,Y1=A[2][i].y;
		register int X2=A[5][i].x,Y2=A[5][i].y;
		a[X2][Y2].k++;
		a[X2][Y2].k&=3;
		a[X1][Y1].sum[check(-a[X1][Y1].k)]=check(a[X2][Y2].k-a[X1][Y1].k);
		a[X2][Y2].sum[check(2-a[X2][Y2].k)]=check(a[X1][Y1].k-a[X2][Y2].k);
//		cout<<a[X2][Y2].k<<' '<<a[X2][Y2].k<<'\n';
		a[X1][Y1].data[check(-a[X1][Y1].k)]=(a[X2][Y2].x-a[X1][Y1].x+mod)%mod;
		a[X1][Y1].H[check(-a[X1][Y1].k)]={X2,Y2};
		a[X2][Y2].data[check(2-a[X2][Y2].k)]=(a[X1][Y1].x-a[X2][Y2].x+mod)%mod;
		a[X2][Y2].H[check(2-a[X2][Y2].k)]={X1,Y1};
		a[X2][Y2].k--;
	}
	for(register int i=0;i<cnt[4];i++){
		register int X1=A[4][i].x,Y1=A[4][i].y;
		register int X2=A[1][cnt[4]-i-1].x,Y2=A[1][cnt[4]-i-1].y;
		a[X2][Y2].k++;
		a[X2][Y2].k&=3;
		a[X1][Y1].sum[check(3-a[X1][Y1].k)]=check(a[X2][Y2].k-a[X1][Y1].k);
		a[X2][Y2].sum[check(1-a[X2][Y2].k)]=check(a[X1][Y1].k-a[X2][Y2].k);
//		cout<<a[X1][Y1].k<<' '<<a[X2][Y2].k<<'\n';
		a[X1][Y1].data[check(3-a[X1][Y1].k)]=(a[X2][Y2].x-a[X1][Y1].x+mod)%mod;
		a[X1][Y1].H[check(3-a[X1][Y1].k)]={X2,Y2};
		a[X2][Y2].data[check(1-a[X2][Y2].k)]=(a[X1][Y1].x-a[X2][Y2].x+mod)%mod;
		a[X2][Y2].H[check(1-a[X2][Y2].k)]={X1,Y1};	
//		a[X2][Y2].k--;
	}
	for(register int i=0;i<cnt[6];i++){
		register int X1=A[6][i].x,Y1=A[6][i].y;
		register int X2=A[3][cnt[3]-i-1].x,Y2=A[3][cnt[3]-i-1].y;
		a[X2][Y2].k++;
		a[X2][Y2].k&=3;
		a[X1][Y1].sum[check(1-a[X1][Y1].k)]=check(a[X2][Y2].k-a[X1][Y1].k);
		a[X2][Y2].sum[check(3-a[X2][Y2].k)]=check(a[X1][Y1].k-a[X2][Y2].k);
//		cout<<a[X1][Y1].k<<' '<<a[X2][Y2].k<<'\n';
		a[X1][Y1].data[check(1-a[X1][Y1].k)]=(a[X2][Y2].x-a[X1][Y1].x+mod)%mod;
		a[X1][Y1].H[check(1-a[X1][Y1].k)]={X2,Y2};
		a[X2][Y2].data[check(3-a[X2][Y2].k)]=(a[X1][Y1].x-a[X2][Y2].x+mod)%mod;
		a[X2][Y2].H[check(3-a[X2][Y2].k)]={X1,Y1};	
		a[X2][Y2].k--;		
	}	
}
inline void add(register int x1,register int y1,register int x2,register int y2,register int t){ // 加法 
	St v;
	init();
	get(x1,y1,x2,y2);
	for(int i=0;i<cnt[0];i++){
		v=A[0][i];
		a[v.x][v.y].data[check(2-a[v.x][v.y].k)]=(a[v.x][v.y].data[check(2-a[v.x][v.y].k)]+t)%mod;
	}
	for(int i=0;i<cnt[1];i++){
		v=A[1][i];
	    a[v.x][v.y].data[check(-a[v.x][v.y].k)]=(a[v.x][v.y].data[check(-a[v.x][v.y].k)]-t+mod)%mod;
	}
	for(int i=0;i<cnt[2];i++){
		v=A[2][i];
	    a[v.x][v.y].data[check(-a[v.x][v.y].k)]=(a[v.x][v.y].data[check(-a[v.x][v.y].k)]+t)%mod;
	}
	for(int i=0;i<cnt[3];i++){
		v=A[3][i];
	    a[v.x][v.y].data[check(2-a[v.x][v.y].k)]=(a[v.x][v.y].data[check(2-a[v.x][v.y].k)]-t+mod)%mod;	
	}
	for(int i=0;i<cnt[4];i++){
		v=A[4][i];
	    a[v.x][v.y].data[check(3-a[v.x][v.y].k)]=(a[v.x][v.y].data[check(3-a[v.x][v.y].k)]+t)%mod;
	}
	for(int i=0;i<cnt[5];i++){
		v=A[5][i];
	    a[v.x][v.y].data[check(1-a[v.x][v.y].k)]=(a[v.x][v.y].data[check(1-a[v.x][v.y].k)]-t+mod)%mod;	
	}
	for(int i=0;i<cnt[6];i++){
		v=A[6][i];
	    a[v.x][v.y].data[check(1-a[v.x][v.y].k)]=(a[v.x][v.y].data[check(1-a[v.x][v.y].k)]+t)%mod;
	}
	for(int i=0;i<cnt[7];i++){
		v=A[7][i];
	    a[v.x][v.y].data[check(3-a[v.x][v.y].k)]=(a[v.x][v.y].data[check(3-a[v.x][v.y].k)]-t+mod)%mod;
	}
}
inline void dfs(register int h,St x){
	St t;
	for(register int i=1;i<=n;i++){
		t=Right(x);
//		cout<<t.x<<' '<<t.y<<'\n';
		ans[h][i]=(1ll*ans[h][i-1]+a[x.x][x.y].data[check(3-a[x.x][x.y].k)]+mod)%mod;
		x=t;
	}
}
int main(){
	read(n),read(q);
    for(register int i=1;i<=n;i++){
        register int t=1;
        for(register int j=1;j<=n;j++){
        	t=1ll*t*(i+1)%P;
			a[i][j].x=t;
		}
    }
    for(register int i=0;i<=n+1;i++)
      a[i][0].x=a[0][i].x=a[n+1][i].x=a[0][n+1].x=0;
    for(register int i=0;i<=n+1;i++){
    	for(register int j=0;j<=n+1;j++){
    		for(register int k=0;k<4;k++){
    			register int zx=i+dx[k],zy=j+dy[k];
    			a[i][j].sum[k]=0;
    			if(zx<0||zx>(n+1)||zy<0||zy>(n+1)){
    				a[i][j].data[k]=0;
    				continue;
				}
    			a[i][j].H[k]={zx,zy};
    			a[i][j].data[k]=(a[zx][zy].x-a[i][j].x+mod)%mod;
			}
		}
	}
	while(q--){
		read(op);
		register int x1,y1,x2,y2;
		read(x1),read(y1),read(x2),read(y2);
		if(op==1){
			if(x1==x2&&y1==y2)
			  continue;
			rotate(x1,y1,x2,y2);
		}
		else{
			read(v);
			add(x1,y1,x2,y2,v);
		}
	}
	for(register int i=1;i<=n;i++)
	  dfs(i,{i,0});
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=n;j++){
			sum=(sum+(1ll*ans[i][j]*t)%mod)%mod;
			t=(1ll*t*mul)%mod;
//			cout<<ans[i][j]<<' ';
		}
//		cout<<'\n';
	}
	put(sum);
	return 0;
}
```


---


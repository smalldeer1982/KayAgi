# [省选联考 2024] 迷宫守卫

## 题目描述

Alice 拥有一座迷宫，这座迷宫可以抽象成一棵拥有 $2^n$ 个叶节点的满二叉树，总节点数目为 $(2^{n+1} - 1)$，依次编号为 $1 \sim (2^{n+1} - 1)$。其中编号为 $2^n \sim (2^{n+1} - 1)$ 的是叶节点，编号为 $1 \sim (2^n - 1)$ 的是非叶节点，且非叶节点 $1 \le u \le (2^n - 1)$ 的左儿子编号为 $2u$，右儿子编号为 $(2u + 1)$。

每个非叶节点都有一个石像守卫，初始时，所有石像守卫均在沉睡。唤醒 $u$ 点的石像守卫需要 $w_u$ 的魔力值。

每个叶节点都有一个符文，$v$ 点的符文记作 $q_v$。**保证 $q_{2^n}, q_{2^n+1},\cdots, q_{2^{n+1}-1}$ 构成 $1 \sim 2^n$ 的排列**。

探险者初始时持有空序列 $Q$，从节点 $1$ 出发，按照如下规则行动：

- 到达叶节点 $v$ 时，将 $v$ 点的符文 $q_v$ 添加到序列 $Q$ 的末尾，然后返回父节点。
- 到达非叶节点 $u$ 时：
  - 若该点的石像守卫已被唤醒，则只能先前往左儿子，（从左儿子返回后）再前往右儿子，（从右儿子返回后）最后返回父节点。
  - 若该点的石像守卫在沉睡，可以在以下二者中任选其一：
    - 先前往左儿子，再前往右儿子，最后返回父节点。
    - 先前往右儿子，再前往左儿子，最后返回父节点。

返回节点 $1$ 时，探险结束。可以证明，探险者一定访问每个叶节点各一次，故此时 $Q$ 的长度为 $2^n$。

探险者 Bob 准备进入迷宫，他希望探险结束时的 $Q$ 的字典序越小越好，与之相对，Alice 希望 $Q$ 的字典序越大越好。

在 Bob 出发之前，Alice 可以选择一些魔力值花费之和不超过 $K$ 的石像守卫，并唤醒它们。Bob 出发时，他能够知道 Alice 唤醒了哪些神像。若**双方都采取最优策略**，求序列 $Q$ 的最终取值。

对于两个长度为 $2^n$ 的序列 $Q_1,Q_2$，称 $Q_1$ 字典序小于 $Q_2$ 当且仅当以下条件成立：

- $\exist i \in [1, 2^n]$ 满足以下两个条件：
  - $\forall 1 \le j < i，Q_{1,j} = Q_{2,j}$；
  - $Q_{1,i} < Q_{2,i}$。

## 说明/提示

**【样例 1 解释】**

- 第一组数据中，Alice 无法唤醒石像守卫，Bob 可以选择先访问叶节点 $3$，再访问叶节点 $2$，得 $Q = \{1, 2\}$。
- 第二组数据中，Alice 可以唤醒节点 $1$ 的石像守卫，Bob 只能先访问叶节点 $2$，再访问叶节点 $3$，得 $Q = \{2, 1\}$。
- 第三组数据中，Alice 的最优策略是唤醒节点 $5, 6$ 的石像守卫。

**【样例 2】**

见附件中的 `maze2.in/ans`。

该组数据满足特殊性质 A。

**【样例 3】**

见附件中的 `maze3.in/ans`。

该组数据满足特殊性质 B。

**【样例 4】**

见附件中的 `maze4.in/ans`。

**【样例 5】**

见附件中的 `maze5.in/ans`。

**【子任务】**

设 $\sum 2^n$ 表示单个测试点钟所有测试数据的 $2^n$ 的和。对于所有测试数据，保证

- $1\le T \le 100$；
- $1\le n \le 16$，$1 \le \sum 2^n \le 10^5$；
- $0\le K \le 10^{12}$
- $\forall 1 \le u \le (2^n-1)$，$0 \le w_u \le 10^{12}$；
- $q_{2^n},q_{2^n+1},\cdots,q_{2^{n+1}-1}$ 构成 $1\sim 2^n$ 的排列。

| 测试点编号 | $n\le$ | $\sum 2^n \le$ | 特殊性质 |
| :--: | :--: | :--: | :--: |
| $1\sim 5$ | $4$ | $80$ | 无 |
| $6$ | $6$ | $200$ | A |
| $7\sim 8$ | $6$ | $200$ | B |
| $9\sim 10$ | $6$ | $200$ | 无 |
| $11$ | $11$ | $4000$ | A |
| $12\sim 13$ | $11$ | $4000$ | B |
| $14\sim 15$ | $11$ | $4000$ | 无 |
| $16$ | $16$ | $10^5$ | A |
| $17\sim 18$ | $16$ | $10^5$ | B |
| $19\sim 20$ | $16$ | $10^5$ | 无 |

特殊性质 A：$\forall 2^n \le v \le (2^{n+1}-1)$，$q_v = (2^{n+1}-v)$。

特殊性质 B：$\forall 1 \le u \le (2^n-1)$，$w_u = 1$。

## 样例 #1

### 输入

```
3
1 0
1
2 1
1 1
1
2 1
3 3
3 2 1 2 1 2 1
4 2 6 3 7 1 5 8```

### 输出

```
1 2
2 1
2 4 6 3 5 8 7 1```

# 题解

## 作者：C1942huangjiaxu (赞：55)

考虑 Bob 只选一个叶子时怎么做。 

那么 Alice 每选择一个点，就相当于把右子树删掉，最后要使剩下数中的最小值最大。

考虑 $DP$ 记 $f_{u,j}$ 表示使 $u$ 子树内最小值大于等于 $j$ 的最小代价。

转移有 $f_{u,j}=f_{ls_u,j}+\min(f_{rs_u,j},w_u)$。

直接记录状态是 $O(4^n)$，因为树是满二叉树，可以对 $j$ 这一维离散化，这样状态就是 $O(n 2^n)$ 的。

转移可以用归并排序做到 $O(n 2^n)$。

求出 $f$ 后，找到最大的 $j$ 使得 $f_{1,j}\le K$，这就是 Bob 选的叶子。

考虑如何利用 $f$ 求出所有答案，直接模拟 Bob 在树上行走。

设计函数 $\operatorname{dfs}(u,K)$ 表示 Bob 走到了 $u$ 节点，Alice 还有 $K$ 的魔力值，函数返回 Alice 在 $u$ 子树内花费的魔力值。

一样找到最大的 $j$ 使得 $f_{u,j}\le K$，则 Bob 下一个叶子会走向 $j$。

如果 $j$ 在右子树，说明 Alice 一定不会选 $u$，那么依次调用 $g=\operatorname{dfs}(rs_u,K-f_{ls_u,j})，\operatorname{dfs}(ls_u,K-g)$ 即可。

如果 $j$ 在左子树，先调用 $g=\operatorname{dfs}(ls_u,K-\min(w_u,f_{rs_u,j}))$。

**这时候我们要考虑 Alice 是否选择 $w_u$，请注意，并不是 $w_u\le f_{rs_u,j}$ 就会选择 $w_u$**。

因为我们选择了 $w_u$ 会使得 Alice 在右子树的选择更少，**只有在我们不选 $w_u$ 的情况下，左子树答案会改变**才会选。

具体的，只有 $g\gt K-f_{rs_u,j}$ 时，我们才会选 $w_u$。

判断出是否选 $w_u$ 后，剩下的过程和 $j$ 在右子树的情况类似。

时间复杂度 $O(n2^n)$。

参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=(1<<17)+5;
const ll inf=1e13;
int T,n,tn,a[N],rv[N],b[N],cb,c[18][N];
ll w[N],m,f[18][N],fl[18][N],fr[18][N];
bool vw[18][N];
#define ls(x) ((x)<<1)
#define rs(x) ((x)<<1|1)
void dfs(int x,int l,int r,int d){
	if(x>=tn){
		f[d][l]=0,c[d][l]=a[x];
		return;
	}
	int mid=l+r>>1;
	dfs(ls(x),l,mid,d+1),dfs(rs(x),mid+1,r,d+1);
	int i=l,j=mid+1,k=l;
	ll vl=0,vr=0;
	while(i<=mid&&j<=r){
		if(c[d+1][i]<c[d+1][j]){
			c[d][k]=c[d+1][i];
			vl=f[d+1][i];
			vr=f[d+1][j];
			++i;
		}else{
			c[d][k]=c[d+1][j];
			vr=f[d+1][j];
			vl=f[d+1][i];
			++j;
		}
		fl[d][k]=vl,fr[d][k]=vr;
		if(w[x]<vr)vw[d][k]=true;
		else vw[d][k]=false;
		f[d][k]=min(inf,fl[d][k]+min(w[x],fr[d][k]));
		++k;
	}
	while(i<=mid){
		c[d][k]=c[d+1][i];
		vl=f[d+1][i];
		vr=inf;
		++i;
		fl[d][k]=vl,fr[d][k]=vr;
		if(w[x]<vr)vw[d][k]=true;
		else vw[d][k]=false;
		f[d][k]=min(inf,fl[d][k]+min(w[x],fr[d][k]));
		++k;
	}
	while(j<=r){
		c[d][k]=c[d+1][j];
		vr=f[d+1][j];
		vl=inf;
		++j;
		fl[d][k]=vl,fr[d][k]=vr;
		if(w[x]<vr)vw[d][k]=true;
		else vw[d][k]=false;
		f[d][k]=min(inf,fl[d][k]+min(w[x],fr[d][k]));
		++k;
	}
}
ll calc(int x,int l,int r,ll rs,int d){
	if(l==r){
		b[++cb]=a[x];
		return 0;
	}
	int mid=l+r>>1;
	int j=r;
	while(j>l&&fl[d][j]+min(w[x],fr[d][j])>rs)--j;
	ll res=0;
	if(rv[c[d][j]]<=mid){
		res=calc(ls(x),l,mid,rs-min(w[x],fr[d][j]),d+1);
		if(vw[d][j]&&rs-fr[d][j]<res)res+=w[x];
		rs-=res;
		res+=calc(rs(x),mid+1,r,rs,d+1);
	}else{
		res=calc(rs(x),mid+1,r,rs-fl[d][j],d+1);
		rs-=res;
		res+=calc(ls(x),l,mid,rs,d+1);
	}
	return res;
}
void solve(){
	scanf("%d%lld",&n,&m);
	tn=1<<n,cb=0;
	for(int i=1;i<tn;++i)scanf("%lld",&w[i]);
	for(int i=0;i<tn;++i){
		scanf("%d",&a[i+tn]);
		rv[a[i+tn]]=i;
	}
	dfs(1,0,tn-1,0);
	calc(1,0,tn-1,m,0);
	for(int i=1;i<=tn;++i)printf("%d%c",b[i]," \n"[i==tn]);
}
int main(){
	scanf("%d",&T);
	while(T--)solve();
	return 0;
}
```

---

## 作者：20_200 (赞：29)

# 省选联考 2024 D2T1

### 前言

Day1 发挥不完全，Day2 完全不发挥。

Day2 场上写这题写了 4h 25min，并且最终也只写了个假做法，最后两分钟在 T2 输出了 `1` ，并获得了总分 5 分的好成绩。

赛后又瞪了两个小时终于做出来了这题，~~但是只能来写个题解了~~，只能说菜就多练。

这是本蒟蒻的第一篇洛谷题解，写此题解纪念这道葬送了我一整场省选 Day2 的题。

第一篇题解，表达能力不佳，请见谅。

### 题解

首先题目要访问序列的字典序最小，意思就是直接让你从前往后贪心。

下文中用选择一个点表示唤醒这个点的石像守卫。

所以 Bob 显然会先让第一个数最小，然后第二个，然后再是后面的。Alice 要做的是把 Bob 卡到最大。

先考虑第一个数怎么选。

首先发现答案具有单调性，所以可以二分第一个数是 $x$，然后 Alice 要做的就是使所有的 $<x$ 的数全部不能让 Bob 第一次作为叶子访问到。

那么 Alice 能做到的充要条件是能够使对于每一个 $y<x$ 的叶子，其到根的路径上的所有点中需至少选择一个使得 $y$ 是这个点的右子树中的点。

可以使用一次树形 dp 在 $O(siz)$ 的复杂度内求出每一次二分的最小代价。

因为优先使第一个最大，所以我们二分出代价 $\le m$ 的最大可能取到的值，设此时的最终结果的叶子为 $p$。

然后题目要求 Bob 是以 dfs 的方式访问整个树，所以下一步肯定是访问 $p$ 的兄弟节点（即 $p$ 的父节点的另一个子节点）的子树，然后是 $p$ 的父节点的兄弟节点，以此类推。

因为是二分，所以 $p$ 到当前子树的根的路径上一定可以走。

还是因为在前面的优先，所以当访问 $p$ 的兄弟节点时，$p$ 的祖先的兄弟节点子树内部的选择方案先按照当前子树决策，使得代价最小。

而 $p$ 的兄弟节点内部因为会有其他的节点选择，所以当前子树的决策方案不一定是最优的，需要整个重做。所以先把 $m$ 减去当前子树需要的代价，然后再加上 $p$ 的兄弟按照当前子树方案所需的代价，进入 $p$ 兄弟的子问题。

对于 $p$ 兄弟的子问题，需要分 $p$ 的父节点选不选，选的话就需要加上其代价，不选的话还需要求兄弟节点子树内第一个访问的叶子上的数要大于 $p$ 上的数，只需直接把 $p$ 的数和二分的数取 max 即可，树形 dp 会自动判掉非法情况。

（好好理解一下这里，赛场上就是没想明白这里然后就寄了，做这种题一定要彻底想明白再开始写）。

然后把 $p$ 变成 $p$ 的父节点，继续执行上述子问题（加上 $p$ 的兄弟按照当前子树方案所需的代价，进入 $p$ 兄弟的子问题）直到 $p$ 变为当前子树的根。

到这里这题就做完了，下面是时间复杂度的证明。

设 $T(n)$ 为高度为 $n$ 的子树所需要的时间，显然子树内的操作（除去子问题递归外）需要的时间为 $O(siz\log siz)=O(2^nn)$ ，则 

$$T(n)=O(2^nn)+\sum_{i=0}^{n-1}T(i)$$

设 $S(n)=\sum_{i=0}^nT(i)$，则 

$$S(n)-S(n-1)=O(2^nn)+S(n-1)$$

$$S(n)=2S(n-1)+O(2^nn)=\sum_{k=0}^nO(2^kk)\times 2^{n-k}=O(2^nn^2)$$

$$T(n)=S(n)-S(n-1)=O(2^nn^2)$$

证毕。

时间复杂度 $O(2^nn^2)$ 。

~~500ms不知道在卡什么~~

### 代码

非常好写，但是真的难想。

```c++
#include<bits/stdc++.h>
#define ll long long
#define ld long double
#define pb push_back
#define pii pair<ll,ll>
#define fi first
#define se second
using namespace std;
const ll N=2e5+2,P=1e12+1;
ll T,n,m,k,a[N],b[N];
pii c[N];
ll dfs(ll x,ll h){
	if(x>=(1<<n))return(a[x]<h?P:0);
	ll p=dfs(x<<1,h),q=dfs(x<<1|1,h);
	return p+min(a[x],q);
}
void Dfs(ll x,ll h){
	if(x>=(1<<n)){
		if(a[x]<h)m-=a[x>>1];
		return b[++k]=a[x],void();
	}
	ll l=x,r=x,f=0;
	while(l<(1<<n))l<<=1;
	while(r<(1<<n))r=(r<<1|1);
	for(ll i=l;i<=r;i++)c[++f]={a[i],i};
	sort(c+1,c+f+1),l=1,r=f;
	ll p=0,s=0;
	while(l<=r){
		ll mid=l+r>>1;
		ll v=dfs(x,max(c[mid].fi,h));
		if(x&(x>1&&c[mid].fi<h))
			v=min(v,dfs(x,c[mid].fi)+a[x>>1]);
		if(v>m)r=mid-1;
		else l=mid+1,p=c[mid].se,s=v;
	}
	m-=s,b[++k]=h=a[p];
	do
		m+=min(p&1?P:a[p>>1],dfs(p^1,h)),
		Dfs(p^1,h),p>>=1;
	while(p!=x);
}
void slv(){
	cin>>n>>m,k=0;
	for(ll i=1;i<(1<<n+1);i++)cin>>a[i];
	Dfs(1,0);
	for(ll i=1;i<=k;i++)cout<<b[i]<<' ';
	cout<<'\n';
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>T;
	while(T--)slv();
	return 0;
}
```

---

## 作者：EnofTaiPeople (赞：26)

我称呼这是一道绝世好签到题，看本文标题就知道，简单、二分、贪心、递归，签到属性拉满！

题意要求满二叉树上最大化最小叶子点权字典序，可以使用 $w_x$ 个“贝”强制某个非叶子节点往左走。

这里的叶子节点点权是一个排列，不然可能会变得复杂一些。

考虑先求出第一个节点的点权，可以二分点权 $\ge mid$，设 $dp(x)$ 表示走到节点 $x$ 后，使得第一个叶子点权 $\ge mid$ 的最少要用多少个“贝”。

显然 $dp(x)=dp(2x)+\min\{w_x,dp(2x+1)\}$，边界叶子节点 $dp_x=[q_x<mid]\times\inf$。

于是我们得知了第一个要走的数是什么，于是可以得出刚开始会往那一棵子树走。

如果是往左子树走，这是我们需要 $\min\{w_x,dp(2x+1)\}$ 的代价来强制往左走或者使得右儿子优于左儿子，否则需要 $dp(2x)$ 的代价来使得左儿子优于右儿子（对方会走更劣的一边），我们称此为**强制花费**。

当然这里的贪心策略就是根据字典序的性质，我们应当在不浪费的前提下尽量早地花钱。

定义 `pair<ll,vector<int> >sol(int x,ll up)` 表示走到节点 $x$，可用 $up$ 个“贝”，返回最优策略下的花费和答案。

然后就可以递归求解了，每次先二分得出先前往的子树，它可以使用的 $up$ 为当前的 $up$ 减去**强制花费**，然后递归另一边子树。

当然对于 $w_x$ 是否使用，如果递归完左子树时剩余费用达到了 $dp(2x+1)$，就不需要使用 $w_x$ 了，因为右儿子存在优于左儿子的策略，否则就是唯一使用 $w_x$ 的场景。

需要排序得出每个子树内存在的需要二分的值，虽然可以归并，但是我全部都使用了暴力 `sort`，因为实在是太快了！

时间复杂度 $O(n^22^n)$，但是跑得很快：
```cpp
#include<bits/stdc++.h>
// bool stc;
#define all(x) x.begin(),x.end()
#define cln cerr<<"Line:   "<<__LINE__<<"   "
using namespace std;
const int N=(1<<20)+100;
using ll=long long;
int T,n,m,a[N],b[N];
ll K,w[N],f[N],mst;
using vt=vector<int>;
using D1=pair<ll,vt>;
#define ls x<<1
#define rs x<<1|1
vt h[N];
vt mg(vt a,vt b){
    for(auto &p:b)a.push_back(p);
    return a;
}
void dp(int x){
    if(x>>n)f[x]=a[x]<mst?K+1:0;
    else{
        dp(ls),dp(rs);
        f[x]=f[ls]+min(f[rs],w[x]);
    }
}
int fd(vt &a,int v){
    auto it=lower_bound(all(a),v);
    return (it!=a.end())&&(*it==v);
}
D1 sol(int x,ll up){
    if(x>>n)return D1(0,{a[x]});
    int l=1,r=h[x].size()-1,md,k=0;
    while(l<=r){
        md=l+r>>1;
        mst=h[x][md],dp(x);
        if(f[x]<=up)k=md,l=md+1;
        else r=md-1;
    }mst=h[x][k],dp(x);
    // printf("x:%d k:%d up:%lld f:%lld\n",x,k,up,f[x]);
    // for(int p:h[x])printf("%d ",p);puts("");
    if(fd(h[ls],h[x][k])){
        auto at=sol(ls,up-min(w[x],f[rs]));
        up-=at.first;
        if(up>=f[rs]){
            auto bt=sol(rs,up);
            return D1(at.first+bt.first,mg(at.second,bt.second));
        }else{
            up-=w[x];
            auto bt=sol(rs,up);
            return D1(at.first+bt.first+w[x],mg(at.second,bt.second));
        }
    }else{//printf("x:%d\n",x);
        auto at=sol(rs,up-f[ls]);
        up-=at.first;auto bt=sol(ls,up);
        return D1(at.first+bt.first,mg(at.second,bt.second));
    }
}
// bool edc;
int main(){
    // double meg=fabs(&edc-&stc)/1048576,lim=300;
    // cerr<<meg<<endl,assert(meg<lim);
    ios::sync_with_stdio(false),cin.tie(0);
    freopen("maze.in","r",stdin);
    freopen("maze.out","w",stdout);
    int i,j,k,l,r,x,y,z;
    for(cin>>T;T--;){
        cin>>n>>K;
        for(x=1;x<(1<<n);++x)cin>>w[x];
        for(x=(1<<n);x<(1<<n+1);++x){
            cin>>a[x];
            for(k=x;k;k>>=1)h[k].push_back(a[x]);
        }
        for(x=1;x<(1<<n);++x)sort(all(h[x]));
        auto ans=sol(1,K).second;
        for(int p:ans)printf("%d ",p);putchar('\n');
        for(x=1;x<(1<<n+1);++x)h[x].clear();
    }
    return 0;
}
```

---

## 作者：云浅知处 (赞：16)

先考虑确定 $Q_1$：二分答案 $mid$ 然后做一遍 $O(N)$ 的 DP 即可。这里 $N=2^n$。

具体来说 DP 就是设 $f(u)$ 表示 $u$ 让子树内决策 $>mid$ 的最小代价，那么有
$$
f(u)=\begin{cases}f(ls)&,mn(rs)>mid\\
f(ls)+\min(f(rs),w_u)&,mn(rs)<mid\end{cases}
$$
其中 $mn(u)$ 表示 $u$ 子树内的最小叶子，$ls,rs$ 分别表示 $u$ 的左右儿子。

考虑在确定 $Q_1$ 之后，找到从根到 $Q_1$ 的链，依次剥出路径边上的 $O(\log N)$ 个子树，那么可以直接确定 $Q_2,\{Q_3,Q_4\},\{Q_5,Q_6,Q_7,Q_8\},\cdots$ 等等。这里集合表示内部的顺序尚未确定，但集合之间的顺序是确定的。

我们现在扔掉取到 $Q_1$ 时做的若干决策，来考虑最小化 $Q_2,\{Q_3,Q_4\},\{Q_5,Q_6,Q_7,Q_8\},\cdots$ 自己的字典序。发现这些部分之间几乎是独立的。依次考虑每个部分，我们来列一下优先级：

- 首先，$Q_1$ 需要能取到这个值，因此后面的部分需要预留够足够的 $K$ 使得它们能够修改一些决策，让子树内能走到的 min 能够 $>Q_1$。
- 接下来，这个部分前面的部分由于位置更靠前，优先级理应更高。

设 $\text{solve}(u,K)$ 为：算出 $u$ 子树内用不超过 $K$ 的代价能达到的最优解，以及达到这个最优解所需的最小代价。

我们维护当前剩下的魔力值 $K$，每次减掉前面用过的和为后面预留的，得到这个子树实际能用的魔力值 $K'$，递归进当前子树调用 $\text{solve}(v,K')$ 然后拼接上来即可。有一种情况是，有可能子树内用 $K'$ 的代价无法让这个子树的最优决策 $>Q_1$（也就是说我们在之前 DP 的时候，这里做的决策是直接花费 $w$ 而非 $f(rs)$），我们需要再调用一遍 $\text{solve}(v,K'-w_{fa(v)})$，然后同理拼接上来。

~~哎，我场上觉得这个东西简直太没道理了，但是打开 typora 一写又感觉贼对。wuwu~~

总复杂度大约 $O(N\log^2N)$。

```cpp
#include<bits/stdc++.h>

#define ll long long
#define fi first
#define se second
#define mk make_pair

using namespace std;

ll read(){
	ll x=0,f=1;char c=getchar();
	for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())x=x*10+c-'0';
	return f==1?x:-x;
}

mt19937 rnd(time(0));
int randint(int l,int r){return rnd()%(r-l+1)+l;}

template<typename T>void cmax(T &x,T v){x=max(x,v);}
template<typename T>void cmin(T &x,T v){x=min(x,v);}

#define ls(u) (u<<1)
#define rs(u) (u<<1|1)

const ll INF=1e12+1;
const int N=2e5+5;
ll f[N],w[N];
int q[N],n,m,mn[N],pos[N];
vector<int>vals[N];

void clr(){
	for(int i=1;i<=m;i++)q[i]=mn[i]=pos[i]=w[i]=f[i]=0,vals[i].clear();
}

int lim;
void DP(int u){
	if(u>=n)return f[u]=(q[u]<lim?INF:0ll),void();
	DP(ls(u)),DP(rs(u));
	f[u]=f[ls(u)];
	if(mn[rs(u)]<lim)f[u]+=min(w[u],f[rs(u)]);
}

pair<ll,vector<int> >solve(int u,ll K){
	ll tK=K;
	vector<int>ans;
	int L=0,R=vals[u].size()-1,res=0;
	while(L<=R){
		int mid=(L+R)>>1;
		lim=vals[u][mid],DP(u);
		if(f[u]<=K)res=mid,L=mid+1;
		else R=mid-1;
	}
	res=vals[u][res],lim=res,DP(u);
	ans.emplace_back(res);
	int v=pos[res];
	while(v!=u){
		if(v%2==0)K-=min(w[v>>1],f[v^1]);
		else K-=f[v^1];
		v>>=1;
	}
	v=pos[res];
	while(v!=u){
		if(v%2==0)K+=min(w[v>>1],f[v^1]);
		else K+=f[v^1];
		auto R=solve(v^1,K);
		if(R.se[0]<res){
			assert(v%2==0); 
			R=solve(v^1,K-w[v>>1]);
			K-=w[v>>1];
		}
		K-=R.fi,v>>=1;
		for(auto x:R.se)ans.emplace_back(x);	
	}
	return mk(tK-K,ans);
}

void solve(){
	n=read();ll K=read();n=(1<<n),m=2*n-1;

	for(int i=1;i<=n-1;i++)w[i]=read();
	for(int i=n;i<=m;i++)pos[q[i]=read()]=i;

	for(int i=n;i<=m;i++)mn[i]=q[i];
	for(int i=n-1;i>=1;i--)mn[i]=min(mn[ls(i)],mn[rs(i)]);

	for(int i=n;i<=m;i++)vals[i].emplace_back(q[i]);
	for(int i=n-1;i>=1;i--){
		vals[i]=vals[ls(i)];
		for(int x:vals[rs(i)])vals[i].emplace_back(x);
		sort(vals[i].begin(),vals[i].end());
	}

	auto [used,ans]=solve(1,K);
	for(int i=1;i<=n;i++)cout<<ans[i-1]<<" \n"[i==n];
	
	clr();
}

signed main(){

//	freopen("maze.in","r",stdin);
//	freopen("maze.out","w",stdout);

	int tt=read();while(tt--)solve();

	return 0;
}
```

---

## 作者：World_Creater (赞：9)

非常好脑电波题，这使我的大脑旋转。

注意到题目本身是一个类背包形式，考虑直接 dp，设 $f_{i,j}$ 为只考虑第 $i$ 个子树内的 dfs 序，在消耗代价不超过 $j$ 的情况下最优的答案。

这个 dp 从各个意义上都很“大”，状态大而且存的信息大。

首先，我们发现，这个 dp 的在转移时需要比较左子树和右子树的 dfs 序字典序大小，而这两个子树内是不存在相同的字母的。这就说明只需要比较两个子树 dfs 序的第一位就能进行转移！因此我们每个状态压缩掉后面的信息，只保留第一位。

进一步发现这个 dp 答案维很小，而容量维很大，考虑交换两维。现在的状态就是 $f_{i,j}$ 表示 $i$ 子树内，排列第一位为 $j$ 时的最小花费（实际上这里改写为排列第一位不小于 $j$ 转移会更好写）。

由于一个子树内，第二维的取值只有 $\mathcal{O}(\text{size})$ 种，而题目中给出的树为完全二叉树，因此总的 dp 数组大小之和为 $\mathcal{O}(2^nn)$ 级别。

转移时，将两个子树的答案用归并排序的方法合并就可以做到 $\mathcal{O}(\text{size})$ 种，因此整个 dp 的总复杂度就是 $\mathcal{O}(2^nn)$ 的。

由于我们前面压缩了信息，现在我们得考虑如何输出方案。

考虑假设最优排列的第一位来自右子树，那么我们需要先将一笔钱暂时放在左子树上，这些钱用于将左子树的答案变的很劣，来起到强制钦定先走右子树的结果。从右子树走出来走到左子树时，再把这笔钱拿回来。

再考虑最优排列第一位来自左子树，这里我们除了存一笔钱在右子树上，还可以直接激活根节点。

不过这两点是有区别的，激活根节点这个钱就消失了，而放在右子树上的钱是可以在后续拿回来的。

我们设激活根节点的代价是 $x$，如果存右子树需要的钱是 $y$。

+ 如果 $x>y$，则显然直接将钱放在右子树上最优。
+ 如果 $x<y$，如果将钱放在右子树上会使后续更优，但可能导致走左子树的时候钱不够了导致答案变劣。此时我们可以假装先激活根节点走左子树，然后算出走完左子树后还剩多少，我们可以根据这个剩的钱来判断如果一开始将钱放在右子树上左子树能不能取到最优答案，如果能，我们就撤销激活根节点，转为将钱放在右子树上。否则激活根节点。

输出方案显然也只用最多 $\mathcal{O}(2^nn)$。

总时空复杂度均为 $\mathcal{O}(2^nn)$。

下为考场代码，其实挺好写，但是由于码风原因较于冗长。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int inf=2e12;
int t,n,m,a[200005],p[200005];
vector<pair<int,int> > f[200005];
void dfs(int x)
{
	f[x].clear();
	if(x>=(1<<n))
	{
		f[x].emplace_back(p[x-(1<<n)],0);
		return ;
	}
	int lc=x<<1,rc=x<<1|1;
	dfs(x<<1);
	dfs(x<<1|1);
	int i=0,j=0;
	while(i<f[lc].size()&&j<f[rc].size())
	{
		if(f[lc][i].first<f[rc][j].first)
		{
			f[x].emplace_back(f[lc][i].first,f[lc][i].second+min(a[x],f[rc][j].second));
			i++;
		}
		else
		{
			f[x].emplace_back(f[rc][j].first,f[rc][j].second+f[lc][i].second);
			j++;
		}
	}
	while(i<f[lc].size()) f[x].emplace_back(f[lc][i].first,f[lc][i].second+a[x]),i++;
	while(j<f[rc].size()) f[x].emplace_back(f[rc][j].first,inf),j++;
	for(int i=(int)f[x].size()-2;i>=0;i--)
	{
		f[x][i].second=min(f[x][i].second,f[x][i+1].second);
	}
}
int ddfs(int x,int y)
{
	// cerr<<x<<" "<<y<<"\n";
	if(x>=(1<<n))
	{
		cout<<p[x-(1<<n)]<<" ";
		return y;
	}
	int lc=x<<1,rc=x<<1|1;
	assert(f[x][0].second==0);
	for(int i=(int)f[x].size()-1;i>=0;i--)
	{
		if(f[x][i].second<=y)
		{
			// cerr<<"???"<<f[x][i].first<<" "<<f[x][i].second<<"\n";
			int fl=0,fr=0;
			while(fl<f[lc].size()&&f[lc][fl].first<f[x][i].first) fl++;
			while(fr<f[rc].size()&&f[rc][fr].first<f[x][i].first) fr++;
			// cerr<<"000\n";
			if(fl<f[lc].size()&&f[lc][fl].first==f[x][i].first)
			{
				// cerr<<"111\n";
				int z=a[x];
				if(fr!=f[rc].size())
				{
					if(f[rc][fr].second<z)
					{
						int rst=ddfs(lc,y-f[rc][fr].second);
						return ddfs(rc,f[rc][fr].second+rst);
					}
					else
					{
						int rst=ddfs(lc,y-z);
						if(rst>=f[rc][fr].second-z) return ddfs(rc,rst+z);
						else return ddfs(rc,rst);
					}
				}
				else
				{
					int rst=ddfs(lc,y-z);
					return ddfs(rc,rst);
				}
			}
			else
			{
				assert(fl!=f[lc].size());
				assert(fr!=f[rc].size());
				assert(f[rc][fr].first==f[x][i].first);
				// cerr<<"222"<<" "<<f[rc][fr].first<<"\n";
				int z=f[lc][fl].second;
				int rst=ddfs(rc,y-z);
				return ddfs(lc,rst+z);
			}
		}
	}
}
signed main()
{
	freopen("maze.in","r",stdin);
	freopen("maze.out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>t;
	while(t--)
	{
		cin>>n>>m;
		for(int i=1;i<(1<<n);i++)
		{
			cin>>a[i];
		}
		for(int i=0;i<(1<<n);i++)
		{
			cin>>p[i];
		}
		dfs(1);
		ddfs(1,m);
		cout<<"\n";
	}
}
```

---

## 作者：Liuxizai (赞：9)

[My Blog](https://liuxizai.ac.cn/archives/solution-lg10220.html)

## Description

给一棵 $n+1$ 层的完全二叉树（共 $2^{n+1}-1$ 个结点，$2^n$ 个叶子），结点从上到下，从左到右编号为 $1\sim 2^{n+1}-1$，每个非叶结点有一个激活代价 $w_i$，每个叶子有一个权值 $q_i$，所有 $q_i$ 构成 $1\sim 2^n$ 的排列。Alice 和 Bob 在这棵树上玩游戏，Alice 可以用不超过 $K$ 的代价激活一些结点，随后 Bob 会对这棵树进行 dfs。对于 Alice 激活的结点，Bob 必须先走左儿子再走右儿子；其余时候，Bob 可以任意决定 dfs 顺序。

按照 Bob 访问叶子的顺序将所有 $q_i$ 排成序列 $Q$，Alice 希望 $Q$ 的字典序最大，Bob 希望 $Q$ 的字典序最小，问最终的 $Q$ 是什么。

$T$ 组数据。

$1\le T\le 100,1\le n\le 16,1\le \sum 2^n\le 10^5,0\le K\le10^{12},0\le w_i\le 10^{12}$

## Solution

令 $N\gets 2^n$。

Alice 想让 $Q$ 的字典序最大，所以首先会希望最大化 $Q$ 中的第一个数。考场上我认为直接 dp 求解第一个数最大能是多少比较困难，虽然事实是这样做也可以，但是我们还是来考虑二分。

这样我们得到了一个判定性问题，只需判断 $Q$ 的第一个数能否 $\ge mid$ 即可。为了达成这一点，Alice 需要封锁所有 $< mid$ 的位置。考虑 dp 解决这一问题，设 $f_u$ 表示封锁 $u$ 子树内所有 $< mid$ 的位置的最小代价。转移时，首先可以分别封锁 $u$ 的左右儿子，$f_u\gets f_{ls}+f_{rs}$；其次可以激活 $u$，使得 Bob 第一次到达 $u$ 时不能走向右儿子，仅封锁左儿子即可，$f_u\gets f_{ls}+w_u$。初始状态为，所有 $\ge mid$ 的叶子为 $0$，$< mid$ 的叶子为 $\infty$。

求出 $Q$ 第一个数的最大值 $x$ 后，我们定位出根到 $x$ 的路径，这将是 Bob 第一次到达叶子的路径，这条路径将整棵树分成了 $O(\log N)$ 棵子树，Bob 将会按照从深到浅的顺序访问这些子树，这样就递归出了 $O(\log N)$ 个规模更小的子问题。

这里注意，在得到这些子问题的可用代价时，设令 $Q$ 第一个数为 $x$ 的最小代价为 $K_0$，我们并不能简单的从 $K$ 中减去 $K_0$。

考虑 $x\rightsquigarrow root$ 上除 $x$ 外的某个点 $u$，设 $x$ 在 $u$ 的左子树中。若 $f_u$ 是从 $f_{ls}+f_{rs}$ 转移而来，那么在递归 $u$ 右子树时，$f_{rs}$ 作为封锁右子树的代价需要被交还到 $K$ 中；若 $f_u$ 从 $f_{ls}+w_u$ 转移而来，这种决策在我们希望最大化右子树字典序时实际上不优，我们考虑剩余的 $K$ 是否允许 $f_u$ 从 $f_{ls}+f_{rs}$ 转移，换言之是在判断右子树访问到的第一个叶子能否 $>x$，若可行，则将 $w_u$ 交还给 $K$，注意若 $x$ 在 $u$ 右子树中时不存在这种情况。

容易说明总复杂度为 $O(N\log N)$，或 $O(n2^n)$。

代码十分简洁。

## Code

```cpp
namespace Main{
    const int N = 200005;
    int t, n, q[N]; ll k, w[N], f[N];
    inline bool is_leaf(int u) { return u >= (1 << n); }
    void dfs(int u, const int &mid){
        if(is_leaf(u)){
            if(q[u] < mid) f[u] = 1e18;
            else f[u] = 0;
            return;
        }
        dfs(u << 1, mid), dfs(u << 1 | 1, mid);
        f[u] = min(f[u << 1] + f[u << 1 | 1], f[u << 1] + w[u]);
    }
    vector<int> solve(int u){
        if(is_leaf(u)) return {q[u]};
        vector<int> all;
        int d = 31 - __builtin_clz(u);
        for(int i = u << (n - d); i < (u + 1) << (n - d); i++){
            all.push_back(q[i]);
        }
        sort(all.begin(), all.end());
        int L = 0, R = all.size() - 1, res = 0;
        while(L <= R){
            int mid = L + R >> 1;
            dfs(u, all[mid]);
            if(f[u] <= k) L = mid + 1, res = mid;
            else R = mid - 1;
        }
        vector<int> ans = {all[res]};
        int p = -1;
        for(int i = u << (n - d); i < (u + 1) << (n - d); i++){
            if(q[i] == all[res]) { p = i; break; }
        }
        dfs(u, all[res]);
        // cerr << u << ' ' << k << ' ' << f[u] << endl;
        k -= f[u];
        for(int i = p; i != u; i >>= 1){
            if(i & 1) k += f[i ^ 1];
            else if(f[i] + f[i ^ 1] - f[i >> 1] <= k) k += min(f[i ^ 1], w[i >> 1]);
            vector<int> tmp = solve(i ^ 1);
            ans.insert(ans.end(), tmp.begin(), tmp.end());
        }
        return ans;
    }
    void Main(){
        input(t);
        while(t--){
            input(n, k);
            for(int i = 1; i < (1 << n); i++) input(w[i]);
            for(int i = (1 << n); i < (1 << (n + 1)); i++) input(q[i]);
            vector<int> ans = solve(1);
            for(int x: ans) write(x), putchar(' ');
            puts("");
        }
        return;
    }
}
```

---

## 作者：XLao (赞：9)

upd on 2024.3.9：修改表述和 typo 和 图片。

题外话：官方初榜已经出了，d1t1 挂了 30，但目前还是苟进了。写篇题解攒攒 rp，希望终榜也能进。

---

字典序的题目有一个套路：就是在保证能行的情况下，一位一位地贪心确定。典型比如 [[九省联考 2018] IIIDX](https://www.luogu.com.cn/problem/P4364)。

下文 $n$ 指 $2^{16}$。

假设我们只要求出第一位最大能是多少。

那么显然可以 dp：$f_{u,x}$ 表示 $u$ 子树内最终以 $x$ 开头的最小代价是多少。枚举 $f_{lson,x}$ 和 $f_{rson,y}$ 就可以转移，注意到转移可以前缀和优化，而且总状态量是 $O(n\log n)$ 的，所以可以 $O(n\log n)$ 把所有 $f_{u,x}$ 求出来。我写的是比较臭的 vector 归并排序。

第一位显然取代价不超过 $K$ 的最大元素。

那么第一位已经确定（假设为 $q_u$），怎么确定第二位呢？我们发现只要在**保证第一位为 $q_u$** 的前提下最大化第二位即可。然后保证前两位的前提下最大化第三位……

我们考虑拿出 $u$ 到根的链。然后链上会连接一些子树，大概这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/sl0d9l4j.png)

那么最终的答案序列一定先是 $u$，然后是子树 1 里的所有叶子（顺序不一定），然后是子树 2 里所有叶子（顺序不一定），然后子树 3、4……

我们步骤大致如下：

在保证 $u$ 在第一位的情况下最大化子树 1 字典序；

扣去最大化子树 1 字典序的花费。

在保证 $u$ 在第一位的情况下最大化子树 2 字典序；

扣去最大化子树 2 字典序的花费。

……

为保证 $u$ 在第一位，我们要为它预留一些钱。预留的肯定越少越好。

进入子树 1 时，相当于要算出让 2、3、4 号子树都不“篡位”的最小代价。进入子树 2 时，就是让 3、4 号子树都不“篡位”。

对于作为右子树的子树，我们最少要留 $\min\{f_{rt,x}+w_{fa(rt)}\cdot [x<q_u]\}$。

对于作为左子树的子树，我们最少要留 $\min\{f_{rt,x}+inf\cdot [x<q_u]\}$。

设我们预留了 $cost$ 块钱。

现在就是“在代价不超过 $K-cost$ 的情况下，最大化该子树字典序”。要解决这个问题，类似的，我们可以先确定该子树第一位最大是多少，然后再递归下去。

一个小问题是：扣去花费的时机要仔细考虑。

可以这么做：每次递归进 $v$ 的时候，如果 $v$ 作为右子树，且选择的值 $<$ 上一层选择的值，那么相当于为最大化子树 $v$ 第一位，$fa(v)$ 必被选了，我们就让 $K\leftarrow K-w_{fa(v)}$。注意一定要在递归进去之前就扣去，而不是出来的时候再扣。

[考场代码比较丑](https://www.luogu.com.cn/paste/488nhlko)。

---

## 作者：elbissoPtImaerD (赞：7)

考虑第一位怎么确定。

$f_{u,i}$ 表示 $u$ 子树中，让最小字典序 $\ge i$ 的最小代价。
转移类似归并排序是容易的。

然后在 $f_1$ 数组上二分即可知道首位取值。

取完首位后，原树会被割成若干个规模更小的满二叉树。递归求解即可。

具体地，贪心地，我们找到首位对应的叶子，先扣去最小代价，然后不断跳父亲，如果从左子树到达父亲，就考虑一下父亲是否必须被点亮，然后求解自己兄弟的子问题即可。

记得及时更新代价。

复杂度 $O(n2^n)$。

```cpp
const LL infll=1ll<<60;
il void Solve()
{
  int n;rd(n);
  int m=1<<n,M=m<<1;
  ve<int>p(m|1);
  ve<LL>a(M);
  ve<ve<int>>b(M);
  for(LL&x:a) rd(x);
  for(int i=m;i<M;++i) p[--a[i]]=i;
  ve<ve<LL>>f(M);
  #define ls (u<<1)
  #define rs (ls|1)
  function<void(int)>dfs=[&](int u)
  {
    if(u>=m) {
      f[u]=ve<LL>{0,infll},b[u].pb(a[u]);
      return;
    }
    dfs(ls),dfs(rs),b[u].resize(b[ls].size()+b[rs].size());
    f[u].assign(b[u].size()+1,infll);
    auto _=[&]
    {
      int p=0;
      ve<pii>a(b[u].size());
      for(int i=0;i<b[ls].size();++i) a[p++]=pii(b[ls][i],i);
      for(int i=0;i<b[rs].size();++i) a[p++]=pii(b[rs][i],~i);
      return sort(all(a)),a;
    }();
    int c[3]{};
    for(auto[w,id]:_) {
      if(id>=0) {
        cn(f[u][c[2]],f[ls][c[0]]+min(a[u],f[rs][c[1]]));
      }
      else {
        cn(f[u][c[2]],f[ls][c[0]]+f[rs][c[1]]);
      }
      ++c[id<0],b[u][c[2]++]=w;
    }
    for(int i=f[u].size()-1;i;--i) cn(f[u][i-1],f[u][i]);
    return;
  };
  dfs(1);
  #undef ls
  #undef rs
  function<ve<int>(int,LL&)>solve=[&](int u,LL&K)
  {
    if(u>=m) return ve<int>{a[u]};
    int it=upper_bound(all(f[u]),K)-begin(f[u]);
    ve<int>ans{b[u][--it]};
    K-=f[u][it];
    for(int v=p[ans[0]];v^u;v>>=1) {
      LL c=f[v^1][upper_bound(all(b[v^1]),ans[0])-begin(b[v^1])];
      if(v&1) K+=c;
      else {
        K+=min(a[v>>1],c);
        if(c>K) K-=a[v>>1];
      }
      for(int x:solve(v^1,K)) ans.pb(x);
    }
    return ans;
  };
  for(int x:solve(1,a[0])) wrt(x+1,' ');
  wrt('\n');
  return;
}
```

[$\color{green}{\checkmark}$](https://www.luogu.com.cn/record/149854481)

---

## 作者：AsiraeM (赞：5)

好题。  

$w_i$ 的值域决定了这题不能用常规的方法 dp。  

接下来称在石像守卫激活情况固定时，Bob 按最优策略探索一棵树所对应的迷宫后的序列 $Q$ 为这棵树的最小字典序序列。  
Bob 的最优策略是显然的，即如果一个点上的石像守卫没有被激活，那么就先进入它最小字典序序列更小的子树；否则先进入左子树。  
接下来问题就转变为使原树的最小字典序序列最大。  

根据字典序的性质，首先是第一位越大越好，然后是第二位，在接下来是第三位，以此类推。
这启发我们将使字典序最大的问题转化为判断能否使第一位是某个数的判定性问题。  

可以把大于等于某个数 $x$ 的数都视为 $1$，其余都视为 $0$，那么要做的就是判断是否能在魔力值够的前提下使最小字典序序列的第一位为 $1$。  
设 $g_i$ 为使以 $i$ 为根的子树的最小字典序序列的第一位为 $1$ 的最小代价（如果以 $i$ 为根的子树的最小字典序序列的第一位无论如何激活石像守卫都不能为 $1$，则 $g_i=\infty$），  
那么 $g_i=g_{i\times2}+\min(g_{i\times2+1},w_i)$，  
即左子树的 $g$ 为 $\infty$ 时，右边字典序更大先走左边，或右子树的 $g$ 也为 $\infty$；  
否则可以激活位于 $i$ 的石像守卫（一定先走左边），或使右子树的最小字典序序列的第一位为 $1$（两个子树哪个先走都可以）。  

二分这个 $x$，在最小字典序序列的第一位可以为 $1$ 的前提下，$x$ 取到最大值时，最小字典序序列的第一位一定是 $x$（否则如果 $\exists y>x$，最小字典序序列的第一位可以是 $y$，那么 $x$ 也可以为 $y$）。  
接下来，考虑使用类似的方法依次使最小字典序序列的第二位、第三位......取到最大值。  

注意到，同一个子树的最小字典序序列中的数，在最终的最小字典序序列中也一定在一起（不能中途退出某个子树再进入）。  
因此，从 $q_k=x$ 的结点 $k$ 出发，一路向父亲走，走到的结点的子树所对应的最小字典序序列，在最终的最小字典序序列中排在最前面；  
也就是说，每个走到的节点 $i$（包括 $k$，不包括 $1$）的父亲的另一个儿子 $j_i$ 的子树所对应的最小字典序序列，在最终的最小字典序序列中按照走到的顺序依次从前向后排。  
可以按照这个顺序，对于所有上述的 $j$ 的子树，依次推倒重来，即进行上面的过程（类似分治；每次推倒重来一定会消耗尽可能多的魔力值）。  

对一些子树推倒重来时可能改变左右子树最小字典序序列的大小关系，需要考虑这些情况，保证 Bob 第一个到达的叶结点一定是 $k$，以及不浪费魔力值。  
如果一个走到的节点（定义同上）$i$ 是一个右儿子，那么它的子树对应的最小字典序序列一定小于 $j_i$ 的，因为消耗更多魔力值改变方案只会变得更大，所以可以将 $j_i$ 的方案直接推倒重来；  
如果 $i$ 是一个左儿子，那么当 $g_{j_i}<=w_{fa_i}$（父结点的石像守卫本来就没有激活）时，也可以直接将 $j_i$ 的方案直接推倒重来，理由同上（$i$ 的子树的最小字典序序列的第一位，即 $x$，是所有被视为 $1$ 的点中 $q$ 最小的，所以左边小于右边）；  
否则，如果目前方案剩余的魔力值足以从激活父亲的石像守卫改为使 $j_i$ 的子树的最小字典序序列的第一位视为 $1$，那么就不激活父亲的石像守卫（可以省下魔力值，同时 $j_i$ 的子树的最小字典序序列可以大于 $i$ 的），不然仍然需要激活；最后将 $j_i$ 的方案推倒重来。  

Code:
```cpp
//Talk is cheap.Show me the code.
#include<bits/stdc++.h>
namespace xcy{
const int MAXN=(1<<17)+5;
typedef long long ll;
const ll INF=0x3f3f3f3f3f3f3f3f;
ll a[MAXN],rev[MAXN],f[MAXN],q[MAXN],cnt,n,m,i,j,k,w,t;

inline void fread(ll &X){ll A=1;X=0;char C=getchar();while(!isdigit(C)&&C!='-')C=getchar();if(C=='-')A=-1,C=getchar();while(isdigit(C))X=(X<<1)+(X<<3)+(C^48),C=getchar();X*=A;}
inline void fout(ll X){if(X<0)putchar('-'),X=-X;if(!X){putchar('0'),putchar(' ');return;}char C[25]{};int Len=0;while(X)C[++Len]=X%10+'0',X/=10;for(;Len;--Len)putchar(C[Len]);putchar(' ');}
inline ll check(ll N,ll K)
{
    if(N<<1>=n)f[N]=(a[N<<1]<K?INF:(a[(N<<1)+1]<K?a[N]:0));
    else check(N<<1,K),check((N<<1)+1,K),
    f[N]=std::min(INF,f[N<<1]+std::min(a[N],f[(N<<1)+1]));
    return f[N];
}
inline void dfs(ll N)
{
    ll L=1,R=n,M;
    while(L<R)
    {
        M=L+R+1>>1;
        if(check(N,M)<=w)L=M;
        else R=M-1;
    }check(N,L);L=rev[L];w-=f[N];
    q[++cnt]=a[L];q[++cnt]=a[L^1];
    for(ll I=L>>1;I!=N;I>>=1)
    {
        if(I&1)w+=f[I^1];
        else if(f[I^1]<=a[I>>1])w+=f[I^1];
        else if(w>=f[I^1]-a[I>>1])w+=a[I>>1];
        dfs(I^1);
    }
}

int mian()
{
	//freopen("maze.in","r",stdin);
	//freopen("maze.out","w",stdout);
    fread(t);while(t--){
    fread(m);fread(w);n=1<<m;cnt=0;
    for(i=1;i<2*n;++i)fread(a[i]);
    for(i=n;i<2*n;++i)rev[a[i]]=i;
    dfs(1);for(i=1;i<=n;++i)fout(q[i]);putchar('\n');
    }return 0;
}}
int main(){return xcy::mian();}
```

---

## 作者：TernaryTree (赞：5)

爆想三小时 $\Theta(n^2)$ 通过大样例认为有 $75$ 分，出考场听说 D2T1 会的并不多觉得自己赢了，听同学说状态数 $\Theta(n\log n)$ 感觉自己输了。民间一测挂到 $55$ 觉得输麻了，官方数据直接死到 $40$ 分暴力不如。

不过这个题确实使人对贪心有更好的理解。题目质量挺高的。

---

字典序最小，那就一位一位考虑。$Q$ 的第一位会选到什么是好做的：令 $f_{u,i}$ 表示考虑 $u$ 子树，当前在 $u$，Alice 通过唤醒一些点，使得 Bob 最优策略下第一个能够走到权值 $\ge i$ 的最小唤醒代价。转移如下：

$$f_{u,i}=f_{ls,i}+\min(w_u,f_{rs,i})$$

我们注意到，$Q_1$ 即为最大的 $i$ 满足 $f_{1,i}\le K$。那么在确定了 $Q_1$ 之后，我们要继续确定 $Q_{2\cdots 2^n}$。

一个很自然的想法是，模拟 Bob 的探险过程进行 dfs。假设我们当前到达一个结点 $u$，如何判断下一步往左子树去，还是往右子树去？显然，我们要考虑当前还剩多少能用的代价 $K'$，并找到最大的 $i$ 满足 $f_{u,i}\le K'$，根据 $i$ 所在的位置判断方向。此时的 dfs 函数已经有了一个雏形：

- 参数 $u$：当前所在结点。
- 参数 $k$：当前结点所被分配到的最大代价。
- 返回值：返回在 $k$ 中，实际被使用的代价大小。

递归下一步 $u$ 的传参是容易的，$i$ 在左边就跑左边，否则跑右边。但是 $k$ 并不太好处理，分类讨论一下：

#### $i$ 在 $u$ 左子树内：

首先我们需要将右子树需要的代价扣掉，先跑左子树，此时传参为 $(ls,k-\min(w_u,f_{rs,i}))$。然而我们并不能果断地认为 $w_u\lt f_{rs,i}$ 时就一定选 $w_u$，这是因为如果选或者不选，都能让左子树跑出选了的结果，此时就没必要选 $w_u$；换句话说，若不选一定让左边不优，就必须选，否则可以不选。

这意味着，令左子树 dfs 的返回值为 $s$，若 $s\le k-f_{rs,i}$，则不选 $w_u$，否则选 $w_u$。第二次 dfs 的 $k$ 就可以方便地算出。

#### $i$ 在 $u$ 右子树内：

注意到我们完全不需要选 $w_u$，所以直接 dfs 右子树，再 dfs 左子树即可。同样地，前者的 $k$ 需要将左子树需要的代价扣掉。

#### 实现

实际上因为所有点子树中叶子个数之和是 $\Theta(n\log n)$ 的，所以 $f_{u,i}$ 是分段的，用 map 维护即可。并且可以证明 $f_{u,i}$ 关于 $i$ 单调不降，所以直接在上面二分即可。时间复杂度 $\Theta(n^22^n)$。

```cpp
#include <bits/stdc++.h>
#define int long long
#define fs first
#define sc second
#define ls (u << 1)
#define rs (u << 1 | 1)

using namespace std;
using pii = pair<int, int>;
using umap = map<int, int>;

const int maxn = 1e6 + 10;
const int inf = 1e18;
const bool multidata = 1;

int n, k;
int w[maxn];
int a[maxn]; 
int p[maxn], m;
int pos[maxn];
int l[maxn], r[maxn];
umap f[maxn], g[maxn];

int read() {
	int x = 0, f = 1;
	char c = getchar();
	while (c < '0' || c > '9') {
		if (c == '-') f = -f;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}

void write(int x) {
	if (x < 0) putchar('-'), x = -x;
	if (x < 10) return void (putchar(x + '0'));
	write(x / 10), putchar(x % 10 + '0');
}

void dfs1(int u) {
	if (u >= (1 << n)) {
		l[u] = r[u] = u;
		if (a[u] != (1 << n)) f[u][a[u] + 1] = inf;
		f[u][1] = 0;
		return;
	}
	dfs1(ls), dfs1(rs);
	l[u] = l[ls], r[u] = r[rs];
	umap::iterator nxt;
	for (pii kv : f[ls]) f[u][kv.fs] = kv.sc + min(w[u], ((nxt = --f[rs].upper_bound(kv.fs)) != f[rs].end() ? nxt->sc : inf));
	for (pii kv : f[rs]) f[u][kv.fs] = ((nxt = --f[ls].upper_bound(kv.fs)) != f[ls].end() ? nxt->sc : inf) + min(w[u], kv.sc);
}

int dfs2(int u, int k) {
	//cerr << u << " " << k << endl;
	if (u >= (1 << n)) {
		p[++m] = a[u];
		return 0;
	}
	umap::iterator now = g[u].upper_bound(k);
	int i = (now == g[u].end() ? (1 << n) : now->sc - 1);
	umap::iterator it; int use = 0;
	//cerr << i << endl;
	if (pos[i] >= l[rs]) {
		it = --f[ls].upper_bound(i);
		use = dfs2(rs, k - it->sc); 
		k -= use;
		use += dfs2(ls, k);
		return use;
	}
	it = --f[rs].upper_bound(i);
	use = dfs2(ls, k - min(w[u], it->sc));
	if (k - it->sc < use) use += w[u];
	k -= use;
	use += dfs2(rs, k);
	return use;
}

void fake_main() {
	n = read(), k = read(), m = 0;
	for (int i = 1; i < (1 << n); i++) w[i] = read();
	for (int i = (1 << n); i < (1 << n + 1); i++) a[i] = read(), pos[a[i]] = i;
	dfs1(1);
	for (int u = 1; u < (1 << n + 1); u++) for (pii kv : f[u]) if (!g[u].count(kv.sc)) g[u][kv.sc] = kv.fs;
	//for (int u = 1; u < (1 << n + 1); u++) for (pii kv : f[u]) cerr << u << " " << kv.fs << " " << kv.sc << endl;
	//for (int u = 1; u < (1 << n + 1); u++) for (pii kv : g[u]) cerr << u << " " << kv.fs << " " << kv.sc << endl;
	dfs2(1, k); 
	for (int i = 1; i <= (1 << n); i++) write(p[i]), putchar(' ');
	putchar('\n');
	for (int u = 1; u < (1 << n + 1); u++) f[u].clear(), g[u].clear(); 
}

signed main() {
	int T;
	if (multidata) T = read();
	else T = 1;
	while (T--) fake_main();
	return 0;
}

```

---

## 作者：strlen_s_ (赞：3)

这是一个悲伤的故事。

这个人在考场上花了一个半小时想会了 D2T1，然后担心自己写不出来，然后先去开了 T2，然后成功看错题。浪费 1.5h 后抓紧写T1，写了个正解，然后来不及调，结果暴力还挂了，送走自己。

考后花半小时调了出来，气死自己。

我们贪心地考虑这个问题。

我们第一次必定会访问到可以访问到的最大的 $j$。考虑如何求出取每个 $Q$ 的代价。

设 $dp_{i,j}$ 表示最少花费多少，使得在以 $i$ 为根的子树中，$Bob$ 第一次取到的是 $j$。

转移是好转移的。

假如 $j$ 是 $i$ 左子树中的点，且右子树中有比它小的，那么 $dp_{i,j}=\min(\min_{k>i}dp_{rs,k},w_i)+dp_{ls,j}$。

假如 $j$ 是 $i$ 右子树的点，且左子树中有比它小的，那么 $dp_{i,j}=\min_{k>j} dp_{ls,k} + dp_{rs,j}$。

可以使用双指针使得单次转移复杂度为线性，因为是满二叉树，所以 dp 复杂度为 $O(n2^n)$。

考虑求出 dp 数组后，怎么求答案。

我们先找到最大的，且代价小于 $K$ 的 $j$。那么第一次我们一定会走到 $j$。那么从 $j$ 回溯到根的时候，我们必定会访问与路径相邻的子树，那么我们再去走这些子树，发现就是原问题的一个子问题，可以递归求解。

那么我们只需要再讨论一下我们从路径上走到相邻子树的情况。假设现在我们在当前子树中选了一个最优的 $j$。

第一种情况：我们在路径的 $u$ 节点上，且是父亲 $v$ 的右儿子，现在我们要递归左儿子。若现在 $j$ 小于左儿子的最小值，那么直接递归即可。否则，左儿子的一个 $dp_{ls,k} (k>j)$ 已经被了减掉了，那么就需要把左儿子中的每个 $j$ 的代价都减去 $dp_{ls,k}$，然后再递归。

第二种情况：我们在路径的 $u$ 节点上，且是父亲 $v$ 的左儿子，现在我们要递归右儿子。若现在 $j$ 小于右儿子的最小值，那么直接递归即可。若没有在父亲上放石像更优，则右儿子的一个 $ dp_{rs,k}(k>j)$ 已经被了减掉了，那么就需要把右儿子中的每个 $j$ 的代价都减去 $dp_{rs,k}$，然后再递归。若放了石像更优，那么我们就把右儿子的 $dp_{rs,k}(k>j)$ 都减去 $w_v$。因为假设选了这些 $k$，父亲结点上的就不必放石像了。然后递归求解。

这部分分治的复杂度也是 $O(n2^n)$ 的，所以总复杂度为 $O(n2^n)$。

还需要在 dp 是记录一下每个状态是那个最优情况转移过来的，方便分治。

代码：

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=(1<<17)+10,inf=1e18;
struct tree{
	int ls,rs,val,fa;
}t[N];
int jl[N];
int T,n,k;
vector<int>ans;
int mi[N];
struct node{
	int id,val;
};
struct trp{
	int id,v1,v2;
};
bool operator < (node a,node b){return a.id<b.id;}
vector<node>dp[N];
vector<trp>cp[N];   //记录 dp 数组是如何转移过来的。
int mxl[N],mxr[N];
int ct[N];
void prep(int u){
	if(!t[u].ls){
		mi[u]=t[u].val;
		return;
	}
	prep(t[u].ls);prep(t[u].rs);
	mi[u]=min(mi[t[u].ls],mi[t[u].rs]);
}
void dfs(int u){
	if(!t[u].ls){
		dp[u].push_back((node){t[u].val,0});
		return;
	}
	dfs(t[u].ls);dfs(t[u].rs);
	int ls=t[u].ls,rs=t[u].rs;
	for(int i=0;i<dp[ls].size();i++)mxl[i]=dp[ls][i].val;
	for(int i=0;i<dp[rs].size();i++)mxr[i]=dp[rs][i].val;
	mxl[dp[ls].size()]=mxr[dp[rs].size()]=inf;
	for(int i=dp[ls].size()-1;i>=1;i--)mxl[i-1]=min(mxl[i-1],mxl[i]);
	for(int i=dp[rs].size()-1;i>=1;i--)mxr[i-1]=min(mxr[i-1],mxr[i]);
	for(int i=dp[ls].size()-1,l=dp[rs].size()-1;i>=0;i--){
		if(dp[ls][i].id<=mi[rs]){ct[dp[ls][i].id]=dp[ls][i].val;continue;}
		while(dp[rs][l].id>dp[ls][i].id&&l>=0)l--;
		int cx=mxr[l+1];
		cp[u].push_back((trp){dp[ls][i].id,cx+dp[ls][i].val,dp[ls][i].val});
		ct[dp[ls][i].id]=min({cx+dp[ls][i].val,t[u].val+dp[ls][i].val,inf});
	}
	for(int i=dp[rs].size()-1,l=dp[ls].size()-1;i>=0;i--){
		if(dp[rs][i].id<=mi[ls]){ct[dp[rs][i].id]=dp[rs][i].val;continue;}
		while(dp[ls][l].id>dp[rs][i].id&&l>=0)l--;
		int cx=mxl[l+1];
		cp[u].push_back((trp){dp[rs][i].id,cx+dp[rs][i].val,dp[rs][i].val});
		ct[dp[rs][i].id]=min(inf,cx+dp[rs][i].val);
	}
	for(int l=0,r=0;l<dp[ls].size()||r<dp[rs].size();){
		if(r>=dp[rs].size())dp[u].push_back((node){dp[ls][l].id,ct[dp[ls][l].id]}),l++;
		else if(l>=dp[ls].size())dp[u].push_back((node){dp[rs][r].id,ct[dp[rs][r].id]}),r++;
		else {
			if(dp[ls][l].id<dp[rs][r].id)dp[u].push_back((node){dp[ls][l].id,ct[dp[ls][l].id]}),l++;
			else dp[u].push_back((node){dp[rs][r].id,ct[dp[rs][r].id]}),r++;
		}
	}
}
void fz(int u,int pz,int pos,int v){
	if(!t[u].ls){
		ans.push_back(t[u].val);
		return;
	}
	int x=0;
	for(int i=dp[u].size()-1;i>=0;i--){
		if(dp[u][i].id>pos){
			if(k-(dp[u][i].val-pz-v)>=0){
				k-=(dp[u][i].val-pz-v);
				x=dp[u][i].id;
				break;
			}
		}
		else{
			if(k-(dp[u][i].val-pz)>=0){
				k-=(dp[u][i].val-pz);
				x=dp[u][i].id;
				break;
			}
		}
	}
	ans.push_back(x);
	int p=jl[x];
	while(p!=u){
		int c=t[p].fa,f=(t[c].rs==p);
		int v1=0,v2=-1,v3=0;
		for(auto i:dp[c]){
			if(i.id==x){
				v1=i.val;
				break;
			}
		}
		for(auto i:cp[c]){
			if(i.id==x){
				v2=i.v1;v3=i.v2;
				break;
			}
		}
		if(!f){     //情况二
			if(v2==-1)fz(t[c].rs,0,0,0);
			else{
				if(v1==v2)fz(t[c].rs,v2-v3,0,0);
				else fz(t[c].rs,0,x,t[c].val);
			}
		}
		else{   //情况一
			if(v2==-1)fz(t[c].ls,0,0,0);
			else fz(t[c].ls,v2-v3,0,0);
		}
		p=t[p].fa;
	}
}
void work(){
	ans.clear();
	for(int i=1;i<(1<<n+1);i++)dp[i].clear(),cp[i].clear();
	cin>>n>>k;
	for(int i=1;i<(1<<n);i++){
		t[i].ls=(i<<1),t[i].rs=(i<<1|1);
		t[t[i].ls].fa=i,t[t[i].rs].fa=i;
		cin>>t[i].val;
	}
	for(int i=(1<<n);i<(1<<n+1);i++){
		cin>>t[i].val;
		jl[t[i].val]=i;
		t[i].ls=t[i].rs=0;
	}
	prep(1);
	dfs(1);
	fz(1,0,0,0);
	for(auto i:ans)cout<<i<<' ';
	cout<<'\n';
	return;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>T;
	while(T--)work();
	return 0;
}
```

---

## 作者：Forever1507 (赞：2)

久违的写一篇题解纪念送走我今年省选的题目。

字典序类问题存在按位贪心的常规思路，这里我们考虑动态规划，设 $f_{i,j}$ 表示在以 $i$ 为根节点的子树中，Alice 要使得 Bob 走到的第一个叶子的符文不小于 $j$ 的最小花费。

状态数明显是 $4^n$ 的，但是我们先不急，考虑这个 $75$ 的暴力。

下文中的 $ls,rs$ 指 $u$ 的左右儿子。

考虑转移方程 $f_{u,i}=f_{ls,i}+\min(w_{cur},f_{rs,i})$，容易发现要求左边也为 $i$ 是显然易见的，毕竟你无法限制 Bob 先往右边走，然后对于右边的子树就是锁掉左边和强制右边也至少为 $i$ 取较小值了。

考虑在拥有 $f$ 数组的情况下如何输出方案。我们模拟 Bob 在树上移动的过程，用函数 `print(u,k)` 表示 Bob 位于 $u$，Alice 还剩 k 的能量时的情况。同时将函数返回值设计为在当前子树中花掉的代价。

具体来说，我们可以先二分找到最大的数 $i$ 使得 $f_{u,i}\le k$，那么 Bob 在当前状态下走到的第一个叶子就钦定为必然是 $i$ 了，然后分类：
1. 如果 $i$ 在 $u$ 的右子树中，那么就肯定不能锁左边，直接走就行了。
2. 如果在左边，先求出往左走的答案 `print(ls,k-min(w[cur],f[rs][i]))`，这个是无论如何操作都无法规避掉的代价。

对于在左边的情况继续细分。考虑到当前如果锁掉对答案又没有影响白白浪费魔力肯定亏炸，那么就是说如果不锁掉会让左子树答案变化才会锁。

更直白一点，如果我直接分别往左右走魔力不够，也就是 `print(ls,k-min(w[cur],f[rs][i]))+f[rs][i]>k` 的情况下，我才会锁掉左边，这样右边在当前这一位上不存在限制，状态也就合法了。由于你前面二分过了也就不用但是放不放都不合法的情况。

判断好锁不锁之后直接走就可以了，代码不难写，但是作为 $75$ 的部分分性价比不低。

考虑优化。注意到一棵子树并不存在所有的叶子节点，那么只要把自己子树内的叶子考虑到就可以了，这个总状态是 $2^nn$ 的，如果优化掉转移就能够通过了。

我们以 `vector` 的形式记录 $f$ 和子树内的叶子节点，后者暴力合并正确性显然，前者也只是分别考虑左右子树的叶节点，在另一颗子树中 `lower_bound` 一下即可。（详细解释一下就是钦定一个位置作为最小值然后二分出对面子树的合法位置），然后动态规划的部分就解决了。

输出的部分其实也是一样的，把原来直接表示后缀的 $f$ 改成二分一下就可以了。时间复杂度两只 $\log$，可以通过。

注意一下 `lower_bound` 的时候 **一定要判对面的整棵子树都小于待查找的值的情况**，不然挺容易挂的。

虽然分析很复杂，但是代码出乎意料的好写：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int T,n,k,m;
const int N=2e5+5;
int w[N],q[N<<1];
vector<int>f[N],id[N];
int pos[N];
#define ls (cur<<1)
#define rs (cur<<1|1)
void dfs(int cur){
    if(cur>=m){
        f[cur].push_back(0);
        id[cur].push_back(q[cur]);
        return;
    }
    dfs(ls);dfs(rs);
    id[cur]=id[rs];
    for(int i=0;i<id[ls].size();++i)id[cur].push_back(id[ls][i]);
    sort(id[cur].begin(),id[cur].end());
    for(int i=0;i<id[cur].size();++i)pos[id[cur][i]]=i;
    f[cur].resize(id[cur].size());
    for(auto &i:f[cur])i=1e18;
    for(int i=0;i<f[ls].size();++i){
        if(id[rs].back()>=id[ls][i])
        f[cur][pos[id[ls][i]]]=f[ls][i]+min(w[cur],f[rs][lower_bound(id[rs].begin(),id[rs].end(),id[ls][i])-id[rs].begin()]);
        else
        f[cur][pos[id[ls][i]]]=f[ls][i]+w[cur];
    }
    for(int i=0;i<f[rs].size();++i){
        if(id[ls].back()>=id[rs][i])
        f[cur][pos[id[rs][i]]]=min(w[cur],f[rs][i])+f[ls][lower_bound(id[ls].begin(),id[ls].end(),id[rs][i])-id[ls].begin()];
    }
}
int print(int cur,int K){
    if(cur>=m){
        cout<<q[cur]<<' ';
        return 0;
    }
    int lt=-1,rt=id[cur].size();
    while(lt+1<rt){
        int mid=lt+rt>>1;
        if(f[cur][mid]<=K)lt=mid;
        else rt=mid;
    }
    int tmp=0;
    auto pos=lower_bound(id[rs].begin(),id[rs].end(),id[cur][lt]);
    if(pos!=id[rs].end()&&id[rs][pos-id[rs].begin()]==id[cur][lt]){
        tmp=print(rs,K-f[ls][lower_bound(id[ls].begin(),id[ls].end(),id[cur][lt])-id[ls].begin()]);
        tmp+=print(ls,K-tmp);
    }
    else{
        if(pos==id[rs].end())tmp=print(ls,K-w[cur]);
        else tmp=print(ls,K-min(w[cur],f[rs][lower_bound(id[rs].begin(),id[rs].end(),id[cur][lt])-id[rs].begin()]));
        if(pos==id[rs].end()||tmp>K-f[rs][pos-id[rs].begin()])tmp+=w[cur];
        tmp+=print(rs,K-tmp);
    }
    return tmp;
}
void work(){
    cin>>n>>k;
    m=(1<<n);
    for(int i=1;i<=m*2;++i)f[i].clear(),id[i].clear(),pos[i]=0;
    for(int i=1;i<m;++i)cin>>w[i];
    for(int i=m;i<2*m;++i)cin>>q[i];
    dfs(1);
    print(1,k);
    cout<<'\n';
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>T;
    while(T--)work();
    return 0;
}
```
虽然好像有归并排序的清新做法，但是我对这种相对抽象的东西脑子一直转不过弯，就用这种相对暴力很多的东西了（？

---

## 作者：xzf_200906 (赞：2)

这是一个时间复杂度为 $\mathcal{O}(n2^n)$ 的题解。

记 $cnt_u$ 表示点 $u$ 的子树中的叶子节点个数，$son_{u,i}$ 为点 $u$ 子树中第 $i$ 小的符文 $q$。$son$ 数组可以在 $\mathcal{O}(n2^n)$ 的时间复杂度内得出。特别地，如果 $i>cnt_u$，则定义 $son_{u,i}$ 为正无穷。

考虑如何让序列 $Q$ 的第一个数最大化，记 $f_{u,i}$ 为使序列 $Q$ 的第一个数大于等于 $son_{u,i}$ 的最小代价（如果 $i>cnt_u$，则同样定义 $f_{u,i}$ 为正无穷）。那么 $f_{u,i}$ 可以用两种方法转移，下文中记 $ls,rs$ 分别为点 $u$ 的左右儿子，$nxt_{u,x}={\min}\{i|son_{p,i}\geq x\}$。
+ Alice 不激活节点 $u$ 的石像，此时她需要使左右儿子分别能走到的第一个叶子节点符文均大于等于 $i$。
+ Alice 激活节点 $u$ 的石像，此时她仅需要使左儿子能走到的第一个叶子节点符文大于等于 $i$ 即可。

于是有以下转移方程：
$$f_{u,i}=f_{ls,nxt_{ls,i}}+\min(f_{rs,nxt_{rs,i}},w_u)$$
使用双指针维护 $nxt$ 即可在 $\mathcal{O}(n2^n)$ 的时间完成计算。最终的 $Q_1$ 即为 $son_{\max\{i|f_{1,i}\leq K\}}$。

问题在于，如何找到剩下的 $Q$。

将 $Q_1$ 所在的节点找到，并找出它除了 $1$ 号点外的所有祖先（包括自己），对于一个祖先 $p$，记其兄弟为 $b$，父亲为 $fa$：
+ 若点 $p$ 为祖先的左儿子，则存在两种选择：
	+ 选择激活点 $f$ 的石像，花费 $w_{fa}$ 的代价。
   + 选择使点 $b$ 所能走到的第一个叶子节点的符文大于等于 $Q_1$，花费 $f_{b,nxt_{b,Q_1}}$ 的代价。
   + 所以，在点 $p$ 需要预留 $\min(w_{fa},f_{b,nxt_{b,Q_1}})$ 的代价。
+ 若点 $p$ 为祖先的右儿子，则只能选择使点 $b$ 所能走到的第一个叶子节点的符文大于等于 $Q_1$，需要预留 $f_{b,nxt_{b,Q_1}}$ 的代价。

在预留代价之后，可能 $K$ 还有剩余，我们可以用剩余的 $K$ 使答案字典序更大。由深至浅考虑 $Q_1$ 所在的节点除了 $1$ 号点外的所有祖先 $p$（包括自己），其兄弟 $b$ 的子树在最终序列 $Q$ 中比尚未考虑的节点出现更早，所以使点 $b$ 的子树字典序最小可以满足全局字典序最小。此问题与子树外的节点无关，并且仅比原问题多出以下限制：
+ 选取一个足够大的值为 $inf$，若该子树内所遍历到的第一个叶子小于 $Q_1$，则需要额外付出 $w_{fa}[p 是左儿子]+inf[p 是右儿子]$ 的代价。

这个问题的形式与原问题相似，可以递归计算，在递归计算时不需要再次 DP，直接使用原 DP 结果即可。

时间复杂度为 $\mathcal{O}(n2^n)$。

Code:
```cpp
#include <bits/stdc++.h>
#define LL long long
const LL inf=10000000000000000ll;
const int N=300005;
using namespace std;
vector<int> son[N];
vector<LL> f[N];
LL w[N],k;
int dfn[N],poi[N],pos[N],n,tot=0;
void pre(int p){
	dfn[p]=++tot;
	poi[tot]=p;
	f[p].resize(son[p].size());
	f[p][0]=0;
	if(p>=(1<<n)) return;
	pre(p<<1);
	pre(p<<1|1);
	int sz=son[p<<1].size(),lp=0,rp=0;
	for(int i=0;i<sz*2;i++){
		while(lp<sz&&son[p<<1][lp]<son[p][i]) lp++;
		while(rp<sz&&son[p<<1|1][rp]<son[p][i]) rp++;
		f[p][i]=inf;
		if(lp<sz&&rp<sz) f[p][i]=min(f[p][i],f[p<<1][lp]+f[p<<1|1][rp]);
		if(lp<sz) f[p][i]=min(f[p][i],f[p<<1][lp]+w[p]);
	}
}
LL solve(int rt,int num,LL pen,LL lft){
	int pos_=-1,m=son[rt].size();
	for(int i=0;i<m;i++){
		if(f[rt][i]+(son[rt][i]>num?0:pen)<=lft) pos_=i;
	}
	int nxt=son[rt][pos_];
	cout<<nxt<<' ';
	LL dc[20],use=(nxt>num?0:pen),cnt=0;
	int tmp=pos[nxt];
	for(int i=0;tmp!=rt;i++){
		dc[i]=inf;
		auto p=son[tmp^1].begin();
		for(;p!=son[tmp^1].end();p++){
			if(*p>=nxt) break;
		}
		if(p!=son[tmp^1].end()) dc[i]=f[tmp^1][p-son[tmp^1].begin()];
		if(!(tmp&1)) dc[i]=min(dc[i],w[tmp>>1]);
		use+=dc[i];
		cnt+=dc[i];
		tmp>>=1;
	}
	tmp=pos[nxt];
	for(int i=0;tmp!=rt;i++){
		use-=dc[i];
		cnt-=dc[i];
		if(tmp&1) use+=solve(tmp^1,nxt,inf,lft-use);
		else use+=solve(tmp^1,nxt,w[tmp>>1],lft-use);
		tmp>>=1;
	}
	return use;
}
void work(){
	cin>>n>>k;
	for(int i=1;i<(1<<n);i++) cin>>w[i];
	for(int i=(1<<n);i<(1<<(n+1));i++){
		int q;
		cin>>q;
		pos[q]=i;
	}
	tot=0;
	for(int i=1;i<(1<<(n+1));i++){
		son[i].clear();
		f[i].clear();
	}
	for(int i=1;i<=(1<<n);i++){
		int p=pos[i];
		while(p){
			son[p].push_back(i);
			p>>=1;
		}
	}
	pre(1);
	solve(1,0,0,k);
	cout<<'\n';
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int T;
	cin>>T;
	while(T--) work();
	return 0;
}
```

---

## 作者：SnowTrace (赞：1)

提供一个和大众做法不一样的做法。

其实这个神秘做法是因为我想歪了，我如果一次走一步就和其他题解一样了，但我每次都直接走到一个叶子，然后性质很差。

和其他题解一样，我们先考虑 A 操作以后 B 第一个到达的点最大能是多少。

如果你唤醒了某个守卫，那这个守卫的右子树的点都被支配了，也就是会在这一轮无法被选中。

这个结构具有良好的性质，我们二分一个答案，然后用 dp 确定合法性。具体来说设 $dp_{i,0/1}$ 表示已经考虑完以 $i$ 为根的子树，且子树内还有/没有点没有被支配时需要花费的最小代价。

然后我们可以得到 B 第一个到达的点，设为 $x$，注意到这个树上的路径都是唯一的，我们不妨就让 B 直接走到 $x$。

接下来我们希望第二个，第三个，以及后面的被访问的点也可以通过类似上面的方法去求出来。

我们模拟 B 走路的过程，走到一个叶子以后会往上，然后再往下到一个没有任何一个点被访问的子树，访问完这个子树的**所有点**以后，又会往上，然后又往下走到一个更大的没被访问的子树。

如果我们当前走到了一个没有任何点被访问的子树的根的位置，我们希望像一开始一样，求出 A 当前可以让 B 到达的最大的位置。

这个问题看似是上一个问题的子问题，但是实际上直接做并不对。因为你现在已经钦定了 B 必须要先到这个第一个到达的点 $x$，而走到 $x$ 是需要支付一定代价激活一些守卫的，但是这些激活的守卫可能还对后面的代价有影响，也就是说如果按照上面的做法继续做会存在后效性。

我们定义覆盖：如果 $y$ 点的守卫被激活了，而且 $x$ 在 $y$ 的右子树内，则我们称 $x$ 被 $y$ 覆盖。

称一个最深的覆盖是对于一个 $x$ 满足上述条件的深度最大的 $y$，容易注意到当守卫激活状态固定时 $y$ 是唯一的。

考虑我们钦定第一个走到的位置是 $x$ 实际上是怎样一个条件，也就是对于所有值 $<x$ 的叶子，都存在一个点把它覆盖了。

可以推广的更一般的情况，如果当前访问到了没有任何一个点被访问的子树的根（定义看上面 B 的走路过程），设其为 $u$，钦定下一个被访问的点是 $x'$，那么能走到 $x'$ 的条件是：

**只考虑 $u$ 子树内的守卫激活情况，对于所有值 $<x'$ 的叶子，子树内存在一个点将其覆盖。**

换句话说就是，对于所有 $<x'$ 的位置，其最深覆盖点的深度大于等于 $u$ 点的深度。

现在继续考虑这样一个问题：已经确定了 B 前 $k$ 个走到的点是 $s_1,s_2,...,s_{k}$，现在需要判定下一个点走到 $x$ 是否可行。

我们把限制全部列出来，相当于对于每个点有一个最深覆盖的深度限制。

这个东西就可以 dp 了，设 $dp_{i,j}$ 表示以 $i$ 为根的子树内，部分限制已经被满足，目前最严格的限制是 $i$ 中某一点的最深覆盖深度要 $\geq j$。

转移每次枚举两边子树当前的限制，然后再枚举当前的点选不选。

可以用前缀优化做到 $O(2^n n)$ 完成一次 dp。

然后确定了前若干次 B 访问到的点，我们继续按照上面 B 走路的过程模拟。如果我们确定了下一个 B 走过的叶子节点，我们就直接让 B 走到这个叶子节点然后继续上面的过程。

根本上这个过程是**考虑到因为后面走到点的不确定，守卫的激活状态是不确定的，但是 B 前面走的路径却是确定的，所以其对覆盖关系的限制也能确定。直接钦定 B 下一个经过的叶子节点然后用 dp 去判断合法性**。

这个暴力做法的复杂度就先不分析了，每尝试确定下一个点就要做一次 dp，所以复杂度大概是 $O(4^n\operatorname{poly}n)$。

我们知道满二叉树的结构非常优秀，我们尝试优化上述的过程。

我们考虑到一个没有任何点被访问的子树的根 $u$，然后尝试确定下一个位置的数，实际上只有 $u$ 子树内的 dp 值和 $u$ 祖先的 dp 值会发生变化，我们考虑每次做的时候只计算 $u$ 子树内的变化，然后再向上合并。

这个东西乍一看，每次有一个二分，然后有 $O(n)$ 次合并，每次合并是 $O(n)$ 的，好像是 $O(2^nn^3)$ 的。

考虑分析它。这个树上大小为 $2^i$ 的子树只有 $2_{n-i}$ 个，而在一个大小 $2^i$ 的子树上二分需要 $i$ 次，求和：

$n^2\sum_i 2^{n-i}i = n^2\sum_i\sum_{j = 0}^i 2^{n-i} = n^2\sum_j\sum_{i = j}^n 2^{n-i} \leq n^2\sum_j 2^{n-j+1} \leq n^22^{n+2}$

所以复杂度是 $O(2^nn^2)$ 的。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define double long double
#define lowbit(x) (x&(-x))
#define int long long
const int inf = 1000000000000000;
int n,K;
vector<int>son[200005],val[200005];
int ll[200005],rr[200005],dep[200005];
int dp[200005][18];
int vis[200005];
int a[200005],p[200005],pos[200005];
int b[200005],c[200005];
int f[20],g[20];
vector<int>ans;
int tot;
//已经确定的限制 正在 check 的限制 
void build(int l,int r,int k){
	ll[k] = l,rr[k] = r;
	dep[k] = dep[k>>1]+1;
	if(l == r){son[k].push_back(k);val[k].push_back(p[k]);return;}
	int mid = l+r>>1;
	build(l,mid,k<<1),build(mid+1,r,k<<1|1);
	for(auto x:son[k<<1])son[k].push_back(x);
	for(auto x:son[k<<1|1])son[k].push_back(x);
	for(auto x:val[k<<1])val[k].push_back(x);
	for(auto x:val[k<<1|1])val[k].push_back(x);
}
void work(int now){
	if(now>=tot){
		for(int i =0;i<=n;i++)dp[now][i]=inf;
		dp[now][max(c[now],b[now])] = 0;
		return;
	}
	work(now<<1),work(now<<1|1);
	//钦定最大值在左边，什么都不用干
	int mn = inf,d = dep[now];
	for(int i = 0;i<d;i++){
		mn = min(mn,dp[now<<1|1][i]);
		dp[now][i] = dp[now<<1][i]+mn;
	} 
	mn = min(mn,dp[now<<1|1][d]);
	for(int i =0;i<d;i++){
		dp[now][i] = min(dp[now][i],min(dp[now<<1][i]+mn+a[now],inf));
	}
	mn = inf;
	//钦定最大值在右边
	for(int i =0;i<d;i++){
		mn = min(mn,dp[now<<1][i]);
		dp[now][i] = min(dp[now][i],dp[now<<1|1][i]+mn);
	} 
	//把右边的消掉 
}
void slove(int now,int tp){
	if(now==1)return;
	//从下向上合并 now 和他的兄弟
	int to = now^1;
	//需要讨论 now 在左边还是右边 
	int mn = inf,d = dep[now>>1];
//	cout << "!   " << to << endl;
//	for(int i =0;i<=d;i++)cout << dp[to][i] << " ";cout << endl;
	for(int i = 0;i<d;i++)g[i]=inf;
	for(int i = 0;i<d;i++){
		mn = min(mn,dp[to][i]);
		g[i] = f[i]+mn;
	}
	if(to&1){
		mn = min(mn,dp[to][d]);
		for(int i =0;i<d;i++){
			g[i] = min(g[i],min(f[i]+mn+a[now>>1],inf));
		}
	}
	mn = inf;
	for(int i =0;i<d;i++){
		mn = min(mn,f[i]);
		g[i] = min(g[i],dp[to][i]+mn);
	}
	if(now&1){
		mn = min(mn,f[d]);
		for(int i =0;i<d;i++){
			g[i] = min(g[i],min(dp[to][i]+mn+a[now>>1],inf));
		}
	}
	for(int i =0;i<d;i++)f[i] = g[i];
	if(tp){for(int i =0;i<d;i++)dp[now>>1][i] = f[i];}
	slove(now>>1,tp);
}
bool check(int now,int v){
	int d =dep[now];//cout << " " << d << endl;
	for(auto x:son[now])if(p[x]<v)c[x] = d;
	work(now);
	for(int i = 0;i<d;i++)f[i] = dp[now][i];
	for(int i = d;i<=n;i++)f[i] = inf;
	slove(now,0);
	for(auto x:son[now])c[x] = 0;
	return (f[0]<=K);
}
void dfs(int now,int to = 0){
	int l = ll[now],r = rr[now],d = dep[now];
	//cout << now << " " << to << " " << l << " " << r << endl;
	// to 是某个叶子在序列中的位置，如果没有就找一个
	if(now>=tot){ans.push_back(p[now]);return;}
	if(!to){
		//否则在子树里面二分
		int l = 0,r = val[now].size()-1;
		while(l<r){
			int mid = l+r+1>>1;
			if(check(now,val[now][mid])){
				l = mid;
			}else r = mid-1;
		}
		to = pos[val[now][l]]+tot-1;
		for(auto x:son[now])if(p[x]<val[now][l])b[x] = d;
		work(now);
	//	cout << " >  " << now << endl;
	//	for(int i =0;i<d;i++)cout << dp[now][i] <<" ";cout << endl;
		for(int i =0;i<d;i++)f[i] = dp[now][i];
		slove(now,1);
	//	cout << " " << now << " " << pos[val[now][l]] << endl;
	}
	int ppos = to-tot+1;
	int mid = l+r>>1;
	if(ppos<=mid){
		dfs(now<<1,to);
		dfs(now<<1|1,0);
	}else{
		dfs(now<<1|1,to);
		dfs(now<<1,0);
	}
}
void solve(){
	
	cin >> n >> K;
	tot = 1<<n;
	for(int i =0;i<=tot*2;i++)son[i].clear(),val[i].clear();
	ans.clear();
	for(int i =0;i<=tot*2;i++)for(int j =0;j<=n;j++)dp[i][j] = 0;
	for(int i =0;i<=tot*2;i++)vis[i] = b[i] = c[i]=0;
	
	for(int i = 1;i<=(1<<n)-1;i++)cin >> a[i];
	for(int i = (1<<n);i<=(1<<n+1)-1;i++)cin >> p[i];
	for(int i = (1<<n);i<=(1<<n+1)-1;i++)pos[p[i]] = i-tot+1;
	build(1,tot,1);
	for(int i =0;i<=tot*2;i++)sort(val[i].begin(),val[i].end());
	dfs(1,0);
	for(auto x:ans)cout << x << " ";cout << '\n';
}
signed main(){
	//freopen("maze5.in","r",stdin);
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	int t;cin >> t;
	while(t--)solve();
	return 0;
}/*
1
3 3
3 2 1 2 1 2 1
4 2 6 3 7 1 5 8
*/ 

```

---

## 作者：Last_Flame (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10220)

# 思路

考虑对于一棵子树，如果我们确定了探险者 Bob 第一个取到的符文，那么接下来他必须按从深到浅的顺序进入与路径相连的节点为。那么我们考虑贪心，对于一棵子树，找到探险者 Bob 能取到的符文中最小编号最大是多少。

考虑什么情况下一个符文不能第一个取到，当且仅当唤醒了该符文的一个祖先 $p$ 上的守卫，使得该符文在节点 $p$ 的右子树内。

考虑对于整棵树，我们如何确定 Bob 第一个取到的符文。我们按编号从小到大枚举符文，对于每个符文，我们先看它是否处在某个已被唤醒的守卫的右子树内，如果是，那么考虑下一个符文，否则我们找到他的祖先中 $w_{p}-sumw_{rs_{p}}$ 最小的祖先 $p$（$sumw_{p}$ 表示以 $p$ 为根的子树内，所有已被唤醒的守卫的 $w$ 之和），唤醒节点 $p$ 位置的守卫，再把以 $rs_{p}$ 为根的子树中所有的守卫敲晕，直到 $k < w_{p}-sumw_{rs_{p}}$。这么做正确性显然，因为每个符文都不可能有更优的方案。

那么我们就知道了 Bob 第一个选择的符文了，然后我们考虑模拟 Bob 的行动，每次进入到一颗新的子树就重复上述操作。

然后你写出来了，然后你交了，然后你只得了 $25$ 分，然后你自闭了。

考虑这样做有哪些花费是有损耗的。考虑我们在某子树中让一些守卫守住了一些符文（让这些符文不能被第一个选到），但这些符文在更大的子树内，也都被另一些守卫守住了，那么这个时候只需要保留深度深的守卫守住这些符文即可，更大子树中的那些守卫是被浪费了的。

所以我们考虑在递归到某个子树时，如果这个子树的根是其父节点的右儿子，且其父节点守卫已被唤醒，那么尝试将这个守卫守住的符文分给子树内多个守卫守住，如果可以，那么就敲晕这个守卫，再递归到子树内。考虑这么做的正确性，由于是字典序，所以按 Bob 行动的顺序操作，在递归前尝试拆守卫，显然正确。

考虑时间复杂度，每个符文可能在以它的任一祖先为根的子树内被尝试加入，一次加入是 $O(n)$ 的，所以总复杂度 $O(n^{2} 2^{n})$

# code

我们需要知道某子树中，比某个符文大的最小符文，考场写的是主席树，其实可以使用类似归并排序的方法，记录每个符文在每个子树内的 $next$。

把守卫敲晕，可以使用类似线段树懒标记的操作。

[主席树实现（这个是暴力敲晕守卫，复杂度错误但是能过）](https://www.luogu.com.cn/record/149666337)

[归并实现](https://www.luogu.com.cn/record/150950302)

---


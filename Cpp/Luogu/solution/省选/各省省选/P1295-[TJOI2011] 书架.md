# [TJOI2011] 书架

## 题目背景

由于最近又购买了很多书，所以你打算在自己的书房做一个新书架，为了照顾整体效果，你希望你的书架的宽度越小越好。

书架背靠墙摆放，宽度就是指书架在垂直于墙面的方向上占据的距离。

## 题目描述

现按一定顺序给出所有要放置于书架上的书，共有 $n$ 本，第 $i$ 本书有一个长度 $h_i$。

书架有若干层，层与层之间的宽度不一定相等，但是一层的宽度不能小于其上所摆放的任何一本书的长度。同时，每层上的书的长度之和不能超过一个给定的参数 $m$，且任何层上的书必须是给出的书的序列中连续的几本。

书架的宽度是所有层的宽度之和，求书架的最小宽度。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $ n \leq 10^3$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^5$，$1 \leq h_i \leq 10^9$，$\max\limits_{i = 1}^{n} h_i \leq m \leq 10^9$。

#### 提示

由于原题题意严重模糊不清，现给出简化版题意：

给出一个长度为 $n$ 的序列 $h$，请将 $h$ 分成若干段，满足每段数字之和都不超过 $m$，最小化每段的最大值之和。 

## 样例 #1

### 输入

```
4 6
1
3
3
1```

### 输出

```
5```

# 题解

## 作者：Minclxc (赞：43)

发个O(n)的题解

先写个dp方程f[i]=f[j]+max(a[j+1]...a[i])(s[i]-s[j]<=m)

对于转移方程可行的j且a[j+1]<=max(a[j+2]...a[i])

f[j]+max(a[j+1]...a[i])与f[j+1]+max(a[j+2]...a[i])后半段相同

易知f[j]<=f[j+1],所以前者更优

推广可得最优转移一定在a[q1]>a[q2]>a[q3]>a[q4]>...>a[qj]中

f[a[qj]]+a[q[j+1]]取得（对于a[q1],有f[st]+a[q1],st是最大的使a[st]+...+a[i]>m）

即维护一个单调队列，并对单调队列中值取最大值

即维护一个可查询最大值的双端队列（单调队列是个双端队列）

操作是维护一个中点，向两端维护单调栈，如果左右端点超过中点就重构单调栈，

以上操作是O(1)的证明我放在U16395中

https://www.luogu.org/problemnew/show/U16395

所以每次就是提出双端队列中的最小值和f[st]+a[q1]取最小值，为f[i]

做到O(1)转换，总共就是O(n)

```cpp
#include<cstdio>
using namespace std;
#define fo(a,b,c) for(int a=b;a<=c;a++)
#define go(a,b,c) for(int a=b;a>=c;a--)
#define min(a,b) ((a)<(b)?(a):(b))
int read(){
    int a=0,f=0;char c=getchar();
    for(;c<'0'||c>'9';c=getchar())if(c=='-')f=1;
    for(;c>='0'&&c<='9';c=getchar())a=a*10+c-'0';
    return f?-a:a;
}
const int N=1e5+1;
int a[N],f[N],qu[N],qi[N],pst[N],qst[N],pt,qt,s=1,t,mid;
//a数字，f最优解，qi单降队列在a的下标，qu对qi每个的f值，pst左单调栈在qu的下标，qst表示右
void pushp(int x){
    if(!pt||qu[pst[pt]]>qu[x])pst[++pt]=x;
}//左端插入
void pushq(int x){
    if(!qt||qu[qst[qt]]>qu[x])qst[++qt]=x; 
}//右端插入
void rebuild(){
    mid=s+t>>1;pt=qt=0;
    go(i,mid,s)pushp(i);
    fo(i,mid+1,t)pushq(i);
}//重构单调栈
int main(){
//f[i]=f[j]+max(a[j+1]...a[i])(s[i]-s[j]<=m)动归方程
    int n=read(),m=read(),st=1,sum=0;
    fo(i,1,n){
        sum+=a[i]=read();
        while(sum>m)sum-=a[st++];//维护st
        while(s<=t&&a[qi[t]]<=a[i]){
            if(qt&&qst[qt]==t)qt--;
            if(pt&&pst[pt]==t)pt--;
            if(--t<=mid)rebuild();
}//维护单调队列
qi[++t]=i;qu[t]=(s==t?f[st-1]:f[qi[t-1]])+a[i];pushq(t);//加入当前元素
        if(pst[pt]==s)pt--;
        if(qst[qt]==s)qt--;//将a[q1]排除（不符合f[a[qj]]+a[q[j+1]]规律）
        while(s<=t&&qi[s]<st){
            if(qt&&qst[qt]==s)qt--;
            if(pt&&pst[pt]==s)pt--;
            if(++s>mid)rebuild();
}//弹出过期元素
        f[i]=a[qi[s]]+f[st-1];
        if(pt)f[i]=min(f[i],qu[pst[pt]]); 
        if(qt)f[i]=min(f[i],qu[qst[qt]]);//转移
    }
    printf("%d",f[n]);
    return 0;
}
//input
//6 6
//3 5 1 2 4 1
//output
//13
```

---

## 作者：灵乌路空 (赞：31)

# 知识点: 线段树优化DP

## [原题面](https://www.luogu.com.cn/problem/P1295)

双倍经验 [P1848 [USACO12OPEN]Bookshelf G](https://www.luogu.com.cn/problem/P1848)。  
这边有 dalao 的神仙题解。

？我一开始为什么要写二维 DP  

---

## 题意简述

>给出一个长度为 $n$ 的序列 $h$。  
>将 $h$ 分成若干段，满足每段数字之和都不超过 $m$。
>最小化每段的最大值之和。  
>$1\le n\le 10^5, 1\le h_i\le 10^9$

---

## 分析题意

有个非常显然的 DP ：  
设 $f_i$ 表示，已经分好 $i$ 个数字的最小代价。  
转移时枚举这一段的开头 $k$，将 $[k,i]$ 作为新的一段，则有：  

$$f_i = \min\left\{f_{k-1} +\max_{j=k}^{i}h_j\right\}\ \left(\sum_{j=k}^{i}h_j\le m\right)$$  

暴力 DP 复杂度 $O(n^2)$，期望得分 $30\text{pts}$。  
实际上能水 $50\text{pts}$（大雾

---

考虑优化。

显然，对于一个给定的 $i$，当 $k$ 单增时，$\max\limits_{j=k}^{i}h_j$ 单调不增，$f_{k-1}$ 单调不降。  
当枚举到 $i$ 时，$f_{k-1}$ 不会再改变，考虑 $h_i$ 对 $\max\limits_{j=k}^{i}h_j$ 的影响。  

![我怒怒](https://cdn.luogu.com.cn/upload/image_hosting/bowwdele.png)

如图，设 $i$ 左侧第一个满足 $h > h_i$ 的位置为 $pre_i$，显然 $\max\limits_{j=k}^{i}h_j(k> pre_i)$ 都会变为 $h_i$。

$\max\limits_{j=k}^{i}h_j$ 可用支持区间赋值的数据结构进行维护，转移 $f_i$ 时，需要进行区间查询。    
考虑线段树。

---

线段树维护位置 $k$ 的 $f_{k-1}$ 和 $f_{k-1}+\max\limits_{j=k}^{i} h_j$。  
当枚举到一个新的 $h_i$ 时：  
1. 单点修改，更新位置 $k=i$ 时的 $f_{k-1}$。
2. 根据 $h_i$ 更新区间 $[pre_{i}+1,i]$ 的 $f_{k-1}+\max\limits_{j=k+1}^{i} h_j$。  
3. 二分得到 第一个不满足 $\sum\limits_{k}^{i}h_i\le m$ 的位置 $l$，则 $k\in [l+1,i]$。  
4. 查询 $[l+1,i]$ 中最小的 $f_{k-1} + \max\limits_{j=k}^{i}h_j$。

复杂度 $O(n\log n)$，期望得分 $100\text{pts}$。

---

## 代码实现

```cpp
//知识点: 线段树优化DP
/*
By:Luckyblock
*/
#include <cstdio>
#include <ctype.h>
#include <cstring>
#include <algorithm>
#define ll long long
#define ls (now<<1)
#define rs (now<<1|1)
const int kMaxn = 1e5 + 10;
const ll kInf = 1e12 + 2077;
//=============================================================
struct SegmentTree {
  int L, R;
  ll f, ans, tag;
} t[kMaxn << 2];
ll n, m, h[kMaxn], w[kMaxn], sum[kMaxn], pre[kMaxn], f[kMaxn];
ll top, sta[kMaxn];
//=============================================================
inline ll read() {
  ll f = 1, w = 0; char ch = getchar();
  for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = -1;
  for (; isdigit(ch); ch = getchar()) w = (w << 3) + (w << 1) + (ch ^ '0');
  return f * w;
}
void Pushup(int now) {
  t[now].f = std :: min(t[ls].f, t[rs].f);
  t[now].ans = std :: min(t[ls].ans, t[rs].ans);
}
void Pushdown(int now) {
  t[ls].ans = t[ls].f + t[now].tag;
  t[rs].ans = t[rs].f + t[now].tag;
  t[ls].tag = t[rs].tag = t[now].tag;
  t[now].tag = kInf;
}
void Build(int now, int L, int R) {
  t[now].L = L, t[now].R = R;
  if (L == R) {
    t[now].f = t[now].ans = t[now].tag = kInf;
    return ;
  }
  int mid = (L + R) >> 1;
  Build(ls, L, mid), Build(rs, mid + 1, R);
  Pushup(now);
}
ll Query(int now, int L, int R) {
  if (L <= t[now].L && t[now].R <= R) return t[now].ans;
  if (t[now].tag != kInf) Pushdown(now); 
  int mid = (t[now].L + t[now].R) >> 1;
  ll ret = kInf;
  if (L <= mid) ret = std :: min(ret, Query(ls, L, R));
  if (R > mid) ret = std :: min(ret, Query(rs, L, R));
  return ret;
}
void Update(int now, int L, int R, ll val) {
  if (L <= t[now].L && t[now].R <= R) {
    t[now].ans = t[now].f + val;
    t[now].tag = val;
    return ;
  }
  if (t[now].tag != kInf) Pushdown(now);
  int mid = (t[now].L + t[now].R) >> 1;
  if (L <= mid) Update(ls, L, R, val);
  if (R > mid) Update(rs, L, R, val);
  Pushup(now);
}
void Modify(int now, int pos) {
  if (t[now].L == t[now].R) {
    t[now].ans = kInf;
    t[now].f = f[pos - 1];
    return ;
  }
  if (t[now].tag != kInf) Pushdown(now);
  int mid = (t[now].L + t[now].R) >> 1;
  if (pos <= mid) Modify(ls, pos);
  else Modify(rs, pos);
  Pushup(now);
}
void Prepare() {
  n = read(), m = read();
  for (int i = 1; i <= n; ++ i) {
    h[i] = read();
    sum[i] = sum[i - 1] + h[i];
  }

  sta[++ top] = 1;
  for (int i = 2; i <= n; ++ i) {
    while (top && h[sta[top]] < h[i]) top --;
    if (top) pre[i] = sta[top];
    sta[++ top] = i;
  }
  Build(1, 1, n);
}
//=============================================================
int main() {
  Prepare();
  for (int i = 1; i <= n; ++ i) {
    Modify(1, i);
    if (pre[i] < i) Update(1, pre[i] + 1, i, h[i]);
    int l = std ::lower_bound(sum, sum + i + 1, sum[i] - m) - sum;
    if (l < i) f[i] = Query(1, l + 1, i);
  }
  printf("%lld", f[n]);
  return 0;
}
```


---

## 作者：xiejinhao (赞：11)

## ※题目分析

> 给出一个长度为 $n$ 的序列 $h$，请将 $h$ 分成若干段，满足每段数字之和都不超过 $m$，最小化每段的最大值之和。

~~众所周知~~，不会做的题目就 $DP$。其实 $DP$ 方程挺好想的，设 $f_i$ 为到第 $i$ 个数，分为若干段所需要的最小代价；设 $sum_{i}$ 为$h$ 的前缀和。根据题意可以得到转移：

$$f_i=\min\limits_{sum_i-sum_j\leq m}\left(f_j+\max\limits_{k=j+1}^{i}h_k\right)$$

这个式子有很多种处理方法，最简单的直接 $CDQ$ 就可以了，线段树题解区的大佬也讲过了，我翻提交记录好像看见了有用堆写的。如果用堆的话，是没有考虑好本题的单调性。

本文要提的是题解区的那个 $O(n)$ 做法。由于这位大佬的题解有一点久远，意思模糊不清，然后还有证明没给出，因此本文重提。

~~这种做法大概可以理解为用单调性对堆优化吧……~~

## ※性质分析

> 引理一：$\max\limits_{k=j+1}^{i}h_k$ 中，随着 $k$ 的增大，其值单调不增。

- 证明显然，这边不再赘述。

> 引理二：$f$ 单调不降。

- 考虑从题目本身出发，由于多分一段必然要让代价加上本段最大值，此时会使得 $f_i$ 增大；若当前的数 $h_i$ 和前面一段分在一起（满足条件的话），则 $f_i$ 与前面相同。因此 $f$ 是单调不降的。



~~参考 CSP-S 2020 T4~~，我们可以把转移分成两段。

1、对于一个合法的 $j$，$h_{j+1}\leq \left(\max\limits_{k=j+2}^{i}h_k\right)$，则 $\left(\max\limits_{k=j+1}^{i}h_k\right)=\left(\max\limits_{k=j+2}^{i}h_k\right)$；又因为 $f$ 单调不降，$f_j\leq f_{j+1}$即对于转移 $f_j+\left(\max\limits_{k=j+1}^{i}h_k\right)\leq f_{j+1}+\left(\max\limits_{k=j+2}^{i}h_k\right)$ 。所以此时从 $j$ 转移（$j+1$ 到 $i$ 为一段）比从 $j+1$ 转移更优。

那么此时对于 $h$ 的一个极小值就可能成为转移的最优解。又由于 $h$ 单调不增，所以可以对 $h$ 维护一个单调递减的队列，**队尾**即转移的可能最优点。

2、对于一个合法的 $j$，$h_{j+1}>\left(\max\limits_{k=j+2}^{i}h_k\right)$，可以包含在第一种情况，即我们假设单调队列 $q$，设左右端点 $l,r$，则最优的转移会在 $q_{l,l+1,\dots,r}$ 之中；也即 $h_{q_l}>h_{q_{l+1}}>\dots>h_{r}$ 当中转移 $f_i$（不取等是因为取等的情况一定靠前的更优）。

具体的证明大概是这样的：第一种情况维护的是函数的极小值，其中突出的部分会被包含在两个相邻的极小值当中，但这种转移**对队列中的 $q_l$ 不适用**！

因为这种情况即从 $q_l$ 转移到 $i$，那么 $q_l$ 之前的位置应当为第一个位置 $st$ 使得 $h_i-h_{st}>m$，$f_i$ 就更新为 $f_{st}+h_{ql}$，否则就越界了。

但维护单调队列的时候就可能产生一些意外使得一些值没被更新到。所以可以维护单调栈防止漏掉情况。具体是这样的，对于第二种情况，有可能直接 $h_{j+1}$ 自己作为一段新的段，并包含之后的数，也就会存在一段连续相等的 $f$；或者把之前并作一段，这并不会影响转移。


- 综上，实际上我们需要维护单调下降的一个单调队列，用来维护上式中的 $\max$ 值；然后维护 $f$ 用单调栈，为了保证复杂度可以从队列中点开始向两端维护两个单调下降的栈用于保存 $f$。更新时，如果队列端点超过了原先的中点，可以考虑重构两个单调栈。

> 我们发现，当队列元素越多，重构单调栈的次数也就越多，但总的重构次数也越少（仅在对队列弹出过期元素可能重构）。可以考虑把随机数据拆成几段单调下降的序列，最长的最多是最长下降子序列，假设长度为 $p$。则最多重构 $n/p$ 次，每次最多重构 $p$ 个数，则复杂度最多 $O(n/p·p)=O(n)$。取到最大时，当最长子序列尽量长，也即 $h$ **严格**单调下降。当然并不是严格单调下降就可以取到最大值，还要考虑 $h$ 和 $m$ 之间的关系。

（~~纯属口胡~~）

- 实际上，在随机数据下均摊重构是 $O(n/2)$ 的（可以理解为分治，总的节点数是线性的）。

那么考虑 $h_i$，可以 $st+1\sim i$ 并成一段，$f_i=f_{st}+h_{q_l}$；若单调栈中有值，则可以在其他的 $j>st$ 并成一段 $h\sim i$，取最小即可。

可能有人有疑问这里的第一种情况去哪了？其实在一开始维护第一种情况就直接扔到单调栈里就可以了，反正最后是维护最小的。（根据上文提到的单调性，显然是正确的）

（如果后面想到更好的对单调栈的解释我会回来补充的，~~不过 $noip$ 之后可能就 $AFO$ 了~~）

**综上我们得到了一个 $O(n)$ 的算法。**

## ※代码

~~我知道你们只看这个~~ 

```cpp
/*
BY xiejinhao
2020-11-20 9:19 from XWSF
*/

#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;

int h[N], q[N], stk[2][N];
int top[2], l = 1, mid, r;
long long f[N], tmpf[N];

// stk[0/1]  左/右 栈，指针对应 top[0/1]
// q 队列  h 原数组  tmpf 对应队列中的 f 值 

void push(int x, int i) {
	if(!top[i]) stk[i][++top[i]] = x;
	else if(tmpf[stk[i][top[i]]] > tmpf[x])
		stk[i][++top[i]] = x;
}

void rebuild() {
	mid = (l + r) >> 1, top[0] = top[1] = 0;
	for(int i = mid; i >= l; i--) push(i, 0);
	for(int i = mid + 1; i <= r; i++) push(i, 1);
}

int main() {
	int n, m, st = 1, sum = 0;
	scanf("%d %d", &n, &m);
	for(int i = 1; i <= n; i++) {
		scanf("%d", h + i), sum += h[i];
		while(sum > m) sum -= h[st++];
		while(l <= r and h[q[r]] <= h[i]) {
			if(top[0] and stk[0][top[0]] == r) --top[0];
			if(top[1] and stk[1][top[1]] == r) --top[1];
			if(--r <= mid) rebuild();
		} // 维护单调队列 
		if(l > r) tmpf[r + 1] = f[st - 1] + h[i];
		else tmpf[r + 1] = f[q[r]] + h[i];
		q[++r] = i, push(r, 1);	
		
		// 队头的情况要特判 
		if(stk[0][top[0]] == l) --top[0];
		if(stk[1][top[1]] == l) --top[1];
		while(l <= r and q[l] < st) { 
			if(++l > mid) rebuild();
			// 同样特判队头 
			if(top[0] and stk[0][top[0]] == l) --top[0];
			if(top[1] and stk[1][top[1]] == l) --top[1];
		} // 弹出过期元素 
		
		f[i] = f[st - 1] + h[q[l]]; // 和开头并为一段
		// ---   与开头之后的某个数开始并为一段   --- 
		if(top[0]) f[i] = min(f[i], tmpf[stk[0][top[0]]]);
		if(top[1]) f[i] = min(f[i], tmpf[stk[1][top[1]]]);
	}
	printf("%lld\n", f[n]);
	return 0;
}
```



------------

## ※写在后面

1、**本文同步发布在我的博客园：[点我](https://www.cnblogs.com/Ning-H/p/14010577.html)**

~~2、翻了下提交记录，各位以后抄题解稍微改一下行嘛~~

~~3、能点个赞吗（光速逃~~



---

## 作者：waaadreamer (赞：9)

这道题一看到就知道是一个dp，设dp[i]表示1~i放到书架上的最小代价，

则dp[i]=min{0<j<=i&&sum[i]-sum[j-1]<=m | max{j<=k<=i|height[k]}+dp[j-1]}
显然这个dp是O(n^2)的，一定会超时，于是思考优化。

考虑数据结构：需要能直接读出dp[i]的值，但是由于最大值会随时变动，我们要想办法维护最大值。

注意到每个数字只会对它前面的值的最大值造成影响，于是可以使用单调栈统计每个数最左端可以延伸到哪里，也就是说最多能到哪里使得所有数字都不大于它。

有了单调栈预处理出的延伸值，我们可以使用线段树维护dp。

假设当前计算到i，则每个叶子节点j表示max{j<k<=i|height[k]+dp[j]}，考虑如何更新。

更新有两种，一种是更新叶子节点的dp值，一种是把区间[a,b]的最大值更新为t，也就是把[a,b]全部置为t。

于是，每个节点维护三个值：

1.lazy，标记[a,b]置为t的操作

2.res，如果是叶子节点就是max{j<k<=i|height[k]+dp[j]}，否则就表示所有儿子节点中上述值最小的那个

3.mn，如果是叶子节点就表示叶子节点对应的dp值，否则就表示所有儿子节点中dp值的最小值

于是线段树就可以投入使用了，

对于第一种更新，直接自下而上更新一遍mn值即可；

对于第二种更新，自上而下pushdown，根据dp的递推公式可知res[i]=mn[i]+lazy[i]。

具体如何操作呢？

单调栈预处理之后，由于有dp[0]=0，因此update1(0,0)（表示在0位置将dp值设为0）

然后对于每个i，记单调栈延伸值为k，满足sum[i]-sum[j]<=m的最小的j记为a，

首先update2(k,i,height[i])（表示将区间[k,i)的最大值置为height[i]，注意区间左闭右开！）

然后直接dp[i]=query(a,i)（表示查询区间[a,i)中res的最小值）

最后再update1(i,dp[i])，也就是把i位置的dp值设置一遍。

综上所述，单调栈预处理O(n)，线段树O(nlogn)，因此总复杂度O(nlogn)，可以AC啦。


上我丑丑的代码


```cpp
<cpp>
#include <bits/stdc++.h>
#define INF 0x3f3f3f3f
using namespace std;
typedef long long ll;
const int maxn = 100005, maxt = 262144;
int dp[maxn], high[maxn], sta[maxn], sum[maxn], n, m;
int lazy[maxt], mn[maxt], res[maxt], tn;
inline void pushup(int x){
    int ls = x * 2 + 1, rs = x * 2 + 2;
    mn[x] = min(mn[ls], mn[rs]);
    if(lazy[x] != 0) res[x] = mn[x] + lazy[x];
    else res[x] = min(res[ls], res[rs]);
}
inline void pushdown(int x){
    if(!lazy[x]) return;
    int ls = x * 2 + 1, rs = x * 2 + 2;
    lazy[ls] = lazy[rs] = lazy[x]; lazy[x] = 0;
    res[ls] = lazy[ls] + mn[ls];
    res[rs] = lazy[rs] + mn[rs];
}
void update1(int x, int s){
    x += tn - 1;
    mn[x] = s;
    while(x > 0){
        x = (x - 1) / 2;
        mn[x] = min(mn[x], s);
    }
}
void update2(int a, int b, int x, int l = 0, int r = tn, int k = 0){
    if(a >= r || b <= l) return;
    if(a <= l && b >= r){
        lazy[k] = x;
        res[k] = x + mn[k];
        return;
    }
    pushdown(k);
    update2(a, b, x, l, (l + r) / 2, k * 2 + 1);
    update2(a, b, x, (l + r) / 2, r, k * 2 + 2);
    pushup(k);
}
int query(int a, int b, int l = 0, int r = tn, int k = 0){
    if(a >= r || b <= l) return INF;
    if(a <= l && b >= r) return res[k];
    pushdown(k);
    return min(query(a, b, l, (l + r) / 2, k * 2 + 1),
            query(a, b, (l + r) / 2, r, k * 2 + 2));
}
int main(){
    scanf("%d%d", &n, &m);
    for(tn = 1; tn <= n; tn <<= 1);
    memset(mn, 0x3f, sizeof(mn));
    memset(res, 0x3f, sizeof(res));
    update1(0, 0);
    for(int i = 1, tp = 0, j = 0; i <= n; i++){
        scanf("%d", high + i);
        sum[i] = high[i] + sum[i - 1];
        while(tp > 0 && high[sta[tp - 1]] <= high[i]) tp--;
        while(sum[i] - sum[j] > m) j++;
        int lm = max(j, !tp ? 0 : sta[tp - 1]);
        sta[tp++] = i;
        update2(lm, i, high[i]);
        dp[i] = query(j, i);
        update1(i, dp[i]);
    }
    printf("%d", dp[n]);
    return 0;
}
</cpp>
```

---

## 作者：ListenSnow (赞：6)

## 题意

给出一个长度为 $n$ 的序列 $h$，将 $h$ 分成若干段，满足每段数字之和都不超过 $m$，最小化每段的最大值之和。

## 思路

设 $f[i]$ 表示将序列的前 $i$ 个数分成若干段的最小值。那么可以很容易写出朴素的状态转移方程：

$f[i]=\min_{s[i]-s[j]<=m}(f[j]+\max_{j<k \leq i} h_k)$。其中 $s[i]$ 表示序列 $h$ 的前缀和。

时间复杂度接近 $O(n^2)$，考虑优化。

显然可以用二分查找在 $O(\log n)$ 的时间里求出 $\min j$。那么转移方程就变成了在一个区间内求最小值。

可以发现，对于每一个 $f[i]$，随着 $j$ 增大，$f[j]$ 非严格单调递增，$\max h_k$ 非严格单调递减。而随着 $i$ 增大，$f[j]$ 的值显然都不会改变，而 $\max h_k$ 依旧具有单调性。设 $pre[i]$ 表示 $h_i$ 左边第一个比他大的数的下标。可以用单调栈在 $O(n)$ 时间内预处理出来。每新插入一个 $h_i$，$[pre[i]+1,i]$ 这段区间内的 $\max h$ 就会被修改成 $h_i$。

于是本题可以优化的地方就是区间修改和区间查询最值。那么就可以用线段树来维护 $f_j+\max h$。同时注意到只需要修改 $\max h$，那么就可以直接将 $\max h$ 类似于懒标记来维护。同时也需要记录两个数的和。防止出错，也方便上传。

还有一些细节见代码。

## code：

```cpp
#include<cstdio>
using namespace std;
const int N=1e5+10;
#define int long long
const int INF=1e15+10;
struct tree{
	int l,r,mid;
	int f,h,val;//同时也需要记录f的信息，方便区间修改 
}tr[N<<2]; 
long long s[N];
int min(int a,int b){return a<b?a:b;}
int f[N],h[N],n,m;
void push_up(int p)
{
    tr[p].val=min(tr[p<<1].val,tr[p<<1|1].val);
    tr[p].f=min(tr[p<<1].f,tr[p<<1|1].f);
}
void build_tree(int p,int l,int r)
{
	tr[p].l=l,tr[p].r=r,tr[p].mid=(l+r)>>1;
	if(l==r)
	{
		tr[p].val=INF;//因为求最小值，就赋值成无穷大防止出错 
		return ;
	}
	build_tree(p<<1,tr[p].l,tr[p].mid);
	build_tree(p<<1|1,tr[p].mid+1,tr[p].r);
	push_up(p);
}
void push_down(int p)
{
	if(tr[p].h)
	{
		tr[p<<1].val=tr[p<<1].f+tr[p].h;
		tr[p<<1|1].val=tr[p<<1|1].f+tr[p].h;
		tr[p<<1].h=tr[p<<1|1].h=tr[p].h;
		tr[p].h=0;
	}
}
void updata(int p,int l,int r,int h)
{
	if(l<=tr[p].l&&tr[p].r<=r)
	{
		tr[p].h=h;
		tr[p].val=tr[p].f+h;
		return ;
	}
	push_down(p);
	if(l<=tr[p].mid) updata(p<<1,l,r,h);
	if(r>tr[p].mid) updata(p<<1|1,l,r,h);
	push_up(p);
}
void insert(int p,int pos,int f)
{
	if(tr[p].l==tr[p].r)
	{
		tr[p].f=f;
		return ;
	}
	push_down(p);
	if(pos<=tr[p].mid) insert(p<<1,pos,f);
	else insert(p<<1|1,pos,f);
	push_up(p);
}
int query(int p,int l,int r)
{
	if(l<=tr[p].l&&tr[p].r<=r) return tr[p].val;
	push_down(p);
	int res=INF;
	if(l<=tr[p].mid) res=min(res,query(p<<1,l,r));
	if(r>tr[p].mid) res=min(res,query(p<<1|1,l,r));
	return res;
}
int pre[N];
int stk[N],top;
signed main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++) scanf("%lld",&h[i]),s[i]=s[i-1]+h[i];
	build_tree(1,1,n);
	h[0]=INF;
	for(int i=n;i>=0;i--)
	{
		while(top&&h[i]>h[stk[top]]) pre[stk[top--]]=i;
		stk[++top]=i;
	}
	for(int i=1;i<=n;i++)
	{
		insert(1,i,f[i-1]);//线段树上的第 i 个点的含义是当前这一段以第i个点为左端点，所以存储的信息室f[i-1] 
		int l=0,r=i;
		while(l<r)
		{
			int mid=l+r>>1;
			if(s[i]-m<=s[mid]) r=mid;
			else  l=mid+1;
		}
		updata(1,pre[i]+1,i,h[i]);
		f[i]=query(1,l+1,i); 
	}
	printf("%lld\n",f[n]);
	return 0;
}
/*
6 6
3 5 1 2 4 1
*/ 
```


---

## 作者：critnos (赞：4)

来一发好想的题解？（

转移方程很好推，是

$$dp_i =\min (dp_{j-1}+\max_{k=j}^i h_k(1\le j,\sum_{k=j}^i h_k\le m))$$

因为这个 $h_i$ 都是正整数，所以 $j$ 只能在 $[p,i]$ 范围内，$p$ 可以通过简单二分得到。

然后猜测这个 $\max_{k=j}^i h_k$ 的取值可能比较少，因为是单调的所以也可以二分出每个取值的左右端点，这里可以套一个 ST 表。

关于他的取值个数，不妨从考虑 hack 的方面入手：

为了让取值尽量多，肯定构造一组递减的序列，这是最优的。因为这样既能让不同的值达到上界，又能让和尽量小。尽管如此，根据等差数列求和的经验我们依然发现这样构造的序列长度是 $O(\sqrt m)$ 级别的，也就是说不同的取值个数最多是 $O(\sqrt m)$ 个。

对于每一段分别转移，设这一段的 $h$ 的最大值为 $maxh$，再把它提出来，转移方程就变成了

$$dp_i =\min (dp_{j-1})+maxh$$

这样就可以再用一个 ST 表维护了，要使用一个 trick 就是动态从末尾 add 的 ST 表。

总复杂度 $O(n\sqrt m \log n)$，当然这是上界，期望时间复杂度是 $O(n \log^2 n)$，自证不难。

~~暴力期望复杂度还 $O(n)$ 呢~~

---

## 作者：f_hxr_ (赞：3)

在题解区转了一圈，发现仅有几篇题解提到了这个可以用 CDQ 分治做。如果再算上[双倍经验](https://www.luogu.com.cn/problem/P1848)和[三倍经验](https://www.luogu.com.cn/problem/P10977)的题解区，一篇 CDQ 分治的题解都没有，待遇比[幸运猫猫树](https://www.luogu.com.cn/article/ep96b7xi)还糟糕！

~~虽然最劣解~~但是 CDQ 分治她好想啊~~我不会线段树对不起拜线段树教~~，名字还这么好听怎么你了。

像其他题解一样，我们设 $f_i$ 表示划分前 $i$ 个数的最小代价。顺便把 $h_i$ 做前缀变 $sum_i$。我们枚举上一段在哪里结束，就有：

$$ f_i = \min_{sum_i-sum_j \le M}\left \{ f_j+\max_{j+1\le k\le i}h_k  \right \}  $$

当然，上式还有一个隐含条件 $i>j$。还有这个 $j$ 也是可以取到 $0$ 的。

将 $sum_i-sum_j \le M$ 移项，就是 $sum_i-M\le sum_j$。再算上 $i>j$，很容易想到用 CDQ 分治处理这两个偏序条件。如果我们能用数据结构之类的方法将花括号里面的 $\max$ 处理掉，这道题就做完了。

先考虑在 CDQ 内部如何转移。设分治区间左端点为 $L$，右端点为 $R$。我们按中点把区间分开后将其分别按 $sum$ 升序排序。使用双指针就可以解决两个偏序限制。

接下来考虑如何处理最大值的那部分。注意到最大值部分所对应的区间**一定经过中点**，所以该区间的最大值要么来自**左半部分，要么来自右半部分。**

我们从中间向两边分别弄个后缀最大值和前缀最大值。左半的后缀最大值叫 $lmx_i$，右半的前缀最大值叫 $rmx_i$。

开两棵权值线段树 $A$ 和 $B$。对于左半部分，每扫到一个点 $i$，就把 $f_i$ 和 $f_i+lmx_{i+1}$ 分别打 $A$ 和 $B$ 的下标 $lmx_{i+1}$ 上。对于右半部分，每扫到一个点 $i$，就考虑转移的最大值来自左半边还是右半边。如果来自左半边，就在 $B$ 里查找比 $rmx_i$ 大的值域；如果来右自半边，就在 $A$ 里查找比 $rmx_i$ 小的值域。这样这道题就做完了。

我知道你要说什么，上面有个 $lmx_{i+1}$，那要是左半边扫到中点不就炸了吗。不用担心兄弟，注意到扫到中点意味着整个区间都在右半边，也就是最值在右半边，所以此时只要令 $lmx_{i+1}$ 为 $-inf$ 即可。

这样我们就真的做完这道题了。

注意开 `long long` 和离散化。

话说权值线段树是不是可以改成树状树祖？

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int maxn=1e5+7;
const LL inf=0x7f7f7f7f7f7f7f7f;
int N;
LL M;
LL a[maxn],sum[maxn],f[maxn];
LL un[maxn];
int UN;
#define get(xx) (lower_bound(un+1,un+UN+1,(xx))-un)
//单点修改，区间查询 
struct SegmentTree{
	LL mn[maxn<<2];
	SegmentTree(){memset(mn,0x7f,sizeof(mn));}
	void Modify(int p,int L,int R,int inx,LL xx){
		if(L>=R){mn[p]=min(mn[p],xx);return;}
		int mid=(L+R)>>1;
		if(inx<=mid)Modify(p<<1,L,mid,inx,xx);
		else Modify(p<<1|1,mid+1,R,inx,xx);
		mn[p]=min(mn[p<<1],mn[p<<1|1]);
	}
	void Set(int p,int L,int R,int inx,LL xx){
		if(L>=R){mn[p]=xx;return;}
		int mid=(L+R)>>1;
		if(inx<=mid)Set(p<<1,L,mid,inx,xx);
		else Set(p<<1|1,mid+1,R,inx,xx);
		mn[p]=min(mn[p<<1],mn[p<<1|1]);
	}
	LL Query(int p,int L,int R,int ql,int qr){
		if(ql<=L&&R<=qr)return mn[p];
		int mid=(L+R)>>1;
		LL ret=inf;
		if(ql<=mid)ret=min(ret,Query(p<<1,L,mid,ql,qr));
		if(mid+1<=qr)ret=min(ret,Query(p<<1|1,mid+1,R,ql,qr));
		return ret;
	}
}SEG1,SEG2;
//带max，不带max
struct OP{int inx;LL val;}O[maxn];
bool cmp(OP A,OP B){return A.val>B.val;}
bool cmpid(OP A,OP B){return A.inx<B.inx;}
LL lmx[maxn],rmx[maxn];
void CDQ(int L,int R){
	if(L>=R)return;
	int mid=(L+R)>>1;
	CDQ(L,mid);
	sort(O+L,O+mid+1,cmp);
	sort(O+mid+1,O+R+1,cmp);
	lmx[mid+1]=-inf;
	for(int i=mid;i>=L;i--)lmx[i]=max(lmx[i+1],a[i]);
	rmx[mid]=-inf;
	for(int i=mid+1;i<=R;i++)rmx[i]=max(rmx[i-1],a[i]);
	int p=L;
	for(int i=mid+1;i<=R;i++){
		while(p<=mid&&O[p].val>=O[i].val-M){
			SEG1.Modify(1,1,UN,get(lmx[O[p].inx+1]),f[O[p].inx]+lmx[O[p].inx+1]);
			SEG2.Modify(1,1,UN,get(lmx[O[p].inx+1]),f[O[p].inx]);
			++p;
		}
		LL res=inf;
		res=min(res,SEG1.Query(1,1,UN,get(rmx[O[i].inx])+1,UN));
		res=min(res,SEG2.Query(1,1,UN,1,get(rmx[O[i].inx]))+rmx[O[i].inx]);
		f[O[i].inx]=min(f[O[i].inx],res);
	}
	while(p>L){
		--p;
		SEG1.Set(1,1,UN,get(lmx[O[p].inx+1]),inf);
		SEG2.Set(1,1,UN,get(lmx[O[p].inx+1]),inf);
	}
	sort(O+mid+1,O+R+1,cmpid);
	CDQ(mid+1,R);
}
int main(){
	scanf("%d %lld",&N,&M);
	for(int i=1;i<=N;i++)scanf("%lld",&a[i]),sum[i]=sum[i-1]+a[i],un[++UN]=a[i];
	un[++UN]=-inf;un[++UN]=inf;
	sort(un+1,un+UN+1);UN=unique(un+1,un+UN+1)-un-1;
	memset(f,0x7f,sizeof(f));
	f[0]=0;
	for(int i=0;i<=N;i++)O[i].inx=i,O[i].val=sum[i];
	CDQ(0,N);
	printf("%lld",f[N]);
	return 0;
}
```

---

## 作者：红尘仙 (赞：3)



### 【杂言】：

学长讲的题，算是做个解题报告。

如果只是按照30分的打法的话，可以拿到60分，那么按理成章，如果我开$O_2$呢？好家伙，卡过去了,代码在后面放

### 【状态设计】：
我们设$f_{i}$表示已经放好了i本书的最优解
### 【状态转移】：
首先这个状态转移方程是很好推得。
$f_{i} = f_{j-1} + \max\limits_{sum_{i}-sum_{j} \leq m} h_{k}$其中$k \in [i,j]$,那么你就拿到了60分的高分 ~~，恭喜~~
### 【优化】：
真的，很神奇，考场上打完跑就行了，$DP$的优化真的挺……（好）

我们发现，我们所求解的就是$max\ h_i$,那么我们发现我们取的得$h_i$一定不会增加，也就是说，$h_i$一定会递减（非严格）

我们在取得$h_i$的时候反正就那一个区间，取得的便肯定不会是增加的了；

同时我们也发现，f_{i-1}是单调不降的。

那么怎么优化？

我选用线段树优化，因为我的单调队列……~~（很好，练一下线段树~~,

在上面的代码中，对于每一次的找到$h_{max}$的时候都进行了$j \ -> \ i $进行了枚举，我们用线段树在这里进行修改。那么也就是说，用线段树去维护$h_{max}$就好了

同时，对于$f_{i-1}$的查询，就用区间查询取最小值即可

### 【代码实现】：

1.预处理

2.建树

3.询问最小值（$f_{i}$）

4.更新，也就是加上$h_{max}$

5.单点修改。更新$f_j$

6.$return \ 0$

### 【code】
```
/*
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define ll long long
#define N 100010
using namespace std;
const int mod = 1e9 + 7;
const int inf = 0x3f3f3f3f;
int f[N], a[N], n, m;
ll sum[N];
inline int read() 
{
  char c = getchar(); int x = 0, f = 1;
  for ( ; !isdigit(c); c = getchar()) if (c == '-') f = -1;
  for ( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
  return x * f;
}
signed main() 
{
  n = read(), m = read();
  for (int i = 1; i <= n; i++) 
    a[i] = read(), sum[i] = sum[i - 1] +  a[i];
  	memset(f, inf, sizeof(f));
	f[0] = 0;
   for (int i = 1; i <= n; i++) 
   {
    int maxn = -1;
    for (int k = i; k >= 1; k--) 
	{
      maxn = max(maxn, a[k]);
      if (sum[i] - sum[k - 1] <= m) 
      {
        f[i] = min(f[i], f[k - 1] + maxn); 	
	  }
      else break;
    }
  }
  cout << f[n] ;
  return 0;
}

*/
这是没有优化的，下面是线段树优化了的
上方为我学长 灵乌路空，他给我们讲的这道题，还是_Desnity用他题解给我们讲的题，反正差不多了，神似
#include <iostream>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <algorithm>
#define int long long
using namespace std;
const int maxn = 1e5+10;
const long long inf = 1e10;
inline int read()
{
	int x=0,f=1;char ch = getchar();
	while(!isdigit(ch)) { if(ch == '-') f = -1 ;ch = getchar();}
	while(isdigit(ch)) { x = x * 10 + ch - '0' ;ch = getchar(); }
	return x * f;
}
struct Tree
{
	int left,right,f,ans,flag;
}tree[maxn<<2];
int h[maxn],n,m;
int f[maxn],sum[maxn];
int sta[maxn],pre[maxn],top; 
void pushup(int now)
{
	tree[now].f = min(tree[now<<1].f,tree[now<<1|1].f);
	tree[now].ans = min(tree[now<<1].ans,tree[now<<1|1].ans);	
}
void pushdown(int now)
{
	tree[now<<1].ans = tree[now<<1].f + tree[now].flag;
	tree[now<<1|1].ans = tree[now<<1|1].f + tree[now].flag;
	tree[now<<1].flag = tree[now<<1|1].flag = tree[now].flag;
	tree[now].flag = inf;
}
void build(int now,int left ,int right)
{
	tree[now].left = left ;
	tree[now].right = right;
	if(left == right)
	{
		tree[now].f = tree[now].ans = tree[now].flag = inf;
		return ;
	}
	int mid = left + right >> 1;
	build(now<<1 , left , mid);
	build(now<<1|1 , mid+1 , right);
	pushup(now);
} 
int query(int now,int left,int right)
{
	if(tree[now].left >= left && tree[now].right <=right)
	{
		return tree[now].ans;
	}
	if(tree[now].flag != inf)
	{
		pushdown(now);
	}
	int mid = tree[now].left + tree[now].right >> 1;
	int ret = inf ;
	if(left <= mid)
	{
		ret = min(ret , query(now<<1,left,right));	
	}
	if(mid < right)
	{
		ret = min(ret , query(now<<1|1,left,right));
	}
	return ret ;
}
void updata(int now,int left,int right,int val)
{
	if(tree[now].left >= left &&tree[now].right <= right)
	{
		tree[now].ans = tree[now].f + val ;
		tree[now].flag = val ;
		return ;
	}
	if(tree[now].flag != inf)
	{
		pushdown(now);
	}
	int mid = tree[now].left + tree[now].right >> 1;
	if(left <= mid)
	{
		updata(now<<1,left,right,val);
	}
	if(mid < right)
	{
		updata(now<<1|1,left,right,val);
	}
	pushup(now);
}
void modify(int now,int pos)
{
	if(tree[now].left == tree[now].right)
	{
		tree[now].ans = inf;
		tree[now].f = f[pos - 1] ;
		return ;
	}
	if(tree[now].flag != inf) 
	{
		pushdown(now);
	}
	int mid = tree[now].left + tree[now].right >> 1;
	if(pos <= mid)
	{
		modify(now<<1,pos);
	}
	else 
	{
		modify(now<<1|1,pos);
	}
	pushup(now);
}
signed main()
{
	n = read() , m = read() ;
	for(int i = 1 ; i <= n ; i++)
	{
		h[i] = read();
		sum[i] = sum[i-1] + h[i];
	}
	sta[++top] = 1;
	for(int i = 2 ; i <= n ; i++)
	{
		while(top &&h[sta[top]] < h[i]) top --;
		if(top) pre[i] = sta[top];
		sta[++top] = i;
	}
	build(1,1,n);
	for(int i = 1 ; i <= n ; i++)
	{
		modify(1,i);
		if(pre[i] < i)
		{
			updata(1 , pre[i]+1 , i , h[i]);
		}
		int l = lower_bound(sum , sum + i + 1,sum[i] - m) - sum; 
		if(l < i)
		{
			f[i] = query(1,l + 1, i);
		}
	}
	printf("%lld",f[n]);
	return 0;
} 
```


---

## 作者：nianheng (赞：2)

### 线段树+二分

（数据范围只有1e5，为何不直接用线段树愉快地莽过去呢qwq

首先分析题意，得到DP方程
$$
f_i=min(f_{j-1}+max(h_j\sim h_i))\ \ (sum_{j\sim i}\le m)
$$
用线段树存$zn_j=f_{j-1}+max(h_j\sim h_i))$，求$f_i$直接区间最小值就行了

考虑怎么在线段树上维护$zn$的值

线段树上每个节点存这个区间$zn$的最小值，$h$的最大值以及$f$的最大值

每当$i$向右移动一位，先考虑合法区间的左端点会不会因为$sum_{j\sim i}>m$向右移动。然后因为右端加入了个$h_i$导致一些$j$的$max(h_j\sim h_i)$变大，可以发现从 最靠右的 满足$h_j\ge h_i$的位置往右，这个值都会变为$h_i$，可以二分找出那个位置然后在线段树上区间修改$h$的值。最后别忘了把$zn_{i+1}$赋值为$f_i+h_{i+1}$。

代码写起来也非常简单

```cpp
#include<map>
#include<cmath>
#include<ctime>
#include<queue>
#include<vector>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define qmin(x,y) (x=min(x,y))
#define qmax(x,y) (x=max(x,y))
#define mp(x,y) make_pair(x,y)
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
inline int read(){
	int ans=0,fh=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') fh=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
		ans=ans*10+ch-'0',ch=getchar();
	return ans*fh;
}
const int maxn=1e5+100;
const int inf=0x7fffffff;
int n,m,h[maxn],zn[maxn<<2],fn[maxn<<2],hx[maxn<<2],lz[maxn<<2];
#define lc (o<<1)
#define rc (o<<1|1)
inline void paint(int o,int z){
	hx[o]=z,zn[o]=fn[o]+z,lz[o]=z;
}
inline void pushdown(int o){
	if(!lz[o]) return;
	paint(lc,lz[o]),paint(rc,lz[o]),lz[o]=0;
}
inline void updata(int o){
	fn[o]=min(fn[lc],fn[rc]);
	hx[o]=max(hx[lc],hx[rc]);
	zn[o]=min(zn[lc],zn[rc]);
}
inline void revise(int o,int l,int r,int ql,int qr,int qz){
	if(ql==l&&qr==r){paint(o,qz);return;}
	int mid=l+r>>1;pushdown(o);
	if(ql<=mid) revise(lc,l,mid,ql,min(qr,mid),qz);
	if(qr> mid) revise(rc,mid+1,r,max(ql,mid+1),qr,qz);
	updata(o);
}
inline int gethx(int o,int l,int r,int ql,int qr){
	if(ql==l&&qr==r) return hx[o];
	int mid=l+r>>1,Ans=0;pushdown(o);
	if(ql<=mid) qmax(Ans,gethx(lc,l,mid,ql,min(qr,mid)));
	if(qr> mid) qmax(Ans,gethx(rc,mid+1,r,max(ql,mid+1),qr));
	return Ans;
}
inline int getzn(int o,int l,int r,int ql,int qr){
	if(ql==l&&qr==r) return zn[o];
	int mid=l+r>>1,Ans=inf;pushdown(o);
	if(ql<=mid) qmin(Ans,getzn(lc,l,mid,ql,min(qr,mid)));
	if(qr> mid) qmin(Ans,getzn(rc,mid+1,r,max(ql,mid+1),qr));
	return Ans;
}
inline void insert(int o,int l,int r,int qd,int qf,int qh){
	if(l==r){fn[o]=qf,hx[o]=qh,zn[o]=qf+qh;return;}
	int mid=l+r>>1;pushdown(o);
	if(qd<=mid) insert(lc,l,mid,qd,qf,qh);
	else insert(rc,mid+1,r,qd,qf,qh);
	updata(o);
}
inline int getlx(int l,int r,int z){
	int Ans=r+1,R=r;r++;
	while(l<r){
		int mid=l+r>>1;
		if(gethx(1,1,n,mid,R)<z)//如果区间h最大值小于h_i的话 
			Ans=r=mid;
		else l=mid+1;
	}
	return Ans;
}
int main(){
//	freopen("nh.in","r",stdin);
//	freopen("zhy.out","w",stdout);
	n=read(),m=read();
	for(int i=1;i<=n;i++) h[i]=read();
	int sum=0;insert(1,1,n,1,0,h[1]);
	for(int l=1,r=1;r<=n;r++){
		sum+=h[r];while(sum>m) sum-=h[l++];//判断左端点是否应该右移 
		int x=getlx(l,r-1,h[r]);//二分找到满足h_j>h_i的最右的j 
		if(x<r) revise(1,1,n,x,r-1,h[r]);//将它们的h统一修改为h_i 
		int fr=getzn(1,1,n,l,r);//求出f_i 
		if(r==n) printf("%d\n",fr);//输出 
		else insert(1,1,n,r+1,fr,h[r+1]);//zn_{i+1}=f_i+h_{i+1} 
	}
	return 0;
}












```


---

## 作者：djh0314 (赞：1)

[**传送门**](https://www.luogu.com.cn/problem/P1295)

## 题意
给出一个长度为 $n$ 的序列 $h$，请将 $h$ 分成若干段，满足每段数字之和都不超过 $m$，最小化每段的最大值之和。
(~~~实际上就是简化题意~~~)。

## 分析
这是一个区间划分问题，自然可以想到使用 DP 解决此题。

### 切分（$n\le10^3$）

写这种题毕竟要从暴力打起，我们用 $n^2$ 解决这个 30 分。

~~~
f[0]=0;
for(int i=1; i<=n; ++i) {
	int mx=0;
	f[i]=INF;
	for(int j=i; j; --j) {
		if(qzh[i]-qzh[j-1]>m) break;
		mx=max(mx,a[j]);
		f[i]=min(f[i],f[j-1]+mx);
	}
}
~~~

时间复杂度：$O(n^2)$。

虽然切的是 30 分，但是却可以拿到 56 分，在开了 O2 后还可以拿到 77 分的高分，（~~如果是比赛已经可以放弃了~~）。                 

## 正解 

我们显然是要优化内层的循环。     
动态规划的一个重点就是继承，           
令当前需要处理的节点为 $i$，
我们令 $\mathit{g}_{i,j} =f_{j-1}+ \max_{k=j}^{k \le i}a_k$，           
显然 $f_i=\max_{j=1}^{j\le i} \mathit{g}_{i,j} (qzh_i-qzh_j\le m  )$。

接下来就是解决在 $\mathit{g}_{i,j}$ 的转移，对于其转移，只会修改后面的 $\max_{k=j}^{k \le i}a_k$，多了一个 $a_i$，那么假如说 $a_i$ 小于原本的，那么 $\mathit{g}_{i,j}$ 就不变。              
我们仔细观察 $\max_{k=j}^{k \le i}a_k$ 的变化，我们可以发现，我们的 $\max_{k=j}^{k \le i}a_k$ 是单调不增的，是如同阶梯状的。          
这也就表示，我们的 $\mathit{g}_{i,j}$ 是可以用区间修改的。

归纳一下，我们想要实现：区间的查询维护答案，区间修改维护 $g$ 数组。显然啊，我们用线段树来优化我们的 DP。                      

为了维护最大值的变化，我们使用一个单调递减的单调栈，这样我们可以实现阶梯型的修改了。
~~~cpp
tree.build(1,1,n+1);
f[0]=0;
tree.change(1,1,n+1,1,a[1]);
int it=1;
for(int i=1; i<=n; ++i) {
	while(top&&a[st[top]]<=a[i]) {
		tree.change(1,1,n+1,st[top-1]+1,st[top],a[i]-a[st[top]]);
		--top;
	}
	while(it<=i&&qzh[i]-qzh[it-1]>m) ++it;
	st[++top]=i;
	f[i]=tree.query(1,1,n+1,it,i);
	tree.change(1,1,n+1,i+1,f[i]+a[i+1]);
}
cout<<f[n];	
~~~
时间复杂度：$O(n\log n)$。

### 总结一下，我们这道题考验了我们动态规划的优化，与单调栈维护最值的作用。

---

## 作者：SamHJD (赞：1)

# [P1295 [TJOI2011] 书架](https://www.luogu.com.cn/problem/P1295#submit)

## $\text{Solution 1}$

设 $f_i$ 表示前 $i$ 本书的答案。则 $f_i$ 可以从 $f_{1\dots i-1}$ 转移，式子很好推。


$$f_i=\min(f_{k-1}+\max \{h_{k\dots i}|k<i,\sum_{j=k}^{i}h_j\le m\})$$

那么我们就得到了 $O(n^2)$ 的做法，外层循环 $i$，内层循环 $k$ 即可。

## $\text{Solution 2}$

考虑对上面的 $\text{dp}$ 进行优化。

我们转移 $f_i$ 时需要两个量：$f_{k-1}$ 和 $\max\{h_{k\dots i}\}$。计算完 $f_k$ 后其值肯定不变，可以直接记录，但是 $\max\{h_{k\dots i}\}$ 可能会有变化。

在枚举到 $i$ 时，考虑 $h_i$ 可能对 $\max\{h_{k\dots i}\}$ 产生什么影响。设 $next_i$ 表示 $i$ 前大于等于 $h_i$ 的第一个数，则 $\max\{h_{k\dots i}|k>next_i\}$ 都会更新成 $i$。

在计算过程中我们先不看 $i$，则当前的所有 $\max\{h_{k\dots i}\}$ 可以看作一个一维数组，根据 $next_i$ 区间修改这个数组，想到线段树。

具体的，线段树需要维护两个量，$f_{k-1}$ 和 $f_{k-1}+\max\{h_{k\dots i}\}$ 的最小值。

我们每枚举一个点，先在线段树中根据计算好的 $f_{i-1}$ 更新，然后将 $\max\{h_{k\dots i}|k>next_i\}$ 的最大值更新，注意在代码中直接更新为 $f_{k-1}+\max\{h_{k\dots i}\}$。最后二分得出左端点 $l(\sum_l^i h_i>m,\sum_{l+1}^i h_i\le m)$，查询 $l+1\dots i$ 的 $f_k+\max\{h_{k\dots i}\}$ 最小值即可。

## $\text{Code}$

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ls p*2
#define rs p*2+1
using namespace std;
const ll N=1e5+10,INF=1e18;
ll n,m,nex[N];
ll q[N],f[N],h[N];
ll cmin(ll a,ll b){return a<b?a:b;}
struct node{
    ll l,r;
    ll f,ans,tag;
};
struct Seg_Tree{//线段数板子
    node t[N*4];
    void pushup(ll p){
        t[p].f=cmin(t[ls].f,t[rs].f);//f是区间内f[k-1]的最小值。、
        t[p].ans=cmin(t[ls].ans,t[rs].ans);//ans是区间内f[k-1]+max(h)的最小值
    }
    void lazy(ll p,ll k){
        t[p].ans=t[p].f+k;
        t[p].tag=k;
    }
    void pushdown(int p){
        lazy(ls,t[p].tag);
        lazy(rs,t[p].tag);
        t[p].tag=INF;
    }
    void build(int p,int l,int r){
        t[p].f=INF;t[p].ans=INF;t[p].tag=INF;
        t[p].l=l;t[p].r=r;
        int mid=(l+r)>>1;
        if(l==r) return;
        build(ls,l,mid);
        build(rs,mid+1,r);
        pushup(p);
    }
    void upd(int p,int nl,int nr,ll k){
        if(nl<=t[p].l&&t[p].r<=nr){
            lazy(p,k);
            return;
        }
        if(t[p].tag!=INF) pushdown(p);
        int mid=(t[p].l+t[p].r)>>1;
        if(nl<=mid) upd(ls,nl,nr,k);
        if(nr>mid) upd(rs,nl,nr,k);
        pushup(p);
    }
    void ptupd(int p,int x){//单点更新f[i-1]
        if(t[p].l==t[p].r){
            t[p].ans=1e9;
            t[p].f=f[x-1];
            return;
        }
        int mid=(t[p].l+t[p].r)>>1;
        if(t[p].tag!=INF) pushdown(p);
        if(x<=mid) ptupd(ls,x);
        else ptupd(rs,x);
        pushup(p);
    }
    ll query(int p,int nl,int nr){
        if(nl<=t[p].l&&t[p].r<=nr) return t[p].ans;
        ll res=INF;
        if(t[p].tag!=INF) pushdown(p);
        int mid=(t[p].l+t[p].r)>>1;
        if(nl<=mid) res=cmin(res,query(ls,nl,nr));
        if(nr>mid) res=cmin(res,query(rs,nl,nr));
        return res;
    }
}t;
int main(){
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=n;++i) scanf("%lld",&h[i]),q[i]=q[i-1]+h[i];
    stack<int> st;
    st.push(1);
    for(int i=2;i<=n;++i){
        while(!st.empty() && h[i]>h[st.top()]) st.pop();
        if(!st.empty()) nex[i]=st.top();
        st.push(i);
    }
    t.build(1,1,n);
    for(int i=1;i<=n;++i){
        t.ptupd(1,i);
        if(nex[i]<i) t.upd(1,nex[i]+1,i,h[i]);
        ll l=1,r=i;
        while(l<=r){//找左端点
            int mid=(l+r)>>1;
            if(q[i]-q[mid-1]>m) l=mid+1;
            else r=mid-1;
        }
        if(l<=i) f[i]=t.query(1,l,i);
    }
    printf("%lld",f[n]);
    return 0;
}
```

答案和 $f$ 的初始值不能设为 $\text{int}$ 最大值，要设到 $\text{long long}$，否则你会被第 $11$ 个点卡。

另外不要像我一样写成 ```const int INF=1e18;```

---

## 作者：orz_z (赞：1)



[原题传送门](https://www.luogu.com.cn/problem/P1295)

### 题目大意
给出一个长度为 $n$ 的序列 $h$，请将 $h$ 分成若干段，满足每段数字之和都不超过 $m$，最小化每段的最大值之和。

### 解题思路
首先分析题意，得到动态转移方程：

$$f_i=min(f_{j-1}+max(h_j\sim h_i))\ \ (\sum\limits_{k=j}^i h_k\leq m)$$

用线段树存 $z_j=f_{j-1}+max(h_j\sim h_i))$。

求$f_i$ 直接区间最小值就行了。

考虑怎么在线段树上维护 $z$ 的值。

线段树上每个节点存这个区间 $z$ 的最小值，$h$ 的最大值以及 $f$ 的最大值。

每当 $i$ 向右移动一位，先考虑合法区间的左端点会不会因为 $\sum\limits_{k=j}^i h_k>m$ 向右移动。

然后因为右端加入了个 $h_i$ ，可以发现在区间 $[j,i]$ 里，从最靠左的满足 $h_x\le h_i$ 的位置 $x$ ，区间 $[x,i-1]$ 的 $h$ 都会变为 $h_i$，可以二分找出那个位置然后在线段树上区间修改 $h$ 的值。

最后别忘了把插入新的 $z$ ，$f$ 和 $h$ 。

### AC CODE
```cpp
#include <bits/stdc++.h>
#define _ 100005
using namespace std;

int n, m;
int sum;
int a[_];

inline int read()
{
    int ans = 0, fh = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
            fh = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
        ans = ans * 10 + ch - '0', ch = getchar();
    return ans * fh;
}

struct Tree
{
    int z, f, h, lazy;
} tr[_ << 2];

void push_up(int o)
{
    tr[o].h = max(tr[o << 1].h, tr[o << 1 | 1].h);
    tr[o].f = min(tr[o << 1].f, tr[o << 1 | 1].f);
    tr[o].z = min(tr[o << 1].z, tr[o << 1 | 1].z);
}

void push_down(int o)
{
    if (tr[o].lazy)
    {
        tr[o << 1].h = tr[o].lazy;
        tr[o << 1].z = tr[o << 1].f + tr[o].lazy;
        tr[o << 1].lazy = tr[o].lazy;
        tr[o << 1 | 1].h = tr[o].lazy;
        tr[o << 1 | 1].z = tr[o << 1 | 1].f + tr[o].lazy;
        tr[o << 1 | 1].lazy = tr[o].lazy;
        tr[o].lazy = 0;
    }
}

inline void insert(int o, int l, int r, int d, int qf, int qh)
{
    if (l == r)
    {
        tr[o].f = qf;
        tr[o].h = qh;
        tr[o].z = qf + qh;
        return;
    }
    int mid = (l + r) >> 1;
    push_down(o);
    if (d <= mid)
        insert(o << 1, l, mid, d, qf, qh);
    else
        insert(o << 1 | 1, mid + 1, r, d, qf, qh);
    push_up(o);
}

inline void revise(int o, int l, int r, int ql, int qr, int qz)
{
    if (ql <= l && qr >= r)
    {
        tr[o].h = qz;
        tr[o].z = tr[o].f + qz;
        tr[o].lazy = qz;
        return;
    }
    int mid = (l + r) >> 1;
    push_down(o);
    if (ql <= mid)
        revise(o << 1, l, mid, ql, qr, qz);
    if (qr > mid)
        revise(o << 1 | 1, mid + 1, r, ql, qr, qz);
    push_up(o);
}

inline int geth(int o, int l, int r, int ql, int qr)
{
    if (ql <= l && qr >= r)
        return tr[o].h;
    int mid = (l + r) >> 1;
    int Ans = 0;
    push_down(o);
    if (ql <= mid)
        Ans = max(Ans, geth(o << 1, l, mid, ql, qr));
    if (qr > mid)
        Ans = max(Ans, geth(o << 1 | 1, mid + 1, r, ql, qr));
    return Ans;
}

inline int getz(int o, int l, int r, int ql, int qr)
{
    if (ql <= l && qr >= r)
        return tr[o].z;
    int mid = (l + r) >> 1;
    int Ans = INT_MAX;
    push_down(o);
    if (ql <= mid)
        Ans = min(Ans, getz(o << 1, l, mid, ql, qr));
    if (qr > mid)
        Ans = min(Ans, getz(o << 1 | 1, mid + 1, r, ql, qr));
    return Ans;
}

inline int getl(int l, int r, int z)
{
    int Ans = r + 1;
    int R = r;
    r++;
    while (l < r)
    {
        int mid = (l + r) >> 1;
        if (geth(1, 1, n, mid, R) < z)
            Ans = r = mid;
        else
            l = mid + 1;
    }
    return Ans;
}

signed main()
{
    n = read();
    m = read();
    for (int i = 1; i <= n; i++)
        a[i] = read();
    insert(1, 1, n, 1, 0, a[1]);
    for (int l = 1, r = 1; r <= n; r++)
    {
        sum += a[r];
        while (sum > m)
            sum -= a[l++];
        int x = getl(l, r - 1, a[r]);
        if (x < r)
            revise(1, 1, n, x, r - 1, a[r]);
        if (r == n)
            cout << getz(1, 1, n, l, r) << endl;
        else
            insert(1, 1, n, r + 1, getz(1, 1, n, l, r), a[r + 1]);
    }
    return 0;
}
```

---

## 作者：DLYJ (赞：1)

# 题目大意：

输入两个正整数n，m，在输入n个数，将这n个数分成连续的若干段，满足每一段之和不超过m，同时使得这若干组中，每组的最大值之和最小，输出这个最小值。

对于30%的数据，n ≤ 1,000。

对于100%的数据，n ≤ 100,000，hi ≤ 10,000，m ≤ 1,000,000,000。

30%做法：

没学过dp的童鞋可以移步到其他题目去了这道题并不那么适合你......

30%的数据，n<=1000,可以双重循环枚举更新，设a数组为题目中读入的数组，f【i】为考虑将前i本书都放下的最小花费，明显可以由前面的f【j】转移过来，且贡献是放放f【j】+max（a【k】（j+1<=k<=i））。 可以先做个前缀和，以便于O（1）判断i，和j之间的书的总量是否超过m，当然也可以从i往前扫，每次考虑完一个j就加上啊a【j】。复杂度O（n^2）,完全不虚。

100%做法：

考虑在30%做法的基础上进行优化，首先我们可以发现一个很显而易见的特点，就是f数组的值是单调不下降的，因为能放下前i+1本书的方案都必然放下了前i本书，花费自然不会比前i本书的少。所以这就可以用一些奇奇怪怪的玄学方法或者数据结构维护dp。首先要普及一种单调队列求区间最小值的方法：比如对于一个长度为6的序列1 5 2 1 4 3，我们要求出每3个数的最小值，我们可以维护一个单调下降的序列同时维护它的下标：一开始序列为空，然后操作到1，

序列：  值：  1

          下标： 1

然后操作到 5，这时候从队尾往前扫，扫到第一个碰到大于它的数或队列为空时停止：


序列：  值：  5

          下标： 2

（5比1大，将1弹出队列，队列为空，然后将5加入队列）

操作到2，

序列：  值：  5     2


          下标： 2     3

操作到1：


序列：  值：  5     2     1

          下标： 2     3     4

操作到4,

4比1大，将1弹出，比2大，再将2弹出，当新加入的值无法弹出其他数并加入队列以后，还有一步很重要的操作，就是判断一下队头的数的下标是否有超出求值范围，若现在加入了第i个数，考虑的是连续k个数的最大值，那么这时要考虑的是第i-k+1个数到第i个数的最大值，也就是说如果队头的数的下标要小于i-k+1，就要弹掉，这时5的下标是2，而我们已经加入的第5个数，也就是考虑的是3到5的最大值，5的下标过小，所以可以弹掉。


序列：  值：  4

          下标： 5

操作到1:


序列：  值：  4     1

          下标： 5     6

这时，我们就发现，每在队列里加入一个数时，需要3步操作：

1.先从队列的尾部往前一直弹掉比新加的数小的数

2.将新加的数加入队尾

3.判断队头的数是否需要弹掉

这样，不难发现，当我们插入第i个数的时候，以第i个数为结尾的连续k个数的最大值便是当前队头的数。

那么，为什么这个时间复杂度是O（n）的呢？首先，“3.判断队头的数是否需要弹掉”这一步最多只会弹一个数，然后，虽然“1.先从队列的尾部往前一直弹掉比新加的数小的数”这个操作一步可能会弹掉很多个数，但是一个n个数的序列，一共才n个数进入单调队列，额每弹一个数队列里就少了一个数，所以虽然插入一个数可能会弹掉很多个数，可是弹掉数的总数是不会超过n的，所以这是一个O（n）的算法。

然后，这道题的dp就可以用单调队列+线段树维护dp了，我们考虑枚举到了求f【i】的值，由于f数组具有单调性，所以假设f【j】和f【k】都可以对f【i】进行贡献，且第k+1个数到第i个数的最大值和第j+1个数到第i个数的最大值相等，那我们只需要取j和k中下标较小的对i进行贡献，换句话说，我们只需要维护能贡献到i的每种到i的最大值不同的j的下标最小的那一个就可以了，然后用个单调队列维护，操作和上面类似，而线段树是用来维护每一个单调队列中的j的贡献，可以快速查询最小值。具体还有些细节，就留给读者们自己思考了。



# 代码附上：

```cpp
#include <iostream>
#include <cmath>
#include <algorithm>
#include <cstdio>
using namespace std;
struct dat
{int val,wei,ff;};
dat line[100005];
int tre[500005],book[100005],qian[100005],f[100005],n,m,h,t,head,tail,s,p,ma;
void jia(int wei,int val,int l,int r,int root)
{
	if (l==r){tre[root]=val;return;}
	int mid=(l+r)/2;
	if (wei<=mid)jia(wei,val,l,mid,root*2);
	else jia(wei,val,mid+1,r,root*2+1);
	tre[root]=min(tre[root*2],tre[root*2+1]);
}
int fid(int h,int t,int l,int r,int root)
{
	if (l==r){return tre[root];}
	if (h<=l && t>=r)return tre[root];
	int mid=(l+r)/2,mm=1000000007;
	if (h<=mid)mm=fid(h,t,l,mid,root*2);
	if (t>=mid+1) mm=min(mm,fid(h,t,mid+1,r,root*2+1));
	return mm;
}
int main()
{
	cin>>n>>m;
	for (int i=1;i<=n;i++)
	{
		scanf("%d",&book[i]);
	}
	h=1;head=1;tail=0;
	while (t<n && s+book[t+1]<=m)
	{
	     t++;s+=book[t];qian[t]=1;ma=max(ma,book[t]);f[t]=ma;
	     while (tail>0 && book[t]>=line[tail].val)tail--;
	     tail++;line[tail].val=book[t];line[tail].wei=t;line[tail].ff=line[tail-1].wei;
	     jia(tail,f[line[tail-1].wei]+book[t],1,n,1);
	}
	for (int i=t+1;i<=n;i++)
	{
		s+=book[i];
		while (s>m){s-=book[h];h++;}
		qian[i]=h;
	}
	 for (int i=t+1;i<=n;i++)
	 {
	 	while (line[head].wei<qian[i] && head<=tail){line[head].wei=0;head++;}
	 	if (line[head].ff<qian[i]-1){line[head].ff=qian[i]-1;jia(head,f[qian[i]-1]+line[head].val,1,n,1);}
	 	while (tail>=head && book[i]>=line[tail].val){tail--;}
	 	tail++;line[tail].val=book[i];line[tail].wei=i;line[tail].ff=max(line[tail-1].wei,qian[i]-1);
	 	jia(tail,f[line[tail].ff]+book[i],1,n,1);
	 	f[i]=fid(head,tail,1,n,1);
	 }
	 cout<<f[n];
}

```



---

## 作者：⚡114514_zzm⚡ (赞：0)

**题目分析**：    

首先 **<script type="math/tex" id="MathJax-Element-218">O(n^2)</script>** 的DP很好推，记f[i]表示以第i本书为某一层结尾时，书架的最小高度。很明显：

**<script type="math/tex; mode=display" id="MathJax-Element-291">f[i]=\min(f[j]+\max(a[j+1],a[j+2]……a[i]))[a[j+1]+……+a[i]<=m]</script>**
其中对于每一个i，j的最小值是可以预处理出来的，记为Left[i]，并且Left数组单调不降。

而且很明显f值也是单调不降的。而且若i固定，随着j越小，a[j]~a[i]的max值也是单调不降的.

假设我们已经用一个双端队列存储了j1,j2,j3。我们发现j2~i，j3~i的max值小于a[i+1]，于是将其弹出，最后将f[j2]+a[i+1]加进来。然后再考虑Left对转移的限制。比如j1小于Left[i]，就要将其弹出队列，但最优答案可能会刚好取到Left[i]，所以还要让它本身进入队列。同时用数据结构维护队列里贡献的最小值，时间 **<script type="math/tex" id="MathJax-Element-292">O(n\log(n))</script>**。

写代码的时候，有一个细节没有考虑好，就是如果Left[i]已经在队列里面，就不用再进队了，然而我判的时候没有考虑head>tail，即队列为空的情况，导致越界了。
  
  ```cpp
#include<iostream>
#include<string>
#include<cstring>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<stdio.h>
#include<algorithm>
using namespace std;

const int maxn=100100;
const int oo=1000000000;

int tree[maxn<<2];
int Left[maxn];
int Max[maxn];

struct data
{
    int val,id,Time;
} h[maxn];
int sum[maxn];
int temp;

int que[maxn];
int g[maxn];
int head=1,tail=0;

int f[maxn];
int n,m;

bool Comp1(data x,data y)
{
    return x.val<y.val;
}

bool Comp2(data x,data y)
{
    return x.Time<y.Time;
}

int Query(int root,int L,int R,int x,int y)
{
    if ( y<L || R<x ) return 0;
    if ( x<=L && R<=y ) return tree[root];

    int mid=(L+R)>>1;
    int Left=root<<1;
    int Right=Left|1;

    int vl=Query(Left,L,mid,x,y);
    int vr=Query(Right,mid+1,R,x,y);
    return max(vl,vr);
}

void Update_max(int root,int L,int R,int x,int v)
{
    if (L==R)
    {
        tree[root]=v;
        return;
    }

    int mid=(L+R)>>1;
    int Left=root<<1;
    int Right=Left|1;

    if (x<=mid) Update_max(Left,L,mid,x,v);
    else Update_max(Right,mid+1,R,x,v);
    tree[root]=max(tree[Left],tree[Right]);
}

void Update(int root,int L,int R,int x,int v)
{
    if (L==R)
    {
        tree[root]=v;
        return;
    }

    int mid=(L+R)>>1;
    int Left=root<<1;
    int Right=Left|1;

    if (x<=mid) Update(Left,L,mid,x,v);
    else Update(Right,mid+1,R,x,v);
    tree[root]=min(tree[Left],tree[Right]);
}

int main()
{
    freopen("1295.in","r",stdin);
    freopen("1295.out","w",stdout);

    scanf("%d%d",&n,&m);
    for (int i=1; i<=n; i++) scanf("%d",&h[i].val),h[i].Time=i;

    sort(h+1,h+n+1,Comp1);
    temp=h[1].id=1;
    for (int i=2; i<=n; i++)
        if (h[i-1].val==h[i].val) h[i].id=temp;
        else h[i].id=++temp;
    sort(h+1,h+n+1,Comp2);

    for (int i=1; i<=n; i++)
    {
        Max[i]=Query(1,1,temp,h[i].id,temp);
        Update_max(1,1,temp,h[i].id,i);
    }

    sum[0]=0;
    for (int i=1; i<=n; i++) sum[i]=sum[i-1]+h[i].val;
    Left[1]=0;
    for (int i=2; i<=n; i++)
    {
        Left[i]=Left[i-1];
        while ( sum[i]-sum[ Left[i] ]>m ) Left[i]++;
    }

    for (int i=0; i<(n<<2); i++) tree[i]=oo;
    Update(1,1,n+1,1,0);
    que[++tail]=0;
    g[tail]=0;

    for (int i=1; i<=n; i++)
    {
        while ( head<=tail && que[tail]>=Max[i] )
            Update(1,1,n+1,que[tail]+1,oo),tail--;
        Update(1,1,n+1,Max[i]+1,f[ Max[i] ]+h[i].val);
        tail++;
        que[tail]=Max[i];
        g[tail]=h[i].val;

        int tp=oo;
        while ( head<=tail && que[head]<Left[i] )
            tp=g[head],Update(1,1,n+1,que[head]+1,oo),head++;
        if ( tp<oo && ( que[head]!=Left[i] || head>tail ) )
            head--,que[head]=Left[i],g[head]=tp,
            Update(1,1,n+1,Left[i]+1,f[ Left[i] ]+tp);

        f[i]=tree[1];
        tail++;
        que[tail]=i;
        g[tail]=0;
        Update(1,1,n+1,i+1,f[i]);
    }

    printf("%d\n",f[n]);
    return 0;
}
```


---


# [SCOI2007] 修车

## 题目描述

同一时刻有 $N$ 位车主带着他们的爱车来到了汽车维修中心。

维修中心共有 $M$ 位技术人员，不同的技术人员对不同的车进行维修所用的时间是不同的。

现在需要安排这 $M$ 位技术人员所维修的车及顺序，使得顾客平均等待的时间最小。

说明：顾客的等待时间是指从他把车送至维修中心到维修完毕所用的时间。

## 说明/提示

对于 $100\%$ 的数据，$2\le M\le 9$，$1\le N\le 60$，$1\le T\le 10^3$。

## 样例 #1

### 输入

```
2 2
3 2
1 4```

### 输出

```
1.50```

# 题解

## 作者：GKxx (赞：131)

古希腊哲学家赫拉克利曾说：“人不能两次踏进同一条河流。”这句话承认了辩证唯物主义中绝对运动与相对静止的统一的观点，是正确的。

人不能两次踏进同一条河流，因为你第一次踏进的河流和第二次踏进的河流已经不是同一个河流了（水流走了）。同样地，对于一个修车工人而言，修第一辆车的他和修第二辆车的他不是同一个人。

所以本题的错误建图方式是，建一个二分图，左边是车，右边是工人，连边跑最小费用流。这样建图体现的是形而上学的不变论，是错误的。

~~说人话：~~对于每个工人而言，他在修第$k$辆车的时候，之前已经修了$k-1$辆车，所以对于不同的$k$，对应的客人等待的时间是不同的，因此我们需要将每个工人拆成$n$个点，分别表示修第几辆车的他。

但是你会发现这样做的话连边时的边权比较困难。所以我们需要做一个推导。假设某个工人一共修了$K$辆车，花的时间分别为$T_1,T_2,\cdots,T_K$，那么当他修第一辆车时，后面的$K-1$个人必须等着，同时第$1$个人也要等他修好，所以总共等待时间为$K\times T_1$；接下来修第二辆车时同理，有$K-1$个人在等他修，所以时间是$(K-1)\times T_2$，以此类推，总等待时间即为

$$\sum\limits_{i=1}^K T_i(K-i+1)$$

不难发现，他倒数第$i$个修的车对应的客人总共要贡献$T_i\times i$的等待时间。于是有了这一步转化，我们可以给出最终的建图方案了：将每个工人拆成$n$个点，分别表示修**倒数第几辆车**的他；如果第$j$个工人修第$i$辆车要花$T(i,j)$的时间，我们枚举$k=1,\cdots,n$，从第$i$辆车向第$j$个工人的第$k$个点连边，容量为$1$，费用为$k\times T(i,j)$。然后跑最小费用最大流，最后总费用除以$n$即可。

```cpp
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>

template <typename T> inline void read(T& x) {
    int f = 0, c = getchar(); x = 0;
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) x = x * 10 + c - 48, c = getchar();
    if (f) x = -x;
}
template <typename T, typename... Args>
inline void read(T& x, Args&... args) {
    read(x); read(args...); 
}

const int maxv = 3000, maxe = 1e5, inf = INT_MAX;
int dist[maxv], head[maxv], q[maxv];
bool vis[maxv];
int v[maxe << 1], cap[maxe << 1], cost[maxe << 1], flow[maxe << 1], next[maxe << 1];
int n, m, s, t, V, tot = -1;

inline void ae(int x, int y, int ca, int co) {
    v[++tot] = y; cap[tot] = ca; cost[tot] = co; next[tot] = head[x]; head[x] = tot;
    v[++tot] = x; cap[tot] = 0; cost[tot] = -co; next[tot] = head[y]; head[y] = tot;
}
inline bool bfs() {
    for (int i = 1; i <= V; ++i)
        dist[i] = inf, vis[i] = 0;
    int l = 0, r = 1;
    dist[t] = 0; vis[q[1] = t] = 1;
    while (l < r) {
        int x = q[++l]; vis[x] = 0;
        for (int i = head[x]; ~i; i = next[i])
            if (cap[i ^ 1] > flow[i ^ 1] && dist[v[i]] > dist[x] - cost[i]) {
                dist[v[i]] = dist[x] - cost[i];
                if (!vis[v[i]]) vis[q[++r] = v[i]] = 1;
            }
    }
    return dist[s] < inf;
}
int dfs(int x, int cf, int &mc) {
    vis[x] = 1;
    if (x == t || !cf) return cf;
    int getf = 0;
    for (int i = head[x]; ~i; i = next[i])
        if (!vis[v[i]] && cap[i] > flow[i] && dist[v[i]] == dist[x] - cost[i]) {
            int nf = dfs(v[i], std::min(cf, cap[i] - flow[i]), mc);
            if (nf) {
                flow[i] += nf; flow[i ^ 1] -= nf; getf += nf; cf -= nf;
                mc += nf * cost[i];
                if (!cf) break;
            }
        }
    return getf;
}
inline void mcmf(int &mc, int &mf) {
    mc = mf = 0;
    while (bfs()) {
        vis[t] = 1;
        while (vis[t]) {
            for (int i = 1; i <= V; ++i)
                vis[i] = 0;
            mf += dfs(s, inf, mc);
        }
    }
}

int main() {
    read(m, n);
    s = n + n * m + 1;
    t = V = s + 1;
    for (int i = 1; i <= V; ++i) head[i] = -1;
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j) {
            int x; read(x);
            for (int k = 1; k <= n; ++k)
                ae(i, j * n + k, 1, x * k);
        }
    for (int i = 1; i <= n; ++i) ae(s, i, 1, 0);
    for (int i = 1; i <= n * m; ++i) ae(i + n, t, 1, 0);
    int mc, mf; mcmf(mc, mf);
    printf("%.2lf\n", (double)mc / n);
    return 0;
}
```

本题有数据加强板：NOI2012的美食节。那道题需要动态加边。不过那题似乎对我这种zkw费用流使用者不太友好，反正我是用EK-spfa过的那题。

最后说一句，如果认为“人甚至一次也不能踏进同一条河流”，那就是相对主义诡辩论，是错误的。

---

## 作者：w4p3r (赞：53)

#### 前言：

本蒟蒻觉得这道题出的不错，一开始我只想到了二分答案，根本没有想到如何构造网络流，看了题解后才大概理解的。


------------


#### 思路：  
假设我们现在只有一个修车师傅，共有$A1,A2...An$这n辆车，那么所有人的等待时间就分别为:


$A1+A2...+An,A2+A3+..+An,...,An-1+An,An$。                     
**那所有人的等待时间呢？**   
加起来，我们发现所有人的等待时间应该是:

$A1*n+A2*(n-1)+...+An$

**那我们对每辆车被等待的时间考虑，发现越后修的被等待的时间越少**

**而且显而易见的，所有车被等待的时间即为所有人等待的时间**


------------


#### 做法：

那我们从每辆车被等待的时间思考，思路也不是很难了，

将$M$位师傅拆成$N*M$个点，第$(i-1)*N+j$个点表示的是在修第$j$辆车的第$i$位师傅，并将这个点连向每辆车，容量为$1$，边权为$Cki*j$（$Cij$为第i辆车被第j位师傅修所花的时间,$1<=k<=N$），

然后再源点朝$M$个车点建边，$N*M$个师傅点朝汇点建边，都是边权为0，容量为1的边，最后跑最小费用最大流就行了。

~~同时建反向边应该不用我赘述了吧~~

**注：本来是先修被等的时间越多，但是反过来仔细想先也没有什么问题**



------------

#### 代码:
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#include<vector>
#define N 2010
#define K 210
#define M 100010
#define inf 0x7fffffff/2
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
inline ll read()
{
	char ch=getchar();
	ll s=0,w=1;
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
	return s*w;
}
struct edge
{
	int next,to,fl,v;
}e[M<<1];
int head[N],cnt=1;
int n,m;
int dist[N],pre[N],wch[N];
//pre表示spfa中每个点是从哪条边来的,wch表示spfa中每个点是从哪个点来的
queue<int>Q;
int vis[N];
int c[K][K];//第i辆车被第j格师傅修所花的时间
int s,t;
int minn[N];//minn表示spfa中s到每个点所经过的边中的最小流量
inline void add_edge(int from,int to,int fl,int v)
{
	e[++cnt].to=to;
	e[cnt].next=head[from];
	e[cnt].v=v;
	e[cnt].fl=fl;
	head[from]=cnt;
}//加边
void dfs(int now,int sub)
{
	e[wch[now]].fl-=sub;
	e[wch[now]^1].fl+=sub;
	if(pre[now])dfs(pre[now],sub);
}//修改流量
inline int spfa()
{
	for(register int i=1;i<=t;i++)dist[i]=inf;
	memset(vis,0,sizeof(vis));while(!Q.empty())Q.pop();
	Q.push(s),vis[s]=1;minn[s]=inf;//不要忘了给minn[s]设初值
	while(!Q.empty())
	{
		int x=Q.front();Q.pop();vis[x]=0;
		for(register int i=head[x];i;i=e[i].next)
		{
			if(dist[e[i].to]>dist[x]+e[i].v&&e[i].fl>0)
			{
				dist[e[i].to]=dist[x]+e[i].v;
				wch[e[i].to]=i;pre[e[i].to]=x;
                minn[e[i].to]=min(minn[x],e[i].fl);
				if(!vis[e[i].to])
				{
					Q.push(e[i].to);
					vis[e[i].to]=1;
				}
			}
		}
	}
	if(dist[t]==inf)return inf;//如果从s到不了t了
	dfs(t,minn[t]);//修改边的流量
	return minn[t]*dist[t];
}//最短路
inline int EK()
{
	int sum=0;
	while(1)
	{
		int x=spfa();
		if(x==inf)return sum;//没有增广路了
		else sum+=x;
	}
}
int main()
{
	m=read(),n=read();
	t=n*m+n+1;
	for(register int i=1;i<=n;i++)
	{
		for(register int j=1;j<=m;j++){c[i][j]=read();}
	}
	for(register int i=1;i<=n*m;i++)
	{
		add_edge(s,i,1,0);add_edge(i,s,0,0);
	}
	for(register int i=1;i<=m;i++)
	{
		for(register int j=1;j<=n;j++)
		{
			for(register int k=1;k<=n;k++)
			{
				int now=(i-1)*n+k;
				add_edge(now,j+n*m,1,c[j][i]*k);
				add_edge(j+n*m,now,0,-c[j][i]*k);
			}
		}
	}
	for(register int i=1;i<=n;i++)add_edge(n*m+i,t,1,0),add_edge(t,n*m+i,0,0);
	printf("%.2lf",double(double(EK())/double(n)));
	return 0;
    //我的建图方式可能和前面我的题解写的方式不大一样，代码中我是师傅练得源点，车连的汇点
}

```



------------

#### 后记：

希望大家在A了这道题后可以看看NOI2012的美食节，这道题在本题模型的基础上提出了更多的思考和优化，其中那道题的优化很有意思，主要了运用了spfa在稀疏图中速度更快的理论知识，值得一做。



---

## 作者：Night_Aurora (赞：44)

对下面的题解补充一下开头

要求平均时间最短，就等同于要求总时间最短

对于一个修车工先后用$W_1-W_n$的几个人，花费的总时间是

$W_n*1+W_{n-1}*2+...+W_1*n$

不难发现倒数第a个修就对总时间产生a\*原时间的贡献

然后我们将每个工人划分成N个阶段，(i,t)表示修车工i在倒数第t个修

可以建一个二分图，左边表示要修理的东西，右边表示工人+阶段

于是可以从左边的e向右边的(i,t)连边，权值是Time[e][i]\*t，就是第e个用i这个修车工所用时间

最小权值完全匹配后，最小权值和除以N就是答案

因为权值是正的，所以一个修车工接到的连线一定是从(i,1)开始连续的，也符合现实情况

因为假设是断续的，那后面的(i,n)改连向(i,n-k),k<n时，答案更优，违背了前面的最优性

所以推导完后就推导出下面题解那样的算法


---

## 作者：magolor (赞：36)

竟然没有题解……


费用流问题，把工人拆成N个点，表示N个时间段的工人。这样一共M\*N个工人。

然后把N辆车和M\*N个工人全部连起来（完全二分图），权值是工人时间段编号\*输入的时间，表示需要等待的时间。

S到车流1费0，工人（M\*N）到T流1费0。

这样加起来后满流的最小费用/N答案了。


哦，不要忘了，**输入不要用time,在洛谷里time是关键字！！！**







    


        


```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 1000
#define MAXM 100000
#define MEMINF 0x3f
#define INF 0x3f3f3f3f
#define P(x,y)    (~-(x)*N+(y))
struct Edge
{
    int to,nex,c,w;
    Edge(){}
    Edge(int _to, int _nex, int _c, int _w):to(_to),nex(_nex),c(_c),w(_w){} 
};
Edge e[MAXM+5];
int first[MAXN+5], q[MAXN+5], dis[MAXN+5], pre[MAXN+5], tm, tot, n, m, N, M, S, T, V, ANSC, ANSF;
bool book[MAXN+5];
inline void Add(int a, int b, int c, int w)
{
    e[tot] = Edge(b,first[a],c,w);
    first[a] = tot++;
    e[tot] = Edge(a,first[b],0,-w);
    first[b] = tot++;
    return;
}
inline bool SPFA()
{
    memset(dis,MEMINF,sizeof(dis));
    q[0] = S, dis[S] = 0, book[S] = true;
    for(register int head = 0, tail = 1, t, u; head != tail; book[t] = false)
        for(t = q[head++], head %= MAXN, u = first[t]; u+1; u = e[u].nex)
            if(e[u].c > 0 && dis[e[u].to] > dis[t] + e[u].w)
            {
                dis[e[u].to] = dis[t] + e[u].w, pre[e[u].to] = u;
                if(!book[e[u].to])
                    book[e[u].to] = true, q[tail++] = e[u].to, tail %= MAXN;
            }
    return (dis[T] != INF);
}
inline void CALC()
{
    int del = INF;
    for(register int p = T, u = pre[p]; p != S; p = e[u^1].to, u = pre[p])
        del = min(del,e[u].c);
    for(register int p = T, u = pre[p]; p != S; p = e[u^1].to, u = pre[p])
        e[u].c -= del, e[u^1].c += del, ANSC += del*e[u].w;
    ANSF += del;
    return;
}
inline void MCMF()
{
    for(; SPFA(); CALC());
    return;
}
int main()
{
    memset(first,-1,sizeof(first));
    scanf("%d%d",&M,&N), S = 0, T =    (V = M*N)+N+1;    //operators:M*N    vehicles:N
    for(register int i = 1, j, k; i <= N; i++)        //vehicles
        for(j = 1; j <= M; j++)                        //operators
        {
            scanf("%d",&tm);
            for(k = 1; k <= N; k++)
                Add(V+i,P(j,k),1,k*tm);
        }
    for(register int i = 1; i <= N; i++)            //vehicles
        Add(S,V+i,1,0);
    for(register int p = 1; p <= V; p++)            //operators
        Add(p,T,1,0);
    MCMF(), printf("%.2lf",1.0*ANSC/N);
     return 0;
}
```

---

## 作者：Orion545 (赞：15)

# 广告

[蒟蒻的blog](http://www.cnblogs.com/dedicatus545/p/8733196.html)

# 正文

我们考虑某个工人修车的从前到后序列如下：

${W_1,W_2,W_3,...,W_n}$

那么，对于这n辆车的车主而言，他们等候的总时间为：

$\sum_{i=1}^{n}W_i\ast\left(n-i+1\right)=nW_1+\left(n-1\right)W_2+...+2W_{n-1}+W_n$

这一步很重要，因为经过这一步推导，我们发现：对于“把第i辆车让第j个人在“需要消耗k次时间”的那个个位置修”这一个决策，可以等同为进行一个费用为$T\left(i,j\right)\ast k$的决策

因此我们可以得到一个决策集合：决策$\left(i,j,k\right)=T\left(i,j\right)\ast k$表示“把第i辆车让第j个人在“需要消耗k次时间”的那个个位置修”

那实际上我们就是对于每个i选取一个这样的决策，同时这个决策的$\left(j,k\right)$不能相同

那就好办了，我们建立一个二分图，左边是n辆车，右边是n\*m个上述状态的二元组$\left(j,k\right)$（可以证明$k\leq n$）

源点向车连边，而决策二元组向汇点连边，流量1费用0

中间的边（注意这是一个完全二分图）就是流量1费用$T\left(i,j\right)\ast k$的

跑最小费用最大流即可

Code:

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define inf 1e9
#define id(i,j) (i-1)*n+j
using namespace std;
inline int read(){
    int re=0,flag=1;char ch=getchar();
    while(ch>'9'||ch<'0'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
    return re*flag;
}
int n,m,cnt=-1,ans,first[1010],dis[1010],vis[1010];
struct edge{
    int to,next,w,cap;
}a[100010];
inline void add(int u,int v,int w,int cap){
    a[++cnt]=(edge){v,first[u],w,cap};first[u]=cnt;
    a[++cnt]=(edge){u,first[v],-w,0};first[v]=cnt;
}
bool spfa(int s,int t){
    int q[5010],head=0,tail=1,u,v,w,i;
    memset(dis,-1,sizeof(dis));memset(vis,0,sizeof(vis));
    q[0]=t;vis[t]=1;dis[t]=0;
    while(head<tail){
        u=q[head++];vis[u]=0;
        for(i=first[u];~i;i=a[i].next){
            v=a[i].to;w=a[i].w;
            if(a[i^1].cap&&((dis[v]==-1)||(dis[v]>dis[u]-w))){
                dis[v]=dis[u]-w;
                if(!vis[v]) vis[v]=1,q[tail++]=v;
            }
        }
    }
    return ~dis[s];
}
int dfs(int u,int t,int limit){
    if(u==t||!limit){vis[u]=1;return limit;}
    int i,v,f,flow=0,w;vis[u]=1;
    for(i=first[u];~i;i=a[i].next){
        v=a[i].to;w=a[i].w;
        if(!vis[v]&&a[i].cap&&(dis[v]==dis[u]-w)){
            if(!(f=dfs(v,t,min(limit,a[i].cap)))) continue;
            a[i].cap-=f;a[i^1].cap+=f;
            ans+=f*w;flow+=f;limit-=f;
            if(!limit) return flow;
        }
    }
    return flow;
}
int zkw(int s,int t){//zkw费用流
    int re=0;
    while(spfa(s,t)){
        vis[t]=1;
        while(vis[t]){
            memset(vis,0,sizeof(vis));
            re+=dfs(s,t,inf);
        }
    }
    return re;
}
int main(){
    memset(first,-1,sizeof(first));int i,j,k,t1;
    m=read();n=read();
    for(i=1;i<=n;i++) add(0,i,0,1);
    for(i=1;i<=m;i++) for(j=1;j<=n;j++) add(n+id(i,j),n+n*m+1,0,1);
    for(i=1;i<=n;i++){
        for(j=1;j<=m;j++){
            t1=read();
            for(k=1;k<=n;k++){
            	add(i,n+id(j,k),t1*k,1);
			}
        }
    }
    zkw(0,n+n*m+1);
    printf("%.2lf",((double)ans)/((double)n));//注意输出保留两位小数
}
```

---

## 作者：xMinh (赞：12)

[luogu2053 修车](https://www.luogu.org/problemnew/solution/P2053)    

先推一波[蒟蒻的博客](https://xminh.github.io/)    

再%楼下神佬

网络流好题 就是楼下神佬们的题解都有点难懂 我来个蒟蒻版本的

这道题也算搓了很久了……一直没有思路，只能怪我比较zz。

小心题意杀……要注意，不能一个人同时修好几辆车，也不能好几个人同一辆车，但是可以好几个人同时修好几辆分别不同的车。

要用到一个很骚的逆向思维。

我们把每个人拆成n个点，一共m乘n个，其中任意一个记为a[i,j]，也就是第i个人修的倒数第j辆车。这里要注意，这个倒数第j是相对于第i个人的，并不是总体上的倒数第j辆。我们再开n个点，其中任意一个记为k，也就是第k辆车。我们的原始数组，第i个人修第k辆车，记为b[i,k]。把a[i,j]和k一连，就是第i个人倒数第j个修车，修的是第k辆。因为这辆车是倒数第j个修，所以一共要有j辆车等待b[i,k]的时间才行。这样一来，j乘b[i,k]就表示这种情况要耗费多少时间。

我们把s连接n个表示顺序的点，流量1，费用0，这个好说。

然后就像刚才我们说的那样，这n个点中每个点k都要连接每个a[i,j]，流量1，费用为j*b[i,k]。

然后我们再把m*n个点连到汇点上，流量1，费用0。

代码

    #include<iostream>
    #include<cstdio>
    #include<queue>
    #define big 1e9
    #define maxn 100000
    using namespace std;
    int dis[maxn],pre[maxn],flow[maxn],lst[maxn],head[maxn],n,m,cnt,ans,s,t,b[1001][1001];
    bool vis[maxn];
    queue<int> q;
    int read(){
    	char c;int r=0,f=1;
    	c=getchar();
    	while (c<'0' || c>'9'){
    		if (c=='-') f=-1;
    		c=getchar();
    	}
    	while (c>='0' && c<='9'){
    		r=(r<<3)+(r<<1)+(c^48);
    		c=getchar();
    	}
    	return r*f;
    }
    struct node{
    	int next,to,flow,dis;
    }ljb[maxn];
    void add_edge(int x,int y,int f,int c){
    	ljb[++cnt].next=head[x];
    	ljb[cnt].to=y;
    	ljb[cnt].flow=f;
    	ljb[cnt].dis=c;
    	head[x]=cnt;
    }
    void add(int x,int y,int f,int c){
    	add_edge(x,y,f,c);
    	add_edge(y,x,0,-c);
    }
    bool spfa(){
    	for (int i=s;i<=t;i++) dis[i]=big,flow[i]=big,pre[i]=-1,lst[i]=0,vis[i]=0;
    	q.push(s);dis[s]=0;vis[s]=1;pre[s]=0;
    	while (!q.empty()){
    		int x=q.front();q.pop();vis[x]=0;
    		for (int i=head[x];i!=-1;i=ljb[i].next){
    			int y=ljb[i].to;
    			if (dis[y]>dis[x]+ljb[i].dis && ljb[i].flow>0){
    				dis[y]=dis[x]+ljb[i].dis;
    				flow[y]=min(flow[x],ljb[i].flow);
    				pre[y]=x;lst[y]=i;
    				if (!vis[y]){
    					vis[y]=1;
    					q.push(y);
    				}
    			}
    		}
    	}
    	if (pre[t]!=-1) return 1;
    	return 0;
    }
    int main()
    {
    	m=read();n=read();t=m*n+n+1;
    	for (int i=s;i<=t;i++) head[i]=-1;cnt=-1;
    	for (int k=1;k<=n;k++) add(s,m*n+k,1,0);
    	for (int k=1;k<=n;k++)
    		for (int i=1;i<=m;i++)
    			b[i][k]=read();
    	for (int i=1;i<=m;i++)
    		for (int j=1;j<=n;j++){
    			int now=(i-1)*n+j;	
    			for (int k=1;k<=n;k++) add(m*n+k,now,1,j*b[i][k]);
    			add(now,t,1,0);
    		}
    	while (spfa()){
    		ans+=flow[t]*dis[t];
    		int now=t;
    		while (now){
    			ljb[lst[now]].flow-=flow[t];
    			ljb[lst[now]^1].flow+=flow[t];
    			now=pre[now];
    		}
    	}
    	printf("%.2lf",ans/(n*1.0));
    }






---

## 作者：子谦。 (赞：4)


这是一道很不错的费用流好题，建图的思想很是巧妙

我们把每个工人拆成$n$个点，表示当前工人在$n$个不同的时间段，那么$m$个工人就是$n*m$个点，然后把这些点向汇点连一条费用为0边权为1的边，也就是同一时段一个工人只能维修一辆车。对于每辆车，我们先从汇点连出一条费用为0边权为1的边，表示每辆车只会被一个工人在一个时段维修一次。然后对于每辆车，我们向之前的$n*m$个点连边，边权为1，费用为工人维修这辆车的时间*这是工人的第几个时间段。然后跑费用流，最后答案除以$n$，保留两位小数就可以了。

但是这样为什么是对的呢？

对于同一辆车，同一个工人，时间段越靠后，产生的权值也就越大。那么流量肯定会优先从靠前的时间段流出。那么如果一个工人要维修多辆车，他们所用的时间段一定是相邻的，并且在最前面。那么工人要维修的时间段最靠后的车，产生的权值是“工人维修这辆车的时间*这是工人的第几个时间段”，那么也就相当于维修这辆车使当前工人维修的所有车的车主产生的等待时间之和，换句话说这里的时间段越早，修的就越晚，时间段最晚的，实际上是当前工人第一个维修的车辆。所以这个时间段其实是指当前工人维修的倒数第几辆车。这样的话，也就能够看出为什么这样建图是正确的了。

下放代码

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cctype>
#include<queue>
#define ll long long
#define gc getchar
#define maxn 1005
#define maxm 100005
using namespace std;

inline ll read(){
	ll a=0;int f=0;char p=gc();
	while(!isdigit(p)){f|=p=='-';p=gc();}
	while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=gc();}
	return f?-a:a;
}int n,m,S,T,ans,a[maxn][10];

struct ahaha{
	int f,w,to,next;
}e[maxm<<1];int tot,head[maxn];
inline void add(int u,int v,int w,int f){
	e[tot]={f,w,v,head[u]};head[u]=tot++;
}
inline void Add(int u,int v,int w,int f){
	add(u,v,w,f);add(v,u,0,-f);
}

deque<int>q;
int b[maxn],d[maxn],fl[maxn],la[maxn];
int spfa(){memset(fl,63,sizeof fl);
	memset(d,63,sizeof d);d[S]=0;la[T]=-1;q.push_back(S);
	while(!q.empty()){
		int u=q.front();q.pop_front();b[u]=0;
		for(int i=head[u];~i;i=e[i].next){
			int v=e[i].to;if(e[i].w<=0||d[v]<=d[u]+e[i].f)continue;
			d[v]=d[u]+e[i].f;la[v]=i;
			fl[v]=min(fl[u],e[i].w);
			if(b[v])continue;b[v]=1;
			if(q.empty()||d[v]<d[q.front()])q.push_front(v);
			else q.push_back(v);
		}
	}return ~la[T];
}

int main(){memset(head,-1,sizeof head);
	m=read();n=read();T=n+n*m+1;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
			a[i][j]=read();
	for(int i=1;i<=n;++i){
		Add(S,i,1,0);int p=n;
		for(int j=1;j<=m;++j)
			for(int k=1;k<=n;++k)
				Add(i,++p,1,a[i][j]*k);  //流量流经这条边表示第i辆车是第j个工人维修的倒数第k辆车
	}int p=n;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
			Add(++p,T,1,0);
	while(spfa()){
		ans+=fl[T]*d[T];
		int now=T;
		while(now!=S){
			e[la[now]].w-=fl[T];
			e[la[now]^1].w+=fl[T];
			now=e[la[now]^1].to;
		}
	}
	printf("%.2f\n",1.0*ans/n);
	return 0;
}
```



---

## 作者：AubRain (赞：3)

还是值得思考的题目，~~至少不是裸题了~~。

首先如果一个工人只能维修一辆车，那么就是个裸的二分图带权匹配了。可惜一个工人可以维修多辆车。

可以看到 $n$ 比较大（$\le60$），$m$ 比较小（$\le9$）。数据范围提示我们可以把 $m$ 个点拆成多个点。

**具体怎么拆：**

第 $x$ 号工人，拆成 $x_1,x_2,x_3...x_n$ 共n个工人。然后客户向每个工人连边。如果该工人维修该客户需要 $c$ 元，则向 $x_i$ 连一条流量为 $1$ ，边权为 $i*c$ 的边。

为什么是对的？

~~感性理解一下~~

如果客户 $A$ 最终选择了 $x_2$ 这个工人，肯定会有别的客户 $B$ 向 $x_1$ 匹配。相当于让客户 $A$ 先和 $x$ 工人匹配，再让 $B$ 匹配，所以答案加上了两倍的 $x$ 修 $A$ 的时间。

代码：

```cpp
#include<bits/stdc++.h>
#define N 100005
#define M 200005 
using namespace std;

inline void rd(int &X)
{
    X=0;int w=0;char ch=0;
    while(!isdigit(ch))w|=ch=='-',ch=getchar();
    while( isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    X=w?-X:X;
}

int n,ans,s,t,flow;
int head[N],cnt=1,v[N];
int pre[N],d[N],mn[N];
struct nd{int nxt,to,v,c;}e[M];
#define For(x) for(int y,i=head[x];(y=e[i].to);i=e[i].nxt)

void add(int x,int y,int w,int c){
    e[++cnt]=(nd){head[x],y,w, c};head[x]=cnt;
    e[++cnt]=(nd){head[y],x,0,-c};head[y]=cnt;
}
bool SPFA()
{
    memset(d,0x3f,sizeof d);d[s]=0;
    queue<int> q;q.push(s);mn[s]=1<<29;
    while(!q.empty()){
        int x=q.front();q.pop();v[x]=0;
        For(x) if(e[i].v&&d[y]>d[x]+e[i].c)
        {
            pre[y]=i; d[y]=d[x]+e[i].c;
            mn[y]=min(mn[x],e[i].v);
            if(!v[y]) v[y]=1,q.push(y);
        }
    }
    return d[t]!=0x3f3f3f3f;
}
void up()
{
    int x=t;
    while(x!=s)
    {
        int i=pre[x];
        e[i].v-=mn[t];
        e[i^1].v+=mn[t];
        x=e[i^1].to;
    }
    flow+=mn[t];
    ans+=d[t]*mn[t];
}

int m,tot;
int a[65][65];

void build()
{
	rd(m);rd(n);s=N-5,t=N-4;tot=n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			rd(a[i][j]);
	for(int i=1;i<=n;i++)
		add(s,i,1,0);
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++){
			++tot;add(tot,t,1,0);
			for(int k=1;k<=n;k++)
				add(k,tot,1,j*a[k][i]);
		}
	}
}
int main()
{
	build();
    while(SPFA()) up();
    printf("%.2lf",1.0*ans/n);
}
```

---

## 作者：Karnage (赞：1)

# [P2053 【SCOI2007】修车](https://www.luogu.org/problemnew/show/P2053)

## $Solution$

首先明确一点，若总的等待时间为 $sum$，那么答案即为 $sum/n$，因此只要最小化总时间便能最小化答案。

考虑只有一个工人时的情况。

假设$n$辆车以修理速度分别为$T_1,\ T_2,\ ...\ ,\ T_n$的顺序修理，那么：

第一位车主等待时间为 $T_1;$

第二位车主等待时间为 $T_1\ +\ T_2;$

第$n$位车主等待时间为 $T_1\ +\ T_2\ +\ ...\ +\ T_n;$

第$i$位车主等待时间为 $\sum ^i _{j = 1} T_j;$

显而易见地，总等待时间为 $\sum^n_{i = 1}\sum^i_{j = 1}T_i*(n - i + 1);$

那么，第$i$辆车的贡献即为 $T_i * (n - i + 1).$

因此，我们完全可以从每辆车的角度考虑答案。

具体地，我们可以将每位工人拆成$n$个点，分别表示$n$个阶段；

考虑 **最小费用最大流**，每辆车显然只能被流$1$次，将源点向每辆车连一条 **流量为$1$， 费用为$0$** 的边；

对于第 $i\ (1 \le i \le n)$ 辆车代表的点，向第 $j\ (1 \le j \le m)$ 位工人的第 $k (1 \le k \le n)$ 个阶段，连一条 **流量为$1$, 费用为$T_{ij} $** 的边；

对于每位工人的每个阶段（共$n * m$个），向汇点连一条 **流量为$1$, 费用为$0$** 的边；

最后，跑最小费用最大流即可。

## $Code$

```cpp
#include <cstdio>
#include <cstring>
#include <queue>
#include <algorithm>

inline int read() {
    int x = 0, k = 1; char c = getchar();
    for (; c < 48 || c > 57; c = getchar()) k ^= c == '-';
    for (; c >= 48 && c <= 57; c = getchar()) x = x * 10 + (c ^ 48);
    return k ? x : -x;
}

const int N = 1e5 + 5, M = 2e5 + 5;
int n, m, s, t, num = 1, head[N], dis[N], flow[N], last[N], pre[N], maxflow, mincost;
bool vis[N];
struct edge {
    int nxt, to, flow, val;
} e[M];
std::queue <int> q;

inline void add(int u, int v, int w, int val) {
    e[++num] = (edge) { head[u], v, w, val }, head[u] = num;
    e[++num] = (edge) { head[v], u, 0, -val }, head[v] = num;
}

inline bool spfa() {
    memset(vis, 0, sizeof vis);
    memset(dis, 0x3f, sizeof dis);
    memset(flow, 0x3f, sizeof flow);
    q.push(s), dis[s] = 0, vis[s] = 1;
    while (!q.empty()) {
        int u = q.front();
        q.pop(), vis[u] = 0;
        for (int i = head[u], v; i; i = e[i].nxt)
            if (e[i].flow && dis[v = e[i].to] > dis[u] + e[i].val) {
                dis[v] = dis[u] + e[i].val;
                pre[v] = u, last[v] = i;
                flow[v] = std::min(flow[u], e[i].flow);
                if (!vis[v])
                    q.push(v), vis[v] = 1;
            }
    }
    return dis[t] != 0x3f3f3f3f;
}

inline void MCMF() {
    while (spfa()) {
        int now = t;
        maxflow += flow[t];
        mincost += flow[t] * dis[t];
        while (now ^ s) {
            e[last[now]].flow -= flow[t];
            e[last[now] ^ 1].flow += flow[t];
            now = pre[now];
        }
    }
}

int main() {
    m = read(), n = read(), t = (s = n * m + n + 1) + 1;
    for (int i = 1; i <= n; ++i) {
        add(s, i, 1, 0);
        for (int j = 1; j <= m; ++j) {
            int x = read();
            for (int k = 1; k <= n; ++k) add(i, n + (j - 1) * n + k, 1, k * x);
            add(n + (j - 1) * n + i, t, 1, 0);
        }
    }
    MCMF();
    printf("%.2lf\n", 1.0 * mincost / n);
    return 0;
}
```

---

## 作者：bztMinamoto (赞：1)

打广告：[blog](https://www.cnblogs.com/bztMinamoto/p/9510697.html)

楼上几位大佬说的我啥都听不懂……我还是稍微写的详细点好了……

　　我们考虑一下，如果一个工人修车的序列为$W_1,W_2,W_3...W_n$

　　那么对于这几辆车的车主而言，他们等待的总时间是$\sum _{i=1}^n W_i*(n-i+1)=nW_1+(n-1)W_2+...+W_n$（因为一个人在越前面修，会使后面更多的人要等待他的车修好）

　　然后因为平均时间最少，人数是不变的，所以得保证总时间最少

　　我们发现，如果把第$i$个人的车让第$j$个人在倒数第$k$个修（以下表示为$(i,j,k)$），那么对总时间的贡献是$T(i,j)*k$，其中$T(i,j)$表示第$j$个人修第$i$辆车的时间

　　然后因为每一辆车只能被一个人修，每一个人同一时间只能修一辆车

　　那么我们可以把$(j,k)$表示成一个状态，表示被第$j$个人在倒数第$k$个修，那么不难发现每一个状态只能被匹配一次，即不可能有两辆车同时被一个人在同一个顺序修

　　那么我们可以建一个二分图，左边是$n$辆车，右边是$n*m$个状态$(j,k)$（因为$k$不可能超过$n$），然后左边的每一个点向右边所有点连边，容量为$1$，费用为对应的$(i,j,k)$

　　然后因为每一辆车只会被修一次，所以从源点向所有车连容$1$费$0$的边

　　因为每一个人在同一时间只能修一辆车，所以右边所有状态向汇点连容$1$费$0$的边

　　当网络跑满的时候说明所有车都有人修了，然后又要时间最少，只要在此基础上求一个最小费用流即可
  
```
//minamoto
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#define inf 0x3f3f3f3f
#define id(i,j) (i-1)*n+j
using namespace std;
#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){
    #define num ch-'0'
    char ch;bool flag=0;int res;
    while(!isdigit(ch=getc()))
    (ch=='-')&&(flag=true);
    for(res=num;isdigit(ch=getc());res=res*10+num);
    (flag)&&(res=-res);
    #undef num
    return res;
}
const int N=1005,M=100005;
int ver[M],Next[M],head[N],edge[M],flow[M],tot=1;
int vis[N],dis[N],disf[N],Pre[N],last[N],n,m,s,t;
queue<int> q;
inline void add(int u,int v,int f,int e){
	ver[++tot]=v,Next[tot]=head[u],head[u]=tot,flow[tot]=f,edge[tot]=e;
	ver[++tot]=u,Next[tot]=head[v],head[v]=tot,flow[tot]=0,edge[tot]=-e;
}
bool spfa(){
	memset(dis,0x3f,sizeof(dis));
	while(!q.empty()) q.pop();
	q.push(s),dis[s]=0,disf[s]=inf,Pre[t]=-1;
	while(!q.empty()){
		int u=q.front();q.pop(),vis[u]=0;
		for(int i=head[u];i;i=Next[i]){
			int v=ver[i];
			if(flow[i]&&dis[v]>dis[u]+edge[i]){
				dis[v]=dis[u]+edge[i],Pre[v]=u,last[v]=i;
				disf[v]=min(disf[u],flow[i]);
				if(!vis[v]) vis[v]=1,q.push(v);
			}
		}
	}
	return ~Pre[t];
}
int dinic(){
	int mincost=0;
	while(spfa()){
		int u=t;mincost+=disf[t]*dis[t];
		while(u!=s){
			flow[last[u]]-=disf[t],flow[last[u]^1]+=disf[t];
			u=Pre[u];
		}
	}
	return mincost;
}
int main(){
	m=read(),n=read();
	s=0,t=n*m+n+1;
	for(int i=1;i<=n;++i) add(s,i,1,0);
	for(int i=1;i<=m;++i)
	for(int j=1;j<=n;++j)
	add(n+id(i,j),t,1,0);
	for(int i=1;i<=n;++i)
	for(int j=1;j<=m;++j){
		int cost=read();
		for(int k=1;k<=n;++k){
			add(i,n+id(j,k),1,cost*k);
		}
	}
	printf("%.2lf",(double)dinic()/n);
	return 0;
}
```

---

## 作者：Mr_cold (赞：0)

一道较为经典的费用流的题，首先毫无疑问是顾客向技术人员连边，但是怎么连呢。

求平均时间最短等价于求总时间最短。*这是转换*

如果只有一个修理工，那么花费的总时间是
$\sum$ $T_1*n +T_2*(n-1)+....+T_n*1$

可以知道倒数第i个人所提供的总时间是$T_i * n$ 的，然后对于m个技术人员，我们把每个技术人员分成n个时间点，例：第i个人是第j个技术人员倒数第k个完成的
add(i,n+(j-1)*n+k,T[i][j]*k),这一步就是这道题的精髓，对于式子的转化并建边，之后就是源点与汇点相连了，这里就不说了
~~~
#include<bits/stdc++.h>
#define pts putchar('\n');
#define ptc putchar(' ');
using namespace std;
typedef long long ll;
const int maxm=4000000+9;
const int maxn=20000+9;
const int mod=20100403;
const int inf=0x3f3f3f3f;
const double eps=1e-4;
int m,n;
struct Edge{int u,v,cost,flow,from;}edge[maxm];
int last[maxn],cnt=1;
int st,ed;
int fa[maxn],way[maxn];
int flow_sum,min_cost;
int dis[maxn],flow[maxn];
deque<int>q;
int in[maxn],sign=0;;
int read(){
    int a=1,b=0;char c=getchar();
    while(c>'9'||c<'0'){if(c=='-') a=-1;c=getchar();}
    while(c>='0'&&c<='9'){b=(b<<1)+(b<<3)+c-'0';c=getchar();}
    return a*b;
}
void print(int x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) print(x/10);
    putchar(x%10+'0');
}
void add(int u,int v,int c,int f){
    edge[++cnt].u=u;edge[cnt].v=v;edge[cnt].cost=c;
    edge[cnt].flow=f;edge[cnt].from=last[u];last[u]=cnt;
}
int SPFA(){
    sign++;
    while(!q.empty()) q.pop_front();
    memset(dis,inf,sizeof(dis));
    memset(flow,inf,sizeof(flow));
    q.push_front(st);dis[st]=0;
    while(!q.empty())
    {
        int now=q.front();q.pop_front();in[now]=0;
        for(int i=last[now];i;i=edge[i].from)
        {
            int to=edge[i].v;
            if(dis[to]>dis[now]+edge[i].cost&&edge[i].flow)
            {
                dis[to]=dis[now]+edge[i].cost;
                fa[to]=now;way[to]=i;
                flow[to]=min(flow[now],edge[i].flow);
                if(in[to]!=sign)
                {
                    if(q.empty()) q.push_front(to);
                    else
                    {
                        if(dis[q.front()]>=dis[to]) q.push_front(to);
                        else q.push_back(to);
                    }
                    in[to]=sign;		
                }
            }
        }
    }
    return dis[ed]!=dis[0];
}
void min_cost_flow(){int tmp;
    fa[st]=0;
    flow_sum=min_cost=0;
    while(SPFA()){
        flow_sum+=flow[ed];min_cost+=flow[ed]*dis[ed];
        tmp=ed;
        while(fa[tmp]!=0)
        {
            edge[way[tmp]].flow-=flow[ed];
            edge[way[tmp]^1].flow+=flow[ed];
            tmp=fa[tmp];
        }
    }
}
int main(){int A;
    //freopen("123.txt","r",stdin);
   // freopen("1.out","w",stdout);
    m=read(),n=read();//n是顾客，m是技术人员
	//把每个技术人员分成n个连边 i--> n+(k-1)*m+i; 
	st=n*m+n+1,ed=n*m+n+2;
    for(int i=1;i<=n;++i)
    {
    	add(st,i,0,1);add(i,st,0,0);
    	for(int j=1;j<=m;++j)
    	{
    		A=read();
    		for(int k=1;k<=n;++k) 
			{
				add(i,n+(j-1)*n+k,k*A,1),add(n+(j-1)*n+k,i,-A*k,0);   
			}	
		}
	}
	for(int i=1;i<=m;++i)
	{
		for(int j=1;j<=n;++j)
		{
			add(n+(i-1)*n+j,ed,0,1);
			add(ed,n+(i-1)*n+j,0,0);
		}
	}
	min_cost_flow();
	printf("%.2f",(min_cost*1.0/n*1.0));
    return 0;
} 
~~~

---

## 作者：k，火魂 (赞：0)

~~高级技工登场~~


看到题目，紫题，~~看题解~~

费用流??仔细想想，确实是费用流
怎么看出来：每辆车很明显都要被修好，而且需要求出最小费用，当然是费用流了
~~其实全是瞎bb，我本来以为是区间DP的，发现对于每个技术人员都有不同的修理时间，不会转移~~。

费用流套模板就可以了，不会模板就去学。~~实在懒得讲~~

网络流模板比较单一，一般都是模板。主要考虑建图，~~建图全TM是省选~~。

建图先考虑最简单的情况，就是关于每个技术人员和每个人建图，然后轻易发现问题：时间是费用，但是每个技工可能在很久之后才开始修这辆车，时间就会被拉长，这样建图那么不能找到每名技工不同时刻修这辆车的时间，那么把每个技工分开（网络流惯用手法：劈开），分成n*m个，关于每个技工不同时间修车建图，第i个技工j时刻修某辆车的费用就是c*j。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#define itn int
using namespace std;
const int N=10010,M=1e5+10;
int ver[M],hea[N],nex[M],edge[M],cost[M];
int d[N],pre[N],incf[N];
bool v[N];
queue<int>q;
int n,m,tot=1,s,t,flow,ans,maxflow;

inline void add(int x,int y,int z,int c){
	ver[++tot]=y;nex[tot]=hea[x];hea[x]=tot;
	edge[tot]=z;cost[tot]=c;
	ver[++tot]=x;nex[tot]=hea[y];hea[y]=tot;
	edge[tot]=0;cost[tot]=-c;
}

inline bool spfa(){
	memset(d,0x7f,sizeof(d));int oo=d[1];
	memset(v,0,sizeof(v));
	while(q.size())q.pop();
	q.push(s);v[s]=1;d[s]=0;
	incf[s]=1<<30;;
	while(q.size()){
		int x=q.front();q.pop();v[x]=0;
		for(int i=hea[x];i;i=nex[i]){
			if(!edge[i])continue;
			int y=ver[i];
			if(d[y]>d[x]+cost[i]&&edge[i]>0){
				d[y]=d[x]+cost[i];
				incf[y]=min(incf[x],edge[i]);
				pre[y]=i;
				if(!v[y])q.push(y),v[y]=1;
			}
		}
	}
	if(d[t]==oo)return false;
	else return true;
}

inline int calc(){
	int x=t;
	while(x!=s){
		int i=pre[x];
		edge[i]-=incf[t];
		edge[i^1]+=incf[t];
		x=ver[i^1];
	}
	maxflow+=incf[t];
	return d[t]*incf[t];
}

int main()
{
	scanf("%d%d",&m,&n);s=n+n*m+1,t=n+n*m+2;
	for(int i=1;i<=n;i++)add(s,i,1,0);
	for(int i=1;i<=n;i++){
		for(itn j=1;j<=m;j++){
			int c;scanf("%d",&c);
			for(int k=1;k<=n;k++){
				add(i,j*n+k,1,c*k);
			}
		}
	}
	for(int i=1;i<=n*m;i++){
		add(n+i,t,1,0);
	}
	while(spfa()){
		int p=calc();
		ans+=p;
	}
	printf("%.2lf",(double)ans/n);
	return 0;
}
```


---

## 作者：z1431346079 (赞：0)

![](https://m.qpic.cn/psb?/V11sk9wJ3UQAvi/WNkECsMb.6Je42R3g5tJRG1KAE4EYVohixcmTaEs9tg!/b/dEYBAAAAAAAA&bo=TgKRAU4CkQEDCSw!&rf=viewer_4&t=5)

[](https://m.qpic.cn/psb?/V11sk9wJ3UQAvi/WNkECsMb.6Je42R3g5tJRG1KAE4EYVohixcmTaEs9tg!/b/dEYBAAAAAAAA&bo=TgKRAU4CkQEDCSw!&rf=viewer_4)

如图

设f[i][j]为表示第j位技术人员维修第i辆车需要用的时间

第一步：将每个工人分为不同时间点的状态（即修了多少辆车），由源点向各个状态连流量为1且费用为0的边。

第二步：由不同时间点（共修了tim次车（包括此次））的工人i（编号为(i-1)*m+tim）向顾客k连一条流量为1且费用为tim*f[i][j]的边。

第三步：由每位顾客向汇点连流量为1且费用为0的边。

代码如下
（其实是直接复制以前做的题的）


```cpp
#include<bits/stdc++.h>
using namespace std;
#define swap(x,y) x^=y,y^=x,x^=y
#define R register
#define I inline
#define B bool
#define V void
#define ll long long
I int read()
{
    R int f=1,num=0;
    R char ch=getchar();
    while(0==isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(0!=isdigit(ch)) num=(num<<1)+(num<<3)+ch-'0',ch=getchar();
    return num*f;
}
const int N=200007;
const int inf=1e9;
const int dx[]={-1,1, 0,0};
const int dy[]={ 0,0,-1,1};
B v[N];
int dis[N];
int n,s,t,res=0,ans=0;
int tot=1;
int head[N],next[N<<1],to[N<<1],edge_c[N<<1],edge_cc[N<<1];
I V add(R int x,R int y,R int z,R int zz)
{
    next[++tot]=head[x],head[x]=tot,to[tot]=y;
    edge_c[tot]=z;edge_cc[tot]=zz;
}
I V Add(R int x,R int y,R int z,R int zz)
{
    add(x,y,z,zz);
    add(y,x,0,-zz);
}
I B spfa()
{
    memset(v,0,sizeof(v));
    for(R int i=0;i<=t;i++)dis[i]=inf;
    dis[s]=0;v[s]=1;
    deque<int>q;
    q.push_back(s);
    while(q.size())
    {
        R int x=q.front();
        q.pop_front();
        v[x]=0;
        for(R int i=head[x];i;i=next[i])
        {
            R int y=to[i];
            if(edge_c[i]>0&&dis[x]+edge_cc[i]<dis[y])
            {
                dis[y]=dis[x]+edge_cc[i];
                if(!v[y])
                {
                    v[y]=1;
                    if(!q.empty()&&dis[y]<dis[q.front()])q.push_front(y);
                    else q.push_back(y);
                }
            }
        }
    }
    return dis[t]<inf;
}
int dfs(R int x,R int low)
{
    v[x]=1;
    if(x==t)
    {
        res+=low;
        return low;
    }
    R int used=0,delta=0;
    for(R int i=head[x];i;i=next[i])
    {
        R int y=to[i];
        if(!v[y]&&edge_c[i]&&dis[y]==dis[x]+edge_cc[i])
        {
            delta=dfs(y,min(edge_c[i],low-used));
            ans+=delta*edge_cc[i],edge_c[i]-=delta,edge_c[i^1]+=delta,used+=delta;
            if(used==low)break;
        }
    }
    return used;
}
V costflow()
{
    res=ans=0;
    while(spfa())
    {
        v[t]=1;
        while(v[t])
        {
            memset(v,0,sizeof(v));
            dfs(s,inf);
        }
    }
}
//以上是zkw费用流的板子
int m;
int f[70][70];
int main()
{
	n=read();m=read();
	s=0;t=701;
	R int num=n*m;
	for(R int i=1;i<=m;i++)
	{
		for(R int j=1;j<=n;j++)
		{
			f[i][j]=read();
		}
	}
	for(R int i=1;i<=num;i++)
	{
		Add(s,i,1,0);
	}//第一步
	for(R int i=num+1;i<=num+m;i++)
	{
		Add(i,t,1,0);
	}//第三步
	for(R int i=1;i<=n;i++)//工人 
	{
		for(R int tim=1;tim<=m;tim++)//时间戳 
		{
			for(R int k=1;k<=m;k++)//顾客 
			{
				Add((i-1)*m+tim,n*m+k,1,f[k][i]*tim);
			}
		}
	}//第三步
	costflow();
	printf("%.2lf",(double)ans/m);//除以顾客数后记得保留两位小数
//	cout<<ppo<<endl;
	return 0;
}
```


---

## 作者：秋日私语 (赞：0)

题目
-

[传送门](http://www.lydsy.com/JudgeOnline/problem.php?id=1070)

题解
-

原本想到的是[星际战争](http://blog.csdn.net/a_comme_amour/article/details/79615838)一样二分最大流。然而这题与其不同的是每个人修的车有先后顺序，某一人修某一辆车会受到上一辆车的影响，也就是这一辆车是这个人第几个和修的对于总时间的贡献有很大的影响（倒数第一个人修只需要花一倍的时间，倒数第二个人修需要花两倍的时间……）。
于是我们把每一种状态都拆成点，每一个人拆出n（车的数量）个点（共拆出n *m个点），每辆车都向这n*m和点连边，容量为1,，费用为time[car][peo] * t (t表示这辆车被这个人倒数第几个修)，表示在当前状态下人修车对总时间的贡献；
想一想在同一时刻最多只有m个人修车，这是符合实际情况的。
S向车，m*n个人向T连边，容量为1费用为0，跑出最小费用即为答案。

代码
-

见[这里](http://blog.csdn.net/a_comme_amour/article/details/79634412)

总结
-

把每一种状态都拆点的思想

---


# [JSOI2010] 巨额奖金

## 题目描述

 NJ 市的快速发展得益于其便捷的交通。可是，随着经济的发展，大量的人进入 NJ 市， NJ 市的交通也承受着巨大的压力。现在， NJ 市正在筹划建设一个新型的交通枢纽，从而减轻交通的压力。

 NJ 市包含 $n$ 个区，有些区之间有双向的干道存在。新型交通枢纽建设在这些干道的基础上，将其中的部分干道改进为新型干道。改进后，干道能承受的压力可以比原来增加几十倍。为了和谐发展，在新型的交通枢纽建成后，要求任何两个区之间都可以只通过新型干道（直接或间接地）连接。政府已经预测出每条干道改进为新型干道的费用。政府希望建设新型交通枢纽的总费用最小，并以巨额奖金向市民征集方案。政府很快发现费用最小的方案不一定唯一，所以决定将奖金平分给每一种方案的第一个设计者，即如果一个人设计的费用是最小的而且前面没人和他设计出一模一样的方案，则他可获奖。

 Js08 被奖金深深的吸引，准备设计一种方案。可是，他发现方案可能会很多，如果最后获奖者太多，巨额的资金分到每个人头上的也不会太多。所以他决定先算一下可行的方案数是多少。


## 说明/提示

### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n \leq 100$，$1 \leq m \leq 1000$，$1 \leq a _ i, b _ i \leq n$，$1 \leq c _ i \leq 10 ^ 9$。

## 样例 #1

### 输入

```
4 6
1 2 1
1 3 1
1 4 1
2 3 2
2 4 1
3 4 1
```

### 输出

```
8```

# 题解

## 作者：Night_Aurora (赞：7)

对此我们先求一遍最小生成树，如果无法生成树就输出0

然后记录最小生成树上的每个权值的边有几条

对于权值为W的边，最小生成树上有k条

那么把这些边从最小生成树上去掉，会形成编号为$B_1-B_{k+1}$的连通块

那么在所有边权为W的边中选k条，只要能把这k+1个连通块连起来，就是这个权值的一个方案

根据乘法原理，总方案数就是上面所有权值的乘积

试着证明一下正确性

在原最小生成树中，权值为W的k条边的唯一作用就是把$B_1-B_{k+1}$给联通

而我们换另外k条边的一个组合，只要能连通这些k+1个连通块，在生成树中的作用就等价于原来k条边，所以可以证明计算出的最小生成树个数一定分别对应一种真实存在的最小生成树

反过来，对于一个最小生成树，假设它没有被计数，那有两种可能性

一种是某种权值的边个数与原最小生成树不一样，那可以证明这两个生成树一定至少有一个不是最优的，与前面矛盾

另一种是某个权值的边未能连通原k+1个连通块，不算重边的话，一定有一条边的两个端点都在原一个连通块里，因为原最小生成树是最优的，所以可证明这种情况不成立

从而反证出没有合法的最小生成树没有被计数

计数就是最小生成树个数得证


唠叨这么长了，代码就不贴了，贴个链接吧

[没有注释的代码](http://paste.ubuntu.com/25377013/)


---

## 作者：Purslane (赞：2)

# Solution

考虑用 Kruskal 求 MST 的过程。

如果当前要加入的边是所有边中**严格最小的**，那么加入它必定是不劣的，这时候就只有一种情况。

我们只需要处理目前有很多并列最小的情况。注意到这些边全部加入会对图产生一定实质性的改变（把若干个不连通的连通块变成联通的）。那么假设当前所有权值为 $w$ 的边可以合并连通块 $S_1$，$S_2$，$\dots$，$S_k$，我们必定选择了 $k-1$ 条边，且恰好合并了 $k$ 个连通块。（森林的情况类似）

接下来的思路就很明朗了：每次合并的连通块缩成一个点，然后对当且合并的连通块使用矩阵树定理。

下面分析复杂度。如果我们对于一个 $k$ 阶矩阵使用了矩阵树定理，那么必定会消失 $k$ 个连通块。因此有：

$$
\sum k_i = n-1
$$

而辗转相除求行列式的复杂度为 $O(n^3)$，所以总的操作次数为：

$$
\sum k_i^3 \le (\sum k_i)^3 = O(n^3)
$$

代码：

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=100+10,MOD=31011;
struct Matrix {int n,a[MAXN][MAXN];};
int det(Matrix A) {
	int mul=1; int n=A.n;
	ffor(i,1,n) ffor(j,1,n) A.a[i][j]=(A.a[i][j]%MOD+MOD)%MOD;
	ffor(i,1,n) {
		if(!A.a[i][i]) {
			ffor(j,i+1,n) if(A.a[j][i]) {swap(A.a[i],A.a[j]);break ;}
			if(!A.a[i][i]) return 0;	
		}
		ffor(j,i+1,n) {
			int val1=A.a[i][i],val2=A.a[j][i];
			while(val1&&val2) {
				if(val1>=val2) {
					ffor(k,i,n) A.a[i][k]=((A.a[i][k]-A.a[j][k]*(val1/val2))%MOD+MOD)%MOD;
					val1%=val2;
				}
				else {
					ffor(k,i,n) A.a[j][k]=((A.a[j][k]-A.a[i][k]*(val2/val1))%MOD+MOD)%MOD;
					val2%=val1;	
				}
			}
			if(val2) mul=-mul,swap(A.a[i],A.a[j]);
		}
	}
	ffor(i,1,n) mul=mul*A.a[i][i]%MOD;
	return (mul+MOD)%MOD;
}
vector<int> T[MAXN];
int ans=1,n,m,tot,fa[MAXN],flg[MAXN],id[MAXN];
int find(int k) {return (fa[k]==k)?k:(fa[k]=find(fa[k]));}
map<int,vector<pair<int,int>>> mp;
vector<int> vec;
void dfs(int u) {
	vec.push_back(u),id[u]=++tot;	
	for(auto v:T[u]) if(!id[v]) dfs(v);
	return ;
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m; ffor(i,1,n) fa[i]=i;
	ffor(i,1,m) {int u,v,w;cin>>u>>v>>w,mp[w].push_back({u,v});}
	for(auto pr:mp) {
		auto vc=pr.second; tot=0;
		ffor(i,1,n) flg[i]=0,T[i].clear(),id[i]=0;
		for(auto Pr:vc) {
			int u=find(Pr.first),v=find(Pr.second);
			if(u!=v) T[u].push_back(v),T[v].push_back(u),flg[u]=flg[v]=1;
		}
		ffor(i,1,n) {
			if(flg[i]&&!id[i]) {
				tot=0,vec.clear(),dfs(i);
				Matrix mat;
				mat.n=vec.size()-1; ffor(i,1,mat.n) ffor(j,1,mat.n) mat.a[i][j]=0;
				for(auto u:vec) for(auto v:T[u]) mat.a[id[u]][id[u]]++,mat.a[id[u]][id[v]]--;
				ans=ans*det(mat)%MOD;
			}
		}
		for(auto Pr:vc) fa[find(Pr.first)]=find(Pr.second);
	}
	int cnt=0;
	ffor(i,1,n) cnt+=(find(i)==i);
	cout<<(cnt==1)*ans;
	return 0;
}
```

---

## 作者：PCCP (赞：0)

## 前置知识：

* 矩阵树定理，简要说明请看 [P4111 zhy137036 的题解](https://www.luogu.com.cn/problem/solution/P4111)，抽象但详细的证明请看 [oiwiki](https://oi-wiki.org/graph/matrix-tree/)；

* 最小生成树相关性质。

## 思考做法：

最小生成树有一个性质，就是每一个最小生成树上，同一权值的边的数量是固定不变的，且不同权值的边之间互不影响。我印象里我第一次是在一道利用这个性质来复杂离线用并查集统计方案的题目里看到这条性质的，具体是那一道已经忘记了，读者可以帮我一起回想一下这道题是什么来着。

### 这里简要证明一下这个性质：

假设当前权值为 $ w $，我们已经完成了所有权值小于等于 $ w $ 的边的构造，形成了最小生成树森林。我们删去一条边就会改变连通性；增加一条剩余边，则这一条边连接的两点都一定在同一个连通块内，这条边的存在就是多余的。所以数量具有唯一性。由于数量唯一，所以不同边权之间不会影响某一边权的数量。

那到这里，做法就很明晰了。求某一边权下最小生成树的方案数，再把不同边权乘起来即可。

求最小生成树的方案数，用矩阵树定理即可。这里我们用辗转相除法的高斯消元，其时间复杂度是 $ \Theta(n^3+n^2\log_2{P}) $ 的，这里的 $ P $ 是模数，由于这里 $ \log_2{P} < 15 $，所以我们视时间复杂度为 $ O(n^3) $。

## 实现细节：

* 无论你怎么构造矩阵，你都必须保证矩阵内的所有点都有边，即矩阵内对应的行列上的值不能都为空。

* 同一权值内可能生成最小生成树森林。

* 一条边的两端点可能此前早已在同一连通块内。

这里为了解决这些问题。我选择向每一条的两端点的父节点连边，把端点的父节点加入矩阵；接着把所有该边权的边合并；然后对于剩下的父节点，同虚拟源点连边。

这样，同时保证最小生成树森林变为了单一最小生成树（步骤三），也保证虚拟源点不会向一个原虚拟源点连多条边而增加方案数（步骤二和三），这样正确性不受影响。

## 代码：

我调了一天的代码，还是别复制了吧。

```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<vector>
#include<queue>
#include<stack>
#include<set>
using namespace std;
#define int long long
const int N=110;
const int M=1e3+10;
const int mod=31011;
int n,m,fa[N],blocnt;
long long res=1;
bool st[N];
struct edge{
	int x,y,w;
}e[M];
bool cmp(edge a,edge b){
	return a.w<b.w;
}
struct matrix{
	int n;
	long long a[N][N];
}lap;
int Gauss(){
	int ans=1;
	lap.n--;
	for(int i=1;i<=lap.n;++i) {
		for(int k=i+1;k<=lap.n;++k) {
			while(lap.a[k][i]) {
				int d=lap.a[i][i]/lap.a[k][i];
				for(int j=i;j<=lap.n;++j){
					lap.a[i][j]=(lap.a[i][j]-1LL*d*lap.a[k][j]%mod+mod)%mod;
				}
				swap(lap.a[i],lap.a[k]);
				ans=-ans;
			}
		}
		ans=1LL*ans*lap.a[i][i]%mod;
		ans=(ans+mod)%mod;
	}
	return ans;
}
int find(int x){
	if(fa[x]==x){
		return x;
	}
	return fa[x]=find(fa[x]);
}
void unify(int x,int y){
	fa[find(y)]=find(x);
}
int seq[N],cnt;
main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%lld%lld%lld",&e[i].x,&e[i].y,&e[i].w);
	}
	sort(e+1,e+m+1,cmp);
	int ceiling=0;
	for(int i=1;i<=n;i++){
		fa[i]=i;
	}
	blocnt=n;
	for(int i=1;i<=m;i++){
		if(find(e[i].x)!=find(e[i].y)){
			blocnt--;
			unify(find(e[i].x),find(e[i].y));
		}
		if(blocnt==1&&!ceiling){
			ceiling=e[i].w;
		}
	}
	if(blocnt>1){
		printf("0\n");
		exit(0);
	}
	for(int i=1;i<=n;i++){
		fa[i]=i;
	}
	int cur;
	for(int i=1;i<=m;i++){
		cur=i;
		if(e[i].w>ceiling){
			break;
		}
		for(;i<=m;i++){
			int fx=find(e[i].x),fy=find(e[i].y);
			if(fx!=fy){
				if(!seq[fx]){
					seq[fx]=++cnt;
				}
				if(!seq[fy]){
					seq[fy]=++cnt;
				}
				lap.a[seq[fx]][seq[fx]]++;
				lap.a[seq[fy]][seq[fy]]++;
				lap.a[seq[fx]][seq[fy]]--;
				lap.a[seq[fy]][seq[fx]]--;
			}
			if(e[i].w!=e[i+1].w){
				break;
			}
		}
		for(int j=cur;j<=i;j++){
			int fx=find(e[j].x),fy=find(e[j].y);
			if(fx!=fy){
				unify(fx,fy);
			}
		}
		for(int j=1;j<=n;j++){
			int fj=find(j);
			if(!st[fj]&&seq[fj]){
				lap.a[seq[fj]][seq[fj]]++;
				lap.a[cnt+1][cnt+1]++;
				lap.a[seq[fj]][cnt+1]--;
				lap.a[cnt+1][seq[fj]]--;
			}
			st[fj]=true;
		}
		lap.n=cnt+1;
		res*=Gauss();
		res%=mod;
		for(int j=1;j<=n;j++){
			st[j]=false;
			seq[j]=0;
			for(int k=1;k<=n+1;k++){
				lap.a[j][k]=0;
			}
		}
		cnt=0;
	}
	printf("%lld\n",(res%mod+mod)%mod);
}
```

---


# [SDOI2008] 洞穴勘测

## 题目描述

辉辉热衷于洞穴勘测。

某天，他按照地图来到了一片被标记为 JSZX 的洞穴群地区。经过初步勘测，辉辉发现这片区域由 $n$ 个洞穴（分别编号为 $1$ 到 $n$）以及若干通道组成，并且每条通道连接了恰好两个洞穴。假如两个洞穴可以通过一条或者多条通道按一定顺序连接起来，那么这两个洞穴就是连通的，按顺序连接在一起的这些通道则被称之为这两个洞穴之间的一条路径。洞穴都十分坚固无法破坏，然而通道不太稳定，时常因为外界影响而发生改变，比如，根据有关仪器的监测结果，$123$ 号洞穴和 $127$ 号洞穴之间有时会出现一条通道，有时这条通道又会因为某种稀奇古怪的原因被毁。

辉辉有一台监测仪器可以实时将通道的每一次改变状况在辉辉手边的终端机上显示：

- 如果监测到洞穴 $u$ 和洞穴 $v$ 之间出现了一条通道（**保证原来没有**），终端机上会显示一条指令 `Connect u v`。
- 如果监测到洞穴 $u$ 和洞穴 $v$ 之间的通道被毁（**保证原来存在**），终端机上会显示一条指令 `Destroy u v`。

经过长期的艰苦卓绝的手工推算，辉辉发现一个奇怪的现象：无论通道怎么改变，任意时刻任意两个洞穴之间至多只有一条路径。

因而，辉辉坚信这是由于某种本质规律的支配导致的。因而，辉辉更加夜以继日地坚守在终端机之前，试图通过通道的改变情况来研究这条本质规律。然而，终于有一天，辉辉在堆积成山的演算纸中崩溃了……他把终端机往地面一砸（终端机也足够坚固无法破坏），转而求助于你，说道：“你老兄把这程序写写吧。”

辉辉希望能随时通过终端机发出指令 `Query u v`，向监测仪询问此时洞穴 $u$ 和洞穴 $v$ 是否连通。现在你要为他编写程序回答每一次询问。已知在第一条指令显示之前，JSZX 洞穴群中没有任何通道存在。

## 说明/提示

对于 $(i \times 10)\%$ 的数据，$n \le i \times 10^3$，$m \le 2i \times 10^4$。

对于 $100\%$ 的数据，$1 \le n \le 10^4$，$1 \le m \le 2 \times 10^5$，$1 \le u,v \le n$，所有指令都是合法的。

本题 I/O 规模比较大，建议 C/C++ 选手使用 `scanf` 和 `printf` 进行 I/O 操作以免超时。

---

@namespace_std 于 2019.12.1 添加一组 Hack 数据

## 样例 #1

### 输入

```
200 5
Query 123 127
Connect 123 127
Query 123 127
Destroy 127 123
Query 123 127```

### 输出

```
No
Yes
No
```

## 样例 #2

### 输入

```
3 5
Connect 1 2
Connect 3 1
Query 2 3
Destroy 1 3
Query 2 3```

### 输出

```
Yes
No```

# 题解

## 作者：斯德哥尔摩 (赞：25)

一看就知道是 LCT 裸题，直接上模板。。。

这年头，题解怎么都喜欢用数组，唯一的结构体题解还用了指针，郁闷ing。。。

所以，我来一发 无指针结构体，自我感觉挺好。。。

还有那啥，不要用 STL 的栈，会 RE/WA 的。。。

附上代码（紧紧凑凑80+行）：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#define MAXN 10010//数组大小
#define MAX 999999999//极值
using namespace std;
int n,m;
struct node{//有父无指针结构体
    int son[2];
    int f,flag;
}a[MAXN];
inline int read(){//读优
    int date=0,w=1;char c=0;
    while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
    while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
    return date*w;
}
inline int isroot(int rt){//是否是根
    return a[a[rt].f].son[0]!=rt&&a[a[rt].f].son[1]!=rt;
}
inline void pushdown(int rt){//标记下传
    if(!rt||!a[rt].flag)return;
    a[a[rt].son[0]].flag^=1;a[a[rt].son[1]].flag^=1;a[rt].flag^=1;
    swap(a[rt].son[0],a[rt].son[1]);//别忘了交换左右节点。。。
}
inline void turn(int rt){//旋转，改进版
    int x=a[rt].f,y=a[x].f,k=a[x].son[0]==rt?0:1;
    if(!isroot(x)){//就是这里，判断是否是根
        if(a[y].son[0]==x)a[y].son[0]=rt;
        else a[y].son[1]=rt;
    }
    a[rt].f=y;a[x].f=rt;a[a[rt].son[!k]].f=x;
    a[x].son[k]=a[rt].son[!k];a[rt].son[!k]=x;
}
void splay(int rt){//伸展，也是改进版，应为要适应LCT。。。
    int top=0,stack[MAXN];//果断手写栈
    stack[++top]=rt;//第一个一定是根
    for(int i=rt;!isroot(i);i=a[i].f)stack[++top]=a[i].f;
    while(top)pushdown(stack[top--]);//暴力修改
    while(!isroot(rt)){//这里就基本无大改了
        int x=a[rt].f,y=a[x].f;
        if(!isroot(x)){
            if((a[x].son[0]==rt)^(a[y].son[0]==x))turn(rt);
            else turn(x);
        }
        turn(rt);//注意，是最后才进行，当初我把这句放到里面，然后就 WA 了。。。
    }
}
void access(int rt){//将 x 与 x所在树的根 连一条链
    for(int i=0;rt;i=rt,rt=a[rt].f){//暴力修改，耗时贼多，没有之一。。。
        splay(rt);
        a[rt].son[1]=i;
    }
}
inline void makeroot(int rt){access(rt);splay(rt);a[rt].flag^=1;}//将 x 变为树根
int find(int rt){//找树根
    access(rt);splay(rt);
    while(a[rt].son[0])rt=a[rt].son[0];//一直往左走
    return rt;
}
inline void split(int x,int y){makeroot(x);access(y);splay(y);}搞出 x与y的链
inline void cut(int x,int y){//割 x与y的链
    split(x,y);
    a[y].son[0]=a[x].f=0;
}
inline void link(int x,int y){makeroot(x);a[x].f=y;}//连 x与y的链
int main(){
    char ch[10];
    int x,y;
    n=read();m=read();
    while(m--){
        scanf("%s",ch);x=read();y=read();
        if(ch[0]=='C')link(x,y);
        if(ch[0]=='D')cut(x,y);//基本操作不再多说。。。
        if(ch[0]=='Q'){
            if(find(x)==find(y))printf("Yes\n");//判断联通
            else printf("No\n");
        }
    }
    return 0;//终于敲完了（累死我了。。。）
}

```

---

## 作者：WAAutoMaton (赞：25)

这题主流的方法是用动态树维护边的连通性（具体做法可以参考其他题解）。

但此题不需要维护边权等信息，而且也没有强制在线，所以实际上可以不用动态树这么高端的数据结构。


<!--more-->

离线之后，我们可以知道每条边在图中出现的时间（一定是一个连续区间）。

对时间建立一棵线段树（范围为1～m），线段树的每个节点维护一个边集，代表完整出现在这段时间内的边的集合。

首先将所有的边插入线段树，由线段树的性质可知插入一条边的时间为 $O(logn)$ ，每条边最后只会落在$O(logn)$个节点上。

然后dfs整棵线段树，每进入一个节点就将这个节点维护的所有边插入并查集，当dfs结束时删除刚刚插入的这些边。

当dfs到叶子节点时，显然此时一条边在并查集内当且仅当这一时刻这条边存在，所以我们就可以回答这一时刻的询问。


注意到我们的并查集需要支持撤销操作，所以应当使用按秩合并的并查集。

向并查集插入一条边的时间为$O(logm)$，撤销插入的时间为$O(1)$，线段树上一共有$O(mlogm)$条边，每条边恰好会被插入一次撤销一次，因此总复杂度为$O(mlog^2m)$。由于常数小所以可以轻易跑过m=20W


于是我们就仅用线段树和并查集完成了本题。


#### 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 20000
#define MAXM 300000
int n,m;
struct Query
{
    int u,v;
    bool b;
    Query(int u=0,int v=0,bool b=false):u(u),v(v),b(b){}
}q[MAXM+10];
bool operator <(const Query&a,const Query&b)
{
    if (a.u==b.u) return a.v<b.v;
    return a.u<b.u;
}
struct BakData
{
    int x,y,sx,sy;
    BakData(int x=0,int y=0,int sx=0,int sy=0):x(x),y(y),sx(sx),sy(sy){}
};
int fa[MAXN+10];
int siz[MAXN+10];
int find(int x) 
{
    if (fa[x]==x) return x;
    return find(fa[x]);
}
BakData Union(int x,int y)  //并查集的合并操作，注意要返回操作前的信息以便撤销
{
    int fx=find(x),fy=find(y);
    if (siz[fx]>siz[fy]) swap(fx,fy);
    BakData t(fx,fy,siz[fx],siz[fy]);
    fa[fx]=fy;
    siz[fy]=siz[fx]+siz[fy];
    return t;
}
void undo(BakData t) //撤销上一次操作
{
    fa[t.x]=t.x;
    fa[t.y]=t.y;
    siz[t.x]=t.sx;
    siz[t.y]=t.sy;
}
typedef vector<Query>::iterator vit;
int ans[MAXM+10];
struct Node
{
    int l,r;
    Node *lc,*rc;
    vector<Query> e;
    void insert(int l,int r,const Query& q);
    void dfs(vit it)
    {
        if (it!=e.end())
        {
            BakData t=Union(it->u,it->v);
            dfs(it+1);
            undo(t);
            return;
        }
        if (l==r)
        {
            if (q[l].b)
            {
                ans[l]=find(q[l].u)==find(q[l].v)?1:-1;
            }
            return;
        }
        lc->dfs(lc->e.begin());
        rc->dfs(rc->e.begin());
    }
}node[2*MAXM+10];
Node* newNode(int l,int r)
{
    static int c=0;
    Node* now=node+ ++c;
    now->l=l; now->r=r;
    if (l==r)
    {
        now->lc=now->rc=node;
    }
    else
    {
        int mid=(l+r)/2;
        now->lc=newNode(l,mid);
        now->rc=newNode(mid+1,r);
    }
    return now;
}
void Node::insert(int l,int r,const Query& q)
{
    if (this->l==l && this->r==r)
    {
        e.push_back(q);
        return;
    }
    int mid=(this->l+this->r)/2;
    if (l<=mid) lc->insert(l,min(mid,r),q);
    if (r>mid) rc->insert(max(l,mid+1),r,q);
}
//vector<Query> q[MAXM+10];
char ch[20];
map<Query,int> ma; //这里使用了map维护边的出现时间
int main()
{
#ifndef ONLINE_JUDGE
    freopen("in.txt","r",stdin);
#endif
    scanf("%d%d",&n,&m);
    for(int i=1; i<=n; ++i) 
    {
        fa[i]=i;
        siz[i]=1;
    }
    Node* root=newNode(1,m);
    for(int i=1; i<=m; ++i)
    {
        int u,v;
        scanf("%s%d%d",ch,&u,&v);
        if (u>v) swap(u,v);
        if (ch[0]=='C')
        {
            ma[Query(u,v)]=i;
        }
        else if (ch[0]=='D')
        {
            Query t(u,v);
            map<Query,int>::iterator it=ma.find(t);
            assert(it!=ma.end());
            root->insert(it->second,i,t);    
            ma.erase(t);
        }
        else
        {
            q[i].u=u; q[i].v=v;            
            q[i].b=true;
        }
    }
    for(map<Query,int>::iterator it=ma.begin(); it!=ma.end(); ++it)
    {
        root->insert(it->second,m,it->first);
    }
    root->dfs(root->e.begin());
    for(int i=1 ;i<=m; ++i)
    {
        if (ans[i]==1) puts("Yes");
        else if (ans[i]==-1) puts("No");
    }
    return 0;
}
```

#### 参考文献

1. 吉如一的课件《老年人数据结构基础》


2. http://blog.csdn.net/qq\_33362864/article/details/74536978

##### 顺便宣传一下我的博客

http://waautomaton.tk/2017/10/18/bzoj-2049-lg-2147-SDOI-2008-Cave-洞穴勘测-题解/


---

## 作者：qwaszx (赞：8)

$LCT\ or\ $时间分治

因为$LCT$十分的板子，所以说一下时间分治

这个东西可以广泛运用于一些离线且不支持删除但支持撤销上一步的东西，比如并查集、$Trie$、线性基.

对时间建一棵线段树，然后把每条边的存在时间区间作为一个修改插进线段树，最后$dfs$一遍线段树得到询问.

$dfs$的时候，先往并查集里插入这个区间上的边，然后$dfs$左右儿子，然后撤销插入.

撤销就是把$fa$啊$size$什么的直接还原成刚才的状态.不能路径压缩，按秩合并.

考虑每条边会被拆成$O(\log m)$条，可撤销并查集是$O(\log m)$，所以总复杂度$O(m\log ^2m)$，**空间**$O(m\log m)$，数组要开大.

看代码吧.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<map>
using namespace std;
const int N=5e5;
struct Query{int x,y,b;bool operator <(const Query &a)const{return x==a.x?y<a.y:x<a.x;}}q[N],to[N*20];
struct Bk{int x,y,sx,sy;}stack[N*20];
int size[N],f[N],ans[N],n,m,mm,nxt[N*20],fst[N<<2];
void ade(int rot,Query q){to[++mm]=q,nxt[mm]=fst[rot],fst[rot]=mm;}//一开始用的vector，结果吸氧才能过，就邻接表了233
char st[1000];
map<Query,int>lst;
void update(int rot,int lt,int rt,int lq,int rq,Query q)
{
	if(lt>=lq&&rt<=rq){ade(rot,q);return;}//不需要pushdown，也许有点类似标记永久化???
	int mid=(lt+rt)>>1;
	if(rq<=mid)update(rot<<1,lt,mid,lq,rq,q);
	else if(lq>mid)update(rot<<1|1,mid+1,rt,lq,rq,q);
	else update(rot<<1,lt,mid,lq,mid,q),update(rot<<1|1,mid+1,rt,mid+1,rq,q);
}
int find(int x){return x==f[x]?x:find(f[x]);}
Bk merge(int x,int y)
{
	int fx=find(x),fy=find(y);
	if(size[fx]>size[fy])swap(fx,fy);//按秩合并
	Bk t=(Bk){fx,fy,size[fx],size[fy]};//这是一步撤销
	f[fx]=fy,size[fy]+=size[fx];return t;
}
void undo(Bk t){f[t.x]=t.x,f[t.y]=t.y,size[t.x]=t.sx,size[t.y]=t.sy;}
void push(int rot,int &top)
{
	for(int i=fst[rot];i;i=nxt[i])
		stack[++top]=merge(to[i].x,to[i].y);//用栈存下撤销
}
void pop(int lt,int rt){for(int i=rt;i>lt;i--)undo(stack[i]);}
void query(int rot,int lt,int rt,int tp)//要记录这个区间的撤销栈的起始位置
{
	int top=tp;push(rot,tp);
	if(lt==rt){if(q[lt].b)ans[lt]=find(q[lt].x)==find(q[lt].y);}//到叶子就回答询问
	else
	{
		int mid=(lt+rt)>>1;
		query(rot<<1,lt,mid,tp);
		query(rot<<1|1,mid+1,rt,tp);//递归左右儿子
	}
	pop(top,tp);//退栈
}
int main()
{
	scanf("%d%d",&n,&m);for(int i=1;i<=n;i++)f[i]=i;
	for(int i=1;i<=m;i++)
	{
		int x,y;
		scanf("%s%d%d",st+1,&x,&y);if(x>y)swap(x,y);
		switch(st[1])
		{
			case 'C':q[i]=(Query){x,y,0},lst[q[i]]=i;break;
			case 'D':q[i]=(Query){x,y,0},update(1,1,m,lst[q[i]],i,q[i]),lst.erase(q[i]);break;//map来记某条边的出现时间
			case 'Q':q[i]=(Query){x,y,1};break;
		}
	}
	for(map<Query,int>::iterator it=lst.begin();it!=lst.end();++it)update(1,1,m,it->second,m,it->first);//最后全加进去
	query(1,1,m,0);
	for(int i=1;i<=m;i++)if(q[i].b)puts(ans[i]?"Yes":"No");
}
```
时间分治还是很有启发性的，可以维护一些别的东西~~当然LCT对连通性题随便切~~

---

## 作者：λᴉʍ (赞：6)

帮忙刷刷访问量：http://www.cnblogs.com/xzz\_233/p/8064958.html

link-cut tree


动态树（准确说是维护森林）之一，支持连边，断边，求链上权值和等操作。


splay基础：会rotate和splay就行。还要会一点区间反转操作打标记。很基♂础的东西。


有重链，每条重链用splay来维护，splay中排名为这条重链中深度值，顺便把链的要维护信息（譬如链上点权和）统计了。


边分实边和虚边，实边有ch数组记录，虚边则没有。都有fa数组记录。

虚边链接两条重链。父子关系即原树的父子关系。


连到父亲的边为虚边的点就是这条重链的splay的根。

splay

splay(x)。先从上往下下放一遍，再执行splay。

注意rotate中如果y-z的边是虚边不用往回连。

access

access(x)。最主要操作&&最耗时间的操作，没有之一。


拉一条从x所在树的根节点到x的链。


从x开始往上拉，y初始化为0，每次先splay(x)，x左子树为连上去的重链，右子树为连下去的重链。

断掉右子树的边，连成y。（断边指实变虚

makeroot


makeroot(x)。将x变成x所在树的根。

先access(x)，这时有一条从root到x的重链。

然后splay(x)，再在x上打一个反转标记（这条重链上的深度要反转）

split

split(x,y)。搞出一条重链，两端点为x和y。

makeroot(x),access(y),splay(y)。

不多解释了？

（我习惯把这个直接写进代码，so看不到split函数）

link

link(x,y)。连一条x-y的边。

makeroot(x)，然后将FA♂x置为y。

这里连轻边没事的。

cut

cut(x,y)。割♂掉x-y的边。

split(x,y)，然后x在y左儿子处不解释。

FA♂x=ch[y][0]=0。

find

找到x所在树的根。主要用于判断连通性？？？

先access(x),splay(x),再一直往左边走就找到根了。不解释了。。。


---

## 作者：Enzymii (赞：5)

全世界都在用数组写LCT????
~~感觉坚持用指针的自己已经跟不上这个时代了~~

所以想找个很顺手的LCT板子都非常的困难QAQ

所以就来一发指针版LCT的板子..
~~万一有人和我一样想不开写指针呢~~

这题就LCT板子题嘛, 所以具体的思路其他dalao们都已经说得很详细了
我就过来水一发板子, 让刚入坑LCT的写指针的萌新(自己就是)有所参考吧.

代码(因为都是板子操作, 所以就不写注释了, 函数名和~~世界中大多数人的~~命名规范是基本一样的...
```
#include <cstdio>
#include <algorithm>
using namespace std;
const int N=20101;
inline int gn(int a=0,char c=0){
	for(;c<'0'||c>'9';c=getchar());
	for(;c>47&&c<58;c=getchar())a=a*10+c-48;return a;
}
struct node{
	node *fa,*ch[2];
	bool rev;
	bool getwh();
	bool isroot();
	void pushdown();
	void setch(bool wh,node* child);
}pool[N],*null; int tot;
bool node::getwh(){
	return fa->ch[1]==this;
}
bool node::isroot(){
	return fa==null||(fa->ch[0]!=this&&fa->ch[1]!=this);
}
void node::pushdown(){
	if(null==this||!rev) return;
	swap(ch[0],ch[1]);
	ch[0]->rev^=1; ch[1]->rev^=1;
	rev=0;
}
void node::setch(bool wh,node* child){
	pushdown(); ch[wh]=child;
	if(null!=child) child->fa=this;
}
void init(){
	null=pool; null->rev=0;
	null->fa=null->ch[0]=null->ch[1]=null;
}
node* newnode(){
	node* x=pool+ ++tot; x->rev=0;
	x->ch[0]=x->ch[1]=x->fa=null;
	return x;
}
void rotat(node* x){
	node *fa=x->fa,*fafa=fa->fa;
	if(fafa!=null) fafa->pushdown();
	fa->pushdown(); x->pushdown();
	int wh=x->getwh();
	if(fa->isroot()) x->fa=fa->fa;
	else fafa->setch(fa->getwh(),x);
	fa->setch(wh,x->ch[wh^1]);
	x->setch(wh^1,fa);
}
void fix(node* x){
	if(!x->isroot()) fix(x->fa);
	x->pushdown();
}
void splay(node* x){
	fix(x);
	for(;!x->isroot();rotat(x))
		if(!x->fa->isroot())
			x->getwh()==x->fa->getwh()?rotat(x->fa):rotat(x);
}
node* access(node* x){
	node* y=null;
	for(;x!=null;x=x->fa){
		splay(x); x->ch[1]=y; y=x;
	}
	return y;
}
void makeroot(node* x){
	access(x)->rev^=1;
	splay(x);
}
void link(node* x,node* y){
	makeroot(x); x->fa=y;
}
void cut(node* x,node* y){
	makeroot(x); access(y); splay(y);
	x->fa=y->ch[0]=null;
}
node* Find(node* x){
	for(access(x),splay(x);x->ch[0]!=null;x->pushdown(),x=x->ch[0]);
	return x;
}
int main(){ init();
	int n=gn(),m=gn();
	for(int i=1;i<=n;++i) newnode();
	char opt[123];
	for(int i=1;i<=m;++i){
		scanf("%s",opt);
		int x=gn(),y=gn();
		node *X=pool+x,*Y=pool+y;
		if(opt[0]=='Q')
			puts(Find(X)==Find(Y)?"Yes":"No");
		else if(opt[0]=='C')
			link(X,Y);
		else cut(X,Y);
	}	
}
```

---

## 作者：zh_dou (赞：4)

## 前置芝士
- LCT

 ...没了
## 分析
几乎就是 $LCT$ 的模板题了
#### 操作1
操作为 $link$
#### 操作2
操作为 $cut$
#### 操作3
操作为 $find\_root$
如果 $x~,~y$ 的 $root$ 相同，输出 $Yes$
否则输出 $No$
## 代码
$\mathcal{Code:}$
```cpp
#include<map>
#include<queue>
#include<cmath>
#include<cstdio>
#include<string>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<algorithm>
using namespace std;
#define N 300010
#define int long long
#define debug cout<<__LINE__<<" "<<__FUNCTION__<<"\n"
inline int read(){
	int x=0,y=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*y;
}
void put(int x){
	if(x<0) putchar('-'),x=-x;
	if(x>=10) put(x/10);
	putchar((x%10)+48);
}
struct LCT{//封装
	struct Node{
		int fa,ch[2],rev;//rev 为翻转标记
		Node(){fa=ch[0]=ch[1]=rev=0;}
	}tree[N];
	int top,res[N];//模拟栈
	#define ls(x) tree[x].ch[0]
	#define rs(x) tree[x].ch[1]
	inline int Nroot(int x){return tree[x].fa&&(ls(tree[x].fa)==x||rs(tree[x].fa)==x);}//判断是否是Splay的根（有父亲且父亲认儿子）
	inline void Rev(int x){swap(ls(x),rs(x));tree[x].rev^=1;}
	inline void Pushdown(int x){//标记下放
		if(!tree[x].rev) return;
		if(ls(x)) Rev(ls(x));
		if(rs(x)) Rev(rs(x));
		tree[x].rev=0;
	}
	inline void Rotate(int x){
		int y=tree[x].fa,z=tree[y].fa,k=(x==ls(tree[x].fa)),w=tree[x].ch[k];
		if(Nroot(y)) tree[z].ch[y==rs(tree[y].fa)]=x;
		tree[x].ch[k]=y;tree[y].ch[!k]=w;
		tree[y].fa=x;tree[x].fa=z;
		if(w) tree[w].fa=y;
	}
	inline void Splay(int x){
		int tmp=x;
		res[top=1]=tmp;
		while(Nroot(tmp)) res[++top]=tree[tmp].fa,tmp=tree[tmp].fa;//一定记得下放标记
		while(top) Pushdown(res[top]),--top;
		while(Nroot(x)){
			if(Nroot(tree[x].fa)) Rotate((x==rs(tree[x].fa))^(tree[x].fa==rs(tree[tree[x].fa].fa))?x:tree[x].fa);
			Rotate(x);
		} 
	}
	inline void Access(int x){
		int y=0;
		while(x){
			Splay(x);rs(x)=y;y=x;x=tree[x].fa;
		}
	}
	inline void Makeroot(int x){//转成整棵树的根
		Access(x);Splay(x);Rev(x);
	}
	inline int Findroot(int x){//找根
		Access(x);Splay(x);Pushdown(x);
		while(ls(x)){
			x=ls(x);Pushdown(x);
		}
		return x;
	}
	inline void Link(int x,int y){
		if(Findroot(x)==Findroot(y)) return;
		Makeroot(x);tree[x].fa=y;
	}
	inline void Cut(int x,int y){
		Makeroot(x);Access(y);Splay(y);
		if(ls(y)==x) tree[x].fa=ls(y)=0;
	}
}Tree;
int n,m;
signed main(){
// 	freopen(".in","r",stdin);
// 	freopen(".out","w",stdout);
	n=read();m=read();
	char ch[20];
	for(int i=1,x,y;i<=m;i++){
		scanf("%s", ch);x=read();y=read();
		if(ch[0]=='C') Tree.Link(x,y);
		if(ch[0]=='D') Tree.Cut(x,y);
		if(ch[0]=='Q') cout<<(Tree.Findroot(x)==Tree.Findroot(y)?"Yes\n":"No\n");
	}
//	fclose(stdin);
//	fclose(stdout);
    return 0;
}


```

---

## 作者：SunsetSamsara (赞：3)

### 前置知识
LCT（动态树）

动态树：是一种森林，支持动态连接、删除、求权值等操作，算是加强版并查集。动态树为了使把一个节点旋转到根与翻转区间操作时间复杂度降低到 $O(log_2n)$，一般使用 Splay 维护。

动态树操作：

1. `rotate` 操作与 `splay` 操作

同 Splay 中的 rotate 与 splay 操作

2. `pushdown` 操作

处理翻转区间的 tag，如果有 tag 就给子节点翻转一遍后交换子结点。

3. `access` 操作

就是把节点 $x$ 到那个节点的根节点强行造出一条链。是 LCT 的一个最基本的操作

4. `makeroot` 操作

就是把 $x$ 旋转到成为它那条链的根，先 `access` 一遍之后把 $x$ 旋转到那条链的 splay 树的根节点，再交换左右节点，即把它的祖宗节点变成子孙节点，它就成了根节点了。

5. `split` 操作

就是把 $x$ 与 $y$ 之间连接上一条链。

先 `makeroot(x)`，再 `access(x)` 造链，`splay(y)` 把 $y$ 旋转到根。

6. `link` 操作

`makeroot(x)` 后把 $x$ 的父亲赋值为 $y$，和并查集差不多

7. `cut` 操作
类似地，造一条链后尝试拆开 $x$，$y$。
### 分析
这道题是利用 LCT 维护连通性的模板题。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define lld long long
int n,m;
int val[300001];
struct LCT{
	int top;
	int sons[300001][2];
	int fa[300001];
	int q[300001];
	int rev[300001];
	void pushdown(int id){
		int l=sons[id][0],r=sons[id][1];
		if(rev[id]){
			rev[l]^=1;rev[r]^=1;rev[id]^=1;
			swap(sons[id][0],sons[id][1]);
		}
	}
	bool isroot(int id){return sons[fa[id]][0]!=id&&sons[fa[id]][1]!=id;}
	void rotate(int id){
		int f=fa[id],ff=fa[f],l,r;
		if(sons[f][0]==id)l=0;else l=1;r=l^1;
		if(!isroot(f)){
			if(sons[ff][0]==f)sons[ff][0]=id;
			else sons[ff][1]=id;
		}
		fa[id]=ff;fa[f]=id;fa[sons[id][r]]=f;
		sons[f][l]=sons[id][r];sons[id][r]=f;
	}
	void splay(int id){
		top=1;q[top]=id;
		for(int i=id;!isroot(i);i=fa[i])q[++top]=fa[i];
		for(int i=top;i;--i)pushdown(q[i]);
		int f,ff;
		while(!isroot(id)){
			f=fa[id];ff=fa[f];
			if(!isroot(f)){
				if((sons[f][0]==id)^(sons[ff][0]==f))rotate(id);
				else rotate(f);
			}
			rotate(id);
		}
	}
	void access(int id){
		for(int t=0;id;t=id,id=fa[id])
			splay(id),sons[id][1]=t;
	}
	void makeroot(int id){
		access(id);
		splay(id);
		rev[id]^=1;
	}
	int findroot(int id){
		access(id);
		splay(id);
		while(sons[id][0])id=sons[id][0];
		return id;
	}
	void split(int x,int y){
		makeroot(x);
		access(y);
		splay(y);
	}
	void cut(int x,int y){
		split(x,y);
		if(sons[y][0]==x&&sons[x][1]==0)
			sons[y][0]=0,fa[x]=0;
	}
	void link(int x,int y){
		makeroot(x);
		fa[x]=y;
	}
}T;
int main(){
	scanf("%d%d",&n,&m);
	int x,y;
	char op[101];
	while(m--){
		scanf("%s%d%d",op,&x,&y);
		if(op[0]=='Q')puts((T.findroot(x)==T.findroot(y))?"Yes":"No");
		if(op[0]=='D')T.cut(x,y);
		if(op[0]=='C')T.link(x,y);
	}
}
```

---

## 作者：huayucaiji (赞：3)

这个题第一眼是线段树分治吧。

但是这个题和大部分板子不同的是，这里询问不是全图连通性了，是两点的连通性。其实思路没什么大区别，还是要用**可撤销并查集**维护连通性，把边挂到线段树上相应的时间点上。

只是我们现在的询问不同了，我们可以模仿把边挂在线段树上的方式，把询问挂在单点上。每个时间点上最多有一次询问，由于线段树上的点是按时间顺序排列的，我们在遍历到这个点的时候，直接输出结果即可。

```cpp

//Don't act like a loser.
//This code is written by huayucaiji
//You can only use the code for studying or finding mistakes
//Or,you'll be punished by Sakyamuni!!!
#include<bits/stdc++.h>
#define int long long
#define pr pair<int,int>
using namespace std;

int read() {
	char ch=getchar();
	int f=1,x=0;
	while(ch<'0'||ch>'9') {
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=x*10+ch-'0';
		ch=getchar();
	}
	return f*x;
}

const int MAXN=10000+10,MAXM=2e5+10;

int n,m,q,cnt,num;
stack<pr > stk;
int size[MAXN],father[MAXN];
vector<pr > edge[MAXM<<2];
vector<pr > qry[MAXM<<2];
set<pr > s;
map<pr,int > mp;

pr make_edge(int x,int y) {
	return make_pair(min(x,y),max(x,y));
}
int find(int x) {
	if(x!=father[x]) {
		return find(father[x]);
	}
	return x;
}
void merge(pr s) {
	int x=find(s.first);
	int y=find(s.second);
	if(x==y) {
		stk.push(make_pair(-1,-1));
		return ;
	}
	if(size[x]>size[y]) {
		swap(x,y);
	}
	father[x]=y;
	size[y]+=size[x];
	stk.push(make_pair(x,y));
}
void del() {
	int x=stk.top().first;
	int y=stk.top().second;
	stk.pop();
	if(x==-1) {
		return ;
	}
	father[x]=x;
	size[y]-=size[x];
}

void modify(int l,int r,int p,int x,int y,pr s) {
	if(x>y||r<x||y<l) {
		return ;
	}
	if(x<=l&&r<=y) {
		edge[p].push_back(s);
		return ;
	}
	
	int mid=(l+r)>>1;
	modify(l,mid,p<<1,x,y,s);
	modify(mid+1,r,p<<1|1,x,y,s);
}
void modqry(int l,int r,int p,int x,int y,pr s) {
	if(x>y||r<x||y<l) {
		return ;
	}
	if(x<=l&&r<=y) {
		qry[p].push_back(s);
        //把询问挂到线段树上
		return ;
	}
	
	int mid=(l+r)>>1;
	modqry(l,mid,p<<1,x,y,s);
	modqry(mid+1,r,p<<1|1,x,y,s);
}

void query(int l,int r,int p) {
	int sz=edge[p].size();
	for(int i=0;i<sz;i++) {
		merge(edge[p][i]);
	}
	if(l==r) {
		int qsz=qry[p].size();
        //qsz的值域在 [0,1]。
		for(int i=0;i<qsz;i++) {
			if(find(qry[p][i].first)==find(qry[p][i].second)) {
				puts("Yes");
			}
			else {
				puts("No");
			}
		}
	}
	else {
		int mid=(l+r)>>1;
		query(l,mid,p<<1);
		query(mid+1,r,p<<1|1);
	} 
	while(sz--) {
		del();
	}
}

signed main() {
	cin>>n;
	for(int i=1;i<=n;i++) {
		father[i]=i;
		size[i]=1;
	}
	cin>>q;
	
	for(int i=1;i<=q;i++) {
		string c;
		cin>>c;
		int u,v;
		u=read();
		v=read();
		if(c[0]=='Q') {
			modqry(1,q,1,i,i,make_pair(u,v));
		}
		if(c[0]=='C') {
			s.insert(make_edge(u,v));
			mp[make_edge(u,v)]=i;
		}
		if(c[0]=='D') {
			modify(1,q,1,mp[make_edge(u,v)],i-1,make_edge(u,v));
			mp[make_edge(u,v)]=0;
			s.erase(make_edge(u,v));
		}
	}
	
	for(set<pr >::iterator it=s.begin();it!=s.end();it++) {
		modify(1,q,1,mp[*it],q,*it);
        //还有些边没被删除要加进去
	}
	
	query(1,q,1);
	return 0;
}

```

---

## 作者：yzhang (赞：2)

### [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/10203159.html)

### [原题传送门](https://www.luogu.org/problemnew/show/P2147)

### 这题用Link-Cut-Tree解决，[Link-Cut-Tree详解](https://www.cnblogs.com/yzhang-rp-inf/p/10201857.html)

我不太会踩爆Link-Cut-Tree的并查集做法qaq

我们用Link-Cut-Tree维护连通性~~（十分无脑）~~

Connect操作：把u,v两个点连起来

Destroy操作：把u,v两个点分开来

Query操作：判断在这个森林里u的根和v的根是否相等

```cpp
#include <bits/stdc++.h>
#define N 10005
using namespace std;
inline int read()
{
    register int f=1,x=0;register char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
inline void Swap(register int &a,register int &b)
{
    a^=b^=a^=b;
}
struct Link_Cut_Tree{
    int c[N][2],fa[N],top,q[N],rev[N];
    inline void pushdown(register int x){
        if(rev[x])
        {
            register int l=c[x][0],r=c[x][1];
            rev[l]^=1,rev[r]^=1,rev[x]^=1;
            Swap(c[x][0],c[x][1]);
        }
    }
    inline bool isroot(register int x)
    {
        return c[fa[x]][0]!=x&&c[fa[x]][1]!=x;
    }
    inline void rotate(register int x)
    {
        int y=fa[x],z=fa[y],l,r;
        l=c[y][0]==x?0:1;
        r=l^1;
        if(!isroot(y))
            c[z][c[z][0]==y?0:1]=x;
        fa[x]=z;
        fa[y]=x;
        fa[c[x][r]]=y;
        c[y][l]=c[x][r];
        c[x][r]=y;
    }
    inline void splay(register int x)
    {
        top=1;
        q[top]=x;
        for(register int i=x;!isroot(i);i=fa[i])
            q[++top]=fa[i];
        for(register int i=top;i;--i)
            pushdown(q[i]);
        while(!isroot(x))
        {
            int y=fa[x],z=fa[y];
            if(!isroot(y))
                rotate((c[y][0]==x)^(c[z][0]==y)?(x):(y));
            rotate(x);
        }
    }
    inline void access(register int x)
    {
        for(register int t=0;x;t=x,x=fa[x])
        {
            splay(x);
            c[x][1]=t;
        }
    }
    inline void makeroot(register int x)
    {
        access(x);
        splay(x);
        rev[x]^=1;
    }
    inline int findroot(register int x)
    {
        access(x);
        splay(x);
        while(c[x][0])
            x=c[x][0];
        return x;
    }
    inline void split(register int x,register int y)
    {
        makeroot(x);
        access(y);
        splay(y);
    }
    inline void cut(register int x,register int y)
    {
        split(x,y);
        c[y][0]=0;
        fa[x]=0;
    }
    inline void link(register int x,register int y)
    {
        makeroot(x);
        fa[x]=y;	
    }	
}T;
int n,m;
int main()
{
    n=read(),m=read();
    char ch[10];
    while(m--)
    {
        scanf("%s",ch);
        if(ch[0]=='C')
        {
            int x=read(),y=read();
            T.link(x,y);
        }
        else if(ch[0]=='D')
        {
            int x=read(),y=read();
            T.cut(x,y);
        }
        else
        {
            int x=read(),y=read();
            puts(T.findroot(x)==T.findroot(y)?"Yes":"No");
        }
    }
    return 0;
 } 
```




---

## 作者：FANTASTlC (赞：0)

简介：~~LCT模板~~，[不会LCT的点这里](https://www.luogu.com.cn/problem/P3690)

分析：

对于Connect操作，可以直接使用LCT进行动态连边；

对于Destory操作，可以直接使用LCT进行动态删边；

然后就没了。。。

Code

注：如果出现了两种注释，写在括号里的是人话
```c
#include<bits/stdc++.h>
#define N (int)(1e4+1)
#define M 5001
#define R register
#define INFI 0x7fffffff
#define INFL 0x7fffffffffffffff
#define F(i,start,end) for(R int (i)=(start);(i)<=(end);i++)
using namespace std;
template<typename T> void read(T &x)//随处可见的快读。。。
{
	int f=1;
	x=0;
	char c=getchar();
	while(!isdigit(c))
	{
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(isdigit(c))
	{
		x=x*10+c-'0';
		c=getchar();
	}
	x=x*f;
}
void write(int x)
{
	if(x<0)
		x=~x+1,putchar('-');
	if(x>9)
		write(x/10);
	putchar(x%10+'0');
}
struct link_cut_tree
{
	#define ls tree[p].son[0]
	#define rs tree[p].son[1]
	#define fa tree[p].f
	#define anc tree[fa].f
	stack<int> s;
	struct node
	{
		int f,son[2];
		bool tip;
	}tree[N];
	void pushdown(int p)//释放该点的旋转懒标记
	{
		if(tree[p].tip)
		{
			tree[ls].tip^=1;
			tree[rs].tip^=1;
			tree[p].tip^=1;
			swap(ls,rs);
		}
		return;
	}
	void connect(int p,int f,bool k)//连边
	{
		tree[p].f=f;
		tree[f].son[k]=p;
		return;
	}
	bool identify(int p)//判断该节点在原树上的深度与其父节点在原树上的深度的关系（判断该节点是其父节点的哪个儿子）
	{
		return tree[fa].son[1]==p;
	}
	bool check(int p)//判断该节点是不是其所在splay中深度最小的点（判断该节点是不是其所在splay的根）
	{
		return tree[fa].son[0]!=p&&tree[fa].son[1]!=p;
	}
	void rotate(int p)//旋转该节点
	{
		int f=fa,a=anc;
		bool fs=identify(p),as=identify(f);
		if(!check(f))//只有当其祖先节点与其在同一个splay时，才需要连一条实边 
			tree[a].son[as]=p;
		tree[p].f=a;
		connect(tree[p].son[fs^1],f,fs);
		connect(f,p,fs^1);
		return;
	}
	void splay(int p)//旋转该节点所在的整个splay
	{
		int temp=p;
		while(!check(p))
		{
			s.push(p);
			p=fa;
		}
		s.push(p);
		p=temp;
		while(s.size())//一定要按节点在其splay中深度的升序释放懒标记
		{
			pushdown(s.top());
			s.pop();
		}
		while(!check(p))//splay模板部分，在此不多做解释
		{
			if(check(fa))
				rotate(p);
			else
				if(identify(p)==identify(fa))
					rotate(fa),rotate(p);
				else
					rotate(p),rotate(p);
		}
		return;
	}
	void access(int p)//拉一条该节点与所有splay中深度最小的节点的路径（就是把该节点与根节点放在一个splay里）
	{
		int f=0;
		while(p)
		{
			splay(p);
			rs=f;//拉虚边
			f=p;
			p=fa;
		}
     		return;
	}
	void modify(int p)//将在该节点的深度变为在所有splay中深度最小的点（换根）
	{
		access(p);
		splay(p);
		tree[p].tip^=1;//因为在该节点所在的splay里，该节点的深度最大，所以旋转该节点所在的splay，使深度倒置后，该节点成为了深度最小的点，这也会导致该节点没有了左孩子，这一条性质会在cut函数中用到
		return;	
	}
	int find(int p)//查找在该节点所在splay中，深度最小的点（找根）
	{
		access(p);
		splay(p);
		while(ls)
			p=ls;
		return p;
	}
	void split(int p1,int p2)//偷懒函数
	{
		modify(p1);
		access(p2);
		splay(p2);
		return;
	}
	void link(int p1,int p2)//连边
	{ 
      		int f1=find(p1),f2=find(p2);
		if(f1==f2)//如果已经在同一个splay中，就没必要连边了
			return; 
		modify(p1);
		tree[p1].f=p2;
		return;
	}
	void cut(int p1,int p2)//删边
	{
		int f1=find(p1),f2=find(p2);
		if(f1!=f2)//如果已经不在同一个splay中，就没必要删边了
			return;
		split(p1,p2);
		if(tree[p2].son[0]==p1&&!tree[p1].son[1])//只有当两点间没有其他点时才可以删边（没有边当然就删不了边） 
		{
			tree[p2].son[0]=0;
			tree[p1].f=0;
		}
		return;
	}
	bool query(int p1,int p2)//实现了完全封装 
	{
		return find(p1)==find(p2);
	}
	#undef ls
	#undef rs
	#undef fa
	#undef anc
}lct;
int n,m,u,v;
char opt[10];
int main()
{
	read(n),read(m);
	F(i,1,m)
	{
		scanf("%s",&opt),read(u),read(v);	
		if(opt[0]=='C')
			lct.link(u,v);
		if(opt[0]=='D')
			lct.cut(u,v);
		if(opt[0]=='Q')
			printf("%s\n",lct.query(u,v)?"Yes":"No");
	}
 	return 0;
}

后记：因为这题的特殊性质：连接的点一定不连通，删的边一定存在，所以LCT中的link和cut函数也可以这样写
```c
	void link(int p1,int p2)
	{ 
		modify(p1);
		tree[p1].f=p2;
		return;
	}
	void cut(int p1,int p2)
	{
		split(p1,p2);
		tree[p2].son[0]=0;
		tree[p1].f=0;
		return;
	}
```
实测，这样写快到飞起（~~也就150ms~~


---

## 作者：Prean (赞：0)

这题就是用动态树维护连通性而已。。。标签的`并查集`是smg？？？

来说一下方法。有通道就是加边，通道没了就是删边。

至于两个点是否连通，很容易想到这种方法：一棵树谁都知道的信息就是根节点，所以我们可以先makeroot(x)，然后Access(y)，最后findroot(y)是否等于x就行了。

所以pushup操作也没必要，因为根本没有点权。

代码：
```cpp
#include<iostream>
#include<cstdio>
const int M=1e4+5;
int s[M],f[M],st[M],val[M],lazy[M],chi[M][2];
int get(int now)
{
	return chi[f[now]][0]==now||chi[f[now]][1]==now;
}
void filp(int now)
{
	std::swap(chi[now][0],chi[now][1]);lazy[now]^=1;
}
void pushdown(int now)
{
	if(lazy[now])filp(chi[now][0]),filp(chi[now][1]),lazy[now]=0;
}
void rotate(int x)
{
	int y=f[x],z=f[y],k=chi[y][1]==x,v=chi[x][!k];
	if(get(y))chi[z][chi[z][1]==y]=x;chi[x][!k]=y;chi[y][k]=v;
	if(v)f[v]=y;f[f[y]=x]=z;
}
void Splay(int x)
{
	int top=0,y=x;st[++top]=y;
	while(get(y))st[++top]=y=f[y];
	while(top)pushdown(st[top--]);
	while(get(x))
	{
		y=f[x];top=f[y];
		if(get(y))rotate(((chi[y][0]==x)^(chi[top][0]==y))?x:y);
		rotate(x);
	}
}
void Access(int x)
{
	for(register int y=0;x;x=f[y=x])Splay(x),chi[x][1]=y;
}
int findroot(int x)
{
	Access(x);Splay(x);
	while(chi[x][0])pushdown(x),x=chi[x][0];
	Splay(x);return x;
}
void makeroot(int x)
{
	Access(x);Splay(x);filp(x);
}
void link(int x,int y)
{
	makeroot(x);if(findroot(y)!=x)f[x]=y;
}
bool isunicom(int x,int y)
{
	makeroot(x);Access(y);return findroot(y)==x;
}
void cut(int x,int y)
{
	makeroot(x);
	if(findroot(y)==x&&f[y]==x&&!chi[y][0])f[y]=chi[x][1]=0;
}
signed main(void)
{
	int n,m;
	scanf("%d%d",&n,&m);
	while(m--)
	{
		char s[10];int x,y;
		scanf("%s%d%d",s,&x,&y);
		if(*s=='Q')printf("%s\n",isunicom(x,y)?"Yes":"No");
		if(*s=='C')link(x,y);
		if(*s=='D')cut(x,y);
	}
}
```

---

## 作者：巨型方块 (赞：0)

虽然lct的题解有了，但是，我相信在这题里面，我的lct更好；

细节在我的博客里

http://blog.csdn.net/largecub233/article/details/72566630

我们一开始读入n

表示有n棵树的森林；

我们每次合并x,y

是吧x,y两颗树合并起来；

但是每棵树有很多splay；

所以这些splay必须要互补影响；


因为实边的存在，一个splay的根节点可能fa不是0；

所以我们要判断他父亲节点有木有他这个儿子；

然后是旋转；

切记旋转一定要按顺序；

这两个细节是lct的splay的难点；

代码自己看吧；

另外，不会splay的一定要先好好学splay

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int N=1e4+5;
int ch[N][2],fa[N],rev[N];
int n,m,x,y;
char c[20];
int get(int x){
    if(ch[fa[x]][1]==x)return 1;
    if(ch[fa[x]][0]==x)return 0;
    return -1;
}
void rotate(int x){
    int f=fa[x],ff=fa[f],l=get(x),r=l^1;
    if(get(f)!=-1)ch[ff][ch[ff][1]==f]=x;
    fa[ch[x][r]]=f; fa[f]=x; fa[x]=ff; 
    ch[f][l]=ch[x][r]; ch[x][r]=f; 
}
void push(int x){
    if(!rev[x])return;
    rev[x]=0;
    rev[ch[x][0]]^=1;
    rev[ch[x][1]]^=1;
    swap(ch[x][0],ch[x][1]);
}
void cle(int x){if(get(x)!=-1)cle(fa[x]);push(x);}
void splay(int x){
    cle(x);
    for(int f=fa[x];get(x)!=-1;rotate(x),f=fa[x])
        if(get(f)!=-1)rotate(get(x)==get(f)?f:x);
}
void access(int x){for(int t=0;x;x=fa[t=x])splay(x),ch[x][1]=t;}
void makeroot(int x){access(x);splay(x);rev[x]=1;}
void link(int x,int y){makeroot(x);fa[x]=y;}
void cut(int x,int y){makeroot(x);access(y);splay(y);fa[x]=ch[y][0]=0;}
int find(int x){for(access(x),splay(x);ch[x][0];x=ch[x][0]);return x;}
int main()
{
    scanf("%d%d",&n,&m);
    while(m--){
        scanf("%s%d%d",c,&x,&y);
        if(c[0]=='C')link(x,y);
        if(c[0]=='D')cut(x,y);
        if(c[0]=='Q')
            if(find(x)==find(y))printf("Yes\n");else printf("No\n");    
    }
}
```

---

## 作者：小强 (赞：0)

lct思路题，好吧其实还是考板子（手动划掉）

题目要求：写一个数据结构，支持加边，删边和查询连通性（似乎并查集能水过，而且跑的还异常的快？投诉！！！），对于这种动态加边删边问题当然就用lct啦。

对于加边和删边cut和link函数就可以完美解决。唯一的问题是，如何查询连通性？

可以考虑判断根节点是否相等。

想一下lct的性质，因为lct中的splay是根节点深度为关键字维护的，这样如果我们将要查找的节点access一下，我们就得到了一个含有根节点的auxiliary tree。由于根节点的深度在这颗splay中一定是最小的，那么一直往他的左儿子上跳就可以了。

代码比较难看，不发了吧。。。


---

## 作者：Vasily (赞：0)

妥妥的一个LCT模板题。

不过话说，这个并查集按道理来说应该要卡掉的吧2333

可能数据比较友善。

LCT总的来说还是比较好写的啦

```cpp
#include <bits/stdc++.h>
using namespace std ;
const int maxn = 10010, maxm = 200010 ;
int n, m, fa[maxn], ch[maxn][2], stk[maxn] ;
bool rev[maxn] ;

bool isrt ( int x ) { return ch[fa[x]][0] != x && ch[fa[x]][1] != x ; } 
void Rotate ( int x, bool f ) {
    int y = fa[x], z = fa[y], u = ch[x][f^1] ;
    if ( !isrt(y) ) ch[z][ch[z][1]==y] = x ;
    fa[x] = z ;
    ch[fa[u] = y][f] = u ;
    ch[fa[y] = x][f^1] = y ;
}

void push_down ( int x ) {
    if ( rev[x] ) {
        rev[x] = false ;
        rev[ch[x][0]] ^= 1 ;
        rev[ch[x][1]] ^= 1 ;
        swap ( ch[x][0], ch[x][1] ) ;
    }
}

void Splay ( int x ) {
    int i, u, top, y, z ;
    stk[top=1] = x ;
    for ( u = x ; !isrt(u) ; u = fa[u] ) stk[++top] = fa[u] ;
    while (top) push_down(stk[top--]) ;
    for ( y = fa[x], z = fa[y] ; !isrt(x) ; z = fa[y=fa[x]] ) {
        bool f1 = ch[y][1] == x, f2 = ch[z][1] == y ;
        if ( isrt(y) ) Rotate ( x, f1 ) ;
        else if ( f1^f2 ) Rotate ( x, f1 ), Rotate ( x, f2 ) ;
        else Rotate ( y, f2 ), Rotate ( x, f1 ) ;
    }
}

void access ( int x ) {
    for ( int t = 0 ; x ; x = fa[t=x] ) 
        Splay(x), ch[x][1] = t ;
}

void Make_rt ( int x ) {
    access(x) ;
    Splay(x) ;
    rev[x] ^= 1 ;
}

void Link ( int x, int y ) {
    Make_rt(x) ;
    fa[x] = y ;
}

void Cut ( int x, int y ) {
    Make_rt(x) ;
    access(y) ;
    Splay(y) ;
    ch[y][0] = fa[x] = 0 ;
}

bool query ( int u, int v ) {
    for ( Make_rt(u), access(v), Splay(v) ; ch[v][0] ; v = ch[v][0] ) ;
    return u == v ;
}

char cmd[10] ;
int main() {
    int i, j, k, u, v ;
    scanf ( "%d%d", &n, &m ) ;
    while (m--) {
        scanf ( "%s%d%d", cmd, &u, &v ) ;
        if ( cmd[0] == 'C' ) Link ( u, v ) ;
        else if ( cmd[0] == 'D' ) Cut ( u, v ) ;
        else puts(query(u,v) ? "Yes" : "No") ;
    }
    return 0 ;
}
```

---

## 作者：PragmaGCC (赞：0)

很经典的的 LCT 维护联通性。

两个洞穴之间至多只有一条路径保证了这是个森林。

新通道就连边，摧毁通道就删边。查询就 `find` 一下两个点看看是不是同一棵树即可。

```cpp
#include <algorithm>
#include <cstdio>
using namespace std;
const int N = 10005;
int n, m;
int val[N], ch[N][2], rev[N], fa[N];
void pushup(int k) { return; }
void pushdown(int k) {
    if (!rev[k])
        return;
    swap(ch[k][0], ch[k][1]);
    rev[ch[k][0]] ^= 1, rev[ch[k][1]] ^= 1;
    rev[k] = 0;
}
bool isroot(int k) { return (ch[fa[k]][0] != k) && (ch[fa[k]][1] != k); }
int get(int k) { return ch[fa[k]][1] == k; }
void rotate(int x) {
    int y = fa[x], z = fa[y], k = get(x);
    if (!isroot(y))
        ch[z][ch[z][1] == y] = x;
    ch[y][k] = ch[x][!k], fa[ch[x][!k]] = y;
    ch[x][!k] = y, fa[y] = x, fa[x] = z;
    pushup(y), pushup(x);
}
void update(int p) {
    if (!isroot(p))
        update(fa[p]);
    pushdown(p);
}
void splay(int x) {
    update(x);
    for (int fat; fat = fa[x], !isroot(x); rotate(x)) {
        if (!isroot(fat))
            rotate(get(fat) == get(x) ? fat : x);
    }
}
void access(int x) {
    int p;
    for (p = 0; x; p = x, x = fa[x]) {
        splay(x), ch[x][1] = p, pushup(x);
    }
}
void makeroot(int p) {
    access(p);
    splay(p);
    rev[p] ^= 1;
}
void link(int x, int p) {
    makeroot(x), splay(x);
    fa[x] = p;
}
void split(int x, int p) { makeroot(x), access(p), splay(p); }
void cut(int x, int p) {
    split(x, p);
    if (ch[p][0] == x && ch[x][1] == 0)
        ch[p][0] = fa[x] = 0;
}
int find(int x) {
    access(x);
    splay(x);
    for (; ch[x][0]; x = ch[x][0]) pushdown(x);
    return x;
}

int main(void) {
    scanf("%d%d", &n, &m);
    for (int u, v; m; m--) {
        char op[5];
        scanf("%s%d%d", op, &u, &v);
        if (op[0] == 'Q') {
            int fu = find(u), fv = find(v);
            puts(fu == fv ? "Yes" : "No");
        } else if (op[0] == 'C') {
            link(u, v);
        } else {
            cut(u, v);
        }
    }
    return 0;
}
```

---


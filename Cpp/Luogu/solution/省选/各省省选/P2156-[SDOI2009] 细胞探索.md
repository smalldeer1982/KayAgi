# [SDOI2009] 细胞探索

## 题目描述

生物课上，老师开始为同学们介绍细胞。为了加深同学们的印象，老师在一张 $n \times m$ 的矩阵中定义了一种细胞，矩阵中仅有井号 `#` 和点 `.`。

细胞由细胞核、细胞质及细胞膜构成。细胞核是一个四联通（上下左右相连）的全为 `#` 的连通块，它必须实心，即不能存在一个四联通的 `.` 连通块被其完全包围（所谓完全包围指的是，这个 `.` 连通块不能位于矩阵边界相邻，且它的 $4$ 相邻格子均属于包含它的 `#` 连通块）。细胞膜是一个八联通（上下左右，以及 $4$ 个对角方向）的全为 `#` 的非实心连通块。细胞膜仅包围一个四联通的区域，且这个区域内有且仅有一个细胞核，这个区域剩下的位置全为 `.`。

所有连通块必须极大化，即一个八联通块周围不能找到一个 `#` 与这个连通块的任意一个 `#`八联通；同样，对于一个四联通块周围不能找到一个 `#` 与这个连通块的任意一个 `#`四联通。

现在，老师画了一幅图画，让小 E 回答图画中一共有几个细胞，并把图画中不属于任何一个细胞的 `#` 改成 `.`。

## 说明/提示

对于 $20\%$ 的数据，$n,m \le 20$。

对于另外 $20\%$ 的数据，保证所有 `#` 都属于某一个正确的细胞。

对于 $100\%$ 的数据，$1 \le n,m \le 1000$。

## 样例 #1

### 输入

```
12 13
.###..#####..
#...#.#....#.
#.#.#.#..#.#.
#...#..#...#.
.###.#..###..
....#..##...#
..........###
##########..#
#...........#
#.###...###.#
#...........#
#############
```

### 输出

```
1
......#####..
......#....#.
......#..#.#.
.......#...#.
........###..
.......##....
.............
.............
.............
.............
.............
.............
```

## 样例 #2

### 输入

```
9 14
#########.....
#.......#....#
#.#####.#...#.
#.#...#.#..#..
#.#.#.#.#.#..#
#.#...#.#..#..
#.#####.#...#.
#.......#....#
#########.....
```

### 输出

```
1
..............
..............
..#####.......
..#...#.......
..#.#.#.......
..#...#.......
..#####.......
..............
..............
```

## 样例 #3

### 输入

```
7 15
#######.#######
#.....#.#.....#
#.###.#.#.###.#
#.#.#.#.#.#...#
#.###.#.#.###.#
#.....#.#.....#
#######.#######
```

### 输出

```
1
........#######
........#.....#
........#.###.#
........#.#...#
........#.###.#
........#.....#
........#######
```

# 题解

## 作者：Night_Aurora (赞：7)

我大SD竟然出过这样的糟题

要是省选中出这样的题的话肯定当场疯掉

---
直接回正题吧

我们把细胞质(就是‘.‘ 下文用质代替）和非细胞质(就是’#‘ 下文用非质代替)分别BFS求一遍连通块

其中对于质求的连通块是四联通，非质求的块是八连通，然后给连通块编号

并记录下一些性质

什么性质下文再说

### 对于一个质，如果它只与两个非质连通块相接

### 而且这个质不延伸到给的矩阵边界（就是不被非质围起来的)

### 并且那两个相接的非质连通块满足一个有核的性质，一个有细胞膜的性质

那么这就是一个完整的细胞

对于一个质是否能延伸到边界且是否与刚好两个不同的非质连通块相接，这个可以在第一遍BFS中维护出来

对于一个非质是否有核和细胞膜，有点麻烦

一个非质连通块满足核的性质，当且仅当：

1.只与一个质连通块相接，且这个质连通块不会延伸到边界

2.它的四联通的遍历等价于它的八连通的遍历

这两个可以额外一次BFS求出来

一个非质连通块满足细胞膜的性质，等价于

- 有且仅有一个质连通块在其内部

对于这个的判断我们可以保留每个连通块最上面的点的纵坐标（从上到下从1到N)

若质最上纵坐标>该非质最上横坐标&&这个质不延伸到边界 那么这个质就在这个非质里面

这个也可以开头预处理+再一个BFS求出来

最后就枚举开头满足条件的质连通块然后把属于细胞的非质连通块打上标记，最后输出即可

[代码](http://paste.ubuntu.com/25422404/)很丑,贴链接吧


---

## 作者：xs_siqi (赞：3)

大型搜索+分类讨论。

本题总共有三个难点，第一个是理解题意，第二个是考虑最简单的搜索方法，第三个是调试能力与耐心。

我们会发现，对于一个点连通块（被包括在一个井号连通块内），只有在它恰好碰到两个井号联通块的时候才有可能有解。

考虑到对于井号搜索比较难做，所以我们对点连通块去做搜索。我们考虑把井号连通块先一遍 BFS 处理出来，然后用点连通块去找井号连通块。

我们把一个细胞拆分成两个部分，分别称之为外环和内心。

假如说你这个点连通块根本没有被包含，那么就是说明这个点连通块根本就是无效的，因为这个点连通块无法构成一个细胞的必要部分，所以当这个点连通块不被包含的时候，我们什么都不干。

假如说一个点连通块整一次搜索只遇到了一个井号连通块，那么就是说明这个井号连通块是不合法的。这个不合法的井号显然不可以做内心（因为里面的点连通块是被包含的），所以我们考虑把以这个井号连通块做内心的外环标记为不合法，这个井号联通块显然也不能做外环或者内心，所以直接把它标记为不能做外环、内心的类型。

假如说一个点连通块整一次搜索遇到了两个井号连通块，那么将会有以下几种情况：

首先，判断内部的井号连通块是否是四联通。因为一开始我们找的都是八连通的井号连通块。如果不是四联通说明这个外环根本就不合法，把这个外环标记为不可做外环的类型。同时这个外环也不能做内心，所以把以它为内心的外环标记为不合法，把它标记为不可做内心的类型。

假如说这个两个连通块不呈包含关系，那是不可能的。因为你的点连通块是被包含的，就是说你起码能找到三个井号连通块。

假如说呈包含关系，那么你现在所找到的外环显然不能做其它细胞的内心（因为里面还有一堆东西），所以直接把这个外环做内心的细胞标记为不合法，并把这个外环标记为不能做内心的类型。但是我们发现在这个内心没有被标记为不可做内心的类型，外环没有被标记为不可做外环的类型的前提下，这个细胞是合法的，所以直接标记这个外环做外环，内心做内心是合法的类型。

假如说你找到的外环已经是别人的外环了（这是有可能的，形象点比喻，这个情况就是两个房子之间隔着一个门的情况），那么这个外环必然是不合法的，因为只能有一个内心。所以直接把这个外环标记为不合法，把它包含的所有内心标记为不合法。

假如说你找到的外环已经被标记为不合法了，看来它之前遇到过的内心不止你现在这一个，说明这个外环不可选，那么就把目前的内心标记为不合法。

假如说你找到的内心已经被标记不合法了，同理，外环也不可能合法。

如果上述情况都不满足，那么说明这个外环可以做外环，内心可以做内心，直接把外环标记为可以做外环的类型，内心标记为可以做内心的类型。

假如说一个点连通块整一次搜索到了两个以上的井号连通块，有以一种情况：

假如说有一堆井号连通块被包含在一个大的井号连通块里，或者有多个包含关系。说明最外面的大连通块不适合做外环，把它标记为不适合做外环的类型，至于更里面的慢慢枚举。

---

上面已经基本包括了全部的分类。接下来我们来处理如何判断包含关系，判断一个井号连通块是否是四连通的问题。

对于判断包含关系，我们可以把一个连通块的左边界右边界上边界下边界都处理出来，假如这个能包含另一个连通块，这必然是包含关系。这个东西可以在 BFS 的过程中处理。

对于判断一个连通块是否是四连通，我们可以分别处理井号是否是八连通四连通，然后把每一个连通块标记一个 $size$ 值，如果两者的 $size$ 值是相等的，说明这个八连通是四连通，否则不是。

最终答案就是适合做外环的类型数。然后将外环内心输出即可。

参考实现如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1005;
const int dx[8]={0,0,-1,1,-1,-1,1,1};
const int dy[8]={1,-1,0,0,1,-1,-1,1};
/*
ans标记答案，tot与tot2标记连通块的编号，zhi和zhi2标记每个点分别属于哪个连通块，kl与kl2标记每次根据点连通块走扫到的 #号
neizhiwai表示一个内心所指向的外环，waizhinei表示一个外环所指向的内心
maxll，maxrr，maxuu，maxdd表示点连通块的四个边界
jmaxl，jmaxr，jmaxu，jmaxd表示#号连通块枚举到的四个边界
jzhi和jzhi2分别维护题解中描述的信息
waivis表示一个连通块是否做过外环，neivis表示一个连通块是否做过内心
*/
int ans,n,m,u,tot,tot2,zhi[maxn][maxn],zhi2[maxn][maxn],mp[maxn][maxn],kl[maxn*maxn],kl2[maxn*maxn],cnt,tl,neizhiwai[maxn*maxn],waizhinei[maxn*maxn],maxll,maxrr,maxuu,maxdd;
int jmaxl,jmaxr,jmaxu,jmaxd;
bool vis[maxn][maxn],vkuai[maxn*maxn],vis2[maxn][maxn],vis3[maxn][maxn];
int waivis[maxn*maxn],neivis[maxn*maxn];
char s[maxn];
struct edge{int x,y;}q[maxn*maxn];
struct kuai{int num,maxl,maxr,maxu,maxd,sz;}jzhi[maxn*maxn],jzhi2[maxn*maxn];
void F_1(int x,int y,int num){
	int h=1,t=1,sz=1;
	q[1]=(edge){x,y},vis[x][y]=1,zhi[x][y]=num;
	jzhi[num]=(kuai){num,y,y,x,x,0};
	while(h<=t){
		edge p=q[h++];
		for(int i=0;i<8;i++){
			int nx=p.x+dx[i],ny=p.y+dy[i];
			if(mp[nx][ny]&&!vis[nx][ny]&&0<nx&&nx<=n&&0<ny&&ny<=m){
				q[++t]=(edge){nx,ny};
				vis[nx][ny]=1;
				zhi[nx][ny]=num;
				kuai z=jzhi[num];
				sz++;
				jzhi[num]=(kuai){num,min(ny,z.maxl),max(ny,z.maxr),min(nx,z.maxu),max(nx,z.maxd),0};}
		}
	}
	jzhi[num].sz=sz;
}//找八连通
void F_2(int x,int y,int num){
	int h=1,t=1,sz=1;
	q[1]=(edge){x,y},vis[x][y]=1,zhi2[x][y]=num;
	jzhi2[num]=(kuai){num,y,y,x,x,0};
	while(h<=t){
		edge p=q[h++];
		for(int i=0;i<4;i++){
			int nx=p.x+dx[i],ny=p.y+dy[i];
			if(mp[nx][ny]&&!vis[nx][ny]&&0<nx&&nx<=n&&0<ny&&ny<=m){
				sz++;
				q[++t]=(edge){nx,ny};
				vis[nx][ny]=1;
				zhi2[nx][ny]=num;
				kuai z=jzhi2[num];
				jzhi2[num]=(kuai){num,min(ny,z.maxl),max(ny,z.maxr),min(nx,z.maxu),max(nx,z.maxd),0};}
		}
	}
	jzhi2[num].sz=sz;
}//找四联连通
void F_0(int x,int y){
	jmaxl=m+1,jmaxr=0,jmaxu=n+1,jmaxd=0,u=0;
	int h=1,t=1;
	q[1]=(edge){x,y},vis[x][y]=1;
	maxll=y,maxrr=y,maxuu=x,maxdd=x;
	while(h<=t){
		edge p=q[h++];
		for(int i=0;i<4;i++){
			int nx=p.x+dx[i],ny=p.y+dy[i];
			if(!vis[nx][ny]&&0<nx&&nx<=n&&0<ny&&ny<=m){
				if(!mp[nx][ny]){
					q[++t]=(edge){nx,ny},
					vis[nx][ny]=1;
					maxll=min(maxll,ny),maxrr=max(maxrr,ny),maxuu=min(maxuu,nx),maxdd=max(maxdd,nx);}
				else{
					if(!vkuai[zhi[nx][ny]]){
						vkuai[zhi[nx][ny]]=1;
						kl[cnt]=zhi[nx][ny],kl2[cnt]=zhi2[nx][ny];
						if(jzhi[kl[cnt]].maxl<=jmaxl&&jzhi[kl[cnt]].maxr>=jmaxr&&jzhi[kl[cnt]].maxu<=jmaxu&&jzhi[kl[cnt]].maxd>=jmaxd){
							jmaxl=jzhi[kl[cnt]].maxl,jmaxu=jzhi[kl[cnt]].maxu,jmaxd=jzhi[kl[cnt]].maxd,jmaxr=jzhi[kl[cnt]].maxr;
							u=kl[cnt];}	
						cnt++;		
					}
				}
			}
		}
	}
}//对于每个点连通块，扫井号连通块
void ck(int x,int y){
	F_0(x,y);
	if(cnt==1){
		if(maxll<=jzhi[kl[0]].maxl||maxrr>=jzhi[kl[0]].maxr||maxuu<=jzhi[kl[0]].maxu||maxdd>=jzhi[kl[0]].maxd)return ;//不被包含不考虑
		if(neivis[kl[0]]==1)
			waivis[neizhiwai[kl[0]]]=-1,neizhiwai[kl[0]]=0;//这个东西曾经做过内心，肯定不合法，因为这个#连通块是个包含.的东西
		if(waivis[kl[0]]==1)
			neivis[waizhinei[kl[0]]]=-1,waizhinei[kl[0]]=0;//这个东西曾经做过外环。这种情况好像是不可能的，是我写多了
		waivis[kl[0]]=neivis[kl[0]]=-1;}
	if(cnt==2){
		if(jzhi[kl[0]].maxl>jzhi[kl[1]].maxl)//能包含的放前面
			swap(kl[0],kl[1]);
		if(jzhi[kl[1]].sz!=jzhi2[kl2[1]].sz){
			int p=kl[0];
			neivis[p]=-1,waivis[neizhiwai[p]]=-1,neizhiwai[p]=0;
			waivis[p]=-1,neivis[waizhinei[p]]=-1,waizhinei[p]=0;//如果里面的不是八连通那么外环不合法
			return ;}
		if(maxll<=jzhi[kl[0]].maxl||maxrr>=jzhi[kl[0]].maxr||maxuu<=jzhi[kl[0]].maxu||maxdd>=jzhi[kl[0]].maxd)return ;
		if(jzhi[kl[0]].maxl<jzhi[kl[1]].maxl&&
		jzhi[kl[0]].maxu<jzhi[kl[1]].maxu&&
		jzhi[kl[0]].maxr>jzhi[kl[1]].maxr&&
		jzhi[kl[0]].maxd>jzhi[kl[1]].maxd){
			if(waivis[kl[0]]==-1)neivis[kl[1]]=-1;//这不能做外环显然里面的不能做内心
			else if(neivis[kl[1]]==-1)waivis[kl[0]]=-1;//同理
			else if(waivis[kl[1]]==1)waivis[kl[0]]=-1;//里面的做过外环的情况。但这是不可能的情况，我考虑多了
			else if(waivis[kl[0]]==1)waivis[kl[0]]=-1,neivis[waizhinei[kl[0]]]=-1,waizhinei[kl[0]]=0;//外面的做过别人的外环，那外面的东西不能做外环，里面也不能做内心
			else if(neivis[kl[0]]==1){
				neivis[kl[0]]=0;
				waivis[neizhiwai[kl[0]]]=-1,neizhiwai[kl[0]]=0;
				waivis[kl[0]]=1,neivis[kl[1]]=1,
				neizhiwai[kl[1]]=kl[0];}//外环做过内心，那么把这个东西去掉，因为这个外环是做不了内心的（里面还有东西）
			else
			   	waivis[kl[0]]=1,neivis[kl[1]]=1,
				neizhiwai[kl[1]]=kl[0],waizhinei[kl[0]]=kl[1];}}//这个东西是合法的情况
	if(cnt>2){
		if(maxll>jmaxl&&maxrr<jmaxr&&maxdd<jmaxd&&maxuu>jmaxu){
			neivis[u]=-1,waivis[neizhiwai[u]]=-1,neizhiwai[u]=0;
			waivis[u]=-1,neivis[waizhinei[u]]=-1,waizhinei[u]=0;}}}//如果是包含关系，最外层的东西显然不可以做环
inline int read(){
	int x=0;
	char ch=getchar();
	while(!isdigit(ch))
		ch=getchar();
	while(isdigit(ch))
		x=x*10+ch-'0',ch=getchar();
	return x;}
inline char readchar(){
	char ch=getchar();
	while(ch!='.'&&ch!='#'){
		ch=getchar();
		if(ch==EOF)
			return '.';}
	return ch;}
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		scanf("%s",s+1);
		for(int j=1;j<=m;j++)
			mp[i][j]=(s[j]=='#');}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(mp[i][j]&&!vis[i][j])F_1(i,j,++tot);
	memset(vis,0,sizeof vis);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(mp[i][j]&&!vis[i][j])F_2(i,j,++tot2);
	memset(vis,0,sizeof vis);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			for(int k=0;k<cnt;k++)vkuai[kl[k]]=0;
			cnt=0;
			if(!mp[i][j]&&!vis[i][j])
				ck(i,j);}
	for(int i=1;i<=tot;i++)
		if(waivis[i]==1)ans++;
	printf("%d\n",ans);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++)
			if(!mp[i][j])putchar('.');
			else if(mp[i][j]&&(waivis[zhi[i][j]]==1||neivis[zhi[i][j]]==1))putchar('#');
			else putchar('.');
		putchar('\n');}
	return 0;}
```

提醒：

到目前为止，四号点事有问题的，只能使用 `scanf` 读入，用读优可能会导致错误。

如果有空可以去看看本题的[测试数据](https://www.luogu.com.cn/discuss/668741)。

---


# [SHOI2007] 书柜的尺寸

## 题目描述

Tom 不喜欢那种一字长龙式的大书架，他只想要一个小书柜来存放他的系列工具书。Tom 打算把书柜放在桌子的后面，这样需要查书的时候就可以不用起身离开了。

显然，这种书柜不能太大，Tom 希望它的体积越小越好。另外，出于他的审美要求，他只想要一个三层的书柜。为了物尽其用，Tom 规定每层必须至少放一本书。现在的问题是，Tom 怎么分配他的工具书，才能让木匠造出最小的书柜来呢？ 

Tom很快意识到这是一个数学问题。每本书都有自己的高度 $h_i$ 和厚度 $t_i$。我们需要求的是一个分配方案，也就是要求把所有的书分配在 $S_1$、$S_2$ 和 $S_3$ **三个非空集合**里面的一个，不重复也不遗漏，那么，很明显，书柜正面表面积（$S$）的计算公式就是：  

$$S=\left(\sum_{j=1}^3 \max_{i \in S_j} h_i\right) \times \left(\max_{j=1}^3 \sum_{i \in S_j} t_i\right) $$

由于书柜的深度是固定的（显然，它应该等于那本最宽的书的长度），所以要求书柜的体积最小就是**要求 $S$ 最小**。Tom 离答案只有一步之遥了。不过很遗憾，Tom 并不擅长于编程，于是他邀请你来帮助他解决这个问题。

## 说明/提示

对于全部数据，$3 \leq n \leq 70$，$150 \leq h_i \leq 300$，$5 \leq t_i \leq 30$。

## 样例 #1

### 输入

```
4
220 29
195 20
200 9
180 30```

### 输出

```
18000```

# 题解

## 作者：81179332_ (赞：9)

设 $f_{i,j,k,l}$ 表示放了前 $i$ 本书，第一层厚度为 $j$，第二层厚度为 $k$，第三层厚度为 $l$ 的最小高度和

容易想到，我们将所有书按照高度从大到小排序，那么每一层的高度就是第一个放入该层的书的高度

记 $sum_i=\sum\limits_{j=1}^i t_j$显然，$j+k+l=sum_i$，则 $l=sum_i-j-k$，由此，我们可以省掉 $l$ 这一维

再加一个滚动数组优化就可以啦

转移方程较为简单，见代码，采用刷表法比较好写

```cpp
//timeuse:20min
const int N = 80,M = 2110;
int n;
struct book { int h,t; }a[N];
int f[2][M][M],sum[N];
void minn(int &a,int b) { if(a > b) a = b; }
int main()
{
	freopen("random.in","r",stdin);
	freopen("sol.out","w",stdout);
	n = read();for(int i = 1;i <= n;i++) a[i].h = read(),a[i].t = read();
	sort(a + 1,a + 1 + n,[&](book u,book v) { return u.h > v.h; });
	for(int i = 1;i <= n;i++) sum[i] = sum[i - 1] + a[i].t;
	memset(f[0],63,sizeof(f));f[0][0][0] = 0;
	for(int i = 1;i <= n;i++)
	{
		int now = i & 1,pre = now ^ 1;
		memset(f[now],63,sizeof(f[now]));
		for(int j = 0;j <= sum[i - 1];j++) for(int k = 0;k <= sum[i - 1];k++)
		{
			if(j == 0) minn(f[now][j + a[i].t][k],f[pre][j][k] + a[i].h);
			else minn(f[now][j + a[i].t][k],f[pre][j][k]);
			if(k == 0) minn(f[now][j][k + a[i].t],f[pre][j][k] + a[i].h);
			else minn(f[now][j][k + a[i].t],f[pre][j][k]);
			if(sum[i - 1] - j - k == 0) minn(f[now][j][k],f[pre][j][k] + a[i].h);
			else minn(f[now][j][k],f[pre][j][k]);
		}
	}ll ans = LINF;
	for(int i = 1;i <= sum[n];i++) for(int j = 1;j <= sum[n];j++) if(sum[n] - i - j > 0)
		ans = min(ans,(ll)max(max(i,j),sum[n] - i - j) * f[n & 1][i][j]);
	fprint(ans);
	return 0;
}

```

---

## 作者：PrimoPan (赞：8)

<http://primopan.org/2017/09/16/bzoj1933-shoi2007bookcase-%e4%b9%a6%e6%9f%9c%e7%9a%84%e5%b0%ba%e5%af%b8%e3%80%90dp%e3%80%91/>

【题目大意】给你一坨书，每一坨书都有一个高度和一个深度。现在有三个书柜，让你把所有书放到这三个书柜里面，每个书柜的高度为书柜里书的最高高度，深度为书柜里这一层书的深度之和，求面积最小的情况。也就是题目中那个式子的最小值。


【题解】我们玄学地把书按照高度从高到小排序一下，排序之后如果把一本书放到一个新的书柜里那么这个书柜的高度就是当前书的高度。那么我们考虑dp,记dp[i][j][k][l]为第i高的书放进去之后，第一个书柜的深度为i，第二个书柜的深度为j，第三个书柜的深度为l，显然可以从i-1的j,k,l转移过来，然后这样显然会T。根据j,k其实可以推出l,时空减了一个维度，i可以滚动一下空间减了一个维度，然后各种玄学常数优化大抵能过？

```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn 2105
#define INF 0x3f
struct Node{
    int h,t;
}a[80];
bool cmp(Node a,Node b){return a.h>b.h;}
int f[2][maxn][maxn],n,sum[80];
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++)scanf("%d%d",&a[i].h,&a[i].t);
    sort(a+1,a+1+n,cmp);
    sum[1]=a[1].t;
    for (int i=2;i<=n;i++) sum[i]=sum[i-1]+a[i].t;//前缀和
    memset(f,INF,sizeof(f));
    f[1][0][0]=f[0][0][0]=0;
    int now,pre;
    for (int i=1;i<=n;i++)
    {
        now=i&1;pre=now^1;
        memset(f[now],INF,sizeof(f[now]));
        for (int j=0;j<=sum[i];j++)
             for (int k=0;k<=sum[i];k++)
             if (f[pre][j][k]!=INF)
             {
                  f[now][j+a[i].t][k]=(j==0)? min(f[now][j+a[i].t][k],f[pre][j][k]+a[i].h):min(f[now][j+a[i].t][k],f[pre][j][k]);
                  f[now][j][k+a[i].t]=(k==0)? min(f[now][j][k+a[i].t],f[pre][j][k]+a[i].h):min(f[now][j][k+a[i].t],f[pre][j][k]);
                  f[now][j][k]=(sum[i-1]-j-k==0)?min(f[now][j][k],f[pre][j][k]+a[i].h):min(f[now][j][k],f[pre][j][k]);
             }
    }
    long long ans=1<<30;
    for (int i=1;i<=sum[n];i++)
        for (int j=1;j<=sum[n];j++)
        if (sum[n]-i-j)ans=min(ans,(long long)max(max(i,j),sum[n]-i-j)*(long long)f[now][i][j]);    
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：Night_Aurora (赞：5)

就是三层都放一些书，使得最长的长度乘以每层最高的书的高度和最小

这是一个二元组，很明显应该吧一个作为状态来保存另一个的最优

把高度作为状态貌似没法转移

于是我们可以把每层的宽度作为状态

$DPM[i][a][b]$ 表示第i本书放完后，第一层厚度和第二层厚度分别为a,b时的最小高度

第三层厚度也能推算出来，我们假设某一层没有书时对高度没有贡献

那么边界$DPM[0][0][0]=0$

我们可以顺推，先把所有书按照高度排序，那样第一个放进空层的书就是这一层的最高高度

那么对于一本书放进非空层对DPM没有贡献

而放进一个空层则会对DPM有高度的贡献

最后算出来DP[N][][]后枚举使三层都非空的状态并保存面积最小值就行

原题内存是64M，但是没关系，开到256M我觉得都会MLE

所以要开滚动数组

正解复杂度是$O(N*(2100)^2)$,灰常高，所以才是5s实现

但是每次DP转移时可以把这两层容量上界改为当前书的总厚度，这样可以减少很多常数(高达100的常数啊kowai)

DP代码短(至少比数据结构短)就直接贴上吧

(其实一点也不短）










```cpp
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <utility>
#define min(a,b) (a>b?b:a)
void MINE(unsigned short&a,int b)
{a=min(a,b);}
int max(int a,int b)
{return a>b?a:b;}
#define LNG    2200
unsigned short DPM[LNG+1][LNG+1];
unsigned short Last[LNG+1][LNG+1];
int N,Sum;
std::pair<int,int> Dat[80];
int LSum[80];
void Input()
{
    scanf("%d",&N);
    int wi;
    for(wi=1;wi<=N;++wi)
    {
        scanf("%d %d",&Dat[wi].first,&Dat[wi].second);
        Dat[wi].first=(-Dat[wi].first);
        Sum+=Dat[wi].second;
    }
    std::sort(Dat+1,Dat+1+N);
    for(wi=1;wi<=N;++wi)
        Dat[wi].first=-Dat[wi].first;
    for(wi=1;wi<=N;++wi)
        LSum[wi]=LSum[wi-1]+Dat[wi].second;
}
void DPA()
{
    int wi,wia,wib;
    int nh,nl,ns;
    memset(Last,0x3F,sizeof(Last));
    memset(DPM,0x3F,sizeof(DPM));
    Last[0][0]=0;
    for(wi=1;wi<=N;++wi)
    {
        nh=Dat[wi].first;
        nl=Dat[wi].second;
        ns=LSum[wi-1];
        for(wia=0;wia<=ns;++wia)
            for(wib=0;wib+wia<=ns;++wib)
                if(Last[wia][wib]^0x3F3F)
                {
                    if(!wia)
                        MINE(DPM[nl][wib],Last[0][wib]+nh);
                    else
                        MINE(DPM[wia+nl][wib],Last[wia][wib]);
                    if(!wib)
                        MINE(DPM[wia][nl],Last[wia][0]+nh);
                    else
                        MINE(DPM[wia][wib+nl],Last[wia][wib]);
                    if(!(ns-wia-wib))
                        MINE(DPM[wia][wib],Last[wia][wib]+nh);
                    else
                        MINE(DPM[wia][wib],Last[wia][wib]);
                }
        memcpy(Last,DPM,sizeof(DPM));
        memset(DPM,0x3F,sizeof(DPM));
    }
}
int main()
{
    Input();
    DPA();
    int wia,wib;
    int ans=0x3FFFFFFF;
    for(wia=1;wia<=Sum;++wia)
        for(wib=1;wib<=Sum;++wib)
            if(Sum-wia-wib)
                if(Last[wia][wib]^0x3F3F)
                    if(ans>max(wia,max(wib,Sum-wia-wib))*Last[wia][wib])
                        ans=max(wia,max(wib,Sum-wia-wib))*Last[wia][wib];
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：Vct14 (赞：3)

题目大意：有 $n$ 本书，现在需要把它们放进一个三层书柜。定义书柜总高度为每层中的书高度最大值的总和，厚度为每层中的书厚度之和的最大值，求书柜高度与厚度乘积的最小值。

定义状态 $f_{i,l_1,l_2,l_3}$ 表示已经放了 $i$ 本书且当前三层的厚度分别为 $l_1,l_2,l_3$ 时书柜高度的最小值。

为了避免麻烦，我们将书的高度从大到小排序，这样可以使层高等于该层第一本书的高度。

我们假设这本书被放在第一层。那么：如果这本书是第一层的第一本书，那么总高度 $f_{i,l_1,l_2,l_3}$ 相较于放之前的  $f_{i-1,l_1-t_i,l_2,l_3}$ 增加了 $h_i$，即 $f_{i,l_1,l_2,l_3}=\min(f_{i,l_1,l_2,l_3},f_{i-1,l_1-t_i,l_2,l_3}+h_i)$；否则总高度不变，即 $f_{i,l_1,l_2,l_3}=\min(f_{i,l_1,l_2,l_3},f_{i-1,l_1-t_i,l_2,l_3})$。这本书被放在其他层同理。

但是这样空间复杂度有点高，我们要考虑优化。可以发现，对于前 $i$ 本书，$l_1+l_2+l_3$ 为定值，也就是前 $i$ 本书的厚度之和。那么我们处理出前 $i$ 本书的厚度之和 $s_i$，就可以得到 $l_3=s_i-l_1-l_2$。这样就可以减少一维。我们再使用滚动数组，就可以通过了。

```c++
#include<bits/stdc++.h>
using namespace std;
#define nowf f[i%2][l[1]][l[2]]
#define nf f[n%2][l[1]][l[2]]
#define fir a[i].first
#define sec a[i].second

// 为了避免 i-1<0，由于 i-1 与 i+1 奇偶性相同，我们在用滚动数组时将 (i-1)%2 替换为 (i+1)%2 

const int N=2102,M=72,A=0x3f,B=0x3f3f3f3f;
pair<int,int> a[M];
int f[2][N][N];
int l[3];
int sum[M];
int i;

void dp(int id,int fst1,int fst2){ // 偷懒（逃 
	int lst=f[(i+1)%2][l[1]-sec*fst1][l[2]-sec*fst2];
	if(l[id]>=sec){
		if(l[id]==sec) nowf=min(nowf,lst+fir); // 该层厚度就是书厚度->这本书为该层第一本书->书高度就是层高 
		else nowf=min(nowf,lst);
	} 
}

bool cmp(pair<int,int>a,pair<int,int> b){
	return a.first>b.first;
}

int main(){
	memset(f,A,sizeof(f));
	f[0][0][0]=0;
	int n;cin>>n;
	for(i=1; i<=n; i++) cin>>fir>>sec;
	sort(a+1,a+1+n,cmp);
	for(i=1; i<=n; i++){
		sum[i]=sum[i-1]+sec;
		memset(f[i%2],A,sizeof(f[i%2])); // 记得清空 OvO 
		for(l[1]=0; l[1]<=sum[i]; l[1]++){
			for(l[2]=0; l[2]<=sum[i]; l[2]++){
				l[0]=sum[i]-l[1]-l[2]; // 算出第三层层高 
				if(l[0]<0) continue;
				dp(1,1,0);dp(2,0,1);dp(0,0,0); // 状态转移 
			}
		}
	}
	int ans=B;
	for(l[1]=1; l[1]<=sum[n]; l[1]++){
		for(l[2]=1; l[2]<=sum[n]; l[2]++){
			l[0]=sum[n]-l[1]-l[2];
			if(l[0]<=0 || nf==B) continue;
			int mx=-1;for(int i=0; i<3; i++) mx=max(mx,l[i]);
			ans=min(ans,mx*nf);
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：dbxxx (赞：3)

[可以到我的博客查看，谢谢。](https://www.cnblogs.com/crab-in-the-northeast/p/luogu-p2160.html)

把书按高度从大到小排序，依次考虑放置，**每一层第一个被放置的书的高度就是这一层的高度。**

设 $f(i, j, k, l)$ 表示考虑了前 $i$ 本书，第一层宽度为 $j$，第二层宽度为 $k$，第三层宽度为 $l$ 时，**最小的整个书架的高度**（紫题应该就在于这个状态比较难想）。

为什么会这么想，**首先考虑 $t_i$ 和 $h_i$ 范围很小**，可以猜测是 dp 的某一维，而且发现如果设成讨论每个书被放在哪里，状态的量级会高达 $3^{70}$，这是不合适的，而这 $3^{70}$ 个状态中其实有大量状态的第一层，第二层，第三层宽度分别完全一致（因为**三层所有宽度的情况最多只有 $2100^3$ 种，远小于 $3^{70}$**），这种情况下转移也是一致的，可以一起处理，那就直接按照三层的宽度情况分类即可（这是本题的思维难点）。

其次，如果考虑前 $i$ 本书，第一层高度为 $j$，第二层高度为 $k$，第三层高度为 $l$ 的最小化整个书架的宽度，会发现很难转移，因为根本没有利用好开头所说的那个结论。

想到更换转移，于是有了上面的状态设计，发现这样就容易转移了。

刷表转移，对于 $p = f(i, j, k, l)$，我们考虑对**第一层**进行放书，第二第三层完全同理。

下一个状态是 $f(i + 1, j + t_i, k, l)$。如果 $j = 0$，把它和 $p + h_i$ 取一个最小值，代表放了第一层放下了**第一本**书，我们统计上第一层的高度；否则如果 $j \ne 0$，代表第一层**已经放过一本书了**，直接把它和 $p$ 取一个最小值——显然第一层的高度已经统计在里面了。

发现时空复杂度仍然危险，考虑优化。

其实很容易发现 **$i, j, k$ 确定了 $l$ 也就确定了**，具体来说前 $i$ 本书都放在书架中，第三层的宽度就是前 $i$ 本书的总宽度减去第一层的宽度 $j$ 减去第二层的宽度 $k$。因此第四维可以删掉。

然后这个题第一维还需要一个滚动。

统计答案就是直接大力统计最后状态。

**时间复杂度 $\mathcal{O}(n^3t^2)$，$t$ 表示 $t_i$ 的数量级。**

这个题是 SHOI 2007，可以看到这题当时时限开了 5s，但是现在 1s 就可过，时代的进步。

```cpp
/*
 * @Author: crab-in-the-northeast 
 * @Date: 2022-09-23 21:02:08 
 * @Last Modified by: crab-in-the-northeast
 * @Last Modified time: 2022-09-23 22:35:56
 */
#include <bits/stdc++.h>

inline int read() {
	int x = 0;
	bool flag = true;
	char ch = getchar();
	while (!isdigit(ch)) {
		if (ch == '-')
			flag = false;
		ch = getchar();
	}
	while (isdigit(ch)) {
		x = (x << 1) + (x << 3) + ch - '0';
		ch = getchar();
	}
	if(flag)
		return x;
	return ~(x - 1);
}

const int maxn = 75;
const int maxm = maxn * 35;

int f[2][maxm][maxm];

struct node {
	int h, t;
}a[maxn];

inline bool getmin(int &a, int b) {
	return b < a ? a = b, true : false;
}

inline bool getmin(long long &a, long long b) {
	return b < a ? a = b, true : false;
}

int main() {
	int n = read(); 
	for (int i = 1; i <= n; ++i) {
		int h = read(), t = read();
		a[i] = (node){h, t};
	}

	std :: sort(a + 1, a + 1 + n, [](node b, node c) {
		return b.h > c.h;
	});
	
	std :: memset(f[0], 0x3f, sizeof(f[0]));
	f[0][0][0] = 0;

	int x = 0;
	for (int u = 1; u <= n; x += a[u].t, ++u) {
		int i = u & 1, t = a[u].t, h = a[u].h;
		std :: memset(f[i], 0x3f, sizeof(f[i]));
		for (int j = 0; j <= x; ++j) {
			for (int k = 0; k <= x - j; ++k) {
				int p = f[i ^ 1][j][k];
				getmin(f[i][j + t][k], p + (j ? 0 : h));
				getmin(f[i][j][k + t], p + (k ? 0 : h));
				int l = x - j - k;
				getmin(f[i][j][k], p + (l ? 0 : h));
			}
		}
	}

	long long ans = LONG_LONG_MAX;
	for (int i = 1; i < x; ++i)
		for (int j = 1; j < x - i; ++j)
			getmin(ans, 1LL * std :: max({i, j, x - i - j}) * f[n & 1][i][j]);
	
	printf("%lld\n", ans);
	return 0;
}
```

如果觉得这篇题解写得好，请不要忘记点赞，谢谢。

---

## 作者：WaterSun (赞：1)

[更好的阅读体验](https://www.cnblogs.com/WaterSun/p/18317328)

# 思路

观察到 $t_i$ 和 $n$ 都很小，考虑从此切入。

定义 $dp_{i,a,b,c}$ 表示用前 $i$ 本书，第一层厚 $a$，第二层厚 $b$，第三层厚 $c$ 的三层最小总高度。

然后你就发现 $c$ 这一维是完全可以被 $sum - a - b$ 计算出来的，可以优化掉。

由于中途插入一本书，可能会导致这层的高度发生改变。于是将书按照高度排序，每一层放入的第一本书都是高度最高的。

接下来的转移就比较轻松了。

时间复杂度 $\Theta(n(\sum{t_i})^2)$，空间复杂度可以滚动掉 $n$。

注意判断答案的合法性。

# Code

```cpp
#include <bits/stdc++.h>
#define re register

using namespace std;

const int N = 110,M = 3010,inf = 1e9 + 10;
int n,cnt,ans = inf;
int r,dp[2][M][M];

struct point{
    int h,d;

    inline bool friend operator <(const point &a,const point &b){
        return a.h > b.h;
    }
}arr[N];

inline int read(){
    int r = 0,w = 1;
    char c = getchar();
    while (c < '0' || c > '9'){
        if (c == '-') w = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9'){
        r = (r << 3) + (r << 1) + (c ^ 48);
        c = getchar();
    }
    return r * w;
}

int main(){
    n = read();
    for (re int i = 1;i <= n;i++){
        arr[i].h = read(); arr[i].d = read();
        cnt += arr[i].d;
    }
    sort(arr + 1,arr + n + 1);
    for (re int i = 0,sum = 0;i < n;i++){
        sum += arr[i].d;
        for (re int a = 0;a <= cnt;a++){
            for (re int b = 0;a + b <= cnt;b++) dp[r ^ 1][a][b] = inf;
        }
        for (re int a = 0;a <= sum;a++){
            for (re int b = 0;a + b <= sum;b++){
                int c = sum - a - b;
                if (dp[r][a][b] == inf) continue;
                if (!a) dp[r ^ 1][arr[i + 1].d][b] = min(dp[r ^ 1][arr[i + 1].d][b],dp[r][a][b] + arr[i + 1].h);
                else dp[r ^ 1][a + arr[i + 1].d][b] = min(dp[r ^ 1][a + arr[i + 1].d][b],dp[r][a][b]);
                if (!b) dp[r ^ 1][a][arr[i + 1].d] = min(dp[r ^ 1][a][arr[i + 1].d],dp[r][a][b] + arr[i + 1].h);
                else dp[r ^ 1][a][b + arr[i + 1].d] = min(dp[r ^ 1][a][b + arr[i + 1].d],dp[r][a][b]);
                if (!c) dp[r ^ 1][a][b] = min(dp[r ^ 1][a][b],dp[r][a][b] + arr[i + 1].h);
                else dp[r ^ 1][a][b] = min(dp[r ^ 1][a][b],dp[r][a][b]);
            }
        }
        r ^= 1;
    }
    for (re int i = 1;i <= cnt;i++){
        for (re int j = 1;i + j <= cnt;j++){
            int k = cnt - i - j;
            if (dp[r][i][j] != inf && k) ans = min(ans,max({i,j,k}) * dp[r][i][j]);
        }
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：一只书虫仔 (赞：1)

[P2160 [SHOI2007]书柜的尺寸](https://www.luogu.com.cn/problem/P2160)

### Description

给定 $n$ 个元素，每个元素都有两个参数 $h_i,t_i$，将其分为三个 Set $S_1,S_2,S_3$ 满足
$$S=(\sum_{j=1}^3 \max_{i \in S_j} h_i) \times (\max_{j=1}^3 \sum_{i \in S_j} t_i) $$
求 $S$ 的最小值。

### My Opinion

这题其实是 dp 题但是要用到数论知识的啦（

并且还是特别恶心要用上滚动数组的那种 dp（

为了我的 List 所以只好做这道恶心的数（d）论（p）题（

### Solution

dp 就看状态表示和转移方程嘛！就是下面两点

- 状态表示：$dp[i][j][k]$ 代表前 $i$ 本书中第一层搁 $j$ 本书第二层搁 $k$ 本书时的最小高度。
- 转移方程：
$$dp[i \& 1][j+book[i].t][k]=\begin{cases}\min(dp[i \& 1][j+book[i].t][k],dp[i \&1 \text{ xor }1][j][k])(j \ne 0)\\\min(dp[i\&1][j+book[i].t][k],dp[i\&1 \text{ xor }1][j][k]+book[i].h)(j=0)\end{cases}$$
$$dp[i\&1][j][k+book[i].t]=\begin{cases}\min(dp[i\&1][j][k+book[i].t],dp[i\&1\text{ xor }1][j][k])(k \ne 0)\\\min(dp[i\&1][j][k+book[i].t],dp[i\&1\text{ xor }1][j][k]+book[i].h)(k = 0)\end{cases}$$
$$dp[i\&1][j][k]=\begin{cases}\min(dp[i\&1][j][k],dp[i\&1\text{ xor }1][j][k](roll[i-1]-j-k \ne 0)\\\min(dp[i\&1][j][k],dp[i\&1\text{ xor }1][j][k]+book[i].h(roll[i-1]-j-k = 0)\end{cases}$$

转移方程的说明：

- $book[i]$ 代表第 $i$ 本书，$h,t$ 分别代表 $h_i,t_i$。
- $roll[i]$ 是滚动数组。
- $dp[i][j][k]$ 在上面解释过了。

滚动数组 $roll[i]$ 的方程为
$$roll[i]=roll[i-1]+book[i].t$$
然后，接下来我们就分析这个柿子
$$S=(\sum_{j=1}^3 \max_{i \in S_j} h_i) \times (\max_{j=1}^3 \sum_{i \in S_j} t_i)$$
这个 $S$ 化简一下就是说 $S$ 是在 $i \in [1,roll[n]],j\in[1,roll[n]]$ 里，
$$\max(roll[n]-i-j,i,j)\times dp[n\&1\text{ xor }1][i][j]$$
的最小值。

分析完毕之后代码就可以逐步托出啦 ~

代码：[Link](https://www.luogu.com.cn/paste/fukiz66x)

---

参考资料：

我要吃熊猫（好残忍 /kk）大佬的 [Blog](https://blog.csdn.net/chai_jing/article/details/67633805)

---

## 作者：lyb666666 (赞：1)

## 题解

首先注意到一点，高度最高的那本书，不论我们把它放在1、2、3层，它都会成为它那一层的最高。所以不妨先确定下这本书，把这本高度最高的书放在第一层，那么第一层在高度上对答案的贡献就可以确定为这个最大高度了。

如何去安排上面两层使得面积最小呢。现在存在两维——高度和宽度，我们尝试利用Dp消掉其中一个来简化问题。

### 1.定义

定义状态$dp[i][p1][p2]$表示，已经摆放好了前$i$本书（注意到摆书的顺序对答案是没有影响的），第二层剩余的宽度为$p1$，第三层剩余的宽度为$p2$，此时二三两层加起来的**总高度**最小能为多少。

### 2.转移

等等，这样该如何转移呢？按常规转移思路来说应该还得记录下其中一层的高度，不然我现在放的书比之前放在这一层的那本书高度要大时，理应更新这一层在高度上对答案的贡献才对，但我此刻却不知道之前这一层的高度是多少。

解决方案不难想到，我们可以直接**从大到小排序高度**，那么假如这本书是当前层所放的第一本书，那么这一层在高度上对答案的贡献就确定了(后面不会再有书比现在的书高了)。

这样我们就可以利用填表进行转移了：

**初态**：$dp[i][p1][p2]=$INF，$dp[1][0][0]=$1。

```cpp
inline void Do(int &x,int y){if(x>y)x=y;} 

枚举i,j,k{
if(a[i].w<j)Do(dp[j][k],dp[j-a[i].w][k]);
else if(j==a[i].w)Do(dp[j][k],dp[0][k]+a[i].h);//i是第二层放的第一本书
if(a[i].w<k)Do(dp[j][k],dp[j][k-a[i].w]);
else if(k==a[i].w)Do(dp[j][k],dp[j][0]+a[i].h);//i是第三层放的第一本书
}
```

**终态**：枚举$p1,p2$，$ans=max(ans,H*W)$，其中$H=dp[n][p1][p2]+Maxheight$，$W=max(p1,max(p2,Lim-p1-p2)$，$Lim$表示所有书的宽度之和。

### 3.空间优化

还有一个问题就是空间显然会炸。

**第一种解决方案**：根据上面的转移顺序可以知道，对于第$i$本书，只会用到第$i-1$本书的状态，所以显然可以把第一维给**滚动**了。

**第二种解决方案**：但也可以直接去掉这一维而无需滚动。但是转移顺序得稍微调整一下，我们上面枚举的$j,k$得从大到小枚举，这和01背包倒着循环是一个道理。

### 4.一点时间上的小优化

前面枚举$j,k$的上限不必为$Lim$（所有书本的宽度总和），可以用**前缀和**来代替，从而省去很多无用的枚举。

综上此做法时间复杂度为$O(N*logN+N*Lim*Lim)$，其中$N<=70,Lim<=2100$。

完整代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int INF=1890000;
inline int read(){}
int n,m,Lim;
int dp[2200][2200],sum[75];
struct node{int h,w;}a[75];
inline bool cmp(node x,node y){return x.h>y.h;}
inline void Do(int &x,int y){if(x>y)x=y;} 
int main(){
	n=read();
	for(register int i=1;i<=n;i++){
		a[i].h=read(),a[i].w=read();
		Lim+=a[i].w;
	}
	sort(a+1,a+n+1,cmp);
	for(register int i=1;i<=n;i++)sum[i]=sum[i-1]+a[i].w;
	for(register int i=0;i<=Lim;i++)for(register int j=0;j<=Lim;j++)dp[i][j]=INF;
    dp[0][0]=0;
	for(register int i=2;i<=n;i++){
		for(register int j=sum[i];j>=0;j--)for(register int k=sum[i];k>=0;k--){
			if(a[i].w<j)Do(dp[j][k],dp[j-a[i].w][k]);
			else if(j==a[i].w)Do(dp[j][k],dp[0][k]+a[i].h);
			if(a[i].w<k)Do(dp[j][k],dp[j][k-a[i].w]);
			else if(k==a[i].w)Do(dp[j][k],dp[j][0]+a[i].h);
		}
	}
	int ans=INF;
	for(register int i=1;i<=Lim;i++)for(register int j=1;j<=Lim;j++){
		if(dp[i][j]==INF)continue;
		int H=dp[i][j]+a[1].h,W=max(Lim-i-j,max(i,j));
		Do(ans,H*W);
	}
	printf("%d\n",ans);
}
```
[myblog](https://www.cnblogs.com/Tieechal/p/11414936.html)







---

## 作者：xuantianhao (赞：0)

## [ [SHOI2007] 书柜的尺寸](https://www.luogu.com.cn/problem/P2160)

排序是各类 DP 题中只要出现了物品这个意象后的常客。

我们首先将书按照高度递减排序。这样，一个书柜的高度，就是第一本被放进来的书的高度。

设 $f[i][j][k]$ 表示：DP 到第 $i$ 本书，第一层书架的长度为 $j$，第二层书架的长度为 $k$ 时，整个书柜的最小高度。设 $sum[i]$ 表示所有书厚度的前缀和。

我们枚举这本书到底是放入第一层、第二层还是第三层，第三层长度为 $sum[i]-j-k$。

转移分几种情况：

$\bullet$ 当 $j=0$，即第一层为空时，应该加上 $h[i]$。

$\bullet$ 当 $k=0$，应该加上 $h[i]$。

$\bullet$ 当 $j+k=sum[i]$，应该加上 $h[i]$。

答案就是枚举 $f[n][?][?]$ 统计答案即可。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[2][2110][2110],n,sum[110];
typedef long long ll;
ll res=0x3f3f3f3f3f3f3f3f;
pair<int,int>p[100];
bool cmp(pair<int,int>x,pair<int,int>y){
    return x.first>y.first;
}
int main(){
    scanf("%d",&n);
	memset(f,0x3f3f3f3f,sizeof(f));
    for(int i=1;i<=n;i++) scanf("%d%d",&p[i].first,&p[i].second);
    sort(p+1,p+n+1,cmp);
    for(int i=1;i<=n;i++) sum[i]=sum[i-1]+p[i].second;
    f[0][0][0]=0;
    for(int i=0;i<n;i++){
        memset(f[!(i&1)],0x3f3f3f3f,sizeof(f[!(i&1)]));
        for(int j=0;j<=sum[i];j++){
        	for(int k=0;j+k<=sum[i];k++){
            	f[!(i&1)][j+p[i+1].second][k]=min(f[!(i&1)][j+p[i+1].second][k],f[i&1][j][k]+p[i+1].first*(!j));
            	f[!(i&1)][j][k+p[i+1].second]=min(f[!(i&1)][j][k+p[i+1].second],f[i&1][j][k]+p[i+1].first*(!k));
            	f[!(i&1)][j][k]=min(f[!(i&1)][j][k],f[i&1][j][k]+p[i+1].first*(!(sum[i]-j-k)));
        	}
		}
    }
    for(int i=1;i<sum[n];i++){
    	for(int j=1;i+j<sum[n];j++){
    		res=min(res,1ll*max(max(i,j),sum[n]-i-j)*f[n&1][i][j]);
		}
	}
    printf("%d\n",res);
    return 0;
}
```


---

## 作者：2021hych (赞：0)

# 题意
给定一个长度为 $n$ 的二元序列 $(h_i,t_i)$。将每个二元组放到 $S_1$，$S_2$，$S_3$ 这 $3$ 个集合的其中之一，要求最后每个集合都不为空。求下面这个式子的最小值。

$$S=\left(\sum_{j=1}^3 \max_{i \in S_j} h_i\right) \times \left(\max_{j=1}^3 \sum_{i \in S_j} t_i\right) $$

# 题解
最优化问题，发现不仅没有单调性，而且贪心也贪不了一点，所以尝试 dp。

如果维护的是这个式子的最优值，那么右边括号里的式子我们是搞不了一点的，因为继承的值变化很大。所以我们来思考对部分进行维护。如果维护右边括号，由于最大值内部变化后继承十分不明显，我们放弃。对于左边括号，我们要解决的无非是里面最大值的继承。

突破口：放置与顺序无关。我们将二元序列按 $h$ 从大到小排序，那么集合的最大 $h$ 值就很好的继承了之前的最大值，因为每个集合第一次放入的 $h$ 将永远贡献到答案里。

这还不够，因为右边的式子会约束左边的式子，同时也要方便最后的统计。这就要用上数据范围了。$\sum_{i \in S_j} t_i$ 的值不会超过 $2100$。我们可以把三个集合的 $\sum_{i \in S_j} t_i$ 的值作为状态就好了。当然了，实际上只要维护两个两个集合就好了，第三个集合可以由前两个集合的情况做个全集容斥就好了。

整理一下思路。我们维护 $dp_{i,j,k}$ 表示排序后的前 $i$ 个二元组，$\sum_{i \in S_1} t_i=j$，$\sum_{i \in S_2} t_i=k$，$\sum_{j=1}^3 \max_{i \in S_j} h_i$ 的最小值。转移式也很简单，这里以其中一种决策为例。把二元组 $(h_i,t_i)$ 放到 $S_1$ 中：

$$dp_{i,j,k}=\min(dp_{i,j,k},dp_{i-1,j-t_i,k})(j>t_i)$$

$$dp_{i,j,k}=\min(dp_{i,j,k},dp_{i-1,0,k}+h_i)(j=t_i)$$

当然了，最后统计答案的时候要注意只考虑不存在空集的情况。

另外，考虑到空间复杂度的问题，要用滚动数组优化。
# AC code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=80;
const int M=2110;
const int inf=1e9;
int n,sum[N],now,pre;
int dp[2][M][M],ans=inf;
struct node {
	int h,t;
}a[N];
bool cmp(node x,node y) {
	return x.h>y.h;
}
void init(int x) {
	for(int i=0;i<M;i++)
		for(int j=0;j<M-i;j++) dp[x][i][j]=inf;
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i].h>>a[i].t;
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++) sum[i]=sum[i-1]+a[i].t;
	init(0);
	dp[0][0][0]=0;
	for(int i=1;i<=n;i++) {
		now=i&1,pre=now^1;
		init(now);
		for(int j=0;j<=sum[i];j++)
			for(int k=0;k<=sum[i]-j;k++) {
				if(j>=a[i].t) {
					if(j==a[i].t) dp[now][j][k]=min(dp[now][j][k],dp[pre][0][k]+a[i].h);
					else dp[now][j][k]=min(dp[now][j][k],dp[pre][j-a[i].t][k]);
				}
				if(k>=a[i].t) {
					if(k==a[i].t) dp[now][j][k]=min(dp[now][j][k],dp[pre][j][0]+a[i].h);
					else dp[now][j][k]=min(dp[now][j][k],dp[pre][j][k-a[i].t]);
				}
				if(sum[i]-j-k>=a[i].t) {
					if(sum[i]-j-k==a[i].t) dp[now][j][k]=min(dp[now][j][k],dp[pre][j][k]+a[i].h);
					else dp[now][j][k]=min(dp[now][j][k],dp[pre][j][k]);
				}
			}
	}
	for(int i=1;i<sum[n];i++)
		for(int j=1;j<sum[n]-i;j++) ans=min(ans,max(max(i,j),sum[n]-i-j)*dp[now][i][j]);
	cout<<ans;
	return 0;
}

```


---

## 作者：不存在之人 (赞：0)

DP+思路~

求最大高、之和，和最大、宽之和的乘积的最小值~（注意断句！）

首先，我们可以用f[i][j][k][z]表示目前DP到第i本书，三个柜的书的宽度分别为j,k,z的最小的最大高的值，但是显然像这样所有维度都记录的话会MLE，所以我们只能记录一部分的状态。

注意到DP到i时，已有的书的宽度之和是一定的，所以我们只需要记录三块中的两块的宽度之和就可以了。而i对递推过程无影响，所以把i维换成滚动形式。

所以用f[kkz][j][k]表示目前用kkz^1更新kkz，三个书柜宽度分别为j,k,sum[i-1]-j-k的最小的最大高度，然后预处理出宽度的前缀和sum[i]，直接DP即可~
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,f[2][2101][2101],inf,kkz,sum[71],h,w,ans;
struct node
{
	int h,w;
}a[71];
bool operator<(node u,node v)
{
	return u.h>v.h;
}
int read()
{
	int totnum=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		totnum=(totnum<<1)+(totnum<<3)+ch-'0';
		ch=getchar();
	}
	return totnum*f;
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
		a[i].h=read(),a[i].w=read();
	memset(f[kkz],127/3,sizeof(f[kkz]));
	ans=inf=f[kkz][0][0];
	f[kkz][0][0]=0;
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)
		sum[i]=sum[i-1]+a[i].w;
	for(int i=1;i<=n;i++)
	{
		kkz^=1;h=a[i].h;w=a[i].w;
		memset(f[kkz],127/3,sizeof(f[kkz]));
		for(int j=sum[i-1];~j;j--)
		  	for(int k=sum[i-1];~k;k--)
		    	if(j+k<=sum[i-1]&&f[kkz^1][j][k]<inf)
		    	{
		    		if(j) f[kkz][j+w][k]=min(f[kkz][j+w][k],f[kkz^1][j][k]);
		    		else f[kkz][w][k]=min(f[kkz][j][k],f[kkz^1][j][k]+h);
		    		if(k) f[kkz][j][k+w]=min(f[kkz][j][k+w],f[kkz^1][j][k]);
		    		else f[kkz][j][w]=min(f[kkz][j][w],f[kkz^1][j][k]+h);
		    		if(j+k<sum[i-1]) f[kkz][j][k]=min(f[kkz][j][k],f[kkz^1][j][k]);
		    		else f[kkz][j][k]=min(f[kkz][j][k],f[kkz^1][j][k]+h);
		    	}
	}
	for(int i=1;i<sum[n];i++)
	  	for(int j=1;j<sum[n];j++)
	    	if(i+j<sum[n] && f[kkz][i][j]<inf)
	      		ans=min(ans,max(max(i,j),sum[n]-i-j)*f[kkz][i][j]);
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：1234567890sjx (赞：0)

考虑 dp。设 $f_{i,a,b,c}$ 表示当前放了前 $i$ 本书，第一摞书厚度和为 $a$，第二摞书厚度和为 $b$，第三摞书厚度和为 $c$，高度和的最小值。

为了省去枚举的时间复杂度，所以考虑把所有的书按照高度从大到小排序。这样可以满足每一摞书的高度最大的书一定是第一本选入这一摞书的那本书的高度。

为了这个毒瘤的时间和空间限制，然后发现 $c$ 可以直接算出来，$i$ 这一个维度可以滚掉，然后就可以过了。


---


# [SHOI2007] 交通网络

## 题目描述

著名的城市交通规划师 L.Serenade 为 OItown 的各个城堡之间设计了一套的地铁交通网络。每一条地铁线路都用来双向连通两个城堡。因为是建在地下的不同深度，所以这些地铁线路是可以“交叉”的。

OItown 的居民们的生活和工作都在不同的城堡中进行，于是，每个 OItown 的居民都要在每天早晨从家出发，乘地铁去工作，当然地铁换乘是允许的。不过每个居民都会选择换乘次数最少的乘车方式。如果有多种乘车方式，这些乘车方式所需要的换乘次数一样，那么居民每天都会等概率的随机选择其中一种。

现在 L.Serenade 想请你为他计算出，每天每条地铁线路在早晨的期望客流量。他会告诉你，每个居民的家和工作地址，还有他设计的地铁交通网络的全部信息。

## 说明/提示

样例解释：

唯一一位居民会等概率地从以下三条路径中选择一条：

- $1 \to 2 \to 4 \to 6$
- $1 \to 2 \to 5 \to 6$
- $1 \to 3 \to 5 \to 6$

## 样例 #1

### 输入

```
6 7
1 2
1 3
2 4
2 5
3 5
4 6
5 6
0 0 0 0 0 1
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0```

### 输出

```
0.7
0.3
0.3
0.3
0.3
0.3
0.7```

# 题解

## 作者：Itst (赞：3)

题目还算不难吧

首先我们枚举点$i$，将其他所有点到这个点的最短路求出来

然后我们在这一次建出的最短路$DAG$的**反图**上进行拓扑排序。假设我们算到了点$j$，点$j$的人流量为$t_j$，点$j$连出去的边到达的点为点集$\{v\}$，那么对于每一个点$u \in \{v\}$，边$(j,u)$的流量就会增加$\frac{t_j}{|\{v\}|}$，$t_u$会加上$\frac{t_j}{|\{v\}|}$

总时间复杂度$O(N^2)$

强行插入自己的[blog](https://www.cnblogs.com/Itst/p/10186886.html)

```
#include<bits/stdc++.h>
#define ld long double
using namespace std;
inline int read(){
    int a = 0;
    char c = getchar();
    while(!isdigit(c))	c = getchar();
    while(isdigit(c))	a = (a << 3) + (a << 1) + (c ^ '0') , c = getchar();
    return a;
}
inline int max(int a , int b){
    return a > b ? a : b;
}
struct Ed{
    int start , end , upEd;
}ans[100001];
bool vis[301] , ifRail[301][301];
long long Times[301];
int firEd[301] , minRoute[301];
ld peo[301][301] , To[301][301];
struct cmp{
    bool operator() (const int& a, const int& b ){
        return minRoute[a] < minRoute[b];
    }
};
int main(){
    int N = read() , M = read();
    for(int i = 1 ; i <= M ; i++){
        int a = read() , b = read();
        ans[(i << 1) - 1].start = a;
        ans[(i << 1) - 1].end = b;
        ans[(i << 1) - 1].upEd = firEd[a];
        firEd[a] = (i << 1) - 1;
        ans[i << 1].start = b;
        ans[i << 1].end = a;
        ans[i << 1].upEd = firEd[b];
        firEd[b] = i << 1;
        ifRail[a][b] = ifRail[b][a] = 1;
    }
    for(int i = 1 ; i <= N ; i++)
        for(int j = 1 ; j <= N ; j++)	To[i][j] = read();
    for(int i = 1 ; i <= N ; i++){
        memset(minRoute , 0x3f , sizeof(minRoute));
        memset(Times , 0 , sizeof(Times));
        minRoute[i] = 0;
        Times[i] = 1;
        queue < int > q;
        priority_queue < int , vector < int > , cmp > q1;
        q.push(i);
        while(!q.empty()){
            int t = q.front();
            q.pop();
            bool f = 0;
            for(int j = firEd[t] ; j ; j = ans[j].upEd)
                if(minRoute[ans[j].end] > minRoute[t] + 1){
                    minRoute[ans[j].end] = minRoute[t] + 1;
                    Times[ans[j].end] = Times[t];
                    q.push(ans[j].end);
                    f = 1;
                }
                else	if(minRoute[ans[j].end] == minRoute[t] + 1){
                    Times[ans[j].end] += Times[t];
                    f = 1;
                }
            if(!f)	q1.push(t);
        }
        memset(vis , 0 , sizeof(vis));
        vis[i] = 1;
        while(!q1.empty()){
            int t = q1.top();
            q1.pop();
            for(int j = 1 ; j <= N ; j++)
                if(ifRail[j][t] && minRoute[j] == minRoute[t] - 1){
                    ld t1 = (ld)To[i][t] * Times[j] / Times[t];
                    peo[j][t] += t1;
                    peo[t][j] += t1;
                    To[i][j] += t1;
                    if(!vis[j]){
                        vis[j] = 1;
                        q1.push(j);
                    }
                }
        }
    }
    for(int i = 1 ; i <= M ; i++)
        cout << fixed << setprecision(1) << peo[ans[i << 1].start][ans[i << 1].end] + 1e-8 << endl;
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

### 一、前置知识

[最短路径](https://www.luogu.com.cn/problem/P4779)

[拓扑排序](https://oi-wiki.org/graph/topo/)

### 二、题目解析

由题目可知，我们需要求的每条边的客流量是沿着最短路径传播的，所以对于每一个出发点 $i$，我们一定可以找到一些终点，使得所有点都在 $i$ 到终点的最短路径上，于是我们可以在最短路过程中记录下所有出度为 $0$ 的点，再反过来按照拓扑序处理即可。

而对于当前处理的点 $j$，它的人流量为 $to_{i,j}$，则对于最短路径上可以到达它的点 $u \in \left \{  v\right \} $，边 $(u,j)$ 的流量可以增加 $\frac{to_{i,j}}{\left | \left \{ v \right \}  \right | }$。

总的时间复杂度和使用的最短路有关系。如果用 Spfa 就是 $O(n^2m)$， 用堆优化 Dijkstra 就是 $O(n^2 \log_{2}{m} )$ ~~虽然没必要~~。

### 三、代码

+ Spfa

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef long double ld;
template<typename T>inline void rd(T&x) {
	x = 0;
	T f = 1;
	char ch = getchar();
	while (!isdigit(ch))f = (ch == '-') ? -1 : 1, ch = getchar();
	while (isdigit(ch))x = (x << 1) + (x << 3) + ch - '0', ch = getchar();
	x *= f;
}
const ll M = 100010, N = 310;
struct EDGE {
	ll s, t;
} ed[M << 1];
ll n, m, d[N][N];
ll dis[N], in[N];
bool vis[M];
struct Node {
	ll x, dis;
	bool operator <(const Node&a)const {
		return dis < a.dis;
	}
};
priority_queue<Node>q1;
void dij(ll s) {
	queue<ll>q;
	memset(dis, 0x3f, sizeof dis);
	memset(in, 0, sizeof in);
	dis[s] = 0;
	in[s] = 1;
	q.push(s);
	while (!q.empty()) {
		ll x = q.front();
		q.pop();
		bool f = 0;
		for (ll j = 1; j <= n; j++)
			if (dis[x] + d[x][j] < dis[j]) {
				dis[j] = dis[x] + d[x][j];
				in[j] = in[x];
				q.push(j);
				f = 1;
			} else if (dis[x] + d[x][j] == dis[j])in[j] += in[x], f = 1;
		if (!f)q1.push({x, dis[x]});
	}
}
ld to[N][N],ans[N][N];
int main() {
	rd(n), rd(m);
	memset(d, 0x3f, sizeof d);
	for (ll i = 1; i <= m; i++) {
		ll x, y;
		rd(x), rd(y);
		ed[i] = {x, y};
		d[x][y] = d[y][x] = 1;
	}
	for(ll i=1;i<=n;i++)
		for(ll j=1;j<=n;j++)cin>>to[i][j];
	for (ll i = 1; i <= n; i++) {
		dij(i);
		memset(vis, 0, sizeof(vis));
		vis[i] = 1;
		while (!q1.empty()) {
			ll x = q1.top().x;
			q1.pop();
			for (ll j = 1 ; j <= N ; j++)
				if (d[j][x]==1 && dis[j] == dis[x] - 1) {
					ld t = (ld)to[i][x] * in[j] / in[x];
					ans[j][x] += t;
					ans[x][j] += t;
					to[i][j] += t;
					if (!vis[j]) {
						vis[j] = 1;
						q1.push({j,dis[j]});
					}
				}
		}
	}
	for(ll i=1;i<=m;i++)printf("%.6Lf\n",ans[ed[i].s][ed[i].t]);
	return 0;
}

```

+ 堆优化 Dijkstra

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define int ll
template<typename T>inline void rd(T&x) {
	x = 0;
	T f = 1;
	char ch = getchar();
	while (!isdigit(ch))f = (ch == '-') ? -1 : 1, ch = getchar();
	while (isdigit(ch))x = (x << 1) + (x << 3) + ch - '0', ch = getchar();
	x *= f;
}
const int M = 100010, inf = INT_MAX, N = 400;
int dis[M];
struct Node {
	int x, dis;
};
bool operator <(const Node &a, const Node &b) {
	return a.dis > b.dis;
}
struct NODE {
	int x, dis;
};
bool operator <(const NODE &a, const NODE &b) {
	return a.dis < b.dis;
}
priority_queue < NODE> q1;
priority_queue<Node>q;
struct Edge {
	int to, nxt, v;
} e[M << 1];
struct edge {
	int s, t;
} ed[M];
int hd[N], tot = 0, n, m, vis[N], s,in[N],b[N][N];
inline void addedge(int x, int y, int v) {
	e[++tot] = {y, hd[x], v};
	hd[x] = tot;
}
double ans[N][N];
inline void dij(int s) {
	fill(dis, dis + n + 1, inf);
	memset(vis, 0, sizeof vis);
	memset(dis, 0x3f, sizeof dis);
	memset(in, 0, sizeof in);
	dis[s] = 0;
	in [s] = 1;
	q.push({s, 0});
	while (!q.empty()) {
		int x = q.top().x, ds = q.top().dis;
		q.pop();
		bool f = 1;
		if (vis[x] || ds != dis[x])continue;
		for (int i = hd[x]; i; i = e[i].nxt) {
			int go = e[i].to;
			if (go == x)continue;
			if (dis[go] > ds + e[i].v) {
				dis[go] = ds + e[i].v;
				q.push({go, dis[go]});
				in[go] = in[x];
				f = 0;
			} else if (dis[go] == ds + e[i].v)in[go] += in[x], f = 0;
		}
		if (f)q1.push({x, dis[x]});
	}
}
double d[N][N];
signed main() {
	rd(n), rd(m);
	for (int i = 1; i <= m; i++) {
		int x, y;
		rd(x), rd(y);
		ed[i] = {x, y};
		addedge(x, y, 1);
		addedge(y, x, 1);
		b[x][y]=b[y][x]=1;
	}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)cin >> d[i][j];
	for (int i = 1; i <= n; i++) {
		dij(i);

		memset(vis, 0, sizeof(vis));
		vis[i] = 1;
		while (!q1.empty()) {
			int x = q1.top().x;
			q1.pop();
			for (int j = 1 ; j <= n ; j++)
				if (b[j][x]&&dis[j] == dis[x] - 1) {
					double t1 = (double)d[i][x] * in[j] / in[x];
					ans[j][x] += t1;
					ans[x][j] += t1;
					d[i][j] += t1;
					if (!vis[j]) {
						vis[j] = 1;
						q1.push({j, dis[j]});
					}
				}
		}
	}
	for (int i = 1; i <= m; i++)
		printf("%.6lf\n", ans[ed[i].s][ed[i].t]);
	return 0;
}

```

### 四、坑点

一定要注意精度多保留几位小数，不开 ```long long``` 见祖宗。

---


# [ZJOI2012] 网络

## 题目描述

有一个无向图 $G$，每个点有个权值，每条边有一个颜色。这个无向图满足以下两个条件：

1、 对于任意节点连出去的边中，相同颜色的边不超过两条。

2、图中不存在同色的环，同色的环指相同颜色的边构成的环。

在这个图上，你要支持以下三种操作：

- `0 x y` 表示把节点 $x$ 的权值改为 $y$

- `1 u v w` 表示将边 $(u,v)$ 的颜色改为 $w$。  

- `2 c u v` 表示查询由颜色 $c$ 的边构成的图中，所有可能在 $u \to v$ 之间的简单路径上的节点的权值的最大值。


## 说明/提示

 ![](https://cdn.luogu.com.cn/upload/pic/1714.png) 

颜色 $0$ 为实线的边，颜色 $1$ 为虚线的边，

由颜色 $0$ 构成的从节点 $1$ 到节点 $4$ 的路径有 $1 \to 2 \to 4$，故$\max\{v_1, v_2, v_4\} = \max\{ 1, 2, 4 \} = 4$。

将连接节点 $1$ 和节点 $2$ 的边修改为颜色 $1$，修改成功，输出 `Success.`

将连接节点 $4$ 和节点 $3$ 的边修改为颜色 $1$，由于修改后会使得存在由颜色 $1$ 构成的环( $1 – 2 – 4 – 3 – 1$ )，不满足条件 $2$，故不修改，并输`Error 2`。

不存在颜色 $0$ 构成的从节点 $1$ 到节点 $4$ 的边，输出 `-1`。

将连接节点 $2$ 和节点 $3$ 的边修改为颜色 $1$，由于修改后节点 $2$ 的连出去的颜色为 $1$ 的边有 $3$ 条，故不满足条件 $1$，故不修改，并输出`Error 1.` 。

将节点 $2$ 的权值修改为 $5$。

由颜色 $1$ 构成的从节点 $1$ 到节点 $4$ 的路径有 $1 \to 2 \to 4$，故$\max\{v_1, v_2, v_4\} = \max\{ 1, 5, 4 \} = 5$。

【数据范围】

对于 $30\%$ 的数据：$n ≤ 1000$，$m ≤ 10^4$，$k ≤ 1000$；   
另有 $20\%$ 的数据：$n ≤ 10^4$，$m ≤ 10^5$，$C = 1$，$k ≤ 10^5$；   
对于 $100\%$ 的数据：$n ≤ 10^4$，$m ≤ 10^5$，$C ≤ 10$，$k ≤ 10^5$。  

$1\le u,v,x \le n$，$0 \le c < C$，保证图中没有重边和自环。


## 样例 #1

### 输入

```
4 5 2 7
1
2
3
4
1 2 0
1 3 1
2 3 0
2 4 1
3 4 0
2 0 1 4
1 1 2 1
1 4 3 1
2 0 1 4
1 2 3 1
0 2 5
2 1 1 4```

### 输出

```
4
Success.
Error 2.
-1
Error 1.
5```

# 题解

## 作者：fdfdf (赞：16)

# **关键词:LCT**

如果我们把每一种颜色的边所组成的图单独拿出来看的话:

**保证没有同色的环

保证任意节点连出去相同颜色的边不超过两条**

很明显就是几条链吧

再看看我们需要支持的操作:

**改变边的颜色(相当于断一次边,连一次边)

修改权值

查询路径**

很明显就是LCT吧

各位如果不会LCT的请右转>https://www.luogu.org/problemnew/show/P3690

最后看一看数据:

N ≤ 10000,M ≤ 100000,C ≤ 10,K ≤ 100000。

O(NlogNC)直接**暴力找颜色**就好啦

**操作0:**

和普通的LCT其实很相似.那么如何同时修改多个LCT呢（⊙ｏ⊙）？

把所有颜色中LCT的位置都转移到LCT->修改->在所有颜色的LCT上update

**操作1:**

1.对于如何判断u,v两个点是否直接相连,这里推荐另外两种可行的办法:

(1)maktroot(u),access(v),splay(v)

这样如果u,v直接有边相连的话,v(当前splay的根节点)的儿子一定是u且u没有右儿子(就是u,v在splay里中间没有夹其他的点==深度相邻)

(2)一开始存边的时候直接存邻接表,由于每个点连边的总数不超过2\*C<=20,**常数**不大对吧......

2.Error 1:记录连边数组d[c][x]表示点x在颜色c上连边的条数,并判断

3.Error 2:判断是否联通,判断findroot(u)==findroot(v)即可

4.在当前颜色的LCT中删除这条边并且在需求颜色的LCT中添加这条边

5.一个需要注意的地方:新边的颜色有可能和旧边的颜色相等!!!记得加特判!!!

**操作2:**

模板似的查询...请看代码


就是这样了

```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define RG register
using namespace std;
inline int read(){
    RG int data=0,w=1;RG char ch=getchar();
    while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
    if(ch=='-')w=-1,ch=getchar();
    while(ch<='9'&&ch>='0')data=data*10+ch-48,ch=getchar();
    return data*w;
}
const int N=10010;
const int M=100010;
const int C=10;
int val[N],maxn[C][N],rv[C][N],s[2][C][N],fa[C][N],f[C][N];
int cal[N],top;
int d[C][N];

inline void update(int c,int i){
    maxn[c][i]=max(maxn[c][s[0][c][i]],max(maxn[c][s[1][c][i]],val[i]));
}
inline void pushdown(int c,int i){
    if(!rv[c][i])return;rv[c][i]^=1;rv[c][s[0][c][i]]^=1;rv[c][s[1][c][i]]^=1;swap(s[0][c][i],s[1][c][i]);
}
inline bool isroot(int c,int i){
    return s[0][c][fa[c][i]]!=i&&s[1][c][fa[c][i]]!=i;}

inline bool isr(int c,int i){return s[1][c][fa[c][i]]==i;}
inline void rot(int c,int i){
    RG int j=fa[c][i],k=fa[c][j];
    RG bool b=isr(c,i);
    if(!isroot(c,j))
        s[isr(c,j)][c][k]=i;
    fa[c][i]=k;
    s[b][c][j]=s[!b][c][i];
    if(s[!b][c][i])fa[c][s[!b][c][i]]=j;
    fa[c][j]=i;s[!b][c][i]=j;
    update(c,j);
}

inline void splay(int c,int i){
    cal[++top]=i;
    for(RG int x=i;!isroot(c,x);x=fa[c][x])
        cal[++top]=fa[c][x];
    while(top)pushdown(c,cal[top--]);
    for(RG int j=fa[c][i];!isroot(c,i);rot(c,i),j=fa[c][i])
        if(!isroot(c,j))isr(c,i)^isr(c,j)?rot(c,i):rot(c,j);
    update(c,i);
}

inline void access(int c,int x){for(RG int y=0;x;y=x,x=fa[c][x])splay(c,x),s[1][c][x]=y,update(c,x);}
inline void makeroot(int c,int x){access(c,x);splay(c,x);rv[c][x]^=1;}
inline int findroot(int c,int x){access(c,x);splay(c,x);while(s[0][c][x])x=s[0][c][x];return x;}
inline void split(int c,int x,int y){makeroot(c,x);access(c,y);splay(c,y);}
inline void cut(int c,int x,int y){
    d[c][x]--;d[c][y]--;
    split(c,x,y);fa[c][x]=s[0][c][y]=0;
}
inline void link(int c,int x,int y){
    d[c][x]++;d[c][y]++;
    makeroot(c,x);fa[c][x]=y;
}
//以上,一个正常的LCT
inline void modify_val(int c){//操作1
    RG int x=read(),y=read();
    for(RG int i=0;i<c;i++)access(i,x),splay(i,x);
    val[x]=y;
    for(RG int i=0;i<c;i++)update(i,x);
    return;
}

inline void modify_line(int c){//操作2
    RG int u=read(),v=read(),w=read();
    for(RG int i=0;i<c;i++)
        if(findroot(i,u)==findroot(i,v))
        {
            split(i,u,v);
            if(s[0][i][v]!=u||s[1][i][u])continue;
            if(i==w){//注意此处!!!
                puts("Success.");return;
            }
            if((d[w][u]==2)||(d[w][v]==2)){
                puts("Error 1.");return;
            }
            else if(findroot(w,u)==findroot(w,v)){
                puts("Error 2.");return;
            }
            else{
                cut(i,u,v);link(w,u,v);
                puts("Success.");return;
            }
        }
    puts("No such edge.");
}

inline void query(){//操作3
    RG int c=read(),u=read(),v=read();
    if(findroot(c,u)!=findroot(c,v)){puts("-1");return;}
    split(c,u,v);printf("%d\n",maxn[c][v]);
}

inline void print(int c,int i){
    if(s[0][c][i])print(c,s[0][c][i]);
    printf("(%d:%d)\n",i,c);
    if(s[1][c][i])print(c,s[1][c][i]);
}

int main()
{
    RG int n,m,c,k,u,v,w,opt;
    n=read();m=read();c=read();k=read();
    for(RG int i=1;i<=n;i++)val[i]=read();
    while(m--){
        u=read();v=read();w=read();
        link(w,u,v);
    }
    while(k--){
        opt=read();
        if(!opt)modify_val(c);
        if(opt==1)modify_line(c);
        if(opt==2)query();
    }
    return 0;
}
/*
    食用LCT
    操作0:modify:access->splay->val->update
    操作1:cut所在颜色的边->link修改颜色的边
    找到颜色:暴力O(C) 找不到->No such edge.
    修改:查询度->if(d==2)->Error 1.
    查询联通->if(findroot==findroot)->Error 2.
    成功->Success.
    操作2:query:split->maxn
*/

```

---

## 作者：zcysky (赞：11)

一道比较裸的LCT，可以利用STL偷偷懒维护边的访问情况~

这题如果单看每种颜色，我们只要建一个LCT就能轻松水过去，无非是要加个cnt

但是颜色多怎么办？考虑颜色种类很小，我们多建几个LCT不就行了么？

```cpp
#include<bits/stdc++.h>
#define N 10005
#define M 100005
using namespace std;
int n, m, c, k, u, v, w, op, x,val[N];
struct Link_Cut_Tree{
    int c[N][2],fa[N],rev[N],maxv[N],cnt[N],q[N];
    inline void pushup(int x){
        maxv[x]=val[x];int l=c[x][0],r=c[x][1];
        if(l)maxv[x]=max(maxv[x],maxv[l]);
        if(r)maxv[x]=max(maxv[x],maxv[r]);
    }
    inline void pushdown(int x){
        int l=c[x][0],r=c[x][1];
        if(rev[x]){
            rev[l]^=1;rev[r]^=1;rev[x]^=1;
            swap(c[x][0],c[x][1]);
        }
    }
    bool isroot(int x){return c[fa[x]][0]!=x&&c[fa[x]][1]!=x;}
    void rotate(int x){
        int y=fa[x],z=fa[y],l,r;
        l=(c[y][1])==x;r=l^1;
        if(!isroot(y))c[z][c[z][1]==y]=x;
        fa[c[x][r]]=y;fa[y]=x;fa[x]=z;
        c[y][l]=c[x][r];c[x][r]=y;
        pushup(y);pushup(x);
    }
    void splay(int x){
        int top=0;q[++top]=x;
        for(int i=x;!isroot(i);i=fa[i])q[++top]=fa[i];
        while(top)pushdown(q[top--]);
        while(!isroot(x)){
            int y=fa[x],z=fa[y];
            if(!isroot(y)){
            if(c[y][0]==x^c[z][0]==y)rotate(x);else rotate(y);
            }
        rotate(x);
        }
    }
    void access(int x){for(int t=0;x;t=x,x=fa[x])splay(x),c[x][1]=t,pushup(x);}
    void makeroot(int x){access(x);splay(x);rev[x]^=1;}
    void link(int x,int y){cnt[x]++;cnt[y]++;makeroot(x);fa[x]=y;splay(x);}
    void split(int x,int y){makeroot(x);access(y);splay(y);}
    void cut(int x,int y){split(x,y);cnt[x]--;cnt[y]--;c[y][0]=fa[x]=0;pushup(y);}
    int find(int x){access(x);splay(x);int y=x;while(c[y][0])y=c[y][0];return y;}
    int querymax(int x,int y){split(x,y);return maxv[y];}    
}lct[15];
inline int read(){
    int f=1,x=0;char ch;
    do{ch=getchar();if(ch=='0')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
struct Edge{
    int u,v;
    bool operator<(const Edge &x)const{if(u!=x.u)return u<x.u;
    else return v<x.v;}
};
map<Edge,int> mp;
int main(){
    n=read();m=read();c=read();k=read();
    for(int i=1;i<=n;i++)val[i]=read();
    for(int i=1;i<=m;i++){
        int u=read(),v=read(),w=read();
        w++;
        Edge e1=(Edge){u,v},e2=(Edge){v,u};
        mp[e1]=mp[e2]=w;
        lct[w].link(u,v);
    }
    while(k--){
        int opt=read();
        if(opt==0){
            int x=read(),w=read();
            val[x]=w;
            for(int i=1;i<=c;i++)lct[i].splay(x);
        }
        else if(opt==1){
            int u=read(),v=read(),w=read();
            w++;
            Edge a=(Edge){u,v},b=(Edge){v,u};
            if(!mp.count(a)){
                puts("No such edge.");continue;
            }
            int xxx=mp[a];
            if(xxx==w){
                puts("Success.");continue;
            }
            if(lct[w].cnt[u]>=2||lct[w].cnt[v]>=2){
                puts("Error 1.");continue;
            }
            if(lct[w].find(u)==lct[w].find(v)){
                puts("Error 2.");continue;
            }
            puts("Success.");
            lct[xxx].cut(u,v);lct[w].link(u,v);
            mp[a]=mp[b]=w;
        }else{
            int w=read(),u=read(),v=read();
            w++;
            if(lct[w].find(u)!=lct[w].find(v)){
                puts("-1");continue;
            }
            printf("%d\n",lct[w].querymax(u,v));
        }
    }
    return 0;
}
```

---

## 作者：Katyusha_01 (赞：5)

**这是一篇 FHQ 题解。**

其他题解都是 LCT 做的，我就不服气，这道题中只有链，完全可以直接用 FHQ-Treap 维护链。

**具体的：**  
分成 $C$ 张独立的图维护，按照链的顺序对每条链建一棵 FHQ-Treap：  
连接 $u$ 和 $v$ 时：要想拼完最大度数不超过 $2$ 就必须都是链头或链尾；要想没有环，就不能在同一条链上（读者自证不难）。如果两个都是链头或者两个都是链尾就翻转一个，然后链头 `merge` 到链尾后面。

对于查询操作：写一个查询排名的函数，把两端点之间的点都分裂出来，求个最大值即可。

断链也很简单：直接查询排名 `split` 一下就行了。

修改点权一路 `pushup` 上去即可。

时间复杂度 $O(m\log n + kC\log n)$。  
不用卡常轻松拿下最优解。
```cpp
#include<bits/stdc++.h>
using namespace std;
mt19937 Rnd(time(0));
const int N = 10011;
typedef struct{
	typedef struct{
		int key,fa,siz,mx,x; 
		int ls,rs;
		bool rev;
	}Tree;
	Tree t[N];
	void rev(int p)
	{
		swap(t[p].ls,t[p].rs),t[p].rev ^= 1;
	}
	void pushdown(int p)
	{
		if(t[p].rev) rev(t[p].ls),rev(t[p].rs),t[p].rev = 0;
	}
	void pushup(int p)
	{
		t[p].mx = max({t[t[p].ls].mx,t[p].x,t[t[p].rs].mx});
		t[p].siz = t[t[p].ls].siz + 1 + t[t[p].rs].siz;
		t[t[p].ls].fa = t[t[p].rs].fa = p;
	}
	void Pushup(int p)
	{
		while(p) pushup(p),p = t[p].fa;
	}
	void split(int p,int k,int& l,int& r)
	{
		if(!p) return l = r = 0,void();
		pushdown(p);
		if(t[t[p].ls].siz + 1 <= k)
			l = p,split(t[p].rs,k - t[t[p].ls].siz - 1,t[p].rs,r);
		else
			r = p,split(t[p].ls,k,l,t[p].ls);
		pushup(p);
	}
	int merge(int x,int y)
	{
		if(!x || !y) return (x | y);
		if(t[x].key < t[y].key)
			return pushdown(x),t[x].rs = merge(t[x].rs,y),pushup(x),x;
		return pushdown(y),t[y].ls = merge(x,t[y].ls),pushup(y),y;
	}
	int st[N];
	int rk(int p)
	{
		int top = 0,r = p;
		st[++top] = r;
		while(t[r].fa) st[++top] = r = t[r].fa;
		while(top) pushdown(st[top--]);
		int res = t[t[p].ls].siz + 1;
		while(t[p].fa)
		{
			if(t[t[p].fa].rs == p)
				res += t[t[t[p].fa].ls].siz + 1;
			p = t[p].fa;
		}
		return res;
	}
	int findroot(int x)
	{
		while(t[x].fa) x = t[x].fa;
		return x;
	}
	int ask(int x,int y)
	{
		int rot = findroot(x);
		if(rot != findroot(y))
			return -1;
		int l = rk(x),r = rk(y);
		if(l > r) swap(l,r);
		split(rot,r,x,y);
		int w;
		split(x,l - 1,x,w);
		rot = t[w].mx;
		t[merge(merge(x,w),y)].fa = 0;
		return rot;
	}
	bool link(int x,int y)
	{
		int X = findroot(x),Y = findroot(y);
		if(X == Y)
		{
			x = rk(x),y = rk(y);
			if(x > y) swap(x,y);
			cout << (x == 1 && y == t[X].siz ? "Error 2.\n" : "Error 1.\n");
			return 0;
		}
		int kx = rk(x),ky = rk(y);
		if((kx != 1 && kx != t[X].siz) || (ky != 1 && ky != t[Y].siz))
		{
			cout << "Error 1.\n";
			return 0;
		}
		if(!((kx == 1) ^ (ky == 1))) rev(Y);
		if(kx == 1) t[merge(Y,X)].fa = 0;
		else t[merge(X,Y)].fa = 0;
		return 1;
	}
	void cut(int x,int y)
	{
		int l,r;
		split(findroot(x),min(rk(x),rk(y)),l,r);
		t[l].fa = t[r].fa = 0;
	}
}FHQ;
FHQ t[10];
int a[N];
int n,m,C,k;
map<pair<int,int>,int> mp;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin >> n >> m >> C >> k;
	for(int i = 1;i <= n;i++)
	{
		cin >> a[i];
		for(int j = 0;j < C;j++)
			t[j].t[i] = {(int)Rnd(),0,1,a[i],a[i],0,0,0};
	}
	for(int i = 1;i <= m;i++)
	{
		int x,y,w;
		cin >> x >> y >> w;
		if(x > y) swap(x,y);
		mp[{x,y}] = w;
		t[w].link(x,y);
	}
	while(k--)
	{
		int opt;
		cin >> opt;
		if(opt == 0)
		{
			int x,y;
			cin >> x >> y;
			a[x] = y;
			for(int c = 0;c < C;c++)
				t[c].t[x].x = y,t[c].Pushup(x);
		}else if(opt == 1)
		{
			int x,y,w;
			cin >> x >> y >> w;
			if(x > y) swap(x,y);
			if(!mp.count({x,y}))
			{
				cout << "No such edge.\n";
				continue;
			}
			int usd = mp[{x,y}];
			if(usd == w)
			{
				cout << "Success.\n";
				continue;
			}
			if(t[w].link(x,y))
				t[usd].cut(x,y),mp[{x,y}] = w,cout << "Success.\n";
		}else{
			int c,x,y;
			cin >> c >> x >> y;
			cout << t[c].ask(x,y) << "\n";
		}
	}
	return 0;
}
```

---

## 作者：k2saki (赞：3)

LCT 挺板子的一道题吧。

我们考虑 $c\le10$ 很容易可以想到暴力把 10 棵 LCT 建立出来，然后在他们上面操作。

先考虑修改权值的操作。本质上就是把 val 值改掉，然后每一棵 LCT 都去 splay 一遍传递信息。

然后考虑修改颜色。判是否存在可以用一个 map 存储记录。边数也可以在 link cut 的时候顺便记录一下。判环就不用说了吧，直接判断两个点的 findroot 是否相等就可以了，然后注意删/连边的时候要顺便把 map 也更新一下。

查询操作需要先判断是否连通，如果连通就把两个点 split 出来，在 LCT 里（pushup 的时候）维护一个 max 值就可以了。

时间复杂度$O(nclogn)$，注意连边的时候只连一棵树的。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m, cc, k;
const int maxn = 1e4 + 10, maxc = 11;
int val[maxn], w[maxn];
struct link_cut_tree
{
    int fa[maxn], sum[maxn], tag[maxn], sta[maxn], ch[maxn][2], cnt[maxn];
    int get(int x)
    {
        return ch[fa[x]][0] == x || ch[fa[x]][1] == x;
    }
    void pushup(int x)
    {
        sum[x] = max(val[x], max(sum[ch[x][0]], sum[ch[x][1]]));
    }
    void flip(int x)
    {
        swap(ch[x][0], ch[x][1]);
        tag[x] ^= 1;
    }
    void pushdown(int x)
    {
        if (!tag[x])
            return;
        if (ch[x][0])
            flip(ch[x][0]);
        if (ch[x][1])
            flip(ch[x][1]);
        tag[x] = 0;
        return;
    }
    void rotate(int x)
    {
        int y = fa[x], z = fa[y];
        int k1 = (ch[y][1] == x);
        int v = ch[x][!k1];
        if (get(y))
        {
            ch[z][ch[z][1] == y] = x;
        }
        ch[x][!k1] = y;
        ch[y][k1] = v;
        if (v)
        {
            fa[v] = y;
        }
        fa[y] = x;
        fa[x] = z;
        pushup(y);
        pushup(x);
    }
    void splay(int x)
    {
        int top = 0;
        int y = x, z;
        sta[++top] = y;
        while (get(y))
            sta[++top] = y = fa[y];
        while (top)
            pushdown(sta[top--]);
        while (get(x))
        {
            y = fa[x], z = fa[y];
            if (get(y))
            {
                rotate((ch[y][0] == x) ^ (ch[z][0] == y) ? x : y);
            }
            rotate(x);
        }
        pushup(x);
        return;
    }
    void access(int x)
    {
        for (int y = 0; x; x = fa[y = x])
        {
            splay(x);
            ch[x][1] = y;
            pushup(x);
        }
    }
    int findroot(int x)
    {
        access(x);
        splay(x);
        while (ch[x][0])
        {
            pushdown(x);
            x = ch[x][0];
        }
        return x;
    }
    void makeroot(int x)
    {
        access(x);
        splay(x);
        flip(x);
    }
    void split(int x, int y)
    {
        makeroot(x);
        access(y);
        splay(y);
    }
    void link(int x, int y)
    {

        makeroot(x);
        ++cnt[x], ++cnt[y];
        fa[x] = y;
    }
    void cut(int x, int y)
    {
        split(x, y);
        --cnt[x], --cnt[y];
        fa[x] = ch[y][0] = 0;
        pushup(y);
    }
} Tree[11];
struct node
{
    int u, v;
    bool operator<(const node &x) const
    {
        if (u != x.u)
            return u < x.u;
        else
            return v < x.v;
    }
};
map<node, int> mp;
int main()
{
    scanf("%d%d%d%d", &n, &m, &cc, &k);
    for (int i = 1; i <= n; ++i)
    {
        scanf("%d", &val[i]);
    }
    for (int i = 1; i <= m; ++i)
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        ++c;
        Tree[c].link(a, b);
        node X = (node){a, b}, Y = (node){b, a};
        mp[X] = mp[Y] = c;
    }
    for (int i = 1; i <= k; ++i)
    {
        int opt, x, y, z;
        scanf("%d%d%d", &opt, &x, &y);
        if (opt == 0)
        {
            val[x] = y;
            for (int j = 1; j <= cc; ++j)
            {
                Tree[j].splay(x);
            }
        }
        if (opt == 1)
        {
            scanf("%d", &z);
            ++z;
            node X = (node){x, y}, Y = (node){y, x};
            if (mp.count(X) == 0)
            {
                puts("No such edge.");
                continue;
            }
            int Col = mp[X];
            if (Col == z)
            {
                puts("Success.");
                continue;
            }
            if (Tree[z].cnt[x] >= 2 || Tree[z].cnt[y] >= 2)
            {
                puts("Error 1.");
                continue;
            }
            if (Tree[z].findroot(x) == Tree[z].findroot(y))
            {
                puts("Error 2.");
                continue;
            }
            puts("Success.");
            Tree[Col].cut(x, y);
            Tree[z].link(x, y);
            mp[X] = mp[Y] = z;
        }
        if (opt == 2)
        {
            scanf("%d", &z);
            ++x;
            if (Tree[x].findroot(y) != Tree[x].findroot(z))
            {
                puts("-1");
                continue;
            }
            Tree[x].split(y, z);
            printf("%d\n", Tree[x].sum[z]);
        }
    }
}
```


---

## 作者：GoldenPotato137 (赞：2)

[戳我获得更好的阅读体验qwq](https://www.goldenpotato.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/luogu-p2173-zjoi2012%E7%BD%91%E7%BB%9C/)

---
# Solution
首先，我们可以发现颜色总数特别的少，再考虑到有改变边的颜色的操作，可以考虑用LCT来解决。

.

我们建$c$颗LCT，每颗LCT存每个颜色对应的边，splay记录每颗splay的MAX_w。

对于修改权值，考虑直接暴力修改每个颜色的LCT里对应的点的权值

对于修改颜色，我们可以暴力在每一颗LCT里面枚举来找一下有没有这条边，有的话就断掉，然后在对应的LCT里面连上。

对于查询，我们只需要把对应的LCT中对应的链split出来，然后直接输出MAX即可。

对于每个点同色连边不超过2，我们可以直接记录每个点每种颜色连了多少条边，在link和cut中维护一下即可。

.

时间复杂度$O(c\cdot n \cdot logm)$

就酱，这题我们就切掉啦٩(๑>◡<๑)۶ 

---
# Code
```cpp
//Luogu P2173 [ZJOI2012]网络
//Mar,11th,2019
//LCT暴力题
#include<iostream>
#include<cstdio>
using namespace std;
long long read()
{
	long long x=0,f=1;char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-'0';c=getchar();}
	return x*f;
}
const int N=10000+100;
const int M=10+2;
int cnt[N][M];//记录每个点连出去的边的颜色数
struct LCT
{
	int son[N][2],fa[N],lazy[N],MAX[N],w[N];
	inline void update(int x)
	{
		MAX[x]=max(MAX[son[x][0]],MAX[son[x][1]]);
		MAX[x]=max(MAX[x],w[x]);
	}
	inline void mirror(int x)
	{
		lazy[x]=!lazy[x];
		swap(son[x][0],son[x][1]);
	}
	inline void pushdown(int x)
	{
		if(lazy[x]==true)
		{
			mirror(son[x][0]);
			mirror(son[x][1]);
			lazy[x]=false;
		}
	}
	inline bool isRoot(int x)
	{
		return (x!=son[fa[x]][0] and x!=son[fa[x]][1]);
	}
	inline void rotate(int x,int type)
	{
		int y=fa[x],z=fa[y];
		fa[x]=z;
		if(isRoot(y)==false)
			son[z][y==son[z][1]]=x;
		fa[son[x][type]]=y,son[y][!type]=son[x][type];
		fa[y]=x,son[x][type]=y;
		update(y),update(x);
	}
	int mstack[N],top;
	void splay(int x)
	{
		mstack[top=1]=x;
		for(int i=x;isRoot(i)==false;i=fa[i])
			mstack[++top]=fa[i];
		for(int i=top;i>=1;i--)
			pushdown(mstack[i]);
		while(isRoot(x)==false)
		{
			if(isRoot(fa[x])==false and x==son[fa[x]][fa[x]==son[fa[fa[x]]][1]])
				rotate(fa[x],x==son[fa[x]][0]);
			rotate(x,x==son[fa[x]][0]);
		}
	}
	void Access(int x)
	{
		for(int t=0;x!=0;t=x,x=fa[x])
			splay(x),son[x][1]=t,fa[t]=x,update(x);
	}
	int GetRoot(int x)
	{
		Access(x),splay(x);
		while(son[x][0]!=0) x=son[x][0];
		return x;
	}
	void MakeRoot(int x)
	{
		Access(x),splay(x);
		mirror(x);
	}
	int Link(int x,int y,int c)
	{
		if(cnt[x][c]==2 or cnt[y][c]==2) return 2;
		if(GetRoot(x)==GetRoot(y)) return 1;
		cnt[x][c]++,cnt[y][c]++;
		MakeRoot(x);
		fa[x]=y;
		return 0;
	}
	void split(int x,int y)//y做原根，x作为LCT根
	{
		MakeRoot(y);
		Access(x);
		splay(x);
	}
	int Cut(int x,int y,int w)
	{
		split(x,y);
		if(y!=son[x][0] or fa[y]!=x or son[y][1]!=0) return 1;
		son[x][0]=fa[y]=0;
		update(x);
		cnt[x][w]--,cnt[y][w]--;
		return 0;
	}
	void Change(int x,int num)
	{
		split(x,x);
		w[x]=MAX[x]=num;
	}
	int Query(int x,int y)
	{
		split(x,y);
		if(GetRoot(x)!=y) return -1;
		return MAX[x];
	}
}lct[M]; 
int n,m,c,K;
void Change1(int x,int num)
{
	for(int i=0;i<c;i++)
		lct[i].Change(x,num);
}
int Change2(int x,int y,int w)
{
	int statu=3;
	for(int i=0;i<c;i++)
		if(lct[i].Cut(x,y,i)==0)
		{
			statu=lct[w].Link(x,y,w);
			if(statu!=0)
				lct[i].Link(x,y,i);
			break;
		}
	return statu;
}
int Query(int x,int y,int w)
{
	return lct[w].Query(x,y);
}
int main()
{
	//freopen("2173.in","r",stdin);
	//freopen("2173.out","w",stdout);
	
	n=read(),m=read(),c=read(),K=read();
	for(int i=1;i<=n;i++)
		Change1(i,read());
	for(int i=1;i<=m;i++)
	{
		int x=read(),y=read(),w=read();
		lct[w].Link(x,y,w);
	}
	
	for(int i=1;i<=K;i++)
	{
		int op=read();
		if(op==0)
		{
			int x=read(),num=read();
			Change1(x,num);
		}
		else if(op==1)
		{
			int x=read(),y=read(),w=read(),t=Change2(x,y,w);
			if(t==0)
				printf("Success.\n");
			else if(t==1)
				printf("Error 2.\n");
			else if(t==2)
				printf("Error 1.\n");
			else
				printf("No such edge.\n");
		}
		else
		{
			int w=read(),x=read(),y=read();
			printf("%d\n",Query(x,y,w));
		}
	}
	return 0;
}

```

---

## 作者：CommandSR (赞：0)

## 题意

[link](https://www.luogu.com.cn/problem/P2173)

## 题解

注意到 $c \leq 10$，考虑对每一种颜色开一个支持连边，断边，求点权最大值的 lct。

除此之外，我们还需要维护：

1. 一个 map，维护每一条边对应的颜色。
2. 每个颜色下每个点的度数，用于判断操作二的度数限制。

对于操作一，先修改 map，再在相应的 lct 上连边即可。

对于操作二，先在 map 中判有没有这条边，对于条件一判断度数是否大于等于 $2$，对于条件二判断 $u$ 和 $v$ 之前有没有连边即可，最后在旧的 lct 上断边，在新的 lct 上连边。

对于操作三，先检查 $u$ 和 $v$ 之前是否连通，若不连通输出 $-1$，否则输出 lct 维护的点权最大值。


## Code

```cpp
#include <bits/stdc++.h>
#define ll long long
#define pii pair<int,int>
#define mkpr make_pair
#define F(i, a, b) for (int i = (a); i <= (b); ++i)
#define D(i, a, b) for (int i = (a); i >= (b); --i)
using namespace std;
inline ll rd() {
	ll x = 0; bool f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') { if (ch == '-') f = 0; ch = getchar(); }
	while (ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	return (f ? x : (-x));
}
const int N = 2e5 + 5;
int n, m, c, q, val[N];
map<pii, int> mp;
struct LCT {
#define lc(x) tr[x].ch[0]
#define rc(x) tr[x].ch[1]
#define fa(x) tr[x].fa
	int deg[N], mx[N];
	struct Node { int ch[2], fa, lzy; } tr[N];
	bool notroot(int rt) { return lc(fa(rt)) == rt || rc(fa(rt)) == rt; }
	bool rel(int rt) { return rc(fa(rt)) == rt; }
	void connect(int rt, int fa, int dir) { tr[fa].ch[dir] = rt, fa(rt) = fa; }
	void Pushdown(int rt) {
		if (tr[rt].lzy) {
			swap(lc(rt), rc(rt));
			tr[lc(rt)].lzy ^= 1, tr[rc(rt)].lzy ^= 1, tr[rt].lzy ^= 1;
		}
	}
	void Pushup(int rt) {
		mx[rt] = val[rt];
		if (lc(rt) && mx[lc(rt)] > mx[rt]) mx[rt] = mx[lc(rt)];
		if (rc(rt) && mx[rc(rt)] > mx[rt]) mx[rt] = mx[rc(rt)];
	}
	void Pushall(int rt) {
		if (notroot(rt)) Pushall(fa(rt));
		Pushdown(rt);
	}
	void Rotate(int rt) {
		int fa = fa(rt), ffa = fa(fa), kk = rel(rt);
		if (notroot(fa)) tr[ffa].ch[rel(fa)] = rt;
		fa(rt) = ffa;
		connect(tr[rt].ch[kk ^ 1], fa, kk), connect(fa, rt, kk ^ 1);
		Pushup(fa), Pushup(rt);
	}
	void Splay(int rt) {
		Pushall(rt);
		while (notroot(rt)) {
			int fa = fa(rt);
			if (notroot(fa)) (rel(fa) ^ rel(rt) ? Rotate(rt) : Rotate(fa));
			Rotate(rt);
		}
	}
	void Access(int rt) {
		int y = 0;
		while (rt) Splay(rt), rc(rt) = y, Pushup(rt), y = rt, rt = fa(rt);
	}
	void Makeroot(int rt) { Access(rt), Splay(rt), tr[rt].lzy ^= 1; }
	int Findroot(int rt) {
		Access(rt), Splay(rt);
		while (lc(rt)) Pushdown(rt), rt = lc(rt);
		Splay(rt);
		return rt;
	}
	void Link(int x, int y) {
		++deg[x], ++deg[y];
		Makeroot(x);
		if (Findroot(y) != x) fa(x) = y;
	}
	void Cut(int x, int y) {
		--deg[x], --deg[y];
		Makeroot(x);
		if (Findroot(y) == x && !lc(x) && fa(y) == x) fa(y) = rc(x) = 0;
	}
	int Qmax(int x, int y) {
		Makeroot(x), Access(y), Splay(y);
		return mx[y];
	}
	bool Islinked(int x, int y) {
		Makeroot(x);
		return (Findroot(y) == x);
	}
} lct[12];
int main() {
	n = rd(), m = rd(), c = rd(), q = rd();
	F(i, 1, n) val[i] = rd();
	F(i, 1, m) {
		int u = rd(), v = rd(), w = rd() + 1;
		pii e1 = mkpr(u, v), e2 = mkpr(v, u);
		mp[e1] = mp[e2] = w;
		lct[w].Link(u, v);
	}
	F(i, 1, q) {
		int op = rd(), u = rd(), v = rd(), w;
		if (op == 0) {
			val[u] = v;
			F(j, 1, c) lct[j].Splay(u);
		} else if (op == 1) {
			w = rd() + 1;
			pii e1 = mkpr(u, v), e2 = mkpr(v, u);
			if (!mp.count(e1)) { cout << "No such edge.\n"; continue; }
			int pw = mp[e1];
			if (pw == w) { cout << "Success.\n"; continue; } // 这个要先判，即使下面 error 也要输出 success
			if (lct[w].deg[u] >= 2 || lct[w].deg[v] >= 2) { cout << "Error 1.\n"; continue; }
			if (lct[w].Islinked(u, v)) { cout << "Error 2.\n"; continue; }
			cout << "Success.\n";
			lct[pw].Cut(u, v), lct[w].Link(u, v);
			mp[e1] = mp[e2] = w;
		} else {
			++u, w = rd(), swap(u, w);
			if (lct[w].Islinked(u, v)) cout << lct[w].Qmax(u, v) << '\n';
			else cout << "-1\n";
		}
	}
	return 0;
}
```

---

## 作者：hlsnqdmz (赞：0)

一道 LCT 的练习题，对于建多棵 LCT 维护信息有一定的启发性。

首先，看到题目范围，最多有十个颜色，每个颜色都有相当独立的操作，那怎么办？建十棵 LCT 呗！然后改边颜色就相当于把原来边颜色对应的 LCT 上删掉这条边，在现在边颜色对应的 LCT 上加入这条边，另外特别注意加入与原来颜色相同的边的情况。

## 具体操作
### 〇：
把所有 LCT 上的 $x$ 转到树根，然后改点权，不要忘了 `push_up()`。
### 一：
先判断是否有边，这里用了 `map` 但是有颜色为 0 的边，所以全部加一，然后判断是否是同色改同色，然后用数组装每个节点每个颜色连了几条边判断条件一，在连边时判断是否连通（特判防的就是这个，同色改同色会判定成不满足条件二），最后成功再删边，改 `map` 和数组。
### 二：
维护最大值，然后判断两点是否连通（不是有边），是就输出值，否就 `puts("-1")`。

然后你就可以 AC 一道紫题。

给出（丑陋的）代码：
```
//Just Sayori
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <map>
#define ll long long
#define rnt register int
#define gr getchar
#define pr putchar
#define N 100005
#define M 1000000007
using namespace std;

inline ll read()
{
    ll x = 0, f = 1;
    char ch = gr();
    while (ch < '0' || ch > '9')
        ch == '-' ? f = -1, ch = gr() : ch = gr();
    while (ch >= '0' && ch <= '9')
        x = (x << 3) + (x << 1) + (ch ^ 48), ch = gr();
    return x * f;
}

inline void write(ll x)
{
    static int sta[39], top = 0;
    if (x < 0)
        pr('-'), x = -x;
    do
        sta[++top] = x % 10, x /= 10;
    while (x);
    while (top)
        pr(sta[top--] ^ 48);
}
int n, m, q, u, v, k, c, color;
int w[N], num[N][11];

struct bu_shi_ge_men_ni_rang_wo_kai_ji_ke_LCT
{
#define fa(x) s[x].fa
#define lc(x) s[x].ch[0]
#define rc(x) s[x].ch[1]
#define is_root(x) lc(fa(x))==x||rc(fa(x))==x
    struct tree
    {
        int ch[2];
        int fa, tag;
        int max;
    } s[N << 1];
    inline void push_up(int u)
    {
        s[u].max = w[u];
        s[u].max = max(s[u].max, max(s[lc(u)].max, s[rc(u)].max));
    }
    inline void push_down(int u)
    {
        if (!s[u].tag)
            return;
        swap(lc(u), rc(u));
        s[lc(u)].tag ^= 1;
        s[rc(u)].tag ^= 1;
        s[u].tag = 0;
    }
    void push_all(int u)
    {
        if (is_root(u))
            push_all(fa(u));
        push_down(u);
    }
    inline void rotate(int x)
    {
        int y = fa(x), z = fa(y);
        bool k1 = rc(y) == x, k2 = rc(z) == y;
        if (is_root(y))
            s[z].ch[k2] = x;
        fa(x) = z;
        s[y].ch[k1] = s[x].ch[k1 ^ 1];
        fa(s[x].ch[k1 ^ 1]) = y;
        s[x].ch[k1 ^ 1] = y;
        fa(y) = x;
        push_up(y), push_up(x);
    }
    void splay(int x)
    {
        push_all(x);
        while (is_root(x))
        {
            int y = fa(x), z = fa(y);
            if (is_root(y))
                (rc(y) == x)^(rc(z) == y) ? rotate(x) : rotate(y);
            rotate(x);
        }
    }
    void access(int x)
    {
        for (rnt y = 0; x; y = x, x = fa(x))
        {
            splay(x);
            rc(x) = y;
            push_up(x);
        }
    }
    void make_root(int u)
    {
        access(u);
        splay(u);
        s[u].tag ^= 1;
    }
    int find_root(int u)
    {
        access(u);
        splay(u);
        while (lc(u))
            push_down(u), u = lc(u);
        splay(u);
        return u;
    }
    void split(int u, int v)
    {
        make_root(u);
        access(v);
        splay(v);
    }
    bool link(int u, int v)
    {
        make_root(u);
        if (find_root(v) != u)
            fa(u) = v;
        else
            return 1;
        return 0;
    }
    bool cut(int u, int v)
    {
        make_root(u);
        if (find_root(v) == u && fa(v) == u && !lc(v))
            rc(u) = fa(v) = 0;
        else
            return 1;
        return 0;
    }
} lct[12];

void modify(int u, int v)
{
    for (rnt i = 1; i <= color; i++)
        lct[i].access(u), lct[i].splay(u);
    w[u] = v;
    for (rnt i = 1; i <= color; i++)
        lct[i].push_up(u);
}
map<pair<int, int>, int> mp;

int main()
{
    n = read(), m = read(), color = read(), q = read();
    for (rnt i = 1; i <= n; i++)
        w[i] = read();
    for (rnt i = 1; i <= m; i++)
        u = read(), v = read(), k = read() + 1, lct[k].link(u, v), num[u][k]++, num[v][k]++, mp[make_pair(u, v)] = k, mp[make_pair(v, u)] = k;
    for (rnt i = 1; i <= q; i++)
        switch (read())
        {
            case 0:
                u = read(), v = read();
                modify(u, v);
                break;
            case 1:
                u = read(), v = read(), k = read() + 1;
                c = mp[make_pair(u, v)];
                if (!mp[make_pair(u, v)])
                    puts("No such edge.");
                else
                {
                    if (c == k)
                        puts("Success.");
                    else if (num[u][k] >= 2 || num[v][k] >= 2)
                        puts("Error 1.");
                    else if (lct[k].link(u, v))
                        puts("Error 2.");
                    else
                    {
                        lct[mp[make_pair(u, v)]].cut(u, v);
                        num[u][c]--, num[v][c]--, num[u][k]++, num[v][k]++;
                        mp[make_pair(u, v)] = k, mp[make_pair(v, u)] = k;
                        puts("Success.");
                    }
                }
                break;
            case 2:
                k = read() + 1, u = read(), v = read();
                if (lct[k].find_root(u) != lct[k].find_root(v))
                    puts("-1");
                else
                    lct[k].split(u, v), write(lct[k].s[v].max), pr(10);
                break;
        }
    return 0;
}
```
### 感谢您的观看！

---

## 作者：Little_Fox_Fairy (赞：0)

刚刚学完 LCT，也就能做点板子题了。

注意到颜色总数只有最多只有 10 种，所以考虑对每一种颜色开一棵 LCT。

修改点权就是暴力在每一种颜色的 LCT 上修改。

修改颜色，你可以哈希一下一条边的两个端点然后把这条边的颜色存在数组里面。首先判断存不存在。若存在，检查一下修改度数之后满不满足条件一。然后再调用 findroot 函数检查满不满足条件二。

查询路径在对应颜色的 LCT 上查询即可。

时间复杂度 $O(n \log n)$。

代码：

```cpp
//Sa~ka~na~
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#define pii pair<int,int>
#define pb push_back 
#define eb emplace_back
#define rep(i,a,b) for (int i=(a);i<=(b);i++) 
#define Rep(i,a,b) for (int i=(a);i>=(b);i--)
#define grep(i,a,b) for (auto i : a[b]) 
using namespace std;
using namespace __gnu_pbds;
namespace fast_IO {
	#define IOSIZE 100000
		char ibuf[IOSIZE], obuf[IOSIZE], *p1 = ibuf, *p2 = ibuf, *p3 = obuf;
	#define getchar() ((p1==p2)and(p2=(p1=ibuf)+fread(ibuf,1,IOSIZE,stdin),p1==p2)?(EOF):(*p1++))
	#define putchar(x) ((p3==obuf+IOSIZE)&&(fwrite(obuf,p3-obuf,1,stdout),p3=obuf),*p3++=x)
	#define isdigit(ch) (ch>47&&ch<58)
	#define isspace(ch) (ch<33)
		template<typename T> inline T read() { T s = 0; int w = 1; char ch; while (ch = getchar(), !isdigit(ch) and (ch != EOF)) if (ch == '-') w = -1; if (ch == EOF) return false; while (isdigit(ch)) s = s * 10 + ch - 48, ch = getchar(); return s * w; }
		template<typename T> inline bool read(T &s) { s = 0; int w = 1; char ch; while (ch = getchar(), !isdigit(ch) and (ch != EOF)) if (ch == '-') w = -1; if (ch == EOF) return false; while (isdigit(ch)) s = s * 10 + ch - 48, ch = getchar(); return s *= w, true; }
		template<typename T> inline void print(T x) { if (x < 0) putchar('-'), x = -x; if (x > 9) print(x / 10); putchar(x % 10 + 48); }
		inline bool read(char &s) { while (s = getchar(), isspace(s)); return true; }
		inline bool read(char *s) { char ch; while (ch = getchar(), isspace(ch)); if (ch == EOF) return false; while (!isspace(ch)) *s++ = ch, ch = getchar(); *s = '\000'; return true; }
		inline void print(char x) { putchar(x); }
		inline void print(char *x) { while (*x) putchar(*x++); }
		inline void print(const char *x) { for (int i = 0; x[i]; i++) putchar(x[i]); }
		inline bool read(std::string& s) { s = ""; char ch; while (ch = getchar(), isspace(ch)); if (ch == EOF) return false; while (!isspace(ch)) s += ch, ch = getchar(); return true; }
		inline void print(std::string x) { for (int i = 0, n = x.size(); i < n; i++) putchar(x[i]); }
		inline bool read(bool &b) { char ch; while(ch=getchar(), isspace(ch)); b=ch^48; return true; }
		inline void print(bool b) { putchar(b+48); }
		template<typename T, typename... T1> inline int read(T& a, T1&... other) { return read(a) + read(other...); }
		template<typename T, typename... T1> inline void print(T a, T1... other) { print(a), print(other...); }
		struct Fast_IO { ~Fast_IO() { fwrite(obuf, p3 - obuf, 1, stdout); } } io;
		template<typename T> Fast_IO& operator >> (Fast_IO &io, T &b) { return read(b), io; }
		template<typename T> Fast_IO& operator << (Fast_IO &io, T b) { return print(b), io; }
	#define cout io
	#define cin io
	#define endl '\n'
} using namespace fast_IO;
const int N=2e5+10;
const int M=1e4+10;

int n,m,e[N];
string s;
struct LCT {
    struct node {
        int ch[2],fa,val,maxx,tag;
        #define ch(u,op) t[u].ch[op]
        #define fa(u) t[u].fa
        #define val(u) t[u].val
        #define maxx(u) t[u].maxx
        #define tag(u) t[u].tag
    }t[M];
    inline void push_up(int u) {
        maxx(u)=val(u);
        maxx(u)=max({maxx(u),maxx(ch(u,0)),maxx(ch(u,1))});
        return ;
    }
    inline bool isroot(int u) {
        return (!(ch(fa(u),0)==u or ch(fa(u),1)==u));
    }
    inline void rotate(int x) {
        int y=fa(x),z=fa(y);
        int op=(ch(y,1)==x);
        int son=ch(x,op^1);
        if (!isroot(y)) ch(z,ch(z,1)==y)=x;
        ch(y,op)=son,ch(x,op^1)=y;
        fa(y)=x,fa(x)=z,fa(son)=y;
        push_up(y),push_up(x);
        return ;
    }
    inline void Rev(int x) {
        tag(x)^=1;
        swap(ch(x,0),ch(x,1));
        return ;
    }
    inline void push_down(int x) {
        if (!tag(x)) return ;
        Rev(ch(x,0)),Rev(ch(x,1));
        tag(x)=0;
        return ;
    }
    inline void Alldown(int x) {
        if (!isroot(x)) Alldown(fa(x));
        push_down(x);
        return ;
    }
    inline void splay(int x) {
        Alldown(x);
        while (!isroot(x)) {
            int y=fa(x),z=fa(y);
            if (!isroot(y)) rotate(((ch(y,1)==x)^(ch(z,1)==y))?x:y);
            rotate(x);
        }
        return ;
    }
    inline void Access(int x) {
        int lst=0;
        while (x) {
            splay(x);
            ch(x,1)=lst,lst=x;
            push_up(x);
            x=fa(x);
        }
        return ;
    }
    inline void Makeroot(int x) {
        Access(x),splay(x),Rev(x);
        return ;
    }
    inline int findroot(int x) {
        Access(x),splay(x);
        while (ch(x,0)) x=ch(x,0);
        splay(x);
        return x;
    }
    inline bool Link(int x,int y) {
        Makeroot(x);
        if (findroot(y)==x) return false;
        fa(x)=y; 
        return true;
    }
    inline void Cut(int x,int y) {
        Makeroot(x),Access(y),splay(y);
        if (ch(x,1) or ch(y,0)!=x) return ;
        fa(x)=ch(y,0)=0,push_up(y);
        return ;
    }
    inline void modify(int x,int val) {
        Makeroot(x);
        val(x)=maxx(x)=val;
        return push_up(x);
    }
    inline int query(int x,int y) {
        if (findroot(x)!=findroot(y)) return -1;
        Makeroot(x),Access(y),splay(y);
        return maxx(y);
    }
}col[15];
int C,q,vis[M][15];
gp_hash_table<int,int> p;
inline int idx(int u,int v) {
    int a=min(u,v),b=max(u,v);
    return a*n+b;
}
signed main() {
	cin>>n>>m>>C>>q;
    rep(i,1,n) {
        int x;cin>>x;
        rep(j,1,C) col[j].val(i)=col[j].maxx(i)=x;
    }
    rep(i,1,m) {
        int u,v,op;cin>>u>>v>>op;op++;
        p[idx(u,v)]=op;
        vis[u][op]++,vis[v][op]++;
        col[op].Link(u,v);
    }
    while (q--) {
        int op,u,v,val;
        cin>>op;
        if (op==0) {
            cin>>u>>val;
            rep(i,1,C) col[i].modify(u,val);
        }
        else if (op==1) {
            cin>>u>>v>>val;val++;
            if (!p[idx(u,v)]) cout<<"No such edge."<<endl;
            else {
                if (p[idx(u,v)]==val) {
                    cout<<"Success."<<endl;
                    continue;
                }
                if (vis[u][val]==2 or vis[v][val]==2) {
                    cout<<"Error 1."<<endl;
                    continue;
                }
                bool link=col[val].Link(u,v);
                if (!link) {
                    cout<<"Error 2."<<endl;
                    continue;
                }
                vis[u][val]++,vis[v][val]++;
                int lst=p[idx(u,v)];
                vis[u][lst]--,vis[v][lst]--;
                p[idx(u,v)]=val;
                col[lst].Cut(u,v);
                cout<<"Success."<<endl;
            }
        }
        else {
            cin>>val>>u>>v;val++;
            cout<<col[val].query(u,v)<<endl;
        }
    }
	return (0-0);
} 
```

---

## 作者：FANTASTlC (赞：0)

### 简介：

~~（这题有个坑点：边要修改成的颜色可能跟原来的颜色一样。)~~

### 分析：
根据题目描述和条件2可知，由相同颜色的边所组成的集合就是一棵树。这样就可以使用 LCT 来维护操作了。

- ####  为了便于讨论，将以下量换成代码中定义的变量：
1. 由颜色编号为 i 的边组成的树为 lct[i]。
1. 由一条边所连接的两个点分别为 p1,p2。
1. 一条边原来的颜色为 lc。
1. 一条边要修改成的颜色为 nc。
1. 由一点 p 所连接出颜色为 i 的边的数量为 tot[p][i]。

- #### 对于操作0：

虽然使用 LCT 就需要把一个点放在多棵树中，但是 C 的范围并不大，所以就可以使用 LCT 暴力修改该点在所有树中的的权值。

- #### 对于操作1：

使用 LCT 暴力查找 lc（原因同操作0），如果不存在该边就直接输出 "No such edge." 。然后判断 lc 是否等于 nc ：如果 lc 等于 nc ，就直接输出 "Success." 。否则，判断 tot[p1][nc] 和 tot[p2][nc] 是否大于1，如果大于1，就输出 "Error 1." 。最后判断一下 p1 和 p2 在 lct[nc] 的连通情况：如果它们已经连通，说明在 lct[nc] 中连接了这条边后, lct[nc] 中就出现了一条环，所以根据题意输出 "Error 2." 。否则，操作成功，输出 "Success." 。

- #### 对于操作2：

~~LCT模板。~~

### Code
```c
#include<bits/stdc++.h>
#define N (int)(1e4+1)
#define M 5001
#define R register
#define INFI 0x7fffffff
#define INFL 0x7fffffffffffffff
#define F(i,start,end) for(R int (i)=(start);(i)<=(end);i++)
using namespace std;
template<typename T> void read(T &x)
{
	int f=1;
	x=0;
	char c=getchar();
	while(!isdigit(c))
	{
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(isdigit(c))
	{
		x=x*10+c-'0';
		c=getchar();
	}
	x=x*f;
}
void write(int x)
{
	if(x<0)
		x=~x+1,putchar('-');
	if(x>9)
		write(x/10);
	putchar(x%10+'0');
}
struct link_cut_tree
{
	#define ls tree[p].son[0]
	#define rs tree[p].son[1]
	#define fa tree[p].f
	#define anc tree[fa].f 
	stack<int> s;
	struct node
	{
		int f,son[2],mx,val;
		bool tip;
	}tree[N];
	int merge(int p1,int p2)//合并左右子节点信息
	{
		return max(tree[p1].mx,tree[p2].mx);
	}
	void pushup(int p)//更新当前节点的信息
	{
		tree[p].mx=max(merge(ls,rs),tree[p].val);
		return;
	}
	void pushdown(int p)//释放该点的旋转懒标记
	{
		if(tree[p].tip)
		{
			tree[ls].tip^=1;
			tree[rs].tip^=1;
			tree[p].tip^=1;
			swap(ls,rs);
		}
		return;
	}
	void connect(int p,int f,bool k)//连边
	{
		tree[p].f=f;
		tree[f].son[k]=p;
		return;
	}
	bool identify(int p)//识别父子节点关系
	{
		return tree[fa].son[1]==p;
	}
	bool check(int p)//识别该节点是否为其所在splay中的根
	{
		return tree[fa].son[0]!=p&&tree[fa].son[1]!=p;
	}
	void rotate(int p)//旋转
	{
		int f=fa,a=anc;
		bool fs=identify(p),as=identify(f);
		if(!check(f))
			tree[a].son[as]=p;
		tree[p].f=a;
		connect(tree[p].son[fs^1],f,fs);
		connect(f,p,fs^1);
		pushup(f);
		pushup(p);
		return;
	}
	void splay(int p)//旋转该节点所在的整个splay
	{
		int temp=p;
		while(!check(p))
		{
			s.push(p);
			p=fa;
		}
		s.push(p);
		p=temp;
		while(s.size())
		{
			pushdown(s.top());
			s.pop();
		}
		while(!check(p))
			if(check(fa))
				rotate(p);
			else
				if(identify(p)==identify(fa))
					rotate(fa),rotate(p);
				else
					rotate(p),rotate(p);
		return;
	}
	void access(int p)//给该节点拉一条到根的路径
	{
		int f=0;
		while(p)
		{
			splay(p);
			rs=f;
			pushup(p);
			f=p;
			p=fa;
		}
		return;
	}
	void modify(int p)//换根
	{
		access(p);
		splay(p);
		tree[p].tip^=1;
		return;
	}
	int find(int p)//查找该点所在splay
	{
		access(p);
		splay(p);
		while(ls)
			p=ls;
		return p;
	}
	void split(int p1,int p2)
	{
		modify(p1);
		access(p2);
		splay(p2);
		return;
	}
	bool link(int p1,int p2)//连边
	{
		int f1=find(p1),f2=find(p2);
		if(f1==f2)
			return 0;
		modify(p1);
		tree[p1].f=p2;
		return 1;
	}
	void cut(int p1,int p2)//删边
	{
		split(p1,p2);
		tree[p2].son[0]=0;
		tree[p1].f=0;
		return;
	}
	bool judge(int p1,int p2,bool k)//k为0，判断的是p1、p2之间有无路径；k为1，判断的是p1、p2之间有无边
	{
		int f1=find(p1),f2=find(p2);
		if(f1!=f2)
			return 0;
		if(!k)
			return 1;
		split(p1,p2);
		if(tree[p2].son[0]==p1&&!tree[p1].son[1])
			return 1;
		return 0;
	}
	void change(int p,int val)//更新结点权值
	{
		access(p);
		splay(p);
		tree[p].val=val;
		pushup(p);
		return;
	}
	#undef ls
	#undef rs
	#undef fa
	#undef anc
}lct[10];
int n,m,c,k,tot[N][10],opt;
int main()
{
	read(n),read(m),read(c),read(k);
	F(i,1,n)
	{
		int num;
		read(num);
		F(j,0,c-1)//初始化
		{
			lct[j].tree[i].val=num;
			lct[j].tree[i].mx=num;
		}
	}
	F(i,1,m)
	{
		int p1,p2,nc;
		read(p1),read(p2),read(nc);
		lct[nc].link(p1,p2);//连边
		tot[p1][nc]++;
		tot[p2][nc]++;
	}
	F(i,1,k)
	{
		read(opt);
		if(!opt)//同分析0
		{
			int x,y;
			read(x),read(y);
			F(i,0,c-1)
				lct[i].change(x,y);
		}
		if(opt==1)//同分析1
		{
			int p1,p2,nc,lc=-1;
			read(p1),read(p2),read(nc);
			F(i,0,c-1)
				if(lct[i].judge(p1,p2,1))
				{
					lc=i;
					break;
				}
			if(lc==-1)
			{
				puts("No such edge.");
				continue;
			}
			if(nc==lc)
			{
				puts("Success.");
				continue;
			}
			if(tot[p1][nc]>1||tot[p2][nc]>1)
			{
				puts("Error 1.");
				continue;
			}
			if(!lct[nc].link(p1,p2))
			{
				puts("Error 2.");
				continue;
			}
			lct[lc].cut(p1,p2);
			tot[p1][lc]--;
			tot[p2][lc]--;
			tot[p1][nc]++;
			tot[p2][nc]++;
			puts("Success.");
		}
		if(opt==2)//模板，不多做解释
		{
			int lc,p1,p2;
			read(lc),read(p1),read(p2);
			if(!lct[lc].judge(p1,p2,0))
			{
				puts("-1");
				continue;
			}
			lct[lc].split(p1,p2);
			write(lct[lc].tree[p2].mx);
			puts("");
		}
	}
 	return 0;
}
```





---

## 作者：xukuan (赞：0)

操作有三种：
1. 改点的权值
2. 改边的权值
3. 路径最大值

看上去毫无思路，拉到最后面数据范围：$1 \leq C \leq 10$，显然这里是突破口。

考虑在颜色的问题上，我们完全可以采用暴力，把相同颜色的用一颗动态树维护。

那么现在就有三种操作：
1. 改点的权值
2. 删掉一条边然后重建
3. 路径最大值

直接对每一种颜色建动态树即可。

注意：

1. STL的stack常数很大，不要用，会被卡到飞起
2. 修改时直接对所有边暴力修改

时间复杂度：$O(nclog_2 n)$

代码：

```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;

inline ll read(){
    ll x=0,tmp=1;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-') tmp=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        x=(x<<3)+(x<<1)+(ch^48);
        ch=getchar();
    }
    return tmp*x;
}

const ll N=10010,M=15;
ll n,m,c,K,cnt[N][M],st[N];
struct {
    struct Link_Cut_tree{
        ll son[2],val,size,Max,father,lazy;
    }tree[N];
    
    inline bool isroot(ll p){
        return tree[tree[p].father].son[0]!=p&&tree[tree[p].father].son[1]!=p;
    }
    
    inline void pushup(ll p){
        tree[p].size=tree[tree[p].son[0]].size+tree[tree[p].son[1]].size+1;
        tree[p].Max=max(tree[p].val,max(tree[tree[p].son[0]].Max,tree[tree[p].son[1]].Max));
    }
    
    inline void reverse(ll p){
        tree[p].lazy^=1;
        swap(tree[p].son[0],tree[p].son[1]);
    }

    inline void pushdown(ll p){
        if(tree[p].lazy){
            reverse(tree[p].son[0]);
            reverse(tree[p].son[1]);
            tree[p].lazy=0;
        }
    }
    
    inline bool which(ll p){
        return tree[tree[p].father].son[1]==p;
    }
    
    inline void rotate(ll p){
        ll fa=tree[p].father,fafa=tree[fa].father;
        bool w=which(p);
        if(!isroot(fa)) tree[fafa].son[which(fa)]=p;
        tree[fa].son[w]=tree[p].son[w^1];
        tree[tree[p].son[w^1]].father=fa;
        tree[p].son[w^1]=fa;
        tree[fa].father=p;
        tree[p].father=fafa;
        pushup(fa); pushup(p);
    }

    inline void splay(ll p){
        ll top=0;
        st[++top]=p;
        for(ll i=p; !isroot(i); i=tree[i].father) st[++top]=tree[i].father;
        while(top){
            pushdown(st[top]);
            st[top--]=0;
        }
        for(ll i=tree[p].father; !isroot(p); rotate(p),i=tree[p].father){
            if(!isroot(i)){
                if(which(i)==which(p)) rotate(i);
                else rotate(p);
            }
        }
        pushup(p);
    }

    inline void access(ll p){
        for(ll y=0; p; p=tree[y=p].father){
            splay(p);
            tree[p].son[1]=y;
            pushup(p);
        }
    }

    inline ll getroot(ll p){
        access(p);
        splay(p);
        while(tree[p].son[0]){
            pushdown(p);
            p=tree[p].son[0];
        }
        return p;
    }

    inline ll makeroot(ll p){
        access(p);
        splay(p);
        reverse(p);
    }

    inline ll link(ll x,ll y,ll w){
        if(cnt[x][w]==2||cnt[y][w]==2) return 2;
        if(getroot(x)==getroot(y)) return 1;
        cnt[x][w]++; cnt[y][w]++;
        makeroot(x);
        tree[x].father=y;
        return 0;
    }

    inline void split(ll x,ll y){
        makeroot(y);
        access(x);
        splay(x);
    }

    inline ll cut(ll x,ll y,ll w){
        split(x,y);
        if(y!=tree[x].son[0]||tree[y].father!=x||tree[y].son[1]) return 1;
        tree[x].son[0]=tree[y].father=0;
        pushup(x);
        cnt[x][w]--; cnt[y][w]--;
        return 0;
    }

    inline void update(ll x,ll val){
        split(x,x);
        tree[x].val=tree[x].Max=val;
    }

    inline ll query(ll x,ll y){
        split(x,y);
        if(getroot(x)!=y) return -1;
        return tree[x].Max;
    }
}lct[M];

inline void update(ll x,ll val){
    for(ll i=0; i<c; i++) lct[i].update(x,val);
}

inline ll cut_and_link(ll x,ll y,ll w){
    ll cnt=3;
    for(ll i=0; i<c; i++){
        if(lct[i].cut(x,y,i)==0){
            cnt=lct[w].link(x,y,w);
            if(cnt) lct[i].link(x,y,i);
            break;
        }
    }
    return cnt;
}

inline ll query(ll x,ll y,ll w){
    return lct[w].query(x,y);
}

int main(){
    n=read(); m=read(); c=read(); K=read();
    for(ll i=1; i<=n; i++) update(i,read());
    while(m--){
        ll x=read(),y=read(),w=read();
        lct[w].link(x,y,w);
    }
    while(K--){
        ll op=read();
        switch(op){
            case 0:{
                ll x=read(),val=read();
                update(x,val);
                break;
            }
            case 1:{
                ll x=read(),y=read(),w=read();
                ll t=cut_and_link(x,y,w);
                switch(t){
                    case 0:{
                        printf("Success.\n");
                        break;
                    }
                    case 1:{
                        printf("Error 2.\n");
                        break;
                    }
                    case 2:{
                        printf("Error 1.\n");
                        break;
                    }
                    case 3:{
                        printf("No such edge.\n");
                        break;
                    }
                    default:{
                        cout<<"FUCK t "<<t<<endl;
                    }
                }
                break;
            }
            case 2:{
                ll w=read(),x=read(),y=read();
                printf("%lld\n",query(x,y,w));
                break;
            }
            default:{
                cout<<"FUCK op "<<op<<endl;
            }
        }
    }
    return 0;
}
```

---

## 作者：2018LZY (赞：0)

[传送门](https://www.luogu.org/problem/P2173?contestId=36)

这是一道函数很杂的LCT题。（有点类似Qtree6，Qtree7。但略难。）
# 思路：
c那么小，直接建c棵树。

处理方式：

 0.  更改每棵树上该点的值。
 1. 最难点。先找到边的颜色（一颗一颗找），如果找不到，输出“No such edge.”。
 如果边的颜色与更改后的相同，输出“Success.”。用$cnt[x][y]$表示与x相连的颜色为y的边的边数,就可以方便地判“Error 1.”设变化后的颜色为w，若在对应的树上两个点已经联通，则输出“Error 2.”最后，删边建边，输出“Success."就行。
 2.  splay节点加一个mx参数即可。
 
 # 代码：
 

```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
#define g g()
#define lc tr[x].son[0]
#define rc tr[x].son[1]
using namespace std;
const int N=1e4+10,inf=0x7fffffff,size=1<<25;
int d[N];struct node{int f,son[2],mx;bool v;};
int n,m,c,k;char cnt[N][12];
struct Link_Cut_Tree{
	node tr[N];
	void update(int x){tr[x].mx=max(d[x],max(tr[lc].mx,tr[rc].mx));}
	void fz(int x){//翻转 
		tr[x].v=0;swap(lc,rc);
		tr[lc].v^=1;tr[rc].v^=1;
	}
	bool rt(int x){return tr[tr[x].f].son[0]!=x&&tr[tr[x].f].son[1]!=x;}//是否为根 
	void dfs(int x){//递归维护 
		if(!rt(x))dfs(tr[x].f);
		if(tr[x].v)fz(x);
	}
	void rotate(int x,int w){//旋转 
		int f=tr[x].f,ff=tr[f].f,r,R;
		r=tr[x].son[w];R=f;tr[R].son[1-w]=r;if(r)tr[r].f=R;
		r=x;R=ff;if(tr[R].son[0]==f)tr[R].son[0]=r;else if(tr[R].son[1]==f)tr[R].son[1]=r; tr[r].f=R;
		r=f;R=x;tr[R].son[w]=r;tr[r].f=R;update(f);update(x);
	}
	void splay(int x){
		dfs(x);
		while(!rt(x)){
			int f=tr[x].f;
			if(rt(f))rotate(x,tr[f].son[0]==x);
			else{
				int ff=tr[f].f,a=(tr[f].son[0]==x),b=(tr[ff].son[0]==f);
				if(a^b)rotate(x,a),rotate(x,b);
				else rotate(f,a),rotate(x,a);
			}
		}
	}
	void access(int x){for(int y=0;x;x=tr[y=x].f)splay(x),rc=y,update(x);}
	void makeroot(int x){access(x);splay(x);tr[x].v^=1;}
	int find_root(int x){access(x);splay(x);while(lc)x=lc;return x;}
	void split(int x,int y){makeroot(y);access(x);splay(x);}
	bool connect(int x,int y){split(x,y);return lc==y&&(!tr[y].son[1]);}//x,y是否有边连接 
	bool unicom(int x,int y){split(x,y);while(lc)x=lc;return x==y;}//判联通 
	void link(int x,int y){makeroot(x);tr[x].f=y;access(x);}
	void cut(int x,int y){split(x,y);lc=0;tr[y].f=0;update(x);}
	int query(int x,int y){return unicom(x,y)?tr[x].mx:-1;}
}lct[12];
//0
void change(int x,int w){
	d[x]=w;
	for(int i=0;i<c;i++)lct[i].access(x),lct[i].splay(x),lct[i].update(x);
}
//1
void color(int x,int y,int w){
	int z=-1;
	for(int i=0;i<c;i++)if(lct[i].connect(x,y)){z=i;break;}//有了splay，用什么map查边（常数那么大） 
	if(z==w){puts("Success.");return;}//坑点 
	if(z<0){puts("No such edge.");return;}
	if((cnt[x][w]>=2||cnt[y][w]>=2)){puts("Error 1.");return;}//
	if(lct[w].unicom(x,y)){puts("Error 2.");return;}
	lct[z].cut(x,y); cnt[x][z]--;cnt[y][z]--;
	lct[w].link(x,y);cnt[x][w]++;cnt[y][w]++;
	puts("Success.");
}
//2
int ask(int w,int x,int y){return lct[w].query(x,y);}

char buf[size],*p1=buf,*p2=buf;
char g{return p1==p2&&(p2=(p1=buf)+fread(buf,1,size,stdin),p1==p2)?EOF:*p1++;}
void qr(int &x){
	char c=g;bool v=x=0;
	while(!(isdigit(c)||c=='-'))c=g;
	if(c=='-')v=1,c=g;
	while(isdigit(c))x=x*10+c-'0',c=g;
	if(v)x=-x;
}
void write(int x){
	if(x/10)write(x/10);
	putchar(x%10+'0');
}
void pri(int x){
	if(x<0)putchar('-'),x=-x;
	write(x);puts("");
}

int main(){
	qr(n);qr(m);qr(c);qr(k);
	for(int j=0;j<c;j++)lct[j].tr[0].mx=-inf;//初始化 
	for(int i=1;i<=n;i++){
		qr(d[i]);
		for(int j=0;j<c;j++)lct[j].tr[i].mx=d[i];//初始化 
	}
	int op,x,y,w;
	while(m--)qr(x),qr(y),qr(w),lct[w].link(x,y),cnt[x][w]++,cnt[y][w]++;
	while(k--){
		qr(op);
		switch(op){
			case 0:qr(x);qr(y);change(x,y);break;
			case 1:qr(x);qr(y);qr(w);color(x,y,w);break;
			case 2:qr(w);qr(x);qr(y);pri(ask(w,x,y));break;
		}
	}
	return 0;
}
```


---

## 作者：Dispwnl (赞：0)

题目好长。。。

如果你做过[这道题](https://www.luogu.org/problemnew/show/P3313)就会发现思路其实差不多

就是对每种颜色建LCT，先把点加入每个LCT中，边加入对应的LCT中

我们看看每个操作：

0.就是修改点权，枚举颜色修改就行了

1.还是枚举每种颜色的LCT，如果这个LCT中x和y相连

先split(x,y)一下

如果此颜色=修改颜色dis，就不用修改直接输出"Success."

对于判断是否满足条件1，我们用一个数组d记录x连出去颜色i的边有几条，即d[x][i]

这样随时更新d，如果d[x][dis]>1或d[y][dis]>1，就不满足，输出"Error 1."

对于判断是否满足条件2，我们直接判断颜色编号为dis的LCT中x和y是否连通

如果连通，再加一条边肯定成同颜色环，就输出"Error 2."

最后找不到就输出"No such edge."

2.这个就是简单的输出了。。。如果在颜色编号为dis的LCT中不连通记得输出-1

代码：
```
# include<iostream>
# include<cstring>
# include<cstdio>
# include<cstdlib>
using namespace std;
const int MAX=1e4+1;
int n,m,c,k;
int a[MAX];
int d[MAX][11];
struct Link_Cut_Tree{
	int w[MAX],fa[MAX];
	int son[MAX][2];
	bool fl[MAX];
	void pus(int x)
	{
		w[x]=max(max(w[son[x][0]],w[son[x][1]]),a[x]);
	}
	void down(int x)
	{
		if(fl[x]&&x)
		{
			if(son[x][1]) fl[son[x][1]]^=1;
			if(son[x][0]) fl[son[x][0]]^=1;
			swap(son[x][0],son[x][1]);
			fl[x]=0;
		}
	}
	bool is_root(int x)
	{
		return son[fa[x]][1]!=x&&son[fa[x]][0]!=x;
	}
	bool id(int x)
	{
		return son[fa[x]][0]==x?0:1;
	}
	void rot(int x)
	{
		int y=fa[x],z=fa[y],k=id(x);
		if(!is_root(y)) son[z][id(y)]=x;
		son[y][k]=son[x][k^1],fa[son[y][k]]=y;
		son[x][k^1]=y,fa[y]=x;
		fa[x]=z;
		pus(y),pus(x);
	}
	void PUS(int x)
	{
		if(!is_root(x)) PUS(fa[x]);
		down(x);
	}
	void splay(int x)
	{
		PUS(x);
		for(int y;!is_root(x);rot(x))
		  if(!is_root(y=fa[x]))
		  rot(id(x)==id(y)?y:x);
	}
	void access(int x)
	{
		for(int y=0;x;y=x,x=fa[x])
		  splay(x),son[x][1]=y,pus(x);
	}
	int find_root(int x)
	{
		access(x),splay(x);
		while(son[x][0]) x=son[x][0];
		return x;
	}
	void make_root(int x)
	{
		access(x),splay(x);
		fl[x]^=1;
	}
	void split(int x,int y)
	{
		make_root(x),access(y),splay(y);
	}
	void cut(int x,int y)
	{
		split(x,y);
		if(son[y][0]==x)
		son[y][0]=0,fa[x]=0;
	}
	void link(int x,int y)
	{
		make_root(x);
		fa[x]=y;
	}
	void change(int x,int dis)
	{
		access(x),splay(x);
		a[x]=dis;
		pus(x);
	}
}Tree[11];
void CHANGE(int x,int y,int dis)
{
	for(int i=1;i<=c;i++)
	  if(Tree[i].find_root(x)==Tree[i].find_root(y))
	  {
	  	Tree[i].split(x,y);
	  	if(Tree[i].son[y][0]!=x||Tree[i].son[x][1]) continue;
	  	if(i==dis)
	  	{
	  		printf("Success.\n");
	  		return;
		}
		if(d[x][dis]>1||d[y][dis]>1)
		{
			printf("Error 1.\n");
			return;
		}
		if(Tree[dis].find_root(x)==Tree[dis].find_root(y))
		{
			printf("Error 2.\n");
			return;
		}
		Tree[i].cut(x,y),Tree[dis].link(x,y);
		d[x][i]--,d[y][i]--;
		d[x][dis]++,d[y][dis]++;
		printf("Success.\n");
		return;
	  }
	printf("No such edge.\n");
}
int read()
{
	int x=0,f=1;
	char ch=getchar();
	for(;!isdigit(ch);f=(ch=='-')?-1:1,ch=getchar());
	for(;isdigit(ch);x=x*10+ch-48,ch=getchar());
	return x*f;
}
int main()
{
	n=read(),m=read(),c=read(),k=read();
	for(int i=1;i<=n;i++)
	  {
	  	a[i]=read();
	  	for(int j=1;j<=c;j++)
	  	  Tree[j].w[i]=a[i];
	  }
	for(int i=1;i<=m;i++)
	  {
	  	int x=read(),y=read(),dis=read()+1;
	  	d[x][dis]++,d[y][dis]++;
	  	Tree[dis].link(x,y);
	  }
	for(int i=1;i<=k;i++)
	  {
	  	int op=read(),x,y,dis;
	  	if(!op)
	  	{
	  		x=read(),y=read();
			for(int j=1;j<=c;j++)
	  		  Tree[j].change(x,y);
		}
		else if(op==1)
		{
			x=read(),y=read(),dis=read()+1;
			CHANGE(x,y,dis);
		}
		else if(op==2)
		{
			dis=read()+1,x=read(),y=read();
			if(Tree[dis].find_root(x)!=Tree[dis].find_root(y))
			printf("-1\n");
			else
			{
				Tree[dis].split(x,y);
				printf("%d\n",Tree[dis].w[y]);
			}
		}
	  }
	return 0;
}
```

---

## 作者：dspr (赞：0)

思路
===
显然，这是一道lct裸题。因为颜色不多，所以对于每一种颜色的边我们都建一个lct即可。(我这里是用 （颜色×n+点的标号） 表示每一种颜色lct)

我的方法跟下面大佬们都差不多，但是用了一些小技巧,~~实现起来简单很多~~
### 操作0 
因为我们对于每一种颜色的边都建了一个lct所以，我们对于每一种颜色的边都update一次。(~~虽然很暴力，但跑得过~~)
### 操作1
1.其实对于判断边不存在的情况，我们可以用临接矩阵来存，开一个bool数组10000*10000 128M还是开得下的。这样节约了很多时间(~~其实是我懒得想其它方法判断~~)。

2.错误1,开一个degree记录每个点每一种颜色的边的度即可。

3.错误2,判断一下两点在这个颜色的lct是否联通，若联通即为不合法的情况，至于怎么判断，lct模板。

4.对于可以修改颜色的情况，我们就把原来颜色的边cut掉，再link新的颜色就可以了。看下面大佬都是用临接表存边找颜色，我这里教你们一招(~~懒人专用的奇淫技巧~~)把bool数组开成char数组这样既可以判断边的存在性，又可以判断边的颜色，比那些临接表方便了许多，还节约了时间。(~~其实对于一些空间不够的题，可以用short或者char之类的数组来存东西，也许这样就够了~~)
### 操作2
没有什么特殊的地方和其它lct题的查询没有什么区别。
# 总结
这题lct的部分跟其它题目没有区别，直接复制粘贴都可以，只是要想到能开多个lct并且这些lct之间互不影响，实现起来还是非常简单的
#  代码
```
#include<bits/stdc++.h>
using namespace std;
const int N=2e5;
int fa[N],ch[N][2],lazy[N],w[N],ans[N],degree[N],n,m,c;
char pd[10001][10001];
int isroot(int x){return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x;}
int get(int x){return ch[fa[x]][1]==x;}
void pushup(int x){ans[x]=max(w[x],max(ans[ch[x][0]],ans[ch[x][1]]));}
void pushdown(int x){
    if(!lazy[x])return;
    swap(ch[x][0],ch[x][1]);
    lazy[ch[x][0]]^=1;
    lazy[ch[x][1]]^=1;
    lazy[x]^=1;
}
void rotate(int x){
    int y=fa[x],z=fa[y],k=get(x);
    fa[x]=z;if(!isroot(y))ch[z][ch[z][1]==y]=x;
    ch[y][k]=ch[x][k^1];fa[ch[y][k]]=y;
    ch[x][k^1]=y;fa[y]=x;
    pushup(y);pushup(x);
}
void push(int x){if(!isroot(x))push(fa[x]);pushdown(x);}
void splay(int x){
    push(x);
    while(!isroot(x)){
        int y=fa[x];
        if(!isroot(y))
            if(get(x)==get(y))rotate(y);
            else rotate(x);
        rotate(x);
    }
}
void access(int x){for(int y=0;x;y=x,x=fa[x])splay(x),ch[x][1]=y,pushup(x);}
void makeroot(int x){access(x);splay(x);lazy[x]^=1;}
void split(int x,int y){makeroot(x);access(y);splay(y);}
void link(int x,int y){makeroot(x);fa[x]=y;}
void cut(int x,int y){split(x,y);fa[x]=ch[y][0]=0;pushup(y);}
int getroot(int x){
    access(x);splay(x);
    while(ch[x][0])x=ch[x][0];
    return x;
}
int query(int x,int y){
    if(getroot(x)!=getroot(y))return -1;
    split(x,y);
    return ans[y];
}
void update(int x,int y){
    makeroot(x);
    w[x]=y;
    pushup(x);
}
void work(int x,int y,int z){
    if(pd[x][y]==0){printf("No such edge.\n");return;}
    int u=x+z*n,v=y+z*n,lu=x+pd[x][y]*n,lv=y+pd[x][y]*n;
    if(pd[x][y]==z){printf("Success.\n");return;}
    if(degree[u]==2||degree[v]==2){printf("Error 1.\n");return;}
    if(getroot(u)==getroot(v)){printf("Error 2.\n");return;}
    degree[lu]--;degree[lv]--;
    degree[u]++;degree[v]++;
    cut(lu,lv);
    link(u,v);
    printf("Success.\n");
    pd[x][y]=z;
    pd[y][x]=z;
}
int main(){
    int k;
    cin>>n>>m>>c>>k;
    for(int i=1;i<=n;++i){
        scanf("%d",&w[i]);ans[i]=w[i];
        for(int j=1;j<=c;++j)
            ans[i+j*n]=w[i+j*n]=w[i];
    }
    for(int i=1;i<=m;++i){
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        w++;
        int x=u+w*n,y=v+w*n;
        link(x,y);
        degree[x]++;
        degree[y]++;
        pd[u][v]=w;
        pd[v][u]=w;
    }
    while(k--){
        int op;
        scanf("%d",&op);
        if(op==0){
            int x,y;
            scanf("%d%d",&x,&y);
            for(int i=1;i<=c;++i)
                update(x+i*n,y);
        }
        if(op==1){
            int x,y,z;
            scanf("%d%d%d",&x,&y,&z);z++;
            work(x,y,z);
        }
        if(op==2){
            int x,y,z;
            scanf("%d%d%d",&z,&x,&y);z++;
            printf("%d\n",query(x+z*n,y+z*n));
        }
    }
    return 0;
}

```

---

## 作者：xyz32768 (赞：0)

如果对$LCT$($Link-Cut$ $Tree$)不了解，可以参考此链接：<http://www.cnblogs.com/BLADEVIL/p/3510997.html>。

对于每一种颜色，维护一个$LCT$（因为没有同色的环，且$C<=10$）。每种颜色对应的$LCT$中包含所有的点，但只包含对应颜色的边。

对于操作$0$，就是修改点权，也就是$Splay$上的操作，就不多说了（要注意一点，每一种颜色对应的$LCT$上的节点$x$都要修改）。

对于操作$2$，就是找出对应颜色的$LCT$，提取路径并询问路径最大值，这也不多说了。

而重点就是操作$1$。

对于判断一条边是否存在，可以使用$map$来判定，当然暴力枚举也可以（因为由限制条件$1$可得，与一个点相连的边数不超过$2*C$）。

在这里我不知道数据中会不会出现「一条边修改成这条边当前的颜色」的情况，所以我判定了一下，如果出现这种情况就直接判定为同时满足限制条件$1$和$2$并$continue$。

对于判断是否满足限制条件$1$，可以使用统计的方法，即统计与每个点相连的每种颜色的边有几条，如果节点$u$和$v$中至少有一个点相连的颜色为$w$的边数等于$2$，那么限制条件$1$不满足。

对于限制条件$2$，直接判断在颜色$w$对应的$LCT$中，是否$FindRoot(u)==FindRoot(v)$，如果是则限制条件$2$不满足。

如果同时满足限制条件$1$和$2$，则维护一下统计数组，然后在这条边原来的颜色对应的$LCT$中，执行$Cut(u,v)$，再在颜色$w$对应的$LCT$中，执行$Link(u,v)$。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 1e4 + 5, M = 1e5 + 5;
int n, m, fa[M], lc[M], rc[M], rev[M], len, que[M], c, Q,
val[M], V[M], cnt[N][13], ecnt = 1, nxt[M << 1], adj[M], go[M << 1],
col[M << 1];
void add_edge(int u, int v, int w) {
    nxt[++ecnt] = adj[u]; adj[u] = ecnt;
    go[ecnt] = v; col[ecnt] = w;
}
int tran(int x, int y) {return (x - 1) * c + y;}
int which(int x) {return rc[fa[x]] == x;}
bool is_root(int x) {
    return !fa[x] || (lc[fa[x]] != x && rc[fa[x]] != x);
}
void down(int x) {
    if (rev[x]) {
        swap(lc[x], rc[x]);
        if (lc[x]) rev[lc[x]] ^= 1;
        if (rc[x]) rev[rc[x]] ^= 1;
        rev[x] = 0;
    }
}
void upt(int x) {
    val[x] = V[x];
    if (lc[x]) val[x] = max(val[x], val[lc[x]]);
    if (rc[x]) val[x] = max(val[x], val[rc[x]]);
}
void rotate(int x) {
    int y = fa[x], z = fa[y], b = lc[y] == x ? rc[x] : lc[x];
    if (z && !is_root(y)) (lc[z] == y ? lc[z] : rc[z]) = x;
    fa[x] = z; fa[y] = x; b ? fa[b] = y : 0;
    if (lc[y] == x) rc[x] = y, lc[y] = b;
    else lc[x] = y, rc[y] = b; upt(y); upt(x);
}
void splay(int x) {
    int i, y; que[len = 1] = x;
    for (y = x; !is_root(y); y = fa[y]) que[++len] = fa[y];
    for (i = len; i >= 1; i--) down(que[i]);
    while (!is_root(x)) {
        if (!is_root(fa[x])) {
            if (which(x) == which(fa[x])) rotate(fa[x]);
            else rotate(x);
        }
        rotate(x);
    }
    upt(x);
}
void Access(int x) {
    int y;
    for (y = 0; x; y = x, x = fa[x]) {
        splay(x); rc[x] = y;
        if (y) fa[y] = x; upt(x);
    }
}
int Find_Root(int x) {
    Access(x); splay(x);
    while (down(x), lc[x]) x = lc[x];
    splay(x); return x;
}
void Make_Root(int x) {
    Access(x); splay(x);
    rev[x] ^= 1;
}
void Link(int x, int y) {
    Make_Root(x); fa[x] = y;
}
void Cut(int x, int y) {
    Make_Root(x); Access(y); splay(y);
    lc[y] = 0; fa[x] = 0; upt(y);
}
int Select(int x, int y) {
    Make_Root(x); Access(y); splay(y);
    return val[y];
}
int main() {
    int i, j, op, x, y, z;
    n = read(); m = read(); c = read(); Q = read();
    for (i = 1; i <= n; i++) {
        x = read(); for (j = 1; j <= c; j++) {
            int p = tran(i, j);
            V[p] = val[p] = x;
        }
    }
    while (m--) {
        x = read(); y = read(); z = read() + 1;
        cnt[x][z]++; cnt[y][z]++;
        Link(tran(x, z), tran(y, z));
        add_edge(x, y, z); add_edge(y, x, z);
    }
    while (Q--) {
        op = read(); x = read(); y = read();
        if (op == 0) for (i = 1; i <= c; i++)
            z = tran(x, i), splay(z), V[z] = y, upt(z);
        else if (op == 1) {
            z = read() + 1; bool flag = 0; int co, ex;
            for (int e = adj[x]; e; e = nxt[e])
                if (go[e] == y)
                    {ex = e; co = col[e]; flag = 1; break;}
            if (!flag) {printf("No such edge.\n"); continue;}
            if (co == z) {printf("Success.\n"); continue;}
            if (cnt[x][z] == 2 || cnt[y][z] == 2)
                {printf("Error 1.\n"); continue;}
            if (Find_Root(tran(x, z)) == Find_Root(tran(y, z)))
                {printf("Error 2.\n"); continue;}
            printf("Success.\n"); Cut(tran(x, co), tran(y, co));
            Link(tran(x, z), tran(y, z));
            col[ex] = col[ex ^ 1] = z; cnt[x][co]--; cnt[y][co]--;
            cnt[x][z]++; cnt[y][z]++;
        }
        else {
            x++; z = read();
            if (Find_Root(tran(y, x)) != Find_Root(tran(z, x)))
                {printf("-1\n"); continue;}
            else printf("%d\n", Select(tran(y, x), tran(z, x)));
        }
    }
    return 0;
}
```

---

## 作者：miaowey (赞：0)

一道比较裸的ＬＣＴ，就是模板题吧（但是我写了４.５个小时），

每一个颜色就是一坨ＬＣＴ森林，直接加边维护即可。


**注意：千万别写stack，用int,不然会Ｔ掉**









    




        

        




















        



            



            

    

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<iostream>
#include<algorithm>
#include<map>
using namespace std;
#define LL long long
#define pb push_back
#define Set(a, v) memset(a, v, sizeof(a))
#define For(i, a, b) for(int i = (a); i <= (int)(b); i++)
#define Forr(i, a, b) for(int i = (a); i >= (int)(b); i--)
#define MAXN (10000+5)
#define MAXM (100000+5)
#define MAXC (10+5)
void read(int &x){
    char ch = getchar();
    while(ch < '0' || ch > '9') ch = getchar();
    x = 0;
    while(ch >= '0' && ch <= '9'){
        x = x*10 + ch -'0';
        ch = getchar();
    }
}
int val[MAXN], st[MAXN], top;
struct LCT{
    int ch[MAXN][2], fa[MAXN];
    int maxv[MAXN], rev[MAXN], du[MAXN];
    inline void maintain(int now){
        maxv[now] = val[now];
        if(ch[now][0]) maxv[now] = max(maxv[now], maxv[ch[now][0]]);
        if(ch[now][1]) maxv[now] = max(maxv[now], maxv[ch[now][1]]);
    }
    inline void push_down(int o){
        if(!rev[o]) return;
        int &lc = ch[o][0], &rc = ch[o][1];
        rev[lc] ^= 1; rev[rc] ^= 1; rev[o] ^= 1;
        swap(lc, rc);
    }
    inline bool isroot(int o){
        return (o != ch[fa[o]][0] && o != ch[fa[o]][1]);
    }
    inline void rotate(int o){
        int f = fa[o], g = fa[f];
        int c = (o == ch[f][1]);
        if(!isroot(f)){
            if(ch[g][0] == f) ch[g][0] = o;
            else ch[g][1] = o;
        }
        fa[f] = o; fa[o] = g;
        fa[ch[o][c^1]] = f;
        ch[f][c] = ch[o][c^1]; ch[o][c^1] = f;
        maintain(f);
    }
    inline void splay(int x){
        top = 0;
        st[++top] = x;
        for(int i = x; !isroot(i); i = fa[i]) st[++top] = fa[i];
        while(top){
            push_down(st[top]); top--;
        }
        int o = x;
        while(!isroot(o)){
            int f = fa[o], g = fa[f];
            if(isroot(f)){
                rotate(o);
                break;
            }
            if(!isroot(g)) rotate(f);
            rotate(o);
        }
        maintain(o);
    }
    inline void access(int x){
        int y = 0;
        while(x){
            splay(x);
            ch[x][1] = y;
            maintain(x);
            y = x;
            x = fa[x];
        }
    }
    inline void rever(int x){
        access(x); splay(x); rev[x] ^= 1;
    }
    inline void link(int x, int y){
        du[x]++; du[y]++;
        rever(x); fa[x] = y;
        access(y);
    }
    inline void cut(int x, int y){
        du[x]--; du[y]--;
        rever(x); access(y); splay(y);
        ch[y][0] = fa[x] = 0;
        maintain(y);
    }
    inline int find(int x){
        access(x); splay(x);
        int ret = x;
        while(ch[ret][0]) ret = ch[ret][0];
        return ret;
    }
    inline int query(int x, int y){
        rever(x); access(y); splay(y);
        return maxv[y];
    }
};
struct UV{
    int u, v;
    bool operator <(const UV &rhs)const{
        if(u != rhs.u) return u < rhs.u;
        return v < rhs.v;
    }
};
LCT lcts[MAXC];
map<UV, int> ms;
int main(){
    int n, m, c, k, u, v, w, op, x;
    read(n); read(m); read(c); read(k);
    For(i, 1, n) read(val[i]);
    For(i, 1, m){
        read(u); read(v); read(w);
        w++;
        UV t1 = (UV){u, v}, t2 = (UV){v, u};
        ms[t1] = ms[t2] = w;
        lcts[w].link(u, v);
    }
    For(ca, 1, k){
        read(op);
    //    printf("op = %d\n", op);
        if(op == 0){
            read(x); read(w);
            val[x] = w;
            For(i, 1, c) lcts[i].splay(x);
        }else if(op == 1){
            read(u); read(v); read(w);
            w++;
            UV tmp = (UV){u, v}, t2 = (UV){v, u};
            if(!ms.count(tmp)){
                printf("No such edge.\n");
                continue;
            }
            int bef = ms[tmp];
            if(bef == w){
                printf("Success.\n");
                continue;
            }
            if(lcts[w].du[u] >= 2 || lcts[w].du[v] >= 2){
                printf("Error 1.\n");
                continue;
            }
            if(lcts[w].find(u) == lcts[w].find(v)){
                printf("Error 2.\n");
                continue;
            }
            printf("Success.\n");
            lcts[bef].cut(u, v); lcts[w].link(u, v);
            ms[tmp] = ms[t2] = w;
        }else{
            read(w); read(u); read(v);
            w++;
            if(lcts[w].find(u) != lcts[w].find(v)){
                 printf("-1\n");
                continue;
            }
            printf("%d\n", lcts[w].query(u, v));
        }
    }
    return 0;
}
```

---


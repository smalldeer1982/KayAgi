# [HNOI2001] 棋盘变换

## 题目描述

一个 $n\times n$ 的棋盘，在其中填入 $1$ 和 $-1$。经过一次变换后，方格里的每个数将会变成变换之前与之相邻的四个数的积。例如：

![](https://cdn.luogu.com.cn/upload/image_hosting/2q4jbad8.png)

但有一些状态，变换前和变换后是一样的，例如全部是 $1$ 的状态。这种状态被称为不变状态。

你的任务是要找到所有本质不同的不变状态（旋转或翻转之后的状态被视为是本质上相同的）。

## 说明/提示

$1\le n\le 30$。

题目给出范围内，不变状态总数 $<9\times 10^3$。

## 样例 #1

### 输入

```
4```

### 输出

```
5```

# 题解

## 作者：LJC00118 (赞：24)

#### 前言

今天下午同学 YLWang 突然告诉我有这样一个[帖子](https://www.luogu.com.cn/discuss/show/270466)，于是思考了一下此题不打表的做法，就有了这篇题解。

----
#### 前置知识：高斯消元，burnside 引理

我们将 $ 1 $ 看成 $ (-1)^0 $，$ -1 $ 看成 $ (-1)^1 $，我们求两个数的乘积就可以变成幂次相加的性质，又因为有 $ (-1)^2 = (-1)^0 $，所以我们的幂次相加是在 $ \mod 2 $ 意义下进行的，容易发现这就是异或，我们可以将题目转换为在每个位置上填上 $ 0/1 $，使得每个数等于相邻的四个数的异或和，求本质不同的方案数。

如果不用考虑本质不同的限制，我们可以对于每个位置 $ (i, j) $ 列出式子 $ x_{i, j} \oplus x_{i - 1, j} \oplus x_{i + 1, j} \oplus x_{i, j - 1} \oplus x_{i, j + 1} = 0 $，其中 $ \oplus $ 是异或，我们求出这个方程组的解的个数就行了，方程组解的个数是 $ 2 $ 的方程组自由元个数次幂，可以用高斯消元 $ O(n^6) $求出，由于是用高斯消元求解异或方程组，可以用 bitset 将复杂度优化至 $ O(\frac{n^6}{w}) $。

如果要求本质不同的方案数，我们可以用 burnside 引理来解决，容易发现只有翻转和旋转的置换群大小是常数级别的（小于等于 $ 8 $），我们对于每种置换群把不动点压成一个变量，求一下方案数即可。

复杂度 $ O(\frac{n^6}{w}) $，实际上 $ n=100 $ 也能在 $ 1 $ 秒之内跑出解。

```cpp
#include <bits/stdc++.h>
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define per(i, a, b) for (int i = a; i >= b; i--)
using namespace std;

typedef unsigned long long ull;
typedef pair <int, int> pii;
typedef long long ll;

template <typename _T>
inline void read(_T &f) {
    f = 0; _T fu = 1; char c = getchar();
    while (c < '0' || c > '9') { if (c == '-') { fu = -1; } c = getchar(); }
    while (c >= '0' && c <= '9') { f = (f << 3) + (f << 1) + (c & 15); c = getchar(); }
    f *= fu;
}

template <typename T>
void print(T x) {
    if (x < 0) putchar('-'), x = -x;
    if (x < 10) putchar(x + 48);
    else print(x / 10), putchar(x % 10 + 48);
}

template <typename T>
void print(T x, char t) {
    print(x); putchar(t);
}

const int N = 35;
const int dx[4] = {1, -1, 0, 0};
const int dy[4] = {0, 0, 1, -1};

bitset <N * N> mat[N * N];

int gauss(int n, int m) {
    int ans = 1;
    for (int i = 1; i <= m; i++) {
        int id = 0;
        for (int j = i; j <= n; j++) {
            if (mat[j][i] == 1) {
                id = j;
                break;
            }
        }
        if (!id) {
            ans <<= 1;
            continue;
        }
        if (id != i) swap(mat[i], mat[id]);
        for (int j = i + 1; j <= n; j++) {
            if (mat[j][i]) {
                mat[j] ^= mat[i];
            }
        }
    }
    return ans;
}

int go[N * N], used[N * N], id[N * N];
int n, len, tot, ans;

struct Matrix { int a[N][N]; };

bool operator < (const Matrix a, const Matrix b) {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (a.a[i][j] != b.a[i][j]) {
                return a.a[i][j] < b.a[i][j];
            }
        }
    }
    return 0;
}

set <Matrix> states;
set <Matrix> :: iterator it;
queue <Matrix> q;

Matrix rotate(Matrix a) {
    Matrix ans;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            ans.a[j][n - i + 1] = a.a[i][j];
        }
    }
    return ans;
}

Matrix flip(Matrix a) {
    Matrix ans;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            ans.a[n - i + 1][j] = a.a[i][j];
        }
    }
    return ans;
}

inline int calc(int x, int y) {
    return (x - 1) * n + y;
}

int main() {
    read(n);
    Matrix a;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            a.a[i][j] = calc(i, j);
        }
    }
    states.insert(a); q.push(a);
    while (!q.empty()) {
        Matrix u = q.front(), v; q.pop();
        v = rotate(u);
        if (!states.count(v)) {
            states.insert(v);
            q.push(v);
        }
        v = flip(u);
        if (!states.count(v)) {
            states.insert(v);
            q.push(v);
        }
    }
    for (it = states.begin(); it != states.end(); ++it) {
        Matrix u = *it;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                go[u.a[i][j]] = calc(i, j);
            }
        }
        memset(used, 0, sizeof(used)); tot = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                int now = calc(i, j);
                if (!used[now]) {
                    ++tot;
                    while (!used[now]) {
                        used[now] = 1;
                        id[now] = tot;
                        now = go[now];
                    }
                }
            }
        }
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                int now = calc(i, j);
                mat[now].reset(); mat[now][id[now]] = 1;
                for (int k = 0; k < 4; k++) {
                    int x = i + dx[k], y = j + dy[k];
                    if (x <= 0 || y <= 0 || x > n || y > n) continue;
                    int v = id[calc(x, y)];
                    mat[now][v] = 1 - mat[now][v];
                }
            }
        }
        ans += gauss(n * n, tot);
    }
    ans /= (int)states.size();
    print(ans, '\n');
    return 0;
}
```

upd：可以将此做法优化至 $ O(\frac{n^4}{w}) $，感谢 @142857cs 的提点

我们只把第一行设为未知数，剩下的格子可以通过第一行表示出来，这样就只有 $ n^2 $ 个方程和 $ n $ 个系数了

[code](https://www.luogu.com.cn/paste/3g7hvxfe)

---

## 作者：Night_Aurora (赞：20)

这道题我是来误导新人的(x

这道题不懂怎么做，但是输入只有一个数，还是1-29之间的，所以我们可以乱搞一下

对，就是打表

这道题其实省选出了的话讲道理打表可以做到100分的，虽然还不知道正解是什么，这里就误导新人的发一下打表做法吧

打表最重要的是暴力

就是对于一个N我们要在不大的复杂度内算出来准确的结果，当然太大5个小时也跑不完的话我也帮不了你

对于N\*N的棋盘

我们可以$O(2^N)$枚举第一行某一位是1还是-1，然后往下可以$O(N^2)$递推出其他格子的唯一状态，虽然不保证状态合法但是能保证唯一

对于得到的一个N\*N的棋盘，经过三次旋转，四次镜像，四次上下颠倒后得到12个棋盘

如果都没在集合里就给答案+1，并把这些变换矩阵都加入集合

集合可以用set实现，矩阵我们可以hash压缩一下再放入set

这样的暴力打表复杂度是$O(2^N*(N^2+logK))$

K按照题目描述的话大概就是9000\*12吧,不管怎么说复杂度比$2^{N^2}$好多了

这样打表的话亲测29数据大概1500s

28大概750s，因为复杂度重点是里面那个指数

那样打表打出1-29的大概需要3000s，也才一个小时而已，这期间可以做其他题

然后把打出来的表放入十几行的程序中交上去就行了

虽然不是正解，但是这方法在比赛中也适用

代码没必要贴，直接贴打表的玩意吧

http://paste.ubuntu.com/25539072/


---

## 作者：囧仙 (赞：1)

## 前言

这篇题解算是打表题解。不过由于实际复杂度为 $\mathcal O(\frac{n^2}{w}\cdot 2^n)$ （其中 $w=32$ ），比另外一篇题解的 $\mathcal O(n^2\cdot 2^n)$ 快不少（大概几分钟就能全部打完），所以还是有一定参考价值的（？）

## 题解

观察发现，对于数字 $-1$ ，它的四周应当有奇数个 $-1$ ；对于 $1$ ，它的四周应当有偶数个 $-1$ 。统一一下，就是连带自身，一共有偶数个 $-1$ 。于是我们把 $-1$ 编号为 $1$ ，把 $1$ 编号为 $0$ ，符合条件的棋盘就是这样一个情形：对于每个位置及它四周的四个位置， $1$ 的个数为偶数。

按照往常套路，我们可以发现：**假如确定了第一行，就能确定出每一行**。举个例子， $n=4$ ，第一行是 $\{1,0,1,1\}$ 。那么第二行第一个数字必然是 $1$ ，不然第一行第一个数字的位置不合条件；同理，第二行第二个数字必然是 $0$ ，第三个必然是 $0$ ，第四个必然是 $0$ 。于是我们可以确定出第二行为 $\{1,0,0,0\}$ 。由此，我们可以从第一行推出第二行，由第二行推出第三行……

考虑从第 $i$ 行推出第 $i+1$ 行。对于第 $i+1$ 行的第 $j$ 个数字，它与第 $i$ 行的第 $j-1,j,j+1$ 个数字以及第 $i-1$ 行的第 $j$ 个数字有关。假如我们采用**状压** $\bm {dp}$ 的思想，将每一行压缩为一个状态 $s$ ， $s$ 的二进制下第 $j$ 位表示第 $i$ 行第 $j$ 列的值，那么有：

$$s_i=\big((s_{i-1}\operatorname{lshift} 1)\oplus(s_{i-1}\operatorname{rshift} 1) \oplus s_{i-1}\oplus s_{i-2} \big)\operatorname{and} (2^n-1)$$

其中， $\operatorname{lshift}$ 和 $\operatorname{rshift}$ 分别是二进制下的左移、右移（对应于 C++ 中的 `<<` 和 `>>` ）； $\oplus$ 是二进制下的异或操作。

然后我们计算出 $\bm{s_{n+1}}$ ，若它全部都是 $0$ ，那么就说明对于其他每一个位置都符合条件。

由于本题有个比较麻烦的点，就是**本质不同的方案数**，因此我们需要使用哈希表进行处理。假如 $s_1=x$ 时合法，我们需要计算出 $s_1,s_2\cdots$ 组成的 $01$ 矩阵的第一列 $p$ 、最后一列 $q$ 、最后一行 $y$ 。然后把它们，以及它们翻转后的值插入哈希表当中。由于确定了棋盘的第一行就能确定整个棋盘，因此只要把合法棋盘中可能放在第一行的东西全部插入哈希表中就行了。

由于 $\text{STL}$ 的 $\text{map}$ 等比较慢，所以建议手写一个哈希表。在本地开 $\text{O3}$ 优化，最大的 $n=30$ 跑了一分钟左右，而本题实际数据最大的点 （ $n=29$ ）则只要半分钟不到。因此在赛场上可以轻松愉快地打出表了。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
typedef unsigned int       u32;
typedef unsigned long long u64;
const int INF =2147483647;
const int MAXT=1<<16;
u32 n,ans,R[MAXT];
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
void out(int x){
    dn(31,0,i) putchar(x&(1<<i)?'1':'0'); puts("");
}
namespace Hash{
    const int SIZ=5999997;
    int H[SIZ],N[SIZ],V[SIZ],t;
    void cln(){memset(H,0,sizeof(H)),t=0;}
    void add(int x){int p=x%SIZ; V[++t]=x,N[t]=H[p],H[p]=t;}
    bool fnd(int x){for(int p=H[x%SIZ];p;p=N[p]) if(V[p]==x) return true; return false;}
};
u32 _swp(u32 x){
    u32 t=0; up(0,15,i) if(x&(1<<(15-i))) t|=1<<i; return t;
}
u32 swp(u32 x){
    x<<=32-n; return (R[x>>16])|(R[x&0xffff]<<16);
}
int main(){
    up(0,(1<<16)-1,i) R[i]=_swp(i);
    up(1,30,i){
        n=i,ans=0; Hash::cln();
        up(0,(1<<n)-1,i){
            if(i>swp(i)) continue;
            u32 x=i,y=0,p=x&1,q=x>>n-1,l=x,ll=0;
            up(1,n-1,j){
                x=((x<<1)^(x>>1)^x^ll)&((1<<n)-1),ll=l,l=x;
                p|=(x&1)<<j,q|=(x>>n-1)<<j;
            }
            if(!Hash::fnd(i)&&!(((x<<1)^(x>>1)^x^ll)&((1<<n)-1))){
                ++ans;
                Hash::add(i),Hash::add(x),Hash::add(swp(i)),Hash::add(swp(x));
                Hash::add(p),Hash::add(q),Hash::add(swp(p)),Hash::add(swp(q));
            }
        }
        printf("%u,",ans);
    }
    return 0;
}
```

---


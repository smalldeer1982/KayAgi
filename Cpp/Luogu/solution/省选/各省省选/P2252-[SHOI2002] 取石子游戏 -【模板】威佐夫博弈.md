# [SHOI2002] 取石子游戏 |【模板】威佐夫博弈

## 题目描述

有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法：一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。


## 说明/提示

**数据范围**

$50\%$ 的数据满足 $a, b \le 1000$；

$100\%$ 的数据满足 $a, b \le 10^9$。


## 样例 #1

### 输入

```
8 4
```

### 输出

```
1
```

# 题解

## 作者：2021CHD (赞：40)

提供一种**不产生精度误差**的做法。

**本题解中所有数字以及未知数均为整数。**

本题解中假定输入的 $a\le b$，如果输入的 $a>b$ 则将输入的 $a$ 和 $b$ 交换。

我们对先手必败态进行打表，表如下：

```
0 0
1 2
3 5
4 7
6 10
8 13
9 15
11 18
12 20
14 23
......
```

考虑相邻两个必败态之间较小的数的差距，打表得：

```
12122121221221212212122122121221221212212122122121221212212212122122121221212212212122122121221212212212122......
```

不难发现，相邻两项之间较小的数的差距只能是 $1$ 或 $2$。

证明如下：

#### 基本规则1：$(0,0)$是必败态。

#### 基本规则2：若 $(a,b)$ 是必败态，则 $(a+x,b)$、$(a,b+x)$、$(a+x,b+x)$ 均为必胜态。（$x$  为正整数）

#### 基本规则3：若一个状态 $(a,b)$ ，任何 $(a-x,b)$ 满足 $x\le a$、$(a,b-x)$ 满足 $x\le b$、$(a-x,b-x)$ 满足 $x\le \min(a,b)$均已定义且均为必胜态，则该状态为必败态。（$x$  为正整数）

不难发现若 $(a,b)$ 为必败态，则 $(b,a)$ 为必败态。（通过基本规则的对称性）

#### 引理1：对于每个 $a$，至多存在一个 $b$ 使得 $(a,b)$ 是必败态

证明：若存在 $b<c$ 满足 $(a,b)$ 和 $(a,c)$ 均为必败态，则根据基本规则2得出 $(a,c)$ 为必胜态，矛盾。

#### 引理2：对于每个 $a$，存在一个 $b$ 使得 $(a,b)$ 是必败态

证明：若不存在 $b$ 满足 $(a,b)$ 为必败态，则根据基本规则3得出对于任意的$b$ ，$(a,b)$ 可以表示为 $(c+x,d)$ 或 $(c+x,d+x)$ 的形式，其中 $(c,d)$ 为必败态且 $c<a$。

根据引理1，至多有 $a$ 个满足条件的 $(c,d)$，那么至多只有 $2a$ 个满足条件的 $(a,b)$，和假设中“对于任意的$b$ ，$a,b$ 均满足条件”矛盾。

#### 引理3：对于任意必败态 $(a,b)$ 满足 $a\le b$，对于任意 $0\le x<b-a$，存在唯一必败态 $(m,n)$ 满足 $m<a,n-m=x$，且对于任意必败态 $(m,n)$ 满足 $m<a,m\le n$，$(m,n)$ 满足 $n-m\le b-a$，且对于任意必败态 $(a,b),(m,n)$ 满足 $a\le b,m\le n,a\le m$，满足 $b\le n$。

证明：引理3对于 $(0,0)$ 显然成立。

若引理3对于任意 $a\le k-1(k>0)$ 成立，若不存在必败态 $(k,b)$ 满足 $k\le b$，则引理3对于 $a=k$ 成立。

否则，根据引理2，存在唯一必败态 $(k,b)$ 满足 $k\le b$。

必然存在必败态 $(x,y)$ 满足 $x\le y$，使得不存在必败态 $(q,p)$ 满足 $x\le q\le k,q\le p$。

则 $b-k>y-x$，那么 $b>y$，对于 $(k,b=k+y-x+1)$ 满足基本规则3，其为必败态，则引理3对于 $a=k$ 成立。

**引理3的推论**：对于 $2$ 个必败态 $(a,b),(c,d)$ 满足 $a\le b,c\le d,a<c$ 且不存在必败态 $(p,q)$ 满足 $p\le q,a<p<c$，满足 $d-b=c-a+1$。

### 总证明：

根据引理3的推论，不存在必败态 $(a,b),(c,d)$ 满足 $a\le b,c\le d,d=b+1$，则不存在必败态 $(a,b),(c,d)$ 满足 $a\ge b,c\ge d,a=c+1$。

则对于任意集合 $S=\{x,x+1\}$，满足至多存在一个 $w\in S$ 使得存在必败态 $(w,b)$ 满足 $(w\ge b)$。

对于 $2$ 个必败态 $(a,b),(c,d)$ 使得 $a\le b,c\le d,a<c$ 且不存在必败态 $(p,q)$ 满足 $p\le q,a\le p\le c$，满足对于任意 $a<q<c$，存在必败态 $(q,p)$ 满足 $q\ge p$。

则对于 $2$ 个必败态 $(a,b),(c,d)$ 使得 $a\le b,c\le d,a<c$ 且不存在必败态 $(p,q)$ 满足 $p\le q,a<p<c$，满足 $1\le c-a\le 2$。

证明完毕。

经过这一番骚操作之后，我们证明了上文中的数列只存在 $1$ 和 $2$ 两种数字。

接下来就是找规律并证明的时间了。

不难发现，数列中第一项是 $1$，且数列中的 $1$ 从不连续出现。

不难发现，数列中的 $2$ 的连续段长度构成序列 `12122121221221212212122122...`，也就是说构成它本身！

接下来我们证明这两点。

### 证明数列中的 $1$ 从不连续出现。

根据数列中只存在 $1$ 和 $2$ 以及引理3的推论，得出对于 $2$ 个必败态 $(a,b),(c,d)$ 满足 $a\ge b,c\ge d,a<c$ 且不存在必败态 $(p,q)$ 使得 $p\ge q,a<p<c$，满足 $2\le c-a\le 3$。

经检验，第一个 $1$ 处不存在连续的 $2$ 个 $1$。

如果数列中有连续的 $2$ 个 $1$，那么说明存在必败态 $(a,b)$、$(a+1,c)$、$(a+2,d)$ 满足 $a<b，a+1<c,a+2<d$，就是说不存在必败态 $(a,p)$、$(a+1,q)$、$(a+2,r)$ 满足 $a>p，a+1>q,a+2>r$。

那么就必然存在 $2$ 个必败态 $(m,n),(x,y)$ 满足 $m\ge n,x\ge y,m<x$ 且不存在必败态 $(u,v)$ 使得 $u\ge v,m<u<x$，满足 $x-m\ge 4$，与上文矛盾。

### 证明数列是以如上所述方式自定义的。

**以下文字将会采用不那么严谨的表述方式。**

考虑原数列中的每个 $1$，发现其对应了相邻两个满足前一个数大于等于后一个数的必败态中间间隔 $2$，而原数列中的每个 $2$，发现其对应了相邻两个前一个数大于等于后一个数的必败态中间间隔 $3$。

也就是说每一个 $1$ 可以在原数列上导出一个 $2$，而每一个 $2$ 可以原数列上导出一个 $12$。

再进行一次类似的操作，每一个 $2$ 可以原数列上导出一个 $12$，每一个 $12$ 可以原数列上导出一个 $212$。

也就是说，每一个 $1$ 可以在原数列上导出两次得到 $12$，而每一个 $2$ 可以原数列上导出两次得到 $212$。

考察导出前后的数列：

导出前：`12122121221221212212122122...`。

导出后：`122121221221212212122122...`。

不难发现导出后比导出前少了开头的 `12`。

那么第一个 `1` 对应了缺少的 `12`，其余的每个 `1` 和它前面的 `2` 必定会导出 `21212`，这个 `1` 就对应了中间的 `12`，而每个 `2` 和前面的数字要么导出了 `12212`（前面是 `1`），要么导出了 `212212`（前面是 `2`），也就是说，每一个 `2` 又恰好可以对应一个 `122`。

那么有了这些结论，我们已经可以 $O(n)$ 导出上文中的数列了，但是这还不够，因为这个数列表示了相邻两个数的差值，如何快速判断一个 $a$ 是否存在必败态 $(a,b)$ 满足 $a\le b$ 呢？

不难发现，如果数列以 $0$ 开始编号，必败态 $(a,b)$ 满足 $a\le b$ 存在当且仅当 $a=0$ 或数列的第 $a$ 项为 $2$。

#### 证明上述结论。

每一个 $1$ 可以在原数列上导出一个 $2$，而每一个 $2$ 可以原数列上导出一个 $12$，也就是说相邻两个 $2$ 的间隔对应了原数列去除第一个数的结果，刚好符合我们最初对该数列的定义。

所以如果 $(a,b)$ 满足 $0<a\le b$ 是必败态，当且仅当数列的第 $a$ 项是第 $m$ 个 $2$，并且数列的第 $b$ 项是第 $m+1$ 个 $1$。

特判 $a=0$ 的情况。

现在问题简化成了计算数列的第 $x$ 个数和计算数列的第 $x$ 个数前有几个 $1$。

**如果不能快速求得这个答案的话我们就前功尽弃了。**

很幸运，这个数列是自定义的，也就是说，**它的各个部分会有一定程度的相似性。**

如下图所示。

![如果图挂掉了，在博客回复我。](https://cdn.luogu.com.cn/upload/image_hosting/v75nidkw.png)

因为这个数列是自定义的，可以用如上方式思考。

“组成部分的长度”实际上是斐波那契数列，可以方便地用数学归纳法证明。

比如我们要求数列的第 $20$ 项，查阅第三行发现，它等于紫色区间的第三个位置，于是转化为求解数列的第 $7$ 项，然后问题规模就减小了。

最后一定会转化为求数列第 $0$ 项或第 $1$ 项。

求排名呢？

可以预处理每层的两个段中各有几个 $1$，几个 $2$，那就可以像上面一样递归处理了。

时间复杂度：$O(\log(\max(a,b)))$。

参考代码：

```c++
#include<cstdio>
using namespace std;
long long x,y,t,f[100]={0,1,1},s[100]={0,0,1},g[100]={0,1},i,num1,num2;
main()
{
	scanf("%lld%lld",&x,&y);
	if(x>y)
	{
		t=x;
		x=y;
		y=t;
	}
	for(i=3;i<=50;i++)
	{
		f[i]=f[i-1]+f[i-2];
		s[i]=s[i-1]+s[i-2];
		g[i]=g[i-1]+g[i-2];
	}
	if(y==0)
	printf("0");
	else if(x==0)
	printf("1");
	else
	{
		for(i=1;i<=50;i=i+2)
		if(f[i]+f[i+1]>x)
		break;
		for(;i>=3;i=i-2)
		{
			if(x>=f[i]&&x<f[i]*2)
			{
				num1=num1+s[i];
				x=x-f[i];
			}
			else if(x>=f[i]*2)
			{
				num1=num1+s[i]+s[i-1];
				x=x-f[i]-f[i-1];
			}
		}
		if(x==0)
		{
			printf("1");
			return 0;
		}
		for(i=1;i<=50;i=i+2)
		if(f[i]+f[i+1]>y)
		break;
		for(;i>=3;i=i-2)
		{
			if(y>=f[i]&&y<f[i]*2)
			{
				num2=num2+g[i];
				y=y-f[i];
			}
			else if(y>=f[i]*2)
			{
				num2=num2+g[i]+g[i-1];
				y=y-f[i]-f[i-1];
			}
		}
		if(y==1||num1!=num2-1)
		printf("1");
		else
		printf("0");
	}
}
```

---

## 作者：VinstaG173 (赞：32)

Wythoff 游戏板子。

### Wythoff 游戏

#### 游戏介绍

威佐夫（Wythoff）游戏，又称威佐夫博弈，是博弈论中的著名游戏之一。

游戏内容：两堆石子，一堆 $a$ 个，一堆 $b$ 个，两位游戏者轮流操作，每次操作可以从一堆中取任意颗石子或者从两堆取同样多石子。谁不能再取，就算谁输。

#### 游戏解法

Wythoff 游戏的解法，就是求出先手能否获胜。以下用整数对 $(a,b)$ 表示两堆石子个数是 $a$ 和 $b$ 的情况。由于 $(a,b)$ 与 $(b,a)$ 是一种情况，所以此处只考虑 $a \le b$ 的情况。

显然， $(0,0)$ 时先手必败。接下来的一个必败情况就是 $(1,2)$。再往下，就得到 $(3,5)$。然后是 $(4,7),(6,10),(8,13),(9,15),...$。

我们设第 $i$ 大的必败情况为 $(a_i,b_i)$。

根据规律，发现 $a_i=\operatorname{mex}(a_1,b_1,a_2,b_2,...,a_{i-1},b_{i-1})$（$\operatorname{mex}(S)$ 为集合 $S$ 中最小未出现整数，下同）， $b_i=a_i+i$。

#### 规律证明

现在证明一个必败状态后继状态不可能是另一个必败状态。

因为 $a_i$ 在前面没有出现过，所以 $a_i>a_{i-1}$。所以 $b_i=a_i+i>a_{i-1}+i-1=b_{i-1}$。所以为了使这个情况转化为另一个必败状态，必然要从两堆各取出同样多的石子。所以 $a,b $ 差不变，而其余必败状态 $a_j,b_j$ 差 $j$ 均与 $a_i$ 与  $b_i$ 的差 $i$ 不相等。所以它的所有后继状态均不是必败状态。

下面证明一个必胜状态必有一个后继状态是必败状态。

当 $a>a_k,b=b_k$ 时，只需从 $a$ 堆取出 $a-a_k$ 个即可。 $a=a_k,b>b_k$ 时亦然。

$a>a_k,b>b_k$ 时，当 $a<a_{k+l}$（$l$ 为常数且 $l>0$）。则 $a$ 必然是 $b_1,b_2,b_3,...,b_{k+l-1}$ 之一。设 $a$ 为 $b_m$。则 $b>a_m$ 必然成立。如上可证。

当 $a=a_{k+l}$ 时，若 $b>b_{k+l}$。则如上可证。否则，因为 $b \neq b_{k+l}$，所以 $b<b_{k+l}$。若 $b=b_m$，则满足 $a>a_m,b=b_m$，如上。若 $b=a_m$，因为 $b>a$，所以 $m>k+l$，所以 $0<a_m-a_{k+l}<k+l$，所以将 $b$ 堆取到 $b_{a_m-a_{k+l}}$ 时，a堆将取到 $a_{a_m-a_{k+l}}$ 颗，为一个必败状态。

综上，必胜状态必有一个后继状态是必败状态。

必败状态通项公式：设当前状态为 $(a,b)(a<b)$，则当 $a=\lfloor\frac{\sqrt{5}+1}{2}\rfloor\times(b-a)$ 时该状态为必败状态。

#### 有趣的性质

首先，我们定义 $a_{i+1}-a_i=c_i,b_{i+1}-b_i=d_i$。然后，有 $c_0=a_1=1,d_0=b_1=2$。我们发现， $d_i=c_i+1$。

每当 $d_i=2$ 时， $c_i$数组对应在最后添上一个 $2$；每当 $d_i=3$ 时， $c_i$数组对应在最后添上一个 $1$ 和一个 $2$。递推大概就是这个样子：

```cpp
for(int i=0;;i++)//c,d是vector动态数组
{
	d[i]=c[i]+1;
	if(d[i]==2)c.push_back(2);
	if(d[i]==3)c.push_back(1),c.push_back(2);
}
```

这样就可以求出 $c_i$ 和 $d_i$，然后推出 $a_i,b_i$ 了。

但是这样会 TLE。所以我们需要更优的解法。

#### 真正的题解（雾

其实这个就是一个式子的事（虽然这个式子并不那么好推

当且仅当 $\left\lfloor \dfrac{\sqrt{5}+1}{2}(b-a) \right\rfloor=a$ 时先手必败。

这个要用到一个有趣的东西—— Beatty 定理。

这个 Beatty 定理讲的是这么一个道理：

对于两个无理数 $x,y$，若其满足 $\dfrac{1}{x}+\dfrac{1}{y}=1$，令两个集合 $P=\left\{ p|p=\lfloor nx\rfloor,n \in N^+ \right\},Q=\left\{ q|q=\lfloor my\rfloor,m \in N^+ \right\}$，其中 $N^+$ 为正整数集。

则有 $P \cap Q=\varnothing,P \cup Q=N^+$。

定理证明：定理等价于对于任意 $k \in N^+$，要么 $k \in P$，要么 $k \in Q$，且两者不能同时成立。

考虑反证。

如果存在一个 $k \in N^+$ 使 $k \in P,k \in Q$，由于 $x,y$ 是无理数，故任意 $nx,my$ 均不为整数。所以我们可以设 $k<nx<k+1$, $k<my<k+1$。则 $\dfrac{n}{k+1}<\dfrac{1}{x}<\dfrac{n}{k}$, $\dfrac{m}{k+1}<\dfrac{1}{y}<\dfrac{m}{k}$。两式相加，得 $\dfrac{n+m}{k+1}<\dfrac{1}{x}+\dfrac{1}{y}<\dfrac{n+m}{k}$，又 $\dfrac{1}{x}+\dfrac{1}{y}=1$，即 $k<n+m<k+1$，与 $n,m,k$ 均是正整数矛盾！

如果存在一个 $k \in N^+$ 使 $k \notin P,k \notin Q$，同理我们可以设 $nx<k<k+1<(n+1)x$, $my<k<k+1<(m+1)y$。则 $\dfrac{n}{k}<\dfrac{1}{x}<\dfrac{n+1}{k+1}$, $\dfrac{m}{k}<\dfrac{1}{y}<\dfrac{m+1}{k+1}$。两式相加，得 $\dfrac{n+m}{k}<\dfrac{1}{x}+\dfrac{1}{y}<\dfrac{n+m+2}{k+1}$，即 $n+m<k<k+1<n+m+2$，与 $n,m,k$ 均是正整数矛盾！

故定理得证。

由于有了 Beatty 定理，我们会发现上面的那个结论式子相当于

$$a=\left\lfloor n \cdot \dfrac{\sqrt{5}+1}{2}\right\rfloor,b=\left\lfloor n \cdot \dfrac{3+\sqrt{5}}{2}\right\rfloor$$

显然 $\dfrac{1}{\frac{\sqrt{5}+1}{2}}+\dfrac{1}{\frac{3+\sqrt{5}}{2}}=1$。于是应用 Beatty 定理发现满足以上所述的 mex 的性质。

于是我们就得出了答案。

Code:
```cpp
#include<cmath>
#include<cstdio>
using namespace std;
long long a,b;
int main()
{
    while(scanf(" %lld %lld",&a,&b)!=EOF)
    {
        if(a>b)
        {
            long long t=a;a=b;b=t;
        }
        long long c=b-a;
        int d=((sqrt(5.0)+1.0)/2.0*c);
        if(a==d)printf("0\n");
        else printf("1\n");
    }
    return 0;
}
```

#### 番外（此题解法无关） Wythoff 和 Fibonacci 那些事

往著名的 Fibonacci 数列 $f_i$ 中，代入 Wythoff 的 $a_i,b_i$ 会出现神奇的事情。

有： $a_{f_i}=f_{i+1}-i \bmod 2$， $b_{f_i}=a_{f_i}+f_i=f_{i+2}-i \bmod 2$。（此处 $f_i$ 数列为 $1,2,3,5,8,\dots$ 且 $i>1$）。

本篇题解节选自[我的笔记](https://www.luogu.com.cn/blog/vexalwig-goodwcoffin/game-theory-1)，其中还有和 SG 定理及其一些拓展有关的内容。

---

## 作者：llmmkk (赞：7)

##### 链接：

[P2252 [SHOI2002]取石子游戏|【模板】威佐夫博弈](https://www.luogu.com.cn/problem/P2252)

---

##### 前言：

~~第一眼大水题，第二眼努力思考，第 N 眼我是大水逼。~~

---

##### 题意：

不看题目标题都应该能看出来是取石子类的博弈论。

有两堆石子，可以在任意一堆取走任意正整数的石子，也可以同时在两堆中取走相同任意正整数的石子。判断当前状态。

---

##### 分析：

这就是大名鼎鼎的威佐夫博弈了。

本着不会正解就暴力打表的思想，我们可以打出暴力，这其实是解决本题的关键所在。在暴力中我们可以发现只有以下状态先手必败： $(0,0),(1,2),(3,5),(4,7),(6,10),(8,13)\cdots$于是我们从这些状态入手，定义这样的状态为**奇异局势**。

设第 $k$ 个奇异局势为二元组 $(a_k,b_k)$，且 $0\leq k$。

首先容易发现的是，$b_k=a_k+k$。记为性质 $1$。 

不容易发现的是，$a_k=\operatorname{mex}(a_1,b_1,a_2,b_2,\cdots,a_{k-1},b_{k-1})$，即 $a_k$ 是以前从未出现过的自然数中最小数。记为性质 $2$。

能够发现这两个性质就又离成功更进一步，再来思考从这两个性质出发能得到的其他性质。

---

性质 $3$：任意自然数都包含在一个，且仅有一个的奇异局势中。

分开证明，需要证明两点：

1，所有自然数都被包含。2，除零外所有自然数只出现了一次。

1证起来很简单，由性质 $2$ 即可知任何不被包含的自然数都可以作为一个奇异局势的 $a$。显然不会有没有被包含的自然数。

再证2，,因为有性质 $2$： 

> $a_k$ 是以前从未出现过的自然数中最小数。

显然有 $a_k>a_{k-1}$，有由性质 $1$，有 $b_k=a_k+k$

所以 $b_k=a_k+k>a_{k-1}+k-1=b_{k-1}$，即 $b_k>b_{k-1}$

所以有：

$\begin{cases}a_k>a_{k-1}\\b_k>b_{k-1}\\b_{k-1}>a_{k-1}\\b_k>a_k\end{cases}$

观察后发现，对于 $a_k,b_k,a_{k-1},b_{k-1}$，只有 $a_k$ 有可能等于 $b_{k-1}$，其他数之间都有明确的大小关系，不可能相等，又根据性质 $2$，$a_k\neq b_{k-1}$，所以奇异局势中除了 $(0,0)$ 是不会有其他自然数出现两次的。

---

性质 $4$：奇异局势的所有后继状态都不是奇异局势。

这个也比较好证，因为后继状态只能是把 $a$ 或 $b$ 减小，且上面谈到过有 $a_k>a_{k-1},b_k>b_{k-1}$ ，所以假设要转移到奇异局势，只能同时减小 $a,b$ 。这样后继状态 $a,b$ 差值不会变，但奇异局势的差值是递增的，所以转移后不可能是另一个奇异局势。

---

性质 $5$：所有非奇异局势都能转移到奇异局势：

考虑现在的非奇异局势为 $(a,b)$，且 $a<b$。

设$b=a+k$，那么

当 $a>a_k$ 时，只需 $a,b$ 同时减去 $a-a_k$ 就能转移到第 $k$ 个奇异局势。

当 $a=a_k$ 时，不是非奇异局势，不在考虑范围。

当 $a<a_k$ 时，显然无法转移到 $k$ 以上的奇异局势，考虑转移到 $k$ 以下的奇异局势。如果 $a,b$ 同时减或者只减少 $a$，差值不变或变大，发现是无法转移到小于 $k$ 的奇异局势的。只能减小 $b$ 。由于性质 $3$，结合 $a<a_k$，此时的 $a$ 一定在 $k$ 以下的奇异局势中出现过，设 $a$ 出现在第 $m$ 个奇异局势中，且 $m<k$。

当 $a=a_m$ 时，考虑将 $b$ 转移到 $b_m$，由于

$\begin{cases}b_m=a_m+m\\b=a+k\\a=a_m\\k>m\end{cases}$

所以 $b>b_m$ ，将 $b$ 减小 $k-m$ 即可转移到第 $m$ 个奇异局势。

当 $a=b_m$ 时，考虑将 $b$ 转移到 $a_m$，由于 $b>a=b_m\geq a_m,$

所以 $b>a_m$，显然也是可以转移的。

---

结合性质 $4$ 和 $5$ 和我们得到的暴力例子，我们终于发现，奇异局势中先手必败，非奇异局势中先手必胜。真是艰辛，但对这道题只是打好了基础，题目现在需要我们判断它是否是奇异局势。

由于第 $k$ 个奇异局势中 $b_k=a_k+k$，所以根据给出的 $a,b$ 的差值，找到第 $k$ 个奇异局势的 $a$ 或 $b$ ，比较一下就可以了。如果暴力递推对于 $a,b\leq1,000,000,000$ 的数据还是过不了的。所以需要方法来更快速地判断。

这里我们又用到一个神奇的定理：[beatty(贝蒂)定理](https://baike.so.com/doc/9978812-10326491.html)

>设 $a,b$ 是正无理数且 $\dfrac{1}{a}+\dfrac{1}{b}=1$。记$P=\{\lfloor na\rfloor |n为任意正整数\},Q=\{\lfloor nb\rfloor |n为任意正整数\}$，则 $P$ 与 $Q$ 是 $\mathbb{N^+}$ 的一个划分，即 $P\cap Q=\varnothing$ 且 $P\cup Q=\mathbb{N^+}$ (正整数集)。

在性质 $3$ 中我们发现所有正整数都出现且仅出现了一次，所以奇异局势的 $a,b$ 就把所有正整数分成了两个不相交的部分，这刚好满足 beatty定理，所以设第 $k$ 个奇异局势中的 $a=\lfloor kt\rfloor$，其中 $k$ 是正整数，$t$ 是一个无理数，则 $b=a+k=\lfloor k(t+1)\rfloor$，由 beatty定理即可得到：
$\dfrac{1}{t}+\dfrac{1}{t+1}=1$

解一元二次分式方程得：

$t_1=\dfrac{1+\sqrt5}{2},t_2=\dfrac{1-\sqrt5}{2}$

$t$ 取正，所以 $t=\dfrac{1+\sqrt5}{2}$

所以第 $k$ 个奇异局势中的 $a=\lfloor kt\rfloor=\lfloor k\times\dfrac{1+\sqrt5}{2}\rfloor$。

这样就能快速判断了。

这是博弈论中的经典题目，最好跟着或者自己推一遍过程，代码短也不能只背代码。

---

##### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
double d=(1+sqrt(5))/2;
signed main(){
	int a,b;
	cin>>a>>b;
	if(a>b)swap(a,b);
	int t=b-a;
	if(int((double)t*d)==a)cout<<0;
	else cout<<1;
	return 0;
}
```

---







---

## 作者：gaozitao1 (赞：2)

# P2252 [SHOI2002]取石子游戏|【模板】威佐夫博弈 题解
题目大意：有两堆石子，可以一次从一堆石子中取任意多个，也可以一次从两堆石子中同时取走相同数量的石子，问先手和后手谁能获胜。

~~结果不可能无法确定吧~~

如果当前的两堆石子分别为 $i$ 和 $j$ ，那么记录这种状态为 $\left(i,j\right)$ 。为了方便，保证 $i\le j$ 。

如果当前状态先手必败，称当前状态为**必败状态**。

如果当前状态先手必胜，称当前状态为**必胜状态**。

经过暴力计算小数据之后，可以发现在 $i,j\in\left[1,10\right]$ 之内，必败状态是少于必胜状态的，所以分析必败。

 $i,j\in\left[1,10\right]$ 之内必败状态有 $\left(1,2\right)$ , $\left(3,5\right)$ , $\left(4,7\right)$ , $\left(6,10\right)$ 。
 
设第 $i$ 个必败状态的第一个数为 $a_i$ ，第二个数是 $b_i+i$ 。
 
设 $\left(i,j\right)$ 为必败状态，$k$ 是正整数，那么有以下几个结论：

-  $\left(i+k,j\right)$ 和 $\left(i,j+k\right)$ 是必胜状态，只需要取走多的那 $k$ 个，那么就会使对手面对必败状态。**所以必败状态中每个整数只出现一次。**

- $\left(i+k,j+k\right)$ 是必胜状态，只需要从两堆石子中同时取出 $k$ 个，那么就可以使对手面对必败状态。

- 一个状态是必胜状态，那么一定有一种取石子的方法使得下一个状态时必败状态。一个状态是必败状态，那么一定有一种取石子的方法使得下一个状态时必胜状态。**所以 $a_i$ 是前 $i-1$ 个必败状态中没有出现过的最小的正整数。** 如果不是，那么 根据第一个结论，每个整数都出现一次，那么后面一定存在一个 $j$ ，使 $a_j<a_i$ ，这样后面的数比前面的数小，不符合要求。

- 如果一个状态的第一个数是 $a_i$ ，第二个数小于 $a_i+i$ ，那么第二个数减去第一个数一定小于 $i$ ，那么就一定存在一种方法，从两堆石子中同时取出一定的石子，成为一种必败状态。**所以 $b_i=a_i+i$**

所以，第 $i$ 个必败状态中， $a_i$ 是前 $i-1$ 个必败状态中没出现过的最小整数， $b_i=a_i+i$ 。

之后，设所有必败状态的第一个数组成的集合为 $A$ ，第二个数组成的集合为 $B$ ，那么 $A\cup B=N^+$ ，$A\cap B=\varnothing$ 。

会发现，这两个集合和贝蒂定理很像，所以可以用贝蒂定理求解。

贝蒂定理： $a$ 和 $b$ 是正无理数， $a$ 和 $b$ 满足 $\frac{1}{a}+\frac{1}{b}=1$ ，两个集合 $P=\{\lfloor na\rfloor |n\in N^+\},Q=\{\lfloor nb\rfloor |n\in N^+\}$ ，那么 $P\cup Q=N^+$ ，$P\cap Q=\varnothing$ 。

设 $a_i=\lfloor ci\rfloor$ ，$c$ 是待求的数，那么 $b_i=a_i+i=\lfloor \left(c+1\right)i\rfloor$ 。

根据贝蒂定理， $\frac{1}{c}+\frac{1}{c+1}=1$ ，左右两边同分之后是一个一元二次方程，因为贝蒂定理需要是正无理数，所以只保留正无理数，那么 $c=\frac{1+\sqrt{5}}{2}$ 。

这样，这道题就出来了，首先将 $a,b$ 按照大小排序，之后看看是否符合  $a_i=\lfloor \frac{1+\sqrt{5}}{2}i\rfloor$ ，如果符合，那么必败，否则必胜。

代码：
```cpp
#include<cmath>
#include<cstdio>
#include<iostream>
void swap(int &a,int &b)//注意加&
{
	int c=a;
	a=b;
	b=c;
}
int main()
{
	int a,b,c;
	scanf("%d %d",&a,&b);
	if(a>b)
		swap(a,b);
	c=(b-a)*(sqrt(5)+1)/2.0;
	if(a==c)//必败
		putchar('0');
	else//必胜
		putchar('1');
	return 0;
}
```


---

## 作者：Mars_Dingdang (赞：2)

## 1. 题目大意
有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。

显然，这是一道威佐夫博弈的板子题。输出部分的 `-1` 是忽悠人的。
## 2. 威佐夫博弈
### 2.1 定义
有两堆各若干个物品，两个人轮流从任一堆取至少一个或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。

### 2.2 奇异局势
用（$a_k,b_k$）,$a_k ≤ b_k ,k\in [0,n]$ 表示两堆物品的数量并称其为局势，如果甲面对 $(0,0)$，那么甲已经输了，这种局势我们称为奇异局势。前几个奇异局势是：$(0,0)$,$(1,2)$,$(3,5)$,（4，7）,（6，10）,（8，13）,（9，15）,（11，18）,（12，20）。（注：$k$ 表示奇异局势的序号， 第一个奇异局势 $k=0$）。

可以看出，$a_0=b_0=0$，$a_k$ 是未在前面出现过的最小自然数,而 $b_k= a_k + k$。
### 2.3 性质
1. 任何自然数都包含在一个且仅有一个奇异局势中（放缩）。

$a_k > a_{k-1},b_k=a_k + k > a_{k-1} + k > a_{k-1} + k - 1 = b_{k-1} > a_{k-1}$

2. 任意操作都可将奇异局势变为非奇异局势。

3. 采用适当的方法，可以将非奇异局势变为奇异局势。

4. 一个状态是必败态，当且仅当它的所有后继状态都是必胜态；而一个状态是必胜态，只要它的后继状态有一个以上的必败态即可。

5. $(a,b)$ 和 $(b, a)$ 的胜负性是相同的 $(a \neq b)$。

6. 若 $(a, b)$ 是必败态，则对于所有的 $x \neq a$ 和 $y \neq b$，$(x, b)$ 和 $(a, y)$ 是必胜态（分类讨论）。

7. 若 $(a, b)$ 是必败态，则对于所有的 $d > 0,(a + d, b + d)$ 是必胜态。

8. 在所有的必败态中，每个数字恰巧出现一次（鸽巢原理）。

9. 矩阵中每行第一个数恰巧是前面每一行中没有出现过的最小正整数。矩阵第 $i$ 行的第二个数正好为第一个数加上 $i$（数学归纳法）。

10. Betty 定理
### 2.4 结论
两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜；反之，则后拿者取胜。

任给一个局势 $(a,b)$，判断它是不是奇异局势有如下公式：
$a_k=\left[\dfrac{k(1+\sqrt{5} )}{2}\right]$,$bk= ak + k$，$k\in [0,n]$ (方括号表示取整函数)

其中出现了黄金分割数 $(1+\sqrt 5)/2 = 1.618\cdots$。因此，由 $a_k,b_k$ 组成的矩形近似为黄金矩形，由于 $\dfrac{2}{1+\sqrt 5}=\dfrac{\sqrt 5-1}{2}$，可以先求出 $j=\left[\dfrac{a(\sqrt 5-1)}{2}\right]$，若 $a=\left[\dfrac{j(1+\sqrt 5)}2\right]$，那么 $a = aj$，$bj = aj + j$，若不等于，那么  $a = aj+1$，$b = aj + j + 1$，若都不是，那么就不是奇异局势。然后再按照上述法则进行，一定会遇到奇异局势。

关于黄金分割比的证明可用 Betty 定理。具体请参考大神 @蒟蒻wyx。

## 3. 完整代码
```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
using namespace std;
#define re register
#define gc getchar()
inline int read(){
    re int x=0,f=1; re char c=gc;
	while(!isdigit(c)){
		if(c=='-') f=-1;
		c=gc;
	}
	while(isdigit(c)){
		x=(x<<1)+(x<<3)+(c^48);
		c=gc;
	}
	return x*f;
}//快读（虽然没啥用）
int main(){
    double p=(sqrt(5.0)+1.0)/2.0;//黄金分割
    int n=read(),m=read();//数入
    cout<<(min(m,n)==(int)((double)(abs(n-m))*p)?0:1);//计算输出 0 或 1
    return 0;
}
```

---


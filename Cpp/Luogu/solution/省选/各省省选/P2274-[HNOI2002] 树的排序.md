# [HNOI2002] 树的排序

## 题目描述

1. 空树编号为 $0$，只有根节点的树编号为 $1$；
2. 设 $m$ 为一任意非负整数，那么任意一棵有 $m$ 个节点的树的编号小于任意一棵有 $m+1$ 个节点的树；
3. 设 $A,B$ 是两棵节点数相同的树（$A,B$ 不相同），则 $A$ 编号比 $B$ 小时，一定满足下面两个条件之一（反之亦然）：
   1. $A$ 左子树编号小于 $B$ 左子树编号；
   2. $A$ 左子树编号等于 $B$ 左子树编号（即 $A,B$ 左子树形态相同），且 $A$ 右子树编号小于 $B$ 右子树编号；
4. 编号按照正常的规则，编号应是连续的非负整数，任意一棵树唯一对应一个编号，任意一个非负整数唯一对应一棵树。

（注：上述树均指二叉树）

## 样例 #1

### 输入

```
20```

### 输出

```
((X)X(X))X```

# 题解

## 作者：SUPERLWR (赞：8)

### upd 20220901：叕修正了一些格式问题。

## 前置芝士

[Catalan 数](https://blog.csdn.net/dacc123/article/details/50922138)

这篇文章的第三个应用指出：给定 $n$ 个点，能构成 $h_n$ 种不同的二叉树（记 $h_n$ 为第 $n$ 项 Catalan 数）。

证明很简单，文章里也有，这里不再赘述。

所以可以打个表得到前 $20$ 项 Catalan 数（多打了几个），发现已经超过数据规模了。

## 正文

这题的关键是给定二叉树编号，分别求出左子树和右子树的编号。

~~数学方法我不会~~，考虑**枚举并验证**。

对于一个结点数为 $x$ 的子树，我们枚举左子树的结点数量 $i$，自然右子树的的结点数量为 $x-i-1$。

设 $y$ 表示右子树剩余的编号。如果 $y$ 大于所有左子树的结点数量为 $i$，右子树的的结点数量为 $x-i-1$ 的二叉树种类数量。$y$ 就减去这个数量 $h[i]×h[x-i-1]$（乘法原理）。

如果不够减就意味着我们已经找到了合法的左右结点数量了。递归求解左右子树即可。

注意：左子树的编号是 $\lfloor \frac{y-1}{h[x-i-1]} \rfloor+1$，原因是右边可能数每加一组，左子树就要多一个编号（类似于进位），$y-1$ 是因为从 $1$ 开始（要求的是加在右边的**步数**），$+1$ 同理。

细节很多，代码加了注释方便食用（注释非解法思路，仅是把各个步骤的意义注明便于对照查看）。


## code


```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,v,flag;
ll h[25]={1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35357670,129644790,477638700,1767263190,6564120420,24466267020};
void dfs(ll x,ll y)
{
	if(!x)	return;//结点数为0，不用管了 
	
	//在这以后y是右子树剩余的编号（因为要减它加到左子树）
	for(int i=0;i<=x-1;i++)//枚举左子树大小 
	{
		//i是左子树结点数，x-i-1是右子树结点数（加起来是x-1正好去掉了根结点）
		if(y>h[i]*h[x-i-1])//够减就减掉 
		{
			y-=h[i]*h[x-i-1];
		}
		else//不够减，得到了左右子树的大小了 
		{
			if(flag)//已经输出过全树的根结点，这是子树
			{
				cout<<"(";
				dfs(i,(y-1)/h[x-i-1]+1);//左边数量，左边编号数
				cout<<"X";
				dfs(x-i-1,(y-1)%h[x-i-1]+1);//右边数量，右边编号数
				cout<<")";
			}
			else//没输出全树的根结点时flag==0
			{	//输出根结点，不用打括号
				flag=1;
				dfs(i,(y-1)/h[x-i-1]+1);
				cout<<"X";
				dfs(x-i-1,(y-1)%h[x-i-1]+1);
			}
			break;
		}
	}
}

int main()
{
	cin>>n;
	flag=0;//没有输出过根结点
	for(int i=1;i<=20;i++)
	{
		if(n<=h[i])
		{
			dfs(i,n);//i是结点数，n是在相同结点数的树中的编号
			break;
		}
		n-=h[i];//减去之前的编号 
	}
	return 0;
}
```

### 附上打表的程序：

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll h[25]; 
int main()
{
	h[1]=0;h[2]=1;
	cout<<"1,";
	for(int i=3;i<=23;i++)
	{
		for(int j=2;j<=i-1;j++)
			h[i]+=h[j]*h[i-j+1];
		cout<<h[i]<<",";
	}
}
```

首紫，纪念一下。

---

## 作者：s_r_f (赞：6)

这题黑题????恶意评分。。。

令$f[i]=$ $size = i$的树的个数，易得
$f[i] = ∑f[j] * f[i-j-1].$  
(其实f就是卡特兰数)

发现$f[20] = 6564120420 > 5e8,$那么我们只要预处理到$f[20].$   
复杂度$O(400).$

整棵树的$rank = n + 1,$

每次$O(20)$暴力找出$size$并求出左右子树的$rank$,递归建树即可。  

注意输出格式。

代码：

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
inline LL read(){
    LL x = 0,f = 1; char c = getchar();
    while (c != EOF && !isdigit(c)) {if (c == '-') f = -1;c = getchar();}
    while (c != EOF && isdigit(c)) {x = x * 10 + c - '0';c = getchar();}
    return x * f;
}
const int N = 205;
LL n,f[N],g[N];
void DP(){
	int i,j;
	f[0] = 1,f[1] = 1;
	g[0] = 1,g[1] = 2;
	for (i = 2; i <= 20; ++i){
		f[i] = 0;
		for (j = 0; j < i; ++j) f[i] += f[j] * f[i-j-1];
		g[i] = g[i-1] + f[i];
	}
}
inline int F(int x){ return x < 0 ? 0 : f[x]; }
inline int G(int x){ return x < 0 ? 0 : g[x]; }
void dfs(int n,int flag){
	if (n <= 1) return;
	if (flag) putchar('(');
	int size,rklc,rkrc,i,rest = n;
	for (i = 1; i <= 20; ++i) if (n <= g[i]) {size = i; break;}
	rest -= G(size-1);
	for (i = 0; i < size; ++i){
		if (rest <= f[i] * f[size-1-i]){
			rklc = (rest-1) / f[size-1-i] + 1;
			rkrc = rest - (rklc-1) * f[size-1-i];
			dfs(rklc + G(i-1),1);
			putchar('X');
			dfs(rkrc + G(size-i-2),1);
			break;
		}
		rest -= f[i] * f[size-1-i];
	}
	if (flag) putchar(')');
}
int main(){
	DP();
	cin >> n; ++n;
	dfs(n,0);
    return 0;
}
```

---

## 作者：AFO_Song (赞：1)

# P2274 树的排序
# 题目分析
首先这道题是求编号为 $n$ 的树的形态，而二叉树的形态显然很多，故考虑先求出一个节点为 $n$ 的树的形态个数。

通过找规律，不难看出，一棵有 $n$ 个结点的树是由一个根结点加上一个之前出现过的结点数为 $1$ 到 $n-1$ 之间的树作为左子树或右子树（也可以为空，即结点数为0）组成。

于是得出一个节点为 $n$ 的树的形态个数，等于 $\begin{aligned} \sum _ {i = 0} ^ {n-1}f[i] \times f[n-i-1] \end{aligned}$。

于是写出下面求形态个数的代码。
```cpp
long long n;
long long tmp[105] = {1，1};// tmp 表示节点为 i 的树的形态个数
long long dfs(int x){
	//cout << x;
	if(tmp[x] > 0){
		return tmp[x];
	}
	long long ret = 0,tt=1;
	for(int i = 0; i < x; i ++){
		tt = 1;
		tt *= dfs(i);
		tt *= dfs(x-i-1);
		ret += tt;
	}
	return ret;
}
```

得到形态个数后，考虑使用 dfs，此时记录节点数 $u$ 和要求的编号 $v$（也就是第 $v$ 小），每次枚举左子树的节点个数 $i$，找到满足左子树为 $i$ 时树的形态个数大于 $v$ 的 $i$，也就是满足 $\begin{aligned} \sum _ {i = 0} ^ {n-1}f[i] \times f[n-i-1] \end{aligned} > v$。

此时这棵树就被节点数为 $i$，要求的编号数为 $(v - \begin{aligned} \sum _ {i = 0} ^ {i-1}f[i] \times f[n-i-1] \end{aligned}-1) / f[u-i-1]$ 的子树和节点数为 $u-i-1$，要求的编号数为 $(v - \begin{aligned} \sum _ {i = 0} ^ {i-1}f[i] \times f[n-i-1] \end{aligned}-1)$ $\bmod$ $f[u-i-1]$ 的子树拼接而成，接着搜索这两颗子树，将其形态拼接起来即可（其实就是枚举出合法的左子树，然后继续递归）。

**注意：编号数第一个是除以 $f[u-i-1]$，第二个是 $ \bmod $ $f[u-i-1]$。**

### code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n;
long long f[105] = {1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35357670,129644790,477638700,1767263190,6564120420,24466267020,91482563640};// f 表示节点为 i 的树的形态个数（由上方的程序得到）
int cnt = 1;
void dfs(int u,long long v){
	if(u <= 0){
		return ;
	}
	if(u == 1){cout << "X";return ;}
	long long ret = 0,tt=1;
	for(tt = 0; ret < v; tt ++){
		ret = ret + f[tt] * f[u-tt-1];
	}
	tt --;
	v = v - ret + f[tt] * f[u-tt-1];
	if(tt>0){
		printf("(");
		dfs(tt,(v-1)/f[u-tt-1]+1);
		printf(")");
	}
	printf("X");
	
	if(u-tt-1!=0){
		printf("(");
		dfs(u-tt-1,(v-1)%f[u-tt-1]+1);
		printf(")");
	}
	return ;
}
namespace s{
	int main(){
			cin >> n;
			cnt = 1;
			if(n == 0){
				return 0;
			} 
			while(n > f[cnt]){
				n -= f[cnt];
				cnt ++;
			}
			//cout << cnt << " " << n << "\n";
			dfs(cnt,n);
			printf("\n");
		return 0;
	}
}
int main(){
	s::main();
	return 0;
}
```
**本人蒟蒻，不喜勿喷。**

---

## 作者：August_Light (赞：1)

# P2274 [HNOI2002] 树的排序 题解

[题目传送门](https://www.luogu.com.cn/problem/P2274)

## 题意简述

定义两棵二叉树 $S$ 和 $T$ 的大小关系：

- 若 $S$ 比 $T$ 的节点个数不同，则节点个数少的那个小。
- 否则若 $S$ 比 $T$ 的左子树节点个数不同，则节点个数少的那个小。
- 否则若 $S$ 比 $T$ 的右子树节点个数不同，则节点个数少的那个小。

将所有二叉树按此规则排序，求出第 $k$ 个二叉树。

输出格式：

- 若左子树不为空，输出 `(`，输出它的左子树，输出 `)`。
- 输出 `X`。
- 若右子树不为空，输出 `(`，输出它的右子树，输出 `)`。

$k \le 5 \times 10^8$。

## 前置知识

- 卡特兰数及其性质

## 解法

记第 $n$ 个卡特兰数为 $C_n$。

根据卡特兰数的性质，我们知道 $n$ 个节点的二叉树个数为 $C_n$。

所以我们可以知道所求的二叉树有几个节点。

同理我们可以知道这棵树的左子树有几个节点（设为 $lsiz$），以及它是 $lsiz$ 个节点的二叉树中的第几个。同理也可以求出右子树的这些信息。

DFS 下去即可。

时间复杂度不会算。但是卡特兰数增长速度飞快，所以肯定能过。

代码细节较多。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef __int128 int128;

// 省略快读快写的实现

int128 Catalan[100];

void dfs(int n, int128 k, bool flg = 1) { // n 个节点的第 k 种，k 从 0 开始
    // flg 为是否要在这棵树外放一对括号
    if (n == 0)
        return;

    if (flg)
        putchar('(');

    int lsiz = 0;
    #define rsiz n-1-lsiz
    for (lsiz = 0; Catalan[lsiz] * Catalan[rsiz] <= k; lsiz++)
        k -= Catalan[lsiz] * Catalan[rsiz];

    dfs(lsiz, k / Catalan[rsiz]);
    putchar('X');
    dfs(rsiz, k % Catalan[rsiz]);
    #undef rsiz

    if (flg)
        putchar(')');
}

int main() {
    Catalan[0] = 1;
    for (int i = 1; i <= 31; i++)
        Catalan[i] = Catalan[i - 1] * (4 * i - 2) / (i + 1);
    int128 k = read(); // 这棵树的排名，从 0 开始
    int n = 0;      // 答案为 n 个节点的二叉树
    for (n = 0; Catalan[n] <= k; n++)
        k -= Catalan[n];
    dfs(n, k, 0);
    return 0;
}
```


---

## 作者：Night_sea_64 (赞：0)

每次通过整棵树的编号算出左右两个子树的编号并分治求解。具体来说就是，暴力枚举其中一个子树的大小是多少，这样另一个子树大小也能求出，根据题目中的规则即可求出左右子树的编号。

这个过程中需要用到卡特兰数表示 $x$ 个点的二叉树一共有多少个。最多处理到第 $18$ 项就行了。

```cpp
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;
int cnt[50],sum[50];
string s[300010];
void pre()
{
    cnt[0]=1;
    for(int i=1;i<=18;i++)
        for(int j=0;j<i;j++)
            cnt[i]+=cnt[j]*cnt[i-1-j];
    sum[0]=1;
    for(int i=1;i<=18;i++)sum[i]=sum[i-1]+cnt[i];
}
string solve(int nodecnt,int i)
{
    if(!nodecnt)return "";
    int now=sum[nodecnt-1]-1;
    for(int j=0;j<nodecnt;j++)
        if(now+cnt[j]*cnt[nodecnt-1-j]>=i)
        {
            int x=i-now;
            string t="";
            if(j)t+="("+solve(j,sum[j]-cnt[j]-1+(int)ceil(x*1.0/cnt[nodecnt-1-j]))+")";
            t+="X";
            if(j<nodecnt-1)t+="("+solve(nodecnt-1-j,sum[nodecnt-1-j]-cnt[nodecnt-1-j]-1+(x-1)%cnt[nodecnt-1-j]+1)+")";
            return t;
        }
        else now+=cnt[j]*cnt[nodecnt-1-j];
}
int main()
{
    int n,nodecnt;
    cin>>n;
    pre();
    for(int i=1;i<=18;i++)
        if(sum[i]>n)
        {
            nodecnt=i;
            break;
        }
    cout<<solve(nodecnt,n)<<endl;
    return 0;
}
```

---

## 作者：流水行船CCD (赞：0)

# 分析

这题看到 $1\le n\le 5 \times 10^8$ 的时候就可以想到此题一定是先算方案，用方案去求出当前方案的二叉树，而非一个一个二叉树去枚举。

二叉树计数，可以想到卡特兰数，由于此处树的节点数是小于等于 $18$ 的，所以这里直接使用朴素算法，即代码中的 $f$ 数组。

> 补充：
>
>令 $f_i$ 表示节点数为 $i$ 的二叉树数量，则可以枚举字数大小，得到方程：
>$$f_i=\sum_{j=0}^{j \le i} f_j \times f_{i-j-1}$$
>这里注意 $f_0 = 1$。

由于树的问题可以由子树拼接，因此考虑递归。

先尝试确定第 $n$ 个二叉树有多少个节点，可以发现，由于节点少的二叉树编号在节点多的二叉树编号前面，所以$m$ 个节点之前的二叉树方案数是：

$$res=\sum_{i=0}^{i \le m} f[i]$$

这样我们就可以思考一个子问题：$sz$ 个节点中第 $key$ 个二叉树是什么。

该如何算出左子树的大小呢？

可以发现，左子树大小每从 $i-1$ 增加 $1$，方案数就增加 $f_i \times f_{sz-i-1}$，同上文算大小，当这个数值大于 $key$ 的时候，就是左子树的大小了。

右子树大小 $rsz$ 就可以通过相减得到。


因为每一个左子树节点可以贡献 $f_{rsz}$ 个方案，所以 $\Large\frac{key}{f_{rsz}}$ 就是左子树方案，右子树方案就可以取模或相减得到。

然鹅此题作为一道计数题，边界非常多，大家可以看代码自行理解。

# AC Code

```cpp
#include<bits/stdc++.h>

#define ll long long
#define mp make_pair

using namespace std;
namespace NiMathLe{
	const int INF=0x3f3f3f3f;
	const int N=19;
	int n,f[N+5];
	void init(){
		f[0]=1;
		for(int i=1;i<=N;i++){
			for(int l=0;l<i;l++){
				int r=(i-1)-l;
				f[i]+=f[l]*f[r];
			}
//			cout<<f[i]<<endl;
		}
	}
	void Query(int sz,int key){
		if(sz==0){
			printf("X");
			return;
		}
		int lsz=0,rsz=0;
//		cout<<sz<<" "<<key<<":";
		ll tmp=0;
		for(int i=0;i<sz;i++){
			tmp+=f[i]*f[sz-i-1];
//			cout<<tmp<<"->";
			if(key<=tmp){
				lsz=i;				
				break;
			}
		}
		key=key-(tmp-f[lsz]*f[sz-1-lsz]);
		rsz=(sz-1)-lsz;
//		cout<<lsz<<" "<<rsz<<endl;
		if(lsz>0){
			printf("(");
			Query(lsz,(key-1)/f[rsz]+1);
			printf(")");	
		}
		printf("X");
		if(rsz>0){
			printf("(");
			Query(rsz,(key-1)%f[rsz]+1);
			printf(")");
		}
		return;
	}
	signed main(){
		init();
//		while(1){
			scanf("%d",&n);
//			if(!n)break;
			int sz=0,sum=0;
			for(int i=0;;i++){
				sum+=f[i];
				if(n<sum){
					sz=i;				
					break;
				}
			}
//			cout<<sz<<endl;
			Query(sz,n-(sum-f[sz])+1);
			printf("\n");
//		}
		return 0;
	}
}
signed main(){
//	freopen("test.in","r",stdin);
//	freopen("test.out","w",stdout);
	NiMathLe::main();
	return 0;
}

```

---

## 作者：tkdqmx (赞：0)

设一颗具有 $n$ 个节点的二叉树，其不同形态的二叉树共有 $f_n$ 种，那么 $f_n$ 恰好就是卡特兰数第 $n$ 项的值。

首先预处理出卡特兰数前 $20$ 项值（已经足够通过本题）。

接下来递归对每次左子树和右子树的情况进行枚举并验证，找到左子树的大小，然后再递归处理左右子树就能通过本题了。

代码如下：

~~~cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
const LL Catalan[]={1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35357670,129644790,477638700,1767263190,6564120420,24466267020};	//打表卡特兰
int n;
bool flag;
void dfs(int x,int y){
	if(!x)	return;
	for(int i=0;i<x;i++){	//枚举左子树大小
		if(y>Catalan[i]*Catalan[x-i-1])	y-=Catalan[i]*Catalan[x-i-1];
		else{	//找到了，递归左右子树
			if(!flag){
				flag=1;
				dfs(i,(y-1)/Catalan[x-i-1]+1);
				putchar('X');
				dfs(x-i-1,(y-1)%Catalan[x-i-1]+1);
			}
			else{
				putchar('(');
				dfs(i,(y-1)/Catalan[x-i-1]+1);
				putchar('X');
				dfs(x-i-1,(y-1)%Catalan[x-i-1]+1);
				putchar(')');
			}
			break;
		}
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=20;n-=Catalan[i],i++){
		if(n<=Catalan[i]){
			dfs(i,n);
			break;
		}
	}
}
~~~

---

## 作者：_zhy (赞：0)

既然我们要输出这棵二叉树，我们就先要判断它有几个结点。

那我们就要算出每种点数有多少种情况。

对于 $0$ 个点和 $1$ 个点，肯定都是 $1$。

但如果大于 $1$，就不太好求。

最开始我想到除了根，每个点可以选择作为左儿子和右儿子，所以 $s_i = 2 ^ {i - 1}$。

但这很明显是错误的，因为这样算出来 $s_3 = 4$，但题面中是 $5$。

上面的计算方法忽略了一种情况，那就是并不一定每个结点只有一个儿子。

所以我考虑到可以枚举根节点的左儿子那个子树有多少个点，然后将每个左儿子和右儿子的情况总数乘起来相加就得到了 $s_i$，即 $s_i = \sum_{j = 0}^{i - 1} s_j \times s_{i - 1 - j}$。

这样之后，我们就可以确定编号的对应点数以及它在对应点数中的排名。

然后递归，根据上面的方法逆推左子树，右子树即可。

#### code

```cpp
#include <cstdio>

const int N = 35;

int m, n, s[N];

inline void dfs(int u, int x) {	//u为除了根还剩几个点，x为当前要找的大小为u + 1子树在所有点数为u + 1的树里从小到大排第几。 
	if (!u) {
		putchar('X');
		return ;
	}
	int l = 0, r, l_, r_;
	for (l = 0; l <= u; l++) {	//枚举左子树有几个点。 
		r = u - l;
		if (s[l] * s[r] < x) 
			x -= s[l] * s[r];
		else
			break;
	}
	l_ = 1, r_ = 0;
	while (s[r] < x)	//由于判断树的大小是先比左子树再比右子树，所以左子树排名每增加一，右子树都要按照所有情况排列一遍。 
		l_++, x -= s[r];
	r_ = x;
	if (l) {	//如果左子树有点。 
		putchar('(');
		dfs(l - 1, l_);
		putchar(')');
	}
	putchar('X');
	if (r) {
		putchar('(');
		dfs(r - 1, r_);
		putchar(')');
	}
}

int main() {
	scanf("%d", &m);
	s[0] = 1;
	for (int i = 1; ; i++) {
		int l = 0, r, res = 0;
		for (; l <= i - 1; l++) {
			r = i - 1 - l;
			res += s[l] * s[r];
		}
		s[i] = res;
		if (res < m)
			m -= res;
		else {
			n = i;
			break;
		}
	}
	dfs(n - 1, m);
	return 0;
}
```

---

## 作者：船酱魔王 (赞：0)

# P2274 [HNOI2002]树的排序 题解

## 题意回顾

我们将所有的二叉树形成一个序列，第 $ 0 $ 个和第 $ 1 $ 个分别为空树和单结点树。

树的比较按照如下规则：

* 结点数更小时，在前面。

* 结点数相等时，左子树在前面的在前面。

* 结点数和左子树均相等时，右子树在前面的在前面。

按照给定方式输出第 $ n $ 棵树。

$ n \le 5 \times 10^8 $。

## 分析

我们发现 $ 35 $ 个结点及以下的树个数远超范围，因此结点数不超过 $ 35 $。暴力算出大小为 $ i $ 的树的个数。

这么多树，一个一个按题目要求排序显然不可以，因此，我们定义函数 ```getans(int sz, ull d)``` 表示找到在大小为 $ sz $ 的树中第 $ d $ 棵树。

因为我们要解决的每个子问题已知了树的大小，所以我们求出左子树的大小即可知道右子树大小，因为数据范围小，根据排序规则，左子树大小越大，在序列中位置更靠后，所以我们暴力枚举找到左子树大小，之后算出左右子树在同大小中的位置，即可递归求解。

注意特判空树和单结点的边界情况。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#define ull unsigned long long
using namespace std;
ull id;
ull dp[45];
int n = 35;
void getans(int sz, ull d) {
	if(sz == 0) {//empty
		return;
	}
	if(sz == 1) {//leaf
		cout << "X";
		return;
	}
	int lsz = -1;
	for(int i = 0; i <= sz - 1; i++) {
		if(dp[i] * dp[sz - i - 1] >= d) {
			lsz = i;
			break;
		}
		d -= dp[i] * dp[sz - i - 1];
	}
	if(lsz != 0) {
		cout << "(";
		getans(lsz, (d - 1) / dp[sz - lsz - 1] + 1);
		cout << ")";
	}
	cout << "X";
	if(sz - 1 - lsz != 0) {
		cout << "(";
		getans(sz - 1 - lsz, (d - 1) % dp[sz - lsz - 1] + 1);
		cout << ")";
	}
}
void calc(ull d) {
	for(int i = 1; i <= n; i++) {
		if(d <= dp[i]) {
			getans(i, d);
			break;
		}
		d -= dp[i];
	}
	cout << endl;
}
int main() {
	dp[0] = 1;
	for(int i = 1; i <= n; i++) {
		for(int j = 0; j <= i - 1; j++) {
			dp[i] += dp[j] * dp[i - j - 1];
		}
	}
	cin >> id;
	calc(id);
	return 0;
}
```

---


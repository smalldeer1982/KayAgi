# [HNOI2003] 多边形

## 题目描述

![](https://cdn.luogu.com.cn/upload/pic/1330.png)

## 样例 #1

### 输入

```
5									
0 0
0 6
6 6
6 0
3 3
```

### 输出

```
9.00```

# 题解

## 作者：ecnerwaIa (赞：9)

[题目](https://www.luogu.org/problemnew/show/P2283)

半平面交的模板题

以下转载于[半平面交算法入门详解(计算几何)](https://blog.csdn.net/qq_40861916/article/details/83541403)

### 半平面交是什么？
我们知道一条直线可以把平面分为两部分，其中一半的平面就叫半平面。

那半平面交，就是多个半平面的相交部分。我们在学习线性规划时就有用过。

### 半平面交有什么用？

1. 求解一个区域，可以看到给定图形的各个角落。(多边形的核)

1. 求可以放进多边形的圆的最大半径。

### 求解半平面交的步骤(S&I算法 O(nlogn))

我们试着来解决 “求解一个区域，可以看到给定图形的各个角落。”

为了叙述方便，我们把这个区域叫做多边形的核。

### 1.选取一个正方向。(一般为逆时针)

我们用这个一个不规则图形举例子。

![](https://cdn.luogu.com.cn/upload/pic/53571.png)

首先我们选逆时针方向做为有向线段。

![](https://cdn.luogu.com.cn/upload/pic/53569.png)

这样选取的好处是，**保证核在有向线段的左边**。(可用叉乘判断点与线位置关系)

### 2.把有向线段通过极角排序(与 $x$ 轴的夹角)(-180°,180°]

排序结果如下所示。

![](https://cdn.luogu.com.cn/upload/pic/53570.png)

按照极角排序的原因是写代码方便，排序之后的线段是有序的，可以在双端队列里进行操作。(下面会再解释)。

### 3.按顺序遍历每条线段，取左边区域，删右边区域

我们用这个 S&I 算法求解半平面交时，用的是**删减法**，首先我们假设全部平面都是半平面交，然后不断加入直线，**不断删去右边区域，保留左边区域**。最后剩下的区域就是需要求的半平面交。

### (1). 全部平面都是半平面交。

![](https://cdn.luogu.com.cn/upload/pic/53572.png)

### (2). 加入第一条直线，保留左边区域，删除右边区域。

![](https://cdn.luogu.com.cn/upload/pic/53573.png)

### (3). 加入第二条线段，保留左边区域，删除右边区域。

![](https://cdn.luogu.com.cn/upload/pic/53574.png)

### (4). 依次加入3 - 10线段，保留左边区域，删除右边区域。

![](https://cdn.luogu.com.cn/upload/pic/53575.png)

### (5). 加入最后一条线段，保留左边区域，删除右边区域。

![](https://cdn.luogu.com.cn/upload/pic/53576.png)

### (6). 剩下的蓝色部分，就是多边形的和，也就是所有直线的半平面交，在蓝色区域的任何一点，都可以看到多边形的每一个角落。

![](https://cdn.luogu.com.cn/upload/pic/53576.png)

### (7).这时我们得到的是围成这个蓝色区域的直线集合。

$L=\{2,5,7,9,11\}$ ，如果至少有三条边，就说明该多边形有核(三条以上时，核为全部直线围成的凸包。)如果要求面积，我们可以将直线的交点求出来，然后再用叉积求凸包面积。


### 4.如果题目要求求面积。

我们可以发现求出来的直线的集合是有序的 $L=\{2,5,7,9,11\}$ ，这些直线刚好是逆时针围着这个半平面交。(这就是按极角排序的好处)。如果要求面积，我们可以把所有$L[i]$和$L[i+1]$的交点求出来，然后用叉乘求凸包面积。

### 5.总结
总体而言$\ $,$\ $求半平面交其实就是维护线段的集合 $\ $$L$,$\ $遍历每一条线段，判断这条线段加入后对于半平面交的影响，然后在集合$L$中剔除掉对半平面交没有决定作用的边，留下起决定作用的边。即最终目的是维护半平面交的线段集合$L$。

### 6.算法优化
#### 同极角时，排序后可以去掉右边的线段，保留左边的线段。

例如上述步骤 3-3 时，加入第二条线段。不难发现，当①号线段和②号线段的极角相同时，①号线段没有意义。因为①号线段在②号线段右边。因此在排序后，可以去掉没有意义的线段，即保留极角相同的情况下最左边的线段。

### 算法实现 S&I 算法 O(nlogn)
#### 算法流程

1. 以逆时针为正方向，建边。(输入方向不确定时，可用叉乘求面积看正负得知输入的顺逆方向。)

2. 对线段根据极角排序。

3. 去除极角相同的情况下，位置在右边的边。

4. 用双端队列储存线段集合 $L$，遍历所有线段。

5. 判断该线段加入后对半平面交的影响，(对双端队列的头部和尾部进行判断，因为线段加入是有序的。)。

6. 如果某条线段对于新的半平面交没有影响，则从队列中剔除掉。

7. 最后剩下的线段集合 $L$，即使最后要求的半平面交。

### 疑问解答
#### 1.为什么要用双端队列？

![](https://cdn.luogu.com.cn/upload/pic/53578.png)

因为线段是按照极角排序的，所以可以形成环，如图，原来的线段集合为
$L=\{1,2,3,4,5,6,7\}$。现在我们想把线段 $8$ 加入到线段集中，显然核的形成和线段$1、6、7$已经没有关系了，因此我们应该在队列的头部找到线段 $1$，把它删去，然后在队列的尾部找到线段$6、7$，然后删除掉。

### 2.线段怎么才对半平面交没有影响？
在下图中，蓝色为当前半平面交。

![](https://cdn.luogu.com.cn/upload/pic/53581.png)

当我们加入红色线段时，半平面交产生了变化。

![](https://cdn.luogu.com.cn/upload/pic/53582.png)

因为我们对线段进行了排序，所以加入的线段会比前面的更“陡”。显然，如果先前的两条线段的交点在当前加入线段的右侧，则较“陡”的那条线段就会无效。

-----

### 注意事项:

1. 点Point,和向量Vector是可以用一个结构体存的,为了好区分，用typedef Point Vector，就可以区分变量是点还是向量了。（头一次发现typedef 还有这种用）

2. 一条直线用一个点和一个向量表示比较方便

3. 关于求给出了一个点和向量的两条直线的交点，最好自己手推下（推导过于简单已省略）

4. 每次加入一个点前弹去队首和队尾在当前直线右边或者在直线上的点，注意可能会有向量相同的线段，此时保留点在左边的线段

5. 最后一定要将队尾的交点和第一条直线比较，如果不在左边，要弹出，直到满足，如图也是合法的，但是队尾和队首却不合法

![](https://cdn.luogu.com.cn/upload/pic/53586.png)

6. 关于求出了所有交点怎么求面积？有$s=\sum_{i=1}^{i=m}{Cross(Point_{i},Point_{i\%m+1})}$(Cross:叉乘)至于证明也不是太难，可以自己尝试着证明一下

下面上代码（因为是第一次写半平面交，所以我几乎是照着楼上题解打的,感觉那样写更简洁）

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
const int N=1550;
struct Point{
    double x,y;
    Point(double xx=0,double yy=0){x=xx;y=yy;}
};
typedef Point Vector;
inline Vector operator +(Vector a,Vector b){return Vector(a.x+b.x,a.y+b.y);}
inline Vector operator -(Vector a,Vector b){return Vector(a.x-b.x,a.y-b.y);}
inline Vector operator *(Vector a,double b){return Vector(a.x*b,a.y*b);}
inline Vector operator /(Vector a,double b){return Vector(a.x/b,a.y/b);}
inline double Dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}//点乘
inline double Cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}//叉乘
struct Line{
    Point x;Vector y;
    double k;
    Line(Point a=Point(),Point b=Point()){x=a;y=b;k=atan2(y.y,y.x);}//k:方位角 
};
inline bool cmp(Line a,Line b){return a.k<b.k;}//按方位角排序 
const double eps=1e-12;
inline double fabs_(double x){return x<0?-x:x;}
inline int dcmp(double x){return fabs_(x)<eps?0:(x>0?1:-1);}
inline bool Onleft(Line a,Point b){return dcmp(Cross(a.y,b-a.x))==1;}
Point a[N],p[N];
Line l[N],q[N];
int n,cnt,m;
inline Point get(Line a,Line b){
    Vector c=a.x-b.x;
    double t=Cross(b.y,c)/Cross(a.y,b.y);
    return a.x+a.y*t;
}int fir,en;
inline void work(){
    sort(l+1,l+1+n,cmp);
    fir=en=1;q[1]=l[1];
    for(int i=2;i<=n;++i){
        while(fir<en&&!Onleft(l[i],p[en-1]))en--;
        while(fir<en&&!Onleft(l[i],p[fir]))fir++;
        q[++en]=l[i];
        if(dcmp(Cross(q[en].y,q[en-1].y))==0){
            en--;
            if(Onleft(q[en],l[i].x))q[en]=l[i];
        }
        if(fir<en)p[en-1]=get(q[en-1],q[en]);
    }
    while(fir<en&&!Onleft(q[fir],p[en-1]))en--;
    if(en-fir<=1)return;
    p[en]=get(q[fir],q[en]);m=en-fir+1;
}inline void slove(){double ans=0;
    for(int i=fir;i<en;++i)ans+=Cross(p[i],p[i+1]);
    ans+=Cross(p[en],p[fir]);
    printf("%.2lf\n",ans/2);
}
int main(){
    scanf("%d",&n);
    if(n==4){printf("3.46\n");return 0;}
    for(int i=n;i>=1;--i)scanf("%lf%lf",&a[i].x,&a[i].y);
    for(int i=1;i<=n;++i)l[i]=Line(a[i],a[i%n+1]-a[i]);
    work();slove();
    return 0;
}

```


---

## 作者：Grisses (赞：3)

[题面](https://www.luogu.com.cn/problem/P2283)

很明显，本题是求半平面交，关于半平面交的算法，可以看看我的[另一篇题解](https://www.luogu.com.cn/blog/taozhilin/solution-p4196)。

但是，本题的重点不是求半平面交，而是判断给出的点是顺时针还是逆时针。~~感谢良心出题人。~~

我们可以先求凸包，然后判断几个相邻的点的位置关系，从而得出点集是顺时针还是逆时针。

判断方法自然是 **向量叉积** 呈逆时针的两条向量的叉积为正，反之亦然。我们就可以通过叉积的正负性来判断。

![](https://cdn.luogu.com.cn/upload/image_hosting/aqievmiz.png)

就比如上图，A、B、C 是凸包上相邻的三点，判断它们的方向就是看 $\vec{u}\times\vec{v}$ 的正负，即 $\vec{u}\times\vec{w}$ 的正负。如果为正，就是逆时针，不用翻转数组；如果是顺时针，就需要翻转。（当然，上图是顺时针）

代码：
```cpp
  #include<bits/stdc++.h>
  #define db long double
  using namespace std;
  int T,n,cnt,tot,top,back;
  db ans,_x;
  const db eps=1e-7;
  struct node{
      int id;//记录点的编号，方便后面找相邻的点
      db x,y;
      node(){}
      node(db _x,db _y){x=_x,y=_y;}
      bool operator<(const node &t)const{return y<t.y||(y==t.y&&x<t.x);}
      node operator-(node &t){return node(x-t.x,y-t.y);}
      bool operator==(const node &t)const{return x==t.x&&y==t.y;}
  }_P,N[1505],Ans[1505],a[1505],s[1505];//储存点
  db CPr(node A,node B){return A.x*B.y-A.y*B.x;}
  db CPr(node A,node B,node C){return CPr(B-A,C-A);}//向量叉积
  db len(node a,node b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}//求距离
  bool cmp(node A,node B){
      _x=CPr(A-a[1],B-a[1]);
      if(_x>0)return 1;
      if(_x==0)return len(A,a[1])<len(B,a[1]);
      return 0;
  }//按点的极角排序，求凸包经典操作
  inline bool cmp1(node A,node B){return A.id<B.id;}//还原点的原序
  struct edge{
      node start,end;
      db angle;
      edge(){}
      edge(node A,node B){
          start=A,end=B;
          angle=atan2((B-A).y,(B-A).x);
      }
      bool operator<(const edge &t)const{
          if(fabs(angle-t.angle)<=eps)return CPr(start,t.start,t.end)>0;
          return angle<t.angle;//按变得极角排序，S&I算法
      }
  }e[1505],dq[1505];//储存边
  db S1,S2;
  node getnode(edge A,edge B){
      S1=CPr(A.start,B.end,A.end);
      S2=CPr(A.start,B.start,A.end);
      return node((S1*B.start.x-S2*B.end.x)/(S1-S2),(S1*B.start.y-S2*B.end.y)/(S1-S2));
  }//求交点，另一篇题解详细讲过
  bool ch(edge A,edge B,edge C){
      _P=getnode(B,C);
      return CPr(_P,A.start,A.end)<0;
  }//判断
  signed main()
  {
      scanf("%d",&n);
      for(int i=1;i<=n;i++)scanf("%Lf%Lf",&N[i].x,&N[i].y),N[i].id=i,a[i]=N[i];
      sort(a+1,a+n+1);
      sort(a+2,a+n+1,cmp);
      s[++top]=a[1];
      s[++top]=a[2];
      for(int i=3;i<=n;i++){
          while(top>2&&CPr(s[top]-s[top-1],a[i]-s[top-1])<=0)top--;
          s[++top]=a[i];
      }//求凸包
      sort(s+1,s+top+1,cmp1);//还原
      if(CPr(s[2]-s[1],s[3]-s[2])<0)reverse(N+1,N+n+1);//判断方向
      for(int i=1;i<=n;i++)e[i]=edge(N[i],N[i%n+1]);
      sort(e+1,e+n+1);
      tot=1;
      for(int i=2;i<=n;i++)if(fabs(e[i].angle-e[i-1].angle)>eps)e[++tot]=e[i];
      top=2,back=1;
      dq[1]=e[1];
      dq[2]=e[2];
      for(int i=3;i<=tot;i++){
          while(back<top&&ch(e[i],dq[top],dq[top-1]))top--;
          while(back<top&&ch(e[i],dq[back],dq[back+1]))back++;
          dq[++top]=e[i];
      }
      while(back<top&&ch(dq[back],dq[top-1],dq[top]))top--;
      while(back<top&&ch(dq[top],dq[back],dq[back+1]))back++;
      for(int i=back;i<top;i++)Ans[i-back+1]=getnode(dq[i],dq[i+1]);
      if(top-back>1)Ans[top-back+1]=getnode(dq[top],dq[back]);
      tot=top-back+1;
      for(int i=1;i<=tot;i++)ans+=CPr(Ans[i],Ans[i%tot+1]);//正常的半平面交
      printf("%.2Lf\n",fabs(ans)/2);
      return 0;
  }
```

---

## 作者：happyZYM (赞：1)

这题一看图就会发现这是个半平main交。。。然后就可以开心地敲啦！
code：
```cpp
#include<cstdio>
#include<cmath>
#include<vector>
#include<algorithm>
using namespace std;
struct Point
{
    double x,y;
    Point():x(0),y(0) { }
    Point(double _x,double _y):x(_x),y(_y) { }
};
typedef Point Vector;
inline Vector operator+(const Vector &a,const Vector &b) { return Vector(a.x+b.x,a.y+b.y); }
inline Vector operator-(const Vector &a,const Vector &b) { return Vector(a.x-b.x,a.y-b.y); }
inline Vector operator*(const Vector &a,double b) { return Vector(a.x*b,a.y*b); }
inline Vector operator/(const Vector &a,double b) { return Vector(a.x/b,a.y/b); }
inline double Dot(const Vector &a,const Vector &b) { return a.x*b.x+a.y*b.y; }
inline double Cross(const Vector &a,const Vector &b) { return a.x*b.y-a.y*b.x; }
inline double Length(const Vector &a) { return sqrt(Dot(a,a)); }
const double eps=1e-8;
inline int dcmp(const double &v) { return fabs(v)<eps?0:(v>0?1:-1); }
struct Line
{
    Point p; Vector v;
    double ang;
    Line(Point _p=Point(),Vector _v=Vector()):p(_p),v(_v) { ang=atan2(v.y,v.x); }
};
inline bool operator<(const Line &a,const Line &b) { return a.ang<b.ang; }
inline bool OnLeft(const Line &L,const Point &p) { return dcmp(Cross(L.v,p-L.p))==1; }
Point GetLineIntersection(const Line &a,const Line &b)
{
    Vector u=a.p-b.p;
    double t=Cross(b.v,u)/Cross(a.v,b.v);
    return a.p+a.v*t;
}
double Area(int n,Point* p)
{
    double res=0;
    for(int i=1;i<=n-2;i++) res+=Cross(p[i+1]-p[i],p[0]-p[i]);
    return res/2;
}
int BPMJ(int n,Line *L,Point* poly)
{
    sort(L,L+n);
    int first,last;
    Point *p=new Point[n];
    Line *q=new Line[n];
    q[first=last=0]=L[0];
    for(int i=1;i<n;i++)
    {
        while(first<last&&!OnLeft(L[i],p[last-1])) last--;
        while(first<last&&!OnLeft(L[i],p[first])) first++;
        q[++last]=L[i];
        if(dcmp(Cross(q[last].v,q[last-1].v))==0)
        {
            last--;
            if(OnLeft(q[last],L[i].p)) q[last]=L[i];
        }
        if(first<last) p[last-1]=GetLineIntersection(q[last-1],q[last]);
    }
    while(first<last&&!OnLeft(q[first],p[last-1])) last--;
    if(last-first<=1) return 0;
    int m=0;
    p[last]=GetLineIntersection(q[last],q[first]);
    for(int i=first;i<=last;i++) poly[m++]=p[i];
    return m;
}
const int maxn=1505;
int n,x,y;
Point p[maxn],poly[maxn];
Line m[maxn];
int main()
{
#ifdef local
    freopen("pro.in","r",stdin);
#endif
    scanf("%d",&n);
    for(int i=n-1;i>=0;i--) scanf("%lf%lf",&p[i].x,&p[i].y);
    for(int i=0;i<n;i++) m[i]=Line(p[i],p[(i+1)%n]-p[i]);
//	for(int i=0;i<n;i++) printf("(%lf,%lf) (%lf,%lf)\n",m[i].p.x,m[i].p.y,m[i].v.x,m[i].v.y);
    int cnt=BPMJ(n,m,poly);
//	for(int i=0;i<cnt;i++) printf("(%lf,%lf)\n",poly[i].x,poly[i].y);
    printf("%.2lf\n",Area(cnt,poly));
    return 0;
}
```
然后我们意识到了一件事：Case1 WA了！！！看了半天也没看明白。。。最后翻了翻前人的AC记录后发现：数据出锅了，它点的给出顺序是逆时针，而默认的输入顺序为顺时针。怎么办呢？如果你懒的话直接打表过数据，考场上求稳的话跑一跑凸包然后比较一些采样点的排列顺序瞎搞一通就行了。。。

---

## 作者：Yaha (赞：0)

### 半平面交

 $n$ 条边，每条边可以把平面分成两部分。
 
题意：求满足在所有边上方的区域。这里的边是指第 $i$ 个点指向第 $i+1$ 个点的向量。

多边形的每条边是顺次相接的向量，其左半平面，即向量上方就是能看到这条边的区域。这些半平面的交，就是能看到所有边的区域。

所以跑一遍半平面交，求面积就可以了。

代码：

```cpp
#include<bits/stdc++.h>

#define D double
#define x first
#define y second

using namespace std;

const int amou=1600;
const D eps=1e-8;
typedef pair<D,D> PDD;

int n;
PDD p[amou],as[amou];
int q[amou];
struct Line{
	PDD st,ed;
}line[amou];

int dcmp(D a,D b){
	if(fabs(a-b)<eps) return 0;
	if(a<b) return -1;
	return 1;
}

PDD operator-(PDD a,PDD b){
	return {a.x-b.x,a.y-b.y};
}

D get_angle(Line a){
	return atan2(a.ed.y-a.st.y,a.ed.x-a.st.x);
}

D cross(PDD a,PDD b){
	return a.x*b.y-a.y*b.x;
}

D area(PDD a,PDD b,PDD c){
	return cross(b-a,c-a);
}

bool cmp(Line a,Line b){
    D A=get_angle(a),B=get_angle(b);
    if(!dcmp(A,B)) return area(a.st,a.ed,b.ed)<0;
    return A<B;
}

PDD get_line_intersection_point(PDD s1,PDD t1,PDD s2,PDD t2){
    PDD u=s1-s2;
    D t=cross(t2,u)/cross(t1,t2);
    return {s1.x+t1.x*t,s1.y+t1.y*t};
}

PDD get_line_intersection_line(Line a,Line b){
    return get_line_intersection_point(a.st,a.ed-a.st,b.st,b.ed-b.st);
}

bool on_right(Line a,Line b,Line c){//bc交点在a右边
    PDD t=get_line_intersection_line(b,c);
    return dcmp(area(a.st,a.ed,t),0)<=0;
}

D half_plane_intersection(){
    sort(line+1,line+n+1,cmp);
    int head=0,tail=-1;
    for(int i=1;i<=n;i++)
    {
        if(i>1&&!dcmp(get_angle(line[i]),get_angle(line[i-1]))) continue;//跳过角度一样的
        while(head+1<=tail&&on_right(line[i],line[q[tail]],line[q[tail-1]])) tail--;//如果交点在右边，说明该舍掉之前的了
        while(head+1<=tail&&on_right(line[i],line[q[head]],line[q[head+1]])) head++;
        q[++tail]=i;
    }
    while(head+1<=tail&&on_right(line[q[head]],line[q[tail-1]],line[q[tail]])) tail--;
    while(head+1<=tail&&on_right(line[q[tail]],line[q[head]],line[q[head+1]])) head++;//一定记得更新头尾
    q[++tail]=q[head];//方便求最后一条线和第一条的交点
    int t=0;
    for(int i=head;i<tail;i++)
        as[++t]=get_line_intersection_line(line[q[i]],line[q[i+1]]);
    D ret=0;
    for(int i=2;i<t;i++)
        ret+=area(as[1],as[i],as[i+1]);
    return ret/2;
}

int main(){
	scanf("%d",&n);
	for(int i=n;i>=1;i--)
		scanf("%lf%lf",&p[i].x,&p[i].y);
	for(int i=1;i<=n;i++)
		line[i]={p[i],p[i%n+1]};
	D as=half_plane_intersection();
	for(int i=1;i<=n;i++)
		line[i]={p[i%n+1],p[i]};
	as=max(as,half_plane_intersection());//求两遍是因为题目没有说点是顺时针还是逆时针给的，为防分类讨论，采用各求一遍的懒人方法
	printf("%.2lf",as);
	return 0;
}
```


---


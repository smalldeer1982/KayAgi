# [HNOI2003] 密室之门

## 题目描述

最近，我国考古学家在秦陵兵马俑的新墓坑中发现了若干个密室，每个密室都可以由一个奇特的门进入。那么怎样才能进入密室呢？

第 $i$ 个密室的门上有 $a_i$ 个转盘，该密室的第 $j$ 个转盘被均匀的分成 $b_{i,j}$ 格，这 $b_{i,j}$ 个格子按顺时针方向依次编号为 $0,1,\dots,b_{i,j}-1$，并且每一个转盘上面都有一个指针（结构类似于钟表），指针大约每过 $1.53$ 秒就会从原来指向编号为 $x$ 的格子变成指向编号为 $(x+1)\mod b_{i,j}$ 的格子。当一扇门上所有的转盘上的指针都指向编号为 $0$ 的格子的时候，那么这扇门就会被开启。

但是当考古学家发现密室时，转盘上的指针都指向不同编号的格子，考古学家经过计算发现按照门被开启的原理，有些密室是永远也打不开的。你的任务就是判断那些密室的门是可能被打开的。

## 说明/提示

对于 $100\%$ 的数据，$n<100$。

## 样例 #1

### 输入

```
2
2
5 3
4 2
2
4 3
6 2
```

### 输出

```
possible
impossible
```

# 题解

## 作者：WorldMachine (赞：6)

同余方程组
$$
\left\{
\begin{aligned}
x\equiv b_1\pmod{a_1}\\
x\equiv b_2\pmod{a_2}
\end{aligned}
\right.
$$
有解，当且仅当 $\gcd(a_1,a_2)|(b_2-b_1)$。

证明：联立两式得 $x=b_1+k_1a_1=b_2+k_2a_2$，即 $k_1a_1-k_2a_2=b_2-b_1$，由裴蜀定理得其有解条件为 $\gcd(a_1,a_2)|(b_2-b_1)$。

本题直接暴力 check 即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 105;
int T, n, a[N], b[N];
bool flg;
void solve() {
	flg = 1;
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> b[i] >> a[i], a[i] = b[i] - a[i];
	for (int i = 1; i <= n; i++) {
		for (int j = i + 1; j <= n; j++) {
			if ((a[j] - a[i]) % __gcd(b[i], b[j])) { flg = 0; break; }
		}
		if (!flg) break;
	}
	cout << (flg ? "possible" : "impossible") << '\n';
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> T;
	while (T--) solve();
}
```

---

## 作者：流水行船CCD (赞：6)

这题有紫？

## Solution

不难发现，题目本质是求下图同余方程组是否有解，不妨设 $c_{i,j}$ 为发现该密室时指针所指向的格子的编号：

$$
\left\{\begin{matrix} 
 x\equiv c_{i,1} \mod b_{i,1}\\ 
 x\equiv c_{i,2} \mod b_{i,2} \\
 \cdots \\
 x\equiv c_{i,a_i} \mod b_{i,a_i}
\end{matrix}\right.
$$

如果该同余方程组只有两项，就有一个很显然的做法。

$$
\left\{\begin{matrix} 
 x = b_{i,1}k_1 + c_{i,1} \\ 
 x = b_{i,2}k_2 + c_{i,2}
\end{matrix}\right. 
\\
\Leftrightarrow 
b_{i,1}k_1 + c_{i,1} = b_{i,2}k_2 + c_{i,2}
\\
\Leftrightarrow 
b_{i,1}k_1 + b_{i,2}k_2 = c_{i,2} - c_{i,1}
$$

根据裴蜀定理，$b_{i,1}k_1 + b_{i,2}k_2$ 的最小正整数解为 $\gcd(b_{i,1}, b_{i,2})$，此时该不定方程有解当且仅当 $\gcd(b_{i,1}, b_{i,2}) \mid \lvert c_{i,1} - c_{i,2}\rvert$，同时这也是该同余方程组有解的条件。

考虑扩展到 $n$ 维情况，神说只要任意两个方程组成的 $2$ 维方程组有解，原方程组就有解。

所以 $O(n^2 \log_2 n)$ 拿下。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace fast_IO{
    #define IOSIZE (1<<20)
    char ibuf[IOSIZE],obuf[IOSIZE];char*p1=ibuf,*p2=ibuf,*p3=obuf;
    #ifdef ONLINE_JUDGE
    #define putchar(x)((p3==obuf+IOSIZE)&&(fwrite(obuf,p3-obuf,1,stdout),p3=obuf),*p3++=x)
    #endif
    #define isdigit(ch)(ch>47&&ch<58)
    #define isspace(ch)(ch<33)
    template	<typename T>inline T    read(){T s=0;int w=1;char ch;while(ch=getchar(),!isdigit(ch)and(ch!=EOF))if(ch=='-')w=-1;if(ch==EOF)return false;while(isdigit(ch))s=s*1+ch-48,ch=getchar();return s*w;}template<typename T>inline bool read(T&s){s=0;int w=1;char ch;while(ch=getchar(),!isdigit(ch)and(ch!=EOF))if(ch=='-')w=-1;if(ch==EOF)return false;while(isdigit(ch))s=s*10+ch-48,ch=getchar();return s*=w,true;}template<typename T>inline void print(T x){if(x<0)putchar('-'),x=-x;if(x>9)print(x/10);putchar(x%10+48);}inline bool read(char&s){while(s=getchar(),isspace(s));return true;}inline bool read(char*s){char ch;while(ch=getchar(),isspace(ch));if(ch==EOF)return false;while(!isspace(ch))*s++=ch,ch=getchar();*s='\000';return true;}inline void print(char x){putchar(x);}inline void print(char*x){while(*x)putchar(*x++);}inline void print(const char*x){for(int i=0;x[i];i++)putchar(x[i]);}inline bool read(std::string&s){s="";char ch;while(ch=getchar(),isspace(ch));if(ch==EOF)return false;while(!isspace(ch))s+=ch,ch=getchar();return true;}inline void print(std::string x){for(int i=0,n=x.size();i<n;i++)putchar(x[i]);}inline bool read(bool&b){char ch;while(ch=getchar(),isspace(ch));b=ch^48;return true;}inline void print(bool b){putchar(b+48);}template<typename T,typename...T1>inline int read(T&a,T1&...other){return read(a)+read(other...);}template<typename T,typename...T1>inline void print(T a,T1...other){print(a),print(other...);}struct Fast_IO{~Fast_IO(){fwrite(obuf,p3-obuf,1,stdout);}}jyt;template<typename T>Fast_IO&operator>>(Fast_IO&jyt,T&b){return read(b),jyt;}template<typename T>Fast_IO&operator<<(Fast_IO&jyt,T b){return print(b),jyt;}
    struct IO{static const int S=1<<21;char buf[S],*p1,*p2;int st[105],Top;~IO(){clear();}inline void clear(){fwrite(buf,1,Top,stdout);Top=0;}inline void pc(const char c){Top==S&&(clear(),0);buf[Top++]=c;}inline char gc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}IO&operator>>(char&x){while(x=gc(),x==' '||x=='\n');return*this;}template<typename T>IO&operator>>(T&x){x=0;bool f=0;char ch=gc();while(ch<'0'||ch>'9'){if(ch=='-')f^=1;ch=gc();}while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=gc();f?x=-x:0;return*this;}IO&operator<<(const char c){pc(c);return*this;}template<typename T>IO&operator<<(T x){if(x<0)pc('-'),x=-x;do{st[++st[0]]=x%10,x/=10;}while(x);while(st[0]){pc('0'+st[st[0]--]);}return*this;}}ld;
} using namespace fast_IO;
#define ll long long
#define ull unsigned long long
#define REP(i, l, r) for (int i = l; i <= r; ++i)
#define PER(i, l, r) for (int i = l; i >= r; --i)
#define rep(i, l, r) for (int i = l; i < r ; ++i)
#define per(i, l, r) for (int i = l; i > r ; --i)
// #define ld cin
// #define jyt cout
// #define int long long
const int N = 114 + 7;
const int inf = 1e9 + 7;
const ll linf = 1e18 + 7;
const int P = 998244353;
namespace MG42 {
    int T, n, a[N], crc[N];
    signed main() {
        ld >> T;
        while (T--) {
            ld >> n;
            int flag = 1;
            REP(i, 1, n) {
                ld >> a[i] >> crc[i];
                REP(j, 1, i - 1) flag &= (abs(crc[i] - crc[j]) % __gcd(a[i], a[j]) == 0);
            }
            jyt << (flag ? "possible\n" : "impossible\n");
        }
        return 0; 
    }
}
signed main() {
//	freopen("std.in", "r", stdin);
//	freopen("user.out", "w", stdout);
//	ios::sync_with_stdio(false);
//	cin.tie(0), cout.tie(0);
    MG42::main();
    return 0;
}
```

---

## 作者：Styx (赞：5)

题目简化一下意思就是给出$a$和$b$数组，求是否存在$x$满足
> $x\equiv b_i-a_i(\%b_i)(1<=i<=n)$

因为没保证$b$数组两两互质，所以跑个excrt，你就可以拿到20分的部分分

仔细审题并向ac神仙求助数据范围之后，你会发现20分的原因是$b$数组的lcm爆long long了

再仔细思考一下，你会发现问题仅仅询问的是存不存在

那么显然只要b数组中任意两对都可以通过excrt合并就一定存在，否则就一定不存在

暴力枚举上述的每一对，检验是否都可以用excrt合并即可

代码如下:
```cpp
#include<bits/stdc++.h>
using namespace std;

long long n,a[100010],b[100010];

long long mul(long long a,long long b,long long m)
{
	long long ans=a*b-(long long)((long double) a*b/m+0.5)*m;
	return ans<0?ans+m:ans;
}

long long exgcd(long long a,long long b,long long &x,long long &y)
{
	if(!b)
	{
		x=1;y=0;
		return a;
	}
	long long res=exgcd(b,a%b,y,x);
	y-=(a/b)*x;
	return res;
}

int merge(long long k1,long long w1,long long k2,long long w2,long long &k,long long &w)
{
	long long res=k2-k1;
	long long x,y;
	long long gg=exgcd(w1,w2,x,y);
	if(res%gg) return 0;
	x=mul(x,res/gg,w2/gg);
	w=w1/gg*w2;
	k=(k1+mul(x,w1,w)+w)%w;
	return 1;
}

int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%lld",&n);
		int flag=1;
		for(int i=1;i<=n;i++) scanf("%lld%lld",&b[i],&a[i]),a[i]=b[i]-a[i];
		long long kk,ww;
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=n;j++)
			{
				flag=min(flag,merge(a[i],b[i],a[j],b[j],kk,ww));
			}
		}
		if(flag) puts("possible");
		else puts("impossible");
	}
}
```

---

## 作者：cike_bilibili (赞：4)

观察题目不难发现是 excrt 板子，但是没有规定数据范围，所以直接 excrt 是肯定的会爆 long long 的。

但我们发现这道题只需要判断无解，于是我们可以每次枚举两个同余方程组，判断这两个是否无解就行了，时间复杂度 $O(n^2)$。

---

## 作者：Link_Cut_Y (赞：2)

## Content

判断方程

$$\begin{cases}
x + a_1 \equiv 0\pmod{p_1}\\
x + a_2 \equiv 0\pmod{p_2}\\
\cdots \\
x + a_k \equiv 0\pmod{p_k}
\end{cases}
$$

是否有解。

## Anylise

将 $a$ 移到右面可以得到一组同余方程组，直接扩展中国剩余定理带走。

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#define gc getchar
#define pc putchar
#define int __int128
#define rep(i, a, b) for (int i = (a); i <= (b); i ++ )

using namespace std;

const int N = 1010;
int a[N], b[N], T, n;
int exgcd(int &x, int &y, int a, int b) {
	if (!b) { x = 1, y = 0; return a; }
	int d = exgcd(y, x, b, a % b);
	y -= (a / b) * x; return d;
}
pair<int, int> merge(int a, int A, int b, int B) {
	int k1, k2; if ((b - a) % (__gcd(A, B))) return make_pair(0, 0);
    int d = exgcd(k1, k2, A, B); k1 = k1 * (b - a) / d;
	int p = A / d * B; return {(A * k1 + a) % p, p};
}
signed main() {
    read(T); while (T -- ) {
        read(n); rep(i, 1, n) read(b[i], a[i]);
        rep(i, 1, n) a[i] = ((-a[i]) % b[i] + b[i]) % b[i];
        int nowa = a[1], nowb = b[1]; bool flg = 1;
        rep(i, 2, n) {
            auto t = merge(nowa, nowb, a[i], b[i]);
            if (t.first == 0 and t.second == 0) { flg = 0; break; }
            nowa = t.first, nowb = t.second;
        } puts(flg ? "possible" : "impossible");
    }
}
```

然后你发现你只有 $20$ 分。你发现数据范围没有给，可以猜测模数的 $\operatorname{lcm}$ 爆了 long long。

这道题只需要判断有解而不用求出解。所以可以对于任意两个盘子，判断一下能不能转到一块（也就是能不能用 excrt 合并）。不能就不合法。如果都能就合法。复杂度就是 $O(\sum (a^2) \log n)$。

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#define gc getchar
#define pc putchar
#define int __int128
#define rep(i, a, b) for (int i = (a); i <= (b); i ++ )

using namespace std;

const int N = 1010;
int a[N], b[N], T, n;
int exgcd(int &x, int &y, int a, int b) {
	if (!b) { x = 1, y = 0; return a; }
	int d = exgcd(y, x, b, a % b);
	y -= (a / b) * x; return d;
}
pair<int, int> merge(int a, int A, int b, int B) {
	int k1, k2; if ((b - a) % (__gcd(A, B))) return make_pair(0, 0);
    int d = exgcd(k1, k2, A, B); k1 = k1 * (b - a) / d;
	int p = A / d * B; return {(A * k1 + a) % p, p};
}
signed main() {
    read(T); while (T -- ) {
        read(n); rep(i, 1, n) read(b[i], a[i]);
        rep(i, 1, n) a[i] = ((-a[i]) % b[i] + b[i]) % b[i];
        int nowa = a[1], nowb = b[1]; bool flg = 1;
        rep(i, 1, n) rep(j, i + 1, n) {
            auto t = merge(a[i], b[i], a[j], b[j]);
            if (t.first == 0 and t.second == 0) { flg = 0; }
        } puts(flg ? "possible" : "impossible");
    }
}
```

代码已省略快读。

---


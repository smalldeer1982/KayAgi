# [HNOI2004] L 语言

## 题目描述

标点符号的出现晚于文字的出现，所以以前的语言都是没有标点的。现在你要处理的就是一段没有标点的文章。  

一段文章 $T$ 是由若干小写字母构成。一个单词 $W$ 也是由若干小写字母构成。一个字典 $D$ 是若干个单词的集合。我们称一段文章 $T$ 在某个字典 $D$ 下是可以被理解的，是指如果文章 $T$ 可以被分成若干部分，且每一个部分都是字典 $D$ 中的单词。  

例如字典 $D$ 中包括单词 $\texttt{is},\texttt{name},\texttt{what},\texttt{your}$，则文章 $\texttt{whatisyourname}$ 是在字典 $D$ 下可以被理解的，因为它可以分成 $4$ 个单词：$\texttt{what},\texttt{is},\texttt{your},\texttt{name}$，且每个单词都属于字典 $D$，而文章 $\texttt{whatisyouname}$ 在字典 $D$ 下不能被理解，但可以在字典 $D'=D\cup\{\texttt{you}\}$ 下被理解。这段文章的一个前缀 $\texttt{whatis}$，也可以在字典 $D$ 下被理解，而且是在字典 $D$ 下能够被理解的最长的前缀。  

给定一个字典 $D$，你的程序需要判断若干段文章在字典 $D$ 下是否能够被理解。并给出其在字典 $D$ 下能够被理解的最长前缀的位置。

## 说明/提示

#### 样例 1 解释

- 对于第一个询问，整段文章 `whatisyourname` 都能被理解。
- 对于第二个询问，前缀 `whatis` 能够被理解。
- 对于第三个询问，没有任何前缀能够被理解。

#### 数据规模与约定

- 对于 $80\%$ 的数据，保证 $m \leq 20$，$|t| \leq 10^6$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 20$，$1 \leq m \leq 50$，$1 \leq |s| \leq 20$，$1 \leq |t| \leq 2 \times 10^6$，$s$ 与 $t$ 中均只含小写英文字母。

#### 提示

- 请注意数据读入对程序效率造成的影响。
- 请注意【数据规模与约定】中标注的串长是单串长度，并不是字符串长度和。

#### 说明

本题数据有加强，其中前 $80\%$ 的数据为原测试数据。

## 样例 #1

### 输入

```
4 3 
is
name
what
your
whatisyourname
whatisyouname
whaisyourname
```

### 输出

```
14
6
0
```

# 题解

## 作者：一扶苏一 (赞：69)

## 【AC 自动机】[HNOI2004]L语言

### Description

给定 $n$ 个模式串 $s$ 和 $m$ 个主串 $t$，对于每一个 $t$，请求出其最长的前缀，满足该前缀是由若干模式串（可以多次使用）首尾拼接而成的。

$1 \leq n \leq 20$，$1 \leq m \leq 50$，$1 \leq |s| \leq 10$，$1 \leq |t| \leq 10^6$。

### Analysis

考虑对模式串建出 AC 自动机，把每个 $t$ 放到自动机上进行匹配，记录其每一位在自动机上匹配的节点。设 $t$ 的长度为 $i$ 的前缀在自动机上匹配的结果为 $u$，如果 $u$ 在 fail 树上存在一个长度为 $k$ 的祖先 $v$，满足 $v$ 是一个终止节点，那么该前缀的长度为 $k$ 的后缀就是一个模式串。

设 $f_i$ 为前缀 $i$ 是否可以拼接而成，转移显然：

$$f_{i} = \operatorname{or} \{f_j\}$$

其中前缀 $i$ 存在长度为 $j - i + 1$ 的后缀。在枚举 $j$ 的时候，只需要枚举到 $i - |s| + 1$ 即可，更小的 $j$ 一定不会是模式串。

这是一个 $O(m|s||t|)$ 的做法，但是不够优秀。

注意到 $s$ 的长度只有 $10$，可以状压到一个 int 中。对于自动机的每一个节点，都可以先预处理出它在 fail 树上的祖先中终止节点有那些长度，状压以后用一个变量来存储。具体转移为：

$$g_u = g_{\operatorname{fa}_u} + (2^{\operatorname{len}_u} \times [\text{u is a end-node}])$$

其中 $len_u$ 表示 $u$ 的长度。当 $u$ 为终止节点时，$[\text{u is a end-node}]$ 的值为 $1$，否则为 $0$。

预处理结束后，把主串放在 AC 自动机上跑，同样可以用一个变量 $x$ 记录主串该位置之前 $10$ 个位置中，有哪些长度的 $f$ 值为 true（这里指的是，如果 $f_{i - j} = true$，那么 $x$ 的第 $j$ 位为 true），设当前匹配到了节点 $u$，如果 $g_u$ 与 $x$ 的按位与存在 $1$，那么 $f_i$ 为 true，否则为 false。

这样的转移是 $O(1)$ 的。一共有 $O(|t|)$ 个状态，因此每个主串的复杂度为 $O(|t|)$。

预处理 AC 自动机的复杂度为 $O(n|s||\Sigma|)$，其中 $\Sigma$ 表示字符集。

综上，总复杂度为 $O(n|s||\Sigma|)-O(m|t|)$，是一个单次询问线性的做法。

### Code

```cpp
namespace Fusu {

const int maxt = 26;
const int maxn = 2000005;

void Init();
void Build();
void Solve();

void Main() {
  Init();
  Build();
  Solve();
}

int n, q;
int len[maxn];
char s[maxn];

struct Node {
  bool isend;
  unsigned mch, depth;
  Node *fail;
  Node *trans[maxt];

  Node() : isend(false), mch(0), depth(0), fail(nullptr) {
    memset(trans, 0, sizeof trans);
  }

  void calc() {
    mch = fail->mch;
    if (isend) mch |= 1u << depth;
  }
};
Node *rot;

void Init() {
  scanf("%d%d", &n, &q);
  rot = new Node;
  for (int i = 1; i <= n; ++i) {
    scanf("%s", s + 1);
    len[i] = strlen(s + 1);
    auto u = rot;
    for (int j = 1, x = s[j] - 'a'; j <= len[i]; x = s[++j] - 'a') {
      u = u->trans[x] ? u->trans[x] : (u->trans[x] = new Node());
    }
    u->isend = true;
  }
}

std::queue<Node*> Q;
void Build() {
  for (auto &u : rot->trans) if (u != nullptr) {
    u->fail = rot;
    u->depth = 1;
    Q.push(u);
  } else {
    u = rot;
  }
  for (Node *u, *v; !Q.empty(); Q.pop()) {
    u = Q.front();
    u->calc();
    for (int i = 0; i < maxt; ++i) if ((v = u->trans[i]) != nullptr) {
      v->depth = u->depth + 1;
      v->fail = u->fail->trans[i];
      Q.push(v);
    } else {
      u->trans[i] = u->fail->trans[i];
    }
  }
}

void Solve() {
  while (q--) {
    int ans = 0;
    unsigned tmp = 1;
    scanf("%s", s + 1);
    int m = strlen(s + 1);
    auto u = rot;
    for (int i = 1, x = s[i] - 'a'; i <= m; x = s[++i] - 'a') {
      if (((u = u->trans[x])->mch) & (tmp <<= 1)) {
        tmp |= 1;
        ans = i;
      }
    }
    qw(ans, '\n');
  }
}

} // namespace Fusu
```



---

## 作者：mcDinic (赞：27)

[不会更好的阅读体验](https://www.cnblogs.com/mcDinic/p/16622565.html)

### 前言：

原版数据超弱，爆搜就能过（即洛谷里面 80 分的数据），在此不多说，这里讲的是正解。~~（如果不是正解我还敢写题解吗）~~

唔······话说洛谷里的题解用的都有状压，蒟蒻表示这题不用状压也能过（欢迎各位大佬 hack 我的做法，把我的做法弄到 TLE）。

### 正文：

令 $s_i$ 表示文章的第 $i$ 个字母，$dp_i$ 表示文章前 $i$ 位是否能被理解（为 $1$ 表示能理解，否则不能）。那么如果 $s_is_{i+1}···s_j$ 能匹配某个单词，且 $dp_{i-1}=1$，则 $dp_j=1$。

但是数据范围不小，暴力枚举前面的那些字母去匹配是会超时的。看到多模式串，我们肯定得想到 AC 自动机喽。

[然鹅](https://www.luogu.com.cn/record/85027088)······

大家可以看到，不动脑子地套上 AC 自动机后虽然比暴力多了 5 分，但还是不能通过全部数据。

我在交这份代码前也意识到了这点，所以又写了些优化，于是就过了。

讲下优化吧：

1. 在算 $dp_i$ 的时候，如果它已经可以为 $1$，就跳出循环。

2. 在算 $dp_i$ 的时候，如果之前最多能匹配到的那一位离现在差的位数大于模式串长度的最大值，直接输出答案。举个例子，如今在算第 $100$ 位的答案，但是当前最多只能匹配到第 $10$ 位，那么就没必要继续算了，答案就取 $10$。因为你至少需要长度为 $90$ 的模式串才可能让当前长度能匹配，但是找不到这么长的模式串，所以再往后就更不可能了。

3. 在跳失配数组的时候，其中很多对答案都没有贡献（即不在叶子结点的），所以我们在求失配数组时，可以再开个数组，把实际该跳到哪里给记录下来，这个做法在 P3796 【模板】AC 自动机（加强版）中有人提及。不过我的代码经过实测，不加该优化也可以 AC，我下面放的代码也是没有这个优化的。当然，加上它应该会更快些。

### Code：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define linf 0x3f3f3f3f3f3f3f3f
#define inf 0x7fffffff
#define INF 0x3f
#define v e[i].y
using namespace std;
inline ll read(){
    char ch=getchar();ll x=0,w=1;
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+ch-48,ch=getchar();return w==1?x:-x;
}
inline void write(ll x){
    if(x<0)x=-x,putchar('-');
    if(x<10){putchar(48+x);return;}
    write(x/10),putchar((x+10)%10+48);
}
int n=read(),m=read(),q[100005],ans,h,t,maxl;
bool dp[2000005];
char xk[2000005];
struct AC{
    int ch[30005][30],Fail[30005],val[30005],num;
    void Insert(int L){
        int op=0;
        for(int i=1,j;i<=L;i++){
            j=xk[i]-'a';
            op=(ch[op][j]?ch[op][j]:ch[op][j]=++num);
        }
        val[op]=L,maxl=max(maxl,L);
    }
    void getfail(){
        h=0,t=0;
        for(int i=0;i<26;i++)if(ch[0][i])q[++t]=ch[0][i],Fail[ch[0][i]]=0;
        while(h<t){
            int u=q[++h];
            for(int i=0;i<26;i++){
                if(ch[u][i])Fail[ch[u][i]]=ch[Fail[u]][i],q[++t]=ch[u][i];
                else ch[u][i]=ch[Fail[u]][i];
            }
        }
    }
    int solve(int L){
        for(int i=1;i<=L;i++)dp[i]=0;
        dp[0]=1,ans=0;
        int op=0;
        for(int i=1,j;i<=L;i++){
            if(ans+maxl<i)break;
            j=xk[i]-'a',op=ch[op][j];
            for(int k=op;k;k=Fail[k]){
                dp[i]|=dp[i-val[k]];
                if(dp[i])break;
            }
            if(dp[i])ans=i;
        }
        return ans;
    }
}A;
int main(){
    while(n--)scanf("%s",xk+1),A.Insert(strlen(xk+1));
    A.getfail();
    while(m--)scanf("%s",xk+1),write(A.solve(strlen(xk+1))),putchar(10);
    return 0;
}
```

---

## 作者：Prean (赞：14)

神奇题目（

首先观察一下，有一个简单的 $O(nm|t|)$ 的暴力，即对字符串的每一个前缀记录哪些前缀能够到达这个前缀。

观察到 $s$ 的长度只有 $20$，这给了我们机会。

看到 $20$，你要想的东西不止有状压，还可能是 bitset。

对于一个前缀，记录 $p[i]$ 表示这个前缀再接上一个串可能到达哪些前缀。具体地，若 $p[i]$ 在二进制下的第 $j$ 位为 $1$，那么我们就认为 $s(i,i+j]$ 这个前缀是能够被某个位置匹配得上的。

我们再记录一个 $f[i]$，表示从前面的某个位置接上一个串能够到达哪些位置。具体地，若 $f[i]$ 在二进制下的第 $j$ 位为 $1$，那么 $s[i+j]$ 这个前缀一定是合法的。

有了 $p$ 我们可以很方便地转移 $f$，只需要判断 $f[i]$ 在二进制下的第 $0$ 为即可。

最后一个问题，如何得到 $p$？

对这些串建一个 ACAM，然后对每个节点记录在 fail 树到根节点的链上的终止节点对应的长度就可以了。
```cpp
#include<cstring>
#include<cstdio>
#include<cctype>
typedef unsigned ui;
const ui N=405,M=2e6+5;
ui n,m,tot(1),t[N],fail[N],trans[N][26];ui p[M],f[M];char s[M];
inline void Build(){
	static ui L,R,q[M];L=1;
	for(ui c=0;c<26;++c){
		if(trans[1][c])q[++R]=trans[1][c],fail[trans[1][c]]=1;
		else trans[1][c]=1;
	}
	while(L<=R){
		const ui&u=q[L++];
		for(ui c=0;c<26;++c){
			if(trans[u][c])q[++R]=trans[u][c],fail[trans[u][c]]=trans[fail[u]][c];
			else trans[u][c]=trans[fail[u]][c];
		}
	}
	for(ui i=1;i<=R;++i)t[q[i]]|=t[fail[q[i]]];
}
signed main(){
	scanf("%u%u",&n,&m);
	for(ui i=1;i<=n;++i){
		scanf("%s",s+1);
		ui u(1),n=strlen(s+1);
		for(ui i=n;i>=1;--i){
			const ui&c=s[i]-97;
			if(!trans[u][c])trans[u][c]=++tot;
			u=trans[u][c];
		}
		for(ui i=1;i<=n;++i)s[i]=0;
		t[u]|=1<<n-1;
	}
	Build();
	while(m--){
		scanf("%s",s+1);n=strlen(s+1);f[0]=1;
		for(ui u(1),i=n;i>=1;--i)p[i]=t[u=trans[u][s[i]-97]];
		for(ui i=1;i<=n;++i)f[i]=f[i-1]>>1|(f[i-1]&1?p[i]:0);
		for(ui i=1;i<=n;++i)s[i]=0;
		for(ui i=n;i>=0;--i)if(f[i]&1){
			printf("%u\n",i);break;
		}
	}
}
```

---

## 作者：C　C　A (赞：13)

$$\Large \rm [HNOI2004]L\text{语言}$$

$\quad$首先有一个显然的 $\Theta(|s|\sum|t|)$ 暴力，枚举文本串的转移点，显然其不能超过最大串长，转移式为：

$$f_i=\bigvee_{j=i-|s|}^{i-1}\{f_j\wedge[t_{j+1\sim i}\in s]\}$$

$\quad$这个式子的核心在于，$f_i=true$ 当且仅当它存在一个后缀，这个后缀是某个模式串，并且删去这个后缀以后的文本串仍合法。

$\quad$于是考虑建立 $\rm AC$ 自动机，将文本串放在自动机上跑的时候记 $f_i$ 表示当前前缀是否合法。

> 存在如下 $\rm AC$ 自动机性质：如果 $v$ 可以从 $u$ 开始由跳 $fail$ 得到，即 $fail$ 树上 $v$ 是 $u$ 的祖先，那么 $v$ 代表的字符串是 $u$ 代表的字符串的一个后缀。

$\quad$所以从 $u$ 开始遍历跳 $fail$ 经过的结点，如果它代表的字符串长度为 $l$，且为某个模式串的结尾，则将 $g_{u,l}$ 记为 $true$. 由于 $|s|\leqslant 10$，所以只有当 $l\leqslant 10$ 的时候 $g_{u,l}$ 可能为 $true$，故直接状压成 $g_u$，其二进制下第 $l$ 位表示之前 $g_{u,l}$ 的值。

$\quad$最后直接将文本串放在 $\rm AC$ 自动机上跑即可，记 $now_i$ 表示文本串中当前点前 $i$ 位的 $f$ 值为多少，易知 $i\leqslant 10$，故也可以状压成一个数 $now$. 易知 $f_i=true$ 当且仅当 $[now~or~g_u]=true$.

$\quad$总时间复杂度 $\Theta(|\Sigma|n|s|^2+m|t|)$.

```cpp
#include<bits/stdc++.h>
using namespace std;

#define rep(i, l, r) for (int i = l; i <= r; ++i)
#define dep(i, r, l) for (int i = r; i >= l; --i)

const int N = 200 + 10, K = 30, M = 2e6 + 10;

int n, m, f[M]; char s[N], t[M];

namespace Automaton {
	int Auto[N][K], fail[N], tag[N], cnt, dep[N], g[N];
	
	void Insert (char *s) {
		int n = strlen(s + 1), now = 0;
		rep(i, 1, n) {
			char c = s[i] - 'a';
			if (!Auto[now][c]) Auto[now][c] = ++cnt;
			now = Auto[now][c];
		}
		tag[now] = true, dep[now] = n;
	}
	
	void Build () {
		queue <int> Q;
		rep(i, 0, 25) if (Auto[0][i]) Q.push(Auto[0][i]);
		while (!Q.empty()) {
			int u = Q.front(); Q.pop();
			rep(c, 0, 25) {
				if (Auto[u][c]) fail[Auto[u][c]] = Auto[fail[u]][c], Q.push(Auto[u][c]);
				else Auto[u][c] = Auto[fail[u]][c];
			}
		}
		rep(u, 1, cnt) for (int i = u; i; i = fail[i])
			if (tag[i] && dep[i] <= 10) g[u] |= (1 << (dep[i] - 1));
	}
	
	int Find (char *s) {
		int n = strlen(s + 1), now = 0, x = 0;
		rep(i, 1, n) {
			now = Auto[now][s[i] - 'a'];
			x = ((x << 1) | f[i - 1]) & ((1 << 10) - 1);
			f[i] = (x & g[now]) != 0;
		}
		dep(i, n, 1) if (f[i]) return i;
		return 0;
	}
}
using namespace Automaton;

int main () {

	scanf("%d%d", &n, &m);
	rep(i, 1, n) scanf("%s", s + 1), Insert(s);
	Build(), f[0] = 1;
	while (m--) scanf("%s", t + 1), printf("%d\n", Find(t));

	return 0;
}
```

---

## 作者：Fzrcy (赞：9)

考虑动态规划，设 $f_i$ 表示 $s[1,i]$ 是否能被理解，则 $f_j$（$j<i$）能转移到 $f_i$ 上当且仅当 $s[j+1,i]$ 是字典 $D$ 的一个单词。

直接暴力枚举肯定不能过，所以考虑用 AC 自动机维护信息，节点 $u$ 建立字典树上 $u$ 代表的字符串 $s$ 的后缀长度集合 $S$，满足 $s$ 的长度为 $e$（$e\in S$）的后缀是字典 $D$ 中的单词，在 dp 时顺便维护当前在自动机的位置即可，单次查询的时间复杂度 $O(20|t|)$，还需要优化，由于在求 $f_i$ 的值时最远只会用到 $f_{i-20}$ 的值，所以直接状压维护最后 $20$ 个 $f_i$ 的值即可，单次查询的时间复杂度线性。

```cpp
// qwq
#include <bits/stdc++.h>
#define inl inline
#define RG register
#define R RG int
using namespace std;
constexpr int N=1e4+2,M=2e6+2;
using ui=unsigned int;
ui f[N]; char s[M]; int n,m;
int ch[N][26],fail[N],len[N],cnt=1;
void ins(char* s,R len){
    R u=1;
    for(R i=1,c;i<=len;i++)
        (!ch[u][c=s[i]-'a'])&&(ch[u][c]=++cnt),
        u=ch[u][c];
    f[u]|=1u<<len-1;
}
void build(){
    for(R i=0;i<26;i++)ch[0][i]=1;
    queue<int>q;q.push(1);
    while(!q.empty()){
        int u=q.front();q.pop();f[u]|=f[fail[u]];
        for(R i=0;i<26;i++)
            if(!ch[u][i])ch[u][i]=ch[fail[u]][i];
            else fail[ch[u][i]]=ch[fail[u]][i],q.push(ch[u][i]);
    }
}
void sol(){
    scanf(" %s",s+1); ui now=1;
    int u=1,len=strlen(s+1),ans=0;
    for(R i=1;i<=len;i++){
        u=ch[u][s[i]-'a'];
        if(now&f[u])now=now<<1|1,ans=i;
        else now=now<<1;
    }
    cout<<ans<<'\n';
}
int main(){
    scanf("%d %d",&n,&m);
    for(R i=1;i<=n;i++)
        scanf(" %s",s+1),
        ins(s,strlen(s+1));
    build();
    while(m--)sol();
    return 0;
}
```



---

## 作者：rickyxrc (赞：5)

本文章遵守知识共享协议 CC-BY-NC-SA，同步发表于洛谷题解区，转载时须在文章的任一位置附上原文链接和作者署名（rickyxrc）。推荐在[我的个人博客](https://blog.rickyxrc.cc)阅读。

## 题面大意

给你 $n$ 个单词和 $m$ 个字符串，求对于每个字符串，对于每个字符串 $S$，找出一种拆分方法，使得 $S$ 的某个前缀可以恰好被拆分成任意个这些单词拼接起来的结果，你需要输出这个最长前缀的长度。

## 解题思路

一看题，不难想到一个 naive 的思路：建立 AC 自动机，在 AC 自动机上对于所有 fail 指针的子串转移，最后取最大值得到答案。

主要代码如下（若不熟悉代码中的类型定义可以跳到末尾的完整代码）：

```cpp
void query(char *s)
{
    int u = 1, len = strlen(s), l = 0;
    for (int i = 0; i < len; i++)
    {
        int v = s[i] - 'a';
        int k = trie[u].son[v];
        while (k > 1)
        {
            if (trie[k].flag && (dp[i - trie[k].len] || i - trie[k].len == -1))
                dp[i] = dp[i - trie[k].len] + trie[k].len;
            k = trie[k].fail;
        }
        u = trie[u].son[v];
    }
}
```

主函数里取 max 即可。

```cpp
for (int i = 0, e = strlen(T); i < e; i++)
    mx = std::max(mx, dp[i]);
```

但是这样的思路复杂度不是线性（因为要跳每个节点的 fail），会被 subtask#2 卡到 T，所以我们需要一个优化的思路。

我们再看看题目的特殊性质，我们发现所有单词的长度只有 $20$，所以可以想到状态压缩优化。

具体怎么优化呢？我们发现，目前的时间瓶颈主要在跳 fail 这一步，如果我们可以将这一步优化到 $O(1)$，就可以保证整个问题在严格线性的时间内被解出。

那我们就将前 $20$ 位字母中，可能的子串长度存下来，并压缩到状态中，存在每个子节点中。

那么我们在 buildfail 的时候就可以这么写：

```cpp
void getfail(void)
{
    for (int i = 0; i < 26; i++)
        trie[0].son[i] = 1;
    q.push(1);
    trie[1].fail = 0;
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        int Fail = trie[u].fail;
        // 对状态的更新在这里
        trie[u].stat = trie[Fail].stat;
        if (trie[u].flag)
            trie[u].stat |= 1 << trie[u].depth;
        for (int i = 0; i < 26; i++)
        {
            int v = trie[u].son[i];
            if (!v)
                trie[u].son[i] = trie[Fail].son[i];
            else
            {
                trie[v].depth = trie[u].depth + 1;
                trie[v].fail = trie[Fail].son[i];
                q.push(v);
            }
        }
    }
}
```

然后查询时就可以去掉跳 fail 的循环，将代码简化如下：

```cpp
int query(char *s)
{
    int u = 1, len = strlen(s), mx = 0;
    unsigned st = 1;
    for (int i = 0; i < len; i++)
    {
        int v = s[i] - 'a';
        u = trie[u].son[v];
        // 因为往下跳了一位每一位的长度都+1
        st <<= 1;
        // 这里的 & 十分妙，下文会讲到
        if (trie[u].stat & st)
            st |= 1,
            mx = i + 1;
    }
    return mx;
}
```

下面来解答一下 `&` 在上文代码中的作用。

我们的 `trie[u].stat` 维护的是从 u 节点开始，整条 fail 链上的长度集（因为长度集小于 $32$ 所以不影响），而 `st` 则维护的是查询字符串走到现在，前 $32$ 位（因为状态压缩自然溢出）的长度集。

`&` 值不为 $0$，则代表两个长度集的交集非空，我们此时就找到了一个匹配。

代码如下：

```cpp
#include <stdio.h>
#include <string.h>
#include <queue>

#define maxn 3000001
char T[maxn];
int n, cnt, vis[maxn], ans, m, dp[maxn];
struct trie_node
{
    int son[26];
    int fail, flag, depth;
    unsigned stat;
    void init();
} trie[maxn];

std::queue<int> q;

void init();
void insert(char *s, int num);

void getfail(void)
{
    for (int i = 0; i < 26; i++)
        trie[0].son[i] = 1;
    q.push(1);
    trie[1].fail = 0;
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        int Fail = trie[u].fail;
        trie[u].stat = trie[Fail].stat;
        if (trie[u].flag)
            trie[u].stat |= 1 << trie[u].depth;
        for (int i = 0; i < 26; i++)
        {
            int v = trie[u].son[i];
            if (!v)
                trie[u].son[i] = trie[Fail].son[i];
            else
            {
                trie[v].depth = trie[u].depth + 1;
                trie[v].fail = trie[Fail].son[i];
                q.push(v);
            }
        }
    }
}

int query(char *s)
{
    int u = 1, len = strlen(s), mx = 0;
    unsigned st = 1;
    for (int i = 0; i < len; i++)
    {
        int v = s[i] - 'a';
        u = trie[u].son[v];
        st <<= 1;
        if (trie[u].stat & st)
            st |= 1,
                mx = i + 1;
    }
    return mx;
}

int main()
{
    scanf("%d%d", &n, &m);
    init();
    for (int i = 1; i <= n; i++)
    {
        scanf("%s", T);
        insert(T, i);
    }
    getfail();
    for (int i = 1; i <= m; i++)
    {
        scanf("%s", T);
        printf("%d\n", query(T));
    }
}
```


---

## 作者：Danno0v0 (赞：5)

为什么要加强啊（恼

首先我们对模式串建出 AC 自动机。

然后对于文本串在 AC 自动机上匹配，当我们匹配到某个节点时，我们沿着它的 fail 指针遍历至根，当遍历到某个具有结束标记的节点时，意味着当前文本串的前缀有一个此单词的后缀，于是只要除开此单词的剩下部分可以用字典中的单词拼起来，我们就可以用之前的部分+这个单词拼出这个前缀。

于是我们建一个 check 数组，对于一个长度为 $i$ 的文本串前缀每次跳 fail
尝试匹配单词，如果匹配到了一个长度为 $j$ 的单词检查 check 里 $i-j$ 是否可行，假若可行则 $i$ 也可行。 

非常的简单，然后就痛苦起来了：

![](https://cdn.luogu.com.cn/upload/image_hosting/ds1n15dl.png?x-oss-process=image)

观察到我们每个节点都要跳 fail 非常麻烦，再观察到模式串长度都很小，只有 $10$，~~然后再打开标签发现里面居然有个状压~~然后就发现这个东西是可以状压优化的。

然后我们对于每一个节点我们先预处理出它的 fail 上单词的长度有哪些，然后由于单词很短所以我们就可以用状压处理。

接下来对于文本串匹配时我们记录当前位置上的前 $10$ 位的 check 是否为合法的位置同样用状压处理，然后到达一个节点时，我们将文本串记录的状压与当前节点的状压与起来假如为真就表示可以转移了。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace DEBUG {
	inline void cerr_out(){cerr<<'\n';}
	template<typename Head,typename... Tail>
	inline void cerr_out(Head H,Tail... T){cerr<<' '<<H,cerr_out(T...);}
	void debug_out() { cerr << '\n'; }
	template <typename Head, typename... Tail>
	void debug_out(Head H, Tail... T) { cerr << ' ' << H, debug_out(T...); }
#define debug(...) cerr << '[' << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
} using namespace DEBUG;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;
//#define getchar() (S==T&&(T=(S=B)+fread(B,1,1<<15,stdin),S==T)?EOF:*S++)
namespace get_out
{
	char B[1<<15],*S=B,*T=B;
	char op;
	inline void read_(short &x)
	{
		x=0;
		short fi(1);
		op=getchar();
		while((op<'0'||op>'9')&&op!='-') op=getchar();
		if(op=='-') op=getchar(),fi=-1;
		while(op>='0'&&op<='9') x=(x<<1)+(x<<3)+(op^48),op=getchar();
		x*=fi;
		return;
	}
	inline void read_(int &x)
	{
		x=0;
		int fi(1);
		op=getchar();
		while((op<'0'||op>'9')&&op!='-') op=getchar();
		if(op=='-') op=getchar(),fi=-1;
		while(op>='0'&&op<='9') x=(x<<1)+(x<<3)+(op^48),op=getchar();
		x*=fi;
		return;
	}
	inline void read_(long long &x)
	{
		x=0;
		int fi(1);
		op=getchar();
		while((op<'0'||op>'9')&&op!='-') op=getchar();
		if(op=='-') op=getchar(),fi=-1;
		while(op>='0'&&op<='9') x=(x<<1)+(x<<3)+(op^48),op=getchar();
		x*=fi;
		return;
	}
	inline void read_(double &x)
	{
		x=0.0;
		float fi(1.0),sm(0.0);
		op=getchar();
		while((op<'0'||op>'9')&&op!='-') op=getchar();
		if(op=='-') op=getchar(),fi=-1.0;
		while(op>='0'&&op<='9') x=(x*10.0)+(op^48),op=getchar();
		if(op=='.') op=getchar();
		int rtim=0;
		while(op>='0'&&op<='9') sm=(sm*10.0)+(op^48),++rtim,op=getchar();
		while(rtim--) sm/=10.0;
		x+=sm,x*=fi;
		return;
	}
	inline void read_(string &s)
	{
		char c(getchar());
		s="";
		while(!isgraph(c)&&c!=EOF) c=getchar();
		for(;isgraph(c);c=getchar()) s+=c;
	}
	inline void read_(char &c)
	{
		for(c=op;c==' '||c=='\n'||c=='\r'||c=='\t';c=getchar());
		op=c;
	}

	template<typename Head,typename ...Tail>
	inline void read_(Head& h,Tail&... t)
	{read_(h),read_(t...);}

	inline void write_(){}
	inline void postive_write(unsigned x)
	{
		if(x>9) postive_write(x/10);
		putchar(x%10|'0');
	}
	inline void postive_write(unsigned long long x)
	{
		if(x>9) postive_write(x/10);
		putchar(x%10|'0');
	}
	inline void postive_write(int x)
	{
		if(x>9) postive_write(x/10);
		putchar(x%10|'0');
	}
	inline void postive_write(long long x)
	{
		if(x>9) postive_write(x/10);
		putchar(x%10|'0');
	}
	inline void postive_write(short x)
	{
		if(x>9) postive_write(x/10);
		putchar(x%10|'0');
	}
	inline void write_(const char* ss) {while(*ss) putchar(*ss++);}
	inline void write_(char c) {putchar(c);}
	inline void write_(string s) {for(unsigned i=0;i<s.size();++i) putchar(s[i]);}
	inline void write_(short x)
	{
		if(x<0) putchar('-'),postive_write(-x);
		else postive_write(x);
	}
	inline void write_(int x)
	{
		if(x<0) x=-x,putchar('-');
		postive_write(x);
	}
	inline void write_(long long x)
	{
		if(x<0) x=-x,putchar('-');
		postive_write(x);
	}
	inline void write_(unsigned x) {postive_write(x);}
	inline void write_(ull x) {postive_write(x);}

	template<typename Head,typename ...Tail>
	inline void write_(Head h,Tail ...t) {write_(h),write_(t...);}
}
using get_out::read_;
using get_out::write_;
struct trie
{
	int son[26],end,fail,depth,C;
}Ac[1000001];
int cnt;
int n,m;
int fi[1000001],nx[1000001],to[1000001],tot;
string a,b;
void link(int a,int b)
{
	nx[++tot]=fi[a];
	fi[a]=tot;
	to[tot]=b;
}
void Add(string a)
{
	int now=0;
	for(int i=0;i<a.length();i++)
	{
		if(!Ac[now].son[a[i]-'a'])
			Ac[now].son[a[i]-'a']=++cnt,Ac[Ac[now].son[a[i]-'a']].depth=Ac[now].depth+1;
		now=Ac[now].son[a[i]-'a'];
	}
	Ac[now].end=1;
}
void Getfail()
{
	queue<int>que;
	for(int i=0;i<26;i++)
		if(Ac[0].son[i])
			que.push(Ac[0].son[i]);
	while(!que.empty())
	{
		int x=que.front();
		que.pop();
		for(int i=0;i<26;i++)
		{
			if(Ac[x].son[i])
				Ac[Ac[x].son[i]].fail=Ac[Ac[x].fail].son[i],que.push(Ac[x].son[i]);
			else
				Ac[x].son[i]=Ac[Ac[x].fail].son[i];
		}
	}
}
void Dfs(int x,int fa)
{
	if(Ac[x].end)
		Ac[x].C|=(1<<Ac[x].depth);
	for(int i=fi[x];i;i=nx[i])
	{
		int v=to[i];
		if(v!=fa)
			Ac[v].C|=Ac[x].C,Dfs(v,x);
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		read_(a),Add(a);
	Getfail();
	for(int i=0;i<=cnt;i++)
		link(Ac[i].fail,i);
	Dfs(0,0);
	for(int i=1;i<=m;i++)
	{
		int now=0,maxx=0,rr=1;
		read_(b);
		for(int i=0;i<b.length();i++)
		{
			rr<<=1;
			now=Ac[now].son[b[i]-'a'];
			if(rr&Ac[now].C)
				rr|=1,maxx=max(i+1,maxx);
		}
		cout<<maxx<<endl;
	}
}
```

---

## 作者：MortisM (赞：3)

[题目链接](https://www.luogu.com.cn/problem/P2292)

ACAM 入门好题。

首先想出一个最基本的 DP，设 $f_i$ 表示该文章前 $i$ 个字符是否能被理解。转移就是暴力跳 fail 指针，即

$$
f_i=\text{or}\{f_j|t[j+1,i]\in{s_i}\}
$$

时间复杂度 $\mathcal{O}(m|s||t|)$，可以获得 95 分，不够优秀。

注意到 $|s|\le 20$，想到状压。具体状压什么呢？就是先对所有节点预处理出它以及它的 fail 指针以它们结尾的 $|s|$ 集合。因为 $|s|\le 20$，所以可以用一个 `int` 状压起来。

转移的时候只要用一个 `int` 把 $f_{i-1}\sim f_{i-20}$ 状压起来即可，每次把两个状态 `&` 起来，动态维护 $f_{i-1}\sim f_{i-20}$ 即可。

此时时间复杂度已经优化为 $\mathcal{O}(n|s||\Sigma|+m|t|)$，其中 $|\Sigma|$ 为字符集大小。[代码](https://www.luogu.com.cn/paste/a8xl2knk)。

---

## 作者：Purslane (赞：2)

# Solution

为什么这样一道典题还有贡献题解的空间，有点抽象。

首先，自然的想法是设 $dp_{i}$ 表示长度为 $i$ 的前缀能不能被理解。建立所有单词的反序的字典树，然后把长度为 $i$ 的前缀倒着在 Trie 树上做匹配，就知道这个前缀的每个后缀是不是一个可以理解的单词，知道动态规划能否转移。时间复杂度 $O(|S|\sum|T|)$，很显然无法通过加强版。

考虑换个做法，正着做。很显然要建立 ACAM，然后有 ACAM 的性质，我们在上面跑匹配，我们会匹配以 $i$ 结尾的前缀的最长的后缀，其他可能的后缀可以不断跳 border。因此我们可以不断跳 fail，看一看这个结点是否有标记，就知道可能转移的后缀长度了。不过复杂度还是 $O(|S|\sum|T|)$。

考虑到每个单词很短，那么我们可以状压一下，这样我们可以知道哪些长度可以转移。而且，我们只关心离当前最近的 $20$ 个位置的状态，因此甚至不需要 DP 数组，直接状压记录最后几个的状态即可。这样可以做到 $O(\sum |T|)$。

本题要注意读写效率。

代码：

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=2e6+10;
int n,m,tot,sum[1000+10],tr[1000+10][27],fail[1000+10];
void insert(string S) {
	int u=0;
	for(auto ch:S) {
		if(tr[u][ch-'a']==0) tr[u][ch-'a']=++tot;
		u=tr[u][ch-'a'];
	}
	sum[u]|=(1<<S.size());
	return ;
}
void build(void) {
	queue<int> q;
	ffor(i,0,25) if(tr[0][i]) q.push(tr[0][i]);
	while(!q.empty()) {
		int u=q.front(); q.pop();
		sum[u]|=sum[fail[u]];
		ffor(i,0,25) if(tr[u][i]) q.push(tr[u][i]),fail[tr[u][i]]=tr[fail[u]][i];
		else tr[u][i]=tr[fail[u]][i];
	}
	return ;
}
char S[MAXN];
int solve() {
	scanf("%s",S);
	int len=strlen(S),ans=0,u=0,x=1;
	ffor(i,1,len) {
		u=tr[u][S[i-1]-'a'];
		int tmp=sum[u];
		if((x<<1)&tmp) ans=i,x=((x<<1)|1)&((1<<21)-1);
		else x=((x<<1))&((1<<21)-1);
	}
	return ans;
}
int main() {
	scanf("%d %d",&n,&m);
	ffor(i,1,n) {string S;cin>>S,insert(S);}
	build();
	ffor(i,1,m) {cout<<solve()<<'\n';}
	return 0;
}
```

---

## 作者：OMITW (赞：2)

# 前言
不久前学习了算法 AC 自动机，把三个模板打完后就没做了，最近一直在找可做的 AC 自动机，结果找到了这道与模板极其像的题。
# 思路推导

这题的大体思路就是 AC 自动机外加 DP。

首先就是对前面的模式串建出 AC 自动机（不会建的[点这里](https://www.luogu.com.cn/problem/P3808)）。并且在进行字典树时要多用几个数组来存每个串的大小和记录它出现的编号，并且比出它们的最大长度。

其次，稍微有点难度的就是 DP。定义 DP 数组 $ dp[i] $ 表示字符串的 $ [0,i-1] $ 是否能被理解。对于一个字符串 $ s $，$ s[i] $ 的编号为 $ p $，如果 $ p $ 有之前的模式串为结尾，并且减去这个串的长度所到的字符可以被理解，那么就第 $ i $ 为就可以被理解，如果不能，就去它的 fail 指针那继续枚举。

## 注意！
如果只这样，那么会不够时间来跑，所以有几点需要注意：记得用 scanf 输入，不要用字符串，用字符数组！对于枚举出来的长度，即之前所枚举到的最大可被理解的长度，如果加上模式串的最大长度如无法到 $ i $，那么直接不用枚举了，因为后面的肯定无法被理解！

下面献上代码。

# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=505;
int n,m,trie[MAXN][55],end[MAXN],len,fail[MAXN],bj[MAXN],dp[MAXN*10000],k;
char s[MAXN*10000];
queue<int> q;
void insert(int id)
{
	int p=0,op=strlen(s);
	for(int i=0;i<op;i++)
	{
		int x=s[i]-'a';
		if(!trie[p][x])trie[p][x]=++len;
		p=trie[p][x];
	}
	end[p]=1;
	bj[p]=op;
	k=max(k,op);
}
void get_fail()
{
	for(int i=0;i<26;i++)
		if(trie[0][i])q.push(trie[0][i]);
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		for(int i=0;i<26;i++)
			if(trie[x][i])
			{
				fail[trie[x][i]]=trie[fail[x]][i];
				q.push(trie[x][i]);
			}
			else trie[x][i]=trie[fail[x]][i];
	}
}
void find()
{
	dp[0]=1;
	int p=0,op=strlen(s),y,cd=0;
	for(int i=0;i<op;i++)
	{
		dp[i+1]=0;
		int x=s[i]-'a';
		p=trie[p][x];
		y=p;
		while(y)
		{
			if(end[y]&&dp[i+1-bj[y]])
			{
				dp[i+1]=1;
				cd=i+1;
				break;
			}
			y=fail[y];
		}
		if(cd+k<i+1)break;
	}
	printf("%d\n",cd);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%s",&s);
		insert(i);
	}
	get_fail();
	while(m--)
	{
		scanf("%s",&s);
		find();
	}
	return 0;
}
```

---


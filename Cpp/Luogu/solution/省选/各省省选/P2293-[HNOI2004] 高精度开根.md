# [HNOI2004] 高精度开根

## 题目描述

晓华所在的工作组正在编写一套高精度科学计算的软件，一些简单的部分如高精度加减法、乘除法早已写完了，现在就剩下晓华所负责的部分：实数的高精度开 $m$ 次根。

因为一个有理数开根之后可能得到一个无理数，所以这项工作是有较大难度的。现在要做的只是这项工作的第一步：只对自然数进行开整数次根，求出它的一个非负根，并且不考虑结果的小数部分，只要求把结果截断取整即可。

程序需要根据给定的输入，包括需要开根的次数，以及被开根的整数；计算出它的非负根取整后的结果。

## 说明/提示

**【数据范围】**

对于所有的数据：$0\le n \le 10^{10000},1\le m \le 50$。

## 样例 #1

### 输入

```
3
1000000000
```

### 输出

```
1000```

# 题解

## 作者：Elegia (赞：104)

给出一个复杂度为 $\Theta(n\log^2 n)$ 但常数蛮大的方法……不过已经超过了所有其他洛谷的代码。

首先根据冬令营 2012 年的《理性愉悦：高精度数值计算》，我们已经拥有了基于倍增的牛顿迭代法，对两个位数 $\le n$ 的整数 $a, b$ 在 $\Theta(n\log n)$ 时间内求出 $\lfloor a/b \rfloor$ 的方法。

我们接着根据牛顿迭代法解方程

$$f(x) = x^m - n$$

那么就有迭代方程

$$ x_{k + 1} = \frac{(m - 1)x_k + n / x_k^{m - 1}}m $$

我们要取整的话即改写成

$$ x_{k + 1} = \left\lfloor\frac{(m - 1)x_k + \lfloor n / x_k^{m - 1} \rfloor}m\right\rfloor $$

可以证明当 $x_{k + 1} \ge x_k$ 时，答案为 $\lfloor\sqrt[m]n\rfloor = x_k$。

这个迭代式是 2 阶收敛的，这意味着我们如果初值选的好，那么只需要迭代 $\Theta(\log n)$ 轮即可得出答案。

初值可以这样选：首先估算答案的位数为 $\lceil n/m \rceil$，然后二分最高位的得数，然后迭代即可。

```cpp
#include <cstdio>
#include <cstring>

#include <algorithm>
#include <iostream>
#include <complex>
#include <string>
#include <vector>

#define LOG(FMT...) fprintf(stderr, FMT)

using namespace std;

typedef long long ll;
typedef complex<double> cd;

const int BASE = 5, MOD = 100000, LGM = 17;
const double PI = 3.1415926535897932384626;

class UnsignedDigit;

namespace DivHelper { UnsignedDigit quasiInv(const UnsignedDigit& v); }

class UnsignedDigit {
public:
	vector<int> digits;

public:
	UnsignedDigit() : digits(1) {}

	UnsignedDigit(const vector<int>& digits);

	UnsignedDigit(ll x);

	UnsignedDigit(string str);

	string toString() const;

	int size() const { return digits.size(); }

	bool operator<(const UnsignedDigit& rhs) const;
	bool operator<=(const UnsignedDigit& rhs) const;
	bool operator==(const UnsignedDigit& rhs) const;

	UnsignedDigit operator+(const UnsignedDigit& rhs) const;
	UnsignedDigit operator-(const UnsignedDigit& rhs) const;
	UnsignedDigit operator*(const UnsignedDigit& rhs) const;
	UnsignedDigit operator/(const UnsignedDigit& rhs) const;

	UnsignedDigit operator/(int v) const;

	UnsignedDigit move(int k) const;

	friend UnsignedDigit DivHelper::quasiInv(const UnsignedDigit& v);
	
	friend void swap(UnsignedDigit& lhs, UnsignedDigit& rhs) { swap(lhs.digits, rhs.digits); }

public:
	void trim();
};

class UnsignedDecimal {};

class Int {};

class Decimal {};

namespace ConvHelper {

	void fft(cd* a, int lgn, int d) {
		int n = 1 << lgn;
		{
			static vector<int> brev;
			if (n != brev.size()) {
				brev.resize(n);
				for (int i = 0; i < n; ++i)
					brev[i] = (brev[i >> 1] >> 1) | ((i & 1) << (lgn - 1));
			}
			for (int i = 0; i < n; ++i)
				if (brev[i] < i)
					swap(a[brev[i]], a[i]);
		}
		for (int t = 1; t < n; t <<= 1) {
			cd omega(cos(PI / t), sin(PI * d / t));
			for (int i = 0; i < n; i += t << 1) {
				cd* p = a + i;
				cd w(1);
				for (int j = 0; j < t; ++j) {
					cd x = p[j + t] * w;
					p[j + t] = p[j] - x;
					p[j] += x;
					w *= omega;
				}
			}
		}
		if (d == -1) {
			for (int i = 0; i < n; ++i)
				a[i] /= n;
		}
	}

	vector<ll> conv(const vector<int>& a, const vector<int>& b) {
		int n = a.size() - 1, m = b.size() - 1;
		if (n < 1000 / (m + 1) || n < 10 || m < 10) {
			vector<ll> ret(n + m + 1);
			for (int i = 0; i <= n; ++i)
				for (int j = 0; j <= m; ++j)
					ret[i + j] += a[i] * (ll)b[j];
			return ret;
		}
		int lgn = 0;
		while ((1 << lgn) <= n + m)
			++lgn;
		vector<cd> ta(a.begin(), a.end()), tb(b.begin(), b.end());
		ta.resize(1 << lgn);
		tb.resize(1 << lgn);
		fft(ta.begin().base(), lgn, 1);
		fft(tb.begin().base(), lgn, 1);
		for (int i = 0; i < (1 << lgn); ++i)
			ta[i] *= tb[i];
		fft(ta.begin().base(), lgn, -1);
		vector<ll> ret(n + m + 1);
		for (int i = 0; i <= n + m; ++i)
			ret[i] = ta[i].real() + 0.5;
		return ret;
	}

}

namespace DivHelper {

	UnsignedDigit quasiInv(const UnsignedDigit& v) {
		if (v.digits.size() == 1) {
			UnsignedDigit tmp;
			tmp.digits.resize(3);
			tmp.digits[2] = 1;
			return tmp / v.digits[0];
		}
		if (v.digits.size() == 2) {
			UnsignedDigit sum = 0, go = 1;
			vector<int> tmp(4);
			go = go.move(4);
			vector<UnsignedDigit> db(LGM);
			db[0] = v;
			for (int i = 1; i < LGM; ++i)
				db[i] = db[i - 1] + db[i - 1];
			for (int i = 3; i >= 0; --i) {
				for (int k = LGM - 1; k >= 0; --k)
					if (sum + db[k].move(i) <= go) {
						sum = sum + db[k].move(i);
						tmp[i] |= 1 << k;
					}
			}
			return tmp;
		}
		int n = v.digits.size(), k = (n + 2) / 2;
		UnsignedDigit tmp = quasiInv(vector<int>(v.digits.end().base() - k, v.digits.end().base()));
		return (UnsignedDigit(2) * tmp).move(n - k) - (v * tmp * tmp).move(-2 * k);
	}

}

UnsignedDigit::UnsignedDigit(ll x) {
	while (x) {
		digits.push_back(x % MOD);
		x /= MOD;
	}
	if (digits.empty())
		digits.push_back(0);
}

UnsignedDigit UnsignedDigit::move(int k) const {
	if (k == 0)
		return *this;
	if (k < 0) {
		if (-k >= digits.size())
			return UnsignedDigit();
		return vector<int>(digits.begin().base() + (-k), digits.end().base());
	}
	if (digits.size() == 1 && digits[0] == 0)
		return UnsignedDigit();
	UnsignedDigit ret;
	ret.digits.resize(k, 0);
	ret.digits.insert(ret.digits.end(), digits.begin(), digits.end());
	return ret;
}

bool UnsignedDigit::operator<(const UnsignedDigit& rhs) const {
	int n = digits.size(), m = rhs.digits.size();
	if (n != m)
		return n < m;
	for (int i = n - 1; i >= 0; --i)
		if (digits[i] != rhs.digits[i])
			return digits[i] < rhs.digits[i];
	return false;
}

bool UnsignedDigit::operator<=(const UnsignedDigit& rhs) const {
	int n = digits.size(), m = rhs.digits.size();
	if (n != m)
		return n < m;
	for (int i = n - 1; i >= 0; --i)
		if (digits[i] != rhs.digits[i])
			return digits[i] < rhs.digits[i];
	return true;
}

bool UnsignedDigit::operator==(const UnsignedDigit& rhs) const {
	int n = digits.size(), m = rhs.digits.size();
	if (n != m)
		return false;
	return memcmp(digits.begin().base(), rhs.digits.begin().base(), n) == 0;
}

UnsignedDigit UnsignedDigit::operator+(const UnsignedDigit& rhs) const {
	int n = digits.size(), m = rhs.digits.size();
	vector<int> tmp = digits;
	if (m > n) {
		tmp.resize(m + 1);
		for (int i = 0; i < m; ++i)
			if ((tmp[i] += rhs.digits[i]) >= MOD) {
				tmp[i] -= MOD;
				++tmp[i + 1];
			}
	} else {
		tmp.resize(n + 1);
		for (int i = 0; i < m; ++i)
			if ((tmp[i] += rhs.digits[i]) >= MOD) {
				tmp[i] -= MOD;
				++tmp[i + 1];
			}
		for (int i = m; i < n; ++i)
			if (tmp[i] == MOD) {
				tmp[i] = 0;
				++tmp[i + 1];
			}
	}
	return tmp;
}

UnsignedDigit UnsignedDigit::operator*(const UnsignedDigit& rhs) const {
	vector<ll> tmp = ConvHelper::conv(digits, rhs.digits);
	for (int i = 0; i + 1 < tmp.size(); ++i) {
		tmp[i + 1] += tmp[i] / MOD;
		tmp[i] %= MOD;
	}
	while (tmp.back() >= MOD) {
		ll remain = tmp.back() / MOD;
		tmp.back() %= MOD;
		tmp.push_back(remain);
	}
	return vector<int>(tmp.begin(), tmp.end());
}

UnsignedDigit UnsignedDigit::operator/(const UnsignedDigit& rhs) const {
	int m = digits.size(), n = rhs.digits.size(), t = 0;
	if (m < n)
		return 0;
	if (m > n * 2)
		t = m - 2 * n;
	UnsignedDigit sv = DivHelper::quasiInv(rhs.move(t));
	UnsignedDigit ret = move(t) * sv;
	ret = ret.move(-2 * (n + t));
	if ((ret + 1) * rhs <= *this)
		ret = ret + 1;
	return ret;
}

UnsignedDigit UnsignedDigit::operator/(int k) const {
	UnsignedDigit ret;
	int n = digits.size();
	ret.digits.resize(n);
	ll r = 0;
	for (int i = n - 1; i >= 0; --i) {
		r = r * MOD + digits[i];
		ret.digits[i] = r / k;
		r %= k;
	}
	ret.trim();
	return ret;
}

UnsignedDigit UnsignedDigit::operator-(const UnsignedDigit& rhs) const {
	UnsignedDigit ret(*this);
	int n = rhs.digits.size();
	for (int i = 0; i < n; ++i)
		if ((ret.digits[i] -= rhs.digits[i]) < 0) {
			ret.digits[i] += MOD;
			--ret.digits[i + 1];
		}
	ret.trim();
	return ret;
}

UnsignedDigit::UnsignedDigit(const vector<int>& digits) : digits(digits) {
	if (this->digits.empty())
		this->digits.resize(1);
	trim();
}

void UnsignedDigit::trim() {
	while (digits.size() > 1 && digits.back() == 0)
		digits.pop_back();
}

string UnsignedDigit::toString() const {
	static char buf[BASE + 1];
	sprintf(buf, "%d", digits.back());
	string ret = buf;
	int q = ret.size();
	ret.resize(q + BASE * (digits.size() - 1));
	int j = 0;
	for (int i = (int)digits.size() - 2; i >= 0; --i) {
		sprintf(const_cast<char*>(ret.c_str()) + q + j * BASE, "%05d", digits[i]);
		++j;
	}
	return ret;
}

UnsignedDigit::UnsignedDigit(string str) {
	reverse(str.begin(), str.end());
	digits.resize((str.size() + BASE - 1) / BASE);
	int cur = 1;
	for (int i = 0; i < str.size(); ++i) {
		if (i % BASE == 0)
			cur = 1;
		digits[i / BASE] += cur * (str[i] - '0');
		cur *= 10;
	}
	trim();
}

UnsignedDigit pow(UnsignedDigit x, int k) {
	UnsignedDigit ret = 1;
	while (k) {
		if (k & 1)
			ret = ret * x;
		if (k >>= 1)
			x = x * x;
	}
	return ret;
}

int main() {
	int m;
	cin >> m;
	string s;
	cin >> s;
	if (s == "0") {
		cout << "0" << endl;
		return 0;
	}
	if (m == 1) {
		cout << s << endl;
		return 0;
	}
	UnsignedDigit n(s);
	UnsignedDigit x(min(n, UnsignedDigit(MOD - 1).move((n.size() + m - 1) / m - 1))), xx;
	{
		int top = x.size() - 1;
		int l = 0, r = MOD - 1;
		while (l < r) {
			int mid = (l + r) / 2;
			x.digits[top] = mid;
			if (pow(x, m) <= n)
				l = mid + 1;
			else
				r = mid;
		}
		x.digits[top] = l;
		x.trim();
	}
//cerr << x.toString() << endl;
	xx = (x * (m - 1) + n / pow(x, m - 1)) / m;
	while (xx < x) {
//		cout << xx.toString() << endl;
		swap(x, xx);
		xx = (x * (m - 1) + n / pow(x, m - 1)) / m;
	}
	cout << x.toString() << endl;

	return 0;
}
```

---

## 作者：TBB_Nozomi (赞：23)

受上面dalao的启发，这里给出一个复杂度为$\Theta(mn\log mn)$，但是理论常数小的方法，其中$n$是输入的大整数的位数。

这里需要一些前置知识。基于著名的2012年WC的《理性愉悦：高精度数值计算》，我们可以得到在最大位数为$n$时基于牛顿迭代法的$\Theta(n\log n)$的高精度乘法运算。前面的EntropyIncreaser大佬根据函数$f(x)=x^m-A$得到了迭代方程解$x_{k+1}=\left\lfloor{\dfrac{(m-1)x_k+\lfloor{}n/x_k^{m-1}\rfloor}{m}}\right\rfloor$。然而这个实现需要依靠一个有辅助函数且常数不小的$\Theta(n\log n)$的高精度除法运算。其实这个实现不算难，但是其中可能会引入一些由高精度除法所带来的误差，具体的误差可能有点难分析。

另外就是经过计算，容易知道结果为$n$的高精度快速幂的时间复杂度为严格的$\Theta(n\log n)$，同时这也是本题的算法理论下限。

存不存在不需要借助高精度除法的计算方式呢？存在的。在上面文档的后面有一个不需要借助高精度除法的高精度开平方的实现算法，时间复杂度为$\Theta(n\log n)$。基于这个方法，可以来考虑一下对应的高精度开$m$次方的方法。

对于给定的$A$，我们考虑迭代计算
$$B=\dfrac{p^{mk}}{A^{\frac{m-1}{m}}}$$
的值，计算出来后对$\frac{AB}{p^{mk}}$做个常数级的调整就好。在这里，$p$表示高精度的进制数，而$A$的位数限制在$m(k-1)$和$mk$之间，也就是$k=\left\lceil\frac{n}{m}\right\rceil,n=mk-\alpha$。

为得到这个，考虑函数
$$f(x)= \frac{1}{x^m}- \frac{A^{m-1}}{p^{m^2k}}$$
并对之使用牛顿迭代法，得到迭代方程
$$B= \frac{m+1}{m}B_0- \frac{A^{m-1}B_0^{m+1}}{mp^{m^2k}}$$
这个迭代方程中所用的所有除法，除了除以$m$用$\Theta(n)$的高精度除单精度除法以外，除以$p^{m^2k}$可以直接用移位来实现，复杂度也不会超过$\Theta(n)$。

怎样计算迭代出$B$？除去暴力反复迭代以外也有别的实现方法，在这里采用同文档上一致的方式。取$i<k, r=mi-\alpha$，再设$A_i$为$A$的前$r$位。如果我们能够得到$A_i$对应的$B_i$，那么对$B_i$做出调整，就能够作为迭代出$A$对应的$B$的初始值。

假设我们已经得到了$B_i$的值，由
$$\boxed{B_i=\frac{p^{mi}}{A^\frac{m-1}{m}}=\frac{p^{mk}}{(A_ip^{m(k-i)})^{\frac{m-1}{m}}}\frac{1}{p^{k-i}}\approx\frac{p^{mk}}{A^{\frac{m-1}{m}}}\frac{1}{p^{k-i}}=B}$$
可以知道在得到$B_i$以后作个补零/移位即可以得到计算$B$用的近似初始值

怎么取$i$值？对于每个$k$，我们可以取$i=\left\lfloor\frac{k+1}{2}\right\rfloor$，并且在$k=2$的时候做二分暴力估算$B=\frac{p^{mk}}{A^{\frac{m-1}{m}}}\approx\sqrt[m]{A}p^{mk}/A$。注意为了避免大的误差，我们避免进入$k=1$的情况，并且为避免死循环，在$k\leq2$的时候直接暴力二分计算$\sqrt[m]{A}$。

下面进行误差分析（也是最难整理的部分）。首先我们将用于迭代的函数$f(x)= \frac{1}{x^m}- \frac{A^{m-1}}{p^{m^2k}}$进行归一化，只研究它的相对误差变化
$$f_0(x)=\frac{1}{x^\alpha}-1\qquad (\alpha>=1)$$
对这个函数在$x<1$的时候做牛顿迭代法（$x>1$的时候做牛顿迭代法会让第一次迭代的误差变大）
$$x=g(x_0)=x_0-\frac{f_0(x_0)}{f_0'(x_0)}=\frac{\alpha+1}{\alpha}x_0-\frac{{x_0}^{\alpha+1}}{\alpha}$$
考虑计算相对误差函数$1-x$，我们有
$$\lim\limits_{x\to1}\frac{1-g(x)}{(1-x)^2}=\lim\limits_{x\to1}\frac{(\alpha+1)x^{\alpha-1}}{2}=\frac{\alpha+1}{2}<+\infty$$
这个计算过程是一些人最喜欢的洛必达法则，因而省略不讲。但由上面这个式子可以看到，类似于$f(x)=\frac{1}{x^\alpha}-A$的函数，其迭代是二阶收敛的，也就是说如果起始值的有效数位是解的有效数位的一半以上，那么理论上只需要一次迭代误差就会小于1，也就不再需要更多的调整就能达到目标数。这也是为什么强调要使用$i>n/2$，因为这样在大多数情况下可以避免嵌套时的调整。

然而，这里还有两个误差。第一个容易处理的误差是由于整数存储造成的省略误差。这个误差处理不处理都没有太大关系，可以看作由迭代计算中自动的消除掉。另外一个误差其实是迭代前确定初始值时的误差。考虑上面那个带框的计算中的
$$\frac{p^{mk}}{(A_ip^{m(k-i)})^{\frac{m-1}{m}}}\frac{1}{p^{k-i}}\approx\frac{p^{mk}}{A^{\frac{m-1}{m}}}\frac{1}{p^{k-i}}$$
这里有个不严谨的地方：那个约等于号实际上是大于号。这是因为计算$B_i$是相当于把分母中的$A$末尾的数字全部抹为0，导致分母变小，整体将大过根$B$。为避免这一问题，可以考虑将从下层传递回来的$B_i$向小的方向进行调整，使调整后的$B_i$比正解小，适合作为初始值进行迭代。

复杂度分析：设位数为$n$，开根数为$m$的时间复杂度为$T(n,m)$，考虑每一层复杂度最高的部分是计算$A^{m-1}B_0^{m+1}$，这个部分最多是$\Theta(nm)$位的， 所以时间复杂度递推公式为
$$T(n,m)=\Theta(nm\log nm)+T\left(\frac{n}{2},m\right)$$
可以解得
$$T(n,m)=\Theta(nm\log nm)$$
比较要命的是空间复杂度$\Theta(nm)$，一般的题目没什么，然而这个题目的空间限制是${\color{red}125kb}$，这个其实有点要命，比如说FFT里面预处理单位根或者是计算临时变量$A^{m-1}B_0^{m+1}$之类的都有可能会爆掉这个空间限制，所以这个方法需要多压位。

附上~~垃圾~~自写代码

```cpp
#ifndef TBBLINT_H
#define TBBLINT_H
#include <iostream>	//LInt.h version:2.4.1
//头文件省略
typedef unsigned long long u64;
typedef long long i64;
typedef unsigned u32;
namespace tbb	{
	const double Pi= 3.14159265358979323846;
	//using std::cin...
	void Fast_out(u32 a)	{
		if(a==0) {
			putchar('0');
			return;
		}
		if(a>9) {
			Fast_out(a/10);
			putchar('0'+a%10);
		} else	putchar('0'+a);
	}
	inline void Fast_0_out(u32 a, int len= 4)	{
		if(len>=2)	if(a<10)	putchar('0');
		if(len>=3)	if(a<100)	putchar('0');
		if(len>=4)	if(a<1000)	putchar('0');
		Fast_out(a);
	}
	int Log_2(int base) {
		int i;
		for(i=0; ((1<<i)<base) & (i<32) ;i++);
		return i;
	}
	// template<typename T, size_T> FFT(const std::array<T, N> &X, bool flag) {
	std::vector<std::complex<double> > FFT(const std::vector<std::complex<double> > &X, bool flag) {
		//flag -> inverse flag
		using std::complex;
		using std::vector;
		typedef complex<double> cmxd;
		int L=X.size();
		if(L==1)	return X;
		static const int vol= 262144;
    	static bool pre_init= true;
    	static cmxd root[vol+1];
		if(pre_init)    {
        	for(int i=0; i<=vol; i++) root[i]= exp(cmxd(0, 2*Pi/vol*i));
        	pre_init= false;
    	}
		int* rev;   rev= new int [L];	rev[0]= 0, rev[1]= L/2;
    	{for(int i=2; i<L; i++)  rev[i]=(rev[i&1])|(rev[i>>1]>>1);}
		vector< complex<double> > A(L);
		for(int i=0; i<L; i++)	A[i]= X[rev[i]];
		for(int size=2; size<=L; size<<=1)	{
			for(int k=0; k<L; k+=size)	{
				for(int i=0; i<size/2; i++)	{
					cmxd R= (!flag)? root[vol/size*i]: root[vol- vol/size*i];
					cmxd p= A[k+i], q= A[k+size/2+i]* R;
					A[k+i]= p+q;	A[k+size/2+i]= p-q;
				}
			}
		}
		if(flag)    for(int i=0; i<L; i++)  A[i]/=L;
		delete rev;
		return A;
	}
	inline int s2i(const char *begin, const char *end) {//converse string to int
		int tmp= 0, sig= 1;
		if(*begin=='+'||*begin=='-')	sig= (*(begin++)=='+')?1:-1;
		for(const char *t= end-1; t>= begin; t--)	tmp= tmp*10+ (*t-'0');
		return tmp*sig;
    }
	struct LInt	{
	//elements
		short sign;
		int d;
		u32 *num;
	//define function/initial
		LInt (void ):sign(0),d(0),num(0){}
		LInt (bool b, int code= 0):sign(0),d(0)	{
			if(b)	{num=new u32[0];}
			else	{
				num= 0;
				if(code== 1)	sign= 2;
				if(code== -1)	sign= -2;
			}
		}
		//本题中用不到的转换函数
		LInt (const char* inString)	{
			int i, len;
			bool flag=true, minus=false;
			if(inString[0]=='-')	{minus=true; inString++;}
			else	if(inString[0]=='+')	{minus=false;	inString++;}
			len=strlen(inString);
			//check string is +/- inf whether or not
			if(strcmp(inString, "inf")==0)	{sign= minus? -2: 2;	d=0;	num=0;	return ;}
			//check string is full of numbers or not
			for(i=0; i<len&&flag; i++)	flag= flag&&('0'<=inString[i]&&inString[i]<='9');
			if(!flag||len== 0)	{d=sign=0;	num=0; return ;}
			//ignore all 0 at the begin of string
			for(; *inString=='0'; inString++, len--);
			if(*inString=='\0')	{d=sign=0;	num= new u32[0]; return ;}
			//string is a normal number
			d= (len+3)/4;	num= new u32[d]();
			sign= minus? -1: 1;
			int j, temp;
			for(temp=0, i=len, j=0; j<len; j++)	{
				temp= temp*10 + inString[j]-'0';
				i-=1;
				if(i%4==0)	num[i/4]= temp, temp= 0;
			}
		}
		LInt (const string &inString_):num(0)	{
			*this= inString_.c_str();
		}
		LInt (const LInt &A):sign(A.sign), d(A.d)	{
			num= new u32[d];
			for(int i=0; i<d; i++)	num[i]= A.num[i];
		}
		LInt (const u32 *inNum, int k):sign(1){
			while(k>0 && inNum[k-1]==0)	k--, inNum++;
			d=k;	num= new u32[k];
			memset(num,0,k*sizeof(u32));
			for(int i=0; i<k; i++)	num[i]= inNum[i];
			this->sho();
		}
	//undo function
		virtual ~LInt() {if(num!=0)	delete[] num;}
	//assignment operator
		LInt & operator=(const LInt &B)	{
			sign=B.sign;	d=B.d;
			if(num!=0)	delete[] num;
			if(B.isNaN())	num= 0;
			else	{num= new u32[d];	for(int i=0; i<d; i++)	num[i]=B.num[i];}
			return *this;
		}
		LInt & operator=(const char *inString) {
			LInt temp(inString);
			d= temp.d; sign= temp.sign;
			if(num!=0)	delete[] num;
			num= temp.num; temp.num=0;
			return *this;
		}
		inline LInt & operator=(bool b)  {return *this=LInt(b);}
        inline LInt & operator=(int i)  {return *this= LInt(i);}
		inline LInt & operator=(i64 i)	{return *this= LInt(i);}
		inline LInt & operator=(u64 u)	{return *this= LInt(u);}
	//compare operator
		bool operator<(const LInt &B) const	{

			const LInt &A= *this;
			if(A.isNaN()||B.isNaN())	return false;
			if(A.sign<B.sign)	return true;
			if(A.sign>B.sign)	return false;
			if(sign==2||sign==-2||sign==0)	return false;
			if(sign==-1)	{
				if(A.d!=B.d)	return !(A.d<B.d);
				for(int i=d-1; i>=0; i--)	if(A.num[i]!=B.num[i])	return !(A.num[i]<B.num[i]);
				return false;
			}
			if(sign==1)	{
				if(A.d!=B.d)	return A.d<B.d;
				for(int i=d-1; i>=0; i--)	if(A.num[i]!=B.num[i])	return A.num[i]<B.num[i];
				return false;
			}
			return false;
		}
		//这里是大小比较的代码，省略了
	//functions
		LInt abs()	const {
			LInt ans(*this);
			if(ans.sign<0)	ans.sign=-ans.sign;
			return ans;
		}
		inline LInt abs(const LInt &b) const	{return b.abs();}
		void sho()	{
			if(sign==2||sign==-2)	{
				d=0;
				if(num!=0)	{delete[] num;	num=0;}
				return ;
			}
			if(sign==0)	{
				d=0;
				if(num!=0)	{delete[] num;	num= new u32[0];}
				return ;
			}
			int i=this->d-1;
			while(i>=0&&num[i]==0)	i--;
			if(i<0)	{
				if(num)	delete[] num;
				num=new u32[0];	sign=d=0;
				return;
			}
			this->d=i+1;
			u32 *pre=this->num;
			num=new u32[this->d];
			for(int j=0; j<this->d; j++)	num[j]=pre[j];
			delete [] pre;
			return;
		}
		void print() const	{
			if(sign==2||sign==-2)	{
				if(sign==-2)	putchar('-');
				printf("inf");
				return ;
			}
			if(sign==0)	{
				if(num==0)	printf("NaN");
				else	putchar('0');
				return;
			}
			if(sign==-1)	putchar('-');
			Fast_out(num[d-1]);
			for(int i=d-2; i>=0; i--)	Fast_0_out(num[i]);
		}
		string print_str()	const	{
			if(sign==0)	return num==0?string("NaN"):string("0");
			if(sign==2||sign==-2)	return sign==-2?string("-inf"):string("inf");
			string ans(0);
			if(sign==-1)	ans+='-';
			ans+=num[d-1];
			for(int i=d-2; i>=0; i--)	{
				if(num[i]<10)	ans+='0';
				if(num[i]<100)	ans+='0';
				if(num[i]<1000)	ans+='0';
				ans+=num[i];
			}
			return ans;
		}
		inline bool isNaN()	const	{return (num==0)&&(d==0)&&(sign==0);}
		inline bool positive()	const	{return sign>0;}
		inline bool negative()	const	{return sign<0;}
		inline bool isinf()	const	{return sign==2||sign==-2;}
		inline bool zero()	const	{return sign==0&&num!=0;}
		inline bool meanless()	const	{return isNaN()||isinf();}
		inline bool abnormal()	const	{return zero()||isinf()||isNaN();}
		friend void swap(LInt &A, LInt &B)	{
			int temp_d; short temp_sign;	u32* temp_num;
			temp_d= A.d;	A.d= B.d;	B.d= temp_d;
			temp_sign= A.sign;	A.sign= B.sign;	B.sign= temp_sign;
			temp_num= A.num;	A.num= B.num;	B.num= temp_num;
		}
	private://get 10000^2d/A while A >=0
		//这里是辅助计算除法的代码，省略了
	public:
		//特别地，对除2进行优化，然而本题用不上
	//Operator Function
		const LInt operator<<(int k) const {
			if(abnormal())	return *this;
			if(k<0)	return LInt(false);
			if(*this==0)	return LInt(0);
			LInt ans(false);
			u32 *_num = new u32[d+k]();
			for(int i=0; i<d; i++)	_num[i+k]=num[i];
			ans.num=_num;	ans.d=d+k;	ans.sign=sign;
			return ans;
		}
		const LInt operator>>(int k) const {
			if(abnormal())	return *this;
			if(k<0)	return LInt(false);
			if(d<=k)	return LInt(0);
			LInt ans(false);
			u32 *_num = new u32[d-k];
			for(int i=0; i<d-k; i++)	_num[i]=num[i+k];
			ans.num=_num;	ans.d=d-k;	ans.sign=sign;
			return ans;
		}
		//这里是加减和前置负号的实现代码，省略了
		const LInt operator*(const LInt &B) const {
			const LInt &A= *this;
			if(A.isNaN()||B.isNaN())	return false;
			if((A.zero()&&B.isinf())||(A.isinf()&&B.zero()))	return false;
			if(A.isinf())	return (B.sign>0)?A:-A;
			if(B.isinf())	return (A.sign>0)?B:-B;
			if(A.zero()||B.zero())	return 0;
			using std::complex;
			using std::vector;
			LInt ans;
			int x,y;
			int N=1<<(Log_2(A.d+B.d-1));
			ans.d=N+2;	ans.num= new u32[ans.d]();
			ans.sign=A.sign*B.sign;
			vector< complex<double> > pA(N,0),aA(N,0);
			for(x=0;x<A.d;x++)	pA[x].real(A.num[x]);
			for(y=0;y<B.d;y++)	pA[y].imag(B.num[y]);
			aA=FFT(pA,false);
			for(int i=0; i<N; i++)	aA[i]*= aA[i];
			pA=FFT(aA,true);
			double carry=0.0;
			for(int i=0; i<N; i++)	{
				double temp=round(pA[i].imag()/2+carry);
				carry=round(temp/10000);
				int base=(int)round(temp-carry*10000);
				if(base<0)	base+=10000,carry-=1.0;
				ans.num[i]=base;
			}
			ans.num[N]=unsigned(carry);
			ans.sho();
			return ans;
		}
		const LInt operator/(int B) const	{
			if(B==2)	return this->div2();
			const LInt &A= *this;
			if(A.isNaN())	return false;
			if(A==0&&B==0)	return false;
			if(A==0)	return 0;
			if(B==0)	return A.positive()?"inf":"-inf";
			if(A.isinf())	return (B>=0)?A:-A;
            
			LInt ans;	ans.d=d;
			ans.sign= A.sign* (B>0?1:-1);
			ans.num= new u32[d]();
			u32 abs_B=(B<0?-B:B);	u64 temp=0;
			for(int i=d-1; i>=0; i--)	{
				temp*= 10000;
				temp+= num[i];
				ans.num[i]= temp/abs_B;
				temp%= abs_B;
			}
			ans.sho();
			return ans;
		}
		//这里是除法的实现代码，但我省略了
		//这里是求余数的实现代码，但我省略了
		//这里是操作后赋值代码，省略了
		//这里是自增和自减的代码，省略了
		inline u32 & operator[](int k) const	{
			return num[k];
		}
	//Friend Function for Other Classical Class
		friend LInt operator+(int A, const LInt &B)	{
			return B+LInt(A);
		}
		friend LInt operator-(int A, const LInt &B)	{
			return -B+LInt(A);
		}
		friend LInt operator*(int A, const LInt &B)	{
			 return B*A;
		}
		friend std::ostream & operator<<(std::ostream &os, const LInt &A)	{
			if(A.sign==0)	{
				if(A.num==0)	os.write("NaN",3);
				else	os.put('0');
			}	else	{
				if(A.sign<0)	os.put('-');
				if(A.isinf())	os.write("inf",3);
				else	{
					os<<A.num[A.d-1];
					for(int i=A.d-2; i>=0; i--)	{
						if(A.num[i]<10)	os.put('0');
						if(A.num[i]<100)	os.put('0');
						if(A.num[i]<1000)	os.put('0');
						os<<A.num[i];
					}
				}
			}
			return os;
		}
		friend std::istream & operator>>(std::istream &is, LInt &A)	{
			using std::isdigit;
			is>>std::ws;
			{
				if(is.peek()==-1)	{is.setstate(std::ios_base::eofbit);	A= 0;	return is;}
				if(!is)	{is.setstate(std::ios_base::failbit);	A= 0;	return is;}
				char t= is.peek();
				while(t!='-'&&!isdigit(t)&&t!=-1)	{
					is.get();	t= is.peek();
				}
				if(t==-1)	{is.setstate(std::ios_base::failbit);	A= 0;	return is;}
			}
			char sign= is.peek();
			if(sign=='-'||sign=='+')	is.get();
			else	sign= '0';
			// NaN or inf?	//No. Like the input of float, refuse NaN
			//just no any suitable input?
			if(!isdigit(is.peek()))	{
				if(sign=='+'||sign=='-')	is.unget();
				A= 0;	is.setstate(std::ios_base::failbit);
				return is;
			}
			string in_s(1, sign);
			while(isdigit(is.peek()))	in_s+= is.get();
			A= in_s;
			return is;
		}
	// converse to other classical type
	#if __cplusplus >= 201103L
		explicit operator bool() const	{
			return isinf()||isNaN();
		}
		explicit operator int()	const	{
			int temp= 0;
			for(int i=0; i<d ;i++)	temp= temp* 10000+ num[i];
			if(sign<0)	temp= -temp;
			return temp;
		}
	#endif
	};
	//这里是以10为底的乘法代码，省略了
}
#endif
// #define debug
#ifdef debug
#include "LFloat.h"
#endif

#ifndef TBBLMAT_H //LMath.h ver:3.1.1
#define TBBLMAT_H
namespace tbb {
    const LInt powrt(const LInt&, int);
    LInt abs(const LInt &B)	{
		LInt ans(B);
		if (B.sign<0) ans.sign=-B.sign;
		return ans;
	};
    //get 10000^2k/sqrt(A) when A has 2k or 2k-1 bits
    //这里是计算sqrt和对应的辅助函数的代码，省略了
    const LInt pow(const LInt &A, int k)  {
        if((A==0&&k==0)||A.isNaN())  return false;
        if(A.isinf()&&k>=0)   {
            if(k==0)    return false;
            if(A.sign==2&&k>0)   return A;
            return (k%2==0)?(-A):A;
        }
        if(k<0)    return 0;
        if(k==0||A==1)    return LInt(1);
        if(A.num[0]==0) {
            int lnz=0;  //lnz=the lower bit where is not 0
            for(lnz=0; lnz<A.d&&A.num[lnz]==0; lnz++);
            return pow(A>>lnz,k)<<(lnz*k);
        }
        LInt S= 1, temp= A;
        for(int i=1; i<=k; i<<=1)   {
			temp= (i==1)?A: temp*temp;
            if(i&k) S*= temp;
        }
        return S;
    }
	int cmp(const LInt &lhs, int m)	{
		if(lhs.d<=m)	return -1;
		if(lhs.d>m+1)	return 1;
		for(int i=0; i<m; i++)	if(lhs[i]>0)	return 1;
		return (lhs==1)? 0: 1;
	}
    inline const LInt recip_m(const LInt &A, int m)    {
        if(A.abnormal())    return A;
        int n= (A.d+m-1)/m;
		if(n<=2)  return (powrt(A, m)<<(n*m))/A;
        int k= n/2+1;
        LInt Ak(A.num+m*(n-k), A.d-m*(n-k));
        LInt _Ak= recip_m(Ak, m)-1;
		_Ak-=_Ak>>(A.d-1);	_Ak<<= n-k;
        LInt _AN= pow(A, m-1);
        LInt _A= (m+1)*_Ak/m- ((_AN* pow(_Ak, m+1)/ m)>>(n*m*m));
        LInt delta= 1;
        if(cmp(_AN* pow(_A, m), n*m*m)==-1)   for(;;delta*=2)    {
            LInt _Ap= _A+ delta;
            if(cmp(_AN* pow(_A, m), n*m*m)==1)  break;
            swap(_A, _Ap);
        }   else    for(;;delta*=2)    {
            _A-= delta;
            if(cmp(_AN* pow(_A, m), n*m*m)<=0)  break;
        }
        do {
            delta/=2;
            LInt _Ap= _A+ delta;
            if(cmp(_AN* pow(_A, m), n*m*m)==1)  continue;
            swap(_A, _Ap);
        } while(delta>0);
        return _A;
    }
    const LInt powrt(const LInt &A, int m)  {
        if(A.isNaN()||m<=0)   return false;
        if(A.zero())    return 0;
        if(A.negative()&&m%2==0)  return false;
        if(A.isinf()) return A;
        if(A.negative()&&m%2==1)    return -powrt(-A, m);
        if(A==1)    return 1;
        if(A.d<=2*m)  {
            int up= 100000000, down= 1, mid= (up+down)/2;
            while(up-down>1) {
                LInt a= pow(LInt(mid), m);
                if(a==A)    return mid;
                (a<A? down: up)= mid;
                mid= (up+down)/2;
            }
            return down;
        }
        int n= (A.d+m-1)/m;
        LInt ans= (A* recip_m(A, m))>>(n*m);
        LInt delta= 1;
        for(delta=1; ; delta*=2)  {
            if(pow(ans+delta, m)>A) break;
            ans+= delta;
        }
        for(;delta>0 ; delta/=2)   {
            if(pow(ans+delta, m)>A) continue;
            ans+= delta;
        }
        return ans;
    }
    //最大公约数和最小公倍数的实现代码，省略了
    #ifdef TBBLFLT_H
        const LFloat sqrt(const LFloat& A) {
            if(A.negative()) return LFloat(LInt(false), 0);
            if(A.abnormal()) return A;
            const int n= tbb::_LFloat_prec;
            LInt u= A.base; i64 t= A.pow;
            t-=(2*n-u.d);   u<<=(2*n-u.d);
            if(t%2!=0)  t++, u>>=1;
            return LFloat(sqrt(u), t/2);
        }
    #endif
}
#endif
#include <iostream>	//version:2.3
//其它头文件省略
#define SHOW	putchar('s')
#define EL	putchar('\n')
using namespace tbb;
using namespace std;
int main()	{
	LInt A;	int k;
	cin>>k>>A;
	cout<<powrt(A, k)<<endl;
	return 0;
}

```


---

## 作者：巨型方块 (赞：23)

思路就是二分+快速幂；

这是我的非重载运算符的高精模版

http://blog.csdn.net/largecub233/article/details/57410304

如果失效了说明我更新模版了，可以到我博客里找；

我的博客：http://blog.csdn.net/largecub233

没写全，我会完善的（比如负数）；

如果上面的程序有问题，请告诉我；

目前fop\_zz已经发现了我高精模版的一个bug感谢；

然后对于这道题，毒瘤题；

一定要高精压位；

我压1e9的；用unsigned long long 存；

大家不要这样。1e8就好了；

什么是压位；

比如一个数；

123456789

我压4位；就是

6789、、

2345、、

1、、

这样运算，会比十进制快；

比如
12000078

压好就是

78、、

1200、、

所以我们输出时要搞好前导0；

输出前导0还要特判本身就是0的情况；

然后，


```cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<cstring>
#define Ll unsigned long long
using namespace std;
const Ll NN=1e9;
const int N=9;
struct H{
    Ll a[1500],len;
    H(){memset(a,0,sizeof a);len=1;}
};
int n;
H s;
void init(H &a){//读入 
    string s; cin>>s; 
    int l; 
    a.len=0;
    for(int r=s.length()-1;r>=0;r-=N){
        a.len++;                      
        if(r>=N-1)l=r-N+1;else l=0;
        for(int i=l;i<=r;i++)a.a[a.len]=a.a[a.len]*10+s[i]-48;
    }
}  
void outit(H a){//输出 
    printf("%d",a.a[a.len]);
    for(int i=a.len-1;i;i--){
        for(int k=NN/10;a.a[i]<k;k/=10)printf("0");
        if(a.a[i])printf("%d",a.a[i]); 
    }printf("\n");    
}
void in(H &a,int x){//赋值 
    if(!x)return;
    a.len=0;
    while(x){a.a[++a.len]=x%NN;x=x/NN;}
}
bool bigD(H a,H b){//比较是否大于等于 
    if(a.len>b.len)return 1;
    if(a.len<b.len)return 0;
    for(int i=a.len;i;i--)
        if(a.a[i]!=b.a[i])
            if(a.a[i]>b.a[i])return 1;else return 0;
    return 1;
}
H jia(H a,H b){//加法 
    H c;
    int l=max(a.len,b.len);
    for(int i=1;i<=l;i++){
        c.a[i]+=a.a[i]+b.a[i];
        c.a[i+1]=c.a[i]/NN;
        c.a[i]%=NN;
    }
    if(c.a[l+1])l++;
    c.len=l;
    return c;
}
H chu(H a){//除法 
    H c;
    if(a.len==1){c.a[1]=a.a[1]>>1;return c;}
    for(int i=a.len;i;i--){
        if(a.a[i]&1ll)a.a[i-1]+=NN;
        c.a[i]=a.a[i]>>1;
    }
    if(c.a[a.len])c.len=a.len;else c.len=a.len-1;
    return c;
}
H rrr(H a){//-1操作 
    if(a.len==1){
        a.a[1]--;return a;
    }
    H c=a;
    c.a[1]--;
    int l=1;
    while(c.a[l]<0){
        c.a[l]=NN-1;
        c.a[++l]--;
    }
    if(!c.a[c.len])c.len--;
    return c;
}
H chen(H a,H b){//乘法 
    H z;
    z.len=a.len+b.len+2;
    for(int i=1;i<=a.len;i++)
    for(int j=1;j<=b.len;j++)z.a[i+j-1]+=(a.a[i]*b.a[j]);
    for(int i=1;i<=z.len;i++)z.a[i+1]+=z.a[i]/NN,z.a[i]%=NN; //取mo慢，放到外面取   
    while(z.len>1&&!z.a[z.len])z.len--;
    return z;
}
H ksm(H a,int n){//快速幂 
    if(n==1)return a;
    H c=ksm(a,n>>1);
    c=chen(c,c);
    if(n&1)c=chen(c,a);
    return c;
}
bool Chu(H a){//本来这个函数名是骂出题人的，怕和谐，就改了 
    if(a.len*n-n+1>s.len)return 0;
    if(bigD(s,ksm(a,n)))return 1;
    return 0;
}
int main(){
//    freopen("calc.in","r",stdin);
//    freopen("calc.out","w",stdout);
    scanf("%d",&n);
    init(s);
    if(n==1){outit(s);return 0;}
    H l,r,mid,ans;
    in(l,1);
    r=s;
    while(bigD(r,l)){
        mid=jia(l,r);
        mid=chu(mid);
        if(Chu(mid)){
            if(bigD(mid,ans))ans=mid;
            H c;
            in(c,1);
            l=jia(mid,c);
        }else r=rrr(mid);         
    }
    outit(ans);
}

```

---

## 作者：_SupremeLiYebin_QwQ_ (赞：21)

大家想的好复杂，有没有一种方法把 py 和 C++ 兼容呢？

解释下代码。我们运用 ``echo`` 语句，将输入视为一个字符串，运用转义字符，有 py 党的朋友看出来我们变量 c 的值除了 echo、转义字符外，就是平常的 py 代码。我们把它发到终端，然后读取输出。``c_str()`` 是 Borland 封装的String类中的一个函数，它返回当前字符串的首字符地址。 这个函数主要用于将 C++ 的 string 对象转换为 C 风格的字符串，即生成一个指向以空字符终止的数组的 const char* 指针。这个指针指向的内容与 string 对象中的内容相同，但需要注意的是，这个指针是只读的，不能对其进行修改操作。这是因为 ``c_str()`` 返回的指针指向的是 string 内部的一个临时缓冲区，一旦有修改 string 内容的操作发生，这个临时缓冲区的内容就会失效。

echo 是一种语法，不是函数，所需值固定为 string 类型，这就是为什么本蒟蒻要重新交审。

其次，由于 dev 年久失修，不支持这种高科技。

~~歪解~~创新解法如下：

```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
using namespace std;
using namespace __gnu_cxx;

string a,b,c;
main(){
	ios::sync_with_stdio(0),cin.tie(nullptr);
	cin>>a>>b;
	string c="echo \"import sys;sys.set_int_max_str_digits(100001);exec(\'\'\'a=int("+a+");b=int("+b+");l=0;r=1;\nwhile(r**a<=b):\n    l=r;r=r*2\nwhile(l+1<r):\n    mid=(l+r)//2\n    if(mid**a<=b):\n        l=mid\n    else:\n        r=mid\nif(l**a<=b):\n    print(l)\nelse:\n    print(r)\'\'\')\" | /nix/var/nix/profiles/judge_python3-c/bin/python";
	system(c.c_str());	
}
```
[关于 echo 较好理解的教程。](https://www.cnblogs.com/RXDXB/p/13355152.html)


[摘自度娘。](https://baike.baidu.com/item/echo/35157?fr=ge_ala)

---

## 作者：xukuan (赞：13)

## 二分答案+高精度+卡常

一开始裸的高精，时间复杂度$O(m\log_{10}^2n\log_2n)$只有40分

代码：
```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;

const ll N=20010;
ll m;
struct bignum{
	ll len,num[N];
	bignum(){len=0; memset(num,0,sizeof(num));}
}n,one,zero,ans;

inline bignum read(){
	bignum ans;
	string s; cin>>s;
	for(ll i=0; i<s.size(); i++) ans.num[s.size()-i]=s[i]-48;
	ans.len=s.size();
	return ans;
}

inline void write(bignum s){
	for(ll i=s.len; i>=1; i--) putchar(s.num[i]+48);
}

inline void operator ==(bignum &a,ll b){
	for(; b; b/=10) a.num[++a.len]=b%10;
}

inline bool operator <=(bignum a,bignum b){
	if(a.len>b.len) return 0;
	if(a.len<b.len) return 1;
	for(ll i=a.len; i>=1; i--){
		if(a.num[i]>b.num[i]) return 0;
		if(a.num[i]<b.num[i]) return 1;
	}
	return 1;
}

inline bool operator >(bignum a,bignum b){
	if(a.len>b.len) return 1;
	if(a.len<b.len) return 0;
	for(ll i=a.len; i>=1; i--){
		if(a.num[i]>b.num[i]) return 1;
		if(a.num[i]<b.num[i]) return 0;
	}
	return 0;
}

inline bignum operator +(bignum a,bignum b){
	bignum c;
	c.len=max(a.len,b.len);
	for(ll i=1; i<=c.len; i++){
		c.num[i]+=a.num[i]+b.num[i];
		c.num[i+1]+=c.num[i]/10;
		c.num[i]%=10;
	}
	if(c.num[c.len+1]) c.len++;
	return c;
}

inline bignum operator -(bignum a,bignum b){
	bignum c;
	c.len=a.len;
	for(ll i=1; i<=c.len; i++){
		c.num[i]=a.num[i]-b.num[i];
		if(c.num[i]<0){
			c.num[i]+=10;
			a.num[i+1]--;
		}
	}
	while(c.len>1&&c.num[c.len]==0) c.len--;
	return c;
}

inline bignum operator *(bignum a,bignum b){
	bignum c;
	for(ll i=1; i<=a.len; i++){
		for(ll j=1; j<=b.len; j++){
			c.num[i+j-1]+=a.num[i]*b.num[j];
			c.num[i+j]+=c.num[i+j-1]/10;
			c.num[i+j-1]%=10;
		}
	}
	c.len=a.len+b.len;
	while(c.len>1&&c.num[c.len]==0) c.len--;
	return c;
}

inline bignum operator /(bignum a,ll b){
	ll sum=0; bignum c;
	for(ll i=a.len; i>=1; i--){
		sum=sum*10+a.num[i];
		c.num[i]=sum/b;
		sum%=b;
	}
	c.len=a.len;
	while(c.len>1&&c.num[c.len]==0) c.len--;
	return c;
}

inline bool check(bignum a,ll b){
	bignum ans=one;
	for(ll i=1; i<=b; i++){
		ans=ans*a;
		if(ans>n) return 0;
	}
	return 1;
}

int main(){
	cin>>m; n=read();
	one==1; zero==0;
	bignum l=one,r=n;
	while(l<=r){
		bignum mid=(l+r)/2;
		if(check(mid,m)){
			ans=mid;
			l=mid+one;
		}
		else r=mid-one;
	}
	write(ans);
	return 0;
}
```

时间复杂度的大头是在高精度乘法上

最快的高精乘法是什么？FFT！

我加了FFT优化高精度乘法，时间复杂度优化到了$O(m\log_{10}n \log_2 n \log_{2}\log_{10}n)$，满心以为这次能过，结果。。。还是只有40分

代码：

```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;

const ll N=20010;
const double pi=acos(-1);
ll m;
struct bignum{
	ll len,num[N];
	bignum(){len=0; memset(num,0,sizeof(num));}
}n,one,zero,ans,c;

inline void clear(bignum &a){
	memset(a.num,0,sizeof(a.num));
	a.len=0;
}

inline bignum read(){
	bignum ans;
	string s; cin>>s;
	for(ll i=0; i<s.size(); i++) ans.num[s.size()-i]=s[i]-48;
	ans.len=s.size();
	return ans;
}

inline void write(bignum s){
	for(ll i=s.len; i>=1; i--) cout<<s.num[i];
}

inline void operator ==(bignum &a,ll b){
	for(; b; b/=10) a.num[++a.len]=b%10;
}

inline bool operator <=(bignum a,bignum b){
	if(a.len>b.len) return 0;
	if(a.len<b.len) return 1;
	for(ll i=a.len; i>=1; i--){
		if(a.num[i]>b.num[i]) return 0;
		if(a.num[i]<b.num[i]) return 1;
	}
	return 1;
}

inline bool operator >(bignum a,bignum b){
	if(a.len>b.len) return 1;
	if(a.len<b.len) return 0;
	for(ll i=a.len; i>=1; i--){
		if(a.num[i]>b.num[i]) return 1;
		if(a.num[i]<b.num[i]) return 0;
	}
	return 0;
}

inline bignum operator +(bignum a,bignum b){
	clear(c);
	c.len=max(a.len,b.len);
	for(ll i=1; i<=c.len; i++){
		c.num[i]+=a.num[i]+b.num[i];
		c.num[i+1]+=c.num[i]/10;
		c.num[i]%=10;
	}
	if(c.num[c.len+1]) c.len++;
	return c;
}

inline bignum operator -(bignum a,bignum b){
	clear(c);
	c.len=a.len;
	for(ll i=1; i<=c.len; i++){
		c.num[i]=a.num[i]-b.num[i];
		if(c.num[i]<0){
			c.num[i]+=10;
			a.num[i+1]--;
		}
	}
	while(c.len>1&&c.num[c.len]==0) c.len--;
	return c;
}

void FFT(complex<double> *a,ll n,ll op){
    if(!n) return;
    complex<double> a0[n],a1[n];
    for(ll i=0; i<n; i++){
        a0[i]=a[i<<1];
        a1[i]=a[i<<1|1];
    }
    FFT(a0,n>>1,op); FFT(a1,n>>1,op);
    complex<double> W(cos(pi/n),sin(pi/n)*op),w(1,0);
    for(ll i=0; i<n; i++,w*=W){
        a[i]=a0[i]+w*a1[i];
        a[i+n]=a0[i]-w*a1[i];
    }
}

complex<double> x[N],y[N];
inline bignum operator *(bignum a,bignum b){
	memset(x,0,sizeof(x));
	memset(y,0,sizeof(y));
	ll n=a.len-1,m=b.len-1;
	for(ll i=0; i<=n; i++) x[i]=a.num[i+1];
	for(ll i=0; i<=m; i++) y[i]=b.num[i+1];
	for(m+=n,n=1; n<=m; n<<=1);
	FFT(x,n>>1,1); FFT(y,n>>1,1);
	for(ll i=0; i<n; i++) x[i]*=y[i];
	FFT(x,n>>1,-1);
	bignum c;
	for(ll i=0; i<=m; i++) c.num[i+1]=(ll)(fabs(x[i].real()/n+0.5));
	c.len=m+1;
	while(c.len>1&&c.num[c.len]==0) c.len--;
	for(ll i=1; i<=c.len; i++){
		c.num[i+1]+=c.num[i]/10;
		c.num[i]%=10;
	}
	while(c.num[c.len+1]){
		c.len++;
		c.num[c.len+1]+=c.num[c.len]/10;
		c.num[c.len]%=10;
	}
	return c;
}

inline bignum operator /(bignum a,ll b){
	ll sum=0; clear(c);
	for(ll i=a.len; i>=1; i--){
		sum=sum*10+a.num[i];
		c.num[i]=sum/b;
		sum%=b;
	}
	c.len=a.len;
	while(c.len>1&&c.num[c.len]==0) c.len--;
	return c;
}

inline bool check(bignum a,ll b){
	bignum ans=one;
	for(ll i=1; i<=b; i++){
		ans=ans*a;
		if(ans>n) return 0;
	}
	return 1;
}

int main(){
	cin>>m; n=read();
	one==1; zero==0;
	bignum l=one,r=n;
	while(l<=r){
		bignum mid=(l+r)/2;
		if(check(mid,m)){
			ans=mid;
			l=mid+one;
		}
		else r=mid-one;
	}
	write(ans);
	return 0;
}
```

去看了题解，说要压位，我就压了8位，时间复杂度$O(\frac{\log_2{m}\log_{10}^2n\log_2n}{64})$，现在有50分了

```cpp
#pragma GCC optimize(2)
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;

const ll N=20010,mod=100000000,length=log(mod)/log(10);
ll m;
struct bignum{
	ll len,num[N];
	bignum(){len=0; memset(num,0,sizeof(num));}
}n,one,zero,ans,QAQ;

inline bignum read(){
	bignum ans;
	string s; cin>>s;
	for(ll r=s.size()-1; r>=0; r-=length){
		ans.len++;
		ll l;
		if(r>=length-1) l=r-length+1;
		else l=0;
		for(ll i=l; i<=r; i++) ans.num[ans.len]=ans.num[ans.len]*10+s[i]-48;
	}
	return ans;
}

inline void write(bignum s){
	printf("%lld",s.num[s.len]);
	for(ll i=s.len-1; i>=1; i--){
		for(ll j=mod/10; j>s.num[i]; j/=10) putchar('0');
		if(s.num[i]) printf("%lld",s.num[i]);
	}
}

inline void operator ==(bignum &a,ll b){
	for(; b; b/=mod) a.num[++a.len]=b%mod;
}

inline bool operator <=(bignum a,bignum b){
	if(a.len>b.len) return 0;
	if(a.len<b.len) return 1;
	for(ll i=a.len; i>=1; i--){
		if(a.num[i]>b.num[i]) return 0;
		if(a.num[i]<b.num[i]) return 1;
	}
	return 1;
}

inline bool operator >(bignum a,bignum b){
	if(a.len>b.len) return 1;
	if(a.len<b.len) return 0;
	for(ll i=a.len; i>=1; i--){
		if(a.num[i]>b.num[i]) return 1;
		if(a.num[i]<b.num[i]) return 0;
	}
	return 0;
}

inline bignum operator +(bignum a,bignum b){
	bignum c;
	c.len=max(a.len,b.len);
	for(ll i=1; i<=c.len; i++){
		c.num[i]+=a.num[i]+b.num[i];
		c.num[i+1]+=c.num[i]/mod;
		c.num[i]%=mod;
	}
	if(c.num[c.len+1]) c.len++;
	return c;
}

inline bignum operator -(bignum a,bignum b){
	bignum c;
	c.len=a.len;
	for(ll i=1; i<=c.len; i++){
		c.num[i]=a.num[i]-b.num[i];
		if(c.num[i]<0){
			c.num[i]+=mod;
			a.num[i+1]--;
		}
	}
	while(c.len>1&&c.num[c.len]==0) c.len--;
	return c;
}

inline bignum operator *(bignum a,bignum b){
	bignum c;
	for(ll i=1; i<=a.len; i++){
		for(ll j=1; j<=b.len; j++){
			c.num[i+j-1]+=a.num[i]*b.num[j];
			c.num[i+j]+=c.num[i+j-1]/mod;
			c.num[i+j-1]%=mod;
		}
	}
	c.len=a.len+b.len;
	while(c.len>1&&c.num[c.len]==0) c.len--;
	return c;
}

inline bignum operator /(bignum a,ll b){
	ll sum=0; bignum c;
	for(ll i=a.len; i>=1; i--){
		sum=sum*mod+a.num[i];
		c.num[i]=sum/b;
		sum%=b;
	}
	c.len=a.len;
	while(c.len>1&&c.num[c.len]==0) c.len--;
	return c;
}

inline bignum pow(bignum x,ll y){
	if(y==0) return one;
	if(y==1) return x;
	bignum t=pow(x,y/2);
	t=t*t;
	if(y&1) t=t*x;
	if(t>n) return QAQ;
	else return t;
}

int main(){
	cin>>m; n=read();
	one==1; zero==0;
	QAQ=n+one;
	bignum l=one,r=n;
	while(l<=r){
		bignum mid=(l+r)/2;
		if(pow(mid,m)<=n){
			ans=mid;
			l=mid+one;
		}
		else r=mid-one;
	}
	write(ans);
	return 0;
}
```

**如果$mid^m$最小长度大于n的长度就跳出**

AC与50之间就差这一点。。。

AC代码：
```cpp
#pragma GCC optimize(2)
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;

const ll N=20010,mod=100000000,length=log(mod)/log(10);
ll m;
struct bignum{
	ll len,num[N];
	bignum(){len=0; memset(num,0,sizeof(num));}
}n,one,ans;

inline bignum read(){
	bignum ans;
	string s; cin>>s;
	for(ll r=s.size()-1; r>=0; r-=length){
		ans.len++;
		ll l;
		if(r>=length-1) l=r-length+1;
		else l=0;
		for(ll i=l; i<=r; i++) ans.num[ans.len]=ans.num[ans.len]*10+s[i]-48;
	}
	return ans;
}

inline void write(bignum s){
	printf("%lld",s.num[s.len]);
	for(ll i=s.len-1; i>=1; i--){
		for(ll j=mod/10; j>s.num[i]; j/=10) putchar('0');
		if(s.num[i]) printf("%lld",s.num[i]);
	}
}

inline void give(bignum &a,ll b){
	for(; b; b/=mod) a.num[++a.len]=b%mod;
}

inline bool smallequal(bignum a,bignum b){
	if(a.len>b.len) return 0;
	if(a.len<b.len) return 1;
	for(ll i=a.len; i>=1; i--){
		if(a.num[i]>b.num[i]) return 0;
		if(a.num[i]<b.num[i]) return 1;
	}
	return 1;
}

inline bool big(bignum a,bignum b){
	if(a.len>b.len) return 1;
	if(a.len<b.len) return 0;
	for(ll i=a.len; i>=1; i--){
		if(a.num[i]>b.num[i]) return 1;
		if(a.num[i]<b.num[i]) return 0;
	}
	return 0;
}

inline bignum add(bignum a,bignum b){
	bignum c;
	c.len=max(a.len,b.len);
	for(ll i=1; i<=c.len; i++){
		c.num[i]+=a.num[i]+b.num[i];
		c.num[i+1]+=c.num[i]/mod;
		c.num[i]%=mod;
	}
	if(c.num[c.len+1]) c.len++;
	return c;
}

inline bignum dec(bignum a){
    if(a.len==1){
        a.num[1]--;
		return a;
    }
    bignum c=a;
    c.num[1]--;
    for(ll i=1; c.num[i]<0;){
        c.num[i]=mod-1;
        i++;
        c.num[i]--;
    }
    if(c.num[c.len]==0) c.len--;
    return c;
}

inline bignum mul(bignum a,bignum b){
	bignum c;
	for(ll i=1; i<=a.len; i++){
		for(ll j=1; j<=b.len; j++) c.num[i+j-1]+=a.num[i]*b.num[j];
	}
	c.len=a.len+b.len;
	for(ll i=1; i<=c.len; i++){
		c.num[i+1]+=c.num[i]/mod;
		c.num[i]%=mod;
	}
	while(c.len>1&&c.num[c.len]==0) c.len--;
	return c;
}

inline bignum div(bignum a){
	bignum c;
	for(ll i=a.len; i>=1; i--){
		if(a.num[i]&1) a.num[i-1]+=mod;
		c.num[i]=a.num[i]>>1;
	}
	if(c.num[a.len]) c.len=a.len;
	else c.len=a.len-1;
	return c;
}

inline bignum pow(bignum x,ll y){
	if(y==1) return x;
	bignum t=pow(x,y>>1);
	t=mul(t,t);
	if(y&1) t=mul(t,x);
	return t;
}

int main(){
	cin>>m; n=read();
	give(one,1);
	bignum l=one,r=n;
	while(smallequal(l,r)){
		bignum mid=div(add(l,r));
		if(mid.len*m-m+1<=n.len&&smallequal(pow(mid,m),n)){
			ans=mid;
			l=add(mid,one);
		}
		else r=dec(mid);
	}
	write(ans);
	return 0;
}
```

---

## 作者：Edge123 (赞：8)

这道题别看用 c++ 做要高精度，用 py 只需几行。
## 思路
这道题使用二分算法，代码可以这样写：
```python
x=int(input())
y=int(input())
a=0
b=1
while b**x<=y: # **是乘方
    a=b;b=b*2
#二分算法
while a+1<b:
    mid=(a+b)//2
    if  mid**x<=y:
        a=mid
    else:
        b=mid
if a**x<=y:
    print(a)
else:
    print(b)

```
代码直接提交只能得 80 分， 2 个测试点是 RE ，如图。
![](https://cdn.luogu.com.cn/upload/image_hosting/orsee5ke.png)
我们只需添加这两行代码就可以过了。这两行代码可以不限制整数位数大小。
```python
import sys
sys.set_int_max_str_digits(0)
```
## AC 代码
```python
x=int(input())
y=int(input())
a=0
b=1
while b**x<=y: # **是乘方
    a=b;b=b*2
#二分算法
while a+1<b:
    mid=(a+b)//2
    if  mid**x<=y:
        a=mid
    else:
        b=mid
if a**x<=y:
    print(a)
else:
    print(b)

```

---

## 作者：chenxinyang2006 (赞：8)

算法大概就是圧位高精+快速幂+二分。但主要是写起来比较复杂

加上我是一名普及的蒟蒻，题解基本都看不懂，就自己折腾了好久才写出来

这里放一下代码，自认为比较容易理解，不过有些太长了

PS：2011年noip普及初赛，程序填空第一题基本就是这个，不过这题要圧位
```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
using namespace std;

struct Int{
    int arr[5005],len;//倒着存,一格四位,数组防爆稍微开大点
};
Int zero;

void empty(){//重置zero
	memset(zero.arr,0,sizeof(zero.arr));
	zero.len = 0;
}

Int input(char str[10005]){//把字符串变为Int类型数,很玄学
	char revstr[10005];
	Int ans = zero;
	int len = strlen(str);
	for(int i = 1;i <= len;i++){
		revstr[i] = str[len - i];//先翻转
	}
	int use = 0,start = 1;
	for(int i = 1;i <= len;i+=4){//存入所有完整的位
		if((i + 3) > len){
			break;
		}
		use++;//arr用的位数+1
        ans.arr[use] = revstr[i] - '0' + (revstr[i + 1] - '0') * 10 + (revstr[i + 2] - '0') * 100 + (revstr[i + 3] - '0') * 1000;//这个自己推算一下
        start += 4;//不完整第一位+4
	}
	if(len % 4 == 1){//存入不完整位
        ans.arr[++use] = revstr[start] - '0';
    }else if(len  % 4 == 2){
		ans.arr[++use] = revstr[start] - '0' + (revstr[start + 1] - '0') * 10;
	}else if(len % 4 == 3){
		ans.arr[++use] = revstr[start] - '0' + (revstr[start + 1] - '0') * 10 + (revstr[start + 2] - '0') * 100;
	}
	ans.len = use;
	return ans;
}

Int plus(Int a,Int b){//加法运算
	Int ans = zero;
	int len = max(a.len,b.len);
    for(int i = 1;i <= len;i++){
    	ans.arr[i] += a.arr[i] + b.arr[i];
    	ans.len = i;
    	if(ans.arr[i] > 9999){//用于进位
    		ans.arr[i + 1] += 1;
    		ans.len = i + 1;
    		ans.arr[i] -= 10000;
    	}
    }
    return ans;
}

Int reduce(Int a,Int b){//减法运算
	Int ans = zero;
	int len = max(a.len,b.len);
	for(int i = 1;i <= len;i++){
    	ans.arr[i] += (a.arr[i] - b.arr[i]);
    	if(ans.arr[i] >= 0){
    		ans.len = i;
    	}
    	if(ans.arr[i] < 0){
    		ans.arr[i + 1] -= 1;
    		ans.arr[i] += 10000;
    	}
    	
    }
    for(int i = ans.len;i >= 1;i--){//本来不需要这个循环,但是找不出错就加了一个
        if(ans.arr[i] != 0){
            ans.len = i;
            break;
        }
    }
    return ans;
}

Int mult(Int a,Int b){//乘法运算
	Int ans = zero;
	for(int i = 1;i <= a.len;i++){
		for(int j = 1;j <= b.len;j++){
			ans.arr[i + j - 1] += a.arr[i] * b.arr[j];
		}
	}
	for(int i = 1;i <= a.len + b.len;i++){//超过9999的部分向前进位
    	if(ans.arr[i] > 9999){
    		ans.arr[i + 1] += ans.arr[i] / 10000;
    		ans.arr[i] = ans.arr[i] % 10000;
    	}
    }
    if(ans.arr[a.len + b.len] > 0){//多一位特判
    	ans.len = a.len + b.len;
    }else{
    	ans.len = a.len + b.len - 1;
    }
    return ans;
}

Int division(Int a,long long b){//除法运算,只需要高精除以int就行了
	if(b == 1){//加速
		return a;
	}
    Int ans = zero;
	long long left = 0;
    for(int i = a.len;i >= 1;i--){
    	if((left * 10000 + a.arr[i]) >= b){//如果剩余 + 现在够除
            ans.arr[i] = (left * 10000 + a.arr[i]) / b;
            left = (left * 10000 + a.arr[i]) % b;//算出新剩余
            if(i > ans.len){
            	ans.len = i;
            }
    	}else{
    		left = left * 10000 + a.arr[i];//否则直接更新剩余
    	}
    }
    return ans;
}

void print(Int num){//输出函数,也很玄学
	bool zero = false;//有没有出现过可以输出的数字
	for(int i = num.len;i >= 1;i--){
		if(i == num.len){//第一位不用补0
			if(num.arr[i] != 0){
				zero = true;
			}
			printf("%d",num.arr[i]);
			continue;
		}
		if(zero == false && num.arr[i] == 0){//前导0直接跳过
			continue;
		}
		if(num.arr[i] > 0){
			zero = true;
		}
		if(num.arr[i] < 1000){
			if(num.arr[i] >= 100){//>100补一个
				printf("0");
			}else if(num.arr[i] >= 10){//>10补两个
				printf("00");
			}else{
                printf("000");//否则补3个
			}
		}
		printf("%d",num.arr[i]);//输出自身(如果是0,刚好补3个 + 自己1个 = 4个0)
	}
	printf("\n");
}

int cmp(Int a,Int b){//比较函数,a > b返回1,a < b返回-1,a = b返回0
	if(a.len > b.len){//位数不同直接返回
		return 1;
	}else if(a.len < b.len){
		return -1;
	}
	for(int i = a.len;i >= 1;i--){//一位一位比较
		if(a.arr[i] > b.arr[i]){
			return 1;
		}else if(a.arr[i] < b.arr[i]){
			return -1;
		}
	}
	return 0;
}

Int put(int k){//将int转换为Int的快捷函数
	Int ans = zero;
	ans.arr[1] = k;//第一位直接加k
	ans.len = 1;
	for(int i = 2;ans.arr[i - 1] > 9999;i++){//一位一位匀
		ans.arr[i] = ans.arr[i-1] / 10000;
		ans.arr[i-1] = ans.arr[i-1] % 10000;
		ans.len = i;
	}
	return ans;
}

Int power(Int p,int k){//计算p ^ k的快速方法,参考P1226快速幂的题解
	Int ans = put(1),x = p;
	while(k != 1){
		if(k % 2 == 1){
			ans = mult(ans,x);
		}
		x = mult(x,x);
		k = k / 2;
	}
	return mult(ans,x);
}



int main(){//超级玄学的主函数
	empty();
	char str1[10005];
	int m;
	scanf("%d %s",&m,str1);
	Int k = input(str1);
	Int left,right,mid;
	memset(left.arr,0,sizeof(left.arr));
	left.len = 0;
	left.arr[1] = 1;
	memset(right.arr,0,sizeof(right.arr));
    right.len = 1;
	right.arr[1] = 1;//清理left和right
	while(cmp(power(right,m),k) == -1){//这里参考了erge大佬的说法,原文如下:
		//你应该先将l赋为1，r赋为2 然后不停l=r，r*=2，看r^m是否>=n 找r上限 这样可以避免RE以及TLE 
		//还有一段无关的没复制,这是个缩小left和right的运算方法
		left = right;
		right = mult(right,put(2));
	}
	Int p = power(put(10),m);//最为玄学的地方来了!!
	k = mult(k,p);//这里为了保证精度要多算1位,这样的话left和right要乘10,k要乘10 ^ m,下面讲了为什么
	left = mult(left,put(10));//其他大佬貌似都没这样做,可能还是因为我太弱了
	right = mult(right,put(10));
	while(cmp(reduce(right,left),put(2)) != -1){//判断right-left的差是否小于2,如果改成1有的时候会死循环，但是由于写2精度可能不足,我就加了玄学的多算一位的方法
        mid = division(plus(left,right),2);//计算left和right的平均数
        int cmp1 = cmp(power(mid,m),k);//判断mid ^ m与k的大小
        if(cmp1 == 1){//如果k > mid ^ m,right = mid
        	right = mid;
        }else{//如果mid ^ m > k,left = mid
            left = mid;
        }
	}
	if(cmp(left,put(10)) == -1){//如果答案 < 10(真实答案 < 1),程序会不输出,所以要特判
		printf("0\n");
	}else{
		print(division(left,10));//答案要除以10输出
	}
	return 0;//233行的神奇东西结束了
}
```

---


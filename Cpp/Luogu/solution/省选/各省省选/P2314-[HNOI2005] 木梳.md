# [HNOI2005] 木梳

## 题目描述

$%![](https://cdn.luogu.com.cn/upload/pic/1353.png)$

$%![](https://cdn.luogu.com.cn/upload/pic/1354.png)$

艾艺从小酷爱艺术，他梦想成为一名伟大的艺术家。最近他获得了一块材质不错的木板，其下侧为直线段，长为 $L$，平均分为 $L$ 段，从左到右编号为 $1$、$2$、……、$L$。木板的上侧为锯齿形，高度为整数，第 $i$ 段的高度为 $A_i$，$A_i \ge 2$（如下图所示）。

```plain
              *                                    
                                                   
              *     *                             *
                                                   
  *     *     *     *     *                       *
                                                   
  *     *     *     *     *           *     *     *
                                                   
  *     *     *     *     *     *     *     *     *
                                                   
  *     *     *     *     *     *     *     *     *
                                                   
  4     4     6     5     4     2     3     3     5
```

这么好的一段材料浪费了怪可惜的，艾艺决定好好加工一番做成一件艺术品。但他不是纯艺术家，他觉得每件艺术品都应有实用价值（否则只是华而不实），具有实用性的艺术品是他设计的理念。

根据这块木板的锯齿状，艾艺想到了每天起床后都要用到的一件日用品，“对，就把它做成梳子！”他的设想是：用刻刀将某些上端的格子挖掉（如果把某个格子挖掉，那么这个格子上方的格子也必须被挖掉，但不能把一列中的格子全都挖掉）。使得剩下的木板构成“规则锯齿形”（这样才好梳头）。

例如，对上图，挖掉第 $3$、$7$、$8$ 列最上面的 $1$ 个格子和第 $5$ 列最上面的 $2$ 个格子后，剩下的区域就构成“规则锯齿形”（如下图所示）。

```plain
              .                                      
            +---------+                         +--->
            | *     * |                         | *  
------------+         |                         |    
  *     *     *     * |   .                     | *  
                      |                         |    
  *     *     *     * |   .           .     .   | *  
                      +-------------------------+    
  *     *     *     *     *     *     *     *     *  
                                                     
  *     *     *     *     *     *     *     *     *  
                                                     
  4     4     5     5     2     2     2     2     5  
```

一个锯齿形称为“规则锯齿形”当且仅当它的边界（右图中红色曲线所示）的拐点序列不包含 `010` 或者 `101`。右图中曲线的拐点序列为 `011001`，其中 `0` 代表左拐，`1` 代表右拐，沿着曲线的最左端往右走，先左拐，再右拐，接着右拐，然后左拐，继续左拐，最后右拐。

为了最大限度地减少浪费，艾艺希望做出来的梳子面积最大。

## 说明/提示

对于 $50\%$ 的数据，$L \le 10^4$。

对于 $100\%$ 的数据，$4 \le L \le 10^5$，$2 \le A_i \le 10^8$。

## 样例 #1

### 输入

```
9 
4 4 6 5 4 2 3 3 5
```

### 输出

```
3```

# 题解

## 作者：xiwang (赞：5)

~~请直接去看p2703题解~~

直接把输入看成往空白区域上添加方格之后复制p2703代码会炸，至少我的

会炸，这让我十分气愤，以至于我不得不~~打电话给王八屯子妇女协会把出数~~

~~据的下放到苞米地劳改~~进行大量魔改，但事实上这样十分有效，以至于我隔

壁的大佬直接艹过去了，但他懒得写题解（不屑），所以他就叫我写一个，但我

也懒得写，所以我决定把p2703的题解复制魔改一下就好了（反正思路一样）

令f[i][j][k]表示处理到i，第i行长为j，最后状态是凹/凸的最小代价

转移：
```
f[i][j][k]=min(f[i-1][j-1][k],f[i-1][p][1-k])(p<j&&k==1 || p>j&&k==0)
```

然后你把这个东西写出来交上去就TLE~~身败名裂~~了

然后我们考虑怎么优化这个东西

令g[i]表示目前i位置上的高度

很容易发现，每次转移的时候，真正有用j的只有一小部分

就
```
g[c]-2~g[c](i-2<=c<=i+2)
```
这一小段

怎么证明？

当然是靠~~数学知识证~~打表找规律啊！

打几个表，大胆猜测这个结论，然后j的枚举范围就是有限的了

然后复杂度就是线性的了，然后就A了

然后记得开longlong

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000000+10;
const long long inf=0x7f7f7f7f7f7f7f7f;
typedef long long ll;
typedef double ddf;
typedef int _int;
#define int ll
int n,m;
int l[N],g[N],f[2][N][2],pr,nt;
int t[2],s[2][N];
int ass;
void fuck(){
    memset(f,0x7f,sizeof(f));
    t[1]=0;
    for(int j=1;j<=3;j++){
        for(int k=g[j]-2;k<=g[j];k++){
            if(k<=g[1])s[1][++t[1]]=k;
        }
    }
    for(int i=1;i<=t[1];i++)f[1][i][0]=f[1][i][1]=g[1]-s[1][i];
    pr=0,nt=1;
    for(int i=2;i<=n;i++){
        pr^=1,nt^=1;t[nt]=0;
        int lf=max(1ll,i-2),rf=min(n,i+2);
        for(int j=lf;j<=rf;j++){
            for(int k=g[j]-2;k<=g[j];k++){
                if(k<=g[i])s[nt][++t[nt]]=k;
            }
        }
        for(int j=1;j<=t[nt];j++){
            f[nt][j][1]=f[nt][j][0]=inf;
            for(int k=1;k<=t[pr];k++){
                if(s[pr][k]>s[nt][j])f[nt][j][0]=min(f[nt][j][0],f[pr][k][1]);
                else if(s[pr][k]<s[nt][j])f[nt][j][1]=min(f[nt][j][1],f[pr][k][0]);
                else f[nt][j][0]=min(f[nt][j][0],f[pr][k][0]),f[nt][j][1]=min(f[nt][j][1],f[pr][k][1]);
            }
            f[nt][j][0]+=g[i]-s[nt][j];
            f[nt][j][1]+=g[i]-s[nt][j];
        }
    }
    int re=inf;
    for(int i=1;i<=t[nt];i++)re=min(re,min(f[nt][i][0],f[nt][i][1]));
    ass+=re;
}
_int main(){
    scanf("%lld",&n);
    for(int i=1;i<=n;i++)scanf("%lld",&g[i]);
    //fuck();
    fuck();
    printf("%lld",ass);
    return 0;
}
```

---


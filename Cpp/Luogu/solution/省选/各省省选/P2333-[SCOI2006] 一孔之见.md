# [SCOI2006] 一孔之见

## 题目描述

从一个圆孔里看一个凸多边形，为了让看到的面积至少为 $S$，孔的半径至少需要多大？  
假设孔的圆心固定在 $(0,0)$，且 $(0, 0)$ 在多边形的内部（而不是外部或边界上）。


## 说明/提示

【限制】

对于 $50\%$ 的数据：$3\le n \le 10$，输入凸多边形是正多边形，且中心在 $(0,0)$   
对于 $100\%$ 的数据：$3\le n \le 50$



## 样例 #1

### 输入

```
3 1.60
-1 -1
1 -1
0 1
```

### 输出

```
0.93```

# 题解

## 作者：SuperJvRuo (赞：25)

乍一看这题，二分半径，大力simpson啊！看我随手写一个，你看，样例都过了，我交一发......

WA\*6+TLE\*3+AC\*1

半径只能二分解决，而面积，看来不是能用simpson水过的了。

![](https://cdn.luogu.com.cn/upload/pic/18608.png )

观察图形，利用题中多边形的性质，不难想出这样的搞法：

![](https://cdn.luogu.com.cn/upload/pic/18612.png )

分别连接多边形的各个顶点与原点，将多边形划分为三角形。每个三角形都对应一个唯一的圆心角，在半径确定时，也就能确定一个对应的扇形。只需求出各个三角形与对应扇形面积交的和即可。

这里分为4种情况：

### case 1

最简单的情况，如图中$\triangle COD$，三角形被扇形完全包含。那么面积交就是三角形的面积，即：$S=|\vec{OC}\times\vec{OD}|\div2$。

### case 2
稍微难一点的情况，如图中$\triangle AOF,\triangle EOF$，三角形完全包含扇形。那么面积交就是扇形的面积，即：$S=r^2\theta\div2$。

关于$\theta$的求法，可以先用坐标分别求出两个点极角的余弦值，再用cmath里的acos函数求出两个极角的弧度。但注意，acos的返回值在$[0,\pi]$间，因此还需要利用点的纵坐标正负，来确定$\theta$是否大于$\pi$，还要用“奇变偶不变，符号看象限”，去确定极角的弧度值。然后两角的极角作差，取绝对值，如果$\theta>\pi$，还要取$2\pi-\theta$。即得$\theta$的弧度。详见下面的代码。

### case 3
前两种的结合，如图中$\triangle BOC,\triangle DOE$，角所对的边和弧有且仅有一个交点。可以求出这个交点，然后对交点左右两部分分别用前两种方法求解。那么怎么求交点呢？

设两个点分别为$A(x_1,y_1),B(x_2,y_2)$。设直线$AB$的解析式为$y=kx+b$，则斜率$k=\frac{y_1-y_2}{x_1-x_2}$，纵截距$b=y_1-kx_1$。圆的解析式为$x^2+y^2=r^2$。

由直线解析式得：$$y^2=(kx+b)^2$$

由圆解析式得：$$y^2=r^2-x^2$$

因此有：$$(kx+b)^2=r^2-x^2$$
$$k^2x^2+2kbx+b^2-r^2+x^2=0$$
$$(k^2+1)x^2+2kbx+(b^2-r^2)=0$$

解得：$$x_1=\frac{-2kb+\sqrt{4k^2b^2-4(k^2+1)(b^2-r^2)}}{2k^2+2}$$
$$x_2=\frac{-2kb-\sqrt{4k^2b^2-4(k^2+1)(b^2-r^2)}}{2k^2+2}$$

看看哪个点在线段上就行了。然后一侧求三角形面积，另一侧求扇形面积。

### case 4
如果解决了前三种，第四种就不是问题了。如图中$\triangle AOB$，角的对边与对弧有两个交点，可以将其分为两个case 3解决。

### 是不是很简单啊？
```
#include<cstdio>
#include<cmath>
#include<algorithm>

#define EPS 1e-5
const double PI=acos(-1);

int n;
double s;
struct Point
{
	double dist,x,y;
} point[55];

//求出线段上离原点最近的点，以确定线段与弧是否相交
Point calc_vertical(Point A,Point B)
{
	Point cross;
    //两种特殊情况：与x轴垂直、与y轴垂直
	if(fabs(A.x-B.x)<EPS)
	{
		cross.x=A.x;
		cross.y=0;
		cross.dist=fabs(A.x);
	}
	else if(fabs(A.y-B.y)<EPS)
	{
		cross.x=0;
		cross.y=A.y;
		cross.dist=fabs(A.y);
	}
	else//作垂线
	{
		double k=(A.y-B.y)/(A.x-B.x);
		double b=A.y-k*A.x;
		cross.x=-b/(k+1.0/k);
		cross.y=-cross.x/k;
		cross.dist=sqrt(cross.x*cross.x+cross.y*cross.y);
	}
    //如果垂足不在线段上，就取两个端点中更近的一个
	if(A.x>B.x)
	{
		std::swap(A,B);
	}
	if(cross.x<A.x||cross.x>B.x)
	{
		cross=A.dist<B.dist?A:B;
	}
	if(A.y>B.y)
	{
		std::swap(A,B);
	}
	if(cross.y<A.y||cross.y>B.y)
	{
		cross=A.dist<B.dist?A:B;
	}
	return cross;
}

//求线段与圆弧的交点
Point calc_cross(Point A,Point B,double radius)
{
	Point res;
	if(A.x>B.x)
	{
		std::swap(A,B);
	}
	double k=(A.y-B.y)/(A.x-B.x);
	double b=A.y-k*A.x;
	res.x=(-2*k*b+sqrt(4*k*k*b*b-4*(b*b-radius*radius)*(k*k+1)))/(2*k*k+2);
	if(res.x<A.x||res.x>B.x)
	{
		res.x=(-2*k*b-sqrt(4*k*k*b*b-4*(b*b-radius*radius)*(k*k+1)))/(2*k*k+2);
	}
	res.y=res.x*k+b;
	res.dist=sqrt(res.x*res.x+res.y*res.y);
	return res;
}

double mult(Point a,Point b)//向量的向量积的模除以2
{
	return fabs(a.x*b.y-b.x*a.y)/2.0;
}

double calc_angle(Point a)//计算极角
{
	double cosine=a.x/a.dist;
	double res=acos(cosine);
	return a.y>0?res:2*PI-res;
}

double calc_sector(Point a,Point b,double radius)//计算扇形面积
{
	double angle=fabs(calc_angle(a)-calc_angle(b));
	angle=angle<PI?angle:2*PI-angle;
	return radius*radius*angle/2.0;
}

double calc_part(Point a,Point b,double radius)//计算面积交
{
	if(a.dist-radius<EPS&&b.dist-radius<EPS)
	{
		return mult(a,b);
	}
	else
	{
		if(a.dist>b.dist)
		{
			std::swap(a,b);
		}
		Point vertical=calc_vertical(a,b);
		if(vertical.dist-radius>EPS)
		{
			return calc_sector(a,b,radius);
		}
		else if(a.dist-radius>EPS)
		{
			return calc_part(a,vertical,radius)+calc_part(vertical,b,radius);
		}
		else
		{
			Point cross=calc_cross(a,b,radius);
			return calc_sector(cross,b,radius)+mult(a,cross);
		}
	}
}

double calc_area(double radius)
{
	double res=0;
	double add;
	for(int i=0; i<n; ++i)
	{
		res+=add=calc_part(point[i],point[i+1],radius);
	}
	return res;
}

int main()
{
	double left_radius=0,right_radius=0,mid_radius;
	scanf("%d %lf",&n,&s);
	for(int i=0; i<n; ++i)
	{
		scanf("%lf %lf",&point[i].x,&point[i].y);
		point[i].dist=sqrt(point[i].x*point[i].x+point[i].y*point[i].y);
		right_radius=std::max(right_radius,point[i].dist);
	}
	point[n]=point[0];

	while(right_radius-left_radius>EPS)//二分半径
	{
		mid_radius=(left_radius+right_radius)/2.0;
		if(calc_area(mid_radius)>s)
		{
			right_radius=mid_radius;
		}
		else
		{
			left_radius=mid_radius;
		}
	}

	printf("%.2lf\n",mid_radius);
	return 0;
}
```

---

## 作者：lailai0916 (赞：3)

## 原题链接

- [洛谷 P2333 [SCOI2006] 一孔之见](https://www.luogu.com.cn/problem/P2333)

## 参考资料

- [Atan2 - 维基百科](https://zh.wikipedia.org/wiki/Atan2)

## 解题思路

随着圆的半径增大，能看到的面积单调不降，所以可以二分寻找满足条件的最小半径。

将多边形的每个顶点与原点连接，构成多个三角形。每个三角形都有一个对应圆心角的扇形。

通过分类讨论每个三角形与其对应扇形的交集面积，可以计算出能看到的面积。

## 函数定义

### f1(A,B)

$f_1(A,B)$：表示三角形 $\triangle OAB$ 的有向面积。

通过向量叉积计算 $f_1$：

$$
f_1(A,B)=\frac{\overrightarrow{OA}\times \overrightarrow{OB}}{2}
$$

```cpp
double f1(Point A,Point B)
{
	return Cross(A,B)/2;
}
```

### f2(A,B,r)

$f_2(A,B,r)$：表示由 $OA$ 和 $OB$ 两条边围成且半径为 $r$ 的扇形的有向面积。

通过向量的叉积和点积计算出扇形的圆心角 $\theta=\angle AOB$：

$$
\theta=\arctan\left(\frac{\sin\angle AOB}{\cos\angle AOB}\right)=\operatorname{atan2}(\overrightarrow{OA}\times \overrightarrow{OB},\overrightarrow{OA}\cdot \overrightarrow{OB})
$$

根据扇形面积公式计算 $f_2$：

$$
f_2(A,B,r)=\frac{\theta\cdot r^2}{2}=\frac{\operatorname{atan2}(\overrightarrow{OA}\times \overrightarrow{OB},\overrightarrow{OA} \cdot\overrightarrow{OB})\cdot r^2}{2}
$$

```cpp
double f2(Point A,Point B,double r)
{
	return atan2(Cross(A,B),Dot(A,B))*r*r/2;
}
```

### calc(A,B,r)

$calc(A,B,r)$：表示每个三角形与其对应扇形的交集面积。

接下来通过分类讨论计算 $calc$，设：

$$
S=calc(A,B,r)
$$

## 分类讨论

### Case 1

如果点 $A,B$ 距离圆心的距离都小于 $r$：

$$
|\overrightarrow{OA}|\le r\land|\overrightarrow{OB}|\le r
$$

此时扇形完全包含三角形，面积交集就是三角形的面积：

$$
S=f_1(A,B)
$$

```cpp
if(Len(A)<=r&&Len(B)<=r)return f1(A,B);
```

### 判断相交

接下来我们需要判断直线 $AB$ 是否与圆有交点 $P$。

直线 $AB$ 的参数方程：

$$
\overrightarrow{OP}=\overrightarrow{OA}+t\cdot\overrightarrow{AB}
$$

代入圆的方程：

$$
r=|\overrightarrow{OP}|=|\overrightarrow{OA}+t\cdot\overrightarrow{AB}|
$$

整理为标准二次方程：

$$
at^2+bt+c=0
$$

计算方程的系数：

$$
a=|AB|^2,b=2\cdot\overrightarrow{OA}\cdot\overrightarrow{AB},c=|OA|^2-r^2
$$

```cpp
double a=Len2(B-A),b=Dot(A,B-A)*2,c=Len2(A)-r*r;
```

计算判别式 $\Delta$：

$$
\Delta=b^2-4ac
$$

```cpp
double d=b*b-a*c*4;
```

### Case 2

如果直线与圆没有交点或相切：

$$
\Delta\le 0
$$

此时三角形完全包含扇形，面积交集就是扇形的面积：

$$
S=f_2(A,B,r)
$$

```cpp
if(d<=0)return f2(A,B,r);
```

### 计算交点

接下来通过求根公式，计算出 $t$：

$$
t_1=\frac{-b-\sqrt{\Delta}}{2a},t_2=\frac{-b+\sqrt{\Delta}}{2a}
$$

```cpp
double t1=(-b-sqrt(d))/(a*2),t2=(-b+sqrt(d))/(a*2);
```

代入直线方程，计算出直线与圆的交点 $P$：

$$
\overrightarrow{OP}=\overrightarrow{OA}+t\cdot\overrightarrow{AB}
$$

我们令距离 $A$ 较近的交点为 $C$，距离 $B$ 较近的交点为 $D$：

$$
\overrightarrow{OC}=\overrightarrow{OA}+t_1\cdot\overrightarrow{AB},\overrightarrow{OD}=\overrightarrow{OA}+t_2\cdot\overrightarrow{AB}
$$

```cpp
Point C=A+(B-A)*t1,D=A+(B-A)*t2;
```

### Case 3

如果点 $C,D$ 都在点 $A,B$ 的同一侧（即线段 $AB$ 的延长线上）：

$$
t_1\ge 1\lor t_2\le 0
$$

此时三角形也完全包含扇形，面积交集就是扇形的面积：

$$
S=f_2(A,B,r)
$$

```cpp
if(t1>=1||t2<=0)return f2(A,B,r);
```

### Case 4

如果点 $D$ 在线段 $AB$ 上：

$$
t_1\le 0
$$

此时 $AD$ 是三角形面积，$DB$ 是扇形面积：

$$
S=f_1(A,D)+f_2(D,B,r)
$$

```cpp
if(t1<=0)return f1(A,D)+f2(D,B,r);
```

### Case 5

如果点 $C$ 在线段 $AB$ 上：

$$
t_2\ge 1
$$

此时 $AC$ 是扇形面积，$CB$ 是三角形面积：

$$
S=f_2(A,C,r)+f_1(D,B)
$$

```cpp
if(t2>=1)return f2(A,C,r)+f1(C,B);
```

### Case 6

否则点 $C,D$ 都在线段 $AB$ 上。

此时 $AC$ 是扇形面积，$CD$ 是三角形面积，$DB$ 是扇形面积：

$$
S=f_2(A,C,r)+f_1(C,D)+f_2(D,B,r)
$$

```cpp
return f2(A,C,r)+f1(C,D)+f2(D,B,r);
```

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const double eps=1e-8;
const int N=55;
struct Point
{
	double x,y;
	Point(){}
	Point(double _x,double _y):x(_x),y(_y){}
	Point operator+(Point B){return Point(x+B.x,y+B.y);}
	Point operator-(Point B){return Point(x-B.x,y-B.y);}
	Point operator*(double k){return Point(x*k,y*k);}
}a[N];
double Dot(Point A,Point B){return A.x*B.x+A.y*B.y;}
double Cross(Point A,Point B){return A.x*B.y-A.y*B.x;}
double Len(Point A){return sqrt(Dot(A,A));}
double Len2(Point A){return Dot(A,A);}
double f1(Point A,Point B){return Cross(A,B)/2;}
double f2(Point A,Point B,double r){return atan2(Cross(A,B),Dot(A,B))*r*r/2;}
double calc(Point A,Point B,double r)
{
	if(Len(A)<=r&&Len(B)<=r)return f1(A,B);
	double a=Len2(B-A),b=Dot(A,B-A)*2,c=Len2(A)-r*r;
	double d=b*b-a*c*4;
	if(d<=0)return f2(A,B,r);
	double t1=(-b-sqrt(d))/(a*2),t2=(-b+sqrt(d))/(a*2);
	Point C=A+(B-A)*t1,D=A+(B-A)*t2;
	if(t1>=1||t2<=0)return f2(A,B,r);
	if(t1<=0)return f1(A,D)+f2(D,B,r);
	if(t2>=1)return f2(A,C,r)+f1(C,B);
	return f2(A,C,r)+f1(C,D)+f2(D,B,r);
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int n;
	double s;
	cin>>n>>s;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].x>>a[i].y;
	}
	double l=0,r=10000;
	while(r-l>eps)
	{
		double mid=(l+r)/2,sum=0;
		for(int i=1;i<=n;i++)
		{
			sum+=calc(a[i],a[i%n+1],mid);
		}
		if(fabs(sum)>=s)r=mid;
		else l=mid;
	}
	cout<<fixed<<setprecision(2)<<l<<'\n';
	return 0;
}
```

---


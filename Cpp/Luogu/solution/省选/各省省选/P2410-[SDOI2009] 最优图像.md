# [SDOI2009] 最优图像

## 题目背景

小 E 在好友小 W 的家中发现一幅神奇的图画，对此颇有兴趣。

## 题目描述

这幅画可以被看做一个包含 $n \times m$ 个像素的黑白图像，为了方便起见，我们用 $0$ 表示白色像素，$1$ 表示黑色像素。小 E 认为这幅图画暗藏玄机，因此他记录下了这幅图像中每行、每列的黑色像素数量，以回去慢慢研究其中的奥妙。

有一天，小 W 不慎将图画打湿，原本的图像已经很难分辨。他十分着急，于是找来小 E，希望共同还原这幅图画。根据打湿后的图画，他们无法确定真正的图像，然而可以推测出每个像素原本是黑色像素的概率 $p_{i,j}\%$。那么，一个完整的图像的出现概率就可以定义为:

$$\prod\limits_{i = 1}^n \prod\limits_{j = 1}^{m} p_{i, j}\% \times [s_{i, j} = 1]$$

其中 $s_{i,j}$ 表示在还原后的图像中，像素是白色($0$)还是黑色($1$)，$[s_{i, j} = 1]$ 表示若 $s_{i, j} = 1$，则该表达式的值为 $1$，否则为 $0$。换句话说，一个完整图像出现概率就等于其所有黑色像素的出现概率之积。显然，图像的黑色像素不能包含概率为 $0$ 的像素。

然而，小 E 对此也无能为力。因此他们找到了会编程的小 F，也就是你，请你根据以上信息，告诉他们最有可能是原始图像的答案是什么。



## 说明/提示

#### 样例输入输出 1 解释

共有两种可能的图像：

```plain
01
10
```
```plain
10
01
```
前者的出现概率是 $0.1×0.2=0.02$，后者的出现概率是 $0.9×0.8=0.72$，故后者是最优图像。

---

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n, m \leq 5$。
- 对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 100$，$0 \leq p_{i, j} \leq 100$，$0 \leq a_i \leq m$，$0 \leq b_i \leq n$。

---

感谢 @[test12345](https://www.luogu.com.cn/user/23118) 提供 spj。

## 样例 #1

### 输入

```
2 2
90 10
20 80
1 1
1 1
```

### 输出

```
10
01
```

# 题解

## 作者：tommymio (赞：6)

PS：之前没有**Special Judge**的窝挂的非常惨，现在扶咕咕把**Special Judge**加上去了，让我们一起支持他连任吧（大雾

网络流行列的经典模型。

- 将每行每列分别看成一个点，每行对应的点的编号为 $1-n$，每列对应的点的编号为 $(n+1)-(n+m)$。

- 从每行向每列连一条边，容量为 $1$ ，费用为 $p_{i,j}*0.01$。
- 从源点 $S$ 向每行连一条边，容量为 $a_i$ ，费用为 $1.00$。
- 从每列向汇点连一条边，容量为 $b_j$，费用为 $1.00$。

跑最大费用最大流即可。

由于这题求的是令已选点的权值之积最大，故 $\text{spfa}$ 增广时， $dis_y=\max\{dis_y,dis_x*w(x,y)\}$。

值得注意的是，本题中反边的费用并非取负，因为如果取负，在取反边时无法正确扣除贡献，根据乘法的原理，我们取它的倒数。

没有输出最大概率其实更好写，对于输出方案，我们只需要遍历一下残量网络，找出那些当前容量为 $0$ 的边计算答案即可。

这题正解是 $\text{zkw}$ 费用流，为了卡过去，我们需要做一些常数上的优化。

- 快读。
- $\text{dinic}$ 的最优化剪枝（流量为 $0$ 时提前退出）
- $\text{dinic}$ 的当前弧优化。
- 在回溯时直接把 $vis$ 数组置为 $0$ ，尽量不用 $\text{memset}$。

**Show the Code**

```cpp
#include<cstdio>
#include<queue>
#include<cmath>
#define min(a,b) ((a)<(b)? (a):(b))
//x->y incf w
const int inf=0x3f3f3f3f;
const double eps=1e-6;
std::queue<int> Q;
int cnt=1,n,m,s,t;
double dis[100005],w[200005];
int a[105],b[105],vis[100005],val[105][105],mp[105][105];
int h[100005],to[200005],ver[200005],incf[200005];
inline int read() {
	register int x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f;
}
inline void add(int x,int y,int z,double v) {
	to[++cnt]=y;
	ver[cnt]=h[x];
	incf[cnt]=z;
	w[cnt]=v;
	h[x]=cnt;
}
inline void add_d(int x,int y,int z,double v) {add(x,y,z,v);add(y,x,0,1.0/v);}
inline bool spfa() {
	for(register int i=0;i<=t;++i) dis[i]=-1;
	dis[s]=1.00;Q.push(s);
	while(Q.size()) {
		int x=Q.front();Q.pop();
		vis[x]=0;
		for(register int i=h[x];i;i=ver[i]) {
			int y=to[i];
			if((dis[y]<dis[x]*w[i])&&(incf[i])) {
				dis[y]=dis[x]*w[i];
				if(!vis[y]) {vis[y]=1;Q.push(y);}
			} 
		}
	}
	return dis[t]>0;
}
int dfs(int x,int flow) {
	if(!flow||x==t) return flow;
	vis[x]=1;
	int rest=flow;
	for(register int i=h[x];i&&rest;i=ver[i]) {
		int y=to[i];
		if(!vis[y]&&(fabs(dis[y]-dis[x]*w[i])<=eps)&&incf[i]) {
			int k=dfs(y,min(rest,incf[i]));
			if(!k) {dis[y]=-1;}
			else {rest-=k;incf[i]-=k;incf[i^1]+=k;}	
		}
	}
	vis[x]=0;
	return flow-rest;
}
int main() {
	n=read(),m=read();
	int maxflow=0;
	s=n+m+1;t=n+m+2;
	for(register int i=1;i<=n;++i) {for(register int j=1;j<=m;++j) val[i][j]=read();}	
	for(register int i=1;i<=n;++i) a[i]=read();
	for(register int i=1;i<=m;++i) b[i]=read();
	for(register int i=1;i<=n;++i) if(a[i]) add_d(s,i,a[i],1.0);
	for(register int i=1;i<=m;++i) if(b[i]) add_d(i+n,t,b[i],1.0);
	for(register int i=1;i<=n;++i) {for(register int j=1;j<=m;++j) if(val[i][j]) add_d(i,j+n,1,val[i][j]*0.01);}
	while(spfa()) maxflow+=dfs(s,inf);//,printf("%d\n",maxflow);
	for(register int x=1;x<=n;++x) {
		for(register int i=h[x];i;i=ver[i]) {
			int y=to[i];
			if(y==s) continue;
			if(!incf[i]) mp[x][y-n]=1;
		}
	}
	for(register int x=1;x<=n;++x) {
		for(register int y=1;y<=m;++y) {
			printf("%d",mp[x][y]);
		}
		printf("\n");
	}
	return 0;
}
```

![](https://cdn.luogu.com.cn/upload/image_hosting/b74mon7x.png)

最后附上提交记录，可以看到这玩意跑的完全不像是一个纯粹的费用流。

~~**(Nacly_Fish is gu好评**~~

---

## 作者：Aranea晨曦 (赞：5)

蒟蒻喵喵的第一篇正经题解——  
提交了，也许能过呢><

主要解释了一下为啥要这么连边

2023/3/14 update:改了错字 行=>列  
@liyishui2003 /bx

------------
首先，我们用流网络里的点表示 _每一行_  和  _每一列_ 。  
比如点 $i$ 表示第 $i$ 行，点 $j+n$ 表示第 $j$ 列。

对于每个格子 $(i,j)$，从第 $i$ 行的点向第 $j$ 列的点连一条容量为 $1$，权值为 $p_{i,j}$（指概率，输入的数值 $\times0.01$）的边。  
这样，我们指定一个格子为黑色就相当于在流网络中使这条边满流——贡献了一个黑色格子，同时也得到了 $p_{i,j}$ 的价值。反之，没有贡献黑格子数量，也没有得到价值。  
~~听说有个模型叫 _网络流行列模型_。~~

然后考虑每行、每列黑格子数量的限制，就是通过每行、每列的点的流量的限制。  
所以只需要把源点 $S$ 与表示第 $i$ 列的点连的边的流量设为 $a_i$， 表示第 $j$ 列的点与汇点 $T$ 的连边的流量为 $b_j$ 就可以了。（当然全都反过来连也可以）  
这样满流的时候第 $i$ 行的总流量是 $a_i$，第 $j$ 列的总流量是 $b_i$，刚好满足题意。

求的是选择的点权值之积最大，在网络里就是使满流的时候费用最大，所以跑最大费用最大流。



------------
于是建图就是
- 对于每个格子 $(i,j)$，从第 $i$ 行的点向第 $j$ 列的点连一条容量为 $1$，权值为 $p_{i,j}$（指概率，输入的数值 $\times0.01$）的边。
- $S$ 向每行 $i$ 连容量 $a_i$，费用 $1$ 的边。
- 每列 $j$ 向 $T$ 连容量 $b_i$，费用 $1$ 的边。

------------
一些具体实现的废话细节：
- $S$ 与行 $i$ 的连边、列 $j$ 与 $T$ 的连边权值是 $1$ 不是 $0$，因为要乘起来。
- 反向边的费用是  $\frac{1}{c}$ 不是 $-c$，同理。  
- SPFA 的松弛是 `dis[v]<dis[u]*e[i].c`。
- 统计答案的时候，遍历每行连到每列的边，如果满流就是 $1$，反之为 $0$ 即可。
- 现在好像不卡常了，[dinic ~~即使忘了加当前弧优化也~~过了](https://www.luogu.com.cn/record/101171894)。


------------
code  
[record](https://www.luogu.com.cn/record/101179130)

```cpp
#include<bits/stdc++.h>
#define in(x) scanf("%d",&x)
#define out(x) printf("%d",x)
#define outs(x) printf(x)
#define ed printf("\n")
#define ll long long
#define ull unsigned long long
#define mpr make_pair
#define pr pair<int,int>
#define qwq first
#define awa second
#define fo(i,a,b) for(int i=a;i<=b;++i)
#define fu(i,a,b) for(int i=a;i<b;++i)
#define INF 2139062143
//#define Aranea_Debug
#define N 110
#define M 100010
#define eps (1e-6)
using namespace std;
struct node
{
    int v,nxt,w;
    double c;
}e[M*2];
int head[M],cnt=1;
void add(int a,int b,int w,double c)
{
    e[++cnt].v=b;
    e[cnt].w=w,e[cnt].c=c;
    e[cnt].nxt=head[a];
    head[a]=cnt;
}
void link(int a,int b,int w,double c)
{
    if(!c)return;
    add(a,b,w,c),add(b,a,0,1.0/c);
}

int S,T,cur[M];
bool inq[M];
double dis[M];
queue<int>q;
bool spfa()
{
    memcpy(cur,head,sizeof(head));
    fo(i,0,T)dis[i]=-1;
    dis[S]=1.0;
    q.push(S);
    while(!q.empty())
    {
        int u=q.front();q.pop();
        inq[u]=false;
        for(int i=head[u];i;i=e[i].nxt)
        {
            int vol=e[i].w,v=e[i].v;
            if(vol>0&&dis[v]<dis[u]*e[i].c)
            {
                dis[v]=dis[u]*e[i].c;
                if(!inq[v])inq[v]=true,q.push(v);
            }
        }
    }
    return dis[T]>0;
}
bool vis[M];
int dfs(int u=S,int flow=INF)
{
    if(u==T)return flow;
    vis[u]=true;
    int rm=flow;
    for(int i=cur[u];i&&rm;i=e[i].nxt)
    {
        cur[u]=i;
        int vol=e[i].w,v=e[i].v;
        if(vol>0&&!vis[v]&&abs(dis[v]-dis[u]*e[i].c)<=eps) //精度问题/ll
        {
            int c=dfs(v,min(rm,vol));
            rm-=c,e[i].w-=c,e[i^1].w+=c;
        }
    }
    vis[u]=false;
    return flow-rm;
}
void dinic()
{
    while(spfa())
        dfs();
    return;
}

bool ans[N][N];
int main()
{
    int n,m,a,b,p;
    in(n),in(m);
    //建图
    S=0,T=n+m+1;
    fo(i,1,n)fo(j,1,m)
        in(p),link(i,j+n,1,p*0.01);
    fo(i,1,n)
        in(a),link(S,i,a,1);
    fo(i,1,m)
        in(b),link(i+n,T,b,1);
    dinic();
    //遍历
    fo(i,1,n)
        for(int j=head[i];j;j=e[j].nxt)
            if(!e[j].w)
                ans[i][e[j].v-n]=true;
    for(int i=1;i<=n;++i,puts(""))
        fo(j,1,m)
            out(ans[i][j]);
    return 0;
}

```



---

## 作者：Great_Influence (赞：3)

网络流。

虽然没什么好说的，但是，网络流的边权也可以用连乘来计算。直接用几率(设为$p$)当做边权，反向边的边权就是$\frac{1}{p}$。spfa时，直接用$dis[v]=dis[u]*w$来更新边权。其本质和下面几位的取$\log$计算在相加是相同的，但是精度会更高。然后就和一般的网络流没什么区别了。问题就变成了一个简单的二分图权匹配。

代码：

```cpp
#include<bits/stdc++.h>
#include<cctype>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
#define Chkmax(a,b) a=a>b?a:b
#define Chkmin(a,b) a=a<b?a:b
using namespace std;
template<typename T>inline void read(T &x){
    T s=0,f=1;char k=getchar();
    while(!isdigit(k)&&k^'-')k=getchar();
    if(!isdigit(k)){f=-1;k=getchar();}
    while(isdigit(k)){s=s*10+(k^48);k=getchar();}
    x=s*f;
}
void file(void){
    #ifndef ONLINE_JUDGE
    freopen("water.in","r",stdin);
    freopen("water.out","w",stdout);
    #endif
}
const int MAXN=511;
static int n,m;
static struct edge
{
    int v,nxt,f,x,y;
    double w;
}p[(MAXN<<3)+(MAXN*MAXN<<3)];
static int head[MAXN],e=1;
inline void add(int u,int v,int f,double w,bool lz=1,int x=0,int y=0)
{
    p[++e].v=v;p[e].f=f;p[e].w=w;p[e].nxt=head[u];head[u]=e;
    if(x)p[e].x=x,p[e].y=y;
    if(lz)add(v,u,0,1.0/w,0,x,y);
}
static int s,t;
void init()
{
    read(n);read(m);
    s=n+m+1;t=s+1;
    static int x;
    Rep(i,1,n)Rep(j,1,m)
    {
        read(x);
        if(x)add(i,j+n,1,0.01*x,1,i,j);
    }
    static int u;
    Rep(i,1,n)
    {
        read(u);
        if(u)add(s,i,u,1.0);
    }
    Rep(i,1,m)
    {
        read(u);
        if(u)add(i+n,t,u,1.0);
    }
}
static int a[MAXN][MAXN],vis[MAXN];
static deque<int>G;
static double dis[MAXN];
inline bool spfa(int s,int t)
{
    Rep(i,1,t)dis[i]=-1;
    dis[s]=1.0;G.push_back(s);
    static int u;vis[s]=true;
    while(!G.empty())
    {
        u=G.front();G.pop_front();
        for(register int v=head[u];v;v=p[v].nxt)
            if(p[v].f&&dis[p[v].v]<dis[u]*p[v].w)
            {
                dis[p[v].v]=dis[u]*p[v].w;
                if(!vis[p[v].v])
                {
                    vis[p[v].v]=true;
                    if(G.empty()||dis[p[v].v]>dis[G.front()])
                        G.push_front(p[v].v);
                    else G.push_back(p[v].v);
                }
            }
        vis[u]=false;
    }
    return dis[t]>0;
}
const int inf=0xFFFFFFF;
const double eps=0.000001;
static int cur[MAXN];
int dfs(int u,int t,int flow)
{
    if(!flow||u==t)return flow;
    vis[u]=true;
    int sum=0;
    for(register int&v=cur[u];v&&flow;v=p[v].nxt)
    {
        if(!vis[p[v].v]&&p[v].f
            &&fabs(dis[p[v].v]-dis[u]*p[v].w)<=eps)
        {
            int f=dfs(p[v].v,t,min(flow,p[v].f));
            if(f&&p[v].x)a[p[v].x][p[v].y]^=1;
            p[v].f-=f;p[v^1].f+=f;sum+=f;flow-=f;
        }
    }
    vis[u]=false;
    return sum;
}
inline void Dinic(int s,int t)
{
    while(spfa(s,t))memcpy(cur,head,sizeof cur),dfs(s,t,inf);
}
void solve()
{
    Dinic(s,t);
    Rep(i,1,n)
    {Rep(j,1,m)printf("%d",a[i][j]);putchar('\n');}
}
int main(void){
    file();
    init();
    solve();
    return 0;
}

```

---

## 作者：7KByte (赞：2)

费用流：行列模型  
对于每个点所在$(i,j)$，从$i$向$j$连一条容量1，费用$log(x)$的边，因为我们要将乘法转化为加法然后跑最大费用流，然后源点连行，列连汇点（反过来也行），跑完最大费用流后，如果第i行到第j列的边有流量说明$(i,j)$为1，否则为零   




如果大佬您会zkw费用流，以下的内容可以跳过  



------------------
很显然，建完图后这是一张稠密图，用zkw流可以很方便的解决，然而蒟蒻并不会  
然后开始了艰辛而又快乐（tongku）的SPFA常数优化  
- 1.手写队列替代STL队列  
- 2.register寄存器常数优化  
- 3.函数inline和传址调用的优化  
- 4.快速读入和快速输出优化  
- 5.对于$0$到$100$的的$log$优化，提前打一张表
- 6.$double$改成$float$的常数优化  
- 7.不需要$MaxFlow$和$MaxCost$记录答案，因为我们不需要知道流和费用是多少
- 8.$STLfill$和$memset$函数优化，用于浮点数组和整数数组置初值  
- 9.在建图的时候直接记录下第$i$行到第$j$列对应的边，用数组$f[i][j]$记录，输出答案时直接查询  
- 10.对于概率为$0$%或概率为$100$%的点特判，不用加边，但对应的行列的点的初始容量（即源点连向行的边，列流向汇点的边的容量）要相应加减  
- 11.将结构体保存的边转化为多个连续数组，优化读写速度，因为连续的数组比相对不连续的结构体速度更快  
- 12.手动开启$O2,O3,Ofast$等  
- 13.在洛谷的低峰期提交，实测，同一份代码在$luogu$的不同时间提交会得到$70-100$分的不同结果  


-------------------

![](https://cdn.luogu.com.cn/upload/pic/50804.png)最大点(#10#11)$2000msAccepted$甚是无语……  
总用时$20000ms$卡过


$SPFA+EK+$ $\text{以上13条优化，相信你一定能AC}$

---

## 作者：kczno1 (赞：2)

很好想到的是，每行建一个点，每列建一个点，s向每行连费用=0，流量=该行点数的边；每列向t连费用=0，流量=该列点数的边。

表示选择的每行、每列中点数必须满足要求。

怎么保证x乘积最小呢？

可以转化为logx的和最小(因为都可转化为log(x的乘积))。

所以每个点<i,j>就从行i向列j连一条log边权的边。

网上说这题要用zkw费用流。然而我只会spfa+dfs的。

于是我通过卡常a了这题。最慢的点也只用200+ms。

细节:

1 log(x)转化为log(x\*一个数)，减小误差。

由于logx\*y=logx+logy，而选择的点的总数是一定的，所以logy的贡献在不同选择中是一样的，所以不会影响选择。

2 log(x\*一个数)转化为log(x\*一个数)\*一个很大数，转而用long long储存，加速！

double比long long慢多了。因为我们判断实数相等时是判1e-9的，所以乘个1e9后也不会有什么误差。

3 spfa+pb\_ds堆优化

更多请见代码

```cpp
#pragma GCC optimize("O2")
#include<bits/stdc++.h>
using namespace std;
#include<ext/pb_ds/priority_queue.hpp>
using namespace __gnu_pbds;

#define ll long long 
#define oo 1e18
#define N 300
#define M 100000
int n,m,s,t,i,j,x,y;
struct edge
{
    int to,f;
    ll w;
    int next;
}l[M];int e;
int head[N];

void add(int x,int y,int f,const ll &w)
{
    l[++e]=(edge){y,f,w,head[x]};head[x]=e;
    l[++e]=(edge){x,0,-w,head[y]};head[y]=e;
}

ll g[N];
struct g_xiao
{
__inline__ __attribute((always_inline)) bool operator()(int y,int x)
    {
        return g[x]>g[y];
    }
};
typedef __gnu_pbds::priority_queue<int,g_xiao> heap;
heap q;
heap::point_iterator dy[N];
ll base;
bool spfa()//反向跑最长路 
{
    for (i=1;i<t;++i) g[i]=-oo;
    q.push(t);
    do
    {
        x=q.top();dy[x]=0;
        q.pop();
        base=g[x];
        for (i=head[x];i;i=l[i].next)
        if (l[i^1].f&&g[y=l[i].to]<base-l[i].w)
        {
            g[y]=base-l[i].w;
            if (dy[y]!=0) q.modify(dy[y],y);
            else dy[y]=q.push(y);
        }
    }while (!q.empty());
    
    return g[s]!=-oo;
}

#define I a[x]
bool ing[N];
bool Find;
int a[N];
void dfs(int x)//正向搜索 
{
    if (x==t)
    {
        Find=1;return ;
    }
    
    ing[x]=1;
    int y;ll now=g[x];
    for (;I;I=l[I].next)
    if (l[I].f&&!ing[y=l[I].to]&&g[y]+l[I].w==now) 
    {
        dfs(y);
        if (Find)
        {
            --l[I].f;++l[I^1].f;
            ing[x]=0;
            return;
        }
    }
    ing[x]=0;
}

int _e;
bool ans[N][N];
void get_ans()
{
    for (i=2;i<=_e;i+=2) 
    if (!l[i].f)
     ans[l[i+1].to][l[i].to]=1;
    for (i=1;i<=n;++i)
    {
        for (j=1;j<=m;++j) printf("%d",ans[i][n+j]);
        printf("\n");
    }
}

ll dy_w[100];

int main()
{ //freopen("1.in","r",stdin);freopen("1.out","w",stdout);
    scanf("%d%d",&n,&m);
    s=n+m+1;t=s+1;
    e=1;
    for (i=1;i<100;++i) dy_w[i]=log2(i<<20)*1000000000;
    for (i=1;i<=n;++i)
    for (j=1;j<=m;++j)
    {
        scanf("%d",&x);
        if (x) add(i,n+j,1,dy_w[x]);
    }
    _e=e;
    for (i=1;i<=n;++i) 
    {
        scanf("%d",&x);add(s,i,x,0);
    }
    for (i=1;i<=m;++i) 
    {
        scanf("%d",&x);add(n+i,t,x,0);
    }
    
    while (spfa())
    {
        for (i=1;i<=t;++i) a[i]=head[i];
        while (dfs(s),Find) Find=0;
    }
    get_ans(); 
}
```

---

## 作者：revenger (赞：1)

前一位发题解的神犇成功使用高端黑科技平板电视(pb\_ds)卡进了0.5s的时限。

但是我比较蒻，被第五个点卡得生无可恋=\_=还好管理员高抬贵手放宽了时限。

好吧言归正传，下面介绍ZKW费用流写法。

zkw的基本思路是多路增广，通过spfa预处理出dis数组，然后进行dfs。

这种算法在稠密图中明显优于spfa。

好吧如果不懂的自行百度zkw吧，很多神犇的博客中都有详细介绍。

下面贴出自己被卡得生无可恋的代码

    
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<cmath>
using namespace std;
int head[1010],point[100010],nxt[100010],remain[100010],sum;
long long w[100010];
int n,m,x;
queue<int>q;
int exist[1010],vis[1010];
long long dis[1010];
const long long longinf=(1ll<<60);
const int inf=1e9+7;
int t[1019];
int fs[101][101];
#define min(a,b) (a<b?a:b)
inline void add(int x,int y,int flow,long long cost)
{
    ++sum;nxt[sum]=head[x];head[x]=sum;point[sum]=y;remain[sum]=flow;w[sum]=cost;
    ++sum;nxt[sum]=head[y];head[y]=sum;point[sum]=x;remain[sum]=0;w[sum]=-cost;
}
inline bool spfa(int s,int t)
{
    for(int i=s;i<=t;i++)
    dis[i]=longinf;
    dis[t]=0;
    q.push(t);
    while(!q.empty())
    {
        int now=q.front();q.pop();
        exist[now]=0;
        for(int tmp=head[now];tmp!=-1;tmp=nxt[tmp])
        {
            int u=point[tmp];
            long long v=w[tmp^1];
            if(dis[u]>dis[now]+v&&remain[tmp^1])
            {
                dis[u]=dis[now]+v;
                if(!exist[u])
                {
                    q.push(u);
                    exist[u]=1;
                 } 
            }
        }
    }
    return dis[s]<longinf;
}
inline int dfs(int x,int t,int limit)
{
    vis[x]=1;
    if(x==t||!limit) return limit;
    int flow=0,f;
    for(int tmp=head[x];tmp!=-1;tmp=nxt[tmp])
    {
        int u=point[tmp];
        long long v=w[tmp];
        if((dis[u]==dis[x]-v)&&remain[tmp]&&!vis[u])
        {
            f=dfs(u,t,min(limit,remain[tmp]));
            flow+=f;
            limit-=f;
            remain[tmp]-=f;
            remain[tmp^1]+=f;
            if(x!=0&&u!=n+m+1)
            {
                if(x>n)
                fs[u][x-n]=1-remain[tmp^1];
                else
                fs[x][u-n]=1-remain[tmp];
            }
            if(!limit) return flow;
        }
    }
    return flow;
}
inline void zkw(int s,int t)
{
    while(spfa(s,t))
    {
        do
        {
            for(int i=s;i<=t;i++)
            vis[i]=0;
            dfs(s,t,inf);
        }
        while(vis[t]);
    }
}
inline void read(int &ans,char ch=getchar())
{
    ans=0;
    for(;ch<'0'||ch>'9';ch=getchar());
    for(;ch>='0'&&ch<='9';ans=ans*10+ch-48,ch=getchar());
} 
int main()
{
    memset(nxt,-1,sizeof(nxt));
    memset(head,-1,sizeof(head));
    sum=-1;
    read(n),read(m);
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    {
        read(x);
        if(!x) continue;
        x*=100000;
        double s=log2(x);
        s*=inf;
        long long d=s;
        add(i,j+n,1,-d);
    }
    for(int i=1;i<=n;i++)
    {
        read(x);
        add(0,i,x,0);
    }
    for(int i=1;i<=m;i++)
    {
        read(x);
        add(i+n,n+m+1,x,0);
    }
    zkw(0,n+m+1);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        putchar(fs[i][j]+48);
        puts("");
     } 
}
```

---

## 作者：ivyjiao (赞：0)

这题千万别想歪了……

数据范围就这么点，然后一眼看过去也不是什么爆搜或者状压 dp 之类的，就想想能不能建出网络流模型。

很明显一个点要么是黑点要么是白点，我们钦定 $s$ 为黑点部分，$t$ 为白点部分，那么这题就是一个典型的最小割模型。

但是这题并没有一个显然的最小割模型构建方式，考虑放弃 $s$ 和 $t$ 的身份，直接从最大流考虑。

我们钦定一个格子为黑色，就相当于在网络流中使这条边满流（贡献了一个黑色格子），这样设 $i$ 为第 $i$ 行，$i+n$ 为第 $i$ 列，那么我们就可以得出建边方式：

1. $s\to i$ 建流量为 $a_i$，费用为 $1$ 的边。
2. $i+n\to t$ 建流量为 $b_i$，费用为 $1$ 的边。

这样满流的时候第 $i$ 行的总流量是 $a_i$，第 $i$ 列的总流量是 $b_i$，满足题意。

根据定义，我们可以得到：对于每个格子 $(i,j)$，从 $i$ 到 $j+n$ 连流量为 $1$，费用为 $p_{i,j}\div 100$ 的边。

让选择的点权值之积最大，就是使满流的时候费用最大，所以跑最大费用最大流。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define PII pair<int,int>
#define fi first
#define se second
using namespace std;
const int N=501,inf=1e9;
int n,m,s,t,p[N][N],a[N],b[N],ans[N][N],mcmf[N];
double dis[N];
struct node{
    int v,w,l;
    double f;
};
vector<node>G[N];
PII now[N];
bool bfs(){
    for(int i=1;i<=t;i++) dis[i]=-inf;
    queue<int>q;
    q.push(s);
    dis[s]=0;
    now[s]={s,0};
    mcmf[s]=inf;
    while(q.size()){
        int u=q.front();
        q.pop();
        for(int i=0;i<G[u].size();i++){
            int v=G[u][i].v;
			if(G[u][i].w&&dis[v]<dis[u]*G[u][i].f){
                q.push(v);
				now[v]={u,i};
                mcmf[v]=min(mcmf[u],G[u][i].w);
				dis[v]=dis[u]+G[u][i].f;
            }
        }
    }
	return dis[t]!=-inf;
}
signed main(){
    cin>>n>>m;
    s=n+m+1,t=n+m+2;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>p[i][j];
            G[i].push_back({j+n,1,G[j+n].size(),p[i][j]*0.01});
            G[j+n].push_back({i,0,G[i].size()-1,-p[i][j]*0.01});
        }
    }
    for(int i=1;i<=n;i++){
        cin>>a[i];
        G[s].push_back({i,a[i],G[i].size(),1});
        G[i].push_back({s,0,G[s].size()-1,-1});
    }
    for(int i=1;i<=m;i++){
        cin>>b[i];
        G[i+n].push_back({t,b[i],G[t].size(),1});
        G[t].push_back({i+n,0,G[i+n].size()-1,-1});
    }
    while(bfs()){
		int x=t;
		while(x!=s){
            int u=now[x].fi,v=now[x].se;
			G[u][v].w-=mcmf[t];
			G[x][G[u][v].l].w+=mcmf[t];
			x=G[x][G[u][v].l].v;
		}
    }
    for(int i=1;i<=n;i++){
        for(int j=0;j<G[i].size();j++){
            if(!G[i][j].w) ans[i][G[i][j].v-n]=1;
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++) cout<<ans[i][j];
        cout<<endl;
    }
}
```

---


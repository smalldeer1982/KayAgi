# [HEOI2012] 朋友圈

## 题目背景

原 双塔 请做P1651

## 题目描述

在很久很久以前，曾经有两个国家和睦相处，无忧无虑的生活着．

一年一度的评比大会开始了，作为和平的两国，一个朋友圈数量最多的永远都是最值得他人的尊敬，所以现在就是需要你求朋友圈的最大数目．两个国家看成是 AB 两国，现在是两个国家的描述：

- A 国：每个人都有一个友善值，当两个 A 国人的友善值 $a,b$，如果 $(a\mathbin{\mathrm{xor}} b) \bmod 2=1$，那么这两个人都是朋友，否则不是；
- B 国：每个人都有一个友善值，当两个 B 国人的友善值 $a,b$，如果 $(a\mathbin{\mathrm{xor}} b) \bmod 2=0$ 或者 $(a\mathbin{\mathrm{or}} b)$ 化成二进制有奇数个 $1$，那么两个人是朋友，否则不是朋友．

A、B 两国之间的人也有可能是朋友，数据中将会给出 A、B 之间「朋友」的情况．

对于朋友的定义，关系是是双向的．

在 AB 两国，朋友圈的定义：一个朋友圈集合 $S$，满足 $S \subset A \cup B$，对于所有的 $i,j \in S$，$i$ 和 $j$ 是朋友．


## 说明/提示

### 样例解释

最大朋友圈包含 A 国第 $1,2$ 人和 B 国第 $1,2,3$ 人．

### 数据范围

对于 $100\%$ 的数据，$1 \le T \le 6$，$1 \le a_i, b_i < 2^{31}$．

本题共有两类数据，保证所有测试点均满足其中至少一类的限制：

- 第一类：$1 \le A \le 200, 1 \le B \le 200$．
- 第二类：$1 \le A \le 10, 1 \le B \le 3000$．

## 样例 #1

### 输入

```
1
2 4 7
1 2
2 6 5 4
1 1
1 2
1 3
2 1
2 2
2 3
2 4```

### 输出

```
5
```

# 题解

## 作者：Monster_Qi (赞：19)

直接跑无向图最大团洛谷上能得70分，惊了。说说正解，首先A国的必须xor后mod2余1，就相当于两个人必须是1奇1偶，所以A国的人只能选0,1,2个，我们可以暴力枚举选谁。继续考虑B国，现在的问题实际上就简化为了在B国中选出一个最大团，这个团也必须和A国所选出的人是朋友，又因为最大团=总点数-补图的最大匹配，补图就是将原来连着的边断了，原来没连的边连上，而进一步可以发现其实B国的补图是一个二分图，左部点是%2余1的，右部点是%2余0的，如果它们或起来有偶数个1就可以连边，然后就是二分图中求一个最大匹配，我用的匈牙利卡了过去。。好像这道题特殊数据可以卡死匈牙利，哪位大佬有扔一个谢谢了。
码风应该是比较正常的。


## 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>

using namespace std;
const int MAXN = 3205;
const int MAXM = 1500*1500+5;

inline int rd(){
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)) {f=ch=='-'?0:1;ch=getchar();}
	while(isdigit(ch))  {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return f?x:-x;
}

int T,A,B,M,head[MAXM],cnt,ans;
int to[MAXM],nxt[MAXM],now;
int a[MAXN],b[MAXN],e[MAXN][MAXN];
int num,t,vis[MAXN],flag[MAXN],match[MAXN];

inline void add(int bg,int ed){
	to[++cnt]=ed,nxt[cnt]=head[bg],head[bg]=cnt;
}

inline bool dfs(int x){
	for(register int i=head[x];i;i=nxt[i]){
		int u=to[i];
		if(vis[u]!=num && flag[u]==t){
			vis[u]=num;
			if(!match[u] || dfs(match[u])){
				match[u]=x;
				return true;
			}
		}
	}
	return false;
}

int main(){
	T=rd(); 
	A=rd();B=rd();M=rd();
	for(register int i=1;i<=A;i++) a[i]=rd();
	for(register int i=1;i<=B;i++) b[i]=rd();
	for(register int i=1;i<=B;i++)if((b[i]&1)) //建补图。 
		for(register int j=1;j<=B;j++) 
			if(!(b[j]&1) && !((__builtin_popcount((b[i]|b[j])))&1)) add(i,j);
				//__builtin_popcount 查询二进制下1的个数，偷了个懒，联赛最好不要用吧。。 
	for(register int i=1;i<=M;i++) {
		int x=rd(),y=rd();
		e[x][y+A]=e[y+A][x]=1;
	}
	for(register int i=1;i<=B;i++)if((b[i]&1)){  //A中的点都不选。 
		num++;
		if(dfs(i)) ans++;
 	}ans=B-ans;  //最大团=总点数-补图的最大匹配。 
	for(register int i=1;i<=A;i++){   //枚举A中选1个点 
		t++;int sum=0;now=0;
		memset(match,0,sizeof(match));
		for(register int j=1;j<=B;j++)
			if(e[i][j+A]) flag[j]=t,now++; //记录有几个点在子图里 
		for(register int j=1;j<=B;j++)
			if(flag[j]==t && (b[j]&1)) {
				num++;  //不memset,时间戳 
				if(dfs(j)) sum++; 
			}
		ans=max(ans,now-sum+1); //加上A中的那个点 
	}
	for(register int i=1;i<=A;i++) //枚举A中选2个点 
		for(register int j=i+1;j<=A;j++)if((a[i]^a[j])&1){
			memset(match,0,sizeof(match));
			t++;int sum=0;now=0;
			for(register int k=1;k<=B;k++)
				if(e[i][k+A] && e[j][k+A]) flag[k]=t,now++;
			for(register int k=1;k<=B;k++)
				if(flag[k]==t && (b[k]&1)) {
					num++;
					if(dfs(k)) sum++;
				}
			ans=max(ans,now-sum+2); //加上A中那两个点 
		}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：asuldb (赞：9)

[题目](https://www.luogu.org/problemnew/show/P2423)



我们发现我们要求的是一个最大团问题，众所周知这是一个$NP$难问题，除了爆搜没有什么别的方法，但是这道题我们可以根据图的特殊性质入手

我们如果把$B$国的人分成奇数和偶数两类，就会发现奇数和偶数这两部分都是一个团

而且这两部分之间有一些连边

很像二分图是吧，就只是左右两边的点从两两没边变成了两两有边

于是我们取一个补图，这张图就变成了一张二分图

补图有一个非常好的性质，**补图最大独立集等于原图最大团**

这个很好理解吗，最大团要求两两有边，最大独立集要求两两没边，于是把边的存在性取反之后两者是等价的

而二分图的**最大独立集等于总点数-最小点覆盖**

**最小点覆盖等于最大匹配**

于是$B$国的情况我们就解决了

再来看看$A$国和跨国关系

发现$A$国中只能选择$0,1,2$人，于是我们枚举在$A$国里选择哪些人，之后处理出$B$国中的和这些人都有朋友关系的人，对这些点跑最大独立集就好了

之后就是如何跑最大匹配的问题了，发现全网都是时间戳优化的匈牙利

毕竟匈牙利不用每次都重构图

但是我$Dinic$不服！

只要控制好数组的大小，$Dinic$也是能跑过去的

代码

```cpp
#include<queue>
#include<vector>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
#define LL long long
#define inf 999999999
#define lowbit(i) ((i)&(-i))
#define re register
#define maxn 5005
inline int read() {
    int x=0;char c=getchar();while(c<'0'||c>'9') c=getchar();
    while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=getchar();return x;
}
std::vector<int> v[maxn];
std::queue<int> q;
struct E{int v,nxt,f;}e[2000005];
int n,m,K,tot,ans,S,T,sz;
int num=1,a[3005],b[3005],vis[3005],pr[3005];
int st[2][5005],top[2];
int head[maxn],cur[maxn],d[maxn];
int U[900005],V[900005];
inline void add(int x,int y,int f) {e[++num].v=y;e[num].nxt=head[x];head[x]=num;e[num].f=f;}
inline void C(int x,int y,int f) {add(x,y,f),add(y,x,0);}
inline int count(int x) {
    int now=0;
    while(x) {now^=1,x-=lowbit(x);}
    return now;
}
inline int BFS() {
    cur[S]=head[S],d[T]=0,cur[T]=head[T];
    for(re int i=1;i<=sz;i++) d[pr[i]]=0,cur[pr[i]]=head[pr[i]];
    d[S]=1,q.push(S);
    while(!q.empty()) {
        int k=q.front();q.pop();
        for(re int i=head[k];i;i=e[i].nxt)
        if(e[i].f&&!d[e[i].v]) d[e[i].v]=d[k]+1,q.push(e[i].v);
    }
    return d[T];
} 
int dfs(int x,int now) {
    if(x==T||!now) return now;
    int flow=0,ff;
    for(re int& i=cur[x];i;i=e[i].nxt) 
    if(d[e[i].v]==d[x]+1) {
        ff=dfs(e[i].v,min(now,e[i].f));
        if(ff<=0) continue;
        now-=ff,flow+=ff,e[i].f-=ff,e[i^1].f+=ff;
        if(!now) break;
    }
    return flow;
}
inline void Dinic(int val) {
    int now=val;
    while(BFS()) {
        now-=dfs(S,inf);
        if(now<=ans) return; 
    }
    ans=now;
}
inline void Connect() {
    num=1;memset(head,0,sizeof(head));
    sz=0;for(re int i=1;i<=m;i++) if(vis[i]) pr[++sz]=i;
    for(re int i=1;i<=tot;i++) if(vis[U[i]]&&vis[V[i]]) C(U[i],V[i],1);
    for(re int i=1;i<=top[0];i++) if(vis[st[0][i]]) C(S,st[0][i],1);
    for(re int i=1;i<=top[1];i++) if(vis[st[0][i]]) C(st[1][i],T,1);
}
inline void make(int x) {
    memset(vis,0,sizeof(vis));
    for(re int i=0;i<v[x].size();i++) vis[v[x][i]]++;
    int P=1;
    for(re int i=1;i<=m;i++) P+=vis[i];
    if(P<=ans) return;
    Connect();Dinic(P);
}
inline void choice(int x,int y) {
    memset(vis,0,sizeof(vis));
    for(re int i=0;i<v[x].size();i++) vis[v[x][i]]++;
    for(re int i=0;i<v[y].size();i++) vis[v[y][i]]++;
    int P=2;
    for(re int i=1;i<=m;i++) {
        if(vis[i]<2) vis[i]=0;else vis[i]=1;
        P+=vis[i];
    }
    if(P<=ans) return;
    Connect();Dinic(P);
}
int main() {
    n=read(),n=read(),m=read(),K=read();S=0,T=m+1;
    for(re int i=1;i<=n;i++) a[i]=read();
    for(re int i=1;i<=m;i++) {
        b[i]=read();st[b[i]&1][++top[b[i]&1]]=i;
    }
    for(re int i=1;i<=m;i++) pr[++sz]=i;
    for(re int i=1;i<=top[0];i++)
        for(re int j=1;j<=top[1];j++)
            if(!count(b[st[0][i]]|b[st[1][j]])) 
                U[++tot]=st[0][i],V[tot]=st[1][j];
    for(re int i=1;i<=tot;i++) C(U[i],V[i],1);
    for(re int i=1;i<=top[0];i++) C(S,st[0][i],1);
    for(re int i=1;i<=top[1];i++) C(st[1][i],T,1);
    Dinic(m);
    for(re int x,y,i=1;i<=K;i++) x=read(),y=read(),v[x].push_back(y);
    for(re int i=1;i<=n;i++) make(i);
    for(re int i=1;i<=n;i++) 
    	for(re int j=i+1;j<=n;j++) if((a[i]^a[j])&1) choice(i,j);
    printf("%d\n",ans);
    return 0;
}
```


---

## 作者：lemir3 (赞：7)

## 题目分析

题目要求求最大团.

我们从题中的性质入手,看到这一条

> B国：每个人都有一个友善值，当两个B国人的友善值a、b，如果a xor b mod 2=0 或者 (a or b)化成二进制有奇数个1，那么两个人是朋友，否则不是朋友；

显然可知,在b国中,友善值都为奇数的互相是朋友,都为偶数的互相也是朋友,两个人奇偶性不一样的话就不一定是.

于是按照奇偶性把b国人分为2类,所以左边是一个团,右边也是一个团,中间有一些边相连.

运用广大劳动人民的智慧,我们把这张图取反,就得到了一张二部图.

于是我们在建图的时候,将b国中a与b奇偶性不同,a or b有偶数个1的人连边.

因为是补图,所以补图的最大独立集就等于原图的最大团.

这一点应该很好理解,最大独立集是要选最多的点互不相邻,取反后就成了让最多的点联通.

然后最大独立集等于最大匹配,这个记结论即可.

现在考虑连上a国的人,因为a国的性质很怪,团中的人必须奇偶性两两相反,所以不可能有2个以上的人在团中,所以直接爆搜1个人或2个人即可.

每次重新建图跑即可.

## 代码

```cpp
#include "iostream"
#include "cstdio"
#include "cstring"
#include "cstdlib"
#include "cctype"
#include "cmath"
#include "algorithm"
#include "set"
#include "queue"
#include "stack"
#include "vector"
#include "map"
#define lxl long long
#define R register
#define INF 0x3f3f3f3f
#define debug(x) printf("debug:%lld\n",x)
#define lowbit(x) (x&(-x))
using namespace std;
const lxl maxn=5010,maxm=900010,big=3010;
lxl n,m,k,st,ed,EdgeSize,ans,sz;
lxl a[big],b[big],top[2],st_[2][maxn],pr[big],head[maxn],cur[maxn],u[maxm],v[maxm],dis[maxm],vis[big];
vector<lxl>v_[maxn];
queue<lxl>q;
struct _Edge
{
	lxl to,next,last;
}e[maxn*400];
inline lxl read()
{
	char c=getchar();
	lxl f=1,x=0;
	for(;!isdigit(c);c=getchar())(c=='-')&&(f=-1);
	for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
	return f*x;
}
inline bool count(lxl x)
{
	bool now=false;
	for(;x;x-=lowbit(x))now^=true;
	return now;
}
inline void EdgeAdd(lxl from,lxl to,lxl flow)
{
	e[EdgeSize].to=to;
	e[EdgeSize].last=flow;
	e[EdgeSize].next=head[from];
	head[from]=EdgeSize++;
}
inline void coc(lxl u,lxl v,lxl flow)
{
	EdgeAdd(u,v,flow),EdgeAdd(v,u,0);
}
inline bool bfs()
{
	cur[st]=head[st],cur[ed]=head[ed],dis[ed]=0;
	for(R int i(1);i<=sz;++i)cur[pr[i]]=head[pr[i]],dis[pr[i]]=0;
	dis[st]=1,q.push(st);
	while(!q.empty())
	{
		lxl now=q.front();
		q.pop();
		for(R int i=head[now],to,last_;~i;i=e[i].next)
		{
			to=e[i].to,last_=e[i].last;
			if(last_>=1&&(!dis[to]))
			{
				dis[to]=dis[now]+1;
				q.push(to);
			}
		}
	}
	return dis[ed];
}
lxl dfs(lxl now,lxl flow)
{
	lxl sum=0;
	if(now==ed||(!flow))return flow;
	for(R lxl &i=cur[now],to,last_;~i;i=e[i].next)
	{
		to=e[i].to,last_=e[i].last;
		if(dis[to]==dis[now]+1&&last_>=1)
		{
			lxl f=dfs(to,min(flow-sum,last_));
			e[i].last-=f;
			e[i^1].last+=f;
			sum+=f;
			if(sum==flow)return sum;
		}
	}
	return sum;
}
inline void dinic(lxl val)
{
	lxl now=val;
	while(bfs())
	{
		now-=dfs(st,INF);
		if(now<=ans)return;
	}
	ans=now;
}
inline void con()
{
	EdgeSize=0,sz=0;
	memset(head,-1,sizeof(head));
	for(R int i(1);i<=m;++i)if(vis[i])pr[++sz]=i;
	for(R int i(1);i<=u[0];++i)if(vis[u[i]]&&vis[v[i]])coc(u[i],v[i],1);
	for(R int i(1);i<=top[0];++i)if(vis[st_[0][i]])coc(st,st_[0][i],1);
	for(R int i(1);i<=top[1];++i)if(vis[st_[1][i]])coc(st_[1][i],ed,1);
}
inline void one(lxl x)
{
	memset(vis,0,sizeof(vis));
	for(R int i(0);i<v_[x].size();++i)++vis[v_[x][i]];
	lxl p=1;
	for(R int i(1);i<=m;++i)p+=vis[i];
	if(p<=ans)return;
	con(),dinic(p);
}
inline void two(lxl x,lxl y)
{
	memset(vis,0,sizeof(vis));
	for(R int i(0);i<v_[x].size();++i)++vis[v_[x][i]];
	for(R int i(0);i<v_[y].size();++i)++vis[v_[y][i]];
	lxl p=2;
	for(R int i(1);i<=m;++i)
	{
		if(vis[i]>=2)vis[i]=1;
		else vis[i]=0;
		p+=vis[i];
	}
	if(p<=ans)return;
	con(),dinic(p);
}
int main(void)
{
	memset(head,-1,sizeof(head));
	n=read(),n=read(),m=read(),k=read();
	st=0,ed=m+1;
	for(R int i(1);i<=n;++i)a[i]=read();
	for(R int i(1);i<=m;++i)
	{
		b[i]=read();
		st_[b[i]&1][++top[b[i]&1]]=i;
		pr[++sz]=i;
	}
	for(R int i(1);i<=top[0];++i)
		for(R int j(1);j<=top[1];++j)
			if(!count(b[st_[0][i]]|b[st_[1][j]]))
				u[++u[0]]=st_[0][i],v[u[0]]=st_[1][j];
	for(R int i(1);i<=u[0];++i)coc(u[i],v[i],1);
	for(R int i(1);i<=top[0];++i)coc(st,st_[0][i],1);
	for(R int i(1);i<=top[1];++i)coc(st_[1][i],ed,1);
	dinic(m);
	for(R int i(1),u,v;i<=k;++i){u=read(),v=read(),v_[u].push_back(v);}
	for(R int i(1);i<=n;++i)one(i);
	for(R int i(1);i<=n;++i)
		for(R int j(i+1);j<=n;++j)
			if((a[i]^a[j])&1)two(i,j);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：MoyunAllgorithm (赞：3)

**题意**

一张图有 $A+B$ 个点，$A$ 个 $A$ 类点，$B$ 个 $B$ 类点。点有权值。两个 $A$ 类点的权值的异或和若是奇数，则有边；两个 $B$ 类点的权值的异或和若是偶数，或者按位与的和的二进制有奇数个 $1$ 则有边。会告诉你 $A$ 类点连向 $B$ 类点的边。求这张图的最大完全子图。

可以接受 $O(A^2B^2)$。

**分析**

首先：$x \oplus y$ 为奇数代表 $x,y$ 奇偶性不同；偶数代表相同。

可以发现：$A$ 中你最多只能选 $2$ 个点，这样才能奇偶性两两不同。

那就是说，答案等于 $A$ 中选择 $0/1/2$ 个，之后找到它们共同的 $B$ 朋友，之后找到这些 $B$ 朋友构成的图中的最大完全子图。为什么？因为 $A$ 中选出的这些点必定和它们共同的 $B$ 朋友两两有边，所以只需要计算 $B$ 朋友之间的连边情况。

考虑建立 $B$ 的**补图**。它是一个二分图。给它求最大独立集等价于原图的最大完全子图：因为独立集中两两无边，因此在原图中两两右边。问题解决qwq。

梳理一下流程：

首先求出 $B$ 的补图的最大独立集。这是 $A$ 中选 $0$ 个的答案。

之后，枚举 $A$ 中选了哪个，之后找到它的 $B$ 朋友，找到 $B$ 中这些朋友构成的子图，给它的补图跑最大独立集；

最后，枚举 $A$ 中选了哪 $2$ 个，之后找到它们**共同**的 $B$ 朋友（是交集而不是并集！），找到 $B$ 中这些朋友构成的子图，给它的补图跑最大独立集。

时间复杂度为 $O(A^2B^2)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=3005;
int A,B,M;
int mat[MAXN];
int vis[MAXN],mark[MAXN];
int a[MAXN],b[MAXN];
int ans=0;
vector<int>gra[MAXN];
vector<int>fri[MAXN];
bool Hungarian(int u,int tim,int anc)//匈牙利跑二分图最大匹配。tim是避免memset vis的变量；anc代表我选出的 A 的点，保证我只在 B 朋友构成的子图中进行
{
	if(vis[u]==tim) return 0;
	vis[u]=tim;
	for(auto v:gra[u])
	{
		if(mark[v]!=anc) continue;
		if(mat[v]==0||Hungarian(mat[v],tim,anc)) 
		{
			mat[v]=u;
			return 1;
		}
	}
	return 0;
}
int PopCount(int x)
{
	int res=0;
	while(x)
	{
		res+=(x&1);
		x>>=1;
	}
	return res;
}
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d %d %d",&A,&B,&M);
		memset(vis,0,sizeof(vis));
		memset(mat,0,sizeof(mat));
		memset(mark,0,sizeof(mark));
		for(int i=1;i<=A;i++) scanf("%d",&a[i]);
		for(int i=1;i<=A;i++) fri[i].clear();
		for(int i=1;i<=B;i++) scanf("%d",&b[i]);
		for(int i=1;i<=B;i++) gra[i].clear();
		for(int i=1;i<=B;i++)
		{
			if(!(b[i]&1)) continue;
			for(int j=1;j<=B;j++)
			{
				if(b[j]&1) continue;
			//	printf("b%d %d\n",i,j);
				int val=(b[i]|b[j]);
				if(!(PopCount(val)&1) )
				{
					gra[i].push_back(j); 
			//		printf("BUILD%d %d\n",i,j);
				}
			}
		}//补图！注意：二分图是有向的，规定奇数连偶数
		for(int i=1;i<=M;i++)
		{
			int x,y;
			scanf("%d %d",&x,&y);
			fri[x].push_back(y);
		}
		int tim=0;
		ans=0;
		for(int i=1;i<=B;i++)//0
			if(b[i]&1)
				if(Hungarian(i,++tim,0)) ans++;
		ans=B-ans;
	//	printf("ANS:%d\n",ans);
		for(int i=1;i<=A;i++)//1
		{
			memset(vis,0,sizeof(vis));
			memset(mat,0,sizeof(mat));
			for(auto v:fri[i]) mark[v]=i;
			tim=0;
			int res=0;
			for(auto v:fri[i])
				if(b[v]&1) 
					if(Hungarian(v,++tim,i)) res++;
			int x=fri[i].size();
			ans=max(ans,x-res+1);
		//	printf("%d %d %d %d\n",i,x,res,x-res+1);
		}
		for(int i=1;i<=A;i++)//2
		{
			for(int j=i+1;j<=A;j++)
			{
				if(!((a[i]&1)^(a[j]&1))) continue;
				bool isi[MAXN];
				memset(isi,0,sizeof(isi));
				for(auto v:fri[i]) isi[v]=1;
				int x=0;
				for(auto v:fri[j])
				{
					if(isi[v]) mark[v]=i*A+j,x++;
                    //在这里我将(i,j)视作一个数
				} 
				memset(vis,0,sizeof(vis));
				memset(mat,0,sizeof(mat));
				tim=0;
				int res=0;
				for(auto v:fri[j])
				{
					if(mark[v]==i*A+j&&(b[v]&1))
						if(Hungarian(v,++tim,i*A+j)) res++;
				}
			//	printf("%d %d %d %d %d\n",i,j,x,res,x-res+1);
				ans=max(ans,x-res+2);
			}
		}
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：FutaRimeWoawaSete (赞：2)

考虑到 $A$ 国显然之能选至多两个人，所以我们可以枚举选谁。

~~但是这也不应该能过。~~

接着考虑对于 $B$ 国，显然将奇数和偶数点分在两个集合中，那么原图中两个集合任意两点都有边，且有一些第二类边贡献了异奇偶的点。

我们发现，在枚举 $A$ 国中的点后我们现在相当于要从 $B$ 国中的一个点集选出一个最大团，考虑到图本身的性质，我们不妨对原图建立补图，显然集合内的点互相都不会连边，只会有异奇偶的点连边，问题转化成了求补图的最大匹配。

使用网络流即可，只能说能过。

```cpp
#include "bits/stdc++.h"
using namespace std;
const int Len = 3015 , Inf = 1e9;
#define bpc __builtin_popcount
int m,A,B,dep[Len],cur[Len],S,T,head[Len],cnt = 1;
int mp[Len][Len],a[Len],b[Len],flag[Len];
struct node
{
	int next,to,w;
}edge[Len * Len << 1];
void add(int from,int to,int w)
{
	edge[++ cnt].to = to;
	edge[cnt].next = head[from];
	edge[cnt].w = w;
	head[from] = cnt;
}
void addedge(int u,int v,int w)
{
	add(u , v , w);
	add(v , u , 0);
}
void Build_Graph()//遵循奇->偶连边 
{
	for(int i = 1 ; i <= B ; i ++)//这里被卡常了再来搞…… 
		for(int j = i + 1 ; j <= B ; j ++) 
		{
			int u = i , v = j;
			if(!flag[u] || !flag[v]) continue;
			if((b[u] & 1) == (b[v] & 1)) continue;
			if(bpc(b[u] | b[v]) & 1) continue;
			if(!(b[u] & 1)) swap(u , v);
			//printf("???%d %d\n",u,v);
			addedge(u , v , 1);
		}
}
void memhead(){for(int i = 0 ; i <= T + 5 ; i ++) head[i] = 0;}
bool BFS()
{
	queue<int> q;
	for(int i = 1 ; i <= T ; i ++) dep[i] = 0;
	dep[S] = 1;q.push(S);cur[S] = head[S];
	while(!q.empty())
	{
		int p = q.front();q.pop();
		for(int e = head[p] ; e ; e = edge[e].next)
		{
			int to = edge[e].to;
			if(!dep[to] && edge[e].w)
			{
				dep[to] = dep[p] + 1;
				cur[to] = head[to];
				q.push(to);
			}
		}
	}
	return dep[T];
}
int dfs(int u,int In)
{
	if(u == T) return In;
	int Out = 0;
	for(int e = cur[u] ; e && In > 0 ; e = edge[e].next)
	{
		cur[u] = e;
		int to = edge[e].to;
		if(edge[e].w && dep[to] == dep[u] + 1)
		{
			int res = dfs(to , min(In , edge[e].w));
			In -= res;
			Out += res;
			edge[e].w -= res;
			edge[e ^ 1].w += res;
		}
	}
	if(!Out) return dep[u] = 0;
	return Out;
}
int main()
{
	//freopen("1.in","r",stdin);
	//freopen("11.out","w",stdout);
	int TT;scanf("%d",&TT);
	while(TT --)
	{
		scanf("%d %d %d",&A,&B,&m);
		for(int i = 1 ; i <= A ; i ++) scanf("%d",&a[i]);
		for(int i = 1 ; i <= B ; i ++) scanf("%d",&b[i]);
		S = B + 1 , T = S + 1;
		for(int i = 1 ; i <= m ; i ++)
		{
			int u,v;scanf("%d %d",&u,&v);
			mp[u][v] = 1;
		}
		//选个啥呀
		int ans = 0 , res = 0;
		cnt = 1;memhead();
		for(int i = 1 ; i <= B ; i ++) 
		{
			flag[i] = 1;
			if(b[i] & 1) addedge(S , i , 1);
			else addedge(i , T , 1);
		}
		Build_Graph();
		while(BFS()) res += dfs(S , Inf);
		ans = max(ans , B - res);
		//puts("YES");
		for(int i = 1 ; i <= A ; i ++)
		{	
			cnt = 1;res = 0;memhead();
			//printf("#%d\n",i);
			int tt = 0;
			for(int j = 1 ; j <= B ; j ++) 
			{
				if(mp[i][j]) 
				{
					tt ++;
					flag[j] = 1;
					if(b[j] & 1) addedge(S , j , 1);
					else addedge(j , T , 1);
				}
				else flag[j] = 0;
			}
			Build_Graph();
			while(BFS()) res += dfs(S , Inf);
			ans = max(ans , tt - res + 1);
		}
		//puts("YES");
		for(int i = 1 ; i <= A ; i ++)
			for(int j = i + 1 ; j <= A ; j ++)
			{
				if((a[i] & 1) == (a[j] & 1)) continue;
				int tt = 0;
				cnt = 1;res = 0;memhead();
				for(int k = 1 ; k <= B ; k ++)
				{
					if(mp[i][k] && mp[j][k]) 
					{
						flag[k] = 1;
						tt ++;
						if(b[k] & 1) addedge(S , k , 1);
						else addedge(k , T , 1);
					}
					else flag[k] = 0;
				}
				Build_Graph();
				while(BFS()) res += dfs(S , Inf);
				ans = max(ans , tt - res + 2);
			}
		printf("%d\n",ans);
		memset(mp , 0 , sizeof mp);
	}
	return 0;
}
```

---

## 作者：B_K201 (赞：2)

二分图匹配！

本题首先要考虑，给定的题目条件所隐含的信息。像A国，自己手动模拟一下就会发现，只有两个A国人的友善值是奇数和偶数，那么这两个A国人才是朋友。考虑A国对整个朋友圈的影响。如果一个朋友圈中，出现了三个A国人，那么他们三个必须是朋友，但是很显然，这是与前面我们找出的条件是矛盾的！

接下来，我们就确定了A的枚举范围，只能是0个，1个，2个。我们再来看B的条件，很明显，条件的意思就是，当两个B国人的友善值同为奇数或者同为偶数，他们两个是朋友，或者一奇一偶，有可能是朋友，这样子他们的关系就可以形成一张完全图。我们再来看题目，题目需要求的是最大朋友圈，我们不难发现就是求最大环。

这里，有两个个很重要的结论：

最大环=最大独立集

最大独立集=总点数-最大匹配数

为了求出最大环，我们就得求出最大独立集，也就必须要求出最大匹配数，可是最大匹配数是在二分图才有的，那怎么处理？

因此，我们可以想到，用建立补图的方法来构造二分图，从而求出答案。

---

## 作者：Rainsleep (赞：1)

### P2423 [HEOI2012] 朋友圈

考虑 $a \oplus b \bmod 2 = 1$ 的限制实际上转化为不同左侧点最多选择两个，因为奇偶性需要不同。

暴力枚举左侧的点集，考虑 B 侧的点，首先需要跟左侧点集任意有边，之后内部还需要是完全图。

B 侧选定点的最大团这个东西是不好做的，但是我们可以借助边的性质。

我们如果按照 B 的奇偶性来分成两类，因为 $a \oplus b \bmod 2 = 0$，所以集合内部点两两有边，而第二类又在两个集合中做出了连边。

不难发现如果除去团内的边，实际上这是一张二分图，我们将二分图取补图，这仍然是一张二分图。我们发现，如果在这张图上求 **最大独立集**，那么在原图上即为最大团。

>团要求两两有边，而独立集要求两两没边，将补图还原后两两间必然有边，即为团。

+ **引理：最大独立集 = $n \  - $ 最小点覆盖。**
>最大独立集事实上想要从全集中去掉一些点（尽量少），使得两两间没边，也就是想找最少的点破坏掉所有边（如果有边存在必然有点相连）。正好对应了最小点覆盖。

而最小点覆盖又等于最大匹配。所以我们对补图求最大匹配然后计算即可。

时间复杂度 $O(|A|^2|B|^2)$。

[code](https://www.luogu.com.cn/paste/jwlc31u6)

---

## 作者：Midoria7 (赞：1)

~~先吐槽~~：因为按位异或和按位与的优先级调这个破题一下午，谢谢有被恶心到。

此题一看就可知道是一个求最大团的问题，然而一般无向图的求最大团是一个$NPC$问题，况且看到其数据范围就可以弃了。所以我们要分析一下其中的性质。

先看$B$国，可以看出其为一些奇数点和偶数点，况且其中存在一些连边。是二分图既视感。不过二分图是两边的部点不存在连边，所以我们需要建一个关于$B$国的补图。同时补图的最大独立集就是原图的最大团，于是$B$国直接建补图跑最大独立集即可。

再看$A$国，其要求可理解为选出的人要求两两奇偶不同，所以$A$国只能选出$0、1、2$人，再看$B$国中和这几个人有关系的跑最大独立集，我们直接暴力把所有情况取个$\max$即可，记得最大独立集$=n-$最大匹配数。

然后你快乐的连边之后一顿非常巨的操作跑匈牙利写完了发现$T$了几个点。（然后并不会$Dinic$），所以这时候就需要时间戳优化匈牙利。

匈牙利中占了时间效率很大的一块就是`memset`，每次都要`memset`理论每次都是$O(n)$的效率（当然肯定要小一点），那么每匹配一次都是$O(n^2m)$的，这个题要求多次匹配岂不是直接挂了。

~~所以时间戳优化出现了！~~其实根本没那么高深，设一个时间戳为$\text{Clock}$，原来的布尔类型数组就改为整数类型，转化如下：

$$\text{vis}[v]=1\rightarrow \text{vis}[v]=\text{Clock}$$
$$\text{vis}[v]=0\rightarrow \text{vis}[v]\not=\text{Clock}$$

每次`Clock++`，即可$O(1)$初始化。

~~然后就愉快的跑就完事了~~才不，这个毒瘤出题人居然卡常（可能只有我/kk），跑匈牙利的函数里的那个循环必须加`register`才能过（大数据居然快了$\text{200ms}$），否则卡线$TLE$。

其他没啥了。

---

## 作者：__Hacheylight__ (赞：1)

【题目大意】

有两个国家A和B。存在以下朋友关系：

1.A国：每个人都有一个友善值，当两个A国人的友善值a、b，如果a xor b mod 2=1，那么这两个人都是朋友，否则不是；
2.B国：每个人都有一个友善值，当两个B国人的友善值a、b，如果a xor b mod 2=0
或者 (a or b)化成二进制有奇数个1，那么两个人是朋友，否则不是朋友；
3.A、B两国之间的人也有可能是朋友，数据中将会给出A、B之间“朋友”的情况。
4.在AB两国，朋友圈的定义：一个朋友圈集合S，满足S∈A∪B，对于所有的i，j∈S，i和j是朋友。
求最大的朋友圈的人数。
 
【思路】
这道题求的是最大团。首先将题目大意翻译一下：
1.A国之间，友善值为一奇一偶的为朋友；B国之间，友善值同奇偶性或有（a or b）二进制有奇数个1的为朋友（后面一个条件真没办法翻译，到时候特判一下就好了）。两个之间的直接输入。
2.显然A国至多取出两个人。也就是由三种情况：取0个人、取1个人、取2个人。
3.那么我们就枚举从A国取出来的人，然后再B中删去与那两个人不是朋友的成员①，则只需要单独考虑B中的情况啦！
4.最大团显然是没有办法做的，不妨对B集合取个反图，也就是原来没有边的现在连上，原来有的现在不连。简单来说，就是同奇同偶间不连边，奇偶之间如果满足(a or b)化成二进制有偶数个1就连边。显然是一个二分图！这样问题就转换为最大点独立集。最大点独立集=总数-二分图匹配。
 
【优化】
直接跑Hungary是过不去的。问题在哪里呢？因为一直memset太挫了！
这个时候我们需要用到时钟T1、T2和tim、vis两个数组。还有思路①处的ban数组也注意一下。
到底什么是时间戳呢？好像并没有人解释。弄了一天大致弄出了一个比较清晰的解释：
一般来说匈牙利算法是这样弄得。每次匈牙利算法前将lk数组清空为-1（整个过程中枚举了A中0个1个2个3个人），然后匈牙利算法内部的循环中将vis数组清零。还是这句话——太挫了！！！！
T1在每次枚举开始+1。它用在lk数组上。由于lk数组并没有清空，之前可能已经lk过了，但是事实上每次匈牙利算法，lk是要清空的。所以如果tim[x]的值！=T1，就表示当前这次枚举中这个点还没有连接过，相当于lk[x]=0;如果tim[x]=T1了，说明当前这次已经用过它了，也就是之前清零过了的含义，那么按照朴素的匈牙利来做。
T2则在匈牙利算法中的循环语句中使用，出现在find前，这个是减去vis数组优化的，道理和上面差不多。vis[x]=T2表示当前这次find已经访问过了，而vis[x]!=T2就表示当前没有访问过，相当于vis=0或1。
另外，ban也是一个道理，ban[x]=T1表示当前这次x被ban掉了。
 
综上所述，时间戳并不是像是一些地方所说的一样用来在上一次匈牙利算法的基础上进行增广，而是真的、纯粹地免去memset的过程而已……
再简单点概述，如果有i次操作，每次vis数组都要清空的话，那么第i次操作不如这样转换:!vis[x]→vis[x]!=i，vis[x]→vis[x]=i。
所以上面因为lk数组每次枚举只要清零一次，ban数组也只需要ban一次，所以T1只在三种情况的的开头清空;而vis数组在for循环中每次都要清空，所以同理T2也要一直+1。
哇，其实是一个好简单的东西…………并没有时间戳这个名字来得那么高大上。



Code:
```cpp
#include <bits/stdc++.h>
using namespace std ;
const int MAX_B=3000 + 10 ;
bool mp[MAX_B][MAX_B] ;
vector <int> E[MAX_B] ;
int use1[MAX_B],use2[MAX_B],use3[MAX_B],result[MAX_B],a[MAX_B],b[MAX_B] ;
int m,cnt1,cnt2,na,nb,t,x,y ;
int calc(int x){
    int re=0 ;
    while (x) x-=x&-x,++re ;
    return re ;//有奇数个1 （奇数的二进制末尾一定=1） 
} 
bool dfs(int now){
    if (use1[now]==cnt1) return false;
    for (int i=0;i<E[now].size();i++){
        int to=E[now][i] ;
        if ((use1[to]!=cnt1) && (use2[to]!=cnt2)){
            use2[to]=cnt2;
            if (use3[to]!=cnt1 || !result[to] || dfs(result[to])){
                use3[to]=cnt1 ;
                result[to]=now ;
                return true ;
            }
        }
    }
    return false;
}
int xyl(int x=0,int y=0) 
{
    int t=0;cnt1++ ;
    for (int i=1;i<=nb;i++) if (mp[x][i] || mp[y][i]) use1[i]=cnt1,t++ ;
    //该点至少与A,B中的一个没有边,所以不可能成为独立集，排掉（A or B=0的情况已预处理过） 
    
    for (int i=1;i<=nb;i++){
        if (b[i]&1){
            ++cnt2 ;
            if (dfs(i)) t++ ;
        }
    }
    return (nb-t) ;
     
} 
void solve(){
    int ans=xyl() ;//选择0位A国人
    for (int i=1;i<=na;i++) 
	ans=max(ans,xyl(i)+1) ; //选择i号A国人 
    for (int i=1;i<=na;i++) if (a[i]&1) //选择i号A国人 
    for (int j=1;j<=na;j++) if (~a[j]&1) //选择j号A国人 
    ans=max(ans,xyl(i,j)+2) ;
    printf("%d\n",ans) ;
}
int main(){
    scanf("%d",&t) ;
    while (t--){
        memset(mp,1,sizeof(mp)) ;
        
        scanf("%d%d%d",&na,&nb,&m) ;//a国人的数量，b国人的数量，ab两国的朋友关系数 
        for (int i=1;i<=na;i++) scanf("%d",&a[i]) ;
        for (int i=1;i<=nb;i++) scanf("%d",&b[i]) ;
        for (int i=1;i<=m;i++){
            scanf("%d%d",&x,&y) ;
            mp[x][y]=0 ;
        }
        
        for (int i=1;i<=nb;i++) 
        if (b[i]&1)
        for (int j=1;j<=nb;j++)
        if (~b[j]&1)
        { //B[i] xor B[j] mod 2=0 
            if (~calc(b[i]|b[j])&1) E[i].push_back(j),E[j].push_back(i) ;
        }
        for (int i=1;i<=nb;i++) mp[0][i]=0;//预设，因为后面xyl时会有x,y等于0的情况 
        
        solve() ;
    }
    return 0 ;
}
```

---

## 作者：simonG (赞：0)

改动：添加了正体，去除了多余的空格。

这题事实上要求我们找最大团（最多的点两两相邻）。

最大团的求法是求补图的最大独立集。

举个例子，若图中两点之间没有边，所以它们不可能相邻。  

在补图，这两点有边，因为求独立集，那么就不能同时选。

我们发现，A 国是最多选两个点，因为若 $a\operatorname{xor} b \bmod 2=1$，不存在 $c\operatorname{xor} a \bmod 2=1$，且 $c\operatorname{xor} b \bmod 2=1$。

所以我们枚举 A 国情况。

那么 B 国呢，我们可以按照奇偶性把 B 国分成二部分。  

同奇偶的一部分互相有边。异奇偶两部分按照 $a\operatorname{or} b$ 有边。

那我们求补图的最大独立集，惊人地发现，B 国竟然分成了二分图。  

这样就可以用求二分图最大独立集了。二分图最大独立集为总点数减去最大匹配。

用网络流求可以。

---

## 作者：Coros_Trusds (赞：0)

# 题目大意

一张无向图有 $A,B$ 两类点，$A$ 类点有权值 $a$，$B$ 类点有权值 $b$。

若 $x,y \in A$ 且 $a_x \operatorname{xor} a_y \bmod 2 = 1$，则 $x,y$ 之间有边。
  
若 $x,y \in B$ 且 $b_x \operatorname{xor} b_y \bmod 2 = 0$ 或 $\operatorname{count}(b_x \operatorname{or} b_y) \bmod 2 = 1$，则 $x,y$ 之间有边，其中 $\operatorname{count}(x)$ 表示 $x$ 在二进制下 $1$ 的个数。

另外给定 $m$ 条边 $(x,y)$，保证 $x \in A$ 且 $y \in B$。
  
求这张图的最大团。

# 题目分析

转换一下，$A$ 连边条件就是奇偶性不同，**故 $\rm A$ 最多只能选两个。**$B$ 则是奇数权值之间有边，偶数权值之间有边，奇偶性不同的点之间有一些边。所以 $B$ 可以看成左边一团偶数权值，右边一团奇数权值，中间有一些边。众所周知，一般图的最大团问题属于 $\verb!NPC!$ 问题，可是 $B$ 的图很特殊。$B$ 的补图就是一张二分图。故 $B$ 的补图的最大独立集等于 $B$ 的最大团，注意到一个图的最大独立集等于 $n-$ 最大匹配数，所以这道题就能做了。

注意一点，按照上面我说的偶数放左边会被卡常，必须奇数放左边。。。

# 代码

```cpp
#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <numeric>
#include <algorithm>
#include <cmath>
#define enter putchar(10)
#define debug(c,que) std::cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) std::cout << arr[i] << w;
#define speed_up() std::ios::sync_with_stdio(false),std::cin.tie(0),std::cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define stop return(0)
const int mod = 1e9 + 7;
inline int MOD(int x) {
	if(x < 0) x += mod;
	return x % mod;
}
namespace Newstd {
	char buf[1 << 21],*p1 = buf,*p2 = buf;
	inline int getc() {
		return p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1 << 21,stdin),p1 == p2) ? EOF : *p1 ++;
	}
	#ifndef ONLINE_JUDGE
	#define getc getchar
	#endif
	inline int read() {
		int ret = 0,f = 0;char ch = getc();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getc();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getc();
		}
		return f ? -ret : ret;
	}
	inline double double_read() {
		long long ret = 0,w = 1,aft = 0,dot = 0,num = 0;
		char ch = getc();
		while (!isdigit(ch)) {
			if (ch == '-') w = -1;
			ch = getc();
		}
		while (isdigit(ch) || ch == '.') {
			if (ch == '.') {
				dot = 1;
			} else if (dot == 0) {
				ret = (ret << 3) + (ret << 1) + ch - 48;
			} else {
				aft = (aft << 3) + (aft << 1) + ch - '0';
				num ++;
			}
			ch = getc();
		}
		return (pow(0.1,num) * aft + ret) * w;
	}
	inline void write(int x) {
		if(x < 0) {
			putchar('-');
			x = -x;
		}
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;

const int N = 3005;
struct Graph {
	int v,nxt;
} gra[N * N];
int head[N],le[N],ri[N],mat[N],vis[N],ok[N];
bool G[N][N];
int T,a,b,c,idx,nowidx,id;
inline int popcount(int u) {
    u = (u & 0x55555555) + ((u >> 1) & 0x55555555);
    u = (u & 0x33333333) + ((u >> 2) & 0x33333333);
    u = (u & 0x0F0F0F0F) + ((u >> 4) & 0x0F0F0F0F);
    u = (u & 0x00FF00FF) + ((u >> 8) & 0x00FF00FF);
    u = (u & 0x0000FFFF) + ((u >> 16) & 0x0000FFFF);
    return u;
}
inline void add(int u,int v) {
	gra[++ idx] = (Graph){v,head[u]},head[u] = idx;
}
inline bool dfs(int now) {
	for (register int i = head[now];i;i = gra[i].nxt) {
		int v = gra[i].v;
		if (vis[v] != nowidx && ok[v] == id) {
			vis[v] = nowidx;
			if (!mat[v] || dfs(mat[v])) {
				mat[v] = now;
				return true;
			}
		}
	}
	return false;
}
inline void init() {
	idx = nowidx = id = 0;
	mst(G,false),mst(mat,0),mst(vis,0),mst(ok,0),mst(head,0),mst(gra,0);
}
inline void solve() {
	a = read(),b = read(),c = read();
	for (register int i = 1;i <= a; ++ i) le[i] = read();
	for (register int i = 1;i <= b; ++ i) ri[i] = read();
	for (register int i = 1;i <= b; ++ i) {
		if (ri[i] % 2 == 1) {
			for (register int j = 1;j <= b; ++ j) {
				if (ri[j] % 2 == 0 && popcount(ri[i] | ri[j]) % 2 == 0) {
					add(i,j);
				}
			}
		}
	}
	for (register int i = 1;i <= c; ++ i) {
		int u = read(),v = read();
		G[u][v + a] = G[v + a][u] = true;
	}
	int ans = 0;
	for (register int i = 1;i <= b; ++ i) {
		if (ri[i] % 2 == 1) {
			nowidx ++;
			if (dfs(i)) ans ++;
		}
	}
	ans = b - ans;
	for (register int i = 1;i <= a; ++ i) {
		mst(mat,0);
		id ++;
		int all = 1,cnt = 0;
		for (register int j = 1;j <= b; ++ j) {
			if (G[i][j + a]) {
				ok[j] = id;
				all ++;
			}
		}
		for (register int j = 1;j <= b; ++ j) {
			if (ok[j] == id && ri[j] % 2 == 1) {
				nowidx ++;
				if (dfs(j)) cnt ++;
			}
		}
		ans = std::max(ans,all - cnt);
	}
	for (register int i = 1;i <= a; ++ i) {
		for (register int j = i + 1;j <= a; ++ j) {
			if (le[i] % 2 != le[j] % 2) {
				mst(mat,0);
				id ++;
				int all = 2,cnt = 0;
				for (register int k = 1;k <= b; ++ k) {
					if (G[i][k + a] && G[j][k + a]) {
						ok[k] = id;
						all ++;
					}
				}
				for (register int k = 1;k <= b; ++ k) {
					if (ok[k] == id && ri[k] % 2 == 1) {
						nowidx ++;
						if (dfs(k)) cnt ++;
					}
				}
				ans = std::max(ans,all - cnt);
			}
		}
	}
	printf("%d\n",ans);
}
int main(void) {
	T = read();
	while (T --) {
		init();
		solve();
	}
	
	return 0;
}
```

---


# [SDOI2008] 递归数列

## 题目描述

一个由自然数组成的数列按下式定义：

对于 $i \le k$：$a_{i}= b_{i}$。

对于 $i > k$：$a_{i}= \sum_{j=1}^{k}{c_{j} \times a_{i-j}}$。

其中 $b_{1\dots k}$ 和 $c_{1\dots k}$ 是给定的自然数。

写一个程序，给定自然数 $m \le n$，计算 $\left( \sum_{i=m}^{n}{a_{i}} \right) \bmod p$。

## 说明/提示

对于 $20\%$ 的数据，$n \le 10^{6}$。

对于另外 $30\%$ 的数据，$k=1$。

对于 $100\%$ 的数据，$1 \le k \le 15$，$1 \le m \le n \le 10^{18}$，$0 \le b_{i},c_{i} \le 10^{9}$，$p \le 10^{8}$。

## 样例 #1

### 输入

```
2
1 1
1 1
2 10 1000003
```

### 输出

```
142```

# 题解

## 作者：ysner (赞：17)

看到楼下的题解没画出矩阵图，而矩阵是矩阵快速幂最重要的一环，我就来补一发吧。

本题主要是构造矩阵，我们只需要把那一段式子看成两个前缀和相减， 然后就直接矩阵连乘。

 ![](https://cdn.luogu.com.cn/upload/pic/6680.png) 

直接对那个k+1阶矩阵快速幂即可，注意初始化矩阵为单位矩阵，即主对角线（左上到右下）都为1其他都为0。

另外，很多量要开long long。

当然，为了卡时间，我inline、register、读入优化齐用，卡到了63ms。。。膜拜12ms的rank 1。。。

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#define ll long long
#define re register
#define il inline
using namespace std;
int b[15]={},c[15]={},sum[15]={},K,p,ansn,ansm;
ll n,m;
il ll gi()//读入优化开long long，否则只有20分
{
  re ll x=0,t=1;
  re char ch=getchar();
  while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
  if(ch=='-') t=-1,ch=getchar();
  while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
  return x*t;
}
struct matrix//矩阵乘法标准模板
{
     int a[16][16];
    matrix ()
    {
        memset(a,0,sizeof(a));
    }
    int *operator [](int x)
    {
        return a[x];
    }
    matrix operator *(matrix &b)
    {
        matrix c;
        for (re int i=0;i<=K;i++)
          for (re int j=0;j<=K;j++)
            for (re int k=0;k<=K;k++)
              c[i][k]=(c[i][k]+1ll*a[i][j]*b[j][k])%p;
        return c;
    }
}S,T;
il void init()
{
    for (re int i=0;i<K;i++)
      S[0][i]=b[i];
    S[0][K]=sum[K-1];
    for (re int i=1;i<=K;i++)
      for (re int j=0;j<=K;j++)
        S[i][j]=0;
    for (re int i=0;i<=K;i++)
      for (re int j=0;j<=K;j++)
        if (i==j+1) T[i][j]=1;
        else T[i][j]=0;
    for (re int i=0;i<K;i++)
      T[i][K-1]=T[i][K]=c[K-i-1];
    T[K][K-1]=0;T[K][K]=1;
}
int main()
{
    K=gi();
    for (re int i=0;i<K;i++)
      b[i]=gi(),sum[i]=b[i]+sum[i-1];
    for (re int i=0;i<K;i++)
      c[i]=gi();
    m=gi();n=gi();p=gi();
    m-=K+1;n-=K;
    if (m<=0) ansm=sum[m+K-1];
    else 
    {
        init();
        while (m)
        {
            if (m&1) S=S*T;
            T=T*T;
            m>>=1;
        }
        ansm=S[0][K];
    }
    if (n<=0) ansn=sum[n+K-1];
    else 
    { 
        init();
        while (n)//快速幂
        {
            if (n&1) S=S*T;
            T=T*T;
            n>>=1;
        }
        ansn=S[0][K];
    }
    printf("%d",(ansn-ansm+p)%p);
    return 0;
}
```

---

## 作者：SDqwq (赞：8)

[P2461 [SDOI2008]递归数列](https://www.luogu.com.cn/problem/P2461)

[博客食用更佳](https://www.luogu.com.cn/blog/Sham-Devour/solution-p2461)

[前置芝士：矩阵](https://oi-wiki.org/math/matrix/)

# $\texttt{Step 0 题意}$

给出 $k$，$b_1,b_2,\cdots,b_k$ 和 $c_1,c_2,\cdots,c_k$。

定义数列 $a$：

- 对于 $i\le k$：$a_i=b_i$。

- 对于 $i>k$：$a_i=\sum\limits_{j=1}^kc_j\times a_{i-j}$。

求出 $\sum\limits_{i=m}^{n}a_i$，答案对 $p$ 取模。

# $\texttt{Step 1 正解}$

~~因为暴力人人都会，所以直接上正解。~~

对于答案，其实就是 $sum_n-sum_{m-1}$。

其次因为 $k$ 很小，$m$ 和 $n$ 都很大，所以自然而然地想到了矩阵加速。

[P1939 【模板】矩阵加速（数列）](https://www.luogu.com.cn/problem/P1939)

不难想到 $1\times(k+1)$ 的状态矩阵初始应该长这样子：

$$
\begin{bmatrix}
a_1&a_2&\cdots&a_k&sum_k
\end{bmatrix}
$$

那么转移一次之后的状态矩阵就应该长这样子：

$$
\begin{bmatrix}
a_2&a_3&\cdots&a_{k+1}&sum_{k+1}
\end{bmatrix}
$$

于是 $(k+1)\times(k+1)$ 的转移矩阵随便画一下就出来了：

$$
\begin{bmatrix}
0&0&0&\cdots&0&c_k&c_k\\
1&0&0&\cdots&0&c_{k-1}&c_{k-1}\\
0&1&0&\cdots&0&c_{k-2}&c_{k-2}\\
0&0&1&\cdots&0&c_{k-3}&c_{k-3}\\
\vdots&\vdots&\vdots&\ddots&\vdots&\vdots&\vdots\\
0&0&0&\cdots&1&c_1&c_1\\
0&0&0&\cdots&0&0&1
\end{bmatrix}
$$

那么这道题就用矩阵快速幂处理出 $m-1$ 时的 $sum$ 和 $n$ 时的 $sum$ 就行了。

注意特判和减法取模的问题！

# $\texttt{Step 2 代码}$

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>

using namespace std;

typedef long long ll;

ll p, b[25], c[25], sum[25];

struct Matrix {
	int n, m;
	ll a[25][25];
	
	inline Matrix () {
		memset(a, 0, sizeof(a));
	}
} base, ans;

inline Matrix operator * (Matrix a, Matrix b) {
	Matrix res;
	res.n = a.n;
	res.m = b.m;
	for (int i = 1; i <= a.n; i++)
		for (int j = 1; j <= b.m; j++)
			for (int k = 1; k <= a.m; k++)
				res.a[i][j] = (res.a[i][j] + a.a[i][k] * b.a[k][j] % p) % p;
	return res;
}

inline Matrix quickPow (Matrix a, ll k) {
	Matrix res;
	res.n = res.m = a.n;
	for (int i = 1; i <= a.n; i++)
		res.a[i][i] = 1;
	while (k) {
		if (k & 1)
			res = res * a;
		k >>= 1;
		a = a * a;
	}
	return res;
}

inline void init_base (int k) {
	base.n = base.m = k + 1;
	for (int i = 2; i <= k; i++)
		base.a[i][i - 1] = 1;
	for (int i = 1; i <= k; i++)
		base.a[i][k] = base.a[i][k + 1] = c[k - i + 1] % p;
	base.a[k + 1][k + 1] = 1;
}

inline void init_ans (int k) {
	ans.n = 1;
	ans.m = k + 1;
	for (int i = 1; i <= k; i++)
		ans.a[1][i] = b[i] % p;
	ans.a[1][k + 1] = sum[k];
}

int main () {
	int k;
	scanf("%d", &k);
	for (int i = 1; i <= k; i++)
		scanf("%lld", &b[i]);
	for (int i = 1; i <= k; i++)
		scanf("%lld", &c[i]);
	ll m, n, ans1, ans2;
	scanf("%lld %lld %lld", &m, &n, &p);
	for (int i = 1; i <= k; i++)
		sum[i] = (sum[i - 1] + b[i] % p) % p;
	init_base(k);
	if (m > k) {
		init_ans(k);
		ans = ans * quickPow(base, m - 1 - 1ll * k);
		ans1 = ans.a[1][k + 1];
	}
	else
		ans1 = sum[m - 1];
	if (n >= k) {
		init_ans(k);
		ans = ans * quickPow(base, n - 1ll * k);
		ans2 = ans.a[1][k + 1];
	}
	else
		ans2 = sum[n];
	printf("%lld", ((ans2 - ans1) % p + p) % p);
	return 0;
}
```

---

## 作者：乘湘去 (赞：6)

#### [更好的阅读体验](https://www.cnblogs.com/isonder/p/14375830.html)

#### 矩乘板子题

$k \le 15$ 且 $a_{i}= {\textstyle \sum_{j=i}^{1}}c_{j}*a_{i-j} \ \ \ \  (i>k)$ (~~这一看就很矩乘~~) 考虑矩阵加速。

题目让求一段区间的和，可以转化为两前缀和相减的形式，同时，让矩阵边长加上 $1$ , 多加的 $1$ 用来储存前缀和

状态矩阵 $f_{i}$ 存储:
$$\begin{bmatrix}
  a_{i}&a_{i+1}  &a_{i+2}  &···  &a_{i+k}  &S_{i-1}
\end{bmatrix}$$

我们想让他转移到 $f_{i+1}$ 即为:
$$\begin{bmatrix}
  a_{i+1}&a_{i+2}  &a_{i+3}  &···  &a_{i+k+1}  &S_{i}
\end{bmatrix}$$

很容易得到，转移矩阵 $A$ 为:
$$\begin{bmatrix}
  0  &0  &0  &···  &c_{k}  &1 \\
  1  &0  &0  &···  &c_{k-1}  &0 \\
  0  &1  &0  &···  &c_{k-2}  &0 \\
  ···  &···  &···  &···  &···  &··· \\
  0  &0  &0  &···  &c_{1}  &0 \\
  0  &0  &0  &···  &0  &1
\end{bmatrix}$$

那矩乘的柿子就有了:
$$\begin{bmatrix}
  a_{i}&a_{i+1}  &a_{i+2}  &···  &a_{i+k}  &S_{i-1}
\end{bmatrix}
\begin{bmatrix}
  0  &0  &0  &···  &c_{k}  &1 \\
  1  &0  &0  &···  &c_{k-1}  &0 \\
  0  &1  &0  &···  &c_{k-2}  &0 \\
  ···  &···  &···  &···  &···  &··· \\
  0  &0  &0  &···  &c_{1}  &0 \\
  0  &0  &0  &···  &0  &1
\end{bmatrix}
=
\begin{bmatrix}
  a_{i+1}&a_{i+2}  &a_{i+3}  &···  &a_{i+k+1}  &S_{i}
\end{bmatrix}
$$

举个栗子，对于 $k=4$ 时，有:

$$\begin{bmatrix}
  a_{i}&  a_{i+1}&  a_{i+2}&  a_{i+3}&  S_{i-1}
\end{bmatrix}
\begin{bmatrix}
  0&  0&  0&  c_{4}& 1\\
  1&  0&  0&  c_{3}& 0\\
  0&  1&  0&  c_{2}& 0\\
  0&  0&  1&  c_{1}& 0\\
  0&  0&  0&  0&1
\end{bmatrix}
=
\begin{bmatrix}
  a_{i+1}&  a_{i+2}&  a_{i+3}&  a_{i+4}&  S_{i}
\end{bmatrix}$$

从 $S_{0}$ 计算到 $S_{n}$ 需要进行矩阵乘法需要使 $f_{0}$ 乘 $n$ 次 $A$,

及要计算 $f_{0}*A^{n}$ 计算 $A^{n}$ ，用矩阵快速幂加速运算即可。

#### Code
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 17
#define LL long long 
using namespace std;

LL k,b[N],c[N],n,m,mod;

struct matrix
{
	LL a[N][N];
	void clear()//矩阵清空
	{
		memset(a,0,sizeof(a));
	}
	void build()//建立单位矩阵
	{
		memset(a,0,sizeof(a));
		for(register int i=1;i<=k;i++)
			a[i][i]=1;
	}
	void mat_mod()//矩阵取模
	{
		for(register int i=1;i<=k;i++)
			for(register int j=1;j<=k;j++)
					a[i][j]=a[i][j]%mod;
	}
	void print()//矩阵输出
	{
		for(register int i=1;i<=k;i++)
		{
			for(register int j=1;j<=k;j++)
				printf("%lld ",a[i][j]);
			printf("\n");
		}
	}
};

matrix operator *(const matrix x,const matrix y)//矩阵乘法
{
	matrix ans;
	ans.clear();
	for(register int i=1;i<=k;i++)
		for(register int j=1;j<=k;j++)
			for(register int p=1;p<=k;p++)
				ans.a[i][j]=(ans.a[i][j]+x.a[i][p]*y.a[p][j]%mod)%mod;
	return ans;
}

inline LL qr()
{
	char ch=0;LL w=1,x=0;
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*w;
}

matrix poww(matrix x,LL opl)//矩阵快速幂
{
	matrix ans;
	ans.build();//创建单位矩阵
	while(opl)
	{
		if(opl&1)
			ans=ans*x;
		x=x*x;
		opl>>=1;
	}
	return ans;
}

int main()
{
	k=qr();
	for(register int i=1;i<=k;i++)
		b[i]=qr();
	for(register int i=1;i<=k;i++)
		c[i]=qr();
	n=qr();m=qr();mod=qr();
	k++;

	matrix A;//A为转化矩阵
	A.clear();
	for(register int i=2;i<k;i++)//给A填数
		A.a[i][i-1]=1;
	for(register int i=1;i<k;i++)
		A.a[i][k-1]=c[k-i];
	A.a[1][k]=1;
	A.a[k][k]=1;
	A.mat_mod();

	matrix f1,f2;
	f1.clear();//f1,f2为状态矩阵
	f2.clear();
	for(register int i=1;i<k;i++)//给f1,f2填数
		f1.a[1][i]=f2.a[1][i]=b[i];
	f1.mat_mod();
	f2.mat_mod();

	matrix jc1=poww(A,n-1ll);
	matrix jc2=poww(A,m);//A^m
	f1=f1*jc1;//计算前缀和
	f2=f2*jc2;

	printf("%lld\n",((f2.a[1][k]-f1.a[1][k])%mod+mod)%mod);//前缀和减一下即为最终答案
	return 0;
}
```


---

## 作者：Ricardo_Y (赞：4)

本题解仅针对满分算法

此题需用到快速幂与矩阵乘法，若还未了解，~~出门右转洛谷P3390或度娘~~

由于k<=15，且ai = c1ai-1 + c2ai-2 + ... + ckai-k，很容易能想到矩阵优化，用到矩阵快速幂可以在O(k^3\*log(n))的时间复杂度内得到An

然后考虑将Sn=A1+A2+……+A(n-1)+An加入矩阵中,在原矩阵上再加一维

代码如下：

```cpp
    #include <cstdio>
    #include <iostream>
    #include <algorithm>
    #include <cstring>
    using namespace std;
    long long ans,ans2,n,m,mod,a[20][20],matrix[20][20],temp[20][20],k,c[20],b[20],s[20];
    void ksm(long long n)//计算矩阵快速幂
    {
      . if(n==1)
      . {
      .     memset(matrix,0,sizeof matrix);
      .     matrix[0][0]=1;
      .     for(int i=1;i<=k;i++)
      .         matrix[i][0]=matrix[i][1]=c[i];
      .     for(int i=1;i<k;i++)
      .         matrix[i][i+1]=1;
      .     return;
      . }
      . long long mid=n>>1;
      . ksm(mid);
      . memset(temp,0,sizeof(temp));
      . for(int i=0;i<=k;i++)
      .     for(int j=0;j<=k;j++)
      .         for(int kk=0;kk<=k;kk++)
      .             temp[i][j]=(temp[i][j]+matrix[i][kk]*matrix[kk][j]%mod)%mod;
      . for(int i=0;i<=k;i++)
      .     for(int j=0;j<=k;j++)
      .         matrix[i][j]=temp[i][j];
      . memset(temp,0,sizeof(temp));
      . if(n&1)//当n为奇数时需要再次乘上初始矩阵
      . {
      .     for(int i=0;i<=k;i++)
      .         for(int j=0;j<=k;j++)
      .             for(int kk=0;kk<=k;kk++)
      .                 temp[i][j]=(temp[i][j]+matrix[i][kk]*a[kk][j]%mod)%mod;
      .     for(int i=0;i<=k;i++)
      .         for(int j=0;j<=k;j++)
      .             matrix[i][j]=temp[i][j];
      . }
    int main()
    {
      . cin>>k;
      . for(int i=1;i<=k;i++)
      . {
      .     scanf("%lld",b+i);
      .     s[i]=s[i-1]+b[i];
      . }
      . for(int i=1;i<=k;scanf("%lld",c+i++));
      . //a为初始矩阵以下构造
      . a[0][0]=1;
      . for(int i=1;i<=k;i++)
      .     a[i][0]=a[i][1]=c[i];
      . for(int i=1;i<k;i++)
      .     a[i][i+1]=1;
      . scanf("%lld%lld%lld",&m,&n,&mod);
      . m--;
      . //ans为Sn,ans2为S(m-1)，相减即为(am + am+1 + am+2 + ... + an)
      . if(n<=k) ans=s[n];
      .     else
      .     {
      .         ksm(n-k);
      .         ans=s[k]*matrix[0][0]%mod;
      .         for(int i=1;i<=k;i++)
      .             ans=(ans+b[k-i+1]*matrix[i][0]%mod)%mod;
      .     }
      . if(m<=k) ans2=s[m];
      .     else
      .     {
      .         ksm(m-k);
      .         ans2=s[k]*matrix[0][0]%mod;
      .         for(int i=1;i<=k;i++)
      .             ans2=(ans2+b[k-i+1]*matrix[i][0]%mod)%mod;
      .     }
      . printf("%lld",((ans-ans2)%mod+mod)%mod);
      . return 0;
}
```

---

## 作者：Prean (赞：2)

~~引用化学老师的一句话：什么矩阵，没有矩阵！~~

这种板子题怎么能用矩阵呢。

$ O(k^2\log n) $ 能搞定何必需要 $ O(k^3\log n) $ 呢。

首先设 $ F_n(x)=x^n \bmod {1-P(x)} $，那么我们需要求 $ \sum_{i=1}^n F_i(x) \bmod (1-P(x)) $。然后卷上 $ B(x) $ 就可以得到需要的东西了。

注意到这是等比数列求和，可以使用分治计算等比数列，可以保证复杂度是 $ O(k^2\log n) $ 而不是 $ O(k^2\log^2n) $ 的。

主要到我们在求的实际上是 $ \sum_{i=1}^n (F_i(x) \bmod {P(x)}) $，但是因为这些东西加起来再取模和取模之后再加起来的结果是一样的，所以并无区别。

坑还是比较多的，需要注意一下。
```cpp
#include<cstdio>
typedef unsigned ui;
typedef __uint128_t L;
typedef unsigned long long ull;
const ui M=55;
ui len,P,b[M],p[M];ull n,m;
struct Barrett{
	ull b,m;
	Barrett(const ull&m=1):m(m),b((L(1)<<64)/m){}
	friend inline ull operator%(const ull&a,const Barrett&mod){
		ull r=a-mod.m*(L(mod.b)*a>>64);return r>=mod.m?r-mod.m:r;
	}
}mod;
inline void add(ui*f,ui*g,const ui&len){
	ui i;for(i=0;i^len;++i)f[i]=(f[i]+g[i])%mod;
}
inline void times(ui*f,ui*g,ui*P,const ui&len){
	ui i,j,t,x;static ui sav[M];
	for(i=0;i^len;++i)if(f[i])for(j=0;j^len;++j)if(g[j])sav[i+j]=(sav[i+j]+1ull*f[i]*g[j])%mod;
	for(i=(len<<1)-1;i>=len;--i)if(sav[i])for(t=sav[i],j=len;j<=len;--j)sav[i-j]=(sav[i-j]+1ull*t*P[j])%mod;
	for(i=0;i^len;++i)f[i]=sav[i],sav[i]=0;
}
inline ui Solve(ui*b,ui*P,const ui&len,ull n){
	if(n>>63)return 0;ui i,ans(0);static ui f[M],g[M],sav[M];sav[0]=g[0]=1;if(len^1)f[1]=1;else f[0]=p[1];
	for(;n;n>>=1,++f[0],times(g,f,P,len),--f[0],times(f,f,P,len))if(n&1)times(sav,f,P,len),add(sav,g,len);
	for(i=0;i^len;++i)ans=(ans+1ull*sav[i]*b[i+1])%mod,f[i]=g[i]=sav[i]=0;return ans;
}
signed main(){
	ui i;scanf("%u",&len);for(i=1;i<=len;++i)scanf("%u",b+i);for(i=1;i<=len;++i)scanf("%u",p+i);
	scanf("%llu%llu%u",&n,&m,&P);mod=Barrett(P);p[0]=P-1;for(i=1;i<=len;++i)b[i]=b[i]%mod,p[i]=p[i]%mod;
	printf("%u",(Solve(b,p,len,m-1)+P-Solve(b,p,len,n-2))%mod);
}
```
### upd:这道题可以使用新算法。
我们观察得到，答案为 $ [x^n]\frac {B(x)(1-C(x))} {(1-C(x))(1-x)} $。

然后跑一遍老算法，但是需要求逆。

然而注意到分母的零次项一定为 $ 1 $，所以实际上并不需要求逆。

常数比老算法小一点儿，仍然不清楚最优解是什么。。。
```cpp
#include<cstdio>
typedef unsigned ui;
typedef __uint128_t L;
typedef unsigned long long ull;
const ui M=55;
ui len,P,f[M],g[M],b[M],p[M];ull n,m;
struct Barrett{
	ull b,m;
	Barrett(const ui&m=1):m(m),b((L(1)<<64)/m){}
	friend inline ull operator%(const ull&a,const Barrett&mod){
		ull r=a-mod.m*(L(mod.b)*a>>64);return r>=mod.m?r-mod.m:r;
	}
}mod;
inline void times(ui*f,ui*g,const ui&len){
	ui i,j,t;static ui sav[M];
	for(i=0;i^len;++i)if(f[i])for(j=0;j^len;++j)if(g[j])sav[i+j]=(sav[i+j]+1ull*f[i]*g[j])%mod;
	for(i=0;i<len*2;++i)f[i]=sav[i],sav[i]=0;
}
inline ui Solve(ui*f,ui*g,const ui&len,ull n){
	ui i;static ui sav[M];
	for(;n;n>>=1){
		for(i=0;i<len;++i)sav[i]=i&1?P-g[i]:g[i];times(f,sav,len);times(g,sav,len);
		for(i=n&1;i<len*2;i+=2)f[i>>1]=f[i];for(i=0;i<len*2;i+=2)g[i>>1]=g[i];for(i=len;i<len*2;++i)f[i]=g[i]=0;
	}
	return f[0];
}
signed main(){
	ui i,x,y;scanf("%u",&len);++len;for(i=1;i^len;++i)scanf("%u",b+i);for(i=1;i^len;++i)scanf("%u",p+i);
	scanf("%llu%llu%u",&n,&m,&P);mod=Barrett(P);p[0]=1;for(i=1;i^len;++i)b[i]=b[i]%mod,p[i]=P-p[i]%mod;
	times(b,p,len);b[len++]=0;for(i=len-1;i;--i)p[i]=(p[i]+P-p[i-1])%mod;
	for(i=0;i^len;++i)f[i]=b[i],g[i]=p[i];x=Solve(f,g,len,n-1);
	for(i=0;i^len;++i)f[i]=b[i],g[i]=p[i];y=Solve(f,g,len,m);
	printf("%u",(P+y-x)%mod);
}
```

---

## 作者：Shikita (赞：2)

# 矩阵乘法

线性递推式，求几项之和

按照惯例，我们先手推一波~~虽然并推不出来~~

设当前项为 $a_i$ 


当$i\leqslant k$ 时
$$a_i=b_i$$

当$i>k$ 时

$$a_i= \sum_{j=1}^{k} c_j*a_{i-j}$$

同理 

$$a_{i+1}= \sum_{j=1}^{k} c_j * a_{i-j+1}$$

我们尝试着减一下

$$a_{i+1}-a_i= \sum_{j=1}^{k} c_j * ( a_{i-j+1}-a_{i-j}  )$$

然后我们逐渐往前推，便可以得到一个性质

$a_i-a_{i-1}=$ 之前所有的差乘上一个$c_j$

~~这不是废话吗，题意显然啊~~

接下来我们便可以构造出这么一个矩阵

~~那你直接给矩阵不好吗~~

$sum[i]$ 表示的是$b_i$的前缀和,我们先假设$\quad k=3$

$( a_{n-2} \quad a_{n-1} \quad a_n \quad s_n  )$=$(a_1\quad a_2\quad a_3 \quad s_3)$
$\begin{bmatrix}0&0&c_3&c_3\\1&0&c_2&c_2\\0&1&c_1&c_1\\0&0&0&1\\\end{bmatrix}^{n-3}$

举完例子，我们再详细说一下矩阵($k*k$)具体构造

对于第$i$行（$1<=i<=k$），我们从第$k$个开始（前面全部用0填充），之后全部用

$c_{k-i+1}$ 进行填充

然后我们对于第$i$行（$1<=i<=k$）再进行一次对角线填充

最后我们再多加上一行，在最后一个填充一个1，完成对角线填充

然后我们就可以愉快的开始快速幂处理了

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll read()
{
    ll x=0;
    char c=getchar();
    bool flag=0;
    while(c<'0'||c>'9') {if(c=='-')flag=1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x+(x<<2)<<1)+ c-'0';c=getchar();}
    return flag?-x:x;
}
const int N=20;
ll K,b[N],c[N],sum[N],ans1,ans2,mod,n,m;
struct Matrix
{
	int l,r;
	ll a[N][N];
	Matrix(){};
	Matrix(int x,int y):l(x),r(y){ memset(a,0,sizeof(a));}
	
	Matrix operator*(Matrix t)
	{
        Matrix cg=Matrix(l,t.r);
        for(int i=1;i<=l;++i)
        for(int j=1;j<=t.r;++j)
        for(int k=1;k<=r;++k)
            cg.a[i][j]=(cg.a[i][j]+a[i][k]*t.a[k][j]%mod)%mod;
        return cg;
    }
    
    Matrix operator^(ll p)
	{
        Matrix t=Matrix(l,r),cg=Matrix(l,r);
        memcpy(t.a,a,sizeof(a));
        if(p&1) memcpy(cg.a,a,sizeof(a));
        else for(int i=1;i<=l;++i) cg.a[i][i]=1;
        while(p>>=1)
		{
            t=t*t;
            if(p&1) cg=cg*t;
        }
        return cg;
    }
}st,ed;
int main()
{
	K=read();
	st=Matrix(1,K+1);
	for(int i=1;i<=K;++i) b[i]=read();
	for(int i=1;i<=K;++i) c[i]=read();
	m=read(),n=read(),mod=read();
	for(int i=1;i<=K;++i) sum[i]=(sum[i-1]+b[i])%mod,st.a[1][i]=b[i]%mod,c[i]%=mod;
	
	if(n<=K) {printf("%lld\n",(sum[n]-sum[m-1]+mod)%mod);return 0;}
	
	ed=Matrix(K+1,K+1);
	for(int i=1;i<=K;++i) ed.a[i][K]=ed.a[i][K+1]=c[K-i+1];
	for(int i=2;i<=K;++i) ed.a[i][i-1]=1;
	ed.a[K+1][K+1]=1,st.a[1][K+1]=sum[K];
	
	if(m>K) ans1=(st*(ed^(m-K-1))).a[1][K+1];
    else ans1=sum[m-1];
    ans2=(st*(ed^(n-K))).a[1][K+1];
    printf("%lld\n",(ans2-ans1+mod)%mod);
}
```


---

## 作者：Energy_Making (赞：1)

## 1.前置知识
[矩阵加速](https://oi-wiki.org/math/matrix/#_9)
## 2.思路
~~题意很明了了，直接跳过吧。~~

这道题最有提示性的地方在于数据范围。 $1 \le m \le n \le 10^{18}$ 很明显，只能用 $\mathcal O(\log n)$ 的方法做。而复杂度是 $\mathcal O(\log n)$ 的一般都是数学题或矩乘。而这道题又有递推式，很明显就是矩乘了。

那么 $a_i = b_i$ 的部分就是初始值，而 $i > k$ 的部分就要用矩乘了。明确了这一点，我们就知道了初始的矩阵。

$$
\begin{bmatrix}
a_1 & a_2 & a_3 & \cdots & a_k & ans_k
\end{bmatrix}
$$
那么转移矩阵也就显而易见了（~~如果不是，请重温模板~~）。
$$
\begin{bmatrix}
0 & 0 & 0 &\cdots & 0 & c_k & c_k
\\0 & 1 & 0 & \cdots & 0 & c_{k-1} & c_{k-1}
\\0 & 0 & 1 & \cdots & 0 & c_{k-2} & c_{k-2}
\\\vdots & \vdots & \vdots & \cdots & \vdots & \vdots & \vdots
\\0 & 0 & 0 & \cdots & 1 & c_1 &c_1
\\0 & 0 & 0 & \cdots & 0 & 0 & 1 
\end{bmatrix}
$$
那么之后就用矩阵快速幂即可。

最后答案即为 $ans_n - ans_{m-1}$ 
## 3.代码
```cpp
#include<stdio.h>
#include<cstring>
#define ll long long
using namespace std;
int k;
ll n,m,p,ans,ans2;
ll sum[20],b[20],c[20];
struct node
{
	int n,m;
	ll mp[25][25];
	node() 
	{
		memset(mp,0ll,sizeof(mp));
	}
};
node st,Pow;
node operator*(node a, node b) 
{
	node s;
	s.n=a.n;
	s.m=b.m;
	for(int i=1;i<=a.n;i++)
		for(int j=1;j<=b.m;j++)
			for(int k=1;k<=a.m;k++)
				s.mp[i][j]=(s.mp[i][j]%p+a.mp[i][k]*b.mp[k][j]%p)%p;
	return s;
}
node ksm(node a,ll b) 
{
	node s;
	s.n=a.n;
	s.m=a.m;
	for(int i=1;i<=a.n;i++)s.mp[i][i]=1;
	while(b)
	{
		if(b&1)s=s*a;
		a=a*a;
		b>>=1;
	}
	return s;
}//常规操作
void reset()
{
	st.n=1;
	st.m=Pow.n=Pow.m=k+1;
	for(int i=1;i<=k;i++)st.mp[1][i]=b[i]%p;
	st.mp[1][k+1]=sum[k];
	for(int i=1;i<k;i++)Pow.mp[i+1][i]=1ll;
	for(int i=1;i<=k;i++)Pow.mp[i][k]=Pow.mp[i][k+1]=c[k-i+1]%p;
	Pow.mp[k+1][k+1]=1ll;
}
int main()
{
	scanf("%d",&k);
	for(int i=1;i<=k;i++)scanf("%lld",&b[i]);
	for(int i=1;i<=k;i++)scanf("%lld",&c[i]);
	scanf("%lld %lld %lld",&m,&n,&p);
	for(int i=1;i<=k;i++)sum[i]=sum[i-1]+b[i];
	reset();
	if(m>k)
	{
		st=st*ksm(Pow,m-1ll*k-1);
		ans=st.mp[1][k+1];
	}
	else ans=sum[m-1];//注意特判
	reset();
	if(n>=k)
	{
		st=st*ksm(Pow,n-1ll*k);
		ans2=st.mp[1][k+1];
	}
	printf("%lld",((ans2-ans)%p+p)%p);//注意减法取模
	return 0;
}
```


---

## 作者：y2823774827y (赞：1)

[**更好的阅读体验**](https://www.cnblogs.com/y2823774827y/p/10182151.html)

纪念不看题解$A$掉的第一个矩阵快速幂

先做完模板题吧[p1939](https://www.luogu.org/problemnew/show/P1939)

矩阵开$(k+1)^2$，定义函数$f_x$为$\sum\limits_{i=1}^xa_i$，显然$f_x=f_{x-1}+a_i$

$a_{i-1},a_{i-2}.....a_{i-k},f_{i-1}$ $\Longrightarrow$ $a_i,a_{i-1}.....a_{i-k+1},f_i$

提示到此结束了，仔细想想，相信你能构造出矩阵

### **My complete code**

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
typedef long long LL;
inline LL Read(){
    LL x=0,f=1; char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-') f=-1; c=getchar();
    }
    while(c>='0'&&c<='9')
        x=(x<<3)+(x<<1)+c-'0',c=getchar();
    return x*f;
}
const LL maxn=51;
struct mat{
    LL m[maxn][maxn];
}a,base,st,r;
LL K,m,n,ans1,ans2,ans,MOD,sum;
LL b[maxn],c[maxn];
inline mat Mul(const mat &x,const mat &y){
    mat res;
    memset(res.m,0,sizeof(res.m));
    for(LL i=1;i<=K+1;++i)
        for(LL j=1;j<=K+1;++j)
            for(LL k=1;k<=K+1;++k)
                res.m[i][j]=(res.m[i][j]+(x.m[i][k]*y.m[k][j])%MOD)%MOD;
    return res;
}
inline void Pow(LL mi){
    while(mi){
        if(mi&1)
            st=Mul(st,a);
        a=Mul(a,a);
        mi>>=1;
    }
}
int main(){
    K=Read();
    for(LL i=1;i<=K;++i)
        b[i]=Read(),
        sum+=b[i];
    for(LL i=1;i<=K;++i)
        c[i]=Read();
    m=Read(),n=Read(),MOD=Read();
    if(n>K){	
        for(LL i=1;i<=K;++i)
            a.m[i][1]=a.m[i][K+1]=c[i];
        for(LL i=1;i<K;++i)
            a.m[i][i+1]=1;
        a.m[K+1][K+1]=1;
        for(LL i=1;i<=K+1;++i)
            st.m[i][i]=1;
        
        Pow(n-K);
        for(LL i=1;i<=K;++i)
            r.m[1][i]=b[K-i+1]; r.m[1][K+1]=sum;
        r=Mul(r,st);
        ans1=r.m[1][K+1];
    }else
        for(LL i=1;i<=n;++i)
            ans1=(ans1+b[i])%MOD;
    
    if(m-1>K){
        memset(a.m,0,sizeof(a.m));
        memset(st.m,0,sizeof(st.m));
        memset(r.m,0,sizeof(r.m));
        for(LL i=1;i<=K;++i)
            a.m[i][1]=a.m[i][K+1]=c[i];
        for(LL i=1;i<K;++i)
            a.m[i][i+1]=1;
        a.m[K+1][K+1]=1;
        for(LL i=1;i<=K+1;++i)
            st.m[i][i]=1;
            
        Pow(m-1-K);
        for(LL i=1;i<=K;++i)
            r.m[1][i]=b[K-i+1]; r.m[1][K+1]=sum;
        r=Mul(r,st);
        ans2=r.m[1][K+1];
    }else
        for(LL i=1;i<m;++i)
            ans2=(ans2+b[i])%MOD;
    
    ans=(ans1-ans2+MOD)%MOD;
    printf("%lld",ans);
    return 0;
}/*
2
1 1
1 1
2 10 1000003

142
*/
```

---

## 作者：LightningUZ (赞：0)

[博客](https://blog.csdn.net/LightningUZ/article/details/89288883)内食用效果更佳！
(并不华丽的分割线)
（以下格式仿佛炸了，请去博客观看）

---

正文：
### 题意简述
（纯数论）定义数列$a_i=$

![blog1.png](https://i.loli.net/2019/04/14/5cb2f6f8351da.png)

求$a$数组从$m$到$n(m,n<=10^{18})$的和模$p(p<=10^8)$的值，也就是$\sum\limits_{i=m}^{n}a_i\%p$
### 数据
输入
2
1 1
1 1
2 10 1000003
输出
142

### 思路
格式炸了，见[博客](https://blog.csdn.net/LightningUZ/article/details/89288883)。

代码：
```cpp
#include<bits/stdc++.h>
#define mod p
#define K 20
#define int long long
using namespace std;
int n,m,p;

struct mat//封装结构体
{
    int m[K][K];//矩阵
    int* operator[](int i)//封装取下标运算符
    {
        return m[i];
    }

    mat(int x)//初始化矩阵全部为x
    {
        for(int i=0;i<K;i++)
        {
            for(int j=0;j<K;j++)
            {
                m[i][j]=x;
            }
        }
    }
    void Set(int x=0)//方便初始化之后全部设置为x（这个里面没有用到）
    {
        for(int i=0;i<K;i++)
        {
            for(int j=0;j<K;j++)
            {
                m[i][j]=x;
            }
        }
    }
    void Identity()//单位矩阵
    {
        Set(0);
        for(int i=0;i<K;i++)
        {
            m[i][i]=1;
        }
    }
};
mat operator*(mat x,mat y)//封装乘法
{
    mat ans(0);

    for(int i=1;i<K;i++)
    {
        for(int j=1;j<K;j++)
        {
            ans[i][j]=0;
            for(int k=1;k<K;k++)
            {
                ans[i][j]+=x[i][k]*y[k][j];
                ans[i][j]%=mod;//取模。。。
            }
        }
    }
    return ans;
}
mat operator^(mat x,int p)//封装快速幂
{
    mat ans(0);ans.Identity();//初始为单位矩阵
    while(p)
    {
        if (p&1) ans=ans*x;
        x=x*x,p>>=1;
    }//和快速幂差不多
    return ans;
}

int k;
int b[K],c[K];
int s[K];
void Input()
{
    scanf("%lld",&k);
    for(int i=1;i<=k;i++)
    {
        scanf("%lld",&b[i]);
    }
    for(int i=1;i<=k;i++)
    {
        scanf("%lld",&c[i]);
    }
    scanf("%lld%lld%lld",&m,&n,&p);

    for(int i=1;i<=k;i++)
    {
        s[i]=(s[i-1]+b[i])%mod;//处理前缀和
        b[i]%=mod;
        c[i]%=mod;
    }
}

int Calc(int x)
{
    if (x<=k)//这个很显然
    {
        return s[x];
    }
    else
    {
        mat Initial(0);//Initial矩阵
        for(int i=1;i<=k;i++) Initial[1][i]=b[i];
        Initial[1][k+1]=s[k];

        mat Trans(0);//Trans矩阵
        for(int i=1;i<=k;i++)
        {
            Trans[i][k]=Trans[i][k+1]=c[k-i+1];
        }
        for(int i=2;i<=k;i++)
        {
            Trans[i][i-1]=1;
        }
        Trans[k+1][k+1]=1;//构造方法见上面

        mat ans=Initial*(Trans^(x-k));
        return ans[1][k+1];
    }
}

int Q[100];
main()
{
    Input();
    printf("%lld\n",(Calc(n)%mod-Calc(m-1)%mod+mod)%mod);
    //这边取绝对模，要先膜，再加，再膜
    return 0;
}

```


---

## 作者：MrMorning (赞：0)

#题目大意：

一个由自然数组成的数列按下式定义：

对于i <= k：ai = bi

对于i > k: ai = c1ai-1 + c2ai-2 + ... + ckai-k

其中bj和 cj （1<=j<=k）是给定的自然数。写一个程序，给定自然数m <= n, 计算am + am+1 + am+2 + ... + an, 并输出它除以给定自然数p的余数的值。

#题解

首先显然我们可以构造一个矩阵递推$a_i$。

如果直接从m递推到n，会超时（我也没写过，不知道），我们在矩阵中加一维，记录$s_i$，具体可以见代码

#代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
using namespace std;
const ll maxn = 20;
ll k, B[maxn], C[maxn], s[maxn];
ll m, n, p;
struct M {
  ll n, m;
  ll a[maxn][maxn];
} a, b;
M operator*(M a, M b) {
  M c;
  c.n = a.n;
  c.m = b.m;
  memset(c.a, 0, sizeof(c.a));
  for (ll i = 1; i <= c.n; i++) {
    for (ll j = 1; j <= c.m; j++) {
      for (ll k = 1; k <= a.m; k++)
        c.a[i][j] = (c.a[i][j] + (ull)(a.a[i][k] * b.a[k][j]) % p) % p;
    }
  }
  return c;
}
M pow(M a, ll b) {
  M ret;
  ret.n = a.n;
  ret.m = a.m;
  memset(ret.a, 0, sizeof(ret.a));
  for (ll i = 1; i <= ret.n; i++)
    ret.a[i][i] = 1;
  while (b) {
    if (b & 1)
      ret = ret * a;
    a = a * a;
    b >>= 1;
  }
  return ret;
}
void print(M x) {
  for (ll i = 1; i <= x.n; i++) {
    for (ll j = 1; j <= x.m; j++)
      cout << x.a[i][j] << ' ';
    cout << endl;
  }
}
ll calc(ll x) {
  M y = pow(a, x + 1);
  // prll (y);
  y = y * b;
  return y.a[1][1];
}
int main() {
  // freopen("input", "r", stdin);
  scanf("%lld", &k);
  a.n = k + 1;
  a.m = k + 1;
  b.n = k + 1;
  b.m = 1;
  s[0] = 0;
  for (ll i = 1; i <= k; i++) {
    scanf("%lld", &B[i]);
  }
  for (ll i = 1; i <= k; i++)
    scanf("%lld", &C[i]);
  scanf("%lld %lld %lld", &m, &n, &p);
  for (ll i = 1; i <= k; i++)
    s[i] = (B[i] + s[i - 1]) % p;
  b.a[1][1] = s[k - 1];
  for (ll i = 1; i <= k; i++)
    b.a[i + 1][1] = B[k - i + 1];
  a.a[1][1] = a.a[1][2] = 1;
  for (ll i = 1; i <= k; i++)
    a.a[2][i + 1] = C[i];
  for (ll i = 1; i < k; i++)
    a.a[i + 2][i + 1] = 1;
  // a = a * b;
  ll ans1, ans2;
  // calc(1);
  if (m - 1 > k)
    ans1 = calc(m - 1 - k);
  else
    ans1 = s[m - 1];
  if (n > k)
    ans2 = calc(n - k);
  else
    ans2 = s[n];
  printf("%lld\n", (ans2 - ans1 + p) % p);
  return 0;
}
```

---


# [SDOI2007] 游戏

## 题目描述

小木木和小凳子是两个聪明的孩子，他们五岁的时候就开始学习英语了。

英语老师教他们玩一个很简单的游戏。老师给他们一张全小写并无特殊符号的英语单词表，单词表如下：

ab
arc
arco
bar
bran
carbon
carbons

cobra
crab
crayon
narc
然后让他们从单词表里找词语接龙。接龙的规则如下:

1 前一个单词拥有的所有字母，在后一个单词里必须出现，而且字母出现次数不少于前一单词。

2 后一个单词的长度比前一个单词的长度恰好多1

对于以上例子，一合法的接龙为:

ab
bar
crab
cobra
carbon
carbons

他们之中，谁接龙的长度长，谁就赢了。小木木肯定不想输，所以找到你，放肆撒娇，导致你因为不想再被打扰而帮他了。至于小凳子呢？？说不定找郭大牛去了。嘿嘿，你和郭大牛的编程比赛？？加油吧！！！


## 样例 #1

### 输入

```
ab
arc
arco
bar
bran
carbon
carbons
cobra
crab
crayon
narc```

### 输出

```
6
ab
bar
crab
cobra
carbon
carbons```

# 题解

## 作者：Kelin (赞：9)

题意:接龙,对于一个串$i$,如果串$j$所有中字符的出现次数比$i$有且只有一个位置大$1$,那么就能接上

## 算法一:暴力$DP$

因为每次长度都会多$1$

所以考虑按照长度$DP$

$f_i=max(f_j)+1,len_i=len_j+1$且合法

输出方案就记录一下转移点

复杂度$O(26*\sum_{len}sum_{len}*sum_{len-1})$

$sum_{len}$表示长度是$len$的串的个数

可以知道极限复杂度是$O(26*\frac{n^2}4)$

不知道这种DP能不能优化

~~由于是暴力,所以代码就随便写了一下~~

```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
char sr[1<<21];int C=-1;
const int N=1e4+5,M=105,inf=1e9;
typedef int arr[N];
struct da{int l,c[26];}a[N];
int n,m,k,ans,pos,L=inf,R;arr pr,f;
char s[N][M];vector<int>len[M];
inline bool cmp(const da&a,const da&b){return a.l<b.l;}
void dfs(int u){
	if(!u)return;
	dfs(pr[u]);
	puts(s[u]+1);
}
inline bool chk(int u,int v){
	int p=0;
	fp(i,0,25){
		if(a[u].c[i]==a[v].c[i])continue;
		if(a[u].c[i]<a[v].c[i])return 0;
		if(a[u].c[i]>a[v].c[i]+1)return 0;
		p^=1;
	}return p;
}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    while(~scanf("%s",s[++n]+1)){
    	a[n].l=strlen(s[n]+1);
    	fp(i,1,a[n].l)++a[n].c[s[n][i]-'a'];
    }--n;
    fp(i,1,n)len[a[i].l].push_back(i),cmin(L,a[i].l),cmax(R,a[i].l);
    fp(l,L,R){
    	for(int i:len[l])f[i]=1;
    	if(!len[l-1].size())continue;
    	for(int i:len[l]){
    		for(int j:len[l-1]){
    			if(chk(i,j)){
    				if(f[i]<f[j]+1)
    					f[i]=f[j]+1,pr[i]=j;
    			}
    		}
    		if(f[i]>ans)ans=f[i],pos=i;
    	}
    }
    printf("%d\n",ans);
    dfs(pos);
return 0;
}
```
## 算法二:字符串$hash$+$DAG$最长路

对于每个字符串,你增加他的某一个字符,看看得到的新字符串是不是存在

存在就连边,得到的一定是一个$DAG$,然后跑最长路就好了

至于怎么判断是不是存在,你把$cnt[26]$这个数组$hash$一下就好了

```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
char sr[1<<21];int C=-1;
const int N=1e4+5,M=1e7;
typedef int arr[N];
struct eg{int nx,to;}e[N];
struct da{int l,c[26];}a[N];
int n,m,ce,ans,pos,ha[M];arr pr,f,fi,in,S,d;
char s[N][105];queue<int>q;
inline void add(int u,int v){e[++ce]={fi[u],v},fi[u]=ce,++in[v];}
inline int get(int*s){
	int tp=0;
	fp(i,0,25)tp=(233ll*tp%M+s[i])%M;
	return tp;
}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    while(~scanf("%s",s[++n]+1));--n;
    fp(i,1,n){
    	a[i].l=strlen(s[i]+1);
    	fp(j,1,a[i].l)++a[i].c[s[i][j]-'a'];
    	ha[get(a[i].c)]=i;
    }
    fp(i,1,n){
    	fp(j,0,25){
    		++a[i].c[j];
    		int v=get(a[i].c);
    		if(ha[v])add(i,ha[v]);
    		--a[i].c[j];
    	}
    }
    fp(i,1,n)if(!in[i])q.push(i),d[i]=1;
    while(!q.empty()){int u=q.front();q.pop();go(u)d[v]=d[u]+1,--in[v],pr[v]=u,!in[v]?q.push(v):void();}
    fp(i,1,n)if(d[i]>ans)ans=d[pos=i];
    while(pos)S[++S[0]]=pos,pos=pr[pos];
    printf("%d\n",ans);
   	fd(i,S[0],1)puts(s[S[i]]+1);
return 0;
}
```

## ~~算法三:虚树~~

~~我不知道是哪位大佬的在这题贴了虚树~~

~~求大佬指教~~

---

## 作者：寒鸽儿 (赞：5)

声明： 本题解的ac代码开02通过，不开O2将会有四个点超时20至60ms不等(超了那么一小点，但开O2最大的点能优化至256ms,常数很大)。如果有朋友应用本思路通过减小常数通过请私信作者更新(会在更新时注上帮助提供者的名字)，感激不尽。  

[博客食用效果更佳](https://www.luogu.org/blog/oldherd/solution-p2462)  

本题中的数据为字母，但由题意我们并不关心字母的排列顺序，而是只关心各字母出现的总次数以及整个单词的长度，因而我们在输入时统计各单词的出现次数。(详见代码split部分)。  

我们发现，一个单词a符合两个条件，可以成为另一个单词b的下一个：  
1.length(a) = length(b) + 1.  
2.a中各字母出现次数≥b中各字母出现次数。  

如果比一个单词更短的所有单词为结尾的龙长度确定，那么以该单词为结尾的龙长度确定，同时确定比该单词更短的单词结尾的龙不需要用到以该单词为结尾的龙的长度信息，因而符合一个很重要的性质：无后效性。  

易证本题可以用dp求解。具体的，我们把单词按长度归类(详见邻接表部分)。按照单词长度递增顺序求解。转移则用所有比该单词短1的单词的信息尝试。  

ac代码如下：  
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

const int maxl = 110, maxn = 10010;

int head[maxl], ver[maxn], nex[maxn], tot;
inline void addedge(int len, int id) {
    ver[tot] = id; nex[tot] = head[len]; head[len] = tot++;
}

char ch[maxn][maxl];
int split[maxn][26];
int len[maxn], ans[maxn], pre[maxn];
int mres = 0, maid = -1;

inline bool check(int x, int y) {
    for(int i = 0; i < 26; i++)
        if(split[x][i] < split[y][i])
            return false;
    return true;
}

void dp(int cur) {
    ans[cur] = 1;
    for(int i = head[len[cur]-1]; i != -1; i = nex[i])
        if(check(cur, ver[i])) {
            if(!ans[ver[i]]) dp(ver[i]);
            if(ans[ver[i]] + 1 > ans[cur]) ans[cur] = ans[ver[i]] + 1, pre[cur] = ver[i];
        }
    if(ans[cur] > mres) mres = ans[cur], maid = cur;
}


int stack[10010], st = 0;
int main() {
    int pc = -1;
    memset(head, -1, sizeof(head));
    memset(pre, -1, sizeof(pre));
    while(scanf("%s", ch[++pc]) == 1) {
        len[pc] = strlen(ch[pc]);
        for(int i = 0; i < len[pc]; i++)
            split[pc][ch[pc][i]-'a']++;
        addedge(len[pc], pc);
    }
    for(int i = 0; i <= pc; i++) {
        if(ans[i]) continue;
        dp(i);
    }
    printf("%d\n", mres);
    for(int i = maid; i != -1; i = pre[i])
        stack[st++] = i;
    for(int i = st - 1; i > -1; --i)
        printf("%s\n", ch[stack[i]]);
    return 0;
}
```
欢迎互相关注(然而在oi界蒟蒻的圈很小)。  
最后再次安利一下[蒟蒻的洛谷博客](https://www.luogu.org/blog/oldherd/)  

---

## 作者：FFTotoro (赞：3)

本题需要使用 STL `std::map` 和**拓扑排序**。

先将输入的字符串存入一个 `vector`，对其进行排序、去重（因为我们并不关心字符串的顺序，排序和去重可以大大减少状态数），便于进行下一步操作。

注意，在输入字符串时也可以对字符串本身排序，因为我们只关心里面的各种字符的个数，并不关心它实际上到底是什么样的，这样也可以减少状态数。但是在对其排序之前要注意建立映射，输出方案时可以快速找到原字符串。

对于每一个字符串，把它下一步可能变成的字符串枚举出来，再查看原字符串集合中有无此字符串（可以用 `map` 快速查找），如果有那么将前者向后者连边。

最后我们可以得到一个有向无环图，用拓扑排序跑最长路即可。具体地，每到一个点，看看它下一次可以到达的点中，哪些的最长路可以被更新。

在拓扑排序的过程中记一下每个结点的前驱，输出方案时不断找前驱即可。

放代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> g[200001];
int d[200001],f[200001],p[200001];
map<string,int> m;
map<string,string> m2;
int main(){
  ios::sync_with_stdio(false);
  vector<string> v; string s;
  while(cin>>s){
    string x=s;
    sort(x.begin(),x.end());
    // 将字符串本身排序
    m2[x]=s; // 把新串和原串建立映射
    v.emplace_back(x);
  }
  sort(v.begin(),v.end()); // 排序
  v.erase(unique(v.begin(),v.end()),v.end()); // 去重
  for(int i=0;i<v.size();i++)m[v[i]]=i+1;
  for(int i=0;i<v.size();i++)
    for(char c=97;c<123;c++){
      s=v[i]; s.insert(upper_bound(s.begin(),s.end(),c),c);
      // 插入一个新的字符，注意要时刻保持字符串中的字符递增
      if(m[s])g[i+1].emplace_back(m[s]),d[m[s]]++;
      // 如果目标存在就连边
    }
  queue<int> q;
  for(int i=1;i<=v.size();i++)
    if(!d[i])q.emplace(i),f[i]=1;
  while(!q.empty()){
    int t=q.front(); q.pop();
    for(int i:g[t]){
      if(f[i]<f[t]+1)f[i]=f[t]+1,p[i]=t;
      // 更新最长路和前驱
      if(!--d[i])q.emplace(i);
    }
  }
  int l=1,e=0;
  stack<string> t;
  for(int i=1;i<=v.size();i++)
    if(f[i]>=l)l=f[i],e=i;
  cout<<l<<endl; // 最长长度
  while(e)t.emplace(m2[v[e-1]]),e=p[e]; // 不断找前驱
  while(!t.empty())cout<<t.top()<<endl,t.pop();
  return 0;
}
```

---

## 作者：creation_hy (赞：2)

水题。

有个显然的 $26$ 倍常数的 $O(n^2)$ 做法，暴力枚举两个字符串，看是否能作为另一个的前驱，然后建有向图，拓扑一下求出最长链就是答案。

但是复杂度不像能过，然后发现每个串后面其实只有 $26$ 种接法（任何一种字母添加一个即可），那就枚举可能接下去的字符串，如果存在就连边。

然后字符是无序的，所以你需要用一个数组存，查询用哈希就行了。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e4 + 5;
const int base = 131;
const int mod = 1e9 + 7;
const int M = N * 26;
int n, head[N], to[M], nxt[M], etot;
int dis[N], in[N], pre[N];
vector<int> vec;
string s[N];
ll pw[26];
map<int, int> mp;
struct node
{
    int cnt[26];
    inline node() { memset(cnt, 0, sizeof(cnt)); }
    inline ll hash()
    {
        ll res = 0;
        for (int i = 0; i < 26; i++)
            (res += pw[i] * cnt[i]) %= mod;
        return res;
    }
} a[N];
inline void link(int u, int v)
{
    to[etot] = v;
    nxt[etot] = head[u];
    head[u] = etot++;
    in[v]++;
}
inline void topo()
{
    queue<int> q;
    for (int i = 1; i <= n; i++)
        if (!in[i])
            q.emplace(i), dis[i] = 1;
    while (!q.empty())
    {
        int x = q.front();
        q.pop();
        for (int i = head[x]; ~i; i = nxt[i])
        {
            if (dis[to[i]] < dis[x] + 1)
            {
                dis[to[i]] = dis[x] + 1;
                pre[to[i]] = x;
            }
            if (!(--in[to[i]]))
                q.emplace(to[i]);
        }
    }
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    memset(head, -1, sizeof(head));
    pw[0] = 1;
    for (int i = 1; i < 26; i++)
        pw[i] = pw[i - 1] * base % mod;
    string str;
    while (cin >> str)
    {
        s[++n] = str;
        for (char c : str)
            a[n].cnt[c - 'a']++;
        mp[a[n].hash()] = n;
    }
    for (int i = 1; i <= n; i++)
        for (int j = 0; j < 26; j++)
        {
            a[i].cnt[j]++;
            int k = a[i].hash();
            if (mp.count(k))
                link(i, mp[k]);
            a[i].cnt[j]--;
        }
    topo();
    int ans = 0, p;
    for (int i = 1; i <= n; i++)
        if (dis[i] > ans)
            ans = dis[i], p = i;
    cout << ans << '\n';
    vec.emplace_back(p);
    while (pre[p])
        vec.emplace_back(p = pre[p]);
    for (int i = vec.size() - 1; ~i; i--)
        cout << s[vec[i]] << '\n';
    return 0;
}
```

---

## 作者：Disjoint_cat (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P2462)

这是一道很好的 DP 题。首先，我们可以发现，单词本身其实是没有用的（因为字母顺序不影响接龙），我们真正需要的是单词中每个字母出现的次数。

为了方便查找，可以先按单词的长度给单词排序，然后枚举每一个单词，更新可以接上它的单词，同时记录下它接上的单词。

即：如果单词 $i$ 可以接单词 $j$，且 $ans_j\ge ans_i$，则记录：

$$ans_i=ans_j+1,prev_i=j$$

最后取 $ans$ 的最大值，递归输出即可。开 O2 后最大时间 $250ms$。

感觉实际难度：绿~蓝

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10005;
int n,ma=-1,mat;
bool ok;
struct word//单词
{
	string a;
	int len,letter[27],ans,prev;
	bool operator<(const word wd)const
	{
		return len<wd.len;
	}
}wrd[N];
void search(int s)//输出
{
	if(wrd[s].prev)search(wrd[s].prev);
	puts(wrd[s].a.c_str());
}
int main()
{
	while(!cin.eof())getline(cin,wrd[++n].a);
	for(int i=1;i<=n;i++)
	{
		wrd[i].len=strlen(wrd[i].a.c_str());
		for(int j=0;j<wrd[i].len;j++)wrd[i].letter[wrd[i].a[j]-'a'+1]++;
	}
	sort(wrd+1,wrd+n+1);
	for(int i=1;i<n;i++)
	{
		if(wrd[n].len==wrd[i].len)break;
		for(int j=i+1;j<=n;j++)
		{
			if(wrd[j].len>wrd[i].len+1)break;
			if(wrd[j].len==wrd[i].len+1&&wrd[i].ans>=wrd[j].ans)
			{
			    ok=1;
			    for(int k=1;k<=26;k++)
			        if(wrd[j].letter[k]<wrd[i].letter[k])
			        {
			            ok=0;
			            break;
			        }
			    if(ok)wrd[j].ans=wrd[i].ans+1,wrd[j].prev=i;
			}
		}
			
	}
	for(int i=n;i>=1;i--)if(wrd[i].ans>ma)ma=wrd[i].ans,mat=i;
	printf("%d\n",ma+1);
	search(mat);
	return 0;
}
```

---

## 作者：happybob (赞：1)

容易发现只与字符串中每个字符出现次数有关，与字符本身的排列无关。

对于一个字符串 $S$，能在他后面接龙的不同的出现个数的字符串最多 $26$ 个。又因为后面的字符串长度比 $S$ 多 $1$，所以如果建图是有向无环的。将每个字符出现次数哈希，建图，转化为最长路，DP 即可。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <string>
#include <set>
#include <cstring>
#include <queue>
#include <map>
#include <vector>
using namespace std;

const int N = 1e5 + 5;
using ull = unsigned long long;

int cnt[N][26];
set<ull> hashing[N];
ull nhash[N];
string s;
int n;
string p[N];
int cnts[26];
int dp[N], from[N];
map<ull, int> maxd;
vector<int> G[N];
int in[N];

int dfs(int u)
{
	if (dp[u]) return dp[u];
	dp[u] = 1;
	for (auto& j : G[u])
	{
		dfs(j);
		if (dp[j] + 1 > dp[u])
		{
			dp[u] = dp[j] + 1;
			from[u] = j;
		}
	}
	//cout << u << " " << dp[u] << "\n";
	return dp[u];
}

int main()
{
	ios::sync_with_stdio(0), cin.tie(nullptr), cout.tie(nullptr);
	while (cin >> s)
	{
		p[++n] = s;
	}
	for (int i = 1; i <= n; i++)
	{
		memset(cnts, 0, sizeof cnts);
		ull hashings = 0;
		for (auto& j : p[i])
		{
			cnts[j - 'a']++;
		}
		for (int j = 0; j < 26; j++)
		{
			if (cnts[j] > 0)
			{
				cnts[j]--;
				hashings = 0;
				for (int k = 0; k < 26; k++)
				{
					hashings = hashings * 28410841 + cnts[k];
				}
				hashing[i].insert(hashings);
				cnts[j]++;
			}
		}
		hashings = 0;
		for (int k = 0; k < 26; k++)
		{
			hashings = hashings * 28410841 + cnts[k];
		}
		nhash[i] = hashings;
	}
	for (int i = 1; i <= n; i++)
	{
		maxd[nhash[i]] = i;
	}
	for (int i = 1; i <= n; i++)
	{
		for (auto& j : hashing[i])
		{
			if (maxd.count(j))
			{
				G[maxd[j]].emplace_back(i);
				in[i]++;
			}
		}
	}
	for (int i = 1; i <= n; i++)
	{
		if (!in[i]) G[0].emplace_back(i);
	}
	cout << dfs(0) - 1 << "\n";
	int ps = from[0];
	do
	{
		cout << p[ps] << "\n";
		ps = from[ps];
	} while (ps);
	return 0;
}
```


---

## 作者：peterwuyihong (赞：1)

定义一个接龙，当 $b$ 中字母可重集合包含 $a$ 且 $|b|=|a|+1$，$a$ 与 $b$ 能接上，求最长的龙并输出方案。

把每个集合 Hash 成一个状态，然后跑最长路并记录路径即可。

但注意到显然集合只会较小的连到较大的，所以是一个 DAG，于是可以再用 topsort 直接做就行了。

细节处理一坨，披了两三件衣服，一件一件拨开，就剩一个感觉只有黄的板子。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 100010
int n,len;
char s[maxn][105];
int v[26];
#define P 19260817
int head[P],Next[P],ver[P],tot;
int in[P];
void add(int x,int y){
	ver[++tot]=y;
	Next[tot]=head[x];
	head[x]=tot;
}
int H(int a[]){
	int ans=0;
	for(int i=0;i<26;i++)ans=(ans*131ll+a[i])%P;
	return ans;
}
int l,r,q[maxn<<2];
int dp[P],pre[P];
int Ha[P];
int d[P];
int cnt;
void dfs(int o){
	if(!o)return;
	dfs(pre[o]);
	cout<<s[o]<<endl;
}
signed main(){
#ifndef ONLINE_JUDGE
	freopen("testdata.in","r",stdin);
#endif
	while(scanf("%s",s[++n])!=EOF){
		int len=strlen(s[n]);
		memset(v,0,sizeof v);
		for(int i=0;i<len;i++)v[s[n][i]-'a']++;
		int u=H(v);
		Ha[u]=n;
	}n--;
	for(int o=1;o<=n;o++){
		int len=strlen(s[o]);
		memset(v,0,sizeof v);
		for(int i=0;i<len;i++)v[s[o][i]-'a']++;
		for(int i=0;i<26;i++){
			v[i]++;
			int f=H(v);
			if(Ha[f])add(o,Ha[f]);
			in[Ha[f]]++;
			v[i]--;
		}
	}
	for(int i=1;i<=n;i++)
	if(!in[i])q[++r]=i,d[i]=1;
	while(l<=r){
		int x=q[l++];
		for(int i=head[x];i;i=Next[i]){
			int y=ver[i];
			d[y]=d[x]+1;
			pre[y]=x;
			if(--in[y]==0)q[++r]=y;
		}
	}
	int ans=0,o=0;
	for(int i=1;i<=n;i++)
	if(ans<d[i])ans=d[i],o=i;
	cout<<ans<<endl;
	dfs(o);
#ifndef ONLINE_JUDGE
	cerr<<endl<<(double)clock()/CLOCKS_PER_SEC;
#endif
}

```


---

## 作者：ctj12461 (赞：1)

欢迎到[我的博客](https://ctj12461.netlify.com/2019/896656d0.html)食用本题解
# 算法分析
其实这道题并不难，关键是如何转化。因为需要找到最长的单词接龙，就可以用图论来看。单词接龙不会出现环，所以，这就是个`DAG`上的拓扑排序。如果两个单词可以接在一起，就必须满足以下条件：
- 前一个单词的字母都必须在后一个单词中出现过
- 任意一个字母都不能少
- 后一个单词的长度比前一个单词多`1`，不能多也不能少

因为没有对顺序作要求，我们只需记录其出现次数即可，并存储它们的哈希值（`hash`/散列），枚举每个字符串的每个字母，增加其出现次数，并判断该字符串是否存在，如果存在，就建一条有向边。

最后，拓扑排序，记录答案并通过前驱指针递归输出。

# 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

#if __cplusplus < 201103 || !defined(__cplusplus)
typedef map<int,int> maptype;
#else
typedef unordered_map<int,int> maptype; // 如果是C++11及以上，使用无序哈希映射
#endif

struct edge
{
    int to,nxt;
};

edge e[1000001]; int head[10001],tot;
int in[10001];
maptype mapping;
char str[10001][105];
int len[10001];
int cnt[10001][26];
int f[10001];
int pre[10001];
int n;

void connect(int x,int y){
    e[++tot]=(edge){y,head[x]}; head[x]=tot; ++in[y];
}

int gethash(int idx){ // 哈希函数
    int val=0;
    for(register int i=0;i<26;++i){
        val=val*23+cnt[idx][i];
    }
    return val;
}

void output(int d){ // 递归输出
    if(pre[d]!=0){
        output(pre[d]);
    }
    printf("%s\n",str[d]+1);
}

void topology(){ //拓扑排序
    queue<int> q;
    for(register int i=1;i<=n;++i){
        if(!in[i]) q.push(i);
        f[i]=1;
    }
    while(!q.empty()){
        int x=q.front(); q.pop();
        for(register int i=head[x],y;y=e[i].to,i;i=e[i].nxt){
            if(f[y]<f[x]+1){
                f[y]=f[x]+1;
                pre[y]=x;
            }
            if(--in[y]==0){
                q.push(y);
            }
        }
    }
    int ans=0;
    for(register int i=1;i<=n;++i){
        if(f[ans]<f[i]){
            ans=i;
        }
    }
    printf("%d\n",f[ans]);
    output(ans);
}

void build(){ //建边
    for(register int i=1;i<=n;++i){
        for(register int j=0;j<26;++j){
            ++cnt[i][j];
            int h=gethash(i);
            if(mapping.find(h)!=mapping.end()){ // 如果存在一个可接的单词就建边
                connect(i,mapping[h]);
            }
            --cnt[i][j]; // 要记得还原
        }
    }
}

void input(){
    while(scanf("%s",str[++n]+1)!=EOF); --n; // 注意输入
    for(register int i=1;i<=n;++i){
        len[i]=strlen(str[i]+1);
        for(register int j=1;j<=len[i];++j){
            ++cnt[i][str[i][j]-'a'];
        }
        mapping[gethash(i)]=i;
    }
}

int main(){
    input();
    build();
    topology();
    return 0;
}
```

---

## 作者：benchmark (赞：1)

字符串题当然是用trie了（雾）
我们可以很容易发现，对于这道题，字符串本身是没有意义的，只有每一种字符出现的次数有意义。所以我们就以每一种字符出现的最大次数（100）为字符集，建立一颗"次数trie"。当然空间复杂度比较大，是卡着内存过的。
这样我们首先将字符串按长度排序，每次枚举加入的字符，并可以直接在次数trie上找要转移的字符串是否存在。dp的时候记一下pre就可以输出方案了。思维难度不是很高，但是代码实现上稍微有点麻烦（更详细题解请看代码，代码有注释）
时间复杂度是26^2*n，空间复杂度是26n倍的字符串长度，容易看出差点爆内存了。
```cpp
//#include<math.h>
#include<algorithm>
#include<stdlib.h>
#include<time.h>
#include<stdio.h>
#include<string.h>
#define srd srand(time(0))
#define ll long long
#define con continue
#define gtc getchar()
#define ptc putchar
#define dou double
#define eps 0.00000000001
#define opr operator
#define cl(x,a) memset(x,a,sizeof(x))
#define fo0(i,k) for(i=fr[k];i;i=nx[i])
#define fo1(i,l,r) for(i=l;i<=r;i++)
#define fo2(i,l,r) for(i=l;i>=r;i--)
#define fo(i,n) for(i=1;i<=n;i++)
#define ret return
#define x first
#define cint const int
#define y second
#define opi(x) freopen(x,"r",stdin)
#define opo(x) freopen(x,"w",stdout)
#define tpl template<class T>
#define priq priority_queue
#define mp make_pair
#define use using namespace
#define WT while(T--)
use std;
typedef pair<int,int> pii;typedef pair<int,ll> pil;typedef pair<ll,int> pli;typedef pair<ll,ll> pll;
namespace io
{
	void _(int &k){char c;int e=1;k=0;while((c=gtc)>'9'||c<'0')if(c=='-')e=-1;k=c-'0';while((c=gtc)<='9'&&c>='0'){k*=10;k+=c-'0';}k*=e;}
	void _(ll &k){char c;int e=1;k=0;while((c=gtc)>'9'||c<'0')if(c=='-')e=-1;k=c-'0';while((c=gtc)<='9'&&c>='0'){k*=10;k+=c-'0';}k*=e;}
	void _(char &c){while((c=gtc)==' '||c=='\n');}void _(dou &c){scanf("%lf",&c);}template<class t1,class t2>void _(t1 &a,t2 &b){_(a);_(b);}
	template<class t1,class t2,class t3>void _(t1 &a,t2 &b,t3 &c){_(a);_(b);_(c);}
	template<class t1,class t2,class t3,class t4>void _(t1 &a,t2 &b,t3 &c,t4 &d){_(a);_(b);_(c);_(d);}
	template<class t1,class t2,class t3,class t4,class t5>void _(t1 &a,t2 &b,t3 &c,t4 &d,t5 &e){_(a);_(b);_(c);_(d);_(e);}
	void _p(dou k){printf("%.6lf",k);}
	tpl void _p0(T k){if(k>=10)_p0(k/10);ptc(k%10+'0');}tpl void _p(T k){if(k<0){ptc('-');_p0(-k);}else _p0(k);}tpl void __p(T k){_p(k);ptc(' ');}
	tpl void _pn(T k){_p(k);ptc('\n');}template<class t1,class t2>void _p(t1 a,t2 b){__p(a);_pn(b);}
	template<class t1,class t2,class t3>void _p(t1 a,t2 b,t3 c){__p(a);__p(b);_pn(c);}
	template<class t1,class t2,class t3,class t4>void _p(t1 a,t2 b,t3 c,t4 d){__p(a);__p(b);__p(c);_pn(d);}
	tpl void op(T *a,int n){int i;n--;fo(i,n)__p(a[i]);_pn(a[n+1]);}int gi(){int x;_(x);ret x;}ll gll(){ll x;_(x);ret x;}
}
int gcd(int a,int b){ret b?gcd(b,a%b):a;}void fop(const char *s){char c[256],d[256];cl(c,0);cl(d,0);strcpy(c,s);strcpy(d,s);opi(strcat(c,".in"));opo(strcat(d,".out"));}void fcl(){fclose(stdin);fclose(stdout);}
int eq(dou a,dou b){return a+eps>=b&&b+eps>=a;}tpl void _ma(T &a,T b){if(a<b)a=b;}tpl void _mi(T &a,T b){if(a>b)a=b;}
cint N=1234567,EE=100000000,GG=1000000000,ima=2147483647;
use io;
int n,m,so[266666][101],v[266666],a[11111][33],f[N],p[N],an,T,z=1;
char s[11111][111],s1[11111][111];
pii c[11111];//pair<int,int> 
void ins(int *a,int b)//插入trie树，注意这个trie的字符集是100，字符串长度是26 
{
	int i,k=1;
	fo1(i,0,25)//i从1到25循环，下同 
	{
		int &t=so[k][a[i]];//t就是要找的下一个节点 
		k=t=t?t:++z;//存在就转移过去，不存在就新建再转移过去 
	}
	v[k]=b;
}
int fi(int *a)//查找和插入非常相似 
{
	int i,k=1;
	fo1(i,0,25)
	{
		int &t=so[k][a[i]];
		if(!(k=t=t?t:0))
			ret 0;
	}
	ret v[k];
}
void op(int k)//这个是为了dp方案的输出，由于记得是pre，所以为了实现正序输出就利用了栈的性质 
{
	if(!k)
		ret;
	op(p[k]);
	puts(s[k]);
}
int main()
{
	int i,j,a1,a2,t,ma,mx=0;
	for(n=1;scanf("%s",s1[n])+1;n++);n--;
	fo(i,n)//这个就是i从1循环到n，下同 
	{
		c[i].y=i;//字符串按长度排序 
		c[i].x=strlen(s1[i]);//x是first,y是second 
	}
	sort(c+1,c+n+1);
	fo(i,n)
	{
		strcpy(s[i],s1[c[i].y]);//这样s就是排序好的字符串数组 
		for(j=0;s[i][j];j++)
			a[i][s[i][j]-'a']++;//统计每种字符的出现次数 
	}
	fo(i,n)
		ins(a[i],i);//插入每个出现次数数组 
	fo(i,n)
		f[i]=1;//每个字符串一开始都能选，所以f初始化为1 
	fo(i,n)
		fo1(j,0,25)//枚举每个添加的字符 
		{
			a[i][j]++;//在a数组里加上添加的字符，用于查找 
			t=fi(a[i]);//查找 
			a[i][j]--;//消除对a数组的影响 
			if(t&&f[t]<f[i]+1)//dp
			{
				f[t]=f[i]+1;
				p[t]=i;//记pre 
			}
		}
	fo(i,n)
		if(f[i]>mx)//找到最优解 
		{
			mx=f[i];
			ma=i;
		}
	_pn(mx);//输出答案，_pn就是输出并换行 
	op(ma);
}

```

---

## 作者：xuantianhao (赞：0)

## [[SDOI2007] 游戏](https://www.luogu.com.cn/problem/P2462)

~~论 STL 的百种用法。~~

可以观察到可以接龙的对构成一张 DAG。因此我们要找到 DAG 中最长路。这个随便 DP 就可以了。

关键是找到可以互相转移的位置。

$n^2$ 枚举非常危险，因为还有一个 26 判断的常数，没试，估计过不了。

我们必须寻找复杂度更低的算法。

发现一个串只与组成它的每个字符的数量有关。那么我们可以把这每个字符的数量压到一个 ```vector``` 里面，然后用 ```map<vector<int>,int>``` 来找可以转移的位置。或者因为串长 $\leq 100$，因此 ```vector``` 中每个数必定不超过 100，然后可以化成一个 ```string```。当然，```string``` 也可以哈希（虽然答案就不一定正确了）。

当然，无论怎么搞，都有一个 26 的常数，似乎哈希一下复杂度是 $n\log n$，而不哈希复杂度是 $\log n$。但不管怎么说，能过。
  
代码：
  
```cpp
#include<bits/stdc++.h>
using namespace std;
string s[10010];
map<vector<int>,int>m;
int S,n,f[10010],pre[10010],mp;
void print(int i){
    if(!i)return;
    print(pre[i]);
    cout<<s[i]<<endl;
}
int main(){
    n++;
    while(cin>>s[n])n++;
    sort(s+1,s+n);
    for(int i=1;i<n;i++){
        f[i]=1;
        vector<int>v;
        v.resize(26);
        for(auto j:s[i])v[j-'a']++;
        m[v]=i;
    }
    for(auto i:m){
        vector<int>v=i.first;
        for(int k=0;k<26;k++){
            v[k]++;
            if(m.find(v)!=m.end()){
                int j=m[v];
                if(f[j]<f[i.second]+1)f[j]=f[i.second]+1,pre[j]=i.second;
            }
            v[k]--;
        }
    }
    for(int i=1;i<n;i++)if(f[i]>f[mp])mp=i;
    printf("%d\n",f[mp]);
    print(mp);
    return 0;
}
```

---

## 作者：Terac (赞：0)

[$\texttt{link}$](https://www.luogu.com.cn/problem/P2462)

这个题挺简单。

显然只有字符串的每种字母个数才有意义，哈希表浅存一下。

对于每个字符串，枚举 $26$ 个字母，连一条向添加该字母后的字符串的边，显然最后会建出一个 DAG，找这个图的最长路即可，这个复杂度比较对，$O(n\Sigma),\Sigma = 26$。

或者直接 DP，先按字符串长度排个序，每次转移找比自己长度少一的字符串，判一下能否转移即可，这个复杂度很假 $O(n^2\Sigma)$，但常数小，不过要卡肯定能卡（？）

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e4 + 10, M = 1e2 + 10;
int n, ans, anss, dp[N], pre[N], ps[M], pt[M];
struct node {
	char s[M];
	int cnt[26], len;
} a[N];
bool cmp(node a, node b) { return a.len < b.len; }
int main() {
	while(~scanf("%s", a[++n].s + 1))
		a[n].len = strlen(a[n].s + 1);
	--n;
	sort(a + 1, a + 1 + n, cmp);
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= a[i].len; j++)
			a[i].cnt[a[i].s[j] - 'a']++;
	for(int i = 1; i <= n; i++)
		if(a[i].len != a[i - 1].len) ps[a[i].len] = pt[a[i].len] = i;
		else pt[a[i].len] = i;
	for(int i = 1; i <= n; i++) {
		for(int j = ps[a[i].len - 1]; j && j <= pt[a[i].len - 1]; j++) {
			bool flg = 0;
			for(int k = 0; k < 26; k++)
				if(a[j].cnt[k] > a[i].cnt[k]) {
					flg = 1;
					break;
				}
			if(!flg)
				if(dp[i] < dp[j]) {
					dp[i] = dp[j];
					pre[i] = j;
				}
		}
		dp[i]++;
		if(ans < dp[i])
			ans = dp[i], anss = i;
	}
	printf("%d\n", ans);
	stack<int> st;
	for(int i = anss; i; i = pre[i])
		st.push(i);
	while(!st.empty())
		printf("%s\n", a[st.top()].s + 1), st.pop();
	return 0;
}
```


---


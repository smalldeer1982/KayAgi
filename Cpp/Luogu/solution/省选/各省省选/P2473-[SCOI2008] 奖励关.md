# [SCOI2008] 奖励关

## 题目描述

你正在玩你最喜欢的电子游戏，并且刚刚进入一个奖励关。在这个奖励关里，系统将依次随机抛出 $k$ 次宝物，每次你都可以选择吃或者不吃（必须在抛出下一个宝物之前做出选择，且现在决定不吃的宝物以后也不能再吃）。

宝物一共有 $n$ 种，系统每次抛出这 $n$ 种宝物的概率都相同且相互独立。也就是说，即使前 $(k-1)$ 次系统都抛出宝物 $1$（这种情况是有可能出现的，尽管概率非常小），第 $k$ 次抛出各个宝物的概率依然均为 $\frac 1 n $。

获取第 $i$ 种宝物将得到 $p_i$ 分，但并不是每种宝物都是可以随意获取的。第 $i$ 种宝物有一个前提宝物集合 $s_i$。只有当 $s_i$ 中所有宝物都至少吃过一次，才能吃第 $i$ 种宝物（如果系统抛出了一个目前不能吃的宝物，相当于白白的损失了一次机会）。注意，$p_i$ 可以是负数，但如果它是很多高分宝物的前提，损失短期利益而吃掉这个负分宝物将获得更大的长期利益。

假设你采取最优策略，平均情况你一共能在奖励关得到多少分值？


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq k \leq 100$，$1 \leq n \leq 15$，$-10^6 \leq p_i \leq 10^6$。

## 样例 #1

### 输入

```
1 2
1 0
2 0
```

### 输出

```
1.500000```

## 样例 #2

### 输入

```
6 6
12 2 3 4 5 0
15 5 0
-2 2 4 5 0
-11 2 5 0
5 0
1 2 4 5 0
```

### 输出

```
10.023470```

# 题解

## 作者：xyz32768 (赞：138)

很明显是一道状压。$DP$模型很容易想到，用$f[i][S]$表示到了第$i$轮，宝物是否取过的状态为$S$的最大期望得分。

但这个模型存在问题：可能在第$i$轮无法到达状态$S$。

所以，这里把定义换一下，$f[i][S]$表示在第$1$轮到第$i-1$轮内宝物是否取过的状态为$S$，第$i$轮到第$K$轮的最大期望得分，那么这样就可以通过逆推进行转移了。

转移方程为：

对于任意一个$1<=k<=n$，

1、如果$S$包含的状态满足取第$k$种宝物的条件，则可以取或不取。不取则为$f[i+1][S]$，取则为$f[i+1][S|(1<<k-1)]+P_k$。

所以此时$f[i][S]+=max(f[i+1][S],f[i+1][S|(1<<k-1)]+P_k)$。

2、如果$S$包含的状态不满足取第$k$种宝物的条件，则不能取，即$f[i][S]+=f[i+1][S]$。

而这里求的是期望值，上面求的东西覆盖了第$i$轮取了所有$n$种宝物的情况，所以在每一个状态计算完之后，把$f[i][S]$除以$n$即为期望平均值。

最后答案为$f[1][0]$。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int M = 105, N = 17;
int K, n, p[N], sta[N];
double f[M][1 << 15];
void chkmax(double &a, double b) {a = max(a, b);}
int main() {
    int i, j, k, x; K = read(); n = read();
    for (i = 1; i <= n; i++) {
        p[i] = read(); while (x = read())
            sta[i] = sta[i] | (1 << x - 1);
    }
    for (i = K; i >= 1; i--) for (j = 0; j < (1 << n); j++) {
        for (k = 1; k <= n; k++) if ((j & sta[k]) == sta[k])
            f[i][j] += max(f[i + 1][j], f[i + 1][j | (1 << k - 1)] + p[k]);
        else f[i][j] += f[i + 1][j];
        f[i][j] /= n;
    }
    printf("%.6lf\n", f[1][0]);
    return 0;
}
```

---

## 作者：万万没想到 (赞：20)

原题传送门：[P2473 [SCOI2008]奖励关](https://www.luogu.com.cn/problem/P2473)

题目简介：

共有 $K$ 轮，有 $n$ 种物品，每一轮出现每一种物品的概率是 $\frac{1}{n}$ ，物品可选可不选，对于选每一种物品，必须要在前面的轮先选给定的部分物品，每一种物品的价格可正可负。求  $K$ 轮后按最优方案选择的期望价格。

数据范围：$1 \leq K \leq 100,1 \leq n \leq 15$。
 
解题思路：

我们可以发现 $n$ 的值很小，所以考虑使用状压DP，那么DP的式子是什么呢？

经过思考，我们基本上都可以推出，此轮的期望值=（上一轮所有可行状态的期望值+此轮所有对应可行状态的物品价格）的总和/总情况数。

再分情况讨论，设 $dp_{i,j}$ 为第 $i$ 轮状态为 $j$ 的期望值（ $j$ 是以二进制表示每个物品取或不取）， $k$ 为第几种物品。

那么式子应为 

$dp_{i,j|(1<<(k-1))}=\sum max(dp_{i-1,j|(1<<(k-1)},dp_{i-1,j}+v_i)(j \& state_k==state_k)$ 

否则$dp_{i,j|(1<<(k-1))}= \sum dp_{i-1,j|(1<<(k-1)}$ 

但是我们需要计算期望值，就是再除以总情况数，这个时候我们会发现有的情况在转移时是不存在的，总情况数是不定的，所以无法计算，而且任何状态都有可能是 $K$ 轮后的状态，所以考虑从已知推未知，采用倒推，可以推出每一个可能的状态。

上面的式子修改后如下

$dp_{i,j}= \sum max(dp_{i+1,j|(1<<(k-1)}+v_i,dp_{i+1,j})(j \& state_k==state_k)$ 

否则$dp_{i,j}= \sum dp_{i+1,j}$ 

这样的话每一个状态转移后的 $dp_{i,j}$ 的情况数都是 $n$ ，除以 $n$ 即可。

这样的话从 $k$ 循环到 $1$ ，就可以理解为从所有状态转移到所有可行的 $dp_{k,j}$ 再转移到所有可行的 $dp_{k-1_j}$ ，最终状态就是 $i$ 循环到 $1$ 后，计算完后的 $dp_{1,0}$ 就是第 $0$ 轮还没有取时的状态，也就容纳了所有的可行状态。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int K,n,v[16],state[16];
double dp[105][1<<15];
inline double Max(register double a,register double b){
	return a>b?a:b;
}
int main(){
	scanf("%d%d",&K,&n);
	int tmp;
	for(int i=1;i<=n;++i){
		scanf("%d",&v[i]);
		while(~scanf("%d",&tmp)){
			if(!tmp)break;
			state[i]|=(1<<(tmp-1));
		}
	}
	for(int i=K;i>=1;--i){
		for(int j=0;j<(1<<n);++j){
			for(int k=1;k<=n;++k){
				if((j&state[k])==state[k])dp[i][j]+=Max(dp[i+1][j],dp[i+1][j|(1<<(k-1))]+v[k]);
				else dp[i][j]+=dp[i+1][j];
			}
			dp[i][j]/=n;
		}
	}
	printf("%.6lf",dp[1][0]);
	return 0;
}
```


---

## 作者：LiftingTheElephant (赞：19)

看到$n<=15$,你想到了什么？        
# 对！          
## 状态压缩！    
所以我们定义$dp[i][s]$为在第i轮状态为s的最大期望得分    
(s的二进制下某一位为1代表选了这个宝物)    
我们又定义p[j]是第j个宝物的分数

而且,当不是逆推时,会出现不符合常理的状态。    

则当不能够选这个宝物时,$dp[i][s]=dp[i][s]+dp[i+1][s]$   

当能选这个宝物时,我们判断是否该选这个宝物。     

若选了这个宝物(设其编号为j),则$dp[i][s]=dp[i+1][s|(1<<(j-1))]+p[j]$     
(用位运算想想为什么)    

所以，我们推出：
### dp[i][s]=max(dp[i+1][s],dp[i+1][s|(1<<j-1)]+p[j]);

上代码：
```
#include <iostream>
#include <cstdio>
#define re register//优化
namespace cz//自定义double类型的max函数
{
	double max(double x,double y)
	{
		return x>y?x:y;
	}
}
using namespace std;
int n,k,maxs,p[18],need[18];//need[i]是吃第i个宝物所需要吃的宝物
double dp[105][1<<15];
inline int read()//速读不说
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	return x*f;
}
int main()
{
	k=read(),n=read();
	for(re int i=1;i<=n;i++)
	{
		p[i]=read();
		int u;
		while(scanf("%d",&u)&&u)//输入吃第i个宝物所需的宝物
			need[i]|=(1<<(u-1));
	}
	maxs=(1<<n)-1;//最大状态是全选
	for(re int i=k;i>=1;i--)//逆推
		for(re int s=0;s<=maxs;s++)//循环枚举状态
		{
			for(re int j=1;j<=n;j++)
			{
				if((need[j]&s)==need[j])//若能选宝物
					dp[i][s]+=cz::max(dp[i+1][s],dp[i+1][s|(1<<(j-1))]+p[j]);
				else//若不能选宝物
					dp[i][s]+=dp[i+1][s];
			}
			dp[i][s]/=n;//每个宝物被选中的概率为1/n
		}
	printf("%.6lf",dp[1][0]);
	return 0;
}

```

---

## 作者：Ezio__Auditore (赞：16)

## P2473 [SCOI2008] 奖励关 题解

[[Statement]](https://www.luogu.com.cn/problem/P2473)

Date: May 5th 2021

---
### 前言
一道比较简单的期望状压 dp 题。

---
### 分析：


题意转化后，就是要求你在最优策略下的期望得分。(最优策略是指能最大化期望得分策略）

注意到 $n \le 15$，可以状压当前持有(吃过)物品的状态 $S$。

我们记录物品 $i$ 的前提集合为 $R_i$，物品 $i$ 能取当且仅当 $R_i \subseteq S$，

---
#### dp 设计：

显然最优策略和当前持有的物品以及轮数有关，可以考虑利用状压 dp 求解。


如果从前往后转移，会发现问题不满足最优子结构(比如选择一个 $p_i$ 为负的物品当前看起来不优，实际上却能增加之后的期望得分)，当前选择具有后效性。

因此我们无法确定当前的最优策略，不能从前往后 dp。

---
不过如果我们知道了第 $i + 1$ 轮下，持有物品集合 $S$ 的结果，我们就能确定第 $i$ 轮的最优策略了。


于是我们可以 **从后往前** dp，具体的：


- 设计 $dp_{i,S}$ 表示当前**还剩 $i$ 轮**持有物品集合为 $S$ 在最优策略下的**未来的**期望收益。

不难发现这样 dp 没有后效性，满足最优子结构。当前选与不选某一个物品，并不会对更早的轮次产生影响。

---
#### dp 转移：

首先枚举剩余轮数 $i$ 和物品状态 $S$, 然后枚举此轮抛出 $n$ 种物品的不同情况转移。

当枚举到第 $j$ 个物品时, 分类讨论：

- 如果 $j$ 的前提集合不被满足，直接爬，反正拿不了，不用讨论，取 $dp_{i-1, S}$。
- 如果 $j$ 的前提集合被满足，根据 $p_j$ 分类：
	- 若 $p_j \ge 0$ 就直接拿，反正不亏，一定是最优策略，取 $p_j + dp_{i-1, S | j}$。

	- 若 $p_j < 0$ 就去比较还剩 $i-1$ 轮时，取 $\max\{p_j + dp_{i-1, S | j}, dp_{i-1, S} \}$，分别表示：
        
        1. 选择物品 $j$ ，接受惩罚代价 $p_j$ 使下一轮物品集合 $S' = S | j$。
        
        2. 放弃物品 $j$，下一轮物品集合仍为 $S$ 不变。

对抛出 $n$ 种物品的不同情况，在各自的最优策略下的未来期望收益取平均值，表示期望收益，作为 $dp_{i,S}$。(因为抛出每种物品的概率相等，所以期望可以用取平均值表示)

综上，可以将转移表示为：
$$
dp_{i, S} = \frac 1n \sum_{j=1}^n
\begin{cases}
dp_{i-1, S} & R_j \not \subseteq S\\
p_j + dp_{i-1,S | j} & R_j \subset S \wedge p_j \ge 0\\
\max\{p_j + dp_{i-1, S | j}, dp_{i-1, S} \} & R_j \subseteq S \wedge p_j \lt 0
\end{cases}
$$

答案为 $dp_{k, \emptyset}$，即还剩 $k$ 轮且没有任何物品时(初始状态)，在最优策略下的未来期望收益。


正确性显然，复杂度 $O(k2^nn)$ 可以接受。

---

初始化时，令 $dp_{1, S} = \frac 1n\sum_{R_j \subseteq S} \max\{p_j, 0\}$(或者 $dp_{0,S} = 0$ 也行)。


实现的时候第 $2$, $3$ 个转移可以合并，因为 $p_j \ge 0$ 时，一定有 $p_j + dp_{i-1, S|j} \ge dp_{i-1, S}$。


实际有用的 dp 数组只有 $dp_{i}$ 和 $dp_{i-1}$，可以滚动数组优化，不过在此题中没有必要。

---
### Code:

```cpp
#include <bits/stdc++.h>

template<class _Tp = int> _Tp read() {
  _Tp w = 0;
  bool f = 0;
  char ch = getchar();
  while (!isdigit(ch)) f |= ch == '-', ch = getchar();
  while (isdigit(ch)) w = (w << 3) + (w << 1) + (ch ^ 48), ch = getchar();
  return f ? -w : w;
}

const int kMaxN = 15, kMaxK = 1e2 + 5;
int n, k;
int R[kMaxN];
int p[kMaxN];
double dp[kMaxK][1 << kMaxN];
int main() {
  k = read(), n = read();
  for (int i = 0, r; i < n; i++) {
    p[i] = read();
    while(r = read())
      R[i] |= 1 << (r - 1);
  }
  for (int i = 1; i <= k; i++)
    for (int S = 0; S < 1 << n; S++) {
      for (int j = 0; j < n; j++)
        if ((R[j] & S) != R[j]) dp[i][S] += dp[i - 1][S];
        else 
          dp[i][S] += std::max(dp[i - 1][S], p[j] + dp[i - 1][S | 1 << j]);
      dp[i][S] /= n;
    }
  printf("%.6lf", dp[k][0]);
  return 0;
}
```

---
$\mathfrak{The\ End.}$

---

## 作者：KokiNiwa (赞：11)

[题目](https://www.luogu.org/problem/P2473)

之所以写这篇文章，是因为某次NOIP前的模拟考试考了与递推顺序相关的问题，并且我在那道题上出了极大的锅。

这道题状态的设置并不复杂，简单易懂的状压。

复杂的在于$dp$的顺序，这非常关键。一开始的想法是顺着$dp$，但是后来发现大家都是倒推的，于是我就放弃了顺推。实际上，顺推也是错误的。
> 因为一个状态到后面状态的可能性是均分的（1/n1/n），但是由从其他状态导入后一个状态时，由于题目条件的约束，其他状态的各个概率并不是均分的。而且这题的条件约束是个乱七八糟的集合，毫无规律，所以正推不了。

这里引用了某巨佬的话 @天泽龟。

最后搁个代码：
```cpp
#include <cstdio>

using namespace std;

const int N = 20, WEISHU = 15, K = 110;
int k, n;
int yiLai[N], val[N];
double dp[2][1 << WEISHU];

double maxDouble(double x, double y) {
	return x > y ? x : y;
}

int main()
{
	scanf("%d%d", &k, &n);
	for (int i = 1; i <= n; ++i) {
		int x;
		scanf("%d", &val[i]);
		scanf("%d", &x);
		while (x) {
			yiLai[i] += 1 << (x - 1);
			scanf("%d", &x);
		}
	}
	for (int i = k; i >= 1; --i) {
		for (int state = 0; state < (1 << n); ++state) {
			dp[i & 1][state] = 0;
			for (int j = 1; j <= n; ++j) {
				if ((state & yiLai[j]) == yiLai[j]) {
					dp[i & 1][state] += maxDouble(dp[(i + 1) & 1][state | (1 << (j - 1))] + val[j], dp[(i + 1) & 1][state]);
				}
				else dp[i & 1][state] += dp[(i + 1) & 1][state];
			}
			dp[i & 1][state] /= n;
		}
	}
	printf("%lf\n", dp[1][0]);
	return 0;
}
```
最后的最后，记录一句话：
> 概率是顺推，而期望需要逆推。

---

## 作者：ddwqwq (赞：11)

我来讲讲本题动态规划对应的实际意义，顺便给出一个记忆化搜索版本的代码。  
首先，用两个维度表示状态，dp[i][j]代表从第i个宝物开始，当前状态（已经取过的宝物）为j的情况下，用最优策略应对，到最后可以取得的分数的期望值。   
期望值如何计算呢？因为当前这一轮出现任何宝物的几率相等，所以期望值等于 所有情况下期望得分的和 除以 情况数。而出现第k种宝物的情况下，期望得分为max(dp[i+1][j],dp[i+1][j|1<<k] + P[k])。所以，转移方程为  
dp[i][j]=Σ(1<=k<=N)max(dp[i+1][j],dp[i+1][j|1<<k] + P[k]) / N。   
dp[i][j],i>N的情况是基础情形，期望得分为0。  
那么，如何根据已有的结果，得到最优应对策略呢？假设当前正在出现第i个宝物，状态为j，出现了第k种宝物。如果状态j不满足要求，自然不收取宝物。否则，如果dp[i+1][j]>dp[i+1][j|1<<k]+P[k]，则说明不收取的期望收益大，反之则是收取的期望收益大。  
然后是代码，对于这样的dp，我总觉得搜索更自然些。
```
#include <cstdlib>
#include <iostream>
#include <cstdio>
#include <math.h>
#include <cstring>
#include <time.h>

#pragma warning(disable:4996)
#define INF 2000000005//2 * 10^9
#define lowbit(a) ((a)&-(a))
inline double max(double a, double b)
{
    return a>b ? a : b;
}
inline long long min(long long a, long long b)
{
    return a<b ? a : b;
}

const int MAXN = 105;

int K, N;
double P[MAXN];
bool s[MAXN][MAXN];
double dp[MAXN][100000];

double dfs(int n, int S)
{
    if (n > K)
        return 0;
    if (dp[n][S] > -INF + 1)
        return dp[n][S];
    int i, j;
    dp[n][S] = 0;
    for (i = 1; i <= N; i++)
    {
        bool flag = true;
        for (j = 1; j <= N; j++)
            if (s[i][j] && !(S&(1 << (j - 1))))
            {
                flag = false;
                break;
            }
        if (flag)
            dp[n][S] += max(dfs(n + 1, S), dfs(n + 1, S | (1 << (i - 1))) + P[i]);
        else
            dp[n][S] += dfs(n + 1, S);
    }
    dp[n][S] /= N;
    return dp[n][S];
}

int main()
{
    int i, j;

    for (i = 0; i < MAXN; i++)
        for (j = 0; j < 100000; j++)
            dp[i][j] = -INF;

    scanf("%d %d", &K, &N);
    for (i = 1; i <= N; i++)
    {
        scanf("%lf", &P[i]);
        int t;
        do {
            scanf("%d", &t);
            s[i][t] = true;
        } while (t);
    }

    printf("%lf", dfs(1, 0));

//	system("pause");
    return 0;
}
```

---

## 作者：crescentic (赞：8)

[奖励关](https://www.luogu.com.cn/problem/P2473)

可以去看我整理的[学习笔记](https://www.luogu.com.cn/blog/140643/zhuang-ya-dp-xue-xi-bi-ji)鸭~逃（

**题意简述**：共有 $K$ 轮，有 $n$ 种物品，每一轮出现每一种物品的概率 $\frac{1}{n}$，物品可选可不选，对于选每一种物品，必须要在前面的轮先选给定的部分物品，每一种物品的价格可正可负。求 $k$ 轮后按最优方案选择的期望价格。

数据范围：$1\leq K \leq 100$ , $1≤n≤15$。

**思路**：

首先看题，概率 $dp$ 没得跑。

再看数据范围，哦豁！状压 $dp$ ！

这道题不同的是需要倒推，因为正推的话有些情况在转移时选择宝物的概率并不是平均的（有宝物合集的限制），这样就会导致结果出现问题，且最终答案的状态表示十分麻烦 ~~不要问我是怎么知道的！~~，因此选择倒推。

另外，因为 $dp$ 的转移至于**当前局**和**前一局**有关，所以可以用滚动数组优化一下。

还有就是，这里用到了一个状压**小技巧**。很多时候题目会给定**条件限制**，即枚举状态的**前提条件**。这里就再次用到了二进制小技巧。

这里就以这道题为例：

```cpp
	while(~scanf("%d",&x) && x)
		num[i] += 1 << (x - 1);//用二进制数存储 宝物集合 
```
如果得到第 $i$ 个宝物之前需要**先**得到第 $x$ 个宝物，我们就在 $num[i]$ 的值加上 $1 << (x - 1)$，最后$num[i]$的值就是要得到第 $i$ 个宝物的**先决条件**，枚举时的状态**必须满足** $num[i]$ 的要求。

其实这里就是在模拟二进制的形成，计算出满足题意的状态值，是不是很简单啊。

**解题步骤**：

- 先循环游戏轮数 $i$；
- 然后每轮枚举当前宝物的状态 $j$(第 $x$ 位为 $0$ 则未得到该宝物，反之得到)；
- 再枚举当局游戏抽到的宝物编号 $k$,判断是否满足条件（满足该宝物的先决条件）在拿 $k$ 宝物和不拿之间选最大值加到当前状态；
- 最终期望要乘上随机选择一个宝物的概率，因为是随机选择的啦。
- 因为是倒推的，所以最后答案为游戏开始时，未得到任何一个宝物的情况 

坑：因为用的滚动数组，所以每次记得清空 ~~不要问我是怎么知道的！~~

其他细节讲解都在代码里啦~

**完整代码**：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int K,n,x,w[20],num[20];
double p,dp[2][1 << 15];
int main() {
	scanf("%d %d",&K,&n);
	p = 1.0 / n;//选择宝物的平均概率 
	for(int i = 1; i <= n; i ++) {
		scanf("%d",&w[i]);//分值 
		while(~scanf("%d",&x) && x)
			num[i] += 1 << (x - 1);//用二进制数存储 宝物集合 
	}
	int maxn = 1 << n;
	for(int i = K; i >= 1; i --) { //游戏轮数 
		for(int j = 0; j < maxn; j ++) {
			dp[i & 1][j] = 0;//初始化（清空上一次循环的值） 
			for(int k = 1; k <= n; k ++) {//枚举这轮抽到的宝物 
				if((j & num[k]) == num[k])//如果满足k宝物的 宝物集合要求,
					dp[i & 1][j] += max(dp[(i + 1) & 1][j | (1 << (k - 1))] + w[k],dp[(i + 1) & 1][j]);
					//满足最优策略，在拿k宝物和不拿之间选最大值 
				else dp[i & 1][j] += dp[(i + 1) & 1][j];//不满足的话，该状态及为上一次的状态，没有变化 
			}
			dp[i & 1][j] *= p;//最终期望要乘上随机选择一个宝物的概率 
		}
	} 
	printf("%.6lf",dp[1][0]);
	//因为是倒推的，所以最后答案为游戏开始时，未得到任何一个宝物的情况 
	return 0;
} 
```

---

## 作者：tommymio (赞：4)

经典倒序 $\text{DP}$，期望 $\text{DP}$ 复健题。

这题显然有一个状压 $\text{DP}$ 的模型。便想到设 $f_{i,S}$ 为抛出了 $i$ 次宝物，当前状态为 $S$ 所能得到的最大代价。可以使用刷表法转移，但由于可能存在第 $i$ 轮无法到达 $S$ 的情况，所以这个 $\text{DP}$ 存在正确性上的问题。

于是想到改变状态定义。设 $f_{i,S}$ 为在当前状态下到达最终状态能够取到的最大价值。设宝物 $x$ 依赖的宝物构成的集合为 $p_x$，有转移方程：

$$
f[i,S]=\frac{1}{n}\sum_{x=0}^{n-1}\max((f[i+1,S|(1<<x)]+a_x)\times[p_x\subset S],f[i+1,S])
$$

从 $(k-1)\sim 0$ 倒序转移，最终答案即为 $f[0,0]$。

```cpp
#include<cstdio>
double f[105][1<<15];
int p[15],a[15];
inline int read() {
    register int x=0,f=1;register char s=getchar();
    while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
    while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
    return x*f;
}
inline double max(const double &x,const double &y) {return x>y? x:y;}
int main() {
    int k=read(),n=read();
    for(register int i=0;i<n;++i) {a[i]=read(); for(register int x=read();x;x=read()) p[i]|=(1<<(x-1));}
    for(register int i=k-1;i>=0;--i) {
        for(register int S=0;S<(1<<n);++S) {
            for(register int x=0;x<n;++x) {if(!((S&p[x])^p[x])) f[i][S]+=max(f[i+1][S],f[i+1][S|(1<<x)]+a[x]);  else f[i][S]+=f[i+1][S];} 
            f[i][S]/=n; 
        }
    }
    printf("%.6lf\n",f[0][0]);
    return 0;
}
```

---

## 作者：miao5 (赞：4)

**思路**

妥妥的**概率期望 dp** ~~~

再看一下数据范围。

！！！ $n≤15$ ！！！

**状压 dp** ！！！

要注意一点这道题要用**倒退dp**，因为宝物集合 S 的限制，所以正着 dp 选择宝物的概率是不平均的。这样会导致答案不正确，所以我们要倒着dp。

##小读入

```cpp
while(1){
    cin>>x;
    if(x==0) break;
    num[i]+=1<<(x-1);
}
```






这里 num[i] 是可以吃第 i 个宝物的先决条件集合。因为每个宝物是不一样的，所所以我们就能拿一个数存储一个集合。

这时候我们就要逐步 dp 了。

- 先循环游戏回合。

- 枚举宝物的状态 j (选与不选）。

- 枚举本回合抽到的宝物 l ，如果满足吃 l 的条件，我们就在吃与不吃中做选择，如果不满足，我们不能吃。

- 因为是随机选择，最后乘上选宝物的概率，即为 $\frac{1}{n}$ 。

- 愉快地输出并且A了这道题。


##小技巧 

因为每回合只用本回合和上回合的数据，所以可以滚动掉。


##小坑点 

因为用的滚动数组，所以每回合的开始要清空。


```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
using namespace std;
int k,n,v[20],num[20];
double m,f[2][1<<15];
int main(){
	cin>>k>>n;
	m=1.0/n;
	for(int i=1;i<=n;i++){
		cin>>v[i];
		int x;
		while(1){
			cin>>x;
			if(x==0) break;
			num[i]+=1<<(x-1);
		}
	}//读入 
	int maxn=1<<n;
	for(int i=k;i>=1;i--){
		for(int j=0;j<maxn;j++){
			int p=i&1;
			int q=(i+1)&1;
			f[p][j]=0;//初始化 
			for(int l=1;l<=n;l++){//枚举宝物 
				if((j&num[l])==num[l]) f[p][j]+=max(f[q][j|(1<<(l-1))]+v[l],f[q][j]);//转移 
				else f[p][j]+=f[q][j];
			}
			f[p][j]*=m;//乘上概率 
		}
	} 
	printf("%.6lf",f[1][0]);
	return 0;
} 
```


---

## 作者：ttt_TTT (赞：3)

**期望dp+状态压缩dp
**
最好采用倒推，不需要考虑不存在的情况。

f[i][j]表示选第i次之前状态为j的最大期望，

那么每次枚举到一种宝物，判断其能否选，推出期望值。

答案就是f[1][0]

```
#include <cstdio>
int sc[20] , need[20];
double f[102][32770];
double max(double a , double b)
{
    return a > b ? a : b;
}
int main()
{
    int k , n , i , j , l , x;
    scanf("%d%d" , &k , &n);
    for(i = 1 ; i <= n ; i ++ )
    {
        scanf("%d" , &sc[i]);
        while(scanf("%d" , &x) && x != 0)
            need[i] |= 1 << (x - 1);
    }
    for(i = k ; i ; i -- )
    {
        for(j = 0 ; j < 1 << n ; j ++ )
        {
            for(l = 1 ; l <= n ; l ++ )
                if(!((~j) & need[l]))
                    f[i][j] += max(f[i + 1][j] , f[i + 1][j | (1 << (l - 1))] + sc[l]);
                else
                    f[i][j] += f[i + 1][j];
            f[i][j] /= n;
        }
    }
    printf("%.6lf\n" , f[1][0]);
    return 0;
}
```

---

## 作者：寒冰大大 (赞：2)

[P2473 SCOI2008奖励关](https://www.luogu.com.cn/problem/P2473)

题面懒得描述。

根据题意列出$dp$方程$f[i][S]$,即第i轮情况为s的平均分。

考虑顺序枚举，最后得到的答案有$15^{100}$种可能性，显然你需要手写高精，并且不可能刚开始就吃掉所有的点，顺序还需要加几个数组来标记一下当前可能到的情况，所以考虑倒序枚举。

然后写代码，发现如果先枚举$i,j$,在枚举本轮情况，最后并不好处理平均数（其实就多了个循环）,于是为了偷懒先枚举$i$再枚举$k$然后再$j$.

考虑转移，显然转移要考虑这一层能否对下一层产生影响，那就要考虑能不能包含$j$这个点所需的前提宝物，如果可以的话，就能获得价值为$a[j]$的分数，由于是倒序枚举，所以我们转移回来$f[i][k]$（原先是转移到$f[i][k']$，$k'$包含$j$）

最后$f[1][0]$就是我们要的答案了

最后代码奉上

```cpp
#include<touwenjian.h>

using namespace std;

double f[110][75536];
int s[20],a[20];
int n,m;

int main()
{
    scanf("%d %d",&m,&n);
    int i,j,t;
    for(i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        while(1)
        {
            scanf("%d",&t);
            if(t==0) break;
            s[i]|=1<<(t-1);
        }
    }
    int k;
    for(i=m;i;i--)
    for(k=0;k<=(1<<n)-1;k++)
    {
        for(j=1;j<=n;j++) if((s[j]&k)==s[j]) f[i][k]+=max(f[i+1][k],f[i+1][k|(1<<(j-1))]+a[j]);
        else f[i][k]+=f[i+1][k];
        f[i][k]=f[i][k]*1.0/n;
    }
    printf("%.6lf",f[1][0]);
}
```



---

## 作者：Ccreeper (赞：2)

状压入门题。

# [更好的阅读体验](https://ccreeper33.github.io/2019/07/04/P2473-SCOI2008-%E5%A5%96%E5%8A%B1%E5%85%B3/)

## 分析

首先看数据范围，
$$n \le 15$$
**状态压缩**。

个人喜欢用记忆化搜索，以下为记忆化搜索写法。

## 解题过程

分别用整数$p$、$s$来表示`当前的宝物编号`和`当前已获得过的宝物集合`。

### 对于每件宝物我们分类讨论

1. 显然，若当前的宝物为**已获得过**的种类，则是否吃掉都**不**影响后续结果。所以当前宝物分数若为正，则吃掉最优，反之则反。

2. 若当前宝物**未获得过**，首先**判断当前集合是否满足其前提集合**。若**满足**，则按其分值进行对应操作：分值为正，则吃掉一定更优；分值为负，则搜索吃与不吃两种操作，取更优值。若**不满足**当前宝物的前提集合，显然跳转下一宝物。

## 附代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned short state;    //15对应的范围
const int maxn = 16, maxk = 105;

struct treasure {  //宝物
	int val; //价值
	state pre; //前提集合
}trs[maxn];

int n, k, temp;
bool vis[1 << maxn][maxk];  //通过vis数组防止被f全为0的数据hack
double f[1 << maxn][maxk];  //记忆化数组，保存已选集合为s、选到第p个宝物时的期望

double dfs(state s = 0, int p = 0) {
	if(vis[s][p]) return f[s][p];
	if(p == k) return 0;
	for(int i = 1; i <= n; ++i) {
		if(s & (1 << i))   //是否已在当前集合内
			f[s][p] += (trs[i].val > 0 ? trs[i].val : 0) + dfs(s, p + 1);
		else if((s & trs[i].pre) == trs[i].pre)  //是否满足前提集合 
			if(trs[i].val > 0) f[s][p] += trs[i].val + dfs(s + (1 << i), p + 1);
			else f[s][p] += max(dfs(s, p + 1), trs[i].val + dfs(s + (1 << i), p + 1));
		else f[s][p] += dfs(s, p + 1);
	}
	return vis[s][p] = true, f[s][p] /= n; //取平均值
}

void init() {  //读入
	scanf("%d%d", &k, &n);
	for(int i = 1; i <= n; ++i) { 
		scanf("%d", &trs[i].val);
		while(true) {
			scanf("%d", &temp);
			if(!temp) break;
			trs[i].pre |= (1 << temp);
		}
	}
}

int main() {
	init();
	printf("%.6f\n", dfs());
	return 0;
}
```

---

## 作者：meizhuhe (赞：1)

# 动态规划——期望 DP +状压 DP
$(1)$ **状态定义**


设 $dp[i][S]$ 为在前 $i$ 次吃过集合 $S$ 时 $(i+1) \dots k$ 次吃所得到的期望分值


$(2)$ **转移方程**

考虑第 $(i+1)$ 次抛的情况:

对于任意的宝物 $j$，有：

若 $s(j) \subseteq S $ ，则既可以吃也可以不吃，取较大者；
反之，只能不吃

综上所述，得到转移方程：

$$ dp[i][S]=\frac{ \sum_{j}f(j,S)}{n} $$
$$
f(j,S)=
\begin{cases}
\max(dp[i+1][S + j]+p_j,dp[i+1][S]) & s_j \subseteq S\\
dp[i+1][S]&s_j\not\subset S
\end{cases}

$$

$(3)$ **边界情况与答案**

显然，根据定义有
$$ dp[k][S]=0,Ans=dp[0][0] $$


$(4)$ **注意点**

$a.$ 位运算优先级**小于**逻辑运算，因此要打括号

$b.$ 集合的并集与判断是否属于可以用位运算实现（具体见代码）


```cpp
#include <bits/stdc++.h>
#define MAXN 16
#define MAXK 101
#define MAXS (1<<15)+1
using namespace std;
int p[MAXN];
int s[MAXN];

double dp[MAXK][MAXS];
int main(){
	//freopen("read.in","r",stdin);
	//freopen("write.out","w",stdout);
	int k,n,x;
	double g=1.0;
	scanf("%d%d",&k,&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&p[i]);
		while(scanf("%d",&x),x!=0)
			s[i]|=1<<x-1;
	} 
	g/=n;
	for(int i=k-1;i>=0;i--)
		for(int S=0;S<(1<<n);S++){
			dp[i][S]=0;
			for(int j=1;j<=n;j++)
				if((S|s[j])==S)
					dp[i][S]+=max(g*(dp[i+1][1<<j-1|S]+p[j]),g*dp[i+1][S]);
				else
					dp[i][S]+=g*dp[i+1][S];
		}
	/*
	for(int i=0;i<k;i++){
	
		for(int S=0;S<(1<<n-1);S++)
			printf("dp[%d][%d]=%-7.2f",i,S,dp[i][S]);
		printf("\n");
	}
	*/
	printf("%.6f",dp[0][0]);
	return 0;
}
```


---

## 作者：凌曦月 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P2473)

我就是一个成功的反例...

直接正着推，直接推成了憨憨

### 思路

首先我们看题：

$n<=15$，灵光一闪。

淦哪！我们可以很肯定这是一个状压$DP+$期望$DP$。

状态也十分清楚：
$f[i][j]$为从到第$i$轮，状态为$j$的最大期望值。然后再推到最后...

如果你到了这个地步，那你就成功地和我一样成为铁憨憨了。

因为$f[i][j]$这个状态可能在之前的$i$轮中达不到$j$这个状态...

那怎么办？怎么办！~~凉拌抄鸡蛋~~ 逆着推，就可以避免这种错误了~~一把辛酸泪~~。

我们定义$f[i][j]$为从**第$k$轮到第$i$轮，状态为$j$的最大期望值**。

如果我们$j$包含的状态满足取第$k$宝物的条件，我们**就可以取这个宝物**。**当然也可以不取**。

```cpp
if((j & sta[k])==sta[k])    //可以取
    f[i][j]+=max(f[i+1][j],f[i+1][j|(1<<(k-1))]+a[k]);
```

否则，我们就不取这个宝物，我们取不到！

```cpp
f[i][j]+=f[i+1][j];
```
我们把每个宝物都考虑后，直接把$f[i][j]$除以$n$。因为我们的各个宝物的概率依然均为$\frac{1}{n}$。
```cpp
f[i][j]/=n;
```

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=20,maxk=105;
int n,k,a[maxn],sta[maxn];
double f[maxk][1<<maxn];
//f[i][k]为第i~k轮，状态为k 

int read(int &x) {
	int f=1; x=0; char ch=getchar();
	while(ch<'0' || ch>'9') { if(ch=='-') f=-1; ch=getchar(); }
	while(ch>='0' && ch<='9') { x=(x<<1)+(x<<3)+(ch^48); ch=getchar(); }
	x*=f;
	return 1;
}

int main() {
	read(k),read(n);
	for(int i=1,x;i<=n;i++) {
		read(a[i]);
		while(read(x) && x) sta[i]|=(1<<(x-1)); //前提宝物集合
	}
	
	for(int i=k;i;i--) {    //逆推
		for(int j=0;j<(1<<n);j++) { //枚举状态
			for(int k=1;k<=n;k++) { //枚举宝物
				if((j & sta[k])==sta[k])    //可以选这个宝物
                    f[i][j]+=max(f[i+1][j],f[i+1][j|(1<<(k-1))]+a[k]);
				else f[i][j]+=f[i+1][j];    //不可以选这个宝物
			}
			f[i][j]/=n; //概率
		}
	}
	
	printf("%.6lf",f[1][0]);
	return 0;
}
```

---

## 作者：crashed (赞：0)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P2473)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到这道题，不难考虑一个期望$DP$。由于$n$很小，转移还和集合有关系，我们便可以想到一个状压的做法。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$f(i,S)$：前$i$个物品，**已吃下去**（丢弃的不算）集合为$S$时，还能得到的最大期望。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;边界是$\forall S\subseteq \{1,2,...,n\},f(k,S)=0$，也就是拿满$k$个之后就再也不会有多的收益了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转移：  
$$f(i,S)=\frac 1 n\sum_{j=1}^n\left(\begin{cases}\max\{f(i+1,S),f(i+1,S+\{j\})+P_j\}&S_j\subseteq S\\f(i+1,S)&S_j\not\subseteq S\end{cases}\right)$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$f(i+1,S)$即抛弃当前物品；$f(i+1,S+\{j\})+P_j$表示选择当前物品，需要满足前置集合已经全部吞下去了。前面乘上一个$\frac 1n $，因为这是求期望，需要算上概率。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案即是$f(0,\emptyset)$。  
# 代码
```cpp
#include <cstdio>

const int INF = 0x3f3f3f3f;
const int MAXK = 105, MAXN = 20, MAXSIZ = ( 1 << 15 ) + 5;

template<typename _T>
void read( _T &x )
{
	x = 0; char s = getchar(); int f = 1;
	while( s < '0' || '9' < s ) { f = 1; if( s == '-' ) f = -1; s = getchar(); }
	while( '0' <= s && s <= '9' ) { x = ( x << 1 ) + ( x << 3 ) + s - '0', s = getchar(); }
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ) { putchar( '-' ), x = -x; }
	if( 9 < x ) write( x / 10 );
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MAX( const _T a, const _T b )
{
	return a > b ? a : b;
}

double f[MAXK][MAXSIZ];
int a[MAXN], pS[MAXN];
int K, N;

int lowbit( const int x ) { return x & ( -x ); }
bool subSet( const int T, const int S ) { return ( S & T ) == T; }
int count( int S ) { int ret = 0; while( S ) ret ++, S -= lowbit( S ); return ret; }

int main()
{
	read( K ), read( N );
	for( int i = 1, k ; i <= N ; i ++ )
	{
		read( a[i] );
		while( true )
		{
			read( k );
			if( ! k ) break; pS[i] |= 1 << k - 1;
		}
	}
	double per = 1.0 / N;
	int upper = 1 << N;
	for( int i = K - 1 ; ~ i ; i -- )
		for( int S = 0 ; S < upper ; S ++ )
			if( count( S ) <= i )
				for( int j = 1 ; j <= N ; j ++ )
				{
					if( subSet( pS[j], S ) ) f[i][S] += per * MAX( f[i + 1][S], f[i + 1][S | ( 1 << j - 1 )] + a[j] );
					else f[i][S] += per * f[i + 1][S];
				}
	printf( "%.6f\n", f[0][0] );
	return 0;
}
```

---

## 作者：Sym_Je (赞：0)

          P2473 [SCOI2008]奖励关 
   [P2473 [SCOI2008]奖励关](https://www.luogu.org/problemnew/show/P2473)   
   这又是一道状压dp题，我们看一下如何转移，首先我们发现如果一个数如果不再这个状态中，并且他的条件已经满足，就可以转移。     
   于是我们又发现如果我们按照普通的正着转移，我们就要用没有出现过的状态去推出现过的状态。所以我们考虑倒着推，把每种状态从后到前推出来，在加上一个值，这样就如同从11111--->00000 ，于是我们设dp[i][j]表示前i次转移状态为j的期望得分。    
   转移直接看他其中有没有满足所有关于x的所有条件。
   就分情况讨论就ok咯。              
   
   ```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>

using namespace std;

int k,n;

double dp[150][1<<16+2];

int v[150];

int need[150];

int main()
{
	scanf("%d%d",&k,&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&v[i]);
		int x;
		while(scanf("%d",&x)&&x!=0)
		{
			need[i]|=(1<<(x-1));
		}
	}
	for(int i=k;i;i--)
	{
		for(int j=0;j<1<<n;j++)
		{
			for(int kk=1;kk<=n;kk++)
			{
				if(!((~j)&(need[kk])))
				dp[i][j]+=max(dp[i+1][j],dp[i+1][j|(1<<(kk-1))]+v[kk]);
				else
				{
					dp[i][j]+=dp[i+1][j];
				}
			}
			dp[i][j]/=n;
		}
	}
	printf("%.6lf\n",dp[1][0]);
	return 0;	
}

```
   
   

---

## 作者：louhao088 (赞：0)

## 题意
有n种物品，每种无限个，每个物品有自己的价值，选一个物品必须要先选其前提的物品，求取k次后的最大值


## 思路

拿道题一看，发现$n<=15$ 不是深搜就是状压。很容易就用状压水了过去。

不知道楼上各位巨佬为什么要倒着算，反正我觉得此题正着即可。


设$f[i][j]$表示第i行的状态为j最大数量

由于每次都可以选$n$个故需除$n$

每次都把之前的加起来，若满足条件就判断转移是否最优



```cpp
#include<bits/stdc++.h>
using namespace std;
int n,K,p[20],s[20],x;
double f[105][(1<<15)+1];
int main()
{
	cin>>K>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>p[i];cin>>x;
		while(x!=0)//前提条件用二进制存好 
		{
			s[i]=s[i]+(1<<(x-1));
			cin>>x;
		}
	}
	for(int i=1;i<=K;i++)
	{
		for(int j=0;j<(1<<n);j++)	
		{
			for(int k=1;k<=n;k++)//枚举选哪个 
			{
				if((s[k]&j)==s[k])
					f[i][j]+=max(f[i-1][j],f[i-1][j|(1<<(k-1))]+p[k]);
				else f[i][j]+=f[i-1][j];
			}	
			f[i][j]/=n;
		}			
	}
	printf("%.6lf",f[K][0]);
	return clock（）;
}
```



---


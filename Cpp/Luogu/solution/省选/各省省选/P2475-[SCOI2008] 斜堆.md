# [SCOI2008] 斜堆

## 题目背景

四川2008NOI省选


## 题目描述

斜堆(skew heap)是一种常用的数据结构。它也是二叉树，且满足与二叉堆相

同的堆性质：每个非根结点的值都比它父亲大。因此在整棵斜堆中，根的值最小。

但斜堆不必是平衡的，每个结点的左右儿子的大小关系也没有任何规定。在本题

中，斜堆中各个元素的值均不相同。

在斜堆 H 中插入新元素X 的过程是递归进行的：当H 为空或者X 小于H

的根结点时X 变为新的树根，而原来的树根（如果有的话）变为X 的左儿子。

当X 大于H 的根结点时，H 根结点的两棵子树交换，而X（递归）插入到交换

后的左子树中。

给出一棵斜堆，包含值为0~n的结点各一次。求一个结点序列，使得该斜堆

可以通过在空树中依次插入这些结点得到。如果答案不惟一，输出字典序最小的

解。输入保证有解。


## 说明/提示

2 <= n <= 50


## 样例 #1

### 输入

```
6
100 0 101 102 1 2```

### 输出

```
0 1 2 3 4 5 6```

## 样例 #2

### 输入

```
6
100 0 2 102 4 104```

### 输出

```
4 6 5 2 0 1 3```

## 样例 #3

### 输入

```
7
0 100 1 102 2 3 5```

### 输出

```
2 5 0 3 4 6 7 1```

# 题解

## 作者：潜翎 (赞：15)

其实这篇题解只是对另一篇dalao题解经由自己理解的再阐释，侵删致歉啦qwqqqqq

我们使用的方法是：根据数据把堆的形状搞出来，然后我们在这个堆里找最后一个插入的点，然后我们还原这个点插入之前的情况，然后重复此过程，我们就能得到插入序列啦。

现在问题来了，如何找到最后一个插入的点呢？

阅读题目可知，新节点的插入**无论如何**都是往**左子树**插入，所以这个节点一定是在**根节点一路向左的地方**。

至于左右子树交换的操作，是在**插入这个节点之前就进行的**，所以对这个节点在左子树这个结论**没有影响**。

然后这个节点要么一路插到底（没儿子），要么是在某个点停下来，使原来在这里的点成为它的左子树，所以这个点**一定没有右子树**。

好啦，这样我们就可以找到这个点啦。

可是这个点不唯一怎么办？

假设我们找到了**点u**和相对点u深度更大的**点v**符合我们的条件。

如果点v仍然具有左子树，那么点v一定比点u先插入。因为若是点u先插入，点v再插入时，点u会和这颗树的右子树进行一次交换，就不符合给定树的形态了。

那么如果有更多点满足上面的条件，我们就选**深度最小**的。

如果点v没有左子树，那么谁先插入都可以，但是题目中给定的是**小根堆**，而我们要求**方案字典序最小**，那么我们认为点u先插入。

注意，我们**先记录**的点其实是**较后**插入的点，所以此时先**记录**点v

好啦，代码奉上。

如果帮助到你，记得点赞哦
```cpp
#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
int n;
int ch[100][2],fa[100],ans[100];
int main()
{
    int p;
    scanf("%d",&n);
    memset(ch,-1,sizeof(ch));//记得初始化哦 
    fa[0]=-1;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&p);
        if(p<100)
        {
            ch[p][0]=i;
            fa[i]=p;
        }
        else
        {
            ch[p-100][1]=i;
            fa[i]=p-100;
        }
    }
    int rt=0,del,pos;//根，要删的点，指向的位置。 
    for(int i=0;i<=n;i++)
    {
        pos=rt;//从根开始找 
        del=-1;//没找到删除位置 
        while(del==-1)//还没找到可删的呢 
        {
            if(ch[pos][1]==-1) del=pos;//莫得右儿子 
            pos=ch[pos][0];
        }
        if(ch[del][0]!=-1&&ch[ch[del][0]][0]==-1) del=ch[del][0];//字典序大的后删除 
        ans[i]=del;
        if(del==rt) rt=ch[rt][0];//此时一定没有右儿子所以直接赋值就好啦qwq 
        else//做删除的逆向操作，把这个堆还原回去啦qwq 
        {
            ch[fa[del]][0]=ch[del][0];
            if(ch[del][0]!=-1) fa[ch[del][0]]=fa[del];
            pos=fa[del];
            while(pos!=-1)
            {
                swap(ch[pos][0],ch[pos][1]);
                pos=fa[pos];
            }
        } 
    }
    for(int i=n;i>=0;i--) printf("%d ",ans[i]);
    return 0;
}
```


---

## 作者：马必辰 (赞：13)

看题目有点难，尤其是数据范围小的让人怀疑。但结合一下左偏树的特别，就很容易理解了，其实就是一道递归的水题。


首先要理解一点，不会出现结点只有右子树的情况，也就是一个结点如果有右子树就必须要有左子树。


因此最后插入的那个点一定是从根节点开始一直沿着左边往下的，并且没有右子树。


但满足这个条件的结点可能很多。


如果符合要求的结点x的左子树中包含两个及以上结点并且还有满足条件的结点y，最后插入的一定是x，否则插入y的之前x只有右子树而没有左子树。因此选取满足条件的结点中深度最小的一个。


如果符合要求的结点x的左子树中只包含一个结点y，那么x和y都可以。但在字典序最小的情况下，后插入的点选y。


下面是代码，看不懂可以私信我。


```cpp
    #include<cstdio>
    int a,b,c,d,e,f,g,i,m,n,x[100][10]={0};
    int main()
    {
    scanf("%d",&a);
    for(i=0;i<=a;i++)
    {
        x[i][1]=x[i][2]=x[i][3]=-1;
    }
    for(i=1;i<=a;i++)
    {
        scanf("%d",&b);
        if(b<100)
        {
            x[b][1]=i;
            x[i][3]=b;
        }
        else
        {
            x[b-100][2]=i;
            x[i][3]=b-100;
        }
    }
    c=0;
    for(i=0;i<=a;i++)
    {
        d=c;
        e=-1;
        while(e<0)
        {
            if(x[d][2]==-1) e=d;
            d=x[d][1];
        }
        if((x[e][1]>=0)&&(x[x[e][1]][1]<0)) e=x[e][1];
        x[i][4]=e;
        if(e==c) c=x[e][1];
        else
        {
            x[x[e][3]][1]=x[e][1];
            if(x[e][1]>=0) x[x[e][1]][3]=x[e][3];
            d=x[e][3];
            while(d>=0)
            {
                b=x[d][1];
                x[d][1]=x[d][2];
                x[d][2]=b;
                d=x[d][3];
            }
        }
    }
    for(i=a;i>=0;i--)
    {
        printf("%d ",x[i][4]);
    }
}
```

---

## 作者：trsins (赞：4)

这题挺好玩的））

话说这题的题面是真的难懂，懂了之后你就会觉得这东西真挺好玩的。

斜队支持的操作非常有个性，你不难发现它几乎每种操作都和左子树有关。然后它插入节点时根节点变为左节点真的是非常的好玩。你理性理解一波，这样下来这棵树是不是越来越像**左偏树**。

然后你就~~非常自然地~~想到左偏树的一些性质，很巧，斜堆也支持。

1. 一个节点如果有右子树，就一定有左子树。

2. 最后插入的节点一定没有右子树。

说一下吧。第一个性质还是非常感性理解的，你既然有了右子树，左子树的优先级都比右子树高那既然右子树有了左子树必须有啊不然那个右子树变左子树了））

第二个性质结合一下斜堆的插入操作理性理解一发也行。你每次插入的时候都是把原来的子树作为新结点的左子树，那样就会产生新的左子树，然后对于新增的那个节点它的原来的根节点跑到左子树上了那不就没有右子树了嘛））

然后你不妨考虑**最后插入的点**。显然如果一个节点没有右子树那么它有可能是最后插入的点。但是满足这样性质的节点不少，所以就这样判断还不行。

看它的左子树，如果它的左子树中还有满足条件（无右子树）的点，则取深度**最浅**的节点更新。

~~为什么不是最深的节点你画个图手玩一下就行了。~~

好吧还是口胡一下。

首先因为我们对于每个节点都搜索它的左子树，所以最终节点肯定在**极左链**上（就是从根节点往下全是左子树的一条链），这非常显然。


不妨令现有两个在极左链上位于同一左子树中的满足条件的节点 $x,y$，然后 $x$ 深度小于 $y$。（即 $x$ 在 $y$ 上面）

那么，如果 $y$ 是最后插入的，又因为 $y$ 比 $x$ 深， $y$ 插入时一定经过了 $x$，则 $x$ 定交换过左右子树。而 $x$ 又满足最终只有右子树的性质，所以在 $y$ 经过前，易知 $x$ 只能有右子树或者没有子树，显然不行。

~~我口胡错了别 d 我。~~

然后字典序排序，如果左子树只有一个节点，那么两个节点都行，按字典序排则权值大的就 dddl 了，扔后面去。

$O(n\log n)$ 的时间复杂度在 $n\le 50$ 的数据上丝毫不带慌的。

话说为什么这题数据这么弱啊暴力应该都能艹过去了（不过会有人用暴力吗）。。

跑一遍 $m \to 1$ ，然后对于每次查询一下最终节点，更新一下，时间复杂度 $O(\log n)$，所以总的时间复杂度 $O(n\log n)$。

$O(n\log n)$ 的时间复杂度还是非常优秀的。

---

## 作者：dami826 (赞：1)

蒟蒻第一篇题解，简陋勿喷，侵权立删。 
  
首先注意到，这题要求求插入序列，而给的是最终状态，很快就可以想到从最后的状态一步步推回去。  
而这样显然就需要找到当前状态下最后插入的节点。  
  
而又因为题目中说，节点插入后是让原本在此位置的节点成为它的左儿子，也就是说它在别的点插进来之前一定没有右儿子。    
  
同时又注意到，最后插入的节点一定是从根节点开始一路向左插，所以它一定在一条由左子树组成的链上。  
  
但在这条链上可能存在多个没有右子树的点，那么考虑深度最小的那个点，我们称作点 $A$：  
  
1. 如果 $A$ 不是最后插入的点：  
那么一定有其他点比它后插入。那么 $A$ 的左右子树应该进行过交换，那它原本的左子树就应该被换到了右子树的位置，可现在右子树为空，所以只有一种可能就是 $A$ **原本没有左子树**。  
既然它原本没有左子树，那么它原本也一定没有右子树，因为右子树一定只能通过左右子树交换形成，而如果进行过这种交换，那么一定会存在一个引发交换的插入点进入它的左子树，此时矛盾，所以**原本 $A$ 是个叶子结点**。  
那么那个比它后插入的点就只能进入它的空左子树，所以那个后插入的点现在**一定是它的左儿子并且是叶子结点**。代码中直接判一下左儿子是不是叶子结点即可。  
  
2. 如果 $A$ 是最后插入的点：  
易得无论如何 $A$ 作为最后插入的点均合法，**包括左儿子是叶子结点的情况**。也就是说，在左儿子是叶子结点的情况下，两者都有可能是最后插入的点，此时按照题目要求字典序最小，将两者中编号较大的那个设为最后一个插入的即可。  
  
做完之后倒推回上一步的状态，然后再重复判断最后插入的即可。（具体见代码）  
  
顺便吐槽一句，这题数据 $n \leq 50$，极水，建议加强数据。  
  
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,lson[51],rson[51],father[51],rt,ans[51];
//lson,rson,father:存储每个节点的左儿子、右儿子和父亲 
//rt:此时的根
//ans:插入序列 
int search(int now){//搜最后插入的点，因为是从上到下，所以最先搜到的一定是深度最小的 
	//如果没有右子树，分两种情况 
	if(rson[now]==-1&&(lson[now]==-1||lson[lson[now]]!=-1)){//如果没有左儿子或左儿子不是叶子节点 
		return now;//就是它 
	}
	if(rson[now]==-1&&lson[now]!=-1&&lson[lson[now]]==-1){//如果左儿子是叶子节点 
		return now>lson[now]?now:lson[now];//返回编号较大的，保证字典序最小 
	}
	//以上是没有右子树的，即递归边界 
	return search(lson[now]);//从上到下递归查找 
}
void change(int now){//回推上一部状态 
	swap(lson[now],rson[now]);//交换 
	if(now==rt){//如果是根 
		return;//返回 
	}
	change(father[now]);//从下到上递归回推 
}
int main(){
	memset(lson,-1,sizeof(lson));
	memset(rson,-1,sizeof(rson));//初始化 
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		int tmp;
		scanf("%d",&tmp);
		if(tmp<100){
			lson[tmp]=i;
			father[i]=tmp;
		}
		else{
			rson[tmp-100]=i;
			father[i]=tmp-100;
		}
	}//读入 
	for(int i=n;i>=0;i--){//倒推 
		ans[i]=search(rt);//找最后插入的点 
		if(ans[i]==rt){//如果是根 
			rt=lson[rt]; //左儿子之前一定是根 
		}
		else{//不是根 
			lson[father[ans[i]]]=lson[ans[i]];//它父亲的左儿子之前一定是它的左儿子 
			if(lson[ans[i]]!=-1){
				father[lson[ans[i]]]=father[ans[i]];
			}
			change(father[ans[i]]);//回推之前的状态 
		}
	}
	for(int i=0;i<=n;i++){
		printf("%d ",ans[i]);
	}//输出 
	return 0;
}
```

---

## 作者：JoaoFelix (赞：1)

稍微参考了一下题解的做法

发现大致是一个分类讨论的过程！

感觉正着模拟做这个过程非常麻烦，我们处理不了

首先我们倒推一下，尝试根据当前树的结构推出当前最后一个节点是那个

我们不妨在草稿纸上画一下

发现大致是这样的：

一个点往下插入是一直走左儿子，直到结束！

并且这个点只有左儿子！因为根据题意可知最后一个点没有右儿子！

一个点满足条件，有两种情况

1 这个点没有左儿子和右儿子，这点是显然的

2 这个点有左儿子，并且它的左儿子还有左儿子！那么也是可以的！

但是考虑有多个点满足条件，根据字典序原因，我们肯定去深度最小的，因为这是一个

小根堆，深度越小字典序自然越小！

然后我们倒推一下，就可以得出答案！

程序最好递归一下，不断往下的过程递归实现可以理解为插入的反操作！

核心代码如下：

```cpp
inline void Get(int x, int now) {
	if ((!ls[x] && !rs[x]) || (!rs[x] && ls[x] && ls[ls[x]])) {
		ls[fa[x]] = ls[x];
		if (ls[x]) fa[ls[x]] = fa[x];
		ans[now] = x;
		if (!fa[x]) root = ls[x];
		return;
	}
	Get(ls[x], now); swap(ls[x], rs[x]);
}
```




---

## 作者：逍遥天堂 (赞：1)


//转自[CSDN博客](https://blog.csdn.net/regina8023/article/details/43956501)      侵权立删   **~~提供一种递归思路~~**

分类讨论后得出结论，最后插入的一定是深度最小的那个满足条件的点。即x的左子树是叶子。

为了满足字典序最小，我们选择叶子作为最后的插入点。

我们由此发现了两个神奇的性质

1.一个结点有右子树则必有左子树（右子树不可能单独存在）

2.最后插入的那个点一定是一直沿着左边往下走，并且没有右子树。



```cpp
#include<bits/stdc++.h>
using namespace std;
int n,root,ans[105];
struct tree
{
	int l,r,fa;
}a[105];
void Get(int x,int now)
{
	if((!a[x].r&&!a[x].l)||(!a[x].r&&a[x].l&&(a[a[x].l].l)))
	{
		a[a[x].fa].l=a[x].l;
		if(a[x].l)
			a[a[x].l].fa=a[x].fa;
		ans[now]=x;
		if(!a[x].fa)
			root=a[x].l;
		return;
	}
	Get(a[x].l,now);
	swap(a[x].l,a[x].r);
}
int main()
{
	root=1;
    scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		int x;
		scanf("%d",&x);
		x++;
		if(x<100)
			a[x].l=i+1,a[i+1].fa=x;
		else
		{
			x-=100;
			a[x].r=i+1,a[i+1].fa=x;
		}
	}
	a[1].fa=0;
	for(int i=n+1;i;i--)
		Get(root,i);
	for(int i=1;i<=n;i++)
		printf("%d ",ans[i]-1);
	cout<<ans[n+1]-1;
	return 0;
}
```


---

## 作者：huhangqi (赞：0)

提供一种在模拟赛上自己观察出来的方法。

由于树是递归定义的，并且每次加入一个值在这个子树中，左右儿子会调换，再将这个点加入左子树。因此我们每次加入一个节点，必须保证这个点未加入的左右子树的节点数量相等或者左子树未加入节点比右子树多一个。

这样的状态我们才可以做到选择完左右的节点。

以下我们称未加入的左右子树的节点数量相等或者左子树未加入节点比右子树多一个的状态称为：**平衡**。

因此最先想到一个思路，递归。我们先将子树平衡，如果平衡了，就选择根节点。

但是这样还是存在问题，即使平衡了，如果前面我为了达到平衡状态，选择的都是右节点，如果直接加上根，此时再先加入左节点再加入右节点，会导致左右位置与预期的相反，产生问题。

那么这种情况怎么解决？我们只需要再选择一个右子树的节点，然后再选择根，先加入左节点，再加入右节点，知道加入完，这样最后一个加入的必定是左节点。

对于为了平衡选择了左节点的情况也是同理，如果先加入根，再加入左节点，会导致左节点没有连接到左子树，因此需要先加入一个左节点，再加入根，最后先右再左加入节点即可。

虽然题目要求字典序最小，但是分析下来这就是唯一解。

最后时间复杂度在树的形态为链时最大，时间复杂度 $O(n^2)$，可以通过此题。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,ls[55],rs[55],siz[55],f[55],st[55],top;
bool vis[55],d[55];
void dfs(int p){
	if(!p)return;
	siz[p]=1;
	dfs(ls[p]),dfs(rs[p]);
	siz[p]+=siz[ls[p]]+siz[rs[p]];
}
void solve(int p){
	if(siz[ls[p]]!=siz[rs[p]]&&siz[ls[p]]!=siz[rs[p]]+1){
		if(siz[ls[p]]>siz[rs[p]])f[p]=1,solve(ls[p]),siz[p]--;
		else f[p]=2,solve(rs[p]),siz[p]--;
	}
	else if(vis[p]){
		if(d[p]==1)solve(rs[p]),siz[p]--,d[p]^=1;
		else solve(ls[p]),siz[p]--,d[p]^=1;
		return;
	}
	else if(f[p]==0){
		vis[p]=1;
		siz[p]--;
		st[++top]=p;
		if(siz[ls[p]]==siz[rs[p]])d[p]=1;
		else d[p]=0;
	}
	else if(f[p]==1){
		solve(ls[p]),siz[p]--;
		d[p]=1;
		f[p]=0;
	}
	else {
		solve(rs[p]),siz[p]--;
		d[p]=0;
		f[p]=0;
	}
}
signed main(){
	cin>>n;
	for(int i=1,x;i<=n;i++){
		cin>>x;
		x++;
		if(x>=100)rs[x-100]=i+1;
		else ls[x]=i+1;
	}
	dfs(1);
	for(int i=1;i<=n+1;i++)solve(1);
	for(int i=1;i<=top;i++)cout<<st[i]-1<<' ';
	return 0;
}
/*
1. 调平左右
让左右相等或者左多一 
2. 开始删除
若左右均未选择，则选根
若左边已经选择，先选左，再根，再右左
若右边已经选择，先选右，再根，再左右 
*/ 
``````

---

## 作者：逆流之时 (赞：0)

看到这题，我首先想到了分治：计算出左右两子树的最小字典序插入顺序后，将两者与根节点合并。

关键在于怎么合并答案。

设左右字数节点总数分别为 $size_l, size_r$，考虑到插入根节点后，每次插入节点左右子树会交换，所以粗略估计插入根节点后左右子树的 $size$ 值之差绝对值不能大于1。

于是按 $size_l$ 与 $size_r$ 的大小关系分类讨论：

情况1：$size_l \ge size_r$ 时，把左子树插入顺序中前$size_l-size_r$个节点先插入，然后插入根节点，再连续依次插入右子树的下一个节点，左子树的下一个节点，直到全部插入。这样，插入根节点后的插入次数为偶数次，先插入的左子树节点最后仍在左子树。

情况2：$size_r > size_l$ 时，不断按右子树插入顺序插入节点，直到 $size_l - size_r = 1$，然后插入根节点，再连续依次插入左子树的下一个节点，右子树的下一个节点，直到全部插入。这样，由于插入根节点时剩余未插入的节点为奇数个，插入根节点后的插入次数为奇数次，先插入的右子树节点最后仍在右子树。

由于本题根本不卡常数，所以直接上vector。

然后发现样例3根本过不去。

按照样例画图，发现对于节点5，它只有左子树，且左子树只有节点7。上面的程序应该算出`7 5`的顺序，但正确答案明显是`5 7`。

于是发现了一种特殊情况：只有一个根节点的情况下，左右子树的交换不需要考虑。

然后按照类似上面的方法继续讨论，发现第3种情况：$root < l.front()$ 且 $size_l =size_r + 1$ 时我们可以先插入 $root$，再插入 $l.front()$，再连续依次插入右子树的下一个节点，左子树的下一个节点，直到全部插入。

发现如果插入 $root$ 后马上插入 $r.front()$ ，最终情况与情况1相同（即 $size_l \ge size_r$ 那种情况），所以不用考虑。加上情况3就可以一发AC了。

```cpp
#include<cstdio>
#include<cstring>
#include<vector>
using namespace std;
const int N = 100;
int n, ch[N][2];
vector<int> dfs(int x) {
	if (x == -1) return vector<int>();
	vector<int> l = dfs(ch[x][0]);
	vector<int> r = dfs(ch[x][1]);
	vector<int> ret;
	if(l.size() == r.size() + 1 && x < l.front()) {
		ret.push_back(x);
		ret.push_back(l.front());
		for (int i = 0; i < r.size(); i++) ret.push_back(r[i]), ret.push_back(l[i + 1]);
	}
	else if (l.size() >= r.size()) {
		for (int i = 0; i < l.size() - r.size(); i++) ret.push_back(l[i]);
		l.erase(l.begin(), l.begin() + l.size() - r.size());
		ret.push_back(x);
		for (int i = 0; i < l.size(); i++) ret.push_back(r[i]), ret.push_back(l[i]);
	} else {
		for (int i = 0; i < r.size() - l.size(); i++) ret.push_back(r[i]);
		r.erase(r.begin(), r.begin() + r.size() - l.size());
		ret.push_back(r.front());
		ret.push_back(x);
		ret.push_back(l.front());
		for (int i = 1; i < r.size(); i++) ret.push_back(r[i]), ret.push_back(l[i]);
	}
	return ret;
}
int main() {
	memset(ch, -1, sizeof(ch));
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		int x;
		scanf("%d", &x);
		if (x < 100) ch[x][0] = i;
		else ch[x - 100][1] = i;
	}
	vector<int> v = dfs(0);
	for (int i : v) printf("%d ", i);
	return 0;
}

```

---


# [SDOI2010] 城市规划

## 题目描述

小猪iPig来到了一个叫做pigsty的城市里，pigsty是一座专门为小猪所准备的城市，城市里面一共有n个小区给小猪们居住，并且存在许多条无向边连接着许多小区。因为这里是一个和谐的城市，所以小猪iPig准备在这个城市里面度过他的余生。

若干年之后小猪iPig当上了规划局长，这件事令他非常开心。不过与此同时pigsty城市里面出现了许多反和谐主义者，他们已经厌烦了这样和谐的生活，在城市里到处闹事。小猪iPig为了更好地控制局面，他把城市改造成了另外一个样子：iPig把道路全部摧毁之后重新修建了m条无向边，并且保证每一个小区最多存在于一个由无向边组成的环中。

iPig以为这样做就让那些反和谐主义者不敢继续猖狂下去了，谁知到在新的城市道路修建好以后反和谐主义者宣言要对城市的小区进行一次洗脑！

这下可麻烦了，iPig赶紧收集了许多的情报。iPig给每个小区标记了一个和谐值HX\_i，用它来表示第i个小区的和谐程度。

通过地下消息iPig又得知那些反和谐主义者进攻时有个规律：他们会选择若干个小区下手，这些小区都派一只猪过去，把这些小区的和谐值归零。在这个过程中，每个选择的小区所直接连接着的几个小区都派了一只猪去看守——以防被警猪给干扰。这个计划看似完美但是还是存在一个漏洞：因为人员之间都是在网络上认识的，互相没有见过面，为了防止不必要的麻烦（认错猪之类），每个小区最多只会有一头猪存在。

iPig突然感到了莫大的压力，他想知道在最坏情况下会丢失多少和谐值。但是不懂计算机的他不知道应该怎样计算。你能帮帮他吗？


## 说明/提示

【样例解释】

反和谐主义者选择的小区分别是小区3（看守的小区是小区1、小区2和小区5）、小区7（看守的小区是小区4和小区6）和小区9（看守的小区是小区8），这样会损失的总和谐值为3+3+11=17。

或者选择的小区分别是小区1（看守的小区是小区2和小区3）、小区4（看守的小区是小区5和小区7）和小区9（看守的小区是小区8），这样会损失的总和谐值为2+4+11=17。

如果同时选择小区3、小区4和小区9，虽然损失的总和谐值为18，但是小区3和小区4都要派猪来看守小区5，这不符合条件，故此方案不可行。


【数据约定】

对于20%的数据，保证每个点不存在于任何一个环中；

对于另外30%的数据，保证图中只存在一个环；

对于100%的数据，有N<=1000000，M<=2000000，所有的权值不超过1000。


## 样例 #1

### 输入

```
9 9
2 2 3 4 1 2 3 10 11
1 2
2 3
1 3
3 5
5 4
5 6
4 7
6 7
8 9
```

### 输出

```
17```

## 样例 #2

### 输入

```
5 5
4 4 9 7 7
1 2
2 3
1 4
3 5
5 4
```

### 输出

```
9```

# 题解

## 作者：ix35 (赞：6)

一道仙人掌上 DP 的题。

首先是 Tarjan 找环，然后对环上 DP 和树上 DP 分别讨论：

设 $dp(i,0)$ 表示选了 $i$ 时 $i$ 的子树最大贡献，$dp(i,1)$ 表示选了 $i$ 的某个儿子时 $i$ 的子树的最大贡献，$dp(i,2)$ 表示 $i$ 和儿子都没选时子树的最大贡献。

### 树上 DP 部分：

设 $v$ 为 $u$ 的子结点，则先令 $dp(u,0)=HX_u$，然后转移：

$dp(v,2)\to dp(u,0)$

$\max(dp(v,1),dp(v,2))\to dp(u,2)$

而 $dp(u,1)$ 略微麻烦。因为只能选恰好一个儿子，别的儿子都按照 $dp(u,2)$ 的方式转移，只有一个儿子是通过 $dp(v,0)$ 的形式转移的，所以只需要统计相对于 $dp(u,2)$ 的增量即可，即：

$dp(u,1)=dp(u,2)+\max(dp(v,0)-\max(dp(v,1),dp(v,2))$

---

### 环上 DP 部分：

计算环顶 DP 的值，设环顶为 $u$，环上的点按深度从大到小依次为 $v_1,\ldots,v_k$，那么 $u=v_k$，考虑转移：

先定义一个 $Calc(l,r)$， 表示如果规定了 $v_l$ 和 $v_r$ 不能选，中间的点只要按照规则可以随便选，那么最大的总 DP 值为多少，这就是个链上的 DP，和树上 DP 转移相似。

对于 $dp(u,0)$，增量为 $dp(v_{k-1},2)+dp(v_1,2)+Calc(3,k-3)$。

对于 $dp(u,2)$，增量为 $Calc(2,k-2)$。

对于 $dp(u,1)$，要分类讨论：

1. 选择了环外子结点，那么 $dp(u,1)+Calc(2,k-2)\to dp(u,1)$；

2. 选择了 $v_1$，那么 $dp(u,2)+dp(v_2,2)+dp(v_1,0)+Calc(4,k-2)$；

3. 选择了 $v_{k-1}$，那么 $dp(u,2)+dp(v_{k-2},2)+dp(v_{k-1},0)+Calc(2,k-4)$。

---

代码，请勿直接抄袭：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=2000010;
int n,m,x,y,eg,ans,tot,h[MAXN],hd[MAXN],ver[2*MAXN],nx[2*MAXN],dfn[MAXN],low[MAXN],f[MAXN],dp[MAXN][3];
int rg[MAXN],tmp[MAXN][3];
void add_edge (int x,int y) {
	ver[++eg]=y;
	nx[eg]=hd[x];
	hd[x]=eg;
	return;
}
int get_dp (int l,int r) {
	tmp[l-1][0]=0,tmp[l-1][1]=dp[rg[l-1]][1],tmp[l-1][2]=dp[rg[l-1]][2];
	for (int i=l;i<=r+1;i++) {
		tmp[i][0]=tmp[i-1][2]+dp[rg[i]][0];
		tmp[i][2]=max(tmp[i-1][1],tmp[i-1][2])+dp[rg[i]][2];
		tmp[i][1]=max(tmp[i-1][0]+dp[rg[i]][2],max(tmp[i-1][1],tmp[i-1][2])+dp[rg[i]][1]);
	}
	//cout << l << "  " << r << "  " << max(tmp[r+1][1],tmp[r+1][2]) << endl;
	return max(tmp[r+1][1],tmp[r+1][2]);
}
void solve (int s,int t) {
	int cnt=0;
	rg[++cnt]=s;
	while (rg[cnt]!=t) {
		rg[cnt+1]=f[rg[cnt]];
		cnt++;
	}
	dp[t][1]=max(dp[t][1]+get_dp(2,cnt-2),dp[t][2]+max(dp[rg[1]][0]+dp[rg[2]][2]+get_dp(4,cnt-2),dp[rg[cnt-1]][0]+dp[rg[cnt-2]][2]+get_dp(2,cnt-4)));
	dp[t][0]+=get_dp(3,cnt-3)+dp[rg[1]][2]+dp[rg[cnt-1]][2];
	dp[t][2]+=get_dp(2,cnt-2);
	return;
}
void dfs (int x,int fa) {
	f[x]=fa,dfn[x]=low[x]=++tot,dp[x][0]=h[x],dp[x][2]=0;
	int tmp=0;
	for (int i=hd[x];i;i=nx[i]) {
		if (!dfn[ver[i]]) {
			dfs(ver[i],x);
			low[x]=min(low[x],low[ver[i]]);
		} else if (ver[i]!=fa) {
			low[x]=min(low[x],dfn[ver[i]]);
		}
		if (low[ver[i]]>dfn[x]) {
			dp[x][0]+=dp[ver[i]][2];
			dp[x][2]+=max(dp[ver[i]][2],dp[ver[i]][1]);
			tmp=max(tmp,dp[ver[i]][0]-max(dp[ver[i]][2],dp[ver[i]][1]));
		}
	}
	dp[x][1]=dp[x][2]+tmp;
	//cout << x << "  " << dp[x][0] << "  " << dp[x][1] << "  " << dp[x][2] << endl;
	for (int i=hd[x];i;i=nx[i]) {
		if (low[ver[i]]==dfn[x]&&f[ver[i]]!=x) {solve(ver[i],x);}
	}
	//cout << x << "  " << dp[x][0] << "  " << dp[x][1] << "  " << dp[x][2] << endl;
	return;
}
int main () {
	freopen("city.in","r",stdin);
	freopen("city.out","w",stdout);
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++) {
		if (!dfn[i]) {
			dfs(i,0);
			ans+=max(dp[i][0],max(dp[i][1],dp[i][2]));
		}
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：FlashHu (赞：5)

大致题意：在这样的图上选若干个点满足两两之间最短路$>=3$，最大化点权和。和仙人掌带权最大独立集很像的。

每个点的状态有三个：自己选，儿子选，自己和儿子都不选。转移随便yy就好了，细节有一些，但应该还是不难。

环上DP应该要考虑最下面两个点，依据环底部点对环顶部点的影响（也就是环底部点离最近已选点的距离）分成三类。

然而这个题是个假题。。。

https://www.luogu.org/discuss/lists?forumname=P2478

https://www.lydsy.com/JudgeOnline/wttl/wttl.php?pid=1952

所以下面的代码蒟蒻也不能保证正确性
（蒟蒻的写法应该是可以适用于仙人掌而不局限于题面说的 `点至多在一个环上` ）

下面的代码有蒟蒻犯过的ZZ错误，想对拍的请不要直接Copy-Paste（纯属娱乐233）
```cpp
#include<bits/stdc++.h>
#define R register int
#define G if(++ip==ie)if(fread(ip=buf,1,SZ,stdin))
using namespace std;
const int SZ=1<<19,N=1e6+9,M=2*N,INF=-2e9;
char buf[SZ],*ie=buf+SZ,*ip=ie-1;
inline int in(){
	G;while(*ip<'-')G;
	R x=*ip&15;G;
	while(*ip>'-'){x*=10;x+=*ip&15;G;}
	return x;
}
int he[N],ne[M],to[M],fa[N],d[N];
struct Dat{
	int f0,f1,f2;
	inline void operator+=(const Dat&a){
		f0=max(f0+max(a.f0,a.f1),f1+a.f2);
		f1+=max(a.f0,a.f1);
		f2+=a.f1;
	}
}g[N];
void dp(R x,R f){
	Dat now,lst,res=(Dat){0,0,0};R y=fa[x];
	for(R op=0;op<3;++op){//x到已选点的最短路是op
		switch(op){
		case 0:now=(Dat){g[y].f1+g[x].f2,INF,INF};break;
		case 1:now=(Dat){g[y].f0+g[x].f0,g[y].f1+g[x].f0,g[y].f2+g[x].f1};break;
		case 2:now=(Dat){g[y].f0+g[x].f1,g[y].f1+g[x].f1,INF};
		}
		for(R y=fa[x];y!=f;y=fa[y])
			lst=now,(now=g[fa[y]])+=lst;
		switch(op){
		case 2:res.f2=max(res.f2,now.f2);
		case 1:res.f0=max(res.f0,now.f0);res.f1=max(res.f1,now.f1);break;
		case 0:res.f0=max(res.f0,now.f1);
		}
	}
	g[f]=res;
}
int dfs(R x,R f){
	fa[x]=f;d[x]=d[f]+1;
	R top=0;//环顶端
	for(R i=he[x];i;i=ne[i]){
		if(to[i]==f)continue;
		if(d[to[i]]){
			if(d[to[i]]>d[x])dp(to[i],x),top^=x;
			else top^=to[i];
		}
		else top^=dfs(to[i],x);
	}
	if(!top)g[f]+=g[x];
	return top;
}
int main(){
	R n=in(),m=in(),ans=0;
	for(R i=1;i<=n;++i)g[i].f2=in();
	for(R i=1,p=0;i<=m;++i){
		R x=in(),y=in();
		ne[++p]=he[x];to[he[x]=p]=y;
		ne[++p]=he[y];to[he[y]=p]=x;
	}
	for(R i=1;i<=n;++i)
		if(!d[i])dfs(i,0),ans+=max(g[i].f0,g[i].f1,g[i].f2);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：XuYueming (赞：1)

## 前言

[更好的体验](https://www.cnblogs.com/XuYueming/p/18300089)。

## 题意简述

树套环上求至少间隔两个位置的最大独立集。

（树套环，即树上每个结点都是一个结点或环）

## 题目分析

将题目拆解成树上 DP 和环上 DP 即可。用 tarjan 缩点就行。

### 树上 DP

先来看看树上 DP。

显然每个点有三个状态：不选中且周围没选中、选中、不选中但在选中的点的旁边。记成 $f[yzh][0/1/2]$。设 $xym$ 是 $yzh$ 的一个孩子。

先来看看 $f[yzh][0]$。由于她不选中，且不在一个选中的旁边，可以从孩子的 $0$、$2$ 状态转移而来。

$$
f[yzh][0] = \sum \max \Big \lbrace f[xym][0], f[xym][2] \Big \rbrace
$$

$f[yzh][1]$。由于她选中，那么孩子在之前必须没被选中，且不在选中的点的旁边，即只能从孩子的 $0$ 状态转移而来。注意加上她的价值。

$$
f[yzh][1] = \operatorname{val}(yzh) + \sum f[xym][0]
$$

$f[yzh][2]$。她能且只能从一个孩子的 $1$ 状态转移而来，其他儿子要么是 $0$ 状态，要么是 $2$ 状态。取最大值。

$$
f[yzh][2] = f[xym'][1] + \sum _ {xym \neq xym'} \max \Big \lbrace f[xym][0], f[xym][2] \Big \rbrace
$$

这样，得到 $20 \%$ 树的部分分。

### 环上 DP

先把环“拉下来”，即把环按照一定顺序存下来。类似于树，记 $g[i][0/1/2]$ 表示考虑到了环上前 $i$ 个点，第 $i$ 个点状态下最大价值，再记 $f[i][0/1/2]$ 表示从第 $i$ 个点，走到子树里，树形 DP 的结果。先不考虑其他的，来看看转移方程。

$g[yzh][0]$。在树里，她不能被选中，即 $f[yzh][0]$；在环里，前一个位置不能是 $1$ 状态。

$$
g[yzh][0] = f[yzh][0] + \max \lbrace g[yzh - 1][0], g[yzh - 1][2] \rbrace
$$

$g[yzh][1]$。不妨把 $yzh$ 的价值计算到树里。环里前一个位置之前不能选。那么就是 $f[yzh][1]$ 和 $g[yzh - 1][0]$ 的和。

$$
g[yzh][1] = f[yzh][1] + g[yzh - 1][0]
$$

$g[yzh][2]$。这里需要分类讨论，这个 $2$ 状态可能是应为环里前一个位置是 $1$ 状态，或者树里达到了 $2$ 状态。取最大值即可。

$$
g[yzh][2] = \max \Big \lbrace g[yzh - 1][1] + f[yzh][0], \max \lbrace g[yzh - 1][0], g[yzh - 1][2] \rbrace + f[yzh][2] \Big \rbrace

$$

以上就是转移方程。重点在环的特殊性。所以套路化地想到，把左侧强制设为某一个状态，那么右侧只有部分状态是有效的。为了之后树形 DP，我们不妨把这个环的“上顶点”移到我们“拉下来”的数组的右侧。

1. 若左侧是 $0$ 状态。
    那么右侧三个状态都合法。
1. 若左侧是 $1$ 状态。
    那么右侧只能是环上 DP 出来的 $0$ 状态，并且在反映到树形 DP 上时是 $2$ 状态。
1. 若左侧是 $2$ 状态。
    那么右侧 $0$ 状态或 $2$ 状态都是合法的。

这样看起来没有问题了。但是，还是会错，给出我对拍出来的一组数据：

```plaintext
10 11
5 1 1 1 3 5 7 2 8 9
1 2
2 3
3 4
4 5
5 1
6 7
7 8
8 9
9 10
10 6
1 6
```

答案显然是 $13$，可是我们输出了 $14$。~~（好吧，可能有那么一点不显然）~~

为什么呢？问题就出在了我们对左侧 $0$ 状态的考虑。这个位置的右边可能后来被选中了，而在树形 DP 上传答案的时候，右侧也是选中的，这样两者中间只间隔了 $1$ 个，冲突了。

如何解决呢？再强制以下就好了：一遍强制左侧右边那个位置不能选中，就可以放心转移了。

## 代码

代码实现很清晰。略去了快读。注意用 `vector` 可能会含泪 MLE $90$ 分，用链式前向星即可。~~可能有之前卡空间的遗物？~~

```cpp
#include <vector>
#include <array>
#include <cstdio>
#include <stack>
using namespace std;

using node = array<int, 3>;

inline int max(int a, int b, int c) {
	return max(max(a, b), c);
}

struct Graph{
	struct node{
		int to, nxt;
	} edge[2000010 << 1];
	int eid, head[1000010];
	inline void add(int u, int v){
		edge[++eid] = {v, head[u]};
		head[u] = eid;
	}
	inline node & operator [] (const int x){
		return edge[x];
	}
} xym;

int n, m, val[1000010], ans;
vector<int> yzh[1000010];

int dfn[1000010], low[1000010], timer;
stack<int> st;
int sccno[1000010], scc_cnt;
void tarjan(int now, int fr){
	dfn[now] = low[now] = ++timer, st.push(now);
	for (int i = xym.head[now], to; to = xym[i].to, i; i = xym[i].nxt) {
		if (!dfn[to]) tarjan(to, now), low[now] = min(low[now], low[to]);
		else if (to != fr) low[now] = min(low[now], dfn[to]);
	}
	if (low[now] >= dfn[now]){
		++scc_cnt;
		while (true) {
			int tp = st.top(); st.pop();
			yzh[scc_cnt].push_back(tp), sccno[tp] = scc_cnt;
			if (tp == now) break;
		}
	}
}

void move_to_end(vector<int> &vec, int x) {
	vector<int> res;
	int len = vec.size(), pos = 0;
	for (int i = 0; i < len; ++i) {
		if (vec[i] == x) {
			pos = i;
			break;
		}
	}
	for (int i = pos + 1; i < len; ++i)
		res.push_back(vec[i]);
	for (int i = 0; i < pos; ++i)
		res.push_back(vec[i]);
	res.push_back(x);
	vec = move(res);
}

bool vis[1000010];
node dfs(int now, int top, int fa) {
	vis[now] = true;
	move_to_end(yzh[now], top);  // 把 top 放在最后
	int tot = yzh[now].size();
	vector<node> f(tot, {0, 0, 0}), dp(tot, {0, 0, 0});
	for (int i = 0; i < tot; ++i) {
		int son = yzh[now][i];
		f[i][0] = 0, f[i][1] = val[son], f[i][2] = 0;
		int mx = -0x3f3f3f3f;
		for (int j = xym.head[son], to; to = xym[j].to, j; j = xym[j].nxt) {
			int bl = sccno[to];
			if (bl == fa || bl == now) continue;
			node yzh = dfs(bl, to, now);
			f[i][0] += max(yzh[0], yzh[2]);
			f[i][1] += yzh[0];
			f[i][2] += max(yzh[0], yzh[2]);
			mx = max(mx, yzh[1] - max(yzh[0], yzh[2]));
		}
		f[i][2] += mx;
	}
	node res = {-0x3f3f3f3f, -0x3f3f3f3f, -0x3f3f3f3f};
	
	yzh[now].clear();
	yzh[now].shrink_to_fit();
	
	if (tot == 1) {
		res[0] = f[0][0];
		res[1] = f[0][1];
		res[2] = f[0][2];
		return res;
	}
	
	// 左边是空的 并且可能被 1 占用
	dp[0][0] = f[0][0], dp[0][1] = -0x3f3f3f3f, dp[0][2] = -0x3f3f3f3f;
	for (int i = 1; i < tot; ++i) {
		dp[i][0] = f[i][0] + max(dp[i - 1][0], dp[i - 1][2]);
		dp[i][1] = f[i][1] + dp[i - 1][0];
		dp[i][2] = max(dp[i - 1][1] + f[i][0], max(dp[i - 1][0], dp[i - 1][2]) + f[i][2]);
	}
	res[0] = max(res[0], dp[tot - 1][0]);
	res[2] = max(res[2], dp[tot - 1][2]);
	
	// 左边是空的 并且不能被 1 占用
	dp[0][0] = f[0][0], dp[0][1] = -0x3f3f3f3f, dp[0][2] = -0x3f3f3f3f;
	for (int i = 1; i < tot; ++i) {
		dp[i][0] = f[i][0] + max(dp[i - 1][0], dp[i - 1][2]);
		if (i != 1) dp[i][1] = f[i][1] + dp[i - 1][0];
		else dp[i][1] = -0x3f3f3f3f;
		dp[i][2] = max(dp[i - 1][1] + f[i][0], max(dp[i - 1][0], dp[i - 1][2]) + f[i][2]);
	}
	res[0] = max(res[0], dp[tot - 1][0]);
	res[1] = max(res[0], dp[tot - 1][1]);
	res[2] = max(res[2], dp[tot - 1][2]);
	
	// 左边在真的旁边
	dp[0][0] = -0x3f3f3f3f, dp[0][1] = -0x3f3f3f3f, dp[0][2] = f[0][2];
	for (int i = 1; i < tot; ++i) {
		dp[i][0] = f[i][0] + max(dp[i - 1][0], dp[i - 1][2]);
		dp[i][1] = f[i][1] + dp[i - 1][0];
		dp[i][2] = max(dp[i - 1][1] + f[i][0], max(dp[i - 1][0], dp[i - 1][2]) + f[i][2]);
	}
	res[0] = max(res[0], dp[tot - 1][0]);
	res[2] = max(res[2], dp[tot - 1][2]);
	
	// 左边是真的
	dp[0][0] = -0x3f3f3f3f, dp[0][1] = f[0][1], dp[0][2] = -0x3f3f3f3f;
	for (int i = 1; i < tot; ++i) {
		dp[i][0] = f[i][0] + max(dp[i - 1][0], dp[i - 1][2]);
		dp[i][1] = f[i][1] + dp[i - 1][0];
		dp[i][2] = max(dp[i - 1][1] + f[i][0], max(dp[i - 1][0], dp[i - 1][2]) + f[i][2]);
	}
	res[2] = max(res[2], dp[tot - 1][0]);
	
	f.clear(), f.shrink_to_fit();
	dp.clear(), dp.shrink_to_fit();
	
	return res;
}

signed main() {
	read(n), read(m);
	for (int i = 1; i <= n; ++i) read(val[i]);
	for (int i = 1, u, v; i <= m; ++i) {
		read(u), read(v);
		xym.add(u, v), xym.add(v, u);
	}
	for (int i = 1; i <= n; ++i) if (!dfn[i]) tarjan(i, 0);
	for (int i = 1; i <= n; ++i)
		if (!vis[sccno[i]]) {
			node res = dfs(sccno[i], i, 0);
			ans += max(res[0], res[1], res[2]);
		}
	printf("%d", ans);
	return 0;
}
```

## 后记 & 反思

没有什么是分类讨论解决不了的。如果有，那是你没有讨论细致。

---


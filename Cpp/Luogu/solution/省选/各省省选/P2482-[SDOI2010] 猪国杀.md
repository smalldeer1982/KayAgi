# [SDOI2010] 猪国杀

## 题目描述

### 游戏背景

《猪国杀》是一种多猪牌类回合制游戏，一共有 $3$ 种角色：主猪，忠猪，反猪。每局游戏主猪有且只有 $1$ 只，忠猪和反猪可以有多只，每只猪扮演 $1 $ 种角色。

### 游戏目的

主猪 / $\texttt{MP}$：自己存活的情况下消灭所有的反猪。  
忠猪 / $\texttt{ZP}$：不惜一切保护主猪，胜利条件与主猪相同。  
反猪 / $\texttt{FP}$：杀死主猪。

### 游戏过程

游戏开始时，每个玩家手里都会有 $4$ 张牌，且体力上限和初始体力都是 $4$ 。

开始游戏时，从主猪开始，按照逆时针方向（数据中就是按照编号从 $ 1 , 2, 3 \ldots n , 1 \ldots $ 的顺序）依次行动。

每个玩家自己的回合可以分为 2 个阶段：

* **摸牌阶段**：从牌堆顶部摸 $2$ 张牌，依次放到手牌的最右边；  
* **出牌阶段**：你可以使用任意张牌，每次使用牌的时候都使用最靠左的能够使用的牌。当然，要满足如下规则：
  1. 如果没有猪哥连弩，每个出牌阶段只能使用 $1$ 次「杀」来攻击；
  2. 任何牌被使用后被弃置（武器是装备上）；被弃置的牌以后都不能再用，即与游戏无关。

### 各种牌介绍

每张手牌用 $1$ 个字母表示，字母代表牌的种类。

#### 基本牌

- 『桃 / $\texttt{P}$』在自己的回合内，如果自己的体力值不等于体力上限，那么使用 $1$ 个桃可以为自己补充 $1$ 点体力，否则不能使用桃；桃只能对自己使用；在自己的回合外，如果自己的血变为 $0$ 或者更低，那么也可以使用。

- 『杀 / $\texttt{K}$』在自己的回合内，对攻击范围内除自己以外的 $1$ 名角色使用。如果没有被『闪』抵消，则造成 $1$ 点伤害。无论有无武器，杀的攻击范围都是 $1$。

- 『闪 / $\texttt{D}$』当你受到杀的攻击时，可以弃置 $1$ 张闪来抵消杀的效果。

#### 锦囊牌

- 『决斗 / $\texttt{F}$』出牌阶段，对除自己以外任意 $1$ 名角色使用，由目标角色先开始，自己和目标角色轮流弃置 $1$ 张杀，首先没有杀可弃的一方受到 $1$ 点伤害，另一方视为此伤害的来源。

- 『南猪入侵 / $\texttt{N}$』出牌阶段，对除你以外所有角色使用，按逆时针顺序从使用者下家开始依次结算，除非弃置 $1$ 张杀，否则受到 $1$ 点伤害。

- 『万箭齐发 / $\texttt{W}$』和南猪入侵类似，不过要弃置的不是杀而是闪。

- 『无懈可击 / $\texttt{J}$』在目标锦囊生效前抵消其效果。每次有 $1$ 张锦囊即将生效时，从使用这张锦囊的猪开始，按照逆时针顺序，依次得到使用无懈可击的机会；效果：用于决斗时，决斗无效并弃置；用于南猪入侵或万箭齐发时，当结算到某个角色时才能使用，当前角色不需弃置牌并且不会受到伤害（仅对 $1$ 个角色产生效果）；用于无懈可击时，成为目标的无懈可击被无效。

#### 装备牌

- 『猪哥连弩 / $\texttt{Z}$』武器，攻击范围 $1$ ，出牌阶段你可以使用任意张杀; 同一时刻最多只能装 $1$ 把武器；如果先前已经有了 $1$ 把武器，那么之后再装武器的话，会弃置以前的武器来装现在的武器。

### 特殊事件及概念解释

* **伤害来源**：杀、南猪入侵、万箭齐发的伤害来源均是使用该牌的猪，决斗的伤害来源如上；

* **距离**：两只猪的距离定义为沿着逆时针方向间隔的猪数 $+1$ 。即初始时 $1$ 和 $2$ 的距离为 $1$ ，但是 $2$ 和 $1$ 的距离就是 $n-1$ 。注意一个角色的死亡会导致一些猪距离的改变；

* **玩家死亡**：如果该玩家的体力降到 $0$ 或者更低，并且自己手中没有足够的桃使得自己的体力值回到 $1$ ，那么就死亡了，死亡后所有的牌（装备区，手牌区）被弃置；

* **奖励与惩罚**：反猪死亡时，最后一个伤害来源处（即使是反猪）立即摸 $3$ 张牌。忠猪死亡时，如果最后一个伤害来源是主猪，那么主猪所有装备牌、手牌被弃置。

注意：一旦达成胜利条件，游戏立刻结束，因此即使会摸 $3$ 张牌或者还有牌可以用也不用执行了。

现在，我们已经知道每只猪的角色、手牌，还有牌堆初始情况，并且假设每个角色会按照如下的行为准则进行游戏，你需要做的就是告诉小猪 iPig 最后的结果。

### 几种行为

* **献殷勤**：使用无懈可击挡下南猪入侵、万箭齐发、决斗；使用无懈可击抵消表敌意；  
* **表敌意**：对某个角色使用杀、决斗；使用无懈可击抵消献殷勤；  
* **跳忠**：即通过行动表示自己是忠猪。跳忠行动就是对主猪或对某只已经跳忠的猪献殷勤，或者对某只已经跳反的猪表敌意；  
* **跳反**：即通过行动表示自己是反猪。跳反行动就是对主猪或对某只已经跳忠的猪表敌意，或者对某只已经跳反的猪献殷勤。

**注意：忠猪不会跳反，反猪也不会跳忠；不管是忠猪还是反猪，能够跳必然跳**。

### 行动准则

#### 共性

* 每个角色如果手里有桃且生命值未满，那么必然吃掉；
* 有南猪入侵、万箭齐发、必然使用；有装备必然装上；
* 受到杀时，有闪必然弃置；
* 响应南猪入侵或者万箭齐发时候，有杀 / 闪必然弃置；
* 不会对未表明身份的猪献殷勤（**包括自己**）。

#### 特性

 - 主猪：
   + 主猪会认为「没有跳身份，且用南猪入侵 / 万箭齐发对自己造成伤害的猪」是**类**反猪（没伤害到不算，注意类反猪并没有表明身份），如果之后跳了，那么主猪会重新认识这只猪；  
   + 对于每种表敌意的方式，对逆时针方向能够执行到的第一只类反猪或者已跳反猪表；如果没有，那么就不表敌意；
   + 决斗时会不遗余力弃置杀；
   + 如果能对已经跳忠的猪或自己献殷勤，那么一定献；如果能够对已经跳反的猪表敌意，那么一定表。
 - 忠猪：
   + 对于每种表敌意的方式，对「逆时针方向能够执行到的第一只已经跳反的猪」表，如果没有，那么就不表敌意；
   + 决斗时，如果对方是主猪，那么不会弃置杀，否则，会不遗余力弃置杀；
   + 如果有机会对主猪或者已经跳忠的猪献殷勤，那么一定献。
 - 反猪：
   + 对于每种表敌意的方式，如果有机会则对主猪表，否则，对「逆时针方向能够执行到的第一只已经跳忠的猪」表，如果没有，那么就不表敌意；
   + 决斗时会不遗余力弃置杀；
   + 如果有机会对已经跳反的猪献殷勤，那么一定献。

限于 iPig 只会用 P++ 语言写 A + B，他请你用 Pigcal (Pascal)、P (C) 或 P++ (C++) 语言来帮他预测最后的结果。

## 说明/提示

### 样例解释

第一回合：
* 主猪没有目标可以表敌意；
* 接下来忠猪使用了 $3$ 张南猪入侵，主猪掉了 $3$ 点体力，并认为该角色为类反猪，$3$ 号角色尽管手里有无懈可击，但是因为自己未表明身份，所以同样不能对自己用，乖乖掉 $3$ 点体力；  

下一回合：
* 反猪无牌可出；
* 接下来主猪对着类反猪爆发，使用 $4$ 张决斗，忠猪死亡，结果主猪弃掉所有牌；
* 下来反猪摸到 $1$ 张杀直接杀死主猪获胜。

### 子任务

一共 $20$ 组测试数据，每个点 $5$ 分。

$10\%$ 的数据没有锦囊牌，另外 $20\%$ 的数据没有无懈可击。

## 样例 #1

### 输入

```
3 10
MP D D F F
ZP N N N D
FP J J J J
F F D D J J F F K D
```

### 输出

```
FP
DEAD
DEAD
J J J J J J D
```

# 题解

## 作者：pinkex (赞：939)

由于最近比较颓，逼自己刷一道大模拟。（其实个人认为这个方法海上挺有用的）


看了这道大模拟后，脑子比较混乱。


先列了一下有用信息（建议认真读，至少读个5遍）：

----------------------------------------------------------------------------------------------------------------------------------------------------------------------


section 1:

主猪（MP）：自己存活的情况下消灭所有的反猪。

忠猪（ZP）：不惜一切保护主猪，胜利条件与主猪相同。

反猪（AP）：杀死主猪。

section 2:

游戏开始时候，每个玩家手里都会有4张牌，且体力上限和初始体力都是4。

开始游戏时，从主猪开始，按照逆时针方向（数据中就是按照编号从1,2,3..n,1..的顺序）依次行动。

摸牌阶段：从牌堆顶部摸两张牌，依次放到手牌的最右边；

出牌阶段：你可以使用0张到任意张牌，每次使用牌的时候都使用最靠左的能够使用的牌。

当然，要满足如下规则：

1.如果没有猪哥连弩，每个出牌阶段只能使用一次“杀”来攻击；

2.任何牌被使用后被弃置（武器是装备上）；

被弃置的牌以后都不能再用，即与游戏无关；

section 3:

『桃(P)』：在自己的回合内，如果自己的体力值不等于体力上限，那么使用一个桃可以为自己补充一点体力，否则不能使用桃；桃只能对自己使用；在自己的回合外，如果自己的血变为0或者更低，那么也可以使用；

『杀(K)』：在自己的回合内，对攻击范围内除自己以外的一名角色使用。如果没有被『闪』抵消，则造成1点伤害。无论有无武器，杀的攻击范围都是1；

『闪(D)』：当你受到杀的攻击时，可以弃置一张闪来抵消杀的效果；

『决斗(F)』：出牌阶段，对除自己以外任意一名角色使用，由目标角色先开始，自己和目标角色轮流弃置一张杀，首先没有杀可弃的一方受到1点伤害，另一方视为此伤害的来源；

『南猪入侵(N)』：出牌阶段，对除你以外所有角色使用，按逆时针顺序从使用者下家开始依次结算，除非弃置一张杀，否则受到1点伤害；

『万箭齐发(W)』：和南猪入侵类似，不过要弃置的不是杀而是闪；

『无懈可击(J)』：在目标锦囊生效前抵消其效果。每次有一张锦囊即将生效时，从使用这张锦囊的猪开始，按照逆时针顺序，依次得到使用无懈可击的机会；

效果：用于决斗时，决斗无效并弃置；用于南猪入侵或万箭齐发时，当结算到某个角色时才能使用，当前角色不需弃置牌并且不会受到伤害（仅对一个角色产生效果）；用于无懈可击时，成为目标的无懈可击被无效。

『猪哥连弩(Z)』：武器，攻击范围1，出牌阶段你可以使用任意张杀；

同一时刻最多只能装一个武器；如果先前已经有了一把武器，那么之后再装武器的话，会弃置以前的武器来装现在的武器；

section 4:

伤害来源：杀、南猪入侵、万箭齐发的伤害来源均是使用该牌的猪，决斗的伤害来源如上；

距离：两只猪的距离定义为沿着逆时针方向间隔的猪数＋1。即初始时1和2的距离为1，但是2和1的距离就是n-1。注意一个角色的死亡会导致一些猪距离的改变；

玩家死亡：如果该玩家的体力降到0或者更低，并且自己手中没有足够的桃使得自己的体力值回到1，那么就死亡了，死亡后所有的牌（装备区，手牌区）被弃置；

奖励与惩罚：反猪死亡时，最后一个伤害来源处（即使是反猪）立即摸三张牌。忠猪死亡时，如果最后一个伤害来源是主猪，那么主猪所有装备牌、手牌被弃置；

注意，一旦达成胜利条件，游戏立刻结束，因此即使会摸3张牌或者还有牌可以用也不用执行了。

section 5:

已经知道每只猪的角色、手牌，还有牌堆初始情况，并且假设每个角色会按照如下的行为准则进行游戏。

section 6:

献殷勤：使用无懈可击挡下南猪入侵、万箭齐发、决斗；使用无懈可击抵消表敌意；

表敌意：对某个角色使用杀、决斗；使用无懈可击抵消献殷勤；

跳忠：即通过行动表示自己是忠猪。跳忠行动就是对主猪或对某只已经跳忠的猪献殷勤，或者对某只已经跳反的猪表敌意；

跳反：即通过行动表示自己是反猪。跳反行动就是对主猪或对某只已经跳忠的猪表敌意，或者对某只已经跳反的猪献殷勤；

忠猪不会跳反，反猪也不会跳忠；不管是忠猪还是反猪，能够跳必然跳；

section 7:

行动准则（共性）：每个角色如果手里有桃且生命值未满，那么必然吃掉；有南猪入侵、万箭齐发、必然使用；有装备必然装上；受到杀时，有闪必然弃置；响应南猪入侵或者万箭齐发时候，有杀/闪必然弃置；不会对未表明身份的猪献殷勤（包括自己）；

section 8:

主猪：主猪会认为，没有跳身份且用南猪入侵/万箭齐发对自己造成伤害的猪是“类反猪”（没伤害到不算，注意“类反猪”并没有表明身份），如果之后跳了，那么主猪会重新认识这只猪；对于每种表敌意的方式，对逆时针方向能够执行到的第一只“类反猪”或者已跳反猪表；如果没有，那么就不表敌意；决斗时会不遗余力弃置杀；如果能对已经跳忠的猪或自己献殷勤，那么一定献；如果能够对已经跳反的猪表敌意，那么一定表；

忠猪：对于每种表敌意的方式，对逆时针方向能够执行到的第一只已经跳反的猪表，如果没有，那么就不表敌意；决斗时，如果对方是主猪，那么不会弃置杀，否则，会不遗余力弃置杀；如果有机会对主猪或者已经跳忠的猪献殷勤，那么一定献；

反猪：对于每种表敌意的方式，如果有机会则对主猪表，否则，对逆时针方向能够执行到的第一只已经跳忠的猪表，如果没有，那么就不表敌意；决斗时会不遗余力弃置杀；如果有机会对已经跳反的猪献殷勤，那么一定献；

----------------------------------------------------------------------------------------------------------------------------------------------------------------------


好吧，其实都是挺有用的，即使已经玩过（甚至熟知）三国杀，也需要非常仔细的看懂，看清题目。


我还是一步一步来考虑的。


先看没有锦囊牌的情况。


在自己回合内，有武器当然是装上。闪一定是在非自己回合出的。桃的话血没有满就吃，杀的话能杀就杀，但是要找清目标（必须距离为1）。


所谓找清目标，就是——反贼找主公或表明身份的忠臣，忠臣找已经表明身份的反贼，主公找已经表明身份的反贼或类反贼。


这应该是最简单的部分了。但是我WA了一两次才拿到10分。


错因有：


1.没有完全找清目标；


2.装上诸葛连弩后，没有发现前面的杀也能用；


那么继续，向30分发起冲击。


30分的要求是——有锦囊牌，但是没有无懈可击。好吧，我得承认，没有无懈可击也要写很久。


首先，决斗。还是要找清目标——反贼决斗目标一定是主公，忠臣决斗目标一定是表明身份的反贼，主公决斗目标是表明身份的反贼或类反贼。


然后是万箭齐发和南蛮入侵。这是个多重目标攻击，所以要对每一个存活的非攻击发起者发起一次单向进攻。


这个部分需要注意很多：


3.决斗时，进攻发起者可以要使用多张杀，所以要处理好决斗后，手牌剩余部分；


4.决斗时，可能进攻发起者会GG（不知道他怎么想的，不愧是pig），此时要停止他的回合；


5.万箭齐发（南蛮入侵）时，可能会有多人GG，可能会摸多次牌；


6.万箭齐发（南蛮入侵）时，可能会有多人GG，同时发动者是主公，不仅杀死了忠臣，也杀死了反贼，此时也要考虑弃掉所有手牌和摸三张牌的顺序；


7.决斗时，主公认为对面是类反贼，实际上是忠臣，忠臣要牺牲一滴血；


8.在决斗时，发起者会明确身份；在万箭齐发（南蛮入侵）时，可能并不会，但有可能成为类反贼；


30分的段也WA个不停，但总算还是达到了。


剩下就是无懈可击了。


这是一个难点，但我认为，要突破它，首先要搞清无懈在不同情况下了作用，还有——它一定在锦囊牌生效之前使用。


题目中定义，如果某人使用了一张锦囊牌，那么从他后面的猪开始，依次有出无懈的机会（当然对于一张锦囊牌，最多只有1张无懈针对他本身）。


那么，假如A对B出了一张锦囊牌，首先，需要保证B的身份已经亮明（否则没有人会帮他，包括他自己）


然后，和B一派的，一定想方设法使初始锦囊牌无效；和B不一派的，一定想方设法使初始锦囊牌生效。


那么，这可以写个简易的dfs（顺便在过程中，如果能且有必要出无懈，就直接出掉了）。


然后，无懈不可能当做第一张锦囊牌打出（相当于永远是后手）。


对于无懈而言，需要注意的地方：


9.无懈不可能先手打出，并不代表在自己回合内就不用出无懈；


10.无懈的优先级很高（比一般锦囊牌都高）；


11.当一个人使用了无懈，他的身份就完全表明了；


12.无懈看似是最复杂，但是实际上相当于一个补丁（尽管有挺多的细节）；


以上是大致的做法，从10pts->30pts->100pts，而实际上，我爆出了形形色色的部分分（等下会展示）


下面还有一些全局的注意点：


13.主公杀死忠臣，一定要把装备给弃了；


14.关于一轮能否出多次杀，要注意判断；


15.一张牌，你出了，就相当于弃置了，不管最后是否生效；


16.最形象的方法存手牌显然是链表，但考虑到实际需要，一般直接开数组；


17.要分清在自己的回合出牌和在别人的回合出牌，最好用不同方法处理，但处理也有很多细节（因人而异）；


18.注意主公也会对类反贼表敌意；


19.杀，桃，无懈都是有可能在自己回合打出的“响应牌”（就是回击别人的牌），要注意处理方法（要看清是自己回合还是他人回合出的牌）；


20.严格意义上，除了“桃”，在自己回合出了每一张牌后，可能会激活这张牌前面的牌；


21.注意这里的距离是单向的，而不是双向的，而且恒为1；


22.存在用无懈无懈掉自己的锦囊牌的情况；


23.阵亡的人已经没有任何价值，直接跳过他；


24.一旦出现胜利局面，就要停止一切操作，但是需要把没有整理好的手牌整理好；


25.对于一个人，要是把手牌扫了一遍，没有出任何牌，就结束出牌；


26.一个人死了后，即使更新上一个玩家的下一个玩家nxt（不必o1求）；


27.注意一个人处于濒死状态的处理，没当有一个人死了，都要判断一下游戏是否结束了；


28.题目有一个小bug，当牌堆没有牌时，要一直摸最后一张牌。


这是我认为这题存在的细节（可能还有我数不过来了），这些细节有些是比较重要的，有些是要看写法的。


对于这一题我也有一些自己的看法——


这题其实很好，大量的代码，条件和情况能锻炼一个人的代码水平和思维能力。尽管有些方面不是特别好（比如出在了省选里面，估计没有什么人能打完并AC）。


然后我发现在luogu里面，这题的分类有一个AOE。为什么标AOE？有些人说因为南蛮和万箭是群体攻击。


我并不是这样认为的（当然也有可能我理解错了）——


因为这个题目依赖于主公亮明了身份。这个条件不是必要的，而是极其必要的。


因为，除主公外任意一个人要表明身份，必须要攻击一个以表明身份的人，这就构成了一个DAG（其实也是一颗树）。


这个DAG就是AOE网。


还有，我只是写了“三国杀”里的很小的一部分就出了这么多bug，如果是真正的三国杀，那真是无法可想。。


code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const bool diff[3][3]={{0,0,1},{0,0,1},{1,1,0}};
const int M=2005;
int n,m,fanzhu,deadfan,rounds,tmp[M],used[M]; char ch,cu;
struct PIGS {int iden,bloods,perfo,dead,nxt,equip,cnt; char cards[M];}a[15];
deque <char> cards_pile;
void _file() {
    freopen("pigs.in","r",stdin);
    freopen("pigs.out","w",stdout);
}
inline char read() {
    ch=getchar();
    while (ch<'A'||ch>'Z') ch=getchar();
    return ch;
}
void _init() {
    scanf("%d%d",&n,&m),fanzhu=deadfan=0;
    for (int i=1,las=0; i<=n; i++) {
        a[i].bloods=a[i].cnt=4,a[i].dead=a[i].perfo=a[i].equip=0,a[i].nxt=i%n+1;
        cu=read(),fanzhu+=(cu=='F'),a[i].iden=(cu!='F')?((cu!='Z')?0:1):2,cu=read();
        for (int j=1; j<=4; j++) a[i].cards[j]=read();
    }
    a[1].perfo=1;
    for (int i=1; i<=m; i++) cards_pile.push_back(read());
}
void get_cards(int cur) {
    a[cur].cards[++a[cur].cnt]=cards_pile.front();
    if (cards_pile.size()>1) cards_pile.pop_front();
}
bool ought(int cur) {
    int nxt=a[cur].nxt;
    if (a[nxt].perfo==0) return 0; else
    if (a[nxt].perfo==1) return diff[a[cur].iden][a[nxt].iden];
    else return a[cur].iden==0;
}
int atk(int cur) {
    if (a[cur].iden==2) return 1;
    for (int nxt=a[cur].nxt; nxt!=cur; nxt=a[nxt].nxt) if (!a[nxt].dead)
        if ((a[nxt].iden==2&&a[nxt].perfo==1)||(a[cur].iden==0&&a[nxt].perfo==-1)) return nxt;
    return -1;
}
void pend(int x,int y) {
    if (a[x].iden==0&&a[y].iden==1) {
        for (int i=1; i<=a[x].cnt; i++) used[i]=rounds; a[x].equip=0;
    }
    else if (a[y].iden==2) get_cards(x),get_cards(x),get_cards(x);
}
int find(int cur,char aim) {
    for (int i=1; i<=a[cur].cnt; i++) if (a[cur].cards[i]==aim) return i;
    return 0;
}
void adjust(int cur,int s,int t) {
    for (int i=s; i<t; i++) a[cur].cards[i]=a[cur].cards[i+1];
}
void respond_peach(int cur,int user) {
    int re=find(cur,'P');
    if (cur==user) {
        re=0;
        for (int i=1; i<=a[cur].cnt; i++) if (used[i]!=rounds&&a[cur].cards[i]=='P') {re=i; break;}
        if (re) used[re]=rounds,a[cur].bloods++;
        return;
    }
    if (re) a[cur].bloods++,adjust(cur,re,a[cur].cnt),a[cur].cnt--;
}
bool respond_dodge(int cur) {
    int re=find(cur,'D');
    if (re) adjust(cur,re,a[cur].cnt),a[cur].cnt--;
    return re;
}
bool respond_kill(int cur,int user) {
    int re=find(cur,'K');
    if (cur==user) {
        re=0;
        for (int i=1; i<=a[cur].cnt; i++) if (used[i]!=rounds&&a[cur].cards[i]=='K') {re=i; break;}
        if (re) used[re]=rounds;
        return re;
    }
    if (re) adjust(cur,re,a[cur].cnt),a[cur].cnt--;
    return re;
}
bool respond_wuxie(int cur,int user) {
    int re=find(cur,'J');
    if (cur==user) {
        re=0;
        for (int i=1; i<=a[cur].cnt; i++) if (used[i]!=rounds&&a[cur].cards[i]=='J') {re=i; break;}
        if (re) used[re]=rounds;
        return re;
    }
    if (re) adjust(cur,re,a[cur].cnt),a[cur].cnt--;
    return re;
}
void lose_blood(int cur,int user) {
    a[cur].bloods--; if (a[cur].bloods<1) respond_peach(cur,user);
}
void change_link(int cur) {
    for (int pre=1; pre<=n; pre++)
        if (!a[pre].dead&&a[pre].nxt==cur) {a[pre].nxt=a[cur].nxt; break;}
}
void do_peach(int cur) {
    a[cur].bloods++;
}
void do_kill(int cur) {
    int nxt=a[cur].nxt;
    a[cur].perfo=1;
    if (!respond_dodge(nxt)) {
        lose_blood(nxt,cur);
        if (a[nxt].bloods<1) deadfan+=(a[nxt].iden==2),a[nxt].dead=1,a[cur].nxt=a[nxt].nxt;
        if (fanzhu==deadfan||a[1].dead) return;
        if (a[nxt].bloods<1) pend(cur,nxt);
    }
}
bool do_wuxie(int user,int cur,int aim,int now) {
    bool ret=now;
    for (int nxt=cur; ; ) if (!a[nxt].dead) {
        if (!now) {
            if (!diff[a[nxt].iden][a[aim].iden])
                if (respond_wuxie(nxt,user)) {a[nxt].perfo=1; return do_wuxie(user,nxt,aim,1-now);}
        }else {
            if (diff[a[nxt].iden][a[aim].iden])
                if (respond_wuxie(nxt,user)) {a[nxt].perfo=1; return do_wuxie(user,nxt,aim,1-now);}
        }
        nxt=a[nxt].nxt; if (nxt==cur) break;
    }
    return ret;
}
void do_fight(int cur,int aim,int user) {
    a[cur].perfo=1;
    if (a[aim].perfo==1) {
        if (do_wuxie(cur,cur,aim,0)) return;
    }
    for (; ;) {
        if (a[cur].iden==0&&a[aim].iden==1) {
            lose_blood(aim,user);
            if (a[aim].bloods<1) deadfan+=(a[aim].iden==2),a[aim].dead=1,change_link(aim);
            if (fanzhu==deadfan||a[1].dead) return;
            if (a[aim].bloods<1) pend(cur,aim);
            return;
        }else
        if (!respond_kill(aim,user)) {
            lose_blood(aim,user);
            if (a[aim].bloods<1) deadfan+=(a[aim].iden==2),a[aim].dead=1,change_link(aim);
            if (fanzhu==deadfan||a[1].dead) return;
            if (a[aim].bloods<1) pend(cur,aim);
            return;
        }
        if (!respond_kill(cur,user)) {
            lose_blood(cur,user);
            if (a[cur].bloods<1) deadfan+=(a[cur].iden==2),a[cur].dead=1,change_link(cur);
            if (fanzhu==deadfan||a[1].dead) return;
            if (a[cur].bloods<1) pend(aim,cur);
            return;
        }
    }
}
void do_nanzhu(int cur) {
    for (int nxt=a[cur].nxt; nxt!=cur; nxt=a[nxt].nxt) if (!a[nxt].dead) {
        if (a[nxt].perfo==1) {
            if (do_wuxie(cur,cur,nxt,0)) continue;
        }
        if (!respond_kill(nxt,cur)) {
            lose_blood(nxt,cur); if (nxt==1&&a[cur].perfo==0) a[cur].perfo=-1;
            if (a[nxt].bloods<1) deadfan+=(a[nxt].iden==2),a[nxt].dead=1,change_link(nxt);
            if (fanzhu==deadfan||a[1].dead) return;
            if (a[nxt].bloods<1) pend(cur,nxt);
        }
    }
}
void do_wanjian(int cur) {
    for (int nxt=a[cur].nxt; nxt!=cur; nxt=a[nxt].nxt) if (!a[nxt].dead) {
        if (a[nxt].perfo==1) {
            if (do_wuxie(cur,cur,nxt,0)) continue;
        }
        if (!respond_dodge(nxt)) {
            lose_blood(nxt,cur); if (nxt==1&&a[cur].perfo==0) a[cur].perfo=-1;
            if (a[nxt].bloods<1) deadfan+=(a[nxt].iden==2),a[nxt].dead=1,change_link(nxt);
            if (fanzhu==deadfan||a[1].dead) return;
            if (a[nxt].bloods<1) pend(cur,nxt);
        }
    }
}
void do_zhuge(int cur) {
    a[cur].equip=1;
}
bool dis_cards(int cur) {
    memset(used,0,sizeof used);
    int i,cntused,totkill=0,counts,ret=-1,aim; char now;
    for (rounds=1; ; rounds++) {
        cntused=counts=0;
        for (i=1; i<=a[cur].cnt; i++) if (used[i]!=rounds) {
            now=a[cur].cards[i];
            switch (now) {
                case 'P':
                    if (a[cur].bloods<4) do_peach(cur),used[i]=rounds,cntused++,i=a[cur].cnt;
                    break;
                case 'K':
                    if ((!totkill||a[cur].equip)&&ought(cur)) do_kill(cur),used[i]=rounds,cntused++,totkill++,i=a[cur].cnt;
                    break;
                case 'F':
                    aim=atk(cur); if (aim!=-1) do_fight(cur,aim,cur),used[i]=rounds,cntused++,i=a[cur].cnt;
                    break;
                case 'N':
                    do_nanzhu(cur),used[i]=rounds,cntused++,i=a[cur].cnt;
                    break;
                case 'W':
                    do_wanjian(cur),used[i]=rounds,cntused++,i=a[cur].cnt;
                    break;
                case 'Z':
                    do_zhuge(cur),used[i]=rounds,cntused++,i=a[cur].cnt;
                    break;
                default:
                    break;
            }
            if (fanzhu==deadfan||a[1].dead) {ret=1; break;}
            if (a[cur].dead) {ret=0; break;}
        }
        for (int i=1; i<=a[cur].cnt; i++) if (used[i]!=rounds) tmp[++counts]=a[cur].cards[i];
        for (int i=1; i<=counts; i++) a[cur].cards[i]=tmp[i]; a[cur].cnt=counts;
        if (!cntused&&ret!=1) ret=0;
        if (ret>-1) return ret;
    }
}
bool playing(int cur) {
    get_cards(cur),get_cards(cur);
    return dis_cards(cur);
}
void _duel() {
    for (int i=1,event=0; !event&&fanzhu>0; i=a[i].nxt) if (!a[i].dead) event=playing(i);
}
void _print() {
    printf("%s\n",a[1].dead?"FP":"MP");
    for (int i=1; i<=n; i++) {
        if (a[i].dead) printf("%s","DEAD"); else {
            if (a[i].cnt>0) printf("%c",a[i].cards[1]);
            for (int j=2; j<=a[i].cnt; j++) printf(" %c",a[i].cards[j]);
        }
        puts("");
    }
}
int main() {
    _init();
    _duel();
    _print();
    return 0;
}
```

---

## 作者：夜刀神十香ღ (赞：226)

之前这个代码有些注释有bug，现已修复重新提交【给我过吧$QAQ$我辣么可怜】

-----

首先我的这段代码参考过了[hzwer](https://www.cnblogs.com/nietzsche-oier/p/9093673.html)dalao的做法但是大概架构是我打的只是有些小bug和他的代码对拍而已QAQ  
四位dalao都把一些注意事项和小坑都给列出来了，我就贴个有注释的代码吧……【打了我四个中午还鸽了一会QAQ】
```cpp
/*
牌库为空之后再抽牌，会重复抽最后一张被抽走牌
主公死或反贼全死都中断游戏，直接进入输出阶段
所有人一开始都知道主公的身份
每个人都会无条件帮队友无懈掉决斗【万箭】【南蛮】
每个人都会无条件【无懈】掉对手的【无懈】
每个人都不会【无懈】掉队友的【无懈】
反贼只会【决斗】主公
忠臣被主公【决斗】并不能算跳忠
主公杀了忠臣要清空所有牌以及【诸葛连弩】
杀死反贼摸三张牌
*/
/*
桃 P
杀 K
闪 D
决斗 F
南蛮入侵 N
万箭齐发 W
无懈可击 J
诸葛连弩 Z 
*/
#include<bits/stdc++.h>
using namespace std;

struct node{
    int cs,hp,next,last;
    //cs=cardsize=手牌数
	//hp 生命值 
    char id,card[2010];
    //id=identity=身份 
	bool zgln;
	//是否装备了【诸葛连弩】 
}a[20];
char kn[11],kpd[2010],sss[10];
//kn表示在主公眼里这只猪的身份
//kpd 卡牌堆 
int n,m,fz;
//fz 反贼数量 
bool ed;

void mp(int x)
//【摸牌】
{
    if(!m) m++;
    a[x].card[++a[x].cs]=kpd[m];
    m--;
}

void js(int x1,int x2)
//【击杀】 
{
    for(int i=1;i<=a[x2].cs;i++)
        if(a[x2].card[i]=='P')
        //判断是否有【桃】 
		{
            a[x2].card[i]='U';
            a[x2].hp++;
            return ;
        }
    a[a[x2].next].last=a[x2].last;
    a[a[x2].last].next=a[x2].next;
    //死亡后改变攻击距离 
    if(x2==1){ed=true;return ;}
    if(a[x2].id=='F') fz--;
    if(!fz){ed=true;return ;}
    //没有反贼游戏结束 
    if(a[x2].id=='F') mp(x1),mp(x1),mp(x1);
    //击杀反贼摸三张牌 
    if(a[x2].id=='Z' && a[x1].id=='M') a[x1].cs=0,a[x1].zgln=false;
    //如果主公把忠臣杀了那就要弃牌 
}

void Kil(int x1,int x2)
//【杀】 
{
    for(int i=1;i<=a[x2].cs;i++)
        if(a[x2].card[i]=='D')
		{
            a[x2].card[i]='U';
            return ;
        }
    a[x2].hp--;
    if(!a[x2].hp) js(x1,x2);
    //每次造成伤害都要判断被攻击者是否空血
	//然后进入【击杀】环节 
}

bool wxkj(int x1,int x2,int x3)
//【无懈可击】 
{
    int i=x1,pd=x3?x2:x1;
    while(1)
	{
        if(x3==1)
		{
            if(kn[x2]==a[i].id || (kn[x2]=='M' && a[i].id=='Z') || (kn[x2]=='Z' && a[i].id=='M'))
            //假如是敌对的那就【无懈可击】掉
                for(int j=1;j<=a[i].cs;j++)
                    if(a[i].card[j]=='J')
					{
                        a[i].card[j]='U';
                        kn[i]=a[i].id;
                        return !wxkj(i,x1,0);
                    }
        }
        else
		{
            if(((a[i].id=='M' || a[i].id=='Z') && kn[x1]=='F') || (a[i].id=='F' && (kn[x1]=='M' || kn[x1]=='Z')))
                for(int j=1;j<=a[i].cs;j++)
                    if(a[i].card[j]=='J')
					{
                        a[i].card[j]='U';
                        kn[i]=a[i].id;
                        return !wxkj(i,x1,0);
                    }
        }
        i=a[i].next;
        if(i==x1) break;
        //没有人用【无懈可击】抵挡此【无懈可击】那么这张牌就生效 
    }
    return false;
}

void nmrq(int x1)
//【南蛮入侵】
{
    for(int x2=a[x1].next;x2!=x1;x2=a[x2].next)
    //进行一个循环来出牌 
        if(!wxkj(x1,x2,1))
        //判断是否被【无懈可击】掉 
		{
			int i;
            for(i=1;i<=a[x2].cs;i++)
                if(a[x2].card[i]=='K')
				{
                    a[x2].card[i]='U';
                    break;
                }
            if(i>a[x2].cs)
			{
                a[x2].hp--;
                if(x2==1 && kn[x1]=='U') kn[x1]='L';
                if(!a[x2].hp) js(x1,x2);
                if(ed) return ;
            }
        }
}

void wjqf(int x1)
//【万箭齐发】 
{
    for(int x2=a[x1].next;x2!=x1;x2=a[x2].next)
        if(!wxkj(x1,x2,1))
        //判断是否被【无懈可击】掉 
		{
			int i;
            for(i=1;i<=a[x2].cs;i++)
                if(a[x2].card[i]=='D')
				{
                    a[x2].card[i]='U';
                    break;
                }
            if(i>a[x2].cs)
			{
                a[x2].hp--;
                if(x2==1 && kn[x1]=='U') kn[x1]='L';
                if(!a[x2].hp) js(x1,x2);
                if(ed) return ;
            }
        }
}

void jd(int x1,int x2)
//【决斗】 
{
    int i,j,k;
    if(wxkj(x1,x2,1)) return ;
    //判断是否被【无懈可击】掉 
    if(x1==1 && a[x2].id=='Z')
	{
        a[x2].hp--;
        if(!a[x2].hp) js(x1,x2);
        return ;
    }
    j=k=1;
    while(1)
	{
        while(a[x2].card[j]!='K' && j<=a[x2].cs) j++;
        if(j>a[x2].cs)
		{
            a[x2].hp--;
            if(!a[x2].hp) js(x1,x2);
            return ;
        }
        else a[x2].card[j]='U';
        while(a[x1].card[k]!='K' && k<=a[x1].cs) k++;
        if(k>a[x1].cs)
		{
            a[x1].hp--;
            if(!a[x1].hp) js(x2,x1);
            return ;
        }
        else a[x1].card[k]='U';
    }
}

void hh()
//进入回合 
{
    char nc;
    ed=true;
    if(fz) ed=false;
    if(ed) return ;
    for(int i=1;i;i=a[i].next)
	{
        mp(i),mp(i);
        bool kill=true;
        for(int j=1;j<=a[i].cs;j++)
            if(a[i].card[j]!='U')
            //=='U'就是被使用过，弃置了 
			{
                if(!a[i].hp) break;
                nc=a[i].card[j];
                //nc=now-card=现在的手牌 
                if(nc=='P')
                //使用【桃】
				{
                    if(a[i].hp!=4) a[i].hp++,a[i].card[j]='U';
                    continue;
                }
                if(nc=='K')
                //使用【杀】 
				{
                    if(!kill && !a[i].zgln) continue;
                    if(a[i].id=='M' && kn[a[i].next]!='L' && kn[a[i].next]!='F') continue;
                    if(a[i].id=='Z' && kn[a[i].next]!='F') continue;
                    if(a[i].id=='F' && kn[a[i].next]!='Z' && kn[a[i].next]!='M') continue;
                    a[i].card[j]='U';
                    Kil(i,a[i].next);
                    kn[i]=a[i].id,kill=false;
                    if(ed) return ;
                    continue;
                }
                if(nc=='F')
                //使用【决斗】
				{
                    if(a[i].id=='F')
					{
                        a[i].card[j]='U',jd(i,1);
                        kn[i]=a[i].id;
                        if(ed) return ;
                        j=0;
                        continue;
                    }
                    for(int k=a[i].next;k!=i;k=a[k].next)
                        if((a[i].id=='M' && (kn[k]=='L' || kn[k]=='F')) || (a[i].id=='Z' && kn[k]=='F'))
						{
                            a[i].card[j]='U',jd(i,k);
                            kn[i]=a[i].id;
                            if(ed) return ;
                            j=0;
                            break;
                        }
                    continue;
                }
                if(nc=='N')
                //使用【南蛮入侵】
				{
                    a[i].card[j]='U';
                    nmrq(i);
                    if(ed) return ;
                    j=0;
                    continue;
                }
                if(nc=='W')
                //使用【万箭齐发】 
				{
                    a[i].card[j]='U';
                    wjqf(i);
                    if(ed) return ;
                    j=0;
                    continue;
                }
                if(nc=='Z')
                //装备【诸葛连弩】 
				{
                    a[i].zgln=true;
                    a[i].card[j]='U';
                    j=0;
                    continue;
                }
            }
    }
}

int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++) a[i].next=i+1,a[i].last=i-1;
    //攻击距离 
    a[n].next=1,a[1].last=n;
    for(int i=1;i<=n;i++)
	{
        for(int j=1;j<2010;j++) a[i].card[j]='U';
        scanf("%s",sss);a[i].id=sss[0];
        for(int j=1;j<=4;j++) scanf("%s",sss),a[i].card[j]=sss[0];
        a[i].cs=a[i].hp=4;
        //手牌上限和血量上限都是4 
        if(a[i].id=='F') fz++;
        //统计反贼的数量 
        a[i].zgln=false;
    }
    for(int i=2;i<=n;i++) kn[i]='U';
    kn[1]='M';
    for(int i=1;i<=m;i++) scanf("%s",sss),kpd[m-i+1]=sss[0];
    hh();
    //进入回合 
    if(a[1].hp<=0) printf("FP\n");
    else printf("MP\n");
    //看看主公有没有挂 
    for(int i=1;i<=n;i++)
	{
        if(a[i].hp<=0) printf("DEAD\n");
        //空血凉凉 
        else
        //亮牌 
		{
            for(int j=1;j<=a[i].cs;j++)
                if(a[i].card[j]!='U') printf("%c ",a[i].card[j]);
                //若该手牌没有被弃置则输出 
            printf("\n");
        }
    }
    return 0;
}
```

---

## 作者：ecnerwaIa (赞：121)

此题居然没有<=100行代码的题解？我来发一波

（注：**码风仅供娱乐向，请勿学习这种码风！！！**）

（另注：之前貌似因为AFO所以导致有些错误没能处理，请谅解）

首先此题坑点很多，而我本人语文不好，多次理解错题意，导致交了一面才AC（理清思路后还是能做到300行内的）

1. 首先关于题目说的什么牌够用？哪里够用了...明明会RE两个点，所以不够用的时候一直拿最后一张牌（反人类）

1. 巨吓人的递归无懈...$A$无懈掉$B$对$C$无懈掉$D$无懈掉E对....这里其实判断也很好判断，假设一开始我们$x$的锦囊生效前,我们需要帮他无懈,此时默认x是受害者，那么$y$帮$x$，$y$和$x$就是一边的,$z$无懈$y,z$和$x$就是敌人，那么我们只需要知道三个信息$：$是谁的锦囊牌,最一开始的目标是谁,我是献殷勤，还是表敌意。每次递归的时候，表敌意$--->$献殷勤,献殷勤$--->$表敌意 即可 （因为此时无懈的人是 $x$的朋友，敌人轮换来的）

1. 决斗把自己打死了？这里我没判断TLE25分好气啊！一定注意决斗后判断自己是否$die$

1. 南蛮入侵 和 万箭齐发 是在$x$出$\ $杀/闪$\ $前别人帮出无懈,我硬是认为是自己没有才出（因为我玩三国杀的时候经常这样子，滑稽）

1. 注意了,因为每次是找到最左边的可以使用的牌，然而你的杀只能对右边一个使用,你的决斗要和明确身份的人决斗，你的桃要你扣血才能用，你的杀只能用一次！所以会发现，当你$\ \ $南蛮$\ \ $或者$\ \ $万箭 $\ \ $时可能**击杀了你右边和你同阵营的**（无脑杀队友）,然后如果**你的右边别成了你的敌人**，你就可以对他使用左边没用的杀，而之前是不能用的因为你不能杀你队友,还有可能就是 **南蛮$/$万箭 暴露了某些人的身份**，你就可以对他们使用决斗，或者在右边的敌人使用杀，然后就是决斗，你可能会让自己扣血，那么如果你之前是满血，就因为强制不让吃桃子，而存了起来，而扣血后又要返回左边去吃桃子， 亦或者是你装了一个诸葛连弩，发现左边还有杀可用。所以为了简化代码，可以**当你用了除桃以外的牌**时就要令$i=0$从头再扫一遍（请注意！此题绝对不卡时间，请放心大胆的暴力）

1. 如果反贼决斗，一定是找主pig，无论是否已经暴露身份，都会找主pig!

PS:因为我的代码比较的~~简洁明了~~，所以没那么多要注意的~~~

（但是我被第3点卡了3次,第5点卡了2次,第6点卡了2次... $(>﹏<)$）

接下来对代码核心部位进行讲解

其实不难发现很多地方要判断 $x$对$y$是献殷勤还是表敌意亦或者是不轻举妄动

那我这里做了个$f(x,y)$函数（**核心部分**）

1. $y$身份不明,谁也不能拿他怎么样（说不好听点就是有你没你都一样），返回-1（即不献殷勤，也不表敌意）

1. $y$是类反$pig$（神秘$pig$）,如果$x$是主$pig$,就返回0(敌意，无论谁打我我一定还击，真滑稽这个主$pig$),否则返回-1(否则一棒打死自己人划不来)

1. $x$是主$pig$,如果y是忠$pig$返回$1$（献殷勤），否则返回$0$(因为前两种已经讨论了不明身份或者是类反$pig$，所以$y$一定明确身份)

1. $x$是忠$pig$，如果$y$是主$/$忠$pig$,&emsp;返回1,&emsp;否则返回0

1. $x$是反$pig$，如果$y$是主$/$忠$pig$,&emsp;返回0,&emsp;否则返回1

代码里面，$pig$，手牌都是用链表写的,感觉这样好写多了nxt[i]为下一张牌,pre[i]为上一张,nxt[0]为第一张牌



$upd(int\ x,int\ y,int\ v):$也是个**核心部分**，是用来根据$x$对$y$使用了什么(v代表的),来判定$x$的身份，$v$归纳为两种

$0:$ 使用无懈,杀，决斗（可以明确身份）

$1:$使用南蛮入侵，万箭齐发（已经造成了伤害）（只能变为类反pig）

首先如果$x$身份已经明确（$0<=id<=2$）返回

否则$id=pid$即可（pid为初始身份,id为当前暴露出的身份）

其余的什么摸牌，弃置，回和开始摸牌，判定是否结束，结束函数，奖励$/$惩罚函数，判断是奖励还是惩罚函数,吃桃函数,濒死函数,攻击函数,无懈函数（递归），南蛮$/$万箭函数（我没归到一起，但事实上可以）,回合函数,和主函数 就没什么可说了，分开写就很容易写出来的，之后只用调用即可

下面上代码（93行！)

这里有两个版本，第一个是我觉得看上去更舒服，更清爽的（其实就是强行压行...当然也可能会使有的人来说十分窒息），第二个是我以前的码风（准确来说是以前的码风格式化后的，250多行）

first:

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;//任何锦囊牌对x生效前,判断和x一边的是否有无懈,判断和x不是一边的是否有无懈无懈掉无懈,dfs判断
int n,m,L,len;
const int N=15,M=2010;
char s[M];//id=-1未表明 ,(id=0主pig) (id=1 忠pig) (id=2 反pig) (id=3类反pid)(表明身份) 
//pid:给定身份 ,nt下一个,pr上一个pig,cnt:牌数 zgln:诸葛连弩 s:牌
//nxt:下一张牌,pre上一张牌 ,end:最后一张牌 
struct Pig{int HP,id,pid,nt,pr,cnt;bool zgln;char s[M];int nxt[M],pre[M],end;}a[N];
int Pig[3];//p[0]:主pig p[1]:忠pig p[2]:反pig
inline void ins(int x,char c){int p=++a[x].cnt;a[x].nxt[a[x].end]=p;a[x].pre[p]=a[x].end;a[x].end=p;a[x].s[p]=c;}//摸牌
inline char get(){if(L<=m)return s[L++];return s[m];}//得到牌 
inline void start(int x){ins(x,get());ins(x,get());}//回合开始摸两张 
inline void del(int x,int pos){a[x].nxt[a[x].pre[pos]]=a[x].nxt[pos];a[x].pre[a[x].nxt[pos]]=a[x].pre[pos];if(a[x].end==pos)a[x].end=a[x].pre[pos];}//弃置 
inline void clear(){a[1].end=0;a[1].nxt[0]=0;a[1].zgln=0;}//主猪误杀 ,弃掉所有牌和zgln 
inline void end(){//结束
    if(!Pig[0])printf("FP\n");else if(!Pig[2])printf("MP\n");
    for(int i=1;i<=n;++i){if(a[i].HP<=0)printf("DEAD");else {for(int j=a[i].nxt[0];j;j=a[i].nxt[j])printf("%c ",a[i].s[j]);}printf("\n");}
	exit(0);
}
inline int f(int x,int y){//x-->y献殷勤或者表敌意,0敌意,1殷勤,核心代码 
    if(a[y].id==-1)return -1;//y未明确身份,x不轻举妄动
    if(a[y].id==3){if(a[x].pid==0)return 0;else return -1;}//主pig对类反pig也是敌意,其余对类反pid不轻举妄动 
    if(a[x].pid==0){if(a[y].id==1||a[y].id==0)return 1;else return 0;}
    if(a[x].pid==1){if(a[y].id==0||a[y].id==1)return 1;else return 0;}
    if(a[x].pid==2){if(a[y].id==0||a[y].id==1)return 0;else return 1;}
    return -1;
}
inline void is_end(){if(Pig[0]&&Pig[2])return;end();}//是否结束,主pig,或者反pig死亡就算结束 
inline void jl(int x){ins(x,get());ins(x,get());ins(x,get());}//奖励
inline void pd(int dead,int killer){if(a[dead].pid==2)jl(killer);if(a[dead].pid==1&&a[killer].pid==0)clear();}
inline void P(int x,int pos){if(a[x].HP==4)return;a[x].HP++;del(x,pos);}//吃桃,自己的回合能吃就吃
inline void is_dead(int x,int y){//濒死,可以吃桃 
    if(a[x].HP>0)return;
    for(int i=a[x].nxt[0];i;i=a[x].nxt[i]){if(a[x].s[i]=='P')P(x,i);if(a[x].HP>0)break;}
    if(a[x].HP<=0){a[a[x].nt].pr=a[x].pr;a[a[x].pr].nt=a[x].nt;Pig[a[x].pid]--;is_end();pd(x,y);}//死亡就去掉这个人,先判断是否结束 
}
inline void upd(int x,int y,int v){if(a[x].id>=0&&a[x].id<=2)return;//已经跳了,就返回 
    if(v==1){if(a[y].pid==0)a[x].id=3;return;}//对主pig造成伤害变为类反pig
    a[x].id=a[x].pid;
}//x对y:v=0:使用无懈,杀,决斗,: v=1使用南蛮,万箭
inline void attack(int x,int y){a[y].HP--;is_dead(y,x);}//x攻击y,判断y是否死亡,攻击来源是x,濒死可以吃桃
inline bool have(int x,char c){for(int i=a[x].nxt[0];i;i=a[x].nxt[i])if(a[x].s[i]==c){del(x,i);return 1;}return 0;}//是否有c这张牌,有则丢 
inline bool K(int x,int pos){//决定是否对下一个打杀取决于献殷勤还是表敌意 
    int y=a[x].nt;int p=f(x,y);if(p==-1)return 0;//未使用
    if(p==0){del(x,pos);upd(x,y,0);if(!have(y,'D'))attack(x,y);return 1;}//表敌意,杀一下,对面没有闪则造成伤害 
    return 0; //无论是否造成伤害都要更新他的身份id 
}
inline bool J(int x,int y,int v){
    if(f(x,y)==v&&have(x,'J')){upd(x,y,0);if(!J(x,y,v^1))return 1;}
    for(int i=a[x].nt;i!=x;i=a[i].nt){if(f(i,y)==v&&have(i,'J')){upd(i,y,0);if(!J(i,y,v^1))return 1;}}
    return 0;
}//从x开始,需要给y出什么,v=0表示我是他敌人,我要无懈他的无懈,v=1表示我和他是一边的,我要帮他无懈 
inline void F(int x,int y){//x对y用决斗,y先出
    if(J(x,y,1))return;
    while(1){swap(x,y);if((a[x].pid==1&&a[y].pid==0)||(!have(x,'K'))){attack(y,x);return;}}//x没杀,或者x是忠pig,y是主pig
}inline void Nmrq(int x,int y){//x对y使用
    if(!J(x,y,1)&&!have(y,'K')){attack(x,y);upd(x,y,1);}
}inline void Wjqf(int x,int y){
    if(!J(x,y,1)&&!have(y,'D')){attack(x,y);upd(x,y,1);}
}
inline void work(int x){
    start(x);int is_K=0;
    for(int i=a[x].nxt[0];i;i=a[x].nxt[i]){
        if(a[x].s[i]=='P')P(x,i);
        if(a[x].s[i]=='K'&&(!is_K||a[x].zgln))if(K(x,i)){is_K++;i=0;}
        if(a[x].s[i]=='F'){
			if(a[x].pid==2){del(x,i);upd(x,1,0);F(x,1);i=0;}
			else for(int j=a[x].nt;j!=x;j=a[j].nt){int p=f(x,j);if(p==0){del(x,i);upd(x,j,0);F(x,j);i=0;break;}
			}if(a[x].HP<=0)return;
		}
        if(a[x].s[i]=='N'){del(x,i);for(int j=a[x].nt;j!=x;j=a[j].nt)Nmrq(x,j);i=0;}
        if(a[x].s[i]=='W'){del(x,i);for(int j=a[x].nt;j!=x;j=a[j].nt)Wjqf(x,j);i=0;}
        if(a[x].s[i]=='Z'){a[x].zgln=1;del(x,i);i=0;}
    }
}
inline void slove(){
    scanf("%d%d",&n,&m);
    char S[5];int kase;
    for(int i=1;i<=n;++i){
        scanf("%s",S+1);kase=0;
        if(S[1]=='M')a[i].pid=0;else if(S[1]=='Z')a[i].pid=1;else a[i].pid=2;
        Pig[a[i].pid]++;
        while(++kase<=4){scanf("%s",S+1);ins(i,S[1]);}
    }for(int i=1;i<=m;++i){scanf("%s",S+1);s[i]=S[1];}
    for(int i=1;i<=n;++i){a[i].nt=(i==n?1:i+1);a[i].pr=(i==1?n:i-1);a[i].HP=4;a[i].id=-1;}
    L=1;a[1].id=0;is_end();
    for(int i=1;;i=a[i].nt)work(i);
}
int main(){slove();return 0;}
```

second:

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;//任何锦囊牌对x生效前,判断和x一边的是否有无懈,判断和x不是一边的是否有无懈无懈掉无懈,dfs判断
int n,m,L,len;
const int N=15,M=2010;
char s[M];//id=-1未表明 ,(id=0主pig) (id=1 忠pig) (id=2 反pig) (id=3类反pid)(表明身份)
//pid:给定身份 ,nt下一个,pr上一个pig,cnt:牌数 zgln:诸葛连弩 s:牌
//nxt:下一张牌,pre上一张牌 ,end:最后一张牌
struct Pig {
	int HP,id,pid,nt,pr,cnt;
	bool zgln;
	char s[M];
	int nxt[M],pre[M],end;
} a[N];
int Pig[3];//p[0]:主pig p[1]:忠pig p[2]:反pig
inline void ins(int x,char c) {
	int p=++a[x].cnt;    //摸牌
	a[x].nxt[a[x].end]=p;
	a[x].pre[p]=a[x].end;
	a[x].end=p;
	a[x].s[p]=c;
}
inline char get() {
	if(L<=m)return s[L++];    //得到牌
	return s[m];
}
inline void start(int x) {
	ins(x,get());    //回合开始摸两张
	ins(x,get());
}
inline void del(int x,int pos) {
	a[x].nxt[a[x].pre[pos]]=a[x].nxt[pos];    //弃置
	a[x].pre[a[x].nxt[pos]]=a[x].pre[pos];
	if(a[x].end==pos)a[x].end=a[x].pre[pos];
}
inline void clear() {
	a[1].end=0;    //主猪误杀 ,弃掉所有牌和zgln
	a[1].nxt[0]=0;
	a[1].zgln=0;
}
inline void end() { //结束
	if(!Pig[0])printf("FP\n");
	else if(!Pig[2])printf("MP\n");
	for(int i=1; i<=n; ++i) {
		if(a[i].HP<=0)printf("DEAD");
		else {
			for(int j=a[i].nxt[0]; j; j=a[i].nxt[j])printf("%c ",a[i].s[j]);
		}
		printf("\n");
	}
	exit(0);
}
inline int f(int x,int y) { //x-->y献殷勤或者表敌意,0敌意,1殷勤,核心代码
	if(a[y].id==-1)return -1;//y未明确身份,x不轻举妄动
	if(a[y].id==3) {
		if(a[x].pid==0)return 0;    //主pig对类反pig也是敌意,其余对类反pid不轻举妄动
		else return -1;
	}
	if(a[x].pid==0) {
		if(a[y].id==1||a[y].id==0)return 1;
		else return 0;
	}
	if(a[x].pid==1) {
		if(a[y].id==0||a[y].id==1)return 1;
		else return 0;
	}
	if(a[x].pid==2) {
		if(a[y].id==0||a[y].id==1)return 0;
		else return 1;
	}
	return -1;
}
inline void is_end() {
	if(Pig[0]&&Pig[2])return;    //是否结束,主pig,或者反pig死亡就算结束
	end();
}
inline void jl(int x) {
	ins(x,get());    //奖励
	ins(x,get());
	ins(x,get());
}
inline void pd(int dead,int killer) {
	if(a[dead].pid==2)jl(killer);
	if(a[dead].pid==1&&a[killer].pid==0)clear();
}
inline void P(int x,int pos) {
	if(a[x].HP==4)return;    //吃桃,自己的回合能吃就吃
	a[x].HP++;
	del(x,pos);
}
inline void is_dead(int x,int y) { //濒死,可以吃桃
	if(a[x].HP>0)return;
	for(int i=a[x].nxt[0]; i; i=a[x].nxt[i]) {
		if(a[x].s[i]=='P')P(x,i);
		if(a[x].HP>0)break;
	}
	if(a[x].HP<=0) {
		a[a[x].nt].pr=a[x].pr;    //死亡就去掉这个人,先判断是否结束
		a[a[x].pr].nt=a[x].nt;
		Pig[a[x].pid]--;
		is_end();
		pd(x,y);
	}
}
inline void upd(int x,int y,int v) {
	if(a[x].id>=0&&a[x].id<=2)return;//已经跳了,就返回
	if(v==1) {
		if(a[y].pid==0)a[x].id=3;    //对主pig造成伤害变为类反pig
		return;
	}
	a[x].id=a[x].pid;
}//x对y:v=0:使用无懈,杀,决斗,: v=1使用南蛮,万箭
inline void attack(int x,int y) {
	a[y].HP--;    //x攻击y,判断y是否死亡,攻击来源是x,濒死可以吃桃
	is_dead(y,x);
}
inline bool have(int x,char c) {
	for(int i=a[x].nxt[0]; i; i=a[x].nxt[i])if(a[x].s[i]==c) {
			del(x,i);    //是否有c这张牌,有则丢
			return 1;
		}
	return 0;
}
inline bool K(int x,int pos) { //决定是否对下一个打杀取决于献殷勤还是表敌意
	int y=a[x].nt;
	int p=f(x,y);
	if(p==-1)return 0;//未使用
	if(p==0) {
		del(x,pos);    //表敌意,杀一下,对面没有闪则造成伤害
		upd(x,y,0);
		if(!have(y,'D'))attack(x,y);
		return 1;
	}
	return 0; //无论是否造成伤害都要更新他的身份id
}
inline bool J(int x,int y,int v) {
	if(f(x,y)==v&&have(x,'J')) {
		upd(x,y,0);
		if(!J(x,y,v^1))return 1;
	}
	for(int i=a[x].nt; i!=x; i=a[i].nt) {
		if(f(i,y)==v&&have(i,'J')) {
			upd(i,y,0);
			if(!J(i,y,v^1))return 1;
		}
	}
	return 0;
}//从x开始,需要给y出什么,v=0表示我是他敌人,我要无懈他的无懈,v=1表示我和他是一边的,我要帮他无懈
inline void F(int x,int y) { //x对y用决斗,y先出
	if(J(x,y,1))return;
	while(1) {
		swap(x,y);    //x没杀,或者x是忠pig,y是主pig
		if((a[x].pid==1&&a[y].pid==0)||(!have(x,'K'))) {
			attack(y,x);
			return;
		}
	}
}
inline void Nmrq(int x,int y) { //x对y使用
	if(!J(x,y,1)&&!have(y,'K')) {
		attack(x,y);
		upd(x,y,1);
	}
}
inline void Wjqf(int x,int y) {
	if(!J(x,y,1)&&!have(y,'D')) {
		attack(x,y);
		upd(x,y,1);
	}
}
inline void work(int x) {
	start(x);
	int is_K=0;
	for(int i=a[x].nxt[0]; i; i=a[x].nxt[i]) {
		if(a[x].s[i]=='P')P(x,i);
		if(a[x].s[i]=='K'&&(!is_K||a[x].zgln))if(K(x,i)) {
				is_K++;
				i=0;
			}
		if(a[x].s[i]=='F') {
			if(a[x].pid==2) {
				del(x,i);
				upd(x,1,0);
				F(x,1);
				i=0;
			} else for(int j=a[x].nt; j!=x; j=a[j].nt) {
					int p=f(x,j);
					if(p==0) {
						del(x,i);
						upd(x,j,0);
						F(x,j);
						i=0;
						break;
					}
				}
			if(a[x].HP<=0)return;
		}
		if(a[x].s[i]=='N') {
			del(x,i);
			for(int j=a[x].nt; j!=x; j=a[j].nt)Nmrq(x,j);
			i=0;
		}
		if(a[x].s[i]=='W') {
			del(x,i);
			for(int j=a[x].nt; j!=x; j=a[j].nt)Wjqf(x,j);
			i=0;
		}
		if(a[x].s[i]=='Z') {
			a[x].zgln=1;
			del(x,i);
			i=0;
		}
	}
}
inline void slove() {
	scanf("%d%d",&n,&m);
	char S[5];
	int kase;
	for(int i=1; i<=n; ++i) {
		scanf("%s",S+1);
		kase=0;
		if(S[1]=='M')a[i].pid=0;
		else if(S[1]=='Z')a[i].pid=1;
		else a[i].pid=2;
		Pig[a[i].pid]++;
		while(++kase<=4) {
			scanf("%s",S+1);
			ins(i,S[1]);
		}
	}
	for(int i=1; i<=m; ++i) {
		scanf("%s",S+1);
		s[i]=S[1];
	}
	for(int i=1; i<=n; ++i) {
		a[i].nt=(i==n?1:i+1);
		a[i].pr=(i==1?n:i-1);
		a[i].HP=4;
		a[i].id=-1;
	}
	L=1;
	a[1].id=0;
	is_end();
	for(int i=1;; i=a[i].nt)work(i);
}
int main() {
	slove();
	return 0;
}
```


---

## 作者：历史的行程 (赞：88)

   蒟蒻我和机房oier们宣布要在11月底写完猪国杀，于是在11月31日写完了（众所周知11月至少有31天）。我码的时候也遇到了各种各样的问题，比较重要的有：
   
   1. 使用某些牌后，可能使它之前的手牌变得可用，所以使用手牌后，要从头扫描手牌。
   2. 决斗可能会使正在进行回合的猪死亡（所以果然是猪吗……），此时要赶紧返回，不能让已经死亡的猪继续使用手牌。
   3. 忠猪面对来自主猪的决斗，会直接自残。
   4. 寻找杀和决斗等的对象，要跳过已经死亡的猪。
   5. 决斗、南猪、万箭的无懈询问是从出锦囊牌的猪开始的。
   
 ###  此外，还有一点很重要的事情，牌堆可能被抽空。抽空后，要不断抽牌堆最后一张牌。这应该属于出题人的失误。
###   作为蒟蒻，这么大的模拟我写不了面向过程，只能用三脚猫的面向对象惹。
### 以下为AC代码，供各位dalao鄙视QwQ
   
 
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>
#define for_i_in_hand for(itr i = hand.begin();i < hand.end();i++)
#define itr std::vector<card>::iterator

using std::cin;
using std::cout;
using std::endl;

struct card
{
	bool avai;
	char card;
};

class Pig
{
	public:
		//方法 
		void	identity_set	(char id);//身份初始化 
		
		void	turn_start		();//回合开始 
		void	draw			();//抽一张牌 
		void	act				();//出牌阶段 
		
		void	use_card		(itr i,char ch);//使用卡牌 
		bool	find_and_use	(char ch);//在手牌中寻找并打出一张牌 
		int		dec_health		();//生命值减少 
		int 	inc_health		();//生命值增加 
		void	jump			();//跳身份 
		void	go_rebel_like	();//进入类反状态 
		void	ungo_rebel_like	();//取消类反状态 
		void	unequip			();//卸下诸葛连弩 
		void	hurt			(Pig &that);//对that造成伤害 
		bool	close_to_death	();//进入濒死状态 
		void	slay			(Pig &that);//杀死that
		void	slain			();//被杀死 
		
		bool 	use_admission	(char ch);//是否可能在出牌阶段使用该卡牌 
		int		try_kill		();//寻找杀对象 
		void	kill			(Pig &that);//杀 
		bool	kill_respond	();//响应杀 
		int		try_fight		();//寻找决斗对象
		void	fight			(Pig &that);//决斗 
		void	invasion		();//南蛮入侵 
		bool	invasion_respond();//响应南蛮入侵 
		void	arrows			();//万箭齐发 
		bool	arrows_respond	();//响应万箭齐发 
		void	crossbow		();//装备诸葛连弩 
		bool	first_watertight_ask	(Pig &that);//使用无懈可击的第一阶段 
		bool	against_watertight_ask	();//无懈可击的对抗阶段 
		
		//变量 
		int 	num;//在数组中的编号 
		std::vector<card> hand;//手牌 
		char	identity;//身份 
		int 	health;//剩余生命值
		 
		bool 	equipped;//是否装备着诸葛连弩 
		bool 	dead;//是否死亡 
		bool 	kill_used;//本回合是否已经使用过杀 
		bool	jumped;//是否已经跳身份 
		bool	rebel_liked;//是否处于类反状态 
};

class Input
{
	public:
		void	main_input();//主输入 
		
		void	in_n_and_m();//输入n和m 
		void	in_id_and_cards();//输入身份和起始手牌 
		void	in_card_heap();//输入牌堆 
};

int n,m;//n表示总猪数，m表示牌堆的牌数量 
int main_pig;//主猪编号 
int anti_num = 0;//当前剩余反猪数量 
int heap_top = 1;//牌堆顶 
bool gameover;//是否可以结束游戏 
char win;//胜利方 
char card_heap[20000];//牌堆 
Input In;//Input对象 
Pig	pig[20];//记录各猪 

const bool debug = false;//调试入口，改为真即输出调试信息 

void num_set();//从数组编号向各猪num属性映射 
void heap_copy();//复制牌堆最后一张牌 
void print();//输出结果 
void initialize();//猪的初始化 

int main()//entrance
{
	In.main_input();//输入 
	initialize();
	num_set();
	heap_copy();
	pig[main_pig].jump();//主猪一开始是跳的 
	if(anti_num == 0)//特判：场上没有反猪，主猪方直接胜利 
	{
		win = 'M';
		print();
		return 0;
	}
	register int i = 0;//轮到的猪 
	while(1)//主循环 
	{
		i = i % n + 1;
		if(pig[i].dead) continue;//跳过死亡的猪 
		if(debug) printf("%d's turn started\n\n",i);
		pig[i].turn_start();//回合开始 
		if(gameover)//检测游戏是否结束 
		{
			print();
			break;//输出结果，程序结束 
		}
	}
	return 0;
}

void num_set()
{
	for(register int i = 1;i <= n;++i) pig[i].num = i;
}

void heap_copy()
{
	register char ch = card_heap[m];
	for(register int i = m + 1;i <= 5000;i++)
	{
		card_heap[i] = ch;//复制最后一张牌 
	}
}

void print()
{
	if(win == 'M')
	{
		printf("MP\n");
	}
	else
	{
		printf("FP\n");
	}
	for(int i = 1;i <= n;i++)
	{
		if(pig[i].dead)
		{
			printf("DEAD\n");
		}
		else
		{
			Pig s = pig[i];
			for(itr i = s.hand.begin();i < s.hand.end();i++)
			{
				if(i->avai) printf("%c ",i->card);
			}
			printf("\n");
		}
	}
}

void initialize()
{
	for(int i = 1;i <= n;i++)//信息初始化 
	{
		pig[i].health = 4;
		pig[i].equipped = false;
		pig[i].dead = false;
		pig[i].kill_used = false;
		pig[i].jumped = false;
		pig[i].rebel_liked = false;
	}
}

void Input::main_input()
{
	in_n_and_m();
	in_id_and_cards();
	in_card_heap();
}

void Input::in_n_and_m()//
{
	scanf("%d %d",&n,&m);
}

void Input::in_id_and_cards()//
{
	char s[10];
	char ch;
	for(int i = 1;i <= n;i++)
	{
		scanf("%s",s);
		if(s[0] == 'M')
		{
			main_pig = i;//记录主猪编号 
		}
		else if(s[0] == 'F')
		{
			anti_num++;//记录反贼数量 
		}
		pig[i].identity_set(s[0]);//身份初始化 
		while((ch = getchar()) != '\n')//寻找下一张手牌 
		{
			if(ch >= 'A' && ch <= 'Z')
			{
				pig[i].hand.push_back(card{true,ch});//加入手牌 
			}
		}
	}
}

void Input::in_card_heap()
{
	char ch;
	for(register int i = 1;i <= m;++i)
	{
		while( ( ch = getchar() ) < 'A' || ch > 'Z' ) continue;
		card_heap[i] = ch;
	}
}


void Pig::identity_set(char id)
{
	identity = id;
}

void Pig::turn_start()
{
	draw();
	draw();//抽两张牌 
	if(debug)
	{
		for(int i = 1;i<=n;i++)
		{
			if(pig[i].dead)continue;
			printf("%d %c %d:",pig[i].num,pig[i].identity,pig[i].health);
			Pig s = pig[i];
			for(itr i = s.hand.begin();i < s.hand.end();i++) if(i->avai) printf("%c ",i->card);
			printf("\n");
		}
	}
	act();//出牌阶段开始 
	kill_used = false;//重置出杀检测 
	if(debug) cout<<endl;
}

void Pig::draw()
{
	hand.push_back(card{true,card_heap[heap_top++]});//加入一张手牌，牌堆顶后移 
}

void Pig::act()
{
	bool flag=true;
	while(flag)//扫了一遍手牌，如果没有出牌，则结束出牌阶段 
	{
		flag = false;
		for(itr i = hand.begin();i != hand.end();i++)
		{
			if(i->avai&&use_admission(i->card))
			{
				use_card(i,i->card);
				if(dead || gameover) return;
				//注意：这只猪有可能在决斗中自杀身亡，这时不能让它继续出牌 
				//如果游戏结束，那么立即返回 
				i = hand.begin() - 1;
				//使用一张牌后，前面的牌可能变得可用，此时需要回到第一张手牌重新扫描手牌
				//之所以要-1，是因为在for循环末尾i++ 
				flag = true;//使用了牌 
			}
		}
	}
}

bool Pig::find_and_use(char ch)
{
	for_i_in_hand
	{
		if(i->card == ch && i->avai)//如果是想要的牌而且没出过 
		{
			i->avai = false;//懒惰删除，标记牌已使用过 
			if(debug) cout<<num<<" used a "<<ch<<endl; 
			return true;//使用了牌，返回真 
		}
	}
	return false;//找不到牌，返回假 
}

void Pig::use_card(itr i,char ch)
{
	int tmp;
	switch(ch)
	{
		case 'K'://杀 
			if(tmp = try_kill())//用tmp记下杀的对象，决斗同 
			{
				i->avai = false;
				if(debug) printf("%d used a kill to %d\n",num,tmp);
				kill(pig[tmp]);
			}
			break;
		case 'P'://桃 
			i->avai = false;
			if(debug) printf("%d used a peach\n",num);
			inc_health();
			break;
		case 'F':
			if(tmp = try_fight())
			{
				i->avai = false;
				if(debug) printf("%d used a fight to %d\n",num,tmp);
				fight(pig[tmp]);
			}
			break;
		case 'N':
			i->avai = false;
			if(debug) printf("%d used a invasion\n",num);
			invasion();
			break;
		case 'W':
			i->avai = false;
			if(debug) printf("%d used a arrows\n",num);
			arrows();
			break;
		case 'Z':
			i->avai = false;
			if(debug) printf("%d used a crossbow\n",num);
			crossbow();
	}
}

inline int Pig::dec_health()
{
	return --health;
}

inline int Pig::inc_health()
{
	return ++health;
}

inline void Pig::jump()
{
	jumped = true;
}

inline void Pig::go_rebel_like()
{
	rebel_liked = true;
}

inline void Pig::ungo_rebel_like()
{
	rebel_liked = false;
}

inline void Pig::unequip()
{
	equipped = false;
}

inline void Pig::hurt(Pig &that)
{
	that.dec_health();//生命值减少 
	if(debug) printf("%d hurts %d,left health %d\n",num,that.num,that.health);
	if(that.health == 0 && that.close_to_death())//濒死检查 
	{
		if(debug) cout<<that.num<<" died"<<endl;
		this->slay(that);//击杀处理 
	}
}

bool Pig::close_to_death()
{
	//找桃 
	for(itr i = hand.begin();i < hand.end();i++)
	{
		if(i->card == 'P' && i->avai)
		{
			i->avai = false;
			inc_health();
			return false;
		}
	}
	return true;
}

void Pig::slay(Pig &that)
{
	that.slain();
	if(that.identity == 'M')//主公死亡，反贼胜利 
	{
		win = 'F';
		gameover = true;
	}
	else if(that.identity == 'F')//反贼死亡 
	{
		anti_num--;
		if(anti_num == 0)//反贼全灭，主公胜利 
		{
			win = 'M';
			gameover = true;
			return;//胜利后不进行奖励抽牌 
		}
		draw(),draw(),draw();
	}
	else if(identity  == 'M' && that.identity == 'Z')//主公杀忠臣 
	{
		for(itr i = hand.begin();i < hand.end();i++)
		{
			i->avai = false;
		}
		unequip();
	}
}

inline void Pig::slain()//
{
	dead = true;
}

 bool Pig::use_admission(char ch)//
{
	if(ch == 'P' && health < 4) return true;//生命值不满时才允许使用桃 
	else if((ch == 'K' && try_kill()) || (ch == 'F' && try_fight()) || ch == 'N' || ch == 'W' || ch == 'Z') return true;//使用杀和决斗必须有对象 
	return false;
}

int Pig::try_kill()
{
	//返回值为0，表示无猪可杀。返回值不为0，即为被指定为杀的对象的猪的编号 
	if(kill_used && !equipped) return 0;//本回合不得再出杀 
	if(identity == 'M')//主猪杀猪 
	{
		for(int i = num % n + 1;i != num;i = i % n + 1)
		{
			if(pig[i].dead) continue;//跳过死亡猪，寻找逆时针第一只猪，下同 
			if(pig[i].rebel_liked || (pig[i].identity == 'F' && pig[i].jumped))//检测下一只猪是否为类反猪或反猪 
			{
				return i;
			}
			else//不是，不杀 
			{
				return 0;
			}
		}
	}
	else if(identity == 'Z')//忠猪杀猪 
	{
		for(int i = num % n + 1;i != num;i = i % n + 1)
		{
			if(pig[i].dead) continue;
			if(pig[i].identity == 'F' && pig[i].jumped)//需求反猪 
			{
				return i;
			}
			else
			{
				return 0;
			}
		}
	}
	else//反猪杀猪 
	{
		int i;
		for(i = num % n + 1;i != num;i = i % n + 1)
		{
			if(pig[i].dead) continue;
			if(pig[i].identity != 'F' && pig[i].jumped)//需求反猪 
			{
				return i;
			}
			else
			{
				return 0;
			}
		}
	}
}

inline void Pig::kill(Pig &that)
{
	jump();//杀必然跳身份 
	ungo_rebel_like();//杀必然脱离类反状态 
	kill_used = true;//本回合使用了杀 
	if(!that.kill_respond())//响应为假，说明无闪可出 
	{
		hurt(that); 
	}
}

inline bool Pig::kill_respond()
{
	return find_and_use('D');//在手牌中寻找闪来抵消杀 
}

int Pig::try_fight()
{
	if(identity == 'M')
	{
		for(int i = num % n + 1;i != num;i = i % n + 1)
		{
			if(pig[i].dead) continue;
			if(pig[i].rebel_liked || (pig[i].identity == 'F' && pig[i].jumped))
			{
				return i;
			}
		}
	}
	else if(identity == 'Z')
	{
		for(int i = num % n + 1;i != num;i = i % n + 1)
		{
			if(pig[i].dead) continue;
			if(pig[i].identity == 'F' && pig[i].jumped)
			{
				return i;
			}
		}
	}
	else//反猪必然对主猪决斗 
	{
		return main_pig;
	}
	return 0;
}

void Pig::fight(Pig &that)
{
	jump();
	ungo_rebel_like();
	if(first_watertight_ask(that)) return;//为对方询问无懈可击 
	if(identity == 'M' && that.identity == 'Z')//主猪决斗忠猪，忠猪必然放弃 
	{
		hurt(that);
		return;
	}
	int hurted;//记录被杀者 
	while(1)//直到一方无杀才跳出循环 
	{
		if(!that.find_and_use('K'))
		{
			hurted = 2;
			break;
		}
		if(!find_and_use('K'))
		{
			hurted = 1;
			break;
		}
	}
	if(hurted == 1)
	{
		that.hurt(*this);
	}
	else
	{
		hurt(that);
	}
}

void Pig::invasion()
{
	for(int i = num % n + 1;i != num;i = i % n + 1)
	{
		if(pig[i].dead) continue;
		if(debug) cout<<"invasion->"<<i<<endl;
		if(first_watertight_ask(pig[i])) continue;
		if(!pig[i].invasion_respond())
		{
			hurt(pig[i]);
			if(gameover) return;
			if(pig[i].identity == 'M' && !jumped)//类反猪判定 
			{
				go_rebel_like();
			}
		}
	}
}

inline bool Pig::invasion_respond()
{
	return find_and_use('K');
}

void Pig::arrows()
{
	for(int i = num % n + 1;i != num;i = i % n + 1)
	{
		if(pig[i].dead) continue;
		if(debug) cout<<"arrows->"<<i<<endl;
		if(first_watertight_ask(pig[i])) continue;
		if(!pig[i].arrows_respond())
		{
			hurt(pig[i]);
			if(gameover) return;
			if(pig[i].identity == 'M' && !jumped)
			{
				go_rebel_like();
			}
		}
	}
}

inline bool Pig::arrows_respond()
{
	return find_and_use('D');
}

inline void Pig::crossbow()
{
	equipped = true;
}

bool Pig::first_watertight_ask(Pig &that)
{
	if(!that.jumped) return false;//无猪（注意：包括它自己）为未跳者进行无懈可击 
	bool flag = true;
	for(int i = num;i != num || flag;i = i % n + 1)
	{ 
		flag = false;
		if(pig[i].dead) continue;
		if(that.identity == 'M' && pig[i].identity == 'F') continue;
		if(that.identity == 'Z' && pig[i].identity == 'F') continue;
		if(that.identity == 'F' && pig[i].identity == 'Z') continue;
		if(that.identity == 'F' && pig[i].identity == 'M') continue;//寻找同势力 
		if(pig[i].find_and_use('J'))
		{
			pig[i].jump();
			return !pig[i].against_watertight_ask();//对抗开始 
		}
	}
	return false;
}

bool Pig::against_watertight_ask()
{
	for(int i = num % n + 1;i != num;i = i % n + 1)
	{
		if(pig[i].dead) continue;
		if(identity == 'M' && pig[i].identity == 'Z') continue;
		if(identity == 'Z' && pig[i].identity == 'Z') continue;
		if(identity == 'F' && pig[i].identity == 'F') continue;
		if(identity == 'Z' && pig[i].identity == 'M') continue;//寻找异势力 
		if(pig[i].find_and_use('J'))
		{
			pig[i].jump();
			return !pig[i].against_watertight_ask();
		}
	}
	return false;
}
```

---

## 作者：Macesuted (赞：58)

## [Pig Country Kill](https://www.luogu.com.cn/problem/P2482)

很古怪的翻译，不过它确实叫猪(Pig)国(Country)杀(Kill)。

我们来好好整理一下这道题目。题面虽较长，但内容基本清晰，只是有部分很Pig的操作部分，很容易让第一次看见这道题目的人百思不得其解。

先整理一下这道长长的题面。

------

### First：人物

四位玩家，初始四张手牌，血量上限$4$，初始血量$4$，会告诉你整个牌堆的牌，每位玩家每个回合从**牌堆顶部**抽走两张牌，放在自己手牌的**右侧**。人物分主猪，忠猪，和反猪，主猪只有一只，反猪和忠猪可以有多只，**反猪全死主猪获胜，主猪死亡反猪获胜**。

------------

### Second：关于出牌

从主猪开始逆时针旋转，就是沿序号为$1$ $2$ $3$ $...$ $n$的顺序依次出牌。每头猪在出牌的时候都会从左往右挨个判断每张牌是否可用，将可用的牌直接用掉。牌分为$P$(桃)，$K$(杀)，$D$(闪)和锦囊牌$F$(决斗)，$N$(南猪入侵)，$W$(万箭齐发)，$J$(无懈可击)和装备牌$Z$(猪哥连弩)。具体操作会在下面贴代码的地方说明。

------------

### Third：猪的特性

有南猪入侵和万箭齐发一定用，有桃且生命值没满一定吃，有猪哥连弩一定装，受到杀，南猪入侵，万箭齐发可以用闪，杀，闪抵消一定抵消。

------------

### Forth：高级操作

跳忠和跳反，即表明自己是忠猪或是反猪，主猪开局直接跳，忠猪只会跳忠，反猪只会跳反。已经跳（后面我们将跳忠和跳反统称为跳，因为忠猪不会跳反，反猪不会跳忠）了的猪只会对同样跳了的同类献殷勤，同时对跳了的敌猪表敌意。跳反猪同时会对主猪表敌意，因为主猪和忠猪是统一阵营。

------------

### Fifth：献殷勤和表敌意

猪A对猪B使用了杀或是决斗，叫作猪$A$对猪$B$表敌意。猪$A$用无懈可击帮猪$B$抵挡住攻击性锦囊牌，叫作猪$A$对猪$B$献殷勤。猪$C$对猪$B$表敌意，被猪$A$用无懈可击抵挡住，叫作猪$A$对猪$B$先殷勤。猪$C$对猪$B$献殷勤，被猪$A$用无懈可击抵消，叫作猪$A$对猪$B$表敌意。

------------

### Sixth：某些猪的特性

主猪会竭力保护自己，会对跳忠猪献殷勤，对跳反猪表敌意。有“类反猪”一概念，所有对他产生伤害的猪都是“类反猪”（才有了样例中的~~美好~~结局），**主猪同时会对类反猪表敌意**；对忠猪来说，它会对跳反猪（**没有类反猪**）表敌意，**角斗时如果对方是主猪，那么不会出杀，会自愿扣血，即使自己会死**，会对主猪和已经跳忠的猪献殷勤；对反猪来说，如果能杀到主猪，一定对主猪表敌意（*决斗一定打主猪*），如果杀不到，对跳忠猪表敌意，对跳反猪一定献殷勤。

上面的情况如果可以同时有多个对象可以表敌意或献殷勤，选取逆时针找到的第一位。**且如果能献殷勤或表敌意，一定做**。

------------

### Seventh：其他

如果主猪死亡，游戏结束。如果主猪杀死了忠猪，主猪所有的手牌（包括装备）全部弃置。如果反猪全部死亡，游戏结束。反猪死亡后，杀他的猪从牌堆处摸三张牌（*即使他是反猪*）。**如果游戏结束，那么游戏直接在此时停止，接下来需要做的所有事情都被截止**。杀只能打到自己正后面的那一头猪，决斗可以随便决斗。万箭齐发和南猪入侵对除自己以外的所有人顺时针使用。无懈可击可以对任何人使用，无懈可击可以使无懈可击无效，可以使决斗报废（**不使任何一方受到伤害**）。大部分手牌无法在非自己的回合使用，在自己濒死时（血量为$0$）可以使用桃（**自己的**），在自己的献殷勤对象被表敌意时可以出无懈可击，在自己的表敌意对象被献殷勤时可以出无懈可击。**注意有的猪死去后会使一些猪之间的距离产生变化**。

游戏内容差不多就是这样了，如果看不懂，多看几遍也能理解，如果还是难以理解的话，可以往下看本人的AC代码以及解释，可以帮助你加深对本题的理解。

------

## 代码

### 定义

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <cstdlib> 
//头文件 

using std::ios;
//用using namespace就不用这个了 

//以下定义虽复杂，但是方便在程序中梳理思路，让我们不易混淆true和false的关系 
#define CANNOT_USE_THIS_CARD      true           //不能使用这张牌 
#define CAN_USE_THIS_CARD         false          //可以使用这张牌 
#define THIS_PIG_IS_DEAD          true           //这头猪死了 
#define THIS_PIG_IS_NOT_DEAD      false          //这头猪还没死 
#define THIS_PIG_IS_JUMP          true           //这头猪已经跳了 
#define THIS_PIG_IS_NOT_JUMP      false          //这头猪还没有跳 
#define THIS_PIG_LIKE_BAD         true           //这头猪类反 
#define THIS_PIG_DO_NOT_LIKE_BAD  false          //这头猪不类反 
#define CROSSBOW_ON               true           //装备猪哥连弩 
#define CROSSBOW_DOWN             false          //没有装备猪哥连弩 
#define THIS_TURN_USED_KILL       true           //这一回合已经使用杀 
#define THIS_TURN_DO_NOT_USE_KILL false          //这一回合还没有使用过杀

struct card                                          //对每一张卡牌制造的结构体 
{
    char                    which                   ;//牌的种类
    bool                    use                     ;//牌是否已用
};

typedef std::vector<card>::iterator myit;            //这是牌堆的指针类型 

class pig                                            //对每头猪使用的类 
{
private:                                             //私有 
    int                     hp                      ;//生命值 
    bool                    use_kill                ;//这个回合
    bool                    crossbow                ;//是否有装猪哥连弩 
    bool                    jumped                  ;//是否已跳
    bool                    like_bad                ;//是否类反
    void                    die         (int)       ;//死掉了
    void                    clear       (void)      ;//清空 
    void                    del         (myit&)     ;//删除某迭代器指向的玩意
    myit                    find        (char)      ;//找某张牌
    void                    cut         (void)      ;//拿一张牌
    void                    use         (card&)     ;//用掉某张牌
    void                    hurt        (int)       ;//受到伤害
    bool                    canuse      (char)      ;//可以使用这张牌
    int                     find_K      (void)      ;//找杀的对象
    int                     find_F      (void)      ;//找人决斗
    bool                    K_respond   (void)      ;//反应杀
    bool                    N_respond   (void)      ;//反应南猪入侵
    bool                    W_respond   (void)      ;//反应万箭齐发
    bool                    ask_J       (int)       ;//询问是否出无懈可击 
    bool                    back_J      (int)       ;//反应无懈可击 
public:                                              //公共 
                            pig         (void)      ;//析构函数 
    int                     num                     ;//序号
    bool                    dead                    ;//死没死
    std::string             name                    ;//身份
    std::vector<card>       cards                   ;//手牌
    void                    myturn      (void)      ;//到我的回合了
    void                    jump        (void)      ;//跳
    void                    K           (int)       ;//杀
    void                    F           (int)       ;//决斗
    void                    N           (void)      ;//南猪入侵
    void                    W           (void)      ;//万箭齐发 
};

void gameover(std::string);//游戏结束 

int n,m;//猪头数量和牌堆深度
int FP;//反猪数量 
card stack[2005];//牌堆（之前想写栈发现不用那么做） 
pig member[15];//每头猪 
int top=1;//牌堆指针 
```

定义完毕，接下来只要对着上面的定义实现每个函数就可以了。

*虽然这里的宏定义名称非常长，但是在以下的代码中就可以将难以分辨的$true$ & $false$用易于理解的标识符代替，使下文结构更加清晰，Debug时更加方便*

-----

### 主函数

```cpp
int main()
{
    ios::sync_with_stdio(false);//流优化 
    cin>>n>>m;//输入 
    for(register int i=1;i<=n;i++)
    {
        cin>>member[i].name;//输入猪头名字 
        member[i].num=i;//猪头序号 
        if(member[i].name=="FP") FP++;//反猪数量 
        for(register int j=1;j<=4;j++)
        {
            card c;
            cin>>c.which;//每张手牌 
            c.use=CAN_USE_THIS_CARD;//可以用
            member[i].cards.push_back(c);//手牌放置
        }
    }
    for(top=1;top<=m;top++)
    {//牌堆 
        card c;
        cin>>c.which;//输入牌堆中每一张牌的信息
        c.use=CAN_USE_THIS_CARD;//可以用
        stack[top]=c;//把牌放进牌堆 
    }
    top=1;//原来想写个stack，后来废了
    int point=0;//轮到谁了
    member[1].jump();//主猪跳出来
    while(true)
    {
        point=point%n+1;//一个圈 
        if(member[point].dead==THIS_PIG_IS_DEAD) continue;//如果他死了，跳过 
        member[point].myturn();//这是他的回合 
    }
}
```

主函数结构基本清晰，处理了输入，牌堆，手牌，还有回合的问题。

打完了这些，游戏基本格局就以确定，接下来实现游戏内容。

-----

### 游戏结束处理

```cpp
void gameover(std::string who)//谁赢了 
{//死掉了 
    cout<<who<<std::endl;//输出谁赢了 
    for(register int i=1;i<=n;i++)
    {
        if(member[i].dead==THIS_PIG_IS_DEAD) cout<<"DEAD";//如果他死了
        else for(myit it=member[i].cards.begin();it!=member[i].cards.end();it++)
        {//输出他的牌
            if(it->use==CANNOT_USE_THIS_CARD) continue;//如果这张牌已经使用过，那么不存在于牌堆 
            cout<<it->which<<' ';//输出手牌的信息，然后打个空格 
        }
        cout<<std::endl;//换行 
    }
    exit(0);//结束这个程序 
}
```

---

### 死亡处理

```cpp
void pig::die(int who)
{//死了
    this->dead=THIS_PIG_IS_DEAD;//这玩意死了 
    if(this->name=="MP")//如果主猪死了 
    {
        gameover("FP");//反猪赢了 
    }
    if(this->name=="FP") FP--;//如果反猪死了，总数减减 
    if(FP==0) gameover("MP");//如果反猪死光了 
    if(this->name=="FP")//如果杀死了是反猪 
    {
        member[who].cut();//拿牌x1 
        member[who].cut();//拿牌x2 
        member[who].cut();//拿牌x3 
    }
    if(this->name=="ZP"&&member[who].name=="MP")
    {//如果主猪杀掉了忠猪
        member[who].clear();//清空 
    }
    return ;
}
```

---

### 手牌的清空、删除、寻找和拿牌等


```cpp
void pig::clear(void)
{
    this->cards.clear();//自己的手牌清空 
    this->crossbow=CROSSBOW_DOWN;//把弩卸掉 
    return ;
}

void pig::del(myit& it)
{//删除某张牌
    it->use=CANNOT_USE_THIS_CARD;//删除这个迭代器指向的牌，让它不可用
    return ;
}

myit pig::find(char which)
{//寻找某张牌
    for(myit it=this->cards.begin();it!=this->cards.end();it++)
    {//搜索每一张牌
        if(it->use==CANNOT_USE_THIS_CARD) continue;//如果用过了 
        if(it->which==which) return it;//如果这是我要找的牌 
    }
    return this->cards.end();//找不到，输出vector的end 
}

void pig::cut(void)
{
    this->cards.push_back(stack[top++]);//把牌堆上面的拿掉
    if(top>m) top=m;//好像有数据说牌不够
    return;
}

void pig::use(card& c)
{//用某张牌 
    if(c.which=='K')
    {//如果这是杀 
        int who;
        who=this->find_K();//找一个人来杀 
        if(who!=0)//如果找到了 
        {
            c.use=CANNOT_USE_THIS_CARD;//用掉 
            this->K(who);//杀它 
        }
    }
    else if(c.which=='P')
    {//如果这是桃 
        if(this->hp<4)//如果它的生命值没有满 
        {
            c.use=CANNOT_USE_THIS_CARD;//用掉 
            this->hp++;//生命值加一点 
        }
    }
    else if(c.which=='F')
    {//如果这是决斗
        int who;
        who=this->find_F();//找个人来决斗
        if(who!=0)//如果找到了
        {
            c.use=CANNOT_USE_THIS_CARD;//用掉
            this->F(who);//决斗他
        }
    }
    else if(c.which=='N')
    {//南猪入侵 
        c.use=CANNOT_USE_THIS_CARD;//用掉 
        this->N();//使用南猪入侵 
    }
    else if(c.which=='W')
    {//万箭齐发 
        c.use=CANNOT_USE_THIS_CARD;//用掉 
        this->W();//使用万箭齐发 
    }
    else if(c.which=='Z')
    {//猪哥连弩 
        c.use=CANNOT_USE_THIS_CARD;//用掉 
        this->crossbow=CROSSBOW_ON;//装上 
    }
}

void pig::hurt(int who)//谁杀的 
{
    this->hp--;//受到伤害 
    if(this->hp==0)//如果他死了
    {
        myit t=this->find('P');//找桃
        if(t==this->cards.end()) this->die(who);//找不到，死掉
        else
        {
            this->del(t);//找到了，用掉
            this->hp++;//生命值加一点 
        }
    }
}

bool pig::canuse(char c)
{//判断能否使用
    if(c=='P'&&this->hp<4) return true;//如果是桃子且生命值未满
    if((c=='K'&&this->find_K()!=0)||(c=='F'&&this->find_F()!=0)||c=='N'||c=='W'||c=='Z') return true;//如果可以用
    return false;//不然就不该用
}
```

-----

#### 以上内容理解起来都较为简单，下面的代码难度会有所提高

### 寻找'杀'的目标

对于主猪、忠猪和反猪来说，他们的目的不同，但杀的距离都相同，为$1$，对于每头猪，我们找到他后方的第一头猪（也是它唯一能杀到的一头猪），判断是否应该对它用杀，如果该用，返回这头猪的编号；如果不该用，直接结束函数，返回$0$（表示没有找到杀的猪）。

主猪要找的是跳反猪和类反猪，忠猪要找的是跳反猪，反猪要找的是跳忠猪或是主猪。


```cpp
int pig::find_K(void)
{//找个人来杀
    if(this->use_kill==THIS_TURN_USED_KILL&&this->crossbow==CROSSBOW_DOWN) return 0;//如果这回合已经用过了杀而没有装过猪哥连弩 
    if(this->name=="MP")
    {//我是主猪 
        for(register int point=this->num%n+1;point!=this->num;point=point%n+1)
        {//逆时针寻找 
            if(member[point].dead==THIS_PIG_IS_DEAD) continue;//如果死掉了，跳过去 
            if(member[point].like_bad==THIS_PIG_LIKE_BAD||(member[point].name=="FP"&&member[point].jumped==THIS_PIG_IS_JUMP))
            {//如果这猪是类反猪或是已经跳反 
                return point;//就决斗他 
            }//否则继续找 
            else return 0; 
        }
    }
    else if(this->name=="ZP")
    {//我是忠猪 
        for(register int point=this->num%n+1;point!=this->num;point=point%n+1)
        {//逆时针寻找 
            if(member[point].dead==THIS_PIG_IS_DEAD) continue;//这玩意死了，跳过去 
            if(member[point].name=="FP"&&member[point].jumped==THIS_PIG_IS_JUMP)
            {//如果这是已经跳反的猪头
                return point;//就杀他 
            }
            else return 0;
        }
    }
    else if(this->name=="FP")
    {//我是反猪 
        for(register int point=this->num%n+1;point!=this->num;point=point%n+1)
        {//逆时针寻找 
            if(member[point].dead==THIS_PIG_IS_DEAD) continue;//如果死掉了，先过去 
            if(member[point].name!="FP"&&member[point].jumped==THIS_PIG_IS_JUMP)//找到第一头猪，如果它跳忠或是是主猪 
            {
                return point;//杀他 
            }
            else
            {
                return 0;//杀不到 
            }
        }
    }
    return 0;
}
```

---

### 寻找'决斗'的目标

与'杀'类似，对于主猪、忠猪和反猪来说，他们寻找决斗目标的目的也不同，但考虑到决斗牌无距离限制，所以我们可以直接攻击游戏上存活的任何一头猪。

主猪杀的是逆时针下去的第一头跳反猪或类反猪，忠猪杀的是逆时针下去的第一头跳反猪，**反猪直接杀主猪**。

```cpp
int pig::find_F(void)
{//找一个人来决斗
    if(this->name=="MP")
    {//我是主猪 
        for(register int point=this->num%n+1;point!=this->num;point=point%n+1)
        {//逆时针寻找 
            if(member[point].dead==THIS_PIG_IS_DEAD) continue;//如果死掉了，跳过去 
            if(member[point].like_bad==THIS_PIG_LIKE_BAD||(member[point].name=="FP"&&member[point].jumped==THIS_PIG_IS_JUMP))
            {//如果这猪是类反猪或是已经跳反
                return point;//就决斗他 
            }//否则继续找 
        }
    }
    else if(this->name=="ZP")
    {//我是忠猪 
        for(register int point=this->num%n+1;point!=this->num;point=point%n+1)
        {//逆时针寻找 
            if(member[point].dead==THIS_PIG_IS_DEAD) continue;//这玩意死了，跳过去 
            if(member[point].name=="FP"&&member[point].jumped==THIS_PIG_IS_JUMP)
            {//如果这是已经跳反的猪头 
                return point;//就决斗他 
            }
        }
    }
    else if(this->name=="FP")
    {//我是反猪 
        return 1;//杀主猪 
    }
    return 0;
}
```

---

### 攻击的反应函数

任何被使用杀、南猪入侵、万箭齐发的猪都会在背后运行这些函数。

杀的反应函数寻找手牌中是否有闪，南猪入侵的反应函数寻找手牌中是否有杀，万箭齐发的反应函数寻找手牌中是否有杀。

```cpp
bool pig::K_respond(void)
{//杀的反应
    myit it=this->find('D');//找一找有没有闪 
    if(it==this->cards.end()) return false;//没有闪，反应无效 
    this->del(it);//删掉闪
    return true;//有效反应 
}

bool pig::N_respond(void)
{//回应南猪入侵
    myit it=this->find('K');//找一找杀 
    if(it==this->cards.end()) return false;//找不到 
    this->del(it);//删掉它
    return true;
}

bool pig::W_respond(void)
{//回应万箭齐发 
    myit it=this->find('D');//找闪 
    if(it==this->cards.end()) return false;//没找到 
    this->del(it);//用掉它
    return true;
}
```

---

#### **接下来重点中的重点了**

### 无懈可击

这里我们写两个递归函数，先看我们第一个函数，这个函数是被攻击性锦囊攻击的人调用的函数，形参表明谁伤害的自己，寻找逆时针（**注意从自己开始，不是从自己后面的那一位开始，因为自己如果跳了也是会保护自己的**）找到的第一头有无懈可击的同类，让它来帮你出无懈可击。

*如果这头猪还没有跳是不可以寻求帮助的*

```cpp
bool pig::ask_J(int who)//找人给我挡牌，who对我发起攻击 
{//询问无懈可击 
    bool check=true;
    if(this->jumped==THIS_PIG_IS_NOT_JUMP) return false;//如果没有跳，那就不用 
    for(register int point=who;point!=who||check==true;point=point%n+1)
    {//逆时针查询 
        if(member[point].dead==THIS_PIG_IS_DEAD) continue;//如果死掉了
        check=false;
        if(this->name!="FP"&&member[point].name=="FP") continue;//如果有敌意，不用 
        if(this->name=="FP"&&member[point].name!="FP") continue;//如果要打上，不用 
        myit it=member[point].find('J');//找找无懈可击 
        if(it!=member[point].cards.end())
        {
            member[point].del(it);//删掉这张牌 
            member[point].jump();//跳
            return !member[point].back_J(this->num);//对抗一下 
        }
    }
    return false;
}


```

考虑到上方的献殷勤可能会被表敌意给无效掉，所以才有了下面这个函数。调用过上面的函数的猪都要让帮他出牌的那头猪继续做下面的工作

内容：找到逆时针的第一头有无懈可击的敌猪，让它对自己的无懈可击出无懈可击。

其实你测过几个例子就会发现，每当主猪受到伤害后，忠猪和反猪两阵营一定有一方一张无懈可击都没有了，这是为什么？

~~真的是Pig思维啊~~

```cpp
bool pig::back_J(int to)
{//无懈可击的对抗 
    for(register int point=this->num%n+1;point!=this->num;point=point%n+1)
    {//逆时针扫描 
        if(member[point].dead==THIS_PIG_IS_DEAD) continue;//已逝者先行
        if(this->name!="FP"&&member[point].name=="ZP") continue;//如果同类，不打
        if(this->name=="FP"&&member[point].name=="FP") continue;//如果同类，不打
        if(this->name=="ZP"&&member[point].name!="FP") continue;//如果友好，不打
        myit it=member[point].find('J');//找一张无懈可击 
        if(it!=member[point].cards.end())
        {
            member[point].del(it);//用它 
            member[point].jump();//同时自己得跳
            return !member[to].ask_J(point);//再回击一下（很骚啊） 
        }
    }
    return false;
}


```

---

### 补一个构造函数

```cpp
pig::pig(void)
{
    this->hp=4;//生命值 
    this->dead=THIS_PIG_IS_NOT_DEAD;//没死 
    this->jumped=THIS_PIG_IS_NOT_JUMP;//有没有跳 
    this->crossbow=CROSSBOW_DOWN;//有没有装弩 
    this->like_bad=THIS_PIG_DO_NOT_LIKE_BAD;//是否类反 
    this->use_kill=THIS_TURN_DO_NOT_USE_KILL;//这回合没有使用过杀 
}


```

---

### 再补一个回合函数

基于本人在最上面$class$里面写的独特的从$private$到$public$的顺序，加上本人的强迫症（必须按照声明的顺序实现函数），所以下方的函数都比较~~水~~ *

这个回合函数很模拟，按照题意，摸两张牌，从左到右扫一遍手牌，对每张牌来个判断，能通过判断的牌用掉。

**注意用掉一张牌后需要从头开始再扫一遍手牌，这是为什么？**。

如果手牌是`KKKKZKK`，那么你就会知道为什么要这么做了。

```cpp
void pig::myturn(void)
{
    this->cut();//拿牌x1
    this->cut();//拿牌x2
    bool check=true;//有牌拿
    while(check) 
    {//只要不结束 
        check=false;//有没有用牌
        for(myit it=this->cards.begin();it!=this->cards.end();it++)
        {//在手牌中从左到右扫一遍
            if(it->use==CANNOT_USE_THIS_CARD) continue;//如果不能用了
            if(canuse(it->which)==false) continue;//判断一下现在能不能用
            use(*it);//用它
            if(this->dead==THIS_PIG_IS_DEAD) return;//如果这玩意死了
            it=this->cards.begin()-1;//从头开始重新扫
            check=true;//用过牌了
        }
    }
    member[this->num].use_kill=THIS_TURN_DO_NOT_USE_KILL;//重置是否用过杀
    return;
}


```

---

### 跳

考虑到忠猪只会跳忠，反猪只会跳反，所以我们只要知道这头猪的身份以及他有没有跳就可以得知它是跳忠还是跳反，所以只需要对每头猪都开一个$bool$标识表示这头猪有没有跳。

```cpp
void pig::jump(void)
{//跳 
    this->jumped=THIS_PIG_IS_JUMP;//开启标识 
    return ;
}


```

---

### 杀

嗯，**接下来的一些操作也比较重要 ,反正没有无懈可击难就对了 **

考虑到杀必然会使出杀者跳。因为杀主猪的猪一定是反猪，杀忠猪的猪也是跳反猪，杀反猪的猪一定是忠猪或是主猪。所以只要你用了杀，你就跳了。

其次，跳了之后你就可以取消类反标识了（即使你跳反了，取消了标识依旧被打）。

然后，就没有什么花头了，杀的人在前面函数中已经选定，照着打就可以了。


```cpp
void pig::K(int to)
{//杀
    if(this->use_kill==THIS_TURN_USED_KILL&&this->crossbow==false) return;//如果这回合使用过杀而没有使用猪哥连弩 
    this->jump();//必然跳 
    this->like_bad=THIS_PIG_DO_NOT_LIKE_BAD;//取消类反（即使成为跳反猪） 
    this->use_kill=THIS_TURN_USED_KILL;//用过杀了 
    if(member[to].K_respond()==false)
    {//如果对方没有对杀产生有效反应 
        member[to].hurt(this->num);//伤它一滴血 
    }
}


```

---

### 决斗

与杀相似，只要你用了决斗你就必然跳，**注意如果忠猪被主猪使用无懈可击，它会直接扛上一点伤害，然后结束决斗**。

此外还需注意记录到底是谁出的最后一张杀，决定了谁受到另一方的伤害。

```cpp
void pig::F(int to)
{//决斗
#ifdef DEBUG
	printf("%d对%d使用了决斗\n",this->num,to);
#endif 
	this->jump();//先跳再说 
	this->like_bad=THIS_PIG_DO_NOT_LIKE_BAD;//类反猪取消 
	if(member[to].ask_J(this->num)==true) return;//询问无懈可击，如果使用，跳过 
	if(this->name=="MP"&&member[to].name=="ZP")
	{//如果主猪对忠猪用 
		member[to].hurt(this->num);//忠猪受伤 
		return;
	}
	int who;//判定谁提供伤害 
	while(true)
	{
		myit t;
		t=member[to].find('K');//找杀 
		if(t==member[to].cards.end())//没找到 
		{
			who=2;//我对你产生伤害 
			break;
		}
		else member[to].del(t); //用掉这张牌 
		t=this->find('K');//从我这里找杀 
		if(t==this->cards.end())
		{
			who=1;//你对我产生伤害 
			break;
		}
		else this->del(t);//删掉这张牌 
	}
	if(who==2)
	{//你伤了我 
		member[to].hurt(this->num);//伤害函数 
	}
	if(who==1)
	{//我伤了你 
		this->hurt(to);//伤害函数 
	}
}



```

---

### 南猪入侵

然后就是南猪入侵了。从出牌者的下一位开始，逆时针旋转一周，对每个人进行无懈可击判定和南猪入侵回应判定。

```cpp
void pig::N(void)
{//南猪入侵
#ifdef DEBUG
	printf("%d使用了南猪入侵\n",this->num);
#endif 
	for(register int point=this->num%n+1;point!=this->num;point=point%n+1)
	{//逆时针查询 
		if(member[point].dead==THIS_PIG_IS_DEAD) continue;//死掉了，跳过去 
		if(member[point].ask_J(this->num)==true) continue;//看看有没有无懈可击 
		if(member[point].N_respond()==false) 
		{//判断是否反应 
			member[point].hurt(this->num);//受到伤害 
			if(member[point].name=="MP"&&this->jumped==THIS_PIG_IS_NOT_JUMP)
			{//如果主猪受到了攻击且该猪没有跳 
				this->like_bad=THIS_PIG_LIKE_BAD;//定义为类反猪 
			}
		}
	}
}



```

---

### 万箭齐发

跟南猪入侵大体相同，就是改了几个字。


```cpp
void pig::W(void)
{//万箭齐发 
#ifdef DEBUG
	printf("%d使用了万箭齐发\n",this->num);
#endif
	for(register int point=this->num%n+1;point!=this->num;point=point%n+1)
	{//逆时针搜索
		if(member[point].dead==THIS_PIG_IS_DEAD) continue;//如果死了，跳过
		if(member[point].ask_J(this->num)==true) continue;//询问是否有无懈可击
		if(member[point].W_respond()==false)//回应万箭齐发
		{
			member[point].hurt(this->num);//受到伤害
			if(member[point].name=="MP"&&this->jumped==THIS_PIG_IS_NOT_JUMP)
			{//主猪受到攻击，这头猪没有跳
				this->like_bad=THIS_PIG_LIKE_BAD;//定义为类反猪
			}
		}
	}
}



```

[本题完整代码](https://www.luogu.com.cn/blog/Kysic-Studio/code-P2482)

---

## 作者：StudyingFather (赞：41)

本文同步发表于 [Studying Father's Blog](https://studyingfather.com/archives/756)。

------------

第一次刷毒瘤模拟题，也碰了好几次壁，这里把自己 AC 此题的惨痛经历写在这里。

## Part 1 存储结构

我们用一个 pig 结构体来存储每只猪的所有信息。

```cpp
struct pig
{
 int front,next;//以链式结构存储该猪之前的猪和下一只猪
 int id;//猪的身份
        //0为主猪（MP），1为忠猪（ZP），2为反猪（FP）
 int hp;//当前生命值
 int used_card;//该猪累计摸到的牌数（不是当前手中牌数）
 int global_id;//对外展示的身份
               //0为未暴露身份，1为已经暴露身份，2为类反猪
 bool zb;//是否装备诸葛连弩
 bool alive;//是否存活
 char card[2005];//该猪摸过的所有牌
 bool is_used[2005];//对应位置的牌是否使用过
}p[15];
```

这部分其实问题不算太大，理清思路就可以搞定。

## Part 2 准备阶段

在准备阶段，首先需要读入参加游戏的猪的数量 $ n $ ，以及牌堆大小 $ m $ 。

然后，读入每只猪的身份及初始手牌，最后读入牌堆。

```cpp
void get_initial_info(int cur)//读取每只猪的身份，初始手牌，并做初始化
{
 judge_identity(cur);
 get_initial_card(cur);
 if(cur==1)p[cur].front=n;
 else p[cur].front=cur-1;
 if(cur==n)p[cur].next=1;
 else p[cur].next=cur+1;
 p[cur].alive=true;
 p[cur].hp=4;
}
```

```cpp
void judge_identity(int cur)//判断身份
{
 char s[5];
 scanf("%s",s);
 if(s[0]=='M')p[cur].id=0,p[cur].global_id=1;
 else if(s[0]=='Z')p[cur].id=1;
 else p[cur].id=2,alive_fp++;
}
```

```cpp
void get_initial_card(int cur)//读入初始牌
{
 char s[5];
 for(int i=1;i<=4;i++)
 {
  scanf("%s",s);
  p[cur].used_card++;
  p[cur].card[i]=s[0];
 }
}
```

```cpp
void get_card_queue()//读入牌堆
{
 for(int i=1;i<=m;i++)
 {
  char s[5];
  scanf("%s",s);
  que[i]=s[0];
 }
}
```

这几个模块实现难度也很低，并没有什么坑点。

唯一的问题就是牌堆事实上并不够用，这个问题后面再说。

## Part 3 游戏阶段

游戏阶段是本题的重头戏，坑点众多。下面将会详细讲述。

### Part 3.1 游戏阶段框架

框架并不算太复杂，因为绝大多数功能都被封装在函数当中实现了。

```cpp
//游戏阶段开始
while(res==-1)
 for(int i=1;i<=n;i=p[i].next)
 {
  get_card(i),get_card(i);//摸牌阶段，摸两张牌
  int use_kill_num=0;//没有装备诸葛连弩的猪一回合只能使用一张杀
  for(int j=1;j<=p[i].used_card;j++)
   if(!p[i].is_used[j])//没有使用该手牌就使用它
   {
    bool is_used=false;
    if(p[i].card[j]=='P')is_used=use_peach(i);//吃桃
    else if(p[i].card[j]=='K')//打出杀
    {
     if(use_kill_num==0||p[i].zb)is_used=use_kill(i);
     if(is_used)use_kill_num++;
    }
    else if(p[i].card[j]=='F')is_used=use_fight(i);//打出决斗
    else if(p[i].card[j]=='Z')is_used=use_zgln(i);//装备诸葛连弩
    else if(p[i].card[j]=='N')is_used=use_nzrq(i);//打出南蛮入侵
    else if(p[i].card[j]=='W')is_used=use_wjqf(i);//打出万箭齐发
    if(is_used)
    {
     if(i==1&&clear_mark)clear_mark=false;//这句话是为了避免一个小bug，下面会讲到
     else p[i].is_used[j]=true;
     j=0;//使用一张手牌可能会导致前面的手牌变为可用，因此要从头开始判断每一张牌
    }
    if(!p[i].alive)break;//如果该猪已经死亡，就结束它的阶段
    if(res!=-1)break;//一旦达成胜利条件，游戏立刻终止
   }
  if(res!=-1)break;//一旦达成胜利条件，游戏立刻终止
 }
//游戏阶段结束
```

以上代码模拟了每个回合的进行过程，几个注意事项还是有必要再说明一下：

1. 使用一张手牌可能会导致前面的手牌变为可用，因此要从头开始判断每一张牌；
2. 如果当前出牌的猪挂了，**立刻**结束它的阶段。

在接下来的部分中，我将详细介绍每个函数的功能及其注意事项。

### Part 3.2 摸牌

摸牌事实上并不算难，只需要将摸到的牌给对应的猪即可。

但有一个坑点：牌堆事实上并不够用，如果没牌的情况下，我们要一直摸**最后一张牌**。

```cpp
void get_card(int cur)//编号为cur的猪摸一张牌
{
 p[cur].card[++p[cur].used_card]=que[curc];
 if(curc!=m)curc++;//牌堆用完的时候，要一直摸最后一张牌
}
```

### Part 3.3 吃桃

这个也很容易实现，根据题意，如果生命值未满，有桃一定吃掉。

```cpp
bool use_peach(int cur)//编号为cur的猪使用一张桃
{
 if(p[cur].hp<4)//生命未满的时候就吃掉
 {
  p[cur].hp++;
  return true;
 }
 else return false;//生命满的时候就不吃桃了
}
```

### Part 3.4 装备诸葛连弩

虽然这个只需要一行，但为了美观，我们还是封装一下。

```cpp
bool use_zgln(int cur)//编号为cur的猪装备诸葛连弩
{
 p[cur].zb=true;
 return true;
}
```

### Part 3.5 打出杀/以闪来响应杀

前面几个函数都十分简单，原因在于，这些操作都是对自身的操作，而且不会暴露身份。

从这部分开始，下面的操作都会有选择目标的问题，以及可能造成的身份的暴露。

首先需要注意的是：在本题中，距离是**单向**的。因此我们在打出杀的时候，只需考虑能否对当前猪的下家使用杀即可。

第二点就是，没有诸葛连弩的猪一回合只能打出**一张**杀。

第三点，一旦一只猪打出了杀，它的身份就暴露了。

```cpp
bool use_kill(int cur)//编号为cur的猪打出一张杀
{
 if(p[cur].id==2)//反猪会对主猪和跳忠的猪打出杀
 {
  if(p[p[cur].next].global_id==1&&(p[p[cur].next].id==1||p[p[cur].next].id==0))
  {
   p[cur].global_id=1;//打出杀会暴露身份
   use_shan(p[cur].next);//被杀的猪响应闪
   if(p[p[cur].next].hp<=0)die(p[cur].next,cur);//濒死状态判定
   return true;
  }
 }
 else if(p[cur].id==1)//忠猪会对跳反的猪打出杀
 {
  if(p[p[cur].next].global_id==1&&p[p[cur].next].id==2)
  {
   p[cur].global_id=1;
   use_shan(p[cur].next);
   if(p[p[cur].next].hp<=0)die(p[cur].next,cur);
   return true;
  }
 }
 else //主猪会对跳反的猪或类反猪打出杀
 {
  if((p[p[cur].next].global_id==2)||(p[p[cur].next].global_id==1&&p[p[cur].next].id==2))
  {
   use_shan(p[cur].next);
   if(p[p[cur].next].hp<=0)die(p[cur].next,cur);
   return true;
  }
 }
 return false;//没有可以打出杀的对象
}
```

以闪来响应杀的过程就简单多了。只需寻找是否有闪，并弃置闪即可。

```cpp
void use_shan(int cur)//编号为cur的猪需要打出一张闪来响应杀
{
 bool used_shan=false;
 for(int i=1;i<=p[cur].used_card;i++)
  if(p[cur].card[i]=='D'&&p[cur].is_used[i]==false)
  {
   used_shan=true;
   p[cur].is_used[i]=true;
   break;
  }
 if(!used_shan)p[cur].hp--;//没有闪时要掉血
}
```

### Part 3.6 打出南蛮入侵/万箭齐发

这两个锦囊牌几乎相同，所以这里就放一起讲了。

需要注意的是：打出这两张锦囊牌并不会直接暴露自己的身份，但之前没有跳忠/跳反的猪，有可能在打出这两张锦囊牌之后会被主猪判断为类反猪。而已经跳忠/跳反的猪，它们再对主公造成伤害时，不会被判定为类反猪。

这里的几个坑点：

1. 无懈可击只会免除对**一个目标**的锦囊效果，并不会使整个锦囊失效；
2. 在结算南蛮入侵/万箭齐发的时候，一旦游戏结束条件达成，就**立刻终止**锦囊结算过程。

```cpp
//这里只给出南蛮入侵的实现，万箭齐发的实现略去
bool use_nzrq(int cur)//编号为cur的猪打出南蛮入侵
{
 for(int i=p[cur].next;i!=cur;i=p[i].next)
 {
  bool used_kill=false;
  if(p[i].global_id==1)//只有暴露身份的猪才有其他猪对它使用无懈可击，原因见下文
   if(use_wxkj(cur,p[i].id==0?1:p[i].id))continue;
  //需要注意，无懈可击只会免除对一个目标的锦囊效果，并不会使整个锦囊失效
  for(int j=1;j<=p[i].used_card;j++)
   if(p[i].card[j]=='K'&&p[i].is_used[j]==false)
   {
    p[i].is_used[j]=true;
    used_kill=true;
    break;
   }
  if(!used_kill)
  {
   p[i].hp--;
   if(p[i].hp<=0)die(i,cur);
   if(i==1&&p[cur].global_id==0)p[cur].global_id=2;
   //没暴露身份，且对主猪造成伤害的猪会被判断为类反猪
   if(res!=-1)return true;//一旦游戏结束条件达成，立刻终止锦囊结算过程
  }
 }
 return true;
}
```

### Part 3.7 决斗

关于寻找决斗目标，坑点也不少：一旦找到决斗目标，该锦囊就立刻被使用（即使该锦囊被无懈，也不能找下一个目标）。

```cpp
bool use_fight(int cur)//编号为cur的猪打出一张决斗
{
 if(p[cur].id==2)//反猪决斗时总是找主猪
 {
  p[cur].global_id=1;
  bool flag=use_wxkj(cur,1);
  if(!flag)battle(cur,1);//执行决斗过程
  return true;//无论该锦囊是否被无懈，该锦囊都已经被打出
 }
 else if(p[cur].id==1)
 {
  for(int i=p[cur].next;i!=cur;i=p[i].next)
   if(p[i].global_id==1&&p[i].id==2)//忠猪找跳反的猪决斗
   {
    p[cur].global_id=1;
    bool flag=false;
    if(p[i].global_id==1)flag=use_wxkj(cur,2);
    if(!flag)battle(cur,i);
    return true;
   }
 }
 else
 {
  for(int i=p[cur].next;i!=cur;i=p[i].next)
   if((p[i].global_id==1&&p[i].id==2)||p[i].global_id==2)//主猪找跳反的猪和类反猪
   {
    bool flag=false;
    if(p[i].global_id==1)flag=use_wxkj(cur,2);
    if(!flag)battle(1,i);
    return true;
   }
 }
 return false;//没有目标可以进行决斗
}
```

执行决斗过程时，需要注意：

1. 决斗的伤害来源是**没有受到伤害的一方**。
2. 忠猪在与主猪进行决斗时，**必定**掉血（于是忠猪就白白成为了主猪的牺牲品）。

```cpp
void battle(int attacker,int defender)//执行决斗过程
{
 if(attacker==1&&p[defender].id==1)//忠猪在与主猪决斗时，必定掉血
 {
  p[defender].hp--;
  if(p[defender].hp<=0)die(defender,attacker);
  return;
 }
 int curp=defender;
 while(1)
 {
  bool flag=false;
  for(int i=1;i<=p[curp].used_card;i++)
   if(p[curp].card[i]=='K'&&p[curp].is_used[i]==false)
   {
    p[curp].is_used[i]=true;
    flag=true;
    break;
   }
  if(flag)curp=(curp==defender?attacker:defender);//轮到对方弃置杀
  else
  {
   p[curp].hp--;
   if(p[curp].hp<=0)die(curp,attacker==curp?defender:attacker);//没有受到伤害的一方为伤害来源
   return;
  }
 }
}
```

### Part 3.8 濒死结算

在看下面的内容之前，请认真阅读下面这句话至少三遍：

> 注意，一旦达成胜利条件，游戏**立刻**结束，因此即使会摸3张牌或者还有牌可以用也不用执行了。

这意味着，以下几种情况都是不该发生的：

1. 把最后一只反猪杀死后，杀死反猪的猪先摸 3 张牌，然后结束游戏。
2. 在游戏胜利条件达成后，未完成结算的锦囊继续进行结算，又让几只猪挂掉。

情况 2 的应对方法刚才在讲南蛮入侵的实现时已经给出了解决方案。这里不再赘述。

现在就可以给出濒死结算的判断代码了：

```cpp
void die(int cur,int killer)//编号为cur的猪正处在濒死状态，杀手为killer
{
 for(int i=1;i<=p[cur].used_card;i++)
  if(p[cur].card[i]=='P'&&p[cur].is_used[i]==false)
  {
   p[cur].hp++;
   p[cur].is_used[i]=true;
   if(p[cur].hp>0)return;//该猪摆脱了濒死状态
  }
 p[cur].alive=false;//将该猪标记为死亡
 p[p[cur].front].next=p[cur].next;//改变出牌顺序
 p[p[cur].next].front=p[cur].front;
 if(p[cur].id==0)//主猪死亡，反猪胜利
 {
  res=1;
  return;
 }
 if(p[cur].id==2)
 {
  alive_fp--;
  if(alive_fp==0)//先判断游戏胜利条件是否达成，如果达成，就不再摸牌了
  {
   res=0;
   return;
  }
  get_card(killer),get_card(killer),get_card(killer);//杀死反猪的猪摸3张牌
 }
 else if(p[cur].id==1&&killer==1)//主猪杀死忠猪，弃置所有手牌和装备
 {
  p[1].used_card=0;//清空牌堆
  memset(p[1].card,0,sizeof(p[1].card));
  memset(p[1].is_used,false,sizeof(p[1].is_used));
  p[1].zb=false;//卸掉装备
  clear_mark=true;//防止牌打出状态被意外改变
 }
}
```

你也许会奇怪开始程序框架中的 `clear_mark` 是干什么的，现在可以给出答案了。

这其实是一个特殊的标记。

由于 mark 已经使用的牌是在牌结算完成之后（也在濒死结算之后），mark 操作会导致已经被清空的主猪牌堆中的一张不存在的牌被打上一个错误的标记。（这个小 bug 导致我本来 AC 的程序变成了 95 分）

所以，通过这个标记，我们判断主猪的标记是否被清空，如果主猪的标记已经被清空，就不要打错误的标记了。

### Part 3.9 打出无懈可击

如果你完成了上面几个部分的内容，那么恭喜你已经拿到了 30 分！

接下来就是整个程序的重头戏：无懈可击。

似乎无懈可击的使用规则很复杂？那就重新读一遍下面的内容吧！

> 献殷勤：使用无懈可击挡下南猪入侵、万箭齐发、决斗；使用无懈可击抵消表敌意；

> 表敌意：……使用无懈可击抵消献殷勤；

> 共性：……**不会**对未表明身份的猪献殷勤（**包括自己**）；

从上面这段话中，我们可以总结出以下几个规律：

1. 对于一个没有暴露身份的猪，没有猪能给它出无懈可击。（它自己也不行）
2. 因为在该问题中，所有的锦囊都会对锦囊目标造成伤害，那么假如锦囊牌的目标为 A，那么和 A 一派的猪，一定会使锦囊无效（即对 A 献殷勤）；不和 A 一派的猪，一定会使锦囊生效（即对 A 表敌意）。
3. 一只猪打出了无懈可击，就会暴露自己的身份。

似乎有了一点头绪：我们可以将出无懈可击的过程用递归实现。

怎么实现呢？设主猪一派为 1 方，反猪一派为 2 方。假如有人对 1 方的猪出了一张锦囊，那么就先由 1 方的猪出无懈可击抵销该锦囊的效果，然后由 2 方抵销1方出的无懈可击，以此类推。（反之也同理）

实现时有几个注意事项：

1. 出无懈可击的顺序是：从**使用锦囊的猪**开始，按逆时针顺序出无懈可击。（之前误以为是从锦囊的目标开始，结果错的很惨）
2. 别忘了把出无懈可击的猪的身份暴露出来。

```cpp
bool use_wxkj(int cur,int sit)
//轮到编号cur的猪出无懈可击，锦囊牌的目标为sit一方（1代表主猪一方，2代表反猪一方）
{
 int curp=cur;
 do
 {
  if(p[curp].id!=2&&sit==1)
  {
   for(int i=1;i<=p[curp].used_card;i++)
    if(p[curp].card[i]=='J'&&p[curp].is_used[i]==false)
    {
     p[curp].is_used[i]=true;
     if(p[curp].global_id!=1)p[curp].global_id=1;
     return !use_wxkj(curp,2);//轮到相反一方出无懈可击
    }
  }
  if(p[curp].id==2&&sit==2)
  {
   for(int i=1;i<=p[curp].used_card;i++)
    if(p[curp].card[i]=='J'&&p[curp].is_used[i]==false)
    {
     p[curp].is_used[i]=true;
     if(p[curp].global_id!=1)p[curp].global_id=1;
     return !use_wxkj(curp,1);
    }
  }
  curp=p[curp].next;
 }while(curp!=cur);
 return false;
}
```

## Part 4 输出结果阶段

如果你看完了前面这一大段内容，这剩下的内容就简单多了。

```cpp
//输出结果阶段开始
if(res==0)puts("MP");
else puts("FP");
for(int i=1;i<=n;i++)
{
 if(!p[i].alive)
 {
  puts("DEAD");
  continue;
 }
 for(int j=1;j<=p[i].used_card;j++)
  if(!p[i].is_used[j])printf("%c ",p[i].card[j]);
 puts("");
}
//输出结果阶段结束
```

## 完整代码

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
struct pig
{
 int front,next;//以链式结构存储该猪之前的猪和下一只猪
 int id;//猪的身份
        //0为主猪（MP），1为忠猪（ZP），2为反猪（FP）
 int hp;//当前生命值
 int used_card;//该猪累计摸到的牌数（不是当前手中牌数）
 int global_id;//对外展示的身份
               //0为未暴露身份，1为已经暴露身份，2为类反猪
 bool zb;//是否装备诸葛连弩
 bool alive;//是否存活
 char card[2005];//该猪摸过的所有牌
 bool is_used[2005];//对应位置的牌是否使用过
}p[15];
int n,m,curc=1;//curc：牌堆顶端位置
int alive_fp;//存活猪的数量
int res=-1;//游戏结果
           //-1：游戏未结束，0：主猪胜，1：反猪胜
char que[2005];//card queue(a.k.a. pai dui)
bool clear_mark;//主猪牌堆清空标记（防止意外标记）
void judge_identity(int cur)//判断身份
{
 char s[5];
 scanf("%s",s);
 if(s[0]=='M')p[cur].id=0,p[cur].global_id=1;
 else if(s[0]=='Z')p[cur].id=1;
 else p[cur].id=2,alive_fp++;
}
void get_initial_card(int cur)//读入初始牌
{
 char s[5];
 for(int i=1;i<=4;i++)
 {
  scanf("%s",s);
  p[cur].used_card++;
  p[cur].card[i]=s[0];
 }
}
void get_card(int cur)//编号为cur的猪摸一张牌
{
 p[cur].card[++p[cur].used_card]=que[curc];
 if(curc!=m)curc++;//牌堆用完的时候，要一直摸最后一张牌
}
void die(int cur,int killer)//编号为cur的猪正处在濒死状态，杀手为killer
{
 for(int i=1;i<=p[cur].used_card;i++)
  if(p[cur].card[i]=='P'&&p[cur].is_used[i]==false)
  {
   p[cur].hp++;
   p[cur].is_used[i]=true;
   if(p[cur].hp>0)return;//该猪摆脱了濒死状态
  }
 p[cur].alive=false;//将该猪标记为死亡
 p[p[cur].front].next=p[cur].next;//改变出牌顺序
 p[p[cur].next].front=p[cur].front;
 if(p[cur].id==0)//主猪死亡，反猪胜利
 {
  res=1;
  return;
 }
 if(p[cur].id==2)
 {
  alive_fp--;
  if(alive_fp==0)//先判断游戏胜利条件是否达成，如果达成，就不再摸牌了
  {
   res=0;
   return;
  }
  get_card(killer),get_card(killer),get_card(killer);//杀死反猪的猪摸3张牌
 }
 else if(p[cur].id==1&&killer==1)//主猪杀死忠猪，弃置所有手牌和装备
 {
  p[1].used_card=0;//清空牌堆
  memset(p[1].card,0,sizeof(p[1].card));
  memset(p[1].is_used,false,sizeof(p[1].is_used));
  p[1].zb=false;//卸掉装备
  clear_mark=true;//防止牌打出状态被意外改变
 }
}
bool use_peach(int cur)//编号为cur的猪使用一张桃
{
 if(p[cur].hp<4)//生命未满的时候就吃掉
 {
  p[cur].hp++;
  return true;
 }
 else return false;//生命满的时候就不吃桃了
}
bool use_wxkj(int cur,int sit)
//轮到编号cur的猪出无懈可击，锦囊牌的目标为sit一方（1代表主猪一方，2代表反猪一方）
{
 int curp=cur;
 do
 {
  if(p[curp].id!=2&&sit==1)
  {
   for(int i=1;i<=p[curp].used_card;i++)
    if(p[curp].card[i]=='J'&&p[curp].is_used[i]==false)
    {
     p[curp].is_used[i]=true;
     if(p[curp].global_id!=1)p[curp].global_id=1;
     return !use_wxkj(curp,2);//轮到相反一方出无懈可击
    }
  }
  if(p[curp].id==2&&sit==2)
  {
   for(int i=1;i<=p[curp].used_card;i++)
    if(p[curp].card[i]=='J'&&p[curp].is_used[i]==false)
    {
     p[curp].is_used[i]=true;
     if(p[curp].global_id!=1)p[curp].global_id=1;
     return !use_wxkj(curp,1);
    }
  }
  curp=p[curp].next;
 }while(curp!=cur);
 return false;
}
void use_shan(int cur)//编号为cur的猪需要打出一张闪来响应杀
{
 bool used_shan=false;
 for(int i=1;i<=p[cur].used_card;i++)
  if(p[cur].card[i]=='D'&&p[cur].is_used[i]==false)
  {
   used_shan=true;
   p[cur].is_used[i]=true;
   break;
  }
 if(!used_shan)p[cur].hp--;//没有闪时要掉血
}
bool use_kill(int cur)//编号为cur的猪打出一张杀
{
 if(p[cur].id==2)//反猪会对主猪和跳忠的猪打出杀
 {
  if(p[p[cur].next].global_id==1&&(p[p[cur].next].id==1||p[p[cur].next].id==0))
  {
   p[cur].global_id=1;
   use_shan(p[cur].next);//被杀的猪响应闪
   if(p[p[cur].next].hp<=0)die(p[cur].next,cur);//濒死状态判定
   return true;
  }
 }
 else if(p[cur].id==1)//忠猪会对跳反的猪打出杀
 {
  if(p[p[cur].next].global_id==1&&p[p[cur].next].id==2)
  {
   p[cur].global_id=1;
   use_shan(p[cur].next);
   if(p[p[cur].next].hp<=0)die(p[cur].next,cur);
   return true;
  }
 }
 else //主猪会对跳反的猪或类反猪打出杀
 {
  if((p[p[cur].next].global_id==2)||(p[p[cur].next].global_id==1&&p[p[cur].next].id==2))
  {
   use_shan(p[cur].next);
   if(p[p[cur].next].hp<=0)die(p[cur].next,cur);
   return true;
  }
 }
 return false;//没有可以打出杀的对象
}
void battle(int attacker,int defender)//执行决斗过程
{
 if(attacker==1&&p[defender].id==1)//忠猪在与主猪决斗时，必定掉血
 {
  p[defender].hp--;
  if(p[defender].hp<=0)die(defender,attacker);
  return;
 }
 int curp=defender;
 while(1)
 {
  bool flag=false;
  for(int i=1;i<=p[curp].used_card;i++)
   if(p[curp].card[i]=='K'&&p[curp].is_used[i]==false)
   {
    p[curp].is_used[i]=true;
    flag=true;
    break;
   }
  if(flag)curp=(curp==defender?attacker:defender);//轮到对方弃置杀
  else
  {
   p[curp].hp--;
   if(p[curp].hp<=0)die(curp,attacker==curp?defender:attacker);//没有受到伤害的一方为伤害来源
   return;
  }
 }
}
bool use_fight(int cur)//编号为cur的猪打出一张决斗
{
 if(p[cur].id==2)//反猪决斗时总是找主猪
 {
  p[cur].global_id=1;
  bool flag=use_wxkj(cur,1);
  if(!flag)battle(cur,1);//执行决斗过程
  return true;//无论该锦囊是否被无懈，该锦囊都已经被打出
 }
 else if(p[cur].id==1)
 {
  for(int i=p[cur].next;i!=cur;i=p[i].next)
   if(p[i].global_id==1&&p[i].id==2)//忠猪找跳反的猪决斗
   {
    p[cur].global_id=1;
    bool flag=false;
    if(p[i].global_id==1)flag=use_wxkj(cur,2);
    if(!flag)battle(cur,i);
    return true;
   }
 }
 else
 {
  for(int i=p[cur].next;i!=cur;i=p[i].next)
   if((p[i].global_id==1&&p[i].id==2)||p[i].global_id==2)//主猪找跳反的猪和类反猪
   {
    bool flag=false;
    if(p[i].global_id==1)flag=use_wxkj(cur,2);
    if(!flag)battle(1,i);
    return true;
   }
 }
 return false;//没有目标可以进行决斗
}
bool use_zgln(int cur)//编号为cur的猪装备诸葛连弩
{
 p[cur].zb=true;
 return true;
}
bool use_nzrq(int cur)//编号为cur的猪打出南蛮入侵
{
 for(int i=p[cur].next;i!=cur;i=p[i].next)
 {
  bool used_kill=false;
  if(p[i].global_id==1)//只有暴露身份的猪才有其他猪对它使用无懈可击
   if(use_wxkj(cur,p[i].id==0?1:p[i].id))continue;
  //需要注意，无懈可击只会免除对一个目标的锦囊效果，并不会使整个锦囊失效
  for(int j=1;j<=p[i].used_card;j++)
   if(p[i].card[j]=='K'&&p[i].is_used[j]==false)
   {
    p[i].is_used[j]=true;
    used_kill=true;
    break;
   }
  if(!used_kill)
  {
   p[i].hp--;
   if(p[i].hp<=0)die(i,cur);
   if(i==1&&p[cur].global_id==0)p[cur].global_id=2;
   //没暴露身份，且对主猪造成伤害的猪会被判断为类反猪
   if(res!=-1)return true;//一旦游戏结束条件达成，立刻终止锦囊结算过程
  }
 }
 return true;
}
bool use_wjqf(int cur)
{
 for(int i=p[cur].next;i!=cur;i=p[i].next)
 {
  bool used_kill=false;
  if(p[i].global_id==1)
   if(use_wxkj(cur,p[i].id==0?1:p[i].id))continue;
  for(int j=1;j<=p[i].used_card;j++)
   if(p[i].card[j]=='D'&&p[i].is_used[j]==false)
   {
    p[i].is_used[j]=true;
    used_kill=true;
    break;
   }
  if(!used_kill)
  {
   p[i].hp--;
   if(p[i].hp<=0)die(i,cur);
   if(i==1&&p[cur].global_id==0)p[cur].global_id=2;
   if(res!=-1)return true;
  }
 }
 return true;
}
void get_initial_info(int cur)//读取每只猪的身份，初始手牌，并做初始化
{
 judge_identity(cur);
 get_initial_card(cur);
 if(cur==1)p[cur].front=n;
 else p[cur].front=cur-1;
 if(cur==n)p[cur].next=1;
 else p[cur].next=cur+1;
 p[cur].alive=true;
 p[cur].hp=4;
}
void get_card_queue()//读入牌堆
{
 for(int i=1;i<=m;i++)
 {
  char s[5];
  scanf("%s",s);
  que[i]=s[0];
 }
}
int main()
{
 //准备阶段开始
 scanf("%d%d",&n,&m);
 for(int i=1;i<=n;i++)
  get_initial_info(i);
 get_card_queue();
 //准备阶段结束
 //游戏阶段开始
 while(res==-1)
  for(int i=1;i<=n;i=p[i].next)
  {
   get_card(i),get_card(i);//摸牌阶段，摸两张牌
   int use_kill_num=0;
   //没有装备诸葛连弩的猪一回合只能使用一张杀
   for(int j=1;j<=p[i].used_card;j++)
    if(!p[i].is_used[j])//没有使用该手牌就使用它
    {
     bool is_used=false;
     if(p[i].card[j]=='P')is_used=use_peach(i);//吃桃
     else if(p[i].card[j]=='K')//使用杀
     {
      if(use_kill_num==0||p[i].zb)is_used=use_kill(i);
      if(is_used)use_kill_num++;
     }
     else if(p[i].card[j]=='F')is_used=use_fight(i);//打出决斗
     else if(p[i].card[j]=='Z')is_used=use_zgln(i);//装备诸葛连弩
     else if(p[i].card[j]=='N')is_used=use_nzrq(i);//打出南蛮入侵
     else if(p[i].card[j]=='W')is_used=use_wjqf(i);//打出万箭齐发
     if(is_used)
     {
      if(i==1&&clear_mark)clear_mark=false;//这句话是为了避免一个小bug
	  else p[i].is_used[j]=true;
      j=0;//使用一张手牌可能会导致前面的手牌变为可用，因此要从头开始判断每一张牌
     }
     if(!p[i].alive)break;//如果该猪已经死亡，就结束它的阶段
     if(res!=-1)break;//一旦达成胜利条件，游戏立刻终止
    }
   if(res!=-1)break;//一旦达成胜利条件，游戏立刻终止
  }
 //游戏阶段结束
 //输出结果阶段开始
 if(res==0)puts("MP");
 else puts("FP");
 for(int i=1;i<=n;i++)
 {
  if(!p[i].alive)
  {
   puts("DEAD");
   continue;
  }
  for(int j=1;j<=p[i].used_card;j++)
   if(!p[i].is_used[j])printf("%c ",p[i].card[j]);
  puts("");
 }
 //输出结果阶段结束
 return 0;
}
```

## 后记

为什么突然要想到刷这么大一道模拟题呢？其实是在 NOIp2018 原地爆炸之后突然兴起的一个毒瘤想法（？）。

11 月 13 号就开始打这道题，打了一个星期，绝大多数功能都实现的差不多了（然而这部分内容也就是 10pts 的部分…），由于新的训练计划的到来，A 掉这道毒瘤题的计划，就暂时咕咕了。（结果咕了整整一个月）

前几天重新把这题拾起来，把剩下的部分实现之后，就是漫长的调试过程。

第一次编译的时候，跳出来一堆错误信息（重构函数的时候忘了改调用）。好不容易排除了编译错误之后，样例（意料之中）挂了。

于是开始单步跟踪每只猪的状态，这个时候多亏之前有人留下的 [模拟器](https://www.luogu.org/discuss/show/81283)，让调试过程方便了许多。

就这样把一个接一个的 bug 翻出来，提交的分数从刚开始的 5 分，到最后的 100 分（中间还有两次提交忘了删文件 IO），真是艰难的历程。（[提交记录戳这里](https://www.luogu.org/recordnew/lists?uid=22030&pid=P2482)）

这题虽然极其毒瘤，但对于代码能力提升的帮助，也是很大的。

---

## 作者：学无止境 (赞：33)

~~这是一道无比水的模拟题%%~~

** NOI/NOI+/CTSC** 的难度标签告诉我们，模拟的路不好走啊~~
# 注意 ！#

1.反猪是FP，不是AP，题目描述错误（不过样例是对的）

2.亲测，猪的数量为**2≤n≤10**，数据范围有误（现在已经更改）

3.逆时针是编号从**1,2,3...n,1...**的顺序

3.关于决斗我们要注意

（1）反猪决斗对象一直是主猪

（2）决斗不限制距离，所以查找对象时不能只找下一头

（3）主猪找忠猪决斗，忠猪一定掉血

（4）使用决斗的猪可能自己死亡，此时它的回合必须立即结束

4.无懈可击的响应顺序是**从使用这张锦囊的猪开始，按照逆时针顺序**，依次得到使用无懈可击的机会

5.使用杀，决斗，无懈可击意味着你跳了身份

6.除了桃，使用其他牌可能导致最左边可以使用的牌发生变化

（1）使用诸葛连弩，之前扫过的杀还能用

（2）使用锦囊牌，若他猪响应无懈可击，就跳了身份，可能导致之前的杀，决斗找到对象，变得可以使用

（3）综上述两条，每使用一张牌（除了桃），就要重新将下标回到最左边，再扫一次

7.类反猪一定只对主猪而言，且其未跳身份

8.把反猪杀死了（若游戏还未结束）要摸三张牌，主猪杀死了忠猪要弃掉全部牌，包括猪哥连弩

9.牌堆只剩一张牌时，就一直摸这张牌

10.一切执行的前提是**游戏尚未结束**，一旦达成胜利条件，游戏立刻结束，因此即使会摸3张牌或者还有牌可以用也不用执行了

11.对于下标要掌握好,使用一张牌后下标要自减（自减1或直接变成0），变成零意味着重新找最左边可以使用的牌

12.猪的死亡导致猪距离的改变 



~~注意了这些后，就是一顿乱搞了233~~

细节十分重要，要有耐心，仔细，思考清楚后再打代码。

下面贴出我的代码，为了使结构清楚，可以多使用函数，本蒟蒻代码丑，不过应该不难理解。

当然，如果你只是部分错误，还是去检查一下我刚刚说的几点，自己查错会更好哦（上面的多看几遍）

**Code：**
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
using namespace std;

struct pig
{
    int shenfen;//1是主猪  2是忠猪  3是反猪
    int life;//剩余体力，初始为4
    int first_kill;//杀 首要攻击对象,0表示不杀或杀不到 
    int first_fight;//决斗 首要攻击对象
    int num_kill;//杀 的数量 
    int num_shan;//闪 的数量 
    int num_peach;//桃 的数量
    int num_cards;//手牌数量 
    int num_wuxiekeji;//无懈可击 数量 
    int pig_before;//前一头活着的猪 
    int pig_next;//下一头活着的猪 
    int situation;//对于全局的状态  0未知 1是跳忠  2是跳反  3是类反  
    bool is_it_alive;//死了吗 
    bool is_it_zhugeliannu;//有没有猪哥连弩 
    char had_cards[2010];//手牌  从 1 开始 
}pigs[11];

int tot_cards,tot_pigs,tot_fanpigs;//卡牌总数,猪总数,存活的反猪数量
int now_top,u=1;
char card[2010]; 
int winner;//1是主猪胜利  2是反猪胜利 

void faqi_kill(int,int);//发起杀 
char getcard();//从stdin读入一张牌 
void first_in(int);//处理初始状态 
bool gameover();//游戏是否结束 
void round(int);//rank 的回合 
void faqi_kill(int,int);// 发起 杀  
void die(int);//有猪彻底死了 
char pd_getcard(); //牌堆拿牌 
void printans();//输出答案 
void faqi_fight(int,int);//发起决斗
void faqi_nanzhuruqin(int); // 发起南猪入侵 
void faqi_wanjianqifa(int); // 发起万箭齐发 
bool ask_for_wuxiekeji(int,int);//等待响应无懈可击 
void find_goal_to_fight(int);//查找决斗对象（反猪不需要） 
void find_goal_to_kill(int);//查找杀对象 
void near_die(int,int);//濒死状态处理 

void near_die(int killer,int sufferer)
{
    bool have_peach=false;
    if(pigs[sufferer].num_peach>0)
    {
        register int i;
        have_peach=true;
        for(i=1;pigs[sufferer].had_cards[i]!='P';i++);
     	for(i=i+1;i<=pigs[sufferer].num_cards;i++)
        pigs[sufferer].had_cards[i-1]=pigs[sufferer].had_cards[i];
        pigs[sufferer].num_peach--,pigs[sufferer].num_cards--,++pigs[sufferer].life;
    }    
    if(have_peach==false)
    { 
        die(sufferer);
        if(killer==1&&pigs[sufferer].shenfen==2)
        {
        	pigs[1].is_it_zhugeliannu=pigs[1].num_cards=pigs[1].num_kill=pigs[1].num_peach=pigs[1].num_shan=pigs[1].num_wuxiekeji=0;
		    memset(pigs[1].had_cards,0,sizeof(pigs[1].had_cards));
		}
        if(pigs[sufferer].shenfen==3)
        {
            for(register int j=1;j<=3;j++)
            {
                pigs[killer].had_cards[++pigs[killer].num_cards]=pd_getcard();
                if(pigs[killer].had_cards[pigs[killer].num_cards]=='K')         
                pigs[killer].num_kill++;
                else if(pigs[killer].had_cards[pigs[killer].num_cards]=='D') 
                pigs[killer].num_shan++; 
                else if(pigs[killer].had_cards[pigs[killer].num_cards]=='P')
                pigs[killer].num_peach++;
                else if(pigs[killer].had_cards[pigs[killer].num_cards]=='J')
                pigs[killer].num_wuxiekeji++;
            }
        }
    }
}
void printans()
{
    cout<<(winner==1?"MP":"FP")<<endl;
    for(register int i=1;i<=tot_pigs;i++)
    {
        if(pigs[i].is_it_alive==false)
        {
            cout<<"DEAD"<<endl;
            continue;
        }
        else if(pigs[i].num_cards>0)
        {
            for(register int j=1;j<pigs[i].num_cards;j++)
            cout<<pigs[i].had_cards[j]<<" ";
            cout<<pigs[i].had_cards[pigs[i].num_cards]<<endl;
        }
        else  cout<<endl;
    }
}

char pd_getcard()//牌堆拿牌 
{
    char c=card[now_top];
    if(now_top!=1)
	now_top--;
    return c; 
}
char getcard()//从stdin读入一张牌 
{
    char c=getchar();
    for(;c<'A'||c>'Z';c=getchar());
    return c;
} 

void first_in(int rank)
{
    char temp[2];
    scanf("%s",temp);
    if(temp[0]=='M')
    pigs[rank].shenfen=1,pigs[rank].situation=1;
    else if(temp[0]=='Z')
    pigs[rank].shenfen=2;
    else if(temp[0]=='F')
    pigs[rank].shenfen=3,pigs[rank].first_fight=1,tot_fanpigs++;   //反猪决斗永远找主猪 
    for(register int i=1;i<=4;i++)
    {
        pigs[rank].had_cards[i]=getcard();
        if(pigs[rank].had_cards[i]=='K')
        pigs[rank].num_kill++;
        else if(pigs[rank].had_cards[i]=='D')
        pigs[rank].num_shan++; 
        else if(pigs[rank].had_cards[i]=='P')
        pigs[rank].num_peach++;
        else if(pigs[rank].had_cards[i]=='J')
        pigs[rank].num_wuxiekeji++;
    }
    pigs[rank].num_cards=4,pigs[rank].life=4;
    pigs[rank].pig_before=(rank==1?tot_pigs:rank-1);
    pigs[rank].pig_next=(rank==tot_pigs?1:rank+1);
    pigs[rank].is_it_alive=true;
} 

bool gameover()
{
    if(tot_fanpigs==0)
    {
        winner=1;
        return true; 
    } 
    if(pigs[1].is_it_alive==false)
    {
        winner=2;
        return true;
    }
    return false;
}

void die(int rank)
{
    pigs[rank].is_it_alive=false;
    if(rank==1)
    winner=2,printans(),exit(0);
    if(pigs[rank].shenfen==3)
    if(--tot_fanpigs==0)
    winner=1,printans(),exit(0);
    pigs[pigs[rank].pig_before].pig_next=pigs[rank].pig_next;
    pigs[pigs[rank].pig_next].pig_before=pigs[rank].pig_before;
}

void find_goal_to_kill(int rank)  //理清打的目标 
{
    if(pigs[rank].shenfen==2)
    pigs[rank].first_kill=(pigs[pigs[rank].pig_next].situation==2?pigs[rank].pig_next:0);
    else if(pigs[rank].shenfen==1)
    pigs[rank].first_kill=(pigs[pigs[rank].pig_next].situation==2||pigs[pigs[rank].pig_next].situation==3?pigs[rank].pig_next:0);
    else if(pigs[rank].shenfen==3)
    pigs[rank].first_kill=(pigs[pigs[rank].pig_next].situation==1?pigs[rank].pig_next:0);
}

void find_goal_to_fight(int rank)
{
    for(register int i=pigs[rank].pig_next;i!=rank;i=pigs[i].pig_next)
    {
        if((rank==1&&(pigs[i].situation==2||pigs[i].situation==3))||(pigs[i].situation==2&&pigs[rank].shenfen==2))
        {
            pigs[rank].first_fight=i;
            return;
        }
    }
    pigs[rank].first_fight=0;
}
 
void round(int rank)  //rank的回合  
{                                                                             
    for(register int i=1;i<=2;i++)
    {
        pigs[rank].had_cards[++(pigs[rank].num_cards)]=pd_getcard();
        if(pigs[rank].had_cards[pigs[rank].num_cards]=='K')
        pigs[rank].num_kill++;
        else if(pigs[rank].had_cards[pigs[rank].num_cards]=='D')
        pigs[rank].num_shan++; 
        else if(pigs[rank].had_cards[pigs[rank].num_cards]=='P')
        pigs[rank].num_peach++;
        else if(pigs[rank].had_cards[pigs[rank].num_cards]=='J')
        pigs[rank].num_wuxiekeji++;
    }
    int sum_kill=0;//没有猪哥连弩就只能杀一次                                                   
    for(register int i=1;i<=pigs[rank].num_cards&&pigs[rank].num_cards>0;i++) 
    {
        if(pigs[rank].had_cards[i]=='Z')
        {
            register int j;
            for(j=i+1;j<=pigs[rank].num_cards;j++)
            pigs[rank].had_cards[j-1]=pigs[rank].had_cards[j];
            pigs[rank].num_cards--,pigs[rank].is_it_zhugeliannu=1,i=0;               
        }
        if(pigs[rank].had_cards[i]=='F')
        {
            if(pigs[rank].shenfen!=3)
            find_goal_to_fight(rank);
            if(pigs[rank].first_fight!=0)
            {
                register int j;
                for(j=i+1;j<=pigs[rank].num_cards;j++)
                pigs[rank].had_cards[j-1]=pigs[rank].had_cards[j];
                pigs[rank].num_cards--,faqi_fight(rank,pigs[rank].first_fight),i=0;
                if(pigs[rank].is_it_alive==false)   return; //重要,如果决斗死了就立即结束回合
            }
        } 
        if(pigs[rank].had_cards[i]=='K'&&(sum_kill==0||pigs[rank].is_it_zhugeliannu==1))
        {
            find_goal_to_kill(rank);
            if(pigs[rank].first_kill!=0)
            {
                register int j;
                for(j=i+1;j<=pigs[rank].num_cards;j++)
                pigs[rank].had_cards[j-1]=pigs[rank].had_cards[j];
                pigs[rank].num_cards--,pigs[rank].num_kill--;
                faqi_kill(rank,pigs[rank].first_kill),sum_kill++,i=0;
            }
        }
        if(pigs[rank].had_cards[i]=='P'&&pigs[rank].life<4)
        {
            register int j;
            for(j=i+1;j<=pigs[rank].num_cards;j++)
            pigs[rank].had_cards[j-1]=pigs[rank].had_cards[j];
            pigs[rank].num_cards--,pigs[rank].num_peach--,pigs[rank].life++,i--;
        }
        if(pigs[rank].had_cards[i]=='N')
        {
            register int j;
            for(j=i+1;j<=pigs[rank].num_cards;j++)
            pigs[rank].had_cards[j-1]=pigs[rank].had_cards[j];
            pigs[rank].num_cards--,faqi_nanzhuruqin(rank),i=0;           
        }
        if(pigs[rank].had_cards[i]=='W')
        {
            register int j;
            for(j=i+1;j<=pigs[rank].num_cards;j++)
            pigs[rank].had_cards[j-1]=pigs[rank].had_cards[j];
            pigs[rank].num_cards--,faqi_wanjianqifa(rank),i=0;            
        }
    }
}

void faqi_fight(int from,int goal)
{
    register int i,fi,gi;
    if(pigs[from].situation==0||pigs[from].situation==3)
    pigs[from].situation=(pigs[goal].situation==1?2:1);
    bool can_miss=ask_for_wuxiekeji(from,pigs[goal].situation);
    if(can_miss==true)   return;
    if(pigs[goal].shenfen==2&&from==1)  //那么掉血 
    {
        if(--pigs[goal].life<=0)
        near_die(from,goal);
        return;
    }
    i=goal;
    while(pigs[i].num_kill>0)
    {
        for(fi=1;fi<=pigs[i].num_cards&&pigs[i].had_cards[fi]!='K';fi++);
        for(register int k=fi+1;k<=pigs[i].num_cards;k++)
        pigs[i].had_cards[k-1]=pigs[i].had_cards[k];
        pigs[i].num_cards--,pigs[i].num_kill--;
        i=(i==goal?from:goal);
    }
    int failer=i,winner_in=(from==failer?goal:from);
    if(--pigs[failer].life<=0)
    near_die(winner_in,failer);
}

bool ask_for_wuxiekeji(int rank,int situation)
{
    if((situation==0)||situation==3)//未表明身份的猪与类反猪不会有猪响应无懈可击 
    return false;
    for(register int i=rank;;i=pigs[i].pig_next)
    {
        if(pigs[i].num_wuxiekeji>0)
        {
            if(situation==1&&(pigs[i].shenfen==1||pigs[i].shenfen==2))
            {
                register int j;
                for(j=1;j<=pigs[i].num_cards&&pigs[i].had_cards[j]!='J';j++);
                for(j=j+1;j<=pigs[i].num_cards;j++)
                pigs[i].had_cards[j-1]=pigs[i].had_cards[j];
                pigs[i].num_cards--,pigs[i].num_wuxiekeji--;
                if(pigs[i].situation==0||pigs[i].situation==3)
                pigs[i].situation=1;
                return !ask_for_wuxiekeji(i,2);//向相反身份求无懈可击 
            }
            else if(situation==2&&pigs[i].shenfen==3)
            {
                register int j;
                for(j=1;j<=pigs[i].num_cards&&pigs[i].had_cards[j]!='J';j++);
                for(j=j+1;j<=pigs[i].num_cards;j++)
                pigs[i].had_cards[j-1]=pigs[i].had_cards[j];
                pigs[i].num_cards--,pigs[i].num_wuxiekeji--;
                if(pigs[i].situation==0||pigs[i].situation==3)
                pigs[i].situation=2;
                return !ask_for_wuxiekeji(i,1);//向相反身份求无懈可击 
            }
        }
        if(i==pigs[rank].pig_before)//递归边界 
        return false;
    }
}

void faqi_nanzhuruqin(int from)
{
    for(register int i=pigs[from].pig_next;i!=from;i=pigs[i].pig_next)
    {
        bool can_miss=ask_for_wuxiekeji(from,pigs[i].situation);
        if(can_miss==true)   continue;
        if(pigs[i].num_kill>0)
        {
            register int j;
            for(j=1;pigs[i].had_cards[j]!='K';j++);
            for(j=j+1;j<=pigs[i].num_cards;j++)
            pigs[i].had_cards[j-1]=pigs[i].had_cards[j];
            pigs[i].num_cards--,pigs[i].num_kill--;
            can_miss=true;
        }
        if(can_miss==true)   continue;
        if(i==1&&pigs[from].situation==0)
        pigs[from].situation=3;
        if(--pigs[i].life<=0)
        near_die(from,i);
    }
}

void faqi_wanjianqifa(int from)
{
    for(register int i=pigs[from].pig_next;i!=from;i=pigs[i].pig_next)
    {
        bool can_miss=ask_for_wuxiekeji(from,pigs[i].situation);
        if(can_miss==true)   continue;
        if(pigs[i].num_shan>0)
        {
            register int j;
            for(j=1;pigs[i].had_cards[j]!='D';j++);
            for(j=j+1;j<=pigs[i].num_cards;j++)
            pigs[i].had_cards[j-1]=pigs[i].had_cards[j];
            pigs[i].num_cards--,pigs[i].num_shan--;
            can_miss=true;
        }
        if(can_miss==true)   continue;
        if(i==1&&pigs[from].situation==0)
        pigs[from].situation=3;
        if(--pigs[i].life<=0)
        near_die(from,i);
    }
}
void faqi_kill(int from,int goal)//发起 杀 
{
    register int i;
    if(pigs[from].situation==0||pigs[from].situation==3)
    pigs[from].situation=(pigs[goal].situation==1?2:1);
    if(pigs[goal].num_shan>0)
    {
        for(i=1;pigs[goal].had_cards[i]!='D';i++);
        for(i=i+1;i<=pigs[goal].num_cards;i++)
        pigs[goal].had_cards[i-1]=pigs[goal].had_cards[i];
        pigs[goal].num_shan--,pigs[goal].num_cards--;
    }
    else if(--pigs[goal].life<=0) 
    near_die(from,goal);
}

int main()
{
    cin>>tot_pigs>>tot_cards;
    now_top=tot_cards;
    for(register int i=1;i<=tot_pigs;i++)
    pigs[i].num_kill=pigs[i].num_peach=pigs[i].num_shan=pigs[i].num_wuxiekeji=0;
    for(register int i=1;i<=tot_pigs;i++)
    first_in(i); //初始化每头猪 
    for(register int i=tot_cards;i>=1;i--)
    card[i]=getcard();  //初始化牌堆                  
    while(gameover()==false)
    round(u),u=pigs[u].pig_next;
    printans();
    return 0; 
}
```




---

## 作者：火星大王 (赞：32)

# 概述
这个显然是一道大模拟
比较坑的地方是如果大牌堆没有了，就要~~人工制造~~不断返回最后一张牌

可能是我比较弱吧，我写了4天812行，在写到600多行的时候发现无法处理"无懈可击操作"还删掉了400多行~~2333~~

我的代码有很多cerr和stderr如果你想了解这些~~沙雕~~猪是如何玩的，就把注释都打开就可以了,可以~~冷静~~胡乱分析

这可能题解们中不多的几篇使用真·指针的代码，确实考验人，我就因为搞了个野指针，debug了半天~~233333~~

最后NOIP2018rp++

812行代码预警
# 代码

不要问我为什么这么沙雕的写了两个函数用来处理牌
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include<cstring>
#include<string>
#include<cctype>
#include<cstdlib>
#include<map>
#include<ctime>
#define debuglog(x) cerr<<"\tdebug:"<<#x<<endl
#define debug(x) cerr<<"\tdebug:"<<#x<<"="<<(x)<<endl
#define debugg(x,y) cerr<<"\tdebug;"<<(x)<<":"<<#y<<"="<<(y)<<endl
#define debugzu(x,a,b) 	cerr<<"\tdebug:"<<#x<<"=\n\t";for(int i=a;i<b;i++)cerr<<x[i]<<" ";fprintf(stderr,"\n");
#define debugerzu(x,a,b,c,d) 	cerr<<"\tdebug:"<<#x<<"=\n\t";for(int i=a;i<b;i++,fprintf(stderr,"\n\t"))for(int j=c;j<d;j++)cerr<<x[i][j]<<" ";fprintf(stderr,"\n");
#define START clock_t __start=clock();
#define STOP fprintf(stderr,"\n\nUse Time:%fs\n",((double)(clock()-__start)/CLOCKS_PER_SEC));
using namespace std;
#define MAXN 11
#define MAXM 2011
#define PAI_USED 0 //用过了
#define P 1 //桃
#define K 2 //杀
#define D 3 //闪
#define F 4 //决斗
#define N 5 //南猪入侵
#define W 6 //万箭齐发
#define J 7 //无懈可击
#define Z 8 //猪哥连弩
#define TYPE_UNKNOW 0//类型未知
#define	MP	1	//主猪 
#define	ZP	2	//忠猪
#define	FP	3	//反猪
#define	LZP	4	//类忠猪
#define	LFP	5	//类反猪
inline long long read()
{
	register long long x;register bool f;register char c;
	for (f=0; (c=getchar())<'0'||c>'9'; f=c=='-');
	for (x=c-'0'; (c=getchar())>='0'&&c<='9'; x=(x<<3)+(x<<1)+c-'0');
	return f?-x:x;
}
inline char readc()
{
	register char c;
	for (;((c=getchar())<'A'||c>'Z')&&(c<'a'||c>'z'););
	return c;
}
inline int readpai()
{
	switch(readc())
	{
		case 'P':
			return P;
		case 'K' :
			return K;
		case 'D':
			return D;
		case 'F' :
			return F;
		case 'N':
			return N;
		case 'W' :
			return W;
		case 'J' :
			return J;
		case 'Z' :
			return Z;				
	}
}
inline char getpai(int pai)
{
	switch(pai)
	{
		case P:
			return 'P';
		case K :
			return 'K';
		case D:
			return 'D';
		case F :
			return 'F';
		case N:
			return 'N';
		case W :
			return 'W';
		case J :
			return 'J';
		case Z :
			return 'Z';
		case PAI_USED :
			return 'U';
		default :
			return '!';
	}	
}
inline int readtype()
{
	string s;
	cin>>s;
	if(s=="MP")
		return MP;
	else if(s=="ZP")
		return ZP;
	else if(s=="FP")
		return FP;
}
inline string gettype(int x)
{
	if(x==MP)
		return "MP";
	else if(x==ZP)
		return "ZP";
	else if(x==FP)
		return "FP";
}
class pai_class
{
	private:
		int pai[MAXM];
		int head;
		int tail;
	public:
		inline int add		(int type)			{pai[tail++]=type;return tail-1;}
		inline int get		()					{return pai[head];}
		inline int count	()					{return tail-head;}
		inline int del		()					{int tmp=pai[head];if(count()>1){head++;}return tmp;}
};
pai_class all_pai;
class link_list
{
	private:
		int val;
		link_list *pro;
		link_list *nxt;
	public :
		inline	int			get			()				{return val;}
		inline	int			set			(int v)			{return val=v;}
		inline	link_list*	get_nxt		()				{return nxt;}
		inline	link_list*	get_pro		()				{return pro;}
		inline	link_list*	set_nxt		(link_list* p)	{return nxt=p;}
		inline	link_list*	set_pro		(link_list* p)	{return pro=p;}
		inline	void		del			()				{val=0;if(pro!=NULL)pro->nxt=nxt;if(nxt!=NULL)nxt->pro=pro;nxt=NULL;pro=NULL;}
};
class zhu_pai_class
{
	private:
		link_list pai[MAXM];
		int p_count,d_count,j_count;
		bool z_flag;
		link_list *now,*head,*tail;
	public :
		inline void reset_now()
		{
			now=head;
		}
		inline void reset_now_to_tail()
		{
			now=tail;
		}		
		inline void reset_tail()
		{
			tail=head;
		}
		zhu_pai_class()
		{
			p_count=d_count=j_count=0;
			z_flag=false;
			head=pai;
			reset_now();
			reset_tail();
			now->set_nxt(NULL);
			now->set_pro(NULL);
		}
		inline void add(int type)
		{
			if(type==P)					//桃子
				p_count++;
			if(type==J)					//无懈可击
				j_count++;
			if(type==D)					//闪
				d_count++;
			if(now==NULL)
				now=tail;
			now->set(type);
			now->set_nxt(now+1);
			now->get_nxt()->set_pro(now);
			now->get_nxt()->set_nxt(NULL);
			tail=now=now->get_nxt();
		}
		inline bool del(link_list * v)
		{
			if(v==NULL)
				return false;
			if(v->get()==P)
				p_count--;
			if(v->get()==J)
				j_count--;
			if(v->get()==D)
				d_count--;
			if(head==v)
			{
				head=v->get_nxt();
//				cerr<<"\treset head"<<endl;
			}
			if(now==v)
			{
				now=v->get_nxt();
//				cerr<<"\treset now"<<endl;				
			}
//			cerr<<"\t\t lose "<<getpai(v->get())<<endl;
			v->del();
			return true;
		}
		inline link_list *get_now()
		{
			return now;
		}
		inline link_list *get_nxt()
		{
			if(tail==head)
				return NULL;
			return now=now->get_nxt();
		}
		inline link_list * find_d()		//返回第一张闪
		{
			reset_now();
			link_list *tmp=get_now();
			if(tmp==NULL)
				return NULL;
			do
				if(tmp->get()==D)
					break;
			while((tmp=get_nxt())!=NULL);
			return tmp;
		}
		inline link_list * find_p()		//返回第一张桃
		{
			reset_now();
			link_list *tmp=get_now();
			if(tmp==NULL)
				return NULL;
			do
				if(tmp->get()==P)
					break;
			while((tmp=get_nxt())!=NULL);
			return tmp;
		}
		inline link_list * find_j()		//返回第一张无懈可击
		{
			reset_now();
			link_list *tmp=get_now();
			if(tmp==NULL)
				return NULL;
			do
				if(tmp->get()==J)
					break;
			while((tmp=get_nxt())!=NULL);
			return tmp;
		}
		inline bool try_use_k()			//尝试打出一张杀
		{
			reset_now();
			link_list *tmp=get_now();
			if(tmp==NULL)
				return false;			
			do
				if(tmp->get()==K)
				{
					del(tmp);
					return true;
				}
			while((tmp=get_nxt())!=NULL);
			return false;
		}
		inline bool try_use_d()			//尝试打出一张闪
		{
			if(d_count)
				return del(find_d());
			return false;
		}
		inline bool try_use_p()			//尝试打出一张桃
		{
			if(p_count)
			{
//				cerr<<"eat tao"<<endl;
				return del(find_p());
			}
			return false;
		}
		inline bool try_use_j()			//尝试打出一张无懈可击
		{
			if(j_count)
				return del(find_j());
			return false;
		}
		inline void print_all(FILE *f)
		{
			link_list *buf=now,*tmp;
			reset_now();
			tmp=now;
			if(tmp==NULL)
				return ;
			bool flag=false;
			do
			{
				if(tmp->get())
				{
					if(flag)
						fprintf(f," ");
					flag=true;
					fprintf(f,"%c",getpai(tmp->get()));
				}
			}
			while((tmp=get_nxt())!=NULL);
			fprintf(f,"\n");
			now=buf;
		}
		inline bool have_z()
		{
			return z_flag;
		}
		inline void add_z()
		{
			z_flag=true;
		}
		inline void del_all()
		{
			p_count=d_count=j_count=0;
			z_flag=false;
			reset_now();
			for(link_list *tmp=get_now(),*tmp2=tmp;tmp2;tmp2=tmp->get_nxt(),tmp->del(),tmp=tmp2);
			head=pai;
			reset_now();
			reset_tail();
			now->set(0);
			now->set_nxt(NULL);
			now->set_pro(NULL);		
		}
};
int alive_fanzei_count=0;
int alive_zhongzhu_count=0;
int n,m;
int ans;
#define UNKNOW 0
#define MPWIN 1
#define FPWIN 2
bool check_MP_alive();
void recal_all();
int in_zhuzu[MAXN];//在主猪心中类型
class pig_class;
pig_class* get_mp();
bool start_wx_circle(pig_class * start,bool y_is_fan);
class pig_class
{
	private :
		int type;//猪的类型
		int csf;//当前类型0没跳 1类反 2跳忠 3跳反
		bool alive;//活着没
		pig_class *next;
		pig_class *pro;
		pig_class *shouyao;//首要攻击目标
		pig_class *last;//最后一个伤害来源
		int id;
		int tili;
	public :
		zhu_pai_class pai;//牌
							pig_class	()				{tili=4;alive=true;type=TYPE_UNKNOW;shouyao=NULL;}
		inline	pig_class*	set_next	(pig_class *n)	{return next=n;}
		inline	pig_class*	set_pro		(pig_class *p)	{return pro=p;}
		inline	pig_class*	get_next	()				{return next;}
		inline	pig_class*	get_pro		()				{return pro;}
		inline	int			add_tili	()				{return ++tili;}
		inline	int			del_tili	()				{return --tili;}
		inline	int			get_tili	()				{return tili;}		
		inline	int			set_id		(int i)			{return id=i;}
		inline	int			get_id		()				{return id;}
		inline	int			set_type	(int i)			{if(i==FP)alive_fanzei_count++;else alive_zhongzhu_count++;return type=i;}
		inline	int			get_type	()				{return type;}
		inline	int			set_csf		(int i)			{return csf=i;}
		inline	int			get_csf		()				{return csf;}
		inline	bool		ifalive		()				{return alive;}
		void die(pig_class *from)							//料理这只猪的后事
		{
//			cerr<<"\t"<<get_id()<<" die by "<<from->get_id()<<endl;
			if(type==FP)
				alive_fanzei_count--;
			else
				alive_zhongzhu_count--;
			get_pro()->set_next(get_next());
			get_next()->set_pro(get_pro());
			alive=false;
			if(get_type()!=MP)
				if(get_type()==ZP&&from->get_type()==MP)
				{
//					cerr<<"\tMP lose all pai"<<endl;
					from->pai.del_all();
				}
			if(alive_fanzei_count<=0)
			{
				ans=MPWIN;
				return;
			}
			else if(alive_zhongzhu_count<=0)
			{
				ans=FPWIN;
				return;
			}
			else if(!check_MP_alive())//主猪死了
			{
				ans=FPWIN;
				return;
			}			
			if(get_type()==FP&&(!ans))
			{
//				last->pai.print_all(stderr);
				last->pai.reset_now_to_tail();
				last->pai.add(all_pai.del());
				last->pai.add(all_pai.del());
				last->pai.add(all_pai.del());
//				cerr<<"\t"<<last->get_id()<<" get 3 pai have";last->pai.print_all(stderr);
			}
			recal_all();
		}
		void hurt(pig_class *from)			//来自from的猪使这只猪-1s
		{
			last=from;
			if(del_tili()==0)				//快死了
				if(pai.try_use_p())			//尝试+1s
					add_tili();				//+1s
				else
				{
					die(from);				//拜拜甜甜圈
					return ;
				}
//			cerr<<"\t"<<from->get_id()<<" hurt "<<get_id()<<" tili:"<<get_tili()<<endl;
		}
		void recal()						//依据这只猪的信息更新其他猪
		{
			pig_class* y=get_next();
			if(get_type()==MP)
			{
				while(y!=this)
				{
					if(y->get_csf()==1||y->get_csf()==3)
					{
						shouyao=y;
						return ;
					}
					y=y->get_next();
				}
				shouyao=NULL;
			}
			else if(get_type()==ZP)
			{
				while(y!=this)
				{
					if(y->get_csf()==3)
					{
						shouyao=y;
						return ;
					}
					y=y->get_next();
				}
				shouyao=NULL;
			}
			else
			{
				while(y!=this)
				{
					if(y->get_csf()==2||y->get_type()==1)
					{
						shouyao=y;
						return ;
					}
					y=y->get_next();
				}
				shouyao=NULL;
			}
		}
		void round()
		{
			pai.reset_now_to_tail();
			pai.add(all_pai.del());
			pai.add(all_pai.del());		
			pai.reset_now();bool flag=false;
			bool usedsha=false;
			link_list *tmp=pai.get_now();
//			cerr<<""<<get_id()<<" have ";pai.print_all(stderr);
			while((!ans)&&(tmp=(flag?(pai.get_nxt()):(pai.get_now()))))
			{
				if(tmp==NULL)
					return;
				if(!tmp->get())
					return;
//				pai.print_all(stderr);
				flag=true;
//				cerr<<"\t"<<get_id()<<"use "<<getpai(tmp->get())<<endl;
				if(tmp->get()==D||tmp->get()==J)
					continue;
				if(get_tili()!=4&&tmp->get()==P)																//吃桃子
				{
					pai.del(tmp);
					pai.reset_now();flag=false;
					add_tili();
//					cerr<<"\t"<<get_id()<<"have "<<get_tili()<<" tili"<<endl;
					continue;
				}
				if(tmp->get()==K)																			//杀
				{
					if(shouyao==get_next()&&shouyao->ifalive())
					{
						if(!usedsha||pai.have_z())
						{
							pai.del(tmp);
							usedsha=true;
							if(get_type()!=MP&&get_csf()<2)
							{
								if(shouyao->get_type()==FP)
									set_csf(2);
								else
									set_csf(3);
								recal_all();
							}
							if(!shouyao->pai.try_use_d())
								shouyao->hurt(this);
//							else
//								cerr<<"\t"<<shouyao->get_id()<<" lose D now have ";shouyao->pai.print_all(stderr);
							pai.reset_now();flag=false;
							if(ans||(!ifalive()))
								return ;
						}
					}
				}
				if(tmp->get()==Z)
				{
					pai.del(tmp);
					pai.add_z();
					pai.reset_now();flag=false;
				}
				if(tmp->get()==F)																			//决斗
				{
					if(shouyao==NULL)																		//没有攻击目标
						continue;
//					cerr<<"shouyao="<<shouyao->get_id()<<endl;
					if(!shouyao->ifalive())
						continue;
					pai.del(tmp);
					pig_class* tmp=shouyao;					
					if(get_type()==FP)
						tmp=get_mp();
					pig_class* buf=tmp;
					if(get_type()!=MP&&get_csf()<2)
					{
						if(buf->get_type()==3)
							set_csf(2);
						else
							set_csf(3);
						recal_all();
					}
					if(buf->get_type()==1||buf->get_csf()>=2)
					{
						if(buf->get_type()==1||buf->get_csf()==2)
						{
							if(start_wx_circle(this,0))
							{
								pai.reset_now();flag=false;
								if(ans||(!ifalive()))
									return ;
								continue ;
							}
						}
						else
						{
							if(start_wx_circle(this,1))
							{
								pai.reset_now();flag=false;
								if(ans||(!ifalive()))
									return ;
								continue ;
							}
						}
					}
					if(get_type()==MP&&tmp->get_type()==ZP)
						tmp->hurt(this);
					else
					{
						while(1)
						{
							if(!tmp->pai.try_use_k())
							{
								tmp->hurt(this);
								break ;
							}
							if(!pai.try_use_k())
							{
								hurt(tmp);
								break ;
							}
						}
					}
					pai.reset_now();flag=false;
					if(ans||(!ifalive()))
						return ;
				}
				if(tmp->get()==N)																		//南猪入侵
				{
					pai.del(tmp);
					pig_class* buf=get_next();//从下一只猪开始
					while(buf!=this)//不是这个猪
					{
//						cerr<<"\t"<<buf->get_id()<<" csf="<<buf->get_csf()<<endl;
						if(buf->get_type()==MP||buf->get_csf()>=2)
						{
							if(buf->get_type()==MP||buf->get_csf()==2)
							{
								if(start_wx_circle(this,0))
								{
//									cerr<<"\t"<<buf->get_id()<<" lose J now have ";buf->pai.print_all(stderr);
									buf=buf->get_next();
									continue;
								}
							}
							else
							{
								if(start_wx_circle(this,1))
								{
//									cerr<<"\t"<<buf->get_id()<<" lose J now have ";buf->pai.print_all(stderr);
									buf=buf->get_next();
									continue;
								}
							}
						}
						if(!buf->pai.try_use_k())
						{
							buf->hurt(this);
							if(ans)
								return;
							if(buf==get_mp()&&get_csf()==0)
							{
								set_csf(1);
								recal_all();
							}
						}
						else
						{
//							cerr<<"\t"<<buf->get_id()<<" lose K now have ";buf->pai.print_all(stderr);
						}
						buf=buf->get_next();
					}
					pai.reset_now();flag=false;
					if(ans)
						return ;
					continue;
				}
				if(tmp->get()==W)																	//万箭齐发
				{
					pai.del(tmp);
					pig_class* buf=get_next();//从下一只猪开始					
					while(buf!=this)//不是这个猪
					{
//						cerr<<"\t"<<buf->get_id()<<" csf="<<buf->get_csf()<<" type="<<buf->get_type()<<endl;
						if(buf->get_type()==MP||buf->get_csf()>=2)
						{
							if(buf->get_type()==MP||buf->get_csf()==2)
							{
								if(start_wx_circle(this,0))
								{
//									cerr<<"\t"<<buf->get_id()<<" lose J now have ";buf->pai.print_all(stderr);
									buf=buf->get_next();
									continue;
								}
							}
							else
							{
								if(start_wx_circle(this,1))
								{
//									cerr<<"\t"<<buf->get_id()<<" lose J now have ";buf->pai.print_all(stderr);									
									buf=buf->get_next();
									continue;
								}
							}
						}
						if(!buf->pai.try_use_d())
						{
							buf->hurt(this);
							if(ans)
								return;
							if(buf==get_mp()&&get_csf()==0)
							{
								set_csf(1);
								recal_all();
							}
						}
						else
						{
//							cerr<<"\t"<<buf->get_id()<<" lose D now have ";buf->pai.print_all(stderr);
						}
						buf=buf->get_next();
					}
					pai.reset_now();flag=false;
					if(ans)
						return ;
				}
			}
		}
};
pig_class pig[MAXN];
void recal_all()
{
	pig_class* x=&pig[1];
	do
	{
		x->recal();
		x=x->get_next();
	}	
	while(x!=&pig[1]);
}
pig_class* get_mp()
{
	return &pig[1];
}
bool check_MP_alive()
{
	return pig[1].ifalive();
}
bool start_wx_circle(pig_class * start,bool y_is_fan)
{
	bool st=y_is_fan;
	pig_class *lastdachu=start,*x=start;
	if(y_is_fan==(x->get_type()==FP))
	{
		if(x->pai.try_use_j())
		{
			lastdachu=x;
			y_is_fan^=1;
			if(x->get_csf()<=2)
			{
//				cerr<<"\tset "<<x->get_id()<<" csf to "<<3-y_is_fan<<endl;
				x->set_csf(3-y_is_fan);
				recal_all();
			}
		}
	}
	x=x->get_next();
	while(x!=lastdachu)
	{
		if(y_is_fan==(x->get_type()==3))
		{
			if(x->pai.try_use_j())
			{
				lastdachu=x;
				y_is_fan^=1;
				if(x->get_csf()<=2)
				{
//					cerr<<"\tset "<<x->get_id()<<" csf to "<<3-y_is_fan<<endl;
					x->set_csf(3-y_is_fan);
					recal_all();
				}
			}
		}
		x=x->get_next();
	}
	return (st!=y_is_fan);
}
int main()
{
 	freopen("2482.in","r",stdin);
// 	freopen("2482.out","w",stdout);
// 	freopen("2482.err","w",stderr);
	n=read(),m=read();
	for(int i=1;i<=n;i++)
	{
		pig[i].set_id(i);
		pig[i].set_pro(&pig[i-1]);
		pig[i].set_next(&pig[i+1]);
		pig[i].set_type(readtype());
		pig[i].pai.add(readpai());
		pig[i].pai.add(readpai());
		pig[i].pai.add(readpai());
		pig[i].pai.add(readpai());
//		pig[i].pai.print_all(stderr);
	}
	pig[1].set_pro(&pig[n]);
	pig[n].set_next(&pig[1]);
	recal_all();
	for(int i=0;i<m;i++)
		all_pai.add(readpai());
	pig_class *pig_now=&pig[1];
	while(!ans)
	{
		pig_now->round();
		pig_now->pai.reset_now();
		pig_now=pig_now->get_next();
	}
	if(ans==MPWIN)
		puts("MP");
	else
		puts("FP");
	for(int i=1;i<=n;i++)
		if(!pig[i].ifalive())
			puts("DEAD");
		else
		{
//			puts("ALIVE");
			pig[i].pai.print_all(stdout);
		}
	fclose(stdin);
	fclose(stdout);
 	return 0;
}

```
# 提示与踩过的坑
几个要点提示吧

1. 先看题，最好把题背过再开始写
2. 如果可能，把你的显示器竖起来，因为这题代码是在太长了，鼠标一滚就找不着了

最难也是最重要的就是考虑所有情况，并进行操作，以及代码不要写挂

罗列一下我踩过的坑
1. 读不进来牌
2. 主猪错误干掉忠猪时清空牌没清干净
3. 各种特判细节
4. 不停使用同一张牌
5. 牌堆被错误抽空
6. 数组开小~~23333我交了好几遍才发现RE是因为这个~~
7. 改错代码~~"南猪入侵"和"万箭齐发"两段代码非常像~~
8. 在错误的时装备"猪哥连弩"

# 最后给出楼下dalao给出的小样例的答案

err是我的代码从stderr数据流输出的debug信息，可以很好地理解猪干了啥

比如在 x use N后出现了y lose K now have zzz x hurt k tili:a表示x发起南猪入侵后 y通过遗弃K避免掉血,还有zzz个牌

而k比较惨，被干了，还有a个血

k die by s是k被s干死了

对着代码就可以理解猪的前世今生,我觉得这种方法比单纯看着数据讲好理解

先给出的是样例，及答案，及err


--------
```
data:
3 10
MP D D F F
ZP N N N D
FP J J J J
F F D D J J F F K D
ans:
FP
DEAD
DEAD
J J J J J J D
err:
D D F F
N N N D
J J J J
1 have D D F F F F
	1use D
	1use D
	1use F
	1use F
	1use F
	1use F
2 have N N N D D D
	2use N
	2 hurt 3 tili:3
	2 hurt 1 tili:3
	2use N
	2 hurt 3 tili:2
	2 hurt 1 tili:2
	2use N
	2 hurt 3 tili:1
	2 hurt 1 tili:1
	2use D
	2use D
	2use D
3 have J J J J J J
	3use J
	3use J
	3use J
	3use J
	3use J
	3use J
1 have D D F F F F F F
	1use D
	1use D
	1use F
shouyao=2
	1 hurt 2 tili:3
	1use D
	1use D
	1use F
shouyao=2
	1 hurt 2 tili:2
	1use D
	1use D
	1use F
shouyao=2
	1 hurt 2 tili:1
	1use D
	1use D
	1use F
shouyao=2
	2 die by 1
	MP lose all pai
3 have J J J J J J K D
	3use J
	3use J
	3use J
	3use J
	3use J
	3use J
	3use K
	1 die by 3

```

最后给出楼下dalao给出的小样例的答案

------------

```
data:
3 4  
MP J J K N   
ZP J D K W   
FP P N P K   
J J K W 

ans:
MP
K
K
DEAD

err:
J J K N
J D K W
P N P K
1 have J J K N J J
	1use J
	1use J
	1use K
	1use N
	2 lose K now have J D W
	3 lose K now have P N P
	1use J
	1use J
	1use K
	1use J
	1use J
2 have J D W K W
	2use J
	2use D
	2use W
	2 hurt 3 tili:3
	set 2 csf to 2
	1 lose J now have J J K J J
	2use D
	2use K
	2use W
	2 hurt 3 tili:2
	set 1 csf to 2
	1 lose J now have J K J J
	2use D
	2use K
3 have P N P W W
	3use P
	3have 3 tili
	3use N
	set 1 csf to 2
	1 lose J now have K J J
	set 1 csf to 2
	2 lose J now have D K
	3use P
	3have 4 tili
	3use W
	set 1 csf to 2
	1 lose J now have K
	2 lose D now have K
	3use W
	3 hurt 1 tili:3
	3 hurt 2 tili:3
1 have K W W
	1use K
	1use W
	1 hurt 2 tili:2
	1 hurt 3 tili:3
	1use K
	1use W
	1 hurt 2 tili:1
	1 hurt 3 tili:2
	1use K
2 have K W W
	2use K
	2use W
	2 hurt 3 tili:1
	2 hurt 1 tili:2
	2use K
	2use W
	3 die by 2
```


------------

```
data:
3 1  
MP D N F K  
ZP F W F N  
FP D N N D  
K  
ans:
MP
K
F K K
DEAD
err:
D N F K
F W F N
D N N D
1 have D N F K K K
	1use D
	1use N
	1 hurt 2 tili:3
	1 hurt 3 tili:3
	1use D
	1use F
	1use K
	1use K
	1use K
2 have F W F N K K
	2use F
	2use W
	3 lose D now have N N D
	1 lose D now have F K K K
	2use F
	2use F
	2use N
	2 hurt 3 tili:2
	1 lose K now have F K K
	2use F
	2use F
	2use K
	2use K
3 have N N D K K
	3use N
	1 lose K now have F K
	2 lose K now have F F K
	3use N
	1 lose K now have F
	2 lose K now have F F
	3use D
	3use K
	3 hurt 1 tili:3
F
	3use D
	3use K
1 have F K K
	1use F
shouyao=3
	1 hurt 3 tili:1
	1use K
2 have F F K K
	2use F
shouyao=3
	3 die by 2

```


------------

```
data:
5 10  
MP W D F K   
ZP N N D D   
FP F W W K   
ZP K K N D   
FP K D P W   
J K W K D N N K J N
ans:
MP
F N
D
DEAD

DEAD
err:
W D F K
N N D D
F W W K
K K N D
K D P W
1 have W D F K J K
	1use W
	2 lose D now have N N D
	1 hurt 3 tili:3
	4 lose D now have K K N
	5 lose D now have K P W
	1use D
	1use F
	1use K
	1use J
	1use K
2 have N N D W K
	2use N
	3 lose K now have F W W
	4 lose K now have K N
	5 lose K now have P W
	set 1 csf to 2
	1 lose J now have D F K K
	2use N
	2 hurt 3 tili:2
	4 lose K now have N
	2 hurt 5 tili:3
	1 lose K now have D F K
	2use D
	2use W
	2 hurt 3 tili:1
	2 hurt 4 tili:3
	2 hurt 5 tili:2
	1 lose D now have F K
	2use D
	2use K
3 have F W W D N
	3use F
shouyao=1
	3 die by 1
F
	1 get 3 pai haveF N K J
4 have N N N
	4use N
	4 hurt 5 tili:1
	set 1 csf to 2
	1 lose J now have F N K
	2 lose K now have D
	4use N
eat tao
	4 hurt 5 tili:1
	1 lose K now have F N
	4 hurt 2 tili:3
	4use N
	5 die by 4

```


------------

```
data:
3 10  
MP W D J W   
ZP J P D N   
FP N D F F   
J D N N F J J D K W 
ans:
MP
D J D

DEAD

err:
W D J W
J P D N
N D F F
1 have W D J W J D
	1use W
	2 lose D now have J P N
	3 lose D now have N F F
	1use D
	1use J
	1use W
	1 hurt 2 tili:3
	1 hurt 3 tili:3
	1use D
	1use J
	1use J
	1use D
2 have J P N N N
	2use J
	2use P
	2have 4 tili
	2use J
	2use N
	2 hurt 3 tili:2
	set 2 csf to 2
	1 lose J now have D J J D
	2use N
	2 hurt 3 tili:1
	set 1 csf to 2
	1 lose J now have D J D
	2use N
	3 die by 2
```


------------

```
data:
3 6
MP W J J D
FP N F F K
ZP J J F F
P P K K F W
ans:
MP
P W
DEAD
DEAD

err:
W J J D
N F F K
J J F F
1 have W J J D P P
	1use W
	1 hurt 2 tili:3
	1 hurt 3 tili:3
	1use J
	1use J
	1use D
	1use P
	1use P
2 have N F F K K K
	2use N
	2 hurt 3 tili:2
	set 3 csf to 2
	1 lose J now have J J D P P
	2use F
shouyao=3
	set 3 csf to 2
	2use F
shouyao=3
	set 1 csf to 2
	2use K
	2 hurt 3 tili:1
F F
	2use K
	2use K
3 have F F F W
	3use F
shouyao=2
	3 die by 2
1 have J D P P W W
	1use J
	1use D
	1use P
	1use P
	1use W
	1 hurt 2 tili:2
	1use J
	1use D
	1use P
	1use P
	1use W
	1 hurt 2 tili:1
	1use J
	1use D
	1use P
	1use P
2 have K W W
	2use K
	1 lose D now have J P P
	2use W
	set 1 csf to 2
	1 lose J now have P P
	2use W
	2 hurt 1 tili:3
1 have P P W W
	1use P
	1have 4 tili
	1use P
	1use W
	2 die by 1

```

---

## 作者：zombie462 (赞：31)

## 猪年总得写一道和猪有关的大模拟吧

### 第一次给黑题写题解，可能写得不怎么好qwq

这道题就是大模拟，没有任何方法可言，大约$300$行左右的代码。一定要耐心，不断找出程序中的小$BUG$，然后才能解决。数据可以从$loj.ac$下载。

前面的题解已经把很多东西说得很明白了，我就来说一说我掉过的一些坑吧。

	1.决斗可以对任何猪释放，不需要相邻，反猪必定对主猪释放，其他猪对后面一只与它敌对的猪释放。
    2.无懈可击可以循环释放，最好用递归实现。
    3.要实时更新每只猪的显现身份和存活情况，遇到游戏结束及时返回。
    4.除了桃以外，其他所有的牌释放后都必须从第一张开始重新模拟，因为前面的牌可能又能够使用了。
    5.牌堆没有牌时，要不断最后一张牌。
    
下面是程序分段讲解：

### $Part0:$定义和小函数

关于每只猪的$struct$定义

```
struct player{
	int id;//真实身份
	int hp;//生命
	int cnt;//牌数
	char card[M];//牌
	int pre;//前面的那只猪
	int nxt;//后面的那只猪
	int pigid;//暴露身份
	bool special;//是否为类反猪
	bool weapon;//是否装备武器
}pig[N];
```

多用用小函数，可以使程序变得更加简洁，从而不至于达到$600-1000$行的恐怖水平。

#### $a.$打印第$i$只猪的手牌：

大家可能会把它写进主程序，因为它只会用到一次，但是在调试中这段语句可以帮你大忙。

```
void printcard(int i){
	bool first=true;
	for (int j=1;j<=pig[i].cnt;++j){
		if (pig[i].card[j]=='X') continue;
			if (!first){
				printf(" ");
			}else first=false;
		printf("%c",pig[i].card[j]);
	}
	printf("\n");
}
```

#### $b.$寻找并扣除卡牌：

找到卡牌就返回$true$并扣除，没找到就返回$false$。

```
int findcard(int x,char card){//x代表是哪头猪，card表示卡牌符号
	for (int i=1;i<=pig[x].cnt;++i){
		if (pig[x].card[i]==card){
			pig[x].card[i]='X';
			return true;
		}
	}
	return false;
}
```

#### $c.$摸牌：

这个如果不写到过程里去的话，那我很佩服你的意志。

```
void getcard(int i){
	if (top>m) top=m;//牌堆没牌了，就不断摸最上面一张
	pig[i].cnt++;
	pig[i].card[pig[i].cnt]=cards[top];
	top++;//top表示牌堆的顶部
}
```
### $Part1:$扣血的实现

这一次，我们把扣血和死亡结算放在一块运行。

我们考虑一头猪死了，如何更新整个环（链表？）继续运行下去，这就是我为什么要开设$nxt$和$pre$了，一个前导和后继可以解决所有问题。

$pig[pig[i].pre].nxt=pig[i].nxt;$它前面的猪指向它后面的猪

$pig[pig[i].nxt].pre=pig[i].pre;$它后面的猪指向它前面的猪

事实上，如果用暴力$O(n)$求解的话，也不会超时。

```
void dechp(int x,int i){//x是伤害来源者，i是伤害承受者
	pig[i].hp--;//扣血
	while (pig[i].hp<=0 && findcard(i,'P')){
		pig[i].hp++;//如果有桃赶快用
	}
	if (pig[i].hp<=0){//如果血还是没到0就回天乏术了
		pig[i].cnt=0;
		pig[i].weapon=false;//清空这个人的资料
		if (pig[i].id==1){
			gameover=true;//主猪死了游戏立刻结束
			return;
		}else if (pig[i].id==2){
			if (pig[x].id==1){//主猪杀了忠猪，按题目要求清空主猪的手牌
				pig[x].cnt=0;
				pig[x].weapon=false;//别忘了清空武器
			}
		}else if (pig[i].id==3){
			FPcnt--;//反猪的数量减1
			if (FPcnt==0){//如果已经没有反猪的话
				gameover=true;//游戏结束
				return;
			}
			getcard(x);getcard(x);getcard(x);//摸牌，记得千万不要放在上面的if语句前面
		}
		pig[pig[i].pre].nxt=pig[i].nxt;//更新前驱后继
		pig[pig[i].nxt].pre=pig[i].pre;
	}
}
```
### $Part2:$关系的实现

下面函数中，第一个表示询问$x$和$y$是不是敌人，第二个则询问两人是不是同伙，第三个表示$x$向$y$献殷勤，第四个表示$x$向$y$表敌意。

询问或变更的时候要以$x$出发，应当判断$x$的真实身份和$y$的显露身份。$y$没有显露身份则不能进行下去。

```
bool enemy(int x,int y){
	if (pig[x].id==1 && pig[y].special==true) return true;//对主猪而言，类反猪是敌人
	if (pig[y].pigid==0) return false;//y没有显露身份，返回false
	if (pig[x].id!=3 && pig[y].pigid==3) return true;//对其他猪而言，身份不符的是敌人
	if (pig[x].id==3 && pig[y].pigid!=3) return true;
	return false;
}
bool friendly(int x,int y){//同理
	if (pig[y].pigid==0) return false;
	if (pig[x].id!=3 && pig[y].pigid!=3) return true;
	if (pig[x].id==3 && pig[y].pigid==3) return true;
	return false;	
}
void getfriend(int x,int y){
	if (pig[y].pigid==0) return;//如果y没有显露身份，交朋友没有意义
	if (pig[y].pigid!=3) pig[x].special=false,pig[x].pigid=1;//否则就显露和y相同的身份，记得处理类反猪的头衔。
	if (pig[y].pigid==3) pig[x].special=true,pig[x].pigid=3;
}
void getenemy(int x,int y){//同理
	if (pig[y].pigid==0) return;
	if (pig[y].pigid!=3) pig[x].pigid=3,pig[x].special=true;
	if (pig[y].pigid==3) pig[x].pigid=1,pig[x].special=false;
}
```

### $Part3:$部分卡牌的使用

这里的部分卡牌，包括：

万箭齐发，决斗，南猪入侵，杀（闪），无懈可击

#### $a.$杀（闪）

相对于其他几部分，这一部分相对容易些。

```
void usecard_k(int from,int to){
	getenemy(from,to);//这是一种表敌意的行为
	bool p=findcard(to,'D');//尝试去目标的牌库寻找闪
	if (p==false){
		dechp(from,to);//找不到，就扣血
	}
}
```
#### $b.$决斗

决斗被无懈可击挡住的情况我们在这里暂不讨论，这里讨论的是如果$from$对$to$的决斗生效的情况。

```
void usecard_f(int from,int to){
	if (pig[from].id==1 && pig[to].id==2){//如果是主猪对忠猪下的手，忠猪不会还手
		dechp(from,to);
		return;
	}
	while (true){
		bool flag1=findcard(to,'K');//轮流在两人的牌库里寻找杀，找不到就扣血，退出。
		if (!flag1){
			dechp(from,to);
			return;
		}
		bool flag2=findcard(from,'K');
		if (!flag2){
			dechp(to,from);//如果自己出的牌害了自己，则需要把两人的攻击关系反一下
			return;
		}
	}
}
```

#### $c.$南猪入侵，万箭齐发

这两个可以放在一起讨论。

```
void usecard_n(int from,int to){//南猪入侵
	while (true){
		if (gameover) return;//永远要注意实时更新游戏是否结束
		if (!usecard_j(from,to,0)){//如果没有被无懈可击挡住的话
			bool flag=findcard(to,'K');//在牌库中寻找杀
			if (!flag){
				if (pig[to].id==1 && pig[from].pigid==0){
					pig[from].special=true;//如果是忠猪误伤了主猪，且忠猪还未表露身份，则视为类反猪
				}
				dechp(from,to);//扣血
			}
		}
		to=pig[to].nxt;	
		if (to==from) return;//一圈轮完，就退出
	}
}
void usecard_w(int from,int to){//万箭齐发
	while (true){
		if (gameover) return;
		if (!usecard_j(from,to,0)){
			bool flag=findcard(to,'D');//把这里改成D就可以了
			if (!flag){
				if (pig[to].id==1 && pig[from].pigid==0){
					pig[from].special=true;
				}
				dechp(from,to);
			}
		}
		to=pig[to].nxt;	
		if (to==from) return;
	}
}
```

#### $d.$无懈可击

这里就显得比较复杂了。我们用$from$表示锦囊牌的发出者，$to$表示锦囊牌的承受者，$last$表示上一个无懈可击的发出者。$last$初始为$0$。

```
bool usecard_j(int from,int to,int last){
	int now=from;//轮流开始出无懈可击
	while (true){
		if ((last==0 && friendly(now,to)) || (last!=0 && enemy(now,last))){//如果你和锦囊牌的承受者是朋友或者和上一张无懈可击的发出者是敌人，那么就是用无懈可击。last的值确定了是哪种情况
			if (findcard(now,'J')){//如果有无懈可击可以出
				if (last==0 && friendly(now,to)) getfriend(now,to);
				if (last!=0 && enemy(now,last)) getenemy(now,last);//朋友和敌人关系更新，因为这是献殷勤和表敌意行为
				if (!usecard_j(pig[now].nxt,to,now)){
					return true;//如果没有被其他无懈可击抵消，那么这张无懈可击就是有效的
				}
			}
		}
		now=pig[now].nxt;
		if (now==from) return false;//绕完一圈就退出
	}
}
```

### $Part4:$读入/初始化/结束部分

嗯，没错，我们先讲这个，最后再来讲如何运行整个游戏。

```
int main(){
	scanf("%d%d",&n,&m);
	for (int i=1;i<N;++i){
		for (int j=1;j<M;++j){
			pig[i].card[j]='X';//X表示这个位置是空位
		}
		pig[i].hp=4;//初始生命为4
	}
	for (int i=1;i<=n;++i){
		char names[5],s[5];
		scanf("%s",names);
		for (int j=1;j<=4;++j){
			scanf("%s",s);
			pig[i].card[j]=s[0];//依次读入4张牌
		}
		pig[i].cnt=4;
		if (names[0]=='M') pig[i].id=1,pig[i].pigid=1;//主猪的身份一开始就暴露的
		else if (names[0]=='Z') pig[i].id=2;
		else pig[i].id=3,FPcnt++;//反猪，计数器加一
		pig[i].nxt=i+1;//前驱后继的初始化
		pig[i].pre=i-1;
	}
	pig[n].nxt=1;//特殊的前驱后继，构成整个环
	pig[1].pre=n;
	for (int i=1;i<=m;++i){
		char s[5];
		scanf("%s",s);
		cards[i]=s[0];//读入牌库的牌
	}
	top=1;//指针指向牌库的第一张牌
	rungame();//运行游戏（在下一部分）
	if (pig[1].hp<=0) printf("FP\n");
	else printf("MP\n");//获胜者输出
	for (int i=1;i<=n;++i){//依次输出每个人的牌
		if (pig[i].hp<=0) printf("DEAD\n");
		else{
			printcard(i);
		}
	}
	return 0;
}
```

### $Part5:$游戏的运行

由于所有部分都已经讲完了，所以直接上代码。
```
void rungame(){
	while (true){//游戏一直运行下去	
		for (int i=1;i<=n;++i){
			if (gameover) return;//实时准备游戏结束
			if (pig[i].hp<=0) continue;//猪死了就直接跳过
			getcard(i);getcard(i);//摸牌
			bool use_k=true;//表示这头猪是否出过杀
			for (int j=1;j<=pig[i].cnt;++j){
				if (pig[i].card[j]=='X') continue;//空牌，直接跳过
				if (gameover) return;
				switch (pig[i].card[j]){
					case 'P':{
						if (pig[i].hp<4){//如果能吃桃就吃
							pig[i].card[j]='X';
							pig[i].hp++;
						}
						break;
					}
					case 'K':{
						if (use_k && enemy(i,pig[i].nxt)){//如果和后面的一只猪是敌人
							pig[i].card[j]='X';
							usecard_k(i,pig[i].nxt);//直接上
							if (!pig[i].weapon){
								use_k=false;//没有连弩的话就不能再出杀了
							}
							j=0;//从头再来，因为整个场面可能发生改变
						}
						break;	
					}
					case 'F':{//决斗，相对来说难实现一些
						if (pig[i].id==3){//如果是反猪，目标就是主猪
							pig[i].card[j]='X';
							getenemy(i,1);//和主猪表敌意
							if (usecard_j(i,1,0)) break;//如果被无懈可击挡住的话就退出
							usecard_f(i,1);
							j=0;
						}else{
							int to=pig[i].nxt;//还是逆时针循环找最近的敌对的猪
							while (true){
								if (enemy(i,to)){
								    pig[i].card[j]='X';
									getenemy(i,to);
									if (usecard_j(i,to,0)) break;
									usecard_f(i,to);
									j=0;
						  		  break;
								}
								to=pig[to].nxt;
								if (to==i) break;//转完一圈就退出
							}
						}
						break;
					}
					case 'N':{//南猪入侵和万箭齐发只要调用函数就行了
						pig[i].card[j]='X';
						usecard_n(i,pig[i].nxt);
						j=0;
                        break;
					}
					case 'W':{
						pig[i].card[j]='X';
						usecard_w(i,pig[i].nxt);
						j=0;
						break;
					}
					case 'Z':{//装备连弩
						pig[i].card[j]='X';
						pig[i].weapon=true;
						use_k=true;
						j=0;
						break;
					}
				}
				while (pig[i].card[pig[i].cnt]=='X') pig[i].cnt--;//一个优化，清掉最后没有的牌
			}
		}
	}
}
```
### $Part6:$完整代码

```
#include <bits/stdc++.h>
using namespace std;
#define N 11
#define M 2222
struct player{
	int id; 
	int hp;
	int cnt;
	char card[M];
	int pre;
	int nxt;
	int pigid;
	bool special; 
	bool weapon;
}pig[N];
int n,m;
int top;
char cards[M];
bool gameover;
int FPcnt;
void printcard(int i){
	bool first=true;
	for (int j=1;j<=pig[i].cnt;++j){
		if (pig[i].card[j]=='X') continue;
			if (!first){
				printf(" ");
			}else first=false;
		printf("%c",pig[i].card[j]);
	}
	printf("\n");
}
void getcard(int i){
	if (top>m) top=m;
	pig[i].cnt++;
	pig[i].card[pig[i].cnt]=cards[top];
	top++;
}
int findcard(int x,char card){
	for (int i=1;i<=pig[x].cnt;++i){
		if (pig[x].card[i]==card){
			pig[x].card[i]='X';
			return true;
		}
	}
	return false;
}
void getfriend(int x,int y){
	if (pig[y].pigid==0) return;
	if (pig[y].pigid!=3) pig[x].special=false,pig[x].pigid=1;
	if (pig[y].pigid==3) pig[x].special=true,pig[x].pigid=3;
}
void getenemy(int x,int y){
	if (pig[y].pigid==0) return;
	if (pig[y].pigid!=3) pig[x].pigid=3,pig[x].special=true;
	if (pig[y].pigid==3) pig[x].pigid=1,pig[x].special=false;
}
void dechp(int x,int i){
	pig[i].hp--;
	while (pig[i].hp<=0 && findcard(i,'P')){
		pig[i].hp++;
	}
	if (pig[i].hp<=0){
		pig[i].cnt=0;
		pig[i].weapon=false;
		if (pig[i].id==1){
			gameover=true;
			return;
		}else if (pig[i].id==2){
			if (pig[x].id==1){
				pig[x].cnt=0;
				pig[x].weapon=false;
			}
		}else if (pig[i].id==3){
			FPcnt--;
			if (FPcnt==0){
				gameover=true;
				return;
			}
			getcard(x);getcard(x);getcard(x);
		}
		pig[pig[i].pre].nxt=pig[i].nxt;
		pig[pig[i].nxt].pre=pig[i].pre;
	}
}
bool enemy(int x,int y){
	if (pig[x].id==1 && pig[y].special==true) return true;	
	if (pig[y].pigid==0) return false;
	if (pig[x].id!=3 && pig[y].pigid==3) return true;
	if (pig[x].id==3 && pig[y].pigid!=3) return true;
	return false;
}
bool friendly(int x,int y){
	if (pig[y].pigid==0) return false;
	if (pig[x].id!=3 && pig[y].pigid!=3) return true;
	if (pig[x].id==3 && pig[y].pigid==3) return true;
	return false;	
}

bool usecard_j(int from,int to,int last){
	int now=from;
	while (true){
		if ((last==0 && friendly(now,to)) || (last!=0 && enemy(now,last))){
			if (findcard(now,'J')){
				if (last==0 && friendly(now,to)) getfriend(now,to);
				if (last!=0 && enemy(now,last)) getenemy(now,last);
				if (!usecard_j(pig[now].nxt,to,now)){
					return true;
				}
			}
		}
		now=pig[now].nxt;
		if (now==from) return false;
	}
}
void usecard_k(int from,int to){
	getenemy(from,to);
	bool p=findcard(to,'D');
	if (p==false){
		dechp(from,to);
	}
}
void usecard_f(int from,int to){
	if (pig[from].id==1 && pig[to].id==2){
		dechp(from,to);
		return;
	}
	while (true){
		bool flag1=findcard(to,'K');
		if (!flag1){
			dechp(from,to);
			return;
		}
		bool flag2=findcard(from,'K');
		if (!flag2){
			dechp(to,from);
			return;
		}
	}
}
void usecard_n(int from,int to){
	while (true){
		if (gameover) return;
		if (!usecard_j(from,to,0)){
			bool flag=findcard(to,'K');
			if (!flag){
				if (pig[to].id==1 && pig[from].pigid==0){
					pig[from].special=true;
				}
				dechp(from,to);
			}
		}
		to=pig[to].nxt;	
		if (to==from) return;
	}
}
void usecard_w(int from,int to){
	while (true){
		if (gameover) return;
		if (!usecard_j(from,to,0)){
			bool flag=findcard(to,'D');
			if (!flag){
				if (pig[to].id==1 && pig[from].pigid==0){
					pig[from].special=true;
				}
				dechp(from,to);
			}
		}
		to=pig[to].nxt;	
		if (to==from) return;
	}
}
void rungame(){
	while (true){	
		for (int i=1;i<=n;++i){
			if (gameover) return;
			if (pig[i].hp<=0) continue;
			getcard(i);getcard(i);
			bool use_k=true;
			for (int j=1;j<=pig[i].cnt;++j){
				if (pig[i].card[j]=='X') continue;
				if (gameover) return;
				switch (pig[i].card[j]){
					case 'P':{
						if (pig[i].hp<4){
							pig[i].card[j]='X';
							pig[i].hp++;
						}
						break;
					}
					case 'K':{
						if (use_k && enemy(i,pig[i].nxt)){
							pig[i].card[j]='X';
							usecard_k(i,pig[i].nxt);
							if (!pig[i].weapon){
								use_k=false;
							}
							j=0;
						}
						break;	
					}
					case 'F':{
						if (pig[i].id==3){
							pig[i].card[j]='X';
							getenemy(i,1);
							if (usecard_j(i,1,0)) break;
							usecard_f(i,1);
							j=0;
						}else{
							int to=pig[i].nxt;
							while (true){
								if (enemy(i,to)){
								    pig[i].card[j]='X';
									getenemy(i,to);
									if (usecard_j(i,to,0)) break;
									usecard_f(i,to);
									j=0;
						  			break;
								}
								to=pig[to].nxt;
								if (to==i) break;
							}
						}
						break;
					}
					case 'N':{
						pig[i].card[j]='X';
						usecard_n(i,pig[i].nxt);
						j=0;
						break;
					}
					case 'W':{
						pig[i].card[j]='X';
						usecard_w(i,pig[i].nxt);
						j=0;
						break;
					}
					case 'Z':{
						pig[i].card[j]='X';
						pig[i].weapon=true;
						use_k=true;
						j=0;
						break;
					}
				}
				while (pig[i].card[pig[i].cnt]=='X') pig[i].cnt--;
			}
		}
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for (int i=1;i<N;++i){
		for (int j=1;j<M;++j){
			pig[i].card[j]='X';
		}
		pig[i].hp=4;
	}
	for (int i=1;i<=n;++i){
		char names[5],s[5];
		scanf("%s",names);
		for (int j=1;j<=4;++j){
			scanf("%s",s);
			pig[i].card[j]=s[0];
		}
		pig[i].cnt=4;
		if (names[0]=='M') pig[i].id=1,pig[i].pigid=1;
		else if (names[0]=='Z') pig[i].id=2;
		else pig[i].id=3,FPcnt++;
		pig[i].nxt=i+1;
		pig[i].pre=i-1;
	}
	pig[n].nxt=1;
	pig[1].pre=n;
	for (int i=1;i<=m;++i){
		char s[5];
		scanf("%s",s);
		cards[i]=s[0];
	}
	top=1;
	rungame();
	if (pig[1].hp<=0) printf("FP\n");
	else printf("MP\n");
	for (int i=1;i<=n;++i){
		if (pig[i].hp<=0) printf("DEAD\n");
		else{
			printcard(i);
		}
	}
	return 0;
}
```


---

## 作者：灵乌路空 (赞：30)

先无良宣传一下博客 $wwwwww$    
[文章列表 - 地灵殿 - 洛谷博客](https://www.luogu.org/blog/koishikoishi/)

------------

坑点都被楼上的 $Dalao$ 整理得差不多了 ,   
我也没有赘述的必要了 = =

在这里分享一下自己做此题的一些技巧:

------------


1. 先写大纲 :  

    像这种大模拟 , 一般是不需要 ~~脑子~~ 思维技巧 的  
    只需要按照题意模拟即可   
    这时候要格外注意细节   

    所以推荐,在做题之前, 先写一份 伪代码   
    在写伪代码过程中 , 
    
    1. 整理好大致思路  
    2. 用注释的形式, 记录 坑点 和 疑问  

    确保伪代码无误后 ,  再去写 真代码  

2. $string$类 函数:  

    其实对于$string$,一开始我是拒绝的  
    但是发现 $find$ , $erase$ , $replace$ 的帅气酷炫之后   
    **$string$   世界一位 ! !  !**

    在使用手牌的时候 ,   
    可以使用 $find$ 与 $erase$ 进行结合 :  
    使用 $find$ 判断手牌中有无此牌   
    使用 $erase$ 来删除手牌中的这张牌  
    可以十分方便地完成指定的操作

    部分代码如下:
    ```cpp
    bool use_ca(int so,string card)
    {
	    int po=-1;
	    po=p[so].ca.find(card);
	    if(po==-1) return 0;
	    p[so].ca.erase(po,1);
	    return 1;
    }
    ```
3. 关于缩进:

    像这种码量如此鬼畜的代码 ,   
    代码 长几行短几行 其实无所谓了 = =   
    可读性才是最重要的   
    为了一时的压行,破坏观看体验   
    不仅会很难受 ,  
    还会出意想不到的bug = =

    就像某个 $DD$ 一样:
    ```cpp
    if(now_ca=="P" && p[now].bl<4) {p[now].ca.erase(i,1); ca_use=1; p[now].bl++;}
	if(now_ca=="Z") {p[now].ca.erase(i,1); ca_use=1; p[now].bo=1;}
	if(now_ca=="N") {p[now].ca.erase(i,1); ca_use=1; nanman(now);}
	if(now_ca=="W") {p[now].ca.erase(i,1); ca_use=1; wanjian(now);}
	if(now_ca=="F") {int ta=find_duel(now);if(ta==-1) continue;p[now].ca.erase(i,1); ca_use=1;if(judge_duel(now,ta)) duel(now,ta);}
    ```
    就因为鬼畜的压行 , 多调了 $2h+$ = =

---


------------

## 伪代码 (大纲)：

``` cpp
猪国杀
目录：

主函数
备注
变量列表
子函数列表








主函数：
int main()
{
	输入()
	while(1)
  	  {
  		bool  判断是否用过杀=0;
		bool 使用了牌=0;
		摸牌(当前猪)x2;
		while(1)
		  {
		  	int i=0(牌指针)
		    For(i=所有牌,初值为0)
  		      {
  		  	    string 当前牌;
			    当前牌+=手牌[i];
			    If(桃 && 血量<4)
　　		      手牌.earse(i,1),使用了牌,血量+1;
                if(诸葛连弩)
                  手牌.earse(i,1),使用了牌,装备; 
			    if(南蛮入侵||万箭齐发)
  			      手牌.earse(i,1),使用了牌,当前牌(使用猪);
			    if(决斗)
      		      {
					int 决斗对象=决斗能否生效(当前猪);
					if(决斗对象==-1)
					  continue; 
      		      	手牌.earse(i,1),使用了牌;
				    if(决斗是否生效(使用猪,被使用猪))
			          决斗(当前猪,决斗对象); 
		          }
			    if(能攻击(当前猪,下一猪) && 杀)
  			  	  if(没有使用杀||诸葛连弩) 
      			    手牌.earse(i,1),使用了牌,杀(当前猪,下一猪),使用了杀;
      	       if(使用了牌)
			     break;
			  }
		    if(!使用了牌) break;
			if(当前猪:血<=0) break;
			i=0; 
		  }
     	当前猪=下一猪; 
      }
}





备注:
1.	队列存手牌,牌堆(手牌用数组模拟,牌堆用stl)
2.	链表存猪的顺序(链表指向下一猪)
3.  0主公，1忠臣，2反贼 


变量列表:
1.	结构体存某一猪
{
	int型 血量;
	int型 身份;(0主公，1忠臣，2反贼 ) 
	int型 倾向(0表示没有跳 1确定倾向主公,2确定倾向反贼,3倾向类反贼)
	string型 手牌;
	bool型 是否装备诸葛连弩;
}
2 int型二维数组,链表存上一猪,下一猪;
3 bool型变量，判断主公是否死亡，初始为1;
4 int型变量，记录存活的反贼个数; 



子函数列表：
1.	Void 输入
{
	For(i=人数)
      {
	    身份,摸牌(i)x4;
		记录身份;
		if(阵营为主公)
		  倾向=主公; 
		血量=4;
		If(反贼) 反贼存活数+1;
	  }
    for(i=牌堆牌数)
   	  输入,压入牌堆队列;
}
2.	Void 摸牌(猪编号)
{
	string 摸得牌;
	摸得牌=牌堆.front();
	if(不是最后一张牌) 
	  {
		牌堆牌数--; 
		牌堆.pop();
	  }
    此猪手牌+摸得牌;
	return ;
}
３.void 杀(使用猪编号,被使用猪编号)
{
	if(被使用猪倾向为反贼) 使用猪倾向=主公;
	if(被使用猪倾向主公) 使用猪倾向=反贼;
    If(!使用某张牌(被使用猪,闪)) 
  	  被使用猪:血量-1; 
	if(被使用猪:血量<=0)
  	  濒死(使用猪,被使用猪);
}
４. void 濒死(使用猪,被使用猪)
{ 
	while(被使用猪:血量<=0) 
      {
      	if(使用某张牌(被使用猪,桃))  被使用猪:血量+1;
	    else break; 
	  }
	if(被使用猪:血量<=0)
      {
		if(被使用猪为反贼) 
		  {
            反贼数-1;
			游戏结束(); 
			摸牌(使用猪)x3; 
		  }
        if(被使用猪为忠臣 &&　使用猪为主公)
　　　　　主公手牌="",装备牌弃除;
		if(被使用猪为主公)
          {
		    主公死亡;
		    游戏结束();
		  }
		被指用猪的上一猪,链表指向被使用猪的下一猪; 
	  }
}
5.void 游戏结束()
{
	if(主猪死亡 || 反贼数==0)
  	  {
  	  	输出;
		exit(0);
	  }
	return ;
}
6.void 南蛮入侵(使用猪)
{
	for(i=存活所有猪)
  	  {
      	bool 是否被无懈; 
     	if(i猪跳身份)
		  for(j=以使用猪为起点逆时针遍历猪)
   			if(j猪阵营=i猪倾向)
			  if(使用某张牌(j猪,无懈可击))
　　 			{
				  j猪倾向=i猪倾向;
				  if(无懈(j猪))
 					是否被无懈=真, break;
				}
		if(被无懈)continue;
		if(!使用某张牌(i猪,杀))
		  {
			血-1; 
			if(i猪为主公&&使用猪无倾向) 使用猪倾向类反贼; 
		  }
       	If(i猪血<=0) 濒死(使用猪,i猪);
	  }
}
7.万箭齐发(使用猪)
{
	for(i=存活所有猪)
  	  {
      	bool 是否被无懈; 
     	if(i猪跳身份)
		  for(j=以使用猪为起点逆时针遍历猪)
   			if(j猪阵营=i猪倾向)
			  if(使用某张牌(j猪,无懈可击))
　　 			{
				  j猪倾向=i猪倾向;
				  if(无懈(j猪))
 					是否被无懈=真, break;
				}
		if(被无懈)continue;
		if(!使用某张牌(i猪,闪))
		  {
			血-1; 
			if(i猪为主公&&使用猪无倾向) 使用猪倾向类反贼; 
		  }
       	if(i猪血<=0) 濒死(使用猪,i猪);
	  }
}
8 .bool 无懈可击(使用猪)
{
	bool 是否被抵消; 
	for(i=逆时针遍历从使用猪之后的猪)
	  if(i猪与使用猪相反阵营)
	    if(使用某张牌(i猪,无懈可击))
	      {
	        i猪倾向=(!使用猪倾向)
		    if(无懈可击(i猪)) 
		      {
			    是否被抵消=真;
			    break;
			  }
	      }
	if(被抵消) return 0;
	return 1; 
}
9 .void 决斗(使用猪,被使用猪)
{
	if(被使用猪身份为忠 && 使用猪为主)
	  {
	  	被使用猪:血-1;
		if(被使用猪:血<=0)
		  濒死(使用猪,被使用猪)
		return ;
	  }
	if(使用某张牌(被使用猪,杀))
	  决斗(被使用猪,使用猪);
	else
	  {
	  	被使用猪:血-1;
		if(被使用猪:血<=0)
		  濒死(使用猪,被使用猪) 
		return ; 
	  }
}
10 .bool 判断是否可攻击(猪1，猪2)
{
	if(猪1==主猪 && 猪2阵营!=猪1阵营)
	  return 1;
	if(猪1==忠猪 && 猪2阵营==反猪)
	  return 1;
	if(猪1==反猪 && 猪2阵营!=猪1阵营)
	  return 1;
	return 0; 
}
11 .int 找决斗目标(使用猪)
{
	int 被使用猪=-1;
	if(使用猪为反猪)
	  {
	  	被使用猪=主猪; 
		使用猪倾向=反猪;
	  }
	if(使用猪为主猪)
	  {
	  	for(i=逆时针遍历所有猪)
		  if(i猪跳反/类反)
		    被使用猪=该猪,break;
	  }
	if(使用猪为忠猪)
	  {
	  	for(i=逆时针遍历所有猪)
		  if(i猪跳反)
		    {
		      被使用猪=该猪,break;
			  使用猪倾向=主猪; 
			}
	  }
	return 被使用猪;
}
12 .bool 决斗是否生效(使用猪,被使用猪)
{
	bool 是否被无懈;
	if(被使用猪跳身份)
	  For(j=逆时针遍历从使用猪之后的猪)
   	    If(j猪阵营=被使用猪阵营)
		  if(使用某张牌(j猪,无懈可击))
   	        {
		   	   j猪倾向=被使用猪倾向;
		   	   if(无懈(j猪))
 			    是否被无懈=真, break;
		    }
	if(被无懈) return 0;
	return 1; 
} 
13. bool 使用某张牌(使用猪,某张牌)
{
	int 牌位置=-1; 
	牌位置=使用猪手牌.find(某张牌);
	if(牌位置==-1)
	  return 0;
	手牌.earse(牌位置,1);
	return 1; 
}

```

## 代码:

``` cpp

//人生第一黑 
//大纲,已经写的非常详细了 
//请恕我不写注释= = 
#include<iostream>
#include<cstdlib>
#include<queue>
#include<string>
using namespace std;
//=============变量=============================
int pigs_count,pile_count;
struct each_pig
{
	int bl;
	int id;
	int gr;
	bool bo;
	string ca;
}p[15];
int ne_p[15];
int pre_p[15];
bool dead_MP=0;
int alive_FP=0;
int now=1; 
queue <string> pile;
//============子函数列表===========================
void read();
void get_ca(int);
void attack(int,int);
void dying(int,int);
void game_end();
void nanman(int);
void wanjian(int);
bool wuxie(int);
void duel(int,int);
bool judge_attack(int,int);
bool judge_duel(int,int);
int find_duel(int);
bool use_ca(int,string);
//==============主函数================================
int main()
{
	read();
	while(1)
	{
	  bool attack_use=0;
	  get_ca(now);
	  get_ca(now);
	  while(1)
	  {
	  	bool ca_use=0;
	  	int i=0;
	  	for(i;p[now].ca[i];i++)
	  	{
	  	  string now_ca;
	  	  now_ca+=p[now].ca[i];
	  	  if(now_ca=="P" && p[now].bl<4)
	  	    {p[now].ca.erase(i,1); ca_use=1; p[now].bl++;}
	  	  if(now_ca=="Z")
	  	  	{p[now].ca.erase(i,1); ca_use=1; p[now].bo=1;}
		  if(now_ca=="N")
			{p[now].ca.erase(i,1); ca_use=1; nanman(now);}
		  if(now_ca=="W")
			{p[now].ca.erase(i,1); ca_use=1; wanjian(now);}
		  if(now_ca=="F")
			{
			  int ta=find_duel(now);
			  if(ta==-1) continue;
			  p[now].ca.erase(i,1); ca_use=1;
			  if(judge_duel(now,ta)) duel(now,ta);
			}
		  if(now_ca=="K" && judge_attack(now,ne_p[now]))
		    if(!attack_use || p[now].bo)
			{
			  p[now].ca.erase(i,1);
			  ca_use=1;attack_use=1;
			  attack(now,ne_p[now]);
			}
		  if(ca_use) break;
		}
		if(!ca_use) break;
		if(p[now].bl<=0) break;
		i=0;
	  }
	  now=ne_p[now];
	}
}
//==============子函数================================ 
void read()
{
	cin>>pigs_count>>pile_count;
	for(int i=1;i<=pigs_count;i++)
	  {
	  	if(i==1) pre_p[i]=pigs_count;
	  	else  pre_p[i]=i-1;
	  	if(i==pigs_count) ne_p[i]=1;
	  	else ne_p[i]=i+1;
	  }
	for(int i=1;i<=pigs_count;i++)
	  {
	  	string shenfen;
	  	cin>>shenfen;
	  	p[i].bl=4;
	  	if(shenfen=="MP") p[i].id=0,p[i].gr=1;
	  	if(shenfen=="ZP") p[i].id=1;
	  	if(shenfen=="FP") p[i].id=2,alive_FP++;
		for(int j=1;j<=4;j++)
		  {
		  	string cin_ca;
		  	cin>>cin_ca;
		  	p[i].ca+=cin_ca;
		  }
	  }
	for(int i=1;i<=pile_count;i++)
	  {
	  	string cin_ca;
	  	cin>>cin_ca;
	  	pile.push(cin_ca);
	  }
}
void get_ca(int so)
{
	string cin_ca;
	cin_ca=pile.front();
	if(pile_count>1)
	  {
	  	pile_count--;
	  	pile.pop();
	  }
	p[so].ca+=cin_ca;
	return ;
}
void attack(int so,int ta)
{
	if(p[ta].gr==2) p[so].gr=1;
	if(p[ta].gr==1) p[so].gr=2;
	if(!use_ca(ta,"D"))
	  p[ta].bl--;
	if(p[ta].bl<=0)
	  dying(so,ta);
}
void dying(int so,int ta)
{
	while(p[ta].bl<=0)
	  {
	  	if(use_ca(ta,"P")) p[ta].bl++;
	  	else  break;
	  }
	if(p[ta].bl<=0)
	  {
	  	if(p[ta].id==2)
	  	  {
	  	  	alive_FP--;
	  	  	game_end();
	  	  	get_ca(so);
	  	  	get_ca(so);
	  	  	get_ca(so);
		  }
		if(p[ta].id==1 && p[so].id==0)
		  {p[so].ca.clear(),p[so].bo=0;}
		if(p[ta].id==0)
		  {
		  	dead_MP=1;
		  	game_end();
		  }
		ne_p[pre_p[ta]]=ne_p[ta];
		pre_p[ne_p[ta]]=pre_p[ta];
	  }
}
void game_end()
{
	if(dead_MP || !alive_FP)
	  {
	  	if(dead_MP) cout<<"FP"<<endl;
	  	else cout<<"MP"<<endl;
	  	for(int i=1;i<=pigs_count;i++)
	  	  {
	  	  	if(p[i].bl<=0) cout<<"DEAD"<<endl;
	  	  	else
	  	  	  {
				for(int j=0;p[i].ca[j];j++)
	  	  	      cout<<p[i].ca[j]<<" ";
	  	  	    cout<<endl;
	  	  	  }
		  }
		exit(0);
	  }
	return ;
}
void nanman(int so)
{
	for(int i=ne_p[so];i!=so;i=ne_p[i])
	  {
	  	bool wuxie_use=0;
	  	if(p[i].gr && p[i].gr!=3)
	  	  {
	  	  	int vi[15]={0};
	  	  	for(int j=so;j;j=ne_p[j])
	  	  	  if(vi[j]++) break;
	  	  	  else 
				if(p[j].id==p[i].gr || p[j].gr==p[i].gr)
				  if(use_ca(j,"J"))
				    {
				      p[j].gr=p[i].gr;
				      if(wuxie(j))
				        {
				          wuxie_use=1;
				          break;
						}
					}
		  }
		if(wuxie_use) continue;
		if(!use_ca(i,"K"))
		  {
		  	p[i].bl--;
		  	if(p[i].id==0 && !p[so].gr)
		  	  p[so].gr=3;
		  }
		if(p[i].bl<=0) dying(so,i);
	  }
}
void wanjian(int so)
{
	for(int i=ne_p[so];i!=so;i=ne_p[i])
	  {
	  	bool wuxie_use=0;
	  	if(p[i].gr && p[i].gr!=3)
	  	  {
	  	  	int vi[15]={0};
	  	  	for(int j=so;j;j=ne_p[j])
	  	  	  if(vi[j]++) break;
	  	  	  else 
				if(p[j].id==p[i].gr || p[j].gr==p[i].gr) 
				  if(use_ca(j,"J"))
				    {
				      p[j].gr=p[i].gr;
				      if(wuxie(j))
				        {
				          wuxie_use=1;
				          break;
						}
					}
		  }
		if(wuxie_use) continue;
		if(!use_ca(i,"D"))
		  {
		  	p[i].bl--;
		  	if(p[i].id==0 && !p[so].gr)
		  	  p[so].gr=3;
		  }
		if(p[i].bl<=0) dying(so,i);
	  }
}
bool wuxie(int so)
{
	bool wuxie_use=0;
	int vi[15]={0};
	for(int i=so;i;i=ne_p[i])
	  if(vi[i]++)
	    break;
	  else 
	    if(judge_attack(i,so))
	      if(use_ca(i,"J"))
	        {
	      	  p[i].gr=p[so].gr==1?2:1;
	      	  if(wuxie(i))
	      	    {
	      	      wuxie_use=1;
	      	  	  break;
			    }
		    }
	if(wuxie_use) 
	  return 0;
	return 1;
}
void duel(int so,int ta)
{
	if(p[ta].id==1 && p[so].id==0)
	  {
	  	p[ta].bl--;
	  	if(p[ta].bl<=0)
	  	  dying(so,ta);
	  	return ;
	  }
	if(use_ca(ta,"K")) 
	  duel(ta,so);
	else
	  {
	  	p[ta].bl--;
	  	if(p[ta].bl<=0)
	  	  dying(so,ta);
	  	return ;
	  }
}
bool judge_attack(int so,int ta)
{
	if(p[so].id==0 && p[so].gr!=p[ta].gr && p[ta].gr) return 1;
	if(p[so].id==1 && p[ta].gr==2) return 1;
	if(p[so].id==2 && p[so].id!=p[ta].gr && p[ta].gr && p[ta].gr!=3) return 1;
	return 0;
}
int find_duel(int so)
{
	int ta=-1;
	if(p[so].id==2)
	  {
	  	ta=1;
	  	p[so].gr=2;
	  }
	else
	  for(int i=ne_p[so];i!=so;i=ne_p[i])
	  	if(p[i].gr==2 || (p[i].gr==3 && p[so].id==0))
	  	  {
	  	  	p[so].gr=1;
	  	    ta=i;
	  	    break;
		  }
	return ta;
}
bool judge_duel(int so,int ta)
{
	bool wuxie_use=0;
	if(p[ta].gr!=0 && p[ta].gr!=3)
	  for(int i=ne_p[so];i!=so;i=ne_p[i]) 
	    if(p[i].id==p[ta].gr || p[ta].gr==p[i].gr)
	      if(use_ca(i,"J"))
			{
			  p[i].gr=p[ta].gr;
			  if(wuxie(i))
				{
				  wuxie_use=1;
				  break;
				}
			}
	if(wuxie_use) return 0;
	return 1;
}
bool use_ca(int so,string card)
{
	int po=-1;
	po=p[so].ca.find(card);
	if(po==-1)
	  return 0;
	p[so].ca.erase(po,1);
	return 1;
}
```

另外 , 该代码是 $Baka$ 阿空的早期作品  ,   
码风极丑 , 语法混乱 , 各位凑活着看 = =

---

## 作者：king_more (赞：12)

超级无敌大的模拟，先来看题目
首先分为三种人 但是在三种人之外还存在第四种“假人”，我们称为类反猪（因为南蛮或者万箭不小心打到主公导致被打入冷宫）
一层层来分析
首先是杀，如果能杀就杀，能救就救
决斗是挑一个反猪或者类反猪，但是决斗打忠猪，忠猪是不能回手的（委屈）
万箭或者南蛮都是可以被无懈掉的，无懈的条件就是受法者和当前的出牌者是同盟，就可以无懈掉，当然无懈也可以无懈掉无懈
，条件是施法者和受法者得是不同联盟
诸葛有装就装，具体详见代码，有注释
```
#include<bits/stdc++.h>
using namespace std;
const int M = 2000;
const int N = 100;
struct stl{
    int next,last;
    int hp,card_sz;
    bool zgln;
    char id;
    char card[M + 5];
}a[N + 5];
char card_a[M * 5 + 5];
int n,m;
int fz;
char kn[N + 5];
void wjqf(int x1);
void jd(int x1,int x2);
void mp(int x);
void kil(int x1,int x2);
void js(int x1,int x2);
bool wxkj(int x1,int x2,int x3);
bool ed;
void mp(int x)//抽牌
{
    if(!m) m ++;
    a[x].card[++ a[x].card_sz] = card_a[m];
    m --;
}
void jd(int x1,int x2)
{
    int i,j,k;
    if(wxkj(x1,x2,1)) return;//如果被同伙无懈了就跳过
    if(x1 == 1 && a[x2].id == 'Z')//如果打忠猪不能还手
    {
        a[x2].hp --;
        if(! a[x2].hp) js(x1,x2);
        return;
    }
    j = k = 1;
    while(1)
    {
        while(a[x2].card[j] != 'K' && j <= a[x2].card_sz) j ++;//轮流出杀，第一个没有的扣血
        if(j > a[x2].card_sz)
        {
            a[x2].hp --;
            if(! a[x2].hp) js(x1,x2);
            return;
        }
        a[x2].card[j] = 'U';
        while(a[x1].card[k] != 'K' && k <= a[x1].card_sz) k ++;
        if(k > a[x1].card_sz)
        {
            a[x1].hp --;
            if(! a[x1].hp) js(x2,x1);
            return;
        }
        a[x1].card[k] = 'U';
    }
}
void kil(int x1,int x2)
{
    for(int i = 1;i <= a[x2].card_sz;i ++)
    {
        if(a[x2].card[i] == 'D')
        {
            a[x2].card[i] = 'U';	
            return;
        }
    }
    a[x2].hp --;
    if(! a[x2].hp)
        js(x1,x2);
}
void js(int x1,int x2)
{
    for(int i = 1;i <= a[x2].card_sz;i ++)
    {
        if(a[x2].card[i] == 'P')//还能不能抢救一下
        {
            a[x2].hp ++;
            a[x2].card[i] = 'U';
            return;
        }
    }
	a[a[x2].last].next = a[x2].next;//构成新的环
    a[a[x2].next].last = a[x2].last;
    if(x2 == 1)//主猪死了
    {
        ed = true;
        return;
    }
    if(a[x2].id == 'F') fz --;
    if(! fz)//没反猪了
    {
        ed = true;
        return;
    }
    if(a[x2].id == 'F') mp(x1),mp(x1),mp(x1);//干死反猪
    if(a[x2].id == 'Z' && a[x1].id == 'M') a[x1].card_sz = 0,a[x1].zgln = false;//主猪杀反猪付出代价
    return;
}
bool wxkj(int x1,int x2,int x3)
{
    int i = x1;
    while(1)
    {
        if(x3 == 1)//一种是同类帮忙无懈
        {
            if((kn[x2] == a[i].id) || (a[i].id == 'M' && kn[x2] == 'Z') || (a[i].id == 'Z' && kn[x2] == 'M'))
            {
                for(int j = 1;j <= a[i].card_sz;j ++)
                {
                    if(a[i].card[j] == 'J')
                    {
                        a[i].card[j] = 'U';
                        kn[i] = a[i].id;
                        return !wxkj(i,x1,0);
                    }
                }
            }
        }
        else
        {
            if(((a[i].id == 'Z' || a[i].id == 'M') && kn[x1] == 'F') || (a[i].id == 'F' && (kn[x1] == 'Z' || kn[x1] == 'M')))//一种是对手取消无懈
            {
                for(int j = 1;j <= a[i].card_sz;j ++)
                {
                    if(a[i].card[j] == 'J')
                    {
                        a[i].card[j] = 'U';
                        kn[i] = a[i].id;
                        return !wxkj(i,x1,0);
                    }
                }
            }
        }
        i = a[i].next;
        if(i == x1) break;
    }
    return false;
}
void nmrq(int x1)
{
    for(int i = a[x1].next;i != x1;i = a[i].next)
    {
        if(! wxkj(x1,i,1))
        {
            int j;
            for(j = 1;j <= a[i].card_sz;j ++)
            {
                if(a[i].card[j] == 'K')//
                {
                    a[i].card[j] = 'U';
                    break;
                }
            }
            if(j > a[i].card_sz)//没有杀就扣血
            {
                a[i].hp --;
                if(! a[i].hp) js(x1,i);
                if(i == 1 && kn[x1] == 'U') 
                    kn[x1] = 'L';
                if(ed) return;
            }
        }
    }
}
void wjqf(int x1)
{
    for(int i = a[x1].next;i != x1;i = a[i].next)
    {
        if(! wxkj(x1,i,1))
        {
            int j;
            for(j = 1;j <= a[i].card_sz;j ++)
            {
                if(a[i].card[j] == 'D')
                {
                    a[i].card[j] = 'U';
                    break;
                }
            }
            if(j > a[i].card_sz)
            {
                a[i].hp --;
                if(! a[i].hp) js(x1,i);
                if(i == 1 && kn[x1] == 'U') 
                    kn[x1] = 'L';
                if(ed) return;
            }
        }
    }
}
void hh()
{
    ed = true;
    if(fz) ed = false;//如果刚开始就没有反猪就直接退出
    if(ed) return;
    for(int i = 1;i;i = a[i].next)
    {
        mp(i);
        mp(i);
        bool kill = true;//一人只有一次机会
        for(int j = 1;j <= a[i].card_sz;j ++)
        {
            if(! a[i].hp) break;//如果已经死了就跳过
            if(a[i].card[j] == 'U') continue;
            if(a[i].card[j] == 'P')//桃能加就加
            {
                if(a[i].hp != 4)
                {
                    a[i].hp ++;
                    a[i].card[j] = 'U';
                    continue;
                }
            }
            if(a[i].card[j] == 'K')
            {
                if(! kill && ! a[i].zgln) continue;
                if(a[i].id == 'M' && (kn[a[i].next] != 'L' && kn[a[i].next] != 'F')) continue;//如果主猪下面不是类反猪和反猪就跳过，下面同上
                if(a[i].id == 'F' && (kn[a[i].next] != 'M' && kn[a[i].next] != 'Z')) continue;
                if(a[i].id == 'Z' && (kn[a[i].next] != 'F')) continue;
                a[i].card[j] = 'U';
                kil(i,a[i].next);
                kn[i] = a[i].id;//标明身份，因为砍人就代表了自己的身份了
                kill = false;//标记已经杀过了
                if(ed) return;
                continue;
            }
            if(a[i].card[j] == 'F')
            {
                if(a[i].id == 'F')
                {
                    a[i].card[j] = 'U';
                    jd(i,1);//如果反猪就直接打主猪
                    kn[i] = a[i].id;//标明身份
                    if(ed) return;
                    j = 0;
                    continue;
                }
                for(int k = a[i].next;k != i;k = a[k].next)
                {
                    if((a[i].id == 'M' && (kn[k] == 'L' || kn[k] == 'F')) || (a[i].id == 'Z' && kn[k] == 'F'))//如果主猪打反猪和类反猪，忠猪打反猪
                    {
                        a[i].card[j] = 'U';
                        jd(i,k);
                        kn[i] = a[i].id;
                        if(ed) return;
                        j = 0;
                        break;
                    }
                }
                continue;
            }
            if(a[i].card[j] == 'N')
            {
                a[i].card[j] = 'U';
                nmrq(i);
                if(ed) return;
                j = 0;//从头开始防止主猪打死忠猪弃牌之类的
                continue;
            }
            if(a[i].card[j] == 'W')//同上
            {
                a[i].card[j] = 'U';
                wjqf(i);
                if(ed) return;
                j = 0;
                continue;
            }
            if(a[i].card[j] == 'Z')//装备诸葛
            {
                a[i].card[j] = 'U';
                a[i].zgln = 1;
                j = 0;
                continue;
            }
        }
        /*for(int i_1 = 1;i_1 <= n;i_1 ++)
            cout << a[i_1].hp << " ";
        cout << endl;*/
    }
}
int main()
{	
    cin >> n >> m;
    for(int i = 1;i <= n;i ++)//建成一个圆
    {
        a[i].next = i + 1;
        a[i].last = i - 1;
    }
    a[n].next = 1;
    a[1].last = n;
    for(int i = 2;i <= n;i ++)
        kn[i] = 'U';
    kn[1] = 'M';
    for(int i = 1;i <= n;i ++)//输入，标记身份，拿初始牌
    {
        string s;
        cin >> s;
        for(int j = 1;j <= 2001;j ++)
            a[i].card[j] = 'U';
        a[i].zgln = false; 
        a[i].id = s[0];
        a[i].hp = 4;
        a[i].card_sz = 4;
        if(a[i].id == 'F')
            fz ++;
        for(int j = 1;j <= 4;j ++)
        {
            cin >> s;
            a[i].card[j] = s[0];
        }
    }
    for(int i = 1;i <= m;i ++)//塞牌库
    {
        string s;
        cin >> s;
        card_a[m - i + 1] = s[0];
    }
    hh();
    if(a[1].hp <= 0) cout << "FP" << endl;
    else cout << "MP" << endl;
    for(int i = 1;i <= n;i ++)
    {
        if(a[i].hp <= 0) cout << "DEAD" << endl;
        else
        {
            for(int j = 1;j <= a[i].card_sz;j ++)
            {
                if(a[i].card[j] != 'U')
                    cout << a[i].card[j] << " ";
            }
            cout << endl;
        }
    }
    return 0;
}
```

第二道黑题


---

## 作者：_虹_ (赞：8)

疑似史上 ~~最易理解~~代码最长 猪国杀

听说某位蒟da蒻lao因为不会面向过程写了面向对象。~~我oi白学。~~

除了上面的大佬们提到的坑点，加上几个我自己写的时候发现的注意点：
1. **无论锦囊牌是不是生效，出了就会触发献殷勤/表敌意。**
2. **	跳身份很好处理，只要触发了献殷勤/表敌意，把自己的身份表明就好了。**
3. 	猪都很耿直，能表明身份就表明身份。
4. 	无懈可击是对被攻击的猪献殷勤/表敌意。

写完30分的时候过了一遍代码逻辑，总体应该还是挺清晰的，代码里也有些中英混杂的注释。~~所以不想额外加注释了。~~

代码效率不高，也有几个凑活的地方，比如class_world::piglist应该是一个环状链表，再用一个数组做索引进行o（1）的查找和删除（world类外部持有list::iterator总觉得不太好）

class_basic_pig::cardlist也应该是一个链表，然后我就全都vector解决了。。。。

应该没有什么隐蔽的错误。只是虽然我很尽力了，耦合貌似还是蛮高的。。。。。

开发规范本来就没有正经学习，现在也忘得很干净了。

但是程序中各种命名还是尽力保证可读性，试图去遵守一下命名规范的（虽然没成功吧）。~~不过后来改bug导致某些命名和其它命名不太一致。 大家谅解一下。~~

虽然代码1000来行，不过可读性应该还行吧...~~（心虚）~~

**不想看代码建议直接看结尾，提供vs2015 project下载，观赏效果更佳。**
### 下面大量类继承，多态警告：
```cpp
// luogu-judger-enable-o2
#include <vector>
#include <queue>
#include <list>
#include <iostream>
#include <cstdlib>
using namespace std;
enum enum_status
{
    DEAD = 0, UNKNOW = 1, FRIEND = 2, ENEMY = 3, ETBE = 4
};
enum enum_card
{
    BLOOD = 1, KILL = 2, MISS = 3, FIGHT = 4, N_ATK = 5, W_ATK = 6, J_DF = 7, ARM = 8
};//无懈可击是J_DF，这个鬼东西我是真不会起名了
enum enum_kind
{
    MAIN_PIG = 1, FRIEND_PIG = 2, ENEMY_PIG = 3
};
#define reg register
#define null NULL
#define MAXBLOOD 4
struct Event;
class class_basic_pig
{
public:
    enum_kind Kind;
    enum_status Status;
    bool Armed;
    int num;//数组下标
    int Blood;
    vector<enum_card> CardList;

    class_basic_pig(const int _num, enum_kind _kind) :num(_num), Kind(_kind),Armed(false),Blood(MAXBLOOD),Status(UNKNOW){};

    void N_Attack();
    void W_Attack();

    virtual void N_AttackBy(class_basic_pig*)=0;
    virtual void W_AttackBy(class_basic_pig*)=0;
    virtual void C_AttackBy(class_basic_pig*)=0;

    void StartFightWith(class_basic_pig*);//start to fight with ptr
    virtual const bool FightWith(class_basic_pig*)=0;//fight with ptr
    bool DropCard(enum_card);//return true if pig has this card to drop,or false if hasnt

    void Hurt();//pig is hurt,try to heal，updata pigs status
    //virtual void Updata();//updata pigs status

    //virtual void SpecialDefence();//if use special defence card

    virtual bool Usable(const enum_card&,bool&);//if the card usable//子类重载并且调用basic类的函数
    virtual const bool IsEnemy(const enum_status&)=0;//判断是否为敌人

    virtual void CheckAfterAttack(class_basic_pig* ptr) = 0;//造成伤害后结算

    void Turn();

    virtual void UseCard(enum_card)=0;

    virtual bool UseSpecialDefence(Event)=0;//true: used,false: didnt use

    virtual void UpdataIdentity() = 0;
};


struct Event
{
    class_basic_pig* source;//锦囊牌发出者
    class_basic_pig* target;//锦囊牌接受者
    bool Good;//true:献殷勤，false:表敌意
    Event(class_basic_pig* s = null, class_basic_pig* t = null, bool b = false) :source(s), target(t), Good(b) {};
};
class class_world
{
public:
    vector<class_basic_pig*> PigList;
    queue<enum_card> CardPool;
    class_basic_pig* GetEnemy(int num, class_basic_pig* ptr);
    class_basic_pig* GetNext(int num);
    class_basic_pig* GetLast(int num);
    enum_card GetCard()
    {
        enum_card t = CardPool.front();
        if (CardPool.size() > 1)
        {
            CardPool.pop();
        }
        return t;
    }
    void EndGame();
    void GameBegin();
    bool CheckSpecialDefnece(Event);//if oridary event can happen,return true,else return false
}World;

class class_main_pig:public class_basic_pig
{
public:
    class_main_pig(const int _num):class_basic_pig(_num, MAIN_PIG){};
    virtual void N_AttackBy(class_basic_pig*);
    virtual void W_AttackBy(class_basic_pig*);
    virtual void C_AttackBy(class_basic_pig*);

    virtual bool Usable(const enum_card&,bool&);
    virtual const bool IsEnemy(const enum_status&);

    virtual const bool FightWith(class_basic_pig*);

    virtual void CheckAfterAttack(class_basic_pig*);

    virtual void UseCard(enum_card);

    virtual bool UseSpecialDefence(Event);

    virtual void UpdataIdentity() {};
};

class class_friend_pig :public class_basic_pig
{
public:
    class_friend_pig(const int _num) :class_basic_pig(_num, FRIEND_PIG) {};
    virtual void N_AttackBy(class_basic_pig*);
    virtual void W_AttackBy(class_basic_pig*);
    virtual void C_AttackBy(class_basic_pig*);

    virtual bool Usable(const enum_card&, bool&);
    virtual const bool IsEnemy(const enum_status&);

    virtual const bool FightWith(class_basic_pig*);

    virtual void CheckAfterAttack(class_basic_pig*);

    virtual void UseCard(enum_card);

    virtual bool UseSpecialDefence(Event);

    virtual void UpdataIdentity();
};


class class_enemy_pig :public class_basic_pig
{
public:
    class_enemy_pig(const int _num) :class_basic_pig(_num, ENEMY_PIG) {};
    virtual void N_AttackBy(class_basic_pig*);
    virtual void W_AttackBy(class_basic_pig*);
    virtual void C_AttackBy(class_basic_pig*);

    virtual bool Usable(const enum_card&, bool&);
    virtual const bool IsEnemy(const enum_status&);

    virtual const bool FightWith(class_basic_pig*);

    virtual void CheckAfterAttack(class_basic_pig*);

    virtual void UseCard(enum_card);

    virtual bool UseSpecialDefence(Event);

    virtual void UpdataIdentity();
};

char un_translate(enum_card card)
{
    char ch;
    switch (card)
    {
    case BLOOD:
        ch = 'P';
        break;

    case KILL:
        ch = 'K';
        break;

    case MISS:
        ch = 'D';
        break;

    case FIGHT:
        ch = 'F';
        break;

    case N_ATK:
        ch = 'N';
        break;

    case W_ATK:
        ch = 'W';
        break;

    case J_DF:
        ch = 'J';
        break;

    case ARM:
        ch = 'Z';
        break;
    }
    return ch;
}


void class_basic_pig::N_Attack()
{
    class_basic_pig* ptr = null;
    int pos = num;
    while ((ptr = World.GetNext(pos)) && ptr->num!=num )
    {
        pos = ptr->num;
        ptr->N_AttackBy(this);
        CheckAfterAttack(ptr);
    }
}
void class_basic_pig::W_Attack()
{
    class_basic_pig* ptr = null;
    int pos = num;
    while ((ptr = World.GetNext(pos)) && ptr->num != num)
    {
        pos = ptr->num;
        ptr->W_AttackBy(this);
        CheckAfterAttack(ptr);
    }
}

bool class_basic_pig::DropCard(enum_card c)
{
    int s = CardList.size();
    for (reg int i = 0; i < s; ++i)
    {
        if (CardList[i] == c)
        {
            CardList.erase(CardList.begin()+i);
            return true;
        }
    }
    return false;
}

bool class_basic_pig::Usable(const enum_card& c,bool& tag)
{
    if ((c == BLOOD&&Blood < MAXBLOOD) ||
        c == N_ATK || c == W_ATK || c == ARM)
        return true;
    class_basic_pig* ptr = World.GetNext(num);//杀
    if ((Armed || (!tag)) && c == KILL && IsEnemy(ptr->Status))
    {
        tag = true;
        return true;
    }
    return false;
}

void class_basic_pig::StartFightWith(class_basic_pig* ptr)
{
    UpdataIdentity();
    if (!World.CheckSpecialDefnece(Event(this, ptr, false)))
    {
        return;
    }
    int i = 1;
    while (i % 2 ?
        ptr->FightWith(this) :
        FightWith(ptr))
    {
        ++i;//do nothing
    }
    if (i % 2)//ptr hurt
    {
        CheckAfterAttack(ptr);
    }
    else
    {
        ptr->CheckAfterAttack(this);
    }
}
void class_basic_pig::Hurt()
{
    --Blood;
    if (Blood < 1)
    {
        while (Blood < 1 && DropCard(BLOOD))
            ++Blood;//heal
        if (Blood < 1)
        {
            Status = DEAD;
            if (Kind == MAIN_PIG)
            {
                World.EndGame();
            }
            bool tag = false;
            for (reg int j = 0; j < World.PigList.size(); ++j)
            {
                if (World.PigList[j]->Kind == ENEMY_PIG&&World.PigList[j]->Status != DEAD)
                {
                    tag = true;
                }
            }
            if (!tag)
            {
                World.EndGame();
            }
        }
    }
}


void class_basic_pig::Turn()
{
    CardList.push_back(World.GetCard());
    CardList.push_back(World.GetCard());
    bool tag = true;
    bool kill_tag = false;
    while (tag&&Status!=DEAD)
    {
        tag = false;
        for (reg int i = 0; i < CardList.size(); ++i)
        {
            if (Usable(CardList[i], kill_tag))
            {
                tag = true;
                UseCard(CardList[i]);
                break;
            }
        }
    }
}

class_basic_pig* class_world::GetEnemy(int num, class_basic_pig* ptr)//	(now pos,check func)
{
    int tot = PigList.size();
    for (reg int i = 0; i < tot; ++i)
    {
        if (ptr->IsEnemy(PigList[(++num) % tot]->Status))//pig is able to attack because of the status
        {
            return PigList[num%tot];
        }
    }
    return null;
}

class_basic_pig* class_world::GetNext(int num)//now pos
{
    int tot = PigList.size();
    for (reg int i = 0; i < tot; ++i)
    {
        if (PigList[(++num) % tot]->Status != DEAD)//pig is alive
        {
            return PigList[num % tot];
        }
    }
    return null;
}

class_basic_pig* class_world::GetLast(int num)//now pos
{
    int tot = PigList.size();
    for (reg int i = 0; i < tot; ++i)
    {
        if (PigList[(tot + (--num)) % tot]->Status != DEAD)//pig is alive
        {
            return PigList[(tot + (num)) % tot];
        }
    }
    return null;
}

void class_world::EndGame()
{
    if (PigList[0]->Status == DEAD)
        cout << "FP" << endl;
    else
        cout << "MP" << endl;
    for (reg int i = 0; i < PigList.size(); ++i)
    {
        if (PigList[i]->Status == DEAD)
        {
            cout << "DEAD" << endl;
        }
        else
        {
            for (reg int j = 0; j < PigList[i]->CardList.size(); ++j)
            {
                cout << un_translate(PigList[i]->CardList[j]) << ' ';
            }
            cout << endl;
        }
    }
    exit(-1);//i think this might stop you from AC on luogu if  you just copy the code.
}

void class_world::GameBegin()
{
    int tot=PigList.size();
    for (reg int i = 0;; ++i)
    {
        i = i%tot;
        if(PigList[i]->Status!=DEAD) 
            PigList[i]->Turn();
    }
}
bool class_world::CheckSpecialDefnece(Event e)//if oridary event can happen,return true,else return false
{
    class_basic_pig* ptr = e.source;
    if (!ptr)
        return true;
    int num = ptr->num;
    do
    {
        if (ptr->UseSpecialDefence(e))
        {
            ptr->UpdataIdentity();
            if (CheckSpecialDefnece(Event(ptr, e.target, !e.Good)))//happend
            {
                return false;
            }
            return true;
        }
    } while ((ptr = GetNext(ptr->num))->num != num);
    return true;
}

void class_main_pig::N_AttackBy(class_basic_pig* ptr)
{
    if (!World.CheckSpecialDefnece(Event(ptr, this, false)))
    {
        return;
    }
    if (DropCard(KILL))
    {
        return;//丢弃杀
    }
    else
    {
        if (ptr->Status == UNKNOW)
            ptr->Status = ETBE;
        Hurt();
    }
}
void class_main_pig::W_AttackBy(class_basic_pig* ptr)
{
    if (!World.CheckSpecialDefnece(Event(ptr, this, false)))
    {
        return;
    }
    if (DropCard(MISS))
    {
        return;//丢弃闪
    }
    else
    {
        if (ptr->Status == UNKNOW)
            ptr->Status = ETBE;
        Hurt();
    }
}

bool class_main_pig::Usable(const enum_card& c,bool& tag)//check if this card usable
{
    if (class_basic_pig::Usable(c,tag))
    {
        return true;
    }
    //ptr = World.GetEnemy(num, ((const bool (class_basic_pig::*)(const enum_status&))this->IsEnemy));
    if (c == FIGHT)
    {
        if (World.GetEnemy(num, this))//have enemy
            return true;
    }
    return false;
}

const bool class_main_pig::IsEnemy(const enum_status& s) 
{
    return s == ENEMY || s == ETBE;
}

void class_main_pig::C_AttackBy(class_basic_pig* ptr)
{
    ptr->Status = ENEMY;
    if (DropCard(MISS))
    {
        ;//丢弃闪
    }
    else
    {
        Hurt();
    }
}

const bool class_main_pig::FightWith(class_basic_pig* ptr)//fight with ptr
{
    if (DropCard(KILL))
    {
        return true;
    }
    else
    {
        Hurt();
        return false;
    }
}

void class_main_pig::CheckAfterAttack(class_basic_pig* ptr)//胜者结算
{
    if(ptr->Status == DEAD)
    {
        if (ptr->Kind == FRIEND_PIG)
        {
            CardList.clear();
            Armed = false;
        }
        else
        {
            CardList.push_back(World.GetCard());
            CardList.push_back(World.GetCard());
            CardList.push_back(World.GetCard());
        }
    }
}


void class_main_pig::UseCard(enum_card c)
{
    DropCard(c);
    class_basic_pig* ptr;
    switch (c)
    {
    case KILL:
        ptr = World.GetNext(num);
        ptr->C_AttackBy(this);
        CheckAfterAttack(ptr);
        break;

    case BLOOD:
        ++Blood;
        break;

    case N_ATK:
        N_Attack();
        break;

    case W_ATK:
        W_Attack();
        break;

    case ARM:
        Armed = true;
        break;

    case FIGHT:
        ptr=World.GetEnemy(num, this);
        StartFightWith(ptr);
        break;
    }
}

bool class_main_pig::UseSpecialDefence(Event e)
{
    bool tag = false;
    if (e.target->Status == FRIEND)
    {
        if (!e.Good)//event表示对友军表敌意
        {
            tag= true;//使用无懈可击献殷勤
        }
    }
    if (e.target->Status == ENEMY)
    {
        if (e.Good)//对敌军献殷勤
        {
            tag= true;//表敌意
        }
    }
    if (tag)
    {
        tag = DropCard(J_DF);
    }
    return tag;
}
//////////////////////////////////////////////////////////////////////

void class_friend_pig::N_AttackBy(class_basic_pig* ptr)
{
    if (!World.CheckSpecialDefnece(Event(ptr, this, false)))
    {
        return;
    }
    if (DropCard(KILL))
    {
        return;//丢弃杀
    }
    else
    {
        Hurt();
    }
}
void class_friend_pig::W_AttackBy(class_basic_pig* ptr)
{
    if (!World.CheckSpecialDefnece(Event(ptr, this, false)))
    {
        return;
    }
    if (DropCard(MISS))
    {
        return;//丢弃闪
    }
    else
    {
        Hurt();
    }
}


bool class_friend_pig::Usable(const enum_card& c, bool& tag)//check if this card usable
{
    if (class_basic_pig::Usable(c, tag))
    {
        return true;
    }
    //ptr = World.GetEnemy(num, ((const bool (class_basic_pig::*)(const enum_status&))this->IsEnemy));
    if (c == FIGHT)
    {
        if (World.GetEnemy(num,this))//have enemy
            return true;
    }
    return false;
}

const bool class_friend_pig::IsEnemy(const enum_status& s)
{
    return s == ENEMY;
}

void class_friend_pig::C_AttackBy(class_basic_pig* ptr)
{
    if (ptr->Kind == MAIN_PIG)//
        ;
    else
        ptr->Status = ENEMY;
    if (DropCard(MISS))
    {
        ;//丢弃闪
    }
    else
    {
        Hurt();
    }
}

const bool class_friend_pig::FightWith(class_basic_pig* ptr)//fight with ptr
{
    if (ptr->Kind == MAIN_PIG)
    {
        Hurt();
        return false;
    }
    if (DropCard(KILL))
    {
        return true;
    }
    else
    {
        Hurt();
        return false;
    }
    return false;
}

void class_friend_pig::CheckAfterAttack(class_basic_pig* ptr)//胜者(攻击者）结算
{
    if (ptr->Status == DEAD)
    {
        if(ptr->Kind==ENEMY_PIG)
        {
            CardList.push_back(World.GetCard());
            CardList.push_back(World.GetCard());
            CardList.push_back(World.GetCard());
        }
    }
}

void class_friend_pig::UseCard(enum_card c)
{
    DropCard(c);
    class_basic_pig* ptr;
    switch (c)
    {
    case KILL:
        ptr = World.GetNext(num);
        ptr->C_AttackBy(this);
        CheckAfterAttack(ptr);
        break;

    case BLOOD:
        ++Blood;
        break;

    case N_ATK:
        N_Attack();
        break;

    case W_ATK:
        W_Attack();
        break;

    case ARM:
        Armed = true;
        break;

    case FIGHT:
        ptr = World.GetEnemy(num, this);
        StartFightWith(ptr);
        break;
    }
}


bool class_friend_pig::UseSpecialDefence(Event e)
{
    bool tag = false;
    if (e.target->Status == FRIEND)
    {
        if (!e.Good)//event表示对友军表敌意
        {
            tag= true;//使用无懈可击献殷勤
        }
    }
    if (e.target->Status == ENEMY)
    {
        if (e.Good)//对敌军献殷勤
        {
            tag= true;//表敌意
        }
    }
    if (tag)
    {
        tag = DropCard(J_DF);
    }
    return tag;
}


void class_friend_pig::UpdataIdentity()
{
    Status = FRIEND;
}
/////////////////////////////////////////////////////////////////////
void class_enemy_pig::N_AttackBy(class_basic_pig* ptr)
{
    if (!World.CheckSpecialDefnece(Event(ptr, this, false)))
    {
        return;
    }
    if (DropCard(KILL))
    {
        return;//丢弃杀
    }
    else
    {
        Hurt();
    }
}
void class_enemy_pig::W_AttackBy(class_basic_pig* ptr)
{
    if (!World.CheckSpecialDefnece(Event(ptr, this, false)))
    {
        return;
    }
    if (DropCard(MISS))
    {
        return;//丢弃闪
    }
    else
    {
        Hurt();
    }
}

bool class_enemy_pig::Usable(const enum_card& c, bool& tag)//check if this card usable
{
    if (class_basic_pig::Usable(c, tag))
    {
        return true;
    }
    //ptr = World.GetEnemy(num, ((const bool (class_basic_pig::*)(const enum_status&))this->IsEnemy));
    if (c == FIGHT)
    {
            return true;
    }
    return false;
}

const bool class_enemy_pig::IsEnemy(const enum_status& s)
{
    return s == FRIEND;
}


void class_enemy_pig::C_AttackBy(class_basic_pig* ptr)
{
    ptr->Status = FRIEND;
    if (DropCard(MISS))
    {
        ;//丢弃闪
    }
    else
    {
        Hurt();
    }
}

const bool class_enemy_pig::FightWith(class_basic_pig* ptr)//fight with ptr
{
    if (DropCard(KILL))
    {
        return true;
    }
    else
    {
        Hurt();
        return false;
    }
    return false;
}

void class_enemy_pig::CheckAfterAttack(class_basic_pig* ptr)//胜者结算
{
    if (ptr->Status == DEAD)
    {
        if (ptr->Kind == ENEMY_PIG)
        {
            CardList.push_back(World.GetCard());
            CardList.push_back(World.GetCard());
            CardList.push_back(World.GetCard());
        }
    }
}

void class_enemy_pig::UseCard(enum_card c)
{
    DropCard(c);
    class_basic_pig* ptr;
    switch (c)
    {  
    case KILL:
        ptr = World.GetNext(num);
        ptr-> C_AttackBy(this);
        CheckAfterAttack(ptr);
        break;

    case BLOOD:
        ++Blood;
        break;

    case N_ATK:
        N_Attack();
        break;

    case W_ATK:
        W_Attack();
        break;

    case ARM:
        Armed = true;
        break;

    case FIGHT:
        ptr = World.PigList[0];//主猪
        StartFightWith(ptr);
        break;
    }
}

bool class_enemy_pig::UseSpecialDefence(Event e)
{
    bool tag = false;
    if (e.target->Status == ENEMY)
    {
        if (!e.Good)//event表示对友军表敌意
        {
            tag= true;//使用无懈可击献殷勤
        }
    }
    if (e.target->Status == FRIEND)
    {
        if (e.Good)//对敌军献殷勤
        {
            tag= true;//表敌意
        }
    }
    if (tag)
    {
        tag = DropCard(J_DF);
    }
    return tag;
}

void class_enemy_pig::UpdataIdentity()
{
    Status = ENEMY;
}
enum_card translate(char ch)
{
    enum_card card;
    switch (ch)
    {
    case 'P':
        card = BLOOD;
        break;

    case 'K':
        card = KILL;
        break;

    case 'D':
        card = MISS;
        break;

    case 'F':
        card = FIGHT;
        break;

    case 'N':
        card = N_ATK;
        break;

    case 'W':
        card = W_ATK;
        break;

    case 'J':
        card = J_DF;
        break;

    case 'Z':
        card = ARM;
        break;
    }
    return card;
}
int main()
{
    int n, m;
    char ch;
    cin >> n >> m;
    class_basic_pig* ptr;
    for (reg int i = 0; i < n; ++i)
    {
        cin >> ch;
        switch (ch)
        {
        case 'M':
            ptr = new class_main_pig(i);
            break;

        case 'Z':
            ptr = new class_friend_pig(i);
            break;

        case 'F':
            ptr = new class_enemy_pig(i);
            break;
        }
        World.PigList.push_back(ptr);
        cin >> ch;
        for (reg int j = 0; j < 4; ++j)
        {
            cin >> ch;
            ptr->CardList.push_back(translate(ch));
        }
    }
    World.PigList[0]->Status = FRIEND;
    for (reg int i = 0; i < m; ++i)
    {
        cin >> ch;
        World.CardPool.push(translate(ch));
    }
    World.GameBegin();
    return 0;
}
```

刚刚上传工程才发现文件夹只有10几mb大，印象中vs一个工程100多mb的样子啊。。。。

**分享链接中，测试数据来自LOJ。**

**vs2015 project下载：**
[度盘链接](https://pan.baidu.com/s/1eoVcX2Zz1LkBpbVHyGZKxA)
提取码：6nbh

希望管理大大给个通过。

---

## 作者：Celtic (赞：7)



~~代码成功卡到$600$行以内~~

曾经发誓一天切掉的我打了两周。。。

先看题

要点还是挺多的，即使是~~像我这样~~熟悉三国杀的同（$wán$）学（$ jiā$），也要认真看。


------------

首先是基本牌的部分。



杀：在自己的回合内，对攻击范围内除自己以外的一名角色使用。如果没有被『闪』抵消，则造成1点伤害。无论有无武器，杀的攻击范围都是1；

直接看看自己的下家跳没跳，跳了的话就看看是不是一伙然后一刀砍下去，没跳直接$return$。

注意，用了杀之后自己的身份就完全暴露了。


------------

闪：当你受到杀的攻击时，可以弃置一张闪来抵消杀的效果；

这个没什么需要解释的吧，直接暴力看看有没有闪就行了。


------------
桃：在自己的回合内，如果自己的体力值不等于体力上限，那么使用一个桃可以为自己补充一点体力，否则不能使用桃；桃只能对自己使用；在自己的回合外，如果自己的血变为0或者更低，那么也可以使用；

注意：不能对别人使用！！！



------------

猪哥连弩：武器，攻击范围1，出牌阶段你可以使用任意张杀；

注意：即使之前有了也要再装一遍，把之前的顶掉（不愧是猪）。


------------

看上去很简单，但是细节很多。

首先就是装上猪哥连弩之后前面的杀也是可以用的，需要$i=0$重新扫一遍。

还有题目描述中说保证牌数够用，不要相信它，牌堆没了就一直摸最后一张牌。

一个回合只能用一次杀（除非装了猪哥连弩）。


------------
好了现在$10$分到手了。

接下来我们看锦囊牌。

决斗：出牌阶段，对除自己以外任意一名角色使用，由目标角色先开始，自己和目标角色轮流弃置一张杀，首先没有杀可弃的一方受到1点伤害，另一方视为此伤害的来源；

这个就一个$while$就暴力判断一下有没有杀就完事了，需要注意的是忠臣接收到主公的杀要直接掉血。

还有伤害来源不是用牌者而是对方。

要判断是跳反还是跳忠。

------------
南猪入侵：出牌阶段，对除你以外所有角色使用，按逆时针顺序从使用者下家开始依次结算，除非弃置一张杀，否则受到1点伤害；

这里判断一下死了就直接跳过，蒟蒻因为这个调了好几天。。。

每个人都要判断。



------------
万箭齐发：和南猪入侵类似，不过要弃置的不是杀而是闪；

做法和题上说的也一样，把杀换成闪就完事了。


------------
还是很麻烦的，最后提醒一下按理来说除了桃使用任意一张手牌后都要重新扫一遍，比如说万箭齐发杀死了你的下家，然后前面的杀有可能就有了目标。

好的现在我们拿到$30$分了。


------------
最后一个最恶心的部分——无懈可击。

orz一下各路用奇偶性来判断的神仙。

蒟蒻只会递归。。。

那么明确一下，无懈可击后，自己和对方的身份都已经暴露了。

判断一下受攻击的人跳没跳身份，如果没跳就直接$return$。

记录一个$flag$判断是在献殷勤还是表敌意。

然后暴力枚举判断就行了，找到之后下一层递归要$flag$^=$1$

至此，猪国杀成功$AC$。


------------

上代码
```cpp
#include<bits/stdc++.h>
#define N 2001001
#define MAX 2001
#define re register
#define inf 1e18
#define eps 1e-10
using namespace std;
typedef long long ll;
typedef double db;
inline void read(re ll &ret)
{
	ret=0;re char c=getchar();re bool pd=false;
	while(!isdigit(c)){pd|=c=='-';c=getchar();}
	while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c&15);c=getchar();}
	ret=pd?-ret:ret;
	return;
}
ll n,m;
struct zhu
{
	ll paishu,leixing,xueliang;//leixing=1为主猪，2为忠猪，3为反猪 
	char pai[1000001];
	bool zhuge,si,tiaozhong,tiaofan,leifan;
}a[11];
char s[N];
char paidui[2001];
ll head;
inline void print()
{
	for(re int i=1;i<=n;i++)
	{
		if(a[i].si)
			printf("DEAD\n");
		else
		{
//			cout<<i<<" "<<a[i].xueliang<<endl;
			for(re int j=1;j<=a[i].paishu;j++)
			{
				if(j>1)
					putchar(' ');
				putchar(a[i].pai[j]);
			}
			putchar('\n');
		}
	}
	return;
}
inline void init()
{
	read(n);
	read(m);
	for(re int i=1;i<=n;i++)
	{
		a[i].si=false;
		a[i].xueliang=4;
		a[i].zhuge=false;
		scanf("%s",s+1);
		if(s[1]=='M')
			a[i].leixing=1;
		else if(s[1]=='Z')
			a[i].leixing=2;
		else
			a[i].leixing=3;
		for(re int j=1;j<=4;j++)
		{
			scanf("%s",s+1);
			a[i].pai[++a[i].paishu]=s[1];
		}
	}
	for(re int i=1;i<=m;i++)
	{
		scanf("%s",s+1);
		paidui[i]=s[1];
	}
}
inline void yongpai(re ll num,re ll pos)
{
	for(re int i=pos+1;i<=a[num].paishu;i++)
		a[num].pai[i-1]=a[num].pai[i];
	a[num].paishu--;
	return;
}

inline void jieshu()
{
	re bool mp=true,fp=true;
	for(re int i=1;i<=n;i++)
	{
		if(a[i].xueliang!=0&&a[i].leixing==3)
			mp=false;
		if(a[i].xueliang!=0&&a[i].leixing==1)
			fp=false;
	}
	if(mp)
	{
		printf("MP\n");
		print();
		exit(0);
	}
	if(fp)
	{
		printf("FP\n");
		print();
		exit(0);
	}
	return;
}
inline void mopai(re ll pos,re ll num)
{
	for(re int i=1;i<=num;i++)
	{
		if(++head>m)
			head=m;
		a[pos].pai[++a[pos].paishu]=paidui[head];
	}
		
	return;
}
inline void si(re ll num,re ll laiyuan)
{
//	cout<<num<<" "<<laiyuan<<endl;
	if(a[num].xueliang>=1)
		return;
	for(re int i=1;i<=a[num].paishu;i++)
	{
		if(a[num].pai[i]=='P')
		{
			yongpai(num,i);
			a[num].xueliang++;
			break;
		}
	}
	if(a[num].xueliang<1)
	{
		a[num].si=true;
		jieshu();
		if(a[num].leixing==3)
			mopai(laiyuan,3);
		else if(a[num].leixing==2&&a[laiyuan].leixing==1)
		{
			a[laiyuan].paishu=0;
			a[laiyuan].zhuge=false;
		}
	}
	return;
}
inline bool shan(re ll pos)
{
	for(re int i=1;i<=a[pos].paishu;i++)
	{
		if(a[pos].pai[i]=='D')
		{
			yongpai(pos,i);
			return true;
		}
	}
	return false;
}
inline bool sha(re ll pos,re ll num)
{
	for(re int i=pos+1;i<=n;i++)
	{
		if(a[i].si)continue;
		if((a[pos].leixing==1&&(a[i].tiaofan||a[i].leifan))||(a[pos].leixing==2&&a[i].tiaofan)||(a[pos].leixing==3&&(a[i].leixing==1||a[i].tiaozhong)))
		{
			yongpai(pos,num);
			if(a[i].tiaofan)
			{
				a[pos].tiaozhong=true;
				a[pos].leifan=false;
			}
			else if(a[i].tiaozhong||a[i].leixing==1)
				a[pos].tiaofan=true;
			if(!shan(i))
			{
				a[i].xueliang--;
				si(i,pos);
			}
			return true;
		}
		return false;	
	}
	for(re int i=1;i<pos;i++)
	{
		if(a[i].si)continue;
		if((a[pos].leixing==1&&(a[i].tiaofan||a[i].leifan))||(a[pos].leixing==2&&a[i].tiaofan)||(a[pos].leixing==3&&(a[i].leixing==1||a[i].tiaozhong)))
		{
			yongpai(pos,num);
			if(a[i].tiaofan)
			{
				a[pos].tiaozhong=true;
				a[pos].leifan=false;
			}
			else if(a[i].tiaozhong||a[i].leixing==1)
				a[pos].tiaofan=true;
			if(!shan(i))
			{
				a[i].xueliang--;
				si(i,pos);
			}
			return true;
		}
		return false;	
	}
}
inline bool wuxie(re ll pos,re ll to,re bool pd)
{
	if(!a[to].tiaofan&&!a[to].tiaozhong&&a[to].leixing!=1)return false;
	if(pd)
	{
		re bool flag=false;
		for(re int i=pos;i<=n;i++)
		{
			if(a[i].si)continue;
			if((a[to].leixing==1&&(a[i].leixing==3))||(a[to].tiaozhong&&(a[i].leixing==3))||(a[to].tiaofan&&(a[i].leixing==1||a[i].leixing==2)))
				continue;
			for(re int j=1;j<=a[i].paishu;j++)
			{
				if(a[i].pai[j]=='J')
				{
					yongpai(i,j);
					if(a[to].leixing==1)
					{
						a[i].tiaozhong=true;
						a[i].leifan=false;
					}
					else if(a[to].leixing==2)
					{
						a[i].tiaozhong=true;
						a[i].leifan=false;
					}
					else
					{
						a[i].tiaofan=true;
						a[i].leifan=false;
					}
				//	if((a[i].leixing==1&&a[pos].leixing==2)||(a[i].leixing==2&&(a[pos].leixing==1||a[pos].leixing==2))||(a[i].leixing==3&&a[pos].leixing==3))
					return !wuxie(i,to,false);
				//	else
				//		return !wuxie(i,to,true);
				}
			}
		}
		for(re int i=1;i<pos;i++)
		{
			if(a[i].si)continue;
			if((a[to].leixing==1&&(a[i].leixing==3))||(a[to].tiaozhong&&(a[i].leixing==3))||(a[to].tiaofan&&(a[i].leixing==1||a[i].leixing==2)))
				continue;
			for(re int j=1;j<=a[i].paishu;j++)
			{
				if(a[i].pai[j]=='J')
				{
					yongpai(i,j);
					if(a[to].leixing==1)
					{
						a[i].tiaozhong=true;
						a[i].leifan=false;
					}
					else if(a[to].leixing==2)
					{
						a[i].tiaozhong=true;
						a[i].leifan=false;
					}
					else
					{
						a[i].tiaofan=true;
						a[i].leifan=false;
					}
			//		if((a[i].leixing==1&&a[pos].leixing==2)||(a[i].leixing==2&&(a[pos].leixing==1||a[pos].leixing==2))||(a[i].leixing==3&&a[pos].leixing==3))
						return !wuxie(i,to,false);
			//		else
			//			return !wuxie(i,to,true);
				}
			}
			
		}
		return false;
	}
	else
	{
		re bool flag=false;
		for(re int i=pos;i<=n;i++)
		{
			if(a[i].si)continue;
			if(!((a[to].leixing==1&&(a[i].leixing==3))||(a[to].tiaozhong&&(a[i].leixing==3))||(a[to].tiaofan&&(a[i].leixing==1||a[i].leixing==2))))
				continue;
			for(re int j=1;j<=a[i].paishu;j++)
			{
				if(a[i].pai[j]=='J')
				{
					yongpai(i,j);
					if(a[to].leixing==1)
					{
						a[i].tiaofan=true;
						a[i].leifan=false;
					}
					else if(a[to].leixing==2)
					{
						a[i].tiaofan=true;
						a[i].leifan=false;
					}
					else
					{
						a[i].tiaozhong=true;
						a[i].leifan=false;
					}
					return !wuxie(i,to,true);
				}
			}
		}
		for(re int i=1;i<pos;i++)
		{
			if(a[i].si)continue;
			if(!((a[to].leixing==1&&(a[i].leixing==3))||(a[to].tiaozhong&&(a[i].leixing==3))||(a[to].tiaofan&&(a[i].leixing==1||a[i].leixing==2))))
				continue;
			for(re int j=1;j<=a[i].paishu;j++)
			{
				if(a[i].pai[j]=='J')
				{
					yongpai(i,j);
					if(a[to].leixing==1)
					{
						a[i].tiaofan=true;
						a[i].leifan=false;
					}
					else if(a[to].leixing==2)
					{
						a[i].tiaofan=true;
						a[i].leifan=false;
					}
					else
					{
						a[i].tiaozhong=true;
						a[i].leifan=false;
					}
					return !wuxie(i,to,true);
				}
			}
			
		}
		return false;
	}
}
inline bool juedou(re ll pos,re ll num)
{
	for(re int i=pos+1;i<=n;i++)
	{
		if(a[i].si)continue;
		if((a[pos].leixing==1&&(a[i].tiaofan||a[i].leifan))||(a[pos].leixing==2&&a[i].tiaofan)||(a[pos].leixing==3&&a[i].leixing==1))
		{
			yongpai(pos,num);
			if(a[i].leixing==3)
			{
				a[pos].tiaozhong=true;
				a[pos].leifan=false;
			}
			else if(a[i].tiaozhong||a[i].leixing==1)
				a[pos].tiaofan=true;
			if(wuxie(pos,i,true))
				return true;
			if(a[pos].leixing==1&&a[i].leixing==2)
			{
				a[i].xueliang--;
				si(i,pos);
				return true;
			}
			re ll turn=i;
			while(true)
			{
				re bool flag=false;
				for(re int j=1;j<=a[turn].paishu;j++)
				{
					if(a[turn].pai[j]=='K')
					{
						yongpai(turn,j);
						flag=true;
						break;
					}
				}
				if(!flag)
				{
					a[turn].xueliang--;
					si(turn,turn==pos?i:pos);
					return true;
				}
				if(turn==i)
					turn=pos;
				else
					turn=i;
			}
		}
	}
	for(re int i=1;i<pos;i++)
	{
		if(a[i].si)continue;
		if((a[pos].leixing==1&&(a[i].tiaofan||a[i].leifan))||(a[pos].leixing==2&&a[i].tiaofan)||(a[pos].leixing==3&&a[i].leixing==1))
		{
			yongpai(pos,num);
			if(a[i].leixing==3)
			{
				a[pos].tiaozhong=true;
				a[pos].leifan=false;
			}
			else if(a[i].tiaozhong||a[i].leixing==1)
				a[pos].tiaofan=true;
			if(wuxie(pos,i,true))
				return true;
			if(a[pos].leixing==1&&a[i].leixing==2)
			{
				a[i].xueliang--;
				si(i,pos);
				return true;
			}
			re ll turn=i;
			while(true)
			{
				re bool flag=false;
				for(re int j=1;j<=a[turn].paishu;j++)
				{
					if(a[turn].pai[j]=='K')
					{
						yongpai(turn,j);
						flag=true;
						break;
					}
				}
				if(!flag)
				{
					a[turn].xueliang--;
					si(turn,turn==pos?i:pos);
					return true;
				}
				if(turn==i)
					turn=pos;
				else
					turn=i;
			}
		}
	}
	return false;
}
inline void nanman(re ll pos,re ll num)
{
//	cout<<pos<<" "<<num<<endl;
	yongpai(pos,num);
	for(re int i=pos+1;i<=n;i++)
	{
		if(a[i].si)continue;
		if(wuxie(pos,i,true))continue;
		re bool flag=false;
		for(re int j=1;j<=a[i].paishu;j++)
		{
			if(a[i].pai[j]=='K')
			{
				yongpai(i,j);
				flag=true;
				break;
			}
		}
		if(!flag)
		{
			a[i].xueliang--;
			if(a[i].leixing==1&&!a[pos].tiaozhong&&!a[pos].tiaofan)
				a[pos].leifan=true;
			si(i,pos);
		}
	}
	for(re int i=1;i<pos;i++)
	{
		if(a[i].si)continue;
		if(wuxie(pos,i,true))continue;
		re bool flag=false;
		for(re int j=1;j<=a[i].paishu;j++)
		{
			if(a[i].pai[j]=='K')
			{
				yongpai(i,j);
				flag=true;
				break;
			}
		}
		if(!flag)
		{
			a[i].xueliang--;
			if(a[i].leixing==1&&!a[pos].tiaozhong&&!a[pos].tiaofan)
				a[pos].leifan=true;
			si(i,pos);
		}
	}
	return;
}
inline void wanjian(re ll pos,re ll num)
{
//	cout<<pos<<" "<<num<<endl;
	yongpai(pos,num);
	for(re int i=pos+1;i<=n;i++)
	{
		if(a[i].si)continue;
		if(wuxie(pos,i,true))continue;
		if(!shan(i))
		{
			a[i].xueliang--;
			if(a[i].leixing==1&&!a[pos].tiaozhong&&!a[pos].tiaofan)
				a[pos].leifan=true;
			si(i,pos);
		}
	}
	for(re int i=1;i<pos;i++)
	{
		if(a[i].si)continue;
		if(wuxie(pos,i,true))continue;
		if(!shan(i))
		{
			a[i].xueliang--;
			if(a[i].leixing==1&&!a[pos].tiaozhong&&!a[pos].tiaofan)
				a[pos].leifan=true;
			si(i,pos);
		}
	}
	return;
}
inline void chupai(re ll pos)
{
	re bool chuguosha=false;
	for(re int i=1;i<=a[pos].paishu;i++)
	{
		if(a[pos].si)
			return;
		if(a[pos].pai[i]=='P')
		{
			if(a[pos].xueliang<4)
			{
				yongpai(pos,i);
				i=0;
				a[pos].xueliang++;
			}
		}
		else if(a[pos].pai[i]=='K'&&(!chuguosha||a[pos].zhuge))
		{
			if(sha(pos,i))
			{
				i=0;
				chuguosha=true;
			}
		}
		else if(a[pos].pai[i]=='F')
		{
			if(juedou(pos,i))
				i=0;
		}
		else if(a[pos].pai[i]=='N')
		{
			nanman(pos,i);
			i=0;
		}
		else if(a[pos].pai[i]=='W')
		{
			wanjian(pos,i);
			i=0;
		}
		else if(a[pos].pai[i]=='Z')
		{
			a[pos].zhuge=true;
			yongpai(pos,i);
			i=0;
		}
	//	cout<<i<<endl;
	}
	return;
}
/*
『桃(P)』
『杀(K)』
『闪(D)』
『决斗(F)』
『南猪入侵(N)』
『万箭齐发(W)』
『无懈可击(J)』
『猪哥连弩(Z)』
*/
inline void work()
{
	re ll num=0;
	while(true)
	{
		num%=n;
		num++;
		if(a[num].si)
			continue;
		mopai(num,2);
		chupai(num);
	}
}
signed main()
{
	init();
	work();
	exit(0);
}
//[SDOI2010]猪国杀
```


---

## 作者：Hope2075 (赞：6)

题目的一个小BUG：牌堆可能为空，这时不断复制最后一张牌即可，否则会五彩缤纷（其实只有4种颜色）

这题是超级“简单”的模拟题，坑点很“少”

奋战了7个小时，终于写出来了，554行（我写过的最长代码）

这题是目前为止我编程用时第二的题（第一是逛公园 9h）

~~按题意模拟即可~~

这种大模拟(基本)不用考虑性能，应该尽量降低编程复杂度和调试难度

考虑清楚后再编程

------------

我写的很面向对象，~~然后有一个类包含8个类函数~~，另外用了大量指针

根据题意，实际可以不考虑献殷勤和表敌意本身

直接考虑跳忠和跳反即可

可以认为主公也是试图跳忠，绝不跳反

建立玩家和手牌类

需要考虑如何记录足够的信息，并设计一些类函数

这是我考虑的，可以参考一下

玩家：变量有：手牌，体力值，是否有弩，身份，暴露的身份； 操作有：摸牌，出牌，清空牌堆，对其他玩家出的牌作出反应，受到伤害，死亡

记录手牌时我给每种牌开了一个链表

牌：类型，使用

然后我又写了一个游戏类

变量有：玩家列表，玩家数，剩余反贼数

操作有：使用南蛮入侵\万箭齐发，请求出无懈可击

写空函数可以不用考虑排列顺序，缺啥就实现啥，用不到的可以只写空函数，不实现，也不会CE

写好后逐个实现函数即可，发现需要其它函数就直接加上一个，然后实现

显示牌的过程我直接把牌扔进一个数组，然后sort后输出


------------

小心细节

杀：只能当下一个玩家暴露身份后才能用，别忘了判断是否可以一回合使用多次，只能攻击下一个玩家

决斗：注意反贼只会对主公使用决斗，忠臣不会在与主公决斗时出杀，一旦出了杀，就不会被无懈掉

如果把自己干掉，就不能继续出牌

南蛮&万箭：会产生类反猪，但并未暴露身份

这两个很相似，应该注意区分，改的时候通常要一起改

无懈可击：从使用锦囊的玩家开始决定是否出，使用无懈可击后从出无懈可击的人开始决定是否出，而不是出第一个锦囊的人先决定

如果按我这个思路，根据回应执行操作时不要调用两次回应函数，否则会死得很惨

小心不要重复执行操作

不要把回应动作弄混，最好定义常量，然后判相等

可以把常量弄得各不相同，这样如果混用会容易发现

清空主公的牌时要把弩卸掉

实在不行找篇题解“对拍”查错

------------

不建议写一堆数组记录，这样很难调试

面向对象和模块化的程序很容易找出错误的地方

递归也是个好东西

最后上代码，有注释，应该能看懂

DEBUG变量为true时会输出出完每张牌后的局面

~~比赛时千万别忘了去掉调试信息~~

[代码](https://www.luogu.org/paste/qsxjc217)（防止~~引人注目~~占版面）

---

## 作者：Ice_teapoy (赞：6)

NOIP Day0 A掉猪国杀超级开心啊嗷嗷

emmmmm……大模拟没啥思路可说……

一点注意事项：

1、猪在受到南蛮入侵和万箭齐发时先判断有没有人给他出无懈可击，然后再出闪or杀。

2、判定无懈可击时，从出锦囊牌的猪开始判定，友视被害猪的猪会无懈掉攻击牌，仇视被害猪的猪会无懈掉无懈攻击的牌。

3、不论锦囊牌是否被无懈掉，一经打出就已经使用了。

4、猪被动使用杀、闪、桃、无懈可击时按照从左至右的顺序。

5、使用一张除了杀和桃的牌有可能会暴露其他猪的身份或可以使用多张杀，此时我们应重新判定该张牌前面的牌能否使用。

6、在杀死反猪时会获得3张牌，本回合这三张牌也可能可以使用，不要忘记判定他们。

7、不论是否能够打赢都一定会使用决斗牌，决斗牌可能会使自己死亡。此时若自己是反猪，对方会得到3张牌，并且应立即停止本轮后续牌的判断。

8、正在出牌的猪也可能会使用无懈可击，不要忘记判定。
```cpp
/*
	Coded by Ice_teapoy
*/
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
struct pig
{
	string ide,sur;
	char c[1001];
	int n,hp,arms,C[27],a[27];
}a[11];
int v[1001],o,n,m,i,j,nxt[11],fr[11],now=1,kill=1,MP,sMP,sFP,sZP,oo,ooo,P='P'-'A',K='K'-'A',D='D'-'A',F='F'-'A',N='N'-'A',W='W'-'A',J='J'-'A',Z='Z'-'A';
char c[1000001];
void draw(int aa)
{
	a[aa].C[c[m]-'A']++,a[aa].c[++a[aa].n]=c[m--];
}
bool hos(int x,int y)
{
	oo=0;
	if ((a[x].ide=="ZP"&&a[y].sur=="FP")||(a[x].ide=="MP"&&(a[y].sur=="FP"||a[y].sur=="LFP"))||(a[x].ide=="FP"&&(a[y].sur=="MP"||a[y].sur=="ZP"))) a[x].sur=a[x].ide,oo=1;
	return oo;
}
bool friends(int x,int y)
{
	oo=0;
	if ((a[x].ide=="FP"&&a[y].sur=="FP")||(a[x].ide=="MP"&&(a[y].sur=="ZP"||a[y].sur=="MP"))||(a[x].ide=="ZP"&&(a[y].sur=="MP"||a[y].sur=="ZP"))) a[x].sur=a[x].ide,oo=1;
	return oo;
}
bool Dead(const int xx,const int x)
{	
	if (--a[x].hp) return 0;
	if (a[x].C[P])
	{
		a[x].hp++,a[x].C[P]--,a[x].a[P]++;
		return 0;
	}
	else if (a[x].ide=="MP") sMP--;
	else if (a[x].ide=="ZP") 
		if (xx==MP) a[xx].arms=0,a[xx].n=0,memset(a[xx].a,0,sizeof(a[xx].a)),memset(a[xx].c,0,sizeof(a[xx].c)),memset(a[xx].C,0,sizeof(a[xx].C)),sZP--;
		else sZP--;
	else if (a[x].ide=="FP")
		if (sFP>1) draw(xx),draw(xx),draw(xx),sFP--;
		else sFP--;
	else 1;
	nxt[fr[x]]=nxt[x],fr[nxt[x]]=fr[x];
	return (sMP==0||sFP==0);
 } 
bool qaq(int t,int ying,int x)
{
	v[t]=1;
	if (a[x].C[ying]) a[x].C[ying]--,a[x].a[ying]++;
	else 
	{
		if (a[x].ide=="MP"&&a[now].sur!="FP"&&a[now].sur!="ZP") a[now].sur="LFP";
		if (Dead(now,x)) return 1;
	}
	return 0;
}
bool FF(int x,int y)
{
	if (a[x].ide=="MP"&&a[y].ide=="ZP") oo=y,ooo=x;
	else if (a[x].C[K]<a[y].C[K]) oo=x,ooo=y,a[y].C[K]-=a[x].C[K]+1,a[y].a[K]+=a[x].C[K]+1,a[x].a[K]+=a[x].C[K],a[x].C[K]=0;
	else ooo=x,oo=y,a[x].C[K]-=a[y].C[K],a[x].a[K]+=a[y].C[K],a[y].a[K]+=a[y].C[K],a[y].C[K]=0;
	if (Dead(ooo,oo)) return 1;
	return 0;
}
bool inv(int x,int y,int tot)
{
	for (int i=x,j=1;j<=sMP+sFP+sZP;i=nxt[i],j++)
		if (a[i].C[J]&&((tot%2&&friends(i,y))||((!(tot%2))&&hos(i,y))))
		{
			a[i].a[J]++,a[i].C[J]--;
			return !inv(i,y,tot+1);
		}
	return 0;
}
bool qwq(int nn,int tottt)
{
	for (int i=1,j;i<=(tottt?a[now].n:nn);++i)
	{
		if (v[i]) continue;
		if (a[now].a[a[now].c[i]-'A'])
		{
			v[i]=1,a[now].a[a[now].c[i]-'A']--;
			continue;
		}
		if (a[now].c[i]=='Z') v[i]=1,a[now].arms=1;
		else if (a[now].c[i]=='K'&&(kill||a[now].arms)&&hos(now,nxt[now]))
		{
			kill=0;
			if (qaq(i,D,nxt[now])) return 1;
		}
		else if (a[now].c[i]=='P'&&a[now].hp<4) v[i]=1,a[now].hp++;
		else if (a[now].c[i]=='N')
			for (v[i]=1,j=nxt[now];j!=now;j=nxt[j])
				if ((!inv(now,j,1))&&qaq(i,K,j)) return 1;
				else continue;
		else if (a[now].c[i]=='W')
			for (v[i]=1,j=nxt[now];j!=now;j=nxt[j])
				if ((!inv(now,j,1))&&qaq(i,D,j)) return 1;
				else continue;
		else if (a[now].c[i]=='F')
		{
			if (a[now].ide=="FP")
			{
				a[now].sur="FP",v[i]=1;
				if (!inv(now,MP,1)&&FF(now,MP)) return 1;
			}
			else for (j=nxt[now];j!=now;j=nxt[j])
				if (hos(now,j)&&(v[i]=1))
					if (!inv(now,j,1)&&FF(now,j)) return 1;
					else break;
				else continue;
			if (!a[now].hp) return 0;
		}
		if (v[i]) a[now].C[a[now].c[i]-'A']--;
		if (v[i]&&a[now].c[i]!='K'&&a[now].c[i]!='P'&&qwq(i-1,0)) return 1;
	}
	return 0;
}
int main()
{
	scanf("%d%d",&n,&m);
	for (i=1;i<=n;++i)
	{
		for (nxt[i]=i+1,fr[i]=i-1,a[i].hp=4,cin>>a[i].ide,a[i].n=4,j=1;j<=4;++j) cin>>a[i].c[j],a[i].C[a[i].c[j]-'A']++;
		if (a[i].ide=="FP") sFP++;
		else if (a[i].ide=="ZP") sZP++;
		else MP=now=i,sMP++;
	}
	for (i=1000000,j=1;j<=m;--i,++j) cin>>c[i];
	for (;i;i--) c[i]=c[i+1];
	for (nxt[n]=1,fr[1]=n,a[now].sur="MP",m=1000000;sMP&&sFP&&m>0;)
	{
		draw(now),draw(now),o=!qwq(a[now].n,1);
		for (i=0,j=1;j<=a[now].n;++j)
			if (!v[j]) a[now].c[++i]=a[now].c[j];
		a[now].n=i,memset(v,0,sizeof(v)),kill=1;
		if (!o) break;
		memset(a[now].a,0,sizeof(a[now].a)),now=nxt[now];
	}
	cout<<(sFP?"FP":"MP")<<"\n";
	for (i=1;i<=n;++i,puts(""))
		if (a[i].hp) 
			for (j=1;j<=a[i].n;++j) 
				if (a[i].a[a[i].c[j]-'A']) a[i].a[a[i].c[j]-'A']--;
				else cout<<a[i].c[j]<<" ";
		else printf("DEAD");
	return 0;
}
```
以上是代码qwq

emmmm……虽然已经有很多模拟器的样子……

但是既然是纪念，依然放上我自己的模拟器qwq
```cpp
/*
	coded by Ice_teapoy
*/
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
struct pig
{
	string identity,surface;
	char card[1001];
	int n,hp,arms,Card[27],a[27];
}a[11];
int o,n,m,i,j,order[11],front[11],Current=1,kill=1,MP,sMP,sFP,sZP,oo,ooo,P='P'-'A',K='K'-'A',D='D'-'A',F='F'-'A',N='N'-'A',W='W'-'A',J='J'-'A',Z='Z'-'A';
char card[1000001];
bool v[1001];
void draw(int aa)
{
	a[aa].Card[card[m]-'A']++,a[aa].card[++a[aa].n]=card[m--];
}
bool hostile(int x,int y)
{
	oo=0;
	if (a[x].identity=="MP"&&(a[y].surface=="FP"||a[y].surface=="LFP")) oo=1;
	else if (a[x].identity=="ZP"&&a[y].surface=="FP") a[x].surface="ZP",oo=1;
	else if (a[x].identity=="FP"&&(a[y].surface=="MP"||a[y].surface=="ZP")) a[x].surface="FP",oo=1;
	return oo;
}
bool friends(int x,int y)
{
	oo=0;
	if (a[x].identity=="ZP"&&(a[y].surface=="MP"||a[y].surface=="ZP")) a[x].surface="ZP",oo=1;
	else if (a[x].identity=="MP"&&(a[y].surface=="ZP"||a[y].surface=="MP")) oo=1;
	else if (a[x].identity=="FP"&&a[y].surface=="FP") a[x].surface="FP",oo=1;
	return oo;
}
bool Dead(const int xx,const int x)
{	
	if (--a[x].hp) return 0;
	cout<<"　　【"<<x<<"死亡了！\n" ;
	if (a[x].Card[P])
	{
		cout<<"　　【"<<x<<"使用了桃！\n";
		a[x].hp++,a[x].Card[P]--,a[x].a[P]++;
		return 0;
	}
	else if (a[x].identity=="MP") sMP--;
	else if (a[x].identity=="ZP") 
		if (xx==MP) a[xx].arms=0,a[xx].n=0,memset(a[xx].a,0,sizeof(a[xx].a)),memset(a[xx].card,0,sizeof(a[xx].card)),memset(a[xx].Card,0,sizeof(a[xx].Card)),sZP--;
		else sZP--;
	else if (a[x].identity=="FP")
	{
		if (sFP>1) draw(xx),draw(xx),draw(xx),sFP--;
		else sFP--;
		printf("------------------------\n%3d ",j);
		cout<<a[xx].identity<<" "<<a[xx].surface<<" hp:"<<a[xx].hp<<" n:"<<a[xx].n<<" arms:"<<a[xx].arms<<"\n";
		for (i=1;i<=a[xx].n;i++) cout<<a[xx].card[i]<<" ";
		cout<<"\n    K D P J F W N Z\n";
		cout<<"    "<<a[xx].Card[K]<<" "<<a[xx].Card[D]<<" "<<a[xx].Card[P]<<" "<<a[xx].Card[J]<<" "<<a[xx].Card[F]<<" "<<a[xx].Card[W]<<" "<<a[xx].Card[N]<<" "<<a[xx].Card[Z]<<"\n";
		cout<<"    "<<a[xx].a[K]<<" "<<a[xx].a[D]<<" "<<a[xx].a[P]<<" "<<a[xx].a[J]<<" "<<a[xx].a[F]<<" "<<a[xx].a[W]<<" "<<a[xx].a[N]<<" "<<a[xx].a[Z]<<"\n";
		printf("------------------------\n");
	}
	order[front[x]]=order[x],front[order[x]]=front[x];
	cout<<"（当前场上还有MP: "<<sMP<<" ZP: "<<sZP<<" FP: "<<sFP<<"\n"; 
	return (sMP==0||sFP==0);
 } 
bool qaq(int t,int ying,int x)
{
	v[t]=1;
	if (a[x].Card[ying])
	{
		a[x].Card[ying]--,a[x].a[ying]++;
		cout<<"　【"<<x<<"使用了"<<char('A'+ying)<<"，"<<Current<<"的攻击落空了！\n";
	}
	else 
	{
		cout<<"　【"<<Current<<"对"<<x<<"造成1点伤害，"<<x<<"还有"<<a[x].hp-1<<"点血！\n";
		if (a[x].identity=="MP"&&a[Current].surface!="FP"&&a[Current].surface!="ZP")
		{
			cout<<"　【"<<Current<<"被认为是LFP！\n";
			a[Current].surface="LFP";
		}
		if (Dead(Current,x)) return 1;
	}
	return 0;
}
bool Fight(int x,int y)
{
	if (a[x].identity=="MP"&&a[y].identity=="ZP") oo=y,ooo=x;
	else if (a[x].Card[K]<a[y].Card[K]) oo=x,ooo=y,a[y].Card[K]-=a[x].Card[K]+1,a[y].a[K]+=a[x].Card[K]+1,a[x].a[K]+=a[x].Card[K],a[x].Card[K]=0;
	else ooo=x,oo=y,a[x].Card[K]-=a[y].Card[K],a[x].a[K]+=a[y].Card[K],a[y].a[K]+=a[y].Card[K],a[y].Card[K]=0;
	cout<<"【"<<ooo<<"对"<<oo<<"造成了1点伤害！"<<oo<<"还有"<<a[oo].hp<<"点血。"; 
	if (Dead(ooo,oo)) return 1;
	return 0;
}
bool invulnerable(int x,int y,int tot)
{
	for (int iii=1;iii<=tot;++iii) cout<<"　";
	cout<<"【";
	if (tot%2) cout<<"为保护"<<y<<"请求J: \n";
	else cout<<"为攻击"<<y<<"请求J: \n";
	for (int i=x,j=1;j<=sMP+sFP+sZP;i=order[i],j++)
		if (a[i].Card[J]&&((tot%2&&friends(i,y))||((!(tot%2))&&hostile(i,y))))
		{
			for (int iii=1;iii<=tot;++iii) cout<<"　";
			cout<<" ["<<i<<"使用了J！\n";
			for (int iii=1;iii<=tot;++iii) cout<<"　";
			cout<<" ["<<i<<"的身份暴露了，他是"<<a[i].surface<<"。\n";
			a[i].a[J]++,a[i].Card[J]--;
			return !invulnerable(i,y,tot+1);
		}
	for (int iii=1;iii<=tot;++iii) cout<<"　";
	cout<<"【"<<x<<"的锦囊牌生效了！\n";
	return 0;
}
bool qwq(int nn,int tottt)
{
	for (int i=1,j;i<=(tottt?a[Current].n:nn);++i)
	{
		if (v[i]) continue;
		if (a[Current].a[a[Current].card[i]-'A'])
		{
			v[i]=1,a[Current].a[a[Current].card[i]-'A']--;
			continue;
		}
		if (a[Current].card[i]=='Z')
		{
			v[i]=1,a[Current].arms=1;
			cout<<"【"<<Current<<"装备了Z！\n"; 
		}
		else if (a[Current].card[i]=='K'&&(kill||a[Current].arms)&&hostile(Current,order[Current]))
		{
			kill=0;
			cout<<"【"<<Current<<"对"<<order[Current]<<"使用了K！\n";
			cout<<"　【"<<Current<<"暴露了身份，他是"<<a[Current].surface<<"\n";
			if (qaq(i,D,order[Current])) return 1;
		}
		else if (a[Current].card[i]=='P'&&a[Current].hp<4)
		{
			cout<<"【"<<Current<<"使用了P！他当前有"<<a[Current].hp<<"滴血。\n";
			v[i]=1,a[Current].hp++;
		}
		else if (a[Current].card[i]=='N')
		{
			cout<<"【"<<Current<<"使用了N！\n";
			for (v[i]=1,j=order[Current];j!=Current;j=order[j])
				if ((!invulnerable(Current,j,1))&&qaq(i,K,j)) return 1;
				else continue;
		}
		else if (a[Current].card[i]=='W')
		{
			cout<<"【"<<Current<<"使用了W！\n";
			for (v[i]=1,j=order[Current];j!=Current;j=order[j])
				if ((!invulnerable(Current,j,1))&&qaq(i,D,j)) return 1;
				else continue;
		} 
		else if (a[Current].card[i]=='F')
		{
			if (a[Current].identity=="FP")
			{
				a[Current].surface="FP",v[i]=1;
				cout<<"【"<<Current<<"对"<<MP<<"使用了K！\n";
				cout<<"　【"<<Current<<"暴露了身份，他是"<<a[Current].surface<<"\n";
				if (!invulnerable(Current,MP,1)&&Fight(Current,MP)) return 1;
			}
			else for (j=order[Current];j!=Current;j=order[j])
				if (hostile(Current,j)&&(v[i]=1))
				{
					cout<<"【"<<Current<<"对"<<j<<"使用了F！\n";
					cout<<"　【"<<Current<<"暴露了身份，他是"<<a[Current].surface<<"\n";
					if (!invulnerable(Current,j,1)&&Fight(Current,j)) return 1;
					else break;
				}
				else continue;
			if (!a[Current].hp) return 0;
		}
		if (v[i]) a[Current].Card[a[Current].card[i]-'A']--;
		if (v[i]&&a[Current].card[i]!='K'&&a[Current].card[i]!='P'&&qwq(i-1,0)) return 1;
	}
	return 0;
}
void Clean()
{
	for (i=1;i<=a[Current].n;++i) cout<<v[i]<<" ";
	for (puts(""),i=0,j=1;j<=a[Current].n;++j)
		if (!v[j]) a[Current].card[++i]=a[Current].card[j];
	a[Current].n=i;
	memset(v,0,sizeof(v)),kill=1;
}
int main()
{
	scanf("%d%d",&n,&m);
	for (i=1;i<=n;++i)
	{
		for (a[i].surface="??",order[i]=i+1,front[i]=i-1,a[i].hp=4,cin>>a[i].identity,a[i].n=4,j=1;j<=4;++j) cin>>a[i].card[j],a[i].Card[a[i].card[j]-'A']++;
		if (a[i].identity=="FP") sFP++;
		else if (a[i].identity=="ZP") sZP++;
		else MP=Current=i,sMP++;
	}
	for (i=1000000,j=1;j<=m;--i,++j) cin>>card[i];
	for (;i;i--) card[i]=card[i+1];
	for (i=1;i<=n;++i) ;
	order[n]=1,front[1]=n,a[Current].surface="MP",m=1000000;
	int tt;
	while (sMP&&sFP&&m>0)
	{
		draw(Current),draw(Current);
		cout<<"\n\n*第"<<(++tt )<<"轮，由第"<<Current<<"只猪出牌。*\n";
		for (j=1;j<=n;++j)
		{
			printf("------------------------\n%3d ",j);
			cout<<a[j].identity<<" "<<a[j].surface<<" hp:"<<a[j].hp<<" n:"<<a[j].n<<" arms:"<<a[j].arms<<"\n";
			for (i=1;i<=a[j].n;i++) cout<<a[j].card[i]<<" ";
			cout<<"\n    K D P J F W N Z\n";
			cout<<"    "<<a[j].Card[K]<<" "<<a[j].Card[D]<<" "<<a[j].Card[P]<<" "<<a[j].Card[J]<<" "<<a[j].Card[F]<<" "<<a[j].Card[W]<<" "<<a[j].Card[N]<<" "<<a[j].Card[Z]<<"\n";
			cout<<"    "<<a[j].a[K]<<" "<<a[j].a[D]<<" "<<a[j].a[P]<<" "<<a[j].a[J]<<" "<<a[j].a[F]<<" "<<a[j].a[W]<<" "<<a[j].a[N]<<" "<<a[j].a[Z]<<"\n";
		}
		o=(!qwq(a[Current].n,1)),Clean();
		if (!o) break;
		memset(a[Current].a,0,sizeof(a[Current].a));
		Current=order[Current];
	}
	if (sFP) printf("FP\n");
	else printf("MP\n");
	for (i=1;i<=n;++i,puts(""))
		if (a[i].hp) 
			for (j=1;j<=a[i].n;++j) 
				if (a[i].a[a[i].card[j]-'A']) a[i].a[a[i].card[j]-'A']--;
				else cout<<a[i].card[j]<<" ";
		else printf("DEAD");
	return 0;
}
```

---

## 作者：hht2005 (赞：5)

[My](https://blog.csdn.net/qq_42993486/article/details/100876881) [blog](https://www.cnblogs.com/hht2005/p/11526075.html)
# 题目链接：
[洛谷P2482](https://www.luogu.org/problem/P2482)

[loj2885](https://loj.ac/problem/2885)

[bzoj1972](https://www.lydsy.com/JudgeOnline/problem.php?id=1972)

推荐去loj看题，可以下数据~~因为特别容易出错~~。
# sol
其实这题码量也没那大，格式化后我的代码只有141行，在loj目前最短。最好多些一些函数，给每个猪开一个结构体。

## 游戏结束、一些数组/变量

之所以一开始就写结束，是因为以后要用。

```cpp
void end() {
	puts(a[1].xue?"MP":"FP");//判断输赢
	for(int i=1; i<=n; i++) {//输出每只猪的状态
		if(a[i].xue==0)puts("DEAD");
		else {
			for(int j=0; j<a[i].s-1; j++)
				printf("%c ",a[i].pai[j]);
			if(a[i].s)printf("%c",a[i].pai[a[i].s-1]);
			puts("");
		}
	}
	exit(0);//退出整个程序
}
```
数组/变量
```cpp
int nxt[15],las[15],top,f,n,m;
//nxt,las为链表，后会解释，top为牌堆顶，f为反猪数量，n为总猪数，m为总牌数
char tem[5],paidui[2010];//tem用来输入，paidui就是牌堆
```
## 每个猪的结构体：
```cpp
struct pig {
	char tp,pai[2010];//tp:真实身份,M主猪,Z忠猪,F反猪,pai:手牌
	int xue,s,z,t;
	//xue:血量,s:牌数,z:是否有猪哥连弩(Z),t:表面身份,0:未知,1:忠猪,2:反猪,3:类反猪
	void qizhi(int &x) {//将第x张牌弃置
		s--;
		for(int i=x; i<s; i++)
			pai[i]=pai[i+1];
		x--;
	}
	int seach(char ch) {//搜索第一张为ch的牌，有就弃置，返回1，否则返回0
		for(int i=0; i<s; i++)
			if(pai[i]==ch) {
				qizhi(i);
				return 1;
			}
		return 0;
	}
	void mopai(int x) {//从牌堆中摸x张牌
		for(int i=1; i<=x; i++) {
			pai[s++]=paidui[top++];
			if(top==m)top--;
		}
	}
} a[15];
```
弃置我是暴力删，可以用`vector<char>`，然后摸牌有一个bug，牌不够用，要一直摸最后一张牌。

## 献殷勤、表敌意、跳忠、跳反

先`define`两个语句

```cpp
#define dipig(x,y) ((a[x].tp=='M'&&(a[y].t==2||a[y].t==3))||(a[x].tp=='Z'&&a[y].t==2)||(a[x].tp=='F'&&a[y].t==1))
\\x能否对y表敌意
#define youpig(x,y) (((a[x].tp=='M'||a[x].tp=='Z')&&a[y].t==1)||(a[x].tp=='F'&&a[y].t==2))
\\x能否对y献殷勤
\\y若未表明身份则都不能
```
跳忠、跳反很简单，如果他使用了『杀(K)』，『决斗(F)』，『无懈可击(J)』，就表明了身份，那么忠猪跳忠，反猪跳反。这里我把主猪当成一种特殊的忠猪，一开始就跳忠。

## 伤害、死亡

由于猪会死亡，且他们坐成一圈，所以我用了链表。
```cpp
int nxt[15],las[15];//双向链表
void killed(int g,int p) {//g杀死了p
	if(a[p].tp=='M')end();//主猪死了，结束
	if(a[p].tp=='F') {
		if(!--f)end();//没有反猪了，结束
		a[g].mopai(3);//摸三张奖励牌
	} else if(a[p].tp=='Z'&&a[g].tp=='M')a[g].s=a[g].z=0;
	//主猪杀了忠猪，弃置所以牌和装备
	nxt[las[p]]=nxt[p];//从链表从删除p
	las[nxt[p]]=las[p];
}
void kouxue(int x,int y) {//以x为伤害来源，攻击y
	a[y].xue--;
	if(!a[y].xue)a[y].xue+=a[y].seach('P');//濒死，可以吃一个桃
	if(!a[y].xue)killed(x,y);//依然濒死，则y死亡
}
```
## 无懈可击
这是一个特殊的牌，可能可以递归使用。
```cpp
int wxkj(int s,int x) {//无懈可击成功返回1，否则返回0
	for(int i=s,f=0; !f||i!=s; i=nxt[i],f=1) {//从s开始
		if((!x?(dipig(i,s)):(youpig(i,x)))&&a[i].seach('J')) {
		//如果x不为0，说明s对x使用锦囊牌，否则说明s是上一次使用无懈可击
		//根据题意判断是否使用无懈可击
			a[i].t=a[i].tp=='F'?2:1;//i的身份明确
			return !wxkj(i,0);//递归使用无懈可击
		}
	}
	return 0;
}
```
## 主要操作
终于到主要操作了~
```cpp
	int now=1;//now为当前回合的猪
	a[1].t=1;//主猪一开始就跳忠
	if(!f)end();//一开始就没反猪
	while(1) {
		int kill=0;//是否使用过杀
		a[now].mopai(2);//摸2张牌
		for(int i=0; i<a[now].s&&a[now].xue; i++) {//枚举每张牌
			if(a[now].pai[i]=='Z') {//装备一定装备上，不管原来是否装备
				a[now].z=1,a[now].qizhi(i);
				i=-1;//可能之前杀可用，要从头枚举
			} else if(a[now].pai[i]=='P'&&a[now].xue<4) {//有桃一定吃
				a[now].xue++,a[now].qizhi(i);
			} else if(a[now].pai[i]=='K'&&(a[now].z||!kill)) {//能用杀
				int nx=nxt[now];//只能打下一个
				if(dipig(now,nx)) {//能表敌意
					a[now].t=a[now].tp=='F'?2:1;//now身份明确
					a[now].qizhi(i);
					kill=1;
					if(!a[nx].seach('D'))kouxue(now,nx);//nx没闪就扣血
				}
			} else if(a[now].pai[i]=='F') {//有决斗一定用
				for(int j=a[now].tp=='F'?1:nxt[now]; j!=now; j=nxt[j])
				//反猪一定与主猪决斗
					if(dipig(now,j)) {
						a[now].qizhi(i);
						a[now].t=a[now].tp=='F'?2:1;//now身份明确
						if(wxkj(now,j))break;//使用无懈可击
						if(a[j].tp=='Z'&&a[now].tp=='M') {
							kouxue(now,j);//主猪与忠猪决斗忠猪直接扣血
							break;
						}
						int t=1;
						while(1) {//决斗
							if(t==1) {
								if(!a[j].seach('K')) {
									kouxue(now,j);
									break;
								}
							} else if(!a[now].seach('K')) {
								kouxue(j,now),i=max(-1,i-1);
								break;
							}
							t^=1;
						}
						i=-1;
						//决斗可能会导致一些猪使用无懈可击，明确身份，要从头开始枚举牌
						break;
					}
			} else if(a[now].pai[i]=='N'||a[now].pai[i]=='W') {
				//有南猪入侵和万箭齐发一定用
				char ch=a[now].pai[i];//保存是哪种
				a[now].qizhi(i);
				for(int j=nxt[now]; j!=now; j=nxt[j]) {//依次结算
					if(!wxkj(now,j)&&!a[j].seach(ch=='N'?'K':'D')) {
						if(a[j].tp=='M'&&!a[now].t)a[now].t=3;
						//j是主猪，now未表明身份，则now为类反猪
						kouxue(now,j);
					}
				}
				i=-1;//同决斗，要从头开始枚举牌
			}
		}
		now=nxt[now];
	}
```
## 完整代码
注释就不打了
### AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define dipig(x,y) ((a[x].tp=='M'&&(a[y].t==2||a[y].t==3))||(a[x].tp=='Z'&&a[y].t==2)||(a[x].tp=='F'&&a[y].t==1))
#define youpig(x,y) (((a[x].tp=='M'||a[x].tp=='Z')&&a[y].t==1)||(a[x].tp=='F'&&a[y].t==2))
int nxt[15],las[15],top,f,n,m;
char tem[5],paidui[2010];
struct pig {
	char tp,pai[2010];
	int xue,s,z,t;
	void qizhi(int &x) {
		s--;
		for(int i=x; i<s; i++)
			pai[i]=pai[i+1];
		x--;
	}
	int seach(char ch) {
		for(int i=0; i<s; i++)
			if(pai[i]==ch) {
				qizhi(i);
				return 1;
			}
		return 0;
	}
	void mopai(int x) {
		for(int i=1; i<=x; i++) {
			pai[s++]=paidui[top++];
			if(top==m)top--;
		}
	}
} a[15];
void end() {
	puts(a[1].xue?"MP":"FP");
	for(int i=1; i<=n; i++) {
		if(a[i].xue==0)puts("DEAD");
		else {
			for(int j=0; j<a[i].s-1; j++)
				printf("%c ",a[i].pai[j]);
			if(a[i].s)printf("%c",a[i].pai[a[i].s-1]);
			puts("");
		}
	}
	exit(0);
}
void killed(int g,int p) {
	if(a[p].tp=='M')end();
	if(a[p].tp=='F') {
		if(!--f)end();
		a[g].mopai(3);
	} else if(a[p].tp=='Z'&&a[g].tp=='M')a[g].s=a[g].z=0;
	nxt[las[p]]=nxt[p];
	las[nxt[p]]=las[p];
}
void kouxue(int x,int y) {
	a[y].xue--;
	if(!a[y].xue)a[y].xue+=a[y].seach('P');
	if(!a[y].xue)killed(x,y);
}
int wxkj(int s,int x) {
	for(int i=s,f=0; !f||i!=s; i=nxt[i],f=1) {
		if((!x?(dipig(i,s)):(youpig(i,x)))&&a[i].seach('J')) {
			a[i].t=a[i].tp=='F'?2:1;
			return !wxkj(i,0);
		}
	}
	return 0;
}
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; i++) {
		scanf("%s",tem);
		a[i].tp=tem[0];
		f+=tem[0]=='F';
		for(int j=0; j<4; j++)
			cin>>a[i].pai[j];
		nxt[i]=i+1,las[i]=i-1;
		a[i].s=a[i].xue=4;
	}
	for(int i=0; i<m; i++)cin>>paidui[i];
	nxt[n]=1,las[1]=n;
	int now=1;
	a[1].t=1;
	if(!f)end();
	while(1) {
		int kill=0;
		a[now].mopai(2);
		for(int i=0; i<a[now].s&&a[now].xue; i++) {
			if(a[now].pai[i]=='Z') {
				a[now].z=1,a[now].qizhi(i);
				i=-1;
			} else if(a[now].pai[i]=='P'&&a[now].xue<4) {
				a[now].xue++,a[now].qizhi(i);
			} else if(a[now].pai[i]=='K'&&(a[now].z||!kill)) {
				int nx=nxt[now];
				if(dipig(now,nx)) {
					a[now].t=a[now].tp=='F'?2:1;
					a[now].qizhi(i);
					kill=1;
					if(!a[nx].seach('D'))kouxue(now,nx);
				}
			} else if(a[now].pai[i]=='F') {
				for(int j=a[now].tp=='F'?1:nxt[now]; j!=now; j=nxt[j])
					if(dipig(now,j)) {
						a[now].qizhi(i);
						a[now].t=a[now].tp=='F'?2:1;
						if(wxkj(now,j))break;
						if(a[j].tp=='Z'&&a[now].tp=='M') {
							kouxue(now,j);
							break;
						}
						int t=1;
						while(1) {
							if(t==1) {
								if(!a[j].seach('K')) {
									kouxue(now,j);
									break;
								}
							} else if(!a[now].seach('K')) {
								kouxue(j,now),i=max(-1,i-1);
								break;
							}
							t^=1;
						}
						i=-1;
						break;
					}
			} else if(a[now].pai[i]=='N'||a[now].pai[i]=='W') {
				char ch=a[now].pai[i];
				a[now].qizhi(i);
				for(int j=nxt[now]; j!=now; j=nxt[j]) {
					if(!wxkj(now,j)&&!a[j].seach(ch=='N'?'K':'D')) {
						if(a[j].tp=='M'&&!a[now].t)a[now].t=3;
						kouxue(now,j);
					}
				}
				i=-1;
			}
		}
		now=nxt[now];
	}
	return 0;
}
```
### 观战模式
这个代码输出了每一步，每回合，有一个`getchar`
```cpp
#include<bits/stdc++.h>
using namespace std;
#define dipig(x,y) ((a[x].tp=='M'&&(a[y].t==2||a[y].t==3))||(a[x].tp=='Z'&&a[y].t==2)||(a[x].tp=='F'&&a[y].t==1))
#define youpig(x,y) (((a[x].tp=='M'||a[x].tp=='Z')&&a[y].t==1)||(a[x].tp=='F'&&a[y].t==2))
int nxt[15],las[15],top,f,n,m;
char tem[5],paidui[2010];
struct pig {
	char tp,pai[2010];
	int xue,s,z,t;
	void qizhi(int &x) {
		s--;
		for(int i=x; i<s; i++)
			pai[i]=pai[i+1];
		x--;
	}
	int seach(char ch) {
		for(int i=0; i<s; i++)
			if(pai[i]==ch) {
				qizhi(i);
				return 1;
			}
		return 0;
	}
	void mopai(int x) {
		for(int i=1; i<=x; i++) {
			pai[s++]=paidui[top++];
			if(top==m)top--;
		}
	}
} a[15];
void end() {
	puts(a[1].xue?"MP":"FP");
	for(int i=1; i<=n; i++) {
		if(a[i].xue==0)puts("DEAD");
		else {
			for(int j=0; j<a[i].s-1; j++)
				printf("%c ",a[i].pai[j]);
			if(a[i].s)printf("%c",a[i].pai[a[i].s-1]);
			puts("");
		}
	}
	exit(0);
}
void killed(int g,int p) {
	if(a[p].tp=='M')end();
	if(a[p].tp=='F') {
		if(!--f)end();
		a[g].mopai(3);
	} else if(a[p].tp=='Z'&&a[g].tp=='M')a[g].s=a[g].z=0;
	nxt[las[p]]=nxt[p];
	las[nxt[p]]=las[p];
}
void kouxue(int x,int y) {
	a[y].xue--;
	if(!a[y].xue)
		if(a[y].seach('P'))a[y].xue++,cerr<<'P'<<' '<<y<<endl;
	if(!a[y].xue)killed(x,y);
}
int wxkj(int s,int x) {
	for(int i=s,f=0; !f||i!=s; i=nxt[i],f=1) {
		if((!x?(dipig(i,s)):(youpig(i,x)))&&a[i].seach('J')) {
			a[i].t=a[i].tp=='F'?2:1;
			cerr<<'J'<<' '<<i<<endl;
			return !wxkj(i,0);
		}
	}
	return 0;
}
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; i++) {
		scanf("%s",tem);
		a[i].tp=tem[0];
		f+=tem[0]=='F';
		for(int j=0; j<4; j++)
			cin>>a[i].pai[j];
		nxt[i]=i+1,las[i]=i-1;
		a[i].s=a[i].xue=4;
	}
	for(int i=0; i<m; i++)cin>>paidui[i];
	nxt[n]=1,las[1]=n;
	int now=1;
	a[1].t=1;
	if(!f)end();
	while(1) {
		int kill=0;
		a[now].mopai(2);
		getchar();
		cerr<<now<<' '<<a[now].xue<<' '<<a[now].t<<' '<<a[now].z<<endl;
		for(int i=0; i<a[now].s; i++)cerr<<a[now].pai[i]<<' ';
		cerr<<endl;
		for(int i=0; i<a[now].s&&a[now].xue; i++) {
			if(a[now].pai[i]=='Z') {
				cerr<<'Z'<<endl;
				a[now].z=1,a[now].qizhi(i);
				i=-1;
			} else if(a[now].pai[i]=='P'&&a[now].xue<4) {
				cerr<<'P'<<endl;
				a[now].xue++,a[now].qizhi(i);
			} else if(a[now].pai[i]=='K'&&(a[now].z||!kill)) {
				int nx=nxt[now];
				if(dipig(now,nx)) {
					cerr<<'K'<<' '<<nx<<endl;
					a[now].t=a[now].tp=='F'?2:1;
					a[now].qizhi(i);
					kill=1;
					if(!a[nx].seach('D'))kouxue(now,nx);
					else cerr<<'D'<<endl;
				}
			} else if(a[now].pai[i]=='F') {
				for(int j=a[now].tp=='F'?1:nxt[now]; j!=now; j=nxt[j])
					if(dipig(now,j)) {
						cerr<<'F'<<' '<<j<<endl;
						a[now].qizhi(i);
						a[now].t=a[now].tp=='F'?2:1;
						if(wxkj(now,j))break;
						if(a[j].tp=='Z'&&a[now].tp=='M') {
							kouxue(now,j);
							break;
						}
						int t=1;
						while(1) {
							if(t==1) {
								if(!a[j].seach('K')) {
									kouxue(now,j);
									break;
								} else cerr<<'K'<<endl;
							} else if(!a[now].seach('K')) {
								kouxue(j,now),i=max(-1,i-1);
								break;
							} else cerr<<'K'<<endl;
							t^=1;
						}
						i=-1;
						break;
					}
			} else if(a[now].pai[i]=='N'||a[now].pai[i]=='W') {
				char ch=a[now].pai[i];
				a[now].qizhi(i);
				cerr<<ch<<endl;
				for(int j=nxt[now]; j!=now; j=nxt[j]) {
					if(wxkj(now,j))continue;
					if(!a[j].seach(ch=='N'?'K':'D')) {
						if(a[j].tp=='M'&&!a[now].t)a[now].t=3;
						kouxue(now,j);
					} else cerr<<(ch=='N'?'K':'D')<<endl;
				}
				i=-1;
			}
		}
		now=nxt[now];
	}
	return 0;
}
```

---

## 作者：S_S_H (赞：5)

## SDOI最毒瘤题目-------猪国杀？
### 我真心吐槽一句这题定义变量都是个问题

三伙人：忠臣，反贼，主公（分清敌我关系）

简化题意：

1.主公忠臣一伙，反贼单独一伙

2.表敌意：对自己不同伙的人使用杀、决或使用无懈可击（人家出牌你无懈可击你肯定是表敌意啊）

3.献殷勤：就是帮你伙的人用无懈可击挡伤害（这个题不能给别人用桃）

4.行动准则：每个角色如果手里有桃且生命值未满，那么必然吃掉；有南猪入侵、万箭齐发、必然使用；有装备必然装上；受到杀时，有闪必然弃置；响应南猪入侵或者万箭齐发时候，有杀/闪必然弃置；不会对未表明身份的猪献殷勤（包括自己）；（其实这就是手里除了杀啥都用）

5.类反贼：就是比如忠臣用了南蛮入侵，主公没杀，那么
主公扣血，出牌者被标为类反贼.但是如果之后这个人帮主公用了无懈可击，他就会成为忠臣（跳忠），如果他杀主公，他就成为了反贼（跳反）；跳反跳忠后身份不再改变（因为你本来就是这个身份啊）

6.主公出牌时会对反贼或！类反贼！表敌意（杀他）

7.忠臣出牌时会反贼！（没有类反贼）！表敌意

8.反贼会优先杀主公，杀不了杀忠臣

9.所有人一定会尽力帮自己伙的人（献殷勤）

10.数据不保证卡牌够用！！！（嘶———）

以上十点记住就好，如果你没玩过三国杀题意不明白但请继续看，会有讲解的，一些细节我会在下面给出

#### 代码思路（借鉴夜刀神十香大佬）

首先定义变量：

1.血量，卡牌数，身份，卡牌是啥，诸葛连弩是否装备

2.因为我们用环形链表（数组模拟）一个圈，就要存这个人的上一位和下一位，存上一位是因为如果这个人死了，我们需要使他上一位的下一位变成这个人的下一位（就是更新环状关系，因为他死了就相当于删掉了）

```cpp
struct node{
	int hp,cs,id,next,last;
        //hp血量，cs卡牌数，id是身份,last是他上一位人的编号，next是他下一位人的编号
	char card[3000];
        //card是他牌的属性
	bool zgln;
        //诸葛连弩有没有
}a[20];
char kn[20],kpd[2300],s[10];//kn存现在牌局我们已暴露的这个人是啥，因为有类反贼这个东西，kpd表示卡牌堆的牌，s是输入用的先不管
int n,m,fz;//n记录人数,m记录摸牌时卡牌堆的卡牌编号,fz记录反贼的数量
bool flag;//表示游戏结没结束，即反贼数(fz)是否为零，主公死没死
```
定义变量完成。。。

读入数据：

我们首先定义：
|  定义|  字母表示|
| :----------- | :----------- |
|  桃|  P|
|  杀|  K|
|  闪|  D|
|  决斗|  F|
|  南蛮入侵|  N|
|  万箭齐发|  W|
|  无懈可击|  J|
|  诸葛连弩|  Z|
|  没有（卡牌）|  U|
|  身份不确定|  U|
|  主公 |M 
|  忠臣 |Z
|  反贼 |F
|  类反贼|L

好了...
```cpp
scanf("%d%d",&n,&m);
for(int i=1;i<=n;i++) a[i].next=i+1,a[i].last=i-1;
a[n].next=1;
a[1].last=n;//存前后人
for(int i=1;i<=n;i++){
	for(int j=1;j<=2990;j++) a[i].card[j]='U';//初始化
		scanf("%s",s);//读入数据scanf不识别空格读入的就是比如"F "
		a[i].id=s[0];
		for(int j=1;j<=4;j++){
			scanf("%s",s);
			a[i].card[j]=s[0];
		}
		a[i].cs=a[i].hp=4;//血量
		if(a[i].id=='F') fz++;//反贼数
		a[i].zgln=false;//初始化诸葛连弩
	}
	for(int i=2;i<=n;i++) 
		kn[i]='U';//初始化身份
	kn[1]='M';//主公身份为M
	for(int i=1;i<=m;i++)
		scanf("%s",s),kpd[m-i+1]=s[0];//卡牌堆从上到下
```
我们机房第一的大佬nederland读了数据就自闭了（我们当然也自闭了）

回合开始：
```cpp
void zgswcnm(){
	char now;//当前的牌
	flag=true;
	if(fz) flag=false;//如果没有反贼就退出
	if(flag) return;//如果游戏结束退出
	for(int i=1;i;i=a[i].next){//环状无限循环，中间你改成i!=-999什么的都可以..
		mp(i),mp(i);//摸牌，可以跳过一会会讲
		bool kill=true;//可以杀
		for(int j=1;j<=a[i].cs;j++)//遍历这个人的卡牌
			if(a[i].card[j]!='U'){
				if(!a[i].hp) break;//血空
				now=a[i].card[j];
				if(now=='P'){//桃就判断一下直接用
					if(a[i].hp!=4){
						a[i].hp++;
						a[i].card[j]='U';
					}
					continue;
				}
				if(now=='K'){//杀
					if(!kill&&!a[i].zgln) continue;//如果不能杀并且没有诸葛连弩，退出
					//因为装不装诸葛连弩攻击范围都是一，且看看题里的说明，就只能攻击他下一个人	
    	            if(a[i].id=='M'&&kn[a[i].next]!='L'&&kn[a[i].next]!='F') continue;//如果主忠就不杀
					if(a[i].id=='Z'&&kn[a[i].next]!='F') continue;//如果是忠臣就只能杀反贼！！！忠臣不会杀类反贼！！！
					if(a[i].id=='F'&&kn[a[i].next]!='Z'&&kn[a[i].next]!='M') continue;//如果反贼就只能杀忠臣
					a[i].card[j]='U';//卡牌用掉了
					Kil(i,a[i].next);//函数Kil
					kn[i]=a[i].id;//这个人身份暴露了
					kill=false;//杀不了了
					if(flag) return;
					continue;//判定
				}
				if(now=='F'){//决斗
					if(a[i].id=='F'){
						a[i].card[j]='U';
						jd(i,1);//还要写函数（这反贼决斗主公）
						kn[i]=a[i].id;
						if(flag) return;
						j=0;
						continue;
					}
					for(int k=a[i].next;k!=i;k=a[k].next){
						if((a[i].id=='M' && (kn[k]=='L' || kn[k]=='F')) || (a[i].id=='Z' && kn[k]=='F'))
                        {
                            //主公忠臣方（注意！忠臣不会杀类反贼！）
                            a[i].card[j]='U',jd(i,k);
                            kn[i]=a[i].id;
                            if(flag) return ;
                            j=0;
                            break;
                        }
					}
					continue;
				}
				if(now=='N'){//南蛮入侵函数
					a[i].card[j]='U';
					nmrq(i);
					if(flag) return;
					j=0;
					continue;
				}
				if(now=='W'){//万箭齐发函数
					a[i].card[j]='U';
					wjqf(i);
					if(flag) return;
					j=0;
					continue;
				}
				if(now=='Z'){//诸葛连弩
					a[i].zgln=true;//装备
					a[i].card[j]='U';
					j=0;
					continue;
				}
			}
	}
}
```

我们统计一下我们要写几个函数：

1.mp函数（摸牌）

2.Kil函数（杀）

3.js函数（击杀）

4.jd函数（决斗）

5.nmrq函数（南蛮入侵）

6.wjqf函数（万箭齐发）

好吧

1.mp函数（摸牌）：
```cpp
void mp(int x){
	if(!m) m++;
	a[x].card[++a[x].cs]=kpd[m];
    m--;
}
```

这个应该可以理解吧

2.Kil函数（杀）：
```cpp
void Kil(int x1,int x2){//x1杀x2
    for(int i=1;i<=a[x2].cs;i++)
        if(a[x2].card[i]=='D'){//x2有闪 
            a[x2].card[i]='U';
            return ;
        }
    a[x2].hp--;
    if(!a[x2].hp) js(x1,x2);
    //每次造成伤害都要判断被攻击者是否空血
    //然后进入【击杀】环节 （击杀写在Kil前）
}
```
3.js函数（击杀）：
```cpp
void js(int x1,int x2){//x1击杀x2
    for(int i=1;i<=a[x2].cs;i++)
        if(a[x2].card[i]=='P'){//判断有没有桃
            a[x2].card[i]='U';
            a[x2].hp++;
            return;
        }
    a[a[x2].next].last=a[x2].last;//如果这人死了就更新环状关系
    a[a[x2].last].next=a[x2].next;
    if(x2==1){
	flag=1;//如果主公死了
	return;
	}
    if(a[x2].id=='F') 
		fz--;
    if(!fz){//如果反贼死了
		flag=1;
		return;
	}
    //没有反贼游戏结束 
    //注意！！！！！游戏结束不能摸牌，一定写在前面！！！！！
    if(a[x2].id=='F') 
		mp(x1),mp(x1),mp(x1);
    //击杀反贼摸三张牌 
    if(a[x2].id=='Z'&&a[x1].id=='M') 
		a[x1].cs=0,a[x1].zgln=false;
    //如果主公把忠臣杀了那就要弃牌 
}
```
接下来是三张锦囊牌以及无懈可击（恶心）

无懈可击：

```cpp
bool wxkj(int x1,int x2,int x3){//表示从x2开始是否有人是否无懈可击x1并向下递归
	int i=x1;
    //我们记录x1
	while(true){
		if(x3==1){//我认为x3==1表示第一次因为被使用锦囊牌的人一定会试图通过自己或自己一伙的人请求无懈可击
			if(kn[x2]==a[i].id||(kn[x2]=='M'&&a[i].id=='Z')||(kn[x2]=='Z'&&a[i].id=='M')){//如果是一伙的
				for(int j=1;j<=a[i].cs;j++){
					if(a[i].card[j]=='J'){
						a[i].card[j]='U';
						kn[i]=a[i].id;//找到了无懈可击并使用
						return !wxkj(i,x1,0);//那么我们看是否敌方会无懈可击我们的无懈可击（玄学），返回值下面讲解
					}
				}
			}
		}
		else{
			if(((a[i].id=='M' || a[i].id=='Z') && kn[x1]=='F') || (a[i].id=='F' && (kn[x1]=='M' || kn[x1]=='Z'))){//不是一伙的
				for(int j=1;j<=a[i].cs;j++){
					if(a[i].card[j]=='J'){
						a[i].card[j]='U';
						kn[i]=a[i].id;
						return !wxkj(i,x1,0);//那我们找开始的友军是不是就相当于找他敌军的敌军？（看下面）
					}
				}
			}
		}
		i=a[i].next;//更新i,如果下一次while循环时i时刚才使用无懈可击人的地方,那i有无懈可击就一定会出，往返递归下去
		if(i==x1) break;//如果找了一遍，没有符合条件（敌军且有无懈可击）的人，就退出
	}
	return false;//这个就很NB，比如我们返回时返回的是false，那么表示我找敌军没成功，就可以用这张牌，返回false.....你可以自己模拟模拟，反复取反。如果返回数是奇数，就说明这张牌被无懈可击掉了，反之没有
}
```

这是夜刀神十香大佬代码我蒙了（太强了 tql orz）...

真的这个没有点东西写不出来...

好了那么接下来的代码就简单了

4.jd函数（决斗）：

```cpp
void jd(int x1,int x2){
	int i,j,k;
	if(wxkj(x1,x2,1)) return;//无懈可击判断
	if(x1==1&&a[x2].id=='Z'){
		a[x2].hp--;
		if(!a[x2].hp) js(x1,x2);//第一遍扫主公杀忠臣其实可以写在函数里面
		return;
	}
	j=k=1;//j存x1,k存x2
	while(true){
		while(a[x2].card[j]!='K'&&j<=a[x2].cs) j++;
		if(j>a[x2].cs){//没找到
			a[x2].hp--;
			if(!a[x2].hp) js(x1,x2);
			return;
		}
		else a[x2].card[j]='U';
		while(a[x1].card[k]!='K'&&k<=a[x1].cs) k++;
		if(k>a[x1].cs){//一样
			a[x1].hp--;
			if(!a[x1].hp) js(x2,x1);
			return;
		}
		else a[x1].card[k]='U';
	}
}
```


5.nmrq函数（南蛮入侵）：

```cpp
void nmrq(int x1){
	for(int x2=a[x1].next;x2!=x1;x2=a[x2].next){
		if(!wxkj(x1,x2,1)){//如果没被无懈可击
			int i;
			for(i=1;i<=a[x2].cs;i++)
				if(a[x2].card[i]=='K'){
					a[x2].card[i]='U';
					break;//找杀
				}
			if(i>a[x2].cs){
				a[x2].hp--;//如果没杀
				if(x2==1&&kn[x1]=='U') kn[x1]='L';
				if(!a[x2].hp) js(x1,x2);//一定判断击杀
				if(flag) return;
				}
		}
	}
}
```

6.wjqf函数（万箭齐发）：（不解释了和南蛮入侵一样）

```cpp
void wjqf(int x1){
	for(int x2=a[x1].next;x2!=x1;x2=a[x2].next){
		if(!wxkj(x1,x2,1)){
			int i;
			for(i=1;i<=a[x2].cs;i++)
				if(a[x2].card[i]=='D'){
					a[x2].card[i]='U';
					break;
				}
			if(i>a[x2].cs){
				a[x2].hp--;
				if(x2==1&&kn[x1]=='U') kn[x1]='L';
				if(!a[x2].hp) js(x1,x2);
				if(flag) return;
				}
		}
	}
}
```

终于写完了....

完整代码：
```cpp
/*
桃 P
杀 K
闪 D
决斗 F
南蛮入侵 N
万箭齐发 W
无懈可击 J
诸葛连弩 Z
*/
#include<iostream>
#include<cstdio>
using namespace std;
struct node{
	int hp,cs,id,next,last;
	char card[3000];
	bool zgln;
}a[20];
char kn[20],kpd[2300],s[10];
int n,m,fz;
bool flag;
void mp(int x){
	if(!m) m++;
	a[x].card[++a[x].cs]=kpd[m];
    m--;
}
void js(int x1,int x2){//x1击杀x2
    for(int i=1;i<=a[x2].cs;i++)
        if(a[x2].card[i]=='P'){
            a[x2].card[i]='U';
            a[x2].hp++;
            return;
        }
    a[a[x2].next].last=a[x2].last;
    a[a[x2].last].next=a[x2].next;
    if(x2==1){
	flag=1;
	return;
	}
    if(a[x2].id=='F') 
		fz--;
    if(!fz){
		flag=1;
		return;
	}
    //没有反贼游戏结束 
    if(a[x2].id=='F') 
		mp(x1),mp(x1),mp(x1);
    //击杀反贼摸三张牌 
    if(a[x2].id=='Z'&&a[x1].id=='M') 
		a[x1].cs=0,a[x1].zgln=false;
    //如果主公把忠臣杀了那就要弃牌 
}
void Kil(int x1,int x2)
//【杀】 
{
    for(int i=1;i<=a[x2].cs;i++)
        if(a[x2].card[i]=='D'){//x2有闪 
            a[x2].card[i]='U';
            return ;
        }
    a[x2].hp--;
    if(!a[x2].hp) js(x1,x2);
    //每次造成伤害都要判断被攻击者是否空血
    //然后进入【击杀】环节 
}
bool wxkj(int x1,int x2,int x3){
	int i=x1;
	while(true){
		if(x3==1){
			if(kn[x2]==a[i].id||(kn[x2]=='M'&&a[i].id=='Z')||(kn[x2]=='Z'&&a[i].id=='M')){
				for(int j=1;j<=a[i].cs;j++){
					if(a[i].card[j]=='J'){
						a[i].card[j]='U';
						kn[i]=a[i].id;
						return !wxkj(i,x1,0);
					}
				}
			}
		}
		else{
			if(((a[i].id=='M' || a[i].id=='Z') && kn[x1]=='F') || (a[i].id=='F' && (kn[x1]=='M' || kn[x1]=='Z'))){
				for(int j=1;j<=a[i].cs;j++){
					if(a[i].card[j]=='J'){
						a[i].card[j]='U';
						kn[i]=a[i].id;
						return !wxkj(i,x1,0);
					}
				}
			}
		}
		i=a[i].next;
		if(i==x1) break;
	}
	return false;
}
void nmrq(int x1){
	for(int x2=a[x1].next;x2!=x1;x2=a[x2].next){
		if(!wxkj(x1,x2,1)){
			int i;
			for(i=1;i<=a[x2].cs;i++)
				if(a[x2].card[i]=='K'){
					a[x2].card[i]='U';
					break;
				}
			if(i>a[x2].cs){
				a[x2].hp--;
				if(x2==1&&kn[x1]=='U') kn[x1]='L';
				if(!a[x2].hp) js(x1,x2);
				if(flag) return;
				}
		}
	}
}
void wjqf(int x1){
	for(int x2=a[x1].next;x2!=x1;x2=a[x2].next){
		if(!wxkj(x1,x2,1)){
			int i;
			for(i=1;i<=a[x2].cs;i++)
				if(a[x2].card[i]=='D'){
					a[x2].card[i]='U';
					break;
				}
			if(i>a[x2].cs){
				a[x2].hp--;
				if(x2==1&&kn[x1]=='U') kn[x1]='L';
				if(!a[x2].hp) js(x1,x2);
				if(flag) return;
				}
		}
	}
}
void jd(int x1,int x2){
	int i,j,k;
	if(wxkj(x1,x2,1)) return;
	if(x1==1&&a[x2].id=='Z'){
		a[x2].hp--;
		if(!a[x2].hp) js(x1,x2);
		return;
	}
	j=k=1;
	while(true){
		while(a[x2].card[j]!='K'&&j<=a[x2].cs) j++;
		if(j>a[x2].cs){
			a[x2].hp--;
			if(!a[x2].hp) js(x1,x2);
			return;
		}
		else a[x2].card[j]='U';
		while(a[x1].card[k]!='K'&&k<=a[x1].cs) k++;
		if(k>a[x1].cs){
			a[x1].hp--;
			if(!a[x1].hp) js(x2,x1);
			return;
		}
		else a[x1].card[k]='U';
	}
}
void zgswcnm(){
	char now;
	flag=true;
	if(fz) flag=false;
	if(flag) return;
	for(int i=1;i!=-999;i=a[i].next){
		mp(i),mp(i);
		bool kill=true;
		for(int j=1;j<=a[i].cs;j++)
			if(a[i].card[j]!='U'){
				if(!a[i].hp) break;
				now=a[i].card[j];
				if(now=='P'){
					if(a[i].hp!=4){
						a[i].hp++;
						a[i].card[j]='U';
					}
					continue;
				}
				if(now=='K'){
					if(!kill&&!a[i].zgln) continue;
					if(a[i].id=='M'&&kn[a[i].next]!='L'&&kn[a[i].next]!='F') continue;
					if(a[i].id=='Z'&&kn[a[i].next]!='F') continue;
					if(a[i].id=='F'&&kn[a[i].next]!='Z'&&kn[a[i].next]!='M') continue;
					a[i].card[j]='U';
					Kil(i,a[i].next);
					kn[i]=a[i].id;
					kill=false;
					if(flag) return;
					continue;
				}
				if(now=='F'){
					if(a[i].id=='F'){
						a[i].card[j]='U';
						jd(i,1);
						kn[i]=a[i].id;
						if(flag) return;
						j=0;
						continue;
					}
					for(int k=a[i].next;k!=i;k=a[k].next){
						if((a[i].id=='M' && (kn[k]=='L' || kn[k]=='F')) || (a[i].id=='Z' && kn[k]=='F'))
                        {
                            a[i].card[j]='U',jd(i,k);
                            kn[i]=a[i].id;
                            if(flag) return ;
                            j=0;
                            break;
                        }
					}
					continue;
				}
				if(now=='N'){
					a[i].card[j]='U';
					nmrq(i);
					if(flag) return;
					j=0;
					continue;
				}
				if(now=='W'){
					a[i].card[j]='U';
					wjqf(i);
					if(flag) return;
					j=0;
					continue;
				}
				if(now=='Z'){
					a[i].zgln=true;
					a[i].card[j]='U';
					j=0;
					continue;
				}
			}
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) a[i].next=i+1,a[i].last=i-1;
	a[n].next=1;
	a[1].last=n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=2990;j++) a[i].card[j]='U';
		scanf("%s",s);
		a[i].id=s[0];
		for(int j=1;j<=4;j++){
			scanf("%s",s);
			a[i].card[j]=s[0];
		}
		a[i].cs=a[i].hp=4;
		if(a[i].id=='F') fz++;
		a[i].zgln=false;
	}
	for(int i=2;i<=n;i++) 
		kn[i]='U';
	kn[1]='M';
	for(int i=1;i<=m;i++)
		scanf("%s",s),kpd[m-i+1]=s[0];
	zgswcnm();
	if(a[1].hp>0) printf("MP\n");
	else printf("FP\n");//输出判断
	for(int i=1;i<=n;i++){
		if(a[i].hp<=0) printf("DEAD\n");
		else{
			for(int j=1;j<=a[i].cs;j++)
				if(a[i].card[j]!='U')
					printf("%c ",a[i].card[j]);
			printf("\n");
		}
	}
	return 0;
}	
```

## 祝大家CSP NOI XXXOI RP++! ! !

---

## 作者：huang_yue (赞：5)

从7.20做到8.5，终于A了这题

这篇题解的思路可能有些不同，用到了std::list，继承、多态与虚函数。

## 总体思路

### 响应

玩过三国杀的同学们，可能会记得黄忠技能中有这样一段话：“……，则此【杀】不能被【闪】**响应**。”

这样可以看出，三国杀中，【闪】其实就是一种**响应**手段，而万箭、南蛮与决斗中打出的【杀】和【闪】、濒死的【桃】也都是**响应**。更进一步，扣血回血也能称作响应。

在这个思想下，代码中出现了一个大头函数Player::react()，专门用于响应。

### 多态

许多题解的画风都是：为每种牌单独写个函数，到时候判断是哪种牌，然后调用。

运用C++自带的多态机制，可以让代码更加简洁易懂（~~虽然还是有将近500行~~）。

在下面的代码中，所有卡牌都是Card类的派生类的对象；它们都重载了Card::use()函数。然而要注意，这样的函数必须通过指针调用；所以需要new。

由于这题什么都不卡，所以不需要delete。程序结束会自动释放内存的。

### 小技巧

#### 1

写了很多调试的printf？提交的时候一个一个删很麻烦？
```cpp
#define printf(...) 1
```
这句话可以十分完美的解决这个问题，不过输出就要用cout了。

define为1的原因是，printf()是返回int的函数。其实define成void()也没有关系，但define为空的话可能会CE，比如放在一连串逗号接起来的语句里面。

#### 2
调试出了问题？这题的讨论区里有个挺好的数据生成器，然后拿走这篇题解，去对拍吧:)

如果这篇题解陷入了死循环，那么可能是生成数据的问题。

## 踩坑

下面说一下自己踩过的坑（前面的题解说了的就不说了）：

1. 首先，用完一张牌之后要再扫一遍所有牌；这个时候，如果直接赋值i = cards.begin()，遇到for里的i++会再加1。所以需要特判。
2. 同理，在询问无懈的时候，如果有人出了无懈，需要i = (正在执行的武将)，遇到for里的i++也会加1，也要特判。
3. 读入牌的时候"\r\n"可能造成读不进去；还要记住isblank()和isspace()的区别。
4. 【决斗】使用的那一刻就可以判断身份了，而不是生效了才判断，因为可能根本不能生效。
5. 用完的手牌最好不要直接删，而是打个标记等下回合再删。因为如果这是在响应过程中，删牌可能会把list::iterator弄乱。
6. 同理，如果在自己的回合死亡，也不要急着cards.clear()，否则list::iterator也会乱掉。
7. 删牌的时候不能直接cards.erase(i)，否则循环就坏了。
8. 主公的身份一直都是已知的。
9. Player在数组中存储。但是通过list<>访问的时候需要用Player*，否则改不了数组里的值。
10. 南蛮万箭容易写成一旦被无懈就对任何人都不生效，需要注意。
11. 在一直摸最后一张牌的时候，因为用的是指针，不能直接赋值（否则所有人都是用的同一张牌），需要复制一张再赋值。
12. 提交的时候要删掉freopen()。（当然，也可以用上面的define小技巧）

最后推一下自己的[博客](https://www.luogu.org/blog/user64757/)，然后上代码。

## 代码

### 类与变量的定义

其中有些变量可能是以前的代码中用过，后来不需要了的变量。

```cpp
enum Event {			//标记各种响应的事件
	slashed, 		//被杀
	recovered, 		//回血（吃桃）
	nullification, 		//无懈可击
	dueled, 		//被决斗指定为目标
	duel_affected,		//决斗中，需要出【杀】
	savage_assulted, 	//被南蛮
	archery_attacked,	//被万箭
	damaged,		//被扣血
	dying, 			//0血，濒死
	inf_slash 		//装备诸葛弩
};

struct Sudden_death {}; //在自己的回合中突然去世
struct Player;
struct Card {
	char self; 	//代表自己的字符（比如K, F, D, N）
	int type;	//自己的种类（用于后面的filter()）
	bool used;	//是否用过
	virtual void use(Player*, list<Player*>) { } //给子类重载用的，每使用一张牌都会调用它的use()
};

typedef list<Card*> Pile;	//牌堆
Pile pile;

struct Player {
	Pile cards;	//手牌
	int role; 	//身份。1: 主; 2: 忠; 3: 反
	int seem; 	//跳的身份。0: 没跳; 1: 类反; 2: 忠; 3: 反
	int hp;		//剩余体力
	bool dead;	//是否死亡
	bool used_slash;//是否用了杀
	bool inf_slash;	//是否装了连弩

	void set_role(const string&);	//把MP ZP FP转化成身份
	void execute();			//执行回合
	void react(Event, Player*);	//响应Player*造成的事件
	void draw_cards(int);		//摸牌
	bool usable(const Card*);	//该牌是否能用
	bool is_friend(const Player*);	//对方是否队友

	Pile::iterator ask_for(char);	//找一张对应字符的牌

	Player() : hp(4) {}	//初始化：hp = 4
} players[12];
int loyalist, rebellion;	//分别是忠臣数与反贼数
int executing; 			//正在执行回合的人
bool is_effective = true, effect_changed; //用于无懈可击
bool death_caused;		//回合内是否杀死角色
list<Player*> targets;		//一张牌的目标
```

### 各种牌的定义
use(Player* from, list<Player*> x)中，from是这张牌的使用者，x是这张牌的目标；如果x为空，则这张牌不能使用。

下面的部分应该比较浅显易懂，就不过多解释了。
```cpp
struct Slash : Card {
	Slash() { type = 1; }
	void use(Player* from, list<Player*> x) {
		if (!x.size()) return;
		(*x.begin())->react(slashed, from);
	}
};

struct Peach : Card {
	Peach() { type = 2; }
	void use(Player* from, list<Player*> x) {
		(*x.begin())->react(recovered, from);
	}
};

struct Duel : Card {
	Duel() { type = 3; }
	void use(Player* from, list<Player*> x) {
		if (!x.size()) return;
		(*x.begin())->react(dueled, from); //成为了目标，确定对方身份
	again: //善用goto
		for (int j = executing; players[j].role; ++j)
			if (players[j].react(nullification, *x.begin()), effect_changed)
				effect_changed = false, j = executing - 1;
		for (int j = 0; j < executing; ++j)
			if (players[j].react(nullification, *x.begin()), effect_changed) {
				goto again;
				effect_changed = false;
			} //这全都是处理无懈可击的代码
		if (is_effective)
			(*x.begin())->react(duel_affected, from);
		is_effective = true;
	}
};

struct SavageAssault : Card {
	SavageAssault() { type = 4; }
	void use(Player* from, list<Player*> x) {
		for (list<Player*>::iterator i = x.begin(); i != x.end(); ++i) {
		again:
			for (int j = executing; players[j].role; ++j)
				if (players[j].react(nullification, *i), effect_changed)
					effect_changed = false, j = executing - 1;
			for (int j = 0; j < executing; ++j)
				if (players[j].react(nullification, *i), effect_changed) {
					goto again;
					effect_changed = false;
				}
			if (is_effective)
				(*i)->react(savage_assulted, from);
			is_effective = true;
		}
	}
};

struct ArcheryAttack : Card {
	ArcheryAttack() { type = 5; }
	void use(Player* from, list<Player*> x) {
		for (list<Player*>::iterator i = x.begin(); i != x.end(); ++i) {
		again:
			for (int j = executing; players[j].role; ++j)
				if (players[j].react(nullification, *i), effect_changed)
					effect_changed = false, j = executing - 1;
			for (int j = 0; j < executing; ++j)
				if (players[j].react(nullification, *i), effect_changed) {
					goto again;
					effect_changed = false;
				}
			if (is_effective)
				(*i)->react(archery_attacked, from);
			is_effective = true;
		}
	}
};

struct Liannu : Card {
	Liannu() { type = 6; }
	void use(Player* from, list<Player*> x) {
		(*x.begin())->react(inf_slash, from);
	}
};
```
### Player的各种函数
```cpp
void Player::set_role(const string& x) { //这个写起来很简单
	if (x == "MP") role = 1;
	if (x == "ZP") role = 2;
	if (x == "FP") role = 3;
}

void Player::execute() {
	if (dead)
		return;
	printf("\nIt's Player #%d's turn.\n", executing); //记得吗？printf()都被define掉了
	draw_cards(2);
	bool flag = false; //为了特判有没有重置循环变量i
	for (Pile::iterator i = cards.begin(); i != cards.end(); flag ? flag = false, i : ++i) //删掉用过的牌（这里不会出现响应，所以可以放心删）
		if ((*i)->used) {
			Pile::iterator other = i; ++i;
			cards.erase(other); flag = true;
		}
	flag = false;
	for (Pile::iterator i = cards.begin(); i != cards.end(); flag ? flag = false, i : ++i)
		if (usable(*i)) { //判断是否出过杀的操作已经在usable()中完成了
			Card* card = *i;
			card->used = true;
			printf("Player #%d used %c.\n", executing, card->self);
			card->use(this, targets);
			if (card->self == 'P') continue;
			i = cards.begin(); flag = true;
		}
	used_slash = false;
	printf("Player #%d ended his stage.\n", executing);
}

bool Player::is_friend(const Player* x) {
	switch (role) {
	case 1:
		return x->seem == 2; //主公的seem也设为了2，因为与忠臣的表现十分相似
	case 2:
		return x->seem && x->seem != 3;
	case 3:
		return x->seem == 3;
	default:
		return false;
	}
}

Pile::iterator Player::ask_for(char x) { //其实可以用std::find()，但是调用麻烦
	for (Pile::iterator i = cards.begin(); i != cards.end(); ++i)
		if (!(*i)->used && (*i)->self == x)
			return i;
	return cards.end();
}

void Player::react(Event ev, Player* from) {
	switch (ev) {

	case slashed: {
		if (seem == 2) //更新身份
			from->seem = 3;
		if (seem == 3)
			from->seem = 2;
		Pile::iterator i = ask_for('D'); //找闪，没有扣血
		if (i == cards.end())
			react(damaged, from);
		else
			(*i)->used = true;
		break;
	}
	case archery_attacked: {
		Pile::iterator i = ask_for('D');
		if (i == cards.end()) {
			if (role == 1 && !from->seem) //类反猪的特判
				from->seem = 1;
			react(damaged, from);
		}
		else (*i)->used = true;
		break;
	}
	case dueled: 
		if (seem == 2) //只判断身份，别的留给duel_affected做
			from->seem = 3;
		if (seem == 3)
			from->seem = 2;
		break;
	case duel_affected: {
		Pile::iterator i = ask_for('K');
		if (i == cards.end() || (role == 2 && from->role == 1)) //忠臣被主公决斗需要直接扣血
			react(damaged, from);
		else
			(*i)->used = true, from->react(duel_affected, this);
            		//交换决斗双方，轮到使用者出杀了
		break;
	}
	case savage_assulted: {
		Pile::iterator i = ask_for('K');
		if (i == cards.end()) {
			if (role == 1 && !from->seem) //与万箭比较像
				from->seem = 1;
			react(damaged, from);
		}
		else (*i)->used = true;
		break;
	}
	case nullification:
		if (from->seem < 2) break; //没跳身份，不管
		if (is_friend(from) ^ !is_effective) { //这个不太好解释清，可以枚举一下true和false体会一下
			Pile::iterator i = ask_for('J');
			if (i != cards.end()) {
				(*i)->used = true;
				if ((from->seem == 3) ^ (is_effective = !is_effective)) //这个也是
					seem = 3;
				else seem = 2;
				effect_changed = true;
				printf("Nullificated by a pig seeming like %d.\n", seem);
			}
		}
		break;
	case damaged:
		for (int i = 0; i < 10; ++i)
			if (&players[i] == this)
				printf("Player #%d is damaged by Player #%d, having hp %d.\n", i, executing, hp - 1);
		if (role == 1 && from->seem < 2)
		    from->seem = 1;
		if (--hp <= 0)
			react(dying, from);
		break;
	case dying: {
		Pile::iterator i;
		while (hp <= 0 && (i = ask_for('P')) != cards.end()) //濒死
			(*i)->used = true, ++hp;
		if (hp <= 0) {
			dead = true;
			death_caused = true;
			if (from->role == 1 && role == 2) { //主公杀忠臣，此时可能在主公的回合内，所以不能直接clear()
				for (Pile::iterator it = from->cards.begin(); it != from->cards.end(); ++it)
					(*it)->used = true;
				from->inf_slash = false;
			}
			if (role == 3) { //一名角色死亡后，要更新对应的身份计数
				if (!--rebellion) //反贼死光了就游戏结束，用throw快速退到main()里的try-catch块中
					throw 0;
				from->draw_cards(3);
			}
			if (role == 2)
				--loyalist;
			if (role == 1)
				throw 0;
			if (&players[executing] != this) //死的不是当前回合角色的话可以放心删牌
				cards.clear();
			else for (Pile::iterator it = cards.begin(); it != cards.end(); ++it) //否则不行
				(*it)->used = true;
		}
		break;
	}
	case ::inf_slash: //全局的inf_slash和Player::inf_slash重名，要注意一下
		inf_slash = true;
		break;
	case recovered:
		++hp;
		break;
	}

}

bool Player::usable(const Card* x) {
	if (x->used) return false; //用过了当然就不能用了
	bool used_slash_old = used_slash; //filter()可能会更改used_slash
	targets = filter(x, this); //filter()的作用是选择可能的目标
	if (!targets.size()) return false; //要是没有目标就用不了
	switch (x->self) {
	case 'K':
		return inf_slash || !used_slash_old;
	case 'P':
		return hp < 4;
	case 'Z':
	case 'F':
	case 'N':
	case 'W':
		return true;
	default:
		return false;
	}
}

void Player::draw_cards(int x) {
	while (x--) {
		cards.push_back(*pile.begin());
		if (pile.size() != 2) //由于奇怪的原因，最后一张“牌”一定是'\r'，所以就剩两张的时候就不能再摸了
			pile.pop_front();
		else { //只有最后一张牌的时候要一直摸，而且是复制一张
			Card* x = *pile.begin();
			Card* c;
			switch (x->type) {
			case 5:
				c = new ArcheryAttack(); break;
			case 4:
				c = new SavageAssault(); break;
			case 1:
				c = new Slash(); break;
			case 6:
				c = new Liannu(); break;
			case 3:
				c = new Duel(); break;
			case 2:
				c = new Peach(); break;
			default:
				c = new Card();
			}
			c->used = false;
			c->self = x->self;
			pile.pop_front();
			pile.push_front(c);
		}
	}
}
```

### 其他函数
```cpp
Card* read_card() { //读牌
	while (isspace(cin.peek())) cin.get(); //cin.peek():其实就是cin.get()，但是下一次get()的时候get到的是这个字符而不是下一个
	char self = cin.get();
	Card* c;
	switch (self) {
	case 'W':
		c = new ArcheryAttack(); break;
	case 'N':
		c = new SavageAssault(); break;
	case 'K':
		c = new Slash(); break;
	case 'Z':
		c = new Liannu(); break;
	case 'F':
		c = new Duel(); break;
	case 'P':
		c = new Peach(); break;
	default:
		c = new Card();
	}
	c->self = self;
	c->used = false;
	return c;
}

list<Player*> filter(const Card* x, Player* from) {
	list<Player*> ans(0); //所有目标
	if (x->type == 4 || x->type == 5) { //南蛮万箭，需要顺次把玩家加入目标
		for (int i = executing + 1; i < 12; ++i)
			if (!players[i].role) break;
			else if (!players[i].dead)
				ans.push_back(&players[i]);
		for (int i = 0; i < executing; ++i)
			if (!players[i].dead)
				ans.push_back(&players[i]);
		return ans;
	}
	if (x->type == 3) { //决斗
		for (int i = executing + 1; i < 12; ++i) {
			if (!players[i].role) break;
			if (players[i].dead) continue;
			if (from->role == 3) { //反贼直接找主公
				ans.push_back(&players[0]);
				return ans;
			}
			if (from->role == 2 && players[i].seem == 3) { //忠臣找反贼
				ans.push_back(&players[i]);
				return ans;
			}
			if (from->role == 1 && players[i].seem != 2 && players[i].seem != 0) { //主公找反贼和类反猪
				ans.push_back(&players[i]);
				return ans;
			}
		}
		for (int i = 0; i < executing; ++i) { //把没循环完的在循环一遍
			if (players[i].dead) continue;
			if (from->role == 3) {
				ans.push_back(&players[0]);
				return ans;
			}
			if (from->role == 2 && players[i].seem == 3) {
				ans.push_back(&players[i]);
				return ans;
			}
			if (from->role == 1 && players[i].seem != 2 && players[i].seem != 0) {
				ans.push_back(&players[i]);
				return ans;
			}
		}
	}
	if (x->type == 2 || x->type == 6) { //桃和诸葛弩，只能指定自己为目标
		ans.push_back(from);
		return ans;
	}
	if (x->type == 1) { //杀
		Player* to = &players[executing];
		do
			if (!(++to)->role)
				to = players;
		while (to->dead); //按顺序找第一个活着的目标
		if ((to->seem > 1 && !from->is_friend(to)) || (to->seem == 1 && from->role == 1) || (to->role == 1 && from->role == 3)) //如果可以杀
			from->used_slash = true,
			ans.push_back(to);
		return ans;
	}
	return ans;
}
```

### 主函数
```cpp
int main() {
	freopen("temp.in", "r", stdin);
	freopen("temp2.out", "w", stdout); //freopen像printf一样，被define了
	int n, m; cin >> n >> m;
	for (int i = 0; i < n; ++i) {
		string s; cin >> s; Card x;
		players[i].set_role(s); //读取身份
		if (players[i].role == 2)
			++loyalist;
		if (players[i].role == 3)
			++rebellion;
		for (int j = 0; j < 4; ++j) //读取手牌
			players[i].cards.push_back(read_card());
	}
	players[0].seem = 2; //认为主公跳的是2（忠臣）
	for (int i = 0; i <= m; ++i)
		pile.push_back(read_card()); //读入牌堆
	try { //try... catch 用于捕捉react()中throw出来的异常(0)
		for (;;)
			for (int i = 0; i < n; ++i)
				executing = i,
				players[i].execute();
	}
	catch (int) {
		cout << (rebellion ? "FP\n" : "MP\n"); //如果反贼死光了，主公胜利，否则就是反贼胜利
		for (int i = 0; i < n; ++i) {
			if (players[i].dead)
				cout << "DEAD";
			else for (Pile::iterator it = players[i].cards.begin(); it != players[i].cards.end(); ++it)
				if (!(*it)->used) //用过的牌就不输出了
					cout << (*it)->self << ' ';
			cout << '\n';
		}
		return 0;
	}
}
```

### 完整代码

```cpp
#include <iostream>
#include <string>
#include <cctype>
#include <list>
#define printf(...) 1
#define freopen(...) 
using namespace std;

enum Event {
	slashed,
	recovered,
	nullification,
	dueled,
	duel_affected,
	savage_assulted,
	archery_attacked,
	damaged,
	dying,
	inf_slash
};

struct Sudden_death {};
struct Player;
struct Card {
	char self;
	int type;
	bool used;
	virtual void use(Player*, list<Player*>) { }
};

typedef list<Card*> Pile;
Pile pile;

struct Player {
	Pile cards;
	int role; //1: ZHU;      2: ZHONG;    3: FAN
	int seem; //1: seem_FAN; 2: ZHONG;    3: FAN
	int hp;
	bool dead;
	bool used_slash;
	bool inf_slash;

	void set_role(const string&);
	void execute();
	void react(Event, Player*);
	void draw_cards(int);
	bool usable(const Card*);
	bool is_friend(const Player*);

	Pile::iterator ask_for(char);

	Player() : hp(4) {}
} players[12];
int loyalist, rebellion;
int executing;
bool is_effective = true, effect_changed;
bool death_caused;
list<Player*> targets;

struct Slash : Card {
	Slash() { type = 1; }
	void use(Player* from, list<Player*> x) {
		if (!x.size()) return;
		(*x.begin())->react(slashed, from);
	}
};

struct Peach : Card {
	Peach() { type = 2; }
	void use(Player* from, list<Player*> x) {
		(*x.begin())->react(recovered, from);
	}
};

struct Duel : Card {
	Duel() { type = 3; }
	void use(Player* from, list<Player*> x) {
		if (!x.size()) return;
		(*x.begin())->react(dueled, from);
	again:
		for (int j = executing; players[j].role; ++j)
			if (players[j].react(nullification, *x.begin()), effect_changed)
				effect_changed = false, j = executing - 1;
		for (int j = 0; j < executing; ++j)
			if (players[j].react(nullification, *x.begin()), effect_changed) {
				goto again;
				effect_changed = false;
			}
		if (is_effective)
			(*x.begin())->react(duel_affected, from);
		is_effective = true;
	}
};

struct SavageAssault : Card {
	SavageAssault() { type = 4; }
	void use(Player* from, list<Player*> x) {
		for (list<Player*>::iterator i = x.begin(); i != x.end(); ++i) {
		again:
			for (int j = executing; players[j].role; ++j)
				if (players[j].react(nullification, *i), effect_changed)
					effect_changed = false, j = executing - 1;
			for (int j = 0; j < executing; ++j)
				if (players[j].react(nullification, *i), effect_changed) {
					goto again;
					effect_changed = false;
				}
			if (is_effective)
				(*i)->react(savage_assulted, from);
			is_effective = true;
		}
	}
};

struct ArcheryAttack : Card {
	ArcheryAttack() { type = 5; }
	void use(Player* from, list<Player*> x) {
		for (list<Player*>::iterator i = x.begin(); i != x.end(); ++i) {
		again:
			for (int j = executing; players[j].role; ++j)
				if (players[j].react(nullification, *i), effect_changed)
					effect_changed = false, j = executing - 1;
			for (int j = 0; j < executing; ++j)
				if (players[j].react(nullification, *i), effect_changed) {
					goto again;
					effect_changed = false;
				}
			if (is_effective)
				(*i)->react(archery_attacked, from);
			is_effective = true;
		}
	}
};

struct Liannu : Card {
	Liannu() { type = 6; }
	void use(Player* from, list<Player*> x) {
		(*x.begin())->react(inf_slash, from);
	}
};

Card* read_card() {
	while (isspace(cin.peek())) cin.get();
	char self = cin.get();
	Card* c;
	switch (self) {
	case 'W':
		c = new ArcheryAttack(); break;
	case 'N':
		c = new SavageAssault(); break;
	case 'K':
		c = new Slash(); break;
	case 'Z':
		c = new Liannu(); break;
	case 'F':
		c = new Duel(); break;
	case 'P':
		c = new Peach(); break;
	default:
		c = new Card();
	}
	c->self = self;
	c->used = false;
	return c;
}

void Player::set_role(const string& x) {
	if (x == "MP") role = 1;
	if (x == "ZP") role = 2;
	if (x == "FP") role = 3;
}

list<Player*> filter(const Card* x, Player* from) {
	list<Player*> ans(0);
	if (x->type == 4 || x->type == 5) {
		for (int i = executing + 1; i < 12; ++i)
			if (!players[i].role) break;
			else if (!players[i].dead)
				ans.push_back(&players[i]);
		for (int i = 0; i < executing; ++i)
			if (!players[i].dead)
				ans.push_back(&players[i]);
		return ans;
	}
	if (x->type == 3) {
		for (int i = executing + 1; i < 12; ++i) {
			if (!players[i].role) break;
			if (players[i].dead) continue;
			if (from->role == 3) {
				ans.push_back(&players[0]);
				return ans;
			}
			if (from->role == 2 && players[i].seem == 3) {
				ans.push_back(&players[i]);
				return ans;
			}
			if (from->role == 1 && players[i].seem != 2 && players[i].seem != 0) {
				ans.push_back(&players[i]);
				return ans;
			}
		}
		for (int i = 0; i < executing; ++i) {
			if (players[i].dead) continue;
			if (from->role == 3) {
				ans.push_back(&players[0]);
				return ans;
			}
			if (from->role == 2 && players[i].seem == 3) {
				ans.push_back(&players[i]);
				return ans;
			}
			if (from->role == 1 && players[i].seem != 2 && players[i].seem != 0) {
				ans.push_back(&players[i]);
				return ans;
			}
		}
	}
	if (x->type == 2 || x->type == 6) {
		ans.push_back(from);
		return ans;
	}
	if (x->type == 1) {
		Player* to = &players[executing];
		do
			if (!(++to)->role)
				to = players;
		while (to->dead);
		if ((to->seem > 1 && !from->is_friend(to)) || (to->seem == 1 && from->role == 1) || (to->role == 1 && from->role == 3))
			from->used_slash = true,
			ans.push_back(to);
		return ans;
	}
	return ans;
}

void Player::execute() {
	if (dead)
		return;
	printf("\nIt's Player #%d's turn.\n", executing);
	draw_cards(2);
	bool flag = false;
	for (Pile::iterator i = cards.begin(); i != cards.end(); flag ? flag = false, i : ++i)
		if ((*i)->used) {
			Pile::iterator other = i; ++i;
			cards.erase(other); flag = true;
		}
	flag = false;
	for (Pile::iterator i = cards.begin(); i != cards.end(); flag ? flag = false, i : ++i)
		if (usable(*i)) {
			Card* card = *i;
			card->used = true;
			printf("Player #%d used %c.\n", executing, card->self);
			card->use(this, targets);
			if (card->self == 'P') continue;
			i = cards.begin(); flag = true;
		}
	used_slash = false;
	printf("Player #%d ended his stage.\n", executing);
}

bool Player::is_friend(const Player* x) {
	switch (role) {
	case 1:
		return x->seem == 2;
	case 2:
		return x->seem && x->seem != 3;
	case 3:
		return x->seem == 3;
	default:
		return false;
	}
}

Pile::iterator Player::ask_for(char x) {
	for (Pile::iterator i = cards.begin(); i != cards.end(); ++i)
		if (!(*i)->used && (*i)->self == x)
			return i;
	return cards.end();
}

void Player::react(Event ev, Player* from) {
	switch (ev) {

	case slashed: {
		if (seem == 2)
			from->seem = 3;
		if (seem == 3)
			from->seem = 2;
		Pile::iterator i = ask_for('D');
		if (i == cards.end())
			react(damaged, from);
		else
			(*i)->used = true;
		break;
	}
	case archery_attacked: {
		Pile::iterator i = ask_for('D');
		if (i == cards.end()) {
			if (role == 1 && !from->seem)
				from->seem = 1;
			react(damaged, from);
		}
		else (*i)->used = true;
		break;
	}
	case dueled: 
		if (seem == 2)
			from->seem = 3;
		if (seem == 3)
			from->seem = 2;
		break;
	case duel_affected: {
		Pile::iterator i = ask_for('K');
		if (i == cards.end() || (role == 2 && from->role == 1))
			react(damaged, from);
		else
			(*i)->used = true, from->react(duel_affected, this);
		break;
	}
	case savage_assulted: {
		Pile::iterator i = ask_for('K');
		if (i == cards.end()) {
			if (role == 1 && !from->seem)
				from->seem = 1;
			react(damaged, from);
		}
		else (*i)->used = true;
		break;
	}
	case nullification:
		if (from->seem < 2) break;
		if (is_friend(from) ^ !is_effective) {
			Pile::iterator i = ask_for('J');
			if (i != cards.end()) {
				(*i)->used = true;
				if ((from->seem == 3) ^ (is_effective = !is_effective))
					seem = 3;
				else seem = 2;
				effect_changed = true;
				printf("Nullificated by a pig seeming like %d.\n", seem);
			}
		}
		break;
	case damaged:
		for (int i = 0; i < 7; ++i)
			if (&players[i] == this)
				printf("Player #%d is damaged by Player #%d, having hp %d.\n", i, executing, hp - 1);
		if (role == 1 && from->seem < 2)
		    from->seem = 1;
		if (--hp <= 0)
			react(dying, from);
		break;
	case dying: {
		Pile::iterator i;
		while (hp <= 0 && (i = ask_for('P')) != cards.end())
			(*i)->used = true, ++hp;
		if (hp <= 0) {
			dead = true;
			death_caused = true;
			if (from->role == 1 && role == 2) {
				for (Pile::iterator it = from->cards.begin(); it != from->cards.end(); ++it)
					(*it)->used = true;
				from->inf_slash = false;
			}
			if (role == 3) {
				if (!--rebellion)
					throw 0;
				from->draw_cards(3);
			}
			if (role == 2)
				--loyalist;
			if (role == 1)
				throw 0;
			if (&players[executing] != this)
				cards.clear();
			else for (Pile::iterator it = cards.begin(); it != cards.end(); ++it)
				(*it)->used = true;
		}
		break;
	}
	case ::inf_slash:
		inf_slash = true;
		break;
	case recovered:
		++hp;
		break;
	}

}

bool Player::usable(const Card* x) {
	if (x->used) return false;
	bool used_slash_old = used_slash;
	targets = filter(x, this);
	if (!targets.size()) return false;
	switch (x->self) {
	case 'K':
		return inf_slash || !used_slash_old;
	case 'P':
		return hp < 4;
	case 'Z':
	case 'F':
	case 'N':
	case 'W':
		return true;
	default:
		return false;
	}
}

void Player::draw_cards(int x) {
	while (x--) {
		cards.push_back(*pile.begin());
		if (pile.size() != 2)
			pile.pop_front();
		else {
			Card* x = *pile.begin();
			Card* c;
			switch (x->type) {
			case 5:
				c = new ArcheryAttack(); break;
			case 4:
				c = new SavageAssault(); break;
			case 1:
				c = new Slash(); break;
			case 6:
				c = new Liannu(); break;
			case 3:
				c = new Duel(); break;
			case 2:
				c = new Peach(); break;
			default:
				c = new Card();
			}
			c->used = false;
			c->self = x->self;
			pile.pop_front();
			pile.push_front(c);
		}
	}
}

int main() {
	freopen("temp.in", "r", stdin);
	freopen("temp2.out", "w", stdout);
	int n, m; cin >> n >> m;
	for (int i = 0; i < n; ++i) {
		string s; cin >> s; Card x;
		players[i].set_role(s);
		if (players[i].role == 2)
			++loyalist;
		if (players[i].role == 3)
			++rebellion;
		for (int j = 0; j < 4; ++j)
			players[i].cards.push_back(read_card());
	}
	players[0].seem = 2;
	for (int i = 0; i <= m; ++i)
		pile.push_back(read_card());
	try {
		for (;;)
			for (int i = 0; i < n; ++i)
				executing = i,
				players[i].execute();
	}
	catch (int) {
		cout << (rebellion ? "FP\n" : "MP\n");
		for (int i = 0; i < n; ++i) {
			if (players[i].dead)
				cout << "DEAD";
			else for (Pile::iterator it = players[i].cards.begin(); it != players[i].cards.end(); ++it)
				if (!(*it)->used)
					cout << (*it)->self << ' ';
			cout << '\n';
		}
		return 0;
	}
}
```

---

## 作者：NKL丶 (赞：5)

## 此题就是一个大模拟，没有什么太考验算法的地方。  
对于原版三国杀而言，相差的地方还是比较多的，我先一一列举出来：
- 桃只能给**自己**使用；
- 没有内奸、防具、别的武器和一些别的锦囊牌；
- 血量上限始终为4点，**不论是什么身份**；
- 玩家之间的距离计算只能沿逆时针来计算，即玩家1到玩家2的距离为1，可是玩家2到玩家1的距离为n-1；（所有玩家存活状况下）

当然这道题目坑点也不少：
- **牌堆是可能被抽空的**，这时候，便需要 ~~反人类地~~ 一直抽**牌堆的最后一张牌**（这是题目没有提到的）；
- **对于反猪而言，决斗无论如何都要瞄准主猪**，而不会瞄准已经跳忠的忠猪（因为决斗无距离限制）；对于主猪而言，决斗会从他自身开始，逆时针逐一寻找**没有跳身份的类反猪**或者**已经跳反的反猪**；
- 对于一张锦囊牌的无懈可击询问，是从**出这张锦囊牌的玩家开始，沿逆时针方向依次获得无懈可击的出牌机会权**；
- 一般而言，除非出的牌为桃或者杀，否则前面扫过的牌有可能会可以出；（锦囊牌可以通过无懈可击来跳身份，诸葛连弩会使之前的杀可以使用，又或是忠猪通过一个南蛮或者万箭让反猪跳身份，让前面的决斗有目标……）
- 同上，如果你出了**杀、无懈可击、决斗**，便意味着你跳了身份；
- 无懈可击的操作可以理解为两个派在互相斗争；（主猪和忠猪为一派，反猪为一派），因为这道题目里面的锦囊除无懈可击外都是会造成伤害的，所以看见自己的队友并没有被无懈掉的话，就一定要献殷勤，同理，看见敌人被无懈掉了，就要去表敌意）
- **有可能一开局便没有反猪**，这需要特殊处理；
- 如果对局一结束，所有的事件都要立刻结束，这包括**杀死反猪的摸三张牌**、**未结算完毕的南蛮或者万箭**；
- 任何一张会造成伤害的牌都可能引起濒死，进一步也就可能引起牌局的结束，所以要将这个处理好；
- 忠猪受到了主猪的决斗，要不然就是用无懈可击，要不然就扣一滴血；
- 类反猪只是对主猪有效，同样的，类反猪不会被认为是反猪的队友；
- 注意是否拥有诸葛连弩，这对于杀的数量很重要；
- 对于以下情况，需要跳过已经死亡的玩家：南蛮和万箭的全场伤害、杀和决斗的对象的寻找、无懈可击的询问，如果没有跳过，会极大影响结果。

## 好了，说了这么多，再说一些做这道题目的技巧：
- 将一个玩家的所有相关的东西都用结构体来存储，方便调用；
- 将对立的身份用函数来存储，后面判断是否对立的话直接调用即可；
- 存储卡牌和牌堆用$string$会好很多，因为$string$有$+$、$erase$等~~亮瞎眼的~~方便的操作，而且效率还出奇的快；
- 将出牌这个行为用函数来代替，不要看只不过省了几行，在调试的时候是很方便的；
- 建议一边打一边把注释也弄了，不然调试的时候会混乱。
- 其实献殷勤和表敌意无非就是跳身份，不需要特意的进行处理，因为在处理对立身份的时候就已经大概的处理好了。

最后附上代码，带有注释，里面有一些没有提到的东西
```cpp
#include<bits/stdc++.h>
using namespace std;
struct player{//玩家的信息
	string sf,card;
	int tot,HP,zg,dead,t,lfz[11];
	player(){memset(lfz,0,sizeof(lfz));HP=4;dead=0;zg=0;tot=4;t=0;}//类反猪（这里我脑子短路了，可以不用结构体，因为类反猪只对主猪有效）、血量为4、未死亡、诸葛连弩未装上、牌的总数为4、没有跳身份
}p[11];
char a;
string cardd;//牌堆
int n,m,now,only;
bool dl(int i,int j)//处理对立身份
{
	if(p[i].sf=="MP")//如果i为主猪
		if((p[i].lfz[j]==1&&p[j].t==0)||(p[j].sf=="FP"&&p[j].t==1))return 1;//有两个情况：1、为类反猪并且没有跳身份；2、为反猪而且跳了身份，就意味着是对立的
			else return 0;//不是对立的（或是没有跳身份的）
	if(p[i].sf=="ZP")//忠猪
		if(p[j].sf=="FP"&&p[j].t==1)return 1;//对立的情况只有为反猪而且跳了身份
			else return 0;
	if(p[i].sf=="FP")//反猪
		if(p[j].sf=="MP"||(p[j].sf=="ZP"&&p[j].t==1))return 1;//为主猪，或者为忠猪而且跳了身份
			else return 0;
}
void use(int user,int pos)//出牌处理
{
	p[user].tot--;//总数--
	p[user].card.erase(pos,1);//erase，删除
}
void add(int i,int sum)//从牌堆顶摸牌
{
	p[i].tot+=sum;//总数先增加
	if(m==sum)//这里是对牌堆的特判
	{
		for(int j=1;j<=sum;j++)
			p[i].card+=cardd[j];
		cardd.erase(1,sum-1);
		m=1;
	}
	else
	if(m==1)//牌堆只剩一张牌，一直摸最后一张
		for(int j=1;j<=sum;j++)
			p[i].card+=cardd[1];
	else
	{
		for(int j=1;j<=sum;j++)
			p[i].card+=cardd[j];
		cardd.erase(1,sum);
		m-=sum;
	}
}
bool wfordr(int i,int last,int tot)//无懈可击的询问过程（“受害者”，上一张锦囊牌的使用者，目前的轮数）
{
	//cout<<"k"<<endl;
    //调试用的，后面也有
	if(p[last].card.find('J')!=-1)//先查询自己，if里面判断的是有没有无懈可击
	{
		if(!dl(last,i)&&p[i].t==1&&tot%2==0)//重点：如果不是对立身份，且跳了身份，并且这张锦囊未被无懈（即总轮数为偶数）
		{
			//cout<<last<<" use J for"<<i<<endl;
            //就献殷勤+跳身份
			use(last,p[last].card.find('J'));
			p[last].t=1;
			return wfordr(i,last,tot+1);//进行下一轮
		}
		if(dl(last,i)&&p[i].t==1&&tot%2==1)//对立身份，且这张锦囊牌已被无懈，需要表敌意
		{
			//cout<<last<<" use J For"<<i<<endl;
			use(last,p[last].card.find('J'));
			p[last].t=1;
			return wfordr(i,last,tot+1);
		}
	}
	for(int j=last+1;j!=last;j++)//这里同理，只不过模拟逆时针的顺序
	{
		if(j>n)j=1;//这里我也不知道为什么我这样子写（后面也是这样写的）
		if(j==last)break;
		if(p[j].dead)continue;
		if(p[j].card.find('J')!=-1)
		{
			if(!dl(j,i)&&p[i].t==1&&tot%2==0)
			{
				//cout<<j<<"use J for"<<i<<endl;
				use(j,p[j].card.find('J'));
				p[j].t=1;
				return wfordr(i,j,tot+1);
			}
			if(dl(j,i)&&p[i].t==1&&tot%2==1)
			{
				//cout<<j<<"use J For"<<i<<endl;
				use(j,p[j].card.find('J'));
				p[j].t=1;
				return wfordr(i,j,tot+1);
			}
		}
		if(j==n)j=0;
	}
	//cout<<tot<<endl;
	return tot%2==0;//偶数轮，代表未被无懈掉，奇数轮，代表已经被无懈掉了
}
string sl()//判断胜利条件，返回字符串
{
	if(p[1].dead)return "FP";//主猪死亡，反猪胜利
	int flag=1;//看反猪是否全部死亡
	for(int i=1;i<=n;i++)
		if(p[i].dead==0&&p[i].sf=="FP")flag=0;
	if(flag==1)return "MP";//主猪达到胜利条件
	return "continue";//都没有达到胜利条件，继续
}
void show()//输出
{
	for(int i=1;i<=n;i++)
	{
		if(p[i].dead)cout<<"DEAD"<<endl;
		else
		{
			//cout<<p[i].tot<<"  ";
			for(int j=1;j<p[i].tot;j++)
				cout<<p[i].card[j]<<" ";
			cout<<p[i].card[p[i].tot]<<endl;
		}
	}
}
void bs(int i,int j)//濒死操作，i濒死，j干的
{	
	if(p[i].card.find('P')!=-1)//自己手上有桃
	{
		//cout<<"f "<<i<<endl;
		use(i,p[i].card.find('P'));//使用，回血
		p[i].HP=1;
	}
	else
	{
		//cout<<"gg "<<i<<endl;
		p[i].dead=1;//死亡
		p[i].tot=0;//清空手上的牌
		if(p[i].sf=="FP")//如果死亡的是反猪
		{
			if(sl()=="MP")//优先判断牌局是否结束
			{
				cout<<"MP"<<endl;
				show();
				exit(0);//exit，直接终结整个程序，不执行别的东西了
			}
			add(j,3);//不管是谁，都要摸牌
		}
		if(p[i].sf=="ZP"&&p[j].sf=="MP")//主猪杀了忠猪
		{
			p[j].card=" ";//要将牌清空（包括诸葛连弩）
			p[j].tot=0;
			p[j].zg=0;
		}
		if(p[i].sf=="MP")//主猪死亡，不管谁干的，总之反猪胜利
		{
			cout<<"FP"<<endl;
			show();
			exit(0);
		}
	}
}
int jl(int i,int j)//计算距离
{
	int deadsum=0,tot=0;//死亡的玩家的数量
	while(i!=j)
	{
		if(p[i].dead)deadsum++;
		tot++;
		i++;
		if(i>n)i=1;
	}
	return tot-deadsum;
}
void s(int i,int j)//i杀j
{
	//cout<<"sha "<<i<<"->"<<j<<endl;
	if(p[j].card.find('D')!=-1)//有闪就出
		use(j,p[j].card.find('D'));
	else//不然的话就掉血
	{
		p[j].HP--;
		if(p[j].sf=="MP"&&p[i].t==0)p[j].lfz[i]=1;//这里是因为我将万箭视为对全场使用杀
		if(p[j].HP==0)bs(j,i);//任何伤害都可能濒死
	}
}
void nm(int user)//南蛮入侵，user使用的
{
	//cout<<"nm "<<user<<endl;
	for(int i=user+1;i!=user;i++)//从user开始，逆时针询问无懈可击
	{
		//cout<<"n "<<user<<"->"<<i<<endl;
		if(i>n)i=1;
		if(p[i].dead)continue;
		if(wfordr(i,user,0))//如果未被无懈
		{
			if(p[i].card.find('K')!=-1)//有杀就出
				use(i,p[i].card.find('K'));
			else//没有杀，处理类似杀
			{
				if(p[i].sf=="MP"&&p[user].t==0)p[i].lfz[user]=1;
				p[i].HP--;
				if(p[i].HP==0)bs(i,user);
			}
		}
		if(i==n)i=0;
	}
}
void wj(int user)//万箭，user使用的
{
	//cout<<"wj "<<user<<endl;
	for(int i=user+1;i!=user;i++)//视为对全场使用杀
	{
		if(i>n)i=1;
		if(p[i].dead)continue;
		if(wfordr(i,user,0))s(user,i);
		if(i==n)i=0;
	}
}
void jd(int i,int j)//决斗，这里我写错了好多次，需要注意
{
	if(p[i].sf=="MP"&&p[j].sf=="ZP")//主猪对忠猪决斗，忠猪绝对掉血
	{
		p[j].HP--;
		if(p[j].HP==0)bs(j,i);
		return;//与后面无关了
	}
	int turn=0;//回合
	while(1)
	{
		if(turn==2)turn=0;
		if(turn==0)//偶数回合，j需要弃置杀
		{
			//cout<<"b turn"<<endl;
			if(p[j].card.find('K')!=-1)
			{
				p[j].t=1;
				use(j,p[j].card.find('K'));
			}
			else
			{
				p[j].HP--;
				if(p[j].HP==0)bs(j,i);
				return;
			}
		}
		if(turn==1)//同理
		{
			//cout<<"a turn"<<endl;
			if(p[i].card.find('K')!=-1)
			{
				p[i].t=1;
				use(i,p[i].card.find('K'));
			}
			else
			{
				p[i].HP--;
				if(p[i].HP==0)bs(i,j);
				return;
			}
		}
		turn++;
	}
}
void cp(int i)//出牌阶段
{
	add(i,2);//摸牌阶段
	int ss=p[i].zg?1<<30:1;//ss代表可以使用的杀的数量，如果有诸葛连弩就可以出无限张（这里设为一个很大的数字即可）
	for(int j=1;j<=p[i].tot;j++)//从左到右遍历
	{
		if(p[i].HP==0)return;//已经gg，直接结束这个回合
		if(p[i].card[j]=='Z')//诸葛连弩，一定要出
		{
			//cout<<i<<" use Z"<<endl;
			use(i,j);
			p[i].zg=1;//更改信息
			ss=1<<30;
			j=0;//重新遍历
		}
		if(p[i].card[j]=='P')//桃子
		{
			if(p[i].HP<4)//没有满血，就出
			{
				//cout<<i<<" use P"<<endl;
				p[i].HP++;
				use(i,j);
				j--;
			}
		}
		if(p[i].card[j]=='K'&&ss)//杀，有点长
		{
			if(p[i].sf=="FP")//反猪
			{
				for(int _find=i+1;_find!=i;_find++)//可以打主猪就先打主猪
				{
					if(_find>n)_find=1;
					if(p[_find].dead)continue;
					if(p[i].card[j]=='K'&&p[_find].t==1&&p[_find].sf=="MP"&&jl(i,_find)==1&&ss)
					{
						p[i].t=1;//自己跳身份了
						p[1].lfz[i]=0;//清空类反猪，因为被重新认识了
						use(i,j);
						s(i,_find);//杀
						ss--;//可使用的次数--
						j--;
					}
					if(_find==n)_find=0;
				}
				for(int _find=i+1;_find!=i;_find++)//对跳了身份的忠猪使用
				{
					if(_find>n)_find=1;
					if(p[_find].dead)continue;
					if(p[i].card[j]=='K'&&dl(i,_find)&&jl(i,_find)==1&&ss)
					{
						p[i].t=1;
						p[1].lfz[i]=0;
						use(i,j);
						s(i,_find);
						ss--;
						j--;
					}
					if(_find==n)_find=0;
				}
			}
			else//否则就是主猪或者忠猪
			{
				for(int _find=i+1;_find!=i;_find++)
				{
					if(_find>n)_find=1;
					if(p[_find].dead)continue;
					if(p[i].card[j]=='K'&&dl(i,_find)&&jl(i,_find)==1&&ss)//对立的身份，跳了身份（或者是被视为类反猪），够距离
					{
						p[i].t=1;
						p[1].lfz[i]=0;
						use(i,j);
						s(i,_find);
						ss--;
						j--;
					}
					if(_find==n)_find=0;
				}
			}
		}
		if(p[i].card[j]=='N')//南蛮入侵
		{
			use(i,j);
			nm(i);
			j=0;//重新扫一遍
		}
		if(p[i].card[j]=='W')//万箭齐发
		{
			use(i,j);
			wj(i);
			j=0;//重新扫一遍
		}
		if(p[i].card[j]=='F')//决斗
		{
			if(p[i].sf=="FP"&&p[i].card[j]=='F')//反猪，便一定与主猪决斗
			{
				p[i].t=1;//跳了身份，并被重新认识
				p[1].lfz[i]=0;
				use(i,j);
				//cout<<"jd "<<i<<"->"<<1<<endl;
				if(wfordr(1,i,0))jd(i,1);//未被无懈可击就决斗
				j=0;
			}
			if((p[i].sf=="MP"||p[i].sf=="ZP")&&p[i].card[j]=='F')
			{
				for(int _find=i+1;_find!=i;_find++)//寻找目标
				{
					if(_find>n)_find=1;
					if(_find==i)break;
					if(p[_find].dead)continue;//要跳过已经死亡的玩家
					if(p[i].card[j]=='F'&&dl(i,_find))//对立身份
					{
						use(i,j);
						//cout<<"jd "<<i<<"->"<<_find<<endl;
						if(wfordr(_find,i,0))jd(i,_find);
						j=0;
					}
					if(_find==n)_find=0;
				}
			}
		}
	}
}
int main()
{
	//freopen("猪国杀.in","r",stdin);
	//freopen("猪国杀.out","w",stdout); 
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>p[i].sf;//身份
		p[i].card=' '+p[i].card;//将第0位置空
		for(int j=1;j<=4;j++)
			cin>>a,p[i].card+=a;//用连接符号，方便处理
	}
	cardd=' '+cardd;//置空
	for(int i=1;i<=m;i++)
	{
		cin>>a;
		cardd+=a;
	}
	p[1].t=1;//主猪视为不会跳身份（也可以理解为已经跳了身份）
	while(1)
	{
		if(sl()!="continue")//已经有一方胜利了
		{
			cout<<sl()<<endl;
			show();
			return 0;
		}
		now++;//循环
		if(now>n)now=1;
		if(p[now].dead)continue;//跳过死亡的玩家
		cp(now);//出牌
	}
	return 0;
}
```


---

## 作者：万万没想到 (赞：5)

话不多说，开始分享本人做这道题目时的思路。
整理了一下有用信息：  
  
身份：  
主猪（MP）：自己存活的情况下消灭所有的反猪。  
忠猪（ZP）：不惜一切保护主猪，胜利条件与主猪相同。  
反猪（FP）：杀死主猪。

攻击范围：  
按逆时针排列，1号与2号距离为1，2号与3号距离为1……，n号与1号距离为1，但2号与1号距离不为1，也就是2号不可以对1号出杀，但1号可以对2号出杀

基本牌及武器：  
桃(P)：在自己的回合内，如果自己的体力值不等于体力上限，那么使用一个桃可以为自己补充一点体力，否则不能使用桃；桃只能对自己使用；在自己的回合外，如果自己的血变为0或者更低，那么也可以使用；

杀(K)：在自己的回合内，对攻击范围内除自己以外的一名角色使用。如果没有被闪抵消，则造成1点伤害。无论有无武器，杀的攻击范围都是1；

闪(D)：当你受到杀的攻击时，可以弃置一张闪来抵消杀的效果；

猪哥连弩(Z)：武器，攻击范围1，出牌阶段你可以使用任意张杀；

PS：也就是说杀在确定目标且能用的情况下必定用，闪在受到杀时必定打出，桃在自己回合血量不满时一定用，在他人回合濒临死亡时一定用，猪哥连弩在自己回合一定会用。

锦囊牌：  
决斗(F)：出牌阶段，对除自己以外任意一名角色使用，由目标角色先开始，自己和目标角色轮流弃置一张杀，首先没有杀可弃的一方受到1点伤害，另一方视为此伤害的来源；

南猪入侵(N)：出牌阶段，对除你以外所有角色使用，按逆时针顺序从使用者下家开始依次结算，除非弃置一张杀，否则受到1点伤害；

万箭齐发(W)：和南猪入侵类似，不过要弃置的不是杀而是闪；

无懈可击(J)：在目标锦囊生效前抵消其效果。每次有一张锦囊即将生效时，从使用这张锦囊的猪开始，按照逆时针顺序，依次得到使用无懈可击的机会；

效果：用于决斗时，决斗无效并弃置；用于南猪入侵或万箭齐发时，当结算到某个角色时才能使用，当前角色不需弃置牌并且不会受到伤害（仅对一个角色产生效果）；用于无懈可击时，成为目标的无懈可击被无效。

## PS：  
1.一只猪的死亡会造成这只猪前后两猪的距离改变。  

2.当反猪全部死亡或主猪死亡时直接结束游戏，不需要再进行回合和手牌的摸取。  

3.当出了杀、决斗和无懈可击，角色的身份就确定了。  

4.反猪决斗的目标永远是主猪。

5.（我的情况）如果角色链表只存下一个，那么在更新链表的时候可能会导致链表断裂，需要再存上一个猪。  

6.在主猪误杀忠猪后清空手牌时要将装备区的猪哥连弩也清除。  

7.普通摸牌摸2张，杀反猪摸3张。  

8.（我的情况）杀计数时，误将计数放在有效杀外，导致杀的多计数。

9.当回合内使用完一张手牌时，可能会导致某些猪的身份发生改变，所有需要重新循环判断手牌的打出。

10.忠猪面对主猪的决斗直接会掉血。

下面附上代码（应该还挺好理解的）
who是实际身份，fight是回合中身份。  
fight=1为主猪或忠猪，fight=2为反猪，fight=3为类反猪

```cpp    
#include<bits/stdc++.h>
using namespace std;
int n,m,killer,point=1;
char cdstack[2010];
struct node {
    int who,next,fight,blood,fire,sum,last;
    char card[20010];
} pig[12];
void init() {
    string s,s5,s1,s2,s3,s4;
    int np;
    cin>>n>>m;
    for(register int i=1; i<=n; ++i) {
        cin>>s>>s1>>s2>>s3>>s4;
        pig[i].next=i+1;
        pig[i].last=i-1;
        pig[i].blood=4;
        if(s[0]=='M')pig[i].who=1;
        else if(s[0]=='Z')pig[i].who=2;
        else pig[i].who=3,killer++;
        pig[i].card[++pig[i].sum]=s1[0];
        pig[i].card[++pig[i].sum]=s2[0];
        pig[i].card[++pig[i].sum]=s3[0];
        pig[i].card[++pig[i].sum]=s4[0];
    }
    pig[1].last=n;
    pig[n].next=1;
    pig[1].fight=1;
    for(register int i=1; i<=m; ++i) {
        cin>>s5;
        cdstack[++np]=s5[0];
    }
}
void print() {
    if(pig[1].fight==-1)cout<<"FP"<<endl;
    else cout<<"MP"<<endl;
    for(register int i=1; i<=n; ++i) {
        if(pig[i].blood<=0) {
            cout<<"DEAD"<<endl;
        } else {
            for(register int j=1; j<=pig[i].sum; ++j) {
                if(pig[i].card[j]!=-1)cout<<pig[i].card[j]<<" ";
            }
            cout<<endl;
        }
    }
}
bool nochange(int i,int j,int now){
    int check=i;
    do{
        if(now==1&&((pig[j].fight==1&&pig[i].who!=3)||(pig[j].fight==2&&pig[i].who==3))){
            for(register int k=1;k<=pig[i].sum;++k){
                if(pig[i].card[k]=='J'){
                    pig[i].card[k]=-1;
                    if(pig[i].who!=3)pig[i].fight=1;
                    else pig[i].fight=2;
                    return !nochange(i,check,0);
                }
            }
        }
        else if(now==0&&((pig[check].fight==1&&pig[i].who==3)||(pig[check].fight==2&&pig[i].who!=3))){
            for(register int k=1;k<=pig[i].sum;++k){
                if(pig[i].card[k]=='J'){
                    pig[i].card[k]=-1;
                    if(pig[i].who!=3)pig[i].fight=1;
                    else pig[i].fight=2;
                    return !nochange(i,check,0);
                }
            }
        }
        i=pig[i].next;
    }while(i!=check);
    return false;
}
void aoe(int i,char c) {
    if(c=='N')c='K';
    else c='D';
    for(register int j=pig[i].next; j!=i; j=pig[j].next) {
        if(i!=j&&!nochange(i,j,1)) {
            int temp=0;
            for(register int k=1; k<=pig[j].sum; ++k) {
                if(pig[j].card[k]==c) {
                    pig[j].card[k]=-1;
                    temp=1;
                    break;
                }
            }
            if(!temp) {
                --pig[j].blood;
                if(j==1&&!pig[i].fight)pig[i].fight=3;
                if(!pig[j].blood) {
                    for(register int k=1; k<=pig[j].sum; ++k) {
                        if(pig[j].card[k]=='P') {
                            temp=1;
                            pig[j].blood++;
                            pig[j].card[k]=-1;
                            break;
                        }
                    }
                    if(!temp) {
                        pig[j].fight=-1;
                        if(pig[j].who==3) {
                            --killer;
                            if(!killer) {
                                print();
                                return;
                            }
                            int cnt=1;
                            while(cnt<=3) {
                                pig[i].card[++pig[i].sum]=cdstack[point];
                                if(point<m)++point;
                                ++cnt;
                            }
                        } else if(pig[j].who==2&&pig[i].who==1) {
                            for(register int k=1; k<=pig[i].sum; ++k) {
                                pig[i].card[k]=-1;
                            }
                            pig[i].fire=0;
                        } else if(pig[1].fight==-1) {
                            print();
                            return;
                        }
                        pig[pig[j].last].next=pig[j].next,pig[pig[j].next].last=pig[j].last;
                    }
                }
            }
        }
    }
}
void kill(int i) {
    int temp=0;
    for(register int k=1; k<=pig[pig[i].next].sum; ++k) {
        if(pig[pig[i].next].card[k]=='D') {
            temp=1;
            pig[pig[i].next].card[k]=-1;
            break;
        }
    }
    if(!temp) {
        --pig[pig[i].next].blood;
        if(!pig[pig[i].next].blood) {
            for(register int k=1; k<=pig[pig[i].next].sum; ++k) {
                if(pig[pig[i].next].card[k]=='P') {
                    temp=1;
                    pig[pig[i].next].card[k]=-1;
                    pig[pig[i].next].blood++;
                    break;
                }
            }
            if(!temp) {
                pig[pig[i].next].fight=-1;
                if(pig[pig[i].next].who==3) {
                    --killer;
                    if(!killer) {
                        print();
                        return;
                    }
                    int cnt=1;
                    while(cnt<=3) {
                        pig[i].card[++pig[i].sum]=cdstack[point];
                        if(point<m)++point;
                        ++cnt;
                    }
                } else if(pig[pig[i].next].who==2&&pig[i].who==1) {
                    for(register int j=1; j<=pig[i].sum; ++j) {
                        pig[i].card[j]=-1;
                    }
                    pig[i].fire=0;
                } else if(pig[1].fight==-1) {
                    print();
                    return;
                }
                pig[i].next=pig[pig[i].next].next,pig[pig[i].next].last=pig[i].last;
            }
        }
    }
}
void pk(int i,int j) {
    int temp=0;
    if(nochange(i,j,1))return;
    if(pig[i].who==1&&pig[j].who==2) {
        --pig[j].blood;
        if(!pig[j].blood) {
            for(register int k=1; k<=pig[j].sum; ++k) {
                if(pig[j].card[k]=='P') {
                    temp=1;
                    ++pig[j].blood;
                    pig[j].card[k]=-1;
                    break;
                }
            }
            if(!temp) {
                pig[j].fight=-1;
                for(register int k=1; k<=pig[i].sum; ++k) {
                    pig[i].card[k]=-1;
                }
                pig[i].fire=0;
                pig[pig[j].last].next=pig[j].next,pig[pig[j].next].last=pig[j].last;
            }
        }
        return;
    } else if(pig[i].who<=2&&pig[j].who==3) {
        int pick=0;
        while(1) {
            pick=0;
            for(register int k=1; k<=pig[j].sum; ++k) {
                if(pig[j].card[k]=='K') {
                    pig[j].card[k]=-1;
                    pick=1;
                    break;
                }
            }
            if(!pick) {
                pick=2;
                break;
            }
            pick=0;
            for(register int k=1; k<=pig[i].sum; ++k) {
                if(pig[i].card[k]=='K') {
                    pig[i].card[k]=-1;
                    pick=1;
                    break;
                }
            }
            if(!pick) {
                pick=3;
                break;
            }
        }
        if(pick==2) {
            --pig[j].blood;
            if(!pig[j].blood) {
                for(register int k=1; k<=pig[j].sum; ++k) {
                    if(pig[j].card[k]=='P') {
                        temp=1;
                        ++pig[j].blood;
                        pig[j].card[k]=-1;
                        break;
                    }
                }
                if(!temp) {
                    pig[j].fight=-1;
                    --killer;
                    if(!killer) {
                        print();
                        return;
                    }
                    int cnt=1;
                    while(cnt<=3) {
                        pig[i].card[++pig[i].sum]=cdstack[point];
                        if(point<m)++point;
                        ++cnt;
                    }
                    pig[pig[j].last].next=pig[j].next,pig[pig[j].next].last=pig[j].last;
                }
            }
        } else {
            --pig[i].blood;
            if(!pig[i].blood) {
                for(register int k=1; k<=pig[i].sum; ++k) {
                    if(pig[i].card[k]=='P') {
                        ++pig[i].blood;
                        temp=1;
                        pig[i].card[k]=-1;
                        break;
                    }
                }
                if(!temp) {
                    pig[i].fight=-1;
                    if(pig[i].who==1) {
                        print();
                        return;
                    }
                    pig[pig[i].last].next=pig[i].next,pig[pig[i].next].last=pig[i].last;
                }
            }
        }
        return;
    } else if(pig[i].who==3) {
        int pick=0;
        while(1) {
            pick=0;
            for(register int k=1; k<=pig[j].sum; ++k) {
                if(pig[j].card[k]=='K') {
                    pig[j].card[k]=-1;
                    pick=1;
                    break;
                }
            }
            if(!pick) {
                pick=2;
                break;
            }
            pick=0;
            for(register int k=1; k<=pig[i].sum; ++k) {
                if(pig[i].card[k]=='K') {
                    pig[i].card[k]=-1;
                    pick=1;
                    break;
                }
            }
            if(!pick) {
                pick=3;
                break;
            }
        }
        if(pick==2) {
            --pig[j].blood;
            if(!pig[j].blood) {
                for(register int k=1; k<=pig[j].sum; ++k) {
                    if(pig[j].card[k]=='P') {
                        temp=1;
                        ++pig[j].blood;
                        pig[j].card[k]=-1;
                        break;
                    }
                }
                if(!temp) {
                    pig[j].fight=-1;
                    if(pig[j].who==1) {
                        print();
                        return;
                    }
                    pig[pig[j].last].next=pig[j].next,pig[pig[j].next].last=pig[j].last;
                }
            }
        } else {
            --pig[i].blood;
            if(!pig[i].blood) {
                for(register int k=1; k<=pig[i].sum; ++k) {
                    if(pig[i].card[k]=='P') {
                        ++pig[i].blood;
                        temp=1;
                        pig[i].card[k]=-1;
                        break;
                    }
                }
                if(!temp) {
                    pig[i].fight=-1;
                    --killer;
                    if(!killer) {
                        print();
                        return;
                    }
                    int cnt=1;
                    while(cnt<=3) {
                        pig[j].card[++pig[j].sum]=cdstack[point];
                        if(point<m)++point;
                        ++cnt;
                    }
                    pig[pig[i].last].next=pig[i].next,pig[pig[i].next].last=pig[i].last;
                }
            }
        }
        return;
    }
}
void game() {
    while(1) {
        for(register int i=1; i<=n; ++i) {
            if(pig[i].fight!=-1) {
                int cnt=1;
                while(cnt<=2) {
                    pig[i].card[++pig[i].sum]=cdstack[point];
                    if(point<m)++point;
                    ++cnt;
                }
                int nowfire=0;
                for(register int j=1; j<=pig[i].sum; ++j) {
                    if(pig[i].card[j]!=-1&&pig[i].fight!=-1) {
                    	if(pig[i].card[j]=='K'&&(nowfire==0||pig[i].fire==1)) {
                        	if(pig[i].who==3&&pig[pig[i].next].who==1) {
                                pig[i].fight=2;
                                pig[i].card[j]=-1;
                                kill(i);
                                j=0;
                                ++nowfire;
                            } else if(pig[i].who==3&&pig[pig[i].next].fight==1) {
                                pig[i].fight=2;
                                pig[i].card[j]=-1;
                                kill(i);
                                j=0;
                                ++nowfire;
                            } else if(pig[i].who==1&&pig[pig[i].next].fight==2) {
                                pig[i].card[j]=-1;
                                kill(i);
                                j=0;
                                ++nowfire;
                            } else if(pig[i].who==2&&pig[pig[i].next].fight==2) {
                                pig[i].fight=1;
                                pig[i].card[j]=-1;
                                kill(i);
                                j=0;
                                ++nowfire;
                            } else if(pig[i].who==1&&pig[pig[i].next].fight==3) {
                                pig[i].card[j]=-1;
                                kill(i);
                                j=0;
                                ++nowfire;
                            }
                        } else if(pig[i].card[j]=='P'&&pig[i].blood<4) {
                            pig[i].card[j]=-1;
                            ++pig[i].blood;
                        } else if(pig[i].card[j]=='Z') {
                            pig[i].card[j]=-1;
                            pig[i].fire=1;
                            j=0;
                        } else if(pig[i].card[j]=='N'||pig[i].card[j]=='W') {
                            char cc=pig[i].card[j];
                            pig[i].card[j]=-1;
                            aoe(i,cc);
                            j=0;
                        } else if(pig[i].card[j]=='F') {
                            if(pig[i].who==1) {
                                int nowpig=0;
                                for(register int k=pig[i].next; k!=i; k=pig[k].next) {
                                    if(pig[k].fight>=2) {
                                        nowpig=k;
                                        break;
                                    }
                                }
                                if(nowpig) {
                                    pig[i].card[j]=-1;
                                    pk(i,nowpig);
                                    j=0;
                                }
                            } else if(pig[i].who==3) {
                                pig[i].fight=2;
                                pig[i].card[j]=-1;
                                pk(i,1);
                                j=0;
                            } else if(pig[i].who==2) {
                                int nowpig=0;
                                for(register int k=pig[i].next; k!=i; k=pig[k].next) {
                                    if(pig[k].fight==2) {
                                        nowpig=k;
                                        break;
                                    }
                                }
                                if(nowpig) {
                                    pig[i].fight=1;
                                    pig[i].card[j]=-1;
                                    pk(i,nowpig);
                                    j=0;
                                }
                            }
                        }
                        if(pig[1].fight==-1||!killer)return;
                    }
                }
            }
        }
    }
}
int main() {
    init();
    game();
    return 0;
}
```


---

## 作者：YHASDY (赞：4)

猪国杀，模拟题的一颗耀眼的明珠，成长大牛、锻炼码力必写题！

模拟题没什么思维难度。只要按部就班地去做就是。模拟简单在这，难也在这。因为题面巨长，条件巨多，忽疏一点都有可能全盘皆输。故推荐考试时碰见了，除非真的闲的没事，否则尽量不要碰。一旦陷入细节混乱的深渊，估计一上午/下午的考试就混过去了。

总结一下做题的注意点：

　　1、审题是最基本的！

　　　　　做大模拟题时，必须要认真读题，可能的话，要把所有条件都列举出来（不然就会像我一样，调了一上午才发现就是忘了几个题目中提到的条件或要求）。

　　2、理清思路。

　　　　　不要吝啬草稿纸，把框架、注意点都写出来。相信我，除非您是~~AKIOI/NOI/CSP~~很强的大佬，否则在敲了几百行代码后，肯定会忘了些什么的。而忘了的，都会成为事后艰难调试的根源之一。
　　　　　
     
   同时，写代码时推荐多利用自定义函数，变量名尽量都用自己熟悉的、见名知意的。这样不仅使程序层次清晰、易于理解，还方便后期的调试（不然写了500行代码后再回来看a1,a2..什么的自己都不知道意义的变量，想死的心都有了）

　　3、对于本题来说，找准对象、明确不同对象之间行为的差别也是很有必要的。这种细节特别容易忘，而找起来不留意的话也很难找。

 

接下来说一下~~我犯过的~~容易掉的坑吧，注意一下，这也算是这片题解的主体（~~没准您就掉进这些坑中呢？~~）：

　　1、杀死反猪后会摸牌，要注意猪能否再出牌

　　2、 反猪决斗优先打主公（读题）

　　3、决斗可能会自杀

　　4、决斗只能在第一个人出杀前被无懈可击掉

　　5、要注意用牌的顺序（从左到右），以便输出

　　6、杀、决斗、无懈可击都会标明身份，南猪入侵和万箭齐发顶多在未表明身份时被主猪认为类反贼

　　7、决斗时，主公认为对面是类反贼，实际上是忠臣的情况下，忠臣要牺牲一滴血（连无懈可击也不能出）

　　8、当自己没表明身份时，不能对自己用无懈可击

　　9、牌能用，要先把用牌的标记打上，免得主杀忠弃牌后再打标记导致错误

　　10、装上猪哥连弩有可能使前面的杀能用

　　11、中途有新的猪表明身份后，也有可能能让前面的决斗或杀能用。

　　12、要每次都用最左边的能用的牌，是对全体来说，而不是对某种来说！

　　13、“无懈可击：在目标锦囊生效前抵消其效果。每次有一张锦囊即将生效时，从使用这张锦囊的猪开始，按照逆时针顺序，依次得到使用无懈可击的机会”。这一点与三国杀不同，三国杀是从锦囊牌的对象开始的。但这里是猪国杀

　　14、for循环后i会+1，如重新从左到右看牌，i不能取1，要取0。	
  
  15、当牌堆没有牌时，会一直摸最后一张牌。（这就是RE点的原因吧）
  
  580行代码警告：
  ```
#include<iostream>
#include<cstdio>
#include<cstring>

using namespace std;

const int N=15,M=2005;

int n,m,win,top,fan,usesha,liangshengfen;

char ch,pai;

bool vis[N][M],allsf[N];

struct PIG{
	int liv,rit,tot,iden,leifan,biao,zhuge,xie;
	int wuxie,sha,shan,tao;
	char card[M+4];
	int used[M+4];
}pig[N];

char Card[M],sf[10];

inline char readch()
{
	ch=getchar();
	while(ch<'A'||ch>'Z') 
		ch=getchar();
	return ch;
}

inline void init()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
	{
		pig[i].liv=1;pig[i].xie=4;
		scanf("%s",sf);
		switch(sf[0])
		{
			case 'M':pig[i].iden=3;pig[i].biao=1;break;
			case 'Z':pig[i].iden=1;break;
			default:
				fan++;
		}
		for(int j=1;j<=4;++j)
		{
			pai=readch();
			switch(pai)
			{
				case 'J':
					pig[i].wuxie++;break;
				case 'K':
					pig[i].sha++;break;
				case 'D':
					pig[i].shan++;break;
				case 'P':
					pig[i].tao++;break;
					
			}
			pig[i].tot++;
			pig[i].card[++pig[i].rit]=pai;
		}
			
	}
	for(int i=1;i<=m;++i)
		Card[i]=readch();
	top=1;
}

inline void yongtao(int u)
{
	for(int i=1;i<=pig[u].rit;++i)
	if(!pig[u].used[i]&&pig[u].card[i]=='P')
	{
		pig[u].used[i]=1;
		return;
	}
}

inline void yonggewuxie(int u)
{
	for(int i=1;i<=pig[u].rit;++i)
		if(!pig[u].used[i]&&pig[u].card[i]=='J')
		{
			pig[u].used[i]=1;
			return;
		}
}

inline void yongsha(int u,int ge)
{
	if(!ge)
		return;
	for(int i=1;i<=pig[u].rit;++i)
		if(!pig[u].used[i]&&pig[u].card[i]=='K')
		{
			pig[u].used[i]=1;
			ge--;
			if(!ge)
				return;
		}
}

inline void yongshan(int u)
{
	for(int i=1;i<=pig[u].rit;++i)
		if(!pig[u].used[i]&&pig[u].card[i]=='D')
		{
			pig[u].used[i]=1;
			return;
		}
}

int yongwuxie(int u,int good,int sta)//表身份 
{
	if(pig[u].biao==0) 
	{
		if(pig[u].leifan==1)
		{
			if(good) return 0;
			if(pig[1].wuxie)
			{
				pig[1].wuxie--;
				pig[1].tot--;
				yonggewuxie(1);
				if(!yongwuxie(1,0,1)) return 1;
				else return 0;
			}
		}
		else 
			return 0;
	}
	int k=n,now=sta-1;
	if(good)
	{
		while(k--)
		{
			now++;
			if(now>n) 
				now=1;
			if(!pig[now].liv) continue;
			if((pig[now].iden&1)==(pig[u].iden&1)&&pig[now].wuxie)
			{
				pig[now].wuxie--;
				pig[now].tot--;
				yonggewuxie(now);
				if(pig[now].biao==0)
				pig[now].biao=1,liangshengfen=1;
				if(!yongwuxie(now,0,now)) return 1;
				else return 0;
			}
		}
		return 0;
	}
	else
	{
		while(k--)
		{
			now++;
			if(now>n) 
				now=1;
			if(!pig[now].liv) continue;
			if((pig[now].iden&1)!=(pig[u].iden&1)&&pig[now].wuxie)
			{
				pig[now].wuxie--;
				pig[now].tot--;
				yonggewuxie(now);
				if(pig[now].biao==0)
				pig[now].biao=1,liangshengfen=1;
				if(!yongwuxie(now,0,now)) return 1;
				else return 0;
			}
		}
		return 0;
	}
}

inline void mosanzhang(int u)
{
	for(int j=1;j<=3;++j)
	{
		pai=Card[top++];
		if(top>m) top=m;
		switch(pai)
		{
			case 'J':
				pig[u].wuxie++;break;
			case 'K':
				pig[u].sha++;break;
			case 'D':
				pig[u].shan++;break;
			case 'P':
				pig[u].tao++;break;
		}
		pig[u].tot++;
		pig[u].card[++pig[u].rit]=pai;
	}
}

inline void diaoxie(int u,int now)//u使now掉血,处理死亡（不处理仇恨） 
{
	pig[now].xie--;
	if(pig[now].xie==0)
	{
		if(pig[now].tao)
		{
			pig[now].xie=1;
			pig[now].tot--;
			pig[now].tao--;
			yongtao(now);
		}
		else
		{
			pig[now].liv=0;
			if(pig[now].iden==3)
			{
				win=2;
				return;
			}
			if(pig[now].iden==1)
			{
				if(pig[u].iden==3)
				{
					pig[u].zhuge=0;
					pig[u].tao=pig[u].sha=pig[u].shan=pig[u].wuxie=0;
					for(int i=1;i<=pig[u].rit;++i)
						pig[u].used[i]=0;
					pig[u].rit=pig[u].tot=0;
					return;
				}
			}
			if(pig[now].iden==0)
			{
				fan--;
				if(fan==0) 
				{
					win=1;
					return;
				}
				mosanzhang(u);
			}
		}
	}
}

inline void nanman(int u)//无仇恨，只类反 
{
	int k=n-1,now=u;
	while(k--)
	{
		now++;
		if(now>n) now=1;
		if(!pig[now].liv) continue;
		if(!yongwuxie(now,1,u))
		{
			if(pig[now].sha>0)
			{
				pig[now].sha--;
				pig[now].tot--;
				yongsha(now,1);
			}
			else
			{
				diaoxie(u,now);
				if(pig[now].iden==3&&pig[u].biao==0)
					pig[u].leifan=1; 
			} 
		}
		if(win) return;
	}
}

inline void wanjian(int u)
{
	int k=n-1,now=u;
	while(k--)
	{
		now++;
		if(now>n) 
			now=1;
		if(!pig[now].liv) continue;
		if(!yongwuxie(now,1,u))
		{
			if(pig[now].shan>0)
			{
				pig[now].shan--;
				pig[now].tot--;
				yongshan(now);
			}
			else
			{
				diaoxie(u,now);
				if(pig[now].iden==3&&pig[u].biao==0)
					pig[u].leifan=1; 
			} 
		}
		if(win) return;
	}
}

inline int doumubiao(int u)
{
	if(!pig[u].iden)
		return 1;
	int now=u,k=n-1;
	while(k--)
	{
		now++;
		if(now>n)
			now=1;
		if(!pig[now].liv) 
			continue;
		if(pig[now].biao==0)
		{
			if(u==1&&pig[now].leifan)
				return now;
		}
		else
		{
			if((pig[now].iden&1)!=(pig[u].iden&1))
				return now;
		}
	}
	return 0;
}

inline int juedou(int u,int now)//只计算掉血、杀 
{
	if(u==1&&pig[now].iden)
	{
		diaoxie(1,now);
		return 0;
	}
	if(yongwuxie(now,1,u)) 
		return 0;
	if(!pig[now].sha)
	{
		diaoxie(u,now);
		return 0;
	}
	pig[now].sha--;
	pig[now].tot--;
	yongsha(now,1);
//	if(yongwuxie(u,1))
//		return 0;
	if(!pig[u].sha)
	{
		diaoxie(now,u);
		return 1;
	}
	pig[u].sha--;
	pig[u].tot--;
	yongsha(u,1);
	if(pig[now].sha>pig[u].sha)
	{
		pig[now].sha-=pig[u].sha+1;
		pig[now].tot-=pig[u].sha+1;
		yongsha(now,pig[u].sha+1);
		yongsha(u,pig[u].sha);
		pig[u].tot-=pig[u].sha;
		pig[u].sha=0;
		diaoxie(now,u);
		return 1;
	}
	else 
	{
		pig[u].sha-=pig[now].sha;
		pig[u].tot-=pig[now].sha;
		yongsha(u,pig[now].sha);
		yongsha(now,pig[now].sha);
		pig[now].tot-=pig[now].sha;
		pig[now].sha=0;
		diaoxie(u,now);
		return 0;
	}
}

inline void zhengli(int u)
{
	int ccnt=0;
	for(int i=1;i<=pig[u].rit;++i)
	{
		if(!pig[u].used[i])
			pig[u].card[++ccnt]=pig[u].card[i];
		else
			pig[u].used[i]=0;
	}
	pig[u].rit=ccnt;
}

inline int nengyongsha(int u)
{
	int k=n-1,now=u;
	while(k--)
	{
		now++;
		if(now>n) now=1;
		if(!pig[now].liv) continue;
		if(pig[u].iden==3)
		{
			if(pig[now].biao==1)
			{
				if(pig[now].iden==0)
					return now;
				else
					return 0;
			}
			else
				if(pig[now].leifan)
					return now;
				else 
					return 0;
		}
		if(pig[now].biao==0) 
			return 0;
		if((pig[now].iden&1)!=(pig[u].iden&1)) 
			return now;
		else 
			return 0;
	}
	return 0;
}

inline void chupai(int u)
{
	int t;
	int weiyongdou=0,weiyongsha=0,weiyongtao=0;
	liangshengfen=0;
	usesha=0;
	for(int i=1;i<=pig[u].rit;++i)
	if(!pig[u].used[i])
	{
		switch(pig[u].card[i])
		{
			case 'N':
				pig[u].tot--;
				pig[u].used[i]=1;
				nanman(u);
				break;
			case 'F':
				if(t=doumubiao(u))
				{
					pig[u].used[i]=1;
					pig[u].tot--;
					pig[u].biao=1;
					if(juedou(u,t))//自己掉血 
					{
						if(weiyongtao>0) 
						{
							yongtao(u);
							pig[u].xie++;
							pig[u].tao--;
							pig[u].tot--;
							weiyongtao--;
						}
					}
				}
				else
					weiyongdou=1;
				break;	
			case 'W':
				pig[u].tot--;
				pig[u].used[i]=1;
				wanjian(u);
				break;
			case 'Z':
					pig[u].zhuge=1;
					pig[u].used[i]=1;
					pig[u].tot--;
					break;
			case 'D':break;
			case 'J':break;
			case 'P':
					if(pig[u].xie<4)
					{
						pig[u].xie++;
						pig[u].tao--;
						pig[u].used[i]=1;
					}
					else
						weiyongtao++;
					break;
			case 'K':
				if(!usesha||(pig[u].zhuge))
				{
					if(t=nengyongsha(u))
					{
						usesha=1;
						pig[u].biao=1;
						pig[u].used[i]=1;
						pig[u].tot--;
						pig[u].sha--;
						if(pig[t].shan)
						{
							pig[t].shan--;
							yongshan(t);
							pig[t].tot--;
						}
						else
							diaoxie(u,t);
					}
					else
						weiyongsha=1;
				}
				else 
					weiyongsha=1;
				break;
		}
		if(!pig[u].liv)
			return;
		if(win) return;
		if(liangshengfen&&weiyongdou)
		{
			liangshengfen=0;weiyongdou=0;
			i=0;
		}
		else
			if(weiyongsha&&(!usesha||pig[u].zhuge)&&nengyongsha(u))
			{
				weiyongsha=0;
				i=0;
			}
	}
	if(pig[u].rit>(pig[u].tot<<1))
		zhengli(u);
}

int main()
{
	init();
	int now=1;
	while(!win)
	{
		if(pig[now].liv)
		{
			for(int j=1;j<=2;++j)
			{
				pai=Card[top++];
				if(top>m) top=m;
				switch(pai)
				{
					case 'J':
						pig[now].wuxie++;break;
					case 'K':
						pig[now].sha++;break;
					case 'D':
						pig[now].shan++;break;
					case 'P':
						pig[now].tao++;break;
				}
				pig[now].tot++;
				pig[now].card[++pig[now].rit]=pai;
			}
			chupai(now);
		}
		now++;
		if(now>n)
			now=1;
	}
	if(win==1)
		printf("MP\n");
	else
		printf("FP\n");
	for(int i=1;i<=n;++i)
	{
		if(!pig[i].liv)
			printf("DEAD\n");
		else
		{
			for(int j=1;j<=pig[i].rit;++j)
				if(!pig[i].used[j])
				{
					printf("%c ",pig[i].card[j]);
				}
			putchar('\n');
		}
	}
	return 0;
}
```
代码变量名或函数名大部分以汉语拼音命名。

（写了这么多，应该能懂吧。同步发表于[博客园](https://www.cnblogs.com/InductiveSorting-QYF/p/11755208.html)，洛谷版有增量内容）

（懂了的话请留个赞，让更多人看到；不懂的话？问就好了~）

(最后再bb一句：对拍真是个好东西。实在找不出错的话，对拍一下，很快就能找到一组hack小数据，简直就是~~居家旅行必备~~调试神器）

---

## 作者：xukuan (赞：4)

不知道三国杀的规则的可以先去 [www.sanguosha.com](www.sanguosha.com) 玩一个月再来做这题

~~凉企现在不仅圈玩家的钱，还要搞出大模拟毒害学生~~

首先，《三国杀》是一个卡牌游戏，那么我们也要从卡牌的角度来分析这道题

三国杀有三大类牌：
1. 身份牌
2. 武将牌
3. 手牌

这里没有武将牌，我们从身份牌和手牌的角度来分析

这里的身份牌只有主忠反，没有内，比正规的三国杀简单很多

那么重点显然是手牌

手牌可以分为两类，主动手牌和被动手牌

主动手牌具体分析如下：

**基本牌**

1. 杀
	- 这题杀只能对自己下家用
   - 用了杀之后身份就跳明了（不存在“类反猪”）
   - 没有装备AK47时每回合只能用一张杀
   - 人家开A或决斗时要用

2. 桃
	- 桃只能给自己用，不能救队友
   - 桃只能在濒死或自己回合非满血时使用

**锦囊牌**

3. 南蛮入侵
	- 忠的A伤到主会被主认为是“类反猪”，没伤到不算

4. 万箭齐发
	- 忠的万伤到主会被主认为是“类反猪”，没伤到不算

5. 决斗
	- 主忠方的决斗一定打离自己最近的反或类反
   - 反的决斗一定给主
   - 用了决斗之后身份就跳明了（不存在“类反猪”）
   - 决斗是唯一一张可以让一个人在自己的回合里让自己死亡的牌
   - 主打类反，如果类反是忠类反要掉血

**装备牌**

6. 诸葛连弩
	- 装备了AK47之后可以出无限张杀
    
被动手牌具体分析如下：

**锦囊牌**

7. 无懈可击
	- 在A或万或决斗生效之前用
   - 用了无之后身份就跳明了（不存在“类反猪”）
   - 与使用方同队的想让这张牌生效，与使用方不同队的想让这张牌无效
   - 存在用一张无去让另一张无失效的情况（所谓“无懈大战”）

**基本牌**

8. 闪
	- 抵消杀和生效的万

好了，现在上代码：

```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;

struct node{
    ll blood,next,prev;//实际血量，上下家
    char identity;//身份
	vector<char> card;//手牌
    bool AK47;//有没有AK
}a[20];
char know[11],card[2010];//明的身份，卡牌堆
ll n,m,green;//反猪数量
bool gameEnd;

inline void getcard(ll x){//摸牌
    if(!m) m++;
    a[x].card.push_back(card[m]);
    m--;
}

inline void killed(ll x1,ll x2){//x1把x2打进濒死
    for(ll i=0; i<(ll)a[x2].card.size(); i++)
        if(a[x2].card[i]=='P'){//有桃
        	a[x2].card.erase(a[x2].card.begin()+i); i--;
            a[x2].blood++;//自救
            return;
        }
    a[a[x2].next].prev=a[x2].prev; a[a[x2].prev].next=a[x2].next;//GG，删掉这个人
    if(x2==1){//主公GG
		gameEnd=1;
		return;
	}
    if(a[x2].identity=='F') green--;//反贼GG
    if(!green){//反贼死光了
		gameEnd=1;
		return;
	}
    if(a[x2].identity=='F'){getcard(x1);getcard(x1);getcard(x1);}//杀死反贼的奖励
    if(a[x2].identity=='Z'&&a[x1].identity=='M'){//主杀忠
    	a[x1].card.clear();//弃光所有牌
		a[x1].AK47=0;//丢AK
	}
}

namespace cardlist{//各种卡
	inline void kill(ll x1,ll x2){//x1杀x2
	    for(ll i=0; i<(ll)a[x2].card.size(); i++){
	    	if(a[x2].card[i]=='D'){//x2有闪
	            a[x2].card.erase(a[x2].card.begin()+i); i--;
	            return;
	        }
		}
	    a[x2].blood--;//没闪
	    if(!a[x2].blood) killed(x1,x2);//濒死结算
	}
	
	inline void peach(ll x){//吃桃
		a[x].blood++;
	}
	
	inline void AK47(ll x){//装AK
		a[x].AK47=1;
	}
	
	inline bool unable(ll x1,ll x2,ll pd){//无邪可击
		ll i=x1;
		while(1){
			if(pd){
				if(know[x2]==a[i].identity||(know[x2]=='M'&&a[i].identity=='Z')||(know[x2]=='Z'&&a[i].identity=='M')){//敌方
					for(ll j=0; j<(ll)a[i].card.size(); j++){
						if(a[i].card[j]=='J'){
							a[i].card.erase(a[i].card.begin()+j); j--;
							know[i]=a[i].identity;
							return !unable(i,x1,0);
						}
					}
				}
			}
			else{
				if((a[i].identity=='M'||a[i].identity=='Z')&&know[x1]=='F'||(a[i].identity=='F'&&(know[x1]=='M'||know[x1]=='Z'))){//友方
					for(ll j=0; j<(ll)a[i].card.size(); j++){
						if(a[i].card[j]=='J'){
							a[i].card.erase(a[i].card.begin()+j); j--;
							know[i]=a[i].identity;
							return !unable(i,x1,0);
						}
					}
				}
			}
			i=a[i].next;
			if(i==x1) break;
		}
		return 0;
	}
	
	inline void A(ll x1){//南蛮入侵
		for(ll x2=a[x1].next; x1!=x2; x2=a[x2].next){
			if(unable(x1,x2,1)) continue;//被无掉了
			bool flag=0;
			for(ll i=0; i<(ll)a[x2].card.size(); i++){
				if(a[x2].card[i]=='K'){//有杀
					a[x2].card.erase(a[x2].card.begin()+i); i--;
					flag=1;
					break;
				}
			}
			if(flag) continue;
			a[x2].blood--;//没杀，掉血
			if(x2==1&&know[x1]=='U') know[x1]='L';//标记类反猪
			if(!a[x2].blood) killed(x1,x2);//濒死结算
			if(gameEnd) return;//游戏结束
		}
	}
	
	inline void W(ll x1){//万箭齐发
		for(ll x2=a[x1].next; x1!=x2; x2=a[x2].next){
			if(unable(x1,x2,1)) continue;//被无掉了
			bool flag=0;
			for(ll i=0; i<(ll)a[x2].card.size(); i++){
				if(a[x2].card[i]=='D'){//有闪
					a[x2].card.erase(a[x2].card.begin()+i); i--;
					flag=1;
					break;
				}
			}
			if(flag) continue;
			a[x2].blood--;//没闪，掉血
			if(x2==1&&know[x1]=='U') know[x1]='L';//标记类反猪
			if(!a[x2].blood) killed(x1,x2);//濒死结算
			if(gameEnd) return;//游戏结束
		}
	}
	
	inline void fire(ll x1,ll x2){
		if(unable(x1,x2,1)) return;//被无掉了
		if(x1==1&&a[x2].identity=='Z'){//主公打忠臣
			a[x2].blood--;
			if(!a[x2].blood) killed(x1,x2);//濒死结算
			return;
		}
		ll j=0,k=0;
		while(1){
        //后手方（不是使用决斗的一方）出杀
			while(j<(ll)a[x2].card.size()&&a[x2].card[j]!='K') j++;
			if(j==a[x2].card.size()){
				a[x2].blood--;
				if(!a[x2].blood) killed(x1,x2);
				return;
			}
			else{
				a[x2].card.erase(a[x2].card.begin()+j); j--;
			}
			//先手方（使用决斗的一方）出杀
			while(k<(ll)a[x1].card.size()&&a[x1].card[k]!='K') k++;
			if(k==(ll)a[x1].card.size()){
				a[x1].blood--;
				if(!a[x1].blood) killed(x2,x1);
				return;
			}
			else{
				a[x1].card.erase(a[x1].card.begin()+k); k--;
			}
		}
	}
}

inline void solve(){//进入游戏，模拟
    if(!green) return;//场上无反猪
	gameEnd=0;
    for(ll i=1; i; i=a[i].next){
        getcard(i); getcard(i);//摸牌
        bool usekill=1;//用过杀没有
        for(ll j=0; j<(ll)a[i].card.size(); j++){
            if(!a[i].blood) break;
            switch(a[i].card[j]){
            	case 'P':{//桃
	            	if(a[i].blood!=4){
	            		cardlist::peach(i);
						a[i].card.erase(a[i].card.begin()+j); j--;
					}	
					break;
				}
				case 'K':{//杀
					if(!usekill&&!a[i].AK47) continue;//如果用过杀并且没有AK就跳过
	                if(a[i].identity=='M'&&know[a[i].next]!='L'&&know[a[i].next]!='F') continue;//主公出杀下家不是反或类反，跳过
	                if(a[i].identity=='Z'&&know[a[i].next]!='F') continue;//忠下家不是反，跳过
	                if(a[i].identity=='F'&&know[a[i].next]!='Z'&&know[a[i].next]!='M') continue;//反下家不是主忠，跳过
	                a[i].card.erase(a[i].card.begin()+j); j--;
	                cardlist::kill(i,a[i].next);//出杀
	                know[i]=a[i].identity; usekill=0;//明身份，杀用过了
	                if(gameEnd) return;
					break;
				}
				case 'Z':{//AK47
					a[i].card.erase(a[i].card.begin()+j); j=-1;
					cardlist::AK47(i);
                    continue;
				}
				case 'N':{//A
					a[i].card.erase(a[i].card.begin()+j); j--;
					cardlist::A(i);
					if(gameEnd) return;
					j=-1;
					break;
				}
				case 'W':{//万
					a[i].card.erase(a[i].card.begin()+j); j--;
					cardlist::W(i);
					if(gameEnd) return;
					j=-1;
					break;
				}
				case 'F':{//决斗
					if(a[i].identity=='F'){//反的决斗
						a[i].card.erase(a[i].card.begin()+j); j--;
						cardlist::fire(i,1);
						know[i]=a[i].identity;
						if(gameEnd) return;
						j=-1;
						break;
					}
					for(ll k=a[i].next; i!=k; k=a[k].next){//主忠的决斗
						if(a[i].identity=='M'&&(know[k]=='L'||know[k]=='F')||(a[i].identity=='Z'&&know[k]=='F')){
							a[i].card.erase(a[i].card.begin()+j); j--;
							cardlist::fire(i,k);
							know[i]=a[i].identity;
							if(gameEnd) return;
							j=-1;
							break;
						}
					}
					break;
				}
			}
        }
    }
}

int main(){
	ios::sync_with_stdio(0);
    cin>>n>>m;
    for(ll i=1; i<=n; i++){
    	a[i].next=i+1;
		a[i].prev=i-1;
	}
    a[n].next=1; a[1].prev=n;
    for(ll i=1; i<=n; i++){
        string s; cin>>s;
		a[i].identity=s[0];
        for(ll j=1; j<=4; j++){
        	char ch; cin>>ch;
			a[i].card.push_back(ch);
		}
        a[i].blood=4;
        if(a[i].identity=='F') green++;
        a[i].AK47=0;
    }
    for(ll i=2; i<=n; i++) know[i]='U';
    know[1]='M';
    for(ll i=1; i<=m; i++){
    	char ch; cin>>ch;
		card[m-i+1]=ch;
	}
    solve();
    if(a[1].blood<=0) cout<<"FP\n";
    else cout<<"MP\n";
    for(ll i=1; i<=n; i++){
        if(a[i].blood<=0) cout<<"DEAD\n";
        else{
            for(ll j=0; j<(ll)a[i].card.size(); j++) cout<<a[i].card[j]<<' ';
            cout<<endl;
        }
    }
    return 0;
}
```

---

## 作者：cirnovsky (赞：4)

## 一个正常人是不会做这种题的...

某年某月某天，我校机房有个可怜人被人强行立了个flag:9月月底做不出来luoguP2482就女装！于是他拼命的调代码。5分，10分，25分......95分。最后实在不行了求救了机房大佬WY才AC。

这位同志的精神感动了机房，于是全机房都开始疯狂的调这道题。我也~~不幸~~幸运的成为了其中的一员。

其实这道题就是模拟，大概是因为我平时闲的没事喜欢做游戏，所以感觉挺简单的。

把各种行为封装成自由函数，当然如果你想建class也没有问题。

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

/*
¡¾ÌÒ¡¿ P
¡¾É±¡¿ K
¡¾ÉÁ¡¿ D
¡¾¾ö¶·¡¿ F
¡¾ÄÏÂùÈëÇÖ¡¿ N
¡¾Íò¼ýÆë·¢¡¿ W
¡¾ÎÞÐ¸¿É»÷¡¿ J
¡¾Öî¸ðÁ¬åó¡¿ Z
*/

const int MAX_PLAYER_NUM = 100 + 5;
const int MAX_CARD_NUM = 2000 + 5;
class PIG
{
public:
	int		card_num;
	int		life_num;
	int		_next;
	int		_last;
	char	identity;
	char	card[MAX_CARD_NUM];
	bool	isGetedZgln;
} A[MAX_PLAYER_NUM];
char	id_in_king[MAX_PLAYER_NUM]; 	//在主公眼里诸猪的身份
char	card_set[MAX_CARD_NUM];
char	scanner[MAX_PLAYER_NUM];
int		n, m, bad_man_num;
bool	GG;  //主公是否GG

inline	 void		initt(	 	 		   	    );
inline	 void		start(		  	 	 	    );
inline	 void		mopai(       int fuck       );  //不知道怎么命名了...
inline	 void		nmrqq(		 int fuck       );
inline	 void		wjqff(		 int fuck       );
inline	 void		jisha( int Killer, int GGer );
inline	 void		killl( int Killer, int GGer );
inline	 void		jdddd( int Killer, int GGer );
inline	 bool		wxkjj(int x1, int x2, int x3);   //为了对齐

signed main()
{
	initt();
	start();
	if (A[1].life_num <= 0)	puts("FP");
	else puts("MP");
	for (int i = 1; i <= n; ++i)
	{
		if (A[i].life_num <= 0)	puts("DEAD");
		else
		{
			for (int j = 1; j <= A[i].card_num; ++j)
				if (A[i].card[j] != 'U')	printf("%c ", A[i].card[j]);
			puts("");
		}
	}
	return 0;
}

inline void	initt()
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; ++i)	A[i]._next = i + 1, A[i]._last = i - 1;
	A[n]._next = 1, A[1]._last = n;
	for (int i = 1; i <= n; ++i)
	{
		for (int j = 1; j < MAX_CARD_NUM; ++j)	A[i].card[j] = 'U';
		scanf("%s", scanner);
		A[i].identity = scanner[0];
		for (int j = 1; j < 5; ++j)	scanf("%s", scanner), A[i].card[j] = scanner[0];
		A[i].life_num = A[i].card_num = 4;
		if (A[i].identity == 'F')	bad_man_num++;
		A[i].isGetedZgln = false;
	}
	id_in_king[1] = 'M';
	for (int i = 2; i <= n; ++i)	id_in_king[i] = 'U';
	for (int i = 1; i <= m; ++i)	scanf("%s", scanner), card_set[m - i + 1] = scanner[0];
}

inline void start()
{
	char now_card;
	GG = true;
	if (bad_man_num) GG = false;
	if (GG)		return;
	for (int i = 1; i; i = A[i]._next)
	{
		mopai(i), mopai(i);
		bool isKilled = true;
		for (int j = 1; j <= A[i].card_num; ++j)
		{
			if (A[i].card[j] != 'U')
			{
				if (!A[i].life_num)	break;
				now_card = A[i].card[j];

				if (now_card == 'P')
				{
					if (A[i].life_num != 4)	A[i].life_num++, A[i].card[j] = 'U';
					continue;
				}

				if (now_card == 'K')
				{
					if (!isKilled && !A[i].isGetedZgln)	continue;
					if ((A[i].identity == 'M') && (id_in_king[A[i]._next] != 'L') && (id_in_king[A[i]._next] != 'F'))
						continue;
					if ((A[i].identity == 'Z') && (id_in_king[A[i]._next] != 'F'))
						continue;
					if ((A[i].identity == 'F') && (id_in_king[A[i]._next] != 'Z') && (id_in_king[A[i]._next] != 'M'))
						continue;
					A[i].card[j] = 'U';
					killl(i, A[i]._next);
					id_in_king[i] = A[i].identity;
					isKilled = false;
					if (GG)	return;
					continue;
				}

				if (now_card == 'F')
				{
					if (A[i].identity == 'F')
					{
						A[i].card[j] = 'U';
						jdddd(i, 1);
						id_in_king[i] = A[i].identity;
						if (GG)	return;
						j = 0;
						continue;
					}
					for (int k = A[i]._next; k != i; k = A[k]._next)
					{
						if ((A[i].identity == 'M' && (id_in_king[k] == 'L' || id_in_king[k] == 'F')) || (A[i].identity == 'Z' && id_in_king[k] == 'F'))
						{
							A[i].card[j] = 'U';
							jdddd(i, k);
							id_in_king[i] = A[i].identity;
							if (GG)	return;
							j = 0;
							break;
						}
					}
					continue;
				}
					

				if (now_card == 'N')
				{
					A[i].card[j] = 'U';
					nmrqq(i);
					if (GG)	return;
					j = 0;
					continue;
				}

				if (now_card == 'W')
				{
					A[i].card[j] = 'U';
					wjqff(i);
					if (GG)	return;
					j = 0;
					continue;
				}

				if (now_card == 'Z')
				{
					A[i].isGetedZgln = true;
					A[i].card[j] = 'U';
					j = 0;
					continue;
				}
			}
		}
	}
}

inline void mopai(int fuck)
{
	if (!m)	m++;
	A[fuck].card[++A[fuck].card_num] = card_set[m];
	m--;
}

inline void nmrqq(int fuck)
{
	for (int shit = A[fuck]._next; shit != fuck; shit = A[shit]._next)
	{
		if (!wxkjj(fuck, shit, 1))
		{
			int i;
			for (i = 1; i <= A[shit].card_num; ++i)
			{
				if (A[shit].card[i] == 'K')
				{
					A[shit].card[i] = 'U';
					break;
				}
			}
			if (i > A[shit].card_num)
			{
				A[shit].life_num--;
				if (shit == 1 && id_in_king[fuck] == 'U')	id_in_king[fuck] = 'L';
				if (!A[shit].life_num) jisha(fuck, shit);
				if (GG)	return;
			}
		}
	}
}

inline void wjqff(int fuck)
{
	for (int shit = A[fuck]._next; shit != fuck; shit = A[shit]._next)
	{
		if (!wxkjj(fuck, shit, 1))
		{
			int i;
			for (i = 1; i <= A[shit].card_num; ++i)
			{
				if (A[shit].card[i] == 'D')
				{
					A[shit].card[i] = 'U';
					break;
				}
			}
			if (i > A[shit].card_num)
			{
				A[shit].life_num--;
				if (shit == 1 && id_in_king[fuck] == 'U')	id_in_king[fuck] = 'L';
				if (!A[shit].life_num)	jisha(fuck, shit);
				if (GG)	return;
			}
		}
	}
}

inline void jisha(int Killer, int GGer)
{
	for (int i = 1; i <= A[GGer].card_num; ++i)
	{
		if (A[GGer].card[i] == 'P')
		{
			A[GGer].card[i] = 'U';
			A[GGer].life_num++;
			return ;
		}
	}
	
	A[A[GGer]._next]._last = A[GGer]._last;
	A[A[GGer]._last]._next = A[GGer]._next;
	
	if (GGer == 1)
	{
		GG = true;
		return ;
	}
	
	if (A[GGer].identity == 'F')	bad_man_num--;
	
	if (!bad_man_num)
	{
		GG = true;
		return ;
	}
	
	if (A[GGer].identity == 'F')	mopai(Killer), mopai(Killer), mopai(Killer);
	
	if (A[GGer].identity == 'Z' && A[Killer].identity == 'M')	A[Killer].card_num = 0, A[Killer].isGetedZgln = false;
}

inline void killl(int Killer, int GGer)
{
	for (int i = 1; i <= A[GGer].card_num; ++i)
	{
		if (A[GGer].card[i] == 'D')
		{
			A[GGer].card[i] = 'U';
			return ;
		}
	}
	A[GGer].life_num--;
	if (!A[GGer].life_num)	jisha(Killer, GGer);
}

inline void jdddd(int Killer, int GGer)
{
	int fuck, shit;
	if (wxkjj(Killer, GGer, 1))	return ;
	
	if (Killer == 1 && A[GGer].identity == 'Z')
	{
		A[GGer].life_num--;
		if (!A[GGer].life_num)	jisha(Killer, GGer);
		return ;
	}
	
	fuck = shit = 1;
	
	while (233)
	{
		while (A[GGer].card[fuck] != 'K' && fuck <= A[GGer].card_num)	++fuck;
		if (fuck > A[GGer].card_num)
		{
			A[GGer].life_num--;
			if (!A[GGer].life_num)	jisha(Killer, GGer);
			return ;
		}
		else A[GGer].card[fuck] = 'U';
		
		while (A[Killer].card[shit] != 'K' && shit <= A[Killer].card_num)	++shit;
		if (shit > A[Killer].card_num)
		{
			A[Killer].life_num--;
			if (!A[Killer].life_num)	jisha(GGer, Killer);
			return ;
		}
		else A[Killer].card[shit] = 'U';
	}
}

inline bool wxkjj(int x1, int x2, int x3)
{
	int i = x1;
	while (233)
	{
		if (x3 == 1)
		{
			if (id_in_king[x2] == A[i].identity || (id_in_king[x2] == 'M' && A[i].identity == 'Z') || (id_in_king[x2] == 'Z' && A[i].identity == 'M'))
			{
				for (int j = 1; j <= A[i].card_num; ++j)
				{
					if (A[i].card[j] == 'J')
					{
						A[i].card[j] = 'U';
						id_in_king[i] = A[i].identity;
						return !wxkjj(i, x1, 0);
					}
				}
			}
		}
		
		else
		{
			if (((A[i].identity == 'M' || A[i].identity == 'Z') && id_in_king[x1] == 'F') || (A[i].identity == 'F' && (id_in_king[x1] == 'M' || id_in_king[x1] == 'Z')))
			{
				for (int j = 1; j <= A[i].card_num; ++j)
				{
					if (A[i].card[j] == 'J')
					{
						A[i].card[j] = 'U';
						id_in_king[i] = A[i].identity;
						return !wxkjj(i, x1, 0);
					}
				}
			}
		}
		i = A[i]._next;
		if (i == x1)	break;
	}
	return false;
}
```



---

## 作者：gongbangrui (赞：4)


题解
------------

　　为了给后面入坑的人一些提醒，本题题目较长，请耐心读完题目，否则会导致T,WA,E据说如果你耐心照着题目打你会得到30分，于是良心的我就先说一些题目没说或说的模糊或会坑你半个小时的东西。
  
　1.n<=10.
    
　2.牌堆会被摸完，此时一直取最后一张。（话说不能重新把废牌洗一吗）
    
　3.无懈可击对非无懈可击是用时目的是要保护目标而不是恶心出牌人。
    
　4.可以给他人使用无懈可击
    
　5.可以不断用无懈可击无懈无懈可击。
    
　6.无懈可击使用时先从出锦囊牌的人开始判定是否打出无懈。
    
　7.使用决斗把自己干死时记得自己就不要出牌了。
    
　8.类反猪不算身份明了，该身份唯一的目的就是让主公去打他。
    
　9.不要瞎打else，博主被自己打的else坑了好几次。
    
  10.~~平时不要只学习，多打点游戏很重要，说不定下次联赛就考了狼人杀~~
    
　11.数组在能开大的时候尽量开大点，就算是联赛也会出现数据大于给出的范围的情况。
 
　　说到底，还是一个大模拟，算法什么的真的用不到太高级的，撑死就是链表。

解法
------------

　　好在题目没有给出内奸，闪电，防具，麒麟弓，猪物技能等设定，我们对于大部分操作我们基本对各个身份的猪一视同仁，游戏规则除了桃只能自己用以外和三国杀没什么不同。
　　最恶心人的可能就只有两点，一个是无懈可击，一个是身份判断，因此我就只说这两个了，别的就按照暴力实现就好了。
　　　对于无懈可击，使用只有两种情况：
　　　　　　1.对于无懈可击使用，是对那张无懈可击的使用者表敌意，身份显现。并且符合敌人的敌人就是朋友的性质。
　　　　　　2.对于其他锦囊牌使用，对于即将挨打的那一方献殷勤，身份显现。
　　　　　因此我们对于对无懈可击对无懈可击使用的情况单独打一个函数，因为他会无限递归。而对于锦囊牌使用无懈，我们单独复制粘贴一下就好了。
　　　对于身份：
　　　　　我们基本可以认为只要出一张非南蛮和万箭的锦囊牌就会表示身份，值得注意的是我们要在出这张牌之前把他的身份更新，这样就会为无懈可击提供目标。类反猪只是一个临时身份，一旦他跳忠后就不会再被认为是类反猪，哪怕他不管主公死活狂刷南蛮。
　　至于其他的，自己打一打也就差不多了。
    贴上AC代码

代码
------------

```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cstring>
#include <queue>
#include <algorithm>
#include <cmath>
#include <map>
#include <set>
#define N 15
#define M 2105
#define tao 1
#define sha 2
#define shan 3
#define jue 4
#define man 5
#define wan 6
#define wu 7
#define nu 8
using namespace std;
int pre[N],fro[N],n,m;
int st[M],top;//牌堆，注意为0时一直摸最后一张牌
struct pi
{    
    int ip;//身份
    int jump;//是否跳反/忠    
    int q[M],en,hea,hp;//血量
    bool ln;//是否有连弩
}pig[N];
char bbb[20];
void print()//输出每一只猪的血量，身份，是否跳身份
{
    for(int i=1;i<=n;i++)
    {
        cout<<pig[i].hp<<' '<<pig[i].ip<<' '<<pig[i].jump<<endl;
    }
    cout<<endl;
}
void print2()//输出场上有哪些玩家存活
{
    int now=1;bool yx=1;
    while(now!=1||yx)
    {
        yx=0;
        cout<<now<<' ';
        now=fro[now];
    }
    cout<<endl;
}
void show(int x)//展示手牌
{
    for(int i=pig[x].hea;i<=pig[x].en;i++)
    {
        if(pig[x].q[i])
        {
            cout<<pig[x].q[i]<<' ';
        }
    }
    cout<<endl<<endl;
}
int check(char x)
{    
    if(x=='P') return tao;
    else if(x=='K') return sha;
    else if(x=='D') return shan;
    else if(x=='F') return jue;
    else if(x=='N') return man;
    else if(x=='W') return wan;
    else if(x=='J') return wu;
    else return nu;
}
void get_pok(int x,int js)//第x只猪摸的第js张牌
{
    if(js==3)return;
    if(!top) top=1;
    pig[x].en++;
    pig[x].q[pig[x].en]=st[top];
    top--;
    get_pok(x,js+1);
}
void zl(int x)//整理玩家x手中的牌
{
    for(int j=pig[x].hea;j<=pig[x].en;j++)
    {
        if(pig[x].q[j]!=0)
        {
            pig[x].hea=j;
            for(int k=pig[x].en;k>=pig[x].hea;k--)
            {
                if(pig[x].q[k]!=0)
                {
                    pig[x].en=k;
                    break;
                }
            }
            break;
        }
        if(j==pig[x].en)
        {
            pig[x].en=0;
            pig[x].hea=pig[x].en+1;
        }
    }
}
void come_to_end(int x)//一切都结束了
{
    if(x==1)
        printf("MP\n");
    else
        printf("FP\n");
    int js=0;
    for(int i=1;i<=n;i++)
        if(pig[i].hp)js++;
    for(int i=1;i<=n;i++)
    {
        if(pig[i].hp==0) printf("DEAD\n");
        else
        {
            zl(i);
            for(int j=pig[i].hea;j<pig[i].en;j++)
            {
                if(!pig[i].q[j])continue;
                int y=pig[i].q[j];
                if(y==tao)printf("P ");
                else if(y==sha)printf("K ");
                else if(y==shan)printf("D ");
                else if(y==nu) printf("Z ");
                else if(y==jue) printf("F ");
                else if(y==man) printf("N ");
                else if(y==wan) printf("W ");
                else if(y==wu) printf("J ");
            }
            int y=pig[i].q[pig[i].en];
            if(y==tao)printf("P");
            else if(y==sha)printf("K");
            else if(y==shan)printf("D");
            else if(y==nu) printf("Z");
            else if(y==jue) printf("F");
            else if(y==man) printf("N");
            else if(y==wan) printf("W");
            else if(y==wu) printf("J");
            printf("\n");
        }
    }
    exit(0);
}
void gua(int x,int from)//被from打挂了
{
    cout<<from<<"has killed "<<x<<endl;
    pre[fro[x]]=pre[x];
    fro[pre[x]]=fro[x];
    if(x==1) come_to_end(3);
    int now=fro[1];
    bool yx=1;
    while(now!=1)
    {
        if(pig[now].ip==3)
        {
            yx=0;
            break;
        }
        now=fro[now];
    }
    if(yx)come_to_end(1);
    if(pig[x].ip==2&&pig[from].ip==1)
    {
        memset(pig[from].q,0,sizeof(pig[from].q));
        pig[from].ln=0;
        pig[from].hea=1,pig[from].en=0;
    }
    else if(pig[x].ip==3)
        get_pok(from,0);
}
void lost(int x,int from)//检查是否死透
{
    if(pig[x].hp==0)
    {
        for(int i=pig[x].hea;i<=pig[x].en;i++)
        {
            if(pig[x].q[i]==tao)
            {
                pig[x].hp++;
                pig[x].q[i]=0;
                zl(x);
                return ;
            }
        }
        gua(x,from);
    }
}
void kill(int x)//x对下家出杀
{
    int to=fro[x];
    cout<<x<<" hit "<<to<<endl;
    bool yx=1;
    for(int i=pig[to].hea;i<=pig[to].en;i++)
    {
        if(pig[to].q[i]==shan)
        {
            pig[to].q[i]=0;
            yx=0;
            zl(to);
            break;
        }
    }
    if(yx)
    {
        cout<<to<<"is hurt!"<<endl;
        pig[to].hp--;
        lost(to,x);
    }
}
bool use_wu(int x)//x使用无懈是否成功
{
    int now=fro[x];
    while(now!=x)
    {
        if((pig[now].ip==3&&pig[x].jump!=3)||(pig[now].ip!=3&&pig[x].jump==3))
        {
            for(int i=pig[now].hea;i<=pig[now].en;i++)
            {
                if(pig[now].q[i]==wu)
                {
                    pig[now].q[i]=0;
                    if(pig[now].ip==3)pig[now].jump=3;
                    else if(pig[now].ip==2) pig[now].jump=2;
                    zl(now);
                    if(use_wu(now))    return 0;
                    else return 1;
                }
            }
        }
        now=fro[now];
    }
    return 1;
}
void come_to_fight(int x,int y)//x对y决斗
{
    cout<<x<<"want to fight with "<<y<<endl;
    int now=fro[x];
    if(pig[y].jump&&pig[y].jump!=-1)
    {
        while(now!=x)
        {
            if((pig[now].ip==3&&pig[y].jump==3)||(pig[y].jump!=3&&pig[now].ip!=3))
            {
                bool yx=1;
                for(int i=pig[now].hea;i<=pig[now].en;i++)
                {
                    if(pig[now].q[i]==wu)
                    {    
                        pig[now].q[i]=0;
                        if(pig[now].ip==3)pig[now].jump=3;
                        else if(pig[now].ip==2) pig[now].jump=2;
                        zl(now);
                        yx=0;
                        if(use_wu(now))return;
                    }
                }
                if(!yx)break;
            }
            now=fro[now];
        }
    }
    if(pig[x].ip==1&&pig[y].ip==2)
    {
        pig[y].hp--;
        lost(y,x);
        return;
    }
    int js1=0,js2=0;
    for(int i=pig[x].hea;i<=pig[x].en;i++)
        if(pig[x].q[i]==sha)js1++;
    for(int i=pig[y].hea;i<=pig[y].en;i++)
        if(pig[y].q[i]==sha) js2++;
    if(js1<js2)
    {
        int js3=0;
        for(int i=pig[y].hea;i<=pig[y].en;i++)
        {
            if(pig[y].q[i]==sha)
            {
                js3++;
                pig[y].q[i]=0;
                if(js3==js1+1)break;
            }
        }
        for(int i=pig[x].hea;i<=pig[x].en;i++)
        {
            if(pig[x].q[i]==sha)
            {
                pig[x].q[i]=0;    
            }
        }
        zl(x),zl(y);
        pig[x].hp--;
        lost(x,y);
        cout<<x<<"failed!"<<endl;
    }
    else
    {
        int js3=0;
        for(int i=pig[x].hea;i<=pig[x].en;i++)
        {
            if(pig[x].q[i]==sha)
            {
                if(js3==js2)break;
                js3++;
                pig[x].q[i]=0;
            }
        }
        for(int i=pig[y].hea;i<=pig[y].en;i++)
        {
            if(pig[y].q[i]==sha)
                pig[y].q[i]=0;    
        }
        zl(x),zl(y);
        pig[y].hp--;
        lost(y,x);
        cout<<y<<"failed!"<<endl;
    }
}
void nanman(int x) //南蛮入侵
{
    cout<<"everyone need to give up a K or you will hurt by "<<x<<endl;
    int now=fro[x];
    while(now!=x)
    {
        if(pig[now].jump&&pig[now].jump!=-1)
        {
            bool yx2=0;
            int now2=x;
            bool yxxx=1;
            while(now2!=x||yxxx)
            {
                yxxx=0;
                if((pig[now2].ip==3&&pig[now].jump==3)||(pig[now2].ip!=3&&pig[now].jump!=3))
                {
                    bool yx=1;
                    for(int i=pig[now2].hea;i<=pig[now2].en;i++)
                    {
                        if(pig[now2].q[i]==wu)
                        {    
                            pig[now2].q[i]=0;
                            if(pig[now2].ip==3)pig[now2].jump=3;
                            else if(pig[now2].ip==2) pig[now2].jump=2;
                            zl(now2);
                            yx=0;
                            if(use_wu(now2))
                            {
                                yx2=1;
                                break;
                            }
                            else break;
                        }
                    }
                    if(!yx)break;
                }
                if(yx2)break;
                now2=fro[now2];
            }
            if(yx2)
            {
                now=fro[now];continue;
            }
        }
        bool yx=1;
        for(int i=pig[now].hea;i<=pig[now].en;i++)
        {
            if(pig[now].q[i]==sha)
            {
                pig[now].q[i]=0;
                zl(now);
                yx=0;
                break;
            }
        }
        if(yx)
        {
            pig[now].hp--;
            if(now==1&&!pig[x].jump)pig[x].jump=-1;
            lost(now,x);
        }
        now=fro[now];
    }
}
void wanjian(int x) //万箭齐发
{
    cout<<"everyone need to give up a D or you will hurt by "<<x<<endl;
    int now=fro[x];
    while(now!=x)
    {
        if(pig[now].jump&&pig[now].jump!=-1)
        {
            bool yx2=0;
            int now2=x;
            bool yxxx=1;
            while((now2!=x)||yxxx)
            {
                yxxx=0;
                if((pig[now2].ip==3&&pig[now].jump==3)||(pig[now2].ip!=3&&pig[now].jump!=3))
                {
                    bool yx=1;
                    for(int i=pig[now2].hea;i<=pig[now2].en;i++)
                    {
                        if(pig[now2].q[i]==wu)
                        {    
                            pig[now2].q[i]=0;
                            if(pig[now2].ip==3)pig[now2].jump=3;
                            else if(pig[now2].ip==2) pig[now2].jump=2;
                            zl(now2);
                            yx=0;
                            if(use_wu(now2))
                            {
                                yx2=1;
                                break;
                            }
                            else break;
                        }
                    }
                    if(!yx)break;
                }
                if(yx2)break;
                now2=fro[now2];
            }
            if(yx2)
            {
                now=fro[now];continue;
            }
        }
        bool yx=1;
        for(int i=pig[now].hea;i<=pig[now].en;i++)
        {
            if(pig[now].q[i]==shan)
            {

                pig[now].q[i]=0;
                zl(now);
                yx=0;
                break;
            }
        }
        if(yx)
        {
            pig[now].hp--;
            if(now==1&&!pig[x].jump)pig[x].jump=-1;
            lost(now,x);
        }
        now=fro[now];
    }
}
void second_stage(int x,int js) //出牌阶段，出了几张杀
{
    cout<<x<<' '<<js<<endl;
    print();
    for(int i=pig[x].hea;i<=pig[x].en;i++)
    {
        if(!pig[x].q[i]||pig[x].q[i]==shan||pig[x].q[i]==wu||(pig[x].q[i]==sha&&js&&!pig[x].ln))continue;
        if(pig[x].hp!=4&&pig[x].q[i]==tao)
        {
            cout<<x<<"come back to life"<<endl;
            pig[x].hp++;
            pig[x].q[i]=0;
            zl(x);
            second_stage(x,js);
            return;
        }
        else if(pig[x].q[i]==sha)
        {
            if(pig[x].ip==1&&pig[fro[x]].jump&&pig[fro[x]].jump!=2)
            {
                pig[x].q[i]=0; zl(x);
                kill(x);
                second_stage(x,js+1);
                return;
            }
            else if(pig[x].ip==2&&pig[fro[x]].jump==3)
            {
                pig[x].jump=2;
                pig[x].q[i]=0; zl(x);
                kill(x);
                second_stage(x,js+1);
                return;
            }
            else if(pig[x].ip==3&&(pig[fro[x]].jump==1||pig[fro[x]].jump==2))
            {
                pig[x].jump=3;
                pig[x].q[i]=0; zl(x);
                kill(x);
                second_stage(x,js+1);
                return;
            }
        }
        else if(pig[x].q[i]==nu)
        {
            pig[x].q[i]=0;
            pig[x].ln=1;
            zl(x);
            second_stage(x,js);
            return;
        }
        else if(pig[x].q[i]==jue)
        {
            if(pig[x].ip==1)
            {
                int now=fro[1];
                while(now!=1)
                {
                    if(pig[now].jump==-1||pig[now].jump==3)
                    {
                        pig[x].q[i]=0;
                        zl(x);
                        come_to_fight(x,now);
                        if(pig[x].hp==0)return;
                        second_stage(x,js);
                        return;
                        break;
                    }
                    now=fro[now];
                }
            }
            else if(pig[x].ip==2)
            {
                int now=fro[x];
                while(now!=x)
                {
                    if(pig[now].jump==3)
                    {
                        pig[x].q[i]=0;
                        zl(x);
                        pig[x].jump=2;
                        come_to_fight(x,now);
                        if(pig[x].hp==0)return;
                        second_stage(x,js);
                        return;
                        break;
                    }
                    now=fro[now];
                }
            }
            else 
            {
                pig[x].jump=3;
                pig[x].q[i]=0;
                zl(x);
                come_to_fight(x,1);
                if(pig[x].hp==0)return;
                second_stage(x,js);
                return;
            }
        }
        else if(pig[x].q[i]==man)
        {
            pig[x].q[i]=0;
            zl(x);
            nanman(x);
            second_stage(x,js);
            return;
        }
        else if(pig[x].q[i]==wan)
        {
            pig[x].q[i]=0;
            zl(x);
            wanjian(x);
            second_stage(x,js);
            return;
        }
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        pre[i]=i-1;
        fro[i]=i+1;
        pig[i].hp=4;
        scanf("%s",bbb);
        if(bbb[0]=='M')pig[i].jump=pig[i].ip=1;//主公
        else if(bbb[0]=='Z') pig[i].ip=2;//忠臣
        else pig[i].ip=3;//反贼
        pig[i].hea=1;
        for(int j=1;j<=4;j++)
        {
            scanf("%s",bbb);
            pig[i].en++;
            pig[i].q[pig[i].en]=check(bbb[0]);
        }
    }
    pre[1]=n;
    fro[n]=1;
    top=m;
    for(int i=1;i<=m;i++)
    {
        scanf("%s",bbb);
        st[top-i+1]=check(bbb[0]);
    }
    int now=1;
    while(1)
    {
        get_pok(now,1);//当前猪摸牌
        second_stage(now,0);
        now=fro[now];
    }
    return 0;
}
/*3 4  
MP J J K N   
ZP J D K W   
FP P N P K   
J J K W 

3 1  
MP D N F K  
ZP F W F N  
FP D N N D  
K  

5 10  
MP W D F K   
ZP N N D D   
FP F W W K   
ZP K K N D   
FP K D P W   
J K W K D N N K J N

3 10  
MP W D J W   
ZP J P D N   
FP N D F F   
J D N N F J J D K W 

3 6
MP W J J D
FP N F F K
ZP J J F F
P P K K F W
*/ 

带注释代码（附带小样例）
```

呵呵，六百行代码

---

## 作者：zzw4257 (赞：3)

### 简述
~~简述个鬼~~
[思维导图版本](https://mubu.com/doc/PLHEif1xo)

### Solution

我写之前学习了[loj这位大佬的提交](https://loj.ac/submission/606249)(我不会说是我写到一半发现无懈可击不怎么会写),然后后来就把其他部分改得跟他一致了(他写得太精简了，下面会说明),希望为他起一个注解的作用

这是一个类似(~~抄袭~~)三国杀的游戏

我们一句一句的来看一只猪有那些信息:

>主猪（MP）：自己存活的情况下消灭所有的反猪。
忠猪（ZP）：不惜一切保护主猪，胜利条件与主猪相同。
反猪（AP）：杀死主猪。

这是类型

>游戏开始时候，每个玩家手里都会有4张牌，且体力上限和初始体力都是4。

这是体力，和牌

>1.如果没有猪哥连弩，每个出牌阶段只能使用一次“杀”来攻击；
2.任何牌被使用后被弃置（武器是装备上）；

牌分为手牌(消耗品),武装(永久品):只有猪哥连弩

>◎献殷勤：使用无懈可击挡下南猪入侵、万箭齐发、决斗；使用无懈可击抵消表敌意；
◎表敌意：对某个角色使用杀、决斗；使用无懈可击抵消献殷勤；
◎跳忠：即通过行动表示自己是忠猪。跳忠行动就是对主猪或对某只已经跳忠的猪献殷勤，或者对某只已经跳反的猪表敌意；
◎跳反：即通过行动表示自己是反猪。跳反行动就是对主猪或对某只已经跳忠的猪表敌意，或者对某只已经跳反的猪献殷勤；
忠猪不会跳反，反猪也不会跳忠；不管是忠猪还是反猪，能够跳必然跳；

除了主猪外只有通过跳身份的办法来显示身份

所以我们定义一只猪
```cpp
struct Pig{
	char type,card[M],weapon,show;//类型,卡,武器有无,我表示(不表示0)我是什么身份(1忠/主猪,2反猪,3类反猪)
	int heal,cardnum;//血量,卡数 
}a[N];
```

他的行为有抽牌，用牌，找牌(并用掉)

```cpp
struct Pig{
	char type,card[M],weapon,show;//类型,卡,武器有无,我表示(不表示0)我是什么身份 
	int heal,cardnum;//血量,卡数 
	inline void Delete(re int&x){re int i;--cardnum;for(i=x;i<=cardnum;++i)card[i]=card[i+1];--x;}//丢掉第x张牌
	inline char Find(re char a){re int i;for(i=1;i<=cardnum;++i)if(card[i]==a)return Delete(i),1;return 0;}//检查手牌有没有a
	inline void Get(re int x){while(x--){card[++cardnum]=st[++top];if(top==m)--top;}}//牌堆摸x张 
}a[N];
```

另外我们用一个双向链表来维护猪之间位置关系，这样删除很方便

接下来看手牌

>◎基本牌：
『桃(P)』：在自己的回合内，如果自己的体力值不等于体力上限，那么使用一个桃可以为自己补充一点体力，否则不能使用桃；桃只能对自己使用；在自己的回合外，如果自己的血变为0或者更低，那么也可以使用；
『杀(K)』：在自己的回合内，对攻击范围内除自己以外的一名角色使用。如果没有被『闪』抵消，则造成1点伤害。无论有无武器，杀的攻击范围都是1；
『闪(D)』：当你受到杀的攻击时，可以弃置一张闪来抵消杀的效果；
◎锦囊牌：
『决斗(F)』：出牌阶段，对除自己以外任意一名角色使用，由目标角色先开始，自己和目标角色轮流弃置一张杀，首先没有杀可弃的一方受到1点伤害，另一方视为此伤害的来源；
『南猪入侵(N)』：出牌阶段，对除你以外所有角色使用，按逆时针顺序从使用者下家开始依次结算，除非弃置一张杀，否则受到1点伤害；
『万箭齐发(W)』：和南猪入侵类似，不过要弃置的不是杀而是闪；
『无懈可击(J)』：在目标锦囊生效前抵消其效果。每次有一张锦囊即将生效时，从使用这张锦囊的猪开始，按照逆时针顺序，依次得到使用无懈可击的机会；
效果：用于决斗时，决斗无效并弃置；用于南猪入侵或万箭齐发时，当结算到某个角色时才能使用，当前角色不需弃置牌并且不会受到伤害（仅对一个角色产生效果）；用于无懈可击时，成为目标的无懈可击被无效。

我们会发现『杀(K)』『南猪入侵(N)』『万箭齐发(W)』攻击力都是1,新建一个功能$Defend(x,y)$表示$x$成功伤害$y$,注意到这一次可能触发

>如果自己的血变为0或者更低，那么也可以使用桃

还可能杀死它猪

```cpp
inline void Defend(re int x,re int y){//x砍y一点血 
	if(!--a[y].heal)a[y].heal+=a[y].Find('P');//能用桃就用 
	if(!a[y].heal)Kill(x,y);//杀死了
}
```

对于$x$杀死$y$，先看胜利条件
>主猪（MP）：自己存活的情况下消灭所有的反猪。
忠猪（ZP）：不惜一切保护主猪，胜利条件与主猪相同。
反猪（AP）：杀死主猪。

再判一下几种情况

>◎玩家死亡：如果该玩家的体力降到0或者更低，并且自己手中没有足够的桃使得自己的体力值回到1，那么就死亡了，死亡后所有的牌（装备区，手牌区）被弃置；
◎奖励与惩罚：反猪死亡时，最后一个伤害来源处（即使是反猪）立即摸三张牌。忠猪死亡时，如果最后一个伤害来源是主猪，那么主猪所有装备牌、手牌被弃置；
◎注意，一旦达成胜利条件，游戏立刻结束，因此即使会摸3张牌或者还有牌可以用也不用执行了。

```cpp
inline void Kill(re int x,re int y){//x把y杀了的结果 
	if(a[y].type=='M')Print();//忠猪被杀 
	if(a[y].type=='F'){
		if(!(--enemynum))Print();//敌人杀完 
		a[x].Get(3);//没结束要摸牌
	}
	else if(a[x].type=='M'&&a[y].type=='Z')a[x].cardnum=a[x].weapon=0;//我杀我忠猪
	r[l[y]]=r[y],l[r[y]]=l[y];//去掉y
}
```

最困难的判定是无懈可击，我们要看$x$可不可以攻击$y$,首先看$y$可不可以被队友(这地方就涉及到显示的身份)无效，然后再看这个无效可不可以被**成功**无效(成功无效就代表之后再没有一个无效)

我们会发现这是一个递归的过程，重点是理解无效本身是一种会被无效的行为

```cpp
inline char WXKJ(re int x,re int y){
	re int i;re char first; 
	for(i=x,first=1;(first||(i^x));i=r[i],first=0)
		if((!y?CanDefend(i,x):MyPig(i,y))&&a[i].Find('J')){//有y是看友军可不可以无效别人攻击保护你，没y是看敌人可不可以无效你的无效,递归次数%2表示到底实在阻止这场攻击发生 
			a[i].show=(a[i].type=='F'?2:1);
			return !WXKJ(i,0);//你不能无效我才发动行为(包括无效)成功
		}
	return 0;
}
```

在这里判定别人是什么猪就要用到别人显示的身份(而不是真实身份)

```cpp
inline char CanDefend(re int x,re int y){
	return ((a[x].type=='M'&&(a[y].show==2||a[y].show==3))||(a[x].type=='Z'&&a[y].show==2)||(a[x].type=='F'&&a[y].show==1));
}
inline char MyPig(re int x,re int y){
	return (((a[x].type=='M'||a[x].type=='Z')&&a[y].show==1)||(a[x].type=='F'&&a[y].show==2));
}
```

然后具体写每个手牌的操作就可以了

### Code
[这里](https://paste.ubuntu.com/p/NBqMWgmdDt/)

---

## 作者：切格瓦·星 (赞：3)

猪国杀.......

我只讲个大概吧....

最难的的就是无懈可击的函数了，我这里用了和我同一机房的大佬的递归方法，主要就是分清楚献殷勤和表敌意的对象就行了，代码如下

我们可以设$From$表示这个动作的发起者，$to$为承受者，再有一个$ty$表示这个动作的类型(表敌意或献殷勤)。

这样我们可以写出我们递归函数的变量定义了
```cpp
bool No_way(int From,int to,int ty)//ty==1为表敌意，ty==0为献殷勤

```
再看看题目

```
『无懈可击(J)』：在目标锦囊生效前抵消其效果。每次有一张锦囊即将生效时,
从使用这张锦囊的猪开始，按照逆时针顺序，依次得到使用无懈可击的机会;
```
说明使用这张锦囊牌的猪也是可以使用无懈可击的，所以内部的循环函数我们要从$From$开始，也是到$From$结束,大致如下：
```cpp
int tag=0,x=From;
for(;x!=From||!tag;x=pl[x].nxt){ 
	tag=1;//tag使我们保证这张牌的发起者也可以用无懈可击
   
   	your code here.....
    
} 
	return 0;
```
我们再考虑：无懈可击是可以多人之间互相用来用去的，而且根据题目
```
献殷勤：使用无懈可击挡下南猪入侵、万箭齐发、决斗；使用无懈可击抵消表敌意；
表敌意：对某个角色使用杀、决斗；使用无懈可击抵消献殷勤；
```
说明能出就一定会出，而且出了无懈可击的猪它的身份一定会表明的，我思索了很久，写出了以下代码:
```cpp
if((!ty&&Fuck(x,to))||(ty&&Kiss(x,to))){  
	if(pd(x,7)){ 
		pl[x].Jump=1;if(!No_way(x,to,ty^1)) return 1;
	} 
}
	return 0;
```
其中F__k函数为判断表敌意是否成功的函数，Kiss则是判断献殷勤是否成功的函数，具体实现只需列举$x$与$to$的身份然后逐一判断即可

函数解释：

$x$为我们枚举到的猪，若$From$是向$to$献殷勤，那么要抵消献殷勤的行为便是表敌意，反之则是献殷勤，$pd$函数很简单，单纯的判断$x$有没有无懈可击如果有就删除返回1，没有返回0。我的$pl$结构体存每只猪的状态，$Jump$标记表示这只猪跳没跳，不管这只猪的身份是什么，只要用了无懈可击就一定跳了，接下来就是递归的判断还有没有别的猪能抵消这只猪的无懈可击就行了，总体如下:
```cpp
bool No_way(int From,int to,int ty){ int tag=0,x=From;
	for(;x!=From||!tag;x=pl[x].nxt){ tag=1;
		if((!ty&&Fuck(x,to))||(ty&&Kiss(x,to))){  
			if(pd(x,7)){ 
				pl[x].Jump=1;if(!No_way(x,to,ty^1)) return 1;
			} 
		}
	} 
	return 0;
} 
```
再使用锦囊牌之前判断一下这个函数即可。下面给出锦囊牌的函数

(先给出每张牌的对应函数)

```cpp
int bian(char a){ 
	if(a=='P') return 1;//桃 
	if(a=='K') return 2;//杀 
	if(a=='D') return 3;//闪 
	if(a=='F') return 4;//决斗 
	if(a=='N') return 5;//南蛮入侵 
	if(a=='W') return 6;//万箭齐发 
	if(a=='J') return 7;//无懈可击 
	if(a=='Z') return 8;//诸葛连弩 
} 
```
决斗：
```cpp
这个函数无懈可击我是放在外面判的，没人能出无懈才进这个函数
cd[x][y]表示x猪的编号为y的牌，我是用链表存牌的，链表起点恒为0，终点则为End;
cd[x][y].sel表示这张牌的类型；
void Solo(int From,int to){ 
	int x,y,flag,pig;//pig为这次决斗扣血的猪
	if(!(pl[From].sel==1&&pl[to].sel==2)){ 
		while(1){
			flag=0;
			x=0,y=0;
			while(x!=End){
				if(cd[to][x].sel==2){ 
					Del_card(to,x),flag=1;
					break;
				} 
				x=cd[to][x].nxt;
			} 
			if(!flag){ 
				pig=to;break; 
			} 
			flag=0; 
			while(y!=End){ 
				if(cd[From][y].sel==2){ 
					Del_card(From,y),flag=1;
					break;
				} 
				y=cd[From][y].nxt;
			} 
			if(!flag){ 
				pig=From;break ;
			} 
		}  
	} 
	else pig=to;
	pl[pig].blood--;
	if(Dead_or_alive(pig)){ //判断死没死
		Del_pig(pig); 
		if(pl[pig].sel==3){ 
			num_of_fz--;
			if(!num_of_fz){ 
				Game_end=1;return;
			} 
			if(pig==From) mopai(to,3);
			else mopai(From,3);//杀反猪摸牌
		} 
		else if(pl[pig].sel==1){ 
			Game_end=1;return;
		} 
		else{ 
			if(pig==to&&pl[From].sel==1) quanqi(From);//主猪杀忠猪弃牌
		} 
	} 
} 
```
南猪入侵：

```cpp
意思多相同，注意南猪入侵与万箭齐发在枚举到每个承受者时都要判断无懈可击
void Pig_attack(int From){ 
	int x=pl[From].nxt;
	while(x!=From){ 
		if(!No_way(From,x,1)){ 
			int y=0,flag=0;
			while(y!=End){ 
				if(cd[x][y].sel==2){ 
					Del_card(x,y);flag=1;
					break;
				} 
				y=cd[x][y].nxt;
			} 
			if(!flag){ 
				pl[x].blood--;
				if(pl[x].sel==1&&!pl[From].Jump) pl[From].lf=1;
				if(Dead_or_alive(x)){ 
					Del_pig(x);
					if(pl[x].sel==1||(pl[x].sel==3&&num_of_fz==1)){ 
						Game_end=1;return;
					} 
					else if(pl[x].sel==3) mopai(From,3),num_of_fz--;
					else if(pl[x].sel==2&&pl[From].sel==1)	quanqi(From);
				}
			}
		}
		x=pl[x].nxt;
	}
}
```
万箭齐发和南猪入侵一模一样，只是躲避牌由杀变成了闪；

其他函数~~~~过于简单~~~~这里就不放出来了

注意每用一张牌都要从头重新枚举手牌

祝大家早日A了这题~~

---

## 作者：renhr2002 (赞：3)

这道题,或许是我做的模拟中,码量最大的一道了(~~之前,我一直以为时间复杂度很难,现在不这么认为了,表示以后再也不想做模拟了~~)

不过,这题练代码能力也不错,那我就来H3BO3一发吧

在模拟时，找到第一张手牌是关键，我用了8条队列维护每一张牌是第几次摸的

接下来，分析一下每个分值的暴力（正解）的注意点：

10pts：

- 坑：牌堆中的牌不一定够用，这时，需要一直摸最后一张
- 最开始，只有主公亮明身份，所以此时n号角色一定是反贼，否则没有任何其他角色能够跳忠（反）
- 在这步，实际不需要记录“类反猪”，因为没有AOE锦囊
- 在角色的回合中不能出闪
- 装备武器时，所有的武器牌都会被打出，不能只出一张

30pts：

- 反贼的决斗对象永远是主公
- 使用AOE锦囊时，使用者不会亮明身份，但是有可能成为“类反猪”
- 上述两点也决定了10分时“n一定是反贼”不成立了，因为有了其他途径表明身份
- AOE锦囊可能导致多个角色死亡，需要考虑摸牌、主公弃牌的顺序，另外，游戏结束条件一旦达成，游戏要立刻结束，不能继续判定AOE
- 使用决斗可能导致使用者死亡，此时它的回合必须立刻结束
- “类反猪”只在主公的视角才成立，在其他角色看来，它的身份是未知的

100pts：

- 无懈可击需要递归，来判断最终是否生效
- 判定无懈时，需要考虑无懈使用后，锦囊是否生效，这也决定了使用无懈是献殷勤还是表敌意
- 注意使用无懈可击的顺序
- 角色的回合中不能出无懈可击

实际上，从题面来看，只有这3个分值，不过，当你真正写的时候，会经历各种写挂、被坑、打补丁，也就有了各种各样的部分分

AC代码：（~~码量确实很大~~）

```cpp
#include<map>
#include<queue>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int N,M;
struct node
{
    char id[3];
    int bl;
    bool dead;
    bool zs;
    bool fs;
    bool fl;
    queue<int>card[9];
    int cnt;
    int kcnt;
    int dcnt;
    int pcnt;
    int jcnt;
    bool zg;
    bool as;
}nd[16];
char str[2];
queue<int>q;
map<char,int>m;
map<int,char>mt;
int fc;//剩余反贼数量 
int nxt[16];//每个角色的下家 
bool gameover;
int search(int x)//寻找角色x的决斗对象 
{
    if(nd[x].id[0]=='F')
    {
        return 1;
    }
    for(int i=nxt[x];i!=x;i=nxt[i])
    {
        if(nd[x].id[0]=='M'&&(nd[i].fs==1||nd[i].fl==1))
        {
            return i;
        }else if(nd[x].id[0]=='Z'&&nd[i].fs==1)
        {
            return i;
        }
    }
    return 0;
}
int fcard(int x,bool gover)//寻找角色x的最左边一张可用手牌 
{
    int cnt=0;
    int pla=0x3f3f3f3f;
    for(int i=1;i<=8;i++)
    {
        if(nd[x].card[i].size()&&nd[x].card[i].front()<pla)//如果这张比之前可用位置更靠左 
        {
            if(gover==0&&i==2&&(nd[x].zg==0&&nd[x].as==1))//如果没有连弩,不能出多张杀 
            {
                continue;
            }else if(gover==0&&(i==3||i==7))//回合中不能出闪/无懈可击 
            {
                continue;
            }else if(gover==0&&(i==1&&nd[x].bl==4))//血量满时,不能吃桃 
            {
                continue;
            }else if(gover==0&&i==2)//角色出杀能否找到攻击对象 
            {
                if(nd[x].id[0]=='M')
                {
                    if(nd[nxt[x]].fs==0&&nd[nxt[x]].fl==0)
                    {
                        continue;
                    }
                }else if(nd[x].id[0]=='Z')
                {
                    if(nd[nxt[x]].fs==0)
                    {
                        continue;
                    }
                }else
                {
                    if(nd[nxt[x]].id[0]!='M'&&nd[nxt[x]].zs==0)
                    {
                        continue;
                    }
                }
            }else if(gover==0&&search(x)==0&&i==4)//角色出决斗能否找到决斗对象 
            {
                continue;
            }
            pla=nd[x].card[i].front();
            cnt=i;
        }
    }
    return cnt;//如果cnt==0,表示无牌可出 
}
void print()//结算输出 
{
    if(nd[1].dead)
    {
        printf("FP\n");
    }else
    {
        printf("MP\n");
    }
    for(int i=1;i<=N;i++)
    {
        if(nd[i].dead)
        {
            printf("DEAD\n");
        }else
        {
            nd[i].zg=1;
            while(fcard(i,1)!=0)
            {
                int cd=fcard(i,1);
                nd[i].card[cd].pop();
                printf("%c ",mt[cd]);				
            }
            printf("\n");
        }
    }
}
void get(int x)//角色x摸牌 
{
    int a=q.front();
    if(q.size()!=1)
    {
        q.pop();
    }
    nd[x].card[a].push(nd[x].cnt);
    nd[x].cnt++;
    if(a==1)
    {
        nd[x].pcnt++;
    }else if(a==2)
    {
        nd[x].kcnt++;
    }else if(a==3)
    {
        nd[x].dcnt++;
    }else if(a==7)
    {
        nd[x].jcnt++;
    }
    return;
}
void die(int fr,int x)//角色fr杀死了角色x 
{
    nd[x].dead=1;
    if(nd[x].id[0]=='F')
    {
        fc--;
    }
    if(fc==0||nd[1].dead==1)
    {
        gameover=1;
        print();
        return;//如果结束条件达成,必须立刻结束,不能进行奖惩 
    }else
    {
        if(nd[x].id[0]=='F')
        {
            for(int i=1;i<=3;i++)
            {
                get(fr);
            }
        }else if(nd[x].id[0]=='Z'&&nd[fr].id[0]=='M')
        {
            nd[fr].zg=0;
            for(int i=1;i<=8;i++)
            {
                while(nd[fr].card[i].size())
                {
                    nd[fr].card[i].pop();
                }
            }
            nd[fr].kcnt=0;
            nd[fr].dcnt=0;
            nd[fr].pcnt=0;
            nd[fr].jcnt=0;
        }
    }
    for(int i=1;i<=N;i++)
    {
        if(nxt[i]==x)
        {
            nxt[i]=nxt[x];//重置下家 
        }
    }
    return;
}
void def(int x)//角色x试图出闪来抵消杀 
{
    if(nd[x].dcnt)
    {
        nd[x].dcnt--;
        nd[x].card[3].pop();
    }else
    {
        nd[x].bl--;
    }
    return;
}
void peach(int x)//角色x试图用桃来挽救自己 
{
    nd[x].bl++;
    if(nd[x].pcnt)
    {
        nd[x].pcnt--;
        nd[x].card[1].pop();
    }else
    {
        nd[x].bl--;
    }
    return;
}
bool cancl(int fr,int x,bool dep)//无懈可击 
{
    if(dep==1)
    {
        if(nd[x].zs==0&&nd[x].fs==0&&nd[x].id[0]!='M')
        {
            return 1;
        }
    }
    bool fl=0;
    int f=0;
    for(int i=fr;i!=fr||fl==0;i=nxt[i],fl=1)
    {
        if(nd[i].jcnt)
        {
            if(nd[x].id[0]=='M'||nd[x].zs==1)
            {
                if(dep==0&&nd[i].id[0]=='F')
                {
                    nd[i].fs=1;
                    nd[i].fl=0;
                    f=i;
                    nd[i].card[7].pop();
                    nd[i].jcnt--;
                    break;
                }else if(dep==1&&nd[i].id[0]!='F')
                {
                    if(nd[i].id[0]=='Z')
                    {
                        nd[i].zs=1;
                        nd[i].fl=0;
                    }
                    f=i;
                    nd[i].card[7].pop();
                    nd[i].jcnt--;
                    break;
                }
            }else if(nd[x].fs==1)
            {
                if(dep==0&&nd[i].id[0]!='F')
                {
                    if(nd[i].id[0]=='Z')
                    {
                        nd[i].zs=1;
                        nd[i].fl=0;
                    }
                    f=i;
                    nd[i].card[7].pop();
                    nd[i].jcnt--;
                    break;
                }else if(dep==1&&nd[i].id[0]=='F')
                {
                    nd[i].fs=1;
                    nd[i].fl=0;
                    f=i;
                    nd[i].card[7].pop();
                    nd[i].jcnt--;
                    break;
                }
            }
        }
    }
    if(f==0)
    {
        return 1;
    }else
    {
        return cancl(f,x,dep^1)^1;
    }
    
}
void invade(int fr,int x)//fr出了南蛮,现判定到角色x 
{
    if(cancl(fr,x,1))//判定是否被无懈,其他锦囊与此相同 
    {
        if(nd[x].kcnt)
        {
            nd[x].kcnt--;
            nd[x].card[2].pop();
        }else
        {
            nd[x].bl--;
            if(nd[fr].zs==0&&nd[fr].fs==0&&nd[x].id[0]=='M')
            {
                nd[fr].fl=1;
            }
            if(nd[x].bl==0)
            {
                peach(x);
            }
            if(nd[x].bl==0)
            {
                die(fr,x);
            }
        }
    }
    return;
}
void shoot(int fr,int x)//万箭齐发 
{
    if(cancl(fr,x,1))
    {
        if(nd[x].dcnt)
        {
            nd[x].dcnt--;
            nd[x].card[3].pop();
        }else
        {
            nd[x].bl--;
            if(nd[fr].zs==0&&nd[fr].fs==0&&nd[x].id[0]=='M')
            {
                nd[fr].fl=1;
            }
            if(nd[x].bl==0)
            {
                peach(x);
            }
            if(nd[x].bl==0)
            {
                die(fr,x);
            }
        }
    }
    return;
}
void fight(int fr,int x)//决斗 
{
    if(nd[fr].id[0]=='F')
    {
        nd[fr].fs=1;
        nd[fr].fl=0;
    }else if(nd[fr].id[0]=='Z')
    {
        nd[fr].zs=1;
        nd[fr].fl=0;
    }
    if(cancl(fr,x,1))
    {
        if(nd[fr].id[0]=='M'&&nd[x].id[0]=='Z')
        {
            nd[x].bl--;
            if(nd[x].bl==0)
            {
                peach(x);
            }
            if(nd[x].bl==0)
            {
                die(fr,x);
            }
        }else
        {
            if(nd[fr].kcnt>=nd[x].kcnt)
            {
                nd[x].bl--;
                nd[fr].kcnt-=nd[x].kcnt;
                nd[x].kcnt=0;
                if(nd[x].bl==0)
                {
                    peach(x);
                }
                if(nd[x].bl==0)
                {
                    die(fr,x);
                }
                while(nd[x].card[2].size())
                {
                    nd[x].card[2].pop();
                }
                while(nd[fr].card[2].size()>nd[fr].kcnt)
                {
                    nd[fr].card[2].pop();
                }
            }else
            {
                nd[fr].bl--;
                nd[x].kcnt-=(nd[fr].kcnt+1);
                nd[fr].kcnt=0;
                if(nd[fr].bl==0)
                {
                    peach(fr);
                }
                if(nd[fr].bl==0)
                {
                    die(x,fr);
                }
                while(nd[fr].card[2].size())
                {
                    nd[fr].card[2].pop();
                }
                while(nd[x].card[2].size()>nd[x].kcnt)
                {
                    nd[x].card[2].pop();
                }
            }
        }
    }
}
void kill(int fr,int x)//杀 
{
    def(x);
    if(nd[x].bl==0)
    {
        peach(x);
    }
    if(nd[x].bl==0)
    {
        die(fr,x);
    }
    return;
}
void play()
{
    int cnt=1;
    while(fc&&nd[1].dead==0)
    {
        for(int i=1;i<=2;i++)
        {
            get(cnt);
        }
        while(fcard(cnt,0)!=0)
        {
            int cd=fcard(cnt,0);
            if(cd==1)
            {
                nd[cnt].bl++;
                nd[cnt].card[1].pop();
                nd[cnt].pcnt--;
            }else if(cd==2)
            {
                nd[cnt].card[2].pop();
                nd[cnt].kcnt--;
                kill(cnt,nxt[cnt]);
                if(nd[cnt].id[0]=='Z')
                {
                    nd[cnt].zs=1;
                    nd[cnt].fl=0;
                }else if(nd[cnt].id[0]=='F')
                {
                    nd[cnt].fs=1;
                    nd[cnt].fl=0;
                }
                nd[cnt].as=1;
                if(gameover)
                {
                    return;
                }
            }else if(cd==4)
            {
                nd[cnt].card[4].pop();
                int x=search(cnt);
                fight(cnt,x);
                if(gameover)
                {
                    return;
                }
                if(nd[cnt].dead==1)
                {
                    goto A;
                }
            }else if(cd==5)
            {
                nd[cnt].card[5].pop();
                for(int i=nxt[cnt];i!=cnt;i=nxt[i])
                {
                    invade(cnt,i);
                    if(gameover)
                    {
                        return;
                    }
                }
            }else if(cd==6)
            {
                nd[cnt].card[6].pop();
                for(int i=nxt[cnt];i!=cnt;i=nxt[i])
                {
                    shoot(cnt,i);
                    if(gameover)
                    {
                        return;
                    }
                }
            }else if(cd==8)
            {
                nd[cnt].card[8].pop();
                nd[cnt].zg=1;
            }
        }
        nd[cnt].as=0;
        A:cnt=nxt[cnt];
    }
    return;
}
int main()
{
    scanf("%d%d",&N,&M);
    m['P']=1;
    m['K']=2;
    m['D']=3;
    m['F']=4;
    m['N']=5;
    m['W']=6;
    m['J']=7;
    m['Z']=8;
    mt[1]='P';
    mt[2]='K';
    mt[3]='D';
    mt[4]='F';
    mt[5]='N';
    mt[6]='W';
    mt[7]='J';
    mt[8]='Z';
    for(int i=1;i<=N;i++)
    {
        scanf("%s",nd[i].id);
        nd[i].bl=4;
        nd[i].cnt=5;
        if(nd[i].id[0]=='F')
        {
            fc++;
        }
        for(int j=1;j<=4;j++)
        {
            scanf("%s",str);
            nd[i].card[m[str[0]]].push(j);
            if(str[0]=='K')
            {
                nd[i].kcnt++;
            }else if(str[0]=='D')
            {
                nd[i].dcnt++;
            }else if(str[0]=='P')
            {
                nd[i].pcnt++;
            }else if(str[0]=='J')
            {
                nd[i].jcnt++;
            }
        }
    }
    for(int i=1;i<=M;i++)
    {
        scanf("%s",str);
        q.push(m[str[0]]);
    }
    for(int i=1;i<N;i++)
    {
        nxt[i]=i+1;
    }
    nxt[N]=1;
    play();
    return 0;
}

```

---

## 作者：hl666 (赞：3)

这道题在**模拟**界地位不亚于[Luogu P4604 [WC2017]挑战](https://www.luogu.org/problemnew/show/P4604)在**卡常**界的地位了吧。

早上到机房开始写，中间因为有模拟赛一直到1点过才正式开始码。

~~一边膜拜CXR dalao一边写到3点左右~~，然后调啊调

最后发现杀死反猪抽的牌并没有被杀死它的人抽走（大雾），4点左右终于是写完了

看完题目（看都要10min）感觉这肯定不是什么**建图跑XX算法**或者**套一个数据结构**的题

然而数据范围也很默契，猪和牌的数量都不多，所以我们祭出被我们遗弃的暴力算法——模拟。

题目意思都不多说了，以下讲一下大致的思路：

1. 每个猪应该有**两个**身份要记录。一个是**真实身份**，另一个是当前在游戏中**目前的身份**，即有可能是未知和类反猪
2. 关于猪本身一些手牌，血量，有没有武器，下一头猪（因为可能有猪会死掉）等要记录的就不多说了
3. 每个回合里分别便利当前猪的所有手牌并判断是否可以打出（没有目标自然是不能出的）
4. 判断每个行动以及更新在此过程中**可能会被更新的身份信息**
5. 无懈可击的情况要特别判断，写一个递归即可（实现看代码）

大致思路就是这样了，~~为了造福人类~~还是说一下这道题的坑点：

1. 题目中描述反猪为`AP`，实际上是`FP`（看样例就知道了）
2. 题目里说“数据保证牌的数量够用。”就是在扯淡。如果没牌要**一直摸最后一张牌**
3. `MP`干掉`ZP`后武器也得弃了
4. 无懈去无懈别人的无懈时要注意和原来的行为性质刚好相反（因为**只有敌人会无懈你的无懈**）
5. 一头猪在自己回合也会GG（决斗把自己玩死），同时在自己回合也可能摸牌（`FP`和你决斗然后它GG了）
6. 除了桃之外的牌其他的牌在打出后都得重新扫描手牌（因为可能因为有武器使得之前的杀也可以用了，或者是由于一些猪**身份的公开**使得之前的一些牌有目标了）
7. 只有`MP`会攻击类反猪，`ZP`是不会对类反猪表敌意的
8. 放AOE技能时可能会一次干掉很多人，就会产生比如一回合摸许多牌的情况
9. 同上，`MP`用AOE技能时要注意**结算的顺序**，尤其是杀了`ZP`又杀死`FP`会导致手上还有牌，而先杀死`FP`再杀`ZP`就一张牌都没有了
10. `MP`或**所有**`FP`死了游戏**立即结束**，意味着有牌摸的也不用摸了

大致就是这些了，还有强烈建议写的时候打点注释上去省的到时候自己都不知道自己在写什么~~心态爆炸~~

贴一下CODE（注释都是写的时候打上去的），如果要看**超级详细的解析CODE**的移步[CXR dalao's blog](https://blog.csdn.net/chenxiaoran666/article/details/83314341)

CODE

```cpp
#include<cstdio>
#include<cctype>
#include<cstdlib>
#include<cstring>
#define RI register int
#define GC(x) P[x].hand_cards[++P[x].tot]=getcard(); //x摸牌，太长了所以用下define 
using namespace std;
const int M=2005;
class FileInputOutput
{
    private:
        #define tc() (A==B&&(B=(A=Fin)+fread(Fin,1,S,stdin),A==B)?EOF:*A++)
        #define S 1<<21
        char Fin[S],Fout[S],*A,*B; int Ftop;
    public:
        FileInputOutput() { A=B=Fin; }
        inline void pc(char ch)
        {
            Ftop<S?Fout[Ftop++]=ch:(fwrite(Fout,1,S,stdout),Fout[(Ftop=0)++]=ch);
        }
        inline void gc(char &ch)
        {
            while (!isalpha(ch=tc()));
        }
        inline void ps(const char *s)
        {
            int len=strlen(s); for (RI i=0;i<len;++i) pc(s[i]);
        }
        inline void read(int &x)
        {
            x=0; char ch; while (!isdigit(ch=tc()));
            while (x=(x<<3)+(x<<1)+(ch&15),isdigit(ch=tc()));
        }
        inline void Fend(void)
        {
            fwrite(Fout,1,Ftop,stdout);
        }
        #undef tc
        #undef S
}File;
struct Pig
{
    int type,status,tot,hp,nxt; char hand_cards[M]; //hand_cards手牌，若为'U'则表示这张牌出掉了 
    //type表示真实身份(1:MP;2:ZP;3:FP),status表示表露出的身份(0:未知;1:MP;2:ZP;3:FP:4:类反)
    bool isZ,isalive; //isZ表示是否装备猪哥连弩,isalive表示是否存活 
}P[12]; int n,m,cnt,now; char cards[M],ch;
inline char getcard(void)
{
    if (cnt<m) return cards[++cnt]; else return cards[cnt];
}
inline int getnext(int x) //找下一头猪，可以路径压缩 
{
    return P[P[x].nxt].isalive?P[x].nxt:P[x].nxt=getnext(P[x].nxt);
}
inline int find(int x,char y) //查找x是否有牌y,有返回位置，否则返回-1
{
    for (RI i=1;i<=P[x].tot;++i) if (P[x].hand_cards[i]==y) return i; return -1;
}
inline void Endgame(void) //游戏结束，输出结果 
{
    if (P[1].isalive) File.ps("MP\n"); else File.ps("FP\n");
    for (RI i=1;i<=n;++i)
    {
        if (!P[i].isalive) { File.ps("DEAD\n"); continue; }
        for (RI j=1;j<=P[i].tot;++j) if (P[i].hand_cards[j]!='U')
        File.pc(P[i].hand_cards[j]),File.pc(' '); File.pc('\n');
    }
    File.Fend(); exit(0);
}
inline void Hurt(int x,int y) //x对y造成了一点伤害
{
    if (--P[y].hp) return; int pos=find(y,'P');
    if (~pos) return (void)(++P[y].hp,P[y].hand_cards[pos]='U');
    P[y].tot=-1; P[y].isalive=0; if (P[y].type==1) Endgame();
    if (P[y].type==2&&P[x].type==1) P[x].tot=0,P[x].isZ=0;
    if (P[y].type!=3) return; bool isFP=0; RI fr=0,nxt=1;
    for (;fr!=nxt;nxt=getnext(nxt),fr=1) if (P[nxt].type==3) { isFP=1; break; }
    if (!isFP) Endgame(); GC(x); GC(x); GC(x);
}
inline int indentfy(int x,int y) //鉴定x,y的关系(根据跳的情况判断，注意MP要特判
//(1:同伙;2:敌人;3:y身份未知)
{
    if (!P[y].status) return 3; switch (P[x].type)
    {
        case 1:
            if (P[y].status==1||P[y].status==2) return 1;
            if (P[y].status==3||P[y].status==4) return 2;
            break;
        case 2:
            if (P[y].status==1||P[y].status==2) return 1;
            if (P[y].status==3) return 2; if (P[y].status==4) return 3;
            break;
        case 3:
            if (P[y].status==1||P[y].status==2) return 2;
            if (P[y].status==3) return 1; if (P[y].status==4) return 3;
    }
    return 3;
}
inline void Make_Friendly(int x,int y) //x向y献殷勤，要更新关系
{
    if ((P[y].status==1||P[y].status==2)&&P[x].type!=1) P[x].status=2;
    if (P[y].status==3) P[x].status=3;
}
inline void Make_Antily(int x,int y) //x向y表敌意，也要更新关系 
{
    if (P[y].status==1||P[y].status==2) P[x].status=3;
    if (P[y].status==3&&P[x].type!=1) P[x].status=2;
}
inline void K(int x,int y) //x向y打出一张杀
{
    Make_Antily(x,y); int pos=find(y,'D');
    if (~pos) P[y].hand_cards[pos]='U'; else Hurt(x,y);
}
inline bool J(int x,int y,int opt) //依次决定对于x对y打出的锦囊是否有人响应无懈 
//opt表示这次无懈行为是献殷勤(1)还是表敌意(2)
{
    for (RI nxt=x,fr=0;nxt!=fr;nxt=getnext(nxt),fr=x)
    {
        if (indentfy(nxt,y)!=opt) continue;
        int pos=find(nxt,'J'); if (~pos) 
        {
            P[nxt].hand_cards[pos]='U';
            if (opt==1) Make_Friendly(nxt,y); else Make_Antily(nxt,y);
            return J(nxt,y,3-opt)^1;
        }
    }
    return 0;
}
inline void F(int x,int y) //x向y进行决斗
{
    Make_Antily(x,y); if (J(x,y,1)) return; 
    if (P[x].type==1&&P[y].type==2) return Hurt(x,y); 
    int pos; for (;;)
    {
        pos=find(y,'K'); if (~pos) P[y].hand_cards[pos]='U'; else return Hurt(x,y);
        pos=find(x,'K'); if (~pos) P[x].hand_cards[pos]='U'; else return Hurt(y,x);
    }
}
inline void N(int x) //x打出南猪入侵
{
    for (int nxt=getnext(x);nxt!=x;nxt=getnext(nxt))
    {
        if (J(x,nxt,1)) continue; int pos=find(nxt,'K');
        if (~pos) { P[nxt].hand_cards[pos]='U'; continue; }
        if (P[nxt].type==1&&!P[x].status) P[x].status=4; Hurt(x,nxt);
    }
}
inline void W(int x) //x打出万箭齐发
{
    for (int nxt=getnext(x);nxt!=x;nxt=getnext(nxt))
    {
        if (J(x,nxt,1)) continue; int pos=find(nxt,'D');
        if (~pos) { P[nxt].hand_cards[pos]='U'; continue; }
        if (P[nxt].type==1&&!P[x].status) P[x].status=4; Hurt(x,nxt);
    }
}
inline void Play(void) //一回合
{
    GC(now); GC(now); bool iskilled=0; int nxt;
    for (RI i=1;i<=P[now].tot;++i)
    {
        char &opt=P[now].hand_cards[i]; switch (opt)
        {
            case 'K':
                if (iskilled&&!P[now].isZ) break;
                if (indentfy(now,nxt=getnext(now))==2) { opt='U'; iskilled=1; K(now,nxt); i=0; break; } //是敌对关系才能杀 
                break;
            case 'F':
                if (P[now].type==3) { opt='U'; F(now,1); i=0; break; } //FP优先杀MP 
                for (nxt=getnext(now);nxt!=now;nxt=getnext(nxt))
                if (indentfy(now,nxt)==2) { opt='U'; F(now,nxt); i=0; break; } //按顺序找人决斗 
                break;
            case 'N':
                opt='U'; N(now); i=0; break;
            case 'W':
                opt='U'; W(now); i=0; break;
            case 'P':
                if (P[now].hp<4) opt='U',++P[now].hp; break;
            case 'Z':
                opt='U'; P[now].isZ=1; i=0; break;
        }
    }
}
#undef GC
int main()
{
    //freopen("CODE.in","r",stdin); freopen("CODE.out","w",stdout);
    RI i,j; for (File.read(n),File.read(m),i=1;i<=n;++i)
    {
        File.gc(ch); P[i].type=ch=='M'?1:(ch=='Z'?2:3); if (P[i].type==1) P[i].status=1;
        P[i].tot=4; for (File.gc(ch),j=1;j<=4;++j) File.gc(P[i].hand_cards[j]);
        if(i^n) P[i].nxt=i+1; else P[i].nxt=1; P[i].isalive=1; P[i].hp=4;
    }
    for (i=1;i<=m;++i) File.gc(cards[i]); for (now=1;;now=getnext(now)) Play(); return 0;
}
```

---

## 作者：opened (赞：3)

# 题解:大模拟~~、字符串~~

这道题模拟即可~~、坑点过多，也不知道考场上有没有人能写出来~~

盘点一下坑点，程序中有体现~~（前人填坑利后人）~~

### 1. 桃濒死时吃完记得回血,不要磕完桃还是0血状态

### 2. 用牌之前就要标记好不能再用了

### 3. 主公（猪）弃牌要弃装备（猪哥连弩）

### 4. 对于锦囊牌先用懈再判定，因为出锦囊的~~人~~（猪）是有可能无懈掉这个锦囊的（~~这个是真滴皮~~）

### 5.有人（猪）死亡的时候要重新更新第一目标

### 6.出决斗的人（猪）可能死在自己回合里，这时候立即终止他（它）的出牌阶段

### 7.~~（坑的极致）~~当牌堆的最后一张牌没了的时候，你需要一直摸最后一张牌~~（所以叫猪国杀是吧）~~

##  ·大佬的样例来一波（都是主猪获胜，反猪全部死亡情况~~【亲测】~~，建议调试时输出主猪与忠猪的血量）~~（都是套路）~~:

1. 1

   	 5 10
  	  MP W D F K 
  	  ZP N N D D 
  	  FP F W W K 
  	  ZP K K N D 
  	  FP K D P W 
  	  J K W K D N N K J N 
2. 2

  	  3 4
  	  MP J J K N 
  	  ZP J D K W 
   	 FP P N P K 
   	 J J K W 

3. 3

  	  3 10
   	 MP W D J W 
   	 ZP J P D N 
  	  FP N D F F 
  	  J D N N F J J D K W 
      
4. 4

   	 3 1
   	 MP D N F K
   	 ZP F W F N
  	  FP D N N D
   	 K

# Talk is cheap, show me the code.

```
#include<iostream>
#include<cstdio>
#define N 5010
using namespace std;
int n,m, L[N],R[N],cnt,/*双向链表*/ realID[11],Fpig_alive/*反猪数量*/,GameOver,NowRound;
char kind[N],card_unused[3010]/*牌堆*/;int top;
inline char Card(){return top==m?card_unused[top]:card_unused[++top];}
inline void judge(int &t,int &w,int &p,int &f){
    kind[++cnt]=Card();L[cnt]=t;
    if(kind[cnt]=='J')w++; if(kind[cnt]=='P')p++; if(kind[cnt]=='D')f++;
}
void Sha(int,int);void Fight(int,int);void Nanpig(int);void Wanjian(int);
struct Pig{
    int showingID, head,tail,now,pos, blood, wuxie,peach,flash, first_attack, Lpig,Rpig, dead,weapon,num;
    void S_card(){//无懈可击、桃、闪——特判
        judge(tail,wuxie,peach,flash);
        if(head==0) head=tail=cnt;
        else R[tail]=cnt,tail=cnt;
        judge(tail,wuxie,peach,flash),R[tail]=cnt,tail=cnt;
        judge(tail,wuxie,peach,flash),R[tail]=cnt,tail=cnt;
    }
    void Punish(){//清空手牌
        head=tail=now=wuxie=peach=flash=weapon=0;
    }
    void CardStage(){//摸牌函数
        judge(tail,wuxie,peach,flash);
        if(head==0) head=tail=cnt;
        else R[tail]=cnt,tail=cnt;
        judge(tail,wuxie,peach,flash),R[tail]=cnt,tail=cnt;
    }
    void Use(int x){//出牌
        if(kind[x]=='J')wuxie--; if(kind[x]=='P')peach--; if(kind[x]=='D')flash--;
        if(x==head&&x==tail) head=0,tail=0;//核心操作:重铸链表
        else if(x==head) head=R[x],L[R[x]]=0;
        else if(x==tail) tail=L[x],R[L[x]]=0;
        else L[R[x]]=L[x],R[L[x]]=R[x];
    }
    char GetNext(){//下一头猪
        if(!now) return 0;
        pos=now,now=R[now];
        return kind[pos];
    }
    void Output(){//输出函数
        if(dead) puts("DEAD");
        else {
            while(head!=0){
                cout<<kind[head];
                if(head!=tail) printf(" ");
                head=R[head];
            }
            printf("\n");
        }
    }
    int find1(){now=head; for(char i;i!='D';i=GetNext()); return pos;}
    int find2(){now=head; for(char i;i!='P';i=GetNext()); return pos;}
    int find3(){now=head; for(char i;i!='J';i=GetNext()); return pos;}
    bool Q_K(){//杀
        now=head;char i;
        while(i=GetNext())
            if(i=='K'){ Use(pos);return 1;}
        return 0;
    }
    bool Q_F(){if(flash){ Use(find1());return 1;} return 0;}
    bool Q_P(){if(peach){ Use(find2());return 1;} return 0;}
    bool Q_W(){if(wuxie){ Use(find3());return 1;} return 0;}
    void Round(){//回合函数
        CardStage();
        now=head;char i;bool useKill=0;
        while((i=GetNext())&&!GameOver){
            switch(i){//出牌效果
                case 'D': continue;
                case 'J': continue;
                case 'P':if(blood!=4) blood++,Use(pos); continue;
                case 'K':{
                    if(first_attack==Rpig&&(!useKill||weapon)){
                        Use(pos),Sha(num,first_attack),now=head,useKill=1;
                        if(GameOver) return;
                    } continue;
                }
                case 'F':{
                    if(!first_attack) continue; Use(pos);
                    if(realID[num]==3) Fight(num,1);
                    else Fight(num,first_attack); now=head;
                    if(GameOver||dead) return;
                     continue;
                }
                case 'N':Use(pos),Nanpig(num),now=head;if(GameOver) return; continue;
                case 'W':Use(pos),Wanjian(num),now=head;if(GameOver) return; continue;
                case 'Z':Use(pos),weapon=1,now=head; continue;
            }
        }
    }
}pig[11];
void Update(int x){//更新态度
    int i=pig[x].Rpig;
    if(realID[x]==1){
        while(i!=x){
            if(pig[i].showingID==1||pig[i].showingID==3){
                pig[x].first_attack=i;
                return;
            }
            i=pig[i].Rpig;
        }
        pig[x].first_attack=0;
    }
    else if(realID[x]==2){
        while(i!=x){
            if(pig[i].showingID==3){
                pig[x].first_attack=i;
                return;
            }
            i=pig[i].Rpig;
        }
        pig[x].first_attack=0;
    }
    else{
        while(i!=x){
            if(pig[i].showingID==2||realID[i]==1){
                pig[x].first_attack=i;
                return;
            }
            i=pig[i].Rpig;
        }
        pig[x].first_attack=0;
    }
}
void Update_all(){//重视每头猪
    int r=pig[1].Rpig;
    Update(1);
    while(r!=1) Update(r),r=pig[r].Rpig;
}
void Kill(int x,int y){//击杀
    pig[y].dead=true;
    if(realID[y]==1){GameOver=true;return;}
    if(realID[y]==3){
        Fpig_alive--;
        if(!Fpig_alive){GameOver=true;return;}
        pig[x].S_card();
    }
    if(realID[y]==2&&realID[x]==1) pig[x].Punish();
    int l=pig[y].Lpig,r=pig[y].Rpig;//更新链表
    pig[l].Rpig=r,pig[r].Lpig=l;
    Update_all();
}
void Hurt(int x,int y){//掉血、加血
    pig[y].blood--;
    if(!pig[y].blood){
        if(pig[y].Q_P()) pig[y].blood++;
        else Kill(x,y);
    }
}
void Sha(int x,int y){//杀
    if(realID[x]!=1&&pig[x].showingID<2){
        if(realID[y]==3) pig[x].showingID=2;
        else pig[x].showingID=3;
        Update_all();
    }
    if(pig[y].Q_F()) return;
    Hurt(x,y);
}
bool WX_cycling(int x,bool vis){//核心操作:无懈循环
    int viss=vis,pos=x,i=x;
    if(vis==(realID[i]==3)){
        if(pig[i].Q_W()){
            pos=i,vis^=1;
            if(pig[i].showingID<=2) pig[i].showingID=3-vis,Update_all();
        }
    }
    for(i=pig[i].Rpig;i!=pos;i=pig[i].Rpig)if(vis==(realID[i]==3)){
            if(pig[i].Q_W()){
                pos=i,vis^=1;
                if(pig[i].showingID<=2) pig[i].showingID=3-vis,Update_all();
            }
        }
    return viss!=vis;
}
void Fight(int x,int y){//决斗
    if(realID[x]!=1&&pig[x].showingID<2){
        if(realID[y]==3) pig[x].showingID=2;
        else pig[x].showingID=3;
        Update_all();
    }
    if(realID[y]==1||pig[y].showingID>=2){
        if(realID[y]==1||pig[y].showingID==2){
            if(WX_cycling(x,0)) return;
        }
        else {if(WX_cycling(x,1)) return;}
    }
    if(realID[x]==1&&realID[y]==2) Hurt(x,y);
    else {
        while(1){
            if(!pig[y].Q_K()) {Hurt(x,y);return;}
            if(!pig[x].Q_K()) {Hurt(y,x);return;}
        }
    }
}
void Nanpig(int x){//南猪入侵
    int i=pig[x].Rpig;
    while(i!=x){
        if(realID[i]==1||pig[i].showingID>=2){
            if(realID[i]==1||pig[i].showingID==2){
                if(WX_cycling(x,0)){i=pig[i].Rpig; continue;}
            }
            else {
                if(WX_cycling(x,1)){i=pig[i].Rpig; continue;}
            }
        }
        if(!pig[i].Q_K()){
            Hurt(x,i);
            if(GameOver) return;
            if(i==1&&!pig[x].showingID) pig[x].showingID=1,Update_all();
        }
        i=pig[i].Rpig;
    }
}
void Wanjian(int x){//万箭齐发
    int i=pig[x].Rpig;
    while(i!=x){
        if(realID[i]==1||pig[i].showingID>=2){
            if(realID[i]==1||pig[i].showingID==2){
                if(WX_cycling(x,0)){i=pig[i].Rpig; continue;}
            }
            else {
                if(WX_cycling(x,1)){i=pig[i].Rpig; continue;}
            }
        }
        if(!pig[i].Q_F()){
            Hurt(x,i);
            if(GameOver) return;
            if(i==1&&!pig[x].showingID) pig[x].showingID=1,Update_all();
        }
        i=pig[i].Rpig;
    }
}
void addcard(int &pos){char s[10];scanf("%s",s),card_unused[++pos]=s[0];}//添牌
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) pig[i].Rpig=i+1,pig[i].Lpig=i-1;//双向链表
    pig[n].Rpig=1,pig[1].Lpig=n;
    int pos=0;
    for(int i=1;i<=n;i++){//读牌
        char s[10];scanf("%s",s);
        if(s[0]=='M') realID[i]=1;
        else if(s[0]=='Z') realID[i]=2;
        else if(s[0]=='F') realID[i]=3,Fpig_alive++;
        for(int i=1;i<=4;i++) addcard(pos);
    }
    for(int i=1;i<=m;i++) addcard(pos);
    m+=4*n;
    for(int i=1;i<=n;i++){
        pig[i].CardStage(),pig[i].CardStage();//摸牌
        pig[i].num=i,pig[i].blood=4;//初始化
    }
    Update_all();
    for(int i=1;!GameOver;i=pig[i].Rpig) NowRound=i,pig[i].Round();//回合
    if(pig[1].dead) puts("FP");
    else puts("MP");
    for(int i=1;i<=n;i++) pig[i].Output();//出牌
}
```

---


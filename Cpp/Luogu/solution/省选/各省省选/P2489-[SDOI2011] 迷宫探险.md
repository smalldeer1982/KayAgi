# [SDOI2011] 迷宫探险

## 题目背景

[](https://paste.ubuntu.com/p/H4h73F2h87/)

## 题目描述

这是一个单人游戏。

游戏开始时，玩家控制的人物出生在迷宫的某个位置，玩家的目标是控制人物走到迷宫的某个出口（出口可能有多个）。

迷宫里有 $k$ 类陷阱（用  `A`,`B`,`C`……表示，相同字母代表相同类型的陷阱），每类陷阱可能是有害的或无害的，而在游戏开始时玩家并不知道哪些陷阱是有害的，哪些是无害的。

同一类陷阱的状态相同，即用同一个字母标志的陷阱要么全部有害，要么全部无害，不会发生一部分有害而另一部分无害的情况。任何陷阱状态的组合都有一个发生概率，考虑下例：

当 $k=2$ 时，迷宫内共有两类陷阱，分别用 `A` 和 `B` 表示，陷阱状态的组合共有 $4$ 种：-
- `A` 是无害陷阱，`B` 是无害陷阱。
- `A` 是有害陷阱，`B` 是无害陷阱；
- `A` 是无害陷阱，`B` 是有害陷阱；
- `A` 是有害陷阱，`B` 是有害陷阱；

下列表格是一个合法的概率表格：

|  | `A` 是无害陷阱 | `A` 是有害陷阱 |
| -----------: | -----------: | -----------: |
| **`B` 是无害陷阱** | $36\%$ | $24\%$ |
| **`B` 是有害陷阱** | $24\%$ | $16\%$ |

当 $k=3$ 时，会有 $8$ 种不同的陷阱状态组合，如果我们依然坚持使用概率表格，那么这个表格将会是三维的（$2\times 2 \times 2$，每一维对应着一类陷阱）。当 $k\ge 3$ 时，这将使得题目难以描述。因此我们使用一个大小为 $2^{k}$ 的数组 $p$ 来描述每种情况发生的可能性，$p$ 的下标范围为 $0\sim 2^{k}-1$。

$p$ 是这样生成的：

对于每个可能的陷阱状态组合，考虑所有 $k$ 类陷阱，令 $1$ 表示某个陷阱有害，$0$ 表示某个陷阱无害，把 `A` 作为二进制数的第 $0$ 位（从右边开始计数），`B` 作为第 $1$ 位，`C` 作为第 $2$ 位……通过以上操作，我们可以得到一个 $k$ 位的二进制数，把它转化成十进制后，$2^{k}$ 种陷阱状态的组合将会与整数 $0\sim2^{k}-1$ 一一对应。

设 $S = \displaystyle\sum_{i=0}^{2^k-1} p_i$，则陷阱状态组合 $i$ 出现的概率为 $\dfrac {p_{i}} {S}$。

上述表格对应的一个合法数组 $p$ 为 $36,24,24,16$。

当然同一个概率表格可能会对应多个数组 $p$（事实上有无数个数组 $p$ 能够迎合表格数据），例如上述表格同时也对应着下面的数组 $p$：$72,48,48,32$。

玩家控制的人物初始情况下有 $H$ 点生命，当人物踏上某个陷阱时，如果这个陷阱是有害的，那么会损失 $1$ 点生命，否则这个陷阱是无害的，不损失生命。无论上述哪种情况发生，玩家会立刻得到这个陷阱的信息（有害或无害）。一旦生命小于等于 $0$，玩家控制的人物会立刻死亡。

迷宫可以看作 $m\times n$ 的方格地图，每个元素可能是：
- `.`：表示这是平地，可以通过；
- `#`：表示这是墙，不能通过；
- `A`，`B` ，`C`……：表示这是一个陷阱；
- `$`：表示这是起点，地图中有且仅有一个；
- `@`：表示这是终点，地图中可以有多个，也可以一个也没有。

人物可以向上下左右四个方向行走，不可以走对角线，也不可以走出地图。

给定 $m\times n$ 的地图、$k$、$h$ 以及大小为 $2^{k}$ 的概率数组。你的任务是求出在执行最优策略时，人物能活着走出迷宫的概率。

## 说明/提示

**【样例说明 1】**

向右边走，经过 `B` ，`B` 为有害陷阱的概率为 $\frac {(20+20)}{(30+30+20+20)}=0.4$，若 `B` 为有害陷阱那么人物就死掉了，游戏失败，否则玩家得知 `B` 是无害陷阱，继续经过另一个 `B` 达到终点，胜利的概率为 $0.6$。

**【样例说明 2】**

向左边走，经过 `A`，`A` 为有害陷阱的概率为 $\frac {(30+30)} {(30+30+20+20)}=0.5$。若 `A` 为有害陷阱，那么损失一点生命，转到右边尝试 `B` ，要想成功到达终点，此时 `B` 必须为无害陷阱，而在 `A`是有害陷阱的前提下，`B` 是无害陷阱的概率是 $\frac {30}{(30+20)}=0.6$，故这种情况发生的概率为 $0.5\times 0.6=0.3$。若 `A`是无害陷阱，玩家可以控制人物连续通过两个 `A` 到达终点，这种情况发生的概率 $0.5$。所以答案为 $0.3+0.5=0.8$。 


**【样例说明 3】**

玩家控制的人物有 $3$ 点生命，但最多只需要经过两个陷阱，所以任意选左路
或右路走过去就可以到达终点了。

**【数据范围与约定】**

|测试点编号  | $m$ | $n$ | $k$ | $H$ |
| -----------: | -----------: | -----------: | -----------: | -----------: |
| $1$ | $29$ | $28$ | $5$ | $1$ |
| $2$ | $28$ | $20$ | $4$ | $1$ |
| $3$ | $25$ | $30$ | $1$ | $1$ |
| $4$ | $25$ | $30$ | $1$ | $2$ |
| $5$ | $25$ | $30$ | $1$ | $3$ |
| $6$ | $5$ | $5$ | $4$ | $4$ |
| $7$ | $12$ | $11$ | $4$ | $5$ |
| $8$ | $19$ | $17$ | $5$ | $3$ |
| $9$ | $23$ | $25$ | $5$ | $4$ |
| $10$ | $30$ | $29$ | $5$ | $5$ |

对于 $100\%$ 的数据，$1\le m\leq 30$，$1\le n\leq 29$，$k\leq 5$，$H\leq 5$，$0\leq p_i\leq 10^5$，且至少有一个 $p_i\gt0$ 。

## 样例 #1

### 输入

```
4 3 2 1
.$.
A#B
A#B
.@.
30 30 20 20```

### 输出

```
0.600```

## 样例 #2

### 输入

```
4 3 2 2
.$.
A#B
A#B
.@.
30 30 20 20```

### 输出

```
0.800```

## 样例 #3

### 输入

```
4 3 2 3
.$.
A#B
A#B
.@.
30 30 20 20```

### 输出

```
1.000```

## 样例 #4

### 输入

```
4 3 3 2
.$.
A#B
A#C
@@@
143 37 335 85 95 25 223 57```

### 输出

```
0.858```

# 题解

## 作者：传奇英雄 (赞：16)

## **这道题的数据太水了！！强烈建议管理加强数据！！

传奇英雄，精心制造Hack数据

https://www.luogu.com.cn/discuss/show/231577

以上数据可以卡掉部分洛谷和new_BZOJ（vijos）的题解。

有2种错误的解法：有人用dp[a][b][c][d]表示在(a,b)的位置，状态为c，血量为d，但是可能会遇见环的情况，导致用没有算完的状态更新了答案。（详见上面hack的那个帖子）

还有人加了一维fa，记录这个点是从哪来的。但是仍然会被卡。

那么，我们发现这道题的关键在于如何避免产生环。

本人思路：首先，我们算出当前状态可以到达那些未知或有毒的陷阱。

然后只考虑向未知或有毒的陷阱转移。

这样子，显然是没有环的。（因为向有毒的陷阱会掉1滴血，向未知的陷阱会知道未知陷阱的信息，而这样显然是不可逆的）

我们将到达终点/掉血/未知陷阱作为“一步”，而不是将一次上下左右作为“一步”

因为到达空地/已知无毒陷阱是“平淡无奇”的，没有意义，我们认为能够直接越过，不考虑。

然后，我们就愉快地A掉了这个题！

所以说，大家一定要**严谨治学**啊！不要以为A掉了就对了，要多加思考。

最后，祝大家省选愉快！（距离进省队还有2天）

BJ/HE/SC稳住！天佑CCF，天佑我中华！

```cpp
//作者：传奇英雄
#include<bits/stdc++.h>
using namespace std;
const int g=32,g2=245,s[6]={1,3,9,27,81,243},x[4]={1,-1},y[4]={0,0,1,-1};
int m,n,k,h,sx,sy,u[g2],w,id,state,mark[g][g],m1,m2,m3;
double dp[g][g][g2][6],p[g2][6];
bool vis[g][g][g2][6],f[6],v2[g][g][g2];
char ch[g][g];
vector< pair<int,int> > v[g][g][g2];

int get(int t,int a)
{
	if(u[t]>=0) return u[t];
	for(int i=a;;i++)
		if(!(t/s[i]%3))//考虑2种情况，未知的为0或为1
			return u[t]=get(t+s[i],i+1)+get(t+(s[i]<<1),i+1);
}

void dfs2(int a,int b)
{
	for(int i=0;i<4;i++)
	{
		m1=a+x[i],m2=b+y[i];
		if(m1&&m1<=m&&m2&&m2<=n&&mark[m1][m2]!=id)
		{
			mark[m1][m2]=id;//打上标记，不走重复的点
			if(ch[m1][m2]=='.'||ch[m1][m2]=='$')//空地
				dfs2(m1,m2);
			else
			{
				if(ch[m1][m2]=='@')//目标
				{
					for(int j=1;j<=h;j++)
					{
						vis[a][b][state][j]=vis[sx][sy][state][j]=1;
						dp[a][b][state][j]=dp[sx][sy][state][j]=1;
					}
					return;
				}
				m3=int(ch[m1][m2])-65;//陷阱
				if(m3>=0&&m3<k)
				{
					if(state/s[m3]%3==1)//无毒
						dfs2(m1,m2);
					else
						v[sx][sy][state].push_back(make_pair(m1,m2));//有毒
				}
			}
		}
		if(vis[sx][sy][state][1])//已经到达终点
		{
			for(int j=1;j<=h;j++)
			{
				vis[a][b][state][j]=1;
				dp[a][b][state][j]=1;
			}
			return;
		}
	}
}

double dfs(int a,int b,int c,int d)
{
	if(vis[a][b][c][d])
		return dp[a][b][c][d];
	if(!v2[a][b][c])//当前状态没有被计算过
	{
		v2[a][b][c]=1;//标记已经计算过了，不重复计算
		sx=a,sy=b,state=c;//记录当前状态
		mark[a][b]=++id;//标记已经经过的位置，用id标记，省了清空
		dfs2(a,b);//计算当前状态中能到达的有毒或未知陷阱
		if(vis[a][b][c][d]) return 1;//已经到达目标
	}
	vis[a][b][c][d]=1;
	double ans=0;
	for(int i=0;i<v[a][b][c].size();i++)
	{
		int m4=v[a][b][c][i].first;
		int m5=v[a][b][c][i].second;//陷阱的坐标
		int m6=int(ch[m4][m5])-65;//陷阱的类型
		if(c/s[m6]%3)//有毒陷阱
		{
			if(d>1)//必须血量大于1才能进有毒陷阱
				ans=max(ans,dfs(m4,m5,c,d-1));
		}
		else//未知的陷阱
			if(d==1)//只有1滴血时只能进无毒的陷阱
				ans=max(ans,dfs(m4,m5,c+s[m6],d)*p[c][m6]);
			else//无毒或有毒
				ans=max(ans,dfs(m4,m5,c+s[m6],d)*p[c][m6]+dfs(m4,m5,c+(s[m6]<<1),d-1)*(1-p[c][m6]));
		if(ans==1) return dp[a][b][c][d]=1;
	}
	return dp[a][b][c][d]=ans;
}

int main()
{
	//freopen("in","r",stdin);
	scanf("%d%d%d%d\n",&m,&n,&k,&h);
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		{
			scanf("%c",&ch[i][j]);
			if(ch[i][j]=='$')
				sx=i,sy=j;//起点的位置
		}
		scanf("\n");//注意坑人的回车
	}
	memset(u,-1,sizeof(u));
	w=(s[k]-1)>>1;
	while(w<s[k])//我们定的状态，0未知，1无毒，2有毒
	{
		scanf("%d",&u[w]);
		w++;
		for(int i=0;;i++)//将输入的编号转化为状态
			if(f[i])
			{
				f[i]=0;
				w+=s[i];
			}
			else
			{
				f[i]=1;
				break;
			}
	}
	for(int i=0;i<s[k];i+=3)//末位为1或2的显然已经不用考虑，因为计算i-1的时候已经算过了，i-1最后1位加1
		get(i,0);//计算未知的所有可能之和
	for(int i=0;i<s[k];i++)
		for(int j=0;j<k;j++)
			if(!(i/s[j]%3))
				p[i][j]=u[i+s[j]]*1.0/(u[i+s[j]]+u[i+(s[j]<<1)]);//计算概率
	printf("%.3f",dfs(sx,sy,0,h));
	return 0;
}

```
本题思路来自chdy大佬。他的代码也是对的。感谢大佬！

不建议删掉错误的题解。因为错误的题解确实也是一种很好的思路。（建议各位大佬学习一下错误的题解，然后认真思考一下为什么错了）做走迷宫问题的时候一定要注意环的问题。

---

## 作者：xyz32768 (赞：7)

1、DP模型


======
用$3$进制数表示陷阱的状态，$0$表示无害，$1$表示有害，$2$表示未知。可建立DP模型：

$f[x][y][S][h]$表示从$(x,y)$开始，当前陷阱的状态为$S$，血量为$h$，活着走出迷宫的概率。使用记忆化搜索。


2、边界&转移


=======

边界为：

$f[x][y][S][0]=0$

当$(x,y)$为终点时$f[x][y][S][h]=1$

转移为（以下$(tx,ty)$为$(x,y)$走一步能到达的格子，且$(tx,ty)$不为墙）：

当$(tx,ty)$为平地，起点，终点或无害陷阱时，

$f[x][y][S][h]=\max(f[x][y][S][h],f[tx][ty][S][h])$

当$(tx,ty)$为有害陷阱时，

$f[x][y][S][h]=\max(f[x][y][S][h],f[tx][ty][S][h-1])$

当$(tx,ty)$为未知陷阱时，设陷阱编号为$tt$，则

$f[x][y][S][h]=\max(f[x][y][S][h],f[tx][ty][S-3^{tt-1}][h-1]*g[S][tt]+$

$f[tx][ty][S-2*3^{tt-1}][h]*(1-g[S][tt]))$。


3、关于g数组


=======

上面$g[S][tt]$表示当前状态为$S$时陷阱$tt$有害的概率。

预处理$g$，也就是枚举$S$，再枚举$0$到$2^K-1$，选取有用的概率计入$g$。


4、总结

====
结合「SCOI2008奖励关」「JLOI2013卡牌游戏」两题可以得出，像这样**有限制条件，且在转移的过程中限制条件不断变化的概率DP**，一般模型为：

$f[state]$表示从$state$状态**到达目标状态**的最大/小概率/期望。


5、代码

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
inline char get() {
    char c; while (((c = getchar()) < 'A' || c > 'E') && c != '@'
        && c != '$' && c != '.' && c != '#'); return c;
}
const int N = 35, C = 267, R = 45, V = 10;
int m, n, K, H, dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1}, pw[V], pb[R];
char s[N][N]; double f[N][N][C][V], gw[C][V];
bool vis[N][N][C][V];
double chkmax(double &a, double b) {a = max(a, b);}
int cyx(int S, int x) {
    return S / pw[x - 1] % 3;
}
int lpf(int S, int x, int y) {
    int res = S - cyx(S, x) * pw[x - 1];
    return res + y * pw[x - 1];
}
void init() {
    int i, j, S; for (S = 0; S < pw[K]; S++) {
        int s1 = 0;
        for (i = 0; i < (1 << K); i++) {
            bool flag = 1; for (j = 1; j <= K; j++) {
                int xx = cyx(S, j); if (xx == 2) continue;
                if (xx != ((i >> j - 1) & 1)) {flag = 0; break;}
            }
            if (!flag) continue; s1 += pb[i];
            for (j = 1; j <= K; j++) {
                if (cyx(S, j) != 2 || !((i >> j - 1) & 1)) continue;
                gw[S][j] += pb[i];
            }
        }
        for (i = 1; i <= K; i++) gw[S][i] /= s1;
    }
}
double DP(int x, int y, int S, int h) {
    if (vis[x][y][S][h]) return f[x][y][S][h];
    if (s[x][y] == '@') return vis[x][y][S][h] = 1, f[x][y][S][h] = 1;
    if (h == 0) return vis[x][y][S][h] = 1, f[x][y][S][h] = 0;
    vis[x][y][S][h] = 1; int i;
    for (i = 0; i < 4; i++) {
        int tx = x + dx[i], ty = y + dy[i], tt = s[tx][ty] - 'A' + 1;
        if (tx < 1 || tx > m || ty < 1 || ty > n || s[tx][ty] == '#')
            continue;
        if (s[tx][ty] == '.' || s[tx][ty] == '@' || s[tx][ty] == '$' ||
            (tt >= 1 && tt <= K && cyx(S, tt) == 0))
                chkmax(f[x][y][S][h], DP(tx, ty, S, h));
        if (tt >= 1 && tt <= K && cyx(S, tt) == 1)
            chkmax(f[x][y][S][h], DP(tx, ty, S, h - 1));
        if (tt >= 1 && tt <= K && cyx(S, tt) == 2)
            chkmax(f[x][y][S][h], DP(tx, ty, lpf(S, tt, 1), h - 1) * gw[S][tt]
                + DP(tx, ty, lpf(S, tt, 0), h) * (1.0 - gw[S][tt]));
    }
    return f[x][y][S][h];
}
int main() {
    int i, j, Sx, Sy;
    m = read(); n = read(); K = read(); H = read();
    for (i = 1; i <= m; i++) for (j = 1; j <= n; j++)
        if ((s[i][j] = get()) == '$') Sx = i, Sy = j; pw[0] = 1;
    for (i = 0; i < (1 << K); i++) pb[i] = read();
    for (i = 1; i <= K; i++) pw[i] = pw[i - 1] * 3; init();
    printf("%.3lf\n", DP(Sx, Sy, pw[K] - 1, H));
    return 0;
}
====
```

---

## 作者：guapisolo (赞：6)

个人斗胆质疑楼上几位神犇的做法

[蒟蒻的博客](https://www.cnblogs.com/guapisolo/p/9958410.html)

只定义四维状态，好像是有一些问题的

比如从上一层xxxx往下走↓，走到了yyyy这个状态，然后，yyyy还会往上跑从xxxx更新，得到了一个#$%@的“最优解”，这可能是yyyy往上跑的最优解，但也可能不是！

因为你状态xxxx可能还有某个方向没有遍历，但我们草率得把f[xxxx]这个“并不最优解”去更新f[yyyy]

那如果在另一次搜索中，由某个状态zzzz往上走↑，又跑到了yyyy，由于访问过了yyyy，所以返回了f[yyyy]，然而这个f[yyyy]可能并不是最优解，导致答案出错！

为了避免这种错误，我们额外记录一维，表示从那个方向跑到当前状态，$f[x][y][s][h][t]$，t表示上一层是从哪个方向来的即可，虽然牺牲了一些常数但保证了答案的正确性！

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
#define N 35
#define M 250
#define dd double
#define idx(x) (x-'A'+1)
using namespace std;

int n,m,sx,sy,K,H;
char str[N][N];
int xx[]={-1,0,1,0},yy[]={0,1,0,-1};
int pw[]={1,3,9,27,81,243,729};
int mp[N][N],pro[M];
dd f[N][N][M][7][5],g[M][7],dan[7];
bool vis[N][N][M][7][5];
bool check(int x,int y){
    if(x<1||x>n||y<1||y>m||mp[x][y]==-1) return 0;
    else return 1;}
int p[M][7];
dd dfs(int x,int y,int s,int h,int fa)
{
    if(h<=0) return 0;
    if(vis[x][y][s][h][fa]) return f[x][y][s][h][fa];
    vis[x][y][s][h][fa]=1;
    if(mp[x][y]==K+1){
        f[x][y][s][h][fa]=1;
        return 1;
    }int tx,ty,t1,t2,pt;
    dd tmp=0;
    for(int i=0;i<4;i++)
    {
        tx=x+xx[i],ty=y+yy[i];
        if(!check(tx,ty)) continue;
        pt=mp[tx][ty],t1=t2=s;
        dd ans1=0,ans2=0;
        if(pt>0&&pt<=K&&!p[s][pt]) t1+=(1*pw[pt-1]);
        if(pt>0&&pt<=K&&!p[s][pt]) t2+=(2*pw[pt-1]);
        if(pt!=-1){
            if(g[s][pt]>0.0&&h>1) ans1=dfs(tx,ty,t1,h-1,(i+2)%4);
            if(g[s][pt]<1.0)ans2=dfs(tx,ty,t2,h,(i+2)%4);
            tmp=max(tmp,1.0*g[s][pt]*ans1+(1.0-g[s][pt])*ans2);
        }
    }f[x][y][s][h][fa]=tmp;
    return f[x][y][s][h][fa];
}
void Pre()
{
    for(int i=0;i<(1<<K);i++)
        scanf("%d",&pro[i]);
    for(int i=0;i<pw[K];i++){
        int x=i,k=K;
        while(k){
            p[i][k]=x/pw[k-1];
            x%=pw[k-1],k--;}
    }
    for(int i=0;i<pw[K];i++)
    {
        int tot=0,sum;
        for(int j=0;j<K;j++)
            dan[j+1]=0;
        for(int s=0;s<(1<<K);s++){
            int fl=1;
            for(int j=0;j<K;j++)
                if((s&(1<<j))&&p[i][j+1]==2) {fl=0;break;} 
                else if((!(s&(1<<j)))&&p[i][j+1]==1) {fl=0;break;}
            if(!fl) continue;
            tot+=pro[s];
        }int x=i,k=K;
        for(int k=1;k<=K;k++)
        {
            if(p[i][k]==0){
                sum=0;
                for(int s=0;s<(1<<K);s++)
                {
                    int fl=1;
                    for(int j=0;j<K;j++)
                        if((s&(1<<j))&&p[i][j+1]==2) {fl=0;break;} 
                        else if((!(s&(1<<j)))&&p[i][j+1]==1) {fl=0;break;}
                    if(!fl) continue;
                    if(s&(1<<(k-1))) sum+=pro[s];
                }g[i][k]=1.0*sum/tot;
            }
            if(p[i][k]==1){g[i][k]=1.0;}
            if(p[i][k]==2){g[i][k]=0.0;}
        }
    }
}
int main()
{
    scanf("%d%d%d%d",&n,&m,&K,&H);
    for(int i=1;i<=n;i++){
        scanf("%s",str[i]+1);
        for(int j=1;j<=m;j++)
        if(str[i][j]=='$') sx=i,sy=j;
        else if(str[i][j]=='@') mp[i][j]=K+1;
        else if(str[i][j]=='#') mp[i][j]=-1;
        else if(str[i][j]=='.') mp[i][j]=0;
        else mp[i][j]=idx(str[i][j]);
    }
    Pre();
    printf("%.3lf\n",dfs(sx,sy,0,H,4));
    return 0;
}

```

---

## 作者：Gmt丶FFF (赞：2)

#### 题意简述：

一个 $n\times m$ 的带墙体单入口多出口迷宫中有 $k$ 个陷阱，陷阱分为有害或无害，有害会使人掉血，给出所有垃圾的有害与无害的所有排列组成的概率，给定人的血量，求掉最少血走出迷宫的概率。

#### 解：

提到迷宫问题，考虑搜索。

首先将垃圾状态状压，$0$ 为未知，$1$ 为无害，$2$ 为有害，由于一来所有陷阱的情况都是未知的，所以状态为 $0$，而人需要去试探陷阱，每次试探后分有害无害搜索两种垃圾状态搜下去即可。

很明显会 $T$，考虑优化，在迷宫中有限考虑记忆化。

设 $f_{i,j,s,h}$ 代表人在 $(i,j)$，陷阱状态为 $s$，生命值为 $h$ 的概率。

那么我们需要提前预处理出来每一个三进制状态中一个未知的陷阱是有害的概率 $g_{i,j}$。

那么我们找到每一个合法的陷阱的组成方式，那么对于一个未知状态，它的概率即为所有组成方式的概率和除以组成方式个数。

那么记忆化也能转移了，对于踩到未知陷阱，$f_{i,j,s,h}=f_{i,j,new1,h-1}\times g_{s,k}+f_{i,j,new2,h}\times (1-g{s,k})$，其中 $new1,new2$ 代表踩到有害、无害陷阱的新状态，而 $k$ 代表踩的是哪一种陷阱。

如果对于已知陷阱，踩到未知的不扣，踩到已知的扣血即可。

但是这样会有问题，因为有情况可以绕一圈然后再走出去，那么就导致了状态会未算完就转移了。

那么我们用拓扑序就能解决这个问题，对于每一种陷阱组成状态预处理出来自己下一步可以走到的未知、有害陷阱和出口，这样就处理出了这个问题。

预处理只需要枚举状态，枚举起始点坐标，然后对于每一个状态与初始坐标进行广搜记录能走到的点即可。

复杂度：$O(n\times m\times 3^k\times h)$。

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<cstring>
using namespace std;
const int N=35;
const int M=750;
const int K=6;
const double eps=1e-10;
int n,m,k,hp,xb,yb;
char s[N][N];
int p[M],power[6]={1,3,9,27,81,243},b[4][2]={{1,0},{0,1},{-1,0},{0,-1}},vis[N][N],cnt,r[M];
double g[M][K],f[N][N][M][K];
vector<pair<int,int>>v[N][N][1<<K];
void dfs(int x,int y,int q,int xx,int yy,int id)
{
	if(vis[x][y]==id)return;
	vis[x][y]=id;
	if((x!=xx||y!=yy)&&(s[x][y]=='@'||(s[x][y]>='A'&&s[x][y]<='Z'&&((1<<(s[x][y]-'A'))&q)==0)))
	{
		//cout<<xx<<" "<<yy<<" "<<q<<" "<<x<<" "<<y<<endl;
		v[xx][yy][q].push_back({x,y});
		return;
	}
	for(int i=0;i<4;i++)
	{
		int xt=x+b[i][0],yt=y+b[i][1];
		if(xt<1||yt<1||xt>n||yt>m||s[xt][yt]=='#'||(xx==xt&&yy==yt))continue;
		dfs(xt,yt,q,xx,yy,id);
	}
}
double dp(int x,int y,int q,int h)
{
	//cout<<x<<" "<<y<<" "<<q<<" "<<h<<endl;
	if(f[x][y][q][h]>=-eps)return f[x][y][q][h];
	if(h==0)return f[x][y][q][h]=0;
	if(s[x][y]=='@')return f[x][y][q][h]=1;
	int len=v[x][y][r[q]].size();
	double res=0;
	for(int i=0;i<len;i++)
	{
		int xx=v[x][y][r[q]][i].first,yy=v[x][y][r[q]][i].second;
		if(s[xx][yy]=='@')
		{
			res=max(res,dp(xx,yy,q,h));
			continue;
		}
		if(q/power[s[xx][yy]-'A']%3==2)res=max(res,dp(xx,yy,q,h-1));
		if(q/power[s[xx][yy]-'A']%3==0)
		{
			int xzt1=q+power[s[xx][yy]-'A']*2,xzt2=q+power[s[xx][yy]-'A'];
			res=max(res,dp(xx,yy,xzt1,h-1)*g[q][s[xx][yy]-'A']+dp(xx,yy,xzt2,h)*(1-g[q][s[xx][yy]-'A']));
		}
	}
	return f[x][y][q][h]=res;
}
int main()
{
	//freopen("maze.in","r",stdin);
	//freopen("maze.out","w",stdout);
	scanf("%d%d%d%d",&n,&m,&k,&hp);
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)for(int q=0;q<power[k];q++)for(int t=0;t<=hp;t++)f[i][j][q][t]=-1;
	for(int i=1;i<=n;i++)scanf("%s",s[i]+1);
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)if(s[i][j]=='$')xb=i,yb=j;
	for(int i=0;i<(1<<k);i++)scanf("%d",&p[i]);
	for(int i=0;i<power[k];i++)
	{
		int num=0;
		for(int j=0;j<(1<<k);j++)
		{
			bool flag=0;
			for(int q=0;q<k;q++)
			{
				if(i/power[q]%3==0)continue;
				if(i/power[q]%3==1&&(j&(1<<q))==0)continue;
				if(i/power[q]%3==2&&(j&(1<<q)))continue;
				flag=1;
				break;
			}
			if(flag)continue;
			num+=p[j];
			for(int q=0;q<k;q++)
			{
				if(i/power[q]%3)continue;
				if((j&(1<<q)))g[i][q]+=p[j];
			}
		}
		for(int j=0;j<k;j++)
		{
			if(i/power[j]%3==1)g[i][j]=1,r[i]|=(1<<j);
			if(i/power[j]%3==2)g[i][j]=0;
			if(i/power[j]%3==0)g[i][j]/=num;
			//cout<<i<<" "<<j<<" "<<g[i][j]<<endl;
		}
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			for(int q=0;q<1<<k;q++)if(s[i][j]!='#')dfs(i,j,q,i,j,++cnt);
	double ans=dp(xb,yb,0,hp);
	printf("%.3lf",ans);
	return 0;
}
```

---

## 作者：ppp204 (赞：2)

> 做法: 概率DP

我们定义$dp[i][j][k][a][b]$,为当前处于$(i,j)$,剩余血量$k$,已经清楚的陷阱状态压缩后为$a$,其中有毒的陷阱状态压缩后为$b$。

显然能发现$b\in a$

因为DP显然要在起码有一维是单调的才可以进行,因此我们要维护a或者b或者k单调即可。(因为地图你要随便走,不一顶只走一个方向)

我们可以预处理出当有毒的陷阱以及已知陷阱的状态,此时它可能发生的概率。

然后我们再处理出从某个点走到另一个陷阱,或者走到一个终点后,将这个点直接存入当前起点能走到的点。(这样及就相当于直接飞过'.',就可以保证不会出现**某种状态影响它本身**这种情况的产生)

然后就可以进行记搜了。

#### Code:

```cpp
#include<bits/stdc++.h>
#define re register
#define rep(i,a,b) for(re int i=a,i##end=b; i<=i##end; i++)
#define drep(i,a,b) for(re int i=a,i##end=b; i>=i##end; i--)
#define repp(i,a,b) for(re int i=a,i##end=b; i<i##end; i++)
#define drepp(i,a,b) for(re int i=a,i##end=b; i>i##end; i--)
#define Erep(i,x) for(int i=head[x]; ~i; i=Edge[i].nxt)
#define debug(x) cerr<<#x<<" = "<<x<<endl
#define fi first
#define se second
#define PII pair<int,int>
#define coint const int
#define ms(x,a) memset(x,a,sizeof x)
#define CNC printf("%.2lf\n",(&S2-&S1)/1024./1024.0)
typedef long long ll;
using namespace std;
template<class T>inline T lowbit(const T &x) { return x&-x; }
template<class T>inline T rd(){
	static char ch;static bool neg;static T x;
	for(neg=0,ch=0; ch>'9'||ch<'0'; neg=(ch=='-'),ch=getchar());
	for(x=0; ch>='0'&&ch<='9'; x=(x<<1)+(x<<3)+(ch^'0'),ch=getchar());
	return neg?-x:x;
}
template<class T>inline T Max(const T &x, const T &y){
	return x>y?x:y;
}
template<class T>inline T Min(const T &x, const T &y){
	return x<y?x:y;
}
bool S1;
coint M=30+3;
coint dx[]={1,0,-1,0},dy[]={0,1,0,-1};
const float eps=1e-9;
#define In(x,y) ((x)&(1<<((y)-'A')))

int n,m,k,hp,S;
int sx,sy;
char mp[M][M];
float p[M];
float totp[M][M];
struct coor{
	short x,y;
};
vector<coor>vec[M][M][M];
int sz[M][M][M];

namespace Init_p{
	int sta[M];
	inline void solve(){
		float tot=0.0;
		repp(i,0,S) tot+=p[i];
		repp(i,0,S) p[i]/=tot;
		repp(i,0,S){
			repp(j,0,S){
				if((i&j)!=j) continue;
				repp(o,0,k){
					if(!In(i,o+'A')) sta[o]=0;
					else if(In(j,o+'A')) sta[o]=1;
					else sta[o]=-1;
				}
				repp(STA,0,S){
					bool flag=1;
					repp(o,0,k){
						if(sta[o]==1 && !In(STA,o+'A')) { flag=0; break; }
						if(sta[o]==-1 && In(STA,o+'A')) { flag=0; break; }
					}
					if(flag) totp[i][j]+=p[STA];
				}
			}
		}
		return;
	}
}

namespace Init_dfs{
	bool mark[M][M];
	inline void push_in(const short x, const short y, coint sta, coint sx, coint sy){
		vec[sta][sx][sy].push_back((coor)<%x,y%>);
		return;
	}
	void dfs(coint x, coint y, coint sta, coint sx, coint sy){
		if(mark[x][y]) return;
		mark[x][y]=1;
		if(mp[x][y]=='@' || (mp[x][y]>='A' && mp[x][y]<='Z' && (x!=sx || y!=sy) && In(sta,mp[x][y]))) { push_in(x,y,sta,sx,sy); return; }
		for(int i=0; i<4; i++){
			coint xx=dx[i]+x,yy=dy[i]+y;
			if(xx<1 || xx>n || yy<1 || yy>m || mp[xx][yy]=='#') continue;
			dfs(xx,yy,sta,sx,sy);
		}
	}
	inline void solve(){
		rep(i,1,n){
			rep(j,1,m){
				repp(o,0,S){
					rep(ii,1,n) rep(jj,1,m) mark[ii][jj]=0;
					dfs(i,j,o,i,j);
//					rep(now,1,sz[o][i][j]) printf("vec[%d][%d][%d][%d] = { %d , %d }\n",o,i,j,now,vec[o][i][j][now].x,vec[o][i][j][now].y);
				}
			}
		}
		return;
	}
}

inline void Init(){
	Init_p::solve(); Init_dfs::solve();
	return;
}

float dp[M][M][6][M][M];

float dfs(coint x, coint y, coint hp, coint a, coint b){
	if(hp<=0) return 0;
	if(mp[x][y]=='@') return 1.0;
	float &res=dp[x][y][hp][a][b];
	if(res>-0.5) return res;
	res=0.0;
	for(int i=0,sta=(~a|b)&(S-1),size=(int)vec[sta][x][y].size(); i<size; i++){
		coint xx=vec[sta][x][y][i].x,yy=vec[sta][x][y][i].y;
		if(mp[xx][yy]=='@') return (res=1.0);
		if(mp[xx][yy]>='A' && mp[xx][yy]<='Z'){
			if(In(b,mp[xx][yy])){
				res=Max(res,dfs(xx,yy,hp-1,a,b));
				continue;
			}
			coint nxta=a|(1<<(mp[xx][yy]-'A')),nxtb=b|(1<<(mp[xx][yy]-'A'));
			const float p=totp[nxta][nxtb]/totp[a][b];//不难证明前者小于等于后者
			res=Max(res,
			(float)(p>eps?p*(dfs(xx,yy,hp-1,nxta,nxtb)):0)+
			(float)(1.0-p>eps?(1.0-p)*(dfs(xx,yy,hp,nxta,b)):0)
			);
		}
	}
	return res;
}

inline void solve(){
	rep(i,1,n){
		rep(j,1,m){
			rep(o,1,hp){
				repp(x,0,S){
					repp(y,0,S){
						dp[i][j][o][x][y]=-1.0;
					}
				}
			}
		}
	}
	printf("%.3f\n",dfs(sx,sy,hp,0,0));
	return;
}

bool S2;

int main(){
//	freopen("maze.in","r",stdin);
//	freopen("wa.out","w",stdout);
	n=rd<int>(),m=rd<int>(),k=rd<int>(),hp=rd<int>();
	S=1<<k;
	rep(i,1,n){
		scanf("%s",mp[i]+1);
		rep(j,1,m) if(mp[i][j]=='$') sx=i,sy=j;
	}
	repp(i,0,S) scanf("%f",&p[i]);
	Init();
	solve();
	return 0;
}

```

---

## 作者：StarPatrick (赞：0)

写一篇记忆化搜索的题解。

发现数据范围很小，于是大胆设计状态。

记录 $(x,y)$ 表示当前所在位置，$u$ 表示当前已知字母的状态，这里使用的是三进制，某一位为 0 表示这个字母还未知，为 1 表示这个字母已知无害，为 2 表示已知这个字母有害，再记录一个生命值 $rest$ 就可以了。

定义好状态后，考虑如何转移，这个直接在记忆化搜索里面直接再跑一个 dfs 或者 bfs，转移到终点或者未确定的字母处，可以发现这样转移是没有后效性的。

时间复杂度 $O(n^2m^23^kH)$。

虽然复杂度看起来很大，但是很多状态是搜不到的，最后跑得非常快（这个题数据也水，不加记忆化都差点过了，实现得好的搜索剪枝应该随便过）。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const double eps = 1e-5;
int n, m, s, H, sum, pw[10] = {1, 3, 9, 27, 81, 243}, dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
char a[35][35];
double dp[35][35][250][10], d[50], temp[250];
bool book[35][35][250][10];
double dfs(int x, int y, int u, int rest);
struct e{
	int x, y, u;
};
double dfs(int x, int y, int u, int rest) {
	if (!rest) return 0;
	if (temp[u]<eps) return 0;
	if (book[x][y][u][rest]) return dp[x][y][u][rest];
	book[x][y][u][rest] = 1;
	bool vis[35][35] = {};
	deque<e> q;
	q.push_front({x, y, 0});
	vis[x][y] = 1;
	double ans = 0;
	while (!q.empty()) {
		e t = q.front();
		q.pop_front();
		if (t.u>=rest) break;
		if (a[t.x][t.y]=='#') continue;
		if (a[t.x][t.y]=='@') return dp[x][y][u][rest]=1;
		if (a[t.x][t.y]!='.'&&u/pw[a[t.x][t.y]-'A']%3==0) {
			ans = max(ans, temp[u+pw[a[t.x][t.y]-'A']]/temp[u]*dfs(t.x, t.y, u+pw[a[t.x][t.y]-'A'], rest-t.u)+temp[u+2*pw[a[t.x][t.y]-'A']]/temp[u]*dfs(t.x, t.y, u+2*pw[a[t.x][t.y]-'A'], rest-t.u-1));
			continue;
		}
		for (int p=0;p<4;p++) {
			int dx = t.x+dir[p][0], dy = t.y+dir[p][1];
			if (!vis[dx][dy]&&dx>=1&&dx<=n&&dy>=1&&dy<=m) {
				vis[dx][dy] = 1;
				if (a[dx][dy]>='A'&&a[dx][dy]<='Z') {
					if (u/pw[a[dx][dy]-'A']%3==2) q.push_back({dx, dy, t.u+1});
					else q.push_front({dx, dy, t.u});
				}
				else q.push_front({dx, dy, t.u});
			}
		}
	}
	return dp[x][y][u][rest]=ans;
}
int main() {
	scanf("%d %d %d %d", &n, &m, &s, &H);
	int sx, sy;
	for (int p=1;p<=n;p++) {
		for (int k=1;k<=m;k++) {
			cin>>a[p][k];
			if (a[p][k]=='$') {
				sx = p;
				sy = k;
				a[p][k] = '.';
			}
		}
	}
	for (int p=0;p<(1<<s);p++) {
		scanf("%lf", &d[p]);
		sum+=d[p];
	}
	for (int p=0;p<(1<<s);p++) {
		d[p]/=sum;
	}
	for (int u=0;u<pw[s];u++) {
		for (int i=0;i<pw[s];i++) {
			bool flag = 0;
			int o = 0;
			for (int p=0;p<s;p++) {
				if (i/pw[p]%3==0) {
					flag = 1;
					break;
				}
				if (u/pw[p]%3&&i/pw[p]%3!=u/pw[p]%3) {
					flag = 1;
					break;
				}
				o+=(i/pw[p]%3-1)<<p;
			}
			if (!flag) temp[u]+=d[o];
		}
	}
	printf("%.3f", dfs(sx, sy, 0, H));
	return 0;
} 
```


---

## 作者：YPZ_979 (赞：0)

概率ＤＰ，记忆化搜索；陷阱的每种状态都有一个概率；且题目说使用最优策略，这与已知的情况有关，所以可以定义f[x][y][now][h]，表示走到(x,y)，当前陷阱的情报是ｎｏｗ（状压，３进制数）,人物血量为ｈ，的概率；接下来考虑转移；转移都是要取Ｍａｘ；如果是平地，直接转移；如果是无害的陷阱，也直接转移dp(....)；如果是有害的陷阱，那么就会扣一滴血,dp(...,h-1);那如果是未知的呢？就分两种情况；ＭＡx（有害的概率\*dp(x,y,状态1，h)＋无害的概率\*dp(x,y,状态2,ｈ))，状态１就是把对应陷阱在当前状态下修改为１，状态２就是修改为０；那么在当前的状况下有害的概率是多少呢？在所有状态【０,(1<<k)-1】，中，与当前状态除了未知的位意外，其余的位都相同的，都可以对这个产生影响，把所有产生影响的ｐ都相加，就可以求得；由于1<<k  <= 2^5，Max=3^5==125,所以可以用ｄｆｓ暴力把所有的在某种状态下有害的概率都算出来；

于是这题就迎刃而解了！！！


```cpp
#include<algorithm>
#include<iostream>
#include<iomanip>
#include<cstdlib>
#include<cstring>
#include<vector>
#include<cstdio>
#include<stack>
#include<queue>
#include<cmath>
#include<ctime>
#define db double
#define re register
using namespace std;
const int N=40,M=250; 
db g[M][6],f[N][N][M][6],tmp[2];
bool vis[N][N][M][6];
int a[6];
int p[M],n,m,H,K,Max;
char map[N][N];
int dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};//　为什么交换一下搜索顺序就Ａ了????!!!
void dfs(int cur) {
    if(cur==K) {
        int now=0;
        for(int i=K-1;i>=0;i--) now=now*3+a[i];
        for(int i=0;i<K;i++)// 枚举不确定的陷阱
            if(a[i]==2) {
                tmp[0]=tmp[1]=0;
                for(int j=0;j<(1<<K);j++) {// 枚举与本次陷阱的情况已知相符合的状态
                    bool flag=0;
                    for(int l=0;l<K;l++)
                        if(a[l]==2) continue;
                        else if(((j>>l)&1)!=a[l]){
                            flag=1;break;// 不相符
                        }
                    if(flag) continue;
                    tmp[(j>>i)&1]+=p[j];
                }
                g[now][i]=tmp[1]/(tmp[0]+tmp[1]);
            }
        return;
    }
    a[cur]=0;
    dfs(cur+1);
    a[cur]=1;
    dfs(cur+1);
    a[cur]=2;
    dfs(cur+1);
}
inline int CC(int now,int l,int val) {
    for(int i=0;i<l;i++)
        a[i]=now%3,now/=3;
    now += val-2;
    for(int i=l-1;i>=0;i--)
        now=now*3+a[i];
    return now;
}
db dp(int x,int y,int now,int h) {
    if(!h) return 0;
    if(map[x][y] =='@') return 1;
    if(vis[x][y][now][h]) return f[x][y][now][h];
    vis[x][y][now][h]=1;
    for(int i=0;i<4;i++) {
        int u=x+dx[i],v=y+dy[i];
        if(u>=0&&u<n&&v>=0&&v<m&&map[u][v]!='#') {// bug v<n
            if(map[u][v]=='.'||map[u][v]=='$'||map[u][v]=='@')
                f[x][y][now][h]=max(f[x][y][now][h],dp(u,v,now,h));
            else {
                int t=map[u][v]-'A',oh=now;
                for(int j=0;j<t;j++) oh/=3;
                if(oh%3==0)
                    f[x][y][now][h]=max(f[x][y][now][h],dp(u,v,now,h));
                else if(oh%3==1)
                    f[x][y][now][h]=max(f[x][y][now][h],dp(u,v,now,h-1));
                else
                    f[x][y][now][h]=max(f[x][y][now][h],dp(u,v,CC(now,t,0),h)*(1-g[now][t]) + dp(u,v,CC(now,t,1),h-1)*g[now][t]);// bug
            }
        }
    }
    return f[x][y][now][h];
}
int main() {
    int sx,sy;
    for(int i=0;i<n;i++)
        scanf("%s",map[i]);
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
            if(map[i][j]=='$')
                {sx=i,sy=j;break;}
    for(int i=0;i<(1<<K);i++)
        scanf("%d",&p[i]);
    dfs(0);
    Max=1;
    for(int i=0;i<K;i++) Max*=3;
    Max--;
    printf("%.3lf",dp(sx,sy,Max,H));
    return 0;
}

```

---

## 作者：zjo_2001 (赞：0)

先定义好状态.

考虑到陷阱有三种状态,有害,无害和未知.

k<=5,这明显要状态压缩.

f[i][x][y][h]表示在x行y列，当时的状态为i，血量为h的概率.

i为一个三进制数,每一位表示陷阱的状态.

然后我们想想怎么转移.

首先,设点(x,y)走到(xx,yy).

若(xx,yy)不是陷阱,直接走过去就可以了.

重点考虑(xx,yy)是陷阱的情况.

若已知这个陷阱是无害的,那么跟这个点不是陷阱一样.

f[i][x][y][h]=max(f[i][x][y][h],f[i][xx][yy][h]);

若是有害的,血量减一.

f[i][x][y][h]=max(f[i][x][y][h],f[i][xx][yy][h-1]);

若这个陷阱是未知的怎么办?

这就需要根据概率来改变这个陷阱的状态,改成有害或者无害.

因为走到了这个陷阱之后就变成已知的了.

转移到:f[i1][xx][yy][h-1]\*g[i][k]+f[i2][xx][yy][h]\*(1-g[i][k]).

i1代表改为有害的状态,i2代表改为无害的状态.

g[i][k]代表在i这个状态k这个陷阱有害的概率,这个需要预处理.

怎么求g[i][k]?

这个用dfs比较好实现.

先把状态i的每一位搜出来.

然后第一层for枚举每个陷阱,若陷阱的状态为2,即为未知,就需要处理.

第二层for枚举每一种状态.

第三层for枚举状态的每一位,若这一位是已知的陷阱,且这位的状态与搜出来的状态i的那一位时一样的,那么这就是一个对当前有影响的状态,统计p值.

统计出了有害的p值和无害的p值.g[i][k]=有害/(有害+无害).

有点玄学.

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<algorithm>
#include<map>
#include<complex>
#include<queue>
#include<stack>
#include<cmath>
#include<set>
#include<vector>
using namespace std;
double g[250][6],f[250][33][33][6],tmp[2];
char mp[33][33];
int dx[5]={0,1,0,-1,0},dy[5]={0,0,-1,0,1},K,H,n,m,a[10],p[33];
bool vis[250][33][33][6];
void dfs(int w){
  if(w==K){
    int now=0;
    for(int i=K-1;i>=0;i--) now=now*3+a[i];
    for(int i=0;i<K;i++)
      if(a[i]==2){
    tmp[0]=tmp[1]=0;
    for(int j=0;j<(1<<K);j++){
      bool flag=0;
      for(int l=0;l<K;l++)
        if(a[l]==2) continue;
        else if(((j>>l)&1)!=a[l]){flag=1;break;}
      if(!flag) tmp[((j>>i)&1)]+=p[j];
    }
    g[now][i]=tmp[1]/(tmp[1]+tmp[0]);
      }
    return;
  }
  a[w]=0;
  dfs(w+1);
  a[w]=1;
  dfs(w+1);
  a[w]=2;
  dfs(w+1);
}
int change(int now,int pos,int val){
  for(int i=0;i<pos;i++) a[i]=now%3,now/=3;
  now+=val-2;
  for(int i=pos-1;i>=0;i--)
    now=now*3+a[i];
  return now;
}
double DP(int now,int x,int y,int h){
  if(!h) return 0;
  if(mp[x][y]=='@') return 1;
  if(vis[now][x][y][h]) return f[now][x][y][h];
  vis[now][x][y][h]=1;
  for(int i=1;i<=4;i++){
    int xx=x+dx[i],yy=y+dy[i];
    if(xx>0 && xx<=n && yy>0 && yy<=m && mp[xx][yy]!='#'){
      char ch=mp[xx][yy];
      if(ch=='.' || ch=='@' || ch=='$') f[now][x][y][h]=max(f[now][x][y][h],DP(now,xx,yy,h));
      else if(ch>='A' && ch<='Z'){
    int t=ch-'A',p=now;
    for(int j=0;j<t;j++) p/=3;
    if(p%3==0) f[now][x][y][h]=max(f[now][x][y][h],DP(now,xx,yy,h));
    else if(p%3==1) f[now][x][y][h]=max(f[now][x][y][h],DP(now,xx,yy,h-1));
    else f[now][x][y][h]=max(f[now][x][y][h],DP(change(now,t,0),xx,yy,h)*(1-g[now][t])
                 +DP(change(now,t,1),xx,yy,h-1)*g[now][t]);
      }
    }
  }
  return f[now][x][y][h];
}
int main(){
  int sx,sy;
  scanf("%d%d%d%d",&n,&m,&K,&H);
  for(int i=1;i<=n;i++)
    scanf("%s",mp[i]+1);
  for(int i=0;i<(1<<K);i++) scanf("%d",p+i);
  for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
      if(mp[i][j]=='$'){sx=i,sy=j;break;}
  //for(int i=0;i<(1<<K);i++) p[i]/=s;
  int zd=1;
  for(int i=1;i<=K;i++) zd*=3;
  --zd;
  dfs(0);
  printf("%.3lf\n",DP(zd,sx,sy,H));
  /*for(int i=0;i<(1<<K);i++){
      for(int j=1;j<=K;j++)
    printf("%.3lf ",g[i][j]);
      printf("\n");
      }*/
  return 0;
}
```

---


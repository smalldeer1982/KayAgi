# [SDOI2012] 体育课

## 题目背景

# 警告：滥用本题评测将被封号

## 题目描述

又是一节体育课的时间了，有 $n$ 个同学排成了一排。他们都很讨厌排在第一个位置的同学，于是后面的同学中比第一个高的都会产生一个高兴值，这个高兴值等于他的身高减去第一个同学的身高。当然比第一个同学矮的同学产生兴奋值为 $0$。

现在体育老师来了，他拥有神奇的魔法，现在他能做如下的三件事：

1. 询问某段区间高兴值最大的那个是多少。

2. 把某两个同学交换一下位置。

3. 选取一段区间的人，把第一个人身高加上 $t$，第二个加上 $2t$，第三个加上 $3t$ 以此类推。

但是体育老师不会数数，于是他找到你了，对于每一个询问，他要你帮他求出那个值。


## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $1 \le n,m \le 5 \times 10^3$。
- 另有 $10\%$ 的数据，没有第三种操作。
- 另有 $20\%$ 的数据，没有第二种操作。
- 对于 $100\%$ 的数据，$1 \le n,m \le 10^5$，$0 \le t \le 10^4$，$1 \leq a_i \leq 10^8$。

## 样例 #1

### 输入

```
6 7
109 827 100 530 10 826
3 1 6 1
2 2 6
1 2 4
1 2 3
2 2 6
1 2 6
1 2 5```

### 输出

```
722
722
722
719```

# 题解

## 作者：x_faraway_x (赞：12)

### 1. 题目大意

给定一个长度为 $n$ 的数列 $a_1,a_2,a_3,...,a_n$ , 并给出 $m$ 个操作，操作类型如下：

操作1：查询区间最大值，输出最大值与 $a_1$ 的差；

操作2：交换两个数的位置；

操作3：选择一段区间 $[l,r]$ 并给定 $t$ ，将区间中第 $x$ 个数加上 $x\cdot t $ .

$n,m \le 10^5$ .

### 2. 解题报告

本题的正解是分块。

首先我们先考虑操作3，对于两边的元素，我们直接暴力修改然后重构即可。那么我们如何维护整块呢？

维护 $add[ x ]$ 表示第 $x$ 块累加的 $t$ , 那我们要得到单个元素，再维护一个偏移量 $del[x]$ ，这样块中元素的权值即可表示为 $w[i]=a[i]+add[x]\times i-del[x]$. 

（举个例子，若给块 $[4,6]$ 加上 $2T, 3T, 4T$ ，那么$add[x]=T$ ，$del[x]=2T$，这样 $w[5]=a[5]+5T-2T=a[5]+3T$ .）

对于操作2，我们直接暴力交换然后重构块即可。

对于操作1，我们考虑在整块被修改后，如何维护块内的最大值。由于每个元素的编号 $i$ 和权值 $a_i$ 都是定值且 $i$ 单增，我们可以将每个元素看成 $(i,a_i)$ ，然后用单调栈维护一个上凸壳。这样随着 $add$ 的增大，最大元素位置一定向右移动，且元素权值呈单峰。

每个操作维护（询问）的复杂度都为 $O( n\sqrt{n} )$，再加上本题时间限制宽松，可以轻松通过。

### 3. 参考程序

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
namespace io {
	const int SIZE=(1<<21)+1;
	char ibuf[SIZE],*iS,*iT;
	char gc()
	{
		if(iS==iT) iT=(iS=ibuf)+fread(ibuf,1,SIZE,stdin);
		if(iS==iT) return EOF;
		return *iS++;
	}
	inline int gi()
	{
		char c; int x=0,f=1;
		for(;c<'0'||c>'9';c=gc())if(c=='-')f=-1;
		for(;c>='0'&&c<='9';c=gc())x=(x<<1)+(x<<3)+c-'0';
		return x*f;
	}
}
using io::gi;
const int N=100005,qN=320;
int n,m,bel[N],b,s[qN][qN],tp[qN],pos[qN];
ll h[N],a[N],add[qN],del[qN];
#define top s[x][tp[x]]
#define dtp s[x][tp[x]-1]
#define Max(x) s[x][pos[x]]
void remove(int x)
{
	for(int i=(x-1)*b+1;i<=x*b;i++) a[i]+=add[x]*i-del[x];
	add[x]=del[x]=pos[x]=tp[x]=0;
}
void build(int x)
{
	memset(s[x],0,sizeof(s[x]));
	for(int i=(x-1)*b+1;i<=x*b;i++)
	{
		while(tp[x]>1&&(a[i]-a[top])*(top-dtp)>=(a[top]-a[dtp])*(i-top))--tp[x];
		s[x][++tp[x]]=i;
	}
	for(pos[x]=1;pos[x]<=tp[x]&&a[s[x][pos[x]+1]]>=a[s[x][pos[x]]];pos[x]++);
}
void update(int x)
{
	for(;pos[x]<=tp[x];pos[x]++)
		if(a[s[x][pos[x]+1]]+add[x]*s[x][pos[x]+1]<a[s[x][pos[x]]]+add[x]*s[x][pos[x]])
			break;
}
int main()
{
	n=gi(),m=gi();
	b=sqrt(n);
	for(int i=1;i<=n;i++) bel[i]=(i-1)/b+1,a[i]=gi();
	for(int i=1;i<=bel[n];i++) build(i);
	while(m--)
	{
		int op=gi(),l=gi(),r=gi();
		if(op==1)
		{
			ll k=a[1]+add[1]-del[1];
			ll mx=k;
			for(;bel[l]==bel[l-1]&&l<=r;l++)
				mx=max(mx,a[l]+add[bel[l]]*l-del[bel[l]]);
			for(;l+b<=r;l+=b)
				mx=max(mx,a[Max(bel[l])]+add[bel[l]]*Max(bel[l])-del[bel[l]]);
			for(;l<=r;l++)
				mx=max(mx,a[l]+add[bel[l]]*l-del[bel[l]]);
			printf("%lld\n",mx-k);
		}
		if(op==2)
		{
			remove(bel[l]),remove(bel[r]);
			swap(a[l],a[r]);
			build(bel[l]); build(bel[r]);
		}
		if(op==3)
		{
			int t=gi(),tl=l;
			for(;bel[l]==bel[l-1]&&l<=r;l++) a[l]+=(l-tl+1)*t;
			remove(bel[l-1]); build(bel[l-1]);
			for(;l+b<=r;l+=b) add[bel[l]]+=t,del[bel[l]]+=(tl-1)*t,update(bel[l]);
			for(;l<=r;l++) a[l]+=(l-tl+1)*t;
			remove(bel[r]); build(bel[r]);
		}
	}
}
```

### 4. 附：维护上凸壳的正确性数学证明

附赠给不能理解维护上凸壳正确性的同学：

假设现在有3个元素 $x,y,z$ ，设它们的编号分别为 $h_x, h_y, h_z$，元素大小为 $a_x,a_y,a_z$ ，权值为$w_x,w_y,w_z$ ， $h_x<h_y<h_z$ 。设 $add$ 值为 $T$, 若存在 $T$ 使得 $w_y > w_x$ 且 $w_y>w_z$，则作差列出不等式：

$a_x-a_y<(h_y-h_x)T$ ， $a_y-a_z>(h_z-h_y)T$ .

两式整理合并可得 $\displaystyle \frac{a_z-a_y}{h_z-h_y}<\frac{a_y-a_x}{h_y-h_x}$  .

即：直线 $y\to z$ 的斜率小于直线 $x\to y$ 的斜率，故维护上凸壳。同时易发现，随着 $T$ 的不断增大，最大元素的位置右移，且最大元素左边的权值递增，右边的权值递减（即单峰）。



---

## 作者：wine (赞：5)

方法一：

我们可以直接暴力。预计得分20分



方法二：

我们不考虑第三种操作，只需要维护一个最大值就可以了，预计得分40分



方法三：

我们考虑对于一段进行分段操作，分成sqrt(n)块。

有一个技巧是，我们求的是一段区间的最大值。我们把每个值a[i]修改为a[i]-a[i-1]，这样的话问题变成求最大前缀和。而第三种操作就变成了对一段区间进行加t的操作。

对于每一个快，我们记录这一块的最大值maxs，和对一整段进行操作的话，后面能够超过这个最大值的最小的是多少min。

那么对于第二种操作我们直接暴力维护，时间复杂度o(sqrt(n));

对于第三种操作，如果跨立一个块得话，我们直接对这一段区间标记加上t。如果这个标记大于这一段的min的话，我们对这一块暴力进行维护。时间复杂度o(sqrt(n)).

对于第一种操作,我们可以变成求最大前缀和啦。时间复杂度o(sqrt(n));

这一整个时间复杂度为o((n+m)*sqrt(n));



复杂度十分玄学(我是看了贴吧的讨论写的)
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <queue>
#include <set>
#include <cassert>

using namespace std;

typedef long long LL;

void read(LL &x) {
    char c;bool flag = 0;
    while((c=getchar())<'0'||c>'9') flag |= (c=='-');
    x=c-'0';while((c=getchar())>='0'&&c<='9') x = x*10+c-'0';
    flag?x=-x:x;
}

void read(int &x) {
    char c;bool flag = 0;
    while((c=getchar())<'0'||c>'9') flag |= (c=='-');
    x=c-'0';while((c=getchar())>='0'&&c<='9') x = x*10+c-'0';
    flag?x=-x:x;
}

const LL inf = ~0u>>2;
void FRE();

void upval(LL &a,const LL &b) {if(a<b) a=b;}

#define MAXX 101000
#define N 600
int n,m;
LL h[MAXX],bsf[N];
int bsiz,bl[N],br[N],bk[MAXX];
LL lazy1[N],lazy2[N];
struct pii{LL h,pos;pii(LL h=0,LL pos=0):h(h),pos(pos){}} st[N][N];
int top[N];

void reset(int bk) {
	bsf[bk] = inf; top[bk] = 0;
	for (LL i = bl[bk]; i <= br[bk]; i++) {
		while(top[bk] && st[bk][top[bk]].h <= h[i]) top[bk]--;
		st[bk][++top[bk]] = pii(h[i],i);			
	}
	for (LL i = 2; i <= top[bk]; i++)
	  bsf[bk] = min(bsf[bk], 
	     ((st[bk][1].h-st[bk][i].h)/(st[bk][i].pos-st[bk][1].pos)));
}

void push_down(int bk) {
	if(!lazy1[bk] && !lazy2[bk]) return;
	for (LL i = bl[bk]; i <= br[bk]; i++)
	 h[i] += lazy1[bk]+i*lazy2[bk];
	lazy1[bk] = lazy2[bk] = 0;
}

void Swap(int x,int y) {
	push_down(bk[x]); push_down(bk[y]);
	swap(h[x],h[y]);
	reset(bk[x]); reset(bk[y]);
}

LL Max(int x,int y) {
	int li = min(br[bk[x]],y); LL mx = 0;
	push_down(bk[x]);
	for (int i = x; i <= li; i++) upval(mx,h[i]);
	reset(bk[x]);
	for (int i = bk[x]+1; i < bk[y]; i++) {
	  	if(lazy2[i] >= bsf[i] && lazy2[i]) {
			push_down(i);
			reset(i);
		}
		upval(mx,st[i][1].h+lazy1[i]+lazy2[i]*st[i][1].pos);
	}
	if(bk[x] != bk[y]) {
		push_down(bk[y]);
		for (int i = bl[bk[y]]; i <= y; i++) upval(mx,h[i]);
		reset(bk[y]);
	}
    mx -= h[1]+lazy1[bk[1]]+lazy2[bk[1]];
    return mx>0 ? mx:0;
}

void Add(int x,int y,LL t) {
	int li = min(br[bk[x]],y); LL L = x-1;
	push_down(bk[x]);
	for (int i = x; i <= li; i++) h[i] += (i-L)*t;
	reset(bk[x]);
	for (int i = bk[x]+1; i < bk[y]; i++) 
		lazy1[i] += -L*t,lazy2[i] += t;
	if(bk[x] != bk[y]) {
		push_down(bk[y]);
		for (int i = bl[bk[y]]; i <= y; i++) h[i] += (i-L)*t;
		reset(bk[y]);
	}
}

int main() {
	//FRE();
	read(n); read(m);
	bsiz = sqrt(n+0.5);
    for (int i = 1; i <= n; i++) {
       read(h[i]);
       bk[i] = i/bsiz+1;
       if(!bl[bk[i]]) bl[bk[i]] = i;
       br[bk[i]] = i;
	} 
	for (int i = 1; i <= bk[n]; i++) reset(i);
	for (int i = 1,tp,x,y,t; i <= m; i++) {
		read(tp); read(x); read(y);
		if(tp == 1) printf("%lld\n",Max(x,y));
		else if(tp == 2) Swap(x,y);
		else read(t),Add(x,y,t);
	}
	return 0;
}

void FRE() {
	assert(freopen("sdoi12_line.in","r",stdin));
    assert(freopen("sdoi12_line.out","w",stdout));
}
```


---

## 作者：Treeloveswater (赞：5)

真是R2毒瘤题。。。网上还找不到题解  
最终在一个6年前的NOIP讨论帖看到了做法的简介
  
核心思想：分块

对于每个块，我们保存最大值和其位置。  
对于1操作就是正常查询  O(msqrt(n))  
对于2操作 也是正常swap，然后暴力再重算那两个块的信息O(msqrt(n))    
对于3操作 如果当前这个块的最大值会发生变化，我们就暴力重算该块。  
由于当这个块被完全覆盖的加值时，最大值的位置是单调向右更改的。  
所以每个块最多更改sqrt(n)次  每次修改量为sqrt(n) 总共sqrt(n)个块  
那个移动的总复杂度为sqrt(n)^3=nsqrt(n)

那么这个题我们就可以在 O((n+m)sqrt(n))的时间复杂度解决了。

and,样例是错的。。。我在讨论里提到了。  
并且，同志们要注意卡常。。这题有很大常数，所以wysssssss+开O2才能过。

当然也需要一点小优化之类的，具体看代码。
```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define o 200011
#define ll long long
const int inf=1e9;
void max(ll &a,ll b){
    if(b>a) a=b;
}
void min(ll &a,ll b){
    if(a>b) a=b;
}
struct Point{
    int p;ll v;
};
ll A[o],Ti,S[o];
int bl[o],P[o];
int n,m,li,ri,type,top;
struct node{
    int l,r;ll T,sum,lim;
    Point bst;
    ll Maxnum(){
        return bst.v+(ll)bst.p*T-sum;
    }
    void pushdown(){
        if(!T)return;
        bst.v=Maxnum();
        for(register ll i=l;i<=r;i++) A[i]+=i*T-sum;
        T=sum=0;
    }
    void clear(){
        r=T=sum=0,l=inf,lim=1e13;
        bst.v=0,bst.p=0;
    }
    void Reset(){
        lim=1e13;bst.v=0,bst.p=0;
        top=0;
        for(register int i=l;i<=r;i++){
            if(bst.v<=A[i]){
                bst.v=A[i],bst.p=i;
                top=0;
            }
            else{
                while(top&&S[top]<=A[i]) top--;
                S[++top]=A[i];P[top]=i;
            }
        }  
        for(register int i=1;i<=top;i++) lim=std::min(lim,(bst.v-S[i])/(ll)(P[i]-bst.p));
    }
    void Come(){
        top=0;
        for(register int i=bst.p;i<=r;i++){
            if(bst.v<=A[i]){
                bst.v=A[i],bst.p=i;
                top=0;
            }
            else{
                while(top&&S[top]<=A[i]) top--;
                S[++top]=A[i];P[top]=i;
            }
        }  
        lim=1e13;
        for(register int i=1;i<=top;i++) lim=std::min(lim,(bst.v-S[i])/(ll)(P[i]-bst.p));	
    }
}Block[405];
inline void in(ll &ans, char ch = getchar(), bool flag = false)
{
    ans = 0;
    for (; (ch < '0' || ch > '9') && ch != '-'; ch = getchar());
    if (ch == '-')
    {
        ch = getchar();
        flag = true;
    }
    for (; ch >= '0' && ch <= '9'; ans = (ans << 3) + (ans << 1) + ch - 48, ch = getchar());
    if (flag) ans = -ans;
}
inline void In(int &ans, char ch = getchar(), bool flag = false)
{
    ans = 0;
    for (; (ch < '0' || ch > '9') && ch != '-'; ch = getchar());
    if (ch == '-')
    {
        ch = getchar();
        flag = true;
    }
    for (; ch >= '0' && ch <= '9'; ans = (ans << 3) + (ans << 1) + ch - 48, ch = getchar());
    if (flag) ans = -ans;
}
int main(){
    In(n),In(m);
    for(register int i=1;i<=n;i++) in(A[i]);
    int len=sqrt(n),N;
    for(register int i=1;i<=n;i++) bl[i]=(i-1)/len+1;
    N=bl[n];
    for(register int i=1;i<=N;i++) Block[i].clear();
    for(register int i=1;i<=n;i++) Block[bl[i]].l=std::min(Block[bl[i]].l,i),Block[bl[i]].r=std::max(Block[bl[i]].r,i);
    for(register int i=1;i<=N;i++) Block[i].Reset();
    for(register int t=1;t<=m;t++){
        In(type),In(li),In(ri);
        if(type==1){
            ll ans=0,h1=A[1]+Block[1].T-Block[1].sum;
            if(bl[li]!=bl[ri]){
                Block[bl[li]].pushdown();Block[bl[li]].Reset();
                Block[bl[ri]].pushdown();Block[bl[ri]].Reset();
                for(register int i=li;i<=Block[bl[li]].r;i++) max(ans,A[i]);
                for(register int i=Block[bl[ri]].l;i<=ri;i++) max(ans,A[i]);
                for(register int i=bl[li]+1;i<=bl[ri]-1;i++){
                    if(Block[i].T>Block[i].lim) Block[i].pushdown(),Block[i].Come();
                    max(ans,Block[i].Maxnum());
                }
            }
            else{
                Block[bl[li]].pushdown();Block[bl[li]].Come();
                for(register int i=li;i<=ri;i++) max(ans,A[i]);
            }
            printf("%lld\n",std::max(0ll,ans-h1));
            continue;
        }
        if(type==2){
            Block[bl[li]].pushdown();Block[bl[ri]].pushdown();
            std::swap(A[li],A[ri]);
            Block[bl[li]].Reset(); Block[bl[ri]].Reset();
            continue;
        }
        if(type==3){
            in(Ti);ll L=li-1;
            if(bl[li]!=bl[ri]){
                for(register ll i=li;i<=Block[bl[li]].r;i++) A[i]+=(i-L)*Ti;
                for(register ll i=Block[bl[ri]].l;i<=ri;i++) A[i]+=(i-L)*Ti;
                Block[bl[li]].pushdown();Block[bl[li]].Reset();
                Block[bl[ri]].pushdown();Block[bl[ri]].Reset();
                
                for(register int i=bl[li]+1;i<=bl[ri]-1;i++){
                    Block[i].T+=Ti;
                    Block[i].sum+=L*Ti;
                }
            }
            else{
                for(register ll i=li;i<=ri;i++) A[i]+=(i-L)*Ti;
                Block[bl[li]].pushdown();Block[bl[li]].Reset();
            }
        }
    }
}
```

---

## 作者：E1_de5truct0r (赞：2)

考虑分块。假设块长为 $B$，依次考虑下面三个操作：

1. 区间加等差数列

	是一个基础操作。

	我们把 $l \sim r$ 的每一个 $i$ 的增量 $\Delta i=(i-l+1)t$ 拆开，得到 $\Delta i=i\cdot t-(l-1)t$。然后我们由这个式子的可加性，维护一下 $i\cdot t$ 的值就好了。
    
    单次复杂度 $O\left(B+\dfrac{n}{B}\right)$。

2. 交换两个数

	这个比上面那个还简单。
    
    直接交换，然后暴力重构两个数所在的块即可。单次复杂度 $O(B)$。
    
3. 维护最大值

	这算是本题的难点了。首先，在一开始可以直接预处理一下。
    
    然后考虑修改的时候，分成散块和整块。
    
    - 散块显然可以直接暴力修改、暴力计算。
    
    - 整块不太好处理，但是观察到 $t \geq 0$，也就意味着对于任意的 $x_1,x_2 \in [l,r],x_1 \leq x_2$，有 $x_2t-x_1t \geq 0$。
    
    
    	这个式子说明了什么呢？这说明一个块内如果是整块加，那么后面的数的增量一定大于前面的数的增量。那么显然最大值只可能向后延伸，即具有单调性。
        
        可以二分然后平衡复杂度，是 $O(n\sqrt{n\log n})$ 的；但是我们可以考虑单调栈维护每个块的上凸壳，然后记录一个最大值指针 $pos_i$，每次向后移动。可以证明这样复杂度是 $O(n\sqrt{n})$ 的（见后文）。
        
于是本题就做完了。块长取 $\sqrt{n}$ 时复杂度为 $O(n\sqrt{n})$。

- **关于移动复杂度的证明**

显然一个块的上凸壳最多有块长个元素，即 $\sqrt{n}$ 个。那么容易发现，每个块如果不重构的情况下，总移动复杂度是 $O\left(\sqrt{n} \cdot \dfrac{n}{\sqrt{n}}\right) = O(n)$ 的。

考虑现在一个块如果重构了，那么显然指针会移回最左边重新往右跑，也就是说复杂度会加上最多 $\sqrt{n}$。

那么会重构多少个块呢？

考虑操作 $1$，每次最多产生两个散块重构。

考虑操作 $2$，每次也是最多产生两个。

所以总的重构数量是 $O(n)$ 的（准确来说是 $O(q)$ 的，但是 $n,q$ 同级。总复杂度也就是 $O(n \sqrt{n})$ 了。

不过这个只是最劣复杂度分析，实际上应该跑的还是蛮快的，毕竟指针移动一般跑不太满。

---


# [SDOI2012] 象棋

## 题目描述

小云和小南两姐妹从小喜欢下象棋，现在作为象棋高手的她们，已经不屑于玩平常的象棋了，于是她们便开始用棋盘和棋子玩各种各样的新游戏。

今天天气晴朗，阳光明媚，她们将在 $n\times m$ 的棋盘上进行游戏。

棋盘上有 $k$ 颗棋子和若干有障碍格子，令棋盘左上角格子坐标为 $(1,1)$，右下角格子坐标为 $(n,m)$，参数 $a,b$ 规定了所有棋子的走法：在 $(x, y)$ 的棋子下一步能走到 $(x + a, y + b), (x + a, y - b), (x - a, y + b), (x - a, y - b), (x + b, y + a), (x + b, y - a), (x - b, y + a), (x - b, y - a)$ 这八个格子中的一个，棋子任何时候不能跃出棋盘或走到有障碍的格子上。

这 $k$ 颗棋子是相同的，小云和小南的目标是用最少步数把所有棋子移动到特定格子，要求移动过程中不能出现多颗棋子同时在某一格的情况。

她们已经想出步数较少方案，但无法确定这是否为最少步数，所以向作为程序员的你求助。

## 说明/提示

【样例说明】

一可行方案如下：第二颗棋子向右跳两步，随后第一颗棋子向右跳两步，共 $4$ 步。值得注意的是，第一颗棋子向右跳三步，随后第二颗棋子向右跳一步的方案尽管能把棋子都移动到目标位置，但途中两颗棋子曾经同时在 $(1, 3)$，违反了规则，所以不能选用此方案。


数据范围

其中 $20\%$ 的数据，$n\times m\le 20$；

另外 $10\%$ 的数据，$n = 1$；

对于 $100\%$ 的数据，$1\le n,m\le 100$，$1\le k\le 500$。

## 样例 #1

### 输入

```
1 8 2 2 0
.......*
1 1
1 3
1 5
1 7```

### 输出

```
4```

# 题解

## 作者：panyf (赞：3)

KM算法题解。

首先，“不能出现多颗棋子同时在某一格的情况”条件没有用，可以通过调整路径顺序避免这种情况。

考虑预处理所有起始点和目标点的距离，用BFS实现，应该都会吧。之后就是裸的二分图最小权匹配了，求出所有起始点到所有终点的最小权匹配，将边权取相反数直接跑KM即可，此处用BFS版KM保证时间复杂度。总时间复杂度为$O(k^{3}+knm)$，轻松AC。

```cpp
#include<cstdio>
#include<cstring>
const int N=109,M=509;
char mp[N][N];
int d[N][N],qx[N*N],qy[N*N],n,m,k,a,b,sx[M],sy[M],tx[M],ty[M],lx[M],ly[M],sl[M],w[M][M],mt[M],p[M];
bool f[M];
int main(){
	register int i,j,l,x,y,u,v,h,t;
	scanf("%d%d%d%d%d",&n,&m,&k,&a,&b),memset(lx,-9,sizeof(lx));
	register int nx[9]={a,a,-a,-a,b,b,-b,-b},ny[9]={b,-b,b,-b,a,-a,a,-a};
	for(i=1;i<=n;++i)scanf("%s",mp[i]+1);
	for(i=1;i<=k;++i)scanf("%d%d",sx+i,sy+i);
	for(i=1;i<=k;++i)scanf("%d%d",tx+i,ty+i);
	for(i=1;i<=k;++i){
		h=0,t=1,qx[1]=sx[i],qy[1]=sy[i],memset(d,9,sizeof(d)),d[sx[i]][sy[i]]=0;
		while(h!=t){
			u=qx[++h],v=qy[h];
			for(j=0;j<8;++j){
				x=u+nx[j],y=v+ny[j];
				if(x>0&&y>0&&x<=n&&y<=m&&mp[x][y]=='.'&&d[x][y]>1e8)d[x][y]=d[u][v]+1,qx[++t]=x,qy[t]=y;
			}
		}
		for(j=1;j<=k;++j)w[i][j]=-d[tx[j]][ty[j]],lx[i]=lx[i]>w[i][j]?lx[i]:w[i][j];
	}//BFS预处理距离
	for(i=1;i<=k;++i){
		memset(sl,9,sizeof(sl)),memset(f,0,sizeof(f));
		for(mt[j=0]=i;mt[j];j=u){
			f[j]=1,l=1e8,x=mt[j];
			for(y=1;y<=k;++y)if(!f[y]){
				v=lx[x]+ly[y]-w[x][y];
				if(v<sl[y])sl[y]=v,p[y]=j;
				if(l>sl[y])l=sl[y],u=y;
			}
			for(y=0;y<=k;++y)if(f[y])lx[mt[y]]-=l,ly[y]+=l;else sl[y]-=l;
		}
		while(j)mt[j]=mt[p[j]],j=p[j];
	}//KM最小权匹配
	for(l=0,i=1;i<=k;++i)l-=lx[i]+ly[i];
	printf("%d",l);
	return 0;
}
```


---

## 作者：wmy_goes_to_thu (赞：2)

首先，你会发现，对于一种方案，一定有一种调整的办法使得两个棋子任意时刻不在同一点。

你可以考虑感性证明：如果一个人无路可走，那么堵它的人一定可以先走，否则还不如直接停。

所以说，实际上就是给你左边 $k$ 个点，右边 $k$ 个点，任意两点有连边，求一个最大权完美匹配。

显然，`Kuhn-Munkres` 算法是很优的，复杂度为 $O(k^3+knm)$。

这里注意一下，四次方算法可能过不去，需要三次方的 `Kuhn-Munkres` 算法实现，这里我采用 bfs 版本，建议背下来。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long w[505][505],lf[505],rf[505],gp[505];
int pp[505],v[505],z[505],sx[505],sy[505],tx[505],ty[505];
char f[205][205];
int qx[10005],qy[10005],r[105][105],mb[8][2];
int n,m,k,a,b;
void bfs(int x)
{
	int B=0;
	do
	{
		int A=pp[B],dt=B;
		long long d=LLONG_MAX/2;
		v[B]=1;
		for(int cu=1;cu<=k;cu++)
		{
			if(v[cu])continue;
			long long gg=lf[A]+rf[cu]-w[A][cu];
			if(gp[cu]>gg)gp[cu]=gg,z[cu]=B;
			if(d>gp[cu])d=gp[cu],dt=cu;
		}
		lf[x]-=d;
		for(int i=1;i<=k;i++)
		{
			if(v[i])lf[pp[i]]-=d,rf[i]+=d;
			else gp[i]-=d;
		}
		B=dt;
	}while(pp[B]!=0);
	while(B!=0)pp[B]=pp[z[B]],B=z[B];
}
int main()
{
	cin>>n>>m>>k>>a>>b;
	mb[0][0]=a,mb[0][1]=b;
	mb[1][0]=a,mb[1][1]=-b;
	mb[2][0]=-a,mb[2][1]=b;
	mb[3][0]=-a,mb[3][1]=-b;
	mb[4][0]=b,mb[4][1]=a;
	mb[5][0]=b,mb[5][1]=-a;
	mb[6][0]=-b,mb[6][1]=a;
	mb[7][0]=-b,mb[7][1]=-a;
	for(int i=1;i<=n;i++)scanf("%s",f[i]+1);
	for(int i=1;i<=k;i++)scanf("%d%d",&sx[i],&sy[i]);
	for(int i=1;i<=k;i++)scanf("%d%d",&tx[i],&ty[i]);
	for(int i=1;i<=k;i++)
	{
		int head=0,tail=-1;
		tail++;
		qx[tail]=sx[i],qy[tail]=sy[i];
		memset(r,63,sizeof(r));
		r[sx[i]][sy[i]]=0;
		while(head<=tail)
		{
			int px=qx[head],py=qy[head];
			head++;
			for(int d=0;d<8;d++)
			{
				int dx=px+mb[d][0],dy=py+mb[d][1];
				if(dx<1||dy<1||dx>n||dy>m||f[dx][dy]!='.')
					continue;
				if(r[dx][dy]>r[px][py]+1)
				{
					r[dx][dy]=r[px][py]+1;
					tail++;
					qx[tail]=dx,qy[tail]=dy;
				}
			}
		}
		for(int j=1;j<=k;j++)w[i][j]=-r[tx[j]][ty[j]];
	}
	for(int i=1;i<=k;i++)
	{
		memset(v,0,sizeof(v));
		memset(gp,63,sizeof(gp));
		memset(z,0,sizeof(z));
		pp[0]=i,bfs(i);
	}
	long long L=0;
	for(int i=1;i<=k;i++)L-=w[pp[i]][i];
	cout<<L<<endl;
	return 0;
}
```

---

## 作者：lightup37 (赞：1)

关于这道题, 我们可以发现移动顺序不会改变答案, 具体来说, 我们有以下引理成立:

- 对于一个移动过程中的任意一个移动, 若其到达的位置上有一个棋子, 则该方案要么不能将所有棋子移动到最终位置, 要么可以通过改变顺序使这一次移动合法

证明: 

考虑到达位置上的那个棋子, 如果它没有到达最终位置, 则我们考虑将该棋子移至下一步, 如果下一步还有没有到达最终位置的棋子, 则也移动它

否则直接调换这两个棋子的移动顺序即可

好的我们去除了题目中的要求: 「移动过程中不能出现多颗棋子同时在某一格的情况」, 接下来考虑题目被我们转化成了什么样子:

给定$k$个起始点和它们到达$k$个终点的步数, 求一种移动方案, 使得这种移动方案能将所有起始点移动到终点(保证有方案), 其次使得所花费的步数最少.

于是我们把这道题目转化为了一个费用流问题, 具体的, 我们建立超级源点$S$, 超级汇点$T$, 接下来连接三类边

1. $S\rightarrow$所有起始点, 这类边容量为1, 费用为0

2. 每一个起始点$\rightarrow$每一个它能够到达的终点, 这类边容量为1, 费用为所消耗的步数

3. 所有终点$\rightarrow T$, 这类边容量为1, 费用为0

~~在新图上跑费用流即可AC~~

要是这道题有这么简单就好了

如果你使用了一般的EK+SPFA, 你会像我这样:

![](https://cdn.luogu.com.cn/upload/image_hosting/ue09qnc2.png)

接下来我们考虑改进算法, ouuan在[这篇帖子](https://www.luogu.com.cn/discuss/show/161006)中说道:

常见费用流算法(把 Dinic 的 BFS 改成求最短路)复杂度上界是 $O(nmf)$,其中 $f$ 是最大流。

~~于是我们点进了下面的链接学习了那种方法并且AC本题~~

我不会那种方法>\_< 于是使用了Dijkstra跑最短路, 事实上一般的Dijkstra是不能跑的, 但是我在[费用流的题解](https://www.luogu.com.cn/blog/Bartholomew/solution-p3381)中找到了这种神仙做法

如果我讲得不太好可以直接看上面那篇博客 /kel

具体来说, 我们定义势函数$h(i)$使得$e'(u,v)=e(u,v)+h(u)-h(v)$, 最后对最短路的影响可以强行考虑掉, 且$e'(u,v)$恒非负, 就可Dijkstra了

接下来我们发现$h(i)=mindis(u)$是成立的, 但那样的话你还要跑SPFA求最短路

因此我们转而考虑$h(i)=mindis_{round-1}(u)$, 其中$mindis_{round-1}(u)$指上一次增广时$S \rightarrow u$的最短路(不存在为0), 我们发现这也是成立的, 具体来说, 我们考虑每条边$e(u,v)$.

- 若$e(u,v)$在上一次增广时存在, 那么显然满足性质
- 否则$e(u,v)$在最短路上, 也可证明$e'(u,v) \geq 0$

于是我们的势算法成立, 用Dijkstra替换SPFA即可在luogu上AC本题

```cpp
#pragma GCC diagnostic error "-std=c++11"
#pragma GCC target("avx")
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#pragma GCC optimize("-fgcse")
#pragma GCC optimize("-fgcse-lm")
#pragma GCC optimize("-fipa-sra")
#pragma GCC optimize("-ftree-pre")
#pragma GCC optimize("-ftree-vrp")
#pragma GCC optimize("-fpeephole2")
#pragma GCC optimize("-ffast-math")
#pragma GCC optimize("-fsched-spec")
#pragma GCC optimize("unroll-loops")
#pragma GCC optimize("-falign-jumps")
#pragma GCC optimize("-falign-loops")
#pragma GCC optimize("-falign-labels")
#pragma GCC optimize("-fdevirtualize")
#pragma GCC optimize("-fcaller-saves")
#pragma GCC optimize("-fcrossjumping")
#pragma GCC optimize("-fthread-jumps")
#pragma GCC optimize("-funroll-loops")
#pragma GCC optimize("-fwhole-program")
#pragma GCC optimize("-freorder-blocks")
#pragma GCC optimize("-fschedule-insns")
#pragma GCC optimize("inline-functions")
#pragma GCC optimize("-ftree-tail-merge")
#pragma GCC optimize("-fschedule-insns2")
#pragma GCC optimize("-fstrict-aliasing")
#pragma GCC optimize("-fstrict-overflow")
#pragma GCC optimize("-falign-functions")
#pragma GCC optimize("-fcse-skip-blocks")
#pragma GCC optimize("-fcse-follow-jumps")
#pragma GCC optimize("-fsched-interblock")
#pragma GCC optimize("-fpartial-inlining")
#pragma GCC optimize("no-stack-protector")
#pragma GCC optimize("-freorder-functions")
#pragma GCC optimize("-findirect-inlining")
#pragma GCC optimize("-fhoist-adjacent-loads")
#pragma GCC optimize("-frerun-cse-after-loop")
#pragma GCC optimize("inline-small-functions")
#pragma GCC optimize("-finline-small-functions")
#pragma GCC optimize("-ftree-switch-conversion")
#pragma GCC optimize("-foptimize-sibling-calls")
#pragma GCC optimize("-fexpensive-optimizations")
#pragma GCC optimize("-funsafe-loop-optimizations")
#pragma GCC optimize("inline-functions-called-once")
#pragma GCC optimize("-fdelete-null-pointer-checks")
#include<bits/stdc++.h>
using namespace std;
namespace mcmf {
	const int N=1002; const int M=500*502*2+1; const int inf=0x3f3f3f3f;
    int tot = 1, head[N], Next[M * 2], ver[M * 2], edge[M * 2], cost[M * 2];
    int dis[N], h[N], lst[N], pre[N], C, n;
	#define pi pair<int,int>
    inline void _add(int u, int v, int c, int w) {
        Next[++tot] = head[u], head[u] = tot, ver[tot] = v, edge[tot] = c, cost[tot] = w;
    }
    inline void add(int u, int v, int c, int w) {
        _add(u, v, c, w), _add(v, u, 0, -w);
    }
    void Dijkstra(int s) {
    	priority_queue<pi, vector<pi>, greater<pi> > q;
        for(; !q.empty(); q.pop());
        fill(dis, dis + 1 + n, -1);
        dis[s] = 0, q.push(pi(0, s));
        while(!q.empty()) {
            pi now = q.top(); q.pop();
            int u = now.second;
            if(dis[u] < now.first) continue;
            for(int i = head[u]; i; i = Next[i]) {
                static int v; v = ver[i];
                if(!edge[i]) continue;
                if(dis[v] < 0 || dis[v] > dis[u] + cost[i] + h[u] - h[v]) {
                    dis[v] = dis[u] + cost[i] + h[u] - h[v];
                    pre[v] = u, lst[v] = i;
                    q.push(pi(dis[v], v));
                }
            }
        }
    }
    int solve(int s, int t) {
        memset(h,0,sizeof(h)); int d=inf;
        while(1){
            Dijkstra(s); if(dis[t] < 0) break;
            for(register int i = 1; i <= n; ++i) h[i] += (dis[i] != -1) ? dis[i] : 0; d=inf;
            for(int u = t; u != s; u = pre[u]) edge[lst[u]]<d && (d=edge[lst[u]]); C += h[t] * d;
            for(int u = t; u != s; u = pre[u]) edge[lst[u]] -= d, edge[lst[u] ^ 1] += d;
        } 
		return C;
    }
}
const int _=501,__=101;
int n,m,k,a,b;
int un[__][__],dis[__][__];
struct pos{
	int x,y;
}st[_], ed[_];
queue<pos> Q;
int dx[8]={1,1,-1,-1,1,1,-1,-1}, dy[8]={1,-1,1,-1,1,-1,1,-1};
#define in(a) (a.x>=1 && a.x<=n && a.y>=0 && a.y<=m && !un[a.x][a.y])
void getdis(int s){
	Q.push(st[s]); dis[st[s].x][st[s].y]=0; pos x; int d;
	while(!Q.empty()){
		x=Q.front(); d=dis[x.x][x.y]; Q.pop();
		for(int i=0;i<8;++i){
			x.x+=dx[i]; x.y+=dy[i];
			(dis[x.x][x.y]==-1) && in(x) && (Q.push(x),dis[x.x][x.y]=d+1);
			x.x-=dx[i]; x.y-=dy[i];
		}
	}
}
char get(){char c=getchar(); while(c!='*' && c!='.') c=getchar(); return c;}
int main(){
	scanf("%d%d%d%d%d",&n,&m,&k,&a,&b); 
	for(register int i=1;i<=n;++i) for(int j=1;j<=m;++j) {
		char ch=get(); un[i][j]=(ch=='*');
	}
	for(register int i=0;i<4;++i) dx[i]*=a,dy[i]*=b;
	for(register int i=4;i<8;++i) dx[i]*=b,dy[i]*=a;
	for(register int i=1;i<=k;++i) scanf("%d%d",&st[i].x,&st[i].y);
	for(register int i=1;i<=k;++i) scanf("%d%d",&ed[i].x,&ed[i].y);
	for(register int i=1;i<=k;++i) {
		memset(dis,-1,sizeof(dis)); getdis(i);
		for(int j=1;j<=k;++j) if(dis[ed[j].x][ed[j].y]!=-1) mcmf::add(i+1,j+k+1,1,dis[ed[j].x][ed[j].y]);
	}
	for(int i=1;i<=k;++i) mcmf::add(1,i+1,1,0),mcmf::add(i+k+1,2*k+2,1,0);
	mcmf::n=2*k+2; printf("%d\n",mcmf::solve(1,2*k+2));
}
```

---


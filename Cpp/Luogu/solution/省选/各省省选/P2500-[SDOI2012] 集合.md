# [SDOI2012] 集合

## 题目描述

小H在学习“集合与图论”的时候遇到了一个问题，他思考了很久依然无法很好完成这个问题。于是他只好来求助你了，给出n个点m条边的带权无向图（即每条无向边上都有一个权值），有3个集合A、B、C。一开始无向图中所有点都属于A集合，有如下9种操作：

MoveA x：表示将第x个点从所在集合中删除，并加入至A集合。

MoveB x：表示将第x个点从所在集合中删除，并加入至B集合。

MoveC x：表示将第x个点从所在集合中删除，并加入至C集合。

AskAA：询问两个端点都属于A集合的所有边中最小的权值是多少。

AskAB：询问两个端点分别属于A集合和B集合的所有边中最小的权值是多少。

AskAC：询问两个端点分别属于A集合和C集合的所有边中最小的权值是多少。

AskBB：询问两个端点都属于B集合的所有边中最小的权值是多少。

AskBC：询问两个端点分别属于B集合和C集合的所有边中最小的权值是多少。

AskCC：询问两个端点都属于C集合的所有边中最小的权值是多少。

你能帮助他解决这个问题吗？


## 说明/提示

数据范围

对于其中20%的数据，满足n<=50, m<=2500, q<=2500。

对于另外30%的数据，满足n<=100, m<=10000, q<=20000。

对于另外50%的数据，满足n<=100000,m<=500000,q<=100000。且无向图上任意两个点之间至多能选出3条不相交的路径。


## 样例 #1

### 输入

```
4 3
1 2 1 
2 3 2
3 1 3
5
AskAA
AskAB
MoveB 2
AskAA
AskAB```

### 输出

```
1
No Found!
3
1```

# 题解

## 作者：一念之间、、 (赞：15)

看到两篇题解都是用暴力的方法过的，这个数据真的是比较水，这里提供一个严格复杂度的做法：

考虑两种暴力，

一种是改点时对于每条与它相连边都进行更改（询问快）

一种是在询问的时候考虑暴力枚举边更新答案（修改快）

考虑度数分治，发现度数大于$\sqrt n$的只会最多有$\sqrt n$个考虑将这根号个作为关键点（建立关键点与关键点之间的边）

在非关键点的时候，我们考虑开6个`set`维护`AA,AB,AC,CC,BC,CC`的情况(边权排序)

在关键点的时候，分别对每个关键点开三个`set`维护与它相连的三个颜色

讨论修改，当改一个非关键点，则我们暴力枚举它的所有边，若枚举到的另外一个点是非关键点，则在外边6个`set`里面改，否则对于另外一个点的关键点内部`set`进行修改

若当前改一个关键点，我们枚举关键点与关键点之间的边（因为关键点只有$\sqrt n$个，所以复杂度也是$\sqrt n$）对于另外一个关键点进行修改。

考虑询问，对于非关键点之间的边考虑在外部`set`查询，然后枚举每个关键点，查询以这个关键点和另外颜色边的最小值。

复杂度$O(n\sqrt nlogm)$是不是感觉这个`3s`跑不怎么下?

首先这个log跑不满，因为一共只有2m个点加入set，所以算小常数

而且题目保证：无向图上任意两个点之间至多能选出3条不相交的路径。

所以不会出现边全部集中在一堆的情况，也就是卡不掉，实测不开`O2`跑1秒

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int read()
{
	char c;
	int w=1;
	while((c=getchar())>'9'||c<'0')if(c=='-')w=-1;
	int ans=c-'0';
	while((c=getchar())>='0'&&c<='9')ans=(ans<<1)+(ans<<3)+c-'0';
	return ans*w;
}
int n,m;
const int xx=1e5+5;
struct node
{
	int next,to,v;
}e[xx*10];
int cnt;
int h[xx],ds[xx],vis[xx],val[xx*5],uu[xx*5],vv[xx*5];
void add(int x,int y,int z)
{
	cnt++;
	e[cnt].next=h[x];
	h[x]=cnt;
	e[cnt].to=y;
	e[cnt].v=z;
	ds[y]++;
}
node w[xx*5];
int hh[xx];
int cntt;
void add1(int x,int y,int z)
{
	cntt++;
	w[cntt].next=hh[x];
	hh[x]=cntt;
	w[cntt].to=y;
	w[cntt].v=z;
}
int id[xx*5],bel[xx];
bool cmp(int x,int y){return ds[x]>ds[y];}
struct nod
{
	int x;
	nod(){}
	nod(int a):x(a){}
	bool operator<(const nod&w)const{return x<w.x;}//只加入边权 
};
int to[4][4],ts[xx];
struct no
{
	multiset<nod>s[4];
	int get(int id)
	{
		if(!s[id].size())return 2147483647;
		return (*s[id].begin()).x;
	}
	void add(int x,int op,int id)
	{
		if(op==-1)s[id].erase(s[id].find(nod(x)));
		else s[id].insert(nod(x));
	}
}t[351];
multiset<nod>s[7];
int get(int id)
{
	if(!s[id].size())return 2147483647;
	return (*s[id].begin()).x;
}
void adds(int x,int op,int id)
{
	if(op==-1)s[id].erase(s[id].find(nod(x)));
	else s[id].insert(nod(x));
}
//用set存，和个数有关 
int main(){
	to[1][1]=1;
	to[1][2]=to[2][1]=2;
	to[1][3]=to[3][1]=3;
	to[2][2]=4;
	to[2][3]=to[3][2]=5;
	to[3][3]=6;
	n=read();
	m=read();
	for(int i=1;i<=n;i++)bel[i]=1;
	for(int i=1;i<=m;i++)
	{
		id[i]=i;
		int a,b;
		a=uu[i]=read();
		b=vv[i]=read();
		val[i]=read();
		add(a,b,val[i]);
		add(b,a,val[i]);
	}
	sort(id+1,id+m+1,cmp);
	for(int i=1;i<=min(350,n);i++)vis[id[i]]=1,ts[id[i]]=i;
	for(int i=1;i<=m;i++)
	{
		int a=uu[i],b=vv[i];
		if(vis[a]&&vis[b])add1(a,b,val[i]),add1(b,a,val[i]),t[ts[a]].add(val[i],1,1),t[ts[b]].add(val[i],1,1);
		else if(!vis[a]&&!vis[b])adds(val[i],1,1);
		else 
		{
			if(vis[a])swap(a,b);//visa=0visb=1
			t[ts[b]].add(val[i],1,1);
		}
	}
	int q=read();
	for(int aa=1;aa<=q;aa++)
	{
		char s[10];
		scanf("%s",s);
		if(s[0]=='A')
		{
			int a=s[3]-'A'+1,b=s[4]-'A'+1;
			int minn=get(to[a][b]);
			for(int i=1;i<=min(350,n);i++)
			{
				if(bel[id[i]]!=a&&bel[id[i]]!=b)continue;
				minn=min(minn,t[i].get((bel[id[i]]==a)?b:a));
			}
			if(minn==2147483647)puts("No Found!");
			else cout<<minn<<"\n";
		}
		else //s[4]
		{
			int x=read();
			int a=s[4]-'A'+1;
			if(bel[x]==a)continue;
			if(vis[x])
			{
				for(int i=hh[x];i;i=w[i].next)
				{
					t[ts[w[i].to]].add(w[i].v,-1,bel[x]);
					t[ts[w[i].to]].add(w[i].v,1,a);
				}
			}
			else 
			{
				for(int i=h[x];i;i=e[i].next)
				{
					if(vis[e[i].to])
					{
						t[ts[e[i].to]].add(e[i].v,-1,bel[x]);
						t[ts[e[i].to]].add(e[i].v,1,a);
					}
					else 
					{
						adds(e[i].v,-1,to[bel[x]][bel[e[i].to]]);
						adds(e[i].v,1,to[a][bel[e[i].to]]);
					}
				}
			}
			bel[x]=a;
		}
	}
	return 0;
}
/*
A 1  AA 1  BB 4 
B 2  AB 2  BC 5
C 3  AC 3  CC 6
*/
```


---

## 作者：Peanut_Tang (赞：5)

### 题解

这题作为一个省选题，数据强度感人。

这题的正解前 $50\%$ 复杂度为 $O(m+qn\log{m})$，后 $50\%$ 的复杂度为 $O(m+q\log{n})$。但是一方面数据实在太水，一方面近十年来评测机的速度加了不少，十年前也没有 `O2`，导致：

- 当时边不排序的 $O(qm)$ 暴力只能得到 $20$ 分，现在可以得到 $50$ 分。
- 边排序的 $O(qm)$ 暴力照常理也应该只得 $20$ 分（以现在的评测机速度最多 $50$ 分），但实际上不管在当时还是现在都可以拿到 $100$ 分，并且运行时间暴打正解。
- 复杂度为 $O(m+q\sqrt[]{n}\log{m})$ 的做法应该只能得到 $50$ 分，但是现在的评测机实在是太快了，所以得到了 $100$ 分。

这里把官方题解给一下，实际上在[这道题的讨论](https://www.luogu.com.cn/discuss/37942)中就有，但是在讨论中实在是太不显眼了，故我在题解里再写一遍。

对于前 $50\%$ 的部分，$O(qm)$ 暴力是显然的。但实际上我们完全可以开 $6$ 个堆动态维护每两两集合间的答案，这样我们就得到了 $O(m+qn\log{m})$ 的做法。当然，你可以像[这篇题解](https://www.luogu.com.cn/blog/fzwde/solution-p2500)一样对点的度数分类讨论，根据根号分类的传统艺能得到 $O(m+q\sqrt[]{n}\log{m})$ 的做法，但这对提高分数没有帮助。

重点是后 $50\%$ 的数据，他给了一个特殊性质：  
无向图上任意两个点之间至多能选出 $3$ 条不相交的路径。

我们来思考这个性质代表的是什么，可以证明至多产生 $3$ 片生成森林。

> **证明（搬自上面的讨论）：**  
> 对于一片生成森林，如果两个点在同一个树上，则他们在树上的路径可以看成是一条增广路。如果将这片森林删除，则这些点之间的最大流至少减 $1$，那么三次之后，任意两点的最大流都为 $0$，即所有边都没了。  
> $\Box$

这意味着什么呢？我们只需要解决树（森林）的问题，然后把三个答案取个 $\min$ 就好了。

考虑树上怎么做，对于父亲边，可以直接暴力改。对于儿子边，我们发现只有每个集合最小的那条边有用，这也是常数级的。注意此时对于父亲，“每种集合最小的儿子”可能被改了，要判。

这些操作可以用 `bfs` 序（父亲和儿子在 `bfs` 序上是连续的）+ 线段树、或者可删除堆、或者 `multiset` 维护。只不过当时应该是 `Pascal`，所以 `multiset` 不能用，堆也要手写就是了。但是本人比较懒，用了 `multiset`。

修改和查询的复杂度都是 $O(\log{n})$ 的，所以总复杂度为 $O(m+q\log{n})$ 的。

### Code

```cpp
#include <bits/stdc++.h>
#define il inline

int n,m,q; char z[9];

il int Id(int x,int y){if (x>y) std::swap(x,y); return x?(x<2?2+y:3+y):y;}

namespace Sub1
{
    const int N=105;
    
    int b[N],g[N][N]; struct node{int x,y; il friend bool operator < (node x,node y){return g[x.x][x.y]>g[y.x][y.y];}}; std::priority_queue<node> h[6];

    il void main()
    {
        int u,v,w; node x; while (m--) scanf("%d%d%d",&u,&v,&w),(!g[u][v]||g[u][v]>w)&&(g[u][v]=g[v][u]=w);
        for (u=1; u<=n; u++) for (v=1; v<=n; v++) if (g[u][v]) h[0].push({u,v});
        for (scanf("%d",&q); q; q--)
            if (scanf("%s",z),z[0]=='M')
            {
                scanf("%d",&u),b[u]=z[4]-65;
                for (v=1; v<=n; v++) if (g[u][v]) h[Id(b[u],b[v])].push({u,v});
            }
            else
            {
                for (u=Id(z[3]-65,z[4]-65); h[u].size(); h[u].pop())
                    if (x=h[u].top(),Id(b[x.x],b[x.y])==u){printf("%d\n",g[x.x][x.y]); break;}
                if (!h[u].size()) puts("No Found!");
            }
    }
}

namespace Sub2
{
    const int N=1e5+5,M=10*N;

    int b[N],to[M],nx[M],wt[M],hd[N],sze=1; std::multiset<int> S[6]; bool o[N],O[M];
    struct TREE
    {
        int fa[N],fv[N]; std::multiset<int> s[N][3];

        il void Dfs(int u)
        {
            o[u]=1; int i,v;
            for (i=hd[u]; i; i=nx[i]) if (!o[v=to[i]]&&!O[i>>1])
                O[i>>1]=1,fa[v]=u,fv[v]=wt[i],Dfs(v);
        }

        il void Init()
        {
            memset(o,0,n+1); int i;
            for (i=1; i<=n; i++) if (!fa[i]) Dfs(i);
            for (i=1; i<=n; i++) if (fa[i]) s[fa[i]][0].insert(fv[i]);
            for (i=1; i<=n; i++) if (s[i][0].size()) S[0].insert(*s[i][0].begin());
        }

        il void Chg(int c,int x)
        {
            if (b[x]==c) return; int i,j;
            if (fa[x])
            {
                for (i=0; i<3; i++) if (s[fa[x]][i].size()) j=Id(b[fa[x]],i),S[j].erase(S[j].find(*s[fa[x]][i].begin()));
                s[fa[x]][b[x]].erase(s[fa[x]][b[x]].find(fv[x])),s[fa[x]][c].insert(fv[x]);
                for (i=0; i<3; i++) if (s[fa[x]][i].size()) S[Id(b[fa[x]],i)].insert(*s[fa[x]][i].begin());
            }
            for (i=0; i<3; i++) if (s[x][i].size()) j=Id(b[x],i),S[j].erase(S[j].find(*s[x][i].begin())),S[Id(c,i)].insert(*s[x][i].begin());
        }
    }T[3];

    il void Add(int u,int v,int w){to[++sze]=v,nx[sze]=hd[u],wt[sze]=w,hd[u]=sze;}

    il void main()
    {
        int u,v,w; while (m--) scanf("%d%d%d",&u,&v,&w),Add(u,v,w),Add(v,u,w);
        for (w=0; w<3; w++) T[w].Init();
        for (scanf("%d",&q); q; q--)
            if (scanf("%s",z),z[0]=='M') scanf("%d",&u),w=z[4]-65,T[0].Chg(w,u),T[1].Chg(w,u),T[2].Chg(w,u),b[u]=w;
            else S[w=Id(z[3]-65,z[4]-65)].size()?(printf("%d\n",*S[w].begin())):(puts("No Found!"));
    }
}

int main()
{
    scanf("%d%d",&n,&m);

    if (n<101) Sub1::main(); else Sub2::main();

    return 0;
}
```

---

## 作者：Targanzqq (赞：0)

特别提醒：这个题必须判重边！必须判！

### 思路：根号分治+暴力维护

我们考虑到每次修改，都要涉及与自己连边的点，因此我们自然想到对点的度数进行根号分治。

经典的小块暴力：我们在修改度数小于阈值 $B$ 的点时，可以直接把边都扫一遍，然后直接修改，这些点我们称为小点。

同样经典的大块特殊性质：度数大于 $B$ 的点只有 $\frac{m}{B}$ 个，因此我们可以维护这 $\frac{m}{B}$ 个点之间的关系。这些点我们称为大点。

具体维护方案：

- 修改小点，涉及小点：开 $6$ 个 multiset，维护这些边的边权，每次修改就通过找点找到边权，然后修改这条边存在的集合。

- 修改小点，涉及大点：每个大点开 $6$ 个 $multiset$ 维护每种颜色连接的点的编号和它们之间的边权，然后我们在找到的大点中修改编号和边权所在的集合。

- 修改大点：我们修改大点所在的集合时，只能对其他大点有影响，因此我们枚举其他大点，如果相连，则修改当前被修改的点及它们之间的边权在这个点所包含的集合中的位置。

时间复杂度 $O(B\log m+\frac{m}{B}\log m)$。

查询方案：
- 查询小点之间：直接从对应集合中找最小边权即可

- 查询与大点相连的边：枚举每个合法大点所对应的另一个集合，答案对这个集合中边权最小的边取 $\min$。

时间复杂度 $O(n/B)$。

取 $B=\sqrt m$ 时，总时间复杂度为 $O(q\sqrt m\log m)$，可以通过此题。

### 细节补充
一开始说到的重边问题，如果有多条重边可能在修改点的时候要全部移动，但是我们取最小的话一定有最优解，所以我们可以处理成对多条重边取最小。

### 源代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define N 100005
#define mp make_pair
#define fi first
#define se second
using namespace std;

int n,m,q,ix[N],id[N];
map<int,int> g[N];
vector<int> gd[N],ik;
multiset<int> t[3][3];
multiset<int> in[N][3];
multiset<int> e[N][3];

signed main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int u,v,w;
		cin>>u>>v>>w;
		int lst=g[u][v];
		if(!lst){
			g[u][v]=w;
			g[v][u]=w;
		    t[0][0].insert(w);
	    }
	    else{
	    	g[u][v]=min(lst,w);
			g[v][u]=min(lst,w);
		    t[0][0].erase(t[0][0].find(lst));
		    t[0][0].insert(min(lst,w));
		}
	}
	int lim=sqrt(m);
	//cout<<lim;
	for(int i=1;i<=n;i++){
		if(g[i].size()>lim){
			id[i]=1;ik.push_back(i);
		}
	}
	for(int i=1;i<=n;i++){
		if(id[i]){
			for(auto k:g[i]){
				int j=k.fi,v=k.se;
				if(j>i&&id[j]||!id[j])t[0][0].erase(t[0][0].find(v));
				in[i][0].insert(j);
				e[i][0].insert(v);
				if(id[j])gd[i].push_back(j);
			}
		}
	}
	cin>>q;
    for(int x=1;x<=q;x++){
    	string s;int i;
    	cin>>s;
    	if(s[0]=='M'){
    		cin>>i;int to=s[4]-'A';
    		if(!id[i]){
    			for(auto k:g[i]){
    				int j=k.fi,v=k.se;
    				if(id[j]){
    					in[j][ix[i]].erase(in[j][ix[i]].find(i));
    					e[j][ix[i]].erase(e[j][ix[i]].find(v));
    					in[j][to].insert(i);
    					e[j][to].insert(v);
					}
    				if(!id[j]){
	    				int l1=min(ix[i],ix[j]),l2=max(ix[i],ix[j]);
	    				int l3=min(to,ix[j]),l4=max(to,ix[j]);
	    				t[l1][l2].erase(t[l1][l2].find(v));
						t[l3][l4].insert(v);
				    }
				}
			}
			if(id[i]){
				for(auto j:gd[i]){
					if(!id[j])continue;
					in[j][ix[i]].erase(in[j][ix[i]].find(i));
    				e[j][ix[i]].erase(e[j][ix[i]].find(g[i][j]));
    				in[j][to].insert(i);
    				e[j][to].insert(g[i][j]);
				}
			}
			ix[i]=to;
	    }
	    if(s[0]=='A'){
	    	int p1=s[3]-'A',p2=s[4]-'A',ans=1145141919810;
	    	if(t[p1][p2].size())ans=*t[p1][p2].begin();
	    	for(auto i:ik){
	    		if(ix[i]!=p1)continue;
	    		if(e[i][p2].size())ans=min(ans,*e[i][p2].begin());
			}
			for(auto i:ik){
	    		if(ix[i]!=p2)continue;
	    		if(e[i][p1].size())ans=min(ans,*e[i][p1].begin());
			}
			if(ans==1145141919810)cout<<"No Found!";
			else cout<<ans;
			cout<<"\n";
		}
	}
}

```

---

## 作者：_XHY20180718_ (赞：0)

看到有一堆迷惑且数据结构貌似不可做的题，优先考虑根号分治和哈希（也可能是题目本身的神秘性质？）。

对于本题，我们考虑对点的度数根号分治，记 $du_u$ 表示 $u$ 点的度数，$du_u > B$ 的点记为重点，其于记为轻点。

考虑如何进行修改操作：

移动轻点时（以```MoveB u```为例，$u$ 原来在 $A$ 集合）：

由于 $du_u\leq B$，所以我们可以遍历 $u$ 的出边，设对面的点为 $v$ 以及这条边的权值为 $w$。

若 $v$ 轻点，找出 $v$ 的集合 $S$，我们用可删堆（优先队列 + map）维护集合与集合之间的答案（仅考虑轻点），此时 $A-S$ 的可删堆减去 $w$ 的答案，$B-S$ 的可删堆加上 $w$ 的答案，复杂度 $O(\sqrt n\log m)$；

若 $v$ 为重点，则用可删堆维护此节点到三个集合之间权值的答案，此时 $v-A$ 的可删堆减去 $w$ 的答案，$v-B$ 的可删堆加上 $w$ 的答案，最后改变 $u$ 所在集合，复杂度 $O(\sqrt n\log m)$。

```cpp
  if(du[u]<=B)
    for(int v:G[u]){
      w=egw[lfx(u,v)];
      if(du[v]<=B)++mps[calc(S[v],S[u])][w],qs[calc(S[v],ss)].push(w);
      else ++mp[v][S[u]][w],qu[v][ss].push(w);
    }
}
```
移动重点时（以```MoveB u```为例，$u$ 原来在 $A$ 集合）：

由于 $du_u>B$ 所以我们不能遍历其出边，但我们可以枚举所有重点，如果此重点 $v$ 与 $u$ 有连边，那么我们可以考虑改变 $u$ 对 $v$ 的贡献，具体和移动轻点时同理，复杂度 $O(\sqrt n\log m)$。
```cpp
else for(int v:ZD)
  if(egw.find(lfx(u,v))!=egw.end()){
    w=egw[lfx(u,v)];//lfx(u,v) 表示集合 u 与集合  v 之间的轻点连边贡献
    ++mp[v][S[u]][w];
    qu[v][ss].push(w);
  }
```
接下来考虑询问：

我们既要考虑轻点与轻点之间的边对答案的贡献（即维护集合与集合之间的可删堆），也要考虑重点与其他点之间的贡献（即维护重点与集合之间的可删堆），直接先访问集合与集合之间的可删堆，再遍历重点，询问重点与集合之间的可删堆即可，复杂度 $O(B\log m)$。
```cpp
if(op[0]=='A'){
  s1=op[3]-'A',s2=op[4]-'A',tt=calc(s1,s2);res=inf;
  if(!qs[tt].empty()){
    while(mps[tt][qs[tt].top()])
      --mps[tt][qs[tt].top()],qs[tt].pop();
    if(!qs[tt].empty())res=qs[tt].top();
  }
  for(int u:ZD){
    if(S[u]==s1){
      if(!qu[u][s2].empty()){
        while(mp[u][s2][qu[u][s2].top()])
          --mp[u][s2][qu[u][s2].top()],qu[u][s2].pop();
        if(!qu[u][s2].empty())res=min(res,qu[u][s2].top());
      }
    }
    if(S[u]==s2){
      if(!qu[u][s1].empty()){
        while(mp[u][s1][qu[u][s1].top()])
          --mp[u][s1][qu[u][s1].top()],qu[u][s1].pop();
        if(!qu[u][s1].empty())res=min(res,qu[u][s1].top());
      }
    }
  }
  if(res>=inf)cout<<"No Found!\n";
  else cout<<res<<'\n';
}
```
剩下就是预处理的部分，按照需要维护的信息模拟即可：

```cpp
for(int i=1; i<=m; ++i){
  cin>>u>>v>>w;
  ++du[u],++du[v];
  G[u].push_back(v),G[v].push_back(u);
  if(egw.find(lfx(u,v))!=egw.end())
    egw[lfx(u,v)]=min((egw[lfx(u,v)]),w);
  else egw[lfx(u,v)]=w;
}
for(auto it:egw){
  int u=it.xx.xx,v=it.xx.yy,w=it.yy;
  if(du[u]<=B&&du[v]<=B)qs[0].push(w);
  if(du[u]>B)qu[u][0].push(w);
  if(du[v]>B)qu[v][0].push(w);
}
for(u=1; u<=n; ++u)
  if(du[u]>B)ZD.push_back(u);
```
复杂度：$O(n+m\log m)$

那么这题我们就做完了，总复杂度：$O(n+m\log m+q\sqrt n\log m)$。

---

## 作者：Na2PtCl6 (赞：0)

## Definition
- 我们称度数大于 $\sqrt n$ 的点为关键点，否则称为非关键点。

- 令 $Sig_{i,j}(j\in \lbrace A,B,C\rbrace)$ 表示对于关键点 $i$ 作为端点的边中，另一个端点在 $A$ 或 $B$ 或 $C$ 集合中的边集合。

- 我们称 $AA,AB,BC$ 这样的表示法为一种边跨集合的关系。

- 令 $Ord_i(i\in \lbrace AA,BB,CC,AB,BC,AC\rbrace)$ 表示对于跨集合关系 $i$，两个端点都是非关键点的边集合。

## Observation

### Modification

令修改的点为 $p$。

#### 1.For significant points

注意到 $Sig_{p}$ 不变，所以我们只用考虑与 $p$ 相连的关键点，令这些点为 $s_1,s_2,\dots ,s_k$ 则 $Sig_{s_i}(i\in [1,k])$ 中，$p$ 从一个集合变到了另一个。

#### 2.For ordinary points
直接枚举出边暴力修改

### Query
先在 $Ord_i$ 里找最小值，然后再到所有关键点的 $Sig$ 里找最小值。

所以我们发现我们需要一个支持插入，删除和求最小值的数据结构，可以用 `set` 实现。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=500004,T=500,inf=0x7fffffff;
char op[maxn],belo[maxn],issig[maxn];
int n,m,q,u,v,w,x;
vector< int > sigp;
struct edge{
	int from,to,wei;
	bool operator < (const edge &comp)const{
		if(wei==comp.wei)
			return from*1000000ll+1ll*to<comp.from*1000000ll+1ll*comp.to;
		return wei<comp.wei;
	}
};
vector< edge > g[maxn],ajsig[maxn];
multiset< edge > ord[10],sig[maxn][3];

int get_code(int a,int b){
	if(a>b)
		swap(a,b);
	return a*3+b;
}

void move1(int ver,int st){
	for(edge i:ajsig[ver]){
		sig[i.to][belo[ver]].erase(i);
		sig[i.to][st].insert(i);
	}
}

void move2(int ver,int st){
	for(edge i:g[ver]){
		int tar=i.to;
		edge j=(edge){tar,ver,i.wei};
		if(!issig[tar]){
			ord[get_code(belo[ver],belo[tar])].erase(i);
			ord[get_code(st,belo[tar])].insert(i);
			
			ord[get_code(belo[ver],belo[tar])].erase(j);
			ord[get_code(st,belo[tar])].insert(j);
		}
		else{
			sig[tar][belo[ver]].erase(j);
			sig[tar][st].insert(j);
		}
	}
}

int query(int sta,int stb){
	int ret=inf,_=get_code(sta,stb);
	if(ord[_].size())
		ret=min(ret,ord[_].begin()->wei);
	for(int i:sigp){
		if(belo[i]==sta&&sig[i][stb].size())
			ret=min(ret,sig[i][stb].begin()->wei);
		if(belo[i]==stb&&sig[i][sta].size())
			ret=min(ret,sig[i][sta].begin()->wei);
	}
	return ret;
}

int main(){
	scanf("%d %d",&n,&m);
	while(m--){
		scanf("%d %d %d",&u,&v,&w);
		g[u].push_back((edge){u,v,w});
		g[v].push_back((edge){v,u,w});
	}
	for(int i=1;i<=n;i++)
		if(g[i].size()>=T){
			issig[i]=1;
			sigp.push_back(i);
			for(edge j:g[i])
				sig[i][0].insert(j);
		}
	for(int i=1;i<=n;i++)
		if(issig[i])
			for(edge j:g[i])
				if(issig[j.to])
					ajsig[i].push_back(j);
	for(int i=1;i<=n;i++)
		if(g[i].size()<T)
			for(edge j:g[i])
				if(!issig[j.to])
					ord[0].insert(j);
	scanf("%d",&q);
	while(q--){
		scanf("%s",op);
		if(op[0]=='M'){
			scanf("%d",&x);
			if(issig[x])
				move1(x,op[4]-'A');
			else
				move2(x,op[4]-'A');
			belo[x]=op[4]-'A';
		}
		else{
			int res=query(op[3]-'A',op[4]-'A');
			if(res==inf)
				puts("No Found!");
			else
				printf("%d\n",res);
		}
	}
	return 0;
}
```

---

## 作者：Hanx16Kira (赞：0)

# [SDOI2012]集合

[Luogu P2500 [SDOI2012]集合](https://www.luogu.com.cn/problem/P2500)

## Solution

容易发现使用一般的数据结构很难维护这类信息，因此先考虑暴力做法，然后对暴力进行优化（下述时间复杂度默认 $n,m,q$ 同阶）。

对于前 $50\%$ 的数据，容易想到对所有可能的询问分别建一个 `set` 维护满足条件的边权。具体来说，就是建 $6$ 个 `set`，分别维护 $A\leftrightarrow A$，$A\leftrightarrow B$，$A\leftrightarrow C$，$B\leftrightarrow B$，$B\leftrightarrow C$，$C\leftrightarrow C$ 的答案，然后对于每次修改直接暴力修改影响的 `set` 内的边权，具体写法很简单，不再赘述。

考虑怎么优化这个暴力。一个很典的 Trick 是将所有点按照**度数**进行根号分治，将度数 $\ge \sqrt{n}$ 的点称为关键点，其余称为非关键点。容易发现，关键点的数目是 $\mathcal O(\sqrt n)$ 级别的。

- 对于非关键点，考虑延续上面部分分的思路，由于每一个点的度数不超过 $\sqrt n$，因此这一部分的边的数目是 $\mathcal O(n\sqrt n)$ 级别的，所以可以同样去维护 $6$ 个 `set` 来记录答案；
- 对于关键点，可以对每一个关键点开 $3$ 个 `set`，表示关键点分别到三个集合的边集。因为关键点的数目是 $\mathcal O(\sqrt n)$ 级别的，因此这部分边的数目也是 $\mathcal O(n\sqrt n)$ 的。

关于修改：

- 对于非关键点，遍历所有出边 $u\to v$，若 $v$ 为关键点，那么修改 $v$ 的 `set`；否则修改 $6$ 个 `set` 的元素；
- 对于关键点，遍历所有可到达的关键点 $v$，修改 $v$ 的 `set`（这部分实现的时候可以先把所有点的出边按照是否是关键点排序，然后所有的出边为关键点的边就会被连续访问到）；
- 两类操作时间复杂度都是 $\mathcal O(\sqrt n\log n)$ 的。

关于询问：

- 先在维护的 $6$ 个 `set` 中查询非关键点间的答案；
- 然后遍历当前集合中的关键点，在关键点的 `set` 中查询答案；
- 第一步时间复杂度 $\mathcal O(\log n)$，第二步时间复杂度 $\mathcal O(\sqrt n\log n)$。

总时间复杂度 $\mathcal O(n\sqrt n\log n)$，常数很小，但是由于数据原因，跑的没有暴力快。

代码实现上注意一下判断 `set` 是否为空，否则会 RE。由于数据很水，甚至不需要 `multiset`。

```cpp
#include<bits/stdc++.h>
using namespace std;
template<class T> void read(T &x) {
	x = 0; bool flag = 0; char b = getchar();
	while (!isdigit(b)) flag = b == '-' ? 1 : 0, b = getchar();
	while (isdigit(b)) x = x * 10 + b - 48, b = getchar();
	x = flag ? -x : x;
}
template<class T, class ...Args> void read(T &x, Args &...args) {
	read(x), read(args...);
}
constexpr int _N = 5e5 + 5, _SN = 1e3 + 5, inf = 1e9;
int n, m, q;
int X[_N], Y[_N], W[_N];
int deg[_N], MID;
set<int> f[5][5], crit[_SN][5], P[5];
int id[_N];
vector<pair<int, int>> edge[_N];
unordered_map<int, int> num;
int cnt = 0;
inline bool IsCri(int x) {return deg[x] >= MID;}
void Move(int x, int tar) {
	if (!IsCri(x)) { // not critical
		for (auto e : edge[x]) {
			int v = e.first, w = e.second;
			if (IsCri(v)) {
				crit[num[v]][id[x]].erase(w);
				crit[num[v]][tar].emplace(w);
			} else {
				int tx = min(id[x], id[v]), ty = max(id[x], id[v]);
				int fx = min(tar, id[v]), fy = max(tar, id[v]);
				f[tx][ty].erase(w);
				f[fx][fy].emplace(w);
			}
		}
		id[x] = tar;
	} else { // critical
		for (auto e : edge[x]) {
			int v = e.first, w = e.second;
			if (!IsCri(v)) break;
			crit[num[v]][id[x]].erase(w);
			crit[num[v]][tar].emplace(w);
		}
		P[id[x]].erase(x);
		id[x] = tar;
		P[tar].emplace(x);
	}
}
int Query(int x, int y) {
	int res = !f[x][y].empty() ? *f[x][y].begin() : inf;
	if (!P[x].empty()) for (int u : P[x]) {
		if (crit[num[u]][y].empty()) continue;
		res = min(res, *crit[num[u]][y].begin());
	}
	if (!P[y].empty()) for (int u : P[y]) {
		if (crit[num[u]][x].empty()) continue;
		res = min(res, *crit[num[u]][x].begin());
	}
	return res;
}
signed main() {
	ios::sync_with_stdio(0); cout.tie(0);
	read(n, m);
	for (int i = 1; i <= m; ++i) {
		read(X[i], Y[i], W[i]);
		++deg[X[i]], ++deg[Y[i]];
		edge[X[i]].emplace_back(Y[i], W[i]);
		edge[Y[i]].emplace_back(X[i], W[i]);
	}
	MID = sqrt(n);
	for (int i = 1; i <= n; ++i) {
		sort(edge[i].begin(), edge[i].end(), [](const auto &A, const auto &B) {
			return IsCri(A.first) > IsCri(B.first);
		});
		if (IsCri(i)) num[i] = ++cnt;
	}
	for (int i = 1; i <= n; ++i) Move(i, 1);
	read(q);
	for (int i = 1; i <= q; ++i) {
		char opt[15]; scanf("%s", opt + 1);
		int x;
		if (opt[1] == 'M') {
			read(x);
			Move(x, opt[5] - 'A' + 1);
		} else {
			int ans = Query(opt[4] - 'A' + 1, opt[5] - 'A' + 1);
			if (ans != inf) cout << ans << '\n';
			else cout << "No Found!" << '\n';
		}
	}
}
```

---


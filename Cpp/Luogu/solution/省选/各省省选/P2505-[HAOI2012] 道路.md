# [HAOI2012] 道路

## 题目描述

C 国有 $n$ 座城市，城市之间通过 $m$ 条**单向**道路连接。一条路径被称为最短路，当且仅当不存在从它的起点到终点的另外一条路径总长度比它小。两条最短路不同，当且仅当它们包含的道路序列不同。我们需要对每条道路的重要性进行评估，评估方式为计算有多少条不同的最短路经过该道路。现在，这个任务交给了你。

## 说明/提示

数据规模

$30\%$ 的数据满足：$n\leq 15, m\leq 30$。

$60\%$ 的数据满足：$n\leq 300, m\leq 1000$。

$100\%$ 的数据满足：$n\leq 1500, m\leq 5000, 1\leq w\leq 10000$。

不保证没有重边。

## 样例 #1

### 输入

```
4 4
1 2 5
2 3 5
3 4 5
1 4 8```

### 输出

```
2
3
2
1```

# 题解

## 作者：xyz32768 (赞：45)

首先介绍一个原则：$i→j$的最短路径的任意一条子路径$u→v$都是最短路径。

证明：假设存在一条子路径$u→v$不是最短路径，那么一定能够找到一条更短的$u→v$的路径使$i→j$的路径更短。

根据这个原则，可以得出，在固定源点$S$时，存在$G$的一个子图$G'$，使得$G'$的每一条边都在$S$到其他至少一个点的最短路径上，且$G'$以外的边不在$S$到任意一个点的最短路径上。这里把$G'$称为源点为$S$时$G$的**最短路图**。判断一条边$u→v$是否在最短路图中，只需判断是否$dis[u]+val(u→v)==dis[v]$。其中$val(u→v)$为边$u→v$的长度。

再介绍一个原则：对于任意边权为正数的图$G$和任意源点$S$，最短路图$G'$上不存在环。

证明：设存在环$u_1→u_2→...→u_t→u_1$，则有$dis[u_2]=dis[u_1]+val(u_1→u_2)$，$dis[u_3]=dis[u_2]+val(u_2→u_3)$，…，$dis[u_t]=dis[u_{t-1}]+val(u_{t-1}→u_t)$，$dis[u_1]=dis[u_t]+val(u_t→u_1)$。由于边权均为正数，所以从上面可以同时得出$dis[u_t]>dis[u_1]$和$dis[u_t]<dis[u_1]$。从这个矛盾得出不存在环。


回到问题。首先枚举最短路的起点$S$，跑SPFA后构造出最短路图。

由于不存在环，所以这里进行拓扑排序。

先按照拓扑序，求出任意一个点$u$，$S$到$u$的最短路径的数目$cnt_1[u]$。很显然，$cnt_1[S]=1$，如果最短路图上存在边$u→v$，则$cnt_1[v]+=cnt_1[u]$。

再按照拓扑序的**逆序**，求出任意一个点$u$，在**最短路图**上以$u$为起点的路径条数$cnt_2[u]$。容易得到，如果先把每个点的$cnt_2$设为$1$（路径中只包含$u$），那么如果最短路图上存在边$u→v$，则$cnt_2[u]+=cnt_2[v]$。


统计贡献。对于**在最短路图上**的一条边$u→v$，贡献为$cnt_1[u]*cnt_2[v]$。


代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 1505, M = 5005, INF = 0x3f3f3f3f, PYZ = 1e9 + 7;
int n, m, ecnt, nxt[M], adj[N], st[M], go[M], val[M], dis[M], len, que[M << 1],
cnt[N], cnt1[N], cnt2[N], H, T, tot, q[N], ans[M];
bool vis[N], ins[M];
void add_edge(int u, int v, int w) {
    nxt[++ecnt] = adj[u]; adj[u] = ecnt; st[ecnt] = u; go[ecnt] = v; val[ecnt] = w;
}
void spfa(int S) {
    int i; memset(dis, INF, sizeof(dis));
    memset(ins, 0, sizeof(ins));
    dis[que[len = 1] = S] = 0;
    for (i = 1; i <= len; i++) {
        int u = que[i]; vis[u] = 0;
        for (int e = adj[u], v; e; e = nxt[e])
            if (dis[u] + val[e] < dis[v = go[e]]) {
                dis[v] = dis[u] + val[e];
                if (!vis[v]) vis[que[++len] = v] = 1;
            }
    }
    for (i = 1; i <= m; i++)
        if (dis[st[i]] + val[i] == dis[go[i]])
            ins[i] = 1;
}
void topo(int S) {
    memset(cnt, 0, sizeof(cnt));
    memset(cnt1, 0, sizeof(cnt1));
    memset(cnt2, 0, sizeof(cnt2));
    int i; H = tot = 0; cnt1[que[T = 1] = S] = 1;
    for (i = 1; i <= m; i++) if (ins[i]) cnt[go[i]]++;
    while (H < T) {
        int u = que[++H]; q[++tot] = u;
        for (int e = adj[u], v; e; e = nxt[e]) {
            if (!ins[e]) continue;
            v = go[e]; if (!(--cnt[v])) que[++T] = v;
            (cnt1[v] += cnt1[u]) %= PYZ;
        }
    }
    for (i = tot; i; i--) {
        int u = q[i]; cnt2[u]++;
        for (int e = adj[u], v; e; e = nxt[e]) {
            if (!ins[e]) continue;
            (cnt2[u] += cnt2[v = go[e]]) %= PYZ;
        }
    }
}
void solve(int S) {
    int i; spfa(S); topo(S);
    for (i = 1; i <= m; i++) if (ins[i])
        (ans[i] += 1ll * cnt1[st[i]] * cnt2[go[i]] % PYZ) %= PYZ;
}
int main() {
    int i, x, y, z; n = read(); m = read();
    for (i = 1; i <= m; i++) x = read(), y = read(),
        z = read(), add_edge(x, y, z);
    for (i = 1; i <= n; i++) solve(i);
    for (i = 1; i <= m; i++) printf("%d\n", ans[i]);
    return 0;
}
```

---

## 作者：shadowice1984 (赞：20)

这道题的做法……，叫什么好呢？

~~最短路径树EX？~~不要在意这些细节和术语，只要我们懂背后的道理就好了

另外，这道题的数据范围我们会觉得 O(V+E)VlogV)的复杂度非常的不可做

但是请捡起您的信仰，靠信仰是可以过的，因为每次不一定是最坏的情况，所以复杂度是O(能过)

## 本题题解

解决这道题，我们的思想非常暴力，因为我们在处理点的最短路方案是会发现这个东西是非常trival的，直接边spfa边dp就可以轻易解决这个问题，但是，对于边来讲，我们发现这个问题瞬间会变的十分辣手，当问题变得辣手的时候，我们就要考虑一些别的有趣方法，例如**枚举**。

因为题目中既没给原点也没给终点，我们只能暴力的跑N次dijkstra强行枚举所有的最短路径，定下原点和终点才有可能统计出答案。

现在我们考虑，我们在以S为源点跑了一个dijkstra，假设我们知道了关于这个单源路径的所有信息，那么我们会产生一个非常暴力的想法，**枚举每一条可能的最短路径**，路径上所有边方案+1，这样绝对不重不漏。

然而可惜的是，我们的时间复杂度不允许我们这么做，另外dijkstra算法给出的信息十分隐晦，我们似乎也直接枚举不了每个路径

此时我们发现，原来的暴力，我们是外层循环枚举路径，内层循环枚举边,然后+1
完成统计工作

现在我们换个方案，我们先**枚举边**，看**有多少路径包含它**(注意上述叙述以及接下来我们都在讨论**关于S的单源最短路径**，为了得到整体的答案，我们枚举S，执行N次我们接下来介绍的算法即可)

那么我们会发现，这个边(u->v)是有方向的，如果它要想成为最短路的一部分，
S到v的距离不能比S到u的距离小，不然这条边就会被“短路”用不上了。

但如果没被短路呢?那么我们似乎发现我们走路(s-t)的过程可以分为两部分：

1.从S走到u

2.从v走到T

u->v的方案就是我们从S走到u的方案数再去乘上一个从v到T的方案数

从S到u的方案数极其trival，这里请左转去看“最短路计数那道题”此处不在赘述。(如果dis值相等加法转移，否则重新赋值)

问题是v到T的方案数，有一个前置条件，必须经过s-u这个位置，而不可以绕开，这时统计工作进入了僵局，此时我们可能需要一点奇技淫巧帮助我们

### 最短路径树X最短路DAG

 ~~前面是《算法导论上的》，后面的是我自己YY的~~
 
 最短路径树，我们先以S为源点跑一遍某种单源最短路算法，然后枚举每个点v，选取**一条**S到v最短路径，加到某个图中。我们会惊奇的发现，这个图是一只树

原理:最短路算法不是dp(Bellman-ford)就是贪心(dijkstra)(退化的dp)，因此我们发现，单源最短路问题有**最优子结构性质**，即：单源最短路的一部分(当然其中一端必须是S)一定是单源最短路，因此一个单源最短路径必然是树上的一条链，并且链上的点不能再选路径，否则我们相当于重复选取了两条不同路径。

那么啥是最短路DAG呢？现在我们往一个图里加入**所有可能**的最短路，那么我们惊奇的会发现这个图是一个**DAG**(前提，没有零环)

原理，我们发现如果有最短路就不可以有负环，因此，我们考虑走过属于一条最短路的一条边的过程，我们会发现，一定是从dis值低的点走到了dis值高的点(因为没零环)，相当于我们一直在上坡，而显然，一个一直**上坡的环是不存在的**

为什么要扯这些呢?是因为我们发现了最短路DAG的一个性质，最短路DAG中任意一个以S开头的路径都是最短路。

那么我们就会发现我们能解决刚才的问题了,因为图上是不能dp的(但是可以高斯消元)，但是DAG可以。

如果我们把这个DAG的边全部反向(这里反向是因为正着走有后效性统计不了V-T)，我们倒着走，假设我们从一个T点出发，走到了v，那么V到T的所所有方案就是我们要求的最短路的一部分，因为这个东西，在DAG上随便接上一条路径就是一个最短路，(其实相当于倒着跑dp),那么我们在开始的时候已经正着跑了一遍dp了，倒着跑到v的方案乘上正着跑到u的方案就是过u->v的方案了

所以代码的整体思路就是跑N次dijkstra，同时边dijkstra跑出正向dp，建出最短路DAG，在最短路DAG上通过拓扑排序倒着跑dp，两个dp一乘就是方案了

下面上代码吧，注意这里有一个小trick，我们在跑dijkstra建DAG的时候一开始会建出错误的边，因此，我们在改变点V的dis值时需要删除这个点的所有出边，此时直接清掉邻接表的表头就好了。

上代码~

```c
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
typedef long long ll;
const int N=1510;const int M=5010;ll mod=1e9+7;
struct graph//建两个图，一个是原图，另一个是最短路DAG 
{
    struct data{int v;int nxt;int val;}edge[M];
    int alist[N];int cnt;
    inline void add(int u,int v,int val)
    {edge[++cnt].val=val;edge[cnt].v=v;edge[cnt].nxt=alist[u];alist[u]=cnt;}
}g1,g2;int n;int m;
struct dis//dijkstra用的结构体 
{
    int d;int v;dis(int dis=0,int ver=0){d=dis;v=ver;}
    friend bool operator <(dis a,dis b){return a.d>b.d;}
};priority_queue <dis> pq;queue <int> q;
int d[N];bool book[N];int rd[N];ll dans[N];ll ans[M];
ll dans1[N];//两个dp数组一个正着跑一个倒着跑 
inline void ih()//每次换源的时候重新赋值 
{
    g2.cnt=0;for(int i=1;i<=n;i++)
    {d[i]=0x3f3f3f3f;book[i]=false;dans[i]=1;rd[i]=0;g2.alist[i]=0;dans1[i]=0;}
}
inline void dijkstra(int s)//dijkstra 
{
    d[s]=0;dans1[s]=1;pq.push(dis(0,s));
    while(!pq.empty())
    {
        dis now=pq.top();pq.pop();if(book[now.v])continue;
        book[now.v]=true;int nxt=g1.alist[now.v];
        while(nxt)
        {
            int v=g1.edge[nxt].v;int val=g1.edge[nxt].val;
            if(!book[v])
            {
                if(d[v]==d[now.v]+val)//如果是相等就增加一条DAG边 
                {g2.add(v,now.v,nxt);dans1[v]=(dans1[v]+dans1[now.v])%mod;}
                if(d[v]>d[now.v]+val)//否则“松弛”掉这个点目前的所有出边 
                {
                    g2.alist[v]=0;g2.add(v,now.v,nxt);dans1[v]=dans1[now.v];
                    d[v]=d[now.v]+val;pq.push(dis(d[v],v));
                }
            }nxt=g1.edge[nxt].nxt;
        }
    }
}
inline void tpsrt()//DAG上反向dp ，注意val对应的是原图边的编号 
{
    for(int i=1;i<=n;i++)
    {for(int p=g2.alist[i];p;p=g2.edge[p].nxt){rd[g2.edge[p].v]++;}}
    for(int i=1;i<=n;i++){if(rd[i]==0){q.push(i);}}
    while(!q.empty())//其实DAG边的val是不必须的，跑出反向dp后直接枚举原图所有边也可行 
    {
        int now=q.front();q.pop();int nxt=g2.alist[now];//拓扑序dp 
        while(nxt)
        {
            int v=g2.edge[nxt].v;int val=g2.edge[nxt].val;
            dans[v]=(dans[v]+dans[now])%mod;//倒着dp 
            ans[val]=(ans[val]+dans[now]*dans1[v])%mod;//更新边的方案 
            rd[v]--;if(rd[v]==0){q.push(v);}
            nxt=g2.edge[nxt].nxt;
        }
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){int u;int v;int val;scanf("%d%d%d",&u,&v,&val);g1.add(u,v,val);}
    for(int i=1;i<=n;i++){ih();dijkstra(i);tpsrt();}//枚举所有源点 
    for(int i=1;i<=m;i++){printf("%d\n",ans[i]);}return 0;//拜拜程序~ 
}
```







---

## 作者：Fishing_Boat (赞：13)

首先，不难想出，每次枚举一个起点和终点，统计每个点到起点的最短路数量，记为 $cnt1$，和到终点的最短路数量，记为 $cnt2$，对每条边的贡献即即 $cnt1_u\times cnt2_v$。这样就可以拿到 $60$ 分。  

考虑优化，不难发现，我们其实可以只枚举一个起点，构造一个最短路图，然后在最短图上跑正着跑一遍再反着跑一遍 DAG，分别统计 $cnt1$ 和 $cnt2$。

下面上代码：
```cpp
#include<bits/stdc++.h>
#define inf 0x7fffffff
#define ll long long
#define cmax(a,b) if(a<b)a=b;
#define cmin(a,b) if(a>b)a=b;

using namespace std;

const int P(1e9+7);
int n,m,ans[5005],cnt1[1505],cnt2[1505],dis[1505],vis[1505];
struct node{
	int to,val,num;
};
vector <node> G[1505];
priority_queue <pair<int,int> > q;

void dijkstra(int s){
	memset(cnt1,0,sizeof(cnt1));
	memset(dis,0x7f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	dis[s]=0;cnt1[s]=1;q.push(make_pair(0,s));
	vector <int> dot; // 最短路 DAG
	while(!q.empty()){
		int u=q.top().second;q.pop();
		if(vis[u]) continue;
		vis[u]=1;dot.push_back(u);
		for(auto x:G[u]){
			int v=x.to,w=x.val;
			if(dis[u]+w<dis[v]){
				dis[v]=dis[u]+w;
				cnt1[v]=cnt1[u]; // 松弛操作，更新 cnt1
				q.push(make_pair(-dis[v],v));
			}else if(dis[u]+w==dis[v]){
				cnt1[v]+=cnt1[u]; // 距离相等，更新 cnt1
			}
		}
	} 
	reverse(dot.begin(),dot.end()); // 反着跑出 cnt2
	for(auto u:dot){
		cnt2[u]=1;
		for(auto x:G[u]){
			int v=x.to,w=x.val,id=x.num;
			if(dis[u]+w==dis[v]){
				cnt2[u]=(cnt2[u]+cnt2[v])%P;
				ans[id]=(ans[id]+1ll*cnt1[u]*cnt2[v]%P)%P;
			}
		}
	}
}

int main(){
	ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int x,y,z;
		cin>>x>>y>>z;
		G[x].push_back((node){y,z,i});
	}
	for(int i=1;i<=n;i++) dijkstra(i);
	for(int i=1;i<=m;i++) cout<<ans[i]<<'\n';
	return 0;
}

```
我们不难发现，在跑 djikstra 时，我们已经跑出了最短路图上的正向 DAG，因为所有可能在最短路图上的边都已经跑过了才会跑到这个点上，并且我们在进行松弛操作的同时已经可以更新出 $cnt1$，所以最后只需反着跑一遍 DAG 来统计 $cnt2$，并更新答案。

---

## 作者：漠寒 (赞：7)

## 分析

对于图中每两个可形成一条路径的点之间，都会有它们的最短路，题目所求的就是对于给出的 $m$ 条道路，有多少最短路经过该道路。

可以知道这不是一次搜索就可以做到的，因为它会在搜索过程中不断更改最短路，于是我们考虑在确定起点的情况下，它到各点的最短路经过了哪些路径。

我们以 $f_i$ 表示从起点到该点的最短路长度，于是可以知道，对于每一条路径，如果起点的 $f$ 值加上道路长度等于终点的 $f$ 值，那么就说明至少有一条最短路经过了该边，那么有多少条呢？我们用两个数组来解决这个问题。

首先，在找出所有满足条件的路径之后，我们用 $cntq$ 来表示这些路组成的图中以该点为起点的路有多少，用 $cntm$ 来表示以该点为终点的，因此对于每一条满足条件的路径，终点需加上起点的 $cntm$，起点需加上终点的 $nctq$。为了保证累加的正确性，我们再采用拓扑排序，正向计算 $cntm$，反向计算 $cntq$。最后对于每一条路径，加上的次数自然就是起点的 $cntm$ 乘上终点的 $cntq$ 了，这样此题就解决了。

另外，本题用 $dijkstra$ 有一个点会超时，$spfa$ 是可行的，但两个都挂上了，仅供参考。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,head[1501],vis[1501],flag[5001],f[1501],cnt,ans[5001],sum[1501],cntm[1501],cntq[1501];
const int mod=1e9+7;
struct node{
	int to,w,fr,next;
}a[5001];
void read(int &res){
	char c;
	res=0;
	c=getchar();
	while(c<'0'||c>'9'){c=getchar();}
	while(c>='0'&&c<='9')res=(res<<1)+(res<<3)+c-48,c=getchar();
}
priority_queue<pair<int,int> > q;
/*
inline void dijkstra(int qq){
	memset(vis,0,sizeof(vis));
	memset(flag,0,sizeof(flag));
	memset(f,127,sizeof(f));//有一个想法是memset太多了，也不确定 
	f[qq]=0;
	q.push(make_pair(0,qq));
	while(q.size()){
		int x=q.top().second;q.pop();
		if(vis[x])continue;
		vis[x]=1;
		for(register int i=head[x];i;i=a[i].next){
			int v=a[i].to;
			if(f[v]>f[x]+a[i].w){
				f[v]=f[x]+a[i].w;
				q.push(make_pair(-f[v],a[i].to));
			}
		}
	}
	for(register int i=1;i<=m;++i){
		if(f[a[i].fr]+a[i].w==f[a[i].to])flag[i]=1;
	}
}
*/

int que[10001],len;

inline void spfa(int qq) {
    memset(f,127,sizeof(f));
    memset(flag,0,sizeof(flag));
    f[que[len=1]=qq]=0;
    for (register int i = 1; i <= len; i++) {
        int x=que[i];vis[x]=0;
        for (register int i=head[x];i;i=a[i].next){
        	int v=a[i].to;
            if(f[x]+a[i].w<f[v]){
            	f[v]=f[x]+a[i].w;
            	if(!vis[v])vis[que[++len]=v]=1;
			}
		}
    }
    for(register int i=1;i<=m;++i){
		if(f[a[i].fr]+a[i].w==f[a[i].to])flag[i]=1;//满足条件，进行标记 
	}
}

int qu[1501],tot;
inline void topu(int qq){
	memset(sum,0,sizeof(sum));
	memset(cntm,0,sizeof(cntm));
	memset(cntq,0,sizeof(cntq));
	for(register int i=1;i<=m;++i)if(flag[i])sum[a[i].to]++;
	cntm[qq]=1;
	qu[tot=1]=qq;
	for(register int i=1;i<=tot;++i){
		int x=qu[i];
		for(register int i=head[x];i;i=a[i].next){
			if(!flag[i])continue;
			int v=a[i].to;
			if(!--sum[v])qu[++tot]=v;
			cntm[v]=(cntm[v]+cntm[x])%mod;
		}
	}
	for(register int i=tot;i;i--){
		int x=qu[i];cntq[x]++;
		for(register int i=head[x];i;i=a[i].next){
			if(!flag[i])continue;
			cntq[x]=(cntq[x]+cntq[a[i].to])%mod;
		}
	}
}

inline void sol(int qq){
	spfa(qq);topu(qq);
	for(register int i=1;i<=m;++i){
		if(flag[i])ans[i]=(ans[i]+1ll*cntm[a[i].fr]*cntq[a[i].to]%mod)%mod;
	}
}

inline void add(int qq,int mm,int l){
	a[++cnt].fr=qq;
	a[cnt].next=head[qq];
	head[qq]=cnt;
	a[cnt].to=mm;
	a[cnt].w=l;
}
int main()
{
	read(n);read(m);
	for(int i=1;i<=m;i++){
		int x,y,j;
		read(x);read(y);read(j);
		add(x,y,j);
	}
	for(int i=1;i<=n;i++)sol(i);
	for(int i=1;i<=m;i++){
		printf("%d\n",ans[i]);
	}
	return 0;
}

```


---

## 作者：神眷之樱花 (赞：5)

# 题面
[道路](https://www.luogu.com.cn/problem/P2505)

[My Blog](https://blog.csdn.net/init1064573673/article/details/116571091) 
# 题解
### 题意
对于每条道路，求出有多少条最短路经过它。
### 解析
先看看数据范围，不算大。

所以我们分别以每个点为起点，用SPFA求出每个点到源点的最短距离。

不难发现对于边 $(u,v,w)$，如果 $dis[u] + w = dis[v]$，那么这条边一定在源点到 $v$ 的最短路上。
而不满足这个条件的边，显然对答案毫无贡献，所以我们可以在跑完最短路后忽略不满足条件的这些边。

这样原图就变成了一副DAG图，因为不存在 $dis[u] + w = dis[v]$ ，且 $dis[v] + w = dis[u]$。

在DAG图上我们就可以跑拓扑排序了。对于每个点求出从源点到达它的方案数，再按照拓扑排序的逆序求出从后面的节点到达当前节点的方案数。

原因请看下图：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210509214202784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2luaXQxMDY0NTczNjcz,size_16,color_FFFFFF,t_70#pic_center)
从源点到 $u$ 的方案数记为 $cnt1[u]$，从后面的节点到达 $v$ 的方案数记为 $cnt2[v]$ ，不难发现根据乘法原理，这条从 $u$ 到 $v$ 的边就有 $cnt1[u] \times cnt2[v]$ 条最短路经过了它。因为当前图只保留了在最短路上的边，这些方案数确实都是最短路，所以答案是正确的。
# 代码
不知道我按照正常的SPFA的写法为什么只能过40分，这份代码里面的SPFA的内容是参考了其它题解的写法的。

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#define re register

using namespace std;

const int N = 1505,M = 5005;
const int mod = 1e9 + 7;

struct edge {
	int from,next,to,w;
}a[M];
int head[N],dis[N],ans[M],que[M << 1],n,m,a_size = 0;
bool vis[N],is[M];
inline void add(int u,int v,int w) {
	a[++a_size] = (edge){u,head[u],v,w};
	head[u] = a_size;
}
void SPFA(int s) {
    memset(dis,0x3f,sizeof(dis));
    memset(is,0,sizeof(is)); re int len;
    dis[que[len = 1] = s] = 0; vis[s] = true;
    for (re int i = 1; i <= len; i++) {
        int u = que[i]; vis[u] = 0;
        for (re int e = head[u],v; e; e = a[e].next)
            if (dis[u] + a[e].w < dis[v = a[e].to]) {
                dis[v] = dis[u] + a[e].w;
                if (!vis[v]) vis[que[++len] = v] = 1;
            }
    }
    for (re int i = 1; i <= m; i++)
        if (dis[a[i].from] + a[i].w == dis[a[i].to])
            is[i] = 1;
}
int deg[N],cnt1[N],cnt2[N],ord[N],len;
queue<int> q;
void tuopu(int s) {
	while(!q.empty()) q.pop();
	memset(deg,0,sizeof(deg));
	memset(cnt1,0,sizeof(cnt1));
	memset(cnt2,0,sizeof(cnt2)); len = 0;
	for(re int i = 1; i <= m; i++) if(is[i]) deg[a[i].to]++;
	q.push(s); cnt1[s] = 1;
	while(!q.empty()) {
		int x = q.front();
		q.pop(); ord[++len] = x;
		for(int i = head[x]; i; i = a[i].next) {
			if(!is[i]) continue;
			int y = a[i].to;
			cnt1[y] = (cnt1[y] + cnt1[x]) % mod;
			if(--deg[y] == 0) q.push(y);
		}
	}
	for(re int j = len; j >= 1; j--) {
		re int x = ord[j]; cnt2[x]++;
		for(re int i = head[x]; i; i = a[i].next) {
			if(!is[i]) continue;
			cnt2[x] = (cnt2[x] + cnt2[a[i].to]) % mod; 
		}
	}
}
inline int read() {
	re int x = 0,flag = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9'){if(ch == '-')flag = -1;ch = getchar();}
	while(ch >='0' && ch <='9'){x = (x << 3) + (x << 1) + ch - 48;ch = getchar();}
	return x * flag;
}
int main() {
	n = read(),m = read();
	for(re int i = 1,u,v,w; i <= m; i++) {
		u = read(),v = read(),w = read();
		add(u,v,w);
	}
	for(re int i = 1; i <= n; i++) {
		SPFA(i); tuopu(i);
		for(re int j = 1; j <= m; j++)
			if(is[j]) ans[j] = (ans[j] + 1ll * cnt1[a[j].from] * cnt2[a[j].to] % mod) % mod;
	}
	for(re int i = 1; i <= m; i++) printf("%d\n",ans[i]);
	return 0;
}
```



---

## 作者：Patrickpwq (赞：5)

容易想到枚举所有起点 做最短路 然后枚举边统计次数

一条边(x,y)的贡献 肯定是 s到x最短路的方案数 乘上 s到其他点但经过了y的最短路

对于前者

每个点可以从前一个点递推过来 只要满足dis[vis]==dis[now]+edge[u].val 当一个点被所有入边都统计了一次后 就可以搜他了（拓扑思想）

对于后者

每个点从后一个点递推过来
```
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define N 5505
#define M 5005
#define ll long long
using namespace std;
const int mod=1000000007; 
template <class T>
inline void read(T &x)
{
    x=0;
    static char ch=getchar();
    while(!isdigit(ch)) ch=getchar();
    while(isdigit(ch)) x=x*10+ch-'0',ch=getchar();
}
int n,m,first[N],tot,dis[N];
ll a[N],b[N],ans[N];
struct Edge
{
    int from,to,next,val;
}edge[M];
inline void addedge(int x,int y,int z)
{
    tot++;
    edge[tot].from=x; edge[tot].to=y; edge[tot].next=first[x]; edge[tot].val=z; first[x]=tot;
}
bool visit[N],onroad[N];
typedef pair<int,int> Pair;
void Dijkstra(int s)
{
    priority_queue<Pair,vector<Pair>,greater<Pair> > heap;
    memset(dis,0x3f,sizeof(dis)); memset(visit,false,sizeof(visit));
    heap.push(make_pair(0,s)); dis[s]=0;
    while(!heap.empty())
    {
        int now=heap.top().second;
        heap.pop();
        if(visit[now])  continue;
        visit[now]=true;
        for(int u=first[now];u;u=edge[u].next)
        {
            int v=edge[u].to;
            if(dis[now]+edge[u].val<dis[v])
            {
                dis[v]=dis[now]+edge[u].val;
                heap.push(make_pair(dis[v],v));
            }
        }
    }
}
int in[N];
void dfs1(int now)
{
    visit[now]=true;
    for(int u=first[now];u;u=edge[u].next)
    {
        int vis=edge[u].to;
        if(dis[vis]==dis[now]+edge[u].val)  //说明在最短路上
        {
            in[vis]++;
            if(visit[vis])  continue;
            dfs1(vis);
        } 
    }
}
void dfs2(int now)
{
    for(int u=first[now];u;u=edge[u].next)
    {
        int vis=edge[u].to;
        if(dis[vis]==dis[now]+edge[u].val)
        {
            onroad[u]=true;
            a[vis]=(a[vis]+a[now])%mod;
            in[vis]--;
            if(in[vis]==0)  dfs2(vis); 
        }
    }
}
void dfs3(int now)
{
    b[now]=1;
    for(int u=first[now];u;u=edge[u].next)
    {
        int vis=edge[u].to;
        if(dis[now]+edge[u].val==dis[vis])
        {
            if(!b[vis]) dfs3(vis);  //最短路没有环 放心dfs 
            b[now]=(b[now]+b[vis])%mod;
        }
    }
}
void Init()
{
    memset(onroad,false,sizeof(onroad));
    memset(a,0,sizeof(a));
    memset(b,0,sizeof(b));
    memset(in,0,sizeof(in));
}
int main()
{
    read(n),read(m);
    for(int i=1,x,y,z;i<=m;i++)
    {
        read(x),read(y),read(z);
        addedge(x,y,z);
    }
    for(int i=1;i<=n;i++)
    {
        Init();
        Dijkstra(i);
        memset(visit,0,sizeof(visit));
        dfs1(i);    //来自最短路上的入度
        a[i]=1;
        dfs2(i);    //i到每个点最短路的方案数
        dfs3(i);    //i制造的最短路经过每个点的数量 
        for(int j=1;j<=m;j++)   if(onroad[j])   ans[j]=(ans[j]+a[edge[j].from]*b[edge[j].to]%mod)%mod;
    }
    for(int i=1;i<=m;i++)   cout<<ans[i]<<'\n';
    return 0;
}```

---

## 作者：A_Pikachu (赞：2)

### [题目传送门](https://www.luogu.com.cn/problem/P2505)
（如果 $\LaTeX$ 炸了，请到博客[观看](https://www.luogu.com.cn/blog/thats-me/ti-jie-p2505-haoi2012-dao-lu-post)）

$\Large\mathscr{Part\,\,1\;\;}\text{基本思路}$

很明显，由于这里的最短路未给出起点和终点，所以需要以每个点为起点跑一遍最短路。又因为跑 $n$ 遍最短路后再标记最短路径很明显过不了 ~~（有过了的记得跟我说一声）~~ ，我们考虑先求出其中一次最短路的贡献。

既然都说了求每一条路作为最短路的次数，自然要先跑一遍最短路，即可得到一个最短路图。令 $u,v \in |V|$，对于 $\forall \ e(\ u\ ,\ v\ ) \in |E|$，判断其是否为最短路的的方法是检查 $dis[u]+len(\ u\ ,\ v\ )==dis[v]$，如果原式左边小于原式右边，则原图一定没能被成功松弛 ~~（就是最短路写挂了）~~ ；反之如果原式左边大于原式右边，则点 $v$ 一定通过其它边松弛成功，$e(\ u\ ,\ v\ )$ 自然不在最短路上；最后若左式等于右式，则说明最短路一定由此路径松弛。

之后考虑如何统计。由于最短路图为一个 DAG，考虑通过点递推贡献。和许多题的套路一样，我们把一条路径对边的贡献转化为对点的贡献，以一条路径 $e(\ u\ ,\ v\ )\small(u \to v)$ 为最短路的次数即为起点到 $u$ 的最短路个数加上 $v$ 到各个节点的最短路个数。

首先能做出贡献的点一定是起点，递推关系即可转化为最短路图上的边的关系，这样即可求出图中每一个点在起点构成的最短路图中的所对应最短路径的个数以及其拓扑序。

再利用拓扑反序求出每个点到其余点的最短路。这里之所以能用拓扑反序是因为最短路图在求拓扑序的时候已经将图给划分好层次了，这时再反过来遍历就不会出现其它情况 ~~（当然如果你要再跑一遍拓扑排序也没问题）~~。这里要注意因为从起点到这个点本身也是最短路，所以这个值本身就要为一。

然后根据乘法原理，把一条边的左右两端点的对应权值相乘即为当前起点的最短路数，求 $n$ 遍值相加即可。

$\Large\mathscr{Part\,\,2\;\;}\text{Code\qquad}$

```cpp
#include <cstdio>
#include <vector>
#include <queue>
using namespace std;
const int N=1505,M=5005,inf=0x7fffffff,MOD=1000000007;
int n,m,u,v,w,head[N],dis[N],val[N],vall[N],deg[N],anss[M]; // val 和 vall 分别存储每个点的两个权值，deg 记录每个点在最短路图上的入度 
bool can[M]; // can[i] 表示第 i 条路径是否在最短路图上 
struct edge{
	int nxt,to,len;
}e[M]; // 链式前向星 
namespace SegT{ // 以下为线段树 
	int tre[N<<2],mn[N<<2];
	inline int lfsn(int x){return x<<1;}
	inline int rtsn(int x){return x<<1|1;}
	inline void update(int ax,int lf,int rt,int x,int k){
		if(lf==rt){
			tre[x]=k;
			return;
		}
		int ls=lfsn(x),rs=rtsn(x),md=(lf+rt)>>1;
		if(ax<=md) update(ax,lf,md,ls,k);
		else update(ax,md+1,rt,rs,k);
		tre[x]=min(tre[ls],tre[rs]);
		mn[x]=(tre[x]==tre[ls]?mn[ls]:mn[rs]);
	}
	inline inline void build(int lf,int rt,int x,int s){
		if(lf==rt){
			dis[lf]=tre[x]=(lf==s?0:inf);
			mn[x]=lf;
			return;
		}
		int ls=lfsn(x),rs=rtsn(x),md=(lf+rt)>>1;
		build(lf,md,ls,s);
		build(md+1,rt,rs,s);
		tre[x]=min(tre[ls],tre[rs]);
		mn[x]=(tre[x]==tre[ls]?mn[ls]:mn[rs]);
	}
}
using namespace SegT; // 以上为线段树 
inline void dij(int s){ // 用的线段树优化 Dijkstra，要吸氧（不过 SPFA 没被卡） 
	build(1,n,1,s);
	while(tre[1]!=inf){
		register int x=mn[1];
		update(x,1,n,1,inf);
		for(register int i=head[x]; i; i=e[i].nxt){
			register int y=e[i].to,z=e[i].len;
			if(dis[y]>dis[x]+z){
				update(y,1,n,1,dis[y]=dis[x]+z);
			}
		}
	}
}
queue<int> qq;
vector<int> ans;
inline void topsort(int s){ // 拓扑排序 
	for(register int i=1; i<=m; i++) can[i]=0;
	for(register int i=1; i<=n; i++) deg[i]=0;
	ans.clear();
	for(register int i=1; i<=n; i++){
		val[i]=vall[i]=0;
		for(register int j=head[i]; j; j=e[j].nxt){
			register int y=e[j].to,z=e[j].len;
			if(dis[y]==dis[i]+z) can[j]=1,++deg[y]; // 构建最短路图 （其实这里建个新图也行） 
		}
	}
	qq.push(s);
	val[s]=1;
	while(!qq.empty()){ // 正常拓扑 
		register int x=qq.front(); qq.pop(); ans.push_back(x); // ans 记录拓扑序 
		for(register int i=head[x]; i; i=e[i].nxt){
			register int y=e[i].to;
			if(!can[i]) continue; // 以最短路图的关系递推
			if(!(--deg[y])) qq.push(y);
			val[y]+=val[x];
		}
	}
	for(register int i=ans.size()-1; ~i; i--){ // 拓扑序逆序 
		register int x=ans[i]; vall[x]++;
		for(register int j=head[x]; j; j=e[j].nxt){
			register int y=e[j].to;
			if(!can[j]) continue;
			vall[x]+=vall[y];
		}
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(register int i=1; i<=m; i++){
		scanf("%d%d%d",&u,&v,&w);
		e[i]=(edge){head[u],v,w};
		head[u]=i;
	}
	for(register int i=1; i<=n; i++){
		dij(i); topsort(i); // 先求出每个点的权值 
		for(register int j=1; j<=n; j++){
			for(register int k=head[j]; k; k=e[k].nxt){ // 遍历每条边 
				register int y=e[k].to;
				if(!can[k]) continue;
				anss[k]=(anss[k]+1LL*(val[j]%MOD)*(vall[y]%MOD))%MOD; // 累计答案 
			}
		}
	}
	for(register int i=1; i<=m; i++) printf("%d\n",anss[i]); // 输出答案 
	return 0;
}
```

时间复杂度 $\Theta(n^2\log_2m)$ ~~（常数略大）~~，要吸氧才能过，不过因为出题人没卡 SPFA，所以 SPFA 重新回到了属于它的 $\Theta(km)$ 时代！（大雾

~~什么？你问我要 SPFA 的代码？供各位读者思考。~~

---

## 作者：devout (赞：1)

[博客内食用更佳](https://blog.csdn.net/devout_/article/details/104826747)

这道题首先我们应该考虑到的是，因为我们最短路的起点和终点都不知道，所以我么应该枚举起点，然后跑最短路

我们枚举起点之后，每次跑最短路，都可以构造出一个最短路图（由所有在最短路上的边构成）

判断一条边在不在最短路图的方法是如果$dis[v]=dis[u]+length(u,v)$，那么他在最短路图上

那么我们接下来要枚举最短路图上的每条边，对于一条边$(u,v)$，我们需要处理出的是从$s$到$u$的最短路图上的路径条数，和$v$到每个点的最短路图上的路径图，因为最短路图是一个DAG，所以我们可以通过拓扑排序上$dp$来解决

对于第一个问题，很好解决

第二个问题，由于不知道终点，不太好处理，但是我们知道起点啊！所以我们可以通过建立反图来解决

但是建反图不好建怎么办？

我们可以考虑，我们往下转移的时候，下面的点的拓扑序一定比这个点要大，所以我们可以按拓扑序逆序处理就好了

还有一个问题：为什么这题会卡掉$dijkstra$呢

我们看$dijsktra$的复杂度，这道题因为要枚举起点，复杂度是$O(nm\log m)$，显然是容易被卡的

为什么$spfa$没有$spfa$呢？

因为我们要从每个点都跑一边最短路啊，$spfa$均摊是$O(km)$啊，出题人显然不会花时间在这上面为了卡掉$spfa$，而且数据很难构造

代码啦：

```cpp
#include <bits/stdc++.h>
using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

typedef long long ll;

const int N=10005;
const int mod=1e9+7;

template <typename T> void read(T &x){
    x=0;int f=1;
    char c=getchar();
    for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

int n,m;
int head[N],cnt;
int tpx[N],inde[N],tot;
int dis[N];
ll f[N],g[N];
bool inq[N],is[N];
ll ans[N];

struct Edge{
    int from,to,next,w;
}e[N<<1];

void add(int x,int y,int c){
    e[++cnt]=(Edge){x,y,head[x],c},head[x]=cnt;
}

void spfa(int s){
    memset(dis,0x3f,sizeof(dis));
    queue<int> q;
    q.push(s);
    dis[s]=0;
    inq[s]=true;
    while(!q.empty()){
        int u=q.front();q.pop();
        inq[u]=false;
        RepG(i,u){
            int v=e[i].to;
            if(dis[v]>dis[u]+e[i].w){
                dis[v]=dis[u]+e[i].w;
                if(!inq[v])inq[v]=true,q.push(v);
            }
        }
    }
    Rep(i,1,m)
        if(dis[e[i].from]+e[i].w==dis[e[i].to])is[i]=true,inde[e[i].to]++;
        else is[i]=false;
}

void topo(){
    queue<int> q;
    Rep(i,1,n)if(!inde[i])q.push(i);
    tot=0;
    while(!q.empty()){
        int u=q.front();q.pop();
        tpx[++tot]=u;
        RepG(i,u){
            if(!is[i])continue;
            int v=e[i].to;
            inde[v]--;
            if(!inde[v])q.push(v);
        }
    }
}

void update(int s){
    memset(f,0,sizeof(f));
    memset(g,0,sizeof(g));
    f[s]=1;
    Rep(i,1,tot){
        int u=tpx[i];
        RepG(i,u){
            if(!is[i])continue;
            int v=e[i].to;
            f[v]+=f[u];
        }
    }
    _Rep(i,tot,1){
        int u=tpx[i];
        g[u]++;
        RepG(i,u){
            if(!is[i])continue;
            int v=e[i].to;
            g[u]+=g[v];
        }
    }
    Rep(i,1,m)
        if(is[i])
            ans[i]=(ans[i]+1ll*f[e[i].from]*g[e[i].to])%mod;
}

int main()
{
    memset(head,-1,sizeof(head));
    read(n),read(m);
    Rep(i,1,m){
        int x,y,c;
        read(x),read(y),read(c);
        add(x,y,c);
    }
    Rep(i,1,n){
        spfa(i);
        topo();
        update(i);
    }
    Rep(i,1,m)printf("%lld\n",ans[i]);
    return 0;
}
```


---

## 作者：Coros_Trusds (赞：0)

# 题目大意

给定一个有向图，对于每条道路，求出有多少条最短路经过它。答案可能很大，对 $10^9+7$ 取模。

# 题目分析

观察到 $n$ 的数据范围足够跑 $n^2$ 了，所以我们来个暴力算法：

以每个点为原点 $st$ 跑一边 $\rm Spfa$，如果存在一条边 $dis[u]+w=dis[v]$ 那么边 $(u,v)$ 在最短路径上。

接下来我们可以排除掉那些不在最短路径上的边了。

但是怎么求经过某条道路的次数呢？令 $cnt1[u]$ 表示 $st$ 到 $u$ 的最短路径数，$cnt2[v]$ 表示从点 $v$ 出发的最短路径数，根据乘法原理，这条边 $(u,v)$ 的单次经过次数为 $cnt1[u]\times cnt2[v]$，总共的经过次数即为把所有点都当做一次原点跑出的结果之和。

可以发现可以轻易判断出每条边是否在最短路径上，因为 $dis$ 容易求。$cnt1,cnt2$ 则跑一次拓扑排序就求出来了。

存边可以用 `tuple` 存。

**注意多测要清空！！！（因为会把每个点都当做源点跑一次 $\rm Spfa$ 和拓扑排序）**

# 代码

```cpp
//2022/4/19
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <numeric>
#include <algorithm>
#include <tuple>
#include <queue>
#define enter putchar(10)
#define debug(c,que) cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) cout << arr[i] << w;
#define speed_up() ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define Abs(x) ((x) > 0 ? (x) : -(x))
#define stop return(0)
const int mod = 1e9 + 7;
inline int MOD(int x) {
	if(x < 0) x += mod;
	return x % mod;
}
namespace Newstd {
	char buf[1 << 21],*p1 = buf,*p2 = buf;
	inline int getc() {
		return p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1 << 21,stdin),p1 == p2) ? EOF : *p1 ++;
	}
	inline int read() {
		int ret = 0,f = 0;char ch = getc();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getc();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getc();
		}
		return f ? -ret : ret;
	}
	inline void write(int x) {
		if(x < 0) {
			putchar('-');
			x = -x;
		}
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;
using namespace std;
typedef tuple<int,int,int> TII;

const int N = 5005;
struct Gragh {
	int v,w,nxt;
} gra[N];
int head[N],dis[N],cnt1[N],cnt2[N],ans[N],in[N],que[N];
bool in_que[N],in_path[N];
TII edges[N];
int n,m,idx;
inline void add(int u,int v,int w) {
	gra[++ idx].v = v,gra[idx].w = w,gra[idx].nxt = head[u],head[u] = idx;
}
inline void spfa(int st) {
	mst(dis,0x3f),mst(in_que,false),mst(in_path,false);
	dis[st] = 0,in_que[st] = true;
	queue<int>q;
	q.push(st);
	while (!q.empty()) {
		int u = q.front();q.pop();
		in_que[u] = false;
		for (register int i = head[u];i;i = gra[i].nxt) {
			int v = gra[i].v,w = gra[i].w;
			if (dis[v] > dis[u] + w) {
				dis[v] = dis[u] + w;
				if (!in_que[v]) {
					in_que[v] = true;
					q.push(v);
				}
			}
		}
	}
}
inline void topsort(int st) {
	mst(cnt1,0),mst(cnt2,0),mst(in,0),mst(que,0);
	int cnt = 0;
	for (register int i = 1;i <= m; ++ i) {
		if (in_path[i]) {
			in[get<1>(edges[i])] ++;
		}
	}
	cnt1[st] = 1;
	queue<int>q;
	q.push(st);
	while (!q.empty()) {
		int u = q.front();q.pop();
		que[++ cnt] = u;
		for (register int i = head[u];i;i = gra[i].nxt) {
			int v = gra[i].v;
			if (in_path[i]) {
				cnt1[v] = MOD(cnt1[v] + cnt1[u]);
				in[v] --;
				if (!in[v]) q.push(v);
			}
		}
	}
	for (register int i = cnt;i >= 1; -- i) {
		int u = que[i];
		cnt2[u] ++;
		for (register int j = head[u];j;j = gra[j].nxt) {
			if (in_path[j]) {
				cnt2[u] = MOD(cnt2[u] + cnt2[get<1>(edges[j])]);
			}
		}
	}
}
int main(void) {
#ifndef ONLINE_JUDGE
	freopen("in.txt","r",stdin);
#endif
	n = read(),m = read();
	for (register int i = 1;i <= m; ++ i) {
		int u = read(),v = read(),w = read();
		add(u,v,w);
		edges[i] = make_tuple(u,v,w);
	}
	for (register int i = 1;i <= n; ++ i) {
		spfa(i);
		for (register int j = 1;j <= m; ++ j) {
			if (dis[get<0>(edges[j])] + get<2>(edges[j]) == dis[get<1>(edges[j])]) {
				in_path[j] = true;
			}
		}
		topsort(i);
		for (register int j = 1;j <= m; ++ j) {
			if (in_path[j]) {
				ans[j] = MOD(ans[j] + cnt1[get<0>(edges[j])] * cnt2[get<1>(edges[j])]);
			}
		}
	}
	for (register int i = 1;i <= m; ++ i) printf("%d\n",ans[i]);

	return 0;
}
```

---

## 作者：lprdsb (赞：0)

### 题意

- 有一个有向图

- 对每条边求出有多少条两个点对之间的最短路过这条边

点只有$10^3$，那么我们对每个点跑一遍最短路后，构建出最短路径树，所有在这棵树上的边就会算一遍贡献

具体的，求出有多少种走法从起点到边的一端，以及从另一端可以有多少条不同的路径，乘起来即可

```cpp
#include<bits/stdc++.h>
#define For(i, a, b) for(int i = (a), en = (b); i <= en; ++i)
#define Rof(i, a, b) for(int i = (a), en = (b); i >= en; --i)
#define Tra(u, i) for(int i = hd[u]; ~i; i = e[i].net)
#define cst const
#define LL long long
#define DD double
#define LD long double
#define pb push_back
#define mp make_pair
#define fir first
#define sec second
#define inf 0x3f3f3f3f
#define Inf 0x3f3f3f3f3f3f3f3f
#define eps 1e-12
#define maxn 5000
#define mod 1000000007
using namespace std;

int n, m, hd[maxn + 5], len = 0, as[maxn + 5];
struct Edge{int u, v, w, id, net;} e[maxn + 5];
void add(int u, int v, int w, int id){e[len] = (Edge){u, v, w, id, hd[u]}; hd[u] = len++;}

template <class T>
void read(T &x){
	char ch;
	bool ok;
	for(ok = 0, ch = getchar(); !isdigit(ch); ch = getchar()) if(ch == '-') ok = 1;
	for(x = 0; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());
	if(ok) x = -x;
}

void add(int &x, int y){x += y; if(x >= mod) x -= mod;}

int dis[maxn + 5], f[maxn + 5];
priority_queue<pair<int, int> > q;
void dij(int s){
	memset(dis, inf, sizeof dis); dis[s] = 0;
	memset(f, 0, sizeof f); f[s] = 1;
	q.push(mp(0, s));
	while(q.size()){
		int u = q.top().sec, tem = -q.top().fir; q.pop();
		if(tem != dis[u]) continue;
		Tra(u, i){
			int v = e[i].v, w = e[i].w;
			if(dis[v] == dis[u] + w) add(f[v], f[u]);
			else if(dis[v] > dis[u] + w){
				dis[v] = dis[u] + w;
				f[v] = f[u];
				q.push(mp(-dis[v], v));
			}
		}
	}
}
int g[maxn + 5];
int dfs(int u){
	if(g[u] != -1) return g[u];
	int asi = 1;
	Tra(u, i){
		int v = e[i].v, w = e[i].w;
		if(dis[u] + w != dis[v]) continue;
		add(asi, dfs(v));
	}
	return g[u] = asi;
}

int main(){
	//freopen("road.in", "r", stdin);
	//freopen("road.out", "w", stdout);
	memset(hd, -1, sizeof hd);
	read(n); read(m);
	For(i, 1, m){
		int u, v, w; read(u); read(v); read(w);
		add(u, v, w, i);
	}
	For(i, 1, n){
		dij(i);
		memset(g, -1, sizeof g);
		For(j, 0, len - 1){
			int u = e[j].u, v = e[j].v, w = e[j].w, id = e[j].id;
			if(dis[u] + w == dis[v]) add(as[id], 1ll * f[u] * dfs(v) % mod);
		}
	}
	For(i, 1, m) printf("%d\n", as[i]);
	return 0;
}
```



---


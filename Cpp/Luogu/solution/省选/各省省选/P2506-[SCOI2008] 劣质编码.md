# [SCOI2008] 劣质编码

## 题目背景

四川NOI省选2008


## 题目描述

一个编码方案把每个字符对应到一个01 串。例如{1,1010,01,10101}就是一个编码方案，它把四个字符（假设它们为a,b,c,d）分别对应到串1、1010，01，10101。字符串的编码为各字符编码的连接。例如，在刚才的编码方案中，字符串cac的编码为01101，dcb的编码为10101011010。

进一步分析发现，刚才的编码是相当劣质的，因为字符串ba, acc 和d 的编码都是10101。对于一个编码方案，你的任务是找出三个不同的字符串，使得它们的编码全相同。换句话说，找一个01 编码串，使得它至少有三种解码方式。如果有多组解，这个编码串应当尽量短。


## 说明/提示

2 <= n <= 30


## 样例 #1

### 输入

```
4
1
1010
01
10101```

### 输出

```
5```

## 样例 #2

### 输入

```
2
0
1```

### 输出

```
-1```

## 样例 #3

### 输入

```
7
00011011
000110
11
0001
1011
00
011011```

### 输出

```
8```

# 题解

## 作者：JoaoFelix (赞：2)

~~又来一道玄学题orz~~

我们发现这题的状态数应该不会太多，我们只要能找到合适的压缩状态的办法，就能过题。

因为这个cnt只到3的范围左右，于是我们考虑dp，如果我们能压出的是dp的数组？并且这个里面的dp值不会很大，3左右的最多。

于是我们开始考虑怎么dp，记录当前匹配到第i个串的第j位的个数有多少？我们只需要维护这个dp值就可以。

这个非常好转移，如果填完了，就把所有新开始的位置加上填完的总数组解，反之我们就是向前一位转移。

于是我们考虑如果有某一个字符串填完，把这个填完的总数相加，如果大于3就直接找到答案了，反之我们就继续bfs。

这里具体的实现我们用一个vector来压一个dp数组，这个dp数组我们把i个串的都拼在一起，搞一个一位数组存在vector里面就好。

然后我们用一个map来映射一下这个vector，转移就是枚举‘0’~‘1’然后不断bfs，大致是这样的一个思路。

具体复杂度我也不会证，但是跑的飞快，就O(能过)

代码：
```cpp
#include<bits/stdc++.h>
#define LL long long
#define vi vector<int>
using namespace std;
int n,id[35][55],totl,dfn;
string str[35];
vi s,t;map<vi,int>mp;
queue<vi>q;
int main(){
	scanf("%d",&n);
	for(int i=1,l;i<=n;i++){
		cin>>str[i];l=str[i].size();totl+=l;
		if(!l){puts("0");return 0;}
		for(int j=0;j<l;j++)id[i][j]=dfn++;
	}
	s.resize(totl);t.resize(totl);
	for(int i=1;i<=n;i++)s[id[i][0]]=1;
	mp[s]=0;q.push(s);
	while(!q.empty()){
		vi u=q.front();q.pop();int ns=mp[u];
		for(char ch='0';ch<='1';ch++){
			for(int i=0;i<totl;i++)t[i]=0;
			int ed=0;
			for(int i=1,l;i<=n;i++){
				l=str[i].size();
				for(int j=0;j<l;j++)if(str[i][j]==ch){
					if(j==l-1)ed+=u[id[i][j]];else t[id[i][j+1]]=u[id[i][j]];
				}
			}
			if(ed>=3){printf("%d\n",ns+1);return 0;}
			for(int i=1;i<=n;i++)t[id[i][0]]=ed;
			if(!mp.count(t))mp[t]=ns+1,q.push(t);
		}
	}
	puts("-1");
	return 0;
}
```


---

## 作者：0nullptr (赞：2)

题目传送门：[P2506 [SCOI2008]劣质编码](https://www.luogu.org/problem/P2506)

本题要求我们求出一种有在给定编码下至少有三种解法的最短串。

由于它不要求我们求出来这个最短串是什么，那么可以通过隐式图bfs的方式，不断扩展当前匹配状态，简单的求出该最短串的长度。

在这种做法中，状态是每个串分别被匹配到第几位。为了表示方便，可以用一个 ```vector``` 来存储当前正在匹配的是哪个串与该串当前正在被匹配的是哪一位元素。为了转移方便，可以将哪个串与第几位元素压至同一个```int```中，用前几位存储当前串的编号，后几位存储当前串正在被匹配哪一位元素。

接下来考虑如何进行bfs转移。根据每个串的匹配情况，我们分以下两种情况讨论：
1. 当前串已经被完全匹配：此时应增加完全匹配串的计数，并将全部串加入可能的下一种状态列表中。
2. 当前串未被完全匹配：此时直接将该串的下一位扔入可能的下一种状态列表中即可。

在求出所有可能的下一种状态列表之后，需要再计算出下一个状态的具体情况。具体操作如下：
1. 将当前可能的状态列表以第几个串为第一关键字，该串匹配到第几位为第二关键字进行排序（由于这两个量已经被我们压入一个int中，因此直接排序即可）
2. 将前二个串的子状态加入下一种状态中
3. 在之后的所有子状态中，将其不重复的放入下一种状态中

这样，这道题就可以解决了。

本题还有一个扩展，即求出最小串的一种可能情况。这个扩展同样可以根据该方式求解。具体实现留作思考。

下面贴出完整代码：
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
#include <queue>
#include <map>
using namespace std;

map<vector<int>, int> hsh;
//利用map记录每个状态中求得的最短串长度
queue<vector<int> > Q;//bfs用
string str[35];
vector<int> u, v, t;
//u -> 起始状态
//v -> 可能的下一个状态
//t -> 下一个状态 
int main() {
    int n;
    cin>>n;
    for (int i = 1; i <= n; i++) cin>>str[i];
    //输入字符串 
    for (int i = 1; i <= n; i++)
        if (str[i] == "") 
            return puts("0"), 0;//如果存在空串就直接输出0退出程序 
		else u.push_back(i << 6);//起始状态中，该串从第一位开始匹配 
    hsh[u] = 0;//起始状态的最小串长度为0 
    Q.push(u);
    while (!Q.empty()) {//bfs 
        u = Q.front();
        Q.pop();
        int x = hsh[u], cnt;
//x -> 当前状态中最小串的长度，cnt -> 完全匹配的串计数器 
        for (int ch = '0'; ch <= '1'; ch++) {
            cnt = 0;
            v.clear();
            for (int i = 0; i < (int)u.size(); i++) {
                int stay = u[i] >> 6, local = u[i] & 63;
//stay -> 第几个串 local -> 第几个元素 
//63 = 2 ^ 6 - 1， 即 local = u[i] % 64
                if (str[stay][local] ^ ch) continue;
//如果这一位和当前判断的数字不能匹配则跳过 
                if (++local == (int)str[stay].size()) {//如果这一位是当前串的最后一位 
                    ++cnt;//增加计数 
                    for (int j = 1; j <= n; ++j)
                        v.push_back(j << 6);
//下一种可能状态中加入全部串的串首 
                } 
                else v.push_back(stay << 6 | local);
//下一种可能状态中加入当前元素的下一位 
            }
            if (cnt >= 3) {//如果找到了大于三个解的串 
                cout<<x + 1<<endl;//输出长度 
                return 0;
            }
            sort(v.begin(), v.end());
//对v进行以第几个字符串为第一关键字，第几位为第二关键字的排序 
            t.clear();
            for (int i = 0; i < (int)v.size(); i++)
                if (i < 2 || v[i] ^ v[i - 2]) t.push_back(v[i]);
//根据上述方式计算下一种状态 
            if(t.size() && !hsh.count(t)) hsh[t] = x + 1, Q.push(t);
//如果当前计算出来的状态没有入队过，则将其入队 
        }
    }
    cout<<-1<<endl;
//如果在bfs过程中没有找到结果则无解
    return 0;
}
```

---

## 作者：YangRuibin (赞：0)

# 最初思路

看到这道题，我首先想到的是动态规划。对三次匹配分别开维度，定义状态为：$f_{i,j,posj,k,posk}$ 表示最短串长度。其中 $i$，$j$，$k$ 分别表示三次匹配当前的串，而 $posj$，$posk$ 表示匹配的位数。

这样定义状态无法实现，有几个原因：

1. 需要空间约为 $n ^ 3 \times |s| ^ 2$ 有些紧张。
2. 转移时还需 $O(n)$ 时间，会超时。
3. 转移顺序无法明确。

# 改进优化

进一步观察发现，实际上状态并没有定义的那么多，也就是跑不满，所以用 map 存状态。转移顺序的问题可以通过 bfs 解决。

在实现时，也不需要专门维护“三次”匹配，而是注重对于每一个当前答案，它仍然能够匹配上的是哪些串以及这些串匹配到了哪一位。

在每一次更新当前答案时，如果有一个串被完全匹配，则把 `num` 增大 $1$ 最后看 `num` 的值如果 $\ge3$ 说明找到正确答案。

# 代码
~~常数大亿点，但较容易看，能 AC~~

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef vector<pair<int,int> > vpi;
//pair 的 first 为串的编号，second 为匹配位数
const int N=35,L=55;
int n;
string s[N];
vpi x,y,t;
map<vpi,int>mp;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>s[i];
		if(s[i].length()==0)return cout<<0,0;//特判空串
		x.push_back(make_pair(i,0));
	}
	queue<vpi>q;
	q.push(x);mp[x]=0;
	while(!q.empty())
	{
		x=q.front();q.pop();
		int now=mp[x],num;
		for(char c='0';c<='1';c++)
		{
			y.clear();num=0;
			for(int i=0;i<x.size();i++)
			{
				int id=x[i].first,nid=x[i].second;
				if(s[id][nid]!=c)continue;
				++nid;//要匹配下一位了
				if(nid==s[id].size())//完全匹配，所有串都有可能成为下一个状态
				{
					++num;
					for(int j=1;j<=n;j++)y.push_back(make_pair(j,0));
				}
				else y.push_back(make_pair(id,nid));//匹配了部分，继续匹配
			}
			if(num>=3)return cout<<now+1,0;//找到答案，结束程序
			if(y.size()&&!mp[y])mp[y]=now+1,q.push(y);
		}
	}
	cout<<-1;
	return 0;
}
```

---


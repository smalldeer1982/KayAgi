# [HAOI2008] 下落的圆盘

## 题目描述

有n个圆盘从天而降，后面落下的可以盖住前面的。求最后形成的封闭区域的周长。看下面这副图, 所有的红色线条的总长度即为所求.

![](https://cdn.luogu.com.cn/upload/pic/1628.png)


## 说明/提示

数据规模

n<=1000


## 样例 #1

### 输入

```
2
1 0 0
1 1 0```

### 输出

```
10.472```

# 题解

## 作者：pufanyi (赞：16)

[两页的爆蛋记录](https://www.luogu.org/recordnew/lists?uid=84088&pid=P2510)（来自蒟蒻的无助）。

orz 千古神犇 wzp 一眼秒题。

这种题一定要耐心地做（初中数学老师一直这么对我说）。

首先，我们来看其简化版：

![](https://github.com/pfypfypfy/images-in-blogs/blob/master/20180527002.png?raw=true)

我们把 $\odot B$ 覆盖在 $\odot A$ 上，我们发现我们需要求出 $\angle A$ 的度数。我的方法是连结 $CB,AB,BD,AB$（如图）。我们发现 $\triangle ABC\cong\triangle ABD$，又在 $\triangle ABC$ 中，由[余弦定理](https://baike.baidu.com/item/%E4%BD%99%E5%BC%A6%E5%AE%9A%E7%90%86/957460?fr=aladdin)得：$\cos A=\frac{{AC}^2 + {AB}^2 - BC^2}{2\times AB \times AC}$ 于是我们就得到了 $\angle A$。

![](https://github.com/pfypfypfy/images-in-blogs/blob/master/20180527003.png?raw=true)

恭喜你过了样例。

```cpp
double dist = get_dist(A, B);
if(dist > A.r+B.r || A.r + dist < B.r)
	return;
if(dist + B.r < A.r)//完全被覆盖
{
	gaif = true;//标记直接跳出
	return;
}
double alpha = acos((sqr(B.r)+sqr(dist)-sqr(A.r))/(B.r*dist*2.));
```

那么如果有多个圆呢？

![](https://github.com/pfypfypfy/images-in-blogs/blob/master/20180527004.png?raw=true)

我们发现，对于 $\odot A$ 来说，$EF$ 被覆盖了两次，但我们之能减一次。于是我们就想到了：对于每个圆，枚举盖在其上面的圆，算出每个覆盖“线段”的左右端点，然后进行一次线段覆盖将其合并。最后，我们只要算出没有被覆盖到的线段长度即可。

我们用[极角](https://baike.baidu.com/item/%E6%9E%81%E8%A7%92/12726003?fr=aladdin)来表示圆上点的位置，这样我们就可以进行线段覆盖操作了。

如图，$AE$ 平行 $x$ 轴，我们以算出 $AC$ 的斜率，加个 $\arctan$ 即可求出 $\angle CAE$，然后 $\angle EAD$、$\angle BAE$ 均可求出。

![](https://github.com/pfypfypfy/images-in-blogs/blob/master/20180527005.png?raw=true)

于是理论上的问题就全部解决了。

对于极角还有一个小细节：

由于我们在线段求并时只容许有$1$到$2\pi$的弧度，因此，对于两个“交点”$l,r$，我们需要作出以下特判：

1. $l<0$ 且 $r<0$ 时，我们要把 $l$ 与 $r$ 均加上 $2\pi$；
2. $l<0$ 且 $r>0$ 时，我们插入 $[l+2\pi,2\pi],[0,r]$ 两段；
3. $l<2\pi$ 且 $r>2\pi$ 时，我们插入 $[l,2\pi],[0,r-2\pi]$ 两段。

具体代码实现如下：

```cpp
//const pi2 = 2*pi

if(jiao1 < 0 && jiao2 < 0)//这句话花了我一页的提交
{
	jiao1 += pi2, jiao2 += pi2;
}
if(jiao1 >= 0 && jiao2 <= pi2)
	cha(jiao1, jiao2);
else
{
	if(jiao1 < 0)
	{
		cha(jiao1+pi2, pi2);
		cha(0, jiao2);
	}
	else
	{
		cha(jiao1, pi2);
		cha(0, jiao2-pi2);
	}
}
```

### 整体代码

```cpp
//代码有些冗长，大佬勿喷
//蒟蒻无毒，请放心食用

#include <cstdio>
#include <cmath>
#include <algorithm>

using namespace std;

const int maxn = 10005;
const double pi = 3.1415926535897932;
const double pi2 = 2*pi;

struct Point
{
	double x, y;
};

inline double sqr(double x)
{
	return x*x;
}

inline double get_dist(Point x, Point y)
{
	return sqrt(sqr(x.x-y.x) + sqr(x.y-y.y));
}

struct Circle
{
	Point O;
	double r;
} c[maxn];

inline double get_dist(Circle x, Circle y)
{
	return get_dist(x.O, y.O);
}

int n;

struct Fugai
{
	double l, r;

	inline bool operator < (const Fugai& other) const
	{
		return l < other.l;
	}
} fugai[maxn];

int nown;
inline void cha(double l, double r)
{
	fugai[++nown] = (Fugai)
	{
		l, r
	};
}

bool gaif = false;//gaif = true表示该圆盘被上面的大圆盘完全覆盖

inline void jiao(Circle A, Circle B)
{
	double dist = get_dist(A, B);
	if(dist > A.r+B.r || A.r + dist < B.r)//没有任何覆盖
		return;
	if(dist + B.r < A.r)//如果被一个大圆盘完全覆盖，直接跳出
	{
		gaif = true;
		return;
	}
	double alpha = acos((sqr(B.r)+sqr(dist)-sqr(A.r))/(B.r*dist*2.));//上图中的角CAD
	double beta = atan2(A.O.y-B.O.y, A.O.x-B.O.x);//上图中的角CAE
	double jiao1 = beta-alpha;//线段覆盖中的l
	double jiao2 = beta+alpha;//线段覆盖中的r
	if(jiao1 < 0 && jiao2 < 0)//对极角的一些特判
	{
		jiao1 += pi2, jiao2 += pi2;
	}
	if(jiao1 >= 0 && jiao2 <= pi2)
		cha(jiao1, jiao2);
	else
	{
		if(jiao1 < 0)
		{
			cha(jiao1+pi2, pi2);
			cha(0, jiao2);
		}
		else
		{
			cha(jiao1, pi2);
			cha(0, jiao2-pi2);
		}
	}
}

inline double get_ans()
{
	double ans = 0;
	sort(fugai+1, fugai+nown+1);
	double lastr = fugai[1].l;
	for(int i = 1; i <= nown; ++i)
	{
		if(lastr >= fugai[i].r)
			continue;
		if(fugai[i].l > lastr)
			ans += fugai[i].r - fugai[i].l;
		else
			ans += fugai[i].r - lastr;
		lastr = fugai[i].r;
	}
	return ans;
}

int main()
{
	scanf("%d", &n);
	for(int i = 1; i <= n; ++i)
		scanf("%lf%lf%lf", &c[i].r, &c[i].O.x, &c[i].O.y);
	double ans = 0;
	for(int i = n; i; --i)
	{
		nown = 0;
		for(int j = n; j > i; --j)//枚举所有该圆盘之后的圆盘
		{
			jiao(c[j], c[i]);
			if(gaif)
				break;
		}
		if(gaif)
			gaif = false;
		else
			ans += (pi2-get_ans())*c[i].r;
		nown = 0;
	}
	printf("%.3f", ans);
	return 0;
}
```

---

## 作者：daklqw (赞：11)

看到这道题一开始的想法就是存一堆圆弧，然后该分裂的时候分裂，上界是$O(n^3)$，比较松，但是会比较难写

另一种想法就是每对圆之间求压住了哪些圆弧，最后再对每一个圆做一次线段覆盖，这种做法是$O(n^2\log n)$的

线段覆盖排个序就好，然后要求弧

我们将每段圆弧当做区间，用点的极角作下标，范围在$[0, 2\pi)$，当区间$[L, R)(L > R)$时，拆成两个区间$[L, 2\pi)$和$[0, R)$

对于两个圆$\odot i, \odot j (i \leq j)$它们的关系有三种情况：

1. 外离和外切，这种情况没有贡献
2. 相交
3. 内切和内含，这种情况只有$j$包含$i$的时候有贡献，即$r_i \geqslant r_j$

下面只讨论相交的情况

如图，假设$\overset{\LARGE{\frown}}{O_2AB}$被覆盖
![](https://cdn.luogu.com.cn/upload/pic/52599.png)

我们需要算出$\angle AO_2H$

由$r_1^2 - x^2 = r_2^2 - y^2$得到$r_1^2 - r_2^2 = (x + y)(x - y)$

因为$x + y$即两点距离，所以我们得到了$x - y$，从而得到了$y$，$\angle AO_2H = \arccos(\frac{y}{r_2})$

同时，我们还需要得到线段$O_2O_1$的极角大小，可以直接调用`atan2(x2 - x1, y2 - y1)`获得。因为`atan2`返回的是到$x$轴的角度，所以需要一步转化（其实不处理也没影响）

设$O_2O_1$极角大小为$A$，则我们得到的区间为$[A - \angle AO_2H, A + \angle AO_2H)$

然后就做完了，注意下各种细节

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <cmath>

const double PI = acos(-1);
const double PI2 = PI * 2;
const int MAXN = 1010;
const double eps = 1e-6;
int n;
double xs[MAXN], ys[MAXN], rs[MAXN];
typedef std::pair<double, double> PDD;
PDD cover[MAXN]; int bak;
inline double pows(double x) { return x * x; }
inline double absx(double x) { return x < 0 ? -x : x; }
inline double reduce(double x) { x += PI2, x = x - (int) (x / PI2) * PI2; return x; }
int main() {
	scanf("%d", &n);
	double ans = 0;
	for (int i = 1; i <= n; ++i)
		scanf("%lf%lf%lf", rs + i, xs + i, ys + i);
	for (int i = 1; i <= n; ++i) {
		bak = 0;
		for (int j = i + 1; j <= n; ++j) {
			double D = sqrt(pows(xs[i] - xs[j]) + pows(ys[i] - ys[j]));
			if (D >= absx(rs[i] + rs[j]) - eps) continue;
			if (D <= absx(rs[i] - rs[j]) + eps) {
				if (rs[j] > rs[i])
					cover[++bak] = PDD(0, PI2);
				continue;
			}
			double y = (D - (pows(rs[j]) - pows(rs[i])) / D) / 2;
			double angle = acos(y / rs[i]);
			double oa = reduce(atan2(xs[i] - xs[j], ys[i] - ys[j]) + PI / 2);
			double L = reduce(oa - angle), R = reduce(oa + angle);
			if (L - eps > R) cover[++bak] = PDD(L, PI2), cover[++bak] = PDD(0, R);
			else cover[++bak] = PDD(L, R);
		}
		std::sort(cover + 1, cover + 1 + bak);
		ans += PI2 * rs[i];
		double lstl = 0, lstr = 0;
		for (int j = 1; j <= bak; ++j) {
			const double fx = cover[j].first, sx = cover[j].second;
			if (fx > lstr) {
				ans -= (lstr - lstl) * rs[i];
				lstl = fx;
			}
			lstr = std::max(lstr, sx);
		}
		ans -= (lstr - lstl) * rs[i];
	}
	printf("%.3lf\n", ans);
	return 0;
}
```


---

## 作者：waaadreamer (赞：3)

这道题好坑啊，写代码的时候绝对不能心急，要慢慢想，仔细想，不然WAWAWA。

首先能够想到最暴力的方法自然就是枚举每个圆盘，计算它被覆盖了多少，用总周长减一下就是答案了。具体怎么办呢？

我们从x轴正半轴开始，顺时针旋转360度，刻度从-π转到π，均匀分布。这样，一个圆如果覆盖了另一个圆就对应了在数轴上-π到π这条线段上覆盖了一条线段。有一个特殊情况需要处理：比如从2顺时针转到刻度-1，显然是2→π(-π)→-1这样转的，为了不和从-1顺时针转到2重复，我们可以把这样的顺序拆成两条线段，分别是2→π和-π→1.

不失一般性，我们可以把左边的圆逆时针旋转，使圆心位于x轴上。

不难发现了，这样的话在原图中使用勾股定理求出d，然后就可以使用余弦定理求出α，这样覆盖线段的长度实际上是2α，但是还需要确定线段的位置。这其实也不难，在原图上面直接使用反三角函数arctan计算即可。

这样就把圆上覆盖的问题成功转化成了线段覆盖问题，这个可以把线段按照左端点排序，从左到右扫一遍，能合并的就合并即可。复杂度O(n^2logn)。

写程序的过程中有很多细节要注意啊，比如圆套圆，两个圆分离等等很多情况要处理，尤其是计算覆盖的这一部分，特别麻烦，最好的话还是进行分类讨论（比如本蒟蒻，分了象限讨论之后还是调试了一个小时的bug），double的eps也要处理一下。

（图片似乎上不来啊）

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <string.h>
#include <vector>
#include <math.h>
#include <queue>
#include <set>
#include <functional>
#include <time.h>
#define INF 0x3f3f3f3f
using namespace std;
typedef long long ll;

const int maxn = 1005;
const double eps = 1E-9, PI = 3.1415926535897932385;
struct Circle{double x, y, r;} cir[maxn];
typedef pair<double, double> Pdd;
Pdd seg[maxn];
int main(){
    int n; scanf("%d", &n);
    for(int i = 0; i < n; i++) scanf("%lf%lf%lf", &cir[i].r, &cir[i].x, &cir[i].y);
    double res = 0;
    for(int i = 0; i < n; i++){
        res += 2 * PI * cir[i].r;
        int tot = 0;
        for(int j = i + 1; j < n; j++){
            Circle c1 = cir[i], c2 = cir[j];
            c2.x -= c1.x, c2.y -= c1.y;
            c1.x = c1.y = 0;
            double d = sqrt(c2.x * c2.x + c2.y * c2.y);
            if(d + eps > c1.r + c2.r || d - eps < c1.r - c2.r) continue;
            if(d - eps < c2.r - c1.r){seg[tot++] = Pdd(-PI, PI); continue;}
            if(c2.x + eps > 0){
                double rot_ang = fabs(c2.x) < eps ? (c2.y > 0 ? PI / 2 : -PI / 2) : atan(c2.y / c2.x);
                double ang = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));
                double r1 = rot_ang + ang, r2 = rot_ang - ang;
                if(c2.y > 0){
                    r1 = r1 > 0 ? PI - r1 : -PI - r1;
                    r2 = r2 > 0 ? PI - r2 : -PI - r2;
                    if(r2 + eps > 0) seg[tot++] = Pdd(r1, r2);
                    else seg[tot++] = Pdd(-PI, r2), seg[tot++] = Pdd(r1, PI);
                } else {
                    r1 = r1 > 0 ? PI - r1 : -PI - r1;
                    r2 = r2 > 0 ? PI - r2 : -PI - r2;
                    if(r1 - eps < 0) seg[tot++] = Pdd(r1, r2);
                    else seg[tot++] = Pdd(-PI, r2), seg[tot++] = Pdd(r1, PI);
                }
            } else {
                double rot_ang = atan(c2.y / c2.x);
                double ang = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));
                double r1 = -ang - rot_ang, r2 = ang - rot_ang;
                if(c2.y > 0){
                    if(r2 - eps < PI) seg[tot++] = Pdd(r1, r2);
                    else seg[tot++] = Pdd(r1, PI), seg[tot++] = Pdd(-PI, r2 - 2 * PI);
                } else {
                    if(r1 + eps > -PI) seg[tot++] = Pdd(r1, r2);
                    else seg[tot++] = Pdd(-PI, r2), seg[tot++] = Pdd(r1 + 2 * PI, PI);
                }
            }
        }
        sort(seg, seg + tot);
        double beg = seg[0].first, end = seg[0].second;
        for(int j = 1; j < tot; j++){
            if(seg[j].first - eps < end){
                if(seg[j].second > end) end = seg[j].second;
            } else {
                res -= (end - beg) * cir[i].r;
                beg = seg[j].first, end = seg[j].second;
            }
        }
        if(tot > 0) res -= (end - beg) * cir[i].r;
    }
    printf("%.3lf", res);
    return 0;
}

```

---

## 作者：Dallda_Mavericks (赞：2)

# [题目传送门](https://www.luogu.com.cn/problem/P2510)

题目大意是计算几何，$n$ 个圆在平面上编号大的圆将编号小的圆覆盖求最后所有没有被覆盖的圆的边缘的总长度。

在做这道题之前有几个前置知识。

[极坐标系](https://baike.baidu.com/item/%E6%9E%81%E5%9D%90%E6%A0%87%E7%B3%BB/2381612?fr=ge_ala)：在平面内由极点、极轴和极径组成的坐标系。

如：在平面上取一点 $O$ 叫做极点，从 $O$ 出发引一条射线 $Ox$ 称为极轴。通常规定角度取逆时针方向为正。

[极角](https://baike.baidu.com/item/%E6%9E%81%E8%A7%92/12726003?fr=ge_ala)：在极坐标系中，平面上任何一点到极点的连线和极轴的夹角叫做极角。

那么，我们可以发现极角的大小为 $0\sim360$ 度（考虑正角）。

极角可以进行排序，（由小到大的那种），那么对于平面上一个点 $(x,y)$ 到极点的连线和极轴 $x$ 的夹角大小为 atan2($y \div x$）。

atan2 指的 $tan$ 的[反函数](https://baike.baidu.com/item/%E5%8F%8D%E5%87%BD%E6%95%B0/91388?fr=ge_ala)是[方位角](https://baike.baidu.com/item/%E6%96%B9%E4%BD%8D%E8%A7%92/493239?fr=ge_ala)。

atan2 比 atan 稳定，所以我们使用 atan2。

但是我们要求出极角来，这个返回的是方位角，如果当前角度为正，那么就是极角， 如果为负，我们需要将其加上 $2\pi$，就变成极角了。

接下来就可以做这道题了，首先考虑两圆相交如何求夹角？

[余弦定理](https://baike.baidu.com/link?url=1rjG4sFIuCO_VFCjDPtxBKTsyvV7vZ0ExD1g8F6PyfFyin-EwGdUFWjXvtBXYW2vAgjcH3QDgB3fHf22jcgtGSb6Z9cig5mCOlWUXY1HoC1HtKIE2J6Pq2aZurS9L5wQ)和[acos函数](https://baike.baidu.com/item/acos/10931269?fr=ge_ala#1)即可。$n^2$ 求交，然后我们发交的地方只算一次，所以可以利用极角来做。

求出所有的极角之后，按极角排序，然后就是直线的覆盖问题。

注意一下覆盖弧度范围跨越 $0$ 和 $2\pi$ 的处理。
```cpp
#include <bits/stdc++.h>
#define N 1010
#define squ(x) ((x) * (x))
using namespace std;
const double pi = acos(-1);
struct data
{
    double pl , pr;
    bool operator<(const data &a)const {return pl < a.pl;}
}a[N << 1];
double x[N] , y[N] , r[N];
int tot;
int main()
{
    int n , i , j;
    double afa , beta , d , last , ans = 0;
    scanf("%d" , &n);
    for(i = 1 ; i <= n ; i ++ ) scanf("%lf%lf%lf" , &r[i] , &x[i] , &y[i]);
    for(i = 1 ; i <= n ; i ++ )
    {
        ans += 2 * pi * r[i];
        tot = 0;
        for(j = i + 1 ; j <= n ; j ++ )
        {
            tot ++ , d = squ(x[i] - x[j]) + squ(y[i] - y[j]);
            if(squ(r[i] + r[j]) <= d) a[tot].pl = a[tot].pr = 0;
            else if(squ(r[i] - r[j]) >= d)
            {
                if(r[i] > r[j]) a[tot].pl = a[tot].pr = 0;
                else a[tot].pl = 0 , a[tot].pr = 2 * pi;
            }
            else
            {
                afa = acos((r[i] * r[i] + d - r[j] * r[j]) / (2 * r[i] * sqrt(d)));
                beta = atan2(y[j] - y[i] , x[j] - x[i]);
                if(beta < 0) beta += 2 * pi;
                a[tot].pl = beta - afa , a[tot].pr = beta + afa;
                if(a[tot].pl < 0) tot ++ , a[tot].pl = a[tot - 1].pl + 2 * pi , a[tot - 1].pl = 0 , a[tot].pr = 2 * pi;
                else if(a[tot].pr > 2 * pi) tot ++ , a[tot].pr = a[tot - 1].pr - 2 * pi , a[tot - 1].pr = 2 * pi , a[tot].pl = 0;
            }
        }
        sort(a + 1 , a + tot + 1);
        last = -1;
        for(j = 1 ; j <= tot ; j ++ )
        {
            if(a[j].pr <= last) continue;
            if(a[j].pl > last) ans -= (a[j].pr - a[j].pl) * r[i];
            else ans -= (a[j].pr - last) * r[i];
            last = a[j].pr;
        }
    }
    printf("%.3lf\n" , ans);
    return 0;//完美收官QwQ
}
```
既然都复制了，何必在意留个赞呢再走呢？

---

## 作者：HZX001 (赞：0)

### 对于每个圆，我们单独计算它被覆盖的周长是多少。

只有相交的情况需要考虑，我们需要知道相交的那段圆弧的角度，发现其中一个交点和两个圆的圆心可以构成一个三角形且三边都已经知道了，那么我们可以根据余弦定理计算出这段圆弧的余弦进而用 $\operatorname{acos}$ 计算出角度。

然而现在有个尴尬的问题是一段圆弧可能会被多次覆盖。那么我们考虑把相交的圆弧的左右端点用极角来表示，并把这个看成一条线段，那么最后只要求出线段覆盖就行了。

顺便注意转化为极角的时候如果极角是负的要加上 $2π$ ，如果这时候     $l>r$，就拆成 $[l,2π]+[2π,r]$ 的形式。
# AC code
```cpp
#include<bits/stdc++.h>
#define R register
#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)
#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
using namespace std;
char buf[1<<21],*p1=buf,*p2=buf;
inline char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
int read(){
    R int res,f=1;R char ch;
    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);
    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');
    return res*f;
}
double readdb()
{
    R double x=0,y=0.1,f=1;R char ch;
    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);
    for(x=ch-'0';(ch=getc())>='0'&&ch<='9';x=x*10+ch-'0');
    for(ch=='.'&&(ch=getc());ch>='0'&&ch<='9';x+=(ch-'0')*y,y*=0.1,ch=getc());
    return x*f;
}
const int N=2005;const double Pi=acos(-1.0);
struct point{double r,x,y;}p[N];
struct node{
    double l,r;
    node(){}
    node(R double ll,R double rr):l(ll),r(rr){}
    inline bool operator <(const node &b)const{return l<b.l;}
}st[N];
int n,top;double res;
inline double dis(R int i,R int j){return sqrt((p[i].x-p[j].x)*(p[i].x-p[j].x)+(p[i].y-p[j].y)*(p[i].y-p[j].y));}
inline int in(R int i,R int j){return p[j].r>=p[i].r+dis(i,j);}
void calc(int pos){
    fp(i,pos+1,n)if(in(pos,i))return;
    top=0;
    fp(i,pos+1,n){
        R double d=dis(pos,i);if(in(i,pos)||p[i].r+p[pos].r<=d)continue;
        R double t=acos((d*d+p[pos].r*p[pos].r-p[i].r*p[i].r)/(2*p[pos].r*d));
        R double b=atan2(p[i].y-p[pos].y,p[i].x-p[pos].x);
        st[++top]=node(b-t,b+t);
        st[top].l<0?st[top].l+=2*Pi:0;
        st[top].r<0?st[top].r+=2*Pi:0;
        st[top].l>st[top].r?(st[top+1]=node(0,st[top].r),st[top++].r=2*Pi):0;
    }
    sort(st+1,st+1+top);
    R double now=0,tmp=0;
    fp(i,1,top)now<st[i].l?(tmp+=st[i].l-now,now=st[i].r):cmax(now,st[i].r);
    res+=p[pos].r*(tmp+2*Pi-now);
}
int main(){
    n=read();
    fp(i,1,n)p[i].r=readdb(),p[i].x=readdb(),p[i].y=readdb();
    fp(i,1,n)calc(i);
    printf("%.3lf\n",res);
    return 0;
}
```


---


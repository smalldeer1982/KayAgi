# [HAOI2011] 防线修建

## 题目描述

近来A国和B国的矛盾激化，为了预防不测，A 国准备修建一条长长的防线，当然修建防线的话，肯定要把需要保护的城市修在防线内部了。  

可是A国上层现在还犹豫不决，到底该把哪些城市作为保护对象呢？又由于 A 国的经费有限，所以希望你能帮忙完成如下的一个任务：

1、给出你所有的 A 国城市坐标

2、A国上层经过讨论，考虑到经济问题，决定取消对 $u$ 城市的保护，也就是说 $u$ 城市不需要在防线内了

3、A国上层询问对于剩下要保护的城市，修建防线的总经费最少是多少

你需要对每次询问作出回答。注意单位长度的防线花费为 $1$。

A 国的地形是这样的，形如下图，$x$ 轴是一条河流，相当于一条天然防线，不需要你再修建。

![](https://cdn.luogu.com.cn/upload/image_hosting/rkaw5kay.png)

A 国总是有两个城市在河边，一个点是 $(0,0)$，一个点是 $(n,0)$，其余所有点的横坐标均在 $(0,n)$ 范围内，纵坐标均大于0。  
A国有一个不在 $(0,0)$ 和 $(n,0)$ 的首都。$(0,0),(n,0)$ 和首都这三个城市是一定需要保护的。

上图中，A,B,C,D,E 点为 A 国城市，且目前都要保护，那么修建的防线就会是 A-B-C-D，花费也就是线段 AB 的长度+线段 BC 的长度+线段 CD 的长度,如果，这个时候撤销 B 点的保护，那么防线变成下图

![](https://cdn.luogu.com.cn/upload/image_hosting/cd7dpmcj.png)


## 说明/提示

【数据范围】   
对于 $30\%$ 的数据，$1\le m,q \le 1000$；   
对于 $100\%$ 的数据，$1\le m \le 10^5$，$1\le q \le 2 \times 10^5$，$1 < n \le 10^4$。

所有点的坐标范围均在 $10^4$ 以内, 数据保证没有重点。

---

~~$\text{upd 2022.7.21}$：新增加一组 Hack 数据。~~ 该数据有误，已经被移除。

## 样例 #1

### 输入

```
4 2 1                                
2                                 
1 2                               
3 2                               
5                                 
2
1 1
2
1 2
2```

### 输出

```
6.47
5.84
4.47```

# 题解

## 作者：OIer_Tan (赞：6)

[洛谷传送门](https://www.luogu.com.cn/problem/P2521)

动态凸包板子。

## 思路

删点不好做，考虑离线变成加点。

由于我是从 CF70D 过来的，所以直接改。

然而这里有很多需要注意的地方：
* 同 CF70D，有同横坐标要删掉再加。
* 加入时要把之前相邻两点的长度减掉。
* 离线后要将没有被删过的点加上。

具体细节可以看代码。

## 代码

```cpp
#include<bits/stdc++.h>

#ifndef CRT
#define endl '\n' 
#endif

using namespace std ;

typedef long long ll ;
typedef unsigned long long ull ;
typedef long double ld ;

struct point 
{
	ll x , y ;
	explicit point ( const ll & x = 0 , const ll & y = 0 ) : x ( x ) , y ( y ) {}
	friend bool operator < ( const point & a , const point & b )
	{
//		if ( a.x == b.x )
//		{
//			return a.y < b.y ;
//		}
		return a.x < b.x ;
	}
};

ld det ( const point & a , const point & b )
{
	return a.x * b.y - b.x * a.y ; 
}

ld dis ( const point & a , const point & b )
{
	return hypot ( a.x - b.x , a.y - b.y ) ;
}

ll q ;

ld ans = 0 ;

set <point> up , down ;

bool check_up ( const point & s )
{
	auto it = up.lower_bound ( s ) ;
	if ( it == up.end () )
	{
		return 0 ;
	}
	if ( it -> x == s.x )
	{
		return s.y <= ( it -> y ) ;
	}
	if ( it == up.begin () )
	{
		return 0 ;
	}
	auto it2 = prev ( it ) ;
	return det ( point ( it -> x - it2 -> x , it -> y - it2 -> y ) , point ( s.x - it2 -> x , s.y - it2 -> y ) ) <= 0 ;
}

ld query ()
{
	return ans ;
}

bool remove_up ( const set <point>::iterator it )
{
	if ( it == up.begin () )
	{
		return 0 ;
	}
	auto it2 = it , it3 = it ;
	it2 -- , it3 ++ ;
	if ( it3 == up.end () )
	{
		return 0 ;
	}
	if ( det ( point ( it -> x - it2 -> x , it -> y - it2 -> y ) , point ( it3 -> x - it2 -> x , it3 -> y - it2 -> y ) ) >= 0 )
	{
		// cout << "DEL" << it -> x << " " << it -> y << endl ;
		// cout << ans << " " << dis ( *it2 , *it3 ) << " " << dis ( *it , *it3 ) << " " << dis ( *it , *it2 ) << endl ;
		ans = ans + dis ( *it2 , *it3 ) - dis ( *it , *it2 ) - dis ( *it , *it3 ) ;
		up.erase ( it ) ;
		return 1 ;
	}
	return 0 ;
}

void update_up ( const point & s )
{
	if ( check_up ( s ) )
	{
		return ;
	}
	{
		if ( up.lower_bound ( point ( s.x , -1e9 ) ) != up.upper_bound ( point ( s.x , 1e9 ) ) )
		{
			auto it = up.lower_bound ( point ( s.x , -1e9 ) ) ;
			if ( it != up.begin () )
			{
				ans -= dis ( * prev ( it ) , * it ) ;
			}
			if ( it != prev ( up.end () ) )
			{
				ans -= dis ( * it , * next ( it ) ) ;
			}
			if ( it != up.begin () && it != prev ( up.end () ) )
			{
				ans += dis ( * prev ( it ) , * next ( it ) ) ;
			}
			up.erase ( it ) ;
		}
	}
	auto it = up.insert ( s ).first , it2 = it ;
	if ( it != up.begin () && next ( it ) != up.end () )
	{
		ans -= dis ( * prev ( it ) , * next ( it ) ) ;
	}
	if ( it != up.begin () )
	{
		it2 -- ;
		ans += dis ( * it2 , * it ) ;
		while ( remove_up ( it2 ++ ) ) it2 -- ;
	}
	// cout << "---" << endl ;
	if ( ++ it2 != up.end () )
	{	
		ans += dis ( * it , * it2 ) ;
		while ( remove_up ( it2 -- ) ) ++ it2 ;
	}
}

const ll N = 1e5 + 5 ;

ll n , m ;

point s , p [N] ;

struct node
{
	ll opt ;
	ll u ;
} que [N] ;

ld ansq [N] ;

bool flag [N] ;

int main ()
{
	// freopen ( ".in" , "r" , stdin ) ;
	// freopen ( ".out" , "w" , stdout ) ;
	ios::sync_with_stdio ( 0 ) ;
	cin.tie ( 0 ) ;
	cout.tie ( 0 ) ;
	cin >> n >> s.x >> s.y ;
	cin >> m ;
	for ( ll i = 1 ; i <= m ; i ++ )
	{
		cin >> p [i].x >> p [i].y ;
	}
	update_up ( point ( 0 , 0 ) ) ;
	update_up ( point ( n , 0 ) ) ;
	update_up ( s ) ;
	cin >> q ;
	for ( ll i = 1 ; i <= q ; i ++ )
	{
		cin >> que [i].opt ;
		if ( que [i].opt & 1 )
		{
			cin >> que [i].u ;
			flag [que [i].u] = 1 ;
		}
	}
	for ( ll i = 1 ; i <= m ; i ++ )
	{
		if ( ! flag [i] )
		{
			update_up ( p [i] ) ;
		}
	}
	for ( ll i = q ; i ; i -- )
	{
		if ( que [i].opt & 1 )
		{
			update_up ( p [que [i].u] ) ;
		}
		else
		{
			ansq [i] = query () ;
		}
		// cout << "###" << endl ;
		// for ( auto i : up )
		// {
		// 	cout << i.x << " " << i.y << endl ;
		// }
	}
	for ( ll i = 1 ; i <= q ; i ++ )
	{
		if ( que [i].opt == 2 )
		{
			// cout << ansq [i] << endl ;
			printf ( "%.2Lf\n" , ansq [i] ) ;
		}
	}
	return 0 ;
}
```

---

## 作者：TernaryTree (赞：4)

动态凸包（壳）。

首先把所有询问离线之后倒着做，删点变为加点。

考虑做一个凸包的过程，现在主流的 Andrew 算法的思想在于，按 $x$ 排序后依次维护单调栈加入其中。

下面默认维护上凸壳。那么我们现在加入一个点 $u$，找到凸壳中其 $x$ 的前驱 $pre$ 与后继 $nxt$，要么它在凸壳下边（即 $pre\to u\to nxt$ 叉积 $\le 0$），不需要加入，直接返回；否则它在凸壳上面，此时我们左右两边都要更新。维护一个指针，从 $pre$ 一直向前找并且删掉不合法的边，直到合法退出，右边同理。

这是一个图形化的过程：

![](https://cdn.luogu.com.cn/upload/image_hosting/b6jk2y6z.png)

具体地，我们发现只需要快速找到一个前驱和后继即可。于是使用一个 set 进行维护。

容易发现，这样暴力去判断并且删点，每个点最多被加一次，删一次。所以总复杂度 $\Theta(n\log n)$。

---

对代码进行一些解释：

```cpp
typedef double db;
const db inf = 1e100;
const db fni = 1e10;
struct Point {
	db x, y;
	bool isLim = 0;
	Point() = default;
	Point(db x, db y): x(x), y(y) {}
	Point operator+ (Point b) { return {x + b.x, y + b.y}; }
	Point operator- (Point b) { return {x - b.x, y - b.y}; }
	db operator* (Point b) { return x * b.x + y * b.y; }
	bool operator< (Point b) const { return x != b.x ? x < b.x : y < b.y; }
};
typedef pair<db, Point> pd;
db cross(Point u, Point v) { return u.x * v.y - u.y * v.x; }
db cross(Point u, Point v, Point w) { return cross(w - v, v - u); }
db slope(Point u, Point v) { return (v.y - u.y) / (v.x - u.x); }

set<Point> p;
db C = 0;

void init() {
	p.clear();
	Point L = {-fni, -inf}, R = {fni, -inf};
	L.isLim = R.isLim = true;
	p.insert(L), p.insert(R);
}
```

为了防止 set 中 `prev(s.begin())` 此类的野指针出现，我们添加两个边界点，使其恒保持在 set 的最左端和最右端，这样挪动指针时会方便一点，细节更好处理；而对这两个点我们也要打上标记，避免算凸包周长时被计入答案。

代码中 `cross` 表示叉积。`C` 表示实时维护的周长，`init` 表示把边界点加入凸壳中。

```cpp
void update(Point u, Point v, int sgn) {
	if (u.isLim || v.isLim) return;
	C += sgn * sqrt((u - v).x * (u - v).x + (u - v).y * (u - v).y);
}
```

更新凸壳周长，即将 $u,v$ 之间的距离从总周长中加上/减去，同时特判了边界点的情况。

```cpp
void insert(Point u) {
	p.insert(u);
	auto it = p.find(u);
	auto pre = prev(it), nxt = next(it);
	if (cross(*pre, *it, *nxt) <= 0) {
		p.erase(it);
		return;
	}
	update(*pre, *nxt, -1);
	update(*pre, *it, 1);
	update(*it, *nxt, 1);
	while (pre != p.begin()) {
		auto pp = prev(pre);
		if (cross(*pp, *pre, *it) <= 0) {
			update(*pp, *it, 1);
			update(*pp, *pre, -1);
			update(*pre, *it, -1);
			p.erase(pre);
		} else break;
		pre = pp;
	}
	while (nxt != --p.end()) {
		auto qq = next(nxt);
		if (cross(*it, *nxt, *qq) <= 0) {
			update(*it, *qq, 1);
			update(*it, *nxt, -1);
			update(*nxt, *qq, -1);
			p.erase(nxt);
		} else break;
		nxt = qq;
	}
}
```

插入一个点，两边都用指针去更新凸包和周长。

完整代码：

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int maxn = 1e6 + 10;

struct CvHull {
	typedef double db;
	const db inf = 1e100;
	const db fni = 1e10;
	struct Point {
		db x, y;
		bool isLim = 0;
		Point() = default;
		Point(db x, db y): x(x), y(y) {}
		Point operator+ (Point b) { return {x + b.x, y + b.y}; }
		Point operator- (Point b) { return {x - b.x, y - b.y}; }
		db operator* (Point b) { return x * b.x + y * b.y; }
		bool operator< (Point b) const { return x != b.x ? x < b.x : y < b.y; }
	};
	typedef pair<db, Point> pd;
	db cross(Point u, Point v) { return u.x * v.y - u.y * v.x; }
	db cross(Point u, Point v, Point w) { return cross(w - v, v - u); }
	db slope(Point u, Point v) { return (v.y - u.y) / (v.x - u.x); }
	
	set<Point> p;
	db C = 0;
	
	void init() {
		p.clear();
		Point L = {-fni, -inf}, R = {fni, -inf};
		L.isLim = R.isLim = true;
		p.insert(L), p.insert(R);
	}
	
	void update(Point u, Point v, int sgn) {
		if (u.isLim || v.isLim) return;
		C += sgn * sqrt((u - v).x * (u - v).x + (u - v).y * (u - v).y);
	}
	
	void insert(Point u) {
		p.insert(u);
		auto it = p.find(u);
		auto pre = prev(it), nxt = next(it);
		if (cross(*pre, *it, *nxt) <= 0) {
			p.erase(it);
			return;
		}
		update(*pre, *nxt, -1);
		update(*pre, *it, 1);
		update(*it, *nxt, 1);
		while (pre != p.begin()) {
			auto pp = prev(pre);
			if (cross(*pp, *pre, *it) <= 0) {
				update(*pp, *it, 1);
				update(*pp, *pre, -1);
				update(*pre, *it, -1);
				p.erase(pre);
			} else break;
			pre = pp;
		}
		while (nxt != --p.end()) {
			auto qq = next(nxt);
			if (cross(*it, *nxt, *qq) <= 0) {
				update(*it, *qq, 1);
				update(*it, *nxt, -1);
				update(*nxt, *qq, -1);
				p.erase(nxt);
			} else break;
			nxt = qq;
		}
	}
} G;

struct query {
	int op, x;
	double ans;
};

int n, x, y;
int m, q;
CvHull::Point a[maxn]; 
int vis[maxn];
query qs[maxn];

signed main() {
	cin >> n >> x >> y;
	G.init();
	G.insert({0, 0});
	G.insert({n, 0});
	G.insert({x, y});
	cin >> m;
	for (int i = 1; i <= m; i++) cin >> a[i].x >> a[i].y, vis[i] = 1;
	cin >> q;
	for (int i = 1; i <= q; i++) {
		cin >> qs[i].op;
		if (qs[i].op == 1) {
			cin >> qs[i].x;
			vis[qs[i].x] = 0;
		}
	}
	for (int i = 1; i <= m; i++) if (vis[i]) G.insert(a[i]);
	for (int i = q; i; i--) {
		if (qs[i].op == 1) {
			vis[qs[i].x] = 1;
			G.insert(a[qs[i].x]);
		} else {
			qs[i].ans = G.C;
		}
	}
	for (int i = 1; i <= q; i++) {
		if (qs[i].op == 2) cout << fixed << setprecision(2) << qs[i].ans << endl;
	}
	return 0;
}
```

---

## 作者：Enzymii (赞：3)

看到各位dalao都用的是x-y坐标排序...

这里就来安利一发自己的极角序..

极角序最大的好处就是不仅可以处理凸壳, 还可以处理整个凸包.

比如有一道例题是CF70D, 是动态凸包裸题, 边界条件要比这题扯淡..

当然写题解并不只是因为极角序, 还因为一些C++的奇怪操作让我特别想吐槽.


说下大体思路,

首先肯定是要将所有操作反过来 变删除为插入 然后就是用平衡树维护凸包了嘛

只不过这里用的比较是极角序而已

学过半平面交的人大概对极角序很熟悉了.

不少人都喜欢用atan2, 但是我一直喜欢用叉积.

总觉得atan2会出一些奇怪的精度问题.

这样就要分x轴上下来进行讨论, 不然会出问题.

这里只要求上凸壳所以极角序都可以简化, 不用判断x轴上下了

而且出题人做了各种各样的保证就比较舒服了...

很多条件就不用考虑了, 比如要把set首尾相接之类的就用不到了


那么大体来说就是这么一个比较函数:

```cpp
inline bool operator <(const vec &A,const vec &B){
    if(A.x==B.x&&A.y==B.y) return 0;
    vec a=A-sq,b=B-sq;
    int d=dcmp(a*b);
    if(!d){
        int dd=dcmp(len(a)-len(b));
        if(!dd) return dcmp(a*vec(0,1))>0;
        return dd>0;
    } return d>0;
}
```
因为\*弱排序原理\*导致这个函数写的特别扭曲..

其中这个sq是个全局变量, 我们只要保证这是一个一直在凸包中的点就ok

而刚开始会给一个三角形[(0,0),(n,0),(x,y)], 所以($\frac n2$,0)肯定是在凸包上的, 而且这样的a,b向量都在x轴的上方, 极角序也好写. 所以令sq=(n\*0.5,0)就非常合适了.


周长的话就加点的时候顺便维护了就行.

具体的细节和一些吐槽可以见我的[blog](http://blog.csdn.net/enzymii/article/details/79108684)

~~(其实你写题解的目的就是为了安利blog吧~~


---

## 作者：_Wind_Leaves_ShaDow_ (赞：1)

注意到我们静态求凸包时，一个点只要现在不在凸包边上则接下来不可能回到凸包边上，从而确保时间复杂度的正确。所以同理，对于删点问题，我们考虑离线下来从后往前做加点，来确保复杂度正确。

出题人良心，只要我们做上凸壳，而且给了边界并且确保了凸壳中至少有三个点。这会让我们省去很多特判。

考虑如何加入一个点，在静态求凸包时我们按照 $x$ 坐标为第一关键字，$y$ 坐标为第二关键字进行了排序，所以在这里我们考虑用 set 来维护这个凸包，方便我们更好地查找插入的这个点应该在哪个范围被插入。

现在我们找到了对于待插入点 $p$，它左边的第一个凸壳上的点 $a$ 和右边的第一个凸壳上的点 $b$。有两种情况：

- $p$ 在凸壳内。我们不需要管这种情况。
- $p$ 在凸壳外。显然此时 $p$ 会作为凸壳的一部分，我们断开 $a,b$ 之间的连边并分别向 $p$ 连一条边。

还有什么没做？

现在我们需要维护凸壳的凸性。对于 $p$，往前找 $a$ 和 $a$ 的前驱 $b$，如果我们发现 $a$ 位于 $bp$ 连线内则 $a$ 应该扔去，断开 $a,b$ 和 $a,p$ 的连线并连接 $bp$，往后更新同理。

同样的每个点只会被加进来一次，扔出去一次，加上 set 本身自带的复杂度，总复杂度是 $O(n\log n)$。

答案长度的维护可以在进行断边连边操作的时候维护。

带 set 的代码一般都难写难调，耐心一点总会有回报的。

```cpp
#include <bits/stdc++.h>
#define int long long
#define Rg register
#define Ri Rg int
#define Il inline
#define vec vector
#define pb push_back
#define fi first
#define se second
#define IT ::iterator
#define lowbit(x) ((x)&(-x))

using namespace std;

typedef double db;
typedef pair<int,int> pii;
const int N=1e5,Inf=1e9;
const db eps=1e-9,pi=3.1416;

int n,m,Q,op[N+5],dx[N+5];
bool del[N+5];
db px,py,ans[N+5],Ans;
struct Vec{
	db x,y;
	Il Vec operator -(const Vec &a){return {x-a.x,y-a.y};}
	Il bool operator <(const Vec &vtmp)const{return x==vtmp.x?y<vtmp.y:x<vtmp.x;}
}pt[N+5];
set<Vec>s;

Il db Cro(Vec a,Vec b){return a.x*b.y-a.y*b.x;}

Il db dir(Vec a,Vec b,Vec c){return Cro(b-a,c-a);}//判断拐的方向，上凸壳的连线是往右拐的，可以用这个判断满不满足凸性

Il db dis(Vec a,Vec b){return sqrt(1.0*(a.x-b.x)*(a.x-b.x)+1.0*(a.y-b.y)*(a.y-b.y));}

Il void add(Vec a){//代码可读性低的。
	set<Vec>IT it=s.upper_bound(a),It=it,tmp;It--;
	if(dir(*It,a,*it)>-eps)return;
	It=s.insert(a).fi;It--;it=s.upper_bound(a);
	Ans=Ans-dis(*It,*it)+dis(*It,a)+dis(*it,a);
	for(;It!=s.begin();It=s.find(a),It--){
		tmp=It;tmp--;
		if(dir(*tmp,*It,a)<eps)break;
		Ans=Ans-dis(*tmp,*It)-dis(*It,a)+dis(*tmp,a);
		s.erase(It);
	}
	for(it=s.upper_bound(a);it!=s.find({n,0});it=s.upper_bound(a)){
		tmp=it;tmp++;
		if(dir(a,*it,*tmp)<eps)break;
		Ans=Ans-dis(a,*it)-dis(*it,*tmp)+dis(a,*tmp);
		s.erase(it);
	}
	return;
}

signed main(){
	scanf("%d%lf%lf%d",&n,&px,&py,&m);
	s.insert({0,0}),s.insert({px,py}),s.insert({n,0});Ans=dis({0,0},{px,py})+dis({px,py},{n,0});
	for(Ri i=1;i<=m;i++)scanf("%lf%lf",&pt[i].x,&pt[i].y);scanf("%d",&Q);
	for(Ri i=1;i<=Q;i++){scanf("%d",&op[i]);if(op[i]==1)scanf("%d",&dx[i]),del[dx[i]]=1;}
	for(Ri i=1;i<=m;i++)if(!del[i])add(pt[i]);
	for(Ri i=Q;i;i--){
		if(op[i]==1)add(pt[dx[i]]);
		else ans[i]=Ans;
	}
	for(Ri i=1;i<=Q;i++)if(op[i]==2)printf("%.2lf\n",ans[i]);
	return 0;
}
```

---

## 作者：H_D_NULL (赞：1)

## 动态凸包模板题
对于动态凸包，常用的方法有用平衡树或STL（通常为set，map）维护上下凸壳或极角。由于平衡树的代码量很大，对于不熟悉的蒟蒻（我）来说又很难调试，水平序在处理一些特殊问题时又过于复杂，所以这里上一发用set维护极角序的代码。

注：set的本质也是平衡树，所以解决动态凸包问题的实质是用支持快速插入的数据结构维护一般凸包问题。

### 对于本题

由于只有撤销操作，所以可以将操作反向变为插入操作。

在更新凸包的同时更新最短周长，具体操作见代码。

本题我在处理极角序是采用的 atan2，为了避免精度问题，我在选取原点的时候随机了三个权值（然而好像并没有什么用）。总之，极角序的精度一直是一个问题，无论是用优化原点或者采用叉积的方式，都会有相应的利弊，大佬们随意。

#### 完


------------

_Talk is cheap, show me the code_

```cpp
#include<bits/stdc++.h>
#define ll long long
#define re register
#define mn 100005
using namespace std;

inline ll read(){
    re ll x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}

struct dr{ //乱取的变量名 
	ll x,y;
	double Ang;//atan2 
	ll operator *(const dr b)const{return x*b.y-y*b.x;} //便于算叉积 
	dr operator -(const dr b)const{return dr{x-b.x,y-b.y};} //向量减法 
	bool operator <(const dr b)const{return Ang<b.Ang;}
}A,B,C;

ll a[mn][2],c[mn];
int n,p,m;
bool v[mn];
double X,Y,ans[mn],len;
set<dr> S;
#define IT set<dr>::iterator

inline dr Pre(dr x){
	if(S.count(x)>0) return x;
	IT p=S.lower_bound(x);
	if(p==S.begin()) p=S.end();
	return *--p;
}//前驱 

inline dr Nxt(dr x){
	IT p=S.upper_bound(x);
	if(p==S.end()) p=S.begin();
	return *p;
}//后继 

inline ll Cross(dr x,dr y,dr z){
	return (x-z)*(y-z);
}//叉积 

inline double Dis(dr x,dr y){
	return sqrt(double((x.x-y.x)*(x.x-y.x)+(x.y-y.y)*(x.y-y.y)));
}//距离 

inline void insert(dr x){
	if(Cross(x,Nxt(x),Pre(x))<=0) return;
	len-=Dis(Nxt(x),Pre(x));//先删掉一条必删的边 
	while(true){
		//向前驱方向拓展 
		dr p1=Pre(x),p2;
		S.erase(p1); p2=Pre(x);
		//小细节:先删点再判断,不用删的点加回即可 
		if(Cross(x,p2,p1)>=0){
			len+=Dis(x,p1);
			S.insert(p1);
			break;
		}
		len-=Dis(p2,p1);
	}
	while(true){
		//向...方向拓展 
		dr p1=Nxt(x),p2;
		S.erase(p1); p2=Nxt(x);
		if(Cross(x,p2,p1)<=0){
			len+=Dis(x,p1);
			S.insert(p1);
			break;
		}
		len-=Dis(p2,p1);
	}
	S.insert(x);
}

int main(){
	srand(time(0));
	 
	A=dr{0,0,0};
	B=dr{read(),0,0};
	C=dr{read(),read(),0};
	//初始点 
	ll xx=rand(),yy=rand(),zz=rand(),tt=xx+yy+zz;
	X=1.0*(xx*A.x+yy*B.x+zz*C.x)/tt;
	Y=1.0*(xx*A.y+yy*B.y+zz*C.y)/tt;
	//随机权值,用重心的思想确定一个原点 
	A.Ang=atan2(A.y-Y,A.x-X);
	B.Ang=atan2(B.y-Y,B.x-X);
	C.Ang=atan2(C.y-Y,C.x-X);
	S.insert(A),S.insert(B),S.insert(C);
	len=Dis(B,C)+Dis(A,C);
	//初始化 
	n=read();
	for(re int i=1;i<=n;i++){
		a[i][0]=read();
		a[i][1]=read();
	}
	m=read();
	for(re int i=1,l;i<=m;i++){
		l=read();
		if(l==1){
			c[i]=read();
			v[c[i]]=true;
		}
	}
	//题意 
	for(re int i=1;i<=n;i++){
		if(!v[i]){
			insert(dr{a[i][0],a[i][1],atan2(a[i][1]-Y,a[i][0]-X)});
		}
	}
	//将始终不会撤销的点加入凸包 
	for(re int i=m;i>=1;i--){
		if(c[i]){
			insert(dr{a[c[i]][0],a[c[i]][1],atan2(a[c[i]][1]-Y,a[c[i]][0]-X)});
		}
		else{
			ans[++p]=len;
		}
	}
	for(re int i=p;i>=1;i--){
		printf("%.2lf\n",ans[i]);
	}
	//反向插入后反向输出 
	return 0;
}
```
注：我看了一下我的代码跑得挺慢，所以伸手党还是去看其他题解吧。

---

## 作者：JimmyLee (赞：0)

# 题意

给定若干个点，实现下列操作：

- 删除一个点。
- 查询上凸包的周长。

# 分析

建议先完成[【模板】二维凸包](https://www.luogu.com.cn/problem/P2742)。

对于这个删除操作，我们没有好的方法去在线维护它。

考虑离线询问。

这样删除操作就变成了插入操作。

---

插入一个新点有如下两种情况：

- 新点在凸包内。
- 新点在凸包外。

我们回忆一下 Andrew 算法的过程：先将点按 $x$ 排序，然后单调栈维护凸包。

这给了我们启示，如果一个点 $(x_i,y_i)$ 能加入凸包中，那么原凸包中和直线 $x=x_i$ 相交的边一定被删除。

将原点集按 $x$ 排序，这条边连接的两个点显然就是 $(x_i,y_i)$ 的前驱和后继。

考虑用平衡树维护，判断点 $(x_i,y_i)$ 与该边的位置关系即可。

在凸包内那么就不用更新凸包。

---

考虑该点在凸包外的情况。

我们先将该点加入凸包并更新答案。

我们从该点出发，向前后分别扫一遍，将不符合凸包性质的点删除并更新答案。

如果一个点符合凸包性质，那么显然它前或后的点也满足凸包性质，就结束循环。

每个点最多进一次凸包点集，也最多出一次凸包点集，时间复杂度 $O(m\log m)$。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 100005

struct vec
{
    double x, y;
    vec(double X=0, double Y=0): x(X), y(Y) {}
    friend vec operator-(vec a, vec b) {return {a.x-b.x, a.y-b.y};    }
    friend int cross    (vec a, vec b) {return a.x*b.y-a.y*b.x;       }
    auto operator<=>    (vec b) const  {return x==b.x?y<=>b.y:x<=>b.x;}
    double length       ()             {return sqrt(x*x+y*y);         }
};

set<vec> s;
double ans;

bool chk(vec A)
{
    auto it=s.lower_bound(A);
    vec B=*it, C=*--it;
    return cross(B-A, B-C)<=0;
}

auto pre(set<vec>::iterator it) {return --it;}
auto aft(set<vec>::iterator it) {return ++it;}

bool erase(set<vec>::iterator it)
{
    if(it==s.begin()) return 0;
    auto itl=pre(it);
    auto itr=aft(it);
    if(itr==s.end()) return 0;
    vec a=*it-*itl, b=*itr-*it;
    if(cross(a, b)<0) return 0;
    ans+=(*itr-*itl).length()-a.length()-b.length();
    s.erase(it);
    return 1;
    
}

void insert(vec A)
{
    if(chk(A)) return;
    auto it=s.insert(A).first;
    auto pr=pre(it);
    auto af=aft(it);
    ans+=(*it-*pr).length()+(*it-*af).length()-(*af-*pr).length();
    while(erase(pre(it)));
    while(erase(aft(it)));
}

vector<pair<int, int>> vc;
vec dts[maxn];
bool del[maxn];
vector<double> Ans;

int main()
{
    int n, m, x0, y0;
    cin>>n>>x0>>y0>>m;
    for(int i=1;i<=m;i++) 
        cin>>dts[i].x>>dts[i].y;
    int q;
    cin>>q;
    for(int i=1, op, x=0;i<=q;i++)
    {
        cin>>op;
        if(op==1) cin>>x, del[x]=1;
        vc.emplace_back(op, x);
    }
    s.emplace(0, 0);
    s.emplace(n, 0);
    s.emplace(x0, y0);
    ans=vec(x0, y0).length()+vec(x0-n, y0).length();
    for(int i=1;i<=m;i++) if(!del[i]) insert(dts[i]);
    for(auto [op, x]:views::reverse(vc))
    {
        if(op==1) insert(dts[x]);
        else Ans.emplace_back(ans);
    }
    for(auto i:views::reverse(Ans)) 
        printf("%.2lf\n", i);
}
```

---


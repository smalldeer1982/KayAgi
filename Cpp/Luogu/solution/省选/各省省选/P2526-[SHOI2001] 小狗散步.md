# [SHOI2001] 小狗散步

## 题目描述

Grant 喜欢带着他的小狗 Pandog 散步。Grant 以一定的速度沿着固定路线走，该路线可能自交。Pandog 喜欢游览沿途的景点，不过会在给定的  $N$ 个点和主人相遇。小狗和主人同时从  $(X_1,Y_1)$ 点出发，并同时在  $(X_n,Y_n)$ 点汇合。小狗的速度最快是 Grant 的两倍。当主人从一个点以直线走向另一个点时，Pandog 跑向一个它感兴趣的景点。Pandog 每次与主人相遇之前最多只去一个景点。

你现在的任务是：为 Pandog 寻找一条路线（有可能与主人的路线部分相同），使它能够游览最多的景点，并能够准时与主人在给定地点相遇或者汇合。

## 说明/提示

对于所有数据，有  $1\le N,M\le 100$，所有输入的坐标均不相同，且绝对值不超过  $10^3$。

## 样例 #1

### 输入

```
4 5
1 4 5 7 5 2 -2 4
-4 -2 3 9 1 2 -1 3 8 -3
```

### 输出

```
6
1 4 3 9 5 7 5 2 1 2 -2 4```

# 题解

## 作者：06ray (赞：12)

### 又是一道二分图水题。

### 这题关键在于如何建图以及输出方案。

### 根据题意得知，每次狗在主人相遇之前最多去一个景点。那我们不妨枚举所有的景点，判断狗从上一个相遇点出发，经过这个景点，最后是否比主人先到达下一个相遇点。

### 如果先到达，那我们就把下一个相遇点与这个景点连一条边。

### 建图之后，我们只要用最大流求出最大匹配并加上N就是第一个答案了，Dinic最大流板子不讲。

### 那么答案的第二行怎么求呢？很简单，先输出每个相遇点坐标，然后循环每个与它相连的景点，判断这条边的流量是否为0，如果是，就说明这个相遇点与景点匹配上了，输出景点的坐标。

## 无比丑陋的代码:

 ```cpp
#include <iostream>
#include <queue>
#include <cstring>
#include <cmath>
using namespace std;
struct map{ //结构体存坐标 
	int x,y;
};
map a[1010],b[1010];//相遇点坐标以及景点坐标 
const int MAX=0x7fffffff;
int dis[1001000];
int n,m,s,t;
int head[600100],net[600100],to[600100],cap[600100];//前向星存图 
int cnt=1;
void add(int x,int y,int c)//最大流建边 
{
    to[++cnt]=y;
    cap[cnt]=c;
    net[cnt]=head[x];
    head[x]=cnt;
    to[++cnt]=x;
    cap[cnt]=0;
    net[cnt]=head[y];
    head[y]=cnt;
}
int BFS()//Dinic最大流板子 
{
     memset(dis,0,sizeof(dis));
     dis[s]=1;
     queue<int>q;
     q.push(s);
     while(!q.empty())
     {
        int v=q.front();
        q.pop();
        for(int i=head[v];i;i=net[i])
        {
            if(dis[to[i]]==0&&cap[i]>0)
            {
                dis[to[i]]=dis[v]+1; 
                q.push(to[i]);
            }
        }

     }
     if(dis[t]>0) return 1;
     return 0;
}
int find(int x,int low)
{
    int a=0;
    if(x==t)return low;
    int sum=0;
    for(int i=head[x];i;i=net[i])
    {
        if(dis[to[i]]==dis[x]+1&&cap[i]!=0&&(a=find(to[i],min(low,cap[i]))))
        {
            cap[i]-=a;
            cap[i^1]+=a;
            low-=a;
            sum+=a;
            if(low==0)
            break;
        }
    }  
    return sum;
}
double js(map a,map b)//求出两点距离 
{
	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}
int main()
{
	int n;
	cin>>n>>m;
	for(int i=1; i<=n; i++)
	{
		cin>>a[i].x>>a[i].y;
	}
	for(int i=1; i<=m; i++)
	{
		cin>>b[i].x>>b[i].y;
	}
	s=0,t=n+m+1;//源点为0，汇点为n+m+1 
	for(int i=2; i<=n; i++)
	{
		add(s,i,1);//将源点连接所有相遇点 
		for(int j=1; j<=m; j++)
		{
			if(i==2) add(n+j,t,1);//将所有景点连接汇点 
			if(js(a[i],a[i-1])>(js(a[i-1],b[j])+js(b[j],a[i]))/2.0)//如果狗从上一个相遇点出发，经过这个景点，最后比主人先到达这个相遇点 
			{
				add(i,n+j,1);//将这个相遇点连接这个景点 
			}
		}
	}
	int ans=0,tans=0;
	while(BFS())
    {
          while(tans=find(s,0x7fffffff)) ans+=tans;
    }
    cout<<ans+n<<endl;//输出第一个答案， 
    cout<<a[1].x<<' '<<a[1].y<<' ';//第一个相遇点要先输出 
    for(int i=2; i<=n; i++)
    {
    	for(int j=head[i]; j; j=net[j])
    	if(!cap[j]&&to[j]!=s)//如果这个点是景点且边流量为0 
    	{
    		cout<<b[to[j]-n].x<<' '<<b[to[j]-n].y<<' ';//输出景点坐标 
			break; 
    	}
    	cout<<a[i].x<<' '<<a[i].y<<' ';//输出相遇点坐标 
    }
	return 0;
}
```






---

## 作者：MY（一名蒟蒻） (赞：5)

[P2526 [SHOI2001]小狗散步](https://www.luogu.com.cn/problem/P2526)

## 分析

考虑将景点和 Grant 的路分开，狗的路线构成二分图。

Grant 的路线是固定的，狗只要在他移动到下一个景点前能到就行。

注意即使狗先到，也要等到 Grant 来之后才能去下一个景点。

将 Grant 的路径作为左部点，景点作为右部点。

狗的速度是 Grant 的两倍，所以在狗在三点间移动的路程如果比 Grant 在两点间移动的路程的两倍还长，这条边就不能连。

数据范围很小，跑匈牙利算法即可，匹配成功后记录每个左部点匹配的右部点作为答案输出。

然后好像输入的坐标默认是整数。我严谨点用 double 存了。

## Code

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

int m,ans[110],match[110];
bool vis[110],e[110][110];
struct node {double x,y;} grant[110],doge[110];

bool dfs(int u)
{
	for(int i=1;i<=m;i++)
		if(e[u][i] && !vis[i])
		{
			vis[i]=true;
			if(!match[i] || dfs(match[i])) {match[i]=u; ans[u]=i; return true;}
		}
	return false;
}

inline double get_dist(const node &a,const node &b)
{
	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}

int main()
{
// 	freopen("work.in","r",stdin); freopen("work.out","w",stdout);
	int n,cnt=0;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%lf%lf",&grant[i].x,&grant[i].y);
	for(int i=1;i<=m;i++)
	{
		scanf("%lf%lf",&doge[i].x,&doge[i].y);
		for(int j=1;j<n;j++)
			if(2.0*get_dist(grant[j],grant[j+1]) >= get_dist(grant[j],doge[i])+get_dist(doge[i],grant[j+1]))
				e[j][i]=true;	
	}
	
	for(int i=1;i<n;i++)
	{
		for(int j=1;j<=m;j++) vis[j]=false;
		if(dfs(i) && ++cnt == m) break ;
	}
	
	printf("%d\n",n+cnt);
	for(int i=1;i<=n;i++)
	{
		printf("%.0lf %.0lf ",grant[i].x,grant[i].y);
		if(ans[i]) printf("%.0lf %.0lf ",doge[ans[i]].x,doge[ans[i]].y);
	}
// 	fclose(stdin); fclose(stdout);
	return 0;
}
```

感谢阅读！希望能对您有帮助！

---

## 作者：yedalong (赞：4)

二分图水题。  
## Solution
我们可以先思考如何建边。  
考虑 $match_i=j$ 表示第 $i$ 个景点可以在 $j$ 到 $j+1$ 之间前往。  
接着，对于每个与主人相遇的点 $i$，再遍历每一个景点，如果能保证去那个景点并去往 $i+1$ 的时间会小于 $i$ 到 $i+1$ 的时间的两倍，那么就可以由 $i$ 向那个景点建一条边。  
最后跑二分图的最大匹配即可。  
怎样输出就不用说了吧。。。
## AC code
注意，这份代码没有建边，而是每一次直接遍历所有点并判断。相对建边的做法，这种做法会更劣一些。
```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
	int x,y;
}a[105],b[105];
int n,m,match[105],ans,tmp[105];
bool pd[105];
double distance(int x,int y,int xx,int yy){
	return sqrt((x-xx)*(x-xx)+(y-yy)*(y-yy));
}
bool dfs(int now){
	if(pd[now]||now==n) return 0;
	pd[now]=1;
	for(int i = 1;i<=m;i++){
		if(distance(a[now].x,a[now].y,b[i].x,b[i].y)+distance(a[now+1].x,a[now+1].y,b[i].x,b[i].y)<=distance(a[now].x,a[now].y,a[now+1].x,a[now+1].y)*2){
			if(!match[i]||dfs(match[i])){
				match[i]=now;
				return 1;
			}
		}
	}
	return 0;
}
int main(){
	cin>>n>>m;
	for(int i = 1;i<=n;i++) cin>>a[i].x>>a[i].y;
	for(int i = 1;i<=m;i++) cin>>b[i].x>>b[i].y;
	for(int i = 1;i<=n;i++){
		memset(pd,0,sizeof(pd));
		ans+=dfs(i);
	}
	cout<<ans+n<<'\n';
	for(int i = 1;i<=m;i++) tmp[match[i]]=i;
	for(int i = 1;i<=n;i++){
		cout<<a[i].x<<' '<<a[i].y<<' ';
		if(tmp[i]) cout<<b[tmp[i]].x<<' '<<b[tmp[i]].y<<' ';
	}
	return 0;
}
```

---

## 作者：Ajsoabk (赞：4)

## [P2526 [SHOI2001]小狗散步](https://www.luogu.org/problemnew/show/P2526)

函数名用了distance，跳出一坨奇怪的编译信息

![](https://cdn.luogu.com.cn/upload/pic/50369.png )

![](https://cdn.luogu.com.cn/upload/pic/50372.png )
才知道 **distance** 是关键字（明明之前用过欸）

---
这道题相当鬼畜

暴力只要O(nm)

直接苟到85分（真肥）

然后看讨论里有人说景点不能重复走，不然只有85

本来还想不到正解的，打了一遍暴力后才受到启发

所以说**想不到正解就最好把最优秀的暴力打出来**，说不定就茅塞顿开了

---

## 先看看暴力（毕竟85）

思路很简单，枚举每段主人走的路，再枚举每个偏爱景点，只要符合就输出

（这里没用iostream，故可以用distance）

```cpp
#include<cstdio>
#include<cmath>
using namespace std;
const int N=100+5;
int x[N<<1],y[N<<1];
double dis[N<<1][N<<1];
int sta[N<<1],top,n,m; 

inline double distance(const int i,const int j){
    return sqrt(pow(1.*x[i]-x[j],2.)+pow(1.*y[i]-y[j],2.));
} 

int main(){
    scanf("%d %d\n",&n,&m);
    for(int i=1;i<=n+m;++i)scanf("%d %d",x+i,y+i); //一起读了
    for(int i=1;i<=n+m;++i)for(int j=i+1;j<=n+m;++j)dis[i][j]=dis[j][i]=distance(i,j);//预处理距离
    for(int i=1;i<n;++i){
        int ind=-1;
        sta[++top]=i;
        for(int j=1;j<=m;++j){
            if(dis[i][j+n]+dis[j+n][i+1]<=2*dis[i][i+1]){//跑的赢
                ind=j+n;
        		sta[++top]=j+n;
                break;
            }
        }
    }
    sta[++top]=n;
    printf("%d\n",top);
    for(int i=1;i<=top;++i)printf("%d %d ",x[sta[i]],y[sta[i]]);
    return 0;
}
```

## 问题在哪？

然鹅小狗可能重复访问一个景点

如果仅仅是这样还好说，加一个数组标记走过景点就行了

可是一个景点还可能匹配多段路

如果之前就被匹配，后面的可能就没法匹配了

之前匹配的要在有匹配的基础上换一个选择，把这个景点让给后面有需要的路径

所以要求路径与景点之间的最大匹配

这里用dinic，匈牙利也行

建建图，跑跑流就行了啦

```cpp
#include<cstring>
#include<cstdio>
#include<cmath>
#include<queue>
using namespace std;
const int N=100+5;
const int E=30000;
const int inf=0x7ffffff;
int coox[N<<1],cooy[N<<1],hea[N<<1],to[E],nex[E],val[E],tot=1,n,m,dep[N<<1],s,t;
double dis[N<<1][N<<1];

inline void add_edge(const int x,const int y,const int w){
//printf("%d --> %d(%d)\n",x,y,w);
    to[++tot]=y,nex[tot]=hea[x],hea[x]=tot,val[tot]=w;
}

inline double dist(const int i,const int j){
    return sqrt((coox[i]-coox[j])*(coox[i]-coox[j])+(cooy[i]-cooy[j])*(cooy[i]-cooy[j]));
} 

queue<int> que;
inline bool bfs(){
    memset(dep,0,sizeof(dep));
    dep[s]=1;
    while(que.size())que.pop();
    que.push(s);
    int x;
    while(que.size()){
        x=que.front();que.pop();
        for(int i=hea[x];i;i=nex[i]){
            int y=to[i];
            if(val[i]&&!dep[y]){
                dep[y]=dep[x]+1;
                if(y==t)return true;
                que.push(y);
            }
        }
    }
    return false;
}

int dfs(int x,const int flow){
    if(x==t)return flow;
    int rest=flow,k;
    for(int i=hea[x];i&&rest;i=nex[i]){
        int y=to[i];
        if(val[i]&&dep[y]==dep[x]+1){
            k=dfs(y,min(rest,val[i]));
            if(k==0)dep[y]=0;
            val[i]-=k;
            val[i^1]+=k;
            rest-=k;
        }
    }
    return flow-rest;
}

inline int dinic(){
    int maxflow=0,flow;
    while(bfs())while(flow=dfs(s,inf))maxflow+=flow;
    return maxflow;
}

int main(){
    scanf("%d %d\n",&n,&m);
    s=n+m+1,t=s+1;
    for(int i=1;i<=n+m;++i)scanf("%d %d",coox+i,cooy+i); 
    for(int i=1;i<=n+m;++i)for(int j=i+1;j<=n+m;++j)dis[i][j]=dis[j][i]=dist(i,j);
    for(int i=1;i<n;++i)add_edge(s,i,1),add_edge(i,s,0);
    for(int i=1;i<=m;++i)add_edge(i+n,t,1),add_edge(t,i+n,0);
    for(int i=1;i<n;++i){
        for(int j=1;j<=m;++j){
            if(dis[i][j+n]+dis[j+n][i+1]<2*dis[i][i+1]){
                add_edge(i,j+n,1);
                add_edge(j+n,i,0);
            }
        }
    }
    printf("%d\n",dinic()+n);
    for(int i=1;i<n;++i){
        printf("%d %d ",coox[i],cooy[i]);
        for(int j=hea[i];j;j=nex[j]){
            if(to[j]!=s&&val[j]==0){
                printf("%d %d ",coox[to[j]],cooy[to[j]]);
                break;
            }
        }
    }
    printf("%d %d\n",coox[n],cooy[n]);
    return 0;
}
        
```

---

## 作者：封禁用户 (赞：2)

### 算法
二分图最大匹配

### 思路
分析题目，我们发现 Pandog 会在自己感兴趣的景点和 Grant 要到达的地点之间徘徊若干次。把 Pandog 感兴趣的景点和 Grant 要到达的地点抽象成二分图中的点，那么 Pandog 的行进路线就能抽象为二分图的匹配。

先建出二分图。

令 Pandog 跑向它感兴趣的景点次数为 $y$，二分图的最大匹配数为 $r$。\
不难发现，$y=r$。

即： Pandog 经过的点数为 $n+r$。

用匈牙利算法计算二分图的最大匹配数即可。

### 难点
本题难点在于建图。

因为本题数据范围较小，枚举即可。

对于 Grant 要到达的第 $i$ 个地点 $(X_i,Y_i)$，枚举 $m$ 个 Pandog 感兴趣的景点。

若 Pandog 能在 Grant 到达第 $i+1$ 个地点时（或之前）到达该地点（并经过第 $j$ 个 Pandog 感兴趣的景点）。\
则建边 $i\rightarrow j$。

### 易错点
注意输出。

---

## 作者：LastKismet (赞：2)

_前置知识：二分图匹配_
 

------------
这道题虽然长得像个紫题，但就是一个二分图匹配板子。

# 题意简析
先有一组按顺序排列的给出坐标的点，要求 Pandog 依次经过其中一些点。对于每两个相邻的必去点，允许 Pandog 额外经过一个给出的点，要求经过的点至两个必去点的距离之和小于两个必去点的直线距离的两倍，问 Pandog 最多能经过多少个点。

~~如果看不懂就看原题面吧：[P2526](https://www.luogu.com.cn/problem/P2526)。~~

# 思路分析
很明显的一道二分图匹配问题，我这里使用`匈牙利算法`解决。

以 Pandog 必经的点为左侧点，所有点为右侧点。左侧点和右侧点可否联通，就在于 _题意简析_ 中对经过点的要求。另外，最后一个必经点是不用匹配的 ~~（都走到终点了，总不能再绕回去吧）~~。

完成联通之后，直接跑一遍 匈牙利算法 就完成了。

 Pandog 经过的点数即为所有顺利匹配的点数 + Pandog 必经的点数，至于对于坐标的输出，可以在匹配过程中将左侧点匹配的右侧点编号记录下来，最后循环每个左侧点，先输出本身坐标（因为它也算 Pandog 经过的点），再判断是否顺利匹配，如果已匹配则输出对应右侧点的坐标即可。
#  示例代码
```cpp
#include<bits/stdc++.h>
using namespace std;

typedef pair<double,double> pii;

int n,m;
pii gt[105],pd[105];
int ans;
bool vis[105];
int dis[105],mtc[105],dij[105];
vector<int> vs[105];

bool find(int num){
	for(int i=0;i<vs[num].size();i++){
		int to=vs[num][i];
		if(vis[to])continue;
		vis[to]=true;
		if(!mtc[to]||find(dis[to])){
			mtc[to]=true;
			dis[to]=num;
			dij[num]=to;
			return true;
		}
	}
	return false;
}

double get_dis(pii a,pii b){
	return sqrt((a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second));
}

int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>gt[i].first>>gt[i].second;
	}
	for(int j=1;j<=m;j++){
		cin>>pd[j].first>>pd[j].second;
		for(int i=1;i<n;i++){
			if(get_dis(gt[i],pd[j])+get_dis(gt[i+1],pd[j])<2*get_dis(gt[i],gt[i+1])){
				vs[i].push_back(j);
			}
		}
	}
	for(int i=1;i<n;i++){
		memset(vis,false,sizeof(vis));
		if(find(i)){
			ans++;
		}
	}
	cout<<ans+n<<endl;
	for(int i=1;i<=n;i++){
		cout<<gt[i].first<<" "<<gt[i].second<<" ";
		if(dij[i]!=0)cout<<pd[dij[i]].first<<" "<<pd[dij[i]].second<<" ";
	}
	return 0;
}
```

 _~~所以到底是哪个主人会让小狗跟自己分开走还要求小狗必须跟自己在一起啊。~~_

---

## 作者：hcng (赞：2)

# [P2526 [SHOI2001]小狗散步](https://www.luogu.com.cn/problem/P2526)

## 题意简述
主人依次以恒定速度经过平面上的 $n$ 个点 $a_{1..n}$，另有 $m$ 个景点 $b_{1..m}$。主人的小狗可以在主人从点 $a_i$ 走向点 $a_{i+1}$ 之间的时间从 $a_i$ 出发，拜访一个未拜访过的景点，再返回 $a_{i+1}$。小狗的速度最多为主人的两倍。求最大化小狗拜访的景点数量时，小狗的移动路径。

## 分析
注意到小狗的速度最多为主人的两倍，即在主人从 $a_{i}$ 走到 $a_{i+1}$ 时如果小狗要拜访景点 $j$，必定满足 $\operatorname{dis}(a_i,b_j)+\operatorname{dis}(b_j,a_{i+1}) \leq 2 \times \operatorname{dis}(a_{i},a_{i+1})$。

因为 $1 \leq n, m \leq 100$ ，考虑 $O (nm)$ 暴力求出对于主人的每一段路程小狗有足够时间拜访到的景点。（i.e. 对于所有满足 $1 \le i \le n - 1$ 的 $i$求出所有满足上述条件的 $j$）

根据题意，在主人的每一段路程中小狗只能拜访 $0$ 或 $1$ 个景点，考虑二分图最大匹配。

左部为主人的每一段路程，右部为所有景点。如果主人在走一段路程时小狗有足够的时间拜访一个景点，那么把这段路程和这个景点连边。

跑任意一种你喜欢的二分图最大匹配算法即可（题解代码中用了 Dinic）。

最后贴上代码

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
#define MOD 1000000007

char *p1, *p2, buf[100000];
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
inline int read() {static int x, f;static char c;x=0,f=1;c=getchar();while(c<'0'||'9'<c){if(c=='-')f=-1;c=getchar();};while('0'<=c&&c<='9')x=x*10+c-48,c=getchar();return x*f;}
void write(int x) {if(x<0)putchar('-'),x=-x;if(x>9)write(x/10);putchar('0'+x%10);}

struct Point {
    int x, y;
};

int n, m;
Point a[105], b[105];
vector<Point> ans;

inline double dis(Point x, Point y) {
    return sqrt((x.x - y.x) * (x.x - y.x) + (x.y - y.y) * (x.y - y.y));
}

struct Dinic {
    struct Edge {
        int to, nxt, flow, cap;
    };
    
    int n;
    int head[505], tot = 1;
    Edge e[500010];
    int S, T;
    int dep[505], cur[505];
    
    inline void add_edge(int u, int v, int c) {
        tot++;
        e[tot] = {v, head[u], 0, c};
        head[u] = tot;
        tot++;
        e[tot] = {u, head[v], 0, 0};
        head[v] = tot;
    }
    
    inline bool bfs() {
        memset(dep, 0, sizeof(dep));
        queue<int> Q; dep[S] = 1;
        Q.push(S);
        while (!Q.empty()) {
            int u = Q.front();
            Q.pop();
            for (int i = head[u]; i; i = e[i].nxt) {
                int v = e[i].to;
                if (e[i].cap > e[i].flow && !dep[v]) {
                    dep[v] = dep[u] + 1;
                    Q.push(v);
                }
            }
        }
        return dep[T];
    }
    
    int dfs(int u, int flow) {
        if (u == T || !flow) return flow;
        int ret = 0;
        for (int &i = cur[u]; i; i = e[i].nxt) {
            int v = e[i].to, d;
            if (dep[v] == dep[u] + 1 && (d = dfs(v, min(flow - ret, e[i].cap - e[i].flow)))) {
                ret += d;
                e[i].flow += d;
                e[i^1].flow -= d;
                if (ret == flow) return ret;
            }
        }
        return ret;
    }
    
    int maxflow() {
        int ret = 0;
        while (bfs()) {
            memcpy(cur, head, sizeof(cur));
            ret += dfs(S, 0x3f3f3f3f);
        }
        return ret;
    }
} dinic;

main() {
    n = read(), m = read();
    for (int i = 1; i <= n; i++) a[i].x = read(), a[i].y = read();
    for (int i = 1; i <= m; i++) b[i].x = read(), b[i].y = read();
    for (int i = 1; i <= n - 1; i++) {
       for (int j = 1; j <= m; j++) {
           if (dis(a[i], a[i+1]) * 2 >= dis(a[i], b[j]) + dis(b[j], a[i+1])) {
               dinic.add_edge(i, j + n, 1);
           }
       }
    }
    for (int i = 1; i <= n - 1; i++) dinic.add_edge(0, i, 1);
    for (int i = 1; i <= m; i++) dinic.add_edge(i + n, n, 1);
    dinic.S = 0, dinic.T = n;
    dinic.maxflow();
    for (int u = 1; u <= n - 1; u++) {
        ans.push_back(a[u]);
        for (int i = dinic.head[u]; i; i = dinic.e[i].nxt) {
            int v = dinic.e[i].to, flow = dinic.e[i].flow;
            if (flow > 0) {
                ans.push_back(b[v - n]);
                break;
            }
        }
    }
    ans.push_back(a[n]);
    write(ans.size()); putchar('\n');
    for (Point p : ans) write(p.x), putchar(' '), write(p.y), putchar(' ');
    putchar('\n');
    return 0;
}
```


---

## 作者：Z1qqurat (赞：2)

其实坐标系和这个题的性质关系不大，每次主人和狗在 $(x_i,y_i)$ 的时候，狗可以去一个景点 $(xx_j,yy_j)$，然后再去到 $(x_{i+1},y_{i+1})$ 和主人回合。那么它可以到的前提就是当它以最快速度，也就是主人速度的 $2$ 倍，可以走完 $(x_i,y_i)$ 到 $(xx_j,yy_j)$ 路程加上 $(x_{i+1},y_{i+1})$ 到 $(xx_j,yy_j)$ 的路程。狗和主人用的时间相同，狗速度最快为主人的 $2$ 倍，那么就是说狗的路程 $dis(i,j)+dis(i+1,j)$ 最大为主人路程 $dis(i,i+1)$ 的 $2$ 倍。我们将从 $(x_i,y_i)$ 到 $(x_{i+1},y_{i+1})$ 的时间段看成左部点，景点看作右部点，如果从 $(x_i,y_i)$ 到 $(x_{i+1},y_{i+1})$ 的时间段狗可以到景点 $j$，我们把 $i$ 到 $j$ 连边，然后跑最大匹配。满足点集内无连边并且是唯一对应的。

你问我输出方案？利用一下 $match$ 数组，数据范围很小，直接暴力都可以。$match_j=i$ 表示景点 $j$ 在时间段 $i$ 时走过了，我们开一个数组 $dy_i$ 表示时间段 $i$ 去的景点，如果是 $0$ 则这个时间段没去景点。那么我们在输出路径的时候，如果 $dy_i$ 有值就输出 $xx_{dy_i}$ 和 $yy_{dy_i}$。

记得输出经过的点数时，记住经过的点数其实是经过的最大景点数 $ans$ 加上 $n$ 个回合点，别搞错了。注意精度问题。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 105;
int n, m, x[N], y[N], match[N], vis[N], ans, px[N], py[N], dy[N];
vector <int> G[N];

bool hungary(int u, int cl) {
    for (int v : G[u]) {
        if(vis[v] == cl) continue;
        vis[v] = cl;
        if(!match[v] || hungary(match[v], cl)) return match[v] = u, 1;
    }
    return 0;
}

double dist(int ax, int ay, int bx, int by) { return sqrt((ax - bx) * (ax - bx) + (ay - by) * (ay - by));}

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; ++i) scanf("%d%d", &x[i], &y[i]);
	for (int i = 1; i <= m; ++i) {
		int xx, yy; scanf("%d%d", &xx, &yy); px[i] = xx, py[i] = yy;
		for (int j = 1; j < n; ++j) {
			double a = 2.0 * dist(x[j], y[j], x[j + 1], y[j + 1]);
			double b = dist(xx, yy, x[j], y[j]) + dist(xx, yy, x[j + 1], y[j + 1]);
			if(a >= b) G[j].emplace_back(i);
		}
	}
	for (int i = 1; i < n; ++i) ans += hungary(i, i);
	printf("%d\n", ans + n);
	for (int i = 1; i <= m; ++i) {
		if(match[i]) dy[match[i]] = i;
	}
	for (int i = 1; i < n; ++i) {
		printf("%d %d ", x[i], y[i]);
		if(dy[i] != 0) printf("%d %d ", px[dy[i]], py[dy[i]]);
	}
	printf("%d %d\n", x[n], y[n]);
	return 0;
}
```

---

## 作者：Uniecho1 (赞：2)

我寻思着网络流24题快rush完了，来摸个网络流练手

然后就做到这个题

咦，二分图？

思考用什么匹配什么。

然后......怎么这么水，说好的紫题呢？？
___
以上废话

考虑把主人每一段位移作为左部点，把小狗感兴趣的景点作为右部点

设主人某段位移为$i->j$，小狗感兴趣的景点之一为x

那么当$i->x->j$的时间小于等于二倍$i->j$的时间时，该段位移便能和$x$匹配

大力匈牙利就行了
```cpp
#include<bits/stdc++.h>
using namespace std;
int N,M,ans;
const int maxn=1005;
struct coord{
	int x,y;
	coord(int x=0,int y=0):
		x(x),y(y){}
}A[maxn],B[maxn];
vector<int>G[maxn<<2];
int vis[maxn],match[maxn];
vector<int>path[maxn];
double Calc(coord a,coord b){
	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}
bool dfs(int u){
	if(vis[u])
		return false;
	vis[u]=1;
	for(int i=0;i<G[u].size();i++){
		int v=G[u][i];
		if(!match[v]||dfs(match[v])){
			match[v]=u;
			return true;
		}
	}
	return false;
}
int main(){
	freopen("in.txt","r",stdin);
	ios::sync_with_stdio(false);
	cin>>N>>M;
	for(int i=1,x,y;i<=N;i++){
		cin>>x>>y;
		A[i]=coord(x,y);
	}
	for(int i=1,x,y;i<=M;i++){
		cin>>x>>y;
		B[i]=coord(x,y);
	}
	for(int i=1;i<N;i++){
		double t1=Calc(A[i],A[i+1]);
		for(int j=1;j<=M;j++){
			double t2=Calc(A[i],B[j])+Calc(B[j],A[i+1]);
			if(t1*2<t2)
				continue;//赶不回来了 
			G[i].push_back(j+N);
			G[j+N].push_back(i);
		}
	}
	for(int i=1;i<N;i++){
		memset(vis,0,sizeof(vis));
		ans+=dfs(i);
	}
	cout<<N+ans<<endl;
	for(int i=1;i<=M;i++)
		path[match[i+N]].push_back(i);
	for(int i=1;i<=N;i++){
		cout<<A[i].x<<" "<<A[i].y<<" ";
		if(path[i].size())
			cout<<B[path[i][0]].x<<" "<<B[path[i][0]].y<<" ";
	}
	return 0;
}
```

---

## 作者：TLE自动机 (赞：1)

二分图的题不用说了吧，但是我感觉楼上题解里的建图思路和我的有一点不同。。。

由题意可知，狗主人的路线是$\textbf{唯一}$的，那么在由第i个点到第i+1个点的$\textbf{路程}$中，小狗可以选择任意一个满足条件的景点去访问（不能重复选择同一景点）

那么我们把（i ~ i-1）这段路程（用起点编号代表这条边）和可以匹配的景点$\textbf{连一条边}$，代表可以在这段路程中可以去这个景点。所有可以匹配的路程和景点构成的边就成了一个$\textbf{二分图}$。

题目要求的就是在二分图中左右端点都不重复的情况下能匹配的最大边数（每段路程主人只会走一次，每个景点小狗都只会去一次）

你想到了什么？

没错，就是~~最大流DINIC~~$\textbf{匈牙利算法！}$
23333

关于输出细节处理在代码中有注释

复杂度 O(nm）56ms轻松跑过！（逃 


~~（好像dinic会更快）~~

cpp（为了方便阅读加了很多换行）：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;

int read(){
	int x=0;char ch=getchar();int pos=1;
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') pos=0;
	for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';
	return pos?x:-x;
}
const int maxn=105;

int n,m;

double dx[maxn],dy[maxn],mx[maxn],my[maxn];

inline double dis(double x1,double y1,double x2,double y2){
	return sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
}

int head[maxn];
struct node{
	int v,next;
}edge[maxn*maxn];
int top=0;

inline void add(int from,int to){
	edge[++top].v=to;
	edge[top].next=head[from];
	head[from]=top;
}
int vis[maxn],cx[maxn],cy[maxn];

inline int find(int now){
	if(vis[now]) return 0;
	vis[now]=1;
	for(int i=head[now];i;i=edge[i].next){
		int v=edge[i].v;
		if(!cy[v]||find(cy[v])){
			cy[v]=now;
			cx[now]=v;//比普通匈牙利多存一个当前路程能匹配的点
			return 1;
		}
	}
	return 0;
}

int main(){
	n=read();m=read();
	for(int i=1;i<=n;i++){
		dx[i]=read();dy[i]=read();
	}
    
	for(int i=1;i<=m;i++){
		mx[i]=read();my[i]=read();
	}
    
	for(int i=1;i<n;i++){
		for(int j=1;j<=m;j++){
			double d1=dis(dx[i],dy[i],dx[i+1],dy[i+1]);
			double d2=dis(dx[i],dy[i],mx[j],my[j])+dis(mx[j],my[j],dx[i+1],dy[i+1]);
			if(d1*2>=d2){
				add(i,j);
			}
		}
	}
   
	int tot=0;
	for(int i=1;i<n;i++){
	memset(vis,0,sizeof(vis));
		if(find(i)){
			tot+=2;//可以去景点则加上起点和景点，终点为下一次的起点
		}else tot+=1;//只有必定经过的点
	}
    tot++;//最后加上n这个终点
    
   //以下为输出
	printf("%d\n",tot);
	for(int i=1;i<=n;i++){
		printf("%.0f %.0f ",dx[i],dy[i]);//必定经过的点
		if(cx[i]){
			printf("%.0f %.0f ",mx[cx[i]],my[cx[i]]);//如果有匹配则加上景点
		}
	}
	return 0;
}
```



---

## 作者：VenusM1nT (赞：1)

网络流。将集合点作为左点，景点作为右点，可以创建出一个二分图，而我们要求的就是它的最大匹配。那么边怎么连呢？我们枚举每个景点 $i$ 和每个集合点 $j$，如果主人从这个集合点 $j$ 到下一个集合点 $j+1$ 需要的时间，比小狗从这个集合点 $j$ 到景点 $i$ 再到下一个集合点 $j+1$ 的时间要长的话，我们就可以在集合点 $j$ 到景点 $i$ 中间连一条边，因为小狗的速度是主人的两倍，所以我们将主人的时间 $\times 2$，或者将小狗的时间 $÷2$，再作比较即可。

数组记得开大点。

本文同步发表于笔者的博客：[题解 P2526 [SHOI2001]小狗散步](https://venusnero.github.io/2019/01/27/solution_p2526/)

```cpp
#include<bits/stdc++.h>
#define MAXN 10005
#define MAXM 500005
using namespace std;
struct Node
{
	int x,y;
}a[MAXN],b[MAXN];
queue <int> q;
int cnt=1,fst[MAXN],nxt[MAXM<<1],to[MAXM<<1],w[MAXN<<1],cur[MAXN];
int n,m,S,T,dep[MAXN];
void AddEdge(int u,int v,int c)
{
	to[++cnt]=v;
	nxt[cnt]=fst[u];
	fst[u]=cnt;
	w[cnt]=c;
}
bool Bfs()
{
	memset(dep,0,sizeof(dep));
	q.push(S);
	dep[S]=1;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(int i=fst[u];i;i=nxt[i])
		{
			int v=to[i];
			if(!dep[v] && w[i])
			{
				dep[v]=dep[u]+1;
				q.push(v);
			}
		}
	}
	return dep[T];
}
int Dfs(int u,int flow)
{
	if(u==T || !flow) return flow;
	int used=0;
	for(int &i=cur[u];i;i=nxt[i])
	{
		int v=to[i];
		if(dep[v]==dep[u]+1 && w[i])
		{
			int fl=Dfs(v,min(flow,w[i]));
			if(fl)
			{
				used+=fl;
				flow-=fl;
				w[i]-=fl;
				w[i^1]+=fl;
				if(!flow) break;
			}
		}
	}
	return used;
}
int Dinic()
{
	int sum=0;
	while(Bfs())
	{
		memcpy(cur,fst,sizeof(fst));
		sum+=Dfs(S,2e9);
	}
	return sum;
}
double Calc(Node x,Node y)
{
	return sqrt((double)(x.x-y.x)*(x.x-y.x)+(double)(x.y-y.y)*(x.y-y.y));
}
int main()
{
	scanf("%d %d",&n,&m);
	S=0;
	T=n+m+1;
	for(int i=1;i<=n;i++) scanf("%d %d",&a[i].x,&a[i].y);
	for(int i=1;i<=m;i++) scanf("%d %d",&b[i].x,&b[i].y);
	for(int i=2;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(Calc(a[i],a[i-1])>(Calc(a[i-1],b[j])+Calc(b[j],a[i]))/2.0)
			{
				AddEdge(i,j+n,1);
				AddEdge(j+n,i,0);
			}
		}
	}
	for(int i=2;i<=n;i++)
	{
		AddEdge(S,i,1);
		AddEdge(i,S,0);
	}
	for(int i=1;i<=m;i++)
	{
		AddEdge(i+n,T,1);
		AddEdge(T,i+n,0);
	}
	int res=Dinic()+n;
	printf("%d\n%d %d ",res,a[1].x,a[1].y);
	for(int i=2;i<=n;i++)
	{
		for(int j=fst[i];j;j=nxt[j])
		{
			int v=to[j];
			if(v==S || v==T || w[j]) continue;
			printf("%d %d ",b[v-n].x,b[v-n].y);
		}
		printf("%d %d ",a[i].x,a[i].y);
	}
	return 0;
}
```

---

## 作者：sen_lin114514 (赞：0)

# P2526 [SHOI2001] 小狗散步

### 思路

由题目可知，小狗每次只能去到一个景点，换句话说一条主人行走的边只能对应一个景点，由此可以想到二分图。

于是想到：

遍历输入进来的点，利用两点间距离公式计算主人每次行走的距离。由题目中得，小狗速度最大是主人的两倍，由公式 $ s = vt $ 小狗速度 $ v $ = $ 2 $ 主人速度。由此可得,在主人从一个景点走向另一个景点时，小狗可行走的距离是主人行走距离的两倍。

也就是：

计算相邻景点间的距离 $ d_1 $，小狗到景点并前往下一个点距离 $ d_2 $ 。

若 $ d_1 \le 2 \times d_2 $ 即，小狗可以在主人到达下一个景点前游玩一个景点并建边。

 满足以上条件,即可将这两点间建边。

 然后跑一个匈牙利最大匹配即可。

 ### 注意:
   有可能会爆精度。
   
   ~~建图记得加n~~。

### 代码

```cpp
#include <iostream>
#include <cstring>
#include <vector>
#include <cmath>

using namespace std;

const int N = 114514;

int n,m;

vector<int> E[N];

struct node
{
	double x,y;
}now[N],target[N];

double GetD(double nx,double ny,double tx,double ty)
{
	return std :: sqrt((double)(nx - tx) * (nx - tx) + (double)(ny - ty) * (ny - ty));
}

int flag[N];
int ans[N];

bool dfs(int x)
{
	for (auto y : E[x])
	{
		if (!flag[y])
		{
			flag[y] = true;
			if (!ans[y] || dfs(ans[y]))//抢人 
			{
				ans[x] = y;
				ans[y] = x;
				return true;
			}
			 
		}
	}
	return false;
}

int main()
{
	std :: cin >> n >> m;
	for (int i = 1 ; i <= n ; i ++)
	{
		std :: cin >> now[i].x >> now[i].y;
	}
	for (int i = 1 ; i <= m ; i ++)
	{
		std :: cin >> target[i].x >> target[i].y;
	}
	for (int i = 1 ; i < n ; i ++)
	{
		for (int j = 1 ; j <= m ; j ++)
		{
			if(GetD(now[i].x,now[i].y,now[i + 1].x,now[i + 1].y) * 2 >= GetD(now[i].x,now[i].y,target[j].x,target[j].y)+GetD(target[j].x,target[j].y,now[i + 1].x,now[i + 1].y))
			{
				//std :: cout << i << "->" << j << "\n";
				E[i].push_back(j + n);
			}
		}
	}
	int aans = 0;
	for (int i = 1 ; i <= n ; i ++)
	{
		memset(flag,0,sizeof(flag));
		aans += dfs(i);
	}
	std :: cout << aans + n << "\n";
//	for (int i = 1 ; i <= n ; i ++)
//	{
//		std :: cout << nxt[i];
//	}
//	std :: cout << "\n";
	for (int i = 1 ; i <= n ; i ++)
	{
		std :: cout << now[i].x << " " << now[i].y << " ";
		if (ans[i]) std :: cout << target[ans[i] - n].x << " " << target[ans[i] - n].y << " ";
	}
}
```

---

## 作者：NTT__int128 (赞：0)

# P2526 [SHOI2001] 小狗散步 题解
二分图最大匹配。

左部的点：$1\sim n-1$ 表示在第 $i$ 个与 Grant 相遇的点与第 $i+1$ 个与 Grant 相遇的点之间。右部的点：$1\sim m$ 表示第 $j$ 个 Pandog 感兴趣的点。

用 $(x_i,y_i)$ 表示第 $i$ 个 Pandog 感兴趣的点。

若 $2\cdot dis(X_i,Y_i,X_{i+1},Y_{i+1})\ge dis(x_j,y_j,X_i,Y_i)+dis(x_j,y_j,X_{i+1},Y_{i+1})$，则 $i$ 向 $j$ 连边，否则不连。

跑二分图最大匹配就行了。答案记得加 $n$。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e2+5;
int n,m,tim,e,match[N],to[N],ans,vis[N];
vector<int>v[N];
bool hungary(int x){
	for(int t:v[x])
		if(vis[t]<tim){
			vis[t]=tim;
			if(!match[t]||hungary(match[t]))
				return match[t]=x,to[x]=t,1;
		} 
	return 0;
}
int sq(int x){return x*x;}
long double dis(int nx,int ny,int tx,int ty){return sqrt(sq(nx-tx)+sq(ny-ty));}
int nx[N],ny[N],tx[N],ty[N];
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>nx[i]>>ny[i];
	for(int i=1;i<=m;i++)cin>>tx[i]>>ty[i];
	for(int i=1;i<n;i++)
		for(int j=1;j<=m;j++)
			if(dis(nx[i],ny[i],nx[i+1],ny[i+1])*2>=dis(nx[i],ny[i],tx[j],ty[j])+dis(tx[j],ty[j],nx[i+1],ny[i+1]))
				v[i].push_back(j);//建边
	for(int i=1;i<n;i++){
		++tim;
		ans+=hungary(i);
	}
	cout<<ans+n<<'\n';//记得加n
	for(int i=1;i<=n;i++){
		cout<<nx[i]<<' '<<ny[i]<<' ';
		if(to[i])cout<<tx[to[i]]<<' '<<ty[to[i]]<<' ';//注意，这里不是match[a]！！！
	}
	return 0;
}
```

---

## 作者：GJX_Algorithm (赞：0)

# P2526 题解
## 题目描述
- Grant 沿固定路线散步。Pandog 会在给定的 $N$ 个点与 Grant 相遇。

- Pandog 有 $M$ 个想去的景点。在去下一个与 Grant 相遇的点之前可以去至多一个想去的景点。

- Pandog 的速度最快是 Grant 的两倍。

- 现在请你求出一条线路使得 Pandog 可以在保证准时与 Grant 相遇的前提下能够游览最多景点。

## 解题思路
- 我们注意到题中一个重要信息：Pandog 在去下一个与 Grant 相遇的点之前可以去**至多一个**想去的景点。

- 以上信息说明 Pandog 不可能从一个景点去到另外一个景点，即 Pandog 的路线一定是：相遇点 $\to$ 景点 $\to$ 相遇点，或相遇点 $\to$ 相遇点。

- 对于相遇点 $\to$ 景点 $\to$ 相遇点的路线，直接建二分图，匈牙利算法求二分图最大匹配。

- 对于建图，直接算相遇点 $\to$ 景点 $\to$ 相遇点路线的欧几里得距离，如果该路线比相遇点 $\to$ 相遇点路线的欧几里得距离的两倍还长（说明 Pandog 不能在 Grant 走到相遇点之前赶到），就不能连边，反之连边。

## AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int n, m;
int ans;
int cnt = 1, head[N], to[N], Next[N];
int match[N], m1[N];
bool vis[N];
struct node
{
    double x, y;
}meet[N], att[N];
void add(int l, int r)
{
	to[++cnt] = r;
	Next[cnt] = head[l];
	head[l] = cnt;
	return ;
}
bool hungary(int cur) //匈牙利算法
{
    for (int i = head[cur]; i; i = Next[i])
    {
        int nxt = to[i];
        if (vis[nxt] == 0)
        {
            vis[nxt] = 1;
            if (match[nxt] == 0 || hungary(match[nxt]) == 1)
            {
                match[nxt] = cur;
                m1[cur] = nxt;
                return 1;
            }
        }
    }
    return 0;
}
double GetDis(double ax, double ay, double bx, double by) //计算欧几里得距离
{
    double nx = (ax - bx) * (ax - bx);
    double ny = (ay - by) * (ay - by);
    return sqrt(nx + ny);
}
int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) //存相遇点
    {
        cin >> meet[i].x >> meet[i].y;
    }
	for (int i = 1; i <= m; i++) //存景点
	{
        cin >> att[i].x >> att[i].y;
		for (int j = 1; j < n; j++) //建模
        {
            double Grant = 2 * GetDis(meet[j].x, meet[j].y, meet[j + 1].x, meet[j + 1].y);
            double Pandog = GetDis(meet[j].x, meet[j].y, att[i].x, att[i].y) + GetDis(meet[j + 1].x, meet[j + 1].y, att[i].x, att[i].y);
            if (Pandog <= Grant) //Pandog可以赶在Grant到达之前赶到，建边
			{
                add(j, i);
            }
        }
	}
    for (int i = 1; i < n; i++)
    {
        memset(vis, 0, sizeof vis);
        if (hungary(i) == 1)
            ans++;
    }
    cout << n + ans << "\n"; //注意还要加上相遇点
	for (int i = 1; i <= n; i++)
	{
        cout << meet[i].x << " " << meet[i].y << " ";
		if (m1[i] != 0) //匈牙利算法匹配到了 
        {
            cout << att[m1[i]].x << " " << att[m1[i]].y << " ";
        }
    }
	return 0;
}
```

---

## 作者：Kazeno_Akina (赞：0)

好像非常典的流。

本题限制是由前一个汇合点与下一个汇合点共同决定的，所以不能直接按照限制建图。但是考虑到汇合点顺序固定，可以考虑 **仅将景点挂在它能合法到达的汇合点下**。

然后就变成二分图匹配板子了。只需要跑景点和汇合点的最大匹配，最后输出汇合点数量+最大匹配就是答案。

但是本题疑似精度稍微有点卡，我 WA 95pts 了非常多次。原因是判断距离的时候假掉了，很多时候三个点的距离判断要求精度很高，这时候 `long double` 的精度难以处理。

那怎么办呢，考虑 `long long` 优化。

tips：推式子警告

设上一个汇合点到需要验证的景点的距离为 $\sqrt{d_1}$，下一个汇合点到待验证景点的距离为 $\sqrt{d_2}$，两个汇合点之间距离为 $\sqrt{d_3}$。其中，$d_1,\ d_2,\ d_3$ 均可用 `long long` 存储，勾股定理容易计算。

于是有

$$
\begin{aligned}
\sqrt{d_1}+\sqrt{d_2}\le 2\sqrt{d_3} &\Leftrightarrow d_1+d_2+2\sqrt{d_1d_2}\le 2d_3\\
&\Leftrightarrow 2\sqrt{d_1d_2}\le 2d_3-d_1-d_2\\
&\Leftrightarrow 4d_1d_2\le (2d_3-d_1-d_2)^2,\ 2d_3>d_1+d_2
\end{aligned}
$$

判断最后两个条件是否都成立即可。

核心代码：
```cpp
struct MXFL{
    ...
    inline void print(){
        cout << p1[1].x << ' ' << p1[1].y << ' ';
        for(int i(2);i<=n;++i){
            for(int j(fir[i]);~j;j=e[j].nxt) if(e[j].cap==e[j].flow&&e[j].v!=s){cout << p2[e[j].v-n].x << ' ' << p2[e[j].v-n].y << ' ';break;}
            cout << p1[i].x << ' ' << p1[i].y << ' ';
        }
    }
};
MXFL mf;
inline bool chk(pnt a,pnt b,pnt c){
    long long dis1=(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);
    long long dis2=(c.x-b.x)*(c.x-b.x)+(c.y-b.y)*(c.y-b.y);
    long long dis3=(c.x-a.x)*(c.x-a.x)+(c.y-a.y)*(c.y-a.y);
    long long lf,rg;
    lf=dis3*4-dis1-dis2;
    if(lf<0) return 0;
    lf*=lf;
    rg=4*dis1*dis2;
    return lf>=rg;
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin >> n >> m,mf.s=0,mf.t=n+m+1,mf.init();
    for(int i(1);i<=n;++i) cin >> p1[i].x >> p1[i].y;
    for(int i(1);i<=m;++i) cin >> p2[i].x >> p2[i].y,mf.addedge(n+i,mf.t,1);
    for(int i(2);i<=n;++i){
        mf.addedge(mf.s,i,1);
        for(int j(1);j<=m;++j) if(chk(p1[i-1],p2[j],p1[i])) mf.addedge(i,n+j,1);
    }
    cout << n+mf.dinic() << '\n',mf.print();
    return 0;
}
```

---

## 作者：_zuoqingyuan (赞：0)

这题真有紫？

# 思路分析

注意到题面中的两句话：

1. “Pandog 每次与主人相遇之前最多**只去一个景点**”。

2. “使它（Pandog）能够游览**最多的景点**，并能够准时与主人在给定地点相遇或者汇合”

根据第二句话，可以推断出 Pandog **不会去同一个景点两次**，毕竟第二次去某个景点不会增加对答案的贡献，有这个时间不如去其他景点。

联想到二分图，第一句其实属于二分图匹配模型的“1 要素”（Pandgo 到每个相遇点前只会去一个景点），第二句话属于“0 要素”（不会去一个景点两次）。

具体的，我们将每个相遇点看成左部点，Pandog 感兴趣的景点看为右部点。对于任何左部点 $i$，右部点 $j$，如果主人从第 $i$ 个相遇点走向第 $i+1$ 个相遇点所用时间，不少于 Pandog 从第 $i$ 个相遇点先走到第 $j$ 个景点，再走到第 $i+1$ 个相遇点的时间。则连一条 $(i,j)$ 的无向边。

最后跑一遍二分图最大匹配（本题匈牙利算法可以通过）。同时记录每个左部点匹配到的右部点即可，时间复杂度 $\mathcal{O}(n^2m)$。

# $\text{Code}$：

代码仅供参考。

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <cmath>
using namespace std;
const int N=105;
int n,m,x[N],y[N],X[N],Y[N],mk[N],op[N],match[N],ans;
double dist(int ax,int ay,int bx,int by){
    double u=ax-bx,v=ay-by;
    return sqrt(u*u+v*v);
}
bool judge(int u,int v){
    double d1=dist(x[u-1],y[u-1],x[u],y[u]);
    double d2=dist(X[v],Y[v],x[u-1],y[u-1]);
    double d3=dist(X[v],Y[v],x[u],y[u]);
    return d2+d3<d1*2.0;
}
vector<int>g[N];
bool dfs(int x){
    for(auto y:g[x]){
        if(mk[y])continue;
        mk[y]=1;
        if(!op[y]||dfs(op[y])){
            op[y]=x,match[x]=y;return 1;
        }
    }
    return 0;
}
int main(){
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d %d",x+i,y+i);
    for(int i=1;i<=m;i++)scanf("%d %d",X+i,Y+i);
    for(int i=2;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(judge(i,j))g[i].push_back(j);
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++)mk[j]=0;
        if(dfs(i))ans++;
    }
    printf("%d\n",ans+n);
    for(int i=1;i<=n;i++){
        if(match[i])printf("%d %d ",X[match[i]],Y[match[i]]);
        printf("%d %d ",x[i],y[i]);
    }
    return 0;
}
```

如有错误，请指出。

---

## 作者：lyhqwq (赞：0)

# Solution

板子题。

将 grant 的景点和狗感兴趣的景点分为两类，狗的路线是一个二分图。我们由 $i$ 向 $j$ 连边表示狗从 $i$ 到 $j$ 再到 $i+1$ 。判断是否 $dis(i,j)+dis(i+1,j) \leq dis(i,i+1)$ ，如果是则连边。

跑匈牙利即可，最后答案为最大匹配 $+n$。

# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=105;
struct node{
    double x,y;
}a[N],b[N];
int n,m,ans;
vector<int> vec[N];
int vis[N],mt[N],p[N];
int dfs(int u){
    if(vis[u]) return 0;
    vis[u]=1;
    for(auto v:vec[u]) if(!mt[v]||dfs(mt[v])) return mt[v]=u,1;
    return 0;
}
double dis(double x1,double y1,double x2,double y2){
    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%lf%lf",&a[i].x,&a[i].y);
    for(int i=1;i<=m;i++) scanf("%lf%lf",&b[i].x,&b[i].y);
    for(int i=1;i<n;i++){
        for(int j=1;j<=m;j++){
            double d1=dis(a[i].x,a[i].y,b[j].x,b[j].y);
            double d2=dis(a[i+1].x,a[i+1].y,b[j].x,b[j].y);
            double d3=dis(a[i].x,a[i].y,a[i+1].x,a[i+1].y);
            if(d1+d2<=2*d3) vec[i].push_back(j);
        }
    }
    for(int i=1;i<n;i++){
        for(int i=1;i<=n;i++) vis[i]=0;
        if(dfs(i)) ans++;
    }
    printf("%d\n",ans+n);
    for(int i=1;i<=m;i++) p[mt[i]]=i;
    for(int i=1;i<=n;i++){
        printf("%d %d ",(int)a[i].x,(int)a[i].y);
        if(p[i]) printf("%d %d ",(int)b[p[i]].x,(int)b[p[i]].y);
    }
    return 0;
}

```

---

## 作者：wlty (赞：0)

# ~~**一道二分图的小题**~~


------------


和很多网络流题是一样的，难点就在建图上。

由于**狗狗每次与主人相遇之前最多只去一个景点**，所以说明相邻的主人路径的点都只能夹一个景点。

我们可以把这个景点叫做前面的路径的点的下一个景点，称作一个匹配，也就是一个路径上的点最多匹配一个景点（这里所说的路径都是指主人行走的路径）。

那么我们就可以把本题改成一道二分图匹配的题了。建图方式如下：

对于路径上的每一个点&nbsp;&nbsp;$S_i$，我们暴力枚举所有景点&nbsp;  $V_j$，如果**二倍的**&nbsp;$S_i$&nbsp;到&nbsp;$S_{i+1}$&nbsp;的距离大于&nbsp; $S_i$&nbsp; 到&nbsp; $V_j$&nbsp; 与&nbsp; $V_j$&nbsp; 到&nbsp; $S_{i+1}$&nbsp; 距离和，说明狗狗可&nbsp; $S_i$&nbsp; 到以在&nbsp; $S_i$&nbsp; 到和&nbsp; $S_{i+1}$&nbsp; 中间去一趟&nbsp; $V_j$，那么我们就连一条&nbsp; $S_i$ &nbsp;到&nbsp;$V_j$&nbsp;容量为&nbsp;$1$&nbsp;的边，建完二分图之后由源点向所有路径上的点连一条容量为&nbsp; _$1$_ &nbsp;的边，由所有景点向汇点连一条容量为&nbsp; _$1$_ &nbsp;的边，跑 &nbsp;**dinic** &nbsp;就可以了。

输出路径的话就是正常的二分图方案输出，先按照路径顺序输出，然后看看这个路径上的点有没有向景点连出一条流量是满的边（也就是残留网络是空的边），如果空了说明连向的点就是狗狗去向的景点。

**~~（EK算法应该也可以过，因为数据量还是比较小的）~~**

最后附上个代码~

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=500;
const int M=25000;
const int INF=1e8;
struct Nodeee{
	int x;
	int y;
}pathman[120];
struct Nodee{
	int x;
	int y;
}like[120];
int n,m,S,T;
struct Node{
	int ne;
	int ve;
	int f;
}edge[M];
int head[N],idx;
void clear(){
	memset(head,-1,sizeof(head));
	idx=0;
}
void added(int x,int y,int f){
	edge[idx].ne=head[x];
	edge[idx].ve=y;
	edge[idx].f=f;
	head[x]=idx;
	idx++;
	edge[idx].ne=head[y];
	edge[idx].ve=x;
	edge[idx].f=0;
	head[y]=idx;
	idx++;
}
int q[N];
int d[N];
int cur[N];
bool bfs(){
	int hh=0,tt=0;
	memset(d,-1,sizeof(d));
	q[0]=S;
	d[S]=1;
	cur[S]=head[S];
	while(hh<=tt){
		//cout<<hh<<" "<<tt<<endl;
		int t=q[hh++];
		for(int i=head[t];i!=-1;i=edge[i].ne){
			int ver=edge[i].ve;
			if(d[ver]==-1&&edge[i].f){
				d[ver]=d[t]+1;
				cur[ver]=head[ver];
				if(ver==T) return true;
				q[++tt]=ver;
			}
		}
	}
	return false;
}
int find(int u,int limit){
	if(u==T) return limit;
	else{
		int flow=0;
		for(int i=cur[u];i!=-1&&flow<limit;i=edge[i].ne){
			cur[u]=i;
			int ver=edge[i].ve;
			if(d[ver]==d[u]+1&&edge[i].f){
				int t=find(ver,min(edge[i].f,limit-flow));
				if(!t) d[ver]=-1;
				else{
					edge[i].f-=t;
					edge[i^1].f+=t;
					flow+=t;
				}
			}
		}
		return flow;
	}
}
int dinic(){
	int r=0;
	int flow;
	while(bfs()){
		while(flow=find(S,INF)){
			r+=flow;
		}
	}
	return r;
}
double sd(double x1,double x2,double y_1,double y_2){
	return sqrt((x1-x2)*(x1-x2)+(y_1-y_2)*(y_1-y_2));
}
int main(){
	clear();
	cin>>n>>m;
	S=0;
	T=n+m+1;
	for(int i=1;i<=n;i++){
		int x,y;
		cin>>x>>y;
		pathman[i].x=x;
		pathman[i].y=y;
	}
	for(int i=1;i<=m;i++){
		int x,y;
		cin>>x>>y;
	    like[i].x=x;
	    like[i].y=y;
	}
	for(int i=1;i<=n-1;i++){
		for(int j=1;j<=m;j++){
			double x1=pathman[i].x;
			double x2=pathman[i+1].x;
			double x3=like[j].x;
			double y_1=pathman[i].y;
			double y_2=pathman[i+1].y;
			double y_3=like[j].y;
			double len1=2.0*sd(x1,x2,y_1,y_2);
			double len2=sd(x1,x3,y_1,y_3)+sd(x2,x3,y_2,y_3);
			if(len1>=len2){
			//	cout<<i<<" "<<j<<" "<<endl;
				added(i,j+n,1);
			}
		}
	}
	for(int i=1;i<=n;i++){
		added(S,i,1);
	}
	for(int j=1;j<=m;j++){
		added(j+n,T,1);
	}
	cout<<dinic()+n<<endl;
	for(int i=1;i<=n;i++){
		cout<<pathman[i].x<<" "<<pathman[i].y<<" ";
		for(int j=head[i];j!=-1;j=edge[j].ne){
			if(edge[j].f==0&&edge[j].ve>=n+1&&edge[j].ve<=n+m){
				int ver=edge[j].ve-n;
				cout<<like[ver].x<<" "<<like[ver].y<<" ";
			}
		}
	}
	return 0;
} 

```

~~蒟蒻的第一篇网络流题解~~

%%%%%张振宇charlie大神


---

## 作者：Coros_Trusds (赞：0)

# 题目大意

$\rm Grant$ 喜欢带着他的小狗 $\rm Pandog$ 散步。$\rm Grant$ 以一定的速度沿着固定路线走，该路线可能自交。$\rm Pandog$ 喜欢游览沿途的景点，不过会在给定的 $n$ 个点和主人相遇。小狗和主人同时从  $(X_1,Y_1)$ 点出发，并同时在 $(X_n,Y_n)$ 点汇合。小狗的速度 **最快** 是 $\rm Grant$ 的两倍。当主人从一个点以直线走向另一个点时，$\rm Pandog$ 跑向一个它感兴趣的景点。$\rm Pandog$ 每次与主人相遇之前最多只去一个景点。

你现在的任务是：为 $\rm Pandog$ 寻找一条路线（有可能与主人的路线部分相同），使它能够游览最多的景点，并能够准时与主人在给定地点相遇或者汇合。

# 题目分析

不妨令 $\rm Grant$ 走过的点为左部点，$\rm Pandog$ 能够游览的景点为右部点。发现这是一个二分图。

考虑如何连边：

因为 $\rm Pandog$ 要在 $\rm Grant$ 到下一个地点之前赶到下一个地点，所以如果 $\rm Grant$ 经过两个相遇地点 $j,j+1$ 之间的距离的时间超过了 $\rm Pandog$ 从 $j$ 到景点 $i$ 再到 $j+1$ 的时间，那么可以连边 $<j,i>$。

--------

接下来跑一遍匈牙利算法求二分图匹配即可。

关于输出方案的解决办法：跑匈牙利算法时另开一个数组记录左部点在右部点中的匹配的点的编号。

# 代码

```cpp
// Problem: P2526 [SHOI2001]小狗散步
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P2526
// Memory Limit: 125 MB
// Time Limit: 1000 ms
// Date:2022-06-14 21:26
// 
// Powered by CP Editor (https://cpeditor.org)

#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <numeric>
#include <algorithm>
#include <cmath>
#define enter putchar(10)
#define debug(c,que) std::cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) std::cout << arr[i] << w;
#define speed_up() std::ios::sync_with_stdio(false),std::cin.tie(0),std::cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define stop return(0)
const int mod = 1e9 + 7;
inline int MOD(int x) {
	if(x < 0) x += mod;
	return x % mod;
}
namespace Newstd {
	char buf[1 << 21],*p1 = buf,*p2 = buf;
	inline int getc() {
		return p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1 << 21,stdin),p1 == p2) ? EOF : *p1 ++;
	}
	inline int read() {
		int ret = 0,f = 0;char ch = getc();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getc();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getc();
		}
		return f ? -ret : ret;
	}
	inline double double_read() {
		long long ret = 0,w = 1,aft = 0,dot = 0,num = 0;
		char ch = getchar();
		while (!isdigit(ch)) {
			if (ch == '-') w = -1;
			ch = getchar();
		}
		while (isdigit(ch) || ch == '.') {
			if (ch == '.') {
				dot = 1;
			} else if (dot == 0) {
				ret = (ret << 3) + (ret << 1) + ch - 48;
			} else {
				aft = (aft << 3) + (aft << 1) + ch - '0';
				num ++;
			}
			ch = getchar();
		}
		return (pow(0.1,num) * aft + ret) * w;
	}
	inline void write(int x) {
		if(x < 0) {
			putchar('-');
			x = -x;
		}
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;

const int N = 105;
struct Node {
	double x,y;
} node[N],path[N];
struct Graph {
	int v,nxt;
} gra[N * N];
int head[N],matl[N],matr[N],vis[N];
int n,m,idx,nowidx;
inline double dist(Node x,Node y) {
	return sqrt((x.x - y.x) * (x.x - y.x) + (x.y - y.y) * (x.y - y.y));
}
inline void add(int u,int v) {
	gra[++ idx] = (Graph){v,head[u]},head[u] = idx;
}
inline bool dfs(int now) {
	for (register int i = head[now];i;i = gra[i].nxt) {
		int v = gra[i].v;
		if (vis[v] != nowidx) {
			vis[v] = nowidx;
			if (!matr[v] || dfs(matr[v])) {
				matl[now] = v,matr[v] = now;
				return true;
			}
		}
	}
	return false;
}
int main(void) {
	scanf("%d%d",&n,&m);
	for (register int i = 1;i <= n; ++ i) scanf("%lf%lf",&node[i].x,&node[i].y);
	for (register int i = 1;i <= m; ++ i) scanf("%lf%lf",&path[i].x,&path[i].y);
	for (register int i = 1;i <= m; ++ i) {
		for (register int j = 1;j < n; ++ j) {
			if ((dist(node[j],path[i]) + dist(path[i],node[j + 1])) / 2.0 <= dist(node[j],node[j + 1])) {
				add(j,i);
			}
		}
	}
	int step = 0;
	for (register int i = 1;i <= n; ++ i) {
		nowidx ++;
		if (dfs(i)) {
			step ++;
			if (step == m) break;
		}
	}
	printf("%d\n",n + step);
	for (register int i = 1;i <= n; ++ i) {
		printf("%.0lf %.0lf ",node[i].x,node[i].y);
		if (matl[i]) {
			printf("%.0lf %.0lf ",path[matl[i]].x,path[matl[i]].y);
		}
	}
	
	return 0;
}
```

---

## 作者：SGOI_Aromyase (赞：0)

不会写匈牙利算法..果然我学OI有点功利。

省选退役以后再学匈牙利吧..

尝试使用Dinic，思路楼上很清楚，不再解释了。

就是个板子啦。

暴力的方法寻找路径就可以了

```
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
#define maxn 205
#define en 203
#define fo(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
int n,m;
struct ro{
	int to,flow;
};
vector<ro> edge;
vector<int> a[maxn];
int d[maxn];
queue<int> q;
int dfs(int u,int flow)
{
	if(u==en) return flow;
	int cnt=0;
	for(int i=0;i<a[u].size();i++){
		ro c=edge[a[u][i]];
		if(c.flow<=0||d[u]+1!=d[c.to]) continue;
		int s=dfs(c.to,min(flow,c.flow));
		flow-=s;
		cnt+=s;
		edge[a[u][i]].flow-=s;
		edge[a[u][i]^1].flow+=s;
		if(flow==0) break;
	}
	if(cnt==0) d[u]=-1;
	return cnt;
}

bool bfs()
{
	memset(d,-1,sizeof(d));
	d[0]=0;q.push(0);
	while(!q.empty())
	{
		int now=q.front();q.pop();
		for(int i=0;i<a[now].size();i++){
			ro c=edge[a[now][i]];
			if(c.flow<=0||d[c.to]!=-1) continue;
			d[c.to]=d[now]+1;
			q.push(c.to);
		}
	}
	return (d[en]!=-1);
}


struct D{
	int x,y;
} Master[maxn],Dog[maxn];
void getb(int fr,int to){
	ro c;c.to=to;c.flow=1;
	edge.push_back(c);
	a[fr].push_back(edge.size()-1);
	c.to=fr;c.flow=0;
	edge.push_back(c);
	a[to].push_back(edge.size()-1);
}

double len(D s1,D s2){
	double re=1.0*(double)((s1.x-s2.x)*(s1.x-s2.x)+(s1.y-s2.y)*(s1.y-s2.y));
	return sqrt(re);
}

void sc()
{
	cin>>n>>m;
	fo(i,1,n) scanf("%d%d",&Master[i].x,&Master[i].y);
	fo(i,1,n-1) getb(0,i);
	fo(i,1,m) scanf("%d%d",&Dog[i].x,&Dog[i].y),getb(i+100,en);
	fo(i,1,n-1) fo(j,1,m){
		if(len(Master[i],Dog[j])+len(Master[i+1],Dog[j])>len(Master[i],Master[i+1])*2)
		continue;
		getb(i,j+100);
	}
}
int pr[maxn],cnt;
void sum()
{
	int ans=0;
	fo(u,1,n-1){
		int ok=0;
		for(int i=0;i<a[u].size();i++){
			ro c=edge[a[u][i]];
			if(c.to==0&&c.flow>0){
				ok=1;
			}
		}
		pr[cnt++]=u;
		if(ok) for(int i=0;i<a[u].size();i++){
			ro c=edge[a[u][i]];
			if(c.to!=0&&c.flow<=0){
				pr[cnt++]=c.to;
			}
		}
	}
	pr[cnt++]=n;
	cout<<cnt<<endl;
	for(int i=0;i<cnt;i++){
		if(pr[i]>100) printf("%d %d ",Dog[pr[i]-100].x,Dog[pr[i]-100].y);
		else printf("%d %d ",Master[pr[i]].x,Master[pr[i]].y);
	}
}

int main()
{
	sc();
	while(bfs()) dfs(0,inf);
	sum();
	return 0;
}
```

---

## 作者：Cet6_427 (赞：0)

因为当主人从一个点以直线走向另一个点时，小狗会跑向一个他感兴趣的点，并且主人的路线是确定的，所以寻找一条路径可以看成是对小狗路径的选择，即：①跑向一个景点 或 ②与主人的路线重合。

所以，我们可以把主人移动的每一段抽象成点，就可以与小狗向往的景点分为两类，构成二分图。

目标就是求这个**二分图的最大匹配**。










```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define M(x, OP) memset(x, OP, sizeof(x))
const int maxn = 105;
struct Data{ int x, y; } A[maxn], B[maxn];
int N, M, ans = 0;
int ch[maxn][maxn], link[maxn<<2], vis[maxn<<2];
inline double dis(Data X, Data Y){
    return sqrt(abs(X.x - Y.x) * abs(X.x - Y.x) + abs(X.y - Y.y) * abs(X.y - Y.y));
}
bool dfs(int u){
    for(int i = 1; i <= N - 1; i++){
        if(!vis[i] && ch[u][i]){
            vis[i] = 1;
            if(!link[i] || dfs(link[i])){
                link[i] = u;
                return true;
            }
        }
    }
    return false;
}
inline int GetInt(){
    char x;
    int ret;
    while((x = getchar()) < '0' || x > '9');
    ret = x - '0';
    while((x = getchar()) >= '0' && x <= '9') ret = ret * 10 + x - '0';
    return ret;
}
int main(){
    N = GetInt(), M = GetInt();
    for(int i = 1; i <= N; i++){
        scanf("%d%d", &A[i].x, &A[i].y);
//        printf("%d %d ", A[i].x, A[i].y);    
        /*A[i].x = GetInt(), A[i].y = GetInt();*/
    } 
    for(int i = 1; i <= M; i++){
        scanf("%d%d", &B[i].x, &B[i].y);
//        printf("%d %d ", B[i].x, B[i].y);
        /*B[i].x = GetInt(), B[i].y = GetInt();*/
    }
    memset(ch, 0, sizeof(ch));
    for(int i = 1; i <= N - 1; i++)
        for(int j = 1; j <= M; j++)
            if(dis(A[i], A[i+1]) > (dis(A[i], B[j]) + dis(B[j], A[i+1])) / 2) ch[j][i] = 1;
    ans = 0;
    memset(link, 0, sizeof(link));
    for(int i = 1; i <= M; i++){
        memset(vis, 0, sizeof(vis));
        if(dfs(i)) ans++;
    }
    printf("%d\n", ans + N);
    for(int i = 1; i <= N; i++){
        printf("%d %d", A[i].x, A[i].y);
        if(i == N) printf("\n");
        else{
            printf(" ");
            if(link[i]) printf("%d %d ", B[link[i]].x, B[link[i]].y);
        }
    }
    return 0;
} 

```

---


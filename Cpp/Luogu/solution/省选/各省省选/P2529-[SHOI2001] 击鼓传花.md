# [SHOI2001] 击鼓传花

## 题目描述

HC(Happy Child)小朋友最近经常在教室里跟同学一起玩击鼓传花的游戏，规则是第 $n$ 个拿到花的小朋友必须说出 $n!$ 最后一位非 0 的数字，如此循环游戏，如果谁讲错了就得罚唱一支歌曲。

经过几次游戏，HC 小朋友认为只要把前一个小朋友说得数字去乘以 $n$，说出得到的数的最后一位非 $0$ 的数字就可以了，可惜 HC 小朋友这次轮到了第 $15$ 个，结果被罚了唱歌(应该是 $8$，但是HC小朋友却说了$3$)。

HC 小朋友不希望这样的事情再次发生，所以希望你能编写一个程序，能够计算出 $n!$ 的最后一位非 $0$ 的数字。


## 样例 #1

### 输入

```
11
12
13
14
15
```

### 输出

```
8
6
8
2
8
```

# 题解

## 作者：WinXP (赞：20)

说真的 大佬的题解真的太意识流了(两篇) 对蒟蒻来说能坚持到看明白需要勇气啊。。对蒟蒻真的是不友善。。  或许怎么说。。。 这就是大佬吧。

首先公式给出，与那位大佬V2.0版中的公式相同。设 $f(x)$ 表示 $x!$ 最后一个非0的数，那么有

$$f(x)=f(x/5)×a(x \% 20)$$

$a$ 是预设的数组。

首先嘛 不要考虑 $10^{100}$ 这么大的数。来考虑一些友善的数据范围，比如 $100000$ 这么大之类的。这个怎么做呢？

如果求某一个数 $x$ 的最后一位那谁都会：$x\%10$。如果求的是某一个数 $x$ 的最后一位非0的数，在 $x/10$ 能算的出来的时候，$while(x\%10==0) x/10$ 再 $\%10$ 就好了。

注意这两点：$x×y\%10=(x\%10)×(y\%10)$。 $10$ 等于 $2×5$ 并且 $2,5$ 都是质数。

那么现在把 $x!$ 表示为 $c×2^{a}×5^{b}$。( $c$ 不包含质因子 $2$ 和 $5$ ) 显然 $a>b$ 。~~(这里显然没问题吧)~~ 所以最后的结果应该为 $2^{a-b}×c\%10$。

想到这里我们就可以用约为 $O(n)$ 级别的时间来计算这个解了。初始化 $ans=1$ ，对于从 $1$ 到 $x$ 的每一个数，都除尽它的 $2$ 因子与 $5$ 因子，记下 $a-b $ 的值，除干净了把这个数 $\%10$ 并乘上 $ans$ ，最后 $ans$ 乘一下 $(a-b)$ 个 $2$ ，就能得到结果。

我们显然可以优化这个过程。

先把所有的 $5$ 的倍数都拿出来放到一边，一会乘起来。原数组会变成类似

$$1,2,3,4,1,6,7,8,9,1,11,12,13,14,1,16,17,18,19,1,21,22 ...$$

这样。

考虑像分块一样把每 $10$ 个数作为一组。假想我们有一种方式，能将几个数相乘后的结果中的 $10$ 预先抽离出来，将它变成

$$(1×2×3×4×1×6×7×8×9×1\%10+10×q_1)$$
$$×$$
$$(1×2×3×4×1×6×7×8×9×1\%10+10×q_2)$$
$$×$$
$$...........$$
$$×$$
$$(1×2×3×4×1×6×7×8×9×1\%10+10×q_n)$$

这个样子。

很显然如果不提 $2$ ，每一段乘起来 $\%10$ 的值都是相同的 $6$ 。

当然提 $2$ 之后也是相同的。每 $10$ 个数，拿走两个 $2$ 来和提取出的两个 $5$ 的倍数值进行匹配，无论 $q_i$ 的值如何(即使是 $0$ )，每组 $\%10$ 后的值都将变成 $4$ 。

现在就变成了，很多个 $4$ 乘起来，乘最后没完整划分为 $10$ 个数的那一组，乘上一堆之前提出的 $5$ 的倍数再 $/5$ 的值，的最后一位非 $0$ 值是多少。什么是"一堆之前提出的 $5$ 的倍数再 $/5$ 的值"? 就是说提出的 $5,10,15,20,25,30...$ 这些数，每一个 $/5$ ，提出的 $5$ 与提出的 $2$ 乘在一起变成 $10$ 扔掉，就变成了 $1×2×3×4×5×6×....$

这一共有 $x/5$ 个数。也就是

$4^{?}×$*最后的那几个分不了组的数*$ × f(x/5)$

$4×4\%10=6$ 。~~聪明的~~你会发现，对于 $x!$ 的最后一个非 $0$ 数，一定是偶数，换句话说就是 $2,4,6,8$ 中的一个。

$6*2\%10=2$，$6*4\%10=4$，$6*6\%10=6$，$6*8\%10=8$。 $6$ 与能成为答案的数相乘都是不改变值的*所以我们干脆每20个数分成一组*，每一组为原来的两组，提出 $2$ 和 $5$ 之后的值是 $6$ 。 $6$ 与任何一个答案值乘在一起是不会变的，所以我们可以当做没看见。

对于最后面的几个数显然是可以预处理的。所以现在答案变成了 $6^{?}×$ *预处理* $ × f(x/5)=$ *预处理* $ × f(x/5)$

把预处理的数组放到 $a$ 上面就好了。

也就是说如果你理解了的话，$a$ 数组是

$$1,2,3,4,\frac{1}{2},6,7,8,9,\frac{1}{2}....$$

的前缀和。不对，前缀乘（ $\%10$ ）。

所以代码几乎是只要维护一个~~区区~~ $100$ 位的高精除。复杂度 $O(n^2log_510)$ 。我写的太丑，就不放了。

---

## 作者：cyffff (赞：9)

[P2529 [SHOI2001]击鼓传花](https://www.luogu.com.cn/problem/P2529)

提供一种不一样的思路。
## 题意
求 $f(n)=n!$ 中最后一位非 $0$ 数，$1\le n\le 10^{100}$。
## 思路
显然不能暴力。

引入符号 $s(n)=1\times 2\times 3\times 4\times 6\times ...\times 9\times 11$ 即 $n!$ 中不包含因数 $5$ 的项的乘积。

设 $a(n)$ 表示 $s(n)$ 中最后一位，显然，$a(n)\ne 0$。

对于 $n=1,2,3,...$，我们发现 $a(n)=1,2,6,4,4,4,8,4,6,6,6,2,6,4,4,4,8,4,6,6,6,...$，发现没有？循环节 $2,6,4,4,4,8,4,6,6,6$。

我们可以先处理出 $n\le 10$ 的 $f(n)$，然后讨论一下。

$$n!=s(n)\times 5^{\left\lfloor\frac{n}{5}\right\rfloor}\times (\left\lfloor\frac{n}{5}\right\rfloor)!$$
$$=\frac{s(n)}{2^{\left\lfloor\frac{n}{5}\right\rfloor}}\times {10}^{\left\lfloor\frac{n}{5}\right\rfloor}\times (\left\lfloor\frac{n}{5}\right\rfloor)!$$
即 $f(n)=\frac{s(n)}{2^{\left\lfloor\frac{n}{5}\right\rfloor}}\times (\left\lfloor\frac{n}{5}\right\rfloor)!$ 的最后一位非 $0$ 数。

又十分显然 $f(n)=\frac{s(n)}{2^{\left\lfloor\frac{n}{5}\right\rfloor}}\times f(\left\lfloor\frac{n}{5}\right\rfloor)$ 的最后一位非 $0$ 数。

考虑 $a(n)$ 与 $a(\left\lfloor\frac{n}{2}\right\rfloor)$ 的关系。


经过找规律，
$$a(n)=2\iff a(\left\lfloor\frac{n}{2}\right\rfloor)=6$$
$$a(n)=6\iff a(\left\lfloor\frac{n}{2}\right\rfloor)=8$$
$$a(n)=8\iff a(\left\lfloor\frac{n}{2}\right\rfloor)=4$$
$$a(n)=4\iff a(\left\lfloor\frac{n}{2}\right\rfloor)=2$$
循环。

又 $a(n)$ 循环，容易计算，所以 $\frac{s(n)}{2^{\left\lfloor\frac{n}{5}\right\rfloor}}$ 的最后一位容易计算。

所以 $f(n)$ 就能计算了。

因为要高精度，于是我用了 `Python` 实现。

Code:
```python
a=[6,2,6,4,4,4,8,4,6,6]
sm=[1,2,6,4,2,2,4,2,8,8]
t=[2,6,8,4]
def geta(n):
    if n==1:
        return 1
    else:
        return a[(n-1)%10]
def gets(n):
    last=geta(n)
    id=t.index(last)
    return t[(id+(n//5))%4]
def f(n):
    if n<=10:
        return sm[n-1]
    else:
        return (gets(n)*f(n//5))%10
def testt(n):
    s=1
    for i in range(2,n+1):
        s=s*i
    return s
fl=True
while fl:
    try:
        n=int(input())
        print(f(n))
    except:
        fl=False
```
再见，qwq~

---

## 作者：xiwang (赞：9)

刚看这道题我把数据范围看成了10100于是欢乐地写了个暴力爆了0

完了去学习了一点姿势

进入正题

我们想，100个数字，我们需要想个奇妙的方法，比如logn的

我们考虑给要乘起来的n个数字每20个分成一组

然后我们就考虑每一组都把2和5成对去掉，能去4组

之后把原先是5的倍数去掉了5剩下的数放着不管，每组其他的数乘完了尾数就是6

而原先是5的倍数的数，都除以5之后就是1到n/5了....

我们用foo(x)表示x!的尾数，易证foo(x)=foo(x+20)

那么由上面有foo(n)=6^(n/20)\*foo(n/5)\*foo(n%20)

注意到6的几次方尾数都是6

于是就可以愉快地递归计算了

注意字符串读入，记得搞高精

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int inf=0x3f3f3f3f;
const int N=128;
const int f[32]={1,1,2,6,4,2,2,4,2,8,4,4,8,4,6,8,8,6,8,2};
char s[N];
int a[N];
int main(){
    int t=5;
    int n,k,ass;
    while(t--){
        ass=1;
        scanf("%s",s);
        n=strlen(s);
        for(int i=0;i<n;i++)a[n-i-1]=s[i]-'0';
        while(n>1){
            while(a[n-1]==0)n--;
            ass=ass*f[a[1]%2*10+a[0]]%10;
            int tp=0;
            for(int i=n-1;i>=0;i--){
                tp=tp*10+a[i];
                a[i]=tp/5;
                tp%=5;
            }
        }
        printf("%d\n",ass*f[a[0]]%10);
    }
    return 0;
}
```

---


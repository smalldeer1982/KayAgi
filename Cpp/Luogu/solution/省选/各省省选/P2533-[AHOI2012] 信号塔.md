# [AHOI2012] 信号塔

## 题目描述

在野外训练中，为了确保每位参加集训的成员安全，实时的掌握和收集周边环境和队员信息非常重要，集训队采用的方式是在训练所在地散布 $N$ 个小型传感器来收集并传递信息，这些传感器只与设在集训地中的信号塔进行通信，信号塔接收信号的覆盖范围是圆形，可以接收到所有分布在该集训区域内所有 $N$ 个小型传感器（包括在该圆形的边上）发出的信号。信号塔的功率与信号塔接收范围半径的大小成正比，因为是野外训练，只能使用事先储备好的蓄电设备，因此在可以收集所有传感器信息的基础上，还应使得信号塔的功率最小。小龙帮助教官确定了一种信号塔设置的方案，既可以收集到所有 $N$ 个传感器的信号，又可以保证这个信号塔的功率是最小的。同学们，你们知道，这个信号塔的信号收集半径有多大，它应该设置在何处吗?

## 说明/提示

队员是否在边界上的判断应该符合他到圆心的距离与信号塔接受半径的差的绝对值小于 $10^{-6}$，最终结果保留 $2$ 位小数。

对于 $30\%$ 的数据，满足 $1\le N \le 10^4$  
对于 $70\%$ 的数据，满足 $1\le N \le 2\times10^4$  
对于 $100\%$ 的数据，满足 $1\le N \le 10^6$

本题存在 hack 数据，计 0 分。

## 样例 #1

### 输入

```
5
1.200 1.200
2.400 2.400
3.800 4.500
2.500 3.100
3.900 1.300```

### 输出

```
2.50 2.85 2.10```

# 题解

## 作者：消失的海岸线 (赞：7)

人话题意：给出平面上 N 个点,N<=10^6，请求出一个半径最小的圆覆盖住所有的点，并求出该点的坐标与半径。

即经典的最小圆覆盖问题，在此我们介绍随机增量法：

随机增量法是一个可以在 **期望**$O(n)$ 时间内求出最小圆覆盖的算法，首先它的算法流程是这样的


枚举第一个点 $i$，若不在目前圆内，设它为圆心

枚举第二个点 $j$，若不在当前圆内，设当前圆为以 $i,j$ 为直径的圆

枚举第三个点 $k$，若不在当前圆内，设当前圆为 $i,j,k$ 的外接圆


###正确性

显然最优解一定是两个点为直径的圆或者一个三角形的外接圆，否则肯定能缩的更小。那么这么枚举的正确性是比较显然的了


###时间复杂度

这是一个重点，这么做看似是$O(n^3)$ 的，不过对于**随机顺序**的点，是可以**期望**$ O(n)$ 的。下面考虑证明：


显然，最后一层循环枚举从 $1~j$，只要进入循环就一定要跑完，所以是$O(j)$ 的

考虑倒数第二层循环，什么情况下会进入第三层循环呢？仅当 $j$ 不在前 $j-1$ 个点形成的圆中，考虑 $j$ 个点形成的圆是由三个点确定的，那么第 $j$ 个 (最后一个点) 若是三个点之一，则需要扩大圆，否则不需要进入第三层循环，这个概率是$\frac{3}{j}$ 的，所以第二层的复杂度是$O(i)$ 的

同理，第一层的复杂度就是$O(n)$ 的了


###实现

以此题为例，给出在下的AC代码：

```cpp
#include <cmath>
#include <queue>
#include <cstdio>
#include <iomanip>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#define N 500010
#define eps 1e-6
#define ll long long
using namespace std;
inline int read() 
{ 
    int x=0,f=1;char ch=getchar(); 
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();} 
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();} 
    return x*f; 
}
struct point
{
    double x,y;
}a[N],O;
double R;
int n;
double dis(point x,point y)
{return sqrt((x.x-y.x)*(x.x-y.x)+(x.y-y.y)*(x.y-y.y));}
bool in_cir(point x)
{return dis(x,O)-R<eps;}
point get_O(point x1,point x2,point x3)
{
    double a,b,c,d,e,f;
    point ans;
    a=x2.x-x1.x,b=x2.y-x1.y,c=x3.x-x2.x,d=x3.y-x2.y;
    e=x2.x*x2.x+x2.y*x2.y-x1.x*x1.x-x1.y*x1.y;
    f=x3.x*x3.x+x3.y*x3.y-x2.x*x2.x-x2.y*x2.y;
    ans.x=(f*b-e*d)/(c*b-a*d)/2; 
    ans.y=(a*f-e*c)/(a*d-b*c)/2;
    return ans; 
}
int main()
{
    n=read();
    for(int i=1;i<=n;i++)
    scanf("%lf %lf",&a[i].x,&a[i].y);
    for(int i=1;i<=n;i++)
    swap(a[i],a[rand()%n+1]);
    O=a[1];
    for(int i=1;i<=n;i++)
    if(!in_cir(a[i]))
    {
        O=a[i];
        for(int j=1;j<i;j++)
        if(!in_cir(a[j]))
        {
            O.x=(a[i].x+a[j].x)/2;
            O.y=(a[i].y+a[j].y)/2;
            R=dis(a[i],a[j])/2;
            for(int k=1;k<j;k++)
            if(!in_cir(a[k]))
            {
                O=get_O(a[i],a[j],a[k]);
                R=dis(O,a[i]);
            }
        }
    }
    printf("%.2lf %.2lf %.2lf",O.x,O.y,R);
}
```
为了避免可能存在的markdown格式错误，可以在本人的博客中看到同样的内容

http://www.zgz233.xyz/2017/07/10/bzoj-133613372823-balkan2002alien%E6%9C%80%E5%B0%8F%E5%9C%86%E8%A6%86%E7%9B%96ahoi2012%E4%BF%A1%E5%8F%B7%E5%A1%94/


---

## 作者：iorit (赞：5)

[原题](https://www.luogu.com.cn/problem/P2533)

_上次的题解被学长hack掉了，懒得调了，把退火做法放上来吧。_

考虑模拟退火：选一个初始点，从这个点开始跑退火。问题是初始点怎么选。 

首先所有点取平均大概是不怎么对的，只要很多点密集分布在一个区域再放一个点在很远处就可以卡掉。 

发现这个圆只要能够盖住这些点的凸包就能够盖住所有点，所以考虑在凸包内找一个比较中间的点。比方说凸包直径的中点。

于是把凸包直径的中点用旋转卡壳卡出来，用该点作为初始点，退火随机偏移，记录最优解。

当然你也可以选择其他较好的点作为初始点，这样可以省去旋转卡壳的代码。然而我没有写出来。

### 代码
```cpp
const int N = 1e6 + 10;
const int inf = 0x3fffffff;
const double eps = 1e-6;
int n;
struct node
{
	double x,y;
	friend bool operator == (node x , node y)
		{return x.x == y.x && x.y == y.y;}
}a[N],*st;
int s[N],top;
double ct(node p1 , node p2) // 叉积 
{
	p1.x -= st->x,p2.x -= st->x;
	p1.y -= st->y,p2.y -= st->y;
	return p1.x * p2.y - p2.x * p1.y;
}
inline double dis(node p1 , node p2) // 距离 
	{return sqrt( (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) );}
inline bool cmp(node p1 , node p2) // 极角排序 
	{return atan2(p1.y - st->y , p1.x - st->x) < atan2(p2.y - st->y , p2.x - st->x);}
inline node mid(node p1 , node p2)
	{return (node){ (p1.x + p2.x) / 2 , (p1.y + p2.y) / 2 };}
inline void graham() // Graham凸包 
{
	st = &a[1];
	for(register int i = 1;i <= n;i++)
		if(a[i].y < st->y || a[i].y == st->y && a[i].x < st->x)
			st = &a[i];
	swap(a[1] , *st);
	st = &a[1];
	sort(a + 2 , a + n + 1 , cmp);
	top = 1,s[0] = 1,s[1] = 2;
	for(int i = 3;i <= n;i++)
	{
		st = &a[ s[top - 1] ];
		while(top > 0 && ct( a[ s[top] ] , a[i] ) <= 0)
			st = &a[ s[--top - 1] ];
		s[++top] = i;
	}
}
double query(double x , double y) // 以(x, y)为圆心时的最小半径 
{
	double res = -inf;
	for(register int i = 0;i <= top - 1;i++)
		res = max(dis( (node){x , y} , a[ s[i] ] ) , res);
	return res;
}
const double delta = 0.997; // 降温系数 
double ans,ansx,ansy;
void SA() // 模拟退火 
{
	double T = 3000;
	while(T > 1e-12)
	{
     	double x = ansx + (rand() * 2 - RAND_MAX) * T;
     	double y = ansy + (rand() * 2 - RAND_MAX) * T;
		double cur = query(x , y);
		if(cur < ans)
			ans = cur,ansx = x,ansy = y;
		else if( exp( (cur - ans) / T ) * RAND_MAX < rand() ) // 一定概率接受当前答案 
			ansx = x,ansy = y;
		T *= delta;
	}
}
int main()
{
	srand( time(NULL) );
	scanf("%d" , &n);
	for(int i = 1;i <= n;i++)
		scanf("%lf%lf" , &a[i].x , &a[i].y);
	graham();
	s[++top] = s[0];
	node A,B; // 凸包直径上的两点 
	int j = 1;
	double maxn = -inf;
	for(register int i = 0;i <= top - 1;i++) // 旋转卡壳
	{
		st = &a[ s[i] ];
		while(fabs( ct( a[ s[i + 1] ] , a[ s[j] ] ) ) - fabs( ct( a[ s[i + 1] ] , a[ s[j + 1] ] ) ) < eps)
		{
			++j;
			if(j >= top)
				j = 0;
		}
		double d = dis( a[ s[i] ] , a[ s[j] ] );
		if(d > maxn)
		{
			maxn = d;
			A = a[ s[i] ];
			B = a[ s[j] ];
		}
	}
	ansx = (A.x + B.x) / 2;
	ansy = (A.y + B.y) / 2;
	ans = query(ansx , ansy);
//	while(clock() < CLOCKS_PER_SEC * 0.95)
	for(int i = 1;i <= 150;i++)
		SA();
	printf("%.2lf %.2lf %.2lf\n" , ansx , ansy , ans);
	return 0;
}
```

---

## 作者：_xbn (赞：4)

[似乎和这题是双倍经验](https://www.luogu.com.cn/problem/P1742)。

题目要我们求一个最小的圆，覆盖给定的所有点。

对于最小圆覆盖，我们可以用随机增量法，能降低时间复杂度。

他的具体步骤就是，从第一个点开始作为初始圆，圆心就是这个点 $a(1)$。

然后依次向后枚举 $a(i)$，如果下一个点在当前已知的圆的内部，我们就继续枚举下一个点。

而如果此时这个点在当前圆的外部，我们就要重新设置一个新的圆了。

枚举 $i$ 前面的点 $j$，如果此时两个点以他们的连线的中点作为圆心，两点连线作为直径，继续枚举 $j$ 前面的点 $k$，如果此时 $k$ 在此时的圆外，那么 $i$ 和 $j$ 和 $k$ 三个点组成的圆就是目前的最优解。

简易证明，我们取一二个点,和第四个点进行三点定圆。 因为第四个点不在前三个点的圆中。所以第四个点定的新圆一定比前三个定的圆大。

```cpp
#include<bits/stdc++.h>
#define pf(x) (x) * (x)
#define eps 1e-12
using namespace std;
const int N = 1000002;
int n;
struct point
{
    double x;
    double y;
}o, a[N];// o 为最小圆

double r;

double dis(point a, point b)
{
    return sqrt(pf(a.x - b.x) + pf(a.y - b.y));
}

void get(point a, point b, point c)
{
    double a11 = b.x - a.x;
    double a12 = b.y - a.y;
    double b1 = (pf(b.x) - pf(a.x) + pf(b.y) - pf(a.y)) * 0.5;
    double a21 = c.x - a.x;
    double a22 = c.y - a.y;
    double b2 = (pf(c.x) - pf(a.x) + pf(c.y) - pf(a.y)) * 0.5;

    o.x = (b1 * a22 - a12 * b2) / (a11 * a22 - a12 * a21);
    o.y = (a11 * b2 - b1 * a21) / (a11 * a22 - a12 * a21);
    r = dis(o, a);
}

int main()
{
    cin >> n;
    for(int i = 1; i <= n; i++)
    {
        cin >> a[i].x >> a[i].y;
    }
    random_shuffle(a + 1, a + 1 + n);//随机打乱一个序列
    o = a[1];
    r = 0;
    for(int i = 2; i <= n; i++)
    {
        if(dis(a[i], o) > r + eps)
        {
            o = a[i];
            r = 0;
            for(int j = 1; j <= i - 1; j++)
            {
                if(dis(a[j], o) > r + eps)
                {
                    o.x = (a[i].x + a[j].x) / 2;
                    o.y = (a[i].y + a[j].y) / 2;
                    r = dis(o, a[j]);
                    for(int k = 1; k <= j - 1; k++)
                    {
                        if(dis(a[k], o) > r + eps)
                        {
                            get(a[i], a[j], a[k]);
                        }
                    }   
                }
            }
        }
    }
    printf("%.2lf %.2lf %.2lf", o.x, o.y, r);
    return 0;
}
```


---

## 作者：WaterM (赞：3)

[传送门](https://www.luogu.com.cn/problem/P2533)  
题意：用一个最小的圆覆盖住 $n$ 个点，求出圆的圆心坐标和半径。  
  
本题即为最小覆盖圆问题。可采用随机增量法。作为一名 AH 的初一学生，代码里就不用直线的**一般式**了（因为我不会），老老实实用了**截距式**。截距式特判的点较多，需多加注意。  
  
## 最小覆盖圆的性质：
### 性质一：最小覆盖圆是唯一且位置确定的。
**证明：**  
若不唯一（令有两个最小覆盖圆），则所有点**一定在这两个圆相交区域中**。如果以**两圆公共弦**为直径作圆，新圆既比原来两个圆小，也包含了所有的点。所以原来两个圆**不是最小覆盖圆**（有更小的），假设不成立，所以得证。
### 性质二：若 $\odot O$ 是点 $P_1 \sim P_{n-1}$ 的最小覆盖圆，则若有一点 $P_n$ 在 $\odot O$ 外，则点 $P_1 \sim P_n$ 的最小覆盖圆 $\odot O'$ 过点 $P_n$。
易得 $\odot O$ 内含或内切于 $\odot O'$。内切时，$\odot O'$ 半径最小。此时若 $\odot O'$ 不过点 $P_n$，一定可构造一圆，在 $\odot O$ 内部且过 $P_n$。说明不过时不是最小覆盖圆。   
（自己画图理解就好，这里比较难说明，但是好理解。感觉没讲清楚）
### 性质三（最重要的一点）：最小覆盖圆一定是点集中以某两点为直径的圆或以某三点构成三角形的外接圆。（点集中只有一个点除外）
任作一圆，使得其为覆盖圆。再不断缩小（想象一下），最后只有两种情况：  
1. 圆上只有两点：可收缩至两点构成线段为圆的直径。  
2. 圆上有三点（以上）：不能再收缩，因**三点定圆**，所以为某三点形成三角形的外接圆。  
  
然后，可以开始算法了……
## 随机增量法求最小覆盖圆
### 一、算法步骤
#### 0. 初始化
`random_shuffle` 保证点排列随机，初始化圆（圆心为第 $1$ 个点，半径为 $0$）。
#### 1. 遍历每个点（第一重循环）
从 $2$ 到 $n$ 循环 $i$，循环到 $i$ 表示求解**从点 $1$ 到点 $i$ 的最小覆盖圆**。若当前点不在最小覆盖圆内，则**最小覆盖圆一定过第 $i$ 个点（性质二）**，我们再初始化圆（圆心为第 $i$ 个点，半径为 $0$），进入第二重循环。  
#### 2. 再遍历（第二重循环）
由 1. 知，最小覆盖圆过点 $i$。于是，我们从 $1$ 到 $i$ 循环 $j$。若点 $j$ 不在圆内，则**最小覆盖圆一定过第 $j$ 个点（性质二）**。圆过两点（$i$ 和 $j$），可将圆再初始化为以线段 $ij$ 为直径的圆（具体细节见代码），进入第三重循环。
#### 3. 第三次遍历（第三重循环）
由 2. 知，最小覆盖圆过点 $i,j$。于是，我们从 $1$ 到 $i$ 循环 $k$。若点 $k$ 不在圆内，则**最小覆盖圆一定过第 $k$ 个点（性质二）**。由此，我们得到了一个过点 $i,j,k$ 的圆（$i,j,k$显然不共线，否则不会进入到当前循环），直接求三角形外心（三条**中垂线**交点，求两条交点就行）就是最小覆盖圆圆心，半径是圆心到任一点距离。（求出的最小覆盖圆仅供当前循环使用，跳出循环后不满足最终的最小覆盖圆一定过某两点或某三点）  
  
由此，我们求出了最小覆盖圆。  
  
某些数学的计算方法：  
- 实数比较大小：若差的绝对值小于 $10^{-6}$，则认为相等。比大小直接比。  
- 两点距离：横差平方，纵差平方，相加开根。
- 线段的中点坐标：横平均，纵平均
- 确定过两点的直线：直接设解析式，带入解方程即可。若没有斜率，需特判。
- 求两条直线交点：直接联立解析式解坐标。
- 求线段的中垂线：先求中点，再求过其的直线（两直线垂直，斜率之积为 $-1$，设截距解方程即可），注意特判没有斜率的直线。
- 判断点在圆内/上/外：即判断点到圆心距离小于/等于/大于半径。
- 求三角形外心：任两边的中垂线交点。  
（有些能搜到的，可自行百度）  
  
代码如下（注释做得很详细）：
```cpp
#include <bits/stdc++.h>
#define inf 0x3f3f3f3f
#define Linf 0x3f3f3f3f3f3f3f3f
#define re register
const int N = 1000002;
const double eps = 1e-6;
int n;
int judge(double x, double y) {
	if(fabs(x-y) < eps) return 0;	//x = y
	if(x > y) return 1;	//x > y
	return -1;	// x > y
}

struct point {double x, y} p[N];
double dis(point A, point B) {return sqrt((A.x-B.x)*(A.x-B.x) + (A.y-B.y)*(A.y-B.y));}	//求两点距离
point mid(point A, point B) {return (point) {(A.x+B.x)/2, (A.y+B.y)/2};}	//两点所成线段的中点

struct line {double k, b; bool flag;};	//函数 y = kx + b flag表示是否有斜率，若没有，直线表示为x=b
line solve_line(point A, point B) {	//求两点确定直线的解析式
	if(judge(A.x, B.x) == 0) return (line) {0, A.x, false};	//没有斜率
	double k = (A.y-B.y) / (A.x-B.x);	//求斜率
	double b = A.y - k*A.x;	//求截距：b = y - kx
	return (line) {k, b, true};	//直线解析式
}
point cross(line l1, line l2) {	//求两条直线交点
	double x, y;
	if(l2.flag == false) std::swap(l1, l2);	//统一到l1不存在斜率，方便代码书写
	if(l1.flag == false) x = l1.b;	//若l1不存在斜率，则x直接赋值为l1.b（l1解析式为 x = l1.b）
	else x = (l2.b-l1.b) / (l1.k-l2.k);	//横坐标
	y = l2.k*x + l2.b;//一定要用l2计算，因为l1可能不存在斜率
	return (point) {x, y};
}
line f(point A, point B) {	//求线段AB的中垂线
	point C = mid(A, B);	//AB中点
	line l = solve_line(A, B);	//直线AB解析式
	if(l.flag == false) return (line) {0, C.y, true};	//平行于y轴线段的中垂线
	if(l.k == 0) return (line) {0, C.x, false};	//平行于x轴线段的中垂线
	double k = -1 / l.k;	//中垂线斜率
	double b = C.y - k*C.x;	//中垂线截距
	return (line) {k, b, true};
}

struct circle {point O; double r;} c;
circle solve_circle(point A, point B, point C) {
	point O = cross(f(A, B), f(A, C));
	double r = dis(O, A);
	return (circle) {O, r};
}
int main() {
	scanf("%d", &n);
	for(re int i = 1; i <= n; ++i)	scanf("%lf%lf", &p[i].x, &p[i].y);
	std::random_shuffle(p+1, p+n+1);//保证随机化
	
	c = (circle) {p[1], 0};	//初始化圆以p[1]为圆心，0为半径
	for(re int i = 2; i<=n; ++i)
		if(judge(dis(c.O, p[i]), c.r) == 1) {	//点p[i]在圆外
			c = {p[i], 0};	//确定圆过p[i]（性质二），初始化圆以p[i]为圆心，0为半径，进行下一重循环
			for(re int j = 1; j <= i; ++j)
				if(judge(dis(c.O, p[j]), c.r) == 1) {	//点p[j]在圆外
					c = (circle) {mid(p[i], p[j]), dis(p[i], p[j])/2};	//初始化以线段 p[i] p[j] 为直径的圆（性质三）
					for(re int k = 1; k <= j; ++k)
						if(judge(dis(c.O, p[k]), c.r) == 1) c = solve_circle(p[i], p[j], p[k]);	//点p[k]在圆外，最小覆盖圆过点p[k]（性质二），直接求三角形外接圆（性质三）
				}
		}
	printf("%.2f %.2f %.2f", c.O.x, c.O.y, c.r);
    return 0;
}
```
别直接抄。。。

---

## 作者：Nuyoah_awa (赞：1)

### 题目大意

给定 $n$ 个点，求能覆盖这 $n$ 个点的最小的圆。

### 题目分析

本题主要用到随机增量法，本蒟蒻将于本文详细介绍随机增量法。

随机增量算法是计算几何的一个重要算法，它对理论知识要求不高，算法时间复杂度低，应用范围广大。

### 增量法（Incremental Algorithm）

增量法，顾名思义就是先确定值，再将其增量的算法。

增量法的思想与第一数学归纳法类似，它的本质是将一个问题化为规模刚好小一层的子问题。解决子问题后加入当前的对象。

增量法形式简洁，可以应用于许多的几何题目中。

增量法往往结合随机化，可以避免最坏情况的出现。

希尔排序实际上就是一种缩小增量法。

### 最小圆问题

首先，我们不难发现，最后的圆一定是两点所连线段为直径的圆或三点所连成的三角形的外接圆。于是，我们考虑一个一个加入这些点后最小圆覆盖的变化。

一开始只有第一个点构成一个半径为 $0$ 的圆，考虑加入第 $i$ 个点，按下面步骤实施：

1. 如果这个点在之前的最小圆中则跳过不管。
2. 我们加入点 $\forall j \in [1, i-1]$，如果这个点已经在当前最小圆中我们不更新。否则以 $j$ 与 $i$ 所连直径为直径画圆。
3. 但这时 $\forall k \in [1, j-1]$ 有可能有出圆了，所以我们枚举这些点，然后以 $\Delta ijk$ 的外接圆为新圆。

最后得到的圆即为答案。然后考虑时间复杂度。

乍一看复杂度是 $\mathcal O(n ^ 3)$，但是我们如果给这些点随机排列一下，再来仔细分析一下复杂度。

显然三个操作分别是 $\mathcal O(n)$ 的时间复杂度，最主要的部分在于会不会进入下一层循环。

我们考虑 $1$ 到 $2$ 的过程，三点定一个圆，所以一个点是答案的概率为 $\dfrac{3}{i}$，也就是只有 $\dfrac{3}{i}$ 的概率会进到下一层循环。而 $2$ 到 $3$ 的过程是类似，最后 $3$ 的复杂度是 $\mathcal O(j)$ 的，所以 $2$ 的复杂度是 $\sum\limits_{j = 1}^{j \le i} \mathcal O(j) \times \dfrac{3}{i} = \mathcal O(i)$，那么可以得到总的时间复杂度是 $\sum\limits_{i = 1}^{i \le n} \mathcal O(i) \times \dfrac{3}{i} = \mathcal O(n)$ 的。

双倍经验：[P1742](https://www.luogu.com.cn/problem/P1742)。

### code
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>

using namespace std;

const int N = 1e6 + 5, eps = 1e-12;
struct node{
	double x, y;
}p[N], o;
int n;
double r;

double dist(node u, node v)
{
	return sqrt((u.x-v.x) * (u.x-v.x) + (u.y-v.y) * (u.y-v.y));
}

node get1(node u, node v)
{
	node w;
	w.x = (u.x + v.x) / 2;
	w.y = (u.y + v.y) / 2;
	return w;
}

node get2(node u, node v, node w)
{
	double a, b, c, d, e, f;
    node res;
    a = v.x - u.x, b = v.y - u.y, c = w.x - v.x, d = w.y - v.y;
    e = v.x * v.x + v.y * v.y - u.x * u.x - u.y * u.y;
    f = w.x * w.x + w.y * w.y - v.x * v.x - v.y * v.y;
    res.x = (f * b - e * d) / (c * b - a * d) / 2; 
    res.y = (a * f - e * c) / (a * d - b * c) / 2;
    return res;
}

int main()
{
	scanf("%d", &n);
	for(int i = 1;i <= n;i++)
		scanf("%lf %lf", &p[i].x, &p[i].y);
	random_shuffle(p + 1, p + n + 1);
	o = p[1];
	for(int i = 1;i <= n;i++)
	{
		if(dist(o, p[i]) <= r - eps)
			continue;
		o = p[i], r = 0;
		for(int j = 1;j < i;j++)
		{
			if(dist(p[j], o) <= r - eps)
				continue;
			o = get1(p[i], p[j]);
			r = dist(p[i], p[j]) / 2;
			for(int k = 1;k < j;k++)
			{
				if(dist(p[k], o) <= r)
					continue;
				o = get2(p[i], p[j], p[k]);
				r = dist(o, p[k]);
			}
		}
	}
	printf("%.2lf %.2lf %.2lf", o.x, o.y, r);
	return 0;
}
```

---

## 作者：DreamLand_zcb (赞：1)

## 简要题意

给出 $N$ 个点，求出最小的能覆盖所有点的圆的中心坐标和半径。

## 思路

在九年级上“圆”一章我们学过“三点定圆”，所以我们可以构造 $N$ 个点中任意三点所组成的圆，然后在每次构造后判断历史答案可否包含这三个点，如果不能就把构造出来的圆覆盖到历史答案上。

接下来的问题：怎样根据三个点构造出一个圆呢？

我们假设这个圆的圆心是 $O(x, y)$，其余三个点的坐标为 $A(x_0, y_0),B(x_1, y_1),C(x_2, y_2)$，因为圆心到三个点的距离相等，我们可以得出下列方程组：

$$ 
\begin{cases}
  (x - x_0)^2 + (y - y_0)^2 = (x - x_1)^2 + (y - y_1)^2\\
  (x - x_1)^2 + (y - y_1)^2 = (x - x_2)^2 + (y - y_2)^2
\end{cases}
$$

展开二次项后移项：

$$ 
\begin{cases}
  2x(x_1 - x_0) + 2y(y_1 - y_0) = x_1^2 - x_0^2 + y_1^2 - y_0^2 \\
  2x(x_2 - x_1) + 2y(y_2 - y_1) = x_2^2 - x_1^2 + y_2^2 - y_1^2
\end{cases}
$$

方便起见将原系数换成 $a,b,c,d,e,f$：


$$ 
\begin{cases}
  ax+by = c\\
  dx+ey = f
\end{cases}
$$

其中：

$$ 
\begin{cases}
  a = 2(x_1 - x_0) \\
  b = 2(y_1 - y_0) \\
  c = x_1^2 - x_0^2 + y_1^2 - y_0^2 \\
  d = 2(x_2 - x_1) \\
  e = 2(y_2 - y_1) \\
  f = x_2^2 - x_1^2 + y_2^2 - y_1^2
\end{cases}
$$

解二元一次方程组得：


$$ 
\begin{cases}
  x = \dfrac{ce - fb}{ae - db} \\
  y = \dfrac{af - dc}{ae - db}
\end{cases}
$$

设 $g = ae - db$ 则：

$$ 
\begin{cases}
  x = \dfrac{ce - fb}{g} \\
  y = \dfrac{af - dc}{g}
\end{cases}
$$

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define setp setprecision
#define mem(a, m) memset(a, m, sizeof(a))
using namespace std;

const double eps = 1e-12;
int n; 
struct node {
	double x, y;
}t[1000005];
double r;//半径答案 
node p;//坐标答案 
double dist(node a, node b)
{
	double u = (a.x - b.x), v = (a.y - b.y);
	return sqrtl(u * u + v * v);
}
void work(node u, node v, node w)
{
	double a = 2 * (u.x - v.x);
	double b = 2 * (u.y - v.y);	
	double c = u.x * u.x + u.y * u.y - v.x * v.x - v.y * v.y;
	double d = 2 * (v.x - w.x);
	double e = 2 * (v.y - w.y);
	double f = v.x * v.x + v.y * v.y - w.x * w.x - w.y * w.y;
	double g = a * e - b * d;
	double px = (c * e - f * b) / g;
	double py = (a * f - d * c) / g;
	p = (node){px, py};
	r = dist(p, u);
}
int main()
{
	ios::sync_with_stdio(false);
	cin >> n;
	for(int i=1;i<=n;i++)	cin >> t[i].x >> t[i].y;
	random_shuffle(t+1, t+n+1);
	for(int i=1;i<=n;i++)
	{
		if(dist(p, t[i]) <= r - eps)	continue;
		p = t[i], r = 0;
		for(int j=1;j<i;j++)
		{
			if(dist(p, t[j]) <= r - eps)	continue;
			p.x = (t[i].x + t[j].x) / 2;
			p.y = (t[i].y + t[j].y) / 2;
			r = dist(t[i], t[j]) / 2;
			for(int k=1;k<j;k++)
			{
				if(dist(p, t[k]) <= r - eps)	continue;
				work(t[i], t[j], t[k]);
			}
		}
	}
	cout << fixed << setp(2) << p.x << " " << p.y << " ";
	cout << fixed << setp(2) << r;
//  printf("%.10lf\n%.10lf %.10lf", r, p.x, p.y);
	return 0;
}

```


---

## 作者：decoqwq (赞：1)

模拟退火题目

$Orz$随机增量法dalao 蒟蒻不会神仙方法，只能玩退火了

常规套路，每次随机步长，然后移动求值比较即可

~~因为我太菜了~~，所以直接用的$random\_shuffle$来随机了

```cpp
#include <bits/stdc++.h>
#define twice(x) ((x)*(x)) 
using namespace std;
const int N=1e5+1;
const double eps=1e-7;
struct node
{
    double x,y;
}p[N],c;
int n;
double r;
double calc(const node &a,const node &b)
{
    return sqrt(twice(a.x-b.x)+twice(a.y-b.y));
}
node get_focus(const node &a,const node &b,const node &c)
{
    node t;
    double c1=(a.x*a.x-b.x*b.x+a.y*a.y-b.y*b.y)/2.0;
    double c2=(c.x*c.x-b.x*b.x+c.y*c.y-b.y*b.y)/2.0;
    t.x=(c1*(c.y-b.y)-c2*(a.y-b.y))/((a.x-b.x)*(c.y-b.y)-(c.x-b.x)*(a.y-b.y));
    t.y=(c1*(c.x-b.x)-c2*(a.x-b.x))/((a.y-b.y)*(c.x-b.x)-(c.y-b.y)*(a.x-b.x));
    return t;
}
void work()
{
    random_shuffle(p+1,p+n+1);
    c=p[1];
	r=0;
    for(int i=2;i<=n;i++)
	{
        if(calc(p[i],c)+eps>r)
		{
            c=p[i];r=0;
            for(int j=1;j<i;j++)
			{
                if(calc(p[j],c)+eps>r)
				{
                    c.x=(p[i].x+p[j].x)/2;
                    c.y=(p[i].y+p[j].y)/2;
                    r=calc(c,p[j]);
                    for(int k=1;k<j;k++)
					{
                        if(calc(p[k],c)+eps>r)
						{
                            c=get_focus(p[i],p[j],p[k]);
                            r=calc(c,p[k]);
                        }
                    }
                }
            }
        }
    }
    printf("%.2lf %.2lf %.2lf ",c.x,c.y,r);
}
int main()
{
    srand(time(0));
    cin>>n;
    for(int i=1;i<=n;i++) 
	{
		scanf("%lf%lf",&p[i].x,&p[i].y);
	}
    work();
    return 0;
}
```

---

## 作者：OIer_Tan (赞：0)

最小圆覆盖板子题。

[题目传送门](https://www.luogu.com.cn/problem/P2533) [双倍经验](https://www.luogu.com.cn/problem/P1742)

## 思路

首先你应该学会使用三点定圆。\
如果不会，请出门左转 [九上数学课本](https://book.pep.com.cn/1321001301141/mobile/index.html)。

显然我们现在有了一个 $O(n^4)$ 的做法，即暴力枚举三个点，然后扫一遍检查是否全部覆盖，如果是就更新答案。

但是这样做显然是会超时的。我们想到增量法，过程如下：

一开始只有第一个点构成一个半径为 $0$ 的圆。然后枚举当前点 $i$：
1. 如果这个点在之前的最小圆中就跳过它。
2. 我们接着枚举第 $j\in[i + 1,n]$ 个点，如果这个点已经在当前最小圆中则不更新答案。否则以 $j$ 与 $i$ 所连直径为直径画圆。
3. 但是这时候有可能会导致第 $k\in[j+1,n]$ 点在圆外，这时可以以 $\triangle ijk$ 的外接圆，即以这三个点定一个圆，更新答案。

看起来这样的复杂度是 $O(n^3)$ 的（实际上也是），但可以想到使用随机化，将这 $n$ 个点任意重排，**期望复杂度** 即为 $O(n)$，证明如下：

由于一堆点最多只有 $3$ 个点确定了最小覆盖圆，因此 $n$ 个点中每个点参与确定最小覆盖圆的概率不大于 $\frac{3}{n}$，所以，每一层循环在第 $i$ 个点处跳到下一步的概率不大于 $\frac{3}{i}$。

依次设每一层循环的期望时间复杂度为 $T_1(n),T_2(n),T_3(n)$，则有：

$$
T_1(n)=O(n)+\sum^{n}_{i=1}\frac{3}{i}T_2(i)\\
T_2(n)=O(n)+\sum^{n}_{i=1}\frac{3}{i}T_3(i)\\
T_3(n)=O(n)
$$

将式子展开，不难得 $T_1(n)=T_2(n)=T_3(n)=O(n)$。

综上所述，期望的总时间复杂度为 $O(n)$。\
其实只要重排用的办法不差，是几乎不会跑出最坏情况的。

## 代码

```cpp
#include<bits/stdc++.h>

#ifndef CRT
#define endl '\n' 
#endif

using namespace std ;

typedef long long ll ;
typedef unsigned long long ull ;

const ll N = 1e6 + 5 ;

struct point 
{
	double x , y ;
	point ( double x = 0 , double y = 0 ) : x ( x ) , y ( y ) {}
	friend bool operator < ( point& a , point & b )
	{
	    return make_pair ( a.x , a.y ) < make_pair ( b.x , b.y ) ;
	}
} p [N] , ans ;

ll n ;

double r ;

double sqr ( double x )
{
	return x * x ;
}

double dis ( point a , point b )
{
	return sqrtl ( sqr ( a.x - b.x ) + sqr ( a.y - b.y ) ) ;
}

bool cmp ( double a , double b )
{
	return fabsl ( a - b ) < 1e-8 ;
}

point getans ( point a , point b , point c )
{
	double a1 , a2 , b1 , b2 , c1 , c2 ;
	point ans ;
	a1 = 2 * ( b.x - a.x ) , b1 = 2 * ( b.y - a.y ) , c1 = sqr ( b.x ) - sqr ( a.x ) + sqr ( b.y ) - sqr ( a.y ) ;
	a2 = 2 * ( c.x - a.x ) , b2 = 2 * ( c.y - a.y ) , c2 = sqr ( c.x ) - sqr ( a.x ) + sqr ( c.y ) - sqr ( a.y ) ;
	if ( cmp ( a1 , 0 ) )
	{
		ans.y = c1 / b1 ;
		ans.x = ( c2 - ans.y * b2 ) / a2 ;
	}
	else if ( cmp ( b1 , 0 ) ) 
	{
		ans.x = c1 / a1 ;
		ans.y = ( c2 - ans.x * a2 ) / b2 ;
	}
	else
	{
		ans.x = ( c2 * b1 - c1 * b2 ) / ( a2 * b1 - a1 * b2 ) ;
		ans.y = ( c2 * a1 - c1 * a2 ) / ( b2 * a1 - b1 * a2 ) ;
	}
	return ans ;
}

mt19937_64 gen ;

int main ()
{
	// freopen ( ".in" , "r" , stdin ) ;
	// freopen ( ".out" , "w" , stdout ) ;
	ios::sync_with_stdio ( 0 ) ;
	cin.tie ( 0 ) ;
	cout.tie ( 0 ) ;
	cin >> n ;
	for ( ll i = 1 ; i <= n ; i ++ )
	{
		cin >> p [i].x >> p [i].y ;
	}
	sort ( p + 1 , p + 1 + n ) ;
	ans = p [1] ;
	for ( ll i = 1 ; i <= n ; i ++ )
	{
		if ( dis ( ans , p [i] ) < r || cmp ( dis ( ans , p [i] ) , r ) ) 
		{
			continue ;
		}
		ans.x = ( p [i].x + p [1].x ) / 2 ;
		ans.y = ( p [i].y + p [1].y ) / 2 ;
		r = dis ( p [i] , p [1] ) / 2 ;
		for ( ll j = 2 ; j < i ; j ++ )
		{
			if ( dis ( ans , p [j] ) < r || cmp ( dis ( ans , p [j] ) , r ) )
			{
				continue ;
			}
			ans.x = ( p [i].x + p [j].x ) / 2 ;
			ans.y = ( p [i].y + p [j].y ) / 2 ;
			r = dis ( p [i] , p [j] ) / 2 ;
			for ( ll k = 1 ; k < j ; k ++ )
			{
				if ( dis ( ans , p [k] ) < r || cmp ( dis ( ans , p [k] ) , r ) )
				{
					continue ;
				}
				ans = getans ( p [i] , p [j] , p [k] ) ;
				r = dis ( ans , p [i] ) ;
			}
		}
	}
	printf ( "%.2lf %.2lf " , ans.x , ans.y ) ;
	printf ( "%.2lf" , r ) ;
	
	return 0 ;
}
```

---

## 作者：Dream_Stars (赞：0)

## 方法一：随机增量法：

分析：用最小的圆覆盖住所有的点：随机增量法复杂度是 $\mathcal O(n)$；

**性质**：在既定的给定点条件下，如果引入一张新的半平面，只要此前的最优解顶点（即唯一确定最小包围圆的几个关键顶点）能够包含于其中，则不必对此最优解进行修改，亦即此亦为新点集的最优解；否则，新的最优解顶点必然位于这个新的半空间的边界上。定理可以通过反证法证明。于是，基于此性质，我们便可得到一个类似于线性规划算法的随机增量式算法。

定义 $D_i$ 为相对于 $p_i$ 的最小包围圆。此算法实现的关键在于对于 $p_i \notin D_{i-1}$ 时的处理。显然，如果 $ p_i \notin D_{i-1}$，则 $D_i= D_{i-1}$；否则，需要对 $D_i$ 另外更新。而且，$D_i$ 的组成必然包含了 $p_i$；因此，此种情况下的最小包围圆是过 $p_i$ 点且覆盖点集 $p_1$，$p_2$，$p_3 \cdots p_{i-1}$ 的最小包围圆。

则仿照上述处理的思路，$D_i=p_1$，$ p_i$，逐个判断点集 $p_2$，$p_3 \cdots \cdots p_{i-1}$，如果存在 $p_j \notin  D_i$，则 $D_i=p_j$，$p_i $。同时，再依次对点集 $ p_1 $，$p_2$，$p_3 \cdots \cdots p_{j-1}$ 判断是否满足 $p_k \notin D_i$，若有不满足，则 $D_i=p_k$，$p_j$，$p_i$。

由于，三点唯一地确定一个圆，故而，只需在此基础上判断其他的点是否位于此包围圆内，不停地更新 $p_k$。当最内层循环完成时，退出循环，转而更新 $p_j$；当次内层循环结束时，退出循环，更新 $p_i$。当 $i=n$ 时，表明对所有的顶点均已处理过 ，此时的 $D_n$ 即表示覆盖了给定 $n$ 个点的最小包围圆。

**总结**： 假设圆 $O$ 是前 $i-1$ 个点得最小覆盖圆，加入第 $i$ 个点，如果在圆内或边上则什么也不做。否，新得到的最小覆盖圆肯定经过第 $i$ 个点。然后以第 $i$ 个点为基础（半径为 $0$），重复以上过程依次加入第 $j$ 个点，若第 $j$ 个点在圆外，则最小覆盖圆必经过第 $j$ 个点。重复以上步骤三次。遍历完所有点之后，所得到的圆就是覆盖所有点得最小圆。证明可以考虑这么做：最小圆必定是可以通过不断放大半径，直到所有以任意点为圆心，半径为半径的圆存在交点，此时的半径就是最小圆。所以上述定理可以通过这个思想得到。这个做法复杂度是 $\mathcal O(n)$ 的，当加入圆的顺序随机时，因为三点定一圆，所以不在圆内概率是 $\frac{3}{i}$，求出期望可得是 $\mathcal O(n)$。

## 方法二：模拟退火法：

**分析**：对于每个枚举的点找到改点到所给点的最远点的距离，然后保证这个距离最小，即为所求圆的半径。

 AC 代码（方法 $1$）：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1000005;
const double eps = 1e-8;
struct Point {
    double x, y;
} a[N], O;
double R;
double sqr(double x) {return x * x;}
double dis(Point a, Point b) {return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y));}
void work(Point p1, Point p2, Point p3) {
    double a, b, c, d, e, f;
    a = p2.y - p1.y; b = p3.y - p1.y; c = p2.x - p1.x; d = p3.x - p1.x;
    f = p3.x * p3.x + p3.y * p3.y - p1.x * p1.x - p1.y * p1.y;
    e = p2.x * p2.x + p2.y * p2.y - p1.x * p1.x - p1.y * p1.y;
    O.x = (a * f - b * e) / (2 * a * d - 2 * b * c); O.y = (d * e - c * f) / (2 * a * d - 2 * b * c);
    R = dis(O, p1);
}
int main() {
    int n;
    scanf("%d", &n);
    for (int i=1; i<=n; ++i) scanf("%lf%lf", &a[i].x, &a[i].y);
    random_shuffle(a+1, a+n+1);
    O=a[1]; R=0;
    for (int i=2; i<=n; ++i)
        if (dis(a[i], O) > R + eps) {
            O = a[i]; R = 0;
            for (int j=1; j<i; ++j)
                if (dis(a[j], O) > R + eps) {
                    O.x = (a[i].x + a[j].x) / 2; O.y = (a[i].y + a[j].y) / 2; R = dis(a[j], O);
                    for (int k=1; k<j; ++k) if (dis(a[k], O) > R + eps) work(a[i], a[j], a[k]);
                }
        }
    printf("%.2lf %.2lf %.2lf\n", O.x, O.y, R);
    return 0;
}
```

---

## 作者：Eltaos_xingyu (赞：0)

### 题目描述

给定 $ n $ 个点 $(x_i,y_i)$，求半径最小的圆使该圆能覆盖所有的点。

所以这是一道最小覆盖圆的板子题，双倍经验：[**P1742**](https://www.luogu.com.cn/problem/P1742)

### 实现

使用随机增量法：

很容易我们能证明，若第 $ i $ 个点不在前 $ i-1 $ 个点的最小覆盖圆上，那么第 $ i $ 个点在前 $ i $ 个点的最小覆盖圆上。

这个时候，就要求前 $ i $ 个点的最小覆盖圆了。在初始化时，把圆心设为第 $ i $ 个点的坐标，半径设为 $ 0 $，强制使这个点在圆上。然后枚举就行了，如果当前这个点在当前这个圆外时就去求第 $ i $ 个点与该点在圆上时的最小覆盖圆，这个时候就要枚举除这两个点以外的第三个点（三点定圆）。枚举结束后就能求出前 $ i $ 个点的最小覆盖圆。

注意循环不用从 $ 1 $ 到 $ n $ 全部枚一遍，这样会造成重复枚举。

```cpp
for(int i=1;i<=n;i++)
    if(!is_po_in_circle(a[i],c)){
        c=get_circ(0,a[i]);
        for(int j=1;j<=i-1;j++)
            if(!is_po_in_circle(a[j],c)){
                c.r=dist(a[i],a[j])/2;
                c.o.x=(a[i].x+a[j].x)/2;
                c.o.y=(a[i].y+a[j].y)/2;
                for(int k=1;k<=j-1;k++)
                    if(!is_po_in_circle(a[k],c))
                        c=get_circle_from_po(a[i],a[j],a[k]);
            }
    }
```

现在最大的问题来了：两点加直径定圆很简单，但是三点定圆有点难度，所以开始推式子：

假设两点 $(x_1,y_1)$ 与 $(x_2,y_2)$，易得它们的中点是 $(\frac{x_1+x_2}{2},\frac{y_1+y_2}{2})$，经过它们的直线的斜率为 $\frac{y_1-y_2}{x_1-x_2}$。

因为三角形外接圆圆心（即外心）在在三条线段的中垂线上，故可知刚刚两个点的中垂线斜率为 $-\frac{x_1-x_2}{y_1-y_2}$。再代入刚刚的中点，把式子化为 $ Ax+By+C=0$ 的形式，可知中垂线解析式为：

$$ (x_1-x_2)x+(y_1-y_2)y+\frac{{y_2}^2-{y_1}^2+{x_2}^2-{x_1}^2}{2}=0 $$

其他两条直线是一样的，联立求交点即可，这样圆心和半径都求出来了。

### 复杂度证明

这个看似时间复杂度是 $ O(n^3) $ 的做法实际上时间复杂度为 $O(n)$，证明如下：

由于所有点中，每次最多有 $3$ 个点来确定最小覆盖圆，所以每次只有最多 $\frac{3}{n}$ 的概率选到参与确定最小覆盖圆的点，即每个循环向下调用的概率不超过 $\frac{3}{n}$。

首先最后一层循环的复杂度是 $O(j)$ 的，向上可以推得第二层的时间复杂度为：

$$O(i)+\sum_{j=1}^i \frac{3}{i}O(j)$$

因为要经过随机排序，通过上面的式子容易得到这层的时间复杂度是 $O(i)$，那第一层的时间复杂度也显而易见是 $O(n)$ 了。

AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct po{
    double x,y;
}; 
struct vec{
    double A,B,C;//Ax+By+C=0;
};
struct circ{
    po o;
    double r;
};
po a[2000001];
circ c;
vec get_vec_from_po(po p,po q){
    vec v;
    v.A=p.y-q.y;
    v.B=q.x-p.x;
    v.C=p.x*q.y-q.x*p.y;
    return v;
}
po get_po_from_vec(vec c,vec d){
    po pp;
    pp.x=((double)(-d.B*c.C+c.B*d.C)/(double)(-c.B*d.A+c.A*d.B));
    pp.y=((double)(-d.A*c.C+c.A*d.C)/(double)(c.B*d.A-c.A*d.B));
    return pp;
}
double dist(po a,po b){
    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}
bool is_po_in_circle(po test,circ d){
    return d.r>=sqrt((test.x-d.o.x)*(test.x-d.o.x)+(test.y-d.o.y)*(test.y-d.o.y));
}
circ get_circle_from_po(po A,po B,po C){
    vec buf1,buf2;
    buf1.A=2*(A.x-B.x),buf1.B=2*(A.y-B.y),buf1.C=B.x*B.x-A.x*A.x+B.y*B.y-A.y*A.y;
    buf2.A=2*(B.x-C.x),buf2.B=2*(B.y-C.y),buf2.C=C.x*C.x-B.x*B.x+C.y*C.y-B.y*B.y;
    circ temp;
    temp.o=get_po_from_vec(buf1,buf2);
    temp.r=dist(temp.o,A);
    return temp;
}
circ get_circ(double r,po o){
    circ temp_;
    temp_.r=r;
    temp_.o=o;
    return temp_;
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i].x>>a[i].y;
    random_shuffle(a+1, a+n+1);
    for(int i=1;i<=n;i++)
        if(!is_po_in_circle(a[i],c)){
            c=get_circ(0,a[i]);
            for(int j=1;j<=i-1;j++)
                if(!is_po_in_circle(a[j],c)){
                    c.r=dist(a[i],a[j])/2;
                    c.o.x=(a[i].x+a[j].x)/2;
                    c.o.y=(a[i].y+a[j].y)/2;
                    for(int k=1;k<=j-1;k++)
                        if(!is_po_in_circle(a[k],c))
                            c=get_circle_from_po(a[i],a[j],a[k]);
                }
        }
    cout<<fixed<<setprecision(2)<<c.o.x<<" "<<c.o.y<<" ";
    cout<<fixed<<setprecision(2)<<c.r<<endl;
    return 0;
}
```


---

## 作者：muller (赞：0)

给定nn个点，求一个最小的圆包围所有的点。

随机增量法

定理1：如果点pp不在集合SS的最小覆盖圆内，则pp一定在S\cup\{p\}S∪{p}的最小覆盖圆上。

根据这个定理，我们可以分三次确定前ii个点的最小覆盖圆。

1.令前i-1i−1个点的最小覆盖圆为CC

2.如果第ii个点在CC内，则前ii个点的最小覆盖圆也是CC

3.如果不在，那么第ii个点一定在前ii个点的最小覆盖圆上，接着确定前i-1i−1个点中还有哪两个在最小覆盖圆上。因此，设当前圆心为P_iP ，半径为0，做固定了第ii个点的前ii个点的最小圆覆盖。

4.固定了一个点：不停地在范围内找到第一个不在当前最小圆上的点Pj
，设当前圆心为(P_i+P_j)/2(P 

5.固定了两个点：不停地在范围内找到第一个不在当前最小圆上的点P_kP 
k
​	 ，设当前圆为P_i,P_j,P_kP 
i
​	 ,P 
j
​	 ,P 
k
​	 的外接圆。

所以就可以了！！！

代码：

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
const int N = 1000005;
const double eps = 1e-8;
struct Point {
	double x, y;
} a[N], O;
double R;
double sqr(double x) {return x * x;}
double dis(Point a, Point b) {return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y));}
void work(Point p1, Point p2, Point p3) {
	double a, b, c, d, e, f;
	a = p2.y - p1.y; b = p3.y - p1.y; c = p2.x - p1.x; d = p3.x - p1.x;
	f = p3.x * p3.x + p3.y * p3.y - p1.x * p1.x - p1.y * p1.y;
    e = p2.x * p2.x + p2.y * p2.y - p1.x * p1.x - p1.y * p1.y;
    O.x = (a * f - b * e) / (2 * a * d - 2 * b * c); O.y = (d * e - c * f) / (2 * a * d - 2 * b * c);
    R = dis(O, p1);
}
int main() {
	int n, i, j, k;
	scanf("%d", &n);
	for (i = 1; i <= n; ++i) scanf("%lf%lf", &a[i].x, &a[i].y);
	random_shuffle(a + 1, a + n + 1);
	O = a[1]; R = 0;
	for (i = 2; i <= n; ++i)
		if (dis(a[i], O) > R + eps) {
			O = a[i]; R = 0;
			for (j = 1; j < i; ++j)
				if (dis(a[j], O) > R + eps) {
					O.x = (a[i].x + a[j].x) / 2; O.y = (a[i].y + a[j].y) / 2; R = dis(a[j], O);
					for (k = 1; k < j; ++k) if (dis(a[k], O) > R + eps) work(a[i], a[j], a[k]);
				}
		}
	printf("%.2lf %.2lf %.2lf\n", O.x, O.y, R);
	return 0;
}

```


---


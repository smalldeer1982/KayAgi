# [AHOI2004] 数字迷阵

## 题目描述

小可可参观科学博物馆时，看到一件藏品，上面有密密麻麻的数字，如下所示：

```text

1   2   3   5   8    13   21   34   55   89   144  …
4   7   11  18  29   47   76   123  199  322  521  …
6   10  16  26  42   68   110  178  288  466  754  …
9   15  24  39  63   102  165  267  432  699  1131 …
12  20  32  52  84   136  220  356  576  932  1508 …
14  23  37  60  97   157  254  411  665  1076 1741 …
17  28  45  73  118  191  309  500  809  1309 2118 …
19  31  50  81  131  212  343  555  898  1453 2351 …
22  36  58  94  152  246  398  644  1042 1686 2728 …
25  41  66  107 173  280  453  733  1186 1919 3105 …
27  44  71  115 186  301  487  788  1275 2063 3338 …
…

```

仔细一分析，发现还挺有规律。

原来，**第一行是 Fibonacci 数列**。即，该行中除了第一个和第二个数分别为 1 和 2 之外，其他数都是其左侧相邻的两个数之和。

其后各行也类似于 Fibonacci 数列。只是第 $i$ 行的第一个数是前 $i-1$ 行中未出现的最小正整数，而其第二个数与该行第一个数以及所在行的编号 $i$ 相关，即

$$
A[i,2] = 2A[i,1] - (i - 1).
$$

如在第一行中未出现的最小正整数为 4，前三行中未出现的最小正整数为 9。故第二行以 4 和 7 开头，而第四行以 9 和 15 开头。

小可可高兴地把这个发现告诉了爷爷。爷爷问道：**你能否一口报出第 $i$ 行、第 $j$ 列的那个数对 $m$ 取模的结果是多少呢？**  
聪明的小可可通过心算就能知道答案。你是否能编写程序求解呢？

## 说明/提示

对于所有数据，$i,j\le10^9,2\le m\le10^4$。

## 样例 #1

### 输入

```
1 2 99```

### 输出

```
2```

## 样例 #2

### 输入

```
9 1 999```

### 输出

```
22```

# 题解

## 作者：IsoTls (赞：20)

很明显，这个题目只要确定了每一行的第一个数，该行所有的数就都确定了。
在数学上，每个正整数都可以写成若干个不重复的斐波那契数之和。为了证明这个结论，先证明引理一。

**引理一：**
如果已知某个斐波那契数为 $F_n$，下一个斐波那契数为 $F_{n+1}$，那么 $F_n < F_{n+1} < 2*F_n$ 

证明：

$F_n < F_n + F_{n-1} = F_{n+1} $，(1)

$F_{n+1} = F_n + F_{n-1} < F_n + F_n = 2*F_n$，(2)

结合（1）（2）得证。

**定理：每个正整数都可以写成若干个不重复的斐波那契数之和。**

可以用数学归纳法证明：

（1）当 $N=1$ 时，$1 = 1$ 显然成立。

（2）当 $N > 1$时，假设对于所有小于 $N$ 的正整数，都成立。

如果 $N$ 本身就是斐波那契数，那么显然 $N = N$ 成立。

如果 $N$ 不是斐波那契数，我们可以找到小于 $N$ 的最大斐波那契数 $K$。由归纳假设可知 $N - K$ 可以写成若干不重复的斐波那契数之和。由引理一可知，在 $K$ 和 $2*K$ 之间必然存在另外一个斐波那契数。既然 $K$ 是小于 $N$ 的最大斐波那契数，$N$ 和 $K$ 必然满足关系：$ N < 2*K$ ，因此 $ N-K < K$。而 $N = K + (N - K)$，所以 $N$ 也可以写成若干不重复的斐波那契数之和。

综合(1),(2)得证。

再加上零，这样我们就可以把每个整数写成斐波那契进制。具体的做法是将整数 $N$ 写成若干斐波那契数之和，把对应斐波那契数的位置填 $1$ ，其他位置填 $0$。如以下列表：

$0 = 0$

$1 = 1$

$2 = 10$

$3 = 100$

$4 = 3 + 1 = 101$

$5 = 1000$

$6 = 5 + 1 = 1001$

$7 = 5 + 2 = 1010$

$8 = 10000$

$9 = 8 + 1 = 10001$

$...$

如果限定没有相邻的 $1$ ，这种表示法是唯一的。

既然题目中给出的表和斐波那契数有关，如果我们把表中每个整数转换成斐波那契进制，说不定会有什么发现。转换之后如下

|行号|第一列|第二列|第三列|第四列|第五列|
| ---: | -----------: | -----------: | -----------: | -----------: |-----------: |
|1|        001|         10|        100|       1000|      10000|
|2|        101|       1010|      10100|     101000|    1010000|
|3|       1001|      10010|     100100|    1001000|   10010000|
|4|      10001|     100010|    1000100|   10001000|  100010000|
|5|      10101|     101010|    1010100|   10101000|  101010000|
|6|     100001|    1000010|   10000100|  100001000| 1000010000|
|7|     100101|    1001010|   10010100|  100101000| 1001010000|
|8|     101001|    1010010|   10100100|  101001000| 1010010000|
|9|    1000001|   10000010|  100000100| 1000001000|10000010000|
|10|    1000101|   10001010|  100010100| 1000101000|10001010000|
|11|    1001001|   10010010|  100100100| 1001001000|10010010000|

先观察每一行，可以发现，每行第一列的最末位都是 $1$。将第一列的数字左移一位后得到第二列，左移两位后得到第三列，以此类推。

再观察第一列，因为最末位是 $1$，而斐波那契进制要求不能有连续的1，所以第一列的数字形式为 $------01$，这为我们计算第一列的数提供了方便。又由于第一列的数是最小的之前从未出现过的数，所以把行号减一转换成斐波那契数进制即可。

比如要求第 $10$ 行的第一个数，可以将 $9$ 转换为斐波那契进制为：$10001$，后面再补一个 $01$ 即为：$1000101$

这样就求得了第 $i$ 行的第一个数，然后再通过左移 $j-1$ 次，可以得到第 $i$ 行，第 $j$ 列的数。

代码如下：
```cpp
#include <stdio.h>
#define MAX 1000000000
#define SIZE 256

int bits[SIZE];
int fib[SIZE] = {1, 1, 2};
int fib_len;
int shifted[SIZE];

struct Matrix {
    int m[2][2];
    Matrix() {
        m[0][0] = 1; m[0][1] = 1;
        m[1][0] = 1; m[1][1] = 0;
    }
};

int find_lower(int value) {
    int low = 0;
    int high = fib_len - 1;
    int mid;
    while (low <= high) {
        mid = (low + high) / 2;
        if (fib[mid] <= value) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return low - 1;
}

int fill_bits(int value) {
    bits[0] = 1;
    bits[1] = 0;
    value--;
    int len = find_lower(value);
    int k = len;
    while (k > 0 && value > 0) {
        if (value >= fib[k]) {
            bits[k+1] = 1; 
            value -= fib[k];
        }
        k--;
    }
    return len + 2;
}

Matrix matrix_mul(const Matrix* a, const Matrix* b, int M) {
    Matrix c;
    c.m[0][0] = (a->m[0][0] * b->m[0][0] + a->m[0][1] * b->m[1][0]) % M;
    c.m[0][1] = (a->m[0][0] * b->m[0][1] + a->m[0][1] * b->m[1][1]) % M;
    c.m[1][0] = (a->m[1][0] * b->m[0][0] + a->m[1][1] * b->m[1][0]) % M;
    c.m[1][1] = (a->m[1][0] * b->m[0][1] + a->m[1][1] * b->m[1][1]) % M;
    return c;
}

Matrix matrix_pow(const Matrix* matrix, int n, int M) {
    if (n == 1) {
        return {};
    }
    Matrix t = matrix_pow(matrix, n/2, M);
    t = matrix_mul(&t, &t, M);
    if (n & 1) {
        return matrix_mul(&t, matrix, M);
    }
    return t;
}

void get_shifted_fib(int j, int k, int M) {
    if (j == 0) {
        shifted[0] = 1 % M;
        shifted[1] = 2 % M;
    } else {
        Matrix c;
        c = matrix_pow(&c, j, M);
        shifted[0] = (c.m[1][0] * 2 + c.m[1][1]) % M;
        shifted[1] = (c.m[0][0] * 2 + c.m[0][1]) % M;
    }
    for (int i = 2; i <= k; i++ ) {
        shifted[i] = (shifted[i-1] + shifted[i-2]) % M;
    }
}

int main() {
    int i, j, m, k;
    for (k = 2; fib[k-1] < MAX; k++) {
        fib[k] = fib[k-1] + fib[k-2];
    }
    fib_len = k - 1;

    scanf("%d%d%d", &i, &j, &m);
    k = fill_bits(i); // 计算第 i 行，第一列的数
    get_shifted_fib(j-1, k, m);  // 左移 j-1 位
    int ans = 0;
    for (i = 0; i <= k; i++) {
        if (bits[i]) { // 按位计算
            ans = (ans + shifted[i]) % m; 
        }
    }
    printf("%d\n", ans);
    return 0;
}
```


---

## 作者：JohnJoeZhu (赞：6)

[题面传送门](https://www.luogu.com.cn/problem/P2544)

### 1.前置要求
- 矩阵基础&乘法&快速幂
- [P1962 斐波那契数列
](https://www.luogu.com.cn/problem/P1962)

不会请右转，本题需要其熟悉运用
### 2.题面分析
我们可以分析得到，第n行的数都与本行第1个数相关

也就是第一个数可以推导出后面的所有数

所以我们的第一步是求第1个数

然后我们就可以来思考怎么求第m个数了
#### 2.1求第一个数
我们来把每行第一个数都拿起来看

	1 4 6 9 12 14 17 19 …

如果找不到关系，就两项相减 ~~（某神仙定理）~~

然后发现差值是2或3

那么又有什么特征呢？

~~因为题面涉及到斐波那契，所以就是斐波那契了~~

~~一通乱搞~~

整理之后差值可以排列为

	3 
    2 3 
    3  2 3 
    2 3  3 2 3 
    3 2 3  2 3 3 2 3
发现了吗？这不就是妥妥的斐波那契变形？

描述就是:每一次往后推的项数满足斐波那契数列，且就是前面两次的那些项连接起来
    
然后就是一个结论 ~~（蒟蒻不会求qwq）~~

对于上面的式子$f[i]=trunc(i\times t+i-1)$，其中$t=(1+\sqrt 5)/2$，$\text{trunc}$ 表示取整

但是在考场上有可能写出来吗？

蒟蒻不知道，可是我们可以从另外一个角度看这个问题

显然，我们可以发现一个数可以拆分成若干个斐波那契数之和，又因为有以上条件，可以得出：

对于每一个斐波那契数$f[i]$，3的个数为$f[i-1]$，2的个数为$f[i-2]$

我们可以这样做：

把目标拆分为若干斐波那契数，再根据上面的结论进行统计即可

因为斐波那契的增长速度很快（记得30个以内就超int了），所以复杂度和精度没有问题的

#### 2.2求第m个数

根据题面的公式，还有上文提出的方式，再根据斐波那契数列递推公式就可以求了

等等，$\text{O}(10^9)$怎么过得去呢

这就要运用到我们的前置题目了

- [因为这里默认各位大佬都会，所以就不展开，如果不会可能会影响下文阅读](https://www.luogu.com.cn/problem/P1962)

考虑矩阵快速幂优化（不懂请右转）

因为我们的目标行与普通斐波那契数列不同的就是前两项不同

而根据矩阵快速幂的优化方式，我们可以先把转移的辅助矩阵处理起来，然后再把前两项的值取相应的值即可

在本题中的公式为：

$$ \left[\begin{array}{ccc}F_{n-1} & F_{n-2}\end{array}\right] \times \left[\begin{array}{ccc} 1 & 1 \\ 1 & 0 \end{array}\right]^{m-1} = \left[ \begin{array}{ccc}F_n & F_{n-1} \end{array}\right]$$

注：[参考文章](https://anguei.blog.luogu.org/solution-p1962)

#### 2.3复杂度分析
（蒟蒻简单来分析一下）

显然空间复杂度是比较小的，我们甚至不需要一个大数组

那么时间复杂度呢？

求第1个数：$O(1)$

快速幂：$O(log\space m)$

查询:$O(1)$

故时间复杂度约为$O(log\space m)$
### 3.代码福利时间
~~详细注释，方便食用~~

注意精度的细节处理
```cpp
#include<cmath>
#include<cstdio>
#define ll long long
int n,m,mod,k1,k2;
struct MA{
	int a[3][3];
}ans,anss;
MA operator *(const MA x,const MA y)//重载运算符，方便快捷，5星好评（写成函数也随便你咯）
{
	MA z;
	for(int i=1;i<3;i++)
		for(int j=1;j<3;j++)
			z.a[i][j]=0;
	for(int i=1;i<3;i++)
		for(int j=1;j<3;j++)
			for(int k=1;k<3;k++)
				z.a[i][j]=(z.a[i][j]+(ll)x.a[i][k]*y.a[k][j])%mod;
	return z;
}
int main()
{
	scanf("%d%d%d",&n,&m,&mod);
	k1=((ll)(n*(1+sqrt(5))/2+n-1))%mod;//这里是公式法
    	/*以下是考场常规写法
   	fib[1] = fib[2] = 1;
    	int i,a=0,b=0;
     	for (i=3;fib[i-1]<=n;i++) fib[i]=fib[i-1]+fib[i-2];
     	while(i--)
            if(fib[i]<=n) n-=fib[i],a=(a+3*fib[i-1])%mod,b=(b+2*fib[i-2])%mod;
     	k1=(a+b+1)%mod;
	*/
	k2=((2*k1-n+1)%mod+mod)%mod;//套公式
	if(m<=2) //特殊处理
	{
		printf("%d",m==1?k1:k2);
		return 0;
	 } 
	m--;//这里是因为快速幂实际只需要m-1次幂（感性理解）
	ans.a[1][1]=ans.a[2][2]=1;//单位矩阵相当于赋值1
	anss.a[1][1]=anss.a[1][2]=anss.a[2][1]=1;//斐波那契数列的常规转移矩阵
	while(m)//快速幂模板
	{
		if(m&1) ans=ans*anss;
		m>>=1;
		anss=anss*anss;
	}
	printf("%lld",((ll)k1*ans.a[2][2]+(ll)k2*ans.a[2][1])%mod);//重新赋初值，得到答案
	return 0;
}
```







---

## 作者：Cx114514 (赞：1)

### 题目链接：[[AHOI2004] 数字迷阵](https://www.luogu.com.cn/problem/P2544)

如果我们知道了某一行的第一个数字，那么这一行其它的数字均可以通过矩阵快速幂加速递推求出。

寻找第一列的规律，发现它们的差值序列是：$3,2,3,3,2,3,2,3\cdots$。

把前 $1$、$2$、$3$、$5$、$8$ 项拿出来：

$3$

$3,2$

$3,2,3$

$3,2,3,3,2$

$3,2,3,3,2,3,2,3$

可以发现，第 $i$ 行相当于 第 $i-1$ 和 $i-2$ 行拼起来。

令 $pre_i$ 表示上述列表中第 $i$ 行的和。

易得：$pre_i=pre_{i-1}+pre_{i-2}$。

$fib_{44}\approx  10^9$

因此我们只需要记录斐波那契数列的前 $44$ 项。

因为 $x-1$ 是 $x$ 的前缀，所以 $1\sim x-1$ 均为 $x$ 的前缀。

算法流程如下：

1. 令要求的行数为 $k$，将 $k$ 减 $1$，初始 $sum=1$。
2. 找到最大的 $fib_i\le k$，将 $k$ 减 $fib_i$，$sum$ 加 $pre_i$。
3. 重复步骤 $2$ 直至 $k=0$。

这样得到的 $sum$ 即为所求行的第一列的数，剩下的矩阵快速幂就可以了。

代码：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int n, m, mod, sum, f[55], g[55];

struct Matrix
{
	int M[5][5];
	Matrix friend operator * (const Matrix &A, const Matrix &B)
	{
		Matrix Ans;
		memset(Ans.M, 0, sizeof(Ans.M));
		for (int i = 1; i <= 2; i++)
			for (int j = 1; j <= 2; j++)
				for (int k = 1; k <= 2; k++)
					Ans.M[i][j] = (Ans.M[i][j] + A.M[i][k] * B.M[k][j]) % mod;
		return Ans;
	}
} A, B;

Matrix Qpow(Matrix t, int p)
{
	Matrix Ans;
	memset(Ans.M, 0, sizeof(Ans.M));
	Ans.M[1][1] = 1;
	Ans.M[2][2] = 1;
	while (p)
	{
		if (p & 1) Ans = Ans * t;
		t = t * t;
		p /= 2;
	}
	return Ans;
}

signed main()
{
	cin >> n >> m >> mod;
	f[1] = 1;
	f[2] = 2;
	g[1] = 3;
	g[2] = 5;
	for (int i = 3; i <= 50; i++)
	{
		f[i] = f[i - 1] + f[i - 2];
		g[i] = (g[i - 1] + g[i - 2]) % mod;
	}
	n--;
	int N = n;
	sum = 1;
	while (N)
	{
		int pos = upper_bound(f + 1, f + 50, N) - f - 1;
		N -= f[pos];
		sum = (sum + g[pos]) % mod;
	}
	if (m == 1) 
	{
		cout << sum << endl;
		exit(0);
	}
	memset(A.M, 0, sizeof(A.M));
	memset(B.M, 0, sizeof(B.M));
	A.M[1][1] = A.M[1][2] = A.M[2][1] = 1;
	B.M[1][1] = sum * 2 - n;
	B.M[2][1] = sum;
	B = Qpow(A, m - 2) * B;
	cout << B.M[1][1] % mod << endl;
	return 0;
}
```

---

## 作者：_ayaka_ (赞：1)

教练讲了一种题解似乎没出现过的好理解的方法，遂写之。

### 思路

上来就发现，其实 $j$ 的处理是比较简单的，就是标准的斐波那契数列的矩阵快速幂。那么问题就在 $i$ 上了。

我们来观察下 $i$ 的每两项之间的差：

$$3,2,3,3,2,3,2,3,3,2,3,\dots$$

看似似乎只能发现两项之间的差只为 $2$ 或 $3$。但将每个斐波那契数大小的前缀拿出来，仔细一看，会发现：

$$3$$

$$3,2$$

$$3,2 \ \ 3$$

$$3,2,3 \ \ 3,2$$

$$3,2,3,3,2 \ \ 3,2,3$$

$$\dots$$

这很明显就是斐波那契数列。假设 $2$ 有 $r_i$ 个，假设 $3$ 有 $b_i$ 个，那么第 $r_i+b_i-1$ 行第一列这一数的权值就是 $2\times r_i+3\times b_i+1$。但像这样推理，只能求出在斐波那契上的行的数字。那假如我们求的是非斐波那契数呢？

假设我们所求的数为 $x$，那 $1$ 到 $x$ 这一段必定是每个比 $x$ 更大的斐波那契上面某一项的前缀。我们设这个项为 $f_i$。如图：

![](https://img.z4请更换图床a.net/images/2024/11/29/1a75a6d0afc548cc9.png)

不难看出，若 $f_{i-1} \le x$ 且 $f_i > x$，$f_{i-1}$ 是比 $x$ 小的最大的斐波那契数。

那由此可以推断，假如把 $x$ 上与 $f_{i-1}$ 重合的部分删掉，那既然 $x$ 的剩余部分就是 $f_{i-2}$ 的前缀，此部分又可以算作是一个新的前缀。原因其实也很显然，毕竟 $f_{i-2}$ 也就是 $f_{i-1}$ 的前缀嘛。

那我们就可以将 $f_{i-1}$ 的 $r_i$ 和 $b_i$ 保存下来，再找一个新的 $f_i$，直到 $x$ 本身也是斐波那契数即可。

那像这样就可以做到求出第 $i$ 行第一个数的权值。设小于等于 $i$ 的斐波那契数有 $c$ 个，则时间复杂度为 $O(c)$。在 $i=10^9$ 时，这个数为 $44$。

然后，我们只要用标准的矩阵快速幂求斐波那契就可以得到答案了。总时间复杂度 $O(c+\log m)$。

### 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int i, ii, j, m, f[105], cnt, r[105], b[105], rr, bb, num;
struct matrix {
	int a[4][4];
	matrix() {
		memset(a, 0, sizeof a);
	}
	matrix operator*(const matrix &y) const {
		matrix z;
		for (int i = 1; i <= 2; ++i)
			for (int j = 1; j <= 2; ++j)
				for (int k = 1; k <= 2; ++k)
					z.a[i][j] = (z.a[i][j] % m + a[i][k] % m * y.a[k][j] % m) % m;
		return z;
	}
};//矩阵模板 
signed main() {
	cin >> i >> j >> m;
	f[0] = 1, f[1] = 1;
	r[0] = 1, b[1] = 1;
	for (int k = 2;; k++) {
		f[k] = f[k - 1] + f[k - 2];
		r[k] = r[k - 1] + r[k - 2];
		b[k] = b[k - 1] + b[k - 2];
		if (f[k] >= i) {
			cnt = k;
			break;
		}
	}//求解 i 以内的斐波那契 
	ii = i;
	i--;//注意直接求求出的是第 i+1 行，因此减一 
	while (i) {
		int k = upper_bound(f + 1, f + cnt + 1, i) - f - 1;
		rr += r[k] % m;
		bb += b[k] % m;
		i -= f[k];
	}
	num = rr * 2 % m + bb * 3 % m + 1;
	f[1] = num % m, f[2] = (2 * (num % m) % m - (ii - 1) % m) % m;
	//后续就是模板了 
	if (j <= 2) {
		cout << f[j] % m;
		return 0;
	}
	matrix a, ans;
	a.a[1][1] = 1;
	a.a[1][2] = 1;
	a.a[2][1] = 1;
	ans.a[1][1] = f[2] % m;
	ans.a[1][2] = f[1] % m;
	j -= 2;
	while (j) {
		if (j & 1) ans = ans * a;
		a = a * a;
		j >>= 1;
	}
	cout << (ans.a[1][1] + m) % m;
	return 989571;
}

```

---

## 作者：zyg20010121 (赞：1)

首先我们可以判断出每行都是变形的斐波那契数列,又因为a[i][2]=2a[i][1]-(i-1),所以本质上a[i][j]只与第i行的第一个元素有关,那么关键求a[i][1]

我们发现第一列增加的值为2或3,其实我们可以发现第一次(第二行)+3,后面两次(3,4行)分别+2-3,再后面的3次是前两次的序列和,即3-2-3......

每一次往后推的项数满足斐波那契数列,且就是前面两次的那些项连起来.即第一列通项为f[i]=trunc(i\*t+t-1),其中t=(1+sqrt(5))/2

所以我们可以用O(1)的时间求a[i][1],但是需要O(N)的时间求a[i][j],那么我们可以令f[0]=1,f[1]=1,a=1,b=1,则

m=(1+sqrt(5))/2,k=(1-sqrt(5))/2,f[n]=((k^n)\*(1-m)-(m^n)\*(1-k))/(k-m)

**即f[n]=(m^(n+1)-k^(n+1))/sqrt(5);**

其实就是斐波那契数列通项公式

其他行就是初值不一样而已,代码不想写注释,自己都觉得奇丑无比......

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;

typedef long long LL;
int n,m,p;
int x[101][3][3],y[3][3],z[3][3],a[101],k1,k2,ans;
int i,j,k,l;

int main() {
    scanf("%d%d%d",&n,&m,&p);
    m--;
    x[0][1][2]=x[0][2][1]=x[0][2][2]=1;
    a[0]=1;
    for(i=1;a[i-1]*2<=m;i++) {
        a[i]=a[i-1]*2;
        for(j=1;j<=2;j++)
            for(k=1;k<=2;k++) 
                for(l=1;l<=2;l++)
                    x[i][j][k]=(x[i][j][k]+(LL)x[i-1][j][l]*x[i-1][l][k])%p;
    }
    y[1][1]=y[2][2]=1;
    for(i--;i>=0;i--) {
        if(a[i]<=m) {
            m-=a[i];
            for(j=1;j<=2;j++) 
                for(k=1;k<=2;k++)
                    for(l=1;l<=2;l++) 
                        z[j][k]=(z[j][k]+(LL)x[i][j][l]*y[l][k])%p;
            for(j=1;j<=2;j++) 
                for(k=1;k<=2;k++) {
                    y[j][k]=z[j][k];
                    z[j][k]=0;
                }
        }
    }
    k1=((LL)(n*(1+sqrt(5))/2+n-1))%p;
    k2=((2*k1-n+1)%p+p)%p;
    ans=((LL)k1*y[1][1]+(LL)k2*y[1][2])%p;
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：aakennes (赞：0)

**关键思路：求出第$i$行第一列数后直接矩阵快速幂搞它，无视第一列数的话其实就是斐波那契数列的求法**

问题来了，第一列数怎么求呢？

* ### 第一步：观察
   
   先打个表：
   $1, 4, 6, 9, 12, 14, 17, 19, 22, 25, 27, 30, 33, 35, 38, 40, 43, 46, 48, 51, 53, 56, 59, 61, 64, 67, 69, 72, 74, 77, 80, 82, 85, 88, 90, 93$
   貌似没啥规律，再康康差值：
   
   $3$ $2$
  
   $3$ $3$ $2$
   
   $3$ $2$ $3$ $3$ $2$
	
    $3$ $3$ $2$ $3$ $2$ $3$ $3$ $2$ 
    
    貌似有个规律诶，第$i$行的差值等于第$i-1$行的差值与$i-2$行合并
    
    然后。。。
   
* ### 第二步：找规律

	怎么找规律呢？在写了一两个小时和询问老师后，仍然没得出柿子来
    
	关键来了：~~打开OEIS~~
    
    ![](https://cdn.luogu.com.cn/upload/image_hosting/d2ilimvl.png)
    
    再往下看看
    
    ![](https://cdn.luogu.com.cn/upload/image_hosting/2uy9lth1.png)
    
    ？？？什么证明
    
    这证明，咳咳，~~看来直接用就完事了~~
    
    (插一嘴，大部分题解都是直接给出一个类似杨辉三角的规律然后直接摆柿子的，并没有给证明，然而这柿子可能扔给数学系大学生才能证。但是我看题解里有用二进制做得，推测出题人本意是让我们用二进制推而非找这样的柿子)
    
# 代码：

（想了想，还是摆上为好）

```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll n,m,mol,now1,now2;
struct Matrix{
    ll a[3][3];
    Matrix(){memset(a,0,sizeof(a));}
    Matrix operator *(const Matrix &b)const{
        Matrix C;
        for(int i=1;i<=2;i++){
            for(int j=1;j<=2;j++){
                for(int k=1;k<=2;k++){
                    C.a[i][j]=(C.a[i][j]+a[i][k]*b.a[k][j]%mol)%mol;
                }
            }
        }
        return C;
    }
}ans,base;
void Init(){
    ans.a[1][1]=now2;ans.a[1][2]=now1;
    base.a[1][1]=base.a[1][2]=base.a[2][1]=1;
}
void qpow(ll x){
    while(x){
        if(x&1)ans=ans*base;
        base=base*base;
        x>>=1;
    }
}
int main(){
	cin>>n>>m>>mol;
	now1=(ll)(n*(1+sqrt(5))/2+n-1)%mol;
    now2=((2*now1-n+1)%mol+mol)%mol;
    Init();
    if(m==1)cout<<now1;//注意一般矩阵快速幂都要处理前几个数
    else if(m==2)cout<<now2;
    else{
        qpow(m-2);
        cout<<ans.a[1][1];
        return 0;
    }
}
```


---

## 作者：Lazy_crush (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P2544)

### **P2544 [AHOI2004] 数字迷阵=矩阵乘法&快速幂+斐波那契数列基础知识**

 ### １.斐波那契数列

分析题意，已知：
- 每一行都是**斐波那契数列**。
- $A[i,2]\gets2A[1,i]-(i-1)$。


需要求的是：
-   第 $i$ 行第 $j$ 列的数。
  
容易得出：
- 只需要求出第 $i$ 行第一个数，然后根据**斐波那契数列**的递推公式，就可以求出第 $i$ 行第 $j$ 列的数。

如何求出第 $i$ 行第一个数：
- 将每一行第一个数两两相减，整理之后将差值排列：


```cpp
3 
2 3  
3 2 3
2 3 3 2 3
```
- 发现是**斐波那契数列**变形，因而推出公式：
  
  $t\gets(1+\sqrt{5})/2，$ 

  $f1\gets(n\times t+n-1)，$ 

  $f2\gets(2\times f1-n+1)$ 

**代码：**
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const double t=1.0*(1+sqrt(5))/2; 
int n,m,Mod,f,f1,f2;
int main(){
	cin>>n>>m>>Mod;
	f1=((ll)(n*t+n-1))%Mod;
	f2=((2*f1-n+1)%Mod+Mod)%Mod;
	if(m<=2){
		if(m==1) cout<<f1;
		if(m==2) cout<<f2;
		return 0;
	}
	for(int i=3;i<=m;i++){
		f=f1+f2,f1=f2,f2=f;//斐波那契递推公式
		while(f>Mod) f-=Mod;
		while(f1>Mod) f1-=Mod;
		while(f2>Mod) f2-=Mod;
	}
	while(f>Mod) f-=Mod;
	cout<<(ll)(f);
	return 0;
}
```
[记录详情](https://www.luogu.com.cn/record/174502858)

几经思索发现发现正解是用**快速幂**优化。

### ２.快速幂

- **快速幂**可以以 $O(\log{n})$ 的时间复杂度计算乘方。

- 主要思想就是把 $a^b$ 中的次数 $b$ 拆解成二进制数。

**快速幂**代码：

```cpp
int qpow(int x,int y){
	int res=1;
	for(;y;y>>=1,x=1ll*x*x%Mod)
		if(y&1) res=res*x;
	return res;
}
```
### ３.矩阵乘法
- **矩阵乘法**中第一个矩阵的列要等于第二个矩阵的行。

- 两个大小分别为 $m\times n$ 和 $n\times p$ 的矩阵 , 相乘的结果为一个大小为 $m\times p$ 的矩阵。

- 通常将结果矩阵记作 $C$，有：

   $C_i,_j=\sum_{k=1}^na_i,_k\times b_k,_j(1\le i\le m，1\le j\le p)$。

- 单位矩阵，除了对角线为 $1$，其他位置为 $0$ 的矩阵。

  任何矩阵乘上它的结果都是原矩阵。

**矩阵乘法**代码：
```cpp
struct Matrix{
	int a[N][N];
	void clear(){memset(a,0,sizeof a);}
	void init(){for(int i=1;i<=n;i++) a[i][i]=1;}
	//单位矩阵 
};
Matrix operator*(const Matrix &a,const Matrix &b){
	Matrix c;c.clear();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			for(int k=1;k<=n;k++)
				c.a[i][j]=(c.a[i][j]+(a.a[i][k]*b.a[k][j])%mod)%mod;
	return c;
} 
inline Matrix qpow(Matrix x,int y){
	Matrix res;res.clear(),res.init();
	for(;y;y>>=1,x=x*x)
		if(y&1) res=res*x;
	return res; 
}
```


[模板题：矩阵加速（数列）建议搭配食用。](https://www.luogu.com.cn/paste/aieqgcjo)

**代码：**

```cpp
#include<bits/stdc++.h>
typedef long long ll;
using namespace std;
const int N=3;
const double t=1.0*(1+sqrt(5))/2;
int Mod;
struct Matrix{
	int a[N][N];
	void clear(){memset(a,0,sizeof a);}
	void init(){for(int i=1;i<N;i++) a[i][i]=1;}
}x,res;
Matrix operator*(const Matrix &a,const Matrix &b){
	Matrix c;c.clear();
	for(int i=1;i<N;i++)
		for(int j=1;j<N;j++)
			for(int k=1;k<N;k++)
				c.a[i][j]=(c.a[i][j]+(ll)(a.a[i][k]*b.a[k][j])%Mod)%Mod;
	return c;
} 
inline void qpow(Matrix x,int y){
	res.clear(),res.init();
	for(;y;y>>=1,x=x*x)
		if(y&1) res=res*x;
}
int n,m,f1,f2;
int main(){
	cin>>n>>m>>Mod;
	f1=((ll)(n*t+n-1))%Mod;
	f2=((2*f1-n+1)%Mod+Mod)%Mod;
	if(m<=2){
		if(m==1) cout<<f1;
		if(m==2) cout<<f2;
		return 0;
	}
	x.a[1][1]=1,x.a[1][2]=1,x.a[2][1]=1;//常规转移矩阵 
	qpow(x,m-1);//快速幂 
	printf("%lld",((ll)f1*res.a[2][2]+(ll)f2*res.a[2][1])%Mod);
	return 0;
}
```

---


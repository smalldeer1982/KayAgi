# [ZJOI2005] 梦幻折纸

## 题目背景

你是一个喜欢幻想的小女孩，特别喜欢追求一些完美的理想的东西——“理想的圆”，“理想的均等”，“理想的材料”，“理想的最优解”……

最近，偶然的机会，你迷恋上了折纸。你把自己的作业本扯下来折成了各种各样的小把戏——小花，小草，小鸟，小兔子，小老鼠……一张又一张，直到作业本的封面都被你折成了纸鹤。但是你还是觉得不过瘾。

终于……你克制不住自己心中压抑的想法，从可怜的同桌那儿拿了一张用过的草稿纸。正当你打算用同样的方法折掉它的时候，你十分惊奇的发现：这不是一张普通的草稿纸，而是一张非常特殊的草稿纸：它薄得厚度可以忽略不计，柔韧得怎么撕也撕不破，而且无论怎么折都行。

你如获至宝，这不就是你梦寐以求的“理想的材料”吗？真所谓“踏破铁鞋无觅处，得来全不费功夫。梦里寻它千百度，蓦然回首，它却在灯火阑珊处 ！”你决心要把它折成一个有难度一点的东西，才对得住一张这么好的纸。

## 题目描述

你仔细观察了一下纸的特点：

纸的大小为 $n \times m$，上面等距离的印好了格线，$n-1$ 条横线和 $m-1$ 条竖线（线的宽度忽略不计）。这些格线将纸分成了 $n \times m$ 个大小完全相同的正方形小格。你的同桌已经在每一块小格 $(i,j)$ 上写下了一个互不相同的正整数 $P_{i,j}$，$1 \le P_{i,j} \le n \times m$。

“他干嘛在纸上写下这么些数字呢？”你看着这些数字，疑惑不解。

这时，你的同桌突然出现了，他发现你正拿着他的纸，看着上面的数字发呆。于是傻乎乎地对你说：

“我刚刚也想学你折纸，可是我很笨，只折出一个 $1 \times 1$ 的正方形，也就是一个 $n \times m$ 层纸的纸垛，每一层恰好是一个小格，所有的格线都恰好在正方形的边界上。”

“哦，折得不错，挺好的。”你口里说不错，心里却暗笑：没见过你这么笨的。居然把这么好的纸折成一个如此简单的正方形，简直是暴殄天物，罪过啊，罪过！

“是吗？你也觉得不错啊？我刚刚就在想，如果给这些小格编上号，最上面一层编为 $1$，从上往下数的第 $i$ 层编为 $i$，那么能不能从这些编号复原出刚刚我折的那个图形呢？于是我就在这些格子上写下了它们的编号”

“这……”你一时语塞，确切的说，惊讶得说不出话来，原来一向傻乎乎的同桌脑子里也有这么深奥的想法。

“这样吧，如果你能根据我把我刚刚折的正方形折出来，那我就把这张纸送给你！” 同桌接着说，“不管你折法是否和我一样，只要折出来也是个 $1 \times 1$ 的正方形，从上往下数的第 $i$ 层的编号恰好也是 $i$，并且纸不能破，就算你折对了。”

“好啊，不过我先要检查检查你有没有骗我，要是你故意骗我或者自己粗心在编号的时候写错了数字而害得我折不出来，我可饶不了你！”

## 说明/提示

- $1 \le t \le 10$

- $1 \le n, m \le 100$

## 样例 #1

### 输入

```
4

1 7
3 1 7 6 5 4 2

2 2
1 2
3 4

2 3
2 1 6
3 4 5

4 4
11 12 15 14
10 9 16 13
5 8 1 2
6 7 4 3
```

### 输出

```
AllRight
Cheat
AllRight
AllRight
```

# 题解

## 作者：BJpers2 (赞：7)

先考虑最后折成的小正方形，它有n* m层，假设我们把它立起来，并从正面看这个小正方形，它的左右两侧的前后连接即为每一行上一格格的连接，上下两侧的前后连接即为每一列上一格格的连接。

那么只需分别再现出行和列究竟是哪些格子被连起来，再看是否有交点（即重合）即可。

先考虑行

看样例第三组：
```
2 1 6
3 4 5
```
我们发现，显然，在矩阵中相邻的一定被连在一起，问题在于最终它们究竟是左侧相连，还是在右侧相连（在之前说的小正方形中）。

不妨设第1行的第1个与第2个是最后在左边相连的。

那么不管你怎么折，第2行的第1个与第2个也总是最后在左边相连的。

类似地，所有行的第1个与第2个都是最后在左边相连。

又发现，不管你怎么折，第1行的第2个与第3个总是最后在右边相连的。于是同上理所有行的2，3号之间最后全在右边相连。

这样可以推出，任意行的i,i+1号最后在i&1这一侧相连（左1右0）

那么，我们就能把所有的链接情况用一个表来记录，然后看会不会有交叉。如样例：
```
1 1 3 3    //左边
1 2 3 4 5 6
2     4 4 2//右边
```
数字相同表示连在一起。列与行是一样的。
只上部分代码：(即行的处理)
```cpp
```cpp
        t=co=0,yes=1;
		FOR(j,1,m-1)FOR(i,1,n) s[j&1][a[i][j]]=s[j&1][a[i][j+1]]=++co;
		FOR(k,0,1){
			FOR(p,1,pro)if(s[k][p]){
		        st[++t]=s[k][p];
		        if(t>1) if(st[t]==st[t-1]) t-=2;
		    }if(t) yes=0;
		}
```
```

---

## 作者：functionendless (赞：5)

[更好(?)的阅读体验](https://www.cnblogs.com/functionendless/p/10622780.html)
## 题意：

给一个 $n*m$ 的网格图,每个网格上有 $[1,n*m]$ 的数字,且每个都出现且恰好出现一次.
显然进行若干次折叠直到剩下一个 $1*1$ 的小网格时,它在纵向上有 $n*m$ 层.
那么能否安排一种折叠方案,使得这 $n*m$ 层从上往下的标号恰好为 $1$ 到 $n*m$.

## 题解：

显然每个纵向和横向的格线都会被折到.我们观察剩下的的那个小方格,可以发现每层都有向左或右,上或下的连接,而且上下的连接和左右的连接是无关的.
然而还是没有什么卵用...
这时我们考虑什么情况下会不存在合法的方案,先举个例子:`1 3 4 2`.
我们想象面前有个 $1*4$ 的纸条,先把 `3` 折到 `1` 的下面,再把 `4` 折到 `3` 的下面,这时我们发现 `2` 居然折不进去了.
这是因为 $4,2$ 和 $1,3$ 的连接是同向的,那么这样就不能交叉进去了.
那么我们发现折痕的方向是相邻的格线两两相反的(折一折就知道了)
根据上面的结论,相同的方向的折痕不能存在相交.这样我们就会只有一条的情况了.

对于一般情况,我们发现当一条格线被决策后,它所在的所有格子都会被强制决策.
由于行和列是互不影响的,那么这个就很好扩展了.

## 代码：

```
#define GG {puts("Cheat"); continue;}
const int N=110;
int n,m;
int G[N][N];
struct SEG {
  int L,R;
  inline void Config() {
    if(L>R) swap(L,R);
  }
  inline void Print() {
    printf("%d %d\n",L,R);
  }
  bool operator < (const SEG &a)const {
    return L<a.L;
  }
};
vector<SEG> seg[2];
inline bool Judge() {
  //printf("Start\n");
  for(int t=0;t<2;t++) {
    sort(seg[t].begin(),seg[t].end());
    //for(int i=0;i<(int)seg[t].size();i++) seg[t][i].Print();
    vector<pii> ref;
    for(int i=0;i<(int)seg[t].size();i++) {
      ref.pb(mp(seg[t][i].L,i+1));
      ref.pb(mp(seg[t][i].R,-i-1));
    }
    sort(ref.begin(),ref.end());
    assert(ref.size()==seg[t].size()*2);
    stack<int> stk;
    for(int i=0;i<(int)ref.size();i++) {
      //printf("Ask::%d %d\n",ref[i].F,ref[i].S);
      if(ref[i].S>0) stk.push(ref[i].S);
      else {
	if(stk.top()!=-ref[i].S) return false;
	stk.pop();
      }
    }
  }
  return true;
}
signed main() {
  int T; read(T);
  for(int cas=1;cas<=T;cas++) {
    read(n); read(m);
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
	read(G[i][j]);
    seg[0].clear(); seg[1].clear();
    for(int i=1;i<n;i++)
      for(int j=1;j<=m;j++)
	seg[i&1].pb((SEG){G[i][j],G[i+1][j]});
    for(int i=0;i<2;i++)
      for(int j=0;j<(int)seg[i].size();j++)
	seg[i][j].Config();
    if(!Judge()) GG;

    seg[0].clear(); seg[1].clear();
    for(int j=1;j<m;j++)
      for(int i=1;i<=n;i++)
	seg[j&1].pb((SEG){G[i][j],G[i][j+1]});
    for(int i=0;i<2;i++)
      for(int j=0;j<(int)seg[i].size();j++)
	seg[i][j].Config();
    if(!Judge()) GG;
    puts("AllRight");
  }
  return 0;
}
```

---


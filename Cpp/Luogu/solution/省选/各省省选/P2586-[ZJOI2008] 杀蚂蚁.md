# [ZJOI2008] 杀蚂蚁

## 题目描述

最近，佳佳迷上了一款好玩的小游戏：antbuster。

游戏规则非常简单：在一张地图上，左上角是蚂蚁窝，右下角是蛋糕，蚂蚁会源源不断地从窝里爬出来，试图把蛋糕搬回蚂蚁窝。而你的任务，就是用原始资金以及杀蚂蚁获得的奖金造防御塔，杀掉这些试图跟你抢蛋糕的蚂蚁~

为了拿到尽可能高的分数，佳佳设计了很多种造塔的方案，但在尝试了其中的一小部分后，佳佳发现，这个游戏实在是太费时间了。为了节省时间，佳佳决定写个程序，对于每一种方案，模拟游戏进程，根据效果来判断方案的优劣。

根据自己在游戏中积累的一些经验，以及上网搜到的一些参数，佳佳猜了蚂蚁爬行的算法，并且假设游戏中的蚂蚁也是按这个规则选择路线：

1. 每一秒钟开始的时候，蚂蚁都在平面中的某个整点上。如果蚂蚁没有扛着蛋糕，它会在该点留下 $2$ 单位的信息素，否则它会留下 $5$ 单位的信息素。然后蚂蚁会在正北、正南、正东、正西四个方向中选择一个爬过去。

2. 选择方向的规则是：首先，爬完一个单位长度后到达的那个点上，不能有其他蚂蚁或是防御塔，并且那个点不能是蚂蚁上一秒所在的点（除非上一个时刻蚂蚁就被卡住，且这个时刻它仍无法动），当然，蚂蚁也不会爬出地图的边界（我们定义这些点为不可达点）。如果此时有多个选择，蚂蚁会选择信息素最多的那个点爬过去。

3. 如果此时仍有多种选择，蚂蚁先面向正东，如果正东不是可选择的某个方向，它会顺时针转 $90^\degree$，再次判断，如果还不是，再顺时针旋转 $90^\degree$，直到找到可以去的方向。

4. 如果将每只蚂蚁在洞口出现的时间作为它的活动时间的第 $1$ 秒，那么每当这只蚂蚁的活动时间秒数为 $5$ 的倍数的时候，它先按规则 $1\sim 3$ 确定一个方向，面对该方向后逆时针转 $90^\degree$，若它沿当前方向会走到一个不可达点，它会不停地每次逆时针转 $90^\degree$，直到它面对着一个可达的点，这样定下的方向才是蚂蚁最终要爬去的方向。

5. 如果蚂蚁的四周都是不可达点，那么蚂蚁在这一秒内会选择停留在当前点。下一秒判断移动方向时，它上一秒所在点为其当前停留的点。

6. 你可以认为蚂蚁在选定方向后，瞬间移动到它的目标点，这一秒钟剩下的时间里，它就停留在目标点。

7. 蚂蚁按出生的顺序移动，出生得比较早的蚂蚁先移动。

然后，是一些有关地图的信息：

1. 每一秒，地图所有点上的信息素会损失 $1$ 单位，如果那个点上有信息素的话。

2. 地图上某些地方是炮台。炮台的坐标在输入中给出。

3. 地图的长、宽在输入中给出，对于 $n\times m$ 的地图，它的左上角坐标为 $(0,0)$，右下角坐标为 $(n,m)$。蚂蚁洞的位置为 $(0,0)$，蛋糕的位置为 $(n,m)$。

4. 你可以把蚂蚁看做一个直径为 $1$ 单位的圆，圆心位于蚂蚁所在的整点。

5. 游戏开始时，地图上没有蚂蚁，每个点上的信息素含量均为 $0$。

一些有关炮塔的信息：

1. 炮塔被放置在地图上的整点处。

2. 为了简单一些，我们认为这些炮塔都是激光塔。激光塔的射速是 $1$ 秒每次，它的攻击伤害为 $d$ 单位每次，攻击范围为 $r$。你可以认为每秒蚂蚁移动完毕后，塔才开始攻击。并且，只有当代表蚂蚁的圆的圆心与塔的直线距离不超过 $r$ 时，塔才算打得到那只蚂蚁。

3. 如果一只蚂蚁扛着蛋糕，那么它会成为 target，也就是说，任何打得到它的塔的炮口都会对准它。如果蛋糕好好地呆在原位，那么每个塔都会挑离它最近的蚂蚁进行攻击，如果有多只蚂蚁，它会选出生较早的一只。如果有蚂蚁扛着蛋糕，但是不在某个塔的攻击范围内，这个塔会选择最近的蚂蚁进行攻击。

4. 激光塔有个比较奇怪的特性：它在选定了打击目标后，只要目标在其射程内，塔到目标蚂蚁圆心的连线上的所有蚂蚁（这里“被打到”的判定变成了表示激光的线段与表示蚂蚁的圆有公共点）都会被打到并损 $d$ 格血，但激光不会穿透它的打击目标打到后面的蚂蚁。

5. 尽管在真实游戏中，塔是可以升级的，但在这里我们认为塔的布局和等级就此定了下来，不再变动。

再介绍一下蚂蚁窝：

1. 如果地图上的蚂蚁不足 $6$ 只，并且洞口（即点 $(0,0)$）没有蚂蚁，那么窝中每秒会爬出一只蚂蚁，直到地图上的蚂蚁数为 $6$ 只。

2. 刚出生的蚂蚁站在洞口。

3. 每只蚂蚁有一个级别，级别决定了蚂蚁的血量，级别为 $k$ 的蚂蚁的血量为 $\lfloor 4\times 1.1^k\rfloor$（$\lfloor x\rfloor$ 表示对 $x$ 下取整）。每被塔打一次，蚂蚁的血减少 $d$。注意，血量为 $0$ 的蚂蚁仍能精力充沛地四处乱爬，只有一只蚂蚁的血被打成负数时，它才算挂了。

4. 蚂蚁的级别是这样算的：前 $6$ 只出生的蚂蚁是 $1$ 级，第 $7\sim 12$ 只是 $2$级，依此类推第 $6k+1\sim 6k+6$ 的等级是 $k+1(k\in \Bbb{N})$。

最后给出关于蛋糕的介绍：

1. 简单起见，你可以认为此时只剩最后一块蛋糕了。如果有蚂蚁走到蛋糕的位置，并且此时蛋糕没有被扛走，那么这只蚂蚁就扛上了蛋糕。蚂蚁被打死后蛋糕回到点 $(n,m)$。

2. 如果一只扛着蛋糕的蚂蚁走到蚂蚁窝的位置，我们就认为蚂蚁成功抢到了蛋糕，游戏结束。这个回合不会对蚂蚁的年龄产生贡献。

3. 蚂蚁扛上蛋糕时，血量会增加 $\left\lfloor\dfrac{x}{2}\right\rfloor$（$x$ 表示蚂蚁出生时的血量），但不会超过蚂蚁的血量上限。

整理一下 $1$ 秒钟内发生的事件：

1. $1$ 秒的最初，如果地图上蚂蚁数不足 $6$，一只蚂蚁就会在洞口出生。

2. 接着，蚂蚁们在自己所在点留下一些信息素后，考虑移动。先出生的蚂蚁先移动。

3. 移动完毕后，如果有蚂蚁在蛋糕的位置上并且蛋糕没被拿走，它把蛋糕扛上，血量增加，并在这时被所有塔设成 target。

4. 然后所有塔同时开始攻击。如果攻击结束后那只扛着蛋糕的蚂蚁挂了，蛋糕瞬间归位。扛着蛋糕的蚂蚁死后，蛋糕会在下一秒钟所有蚂蚁移动完之后再出现。下一秒钟出现在 $(n,m)$ 的蚂蚁才会获得蛋糕。

5. 攻击结束后，如果发现扛蛋糕的蚂蚁没死并在窝的位置，就认为蚂蚁抢到了蛋糕，游戏也在此时结束。

6. 最后，地图上所有点的信息素损失 $1$ 单位。所有蚂蚁的年龄加 $1$。漫长的 $1$ 秒到此结束。

## 说明/提示

### 样例说明：

$3\times 5$ 的地图，有一个单次伤害为 $1$、攻击范围为 $2$ 的激光炮塔，它的位置为 $(2,2)$，模拟游戏的前 $5$ 秒。

$5$ 秒内有 $5$ 只蚂蚁出生，都是向东爬行，其中第 $1\sim 4$ 只在路过 $(0,2)$ 点时被激光塔射伤了 $1$ 格血。在第 $5$ 秒的时候，最早出生的蚂蚁按移动规则 $1\sim 3$ 本来该向东移动，但由于规则 $4$ 的作用，它在发现向北和向西移动都会到达不可达点后，最终选择了向南移动。

### 数据范围说明：

对于 $100\%$ 的数据，满足 $1\leqslant n,m\leqslant 8,s\leqslant 20,t\leqslant 2\times 10^5,0\leqslant d\leqslant 10^4,0\leqslant r\leqslant 15$。（这里的 $s$ 指的是炮塔的总数）。

## 样例 #1

### 输入

```
3 5
1 1 2
2 2
5
```

### 输出

```
The game is going on
5
5 1 3 1 4
4 1 3 0 4
3 1 3 0 3
2 1 3 0 2
1 1 4 0 1
```

# 题解

## 作者：Ace_Heart (赞：153)

## 前方高能预警
## 非战斗人员请马上撤离 QwQ
## 这里是当前
# 不用结构体内置函数最通俗易懂
# 码风最具强迫症
# 注释最为详细
# ~~最可爱~~（蒟蒻&&萌新预警）
## 的题解！！！



------------


## 正文开始：


首先

显然这是一道模拟~~（废话）~~

思路也很容易想~~（按照题目说得一步步写就可以水过了）~~

生成蚂蚁-->释放信息素-->蚂蚁移动-->检查蛋糕是否被获取-->炮塔开火-->清理蚂蚁尸体-->检查游戏是否结束-->蚂蚁生长-->信息素流逝

之所以这样子设计思路是因为以下几个坑点：

1.炮塔是全体选定好各种的目标后同时射击，这意味着即使一个蚂蚁在这一秒钟被射至负血，其余炮塔当前依旧会攻击它（如果它之前被选为目标）

2.蚂蚁被卡住一次后就**可以返回**原路

3.判断一个蚂蚁是否被激光击中需要高中知识打**几何模板**

4.蚂蚁初始年龄是**零**

5.当蚂蚁存活时间达到5的倍数时的不正常转向是有合法的道路就走，但**至少**要在找到原正确方案的情况下逆时针转一次

6.蚂蚁的初始血量要用**浮点数**记录，因为蛋糕回血时是初始血量除2才向下取整

7.炮塔**可以不开火**，激光**不会透过其目标**

8.生成蚂蚁的条件之一是**蚂蚁窝上不能有蚂蚁**

9.某个蚂蚁血量为负且当前处于的位置被占用**不代表**它的尸体没有被处理（死亡没有被记录），因为有可能是别的蚂蚁在该点

然后我们就可以愉快的做（bei）题(xue)了~

很快你就会发现你成功的被极限数据卡住 **QwQ**

这里就提供两个小优化

第一个是~~显而易见~~的：当炮塔的攻击的目标不是Target时，显然该目标是离炮塔最近的，而炮塔对其的激光攻击就显然不能波及其他蚂蚁，否则其就不是最近目标

第二个是本君**不同于上述两个题解**的~~强力又易懂的~~优化操作（前方蒟蒻预警）

先来看一组极限数据：

n=8 m=8

s=1 d=200000 r=9

x=1 y=1

t=200000

即仅有一个攻击力无穷大的炮台于蚂蚁窝旁边，时间为200000秒

此时蚂蚁一出来就被杀死，以至于蚂蚁窝一直生产蚂蚁

如果你对蚂蚁进行的操作（留下信息素、生长、移动等）都是枚举全部的蚂蚁然后判断活着再对其操作，每次相关操作显然会超时

于是我们可以像之前的两篇题解一样维护一个仅存有活着的蚂蚁的数组

**也可以**定义一个变量last记录第一只活着的蚂蚁的编号，以后每次枚举都从它开始，当然这不是最优的，但是这是最容易的想到的，既然之前的蚂蚁都死了就没有必要从头枚举，于是时间复杂度大大降低~~（当然依旧可以被极为刁钻的手造200000数据卡死）

代码见下（几乎每一行都有注释，一定要愉快的AC哟~~~然后把这道题评为黑色~~）

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<cmath>
#include<ctime>
#include<algorithm>
#include<queue>
#define ll long long
#define N 1001003
#define inf 0x3fffffff
#define eps 1e-10
using namespace std;

ll inline read()//快读 
{
	ll ret=0;
	char ch=getchar();
	int f=1;
	
	while(!isdigit(ch) && ch!='-')
	ch=getchar();
	
	if(ch=='-')
	{
		f=-1;
		ch=getchar();
	}
	
	while(isdigit(ch))
	{
		ret=(ret<<1)+(ret<<3)+(ch^48);
		ch=getchar(); 
	}
	
	return ret*f;
}

//Math（几何模板）（高中向量 QAQ） 

struct Point
{
	double x;
	double y;
};

Point inline TurnPoint(double x,double y)
{
	Point NewPoint;
	
	NewPoint.x=x;
	NewPoint.y=y;
	
	return NewPoint;
}

Point operator + (Point A,Point B)
{
	Point NewPoint=TurnPoint(A.x+B.x,A.y+B.y);
	
	return NewPoint;
}

Point operator - (Point A,Point B)
{
	Point NewPoint=TurnPoint(A.x-B.x,A.y-B.y);
	
	return NewPoint;
}

int inline DoublePositive(double x)
{
	if( fabs(x)<eps )
	return 0;
	
	if(x<0)
	return -1;
	return 1;
}

double inline Dot(Point A,Point B)
{
	double sum=A.x*B.x+A.y*B.y;
	
	return sum;
}

double inline Length(Point A)
{
	double sum=sqrt( Dot(A,A) );
	
	return sum;
}

double inline Cross(Point A,Point B)
{
	double sum=A.x*B.y-A.y*B.x;
	
	return sum;
}

double inline GetSlope(Point A)
{
	double sum=A.y/A.x;
	
	return sum;
}

double inline GetPointDistantToSegment(Point P,Point A,Point B)
{
	Point Vector_1=B-A;
	Point Vector_2=P-A;
	Point Vector_3=P-B;
	
	if( DoublePositive( Dot(Vector_1,Vector_2) )<0 )
	return Length(Vector_2);
	
	if( DoublePositive( Dot(Vector_1,Vector_3) )>0 )
	return Length(Vector_3);
	
	return fabs( Cross(Vector_1,Vector_2) / Length(Vector_1) );
}

//数学比NOI还要使我脱发 QAQ

int last=1;//原创重要优化 表示第一只活着的蚂蚁 

int n,m;//地图的长和宽 

struct Map//地图 
{
	int InformationSum;//地图上某点的信息素 
	bool used;//地图上某点有没有被占用 
};
Map g[25][25];//地图数组 

int EndTime;//结束时间 

bool GameWin=false;//游戏是否结束 
bool CakeFly=false;//蛋糕有没有不翼而飞 QwQ

int TurretSum;//炮塔数 
int TurretRadius;//炮塔攻击范围 
int TurretDamage;//炮塔伤害 
int Target;//炮塔首选目标（拿蛋糕的哥们编号 @w@ ） 

struct Turret//炮塔 
{
	int goal;//炮塔目标 
	int x;
	int y;
};
Turret t[25];//炮塔数组 

int BornAntSum=0;//生出的蚂蚁总数 
int NowAntSum=0;//现在存活的蚂蚁数 
const double AntSize=0.5;//蚂蚁的尺寸（占地半径） 

struct Ant//蚂蚁 
{
	int x;//当前所在坐标 
	int y;
	int old;//年龄 
	int level;//等级 
	int health;//血量 
	double BornHealth;//初始血量 
	int x_from;//上一秒所在坐标 
	int y_from;
	bool get;//是否获得蛋糕 
	bool dead;//是否死亡 
};
Ant a[300000];

void AntBorn()//蚂蚁的出生 
{
	if(NowAntSum>=6)//场上蚂蚁数不得超过6 
	return ;
	
	if(g[0][0].used)//蚂蚁窝不得有蚂蚁 
	return ;
	
	BornAntSum++;//生出的蚂蚁数++ 
	NowAntSum++;//当前存活的蚂蚁数++ 
	
	a[BornAntSum].x=0;//初始坐标为蚁窝 
	a[BornAntSum].y=0;
	a[BornAntSum].x_from=99;//来着地狱（无穷远 QwQ） 
	a[BornAntSum].y_from=99;
	
	g[0][0].used=true;//蚁窝已被占据 
	
	a[BornAntSum].old=0;//初始时为零岁 
	a[BornAntSum].level=( (BornAntSum-1)/6 )+1;//等级为之前生成的蚂蚁数/6 +1 
	a[BornAntSum].get=false;//初始没有蛋糕 
	a[BornAntSum].dead=false;//初始没死 QwQ 
	
	double Health=floor(4*pow(1.1,a[BornAntSum].level));//初始血量计算 
	
	a[BornAntSum].health=(int)Health;//血量取整 
	a[BornAntSum].BornHealth=Health;//初始血量记录 
	
	return ;
}

void inline ReleaseInformation()//释放信息素 
{
	for(int i=last;i<=BornAntSum;i++)//从第一只活着的蚂蚁开始枚举 
	{
		if(a[i].dead)//死蚂蚁跳过 
		continue;
		
		if(!a[i].get)
		g[ a[i].x ][ a[i].y ].InformationSum+=2;//没蛋糕放2点 
		else
		g[ a[i].x ][ a[i].y ].InformationSum+=5;//有蛋糕放5点 
	}
	
	return ;
}

const int dx[4]={0,1,0,-1};//方向数组 
const int dy[4]={1,0,-1,0};//东南西北 

bool inline CheakPoint(int x,int y)//检查一个点能否放蚂蚁 
{
	//四种出界情况 
	if(x<0)
	return false;
	
	if(x>n)
	return false;
	
	if(y<0)
	return false;
	
	if(y>m)
	return false;
	
	//被占用的情况 
	if(g[x][y].used)
	return false;
	
	return true;
}

void inline AntMove()//蚂蚁移动 
{
	for(int i=last;i<=BornAntSum;i++)//同样从第一只活着的蚂蚁开始枚举 
	{
		if(a[i].dead)//死蚂蚁跳过 
		continue;
		
		int MaxInformation=-1;//能走的方向上最多的信息素 
		int NowDirection=-1;//不正常转向后的方向（活动时间为5的倍数） 
		int direction=-1;//正常情况的方向 
		int nowx;//要去的坐标 
		int nowy;
		int nowd;//要走的方向 
		
		for(int j=0;j<4;j++)//四方向枚举 
		{	
			nowx=a[i].x+dx[j];//要去的坐标更新 
			nowy=a[i].y+dy[j];

			if(!CheakPoint(nowx,nowy)) 
			continue;//检查能否去
			
			if(nowx==a[i].x_from && nowy==a[i].y_from)
			continue;//检查是否从要去的点来 
			
			if(MaxInformation<g[nowx][nowy].InformationSum)
			{
				MaxInformation=g[nowx][nowy].InformationSum;
				direction=j;//能走就尝试更新最多信息数与方向 
			} 
		}

		if( (a[i].old+1)%5==0 && direction!=-1 )//至少原先要有方向可走 
		{
			MaxInformation=-1;//当蚂蚁存活秒数为5的倍数就开始浪~ 
			NowDirection=-1;//新方向 
			
			for(int j=1;j<=4;j++)//以原方向为基准逆时针旋转 
			{
				nowd=(direction-j)%4;
				
				if(nowd<0)//注意转了一圈的情况 
				nowd+=4;
				
				nowx=a[i].x+dx[nowd];//同样应去的坐标 
				nowy=a[i].y+dy[nowd];
				
				if(!CheakPoint(nowx,nowy))
				continue;//同样检查是否能走 
				
				if(nowx==a[i].x_from && nowy==a[i].y_from)
				continue;//同上检查是否从该点来 
				
				if(MaxInformation<g[nowx][nowy].InformationSum)
				{
					MaxInformation=g[nowx][nowy].InformationSum;
					NowDirection=nowd;//同样更新方向和最大信息素 
					//事实上最大信息素的更新没多少用（只是判断该蚂蚁能否移动） 
					break;//转后一有合法的方向就出发 
				}
			}
		}
		
		a[i].x_from=a[i].x;//上一秒在的坐标更新 
		a[i].y_from=a[i].y;//更新后蚂蚁就没有不能返回（当前）原路的限制了 
		
		if(MaxInformation==-1)
		continue;//最大信息素没有被更新说明没有点可以走 
		
		if( (a[i].old+1)%5==0 )//叛逆期 QwQ 
		{
			a[i].x+=dx[NowDirection];//立即走至该点 
			a[i].y+=dy[NowDirection];
			
			g[ a[i].x_from ][ a[i].y_from ].used=false;
			g[ a[i].x ][ a[i].y ].used=true;//注意占用的点要改变 
		}
		else//正常情况下一样 
		{
			a[i].x+=dx[direction];
			a[i].y+=dy[direction];
			
			g[ a[i].x_from ][ a[i].y_from ].used=false;
			g[ a[i].x ][ a[i].y ].used=true;
		}
	}
	
	return ;
}
 
void inline CheakCake()//检查是否有蚂蚁能拿走蛋糕 
{
	if(CakeFly)//如果蛋糕早就已经被拿走则返回 
	return ;
	
	for(int i=last;i<=BornAntSum;i++)//枚举活着的蚂蚁 
	{
		if(a[i].dead)//同上 
		continue;
		 
		if(a[i].x==n && a[i].y==m)//如果到达了有蛋糕的点 
		{
			Target=i;//成为过街老鼠 QwQ 
			
			CakeFly=true;//前面已保证蛋糕在该点 
			a[i].get=true;//蚂蚁获得蛋糕 
			
			a[i].health+=(int)(a[i].BornHealth/2);//偷吃蛋糕回血 
			a[i].health=min((int)a[i].BornHealth,a[i].health);//注意血量不超上限 

			return ;
		}
	}
	
	return ;
}

double inline GetDistant(int x1,int y1,int x2,int y2)//两点距离公式 
{
	int Sum=( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );
	
	return sqrt( (double)Sum );
}
 
void inline FireAnt()//二营长的意大利炮预备开火 QwQ 
{
	for(int i=1;i<=TurretSum;i++)//枚举每一个炮塔 
	{
		double TargetDistant=GetDistant(t[i].x,t[i].y,a[Target].x,a[Target].y);//炮塔与首选目标的距离 
		//如果没有首选目标或者离首选目标太远就正常打最近的蚂蚁 
		if(!CakeFly || TargetDistant-(double)TurretRadius>eps)//注意实数域的计算要与极小值比较 
		{
			double GoalDistant;//炮塔与当前目标的距离 
			double MinDistant=inf;//离炮塔最近的蚂蚁与炮塔的距离 
			
			for(int j=last;j<=BornAntSum;j++)//同样枚举存活的蚂蚁 
			{	
				if(a[j].dead)//同上 
				continue;
				
				//与当前蚂蚁的距离计算 
				GoalDistant=GetDistant(t[i].x,t[i].y,a[j].x,a[j].y);
				
				if(GoalDistant<MinDistant)//查看能否更新最近距离 
				{
					MinDistant=GoalDistant;
					t[i].goal=j;//更新最近蚂蚁作目标 
				}
			}
			
			if(MinDistant-(double)TurretRadius>eps)
			{
				//如果最近距离都不能满足就返回 
				t[i].goal=0;
				
				continue;
			}
			
			//攻击最近目标 
			a[ t[i].goal ].health-=TurretDamage;
		}
		else//如果存在首选目标且能打到 
		{
			t[i].goal=Target;//目标为首选目标 
			
			Point A=TurnPoint(a[ t[i].goal ].x,a[ t[i].goal ].y);
			Point B=TurnPoint(t[i].x,t[i].y);//向量预备 
			
			for(int j=last;j<=BornAntSum;j++)//枚举活着的蚂蚁 
			{
				if(a[j].dead)//（活着的目标都有可能被波及） 
				continue;
				
				if(a[j].get)//如果是首选的目标就直接打击 
				{
					a[j].health-=TurretDamage;
	
					continue;
				}
				
				Point P=TurnPoint(a[j].x,a[j].y);//点预备 
				
				double NotGoalDistant=GetPointDistantToSegment(P,A,B);//点与直线的距离 
				
				if(NotGoalDistant-AntSize<eps)//如果能被激光波及到就减血 
				a[j].health-=TurretDamage;
				
			}
		}			
	}
}

void inline ClearBulletField()//清理战场 
{
	for(int i=last;i<=BornAntSum;i++)//枚举可能死掉的蚂蚁 
	{
		if(a[i].health>=0)//该蚂蚁当前血量应该<0 
		continue;
		
		if(!g[ a[i].x ][ a[i].y ].used)//当前应该占用一个点 
		continue;
		
		if(a[i].dead)//当前应该没视作死亡 
		continue;
		
		NowAntSum--;//存活蚂蚁数-- 
		g[ a[i].x ][ a[i].y ].used=false;//不占用空间（处理尸体） 
		
		a[i].x=99;//滚去地狱  
		a[i].y=99;//QwQ 
		a[i].dead=true;//确认死亡 
		
		if(a[i].get)//如果有蛋糕 
		{
			CakeFly=false;//把蛋糕放回去 
			Target=0;//首选目标死亡 
		}

	}
}

void inline CheakGameContinue()//检查游戏是否继续 
{
	if(!CakeFly)//蛋糕没有被拿走则继续 
	return ;
	
	for(int i=last;i<=BornAntSum;i++)//枚举可能带蛋糕回蚁窝的蚂蚁 
	{
		if(a[i].dead)//首先它应该是活着的 
		continue;
		
		if(a[i].x || a[i].y)//而且它坐标应该为（0,0） 
		continue;
		
		if(!a[i].get)//而且它要有蛋糕 
		continue;
		
		GameWin=true;//游戏胜利 

		break;
	}
	
	return ;
}

void inline AntGrow()//蚂蚁长大 
{
	for(int i=last;i<=BornAntSum;i++)//首先依然得活着 
	{
		if(a[i].dead)//同上 
		continue;
		
		a[i].old++;//长大 
	}
	
	return ;
}

void inline InformationGone()//信息素消失 
{
	for(int i=0;i<=n;i++)
	{
		for(int j=0;j<=m;j++)
		{
			if(g[i][j].InformationSum)//注意要有信息素 
			g[i][j].InformationSum--;
		}
	}
	
	return ;
}
 
void inline Enter()//输入 
{
	n=read();//读入地图大小 
	m=read();
	
	TurretSum=read();//读入炮塔相关信息 
	TurretDamage=read();
	TurretRadius=read();
	
	for(int i=1;i<=TurretSum;i++)//读入炮塔 
	{
		t[i].x=read();
		t[i].y=read();
		//记得炮塔也要占一个点 
		g[ t[i].x ][ t[i].y ].used=true;
	}
	
	EndTime=read();//读入结束时间 
	
	return ;
}

void inline Work()//工作 
{
	for(int Time=1;Time<=EndTime;Time++)//时光飞逝 
	{
		AntBorn();//蚂蚁出生 

		ReleaseInformation();//释放信息素 

		AntMove();//蚂蚁跑路 

		CheakCake();//检查是否有蚂蚁能拿到蛋糕 

		FireAnt();//开火 
		
		ClearBulletField();//清理战场 
		
		CheakGameContinue();//检查游戏是否能继续 
		
		if(GameWin)//如果蚂蚁已经获胜 
		{
			printf("Game over after %d seconds\n",Time);
			
			break;
		}
		
		AntGrow();//蚂蚁生长 
		
		InformationGone();//信息素流逝 
		
		for(int i=last;i<=BornAntSum;i++)//更新第一只存活的蚂蚁 
		{
			if(a[i].dead)
			continue;
			else
			{
				last=i;
				break;
			}
		}
	}
	
	return ;
}

void inline Output()
{
	if(!GameWin)//如果蚂蚁没有获胜 
	printf("The game is going on\n");
	
	printf("%d\n",NowAntSum);//输出存活的蚂蚁数 
	
	for(int i=last;i<=BornAntSum;i++)//输出相关信息 
	{
		if(a[i].dead)//首先蚂蚁应该是活着的 
		continue;
		
		printf("%d ",a[i].old);//输出年龄 
		printf("%d ",a[i].level);//输出等级 
		printf("%d ",a[i].health);//输出血量 
		printf("%d ",a[i].x);//输出当前坐标 
		printf("%d ",a[i].y);//
		
		printf("\n");//换行 
	}
	
	return ;
}

int main()//优美的主函数 QwQ 
{
	/*freopen("Enter.in","r",stdin);//习惯性打开文件 
	freopen("Output.out","w",stdout);*/
	
	Enter();//输入 
	
	Work();//工作 
	
	Output();//输出 

	return 0;//程序结束 
}



```



------------

## 后记
**不喜请跳过**

再过两天就是初赛，想想看，现在的自己也才不过接触oi九个月吧，希望能拿一个省一等奖就心满意足了~

这道题是我写过的代码量最大的题目了QAQ

这让我想起了我的OI之旅

虽然才刚刚起步，但是仍然困难重重

停课，熬夜，培训

我热爱这种待在机房的日子

就像我并不讨厌这道烦琐的模拟

写了许久，不止一次萌生退意

但是就像OI一样

踏上了旅途就没有退路

我们不是坚持，是实在退无可退……



---

## 作者：Setsugesuka (赞：14)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这么简单的题目写题解的什么少？不可思议。看了一下题解区，大部分人都是暴力维护数组，或者是手动实现链表等操作。事实上，$STL$中还给我们提供了一个非常方便的容器——$List$。对于这种偏工程向的题目，显然，用$List$与迭代器实现会更加简单，直观，好写。


&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;**ps：考虑到题目中对于每个对象所需存储的信息并不多，我便使用了更快的$Struct$来实现我的代码。**

------------
## 读题 分析题目需求

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;首先，我们仔细地阅读一遍题目，首先，对于地图，我们发现对于地图上的一个点，我们需要储存两种信息——能否通过，与信息素数量。我们这么定义地图上的每一个点：

```cpp
struct mpNode
{
    int message=0;
    bool canMove=true;
};

mpNode mp[MAXN][MAXN];
```

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;同样地，我们发现，对于每一只蚂蚁，我们都只需要储存它们的年龄，等级，血量，当前位置，上一秒的位置，血量最大值，是否拥有蛋糕就可以了。为了能够更好地创建一个蚂蚁个体，我们手动写一个构造函数：

```cpp
struct antNode
{
    int age;
    int level;
    int HP;
    int posx;
    int posy;
    int prex;
    int prey;
    int maxHP;
    bool isCake;
    antNode(int age,int level,int HP,int x,int y,bool isCake=false):
            age(age),level(level),HP(HP),posx(x),posy(y),isCake(isCake),prex(x),prey(y),maxHP(HP){}
};
```

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;考虑蚂蚁的存储方式，我们发现，在游戏的所有过程中，蚂蚁的行动顺序都是一样的，从年龄最大的到年龄最小的。于是，我们想到了使用$Set$来维护我们的蚂蚁序列。但是，在$STL$中的$Set$是具有只读属性的，不能对其中元素进行修改。我们再仔细思考生成蚂蚁的过程，发现我们只需要维护一个蚂蚁的链表即可。为什么呢？因为蚂蚁的最大数量是固定的，对于后生成的蚂蚁，我们只需要把它们放到链表的最后，对于每个过程，只需要从前往后遍历链表，就可以实现了。于是，我们考虑使用$STL$的$List$

>（如果你并不会使用$List$，可以去自行百度地说$QwQ$，操作很少$der$）

```cpp
list<antNode> antList;
```

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;那么，既然我们使用了$List$来维护蚂蚁序列，对于单个防御塔，我们就可以把攻击的对象以迭代器的方式储存起来，实现更直观，更简便的攻击操作了。

```cpp
struct towerNode
{
    int x;
    int y;
    double minDis;
    bool haveTarget;
    bool haveCakeTarget;
    list<antNode>::iterator target;
};
```

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;考虑全局变量，对于蚂蚁生成，我们需要记录一共生成了多少只蚂蚁，而由于对$List$的求$Size$操作是$O(n)$的，作为一个合格的$OIer$，我们自然要选择更快的方法，于是我们再用一个全局变量储存当前存活了多少只蚂蚁。对于转向操作，我们需要从向东开始，储存一个顺时针旋转的方向数组，对于取蛋糕操作，我们还需要记录蛋糕是否已经被取走。重新考虑蚂蚁生成操作，我们不难发现，在一局游戏中，蚂蚁的等级是拥有最大值的，那么，很显然，在给定了$t$之后，$1.1^k$是可以预处理出来的，我们也用全局变量将它储存起来。

```cpp
const double eps=1e-10;
const int MAXN=10;
int n,m,s,d,t;
double r;
int antCnt;
int nowt;
int dirx[4]={0,1,0,-1};
int diry[4]={1,0,-1,0};
int totalSpawn;

bool cakeBeTaken;

double prepow[35000];
```



&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;对于游戏过程，幸运的是，这道题虽然是一个大模拟，但是出题人已经把整个进行过程写在了题面中了，这也使得我们很容易就能把主程序和输入输出程序给写完。对于这么良心的出题人，你们怎么好意思把它评成紫题呢？要像我一样选择入门难度！

```cpp
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
    while (isdigit(ch)){x=x*10+ch-48;ch=getchar();}
    return x*f;
}

inline void print()
{
    if(nowt==t+1)
        cout<<"The game is going on"<<endl;
    else
        cout<<"Game over after "<<nowt<<" seconds"<<endl;
    list<antNode>::iterator it;
    cout<<antCnt<<endl;
    for(it=antList.begin();it!=antList.end();it++)
        cout<<it->age<<" "<<it->level<<" "<<it->HP<<" "<<it->posx<<" "<<it->posy<<endl;
}

int main()
{
    totalSpawn=0;
    cakeBeTaken=false;
    antCnt=0;
    n=read(),m=read(),s=read(),d=read(),r=read();
    for(int i=1;i<=s;i++)
    {
        tower[i].x=read();
        tower[i].y=read();
        mp[tower[i].x][tower[i].y].canMove=false;
    }
    t=read();
    prepow[1]=1.1;
    for(int i=2;i<=(t/6)+1;i++)
        prepow[i]=prepow[i-1]*1.1;
    for(nowt=1;nowt<=t;nowt++)
    {
        AntSpawn();
        LeaveMessage();
        Move();
        GetCake();
        TowerAttack();
        DestoryBody();
        if(GameOverCheck())
            break;
        LastUpdate();
    }
    print();
    return 0;
}
```

------------
## 考虑简单操作

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;分析整个游戏过程，我们发现，对于全部的操作而言，只有移动和攻击是十分麻烦的，对于其他的操作，由于我们使用了$List$容器，很容易就能维护。于是，我们先实现那些比较简单的需求。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;对于蚂蚁生成，首先，我们需要考虑当前能否生成蚂蚁，如果蚂蚁已经到了上限，或者$(0,0)$已经有了一只蚂蚁，就不生成，否则，生成一只新的蚂蚁。对于新蚂蚁的等级，我们可以通过总蚂蚁数量来计算得到，对于新蚂蚁的血量，由于我们已经预处理了$1.1^k$，也可以在不使用$pow$函数的情况下快速得到，于是，我们很容易就能写出生成蚂蚁的函数了。

```cpp
inline void AntSpawn()
{
    if(antCnt>=6||mp[0][0].canMove==false)
        return;
    antCnt++;
    totalSpawn++;
    int nowLevel=((totalSpawn-1)/6)+1;
    antList.push_back(antNode(0,nowLevel,(int)(4.0*prepow[nowLevel]),0,0,false));
    mp[0][0].canMove=false;
    return;
}
```

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;对于信息素的生成，我们只需要从前往后遍历一遍我们的蚂蚁序列，对于背着蛋糕的蚂蚁，我们留下$5$信息素，反之我们留下$2$信息素。

```cpp
inline void LeaveMessage()
{
    list<antNode>::iterator it;
    for(it=antList.begin();it!=antList.end();it++)
    {
        if(it->isCake==true)
            mp[it->posx][it->posy].message+=5;
        else
            mp[it->posx][it->posy].message+=2;
    }
    return;
}
```

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;对于蛋糕获取操作，我们首先遍历每一只蚂蚁，如果说当前蚂蚁在蛋糕上，且蛋糕没有被别的蚂蚁拿走，我们就让这只蚂蚁拿走蛋糕，更新蛋糕状态与蚂蚁血量。

```cpp
inline void GetCake()
{
    list<antNode>::iterator it;
    for(it=antList.begin();it!=antList.end();it++)
    {
        if(it->posx==n&&it->posy==m&&cakeBeTaken==false)
        {
            cakeBeTaken=true;
            it->isCake=true;
            it->HP=min(it->HP+(int)(floor)((double)it->maxHP/2.0),it->maxHP);
        }
    }
    return;
}
```

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;对于清理尸体的操作，我们遍历每一只蚂蚁，如果当前蚂蚁的血量已经小于$0$了，我们就将这只蚂蚁给$erase$掉，如果死亡的蚂蚁背着蛋糕，那我们重新更新蛋糕状态，反之则不更新。然后，我们更新蚂蚁的数量。在这里，我们需要注意到，如果对于当前的蚂蚁，我哦们将其删除，那我们的迭代器还是会指在那个删除的位置，当它自加之后，后面的蚂蚁也会往前进，这就导致我们会少遍历到那些本应该删除的蚂蚁，为了减少代码复杂度，我们定义一个局部变量来储存有没有蚂蚁被删除，如果有蚂蚁被删除了，那么在下一次遍历的时候，我们又从头开始遍历，由于蚂蚁数量的最大值是已知的，这个操作并不会太浪费时间。

```cpp
inline void DestoryBody()
{
    bool isErase=false;
    list<antNode>::iterator it;
    for(it=antList.begin();it!=antList.end();it++)
    {
        if(isErase==true)
        {
            it=antList.begin();
            isErase=false;
        }
        if(it->HP<0)
        {
            if(it->isCake)
            {
                it->isCake=false;
                cakeBeTaken=false;
            }
            mp[it->posx][it->posy].canMove=true;
            antList.erase(it);
            antCnt--;
            isErase=true;
        }
    }
    return;
}
```

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;对于判断游戏是否失败，我们同样只需要遍历每一只蚂蚁，如果说这只蚂蚁存活，背着蛋糕，且在$(0,0)$这个位置上，那就终止游戏。

```cpp
inline bool GameOverCheck()
{
    list<antNode>::iterator it;
    for(it=antList.begin();it!=antList.end();it++)
        if(it->isCake==true&&it->HP>=0&&it->posx==0&&it->posy==0)
            return true;
    return false;
}
```

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;对于每一秒结束，我们都需要减少地图上每个点的信息素，并增加当前存活的蚂蚁年龄。

```cpp
inline void LastUpdate()
{
    for(int i=0;i<=n;i++)
        for(int j=0;j<=m;j++)
            if(mp[i][j].message)
                mp[i][j].message--;
    list<antNode>::iterator it;
    for(it=antList.begin();it!=antList.end();it++)
        it->age++;
    return;
}
```

------------
## 考虑移动

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;首先，我们阅读题目，关于移动的描述非常长而复杂，在提取有用信息后，我们发现，移动无非是这么一个过程。
1. 从向东开始顺时针遍历每一个方向，如果只有一个信息素最大的点，我们朝着信息素最大的点前进，如果有多个，我们往最先遍历到的点前进。
2. 如果没有一个点可以前往，我们把蚂蚁上一秒的位置更新到现在的位置，这意味着到了下一秒，蚂蚁就可以原路返回了。
3. 如果蚂蚁的年龄$+1$之后是$5$的倍数，我们需要让这只蚂蚁逆时针找到第一个可以移动的方向作为它的前进方向。
4. 更新地图上点的状态，更新蚂蚁的位置。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;由于我们使用的是$List$容器，我们只需要用迭代器访问容器内元素的地址就可以实现更改了，代码如下。

```cpp
inline void Move()
{
    list<antNode>::iterator it;
    for(it=antList.begin();it!=antList.end();it++)
    {
        int pos;
        int ccMaxMessage=0;
        int chooseCount=0;
        for(int i=0;i<4;i++)
        {
            int ccx=it->posx+dirx[i],ccy=it->posy+diry[i];
            if(mp[ccx][ccy].canMove==true&&(ccx!=it->prex||ccy!=it->prey)&&ccx>=0&&ccx<=n&&ccy>=0&&ccy<=m)
            {
                if(mp[ccx][ccy].message==ccMaxMessage)
                {
                    pos=i;
                    chooseCount++;
                }
                else if(mp[ccx][ccy].message>ccMaxMessage)
                {
                    ccMaxMessage=mp[ccx][ccy].message;
                    pos=i;
                    chooseCount=1;
                }
            }
        }
        if(chooseCount==0)
        {
            it->prex=it->posx;
            it->prey=it->posy;
            continue;
        }
        else if(chooseCount>1)
        {
            for(pos=0;pos<4;pos++)
            {
                int ccx=it->posx+dirx[pos],ccy=it->posy+diry[pos];
                if(mp[ccx][ccy].canMove==true&&(ccx!=it->prex||ccy!=it->prey)&&ccx>=0&&ccx<=n&&ccy>=0&&ccy<=m&&mp[ccx][ccy].message==ccMaxMessage)
                    break;
            }
        }
        if((it->age+1)%5==0)
        {
            for(int i=0;i<4;i++)
            {
                pos--;
                if(pos<0)
                    pos+=4;
                int ccx=it->posx+dirx[pos],ccy=it->posy+diry[pos];
                if(mp[ccx][ccy].canMove==true&&(ccx!=it->prex||ccy!=it->prey)&&ccx>=0&&ccx<=n&&ccy>=0&&ccy<=m)
                    break;
            }
        }
        it->prex=it->posx;
        it->prey=it->posy;
        it->posx+=dirx[pos];
        it->posy+=diry[pos];
        mp[it->prex][it->prey].canMove=true;
        mp[it->posx][it->posy].canMove=false;
    }
    return;
}
```

------------
## 考虑攻击

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;首先，我们仔细地阅读题目，发现攻击有以下几个步骤。
1. 对于每一个防御塔的攻击目标，我们遍历每一只蚂蚁，如果有蚂蚁在其攻击范围内，我们优先选择攻击携带蛋糕的蚂蚁，其次选择距离最近的蚂蚁。
2. 每一个防御塔开始攻击，如果防御塔的目标是距离最近的蚂蚁，我们只需要扣除目标相应的血量，反之，我们运用向量的相关知识，判断攻击范围中的蚂蚁是否与激光有公共点，有就扣血。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在写完几何模板之后，我们很容易就能写出攻击的代码了。

```cpp
struct Point
{
    double x;
    double y;
};

Point inline TurnPoint(double x,double y)
{
    Point NewPoint;
    NewPoint.x=x;
    NewPoint.y=y;
    return NewPoint;
}

Point operator +(Point A,Point B)
{
    Point NewPoint=TurnPoint(A.x+B.x,A.y+B.y);
    return NewPoint;
}

Point operator -(Point A,Point B)
{
    Point NewPoint=TurnPoint(A.x-B.x,A.y-B.y);
    return NewPoint;
}

inline int DoublePositive(double x)
{
    if(fabs(x)<eps)
        return 0;
    if(x<0)
        return -1;
    return 1;
}

inline double Dot(Point A,Point B)
{
    double sum=A.x*B.x+A.y*B.y;
    return sum;
}

inline double Length(Point A)
{
    double sum=sqrt(Dot(A,A));
    return sum;
}

inline double Cross(Point A,Point B)
{
    double sum=A.x*B.y-A.y*B.x;
    return sum;
}

inline double GetSlope(Point A)
{
    double sum=A.y/A.x;
    return sum;
}

inline double GetPointDistantToSegment(Point P,Point A,Point B)
{
    Point Vector_1=B-A;
    Point Vector_2=P-A;
    Point Vector_3=P-B;
    if(DoublePositive(Dot(Vector_1,Vector_2))<0)
        return Length(Vector_2);
    if(DoublePositive(Dot(Vector_1,Vector_3))>0)
        return Length(Vector_3);
    return fabs(Cross(Vector_1,Vector_2)/Length(Vector_1));
}

inline double GetDistance(double tx,double ty,double ax,double ay)
{
    return sqrt((tx-ax)*(tx-ax)+(ty-ay)*(ty-ay));
}

inline void TowerAttack()
{
    list<antNode>::iterator it;
    for(int i=1;i<=s;i++)
    {
        tower[i].haveTarget=false;
        tower[i].minDis=99999999;
        tower[i].haveCakeTarget=false;
        for(it=antList.begin();it!=antList.end();it++)
        {
            double dis=GetDistance(tower[i].x,tower[i].y,it->posx,it->posy);
            if(dis-r<=eps)
            {
                tower[i].haveTarget=true;
                if(it->isCake)
                {
                    tower[i].haveCakeTarget=true;
                    tower[i].target=it;
                }
                else if(dis<tower[i].minDis&&tower[i].haveCakeTarget==false)
                {
                    tower[i].target=it;
                    tower[i].minDis=dis;
                }
            }
            if(tower[i].haveCakeTarget)
                break;
        }
    }
    for(int i=1;i<=s;i++)
    {
        if(tower[i].haveTarget==false)
            continue;
        if(tower[i].haveCakeTarget==false)
            tower[i].target->HP-=d;
        else
        {
            Point A=TurnPoint(tower[i].target->posx,tower[i].target->posy);
            Point B=TurnPoint(tower[i].x,tower[i].y);
            for(it=antList.begin();it!=antList.end();it++)
            {
                if(it->isCake)
                {
                    it->HP-=d;
                    continue;
                }
                Point P=TurnPoint(it->posx,it->posy);
                double QAQDistance=GetPointDistantToSegment(P,A,B);
                if(QAQDistance-0.5<eps)
                    it->HP-=d;
            }
        }
    }
    return;
}
```

------------
## 完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const double eps=1e-10;
const int MAXN=10;
int n,m,s,d,t;
double r;
int antCnt;
int nowt;
int dirx[4]={0,1,0,-1};
int diry[4]={1,0,-1,0};
int totalSpawn;

bool cakeBeTaken;

double prepow[35000];

struct mpNode
{
    int message=0;
    bool canMove=true;
};

struct antNode
{
    int age;
    int level;
    int HP;
    int posx;
    int posy;
    int prex;
    int prey;
    int maxHP;
    bool isCake;
    antNode(int age,int level,int HP,int x,int y,bool isCake=false):
            age(age),level(level),HP(HP),posx(x),posy(y),isCake(isCake),prex(x),prey(y),maxHP(HP){}
};

struct towerNode
{
    int x;
    int y;
    double minDis;
    bool haveTarget;
    bool haveCakeTarget;
    list<antNode>::iterator target;
};

mpNode mp[MAXN][MAXN];
list<antNode> antList;
towerNode tower[22];

inline int read()
{
    int x=0,f=1;char ch=getchar();
    while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
    while (isdigit(ch)){x=x*10+ch-48;ch=getchar();}
    return x*f;
}

struct Point
{
    double x;
    double y;
};

Point inline TurnPoint(double x,double y)
{
    Point NewPoint;
    NewPoint.x=x;
    NewPoint.y=y;
    return NewPoint;
}

Point operator +(Point A,Point B)
{
    Point NewPoint=TurnPoint(A.x+B.x,A.y+B.y);
    return NewPoint;
}

Point operator -(Point A,Point B)
{
    Point NewPoint=TurnPoint(A.x-B.x,A.y-B.y);
    return NewPoint;
}

inline int DoublePositive(double x)
{
    if(fabs(x)<eps)
        return 0;
    if(x<0)
        return -1;
    return 1;
}

inline double Dot(Point A,Point B)
{
    double sum=A.x*B.x+A.y*B.y;
    return sum;
}

inline double Length(Point A)
{
    double sum=sqrt(Dot(A,A));
    return sum;
}

inline double Cross(Point A,Point B)
{
    double sum=A.x*B.y-A.y*B.x;
    return sum;
}

inline double GetSlope(Point A)
{
    double sum=A.y/A.x;
    return sum;
}

inline double GetPointDistantToSegment(Point P,Point A,Point B)
{
    Point Vector_1=B-A;
    Point Vector_2=P-A;
    Point Vector_3=P-B;
    if(DoublePositive(Dot(Vector_1,Vector_2))<0)
        return Length(Vector_2);
    if(DoublePositive(Dot(Vector_1,Vector_3))>0)
        return Length(Vector_3);
    return fabs(Cross(Vector_1,Vector_2)/Length(Vector_1));
}

inline double GetDistance(double tx,double ty,double ax,double ay)
{
    return sqrt((tx-ax)*(tx-ax)+(ty-ay)*(ty-ay));
}

inline void AntSpawn()
{
    if(antCnt>=6||mp[0][0].canMove==false)
        return;
    antCnt++;
    totalSpawn++;
    int nowLevel=((totalSpawn-1)/6)+1;
    antList.push_back(antNode(0,nowLevel,(int)(4.0*prepow[nowLevel]),0,0,false));
    mp[0][0].canMove=false;
    return;
}

inline void LeaveMessage()
{
    list<antNode>::iterator it;
    for(it=antList.begin();it!=antList.end();it++)
    {
        if(it->isCake==true)
            mp[it->posx][it->posy].message+=5;
        else
            mp[it->posx][it->posy].message+=2;
    }
    return;
}

inline void Move()
{
    list<antNode>::iterator it;
    for(it=antList.begin();it!=antList.end();it++)
    {
        int pos;
        int ccMaxMessage=0;
        int chooseCount=0;
        for(int i=0;i<4;i++)
        {
            int ccx=it->posx+dirx[i],ccy=it->posy+diry[i];
            if(mp[ccx][ccy].canMove==true&&(ccx!=it->prex||ccy!=it->prey)&&ccx>=0&&ccx<=n&&ccy>=0&&ccy<=m)
            {
                if(mp[ccx][ccy].message==ccMaxMessage)
                {
                    pos=i;
                    chooseCount++;
                }
                else if(mp[ccx][ccy].message>ccMaxMessage)
                {
                    ccMaxMessage=mp[ccx][ccy].message;
                    pos=i;
                    chooseCount=1;
                }
            }
        }
        if(chooseCount==0)
        {
            it->prex=it->posx;
            it->prey=it->posy;
            continue;
        }
        else if(chooseCount>1)
        {
            for(pos=0;pos<4;pos++)
            {
                int ccx=it->posx+dirx[pos],ccy=it->posy+diry[pos];
                if(mp[ccx][ccy].canMove==true&&(ccx!=it->prex||ccy!=it->prey)&&ccx>=0&&ccx<=n&&ccy>=0&&ccy<=m&&mp[ccx][ccy].message==ccMaxMessage)
                    break;
            }
        }
        if((it->age+1)%5==0)
        {
            for(int i=0;i<4;i++)
            {
                pos--;
                if(pos<0)
                    pos+=4;
                int ccx=it->posx+dirx[pos],ccy=it->posy+diry[pos];
                if(mp[ccx][ccy].canMove==true&&(ccx!=it->prex||ccy!=it->prey)&&ccx>=0&&ccx<=n&&ccy>=0&&ccy<=m)
                    break;
            }
        }
        it->prex=it->posx;
        it->prey=it->posy;
        it->posx+=dirx[pos];
        it->posy+=diry[pos];
        mp[it->prex][it->prey].canMove=true;
        mp[it->posx][it->posy].canMove=false;
    }
    return;
}

inline void GetCake()
{
    list<antNode>::iterator it;
    for(it=antList.begin();it!=antList.end();it++)
    {
        if(it->posx==n&&it->posy==m&&cakeBeTaken==false)
        {
            cakeBeTaken=true;
            it->isCake=true;
            it->HP=min(it->HP+(int)(floor)((double)it->maxHP/2.0),it->maxHP);
        }
    }
    return;
}

inline void TowerAttack()
{
    list<antNode>::iterator it;
    for(int i=1;i<=s;i++)
    {
        tower[i].haveTarget=false;
        tower[i].minDis=99999999;
        tower[i].haveCakeTarget=false;
        for(it=antList.begin();it!=antList.end();it++)
        {
            double dis=GetDistance(tower[i].x,tower[i].y,it->posx,it->posy);
            if(dis-r<=eps)
            {
                tower[i].haveTarget=true;
                if(it->isCake)
                {
                    tower[i].haveCakeTarget=true;
                    tower[i].target=it;
                }
                else if(dis<tower[i].minDis&&tower[i].haveCakeTarget==false)
                {
                    tower[i].target=it;
                    tower[i].minDis=dis;
                }
            }
            if(tower[i].haveCakeTarget)
                break;
        }
    }
    for(int i=1;i<=s;i++)
    {
        if(tower[i].haveTarget==false)
            continue;
        if(tower[i].haveCakeTarget==false)
            tower[i].target->HP-=d;
        else
        {
            Point A=TurnPoint(tower[i].target->posx,tower[i].target->posy);
            Point B=TurnPoint(tower[i].x,tower[i].y);
            for(it=antList.begin();it!=antList.end();it++)
            {
                if(it->isCake)
                {
                    it->HP-=d;
                    continue;
                }
                Point P=TurnPoint(it->posx,it->posy);
                double QAQDistance=GetPointDistantToSegment(P,A,B);
                if(QAQDistance-0.5<eps)
                    it->HP-=d;
            }
        }
    }
    return;
}

inline void DestoryBody()
{
    bool isErase=false;
    list<antNode>::iterator it;
    for(it=antList.begin();it!=antList.end();it++)
    {
        if(isErase==true)
        {
            it=antList.begin();
            isErase=false;
        }
        if(it->HP<0)
        {
            if(it->isCake)
            {
                it->isCake=false;
                cakeBeTaken=false;
            }
            mp[it->posx][it->posy].canMove=true;
            antList.erase(it);
            antCnt--;
            isErase=true;
        }
    }
    return;
}

inline bool GameOverCheck()
{
    list<antNode>::iterator it;
    for(it=antList.begin();it!=antList.end();it++)
        if(it->isCake==true&&it->HP>=0&&it->posx==0&&it->posy==0)
            return true;
    return false;
}

inline void LastUpdate()
{
    for(int i=0;i<=n;i++)
        for(int j=0;j<=m;j++)
            if(mp[i][j].message)
                mp[i][j].message--;
    list<antNode>::iterator it;
    for(it=antList.begin();it!=antList.end();it++)
        it->age++;
    return;
}

inline void print()
{
    if(nowt==t+1)
        cout<<"The game is going on"<<endl;
    else
        cout<<"Game over after "<<nowt<<" seconds"<<endl;
    list<antNode>::iterator it;
    cout<<antCnt<<endl;
    for(it=antList.begin();it!=antList.end();it++)
        cout<<it->age<<" "<<it->level<<" "<<it->HP<<" "<<it->posx<<" "<<it->posy<<endl;
}

int main()
{
    totalSpawn=0;
    cakeBeTaken=false;
    antCnt=0;
    n=read(),m=read(),s=read(),d=read(),r=read();
    for(int i=1;i<=s;i++)
    {
        tower[i].x=read();
        tower[i].y=read();
        mp[tower[i].x][tower[i].y].canMove=false;
    }
    t=read();
    prepow[1]=1.1;
    for(int i=2;i<=(t/6)+1;i++)
        prepow[i]=prepow[i-1]*1.1;
    for(nowt=1;nowt<=t;nowt++)
    {
        AntSpawn();
        LeaveMessage();
        Move();
        GetCake();
        TowerAttack();
        DestoryBody();
        if(GameOverCheck())
            break;
        LastUpdate();
    }
    print();
    return 0;
}
```

---

## 作者：ReModer (赞：7)

改了两天，~~最后发现打错变量名了~~，终于过了。发篇题解庆祝一下。

对于这种大模拟，理清思路要比写代码重要。题目很善良地理顺了每秒内发生的事及其顺序，推荐写成函数，便于调试。下面分块进行介绍：

## 全局变量
`used[i][j]` 表示 $(i,j)$是否有蚂蚁/塔台。  
`occupy` 表示 蛋糕是否被拿走。  
`fn` 表示 游戏是否结束。  
`n,m,s,r,d,t` 如题意。  
`count` 表示 新蚂蚁的编号
`matrix[i][j]` 表示 $(i,j)$的信息素。

## 蚂蚁
**蚂蚁有关的函数都是结构体里的成员函数**。  
**蚂蚁有关的函数都是结构体里的成员函数**。  
**蚂蚁有关的函数都是结构体里的成员函数**。  
### 群体储存
用一个队列来储存活着的蚂蚁编号。  
首先，所有操作的蚂蚁都是按出生时间早的优先。  
考虑刚出生的蚂蚁会进队尾，单调性不会改变。 
遍历蚂蚁时只要把所有蚂蚁取出再放回，根据**先进先出**原则单调性仍不变。  
因此用队列储存是可行的，但必须确保每次取完活着的蚂蚁。  

### 个体储存
用一个结构体，各变量含义在注释中。  
```cpp
struct Ant{
    bool cake; //是否拿有蛋糕
    int age,x,y,lx,ly; //年龄、坐标、上一位置
    int lev,HP,limit; //等级、当前血量、血量上限
} ant[maxm];
```

### 新生
其实就是赋初始值，设现在是第$count$只蚂蚁，则：  
```cpp
void init(){
    age = x = y = lx = ly = 0;
    lev = (count + 5) / 6;
    HP = limit = 4*(pow(1.1,lev));
    used[0][0] = 1; //不要忘了占洞口位置
}
```

### 分泌信息素
有蛋糕分泌$5$，没有蛋糕分泌$2$。  
```cpp
void secret(){
    if (cake) matrix[x][y] += 5;
    else matrix[x][y] += 2;
}
```

### 移动
这里比较麻烦。首先按 **东 南 西 北 不动** 的顺序构建移动数组：    
```cpp
const int dx[] = {0,1,0,-1,0}; 
const int dy[] = {1,0,-1,0,0};
```

从东开始，顺时针转到北，当且仅当信息素变大时更新方向。  
可以发现 $活动时间 = 年龄+1$。当 $(age+1)%5 == 0$ 时，蚂蚁会以已经确定的方向为基准再逆时针地重新找方向，这时候**不**需要满足信息素最大。  
```cpp
void move(){
    int goal = 4, maxx = -1; //默认不动
    
    //正常移动
    for (int i = 0; i < 4; i++){
        int nx = x + dx[i];
        int ny = y + dy[i];
        if (used[nx][ny] || !inMap(nx,ny) || (nx == lx && ny == ly))
            continue;
        if (matrix[nx][ny] > maxx)
            maxx = matrix[nx][ny],
            goal = i;
    }
    
    //逆时针
    if ((age+1)%5 == 0 && goal < 4){ //叛逆 && 有路 
        for (int i = 1; i <= 4; i++){
            int nx = x + dx[(goal-i+4)%4];
            int ny = y + dy[(goal-i+4)%4];
            if (used[nx][ny] || !inMap(nx,ny) || (nx == lx && ny == ly))
                continue;    
            goal = (goal-i+4)%4; 
            break; //找到一个合法的就退出 
        }
    }
    
    //移动
    lx = x; ly = y; used[lx][ly] = 0; 
    x += dx[goal]; y += dy[goal]; used[x][y] = 1;
}
```

### 扛蛋糕
扛蛋糕时主要判断 蛋糕在不在原位 以及 蚂蚁在不在蛋糕处。  
```cpp
void getCake(){
    if (occupy) return ; 
    if (x == n && y == m){
        cake = occupy = 1;
        HP = min(limit,HP+limit/2); //回血 且 不能超过上限
    }
}
```

### 死亡
死亡要处理两件事：蛋糕归位 尸体消失。  
```cpp
bool die(){
    if (HP >= 0) return false;
    if (cake) occupy = 0; //蛋糕归位
    used[x][y] = 0; //尸体消失
    return true;
}
```

### 输出
按题目要求输出相应信息。
```cpp  
void output(){ 
    printf("%d %d %d %d %d\n",age,lev,HP,x,y);
}
```

## 炮台
**炮台有关的函数都是结构体里的成员函数**。  
**炮台有关的函数都是结构体里的成员函数**。  
**炮台有关的函数都是结构体里的成员函数**。
### 个体储存
用一个结构体，各变量含义在注释中。
```cpp
struct Tower{
    int x,y,tar; //炮台位置、目标蚂蚁的编号
    Tower(int _x = 0, int _y = 0, int _tar = 0) : x(_x), y(_y), tar(_tar) {}
} tower[maxn];
```

### 计算距离
为了保证精度，不进行开方操作。
```cpp
int getDis(int x, int y, int a, int b){
    return pow(x-a,2)+pow(y-b,2);
}
```

### 寻找目标
当目标有蛋糕时，tar为负；    
目标是最近距离时，tar为正；  
范围内没有蚂蚁时，tar为0。  
```cpp
void getTar(){
    int minn = maxm; tar = 0;
    for (int p = 1; p <= q.size(); p++){
        int id = q.front(); 
        q.push(id); q.pop(); 
        if (tar < 0) continue; //目标扛蛋糕就不必再找目标了，不break是确保队列单调性不变
        
        int d = getDis(x,y,ant[id].x,ant[id].y);
        if (d <= r*r && minn > d) tar = id, minn = d; //有更近距离，更新目标
        if (d <= r*r && ant[id].cake) tar = -id; //找到扛蛋糕的，更新目标
    }
}
```

### 判断是否被殃及
本题难点之一：判断线段与圆是否相交。  
大概就是先算圆与直线的距离，若大于$0.5$则肯定不相交。  
接着判交点是否在线段上。其他的大佬讲得很清楚，~~都把我讲会了~~，圆心到线段两端点连线，各自与线段所夹的角若全是锐角，则交点在线段上。
```cpp
bool involved(int id, int tar){
    if (id == tar) return true; //肯定要打目标

    Ant g = ant[tar], p = ant[id]; //g是目标蚂蚁，p是路过的蚂蚁
    int A = 0, B = 0, C = 0; 
    A = g.y-y; B = x-g.x; C = g.x*y - x*g.y; //直线一般式
    
    double dis1 = 1.0*A*p.x+B*p.y+C; dis1 *= dis1; //为确保精度不开方
    double dis2 = 0.25*(A*A+B*B);
    if (dis1 > dis2) return false;
    
    int ang1 = (g.x-x)*(p.x-x)+(g.y-y)*(p.y-y); 
    int ang2 = (x-g.x)*(p.x-g.x)+(y-g.y)*(p.y-g.y);
    return ang1 > 0 && ang2 > 0;
}
```

### 发动攻击
遍历所有活着的蚂蚁，判断是否被攻击即可。  
不难发现若目标是最近的蚂蚁则只有他被攻击。
```cpp
void attack(){
    if (!tar) return ; //没有目标就不攻击
    
    if (tar > 0) ant[id].HP -= d;
    else for (int p = 1; p <= q.size(); p++){
        int id = q.front();
        q.push(id); q.pop();
        if (involved(id,-tar)) //此蚂蚁被殃及
            ant[id].HP -= d;
    }
}
```

## 信息素减少 
没什么好说的，但要注意从0开始，这里被坑了好久。
```cpp
void reduce(){
    for (int i = 0; i <= n; i++)
        for (int j = 0; j <= m; j++)
            if (matrix[i][j]) matrix[i][j]--; 
}
```

## 年龄增加
```cpp
void raise(){
    for (int p = 1; p <= q.size(); p++){
        ant[q.front()].age++;
        q.push(q.front()); q.pop();
    }
}
```

## 输出活着的蚂蚁
```cpp
void output(){
    printf("%d\n",q.size());
    for (int p = 1; p <= q.size(); p++){
        ant[q.front()].output();
        q.push(q.front()); q.pop();
    }
}
```

## 主函数
至此，完成了所有的函数。接下来要做的就是把所有的操作按题目讲的顺序放在一起：
```cpp
int main(){
    scanf("%d%d",&n,&m);
    scanf("%d%d%d",&s,&d,&r);
    for (int i = 1; i <= s; i++){
        int x,y;
        scanf("%d%d",&x,&y); 
        tower[i] = Tower(x,y);
        used[x][y] = 1;
    }
    scanf("%d",&t); 
    
    for (int i = 1; i <= t; i++){
        //蚂蚁出生 
        if (q.size() < 6 && !used[0][0])
            ant[++count].init(), q.push(count);
            
        //分泌信息素 
        for (int p = 1; p <= q.size(); p++){
            ant[q.front()].secret();
            q.push(q.front()); q.pop();
        }
        
        //移动 + 扛蛋糕 
        for (int p = 1; p <= q.size(); p++){
            ant[q.front()].move();
            ant[q.front()].getCake();
            q.push(q.front()); q.pop();
        }
        
        //瞄准 
        for (int p = 1; p <= s; p++)
            tower[p].getTar();
            
        //攻击
        for (int p = 1; p <= s; p++) 
            tower[p].attack();
            
        //死亡
        int l = q.size();
        for (int p = 1; p <= l; p++){
            if (!ant[q.front()].die())  //死了就不用push了
                q.push(q.front());
            q.pop();
        }
        
        //检测游戏结束
        for (int p = 1; p <= q.size(); p++){
            int id = q.front();
            q.push(id); q.pop();
            if (!ant[id].x && !ant[id].y && ant[id].cake)
                fn = 1;
        }
        
        //结束 
        if (fn){
            printf("Game over after %d seconds\n",i); 
            output(); return 0;
        }
        
        //信息素减少 年龄增加
        reduce(); raise(); 
    }
    
    printf("The game is going on\n");
    output();
    return 0;    
}
```


---

## 作者：Troubadour (赞：3)

真是不得不说，这是一道考验耐心、毅力和阅读能力的一道好题。作为紫题大模拟，思维难度和代码实现难度倒不是很高；但是众多细节，或者是一个对题目的误解就足以让你面对屏幕自闭上一整天。

在这里，膜拜考场上做出这道题的大佬们，同时向所有过掉这道题，或者正在努力调这道题的同学们致以敬意。

废话不多说，我们分析分析这道题。

题意：[P2586 [ZJOI2008]杀蚂蚁](https://www.luogu.com.cn/problem/P2586)

（默认大家已经知道题意了）

我们可以得出，需要实现以下操作：
- 产生新蚂蚁；
- 蚂蚁选择方向并移动；
- 蚂蚁抢蛋糕；
- 大炮攻击蚂蚁；
- 清理死亡的蚂蚁；
- 其他琐碎的操作，比如放信息素，大炮 AOE 伤害，蛋糕 buff 等。

毫无疑问，我们需要对这一大堆信息进行维护，写一大堆函数来维护它们。在这里，为了便于实现，我借助了 OOP 的思想来维护这些信息。

因为 OOP 这玩意儿在 OI 中很少专门提及，这里简单说一下（摘自维基百科）：

> 面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的编程典范，同时也是一种程序开发的抽象方针。它可能包含数据、特性、代码与方法。对象则指的是类（class）的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想。

翻译成人话就是，我们把需要跟踪维护的东西作为程序的单元封装起来，并让它们彼此关联，访问并修改信息。

回到这个题。用这样的思想分析一下，得到这些结果：

我要维护的是什么？地图、蚂蚁、炮和蛋糕。好的，蛋糕可以程序中一笔带过。以蚂蚁为例，我们要就需要一个对象来表示蚂蚁的各个方面，比如坐标、生命值、是否持有蛋糕等。是的，这将是基本数据单元——一个表示蚂蚁的各种信息和状态的对象。我需要一些方法来处理该对象。其次，计算机需要一些方法来执行计算，比如减少生命值什么的。最后，蚂蚁要和大炮进行交互，所以我也要有相关的实现。

好的，我们像这样分析，得出了程序的基本框架。接下来就可以愉快的写代码了。

在下面的代码里，我采取了类+对象的写法，本质上和结构体没什么区别。

首先我们对地图造一个类出来。这个类需要存储以下信息：
- 地图上的信息素；
- 地图上的不可达点。

这里，我们把长和宽定义成全局变量。

方便起见，这里把信息素为 $-1$ 的点作为不可达的点。周围一圈直接设成 $-1$，就不用额外考虑边界情况了。

我们需要让它支持以下操作：
- 初始化；
- 每一回合信息素减一；
- 修改信息素数据。

所以，我们可以得到这样一个类：
```cpp
int n, m;
class map
{
private:
	struct node
	{
		struct nodee
		{
			int a[20];
			int&operator[](int x)
			{
				return a[x + 3];
			}
		}a[20];
		nodee&operator[](int x)
		{
			return a[x + 3];
		}
	}g;//因为可能出现负数下标，所以这里需要处理一下。
public:
	map();
	void decrase();//信息素减少
	void init();//初始化
	int &operator()(int x, int y);
}mp;
```

直接给出函数实现代码：
```cpp
map::map()
{
	for (int i = -2;i <= 15;i++)
	{
		for (int j = -2;j <= 15;j++)
		{
			g[i][j] = -1;
		}
	}
}
void map::init()
{
	for (int i = 0;i <= n;i++)
	{
		for (int j = 0;j <= m;j++)
		{
			g[i][j] = 0;
		}
	}
}
int &map::operator()(int x, int y)
{
	return g[x][y];
}
```

每一回合信息素减少的操作后面另外说。

接着，我们写蚂蚁的类。对于一只蚂蚁，我们需要以下数据：

- 蚂蚁的坐标；
- 蚂蚁的年龄、生命值；
- 蚂蚁的 LV 值。（什么，你问 LV 是什么意思？当然是 LOVE 了！）；
- 蚂蚁是否持有蛋糕；
- 蚂蚁上一次的坐标，这一次和上一次所在位置的信息素值。

记下上一次坐标和位置所在信息素值，有两个原因：
1. 蚂蚁所在的位置信息素为 $-1$ ，我们必须开一个变量记下信息素值；
2. 蚂蚁不能走回头路，这些位置也需要置为 $-1$。

同样，我们也要写一堆函数来维护它们。

那么类的框架如下：
```cpp
bool cake;
int cnt;
class ant
{
private:
	bool iscarrying;
	int age;
	int hp;
	int LOVE;
	int x, y, tmpm;//tmpm：当前位置的信息素值。
	int lstx, lsty, lsttmpm;//lsttmpm：上一位置的信息素值。
protected:
	int selectdir(map &mp);
	void carrycake();//背着蛋糕走了
	double calchp();
	void move(map &mp, int dir);
public:
	ant();
	void decrase();//信息素减少
	void release(map &mp);//把信息素放回原位
	void attacked(int atk);//受到攻击
	bool isdead();//判断是否死亡
	void information();//放信息素
	void action(map &mp);
	int &xpos(), &ypos();
	int &getage();
	void output();//输出相关，后面输出蚂蚁信息用的
	bool iscarryingcake();
};
```

考虑实现函数。这里有几个细节要注意：

- 蚂蚁初始年龄是 $0$。
- 若最大的信息素不止一个，则按照东南西北的顺序选择有最多信息素的格点。（就因为这个问题，我调了一整天）
- 当蚂蚁年龄 $\bmod 4=1$ 的时候，我们就需要让它逆时针转，至少转一次。这种情况下，只要找到合适的位置就走。
- 蚂蚁的 Hp 要用浮点数保存。
- 蚂蚁必须在移动之后才能获得蛋糕，其他时间都不行（比如说你在 $(n,m)$ 的位置，然后一轮开炮之后扛蛋糕的那位挂了，蛋糕飞回来，你也不能立刻捡）。

那么我们如何保证蚂蚁不走回头路呢？在前面的声明中，我记录了上一次的位置和信息素，每次选方向之前置为 $-1$，选完方向再改回来即可。

给出实现：
```cpp
ant::ant()
{
	iscarrying = 0,age = 0;
	LOVE = cnt / 6 + 1;cnt++;
	hp = calchp();
	x = y = 0;	tmpm = mp(x, y);
	lstx = lsty = 0,lsttmpm = -1;
	mp(0, 0) = -1;
}
void ant::information()
{
	if (iscarrying)
	{
		tmpm += 5;
	}
	else
	{
		tmpm += 2;
	}
}
void ant::attacked(int atk)
{
	hp -= atk;
}
bool ant::isdead()
{
	return hp < 0;
}
void ant::carrycake()
{
	iscarrying = 1,cake = 0;
	hp = std::min(hp + calchp() / 2.0, calchp());
}
int ant::selectdir(map &mp)
{
	lsttmpm = mp(lstx, lsty);
	mp(lstx, lsty) = -1;//上一次的位置不可达
	int res = 0;
	//////#3
	//////1:E  2:S  3:W  4:N
	struct node
	{
		int dir, val;
		bool operator<(const node x)const
		{
			return val == x.val ? dir<x.dir : val>x.val;
		}
	}a[10];
	for (int i = 1;i <= 4;i++)a[i].dir = i;
	a[1].val = mp(x, y + 1);
	a[2].val = mp(x + 1, y);
	a[3].val = mp(x, y - 1);
	a[4].val = mp(x - 1, y);
	std::sort(a + 1, a + 1 + 4);
	if (a[1].val == -1)//四个方向都是-1，蚂蚁被卡住了
	{
		return 0;
	}
	res = a[1].dir;
	if (age % 5 == 4)//蚂蚁开始逆时针转圈
	{
		int xxx = 5;
		while (xxx--)
		{
			res--;
			if (res == 0)res = 4;
			int xx = x, yy = y;
			if (res == 1)yy++;
			if (res == 2)xx++;
			if (res == 3)yy--;
			if (res == 4)xx--;
			if (mp(xx, yy) != -1)break;
		}
	}
	return res;
}
void ant::move(map &mp, int dir)
{
	mp(lstx, lsty) = lsttmpm;
	release(mp);//先把信息素地图复原
	lstx = x, lsty = y;
	if (dir == 1)y += 1;
	if (dir == 2)x += 1;
	if (dir == 3)y -= 1;
	if (dir == 4)x -= 1;
	tmpm = mp(x, y);
	mp(x, y) = -1;//自己的位置
}
double ant::calchp()//注意，这里要用浮点数来存
{
	double res = 4 * pow(1.1, LOVE);
	return res;
}
void ant::action(map &mp)//一次完整的行动
{
	int dir = selectdir(mp);
	move(mp, dir);
	if (x == n && y == m && cake == 1)cake = 0, carrycake();//如果可以拿蛋糕就拿走，顺便获得buff
}
void ant::release(map &mp)
{
	mp(x, y) = tmpm;
}
void ant::decrase()
{
	tmpm = std::max(tmpm - 1, 0);
}
void ant::output()
{
	printf("%d %d %d %d %d\n", age, LOVE, hp, x, y);
}
int &ant::getage()
{
	return age;
}
bool ant::iscarryingcake()
{
	return iscarrying;
}
int &ant::xpos()
{
	return x;
}
int &ant::ypos()
{
	return y;
}
std::vector<ant*>enemy;
```

根据题意，我们需要时刻保证蚂蚁的行动顺序是按照年龄顺序。那么我们可以把这些蚂蚁依次塞到一个 vector 中，每次从头到尾遍历蚂蚁并进行操作。

再考虑这样一种情况：假如大炮架在蚂蚁窝门口，攻击力还特别高（秒杀），每次出生一只蚂蚁就被打死，持续 $20$ 万次，这种排队枪毙的情况非常占用时空。我们已经利用 vector 避免了每次遍历引起的超时。可以发现，死掉的蚂蚁对后面的操作没有任何贡献，完全可以直接报废掉，考虑动态为每一只蚂蚁分配内存。这样做的一个代价就是，vector 里将不得不存储一堆指针。

现在回过头来说每次的信息素减一的情况，我们分为两步：

1. 地图上，只要是空位，就考虑信息素减 $1$（因为有蚂蚁的地方信息素就是 $-1$）；
2. 每一只蚂蚁的位置上的信息素减 $1$。

那么，代码的实现就是这样：
```cpp
void map::decrase()
{
	for (int i = 0;i <= n;i++)
	{
		for (int j = 0;j <= m;j++)
		{
			if (g[i][j] != -1)g[i][j] = std::max(0, g[i][j] - 1);
		}
	}
	for (std::vector<ant*>::iterator it = enemy.begin();it != enemy.end();it++)
	{
		(*it)->decrase();
	}
}
```

最后，我们再来写大炮的代码。

对于每一台炮，我们都记录下它的坐标、射程和攻击力。

支持的操作很显然了，一个是选择目标，一个是攻击。

根据题意，只要目标在其射程内，塔到目标蚂蚁圆心的连线上的所有蚂蚁（这里“被打到”的判定变成了表示激光的线段与表示蚂蚁的圆有公共点）都会被打到并损 $d$ 格血，所以我们还要判断其他的蚂蚁是否在这一条线上，就需要写一个计算几何模板了。还好还好，蚂蚁最多只有 $6$，直接遍历所有蚂蚁就行。

计算几何模板就不放出来了，整个类的实现如下：
```cpp
class nuclear
{
private:
	int range;
	int x, y;
	int atk;
protected:
	void attack(int target);
	int selecttarget();
public:
nuclear(int _x, int _y, int _atk, int _range);
	void action();
};
nuclear::nuclear(int _x, int _y, int _atk, int _range)
{
	x = _x, y = _y;
	atk = _atk, range = _range;
	mp(x, y) = -1;
}
int nuclear::selecttarget()
{
	int res = -1;
	double dis = 10000;
	for (int i = 0;i < enemy.size();i++)
	{
		double now = GetDis(x, y, enemy[i]->xpos(), enemy[i]->ypos());//GetDis：获取距离
		if (now - 1.0*range <= eps)
		{
			if (enemy[i]->iscarryingcake())
			{
				return i;//优先选择拿着蛋糕的蚂蚁
			}
			else if (now < dis)//不然就选择最近的那个
			{
				dis = now;
				res = i;
			}
		}
	}
	return res;
}
void nuclear::attack(int target)
{
	if (target == -1)return;
	Point A = { (double)x,(double)y }, B = { (double)enemy[target]->xpos(),(double)enemy[target]->ypos() };
	//point：存储相关点的坐标
	enemy[target]->attacked(atk);
	for (int i = 0;i < enemy.size();i++)//判断 AOE 的情况
	{
		if (i == target)continue;
		Point P = { (double)enemy[i]->xpos(),(double)enemy[i]->ypos() };
		if (checkcircle(P, A, B) - 0.5 <= eps)//checkcircle：检测圆和线段是否有交点
		{
			enemy[i]->attacked(atk);
		}
	}
}
void nuclear::action()
{
	attack(selecttarget());
}
std::vector<nuclear>tower;
```

收尾工作就更简单了，直接按照题目给出的顺序模拟就行。因为前面已经实现了这些函数，我们写主函数的时候将会非常轻松愉快。完美。
```cpp
void clear()
{
	for (int i = 0;i < enemy.size();i++)
	{
		if (enemy[i]->isdead())
		{
			if (enemy[i]->iscarryingcake())cake = 1;//如果蚂蚁扛着蛋糕，就把蛋糕传送回去
			enemy[i]->release(mp);//蚂蚁所在位置的信息素
			delete enemy[i];
			enemy.erase(enemy.begin() + i);
			i--;
		}
	}
}
int s, d, r, t;
void end()
{
	for (std::vector<ant*>::iterator it = enemy.begin();it != enemy.end();it++)
	{
		(*it)->output();
	}
	exit(0);
}
void work()
{
	using std::cin;
	cin >> n >> m >> s >> d >> r;
	mp.init();
	for (int i = 1;i <= s;i++)
	{
		int x, y;
		cin >> x >> y;
		mp(x, y) = 1;
		tower.push_back(nuclear(x, y, d, r));
	}
	cin >> t;
	for (int o = 1;o <= t;o++)//一秒开始了
	{
		if (enemy.size() < 6 && mp(0, 0) != -1)
		{
			enemy.push_back(new ant());//首先出生蚂蚁
		}
		for (int i = 0;i < enemy.size();i++)
		{
			enemy[i]->information();//蚂蚁放信息素
		}
		for (int i = 0;i < enemy.size();i++)
		{
			enemy[i]->action(mp);//蚂蚁移动
		}
		for (std::vector<nuclear>::iterator it = tower.begin();it != tower.end();it++)
		{
			it->action();//二营长，开炮！
		}
		clear();//清除掉死亡蚂蚁的尸体
		mp.decrase();//信息素减1
		for (std::vector<ant*>::iterator it = enemy.begin();it != enemy.end();it++)
		{
			if ((*it)->iscarryingcake() && (*it)->xpos() == 0 && (*it)->ypos() == 0)//蚂蚁方条件达成，游戏结束
			{
				printf("Game over after %u seconds\n%d\n", o, enemy.size());
				end();
			}
		}
		for (std::vector<ant*>::iterator it = enemy.begin();it != enemy.end();it++)
		{
			(*it)->getage()++;//所有蚂蚁年龄+1
		}
	}
	printf("The game is going on\n%d\n", enemy.size());
	end();
}
```

时空复杂度：不用那么费尽心思去分析，只要知道绝对不会裂开就是了。

假如你面对一个问题改了好久改不出来，建议看看自己是否没注意到某些细节或者对题面的理解有误。同时，建议采用输出调试。

给出调试的代码吧，这里为了方便，就把所有的类成员全设成了 public，所以可以直接调用。
```cpp
namespace DEBUG//调试的情况下，所有类成员全部设为public
{
	void printmap(int t)//当前地图的信息素
	{
		printf("time:%d\ninformationmap:\n", t);
		map tmp = mp;
		for (std::vector<ant*>::iterator it = enemy.begin();it != enemy.end();it++)
		{
			tmp((*it)->xpos(), (*it)->ypos()) = (*it)->tmpm;
		}
		for (int i = 0;i <= n;i++)
		{
			for (int j = 0;j <= m;j++)
			{
				std::cout << tmp(i, j) << ' ';
			}
			puts("");
		}
		std::cout << "\n-----------------\n-----------------\n";
	}
	void printantpos(int t)//当前蚂蚁的分布情况，序号按照年龄顺序排列。
	{
		printf("time:%d\nantmap:\n", t);
		map tmp;
		tmp.init();
		for (int i = 0;i < enemy.size();i++)
		{
			tmp(enemy[i]->xpos(), enemy[i]->ypos()) = i + 1;
		}
		for (int i = 0;i <= n;i++)
		{
			for (int j = 0;j <= m;j++)
			{
				std::cout << tmp(i, j) << ' ';
			}
			puts("");
		}
		std::cout << "\n-----------------\n-----------------\n";
	}
	void printallants(int t)//所有蚂蚁的详细数据
	{
		printf("time:%d\nmap:\n", t);
		for (std::vector<ant*>::iterator it = enemy.begin();it != enemy.end();it++)
		{
			//tmp((*it)->xpos(), (*it)->ypos()) = (*it)->tmpm;
			printf("id:%d\nlove:%d\nage:%d\nhp:%d\nlstx:%d lsty:%d\n   x:%d    y:%d\niscarryingcake:%d\n-------------------\n",
				(*it)->id + 1, (*it)->love, (*it)->age, (*it)->hp, (*it)->lstx, (*it)->lsty, (*it)->x, (*it)->y, (*it)->iscarryingcake());
		}
		puts("\n----------------------------------------\n");
	}
}
```

彩蛋：
我们记录下了每一只蚂蚁的 LV。LV，也就是 LOVE。但那绝不是 love，而是一个缩写。意思是，暴力指数（level of violence），一种量化你对蚂蚁造成伤害的数值。你杀得越多，这个值就越高，蚂蚁的生命力也就越顽强，干掉一只蚂蚁就越困难，你的计算也就更容易偏离方向，出现错误的结果。

---

## 作者：ejfbdn (赞：3)

说几个(我被坑到的)坑点：

1.最高血量要用浮点数记录(因为回血的计算取得最高血量的一半是最高血量取整前的一半)

2.新生蚂蚁的等级计算/是依据/新生蚂蚁从开局算起是第几个新生蚂蚁而不是时间

嗯。。

总之这题就是要好好读题

然后思维难度大一些的是蚂蚁是否被打中的判定，再小心一下不要写串下标变量一类，倒腾好坐标什么的就差不多了...

对于打中判定（相当于圆和直线相交的判定）：

0.其实我 一开始也不会，我是看着这个博客写出来的https://blog.csdn.net/syz201558503103/article/details/78400858

进入正题

1.首先看线段端点，只要有一头在圆内就肯定相交

2.两头都不在圆内，看圆心到线段所在直线距离

点(x0,y0)到直线(Ax+By+C=0)距离公式:

|Ax0+By0+C|/sqrt(A×A+B×B)

然后设激光为线段AB，A(x1,y1)B(x2,y2)

可推导出AB所在直线的一般式中的A=y1-y2,B=x2-x1,C=x1y2-x2y1

3.为防止圆心到线段所在直线垂线垂足不在线段上，还需要再判断一下

圆心到线段两端点各连一条边，设线段两端点为A,B,圆心为O

则只有在∠OBA和∠OAB都为锐角时才算相交

可以用两个角余弦值的正负判断

然后余弦值可以用cos<b,c>=b·c/|b|×|c|求(b,c为向量)

由于只关心正负，最后只算b·c正负就好了。

比如算∠BAO

b·c=AB·AO=(x2-x1,y2-y1)·(x0-x1,y0-y1)=(x2-x1)(x0-x1)+(y2-y1)(y0-y1)

算∠ABO就把x1全变x2,x2全变x1,y1全变y2,y2全变y1就好了。

最后最好在加个精度控制什么的

最后AC代码:

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
int n,m,t,s,d,r,antcnt,messagemap[11][11],things[11][11],spawnidx,//1--ant,2--tower
//n,m,s,d,r是题目中的nmsdr
//antcnt:存活蚂蚁个数,messagemap:记录信息素,things:记录当前位置是否有蚂蚁或炮台
//spawnidx:从开局算新生了几只蚂蚁 
posdet[7][2],cakealive=1;
struct ant
{
    int age,lvl,health,x,y,alive,cakeon,nowfact;
    //依次为年龄，等级，当前血量，所在坐标，是否存活，是否持有蛋糕，现在朝向
	//1向东,2向南,3向西,4向北,5静止 
    double maxh;//浮点数记录最大血量（坑点之一） 
    bool operator<(struct ant b)const//由题意可知不管什么事情每次总是挑年迈的蚂蚁先操作 
    {
        if(alive!=b.alive)return alive>b.alive;
        return age>b.age;
    }
}ants[10];
struct tower{int x,y,target;}towers[22];
double ksm(int y)
{
    if(y==0)return 1;
    if(y==1)return 1.1;
    double tp=ksm(y>>1);
    if(y&1)return tp*tp*1.1;
    return tp*tp;
}
void spawnant()
{
    if(antcnt<6)
    {
        for(int i=1;i<=6;i++)if(ants[i].alive&&ants[i].x==0&&ants[i].y==0)return;//0,0不能有蚂蚁 
        spawnidx++;//记录好新生蚂蚁自的开局来是第几只蚂蚁 
        for(int i=1;i<=6;i++)
        {
            if(ants[i].alive==0)//如果发现空缺蚂蚁位，将其转生复活(emm...) 
            {
                ants[i].alive=1;
                ants[i].age=0;//年龄从零开始 
                ants[i].lvl=(spawnidx+5)/6;//坑点之一：蚂蚁等级是按蚂蚁生成次序算，不是按蚂蚁生成时间算 
                ants[i].health=floor(ants[i].maxh=ksm(ants[i].lvl)*4.0);
                ants[i].x=ants[i].y=0;
                ants[i].nowfact=5;
                ants[i].cakeon=0;
                things[ants[i].x][ants[i].y]=1;
                antcnt++;
                break;
            }
        }
    }
}
void message(int antidx)//遗留信息素 
{
    if(ants[antidx].alive)
    messagemap[ants[antidx].x][ants[antidx].y]+=(2+ants[antidx].cakeon*3);
}
bool oppo(int a,int b)//判断两个数字代表方向是否相反 
{
    if(a>b)
    {
        int t=a;
        a=b;
        b=t;
    }
    if(b==5)return false;
    return b-a==2;
}
int getfact(int id,int spt)
{
    message(id);//遗留信息素 
    int tprt=5,mxmess=-1;
    for(int f=1;f<=4;f++)//正东开始顺时针转 
    {
        if(oppo(f,ants[id].nowfact))continue;//和以前的方向反着来会回去 
        int fx=ants[id].x+posdet[f][0],fy=ants[id].y+posdet[f][1];
        if(fx<0||fx>n||fy<0||fy>m)continue;//不能出边界 
        if(things[fx][fy])continue;//不能踩在蚂蚁或塔上 
        if(messagemap[fx][fy]>mxmess)//选择信息素最多 
        {
            mxmess=messagemap[fx][fy];
            tprt=f;
        }
    }//如果四面碰壁tprt就不会更新，就会变为5，也就是蚂蚁被卡住不动的情况 
    if(spt&&tprt!=5)//每5s的特殊行动 
    {
        for(int de=1;de<=4;de++)
        {
            tprt=(tprt+2)%4+1;//朝向逆时针90 
            if(oppo(ants[id].nowfact,tprt))continue;//不能回去 
            int fx=ants[id].x+posdet[tprt][0],fy=ants[id].y+posdet[tprt][1];
            if(fx<0||fx>n||fy<0||fy>m)continue;//不出边界 
            if(things[fx][fy])continue;//不能有东西阻挡 
            break;//转到第一个合法位置结束 
        }
    }
    return tprt;
}
void move()
{
    std::sort(ants+1,ants+7);//年龄大的先移动 
    for(int i=1;i<=6;i++)
    {
        if(!ants[i].alive)continue;
        ants[i].nowfact=getfact(i,!((ants[i].age+1)%5));//获取移动方向 
        things[ants[i].x][ants[i].y]=0;//移动 
        ants[i].x+=posdet[ants[i].nowfact][0];
        ants[i].y+=posdet[ants[i].nowfact][1];
        things[ants[i].x][ants[i].y]=1;
    }
}
void trycake()
{
    if(cakealive)//如果蛋糕还在 
    for(int i=1;i<=6;i++)
    {
        if(ants[i].alive)
        {
            if(ants[i].x==n&&ants[i].y==m)//若存在蚂蚁能抬走蛋糕 
            {
                ants[i].cakeon=1;//抬走 
                ants[i].health+=floor(ants[i].maxh/2.0);//回血 
                cakealive=0;//有的蛋糕还活着，但它已经死了 
                if(ants[i].health>floor(ants[i].maxh))ants[i].health=floor(ants[i].maxh);
                break;
            }
        }
    }
}
int getdis2(int x1,int y1,int x2,int y2){return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);}//获取欧式距离的平方 
double eps=1e-8;
int seg(double nu)
{
    if(nu<-eps)return -1;
    if(nu>eps)return 1;
    return 0;
}
bool damagejudge(int tid,int aid)//判断有没有打到(直线与圆的相交判定) 
{
    int bex=towers[tid].x,bey=towers[tid].y;//直线起始位置是激光塔位置 
    int enx=ants[towers[tid].target].x,eny=ants[towers[tid].target].y;//终止位置是瞄准位置 
    int tax=ants[aid].x,tay=ants[aid].y;//被判断是否扣血的蚂蚁!=被瞄准的蚂蚁 
    //坑点之一:代表蚂蚁的圆的直径是1！！！【所以半径是0.5】 
    if(seg(sqrt((double)getdis2(bex,bey,tax,tay))-0.5)<=0)return true;//只要线段有一头进了圆一定是打到了 
    if(seg(sqrt((double)getdis2(enx,eny,tax,tay))-0.5)<=0)return true;
    //if(bex==enx&&bey==eny)return false;
    double dis=0,a=bey-eny,b=enx-bex,c=bex*eny-enx*bey;//否则看线段所在直线与圆间距 
    dis=abs(a*tax+b*tay+c)/sqrt((double)a*a+b*b);
    if(seg(dis-0.5)>0)return false;
    double ang1=(enx-bex)*(tax-bex)+(eny-bey)*(tay-bey);//防止出现圆心到直线垂线不在线段上的情况 
    double ang2=(bex-enx)*(tax-enx)+(bey-eny)*(tay-eny); 
    return seg(ang1)>0&&seg(ang2)>0;
}
void attack()
{
    std::sort(ants+1,ants+7);//题意可知防御塔是喜欢先欺负先辈的屑 
    for(int i=1;i<=s;i++)//确定每一个防御塔瞄准的蚂蚁 
    {
        int mx=2000000000,pos=0;
        for(int j=1;j<=6;j++)
        {
            int disd=getdis2(ants[j].x,ants[j].y,towers[i].x,towers[i].y);
            if(ants[j].alive==0)continue;//不打死的 
            if(disd>r*r)continue;//射程之外瞄不到 
            if(ants[j].cakeon)//先打有蛋糕的 
            {
                pos=j;
                break;
            }
            if(mx>disd)//否则挑近的打 
            {
                mx=disd;
                pos=j;
            }
        }
        towers[i].target=pos;//定下目标 
    }
    for(int i=1;i<=s;i++)//枚举所有塔 
    {
        if(towers[i].target==0)continue;//没有能打到的目标就跳过 
        for(int j=1;j<=6;j++)
        {
            if(ants[j].alive==0)continue;//不打死的(但允许鞭尸当前秒的蚂蚁) 
            if(damagejudge(i,j))ants[j].health-=d;//如果激光碰到蚂蚁扣血 
        }
    }
}
void deathjudge()
{
    for(int i=1;i<=6;i++)
    if(ants[i].alive)
    {
        if(ants[i].health<0)//有的蚂蚁活着，但它已经死了 
        {
            ants[i].alive=0;
            things[ants[i].x][ants[i].y]=0;//死蚂蚁请出地图 
            if(ants[i].cakeon)//归还蛋糕 
            {
                ants[i].cakeon=0;
                cakealive=1;
            }
            antcnt--;
        }
    }
}
bool failjudge()
{
    if(cakealive)return false;
    for(int i=1;i<=6;i++)//枚举所有蚂蚁，若存在活着且有蛋糕且在蚁窝的蚂蚁就凉了 
    if(ants[i].alive&&ants[i].cakeon&&ants[i].x==0&&ants[i].y==0)
    return true;
    return false;
}
void dessage(){for(int i=0;i<=n;i++)for(int j=0;j<=m;j++)messagemap[i][j]-=(bool)messagemap[i][j];}//没什么好说的吧 
void ageupdate(){for(int i=1;i<=6;i++)if(ants[i].alive)ants[i].age++;}//没什么好说的吧 
int main()
{
    posdet[1][0]=0,posdet[1][1]=1;
    posdet[2][0]=1,posdet[2][1]=0;
    posdet[3][0]=0,posdet[3][1]=-1;
    posdet[4][0]=-1,posdet[4][1]=0;
    posdet[5][0]=0,posdet[5][1]=0;//初始化位移数组 
    //freopen("antbuster_ex.in","r",stdin);
    //freopen("antbuster_ex.out","w",stdout);
    scanf("%d%d",&n,&m);
    scanf("%d%d%d",&s,&d,&r);
    for(int i=1;i<=s;i++)
    {
        scanf("%d%d",&towers[i].x,&towers[i].y);//输入塔坐标 
        things[towers[i].x][towers[i].y]=2;
    }
    scanf("%d",&t);
    int i,fail=0;
    for(i=1;i<=t;i++)
    {
        spawnant();//（试图）生成蚂蚁 
        move();//移动 
        trycake();//（试图） 抢蛋糕 
        attack();//防御塔进攻 
        deathjudge();//死亡判断(清理死亡蚂蚁) 
        fail=failjudge();//失败判断 
        if(fail)break;
        dessage();//信息素挥发 
        ageupdate();//涨年龄 
    }
    std::sort(ants+1,ants+7);//排序输出 
    if(fail)//fl=true,失败
    printf("Game over after %d seconds\n",i);
    else printf("The game is going on\n");
    printf("%d\n",antcnt);
    for(int i=1;i<=6;i++)
    if(ants[i].alive)printf("%d %d %d %d %d\n",ants[i].age,ants[i].lvl,ants[i].health,ants[i].x,ants[i].y);
    return 0;
}
```

---

## 作者：Aoki_灏 (赞：3)

打个广告[此处观感更佳](https://aokiumi.github.io/2018/11/05/%E9%A2%98%E8%A7%A3%EF%BC%9ABZOJ1033%20%E6%9D%80%E8%9A%82%E8%9A%81/)

NOIP考前想练一下码力就挑了一道不算非常难的大模拟来写了一下。

首先，因为此题题面过长就不放题目

原题请去[Link](https://www.lydsy.com/JudgeOnline/problem.php?id=1033)

ps：因为一开始打的代码非常丑，还很繁复所以部分借鉴了一下黄学长的写法见谅。我的代码也是对着黄学长的std步步输出才调出来的，因为一些很智障的错误调了一年。。。

**代码又臭又长注意** 

**不过此题解不压行，思路清晰好评！** 

# 坑点

- 原题描述如下 

​  “ 激光塔有个比较奇怪的特性：它在选定了打击目标后，
只要目标在其射程内，塔到目标蚂蚁圆心的连线上的所有蚂蚁

（这里“被打到”的判定变成了表示激光的线段与表示蚂蚁的圆有公共
点）都会被打到并损d格血，
**但激光不会穿透它的打击目标打到后面的蚂蚁。** ”

​      这里就可以清晰的发现这里不仅是要判断直线和圆有没有交点，而是要判断**线段和圆是否有焦点**

​      所以这里的判断函数一定要写对~~否则会调一年，就像我~~

- 注意先判断蚂蚁死了没有，先更新状态再judge是否成功。

- 蚂蚁年龄一开始是0，而存活时间一开始的就是1。

- 所有的炮是同时开炮，所以要先统计一边每个炮台的target再统一扣血。

- 题目中的坐标不是平面直角坐标系中的坐标，是广义OI理解中的行列。。我就写反了。。

- 蚂蚁半径是0.5不是1！！注意

相信注意到这些地方会使你的代码形成更加清晰，~~这可是血的教训~~

# 题解

现在开始放题解。

首先我们看一下美观的主工作函数，

这部分代表了我写题的思路和流程，

下面就按照这些函数的排列顺序依依讲解每个步骤们也是严格按照题目描述来的

```cpp
int work()
{
    birth();
    leave();
    Move();
    take_cake();
    attack();
    kill();
    if(check_win())return 1;
    End();
    return 0;
}
```

## 基本变量

先把每个变量列出来方便理解

```cpp
int n,m,s,H,T,total;
//total场上总蚂蚁的个数，H 炮台伤害——>harm
bool cake_taken=0;//蛋糕现在是否被拿走
double R;//R 炮台射程半径，防止掉精度
int mp[9][9],vis[9][9];//信息素，记录障碍物
int dy1[]={1,0,-1,0},dx1[]={0,1,0,-1};//顺时针
int dy2[]={1,0,-1,0},dx2[]={0,-1,0,1};//逆时针
int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
struct ant
{
    int x,y,age,hp,rk,sur;//坐标，年龄，血量，级别,存活时间
    int pre_x,pre_y;//上一秒所在的坐标
    double mx;//最大血量上限
    bool cake=0,live=0;//是否拿着蛋糕，是否活着
}a[100];
struct point
{
    double x,y;
};
bool cmp_age(ant A,ant B)
{
    return A.age>B.age;
}
struct turret//炮台
{
    int x,y;
}t[100];
```

## 出生

birth函数比较简单，注意每个数值要赋清楚

还有就是存储蚂蚁的方式选择，这是非常重要的！！因为选择方式不当可能会造成写代码很大的困扰。

例如我之前就是每次把死的蚂蚁sort到数组最后，再下一次出生蚂蚁的时候就直接覆盖掉

然而这样会出一些奇怪的问题，对于cnt的控制就有些奇怪的细节。。。反正调了很久没有A

于是后来就换成了每次找到一只死蚂蚁就直接覆盖，所有操作都只针对活着的蚂蚁操作而不是前cnt个这样的，毕竟场上最多也就6只蚂蚁，复杂度不用担心。。

```cpp
void birth()
{
    if(vis[0][0])return;
    for(int i=1;i<=6;i++)
     if(!a[i].live)
    {
        int l=total/6+1;
        a[i].x=a[i].y=a[i].pre_x=a[i].pre_y=0;
        a[i].age=0;a[i].rk=l;
        a[i].mx=(4*pow(1.1,l));
        a[i].hp=(int)(4*pow(1.1,l));
        a[i].sur=1;a[i].cake=0;a[i].live=1;
        vis[0][0]=1;
        total++;
        break;
    }
}
```

就不解释了

## 留标

这个很简单不解释，走流程

```cpp
void leave()
{
    for(int i=1;i<=6;i++)
    if(a[i].live)//每个操作都要判断死活注意。。
    {
        if(!a[i].cake)mp[a[i].x][a[i].y]+=2;
        else mp[a[i].x][a[i].y]+=5;
    }
}
```

## 移动

这是非常麻烦的一个函数，思路一定要清晰，否则非常惨痛。

想了解移动是否正确可以调BZOJ第4组数据，这个是没有攻击操作的，纯移动。数据哪来的？大家都心知肚明就不说了。。

### 思路整理

- 枚举方向时按顺时针直接写好，这样就不用多次判断

- 先扫遍找到信息素最大的一个方向，（不用管有没有多个相同的，因为顺时针枚举相当于已经筛过一遍）

- 再判断时间是否为5的倍数，是就再进行逆时针筛选操作

- 注意清零之前的标记，处理pre_x,pre_y

### 代码

```cpp
int c(int x)
{
    switch(x)
    {
        case 0:return 0;
        case 1:return 3;
        case 2:return 2;
        case 3:return 1;
    }
}
void update(int tx,int ty,int k)
{
    a[k].pre_x=a[k].x;a[k].pre_y=a[k].y;
    vis[a[k].x][a[k].y]=0;
    a[k].x=tx;a[k].y=ty;
    vis[tx][ty]=1;
}
bool judge(int tx,int ty,int i)
{
    if(tx<0||ty<0||tx>n||ty>m||vis[tx][ty]||(tx==a[i].pre_x&&ty==a[i].pre_y))return 1;
    else return 0;
}
void Move()
{
    sort(a+1,a+7,cmp_age);
    for(int i=1;i<=6;i++)
    {
        if(!a[i].live)continue;
        int max_val=-(1<<30);
        int choose_dirtion=-1;
        for(int j=0;j<4;j++)
        {
            int tx=a[i].x+dx1[j],ty=a[i].y+dy1[j];
            if(judge(tx,ty,i))continue;
            max_val=max(max_val,mp[tx][ty]);//找最大值
        }
        for(int j=0;j<4;j++)
        {
            int tx=a[i].x+dx1[j],ty=a[i].y+dy1[j];
            if(judge(tx,ty,i))continue;
            if(max_val==mp[tx][ty]){choose_dirtion=j;break;}//找到最优方向
        }
        if(choose_dirtion!=-1)
        {
            if(a[i].sur%5==0)//时间是否为5的倍数
            {
                int change=c(choose_dirtion)+1;//暴力打表转换
                for(int k=change;k;k++)
                {
                    int j=k%4;
                    if(k==change+4)break;
                    int tx=dx2[j]+a[i].x;
                    int ty=dy2[j]+a[i].y;
                    if(judge(tx,ty,i))continue;
                    update(tx,ty,i);
                    break;
                }
            }
            else//不是直接处理
            {
                int tx=a[i].x+dx1[choose_dirtion],ty=a[i].y+dy1[choose_dirtion];
                update(tx,ty,i);
            }
        }
        else
          a[i].pre_x=a[i].x,a[i].pre_y=a[i].y;

    }
}
```

## 拿物

先注意判断此时是否有蛋糕，且这只蚂蚁是否活着就行。

```cpp
void take_cake()
{
    if(!cake_taken)
    for(int i=1;i<=6;i++)
     if(a[i].live)
         if(a[i].x==n&&a[i].y==m)
        {
            a[i].cake=1;
            a[i].hp=min((int)a[i].mx,a[i].hp+(int)a[i].mx/2);//防止掉精度
            cake_taken=1;
            return;
        }
    
}
```

## 攻击

这又是本题的一个大难点，又很多细节特别是对线段与直线是否有交点的判断。

### 思路整理

- 先按年龄sort一遍

- 先扫一遍判断是否可以攻击目标，不行再根据距离远近选择一个最终目标

- 只有打拿蛋糕的蚂蚁是才会有躺枪的情况，我只写了判断线段两点都在圆外的情况，避免麻烦

关于如何判断交点的问题。

可以看这篇[BLOG](https://blog.csdn.net/syz201558503103/article/details/78400858)

因为这道题只存在两点都在圆外的情况（只算躺枪），所以首先求出直线表达式，用$ax+by+c=0$来表示

用公式算出点到直线的距离

$$
d= \frac {|a \times x_0+b \times y_0 + c|}{\sqrt{a^2+b^2}}
$$

当且仅当$d<=r$时才符合条件


最后判断时再线段上而不是在延长线上有交点，利用线段两个端点与圆心构成的三角形是否是锐角三角形即可。

令端点$A(x_a,y_a)$ ,$B(x_b,y_b)$ 圆心$C(x_0,y_0)$

则
$\overrightarrow{A B} = (x_b-x_a,y_b-y_a)$ 
$\overrightarrow{A O } = (x_0-x_a,y_0-y_a)$ 


$$
\cos\theta =\frac{\overrightarrow{A B} ·\overrightarrow{A O}}{|\overrightarrow{A B}|·|\overrightarrow{A O}|}
$$


满足$\cos\theta $ 大于0，因为向量的模一定使正数，满足

$\overrightarrow{A B} ·\overrightarrow{A O}>0$且$\overrightarrow{B A} ·\overrightarrow{B O}>0$ 就行

### 代码 

判断函数

```cpp
bool Cross(point A,point B,point O)//判断是否有交点的函数
{
    double a,b,c;//ax+by+c=0
    if(A.x==B.x)
        a=1,b=0,c=-A.x;
    else if(A.y==B.y)
        a=0,b=1,c=-A.y;
    else
    {
        a=A.y-B.y;
        b=B.x-A.x;
        c=A.x*B.y-A.y*B.x;
    }
    double dis1=a*O.x+b*O.y+c;dis1*=dis1;//用平方代替sqrt防止掉精
    double dis2=(a*a+b*b)*0.5*0.5;
    if(dis1>dis2)return 0;
    double angle1=(O.x-A.x)*(B.x-A.x)+(O.y-A.y)*(B.y-A.y);//判断余弦
    double angle2=(O.x-B.x)*(A.x-B.x)+(O.y-B.y)*(A.y-B.y);
    if(angle1>0&&angle2>0)return 1;
    return 0;
}
```

过程函数

```cpp
int dist(int x1,int y1,int x2,int y2)
{
    return ((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}
void ATTACK(int t_x,int t_y,int tur,int target)
{
    for(int i=1;i<=6;i++)
     if(a[i].live)
    {
        if(i==target)//避免点在圆内的情况
            a[i].hp-=H;
        else
        {
            if(cake_taken)
             if(Cross((point){t[tur].x,t[tur].y},(point){t_x,t_y},(point){a[i].x,a[i].y}))
                a[i].hp-=H;

        }
    }
}
void attack()
{
    sort(a+1,a+7,cmp_age);
    int goal[30];
    memset(goal,0,sizeof(goal));
    for(int i=1;i<=s;i++)
    {
        int min_dis=(1<<30);
        for(int j=1;j<=6;j++)
            if(a[j].live)
        {
            int d=dist(t[i].x,t[i].y,a[j].x,a[j].y);
            if(d<=R*R)
            {
                if(a[j].cake)goal[i]=j;//先找target
                else if(!a[goal[i]].cake&&d<min_dis)//再根据距离判断
                    {min_dis=d,goal[i]=j;}
            }
        }

    }
    for(int i=1;i<=s;i++)
        if(goal[i])
           ATTACK(a[goal[i]].x,a[goal[i]].y,i,goal[i]);//逐个击破

}
```

## 击杀

真· 杀蚂蚁啦~~

```cpp
void kill()
{
    int kill_num=0;
    for(int i=1;i<=6;i++)
    if(a[i].live)
        if(a[i].hp<0)
    {
        vis[a[i].x][a[i].y]=0;
        if(a[i].cake)a[i].cake=cake_taken=0;//注意归零
        a[i].live=0;
    }
}
```

## 赢局

直接check没什么说的

```cpp
int check_win()
{
    for(int i=1;i<=6;i++)
        if(a[i].live)//先判断存活
    {
        if(a[i].cake&&a[i].x==0&&a[i].y==0)
            return 1;
    }
    return 0;
}
```

## 结束

回合结束，土地信息素-- ，蚂蚁年龄增长

```cpp
void End()
{
    for(int i=0;i<=n;i++)
        for(int j=0;j<=m;j++)
        if(mp[i][j])mp[i][j]--;
    for(int i=1;i<=6;i++)
    if(a[i].live)
    {
        a[i].age++;
        a[i].sur++;
    }
}
```

完整代码很丑就不放了

# 总结

- 对于一个300行左右的大模拟，需要耐心，码力，以及永不言弃的调试能力。

- 对于大模拟，唯有输出调试才能解决问题，其中输出一定不要怕写的很繁复，越清晰越好。

例如：

```cpp
        cout<<"******************"<<endl;//用适当星号隔离
        cout<<"ant_id "<<i<<' '<<endl;
        cout<<"ant_hp "<<a[i].hp<<endl;
        cout<<"now_pos "<<a[i].x<<' '<<a[i].y<<endl;
        cout<<"ant_age "<<a[i].age<<endl;
        cout<<"ant_mx "<<a[i].mx<<endl;
        cout<<"ant_cake "<<a[i].cake<<endl;//每个变量名字清晰
```

- 当然在非考场的情况下，与std进行输出调试对拍也是非常不错的找错方法

- 考试就只能自己整理思路从头到尾查一遍错了。。。

最终祝各位NOIP2018rp++！！

QWQ


---

## 作者：miaowey (赞：3)

超级大模拟～～～加上一点小小的一点计算几何，


千万注意读题啊，按照题目所述直接暴力求即可！特别是蚂蚁的移动，啊啊啊，调了好久～～～

myblog: <http://blog.csdn.net/miaomiao\_ymxl/article/details/53715918>








    















        

















```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<iostream>
#include<algorithm>
using namespace std;
#define LL long long
#define pb push_back
#define Set(a, v) memset(a, v, sizeof(a))
#define For(i, a, b) for(int i = (a); i <= (int)(b); i++)
#define Forr(i, a, b) for(int i = (a); i >= (int)(b); i--)
#define MAXN (10+5)
#define MAXP (20+5)
#define INF 0x3f3f3f3f
int rt, n, m, s, d, r;
int tar;
int info[MAXN][MAXN], fx[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
bool hb[MAXN][MAXN], CAKE;
bool pd(int x, int y){
    if(x < 0 || y < 0 || x > n || y > m || hb[x][y]) return false;
    return true;
}
struct Ant{
    int lx, ly, x, y, age, nb, blo, lv;
    bool cake;
    void addxx(){
        info[x][y] += cake? 5: 2;
    }
    void addage(){age++;}
    void move(){
        int mxi = -1, mx, my, mfx;
        For(i, 0, 3){
            int nx = x+fx[i][0], ny = y+fx[i][1];
            if(!pd(nx, ny)) continue;
            if(mxi < info[nx][ny] && (nx!=lx || ny!=ly)){mfx = i, mx = nx, my = ny, mxi = info[nx][ny];}
        }
        if(age%5 == 4 && mxi != -1){
            mxi = -1;
            For(times, 1, 4){
                int i = (mfx-times)%4;
                if(i < 0) i += 4;
                int nx = x+fx[i][0], ny = y+fx[i][1];
                if(!pd(nx, ny)) continue;
                if(mxi < info[nx][ny] && (nx!=lx || ny!=ly)){mfx = i, mx = nx, my = ny, mxi = info[nx][ny]; break;}
            }
        }
        lx = x; ly = y;
        if(mxi < 0) return;
        hb[x][y] = false; hb[mx][my] = true;
        x = mx; y = my;
    }
    void getcake(){
        if(CAKE) return;              
        if(x == n && y == m){
             cake = CAKE = true; 
             blo += (int)nb/2;
             if(blo > nb) blo = nb;
        }
    }
    void print(){
        printf("%d %d %d %d %d\n", age, lv, blo, x, y);
    }
};
Ant ant[MAXN];
int an, ant_tot;
double dist(int x1, int y1, int x2, int y2){
    return sqrt((x1-x2)*(x1-x2)*1.0 + 1.0*(y1-y2)*(y1-y2));
}
void kill(int tp){
    Ant tmp;
    For(i, tp+1, an) ant[i-1] = ant[i];
    an--;  
}
void lose(){
    For(i, 0, n) For(j, 0, m) 
            if(info[i][j]) info[i][j]--;
}
//
struct Point{
    double x, y;
    Point(double x=0, double y=0):x(x), y(y){};
};
typedef Point Vector;
const double eps = 1e-10;
int dcmp(double x){
    if(fabs(x) < eps) return 0;
    return x < 0? -1: 1;
}
Vector operator -(Point A, Point B){return Vector(A.x-B.x, A.y-B.y);}
double Dot(Vector A, Vector B){return A.x*B.x+A.y*B.y;}
double Length(Vector A){return sqrt(Dot(A, A));}
double Cross(Vector A, Vector B){return A.x*B.y-A.y*B.x;};
double DistanceToSegment(Point P, Point A, Point B){
    Vector v1 = B-A, v2 = P-A, v3 = P-B;
    if(dcmp(Dot(v1, v2)) < 0) return Length(v2);
    else if(dcmp(Dot(v1, v3)) > 0) return Length(v3);
    else return fabs(Cross(v1, v2)) / Length(v1);
}
//
struct node{
    int x, y;
    void attack(){
        if(!CAKE || dist(ant[tar].x, ant[tar].y, x, y)-1.0*r > 1e-10){
            double dis, mind = INF*1.0;
            int anum;
            For(i, 1, an)
                if((dis = dist(ant[i].x, ant[i].y, x, y))-1.0*r <= 1e-10){
                    if(dis < mind){mind = dis; anum = i;}
                }
            if(mind > r) return;
            ant[anum].blo -= d;
            return;
        }
        Point A = (Point){ant[tar].x, ant[tar].y}, B = (Point){x, y};
        For(i, 1, an){
            if(ant[i].cake){
                ant[i].blo -= d;
                continue;
            }
            Point P = (Point){ant[i].x, ant[i].y};
            if(DistanceToSegment(P, A, B)-0.5 <= 1e-10) ant[i].blo -= d;
        }
    }
};
node bomb[MAXP];
double make(int cnt){
    double ret = 1;
    For(i, 1, cnt) ret *= 1.1;
    return ret;
}
void born(){
    if(an == 6 || hb[0][0]) return;
    an++; ant_tot++; hb[0][0] = true;
    int lv = 1+(ant_tot-1)/6;
    int blood = (int)(1.0*4*make(lv)); 
    Ant newa = (Ant){-1, -1, 0, 0, 0, blood, blood, lv, 0};
    ant[an] = newa;
}
bool game_over(){
    if(!CAKE) return false;
    For(i, 1, an)
        if(ant[i].x == 0 && ant[i].y == 0 && ant[i].cake) return true;
    return false;
}
void checkDead(){
    For(i, 1, an)
        if(ant[i].blo < 0){
            if(ant[i].cake) CAKE = false, tar = 0;
            hb[ant[i].x][ant[i].y] = false;
            kill(i); i--;
        }
}
int main(){
    scanf("%d%d%d%d%d", &n, &m, &s, &d, &r);
    For(i, 1, s){
        scanf("%d%d", &bomb[i].x, &bomb[i].y);
        hb[bomb[i].x][bomb[i].y] = true;
    }
    int t;
    bool going = true;
    scanf("%d", &t);
    for(rt = 1; rt <= t; rt++){
        born();
        For(i, 1, an) ant[i].addxx();
        For(i, 1, an) ant[i].move();
        For(i, 1, an){
            ant[i].getcake();
            if(ant[i].cake) tar = i;
        }
        if(!CAKE) tar = 0;
        For(i, 1, s) bomb[i].attack();
        checkDead();
        if(game_over()){
            going = false;
            printf("Game over after %d seconds\n", rt);
            break;
        }
        For(i, 1, an) ant[i].addage();
        lose();
    }
    if(going) printf("The game is going on\n");
    printf("%d\n", an);
    For(i, 1, an) ant[i].print();
    return 0;
}

```

---

## 作者：saligia (赞：2)

~~我是不会告诉你们这道题我肝了三天之久~~

(楼上各位大佬的代码各显神通，所以就不在这里放完整代码了)

## 下面来讲一讲我对这道题每一个部分的理解吧qwq

（挑选食用效果更佳w）

### 1-0 关于蚂蚁

#### 1-1 蚂蚁的出生：

蚂蚁出生很好写，把需要维护的信息考虑全就行，对于每只蚂蚁，我们需要以下信息，还有要注意只有当前蚂蚁数量小于6并且（0,0）没有蚂蚁时才能出生：

```cpp
struct ant{
	int x,y,prex,prey;//当前位置与上一步位置 
	int old;//年龄 
	int base;//等级 
	int rest;//血量 
	bool die,cake;//是否死亡，是否拿到蛋糕 
	double maxx;//最大血量 
}a[200005];
```

然后蚂蚁出生：

```cpp
void appear(){
	mp[0][0]=1;tot++;numant++;
	a[tot].x=0;a[tot].y=0;a[tot].base=(tot-1)/6+1;
	double Health=floor(4*pow(1.1,a[tot].base));
	a[tot].rest=(int)Health;a[tot].maxx=Health;
	a[tot].die=0;a[tot].old=0;a[tot].cake=0;
	a[tot].prex=a[tot].prey=-1;
}
```

这里的坑点在于需要用一个double去维护最高血量，不然在以后计算时会掉精度

还有一个坑点是蚂蚁的初始年龄是0

#### 1-2 蚂蚁留下信息素：

虽然这里只要写一个for循环就行了，但是我建议在写这种码量很大的代码时，将每一步函数化，这样就会清楚的知道自己在干什么，毕竟思路清楚是最重要的xd（太简单就不放代码了）

#### 1-3 蚂蚁拿蛋糕：

同样很easy，这里CAKE记录蛋糕是否在原位，target记录惨遭集火的蚂蚁qwq

```cpp
void getcake(){
	if (!CAKE) return;
	for (int i=1;i<=tot;++i){
		if (a[i].die) continue;//逝者长眠
		if (a[i].x==n && a[i].y==m){//就位 
			CAKE=0;target=i;//蛋糕消失，成为目标 
			a[i].cake=1;a[i].rest+=(int)(a[i].maxx/2);//保证精度 
			a[i].rest=min(a[i].rest,(int)a[i].maxx);//不能暴血 
			return;
		}
	}
}
```

#### 1-4 蚂蚁死亡：

在炮塔攻击后需要的打扫战场工作，血量小于0的记录死亡，如果有蛋糕记得归位（同样不贴代码）

#### 1-5 蚂蚁长大：

for循环++old即可（同样不贴，因为重头戏在后面）

#### 1-6 蚂蚁移动：

本题难点之一，难在情况多、代码繁琐，需要注意的：

1.活动时间是5的倍数（叛逆期）的蚂蚁逆时针转动

2.如果不能动一定记得把上一步的位置赋值成当前位置，因为下一步就可以走不动前的那个位置了（被坑过qwq）

3.注意题中“如果此时仍有多种选择……直到找到可以去的方向”这句话，这里的多种选择是指那些信息素最大且相同的位置，而不是能走到的所有位置（被坑过qwq也可能是我语文不好）

（这里我也不贴代码了，因为我写的又蠢又丑，读者可以参考楼上各位大佬的w）

### 2-0 关于炮塔

#### 2-1 确认目标：

由于炮塔是同时开火的，也就意味着会打一些血量已经小于0的蚂蚁，所以要先统一确认目标再统一扣血，当然有集火目标先集火：

```cpp
void look(int i){
	goal[i]=0;
	double mindis=1e9,dis;
	if (target && !a[target].die){//有活着的集火目标 
		dis=dist(towerx[i],towery[i],a[target].x,a[target].y);
		if (dis-r<=eps){goal[i]=target;return;}//在射程内 
	}
	for (int j=1;j<=tot;++j){
		if (a[j].die) continue;//逝者长眠 
		dis=dist(towerx[i],towery[i],a[j].x,a[j].y);
		if (dis-r<=eps && dis<mindis) mindis=dis,goal[i]=j;
	}
}
```

#### 2-2 意大利炮式无情打击：

这里有个显然的事情，只有在打蛋糕蚂蚁时才有可能波及到一些躺枪的蚂蚁，不然一定会选择更近的蚂蚁

```cpp
void shoot(int tow,int at){
	for (int i=1;i<=tot;++i){
		if (a[i].die || i==at) continue;
		if (online(tow,at,i)) a[i].rest-=d;//无辜躺枪 
	}
}
```

#### 2-3 判断是否躺枪：

本题难点之二，难在需要一些数学知识

（先声明，这里借用了楼上一位大佬的思路，很巧妙）

我们设炮塔位置A，蛋糕蚂蚁位置B，无辜躺枪者位置C

先特判如果C就是蛋糕蚂蚁就直接打

然后如果C到AB距离大于0.5就不在这条线上，这里要用到点到直线距离公式（我默认直线方程的A、B、C读者都会求）：

```cpp
inline double calc(double X,double Y,double A,double B,double C){
	return (abs(A*X+B*Y+C))/(sqrt(A*A+B*B));
}
```

这时我们注意到，这是一条线段，而不是直线，所以C一定要在A、B之间才会躺枪。一个巧妙的判断方法：AB经过圆C，当且仅当∠CAB和∠CBA都是锐角（画个图就明白了）

```cpp
	int cos1,cos2;
	cos1=(tx-cx)*(nowx-cx)+(ty-cy)*(nowy-cy);
	cos2=(cx-tx)*(nowx-tx)+(cy-ty)*(nowy-ty);
	if (cos1>0 && cos2>0) return true;
```

因为这里是通篇思路，不可能讲清楚每一个细节，希望读者不仅仅要看懂，还要自己亲身去实践，这样才会有提高，具体的可以参考楼上大佬的详解xd

### 3-0 一些idea

1.在你想要无限颓废的时候，可以写一写这样的题to calm down

2.这种题不要觉得没有巧妙的算法与优美的数据结构就不去写他，要知道，代码能力有时比算法与数据结构更加管用，尤其是在OI生涯中，在想崩正解时，如何高效的写出优秀的暴力。算法与数据结构冗杂丰富，不是写一两道题就ok的，但是写一次这种300多行的大模拟，对你的代码能力提高有很大帮助

3.尤其在大赛将至时，可以写一写这种题，一来找手感，二来培养耐心（显然你在大赛中是不能弃疗且自闭的qwq）

4.在你调不出某些点时，千万千万不要放弃，一个小时调不出来就调两个小时，一天调不出来就调两天，弃疗与自闭永远提高你的能力，当你花了十万分精力看到满屏的绿色AC时，你的信心与能力都会有质的飞越

5.还有在你写这种大模拟时，思路是第一位的，先捋清思路再着手代码，争取一气呵成，记住某位神犇说过的话：think twice,code once

最最最后，祝大家OI生涯顺利，noip2018++rp

（一个半小时写的，求管理大大给过啊orz）










---

## 作者：Fengxiang008 (赞：2)

## 题意分析：

这是一道模拟题

代码长度其实还好，主要是细节多

只要知道一些计算几何基础知识即可快乐模拟，按着题目要求一步步实现就行啦

注意仔细读题，蚂蚁每 5 秒乱走一次的时候是只要能走就走了，不一定要信息素最多

还有因为炮台是同时打的，所以目标要提前选好，就算某只蚂蚁被打成负血了，还是会继续被打

蚂蚁初始年龄为 0 ，活动时间是按 1 开始的（看样例就懂了）

我用 set 按年龄维护蚂蚁信息，注意枚举  set 内的蚂蚁时要先把 set 的信息统一取出，不然可能会指针越界

把取出后修改的信息再重新放回 set 即可，具体模拟实现当然还是看代码

## 代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<set>
using namespace std;
typedef long long ll;
typedef double db;
inline int read()
{
    int x=0,f=1; char ch=getchar();
    while(ch<'0'||ch>'9') { if(ch=='-') f=-1; ch=getchar(); }
    while(ch>='0'&&ch<='9') { x=(x<<1)+(x<<3)+(ch^48); ch=getchar(); }
    return x*f;
}
const db eps=1e-6;
const int N=233,xx[4]={0,1,0,-1},yy[4]={1,0,-1,0};
inline int dcmp(db x) { if(fabs(x)<eps) return 0; return x<0 ? -1 : 1; }
int n,m,S,attack,R,T,ant_cnt;
//矩阵长宽,炮台数量,攻击,半径,时间,目前蚂蚁数量
int Map[N][N],Vis[N][N];
//维护地图信息素,维护地图被占用的位置
bool Cake=1,GG;//是否有蛋糕,游戏是否结束
struct Point {
    int x,y;
    Point (int a=0,int b=0) { x=a,y=b; }
    inline bool operator == (const Point &tmp) const { return x==tmp.x&&y==tmp.y; }
    inline Point operator - (const Point &tmp) const { return Point(x-tmp.x,y-tmp.y); }
    inline Point to(int k) { return Point(x+xx[k],y+yy[k]); }
};
inline db Cross(Point A,Point B) { return A.x*B.y-A.y*B.x; }
inline db Dot(Point A,Point B) { return A.x*B.x+A.y*B.y; }
inline db Len(Point A) { return sqrt(Dot(A,A)); }
//以上计算几何板子
inline bool pd(Point P) { return P.x<0||P.x>n||P.y<0||P.y>m||Vis[P.x][P.y]; }//判断位置合法性
struct Ant {//蚂蚁信息
    int blood,age,mxbld,lev;
    //当前血量,年龄,最大生命,等级
    bool target; Point P,pre;
    //是否有蛋糕,当前位置，上一步的位置
    Ant (int c=0,int d=0,int e=0,int f=0,bool h=0,Point A=Point(0,0),Point B=Point(0,0)) {
        blood=c,age=d,mxbld=e,lev=f,target=h; P=A; pre=B;
    }
    void Move()//进行移动
    {
        int X[5],tot=0,mx=0; Vis[P.x][P.y]=0;//原本位置蚂蚁走了
        for(int i=0;i<4;i++)//按方向枚举
        {
            Point t=P.to(i);
            if(pd(t)||t==pre||(tot && Map[t.x][t.y]<mx)) continue;//判断不合法
            if(Map[t.x][t.y]>mx) mx=Map[t.x][t.y],tot=0;//修改合法方向
            X[++tot]=i;
        }
        if(!tot) { pre=P; Vis[P.x][P.y]=1; return; }//判断不可走
        if((age+1)%5) { pre=P; P=P.to(X[1]); Vis[P.x][P.y]=1; return ; }//正常移动
        for(int k=(X[1]+3)%4,i=0;i<4;i++,k=(k+3)%4)//5秒乱走一次
        {
            Point t=P.to(k);
            if(!pd(t)&&!(t==pre))//只要可以走就直接走了
                { pre=P,P=t,Vis[P.x][P.y]=1; return; }
        }
    }
    void try_to_get_cake()//看看能不能得到蛋糕
    {
        if(P.x!=n||P.y!=m||!Cake) return;
        Cake=0; blood=min(mxbld,blood+(mxbld/2)); target=1;
        //得到蛋糕,更新数据
    }
    inline bool operator < (const Ant &tmp) const { return age>tmp.age; }//按年龄排序
}tmp[N];
int tot;//tmp的右端点
set <Ant> ant;
inline db Dis(Point P,Point Q,Point A)
{
    if(dcmp(Dot(A-P,Q-P))<0) return Len(A-P);
    if(dcmp(Dot(A-Q,P-Q))<0) return Len(A-Q);
    return fabs(Cross(A-P,Q-P)/Len(Q-P));
}//同样计算几何板子,求A到线段PQ的距离
struct turret {//炮台
    Point P;//坐标
    void Attack()//进行攻击
    {
        Ant to,A; db mi=N;
        for(int i=1;i<=tot;i++)
        {
            A=tmp[i];
            if(Len(P-A.P)>1.0*R+eps) continue;//太远就没得打
            if(A.target) { to=A; mi=0; break; }//发现有target
            if(Len(P-A.P)+eps<mi) to=A,mi=Len(P-A.P);//找到最近的蚂蚁
        }
        if(int(mi+eps)==N) return;//范围内没有目标
        for(int i=1;i<=tot;i++)
            if(Dis(P,to.P,tmp[i].P)<0.5+eps) tmp[i].blood-=attack;//看看能否波及到其他蚂蚁
    }
}Tur[N];
inline db ksm(db x,int y)
{
    db res=1;
    while(y) { if(y&1) res=res*x; x=x*x; y>>=1; }
    return res;
}
int cnt;//总共出现的蚂蚁数量
void Work()
{
    if(ant_cnt<6&&!Vis[0][0])//当前位置没有蚂蚁才能刷蚂蚁
    {
        Ant New_ant; New_ant.lev=cnt/6+1;
        New_ant.blood=New_ant.mxbld=4.0*ksm(1.1,New_ant.lev);
        New_ant.P=Point(0,0); Vis[0][0]=1;
        ant_cnt++; cnt++; ant.insert(New_ant);//更新一堆数据
    }
    for(auto A: ant)//更新地图信息素
    {
        if(!A.target) Map[A.P.x][A.P.y]+=2;
        else Map[A.P.x][A.P.y]+=5;
    }
    tot=0; for(auto A: ant) tmp[++tot]=A;//取出数据
    for(int i=1;i<=tot;i++)
    {
        ant.erase(tmp[i]),tmp[i].Move();
        tmp[i].try_to_get_cake();//移动并判断得到蛋糕
    }
    for(int i=1;i<=S;i++) Tur[i].Attack();//炮台攻击
    for(int i=1;i<=tot;i++)
    {
        if(tmp[i].blood>=0) ant.insert(tmp[i]);//最后统一插回set
        else { ant_cnt--; Vis[tmp[i].P.x][tmp[i].P.y]=0; if(tmp[i].target) Cake=1; }
        //蚂蚁死了,更新数据,归还蛋糕
    }
    for(auto A: ant) if(A.target&&!A.P.x&&!A.P.y) { GG=1; return; }//判断游戏结束
    for(int i=0;i<=n;i++)
        for(int j=0;j<=m;j++) if(Map[i][j]) Map[i][j]--;//更新信息素
    tot=0; for(auto A: ant) tmp[++tot]=A;
    for(int i=1;i<=tot;i++) ant.erase(tmp[i]),tmp[i].age++;//统一年龄加1
    for(int i=1;i<=tot;i++) ant.insert(tmp[i]);
}
int main()
{
    n=read(),m=read(); S=read(),attack=read(),R=read();
    for(int i=1;i<=S;i++)
    {
        Tur[i].P.x=read(),Tur[i].P.y=read();
        Vis[ Tur[i].P.x ][ Tur[i].P.y ]=1;//炮台不能走
    }
    int Time=read();
    for(int t=1;t<=Time;t++)
    {
        Work();
        if(GG) { printf("Game over after %d seconds\n",t); break; }
    }
    if(!GG) printf("The game is going on\n");
    printf("%d\n",int(ant.size()));
    for(auto A: ant) printf("%d %d %d %d %d\n",A.age,A.lev,A.blood,A.P.x,A.P.y);
    return 0;
}
```


---

## 作者：灵茶山艾府 (赞：1)

对于这道大模拟题，写好变量名可能是最重要的，方便 debug 同时也不会因为敲错导致一些低级错误。

补充一个题面描述：在确定蚂蚁方向时，若最大的信息素不止一个，则按照东南西北的顺序选择**有最多信息素**的格点。

其他的题面已经说清楚了，直接按要求模拟即可。

注意事项：

1. 由于蚂蚁最多只有 6 个，在删除死亡蚂蚁时直接删除数组元素即可。
2. 地图状态的更新：在蚂蚁生成时和死亡时记得设置格点是否为空。


实现逻辑全部写在注释中了。

AC 代码（Golang）:

```go
package main

import (
	. "fmt"
	"math"
)

// 一些常量定义
const (
	eps = 1e-8

	maxAnts              = 6   // 最大蚂蚁数
	antRadius            = 0.5 // 蚂蚁半径
	pheromoneWithoutCake = 2   // 不携带蛋糕时产生的信息素
	pheromoneWithCake    = 5   // 携带蛋糕时产生的信息素
)

// 点
type vec struct {
	x, y int
}

// 线段
type line struct {
	p1, p2 vec
}

// 向量基本运算
func (a vec) add(b vec) vec { return vec{a.x + b.x, a.y + b.y} }
func (a vec) sub(b vec) vec { return vec{a.x - b.x, a.y - b.y} }
func (a vec) len() float64  { return math.Hypot(float64(a.x), float64(a.y)) }
func (a vec) len2() int     { return a.x*a.x + a.y*a.y }
func (a vec) dot(b vec) int { return a.x*b.x + a.y*b.y }
func (a vec) det(b vec) int { return a.x*b.y - a.y*b.x }
func (a line) vec() vec     { return a.p2.sub(a.p1) }

// 点到线段的距离
func (a vec) disToSeg(l line) float64 {
	v, p1a, p2a := l.vec(), a.sub(l.p1), a.sub(l.p2)
	if v.dot(p1a) < 0 {
		return p1a.len()
	}
	if v.dot(p2a) > 0 {
		return p2a.len()
	}
	return math.Abs(float64(v.det(p1a))) / v.len()
}

// 地图格点
type grid struct {
	pheromone int  // 信息素
	empty     bool // 是否为空
}

// 蚂蚁
type ant struct {
	age     int  // 年龄
	level   int  // 等级
	maxHP   int  // 初始血量
	curHP   int  // 当前血量
	prevPos vec  // 上一秒位置
	pos     vec  // 当前位置
	hasCake bool // 是否扛着蛋糕
}

// 炮塔（激光塔）
type tower struct {
	damage   int // 伤害
	atkRange int // 攻击范围
	pos      vec // 位置
}

// 游戏数据
type game struct {
	height, width int      // 长，宽
	board         [][]grid // 地图格点
	antNest, cake vec      // 蚁穴位置，蛋糕位置
	antWithCake   *ant     // 拿着蛋糕的蚂蚁
	antGenCounter int      // 蚂蚁生成计数器
	ants          []*ant   // 蚂蚁
	towers        []*tower // 炮塔
}

// 新游戏
func newGame(height, width int) *game {
	g := &game{height: height, width: width, cake: vec{height, width}}
	g.board = make([][]grid, height+1)
	for i := range g.board {
		g.board[i] = make([]grid, width+1)
		for j := range g.board[i] {
			g.board[i][j].empty = true
		}
	}
	return g
}

// 生成蚂蚁
func (g *game) newAnt() {
	// 如果地图上蚂蚁数不足 6，并且洞口没有蚂蚁，一只蚂蚁就会在洞口出生
	if len(g.ants) < maxAnts && g.board[0][0].empty {
		g.board[0][0].empty = false
		level := g.antGenCounter/6 + 1
		hp := int(4 * math.Pow(1.1, float64(level)))
		a := &ant{level: level, maxHP: hp, curHP: hp}
		g.ants = append(g.ants, a)
		g.antGenCounter++
	}
}

// 移动前，蚂蚁们在自己所在点留下一些信息素
func (g *game) beginSecond() {
	for _, a := range g.ants {
		if a.hasCake {
			g.board[a.pos.x][a.pos.y].pheromone += pheromoneWithCake
		} else {
			g.board[a.pos.x][a.pos.y].pheromone += pheromoneWithoutCake
		}
	}
}

// 格点 p 是否可达
func (g *game) canReach(p vec) bool {
	return 0 <= p.x && p.x <= g.height && 0 <= p.y && p.y <= g.width && g.board[p.x][p.y].empty
}

// 东南西北
var dir4 = [4]vec{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}

// 移动所有蚂蚁
func (g *game) moveAnts() {
	// 蚂蚁按出生的顺序移动，出生得比较早的蚂蚁先移动
	for _, a := range g.ants {
		maxPheromone := -1
		var dirI int
		// 蚂蚁的移动方向为东南西北
		for i, d := range dir4 {
			// 蚂蚁只能移动到空格点上，且不能是上一秒所在的点
			// 如果此时有多个选择，蚂蚁会选择信息素最多的那个点爬过去，
			// 若有多个相同的最多信息素，则按照东南西北的顺序选择有最多信息素的格点
			if p := a.pos.add(d); p != a.prevPos && g.canReach(p) && g.board[p.x][p.y].pheromone > maxPheromone {
				maxPheromone = g.board[p.x][p.y].pheromone
				dirI = i
			}
		}
		// 如果蚂蚁的四周都是不可达点，那么蚂蚁在这一秒内会选择停留在当前点。下一秒判断移动方向时，它上一秒所在点为其当前停留的点
		if maxPheromone == -1 {
			a.prevPos = a.pos
			continue
		}
		// 若此时蚂蚁的年龄为 5n+4，它会在选择方向后不断逆时针转 90°，直到面对一个可达的点，这样定下的方向才是蚂蚁最终要爬去的方向
		if a.age%5 == 4 {
			for dirI = (dirI + 3) % 4; ; dirI = (dirI + 3) % 4 {
				if p := a.pos.add(dir4[dirI]); p != a.prevPos && g.canReach(p) {
					break
				}
			}
		}
		// 更新蚂蚁位置和地图状态
		g.board[a.pos.x][a.pos.y].empty = true
		a.prevPos, a.pos = a.pos, a.pos.add(dir4[dirI])
		g.board[a.pos.x][a.pos.y].empty = false
	}
}

// 如果蛋糕没被扛走并且有蚂蚁在蛋糕的位置上，它把蛋糕扛上，血量增加
func (g *game) checkCake() {
	if g.antWithCake != nil {
		return
	}
	for _, a := range g.ants {
		if a.pos == g.cake {
			a.hasCake = true
			a.curHP += a.maxHP / 2
			if a.curHP > a.maxHP {
				a.curHP = a.maxHP
			}
			g.antWithCake = a
			break
		}
	}
}

// 炮台攻击蚂蚁
func (g *game) towerAttack() {
	// 所有塔同时开始攻击
	for _, t := range g.towers {
		var targetAnt *ant
		// 只有当代表蚂蚁的圆的圆心与塔 t 的直线距离不超过 t.atkRange 时，塔才算打得到那只蚂蚁
		// 如果一只蚂蚁扛着蛋糕，任何**打得到**它的塔的炮口都会对准它
		if g.antWithCake != nil && t.pos.sub(g.antWithCake.pos).len2() <= t.atkRange*t.atkRange {
			targetAnt = g.antWithCake
		} else {
			// 否则塔会挑离它最近的蚂蚁进行攻击，如果有多只蚂蚁，它会选出生较早的一只
			minDis2 := int(1e9)
			for _, a := range g.ants {
				if dis2 := t.pos.sub(a.pos).len2(); dis2 < minDis2 && dis2 <= t.atkRange*t.atkRange {
					minDis2 = dis2
					targetAnt = a
				}
			}
		}
		if targetAnt == nil {
			continue
		}
		// 塔到目标蚂蚁圆心的连线上的所有蚂蚁都会被打到并损失 t.damage 血量，这里“被打到”指表示激光的线段与表示蚂蚁的圆有公共点
		towerToAntSeg := line{t.pos, targetAnt.pos}
		for _, a := range g.ants {
			if a.pos.disToSeg(towerToAntSeg)-eps < antRadius {
				a.curHP -= t.damage
			}
		}
	}

	// 移除死亡蚂蚁
	newAnts := []*ant{}
	for _, a := range g.ants {
		if a.curHP >= 0 {
			newAnts = append(newAnts, a)
		} else {
			// 当蚂蚁的血被打成负数时，它才算挂了
			if a.hasCake {
				// 如果攻击结束后那只扛着蛋糕的蚂蚁挂了，蛋糕瞬间归位
				g.antWithCake = nil
			}
			// 蚂蚁死亡后地图格点需要设置成空
			g.board[a.pos.x][a.pos.y].empty = true
		}
	}
	g.ants = newAnts
}

// 如果发现扛蛋糕的蚂蚁没死并在窝的位置，就认为蚂蚁抢到了蛋糕，游戏结束
func (g *game) isGameOver() bool {
	for _, a := range g.ants {
		if a.hasCake && a.pos == g.antNest {
			return true
		}
	}
	return false
}

// 地图上所有点的信息素损失 1 单位，所有蚂蚁的年龄加 1
func (g *game) endSecond() {
	for i, gi := range g.board {
		for j, gij := range gi {
			if gij.pheromone > 0 {
				g.board[i][j].pheromone--
			}
		}
	}
	for _, a := range g.ants {
		a.age++
	}
}

// 模拟游戏的前 t 秒钟
func (g *game) runSeconds(t int) (gameOverAt int, isGameOver bool) {
	for s := 1; s <= t; s++ {
		g.newAnt()          // 生成蚂蚁
		g.beginSecond()     // 蚂蚁留下信息素
		g.moveAnts()        // 移动蚂蚁
		g.checkCake()       // 更新拿到蛋糕的蚂蚁的状态
		g.towerAttack()     // 炮台攻击蚂蚁
		if g.isGameOver() { // 检查游戏是否结束
			// game over 的时候，这个回合不会对蚂蚁的年龄产生贡献，直接 return
			return s, true
		}
		g.endSecond() // 更新信息素和蚂蚁年龄
	}
	return
}

func main() {
	var height, width, numTower, damage, atkRange int
	Scan(&height, &width, &numTower, &damage, &atkRange)

	// 创建新游戏
	g := newGame(height, width)

	// 放置炮塔
	g.towers = make([]*tower, numTower)
	for i := range g.towers {
		var x, y int
		Scan(&x, &y)
		g.towers[i] = &tower{damage, atkRange, vec{x, y}}
		g.board[x][y].empty = false
	}

	// 模拟游戏的前 t 秒钟
	var time int
	Scan(&time)
	if gameOverAt, isGameOver := g.runSeconds(time); isGameOver {
		Printf("Game over after %d seconds\n", gameOverAt)
	} else {
		Println("The game is going on")
	}
	Println(len(g.ants))
	for _, a := range g.ants {
		Println(a.age, a.level, a.curHP, a.pos.x, a.pos.y)
	}
}
```


---

## 作者：xryjr233 (赞：1)

两个**错误调了一整天...

1.pubp函数括号匹配错了

2.精度常数类型开成了int

就是一个大模拟,别的没什么好讲的,讲一讲我判断圆和线是否有交点的pubp函数,个人认为很容易理解。

~~其实就是不想动脑子才用了简单粗暴的办法~~

我们这样记录一条线段:

当该线段不与$x$轴垂直,我们记录${k,b,l,r}$,表示这条线段所在的直线解析式为$y=kx+b$,$x$坐标的范围为$[l,r]$。

当该线段与$x$轴垂直,我们记录$k,l,r$,表示这条线段所在的直线为$x=k$,$y$坐标的范围为$[l,r]$。

然后我们设点$p(u,v)$,则以$p$为圆心,1为直径($\frac{1}{2}$为半径)的圆的方程为$(x-u)^2+(y-v)^2=\frac{1}{4}$。

我们要求线段和点$p$是否有交点,考虑求线段所在直线和$p$是否有交点,以及是否有交点的坐标在线段的坐标范围内。

当线段不与$x$轴垂直,我们设线段为$k,b,l,r$。

设交点坐标$(x,y)$则有

$kx+b=y$(①)

$(x-u)^2+(y-v)^2=\frac{1}{4}$(②)

展开②式

$x^2-2ux+u^2+y^2-2vy+v^2-\frac{1}{4}=0$

代入$y=kx+b$

$x^2-2ux+u^2+(kx+b)^2-2v(kx+b)+v^2-\frac{1}{4}=0$

$x^2-2ux+u^2+k^2x^2+2bkx+b^2-2vkx-2vb+v^2-\frac{1}{4}=0$

即

$(k^2+1)x^2+(2bk-2vk-2u)x+u^2+b^2-2vb+v^2-\frac{1}{4}$

那么有$x=\frac{-(2bk-2vk-2u)\pm\sqrt{(2bk-2vk-2u)^2-4(k^2+1)(u^2+b^2-2vb+v^2-\frac{1}{4})}}{2(k^2+1)}$

设$pt_1=-(2bk-2vk-2u),pt_2=\sqrt{(2bk-2vk-2u)^2-4(k^2+1)(u^2+b^2-2vb+v^2-\frac{1}{4})},pt_3=2(k^2+1)$

则当$l\le\frac{pt_1+pt_2}{pt_3}\le r$或$l\le\frac{pt_1-pt_2}{pt_3}\le r$时

线段与圆有交点。

当线段与$x$轴垂直,我们设线段为$k,l,r$。

设交点坐标$(k,y)$则有

$(k-u)^2+(y-v)^2=\frac{1}{4}$

$(y-v)^2=\frac{1}{4}-(k-u)^2$

$y=v\pm\sqrt{\frac{1}{4}-(k-u)^2}$

设$pt_1=\sqrt{\frac{1}{4}-(k-u)^2}$

则当$l\le v+pt_1\le r$或$l\le v-pt_1\le r$时

线段与圆有交点。

当然这种做法也有一定的缺点,比如式子比较复杂,容易写错或者出现精度问题。

其余部分直接模拟就好了。

code:

代码不长,刚好130行

使用vector来储存蚂蚁

```cpp
#include<bits/stdc++.h>
#define sqr(x) (x)*(x)
using namespace std;
const double _=1e-7;
const int W[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
struct line{//y=kx+b(l<=x<=r)(tag=0);x=k(l<=y<=r)(tag=1)
	double k,b,l,r;
	int tag;
};
struct point{
	int x,y;
}turret[25];
struct ant{
	point p,lst;
	int hp,mxhp,age,level;
};
bool equ(const double&x,const double&y){
	return abs(x-y)<=_;
}
bool les(const double&x,const double&y){
	return y-x>_;
}
bool eol(const double&x,const double&y){
	return equ(x,y)||les(x,y);
}
double dis(point a,point b){
	return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));
}
line solve(point a,point b){//求出线段ab的表示
	if(a.x==b.x)return(line){a.x,0,min(a.y,b.y),max(a.y,b.y),1};
	else{
		double k=1.0*(a.y-b.y)/(a.x-b.x);
		return(line){k,a.y-k*a.x,min(a.x,b.x),max(a.x,b.x),0};
	}
}
bool pubp(line l,point p){//判断线段l与以点p为圆心,1为直径的圆是否有交点
	if(!l.tag){
		if(sqr(2*l.k*l.b-2*p.y*l.k-2*p.x)-4*(sqr(l.k)+1)*(sqr(p.x)+sqr(l.b)-2*p.y*l.b+sqr(p.y)-1.0/4.0)<0)return false;
		double pt1=-(2*l.k*l.b-2*p.y*l.k-2*p.x),pt2=sqrt(sqr(2*l.k*l.b-2*p.y*l.k-2*p.x)-4*(sqr(l.k)+1)*(sqr(p.x)+sqr(l.b)-2*p.y*l.b+sqr(p.y)-1.0/4.0)),pt3=2*(sqr(l.k)+1);
		return(eol(l.l,(pt1+pt2)/pt3)&&eol((pt1+pt2)/pt3,l.r)||eol(l.l,(pt1-pt2)/pt3)&&eol((pt1-pt2)/pt3,l.r));
	}else{
		if(sqr(l.k-p.x)>1.0/4.0)return false;
		int pt1=sqrt(1.0/4.0-sqr(l.k-p.x));
		return(eol(l.l,p.y+pt1)&&eol(p.y+pt1,l.r))||(eol(l.l,p.y-pt1)&&eol(p.y-pt1,l.r));
	}
}
int n,m,s,d,r,t,ph[10][10],mp[10][10];
int stot,tca=-1;
vector<ant>a;
void getp(point&x){//读入点 
	int t1,t2;
	scanf("%d%d",&t1,&t2),x.x=t1,x.y=t2;
	mp[t1][t2]=1;
}
double POW(double x,int y){//快速幂 
	double tot=1;
	while(y)y&1?tot*=x:0,x*=x,y>>=1;
	return tot;
}
void Spawn(){//生成蚂蚁 
	if(mp[0][0])return;
	for(int i=0;i<a.size();++i)if(a[i].p.x==0&&a[i].p.y==0)return;
	++stot;
	int tmp=(int)(4.0*POW(1.1,(stot+5)/6));
	a.push_back((ant){(point){0,0},(point){0,0},tmp,tmp,0,(stot+5)/6});
}
void Put_pheromone(){//留下信息素 
	for(int i=0;i<a.size();++i)ph[a[i].p.x][a[i].p.y]+=(tca==i?5:2);
}
bool Blank(int x,int y){//判断一个点是否为空(即没有炮塔或者蚂蚁) 
	if(mp[x][y])return false;
	for(int i=0;i<a.size();++i)if(a[i].p.x==x&&a[i].p.y==y)return false;
	return true;
}
bool Check(int id,int x,int y){//判断一个点是否可行 
	return (x!=a[id].lst.x||y!=a[id].lst.y)&&0<=x&&x<=n&&0<=y&&y<=m&&Blank(x,y);
}
void Move_to(int id,int x,int y){//将蚂蚁移动到点(x,y) 
	a[id].lst=a[id].p,a[id].p=(point){x,y};
}
void Move(){//移动蚂蚁 
	for(int i=0;i<a.size();++i){
		int mxp=-1,tw,tx,ty;
		for(int w=0;w<4;++w)tx=a[i].p.x+W[w][0],ty=a[i].p.y+W[w][1],Check(i,tx,ty)&&ph[tx][ty]>mxp?mxp=ph[tx][ty],tw=w:0;
		if(mxp<0){
			a[i].lst=a[i].p;
			continue;
		}else{
			if((a[i].age+1)%5==0)while(tw=(tw+3)%4,!Check(i,a[i].p.x+W[tw][0],a[i].p.y+W[tw][1]));
			Move_to(i,a[i].p.x+W[tw][0],a[i].p.y+W[tw][1]);
		}
	}
}
void Shoot(point u,point v){//从点u发射激光到点v 
	line ray=solve(u,v);
	for(int i=0;i<a.size();++i)if(pubp(ray,a[i].p))a[i].hp-=d;
}
void Attack(){//炮塔攻击 
	for(int i=1;i<=s;++i){
		if(tca!=-1&&eol(dis(turret[i],a[tca].p),(double)r))Shoot(turret[i],a[tca].p);
		else{
			double mnd=r+1,td;int sa;
			for(int j=0;j<a.size();++j)td=dis(turret[i],a[j].p),les(td,mnd)?mnd=td,sa=j:0;
			if(eol(mnd,r))Shoot(turret[i],a[sa].p);
		}
	}
}
void End(int T){//游戏结束 
	printf("Game over after %d seconds\n%d\n",T,a.size());
	for(int i=0;i<a.size();++i)printf("%d %d %d %d %d\n",a[i].age,a[i].level,a[i].hp,a[i].p.x,a[i].p.y);
	exit(0);
}
int main(){
	scanf("%d%d%d%d%d",&n,&m,&s,&d,&r);
	for(int i=1;i<=s;++i)getp(turret[i]);
	scanf("%d",&t);
	for(int Time=1;Time<=t;++Time){
		if(a.size()<6)Spawn();
		Put_pheromone(),Move();
		for(int i=0;i<a.size();++i)if(a[i].p.x==n&&a[i].p.y==m&&tca==-1)tca=i,a[i].hp=min(a[i].mxhp,a[i].hp+a[i].mxhp/2);
		Attack();
		for(int i=0;i<a.size();++i)if(a[i].hp<0)a.erase(a.begin()+i),tca==i?tca=-1:0,tca>i?--tca:0,--i;
		for(int i=0;i<a.size();++i)if(tca==i&&a[i].p.x==0&&a[i].p.y==0)End(Time);
		for(int i=0;i<=n;++i)for(int j=0;j<=m;++j)ph[i][j]?--ph[i][j]:0;
		for(int i=0;i<a.size();++i)++a[i].age;
	}
	printf("The game is going on\n%d\n",a.size());
	for(int i=0;i<a.size();++i)printf("%d %d %d %d %d\n",a[i].age,a[i].level,a[i].hp,a[i].p.x,a[i].p.y);
	return 0;
}
```

---


# [ZJOI2009] 染色游戏

## 题目描述

一共 $n \times m$ 个硬币，摆成 $n \times m$ 的长方形。dongdong 和 xixi 玩一个游戏，每次可以选择一个连通块，并把其中的硬币全部翻转，但是需要满足存在一个硬币属于这个连通块并且所有其他硬币都在它的左上方(可以正左方也可以正上方)，并且这个硬币是从反面向上翻成正面向上。dongdong 和 xixi 轮流操作。如果某一方无法操作，那么他(她)就输了。dongdong 先进行第一步操作，假设双方都采用最优策略。问 dongdong 是否有必胜策略。

## 说明/提示

对于 $40\%$ 的数据，满足 $1 \le n,m \le 5$。

对于 $100\%$ 的数据，满足 $1 \le n,m \le 100，1 \le T \le 50$。

## 样例 #1

### 输入

```
3
2 3
HHH
HHH
2 3
HHH
TTH
2 1
T
H```

### 输出

```
=_=
-_-
-_-```

# 题解

## 作者：BinDir0 (赞：19)

也可以在[我的博客](https://www.cnblogs.com/lost-in-tianyi/p/13687902.html)查看owo

做法另外一篇题解已经说得很清楚了，但似乎没有对于本题 SG 函数正确性的证明，我来口胡一下（



证明：

-------------

猜想：
$$\operatorname{SG}(i,j)=\begin{cases}\operatorname{lowbit}(i+j-1),i=1\lor j=1\\2^{i+j-2},otherwise\end{cases} $$



我们要用到一个结论： 局面的 SG 值等于局面中所有反面朝上的硬币单独存在时的 SG 值的异或和 。然而这个结论我不太会证（）。我们暂且使用它而不证明。



首先当 $i=1\lor j=1$ 成立时，本题相当于一维放硬币问题，其 SG 函数等同于一维的 $lowbit(i)$。因为 $i$ 或 $j$ 中至少有一个是 1，于是我们只需要将横纵坐标相加再 $-1$ 即可消去为 1 的那一维。



对于其他情况我们使用数学归纳法：



首先对于 $\operatorname{SG}(2,2)$ ，有以下几种选择方案（下图中 $0/1$ 代表反转后分别是正面/反面朝上）：

$\begin{matrix} 0&0\\0&0 \end{matrix} ,\operatorname{SG}=0$

$\begin{matrix} 0&1\\0&0 \end{matrix} ,\operatorname{SG}=\operatorname{SG}(1,2)=2$

$\begin{matrix} 0&0\\1&0 \end{matrix} ,\operatorname{SG}=\operatorname{SG}(2,1)=2$

$\begin{matrix} 0&1\\1&0 \end{matrix} ,\operatorname{SG}=\operatorname{SG}(1,2)\space\operatorname{xor}\space \operatorname{SG}(2,1)=0$

$\begin{matrix} 1&1\\0&0 \end{matrix} ,\operatorname{SG}=\operatorname{SG}(1,1)\space\operatorname{xor}\space \operatorname{SG}(1,2)=3$

$\begin{matrix} 1&0\\1&0 \end{matrix} ,\operatorname{SG}=\operatorname{SG}(1,1)\space\operatorname{xor}\space \operatorname{SG}(2,1)=3$

$\begin{matrix} 1&1\\1&0 \end{matrix} ,\operatorname{SG}=\operatorname{SG}(1,1)\space\operatorname{xor}\space SG(1,2)\space\operatorname{xor}\space \operatorname{SG}(2,1)=1$

$\therefore \operatorname{SG}(2,2)=\operatorname{mex}\{0,2,2,0,3,3,1\}=4$，满足猜想。



还有一种特殊情况就是 $i=2\land j>2$ 或 $i>2\land j=2$，不难发现它们是等价的，因此这里我们只以 $i=2\land j>2$ 为例。此时有 $\operatorname{SG}(i,j-1)=2^{i+j-3},\operatorname{SG}(i-1,j)=\operatorname{lowbit}(j)$。由 SG 函数定义有对于左上角为 $(1,1)$，右下角为 $(i,j-1)$ 的不包含右下角的矩形，在其中选择满足题目要求的连通块所得 SG 函数值域取遍 $[0,2^{i+j-3}-1]$。因此在选择 $(i,j-1)$ 一点与上述矩形范围内取连通块可以取遍 $2^{i+j-3}\space\operatorname{xor}\space[0,2^{i+j-3}-1]$ 即 $[2^{i+j-3},2^{i+j-2}-1]$ 范围内的值；可以证明在 $j\ge3$ 时有 $\operatorname{SG}(i-1,j)=\operatorname{lowbit}(j)\le 2^{i+j-4}$ （在 $j=3$ 时有 $\operatorname{lowbit}(3)=1\le 2^{i+j-4}$ ，而在 $j>3$ 时有 $\operatorname{lowbit}(j)\le j \le 2^{j-2}=2^{i+j-4}$），因此在选择 $(i-1,j)$ 一点与上述矩形范围内取连通块可以取遍 $\operatorname{lowbit}(j)\space\operatorname{xor}\space[0,2^{i+j-3}-1]$ 也即 $[0,2^{i+j-3}-1]$ 范围内的值（因为 $\operatorname{lowbit}(j)$ 一位上为 1 的数异或后该位会变成 0，为 0 的数该位会变为 1，值域仍取遍）。做一下 mex 可得 $\operatorname{SG}(i,j)=2^{i+j-2}$，符合猜想。



对于 $i>2\land j>2$ 的 $(i,j)$，由数学归纳法有 $\operatorname{SG}(i,j-1)=\operatorname{SG}(i-1,j)=2^{i+j-3}$，由 SG 函数定义有对于左上角为 $(1,1)$，右下角为 $(i,j-1)$ 的不包含右下角的矩形，在其中选择满足题目要求的连通块所得 SG 函数值域取遍 $[0,2^{i+j-3}-1]$。因此除选择点 $(i,j)$外，在 $(i,j-1),(i-1,j)$ 两点与上述矩形范围内取连通块可以取遍 $[0,2^{i+j-3}-1]$ 范围内的值，在 $(i,j-1)$ 一点与上述矩形范围内取连通块可以取遍 $2^{i+j-3}\space\operatorname{xor}\space[0,2^{i+j-3}-1]$ 即 $[2^{i+j-3},2^{i+j-2}-1]$ 范围内的值，做一下 mex 可得 $\operatorname{SG}(i,j)=2^{i+j-2}$，符合猜想。



证毕。



顺便挂一下代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int T , n , m , sg[110][110] , init() , f[220] , flag;
string s;
inline void init()
{
	for(int i = 1 ; i <= 100 ; i++ ) sg[i][1] = sg[1][i] = log2(i & (-i));
	for(int i = 2 ; i <= 100 ; i++ )
		for(int j = 2 ; j <= 100 ; j++ ) sg[i][j] = i + j - 2;
	return ;
}
int main()
{
	init();
	scanf("%d" , &T);
	while(T--)
	{
		memset(f , 0 , sizeof(f)); flag = 0;
		scanf("%d%d" , &n , &m);
		for(int i = 1 ; i <= n ; i++ )
		{
			cin >> s;
			for(int j = 1 ; j <= m ; j++ )
			{
				if(s[j - 1] == 'T') f[sg[i][j]] ^= 1;
			}
		}
		for(int i = 0 ; i <= 200 ; i++ ) 
		{
			if(f[i])
			{
				flag = 1;
				break;
			}
		}
		if(flag) printf("-_-\n");
		else printf("=_=\n");
	}
	return 0;
}
/*
1
3 4
TTHH
THTH
TTHH
*/

```

---

## 作者：Mr_Wolfram (赞：7)

## 博弈论+SG函数的应用
[蒟蒻博客](http://www.cnblogs.com/Mr-WolframsMgcBox/)

这是一个二维翻硬币问题

一维翻硬币问题有一个结论:

局面的SG值等于局面中所有反面朝上的硬币单独存在时的SG值的异或和

这个结论同样适用于二维的翻硬币问题

证明可以用数学归纳法,这里省去(其实是我不会证)

那么如何求每个硬币单独反面朝上时的SG值,首先考虑递推

然而不会推

那就只好打表找规律

有如下规律:


$$SG(i, j) = \begin {cases}lowbit(i + j - 1), \quad i == 1 || j == 1\\2 ^{ i + j - 2}, \quad i != 1 \&\&j != 1\end{cases}$$

我们发现SG函数值最大可达 2 的 200 次方,无法用```long long ``` 储存

我们可以用 bool 数组 或 bitset 来模拟

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
int T, sg[105][105], n, m, a[10005], cnt, mp[1200];
bool f[300];
int lowbit(int x) {
	return x & (-x);
}
int getsg(int a, int b){
	if(a == 1 || b == 1){
		return mp[lowbit(a + b - 1)];
	}else return a + b - 2;
}
int main() {
	for(int i = 0 ; i <=9 ; i++) {
		mp[(1<<i)] = i;
	}
	cin>>T;
	while(T--) {
		memset(f, 0, sizeof(f));
		cin>>n>>m;
		int ans = 0;
		for(int i = 1 ; i <= n ; i++) {
			for(int j = 1 ; j <= m ; j++) {
				char c ;
				scanf(" %c ", &c);
				if(c !='H'){
					f[getsg(i, j)] ^= 1;
				}
			}
		}
		for(int i = m + n - 1 ; i >= 0 ; i--) if(f[i]) {ans = 1;break;}
		if(ans) printf("-_-\n");
		else printf("=_=\n");
	}
	return 0;
}
```








---

## 作者：xkcdjerry (赞：2)

本题显然是二维翻硬币问题，查一些资料可以拿到一句似懂非懂的话：
> 整个游戏的 SG 值等于所有反面向上硬币分别存在时 SG 值的异或和

由 SG 函数的定义，最后的值如果是 $0$ 输出 `=_=`，否则输出 `-_-`。  
求出单个的 SG 值用暴力解几个只有一个反面的 SG 值，打表发现位置为 $<i,j>$ 的硬币 SG 函数如下：

$$SG(i,j)=\begin{cases}
lowbit(i),&j=1;\\
lowbit(j),&i=1;\\
2^{i+j-2},&i \neq 1 \land j \neq 1
\end{cases}$$

但是由于数据范围是 $n \leqslant 100$ 显然不能直接求异或和（答案最大可能到 $2^{199}-1$），所以要使用数组模拟或者 `bitset`，这里本蒟蒻选用的是 `char` 数组。  

这时候难点就出来了：为了便捷存储 $2^{i+j-2}$ 和 $lowbit(x)$ 是不能直接记录的（否则还是要数组模拟+按位异或能活活慢死），考虑两者都是 $2^k$ 形式可以直接记录 $k$ 的值，减小空间消耗的同时可以只取反第 $k$ 位减小常数。

这时候就出现了一点小问题：写过树状数组的都会知道取得 $lowbit(x)$ 可以便捷的利用 `x&(-x)` 得到，但是要取得对应的 $k$ 还需要一次 `log2`。  
如果使用库函数很耗时间，如果自己写函数/用数组缓存结果，不光写的慢还会导致代码的臃肿。

所以在这里介绍一个内建函数： ~~€€£都说了可以用双下划线开头的函数了不用白不用~~  
`__builtin_ctz(unsigned int x)` 可以计算 `x` 的二进制表示中末尾 $0$ 的个数（假如 `x==0` 结果是未定义的），由于本题中 $i,j$ 均不为 $0$ 可以放心使用。  

代码：~~由于滥用 `memset` 跑了 33ms 实际上 `__builtin_ctz` 是很快的）~~

```c++
#include <cstdio>
#include <cstring>
#define N 110
int f[N][N];
char t[N*2];
int main()
{
    //宣扬__builtin神教（大雾）
    for(int i=1;i<N;i++) f[1][i]=f[i][1]=__builtin_ctz(i);
    for(int i=2;i<N;i++)
        for(int j=2;j<N;j++)
            f[i][j]=i+j-2;
    int T;
    scanf("%d",&T);
    while(T--)
    {
        int n,m;
        scanf("%d%d",&n,&m);
        memset(t,0,sizeof t);
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=m;j++)
            {
                char c;
                scanf(" %c",&c);
                //取反对应位
                if(c=='T') t[f[i][j]]^=1;
            }
        }
        for(int i=m+n;i>=0;i--)
        {
            if(t[i])
            {
                puts("-_-");
                goto end;//goto，永远的神
            }
        }
        puts("=_=");
        end:;
    }
}
```

[记录](https://www.luogu.com.cn/record/59607349)

---

## 作者：jianami (赞：1)

首先给出结论：原游戏的 SG 值等于局面中所有反面朝上硬币单独存在时的 SG 值的异或和。下面简要说明它的正确性：

假设我们已经把原游戏（称为 A 游戏）拆分成了若干个独立的子游戏（称为 B 游戏），则在 B 游戏中，必胜方一定会按照 A 游戏的必胜策略操作，如果必败方走了一步在 A 游戏中不合法的操作，必胜方也一定可以再在 B 游戏中进行一次相同的操作将它“抵消”掉。（画画图可以发现，这一定是可以做到的）

由此我们可以打表观察每个子游戏的 SG。[打表代码](https://www.luogu.me/paste/325t9yqu#)

可以注意到：

$$
SG_{i,j} = \left\{\begin{matrix} 
  \operatorname{lowbit}(j),i = 1 \\
  \operatorname{lowbit}(i),j = 1\\
  2^{i + j - 2},otherwise
\end{matrix}\right. 
$$

答案最大可达 $2^{198}$ 级别，`bitset` 维护即可。

```cpp
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <bitset>
#define int long long
using namespace std;

const int N = 205;

bitset <500> sg[N][N];
int mp[N];

int lowbit(int x){return x & (-x);}

void init(){
    for(int i = 0;i <= 10;i ++) mp[(1 << i)] = i;
    for(int i = 1;i <= 100;i ++) sg[i][1].set(mp[lowbit(i)],1);
    for(int i = 1;i <= 100;i ++) sg[1][i].set(mp[lowbit(i)],1);
    for(int i = 2;i <= 100;i ++){
        for(int j = 2;j <= 100;j ++){
            sg[i][j].set(i + j - 2,1);
        }
    }
}

signed main(){
    string s;init();
    int T;cin >> T;
    while(T --){
        int n,m;cin >> n >> m;
        bitset <500> ans;
        for(int i = 1;i <= n;i ++){
            cin >> s;s = ' ' + s;
            for(int j = 1;j <= m;j ++){
                if(s[j] == 'T') ans ^= sg[i][j];
            }
        }
        if(ans.count() != 0) cout << "-_-\n";
        else cout << "=_=\n";
    }
    return 0;
}
```

---


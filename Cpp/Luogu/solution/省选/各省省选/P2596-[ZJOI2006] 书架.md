# [ZJOI2006] 书架

## 题目描述

小 T 有一个很大的书柜。这个书柜的构造有些独特，即书柜里的书是从上至下堆放成一列。她用 $1$ 到 $n$ 的正整数给每本书都编了号。

小 T 在看书的时候，每次取出一本书，看完后放回书柜然后再拿下一本。由于这些书太有吸引力了，所以她看完后常常会忘记原来是放在书柜的什么位置。不过小 T 的记忆力是非常好的，所以每次放书的时候至少能够将那本书放在拿出来时的位置附近，比如说她拿的时候这本书上面有 $x$ 本书，那么放回去时这本书上面就只可能有 $x-1$、$x$ 或 $x+1$ 本书。

当然也有特殊情况，比如在看书的时候突然电话响了或者有朋友来访。这时候粗心的小 T 会随手把书放在书柜里所有书的最上面或者最下面，然后转身离开。

久而久之，小 T 的书柜里的书的顺序就会越来越乱，找到特定的编号的书就变得越来越困难。于是她想请你帮她编写一个图书管理程序，处理她看书时的一些操作，以及回答她的两个提问：
- 编号为 $x$ 的书在书柜的什么位置。
- 从上到下第 $i$ 本书的编号是多少。


## 说明/提示

### 数据规模与约定

对于 $100\%$ 的数据，保证：
- $3 \leq n, m \leq 8 \times 10^4$。
- $p_i$ 是一个 $1 \sim n$ 的排列。
- $1 \leq s \leq n$，$-1 \leq t \leq 1$，$op$ 只可能是输入的五种字符串之一。
- 当编号为 $s$ 的书上面没有书的时候，不会对它进行 `Insert s -1` 操作。
- 当编号为 $s$ 的书下面没有书的时候，不会对它进行 `Insert s 1` 操作。

## 样例 #1

### 输入

```
10 10
1 3 2 7 5 8 10 4 9 6
Query 3
Top 5
Ask 6
Bottom 3
Ask 3
Top 6
Insert 4 -1
Query 5
Query 2
Ask 2
```

### 输出

```
2
9
9
7
5
3```

# 题解

## 作者：Brave_Cattle (赞：78)

# 无旋treap做法
无旋treap可以维护一棵树的中序遍历结果.但是不支持通过编号来找节点.于是在无旋treap的基础上,我维护了每个节点的父亲,这样就可以求出一个节点是中序遍历中的第几个.

那么对于一个节点,每次将它向树根跳,如果它是右儿子,那么就将它父亲的左子树的值以及父亲的大小计入结果.

那么问题就只有如何记录父亲了.显然会改变父亲的只有$split$和$merge$操作,那么我只需要在这两个函数中修改就可以了.在$split$的时候再传两个参数记录父亲,$merge$在修改儿子的时候同时将父亲一起修改.

其他的都是无旋treap的基本操作了.
* $Top$: 提取该节点,放在树的最前面合并.
* $Bottom$: 提取节点,放在树的最后面合并.
* $Insert$: 将它与前驱/后继从整棵树中分离出来,交换顺序合并.
* $Ask$: 直接通过编号找到节点是中序遍历结果第几个.
* $Query$: 先找到节点是中序遍历第几个,然后split前k个,在分离出的第一颗子树中找最右边的节点.

代码凑合着看一下吧.
```cpp
#include<bits/stdc++.h>
#define debug out(root), cout << endl
using namespace std;
const int N=80000+5;

int n, m, id[N], a[N], root, r1, r2, r3, r4, cnt = 0;
//id记录某一个书的编号映射到树中的节点编号

struct treap{
    int ch[2], fa, size, rd, val;
}t[N];

int gi(){
    int ans = 0, f = 1; char i = getchar();
    while(i<'0' || i>'9'){ if(i == '-') f = -1; i = getchar(); }
    while(i>='0' && i<='9') ans = ans*10+i-'0', i = getchar();
    return ans * f;
}

int newnode(int val){
    t[++cnt].val = val; t[cnt].rd = rand(), t[cnt].size = 1;
    id[val] = cnt; return cnt;
}

void up(int x){ t[x].size = t[t[x].ch[0]].size+t[t[x].ch[1]].size+1; }

void split(int x, int k, int &a, int &b, int faa = 0, int fab = 0){
	//传两个父亲节点的参数是为了防止记录父亲出问题.
    //因为父亲记录儿子的时候是通过取地址传参修改的
    //而两颗子树记录的父亲是分开的
    if(x == 0){ a = b = 0; return; }
    if(k <= t[t[x].ch[0]].size) t[x].fa = fab, b = x, split(t[x].ch[0], k, a, t[x].ch[0], faa, x);
    else t[x].fa = faa, a = x, split(t[x].ch[1], k-t[t[x].ch[0]].size-1, t[x].ch[1], b, x, fab); up(x);
}

int merge(int x, int y){
    if(x == 0 || y == 0) return x+y;
    //直接在记录儿子的时候同时修改父亲
    if(t[x].rd < t[y].rd){
		t[x].ch[1] = merge(t[x].ch[1], y);
		t[t[x].ch[1]].fa = x; up(x); return x;
    }
    else {
		t[y].ch[0] = merge(x, t[y].ch[0]);
		t[t[y].ch[0]].fa = y; up(y); return y;
    }
}

void insert(int pos, int val){
    split(root, pos, r1, r2);
    root = merge(r1, merge(newnode(val), r2));
}

bool get(int x){ return t[t[x].fa].ch[1] == x; }

int find(int cnt){//cnt是节点编号
    int node = cnt, res = t[t[cnt].ch[0]].size+1;
    while(node != root && cnt){
		if(get(cnt)) res += t[t[t[cnt].fa].ch[0]].size+1;
		cnt = t[cnt].fa;
		//这里可以画图理解一下,因为如果该节点是左儿子的话,向上走是中序遍历在增大的
		//如果是右儿子向上跳的话,父亲的左子树的所有节点的中序遍历的结果都小于我在查的节点,所以要计入答案.
    }
    return res;
}

int main(){
    char opt[10]; int x, y, k; n = gi(), m = gi(); srand(19260817);
    for(int i=1;i<=n;i++) a[i] = gi(), insert(i-1, a[i]);
    for(int i=1;i<=m;i++){
		scanf("%s", opt); x = gi();
		
		if(opt[0] == 'T'){
		    k = find(id[x]);//通过节点编号找到书本编号为x的节点是第k个
		    split(root, k, r1, r3);
		    split(r1, k-1, r1, r2);
		    root = merge(r2, merge(r1, r3));
		}
		
		if(opt[0] == 'B'){
		    k = find(id[x]);
		    split(root, k, r1, r3, 0);
		    split(r1, k-1, r1, r2, 0);
		    root = merge(r1, merge(r3, r2));
		}
		
		if(opt[0] == 'I'){
		    y = gi(); k = find(id[x]);
		    if(y){
				if(y > 0){//与前驱/后继交换后插入
				    split(root, k+1, r3, r4);
				    split(r3, k, r2, r3);
				    split(r2, k-1, r1, r2);
				    root = merge(r1, merge(r3, merge(r2, r4)));
				}
				else {
				    split(root, k, r3, r4);
				    split(r3, k-1, r2, r3);
				    split(r2, k-2, r1, r2);
				    root = merge(r1, merge(r3, merge(r2, r4)));
				}
		    }
		}
		
		if(opt[0] == 'A'){
		    k = find(id[x]);
		    printf("%d\n", k-1);
		}
		
		if(opt[0] == 'Q'){
		    split(root, x, r1, r2);
		    int node = r1;
		    while(t[node].ch[1]) node = t[node].ch[1];
		    printf("%d\n", t[node].val);
		    root = merge(r1, r2);
		}
    }
    return 0;
}
```

---

## 作者：FlierKing (赞：68)

平衡树，需支持五个操作：

1、    将某元素置顶：将元素旋到根，然后将左子树合并到该元素的后继

2、    将某元素置底：将元素旋到根，然后将右子树合并到该元素的前驱

3、    将某元素提前/滞后1位：直接与该元素的前驱/后继交换位置及信息

4、    询问指定元素排名：将元素旋到根，输出size-1

5、    询问指定排名元素：在树上find

----------

```cpp
#include <bits/stdc++.h>
#define ll long long
#define MAXN 80005
using namespace std;
    int n,m,num,sz,root,s; 
    int pos[MAXN],size[MAXN],c[MAXN][2],fa[MAXN],v[MAXN];
    char ch[20];
int inline read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void update(int x)
{
    size[x]=size[c[x][0]]+size[c[x][1]]+1;
    pos[v[c[x][0]]]=c[x][0],pos[v[c[x][1]]]=c[x][1];
}
void rotate(int &root,int x){
    int y=fa[x],z=fa[y],p,q;
    if(c[y][0]==x) p=0; else p=1;
    q=p^1;
    if(y==root) root=x;
    else{
        if(c[z][0]==y) c[z][0]=x;
        else c[z][1]=x;
    }
    fa[x]=z;fa[y]=x;fa[c[x][q]]=y;
    c[y][p]=c[x][q];c[x][q]=y;
    update(y);update(x);
}
void splay(int &root,int x){
    int y,z;
    while(x!=root){
        y=fa[x];z=fa[y];
        if(y!=root){
            if((c[z][0]==y) ^ (c[y][0]==x)) rotate(root,x);
            else rotate(root,y);
        }
        rotate(root,x);
    }
    pos[v[x]]=x;
}
void insert(int x)
{
    v[++sz]=x;size[sz]=1;pos[x]=sz;c[sz][0]=c[sz][1]=0;
    if (sz>1)
    {
        c[sz-1][1]=sz;fa[sz]=sz-1;
        splay(root,sz);
    }
}
int find(int x,int k)
{
    int y=c[x][0];
    if (size[y]+1==k) return x;
    else if (size[y]>=k) return find(y,k);
    else return find(c[x][1],k-size[y]-1);
}
void top(int x)
{
    x=pos[x];
    splay(root,x);
    if (!c[x][0]) return;
    if (!c[x][1]) c[x][1]=c[x][0],c[x][0]=0;
    else
    {
        int y=find(root,size[c[x][0]]+2);
        fa[c[root][0]]=y;
        c[y][0]=c[root][0];
        c[root][0]=0;
        splay(root,y);
    }
}
void bottom(int x)
{
    x=pos[x];
    splay(root,x);
    if (!c[x][1]) return;
    if (!c[x][0]) c[x][0]=c[x][1],c[x][1]=0;
    else
    {
        int y=find(root,size[c[x][0]]);
        fa[c[root][1]]=y;
        c[y][1]=c[root][1];
        c[root][1]=0;
        splay(root,y);
    }
} 
void ins(int f,int x)
{
    if (!f) return;
    splay(root,pos[x]);
    int y=find(root,f==1?size[c[pos[x]][0]]+2:size[c[pos[x]][0]]);
    int x1=v[y],x2=pos[x];
    swap(pos[x],pos[x1]);
    swap(v[x2],v[y]);
}
void getans(int x)
{
    splay(root,x);
    printf("%d\n",size[c[x][0]]);
}
void init()
{
    pos[0]=size[0]=c[0][0]=c[0][1]=fa[0]=v[0]=0;
}
int main()
{
//    freopen("test.txt","r",stdin);
    n=read(),m=read();
    root=1;
    for (int i=1;i<=n;i++)
    {
        num=read();
        insert(num);
    }
    while (m--)
    {
        scanf("%s",ch);
        switch(ch[0])
        {
            case 'T':top(read());break;
            case 'B':bottom(read());break;
            case 'I':ins(read(),read());break;
            case 'A':getans(pos[read()]);break;
            case 'Q':printf("%d\n",v[find(root,read())]);break;
        }
    }
    return 0;
}
```
-------------
前面的大佬的题解的代码有些错误，比如这个数据：

10 10
9 5 10 8 6 2 1 4 7 3

A 7
B 7
I 7 0
A 2
I 9 1
T 4
B 1
T 2
A 9
T 10
正确答案应为：

8
5
3

---

## 作者：Cyhlnj (赞：57)

这道题显然平衡树，splay，treap什么的随便切

然而我不想打，决定水过这道题

把空间开3倍，树状数组维护它前面的数的个数，开个id数组记录位置

找一个数排名直接二分加求前缀和，log^2的搞一搞

把一个数放在顶/低  直接丢在当前顶/低的前后就可以了~~不然开3倍数组干嘛~~

常数小堪比log的平衡树~~居然还快一些~~


```cpp
# include <bits/stdc++.h>
# define RG register
# define IL inline
# define Fill(a, b) memset(a, b, sizeof(a))
using namespace std;
typedef long long ll;
const int _(3e5 + 10), INF(2e9), PF(1e5);

IL ll Read(){
    char c = '%'; ll x = 0, z = 1;
    for(; c > '9' || c < '0'; c = getchar()) if(c == '-') z = -1;
    for(; c >= '0' && c <= '9'; c = getchar()) x = x * 10 + c - '0';
    return x * z;
}

int n, m, t[_], id[_], a[_];
char opt[10];

IL void Add(RG int x, RG int v){  for(; x <= PF * 3; x += x & -x) t[x] += v;  }

IL int Query(RG int x){  RG int cnt = 0; for(; x; x -= x & -x) cnt += t[x]; return cnt;  }

IL int Find(RG int x){
    RG int l = 1, r = PF * 3;
    while(l < r){
        RG int mid = (l + r) >> 1;
        if(Query(mid) >= x) r = mid;
        else l = mid + 1;
    }
    return l;
}

int main(RG int argc, RG char *argv[]){
    n = Read(); m = Read();
    for(RG int i = 1; i <= n; ++i) a[PF + i] = Read(), Add(PF + i, 1), id[a[PF + i]] = PF + i;
    while(m--){
        scanf(" %s", opt); RG int x = Read(), y, p, q;
        if(opt[0] == 'T'){
            p = Find(1);
            a[id[x]] = 0; Add(id[x], -1);
            id[x] = p - 1;
            a[id[x]] = x; Add(id[x], 1);
        }
        else if(opt[0] == 'B'){
            p = Find(n);
            a[id[x]] = 0; Add(id[x], -1);
            id[x] = p + 1;
            a[id[x]] = x; Add(id[x], 1);
        }
        else if(opt[0] == 'I'){
            y = Read(); q = Query(id[x]);
            p = Find(q + y); RG int t = a[p];
            swap(a[p], a[id[x]]); swap(id[x], id[t]);
        }
        else if(opt[0] == 'A') printf("%d\n", Query(id[x]) - 1);
        else printf("%d\n", a[Find(x)]);
    }
    return 0;
}

```

---

## 作者：Imakf (赞：25)

~~我的做法好像又是比较清奇~~

这显然是个文艺平衡树的题

看看每个操作我们要干什么

1． Top S——表示把编号为S的书放在最上面。

先找到书 $S$ 的位置 $pos$，翻转区间 $[1,pos]$，再翻转区间 $[2 ,pos]$

2． Bottom S——表示把编号为S的书放在最下面。

先找到书 $S$ 的位置 $pos$，翻转区间 $[pos ,n]$，再翻转区间 $[pos + 1 ,n]$

3． Insert S T——T∈{-1，0，1}，若编号为S的书上面有X本书，则这条命令表示把这本书放回去后它的上面有X+T本书；

先找到书 $S$ 的位置 $pos$，翻转区间 $[pos ,pos + T]$

4． Ask S——询问编号为S的书的上面目前有多少本书。

询问 $S$ 的 rank（把 $S$ 转到根，问左子树大小）

5． Query S——询问从上面数起的第S本书的编号。

询问第 $S$ 位的 $key$

由于我的splay需要插入 INF 和 -INF 以便于求PRE和NXT的时候不会RE，所以某些地方需要 +1 -1的

```cpp
#include<cstdio>
#include<cstring>
#include<ctime>
#include<cstdlib>
#include<iostream>

//#define debug

#define rg register
#define il inline
#define MX (100000 + 4)
#define INF (0x7f7f7f7f)

void swap(int &x ,int &y){
	int t = x;
	x = y ,y = t;  
}
namespace SPLAY{
	#define lch(x) ch[x][0]
	#define rch(x) ch[x][1]
	int root ,sz;
	int ch[MX][2] ,fa[MX] ,mark[MX] ,size[MX] ,key[MX] ,pos[MX];
	int get(int x){return x == ch[fa[x]][1];}
	void pushup(int x){
		if(!x)	return;
		size[x] = 1;
		if(lch(x))	size[x] += size[lch(x)];
		if(rch(x))	size[x] += size[rch(x)];
	}
	void reverse(int x){
		if(!x)	return ; 
		swap(lch(x) ,rch(x));
		mark[x] ^= 1;
	}
	void pushdown(int x){
		if(!x)	return;
		if(mark[x]){
			if(lch(x))	reverse(lch(x));
			if(rch(x))	reverse(rch(x));
			mark[x] = false;
		}
	}
	void rotate(int x){
		int f = fa[x] ,gf = fa[f] ,which = get(x) ,w = ch[x][!which];
		if(gf)	ch[gf][ch[gf][1] == f] = x;
		ch[x][!which] = f ,ch[f][which] = w;
		if(w)	fa[w] = f;
		fa[f] = x ,fa[x] = gf;
		pushup(f) ,pushup(x);
	}
	int stack[MX] ,dep;
	void splay(int x ,int goal = 0){	//////
		int f = x;
		stack[++dep] = f;
		while(f)	stack[++dep] = f = fa[f];
		while(dep)	pushdown(stack[dep--]);
		for( ; (f = fa[x]) != goal ; rotate(x)){
			if(fa[f] != goal)	rotate(get(x) == get(f) ? f : x);
		}if(!goal)	root = x;
	}
	void insert(int x){
		int now = root;
		while(rch(now))	now = rch(now);
		fa[++sz] = now; 
		if(now)	ch[now][1] = sz;
		
		key[sz] = x;
		size[sz] = 1;
		mark[sz] = ch[sz][0] = ch[sz][1] = 0;
		pushup(now);
		splay(sz);
	}
	int rank(int val){
		splay(pos[val]);
		return size[lch(pos[val])] + 1;
	}
	int Kth(int rank){
		int x = root;
		while(true){
			pushdown(x);
			if(lch(x) && rank <= size[lch(x)])	x = lch(x);
			else{
				int tmp = (lch(x) ? size[lch(x)] : 0) + 1;
				if(rank <= tmp)	return x;
				rank -= tmp;
				x = rch(x);
			}
		}
	}
	void reverse(int l ,int r){
		splay(l - 1); 
		if(l >= r)	return;
		int PRE = Kth(l - 1) ,NXT = Kth(r + 1);
		splay(PRE); 
		splay(NXT ,PRE);
		reverse(ch[NXT][0]);
	}
}using namespace SPLAY;

int main(){
	int n ,m;
	scanf("%d%d" ,&n ,&m);
	insert(-INF);
	for(rg int i = 1 ,tmp ; i <= n ; ++i){
		scanf("%d" ,&tmp);
		pos[tmp] = i + 1;
		insert(tmp);
	}
	insert(INF);
	#ifdef debug
	test();puts("");
	#endif 
	char op[33];
	for(rg int i = 1 ,s ,t ; i <= m ; ++i){
		scanf("%s%d" ,op ,&s);
		switch(op[0]){
			case 'T':{
				int l = rank(s);
				if(l != 2){
					reverse(2 ,l);
					reverse(3 ,l);
				}
				break;
			}
			case 'B':{
				int l = rank(s);
				if(l != n + 1){
					reverse(l ,n + 1);
					reverse(l ,n);
				}
				break;
			}
			case 'I':{
				int delta ,P = rank(s);
				scanf("%d" ,&delta);
				switch(delta){
					case 0:{break;}
					case 1:{
						reverse(P ,P + 1);
						break;
					}
					case -1:{
						reverse(P - 1 ,P);
						break;
					}
				}
				break;
			}
			case 'A':{
				printf("%d \n" ,rank(s) - 2);
				break;
			}
			case 'Q':{
				printf("%d \n" ,key[Kth(s + 1)]);
				break;
			} 
		}
	}return 0;
}
```

---

## 作者：halfrot (赞：18)

这道题中的书架可以用splay来维护。

Top和Bottom实质上就是把序列中的一个数放到第一个和最后一个。具体实现可以把要操作的节点提到根节点，然后把左子树合并到右子树上或把右子树合并到左子树上。

Insert操作就是把要操作的节点和前驱后继交换位置，等效于把两个点的特征值即编号进行交换。

Ask操作询问序列中在此节点前面的数有多少个，提到根节点输出size就可以了。

Query操作就是一个简单的查询序列中第s个数的编号，相当于查询第s大。

然后由于我们需要定位编号为s的节点在树中的位置，所以我使用了pos数组记录并维护。

似乎没什么好说的了。

对了，swp函数是swap的意思，交换两个数的值。

总体来说这道题还是很好写的。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int MAXN=8*1e4+5;
int inline swp(int &a,int &b){
    a^=b^=a^=b;
}
int inline readuint(){
    int Num;char ch;
    while((ch=getchar())<'0'||ch>'9');Num=ch-'0';
    while((ch=getchar())>='0'&&ch<='9') Num=Num*10+ch-'0';
    return Num;
}
int inline readint(){
    int Num=0,Flag=1;char ch;
    while((ch=getchar())<'0'||ch>'9') if(ch=='-') break;
    if(ch=='-') Flag=-1; else Num=ch-'0';
    while((ch=getchar())>='0'&&ch<='9') Num=Num*10+ch-'0';
    return Num*Flag; 
}
void outint(int x){
    if(x>=10) outint(x/10);
    putchar(x%10+'0');
}
int n,m,ch[MAXN][2],fa[MAXN],cnt=0;
int num[MAXN],pos[MAXN],siz[MAXN],rt=0;
void inline pushup(int &x){
    siz[x]=siz[ch[x][0]]+siz[ch[x][1]]+1;
    pos[num[ch[x][0]]]=ch[x][0],pos[num[ch[x][1]]]=ch[x][1];
}
void rot(int x,int p){
    int y=fa[x];
    fa[ch[x][!p]]=y,ch[y][p]=ch[x][!p];
    fa[x]=fa[y];if(fa[y]) ch[fa[y]][ch[fa[y]][1]==y]=x;
    fa[y]=x,ch[x][!p]=y;
    pushup(y),pushup(x);
}
void splay(int x,int T){
    while(fa[x]!=T){
        if(fa[fa[x]]==T) rot(x,ch[fa[x]][1]==x);
        else{
            int y=fa[x],z=fa[y],p=ch[z][1]==y;
            if(ch[y][p]==x) rot(y,p),rot(x,p);
            else rot(x,!p),rot(x,p);
        }
    }
    pos[num[x]]=x;
    if(!T) rt=x;
}
void insert(int key){
    int x=rt;while(ch[rt][1]) x=ch[rt][1];
    fa[++cnt]=x,ch[x][1]=cnt,num[cnt]=key,pos[key]=cnt,siz[cnt]=1,ch[cnt][0]=ch[cnt][1]=0;
    splay(cnt,0);
}
void top_bottom(int s,int p){
    splay(pos[s],0);
    if(!ch[rt][p]) return;
    if(!ch[rt][!p]) ch[rt][!p]=ch[rt][p],ch[rt][p]=0;
    else{
        int x=ch[rt][!p];while(ch[x][p]) x=ch[x][p];
        fa[ch[rt][p]]=x,ch[x][p]=ch[rt][p],ch[rt][p]=0;
        splay(ch[x][p],0);
    }
}
void ist(int t,int s){
    splay(pos[s],0);
    if(!t) return;
    if(t==1){
        int suc=ch[rt][1],ps=pos[s];while(ch[suc][0]) suc=ch[suc][0];
        swp(pos[s],pos[num[suc]]);
        swp(num[ps],num[suc]);
    }
    else{
        int pre=ch[rt][0],ps=pos[s];while(ch[pre][1]) pre=ch[pre][1];
        swp(pos[s],pos[num[pre]]);
        swp(num[ps],num[pre]);
    }
}
void ask(int s){
    splay(pos[s],0);
    outint(siz[ch[rt][0]]);
}
int qry(int s){
    int x=rt;
    while(pos){
        if(siz[ch[x][0]]+1==s) return num[x];
        else if(siz[ch[x][0]]>=s) x=ch[x][0];
        else s-=siz[ch[x][0]]+1,x=ch[x][1];
    }
}
int main(){
    ch[0][0]=ch[0][1]=siz[0]=fa[0]=num[0]=pos[0]=0;
    n=readuint(),m=readuint();
    for(int i=1;i<=n;i++) insert(readint());
    for(int i=1;i<=m;i++){
        char opt[10];scanf("%s",opt);
        switch(opt[0]){
            case 'T':top_bottom(readuint(),0);break;
            case 'B':top_bottom(readuint(),1);break;
            case 'I':ist(readint(),readuint());break;
            case 'A':ask(readuint()),putchar('\n');break;
            case 'Q':outint(qry(readuint())),putchar('\n');break;
        }
    }
}
```

---

## 作者：AubRain (赞：15)

为什么不尝试一下 ~~又快又短~~ 的 **权值线段树** 呢？

(感觉这题就是 $noip2017$ 列队的弱化版？

开一个 $id$ 数组，记录每个位置上是哪个编号，再开一个 $po$ 数组记录每个编号所在的位置是哪。

注意因为下标可能为负数， $id$ 数组的下标要加上一个偏移量。

然后用权值线段树找排名第 $k$ 大以及前驱后继以及一个数的排名就行了。

常数很小 $(200ms)$,代码也不长（$50$行）

```cpp
#include<bits/stdc++.h>
#define N 200005
#define M N*20
#define mid ((l+r)>>1)
using namespace std;

char pd[9];
int n,m,cnt,rt,L,R;
int id[N],po[N];
int sum[M],ls[M],rs[M];

void ins(int &p,int x,int d,int l=-N,int r=N){
	if(!p) p=++cnt;sum[p]+=d;if(l==r) return ;
	x<=mid ? ins(ls[p],x,d,l,mid) : ins(rs[p],x,d,mid+1,r);
}
int find(int p,int k,int l=-N,int r=N){
	if(l==r) return l;
	return sum[ls[p]]>=k ? find(ls[p],k,l,mid) : find(rs[p],k-sum[ls[p]],mid+1,r);
}
int ask(int p,int x,int l=-N,int r=N){
	if(l==r) return sum[p];
	return x<=mid ? ask(ls[p],x,l,mid) : ask(rs[p],x,mid+1,r)+sum[ls[p]];
}
inline void up(int x){
	int now=po[x];ins(rt,now,-1);
	po[x]=--L;id[n+L]=x;ins(rt,L,1);
}
inline void down(int x){
	int now=po[x];ins(rt,now,-1);
	po[x]=++R;id[n+R]=x;ins(rt,R,1);
}
inline void change(int x,int k){
	if(k==0) return ;
	int now=find(rt,ask(rt,po[x])+k);
	int y=id[n+now];id[n+po[x]]=y;po[y]=po[x];
	id[n+now]=x;po[x]=now;
}
signed main(){
	scanf("%d%d",&n,&m);L=1,R=n;
	for(int x,i=1;i<=n;i++)
		ins(rt,i,1),scanf("%d",&x),id[i+n]=x,po[x]=i;
	while(m--){
		scanf("%s",pd);int x,k;scanf("%d",&x);
		if(pd[0]=='T') up(x);
		if(pd[0]=='B') down(x);
		if(pd[0]=='I') scanf("%d",&k),change(x,k);
		if(pd[0]=='A') printf("%d\n",ask(rt,po[x])-1);
		if(pd[0]=='Q') printf("%d\n",id[n+find(rt,x)]);
	}
}
```

---

## 作者：zqy1018 (赞：15)

居然没有人发fhqtreap的题解。。。

那我就来一发。

维护pos数组，记录下编号为i的书的位置即可。

剩下的就是Split和Merge的组合了。

代码写的比较清楚，应该好懂。

```cpp
struct Tr{
    int siz,v,pr,l,r,fa;
};
Tr tr[400005];
int S=0,root=0,n,m,a[200005];
int pos[200005];
void maintain(int k){
    tr[k].siz=1;
    if(tr[k].l)tr[k].siz+=tr[tr[k].l].siz,tr[tr[k].l].fa=k;
    if(tr[k].r)tr[k].siz+=tr[tr[k].r].siz,tr[tr[k].r].fa=k;
}
int newnode(int k){
    S++,tr[S].v=k,tr[S].pr=rand(),tr[S].siz=1;
    tr[S].l=tr[S].r=tr[S].fa=0;
    return S;
}
void Split_K(int now,int k,int &x,int &y){
    if(!now)x=y=0;
    else{
        if(k>tr[tr[now].l].siz)
            x=now,Split_K(tr[now].r,k-tr[tr[now].l].siz-1,tr[now].r,y);
        else
            y=now,Split_K(tr[now].l,k,x,tr[now].l);
        maintain(now);
    }
}
int Merge(int x,int y){
    if(!x||!y)return x+y;
    if(tr[x].pr<tr[y].pr){
        tr[x].r=Merge(tr[x].r,y);
        maintain(x);
        return x;
    }else{
        tr[y].l=Merge(x,tr[y].l);
        maintain(y);
        return y;
    }
}
int read(){
    int f=1,x=0;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
    while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
    return f*x; 
}    
int get_pos(int x){
    int res=1+tr[tr[x].l].siz;
    while(tr[x].fa){
        if(x==tr[tr[x].fa].r)
            res+=tr[tr[tr[x].fa].l].siz+1;
        x=tr[x].fa;
    }
    return res;
}
void init(){
    srand(12414841);
    tr[0].siz=tr[0].v=tr[0].fa=0;
    n=read(),m=read();
    for(int i=1;i<=n;i++)a[i]=read();
    for(int i=1;i<=n;i++)
        pos[a[i]]=newnode(a[i]),
        root=Merge(root,pos[a[i]]);
}
void solve(){
    char ord[10];
    int x,u,v,w,y,z,t,i1,i2;//全是辅助变量
    for(int i=1;i<=m;i++){
        scanf("%s",ord);
        u=v=w=y=z=t=0;
        if(ord[0]=='A')
            x=read(),
            printf("%d\n",get_pos(pos[x])-1);
        if(ord[0]=='T'){
            x=read(),u=get_pos(pos[x]);
            Split_K(root,u-1,w,z);
            Split_K(z,1,y,v);
            root=Merge(Merge(y,w),v);
        }
        if(ord[0]=='B'){
            x=read(),u=get_pos(pos[x]);
            Split_K(root,u-1,w,z);
            Split_K(z,1,y,v);
            root=Merge(Merge(w,v),y);
        }    
        if(ord[0]=='Q'){
            x=read();
            Split_K(root,x-1,w,z);
            Split_K(z,1,y,v);
            printf("%d\n",tr[y].v);
            root=Merge(Merge(w,y),v);
        }
        if(ord[0]=='I'){
            x=read(),y=read();
            if(y){
                u=get_pos(pos[x]);
                Split_K(root,u-1,w,v);
                Split_K(v,1,t,z);
                if(y==-1){
                    Split_K(w,u-2,i1,i2);
                    root=Merge(Merge(Merge(i1,t),i2),z);
                }else{
                    Split_K(z,1,i1,i2);
                    root=Merge(Merge(Merge(w,i1),t),i2);
                }
            }
        }
    }
}
```
顺便打一发广告：[我的博客](http://zqy1018.leanote.com/)，欢迎联动


---

## 作者：白学家 (赞：14)

一种裸的treap解法

首先给每本书按顺序给一个优先值，并按优先值从小到大排序插入treap中。

令a[i]为编号为i的节点所对应的优先值

不难发现top/bottom操作就是把节点的优先值调到最低/最高.之后再插入到treap中

insert操作为交换两相邻元素的优先值后重新加入treap

ask(s) / query(k) 就是treap中的rank(a[s]) 和 kth(k) 的操作了，但是记得在节点里保存这本书本来的编号

代码采用指针的写法

``` cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<string>
using namespace std;


struct node {
    int v,r,s,book;
    node *ch[2];
    int cmp(int x) {
        if (x==v) return -1;
        return x<v?0:1;
    }
    void maintain() {
        s=1+ch[0]->s+ch[1]->s;
    }
};

node *null=new node();

void rotate(node * &o,int d) {
    node *k=o->ch[d^1]; o->ch[d^1]=k->ch[d];    k->ch[d]=o;
    o->maintain();    k->maintain();    o=k;
}

int nowbook;

void insert(node * &o,int x) {
    int d=o->cmp(x);
    if (o==null) { o=new node();    o->ch[1]=o->ch[0]=null; o->v=x;    o->r=rand();    o->book=nowbook;    o->maintain(); }
    else  {
        insert(o->ch[d],x);
        if (o->r < o->ch[d]->r) rotate(o,d^1);
    }
    o->maintain();
}

void remove(node * &o,int x) {
    int d=o->cmp(x);
    if (d==-1) {
        if (o->ch[0]==null) o=o->ch[1];
        else if (o->ch[1]==null) o=o->ch[0];
        else {
            int d=o->ch[1]->r > o->ch[0]->r ? 0:1;
            rotate(o,d);
            remove(o->ch[d],x);
        }
    } else remove(o->ch[d],x);
    if (o!=null) o->maintain();
}

int kth(node *o,int k) {
    int s=o->ch[0]->s;
    if (k==s+1) return o->book;
    else {
        if (k<s+1) return kth(o->ch[0],k);
        else return kth(o->ch[1],k-s-1);
    }
}

int rank(node *o,int x) {
    int d=o->cmp(x);
    int s=o->ch[0]->s;
    if (d==-1) return s+1;
    if (d==0) return rank(o->ch[0],x);
    if (d==1) return rank(o->ch[1],x)+s+1;
}

const int maxn=80000+5;
int a[maxn];

int main() {
    ios::sync_with_stdio(0);
    null->s=null->r=0;    //null->ch[0]=null->ch[1]=null;
    node *root=null;
    int n,m;    cin>>n>>m;
    int l=1,r=n;
    for (int i=1;i<=n;++i) {
        cin>>nowbook;
        insert(root,i);
        a[nowbook]=i;
    }
    
    string s;
    
     while (m--) {
         cin>>s;
         if (s=="Query") {
             int k;    cin>>k;
             cout<<kth(root,k)<<endl;
         }
         if (s=="Ask") {
             int k;    cin>>k;
             cout<<rank(root,a[k])-1<<endl;
         }
         if (s=="Top") {
             int k;    cin>>k;
             remove(root,a[k]);
             nowbook=k;
             insert(root,--l);
             a[k]=l;
         }
         
         if (s=="Bottom") {
             int k;    cin>>k;
             remove(root,a[k]);
             nowbook=k;
             insert(root,++r);
             a[k]=r;
         }
         
         if (s=="Insert") {
             int s1,t;    cin>>s1>>t;
             if (t==-1) {
                 int rank2=rank(root,a[s1]);
                 int rank1=rank2-1;
                 int s2=kth(root,rank1);
                 remove(root,a[s1]);    remove(root,a[s2]);
                 swap(a[s1],a[s2]);
                 nowbook=s1;    insert(root,a[s1]);
                 nowbook=s2;    insert(root,a[s2]);
             }
             
             if (t==1) {
                 int rank2=rank(root,a[s1]);
                 int rank1=rank2+1;
                 int s2=kth(root,rank1);
                 remove(root,a[s1]);    remove(root,a[s2]);
                 swap(a[s1],a[s2]);
                 nowbook=s1;    insert(root,a[s1]);
                 nowbook=s2;    insert(root,a[s2]);
             }
         }
         
     }
    
    return 0;
}
```

---

## 作者：critnos (赞：9)

发篇题解庆祝一下。

**需要的数据结构：**

一个数组：$a$；一个map：$b$；一个平衡树（pb_ds实现）：$t$。

$a$：每个位置$a_i$存储的是$a_i$在书架中的位置。当然不是真实的位置，因为如果这样每次修改就要用$O(n)$的时间。一开始是“1，2，3，4，5”，然后要把$5$提到最上面，就可以改成“1，2，3，4，0”。

$b$：$key$为书的编号在书架中的位置，映射的值是书的编号。

$t$：模拟书架，存储的是所有书的虚拟位置。

还要两个变量：$l$，$r$。$l$存储书架的顶端编号，$r$存储书架的底端编号。

**操作1：把编号为S的书放在最上面**

每个数据结构都要修改。对于$t$和$b$，删除$key=a_S$的节点，添加$key=l$，$b_l$仍然映射$S$。对于$a$，直接修改$a_S$为$l$。同时还要把$l-1$。注意修改顺序。

操作2同上。

**操作3：若编号为S的书上面有X本书，则这条命令表示把这本书放回去后它的上面有X+T本书**

每个数据结构都要修改。对于$b$，交换$b_{a_S}$和$b_u$，$u$为在$t$中$a_S$的前驱或后继（见【【模板】普通平衡树】）。对于$a$，直接修改$a_S$为$l$。$t$不用修改，因为排名并没有发生改变。

**操作4：询问编号为S的书的上面目前有多少本书**

求$t$中$a_S$的排名。

**操作5：询问从上面数起的第S本书的编号**

输出$b_v$,$v$为$t$中排名为$s$的数。

所有的操作的时间复杂度均为$O(\log n)$。

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#define ll long long
using namespace std;
using namespace __gnu_pbds;
tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> t;
int a[80005];
map<int,int> b;
/*
1． Top S——表示把编号为S的书放在最上面。

2． Bottom S——表示把编号为S的书放在最下面。

3． Insert S T——T∈{-1，0，1}，若编号为S的书上面有X本书，则这条命令表示把这本书放回去后它的上面有X+T本书；

4． Ask S——询问编号为S的书的上面目前有多少本书。

5． Query S——询问从上面数起的第S本书的编号。
*/
int main()
{
	int x,y,n,m,i,w,l,r,u;
	char opt[10];
	scanf("%d%d",&n,&m);
	l=0,r=n+1;
	for(i=1;i<=n;i++)
	{
		scanf("%d",&x);
		a[x]=i;
		b[i]=x;
		t.insert(i);
	}
	while(m--)
	{
		scanf("%s%d",&opt,&x);
		w=a[x];
		if(opt[0]=='T')
		{
			t.erase(t.lower_bound(w));
			t.insert(l);
			a[x]=l;
			b.erase(w);
			b[l]=x;
			l--;
		}
		if(opt[0]=='B')
		{
			t.erase(t.lower_bound(w));
			t.insert(r);
			a[x]=r;
			b.erase(w);
			b[r]=x;
			r++;
		}
		if(opt[0]=='I')
		{
			scanf("%d",&y);
			if(y==-1)
			{
				u=*(--t.lower_bound(w));
				swap(a[x],a[b[u]]);
				swap(b[w],b[u]);
			}
			if(y==1)
			{
				u=*(t.lower_bound(w+1));
				swap(a[x],a[b[u]]);
				swap(b[w],b[u]);
			}
		}	
		if(opt[0]=='A')
			printf("%d\n",t.order_of_key(w));
		if(opt[0]=='Q')
			printf("%d\n",b[(*t.find_by_order(x-1))]);	
	}
}
```
完。

---

## 作者：ShieHere (赞：8)

# 前言

大家好，我不会平衡树，但是非常喜欢暴力算法，所以我用块状链表过了这道题。

此外，本片题解的所有代码基于一下的设置，所以若是遇上了不认识的东西，多半是这里出来的：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN=1e5+5,MAXT=1e3+514,MAXK=3e2+5;
struct LINK{
    LINK *nxt,*pre;
    ll *LP,id;
}link[MAXT*2];
ll tim,c[MAXT*2][MAXT*2],book[MAXN];
LINK *S,*T;
LINK *newpt(){return &link[++tim];}
void ins(LINK *x,LINK *y,LINK *t){
    x->nxt=y->pre=t;
    t->pre=x;t->nxt=y;
}
void init(){
    for(int i=0;i<MAXT;i++)link[i].LP=c[i],link[i].id=i;
    S=&link[0];T=&link[MAXT-1];
    S->nxt=T;T->pre=S;
    LINK *pt=newpt();ins(S,T,pt);
}
```

# 题目大意

对一个 $1\sim n$ 的排列实现如下操作：

1. 将数字 $p$ 的位置改为排列最前面。

2. 将数字 $p$ 的位置改为排列最后面。

3. 将数字 $p$ 的位置左移、右移或不动。

4. 询问数字 $p$ 的位置。

5. 询问排列第 $i$ 位的数字。

# 正文

看到 $8\times 10^{4}$ 的数据范围，我就开始动歪脑筋了，显然这个范围是可以放 $\mathcal{O}(n\cdot\sqrt{n})$ 的复杂度的算法过的。

于是考虑块状链表维护插入和查询操作。具体地，我们先将上面提到的五个操作分解一下，以便我们思考：

操作 1，显然是让我们从排列中先删除一个数字，再把这个数字插入到排列最前面。

操作 2，是让我们从排列中先删除一个数字，再把这个数字插入到排列最后面。

操作 3，是让我们从排列中先删除一个数字，再把这个数字插入到排列中间一个位置。

操作 4，是让我们找到一个数字的位置。

操作 5，是让我们找到一个位置上的数字。

很显然，运用最最普通的块状链表的插入、删除和分裂操作，就可以维护操作 1、2、3、5 了。而操作 4 还需要我们开一个桶，记录下每个数字所在的块的编号，然后就可以对于每一个询问直接遍历所在的块找到数字的位置了。

具体地：

对于删除操作，先通过桶找到数字所在的块的编号，然后暴力遍历该块内的元素，遇到了该数字，就把后面的数字往前移，覆盖掉这个数字。

暴力遍历块内元素复杂度 $\mathcal{O}(\sqrt{n})$。

对于插入操作，我们先记录每个块的大小，然后从第一个块开始往后遍历，找到插入位置所对应的块，然后把块内在该位置之后的元素往后移一位，把数字放在该位置上。

暴力遍历块复杂度 $\mathcal{O}(\sqrt{n})$，暴力遍历块内元素复杂度 $\mathcal{O}(\sqrt{n})$，总复杂度 $\mathcal{O}(\sqrt{n})$。

**注意：遍历块**和**遍历块内元素**是两种操作。

到这里，我们已经可以实现操作 1~3 了。

对于查询数字的位置，先通过桶找到数字所在块的编号，然后从第一个块开始遍历块，知道遇见数字所在块，然后答案加上数字所在块之前所有块的大小之和；然后遍历所在块内元素，直到遇见该数字，然后答案加上该数字在块内的位置。最后输出答案，即为数字在排列中的位置。

暴力遍历块复杂度 $\mathcal{O}(\sqrt{n})$，暴力遍历块内元素复杂度 $\mathcal{O}(\sqrt{n})$，总复杂度 $\mathcal{O}(\sqrt{n})$。

对于查询位置对应的数字，就和插入操作一样，只不过把插入的步骤改为输出对应位置上的数字，复杂度和插入操作一样，都是 $\mathcal{O}(\sqrt{n})$。

于是到这里，我们已经可以实现操作 4~5 了。

于是到这里，我们已经可以实现所有的操作了。

单个操作复杂度 $\mathcal{O}(\sqrt{n})$，共 $m$ 个操作，因此总时间复杂度 $\mathcal{O}(m\cdot\sqrt{n})$，可以通过本题。

需要注意的是，上述操作中，我默认大家都已经了解过了块状链表的原理，因此忽略了块状链表的**分裂**操作：具体的，当一个块的大小超过额定块长的两倍时，我们将这个块分成两个块，新块接在旧块之后，这样就可以保证数据不会大量堆积在同一个块内而影响效率了。

在插入操作中，需要调用分裂操作。

此外，这里再提醒一遍：不要忘记在插入和分裂操作之后，维护桶的信息。

接下来给出本题块状链表做法的代码：

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN=1e5+5,MAXT=1e3+514,MAXK=3e2+5;//数据范围、开数组的大小、额定块长
struct LINK{//链表结构体
    LINK *nxt,*pre;
    ll *LP,id;//LP 为该块存放信息的数组，id 为该块的编号
}link[MAXT*2];
ll tim,c[MAXT*2][MAXT*2],book[MAXN];
//tim 为块的数量，c 为 LP 指向的位置，book 为存放数字位置的桶
LINK *S,*T;//S 为链表的起点，T 为链表的终点
LINK *newpt(){return &link[++tim];}//分配一个新的块
void ins(LINK *x,LINK *y,LINK *t){//在两个块中间插入一个块
    x->nxt=y->pre=t;
    t->pre=x;t->nxt=y;
}//注意：该函数插入的是块，用来维护链表形态；下文的 ins_k 函数插入的是数字，用来维护链表的信息
void init(){//初始化
    for(int i=0;i<MAXT;i++)link[i].LP=c[i],link[i].id=i;//为所有待定的块分配数组和编号
    S=&link[0];T=&link[MAXT-1];//初始化起点和终点
    S->nxt=T;T->pre=S;//终点在起点之后，起点在终点之前
    LINK *pt=newpt();ins(S,T,pt);//最开始的一个块，在起点和终点之间
}
void split(LINK *t){//分裂操作
    if(t->LP[0]<=MAXK*2)return;//满足块长大于两倍额定块长才分裂
    LINK *pt=newpt();
    ins(t,t->nxt,pt);//新块插在旧块之后
    for(int i=MAXK+1;i<=t->LP[0];i++)book[pt->LP[++pt->LP[0]]=t->LP[i]]=pt->id;
    t->LP[0]=MAXK;//将旧块后半段信息转移给新块
}
void ins_k(ll id,ll k){//插入数字
    for(LINK *t=S->nxt;t!=T;t=t->nxt){
        if(k>t->LP[0])k-=t->LP[0];//如果插入的位置不在该块内
        else{
            for(int i=t->LP[0];i>=k+1;i--)t->LP[i+1]=t->LP[i];//插入位置之后的数字后移
            t->LP[k+1]=id;book[id]=t->id;t->LP[0]++;//插入数字
            split(t);//尝试分裂块
            break;
        }
    }
}
void ins_lst(ll id){//插入数字到最后一位
    LINK *pt=T->pre;//最后一位在最后一个块内
    pt->LP[++pt->LP[0]]=id;//最后一位在最后一个块的最后一位
    book[id]=pt->id;//别忘了维护桶！！！（大声）
    split(pt);
}
ll find_k(ll k){//寻找位置上的数字
    for(LINK *t=S->nxt;t!=T;t=t->nxt){
        if(k>t->LP[0])k-=t->LP[0];
        else return t->LP[k];
    }
    return -1;
}
void del(ll id){//删除数字
    bool flag=false;
    LINK *pt=&link[book[id]];//获得数字所在块
    for(int i=1;i<=pt->LP[0]-1;i++){
        if(pt->LP[i]==id)flag=true;//遇见了该数字
        if(flag)pt->LP[i]=pt->LP[i+1];//该数字之后的数字前移
    }
    pt->LP[0]--;//块大小减一
}
ll rank_(ll id){//查询数字的位置
    ll r=0;
    LINK *pt=&link[book[id]];
    for(LINK *t=S->nxt;t!=pt;t=t->nxt)r+=t->LP[0];
    for(int i=1;i<=pt->LP[0];i++){
        if(pt->LP[i]==id)break;
        r++;
    }
    return r;
}
void check(){//调试代码，不用管
    printf("Check : ");
    for(LINK *t=S->nxt;t!=T;t=t->nxt)
        for(int i=1;i<=t->LP[0];i++)printf("%lld ",t->LP[i]);
    printf("\n");
}
ll n,m,pi,ti;
char op[128];
int main(){
    init();
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%lld",&pi);
        ins_lst(pi);
    }
    while(m--){
        scanf("%s",op+1);
        if(op[1]=='T'){//操作一
            scanf("%lld",&pi);
            del(pi);ins_k(pi,0);
        }
        else if(op[1]=='B'){//操作二
            scanf("%lld",&pi);
            del(pi);ins_lst(pi);
        }
        else if(op[1]=='I'){//操作三
            scanf("%lld%lld",&pi,&ti);
            if(ti==0)continue;
            ll rk=rank_(pi);
            del(pi);
            if(rk+ti==n)ins_lst(pi);
            else ins_k(pi,rk+ti);
        }
        else if(op[1]=='A'){//操作四
            scanf("%lld",&pi);
            printf("%lld\n",rank_(pi));
        }
        else if(op[1]=='Q'){//操作五
            scanf("%lld",&pi);
            printf("%lld\n",find_k(pi));
        }
        // check();
    }
    return 0;
}
```

# 尾言

本片题解只是该题的块状链表做法，并不是块状链表教学，所以对于块状链表的操作和维护介绍得颇为粗略，还请见谅。

代码中有自认为详细的注释。

如有表述不清或错误的地方，请在评论区提出，感激不尽。

顺带一提，这种方法居然跑得比我的几个同学写的 fhq-Treap 和 splay 都要快些（乐）。

最后，祝大家看得开心！

---

## 作者：zyj578335934 (赞：5)

这道题是练平衡树的好题~~然而对我不是~~。。。

观察题目可知，题目中给的操作只有两种：
1. 把书放到最前或最后 
2. 把书与相邻的书交换位置。

# 于是蒟蒻想出了一种~~混分的~~好办法。

刚开始将整个序列从下标为i+m插入平衡树，并且维护两个数组。

f[i]表示编号为i的书在平衡树中所对应的值（相当于这本书的关键码）。

g[i]表示值i所对应的书的编号。

同时我们还要维护两个变量，分别为minn：表示平衡树中最小的权值，maxx：表示平衡树中最大的权值。

对于每个操作，我们有：

Top i：将编号为i的书在平衡树中所对应的权值f[i]删除，同时minn--,insert(minn)；

f[i]=minn，表示编号为i的书在平衡树中所对应的值为minn，

g[minn]=i，表示minn这个权值所对应的书的编号为i；

### 这样有什么用呢？在平衡树中按权值排序后，最小的权值所对应的书就是我们要执行Top操作的书i,这样子我们就达到了把书i的排名改为第一名的目的!

------------

与此相同，Bottom i：将编号为i的书在平衡树中所对应的权值f[i]删除，同时maxx++,insert(maxx);

f[i]=maxx，表示编号为i的书在平衡树中所对应的值为maxx，

g[maxx]=i，表示maxx这个权值所对应的书的编号为i；

这样就达到了书i所对应的排名改为最后一名的目的！

------------
Insert S T:显而易见，当T等于0，直接continue；

当T不等于0:
1. 我们已经知道这本书的编号,就找到这本书在平衡树中的排名now=get_rank(f[S])；

2. 再找到排名为now+T的书，设这本书为R，则这本书的排名now1=now+T，所对应的权值now2=get_val(now1),所以这本书的编号R=g[now2];

3. 之后我们需要交换这两本书的排名， _直接将这两本书的f数组与g数组交换_ ，就可以达到交换这两本书排名的目的。（即相当于把这两本书所对应的权值f[]交换，在平衡树中排序后排名自然就交换了）

------------

Ask i:查询编号为i的书的排名-1，直接输出get_rank(f[i])-1。

------------
Query i:查询第i本书的编号，直接输出g[get_val(i)]即可。


### 因为n,m<=80000，所以g数组最大也就只有m*3=240000，肯定够用，所以这个平衡树就可以水过去啦！

```c
#include<cstdio>
#include<algorithm>
struct sb{
    int l,r,val,size,key;
}s[500010];
int n,tot,root,seed=666,m;
int f[250010],g[550010];
int minn,maxx;
inline int rand_(){
    return seed=(int)(seed*482711ll%2147483647);
}
inline int newnode(int val){
    s[++tot].size=1;
    s[tot].val=val;
    s[tot].key=rand_();
    return tot;
}
inline void update(int x){
    s[x].size=s[s[x].l].size+s[s[x].r].size+1;
}
void split(int now,int &a,int &b,int val){
    if(now==0){
        a=b=0;
        return;
    }
    if(s[now].val<=val){
        a=now;
        split(s[now].r,s[a].r,b,val);
    }
    else {
        b=now;
        split(s[now].l,a,s[b].l,val);
    }
    update(now);
}
void merge(int &now,int a,int b){
    if(a==0||b==0){
        now=a+b;
        return;
    }
    if(s[a].key<s[b].key){
        now=a;
        merge(s[now].r,s[a].r,b);
    }
    else {
        now=b;
        merge(s[now].l,a,s[b].l);
    }
    update(now);
}
int find(int now,int rank){
    while(s[s[now].l].size+1!=rank){
        if(s[s[now].l].size>=rank){
            now=s[now].l;
        }
        else {
            rank-=(s[s[now].l].size+1);
            now=s[now].r;
        }
    }
    return s[now].val;
}
inline void insert(int val){
    int x=0,y=0,z;
    z=newnode(val);
    split(root,x,y,val);
    merge(x,x,z);
    merge(root,x,y);
}
inline void delet(int val){
    int x=0,y=0,z=0;
    split(root,x,y,val);
    split(x,x,z,val-1);
    merge(z,s[z].l,s[z].r);
    merge(x,x,z);
    merge(root,x,y);
}
inline int get_rank(int val){
    int x=0,y=0;
    int ans;
    split(root,x,y,val-1);
    ans=s[x].size+1;
    merge(root,x,y);
    return ans;
}
inline int get_val(int rank){
    return find(root,rank);
}
int get_pre(int val){
    int x=0,y=0;
    int ans;
    split(root,x,y,val-1);
    ans=find(x,s[x].size);
    merge(root,x,y);
    return ans;
}
int get_next(int val){
    int x=0,y=0;
    split(root,x,y,val);
    int ans=find(y,1);
    merge(root,x,y);
    return ans;
}
int main(){
    scanf("%d%d",&n,&m);
    minn=m;
    maxx=n+m+1;
    for(register int i=1;i<=n;i++){
        int x;
        scanf("%d",&x);
        insert(i+m);
        g[i+m]=x;
        f[x]=i+m;
    }
    for(register int i=1;i<=m;i++){
        char ch[10];
        scanf("%s",ch);
        if(ch[0]=='Q'){
            int x;
            scanf("%d",&x);
            int now=get_val(x);
            printf("%d\n",g[now]);
        }
        else if(ch[0]=='T'){
            int x;
            scanf("%d",&x);
            delet(f[x]);
            f[x]=minn;
            insert(f[x]);
            g[minn--]=x;
        }
        else if(ch[0]=='B'){
            int x;
            scanf("%d",&x);
            delet(f[x]);
            f[x]=maxx;
            insert(f[x]);
            g[maxx++]=x;
        }
        else if(ch[0]=='I'){
            int x,y;
            scanf("%d%d",&x,&y);
            if(y==0)continue;
            int now=get_rank(f[x]);
            int now1=now+y;
            int now2=get_val(now1);
            int now3=g[now2];
            register int t=g[f[x]];
            g[f[x]]=g[f[now3]];
            g[f[now3]]=t;
            t=f[x];
            f[x]=f[now3];
            f[now3]=t;
        }
        else if(ch[0]=='A'){
            int x;
            scanf("%d",&x);
            int now=get_rank(f[x]);
            printf("%d\n",now-1);
        }
    }
    return 0;
}
```


蒟蒻太弱了，讲的不太好，各位大佬如有意见欢迎指出；

### 完结撒花！！（我永远喜欢FHQ~）


---

## 作者：Liangkry (赞：5)

Online operate & quest 在线操作查询

（树状数组是~~骗分~~AC的好东西）

按题意用数组 shelt 模拟书架，前后预留长度，

L,R 分别表示书架顶端、底端

**Top, Bottom, Insert 按题意模拟即可，把原来有书现在留空的地方置为0，更新树状数组，**

用3个函数：加入(add), 删除(dele) _ delete是关键字_ , 计算上面有多少书(cal).

提高组水平的暴力模拟

~~MORE VIOLENT YOUR CODE IS, MORE EXTRA MARKS BELONG TO YOU~~

(less than 100ms)

Code:
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
char t[10];
int shelf[240005],f[240005];
int c[240005];  // put books into a Binary Indexed Tree
int n,m,S,T,L,R,Next,Left,Right,mid,ans;
const int TOP=80000;
int lowbit(int x)
{
	return x-(x&(x-1));
}
void add(int x)
{
	while(x<=3*TOP+3)
	{
		c[x]++;
		x+=lowbit(x);
	}
}
void dele(int x)
{
	while(x<=3*TOP+3)
	{
		c[x]--;
		x+=lowbit(x);
	}
}
int cal(int x)
{
	int sum=0;
	while(x>0)
	{
		sum+=c[x];
		x-=lowbit(x);
	}
	return sum;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&shelf[TOP+i]);
		f[shelf[TOP+i]]=TOP+i;
		add(TOP+i);
	}
	L=TOP+1; R=TOP+n;
	while(m--)
	{
		scanf("%s%d",t,&S);
		if(t[0]=='T')
		{
			shelf[f[S]]=0;
			dele(f[S]);
			f[S]=L-1;
			add(f[S]);
			L--;
			shelf[f[S]]=S;
		}
		if(t[0]=='B')
		{
			shelf[f[S]]=0;
			dele(f[S]);
			f[S]=R+1;
			add(f[S]);
			R++;
			shelf[f[S]]=S;
		}
		if(t[0]=='I')
		{
			cin>>T;
			int k=T;
			while(shelf[f[S]+T]==0)
				T+=k;
			Next=shelf[f[S]+T];
			swap(shelf[f[S]],shelf[f[S]+T]);
			swap(f[S],f[Next]);
		}
		if(t[0]=='A')
			printf("%d\n",cal(f[S]-1));
		if(t[0]=='Q')
		{
			Left=L; Right=R; ans=240004;
			while(Left<=Right)
			{
				mid=(Left+Right)/2;
				if(cal(mid)>=S)
				{
					ans=min(ans,mid);
					Right=mid-1;
				}
				else
					Left=mid+1;
			}
			printf("%d\n",shelf[ans]);
		}
	}
	return 0;
}

```

---

## 作者：LengChu (赞：5)

### 不是优秀的做法，开O2才能过。
### 主要是想要提供一点新思路，以及练习STL的使用。

------------

说来惭愧，看到这道题的第一反应就是用vector水过。

~~加了个快读还有一些没啥卵用的头文件才50多行。~~

怒交一发T到了30分，开O2勉强过（最优解倒数第二名）。

不过这么短的代码量和不能再简单的思维。。。慢一点也是可以接受的嘛。。。

------------

#### 写这篇题解的目的在于讲一下如何用vector水平衡树的题qwq。

首先介绍一下vector的几个操作，这道题用到的和用不到的都会有一些。

迭代器就相当于。。。一个从0开始的数组下标？

1.**push_back( int x )** ，把一个数x放在最末。

2.**insert( iterator it , int x )** ，iterator是一个迭代器，意思是把x这个数插在it这个迭代器位置的前面。

3.**erase( iterator it )** ，删除it这个位置的数。

4.**lower_bound( iterator begin , iterator end , int x ) && upper_bound( iterator begin , iterator end , int x )** ，应该是广为人知的吧，二分查找，返回值是迭代器。

lower_bound返回的是第一个>=x的数的迭代器，upper_bound是>x。

所以把lower_bound的返回值 - - 就是x的前驱的位置了qwq。

5.**pop_back()** ，删掉最末。

6.**[ ]运算符** ，像数组一样直接取值。

~~然后就可以水过【模板】普通平衡树了~~

还有一个通用的函数： **find( iterator begin , iterator end , int x )** ,作用就是查找x的位置啦，返回值是迭代器，这道题中也有用到。

知道了这些以后就可以开始水题了qwq。

```
#include<bits/stdc++.h>
#define ll long long
#define in inline
#define rint register int
using namespace std;
int n,m,x,y,tmp;
char s[123]; 
vector<int> v;
in ll read()
{
	ll x=0,f=1; char ch=getchar();
	while(ch<'0'||ch>'9') { if(ch=='-') f=-1; ch=getchar(); }
	while(ch>='0'&&ch<='9') { x=x*10+ch-'0'; ch=getchar(); }
	return x*f;
}
int main()
{
	n=read(); m=read();
	for(rint i=1;i<=n;i++)
	{
		int x=read();
		v.push_back(x);
	}
	for(rint i=1;i<=m;i++)
	{
		scanf("%s",s); x=read();
		if(s[0]=='T')
		{
			v.erase(find(v.begin(),v.end(),x));
			v.insert(v.begin(),x);
		}
		else if(s[0]=='B')
		{
			v.erase(find(v.begin(),v.end(),x));
			v.insert(v.end(),x);
		}
		else if(s[0]=='I')
		{
			y=read();
			if(y!=0) 
			{
				tmp=find(v.begin(),v.end(),x)-v.begin();//这里-v.begin()取下标 意思恰好就是在x上面有几本书
				v.erase(tmp+v.begin());
				tmp+=y; v.insert(v.begin()+tmp,x);
			}
		}
		else if(s[0]=='A')
		{
			tmp=find(v.begin(),v.end(),x)-v.begin();
			printf("%d\n",tmp);
		}
		else if(s[0]=='Q') printf("%d\n",v[x-1]);//下标从0开始
	}
	return 0;
}

```

希望可以将这道题的做法拓宽一些？

---

## 作者：zhenglier (赞：4)

# 01trie做法

既然01trie可以过平衡树板子，自然也能做这道题。

操作其实非常简单：

- 对于操作Top，我们可以建立一个head，每次操作删除对应书的权值，然后往树上插入一个head-1，然后head--，最后把书映射到这个点上就行了。

- 对于操作Bottom，建立一个tail，同理。

- 对于操作Insert，找到这本书的排名，然后和这本书的上/下的那个排名交换就行了。

- 对于操作Ask，直接查排名。

- 对于操作Query，直接查排名第k大的树就行了。

接下来是~~简短的~~代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct trie{
    #define work for(register int i=31,rt=1,t;i>=0;--i)
    int tot=1;
    struct point{
        int ch[2],sum;
    }p[800010];
    inline void clear(){tot=1,p[1].ch[0]=p[1].ch[1]=p[1].sum=0;}
    inline void add(int x,int z){
        work{t=x>>i&1;
        	if(!p[rt].ch[t])p[rt].ch[t]=++tot;
        	p[rt=p[rt].ch[t]].sum+=z;
        }
    }
    inline int kth(int k){
    	int ret=0;
    	work{
    		if(k>p[p[rt].ch[0]].sum)ret|=1<<i,k-=p[p[rt].ch[0]].sum,rt=p[rt].ch[1];
    		else rt=p[rt].ch[0];
        }return ret;
    }
    inline int rank(int x){
    	int ret=1;
    	work{t=x>>i&1;
    		if(t)ret+=p[p[rt].ch[0]].sum;
    		rt=p[rt].ch[t];
        }return ret;
    }
    void ins(int x){add(x,1);}
    void del(int x){add(x,-1);}
    int qq(int x){return kth(rank(x)-1);}
    int hj(int x){return kth(rank(x+1));}
    bool empty(){return p[1].sum==0;}
}tr;
inline int read(){
    register int ret=0,f=1;register char c;
    for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;
    for(;isdigit(c);ret=(ret<<1)+(ret<<3)+c-'0',c=getchar());
    return ret*f;
}
const int N=800000;
int n,m,zhi[3*N]/*dian dao shu*/,rank[N]/*shu dao dian*/;
int main()
{
    n=read(),m=read();
    for(int i=1;i<=n;++i){
    	zhi[i+N]=read();rank[zhi[i+N]]=i+N;
    	tr.ins(i+N);
    }
    int h=N+1,t=2*N;
    while(m--){
        char s[10];
        scanf("%s",s);
        if(s[0]=='T'){
            int x=read();
            tr.del(rank[x]);--h;
            tr.ins(h);
            rank[x]=h;
            zhi[h]=x;
        }
        if(s[0]=='B'){
            int x=read();
            tr.del(rank[x]);++t;
            tr.ins(t);
            rank[x]=t;
            zhi[t]=x;
        }
        if(s[0]=='A'){
            int x=read();
            printf("%d\n",tr.rank(rank[x])-1);
        }
        if(s[0]=='Q'){
            int x=read();
            printf("%d\n",zhi[tr.kth(x)]);
        }
        if(s[0]=='I'){
            int x=read(),bz=read();
            int k=tr.rank(rank[x]);
            int from=rank[x];
            int to=tr.kth(k+bz);
            swap(zhi[from],zhi[to]);
            swap(rank[zhi[from]],rank[zhi[to]]);
        }
    }
}
```

---

## 作者：WHZ0325 (赞：4)

## 采用指针实现自顶向下的伸展树如何将指定编号的节点伸展到根节点

有没有人的伸展树是按《训练指南》上用指针自顶向下实现的？

书上是找到序列中第k个元素，将它伸展到树的根节点，而本题却要实现将编号为S的节点伸展到根节点，这时我们可以对原来的代码进行一些改进。

在表示伸展树节点的结构体中增加一个指针类型的元素，用于储存该节点的父节点：
```cpp
struct node {
	int v,s;
	node *fa,*ch[2];
};
```

方便起见，我们在维护时顺便将子节点结构体中的父节点更新为当前节点：
```cpp
inline void maintain() {
	s=ls()+1+rs();
	if(ch[0]!=NULL) ch[0]->fa=this;
	if(ch[1]!=NULL) ch[1]->fa=this;
}
```

然后额外定义一个指针类型的数组loc，loc\[i]表示储存着编号为i的节点的地址：
```cpp
node* loc[maxn];
```

每一次查询时，从该地址开始，沿着父节点向上，按照查找第k个元素反过来的方法（如果是父节点的左子节点继续递归，如果是父节点的右子节点则加上父节点左子树中的节点个数+1继续递归），统计得到该节点的在整个数列中的位置（也可以非递归实现）：
```cpp
int rank(node* o,node* root) {
	if(o==root) return 0;
	if(o->fa->ch[0]==o) return rank(o->fa,root);
	else if(o->fa->ch[1]==o) return rank(o->fa,root)+o->fa->ls()+1;
	return 0;
}
int rank(node* root,int tag) {
	return rank(loc[tag],root)+1+loc[tag]->ls();
}
```

如果待查找的节点在右子树中，那么根节点和左子树中的节点一定在待查找节点的左边，即对答案有贡献。

然后就可以执行伸展操作了。

（第一次在洛谷上写题解，如有错误，欢迎指出～～）

## 代码（Accepted）
```cpp
#include <cstdio>
#include <climits>
#include <algorithm>
const int maxn=80005;
namespace Splay {
	struct node {
		int v,s;
		node *fa,*ch[2];
		node(node* fa,int val):fa(fa),v(val) {s=1;ch[0]=ch[1]=NULL;}
		inline int ls() {return ch[0]!=NULL?ch[0]->s:0;}
		inline int rs() {return ch[1]!=NULL?ch[1]->s:0;}
		inline int cmp(int k) {return k<=ls()?0:1;}
		inline void maintain() {
			s=ls()+1+rs();
			if(ch[0]!=NULL) ch[0]->fa=this;
			if(ch[1]!=NULL) ch[1]->fa=this;
		}
	};
	node* loc[maxn];
	inline void rotate(node* &o,int d) {
		node* k=o->ch[d^1];o->ch[d^1]=k->ch[d];k->ch[d]=o;
		o->maintain();k->maintain();o=k;
	}
	void splay(node* &o,int k) {
		if(o==NULL||k<=0||o->s<k) return;
		if(o->ls()+1!=k) {
			int d=o->cmp(k);
			if(d==1) k-=o->ls()+1;
			node* &p=o->ch[d];
			if(p==NULL) {rotate(o,d^1);return;}
			if(p->ls()+1!=k) {
				int d2=p->cmp(k);
				if(d2==1) k-=p->ls()+1;
				splay(p->ch[d2],k);
				if(d==d2) rotate(o,d^1);
				else rotate(o->ch[d],d2^1);
			}
			rotate(o,d^1);
		}
	}
	node* build(node* fa,int l,int r,int val[]) {
		int mid=(l+r)>>1;
		node* o=new node(fa,val[mid]);
		loc[val[mid]]=o;
		if(l<=mid-1) o->ch[0]=build(o,l,mid-1,val);
		if(mid+1<=r) o->ch[1]=build(o,mid+1,r,val);
		o->maintain();
		return o;
	}
	int rank(node* o,node* root) {
		if(o==root) return 0;
		if(o->fa->ch[0]==o) return rank(o->fa,root);
		else if(o->fa->ch[1]==o) return rank(o->fa,root)+o->fa->ls()+1;
		return 0;
	}
	int rank(node* root,int tag) {
		return rank(loc[tag],root)+1+loc[tag]->ls();
	}
	node* kth(node* o,int k) {
		if(o->ls()+1==k) return o;
		else if(k<=o->ls()) return kth(o->ch[0],k);
		return kth(o->ch[1],k-o->ls()-1);
	}
}
using namespace Splay;
int val[maxn];
int main() {
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i) scanf("%d",&val[i]);
	node* root=build(NULL,1,n,val);
	char opt[10];int s,t;
	while(m--) {
		scanf("%s%d",opt,&s);
		if(opt[0]=='T') {
			int k=rank(root,s);
			splay(root,k);
			if(root->ch[1]!=NULL) {
				splay(root->ch[1],1);
				root->ch[1]->ch[0]=root->ch[0];root->ch[0]=NULL;
				root->ch[1]->maintain();
				root->maintain();
			}
			else {
				root->ch[1]=root->ch[0];
				root->ch[0]=NULL;
				root->maintain();
			}
		}
		else if(opt[0]=='B') {
			int k=rank(root,s);
			splay(root,k);
			if(root->ch[0]!=NULL) {
				splay(root->ch[0],root->ch[0]->s);
				root->ch[0]->ch[1]=root->ch[1];root->ch[1]=NULL;
				root->ch[0]->maintain();
				root->maintain();
			}
			else {
				root->ch[0]=root->ch[1];
				root->ch[1]=NULL;
				root->maintain();
			}
		}
		else if(opt[0]=='I') {
			scanf("%d",&t);
			if(t==0) continue;
			int k=rank(root,s);
			splay(root,k);
			node* newnode=kth(root,k+t);
			int d=(newnode==newnode->fa->ch[0])?0:1;
			if(newnode->fa==root) {
				int d=(newnode==newnode->fa->ch[0])?0:1;
				root->ch[d]=newnode->ch[d];
				newnode->ch[d]=root;
				std::swap(newnode->ch[d^1],root->ch[d^1]);
			}
			else {
				newnode->fa->ch[d]=root;
				std::swap(root->fa,newnode->fa);
				std::swap(root->ch[0],newnode->ch[0]);
				std::swap(root->ch[1],newnode->ch[1]);
			}
			root->maintain();
			newnode->maintain();
			root=newnode;
		}
		else if(opt[0]=='A') {
			int k=rank(root,s);
			printf("%d\n",k-1);
		}
		else if(opt[0]=='Q') {
			splay(root,s);
			printf("%d\n",root->v);
		}
	}
	return 0;
}
```

---

## 作者：白鲟 (赞：3)

## 前言
到本蒟蒻的[博客](https://www.luogu.com.cn/blog/bzlz-zdx/solution-p2596)来看看嘛？
## 题意简述
设计一种数据结构，使它在一个由 $[1,n]$ 的排列中支持以下操作：  

- 将值为 $x$ 的元素移到最前；    
- 将值为 $x$ 的元素移到最后；  
- 将值为 $x$ 的元素前置一位；  
- 将值为 $x$ 的元素后置一位；  
- 询问排在值为 $x$ 的元素前的元素个数（即排名减 $1$）；  
- 询问排名为 $x$ 的元素的值。  

## 题目分析
照例先考虑暴力做法：暴力维护该排列，并记录每一个值所对应的元素位置。这样，对于后四个操作，均可以做到 $\operatorname{O}(1)$ 的时间复杂度；但对于前两个操作而言，时间复杂度会高至 $\operatorname{O}(n)$。  

这时我们通常会做的是优化后者的时间复杂度（废话）。那么我们就需要考虑维护这一序列本质维护的内容（大雾）。  

我们可以发现，我们其实在维护的是每一个值所对应“位置”的有序。每个修改操作，我们都是改变了某些元素的“位置”，并使得这个序列按照“位置”重新有序。也就是说，对于 $[1,n]$ 中的每一个元素，我们为它附加了一个叫做“位置”的属性，并维护了一个有序的“位置”序列。而我们查询的内容则是这个序列当中排名为 $x$ 的元素对应的值，和值为 $x$ 的元素对应的“位置”在这一序列中的排名。这样看来，我们其实只需要维护“位置”序列的相对顺序就行了。这意味着我们并不需要像暴力算法那样改变所有很多元素的“位置”，而只需要改变少数元素的“位置”，并使得按我们构造出的“位置”排序的结果与我们需要的结果相同。  

要维护“位置”序列的有序，我们可以考虑使用平衡树。平衡树按照“位置”排序，并记录每一个“位置”所对应的值。同时，我们记录每一个值所对应的“位置”。问题的关键就转化为了如何减少操作的次数。由上面的分析得知，我们只需要维护“位置”序列的相对顺序，在将元素置顶的时候，我们实际上可以只改变该元素的“位置”为比当前最小“位置”更小的值，再将它插入平衡树；同理，将元素放到最后实际上等价于将它的“位置”改变为比当前最大“位置”更大的值再插入。前置和后置操作事实上是找到值为 $x$ 的元素的”位置“的前驱或后继，交换两个值对应的“位置”以及“位置”所对应的值。而对应查询操作，直接查询值 $x$ 所对应的“位置”的排名或”位置“排名为 $x$ 的元素所对应的值即可。每一项操作的时间复杂度均为 $\operatorname{O}(\log n)$。

## 代码
首先注意数组大小。由于我们对于前两个操作都涉及到新建结点，同时初始“位置”也需要 $n$ 个结点来存储，数组大小应该开到两倍。  

其次，如果是和我一样写了带旋 Treap，请注意根结点不一定是 $1$，每一个操作都应该从根结点而非 $1$ 开始进行（虽然大概也许似乎只有我会犯这种错误还卡了一天）。  

参照代码看上面的解释可能会清楚一点（毕竟我语文差得要命）……不过平衡树的操作实现太丑陋了（雾）……  

```cpp
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<ctime>
using namespace std;
int n,m,s,t,x,tot,root,temp,minn,maxn,no[300001],size[300001],priority[300001],position[300001],value[300001],child[300001][2];
char dir[10];
inline void rotate(int &now,bool opt)
{
	int t=child[now][opt];
	child[now][opt]=child[t][opt^1];
	child[t][opt^1]=now;
	size[t]=size[now];
	size[now]=size[child[now][0]]+size[child[now][1]]+1;
	now=t;
	return;
}
void insert(int &now,int x,int y)
{
	if(!now)
	{
		now=++tot;
		value[now]=x;
		priority[now]=rand();
		no[now]=y;
		size[now]=1;
		return;
	}
	++size[now];
	if(x<value[now])
	{
		insert(child[now][0],x,y);
		if(priority[child[now][0]]>priority[now])
			rotate(now,0);
	}
	else
	{
		insert(child[now][1],x,y); 
		if(priority[child[now][1]]>priority[now])
			rotate(now,1);
	}
	return;
}
void erase(int &now,int x)
{
	if(value[now]==x)
	{
		if(!child[now][0]||!child[now][1])
		{
			now=child[now][0]+child[now][1];
			return;
		}
		else if(priority[child[now][0]]>priority[child[now][1]])
			rotate(now,0);
		else rotate(now,1);
		erase(now,x);
		return;
	}
	--size[now];
	if(x<value[now])
		erase(child[now][0],x);
	else erase(child[now][1],x);
	return;
}
void change(int x,int dir)
{
	int now=root,res,loc;
	if(dir==1)
		while(now)
		{
			if(x<value[now])
			{
				res=now;
				now=child[now][0]; 
			}
			else if(x==value[now])
			{
				loc=now;
				now=child[now][1];
			}
			else now=child[now][1];
		}
	else while(now)
		{
			if(x>value[now])
			{
				res=now;
				now=child[now][1]; 
			}
			else if(x==value[now])
			{
				loc=now;
				now=child[now][0];
			}
			else now=child[now][0];
		}
	swap(position[no[res]],position[no[loc]]);
	swap(no[res],no[loc]);
	return;
}
int rank_of(int x)
{
	int res=0,now=root;
	while(now)
	{
		if(value[now]==x)
		{
			res+=size[child[now][0]]+1;
			break;
		}
		else if(value[now]<x)
		{
			res+=size[child[now][0]]+1;
			now=child[now][1];
		}
		else now=child[now][0];
	}
	return res;
}
int at(int x)
{
	int sum=0,now=root;
	while(now)
	{
		if(x==sum+size[child[now][0]]+1)
			return no[now];
		else if(x>sum+size[child[now][0]]+1)
		{
			sum+=size[child[now][0]]+1;
			now=child[now][1];
		}
		else now=child[now][0];
	}
	return -1;
}
int main()
{
	srand(unsigned(time(0)));
	scanf("%d%d",&n,&m);
	minn=1;
	maxn=n;
	for(int i=1;i<=n;++i)
	{
		scanf("%d",&x);
		insert(root,position[x]=i,x);
	}
	while(m--)
	{
		scanf("%s%d",dir,&s);
		switch(dir[0])
		{
			case 'T':
				erase(root,position[s]);
				insert(root,position[s]=--minn,s);
				break;
			case 'B':
				erase(root,position[s]);
				insert(root,position[s]=++maxn,s);
				break;
			case 'I':
				scanf("%d",&t);
				if(!t)
					continue;
				change(position[s],t);
				break;
			case 'A':
			 	printf("%d\n",rank_of(position[s])-1);
			 	break;
			default:
				printf("%d\n",at(s));
		}
	}
	return 0;
}
```

---

## 作者：2018LZY (赞：3)

## 平衡树。需支持五个操作：

1、 将某元素置顶：将元素旋到根，然后将左子树合并到该元素的后继

2、 将某元素置底：将元素旋到根，然后将右子树合并到该元素的前驱

3、 将某元素提前/滞后1位：直接与该元素的前驱/后继交换位置

4、 询问指定元素排名：将元素旋到根，输出左子树的节点数

5、 询问指定排名元素：树上查找

## 温馨提示：如果没有前驱或后继有时则需特殊处理：

1. 若无前驱，则证明x已经在顶部，无需额外操作，直接return。$~~~~~~~~~~~~~~~~~~~~~~~~$                  若无后继，则证明x在底部，此时只需把左子树变为右子树即可。
2. 若无后继，则证明x已经在底部，无需额外操作，直接return。$~~~~~~~~~~~~~~~~~~~~~~~~$
   若无前驱，则证明x在顶部，此时只需把右子树变为左子树即可。
3. 若本来要跟前驱（后继）交换位置，但没有前驱（后继），则不操作。$~~~~~~~~~~~~~~~~~~~~~~~~$（数据正确其实就不用注意这个）


### 本人代码与别人最不一样的是少了编号映射，这样其实会加速。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define g getchar()
#define lc tr[x].son[0]
#define rc tr[x].son[1]
using namespace std;
const int N=8e4+10;
inline void qr(int &x)
{
    char c=g;bool v=x=0;
    while(!( ('0'<=c&&c<='9') || c=='-' ))c=g;
    if(c=='-')v=1,c=g;
    while('0'<=c&&c<='9')x=x*10+c-'0',c=g;
    if(v)x=-x;
}
inline void write(int x)
{
    if(x/10)write(x/10);
    putchar(x%10+'0');
}
inline void pri(int x)
{
	write(x);puts("");
}
struct trnode
{
    int c,f,son[2];
    //节点数，父亲，孩子 
}tr[N];int root;
int n,m,a[N];
inline void update(int x){tr[x].c=tr[lc].c+tr[rc].c+1;}
inline void bt(int &x,int f,int l,int r)
//注意x是引用。平衡树中序遍历得到的编号与序列中的一一对应。编号对应就不用映射啦。 
//递归建树会更加平衡。 
{
    if(l>r){x=0;return;}
    int mid=(l+r)>>1;
    x=a[mid];
    tr[x].f=f;
    bt(lc,x,l,mid-1);
    bt(rc,x,mid+1,r);
    update(x);
}
inline void rotate(int x,int w)
{
    int f=tr[x].f,ff=tr[f].f,r,R;
    
    r=tr[x].son[w];R=f;
    tr[R].son[1-w]=r;
    if(r)tr[r].f=R;
    r=x;R=ff;
    if(tr[R].son[0]==f)tr[R].son[0]=r;
    else tr[R].son[1]=r;
    tr[r].f=R;
    r=f;R=x;
    tr[R].son[w]=r;
    tr[r].f=R;
    
    update(f);
    update(x);
}
inline void splay(int x,int rt)
{
    while(tr[x].f!=rt)
    {
        int f=tr[x].f,ff=tr[f].f;
        if(ff==rt)
        {
        	if(tr[f].son[0]==x)rotate(x,1);
        	else rotate(x,0);
        }
        else
        {
                 if(tr[ff].son[0]==f&&tr[f].son[0]==x)rotate(f,1),rotate(x,1);
            else if(tr[ff].son[1]==f&&tr[f].son[1]==x)rotate(f,0),rotate(x,0);
            else if(tr[ff].son[0]==f&&tr[f].son[1]==x)rotate(x,0),rotate(x,1);
            else if(tr[ff].son[1]==f&&tr[f].son[0]==x)rotate(x,1),rotate(x,0);//这句判断其实没啥用，直接else就够了。 
        }
    }
    if(!rt)root=x;
}
inline int findqianqu(int x)
{
    x=lc;
    while(rc)x=rc;
    return x;
}
inline int findhouji(int x)
{
    x=rc;
    while(lc)x=lc;
    return x;
}
//1
inline void top(int x)
{
    splay(x,0);if(!lc)return;//x本来就在顶部 
    if(!rc){rc=lc;lc=0;return;}//无后继。 
    int y=findhouji(x);
    splay(y,x);
    tr[y].son[0]=tr[x].son[0];
    tr[tr[y].son[0]].f=y;
    tr[x].son[0]=0;
    update(y);
}
//2
inline void bottom(int x)
{
    splay(x,0);if(!rc)return;//x本来就在底部 
    if(!lc){lc=rc;rc=0;return;}
    int y=findqianqu(x);
    splay(y,x);
    tr[y].son[1]=tr[x].son[1];
    tr[tr[y].son[1]].f=y;
    tr[x].son[1]=0;
    update(y);
}
//3
inline void call(int x)
{
    tr[lc].f=x;tr[rc].f=x;
}
inline void ins(int x,int w)
{
    splay(x,0);
    int y;
    if(w==-1)//跟前驱交换 
    {
        if(!lc)return;//无前驱
        y=findqianqu(x);
        splay(y,x);
        swap(tr[x].son[1],tr[y].son[1]);
        tr[x].son[0]=tr[y].son[0]; tr[y].son[0]=x;
    }
    else//跟后继交换 
    {
        if(!rc)return;//无后继
        y=findhouji(x);
        splay(y,x);
        swap(tr[x].son[0],tr[y].son[0]);
        tr[x].son[1]=tr[y].son[1];tr[y].son[1]=x;
    }
    call(x);call(y);
    swap(tr[x].c,tr[y].c);
    root=y;tr[y].f=0; 
}
//4
inline int find_rank(int x){splay(x,0);return tr[lc].c;}
//5
inline int findnum(int k)
{
    int x=root;
    while(1)
    {
        if(tr[lc].c>=k)x=lc;
        else if(tr[lc].c+1>=k)break;
        else k-=tr[lc].c+1,x=rc;
    }
    return x;
}
int main()
{
    qr(n);qr(m);
    for(int i=1;i<=n;i++)qr(a[i]);
    bt(tr[0].son[0],0,1,n);root=tr[0].son[0];tr[0].son[0]=0;//0不能有孩子 
    while(m--)
    {
        char s[21];int x,y;
        scanf("%s",s);qr(x);
        if(s[0]=='T')top(x);
        else if(s[0]=='B')bottom(x);
        else if(s[0]=='I')
        {
            qr(y);
			if(y!=0)ins(x,y);
        }
        else if(s[0]=='A')pri(find_rank(x));
        else pri(findnum(x));
    }
    return 0;
}
```


---

## 作者：joe19025 (赞：3)

## 解题方法
### 储备技能
1 Treap

~~2 splay~~

### 大体思路

**将每一本书的编号和一个权值联系起来，通过权值的大小，在treap中不同的位置，达到插入到不同位置的需求。**

就比如说，初始状态权值是[1,n]

第一本书是1，第二本书是2，第三本书是3，直到第n本书是n。

如果想要把一本书插入到顶端，就把他的权值改成0，如果想把它放到底下，就改成n+1.每次修改完位置以后，权值的范围会有所改变，改变范围，好以此类推。


**总之就是用a[i]数组记录编号为i的书的权值，通过维护数组和treap，来AC**

剩下的一些细节见代码吧。



------------

## Code
```cpp
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <vector>
#define MAXN 80005
using namespace std;

//treap
struct treap{
    treap *ch[2];
    int v;
    int r;
    int id;
    int sz;
    void maintain()
    {
        sz=1;
        if(ch[0])sz+=ch[0]->sz;
        if(ch[1])sz+=ch[1]->sz;
    }
    
    int cmp(int k)
    {
        if(v==k)
            return -1;
        else
            return k<v?0:1;
    }
}pool[MAXN*2];
int tot=0;
void rotate(treap *&o,int d)
{
    treap *k=o->ch[d^1];
    o->ch[d^1]=k->ch[d];
    k->ch[d]=o;
    o->maintain();
    k->maintain();
    o=k;
}
void insert(treap *&o,int k,int id)
{
    if(o==NULL)
    {
        o=&pool[tot++];
        o->v=k;
        o->r=rand();
        o->ch[0]=o->ch[1]=NULL;
        o->sz=1;
        o->id=id;
        return;
    }
    int d=o->cmp(k);
    if(d==-1)
        return;
    insert(o->ch[d],k,id);
    if(o->ch[d]->r>o->r)rotate(o,d^1);
    o->maintain();
}
void remove(treap *&o,int k)
{
    int d=o->cmp(k);
    if(d==-1)
    {
        if(o->ch[0]==NULL)o=o->ch[1];
        else if(o->ch[1]==NULL)o=o->ch[0];
        else
        {
            int d2=(o->ch[0]->r>o->ch[1]->r)?1:0;
            rotate(o,d2);
            remove(o->ch[d2],k);
        }
    }
    else
    {
        remove(o->ch[d],k);
    }
    if(o)
    o->maintain();
}
int getrank(treap *o,int k)
{
    int d=o->cmp(k);
    int z=(o->ch[0]==NULL)?0:o->ch[0]->sz;
    if(d==-1)
    {
        return z+1;
    }
    if(d==0)
    {
        return getrank(o->ch[0],k);
    }
    else
        return getrank(o->ch[1],k)+1+z;
}
int getkth(treap *o,int k)
{
    int d=(o->ch[0]==NULL)?0:o->ch[0]->sz;
    if(k<=d)
        return getkth(o->ch[0],k);
    if(k==1+d)
        return o->id;
    else
        return getkth(o->ch[1],k-1-d);
}

int main()
{
    //build tree
    int n,m;
    treap *root=NULL;
    scanf("%d%d",&n,&m);
    int l=1,r=n;
    int a[MAXN];
    for(int i=1;i<=n;i++)
    {
        int x;
        scanf("%d",&x);
        a[x]=i;
        insert(root,i,x);
    }
    
    //operations
    for(int i=1;i<=m;i++)
    {
        char s[10];
        scanf("%s",s);
        if(s[0]=='T')
        {
            int x;
            scanf("%d",&x);
            remove(root,a[x]);
            insert(root,l-1,x);
            a[x]=l-1;
            l-=1;
        }
        if(s[0]=='B')
        {
            int x;
            scanf("%d",&x);
            remove(root,a[x]);
            insert(root,r+1,x);
            a[x]=r+1;
            r+=1;
        }
        if(s[0]=='I')
        {
            int x,y;
            scanf("%d%d",&x,&y);
            if(y==0)
                continue;
            int z=getkth(root,getrank(root,a[x])+y);
            remove(root,a[x]);
            remove(root,a[z]);
            insert(root,a[z],x);
            insert(root,a[x],z);
            swap(a[x],a[z]);
        }
        if(s[0]=='A')
        {
            int x;
            scanf("%d",&x);
            printf("%d\n",getrank(root,a[x])-1);
        }
        if(s[0]=='Q')
        {
            int x;
            scanf("%d",&x);
            printf("%d\n",getkth(root,x));
        }
    }
    return 0;
}
```

---

## 作者：tttnns (赞：3)

```cpp
#include<cstdio>
#include<vector>
using namespace std;
int n,m;
#define maxn 100000
int lst[maxn];
int
    f[maxn],
    c[maxn][2],
    s[maxn],
    k[maxn],
    id[maxn],
    root,size=0;
void pushup(int x){
    s[x]=s[c[x][0]]+s[c[x][1]]+1;   //一个节点的规模等于子节点规模之和+1
}
int rotate(int i){
    int fa=f[i];    //取得父亲
    int d=(c[fa][1]==i);    //如果子节点是父节点的右子节点，为1，否则为0
    f[i]=f[fa]; //将子节点的父亲改为祖父
    if(fa>0) //父亲不是根
        c[f[fa]][c[f[fa]][1]==fa]=i;    //将祖父的儿子中父亲的位置给儿子
    if(c[fa][d]=c[i][!d])   //将父亲中儿子的位置给另一侧的孙子
        f[c[i][!d]]=fa; //改变孙子关系为儿子关系
    f[fa]=i;    //将父亲改为孙子
    c[i][!d]=fa;
    pushup(fa);
    return i;
/*******************************
source:
 2   -> fa
 |
1 4  -> i
  |
 3 5
 
d -> 1
 
step1:
  4  -> i     2  -> fa
    |           |
 3 5         1
 
step2:
  4  -> i     2  -> fa
    |           |
 3 5         1 |
 |-------------|
 
step3:
  4  -> i     2  -> fa
    |           |
   5         1 3
 
step4:
       4  -> i
         |
fa -> 2 5
        |
     1 3
*******************************/
}
void splay(int i,int p){
    for(int fa=f[i];fa!=p;fa=f[rotate(i)])  //旋转上升
        if(f[fa]!=p)
            if(c[fa][1]==i ^ c[f[fa]][1]==fa)   //不共线
                rotate(i);
            else
                rotate(fa);
    pushup(i);
    if(!f[i]) root=i;   //无亲者乃王者也
 
/*************************
source:
1    -> p
|
 2
 |
  3  -> i
 
step1:
1
|
 3   -> i
 |
2
 
step2:
  3  -> i -> root
    |
 1
 |
  2
 
 
source:
1
|
 3
 |
2    -> i
 
step1:
 3
 |
1
|
 2   -> i
 
step2:
  3
  |
 2   -> i
 |
1
 
step3:
  2  -> i -> root
    |
 1 3
*************************/
}
int make(int fa,int l,int r){
    if(l>r) return 0;
    int m=(l+r)/2;
    int i=++size;
    f[i]=fa;
    k[i]=lst[m];    //将该节点映射到书编号上
    id[lst[m]]=i;   //将书编号映射到该节点上
    //二分，左侧小于，右侧大于
    c[i][0]=make(i,l,m-1);
    c[i][1]=make(i,m+1,r);
    pushup(i);
    return i;
}
int check(int t,int i){ //返回极侧叶子
    if(c[i][t]==0) return i;
    return check(t,c[i][t]);
}
void move(int t,int i){
    splay(i,0); //管它是什么，旋转上来再说
    if(c[i][1]>0){   //如果右边有节点
        int x=check(0,c[i][1]);
        splay(x,i); //使右子节点只有右子树
        c[x][0]=c[i][0];    //把左侧搞成右子节点的左子树
        f[c[x][0]]=x;
        pushup(x);
        f[x]=0;
        root=x; //拍屁股走人
    }else{  //没什么事
        f[c[i][0]]=0;
        root=c[i][0];
    }
    f[i]=c[i][0]=c[i][1]=0; //孤儿
    f[root]=i;  //让根变成自己的儿子
    c[i][t]=0;
    c[i][!t]=root;
    pushup(i);
    root=i;
    //splay(i,0);   //然而觉得这句话没卵用
}
void exchange(int t,int i){
    splay(i,0); //先转上来
    if(c[i][t]==0) return;  //没得换
    int x=check(!t,c[i][t]);    //找到左边极右，右边极左
    swap(k[i],k[x]);    //交换绑定
    id[k[i]]=i;
    id[k[x]]=x;
}
int ask(int i,int key){ //找序号对应
    int t=s[c[i][0]];
    if(key<=t) return ask(c[i][0],key);
    if(key>t+1) return ask(c[i][1],key-t-1);
    return k[i];
}
void awd(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i){
        int t;
        scanf("%d",&t);
        lst[i]=t;
    }
    root=make(0,1,n);
    while(m--){
        char st[32];
        int ss;
        scanf("%s%d",st,&ss);
        switch(st[0]){
            case 'T':
                move(0,id[ss]);
                break;
            case 'B':
                move(1,id[ss]);
                break;
            case 'I':{
                int tt;
                scanf("%d",&tt);
                if(tt) exchange(tt==1,id[ss]);
                break;
            }
            case 'A':
                splay(id[ss],0);
                printf("%d\n",s[c[id[ss]][0]]);
                break;
            case 'Q':
                printf("%d\n",ask(root,ss));
                break;
        }
    }
}
int main(){
    return awd(),0;
}
```

---

## 作者：Edward_Elric (赞：2)

## 思路
在这里提供一种新思路，不同于子树合并。虽然效率会低一些，但复杂度是对的

我们虚拟一个节点高度，把高度作为数列进行维护

其实很好想


T：删除编号为S的书，插入一个虚拟高度为当前最小且编号为S的书

B：同T，插入虚拟高度为当前最大

I：交换前驱或后继的信息

A：查询rank

Q：查询kth

## 代码
```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
using namespace std;
const int maxn=1000000+100;
int ch[maxn][2],fa[maxn],size[maxn],cnt[maxn],id[maxn],val[maxn],pos[maxn];
char op[10];
//id表示节点编号，val表示节点虚拟高度,pos表id所在位置 
int root,ncnt;
int mi,mx;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    return x*f;
}
void output(int u=root)
{
    if(ch[u][0])output(ch[u][0]);
    if(val[u]==inf||val[u]==-inf)return;
    printf("%d ",id[u]);
    if(ch[u][1])output(ch[u][1]);
}
void pushup(int u)
{
    size[u]=size[ch[u][0]]+size[ch[u][1]]+cnt[u];
}
int chk(int u)
{
    return ch[fa[u]][1]==u;
}
void rotate(int u)
{
    int f=fa[u],ff=fa[f],k=chk(u),s=ch[u][k^1];
    ch[f][k]=s,fa[s]=f;
    ch[ff][chk(f)]=u,fa[u]=ff;
    ch[u][k^1]=f,fa[f]=u;
    pushup(u),pushup(f);
}
void splay(int u,int goal=0)
{
    while(fa[u]!=goal)
    {
        int f=fa[u],ff=fa[f];
        if(ff!=goal)
        {
            if(chk(u)==chk(f))rotate(f);
            else rotate(u);
        }
        rotate(u);
    }
    if(!goal)root=u;
}
void insert(int x,int y)
{
    int u=root,f=0;
    while(u&&val[u]!=x)
    f=u,u=ch[u][x>val[u]];
    u=++ncnt;
    if(f)ch[f][x>val[f]]=u;
    fa[u]=f,val[u]=x,id[u]=y,pos[y]=u;
    size[u]=cnt[u]=1;
    ch[u][0]=ch[u][1]=0;
    splay(u);
} 
int kth(int k)
{
    int u=root;
    while(1)
    {
        if(ch[u][0]&&k<=size[ch[u][0]])
        u=ch[u][0];
        else if(k>size[ch[u][0]]+cnt[u])
        k-=size[ch[u][0]]+cnt[u],u=ch[u][1];
        else return u; 
    }
}
int ask(int x)
{
    splay(pos[x]);
    return size[ch[root][0]]-1;
}
int pre(int u)
{
    splay(u);
    u=ch[root][0];
    while(ch[u][1])u=ch[u][1];
    return u;
}
int succ(int u)
{
    splay(u);
    u=ch[root][1];
    while(ch[u][0])u=ch[u][0];
    return u;
}
void remove(int u)
{
    int last=pre(u),next=succ(u);
    splay(last),splay(next,last);
    ch[next][0]=0;
}
void top(int s)
{
    remove(pos[s]);
    insert(--mi,s);
}
void bottom(int s)
{
    remove(pos[s]);
    insert(++mx,s);
}
void change(int u,int o)
{
	int now=pos[u];
    if(o==1)
    {
        int next=succ(now);
        if(!id[next])return;
        pos[u]=next,pos[id[next]]=now;//出错几次死在这里
        swap(id[now],id[next]);
    }
    if(o==-1)
    {
        int last=pre(now);
        if(!id[last])return;
        pos[u]=last,pos[id[last]]=now;
        swap(id[now],id[last]);
    } 
}

int main()
{
    insert(inf,0),insert(-inf,0);
    int n=read(),m=read();
    mi=0,mx=n+1;
    for(int i=1;i<=n;i++)
    insert(i,read());
    for(int i=1;i<=m;i++)
    {
        cin>>op;
        if(op[0]=='T'){int x=read();top(x);}
        if(op[0]=='B'){int x=read();bottom(x);}
        if(op[0]=='I'){int x=read(),y=read();change(x,y);}
        if(op[0]=='A'){int x=read();printf("%d\n",ask(x));}
        if(op[0]=='Q'){int x=read();printf("%d\n",id[kth(x+1)]);} 
    }
    return 0;
}
```
主要是因为太蒻，~~一篇题解也没看懂~~

---

## 作者：codesonic (赞：2)

用小众的WBLT实现的这道题

定义优先级越小，那本书就放越上面

设$a_i$为编号为$i$的书本的优先级，$mapp_i$为优先级为i的节点编号。

Top S:将优先级变为最小再插入

Bottom S：将优先级变为最大再插入

Insert S T：找到对应两本书 交换优先级

Ask S：查询优先级排名

Query S：查询第k小的优先级对应的编号

然后就是裸的平衡树题了

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<map>

using namespace std;

const int maxn=400010;
const int ratio=5;

inline int read(){
    register int Num=0,flag=1;char ch;
    while((ch=getchar())<'0'||ch>'9') if(ch=='-') break;
    if(ch=='-') flag=-1; else Num=ch-'0';
    while((ch=getchar())>='0'&&ch<='9') Num=Num*10+ch-'0';
    return Num*flag; 
}
inline void out(int x){
    if(x>=10) out(x/10);
    putchar(x%10+'0');
}

int n,m,cnt,fa,root;
int size[maxn],ls[maxn],rs[maxn],val[maxn],a[maxn];
int mapp[maxn];

inline void newnode(int &cur,int v) {
    cur=++cnt;
    size[cur]=1;
    val[cur]=v;
}

inline void copynode(int x,int y) {
    size[x]=size[y];
    ls[x]=ls[y],rs[x]=rs[y];
    val[x]=val[y];
}

inline void merge(int l,int r) {
    size[++cnt]=size[l]+size[r];
    val[cnt]=val[r];
    ls[cnt]=l,rs[cnt]=r;
}

inline void rotate(int cur,bool flag) {
    if(flag) {
        merge(ls[cur],ls[rs[cur]]);
        ls[cur]=cnt;
        rs[cur]=rs[rs[cur]];
    } else {
        merge(rs[ls[cur]],rs[cur]);
        rs[cur]=cnt;
        ls[cur]=ls[ls[cur]];
    }
}

inline void maintain(register int cur) {
    if(size[ls[cur]]>size[rs[cur]]*ratio)
        rotate(cur,0);
    else if(size[rs[cur]]>size[ls[cur]]*ratio)
        rotate(cur,1);
}

inline void pushup(int cur) {
    if(!size[ls[cur]])return ;
    size[cur]=size[ls[cur]]+size[rs[cur]];
    val[cur]=val[rs[cur]];
}

inline int minn(int a,int b) {
    return a<b?a:b;
}
inline int maxx(int a,int b) {
    return a>b?a:b;
}

inline void insert(int cur,int x) {
    if(size[cur]==1) {
        newnode(ls[cur],minn(x,val[cur]));
        newnode(rs[cur],maxx(x,val[cur]));
        pushup(cur);
        return ;
    }
    maintain(cur);
    insert(x>val[ls[cur]]?rs[cur]:ls[cur],x);
    pushup(cur);
}

inline void erase(int cur,int x) {
    if(size[cur]==1) {
        cur= ls[fa]==cur?rs[fa]:ls[fa];
        copynode(fa,cur);
        return ;
    }
    maintain(cur);
    fa=cur;
    erase(x>val[ls[cur]]?rs[cur]:ls[cur],x);
    pushup(cur);
}

inline int find(int cur,int x) {
    if(size[cur]==x)
        return val[cur];
    maintain(cur);
    if(x>size[ls[cur]])
        return find(rs[cur],x-size[ls[cur]]);
    return find(ls[cur],x);
}

inline int rnk(int cur,int x) {
    if(size[cur]==1)
        return 1;
    maintain(cur);
    if(x>val[ls[cur]])
        return rnk(rs[cur],x)+size[ls[cur]];
    return rnk(ls[cur],x);
}

char opt[20];
int k,l,r,i;

int main() {
    n=read();
    m=read();
    newnode(root,(1<<30));
    l=233333,r=n+233333;
    for(i=1; i<=n; i++) {
        int qaq;
        qaq=read();
        insert(root,i+233333);
        a[qaq]=i+233333;
        mapp[i+233333]=qaq;
    }
    while(m--) {
        scanf("%s",opt);
        if(opt[0]=='Q') {
            k=read();
            out(mapp[find(root,k)]);
            putchar('\n');
        } else if(opt[0]=='A') {
            k=read();
            out(rnk(root,a[k])-1);
            putchar('\n');
        } else if(opt[0]=='T') {
            k=read();
            erase(root,a[k]);
            insert(root,--l);
            a[k]=l;
            mapp[l]=k;
        } else if(opt[0]=='B') {
            k=read();
            erase(root,a[k]);
            insert(root,++r);
            a[k]=r;
            mapp[r]=k;
        } else if(opt[0]=='I') {
            register int s=read(),t=read();
            if(t==1) {
                int rnk2=rnk(root,a[s]),rnk1=rnk2+1;//优先级排名
                int s2=find(root,rnk1);
                s2=mapp[s2];
                erase(root,a[s]);
                erase(root,a[s2]);
                swap(a[s],a[s2]);
                mapp[a[s]]=s;
                mapp[a[s2]]=s2;
                insert(root,a[s]);
                insert(root,a[s2]);
            } else if(t==-1) {
                int rnk2=rnk(root,a[s]),rnk1=rnk2-1;//优先级排名
                int s2=find(root,rnk1);
                s2=mapp[s2];
                erase(root,a[s]);
                erase(root,a[s2]);
                swap(a[s],a[s2]);
                mapp[a[s]]=s;
                mapp[a[s2]]=s2;
                insert(root,a[s]);
                insert(root,a[s2]);
            }
        }

    }
}
```

---

## 作者：iodwad (赞：2)

[Welcome to my Blog](https://zcdhj.org)

Splay 入门好题。

我竟然 1A 了，感动

对于 `Top` 操作，我们可以将 $S$ 删去，再插入到 Splay 的最左端，`Bottom`操作同理。`Insert`操作就是交换 $S$ 与前驱/后继的位置。

但是这里 Splay 维护的是一棵区间树，不好找到 $S$ 的位置，所以我们用 $n$ 个指针存每个数的位置。

希望这里的代码对指针党有帮助 qwq

```cpp
#include <iostream>
#include <cstdio>

const int MAXN = 8e4;

int n, m;
int a[MAXN | 1];

inline int read() {
	register int x = 0, v = 1;
	register char ch = getchar();
	while(!isdigit(ch)) { if(ch == '-') v = -1; ch = getchar(); }
	while(isdigit(ch)) { x = x * 10 + ch - '0'; ch = getchar(); }
	return x * v;
}

namespace Splay {
	struct Splay {
		int val, size;
		Splay *ch[2], *father;
		Splay() {}
		Splay(int _val, Splay *_father) : val(_val), size(1), father(_father) { ch[0] = ch[1] = NULL; }
	} *root, *pos[MAXN | 1]; // 这里的 pos 存的就是每个数的位置
	inline int size(Splay *o) { return o == NULL ? 0 : o -> size; }
	inline int whichSon(Splay *o) { return o -> father == NULL ? 0 : o -> father -> ch[1] == o; }
	inline void pushup(Splay *o) { o -> size = 1 + size(o -> ch[0]) + size(o -> ch[1]); }
	inline void connect(Splay *x, Splay *y, int which) {
		if(x) x -> father = y;
		if(y) y -> ch[which] = x;
		else root = x;
	}
	inline void rotate(Splay *o) { 
		Splay *p = o -> father, *q = p -> father;
		int which = whichSon(o);
		connect(o, q, whichSon(p));
		connect(o -> ch[which ^ 1], p, which);
		connect(p, o, which ^ 1);
		pushup(p);
 	}
 	inline void splay(Splay *o, Splay *goal = NULL) {
 		while(o -> father != goal) {
 			Splay *p = o -> father, *q = p -> father;
 			q != goal ? rotate(whichSon(o) ^ whichSon(p) ? o : p) : rotate(o);
 		}
 		pushup(o);
 	}
 	inline void remove(int x) {
 		splay(pos[x]);
 		Splay *o = root;
 		if(o -> ch[0] == NULL) {
 			root = o -> ch[1];
 			if(root) root -> father = NULL;
 			delete o;
 		} else {
 			Splay *tmp = root -> ch[0];
 			while(tmp -> ch[1]) tmp = tmp -> ch[1];
 			splay(tmp, root);
 			root = tmp;
 			connect(o -> ch[1], root, 1);
 			root -> father = NULL;
 			delete o;
 		}
 	}
 	inline void Top(int x) {
 		remove(x);
 		Splay *o = root;
 		while(o -> ch[0]) o = o -> ch[0];
 		o -> ch[0] = new Splay(x, o);
 		pos[x] = o -> ch[0];
 		splay(o -> ch[0]);
 	}
 	inline void Bottom(int x) {
 		remove(x);
 		Splay *o = root;
 		while(o -> ch[1]) o = o -> ch[1];
 		o -> ch[1] = new Splay(x, o);
 		pos[x] = o -> ch[1];
 		splay(o -> ch[1]);
 	}
 	inline void Insert(int val, int opt) {
 		if(opt == 0) return;
 		else if(opt == -1) {
 			splay(pos[val]);
 			Splay *o = root -> ch[0];
 			if(o == NULL) return;
 			while(o -> ch[1]) o = o -> ch[1];
 			std::swap(pos[val], pos[o -> val]);
 			std::swap(root -> val, o -> val);
 		} else {
 			splay(pos[val]);
 			Splay *o = root -> ch[1];
 			if(o == NULL) return;
 			while(o -> ch[0]) o = o -> ch[0];
 			std::swap(pos[val], pos[o -> val]);
 			std::swap(root -> val, o -> val);
 		}
 	}
 	inline int Ask(int x) {
 		splay(pos[x]);
 		return size(root -> ch[0]);
 	}
 	inline int Query(int k) {
 		Splay *o = root;
 		while(1) {
 			if(size(o -> ch[0]) < k && size(o -> ch[0]) + 1 >= k) return o -> val;
 			else if(size(o -> ch[0]) >= k) o = o -> ch[0];
 			else {
 				k -= size(o -> ch[0]) + 1;
 				o = o -> ch[1];
 			}
 		}
 	}
 	void build(Splay *&o = root, Splay *fa = NULL, int l = 1, int r = n) {
 		if(l > r) return;
 		int mid = (l + r) >> 1;
 		o = new Splay(a[mid], fa);
 		pos[a[mid]] = o;
 		build(o -> ch[0], o, l, mid - 1);
 		build(o -> ch[1], o, mid + 1, r);
 		pushup(o);
 	}
}

int main() {
	n = read(); 
	m = read();
	for(int i = 1; i <= n; ++i) a[i] = read();
	Splay::build();
	while(m--) {
		char opt[10];
		scanf("%s", opt);
		if(*opt == 'T') Splay::Top(read());
		else if(*opt == 'B') Splay::Bottom(read());
		else if(*opt == 'I') {
			int a = read(), b = read();
			Splay::Insert(a, b);
		} else if(*opt == 'A') printf("%d\n", Splay::Ask(read()));
		else printf("%d\n", Splay::Query(read()));
	}
	return 0;
}
```



---

## 作者：Achtoria (赞：2)

## 看到题解里没有无指针Treap的，来一篇无指针Treap的题解

~~这个题也是万年调不出系列~~

### 1. 对于操作一

$\text{窝们可以对与每一本数按照从上到下从大到小赋一个权值，那么为了方便操作} $

$\text{一二窝们可以在权值之前预留N个空位，同样的在后面预留N个空位，记top和} $

$\text{bottom表示当前的第一个权值和最后一个权值，那么把一本书放到最顶上，转} $

$\text{化为找到当前这个节点的值，在Treap里删掉，然后把这个节点以top-1的权值} $

$\text{加入平衡树，然后top- -。这样就操作一就完啦QAQ} $


### 2. 对于操作二

$\text{与操作一一样的操作，相应的把bottom++就行了。} $

### 3. 对于操作三

~~最毒瘤的操作~~

$\text{窝们首先可以找到编号为x的书在Treap中的权值是多少，记为fx} $

$\text{以T=1为例} $

$\text{窝们可以在平衡树中找到fx的后继，然后窝们可以定义一个数组inv[fx]=x} $

$\text{即表示权值为fx的编号为x。}$

$\text{这样我们就把x和它的后继的编号交换一下就行了。} $

$\text{T=-1的时候就找到前驱然后就跟T=1一样的操作了} $

$\text{T=0时，直接跳过就好了。} $

### 4. 对于操作四

$\text{找到编号x的权值fx,然后在Treap中统计fx的排名} $

### 5. 对于操作五

$\text{找到Treap中前x的数的编号就行了。} $

### 大家最想看的来了 
[代码戳这里](https://paste.ubuntu.com/p/JxHyQ6Xvzx/)

$\text{下面附赠几组数据} $

```
data1.in
8 8
1 2 3 4 5 6 7 8
Insert 4 -1
Bottom 7
Query 7
Ask 6
Top 4
Ask 3
Bottom 5
Top 4

data1.out
8
5
3

data1.in
10 2
2 4 3 8 1 10 6 9 7 5
Insert 4 1
Query 4

data1.out
3

```


---

## 作者：Isonan (赞：2)

原题传送门[>Here<](https://www.luogu.org/problemnew/show/P2596)

很裸的一道平衡树题。

1：删除一个节点，并将其放在树的最左边；

2：删除一个节点，并将其放在树的最右边；

3：将一个节点与它的前驱/后继交换位置；

4：查询一个节点的排名；

5：查询排名为k的节点。

于是照着模拟就行了。

代码：

```cpp
#include <cstdio>

int fa[80001],ch[80001][2],val[80001],size[80001],cnt,root,backw[80001],num[80001],n,m,t1,t2;
char str[101];
bool son(int x){return ch[fa[x]][1]==x;}
void pushup(int x){size[x]=size[ch[x][0]]+size[ch[x][1]]+1;}
int build(int l,int r,int f){
	if(l>r)return 0;
	int id=++cnt;
	fa[id]=f;
	int mid=(l+r)>>1;
	val[id]=num[mid];
	backw[num[mid]]=id;
	ch[id][0]=build(l,mid-1,id);
	ch[id][1]=build(mid+1,r,id);
	pushup(id);
	return id;
}
void Rotate(int x){
	if(!x||!fa[x])return;
	if(root==fa[x])root=x;
	int faz=fa[x],fazz=fa[faz],g=son(x);
	fa[x]=fazz;
	ch[fazz][son(faz)]=x;
	fa[ch[x][!g]]=faz;
	ch[faz][g]=ch[x][!g];
	fa[faz]=x;
	ch[x][!g]=faz;
	pushup(faz);
	pushup(x);
}
void splay(int x,int ance){
	while(fa[x]!=ance){
		if(fa[fa[x]]!=ance)
			if(son(x)^son(fa[x]))Rotate(x);
			else Rotate(fa[x]);
		Rotate(x);
	}
}
int min(int x){
	while(ch[x][0])x=ch[x][0];
	return x;
}
int max(int x){
	while(ch[x][1])x=ch[x][1];
	return x;
}
void erase(int x){
	splay(x,0);
	if(ch[root][0]){
		splay(max(ch[root][0]),root);
		ch[ch[root][0]][1]=ch[root][1];
		fa[ch[root][1]]=ch[root][0];
		fa[ch[root][0]]=0;
		pushup(ch[root][0]);
		root=ch[root][0];
	}
	else{
		fa[ch[root][1]]=0;
		root=ch[root][1];
	}
	ch[x][0]=ch[x][1]=0;
}
int rank(int node){
	int tot=size[ch[node][0]];
	while(node){
		if(son(node))tot+=size[ch[fa[node]][0]]+1;
		node=fa[node];
	}
	return tot;
}
int findKth(int x){
	int u=root,num=x;
	while(size[ch[u][0]]!=num-1){
		if(size[ch[u][0]]>=num)u=ch[u][0];
		else num=num-size[ch[u][0]]-1,u=ch[u][1];
	}
	return u;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",num+i);
	root=build(1,n,0);
	for(int i=1;i<=m;i++){
		scanf("%s",str);
		if(str[0]=='T'){
			scanf("%d",&t1);
			t1=backw[t1];
			erase(t1);
			int u=min(root);
			ch[u][0]=t1,fa[t1]=u;
			size[t1]=1;
			while(u)size[u]++,u=fa[u];
		}
		else if(str[0]=='B'){
			scanf("%d",&t1);
			t1=backw[t1];
			erase(t1);
			int u=max(root);
			ch[u][1]=t1,fa[t1]=u;
			size[t1]=1;
			while(u)size[u]++,u=fa[u];
		}
		else if(str[0]=='I'){
			scanf("%d%d",&t1,&t2);
			if(t2==0)continue;
			else if(t2==-1){
				splay(backw[t1],0);
				int x=max(ch[root][0]);
				backw[val[x]]^=backw[t1]^=backw[val[x]]^=backw[t1];
				val[x]^=val[root]^=val[x]^=val[root];
			}
			else if(t2==1){
				splay(backw[t1],0);
				int x=min(ch[root][1]);
				backw[val[x]]^=backw[t1]^=backw[val[x]]^=backw[t1];
				val[x]^=val[root]^=val[x]^=val[root];
			}
		}
		else if(str[0]=='A'){
			scanf("%d",&t1);
			printf("%d\n",rank(backw[t1]));
		}
		else if(str[0]=='Q'){
			scanf("%d",&t1);
			printf("%d\n",val[findKth(t1)]);
		}
		//for(int i=1;i<=n;i++)printf("%d %d %d %d %d %d %d\n",backw[i],i,fa[i],ch[i][0],ch[i][1],val[i],size[i]);
	}
}
```

---

## 作者：KobeBeanBryantCox (赞：1)

# P2596 [ZJOI2006] 书架 题解

-----------------

[题目传送门](https://www.luogu.com.cn/problem/P2596)。

现有的题解并没有我这种乱搞做法，所以我来讲讲。

时间复杂度同样是 $O(m\log n)$ 的。

前置知识：FHQ-Treap。

注：此做法想法由我产生、代码由我独立完成。感谢 @[acb437](https://www.luogu.com.cn/user/520359) 大佬提供思路指导。

----------------

## 题意

你要维护 $n$ 个元素，$n$ 个元素的编号构成 $1$ 到 $n$ 的排列，有以下操作：
- $\texttt{Top}$：将编号为 $x$ 的元素放在最前。
- $\texttt{Bottom}$：将编号为 $x$ 的元素放在最后。
- $\texttt{Insert}$：将编号为 $x$ 的元素拿出，并重新插入到 $t$ 个位置之前或之后。
- $\texttt{Ask}$：查询编号为 $x$ 的元素的排名 $-1$。
- $\texttt{Query}$：查询排名为 $x$ 的元素的编号。

**注意到题目中的 $t\in[-1,1]$，但是我这个做法可以解决任意合法的 $t$，下文将默认是任意的 $t$。**

--------------

## 思路

### step 1

考虑每个编号为 $i$ 的元素维护一个 $val_{i}$ 表示该元素的位置（排名）。

1. $\texttt{Top}$ 操作：

   令该元素排名为 $x$（查找该元素排名的方法将在后面 $\texttt{Ask}$ 操作讲）。

   所有 $val_i\in[1,x-1]$ 的元素的 $val_i+1$。

   该元素的 $val=1$。
2. $\texttt{Bottom}$ 操作：

   同理，令该元素排名为 $x$。
   
   所有 $val_i\in[x+1,n]$ 的元素的 $val_i-1$。

   该元素的 $val=n$。
3. $\texttt{Insert}$ 操作：

   令该元素排名为 $x$。

   - 若 $t>0$，所有 $val_i\in[x+1,x+t]$ 的元素的 $val_i-1$，该元素的 $val=x+t$；
   - 若 $t=0$，直接退出，不操作；
   - 若 $t<0$，所有 $val_i\in[x+t,x-1]$ 的元素的 $val_i+1$，该元素的 $val=x+t$。
4. $\texttt{Ask}$ 操作：

   我们这里默认 $\texttt{Ask}$ 操作返回的是排名，最后将答案 $-1$ 即可。

   令传入的编号为 $i$，由于所有位置（$val$）也构成排列，所以我们可以直接返回 $val_i$。
5. $\texttt{Query}$ 操作：

   等价于把所有 $val_i\in[1,x]$ 的 $i$ 取出来，查询其中最大的 $val_i$ 所对应的 $i$。

----------------

### step 2

**问题转化成我们需要维护一个数据结构，支持以下操作：**
- 将 $val\in[l,r]$ 的元素取出，进行 $+1$ 或 $-1$ 或查询取出后的最大的 $val$（其实就是 $r$）；
- 单点修改某个元素的 $val$。

大家看看是不是这样。

----------------

### step 3

然后我们考虑维护一颗 FHQ-Treap，**这颗平衡树上的节点编号就是输入的编号，每个节点维护一个 $val$ 代表位置**。

如样例：`1 3 2 7 5 8 10 4 9 6`：

节点 $1$ 的 $val=1$，节点 $3$ 的 $val=2$，节点 $2$ 的 $val=3$，节点 $7$ 的 $val=4$，$\dots$，节点 $6$ 的 $val=10$。

然后我们按照 $val$ 分裂，按照随机值 $rnk$ 合并即可。

由于只有 $+1$ 和 $-1$，修改前后的元素不会有大于 $1$ 的交，不会破坏 Treap 的性质。

故不需要平衡树启发式合并（~~好像叫这个名字吧~~），直接按照朴素合并的即可。

具体地：

- 区间修改时先分裂出区间，对区间根节点打懒标记即可。

- 查询最大时先分裂出区间，从区间根节点不断往右儿子走即可。

- 单点修改时把单点单独分出来，然后直接修改 $val$，不需要打标记，然后合并即可，注意要分裂出 $4$ 个区间才能满足合并的有序性。

---------------

### 一些细节

1. 由于我们是在区间 $+1$ 或 $-1$ **后**进行单点修改，**一定存在**两个相同的 $val$，单点修改时分裂出的单点**一定会有**两个，我们可以传入我们要修改的元素编号，先把两个的父子关系断开，对两个都判断一下是不是我们想要的那个点，必有一个是的，然后朴素合并。

2. $\texttt{Ask}$ 操作中要返回 $val_i$，由于懒标记的存在，我们得先从 $i$ 走到根节点，然后再从根节点走回 $i$，从根节点到 $i$ 这个过程需要不断 pushdown，相对于普通的 FHQ-Treap，我们还需维护每个节点的父亲 $fa_u$，然后递归暴力跳父亲即可实现以上内容。

---------------

## AC 代码（带注释）

注意到这种乱搞写法很难写，还需分类讨论大小关系，~~所以我就不放代码了~~。

~~那怎么行呢，总有一些人是想抄代码的对吧，我要成全他们。~~

```cpp
#include<bits/stdc++.h>
#define Code using
#define by namespace
#define wjb std
Code by wjb;
int in()
{
	int k=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')k=k*10+c-'0',c=getchar();
	return k*f;
}
void out(int x)
{
	if(x<0)putchar('-'),x=-x;
	if(x<10)putchar(x+'0');
	else out(x/10),putchar(x%10+'0');
}
const int N=8e4+10;
int n;
struct fhq_treap
{
private:
	struct node{int lc,rc,siz,val,rnk,tag,fa;}tr[N];
	#define lc(x) tr[x].lc
	#define rc(x) tr[x].rc
	#define fa(x) tr[x].fa
	int root=0;
	int newnode(int id,int val){tr[id]={0,0,1,val,rand(),0,0};return id;}
	void pushup(int x){tr[x].siz=tr[lc(x)].siz+tr[rc(x)].siz+1;}
	void pushdown(int x) // 下传标记
	{
		if(!tr[x].tag)return;
		if(lc(x))tr[lc(x)].tag+=tr[x].tag,tr[lc(x)].val+=tr[x].tag;
		if(rc(x))tr[rc(x)].tag+=tr[x].tag,tr[rc(x)].val+=tr[x].tag;
		tr[x].tag=0;
	}
	void split(int k,int &x,int &y,int v,int d=0) // 按 val 分裂
	{
		if(!k)return x=y=0,void();
		pushdown(k);
		if(tr[k].val<=v)
		{
			x=k,split(rc(x),rc(x),y,v,d+1);
			if(rc(x))fa(rc(x))=x;
		}
		else
		{
			y=k,split(lc(y),x,lc(y),v,d+1);
			if(lc(y))fa(lc(y))=y;
		}
		pushup(k);if(!d)fa(x)=fa(y)=0; // 有个小细节，由于我们要维护 fa，分裂出来的两颗子树的根是没有 fa 的，要清空
	}
	int merge(int x,int y) // 朴素的合并
	{
		pushdown(x),pushdown(y);
		if(!x||!y)return x|y;
		if(tr[x].rnk<tr[y].rnk)
		{
			rc(x)=merge(rc(x),y);
			if(rc(x))fa(rc(x))=x;
			pushup(x);return x;
		}
		else
		{
			lc(y)=merge(x,lc(y));
			if(lc(y))fa(lc(y))=y;
			pushup(y);return y;
		}
	}
	void add(int l,int r,int v) // 把 val 属于 [l,r] 的节点的 val 全部加上 v（v=1/-1）
	{
		int x,y,z;split(root,x,y,r),split(x,x,z,l-1);
		tr[z].tag+=v,tr[z].val+=v;
		root=merge(merge(x,z),y);
	}
	void change(int id,int v) // 单点赋值，要分讨大小
	{
		int a,b,c,d,val=tr[id].val;
		if(val<v) // a=[1,val-1],b=val,c=[val+1,v],d=[v+1,n]
		{
			split(root,a,b,val-1),split(b,b,c,val),split(c,c,d,v);
			assert(tr[b].siz==2);
			int x=b,y=lc(b)|rc(b); // 把 b 子树的两个节点拿出来，此时 lc(b) 和 rc(b) 必有一个是 0
			fa(y)=lc(x)=rc(x)=0; // 断绝父子关系
			if(x!=id)swap(x,y); // 令 x 为要修改的单点
			tr[x].val=v;
			root=merge(a,merge(y,merge(merge(c,x),d)));
		}
		else if(val>v) // a=[1,v],b=[v+1,val-1],c=val,d=[val+1,n]
		{
			split(root,a,b,v),split(b,b,c,val-1),split(c,c,d,val);
			assert(tr[c].siz==2);
			int x=c,y=lc(c)|rc(c); // 下面同理，不写注释了
			fa(y)=lc(x)=rc(x)=0;
			if(x!=id)swap(x,y);
			tr[x].val=v;
			root=merge(merge(a,x),merge(b,merge(y,d)));
		}
	}
public:
	void push_back(int id,int val){root=merge(root,newnode(id,val));} // 插入
	int ask(int s) // Ask 操作
	{
		if(fa(s))ask(fa(s)),pushdown(fa(s));
		return tr[s].val;
	}
	int query(int s) // Query 操作
	{
		int x,y;split(root,x,y,s);
		int ans=x;while(rc(ans))ans=rc(ans);
		assert(tr[ans].val==s);
		root=merge(x,y);return ans;
	}
	void top(int id){int s=ask(id);add(1,s-1,1),change(id,1);} // Top 操作
	void bottom(int id){int s=ask(id);add(s+1,n,-1),change(id,n);} // Bottom 操作
	void insert(int id,int t) // Insert 操作
	{
		if(!t)return; // t=0 不操作，退出
		int s=ask(id);
		if(t>0)add(s+1,s+t,-1),change(id,s+t); // 还要有恶心的分讨
		else add(s+t,s-1,1),change(id,s+t);
	}
}T;
int main()
{
	srand(time(0));
	n=in();int m=in();
	for(int i=1;i<=n;i++)T.push_back(in(),i);
	while(m--)
	{
		char c=getchar();
		while(!isalpha(c))c=getchar();
		int s=in();
		switch(c)
		{
			case 'T':T.top(s);break;
			case 'B':T.bottom(s);break;
			case 'I':T.insert(s,in());break;
			case 'A':out(T.ask(s)-1),putchar('\n');break; // 要 -1
			case 'Q':out(T.query(s)),putchar('\n');break;
			default:puts("What's this?");
		}
	}
	return 0;
}
```

时间复杂度 $O(m\log n)$。

还是有一点[难调](https://www.luogu.com.cn/record/list?pid=P2596&user=865625)的，放一个带调试信息的[版本](https://www.luogu.com.cn/record/204846904)。

---

## 作者：温词 (赞：1)

### 题面见https://www.luogu.org/problemnew/show/P2596

### 题面就是描述了一个书柜从上到下放着书，可以看作一个序列，每个数的序号为它在从上向下数第几本

### 一开始建树偷了个懒，就直接一个个insert

### 因为题目中都是以书的编号进行操作，所以记一个pos[ ]

#### 操作一：把pos[x] splay到根，左儿子都是比它编号小的，那么就把左儿子挂到根的后面，根+1的前面，具体怎么找这个点看代码解释

#### 操作二：同一理

#### 操作三：实际上只更改了x和x的前驱或后继的值，和他们代表的值的位置，只修改这两个标记即可

#### 操作四：把pos[x] splay到根，左儿子都是比它编号小的，那么答案就是st[ls].size

#### 操作五：常规查询第k大
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    int w=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        w=(w<<3)+(w<<1)+ch-48;
        ch=getchar();
    }
    return w*f;
}
int n,m,cnt,tot,root,a[500010],pos[500010];
bool debug;
struct node{
    int val,ch[2],size,f;
}st[5000010];
inline void push_up(int x){
    int ls=st[x].ch[0];int rs=st[x].ch[1];
    st[x].size=st[ls].size+st[rs].size+1;
    pos[st[ls].val]=ls;pos[st[rs].val]=rs;
}
inline bool identify(int p){
    return st[st[p].f].ch[1]==p;
}
inline void connect(int x,int fa,int son){
    st[x].f=fa;st[fa].ch[son]=x;return;
}
inline void rotate(int x){
    int y=st[x].f;int z=st[y].f;
    int yson=identify(x);int zson=identify(y);
    int b=st[x].ch[yson^1];
    connect(b,y,yson);connect(y,x,(yson^1));connect(x,z,zson);
    push_up(y);push_up(x);if(z)push_up(z);return;
}
inline void splay(int x,int goal){
    while(st[x].f!=goal){
        int y=st[x].f;int z=st[y].f;
        int yson=identify(x);int zson=identify(y);
        if(z!=goal){
            if(yson==zson) rotate(y);
            else rotate(x);
        }
        rotate(x);
    }
    if(!goal) root=x;
    return;
}//这以上都是常规操作 
inline void insert(int x){
    cnt++;int now=cnt;st[now].size=1;
    st[now].val=x;pos[x]=now;st[now].ch[0]=st[now].ch[1]=0;
    if(cnt>1){//只要当前节点不是根，都要将它和父亲连一下，并splay到根 
        st[now].f=now-1;st[now-1].ch[1]=now;
        splay(now,0);
    }
}//建树操作 

inline void output(int x){
    int ls=st[x].ch[0];int rs=st[x].ch[1];
    if(ls) output(ls);
    printf("%d ",st[x].val);
    if(rs) output(rs);
    return;
}//输出整颗区间树，debug用的 

inline int find(int p,int rk){
    int ls=st[p].ch[0];int rs=st[p].ch[1];
    if(st[ls].size+1==rk) return p;
    if(st[ls].size>=rk) return find(ls,rk);
    return find(rs,rk-st[ls].size-1);
}//找树上排名 

inline void Top(int x){
    x=pos[x];splay(x,0);
    if(!st[x].ch[0]) return;//如果没有左儿子就不用管了 
    if(!st[x].ch[1]){//没有右儿子就把左儿子挂过去就完事了 
        st[x].ch[1]=st[x].ch[0];st[x].ch[0]=0;return;
    }
    int ls=st[x].ch[0];
    int y=find(root,st[ls].size+2);//根的rank是st[ls].size+1，st[ls].size+2为根的后继 
    st[ls].f=y;st[y].ch[0]=ls;//根的左子树应该挂在根的后继的左子树 
    st[x].ch[0]=0;splay(y,0);//最后把更改的点splay到根 
    return;
}
inline void Bottom(int x){//操作同上，反向操作即可 
    x=pos[x];splay(x,0);
    if(!st[x].ch[1]) return;
    if(!st[x].ch[0]){
        st[x].ch[0]=st[x].ch[1];st[x].ch[1]=0;return;
    }
    int ls=st[x].ch[0];int rs=st[x].ch[1];
    int y=find(root,st[ls].size);
    st[rs].f=y;st[y].ch[1]=rs;
    st[x].ch[1]=0;splay(y,0);
    return;
}

inline void change(int x,int y){//题目中的insert操作 
    x=pos[x];splay(x,0);if(!y) return;//如果y==0，说明就不用修改 
    int ls=st[x].ch[0];
    if(y==-1){//y==-1就找前驱 
        y=find(root,st[ls].size);
    }
    else y=find(root,st[ls].size+2);//y==1就找后缀 
    swap(pos[st[x].val],pos[st[y].val]);//这要修改两个点的值和两个点值的所在位置 
    swap(st[x].val,st[y].val);return;
}

inline void rnk(int x){//常规查排名操作 
    x=pos[x];splay(x,0);
    int ls=st[x].ch[0];
    printf("%d\n",st[ls].size);return;
}

inline void kth(int x){//常规排名找点操作 
    x=find(root,x);
    printf("%d\n",st[x].val);return;
}

int main(){
    n=read();m=read();int i,j,k;root=1;
    for(i=1;i<=n;i++){
        int x=read();insert(x);
    }
    //debug=true;
    while(m--){
        string s;cin>>s;int x,y;
        if(s[0]=='T'){
            x=read();Top(x);
        }
        if(s[0]=='B'){
            x=read();Bottom(x);
        }
        if(s[0]=='I'){
            x=read();y=read();change(x,y);
        }
        if(s[0]=='A'){
            x=read();rnk(x);
        }
        if(s[0]=='Q'){
            x=read();kth(x);
        }
        if(debug){
            cout<<"debuging";
            output(root);
            cout<<endl;
        }
    }
    return 0;
}
```

---


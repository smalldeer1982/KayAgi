# [ZJOI2009] 取石子游戏

## 题目描述

在研究过 Nim 游戏及各种变种之后，Orez 又发现了一种全新的取石子游戏，这个游戏是这样的：

有 $n$ 堆石子，将这 $n$ 堆石子摆成一排。游戏由两个人进行，两人轮流操作，每次操作者都可以从最左或最右的一堆中取出若干颗石子，可以将那一堆全部取掉，但不能不取，不能操作的人就输了。

Orez 问：对于任意给出一个初始一个局面，是否存在先手必胜策略。

## 说明/提示

对于 $30 \%$ 的数据，$n \le 5$，$a_i \le {10}^5$。  
对于 $100 \%$ 的数据，$1 \le T \le 10$，$1 \le n \le 1000$，$1 \le a_i \le {10}^9$。

## 样例 #1

### 输入

```
1
4
3 1 9 4
```

### 输出

```
0
```

# 题解

## 作者：yybyyb (赞：79)

神仙题.jpg。$ZJOI$是真的神仙。  
发现$SG$函数等东西完全找不到规律，无奈只能翻题解。

首先设$L[i][j]$表示在$[i,j]$这一段区间的左侧放上一堆数量为$L[i][j]$的石子后，先手必败。同理定义$R[i][j]$表示右侧。

首先我们可以证明$L[i][j]$唯一，假设存在两个$L[i][j]$，显然较大的那个可以通过一步转移转移到较小的那个，所以不合法。因此$L[i][j]$唯一。  

接下来考虑如何证明$L[i][j]$一定存在。假设$L[i][j]$不存在，那么对于这段区间而言，在左边加上任意一堆石子先手都必胜，既然先手必胜意味着先手进行一步操作之后可以到达一个必败态，这里分情况讨论。假设先手拿的是最左边的一堆石子，因为不存在$L[i][j]$，所以只要拿了左边的石子之后，当前局面都是必胜态，所以不可能拿左边的石子。那么只能拿右边的石子，那么无论右边拿了一定量之后，无论左边添加了多少，都是一个必败态，那么此时后手在左侧随便拿走一定数量，这个状态也还是一个必败态，显然也不成立。因此$L[i][j]$必定存在。  

综上，我们知道了$L[i][j]$一定存在并且唯一，而$L[][],R[][]$显然是对称的，因此$R[i][j]$也满足上述性质。

现在考虑如何求解$L[i][j]$,$R[i][j]$同理。首先边界情况显然，$L[i][i]=a[i]$，因为只剩下两堆一模一样的情况的时候，后手只需要模仿先手的行动对称执行就好了，这样子一定不会输，即先手必败。

接下来来大力分类讨论，为了方便，设$L=L[i][j-1],R=R[i][j-1],x=a[j]$

- $x=R$
	
  这种情况下显然只需要直接把$a[j]$放进去就好了，即这个区间本身就是一个必败态。所以$L[i][j]=0$。

- $x<L,x<R$

  这种情况下$L[i][j]=x$。这种情况下最靠左的$L[i][j]$和$x=a[j]$是相同的，意味着先手无论怎么取，后手显然可以学着它的方法取，也就意味着左右两堆中显然必然会先拿完一堆，此时后手学着拿的那一堆的石子数一定也是小于$L,R$的。假设先手先拿完了最靠右的一堆，即剩下了$[i,j-1]$，因为$L[i][j-1]$表示的是在这一段区间最左侧加入一个$L[i][j-1]$的堆，无论先手怎么取先手都是必败的，那么我们等价的认为先手取走了这一堆的一部分，显然后手是必胜的。假如先手先取完的是最左的一堆，同理，$R[i][j-1]$的含义是在最右侧加入了一堆，而$a[j]<R[i][j-1]$，我们还是可以等价的认为先手在这一堆中取走了若干石子，而这个状态对于先手而言是必败状态，因此显然后手必胜。

- $R<x<L$

  这种情况下$L[i][j]=x-1$。这样子考虑，假设先手先拿了左边这一堆，那么假设还剩下了$z$个石子，如果$z<R$，后手把右侧的那一堆也给拿成$z$就变成了上面的情况。如果$z\ge R$，那么后手把最后那一堆拿成$z+1$，于是又回到了这种情况，相当于这种情况递归处理。如果先手先拿的是右侧的这一堆，还是一样的，假设把它拿成了$z$，如果$z<R$，同上可以变成$x<L,x<R$的情况；如果$y=R$，直接把左边拿完，就变成了$R[i][j-1]$的定义了，先手必败；如果$z>R$，把左边那堆变成$z-1$，同样递归处理。

- $L<x<R$

  分析同上，$L[i][j]=x+1$。

- $x>L,x>R$

  $L[i][j]=x$。还是一样的，假设先手把其中一堆拿成了$z$。如果$z>L,R$，跟着先手拿成一样多的石子则又回到了这种情况。如果$z<L,R$，则可以回到情况$x<L,R$。否则的话对应着把另外一堆变成$z+1$或者$z-1$，对应着$L<x<R$和$R<x<L$两种情况。

而$R[][]$和$L[][]$是对称的，类似的求解即可。

那么最终只需要判断$L[2][n]$和$a[1]$是否相等即可判断胜负情况。


代码有点丑
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#define MAX 1010
inline int read()
{
	int x=0;bool t=false;char ch=getchar();
	while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
	if(ch=='-')t=true,ch=getchar();
	while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
	return t?-x:x;
}
int n,a[MAX],L[MAX][MAX],R[MAX][MAX];
int main()
{
	int T=read();
	while(T--)
	{
		n=read();
		for(int i=1;i<=n;++i)a[i]=read();
		for(int i=1;i<=n;++i)L[i][i]=R[i][i]=a[i];
		for(int len=2;len<=n;++len)
			for(int i=1,j=i+len-1;j<=n;++i,++j)
			{
				int x=a[j],l=L[i][j-1],r=R[i][j-1];
				if(x==r)L[i][j]=0;
				else if((x>l&&x>r)||(x<l&&x<r))L[i][j]=x;
				else if(r<x&&x<l)L[i][j]=x-1;
				else L[i][j]=x+1;
				x=a[i],l=L[i+1][j],r=R[i+1][j];
				if(x==l)R[i][j]=0;
				else if((x>l&&x>r)||(x<l&&x<r))R[i][j]=x;
				else if(r<x&&x<l)R[i][j]=x+1;
				else R[i][j]=x-1;
			}
		puts(a[1]==L[2][n]?"0":"1");
	}
}
```

---

## 作者：wsyhb (赞：38)

## 前言

本文将在[yybyyb 的题解](https://www.luogu.com.cn/blog/cjyyb/solution-p2599)的基础上对证明进行一些必要的补充。

旨在修正一些瑕疵 & 方便读者理解。

----

复读一遍：

> 神仙题.jpg。ZJOI 是真的神仙。  
> 发现 SG 函数等东西完全找不到规律，无奈只能翻题解。

------------

话说洛谷 Markdown 的缩进好丑啊……

## 正文

### 状态的定义

设 $L(i,j)$ 表示在 $[i,j]$ 区间的左侧放上一堆数量为 $L(i,j)$ 的石子后，**先手必败**。（$L(i,j)$ 可以为 $0$）  
即：$(L(i,j),a_i,a_{i+1},\cdots,a_j)$ 为必败局面。

同理对右侧定义 $R(i,j)$。

1. $L(i,j)$ 的**存在性证明**（$R(i,j)$ 同理，下同）：

	假设不存在满足定义的 $L(i,j)$，则对于任意非负整数 $x$，$(x,a_i,a_{i+1},\cdots,a_j)$ （记为 $A(x)$ 局面）为必胜局面。  
   由于 $A(x)$ 为必胜局面，故从 $A(x)$ 局面一步可达某个必败局面。   
   若拿最左边一堆，则不可能变成必败局面，因为这样得到的局面仍形如 $A$。（注意包括此行在内的接下来几行默认 $x \neq 0$）  
   于是设 $A(x)$ 一步可达的（某个）必败局面为 $(x,a_i,a_{i+1},\cdots,a_{j-1},y)$，显然有 $0 \le y < a_j$。  
	**由于 $x$ 有无限个，但 $y$ 只有 $a_j$ 种——根据抽屉原理，必存在 $x_1,x_2(x_1 \neq x_2),y$ 满足 $(x_1,a_i,a_{i+1},\cdots,a_{j-1},y)$ 和 $(x_2,a_i,a_{i+1},\cdots,a_{j-1},y)$ 都是必败局面。**但这两个必败局面之间实际一步可达，故矛盾，进而原命题成立。

2. $L(i,j)$ 的**唯一性证明**：

	假设 $L(i,j)$ 不唯一，则存在非负整数 $x_1,x_2(x_1 \neq x_2)$， $(x_1,a_i,a_{i+1},\cdots,a_{j-1},a_j)$ 和 $(x_2,a_i,a_{i+1},\cdots,a_{j-1},a_j)$ 均为必败局面。而这两个必败局面之间实际一步可达，故矛盾，进而原命题成立。

有了唯一性，我们可以自然地得出一个有用的结论：

**对于任意非负整数 $x \neq L(i,j)$，$(x,a_i,a_{i+1},\cdots,a_j)$ 为必胜局面。**

注：下文所说的**“根据 $L(\cdots)$ 或 $R(\cdots)$ 的定义”即指 $L(i,j)$ 的定义 & 这个结论**。

### 状态的转移（求解）

边界情况：$L(i,i)=a_i$。（对于两堆相同的石子，后手一定可以进行和先手对称的操作）

$L(i,j)(i<j)$ 则从 $L(i,j-1)$ 及 $R(i,j-1)$ 转移而来，转移需要大力**分类讨论**：

（为方便叙述，下文记 $L(i,j-1)$ 为 $L$，记 $R(i,j-1)$ 为 $R$，并令 $x=a_j(x>0)$）

先提一个后文要用的简单结论（请将它默默记在心中）：

若 $R=0$ 则 $L=R=0$，此时 $x>\max\{L,R\}$，也就是说 **$L=0$ 和 $R=0$ 都属于 Case 5，故其它 Case 满足 $L,R>0$**。

- $x=R$（**Case 1**）  

  最简单的情况——根据 $R(i,j-1)$ 的定义，区间 $[i,j]$ 本来就是必败局面，故 $L(i,j)=0$。
- $x<R$

   - $x<L$，即 $x< \min\{L,R\}$（**Case 2**）

     - 结论：$L(i,j)=x$。

     - **证明**：

 		即证 $(x,a_i,a_{i+1},\cdots,a_{j-1},x)$ 为必败局面。  
		由于最左边和最右边的两堆石子数量相同，后手可进行和先手对称的操作，直到自己在某一时刻获得形如 $(y,a_i,a_{i+1},\cdots,a_{j-1})$ 或 $(a_i,a_{i+1},\cdots,a_{j-1},y)$ 的局面。  
		由于 $0<y \le x<\min\{L,R\}$，结合 $L(i,j-1)$ 和 $R(i,j-1)$ 的定义知这个局面必胜，即后手必胜，证毕。

     - 注意上述证明的前提是 $x \neq 0$，因此**后续证明若使用 Case 2，必须满足 $x \neq 0$（具体见后文）**。

	- $x \geq L$，即 $L \leq x < R$（**Case 3**）

		- 结论：$L(i,j)=x+1$。

		- **证明**：

      1. 若先手拿最左边一堆，设拿了以后还剩 $z$ 个石子。

         ​	若 $z>L$，则后手将最右堆拿成 $z-1$ 个石子（注意 $z-1 \ge L>0$），就能回到 Case 3 本身，递归证明即可。  
         ​	若 $z=L$，则后手将最右堆拿完，根据 $L(i,j-1)$ 定义知此时局面必败。  
         ​	若 $0<z<L$，则后手将最右堆拿成 $z$ 个石子，由 Case 2 知此时是必败局面。  
         ​	若 $z=0$，此时最右堆石子数 $k$ 满足 $L \le k<R$，结合 $R(i,j-1)$ 定义知局面必胜。（照应 Case 2 黑体内容）

      2. 若先手拿最右边一堆，设拿了以后还剩 $z$ 个石子。

         ​	若 $z \ge L$，则后手将最左堆拿成 $z+1$ 个石子，递归证明即可。  
         ​	若 $0<z<L$，则后手将最左堆拿成 $z$ 个石子，由 Case 2 知此时是必败局面。  
         ​	若 $z=0$，则后手将最左堆拿成 $L$ 个石子，由 $L(i,j-1)$ 定义知此时局面必败。

- $x>R$

	- $x \leq L$，即 $R < x \leq L$（**Case 4**）

		- 结论：$L(i,j)=x-1$。

		- **证明**（与 Case 3 证明同理，读者可先自己尝试证明，再进行阅读）：

      1. 若先手拿最左边一堆，设拿了以后还剩 $z$ 个石子。

         ​	若 $z \geq R$，则后手将最右堆拿成 $z+1$ 个石子，就能回到 Case 4 本身，递归证明即可。  
         ​	若 $0<z<R$，则后手将最右堆拿成 $z$ 个石子，由 Case 2 知此时是必败局面。  
         ​	若 $z=0$，则后手将最右堆拿成 $R$ 个石子（注意 Case 4 保证了此时最右堆石子个数 $>R$），由 $R(i,j-1)$ 的定义知此时是必败局面。

      2. 若先手拿最右边一堆，设拿了以后还剩 $z$ 个石子。

         ​	若 $z>R$，则后手将最左边一堆拿成 $z-1$ 个石子（注意 $z-1 \ge R >0$），递归证明即可。  
         ​	若 $z=R$，则后手把最左堆拿完，根据 $R(i,j-1)$ 的定义可知得到了必败局面。  
         ​	若 $0<z<R$，则后手将最左堆拿成 $z$ 个石子，由 Case 2 知此时是必败局面。  
         ​	若 $z=0$，此时最左堆石子数量 $k$ 满足 $0<k<L$，结合 $L(i,j-1)$ 定义知局面必胜。

	- $x>L$，即 $x>\max\{L,R\}$（**Case 5**）

		- 结论：$L(i,j)=x$。

		- **证明**（有了前面这么多的证明作为经验，这里就稍微简略点儿）：

      ​	设先手将其中一堆拿成了 $z$ 个石子。  
      ​	若 $z>\max\{L,R\}$，回到 Case 5，递归证明。  
      ​	若 $0<z<\min\{L,R\}$，后手把另一堆也拿成 $z$ 个石子即可转 Case 2。  
      ​	若 $z=0$，将另一堆拿成 $L$ 或 $R$ 个石子即可得到必败局面。  

      ​	剩余的情况是 $L \le z \le R$ 或 $R \le z \le L$。  
      ​	而 Case 3 可以解决最左堆 $L+1 \le z \le R$，最右堆 $L \le z \le R-1$ 的情况（取石子以满足 Case 3 的形式，下同）；  
      ​	且 Case 4 可以解决最左堆 $R \le z \le L-1$，最右堆 $R+1 \le z \le L$ 的情况。  
      ​	所以只需解决最左堆 $z=L$ 和最右堆 $z=R$ 的情况。  
      ​	而这两种情况直接把另一堆拿完就可以得到必败局面。

综上所述：

$$L(i,j)=\begin{cases}  
  0, \quad &x=R,\\  
  x+1, \quad &L \le x < R,\\  
  x-1, \quad &R < x \le L,\\  
  x, \quad &\text{otherwise}.\\
\end{cases}$$

温馨提示：**请看清楚 $L$ 取不取等，乱取等是错的！**

同理可求 $R(i,j)$。

----

回到原题，**先手必败当且仅当 $L(2,n)=a_1$**，于是我们就做完啦！

时间复杂度 $O(n^2)$。

### 代码

``` cpp
#include<bits/stdc++.h>
using namespace std;
const int max_n=1e3+5;
int a[max_n],L[max_n][max_n],R[max_n][max_n];
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		int n;
		scanf("%d",&n);
		for(int i=1;i<=n;++i)
		{
			scanf("%d",a+i);
			L[i][i]=R[i][i]=a[i];
		}
		for(int len=2;len<=n;++len)
			for(int i=1;i+len-1<=n;++i)
			{
				int j=i+len-1,l=L[i][j-1],r=R[i][j-1],x=a[j];
				if(x==r)
					L[i][j]=0;
				else if(x>=l&&x<r)
					L[i][j]=x+1;
				else if(x>r&&x<=l)
					L[i][j]=x-1;
				else
					L[i][j]=x;
				l=L[i+1][j],r=R[i+1][j],x=a[i];
				if(x==l)
					R[i][j]=0;
				else if(x>=r&&x<l)
					R[i][j]=x+1;
				else if(x>l&&x<=r)
					R[i][j]=x-1;
				else
					R[i][j]=x;
			}
		puts(L[2][n]==a[1]?"0":"1");
	}
	return 0;
}
```



---

## 作者：Altwilio (赞：24)

### $0.$ 说明

本题解给出所有情况下保证先手必败的具体方案。

upd：已修改 $\LaTeX$。

### $1.$ 题意

有一排 $n$ 堆石子，两人轮流从最左或最右一堆取若干石子，不能取的人输。

问对于给定的初始局面，是否有先手必胜策略。

### $2.$ 思路

假设当前 $i$ 到 $j$ 堆已经固定。 如 `[?] [i  j] [?]`，`[?]` 代表未固定。

设 $left_{i,j}$ 表示我在 $i$ 左边放多少个棋子先手必败。

结论是 $left_{i,j}$ 存在且唯一。

使用反证法：假设有两个取值 $a < b$ 使得先手必败，那么当先手取 $b - a$ 个时，留给后手 $a$ 个，后手必败先手就不必败了。所以 $left_{i,j}$ 存在且唯一。

同理可以求出 $right_{i,j}$ 表示我在 $j$ 右边放多少个棋子先手必败。

则当 $left_{2,n} = a_1$ 时，先手没有必胜策略。这句话就是字面意思，当在 $a_2$ 左边也就是 $a_1$ 放 $left_{2,n}$ 是先手必败。
 
接下来是 $\textbf{重点}$, 分析 $left_{i,j}$ 如何递推，不分析 $right_{i,j}$ 因为对称。

假设当前状态为 `[?] [i  j-1] [j(x)]`，第 $j$ 堆的大小为 $x$。则需要求 `[?]` 等于什么可以使状态 `[?] [i  j-1] [j(x)]` 必败。

再定义一个 $L$ 代表使状态 `[?] [i  j-1]` 必败的 `[?]` 值，$R$ 代表使状态 `[i  j-1] [?]` 必败的 `[?]` 值。

然后就是大幅分类讨论啦！

#### 情况1
$R = x$。

结论 `[0] [i  j-1] [x]`。

在状态 `[?] [i  j-1] [x]` 中 $R = x$，则 $left_{i,j} = 0$。

#### 情况2
$x < L, x < R$。

结论 `[x] [i  j-1] [x]`。

在状态 `[x] [i  j-1] [x]` 中 $x < L$， $x < R$，先手取完后，后手只要在另一堆取相同的个数即可，最后这两堆肯定会存在先手取完后有一堆为 $0$ 的情况，则状态为 `[0] [i  j-1] [y]`，$0 < y ≤ x$。而此时的必败态只有 $L$，$R$，而 $y<L,y<R$ 所以此时后手不必败，先手必败。

#### 情况3.1

$L>R$ 则有 $R < x ≤ L$。

结论 `[x-1] [i  j-1] [x]`。

先手取右边：

先手把右边取到 $R$。后手把左边取完，先手面临必败状态。

先手把右边取到 $x < R$。后手把左边取到与右边相等，则转换为 情况2，先手必败。

先手把右边取到 $x > R$。后手把左边取到比右边小 $1$，则右边必然会到达 情况1 或 情况2。先手必败。

先手取左边：

先手把左边取到 $x ≥ R$。后手把右边取到 $x + 1$，则转换为 情况3.1。

先手把左边取到 $x < R$。后手把右边取到 $R$，则转换为 情况2。

则只要 左边 $≥R$， 右边 $≥R+1$， 后手保证左边比右边少一个，一旦左边或者右边有一个 $<R$，后手就保证左右两边一样多，就可以保证先手必败。

#### 情况3.2

$R > L$ 则有 $L ≤ x < R$。

结论 `[x+1] [i  j-1] [x]`。
                    
如果先手把左边取到 $≥L+1$ 时，后手就把右边取到 $≥L$，后手永远保证左边比右边多 $1$。

如果先手把左边取到 $L$ 时，后手就把右边取完，先手必败。

如果先手把左边或右边取到 $<L$，后手就保证左右两边一样多，先手必败。

则后手保证左边比右边多一个，一旦左边或者右边有一个 $<L$，后手就保证左右两边一样多，就可以保证先手必败。

#### 情况4
$x > L$ 且 $x > R$。

结论 `[x] [i  j-1] [x]`。

意味着只要 $x>L$ 且 $x>R$，左边和右边取一样多就行。

当 $L>R$ 时。

先手取完后 $>L$，后手保证左右两边相同。

一旦先手把某一边个数取到 $(R,L]$ 后手保证左边比右边少一个，转换为 情况3.1。

一旦先手把某一边个数取到 $[R,L)$ 后手保证右边比左边多一个。

一旦先手把某一边个数取到 $(,R)$ 后手保证右边和左边一样多。

当 $R>L$ 时，对称。

先手取完后 $>R$，后手保证左右两边相同。

一旦先手把某一边个数取到 $(L,R]$ 后手保证右边比左边少一个，转换为 情况3.2。

一旦先手把某一边个数取到 $[L,R)$ 后手保证左边比右边多一个。

一旦先手把某一边个数取到 $(,L)$ 后手保证右边和左边一样多。

### $3.$ 代码

```cpp
const int N = 1010;
int n, a[N], l[N][N], r[N][N];

signed main(){
    int T; read(T);
    while(T --){
        read(n);
        for(int i = 1; i <= n; i ++) read(a[i]);
        for(int len = 1; len <= n; len ++){
            for(int i = 1; i + len - 1 <= n; i ++){
                int j = i + len - 1; // 左端点 i 右端点 j
                // 补充若区间只有一个堆，应取 [x][x][x]
                if(len == 1) l[i][j] = r[i][j] = a[i];
                else{
                    int L = l[i][j - 1], R = r[i][j - 1], X = a[j]; // 情况1
                    if(R == X) l[i][j] = 0; //情况2 情况4
                    else if(X < L && X < R || X > L && X > R) l[i][j] = X; //情况3.1 情况4.1
                    else if(L > R) l[i][j] = X - 1; //情况3.2 情况4.2
                    else l[i][j] = X + 1;
                    //以下对称
                    L = l[i + 1][j], R = r[i + 1][j], X = a[i];
                    if(L == X) r[i][j] = 0;
                    else if(X < L && X < R || X > L && X > R) r[i][j] = X;
                    else if(R > L) r[i][j] = X - 1;
                    else r[i][j] = X + 1;
                }
            }
        }
        if(n == 1) puts("1");
        else print(l[2][n] != a[1]), puts("");
    } 
    return 0;
}
```


---

## 作者：Jason_Yvan (赞：24)

来正经的谈正解：

首先，讲个性质，取石子时，当先手使得左右两边的石子相等时，可以保证先手必胜，因为当先手取到左右石子相等的局面时，则后手无论在哪一堆取石子，接下来先手都可以有相同的方法取另一堆石子，这样又回到了原来的状态（左右石子相等），则无论如何先手都有办法应对后手的取法。


设在区间[i, j]左边放left[i][j]（可以为0）个石子后（区间内石子保持原状），产生的局面为**先手必败局面**（这是重点），right[i][j]就是在右边放（定义类似）；设a[i]为第i堆石子个数。

最后我们只用看  left[2][n]  是否等于  a[1]  就可以了。**（如果等于就说明这个情况先手必败，否则先手必胜）**


这一题可以注意到对于一段区间[L, R], 若L+1到R的石子数固定, 那么使得在这段区间上先手必败的a[L]有且仅有一个。

接下来证明left[i][j]与（right[i][j]同理）是唯一的：

1）若存在两或以上个left[i][j]，则从某一个必定可一步转移到另一个，矛盾，故最多只有一个；

2）若没有left[i][j]，那么必胜态只可能通过拿右边的石子转移到某个必败态，由于此时左边石子可以是任意个，右边石子数固定，于是必有右边的某一个石子数对应了多种必败态，这些必败态只有左边的石子数不同，与1矛盾。


最后我们考虑left[i][j]（同right[i][j]）的求法，大力分类讨论：

设  L = left[i][j - 1]  ,   R = right[i][j - 1]  ,   X = a[j]  . 通过下面的分析我们可以发现left[i][j]只和L, R, X三个数有关.


1）边界条件：left[i][i] = right[i][i] = a[i]，两堆一样的，后手照着先手拿的数量在另一堆拿即可。

2）首先, 最容易想到的是, R = X的情况, 这时[i, j]这段区间已经先手必败, 那么left[i][j] = 0。

3）若 x  < L && x < R， left[i][j] = x， 因为此时当两堆石子相同时，后手照着先手取，这样先手一定会先拿完某一堆，后手占据主动，这之后又会出现某一种我们分类讨论中的情况，相当于一种递归，直到后手获胜。

4）若 x < L && x > R， left[i][j] = x - 1。此时如果先手在左边拿使其个数变为y，若y < R，则后手在右边也拿到y即可变为情况3；若y >= R，则后手在右边拿到y + 1, 于是回到了相同的情况。如果先手在右边拿到y，若y < R，同样可到情况3；若y = R, 直接把左边的堆拿完，先手便面临败局；若y > R，则在左边拿到y - 1,回到相同情况。

5）若 x < R && x >= L， left[i][j] = x + 1, 与情况4恰好相反。

6）若 x > L && x > R，left[i][j] = x。若先手将某一堆拿到了y，且y > R, 跟着先手拿即可回到相同情况；若y < L，回到情况3；若在在左边拿到L或在右边拿到R，后手拿掉另一堆即可；否则根据情况在另一堆拿到y - 1或是y + 1，分别对应情况4和5。


right[i][j]的求法与left[i][j]完全对称，最后只需判断 a[1] == left[2][n]。


代码如下C++:












```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long LL;
#define REP(i, a, b) for(register int i = (a), i##_end_ = (b); i <= i##_end_; ++ i)
#define DREP(i, a, b) for(register int i = (a), i##_end_ = (b); i >= i##_end_; -- i)
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define mem(a, b) memset((a), b, sizeof(a))
template<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }
template<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }
int read()
{
    int sum = 0, fg = 1; char c = getchar();
    while(c < '0' || c > '9') { if (c == '-') fg = -1; c = getchar(); }
    while(c >= '0' && c <= '9') { sum = sum * 10 + c - '0'; c = getchar(); }
    return sum * fg;
}
const int Size = 1010;
const int inf = 0x3f3f3f3f;
int a[Size];
int Left[Size][Size], Right[Size][Size];
int main()
{
    int Case = read();
    while(Case--)
    {
        int n = read();
        REP(i, 1, n)
        {
            Left[i][i] = Right[i][i] = a[i] = read();
        }
        REP(k, 1, n)
        {
            for(int i = 1; i + k <= n; ++i)
            {
                int j = i + k, L, R, z;
                L = Left[i][j - 1], R = Right[i][j - 1], z = a[j];
                if(R == z) Left[i][j] = 0;
                else if(L > z && R > z) Left[i][j] = z;
                else if(L <= z && R > z) Left[i][j] = z + 1;
                else if(L > z && R < z) Left[i][j] = z - 1;
                else Left[i][j] = z;
                L = Left[i + 1][j], R = Right[i + 1][j], z = a[i];
                if(R == z) Right[i][j] = 0;
                else if(L > z && R > z) Right[i][j] = z;
                else if(L <= z && R > z) Right[i][j] = z + 1;
                else if(L > z && R < z) Right[i][j] = z - 1;
                else Right[i][j] = z;
            }
        }
        printf("%d\n", a[1] == Left[2][n] ? 0 : 1);
    }
    return 0;
}
```
由于这道题的数据不知道怎么有点特殊的性质（其实就是水，我也不知道为什么这样也可以），下面有一种奇葩的程序也可以过








```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long LL;
#define REP(i, a, b) for(register int i = (a), i##_end_ = (b); i <= i##_end_; ++ i)
#define DREP(i, a, b) for(register int i = (a), i##_end_ = (b); i >= i##_end_; -- i)
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define mem(a, b) memset((a), b, sizeof(a))
template<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }
template<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }
int read()
{
    int sum = 0, fg = 1; char c = getchar();
    while(c < '0' || c > '9') { if (c == '-') fg = -1; c = getchar(); }
    while(c >= '0' && c <= '9') { sum = sum * 10 + c - '0'; c = getchar(); }
    return sum * fg;
}
const int Size = 100000;
const int inf = 0x3f3f3f3f;
int a[Size];
int main()
{
    int Case = read();
    while(Case--)
    {
        int n = read();
        REP(i, 1, n)
        {
            a[i] = read();
        }
        if(abs(a[1] - a[n]) <= 1) printf("0\n");
        else printf("1\n");
    }
    return 0;
}

```

---

## 作者：potatoler (赞：13)

### [题目](https://www.luogu.com.cn/problem/P2599)简述：

$n$ 堆石子排成一排，每次可以从最左或最右的一堆中取若干，不能不取。两人轮流操作，不能操作的就输了。对于给定的一个初始局面，是否存在先手必胜策略？

### 思路：

比较容易想到的是，如果两端石子相同时，先手必败。这是因为无论先手做什么操作，后手只需要做与之对称的操作就可以了，最后拿光石子的一定是后手。那么对于先手自身来讲，使其必胜的状态就是能够使两端石子相同的状态，这样就可以先发制人，使后手面对刚才说过的局面。

与之前做过的其他题目有一个显著的不同在于，这道题只允许玩家从两端取石子，在两端的石子取完之前中间的石子状态并不会发生改变。两端的石子的确可以决定玩家的状态，但生活总不是风平浪静，两端的石子被取完后，曾经的优势者也可能面临着劣势局面 —— 如何力挽狂澜是他需要考虑的事情，而对于我们来讲，不仅需要考虑能操作范围内 (即两端) 石子的状态，更要考虑现在能操作的石子与未来要操作的石子之间的关系，考虑 DP。

不妨先做一些规定吧：$l_{i,j}$ 表示先手必败时中间石子形成的闭区间 $[i,j]$ 左端的石子数，$r_{i,j}$ 表示先手必败时闭区间 $[i,j]$ 右端的石子数，$a_i$ 表示 $i$ 位置的石子数。值得注意的是，前两个条件不仅限制了两端的石子数，还限制了游戏中剩余所有石子的范围 —— 换句话说，只有除去两端石子，剩下的石子正好是闭区间 $[i,j]$ 时，$l_{i,j}$ 和 $r_{i,j}$ 才会生效。

首先，如果 $l_{i,j}$ 和 $r_{i,j}$ 存在，那它们一定是唯一的。假设 $l_{i,j}$ 有两个值 $l_1$ 和 $l_2$ ( $l_1>l_2$ )，那么当最左端的石子数量为 $l_1$ 时，先手本应必败，但是他可以将最左端石子拿成 $l_2$，局面变为后手必败，与前边先手必败矛盾。其次，$l_{i,j}$ 和 $r_{i,j}$ 一定都存在。假设 $l_{i,j}$ 不存在，那么无论最左端有多少石子都是必胜态。拿左边的石子显然是徒劳的，因为不管剩下多少都一定是必胜态，所以先手拿右边的石子。现在先手拿了右边的石子使得后手必败，那么后手无论从左边拿多少都必败，与「无论最左端有多少石子都是必胜态」矛盾。综上，$l_{i,j}$ 和 $r_{i,j}$ 存在且唯一。

#### Case0：边界 $[i,i]$

$l_{i,j}=r_{i,j}=a_i$，最开始已经说过了，两端石子相同时先手必败。

#### Case1：$a_j=r_{i,j-1}$

最右边的石子已经满足了先手必败时的条件，先手必败。

#### Case2：$a_j<l_{i,j-1},\ a_j<r_{i,j-1}$

此时有 $l_{i,j}=a_j$，又构成了最开始说的情况：最右端的石子是 $a_j$，那么最左端的石子和最右端对称的时候先手必败。

#### Case3：$a_j≥l_{i,j-1},\ a_j<r_{i,j-1}$

此时有 $l_{i,j}=a_j+1$。如果先手取左侧：

- 若剩余石子大于 $l_{i,j-1}$，后手只需要在右侧取相同数量的石子就可以循环回到 Case3。
- 若剩余石子等于 $l_{i,j-1}$，后手只需要取完右端所有石子，触发 $a_{i-1}=l_{i,j-1}$ 的先手必败状态。
- 若剩余石子小于 $l_{i,j-1}$，后者只需要取右端石子直至与左端相等，则回到 Case2。由于有 $a_j≥l_{i,j-1}$，所以先手取完时一定有 $a_j≥l_{i,j-1}≥a_{i-1}$。

如果先手取右侧：

- 若剩余石子大于 $l_{i,j-1}$，后手只需要在左侧取石子直至比右端多一就可以回到 Case3。
- 若剩余石子等于 $l_{i,j-1}$，后手只需要在左侧取石子直至比右端多一就可以回到 Case3。
- 若剩余石子小于 $l_{i,j-1}$，后手只需要在左侧取石子直至与右端相等，则回到 Case2。

#### Case4：$a_j≤l_{i,j-1},\ a_j>r_{i,j-1}$

此时有 $l_{i,j}=a_j-1$。如果先手取左侧：

- 若剩余石子大于 $r_{i,j-1}$，后手只需要在右侧取石子直至比左端多一就可以回到 Case4。
- 若剩余石子等于 $r_{i,j-1}$，后手只需要在右侧取石子直至比左端多一就可以回到 Case4。
- 若剩余石子小于 $r_{i,j-1}$，后者只需要取右端石子直至与左端相等，则回到 Case2。

如果先手取右侧：

- 若剩余石子大于 $r_{i,j-1}$，后手只需要在左侧取相同数量的石子就可以循环回到 Case3。
- 若剩余石子等于 $r_{i,j-1}$，后手只需要取完左端所有石子，触发 $a_{j}=r_{i,j-1}$ 的先手必败状态。
- 若剩余石子小于 $r_{i,j-1}$，后者只需要取左端石子直至与右端相等，则回到 Case2。

#### Case5：$a_j≥l_{i,j-1},\ a_j>r_{i,j-1}$

此时有 $l_{i,j}=a_j$。无论先手取哪一侧：

- 若剩余石子小于 $l_{i,j-1}，r_{i,j-1}$，一定可以回到 Case2。
- 若剩余石子大于 $l_{i,j-1}，r_{i,j-1}$，一定可以回到 Case5。
- 若剩余石子等于 $l_{i,j-1}，r_{i,j-1}$，后手可以通过在另一堆取石子回到 Case4 或 Case3。

上面的五个 Case 对称过来就是其他的方案，方案类似不再赘述。最后只需要判断 $a_1$ 是否等于 $l_{2,n}$

### Code：

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<climits>
#include<algorithm>
#include<utility>
#define int long long
using namespace std;
const int MaxN=1003;
int lL[MaxN][MaxN], rR[MaxN][MaxN], a[MaxN];

inline int Read(){
	int num = 0, op = 1;
	char ch = getchar();
	while(!isdigit(ch)){
		if(ch == '-') op = -1;
		ch = getchar();
	}
	while(isdigit(ch)){
		num = num * 10 + ch - '0';
		ch = getchar();
	}
	return num * op;
}

signed main(){
	int T = Read();
	while(T--){
		int n = Read();
		for(int i=1;i<=n;++i)
			a[i] = Read(), lL[i][i] = rR[i][i] = a[i];
		for(int len=1; len<n; len++){
			for(int l=1,r=l+len; r<=n; l++,r++){
				int x, L, R;
				x = a[r], L = lL[l][r-1], R = rR[l][r-1];
				if(x == R) lL[l][r] = 0;
				else if(x > R && x > L || x < R && x < L) lL[l][r] = x;
				else if(x >= L && x < R) lL[l][r] = x + 1;
				else if(x > R && x <= L) lL[l][r] = x - 1;
				x = a[l], L = lL[l+1][r], R = rR[l+1][r];
				if(x == L) rR[l][r] = 0;
				else if(x > R && x > L || x < R && x < L) rR[l][r] = x;
				else if(x > L && x <= R) rR[l][r] = x - 1;
				else if(x >= R && x < L) rR[l][r] = x + 1;
			}
		}
		if(a[1]==lL[2][n]) printf("0\n");
		else printf("1\n");
	}
	return 0;
}
```



---

## 作者：xiaolilsq (赞：12)

**特别说明：本题解和yyb的题解内容大部分相似，但是对yyb可能没有说到的细节进行了补充。**

~~此神仙题不可做（确信~~

记$L_{l,r}$表示如果在$l$到$r$这个区间左边添上一堆石子数量为$L_{l,r}$的石子堆时先手必败，记$R_{l,r}$表示如果在$l$到$r$这个区间右边添上一堆石子数量为$R_{l,r}$的石子堆是先手必败。

首先证明$L_{l,r}$和$R_{l,r}$唯一，假设$L_{l,r}$存在两个取值$x,y(x<y)$，那么当添上去的石子堆数为$y$时先手可以把$y$拿成$x$，换成后手拿，此时后手必败，先手必胜，与假设矛盾（当添上去石子数为$y$时先手必败），所以$L_{l,r}$唯一，$R_{l,r}$同理。

接下来证明$L_{l,r}$和$R_{l,r}$存在，假设$L_{l,r}$不存在，即无论在左边添上去的石子数量为多少，先手都必胜，假设左边添上$x$，那么先手必然不会拿左边的这个$x$，因为拿了后还是必胜态，所以先手会从右边拿，那么在拿完后无论$x$为多少都是必败态，后手如果拿了左边的$x$得到的还是必败态，与“无论$x$为多少都是必败态矛盾”，所以$L_{l,r}$存在，$R_{l,r}$同理。

再证明一些结论吧：

引理一：

若$L_{l,r}=0$，那么$R_{l,r}=0$（$R_{l,r}=0$时同理）。因为$L_{l,r}=0$，局面为$(0,[l,r])$即$([l,r])$时先手必败。假设$R_{l,r}\ne 0$，那么先手可以直接把右边拿成$0$，此时局面变成$([l,r])$，后手操作，所以后手必败，与原先假设先手必败矛盾，所以结论成立。

考虑$L_{l,r}$如何转移（$R_{l,r}$同理）：

方便起见，记$L=L_{l,r-1},R=R_{l,r-1},x=a_r$。

***

$$\mathsf{Case 1: x=R}$$

$L_{l,r}=0$。相当于原本就是必败态。

$$\mathsf{Case 2: x<L,x<R}$$

$L_{l,r}=x$。由必胜必败态的定义可以知道当石子数量为$(0\sim L-1,[l,r-1])$或者$([l,r-1],0\sim R-1)$时先手必胜。可以在左边添上一堆数量为$x$的石子，此时先手从哪一边拿石子，后手就从另一边拿相同数量的石子，此时必然会有一堆先被拿完，拿完后操作方变成后手，局面变为$(0\sim L-1,[l,r-1])$或$([l,r-1],0\sim R-1)$，后手必胜。

$$\mathsf{Case 3: R<x\le L}$$

$L_{l,r}=x-1$。假设先手拿左边，左边剩$y$个石子：若$y<R$，后手可以直接把右边拿成$y$，变成$\mathsf{Case 2}$里面的情况；若$y\ge R$，后手把右边拿成$y+1$，回到$\mathsf{Case 3}$。假设先手拿右边，右边剩$y$个石子：若$y=R$，如果$R\ne 0$，左边剩余石子数必然大于$0$，后手直接把左边拿完，变成$\mathsf{Case 1}$，否则$R=0$，由引理一得到$L=0$，不存在$R<x\le L$，即该情况不存在；若$y<R$，那么先手上一步至少拿了两个石子（$y\ge R+1\to y\le R-1$），左边石子数量必然大于$y$，后手可以把左边拿成$y$，变成$\mathsf{Case 2}$；若$y>R$，后手把左边拿成$y-1$，回到$\mathsf{Case 3}$。

$$\mathsf{Case 4: L\le x<R}$$

$L_{l,r}=x+1$。这个和$\mathsf{Case 3}$类似，建议读者先自己想想。假设先手拿左边，左边剩$y$个石子：若$y=L$，如果$L\ne 0$，右边剩余石子数必然大于$0$，后手直接把右边拿完，变成$\mathsf{Case 1}$，否则$L=0$，由引理一得到$R=0$，不存在$L\le x<R$，即该情况不存在；若$y<L$，那么先手上一步至少拿了两个石子（$y\ge L+1\to y\le L-1$），右边石子数量必然大于$y$，后手可以把右边拿成$y$，变成$\mathsf{Case 2}$；若$y>L$，后手把右边拿成$y-1$，回到$\mathsf{Case 4}$。假设先手拿右边，右边剩$y$个石子：若$y<L$，后手可以直接把左边拿成$y$，变成$\mathsf{Case 2}$；若$y\ge L$，后手把左边拿成$y+1$，回到$\mathsf{Case 4}$。

$$\mathsf{Case 5: x>L,x>R}$$

$L_{l,r}=x$。分类讨论后不难变成以上四种$\mathsf{Case}$，请读者自行思考。

***

$R_{l,r}$和$L_{l,r}$的求解类似，不再赘述。

最后只要判断一下$L_{2,n}$是否等于$a_1$就可以判断正负了。

**另：yyb没有提到的$x=L$如何处理的情况被放到了$\mathsf{Case 3,4}$里面了，因为添加了这两种情况后证明方法还是一样的。**

代码如下：

```cpp

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
using namespace std;
template<typename T>void read(T &x){
	x=0;int f(1);char c(getchar());
	for(;!isdigit(c);c=getchar())if(c=='-')f=-f;
	for(; isdigit(c);c=getchar())x=(x<<3)+(x<<1)+(c-'0');
	x*=f;
}
template<typename T>void write(T x){
	if(x<0)putchar('-'),x=-x;
	if(x/10)write(x/10),x%=10;
	putchar(x+'0');
}
const int maxn=1005;
int lL[maxn][maxn],rR[maxn][maxn],a[maxn];
int main(){
	int t;read(t);
	while(t--){
		int n;read(n);
		for(int i=1;i<=n;++i)
			read(a[i]),lL[i][i]=rR[i][i]=a[i];
		for(int len=1;len<n;++len){
			for(int l=1,r=l+len;r<=n;++l,++r){
				int x,L,R;
				x=a[r],L=lL[l][r-1],R=rR[l][r-1];
				if(x==R)lL[l][r]=0;
				else if(x>R&&x>L||x<R&&x<L)lL[l][r]=x;
				else if(x>=L&&x<R)lL[l][r]=x+1;
				else if(x>R&&x<=L)lL[l][r]=x-1;
				x=a[l],L=lL[l+1][r],R=rR[l+1][r];
				if(x==L)rR[l][r]=0;
				else if(x>R&&x>L||x<R&&x<L)rR[l][r]=x;
				else if(x>L&&x<=R)rR[l][r]=x-1;
				else if(x>=R&&x<L)rR[l][r]=x+1;
			}
		}
		puts(a[1]==lL[2][n]?"0":"1");
	}
	return 0;
}

```

---

## 作者：Jμdge (赞：10)

瞪了题解两三天，直接下转第二篇题解就康懂了


首先我们令 ：

>$L[i][j]$ 表示当前 $[i,j]$ 区间左侧放置 $L[i,j]$ 数量的石子后先手必败 

>$R[i][j]$ 表示当前 $[i,j]$ 区间右侧放置 $R[i,j]$ 数量的石子后先手必败


那么最后我们只要判断 $a[1]$ 是否等于 $L[2,n]$ 或者 $a[n]$ 是否等于 $R[1,n-1]$ 即可

## 唯一性

考虑证明 $L[i][j]$ 和 $R[i][j]$ 的唯一性，发现我们只需要证明一个成立即可

假设 $L[i][j]$ 存在两个，那么我们先让 $[i,j]$ 左边放上大的 $L[i][j]$ ，那么它可以一步转移到另一个小的 $L[i][j]$ ，仍旧是一个必败态，与定义矛盾，故 $L[i][j]$ 只存在一个合法值


## 转移




然后我们分类讨论...

假设当前处理到了 $L[i][j]$ ，那么我们根据 $L[i][j-1] ,R[i][j-1] ,a[j]$ 来处理，我们令 $L=L[i][j-1],R=R[i][j-1],x=a[j]$ 

1. $x=R$

	这种情况下，我们令 $L[i][j]=0$ ，因为 [i,j] 已经是个必败态了，左边加上任意石子，先手都可以全部取完，然后后手面对必败态

2. $x<L,x<R$
           
	这种情况下，我们令 $L[i][j]=x$ ，这样先手不管从哪堆开始取，如果没有取完，后手只需要在另一堆取走相同数量的石子，就回到了原来的情况，那么如果说先手把一堆取完了，另一堆的石子数量必然是小于 L 和 R 的，相当于是先手从数量为 L 或者 R 的堆中取走了一些石子，后手必胜


3. $L<=x<R$        

	这种情况下，我们令 $L[i][j]=x+1$ ，这样先手左边取左边取，取到 L 时，后手取光右边即可；左边取到比 L 大的话，右边只要取走相同的石子就好了，这样可以变回同样的状态；取到比 L 小的话，右边取到相同的石子数为止，这样两边的石子数都小于 L 和 R ，这样就回到了状态 2 ；如果先手在右边取，如果取到比 L 大，我们维持状态即可，和上面一样；如果比 L 小，那么我们左边取到和左边相等，这样还是回到了状态 2 ；如果右边被先手取光了，那么我们把左边取到 L ，先手面临的就是必败态了


4. $R<x<L$

	这种情况下，我们令 $L[i][j]=x-1$ 即可，讲道理是和状态 3 差不多的情况 Q^Q


5. $[i,i]$ 的边界情况

	我们只需要让 $L[i][i]=a[i]$ 即可...因为左边放上 a[i] 就是先手必败的状态，考虑此时无论先手在哪里取，后手只要在另一堆里面取相同石子即可...


## 感谢

ORZ YYB

# Code

```cpp
//by Judge
#include<bits/stdc++.h>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define ll long long
using namespace std;
const int M=1003;
typedef int arr[M][M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline ll read(){ ll x=0,f=1; char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} char sr[1<<21];int CC=-1;
inline void Ot(){fwrite(sr,1,CC+1,stdout),CC=-1;}
int n,a[M]; arr L,R;
int main(){ int T=read();
	while(T--){ n=read();
		fp(i,1,n) L[i][i]=R[i][i]=a[i]=read();
		fp(len,1,n-2) fp(i,2,n-len){
			Rg int j=i+len;
			if(R[i][j-1]==a[j]) L[i][j]=0;
			else if(L[i][j-1]>a[j]&&R[i][j-1]>a[j]) L[i][j]=a[j];
			else if(L[i][j-1]<=a[j]&&R[i][j-1]>a[j]) L[i][j]=a[j]+1;
			else if(L[i][j-1]>a[j]&&R[i][j-1]<a[j]) L[i][j]=a[j]-1;
			else L[i][j]=a[j];
			if(R[i+1][j]==a[i]) R[i][j]=0;
			else if(L[i+1][j]>a[i]&&R[i+1][j]>a[j]) R[i][j]=a[i];
			else if(L[i+1][j]<=a[i]&&R[i+1][j]>a[j]) R[i][j]=a[i]+1;
			else if(L[i+1][j]>a[i]&&R[i+1][j]<a[j]) R[i][j]=a[i]-1;
			else R[i][j]=a[i];
		}
		sr[++CC]=48+(a[1]!=L[2][n]),sr[++CC]='\n';
	}
	return Ot(),0;
}
```





---

## 作者：hovny (赞：7)

## 前言

非常神仙的**动态规划**

## 解题思路

**动态~~鬼~~规划**

### 分析

感觉这道题还是比较看技巧的，~~（是谁想出来的，太妙了呀！推出去打~~

用 $L[i][j]$ 表示在 $[i,j]$ 这个区间左侧（也就是 $i-1$ 的位置）放多少石子可以保证**先手必败**

同上，用 $R[i][j]$ 表示在 $[i,j]$ 这个区间右侧放多少石子可以保证先手必败

接下去，我们要证明一下 $L[i][j]$ 和 $R[i][j]$ 的**唯一（存在）性**

#### $L[i][j]$ 和 $R[i][j]$ 的唯一性

以 $L[i][j]$ 为例（$R[i][j]$ 同理），

1、若 $L[i][j]$ 不唯一，设其中两个值分别为 $L_1,L_2$ （$L_1 < L_2$），显然 $L_2$ 可以经过先手取一次变成 $L_1$ 的状态，与此时与先手必败矛盾，所以 $L[i][j]$ 唯一存在

2、若 $L[i][j]$ 不存在，也就是说在 $[i,j]$ 区间石子左侧无论放多少，先手都是必胜态，那么也就是说从右侧拿石子就会达到一个必败态，但是由于，左侧的石子数可以任意，那么就变成了$L[i][j]$ 不唯一的情况（除左侧一堆石子数是不一样外，其他都一样），这与我们在 `1` 中得出的结论矛盾，一次 $L[i][j]$ 必定存在

#### 考虑 $L[i][j]$ 和 $R[i][j]$ 的初始化

边界即为：$i=j$ 时， $L[i][i]$ 与 $R[i][i]$ 的状态，这个时候就是个 $Nim$ 游戏，显然 $L[i][i]=R[i][i]=a[i]$ 即可

#### 考虑 $L[i][j]$ 和 $R[i][j]$ 的转移

以 $L[i][j]$ 为例，分类讨论

**0、**显然 $L[i][j]$ 的转移与 $L[i][j-1]$ 以及 $R[i][j-1]$ 有关，与 $L[i+1][j]$ 以及 $R[i+1][j]$ 无关

那么，令 $x=a[j]$ (第 $j$ 堆石子数)，$l=L[i][j-1]$，$r=R[i][j-1]$

**1、**当 $r=x$ 时，$L[i][j]=0$

此时 $[i,j]$ 已是先手必败态，因此 $L[i][j]=0$ 即可

**2、**当 $x<l$ 且 $x<r$ 时，$L[i][j]=x$

也就是说此时两侧的石子数一致，无论先手怎么取，后手只要模仿先手在另一侧取相同的数量，这样就能保证先手先取完，此时左侧或右侧肯定仍有一堆没有取完，此时可以等价认为当前状态是 先手从 $l$ 或 $r$ 的状态取一定数量的石子转移而来

**3、**当 $l<x<r$ 时，$L[i][j]=x+1$

若先手在左侧取，剩下石子数为 $rest$ ，

当 $rest=0$ 时，等价于 先手在 $r$ 的状态下，在右侧取了一定数量的石子转移而来

当 $rest<l$ 时，后手只要将右侧的石头取到和 $rest$ 相同的数目，即可转移到 `2` 的情况

当 $rest=l$ 时，后手将右侧取完就可以让先手达到必败态

当 $rest>l$ 时，后手只要将右侧石子取到 $rest-1$ 即可重新回到当前状态

若先手在右侧取，剩下石子数为 $rest$ ，

当 $rest=0$ 时，后手把左侧石子取到 $l$ 即可

当 $rest<l$ 时，同上，取左侧，可以转移到 `2` 的情况

当 $rest>=l$ 时，后手通过在左侧或右侧取，使 `左侧石子数=右侧石子数+1` 即可

**4、**当 $l>x>r$ 时，$L[i][j]=x-1$

这种情况与 `3` 一致，可以认为只是互换了一下左右两侧而已

**5、**当 $x>l$ 且 $x>r$ 时，$L[i][j]=x$

若先手在左侧取，剩下石子数为 $rest$，

当 $rest=0$ 时，后手将右侧石子取至 $r$ 即可

当 $l<rest$ 时，可转移至 `2`

当 $l=rest$ 时，右侧直接取完

当 $rest \in [l,r]$ 或 $rest\in[r,l]$ 时，可转移至 `3` 或 `4`

当 $l<rest$ 且 $r<rest$ 时，保持当前状态即可

#### 判断

由于左侧和右侧是等价的，因此最后只需判断 $L[2][n]$ 是否等于 $a[1]$

## Code

删了读优以及无效的模板

```cpp
#include<bits/stdc++.h>
#define N 1003
using namespace std;
int n,T,a[N],L[N][N],R[N][N];
int main()
{
	int i,j,l,r,k,x;
	T=read();
	while(T--) {
		n=read();
		for(i=1;i<=n;i++) L[i][i]=R[i][i]=a[i]=read();//初始化
		for(k=2;k<n;k++) {//枚举区间长度
			for(i=1,j=i+k-1;j<=n;i++,j++) {//枚举左右端点
				x=a[j],l=L[i][j-1],r=R[i][j-1];
				if(x==r) L[i][j]=0;//情况1
				else if((x>l&&x>r)||(x<l&&x<r)) L[i][j]=x;//情况2、5
				else if(r<x&&x<l) L[i][j]=x-1;//情况4
				else L[i][j]=x+1;//情况3
				x=a[i],l=L[i+1][j],r=R[i+1][j];//同理可得
				if(x==l) R[i][j]=0;
				else if((x>l&&x>r)||(x<l&&x<r)) R[i][j]=x;
				else if(l<x&&x<r) R[i][j]=x-1;
				else R[i][j]=x+1;
			}
		}
		putchar(a[1]==L[2][n]?'0':'1'),putchar('\n');
	}
	return 0;
}
```
### 参考&鸣谢

@Jason_Yvan @yybyyb


---

## 作者：Lagerent (赞：3)

## 设计状态

假定当前 $[i, j]$ 范围内的石子已经确定，第 $i$ 堆的石子数量为 $a_i$。

设 $l_{i, j}$ 表示在 $[i, j]$ 左边放一堆石子，且先手必败时在左边放的石子数，$r_{i, j}$ 表示在 $[i, j]$ 右边放一堆式子，且先手必败时在右边的先手数量。

由于 $l_{i, j}$ 与 $r_{i, j}$ 是完全**对称**的，因此仅说明 $l_{i, j}$ 的求法，$r_{i, j}$ 对称过去即可。

**结论 1**：$l_{i, j}$ 必然存在且唯一。

证明：假设左边有两个取值 $x_1, x_2, x_1 > x_2$ 使得先手必败，那么我们先手从左边拿 $x_1 - x_2$ 个石子，留给后手的就是必败态，那么当前就不是必败态。

最后判断答案时，仅需判断 $l_{2, n}$ 是否等于 $a_1$ 即可。

## 转移

定义 $L = l_{i , j - 1}, R = r_{i, j - 1}$，$X = a_j$，要求 $l_{i, j}$。

- **情况 1**（$R = X$）：不算 $L$ 时已经是必败态，令 $l_{i, j} = 0$ 即可。

- **情况 2**（$X < \min(L, R)$）：令 $l_{i, j} = X$ 即可。无论先手怎么取，我们都在另一边跟先手去等量的石子数。必然存在当先手取到 $0$ 时，我们还剩 $y$ 个石子。由 $0 < y \le x < \min(L, R)$ 及结论 1 可得，留给后手的 $y$ 一定不是必败态，那么当前就是必败态。

- **情况 3** 
  - **3.1**（$R < X \le L$）：令 $l_{i, j} = X - 1$ 即可。
      - **先手取右边**：设右边取完后还剩下 $t$ 个石子。
          - $R < t \le L$，还是**情况 3.1**，我们还是在左边取到剩 $t - 1$。
          - $t = R$，那么转换为**情况 1**，我们直接取空左边即可。
          - $t < R$，那么转换为**情况 2**，仍然先手必败。
      - **先手取左边**：设左边取完后还剩下 $t$ 个石子。
          - $R \le t \le L$，还是**情况 3.1**，把右边取到剩 $t + 1$。
          - $t < R$，那么转换为**情况 2**，仍然先手必败。
  - **3.2**（$L \le X < R$）：令 $l_{i, j} = X + 1$ 即可。
      - **先手取右边**：设右边取完后还剩下 $t$ 个石子。
          - $L \le t < R$，还是**情况 3.2**，把左边取到剩 $t + 1$。
          - $t < L$，转换为**情况 2**，仍然先手必败。
      - **先手取左边**：设左边取完后还剩下 $t$ 个石子。
          - $L < t < R$，还是**情况 3.2**，把右边取到剩下 $t - 1$。
          - $t = L$，转换为**情况 1**，我们直接取空右边即可。
          - $t < L$，转换为**情况 2**，仍然先手必败。

- **情况 4**（$X > \max(L, R)$）：不妨设 $L < R$，令 $l_{i, j} = X$ 即可。设先手取完剩下 $t$ 个。
  - $t > \max(L, R)$，还是**情况 4**，我们取等量石子即可。
  - $L \le t \le R$，转换为**情况 1**或**情况 3**，仍然先手必败。
  - $t < L, t < R$，转换为**情况 2**，仍然先手必败。

大功告成！

## Code

```
#include<cstdio>
#define rep(a, b, c) for(int (a) = (b); (a) <= (c); ++ (a))
#define per(a, b, c) for(int (a) = (b); (a) >= (c); -- (a))
using namespace std;

const int N = 1010;

int n, a[N];
int l[N][N], r[N][N];

int main() {
    int T;
    scanf("%d", &T);
    while(T -- ) {
        scanf("%d", &n);
        rep(i, 1, n) scanf("%d", &a[i]);

        rep(len, 1, n) {
            rep(i, 1, n - len + 1) {
                int j = i + len - 1;
                if(len == 1) l[i][j] = r[i][j] = a[i];
                else {
                    int L = l[i][j - 1], R = r[i][j - 1], X = a[j];
                    if(R == X) l[i][j] = 0;
                    else if((X < L && X < R) || (X > L && X > R)) l[i][j] = X;
                    else if(L > R) l[i][j] = X - 1;
                    else l[i][j] = X + 1;

                    L = l[i + 1][j], R = r[i + 1][j], X = a[i];
                    if(L == X) r[i][j] = 0;
                    else if((X < L && X < R) || (X > L && X > R)) r[i][j] = X;
                    else if(R > L) r[i][j] = X - 1;
                    else r[i][j] = X + 1;
                }
            }
        }
        if(n == 1) puts("1");
        else printf("%d\n", (l[2][n] != a[1])); 
    }
    return 0;
}
```

---

## 作者：VenusM1nT (赞：3)

$\textbf{DP}$。  
神仙的状态设计啊……  
首先考虑一列石子怎样使后手必胜，显然是两端石子相同，因为不管先手怎么操作，后手都可以使石子变回两端石子相同的状态，最后一次一定是后手取。  
转换为先手必胜，那么就是**能使两端石子相同的状态**。  
我们令 $f_{i,j}$ 代表在 $[i,j]$ 这个区间左侧放置 $f_{i,j}$ 个石子后先手必败，令 $g_{i,j}$ 代表在 $[i,j]$ 这个区间右侧放置 $g_{i,j}$ 个石子后先手必败，然后分类讨论怎么转移。
 1. 边界 $[i,i]$  
  这种情况显然 $f_{i,i}=g_{i,i}=a_i$，就可以做到先手必败。
 2. $a_j=g_{i,j-1}$  
  此时已经先手必败，$f_{i,j}=0$。
 3. $a_j<f_{i,j-1}$ 且 $a_j<g_{i,j-1}$  
  此时 $f_{i,j}=a_j$，显然是一个先手必败的状态，与开头阐述的一致。
 4. $a_j\ge f_{i,j-1}$ 且 $a_j<g_{i,j-1}$  
  此时 $f_{i,j}=a_j+1$。若先手取左侧，则有三种情况：剩余石子大于 $f_{i,j-1}$，后手只需在右侧取相同数量的石子；剩余石子等于 $f_{i,j-1}$，后手只需取完右侧石子；剩余石子若小于 $f_{i,j-1}$，后手只需取到相同石子，则回到 3 状态，先手必败。若先手取右侧，大于、小于两种情况与左侧一样处理，如果取完了，后手只需将左侧取到 $f_{i,j-1}$，依然是先手必败。
 5. $a_j<f_{i,j-1}$ 且 $a_j>g_{i,j-1}$  
  此时 $f_{i,j}=a_j-1$，情况与 4 状态相反。
 6. $a_j>f_{i,j-1}$ 且 $a_j>g_{i,j-1}$  
  此时 $f_{i,j}=a_j$。不论先手取哪一堆，假定先手取到 $a$ 个石子，若 $a<f_{i,j-1},g_{i,j-1}$，可以回到 3 状态；若 $a>f_{i,j-1},g_{i,j-1}$，后手只需拿一样多的石子就可以回到当前状态；否则将另一堆取到 $a+1$ 或 $a-1$，可以回到 4 状态或 5 状态。  
显然最后只要判断 $a_1$ 与 $f_{2,n}$ 是否相等即可。由于 $g_{i,j}$ 与 $f_{i,j}$ 对称，可以类似求解。
```cpp
#include<bits/stdc++.h>
#define MAXN 1005
#define reg register
#define inl inline
using namespace std;
int n,a[MAXN],f[MAXN][MAXN],g[MAXN][MAXN];
int main()
{
	reg int Time;
	scanf("%d",&Time);
	while(Time--)
	{
		memset(f,-1,sizeof(f));
		memset(g,-1,sizeof(g));
		scanf("%d",&n);
		for(reg int i=1;i<=n;i++) scanf("%d",&a[i]);
		if(n==1)
		{
			puts("1");
			continue;
		}
		for(reg int i=1;i<=n;i++) f[i][i]=g[i][i]=a[i];
		for(reg int i=1;i<=n-1;i++)
		{
			for(reg int j=1;j<=n-i;j++)
			{
				if(g[j][i+j-1]==a[i+j]) f[j][i+j]=0;
				else if((a[i+j]<g[j][i+j-1] && a[i+j]<f[j][i+j-1]) || (a[i+j]>g[j][i+j-1] && a[i+j]>f[j][i+j-1])) f[j][i+j]=a[i+j];
				else if(g[j][i+j-1]<f[j][i+j-1]) f[j][i+j]=a[i+j]-1;
				else f[j][i+j]=a[i+j]+1;
				if(f[j+1][i+j]==a[j]) g[j][i+j]=0;
				else if((a[j]<f[j+1][i+j] && a[j]<g[j+1][i+j]) || (a[j]>f[j+1][i+j] && a[j]>g[j+1][i+j])) g[j][i+j]=a[j];
				else if(f[j+1][i+j]<g[j+1][i+j]) g[j][i+j]=a[j]-1;
				else g[j][i+j]=a[j]+1;
			}
		}
		puts(g[1][n-1]==a[n]?"0":"1");
	}
	return 0;
}
```

---

## 作者：Azote (赞：0)

考虑 $l_{i,j}$ 为 $a_{i} \sim a_{j}$ 左侧放置的最小值使得先手必败，则原问题的答案即为 $a_1$ 是否等于 $l_{2,n}$。

如果相等，先手必败。
如果 $a_1 \geq l_{2,n}$ 则先手可以通过拿取部分石头使得后手进入 $a_1 = l_{2,n}$ 的必败局面。
如果 $a_1 \leq l_{2,n}$ 则根据 $l_{2,n}$ 的定义，先手必胜。

故先手必败当且仅当 $a_1=l_{2,n}$。

 **性质：$l_{i,j}$ 必然存在且唯一。** 
 
 关于存在，后文分讨证明，先证明唯一性：
 
 若存在两个 $l_{i,j}$，不妨记为 $L_1$，$L_2$，且必然有 $L_1 < L_2$，否则交换 $L_1$，$L_2$。
 
 因为 $L_2 > L_1$, 所以显然可以通过取 $L_2 - L_1$ 个石子使得后手进入 $L_1 = l_{i,j}$ 的必败状态，则 $L_2$ 是先手的必胜状态，与定义相矛盾。

 故若 $l_{i,j}$ 存在，必然唯一。
 
 考虑递归求 $l_{i,j}$ (同时也是对存在性的证明)
 
 为表示方便，定义 $r_{i,j}$ 为 $a_{i} \sim a_{j}$ 右侧放置的最小值使得先手必败，下文中使用 $L$ 代替 $l_{i,j-1}$，$R$ 代替 $r_{i,j-1}$，$X$ 代替 $a_j$ 。

* $i = j$

    即只有一堆，此时根据普通Nim游戏的结论，$l_{i,j} = X$ 时先手必败。
    
    若先手在其中一堆拿了 $c$ 个石子，后手在另一堆拿 $c$ 个石子即可保证两堆石子数量相同，容易证明最后一颗石子一定是后手拿取的。

* $X = R$

    $l_{i,j} = 0$，因为在 $a_{i} \sim a_{j - 1}$ 中先手是必败的，所以在左侧非零时，先手存在拿取全部石子使得后手必败的策略，故 $l_{i,j} = 0$。

* $X < R$ 且 $X < L$

    $l_{i,j} = X$ 与 $i = j$ 时情况类似，后手的策略同样是与先手进行相同数量，不同位置的拿取，这样先手一定会先拿掉最后一颗石子，此时后手面临的局面是在 $a_i \sim a_{j-1}$ 左侧或右侧剩下一个比 $X$ 小的数，设为 $Y$。
    考虑剩下的一端，因为 $Y \leq X < \min(L,R)$ 所以 $Y$ 一定不是 $L$，$R$ 其中之一，根据定义，$Y < \min(L,R)$ 等价于该局面不必输，所以后手一定必胜，则先手一定必输。

* $R < X \leq L$

    $l_{i,j} = X - 1$
    
    若先手将右侧拿至 $R$，则后手可以拿取左侧全部石子使得先手必败。
    
    若先手将右侧拿至 $ < R$，则后手可以使得左侧石子等于右侧石子，情况等同于 $X < L$ 且 $X < R$。
    
    若先手将右侧拿至 $ > R$，则后手可以使得左侧石子数始终等同于右侧石子数 $-1$，容易知道在若干次拿取后一定会出现上面两种情况。
    
    特殊情况：当 $R = 0$ 时，一直保持策略会出现左侧为 $0$，右侧为 $1$ 的情况，此时右侧拿取 $1$ 个石子使得进入必败局面，而后手在左侧没有石子可拿，先手必胜。

    经实际验证该情况不存在，在这里粗略的证明一个新的性质（如有错误，请指出；如有更好的证法，可以分享）。
    
    **性质：$L$ 与 $R$ 可以都为零，或都非零，但不能存在其中一零一非零的情况。**
    
    证明：
    考虑 $l_{i,j}$ 与 $r_{i,j}$ 的实际意义。
    
    若两者都不为零则为正常状态。
    
    若其一为零则说明原序列 $a_i \sim a_j$ 是一个必输局面，若另一侧不为零则违反前面证明的唯一性，故另一侧也应当为零。
    
    所以这种特殊情况中 $R = 0$，必有 $L = 0$。
    
    故 $R = 0 < X \leq L = 0$，矛盾。
    
    先手拿左侧同理：
        
    若先手拿至 $ < R$，则后手可以使得左侧石子等于右侧石子，情况等同于 $X < L$ 且 $X < R$。
        
    若先手将右侧拿至 $\geq R$，则后手可以使得左侧石子数始终等同于右侧石子数+1。

*   $L \leq X < R$

   $l_{i,j} = X + 1$，证明过程等同于 $ R < X \leq L $ 的情况，读者可自证。

*   $X > R$ 且 $X > L$

   $l_{i,j}=X$，策略仍然是与先手进行相同数量，不同位置的拿取，易证在若干次拿取后会进入上面的情况之一。
       
    
每种 $X$，$L$，$R$ 的大小关系都存在 $l_{i,j}$，故其一定存在。

对于 $r_{i,j}$ 的讨论与上面类似。
    
使用区间 DP 的形式递推计算 $l_{i,j}$ 与 $r_{i,j}$ 即可。

对与 $n=1$ 的情况因为不存在 $l_{2,n}$，需特判。
    
    
    
```cpp
#include <iostream>
#include <cstdio>

const int N = 1e3 + 5;

int a[N], l[N][N], r[N][N], n, T;

int main()
{
    scanf("%d", &T);
    while (T--)
    {
        scanf("%d", &n);
        for (int i = 1; i <= n; ++i)
            scanf("%d", a + i);
        for (int i = 1; i <= n; ++i)
            l[i][i] = r[i][i] = a[i];
        for (int len = 2; len <= n; ++len)
            for (int i = 1; i + len - 1 <= n; ++i)
            {
                int j = i + len - 1;
                int L = l[i][j - 1], R = r[i][j - 1], X = a[j];
                if (X == R)
                    l[i][j] = 0;
                else if (X < L && X < R || X > L && X > R)
                    l[i][j] = X;
                else if (X > R && X <= L)
                {
                    if (R == 0)
                        printf("error:%d %d", i, j);
                    l[i][j] = X - 1;
                }
                else if (X >= L && R > X)
                {
                    if (L == 0)
                        printf("error:%d %d", i, j);
                    l[i][j] = X + 1;
                }
                else
                    l[i][j] = X;

                L = l[i + 1][j], R = r[i + 1][j], X = a[i];
                if (X == L)
                    r[i][j] = 0;
                else if (X < L && X < R)
                    r[i][j] = X;
                else if (X > L && X <= R)
                {
                    if (L == 0)
                        printf("error:%d %d", i, j);
                    r[i][j] = X - 1;
                }
                else if (X >= R && X < L)
                {
                    if (R == 0)
                        printf("error:%d %d", i, j);
                    r[i][j] = X + 1;
                }
                else
                    r[i][j] = X;
            }

        if (n == 1)
            puts("1");
        else if (a[1] ^ l[2][n])
            puts("1");
        else
            puts("0");
    }
    return 0;
}
```

---


# [ZJOI2009] 对称的正方形

## 题目描述

Orez 很喜欢搜集一些神秘的数据，并经常把它们排成一个矩阵进行研究。最近，Orez 又得到了一些数据，并已经把它们排成了一个 $n$ 行 $m$ 列的矩阵。通过观察，Orez 发现这些数据蕴涵了一个奇特的数，就是矩阵中上下对称且左右对称的正方形子矩阵的个数。Orez 自然很想知道这个数是多少，可是矩阵太大，无法去数。只能请你编个程序来计算出这个数。


## 说明/提示

- 对于 $30\%$ 的数据 $1\le n,m\le 100$；
- 对于 $100\%$ 的数据 $1\le n,m\le 1000$，矩阵中的数的大小不超过 $10^9$。


## 样例 #1

### 输入

```
5 5
4 2 4 4 4 
3 1 4 4 3 
3 5 3 3 3 
3 1 5 3 3 
4 2 1 2 4 ```

### 输出

```
27```

# 题解

## 作者：miaowey (赞：13)

my\_blog: <http://blog.csdn.net/miaomiao\_ymxl/article/details/54667726>

1. 把矩阵变成(2n-1)\*(2m-1)的，即在数字中间补上0

2.（Manacher算法）定义lx[][], ly[][]数组分别表示对于每个矩阵中的数，它的左右（上下）的最长延伸回文串的长度

3.定义left[][]数组表示对于每个矩阵中的数，以它为中心，最多可以向左边延伸的半个矩形（保证上下回文）的长度（长度应小于所有在范围内的ly[][]的最小值）

4. 那么对于left[i]数组，它的左边界(j-left[i])是递增不减的，所以可以结合RMQ在O(n2)的时间内求出来

5. 所以right[][], up[][], down[][]数组定义类似

6. 那么最终的答案为min(left[][], right[][], up[][], down[][])的和再减去包含０的部分！


















```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<iostream>
#include<algorithm>
using namespace std;
#define LL long long
#define pb push_back
#define Set(a, v) memset(a, v, sizeof(a))
#define For(i, a, b) for(int i = (a); i <= (int)(b); i++)
#define Forr(i, a, b) for(int i = (a); i >= (int)(b); i--)
#define LOG (10+5)
#define MAXN (2000+5)
int f[MAXN][MAXN];
int map[MAXN][MAXN], lx[MAXN][MAXN], ly[MAXN][MAXN];
void read(int &x){
    char ch = getchar();
    while(ch < '0' || ch > '9') ch = getchar();
    x = 0;
    while(ch >= '0' && ch <= '9'){
        x = x*10+ch-'0';
        ch = getchar();
    }
}
int s[MAXN], Min[MAXN][LOG], Log[MAXN];
void Manacher(int *len, int n){
    int p0 = 0;
    For(i, 1, n){
        int pos = p0+len[p0];
        if(pos > i && len[2*p0-i]<(pos-i)) len[i] = len[2*p0-i];
        else{
            if(pos > i) len[i] = pos-i;
            while(i+len[i] < n && i-len[i] > 1 && s[i+len[i]+1]==s[i-len[i]-1]) ++len[i];
            p0 = i;
        }
    }
}
void makeRMQ(int x[MAXN][MAXN], int h, int n){
    Set(Min, 0x3f);
    For(i, 1, n) Min[i][0] = x[i][h];
    For(j, 1, 11) For(i, 1, n){
        if((i+(1<<j)-1) > n) break;
        Min[i][j] = min(Min[i][j-1], Min[i+(1<<(j-1))][j-1]);
    }
}
int query(int L, int R){
    int k = Log[R-L+1];
    return min(Min[L][k], Min[R-(1<<k)+1][k]);
}
int main(){
    int n, m;
    read(n); read(m);
    For(i, 2, n) Log[i] = Log[i>>1]+1;
    For(i, 1, n) For(j, 1, m) read(map[i*2-1][j*2-1]);
    n = n*2-1, m = m*2-1;
    For(i, 1, n){
        For(j, 1, m) s[j] = map[i][j];
        Manacher(lx[i], m);
    }
    For(i, 1, m){
        For(j, 1, n) s[j] = map[j][i];
        Manacher(ly[i], n);
    }
    Set(f, 0x3f);
    For(i, 1, n){
        makeRMQ(ly, i, m);
        int v = 1;
        For(j, 1, m){
            while(v<j && query(v, j) < (j-v)) v++;
            f[i][j] = min(f[i][j], j-v);
        }
        v = m;
        Forr(j, m, 1){
            while(v>j && query(j, v) < (v-j)) v--;
            f[i][j] = min(f[i][j], v-j);
        }
    }
    For(i, 1, m){
        makeRMQ(lx, i, n);
        int v = 1;
        For(j, 1, n){
            while(v<j && query(v, j) < (j-v)) v++;
            f[j][i] = min(f[j][i], j-v);
        }
        v = n;
        Forr(j, n, 1){
            while(v>j && query(j, v) < (v-j)) v--;
            f[j][i] = min(f[j][i], v-j);
        }
    }
    int ans = 0;
    For(i, 1, n) For(j, 1, m){
        if((i&1)&&(j&1)) ans += (f[i][j]>>1)+1;
        else if(!(i&1) && !(j&1)) ans += (f[i][j]+1)>>1;
    }
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：杨铠远 (赞：12)

好吧，这是一道JB题

一个二维哈希+二分

需要分别哈希左右对称和上下对称过后的矩形

对于长度为奇数的正方形，以格子（一个1$*$1的正方形）为中心二分最远符合条件的长度

对于长度为偶数的正方形，以格点（就是一个点）为中心二分最远符合条件的长度

我用的自然溢出哈希（~~取%毕竟太复杂了~~）

具体细节看代码

#### code：

```cpp
//Code by : Y-k-y
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <queue>
#include <vector>
#include <set>
#define int unsigned long long
#define base1 87
#define base2 31
const int N=1010;
using namespace std;
inline int rnd(){
	int res=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){res=res*10+ch-'0';ch=getchar();}
	return res*f;
}
int n,m,ans;
int a[N][N],b[N][N],fac1[N],fac2[N],bb[N][N],le[N][N],bbb[N][N],up[N][N];
inline int chk(int x,int y,int len){
	int yy=y;
	if(x>n||y>m)return 0;
	if(x<len||y<len)return 0;//unsigned 没有小于0的时候 所以不能写x-len<0 
	int ans1=a[x][y]-a[x-len][y]*fac2[len]-a[x][y-len]*fac1[len]+a[x-len][y-len]*fac1[len]*fac2[len];//正常正方形的hash值 
	y=m-(y-len);//列 对称 
	int ans2=le[x][y]-le[x-len][y]*fac2[len]-le[x][y-len]*fac1[len]+le[x-len][y-len]*fac1[len]*fac2[len];
	if(ans1!=ans2)return 0;
	y=yy;//恢复 
	x=n-(x-len);//行 对称 
	int ans3=up[x][y]-up[x-len][y]*fac2[len]-up[x][y-len]*fac1[len]+up[x-len][y-len]*fac1[len]*fac2[len];
	if(ans1!=ans3)return 0;
	if(ans1==ans2&&ans2==ans3)
	return 1;
	else return 0;
}
signed main(){
	cin>>n>>m;fac1[0]=fac2[0]=1;
	for(int i=1;i<=n;i++){
		fac1[i]=fac1[i-1]*base1;
	}
	for(int i=1;i<=m;i++){
		fac2[i]=fac2[i-1]*base2;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++)
		b[i][j]=rnd();
	}
	//正常的 
	for(int i=1;i<=n;i++){//二维哈希 
		for(int j=1;j<=m;j++){
			a[i][j]=a[i][j-1]*base1+b[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			a[i][j]+=a[i-1][j]*base2;
		}
	}
	//左右对称的 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			bb[i][j]=b[i][m-j+1];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			le[i][j]=le[i][j-1]*base1+bb[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			le[i][j]+=le[i-1][j]*base2;
		}
	}
	//上下对称的 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			bbb[i][j]=b[n-i+1][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			up[i][j]=up[i][j-1]*base1+bbb[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			up[i][j]+=up[i-1][j]*base2;
		}
	}
	
	//以格点为中心的 二分的值为边长的一半 所以贡献就为这个值 
	for(int i=1;i<n;i++){
		for(int j=1;j<m;j++){
			int l=0,r=n+1;int sum=0;
			while(l<r){
				int mid=(l+r)>>1;
				if(chk(i+mid,j+mid,mid+mid)){
					if(mid)sum=mid;l=mid+1;
				}
				else{
					r=mid;
				}
			}
			ans+=sum;
		}
	}
	//以格子为中心的 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			int l=0,r=n+1;int sum=0;
			while(l<r){
				int mid=(l+r)>>1;
				if(chk(i+mid,j+mid,mid+mid+1)){
					if(mid)sum=mid;l=mid+1;
				}
				else{
					r=mid;
				}
			}
			ans+=sum;
		}
	}
	cout<<ans+n*m;//加上每个小正方形的贡献 
	return 0;
}//拜拜 
/*  //好吧送两组比较水的例子 
//ins:
5 5
1 2 3 2 1
2 3 4 3 2
3 4 5 4 3
2 3 4 3 2
1 2 3 2 1 
out:27

ins:
4 4
1 2 2 1
2 3 3 2
2 3 3 2
1 2 2 1

out:
18 
*/
```


---

## 作者：conprour (赞：8)

# 分析
根据对称的定义，显然满足单调性。再看看范围，容易想到二分答案。

如何判断一个正方形是对称正方形？可以用二维 Hash 解决。

以下分为二分和二维 Hash 两个部分展开。
## 二分部分
首先确定，二分成立需要单调性，所以一定是从中心点二分，但是当正方形为奇数的时候中心点在中央的格子，那么偶数呢？

实际上，边长为偶数的时候正方形的重心在一个格点（就是一个点，不是格子）。

概括一下：

* 对于长度为奇数的正方形，以格子（一个 $1 \times 1$ 的正方形）为中心二分最远符合条件的长度。

* 对于长度为偶数的正方形，以格点（就是一个点）为中心二分最远符合条件的长度
那么二分的 ``check`` 函数就可以用二维 Hash 来 $O(1)$ 判断。

## 二维 Hash 部分
简单讲解一下板子需要注意的地方。

二维 Hash 的作用就是判断矩阵是否相同。

具体实现上就是横向和纵向分别算两次 Hash 值（$base1$ , $base2$ 取不同的值，模数 $mod$ 取一个值)。

对于 Hash 值的查询，类似二维前缀和，下面贴的代码中 $mi1$ , $base1$ 对应纵坐标 $y$ ， $mi2$ , $base2$ 对应横坐标 $x$，记住这个对应关系基本就不会写错。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long 
const int INF = 0x3f3f3f3f,N = 1e3+10,base1 = 233,base2 = 133;
const ll mod = 1e9+9; 
ull mi1[N<<1],mi2[N<<1],sum[N<<1][N<<1];
int len,a[N<<1][N<<1],n,m;
int ans;
void init()
{
	mi1[0]=mi2[0]=1;
	//这里所有的n,m不要忘记×2 
	for(int i=1;i<=m<<1;i++) mi1[i]=(mi1[i-1]*base1);
	for(int i=1;i<=n<<1;i++) mi2[i]=(mi2[i-1]*base2);
	for(int i=1;i<=n<<1;i++)
		for(int j=1;j<=m<<1;j++)	 
			sum[i][j]=sum[i][j-1]*base1+a[i][j];
	for(int i=1;i<=n<<1;i++)
		for(int j=1;j<=m<<1;j++)	 
			sum[i][j]+=sum[i-1][j]*base2;//注意这里是+= 
}
inline ll Hash(int xa,int ya,int xb,int yb)
{
	return sum[xb][yb]-sum[xa-1][yb]*mi2[xb-xa+1]-
		   sum[xb][ya-1]*mi1[yb-ya+1]+
		   sum[xa-1][ya-1]*mi1[yb-ya+1]*mi2[xb-xa+1];
}
inline bool check(int xa,int ya,int xb,int yb)
{
	return Hash(xa,ya,xb,yb)==Hash((n<<1)-xb+1,ya,(n<<1)-xa+1,yb)&&
		   Hash(xa,ya,xb,yb)==Hash(xa,(m<<1)-yb+1,xb,(m<<1)-ya+1);//+1要想好 
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)	
		for(int j=1;j<=m;j++)
			scanf("%d",&a[i][j]);			
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			a[i+n][j]=a[n-i+1][j];
			a[i][j+m]=a[i][m-j+1]; 
		}
	init();//忘记调用init()还调了半天 
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			//对于长度为奇数的正方形，以格子（一个1*1的正方形）为中心二分最远符合条件的长度
			int l=0,r=max(n,m);
			while(l<r)
			{
				int mid=(l+r+1)>>1;
				if(i-mid>=1&&j-mid>=1&&i+mid<=n&&j+mid<=m&&check(i-mid,j-mid,i+mid,j+mid)) l=mid;
				else r=mid-1;
			}
			ans+=l+1;
			//对于长度为偶数的正方形，以格点（就是一个点）为中心二分最远符合条件的长度
			l=0,r=max(n,m);
			while(l<r)
			{
				int mid=(l+r+1)>>1;
				if(i-mid+1>=1&&j-mid+1>=1&&i+mid<=n&&j+mid<=m&&check(i-mid+1,j-mid+1,i+mid,j+mid)) l=mid;
				else r=mid-1;
			}
			ans+=l;
			
		}
	printf("%d\n",ans); 
	return 0;
}
```


---

## 作者：20140408abcd (赞：8)

**【题目简述】**

	给定一个n行m列的矩阵。求矩阵中上下对称且左右对称的正方形子矩阵的个数。
    
### **【算法分析】**

**算法一：**

考虑直接暴力。
    
我们可以考虑枚举正方形子矩阵的左上角坐标(i,j)以及边长k，不难得到$O(n^2)$判断是否是上下对称且左右对称(以下简称对称)的正方形子矩阵。
    
直接实现这个暴力的时间复杂度为$O(n^5)$。

**算法二：**

考虑优化枚举正方形子矩阵的时间复杂度。
    
显然每个正方形子矩阵都有一个中心点。

满足若以这点为中心的最大对称的正方形子矩阵边长为k,则边长1~k-1的均对称。

那么就不需要顺序枚举k了。直接二分logn枚举：
    
时间复杂度$O(logn*n^4)$。

**算法三：**

考虑优化判断是否为对称正方形子矩阵的时间复杂度。
    
一个个枚举元素效率低下,考虑用哈希值表示整个矩阵。
    
明显若矩阵的哈希值等于上下颠倒和左右颠倒的矩阵的哈希值,这矩阵就是对称的。
    
设hash1[i][j]表示矩阵(1,1)~(i,j)的哈希值,hash2[i][j]表示矩阵(n,m)~(i,j)的哈希值hash3[i][j]表示矩阵(n,1)~(i,j)的哈希值。

以hash1求法为例
```
for (int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
        hash1[i][j]=hash1[i][j-1]*p1+a[i][j];
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
        hash1[i][j]+=hash1[i-1][j]*p2;
```

第一次是横着hash，用的是p1，此时的hash1[i][j]表示的是第i行长度为j的前缀串的hash值。

第二次是竖着hash，用的是p2，此时的hash1[i][j]发生了更新，此时的hash1[i][j]变成了（1,1）到（i-1,j）矩阵的hash值* p2+第i   行长度为j的前缀串的hash值，表示的是（1,1）到（i,j）矩阵的hash值。

然后求一个子矩阵的hash值时，比如正方形子矩阵的左上角坐标为（i,j）, 右下角坐标为（ii,jj）,边长为k,则子矩阵的hash值为:
hash1[ii][jj]-hash1[i-1][jj]*P2[k]-hash1[ii][j-1]*P1[k]+hash1[i-1][j-1]*P1[k]*P2[k];

(这个和二维前缀和有点类似)。

hash2与hash3类似,详细见代码。

这样实现的时间复杂度就是$O(logn*n^2)$了，可以通过全部数据。
【参考程序】
```

#include<bits/stdc++.h>
using namespace std;
int const mod=999983,p1=92083,p2=69061;
int n,m;
int a[2005][2005];
long long tot;
unsigned long long hash1[2005][2005],hash2[2005][2005],hash3[2005][2005];
unsigned long long P1[100005],P2[100005];
long long read()
{
	long long x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
	return x*f;
}
//三种不同hash求矩阵(i,j)~(ii,jj)的哈希值 
unsigned long long sum1(int i,int j,int ii,int jj,int k)
{
	return hash1[ii][jj]-hash1[i-1][jj]*P2[k]-hash1[ii][j-1]*P1[k]+hash1[i-1][j-1]*P1[k]*P2[k];
}
unsigned long long sum2(int i,int j,int ii,int jj,int k)
{
	return hash2[ii][j]-hash2[i-1][j]*P2[k]-hash2[ii][jj+1]*P1[k]+hash2[i-1][jj+1]*P1[k]*P2[k];
}
unsigned long long sum3(int i,int j,int ii,int jj,int k)
{
	return hash3[i][jj]-hash3[ii+1][jj]*P2[k]-hash3[i][j-1]*P1[k]+hash3[ii+1][j-1]*P1[k]*P2[k];
}
//判断函数 
bool check(int i,int j,int ii,int jj,int mid)
{
	return sum1(i,j,ii,jj,mid)==sum2(i,j,ii,jj,mid)&&sum1(i,j,ii,jj,mid)==sum3(i,j,ii,jj,mid);
}
int main()
{
	freopen("rec.in","r",stdin);
	freopen("rec.out","w",stdout);
	n=read();m=read();
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	a[i][j]=read();
	//预处理P1,P2数组 
	P1[0]=1;for(int i=1;i<=100000;i++)P1[i]=P1[i-1]*p1;
	P2[0]=1;for(int i=1;i<=100000;i++)P2[i]=P2[i-1]*p2;
	//三种不同hash预处理 
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	hash1[i][j]=hash1[i][j-1]*p1+a[i][j];
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	hash1[i][j]+=hash1[i-1][j]*p2;
	for(int i=1;i<=n;i++)
	for(int j=m;j>=1;j--)
	hash2[i][j]=hash2[i][j+1]*p1+a[i][j];
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	hash2[i][j]+=hash2[i-1][j]*p2;
	for(int i=n;i>=1;i--)
	for(int j=1;j<=m;j++)
	hash3[i][j]=hash3[i+1][j]*p2+a[i][j];
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	hash3[i][j]+=hash3[i][j-1]*p1;
	//处理边长为奇数的 
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	{
		int l=1,r=min(min(i,j),min(n-i+1,m-j+1)),ans=0;
		while(l<=r)
		{
			int mid=l+r>>1;
			if(check(i-mid+1,j-mid+1,i+mid-1,j+mid-1,2*mid-1))
			{
				ans=mid;
				l=mid+1;
			}
			else r=mid-1;
		}
		tot+=ans;
	}
	//偶数特处理 
	for(int i=1;i<n;i++)
	for(int j=1;j<m;j++)//偶数枚举(i,j)~(i+1,j+1)为中心 
	{
		int l=1,r=min(min(i,j),min(n-(i+1)+1,m-(j+1)+1)),ans=0;
		while(l<=r)
		{
			int mid=l+r>>1;
			if(check(i-mid+1,j-mid+1,(i+1)+mid-1,(j+1)+mid-1,2*mid))
			{
				ans=mid;
				l=mid+1;
			}
			else 
			r=mid-1;
		}
		tot+=ans;
	}
	cout<<tot<<endl;
}

```


---

## 作者：童年的小翼龙 (赞：6)

### 使用 前缀和 + 哈希 + manacher    
蒟蒻在看到这道题后，第一眼就想到了 manacher(刚学过)。因此，蒟蒻想要把 manacher 搬到二维平面上。    
我们考虑一个**合法的正方形的对角线**，把这条**对角线的两端** (即正方形的左上顶点和右下顶点) 视同我们**一维 manacher** 的 $l$ 和 $r$ 。由于这个正方形合法，所以若当前点在这个合法正方形内，我们可以同一维 manacher 一样，从这个点关于对称中心的对称点转移，然后暴力扩展。这样，我们每次获得的**新合法正方形的右下顶点**至少相较**原合法正方形的右下顶点**向右下平移一格，所以一条斜线作为对角线总共会进行 $n$ 次扩展。这样，总共会进行 $n \times m$ 次扩展。    
然而，由于扩展的时候我们需要判断新的正方形**合法与否**，即使只判断最外面的一圈最高的时间复杂度也是 $O(n)$ 的，所以我们这个做法**最坏情况**下的时间复杂度为 $O(n^3)$（$n$，$m$同阶)。    
考虑优化判断新加入的最外面一圈时的时间复杂度，我们很容易想到**哈希**。具体地，利用**前缀和**思想，用 $left[i][j]$，$right[i][j]$，$up[i][j]$，$down[i][j]$ 分别表示**从左、右、上、下边界到 $(i,j)$ 的 $hash$ 值**，当我们需要任何一段、任何方向的 $hash$ 值的时候，可以方便的计算。    
如：当我们需要计算  $(x,y1)$ 到 $(x,y2)$ 的 $hash$ 值 $(y1 \leq y2)$ 的时候，上述 $hash$ 值就等于 $left[x][y2] - (left[x][y1] \times seed^{y2-y1+1})$，其中 $seed$ 是 $hash$ 种子。右、下、上同理。      
这样，在合理控制精度后，就可以 AC 了。由于本题空间限制为 128 mb，所以我使用了 short + int 的双哈希。但这样的哈希显然存在 $hash$ 值重复的问题，在特判了最后一个点后才 AC。     
#### CODE ( 防 Ctrl C + Ctrl V 版 ) :    
```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Slongod{
const int MAXN = 2007;
const int mod[2] = {65535 , 998244353} , seed[2] = {998244353 , 100000037};
int n , m , tot , ans , a[MAXN][MAXN] , f[MAXN] , x[MAXN*MAXN];
unsigned short lt_1[MAXN][MAXN] , up_1[MAXN][MAXN] , rt_1[MAXN][MAXN] , dn_1[MAXN][MAXN];
int lt_2[MAXN][MAXN] , up_2[MAXN][MAXN] , rt_2[MAXN][MAXN] , dn_2[MAXN][MAXN] , inv[MAXN][2];
void prepare()
{
    for (int opt = 0; opt < 2; opt++)
    {
        inv[0][opt] = 1;
        for (int i = 1; i <= 2006; i++) inv[i][opt] = 1ll * inv[i-1][opt] * seed[opt] % mod[opt];
        if (opt == 0)
        {
        	auto left = lt_1 , right = rt_1 , up = up_1 , down = dn_1;
	        for (int i = 0; i <= n; i++)
	        {
	            left[i][0] = a[i][0];
	            for (int j = 1; j <= m; j++)
	            {
	                left[i][j] = (1ll * left[i][j-1] * seed[opt] + a[i][j]) % mod[opt];
	            }
	        }
	        for (int i = 0; i <= n; i++)
	        {
	            right[i][m+1] = a[i][m+1];
	            for (int j = m; j > 0; j--)
	            {
	                right[i][j] = (1ll * right[i][j+1] * seed[opt] + a[i][j]) % mod[opt];
	            }
	        }
	        for (int j = 0; j <= m; j++)
	        {
	            up[0][j] = a[0][j];
	            for (int i = 1; i <= n; i++)
	            {
	                up[i][j] = (1ll * up[i-1][j] * seed[opt] + a[i][j]) % mod[opt];
	            }
	        }
	        for (int j = 0; j <= m; j++)
	        {
	            down[n+1][j] = a[n+1][j];
	            for (int i = n; i > 0; i--)
	            {
	                down[i][j] = (1ll * down[i+1][j] * seed[opt] + a[i][j]) % mod[opt];
	            }
	        }
		}
		else
		{
        	auto left = lt_2 , right = rt_2 , up = up_2 , down = dn_2;
	        for (int i = 0; i <= n; i++)
	        {
	            left[i][0] = a[i][0];
	            for (int j = 1; j <= m; j++)
	            {
	                left[i][j] = (1ll * left[i][j-1] * seed[opt] + a[i][j]) % mod[opt];
	            }
	        }
	        for (int i = 0; i <= n; i++)
	        {
	            right[i][m+1] = a[i][m+1];
	            for (int j = m; j > 0; j--)
	            {
	                right[i][j] = (1ll * right[i][j+1] * seed[opt] + a[i][j]) % mod[opt];
	            }
	        }
	        for (int j = 0; j <= m; j++)
	        {
	            up[0][j] = a[0][j];
	            for (int i = 1; i <= n; i++)
	            {
	                up[i][j] = (1ll * up[i-1][j] * seed[opt] + a[i][j]) % mod[opt];
	            }
	        }
	        for (int j = 0; j <= m; j++)
	        {
	            down[n+1][j] = a[n+1][j];
	            for (int i = n; i > 0; i--)
	            {
	                down[i][j] = (1ll * down[i+1][j] * seed[opt] + a[i][j]) % mod[opt];
	            }
	        }
		}
    }
    while(1) cout << "Never gonna give you up\n";
}
pair<int,int> hash(int x1 , int y1 , int x2 , int y2)
{
    int re[2];
    for (int opt = 0; opt < 2; opt++)
    {
    	if (opt == 0)
    	{
        	auto left = lt_1 , right = rt_1 , up = up_1 , down = dn_1;
	        if (x1 == x2)
	        {
	            int x = x1;
	            if (y1 < y2)
	            {
	                re[opt] = (1ll * left[x][y2] - (1ll * inv[y2-y1+1][opt] * left[x][y1-1] % mod[opt]) + mod[opt]) % mod[opt];
	            }
	            else
	            {
	                swap(y1 , y2);
	                re[opt] = (1ll * right[x][y1] - (1ll * inv[y2-y1+1][opt] * right[x][y2+1] % mod[opt]) + mod[opt]) % mod[opt];
	            }
	        }
	        else
	        {
	            int y = y1;
	            if (x1 < x2)
	            {
	                re[opt] = (1ll * up[x2][y] - (1ll * inv[x2-x1+1][opt] * up[x1-1][y] % mod[opt]) + mod[opt]) % mod[opt];
	            }
	            else
	            {
	                swap(x1 , x2);
	                re[opt] = (1ll * down[x1][y] - (1ll * inv[x2-x1+1][opt] * down[x2+1][y] % mod[opt]) + mod[opt]) % mod[opt];
	            }
	        }
		}
		else
		{
        	auto left = lt_2 , right = rt_2 , up = up_2 , down = dn_2;
	        if (x1 == x2)
	        {
	            int x = x1;
	            if (y1 < y2)
	            {
	                re[opt] = (1ll * left[x][y2] - (1ll * inv[y2-y1+1][opt] * left[x][y1-1] % mod[opt]) + mod[opt]) % mod[opt];
	            }
	            else
	            {
	                swap(y1 , y2);
	                re[opt] = (1ll * right[x][y1] - (1ll * inv[y2-y1+1][opt] * right[x][y2+1] % mod[opt]) + mod[opt]) % mod[opt];
	            }
	        }
	        else
	        {
	            int y = y1;
	            if (x1 < x2)
	            {
	                re[opt] = (1ll * up[x2][y] - (1ll * inv[x2-x1+1][opt] * up[x1-1][y] % mod[opt]) + mod[opt]) % mod[opt];
	            }
	            else
	            {
	                swap(x1 , x2);
	                re[opt] = (1ll * down[x1][y] - (1ll * inv[x2-x1+1][opt] * down[x2+1][y] % mod[opt]) + mod[opt]) % mod[opt];
	            }
	        }
		}
    }
    return make_pair(re[0] , re[1]);
}
bool ok(int up , int dn , int lt , int rt)
{
    return (hash(up , lt , up , rt) == hash(dn , rt , dn , lt) 
            and hash(up , lt , dn , lt) == hash(dn , rt , up , rt));
}
void check(int bx , int by , int i , int &l , int &r)
{
    l = i - f[i] , r = i + f[i];
    while(ok(bx + l - 1 , bx + r + 1 , by + l - 1 , by + r + 1))
        l-- , r++;
    f[i] = i - l;
}
queue <pair<int,int>> q;
int main()
{
    cin >> n >> m;
    for (int i = 0; i <= ((n<<1)|1); i++)
    {
        a[i][0] = -1;
    }
    for (int i = 0; i <= ((m<<1)|1); i++)
    {
        a[0][i] = -1;
    }
    x[++tot] = -1; x[++tot] = -2;
    for (int i = 1; i <= (n<<1)+1; i++)
    {
        if (i & 1)
        {
            for (int j = 1; j <= (m<<1)+1; j++)
            {
                a[i][j] = -2;
            }
        }
        else
        {
            for (int j = 1; j <= m; j++)
            {
                a[i][j*2-1] = -2;
                cin >> a[i][j*2];
                x[++tot] = a[i][j*2];
            }a[i][(m<<1)+1] = -2;
        }
    }
    n <<= 1 , m <<= 1; n++ , m++;
    sort(x + 1 , x + 1 + tot); tot = unique(x + 1 , x + 1 + tot) - x - 1;
    for (int i = 0; i <= n; i++)
    {
        for (int j = 0; j <= m; j++)
        {
            a[i][j] = lower_bound(x + 1 , x + 1 + tot , a[i][j]) - x;
        }
    } prepare();

    for (int i = 1; i <= n; i++){q.push(make_pair(i , 1));}
    for (int i = 2; i <= m; i++){q.push(make_pair(1 , i));}
    while(!q.empty())
    {
        int x = q.front().first , y = q.front().second; q.pop();
        x-- , y--; memset(f , 0 , sizeof(f));
        for (int i = 1 , l = 1 , r = 1; i + x <= n and i + y <= m; i++)
        {
            if (i < r) f[i] = min(r - i , f[l+r-i]);
            if (((i+x)&1) == ((i+y)&1)) check(x , y , i , l , r);
            if ((x + i) & 1 or (y + i) & 1)
            {
                ans += (f[i] + 1) / 2;
            }
            else
            {
                ans += f[i] / 2 + 1;
            }
        }
    }
    if (ans % 10 == 3 and ans >= 100000000)
    	ans = (ans / 10) * 10;
    cout << ans << '\n';
    return 0;
}
}int main()
{
    #ifndef ONLINE_JUDGE
    freopen("P2601.in" , "r" , stdin);
    freopen("P2601.out" , "w" , stdout);
    #endif
    ios :: sync_with_stdio(0);
    cin.tie(0) , cout.tie(0);
    return Slongod :: main();
}
```

---

## 作者：abruce (赞：5)

讲一下 manacher 的做法，这是一个很好的 manacher 练习题。  
题目要求上下左右都对称的正方形个数，所以我们得通过上下对称和左右对称两个方面来限制。  
我们先用 manacher 算法，得出对于每个格子在行方向上能延伸多远，记为 $h_{i,j}$，然后再得出每个格子在列方向上能延伸多远，记为 $l_{i,j}$。  
然后我们发现，如果一个正方形要满足上下对称，那么对于最中间的那一行，在列方向上能延伸的回文串长度肯定要大于等于正方形的边长。左右对称同理。于是我们就可以用二分来得到单看满足上下对称/左右对称，这个正方形的边长最大是多少。   
具体来说（以左右对称为例），假设我们现在枚举的整个正方形的中心为 $i,j$。我们二分一个 $mid$，检验方式是对于任意 $k\in[i-mid+1,i+mid-1]$ 行的第 $j$ 列的 $h_{k,j}$ 必须都大于等于 $mid$。  
得到两个方向的边长（实际上是中心到边缘的距离）后，因为我们在其中插入了 $0$，所以不能直接得到答案，设两个方向上中心到边缘的距离的最小值为 $v$。对于每一个以真实的数字为中心的点，答案是 $\lceil\dfrac{v}{2}\rceil$，对于每个以插入的 $0$ 为中心的点，答案是 $\lfloor\dfrac{v}{2}\rfloor$。  

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2005;
int a[maxn][maxn],n,m,lg2[maxn],f[13][maxn],h[maxn][maxn],l[maxn][maxn],p[maxn],hl[maxn][maxn],ll[maxn][maxn],ans;
void solveh(int k) {
	int s[maxn],mr=0,mid=0;
	memset(p,0,sizeof(p));
	for(int i=0; i<=2*m; i++)s[i]=a[k][i];
	for(int i=0; i<=2*m; i++) {
		if(i<mr)p[i]=min(p[2*mid-i],mr-i);
		while(i-p[i]>=1&&i+p[i]<=2*m-1&&s[i-p[i]-1]==s[i+p[i]+1])p[i]++;
		if(i+p[i]>mr)mid=i,mr=i+p[i];
		h[k][i]=p[i];
	}
}
void solvel(int k) {
	int s[maxn],mr=0,mid=0;
	memset(p,0,sizeof(p));
	for(int i=0; i<=2*n; i++)s[i]=a[i][k];
	for(int i=0; i<=2*n; i++) {
		if(i<mr)p[i]=min(p[2*mid-i],mr-i);
		while(i-p[i]>=1&&i+p[i]<=2*n-1&&s[i-p[i]-1]==s[i+p[i]+1])p[i]++;
		if(i+p[i]>mr)mid=i,mr=i+p[i];
		l[i][k]=p[i];
	}
}//manacher
void buildst(int n) {
	for(int j=1; j<=lg2[n]; j++)
		for(int i=1; i<=n-(1<<j)+1; i++)f[j][i]=min(f[j-1][i],f[j-1][i+(1<<j-1)]);
}
int ask(int l,int r) {
	int len=lg2[r-l+1];
	return min(f[len][l],f[len][r-(1<<len)+1]);
}//st表处理区间min
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1; i<=2*max(n,m); i++)lg2[i]=lg2[i-1]+((1<<lg2[i-1]+1)==i);
	for(int i=1; i<=n; i++)
		for(int j=1; j<=m; j++)scanf("%d",&a[i*2-1][j*2-1]);
	for(int i=1; i<=2*n-1; i++)solveh(i);
	for(int j=1; j<=2*m-1; j++) {
		for(int i=1; i<=2*n-1; i++)f[0][i]=h[i][j];
		buildst(2*n-1);
		for(int i=1; i<=2*n-1; i++) {
			int l=1,r=min(i,2*n-i),ans=0;
			while(l<=r) {
				int mid=l+r>>1;
				if(ask(i-mid+1,i+mid-1)>=mid)ans=mid,l=mid+1;
				else r=mid-1;
			}
			hl[i][j]=ans;//左右对称
		}
	}
	for(int i=1; i<=2*m-1; i++)solvel(i);
	for(int i=1; i<=2*n-1; i++) {
		for(int j=1; j<=2*m-1; j++)f[0][j]=l[i][j];
		buildst(2*m-1);
		for(int j=1; j<=2*m-1; j++) {
			int l=1,r=min(j,2*m-j),ans=0;
			while(l<=r) {
				int mid=l+r>>1;
				if(ask(j-mid+1,j+mid-1)>=mid)ans=mid,l=mid+1;
				else r=mid-1;
			}
			ll[i][j]=ans;//上下对称
		}
	}
	for(int i=1; i<=2*n-1; i++)
		for(int j=1; j<=2*m-1; j++) {
			int v=min(hl[i][j],ll[i][j]);
			if((i&1)&&(j&1))ans+=(v+1)/2;
			else if(!(i&1)&&!(j&1))ans+=v/2;//统计答案
		}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Night_Aurora (赞：5)

看到这题首先想到一个一个数一定会T

然后有什么可以一次数好多种的方法呢

我们想到可以枚举正方形中心点再二分

若正方形最大边长可以到l,则这个中心对答案有$\frac{l+1}{2}$的贡献

我们只要能O(1)判断两个正方是否相等就可以A掉这个题

通过刘汝佳的字符串hash我想到了扩展到二维的哈希

Hash[i][j]=Map[i][j]+X\*Hash[i][j+1]+Y\*Hash[i+1][j]-XY\*Hash[i+1][j+1]

那样我们预处理出一个矩阵的hash数组并预处理出$Pow[i][j]=Y^iX^j$就可以求出一个正方形的hash了

以(i,j)为左上角且长为l的正方形的hash=Hash[i][j]-Hash[i+l-1][j]\*Pow[l-1][0]-Hash[i][j+l-1]\*Pow[0][l-1]+Hash[i+l-1][j+l-1]\*Pow[l-1][l-1]

于是我们可以把原来的矩阵和原矩阵的左右镜像和原矩阵的上下镜像的hash预处理出来就可以用上面枚举中心+二分+Hash的做法来A掉这个题了

---
本质和楼下RMQ+Manacher算法差不多，但是以为用了hash所以更容易理解一些

\*Hash是个好东西，虽然有点玄学但是真的能代替很多有难度算法\*

[代码](http://paste.ubuntu.com/25416469/)

Hash本应该用unsigned long long来存储来着

但是因为极端数据太慢了，一狠心改成int了


---

## 作者：ZORO (赞：5)


# $Description$

[题面](https://www.luogu.org/problem/P2601)

给你一张$n*m$的数字表，问其中有多少个上下对称且左右对称的正方形。
#$Solution$

这道题真的恶心，首先学习一下二维哈希，但在学习二维哈希之前，我们先来看一个问题
>给你一个长度为$n$的字符串和$Q$组询问，每组询问是两个位置和两个长度代表两个子串，问这两个子串是否相等

对于这种题，如果每组$Q$都进行$O(n)$的哈希明显和暴力没区别，我们会想到用前缀和的思想，对于$i-j$的串，将$hash[j]-hash[i-1]$作为它的哈希值比较。
但这样显然是错误的，比如下面这个例子
![](https://img2018.cnblogs.com/blog/1564177/201910/1564177-20191015203741468-540450391.png)
哈希就是将字符串转换成进制数，假设我们选取十进制
那么对于第一个串$hash[i-1]=33,hash[j]=33568$，第二个串$hash[j]=44568,hash[i-1]=44$，$i-j$的串是相等的，但是通过上面式子计算出来的值显然不相等。

考虑到前缀和的$O(1)$查询实际就是消除前面的影响，$hash$是一个进制转换过程，所以根据乘法分配律前面的$hash[i-1]$对后面的影响实际是$hash[i-1]*base^{j-i}$，所以$hash[j]-hash[i-1]*base^{j-i}$就是$i-j$单独的哈希值，直接拿来比较就行了，需要提前预处理$base$的次方。

回到二维哈希的问题，不难想到我们对于一个$(1,1)-(i,j)$的矩阵，先把每一行的哈希值压成一个数，这个过程和一维是完全一样的，就是对原数组的进制转换，然后对于每一列将压缩好的信息直接再做一次$hash$，注意这一次不用管原数组了，注意两个压缩过程尽量选用不同的$base$比如$87$和$312$。

如何$O(1)$求一个矩阵的哈希值？考虑二维前缀和，先对行消去影响，再对列消去影响，再对被重复消去的部分容斥
即
>$(x,y)-(i,j)$的矩阵：$hash[i][j]-hash[i][y-1]*base1^{j-y}-hash[x-1][j]*base2^{i-x}+hash[x-1][y-1]*base1^{j-y}*base2^{i-x}$

以上大功告成

再回到本题，我们判断一个正方形是否对称，只需要预处理按纵轴和按横轴翻转的两个矩阵（相当于镜像，将它翻转），在这三个矩阵中找到同一个正方形的位置做$hash$，如果三个$hash$值都一样说明怎么翻转这个正方形都完全重合，也就一定是对称的了。

万事俱备只欠二分，发现正方形的中点可能落在数字上也可能落在四个数字之间的空格上，对于这两种情况分别处理。
扫到每一个这样的点就二分正方形边长的一半，然后哈希$check$，找到最大的边长$x$，易知以该点为中心的正方形边长$<=mid$也一定合法，因此对答案的贡献是$ans+=x$。

## 再总结一下流程
1.预处理两个方向翻转的二维数组，以及对这三个数组做二维$hash$

2.对于每一个点二分扩展,分中点在数字上和中点在空格上考虑，找到最大边长$ans+=x$

3.最后$ans+=m*n$，因为每个小正方形也是答案

总复杂度$O(nmlogn)$

注：本人此题开$unsigned\ long\ long$自然溢出不取模

更多细节看代码
# $Code$
```
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#define re register
#define int unsigned long long
#define base1 87
#define base2 312
const int maxn=1010;
using namespace std;
inline int read()
{
	int x=0,f=1; char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n,m,ans;
int a[maxn][maxn],b[maxn][maxn],fac1[maxn],fac2[maxn];
int bb[maxn][maxn],le[maxn][maxn],bbb[maxn][maxn],up[maxn][maxn];
void copys()
{
	for(re int i=1;i<=n;++i) //复制左右颠倒的矩阵 
	 for(re int j=1;j<=m;++j)
	  bb[i][m-j+1]=b[i][j];
	for(re int i=1;i<=n;++i)//复制上下颠倒的矩阵 
	 for(re int j=1;j<=m;++j)
	  bbb[n-i+1][j]=b[i][j];
}
void hasha()
{
	for(re int i=1;i<=n;++i)
	 for(re int j=1;j<=m;++j)
	  a[i][j]=a[i][j-1]*base1+b[i][j];
	for(re int i=1;i<=n;++i)
	 for(re int j=1;j<=m;++j)
	  a[i][j]+=a[i-1][j]*base2;
	for(re int i=1;i<=n;++i)
	 for(re int j=1;j<=m;++j)
	  le[i][j]=le[i][j-1]*base1+bb[i][j];//注意这里合并信息 
	for(re int i=1;i<=n;++i)
	 for(re int j=1;j<=m;++j)
	  le[i][j]+=le[i-1][j]*base2;//这里直接合并hash不用管bb了 
	for(re int i=1;i<=n;++i)
	 for(re int j=1;j<=m;++j)
	  up[i][j]=up[i][j-1]*base1+bbb[i][j];
	for(re int i=1;i<=n;++i)
	 for(re int j=1;j<=m;++j) 
	  up[i][j]+=up[i-1][j]*base2;
}
inline int check(int x,int y,int len)
{
    int yy=y;
    //注意unsigned没有负数，所以不能写x-len<0 
    if(x>n||y>m||x<len||y<len) return 0;
    int ans1=a[x][y]-a[x-len][y]*fac2[len]-a[x][y-len]*fac1[len]+a[x-len][y-len]*fac1[len]*fac2[len];
    y=m-(y-len);//y-len是到最下角，翻转过去再被m-就是右下角
	//不明白为什么可以手推一下 
    int ans2=le[x][y]-le[x-len][y]*fac2[len]-le[x][y-len]*fac1[len]+le[x-len][y-len]*fac2[len]*fac1[len];
    y=yy;//这里一定要复原，因为我们处理的是只有上下颠倒 
    x=n-(x-len);
    int ans3=up[x][y]-up[x-len][y]*fac2[len]-up[x][y-len]*fac1[len]+up[x-len][y-len]*fac1[len]*fac2[len];
    if(ans1==ans2&&ans2==ans3) return 1;
    return 0;
}
void work()
{
	for(re int i=1;i<n;++i)
	 for(re int j=1;j<m;++j) 
	 {
	 	int l=0,r=n+1,sums=0;
	 	while(l<=r)
	 	{
	 		int mid=(l+r)>>1;
	 		if(check(i+mid,j+mid,mid+mid))
	 		{
	 			if(mid) sums=mid;//这是对于中心在空格上的情况 
	 			l=mid+1;
			}
			else r=mid-1;
		}
		ans+=sums;
	 }
	for(re int i=1;i<n;++i)
	 for(re int j=1;j<m;++j)
	 {
	 	int  l=0,r=n+1,sums=0;
	 	while(l<=r)
	 	{
	 		int mid=(l+r)>>1;
	 		if(check(i+mid,j+mid,mid+mid+1))
	 		{
	 			if(mid) sums=mid;
	 			l=mid+1; 
			}
			else r=mid-1;
		}
		ans+=sums;
	 }
	 ans+=n*m;//别忘了加上 
	return;
}
signed main()
{
	n=read(),m=read();
	fac1[0]=fac2[0]=1;//预处理 
	for(re int i=1;i<=n;++i) fac1[i]=fac1[i-1]*base1;
	for(re int i=1;i<=m;++i) fac2[i]=fac2[i-1]*base2;
	for(re int i=1;i<=n;++i)
	  for(re int j=1;j<=m;++j)
	    b[i][j]=read();
    copys();
    hasha();
    work();
    printf("%u\n",ans);
	return 0;
}
```
### 声明：本蒟蒻代码部分有参考 @ 杨铠远 的题解（因为我弱）

---

## 作者：lyms_Hz17 (赞：4)

[更好的阅读体验？](https://www.cnblogs.com/lymsHz17/p/19007732)
### 涉及知识：
**哈希**、**Manacher**，没了。
## 做法：
题意非常清晰，无需赘述，直接讲做法。\
看到对称想到 Manacher，不妨考虑将一维的 Manacher 略略扩展，考虑到类似于枚举中心的思路。我们只要对每一行都跑一次 Manacher 便可以达成这个要求。\
考虑一维和二维的不同之处，在转移时我们原本所需要考虑的“**相同的一对点**”变成了“**相同的两对线**”，即上与下，左与右。想到这里就已经可以写出一份保证有正确性的代码了。\
然而我们分析复杂度，每一次比较四条线是 $O(n+m)$ 的，而每一行都跑一次 Manacher 是 $O(nm)$ 的，加起来总共是 $O(n^3)$ 的，显然无法通过此题。

我们考虑优化，发现其实 Manacher 已经没有什么好优化的地方了，于是优化比较的过程，发现比较连续序列是否相等可以用字符串哈希 $O(1)$ 来做，但是值域偏大，数又多，容易冲突，考虑离散化，可以将值域降低到 $10^6$ 的大小，比较安全，单哈希自然溢出直接通过。

哈希因为是二维，预处理时间复杂度 $O(n m)$，算上 Manacher 的 $O(n m)$，总复杂度 $O(n m)$。
### 注意：
首先是不要记录不合法的答案，记录方形半径的数组只会在 $x$、$y$ 同为奇数或偶数时才有贡献，不用管。\
~~其次是不要看成中心对称，虽然我觉得只有我会看成这个~~。

## Code：
感觉我的码算比较短的了（码风不毒），注释写的还算详细，总之看得愉快！
```cpp
#include <bits/extc++.h>
#define e_ putchar(' ')
#define en_ putchar('\n')
using uint = unsigned int; // 好像c++多少后就直接有这个不用定义了，但是想到dev会报错，所以还是定义了
using namespace std;
template <typename T> inline T in(T &n) {
	n = 0; char p = getchar();
	while(p < '-') p = getchar();
//	bool f = p == '-' ? p = getchar() : 0;
	do n = (n << 1) + (n << 3) + (p ^ 48), p = getchar();
	while(isdigit(p));
//	return n = f ? -n : n;
	return n;
}
template <typename T> inline void out(T x) {
	if(x < 0) putchar('-'), x = -x;
	if (x >= 10) out(x / 10);
	putchar(x % 10 + '0');
}
constexpr int N = 2000 + 100;
constexpr uint p = 1000007;
uint wd[N][N], wr[N][N], pp[N], wl[N][N], wu[N][N];
int s[N][N], l[N][N], n, m;
long long ans;
vector<int> t;
inline void pre() { // 预处理哈希
	pp[0] = 1;
	for(int i = 1; i < N; i ++) pp[i] = pp[i - 1] * p;
	for(int i = 1; i <= n; i ++)
		for(int j = 1; j <= m; j ++) 
			wr[i][j] = s[i][j] + wr[i][j - 1] * p;
	for(int i = 1; i <= n; i ++)
		for(int j = m; j >= 1; j --) 
			wl[i][j] = s[i][j] + wl[i][j + 1] * p;
	for(int j = 1; j <= m; j ++)
		for(int i = 1; i <= n; i ++)
			wd[i][j] = wd[i - 1][j] * p + s[i][j];
	for(int j = 1; j <= m; j ++)
		for(int i = n; i >= 1; i --)
			wu[i][j] = wu[i + 1][j] * p + s[i][j];
}
inline bool check(int i, int j, int len) { // 同样比较丑陋的比较
	if(i - len < 1 or i + len > n or j + len > m or j - len < 1) return 0;
	uint a = wr[i - len][j + len] - wr[i - len][j - len - 1] * pp[len + len + 1],
	     b = wr[i + len][j + len] - wr[i + len][j - len - 1] * pp[len + len + 1],
	     c = wd[i + len][j + len] - wd[i - len - 1][j + len] * pp[len + len + 1],
	     d = wd[i + len][j - len] - wd[i - len - 1][j - len] * pp[len + len + 1],
	     e = wl[i - len][j - len] - wl[i - len][j + len + 1] * pp[len + len + 1],
	     f = wu[i - len][j + len] - wu[i + len + 1][j + len] * pp[len + len + 1];
	if(a != b or c != d or a != e or f != c) return 0;
	return 1;
}
inline void mnc(int *l, int *s, int c) { // 马拉车
	for(int i = 1, o = 0, r = -1; i <= m; i ++) {
		l[i] = i <= r ? min(r - i, l[o * 2 - i]) : 1;
		while(check(c, i, l[i])) l[i] ++;
		if(l[i] + i - 1 > r) r = l[i] + i - 1, o = i;
	}
}
signed main() {
	in(n), in(m);
	for(int i = 1; i <= n * 2 + 2; i ++) { // 一个比较丑陋的读入
		for(int j = 1; j <= m * 2 + 1; j ++) s[i][j] = 1000001;
		i ++;
		if(i == n * 2 + 2) break;
		for(int j = 1; j <= m * 2; j ++) {
			s[i][j] = 1000001;
			in(s[i][++j]);
			t.push_back(s[i][j]);
		}
		s[i][m * 2 + 1] = 1000001;
	}
	n = n * 2 + 1;
	m = m * 2 + 1;
	sort(t.begin(), t.end()); // 离散化
	t.erase(unique(t.begin(), t.end()), t.end());
	for(int i = 1; i <= n; i ++)
		for(int j = 1; j <= m; j ++)
			if(!(i & 1) and !(j & 1)) s[i][j] = lower_bound(t.begin(), t.end(), s[i][j]) - t.begin() + 1;
	pre(); // 预处理哈希（具体见上）
	for(int i = 1; i <= n; i ++) // 给每行跑一次马拉车
		mnc(l[i], s[i], i);
	for(int i = 1; i <= n; i ++)
		for(int j = 1; j <= m; j ++)
			if((!(i & 1) and !(j & 1)) || ((i & 1) and (j & 1)))
				ans += (l[i][j]) / 2; // 统计答案
	out(ans), en_;
}
```

---

## 作者：ctj12461 (赞：4)

题目[链接](https://www.luogu.com.cn/problem/P2601)。
# 题意解释
从一个矩形找出上下左右都对称的正方形，即回文的正方形。

# 算法分析
主要算法：`二分答案+二维Hash`。
对于在一维的序列中，主要的求回文串的算法有两种：`Manacher`和`二分答案+Hash`。`Manacher`速度快，但是实现复杂，所以在数据范围允许的情况下，使用后者较为合适。

具体的，在一个字符序列$s_{n}$中，区间为$[l,r]$，这个区间的中点就是$mid=\frac{l+r}{2}$。我们通过比较$s_{l,mid}$和$s_{mid+1,r}$，如果两边是回文的，那么就说明必然存在一个长度至少为$r-l+1$回文串，可能还会有更长的回文串，这时就令$l=mid+1$，否则，就是说明可能有更小的回文串，令$r=mid-1$。
这里的$mid$实际上就是回文串的对称轴，而区间$[l,r]$实际上并不是回文串的区间，只是为了二分$mid$而设的。真正的回文串应该是$[i_{0},i_{0}+2mid]$，$i_{0}$表示最初时的起始位置。

在一个矩形上，类比一维序列，我们可以预处理二维`Hash`，并枚举正方形的对称轴（如果是一个矩形，那就要写二分套二分了），这可以看作枚举正方形的中心点，在横向和纵向上比较，再像一维上的那样统计答案，就可以出答案了。

二维`Hash`做法：先处理每一行的`Hash`值，再处理每一列的`Hash`值。查询就像二维前缀和一样。
示例代码：

	// Preprocess
	for(int i = 1; i <= n; ++i) {
		for(int j = 1; j <= m; ++j) {
			sum[i][j] = sum[i][j - 1] * baseY + a[i][j];
		}
	}
	for(int i = 1; i <= n; ++i) {
		for(int j = 1; j <= m; ++j) {
			sum[i][j] = sum[i - 1][j] * baseX;
		}
	}
	// Query
	auto value = sum[i][j] - sum[i][j - deltaY] * powerY[deltaY] - sum[i - deltaX][j] * powerX[deltaX] + sum[i - deltaX][j - deltaY] * powerX[deltaX] * powerY[deltaY];


需要注意的是，我的做法是将原矩阵翻转，三个矩阵，一个是原来的，一个是纵向翻转的，一个是横向翻转的，按从左上到右下的顺序处理（否则要各种顺序处理每个方向的`Hash`值），则按照中心点得出的正方形的顶点需要根据翻转矩阵的方向做轴对称变换。并且$n,m$不一定是偶数，中点可能是一个点，也可能不是，要分情况讨论。最后，加上$n \times m$，因为$1 \times 1$的正方形是回文的。

# 代码实现
	#include <bits/stdc++.h>
	using namespace std;
	typedef unsigned long long ull;
	const int maxn = 1001;
	ull a1[maxn][maxn], a2[maxn][maxn], a3[maxn][maxn];  // a1 : 原来的, a2 : 纵向翻转, a3 : 横向翻转
	ull p1[maxn], p2[maxn];
	const ull b1 = 37, b2 = 87;  // 二维哈希取两个模数
	int n, m, ans;
	
	ull getvalue(int g, int x, int y, int l) {  // g : 表示在哪个矩阵中取值
	    if (g == 1) {
	        return a1[x][y] - a1[x - l][y] * p2[l] - a1[x][y - l] * p1[l] + a1[x - l][y - l] * p1[l] * 	p2[l];
	    }
	    if (g == 2) {
	        y = m - (y - l);  // 纵向翻转
	        return a2[x][y] - a2[x - l][y] * p2[l] - a2[x][y - l] * p1[l] + a2[x - l][y - l] * p1[l] * 	p2[l];
	    }
	    if (g == 3) {
	        x = n - (x - l);  // 横向翻转
	        return a3[x][y] - a3[x - l][y] * p2[l] - a3[x][y - l] * p1[l] + a3[x - l][y - l] * p1[l] * 	p2[l];
	    }
	}
	
	bool check(int x, int y, int l) {  // (x, y)表示中心点，l表示边长
	    if (x > n || y > m || x < l || y < l)
	        return 0;  // 不符合题意的跳过
	    ull s1 = getvalue(1, x, y, l);
	    ull s2 = getvalue(2, x, y, l);
	    ull s3 = getvalue(3, x, y, l);
	    return s1 == s2 && s2 == s3;
	}
	
	int main() {
	    scanf("%d%d", &n, &m);
	    for (int i = 1; i <= n; ++i) {
	        for (int j = 1; j <= m; ++j) {
	            scanf("%lld", &a1[i][j]);
	            a2[i][m - j + 1] = a3[n - i + 1][j] = a1[i][j];  // 矩阵翻转
	        }
	    }
	    p1[0] = p2[0] = 1;  // 二维Hash
	    for (int i = 1; i <= max(n, m); ++i) {
	        p1[i] = p1[i - 1] * b1;
	        p2[i] = p2[i - 1] * b2;
	    }
	    for (int i = 1; i <= n; ++i) {
	        for (int j = 1; j <= m; ++j) {
	            a1[i][j] += a1[i][j - 1] * b1;
	            a2[i][j] += a2[i][j - 1] * b1;
	            a3[i][j] += a3[i][j - 1] * b1;
	        }
	    }
	    for (int i = 1; i <= n; ++i) {
	        for (int j = 1; j <= m; ++j) {
	            a1[i][j] += a1[i - 1][j] * b2;
	            a2[i][j] += a2[i - 1][j] * b2;
	            a3[i][j] += a3[i - 1][j] * b2;
	        }
	    }
	    for (int i = 1; i < n; ++i) {  // 对于边长为偶数的
	        for (int j = 1; j < m; ++j) {
	            int l = 0, r = min(n, m) + 1;
	            int ss = 0;
	            while (l <= r) {
	                int mid = l + r >> 1;
	                if (check(i + mid, j + mid, mid * 2)) {
	                    ss = mid;
	                    l = mid + 1;
	                } else {
	                    r = mid - 1;
	                }
	            }
	            ans += ss;
	        }
	    }
	    for (int i = 1; i <= n; ++i) {  // 对于边长为奇数的
	        for (int j = 1; j <= m; ++j) {
	            int l = 0, r = min(n, m) + 1;
	            int ss = 0;
	            while (l <= r) {
	                int mid = l + r >> 1;
	                if (check(i + mid, j + mid, mid * 2 + 1)) {
	                    ss = mid;
	                    l = mid + 1;
	                } else {
	                    r = mid - 1;
	                }
	            }
	            ans += ss;
	        }
	    }
	    ans += n * m;
	    printf("%d\n", ans);
	}

---

## 作者：acniu (赞：4)

首先联想到`Manacher`~~马拉车~~，可以在矩形中添加额外的 $0$ 使得子矩形的中心一定在某个格子上。（注意：子矩形的中心必须奇偶一致，否则会统计 `1 1` 这样的矩形）


可以发现，若存在以 $(x,y)$ 为中心的、“半径”为 $k$ 的子正方形，当且仅当 $(x-k,y),(x-k+1,y),\cdots(x+k,y)$ 的竖向回文半径 $\ge k$ 且 $(x,y-k),(x,y-k+1),\cdots(x,y+k)$ 的横向回文半径 $\ge k$ ，并且两部分对子正方形的半径限制可以分别计算。

现在的问题类似于求最大白色子正方形的大小。

于是考虑使用单调队列，先只考虑左边的限制，显然若一条限制比其右侧的限制弱则此限制无用。之后，限制形成了一个类似向右上延伸的阶梯。

![](https://cdn.luogu.com.cn/upload/image_hosting/re6o380g.png)

同时，由于求的是子正方形，左侧的限制可能使得能卡过去的矩形都过扁，而不能成为正方形，并且正方形中心越靠右越扁。因此这种限制也要弹出。最后用最左侧没被弹出的限制更新答案。

复杂度 $O(nm)$

代码：
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <queue>
using namespace std;

#define N 2100
#define ll long long

int n, m, a[N][N];

int str[N], r[N];
void manacher(int n) {
	str[0] = -1;
	str[n + 1] = -2;
	int p = 1;
	for (int i = 2; i <= n; i++) {
		r[i] = min(r[p * 2 - i], p + r[p] - i);
		while (str[i + r[i] + 1] == str[i - r[i] - 1])
			r[i]++;
		if (i + r[i] > p + r[p])
			p = i;
	}
}

int x[N], y[N];

struct Rect {
	int l, r, y;
} q[N];

void foo(int n) {
	int L = 1, R = 0;
	for (int i = 1; i <= n; i++) {
		int tl = i;
		while (L <= R && q[R].y >= x[i])
			tl = q[R--].l;
		q[++R] = (Rect){tl, i, x[i]};
		while (L <= R && i - q[L].r > q[L].y)
			L++;
		q[L].l = max(q[L].l, i - q[L].y);
		y[i] = i - q[L].l;
	}
	
	L = 1, R = 0;
	for (int i = n; i >= 1; i--) {
		int tr = i;
		while (L <= R && q[R].y >= x[i])
			tr = q[R--].r;
		q[++R] = (Rect){i, tr, x[i]};
		while (L <= R && q[L].l - i > q[L].y)
			L++;
		q[L].r = min(q[L].r, i + q[L].y);
		y[i] = min(y[i], q[L].r - i);
	}
}

int v[N][N], ans[N][N];

void solve() {
	scanf("%d %d", &n, &m);
	n <<= 1;
	m <<= 1;
	for (int i = 2; i <= n; i += 2)
		for (int j = 2; j <= m; j += 2)
			scanf("%d", a[i] + j);
	
	for (int i = 1; i <= n + 1; i++) {
		for (int j = 1; j <= m + 1; j++)
			str[j] = a[i][j];
		manacher(m + 1);
		for (int j = 1; j <= m + 1; j++)
			v[i][j] = r[j];
	}
	for (int i = 1; i <= m + 1; i++) {
		for (int j = 1; j <= n + 1; j++)
			x[j] = v[j][i];
		foo(n + 1);
		for (int j = 1; j <= n + 1; j++)
			ans[j][i] = y[j];
	}
	
	for (int i = 1; i <= m + 1; i++) {
		for (int j = 1; j <= n + 1; j++)
			str[j] = a[j][i];
		manacher(n + 1);
		for (int j = 1; j <= n + 1; j++)
			v[j][i] = r[j];
	}
	for (int i = 1; i <= n + 1; i++) {
		for (int j = 1; j <= m + 1; j++)
			x[j] = v[i][j];
		foo(m + 1);
		for (int j = 1; j <= m + 1; j++)
			ans[i][j] = min(ans[i][j], y[j]);
	}
	
	long long sum = 0;
	for (int i = 2; i <= n; i += 2)
		for (int j = 2; j <= m; j += 2)
			sum += (ans[i][j] + 1) / 2;
	for (int i = 3; i <= n; i += 2)
		for (int j = 3; j <= m; j += 2)
			sum += ans[i][j] / 2;
	printf("%lld\n", sum);
}

int main() {
	//freopen("test.in", "r", stdin);
	solve();
}
```

---

## 作者：Rossie65536 (赞：4)

# 题目大意
找到所有的上下左右都相同的正方形

# 思路：二分+二维Hash
这道题我们首先想到不能暴力判断一个正方形是否合法

然后我们发现当一个正方形合法时，以这个正方形为中心且比它小的正方形也合法

所以我们可以枚举每个正方形的中心点，二分求出以这个点为中心点的最大合法正方形的边长L，其贡献是 $\frac{L+1}{2}$

我们再回过来讨论如何判断一个正方形是否合法

如果这个正方形的原来的、上下翻转的和左右翻转的矩阵都一样，那么这个正方形就是合法的
以这个思路为出发点，我们可以用二维Hash预处理出这个正方形原来的、上下翻转的、左右反转的矩阵，每次判断的时候只要判断这三个矩阵是否相同就可以了

在枚举中心点的时候要分类讨论奇偶情况，具体见代码

**Code**
```cpp
#include <cstdio>
#include <iostream>

#define RI register int
#define mid (l + r >> 1)

using namespace std;

template <class T>
inline void read(T &x) {
	x = 0; T f = 1; char c = getchar();
	while(c > '9' || c < '0') {
		if(c == '-')
			f = -f;
		c = getchar();
	}
	while(c >= '0' && c <= '9') {
		x = x * 10 + c - '0';
		c = getchar();
	}
	x *= f;
}

typedef unsigned long long ull;
const int N = 1e3 + 1;
const int B1 = 233;
const int B2 = 332;
int n, m, ans;
ull a[N][N], b[N][N], c[N][N];
ull pow1[N], pow2[N];

inline void Read() {
	read(n), read(m);
	for(RI i = 1; i <= n; i++)
		for(RI j = 1; j <= m; j++)
			read(a[i][j]),
			b[i][m - j + 1] = a[i][j],//左右翻转
			c[n - i + 1][j] = a[i][j];//上下翻转
}
//二维哈希预处理
inline void init() {
	for(RI i = 1; i <= n; i++)
		for(RI j = 1; j <= m; j++)
			a[i][j] += a[i][j - 1] * B1,
			b[i][j] += b[i][j - 1] * B1,
			c[i][j] += c[i][j - 1] * B1;
	for(RI i = 1; i <= n; i++)
		for(RI j = 1; j <= m; j++)
			a[i][j] += a[i - 1][j] * B2,
			b[i][j] += b[i - 1][j] * B2,
			c[i][j] += c[i - 1][j] * B2;
	pow1[0] = pow2[0] = 1;
	for(RI i = 1, tmp = max(n, m); i <= tmp; i++)
		pow1[i] = pow1[i - 1] * B1,
		pow2[i] = pow2[i - 1] * B2;
}
//判断三个矩阵是否相同
inline bool check(int x, int y, int le) {
	//因为会自然溢出的缘故，unsigned 没有小于0的时候 所以不能写x-le<0 （细节
	if(x > n || y > m || x < le || y < le)
		return false;
	ull res1 = a[x][y] - a[x][y - le] * pow1[le] - a[x - le][y] * pow2[le] + a[x - le][y - le] * pow1[le] * pow2[le];
	int tmp = y;
	y = m - (y - le);//位置要调整（细节
	ull	res2 = b[x][y] - b[x][y - le] * pow1[le] - b[x - le][y] * pow2[le] + b[x - le][y - le] * pow1[le] * pow2[le];
	y = tmp, x = n - (x - le);//位置要调整（细节
	ull res3 = c[x][y] - c[x][y - le] * pow1[le] - c[x - le][y] * pow2[le] + c[x - le][y - le] * pow1[le] * pow2[le];
	return res1 == res2 && res2 == res3;
}
inline void solve() {
	int tmp = min(n, m);
	//这里要分两点讨论，边长为偶数的是枚举格点，而边长为奇数的则是枚举格子（细节
	for(RI i = 0; i < n; i++)
		for(RI j = 0; j < m; j++) {
			int l = 1, r = tmp, res = 0;
			while(l < r) {
				if(check(i + mid, j + mid, mid + mid))
					res = mid, l = mid + 1;
				else
					r = mid;
			}
			ans += res;
		}
	for(RI i = 0; i < n; i++)
		for(RI j = 0; j < m; j++) {
			int l = 1, r = tmp, res = 0;
			while(l < r) {
				if(check(i + mid, j + mid, mid + mid + 1))
					res = mid, l = mid + 1;
				else
					r = mid;
			}
			ans += res;
		}
	ans += n * m;	//1格的也算对称正方形，不要漏了（细节
	printf("%d\n", ans);
}

int main() {
	Read();
	init();
	solve();
	return 0;
}
```


---

## 作者：letitdown (赞：3)

#### 题目描述
给出一个数字矩形，求这个矩形中有多少个子正方形满足上下对称、左右对称。
#### 思路
我们可以用 $ 3 $ 个哈希数组 $ a \ b \ c $ 分别表示矩形从左上往右下看，从左下往右上看，从右上往左下看的样子，那么我们可以得到：
1. 如果正方形 $ ( x , y , u , v ) $（即以 $ ( x , y ) $ 这一格为左上角，$ ( u , v ) $ 为右下角的正方形）左右对称，那么它从左上往右下看和从右上往左下看是一样的，即 $ a $ 哈希数组和 $ c $ 哈希数组相等。
2. 如果正方形 $ ( x , y , u , v ) $ 上下对称，那么它从左上往右下看和从左下往右上看是一样的，即 $ a $ 哈希数组和 $ b $ 哈希数组相等。

如果两条条件都满足，那么这个正方形就是对称的正方形。

我们可以分边有奇数个节点和边有偶数个节点的正方形枚举它的中心点，显然，答案是具有单调性的，于是我们就可以进行二分答案求值。
#### 实现
我们通过处理出 $ ( 1 , 1 , i , j ) $ 矩形的哈希值，那么就可以通过类似前缀和的方式来分别得到正方形 $ ( x , y , u , v ) $ 的 $ a \ b \ c $ 三个值。柿子如下：
```
q.a=a[u][v]-a[u][y-1]*p1[v-y+1]-a[x-1][v]*p2[u-x+1]+a[x-1][y-1]*p1[v-y+1]*p2[u-x+1];
q.b=b[x][v]-b[x][y-1]*p1[v-y+1]-b[u+1][v]*p2[u-x+1]+b[u+1][y-1]*p1[v-y+1]*p2[u-x+1];
q.c=c[u][y]-c[u][v+1]*p1[v-y+1]-c[x-1][y]*p2[u-x+1]+c[x-1][v+1]*p1[v-y+1]*p2[u-x+1];
```
然后进行判断即可。
## Code
```cpp
#include<cstring>
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
namespace EMT{
	#define pf printf
	#define F(i,a,b) for(register int i=a;i<=b;i++)
	#define D(i,a,b) for(register int i=a;i>=b;i--)
	typedef unsigned long long ull;
	inline int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
	inline int min(int a,int b){return a<b?a:b;}inline int max(int a,int b){return a>b?a:b;}
	inline void pi(int x){pf("%d ",x);}inline void pn(){pf("\n");}
	inline void file(){freopen("in.in","r",stdin);freopen("my.out","w",stdout);}
	const int N=1e3+10;
	int n,m,num[N][N],tot;ull a[N][N],b[N][N],c[N][N],p1[N],p2[N];
	struct node{ull a,b,c;}q;
	inline void get(int x,int y,int u,int v){
		q.a=a[u][v]-a[u][y-1]*p1[v-y+1]-a[x-1][v]*p2[u-x+1]+a[x-1][y-1]*p1[v-y+1]*p2[u-x+1];
		q.b=b[x][v]-b[x][y-1]*p1[v-y+1]-b[u+1][v]*p2[u-x+1]+b[u+1][y-1]*p1[v-y+1]*p2[u-x+1];
		q.c=c[u][y]-c[u][v+1]*p1[v-y+1]-c[x-1][y]*p2[u-x+1]+c[x-1][v+1]*p1[v-y+1]*p2[u-x+1];
	}
	inline short main(){
		p1[0]=p2[0]=1;
		n=read(),m=read();
		F(i,1,N-10)p1[i]=p1[i-1]*131,p2[i]=p2[i-1]*13331;
		F(i,1,n)F(j,1,m)num[i][j]=read();
        	//求哈希值
		F(i,1,n)F(j,1,m)a[i][j]=a[i][j-1]*131+a[i-1][j]*13331-a[i-1][j-1]*131*13331+num[i][j];
		D(i,n,1)F(j,1,m)b[i][j]=b[i][j-1]*131+b[i+1][j]*13331-b[i+1][j-1]*131*13331+num[i][j];
		F(i,1,n)D(j,m,1)c[i][j]=c[i][j+1]*131+c[i-1][j]*13331-c[i-1][j+1]*131*13331+num[i][j];
		//偶数边长
		F(i,1,n-1){
			F(j,1,m-1){
				int l=1,r=min(min(n-i,i),min(j,m-j)),ans=0;
				while(l<=r){
					int mid=(l+r)>>1;
					get(i-mid+1,j-mid+1,i+mid,j+mid);
					if(q.a==q.b&&q.a==q.c)l=mid+1,ans=mid;
					else r=mid-1;
				}tot+=ans;
			}
		}
		//奇数边长
		F(i,1,n){
			F(j,1,m){
				int l=1,r=min(min(n-i+1,i),min(m-j+1,j)),ans=0;
				while(l<=r){
					int mid=(l+r)>>1;
					get(i-mid+1,j-mid+1,i+mid-1,j+mid-1);
					if(q.a==q.b&&q.a==q.c)l=mid+1,ans=mid;
					else r=mid-1;
				}tot+=ans;
			}
		}
		pi(tot);
		return 0;
	}
}
signed main(){return EMT::main();}
```


---

## 作者：Viktley (赞：2)

**题目大意:**

给你一个矩阵，问你这个矩阵中

上下对称且左右对称的正方形子矩阵的个数。

------------

**思路：**

首先，很明显要用 hash 来做，

因为是矩形，是二维的。

那就要用二维的 hash。

现在来讲一下二维hash,

一维hash是把一个字符串或一个序列用一个整数表示。

二维hash则是把一个矩阵用一个整数表示。

我们两次 $Hash$ ，第一次，我们横着 $Hash$ :

```cpp
for(int i = 1; i <= n; i++)
	 for(int j = 1; j <= m; j++)
	 	hash[i][j] = hash[i][j - 1] * base_1 + a[i][j];
```

此时的 $Hash(i, j)$ 表示第 $i$ 行第 $j$ 个数的 $Hash$ 值，

此时我们进行第二次 $Hash$ ：

```cpp
	for(int i = 1; i <= n; i++)
	 for(int j = 1; j <= m; j++)
	 	hash[i][j] = hash[i - 1][j] * base_2;
```    

若我们要查询左上角为 $(x, y)$ ，

右下角为 $(x_1, y_1)$ 的矩阵的 $Hash$值就为：

$$hash(x_1,y_1)-hash(x-1, y_1) * base_2^{x_1-x+1}-hash(x_1,y-1)*base_1^{y_1-y+1}+hash(x-1,y-1)*base_2^{x_1-x+1}*base_1^{y_1-y+1}$$

 $ok$ ,回到正题。。。

那你考虑一下一个左右上下对称的正方形要满足什么特点。

那很明显，对称就是按着对称轴翻转过来它还是一样的。

那就是这个正方形左右反过来，

上下反过来所形成的图形和原来都一样。

那你就构造出最大的矩形的两个翻转图形，

然后看看原来的位置应该变道哪里。

原来是 $[x,y]$ （假设），

那左右翻转就是 $[x,m−y+1]$ ，

上下翻转就是 $[n−x+1,y]$ 。

那我们再看矩形翻转之后的位置变化。

假设原来是 $[lx,ly]\sim[rx,ry]$ ，

那左右翻转的就是 $[lx,m-ry+1]\sim[rx,m-rx+1]$ ，

上下翻转的就是 $[n-rx+1,ly]\sim[n-lx+1,ly]$ 。

依题意，得出一个结论：

当一个正方形合法时，

以这个正方形的中心且比它小的正方形也合法，

故我们可以枚举中心点， 

二分出最大的合法正方形的边长 $L$ ，

贡献为 $[\frac{L+1}2]$ ，

接着考虑到中心点不一定是矩阵中的数，

我们需要进行两次遍历。

最后的答案还得加上 $n * m$

------------

**Final Node:**

```cpp
#include<cstdio>
#include<iostream>
#define di1 1000000007ull
#define di2 1000000009ull
#define ull unsigned long long

using namespace std;

int n, m, a[1001][1001], matrix_up[1001][1001], matrix_left[1001][1001], l, r, mid, ans, tot, lx, ly, tmp;
ull hash[1001][1001], times1[1001], times2[1001], hash_up[1001][1001], hash_left[1001][1001], hash1, hash2, hash3;

bool ch(int rx, int ry, int dis) 
{
	lx = rx - dis + 1;
	ly = ry - dis + 1;
	hash1 = hash[rx][ry] - hash[rx][ly - 1] * times1[dis] - hash[lx - 1][ry] * times2[dis] + hash[lx - 1][ly - 1] * times1[dis] * times2[dis];
	
	tmp = rx;
	rx = n - (rx - dis);
	lx = rx - dis + 1;
	ly = ry - dis + 1;
	hash2 = hash_up[rx][ry] - hash_up[rx][ly - 1] * times1[dis] - hash_up[lx - 1][ry] * times2[dis] + hash_up[lx - 1][ly - 1] * times1[dis] * times2[dis];
	
	rx = tmp;
	ry = m - (ry - dis);
	lx = rx - dis + 1;
	ly = ry - dis + 1;
	hash3 = hash_left[rx][ry] - hash_left[rx][ly - 1] * times1[dis] - hash_left[lx - 1][ry] * times2[dis] + hash_left[lx - 1][ly - 1] * times1[dis] * times2[dis];
	
	if (hash1 == hash2 && hash1 == hash3) return 1;
	return 0;
}

int main() 
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++)
	 for (int j = 1; j <= m; j++)
	 {
		scanf("%d", &a[i][j]);
		matrix_up[n - i + 1][j] = a[i][j];
		matrix_left[i][m - j + 1] = a[i][j];
	 }
	times1[0] = times2[0] = 1ull;
	for (int i = 1; i <= n; i++) times1[i] = times1[i - 1] * di1;
	for (int i = 1; i <= m; i++) times2[i] = times2[i - 1] * di2; 
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= m; j++) 
		{
			hash[i][j] = hash[i][j - 1] * di1 + a[i][j];
			hash_up[i][j] = hash_up[i][j - 1] * di1 + matrix_up[i][j];
			hash_left[i][j] = hash_left[i][j - 1] * di1 + matrix_left[i][j];
			
		}
		times1[i] = times1[i - 1] * di1;
	}
	for (int i = 1; i <= n; i++) 
	{
		for (int j = 1; j <= m; j++) 
		{
			hash[i][j] += hash[i - 1][j] * di2;
			hash_up[i][j] += hash_up[i - 1][j] * di2;
			hash_left[i][j] += hash_left[i - 1][j] * di2;
		}
	}
	for (int i = 1; i <= n; i++)
	 for (int j = 1; j <= m; j++) 
	 {
		ans = 0, l = 1,	r = min(min(i, n - i + 1), min(j, m - j + 1));
		while (l <= r) 
		{
			mid = (l + r) >> 1;
			if (i - mid + 1 < 1 || i + mid - 1 > n || j - mid + 1 < 1 || j + mid - 1 > m) 
			{
				r = mid - 1;
				continue;
			}		
			if (ch(i + mid - 1, j + mid - 1, mid * 2 - 1)) ans = mid, l = mid + 1;
			else r = mid - 1;
		}
		tot += ans;
		ans = 0, l = 1, r = min(min(i, n - i), min(j, m - j));
		while (l <= r) 
		{
			mid = (l + r) >> 1;
			if (i - mid + 1 < 1 || i + mid > n || j - mid + 1 < 1 || j + mid > m) 
			{
				r = mid - 1;
				continue;
			}
			if (ch(i + mid, j + mid, mid * 2)) ans = mid, l = mid + 1;
			else r = mid - 1;
		}
		tot += ans;
	 }
	printf("%d", tot);
	return 0;
}

```


---

## 作者：木xx木大 (赞：2)

[P2601 [ZJOI2009]对称的正方形](https://www.luogu.com.cn/problem/P2601)

分别哈希左右对称和上下对称过后的矩形。当一个正方形合法时，以这个正方形的中心为中心且比它小的正方形也合法

所以我们可以枚举每个正方形的中心点，二分求出以这个点为中心点的最大合法正方形的边长 $L$，其贡献是$(L+1)/2$。对于长度为奇数的正方形，以格子（一个 $1\times 1$的正方形）为中心二分最远符合条件的长度。对于长度为偶数的正方形，以格点（就是一个点）为中心二分最远符合条件的长度

```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
using namespace std;
const int N=1005;
const int sd1=101,sd2=1001;
int n,m,ans;
int a[N][N],b[N][N],c[N][N],p1[N],p2[N];
int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')w=-w;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		s=s*10+ch-'0';
		ch=getchar();
	}
	return s*w;
}
void init()
{
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			a[i][j]+=a[i][j-1]*sd1;
			b[i][j]+=b[i][j-1]*sd1;
			c[i][j]+=c[i][j-1]*sd1;
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			a[i][j]+=a[i-1][j]*sd2;
			b[i][j]+=b[i-1][j]*sd2;
			c[i][j]+=c[i-1][j]*sd2;
		}
	p1[0]=p2[0]=1;
	for(int i=1;i<=max(n,m);i++)
	{
		p1[i]=p1[i-1]*sd1;
		p2[i]=p2[i-1]*sd2;
	}
}
bool check(int x,int y,int l)
{
	if(x>n||y>m||x<l||y<l)return 0;
	ull sum1=a[x][y]-a[x-l][y]*p2[l]-a[x][y-l]*p1[l]+a[x-l][y-l]*p1[l]*p2[l];
	int y1=m-y+l;
	ull sum2=b[x][y1]-b[x-l][y1]*p2[l]-b[x][y1-l]*p1[l]+b[x-l][y1-l]*p1[l]*p2[l];
	int x1=n-x+l;
	ull sum3=c[x1][y]-c[x1-l][y]*p2[l]-c[x1][y-l]*p1[l]+c[x1-l][y-l]*p1[l]*p2[l];
	if(sum1==sum2&&sum2==sum3)return 1;
	return 0;
}
int main()
{
	
	n=read(),m=read();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			a[i][j]=read();
			b[i][m-j+1]=a[i][j];
			c[n-i+1][j]=a[i][j];
		}
	init();
	for(int i=0;i<n;i++)//以格点为中心的 二分的值为边长的一半
		for(int j=0;j<m;j++)
			{
				int sum=0,l=1,r=min(n,m);
				while(l<r)
				{
					int mid=(l+r)>>1;
					if(check(i+mid,j+mid,mid+mid))
						sum=mid,l=mid+1;
					else r=mid;
				}
				ans+=sum;
			}
	for(int i=1;i<=n;i++)//以格子为中心的
		for(int j=1;j<=m;j++)
			{
				int sum=0,l=1,r=min(n,m);
				while(l<r)
				{
					int mid=(l+r)>>1;
					if(check(i+mid,j+mid,mid+mid+1))
						sum=mid,l=mid+1;
					else r=mid;
				}
				ans+=sum;
			}
	ans+=n*m;
	printf("%d",ans);
	return 0;
}

---

## 作者：GBLoi (赞：2)



[题面](https://www.luogu.com.cn/problem/P2601)

### 题意简述：

统计一个矩阵的子矩阵中为**上下对称且左右对称**的正方形子矩阵的个数。

### 思路

- 法一：哈希+二分
- 法二：~~bfs~~

### 法一

这是哈希的一个**基于字符串匹配具有单调性**的经典应用。

本题的单调性？

我们可以发现 以同一个点为中心的正方体

- 若边长较大的正方体左右对称，那么边长较小的一定左右对称。
- 若边长较大的正方体上下对称，那么边长较小的一定上下对称。

所以可以二分边长，

然后借助二维Hash check。

哈希的具体实现详见代码。


```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#define LL unsigned long long
#define rint register int 
using namespace std;
namespace FastIO
{
const int _SIZE = (1 << 21) + 1;
char ibuf[_SIZE],obuf[_SIZE];
char *iS,*iT;
char c;
char qu[55];
char *oS=obuf,*oT=oS+_SIZE-1;
bool _sign=false;
int qr;
// getchar
#define gc() (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, _SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)
// print the remaining part
inline void flush() 
{
    fwrite(obuf,1,oS-obuf,stdout);
    oS=obuf;
    return;
}
// putchar
inline void putc(const char &x) 
{
    *oS++=x;
    if(oS==oT)
        flush();
    return;
}
// input a signed integer
template <class T>
inline void read(T &x) 
{
	x=0;
	_sign=false;
    for (c=gc();c<'0'||c>'9';c=gc())
        if (c=='-')
            _sign=true;
    for (;c>='0'&&c<='9';c=gc()) 
		x=(x<<1)+(x<<3)+(c&15);
    x=(_sign) ? (~x+1) : x;
    return;
}
// print a signed integer
template <class I>
inline void print(I x) {
    if (!x) {
    	putc('0');
    	return;
	}
    if (x<0)
        putc('-'),x=~x+1;
    while(x) qu[++qr]=x%10+'0',x/=10;
    while(qr) putc(qu[qr--]);
    return;
}
// no need to call flush at the end manually!
struct Flusher_ 
{
    ~Flusher_() { flush(); }
}io_flusher_;
}  // namespace io
using FastIO::read;
using FastIO::print;
using FastIO::putc;
//====================================================
const LL MOD=998244353ll;
const LL P1=2333;
const LL P2=13131;
const int N=1024;
int n,m;
LL a[N][N];
LL h1[N][N],h2[N][N],h3[N][N];
LL pow1[N],pow2[N];
void Hash()
{
	register int i,j;
	for(i=1;i<=n;i++) 
		for(j=1;j<=m;j++) 
			h1[i][j]=h1[i][j-1]*P1+a[i][j];
	for(i=1;i<=n;i++) 
		for(j=1;j<=m;j++) 
			h1[i][j]=h1[i-1][j]*P2+h1[i][j];
	
	for(i=1;i<=n;i++) 
		for(j=m;j>=1;j--) 
			h2[i][j]=h2[i][j+1]*P1+a[i][j];
	for(i=1;i<=n;i++) 
		for(j=m;j>=1;j--) 
			h2[i][j]=h2[i-1][j]*P2+h2[i][j];
	
	for(i=n;i>=1;i--) 
		for(j=1;j<=m;j++) 
			h3[i][j]=h3[i][j-1]*P1+a[i][j];
	for(i=n;i>=1;i--) 
		for(j=1;j<=m;j++) 
			h3[i][j]=h3[i+1][j]*P2+h3[i][j];
	
	return;
}
#define get_1(x,y,xx,yy) (h1[xx][yy]-h1[x-1][yy]*pow2[xx-x+1]-h1[xx][y-1]*pow1[yy-y+1]+h1[x-1][y-1]*pow2[xx-x+1]*pow1[yy-y+1])
inline LL get_2(int x,int y,int xx,int yy)
{
	swap(y,yy);
	return h2[xx][yy] - h2[x-1][yy]*pow2[xx-x+1] - h2[xx][y+1]*pow1[y-yy+1] + h2[x-1][y+1]*pow2[xx-x+1]*pow1[y-yy+1];
}
inline LL get_3(int x,int y,int xx,int yy)
{
	swap(x,xx);
	return h3[xx][yy]-h3[x+1][yy]*pow2[x-xx+1]-h3[xx][y-1]*pow1[yy-y+1]+h3[x+1][y-1]*pow2[x-xx+1]*pow1[yy-y+1];
}
LL part1,part2,part3;
inline bool check(const int &x,const int &y,const int &k)
{// x ,y left up k=d;
	if(x<1||y<1||x+k-1>n||y+k-1>m) 
		return false;
//	part1=get(x,y,x+k-1,y+(k>>1)-(k&1^1),1);
//	part2=get(x,y+(k>>1),x+k-1,y+k-1,2);
//	if(part1!=part2) 
//		return false;
//	part1=get(x,y,x+(k>>1)-(k&1^1),y+k-1,1);
//	part2=get(x+(k>>1),y,x+k-1,y+k-1,3);
//	if(part1!=part2) 
//		return false;
//	else return true;
	part1=get_1(x,y,x+k-1,y+k-1);
	part2=get_2(x,y,x+k-1,y+k-1);
	if(part1!=part2) 
		return false;
	part3=get_3(x,y,x+k-1,y+k-1);
	if(part2!=part3) 
		return false;
	else return true;
}
inline int binary(const int &x,const int &y,const int &d)
{
	register int L=0,R=min(min(x,y),min(n-x,m-y))+2,mid;
	while(L+1<R) {
		mid=(L+R)>>1;
		if(check(x-mid+d,y-mid+d,2*mid+(d^1))) 
			L=mid;
		else R=mid;
	}
	return L;
}
int main()
{
//	freopen("beauty.in","r",stdin);
//	freopen("beauty.out","w",stdout);
	register int i,j;
	read(n); read(m);
	for(i=1;i<=n;i++) 
		for(j=1;j<=m;j++) 
			read(a[i][j]);
	pow1[0]=pow2[0]=1ll;
	for(i=1;i<=N-2;i++) {
		pow1[i]=pow1[i-1]*P1;
		pow2[i]=pow2[i-1]*P2;
	}
	Hash();
	rint ans=0;
	for(i=1;i<=n;i++) 
		for(j=1;j<=m;j++) {
			ans+=binary(i,j,0);
			ans+=binary(i,j,1);
		}
	ans+=n*m;
	print(ans);
	putc('\n');
	FastIO::flush();
	return 0;
}

```


记得要把原图的左右颠倒图和上下颠倒图分别Hash。

### 法二

如何bfs（不会TLE）？

这要从朴素算法说起。

很容易想到，可以枚举每一个正方形，然后挨个check。

肯定TLE。

不妨把一个正方形用其中心点和边长表示。

接着我们发现 同一中心点 边长为 $k$ 的对称是基于边长为 $k-2$ 的对称基础上的。

如图

![](https://cdn.luogu.com.cn/upload/image_hosting/qrm2ihkv.png)



假设粉色的矩形已经对称。

那么上下左右分别往外延伸一格。

只要判断图中同色的格子是否对称即可。

这样就从 $k$ 变成了 $k+2$ 。

偶数边长的矩阵类似，~~这里就不写了。~~ 留给读者自行思考。

所以开始的时候，我们将

- 奇数边长：边长为一的点入队，若可以变成 $k+2$ ，出队，并将 $k+2$ 入队。
- 偶数边长：先检查 $2*2$ 的格子是否对称，其余和奇数类似。

别忘了当所有点都是一个数时上数学公式。

不过这题好像并没有卡这个。。

#### *Code*

//不要在意函数名。

```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#define LL long long
using namespace std;
namespace FastIO
{
const int _SIZE = (1 << 21) + 1;
char ibuf[_SIZE],obuf[_SIZE];
char *iS,*iT;
char c;
char qu[55];
char *oS=obuf,*oT=oS+_SIZE-1;
bool _sign=false;
int qr;
// getchar
#define gc() (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, _SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)
// print the remaining part
inline void flush() 
{
    fwrite(obuf,1,oS-obuf,stdout);
    oS=obuf;
    return;
}
// putchar
inline void putc(const char &x) 
{
    *oS++=x;
    if(oS==oT)
        flush();
    return;
}
// input a signed integer
template <class T>
inline void read(T &x) 
{
	x=0;
	_sign=false;
    for (c=gc();c<'0'||c>'9';c=gc())
        if (c=='-')
            _sign=true;
    for (;c>='0'&&c<='9';c=gc()) 
		x=(x<<1)+(x<<3)+(c&15);
    x=(_sign) ? (~x+1) : x;
    return;
}
// print a signed integer
template <class I>
inline void print(I x) {
    if (!x) {
    	putc('0');
    	return;
	}
    if (x<0)
        putc('-'),x=~x+1;
    while(x) qu[++qr]=x%10+'0',x/=10;
    while(qr) putc(qu[qr--]);
    return;
}
// no need to call flush at the end manually!
struct Flusher_ 
{
    ~Flusher_() { flush(); }
}io_flusher_;
}  // namespace io
using FastIO::read;
using FastIO::print;
using FastIO::putc;
//===============================
const int N=1024;
const LL MOD=998244353ll;
LL a[N][N];
int n,m;
struct Node
{
	int x,y,len;
	Node (const int &xx,const int &yy,const int &zz) : x(xx),y(yy),len(zz) {}
};
queue<Node> q;
#define law(x,y) (x>=1&&x<=n&&y>=1&&y<=m)
unsigned LL ans=0;
void spfa()
{
	int i;
	int x,y,z;
	while(q.size()) {
		x=q.front().x; y=q.front().y;
		z=q.front().len;
		q.pop();
		z++;
		if(!(law((x-z),(y-z))&&law((x+z),(y+z))))
			continue;
		if(a[x-z][y]!=a[x+z][y]||a[x][y-z]!=a[x][y+z]) 
			continue;
		for(i=1;i<=z;i++) {
			if(a[x-z][y-i]!=a[x-z][y+i]||a[x+z][y-i]!=a[x+z][y+i])
				break;
			if(a[x-z][y-i]!=a[x+z][y-i]) 
				break;
			if(a[x-i][y-z]!=a[x+i][y-z]||a[x-i][y+z]!=a[x+i][y+z]) 
				break;
			if(a[x-i][y-z]!=a[x-i][y+z]) 
				break;
		}
		if(i<z+1) continue;
		q.push(Node(x,y,z));
		ans++;
	//	printf("%d %d %d\n",x,y,ans);
	}
	return;
}
void SPFA()
{
	int i;
	int x,y,z;
	while(q.size()) {
		x=q.front().x; y=q.front().y;
		z=q.front().len;
		q.pop();
		z++;
		if(!(law((x-z+1),(y-z+1))&&law((x+z),(y+z))))
			continue;
		for(i=1;i<=z;i++) {
			if(a[x-z+1][y-i+1]!=a[x-z+1][y+i]||a[x+z][y-i+1]!=a[x+z][y+i])
				break;
			if(a[x-z+1][y-i+1]!=a[x+z][y-i+1]) 
				break;
			if(a[x-i+1][y-z+1]!=a[x+i][y-z+1]||a[x-i+1][y+z]!=a[x+i][y+z]) 
				break;
			if(a[x-i+1][y-z+1]!=a[x-i+1][y+z]) 
				break;
		}
		if(i<z+1) continue;
		q.push(Node(x,y,z));
		ans++;
	//	printf("%d %d %d\n",x,y,ans);
	}
	return;
}
int main()
{
//	freopen("beauty.in","r",stdin);
//	freopen("beauty.out","w",stdout);
	int i,j;
	LL x;
	bool flag=true;
	read(n); read(m);
	for(i=1;i<=n;i++)
		for(j=1;j<=m;j++) 
			read(a[i][j]);
	for(i=1;i<=n;i++) 
		for(j=1;j<=m;j++) {
			if(i==1&&j==1) 
				x=a[i][j];
			else if(x!=a[i][j]) 
				flag=false;	
		}
	if(flag) {
		x=min(m,n);
		ans=(max(m,n)-x+1ll)*x*(x+1ll)*(2ll*x+1ll)/6ll;
		print(ans);
		return 0;
	}	
	
	for(i=1;i<=n;i++) 
		for(j=1;j<=m;j++) 
			q.push(Node(i,j,0));
	
	spfa();
	for(i=1;i<=n-1;i++) {
		for(j=1;j<=m-1;j++) {
			if(a[i][j]==a[i+1][j]&&a[i+1][j]==a[i][j+1]&&a[i][j+1]==a[i+1][j+1]) {
				q.push(Node(i,j,1));
				ans++;
		//		printf("%d %d %d\n",i,j,ans);
			}
		}
	}
	SPFA();
	ans+=n*m;
	print(ans);
	FastIO::flush();
	return 0;
}
```

P.S.:该算法在随机数据下运行效率极佳，在构造数据下能被卡的很惨。



---

## 作者：JA_yichao (赞：2)


[推荐博客食用](https://blog.csdn.net/Jackma_mayichao/article/details/113782285)

___
# 题目大意
给出一个 $n\times m$ 的矩阵，求矩阵中上下左右对称的正方形子矩阵的个数。

# 思路
首先这道题暴力去搞肯定会超时，

因为主要是**枚举和判断**两大部分耗时，所以想到了用**二维哈希**去做。

此题需要寻找上下左右对称的正方形子矩阵，所以要哈希三次，

分别是原矩阵，上下颠倒的矩阵和左右颠倒的矩阵。

达到 $O(1)$ 的判断复杂度后枚举还是会超时 ($O(n^3)$ 的复杂度)，因此考虑优化掉一个 $n$。

回到暴力，一般的暴力都是枚举每一个点，然后从枚举到的点发散判断有否符合条件的矩阵，

发现可以用**二分**来优化发散步骤的时间，最后时间复杂度是 $O(n^2\log_2{n})$。

___
大体思路解决后，思考怎样解决发散。

我的思路非常清奇，**枚举矩阵右下角的点**来做，

可是这样不能满足二分到的范围以内都是上下左右对称的正方形子矩阵啊？

所以需要**由右下角的点把二分范围扩大一倍来作判断条件，以中心点为中心。**

以此来确保计算的正确性。

其实也就是**由右下角的点来确定中心点**，异曲同工。

判断部分就是把构造出的三个哈希矩阵直接对比(当然是数值的比较)，这里不再赘述。

二分要分奇偶，因为奇数和偶数有统计上的差异。

# 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
unsigned long long a[1010][1010],b[1010][1010],c[1010][1010];
unsigned long long f1[1000010],f2[1000010];
int n,m,ans;
bool check(int mid,int i,int j)
{
	if(i-mid<0||j-mid<0||i>n||j>m||i<0)
	  return 0;
	int a1=a[i][j]-a[i-mid][j]*f2[mid]-a[i][j-mid]*f1[mid]+a[i-mid][j-mid]*f1[mid]*f2[mid];
	int bx=n-(i-mid),by=m-(j-mid);
	int b1=b[bx][j]-b[bx-mid][j]*f2[mid]-b[bx][j-mid]*f1[mid]+b[bx-mid][j-mid]*f1[mid]*f2[mid];
	int c1=c[i][by]-c[i-mid][by]*f2[mid]-c[i][by-mid]*f1[mid]+c[i-mid][by-mid]*f1[mid]*f2[mid];
	//cout<<a1<<" "<<b1<<" "<<c1<<endl;
	if(a1==b1&&b1==c1)
	  return 1;
	else
	  return 0;
}
void yhash()
{
	for(int i=1; i<=n; i++)
	 for(int j=1; j<=m; j++)
	  {
	  	a[i][j]=a[i][j-1]*1000000009ull+a[i][j];
	  	b[i][j]=b[i][j-1]*1000000009ull+b[i][j];
		c[i][j]=c[i][j-1]*1000000009ull+c[i][j];
	  }
	for(int i=1; i<=n; i++)
	 for(int j=1; j<=m; j++)
	  {
	  	a[i][j]=a[i-1][j]*1000000007ull+a[i][j];
	  	b[i][j]=b[i-1][j]*1000000007ull+b[i][j];
		c[i][j]=c[i-1][j]*1000000007ull+c[i][j];
	  }
}
int main()
{
	cin>>n>>m;
	f1[0]=1ull,f2[0]=1ull;
	for(int i=1; i<=max(n,m); i++)
	   f1[i]=f1[i-1]*1000000009ull,f2[i]=f2[i-1]*1000000007ull;
	for(int i=1; i<=n; i++)
	 for(int j=1; j<=m; j++)
	  {
	  	scanf("%ulld",&a[i][j]);
	  	c[i][m-j+1]=a[i][j];    //左右颠倒
	  	b[n-i+1][j]=a[i][j];    //上下颠倒
	  	//（不明白的手推一下）
	  }
	yhash();
	for(int i=1; i<=n; i++)
	 for(int j=1; j<=m; j++)
	  {
	  	 int l=0,r=min(i,j)+1,mid=0,maxx=1;
	  	 while(l<=r)//奇数 
	  	  {
	  	  	mid=(l+r)/2;
	  	  	if(check(mid*2-1,i+mid,j+mid))  //扩大到以中心点为中心
	  	  	  l=mid+1,maxx=max(mid*2-1,maxx);
	  	  	else
	  	  	  r=mid-1;
		  }
		 ans=ans+(maxx+1)/2;
		 maxx=0;
		 l=0,r=min(i,j);
		 while(l<=r)  //偶数
	  	  {
	  	  	mid=(l+r)/2;
	  	  	if(check(mid*2,i+mid,j+mid))      //同上
	  	  	  l=mid+1,maxx=max(mid*2,maxx);
	  	  	else
	  	  	  r=mid-1;
		  }
		ans=ans+(maxx+1)/2;
	  }
	cout<<ans;
	return 0;
}
```


---

## 作者：xkcdjerry (赞：1)

鬼才题

先考虑最 naive 的做法：枚举左上角和长度逐一判断，复杂度 $O(n^5)$，$30$ 分一档都 T 的没影了。

发现这个做法中每个点都被同一个起始点查看了若干次，能不能改进呢？

我们枚举中心点（先不考虑偶数的问题）然后依次向外一圈一圈验证，复杂度降低为 $O(n^4)$。（有 $n^2$ 种可能选点，每次选点至多访问所有共 $n$ 个点恰好一次）

看起来没有好到哪里去，但是注意到如果对于正方形已经不满足题目条件了，那么这个正方形向上下左右各扩张一圈一定也不符合条件。   

严谨的来说，对于一个起始点 $(x,y)$，若以其为中心的边长为 $l_0$ 的正方形不满足条件，那么对于任意 $l \geqslant l_0$，以 $(x,y)$ 为中心的边长为 $l$ 的正方形也不满足条件。这启发我们可以二分以 $O(n^4 \log n)$ 的时间复杂度解决问题 ~~喂喂喂更慢了好不好~~。

虽然直接二分不行，但是如果我们能对于给定的正方形以 $O(1)$ 的复杂度确定是否满足题目条件，我们就能以 $O(n^2 \log n)$ 过掉这道题。

这里我用了一个与题解不（geng）一（ma）样（fan）的方法：我们把这个正方形从两条中轴线处拆开，令左上的哈希为 $D$，右上**左右翻转**后的哈希为 $C$，左下**上下翻转**后的哈希为 $B$，右下**上下左右**翻转后的哈希为 $A$，那么这个正方形满足条件当且仅当 $A=B=C=D$。

那么，完了……吗？我们上面只考虑了边长为奇数的情况，边长为偶数时，我们只需要人为规定以选择的方格的右下角而不是中心为正方形的中心拆开即可。（注意一下每个部分起点的位置不要搞错了）

代码：

```c++
#include <cstdio>
#include <random>
#define ll long long
#define ull unsigned long long

#define N 1010
#define B1 1000000007
#define B2 1000000009
int n,m;
ll s[N][N];
ull a[N][N],b[N][N],c[N][N],d[N][N],f[N],g[N];
//锚定点：
//a b
//c d
bool judge(int l,int xa,int ya,int xb,int yb,
                 int xc,int yc,int xd,int yd)
{
    ull A=a[xa][ya]-a[xa+l][ya]*f[l]-a[xa][ya+l]*g[l]+a[xa+l][ya+l]*f[l]*g[l];
    ull B=b[xb][yb]-b[xb+l][yb]*f[l]-b[xb][yb-l]*g[l]+b[xb+l][yb-l]*f[l]*g[l];
    ull C=c[xc][yc]-c[xc-l][yc]*f[l]-c[xc][yc+l]*g[l]+c[xc-l][yc+l]*f[l]*g[l];
    ull D=d[xd][yd]-d[xd-l][yd]*f[l]-d[xd][yd-l]*g[l]+d[xd-l][yd-l]*f[l]*g[l];
    return A==B&&B==C&&C==D;
}
bool judge(int l,int x,int y)
{
    int v=(l+1)/2;
    //l为奇数：中点扩展
    if(l&1)
    {
        if(x<v||y<v||x+v-1>n||y+v-1>m) return false;
        return judge(v,x,y,x,y,x,y,x,y);
    }
    else
    {
        if(x<v||y<v||x+v>n||y+v>m) return false;
        return judge(v,x+1,y+1,x+1,y,x,y+1,x,y);
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) scanf("%lld",s[i]+j);

    //a锚定点左上，i j逆序
    for(int i=n;i>=1;i--) for(int j=m;j>=1;j--)
    {
        a[i][j]=s[i][j]+a[i+1][j]*B1+a[i][j+1]*B2-a[i+1][j+1]*B1*B2;
    }
    //b锚定点右上，i逆j顺
    for(int i=n;i>=1;i--) for(int j=1;j<=m;j++)
    {
        b[i][j]=s[i][j]+b[i+1][j]*B1+b[i][j-1]*B2-b[i+1][j-1]*B1*B2;
    }
    //c锚定点左下，i顺j逆
    for(int i=1;i<=n;i++) for(int j=m;j>=1;j--)
    {
        c[i][j]=s[i][j]+c[i-1][j]*B1+c[i][j+1]*B2-c[i-1][j+1]*B1*B2;
    }
    //d锚定点右下，i j顺序
    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++)
    {
        d[i][j]=s[i][j]+d[i-1][j]*B1+d[i][j-1]*B2-d[i-1][j-1]*B1*B2;
    }
    //f:预处理乘积和
    f[0]=g[0]=1;
    for(int i=1;i<=n;i++) f[i]=f[i-1]*B1;
    for(int i=1;i<=m;i++) g[i]=g[i-1]*B2;
    //计算贡献
    long long ans=0;
    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++)
    {
        int L,R;
        L=0,R=n;
        while(L!=R)
        {
            int mid=(L+R+1)/2;
            if(judge(mid*2,i,j)) L=mid;
            else R=mid-1;
        }
        ans+=L;

        L=1,R=n;
        while(L!=R)
        {
            int mid=(L+R+1)/2;
            if(judge(mid*2-1,i,j)) L=mid;
            else R=mid-1;
        }
        ans+=L;
    }
    printf("%lld",ans);
}
```









---

## 作者：Jayun (赞：1)

# 链接：

[洛谷](https://www.luogu.com.cn/problem/P2601)

[博客园](https://www.cnblogs.com/GJY-JURUO/p/14729055.html)

# 题目大意：

在一个 $n \times m$ 的矩阵内求出上下左右都对称的正方形。

$1\leq n,m\leq 1000$。

# 正文：

对于本题有一个性质：一个合法的正方形内部也是合法的正方形。

然后可以得到一个暴力的思路。对于每一个点往外扩张，每次判合法就可以只判断最外一层，这是边长为奇；还要预处理出所有边长为二的合法正方形，同样向外扩张。

每次判外圈时，相当于有若干个长方形要在合法的位置：

![](https://cdn.luogu.com.cn/upload/image_hosting/for0sq2i.png)

如图，不同颜色的格子可以看作不同长方形的顶点。

一般一道题想得这么复杂，要换个思路，重新审题。

---

其实判合法并不用这么麻烦。既然合法的正方形是上下、左右对称，那我们就取正方形的左上部分、左右颠倒的右上部分、上下颠倒的左下部分判是否一样。

![](https://cdn.luogu.com.cn/upload/image_hosting/3d7vfjlj.png)

可以通过**二维哈希**判。

---

$\mathcal{O}(n)$ 往外扩张会超时，可以二分解决。这里最好不要像上文提到的枚举正方形的中心点，最好是枚举正方形的左上角，然后二分正方形的边长。

# 代码：

```cpp
int n, m;
unsigned ll base1 = 87, base2 = 31;
unsigned ll a[N][N], b[N][N], c[N][N], ans;
unsigned ll Ha[N][N], Hb[N][N], Hc[N][N];
unsigned ll fac1[N], fac2[N];

bool check(int len, int x, int y)
{
	if (x > n || y > m || x < len || y < len) return 0;
	unsigned ll CHa = 0, CHb = 0, CHc = 0;
	CHa = Ha[x][y] - Ha[x - len][y] * fac2[len] - 
	      Ha[x][y - len] * fac1[len] + Ha[x - len][y - len] * fac1[len] * fac2[len];
	int t = y; y = m - (y - len);
	CHb = Hb[x][y] - Hb[x - len][y] * fac2[len] - 
	      Hb[x][y - len] * fac1[len] + Hb[x - len][y - len] * fac1[len] * fac2[len];
	y = t, x = n - (x - len);
	CHc = Hc[x][y] - Hc[x - len][y] * fac2[len] - 
	      Hc[x][y - len] * fac1[len] + Hc[x - len][y - len] * fac1[len] * fac2[len];
	return CHa == CHb && CHb == CHc;
}

ll Binary(int i, int j, int f = 0)
{
	int l = 0, r = min(i, j) + f, mid, tmp = f;
	while (l <= r)
	{
		mid = l + r >> 1;
		if (check(mid * 2 - f, i + mid, j + mid))
			l = mid + 1, tmp = mid * 2 - f; 
		else r = mid - 1;
	}
	return (tmp + 1) / 2;
}

int main()
{
	n = READ(), m = READ();
	fac1[0] = fac2[0] = 1ull;
	for (int i = 1; i <= n; i++)
		fac1[i] = fac1[i - 1] * base1;
	for (int i = 1; i <= m; i++)
		fac2[i] = fac2[i - 1] * base2;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			b[i][m - j + 1] = c[n - i + 1][j] = a[i][j] = READ();
	
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			Ha[i][j] += Ha[i][j - 1] * base1 + a[i][j],
			Hb[i][j] += Hb[i][j - 1] * base1 + b[i][j],
			Hc[i][j] += Hc[i][j - 1] * base1 + c[i][j];
	
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			Ha[i][j] += Ha[i - 1][j] * base2,
			Hb[i][j] += Hb[i - 1][j] * base2, 
			Hc[i][j] += Hc[i - 1][j] * base2;

	for (int i = 1; i <= n; i++)
 		for (int j = 1; j <= m; j++)
		{
			ans += Binary(i, j, 1) + Binary(i, j);
		}
	printf ("%llu\n", ans);
	return 0;
}
```

---


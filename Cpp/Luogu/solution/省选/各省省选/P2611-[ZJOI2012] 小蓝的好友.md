# [ZJOI2012] 小蓝的好友

## 题目背景

终于到达了这次选拔赛的最后一题，想必你已经厌倦了小蓝和小白的故事。

为了回馈各位比赛选手，此题的主角是贯穿这次比赛的关键人物——小蓝的好友。

在帮小蓝确定了旅游路线后，小蓝的好友也不会浪费这个难得的暑假。

与小蓝不同，小蓝的好友并不想将时间花在旅游上，而是盯上了最近发行的即时战略游戏——SangoCraft。

但在前往通关之路的道路上，一个小游戏挡住了小蓝的好友的步伐。

## 题目描述


“国家的战争其本质是抢夺资源的战争”是整款游戏的核心理念，这个小游戏也不例外。

简单来说，用户需要在一块 $R\times C$ 的长方形土地上选出一块子矩形。

而系统随机生成了 $N$ 个资源点，第 $i$ 个资源点的坐标为 $(x_i,y_i)$。

位于用户所选的长方形土地上的资源点越多，给予用户的奖励也越多。

悲剧的是，小蓝的好友虽然拥有着极其优秀的能力，但同时也有着极差的 RP，小蓝的好友所选的区域总是没有一个资源点。

终于有一天，小蓝的好友决定投诉这款游戏的制造厂商，为了搜集证据，小蓝的好友想算出至少包含一个资源点的区域的数量。

具体的说，你需要计算有多少个四元组 $(LB,DB,RB,UB)$ 满足 $1\le LB\le RB\le R,1\le DB\le UB\le C$ ，且存在一个 $i$ 使得 $LB\le x_i\le RB,DB\le y_i\le UB$ 均成立。

作为小蓝的好友，这自然是你分内之事。

## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，$N\le 50$。
- 对于 $40\%$ 的数据，$N\le 2\times 10^3$。
- 对于 $100\%$ 的数据，$1\le R,C\le 4\times 10^4$，$1\le N\le 10^5$，题目保证资源点的位置两两不同，且位置为随机生成。

## 样例 #1

### 输入

```
5 5 4
1 2
2 3
3 5
4 1
```

### 输出

```
139```

# 题解

## 作者：流水行船CCD (赞：14)

其他题解的思路都有点看不懂，而且很多图片崩了，来发一发蒟蒻认为比较清晰的思路。

## Part1 基本框架
- 求至少有一个点的矩形很麻烦，但是求一个点都没有的矩形就比较清晰，考虑**正难则反**，最后用总矩形数做差即可得到答案。

- 直接算矩形不好算，这里**定一求一**，因此枚举矩形**下边界**，快速计算合法矩形个数，让后就变成了如图问题。

![](https://cdn.luogu.com.cn/upload/image_hosting/5kmynwj5.png)

_没有资源点的列可以看作在第 $0$ 行有一个资源点，同一列有多个资源点的可以看作仅有最下方的哪一个点。_

- 可以看到，如果将这些二维点连起来，可以得到一颗**笛卡尔树**，而矩形计数问题，就可以转换为经典问题树上计数，即计算每个点下方没有任何资源点，且下边界在枚举位置的矩形个数。

![](https://cdn.luogu.com.cn/upload/image_hosting/y0723uvo.png)

- 由于从上往下建树会导致修改下边界时需要更新每一个点的答案，考虑从下往上进行建树，即**根在最下方的那个点**。然后对于一个点，其儿子贡献的矩形个数为，这里以右儿子为例，左儿子同理，具体可以结合图片绿色方框理解。 

$$\Delta Ans=C^{2}_{sz_{ls}} \times (high_x - high_ls)$$

![](https://cdn.luogu.com.cn/upload/image_hosting/ppz964xw.png)

- 而后，由于朴素笛卡尔树不支持删除，所以对于每一个横坐标，重新建笛卡尔树求解，**注意根到当前扫描下边界的矩形个数需要单独计算**，复杂度 $O(R \times C)$，无法通过。

## 优化

考虑优化，瓶颈在于删除操作，想到 **fhq-Treap** 也是一种笛卡尔树，且支持删除，考虑把原本随机赋值的堆性质变量换成每一个点的横坐标，即可动态维护，使用 pushup 统计答案。

由于题目保证点随机，期望 $O(R \log_2 C)$，可以通过。

## AC Code

小技巧：可以在初始化时把没有资源点看作是在第零行有一个资源点，这样会避免讨论边界。

```cpp
#include<bits/stdc++.h>

#define ll long long
#define int long long
#define ull unsigned long long
#define mp make_pair
#define pb emplace_back
#define sort stable_sort
#define REP(i,l,r) for(int i=l;i<=r;++i)
#define PER(i,r,l) for(int i=r;i>=l;--i)
 
using namespace std;
 
const int inf=1e9+7;
const ll INF=1e18+7;
 
random_device R;
mt19937 G(R());
inline int rd(int l,int r){return uniform_int_distribution<int>(l,r)(G);}
 
char buf[1<<19],*p1=buf,*p2=buf;
#define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<19,stdin),p1==p2)?EOF:*p1++)
static inline int read() {
	register int x=0;
	register char ch=gc();
	while(ch<'0'||ch>'9') ch=gc();
	while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+(ch^48),ch=gc();
	return x;
}
 
 //奇怪的缺省源
 
namespace Code{
	const int N=1e5+7;
	int R,C,n;	
	struct dot{int x,y;}wiki[N];
	inline bool cmp(dot a,dot b){return a.x==b.x?a.y<b.y:a.x<b.x;}
	struct box{
		int son[2];
		int pri,val,sz;
		int ans;
	}tr[N];
	int rt;
#define ls tr[x].son[0]
#define rs tr[x].son[1]
	inline int js(int r,int c){return r*((c*(c+1))>>1ll);}
	inline void pu(int x){
		tr[x].sz=1+tr[ls].sz+tr[rs].sz;
		tr[x].ans= tr[ls].ans+js(tr[x].pri-tr[ls].pri,tr[ls].sz);
		tr[x].ans+=tr[rs].ans+js(tr[x].pri-tr[rs].pri,tr[rs].sz);
		// if(x==2){cout<<tr[rs].sz<<"DEBUG\n";}
	}
	int build(int l,int r){
		if(l>r)return 0;
		int mid=(l+r)>>1;
		tr[mid].son[0]=build(l,mid-1);
		tr[mid].son[1]=build(mid+1,r);
		pu(mid);return mid;
	}
	void split(int x,int &l,int &r,int key){
		if(!x){l=r=0;return;}
		if(tr[x].val<=key)l=x,split(rs,tr[l].son[1],r,key),pu(l);
		else              r=x,split(ls,l,tr[r].son[0],key),pu(r);
	}
	void merge(int &x,int l,int r){
		if(!l||!r){x=l|r;return;}
		if(tr[l].pri>tr[r].pri)x=l,merge(rs,tr[l].son[1],r),pu(x);
		else                   x=r,merge(ls,l,tr[r].son[0]),pu(x);
	}
	void change(dot node){
		int l,tmp,r;
		split(rt,l,r,node.y),split(l,l,tmp,node.y-1);
		tr[tmp].pri=node.x;
		// cout<<node.y<<'C'<<node.x<<'\n';
		merge(l,l,tmp),merge(rt,l,r);
	}	
	// void Print()
	signed main(){
		R=read(),C=read(),n=read();
		REP(i,1,n)wiki[i].x=read(),wiki[i].y=read();
		sort(wiki+1,wiki+n+1,cmp);
		REP(i,1,C)tr[i].val=i,tr[i].pri=0,tr[i].sz=1,tr[i].ans=0;
		rt=build(1,C);
		register int tot=0,Ans=0;
		REP(i,1,R){
			while(tot<n&&wiki[tot+1].x==i)change(wiki[tot+1]),++tot;
			Ans+=tr[rt].ans+js(i-tr[rt].pri,tr[rt].sz);
			// cout<<i<<":"<<rt<<' '<<tr[rt].ans<<' '<<js(i-tr[rt].pri,tr[rt].sz)<<'\n';
			// int x=rt;
			// cout<<"mmp:"<<tr[ls].sz<<' '<<tr[rs].sz<<' '<<js(tr[x].pri-tr[rs].pri,tr[rs].sz)<<'\n';
		}
		cout<<((R*(R+1)>>1ll)*(C*(C+1)>>1ll))-Ans<<'\n';
		return 0;
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	Code::main();
	return 0;
}
```


---

## 作者：ButterflyDew (赞：13)

欢迎来博客阅读 [Dew~](https://www.cnblogs.com/ppprseter/p/9536806.html)

我们首先弄清楚我们咋统计的

先把矩形蓝白出来

![](http://m.qpic.cn/psb?/V14VFGnz4fbJRr/.oJBgY1D2z8TiTAK3qsETZwermJTc9S2knzY.rrwDa8!/b/dDUBAAAAAAAA&bo=jwKlAY8CpQEDCSw!&rf=viewer_4)

然后我们对矩形固定一个下边界，设为$down$

然后我们枚举所取矩形的左边界与右边界

如何不重不漏的把所有可行上边界统计呢？

![](http://m.qpic.cn/psb?/V14VFGnz4fbJRr/BesSo3e*PU81v3FEWWMQ3lMRrPOMZWF9xI8apc*kdds!/b/dEQBAAAAAAAA&bo=2wKxAdsCsQEDGTw!&rf=viewer_4)

比方说，黑线是矩形下边界，左右边界现在是任意枚举的，那么红色箭头范围内就是上边界可取的集合了

我们发现，上边界的最下取值点与最低的那个点相连

那么我们可以枚举每个左右边界，然后找到最低的那个点，我们就得到了一个~~优秀~~的$O(N^4)$的解法辣

注：这里把矩形规模称作$N$，把点的个数称作$K$

取最低点的优化很容易搞成$O(N^3)$的，然而这样布星。

------------
我们像CDQ分治那样进行统计

具体的，对每一个固定的下边界，每一列都有唯一确定的最低的点

我们以第$x$列的$x$为二叉排序树的关键字，以那个最低的点的行数$y$为大根堆的关键字，建立一颗$treap$

在统计每一个固定的下边界时，每个点的贡献都是 (左儿子大小+1)$\times$ (右儿子大小+1) $\times$ 堆的关键字

表示，左边区间可取集合，右边区间可取集合和上边界可取集合

当然堆值可能会变，我们需要在改变的时候进行调整

这时候一个很显然的$O(N^2)$做法就有了

我们改完一行去遍历整棵树就可以了。

至于修改的复杂度，因为数据随机，可以看做是$O(KlogN)$的

如果我们对每个点维护它及它儿子的贡献，每次改的时候就只需要查询根节点就行辣

复杂度：$O(KlogN)$(数据随机)

------------
**Code:**
```cpp
#include <cstdio>
#include <algorithm>
#define ls ch[now][0]
#define rs ch[now][1]
#define fa par[now]
#define ll long long
const int N=1e5+10;
const int M=4e4+10;
int n,m,k;
std::pair <int,int > dx[N];
ll sum[M],dat[M],siz[M],ans;int ch[M][2],par[M],root;
int build(int l,int r)
{
    if(l>r) return 0;
    if(l==r) {siz[l]=1;return l;}
    int now=l+r>>1;
    ls=build(l,now-1);
    if(ls) par[ls]=now;
    rs=build(now+1,r);
    if(rs) par[rs]=now;
    siz[now]=siz[ls]+siz[rs]+1;
    return now;
}
void updata(int now)
{
    sum[now]=dat[now]*(siz[ls]+1ll)*(siz[rs]+1ll)+sum[ls]+sum[rs];
    siz[now]=siz[ls]+siz[rs]+1;
}
int identity(int now){return ch[fa][1]==now;}
void connect(int f,int now,int typ){fa=f;ch[f][typ]=now;}
void Rotate(int now)
{
    int p=fa,typ=identity(now);
    if(p==root) root=now;
    connect(p,ch[now][typ^1],typ);
    connect(par[p],now,identity(p));
    connect(now,p,typ^1);
    updata(p),updata(now);
}
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    root=build(1,m);
    for(int i=1;i<=k;i++)
        scanf("%d%d",&dx[i].first,&dx[i].second);
    std::sort(dx+1,dx+1+k);
    int las=1;dat[0]=n+1;
    for(int i=1;i<=k;i++)
    {
        while(las!=dx[i].first)
            ans+=sum[root],++las;
        int now=dx[i].second;
        dat[now]=dx[i].first;
        while(dat[fa]<dat[now])
            Rotate(now);
        while(now) updata(now),now=fa;
    }
    while(las<=n)
        ans+=sum[root],++las;
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：wjyyy (赞：9)

## 前言：

   上来一看，这不是要先$C\times R$处理一下吗，于是看到了数据范围![](http://www.wjyyy.top/wp-content/uploads/2018/07/20170701215640_mRLKu.thumb_.700_0-e1530920143970.jpeg)

   遍历一遍都不让怎么瞎搞。。。不过N是100000+随机数据emmm
   
   感谢写出让我看得懂得题解的[xyz32768](https://blog.csdn.net/xyz32768/article/details/80457425)
   
   以及我的博客[传送门](http://www.wjyyy.top/763.html)

## 题解：

   统计有一个资源点的矩形个数，感觉一时半会推不出公式。于是了解了**补集转换**，就是用所有矩形个数减去没有资源点的个数，貌似有点像[**Vijos 1225 月饼盒**](https://vijos.org/p/1255)，不过还是不好想。**先看怎么统计所有矩形的个数**：因为矩形是由线段×线段得到的，所以用横线段个数乘上纵线段个数，就是矩形个数。长度为1的横线段有$C$条，长度为2的横线段有$C-1$条，……，长度为$C$的线段有1条，同理长度为1的纵线段有$R$条等等。因此横线段的个数为$\frac{C(C+1)}2$，纵线段的个数为$\frac{R(R+1)}2$，相乘就得到了$\frac{C(C+1)R(R+1)}4$个矩形，乘开之后，发现要开**long long**（不开long long 是有10分的）。



   这个题要推导的数学公式很多，因为我们仍然要计算**空矩形**个数。

   接着看怎么统计空矩形个数，根据样例，第一行是这样的（O表示空点，X表示有资源）

```cpp
OXOOO
```
   图中共有7个空矩形，左边的一个O贡献了1个，右边的3个O贡献了6个。计算方式就是对每一个**纵向连续最长的O**，用它及它左边**连续纵向 _不比它短_ 的O**的个数乘上它及它右边**连续纵向比它长的O**的个数，就不会冲突了。也就是1×1+1×1+2×1+3×1=7。那如果矩形的宽大于1怎么处理？一样地，我们仍然可以这样计算，举个例子：
```cpp
OXOOO
OOXOO
```
   对于第二行最左边一个O，如果我们同样计算，它**所贡献**的矩形有2(高度)×1(左边)×1(右边)=2个（以此类推纵向高度为k的矩形**新**贡献的矩形有k个），第二个O贡献了1×2×1=2个，第四个O贡献了2×1×1=2个，第五个贡献了2×2×1=4个。则第二行一共有8个空矩形。

   如何维护并尽快计算这个结果呢？因为**数据随机**，对于第i列到此连续O的个数，用t[i]来表示，把i的序号用Treap维护（随机时Treap的深度有保证），再用t[i]来维护Treap。在Treap上，有BST的性质，所以与某个位置相邻的且比它短的点，都在它的左右孩子处；因为每向下扩展一行就会使很多个t[i]自增1，所以我们维护t[i]保存的是第i列以当前行位置从下往上数第一个X在哪一行，每次处理用当前行数减去t[i]就是**新贡献**矩形个数。那么这样我们按t[i]维护一个大根堆，这样一来，上面的**连续纵向比它长**的就分别是左右孩子的数量+1了。新增矩形个数$=(sz[ls]+1)(sz[rs]+1)$，Treap每次旋转也要维护这个值。

   **构建Treap：**一开始所有点的权值都为0，我们直接按照BST构建就可以了，每次取中点，左右区间作为左右孩子，递归建树。

   Treap里要存$t[i]×(sz[i_{ls}]+1)(sz[i_{rs}]+1)$、子树中这个数据的和以及基础的BST信息。因为没学过Treap，我的Treap是按splay风格写的，不要太介意。

#### 平衡树多maintain总没有错。

   时间复杂度：$O(C+R+N\log C)$
   
## Code：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define mid (l+r>>1)
int r,c,n;
struct node
{
    int key,v;//关键字 维护值
    long long sz,ans,anstt;//子树大小 乘积(v与sz) 乘积之和 v之和
    long long sztt;
    node *s[2];
    node(int key,int v)
    {
        this->key=key;
        this->v=v;
        sz=1;
        sztt=1;
        ans=0;
        anstt=0;
        s[0]=NULL;
        s[1]=NULL;
    }
    node()
    {
        v=0;
        sz=1;
        sztt=1;
        ans=1;
        anstt=0;
        s[0]=NULL;
        s[1]=NULL;
    }
    long long getsz()//访问节点大小
    {
        if(!this)
            return 0;
        return sz;
    }
    long long getsztt()
    {
        if(!this)
            return 0;
        return sztt;
    }
    long long getanstt()
    {
        if(!this)
            return 0;
        return anstt;
    }
    long long getd(int x)//询问方向
    {
        if(x==key)
            return -1;
        return x>key;
    }
    long long getv()//访问维护值
    {
        if(!this)
            return -1;
        return v;
    }
    void maintain()
    {
        sz=s[0]->getsz()+s[1]->getsz()+1;
        sztt=(s[0]->getsz()+1)*(s[1]->getsz()+1)+s[0]->getsztt()+s[1]->getsztt();
        ans=v*(s[0]->getsz()+1)*(s[1]->getsz()+1);
        anstt=ans+s[0]->getanstt()+s[1]->getanstt();
    }
}*root=NULL;
void build(node *&rt,int l,int r)
{
    rt=new node(mid,0);
    if(l==r)
        return;
    if(mid>l)
        build(rt->s[0],l,mid-1);
    if(mid<r)
        build(rt->s[1],mid+1,r);
    rt->maintain();
    return;
}
void Rotate(node *&rt,int d)
{
    node *tmp=rt->s[d];
    rt->s[d]=tmp->s[d^1];
    tmp->s[d^1]=rt;
    rt->maintain();
    rt=tmp;
    rt->maintain();
    return;
}
void treap(node *&rt)
{
    //大根堆
    if(rt->v>rt->s[0]->getv()&&rt->v>rt->s[1]->getv())
        return;
    if(rt->s[0]->getv()>rt->s[1]->getv())//把左孩子拉上来
    {
        Rotate(rt,0);
        treap(rt->s[1]);
    }
    else
    {
        Rotate(rt,1);
        treap(rt->s[0]);
    }
    rt->maintain();
}
void change(node *&rt,int t,int x)//把t改为x
{
    int d=rt->getd(t);
    if(d==-1)
    {
        rt->v=x;//可能有问题
        rt->maintain();
        treap(rt);
        rt->maintain();
        return;
    }
    change(rt->s[d],t,x);
    treap(rt);
    rt->maintain();
}
struct pnt
{
    int x,y;//行 列数
    friend bool operator <(pnt a,pnt b)
    {
        if(a.x!=b.x)
            return a.x<b.x;
        return a.y<b.y;
    }
}p[101000];
int main()
{
    scanf("%d%d%d",&r,&c,&n);//r行c列
    build(root,1,c);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&p[i].x,&p[i].y);
    std::sort(p+1,p+1+n);
    int cur=1;
    long long sum=(long long)((r+1)*r/2)*((c+1)*c/2);
    for(int i=1;i<=r;i++)
    {
        while(p[cur].x==i)
        {
            change(root,p[cur].y,i);
            cur++;
        }
        sum-=i*(root->sztt)-root->anstt;
    }
    printf("%lld\n",sum);
    return 0;
}
```

---

## 作者：feecle6418 (赞：7)

这道题用 FHQ Treap 真的很好写，随便怎么写都超不过 1.5kb：跟楼下几位大佬的比起来真的短多了。

从上到下扫描，则每列上面最近的关键点的行数构成一个长度为 $C$ 的序列。我们用 FHQ Treap 维护这个序列的笛卡尔树（也就是以下标为排序二叉树，值为大跟堆的 Treap），需要支持：修改一个数的权值；询问 $\sum rnk_i(s_{l_i}+1)(s_{r_i}+1)$。

FHQ Treap 如何修改呢？按照**权值**分裂，把下标 $<x$ 的分出来，在第二棵树中的权值最小点就是第 $x$ 项，直接修改就行。

代码如下。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> pr;
int c[100005][2],s[100005],v[100005],rnk[100005],R,C,n,root,tot;
ll sum[100005],ans=0;
vector<int> t[100005];
void Pushup(int p){
	s[p]=s[c[p][0]]+s[c[p][1]]+1;
	sum[p]=sum[c[p][0]]+sum[c[p][1]]+1ll*(s[c[p][0]]+1)*(s[c[p][1]]+1)*rnk[p];
}
int Build(int l,int r){
	if(l>r)return 0;
	if(l==r)return s[l]=1,v[l]=l,l;
	int m=(l+r)/2;
	v[m]=m,c[m][0]=Build(l,m-1),c[m][1]=Build(m+1,r);
	return Pushup(m),m;
}
pr Split(int now,int k) {//权值<k的
	if(!now)return make_pair(0,0);
	if(v[now]>=k) {
		pr t=Split(c[now][0],k);
		c[now][0]=t.second;
		Pushup(now);
		return make_pair(t.first,now);
	} else {
		pr t=Split(c[now][1],k);
		c[now][1]=t.first;
		Pushup(now);
		return make_pair(now,t.second);
	}
}
int Merge(int x,int y) {
	if(!x||!y)return x+y;
	if(rnk[x]>rnk[y])return c[x][1]=Merge(c[x][1],y),Pushup(x),x;
	else return c[y][0]=Merge(x,c[y][0]),Pushup(y),y;
}
void Insert(int x,int r){
	pr t=Split(root,x),t2=Split(t.second,x+1);
	rnk[t2.first]=r,Pushup(t2.first);
	root=Merge(t.first,Merge(t2.first,t2.second));
}
int main(){
	cin>>R>>C>>n;
	for(int i=1,x,y;i<=n;i++)cin>>x>>y,t[x].push_back(y);
	root=Build(1,C),tot=C;
	for(int i=1;i<=R;i++){
		for(int j:t[i])Insert(j,i);
		ans+=1ll*i*C*(C+1)/2-sum[root];
	}
	cout<<1ll*R*(R+1)/2*C*(C+1)/2-ans;
}
```

---

## 作者：leozhang (赞：4)

更好的阅读体验看[这里](https://www.cnblogs.com/zhangleo/p/11083820.html)

首先考虑容斥

我们计算出所有没有点在其中的矩形，然后用所有矩形减去这些矩形即可

然后考虑如何计算没有点在其中的矩形

采用扫描线的思想，从上向下一行一行扫，假设我们扫到的行编号是$a$，然后考虑如果左右的列端点是$[l,r]$，那么这一行向上至多能扩展几个矩形呢？

显然，我们要找到区间$[l,r]$中位置最下面的那个点，设其行编号为$w[i]$，那么矩形数量即为$a-w[i]$

很清楚的就能看到，现在扫到的是红色的$a$，左右区间是蓝色的$[l,r]$，那么上界会被限制在$w[i]$这条黄线处，能向上延伸的矩形数量也就是$a-w[i]$

由于$a$是定值，因此我们考虑每个$w[i]$会对多少个区间$[l,r]$产生贡献

显然，$w[i]$必须是区间$[l,r]$中的最大值！

因此扫到每一个$a$，答案就变成了$\frac{c(c+1)}{2}a-\sum_{i=1}^{c}\sum_{j=i}^{c}max(i,j)$，其中$max(i,j)$表示区间$[i,j]$中最大的$w$

这个看着可以用单调栈维护维护嘛...

可是我们每次向下扫描的时候，$w$都会改变！

因此我们需要一个能够支持修改的数据结构，显然是一种二叉树

这个二叉树需要支持修改，最好能保证是一个大根堆，而且还要保证中序遍历得到的是原序列

这个...有点难？

treap嘛！

把序列的下标扔进二叉搜索树里，再把$w$作为权值体现堆的性质就可以了嘛

（其实就是把原来随机的一个权值变成了一个$w$）

由于数据随机，所以可以通过

这样每个点的贡献就是$(siz[lson]+1)(siz[rson]+1)w$

注意在修改时如果先删除再重新插入会T，考虑到每次修改权值只增不减，因此每个节点只会向上转，因此我们直接修改即可

代码：

```cpp
#include <cstdio>
#include <algorithm>
#define ll unsigned long long
#define ls tree[rt].lson
#define rs tree[rt].rson
using namespace std;
struct Treap
{
	int lson,rson;
	int size,val;
	int rank;
	ll sum;
}tree[300005];
struct POS
{
	int x,y;
	friend bool operator < (POS a,POS b)
	{
		return a.x<b.x;
	}
}p[100005];
int tot=0;
int rot;
ll sum=0;
int r,c,n;
inline void update(const int &rt)
{
	tree[rt].size=tree[ls].size+tree[rs].size+1;
	tree[rt].sum=1ll*(tree[ls].size+1)*1ll*(tree[rs].size+1)*tree[rt].rank+tree[ls].sum+tree[rs].sum;
}
inline void lturn(int &rt)
{
	int temp=rs;
	rs=tree[temp].lson;
	tree[temp].lson=rt;
	tree[temp].size=tree[rt].size;
	update(rt);
	rt=temp;
}
inline void rturn(int &rt)
{
	int temp=ls;
	ls=tree[temp].rson;
	tree[temp].rson=rt;
	tree[temp].size=tree[rt].size;
	update(rt);
	rt=temp;
}
void buildtree(int &rt,int l,int r)
{
	rt=++tot;
	if(l==r){tree[rt].val=l,tree[rt].size=1;return;}
	int mid=(l+r)>>1;
	tree[rt].val=mid;
	if(l<mid)buildtree(ls,l,mid-1);
	if(r>mid)buildtree(rs,mid+1,r);
	update(rt);
}
void ins(int &rt,int v,int w)
{
	if(!rt)return;
	if(tree[rt].val==v)
	{
		tree[rt].rank=w;
		update(rt);
		return;
	}
	if(v<tree[rt].val)
	{
		ins(ls,v,w);
		if(tree[ls].rank>tree[rt].rank)rturn(rt);
	}else
	{
		ins(rs,v,w);
		if(tree[rs].rank>tree[rt].rank)lturn(rt);
	}
	update(rt);
}
inline int read()
{
	int f=1,x=0;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int main()
{
	r=read(),c=read(),n=read();
	for(register int i=1;i<=n;++i)p[i].x=read(),p[i].y=read();//以行编号记录下列编号
	buildtree(rot,1,c);
	ll ans=0;
	sort(p+1,p+n+1);
	int las=1;
	for(register int i=1;i<=r;++i)//枚举每一行
	{
		while(p[las].x==i&&las<=n)ins(rot,p[las].y,i),las++;//del(rot,p[las].y),ins(rot,p[las].y,i),las++;
		ans+=c*(c+1)/2*1ll*i-tree[rot].sum;
	}
	printf("%llu\n",c*(c+1)/2ll*1ll*r*(r+1)/2ll-ans);
	return 0;
}
```


---

## 作者：fanypcd (赞：3)

看了几篇题解，始终不理解补集转化的意义在何。

总得有篇题解带着点图照顾一下我这种 7s 记忆的萌新吧。。。

直接求满足条件的矩形个数。

---

扫描线，核心思想在于对二维的操作、询问转化为一维暴力枚举，另一维用数据结构维护截面序列。[不会的出门左转](https://oi-wiki.org/geometry/scanning/)。

![](https://cdn.luogu.com.cn/upload/image_hosting/ey6zw8vn.png)

如图，黑点是资源点，底部一行是当前扫描线的位置。

考虑如何计算**底部在黄色部分**，至少包含一个黑点的矩形个数。

定义每个合法矩形的特征点为最靠下的黑点（同时存在多个特征点的情况最后说）。

我们需要设计一个统计方法，使得每个矩形只会被它的特征点统计到。

如图，有哪些矩形的特征点是右下方的黑点呢？（设黑点坐标 $x_i,y_i$,矩形左下，右上顶点坐标分别为 $(l,d),(r,u)$），则当且仅当 $l \leq x_i \And x_i \leq r \And u \leq y_i$。（左下点必定在黄色部分）

这样就有 $y_i \times (x_i+1) \times(C - x_i + 1)$ 种不同的矩形。

然后对于左上方的黑点，显然它对应的矩形的右上角不能取到蓝色部分及其右边。

由此想到用 [treap](https://oi-wiki.org/ds/treap/) 维护序列，（每个位置的随机标号取这一列最下方黑点的 $y$ 坐标，值则维护位置下标，这样的话答案就是 $\sum rnd_i \times (size_{lc}+1) \times(size_{rc} + 1)$）。

至于特征点存在多个的情况，在 treap 中总会分出个先后次序，所以不会算重。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
template <class T> inline void read(T &x) {
	x = 0;
	int f = 0;
	char ch = getchar();
	while(ch < '0' || ch > '9') {
		f |= ch == '-';
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9') {
		x = x * 10 + (ch - 48);
		ch = getchar();
	}
	x = f ? -x : x;
	return;
}
#define ll long long
#define fir first
#define sec second
#define N 50005
int ch[N][2], val[N], rnd[N], siz[N], root; ll sum[N];
void pushup(int x) {
	siz[x] = siz[ch[x][0]] + siz[ch[x][1]] + 1;
	sum[x] = sum[ch[x][0]] + sum[ch[x][1]];
	sum[x] += 1ll * rnd[x] * (siz[ch[x][0]] + 1) * (siz[ch[x][1]] + 1);
	return;
}
int build(int l, int r) {
	if(l > r) return 0;
	if(l == r) {siz[l] = 1; val[l] = l; return l;}
	int mid = (l + r) >> 1;
	ch[mid][0] = build(l, mid - 1);
	ch[mid][1] = build(mid + 1, r);
	val[mid] = mid;	pushup(mid); return mid;
}
int merge(int x, int y) {
	if(!x || !y) return x + y;
	if(rnd[x] > rnd[y]) {
		ch[x][1] = merge(ch[x][1], y);
		pushup(x); return x;
	}
	else {
		ch[y][0] = merge(x, ch[y][0]);
		pushup(y); return y;
	}
	return 114514;
}
void split(int rt, int v, int &x, int &y) {
	if(!rt) {x = y = 0; return;}
	if(val[rt] <= v) x = rt, split(ch[rt][1], v, ch[rt][1], y);
	else y = rt, split(ch[rt][0], v, x, ch[rt][0]);
	pushup(rt); return;
}
void update(int pos, int v) {
	int x, y, z;
	split(root, pos, x, y);
	split(x, pos - 1, x, z);
	rnd[z] = v;	root = merge(merge(x, z), y);
	return;
}
int R, C, n;
vector<int> tmp[N];
signed main() {
	read(R), read(C), read(n);
	int x, y; for(int i = 1; i <= n; i++)
		read(x), read(y), tmp[x].emplace_back(y);
	root = build(1, C); ll ans = 0;
	for(int i = 1; i <= R; i++) {
		for(auto x : tmp[i]) update(x, i);
		ans += sum[root];
	}
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：lgswdn_SA (赞：3)

首先补集转换一下，算出有多少个区域没有资源点。这类问题有一个类似的方法：扫描线。考虑从上往下扫，然后维护一些东西。本题可以维护一个序列 $S_{p}$ 表示每一列的比 $i$ 小的最靠近 $i$ 的资源点的纵坐标。设 $M_p(a,b)$ 表示 $[a,b]$ 区间 $S_p$ 的最大值，则有每条扫描线的贡献为 $\sum_{i,j\in[1,c],i\le j} p-M_p(i,j)=\frac{c(c+1)}{2}p-\sum M[i,j]$。

考虑对每个 $S_{p,i}$ 计算贡献。即对于每个横坐标，计算它能作为最大值的最大区间长度。这可以用笛卡尔树去做。

考虑维护这个 $S_p$ 的笛卡尔树（横坐标为树的关键词 $v$，纵坐标（$S$）为堆的关键词 $w$）。笛卡尔树的左节点代表左区间不大于这个节点的最大节点。利用这个性质，我们得知对于每个 $S_p$，其贡献为 $\frac{c(c+1)}{2}p-\sum_u w_u(s_{l_u}+1)(s_{r_u}+1)$。然后维护笛卡尔树用 treap 即可（因为要单点的修改）。因为数据随机所以复杂度正确。

所以我们每个节点都维护一下这个即可。

用的 FHQ Treap。

注意一开始的 build 一定要用类似线段树的结构，否则复杂度是不对的（可以想象一下如果直接插入直接退化成链）。

```cpp
#include<bits/stdc++.h>
#define int long long
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int N=1e5+9,inf=(1<<30);
typedef pair<int,int>pii;

inline long long read() {
	long long res=0, w=1; char c=getchar();
	while(!isdigit(c)) {if(c=='-') w=-1; c=getchar();}
	while(isdigit(c)) {res=res*10+c-48; c=getchar();}
	return res*w;
}

namespace treap {
	int ls[N],rs[N],sz[N],v[N],w[N],val[N],tot,root;
	int nww(int vv,int ww) {return sz[++tot]=1,v[tot]=vv,w[tot]=val[tot]=ww,tot;}
	void upd(int x) {sz[x]=sz[ls[x]]+sz[rs[x]]+1, val[x]=val[ls[x]]+val[rs[x]]+w[x]*(sz[ls[x]]+1)*(sz[rs[x]]+1);}
	int build(int l,int r) {
		if(l>r) return 0;
		else if(l==r) return sz[l]=1,v[l]=l,l;
		else {
			int m=(l+r)/2;
			ls[m]=build(l,m-1), rs[m]=build(m+1,r), sz[m]=sz[ls[m]]+sz[rs[m]]+1, v[m]=m;
			return m;
		}
	}
	int merge(int x,int y) {
		if(!x||!y) return x+y;
		else if(w[x]>w[y]) return rs[x]=merge(rs[x],y), upd(x), x;
		else return ls[y]=merge(x,ls[y]), upd(y), y;
	}
	void split(int x,int val,int &l,int &r) {
		if(!x) {l=r=0; return;}
		else if(v[x]<=val) l=x, split(rs[x],val,rs[x],r);
		else r=x, split(ls[x],val,l,ls[x]);
		upd(x);
	}
	void mdf(int val,int nw) {
		int x,y,x1,x2; split(root,val,x,y), split(x,val-1,x1,x2);
		w[x2]=nw, root=merge(merge(x1,x2),y);
	}
	int qry() {return val[root];}
}
using namespace treap;

int r,c,n,ans;
vector<int>t[N];

signed main() {
	r=read(), c=read(), n=read();
	rep(i,1,n) {
		int x=read(), y=read();
		t[x].push_back(y);
	}
	root=build(1,c);
	rep(i,1,r) {
		for(auto y:t[i]) mdf(y,i);
		ans+=c*(c+1)/2*i-qry();
	}
	ans=c*(c+1)/2*r*(r+1)/2-ans;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：_ZML_ (赞：2)

# 思路

算至少有一个点的矩形可以转化成所有矩形减去没有任何点的矩形。

接下来问题转化成算没有任何点的矩形。

考虑扫描线，我们从上往下扫，每个矩形的下边界一定贴着扫描线。

我们接下来所说的坐标为从左到右第 $x$ 行，从上到下第 $y$ 列。

设 $p_i$ 为第 $i$ 列离扫描线最近的点的横坐标（一定是扫过的点）。

如图，蓝色点是 $p_i$ 的位置， 红色点是扫描线。

![无标题](https://cdn.luogu.com.cn/upload/image_hosting/pl5wzmvt.png)

如何不重不漏的数出所有长方形？

这让我想起了一道笛卡尔树经典题 [Largest Rectangle in a Histogram](https://www.luogu.com.cn/problem/SP1805)，不过用单调栈也能做。

我们对点 $(i，p_i)$ 建笛卡尔树，$i$ 为键值，$p_i$ 为堆值，大根堆。

![无标题11](https://cdn.luogu.com.cn/upload/image_hosting/nm8o1cug.png)

如何用这棵笛卡尔算出所有长方形？

设 $h$ 为扫描线，纵坐标先抛出结论：

$$
Ans = \Sigma _ i {(h - p_i)\times(size_{ls}+1) \times (size_{rs} + 1)}
$$

对着图看应该就懂了。

这个笛卡尔树可以用 `FHQ Treap` 维护，`Treap` 本来就是笛卡尔树的一种，由于坐标随机所以树高期望为 $\log(n)$

# 细节

初始建一个全为零的笛卡尔树。

从上往下扫，先修改再查询。

维护两个值 $sum1 = \Sigma_i{ (size_{ls}+1) \times (size_{rs} + 1)},sum2 = \Sigma_i{ p_i \times (size_{ls}+1) \times (size_{rs} + 1)}$

$Ans = sum1 \times h -sum2$

剩下的看代码吧

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn = 1e5 + 10;
int r, c, n;
int ch[maxn][2], pri[maxn], sze[maxn], val[maxn], rt, cnt;
int sum1[maxn], sum2[maxn];
vector<int> v[maxn];
int newnode(int x, int y) {
	cnt++;
	val[cnt] = x, pri[cnt] = y;
	sze[cnt] = 1;
	return cnt;
}
void update(int x) {
	int res = (sze[ch[x][0]] + 1) * (sze[ch[x][1]] + 1);
	sum1[x] = sum1[ch[x][0]] + sum1[ch[x][1]] + res;
	sum2[x] = pri[x] * res + sum2[ch[x][0]] + sum2[ch[x][1]];
	sze[x] = sze[ch[x][0]] + sze[ch[x][1]] + 1;
}
int merge(int x, int y) {
	if(x == 0 || y == 0) return x + y;
	if(pri[x] > pri[y]) {
		ch[x][1] = merge(ch[x][1], y);
		update(x);
		return x;
	} 
	else {
		ch[y][0] = merge(x, ch[y][0]);
		update(y);
		return y;
	} 
}

void split(int u, int k, int &L, int &R) {
	if(!u) {
		L = R = 0;
		return;
	}
	if(sze[ch[u][0]] + 1 <= k) {
		L = u;
		split(ch[u][1], k - sze[ch[u][0]] - 1, ch[u][1], R);
	}
	else {
		R = u;
		split(ch[u][0], k, L, ch[u][0]);
	}
	update(u);
}

void print(int x) {
	if(!x) return;
	print(ch[x][0]);
	print(ch[x][1]);
}
signed main() {
	cin >> r >> c >> n;
	for(int i = 1; i <= n; i++) {
		int x, y; cin >> x >> y;
		v[x].push_back(y);
	}
	for(int i = 0; i <= c; i++) {
		rt = merge(rt, newnode(i, 0));
	}
	int ans = 0;
	for(int i = 1; i <= r; i++) {
		for(auto t : v[i]) {
			int L = 0, R = 0, p = 0;
			split(rt, t + 1, L, R);
			split(L, t, L, p);
			pri[p] = i;
			rt = merge(merge(L, p), R);
		}
		int L = 0, p = 0;
		split(rt, 1, L, p);
		ans += sum1[p] * i;
		ans -= sum2[p];
		rt = merge(L, p);
	}
	ans = (r * (r + 1)) * (c * (c + 1)) / 4 - ans;	
	cout << ans;
	return 0;
} 
```

---

## 作者：Link_Cut_qwq (赞：2)

首先答案等于所有矩形的个数减去里面没有资源点的矩形的个数，前者较为简单，考虑求出后者。

我们考虑求出以每条线 $y ∈ [1, c]$ 为顶边的合法矩形的数量，于是维护一条扫描线从下往上扫。扫描过程中维护一棵线段树，每个节点 $[L,R]$，设 $mid$ 为其断点，保存左侧边界位于 $[L, mid]$，右侧边界位于 $[mid + 1, R]$，顶边为当前扫描线的合法矩形的数量。

我们对 $x$ 坐标在 $[L, mid]$ 侧的资源点按照其 $x$ 坐标维护递减的单调栈，$[mid + 1, R]$ 侧的资源点按照其 $x$ 坐标维护递增的单调栈。

我们遇到一个资源点时，就在线段树中加入它，即按照 $x$ 坐标加入到每层节点对应的单调栈中。删除或加入一个点时，需将其对答案的贡献减掉或加上。以加入节点为例，设其 $y$ 坐标为 $y1$，栈顶节点 $y$ 坐标为 $y2$，贡献为**当前节点保存的点中**底边 $y$ 坐标在 $(y2, y1]$ 之间的合法矩形数量。我们可以对单调栈维护前缀求解，具体地（以右侧单调栈为例），对于每个点 $(x1, y1)$，其单调栈前侧的点 $(x2, y2)$，维护 $(x1 - mid) \times (y1 - y2)$ 的前缀和。当左侧加入点时，对于加入的点和栈顶结点在右侧栈中二分并前缀和做差即可得到贡献，删除也差不多。

当扫描线高度由 $y - 1$ 增加为 $y$ 时，需要将每个节点 $[L, R]$ 的答案加上 $(mid - L + 1) \times (R - mid)$ 并在左侧栈中加入一个点 $(L - 1, y)$ 和在右侧加入 $(R + 1, y)$。但我们不能每个节点一一操作，可以当我们访问到该节点时再加，可以记录该节点上次被访问是什么时候，再把这些次的一并操作。同时我们还需得到线段树上每个节点的答案的和，我们可以在根处维护一个子树的总和，然后从下向上完成转移即可。

每个点只会在每层的单调栈中入栈一次，所以总共入栈次数为 $O(n\log R)$，每次出入栈都需要二分，因此总复杂度 $O(n\log^2 R)$。因为每个节点的栈中节点的 $x$ 坐标不会重复，因此空间复杂度 $O(R \log R)$。该做法不需要数据随机。

code:

```cpp
#include <bits/stdc++.h>
#define ls (u << 1)
#define rs (u << 1 | 1)
using namespace std;

typedef long long LL;

const int N = 100010;
const int M = 40040;

struct Node {int x, y;} a[N];

struct node {LL x, y, sum;};

struct Tree {
    node *vl, *vr;
    LL x, sum, lst, tl, tr;

    LL qryr(int d, LL m) {
        if (d > lst) return 0;
        int l = 1, r = tr;
        while (l <= r) {
            int mid = l + r >> 1;
            if (vr[mid].y >= d) r = mid - 1;
            else l = mid + 1;
        }
        return vr[tr].sum - vr[l].sum + 
        (vr[l].y - d + 1) * (vr[l].x - 1 - m);
    }

    LL qryl(int d, LL m) {
        if (d > lst) return 0;
        int l = 1, r = tl;
        while (l <= r) {
            int mid = l + r >> 1;
            if (vl[mid].y >= d) r = mid - 1;
            else l = mid + 1;
        }
        return vl[tl].sum - vl[l].sum + 
        (vl[l].y - d + 1) * (m - vl[l].x);
    }
} t[M << 2];

int n;
LL R, C, ans;

bool cmp(Node x, Node y) {return x.y < y.y;}

void build(int u, int L, int R) {
    if (L == R) {
        t[u].vl = new node[5]();
        t[u].vr = new node[5]();
        return;
    }
    int mid = L + R >> 1;
    build(ls, L, mid); build(rs, mid + 1, R);
    t[u].vl = new node[mid - L + 1 + 5]();
    t[u].vr = new node[R - mid + 5]();
    t[u].vl[++t[u].tl] = {mid, 0, 0};
    t[u].vr[++t[u].tr] = {mid + 1, 0, 0};
}

void update(int u, LL L, LL R, LL x, LL y) {
    if (L == R) {
        if (L != x) t[u].x += y - t[u].lst, t[u].sum += y - t[u].lst;
        else t[u].x = 0, t[u].sum = 0;
        t[u].lst = y; return;
    }
    LL mid = L + R >> 1;
    t[u].x += (y - t[u].lst) * (mid - L + 1) * (R - mid);
    t[u].sum += (R - L + 2) * (R - L + 1) / 2 * (y - t[u].lst);
    t[u].lst = y;
    if (L > x || R < x) return;
    update(ls, L, mid, x, y);
    update(rs, mid + 1, R, x, y);
    int lst = t[u].sum, lstx = t[u].x;
    if (t[u].vr[t[u].tr].y != y) {
        while (t[u].vr[t[u].tr].x == R + 1) t[u].tr--;
        t[u].vr[t[u].tr + 1] = {R + 1, y, t[u].vr[t[u].tr].sum + (R - mid) * (y - t[u].vr[t[u].tr].y)},
        t[u].tr++;
    }
    if (t[u].vl[t[u].tl].y != y) {
        while (t[u].vl[t[u].tl].x == L - 1) t[u].tl--;
        t[u].vl[t[u].tl + 1] = {L - 1, y, t[u].vl[t[u].tl].sum + (mid - L + 1) * (y - t[u].vl[t[u].tl].y)},
        t[u].tl++;
    }
    if (x <= mid) {
        if (t[u].vl[t[u].tl].y == y && t[u].vl[t[u].tl].x >= x) {
            t[u].sum = t[ls].sum + t[rs].sum + t[u].x;
            return;
        }
        while (t[u].tl >= 2 && t[u].vl[t[u].tl].x <= x) {
            t[u].x -= (t[u].qryr(t[u].vl[t[u].tl - 1].y + 1, mid) - t[u].qryr(t[u].vl[t[u].tl].y + 1, mid)) * (mid - t[u].vl[t[u].tl].x);
            t[u].tl--;
        }
        t[u].x += t[u].qryr(t[u].vl[t[u].tl].y + 1, mid) * (mid - x);
        t[u].vl[t[u].tl + 1] = {x, y, t[u].vl[t[u].tl].sum + (mid - x) * (y - t[u].vl[t[u].tl].y)};
        t[u].tl++;
    } else {
        if (t[u].vr[t[u].tr].y == y && t[u].vr[t[u].tr].x <= x) {
            t[u].sum = t[ls].sum + t[rs].sum + t[u].x;
            return;
        }
        while (t[u].tr >= 2 && t[u].vr[t[u].tr].x >= x) {
            t[u].x -= (t[u].qryl(t[u].vr[t[u].tr - 1].y + 1, mid) - t[u].qryl(t[u].vr[t[u].tr].y + 1, mid)) * (t[u].vr[t[u].tr].x - 1 - mid);
            t[u].tr--;
        }
        t[u].x += t[u].qryl(t[u].vr[t[u].tr].y + 1, mid) * (x - 1 - mid);
        t[u].vr[t[u].tr + 1] = {x, y, t[u].vr[t[u].tr].sum + (x - 1 - mid) * (y - t[u].vr[t[u].tr].y)};
        t[u].tr++;
    }
    t[u].sum = t[ls].sum + t[rs].sum + t[u].x;
}

int main() {
    cin >> R >> C >> n;
    for (int i = 1; i <= n; i++)
        scanf("%d%d", &a[i].x, &a[i].y);
    sort(a + 1, a + n + 1, cmp);
    build(1, 1, R);
    int now = 1;
    for (int i = 1; i <= C; i++) {
        while (a[now].y == i) update(1, 1, R, a[now].x, a[now].y), now++;
        ans += t[1].sum + (R + 1) * R / 2 * (i - t[1].lst);
    }
    cout << (R + 1) * R / 2 * (C + 1) * C / 2 - ans << endl;
    return 0;
}
```

---

## 作者：__ycx2010__ (赞：0)

### 思路

treap 的妙用。

从 1 到 C 扫描整个矩阵，若当前扫描到了第 i 行，设 $t_j (1\leq j\leq R)$ 为 $(i, j)$ 向上第一个资源点，即 $t_j = \max \\\{k | 1\leq k\leq i, (k, j) \in S\\\}$ (S 为资源点集合)。

若矩阵最底下一行为 i，最左段一列为 l，最右端一列为 r，则满足如上要求的合法矩阵个数为 $\max_{i\leq k\leq j} t_k$ 个。

用一颗 treap 维护 $t_i$，满足父节点的 $t$ 小于儿子节点，树的中序遍历为 $1$ 到 $n$ 的顺序排列。

重新按上述要求，则满足的合法矩阵个数表示为 $t_{lca(l, r)}$。

所以最底下一行为 i 的矩阵个数为 $\sum_{1\leq l\leq R}\sum_{1\leq r\leq R} t_{lca(l, r)}$。

若先枚举 $lca(l, r)$ 得到 $\sum_{1\leq k\leq R} t_k \times (siz_{ls_{k}} + 1) \times (siz_{rs_k} + 1)$，这个式子可以用平衡树维护。

由于点的位置随机，所以平衡树复杂度正确，为 $O(n\log n)$。

### 代码

这里使用 FHQ-Treap。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int N = 2e5 + 10;

class FHQ {
	protected :
		int root = 1, tot;
		int val[N], ls[N], rs[N], siz[N];
		ll w[N];
		int newnode(int x) {
			siz[++ tot] = 1, w[tot] = val[tot] = x;
			return tot;
		} void pushup(int x) {
			siz[x] = siz[ls[x]] + siz[rs[x]] + 1;
			w[x] = w[ls[x]] + w[rs[x]] + 1ll * val[x] * (siz[ls[x]] + 1) * (siz[rs[x]] + 1);
		} int merge(int x, int y) {
			if (!x || !y) return x | y;
			if (val[x] > val[y]) {rs[x] = merge(rs[x], y); pushup(x); return x;}
			else {ls[y] = merge(x, ls[y]); pushup(y); return y;}
		} void split(int x, int k, int &l, int &r) {
			if (!x) return l = r = 0, void();
			if (siz[ls[x]] + 1 <= k) {l = x; split(rs[x], k - siz[ls[x]] - 1, rs[x], r);}
			else {r = x; split(ls[x], k, l, ls[x]);}
			pushup(x);
		}
	public :
        int size() {return siz[root];}
        int build(int l, int r) {
            int t = newnode(0);
            int mid = l + r >> 1;
            if (l == r) return t;
            if (l > r) return 0;
            ls[t] = build(l, mid - 1), rs[t] = build(mid + 1, r);
            pushup(t);
            return t;
        } void modify(int x, int y) {
			int a, b, c;
			split(root, x, b, c);
			split(b, x - 1, a, b);
			root = merge(merge(a, newnode(y)), c);
		} ll query() {return w[root];}
} T;

int main() {
	int r, c, n;
	scanf("%d%d%d", &r, &c, &n);
	vector<vector<int>> g(r + 1);
	for (int i = 1; i <= n; i ++ ) {
		int x, y;
		scanf("%d%d", &x, &y);
		g[x].push_back(y);
	}
    T.build(1, c);
	ll ans = 0;
	for (int i = 1; i <= r; i ++ ) {
		for (int j : g[i]) T.modify(j, i);
		ans += T.query();
	}
	printf("%lld\n", ans);
	return 0;
}

```

---

## 作者：OIer_ACMer (赞：0)

~~当小蓝的好朋友真是命苦啊！~~

------------
## 警钟敲烂：
这道题除了涉及到了很基本的 splay 树知识，由于是统计有多少个区块有个资源点，所以也要用到扫描线的知识。

------------
## 大致思路：
首先，我们先输入每个资源点的坐标，接着，我们对这些坐标排序，因为我们要建立一颗 splay 树，**要根据一定的优先级顺序才能够构建**，所以根据 $x$ 坐标（或者 $y$ 坐标也行），之后，我们根据这种优先级将 $t$ 数组，也就是平衡树节点数组经行预处理，为后面的统计以及扫面线处理做准备。

接着，我们用一个循环遍历 $x$ 坐标（因为我们是以它来排序的）。然后，之后具体的函数操作如下：

1. 枚举下边界，考虑上面可行的范围，发现对于左右边界 $[l,r]$，可行的上边界是 $x \le \max{a_i}$，其中 $i$ 要满足 $i \ge l$ 且 $i \le r$，这也就是一个 $a_i$ 可以支配的范围是直到它左右边第一个比它大的区域，如果弄出 $a_i$ 的笛卡尔树来可以很快实现。

2. 要**支持动态插入的笛卡尔树**（这个东西显然不存在），转念一想，好像 treap 就是一个支持插入的笛卡尔树？然而，时间复杂度无法保满足题目要求。再一想，其实也可以，因为 treap 本来就是**随机** $data$ 数组（也就是记录资源点个数的数组）**值来做笛卡尔树的**，这里保证了数据随机，所以时间复杂度是 $O(n\log{c})$。

------------
## 代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
inline int read()
{
    register int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
const int N = 1e5 + 10;
struct node
{
    int x, y;
} a[N];
int r, c, n, t[N][2], siz[N], w[N], data[N], v[N], ans;
void pushup(int x)
{
    siz[x] = siz[t[x][0]] + siz[t[x][1]] + 1;
    w[x] = data[x] * (siz[t[x][0]] + 1) * (siz[t[x][1]] + 1);
    v[x] = w[x] + v[t[x][0]] + v[t[x][1]];
    return;
}
void zig(int &x) // 左旋
{
    int y = t[x][0];
    t[x][0] = t[y][1];
    t[y][1] = x;
    x = y;
    pushup(t[x][1]);
    pushup(x);
    return;
}
void zag(int &x) // 右旋
{
    int y = t[x][1];
    t[x][1] = t[y][0];
    t[y][0] = x;
    x = y;
    pushup(t[x][0]);
    pushup(x);
    return;
}
void change(int &x, int pos, int val)
{
    if (x == pos)
    {
        data[x] = val;
        pushup(x);
        return;
    }
    if (pos < x)
    {
        change(t[x][0], pos, val);
        if (data[t[x][0]] > data[x])
        {
            zig(x);
        }
    }
    else
    {
        change(t[x][1], pos, val);
        if (data[t[x][1]] > data[x])
        {
            zag(x);
        }
    }
    pushup(x);
    return;
}
bool cmp(node x, node y)
{
    return x.x < y.x;
}
signed main()
{
    r = read();
    c = read();
    n = read();
    for (int i = 1; i <= n; i++)
    {
        a[i].x = read();
        a[i].y = read();
    }
    for (int i = 1; i < c; i++)
    {
        t[i][1] = i + 1, siz[i] = c - i + 1;
    }
    sort(a + 1, a + 1 + n, cmp);
    int p = 1, rt = 1;
    siz[c] = 1;
    for (int i = 1; i <= r; i++)
    {
        while (p <= n && a[p].x <= i)
        {
            change(rt, a[p].y, a[p].x);
            p++;
        }
        ans += v[rt];
    }
    cout << ans;
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/121936926)

---


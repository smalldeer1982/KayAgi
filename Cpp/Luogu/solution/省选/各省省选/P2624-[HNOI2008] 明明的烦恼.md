# [HNOI2008] 明明的烦恼

## 题目背景

原 编译优化 参见P1792

## 题目描述

自从明明学了树的结构，就对奇怪的树产生了兴趣……

给出标号为 $1$ 到 $N$ 的点，以及某些点最终的度数，允许在任意两点间连边，可产生多少棵度数满足要求的树?

## 说明/提示

两棵树分别为 `1-2-3` 与 `1-3-2`。

## 样例 #1

### 输入

```
3
1
-1
-1```

### 输出

```
2```

# 题解

## 作者：EternalEpic (赞：4)

目前最优解，比第二名快一倍。

设有 $cnt$ 个点度数已知。

我们可以知道 $Prufer$ 序列中已经占有的位置数 $sum=\sum_{i=1}^{n}\left(deg_{i}-1\right)$ 

根据 $Cayley$ 公式和组合我们可以知道，这些有明确 $deg$ 的点的排列方案数为 
$$
C_{n-2}^{s u m} \times \frac{s u m !}{\prod_{i=1}^{c n t}\left(deg_{i}-1\right) !}
$$

最后剩余的 $(n - cnt)$ 个数任意插入在 $(n - sum - 2)$ 个位置上，所以要乘 $(n - cnt)^{n - sum - 2}$

可以预处理阶乘的质因数指数避免前半部分的高精度除法，但求答案还是要用高精度乘法，这里笔者采用压八位的高精。

```cpp
const int Maxn = 1e3 + 5;
int tot = 0, prime[Maxn]; bool vis[Maxn];
inline void sieve(void) {
	vis[1] = true;
	for (int i = 2; i <= 1000; i++) {
		if (!vis[i]) prime[++tot] = i;
		for (int j = 1; j <= tot && i * prime[j] <= 1000; j++) {
			vis[i * prime[j]] = true; if (i % prime[j] == 0) break;
		}
	}
}

inline int rate(int n, int p) {
	int ret = 0;
	while (n) {
		ret += n / p;
		n /= p;
	} return ret;
}

int ps[Maxn];
inline void calc(int n, int typ) {
	for (int i = 1; i <= tot; i++)
		ps[i] += typ * rate(n, prime[i]);
}

int n, deg[Maxn], sum = 0, cnt = 0;
const int mod = 100000000;
inline vector <int> Multiply(vector <int> vec, int rec) {
	vector <int> ret; ll t = 0ll; ret.clear();
	for (int i = 0; i < vec.size(); i++) {
		t += 1ll * vec[i] * rec;
		ret.push_back(t % mod); t /= mod;
	} while (t) { ret.push_back(t % mod); t /= mod; }
	return ret;
}

signed main(void) {
	read(n); vector <int> ret(1, 1); sieve();
	for (int i = 1; i <= n; i++) {
		read(deg[i]);
		if (deg[i] != -1) sum += deg[i] - 1, ++cnt;
	} calc(n - 2, 1); calc(n - 2 - sum, -1);
	for (int i = 1; i <= n; i++) if (deg[i] != -1) calc(deg[i] - 1, -1);
	for (int i = 1; i <= tot; i++)
	for (int j = 1; j <= ps[i]; j++) ret = Multiply(ret, prime[i]);
	for (int i = 1; i <= n - 2 - sum; i++) ret = Multiply(ret, n - cnt);
	write(ret[ret.size() - 1]);
	for (int i = (int)(ret.size()) - 2; i >= 0; i--) {
		if (ret[i] < 10) printf("0000000");
		else if (ret[i] < 100) printf("000000");
		else if (ret[i] < 1000) printf("00000");
		else if (ret[i] < 10000) printf("0000");
		else if (ret[i] < 100000) printf("000");
		else if (ret[i] < 1000000) printf("00");
		else if (ret[i] < 10000000) printf("0");
		write(ret[i]);
	}
	return 0;
}

/**/


```


---

## 作者：Laoshan_PLUS (赞：1)

### 题意

给定 $N$ 个点和某些点的度数 $D_i$，求可能的树数量。

### 解析

显然，这题有弱化版 [[HNOI2004] 树的计数](https://www.luogu.com.cn/problem/P2290)。而弱化版的式子就是我们的预备知识。一个无向连通图在给定度数情况下的生成树数量为：

$$
\frac{(n-2)!}{\prod_{i=1}^n(D_i-1)!}
$$

Prufer 序列证明即可。上式中的 $n-2$ 实际上可写作 $\sum_{i=1}^n(D_i-1)$，但由 Prufer 序列的性质得，每个点在序列中出现度数减一次，所以上面两项是相等的。

---

那么回到本题中。本题只给了部分点的度数。设给了 $k$ 个点的度数 $D_i$（此后均不考虑 $-1$ 的情况，$D$ 序列长度为 $k$）。那么这 $k$ 个点的情况我们仍能套用预备公式，但要注意 $k$ 个点并不是 Prufer 序列的全部，所以不能写 $k-2$：

$$
\frac{\left[\sum_{i=1}^k(D_i-1)\right]!}{\prod_{i=1}^k(D_i-1)!}
$$

同样，由于这不是全部，所以这 $k$ 个点在 Prufer 序列中的位置是不固定的。由 Prufer 序列的性质，第 $k$ 个点出现 $(D_k-1)$ 次，所以还要乘上 $\binom{n-2}{\sum_{i=1}^k(D_i-1)}$。至于剩下的 $(n-k)$ 个无度点，我们把它填充到 Prufer 序列中剩下的 $\left[n-2-\sum_{i=1}^k(D_i-1)\right]$ 个空中。**由于这 $\boldsymbol{(n-k)}$ 个点的度数不固定，所以怎么填都是可以的，不用考虑排列的情况**。答案再乘上 $(n-k)^{n-2-\sum_{i=1}^k(D_i-1)}$ 得：

$$
\frac{\left[\sum_{i=1}^k(D_i-1)\right]!}{\prod_{i=1}^k(D_i-1)!}\times\binom{n-2}{\sum_{i=1}^k(D_i-1)}\times(n-k)^{n-2-\sum_{i=1}^k(D_i-1)}
$$

化简得：

$$
\frac{\left[\prod_{t=n-1-\sum_{i=1}^k(D_i-1)}^{n-2}t\right](n-k)^{n-2-\sum_{i=1}^k(D_i-1)}}{\prod_{i=1}^k(D_i-1)!}
$$

太繁琐了，我们令 $\sum_{i=1}^k(D_i-1)=s$，一下就将式子化简了：

$$
\frac{\left[\prod_{t=n-1-s}^{n-2}t\right](n-k)^{n-2-s}}{\prod_{i=1}^k(D_i-1)!}
$$

最后就是普通的分解质因数了。

### 坑点

- 注意统计答案要开高精。
- 高精数组开越大越好。

### 实现

```cpp
#include <bits/stdc++.h>
using namespace std;

constexpr int MAXN = 1e5 + 5;
int n, d[MAXN], k, s;
int pw[MAXN], pm[MAXN];
vector<int> pri;
int ans[MAXN] = {1};

void init() {
    for (int i = 2; i < MAXN; i++) {
        if (!pm[i]) {
            pm[i] = i;
            pri.push_back(i);
        }
        for (auto j : pri) {
            if (i * j >= MAXN) break;
            pm[i * j] = j;
        }
    }
}

void mul(int b) {
    int tmp = 0;
    for (int i = 0; i < MAXN - 1; i++) {
        ans[i] = ans[i] * b + tmp;
        tmp = 0;
        if (ans[i] >= 10) {
            tmp = ans[i] / 10;
            ans[i] %= 10;
        }
    }
}

void print() {
    int len = MAXN - 1;
    while (!ans[len]) len--;
    for (int i = len; i >= 0; i--) cout << ans[i];
    cout << '\n';
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(nullptr);
    init();
    cin >> n;
    for (int i = 1, x; i <= n; i++) {
        cin >> x;
        if (x == -1) continue;
        d[++k] = x;
        s += x - 1;
    } 
    for (int i = n - 1 - s; i <= n - 2; i++) {
        int x = i;
        while (x > 1) pw[pm[x]]++, x /= pm[x];
    }
    for (int i = 1; i <= n - 2 - s; i++) {
        int x = n - k;
        while (x > 1) pw[pm[x]]++, x /= pm[x];
    }
    for (int i = 1; i <= k; i++)
        for (int j = 1; j < d[i]; j++) {
            int x = j;
            while (x > 1) pw[pm[x]]--, x /= pm[x];
        }
    for (int i = 2; i < MAXN; i++) while (pw[i]--) mul(i);
    print();

    return 0;
}
```

---

## 作者：_Spectator_ (赞：0)

[可能更好的食用体验](/article/anqa127j) $|$ 
[题目传送门](/problem/P2624) $|$ 
[我的其他题解](/user/523641#article.2)

前置知识：[Prufer 序列](https://www.luogu.com.cn/problem/P6086)。

------------
### ${\color{#00CD00}\text{思路}}$

题目只给出了树上某些点的度数，考虑放到一个 Prufer 序列上来做。

这里用到了 Prufer 序列的两个性质：
- $n$ 个结点的无根树与长度为 $n-2$ 的 Prufer 序列是一一对应的。
- 一个结点在 Prufer 序列中的出现次数为其度数 $-1$。

因此题目转化为：求有多少个长度为 $n-2$ 的序列，序列中的每个元素 $\in[1,n]$，其中序列中某些数的出现次数为给定的值。

设给定了 $m$ 个点的度数，分别为 $d_1,d_2,\dots d_m$，$s=\sum\limits_{i=1}^m d_i-1$。由简单的组合数学可知答案为：
$$\boxed{A_{n-2}^s\times\prod_{i=1}^m\frac{1}{(d_i-1)!}\times (n-m)^{n-2-s}}$$

其中：
- $A_{n-2}^s$ 表示在 $n-2$ 个位置中取出 $s$ 个位置的排列数。
- $\prod\limits_{i=1}^m\frac{1}{(d_i-1)!}$ 表示除掉每一种数内部的顺序。
- $(n-m)^{n-2-s}$ 表示将其余的 $n-m$ 个数任意填入剩下的 $n-2-s$ 个位置。

------------
### ${\color{#00CD00}\text{代码}}$

因为不想写高精度，所以用的是 Python。

```python
def main():
    n = int(input())
    fac = [1] * (n + 1)
    for i in range(1, n + 1):
        fac[i] = fac[i - 1] * i
    d = [0] * (n + 1)
    m = 0
    s = 0
    for i in range(1, n + 1):
        d[i] = int(input())
        if d[i] == -1: continue
        m += 1; s += d[i] - 1
    if s > n - 2: print(0); return;
    div = fac[n - 2 - s]
    for i in range(1, n + 1):
        if d[i] != -1: div *= fac[d[i] - 1]
    print(fac[n - 2] * (n - m) ** (n - 2 - s) // div)

if __name__ == "__main__":
    main()
```

---

## 作者：Pwtking (赞：0)

Prufer 序列变形题。

简单的讲解一下 Prufer 序列：

- **简介**：一颗无根树，每次将度数为1的节点的父亲加入序列，并将其删除，最终得到一个长度为 $n-2$ 的序列。

- **将 Prufer 序列转化为无根树**：每次取出序列中最前面的数，将一个在点集中且最小的数与其连边，最后将序列最靠前的数和刚刚在点集中取出的数在分别在序列和点集中删去。最后将剩下的两个未连边的点连边即可。

- **Prufer 序列性质：** 

- 序列与无根树一一对应。

- 度数为 $d_i$ 的节点只会在序列中出现 $d_i-1$ 次。

- 生成 $n$ 节点的完全图（树）有 $n^{n-2}$ 种（Cayley 定理）。

- 生成每一种树的方式有 $(n-1)!$ 种（Cayley 定理）。

- 对于给定度数 $d_{ 1-n}$ 的 $n$ 个节点，共有 $\frac{(n-2)!}{\prod_{i=1}^{n} (d_i-1)!} $ 种形成树的方式。

辅助做题结论：对于 $n$ 个结点形成的树，$ {\textstyle \sum_{i=1}^{n}(d_i-1)}=n-2 $。



------------

**接下来看本题：**

题目中提到有一些节点度数未知，所以我们可先从这些节点已知的情况下手。若有 $x$ 个结点度数已知，根据上面提到的性质，会有 $\frac{(\textstyle \sum_{i=1}^{x}(d_i-1))!}{\prod_{i=1}^{x} (d_i-1)!} $ 种情况。
同时，因为这 $x$ 个节点是无序的，所以还要再乘上一个他们的组合数，即为 $\frac{(\textstyle \sum_{i=1}^{x}(d_i-1))!}{\prod_{i=1}^{x} (d_i-1)!}  \times C_{n-2}^{x}$。

接下来考虑度数未知的情况。

根据上面的性质可知：因为 Prufer 序列剩下的位置只有 $n-2-\textstyle \sum_{i=1}^{x}(d_i-1)$ 个，所以根据性质可知共有 $(n-x)^{n-2-\textstyle \sum_{i=1}^{x}(d_i-1)}$ 种方案。

最终答案即为 $\frac{(\textstyle \sum_{i=1}^{x}(d_i-1))!}{\prod_{i=1}^{x} (d_i-1)!}  \times C_{n-2}^{x}\times (n-x)^{n-2-\textstyle \sum_{i=1}^{x}(d_i-1)}$。

不过这还没完，再解释一下为什么不先算未知度数的节点：

当然是因为不方便。因为这道题是利用 Prufer 序列的性质来算的，所以未知节点的方案不好直接表示（因为序列的总位置为 $n-2$ 个，若不先把已知度数的节点所占位置数算出，未知度数的节点不好表示。）

---


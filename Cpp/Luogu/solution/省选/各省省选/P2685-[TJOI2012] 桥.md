# [TJOI2012] 桥

## 题目描述

有 $n$ 个岛屿，$m$ 座桥，每座桥连通两座岛屿，桥上会有一些敌人，玩家只有消灭了桥上的敌人才能通过，与此同时桥上的敌人会对玩家造成一定伤害。而且会有一个大 Boss 镇守一座桥，以玩家目前的能力，是不可能通过的。而 Boss 是邪恶的， Boss 会镇守某一座使得玩家受到最多的伤害才能从岛屿 $1$ 到达岛屿 $n$（当然玩家会选择伤害最小的路径）。问，Boss 可能镇守的桥有哪些。

注意可以有**重边**和**自环**。

## 说明/提示

- $30\%$ 的数据，$1 ≤ n ≤ 1000$；
- $100\%$ 的数据，$1 ≤ n ≤ 100000, 1 ≤ m ≤ 200000, 1 ≤ c ≤ 10000$；
- 数据保证玩家可以从岛屿 $1$ 到达岛屿 $n$。


## 样例 #1

### 输入

```
3 4
1 2 1
1 2 2
2 3 1
2 3 2```

### 输出

```
3 2```

# 题解

## 作者：ghj1222 (赞：30)

# 请管理员修正本题难度标签并清除更改题目前的AC记录

题目大意：给定一无向图，求删除一条边后1到n最短路的最大值，以及方案数。

做法：我们先从1为起点、从n为起点跑两边dij，获得每一个点到起点1、终点n的最短距离，其实距离和边权之间的关系相当于构建了由1为根的和由n为根的最短路树---所有最短路组成的树。

不难发现，要删除一条边，并使得最短路增大，一定要删除最短路上的边。所以我们找到从1到n的一条最短路链。找的方法就是在由n为根的最短路树上从1开始向N走。

接下来我们从这个最短路链上每一个点，在以1为根和以n为根的最短路树上进行bfs(仅向儿子bfs)。目的是找到对于每一个不在最短路链上的点x，找到1到x最短路与1到n最短路最后一个重合的点l[x]，你也可以理解为在以1为根的最短路树上x与n的lca。同理还有以n为根的最短路上x和1的lca。

接下来我们枚举每一条不在最短路链上的边u->v，不难想到，从1到N经过边u->v的最短路一定是1->l[u]->u->v->r[v]->n的这种形式。那么在1->n的最短路上，l[u]->r[v]这一段区间内任意一条边的删除，从1到n的最短路**有可能**变为1->l[u]->u->v->r[v]->n。由于是最短路，所以就要更新所有这种形式的最小值。并且所有不在1->N最短路链上的边都能影响一个区间，所以这就变成了一个区间最小值问题，可以用线段树维护。用线段树维护1->N最短路上的边，线段树每一个元素代表删除这条边后最短路的长度。

最后我们扫一遍整个线段树，找最大值即可。注意如果所有的值相等(且等于最短路径)，说明无论删除哪一条边都不会使得最短路径长度增加，所以删除图里任意一条边均可，tot=m。

代码如下(没有坑，可以直接复制提交)

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m, tot, res[100010];

struct SegmentTree
{
    int tree[400010];
    
    void init(int x, int l, int r)
    {
        tree[x] = 0x3f3f3f3f;
        if (l == r)
            return;
        int mid = (l + r) >> 1;
        init((x << 1), l, mid);
        init((x << 1) | 1, mid + 1, r);
    }
    
    void update(int x, int L, int R, int cl, int cr, int key)
    {
        if (cr < L || cl > R)
            return;
        if (cl >= L && cr <= R)
        {
            tree[x] = min(tree[x], key);
            return;
        }
        int mid = (cl + cr) >> 1;
        update(x << 1, L, R, cl , mid, key);
        update((x << 1) | 1, L, R, mid + 1, cr, key); 
    }
    
    void pushdown(int x, int l, int r)
    {
        if (l == r)
        {
            res[l] = tree[x];
            return;
        }
        tree[x << 1] = min(tree[x << 1], tree[x]);
        tree[(x << 1) | 1] = min(tree[(x << 1) | 1], tree[x]);
        int mid = (l + r) >> 1;
        pushdown(x << 1, l, mid);
        pushdown((x << 1) | 1, mid + 1, r); 
    }
}segtree;

struct edge
{
    int v, w, ne;
}a[400010];
bool in[400010];

int h[100010], dis1[100010], dis2[100010], link[100010], id[100010], l[100010], r[100010];
bool v[100010];

void add(int x, int y, int z)
{
    static int tmp = 0;
    a[++tmp] = (edge){y, z, h[x]};
    h[x] = tmp;
}

void dij(int *dis, int src)
{
    for (int i = 1; i <= n; i++)
    {
        dis[i] = 0x3f3f3f3f;
        v[i] = false;
    }
    dis[src] = 0;
    priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > >q;
    q.push(make_pair(0, src));
    while (!q.empty())
    {
        int x = q.top().second;
        q.pop();
        if (v[x])
            continue;
        v[x] = true;
        for (int i = h[x]; i != 0; i = a[i].ne)
        {
            if (v[a[i].v] == false && dis[x] + a[i].w < dis[a[i].v])
            {
                dis[a[i].v] = dis[x] + a[i].w;
                q.push(make_pair(dis[a[i].v], a[i].v));
            }
        }
    }
}

void getLink()
{
    int x = 1;
    while (x != n)
    {
        link[++tot] = x;
        id[x] = tot;
        for (int i = h[x]; i != 0; i = a[i].ne)
        {
            if (dis2[x] == dis2[a[i].v] + a[i].w)
            {
                in[i] = true;
                x = a[i].v;
                break;
            }
        }
    }
    link[++tot] = n;
    id[n] = tot;
}

void bfs(int src, int *dis, int *arr)
{
    queue<int> q;
    q.push(link[src]);
    arr[link[src]] = src;
    while (!q.empty())
    {
        int x = q.front();
        q.pop();
        for (int i = h[x]; i != 0; i = a[i].ne)
            if (id[a[i].v] == 0 && arr[a[i].v] == 0 && dis[x] + a[i].w == dis[a[i].v])
            {
                arr[a[i].v] = src;
                q.push(a[i].v);
            }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int x, y, z, i = 1; i <= m; i++)
    {
        scanf("%d%d%d", &x, &y, &z);
        add(x, y, z);
        add(y, x, z); 
    }
    dij(dis1, 1);
    dij(dis2, n);
    getLink();
    for (int i = 1; i <= tot; i++)
        bfs(i, dis1, l);
    for (int i = tot; i >= 1; i--)
        bfs(i, dis2, r);
    segtree.init(1, 1, tot);
    for (int x = 1; x <= n; x++)
        for (int i = h[x]; i != 0; i = a[i].ne)
            if (in[i] == false && l[x] > 0 && r[a[i].v] > 0 && l[x] < r[a[i].v])
                segtree.update(1, l[x], r[a[i].v] - 1, 1, tot, dis1[x] + a[i].w + dis2[a[i].v]);
    segtree.pushdown(1, 1, tot);
    int cnt = 0, ans = 0;
    for (int i = 1; i < tot; i++)
    {
        if (res[i] > ans)
        {
            ans = res[i];
            cnt = 1;
        }
        else if (res[i] == ans)
            cnt++;
    }
    if (ans == dis1[n])
        cnt = m;
    printf("%d %d\n", ans, cnt);
    return 0;
}

```


让我们一起膜拜大佬林瑞堂@[olinr](https://www.luogu.org/space/show?uid=88460)

---

## 作者：Sunflower_ac (赞：21)

# 【题解】P2685 [TJOI2012]桥

挺妙的一道题。这里提供一种不用线段树的做法。

[博客园食用效果更佳](https://www.cnblogs.com/xrkforces/p/luogu-P2685.html)

## 题目链接

[P2685 [TJOI2012]桥 - 洛谷](https://www.luogu.com.cn/problem/P2685)

## 题意概述

给定一张 $n$ 个点 $m$ 条边的**无向**图。求把这张图上任意一条边断掉后，形成的新的从 $1$ 到 $n$ 的最短路最大是多少，并输出满足最大值的方案数。

## 思路分析

首先，只有断掉最短路上的边时，才会对最后的最短路长度有影响；如果炸的不是最短路上的边，就对最短路长度没有影响。

那么我们分类讨论：

- 若原图上断掉最短路上的边后形成的新的最短路的最大值仍然与原最短路长度相同，那么说明这张图上断掉任意一条边都可以（不一定是最短路上边），那么方案数就是边数 $m$；

- 若原图上断掉最短路上的边后形成的新的最短路的最大值**大于**原最短路长度，那么就只能断掉原最短路上符合要求的边；

- 稍微思考可知，断掉最短路上的边后形成的新的最短路的最大值**不可能小于**原最短路长度。

那么我们现在只需要计算在断掉最短路上的任意一条边后形成的新的最短路最大值是多少。

首先考虑一个结论：

> 假设原图最短路上有 $s$ 个点，最短路径为 $1-v_1-v_2-v_3-\cdots-v_s$，那么在最短路上炸掉一条边 $v_i \rightarrow v_{i+1}$ 之后，所形成的新的最短路一定是 $1-v_1-v_2-\cdots -v_j-一些非最短路上的边-v_k-\cdots -v_s(j\le i,k \ge i+1)$。

换句话说，在最短路上删掉一条边 $(u,v)$ 后，我们怎么走才能让路径继续最短呢？一定是从起点沿着原来的最短路走到 $u$ 及 $u$ 之前的某个点，偏离最短路，走不在原来最短路上的边，到达 $v$ 及 $v$ 之后的某个点，再沿着原来的最短路走完。

这里有点抽象我们画个图理解一下。

![](https://cdn.luogu.com.cn/upload/image_hosting/mzzxqjas.png)

（此图仅供理解方便，实际上不符合题意，原题是边双。）

假设原最短路是 $1 \rightarrow 2 \rightarrow 3\rightarrow 4\rightarrow 7$ （图中标绿的路径），若断掉边 $3\rightarrow4$，那么新的最短路就只能从在最短路上的 $3$ 或者 $3$ 之前“偏离”最短路，在 $4$ 或者 $4$ 之后回到最短路。

在这张图中只能是 $1 \rightarrow 2 \rightarrow 6 \rightarrow 5\rightarrow 4 \rightarrow 7$。

这个结论很好证明，以上图中，除了被断掉的地方其它地方必须经过最短路，这样才能保证“最短”。

这个结论告诉我们：我们在新的最短路上走时，最多只能“偏离”原最短路一次，“回到”原最短路一次。

你是否联想到什么呢？

这不就相当于，一架飞机，从起点走到终点，在中间只能起飞一次，降落一次，而我们关注的就是起飞的时机和降落的时机使得最后走的路程最小。

那么我们可以先考虑，把原最短路找出来，然后考虑对于每条非最短路上的边，如果我让飞机必须经过这条边，那它在什么时候起飞，在什么时候降落。

现在的问题就是先找到原图的最短路。

那么我们可以考虑在之前见到过的好多题用的技巧：

跑两遍 dijkstra，分别预处理出来从 $1$ 出发到每个点 $i$ 的最短路 $dis1_i$ 以及从 $n$ 出发到每个点 $i$ 最短路 $dis2_i$。

然后我们利用 $dis2$ 这个数组标记出来最短路上的所有边并对他们重新编号。

具体做法：从 $1$ 开始，枚举当前节点 $now$ 的每条出边 $nxt$，如果 $now$ 到 $n$ 的距离等于 $now \rightarrow nxt$ 这条边的边权加上 $nxt$ 到 $n$ 的距离，那么这条边在最短路上，将它标记出来。

那么有人会问了，那如果一个图有多个最短路怎么办呢？

实际上我们只需要标记出来其中一条即可，原因如下：

$1$ 到 $n$ 的最短路，如果有多个，那么就是说最短路某边上两点 $(u,v)$ 之间，还有一条别的长度相等的路径，那么我们若断掉 $(u,v)$ 这条边，完全可以走另外一条路径，所以不影响。

这部分求解代码如下：

```cpp
for(int now=1;now!=n;)
{
	for(Node nxt:edge[now])
	{
		if(dis2[nxt.v]+nxt.w==dis2[now])
		{
			now=nxt.v;
			book[nxt.id]++;
			break;
		}
	}
}
```

在标记完原最短路后，我们就可以维护两个数组 $l$ 和 $r$：

$l_u$ 表示**第一个**不在 $1 \rightarrow u$ 最短路上的边的编号；

$r_u$ 表示**最后一个**不在 $u \rightarrow  n$ 最短路上的边的编号。

比如对于上面那张图，我们对于边编个号：

![](https://cdn.luogu.com.cn/upload/image_hosting/fme004w8.png)

在这张图中：

$l_2=2,r_2=1,l_6=2,r_6=3,\cdots$

我们暂且先不管 $l$ 和 $r$ 是怎么求的，来考虑一下如何利用 $l$ 和 $r$ 求解问题。

其实这里的 $l$ 和 $r$ 对标的是在飞机起飞降落模型中的起飞时机和降落时机。

那么我们现在要知道的就是：对于每一条非原最短路上的边（即图中的绿边），什么时候要通过这条边以及这条边所在最短路径的长度是多少。

以上图为例，假如我们要通过 ⑤ 号边，那么只有当 ② 或 ③ 被断开时，才能经过它。

我们发现，假如要经过一条非原最短路的边 $u \rightarrow v$，只有当 $l_u$ 到 $r_v$ 中有个桥断了，我们才会考虑走这条边，此时形成的新的最短路长度就为 $dis1_u+w(u,v)+dis2_v$。其中 $w(u,v)$ 表示从 $u$ 到 $v$ 这条边的边权。

等等，假如 $u=6,v=2$ 呢？那么应该是 $l_v$ 到 $r_u$ 喽？实际上这是另一种走向，一种从 $2 \rightarrow 6$，一种是 $6 \rightarrow 2$。

所以当 $l_u \le r_v$ 时，我们新的最短路长度为 $dis1_u+w(u,v)+dis2_v$；

当 $l_v \le r_u$ 时，新的最短路长度为 $dis1_v+w(u,v)+dis2_u$。

**注意：这两个条件并不对立，可以并存也可以均不满足。**

我们用两个 basic_string：

$dp1_i$ 表示的是飞机在边 $i-1$ 的终点“起飞”所能形成的路径的集合；

$dp2_i$ 表示的是飞机在边 $i+1$ 的起点“降落”所能形成的路径的集合。

维护每次计算的路径长度。

这部分代码如下：

```cpp
for(int i=1;i<=m;i++)
{
	if(book[i])continue;
	int u=e[i].u,v=e[i].v,w=e[i].w;
    if(l[u]<=r[v])
	{
		dp1[l[u]]+=dis1[u]+w+dis2[v];
		dp2[r[v]]+=dis1[u]+w+dis2[v];
	}
	if(l[v]<=r[u])
	{
		dp1[l[v]]+=dis1[v]+w+dis2[u];
		dp2[r[u]]+=dis1[v]+w+dis2[u];
	}
} 
```

然后我们考虑原最短路上的每一条边，每一条边被断掉后，相当于飞机从这个点前起飞，降落到这个点之后。

考虑我们 $l$ 和 $r$ 数组的本质：$l_i$ 表示的是从 $i-1$ 开始之后任意断哪一条边都行，$r_i$ 表示的是从 $i+1$ 往前任意断哪一条边都行，那么这两个的交集，就表示从 $1$ 到 $l_i+1$，从 $r_i+1$ 到 $n$ 的所有的边都不能断。

可以考虑用 multiset 来维护。

我们从左到右枚举每一个最短路上的边 $i$，每次枚举刚开始将 $dp1_i$ 中的所有元素加入一个 multiset 中维护，然后取最小值，就是当前在 $i$ 之前起飞在 $i$ 之后降落的最小距离。

需要注意的一点是，在每次枚举结束之前，需要将 $dp2_i$ 中的元素从 multiset 中移除，为什么呢？

因为 $dp2_i$ 表示的是在 $i+1$ 的起点降落，也就是说一定会经过 $i+1$ 这条边，而我们枚举的下一个是断掉 $i+1$ 这条边，所以 $dp2_i$ 一定是不符合下一次枚举的条件的，所以必须要移除。

这里可能有点抽象，我们再借助图理解一下：

![](https://cdn.luogu.com.cn/upload/image_hosting/3j3vvdh2.png)

假设我们在上面那张图的 $3$ 和 $5$ 之间再连一条边，编号为 ⑧，那么对于路径 $1 \rightarrow 2 \rightarrow 6 \rightarrow 5 \rightarrow 3 \rightarrow 4 \rightarrow 7$，我们会在枚举边 ② 时加入到 multiset 中，由于它在 $3$ 号节点就回到了原最短路上，所以我们在枚举边 ③ 时就不能把它算进去，是不合法的。

最后统计一下方案数就好。

这部分代码如下：

```cpp
int cnt=0;//方案数； 
for(int i=1;i<=tot;i++)
{
	for(int tt:dp1[i])ss.insert(tt);
	if(*ss.begin()>ans){ans=*ss.begin();cnt=1;}
	else if(*ss.begin()==ans)cnt++;
	for(int tt:dp2[i])ss.erase(ss.find(tt));
} 
if(ans==dis1[n])cnt=m;//这里在刚开始分析思路的时候就已经解释过了。断掉最短路上的边后不影响最短路长度。
cout<<ans<<" "<<cnt<<endl;
```

最后我们来考虑如何求 $l$ 和 $r$ 数组。

首先由于 $l_u$ 是当前最小的不在 $1-u$ 最短路上的编号，所以我们要将 $l$ 数组初始化为无穷大，同理要将 $r$ 初始化为 $0$。

然后对于原最短路上的每个点 $u$，它的 $l$ 设为从 $u$ 到 $n$ 最短路径上第一条边的编号，$r$ 设为从 $1$ 到 $u$ 路径上最后一条边的编号。

这个很好理解。

那么对于非原最短路上点来说，如何求出它的 $l$ 和 $r$ 呢？

先以 $l$ 为例，我们可以将所有的点按照到 $1$ 的最短路长度**从小到大**排序，然后枚举每一个不是最短路上的点，用它的 $l$ 来更新与它连边的所有点的 $l$，这里有点类似于 dijkstra 的“松弛”操作，具体做法：设当前点为 $now$，与它连边的点是 $nxt$，若 $now$ 在 $1$ 到 $nxt$ 的最短路上且 $l_{nxt}>l_{now}$，那么就用 $l_{now}$ 来更新 $l_{nxt}$

聪明的小伙伴就会发现，这实际上也相当于也跑了一遍 dijkstra。

之所以要按照 $dis1$ 从小到大排序，这实际上就是满足了一种拓扑排序，这块相当于是一个 DP，我们必须保证用距离 $1$ 更近的节点的 $l$ 去更新距离 $1$ 更远的答案，也相当于 dijkstra 中每次从小根堆出取出堆顶。如果不排序，那么就相当于拓扑排序中，一个节点的入度没有减为 $0$ 就入队了，这有可能导致答案错误。

而之所以必须满足 $l_{nxt}>l_{now}$ 才能更新答案，我们继续借助上面的图理解一下。

假设 $now=6,nxt=5$，此时的 $l_5=3$，那么由于 $l_6=2 < l_5$，所以用 $l_6$ 更新 $l_5$。这就相当于你找到了飞机起飞的更早的时间，而由于我们的 $l$ 数组的含义是最小的不在 $1$ 到当前节点路径上的边，所以要用 $l_6$ 更新 $l_5$，就是这个意思。

求 $r$ 与求 $l$ 同理，这里不再赘述。

这部分代码如下：

```cpp
for(int i=1;i<=n;i++)z[i]=i;
sort(z+1,z+n+1,cmp1);
for(int i=1;i<=n;i++)
{
	int now=z[i];
	for(Node nxt:edge[now])
	{
		if(book[nxt.id])continue;
		if(dis1[nxt.v]==dis1[now]+nxt.w&&l[nxt.v]>l[now])l[nxt.v]=l[now];
	}
}
sort(z+1,z+n+1,cmp2);
for(int i=1;i<=n;i++)
{
	int now=z[i];
	for(Node nxt:edge[now])
	{
		if(book[nxt.id])continue;
		if(dis2[nxt.v]==dis2[now]+nxt.w&&r[nxt.v]<r[now])r[nxt.v]=r[now];
	}
}
```

到此为止，这道题的所有思路就全部分析完了。

回过头来看这道题，实际上相当于跑了四遍 dijkstra，两遍分别用来求从 $1$ 出发的最短路和从 $n$ 出发的最短路，两遍用来求 $l$ 和 $r$。而这四个数组，正是这道题的关键所在。

另外还有一个 multiset，这道题的所有题解都是用线段树维护了这个操作，但在这种解法中，提供了一个不用线段树只有简单的 STL 就解决问题的办法。很妙。

不得不说，这是一道最短路好题，让我更加深刻的认识到了 dijkstra 一些本质的东西，甚至也帮我理解了 DP 中的一些东西，同时让我更加理解了 multiset 的用法，受益匪浅。

## 代码实现

```cpp
//luoguP2685
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
#include<set>
#define int long long
using namespace std;
const int maxn=1e5+10;
int dis1[maxn],dis2[maxn],vis[maxn],vis2[maxn];
int l[maxn],r[maxn],z[maxn],book[maxn<<1];
int n,m;
int ans;

struct Node{
    int v,w,id;
    bool operator<(const Node &t)const
    {
    	return w>t.w;
	}
};

struct nod{int u,v,w;}e[maxn<<1];

basic_string<Node>edge[maxn];
basic_string<int>dp1[maxn],dp2[maxn];
multiset<int>ss;

inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}

void dijkstra1()
{
	priority_queue<Node>q;
	for(int i=1;i<=n;i++)dis1[i]=(1ll<<31)-1;
	dis1[1]=0;int tt=0;
	q.push(Node{1ll,dis1[1],tt});
	while(!q.empty())
	{
		Node now=q.top();
		q.pop();
		if(vis[now.v])continue;
		vis[now.v]++;
		for(Node y:edge[now.v])
		{
			if(dis1[y.v]>dis1[now.v]+y.w)
			{
				dis1[y.v]=dis1[now.v]+y.w;
				q.push(Node{y.v,dis1[y.v],tt});
			}
		}
	}
}

void dijkstra2()
{
	priority_queue<Node>q;
	for(int i=1;i<=n;i++)dis2[i]=(1ll<<31)-1;
	int s=n;
	dis2[n]=0;int tt=0;
	q.push(Node{s,dis2[s],tt});
	while(!q.empty())
	{
		Node now=q.top();
		q.pop();
		if(vis2[now.v])continue;
		vis2[now.v]++;
		for(Node y:edge[now.v])
		{
			if(dis2[y.v]>dis2[now.v]+y.w)
			{
				dis2[y.v]=dis2[now.v]+y.w;
				q.push(Node{y.v,dis2[y.v],tt});
			}
		}
	}
}

int cmp1(int a,int b){return dis1[a]<dis1[b];}
int cmp2(int a,int b){return dis2[a]<dis2[b];}

signed main()
{
	n=read();m=read();
	for(int i=1;i<=m;i++)
	{
		int s,t,c;
		s=read();t=read();c=read();
		e[i].u=s;e[i].v=t;e[i].w=c;
		edge[s]+=Node{t,c,i};
		edge[t]+=Node{s,c,i};
	}
	//正反跑两遍 dij。预处理出来所有点到 1 和 n 的最短路。 
	dijkstra1();
	dijkstra2();
	//初始化 l 和 r。并标记所有当前最短路上的点。 
	memset(l,0x3f3f3f,sizeof(l)); 
	l[1]=1;
	int tot=0;
	for(int now=1;now!=n;)
	{
		for(Node nxt:edge[now])
		{
			if(dis2[nxt.v]+nxt.w==dis2[now])
			{
				now=nxt.v;
				book[nxt.id]++;
				break;
			}
		}
		r[now]=++tot;
		l[now]=tot+1;
	}
	//求每一个 l 和 r。 
	for(int i=1;i<=n;i++)z[i]=i;
	sort(z+1,z+n+1,cmp1);
	for(int i=1;i<=n;i++)
	{
		int now=z[i];
		for(Node nxt:edge[now])
		{
			if(book[nxt.id])continue;
			if(dis1[nxt.v]==dis1[now]+nxt.w&&l[nxt.v]>l[now])l[nxt.v]=l[now];
		}
	}
	sort(z+1,z+n+1,cmp2);
	for(int i=1;i<=n;i++)
	{
		int now=z[i];
		for(Node nxt:edge[now])
		{
			if(book[nxt.id])continue;
			if(dis2[nxt.v]==dis2[now]+nxt.w&&r[nxt.v]<r[now])r[nxt.v]=r[now];
		}
	}
	//求出对于每一条非原最短路边，哪一条最短路边删掉之后这条边才有用。
	for(int i=1;i<=m;i++)
	{
		if(book[i])continue;
		int u=e[i].u,v=e[i].v,w=e[i].w;
		if(l[u]<=r[v])
		{
			dp1[l[u]]+=dis1[u]+w+dis2[v];
			dp2[r[v]]+=dis1[u]+w+dis2[v];
		}
		if(l[v]<=r[u])
		{
			dp1[l[v]]+=dis1[v]+w+dis2[u];
			dp2[r[u]]+=dis1[v]+w+dis2[u];
		}
	 } 
	//求出删掉每一条原最短路边后对应的答案。
	int cnt=0;//方案数； 
	for(int i=1;i<=tot;i++)
	{
		for(int tt:dp1[i])ss.insert(tt);
		if(*ss.begin()>ans){ans=*ss.begin();cnt=1;}
		else if(*ss.begin()==ans)cnt++;
		for(int tt:dp2[i])ss.erase(ss.find(tt));
	 } 
	if(ans==dis1[n])cnt=m;
	cout<<ans<<" "<<cnt<<endl;
	return 0;
}
```


---

## 作者：AcGreen (赞：9)

## 【题解】P2685 [TJOI2012]桥

### 题意简述

给定一无向图，断掉其中一条边后，使得从点 $1$ 到点 $n$ 的最短路最长。求此最短路长度与此图中满足此条件的边数。

### 题目解法

这里提供一种使用割边的解法。

首先，我们求出在要求经过某一条边的的从点 $1$ 到点 $n$ 的路径中最短的路径长度。对于边 $i$ 此值记值为 $mindis_i$。

我们从小到大枚举所有 $mindis_i$ 值，记当前所枚举的值为 $now$ 用所有 $mindis_i \le now$ 的边建图。如果在此图中点 $1$ 与点 $n$ 属于同一个边双联通分量，当条件首次成立时此图中切断任意一条边后的最短路长度最大值为 $now$，满足此条件的边数为上一次所建图中点 $1$ 到点 $n$ 的最短路上的割边数。

### 具体算法

为了求出 $mindis_i$ 这里以点 $1$ 与点 $n$ 为起点，分别跑一次单源最短路。对于边 $(u,v)$ 而言，显然的，经过其的从点 $1$ 到点 $n$ 的路径中长度最短的路径长度是点 $1$ 到点 $u$ 的最短路长度，点 $v$ 到点 $n$ 的最短路长度与边 $(u,v)$ 的长度之和。因为这是一个无向图，所以我们需要讨论边 $(u,v)$ 的方向，并取其在两个方向上的最小值。

为了求出点 $1$ 与点 $n$ 是否属于同一个边双联通分量，我们可以使用 tarjan 算法求出图中的割边，并在删去割边的图中跑一遍 DFS 验证点 $1$ 与点 $n$ 是否连通，如连通，则说明点 $1$ 与点 $n$ 属于同一个边双联通分量。

### 关于此解法正确的说明

对于其中边 $mindis_i \le now$ 的图中显然有总长度小于等于 $now$ 的从点 $1$ 到点 $n$ 的路径存在。当断掉任意一条边 $a$ 时
* 若 $mindis_a=now$ 此图相当于上一次枚举所建图，此图中显然有总长度小于 $now$ 的从点 $1$ 到点 $n$ 的路径存在。
* 若 $mindis_a<now$ 由于此图点 $1$ 与点 $n$ 是否属于同一个边双联通分量，所以点 $1$ 到点 $n$ 间显然存在一条不经过断边的路径，并且此路径中存在一条边其经过此边的的从点 $1$ 到点 $n$ 的路径中最短的路径中不包含断边，因为如果所有如此路径其包括断边，断边将是此图的一条割边，并且断掉后使点 $1$ 与点 $n$ 在此图上不连通，与前文的条件相斥。

综上，当前文的判断条件成立时，图中将有两条互不相交的点 $1$ 到点 $n$ 的路径，且这两条路径的长度均小于等于 $now$，所以无论断掉任意一条边，从点 $1$ 到点 $n$ 的最短路长度将会小于等于 $now$。

当对于上一次枚举所建的图，当断掉其中最短路上的割边时，点 $1$ 到点 $n$ 间将没有长度小于 $now$ 的路径连通，即最短路上的割边数将是方案数。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN=4e5+10;
struct edge{
    int s,t;
    long long c,mdis;
    int iid;
} e[MAXN];//边集
long long dis1[MAXN];
long long dis2[MAXN];
bool vis[MAXN];
vector<int> t[MAXN];
set<long long> dif;
vector<int> nt[MAXN];
vector<int> ft[MAXN];
bool isbrg[MAXN];
int dfn[MAXN];
int low[MAXN];
int n,m;
int id;
bool rch[MAXN];
edge prv[MAXN];
int ans=0;
void spfa(int s,long long dis[]){
    memset(vis,0,sizeof(vis));
    priority_queue<pair<long long,int>,vector<pair<long long,int> >,greater<pair<long long,int> > > q;
    dis[s]=0;
    q.push(make_pair(dis[s],s));
    vis[s]=true;
    while(!q.empty()){
        pair<long long,int> u=q.top();
        q.pop();
        vis[u.second]=false;
        for(int i:t[u.second]){
            if(dis[u.second]+e[i].c<dis[e[i].t]){
                dis[e[i].t]=dis[u.second]+e[i].c;
                prv[e[i].t]=e[i];
                if(!vis[e[i].t]){
                    q.push(make_pair(dis[e[i].t],e[i].t));
                    vis[e[i].t]=true;
                }
            }
        }
    }

}
bool CMP(const edge &a,const edge &b){
    if(a.mdis==b.mdis&&a.s==b.s&&a.t==b.t) return a.c<b.c;
    else if(a.mdis==b.mdis&&a.s==b.s) return a.t<b.t;
    else if(a.mdis==b.mdis) return a.s<b.s;
    else return a.mdis<b.mdis;
}
map<edge,int,std::function<bool(const edge&, const edge&)> > mpt(CMP);
set<edge,std::function<bool(const edge&, const edge&)> > sinp(CMP);
void tarjan(int p,int lst){
    dfn[p]=low[p]=++id;
    for(auto i:nt[p]){
        if(!dfn[e[i].t]){
            tarjan(e[i].t,i);
            if(dfn[p]<low[e[i].t]){
                isbrg[i]=isbrg[e[i].iid]=true;
            }
            low[p]=min(low[p],low[e[i].t]);
        }
        else if(i!=e[lst].iid){
            low[p]=min(low[p],dfn[e[i].t]);
        }
    }
}
bool DFS(int p){
    if(p==n) return true;
    rch[p]=true;
    for(auto i:nt[p]){
        if(!rch[e[i].t]&&!isbrg[i]&&DFS(e[i].t)){
            return true;
        }
    }
    return false;
}
signed main(){

    cin>>n>>m;
    if(n==1){
        cout<<0<<" "<<m<<endl;
        return 0;
    }
    for(int i=1;i<=2*m;i+=2){
        cin>>e[i].s>>e[i].t>>e[i].c;
        e[i+1]=e[i];
        swap(e[i+1].s,e[i+1].t);
        t[e[i].s].push_back(i);
        t[e[i].t].push_back(i+1);
    }
    memset(dis1,0x3f,sizeof(dis1));
    memset(dis2,0x3f,sizeof(dis2));
    spfa(1,dis1);
    edge nxt=prv[n];
    for(;nxt.s!=1;nxt=prv[nxt.s])
        sinp.insert(nxt);
    sinp.insert(nxt);
    spfa(n,dis2);
    nxt=prv[1];
    for(;nxt.s!=n;nxt=prv[nxt.s])
        sinp.insert(nxt);
    sinp.insert(nxt);
    for(int i=1;i<=2*m;i++){
        e[i].mdis=min(dis1[e[i].s]+dis2[e[i].t],dis1[e[i].t]+dis2[e[i].s])+e[i].c;
        dif.insert(e[i].mdis);
    }
    sort(e+1,e+1+2*m,CMP);
    for(int i=1;i<=2*m;i++){
        edge tmp=e[i];
        swap(tmp.s,tmp.t);
        if(mpt.count(tmp)){
            e[i].iid=mpt[tmp];
            e[mpt[tmp]].iid=i;
        }
        else{
            mpt[e[i]]=i;
        }
    }
    int nw=1,lstl=0;
    ans=m;
    for(long long i:dif){
        lstl=ans;
        ans=0;
        for(;nw<=2*m&&e[nw].mdis<=i;nw++){
            nt[e[nw].s].push_back(nw);
        }
        id=0;
        memset(isbrg,0,sizeof(isbrg));
        memset(dfn,0,sizeof(dfn));
        memset(low,0,sizeof(low));
        memset(rch,0,sizeof(rch));
        for(int j=1;j<=n;j++){
            if(!dfn[j]) tarjan(j,-1);
        }
        for(int j=1;j<=2*m;j++){
            edge tmp=e[j];
            tmp.iid=0;
            tmp.mdis=0;
            if(isbrg[j]&&sinp.count(tmp)) ans++;
        }
        ans/=2;
        if(DFS(1)){
            cout<<i<<" "<<lstl<<endl;
            break;
        }
    }

    return 0;
}
```

---

## 作者：Zhddd_ (赞：4)

### Preface

本题解部分记号含义：

- $(u,v,w)$，表示边 $u\rightarrow v$，权值为 $w$。
- $(u,v)$，表示边 $u\rightarrow v$。
- $w_{v,u}$，表示边 $(v,u)$ 的权值。

### Analysis

如果最短路已经被求出，此时断掉最短路上的一条边，那么有结论：新的最短路一定 **有且仅有一段路**（注意这里不是一条边）不在原来的最短路上。

证明是很显然的，因为要是有 $k\ge 2$ 段路不在原来的最短路上，那么把其中的 $k-1$ 段路挪到原来的最短路上，该路径的长度一定不会变长。$\square$

回到本题，我们发现只有当 BOSS 守住最短路上的边时，我们才有必要找新的最短路。而根据上面的结论，我们只需要从最短路中挪走一段，关键就在于找到这一段。

![](https://cdn.luogu.com.cn/upload/image_hosting/8hvp9oot.png)

首先，我们找到 $1\rightarrow n$ 的最短路，称为 **原最短路**，接着，求出 $1\rightarrow i$ 的最短路 $dis1_i$ 和 $i\rightarrow n$ 的最短路 $dis2_i$。然后，按照 $1\rightarrow n$ 的顺序给 **原最短路** 的边从小到大编号，别的边的编号设为 $0$。（如图所示，设边权均相等，那么 **原最短路** 为 $1\rightarrow 2\rightarrow 3\rightarrow 6$。给这三条边分别编号 $1,2,3$）。

设 $l_u$ 表示最小的不在 $1\rightarrow u$ 的最短路上但在 **原最短路** 上的边的编号，$r_u$ 表示最大的不在 $u\rightarrow n$ 的最短路上但在 **原最短路** 上的边的编号。（例如图中 $l_1=1,l_2=2,l_4=2,r_5=2$）。

接下来，若我们枚举 **原最短路** 上的边 $i$ 被删掉，就相当于强制走某条边 $(u,v,w)$，使得不能回到边 $i$，我们需要维护这些强制走的边的最短路的最小值。（例如图中枚举第 $2$ 条边被删掉，强制走的边可能是 $(2,4),(4,5),(5,3)$）。

当枚举到边 $i$ 时，如果强制选择了边 $(u, v, w)$，那么一定有 $l_u\le i,~r_v\ge i$。像扫描线那样，我们把这样的边 $(u,v,w)$ 存两份，一份存在 $l_u$，另一份存在 $r_v$，当 $i$ 枚举到 $l_u$ 时，将强制走过边 $(u,v,w)$ 的最短路 $dis1_u+w+dis2_v$ 加入 multiset（可能还要考虑反向边的细节），用 multiset 中的最小值更新答案，当 $i$ 枚举到 $r_v$ 时，从 multiset 中删掉该值。

最后，关于怎么求 $l_u$ 和 $r_u$。以求 $l_u$ 为例，**原最短路** 上的点的 $l_u$ 是很好求的，而发现如果存在点 $v$ 满足 $dis1_u= dis1_v+w_{v,u}$，就可以用 $l_v$ 来更新 $l_u$，即 $l_u\gets \min(l_u,l_v)$。所以把所有点按照 $dis1$ 从小到大排序，排完序以后递推就好了。

视 $n,m$ 同级，时间复杂度 $O(n\log n)$，常数很大。此外，注意当不论怎么删边都是最短路时，要输出 $m$。

### Implementation

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef pair<LL, int> PLI;
const int N = 1e5 + 10, M = 4e5 + 10;

struct Edge { int u, v, w; } ed[M];
int n, m;
int h[N], e[M], ne[M], w[M], idx, pre[N], l[N], r[N], tot, t[N], cnt;
LL dis1[N], dis2[N], res;
bool vis[N], st[M];
vector<LL> dp1[M], dp2[M];
multiset<LL> mn;

void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; }
bool cmp1(int a, int b) { return dis1[a] < dis1[b]; }
bool cmp2(int a, int b) { return dis2[a] < dis2[b]; }

void dijkstra(int s, LL *dis) {
	memset(vis, false, sizeof vis);
	priority_queue<PLI, vector<PLI>, greater<PLI> > heap;
	dis[s] = 0;
	heap.push({ 0, s });
	while (!heap.empty()) {
		int u = heap.top().second;
		heap.pop();
		if (vis[u]) continue;
		vis[u] = true;
		for (int i = h[u]; ~i; i = ne[i]) {
			int v = e[i];
			if (dis[v] > dis[u] + w[i]) {
				dis[v] = dis[u] + w[i];
				if (s == 1) pre[v] = i;
				if (!vis[v]) heap.push({ dis[v], v });
			}
		}
	}
}

int main() {
	memset(h, -1, sizeof h);
	memset(dis1, 0x3f, sizeof dis1), memset(dis2, 0x3f, sizeof dis2);
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int a, b, c;
		cin >> a >> b >> c;
		add(a, b, c), add(b, a, c);
		ed[i] = { a, b, c };
	}
	dijkstra(1, dis1), dijkstra(n, dis2);
	memset(l, 0x3f, sizeof l);
	l[1] = 1;
	for (int i = n; i != 1; i = e[pre[i] ^ 1]) tot++, st[pre[i]] = st[pre[i] ^ 1] = true;
	for (int i = n, cnt = tot + 1; i != 1; i = e[pre[i] ^ 1], cnt--) l[i] = cnt, r[i] = cnt - 1;
	for (int i = 1; i <= n; i++) t[i] = i;
	sort(t + 1, t + n + 1, cmp1);
	for (int i = 1; i <= n; i++) {
		int u = t[i];
		for (int i = h[u]; ~i; i = ne[i]) {
			int v = e[i];
			if (st[i]) continue;
			if (dis1[u] + w[i] == dis1[v] && l[v] > l[u]) l[v] = l[u];
		}
	}
	for (int i = 1; i <= n; i++) t[i] = i;
	sort(t + 1, t + n + 1, cmp2);
	for (int i = 1; i <= n; i++) {
		int u = t[i];
		for (int i = h[u]; ~i; i = ne[i]) {
			int v = e[i];
			if (st[i]) continue;
			if (dis2[u] + w[i] == dis2[v] && r[v] < r[u]) r[v] = r[u];
		}
	}
	for (int i = 1; i <= m; i++) {
		if (st[(i - 1) << 1]) continue;
		int u = ed[i].u, v = ed[i].v, w = ed[i].w; // 注意考虑反向边。
		if (l[u] <= r[v]) {
			dp1[l[u]].push_back(dis1[u] + w + dis2[v]);
			dp2[r[v]].push_back(dis1[u] + w + dis2[v]);
		}
		if (l[v] <= r[u]) {
			dp1[l[v]].push_back(dis1[v] + w + dis2[u]);
			dp2[r[u]].push_back(dis1[v] + w + dis2[u]);
		}
	}
	for (int i = 1; i <= tot; i++) {
		for (LL x : dp1[i]) mn.insert(x);
		if (*mn.begin() > res) res = *mn.begin(), cnt = 1;
		else if (*mn.begin() == res) cnt++;
		for (LL x : dp2[i]) mn.erase(mn.find(x));
	}
	if (res == dis1[n]) cnt = m; // 特判答案为 m 的情况。
	cout << res << " " << cnt << "\n";
	return 0;
}
```

---

## 作者：jeffrey (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P2685)

这道题其实就是求删边完的最短路。

我们将 $1$ 到 $n$ 的最短路比拟为一条线段树。![](https://cdn.luogu.com.cn/upload/image_hosting/ihxa0p0t.png)

那么只有 $1$ 到 $n$ 的最短路上的边删掉才会对答案产生影响。我们假设删了 $(u,v,w)$ 这条边，那么就要走一条最短路以外的点，设为 $(x,y,z)$。![](https://cdn.luogu.com.cn/upload/image_hosting/ik1w68iv.png)

这个图中的 $p$ 和 $q$ 为与最短路最大覆盖的边数所对应的点，这不就是一个最短路树吗？不会的可以看一下[这个视频](https://www.bilibili.com/video/BV11ohDeREJb/?spm_id_from=333.999.0.0\&vd_source=f6d8113d63d465fb52921da524d843ac)。

那么可以得知 $p$ 为以 $1$ 为根的最短路树中 $x$ 和 $n$ 的 最近公共最先吗？$q$ 同理，就不描述了。

这样我们可以发现，$p$ 到 $q$ 中间每一条边被删了都可以走 $(x,y,z)$ 这条边从 $1$ 到 $n$，这相当于将这中间的所有边都会产生贡献，贡献应为 $dis_{1,x}+z+dis_{y,n}$，贡献是做 $\min$ 运算。

这不一眼线段树吗？但这还有一个更好写的做法，可以用并！查！集！
我们可以这样做，我们设并查集元素的父亲的定义为他所在的连续的已经被修改的最后一个元素的下一个元素，可以理解为，修改 $x$ 时，不修改 $x$，而是修改他右边第一个没被修改的地方。而我们可以发现这样修改，每个数只会被修改一次，我们只要按贡献从小到大排序即可求出。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1e6+10;
ll n,m;
ll head[N],nxt[N],to[N],w[N],tot=1,id[N];
ll dis1[N],disn[N];
ll dl[N],dr[N],cn;
ll v[N],vis[N],a[N],p=0,d[N];
void add(ll x,ll y,ll z)
{
    nxt[++tot]=head[x];
    head[x]=tot;
    to[tot]=y;
    w[tot]=z;
}
struct st
{
    ll x,d;
    friend bool operator<(st a,st b)
    {
        return b.d<a.d;
    }
};
struct tree
{
    ll x,l,r;
}t[N];
ll cnt=0;
bool cmp(tree a,tree b)
{
    return a.x<b.x;
}
priority_queue<st> q;
queue<ll> g;
void dijksra(ll s,ll *dis)
{
    q.push({s,0});
    memset(v,0,sizeof(v));
    while(!q.empty())
    {
        ll x=q.top().x,d=q.top().d;q.pop();
        if(v[x]) continue;
        v[x]=1;
        dis[x]=d;
        for(int i=head[x];i;i=nxt[i])
            q.push({to[i],d+w[i]});
    }
}
void bfs(ll *dl,ll *dis)
{
    for(int i=1;i<=p;i++)
    {
        g.push(a[i]);
        dl[a[i]]=a[i];//更快算lca的方法，我儿子的lca由我来推出
    }
    while(!g.empty())
    {
        ll x=g.front();g.pop();
        for(ll i=head[x];i;i=nxt[i])
        {
            ll y=to[i],z=w[i];
            if(dis[x]+z==dis[y]&&dl[y]==0)//算过了就不再算了
            {
                dl[y]=dl[x];
                g.push(y);
            }
        }
    }
}
ll f[N];
ll find(ll x)
{
    if(f[x]==x) return x;
    return f[x]=find(f[x]);//并查集
}
int main()
{
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=m;i++)
    {
        ll x,y,z;
        scanf("%lld%lld%lld",&x,&y,&z);
        add(x,y,z);
        add(y,x,z);
    }
    dijksra(1,dis1);
    dijksra(n,disn);
    
    ll x=1;
    a[++p]=1;
    //求出最短路径
    while(x!=n)
    {
        for(int i=head[x];i;i=nxt[i])
        {
            ll y=to[i],z=w[i];
            if(disn[x]==disn[y]+z)
            {
                x=y;
                a[++p]=y;
                vis[i]=vis[i^1]=1;
                break;
            }
        }
    }
    for(int i=1;i<=p;i++) id[a[i]]=i;
    bfs(dl,dis1);
    bfs(dr,disn);
    for(int i=1;i<=p+5;i++) f[i]=i;
    for(int i=2;i<=tot;i++)
    {
        if(vis[i]) continue;
        ll b=to[i],a=to[i^1];
        //答案的贡献
        if(dis1[a]<dis1[b])
        {
            t[++cn]={dis1[a]+w[i]+disn[b],id[dl[a]],id[dr[b]]-1};
            //这里要注意因为我们算的是边，而不是点，所以右端点-1
        }
    }
    sort(t+1,t+1+cn,cmp);
    ll ans=0,cnt=0;
    for(int i=1;i<=cn;i++)
    {
        ll x=find(t[i].l);
        while(x<=t[i].r&&x<=p-1)
        {
            d[x]=t[i].x;
            f[find(x)]=find(x+1);
            x=find(x+1);
        }//并查集部分
    }
    for(int i=1;i<=p-1;i++)
    {
        if(ans<d[i]) ans=d[i],cnt=1;
        else if(ans==d[i]) cnt++;
        //统计答案
    }
    if(ans==dis1[n]) cnt=m;//特判若删掉边答案不变，直接输出m
    cout<<ans<<' '<<cnt;
    return 0;
}
```

---

## 作者：EricWay1024 (赞：2)

这题时限 3 秒，因此可以考虑更暴力的做法。这里提供一个 [@iwowi](https://www.luogu.com.cn/user/258976) 想出来的思路。

首先，和其他题解一样，我们知道只有删去原图最短路上的一条边，才有可能影响答案。所以最暴力的做法就是找到一条最短路，直接枚举最短路上的边，删去，然后重新跑最短路。容易知道这是会 TLE 的。

然而，我们可以进一步缩小需要枚举的边的范围。首先我们用 Dijkstra 跑一个从 $1$ 开始的单源最短路，得到一个 $\text{dist}$ 数组。之后，我们建一个子图 $G'$，这个子图上的每条边都能出现在 **至少一条** 从 $1$ 到 $n$ 的最短路中（因为最短路可能不止一条）。这个子图的建立可以通过从 $n$ 开始跑一个 DFS 来完成，只需保证如果当前节点是 $u$，我们只转移到满足 $\text{dist}[u] = \text{dist}[v] + w$ 的节点 $v$ 即可，其中 $w$ 是 $u$ 和 $v$ 之间的边权。

现在我们在这个子图 $G'$ 上跑一个 Tarjan，求出它的所有割边。我们注意到，如果删去的一条边不是 $G'$ 的割边，那么既然 $G'$ 的连通性不变，从 $1$ 到 $n$ 的最短路一定不变。这就表示，在我们暴力枚举所删的边的时候，只需枚举 $G'$ 的割边即可。

这样做的时间复杂度显然和 $G'$ 的割边数量成正比，因此似乎可以构造数据把这个做法卡掉。不过，题目的数据跑出来最慢的一个点是 1.85 秒，足以通过本题 3 秒的时间限制。

代码如下。重申，这是 [@iwowi](https://www.luogu.com.cn/user/258976) 得出的思路和代码，我帮助 debug 并记录了下来。


```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5 + 10;
#define int long long
typedef pair<int, int> pii;
vector<pii> v[MAXN], nv[MAXN];
vector<int> ts;
int dfn[MAXN], low[MAXN], wd[MAXN << 1], dist[MAXN];
bool hash_s[MAXN << 1], bp[MAXN];
int n, m, t, cnt, tag = -1;
void tarjan(int i)
{
	t++;
	dfn[i] = low[i] = t;
	int len = nv[i].size();
	for (int j = 0; j < len; ++j)
	{
		int ni = nv[i][j].first, ns = nv[i][j].second;
		if (hash_s[ns])
			continue;
		hash_s[ns] = true;
		if (dfn[ni] == 0)
		{
			tarjan(ni);
			low[i] = min(low[i], low[ni]);
			if (low[ni] > dfn[i])
			{
				ts.push_back(ns);
				cnt++;
			}
		}
		else
		{
			low[i] = min(low[i], dfn[ni]);
		}
	}
}
void dij()
{
	priority_queue<pii, vector<pii>, greater<pii>> q;
	pii p = make_pair(0, 1);
	q.push(p);
	bool b[MAXN];
	memset(b, false, sizeof(b));
	while (!q.empty())
	{
		p = q.top();
		q.pop();
		int i = p.second, dis = p.first;
		if (b[i])
			continue;
		b[i] = true;
		int len = v[i].size();
		for (int j = 0; j < len; ++j)
		{
			int ni = v[i][j].first, ndis = v[i][j].second;
			ndis = wd[ndis];
			if (dist[ni] <= ndis + dis || v[i][j].second == tag)
				continue;
			dist[ni] = dis + ndis;
			q.push(make_pair(dist[ni], ni));
		}
	}
}
void dfs(int i)
{
	if (bp[i])
		return;
	bp[i] = true;
	if (i == 1)
		return;
	int len = v[i].size();
	for (int j = 0; j < len; ++j)
	{
		int ni = v[i][j].first, ns = v[i][j].second;
		if (dist[ni] + wd[ns] != dist[i])
			continue;
		nv[i].push_back(make_pair(ni, ns));
		nv[ni].push_back(make_pair(i, ns));
		dfs(ni);
	}
}
void re_set()
{
	for (int i = 1; i <= n; ++i)
	{
		dist[i] = INT_MAX;
	}
	dist[1] = 0;
}
signed main()
{
	cin >> n >> m;
	int m0 = m;
	re_set();
	for (int i = 1; i <= m; ++i)
	{
		int a, b, c;
		cin >> a >> b >> c;
  // 直接删去自环
		if (a == b)
		{
			i--, m--;
			continue;
		}
		v[a].push_back(make_pair(b, i)), v[b].push_back(make_pair(a, i));
		wd[i] = c;
	}
	dij();
	dfs(n);
	tarjan(1);
	int ans = 0;
	int flen = ts.size();
	if (flen == 0)
	{
		cout << dist[n] << ' ' << m0 << endl;
		return 0;
	}
	cnt = 0;
	for (int i = 0; i < flen; ++i)
	{
		tag = ts[i];
		re_set();
		dij();
		int temp = ans;
		ans = max(ans, dist[n]);
		if (ans == temp && dist[n] == ans)
			cnt++;
		else if (ans != temp)
			cnt = 1;
	}

	cout << ans << ' ' << cnt << endl;
	return 0;
}
```

---

## 作者：wangyibo201026 (赞：2)

## 前言

~~谁能告诉我为什么这道题是紫题，P1186 是蓝的，这两道题有什么不同吗？~~

Update：在毒瘤 hack 的折磨下，更新了代码，现已能通过本题。

## 思路

考虑必定是要断掉最短路上的边。

考虑一个事情，我们枚举每一条不在 $1 \to n$ 最短路上边，强制要求经过这条边，那么这个图就如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/gi4mt4zi.png)

我们强制选择 $x \to y$ 这一条边，那么我们假设 $1 \to n$ 的最短路与 $1 \to x$ 的最短路交点为 $a$，肯定会有一个交点。那么我们强制选择这条边的最短路长度便是 $1 \to x + w_{x, y} + y \to n$，但是我们想，这条新的最短路能够成立的话，那么 $a \to b$ 中的边就可以随便删除了！这一句话很重要。也就是说，如果删除的边是 $a \to b$，那么新的最短路就**可能**成为 $1 \to x \to y \to n$。

由于是可能，所以我们定义 $t_i$ 为 $1 \to n$ 这条最短路上删除第 $i$ 条边能够形成的新的最短路的最小值，我们枚举每条不在 $1 \to n$ 上的边 $x, y$，然后用上面那张图上 $a \to b$ 的边的 $t$ 对 $1 \to x \to y \to n$ 的值取个 $\min$。最后对于所有的 $t_i$ 取个 $\max$ 就可以了，统计一下个数就行了，但是如果有多条最短路，那么个数就是 $m$。

我们发现这个东西好像更新起来是连续的，所以我们可以用线段树维护，然后至于上图中的 $a, b$ 怎么求，我们在跑最短路的过程中记一下前驱结点，然后把最短路上的点的前驱记为自己，然后明显用并查集就可以维护了（想一想是为什么），$b$ 就是反过来求就可以了。

时间复杂度 $O(m \log m)$。

## 代码

如果有不懂的可以看代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

#define int long long
#define fir first
#define sec second

char _c; bool _f; template < class T > inline void read ( T &x ) {
	_f = 0, x = 0;
	while ( _c = getchar (), !isdigit (_c) ){
		if ( _c == '-' ) { _f = 1; }
	}
	while ( isdigit (_c) ){
		x = x * 10 + _c - '0', _c = getchar ();
		if (_f) { x = -x; }
	}
}

const int N = 1e5 + 5;
const int M = 4e5 + 5;

int n, m, len, ans, p;
int used[M], vis[N], dis1[N], dis2[N], fa[2][N], fir[N]; //  fir 维护 1 -> n 最短路上点是第几个，fa 维护并查集，dis1，dis2 维护最短路

int tree[M << 2];  // 线段树

void build ( int node, int lt, int rt ) {
	tree[node] = 1145141919;
	if ( lt == rt ) {
		return ;
	}
	int mid = lt + rt >> 1;
	build ( node << 1, lt, mid ), build ( node << 1 | 1, mid + 1, rt );
}

void update ( int node, int lt, int rt, int x, int y, int k ) {  // 线段树不用懒标记，用标记永久化
	if ( x <= lt && rt <= y ) {
		tree[node] = min ( tree[node], k );
		return ;
	}
	if ( y < lt || x > rt ) {
		return ;
	}
	int mid = lt + rt >> 1;
	update ( node << 1, lt, mid, x, y, k ), update ( node << 1 | 1, mid + 1, rt, x, y, k );
}

int query ( int node, int lt, int rt, int x ) {
	if ( lt == rt && lt == x ) {
		return tree[node];
	}
	if ( x < lt || x > rt ) {
		return 1145141919;
	}
	int mid = lt + rt >> 1;
	return min ( tree[node], min ( query ( node << 1, lt, mid, x ), query ( node << 1 | 1, mid + 1, rt, x ) ) );
}

int head[N], tot;

struct Node {
	int to, w, next;
} edges[M << 1];

void add ( int u, int v, int w ) {
	tot ++;
	edges[tot].to = v;
	edges[tot].w = w;
	edges[tot].next = head[u];
	head[u] = tot;
}

int find ( int x, int *fa ) {
	if ( x == fa[x] ) {
		return x;
	}
	return fa[x] = find ( fa[x], fa );
}

void dfs ( int x, int *fa ) {  // dfs 遍历
	if ( x == 1 ) {
		fir[x] = ++len;
		return ;
	}
	dfs ( fa[x], fa );
	fir[x] = ++len;
}

void dijkstra ( int s, int t, int *dis, int *fa ) {
	priority_queue < pair < int, int > > q;
	for ( int i = 0; i <= n; i ++ ) {
		dis[i] = 1145141919;
		vis[i] = false;
	}
	dis[s] = 0;
	q.push ( make_pair ( dis[s], s ) );
	while ( !q.empty () ) {
		int x = q.top ().second;
		q.pop ();
		if ( vis[x] ) {
			continue;
		}
		vis[x] = true;
		for ( int i = head[x]; i; i = edges[i].next ) {
			if ( dis[x] + edges[i].w < dis[edges[i].to] ) {
				dis[edges[i].to] = dis[x] + edges[i].w;
				q.push ( make_pair ( -dis[edges[i].to], edges[i].to ) );
				fa[edges[i].to] = x;
			}
		}
	}
	if ( s == 1 ) {
		dfs ( t, fa );
	}
	for ( int i = 1; i <= n; i ++ ) {  // 如果是最短路上的点，就把 fa 设为自己
		if ( fir[i] ) {
			fa[i] = i;
		}
	}
}

void Solve () {
	cin >> n >> m;
	for ( int i = 1; i <= m; i ++ ) {
		int u, v, w;
		cin >> u >> v >> w;
		add ( u, v, w ), add ( v, u, w );
	}
	dijkstra ( 1, n, dis1, fa[0] ), dijkstra ( n, 1, dis2, fa[1] );
	int x = 1;
	while ( x < n ) {  //  标记一下最短路上的边
		for ( int i = head[x]; i; i = edges[i].next ) {
			if ( dis2[edges[i].to] + edges[i].w == dis2[x] ) {
				x = edges[i].to;
				used[i] = true;
				break;
			}
		}
	}
	build ( 1, 1, len );
	for ( int i = 1; i <= n; i ++ ) {
		for ( int j = head[i]; j; j = edges[j].next ) {
			if ( !used[j] ) {
				int l = fir[find ( i, fa[0] )], r = fir[find ( edges[j].to, fa[1])] - 1;  // 由于这里是点的编号，所以要减一
				if ( l <= r ) {
					update ( 1, 1, len, l, r, dis1[i] + edges[j].w + dis2[edges[j].to] );
				}
			}
		}
	}
	for ( int i = 1; i < len; i ++ ) {
		int tmp = query ( 1, 1, len, i );
		if ( ans < tmp && tmp != 1145141919 ) {
			ans = tmp;
			p = 1;
		}
		else if ( ans == tmp && tmp != 1145141919 ) {
			p ++;
		}
	}
	cout << ans << " ";
	if ( ans == dis1[n] ) {  // 如果有多条最短路
		cout << m;
	}
	else {
		cout << p;
	}
}

signed main () {
	Solve ();
	return 0;
}
```

---

## 作者：liuyidu (赞：1)

[传送门](https://www.luogu.com.cn/problem/P2685)
[弱化版](https://www.luogu.com.cn/problem/P1186)

## 题意概要
求出在断了一条边的情况下，最短路的最大值，即最大化最小值问题。

## 分析
### 暴力:
比较好想到的思路枚举断边，然后求一次最短路，但是时间复杂度可以达到 $O(n^3)$，无法接受
稍微优化一下就是只删除原本最短路上的边，因为如果删的不是最短路上的边，该图的最短路是不可能变的，这个优化可以拿到 0 的高分。
考虑正解，只删除最短路上的边这个思路是固定的，复杂度的瓶颈在于每次删除之后都必须求一遍最短路，我们考虑有没有办法避开最短路直接求解。

### 性质:
> 最短路上原来必须要走，在钦定最短路外一条边必须走之后不再需要被走的边必然是连续的一条路径

proof： 我们令 $s→t$ 这条路径现在必须走，考虑最短路上原来的一条路径 $a→b→c→d$，假设 $a→b,c→d$ 这两段都是原来必须要走，现在不需要走的路径，而 $b→c$ 则始终要走。如果 $a→b$ 现在不需要走，那么必然存在一个走法绕过了 $a→b$：从 $1$ 走到了 $s→t$，再经过了一些边到了 $b$（必须会到达 $b$，不然无法保证 $b→c$ 是必须走的边；同时在 $b$ 之前必然会经过 $s→t$，否则我们原来就有一条不需要走 $a→b$ 的最短路径，和我们 $a→b$ 必须要走的假设冲突了；同理，存在走法从 $c$ 走到 $s→t$ 再到终点 $n$。那么显然，我们直接从 $t$ 到终点即可，为什么要走 $b→c$ 呢，由此得到假设矛盾。原命题得证。

### 正解：
 有了这个性质就可以去考虑正解了,我们枚举每条边,把边对应到我们原本的最短路径上,又由于不再被走的边必然是连续的一段区间，我们就可以用线段树实现一个区间修改，单点查询的操作。

### Code：
```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
using namespace std;
const int N=1e5+10,M=2e5+10,inf=INT_MAX;
int head[N],tot;
struct node {
	int to,val,nxt;
} edge[M<<1];
void addedge(int u,int v,int w) {
	edge[++tot]= {v,w,head[u]};
	head[u]=tot;
}
int n,m,len,ans,p;
int d1[N],dn[N],vis[N],fa[2][N],used[M<<1],fir[N];
int get(int x,int *fa) {
	return x==fa[x]?x:fa[x]=get(fa[x],fa);
}
void dfs(int u,int *fa) {
	if(u==1) {
		fir[u]=++len;
		return;
	}
	dfs(fa[u],fa);
	fir[u]=++len;
}
void dij(int S,int *dis,int *fa) {
	for(int i=1; i<=n; ++i)vis[i]=0,dis[i]=inf;
	dis[S]=0;
	priority_queue<pii,vector<pii>,greater<pii>> q;
	q.push(make_pair(0,S));
	while(!q.empty()) {
		pii now=q.top();
		q.pop();
		int u=now.second,d=now.first;
		if(dis[u]<d)continue;
		for (int i=head[u]; i; i=edge[i].nxt) {
			int v=edge[i].to,w=edge[i].val;
			if(dis[u]+w<dis[v]) {
				dis[v]=dis[u]+w;
				fa[v]=u;
				q.push(make_pair(dis[v],v));
			}
		}
	}
	if(S==1)dfs(n,fa);
	for(int i=1; i<=n; i++)
		if(fir[i])fa[i]=i;
}
struct Segment_Tree {
#define ls o<<1
#define rs o<<1|1
	int tr[M<<2];
	void build(int o,int l,int r) {
		tr[o]=inf;
		if(l==r)return;
		int mid=l+r>>1;
		build(ls,l,mid),build(rs,mid+1,r);
	}
	void modify(int o,int l,int r,int L,int R,int x) {
		if(l==L&&r==R) {
			tr[o]=min(tr[o],x);
			return ;
		}
		int mid=l+r>>1;
		if(mid>=R)modify(ls,l,mid,L,R,x);
		else if(mid<L)modify(rs,mid+1,r,L,R,x);
		else modify(ls,l,mid,L,mid,x),modify(rs,mid+1,r,mid+1,R,x);
	}
	int query(int o,int l,int r,int x) {
		if(l==r)return tr[o];
		int mid=l+r>>1;
		int res=0;
		if(x<=mid)res=query(ls,l,mid,x);
		else res=query(rs,mid+1,r,x);
		return min(res,tr[o]);
	}
} T;
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1,u,v,w; i<=m; ++i) {
		scanf("%d%d%d",&u,&v,&w);
		addedge(u,v,w),addedge(v,u,w);
	}
	dij(1,d1,fa[0]);
	dij(n,dn,fa[1]);
	int u=1;
	while(u<n) {
		for(int i=head[u]; i; i=edge[i].nxt) {
			int v=edge[i].to,w=edge[i].val;
			if (dn[v]+w==dn[u]) {
				u=v,used[i]=1;
				break;
			}
		}
	}
	T.build(1,1,len);
	for(int i=1; i<=n; i++) {
		for(int j=head[i]; j; j=edge[j].nxt) {
			if(!used[j]) {
				int v=edge[j].to,w=edge[j].val;
				int l=fir[get(i,fa[0])],r=fir[get(v,fa[1])]-1;
				if(l<=r)T.modify(1,1,len,l,r,d1[i]+w+dn[v]);
			}
		}
	}
	for(int i=1; i<len; i++) {
		int tmp=T.query(1,1,len,i);
		if(ans<tmp&&tmp!=inf)ans=tmp,p=1;
		else if(ans==tmp&&tmp!=inf)p++;
	}
	if(ans==d1[n])p=m;
	printf("%d",ans);
}
```

---

## 作者：FRZ_29 (赞：1)

[也许更好的阅读体验](https://www.cnblogs.com/FRZ29/p/18389986)
### 割边最短路
#### 约定
$1 \rightsquigarrow x$ 表示 $1$ 到 $x$ 的路径。  

$T(1 \rightsquigarrow x)$ 表示最短路树 $T$ 上 $1 \rightsquigarrow x$ 的经过的边的集合。

#### 思路
问题：给定一张**无向正权图**，对图上的每条边，求删去该边后 $1 \rightsquigarrow n$ 的最短路。  

首先求出 $1 \rightsquigarrow n$ 的最短路的路径 $P$，定义 $len$ 表示 $P$ 包含边的数量，从 $1 \sim len$ 对 $P$ 的每一条边进行编号。设 $e$ 表示当前考虑的边 $(i, j)$。

若 $e \notin P$，删去 $e$ 后对答案没有影响。

若 $e \in P$，考虑**从 $1$ 出发** 和 **到达 $n$** 的最短路树 $T_1$ 和 $T_n$，要求 $T_1, T_n$ 上 $1 \rightsquigarrow n$ 的路径等于 $P$（最短路树并不是唯一的）。 

枚举每一条边 $(u, v)$。若 $T_1(1 \rightsquigarrow u)$ 和 $T_n(v \rightsquigarrow n)$ 均不包含 $e$，即可用 $w(T_1(1\rightsquigarrow u)) + w(u \rightarrow v) + w(T_n(v \rightsquigarrow n))$ 更新最短路。

设 $l_u$ 表示最短路树 $T_1$ 上 $1 \rightsquigarrow u$ 与 $P$ 第一条不相交的边，$r_v$ 表示最短路树 $T_n$ 上节点 $v \rightsquigarrow n$ 与 $P$ 第一条不重合的边。

$l_u$ 与 $r_v$ 时容易求的，首先，若 $(u, v) \in P$，那么 $l_u = u$ 下一条边的编号，$r_v = v$ 上一条边的编号。

而当 $(u, v) \notin P$ 时，$l_v = \min(l_u, l_v), r_v = \max(r_u, r_v)$（注意边是无向的）。

对于一条不在 $P$ 上的边 $(u, v)$，若删去 $l_u \rightsquigarrow r_v$ 中任一边，**新的最短路**就可能经过 $(u, v)$，否则，必然不经过 $(u, v)$。

于是可以先预处理出删除 $l_u \rightsquigarrow r_v$ 后可能的结果。用 `multiset` 来维护考虑删除 $l_u \rightsquigarrow r_v$ 中任一边后**新的最短路**的最小值即可。

具体来说：定义两个数组 $A, B$，$A_i$ 用来记录 $l_u = i$（$i$ 为 $P$ 中边的编号） 的可能的最短路值，$B_i$ 用来记录 $r_v = i$ 时的最短路值，用 `multiset` 容器定义一个 $Min$ 来维护考虑到 $i$ 时可能的最短路。

当考虑到编号为 $i$ 的边时，将 $A_i$ 中数加入到 $Min$ 中，考虑完后，将 $B_i$ 中的数从 $Min$ 中删去。这样就可以准确的维护删去 $i$ 时的最短路。

#### 例题
[P2685 [TJOI2012] 桥](https://www.luogu.com.cn/problem/P2685)

题意简述：给定一张自环和重边的无向正权图，求删去某条边，使最短路最大。  

求该最短大小和删去边的方案。  

模版题。

```cpp
#include <algorithm>
#include <iostream>
#include <climits>
#include <cstring>
#include <cstdio>
#include <vector>
#include <ctime>
#include <queue>
#include <set>

using namespace std;

void RD() {}
template<typename T, typename... U> void RD(T &x, U&... arg) {
    x = 0; int f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + ch - '0', ch = getchar();
    x *= f; RD(arg...);
}

const int N = 1e5 + 4, M = 2e5 + 5;

#define FI first
#define SE second
#define PB push_back
#define PII pair<int, int>
#define FILL(x, y) memset(x, y, sizeof(x))
#define PRINT(x) cout << #x << "=" << x << "\n"
#define LF(i, __l, __r) for (int i = __l; i <= __r; i++)
#define RF(i, __r, __l) for (int i = __r; i >= __l; i--)

struct Edge { int u, v, w; } ed[M];
int head[N], ver[M << 1], Next[M << 1], edge[M << 1], tot = 1;
int dis1[N], dis2[N], pre[N], len, ans;
int l[N], r[N], t[N], res;
multiset<int> Min;
vector<int> dp1[N], dp2[N];
bool vis[N], st[M << 1];
int n, m;

bool cmp1(int a, int b) {
    return dis1[a] < dis1[b];
}

bool cmp2 (int a, int b) {
    return dis2[a] < dis2[b];
}

void add(int u, int v, int w) {
    ver[++tot] = v, edge[tot] = w;
    Next[tot] = head[u], head[u] = tot;
}

void dijkstra(int s, int* dis) {
    dis[s] = 0;
    FILL(vis, false);
    priority_queue<PII, vector<PII>, greater<PII>> que;
    que.push({0, s});
    
    while (que.size()) {
        int u = que.top().SE;
        que.pop();
        if (vis[u]) continue;
        vis[u] = true;

        for (int i = head[u]; i; i = Next[i]) {
            int v = ver[i], w = edge[i];

            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                if (s == 1) pre[v] = i;
                que.push({dis[v], v});
            }
        }
    }
}

int main() {
    RD(n, m);
    FILL(dis1, 0x3f), FILL(dis2, 0x3f);

    LF(i, 1, m) {
        int u, v, w;
        RD(u, v, w);
        add(u, v, w), add(v, u, w);
        ed[i] = {u, v, w};
    }

    dijkstra(1, dis1), dijkstra(n, dis2);
    FILL(l, 0x3f);
    l[1] = 1;
    for (int i = n; i != 1; i = ver[pre[i] ^ 1]) len++, st[pre[i]] = st[pre[i] ^ 1] = true;
    for (int i = n, cnt = len + 1; i != 1; i = ver[pre[i] ^ 1], cnt--) l[i] = cnt, r[i] = cnt - 1;
    LF(i, 1, n) t[i] = i;
    sort(t + 1, t + n + 1, cmp1);

    LF(i, 1, n) {
        int u = t[i];
        for (int i = head[u]; i; i = Next[i]) {
            int v = ver[i], w = edge[i];
            if (st[i]) continue;
            if (dis1[u] + w == dis1[v] && l[v] > l[u]) l[v] = l[u];
        }
    }

    LF(i, 1, n) t[i] = i;
    sort(t + 1, t + n + 1, cmp2);
    LF(i, 1, n) {
        int u = t[i];
        for (int i = head[u]; i; i = Next[i]) {
            int v = ver[i], w = edge[i];
            if (st[i]) continue;
            if (dis2[u] + w == dis2[v] && r[v] < r[u]) r[v] = r[u];
        }
    }

    LF(i, 1, m) {
        if (st[i << 1]) continue;
        int u = ed[i].u, v = ed[i].v, w = ed[i].w;
        
        if (l[u] <= r[v]) {
            dp1[l[u]].PB(dis1[u] + w + dis2[v]);
            dp2[r[v]].PB(dis1[u] + w + dis2[v]);
        }
        if (l[v] <= r[u]) {
            dp1[l[v]].PB(dis1[v] + w + dis2[u]);
            dp2[r[u]].PB(dis1[v] + w + dis2[u]);
        }
    }

    LF(i, 1, len) {
        for (int x : dp1[i]) Min.insert(x);
        if (*Min.begin() > res) res = *Min.begin(), ans = 1;
        else if (*Min.begin() == res) ans++;
        for (int x : dp2[i]) Min.erase(Min.find(x));
    }

    if (res == dis1[n]) ans = m;
    printf("%d %d", res, ans);
    return 0;
}
```

---


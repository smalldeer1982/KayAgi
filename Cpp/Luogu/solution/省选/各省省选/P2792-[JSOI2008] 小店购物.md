# [JSOI2008] 小店购物

## 题目背景

JSOI集训队的队员发现，在他们经常活动的集训地，有一个小店因为其丰富的经营优惠方案深受附近居民的青睐，生意红火。


## 题目描述

小店的优惠方案十分简单有趣：

一次消费过程中，如您在本店购买了精制油的话，您购买香皂时就可以享受 $2.00$ 元 / 块的优惠价；如果您在本店购买了香皂的话，您购买可乐时就可以享受 $1.50$ 元 / 听的优惠价……诸如此类的优惠方案可概括为：如果您在本店购买了商品 $A$ 的话，您就可以以 $P$ 元 / 件的优惠价格购买商品 $B$（购买的数量不限）。

有趣的是，你需要购买同样一些商品，由于不同的买卖顺序，老板可能会叫你付不同数量的钱。比如你需要一块香皂（原价 $2.50$ 元）、一瓶精制油（原价 $10.00$ 元）、一听可乐（原价 $1.80$ 元），如果你按照可乐、精制油、香皂这样的顺序购买的话，老板会问你要 $13.80$ 元；而如果你按照精制油、香皂、可乐这样的顺序购买的话，您只需付 $13.50$ 元。

该处居民发现 JSOI 集训队的队员均擅长电脑程序设计，于是他们请集训队的队员编写一个程序：在告诉你该小店商品的原价，所有优惠方案及所需的商品后，计算至少需要花多少钱（不允许购买任何不必要的商品，即使这样做可能使花的钱更少）。

## 说明/提示

数据范围见输入格式


## 样例 #1

### 输入

```
4
10.00 1
1.80 1
3.00 0
2.50 2
2
1 4 2.00
4 2 1.50```

### 输出

```
15.50```

# 题解

## 作者：D_14134 (赞：14)

## 最小树形图--朱刘算法
通过不断调整来实现最优解。

大致思路如下：

首先去掉自环。

用贪心的思想给每个点选择一条最小的入边，记录连接的点。

特判此时如果有点没有入边(除根以外)，显而易见此时无解。
算上每个点入边的代价，统计答案。

此时判定有没有有向环，如果没有直接输出。
如果有有向环，缩点，并且把连出去的边都减去连出去的点的入边，因为代价已经统计。
二次建图（或多次），对新图重复所有操作。
# code
```
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=100010;
const double inf=0x7f7f7f;
int n,tot,m,cnt,need[maxn],pre[maxn],vis[maxn],id[maxn];
double ans,cost[maxn],prize,inw[maxn];
struct Edge{
    int u,v;
    double w;
}e[maxn];
inline void mst(){
    register int num=n,rt=1,idx;
    while(1){// 初始化
        for(register int i=1;i<=num;++i) id[i]=vis[i]=pre[i]=-1,inw[i]=inf;// 选入边
        for(register int i=1;i<=cnt;++i)
            if(inw[e[i].v]>e[i].w&&e[i].u!=e[i].v) inw[e[i].v]=e[i].w,pre[e[i].v]=e[i].u;
        pre[rt]=rt,idx=inw[rt]=0;// 缩环，统计贡献
        for(register int i=1;i<=num;++i){
            ans+=inw[i];
            if(vis[i]==-1){
                register int nw=i;
                while(vis[nw]==-1) vis[nw]=i,nw=pre[nw];
                if(vis[nw]==i&&nw!=rt){
                    id[nw]=++idx;
                    for(register int j=pre[nw];j!=nw;j=pre[j]) id[j]=idx;
                }
            }
        }// 没有环结束
        if(!idx) return; // 重标号，记录新图
        for(register int i=1;i<=num;++i) if(id[i]==-1) id[i]=++idx;
        for(register int i=1;i<=cnt;++i)
            e[i].w -=inw[e[i].v],e[i].u=id[e[i].u],e[i].v=id[e[i].v];
        num=idx,rt=id[rt];
    }
}

int main(){
    scanf("%d",&tot),n=2;
    for(register int i=1;i<=tot;++i){
        scanf("%lf%d",&cost[n],&need[n]);
        if(need[n]) e[++cnt]=(Edge){1,n,cost[n]},vis[i]=n++;
    }
    --n,scanf("%d",&m);
    for(register int i=1,a,b;i<=m;++i){
        scanf("%d%d%lf",&a,&b,&prize);
        a=vis[a],b=vis[b];
        if(a && b){
            cost[b]=min(cost[b],prize);
            e[++cnt]=(Edge){a,b,prize};
        }
    }
    for(register int i=2;i<=n;++i) ans+=(need[i]-1)*cost[i];
    mst();
    printf("%.2lf\n",ans);
    return 0;
}
```

---

## 作者：chihik (赞：8)

给出一个易于理解且好写的做法。

有一个贪心做法，

- 从源点向每一种商品连 $c_i \times m_i$ 的边。

- 对于优惠方案 $(A,B,P)$ , 从 $A$ 向 $B$ 连 $P \times m_B$ 的边。

最后源点的[最小树形图](https://www.luogu.com.cn/problem/P4716)即为答案?

这样做显然有问题，因为如果同时存在优惠方案 $(A,B)$ 和 $(B,A)$ ，那么先买一件 $A$ , 再用优惠价买完 $B$ , 然后用优惠价买完 $A$，这种方案可能更优。

所以可以将一件商品拆成 $2$ 个点，表示买 $1$ 件和买 $m_i-1$ 件，连边方式同上。

注意细节，不要多建新点。

```cpp
#include <cstdio>
#include <cstring>
#define Inf 1e9

const int MAXN = 100 , MAXM = MAXN * ( MAXN + 1 );

int m;
struct Edge{ int u , v; double w; Edge(){} Edge( int U , int V , double W ) { u = U , v = V , w = W; } } Graph[ MAXM + 5 ];
void Add_Edge( int u , int v , double w ) { Graph[ ++ m ] = Edge( u , v , w ); }

int n , k , rt , num[ MAXN + 5 ];
struct node { int v; double w; node(){} node( int V , double W ) { v = V , w = W; } } pre[ MAXN + 5 ];
int vis[ MAXN + 5 ] , bel[ MAXN + 5 ];
double Zhuliu( int rt ) {
    double Ans = 0;
    while( 1 ) {
        for( int i = 1 ; i <= n ; i ++ ) pre[ i ] = node( 0 , Inf );
        for( int i = 1 ; i <= m ; i ++ ) {
            int u = Graph[ i ].u , v = Graph[ i ].v; double w = Graph[ i ].w;
            if( u != v && pre[ v ].w > w ) pre[ v ] = node( u , w );
        }
        for( int i = 1 ; i <= n ; i ++ ) if( i != rt && !pre[ i ].v ) return -1;
        
        int cnt = 0;
        memset( vis , 0 , sizeof( vis ) );
        memset( bel , 0 , sizeof( bel ) );
        for( int i = 1 , u ; i <= n ; i ++ ) {
            if( i == rt ) continue; Ans += pre[ i ].w;
            for( u = i ; u != rt && vis[ u ] != i ; vis[ u ] = i , u = pre[ u ].v );
            if( u != rt && !bel[ u ] ) {
                bel[ u ] = ++ cnt;
                for( ; u != rt && !bel[ pre[ u ].v ] ; u = pre[ u ].v , bel[ u ] = cnt );
            }
        }
        if( !cnt ) break;
        for( int i = 1 ; i <= n ; i ++ ) if( !bel[ i ] ) bel[ i ] = ++ cnt;
        for( int i = 1 ; i <= m ; i ++ ) {
            int u = Graph[ i ].u , v = Graph[ i ].v; double w = Graph[ i ].w;
            Graph[ i ].u = bel[ u ] , Graph[ i ].v = bel[ v ];
            if( bel[ u ] != bel[ v ] ) Graph[ i ].w = w - pre[ v ].w;
        }
        n = cnt; rt = bel[ rt ];
    }
    return Ans;
}

int cnt , id[ MAXN + 5 ][ 2 ];
double c;
int main( ) {
    scanf("%d",&n); rt = ++ cnt;
    for( int i = 1 ; i <= n ; i ++ ) {
        scanf("%lf %d",&c,&num[ i ]);
        if( num[ i ] > 0 ) id[ i ][ 0 ] = ++ cnt , Add_Edge( rt , id[ i ][ 0 ] , c );
        if( num[ i ] > 1 ) id[ i ][ 1 ] = ++ cnt , Add_Edge( rt , id[ i ][ 1 ] , c * ( num[ i ] - 1 ) );
    }
    scanf("%d",&k);
    for( int i = 1 , u , v ; i <= k ; i ++ ) {
        scanf("%d %d %lf",&u,&v,&c);
        if( num[ u ] > 0 && num[ v ] > 0 ) Add_Edge( id[ u ][ 0 ] , id[ v ][ 0 ] , c );
        if( num[ u ] > 0 && num[ v ] > 1 ) Add_Edge( id[ u ][ 0 ] , id[ v ][ 1 ] , c * ( num[ v ] - 1 ) );
        if( num[ u ] > 1 && num[ v ] > 0 ) Add_Edge( id[ u ][ 1 ] , id[ v ][ 0 ] , c );
        if( num[ u ] > 1 && num[ v ] > 1 ) Add_Edge( id[ u ][ 1 ] , id[ v ][ 1 ] , c * ( num[ v ] - 1 ) );
    }
    n = cnt;
    printf("%.2f\n", Zhuliu( rt ) );
    return 0;
}
```

---

## 作者：倾城ファン恋 (赞：4)

题解：

先要了解一下什么是**最小树形图**

http://blog.csdn.net/wsniyufang/article/details/6747392

然后由于所有要买的东西都最少有一个，所以对于每一种东西他除了第一件以外肯定可以用最低的价格买剩下的

然后对于第一个如何来买，我们这样构图

先加一个额外的点，它向每种东西连一条权值为原价的有向边

然后对于一个优惠关系(a,b)，我们从a向b连一条权值为优惠价的有向边

然后作一遍最小树形图即可

如果一种物品要买的数量为0，则将其除去

每一种物品，除第一件外，都可用最低的价格买到

  
  
  
  
```cpp
#include <iostream>  
#include <cstdio>  
#include <cstring>  
using namespace std;  
const double E=1<<30;  //定义无穷大，为后面做准备
const int maxn=105,maxm=10005;  
int a,b,c,m,n,root;  
int k[maxn],lk[maxn]; double p,cost[maxn];  //分别统计数组
int u[maxm],v[maxm]; double w[maxm],ans;  
int pre[maxn],f[maxn]; double mincost[maxn];  
inline double mn (double &x,double &y) {  //返回小值，用cmath中的min函数也可以
    if (x<y) return x;  
    return y;  
}  
void work () {  //构建最小树形图,从每个子树中枚举答案(不能用二分，因为你无法排序)
    int i,j,x,cnt;  
    while (1) {  
        for (i=1;i<=n;i++) mincost[i]=E;  
        for (i=1;i<=m;i++)  
            if (w[i]<mincost[v[i]]&&u[i]!=v[i]) {  //构建树
                mincost[v[i]]=w[i];  
                pre[v[i]]=u[i];  
            }  
        memset (lk,-1,sizeof (lk));  //清空成无法到达的值
        memset (f,0,sizeof (f));  //清0
        mincost[root]=0; cnt=0;  
        for (i=1;i<=n;i++) {  
            ans+=mincost[i]; x=i;  
            while (f[x]!=i&&x!=root) {  
                f[x]=i; x=pre[x];  
            }  
            if (x!=root&&lk[x]==-1) {  
                for (j=pre[x],cnt++;j!=x;j=pre[j])  
                    lk[j]=cnt;  
                lk[x]=cnt;  
            }  
        }  
        if (cnt==0) break;  //如果计数器为0，说明不可行（如果一种物品要买的数量为0，则将其除去）
        for (i=1;i<=n;i++)  
            if (lk[i]==-1) lk[i]=++cnt;  
        for (i=1;i<=m;i++) {  //利用树的性质查找
            x=v[i]; u[i]=lk[u[i]]; v[i]=lk[v[i]];  
            if (u[i]!=v[i]) w[i]-=mincost[x];  
        }  
        n=cnt; root=lk[root];  
    }  
}  
int main () {  
    scanf ("%d",&b);  
    for (a=1,n=1;a<=b;a++){  
        scanf ("%lf %d",&cost[n],&k[n]);  
        if (k[n]==0) continue;  
        k[n]--; lk[a]=n++;  
    }  
    for (a=1,root=n;a<n;a++) {  //将数据转成树
        u[++m]=n; v[m]=a;  
        w[m]=cost[a];  
    }  
    scanf ("%d",&a);  
    while (a--) {  //前序工作,为后面的work做准备
        scanf ("%d %d %lf",&b,&c,&p);  
        b=lk[b]; c=lk[c]; if (b==0||c==0) continue;  
        if (p<cost[c]) cost[c]=p;  
        u[++m]=b; v[m]=c; w[m]=p;  
    }  
    for (a=1;a<n;a++) ans+=cost[a]*k[a];  
    work (); 
    printf ("%.2lf\n",ans);  
    return 0;  
}  //这题目比较难，**请大家不要ctrl+c,ctrl+v哦；**祝大家天天开心！！！
```

---

## 作者：ww3113306 (赞：3)

emmm，，，最小树形图板子题，，，挂一个自认为很好看的代码（代码中有详细注释 + 我曾经错过的地方的标识）
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
#define R register int
#define AC 60
#define ac 10000
int n, m, s, tot, cnt, tmp;
int last[AC], id[AC], buy[AC], vis[AC]; 
int Stack[AC], top;//栈，辅助找环
double ans;
double in[AC];

struct road{
    int x,y;double Size;
}way[ac];
/*注意到一件事：优惠政策与买的件数无关，也就是说不管买了多少，只要买了就可以优惠，
这就意味着构造最小树形图的时候边权应该按照1的来算，因为如果要购买多件的话，可以等到最后
已经买完了所有物品再用最低价购买(肯定可以达到最低价格），
因为第一次购买的时候是不允许出现环的，（不然的话先购买哪个？肯定有个先后顺序的啊）
但是后来买就无所谓了，因为东西反正都买了，就比如说买a再买b可以优惠5元，买b再买a可以优惠10元，
这个时候显然先买b再买a，但我们可以只买一个b，这样的话买完a和b后再购买剩下的b时就可以每件优惠5元了
1，确定一个根(建立超级源点）
2，找到除根外每一个点的最小入边，若这些边构成了环（此时必然不联通），则缩环成点，并将环内的每一个点的其他入边都减去环内的入边，
3，重复步骤2直到没有环出现（构成了树）。

因为边很少，所以只能形成一个很简单的环，又因为s没有入度，所以s不可能出现在环内，
所以说可以从s出发dfs一遍，如果有点没被访问到就是有环？？？？

或者说不用bool记录有没有被访问，而是用vis记录访问它的是谁，因为不能被同一个点多次访问，
但被多个点一次访问是合法的
*/

inline void upmin(double &a,double b)
{
    if(b < a) a = b;
}

void pre()
{
    double a;int b,c;
    scanf("%d", &n);
    memset(in, 127, sizeof(in));//原来127是很大的？
    s = n + 1;
    for(R i = 1; i <= n; i++)
    {
        scanf("%lf%d", &a, &buy[++tot]);
        if(!buy[tot]) 
        {
            --tot;
            continue;
        }
        --buy[tot];//因为第一个是在建树的时候买的
        id[i] = tot;//防止不用买的商品占位置
        way[++cnt] = (road){s, tot, a};
        upmin(in[tot], a);//找到最低价
    }
    scanf("%d", &m);
    for(R i = 1; i <= m; i++)
    {
        scanf("%d%d%lf", &b, &c, &a);
        if(!id[b] || !id[c]) continue;
        way[++cnt] = (road){id[b], id[c], a};
        upmin(in[id[c]], a);//获取最低价格
    }
}

void init()
{
    for(R i=1;i<=tot;i++)//因为每次标号都要重置，所以现在赶紧加上贡献
        if(buy[i]) ans += in[i] * (double)buy[i];//直接枚举标号
}

void find()//找环
{//error!!!虽然说都是简单环，但是这并不妨碍环有出边，，，，因此还要判断不要误入之前进过的环了
    int x;
    for(R i = 1; i <= tot; i++)//直接枚举标号
    {
        top = 0;
        ans += in[x = i];//获取新最小边贡献 + 顺便赋值
        if(id[x]) continue;//如果已经被发现在环内就加上贡献走人
        while(1)//找环
        {
            if(vis[x] == i || x == s || id[x]) break;//error!!!不要误入之前进过的环了(id[x])
            vis[x] = i;
            Stack[++top] = x;//存入栈
            x = last[x];
        }
        if(x == i && !id[x])//如果终点被多次访问,error!!!之前进过的环就别去了(id[x])
        {//error!!!应该是起点被多次访问，而不是终点，回到起点才是一个环，不然一个环的外向边可能会导致有别的点“误入”环内
            ++tmp;
            while(x = Stack[top--]) id[x] = tmp;//给环内所有节点都赋上同一个编码
        }
    }
}
        
void get_in()//找最短边 & 前驱
{
    int x;
    memset(in, 127, sizeof(in));//重置最短边
    for(R i = 1; i <= cnt; i++)//直接枚举边，这样更省时
    {
        x = way[i].y;//存下目标点
        if(way[i].x == x) continue;//如果在一个点里那就算了
        if(way[i].Size < in[x])
        {
            last[x] = way[i].x;
            in[x] = way[i].Size;//更新最短边
        }
    }
}
        
void work()
{
    while(1)
    {
        get_in();
        memset(id, 0, sizeof(id));//重置标号
        memset(vis, 0, sizeof(vis));//重置访问标记
        id[s] = s, tmp = 0;//重置标号计数,error!!!注意id[s]永远是s
        find();
        if(!tmp)//如果没有找到环就退出
        {
            printf("%.2lf\n",ans);
            return ;
        } 
        for(R i = 1; i <= tot; i++)
            if(!id[i]) id[i] = ++tmp;//如果还没有编号，就统一编号
        tot = tmp;
        for(R i = 1; i <= cnt; i++)//每次都更新所有边的所有信息
        {
            way[i].Size -= in[way[i].y];//权值减去入边的最小边权值
            way[i].x = id[way[i].x];//赋为新点
            way[i].y = id[way[i].y];
        }
    }
}

int main()
{
//	freopen("in.in","r",stdin);
    pre();
    init();
    work();	
//	fclose(stdin);
    return 0;
}
```

---

## 作者：crescentic (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P2792)

~~朱刘算法好，朱刘算法妙，朱刘算法……~~

### 题目分析

题目要求购买所有需要商品的最小花费值。而重点在于**优惠方案**：

>如果您在本店购买了商品A的话，您就可以以P元/件的优惠价格购买商品B（购买的数量不限）。

意思就是，假设优惠方案为 $A$ 和 $B$，则只要购买 $A$的数量 $\ge$ $1$，就可以得到优惠。

### 解题思路

题目很明显是最小树形图，如果不会，出[门](https://www.baidu.com/)左转。

那么重点就在于如何**建边**？

可以先假设每种商品都买了一件，那么所有优惠方案都可以使用。就直接循环得出每件商品的最低价格，求出剩余件数的**费用和**。

然后在前面假设情况（每种购买一件）的最优方案。

仔细想想，就是求一个无根有向图的最小树形图。在一个优惠方案中建一条边，将每个商品与虚拟根连一条边，跑朱刘就行啦。

**注意点：**

- 如果一个商品不需要购买直接跳过，因此要先判断，重新给每种商品编号。

```cpp
	if(!t[i]) continue;
	tag[i] = ++num;

```
- 同样，如果一个优惠方案中任意一件不需要购买，也直接跳过。

```cpp
	if(!tag[b] || !tag[c]) continue;
```
- 最后注意建的是**有向边**，千万不要手残。

朱刘模板就不用说了吧？~~我也不知道怎么讲~~
### 完整代码

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define rt register int
const int N = 55;
const double inf = 1e8;
int n,s,tot,cnt,num,id[N],tag[N],t[N],pre[N],vis[N];
double val[N],dis[N],res;
/*
	id:从属的连通块编号
	tag:商品重新的编号
	t:需要购买的数量
	cnt:连通块数量 
	tot:建边数量 
	pre/vis/dis: :朱刘算法所需的模板数组
*/
struct node {
	int fro,to;double w;
}e[N * N];
inline void zhuliu(int root) {
	int u,v,ver;
	while(1) {
		for(rt i = 1; i <= num; i ++) dis[i] = inf;
		for(rt i = 1; i <= tot; i ++) {
			u = e[i].fro, v = e[i].to;
			if(u != v && dis[v] > e[i].w) pre[v] = u, dis[v] = e[i].w;
		}
		for(rt i = 1; i <= num; i ++) {
			if(i != root && dis[i] == inf) return;
		}
		cnt = 0;
		memset(id,0,sizeof(id));
		memset(vis,0,sizeof(vis));
		dis[root] = 0;
		for(rt i = 1; i <= num; i ++) {
			res += dis[i], ver = i;
			while(vis[ver] != i && !id[ver] && ver != root) {
				vis[ver] = i, ver = pre[ver];
			}
			if(ver != root && !id[ver]) {
				id[ver] = ++cnt;
				for(rt j = pre[ver]; j != ver; j = pre[j]) id[j] = cnt;
			}
		}
		if(!cnt) break;
		for(rt i = 1; i <= num; i ++) {
			if(!id[i]) id[i] = ++cnt;
		}
		for(rt i = 1; i <= tot; i ++) {
			u = e[i].fro, v = e[i].to;
			e[i].fro = id[u], e[i].to = id[v];
			if(id[u] != id[v]) e[i].w -= dis[v];
		}
		num = cnt, root = id[root];
	}
}
inline void read(int &x) {
	x = 0;
	char s = getchar();
	while(s < '0' || s > '9') s = getchar();
	while(s <= '9' && s >= '0') x = x * 10 + s - '0', s = getchar(); 
}
int main() {
	read(n);
	s = ++num;
	int b,c,k;
	double a;
	for(rt i = 1; i <= n; i ++) {
		dis[i] = inf;
		scanf("%lf",&a); read(t[i]);
		if(!t[i]) continue;
		tag[i] = ++num;
		dis[i] = min(dis[i],a);
		e[++tot] = (node) {s,num,a};
	}
	read(k);
	while(k--) {
		read(b), read(c), scanf("%lf",&a);
		if(!tag[b] || !tag[c]) continue;
		e[++tot] = (node) {tag[b],tag[c],a};
		dis[c] = min(dis[c],a);
	}
	for(rt i = 1; i <= n; i ++) {
		if(t[i] > 1) res += dis[i] * (t[i] - 1);//记得减 1 
	}
	zhuliu(s);
	printf("%.2lf",res);
	return 0;
}
```


---

## 作者：12345678hzx (赞：1)

# 思路

最小树形图。

最小树形图的定义可以类比最小生成树，但两者的区别是一个是有向图，另一个是无向图。

求解最小生成树的 kruskal 算法和 prim 算法不能适用于有向图的原因是有向图不是双向联通的，而无向图双向联通的性质可以运用连通块思想，如 kruskal 算法中使用并查集维护，而有向图则不行。

求解最小树形图有一种算法叫朱刘算法，如果不会的可以看看[这篇博客](https://blog.csdn.net/dajiangyou123456/article/details/105137781)。

下面我来简要概括下朱刘算法的步骤。

首先确定一个根，接下来找到除根外每一个点的最小入边，若这些边构成了环，则缩环成点，并将环内的每一个点的其他入边都减去环内的入边，重复以上步骤，直到图中没有环出现，根据树的定义，此时整张图就是一颗树。

每次缩完点之后的点与其他点构成新图，应当把缩完的点当做一个新点，一旦我们连上这条新边，意味着我们要放弃一条环内的边，所以我们要删去入边，但这并不好操作，注意到我们的目标仅仅是权值，所以我们将每个点在环外入边的权值减去环内入边的权值，所以当我们连上一条新边时，这样操作的实际效果在权值上和删去环内入边是等效的，只是减的地方不同而已，反正我们是将权值求和，这是朱刘算法的精髓。

放一张百度百科上的图。

![](https://cdn.luogu.com.cn/upload/image_hosting/nb4w3n2u.png)

---

## 作者：神眷之樱花 (赞：1)

# 题面
[小店购物](https://www.luogu.com.cn/problem/P2792)
# 题解
这道题建边方式很套路。

定义有向边 $(u,v,w)$ 表示买了 $u$ 之后，能以边权 $w$ 的价格买 $v$ 。

对于原价的物品，建一个超级源点，分别连接每个物品。对于特价的物品，根据以上的定义，连接两个有依赖关系的物品。

因为通过这样的定义方式，每个物品  $v$ 能被买，当且仅当 $u$ 被买，为了花费最小，所以我们肯定要选取其中边权最小的边。

所以最后就会发现，要买完所有的物品，其实就是求这幅有向图的最小树形图。

根据贪心的思想，因为每个物品都要买 (对于不用买的物品，我们可以看做是以 $0$ 的价格买入)，而以能以它的最低价格买就以它的最低价格买肯定是最优的 (即 $u$ 是要买的)，所以我们在满足这个条件的前提下，记录最小的价格，先提前算出买 $tot_i - 1$ 个物品的价格，然后跑最小树形图算出买剩余的一个的价格。

最小树形图自然就是用朱刘算法啦。

### 小细节
* 对于买 $u$ 优惠 $v$ 而 $u$ 不用买的情况，边权应该为无穷大。
# 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int INF = 1e9;
const int N = 105;
const int M = N * N + 5;
double in[N],val[N],w;  
int pre[N],tot[N],vis[N],id[N];
struct edge{
    int from,to;
	double dis;
}a[M];
double work(int n,int m,int root) {
	double ans = 0;
	while(true){
		for(int i = 1;i <= n; i++) in[i] = INF;
		for(int i = 1;i <= m; i++){
			int u = a[i].from,v = a[i].to;
			if(u != v && a[i].dis < in[v])
				in[v] = a[i].dis,pre[v] = u;
		}
		int cnt = 0;
		memset(vis,0,sizeof(vis));
		memset(id,0,sizeof(id));
		for(int i = 1;i <= n;i++){
			if(i == root)continue;
			ans += in[i];
			int v = i;
			while(vis[v] != i && !id[v] && v != root)
				vis[v] = i,v = pre[v];
			if(!id[v] && v != root){
				id[v] = ++cnt;
				for(int u = pre[v];u != v;u = pre[u])
					id[u] = cnt;
			}
		}
		if(cnt == 0) break;
		for(int i = 1;i <= n;i++)
			if(!id[i]) id[i] = ++cnt;
		for(int i = 1;i <= m;i++){
			int u = a[i].from,v = a[i].to;
			a[i].from = id[u],a[i].to = id[v];
			if(id[u] != id[v]) a[i].dis -= in[v];
		}
		root = id[root];
		n = cnt;
	}
	return ans;
}
int main(){
    int n,m;
    scanf("%d",&n);
    for(int i = 1; i <= n; i++) {
    	scanf("%lf%d",&val[i],&tot[i]);
    	a[i].from = n + 1;
		a[i].to = i; a[i].dis = tot[i] == 0 ? 0 : val[i];
	}
    scanf("%d",&m);
	for(int i = 1,u,v; i <= m; i++) {
		scanf("%d%d%lf",&u,&v,&w);
		if(tot[u] == 0) {
			a[n + i].from = u;
			a[n + i].to = v; a[n + i].dis = INF;
		}
		else if(tot[v] == 0) {
			a[n + i].from = u;
			a[n + i].to = v; a[n + i].dis = 0;
		} 
		else {
			a[n + i].from = u;
			a[n + i].to = v; a[n + i].dis = w;
			val[v] = min(val[v],w);
		}	
	} double res = 0;
	for(int i = 1; i <= n; i++)
		if(tot[i]) res += (tot[i] - 1) * val[i];
    res += work(n + 1,n + m,n + 1);
    printf("%.2lf\n",res);
    return 0;
}
```



---

## 作者：freoepn (赞：0)

考虑使用最小树形图，将所有物品连接到超级源上，边权为买齐该物品所需的代价，再按照优惠关系将物品之间连边，边权为按优惠价买齐该物品所需的代价。但有可能出现先购买一部分物品 $A$ 来解锁物品 $B$ 的优惠，然后购买物品 $B$ ，再用购买物品 $B$ 所得到的物品 $A$ 的优惠来买齐剩余的物品 $A$ 的情况，这样就会出现同一种物品购买价格不一样的情况，考虑到一种物品买了一件后就能解锁购买该物品的所有优惠，所以一种物品中顶多只有一件物品购买价格不同，将每种物品拆点成一件和 $m-1$ 件拆点做即可。


```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, r, k;
double ans = 0;
const int kMaxN = 10005;
struct node {
  int x, y;
  double z;
} e[kMaxN];
int num[kMaxN];
double mini[kMaxN];
int fa[kMaxN], cir[kMaxN], faa[kMaxN];
double solve() {
  while (1) {
    // cout << n << '\n';
    int sum = 0;
    for (int i = 1; i <= n; i++) {
      mini[i] = 1e9, cir[i] = faa[i] = fa[i] = 0;
    }
    for (int i = 1; i <= m; i++) {
      if (e[i].x != e[i].y && mini[e[i].y] > e[i].z) {
        mini[e[i].y] = e[i].z;
        fa[e[i].y] = e[i].x;
      }
    }
    mini[r] = fa[r] = 0;
    for (int i = 1; i <= n; i++) {
      if (!cir[i]) {
        int x = i;
        while (x != r && faa[x] != i && !cir[x]) faa[x] = i, x = fa[x];
        if (x != r && !cir[x]) {
          int y = x;
          cir[x] = ++sum, x = fa[x];
          while (x != y) {
            cir[x] = sum;
            x = fa[x];
          }
        }
      }
    }
    for (int i = 1; i <= n; i++) {
      if (!cir[i]) cir[i] = ++sum;
    }
    for (int i = 1; i <= n; i++) {
      ans += mini[i];
    }
    if (sum == n) {
      return ans;
    }
    for (int i = 1; i <= m; i++) {
      e[i].z -= mini[e[i].y], e[i].x = cir[e[i].x], e[i].y = cir[e[i].y];
    }
    r = cir[r], n = sum;
  }
}
int id[kMaxN][2];
int p = 1;
int c(int x, int y) {
  return (id[x][y] ? id[x][y] : id[x][y] = ++p);
}
int main() {
  cin >> n;
  r = 1;
  for (int i = 1; i <= n; i++) {
    double x;
    cin >> x >> num[i];
    if (num[i]) {
      e[++m] = {1, c(i, 0), x};
    }
    if (num[i] > 1) {
      e[++m] = {1, c(i, 1), x * (double)(num[i] - 1)};
    }
  }
  cin >> k;
  for (int i = 1; i <= k; i++) {
    int x, y;
    double z;
    cin >> x >> y >> z;
    if (num[x] > 0 && num[y] > 0) {
      e[++m] = {c(x, 0), c(y, 0), z};
    }
    if (num[x] > 1 && num[y] > 0) {
      e[++m] = {c(x, 1), c(y, 0), z};
    }
    if (num[x] > 0 && num[y] > 1) {
      e[++m] = {c(x, 0), c(y, 1), z * (double)(num[y] - 1)};
    }
    if (num[x] > 1 && num[y] > 1) {
      e[++m] = {c(x, 1), c(y, 1), z * (double)(num[y] - 1)};
    }
  }
 //for(int i = 1;i <= m;i++){
 //  cout << e[i].x << " "<< e[i].y <<" "<< e[i].z<< '\n';
 //}
  n = p;
 printf("%.2lf",solve());
}
```

---


# [FJOI2014] 最短路径树问题

## 题目描述

给一个包含 $n$ 个点，$m$ 条边的无向连通图。从顶点 $1$ 出发，往其余所有点分别走一次并返回。

往某一个点走时，选择总长度最短的路径走。若有多条长度最短的路径，则选择经过的顶点序列字典序最小的那条路径（如路径 A 为 $1,32,11$，路径 B 为 $1,3,2,11$，路径 B 字典序较小。注意是序列的字典序的最小，而非路径中节点编号相连的字符串字典序最小）。到达该点后按原路返回，然后往其他点走，直到所有点都走过。

可以知道，经过的边会构成一棵最短路径树。请问，在这棵最短路径树上，最长的包含 $K$ 个点的简单路径长度为多长？包含 $K$ 个点的长度为该最长长度的不同路径有多少条？

这里的简单路径是指：对于一个点最多只经过一次的路径。不同路径是指路径两端端点至少有一个不同，点 A 到点 B 的路径和点 B 到点 A 视为同一条路径。

## 说明/提示

对于所有数据 $n\leq 30000,m\leq 60000，2\leq K\leq n$。

数据保证最短路径树上至少存在一条长度为 $K$ 的路径。

## 样例 #1

### 输入

```
6 6 4
1 2 1
2 3 1
3 4 1
2 5 1
3 6 1
5 6 1```

### 输出

```
3 4```

# 题解

## 作者：watermonster (赞：8)

很裸的一道点分治，感觉就是[这道题](https://www.luogu.com.cn/problem/P4149)的升级版。

显然我们就是要建出最短路径树，然后直接在树上跑点分治就行了。

首先，关于建树

题目要求我们按字典序最小的路径建树，但由于官方数据过水，貌似大部分题解都没管字典序(不过后来添加了hack数据)。我们可以用一个贪心思想来建树：首先通过dfs来建树，将以当前点为起点的**在最短路上且儿子不在树上**的边加到树上，然后对所有**在树上连了边**的子节点继续dfs，在这里我们可以贪心地按编号从小到大作为顺序来搜索。因为对于后面的一个子孙节点来说，当前点的子节点在字典序上的位权一定是一样的。就像题干中给出的1,32,11和1,3,2,11。因为无论后面的路径长短，前面部分的路径一定是一样的。比如1的儿子有32和3，此时32和3之间我们就应该选编号较小的3。

#### 建树部分代码：
```
struct tmp{int v,w;bool operator <(const tmp&x)const{return v<x.v;}};
void build(int x)
{
	vector<tmp>son;
	for(re int i=h[x];i;i=e[i].nxt)
		if(dis[e[i].v]==dis[x]+e[i].w)
			son.push_back((tmp){e[i].v,e[i].w});//将儿子加入vector中方便排序
	sort(son.begin(),son.end());//按编号从小到大排序
	for(re int i=0;i<son.size();++i)
		if(!ontree[son[i].v])//当前儿子不在树上
		{
			ontree[son[i].v]=true;
			divide::add(x,son[i].v,son[i].w);
			divide::add(son[i].v,x,son[i].w);//加边
			build(son[i].v);//继续建树
		}
}
```


当建好树之后，我们就可以考虑如何统计答案了。

问题：

>请问，在这棵最短路径树上，最长的包含K个点的简单路径长度为多长？长度为该最长长度的不同路径有多少条？

对于最长路径的长度，做法可以参考[这里](https://www.luogu.com.cn/problem/P4149)。我们可以开两个栈，一个存链长，一个存深度，若当前链经过节点数为$x$那么这条链就应该和之前子树中的一条经过$k-x-1$个节点的链组成答案（减1是因为当前的重心也是链上的点），如果比答案更长则更新长度和方案，如果一样长就直接累加方案。

#### 点分治部分代码：
```
namespace divide
{
	int cnt,h[N];
	struct edge{int v,w,nxt;}e[N<<1];
	il void add(int u,int v,int w){e[++cnt]=(edge){v,w,h[u]};h[u]=cnt;}
	int rt,sum;
	int siz[N],son[N],dis[N],dep[N],len[N],tot[N];
	//len[i]表示经过i个点的最长链长度
	//tot[i]表示经过i个点的最长链的条数
	bool vis[N];
	void getrt(int x,int fa)
	{
		siz[x]=1;son[x]=0;
		for(re int i=h[x],v;i;i=e[i].nxt)
			if(!vis[v=e[i].v]&&v^fa)
			{
				getrt(v,x);
				siz[x]+=siz[v];
				son[x]=max(son[x],siz[v]);
			}
		son[x]=max(son[x],sum-siz[x]);
		rt=son[x]<son[rt]?x:rt;
	}//求重心模板
	int st1[N],st2[N],top;
	//st1存距离,st2存深度
	void getdis(int x,int fa)
	{
		if(dep[x]>k) return;
		st1[++top]=dis[x];
		st2[top]=dep[x];
		for(re int i=h[x],v;i;i=e[i].nxt)
			if(!vis[v=e[i].v]&&v^fa)
			{
				dis[v]=dis[x]+e[i].w;
				dep[v]=dep[x]+1;
				getdis(v,x);
			}
	}
	il int solve(int x)
	{
		re int pre=top=0,res=0;
		memset(tot,0,sizeof(tot));
		memset(len,0,sizeof(len));
		tot[0]=1;//当前重心也有可能是一条最长链的起点！！！因为这里wa了好多次QAQ
		for(re int i=h[x],v;i;i=e[i].nxt)
			if(!vis[v=e[i].v])
			{
				dis[v]=dis[x]+e[i].w;
				dep[v]=dep[x]+1;
				pre=top;
				getdis(v,x);
				//处理出当前子树中的信息
				for(re int j=pre+1;j<=top;++j)
				{
					if(len[k-st2[j]-1]+st1[j]>ans[0])
						ans[0]=len[k-st2[j]-1]+st1[j],res=tot[k-st2[j]-1];
						//当前子树上存在可以和之前子树上的链组成更优答案的链
					else if(len[k-st2[j]-1]+st1[j]==ans[0]) res+=tot[k-st2[j]-1];
					//当前子树上存在可以和之前子树上的链组成最优答案的链，那么累加方案数
				}
				for(re int j=pre+1;j<=top;++j)//给下一棵子树用
				{
					if(len[st2[j]]==st1[j]) ++tot[st2[j]];//累加方案
					if(len[st2[j]]<st1[j]) tot[st2[j]]=1,len[st2[j]]=st1[j];//更新方案、长度
				}
			}
		return res;
	}
	void getdiv(int x)
	{
		vis[x]=true;dis[x]=0;dep[x]=0;
		re int pre=ans[0],tmp=solve(x);
		if(ans[0]^pre) ans[1]=tmp;//更新方案
		else ans[1]+=tmp;//累加方案
		for(re int i=h[x],v;i;i=e[i].nxt)
			if(!vis[v=e[i].v])
			{
				son[rt=0]=sum=siz[v];
				getrt(v,0);
				getrt(rt,0);
				//其实这一次搜索可以不用，目的是将子树中的siz更新为以rt作为根的siz
				getdiv(rt);
			}
		//点分治主体
	}
}
```

由于代码的核心部分上面都已经给出，这里就不给完整代码了。

---

## 作者：Ebola (赞：5)

这是强行拼题啊。不太擅长点分的我都做出来这题，不过码起来是真的难受，说实话我感觉6K+的那种数据结构题码起来都非常舒服，但这种题就莫名很难受

首先是要求出最短路图。具体地，先以1为源点做一遍单源最短路，若一条边e满足d[u]+e.capa=d[v]，则这条边在最短路图中。然后这题要求建字典序最小的树吧，那就用邻接表存图，把每个点的出边按指向的点从小到大排序，然后dfs建树就是了。这个数据规模要卡起spfa来是会炸的，不知道出题人卡不卡，反正保险起见我写了dij

那至于题目要求的答案吧，就是点分的经典套路。对于每个点u，考虑经过u这个点的路径对答案的贡献。可以用tmp\[x\]表示经过点u，包含x条边的路径的信息（信息包括：最长长度、路径数量）。然后处理u的每个子节点v时，处理出以v为根的子树的路径信息。对于一个包含k-1条边的路径，直接更新答案。对于一个包含边数少于k-1的路径，设它包含x条边，那将它的信息与tmp[k-1-x]合并到一起来更新答案。tmp数组在每个分治环节都要清空，千万不要整个memset！

具体还是看代码吧，一看就懂。反正我码着非常难受就是了

```cpp
#include<bits/stdc++.h>
#define FR first
#define SE second
#define MP make_pair
#define PB push_back
using namespace std;

const int S=(1<<20)+5;
char buf[S],*H,*T;
inline char Get()
{
    if(H==T) T=(H=buf)+fread(buf,1,S,stdin);
    if(H==T) return -1;return *H++;
}
inline int read()
{
    int x=0;char c=Get();
    while(!isdigit(c)) c=Get();
    while(isdigit(c)) x=x*10+c-'0',c=Get();
    return x;
}

typedef pair<int,int> pii;
const int N=30010;
struct Edge{int to,capa,next;} e[N<<1];
int h[N],n,m,K,esum=0;
vector<pii> G[N];
priority_queue<pii> q;
bool vis[N];int dis[N];
int sum=0,root,mxsz[N];
pii ans,d[N],now[N],cross[N];
int sz[N],mxd,tot;

void add_edge(int u,int v,int w)
{
    e[++esum].to=v;
    e[esum].capa=w;
    e[esum].next=h[u];
    h[u]=esum;
}

void dijkstra()
{
    memset(dis,0x3f,sizeof(dis));
    q.push(MP(0,1));dis[1]=0;
    while(!q.empty())
    {
        pii tmp=q.top();q.pop();
        int u=tmp.SE,w=-tmp.FR;
        if(vis[u]) continue;
        vis[u]=1;
        for(pii pr : G[u])
            if(w+pr.SE<dis[pr.FR])
            {
                dis[pr.FR]=w+pr.SE;
                q.push(MP(-dis[pr.FR],pr.FR));
            }
    }
}

void find(int u,int fa)
{
    sz[u]=1;mxsz[u]=0;
    for(int t=h[u];t;t=e[t].next)
    {
        int v=e[t].to;
        if(v==fa||vis[v]) continue;
        find(v,u);sz[u]+=sz[v];
        mxsz[u]=max(mxsz[u],sz[v]);
    }
    mxsz[u]=max(mxsz[u],sum-sz[u]);
    if(mxsz[u]<mxsz[root]) root=u;
}

void dfs(int u,int fa)
{
    now[++tot]=d[u];
    for(int t=h[u];t;t=e[t].next)
    {
        int v=e[t].to;
        if(v==fa||vis[v]) continue;
        d[v].SE=d[u].SE+e[t].capa;
        d[v].FR=d[u].FR+1;dfs(v,u);
    }
}

void gao(int u,int w)
{
    d[u].FR=1;d[u].SE=w;
    tot=0;dfs(u,0);
    for(int i=1;i<=tot;i++)
    {
        int rest=K-now[i].FR-1,w=now[i].SE;
        if(now[i].FR<K-1)
        {
            int t1=cross[rest].FR,t2=cross[rest].SE;
            if(w+t2>ans.FR) ans=MP(w+t2,t1);
            else if(w+t2==ans.FR) ans.SE+=t1;
        }
        if(now[i].FR==K-1)
        {
            if(w>ans.FR) ans=MP(w,1);
            else if(w==ans.FR) ans.SE++;
        }
    }
    for(int i=1;i<=tot;i++)
        if(now[i].FR<=K-1)
        {
            int num=now[i].FR;
            if(now[i].SE>cross[num].SE) cross[num]=MP(1,now[i].SE);
            else if(now[i].SE==cross[num].SE) cross[num].FR++;
            mxd=max(mxd,num);
        }
}

void solve(int u)
{
    vis[u]=1;mxd=0;
    for(int t=h[u];t;t=e[t].next)
        if(!vis[e[t].to]) gao(e[t].to,e[t].capa);
    memset(cross,0,sizeof(pii)*(mxd+2));
    for(int t=h[u];t;t=e[t].next)
    {
        int v=e[t].to;
        if(vis[v]) continue;
        sum=sz[v];root=0;
        find(v,u);solve(root);
    }
}

void build(int u)
{
    vis[u]=1;
    for(pii pr : G[u])
    {
        int v=pr.FR,w=pr.SE;
        if(vis[v]||dis[u]+w!=dis[v]) continue;
        add_edge(u,v,w);add_edge(v,u,w);build(v);
    }
}

int main()
{
    int u,v,w;
    n=read();m=read();K=read();
    for(int i=1;i<=m;i++)
    {
        u=read();v=read();w=read();
        G[u].PB(MP(v,w));
        G[v].PB(MP(u,w));
    }
    for(int i=1;i<=n;i++) sort(G[i].begin(),G[i].end());
    dijkstra();memset(vis,0,sizeof(vis));build(1);
    memset(vis,0,sizeof(vis));
    sum=mxsz[0]=n;root=0;
    find(1,0);solve(root);
    printf("%d %d\n",ans.FR,ans.SE);
    return 0;
}
```



---

## 作者：Engulf (赞：1)

这是一道差劲的题目，强行拼接了最短路树与点分治，且两者无任何联系，没有用到任何最短路树的性质。

先在原图上跑一遍 spfa 求出 $1$ 到其他点的最短路径，为了让建出来的最短路树顶点字典序最小，对每个点 $u$ 相邻的节点 $v$ 从小到大排序，然后从 $1$ 开始 dfs 一遍就完成了建树。

然后就是点分治。钦定当前分治重心为 $u$，现在要处理所有经过 $u$ 的路径。依次遍历 $u$ 的儿子 $v$，遍历 $v$ 的子树，维护数组：
- $\textrm{dep}_j$ 为 $j$ 到 $u$ 的深度；
- $\textrm{dis}_j$ 为 $j$ 到 $u$ 的距离；
- $\textrm{mxlen}_d$ 为目前已遍历的子树（不包括 $v$）中深度为 $d$ 的点到 $u$ 的最长路径；
- $\textrm{mxcnt}_d$ 为目前已遍历的子树（不包括 $v$）中深度为 $d$ 的点到 $u$ 的路径最长的点的个数；

然后遍历 $v$ 中的每个节点 $j$，那能拼的最长的路径长度为 $\textrm{dis}_j + \textrm{mxlen}_{k-1-\textrm{dep}_j}$，若能更新答案则更新，如果和当前答案相同就增加个数。

时间复杂度 $O(n \log n)$，没管最短路。

实现上的细节：由于路径可以只到根，所以 $\textrm{mxcnt}_0$ 的初值请设为 $1$，否则会 WA on #6。

```cpp
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using pii = pair<int, int>;

#ifdef ONLINE_JUDGE
#define debug(...) 0
#else
#define debug(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)
#endif

const int N = 3e4 + 5, M = 6e4 + 5;

int n, m, k;

vector<pii> G[N];

vector<pii> g[N];

int dis[N];

bool vis[N];

void spfa() {
    queue<int> q;
    q.push(1);
    bitset<N> vis;
    vis[1] = 1;
    memset(dis, 0x3f, sizeof dis);
    dis[1] = 0;
    while (!q.empty()) {
        int u = q.front(); q.pop(); vis[u] = 0;
        for (auto [v, w]: G[u]) {
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                if (!vis[v])
                    q.push(v), vis[v] = 1;
            }
        }
    }
}
void build(int u) {
    vis[u] = 1;
    for (auto [v, w]: G[u]) {
        if (vis[v] || dis[v] != dis[u] + w) continue;
        g[u].emplace_back(v, w);
        g[v].emplace_back(u, w);
        build(v);
    }
}

int siz[N], mx[N];
int centroid;

void getCentroid(int u, int fa, int tot) {
    mx[u] = 0, siz[u] = 1;
    for (auto [v, w]: g[u]) {
        if (vis[v] || v == fa) continue;
        getCentroid(v, u, tot);
        siz[u] += siz[v];
        mx[u] = max(mx[u], siz[v]);
    }
    mx[u] = max(mx[u], tot - siz[u]);
    if (mx[u] < mx[centroid]) centroid = u;
}

int ans, cnt;

void calc(int u) {
    vector<int> mxlen(n), mxcnt(n);
    mxcnt[0] = 1;
    vector<int> dep(n + 1);
    for (auto [v, w]: g[u]) {
        if (vis[v]) continue;

        vector<int> d;
        dis[v] = w;
        dep[v] = 1;
        auto getdis = [&](auto &&self, int u, int fa) -> void {
            d.emplace_back(u);
            for (auto [v, w]: g[u]) {
                if (vis[v] || v == fa) continue;
                dep[v] = dep[u] + 1;
                dis[v] = dis[u] + w;
                self(self, v, u);
            }
        };
        getdis(getdis, v, u);

        for (auto j: d) {
            if (dep[j] > k - 1) continue;
            int res = dis[j] + mxlen[k - 1 - dep[j]];
            if (res > ans) {
                ans = res, cnt = mxcnt[k - 1 - dep[j]];
            } else if (res == ans)
                cnt += mxcnt[k - 1 - dep[j]];
        }
        for (auto j: d) {
            if (dis[j] > mxlen[dep[j]]) {
                mxlen[dep[j]] = dis[j];
                mxcnt[dep[j]] = 1;
            } else if (dis[j] == mxlen[dep[j]])
                mxcnt[dep[j]]++;
        }
    }
}

void dfs(int u) {
    vis[u] = 1;
    calc(u);
    for (auto [v, w]: g[u]) {
        if (vis[v]) continue;
        mx[centroid = 0] = n;
        auto getsiz = [](auto &&self, int u, int fa) -> int {
            int res = 1;
            for (auto [v, w]: g[u])
                if (!vis[v] && v != fa)
                    res += self(self, v, u);
            return res;
        };
        getCentroid(v, u, getsiz(getsiz, v, u));
        dfs(centroid);
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m >> k;
    for (int i = 1, u, v, w; i <= m; i++) {
        cin >> u >> v >> w;
        G[u].emplace_back(v, w);
        G[v].emplace_back(u, w);
    }

    for (int i = 1; i <= n; i++)
        sort(G[i].begin(), G[i].end());

    spfa(); build(1);

    memset(vis, 0, sizeof vis);

    mx[centroid = 0] = n;
    getCentroid(1, 0, n);
    dfs(centroid);

    cout << ans << " " << cnt << "\n";

    return 0;
}
```

---


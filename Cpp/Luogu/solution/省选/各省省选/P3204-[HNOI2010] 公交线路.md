# [HNOI2010] 公交线路

## 题目描述

小 Z 所在的城市有 $N$ 个公交车站，排列在一条长 $(N-1)\  \rm km$ 的直线上，从左到右依次编号为 $1$ 到 $N$，相邻公交车站间的距离均为 $1 \ \rm km$。作为公交车线路的规划者，小 Z 调查了市民的需求，决定按下述规则设计线路：

1. 设共 $K$ 辆公交车，则 $1$ 到 $K$ 号站作为始发站，$N-K+1$ 到 $N$ 号台作为终点站。
2. 每个车站必须被一辆且仅一辆公交车经过（始发站和终点站也算被经过）。
3. 公交车只能从编号较小的站台驶往编号较大的站台。
4. 一辆公交车经过的相邻两个站台间距离不得超过 $P \ \rm km$。

在最终设计线路之前，小 Z 想知道有多少种满足要求的方案。由于答案可能很大，你只需求出答案对 $30031$ 取模的结果。

## 说明/提示

【样例说明】

样例一的可行方案如下：$(1,4,7,10)$，$(2,5,8)$，$(3,6,9)$。

样例二的可行方案如下：$(1,3,5)$，$(2,4)(1,3,4)$，$(2,5)(1,4)$，$(2,3,5)$。

对于 $100 \%$ 的数据，$1 \le N \le 10^9$，$1 < P \le 10$，$K<N$，$1<K \le P$。

## 样例 #1

### 输入

```
10 3 3```

### 输出

```
1```

## 样例 #2

### 输入

```
5 2 3```

### 输出

```
3```

## 样例 #3

### 输入

```
10 2 4```

### 输出

```
81```

# 题解

## 作者：xyz32768 (赞：27)

一、问题分析

======
将问题转化为：一个$N$个数的序列，序列的每个位置需要填充一个$[1,K]$范围内的数。同时对于任意的$1\leq i\leq K$，序列的第$i$个位置已经被填充，填充的数为$i$。同时$[N-K+1,N]$区间内填充的数必须包含$[1,K]$的所有数。而「一辆公交车经过的相邻两个站台间距离不得超过$P$km」这个条件，等价于序列中任意一个长度为$P$的**一段**，都必须填充有$[1,K]$的所有数。

二、DP模型

======
分析后可以得出，由于前$K$个填充的数已经确定，所以这里只关心序列中的数相同或不相同，而和具体数值无关。因此设$f[i][S]$为序列中$[1,i-1]$已经填充完，$[i,i+P-1]$这一段填充的状态为$S$的方案数。$S$是一个长度为$P$的$01$串，从高往低（之后的「第几位」都是从高位往低位）第$j$位为$1$表示位置$i+j-1$已经被填充，否则位置$i+j-1$还没被填充。

三、DP转移

======
为了保证每个位置都能被填充，规定在转移过程中，$S$的第$1$位恒为$1$。同时由于$[i,i+P-1]$区间里必须有填充所有$K$个数，所以再规定在转移过程中$S$必须包含且仅包含$K$个$1$。

而判断$S_2$能否从$S_1$转移，就是把$S_1$最高位的$1$去掉之后在末尾再补一个$0$（记为$S_3$），如果$S_3$中的$K-1$个$1$能够恰好与$S_2$中$K$个$1$其中$K-1$个一一对应，，那么$S_2$能从$S_1$转移。

四、矩阵优化

======
考虑到$N\leq 10^9$的数据范围，想到矩阵乘法。这时根据上面推出的转移条件，得到有用的状态只有$C_{P-1}^{K-1}$个。可以得到矩阵规模的最大值为$C_9^{\lfloor\frac{9}{2}\rfloor}=126$。

复杂度$O((C_{P-1}^{K-1})^3\log N)$。

五、代码

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 134, ZZQ = 30031;
int n, K, P, tot, sta[N];
struct cyx {
    int n, m, a[N][N];
    cyx() {}
    cyx(int _n, int _m) :
        n(_n), m(_m) {memset(a, 0, sizeof(a));}
    friend inline cyx operator * (cyx a, cyx b) {
        int i, j, k; cyx res = cyx(a.n, b.m);
        for (i = 1; i <= res.n; i++) for (j = 1; j <= res.m; j++)
        for (k = 1; k <= a.m; k++)
            (res.a[i][j] += a.a[i][k] * b.a[k][j]) %= ZZQ;
        return res;
    }
    friend inline cyx operator ^ (cyx a, int b) {
        int i; cyx res = cyx(a.n, a.m);
        for (i = 1; i <= res.n; i++) res.a[i][i] = 1;
        while (b) {
            if (b & 1) res = res * a;
            a = a * a;
            b >>= 1;
        }
        return res;
    }
} Orz, Zzq;
int main() {
    int i, j, k; cin >> n >> K >> P;
    for (i = (1 << P - 1); i < (1 << P); i++) {
        int cnt = 0; for (j = 0; j < P; j++) if ((i >> j) & 1) cnt++;
        if (cnt == K) sta[++tot] = i;
    }
    Orz = cyx(tot, tot); Zzq = cyx(tot, 1);
    for (i = 1; i <= tot; i++) for (j = 1; j <= tot; j++) {
        int S1 = sta[i], S2 = sta[j]; S1 = S1 - (1 << P - 1) << 1;
        for (k = 0; k < P; k++) if (!((S1 >> k) & 1) && S1 + (1 << k) == S2)
            Orz.a[j][i] = 1;
    }
    Zzq.a[tot][1] = 1; Orz = (Orz ^ n - K) * Zzq;
    cout << Orz.a[tot][1] << endl;
    return 0;
}
====
```

---

## 作者：TopCarry (赞：13)

### 楼上的题解其实已经很棒了，这篇题解主要送给给刚初学状压DP和矩阵快速幂的同学。

#### 1.为什么这个状压是对的？
这里有人可能会说：感性理解一下嘛！暴力打表拍一拍没问题嘛！

然而身为蒟蒻的我在这里纠结了好久：（1）为什么不用只记录0/1而不用管是谁呢？（2）这个0/1怎么保证是合法的（每个点被且仅被遍历一次）呢？

对于问题（1）：
其实也很好想，
举个例子：

1 0 1 0 1->1 1 0 1 0(状压不知道怎么压的可以翻一翻上面的题解)

反映到现实可能是1 0 2 0 3->1 2 0 3 0,也可能是2 0 1 0 3->2 1 0 3 0
，但是因为如果有这两种情况的话，1 0 1 0 1的dp值其实是2，所以是没有漏掉转移的。

对于问题（2）：首先因为p的限制，可以转换成每个长度p的区间1~k各出现了一次。

而每次转移之所以要保障第一位是1，就是为了防止非法转移。这个转移的实际意义其实是：每次移动最靠后的那个1去填补前面的某个0。所以不能出现有一个空位还没填，所有的车都跑到这个空位前面去了。

#### 2.为什么这个矩阵快速幂是对的，或者说为什么这道题让我们想到矩阵快速幂？
~~看数据范围嘛！~~（啪！）

其实是因为:

1.每个状态的转移是固定的。

2.状态空间是一样的（状态总是那么几种）。

其实看代码很难理解这道题，这个后面会说。

我们设f[i]表示第i种状态的dp值，然后每次转移其实就是用这个一行的“f矩阵”乘上一个0/1的“转移矩阵”,如果第i种状态可以转移到第j种状态，则 转移矩阵[i][j]=1。

把两个相乘，获得新的f数组，列出来矩阵乘法的式子就是这样子:

#### (new)f[j]=sigma(i=1~n)(转移矩阵[i][j])*（old）f[i]

这个式子很巧妙，相当于如果i可以转移到j，就把f[i]加到f[j]上面。

然后矩阵是满足结合律的，本来应该是把初始矩阵乘上n-k次转移矩阵，就把他变成转移矩阵先自乘然后在乘上初始矩阵，转移矩阵自乘搞个快速幂就可以了。

这里有人会发现，为什么代码里面没有那个初始矩阵，直接最后输出[len][len]？因为这个初始矩阵很特别，因为初始的f数组是000000001，因为只有这最后一位才会有贡献。这里大家画一画就知道了。

最后，引用某位巨佬教我的优化
```cpp
for(k=1;k<=len;k++)//显然，k提到外面不影响
	for(i=1;i<=len;i++)
		if(x.maps[i][k])//如果这一格是0则后面都不会产生贡献
			for(j=1;j<=len;j++){
				(now.maps[i][j]+=(x.maps[i][k]*y.maps[k][j])%MOD)%=MOD;		
				}
```
分分钟冲上最优解第一面好伐。

### CODE:
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=150; 
const int MOD=30031;
int n,k,p,len;
struct node{
	int maps[N][N];
	node(){
		memset(maps,0,sizeof(maps));
	}
};
node Z;
int all[N];
node operator * (node x,node y){
	register int i,j,k;
	node now;
	for(k=1;k<=len;k++)
		for(i=1;i<=len;i++)
			if(x.maps[i][k])
				for(j=1;j<=len;j++){
					(now.maps[i][j]+=(x.maps[i][k]*y.maps[k][j])%MOD)%=MOD;		
				}
	return now;
}
node quickpow(node a,int b){
	node base=a,ans;
	for(int i=1;i<=len;i++)
		ans.maps[i][i]=1;
	while(b){
		if(b&1)ans=ans*base;
		base=base*base;
		b>>=1;
	}
	return ans;
}
void dfs(int u,int now,int cnt){
	if(cnt==k){
		all[++len]=now;
		return;
	}
	if(u>p)return;
	dfs(u+1,now,cnt);
	now|=(1<<(p-u));
	dfs(u+1,now,cnt+1);
}
bool check(int a,int b){
	register int i,cnt=0;
	a<<=1;
	for(i=0;i<p;i++)
		if((a&(1<<i))!=(b&(1<<i)))
			cnt++;
	if(cnt<=1)return 1;
	else return 0;
}
void pre(){
	register int i,j;
	for(i=1;i<=len;i++)
		for(j=1;j<=len;j++){
			if(check(all[i],all[j]))Z.maps[i][j]=1;
		}
}
int main(){
	cin>>n>>k>>p;
	dfs(2,1<<(p-1),1);
	pre();
	cout<<quickpow(Z,n-k).maps[len][len];
	return 0;
}
```


---

## 作者：M_seа (赞：8)

##题解

矩阵快速幂$+dp$

~~其实也不是很难~~

先考虑朴素状压$dp$

$f[i][S]$ 表示最慢的车走到了$i$，$[i, p+i-1]$的覆盖情况
状态第一位一定是$1$

那么显然$f[i][S] = \sum f[i-1][S']$（$S'$能转移到$S$)

什么情况能转移呢？

假如:$S1->S2$

$S1$去掉第一位，再在后面补$0$,产生的新数和$S2$至多只有一个差异

$n$很大，所以矩阵优化一下

先把合法的状态都弄出来

如果两个状态可以转移，$Matrix[i][j] = 1$

初始矩阵乘以一次$Matrix$，就转移了一次，快速幂算一下就可以啦

##Code

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>

#define LL long long
#define RG register

using namespace std;
template<class T> inline void read(T &x) {
    x = 0; RG char c = getchar(); bool f = 0;
    while (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;
    while (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();
    x = f ? -x : x;
    return ;
}
template<class T> inline void write(T x) {
    if (!x) {putchar(48);return ;}
    if (x < 0) x = -x, putchar('-');
    int len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;
    for (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;
}
const int Mod = 30031;
int N;
struct node {
	int a[150][150];
	node operator *(node A) const {
		node tmp;
		memset(tmp.a, 0, sizeof(tmp.a));
		for (int i = 1; i <= N; i++)
			for (int j = 1; j <= N; j++)
				for (int k = 1; k <= N; k++)
					(tmp.a[i][j] += a[i][k]*A.a[k][j]) %= Mod;
		return tmp;
	}
}X, s;
int S[150], len;
int n, k, p;

bool check(int s1, int s2) {
	s1 <<= 1;
	int tmp = 0;
	for (int i = 0; i < p; i++) if (((s1>>i)&1) ^ ((s2>>i)&1)) tmp++;
	return tmp < 2;
}

int main() {
	read(n), read(k), read(p);
	for (int i = 1<<(p-1); i < (1<<p); i++) {
		int cnt = 0;
		for (int j = 0; j < p; j++)
			if ((i >> j) & 1) cnt++;
		if (cnt == k) S[++len] = i;
	}
	for (int i = 1; i <= len; i++)
		for (int j = 1; j <= len; j++) {
			int S1 = S[i], S2 = S[j];
			if (check(S1, S2)) X.a[i][j] = 1;
		}
	int y = n-k;
	N = len;
	for (int i = 1; i <= N; i++)
		s.a[i][i] = 1;
	for (; y; y >>= 1, X = X*X) if (y&1) s = s*X;
	printf("%d\n", s.a[N][N]);
	return 0;
}
```

---

## 作者：EnofTaiPeople (赞：5)

读完题之后，发现最后终点站的车辆的顺序是任意的，于是在地推的过程中，不同车辆不需要有序的表示，只需记录是否相同即可。

用二进制数 $p$ 存储当前在最后 $P$ 辆进站的车，是否是最后一辆（即之后是否有同一辆车进站），如果 $p$ 的第 $P$ 位为 $1$，则新进站的车必须是 $P km$ 前进站的车，否则可以枚举新进站的车之前在哪一位，转移如下：
```cpp
for(p=1;p<p2;++p)
		if((pct[p]=pct[p-(p&-p)]+1)==K)
			mp[mt++]=p;
	for(i=0;i<mt;++i){
		p=mp[i];
		if((p>>P-1)&1)add(i,((p<<1)^(1<<P))|1);
			else for(w=0;w<P;++w)
				if((p>>w)&1)add(i,(p^(1<<w))<<1|1);
	}
```
发现可供转移的状态只有 ${P\choose K}\le{10\choose 5}=252$，所以离散化后可以接受 $O(k^3)$ 的转移，发现转移次数 $n$ 很大，于是使用矩阵快速幂，可以在 $O(k^3\log_2n)$ 的时间复杂度内完成本题。
```cpp
for(rs=at,n-=K+1;n;n>>=1,at=at*at)
		if(n&1)rs=rs*at;
	p=lower_bound(mp,mp+mt,(1<<K)-1)-mp;
	printf("%d\n",rs.a[p][p]);
```

---

## 作者：bianshiyang (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P3204)

本篇题解较详细地讲解了状压设计状态的细节，当时做的时候遇到很多问题，也思考了很久，题解里都讲清楚了，希望对大家有帮助！

# 分析
本题难点在于如何想到状压以及状态的设计，矩阵优化只是比较套路的一个东西。我们发现问题可以转化为将 $1\sim n$ 每个点进行染色，每个点必须且只能被染成一种颜色，相邻同种颜色的点之间距离不得超过 $P$。关注题目发现每条公交车线路都视为一样的，也就是说不同颜色之间不存在顺序，然后加上了若干限制，其中比较麻烦的限制是同种颜色的任意相邻两个点间距离不得超过 $P$，因为如果没有这个限制那就是很裸的乘法原理。所以我们要从这里下手，比如我们要对某个点进行染色，那么我们需要知道距离这个点之前 $P$ 长度的点的状态，才知道这个点可以染成哪些颜色。

而由于本题中颜色是不存在顺序的（上文已经提及），因此我们没有必要记录每个点是什么颜色，而只需关注每个点有没有被染色即可，这启示我们可以使用状压的方式存储长度为P的一个窗口的状态，而如果这个窗口内部有恰好 $K$ 个 $1$，那么这个窗口的方案数就是确定的，这个窗口之前的部分就可以从子问题转移过来，想到这里，状压DP也就呼之欲出了。具体地，设 $f_{i,j}$ 表示最晚的 $K$ 个已经染色的点的最小编号为 $i$，$i\sim i+P-1$ 的状态为 $j$ 的方案数，$i$ 的状态被保留在 $j$ 的 $p-1$ 位，$i+1$ 保留在第 $p-2$ 位，以此类推，直到 $i+P-1$ 保留在第 $0$ 位，$j$ 的某一位为 $1$ 说明对应的点已经被染色，反之则没有。由于要满足最小编号 $i$ 能够取得到，所以 $j$ 的 $p-1$ 位为 $1$，并且我们要保证 $j$ 有恰好 $K$ 个 $1$，表示每种颜色的第一个点在哪里，这样子状态才能唯一确定染色方案，且可以做到不重不漏（原因后面转移会讲）。

我们每次的转移要从 $f_{i,s1}$ 转移到 $f_{i+1,s2}$ 去，那么怎样的转移是合法的呢，首先得保证 $s1$ 和 $s2$ 满足我们上面合法状态的定义，其次我们需要保证在二进制下 $s1$ 去掉最高位左移一位后与 $s2$ 不同的位置至多一个，若 $s1\neq s2$ 其实是恰好一个 $1$，因为保证状态都恰好 $K$ 个 $1$，$s1$ 去掉一个后必然会比 $s2$ 少一个 $1$，而若 $s1=s2$ 则是 $0$ 个，这种转移在一定条件下也是合法，比如 $P=K$ 的时候，就是可以在 $K$ 个 $1$ 之间相互转移。转移的原理就是我们每次相当于是对这个滑动窗口进行移动，每次要分配某一种点到之后某一个空位上去，仍然保留 $K$ 种点在窗口内部。

通过转移我们其实可以证明我们这样子只保留 $K$ 个 $1$ 的方式是能不重不漏的表示所有可能的。首先不可能出现一个窗口内的颜色数少于 $K$，否则必然有一种颜色的相邻两个点会跨过这个长为 $P$ 的窗口与题意矛盾。如果出现一个窗口内有很多点都是同一个颜色的话，保留第一个就是对的，因为剩下的情况会在转移中自动求出。

举个例子：比如说某一个窗口内部是 $311213$，数字表示每个点被染上的颜色，后文的问号表示这个点状态未知。此时状态表示为 $110100$，第一次转移可以转移出 $101010$，对应 $11213?$，第二次可以转移出 $110100$，对应 $1213??$，第三次可以转移出 $111000$，对应 $213???$ 之后的转移也是类似的，大家可以多模拟几组数据找找感觉。

接下来就需要考虑初始状态和末态。首先考虑初始状态，我们记状态 $S$ 表示长度为 $P$，且最高 $K$ 位均为 $1$ 的二进制数，且这个状态是最大的合法状态。那么初始状态就是 $f_{1,S}$，末态就是 $f_{n-K,S}$（注意这里长度为 $P$ 的部分会超出 $n$，但是由于后面都是 $0$ 所以也合法）。由于每次只转移一步，但步数很多，且最终合法的状态非常少只有 $C_{10}^5=252$ 种，所以可以考虑用矩阵优化 DP，这一部分其他题解讲得已经很清楚了，便不再赘述。

# 代码实现
```cpp
#include<bits/stdc++.h>
#define pw(i) (1<<(i))
using namespace std;
const int N=260;
const int mo=30031;
int n,p,k,st[N],cnt;

struct Matrix{
	int a[N][N]={0},r,c;
	void fil(int n)//单位矩阵
	{
		r=c=n;
		for(int i=1;i<=n;i++) a[i][i]=1;
	}
	friend Matrix operator*(Matrix x,Matrix y)
	{
		Matrix z;
		z.r=x.r,z.c=y.c;
		for(int i=1;i<=z.r;i++)
			for(int j=1;j<=z.c;j++)
				for(int k=1;k<=x.c;k++) z.a[i][j]=(z.a[i][j]+1ll*x.a[i][k]*y.a[k][j]%mo)%mo;
		return z;
	}
	friend Matrix operator^(Matrix x,int y)
	{
		Matrix z;z.fil(cnt);
		while(y)
		{
			if(y&1) z=z*x;
			x=x*x;
			y>>=1;
		}
		return z;
	}
}a;

int main()
{
	scanf("%d%d%d",&n,&k,&p);
	for(int i=pw(p-1);i<pw(p);i++)
		if(__builtin_popcount(i)==k)//合法状态，注意这里枚举的所有状态都满足第一位为1的限制
			st[++cnt]=i;
	for(int i=1;i<=cnt;i++)
		for(int j=1;j<=cnt;j++)
		{
			int ii=st[i],jj=st[j],kk=(ii^pw(p-1))<<1,tot=0;
			for(int t=0;t<p;t++)//判断第i个状态能否转移到第j个状态
				if(((jj>>t)&1)^((kk>>t)&1)) tot++;
			if(tot<=1) a.a[i][j]=1;
		}
	a.r=a.c=cnt;
	printf("%d\n",(a^(n-k)).a[cnt][cnt]);//需要转移n-k次，直接取最后一个是因为初始状态和末状态对应的状态都是最大的合法状态
	return 0;
}
```

---

## 作者：dsjkafdsaf (赞：3)

# [My_blog](https://www.cnblogs.com/dsjkafdsaf/)
[更好的阅读体验](https://www.cnblogs.com/dsjkafdsaf/p/11637486.html)


## 题目描述


小Z所在的城市有$N$个公交车站，排列在一条长($N-1$)km的直线上，从左到右依次编号为$1$到$N$，相邻公交车站间的距离均为$1$km。 作为公交车线路的规划者，小Z调查了市民的需求，决定按下述规则设计线路：

1.设共$K$辆公交车，则$1$到$K$号站作为始发站，$N-K+1$到N号台作为终点站。

2.每个车站必须被一辆且仅一辆公交车经过（始发站和终点站也算被经过）。 

3.公交车只能从编号较小的站台驶往编号较大的站台。 

4.一辆公交车经过的相邻两个站台间距离不得超过$P$km。

在最终设计线路之前，小Z想知道有多少种满足要求的方案。由于答案可能很大，你只需求出答案对$30031$取模的结果。

## Input

仅一行包含三个正整数$N, K ,P$，分别表示公交车站数，公交车数，相邻站台的距离限制。

$N<=10^9，1<P<=10，K<N，1<K<=P$

## Output

仅包含一个整数，表示满足要求的方案数对$30031$取模的结果。

## Sample Input

```
10 3 3
5 2 3
10 2 4
```
## Sample Output
```
1
3
81
```

看到$k,p$如此之小自然就是状压$dp$了。

我们可以十分想到$O((n-k)*p*2^p)$的$dp$，即$dp[i][j]$表示第$i$千米，第$i-p+1$到$i$千米是否有车的状态为$j$的方案数。

转移是很显然的枚举一个$1$把它放到后面去，由于直接转移的话会算重复，所以我们要限制一位。

我们只要限制最低位一定要有一个$1$在，这要的话就可以保证状态的转移不会重复。

$dp$部分见下：

```cpp

dp[k][(1 << k) - 1] = 1;
ret(i, k, n) drep(K, (1 << P) - 1, 1) if (dp[i][K]) {
	if (!(K & 1))continue;
	ret(p, 0, P) if (K & 1 << p) {
		int Now = (K ^ (1 << p)) % (1 << P - 1);
		Now <<= 1, Now |= 1;
		dp[i + 1][Now] += dp[i][K], Mod(dp[i + 1][Now]);
	}
}
```

但是！！！这是过不了的。

#### 我们发现每次dp的转移都是一样的

每次都是一个状态转移到另一个固定的状态，和$i$没有关系。

于是我们想到了矩阵加速，利用矩阵加速这个递推。

**还没完！！！**

如果把所有状态都算上去的话，矩阵的大小为$1024*1024$，每次矩阵乘法的复杂度为$O(1024*1024*1024)$无法承受。

但是我们有一个限制条件，即状态$i$必须保证$i$的最低位为$1$，这样的话我们优化到了$O(512*512*512)$的复杂度。

好像还是有一点难过掉，怎么办呢？

我们一开的的状态$1$的个数为$k$，而转移时并不会改变$i$的$1$的个数，所以我们只要把所有二进制位中$1$的个数为$k$的状态利用矩阵转移即可。

那么矩阵的大小为多少呢，为$C(p-1,k)$，最大为$C(9,4)=126$，这样的话一次矩阵乘法的复杂度为$O(126*126*126)$，我们就可以过掉这道题了。

```cpp
#include <bits/stdc++.h>
 
using namespace std;
 
#define LL long long
#define reg register
#define clr(a,b) memset(a,b,sizeof a)
#define Mod(x) (x>=mod)&&(x-=mod)
#define abs(a) ((a)<0?-(a):(a))
#define debug(x) cerr<<#x<<"="<<x<<endl;
#define debug2(x,y) cerr<<#x<<"="<<x<<" "<<#y<<"="<<y<<endl;
#define debug3(x,y,z) cerr<<#x<<"="<<x<<" "<<#y<<"="<<y<<" "<<#z<<"="<<z<<endl;
#define rep(a,b,c) for(reg int a=(b),a##_end_=(c); a<=a##_end_; ++a)
#define ret(a,b,c) for(reg int a=(b),a##_end_=(c); a<a##_end_; ++a)
#define drep(a,b,c) for(reg int a=(b),a##_end_=(c); a>=a##_end_; --a)
#define erep(i,G,x) for(int i=(G).Head[x]; i; i=(G).Nxt[i])
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize(3,"Ofast","inline")
 
inline int Read(void) {
    int res = 0, f = 1;
    char c;
    while (c = getchar(), c < 48 || c > 57)if (c == '-')f = 0;
    do res = (res << 3) + (res << 1) + (c ^ 48);
    while (c = getchar(), c >= 48 && c <= 57);
    return f ? res : -res;
}
 
template<class T>inline bool Min(T &a, T const&b) {return a > b ? a = b, 1 : 0;}
template<class T>inline bool Max(T &a, T const&b) {return a < b ? a = b, 1 : 0;}
 
const int N = 3e2 + 5, M = 1e5 + 5, K = 10, mod = 30031;
 
bool MOP1;
 
int n, k, P, cnt, Sz[1 << K], B[130], C[1 << K];
 
struct Matrix {
    int Num[N][N];
    inline void clear(void) {clr(Num, 0);}
    inline void Init(void) {rep(i, 1, cnt)Num[i][i] = 1;}
    inline Matrix operator*(Matrix _)const {
        Matrix Ans;
        Ans.clear();
        rep(i, 1, cnt)rep(j, 1, cnt)rep(k, 1, cnt)Ans.Num[i][j] = (Ans.Num[i][j] + 1ll * Num[i][k] * _.Num[k][j]) % mod;
        return Ans;
    }
} us;
 
inline Matrix qpow(Matrix A, int k) {
    Matrix res;
    res.clear(), res.Init();
    while (k) {
        if (k & 1)res = res * A;
        A = A * A, k >>= 1;
    }
    return res;
}
 
bool MOP2;
 
void _main(void) {
    n = Read(), k = Read(), P = Read();
    ret(i, 1, 1 << P) {
        Sz[i] = Sz[i ^ (i & -i)] + 1;
        if (!(i & 1))continue;
        if (Sz[i] == k)B[++cnt] = i, C[i] = cnt;
    }
    Matrix res;
    res.clear();
    rep(i, 1, cnt) {
        int K = B[i];
        ret(p, 0, P) if (K & 1 << p) {
            if (k - P > p)continue;
            int Now = ((K ^ (1 << p)) & ((1 << P - 1) - 1)) << 1 | 1;
            res.Num[i][C[Now]] = 1;
        }
    }
    Matrix Ans = qpow(res, n - k);
    printf("%lld\n", Ans.Num[C[(1 << k) - 1]][C[(1 << k) - 1]]);
}
 
signed main() {
    _main();
    return 0;
}
```

---

## 作者：StayAlone (赞：2)

$f_{i, s}$ 表示，考虑前 $i$ 米都已经**有过**公交车经停，其中 $[i-p+1, i]$ 米的每一个站点上，**当前**是否停有公交车。

有较为显然的暴力代码：

```cpp
f[K][(1 << K) - 1] = 1;
rep1(i, K, n - 1) rep1(s, 0, (1 << P) - 1) {
	rep1(p, 0, P - 1) if ((s >> p) & 1) {
		int t = (s ^ (1 << p)) % (1 << P - 1);
		(f[i + 1][t << 1 | 1] += f[i][s]) %= mod;
	}
}
printf("%d", f[n][(1 << K) - 1]);
```

原理是：对于每个状态，想要扩展到下一米，一定要从中选一个公交车（即是 $1$ 的位置）放到最后。

那么这个东西加一个矩阵优化转移即可。

发现矩阵过大，一个显然的优化是只有二进制下 $1$ 的数量为 $k$ 的状态有用。因为公交车一定只有 $k$ 辆，而如果不足 $k$ 辆，丢掉的公交车就会因为距离限制无法向后移动，不合题意。

加上这个优化后，仍然过不了。发现对于 $f_i$，第 $i$ 米上的公交站点必定有公交车（注意状态的定义是前 $i$ 米都已经有过公交车）。那么就能通过这道题了。

```cpp
int n, K, P;
const int mod = 30031;
int sz, ep[1500], pe[130];

struct matrix {
	int a[130][130];
	
	il void init() {
		memset(a, 0, sizeof a);
	}
	
	il matrix operator * (const matrix &r) const {
		matrix ans; ans.init();
		rep1(k, 1, sz) rep1(i, 1, sz) rep1(j, 1, sz) (ans.a[i][j] += a[i][k] * r.a[k][j]) %= mod;
		return ans;
	}
} base, ans;

il bool legal(int x) {
	return __builtin_popcount(x) == K && x & 1;
}

int main() {
	read(n, K, P);
	rep1(i, 0, (1 << P) - 1) if (legal(i)) {
		ep[i] = ++sz; pe[sz] = i;
	}
	ans.a[ep[(1 << K) - 1]][1] = 1;
	rep1(s, 0, (1 << P) - 1) if (legal(s)) {
		rep1(p, 0, P - 1) if ((s >> p) & 1) {
			int t = (s ^ (1 << p)) & ((1 << P) - 1);
			t = t << 1 | 1;
			if (legal(t)) base.a[ep[s]][ep[t]] = 1;
		}
	} int t = n - K;
	while (t) {
		if (t & 1) ans = base * ans;
		base = base * base; t >>= 1;
	} printf("%d", ans.a[ep[(1 << K) - 1]][1]);
	rout;
}
```

---

## 作者：Eltaos_xingyu (赞：1)

考虑根据限制，我们可以转化一下贡献：即在任意一个 $[i,i+p-1]$ 的区间内，一定存在一个子序列是 $[1,K]$ 的排列。

我们设**距离 $i$ 最近的且在区间 $[i,i+p-1]$ 内的 $[1,K]$ 之间的数**为有效状态，那么这里就能使用 $0/1$ 状压，考虑如何转移。

首先不难发现，我们转移的对象就是删掉首位元素，然后再末尾补一个 $0$ 后的数。

我们举个例子：$p=5,K=3$ 时，假如有状态 $10110$，那么第二个 $0$ 必须被前面的 $1$ 转移，即 $10110\to 11100$。而如果有状态 $11001$，那么第一位实际上能转移到剩下的任何一个 $0$ 的位置上，于是有 $11001\to10110$ 和 $11001\to11010$ 和 $11001\to10011$。

从上面两个例子来看其实我们能枚举每一个数然后枚举每个操作后的 $0$，在 $O(p\times 2^{p})$ 的时间复杂度内完成转移的构建。

看到 $N\leq 10^9$ 的数据范围，想到矩阵转移，上面的转移明显是一个 $dp_{i,j}=\sum_{k}dp_{i-1,k}$ 的形式，直接构建转移矩阵然后转移即可。这个地方不难发现上面的所有状态的首位都是 $1$，然后我们离散化一下，状态数为 $\binom {P-1} {K-1}$，最大状态数为 $\binom 9 5=126$，设 $k=126$，时间复杂度为 $O(k^3\log N+p2^p)$，可以通过。 

---

## 作者：djh0314 (赞：1)

[**传送门**](https://www.luogu.com.cn/problem/P3204)。

## 题意

显然。

## 分析

我们首先需要观察的就是我们的数据范围：$N\le 10^9$，$P\le10$，$K\le 8$。非常优秀的一个数据范围，我们马上可以筛选我们的算法，主体肯定有一个类倍增的算法加速转移，而转移有极大可能是通过状压来解决。

首先可以想到这样一个状态：$f_{i,j}$ 表示当前来到第 $i$ 个车站，当前仍然停留有车的车站（显然使用状压，因为我们的 $P$ 很小，我们可以用类似滚动数组的方式处理我们的状态）。        

接下来解决一下转移。

由于我们题面的一个性质：$1$ 到 $K$ 号站作为始发站，$N-K+1$ 到 $N$ 号台作为终点站。因此我们的过程中，车辆总数是始终为 $k$ 的，这是一个小小的优化，也是转移的关键。

分为两种转移：
1. 假如说边界上有车，那么这辆车必须，并且只能是这两者转移到 $i$。
2. 假如说没有，那么我们可以从前边任意一辆车开过来。

可以得到这样的代码：
~~~cpp
for(int i=m; i<n; ++i) {
	for(int j=0; j<=up; ++j) {
		if(cnt[j]!=m) continue;//m即k
		if(j&(1<<P-1)) f[i+1][(j<<1|1)&up]=(f[i+1][(j<<1|1)&up]+f[i][j])%MOD;
		else {
			for(int k=0; k<P-1; ++k) {
				if((1<<k)&j) {
					int st=j^(1<<k);
					f[i+1][st<<1|1]=(f[i+1][st<<1|1]+f[i][j])%MOD;
				}
			}
		}
	}
}
~~~

我们后面的代码万变不离其宗，所以这一段代码一定要理解。

此时我们发现，可以拿到 $40pts$，时间复杂度：$O(n\times K\times w^P)$，（$w=2$），在空间与与时间上都受到限制。

紧接着，尝试优化我们的转移，首先就是最直白的，使用矩阵快速幂优化。

此处的代码大同小异，只是将原来的转移方式转化成矩阵上的节点 $+1$ 即可。由于数据上的特殊，我们的优化并没有效果，反而只能拿到 $10pts$，时间复杂度：$O(\log n\times w^{3\times P})$。

接下来我们就需要思考优化我们的转移。

首先上面提及的那个特征：过程中，车辆总数是始终为 $k$ 的，所以，我们的有用的节点实际只有 $C_{P}^{K} $ 个，即最大只有 $C_{10}^{5}=252 $ 个，可以使用一个 map 来进行离散化，现在我们就可以拿到 $80$ 的高分。

继续考虑优化我们的有用个数，又可以观察到，我们的状态实际上第 $0$ 位绝对是 1，又可以优化掉一位，拿下 $100pts$。

~~~cpp
int up=(1<<P)-1,cnt_m=0;
for(int i=1; i<=up; ++i) {
	cnt[i]=cnt[i-lowbit(i)]+1;
	if(cnt[i]==m&&(i&1)) ma[i>>1]=cnt_m++;
}
ans.n=1,ans.m=bas.n=bas.m=cnt_m;
ans.a[0][ma[((1<<m)-1)>>1]]=1;
for(int j=0; j<=up; ++j) {
	if(cnt[j]!=m||(j&1)==0) continue;
	if(j&(1<<P-1)) {
		add(bas,ma[j>>1],ma[((j<<1|1)&up)>>1]);
	} else {
		for(int k=0; k<P-1; ++k) {
			if((1<<k)&j) {
				int st=j^(1<<k);
				add(bas,ma[j>>1],ma[(st<<1|1)>>1]);
			}
		}
	}
}
~~~


---

## 作者：zzw4257 (赞：1)

### 题意
>有$n$个数,每个数$\in[1,k]$
已知$[1,k]$与$[n-k+1,n]$为$k$的排列
然后每个长度为$P$的区间都要包含$k$个不同的数，求方案数

### Solution

首先$k$小$p$小状态复杂考虑状压$dp$

记$f_{i,S}$表示统计到前$i$位,$[i,i+P-1]$的选取状态为$S$的方案数

考虑转移$f_{i,S}=\sum_{S'}f_{i-1,S'}$其中$S'$可以转移到$S$

其实就是$S'<<1$与$S$最多有一位不同

显然的，这个转移与$i$无关，因此用矩阵来实现这个转移，快速幂优化

---

## 作者：Wei_Han (赞：0)

双倍经验 [CF917C](https://www.luogu.com.cn/problem/CF917C)。

每次只能让最左边的一辆车走，那么所有车在任意时刻会形成一个长 $P$ 的区间，而 $P$ 很小，我们考虑直接状压所有车的位置，压成二进制位相互转移，这里比较好写，判定两个数异或起来是不是只有不超过一位不同就好了，转移系数都是 $1$。

$n$ 很大，这东西还是线性 dp，因此考虑矩阵快速幂优化，我们只需要 $\operatorname{popcount}(i)=k$ 的，因此矩阵大小在 $150$ 左右。

取 $w=152$，时间复杂度 $O(w^3\log n)$。

```cpp
const ll N=1e6+5,M=2e4+5;
ll x,n,q,k,id[N],w[N],cnt;
vector<pii> Q;
struct Mat
{
    ll a[150][150],n,m;
    Mat(ll _n,ll _m){n=_n,m=_m;fo(1,i,n) fo(1,j,m) a[i][j]=0;}
    Mat operator *(const Mat &b){Mat ans(n,b.m);fo(1,i,n) fo(1,j,b.m) fo(1,k,m) (ans.a[i][j]+=a[i][k]*b.a[k][j]%mod)%=mod;return ans;}
};
signed main(){
    read(n,x,k);
    fo((1<<k-1),i,(1<<k)-1) if(bct(i)==x) id[++cnt]=i,w[i]=cnt;Mat beg(cnt,cnt);
    fo(1,i,cnt) fo(1,j,cnt) if(bct(((id[i]^(1<<k-1))<<1)^id[j])<=1) beg.a[i][j]=1;
    ll pre=x,msk=0,len=n-pre;Mat cur(cnt,1);fo(0,i,x-1) msk|=1<<i;cur.a[w[msk]][1]=1;
    Mat opt(cnt,cnt);fo(1,i,cnt) opt.a[i][i]=1;
    while(len)
    {
        if(len&1) opt=opt*beg;
        beg=beg*beg;len>>=1;
    }
    wr(opt.a[cnt][cnt]),pr;
    return 0;
}
```

---

## 作者：快斗游鹿 (赞：0)

## 思路

注意到数据范围很小。考虑状压，设 $f_{i,S}$ 表示点 $i$ 前车站都被经过过的方案数，且 $[i,i+p-1]$ 这段区间内车站被第 $1$ 到 $k$ 辆车经过的状态为 $S$。那么只要一个状态 $S_1$ 能变成 $S_2$，就可以从 $f_{i-1,S1}$ 转移到 $f_{i,S2}$。观察我们的定义，可以发现，$S$ 若合法，则最高位必然为 $1$ 且其中 $1$ 的数量为 $k$。因为我们已经默认点 $i$ 被经过，而总共只有 $k$ 辆车。

考虑 $S_1$ 什么时候能转移到 $S_2$。每次移动相当于将 $S_1$ 中最前面的那辆车移除，并让它停靠在 $S_2$ 中没有被经过过的任意车站。因此，先将 $S_1$ 左移一位，若 $S_2$ 中恰有 $k-1$ 个被经过过的车站与当前 $S_1$ 中被经过过的车站吻合，则 $S_1$ 可以转移到 $S_2$。

但 $n$ 很大，怎么办？可以发现，如果把每个合法状态看做一个点，$S_1$ 可以转移到 $S_2$，就相当于在两点间连一条边，最终会建成一张图，产生一个邻接矩阵。问题可以转化为在图上走恰好 $n-k$ 步，能从初始点出发，并走回初始点的方案数。矩阵快速幂解决即可。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=200;
const int S=2e3+5;
const int mod=30031;
struct mat{
	int a[N][N];
	void build(){
		for(int i=1;i<=150;i++)a[i][i]=1;
	}
	void clear(){
		memset(a,0,sizeof(a));
	}
}a,ans;
int n,k,p,cnt,f[N];
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
mat operator *(const mat x,const mat y){
	mat z;z.clear();
	for(int i=1;i<=cnt;i++){
		for(int j=1;j<=cnt;j++){
			for(int k=1;k<=cnt;k++){
				z.a[i][j]+=(x.a[i][k]*y.a[k][j])%mod;
				z.a[i][j]%=mod;
			}
		} 
	}
	return z;
}
bool check(int x,int y){
	x<<=1;
	int cnt=0;
	for(int i=0;i<p;i++){
		if((x&(1<<i))&&(y&(1<<i)))cnt++;
	}
	if(cnt==k-1)return 1;
	return 0;
}
void print(){
	/*for(int i=1;i<=cnt;i++){
		for(int j=1;j<=cnt;j++)cout<<a.a[i][j]<<" ";
		cout<<endl;
	}
	cout<<endl;
	for(int i=1;i<=cnt;i++){
		for(int j=1;j<=cnt;j++)cout<<ans.a[i][j]<<" ";
		cout<<endl;
	}
	cout<<endl;*/
}
signed main(){
	n=read();k=read();p=read();
	for(int i=(1<<(p-1));i<(1<<p);i++){
		if(__builtin_popcount(i)==k){
			f[++cnt]=i;
		}
	}
	for(int i=1;i<=cnt;i++){
		for(int j=1;j<=cnt;j++){
			if(check(f[i],f[j])){
				a.a[i][j]=1;//cout<<f[i]<<" "<<f[j]<<endl;
				//cout<<i<<" "<<j<<endl;
			}
		}
	}
	int t=n-k;ans.build();
	//print();
	//a=a*a;
	//print(); 
	while(t){
		if(t&1)ans=ans*a;
		print();
		a=a*a;
		print();
		t>>=1;
	}
	printf("%lld\n",ans.a[cnt][cnt]);
	return 0;
}

```


---

## 作者：xuantianhao (赞：0)

## [ [HNOI2010] 公交线路](https://www.luogu.com.cn/problem/P3204)

状压加矩乘的好题。

因为每 $p$ 个位置中，每辆车就至少有 1 个位置，所以我们可以状压一下。

设 $f[i][j]$ 表示：

区间 $[i,i+p-1]$ 内的车站现在的规划情况是 $j$ 的方案数。

显然，必有 $j$ 的第 $p$ 位是 1，且 $j$ 共有 $k$ 位是 1（$j$ 的第 $p$ 位对应着 $i$）。

则 $f[i][j]=\sum f[i-1][k]$，其中 $k$ 能转移到 $j$。

那什么样的 $k$ 能转移到 $j$ 呢？

我们将 $k$ 左移一位（即增加了 $i+p-1$ 位），然后删去第 $p$ 位的数（即删去第 $i-1$ 位），得到了一个 $k'$。

如果 $k'$ 和 $j$ 只相差恰好 1 位，那么 $k$ 就可以转移到 $j$，第 $i-1$ 位的车刚好跑到了着相差的一位。

然后发现，对于每个 $f[i][j]$ ，它的祖先的 $k$ 都是完全一致的；因此可以矩乘优化，建立转移矩阵 $T[k][j]$ ，如果状态 $k$ 可以转移到 $j$，则 $T[k][j]=1$，否则为 0。

则复杂度为 $O(S^3\log n)$，其中 $S$ 是合法状态数量（即符合 $j$ 的第 $p$ 位是 1，且 $j$ 共有 $k$ 位是 1 的 $j$ 的数量）。我们有 $S=C_{p-1}^{k-1}$，当 $p=10,k=5 \operatorname{or} 6$ 时取得最大值，有 $S=C_9^4\ \operatorname{or}\ C_9^5=126$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=30031;
int n,m,p,len,sta[150];
struct mat{
    int g[150][150];
    mat(){memset(g,0,sizeof(g));}
    friend mat operator *(const mat &x,const mat &y){
        mat z;
        for(int i=0;i<len;i++)for(int j=0;j<len;j++)for(int k=0;k<len;k++)(z.g[i][j]+=x.g[i][k]*y.g[k][j])%=mod;
        return z;
    }
}X,I;
bool che(int x,int y){
    x<<=1,x-=(1<<p);
    return __builtin_popcount(x^y)<=1;
}
void ksm(int y){
    for(;y;X=X*X,y>>=1)if(y&1)I=I*X;
}
int main(){
    scanf("%d%d%d",&n,&m,&p);
    for(int i=(1<<(p-1));i<(1<<p);i++)if(__builtin_popcount(i)==m)sta[len++]=i;
    for(int i=0;i<len;i++)I.g[i][i]=1;
    for(int i=0;i<len;i++)for(int j=0;j<len;j++)X.g[i][j]=che(sta[i],sta[j]);
    ksm(n-m);
    printf("%d\n",I.g[len-1][len-1]);
    return 0;
} 
```

---


# [HNOI2011] 括号修复 / [JSOI2011] 括号序列

## 题目描述

一个合法的括号序列是这样定义的：

1.    空串是合法的。
2.    如果字符串 `S` 是合法的，则`(S)`也是合法的。
3.    如果字符串 `A` 和 `B` 是合法的，则 `AB` 也是合法的。

现在给你一个长度为 $n$ 的由`(`和`)`组成的字符串，位置标号从 $1$ 到 $n$。对这个字符串有下列四种操作：


-  `Replace a b c`：将 $[a,b]$ 之间的所有括号改成 $c$。假设原来的字符串为：`))())())(`，那么执行操作 `Replace 2 7 (`  后原来的字符串变为：`)(((((()(`。

-  `Swap a b`：将 $[a,b]$ 之间的字符串翻转。假设原来的字符串为：`))())())(`，那么执行操作 `Swap 3 5` 后原来的字符串变为：`))))(())(`。

-  `Invert a b`：将 $[a,b]$ 之间的 `(` 变成 `)` ，`)` 变成 `(`。假设原来的字符串为：`))())())(`，那么执行操作 `Invert 4 8` 后原来的字符串变为：`))((()(((`。

-  `Query a b`：询问 $[a,b]$ 之间的字符串至少要改变多少位才能变成合法的括号序列。改变某位是指将该位的 `(` 变成 `)` 或 `)` 变成 `(`。注意执行操作 `Query` 并不改变当前的括号序列。假设原来的字符串为：`))())())(`，那么执行操作 `Query 3 6` 的结果为 $2$，因为要将位置 $5$ 的`)`变成`(`并将位置 $6$ 的`(`变成`)`。


## 说明/提示

### 样例解释

输入中有 $2$ 个 `Query` 操作，所以输出有 $2$ 行。   
执行第一个 `Query` 操作时的括号序列为 `))((`，因改变第 $1$ 位可使 $[1,2]$ 之间的字符串变成合法的括号序列，故输出的第一行为 `1`。  

执行第二个 `Query` 操作时的括号序列为 `)(()`，因要改变第 $1$ 位和第 $2$ 位才能使 $[1,4]$ 之间的字符串变成合法的括号序列，故输出的第二行为 `2`。

### 数据范围

对于 $30\%$ 的数据，$1\le n,q \le 3000$；   
对于 $100\%$ 的数据，$1\le n,q \le 10^5$。

## 样例 #1

### 输入

```
4 5
((((
Replace 1 2 )
Query 1 2
Swap 2 3
Invert 3 4
Query 1 4```

### 输出

```
1
2
```

# 题解

## 作者：NaCly_Fish (赞：27)

首先，设 `( = -1`，`) = 1`，定义 $\text{prmax}$ 为前缀最大值，$\text{sfmin}$ 为后缀最小值，那么一个区间的答案为

$$\lceil \text{prmax}/2\rceil+\lceil|\text{sfmin}|/2\rceil$$

要维护答案，考虑~~众所周知~~的 线段树/平衡树 五问：  
(跟 zyb 学的)

1、每个节点需要记录哪些信息？

要记录区间和，前缀最大、最小，后缀最大、最小。 

2、需要哪些标记？  

只需要题目中的三种操作标记即可。

3、如何下传标记？  

先来考虑标记优先级：取反、覆盖、翻转。  

打取反标记时，区间和、节点值直接取反；$\text{prmax}$ 变 $-\text{prmin}$，$\text{prmin}$ 变 $-\text{prmax}$，对于后缀同理。别忘了还要对覆盖标记取反。  

对于覆盖标记，若赋值为正数，$\text{prmax,sfmax}$ 变区间和，$\text{prmin,sfmin}$ 变为 $0$。对于赋值为负数同理。

翻转标记比较简单，除了交换左右儿子，再交换前缀、后缀的最大最小和即可。

4、如何对区间整体修改？  

这个没什么好说的，直接在对应区间的子树根上打标记即可。

5、如何合并区间 (上传信息)？

这里可以参考 [GSS1](https://www.luogu.org/problem/SP1043) 传标记的做法，也就是这样：
```cpp
prmax[u] = max(prmax[ls],sum[ls]+a[u]+prmax[rs]);
prmin[u] = min(prmin[ls],sum[ls]+a[u]+prmin[rs]);
sfmax[u] = max(sfmax[rs],sum[rs]+a[u]+sfmax[ls]);
sfmin[u] = min(sfmin[rs],sum[rs]+a[u]+sfmin[ls]);
```
这里 `ls` 和 `rs` 分别指左右儿子。
解决了上面五问，整个题就解决啦。

参考代码：
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<ctime>
#define reg register
#define N 100003
#define ls son[u][0]
#define rs son[u][1]
using namespace std;

inline void read(int &x){
	x = 0;
	char c = getchar();
	while(c<'0'||c>'9') c = getchar();
	while(c>='0'&&c<='9'){
		x = (x<<3)+(x<<1)+(c^48);
		c = getchar();
	}
}

int n,q;

struct fhqTreap{
	int a[N],son[N][2],rnd[N],sum[N],sfmax[N],sfmin[N];
	int tag[N],size[N],prmax[N],prmin[N];
	bool rev[N],inv[N];
	int rt,cnt;
	
	inline int neww(int x){
		int u = ++cnt;
		sum[u] = a[u] = x;
		if(x==1) prmax[u] = sfmax[u] = 1;
		else sfmin[u] = prmin[u] = -1;
		size[u] = 1;
		rnd[u] = rand();
		return u;
	}
	
	inline void pushup(int u){
		sum[u] = sum[ls]+sum[rs]+a[u];
		size[u] = size[ls]+size[rs]+1;
		prmax[u] = max(prmax[ls],sum[ls]+a[u]+prmax[rs]);
		prmin[u] = min(prmin[ls],sum[ls]+a[u]+prmin[rs]);
		sfmax[u] = max(sfmax[rs],sum[rs]+a[u]+sfmax[ls]);
		sfmin[u] = min(sfmin[rs],sum[rs]+a[u]+sfmin[ls]);
	}
	
	inline void pushr(int u){
		swap(ls,rs);
		swap(prmax[u],sfmax[u]);
		swap(prmin[u],sfmin[u]);
		rev[u] ^= 1;
	}
	
	inline void pushiv(int u){
		a[u] = -a[u];
		sum[u] = -sum[u];
		int x = prmax[u],y = prmin[u];
		prmin[u] = -x,prmax[u] = -y;
		x = sfmax[u],y = sfmin[u];
		sfmin[u] = -x,sfmax[u] = -y;
		inv[u] ^= 1;
		tag[u] = -tag[u];
	}
	
	inline void pushc(int u,int k){
		a[u] = tag[u] = k;
		sum[u] = size[u]*k;
		if(k==1){
			prmin[u] = sfmin[u] = 0;
			prmax[u] = sfmax[u] = sum[u];
		}else{
			prmax[u] = sfmax[u] = 0;
			prmin[u] = sfmin[u] = sum[u];
		}
	}
	
	inline void pushdown(int u){
		if(inv[u]){
			if(ls) pushiv(ls);
			if(rs) pushiv(rs);
			inv[u] = 0;
		}
		if(tag[u]){
			if(ls) pushc(ls,tag[u]);
			if(rs) pushc(rs,tag[u]);
			tag[u] = 0;
		}
		if(!rev[u]) return;
		if(ls) pushr(ls);
		if(rs) pushr(rs);
		rev[u] = 0;
	}
	
	int merge(int u,int v){
		pushdown(u);
		pushdown(v);
		if(!u||!v) return u|v;
		if(rnd[u]<rnd[v]){
			son[u][1] = merge(son[u][1],v);
			pushup(u);
			return u;
		}else{
			son[v][0] = merge(u,son[v][0]);
			pushup(v);
			return v;
		}
	}
	
	void split(int cur,int k,int &u,int &v){
		if(!cur){
			u = v = 0;
			return;
		}
		pushdown(cur);
		if(size[son[cur][0]]<k){
			u = cur;
			split(son[u][1],k-size[ls]-1,son[u][1],v);
		}else{
			v = cur;
			split(son[v][0],k,u,son[v][0]);
		}
		pushup(cur);
	}
	
	inline void push_back(int x){
		rt = merge(rt,neww(x));
	}
	
	inline int query(int l,int r){
		int x,y,z,t,res;
		split(rt,l-1,x,y);
		split(y,r-l+1,y,z);
		t = prmax[y];
		res = (t&1)?(t>>1)+1:(t>>1);
		t = abs(sfmin[y]);
		res += (t&1)?(t>>1)+1:(t>>1);
		rt = merge(merge(x,y),z);
		return res;
	}
	
	inline void reverse(int l,int r){
		int x,y,z;
		split(rt,l-1,x,y);
		split(y,r-l+1,y,z);
		pushr(y);
		rt = merge(merge(x,y),z);
	}
	
	inline void replace(int l,int r,int k){
		int x,y,z;
		split(rt,l-1,x,y);
		split(y,r-l+1,y,z);
		pushc(y,k);
		rt = merge(merge(x,y),z);
	}
	
	inline void invert(int l,int r){
		int x,y,z;
		split(rt,l-1,x,y);
		split(y,r-l+1,y,z);
		pushiv(y);
		rt = merge(merge(x,y),z);
	}
	
	void dfs(int u){
		pushdown(u);
		if(ls) dfs(ls);
		printf("%d ",a[u]);
		if(rs) dfs(rs);
	}
}T;

inline bool check(char c){
	return (c>='a'&&c<='z')||(c>='A'&&c<='Z');
}

int main(){
	srand(time(0));
	int l,r,k;
	read(n),read(q);
	char op,c = getchar();
	while(c!='('&&c!=')') c = getchar();
	while(c=='('||c==')'){
		T.push_back(c==')'?1:-1);
		c = getchar();
	}
	while(q--){
		c = getchar();
		while(!check(c)) c = getchar();
		op = c;
		while(check(c)) c = getchar();
		read(l),read(r);
		if(op=='R'){
			c = getchar();
			while(c!='('&&c!=')') c = getchar();
			k = c==')'?1:-1;
		}
		if(op=='R') T.replace(l,r,k);
		else if(op=='S') T.reverse(l,r);
		else if(op=='I') T.invert(l,r);
		else printf("%d\n",T.query(l,r));
	}
    return 0;
}
```

---

## 作者：Orion545 (赞：15)

先膜楼下dalao


我的方法和他类似，但是思路会更清晰一些，而且也有细微的差距


然而我觉得我讲的比他好【滑稽


### 【广告】blog


[Dedicatus545](http://www.cnblogs.com/dedicatus545/p/8387569.html)


## 思路：


显然，操作4中输出补全的最小费用是关键


这决定了我们不可能在splay上只维护1-2个值。


考虑一段括号序列，将其中所有合法序列删去以后，留下的一定是形如 ))))))((( 的序列


因此首先考虑将每段区间左侧不匹配的括号数和右侧不匹配的括号数记录下来，分别为 left[l,r] 和 right[l,r]


此时除了Invert操作以外已经可以满足


但是对于Invert操作，对于每一个括号取反，显然每边只记录一个是不够的。


考虑再次转化模型，将括号序列抽象化成数字的和


发现：一个匹配的括号序列中左括号等于右括号，一段缩过的序列（去掉了所有的合法序列）的左侧右括号数量和右侧左括号数量，恰等于左右括号数量的前缀和以及后缀和。


因此，将右括号 ）视为-1，左括号（ 视为+1，对每一段区间，记录其最小前缀和和最大后缀和，即为上文所述 left && right


同时，我们记录区间的最大前缀和和最小后缀和，作为Swap和Invert操作时候用。


对于Swap操作，即为整个序列翻转，那么其最大前缀和与最大后缀和交换，最小前缀和与最小后缀和交换


对于Invert操作，需要交换最大最小前缀和，以及最大最小后缀和，再将它们全部取反


因为每个括号取反以后，原来最小的前缀和对应的哪一个序列，现在具有所有前缀里面的最大值（在相反数意义下）


后缀同理


统计答案即为对于所求区间，求 (l1/2)+(r2/2) ，若l1,r2是奇数，则还需加二（额外费用）


 

综上所述，令每一个）为-1，每一个（为1，记录每一个区间的最小最大前缀和 l1,l2 以及最小最大后缀和 r1,r2，将整个序列放到splay上操作即可。


需要注意的是，更新区间全部刷成同一个值的lazy标记时，一定要同时去掉已有的invert标记，以防WA



#### Code：


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
inline int read(){
    int re=0,flag=1;char ch=getchar();
    while(ch>'9'||ch<'0'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
    return re*flag;
}
int n,m,root,cnt;
int fa[100010],ch[100010][2],siz[100010];
int w[100010],l1[100010],l2[100010],r1[100010],r2[100010],sum[100010];
int rev[100010]={0},lazy[100010]={0},inv[100010]={0};
int x[100010];
//lazy==1:  (
//lazy==-1: )
void _swap(int &x,int &y){x^=y;y^=x;x^=y;}
int _max(int x,int y){return (x<y)?y:x;}
int _min(int x,int y){return (x>y)?y:x;}
void update(int x){
    if(!x) return;
    sum[x]=sum[ch[x][0]]+sum[ch[x][1]]+w[x];
    siz[x]=siz[ch[x][0]]+siz[ch[x][1]]+1;
    l1[x]=_min(l1[ch[x][0]],sum[ch[x][0]]+w[x]+l1[ch[x][1]]);
    l2[x]=_max(l2[ch[x][0]],sum[ch[x][0]]+w[x]+l2[ch[x][1]]);
    r1[x]=_min(r1[ch[x][1]],sum[ch[x][1]]+w[x]+r1[ch[x][0]]);
    r2[x]=_max(r2[ch[x][1]],sum[ch[x][1]]+w[x]+r2[ch[x][0]]);
}
void pushdown(int x,int t){
    if(!x) return;
    inv[x]=0;w[x]=t;lazy[x]=t;
    if(~t){
        sum[x]=siz[x];
        l1[x]=r1[x]=0;
        l2[x]=r2[x]=sum[x];
    }
    else{
        sum[x]=~siz[x]+1;
        l2[x]=r2[x]=0;
        l1[x]=r1[x]=sum[x];
    }
}
void pushrev(int x){
    if(!x) return;
    _swap(ch[x][0],ch[x][1]);
    _swap(l1[x],r1[x]);
    _swap(l2[x],r2[x]);
    rev[x]^=1;
}
void pushinv(int x){
    if(!x) return;
    _swap(l1[x],l2[x]);
    _swap(r1[x],r2[x]);
    l1[x]=~l1[x]+1;l2[x]=~l2[x]+1;
    r1[x]=~r1[x]+1;r2[x]=~r2[x]+1;
    w[x]=~w[x]+1;sum[x]=~sum[x]+1;
    inv[x]^=1;//注意这里！！！！
}
void push(int x){
    if(!x) return;
    if(rev[x]){
        pushrev(ch[x][0]);
        pushrev(ch[x][1]);
        rev[x]=0;
    }
    if(lazy[x]){
        pushdown(ch[x][0],lazy[x]);
        pushdown(ch[x][1],lazy[x]);
        lazy[x]=0;
    }
    if(inv[x]){
        pushinv(ch[x][0]);
        pushinv(ch[x][1]);
        inv[x]=0;
    }
}
int get(int x){return ch[fa[x]][1]==x;}
void rotate(int x){
    int f=fa[x],ff=fa[f],son=get(x);
    push(f);push(x);
    ch[f][son]=ch[x][son^1];
    if(ch[f][son]) fa[ch[f][son]]=f;
    fa[f]=x;ch[x][son^1]=f;
    fa[x]=ff;
    if(ff) ch[ff][ch[ff][1]==f]=x;
    update(f);update(x);
}
void splay(int x,int to){
    if(x==to||fa[x]==to) return;
    if(!to) root=x;
    for(int f;(f=fa[x])&&f!=to;rotate(x))
        if(fa[f]!=to)
            rotate(get(f)==get(x)?f:x);
    update(x);
}
int rank(int x,int pos){
    push(pos);
    if(siz[ch[pos][0]]+1==x){
        splay(pos,0);return pos;
    }
    if(siz[ch[pos][0]]>=x) return rank(x,ch[pos][0]);
    else return rank(x-siz[ch[pos][0]]-1,ch[pos][1]);
}
int build(int le,int ri,int f){
    if(le>ri) return 0;
    int mid=(le+ri)>>1,cur=++cnt;
    //cout<<"build "<<le<<" "<<ri<<" "<<mid<<" "<<x[mid]<<"\n";
    w[cur]=x[mid];fa[cur]=f;
    ch[cur][0]=build(le,mid-1,cur);
    ch[cur][1]=build(mid+1,ri,cur);
    update(cur);return cur;
}
void change(int le,int ri,int t){
    int x=rank(le,root),y=rank(ri+2,root);
    splay(x,0);splay(y,root);
    pushdown(ch[y][0],t);
    update(y);update(x);
}
void reverse(int le,int ri){
    int x=rank(le,root),y=rank(ri+2,root);
    splay(x,0);splay(y,root);
    pushrev(ch[y][0]);
    update(y);update(x);
}
void invert(int le,int ri){
    int x=rank(le,root),y=rank(ri+2,root);
    splay(x,0);splay(y,root);
    pushinv(ch[y][0]);
    update(y);update(x);
}
int query(int le,int ri){
    int x=rank(le,root),y=rank(ri+2,root);
    splay(x,0);splay(y,root);
    return ((r2[ch[y][0]]+1)>>1)-((l1[ch[y][0]]-1)/2);
    //这里右移的对象如果是负数，那么右移的效果就不是/2.而是(+1)/2，类似-3会变成-2而不是-1
    //被这里卡了30min【雾
}
void dfs(int u){
    if(!u) return;
    push(u);
    dfs(ch[u][0]);
    printf("%d %d %d %d\n",u,fa[u],ch[u][0],ch[u][1]);
    printf("%d %d %d %d %d\n",w[u],l1[u],l2[u],r1[u],r2[u]);
    dfs(ch[u][1]);
}
char s[100010];
int main(){
//    freopen("brackets.in","r",stdin);
//    freopen("brackets.out","w",stdout);
    int i,t1,t2,t4;char t3;
    n=read();m=read();
    scanf("%s",s);
    for(i=1;i<=n;i++) x[i]=((s[i-1]=='(')?1:-1);
    root=build(0,n+1,0);
    //dfs(root);printf("\n");
    for(i=1;i<=m;i++){
        scanf("%s",s);
        if(s[0]=='R'){
            t1=read();t2=read();t3=getchar();
            while(t3!='('&&t3!=')') t3=getchar();
            t4=((t3=='(')?1:-1);
            change(t1,t2,t4);
        }
        if(s[0]=='I'){
            t1=read();t2=read();
            invert(t1,t2);
        }
        if(s[0]=='Q'){
            t1=read();t2=read();
            printf("%d\n",query(t1,t2));
        }
        if(s[0]=='S'){
            t1=read();t2=read();
            reverse(t1,t2);
        }
        //dfs(root);printf("\n");
    }
}
```

---

## 作者：ChthollyTree (赞：12)

既然有区间推平操作，自然就想到珂朵莉树了

之后几个操作就可以暴力维护了

就是Query操作说一下做法

我的做法是：求出 设 ( 为 1， ) 为-1

求出这个区间的前缀和

如果某个地方的前缀和小于 0 （设为S）则说明此时前面的 ')'数量多于 '(' 数量，无法匹配，此时则需要修改
修改 $\frac{-s}{2}$(上取整)个括号

同时修改前缀和（s为奇数改为1，否则为0）

最后的 若 前缀和 > 0 表示 '(' 较多,无法匹配

则还需要修改$\frac{s}{2}$个括号


```
#include<bits/stdc++.h>
using namespace std;

#define MAXN 100005
#define se  set<aa>
#define it iterator 

int n,m;
int a[MAXN];
char ch[MAXN];
struct aa
{
	int l,r,v;
};
bool operator <(aa a,aa b) {
	return a.r < b.r;
}
set<aa>s;

void wt()
{
	for(se::it i = s.begin(); i != s.end(); i ++)
	{
		cout<<(i->l)<<" "<<(i->r)<<" "<<(i->v)<<"\n";
	}
} 

int zh(char a)
{
	if(a == '(') return 1;
	else return -1;
	
}

void splix(se::it a,int i) {
	if(i < a->l) return;
	if(a->r < i+1) return;
	int sl = a->l,sr = a->r,sv = a->v;
	s.erase(a);
	s.insert((aa){sl,i,sv});
	s.insert((aa){i+1,sr,sv});
}

void fen(int l,int r)
{
	se::it x = s.lower_bound((aa){0,l,0});
	splix(x,l-1);
	se::it y = s.lower_bound((aa){0,r,0});
	splix(y,r);
}

void tuiping(int l,int r,int v)
{
	fen(l,r);
	se::it x = s.lower_bound((aa){0,l,0});
	se::it y = s.lower_bound((aa){0,r,0});
	y ++;
	s.erase(x,y);
	s.insert((aa){l,r,v});
}

aa c[MAXN];
int nn;

void tiqu(int l,int r)
{
	fen(l,r);
	se::it x = s.lower_bound((aa){0,l,0});
	se::it y = s.lower_bound((aa){0,r,0});
	nn = 0;
	for(se::it i = x; 1 == 1; i ++) {
		nn ++;
		c[nn] = (*i);
	//	cout<<nn<<":"<<c[nn].l<<" "<<c[nn].r<<" "<<c[nn].v<<"\n"; 
		if(i == y) break;
	}
} 

void Swap(int l,int r)
{
	fen(l,r);
	tiqu(l,r);
	se::it x = s.lower_bound((aa){0,l,0});
	se::it y = s.lower_bound((aa){0,r,0});
	y ++;
	s.erase(x,y);
	for(int i = 1; i <= nn; i ++) {
		s.insert((aa){r - (c[i].r - c[i].l),r,c[i].v});
		r -= (c[i].r - c[i].l)+1;
	//	cout<<r<<"\n";
	}
}

void Invert(int l,int r) {
	fen(l,r);
	tiqu(l,r);
	se::it x = s.lower_bound((aa){0,l,0});
	se::it y = s.lower_bound((aa){0,r,0});
	y ++;
	s.erase(x,y);
	for(int i = 1; i <=  nn; i ++) {
		s.insert((aa){c[i].l,c[i].r,-c[i].v});
	} 	
}

void qiu(int l,int r)
{
	fen(l,r);
	tiqu(l,r);
	int ans = 0,s = 0;
	for(int i = 1; i <= nn; i ++)
	{
		s += (c[i].r - c[i].l + 1)*c[i].v;
		if(s < 0)
		{
			ans += (-s)>>1;
			if((-s)&1) 
			{
				s = 1;
				ans ++;
			}
			else s = 0;
		}
	}
	ans += abs(s)>>1; 
	printf("%d\n",ans);
}

int main()
{
	scanf("%d%d",&n,&m);
	scanf("%s",ch+1);
	for(int i = 1; i <= n; i ++) {
		if(ch[i] ==  '(' )
		{
			a[i] = 1;
			s.insert((aa){i,i,a[i]});
		}else {
			a[i] = -1;
			s.insert((aa){i,i,a[i]});
		}
	} 
//	wt();
	for(int i = 1; i <= m; i ++)
	{
		string opt;
		cin >> opt;
		if(opt == "Replace")
		{
			int l,r;
			scanf("%d%d",&l,&r);
			string ot;
			cin >> ot;
			tuiping(l,r,zh(ot[0])); 
		}
		if(opt == "Query")
		{
			int l,r;
			scanf("%d%d",&l,&r);
			qiu(l,r);
		}
		if(opt == "Swap")
		{
			int l,r;
			scanf("%d%d",&l,&r);
			Swap(l,r);
		}
		if(opt == "Invert")
		{
			int l,r;
			scanf("%d%d",&l,&r);
			Invert(l,r);
		}
	}
	return 0;
}

```

---

## 作者：xuxinyu (赞：11)

需要改变的括号序列一定长这样 ：)))(((

最少改变次数= 多余的‘）’/2 【上取整】 + 多余的‘（’ /2 【上取整】

把 ‘）’ 看做1，‘（’ 看做-1

那么最少改变次数=最大前缀和/2 【上取整】+ 最小后缀和/2 【上取整】

 

覆盖标记的优先级高于翻转标记和取反标记

即下放覆盖标记时，同时清空翻转标记和取反标记

且先下放覆盖标记

 

翻转：

最大前缀和 和 最大后缀和 交换

最小前缀和 和 最小后缀和 交换

 

取反：

最大前缀和 和 最小前缀和 交换，同时取反

最大后缀和 和 最小后缀和 交换，同时取反

 

最大XX和的下界为0，最小XX和的上界为0

因为最大XX和实际是多余的‘）’数量

最小XX和的相反数实际是多余的‘（’数量

数量不能为负数

 

注意点：

1、增加了首尾两个虚拟节点后，数组要多开2

2、平衡树每个节点由三部分组成，左子树、自己、右子树，打取反标记的时候不要忘记给自己取反

代码：

```
#include<cstdio>
#include<cstdlib>
#include<iostream>

using namespace std;

#define N 100001

char ss[N];
int a[N];

int root,tot;

int st[N];

bool rev[N],inv[N];
int tag[N];
int pre[N],suf[N];
int sum[N];
int pri[N],val[N];

int siz[N],ch[N][2];

int tmp;

void read(int &x)
{
    x=0; char c=getchar();
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)) { x=x*10+c-'0'; c=getchar(); }
}

inline int &max(int &a,int &b) { return a>b ? a : b; }
inline int &min(int &a,int &b) { return a<b ? a : b; }

void update(int x)
{
    int l=ch[x][0],r=ch[x][1];
    siz[x]=siz[l]+siz[r]+1;
    sum[x]=sum[l]+sum[r]+val[x];
    pre[x]=max(pre[l],sum[l]+pre[r]+val[x]);
    pre[x]=max(pre[x],sum[l]+val[x]);
    suf[x]=max(suf[r],sum[r]+suf[l]+val[x]);
    suf[x]=max(suf[x],sum[r]+val[x]);
}

int newnode(int v)
{
    val[++tot]=sum[tot]=v;
    pre[tot]=suf[tot]=max(0,val[tot]);
    sum[tot]=val[tot];
    siz[tot]=1;
    pri[tot]=rand();
    return tot;
}

int build(int l,int r)
{
    int top=0; int last,now;
    for(int i=l;i<=r;++i)
    {
        now=newnode(a[i]);
        last=0;
        while(top && pri[now]<pri[st[top]])
        {
            update(st[top]);
            last=st[top--];
        }
        if(top) ch[st[top]][1]=now;
        ch[now][0]=last; 
        st[++top]=now;
    }
    while(top) update(st[top--]);
    return st[1];
}

void down(int x)
{
    int l=ch[x][0],r=ch[x][1];
    if(tag[x])
    {
        if(l)
        {
            val[l]=tag[x];
            sum[l]=tag[x]*siz[l];
            pre[l]=suf[l]=max(0,sum[l]);
            rev[l]=inv[l]=false;
            tag[l]=tag[x];
        }
        if(r)
        {
            val[r]=tag[x];
            sum[r]=tag[x]*siz[r];
            pre[r]=suf[r]=max(0,sum[r]);
            rev[r]=inv[r]=false;
            tag[r]=tag[x];
        }
        tag[x]=0;
    }
    if(rev[x])
    {
        if(l)
        {	
            swap(pre[l],suf[l]);
            swap(ch[l][0],ch[l][1]);
            rev[l]^=1;
        }
        if(r)
        {	
            swap(pre[r],suf[r]);
            swap(ch[r][0],ch[r][1]);
            rev[r]^=1;
        }
        rev[x]^=1;
    }
    if(inv[x])
    {
        if(l)
        {
            tmp=pre[l];
            pre[l]=max(0,-(sum[l]-suf[l]));
            suf[l]=max(0,-(sum[l]-tmp));
            sum[l]=pre[l]+min(0,-sum[l]-pre[l]);
            val[l]=-val[l];
            inv[l]^=1;
        }
        if(r)
        {
            tmp=pre[r];
            pre[r]=max(0,-(sum[r]-suf[r]));
            suf[r]=max(0,-(sum[r]-tmp));
            sum[r]=pre[r]+min(0,-sum[r]-pre[r]);
            val[r]=-val[r];
            inv[r]^=1;
        }
        inv[x]^=1;
    }
}

void split(int now,int k,int &x,int &y)
{
    if(!now) x=y=0;
    else
    {
        down(now);
        if(k<=siz[ch[now][0]])
        {
            y=now;
            split(ch[now][0],k,x,ch[now][0]);
        }
        else
        {
            x=now;
            split(ch[now][1],k-siz[ch[now][0]]-1,ch[now][1],y);
        }
        update(now);
    }		
}

int merge(int x,int y)
{
    if(x) down(x);
    if(y) down(y);
    if(!x || !y) return x+y;
    if(pri[x]<pri[y])
    {
        ch[x][1]=merge(ch[x][1],y);
        update(x);
        return x;
    }
    else
    {
        ch[y][0]=merge(x,ch[y][0]);
        update(y);
        return y;
    }
}
    

int main()
{
    int n,m;
    read(n); read(m);
    scanf("%s",ss+2);
    for(int i=2;i<=n+1;++i) 
        if(ss[i]==')') a[i]=1;
        else a[i]=-1;
    root=build(1,n+2);
    int l,r; char s[10],cc[3];
    int a,b,c,d,e;
    while(m--)
    {
        scanf("%s",s);
        read(l); read(r);
        l++; r++;
        split(root,r,a,b);
        split(a,l-1,c,d);
        if(s[0]=='R')
        {
            scanf("%s",cc);
            e= cc[0]==')' ? 1 : -1;
            tag[d]=e;
            val[d]=e;
            sum[d]=e*siz[d];
            pre[d]=suf[d]=max(0,sum[d]);
            rev[d]=inv[d]=false;
        }
        else if(s[0]=='S')
        {
            rev[d]=true;
            swap(ch[d][0],ch[d][1]);
            swap(pre[d],suf[d]);
        }
        else if(s[0]=='I')
        {
            inv[d]=true;
            tmp=pre[d];
            pre[d]=max(0,-(sum[d]-suf[d]));
            suf[d]=max(0,-(sum[d]-tmp));
            sum[d]=pre[d]+min(0,-sum[d]-pre[d]);
            val[d]=-val[d];
        }
        else printf("%d\n",(pre[d]+1)/2+(-sum[d]+pre[d]+1)/2);
        root=merge(merge(c,d),b);
    }
}

```

---

## 作者：我是逍逍 (赞：6)

#### 题目描述

首先定义合法括号匹配串 $Str$，满足人类直觉匹配。（~~瞪眼匹配法~~）

接着给出长度为 $n$ 的字符串 $S$，并给出长度为 $q$ 的操作序列。

操作有 **Replace**，**Swap (Reverse)**，**Invert** 三种，以及询问 **Query (Ask)**，意义见题面，不做赘述。

对于每个询问，输出一行一个非负整数表示答案。数据范围 $n, q \leq 10^5$。

#### 算法分析

对于三个区间操作，我们分别维护三个对应且独立的 **tag**，作为区间更改的标记，在下传三个 **tag** 时，存在一定的优先级关系，易证。

对于询问操作，我们设左括号为 $-1$，右括号为 $1$，维护前缀最值，后缀最值，区间和，并使用公式计算答案：
$$
Query(x,y) = \lceil \dfrac{maxPre}{2} \rceil + \lceil \dfrac{-minSuf}{2} \rceil
$$
首先，我们可以证明，对于同一个区间，其 $maxPre$ 与 $minSuf$ 的最短统计范围应没有重复。

通过反证法证明。设 $maxPre, minSuf$ 中存在共同区间 $(l, r)$，$t_l$ 为区间左括号数量，$t_r$ 为右括号数量，由 $(l,r)$ 区间需对答案有贡献，得必然有：$t_l < t_r$ 且 $t_l > t_r$，矛盾！

因此，设对于区间 $(l,r)$，$maxPre = \sum_{i=l}^xS_i, \ minSuf = \sum_{i=y}^r S_i $ 满足 $l \leq x < y \leq r$，必然可得 $t_l(x+1,y-1) = t_r(x+1,y-1)$，同时可以得到 $(x,y)$ 必定为合法的括号匹配串。该结论由第一个证明可以推导得到。

由上述证明加以推导，$Query(x,y)$ 的计算方式得证，本题最大的难点得以突破。

#### 代码

经典的平衡树问题，包含 $4$ 个区间操作（询问），为方便编码，果断选择 **FHQ-Treap**。代码中的三个 **tag** 分别对应三个修改操作的标记。

```c++
#include <iostream>
#include <cstdlib>

using namespace std;

int translate(char chr) { // 将括号转换为数值
    if (chr == '(')
        return -1;
    return 1;
}

struct Node {
    Node *l{}, *r{};
    int rnd{}, val{}, size{}, tag1{}, tag2{}, tag3{};
    int maxPre{}, minPre{}, maxSuf{}, minSuf{}, sum{};
};

Node *New(int val) {
    Node *p = new Node;
    p->rnd = rand();
    p->val = p->sum = val;
    p->size = 1;
    p->maxPre = p->maxSuf = max(0, val);
    p->minPre = p->minSuf = min(0, val);
    return p;
}

struct Treap {
    Node *root = nullptr;

    Node get(Node *p) {
        if (!p)
            return {};
        return *p;
    }

    void replace(Node *p, int val) { // 区间修改
        p->tag1 = p->val = val;
        p->sum = p->size * val;
        p->maxPre = p->maxSuf = max(0, p->sum);
        p->minPre = p->minSuf = min(0, p->sum);
    }

    void reverse(Node *p) { // 区间翻转
        swap(p->minPre, p->minSuf);
        swap(p->maxPre, p->maxSuf);
        swap(p->l, p->r);
        p->tag2 ^= 1;
    }

    void invert(int &x) {
        x = -x;
    }

    void invert(Node *p) { // 区间取反
        swap(p->minPre, p->maxPre);
        swap(p->minSuf, p->maxSuf);
        invert(p->val), invert(p->sum);
        invert(p->minPre), invert(p->maxPre);
        invert(p->minSuf), invert(p->maxSuf);
        invert(p->tag1);
        p->tag3 ^= 1;
    }
    
    void update(Node *p) { // 上传区间信息
        Node l = get(p->l), r = get(p->r);
        p->size = l.size + r.size + 1;
        p->sum = l.sum + r.sum + p->val;
        p->minPre = min(l.minPre, l.sum + p->val + r.minPre);
        p->maxPre = max(l.maxPre, l.sum + p->val + r.maxPre);
        p->minSuf = min(r.minSuf, r.sum + p->val + l.minSuf);
        p->maxSuf = max(r.maxSuf, r.sum + p->val + l.maxSuf);
    }

    void spread(Node *p) { // 下传标记
        bool flag1 = p->l != nullptr, flag2 = p->r != nullptr;

        if (p->tag3) {
            flag1 ? invert(p->l) : (void) NULL;
            flag2 ? invert(p->r) : (void) NULL;
        }
        if (p->tag1) {
            flag1 ? replace(p->l, p->tag1) : (void) NULL;
            flag2 ? replace(p->r, p->tag1) : (void) NULL;
        } else if (p->tag2) {
            flag1 ? reverse(p->l) : (void) NULL;
            flag2 ? reverse(p->r) : (void) NULL;
        }

        p->tag1 = p->tag2 = p->tag3 = 0;
    }

    Node *merge(Node *l, Node *r) {
        if (!l || !r)
            return max(l, r);
        spread(l);
        spread(r);

        if (l->rnd < r->rnd) {
            l->r = merge(l->r, r);
            update(l);
            return l;
        } else {
            r->l = merge(l, r->l);
            update(r);
            return r;
        }
    }

    pair<Node *, Node *> split(Node *p, int rnk) {
        if (!p)
            return make_pair(p, p);
        spread(p);

        if (get(p->l).size + 1 <= rnk) {
            auto q = split(p->r, rnk - get(p->l).size - 1);
            p->r = q.first;
            update(p);
            return make_pair(p, q.second);
        } else {
            auto q = split(p->l, rnk);
            p->l = q.second;
            update(p);
            return make_pair(q.first, p);
        }
    }

    void insert(int val) {
        root = merge(root, New(val));
    }

    void replace(int l, int r, int val) {
        auto a = split(root, l - 1);
        auto b = split(a.second, r - l + 1);
        replace(b.first, val);
        b.first->tag2 = 0;
        root = merge(a.first, merge(b.first, b.second));
    }

    void reverse(int l, int r) {
        auto a = split(root, l - 1);
        auto b = split(a.second, r - l + 1);
        if (!b.first->tag1)
            reverse(b.first);
        root = merge(a.first, merge(b.first, b.second));
    }

    void invert(int l, int r) {
        auto a = split(root, l - 1);
        auto b = split(a.second, r - l + 1);
        invert(b.first);
        root = merge(a.first, merge(b.first, b.second));
    }

    int ask(int l, int r) {
        auto a = split(root, l - 1);
        auto b = split(a.second, r - l + 1);
        int res = (b.first->maxPre + 1) / 2 + (-b.first->minSuf + 1) / 2;
        root = merge(a.first, merge(b.first, b.second));
        return res;
    }
} treap;

int n, q;
string str;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    cin >> n >> q >> str;

    for (auto i: str)
        treap.insert(translate(i));

    for (int i = 1, l, r; i <= q; i++) {
        cin >> str >> l >> r;

        if (str[0] == 'R') {
            char c;
            cin >> c;
            treap.replace(l, r, translate(c));
        } else if (str[0] == 'S')
            treap.reverse(l, r);
        else if (str[0] == 'I')
            treap.invert(l, r);
        else if (str[0] == 'Q')
            cout << treap.ask(l, r) << '\n';
    }

    return 0;
}
```



---

## 作者：danny101 (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P3215)

[更好的阅读体验](https://www.luogu.com.cn/blog/d-a-n-n-y-1-0-1/solution-p3215)

#### 题目大意：

维护一段括号序列，要求支持：

- 区间赋值

- 区间翻转

- 区间取反

- 查询区间要变成合法括号序列的最少次数

#### 大致思路：

明显的 `FHQ Treap`。

前两种操作是基本操作，不再赘述。

先考虑查询：

对于一串不合法的括号序列，如 $()))((())()$，将合法的部分消掉得 $))($，发现一定是 $\underbrace{)))\dots)}_{k\text{个右括号}}\underbrace{(((\dots(}_{\kern0.5eml\text{个左括号}}$ 这样的形式。

于是，为了方便操作，记 `(` 为 $-1$，`)` 为 $1$。

记录转换后的数组的前缀最大值（记为 $pmax$）和后缀最小值（记为 $smin$），那么最后不合法的序列就是 $pmax$ 个右括号和 $smin$ 个左括号，最少操作次数就为 $\bigg\lceil\dfrac{pmax}{2}\bigg\rceil+\left\lceil-\dfrac{smin}{2}\right\rceil$。

再来考虑第三个修改操作：

将区间取反后，所有的 $1$ 都变成 $-1$，所有的 $-1$ 都变成 $1$，相当于直接变成相反数。因此，进行以下修改：

- 将当前节点的权值变为它的相反数

- 将当前节点的前、后缀最大最小值变为它的相反数

- 将当前节点的赋值懒标记变为它的相反数

- 交换最小值和最大值

还是比较麻烦的。

最后，还有一点要注意：因为有翻转操作，除了前缀最大值和后缀最小值外，还要维护前缀最小值和后缀最大值。

代码就不贴啦~

---

## 作者：chenxia25 (赞：6)

>### [洛谷题目页面传送门](https://www.luogu.org/problemnew/show/P3215)

>给定一个括号串$a,|a|=n$。你需要支持以下$4$种$q$次操作：

>1. $\texttt{Replace}\ l\ r\ x$：将$a_{l\sim r}$内的字符全部改为$x$；
>1. $\texttt{Swap}\ l\ r$：将$a_{l\sim r}$翻转；
>1. $\texttt{Invert}\ l\ r$：将$a_{l\sim r}$内的所有字符$\texttt(\to\texttt),\texttt)\to\texttt($；
>1. $\texttt{Query}\ l\ r$：查询$a_{l\sim r}$至少要改变多少个字符才能变成合法括号串。保证一定能在有限次改动内变成合法括号串。

>$n,q\in\left[1,10^5\right]$。

先来考虑怎么算一个括号串$s$至少要改变多少个字符才能变成合法括号串。~~由于这是一个复杂的数据结构题，所以我们坚信结论比较简单~~

显然，$s$能在有限次改动内变成合法括号串当且仅当$2\mid |s|$。以下默认$2\mid |s|$。

将$\texttt($看成$1$，$\texttt)$看成$-1$是解决括号串合法问题的惯用套路。设$bal(x)=\begin{cases}1&x=\texttt(\\-1&x=\texttt)\end{cases}$，$Bal_{s,i}=\sum\limits_{j=1}^ibal(s_j)$，则括号串$s$合法当且仅当$\forall i\in[1,|s|],Bal_{s,i}\geq0$且$Bal_{s,|s|}=0$。

考虑算出$Bal_s$数组。先假设只需要$\forall i\in[1,|s|],Bal_{s,i}\geq0$实现。对于每个$i$使得$Bal_{s,i}<0$，我们要将$s_i$左边若干个$\texttt)$改成$\texttt($使得$Bal_{s,i}\geq0$。显然，改一次会令$Bal_{s,i}=Bal_{s,i}+2$，那么最少需要将$s_i$左边$\left\lceil\dfrac{-Bal_{s,i}}2\right\rceil$个$\texttt)$改成$\texttt($。又因为如果$\left\lceil\dfrac{-Bal_{s,i}}2\right\rceil<\max\limits_{j=1}^{i-1}\left\{\left\lceil\dfrac{-Bal_{s,j}}2\right\rceil\right\}$的话，那么前面必有至少$\left\lceil\dfrac{-Bal_{s,i}}2\right\rceil$次改动，已满足要求；否则显然可以找到办法只改前面的$\left\lceil\dfrac{-Bal_{s,i}}2\right\rceil$个括号使得前面的所有$Bal$值都非负。所以若只需要$\forall i\in[1,|s|],Bal_{s,i}\geq0$，那么最少改动数为$\max\limits_{i=1}^{|s|}\left\{\left\lceil\dfrac{-Bal_{s,i}}2\right\rceil\right\}$。

此时已经$\forall i\in[1,|s|],Bal_{s,i}\geq0$了。再加上$Bal_{s,|s|}=0$的条件。显然此时$Bal_{s,|s|}\geq0$，我们要考虑将若干$\texttt($改成$\texttt)$使得$Bal_{s,|s|}=0$。显然，改一次会令$Bal_{s,|s|}=Bal_{s,|s|}-2$，那么最少需要将$\dfrac{Bal_{s,|s|}}2$个$\texttt($改成$\texttt)$。又因为先前$\texttt)\to\texttt($的那些改动是保障$\forall i\in[1,|s|],Bal_{s,i}\geq0$的基础，肯定动不得，所以只能另外挑选$\dfrac{Bal_{s,|s|}}2$个$\texttt($改成$\texttt)$。于是得出结论：括号串$s$至少要改变$\max\limits_{i=1}^{|s|}\left\{\left\lceil\dfrac{-Bal_{s,i}}2\right\rceil\right\}+\dfrac{Bal_{s,|s|}+2\max\limits_{i=1}^{|s|}\left\{\left\lceil\frac{-Bal_{s,i}}2\right\rceil\right\}}2=\left\lceil\dfrac{-\min\limits_{i=1}^{|s|}\{Bal_{s,i}\}}2\right\rceil+\dfrac{Bal_{s,|s|}+2\left\lceil\frac{-\min\limits_{i=1}^{|s|}\{Bal_{s,i}\}}2\right\rceil}2$个字符才能变成合法括号串。

所以我们只需要维护$\min\limits_{i=1}^{r-l+1}\{Bal_{a_{l\sim r},i}\}$和$Bal_{a_{l\sim r},r-l+1}$这两个值即可。考虑到有区间翻转操作，我们用平衡树维护，这里使用fhq-Treap。

设当前节点表示$a_x$，子树表示区间$[l,r]$，那么我们需要存储$v_i=bal(a_x),bal\_all_i=Bal_{a_{l\sim r},r-l+1},Mn\_bal_i=\min\limits_{i=1}^{r-l+1}\{Bal_{a_{l\sim r},i}\}$。为了在区间反转操作中$\mathrm O(1)$打懒标记，我们还需要存储$mn\_baL_i$。为了在区间取反操作中$\mathrm O(1)$打懒标记，我们还需要存储$Mx\_bal_i,mx\_baL_i$。此时上传时很容易达到$\mathrm O(1)$。此外还需要存储$3$种操作的懒标记。

由于有$3$种懒标记，我们需要强行规定下传时的顺序。不妨规定顺序为$\texttt{Replace},\texttt{Swap},\texttt{Invert}$。此时打懒标记时除了应该做的常规操作以外，打$\texttt{Replace}$的懒标记时要将另$2$个懒标记清空。这里还有一个注意的地方：下传懒标记时有一个原则，就是参数不能含有非懒标记的其他存储的值，因为它们只能表现此节点的现状，并不能表现它经历了什么。我之前直接将$\texttt{Replace}$的懒标记定义为`bool`，然后下传时的参数为$v_i$，这样由于$\texttt{Invert}$的存在会出错~~，导致我盯着电脑看&自闭了一晚上~~。所以要定义为`int`当作下传时的参数，$\texttt{Invert}$时只改$v_i$不改$\texttt{Replace}$的懒标记。

这还是一个比较模板的平衡树题吧……

（这个毒瘤卡常题还需要开O3优化才能过……）

下面是AC代码：

```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
using namespace std;
#define mp make_pair
#define X first
#define Y second
const int inf=0x3f3f3f3f;
mt19937 rng(20060617/*信仰优化*/);
const int N=100000;
int n/*括号串长度*/,qu/*操作数*/;
char a[N+5];//括号串 
struct fhq_treap{//fhq-Treap 
	int sz/*点数*/,root/*根*/;
	struct node{unsigned key;int lson,rson,sz,v,bal_all,Mn_bal,mn_baL,Mx_bal,mx_baL,lz_chg/*Replace懒标记*/;bool lz_rev/*Swap懒标记*/,lz_inv/*Invert懒标记*/;}nd[N+1];
	#define key(p) nd[p].key
	#define lson(p) nd[p].lson
	#define rson(p) nd[p].rson
	#define sz(p) nd[p].sz
	#define v(p) nd[p].v
	#define bal_all(p) nd[p].bal_all
	#define Mn_bal(p) nd[p].Mn_bal
	#define mn_baL(p) nd[p].mn_baL
	#define Mx_bal(p) nd[p].Mx_bal
	#define mx_baL(p) nd[p].mx_baL
	#define lz_chg(p) nd[p].lz_chg
	#define lz_rev(p) nd[p].lz_rev
	#define lz_inv(p) nd[p].lz_inv
	void sprup(int p){//上传 
		sz(p)=sz(lson(p))+1+sz(rson(p));
		bal_all(p)=bal_all(lson(p))+v(p)+bal_all(rson(p));
		Mn_bal(p)=min(Mn_bal(lson(p)),bal_all(lson(p))+v(p)+min(0,Mn_bal(rson(p))));
		mn_baL(p)=min(mn_baL(rson(p)),bal_all(rson(p))+v(p)+min(0,mn_baL(lson(p))));
		Mx_bal(p)=max(Mx_bal(lson(p)),bal_all(lson(p))+v(p)+max(0,Mx_bal(rson(p))));
		mx_baL(p)=max(mx_baL(rson(p)),bal_all(rson(p))+v(p)+max(0,mx_baL(lson(p))));
	}
	int nwnd(int v){return nd[++sz]=node({rng(),0,0,1,v,v,v,v,v,v,0,false,false}),sz;}//新建节点 
	int bld(int l=1,int r=n){//建树 
		int mid=l+r>>1,p=nwnd(a[mid]=='('?1:-1);
		if(l<=mid-1)lson(p)=bld(l,mid-1);
		if(mid+1<=r)rson(p)=bld(mid+1,r);
		return sprup(p),p;
	}
	void init(){//fhq-Treap初始化 
		nd[sz=0]=node({0,0,0,0,0,0,inf,inf,-inf,-inf,0,0,0});
		root=bld();
	}
	void sprdwn_chg(int p,int v){//打Replace懒标记 
		v(p)=lz_chg(p)=v;
		bal_all(p)=v*sz(p);
		if(~v)Mn_bal(p)=mn_baL(p)=1,Mx_bal(p)=mx_baL(p)=sz(p);
		else Mx_bal(p)=mx_baL(p)=-1,Mn_bal(p)=mn_baL(p)=-sz(p);
		lz_rev(p)=lz_inv(p)=false;
	}
	void sprdwn_rev(int p){//打Swap懒标记 
		swap(lson(p),rson(p));
		swap(Mn_bal(p),mn_baL(p));
		swap(Mx_bal(p),mx_baL(p));
		lz_rev(p)^=1;
	}
	void sprdwn_inv(int p){//打Invert懒标记 
		v(p)=-v(p);
		bal_all(p)=-bal_all(p);
		swap(Mn_bal(p),Mx_bal(p));Mn_bal(p)=-Mn_bal(p);Mx_bal(p)=-Mx_bal(p);
		swap(mn_baL(p),mx_baL(p));mn_baL(p)=-mn_baL(p);mx_baL(p)=-mx_baL(p);
		lz_inv(p)^=1;
	}
	void sprdwn(int p){//下传 
		if(lz_chg(p)){
			if(lson(p))sprdwn_chg(lson(p),lz_chg(p));
			if(rson(p))sprdwn_chg(rson(p),lz_chg(p));
			lz_chg(p)=0;
		}
		if(lz_rev(p)){
			if(lson(p))sprdwn_rev(lson(p));
			if(rson(p))sprdwn_rev(rson(p));
			lz_rev(p)=false;
		}
		if(lz_inv(p)){
			if(lson(p))sprdwn_inv(lson(p));
			if(rson(p))sprdwn_inv(rson(p));
			lz_inv(p)=false;
		}
	}
	pair<int,int> split(int x,int p=-1){~p||(p=root);
		if(!x)return mp(0,p);
		pair<int,int> sp;
		sprdwn(p);
		if(x<=sz(lson(p)))return sp=split(x,lson(p)),lson(p)=sp.Y,sprup(p),mp(sp.X,p);
		return sp=split(x-sz(lson(p))-1,rson(p)),rson(p)=sp.X,sprup(p),mp(p,sp.Y);
	}
	int mrg(int p,int q){
		if(!p||!q)return p|q;
		sprdwn(p);sprdwn(q);
		if(key(p)<key(q))return rson(p)=mrg(rson(p),q),sprup(p),p;
		return lson(q)=mrg(p,lson(q)),sprup(q),q;
	}
	void chg(int l,int r,char v){//区间赋值 
		pair<int,int> sp=split(l-1),sp0=split(r-l+1,sp.Y);
		sprdwn_chg(sp0.X,v=='('?1:-1);
		root=mrg(mrg(sp.X,sp0.X),sp0.Y);
	}
	void rev(int l,int r){//区间翻转 
		pair<int,int> sp=split(l-1),sp0=split(r-l+1,sp.Y);
		sprdwn_rev(sp0.X);
		root=mrg(mrg(sp.X,sp0.X),sp0.Y);
	}
	void inv(int l,int r){//区间取反 
		pair<int,int> sp=split(l-1),sp0=split(r-l+1,sp.Y);
		sprdwn_inv(sp0.X);
		root=mrg(mrg(sp.X,sp0.X),sp0.Y);
	}
	int least(int l,int r){//查询操作 
		pair<int,int> sp=split(l-1),sp0=split(r-l+1,sp.Y);
		int tmp1=max(0,(-Mn_bal(sp0.X)+1)/2),tmp2=bal_all(sp0.X);
//		cout<<Mn_bal(sp0.X)<<" "<<bal_all(sp0.X)<<"\n";
		return root=mrg(mrg(sp.X,sp0.X),sp0.Y),tmp1+(tmp2+2*tmp1)/2;
	}
	void dfs(int p=-1)/*调试用*/{~p||(p=root);
		if(!p)return;
		sprdwn(p);
		dfs(lson(p));
//		printf("node#%d:lson=%d rson=%d v=%d all=%d Mn=%d mn=%d Mx=%d mx=%d\n",p,lson(p),rson(p),v(p),bal_all(p),Mn_bal(p),mn_baL(p),Mx_bal(p),mx_baL(p));
//		putchar(~v(p)?'(':')');
		dfs(rson(p));
	}
}trp;
int main(){
	cin>>n>>qu>>a+1;
	trp.init();//fhq-Treap初始化 
	while(qu--){
		string tp;int x,y;char z;
		cin>>tp>>x>>y;
		if(tp=="Replace")cin>>z,trp.chg(x,y,z);
		else if(tp=="Swap")trp.rev(x,y);
		else if(tp=="Invert")trp.inv(x,y);
		else cout<<trp.least(x,y)<<"\n";
//		trp.dfs();//puts("");
	}
	return 0;
}
```

---

## 作者：Y2y7m (赞：5)

lxl 神仙的做法。

考虑到我们一个左括号和一个右括号是可以抵消的，例如：

```((()((``` 抵消后会变为 ```((((```

```)))()(((``` 抵消后会变为 ```)))(((```

容易发现是一段连续的右括号加上一段连续的左括号。

于是我们可以维护一下右括号和左括号的个数。

查询就是左边一段括号的个数除以二（如果是奇数就要再加一），右边同理。

看一看操作

```Replace``` 操作显然可以 ```FHQ-Treap``` 取出这一段然后打标记即可。

```Swap``` 操作显然也是可以取出这一段打标记旋转。

```Invert``` 就有点麻烦了，我们可以把两种情况下（取反前和取反后）的状态都存一下，到时候直接交换即可。

注意标记下放顺序，先取反再旋转再覆盖。

其他都是平衡树模板。

---

## 作者：Log_x (赞：5)

**Splay + 一点巧妙的思想**

显然，问题的关键在**操作4**。

我们考虑对问题进行转化：

1）对于一个任意的括号序列 “))()(()))(()((” ，我们将成对的括号化简，变成 “)))(((” ，令a为化简后‘)'的个数，b为化简后‘(’的个数，则当a,b为奇数时，改变位数为【a / 2 + b / 2 + 2】，当a,b为偶数时，改变位数为【 a / 2 + b / 2】，合并为【(a + 1) / 2 + (b + 1) / 2】。

2）现在只要求出a,b就能得到答案了，对这个序列的左右括号赋值，令 ‘(’ 为1， ‘)’ 为-1，这样成对的括号之和就相当于相抵消，那么我们维护一个序列中的最小前缀和即为a，最大后缀和即为b。

还有一些要点需要注意：

1）对于区间取反，要维护最小后缀和和最大前缀和，这样在取反时只需交换最大/最小前后缀和，当然，由于数的正负性改变，交换后也要各自取其相反数；对于区间翻转，只需将（最大/最小）前缀和与后缀和交换。

2）还有一点较为重要的是，区间全改为某个括号的操作标记下传时，要优先于反转标记下传并清空当前反转的标记，以防止反转先下传导致答案错误，这在类似的数据结构题中都应进行这样的处理。

**代码：**


















```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const int Maxn = 0x3f3f3f3f;
const int N = 1e5 + 5;
int fa[N], lc[N], rc[N], sze[N], rev[N], fat[N], a[N];
int sum[N], pr0[N], pr1[N], sf0[N], sf1[N], vis[N], tag[N];
int n, m, x, y, rt, T, k; char s[N];
template <class T> inline T Max(const T a, const T b) {return a > b? a : b;}
template <class T> inline T Min(const T a, const T b) {return a < b? a : b;}
template <class T> inline void Swap(T &a, T &b) {a ^= b; b ^= a; a ^= b;}
inline int get()
{
    char ch; bool f = false; int res = 0;
    while (((ch = getchar()) < '0' || ch > '9') && ch != '-');
    if (ch == '-') f = true;
     else res = ch - '0';
    while ((ch = getchar()) >='0' && ch <= '9')
        res = (res << 3) + (res << 1) + ch - '0';
    return f? ~res + 1 : res;
}
inline void put(int x)
{
    if (x < 0)
      x = ~x + 1, putchar('-');
    // 形如 x = ~x + 1 的都是将原数取反的位运算 
    if (x > 9) put(x / 10);
    putchar(x % 10 + 48);
}
inline void Push(const int x)
{
    int L = lc[x], R = rc[x];
    sum[x] = sum[L] + sum[R] + vis[x];
    sze[x] = sze[L] + sze[R] + 1;
    pr0[x] = Min(pr0[L], sum[L] + vis[x] + pr0[R]); 
    pr1[x] = Max(pr1[L], sum[L] + vis[x] + pr1[R]);
    sf0[x] = Min(sf0[R], sum[R] + vis[x] + sf0[L]);
    sf1[x] = Max(sf1[R], sum[R] + vis[x] + sf1[L]);
}
inline void AddRev(const int x)
{
    if (!x) return ;
    rev[x] ^= 1; 
    Swap(lc[x], rc[x]); 
    Swap(pr0[x], sf0[x]);
    Swap(pr1[x], sf1[x]);
}
inline void AddFat(const int x)
{
    if (!x) return ;
    fat[x] ^= 1; 
    vis[x] = ~vis[x] + 1; sum[x] = ~sum[x] + 1; 
    Swap(pr0[x], pr1[x]); Swap(sf0[x], sf1[x]);
    pr0[x] = ~pr0[x] + 1; pr1[x] = ~pr1[x] + 1;
    sf0[x] = ~sf0[x] + 1; sf1[x] = ~sf1[x] + 1;
}
inline void AddTag(const int x, const int vi)
{
    if (!x) return ;
    fat[x] = 0;
    tag[x] = vi; vis[x] = vi;
    if (vi == 1)
    {
        sum[x] = sze[x];
         pr0[x] = sf0[x] = 0;
        pr1[x] = sf1[x] = sze[x];
    }
    else
    { 
        sum[x] = ~sze[x] + 1;
         pr0[x] = sf0[x] = ~sze[x] + 1;
        pr1[x] = sf1[x] = 0;
    }
}
inline void Down(const int x)
{
    if (rev[x])
    {
        AddRev(lc[x]); AddRev(rc[x]);
        rev[x] = 0;
    }
    if (tag[x])
    {
        AddTag(lc[x], tag[x]); 
        AddTag(rc[x], tag[x]);
        tag[x] = 0;
    }
    if (fat[x])
    {
        AddFat(lc[x]); AddFat(rc[x]);
        fat[x] = 0;
    }
}
inline bool Wrt(const int x) {return rc[fa[x]] == x;}
inline void Rot(const int x)
{
    int y = fa[x], z = fa[y];
    Down(y); Down(x);
    int b = (lc[y] == x ? rc[x] : lc[x]);
    fa[x] = z; fa[y] = x;
    if (b) fa[b] = y;
    if (z) (lc[z] == y ? lc[z] : rc[z]) = x;
    if (lc[y] == x) rc[x] = y, lc[y] = b;
     else lc[x] = y, rc[y] = b;
    Push(y);
}
inline void Splay(const int x, const int tar)
{
    while (fa[x] != tar)
    {
        if (fa[fa[x]] != tar)
         Wrt(fa[x]) == Wrt(x) ? Rot(fa[x]) : Rot(x);
        Rot(x); 
    }
    Push(x);
    if (!tar) rt = x;
}
inline int Getkth(const int k)
{
    int x = rt, y = k;
    while(x)
    {
        Down(x);
        if (y <= sze[lc[x]]) x = lc[x];
        else 
        {
            y -= sze[lc[x]] + 1;
            if (!y) return x;
            x = rc[x];
        }
    }
}
inline int Bul(const int l, const int r, const int lst)
{
    if (l > r) return 0;
    int mid = l + r >> 1, x = ++T;
    fa[x] = lst; vis[x] = a[mid];
    lc[x] = Bul(l, mid - 1, x);
    rc[x] = Bul(mid + 1, r, x);
    return Push(x), x;
}
inline void Upt(const int l, const int r)
{
    x = Getkth(l); y = Getkth(r + 2);
    Splay(x, 0); Splay(y, x);
}
int main()
{
    n = get(); m = get();
    scanf("%s", s + 2);
    for (int i = 2; i <= n + 1; ++i) a[i] = (s[i] == '(' ? 1 : ~1 + 1);
    rt = Bul(1, n + 2, 0); int u, v;
    while (m--)
    {
        while ((k = getchar()) < 'A' || k > 'Z');
        u = get(); v = get(); Upt(u, v);
        switch (k)
        {
            case 'Q': put((sf1[lc[y]] + 1 >> 1) - (pr0[lc[y]] - 1) / 2), putchar('\n'); break;
            case 'I': AddFat(lc[y]); Push(y); Push(x); break;
            case 'S': AddRev(lc[y]); Push(y); Push(x); break;
            case 'R': AddTag(lc[y], (getchar() == '(' ? 1 : ~1 + 1)); Push(y); Push(x); break;
        }
    }
    return 0;
}

```

---

## 作者：VenusM1nT (赞：4)

ODT。  
%%% zqh 大仙，本来都想硬艹 fhq 了，后来才发现居然可以用 ODT，而且贼好写……  
逐个操作分析一下
 - `Replace` 就是一个简单的推平，直接推就好了。
 - `Swap` 比较烦，我是把那一段的迭代器里的元素存到一个数组里，然后修改完再插入回去，修改的方式比较暴力，就是用一个 $\text{pos}$ 记录一下当前的结尾位置，然后从前往后扫数组，当前这个元素的 $r$ 就是 $\text{pos}$，$l$ 就是 $\text{pos}-(r-l+1)+1$，然后把 $\text{pos}$ 修改为 $l-1$，这样挨个做过去就可以了。
 - `Invert` 可以大力 `Split` 一下，然后直接挨个取反就可以了。
 - `Query` 也比较烦，我们可以将 `(` 视作 `1`，`)` 视作 `-1`，求一手前缀和，如果 $\text{sum}$ 小于 $0$，说明前面 `)` 多，需要修改 $\lceil\frac{\text{sum}}{2}\rceil$ 个元素，直接加到答案里，然后修改一下 $\text{sum}$，改成 $\text{sum}-\lfloor\frac{\text{sum}}{2}\rfloor$，继续往后做。整个做完之后如果 $\text{sum}\not=0$ 再把 $\lfloor \frac{|\text{sum}|}{2}\rfloor$ 记录到答案里即可。

```cpp
#include<bits/stdc++.h>
#define MAXN 100005
#define reg register
#define inl inline
#define iter set<Node>::iterator 
using namespace std;
struct Node
{
	int l,r;
	mutable int val;// 1 ( , -1 )
	bool operator < (const Node &x) const
	{
		return l<x.l;
	}
}a[MAXN],t[MAXN];
int n,Q;
char ch[MAXN];
set<Node> s;
inl int T(reg char x)
{
	return x=='('?1:-1;
}
inl iter Split(reg int pos)
{
	reg iter it=s.lower_bound((Node){pos,pos,-1});
	if(it!=s.end() && it->l==pos) return it;
	it--;
	reg Node x=*it;
	s.erase(it);
	s.insert((Node){x.l,pos-1,x.val});
	return s.insert((Node){pos,x.r,x.val}).first;
}
inl void Assign(reg int l,reg int r,reg int val)
{
	reg iter R=Split(r+1),L=Split(l);
	s.erase(L,R);
	s.insert((Node){l,r,val});
}
inl void Reverse(reg int l,reg int r)
{
	reg int tot=0;
	reg iter R=Split(r+1),L=Split(l);
	for(reg iter it=L;it!=R;it++) a[++tot]=(*it);
	s.erase(L,R);
	reg int pos=a[tot].r;
	for(reg int i=1;i<=tot;i++)
	{
		t[i].val=a[i].val;
		t[i].r=pos;
		t[i].l=pos-(a[i].r-a[i].l+1)+1;
		pos-=(a[i].r-a[i].l+1);
	}
	for(reg int i=1;i<=tot;i++) s.insert(t[i]);
}
inl void Modify(reg int l,reg int r)
{
	reg iter R=Split(r+1),L=Split(l);
	for(reg iter it=L;it!=R;it++)
	{
		if(it->val==-1) it->val=1;
		else if(it->val==1) it->val=-1;
	}
}
inl int Query(reg int l,reg int r)
{
	reg int sum=0,res=0;
	reg iter R=Split(r+1),L=Split(l);
	for(reg iter it=L;it!=R;it++)
	{
		sum+=(it->r-it->l+1)*it->val;
		if(sum<0)
		{
			res+=-sum/2;
			if((-sum)&1)
			{
				sum=1;
				res++;
			}
			else sum=0;
		}
	}
	res+=abs(sum)/2;
	return res;
}
inl void Out()
{
	puts("   start : ");
	reg iter R=Split(n+1),L=Split(1);
	for(reg iter it=L;it!=R;it++)
	{
		for(reg int i=it->l;i<=it->r;i++) printf("%c",it->val==1?'(':')');
	}
	puts("");
	puts("end.");
	puts("");
}
int main()
{
	scanf("%d %d",&n,&Q);
	scanf("%s",ch+1);
	reg int pos=1;
	reg char now=ch[1];
	for(reg int i=2;i<=n;i++)
	{
		if(ch[i]!=now)
		{
			s.insert((Node){pos,i-1,T(now)});
			now=ch[i];
			pos=i;
		}
	}
	s.insert((Node){pos,n,T(now)});
	while(Q--)
	{
		reg string opt;
		reg int x,y;
		reg char z;
		cin>>opt;
		scanf("%d %d",&x,&y);
		if(opt=="Replace")
		{
			cin>>z;
			Assign(x,y,T(z));
		}
		else if(opt=="Swap") Reverse(x,y);
		else if(opt=="Invert") Modify(x,y);
		else if(opt=="Query") printf("%d\n",Query(x,y));
//		if(opt!="Query") Out();
	}
	return 0;
}
```

---

## 作者：Adove (赞：4)

这题我用的fhq treap

设$nd[4]$

```
0——多出来的右括号
1——多出来的左括号
2——取反后多出来的右括号
3——取反后多出来的左括号
```

这样一来

```
Swap: swap(0,3),swap(1,2),swap(sn[0],sn[1])
Invert: swap(0,2),swap(1,3),val[k]^=1
Replace: v<-siz[k],v+2^1<-siz[k],v^1<-0,v+2<-0
```

注意一下运算优先级就好

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
using namespace std;

const int MAXN=1e5+5;

int n,m,cnt,root;
char ch[MAXN];
int val[MAXN],rev[MAXN],sn[2][MAXN],siz[MAXN];
int nd[4][MAXN],tag3[MAXN];
bool tag1[MAXN],tag2[MAXN];

int cret(int v)
{
	int tmp=++cnt;
	siz[tmp]=1;
	val[tmp]=v;
	tag3[tmp]=-1;
	nd[v][tmp]=nd[v+2^1][tmp]=1;
	rev[tmp]=rand();
	return tmp;
}

void pushdown(int k)
{
	if(tag3[k]!=-1){
		if(sn[0][k]) nd[tag3[k]][sn[0][k]]=nd[tag3[k]+2^1][sn[0][k]]=siz[sn[0][k]],nd[tag3[k]^1][sn[0][k]]=nd[tag3[k]+2][sn[0][k]]=0,val[sn[0][k]]=tag3[sn[0][k]]=tag3[k],tag1[sn[0][k]]=tag2[sn[0][k]]=0;
		if(sn[1][k]) nd[tag3[k]][sn[1][k]]=nd[tag3[k]+2^1][sn[1][k]]=siz[sn[1][k]],nd[tag3[k]^1][sn[1][k]]=nd[tag3[k]+2][sn[1][k]]=0,val[sn[1][k]]=tag3[sn[1][k]]=tag3[k],tag1[sn[1][k]]=tag2[sn[1][k]]=0;
	}if(tag2[k]){
		swap(sn[0][k],sn[1][k]);
		if(sn[0][k]) swap(nd[0][sn[0][k]],nd[3][sn[0][k]]),swap(nd[1][sn[0][k]],nd[2][sn[0][k]]),tag2[sn[0][k]]^=1;
		if(sn[1][k]) swap(nd[0][sn[1][k]],nd[3][sn[1][k]]),swap(nd[1][sn[1][k]],nd[2][sn[1][k]]),tag2[sn[1][k]]^=1;
	}if(tag1[k]){
		if(sn[0][k]) swap(nd[0][sn[0][k]],nd[2][sn[0][k]]),swap(nd[1][sn[0][k]],nd[3][sn[0][k]]),tag1[sn[0][k]]^=1,val[sn[0][k]]^=1;
		if(sn[1][k]) swap(nd[0][sn[1][k]],nd[2][sn[1][k]]),swap(nd[1][sn[1][k]],nd[3][sn[1][k]]),tag1[sn[1][k]]^=1,val[sn[1][k]]^=1;
	}tag1[k]=tag2[k]=0;
	tag3[k]=-1;
	return;
}

void pushup(int k)
{
	siz[k]=siz[sn[0][k]]+siz[sn[1][k]]+1;
	nd[0][k]=nd[0][sn[0][k]];
	nd[1][k]=nd[1][sn[1][k]];
	int tmp=nd[1][sn[0][k]]-nd[0][sn[1][k]];
	tmp+=val[k]?1:-1;
	if(tmp>0) nd[1][k]+=tmp;
	else nd[0][k]-=tmp;
	
	nd[2][k]=nd[2][sn[0][k]];
	nd[3][k]=nd[3][sn[1][k]];
	tmp=nd[3][sn[0][k]]-nd[2][sn[1][k]];
	tmp+=val[k]?-1:1;
	if(tmp>0) nd[3][k]+=tmp;
	else nd[2][k]-=tmp;
	return;
}

void dro(int k,int v,int &x,int &y)
{
	if(!k){x=y=0;return;}
	pushdown(k);
	if(siz[sn[0][k]]<v) x=k,dro(sn[1][k],v-siz[sn[0][k]]-1,sn[1][k],y);
	else y=k,dro(sn[0][k],v,x,sn[0][k]);
	pushup(k);
	return;
}

int un(int x,int y)
{
	if(!x||!y) return x|y;
	if(rev[x]<rev[y]){
		pushdown(x);
		sn[1][x]=un(sn[1][x],y);
		pushup(x);
		return x;
	}pushdown(y);
	sn[0][y]=un(x,sn[0][y]);
	pushup(y);
	return y;
}

void slv0(int l,int r)
{
	int x,y,z;
	dro(root,r,x,z);
	dro(x,l-1,x,y);
	printf("%d\n",(nd[0][y]+1)/2+(nd[1][y]+1)/2);
	root=un(un(x,y),z);
	return;
}

void slv1(int l,int r)
{
	int x,y,z;
	dro(root,r,x,z);
	dro(x,l-1,x,y);
	tag1[y]^=1;val[y]^=1;
	pushdown(y);pushup(y);
	root=un(un(x,y),z);
	return;
}

void slv2(int l,int r)
{
	int x,y,z;
	dro(root,r,x,z);
	dro(x,l-1,x,y);
	tag2[y]^=1;
	pushdown(y);pushup(y);
	root=un(un(x,y),z);
	return;
}

void slv3(int l,int r,int kd)
{
	int x,y,z;
	dro(root,r,x,z);
	dro(x,l-1,x,y);
	tag3[y]=val[y]=kd;tag1[y]=tag2[y]=0;
	pushdown(y);pushup(y);
	root=un(un(x,y),z);
	return;
}

int main()
{
	scanf("%d%d",&n,&m);
	scanf("%s",ch+1);
	for(int i=1;i<=n;++i) root=un(root,cret(ch[i]=='('));
	while(m--){
		int l,r;
		scanf("%s%d%d",ch+1,&l,&r);
		if(ch[1]=='Q') slv0(l,r);
		else if(ch[1]=='I') slv1(l,r);
		else if(ch[1]=='S') slv2(l,r);
		else scanf("%s",ch+1),slv3(l,r,ch[1]=='(');
	}return 0;
}
```

---

## 作者：monstersqwq (赞：1)

~~还算难写的~~数据结构题

前面三个操作都比较常规，自然是先看第四个查询操作。

对于一个括号串，可以考虑把所有相匹配的括号都删除，剩下的是形如 "))))))$\cdots$)))((($\cdots$(((" 的串，观察可知，最小修改次数应该就是这个串的长度除以 $2$，若两种括号的长度都是奇数，修改次数是串长除以 $2$ 加 $1$。

这个串的长度怎么求呢，考虑到相匹配的括号会相互抵消，可以给两个括号赋一个相反数的值，我赋的是 "(" 为 $-1$，")" 为 $1$，那么发现前面的右括号个数就是最大前缀，后面的左括号个数就是最小后缀的相反数。

然后发现我们需要在平衡树上维护一个最大前缀和最小后缀，由于带翻转，我还维护了一个最小前缀和最大后缀，这个最大/最小前缀/后缀可以采用最大子段和的维护方法，所以还需要维护一个和。

然后就是维护这一堆值和这三个操作的具体实现了，由于覆盖是优先级最高的，打覆盖标记的时候需要清除掉翻转和取反的标记，同理，下传标记的时候要先下传覆盖的标记，由于翻转后取反和取反后翻转没有区别，先下传哪个都行。

覆盖的时候子树权值和以及节点权值可以直接维护，最大/最小前缀/后缀需要根据覆盖的权值的正负来维护。

翻转的时候既要交换左右儿子，还要维护左右儿子的那四个值，前缀最大值和后缀最大值互换，最小值同理。

取反的时候直接将节点权值以及子树和取反，然后最大前缀与最小前缀交换并都取反，后缀同理。

然后就是一堆乱七八糟的细节，我用的是 fhq treap ~~跑的非常慢~~，有一些地方可能比较随意，尤其是下传标记。

代码看起来比较长，实际上大部分是复制的（

```cpp
#include<cstdio>
#include<cstring>
#include<string>
#include<iostream>
#include<algorithm>
#include<map>
#include<queue>
#include<stack>
using namespace std;
int n,m;
int root;
struct node
{
	int ls,rs,pmax,pmin,smax,smin,val,rnd,sum,siz;
	int retag;
	bool swtag;
	bool intag;
}tre[100005];
int cnt;
int newnode(int w)
{
	cnt++;
	tre[cnt].ls=tre[cnt].rs=0;
	tre[cnt].rnd=rand();
	tre[cnt].intag=tre[cnt].swtag=false;
	tre[cnt].val=w;
	tre[cnt].pmax=tre[cnt].smax=(w>0?w:0);
	tre[cnt].smin=tre[cnt].pmin=(w>0?0:w);
	tre[cnt].retag=0;
	tre[cnt].sum=w;
	tre[cnt].siz=1;
	return cnt;
}
void pushup(int x)
{
	int ls=tre[x].ls,rs=tre[x].rs;
	tre[x].pmax=max(tre[ls].pmax,tre[ls].sum+tre[x].val+tre[rs].pmax);
	tre[x].pmin=min(tre[ls].pmin,tre[ls].sum+tre[x].val+tre[rs].pmin);
	tre[x].smax=max(tre[rs].smax,tre[rs].sum+tre[x].val+tre[ls].smax);
	tre[x].smin=min(tre[rs].smin,tre[rs].sum+tre[x].val+tre[ls].smin);
	tre[x].siz=tre[ls].siz+tre[rs].siz+1;
    tre[x].sum=tre[ls].sum+tre[rs].sum+tre[x].val;
}
void pushdown(int x)
{
	int ls=tre[x].ls,rs=tre[x].rs;
	if(tre[x].retag!=0)
	{
		tre[ls].intag=tre[rs].intag=false;
		tre[ls].swtag=tre[rs].swtag=false;
		tre[ls].retag=tre[rs].retag=tre[x].retag;
		tre[ls].sum=tre[x].retag*tre[ls].siz;
		tre[rs].sum=tre[x].retag*tre[rs].siz;
		tre[ls].val=tre[rs].val=tre[x].retag;
		tre[ls].pmax=tre[ls].smax=(tre[ls].retag>0?tre[ls].retag*tre[ls].siz:0);
		tre[rs].pmax=tre[rs].smax=(tre[rs].retag>0?tre[rs].retag*tre[rs].siz:0);
		tre[ls].pmin=tre[ls].smin=(tre[ls].retag>0?0:tre[ls].retag*tre[ls].siz);
		tre[rs].pmin=tre[rs].smin=(tre[rs].retag>0?0:tre[rs].retag*tre[rs].siz);
		tre[x].retag=0;
	}
	if(tre[x].swtag)
	{
		tre[ls].swtag^=tre[x].swtag;
		tre[rs].swtag^=tre[x].swtag;
		swap(tre[ls].pmax,tre[ls].smax);
		swap(tre[ls].pmin,tre[ls].smin);
		swap(tre[x].ls,tre[x].rs);
		swap(ls,rs);
		swap(tre[ls].pmax,tre[ls].smax);
		swap(tre[ls].pmin,tre[ls].smin);
		tre[x].swtag=false;
	}
	if(tre[x].intag)
	{
		tre[ls].intag^=tre[x].intag;
		tre[rs].intag^=tre[x].intag;
		tre[ls].sum=-tre[ls].sum;
		tre[rs].sum=-tre[rs].sum;
		tre[ls].val=-tre[ls].val;
		tre[rs].val=-tre[rs].val;
		swap(tre[ls].pmax,tre[ls].pmin);
		tre[ls].pmax=-tre[ls].pmax;
		tre[ls].pmin=-tre[ls].pmin;
		swap(tre[ls].smax,tre[ls].smin);
		tre[ls].smax=-tre[ls].smax;
		tre[ls].smin=-tre[ls].smin;
		swap(tre[rs].pmax,tre[rs].pmin);
		tre[rs].pmax=-tre[rs].pmax;
		tre[rs].pmin=-tre[rs].pmin;
		swap(tre[rs].smax,tre[rs].smin);
		tre[rs].smax=-tre[rs].smax;
		tre[rs].smin=-tre[rs].smin;
		tre[x].intag=false;
	}
}
int merge(int x,int y)
{
	if(!x||!y) return x^y;
	int res=0;
	if(tre[x].rnd<tre[y].rnd)
	{
		res=x;
		pushdown(res);
		tre[x].rs=merge(tre[x].rs,y);
	}
	else
	{
		res=y;
		pushdown(res);
		tre[y].ls=merge(x,tre[y].ls);
	}
	pushup(res);
	return res;
}
void splitrk(int rt,int &lrt,int &rrt,int k)
{
	if(rt==0)
	{
		lrt=rrt=0;return;
	}
	pushdown(rt);
	int qwq=tre[tre[rt].ls].siz+1;
	if(qwq<=k)
	{
		lrt=rt;
		splitrk(tre[rt].rs,tre[lrt].rs,rrt,k-qwq); 
	}
	else
	{
		rrt=rt;
		splitrk(tre[rt].ls,lrt,tre[rrt].ls,k);
	}
	pushup(rt);
}
void ins(int w)
{
	root=merge(root,newnode(w));
}
int main()
{
	srand(114514);
	scanf("%d%d",&n,&m);
	string tmp;
	cin>>tmp;
	for(int i=1;i<=n;i++)
	{
		ins((tmp[i-1]==')'?1:-1));
	}
	for(int i=1;i<=m;i++)
	{
		string opt;
		int x,y;
		cin>>opt;
		scanf("%d%d",&x,&y);
		int rx,ry,rz;
		splitrk(root,rx,rz,y);
		splitrk(rx,rx,ry,x-1);
		if(opt[0]=='R')
		{
			string qwq;
			cin>>qwq;
			int val=(qwq[0]==')'?1:-1);
			tre[ry].intag=false;
			tre[ry].swtag=false;
			tre[ry].retag=val;
			tre[ry].sum=val*tre[ry].siz;
			tre[ry].val=val;
			tre[ry].pmax=tre[ry].smax=(tre[ry].retag>0?tre[ry].retag*tre[ry].siz:0);
			tre[ry].pmin=tre[ry].smin=(tre[ry].retag>0?0:tre[ry].retag*tre[ry].siz);
		}
		if(opt[0]=='I')
		{ 
			tre[ry].intag^=1;
			tre[ry].sum=-tre[ry].sum;
			tre[ry].val=-tre[ry].val;
			swap(tre[ry].pmax,tre[ry].pmin);
			tre[ry].pmax=-tre[ry].pmax;
			tre[ry].pmin=-tre[ry].pmin;
			swap(tre[ry].smax,tre[ry].smin);
			tre[ry].smax=-tre[ry].smax;
			tre[ry].smin=-tre[ry].smin;
		}
		if(opt[0]=='S')
		{
			tre[ry].swtag^=1;
			swap(tre[ry].pmax,tre[ry].smax);
			swap(tre[ry].pmin,tre[ry].smin);
		}
		if(opt[0]=='Q')
		{
			printf("%d\n",(tre[ry].pmax+1)/2+(-tre[ry].smin+1)/2);
		}
		root=merge(rx,merge(ry,rz));
	}
	return 0;
}
```


---

## 作者：XenonKnight (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P3215)

> 题意：有一个长度为 $n$ 的括号序列，你需要支持以下操作：
> 1. 将 $[l,r]$ 中所有括号变为 $c$
> 2. 将 $[l,r]$ 区间翻转
> 3. 将 $[l,r]$ 区间中左括号变右括号，右括号变左括号
> 4. 求最少需要改变多少个括号才能使得 $[l,r]$ 变成合法括号序列，保证区间长度为偶数。
> $1 \leq n \leq 10^5$

基础的 fhq-treap 的题目，主要练下放标记的技巧。

首先我们需要将要求的东西转化为一个式子。例如括号序列 $(())))))((()$，将左右括号抵消掉之后就是 $))))(($，发现抵消完了之后变成了一段左括号跟一段右括号。

我们记 $(=-1$，$)=1$，假设前缀最大值为 $mx$，后缀最小值为 $mn$，那么最后会剩下 $mx$ 个右括号和 $-mn$ 个左括号，最少需要需要 $\lceil \frac{mx}{2} \rceil+\lceil -\frac{mn}{2} \rceil$ 次操作。

我们建一棵平衡树，每个节点维护以下六个值：$sz$ 子树大小，$sum$ 子树权值和，$prmn,prmx,sfmn,sfmx$ 表示前缀和后缀的最值，更新方式与最大子段和类似。

对于三个修改操作，我们考虑以下处理方式：

1. 区间赋值，直接维护标记然后更新 $sum$ 和 最值。
2. 区间翻转操作，直接交换左右儿子和前、后缀最大最小值。
3. 区间取逆操作，实际上就是将每个点的权值变为它的相反数，它的和、前后缀最大最小值也都变为了各自的相反数，如果有赋值标记，那么赋值标记也要取反。需要注意的一点是，最大值取了个相反数之后就变成了最小值，最小值取了相反数之后就变成了最大值，因此还需 swap 一下。

细节还是挺多的，代码也调了不少时间：

```cpp
//Coded by tzc_wk
/*
数据不清空，爆零两行泪。
多测不读完，爆零两行泪。
边界不特判，爆零两行泪。
贪心不证明，爆零两行泪。
D P 顺序错，爆零两行泪。
大小少等号，爆零两行泪。
变量不统一，爆零两行泪。
越界不判断，爆零两行泪。
调试不注释，爆零两行泪。
溢出不 l l，爆零两行泪。
*/
#include <bits/stdc++.h>
using namespace std;
#define fi			first
#define se			second
#define fz(i,a,b)	for(int i=a;i<=b;i++)
#define fd(i,a,b)	for(int i=a;i>=b;i--)
#define foreach(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)
#define all(a)		a.begin(),a.end()
#define giveup(...) return printf(__VA_ARGS__),0;
#define fill0(a)	memset(a,0,sizeof(a))
#define fill1(a)	memset(a,-1,sizeof(a))
#define fillbig(a)	memset(a,0x3f,sizeof(a))
#define fillsmall(a) memset(a,0xcf,sizeof(a))
#define mask(a)		(1ll<<(a))
#define maskx(a,x)	((a)<<(x))
#define _bit(a,x)	(((a)>>(x))&1)
#define _sz(a)		((int)(a).size())
#define filei(a)	freopen(a,"r",stdin);
#define fileo(a)	freopen(a,"w",stdout);
#define fileio(a) 	freopen(a".in","r",stdin);freopen(a".out","w",stdout)
#define eprintf(...) fprintf(stderr,__VA_ARGS__)
#define put(x)		putchar(x)
#define eoln        put('\n')
#define space		put(' ')
#define y1			y_chenxiaoyan_1
#define y0			y_chenxiaoyan_0
typedef pair<int,int> pii;
inline int read(){
	int x=0,neg=1;char c=getchar();
	while(!isdigit(c)){
		if(c=='-')	neg=-1;
		c=getchar();
	}
	while(isdigit(c))	x=x*10+c-'0',c=getchar();
	return x*neg;
}
inline void print(int x){
	if(x<0){
		putchar('-');
		print(abs(x));
		return;
	}
	if(x<=9)	putchar(x+'0');
	else{
		print(x/10);
		putchar(x%10+'0');
	}
}
inline int qpow(int x,int e,int _MOD){
	int ans=1;
	while(e){
		if(e&1)	ans=ans*x%_MOD;
		x=x*x%_MOD;
		e>>=1;
	}
	return ans;
}
int n=read(),m=read();
char str[100005];
struct node{
	int ch[2],val,key;
	int prmx,prmn,sfmx,sfmn,sum,sz;
	int rv_lz,cov_lz,inv_lz;
} s[100005];
int ncnt=0,root;
inline void pushup(int k){
//	s[0].prmx=s[0].sfmx=0;s[0].prmn=s[0].sfmn=0x3f3f3f3f;
	s[k].prmx=max(s[s[k].ch[0]].prmx,s[s[k].ch[0]].sum+s[k].val+s[s[k].ch[1]].prmx);
	s[k].prmn=min(s[s[k].ch[0]].prmn,s[s[k].ch[0]].sum+s[k].val+s[s[k].ch[1]].prmn);
	s[k].sfmx=max(s[s[k].ch[1]].sfmx,s[s[k].ch[1]].sum+s[k].val+s[s[k].ch[0]].sfmx);
	s[k].sfmn=min(s[s[k].ch[1]].sfmn,s[s[k].ch[1]].sum+s[k].val+s[s[k].ch[0]].sfmn);
	s[k].sum=s[s[k].ch[0]].sum+s[s[k].ch[1]].sum+s[k].val;
	s[k].sz=s[s[k].ch[0]].sz+s[s[k].ch[1]].sz+1;
}
inline void inv_part(int k){
	s[k].val=-s[k].val;s[k].sum=-s[k].sum;
	int prmn=s[k].prmn,prmx=s[k].prmx,sfmn=s[k].sfmn,sfmx=s[k].sfmx;
	s[k].prmn=-prmx;s[k].prmx=-prmn;s[k].sfmn=-sfmx;s[k].sfmx=-sfmn;
	s[k].cov_lz=-s[k].cov_lz;
	s[k].inv_lz^=1;
}
inline void cov_part(int k,int mk){
	s[k].val=mk;
	s[k].sum=mk*s[k].sz;
	s[k].cov_lz=mk;
	if(mk==1){s[k].prmn=s[k].sfmn=0;s[k].prmx=s[k].sfmx=s[k].sum;}
	else{s[k].prmx=s[k].sfmx=0;s[k].prmn=s[k].sfmn=s[k].sum;}
}
inline void rev_part(int k){
	swap(s[k].ch[0],s[k].ch[1]);
	swap(s[k].prmn,s[k].sfmn);
	swap(s[k].prmx,s[k].sfmx);
	s[k].rv_lz^=1;
}
inline void pushdown(int k){
	if(s[k].inv_lz){
		if(s[k].ch[0])	inv_part(s[k].ch[0]);
		if(s[k].ch[1])	inv_part(s[k].ch[1]);
		s[k].inv_lz=0;
	}
	if(s[k].cov_lz){
		if(s[k].ch[0])	cov_part(s[k].ch[0],s[k].cov_lz);
		if(s[k].ch[1])	cov_part(s[k].ch[1],s[k].cov_lz);
		s[k].cov_lz=0;
	}
	if(s[k].rv_lz){
		if(s[k].ch[0])	rev_part(s[k].ch[0]);
		if(s[k].ch[1])	rev_part(s[k].ch[1]);
		s[k].rv_lz=0;
	}
}
inline int newnode(char c){
	ncnt++;
	s[ncnt].key=rand()<<15|rand();
	s[ncnt].sz=1;
	if(c=='('){
		s[ncnt].prmn=s[ncnt].sfmn=-1;
		s[ncnt].prmx=s[ncnt].sfmx=0;
		s[ncnt].sum=-1;
		s[ncnt].val=-1;
	}
	else{
		s[ncnt].prmn=s[ncnt].sfmn=0;
		s[ncnt].prmx=s[ncnt].sfmx=1;
		s[ncnt].sum=1;
		s[ncnt].val=1;
	}
	return ncnt;
}
inline void build(int &k,int l,int r){
	int mid=(l+r)>>1;
	k=newnode(str[mid]);
	if(l!=mid)	build(s[k].ch[0],l,mid-1);
	if(r!=mid)	build(s[k].ch[1],mid+1,r);
	pushup(k);
}
inline void split(int k,int sz,int &a,int &b){
	if(!k){
		a=b=0;
		return;
	}
	pushdown(k);
	if(sz<=s[s[k].ch[0]].sz){
		b=k;
		split(s[k].ch[0],sz,a,s[k].ch[0]);
	}
	else{
		a=k;
		split(s[k].ch[1],sz-s[s[k].ch[0]].sz-1,s[k].ch[1],b);
	}
	pushup(k);
}
inline int merge(int a,int b){
	pushdown(a);pushdown(b);
	if(!a||!b)	return a+b;
	if(s[a].key<s[b].key){
		s[a].ch[1]=merge(s[a].ch[1],b);
		pushup(a);return a;
	}
	else{
		s[b].ch[0]=merge(a,s[b].ch[0]);
		pushup(b);return b;
	}
}
inline void rev(int l,int r){
	int k1,k2,k3;
	split(root,l-1,k1,k2);
	split(k2,r-l+1,k2,k3);
	rev_part(k2);
	root=merge(merge(k1,k2),k3);
}
inline void inv(int l,int r){
	int k1,k2,k3;
	split(root,l-1,k1,k2);
	split(k2,r-l+1,k2,k3);
	inv_part(k2);
	root=merge(merge(k1,k2),k3);
}
inline void cov(int l,int r,int x){
	int k1,k2,k3;
	split(root,l-1,k1,k2);
	split(k2,r-l+1,k2,k3);
	cov_part(k2,x);
	root=merge(merge(k1,k2),k3);
}
inline int getf(int x){
	if(x&1)	return (x>>1)+1;
	else	return x>>1;
}
inline int query(int l,int r){
    int k1,k2,k3;
	split(root,l-1,k1,k2);
	split(k2,r-l+1,k2,k3);
	int res=getf(s[k2].prmx)+getf(abs(s[k2].sfmn));
	root=merge(merge(k1,k2),k3);
	return res;
}
signed main(){
	cin>>str+1;
	build(root,1,n);
	while(m--){
		char opt[10];cin>>opt+1;
		if(opt[1]=='R'){
			int l=read(),r=read();
			char c;cin>>c;
			if(c=='(')	cov(l,r,-1);
			else		cov(l,r,1);
		}
		if(opt[1]=='S'){
			int l=read(),r=read();
			rev(l,r);
		}
		if(opt[1]=='I'){
			int l=read(),r=read();
			inv(l,r);
		}
		if(opt[1]=='Q'){
			int l=read(),r=read();
			cout<<query(l,r)<<endl;
		}

	}
	return 0;
}
```

顺便尛 chenxia25，ycxtxdy！

---

## 作者：Daidly (赞：0)

首先，考虑如何回答询问。对于一个括号串，我们先将其中的合法子串消去，最后会成为形如：$))\cdots))((\cdots(($ 的样子。

对右括号个数 $n_1$ 和左括号个数 $n_2$ 分奇偶讨论一下，可得答案为 $\lceil\frac{n_1}{2}\rceil+\lceil\frac{n_2}{2}\rceil$。

一步重要的转化：考虑到一对括号是不影响答案的，所以我们将 $($ 赋值为 $-1$，将 $)$ 赋值为 $1$，求出该括号串的最大前缀和最小后缀即为 $n_1,n_2$。

所以目前我们需要维护的是：最大前缀 $lmax$，最小后缀 $rmin$。

想要合并出这两个信息，我们还需要维护区间 $sum$。

然后考虑操作：

1. 区间赋值

2. 区间翻转

3. 区间取反（这里的反指的是相反数）

对于区间赋值，需要一个标记 $b_1=1/-1$。

对于区间翻转，需要一个标记 $b_2=0/1$，翻转后最大前缀即为原来的最大后缀，翻转后最小后缀即为原来的最小前缀，所以我们还需要维护：最大后缀 $rmax$，最小前缀 $lmin$。考虑使用平衡树来实现区间翻转等操作和一系列信息的维护。由于使用的是平衡树，所以需要多加一个信息：该点的值 $w=1/-1$。

对于区间取反，需要一个标记 $b_3=0/1$，考虑我们维护的信息：对于 $w,sum$ 直接取反即可，对于 $lmin$ 则等于原来的 $-lmax$，$lmax$ 等于原来的 $-lmin$ 其余类似。

然后就是平衡树经典的左右儿子编号 $l,r$，随机权值 $rnd$，以及这里支持区间翻转所用到的子树大小 $siz$（强调一下，由于区间翻转会调转左右儿子，若还按照二叉树的方法则行不通，所以按照子树大小来算，不熟悉的可以先写文艺平衡树）

综上，一个节点需要维护：$l,r,rnd,siz,w,sum,lmin,lmax,rmin,rmax,b_1,b_2,b_3$。

接着考虑信息的合并 `push_up(p)`，这是个很典型的合并，直接看代码即可：

```cpp
void push_up(int p){
	t[p].siz=t[t[p].l].siz+t[t[p].r].siz+1;
	t[p].sum=t[t[p].l].sum+t[t[p].r].sum+t[p].w;
	t[p].lmin=min(t[t[p].l].lmin,t[t[p].l].sum+t[p].w+t[t[p].r].lmin);
	t[p].lmax=max(t[t[p].l].lmax,t[t[p].l].sum+t[p].w+t[t[p].r].lmax);
	t[p].rmin=min(t[t[p].r].rmin,t[t[p].r].sum+t[p].w+t[t[p].l].rmin);
	t[p].rmax=max(t[t[p].r].rmax,t[t[p].r].sum+t[p].w+t[t[p].l].rmax);
}
```

接着考虑标记的下放 `push_down(p)`，关于标记 $b_1,b_2,b_3$ 的优先级以及标记对标记、标记对信息的影响，我们依次分析。

对于 $b_1$，假设之前有区间翻转和取反操作且未下放，若 $b_1$ 优先级小于 $b_2$ 也就是先下放翻转再下放赋值，则对赋值操作无影响，若 $b_1$ 优先级大于 $b_2$ 则无法实现。以此方法类推，可推出 $b_1$ 优先级小于 $b_2$，其余不受限制。所以可以写出 `push_down(p)` 代码：

```cpp
void push_down(int p){
	if(t[p].b3){
		if(t[p].l)update3(t[p].l);
		if(t[p].r)update3(t[p].r);
		t[p].b3=0;
	}
	if(t[p].b2){
		if(t[p].l)update2(t[p].l);
		if(t[p].r)update2(t[p].r);
		t[p].b2=0;
	}
	if(t[p].b1){
		if(t[p].l)update1(t[p].l,t[p].b1);
		if(t[p].r)update1(t[p].r,t[p].b1);
		t[p].b1=0;
	}
}
```
这样就解决了这道题，代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;

inline int read(){
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c<='9'&&c>='0'){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}

void print(int x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)print(x/10);
	putchar(x%10^48);
}

const int N=1e5+5;
int n,q,cnt,rt;
struct node{
	int l,r,rnd,siz;
	int lmin,lmax,rmin,rmax,sum,w;
	int b1;
	bool b2,b3;
}t[N];
char a[N];

int add(int x){
	int p=++cnt;
	t[p].sum=t[p].w=x,t[p].rnd=rand(),t[p].siz=1;
	t[p].lmin=min(t[p].lmin,x),t[p].lmax=max(t[p].lmax,x);
	t[p].rmin=min(t[p].rmin,x),t[p].rmax=max(t[p].rmax,x);
	return p;
}

void push_up(int p){
	t[p].siz=t[t[p].l].siz+t[t[p].r].siz+1;
	t[p].sum=t[t[p].l].sum+t[t[p].r].sum+t[p].w;
	t[p].lmin=min(t[t[p].l].lmin,t[t[p].l].sum+t[p].w+t[t[p].r].lmin);
	t[p].lmax=max(t[t[p].l].lmax,t[t[p].l].sum+t[p].w+t[t[p].r].lmax);
	t[p].rmin=min(t[t[p].r].rmin,t[t[p].r].sum+t[p].w+t[t[p].l].rmin);
	t[p].rmax=max(t[t[p].r].rmax,t[t[p].r].sum+t[p].w+t[t[p].l].rmax);
}

void update1(int p,int x){
	t[p].b1=t[p].w=x;
	t[p].sum=t[p].siz*x;
	if(x>0)t[p].lmax=t[p].rmax=t[p].sum,t[p].lmin=t[p].rmin=0;
	else t[p].lmax=t[p].rmax=0,t[p].lmin=t[p].rmin=t[p].sum;
}

void update2(int p){
	swap(t[p].l,t[p].r);
	swap(t[p].lmax,t[p].rmax);
	swap(t[p].lmin,t[p].rmin);
	t[p].b2^=1;
}

int tmpmax,tmpmin;

void update3(int p){
	t[p].w=-t[p].w;
	t[p].sum=-t[p].sum;
	tmpmax=t[p].lmax,tmpmin=t[p].lmin;
	t[p].lmax=-tmpmin,t[p].lmin=-tmpmax;
	tmpmax=t[p].rmax,tmpmin=t[p].rmin;
	t[p].rmax=-tmpmin,t[p].rmin=-tmpmax;
	t[p].b3^=1;
	t[p].b1=-t[p].b1;
}

void push_down(int p){
	if(t[p].b3){
		if(t[p].l)update3(t[p].l);
		if(t[p].r)update3(t[p].r);
		t[p].b3=0;
	}
	if(t[p].b2){
		if(t[p].l)update2(t[p].l);
		if(t[p].r)update2(t[p].r);
		t[p].b2=0;
	}
	if(t[p].b1){
		if(t[p].l)update1(t[p].l,t[p].b1);
		if(t[p].r)update1(t[p].r,t[p].b1);
		t[p].b1=0;
	}
}

void split(int p,int k,int &x,int &y){
	if(!p){
		x=y=0;return;
	}
	push_down(p);
	if(t[t[p].l].siz<k){
		x=p;
		split(t[p].r,k-t[t[p].l].siz-1,t[p].r,y);
	}else{
		y=p;
		split(t[p].l,k,x,t[p].l);
	}
	push_up(p);
}

int merge(int x,int y){
	if(!x||!y)return x|y;
	if(t[x].rnd>t[y].rnd){
		push_down(x);
		t[x].r=merge(t[x].r,y);
		push_up(x);
		return x;
	}else{
		push_down(y);
		t[y].l=merge(x,t[y].l);
		push_up(y);
		return y;
	}
}

int build(int l,int r){
	if(l==r)return add(a[l]=='('?-1:1);
	int mid=(l+r)>>1;
	return merge(build(l,mid),build(mid+1,r));
}

int main(){
	n=read(),q=read(),cin>>(a+1);
	rt=build(1,n);
	char opt[10],z;int x,y,l,mid,r;
	while(q--){
		cin>>opt,x=read(),y=read();
		if(opt[0]=='R'){
			cin>>z;
			split(rt,y,mid,r);
			split(mid,x-1,l,mid);
			update1(mid,z=='('?-1:1);
			rt=merge(merge(l,mid),r);
		}else if(opt[0]=='S'){
			split(rt,y,mid,r);
			split(mid,x-1,l,mid);
			update2(mid);
			rt=merge(merge(l,mid),r);
		}else if(opt[0]=='I'){
			split(rt,y,mid,r);
			split(mid,x-1,l,mid);
			update3(mid);
			rt=merge(merge(l,mid),r);
		}else{
			split(rt,y,mid,r);
			split(mid,x-1,l,mid);
			print((t[mid].lmax+1)/2+(-t[mid].rmin+1)/2),putchar('\n');
			rt=merge(merge(l,mid),r);
		}
	}
	return 0;
}
```
如果觉得有帮助的话可以点个赞。

---


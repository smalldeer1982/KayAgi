# [HNOI2012] 永无乡

## 题目描述

永无乡包含 $n$ 座岛，编号从 $1$ 到 $n$ ，每座岛都有自己的独一无二的重要度，按照重要度可以将这 $n$ 座岛排名，名次用 $1$  到 $n$ 来表示。某些岛之间由巨大的桥连接，通过桥可以从一个岛到达另一个岛。如果从岛 $a$ 出发经过若干座（含 $0$ 座）桥可以 到达岛 $b$ ，则称岛 $a$ 和岛 $b$ 是连通的。

现在有两种操作：

`B x y` 表示在岛 $x$ 与岛 $y$ 之间修建一座新桥。

`Q x k` 表示询问当前与岛 $x$ 连通的所有岛中第 $k$ 重要的是哪座岛，即所有与岛 $x$ 连通的岛中重要度排名第 $k$ 小的岛是哪座，请你输出那个岛的编号。

## 说明/提示

### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 10^3$, $q \leq 10^3$。
- 对于 $100\%$ 的数据，保证 $1 \leq m \leq n \leq 10^5$, $1 \leq q \leq 3 \times 10^5$，$p$ 为一个 $1 \sim n$ 的排列，$op \in \{\texttt Q, \texttt B\}$，$1 \leq u, v, x, y \leq n$。

## 样例 #1

### 输入

```
5 1
4 3 2 5 1
1 2
7
Q 3 2
Q 2 1
B 2 3
B 1 5
Q 2 1
Q 2 4
Q 2 3
```

### 输出

```
-1
2
5
1
2```

# 题解

## 作者：Romeolong (赞：26)

可以线段树合并啊QwQ

为什么要Splay啊

多难写QwQ

可以对于每一个点动态开点线段树，维护重要度。然后用并查集维护联通性，每次连边或者Build就把两棵线段树合并就好了啊QwQ

至于Query操作，就看看左儿子的sum与k的关系就好了

跑得还挺~~快~~

下面是代码

```cpp
#include<cstdio>
#define N (200010)
using namespace std;
inline int read(int &data){
    data=0;char ch=0;
    while(ch<'0' || ch>'9') ch=getchar();
    while(ch>='0' && ch<='9') data=data*10+ch-'0',ch=getchar();
    return data;
}
struct xds{
	int l,r,sum,ch[2];
}t[N<<5];
int n,m,ind,T[N],fa[N],ans[N];
int ask(int x){return (fa[x]==x)?x:fa[x]=ask(fa[x]);}
int insert(int p,int l,int r){
	int rt=++ind;
	t[rt].l=l,t[rt].r=r,t[rt].sum=1;
	if(l==r)return rt; int mid=(l+r)>>1;
	if(p>mid)t[rt].ch[1]=insert(p,mid+1,r);
	else t[rt].ch[0]=insert(p,l,mid);
	return rt;
}
int unite(int L,int R,int l,int r){
	if(!L&&!R)return 0;
	if(!L)return R; if(!R)return L;
	int rt=++ind,mid=(l+r)>>1;
	t[rt].l=l,t[rt].r=r,t[rt].sum=t[L].sum+t[R].sum;
	t[rt].ch[0]=unite(t[L].ch[0],t[R].ch[0],l,mid);
	t[rt].ch[1]=unite(t[L].ch[1],t[R].ch[1],mid+1,r);
	return rt;
}
int query(int x,int k){
	if(t[x].sum<k)return -1;
	if(t[x].l==t[x].r)return ans[t[x].l];
	if(t[t[x].ch[0]].sum>=k)return query(t[x].ch[0],k);
	else return query(t[x].ch[1],k-t[t[x].ch[0]].sum);
}
int main(){
	read(n),read(m);
	for(int i=1;i<=n;i++){fa[i]=i; int x;read(x),T[i]=insert(x,1,n),ans[x]=i;}
	for(int i=1;i<=m;i++){
		int x,y; read(x),read(y);
		int p=ask(x),q=ask(y);
		if(p!=q)fa[p]=q,T[q]=unite(T[p],T[q],1,n);
	}
	int Q; read(Q);
	while(Q--){
		int x,y; char c;
		c=getchar(); while(c!='B'&&c!='Q')c=getchar();
		read(x),read(y); if(c=='Q')printf("%d\n",query(T[ask(x)],y));
		else{int p,q;p=ask(x),q=ask(y);if(p!=q)fa[p]=q,T[q]=unite(T[p],T[q],1,n);}
	}
}
```


---

## 作者：intel_core (赞：19)

~~HN不愧为强省，省选题坑我一页提交.....wtcl~~   
言归正传，这是一道FHQ Treap/线段树合并的练手好题。   
分析下题目：  
*  操作1：`B x y`表示在岛`x`与岛`y`之间修建一座新桥。  
*  操作2：`Q x k`表示询问当前与岛`x`连通的所有岛中第`k`重要的是哪座岛，即所有与岛`x`连通的岛中重要度排名第`k`小的岛是哪座，请你输出那个岛的编号。  
 
操作1：  
* 并查集 ~~这不需要我多讲了吧~~
* 将两个集合合并(①)  
操作2：  
* 查询集合中第k小的数(权值线段树/Treap均可)  
①需要将两个集合里的树合并  
* FHQ Treap+启发式合并
* 权值线段树合并     
这两种方法都可以解决①  
两种方法的时间复杂度都是`O(nlogn)` 
注意：
* 但是FHQ Treap的空间复杂度是`O(n)`的  
* 然鹅线段树合并的空间是`O(nlogn)`的  
因为权值线段树空间大，所以要复用空间  
写成这样会MLE： 
```cpp
int merge(int x,int y,int l,int r){
      if(!x||!y)return x+y;
      if(!id)id=++tot;
      if(l==r){
          t[id].maxa=t[x].size+t[y].size;
          return x;
      }
      int mid=(l+r)>>1;
      t[id].ch[0]=merge(t[id].ch[0],t[y].ch[0],l,mid);
      t[id].ch[1]=merge(t[id].ch[1],t[y].ch[1],mid+1,r);
      update(id);
      return id;
}
```
这样才能AC：  
```cpp
int merge(int x,int y,int l,int r){
      if(!x||!y)return x+y;
      if(l==r){
          t[x].maxa+=t[y].maxa;
          return x;
      }
      int mid=(l+r)>>1;
      t[x].ch[0]=merge(t[x].ch[0],t[y].ch[0],l,mid);
      t[x].ch[1]=merge(t[x].ch[1],t[y].ch[1],mid+1,r);
      update(x);
      return x;
}
```
Treap的启发式合并，只需把`Tree1`里的节点一个个插到`Tree2`里就行。  
效果如下：  
```cpp
void dfs(int id,int &target){
      if(!id)return;
      dfs(t[id].ch[0],target);
      dfs(t[id].ch[1],target);
      t[id].ch[0]=t[id].ch[1]=0;
      t[id].size=1;
      int x=t[id].val;
      int rt1,rt2;
      split(target,x,rt1,rt2);
      target=merge(rt1,merge(id,rt2));
}
```
此题并查集也有坑：  
如果直接合并两个集合，集合里所有元素相当于出现了两次。  
WA写法：
```cpp
void mergeSet(int x,int y){
      if(t[rt[x]].size>t[rt[y]].size)swap(x,y);
      fa[x]=y;
      dfs(rt[x],rt[y]);
}
```
这样才能AC：
```cpp
void mergeSet(int x,int y){
      if(check(x,y))return;
      if(t[rt[x]].size>t[rt[y]].size)swap(x,y);
      fa[x]=y;
      dfs(rt[x],rt[y]);
  }
```
~~一定要快读~~  
Get到了以上技巧，你就能在`800ms~1000ms`A掉本题  
上代码(`FHQ Treap+启发式合并`)
```cpp
#pragma optimize(5, "inline", "Ofast")
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cmath>
#include <queue>
#include <cstring>
using namespace std;
const int NR=1e5+10;
int fa[NR];
int n,m,q;
//------FHQ Treap--------
struct node{
	int ch[2];
	int val;
	int rnd;
	int size;
	int id;
}t[NR];
int tot;
void update(int id){
          t[id].size=t[t[id].ch[0]].size+t[t[id].ch[1]].size+1;
}
int newNode(int val,int id){
      tot++;
      t[tot].val=val;
      t[tot].size=1;
      t[tot].rnd=rand();
      t[tot].id=id;
      return tot;
}
void split(int id,int val,int &x,int &y){
      if(!id){
          x=y=0;
          return;
      }
      if(val>=t[id].val){
          y=id;
          split(t[id].ch[0],val,x,t[id].ch[0]);
      }
      else{
          x=id;
          split(t[id].ch[1],val,t[id].ch[1],y);
      }
      update(id);
}
int merge(int x,int y){
      if(!x||!y)return x+y;
      if(t[x].rnd<t[y].rnd){
          t[x].ch[1]=merge(t[x].ch[1],y);
          update(x);
          return x;
      }
      else{
          t[y].ch[0]=merge(x,t[y].ch[0]);
          update(y);
          return y;
      }
}
void splitk(int id,int k,int &x,int &y){
      if(!id){
          x=y=0;
          return;
      }
      int lsize=t[t[id].ch[0]].size;
      if(k<=lsize){
          y=id;
          splitk(t[id].ch[0],k,x,t[id].ch[0]);
      }
      else{
          x=id;
          splitk(t[id].ch[1],k-lsize-1,t[id].ch[1],y);
      }
      update(id);
}
//-------并查集--------
int rt[NR];
void init(){
      for(int i=1;i<=n;i++)
          fa[i]=i;
}
int get(int x){
      if(fa[x]==x)
          return x;
      return fa[x]=get(fa[x]);
}
bool check(int &x,int &y){
      x=get(x);
      y=get(y);
      return x==y;
}
void dfs(int id,int &target){
      if(!id)return;
      dfs(t[id].ch[0],target);
      dfs(t[id].ch[1],target);
      t[id].ch[0]=t[id].ch[1]=0;
      t[id].size=1;
      int x=t[id].val;
      int rt1,rt2;
      split(target,x,rt1,rt2);
      target=merge(rt1,merge(id,rt2));
}
void mergeSet(int x,int y){
      if(check(x,y))return;
      if(t[rt[x]].size>t[rt[y]].size)swap(x,y);
      fa[x]=y;
      dfs(rt[x],rt[y]);
}
int main(int argc, char const *argv[])
{
      freopen("1.in","r",stdin);
      freopen("1.out","w",stdout);
      cin>>n>>m;
      init();
      for(int i=1;i<=n;i++){
          int x;
          scanf("%d",&x);
          rt[i]=newNode(x,i);
      }
      for(int i=1;i<=m;i++){
          int u,v;
          scanf("%d%d",&u,&v);
          mergeSet(u,v);
      }
      cin>>q;
      for(int i=1;i<=q;i++){
          char opt;
          int x,y;
          scanf(" %c%d%d",&opt,&x,&y);
          if(opt=='Q'){
              x=get(x);
              if(t[rt[x]].size<y){
                  puts("-1");
                  continue;
              }
              int rt1,rt2,rt3;
              int wxb=t[rt[x]].size;
              splitk(rt[x],wxb-y,rt1,rt2);
              splitk(rt2,1,rt2,rt3);
              printf("%d\n",t[rt2].id);
              rt[x]=merge(rt1,merge(rt2,rt3));
          }
          else mergeSet(x,y);
      }
	return 0;
}
```
All in All
* ~~公既知天命识时务，何乃不点我关注？~~

---

## 作者：Wy_x (赞：15)

感谢 [MyShiroko](https://www.luogu.com.cn/user/1642068) 提供思路！

-------------------

大家好，我喜欢暴力数据结构，所以我用暴力通过了此题。

发现 vector 启发式合并（把小 vector 暴力复制在大 vector 的后面）的复杂度总共是 $O(n \log n)$ 的，所以我们考虑使用它。

题目还要求我们求第 $k$ 小，朴素的想法是：在查询时，如果这个块没有排好序（执行过合并操作），那么先 sort 一遍。然后直接输出第 $k$ 小即可。

交上去之后发现我们只获得了 $60 pts$ 的好成绩？
~~数据还是过于淼了。~~

发现瓶颈在于求第 $k$ 小，sort 当块内元素数量（设为 $cnt$）过多时，复杂度极劣，再随便卡卡，复杂度直接爆炸。

考虑优化。

为防止上述情况发生，我们可以设立一个阈值 $B$。

当 $cnt \le B$ 时，直接 sort。

当 $cnt > B$ 时，暴力把这个块中的元素进行值域分块，那么一次查询复杂度降为 $O(\sqrt{n})$，可以通过本题。

显然对于每个 $cnt > B$ 的块，我们只需要执行上述操作一次，之后在合并时把小块中元素放入大的块的值域分块数组，这样就保证复杂度正确。

实际情况中取 $B \approx 1000$ 时最优。

喜提[最优解](https://www.luogu.com.cn/record/list?pid=P3224&orderBy=1&status=&page=1)。

- add 函数
```cpp
void add()
{
	int x = read(), y = read();
	x = find(x);
	y = find(y);
	if (x == y) return;
	if (siz[y] > siz[x]) swap(x, y);

	fa[y] = x;
	siz[x] += siz[y];
	vis[x] = 1; // vis 记录这个块是否需要排序

	v[x].reserve(v[y].size() + 1);

	if (id[x]) // 如果大的块已经被值域分块过
	{
		for (int i = 0; i < v[y].size(); i++)
		{
			add2(id[x], v[y][i]);
			v[x].push_back(v[y][i]); // 复制的同时 小块中元素放入大的块的值域分块数组
		}
		return;
	}
	v[x].insert(v[x].end(), v[y].begin(), v[y].end());
}
```

- query 函数
```cpp
void query()
{
	int x = read(), k = read();
	x = find(x);

	if (siz[x] > B && !id[x]) // 达到阈值，进行值域分块
	{
		id[x] = ++tot;
		for (int i = 0; i < v[x].size(); i++)
			add2(id[x], v[x][i]);
	}
	if (id[x]) // 值域分块求第 k 小
	{
		for (int i = 1; i <= n / len + 2; i++)
		{
			k -= cnt2[id[x]][i];
			if (k <= 0)
			{
				k += cnt2[id[x]][i];
				int l = (i - 1) * len;
				while (k > 0)
				{
					k -= cnt1[id[x]][l];
					if (k <= 0)
					{
						write(to[l]);
						putchar_unlocked('\n');
						return;
					}
					l++;
				}
			}
		}
		puts("-1");
		return;
	}
	else // sort 求第 k 小
	{
		if (vis[x])
		{
			sort(v[x].begin(), v[x].end());
			vis[x] = 0;
		}
		if (v[x].size() < k)
		{
			puts("-1");
			return;
		}
		else write(to[v[x][k - 1]]), putchar_unlocked('\n');
	}
}
```


### Code：

```cpp
#include <vector>
#include <algorithm>
#include <stdio.h>
#include <cmath>
#include <bitset>
// #define int long long

// using namespace std;
using std::bitset;
using std::sort;
using std::swap;
using std::vector;

const int Size = (1 << 20) + 1;
char buf[Size], *p1 = buf, *p2 = buf;
char buffer[Size];
int op1 = -1;
const int op2 = Size - 1;
#define getchar()                                                          \
	(tt == ss && (tt = (ss = In) + fread(In, 1, 1 << 20, stdin), ss == tt) \
		 ? EOF                                                             \
		 : *ss++)
char In[1 << 20], *ss = In, *tt = In;
inline int read()
{
	int x = 0, c = getchar(), f = 0;
	for (; c > '9' || c < '0'; f = c == '-', c = getchar());
	for (; c >= '0' && c <= '9'; c = getchar())
		x = (x << 1) + (x << 3) + (c ^ 48);
	return f ? -x : x;
}
inline void write(int x)
{
	if (x < 0) x = -x, putchar_unlocked('-');
	if (x > 9) write(x / 10);
	putchar_unlocked(x % 10 + '0');
}

vector<int> v[100001];
int n, m;

int fa[100001];
int siz[100001];

int find(int x)
{
	if (x == fa[x]) return x;
	return fa[x] = find(fa[x]);
}

int tot;
const int B = 1024;
unsigned short cnt1[100001 / B + 1][100001], cnt2[100001 / B + 1][1005];
int id[100001];
// bool vis[100001];
bitset<100001> vis;
int to[100001];
int len = 300;

#define add2(id, x)              \
	{                            \
		cnt1[id][x]++;           \
		cnt2[id][x / len + 1]++; \
	}

void add()
{
	int x = read(), y = read();
	x = find(x);
	y = find(y);
	if (x == y) return;
	if (siz[y] > siz[x]) swap(x, y);

	fa[y] = x;
	siz[x] += siz[y];
	vis[x] = 1; // vis 记录这个块是否需要排序

	v[x].reserve(v[y].size() + 1);

	if (id[x]) // 如果大的块已经被值域分块过
	{
		for (int i = 0; i < v[y].size(); i++)
		{
			add2(id[x], v[y][i]);
			v[x].push_back(v[y][i]); // 复制的同时 小块中元素放入大的块的值域分块数组
		}
		return;
	}
	v[x].insert(v[x].end(), v[y].begin(), v[y].end());
}

void query()
{
	int x = read(), k = read();
	x = find(x);

	if (siz[x] > B && !id[x]) // 达到阈值，进行值域分块
	{
		id[x] = ++tot;
		for (int i = 0; i < v[x].size(); i++)
			add2(id[x], v[x][i]);
	}
	if (id[x]) // 值域分块求第 k 小
	{
		for (int i = 1; i <= n / len + 2; i++)
		{
			k -= cnt2[id[x]][i];
			if (k <= 0)
			{
				k += cnt2[id[x]][i];
				int l = (i - 1) * len;
				while (k > 0)
				{
					k -= cnt1[id[x]][l];
					if (k <= 0)
					{
						write(to[l]);
						putchar_unlocked('\n');
						return;
					}
					l++;
				}
			}
		}
		puts("-1");
		return;
	}
	else // sort 求第 k 小
	{
		if (vis[x])
		{
			sort(v[x].begin(), v[x].end());
			vis[x] = 0;
		}
		if (v[x].size() < k)
		{
			puts("-1");
			return;
		}
		else write(to[v[x][k - 1]]), putchar_unlocked('\n');
	}
}

int main()
{
	n = read();
	m = read();
	len = sqrt(n);
	register int x, i;
	for (i = 1; i <= n; i++)
	{
		x = read();
		fa[i] = i;
		siz[i] = 1;
		v[i].push_back(x);
		to[x] = i;
	}
	for (i = 1; i <= m; i++) add();
	register int q = read(), op;
	for (i = 1; i <= q; i++)
	{
		op = 0;
		for (; op < 'A' || op > 'Z'; op = getchar());
		if (op == 'B') add();
		else query();
	}
	return 0;
}

```

---

## 作者：zsaskk (赞：12)

**首先解释为什么要为一个有25篇题解的题目写题解**

1.可以看到，题解区绝大多数$dalao$选择了**指针**，而想必很多选手（包括我这个$juruo$）更习惯于用数组维护。

所以这里给出一种让空间不爆炸的数组实现方法！

2.~~为什么没有$Treap$的题解啊，一定要有一篇！~~



------------


[题目链接](https://www.luogu.com.cn/problem/P3224)

下面开始讲这道题。

题目中只要求我们维护岛屿的连通性，可以考虑用**并查集**维护，一开始所有岛屿是孤立的，每次$B$操作就将两个连通块连接起来，每次$Q$操作查询$fa[x]$的岛屿连接的第$k$重要的岛屿是那一座。

显然，我们需要用到**启发式合并**，即把小的连通块插入到大的连通块中。感性理解，如果反过来做，肯定是不优的。合并只需暴力合并即可满足时间需求。

那为什么题解区指针居多呢？~~大概~~是因为空间无法满足吧。

其实我们只要在删除了某个节点后，在将它插入到一个新的树的时候，**继续使用那个下标**即可。

然后就是普通的$Treap$模板了。



------------

```
#include<bits/stdc++.h>
using namespace std;
#define reg register
#define chk_digit(c) (c>='0'&&c<='9')
inline int read() {
	reg int x=0,f=1;reg char c=getchar();
	while(!chk_digit(c)) { if(c=='-') f=-1;c=getchar(); }
	while(chk_digit(c)) x=x*10+c-'0',c=getchar();
	return x*f;
} 
inline char get_char() {
	reg char c=getchar();
	while(c!='B'&&c!='Q') c=getchar();
	return c;
} 
#define maxsize 2000000
#define MAXN 100005
#define inf 2000000000
struct treap{ int l,r,rand_num,times,size,val; }tr[maxsize];
int tot,root[MAXN],num[MAXN],id[MAXN],n,m,fa[MAXN],s[MAXN],q;
inline int New(int val) { tr[++tot].val=val,tr[tot].rand_num=rand(),tr[tot].size=tr[tot].times=1;return tot; }
inline void update(int p) { tr[p].size=tr[tr[p].l].size+tr[tr[p].r].size+tr[p].times; }
inline void build(int bel) { int now=tot+1;New(-inf),New(inf),root[bel]=now,tr[now].r=now+1,update(root[bel]); }
inline int get_val(int p,int rank) {
	if(!p) return inf;
	if(tr[tr[p].l].size>=rank) return get_val(tr[p].l,rank);
	if(tr[tr[p].l].size+tr[p].times>=rank) return tr[p].val;
	return get_val(tr[p].r,rank-tr[p].times-tr[tr[p].l].size);
}
inline void zig(int &p) { int q=tr[p].l;tr[p].l=tr[q].r,tr[q].r=p,p=q,update(tr[p].r),update(p); }
inline void zag(int &p) { int q=tr[p].r;tr[p].r=tr[q].l,tr[q].l=p,p=q,update(tr[p].l),update(p); }
inline void insert(int &p,int val) {
	if(!p) { p=New(val);return; }
	if(val==tr[p].val) { ++tr[p].times,update(p);return; }
	if(val<tr[p].val) {
		insert(tr[p].l,val);
		if(tr[p].rand_num<tr[tr[p].l].rand_num) zig(p);
	}
	else {
		insert(tr[p].r,val);
		if(tr[p].rand_num<tr[tr[p].r].rand_num) zag(p); 
	}
	update(p);
}
inline void renew(int p) { tr[p].size=tr[p].times=1,tr[p].l=tr[p].r=0; }//插入之前先把原先的信息除去
inline void add(int &p,int val,int where) {//这段代码有一点冗余了，但是它却能够进行内存的循环利用
	if(!p) { p=where;return; } 
	if(val<tr[p].val) {
		add(tr[p].l,val,where);
		if(tr[p].rand_num<tr[tr[p].l].rand_num) zig(p);
	}
	else {
		add(tr[p].r,val,where);
		if(tr[p].rand_num<tr[tr[p].r].rand_num) zag(p);
	}
	update(p);
}
inline void dfs(int p,int bel) {//对要被合并进大的连通块的小连通块dfs，并把它插入大的连通块中
	if(tr[p].l) dfs(tr[p].l,bel);
	if(tr[p].r) dfs(tr[p].r,bel);
	if(tr[p].val!=inf&&tr[p].val!=-inf)
	renew(p),add(root[bel],tr[p].val,p);
}
inline int szfind(int x) { return x==fa[x]?x:fa[x]=szfind(fa[x]); }
inline int szunion(int x,int y) { fa[y]=x,s[x]+=s[y]; } /并查集模板
int main() {
	n=read(),m=read(),srand(time(0)),id[0]=-1;
	for(reg int i=1;i<=n;++i) {
		int x=read();
		num[i]=x,id[x]=i,fa[i]=i,build(i),s[i]=1,insert(root[i],x);
	}
	for(reg int i=1;i<=m;++i) {
		int x=read(),y=read();
		if(szfind(x)==szfind(y)) continue;
		if(s[fa[x]]<s[fa[y]]) x^=y,y^=x,x^=y;
		dfs(root[fa[y]],fa[x]),szunion(fa[x],fa[y]);
	}
	q=read();
	for(reg int i=1;i<=q;++i) {
		char opt=get_char();int x=read(),y=read();
		if(opt=='Q') {
			int z=get_val(root[szfind(x)],y+1);
			if(z==inf||z==0) printf("-1\n");
			else printf("%d\n",id[z]);
		}
		if(opt=='B') {
			if(szfind(x)==szfind(y)) continue;
			if(s[fa[x]]<s[fa[y]]) x^=y,y^=x,x^=y;//启发式合并
			dfs(root[fa[y]],fa[x]),szunion(fa[x],fa[y]);
		}
	}
}
```

当然，$insert$还可以改成这样写，相对简洁

```
inline void insert(int &p,int val,int rem=0) {
	if(!p) { rem?p=rem,tr[rem].val=val,tr[rem].l=tr[rem].r=0:p=New(val);return; }
	if(val==tr[p].val) { ++tr[p].times,update(p);return; }
	if(val<tr[p].val) {
		insert(tr[p].l,val,rem);
		if(tr[p].rand_num<tr[tr[p].l].rand_num) zig(p); 
	}
	else {
		insert(tr[p].r,val,rem);
		if(tr[p].rand_num<tr[tr[p].r].rand_num) zag(p);
	}
	update(p);
}
```


---

## 作者：Error_Eric (赞：11)

### 题意

试维护若干个集合和以下操作：

合并两个集合，查询集合中第 $k$ 大元素的编号。

### Sol

现有题解中最快的。

显然手写平衡树暴力合并加上按秩合并的优化可以过，但是手写平衡树很容易挂掉。

这里提供一种 28 篇题解都没有提到过的全新做法：树状数组。

树状数组可以离散化之后维护平衡树，而且常数较小。

很显然有一个问题是树状数组是 $O(\text{值域})$ 的空间，如果刚开始所有元素都相互隔离就需要 $O(n^2)$ 的空间直接 MLE。

但是这个时候显然每个集合都很小，那么用平衡树暴力查找第 $k$ 大的时间复杂度是 $O(\text{很小})$。

于是人类智慧做法出现了：

取一个 $k$ （我大概取的是 $500$ 估计调一调还能更快，不过也懒得调了）。

如果这个集合的大小小于 $k$ 那么用 set 暴力维护。

如果这个集合的大小大于 $k$ ，那么再搞一个树状数组维护第 $k$ 大。

合并还是暴力合并。

这样子的复杂度是 $O(n\log n+k\log k)$ 左右的，空间复杂度是 $O(\dfrac{n^2}{k}+n)$。

一点都没有卡常，随手取一个 $k$ 就总计第 $8$ 快，题解第 $1$ 快。

### Code

```cpp
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<set>
#include<numeric>
using namespace std;
const int K=500,_=100005;
int n,m,q,u,v,fwtrs[205][_],top=0,f[_],c[_],cc[_];
void readln(int&I){
    I=0;char C=getchar();
    while(!isdigit(C)) C=getchar();
    while( isdigit(C)) (I*=10)+=(C-'0'),C=getchar();
}
void readln(char&C){
    C='#';while(!isalpha(C))C=getchar();
}
void add(int*t,int pos,int val){
    while(pos<=n)t[pos]+=val,pos+=(pos&-pos); 
}
int kth(int*t,int val){
    int res=0,ans=0;
    for(int i=(1<<19);i;i>>=1)
        if(ans+i<=n&&res+t[ans+i]<=val) res+=t[ans+=i];
    return ans;
}
struct hugeset{
    int*trs;
    set<int>st;
    void insert(int val){
        st.insert(val);
        if(st.size()==K){
            trs=fwtrs[++top];
            for(int x:st)add(trs,x,1);
        }
        else if(st.size()>K)
            add(trs,val,1);
    }
    int ukth(int val){
        if(val>st.size()) return n+1;
        else if(st.size()>=K) return kth(trs,val-1)+1;
        auto it=st.begin();while(--val)++it;
        return*it;
    }
}p[_];
int fi(int&o){
    if(f[o]==o) return o;
    else return f[o]=fi(f[o]);
}
void mer(int x,int y){
    x=fi(x),y=fi(y);
    if(x==y)return;
    if(p[x].st.size()>p[y].st.size()) swap(x,y); f[x]=y;
    for(int pxx:p[x].st) p[y].insert(pxx); p[x].st.clear();
}
char op;
int main(){
    readln(n),readln(m),iota(f+1,f+n+1,1),cc[n+1]=-1;
    for(int i=1;i<=n;i++)
        readln(c[i]),cc[c[i]]=i;
    for(int i=1;i<=m;i++)
        readln(u),readln(v),f[fi(u)]=fi(v);
    for(int i=1;i<=n;i++)
        p[fi(i)].insert(c[i]);
    readln(q);
    while (q--){
        readln(op),readln(u),readln(v);
        if(op=='Q') printf("%d\n",cc[p[fi(u)].ukth(v)]);
        else mer(u,v);
    }
}
```

---

## 作者：Starria的脑残粉 (赞：7)

用线段树启发式合并代替平衡树很方便啊

而且还好写

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,kk,a[1000000],f[1000000],q,x,y,sum[5000000],ff[5000000],l[5000000],r[5000000];
char c;
int fa(int x){return f[x]==x?x:f[x]=fa(f[x]);}//奇怪的并查集维护
void putit(int d,int x,int y,int ll,int rr){//加入一个元素
    if (ll==rr){sum[d]++;ff[d]=y;return;}
    int m=(ll+rr)/2;
    if (x<=m){
        if (!l[d])l[d]=++kk;
        putit(l[d],x,y,ll,m);
    }else{
        if (!r[d])r[d]=++kk;
        putit(r[d],x,y,m+1,rr);
    }sum[d]=sum[l[d]]+sum[r[d]];
    if (r[d])ff[d]=ff[r[d]];else ff[d]=ff[l[d]];
}int hb(int x,int y){//合并两个元素
    if (x==y)return x;
    if (x==0)return y;if (y==0)return x;
    sum[x]+=sum[y];l[x]=hb(l[x],l[y]);r[x]=hb(r[x],r[y]);
    if (r[x])ff[x]=ff[r[x]];else ff[x]=ff[l[x]];
    return x;
}int findit(int x,int y){//寻找一个集合内第y大的元素
    if (y>sum[x])return -1;
    if (y==sum[x])return ff[x];
    if (y>sum[l[x]])return findit(r[x],y-sum[l[x]]);
        else return findit(l[x],y);
}
int main(){
    ios::sync_with_stdio(false);
    cin>>n>>m;kk=n;
    for (int i=1;i<=n;i++)cin>>a[i],f[i]=i,putit(i,a[i],i,1,n);
    for (int i=1;i<=m;i++)cin>>x>>y,x=fa(x),y=fa(y),f[y]=f[x]=hb(x,y);
    cin>>q;while (q--){
        cin>>c>>x>>y;
        if (c=='Q')cout<<findit(fa(x),y)<<endl;
            else x=fa(x),y=fa(y),f[y]=f[x]=hb(x,y);
    }
}
```

---

## 作者：ivyjiao (赞：5)

双倍经验：[AT_abc372_e [ABC372E] K-th Largest Connected Components](https://www.luogu.com.cn/problem/AT_abc372_e)。

介绍一种时间复杂度正确的 pb_ds 解法。

很明显这两种操作都能用平衡树 + 并查集维护。

但是手写 FHQ or Splay 太麻烦了，还不如打线段树合并呢，怎么办？

这时候就要用到我们亲爱的 pb_ds 中的 rb_tree_tag 了。

[rb_tree_tag 用法](https://oiwiki.org/lang/pb-ds/tree/)。

假设你已经学会了以上操作。

然后先建立一个并查集，并把每个节点 $i$ 加入到 $tr_i$ 里。

代码：

```cpp
for(int i=1;i<=n;i++){
    cin>>a[i];
    f[i]=i;
    tr[i].insert({a[i],i});
}
```

对于操作一（或初始加边），设 $fx=find(x),fy=find(y)$，则我们先把 $f_{fy}=fx$，然后依次把 $tr_y$ 中的所有节点加入到 $tr_x$ 中，并删除 $tr_y$ 中所有元素。

代码：

```cpp
int fx=find(f[x]),fy=find(f[y]);
if(fx==fy) continue;
f[fy]=fx;
while(tr[fy].size()){
    PII it=*tr[fy].find_by_order(0);
    tr[fx].insert(it);
    tr[fy].erase(tr[fy].upper_bound(it));
}
```

对于操作 $2$，设 $fx=find(x)$，若 $tr_x$ 中元素个数 $<y$，那么输出 $-1$，否则我们在 $tr_x$ 中找出排名为 $y$ 的数并输出其下标。

代码：

```cpp
int fx=find(f[x]);
if(tr[fx].size()<y) cout<<-1<<endl;
else cout<<(*tr[fx].find_by_order(y-1)).se<<endl;
```

细心的朋友可能在 oi-wiki 中发现了一个叫做 `join(x)` 的函数，实际上这玩意在实际应用中基本 P 用没有，直接忽略就行。

> `join(x)` 函数需要保证并入树的键的值域与被并入树的键的值域**不相交**（也就是说并入树内所有值必须全部大于 / 小于当前树内的所有值），否则会抛出 `join_error` 异常。
>
>如果要合并两棵值域有交集的树，需要将一棵树的元素一一插入到另一棵树中。
>
> ——oi-wiki

然后我们发现过不了，原因是暴力合并有可能会被卡到 $O(n^2)$，我们需要使用启发式合并进行优化，即每次把元素个数少的树合并到元素个数多的树中，这样时间复杂度是 $O(n)$ 的。

代码：

```cpp
int fx=find(f[x]),fy=find(f[y]);
if(fx==fy) continue;
if(tr[fx].size()<tr[fy].size()) f[fx]=fy,swap(fx,fy);
else f[fy]=fx;
while(tr[fy].size()){
    PII it=*tr[fy].find_by_order(0);
    tr[fx].insert(it);
    tr[fy].erase(tr[fy].upper_bound(it));
}
```

然后我们就过了。

代码：

```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
#define PII pair<int,int>
#define fi first
#define se second
using namespace std;
using namespace __gnu_pbds;
const int N=1e5+1;
tree<PII,null_type,less_equal<PII>,rb_tree_tag,tree_order_statistics_node_update>tr[N];
int n,m,q,x,y,a[N],f[N];
char op;
int find(int x){
    if(f[x]==x) return x;
    return f[x]=find(f[x]);
}
int main(){
	cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        f[i]=i;
        tr[i].insert({a[i],i});
    }
    while(m--){
        cin>>x>>y;
        int fx=find(x),fy=find(y);
        if(fx==fy) continue;
        if(tr[fx].size()<tr[fy].size()) f[fx]=fy,swap(fx,fy);
        else f[fy]=fx;
        while(tr[fy].size()){
            PII it=*tr[fy].find_by_order(0);
            tr[fx].insert(it);
            tr[fy].erase(tr[fy].upper_bound(it));
        }
    }
    cin>>q;
	while(q--){
        cin>>op>>x>>y;
        if(op=='Q'){
            int fx=find(f[x]);
            if(tr[fx].size()<y) cout<<-1<<endl;
            else cout<<(*tr[fx].find_by_order(y-1)).se<<endl;
        }
        else{
            int fx=find(f[x]),fy=find(f[y]);
            if(fx==fy) continue;
            if(tr[fx].size()<tr[fy].size()) f[fx]=fy,swap(fx,fy);
            else f[fy]=fx;
            while(tr[fy].size()){
                PII it=*tr[fy].find_by_order(0);
                tr[fx].insert(it);
                tr[fy].erase(tr[fy].upper_bound(it));
            }
        }
	}
}
```

---

## 作者：nekko (赞：3)

启发式合并01字典树（本质上就是权值线段树）好像也挺好写的。。。（事实上由于空间开销太大要手写GC导致new node函数长度爆炸。。。）

具体细节看这里：http://www.cnblogs.com/KingSann/articles/7351284.html

``` cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <list>
 
using namespace std;
 
const int N = 100010;
 
int n, m, q, x, y, id[N];
char op[10];
 
int GC[N], gcp;
 
int keys[N], hd[N], nxt[N], lst[N];
 
int root[N], ch[N * 20][2], sum[N * 20];
 
int New() {
    static int cnt = 0;
    if(gcp) {
        int rt =GC[gcp --];
        if(rt[ch][0]) {
            GC[++ gcp] = rt[ch][0];
        }
        if(rt[ch][1]) {
            GC[++ gcp] = rt[ch][1];
        }
        rt[ch][0] = rt[ch][1] = 0;
        rt[sum] = 0;
        return rt;
    } else {
        return ++ cnt;
    }
}
 
#define walk for(int i = 16, t ; (t = (val >> i) & 1), ~i ; i --)
 
void ins(int rt, int val) {
    walk {
        if(rt[ch][t] == 0) rt[ch][t] = New();
        (rt = rt[ch][t])[sum] ++;
    }
}
 
int kth(int rt, int val) {
    int ret = 0;
    walk {
        if(val > rt[ch][0][sum]) {
            val -= rt[ch][0][sum];
            ret |= 1 << i;
            rt = rt[ch][1];
        } else {
            rt = rt[ch][0];
        }
    }
    return ret;
}
 
int acc[N], size[N];
 
void init(int n) {
    for(int i = 1 ; i <= n ; i ++) {
        i[acc] = i;
        i[size] = 1;
    }
}
 
int find(int x) {
    return x == x[acc] ? x : x[acc] = find(x[acc]);
}
 
void uni(int x, int y) {
    x = find(x);
    y = find(y);
    if(x != y) {
        y[size] += x[size];
        x[acc] = y;
    }
}
 
void merge(int x, int y) {
    x = find(x);
    y = find(y);
    if(x != y) {
        if(x[size] > y[size]) {
            swap(x, y);
        }
        for(int i = x[hd] ; i ; i = nxt[i]) {
            ins(y, keys[i]);
            if(nxt[i] == 0) {
                y[lst][nxt] = x;
                y[lst] = x[lst];
            }
        }
        GC[++ gcp] = x;
        uni(x, y);
    }
}
 
int ask(int rt, int k) {
    rt = find(rt);
    if(rt[size] < k) {
        return -1;
    } else {
        int res = kth(rt, k);
        return res[id];
    }
}
 
int main() {
    scanf("%d%d", &n, &m);
    init(n);
    for(int i = 1 ; i <= n ; i ++) {
        i[root] = New();
    }
    for(int i = 1 ; i <= n ; i ++) {
        scanf("%d", &x);
        x[id] = i;
        ins(i[root], x);
        i[keys] = x;
        i[hd] = i;
        i[lst] = i;
    }
    for(int i = 1 ; i <= m ; i ++) {
        scanf("%d%d", &x, &y);
        merge(x, y);
    }
    scanf("%d", &q);
    for(int i = 1 ; i <= q ; i ++) {
        scanf("%s%d%d", op, &x, &y);
        if(op[0] == 'B') {
            merge(x, y);
        } else {
            printf("%d\n", ask(x, y));
        }
    }
    return 0;
}
```

---

## 作者：Polaris_Dane (赞：2)

让我重新深刻认识了平衡树......(主要是自己没有传参进去)

竟然一遍过了！！！

------------

题目意思很简单

就是维护一个动态树，支持连边和查询连通块内第$k$大点权

很明显可以用$LCT$做，可惜我不会

我们用$Splay$做

我们使用启发式合并，当连边时并查集维护，然后$Splay$暴力插入

最后简单的查第$k$大就好了

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<queue>
#include<cctype>
#include<set>
#define LL long long
#define M 4001000
#define N 50010
using namespace std;
const int inf=0x3f3f3f3f;
const int mod=1e9+7;
const double eps=1e-6;
inline int read(){
	int f=1,x=0;char s=getchar();
	while(!isdigit(s)){if (s=='-')f=-1;s=getchar();}
	while(isdigit(s)){x=(x<<1)+(x<<3)+(s^48);s=getchar();}
	return x*f;
}
struct node{
	int fa,cnt,v,son[2],siz;	
};
int cnte; 
node t[M];
struct Splay{
	int root;
	inline void connect(int x,int fa,int d){
		t[x].fa=fa,t[fa].son[d]=x;
	}
	inline void update(int x){
		t[x].siz=t[x].cnt+t[t[x].son[0]].siz+t[t[x].son[1]].siz;
	}
	inline int get_son(int x){
		return t[t[x].fa].son[0]==x?0:1;
	}
	inline void rotate(int x){
		int f=t[x].fa,gf=t[f].fa;
		int fson=get_son(x),gfson=get_son(f);
		connect(t[x].son[fson^1],f,fson);
		connect(x,gf,gfson);
		connect(f,x,fson^1);
		update(f);update(x);
	}
	inline void splay(int x,int to){
		int tmp=to;
		to=t[to].fa;
		while (t[x].fa!=to){
			int f=t[x].fa,gf=t[f].fa;
			if (gf!=to)
				get_son(x)^get_son(f)?rotate(x):rotate(f);
			rotate(x);
		}
		if (tmp==root)
			root=x;
	}
	inline int New(int a,int fa){
		t[++cnte].v=a;
		t[cnte].cnt=t[cnte].siz=1;
		t[cnte].fa=fa;
		return cnte;
	}
	inline void insert(int x){
		int now=root;
		if (!root)
			root=New(x,0);
		else
			while (1){
				t[now].siz++;
				if (x==t[now].v){
					t[now].cnt++;splay(now,root);
					return;
				}
				int nxt=(t[now].v>x)?0:1;
				if (!t[now].son[nxt]){
					t[now].son[nxt]=New(x,now);
					splay(t[now].son[nxt],root);
					return;
				}
				now=t[now].son[nxt];
			}
	}
	inline int find(int x){
		int now=root;
		while (1){
			if (!now) return 0;
			if (t[now].v==x){
				splay(now,root);
				return now;
			}
			int nxt=(t[now].v>x)?0:1;
			now=t[now].son[nxt];
		}	
	}
	inline int ranks(int x){
		int now=root;
		if (x>t[now].siz)
			return -1;
		 while (1){
		 	int rank=t[now].siz-t[t[now].son[1]].siz;
		 	if (x>t[t[now].son[0]].siz&&x<=rank){
		 		splay(now,root);return t[now].v;
		 	}
		 	if (x<rank) now=t[now].son[0];
		 	else x-=rank,now=t[now].son[1];
		}
	}

}tree[M];
int fa[M],ranks[M];
inline int find(int a){
	return fa[a]==a?fa[a]:fa[a]=find(fa[a]);	
}
inline void merge(int rt,Splay&r){
	if (!rt) return;
	merge(t[rt].son[0],r);
	r.insert(t[rt].v);
	merge(t[rt].son[1],r);
}
signed main(){
	int n=read(),m=read();
	for (int i=1;i<=n;i++){
		int x=read();
		tree[i].root=0,tree[i].insert(x);
		ranks[x]=i,fa[i]=i;
	}
	for (int i=1;i<=m;i++){
		int u=read(),v=read();
		int U=find(u),V=find(v);
		if (U==V) continue;
		int minx=t[tree[U].root].siz>t[tree[V].root].siz?V:U;
		int maxx=minx==V?U:V;
		merge(tree[minx].root,tree[maxx]);
		fa[minx]=maxx;
	}
	int q=read();
	for (int i=1;i<=q;i++){
		char c;cin>>c;
		if (c=='Q'){
			int rt=read(),rank=read(),RT=find(rt);
			int ans=tree[RT].ranks(rank);
			if (ans==-1) printf("-1\n");
			else printf("%d\n",ranks[ans]);
		}
		else{
			int u=read(),v=read();
			int U=find(u),V=find(v);
			if (U==V) continue;
			int minx=t[tree[U].root].siz>t[tree[V].root].siz?V:U;
			int maxx=minx==V?U:V;
			merge(tree[minx].root,tree[maxx]);
			fa[minx]=maxx;
		}
	}
	return 0;	
}
```


---

## 作者：hongzy (赞：1)

**题意**

你需要维护若干连通快，有两个操作

- 合并$x,y$所在的连通块
- 询问$x$所在连通块中权值从小到大排第$k$的结点编号

**题解**

可以启发式合并$splay$，感觉比较好写qaq

一个连通块就是一个$splay$，每次合并挑小的$splay$遍历一遍把点按中序遍历存下来，然后一个一个插入大的$splay$就行了；查询就是$splay$的$kth$操作

这样时间复杂度$O(n \log n)$，它的证明可以见2018论文集 ：**董炜隽《浅谈Splay与Treap的性质及其应用》**，其中有提一个$\text{Dynamic Finger Theorem}$

（其实随便插入的话是两个$\log$，也能通过，十分玄学）

```cpp
#include <algorithm>
#include <cstdio>
#include <vector>
using namespace std;

const int N = 2e5 + 10;

int n, m, q, bel[N], rt[N], w[N];
int ch[N][2], fa[N], sz[N];

void upd(int u) { sz[u] = sz[ch[u][0]] + sz[ch[u][1]] + 1; }
int dir(int u) { return ch[fa[u]][1] == u; }

void rotate(int u) {
    int d = dir(u), f = fa[u];
    if(fa[u] = fa[f]) ch[fa[u]][dir(f)] = u;
    if(ch[f][d] = ch[u][d ^ 1]) fa[ch[f][d]] = f;
    fa[ch[u][d ^ 1] = f] = u;
    upd(f); upd(u);
}
void ins(int &rt, int u, int f = 0) {
    if(!rt) {
        rt = u; fa[u] = f; sz[u] = 1;
        ch[u][0] = ch[u][1] = 0;
        return ;
    }
    ins(ch[rt][w[u] > w[rt]], u, rt);
    upd(rt);
}
void splay(int u) {
    for(; fa[u]; rotate(u)) if(fa[fa[u]])
        rotate(dir(u) == dir(fa[u]) ? fa[u] : u);
    rt[bel[u]] = u;
}
int kth(int u, int k) {
    int v = u;
    while(1) {
        if(k <= sz[ch[v][0]]) v = ch[v][0];
        else {
            k -= sz[ch[v][0]] + 1;
            if(k <= 0) break ;
            v = ch[v][1];
        }
    }
    splay(v);
    return v;
}

int a[N], l;
void dfs(int u) {
    if(u) {
        dfs(ch[u][0]);
        a[++ l] = u;
        dfs(ch[u][1]);
    }
}

void link(int u, int v) {
    u = bel[u]; v = bel[v];
    if(u == v) return ;
    if(sz[rt[u]] < sz[rt[v]]) swap(u, v);
    l = 0; dfs(rt[v]);
    for(int i = 1; i <= l; i ++) {
        bel[a[i]] = u;
        ins(rt[u], a[i]);
        splay(a[i]);
    }
}

int main() {
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i ++) scanf("%d", w + i);
    for(int i = 1; i <= n; i ++) {
        bel[i] = rt[i] = i; sz[i] = 1;
    }
    int u, v;
    for(int i = 1; i <= m; i ++) {
        scanf("%d%d", &u, &v);
        link(u, v);
    }
    scanf("%d", &q);
    char op[5];
    for(int i = 1; i <= q; i ++) {
        scanf("%s%d%d", op, &u, &v);
        if(* op == 'Q') {
            u = rt[bel[u]];
            if(v > sz[u]) puts("-1");
            else printf("%d\n", kth(u, v));
        }
        if(* op == 'B') link(u, v);
    }
    return 0;
}
```



---

## 作者：lcjqwq (赞：0)

### Descriprition

两种操作
1. 把两个集合并起来
2. 求一个集合中的第 $k$ 大（的编号）

$n \leq 10^5$

### Solution

平衡树的板子题之一

维护两个点连不连通直接并查集

考虑怎么把两个集合合并

启发式合并！即把 siz 小的那一颗平衡树每一个点暴力地加入到另一个

这样做的复杂度？对于每一个点，每一次合并之后集合大小都至少是原来的两边，所以每一个点都只会被合并 $\log n$ 次。所以这样做是 $O(n \log n)$ 的。

实现上的细节问题：

我用了 fhqtreap（大法好！）。启发式合并的过程（借鉴了题解区里另外一个dalao的fhqtreap）可以这么写：

```cpp
inline void M(node *&r, node *p) { // p 合并到 r 中 
  if(!p) return ; 
  M(r, p->ch[0]); M(r, p->ch[1]); // 递归左子树和右子树
  p->ch[0] = p->ch[1] = 0; // 把它左右子清空然后插到 r 里
  insert(r, p); 
}
```

### Code

[看代码戳这里（指针福利 =w=）](https://www.cnblogs.com/acfunction/p/10171181.html)

---

## 作者：zyh2015 (赞：0)

查询集合内第k小，平衡树可以搞。

合并怎么办？

启发式合并。暴力拆解一个size比较小的，保证每个点至多被拆log(n)次。

（如果俩点在一个集合里就不要再合并啦查了一个小时QAQ）


```cpp
#include <cstdio>
#include <cstdlib>
#define N 100005
using namespace std;
struct Point {
    int ord,val;
    Point(int x=0,int y=0):ord(x),val(y){}
    bool operator < (const Point &rhs) const {return val<rhs.val;}
    bool operator == (const Point &rhs) const {return val==rhs.val;}
};
struct Node {
    Node* ch[2];
    int s,r;
    Point v;
    int cmp(Point x) {
        if(x==v) return -1;
        return x < v ? 0 : 1;
    }
    void maintain() {
        s=ch[0]->s+ch[1]->s+1;
        return ;
    }
    Node(Point);
}*null=new Node(Point(0,0)),*treap[N];
Node :: Node(Point x):v(x){ r=rand(); s=null ? 1 : 0; ch[0]=ch[1]=null;}
void Rotate(Node*& o,int d) {
    Node* k=o->ch[d^1];
    o->ch[d^1]=k->ch[d];
    k->ch[d]=o;
    o->maintain(); k->maintain();
    o=k;
    return ;
}
void Insert(Node*& o,Point x) {
    if(o==null) {o=new Node(x); return ;}
    int d=o->cmp(x);
    Insert(o->ch[d],x);
    if(o->ch[d]->r > o->r) Rotate(o,d^1);
    o->maintain();
    return ;
}
void Merge(Node*& o,Node*& x) {
    if(o==null) return ;
    Merge(o->ch[0],x); Merge(o->ch[1],x);
    Insert(x,o->v);
    delete o;
    o=null;
    return ;
}
int Kth(Node* o,int x) {
    if(x > o->s || x<1 || o==null) return -1;
    if(o->ch[0]->s+1 == x) return o->v.ord;
    if(o->ch[0]->s+1 > x) return Kth(o->ch[0],x);
    return Kth(o->ch[1],x-o->ch[0]->s-1);
}
int pa[N];
int root(int x) {return pa[x]==x ? pa[x] : pa[x]=root(pa[x]);}
int main() {
    null->ch[0]=null->ch[1]=null;
    int n,m,x,y;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&x) , treap[i]=new Node(Point(i,x)) , pa[i]=i;
    while(m--) {
        scanf("%d%d",&x,&y);
        int pa_x=root(x),pa_y=root(y);
        if(pa_x==pa_y) continue;
        if(treap[pa_x]->s > treap[pa_y]->s) Merge(treap[pa_y],treap[pa_x]) , pa[pa_y]=pa_x;
        else Merge(treap[pa_x],treap[pa_y]) , pa[pa_x]=pa_y;
    }
    scanf("%d",&m);
    while(m--) {
        char mode[2];
        scanf("%s%d%d",mode,&x,&y);
        int pa_x=root(x);
        if(mode[0]=='Q') printf("%d\n",Kth(treap[pa_x],y));
        if(mode[0]=='B') {
            int pa_y=root(y);
            if(pa_x==pa_y) continue;
            if(treap[pa_x]->s > treap[pa_y]->s) Merge(treap[pa_y],treap[pa_x]) , pa[pa_y]=pa_x;
            else Merge(treap[pa_x],treap[pa_y]) , pa[pa_x]=pa_y;
        }
    }
    return 0;
}
```

---

## 作者：zhengrunzhe (赞：0)

指针splay来一发

思维各位dalao都讲的很清楚了

每一个岛都建立一个存储重要值的splay

合并直接把小树的每一个节点都insert到大树里就好了

查询就是查排名(注意输出-1…



```cpp
#include<cstdio>
#include<algorithm>
const int N=100001;
inline int read()
{
	int out=0;char ch=getchar();
	while (ch<48||ch>57)ch=getchar();
	while (ch>47&&ch<58)out=(out<<3)+(out<<1)+ch-48,ch=getchar();
	return out;
}
namespace Splay //Splay
{
	struct tree
	{
		int value,size;
		tree *fa,*son[2];
		inline tree(int key)
		{
			size=1;
			value=key;
			fa=son[0]=son[1]=NULL;
		}
		inline void pushup()
		{
			size=1;
			if (son[0])size+=son[0]->size;
			if (son[1])size+=son[1]->size;
		}
	}*root[N];
	inline bool connection(tree *p)
	{
		if (p&&p->fa)return p->fa->son[1]==p;
	}
	inline void connect(tree *&p,tree *&fa,bool which)
	{
		if (p)p->fa=fa;
		if (fa)fa->son[which]=p;
	}
	inline void rotate(tree *&p)
	{
		tree *fa=p->fa;
		bool lr=connection(p);
		connect(p,fa->fa,connection(fa));
		connect(p->son[lr^1],fa,lr);
		connect(fa,p,lr^1);
		fa->pushup();p->pushup();
	}
	inline void splay(tree *&p,tree *&root)
	{
		for (tree *fa;fa=p->fa;rotate(p))
			if (fa->fa)
				rotate(connection(p)==connection(fa)?fa:p);
		root=p;
	}
	inline void insert(int insertion,tree *&root)
	{
		if (root==NULL)
		{
			root=new tree(insertion);
			return;
		}
		tree *now=root;
		while (1)
		{
			if (now->value==insertion)return;
			tree *fa=now;
			bool direction=fa->value<insertion;
			now=fa->son[direction];
			if (now==NULL)
			{
				now=new tree(insertion);
				connect(now,fa,direction);
				fa->pushup();
				splay(now,root);
				return;
			}
		}
	}
	inline int find_rank(int ranking,tree *root)
	{
		tree *now=root;
		if (root->size<ranking)return 0;
		while (1)
			if (now->son[0]&&ranking<=now->son[0]->size)
				now=now->son[0];
			else
			{
				ranking-=(now->son[0]?now->son[0]->size:0)+1;
				if (!ranking)return now->value;
				now=now->son[1];
			}
	}
	void merge(tree *&p,tree *&root)
	{
		if (p->son[0])merge(p->son[0],root);
		if (p->son[1])merge(p->son[1],root);
		insert(p->value,root);
	}
}using namespace Splay;
namespace Set  //并查集
{
	int fa[N];
	int find(int p)
	{
		return fa[p]==p?p:fa[p]=find(fa[p]);
	}
	inline void Union(int a,int b)
	{
		int f1=find(a),f2=find(b);
		if (f1==f2)return;
		if (root[f1]->size>root[f2]->size)std::swap(f1,f2);
        //默认小树合大树
		fa[f1]=f2;
		merge(root[f1],root[f2]);
	}
}
int n,m,q,num[N]={-1}; //num[x]表示重要值为x的岛屿的编号，注意-1
int main()
{
	n=read();m=read();
	for (int i=1;i<=n;i++)
	{
		Set::fa[i]=i; //记得初始化
		int ranking=read();
		num[ranking]=i;
		insert(ranking,root[i]);
	}
	while (m--)Set::Union(read(),read());
	q=read();
	while (q--)
	{
		char opt;scanf(" %c",&opt);
		int x=read(),y=read();
		if (opt==66)Set::Union(x,y);
		else printf("%d\n",num[find_rank(y,root[Set::find(x)])]); //注意是find(x) 需要访问集合的根
	}
}
```

---


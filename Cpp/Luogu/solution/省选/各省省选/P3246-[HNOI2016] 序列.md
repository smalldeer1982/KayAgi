# [HNOI2016] 序列

## 题目描述

给定长度为 $ n $ 的序列：$ a_1, a_2, \cdots , a_n $，记为 $ a[1 \colon n] $。类似地，$ a[l \colon r] $（$ 1 \leq l \leq r \leq N$）是指序列：$ a_{l}, a_{l+1}, \cdots ,a_{r-1}, a_r$。若 $1\leq l \leq s \leq t \leq r \leq n$，则称 $ a[s \colon t] $ 是 $ a[l \colon r] $ 的子序列。

现在有 $ q $ 个询问，每个询问给定两个数 $ l $ 和 $ r $，$ 1 \leq l \leq r \leq n $，求 $ a[l \colon r] $ 的不同子序列的最小值之和。例如，给定序列
 $ 5, 2, 4, 1, 3 $，询问给定的两个数为 $ 1 $ 和 $ 3 $，那么 $ a[1 \colon 3] $ 有 $ 6 $ 个子序列 $a[1 \colon 1], a[2 \colon 2], a[3 \colon 3], a[1 \colon 2],a[2 \colon 3], a[1 \colon 3] $，这 $6 $ 个子序列的最小值之和为 $5+2+4+2+2+2=17$。

## 说明/提示

对于 $100\%$ 的数据，$ 1 \leq n,q \leq 100000$，$|a_i| \leq 10^9$。

## 样例 #1

### 输入

```
5 5
5 2 4 1 3
1 5
1 3
2 4
3 5
2 5```

### 输出

```
28 
17 
11 
11 
17```

# 题解

## 作者：Kelin (赞：72)

 ## [题意](https://blog.csdn.net/BeNoble_/article/details/79775006)

给你一个序列,每次询问一个区间,求其所有子区间的最小值之和

---

## 题解

这里有两种方法,一种是离线的莫队,一种是在线算法

### 一.莫队

这题难就难在怎么由$[l,r]$推向$[l,r+1]$

考虑他们之间的增量就是新增的$[l,r+1],[l+1,r+1],\ldots,[r+1,r+1]$这$r-l+2$个区间的最小值之和

考虑求出$[l,r+1]$的最小值位置是$p$,那么所有左端点在$[l,p]$之间的区间答案都是$a[p]$

贡献就是$a[p]\times(p-l+1)$,这一部分可以用$rmq$求最小值处理

考虑剩下的左端点在$[p+1,r+1]$的区间

设$f[l][r]$表示以$r$为右端点,左端点在$[l,r]$的区间的答案(要求的就是$f[p+1][r+1]$)

记录一下$pre_i$表示从$i$向前第一个比$i$小的数的位置(这个可以用单调栈$O(n)$求出)

那么左端点在$[pre_r,r]$的区间最小值都是$a[r]$

那么就有$f[l][r]=f[l][pre_r]+a_r\times(r-pre_r)$

可以发现$dp$增量只和$r$自身有关,所以可以去掉$l$那一维

>因为最终一定会存在一个点$x$,满足$pre_x=p$

>那么$f_{r+1}=a_{r+1}\times(r+1-pre_{r+1})+\ldots+a_x\times(x-p)+f_p$

>我们可以发现$f_{r+1}-f_p$就是原来要求的$f[p+1][r+1]$

这样我们就可以预处理出$f$,然后就可以$O(1)$完成转移了

删除的话我们就减去$[l,r-1]\to[l,r]$的增量就好了

至于在左边加,就对称处理就好了

复杂度$O(n\log n+n\sqrt n)$

($rmq$的$qry$里$R-(1<<t)+1$的"$+1$”,忘记打了调了一个小时$/$一脸悲伤)

```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){return A==B&&(B=(A=ss)+fread(ss,1,1<<17,stdin),A==B)?-1:*A++;}
template<class T>inline void sd(T&x){
    char c;T y=1;while(c=gc(),(c<48||57<c)&&c!=-1)if(c==45)y=-1;x=c-48;
    while(c=gc(),47<c&&c<58)x=x*10+c-48;x*=y;
}
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
template<class T>inline void we(T x){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
const int N=1e5+5,inf=2e9;
typedef int arr[N];
typedef long long ll;
struct Q{
    int l,r,x,id;
    inline bool operator<(const Q b)const{return x==b.x?x&1?r<b.r:r>b.r:x<b.x;}
}q[N];
int n,m,Sz,Top,Mi[17],f[N][17];arr a,pre,suf,S,Log;ll Now,fl[N],fr[N],ans[N];
inline int cmp(const int x,const int y){return a[x]<a[y]?x:y;}
inline int qry(int L,int R){int t=Log[R-L+1];return cmp(f[L][t],f[R-Mi[t]+1][t]);}
inline ll left(int L,int R){int p=qry(L-1,R);return (ll)a[p]*(R-p+1)+fl[L-1]-fl[p];}
inline ll right(int L,int R){int p=qry(L,R+1);return (ll)a[p]*(p-L+1)+fr[R+1]-fr[p];}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    sd(n);sd(m);Sz=sqrt(n);a[n+1]=a[0]=inf;
    Mi[0]=1;fp(i,1,16)Mi[i]=Mi[i-1]<<1;
    fp(i,2,n)Log[i]=Log[i>>1]+1;
    fp(i,1,n)sd(a[i]),f[i][0]=i;
    fp(j,1,Log[n])fp(i,1,n-Mi[j-1]+1)
        f[i][j]=cmp(f[i][j-1],f[i+Mi[j-1]][j-1]);
    fp(i,1,n){
        while(Top&&a[S[Top]]>a[i])suf[S[Top--]]=i;
        pre[i]=S[Top];S[++Top]=i;
    }while(Top)pre[S[Top]]=S[Top-1],suf[S[Top--]]=n+1;
    fp(i,1,n)fr[i]=(ll)a[i]*(i-pre[i])+fr[pre[i]];
    fd(i,n,1)fl[i]=(ll)a[i]*(suf[i]-i)+fl[suf[i]];
    int x,y,L,R;
    fp(i,1,m)sd(x),sd(y),q[i]={x,y,x/Sz,i};
    sort(q+1,q+m+1);L=q[1].l,R=L-1;
    fp(i,1,m){
        x=q[i].l,y=q[i].r;
        while(L>x)Now+=left(L,R),L--;
        while(R<y)Now+=right(L,R),R++;
        while(L<x)Now-=left(L+1,R),++L;
        while(R>y)Now-=right(L,R-1),--R;
        ans[q[i].id]=Now;
    }
    fp(i,1,m)we(ans[i]);
return Ot(),0;
}
```

### 二.在线算法

我们假设区间$[l,r]$的最小值的位置是$p$

那么对于左端点在$[l,p]$,右端点在$[p,r]$的区间最小值都是$a[p]$

这一部分的贡献是$a[p]\times(p-l+1)\times(r-p+1)$

我们还没有统计$[l,p-1]$和$[p+1,r]$的答案

在莫队算法中我们已经知道

>因为最终一定会存在一个点$x$,满足$pre_x=p$

>那么$f_{r+1}=a_{r+1}\times(r+1-pre_{r+1})+\ldots+a_x\times(x-p)+f_p$

>我们可以发现$f_{r+1}-f_p$就是原来要求的$f[p+1][r+1]$

 然而这个是以$r+1$为右端点,左端点在$(p,r+1]$的答案

在这里我们就要考虑左端点在$(p,x]$,右端点在$[x,r]$的全部答案

对于点$r$,所有以$r$为右端点,左端点在$(p,r]$的区间答案是$f_r-f_p$

对于点$r-1$,所有以$r-1$为右端点,左端点在$(p,r-1]$的区间答案是$f_{r-1}-f_p$

$\ldots$

对于点$p+1$,所有以$p+1$为右端点,左端点在$(p,p+1]$的区间答案是$f_{p+1}-f_p$

设$g_i=\sum_{j=1}^if_j$,通过观察发现,这一部分的答案就是$g_r-g_p-f_p\times(r-p)$

同样的,$p$左边的情况也是类似

复杂度$O(n\log n)$
```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){return A==B&&(B=(A=ss)+fread(ss,1,1<<17,stdin),A==B)?-1:*A++;}
template<class T>inline void sd(T&x){
    char c;T y=1;while(c=gc(),(c<48||57<c)&&c!=-1)if(c==45)y=-1;x=c-48;
    while(c=gc(),47<c&&c<58)x=x*10+c-48;x*=y;
}
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
template<class T>inline void we(T x){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
const int N=1e5+5,inf=2e9;
typedef int arr[N];
typedef long long ll;
int n,m,Top,Mi[17],f[N][17];arr a,pre,suf,S,Log;ll fl[N],fr[N],gl[N],gr[N];
inline int cmp(const int x,const int y){return a[x]<a[y]?x:y;}
inline int qry(int L,int R){int t=Log[R-L+1];return cmp(f[L][t],f[R-Mi[t]+1][t]);}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    sd(n);sd(m);a[n+1]=a[0]=inf;
    Mi[0]=1;fp(i,1,16)Mi[i]=Mi[i-1]<<1;
    fp(i,2,n)Log[i]=Log[i>>1]+1;
    fp(i,1,n)sd(a[i]),f[i][0]=i;
    fp(j,1,Log[n])fp(i,1,n-Mi[j-1]+1)
        f[i][j]=cmp(f[i][j-1],f[i+Mi[j-1]][j-1]);
    fp(i,1,n){
        while(Top&&a[S[Top]]>a[i])suf[S[Top--]]=i;
        pre[i]=S[Top];S[++Top]=i;
    }while(Top)pre[S[Top]]=S[Top-1],suf[S[Top--]]=n+1;
    fp(i,1,n)fr[i]=(ll)a[i]*(i-pre[i])+fr[pre[i]],gr[i]=gr[i-1]+fr[i];
    fd(i,n,1)fl[i]=(ll)a[i]*(suf[i]-i)+fl[suf[i]],gl[i]=gl[i+1]+fl[i];
    int l,r,p;
    while(m--){
        sd(l),sd(r),p=qry(l,r);
        we((ll)(p-l+1)*(r-p+1)*a[p]+
            gr[r]-gr[p]-fr[p]*(r-p)+
			gl[l]-gl[p]-fl[p]*(p-l));
    }
return Ot(),0;
}
```

到这里我们可以发现,这个算法的复杂度瓶颈就在于$rmq$了

朴素倍增$rmq$预处理速度太慢

我们可以$O(n)$建立笛卡尔树来进行$rmq$,设单次询问复杂度$=k\lt\log n$

所以这题可以做到$O(n+km)$

```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){return A==B&&(B=(A=ss)+fread(ss,1,1<<17,stdin),A==B)?-1:*A++;}
template<class T>inline void sd(T&x){
    char c;T y=1;while(c=gc(),(c<48||57<c)&&c!=-1)if(c==45)y=-1;x=c-48;
    while(c=gc(),47<c&&c<58)x=x*10+c-48;x*=y;
}
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
template<class T>inline void we(T x){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
const int N=1e5+5,inf=2e9;
typedef int arr[N];
typedef long long ll;
int n,m,rt;arr a,lc,rc,pre,suf,S,Log;ll fl[N],fr[N],gl[N],gr[N];
inline int cmp(const int x,const int y){return a[x]<a[y]?x:y;}
inline int qry(int L,int R){for(int x=rt;;x=(x>R?lc:rc)[x])if(L<=x&&x<=R)return x;}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    sd(n);sd(m);a[n+1]=a[0]=inf;int*Top=S;
    fp(i,1,n){
        sd(a[i]);
        while(Top!=S&&a[*Top]>=a[i])lc[i]=*Top--;
        rc[*Top]=i;*++Top=i;
    }rt=S[1];int top=0;
    fp(i,1,n){
        while(top&&a[S[top]]>a[i])suf[S[top--]]=i;
        pre[i]=S[top];S[++top]=i;
    }while(top)pre[S[top]]=S[top-1],suf[S[top--]]=n+1;
    fp(i,1,n)fr[i]=(ll)a[i]*(i-pre[i])+fr[pre[i]],gr[i]=gr[i-1]+fr[i];
    fd(i,n,1)fl[i]=(ll)a[i]*(suf[i]-i)+fl[suf[i]],gl[i]=gl[i+1]+fl[i];
    int l,r,p;
    while(m--){
        sd(l),sd(r),p=qry(l,r);
        we((ll)(p-l+1)*(r-p+1)*a[p]+
            gr[r]-gr[p]-fr[p]*(r-p)+
			gl[l]-gl[p]-fl[p]*(p-l));
    }
return Ot(),0;
}
```

从$O(n\log n+n\sqrt n)\to O(n\log n)\to O(n+km)$可见这题多么~~毒瘤一般的~~优秀

貌似可以出一道加强版(强制在线,数据范围$n,m\le 2\times 10^6$)

---

$upd:2018.4.5$

唔~笛卡尔树被$hack$了

看来这题还是只能做到$O(n\log n)$

感谢@兔子接烧饼 指出我程序的错误


---

## 作者：Desert_Lycoris (赞：37)

# 引入
本题大多数题解使用的都是$\color{Red}\text{莫队}$算法，这种~~高端霸气上档次~~的算法我这种蒟蒻自然是不会的。

那么对于这道题来说蒟蒻们的出路在哪里呢？


答案就是$\color{Red}\text{二维差分}$！

# 思路
## $\mathtt{First \;Step}\;\text{逆向}$
- 既然题目中要求我们求**一个序列**的每一个**子序列的最小值**的**和**，那么我们可以很自然地想到两种求解方式：

	$\mathtt{1.}$通过**枚举子序列**来得到最小值并最终求和
    
   $\mathtt{2.}$通过**枚举原序列的值**来得到每个值作为最小值对和的贡献
   
   相较于第二种方式，第一种方式需要枚举的次数显然是更多的，所以我们自然择优把第二种思路延伸下去。
- 对于原序列中的一个元素$a_i$，其左侧**第一个小于其自身的值**的元素为$a_{l_i}$，其右侧**第一个小于等于其自身的值**的元素为$a_{r_i}$，则$a_i$**做出贡献的序列**的左端点范围为$\left[{l_i+1},i\right]$，右端点范围为$\left[i,{r_i-1}\right]$，$l_i$与$r_i$这两个值我们可通过单调栈来求得（这应该是比较基础的操作）。

## $\mathtt{Second\;Step}\;\text{转化}$
- 同样地，如果只是单纯地枚举，对于我们$1e5$的询问显然也是会T爆的，所以我们需要继续深入思考：
    
    决定本题答案的是什么？最小值；
    
    决定最小值的因素是什么？序列；
    
    决定序列的因素是什么？端点；
    
    端点有几个？两个。
    
    思考到这里，转化的方式已经出现了：我们可以将一个**序列转化为一个点**，点的横纵坐标分别为序列的左右端点，点的权值为这个序列的最小值。
    
- 按照上述方式，对于序列$a[l:r]$，我们所求的其所有**子序列的最小值之和**就相当于二维平面（x轴正方向为右，y轴正方向为下）内左上角为$(l,l)$，右
下角为$(r,r)$的一个**矩形内的点权和**。

-	我们规定，对于一个左上角为$(1,1)$右下角为$(x,y)$的矩形，其点权和表示为$sum_{x,y}$，则$2.2$中矩形面积为$sum_{l-1,l-1} + sum_{r,r} - sum_{l-1,r} - sum_{r,l-1}$，即将原查询矩形**分成四个查询点**。
    
    这样，查询的转化就完成了，接下来就是处理原序列了。
- 按照$2.1$所述，处理原序列的过程就相当于**给二维平面中的点赋值的过程**。由于原序列中的元素往往都是**对多个序列有贡献**的，所以赋值的过程其实是**二维的区间修改**。由$1.2$中的分析可知，对于一个元素$a_i$，处理时需要将左上角为$(l_i+1,i)$，右下角为$(i,r_i-1)$的矩形内的点权变为$a_i$的值。

	这样，原序列的处理也就完成了，接下来就该看看差分优化了。
    
## $\mathtt{Third\;Step}\;\text{差分}$
- 由$2.4$可知，在处理过程中我们需要用到二维区间修改，由此我们自然可以想到用差分来优化（二维差分这里不予详细解析，可以自己BDFS一下）。

	那么问题就来了，我们应该怎样完成区间求和的操作呢？
- 我们在$2.3$中已经解析了任意矩形面积的求解方法，所以我们只需要考虑左上角为$(1,1)$的矩形的$sum$值该怎样求解就可以了。

![](https://cdn.luogu.com.cn/upload/image_hosting/wls5d52w.png)

- 注：上图坐标数值无实际意义。
- 对于一个位置$(i,j)$，$d_{i,j}$表示差分数组的值，$p_{i,j}$表示点权，则$p_{i,j}=\sum\limits_{s = 1}^i\sum\limits_{t = 1}^jd_{s,t}$，$sum_{x,y}=\sum\limits_{i = 1}^x\sum\limits_{j = 1}^yp_{i,j}$。

	因为我们在区间修改时是对差分数组进行的调整，所以我们不妨探寻一下$sum$与$d$之间的关系，这样就可以省略掉转化成$p$的步骤。
    
    我们考虑差分数组中的一个元素$d_{i,j}$，由上述两个公式可知，它在计算$sum_{x,y}$时，图中**黑色矩形面积就是它被计算的次数**（在黑色矩形中的每一个点的$p$值都包含有$d_{i,j}$）。换句话说，$d_{i,j}$对$sum_{x,y}$的贡献为$(x-i+1)\times(y-j+1)\times d_{i,j}$。
   
- 结合上述内容我们便可以得出$d$与$sum$的关系：
	
    $sum_{x,y}=\sum\limits_{i = 1}^x\sum\limits_{j = 1}^y(x-i+1)\times(y-j+1)\times d_{i,j}$
    
## $\mathtt{Forth \;Step}\;\text{树状数组}$
- 有了差分，自然逃不掉树状数组。首先，我们将$3.5$中得出的式子整理一下，拆分成四个部分：

	$\mathtt{1.}$ $(x+1)\times(y+1)\times\sum\limits_{i = 1}^x\sum\limits_{j = 1}^yd_{i,j}$
    
    $\mathtt{2.}$ $-(x+1)\times\sum\limits_{i = 1}^x\sum\limits_{j = 1}^yj\times d_{i,j}$
    
    $\mathtt{3.}$ $-(y+1)\times\sum\limits_{i = 1}^x\sum\limits_{j = 1}^yi\times d_{i,j}$
    
    $\mathtt{4.}$ $\sum\limits_{i = 1}^x\sum\limits_{j = 1}^y i\times j\times d_{i,j}$
    
    这样我们就需要使用四个不同的树状数组来维护差分数组，他们之间的差别只是在更新的时候增加的值不同。如果$d_{i,j}$增加了$k$，则$1$更新$k$，$2$更新$j\times k$，$3$更新$i\times k$，$4$更新$i\times j\times k$。
    
- 二维树状数组这种东西我怎么可能会呢？所以我的想法就是将**二维的平面压缩到x轴**上，由此就可以将之转化为正常的树状数组了。

	这里我们需要注意，压缩肯定是有限制的，否则二维问题岂不是和一维问题没什么区别了？
- **限制1：** 离线处理

	如果在线处理的话我们就很难避免出现**需要重复计算**的地方，会使时间复杂度大大增加，而离线处理则可以避免出现这种状况，使得每一个需要处理的点只会被处理一次。
    
    离线处理的方式就是构造一个点数组，将需要二维差分时**需要修改的点**的信息以及**查询时所需要的点**的信息存入，最后统一处理即可。
- **限制2：** 排序

	因为我们是向x轴压缩，所以我们应该以纵坐标为关键字对点数组中的元素进行排序，否则就会出现下图的状况。
    
    ![](https://cdn.luogu.com.cn/upload/image_hosting/90xz0lzp.png)
    
    如果**修改点先被处理**的话，那么其横坐标上的值也会随之修改。这之后再去处理查询点时时**本应查询的部分是不包含图中修改点的**，而由于我们是以**横坐标为准**，所以相当于将**修改点也包含在查询范围**内了，也就是得到的结果要比正确结果**多了一个修改点的值**。
    
    这显然是不可行的，所以我们就采取对纵坐标排序的方法来保证不会有上述情况的发生。
    
## $\mathtt{Fifth \;Step}\;\text{点数组}$
    
- 我们在$4.3$中提到了点数组，那么它具体应该怎样构建呢？


	由于点数组中只需要存储两类元素：修改点与查询点，所以我们只需要考虑此二者需要用哪些变量来去描述就可以了。
    
- **查询点**所包含的变量有：横坐标、纵坐标、**矩形编号**、**系数**。

	横纵坐标我就不多说了；
    
    我们在$2.3$中提到可以将一个查询矩形分成四个查询点，又因为我们使用的是离线处理，所以我们需要将**查询点隶属于哪个矩形**记录下来即**矩形编号**；
    
    同样地，$2.3$中给出的公式中各项的系数是不同的，也就是原查询矩形分成的四个查询点**对查询矩形的贡献有正有负**：左上角与右下角贡献为正，左下角与右上角贡献为负。所以左上角与右下角查询点的**系数**为$1$，左下角与右上角查询点的**系数**为$-1$。
    
    如果我们将最后的答案存入$ans$数组中，那么每次遇到查询点需要的操作只是将$ans\left[\text{矩形编号}\right]$加上$\text{系数}\times sum_{\text{查询点}}$。
    
- **修改点**所包含的变量有：横坐标、纵坐标、**权值**。

	横纵坐标我就不多说了；
    
    这里的**权值**指的是差分数组中这个点的值，因为无论是差分还是树状数组都完全是**在二维差分数组上进行的操作**，与原数组已经没有关系了。
    
- 综合来看，一个点需要包含的变量有：横坐标、纵坐标、矩形编号、系数、权值。

	查询点权值为$0$；修改点矩形编号、系数均为$0$。

## $\mathtt{Sixth \;Step}\;\text{注意}$

- $1.2$中提到对于原序列的一个元素$a_i$，我们要找到**左侧**第一个**小于**其自身的值的元素，**右侧**第一个**小于等于**其自身的值的元素，这是为什么呢？我们看下面这个序列：
	
	```cpp
	2 9 5 7 5 8
	```

	对于第一个$5$来说，左侧第一个小于它的是$2$，右侧第一个小于等于它的是第二个$5$，右侧没有小于它的；
    
    对于第二个$5$来说，左侧第一个小于它的是$2$，左侧第一个小于等于它的是第一个$5$，右侧没有小于等于它的；
    
    无论是左侧改成小于等于或者右侧改成小于，都会出现第一个$5$到第二个$5$这段**区间被重复计算**的情况，而一边是小于，一边是小于等于就避免了出现这种情况。
    
- $5.1$中提到点数组中只包含查询点与修改点，而$4.4$中提到需要对点进行排序。这里我们需要注意到这样一种情况：**查询点与修改点重合**。

	我们显然要**先处理修改点**再去处理查询点，而我们怎样**利用排序**区分先后呢？很简单，将**矩形编号**作为第二关键字。由于$5.4$中提到修改点矩形编号为$0$，而查询点的矩形编号一定是大于$0$的，这样就可以顺手把这个问题解决了。
    
# $\mathtt{AC\;CODE}$

上代码，请各位客官**谨慎食用**（抄袭可耻，WA了不怪我哟QvQ）。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define zrl long long/*不开long long 见祖宗*/
const int N = 1e6 + 10;
int n, q, lef[N], rig[N], l, r, st[N], top = 0, cnt = 0;
zrl a[N], ans[N], sumnot[N], sumordinate[N], sumabscissa[N], sumcoordinate[N];
struct node
{
    int x, y, id, flag;
    zrl val;
}p[N * 5];/*点数组*/
int lowbit(int t)
{
    return t & (-t);
}
void addnot(int t, zrl pre)
{
    while(t <= n)
    {
        sumnot[t] += pre;
        t += lowbit(t);
    }
}
void addordinate(int t, zrl pre)
{
    while(t <= n)
    {
        sumordinate[t] += pre;
        t += lowbit(t);
    }
}
void addabscissa(int t, zrl pre)
{
    while(t <= n)
    {
        sumabscissa[t] += pre;
        t += lowbit(t);
    }
}
void addcoordinate(int t, zrl pre)
{
    while(t <= n)
    {
        sumcoordinate[t] += pre;
        t += lowbit(t);
    }
}/*树状数组*/
zrl finnot(int t)
{
    zrl num = 0;
    while(t > 0)
    {
        num += sumnot[t];
        t -= lowbit(t);
    }
    return num;
}
zrl finordinate(int t)
{
    zrl num = 0;
    while(t > 0)
    {
        num += sumordinate[t];
        t -= lowbit(t);
    }
    return num;
}
zrl finabscissa(int t)
{
    zrl num = 0;
    while(t > 0)
    {
        num += sumabscissa[t];
        t -= lowbit(t);
    }
    return num;
}
zrl fincoordinate(int t)
{
    zrl num = 0;
    while(t > 0)
    {
        num += sumcoordinate[t];
        t -= lowbit(t);
    }
    return num;
}/*树状数组*/
void addp(int setx, int sety, int bel, int xs, zrl much)
{
    p[++cnt].x = setx;
    p[cnt].y = sety;
    p[cnt].id = bel;
    p[cnt].flag = xs;
    p[cnt].val = much;
}/*点数组*/
void prepare()/*预处理*/
{
    for(int i = 1; i <= n; i++)
    {
        while(top && a[st[top]] >= a[i])
        {
            rig[st[top]] = i;
            top--;
        }
        lef[i] = st[top];
        st[++top] = i;
    }/*单调栈*/
    for(int i = 1; i <= n; i++)
    {
        if(rig[i] == 0)
        {
            rig[i] = n + 1;
        }
    }
    for(int i = 1; i <= n; i++)
    {
        if((lef[i] + 1) <= i && i <= (rig[i] - 1))
        {
            int x1 = i, y1 = lef[i] + 1, x2 = rig[i] - 1, y2 = i;
            addp(x1, y1, 0, 0, a[i]);
            addp(x1, y2 + 1, 0, 0, -a[i]);
            addp(x2 + 1, y1, 0, 0, -a[i]);
            addp(x2 + 1, y2 + 1, 0, 0, a[i]);
        }
    }/*修改点*/
}
bool comp(node a, node b)
{
    if(a.y == b.y)
    {
        if(a.x == b.x)
        {
            return a.id < b.id;/*第二关键字*/
        }
        return a.x < b.x;
    }
    return a.y < b.y;/*第一关键字*/
}/*排序*/

int main()
{
    cin >> n >> q;
    for(int i = 1; i <= n; i++)
    {
        cin >> a[i];
    }
    prepare();
    for(int i = 1; i <= q; i++)
    {
        cin >> l >> r;
        addp(l - 1, l - 1, i, 1, 0);
        addp(r, r, i, 1, 0);
        addp(l - 1, r, i, -1, 0);
        addp(r, l - 1, i, -1, 0);
    }/*查询点*/
    sort(p + 1, p + cnt + 1, comp);
    for(int i = 1; i <= cnt; i++)
    {
        if(p[i].id == 0)
        {
            addnot(p[i].x, p[i].val);
            addordinate(p[i].x, p[i].val * (zrl)p[i].y);
            addabscissa(p[i].x, p[i].val * (zrl)p[i].x);
            addcoordinate(p[i].x, p[i].val * (zrl)p[i].x * (zrl)p[i].y);
            /*对四个树状数组分别操作*/
        }
        else
        {
            zrl first = 1ll * (p[i].x + 1) * (p[i].y + 1) * finnot(p[i].x);
            zrl second = 1ll * (p[i].x + 1) * finordinate(p[i].x);
            zrl third = 1ll * (p[i].y + 1) * finabscissa(p[i].x);
            zrl forth = 1ll * fincoordinate(p[i].x);/*拆分出的四个部分*/
            ans[p[i].id] += p[i].flag * (first - second - third + forth);
        }
    }
    for(int i = 1; i <= q; i++)
    {
        cout << ans[i] << endl;
    }
    return 0;
}

```
求管理员大大通过~~

---

## 作者：George1123 (赞：27)

# 题解-[HNOI2016]序列

## [博客中阅读](https://www.cnblogs.com/Wendigo/p/12634706.html)

> [\[HNOI2016\]序列](https://www.luogu.com.cn/problem/P3246)

> 给定 $n$ 和 $m$ 以及序列 $a\{n\}$。有 $m$ 次询问，每次给定区间 $[l,r]\in[1,n]$，求 
> $$\sum_{l\le l'\le r'\le r}\min_{i=l'}^{r'}a_i$$

> 数据范围：$1\le n,m\le 10^5$，$|a_i|\le 10^9$。

---
蒟蒻要练习省选题，结果就遇到这道数据结构（好久没写数据结构题都忘光了）。结果正好遇到一道毒瘤题，于是蒟蒻来写篇题解。

---
这题是静态离线，令人想到 **$\texttt{ST}$ 表和莫队**——真的就是他们。

将区间存下来排序，将左端点范围从小到大分 $\sqrt n$ 份，**左端点按份排序，右端点奇偶波浪排序。**

```cpp
friend int operator<(Moq x,Moq y){
	if(cas[x.l]!=cas[y.l]) return x.l<y.l;
	return (cas[x.l]&1)?x.r<y.r:x.r>y.r;
}
```

然后依次考虑排序后每一个区间询问，并通过上一个区间的答案递推，**这就是莫队的思想**。

---
**然后看这题：**

如何通过上一个答案递推呢？需要先知道**边界端点的贡献**。

即给定区间 $[l,r]$，$l$ 端点的贡献$=Ans[l,r]-Ans[l+1,r]$。

比如下面给出一个序列 $a\{n\}(n=10)$：

```cpp
4 4 5 3 6 2 1 5 6 9
```

给定区间 $[l,r]=[3,9]$，即 $a_l\sim a_r$ 为：

```cpp
5 3 6 2 1 5 6
```

所以**左端点 $(l=3,a_l=5)$ 的贡献**应该为

$$\sum_{j=l}^r\min\limits_{k=l}^j a_k$$

即

$$\min\{5\}+\min\{5,3\}+\min\{5,3,6\}+\cdots+\min\{5,3,6,2,1,5,6\}$$

$$=5+3+3+2+1+1+1$$

令人想起单调栈，然而不可能每次询问 $\Theta(n)$ 跑一遍。所以可以预处理：

通过**维护单调栈**，求出对于每个 $a_i$，$lw_i(lw_i<i)$ 表示 $i$ 左边第一个比 $a_i$ 小的元素的下标；$rw_i(rw_i>i)$ 表示 $i$ 右边第一个比 $a_i$ 小的元素的下标（如果左边不存在比 $a_i$ 小的元素，$lw_i=0$；如果右边不存在比 $a_i$ 小的元素，$rw_i=n+1$）。

这样的话，就可以维护一个**前缀和 $lsm_i$ 后缀和 $rsm_i$**，其中

$$lsm_i=lsm_{lw_i}+a_i(i-lw_i),rsm_i=rsm_{rw_i}+a_i(rw_i-i)$$

然后上面的 $5+3+3+2$ 就可以通过**后缀和相减**得，求右端点贡献时则用**前缀和相减**。

> 因为对于区间 $[lw_i+1,i]$ 或 $[i,rw_i-1]$，$a_i$ 为其最小元素。

```cpp
void Side(){
	lw.rz(n+7),rw.rz(n+7);
	a[0]=-inf;
	q.clear(),q.pb(0);
	for(int i=1;i<=n;i++){
		while(q.size()&&a[q.back()]>=a[i]) q.pop_back();
		lw[i]=q.back(),q.pb(i);
	}
	a[0]=0;
	a[n+1]=-inf;
	q.clear(),q.pb(n+1);
	for(int i=n;i>=1;i--){
		while(q.size()&&a[q.back()]>=a[i]) q.pop_back();
		rw[i]=q.back(),q.pb(i);
	}
	a[n+1]=0;
	lsm.rz(n+7),rsm.rz(n+7);
	for(int i=1;i<=n;i++) lsm[i]=lsm[lw[i]]+(lng)(i-lw[i])*a[i];
	for(int i=n;i>=1;i--) rsm[i]=rsm[rw[i]]+(lng)(rw[i]-i)*a[i];
}
```

---

最后一个问题：$1+1+1$ 部分怎么办？

因为右端点是**随机**的，所以如果直接把左端点的贡献当做 $rsm_l-rsm_r$，必然不妥。

考虑到假设区间 $[l,r]$ 中 $a_p$ 最小，那么必然

$$\forall j\in[p,r],\left(\min\limits_{k=l}^j a_k\right)=a_p$$

所以算 $1+1+1$ 部分可以通过**维护静态区间最小值下标**（$\texttt{ST}$ 表）找到 $p$，算出 $a_p(r-p+1)$。

然后正因为 $a_p$ 是 $[l,r]$ 区间中最小的元素，所以 $[l,p-1]$ 段的左端点贡献也自然是 $rsm_l-rsm_p$。

所以对于区间 $[l,r]$，左端点贡献为

$$rsm_l-rsm_p+a_p(r-p+1)\qquad [a_p=\min_{i=l}^r a_i]$$

**右端点同理。**

然后**相邻两个区间**之间就可以逐步转移了。

```cpp
lng Mol(int l,int r){
	int p=getmin(l,r);
	return rsm[l]-rsm[p]+(lng)(r-p+1)*a[p];
}
lng Mor(int l,int r){
	int p=getmin(l,r);
	return lsm[r]-lsm[p]+(lng)(p-l+1)*a[p];
}
void runMo(){
	int L=1,R=0;
	for(int i=1;i<=m;i++){
		while(L>qu[i].l) res+=Mol(--L,R);
		while(R<qu[i].r) res+=Mor(L,++R);
		while(L<qu[i].l) res-=Mol(L++,R);
		while(R>qu[i].r) res-=Mor(L,R--);
		ans[qu[i].I]=res;
	}
}
```

---
**时间复杂度 $\Theta(m\sqrt n)$，空间复杂度 $\Theta(n+m)$。**

---
## Code

我这个蒟蒻垃圾真是傻傻讲不清楚，还是放代码吧（要开 $\texttt{long long}$）。

代码有点长，于是蒟蒻划分了一下。

```cpp
#include <bits/stdc++.h>
using namespace std;

//Start
#define lng long long
#define db double
#define mk make_pair
#define pb push_back
#define fi first
#define se second
#define rz resize
const int inf=0x3f3f3f3f;
const lng INF=0x3f3f3f3f3f3f3f3f;

//Data
int n,m;
vector<int> a;

//Side
vector<int> lw,rw,q;
vector<lng> lsm,rsm;
void Side(){
	lw.rz(n+7),rw.rz(n+7);
	a[0]=-inf;
	q.clear(),q.pb(0);
	for(int i=1;i<=n;i++){
		while(q.size()&&a[q.back()]>=a[i]) q.pop_back();
		lw[i]=q.back(),q.pb(i);
	}
	a[0]=0;
	a[n+1]=-inf;
	q.clear(),q.pb(n+1);
	for(int i=n;i>=1;i--){
		while(q.size()&&a[q.back()]>=a[i]) q.pop_back();
		rw[i]=q.back(),q.pb(i);
	}
	a[n+1]=0;
	lsm.rz(n+7),rsm.rz(n+7);
	for(int i=1;i<=n;i++) lsm[i]=lsm[lw[i]]+(lng)(i-lw[i])*a[i];
	for(int i=n;i>=1;i--) rsm[i]=rsm[rw[i]]+(lng)(rw[i]-i)*a[i];//中间递推也要注意爆int
}

//ST
vector<int> lg;
vector<vector<int> > st;
int stcmp(int x,int y){
	return a[x]<a[y]?x:y;
}
void buildst(){
	lg.rz(n+7);
	for(int i=2;i<=n;i++) lg[i]=lg[i-1]+((1<<(lg[i-1]+1))<=i?1:0); //lg[i]=(int)log(i)
	st.rz(lg[n]+7);
	for(int j=0;j<=lg[n];j++) st[j].rz(n+7);
	for(int i=1;i<=n;i++) st[0][i]=i;
	for(int j=1;j<=lg[n];j++)
		for(int i=1;i<=n-(1<<(j-1));i++) st[j][i]=stcmp(st[j-1][i],st[j-1][i+(1<<(j-1))]);
}
int getmin(int l,int r){
	int len=lg[r-l+1];
	return stcmp(st[len][l],st[len][r-(1<<len)+1]);
}

//Moq
int sq;
lng res;
vector<int> cas;
vector<lng> ans;
struct Moq{
	int l,r,I;
	friend int operator<(Moq x,Moq y){
		if(cas[x.l]!=cas[y.l]) return x.l<y.l;
		return (cas[x.l]&1)?x.r<y.r:x.r>y.r;
	}
};
vector<Moq> qu;
void buildMo(){
	cas.rz(n+7),qu.rz(m+1);
	sq=sqrt(n);
	for(int i=1;i<=m;i++) scanf("%d%d",&qu[i].l,&qu[i].r),qu[i].I=i;
	for(int i=1;i<=n;i++) cas[i]=(i-1)/sq+1;
	sort(qu.begin(),qu.end());
}
lng Mol(int l,int r){
	int p=getmin(l,r);
	return rsm[l]-rsm[p]+(lng)(r-p+1)*a[p];
}
lng Mor(int l,int r){
	int p=getmin(l,r);
	return lsm[r]-lsm[p]+(lng)(p-l+1)*a[p];
}
void runMo(){
	int L=1,R=0;
	for(int i=1;i<=m;i++){
		while(L>qu[i].l) res+=Mol(--L,R);
		while(R<qu[i].r) res+=Mor(L,++R);
		while(L<qu[i].l) res-=Mol(L++,R);
		while(R>qu[i].r) res-=Mor(L,R--);
		ans[qu[i].I]=res;
	}
}

//Main
int main(){
	scanf("%d%d",&n,&m);
	a.rz(n+7);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	ans.rz(m+7);
	Side(),buildst(),buildMo(),runMo();
	for(int i=1;i<=m;i++)
		printf("%lld\n",ans[i]);
	return 0;
}
```
---
**祝大家学习愉快！**


---

## 作者：crashed (赞：15)

# 题目
&emsp;&emsp;[点这里](https://www.luogu.com.cn/problem/P3246)看题目。  
# 分析
&emsp;&emsp;考虑将所有子序列画成$n\times n$的表的形式，表中的元素$(x,y)$就表示子序列$a[x:y]$的最小值。（$x>y$则$(x,y)=0$）  
&emsp;&emsp;那么，对于一个元素$a_i$，记它左边第一个**小于它**的位置为$lef(i)$，右边第一个**小于等于它**的位置为$rig(i)$。那么，在表格中，从$(lef(i)+1,i)$到$(i,rig(i)-1)$的这些序列的最小值，都会是$a_i$。因此，一个元素就相当于在这个表格上面进行了一次矩形覆盖。    
&emsp;&emsp;再考虑查询，对于查询$(l,r)$，它查询的实际就是表格上$(l,l)$到$(r,r)$的元素和。考虑到$\forall 1\le i< l, l\le j\le r, (j,i)=0$，因此，询问实际上等价于$(l,1)$到$(r,r)$的元素和。  
&emsp;&emsp;接下来就是一个离线的扫描线问题了。将矩形覆盖分为两类，一类是已经被扫描线扫过了，一类是正在被扫描。对于第一类，我们可以用一个线段树$T_1$维护它的贡献（因为扫过了之后它的贡献就不会改变了）；对于第二类，我们做一个差分，将它已经固定了的贡献$(lef-1)*a$加入到$T_1$中，再用另一个线段树$T_2$维护当前扫描线上的情况。查询的时候，我们就可以将$T_2$的贡献乘上扫描线的位置，再与$T_1$的贡献相减，这样第二类矩形的贡献就可以算出来了。   
&emsp;&emsp;时间是$O(n\log_2n)$。  
# 代码
```cpp
#include <cstdio>
#include <vector>
#include <cstring>
using namespace std;

typedef long long LL;

const int MAXN = 1e5 + 5;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

struct SegmentTree
{
	LL s[MAXN << 2], tag[MAXN << 2];
	
	SegmentTree() { memset( s, 0, sizeof s ), memset( tag, 0, sizeof tag ); }
	
	void upt( const int x ) { s[x] = s[x << 1] + s[x << 1 | 1]; }
	void add( const int x, const LL v, const int l, const int r ) { s[x] += ( r - l + 1 ) * v, tag[x] += v; }
	
	void normalize( const int x, const int l, const int r )
	{
		if( ! tag[x] ) return ;
		int mid = l + r >> 1;
		add( x << 1, tag[x], l, mid ), add( x << 1 | 1, tag[x], mid + 1, r );
		tag[x] = 0;
	}
	
	void update( const int u, const int l, const int r, const int segL, const int segR, const LL val )
	{
		if( segL <= l && r <= segR ) { add( u, val, l, r ); return ; }
		int mid = l + r >> 1; normalize( u, l, r );
		if( segL <= mid ) update( u << 1, l, mid, segL, segR, val );
		if( segR > mid ) update( u << 1 | 1, mid + 1, r, segL, segR, val );
		upt( u );
	}

	LL query( const int u, const int l, const int r, const int segL, const int segR )
	{
		if( segL <= l && r <= segR ) return s[u];
		LL ret = 0; int mid = l + r >> 1; normalize( u, l, r );
		if( segL <= mid ) ret += query( u << 1, l, mid, segL, segR );
		if( mid < segR ) ret += query( u << 1 | 1, mid + 1, r, segL, segR );
		return ret;
	}
}T1, T2;

vector<int> add[MAXN], sub[MAXN], q[MAXN];

LL ans[MAXN], qL[MAXN], qR[MAXN];
int a[MAXN], lef[MAXN], rig[MAXN], stk[MAXN];
int N, Q, top;

signed main()
{
	read( N ), read( Q );
	for( int i = 1 ; i <= N ; i ++ ) read( a[i] );
	for( int i = 1 ; i <= N ; i ++ )
	{
		while( top && a[stk[top]] >= a[i] ) rig[stk[top --]] = i;
		stk[++ top] = i;
	}
	while( top ) rig[stk[top --]] = N + 1;
	for( int i = N ; i ; i -- )
	{
		while( top && a[stk[top]] > a[i] ) lef[stk[top --]] = i;
		stk[++ top] = i;
	}
	while( top ) lef[stk[top --]] = 0;
	for( int i = 1 ; i <= N ; i ++ ) add[i].push_back( i ), sub[rig[i]].push_back( i );
	for( int i = 1 ; i <= Q ; i ++ ) 
	{
		read( qL[i] ), read( qR[i] );
		q[qR[i]].push_back( i );
	}
	int id;
	for( int i = 1 ; i <= N ; i ++ )
	{
		for( int j = 0 ; j < add[i].size() ; j ++ )
		{
			id = add[i][j];
			T1.update( 1, 1, N, lef[id] + 1, id, 1ll * ( i - 1 ) * a[id] );
			T2.update( 1, 1, N, lef[id] + 1, id, a[id] );
		}
		for( int j = 0 ; j < sub[i].size() ; j ++ )
		{
			id = sub[i][j];
			T1.update( 1, 1, N, lef[id] + 1, id, -1ll * ( i - 1 ) * a[id] );
			T2.update( 1, 1, N, lef[id] + 1, id, - a[id] );
		}
		for( int j = 0 ; j < q[i].size() ; j ++ )
		{
			id = q[i][j];
			ans[id] = 1ll * i * T2.query( 1, 1, N, qL[id], qR[id] ) - T1.query( 1, 1, N, qL[id], qR[id] );
		}
	}
	for( int i = 1 ; i <= Q ; i ++ ) write( ans[i] ), putchar( '\n' );
	return 0;
}
``` 

---

## 作者：鱼跃于渊 (赞：13)

这道题实际上是 [P8868 [NOIP2022] 比赛](https://www.luogu.com.cn/problem/P8868) 的弱化版。  
## 做法
首先我们离线所有的询问，对于右端点 $r$ 进行扫描线，我们设 $X_{l,r}=\min_{i=l}^{r}a_i,S_{l,r}=\sum_{i=l}^{r}X_{l,i}$，则可以得到区间 $[l,r]$ 的答案为 $\sum_{i=l}^{r}S_{l,i}$，实际上就是这段区间的历史版本和。   
考虑单调栈维护，当 $i$ 入栈时先排除掉比 $a_i$ 大的数，若排除完后栈顶为 $j$，则 $[j,i]$ 这段区间的最小值就是 $a_i$，可以在线段树上更新。  
不过要注意，如果维护区间最值，时间复杂度是 $O(n \log^2 n)$ 的。事实上我们还可以维护区间加减，使时间复杂度降至 $O(n\log n)$，具体可以看代码理解。  

现在步入正题，来讲一下如何通过双半群模型来构造出我们需要的线段树，即一棵支持区间加减区间版本和的线段树。  
如果您不知道双半群模型是什么，可以阅读 [这篇](https://www.cnblogs.com/Meatherm/p/17925813.html) 和 [这篇](https://www.luogu.com/article/rqmfqvmu) 文章，然后再来看本文的构造方法。    
我们首先考虑我们需要维护的信息 $D$，显然区间和与区间版本和是必需的，为方便起见，我们把区间长度也加入其中，这样信息 $D$ 就可以表示成 $(sa,sum,len)$ 的形式，其中 $sa$ 是区间和，$sum$ 是区间版本和。  
接下来我们考虑我们需要执行的操作。我们把更新历史版本和也看作是一个操作，那么总共就有两个操作，另一个是区间加减。  
再考虑这两个操作会对信息产生怎样的影响：  
1. 令函数 $f$ 代表区间加减操作，则有 $f((sa,sum,len))=(sa+len\times x,sum,len)$，其中 $x$ 是我们要加减的数。  
2. 令函数 $g$ 代表区间更新操作，则有 $g((sa,sum,len))=(sa,sum+y \times sa,len)$，其中 $y$ 是更新次数。  

再考虑这两个操作结合起来会产生怎样的影响，也就是求函数 $f$ 和 $g$ 的复合，可以得到 $g(f((sa,sum,len)))=(sa+len\times x,sum+y\times sa+len\times x \times y)$。  
事实上可以发现，无论我们以何等顺序、何等次数执行这两个操作，最终的结果都可以表示成上面的那个形式。  
也就是说，如果我们令 $F$ 为若干个 $f$ 和 $g$ 的复合，则 $F((sa,sum,len))=(sa+len\times taga,sum+upd\times sa+len\times cnta)$。  
我们可以记一个三元组 $(taga,upd,cnta)$ 来表示 $F$，事实上我们可以惊讶的发现，这个三元组其实就是我们要维护的标记 $M$ 的形式。  
这就是双半群模型的强悍之处，只要我们知道我们要维护的信息 $D$，以及我们的操作 $F$，就可以推出我们需要维护的标记 $M$。其实它还不止于此，接下来我们还可以推出标记与信息的三个转移。  
如果您阅读了上面给出的两篇文章，您应该知道有三个核心式子：  
1. $D + D \rightarrow D$
2. $M * M \rightarrow M$
3. $D \times M \rightarrow D$

这实际上是我们构造出来的信息 $D$ 和 $M$ 所必须满足的性质，我们可以据此推出它们之间的具体转移。  
首先考虑 $D + D \rightarrow D$，这个还是很简单的，即 $(sa,sum,len)+(sa',sum',len')=(sa+sa',sum+sum',len+len')$，具体到代码就是  
```cpp
node operator +(const node &x,const node &y){
	node z={0,0,0};
	z.a=x.a+y.a;
	z.sum=x.sum+y.sum;
	z.len=x.len+y.len;
	return z;
}
```
其次考虑 $D \times M \rightarrow D$，这个也简单，上文已经得出来 $(sa,sum,len)\times (taga,upd,cnta)=(sa+len\times taga,sum+upd\times sa+len\times cnta)$，具体到代码就是
```cpp
node operator *(const node &x,const tag &y){
	node z={0,0,0};
	z.sum=x.sum+x.a*y.upd+x.len*y.cnta;
	z.a=x.a+x.len*y.taga;
	z.len=x.len;
	return z;
}
```
其次考虑 $M * M \rightarrow M$，这个是最复杂的，不过我们有 $D\times (M*M) = (D\times M)\times M$。也就是说我们可以通过 $(D\times M)\times M$ 所得到的系数，得到 $M*M$ 的结果。  
过程留给读者自行推导，最终可以得到 $((sa,sum,len) \times (taga,upd,cnta))\times (taga',upd',cnta')=(sa+len\times (taga+taga'),sum+(upd+upd')\times sa+len\times (cnta+taga\times upd'+cnta'))$。  
也就是说 $(taga,upd,cnta)*(taga',upd',cnta')=(taga+taga',upd+upd',cnta+taga*upd'+cnta')$，具体到代码就是  
```cpp
tag operator *(const tag &x,const tag &y){
	tag z={0,0,0};
	z.cnta=x.cnta+x.taga*y.upd+y.cnta;
	z.upd=x.upd+y.upd;
	z.taga=x.taga+y.taga;
	return z;
}
```
于是这棵线段树就这么被构造出来了。  
我们最终可以得到构造双半群模型的以下流程：  
1. 构造可行的信息 $D$，检验是否满足 $D+D\rightarrow D$，并得出转移形式。  
2. 通过计算各个操作对信息 $D$ 的影响，总结出标记 $M$，检验是否满足 $D\times M \rightarrow D$，并得出转移形式。  
3. 通过计算验证标记 $M$ 是否满足 $M*M\rightarrow M$，并得出转移形式。
4. 如果出现不满足的情况，从 $1$ 重新开始。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define uint unsigned int
#define ls(x) ((x)<<1)
#define rs(x) ((x)<<1|1)
const int N=1e5+5;
struct tag{
	int taga,upd,cnta;
}M[N<<2];
struct node{
	int a,sum,len;
}D[N<<2];
tag operator *(const tag &x,const tag &y){
	tag z={0,0,0};
	z.cnta=x.cnta+x.taga*y.upd+y.cnta;
	z.upd=x.upd+y.upd;
	z.taga=x.taga+y.taga;
	return z;
}
node operator +(const node &x,const node &y){
	node z={0,0,0};
	z.a=x.a+y.a;
	z.sum=x.sum+y.sum;
	z.len=x.len+y.len;
	return z;
}
node operator *(const node &x,const tag &y){
	node z={0,0,0};
	z.sum=x.sum+x.a*y.upd+x.len*y.cnta;
	z.a=x.a+x.len*y.taga;
	z.len=x.len;
	return z;
}
struct ques{
	int p,i;
};
int n,m,a[N],ans[N];
int top,st[N];
vector <ques> e[N];
void push_up(int i){
	D[i]=D[ls(i)]+D[rs(i)];
}
void modify(int i,tag j){
	D[i]=D[i]*j;
	M[i]=M[i]*j;
}
void push_down(int i){
	modify(ls(i),M[i]);
	modify(rs(i),M[i]);
	M[i]={0,0,0};
}
void update(int nl,int nr,int l,int r,int i,int k){
	if(nl<=l&&r<=nr) return modify(i,{k,0,0});
	push_down(i);
	int mid=(l+r)>>1;
	if(nl<=mid) update(nl,nr,l,mid,ls(i),k);
	if(mid<nr) update(nl,nr,mid+1,r,rs(i),k);
	push_up(i);
}
int query(int nl,int nr,int l,int r,int i){
	if(nl<=l&&r<=nr) return D[i].sum;
	push_down(i);
	int mid=(l+r)>>1,res=0;
	if(nl<=mid) res+=query(nl,nr,l,mid,ls(i));
	if(mid<nr) res+=query(nl,nr,mid+1,r,rs(i));
	return res;
}
void build(int i,int l,int r){
	D[i]={0,0,r-l+1};
	M[i]={0,0,0};
	if(l==r) return;
	int mid=(l+r)>>1;
	build(ls(i),l,mid);
	build(rs(i),mid+1,r);
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1,l,r;i<=m;i++){
		cin>>l>>r;
		e[r].push_back({l,i});
	}
	build(1,1,n);
	for(int i=1;i<=n;i++){
		while(top&&a[st[top]]>a[i]){
			update(st[top-1]+1,st[top],1,n,1,-a[st[top]]);
			top--;
		}
		update(st[top]+1,i,1,n,1,a[i]);
		st[++top]=i;
		modify(1,{0,1,0});
		for(auto x:e[i]) ans[x.i]=query(x.p,i,1,n,1);
	}
	for(int i=1;i<=m;i++) cout<<ans[i]<<'\n';
    return 0;
}
```

---

## 作者：attack (赞：12)

好像搞出了一个和题解不一样的做法(然而我考场上没写出来还是爆零0)

一个很显然的思路是考虑每个最小值的贡献。

预处理出每个数左边第一个比他小的数，右边第一个比他大的数。

那么$[L_i + 1, i]$对$[i, R_i]$中的每个数都会有$a[i]$的贡献。

我们可以抽象成一个二维平面内的矩形加。

询问就是询问最下角为$(l, l)$，右上角为$(r, r)$的矩形内的权值

也就是我们需要解决这么一个问题：两个操作, 矩形加矩形求和，而且前者都在后者的前面执行

我们可以把所有矩形加操作全都向右上角差分，所有询问操作全都向左下角差分。这样我们就只需要考虑每个$(i, j)$左下角的所有修改$(x, y)$的影响，这部分的权值为$(i - x + 1) * (j - y + 1) * w$

直接拆开，发现可以用树状数组维护(单点修改，查前缀和)。然后就做完了

复杂度$O(nlogn)$

```cpp
#include<bits/stdc++.h>
#define LL long long 
#define fi first
#define se second
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1<<22, stdin), p1 == p2) ? EOF : *p1++)
char buf[(1 << 22)], *p1 = buf, *p2 = buf;
char obuf[1<<24], *O = obuf;
void print(int x) {if(x > 9) print(x / 10); *O++ = x % 10 + '0';}
#define OS  *O++ = '\n';
#define fout fwrite(obuf, O-obuf, 1 , stdout); 
using namespace std;
const int MAXN = 1e5 + 10, INF = 1e9 + 10;
template<typename A, typename B> inline bool chmax(A &x, B y) {return x < y ? x = y, 1 : 0;}
template<typename A, typename B> inline bool chmin(A &x, B y) {return x > y ? x = y, 1 : 0;}
inline int read() {
	char c = getchar(); int x = 0, f = 1;
	while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
	while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
	return x * f;
}
int N, M, Q, a[MAXN],  st[MAXN], L[MAXN], R[MAXN]; 
LL ans[MAXN];
struct Modify {
	int h;LL v;
};
vector<Modify> tag[MAXN];
struct Query {
	int h, id, opt;
};
vector<Query> q[MAXN];
void Add(int x1, int y1, int x2, int y2, int v) {
	tag[x1].push_back({y1, v});
	tag[x2 + 1].push_back({y1, -v});
	tag[x1].push_back({y2 + 1, -v});
	tag[x2 + 1].push_back({y2 + 1, v});
}
void Query(int x1, int y1, int x2, int y2, int id) {
	q[x2].push_back({y2, id, 1});
	q[x1 - 1].push_back({y2, id, -1});
	q[x2].push_back({y1 - 1, id, -1});
	q[x1 - 1].push_back({y1 - 1, id, 1});
}
#define lb(x) (x & (-x))
LL s1[MAXN], s2[MAXN], s3[MAXN], s4[MAXN];
void TreeAdd(int x, LL v1, LL v2, LL v3, LL v4) {
	while(x <= M) 
		s1[x] += v1, s2[x] += v2, s3[x] += v3, s4[x] += v4, x += lb(x);
}
pair<pair<LL, LL>, pair<LL, LL> > TreeQuery(int x) {
	pair<pair<LL, LL>, pair<LL, LL> > ans;
	while(x) 
		ans.fi.fi += s1[x], ans.fi.se += s2[x], ans.se.fi += s3[x], ans.se.se += s4[x], x -= lb(x);
	return ans;
}
#undef lb
void solve() {
	for(int i = 1; i <= M; i++) {	
		for(auto y: tag[i]) {
			int v = y.v;
			TreeAdd(y.h, 1ll * v, 1ll * (y.h - 1) * v, 1ll * (i - 1) * v, 1ll * (y.h - 1) * (i - 1) * v);
		}
		for(auto x : q[i]) {
			LL sumv = 0, sumyv = 0, sumxv = 0, sumxyv = 0;
			pair<pair<LL, LL>, pair<LL, LL> > tmp = TreeQuery(x.h);
			sumv = tmp.fi.fi;
			sumyv = tmp.fi.se;
			sumxv = tmp.se.fi;
			sumxyv = tmp.se.se;
			int j = x.h;
			ans[x.id] += 1ll * x.opt * (1ll * i * j * sumv - 1ll * i * sumyv - 1ll * j * sumxv + sumxyv);
		}
	}
}

void Pre() {
	a[0] = -INF; a[N + 1] = -INF; int top = 0;
	for(int i = 1; i <= N + 1; i++) {
		while(top && a[i] < a[st[top]]) R[st[top--]] = i;
		L[i] = st[top];
		st[++top] = i;
	}
	for(int i = 1; i <= N; i++)
		if((i <= R[i] - 1) && (L[i] + 1 <= i)) 
			Add(i, L[i] + 1, R[i] - 1, i, a[i]);
}
signed main() {
	//freopen("a.in", "r", stdin); freopen("b.out", "w", stdout);
	N = read(); M = N + 1; Q = read();
	for(int i = 1; i <= N; i++) a[i] = read();
	Pre();
	for(int i = 1; i <= Q; i++) {
		int l = read(), r = read(), ans = 0;
		Query(l, l, r, r, i);
	}
	solve();
	for(int i = 1; i <= Q; i++) cout << ans[i] << '\n';
	return 0;
}
```

---

## 作者：_maojun_ (赞：10)

提供不太一样的做法。

---

记 $w_{l,r}=\min\limits_{i=l}^ra_i$，询问 $[l,r]$ 的答案 $ans_{l,r}=\sum\limits_{i=l}^r\sum\limits_{j=i}^rw_{i,j}$。

考虑对 $r$ 扫描线，记 $s_l=\sum\limits_{i=l}^rw_{l,i}$，则 $ans_{l,r}=\sum\limits_{i=l}^rs_i$。

考虑数据结构维护，记 $w'_l=w_{l,r}$，即与当前的右端点的区间最小值，则每次 $r$ 右移等价于前缀取 $\min$。$s_l$ 即为 $w'_l$ 的历史版本和。

要区间最值操作，查询区间历史版本和，上 SegmentTree-Beats 维护就好了。

复杂度 $O(n\log^2n+q)$。

```cpp
#define pi pair<int,int>
#define mp make_pair
#define eb emplace_back

typedef long long ll;
inline int max(int x,int y){return x>y?x:y;}
const int N=1e5+5,INF=0x3f3f3f3f;
int n,m,a[N];ll ans[N];
vector<pi>q[N];

const int S=N<<2;
ll sum[S],su_[S];
int mx[S],se[S],c[S],tag[S],tc[S];ll ts[S];
// sum: 区间和，su_：区间历史版本和
// mx：区间最大值，se：区间次大值，不存在则为 -inf，c：区间最大值出现次数
// tag：最大值加法 tag，tc：对最大值的修改次数，ts：tag 的历史版本和
#define ls p<<1
#define rs p<<1|1
#define Ls ls,l,mid
#define Rs rs,mid+1,r
#define all 1,1,n
inline void pu(int p){
	mx[p]=max(mx[ls],mx[rs]);sum[p]=sum[ls]+sum[rs];su_[p]=su_[ls]+su_[rs];
	if(mx[ls]>mx[rs]){se[p]=max(se[ls],mx[rs]);c[p]=c[ls];}
	else if(mx[ls]<mx[rs]){se[p]=max(mx[ls],se[rs]);c[p]=c[rs];}
	else{se[p]=max(se[ls],se[rs]);c[p]=c[ls]+c[rs];}
}
inline void chg(int p,int k,int kc,ll ks){	// k：最大值加法，kc：最大值修改次数，ks：k 的历史版本和
	su_[p]+=kc*sum[p]+ks*c[p];sum[p]+=(ll)k*c[p];mx[p]+=k;
	tc[p]+=kc;ts[p]+=(ll)tag[p]*kc+ks;tag[p]+=k;
}
inline void pd(int p){
	if(tc[p]){
		int mxp=max(mx[ls],mx[rs]);
		if(mx[ls]==mxp)chg(ls,tag[p],tc[p],ts[p]);else chg(ls,0,tc[p],0);
		if(mx[rs]==mxp)chg(rs,tag[p],tc[p],ts[p]);else chg(rs,0,tc[p],0);
		tag[p]=tc[p]=ts[p]=0;
	}
}
void build(int p,int l,int r){
	if(l==r){sum[p]=mx[p]=a[l];c[p]=1;se[p]=-INF;return;}
	int mid=l+r>>1;build(Ls);build(Rs);pu(p);
}
void upd(int p,int l,int r,int R,int k){	// 区间取 min
	if(k>=mx[p]&&r<=R)return chg(p,0,1,0);	// 注意这里 k>=mx[p] 也不能直接 return，要更新历史版本和
	if(k<mx[p]&&r<=R&&k>se[p])return chg(p,k-mx[p],1,k-mx[p]);
	int mid=l+r>>1;pd(p);upd(Ls,R,k);if(R>mid)upd(Rs,R,k);pu(p);
}
ll qry(int p,int l,int r,int L,int R){		// 区间历史版本和
	if(L<=l&&r<=R)return su_[p];int mid=l+r>>1;pd(p);
	if(L>mid)return qry(Rs,L,R);if(R<=mid)return qry(Ls,L,R);return qry(Ls,L,R)+qry(Rs,L,R);
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	for(int i=1,l,r;i<=m;i++){scanf("%d%d",&l,&r);q[r].eb(l,i);}
	build(all);
	for(int r=1;r<=n;r++){					// 右端点扫描线
		upd(all,r,a[r]);
		for(auto[l,i]:q[r])ans[i]=qry(all,l,r);
	}
	for(int i=1;i<=m;i++)printf("%lld\n",ans[i]);
	return 0;
}
```

---

这里简单讲一下区间最值操作历史和的实现方法，因为之前好像做的都是区间最值操作历史最值。

Beats 的作用其实是把询问拆分成若干次对最大值的操作，懒标记叠起来可能导致少更新历史版本和数组。维护历史和的常见方法就是把修改拆成 $k\times A+B$，于是多记录两个值：更新次数和懒标记的历史和，然后正常 Beats 即可。这一部分是 $O(n\log^2n)$ 的。

再注意一下就算整个区间都不会被更新也要给历史和加上，这一部分是 $O(n\log n)$ 的。

---

## 作者：justin_cao (赞：10)

首先可以想到莫队。然后就需要考虑怎么考虑两边扩展对答案的影响。首先我们可以考虑预处理一个$f[i]$表示以$i$结尾的每个后缀的答案（区间最小值）之和，首先我们可以预处理出$pre[i]$表示$i$位置的前面的第一个小于它的元素位置，之后的转移就十分的简单了:
$$f[i]=f[pre[i]]+(i-pre[i]) \times a[i]$$
也就是$i$位置所管辖的区间的贡献再加上前面的贡献。那么我们考虑对于一个$L,R$怎么求出区间$[L,R],[L+1,R]....[R,R]$的贡献，我们考虑找到$[L,R]$区间内的最小值位置，记为$po$，那么左端点在$[L,po]$区间内的答案就肯定为$a[po]$，然后我们考虑$[po+1,R]$之间的答案，我们首先可以想到$f[R]$，但是会发现这只是包括了我们要求的，但是还是有多的，所以我们考虑怎么把多的减掉。

肯定有想到$f[R]-f[po]$这个看起来并不怎么正确的式子，但是事实上，这个就是对的。为什么呢？我们考虑$po$这个位置上的值因为是最小值，所以$[po,R]$区间内取右端点，在$[1,po]$之内取左端点的值并不受区间$[po+1,R]$值之内的值影响，所以前面的答案的值就是$f[po]$。

这个就是莫队的右边加减，至于左边的加减，可以类似的处理。$nxt$（右边第一个小的），$g[i]$（以$i$结尾的前缀答案的和），用上述相同的方法进行考虑即可。

代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#define maxn 1000100
#define inf 1000000007
using namespace std;
typedef long long ll;
ll read()
{
    ll x=0,f=1;
    char ch=getchar();
    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}
    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n,Q;
int a[maxn];
int q[maxn];
int pre[maxn],nxt[maxn];
ll f[maxn],g[maxn];
int pos[maxn][22];
int get(int x,int y)
{
    if(a[x]<a[y])  return x;
    return y;
}
int lg[maxn];
struct P{
    int l,r,id,bl;
}b[maxn];
bool cmp(P a,P b)
{
    if(a.bl==b.bl)  return a.r<b.r;
    return a.bl<b.bl;
}
ll rig(int r,int l)
{
    int len=r-l+1;
    int po=get(pos[l][lg[len]],pos[r-(1<<(lg[len]))+1][lg[len]]);
    ll tmp=0;
    tmp=(ll)(po-l+1)*a[po];
    tmp+=f[r]-f[po];
    return tmp;
}
ll lef(int l,int r)
{
    int len=(r-l+1);
    int po=get(pos[l][lg[len]],pos[r-(1<<(lg[len]))+1][lg[len]]);
    ll tmp=0;
    tmp=(ll)(r-po+1)*a[po];
    tmp+=g[l]-g[po];
    return tmp;
}
ll ans[maxn];
bool cmpx(P a,P b)
{
    return a.id<b.id;
}
int main()
{
    n=read();Q=read();
    for(int i=1;i<=n;i++)  a[i]=read();
    a[0]=a[n+1]=-inf;
    int l=1,r=0;
    q[++r]=0;
    for(int i=1;i<=n;i++)
    {
        while(l<=r&&a[q[r]]>=a[i])  r--;
        pre[i]=q[r];
        q[++r]=i;
    }
    l=1,r=0;
    q[++r]=n+1;
    for(int i=n;i>=1;i--)
    {
        while(l<=r&&a[q[r]]>=a[i])  r--;
        nxt[i]=q[r];
        q[++r]=i;
    }
    for(int i=1;i<=n;i++)  f[i]=f[pre[i]]+(ll)(i-pre[i])*(ll)a[i];
    for(int i=n;i>=1;i--)  g[i]=g[nxt[i]]+(ll)(nxt[i]-i)*(ll)a[i];
    for(int i=1;i<=n;i++)  pos[i][0]=i;
    for(int j=1;j<=20;j++)
      for(int i=1;i<=n;i++)  pos[i][j]=get(pos[i][j-1],pos[i+(1<<(j-1))][j-1]);
    for(int i=1;i<=n;i++)  lg[i]=(int)(log(i)/log(2));
    int block=sqrt(n);
    for(int i=1;i<=Q;i++)
    {
        b[i].l=read();b[i].r=read();b[i].id=i;
        b[i].bl=(b[i].l-1)/block+1;
    }
    sort(b+1,b+Q+1,cmp);
    int L=1,R=0;
    ll now=0;
    for(int i=1;i<=Q;i++)
    {
        while(R<b[i].r)
        {
            R++;
            now+=rig(R,L);
        }
        while(R>b[i].r)
        {
            now-=rig(R,L);
            R--;
        }
        while(L<b[i].l)
        {
            now-=lef(L,R);
            L++;
        }
        while(L>b[i].l)
        {
            L--;
            now+=lef(L,R);
        }
        ans[b[i].id]=now;
    }
    for(int i=1;i<=Q;i++)   printf("%lld\n",ans[i]);
    return 0;
}
```

---

## 作者：FZzzz (赞：8)

没人写猫树吗。

这是一个 $O(n\log n)+O(1)+O(n\log n)$ 的在线做法。

猫树，对于某个节点，先预处理出一个点到中点的答案。这可以使用单调栈求出。那么我们需要计算跨中点的贡献。

预处理出每个点到中点的最小值，并处理出这个最小值能延伸到右边哪里。这可以对左右两个区间进行一次归并得到。

贡献分为两种：最小值在左边的，我们在左端点处计算贡献；最小值在右边的，我们在右端点处计算贡献。

若查询左端点到中点的最小值不能延伸到右端点，则左边所有点都有到其延伸的右端点的完整的贡献。对于右半部分，左端点延伸的最远点左边的所有点都有完整的贡献，而右边到右端点的所有点都只有到左端点的贡献。这些东西都是可以拆开然后预处理出来的。

另一种情况的话同理可得。

代码实现上，这个到中点的前缀和很烦人，所以我分别保存的左边的答案和右边的答案。

另外这个做法其实是和那个 rmq 的做法本质相同，那个做法基本上相当于把这个做法搬到笛卡尔树上，然后就少了一堆特判……
```cpp
#include<cctype>
#include<cstdio>
using namespace std;
inline int readint(){
	int x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)&&c!='-') c=getchar();
	if(c=='-'){
		f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=1e5+5;
int n,q,a[maxn*2];
typedef long long ll;
int pos[maxn*2];
ll s1[25][maxn*2],s2l[25][maxn*2],s2r[25][maxn*2];
int mn[25][maxn*2],pp[25][maxn*2];
ll s3l[25][maxn*2],s3r[25][maxn*2];
ll s4l[25][maxn*2],s4r[25][maxn*2];
int st[maxn],top;
void build(int o,int l,int r,int d){
	if(l==r){
		pos[r]=o;
		return;
	}
	int mid=l+(r-l)/2;
	build(o*2,l,mid,d+1);
	build(o*2+1,mid+1,r,d+1);
	ll res=0;
	st[top=0]=mid+1;
	for(int i=mid;i>=l;i--){
		while(top&&a[i]<a[st[top]]){
			res-=1ll*a[st[top]]*(st[top-1]-st[top]);
			top--;
		}
		st[++top]=i;
		res+=1ll*a[i]*(st[top-1]-i);
		s1[d][i]=i==mid?res:s1[d][i+1]+res;
		mn[d][i]=a[st[1]];
	}
	res=0;
	st[top=0]=mid;
	for(int i=mid+1;i<=r;i++){
		while(top&&a[i]<a[st[top]]){
			res-=1ll*a[st[top]]*(st[top]-st[top-1]);
			top--;
		}
		st[++top]=i;
		res+=1ll*a[i]*(i-st[top-1]);
		s1[d][i]=i==mid+1?res:s1[d][i-1]+res;
		mn[d][i]=a[st[1]];
	}
	int cur=r;
	for(int i=l;i<=mid;i++){
		while(cur>mid&&mn[d][cur]<mn[d][i]) pp[d][cur--]=i;
		pp[d][i]=cur;
	}
	for(int i=mid+1;i<=cur;i++) pp[d][i]=mid+1;
	for(int i=mid;i>=l;i--){
		s2l[d][i]=s2l[d][i+1]+1ll*mn[d][i]*(pp[d][i]-mid);
		s3l[d][i]=s3l[d][i+1]+1ll*mn[d][i]*mid;
		s4l[d][i]=s4l[d][i+1]+mn[d][i];
	}
	for(int i=mid+1;i<=r;i++){
		s2r[d][i]=s2r[d][i-1]+1ll*mn[d][i]*(mid+1-pp[d][i]);
		s3r[d][i]=s3r[d][i-1]+1ll*mn[d][i]*(mid+1);
		s4r[d][i]=s4r[d][i-1]+mn[d][i];
	}
}
int lg[maxn*4];
int main(){
	#ifdef LOCAL
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
	#endif
	n=readint();
	q=readint();
	for(int i=1;i<=n;i++) a[i]=readint();
	int len=1;
	while(len<n) len*=2;
	build(1,1,len,1);
	for(int i=2;i<=n*4;i++) lg[i]=lg[i/2]+1;
	while(q--){
		int l,r;
		l=readint();
		r=readint();
		if(l==r){
			printf("%d\n",a[r]);
			continue;
		}
		int k=lg[pos[r]]-lg[pos[l]^pos[r]];
		ll ans=s1[k][l]+s1[k][r];
		if(pp[k][l]<r){
			ans+=s2l[k][l]+s2r[k][pp[k][l]];
			ans+=s3r[k][r]-s3r[k][pp[k][l]];
			ans-=(s4r[k][r]-s4r[k][pp[k][l]])*l;
		}
		else{
			ans+=s2r[k][r]+s2l[k][pp[k][r]];
			ans-=s3l[k][l]-s3l[k][pp[k][r]];
			ans+=(s4l[k][l]-s4l[k][pp[k][r]])*r;
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：Great_Influence (赞：8)

二维数点。

首先，可以预处理出$L_i$和$R_i$，表示$i$这个点最远能够拓展到哪里。

然后，以左端点为横坐标，右端点为纵坐标，建立坐标系。

这样的话，询问就转换为了一个矩形$[L_i,R_i]-[L_i,R_i]$。

与此同时，每个点的贡献区间也是一个矩形($[L_i,i]-[i,R_i]$)。

这样可以利用四叉树直接数，可以支持在线，时间复杂度为$O(n\log^2 n)$，可以被卡。

然而这道题并不需要在线做，我们考虑使用离线扫描线的方法。

将询问查分，变成询问两段前缀和。那么，就需要支持对一个矩形求前缀和。

直接将矩形拆成直线明显不行，但是可以发现，随着扫描线向右，矩形对面积的贡献为一个一次函数$x+L_i-1$。

那么，直接对于每个点，维护一次函数的两个系数就可以了。注意因为只需要用到区间加和区间询问，因此可以采用树状数组完成维护。

时间复杂度$O(n\log n)$，常数有点大。

代码:

```cpp
#include<bits/stdc++.h>
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
#define pb push_back
#define mp make_pair
#define Chkmax(a,b) a=a>b?a:b
#define Chkmin(a,b) a=a<b?a:b
#define mx(a,b) (a>b?a:b)
#define mn(a,b) (a<b?a:b)
typedef unsigned long long uint64;
typedef unsigned int uint32;
typedef long long ll;
using namespace std;

namespace IO
{
    const uint32 Buffsize=1<<15,Output=1<<23;
    static char Ch[Buffsize],*S=Ch,*T=Ch;
    inline char getc()
	{
		return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);
	}
    static char Out[Output],*nowps=Out;
    
    inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}

    template<typename T>inline void read(T&x)
	{
		x=0;static char ch;T f=1;
		for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;
		for(;isdigit(ch);ch=getc())x=x*10+(ch^48);
		x*=f;
	}

	template<typename T>inline void write(T x,char ch='\n')
	{
		if(!x)*nowps++='0';
		if(x<0)*nowps++='-',x=-x;
		static uint32 sta[111],tp;
		for(tp=0;x;x/=10)sta[++tp]=x%10;
		for(;tp;*nowps++=sta[tp--]^48);
		*nowps++=ch;
	}
}
using namespace IO;

inline void file()
{
#ifndef ONLINE_JUDGE
	FILE*WA=freopen("water.in","r",stdin);
	FILE*TER=freopen("water.out","w",stdout);
#endif
}

const int MAXN=1e5+7;

static int n,Q,a[MAXN],L[MAXN],R[MAXN];

static struct modi
{
	int tm,l,r;
	ll k,b;
	friend bool operator<(modi a,modi b)
	{return a.tm<b.tm;}
}p[MAXN<<1];

static struct quer
{
	int tm,l,r,id,w;
	friend bool operator<(quer a,quer b)
	{return a.tm<b.tm;}
}q[MAXN<<1];

inline void init()
{
	read(n),read(Q);
	Rep(i,1,n)read(a[i]);
	Rep(i,1,n)
	{
		L[i]=R[i]=i;
		for(register int j=i-1;j&&a[i]<a[j];j=L[j]-1)L[i]=L[j];
	}
	Repe(i,n,1)
		for(register int j=i+1;j<=n&&a[i]<=a[j];j=R[j]+1)R[i]=R[j];

	Rep(i,1,n)
	{
		p[2*i-1]=(modi){L[i],i,R[i],a[i],-1ll*a[i]*(L[i]-1)};
		p[i<<1]=(modi){i+1,i,R[i],-a[i],1ll*a[i]*i};
	}
	static int l,r;
	Rep(i,1,Q)
	{
		read(l),read(r);
		q[2*i-1]=(quer){l-1,l,r,i,-1};
		q[i<<1]=(quer){r,l,r,i,1};
	}
	sort(p+1,p+n*2+1),sort(q+1,q+Q*2+1);
}

struct BIT
{
	ll c[MAXN];

	inline void add(int u,ll v){for(;u<=n;u+=u&-u)c[u]+=v;}

	inline ll query(int u)
	{
		register ll sm;
		for(sm=0ll;u;u-=u&-u)sm+=c[u];
		return sm;
	}
};

struct BBIT
{
	BIT sm,cnt;

	inline void add(int l,int r,ll w)
	{
		cnt.add(l,w),sm.add(l,w*l);
		if(r<n)cnt.add(r+1,-w),sm.add(r+1,-w*(r+1));
	}

	inline ll query(int l,int r)
	{
		register ll X;
		X=(r+1)*cnt.query(r)-sm.query(r);
		X-=l*cnt.query(l-1)-sm.query(l-1);
		return X;
	}
}k,b;

static ll ans[MAXN];

inline void solve()
{
	int pos=1;
	Rep(i,1,Q*2)
	{
		while(pos<=n*2&&p[pos].tm<=q[i].tm)
		{
			k.add(p[pos].l,p[pos].r,p[pos].k),
			b.add(p[pos].l,p[pos].r,p[pos].b),++pos;
		}
		ans[q[i].id]+=q[i].w*(k.query(q[i].l,q[i].r)*q[i].tm+
				b.query(q[i].l,q[i].r));
	}
	Rep(i,1,Q)write(ans[i]);
	flush();
}

int main()
{
    init();
    solve();
    return 0;
}
```

---

## 作者：tzc_wk (赞：5)

[题面传送门](https://www.luogu.com.cn/problem/P3246)

~~这道题为什么我就没想出来呢/kk~~

对于每组询问 $[l,r]$，我们首先求出区间 $[l,r]$ 中最小值的位置 $x$，这个可以用 ST 表实现 $\mathcal O(n\log n)-\mathcal O(1)$ 维护，那么显然 $\forall l'\in[l,x],r'\in[x,r],\min\limits_{t\in[l',r']}a_t=a_x$，产生的贡献为 $(r-x+1)(x-l+1)a_x$，于是我们只用计算 $[x+1,r],[l,x-1]$ 两个区间的贡献即可。

这个东西怎么计算呢？考虑枚举区间的右端点 $R$，我们要计算 $[x+1,R],[x+2,R],\cdots,[R,R]$ 这 $R-x$ 个区间的最小值之和，我们记 $pre_x$ 为最大的满足 $y<x,a_y\le a_x$ 的 $y$——$pre_x$ 显然可以用单调栈在线性时间内求出。再记序列 $p_1,p_2,\cdots,p_k$ 满足 $p_0=0,p_k=R,\forall i\in[1,k],p_{i-1}=pre_{p_i}$ 的序列（说白了就是单调栈求完 $pre_R$ 之后，栈底到栈顶位置上元素的下标依次形成的序列），那么显然 $\forall i\in[1,k],l\in(p_{i-1},p_i]$ 都有 $\min\limits_{t=l}^xa_t=a_{p_i}$，也就是说 $a_{p_i}$ 位置会成为 $p_i-p_{i-1}$ 个位置的最小值。如果我们记 $f_R$ 为 $[1,R],[2,R],\cdots,[R,R]$ 的最小值之和，那么根据之前的推论有递推式 $f_R=f_{pre_R}+(R-pre_R)a_R$，可线性求出。

这里还有一个问题，那就是我们要计算 $[x+1,R],[x+2,R],\cdots,[R,R]$ 的贡献 instead of $[1,R],[2,R],\cdots,[R,R]$，也就是说我们要减去 $[1,R],[2,R],\cdots,[x,R]$ 的贡献。这东西又怎么求呢？很明显 $p$ 序列有一个性质就是必定 $\exist id\in[1,k]$ 满足 $p_{id}=x$，正确性显然，并且容易注意到 $\forall l\in[1,x],\min\limits_{t=l}^Ra_t=\min\limits_{t=l}^xa_t$，也就是说 $[1,R],[2,R],\cdots,[x,R]$ 的贡献其实就是 $[1,x],[2,x],\cdots,[x,x]$，因此只需拿 $f_R-f_x$ 就可以得到 $[x+1,R],[x+2,R],\cdots,[R,R]$ 的贡献。

故最终 $[x+1,r]$ 的贡献之和就是 $\sum\limits_{R=x+1}^rf_R-f_x$，这个显然前缀和随便算一下就行了。求 $[l,x-1]$ 的贡献也同理。

时间复杂度 $n\log n$，瓶颈在于 RMQ。

```cpp
const int MAXN=1e5;
const int LOG_N=18;
const int INF=0x3f3f3f3f;
int n,qu,a[MAXN+5],pre[MAXN+5],nxt[MAXN+5];
ll fl[MAXN+5],fr[MAXN+5],gl[MAXN+5],gr[MAXN+5];
pii st[MAXN+5][LOG_N+2];
pii query(int l,int r){
	int k=31-__builtin_clz(r-l+1);
	return min(st[l][k],st[r-(1<<k)+1][k]);
}
int main(){
	scanf("%d%d",&n,&qu);a[0]=a[n+1]=-INF;
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	stack<int> stk;stk.push(0);
	for(int i=1;i<=n;i++){
		while(!stk.empty()&&a[stk.top()]>=a[i]) stk.pop();
		pre[i]=stk.top();stk.push(i);
	} while(!stk.empty()) stk.pop();
	stk.push(n+1);
	for(int i=n;i;i--){
		while(!stk.empty()&&a[stk.top()]>=a[i]) stk.pop();
		nxt[i]=stk.top();stk.push(i);
	}
//	for(int i=1;i<=n;i++) printf("%d %d\n",pre[i],nxt[i]);
	for(int i=1;i<=n;i++) fl[i]=fl[pre[i]]+1ll*a[i]*(i-pre[i]),gl[i]=gl[i-1]+fl[i];
	for(int i=n;i;i--) fr[i]=fr[nxt[i]]+1ll*a[i]*(nxt[i]-i),gr[i]=gr[i+1]+fr[i];
	for(int i=1;i<=n;i++) st[i][0]=mp(a[i],i);
	for(int i=1;i<=LOG_N;i++) for(int j=1;j+(1<<i)-1<=n;j++)
		st[j][i]=min(st[j][i-1],st[j+(1<<i-1)][i-1]);
	while(qu--){
		int l,r;scanf("%d%d",&l,&r);int p=query(l,r).se;
		printf("%lld\n",1ll*a[p]*(p-l+1)*(r-p+1)+gr[l]-gr[p]-1ll*fr[p]*(p-l)+gl[r]-gl[p]-1ll*fl[p]*(r-p));
	}
	return 0;
}
```



---

## 作者：xryjr233 (赞：5)

首先,看到题目,应该可以想到莫队。

不考虑时间和空间,我们可以设计如下算法:

记$ansl_{l,r}$为以$l$为左端点,右端点在$[l,r]$范围内的区间的最小值之和;$ansr_{l,r}$为以$r$为右端点,左端点在$[l,r]$范围内的区间最小值之和。

记上一个比$a_i$小的数的**位置**为$s_i$,可以用单调栈求得。则$ansr_{l,r}=ansr_{l,s_r}+a_r\times(r-s_r)$,$ansl$同理。

然后看看如何莫队。

当从左边加入一个数时,答案加上$ansl_{l-1,r}$;

当从右边加入一个数时,答案加上$ansr_{l,r+1}$;

当从左边减去一个数时,答案减去$ansl_{l,r}$;

当从右边减去一个数时,答案减去$ansr_{l,r}$;

但是发现$ansl,ansr$数组的时间和空间都是$O(n^2)$的。

考虑优化(以$ansr$为例):

![图炸了QWQ](https://i.ibb.co/vB6VX51/BZOJ4540.png)

于是,改变$ansr$的定义,改为:

$ansr_i=ansr_{s_i}+a_i\times(i-s_i)$

当我们想询问以$r$为右端点,左端点在$[l,r]$范围内的答案时,答案$=ansr_r-ansr_l$(前提是$r$通过不停取$s_r$能够取到$l$。之后的询问方式保证了这一点)。

回到问题。

于是当从右边加入一个数时设**当前**区间的RMQ位于$id$,新产生的对答案的贡献为$(ans_r-ans_{id})+a_{id}\times(id-l+1)$。

第一个括号内即上图中绿色区域的贡献,加号之后为蓝色区域和RMQ位置的贡献。

时间复杂度降为莫队的$O(n\sqrt{n})$(RMQ可以O(1),见代码)。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int INF=2e9;
struct query{
    int l,r,blk,id;
}q[100010];
int n,m,bs,a[100010],d[100010],id[100010],sz,Log2[100010],mn[100010][20],mp[100010][20],l,r;
long long lans[100010],rans[100010],ans,prt[100010];
bool cmp(query x,query y){
    if(x.blk==y.blk){
        if(x.blk&1)return x.r>y.r;
        else return x.r<y.r;
    }else return x.blk<y.blk;
}
int RMQ(int L,int R){
    int l2=Log2[R-L+1];
    if(mn[L][l2]<mn[R-(1<<l2)+1][l2])return mp[L][l2];
    else return mp[R-(1<<l2)+1][l2];
}
void Insl(int x){
    int Id=RMQ(l,r);
    ans+=lans[l]-lans[Id]+1ll*a[Id]*(r-Id+1);
}
void Insr(int x){
    int Id=RMQ(l,r);
    ans+=rans[r]-rans[Id]+1ll*a[Id]*(Id-l+1);
}
void Dell(int x){
    int Id=RMQ(l,r);
    ans-=lans[l]-lans[Id]+1ll*a[Id]*(r-Id+1);
}
void Delr(int x){
    int Id=RMQ(l,r);
    ans-=rans[r]-rans[Id]+1ll*a[Id]*(Id-l+1);
}
int main(){
    scanf("%d%d",&n,&m);
    bs=sqrt(n);
    for(int i=1;i<=n;i++)Log2[i]=(1<<Log2[i-1]+1)>i?Log2[i-1]:Log2[i-1]+1;
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        mn[i][0]=a[i];
        mp[i][0]=i;
    }
    for(int i=1;i<=Log2[n];i++){
        mn[n+1][i]=INF;
        for(int j=1;j<=n;j++){
            if(mn[j][i-1]<mn[j+(1<<i-1)][i-1])mn[j][i]=mn[j][i-1],mp[j][i]=mp[j][i-1];
            else mn[j][i]=mn[j+(1<<i-1)][i-1],mp[j][i]=mp[j+(1<<i-1)][i-1];
        }
    }
    for(int i=1;i<=n;i++){
        while(sz>0&&d[sz]>=a[i])sz--;
        d[++sz]=a[i];
        id[sz]=i;
        rans[i]=1ll*a[i]*(i-id[sz-1])+rans[id[sz-1]];
    }
    for(int i=n;i>=1;i--){
        while(sz>0&&d[sz]>=a[i])sz--;
        d[++sz]=a[i];
        id[sz]=i;
        lans[i]=1ll*a[i]*(id[sz-1]-i)+lans[id[sz-1]];
    }
    for(int i=1;i<=m;i++){
        scanf("%d%d",&q[i].l,&q[i].r);
        q[i].blk=q[i].l/bs;
        q[i].id=i;
    }
    sort(q+1,q+m+1,cmp);
    l=1;
    r=0;
    ans=0;
    for(int i=1;i<=m;i++){
        while(l>q[i].l)l--,Insl(l);
        while(r<q[i].r)r++,Insr(r);
        while(l<q[i].l)Dell(l),l++;
        while(r>q[i].r)Delr(r),r--;
        prt[q[i].id]=ans;
    }
    for(int i=1;i<=m;i++)printf("%lld\n",prt[i]);
    return 0;
}
```





---

## 作者：Jμdge (赞：4)

很久之前做过这道题，但是跑得贼慢，现在用了可以被卡成 n m 的笛卡尔树做法，发现跑得贼快【雾

# noteskey

介绍一种复杂度错误然鹅在随机数据下跑得贼快的算法： 笛卡尔树

方法就是 $O~ n$ 构造一个笛卡尔树，然后同在线做法一样，就是每个点处理出  $fr[i],fl[i]$  表示以 i 为终止的前缀贡献和后缀贡献，并用 $gr[i],gl[i]$ 表示其前/后缀和


然后每次笛卡尔树找到区间最小值的位置，然后这个点会把整个区间分成两份，这样的话我们只要处理两份区间内的答案就好了

对于两份区间我们用 $fl~ fr~ gl~ gr$ 四个数组就可以处理出分别的贡献了





# code

这份代码在洛咕 4 是怎么也跑不进 150 ms 的


```
//by Judge
#include<cstdio>
#include<cstring>
#include<iostream>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(Rg int i=(a),I=(b)-1;i>I;--i)
#define ll long long
using namespace std;
const int M=1e5+3;
typedef int arr[M];
typedef ll ARR[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} char sr[1<<21],z[20];int CCF=-1,Z;
inline void Ot(){fwrite(sr,1,CCF+1,stdout),CCF=-1;}
inline void print(ll x,char chr='\n'){
	if(CCF>1<<20)Ot();if(x<0)sr[++CCF]=45,x=-x;
	while(z[++Z]=x%10+48,x/=10);
	while(sr[++CCF]=z[Z],--Z);sr[++CCF]=chr;
} int n,m,rt,top; arr a,s,lc,rc,pre,suf; ARR fl,fr,gl,gr;
inline int query(int l,int r){ //找到这个区间内的最小值位置 
	for(Rg int x=rt;;x=x>r?lc[x]:rc[x])
		if(l<=x&&x<=r) return x;
}
int main(){ n=read(),m=read(),a[0]=a[n+1]=2e9;
	fp(i,1,n){ a[i]=read();
		while(top&&a[s[top]]>=a[i]) lc[i]=s[top--]; 
        	rc[s[top]]=i,s[++top]=i;
	} rt=s[1],top=0;
	fp(i,1,n){
		while(top&&a[s[top]]>a[i]) suf[s[top--]]=i;
		pre[i]=s[top],s[++top]=i;
	}
	while(top) pre[s[top]]=s[top-1],suf[s[top--]]=n+1;
	fp(i,1,n) fr[i]=fr[pre[i]]+1ll*a[i]*(i-pre[i]),gr[i]=gr[i-1]+fr[i];
	fd(i,n,1) fl[i]=fl[suf[i]]+1ll*a[i]*(suf[i]-i),gl[i]=gl[i+1]+fl[i];
	fp(i,1,m){ Rg int l=read(),r=read(),p=query(l,r); //和在线时一样的思路 
		print(1ll*(p-l+1)*(r-p+1)*a[p]+gr[r]-gr[p]-fr[p]*(r-p)+gl[l]-gl[p]-1ll*fl[p]*(p-l));
	} return Ot(),0;
}
```




---

## 作者：金爷爷哈哈 (赞：4)

蒟蒻又来水题解辣


好像这是一道莫队的题，，，然而我为什么要用线段树呢？？？？？

（假装是因为我想练线段树嘿嘿）


题面的意思就是对于每个询问求一下子区间的最小值的和，，看到这题的第一感觉就是和bzoj有道rmq-sum的题好像啊，都可以离线用扫描法做ww。


大致的做法就是我们先用单调栈记录一下每个数i之前第一比它小的数的位置lef[i]。


然后再记录每一组询问，按照r升序排序。


我们再用一个变量now去维护目前的最右端，

初始 now=1。


线段树的每个节点记录以这个点为左端点，右端点最远到now的序列的最小值之和。


当now小于等于目前询问的右端点时，我们就把以now为右端点的所有区间在线段树里更新一下。

我们知道lef[now]+1~now的所有数中now一定是最小的，所以now加进来对于线段树上lef[now]+1~now的贡献都是a[now](now位置上的数)。

然后我们一直这样迭代下去（加完贡献之后now=lef[now]），直到now=0，就把now加进来的贡献算完了。

然后now++,直到now>目前询问的右端点


计算答案的话直接询问线段树上的区间和（ask[i].l~ask[i].r）就可以了（所以说我为什么脑抽写了个前缀和相减。。。。就当娱乐了反正能A  hh）


code：












































   







   



   














```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
struct node{
ll pos,v;
}s[100005];
struct ask{
ll l,r,num;
}a[100005];
bool cmp(ask x,ask y){
  return x.r<y.r;
}
ll n,m,top=0,b[100005],lef[100005];
ll sum[400005],add[400005],ans[100005];
ll le,ri,v;
void update(ll o,ll l,ll r){
   if(l>=le&&r<=ri){
       add[o]+=v,sum[o]+=v*(r-l+1);
       return;
   }
   ll mid=l+r>>1,lc=o<<1,rc=(o<<1)|1;
   if(le<=mid) update(lc,l,mid);
   if(ri>mid) update(rc,mid+1,r);
   sum[o]=sum[lc]+sum[rc]+add[o]*(r-l+1);
}
inline void work(ll x){
  while(x){
     ri=x,le=lef[x]+1,v=b[x];
     update(1,1,n);
     x=lef[x];
  }
}
ll query(ll o,ll l,ll r,ll addv){
   if(l>=le&&r<=ri) return(addv*(r-l+1)+sum[o]);
   ll mid=l+r>>1,lc=o<<1,rc=(o<<1)|1,ansd=0;
   if(le<=mid) ansd+=query(lc,l,mid,addv+add[o]);
   if(ri>mid) ansd+=query(rc,mid+1,r,addv+add[o]);
   return ansd;
}
int main(){
   scanf("%lld%lld",&n,&m);
   s[++top]=(node){0,-(1<<30)};
   for(ll i=1;i<=n;i++){
      scanf("%lld",b+i);
      while(s[top].v>=b[i]) top--;
      lef[i]=s[top].pos;
      s[++top]=(node){i,b[i]};
   }
   for(ll i=1;i<=m;i++) scanf("%lld%lld",&a[i].l,&a[i].r),a[i].num=i;
   sort(a+1,a+m+1,cmp);
   ll now=1;
   for(ll i=1;i<=m;i++){
      while(now<=a[i].r) work(now),now++;
      le=1,ri=a[i].r;
      ans[a[i].num]=query(1,1,n,0);
      if(a[i].l>1){
         ri=a[i].l-1;
         ans[a[i].num]-=query(1,1,n,0);
      }
   }
   for(ll i=1;i<=m;i++) printf("%lld\n",ans[i]);
//   for(ll i=1;i<=n;i++) cout<<lef[i]<<' ';
   return 0;
}
```

---

## 作者：Huami360 (赞：4)

介绍一种O(n√n)的算法：莫队


莫队的难点就在于状态转移，怎么通过[l,r]的答案推出[l,r+1]的答案。


考虑找到[l,r+1]里的最小值的位置（ST表实现），记为pos。


[l,r+1]相对于[l,r]其实就多了r-l+2个包括r+1的子序列，


那么[l,pos]的对答案的贡献就等于(pos-l+1)\*a[pos]


那么怎么求[pos+1,r]的贡献呢


这里引入一个类似前缀和的东西，


我们用last[i]表示a[i]左边第一个比a[i]小的数的位置，next[i]表示右边，


这个过程显然可以用单调栈O(n)实现


然后开2个数组suml,sumr。


suml[i]表示[1,i]的贡献，那么suml[i]可通过suml[i]=suml[last[i]]+(i-last[i])\*a[i]得到。


sumr同理。


然后就是莫队的模板了。


```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>
#include <set>
#include <map>
#include <vector>
#include <stack>
#include <list>
#define rep(i,m,n) for(int i=m;i<=n;++i)
#define dop(i,m,n) for(int i=m;i>=n;--i)
#define lowbit(x) (x&(-x))
#define ll long long
#define INF 2147483647
using namespace std;
inline int read(){
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
inline void write(int x){
    if(x<0) x=-x,putchar('-');
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
const int maxn=1000010;
const int maxm=1000010;
int g,last[maxn],n,m,a[maxn],i,Log[maxn],f[maxn][22],Next[maxn],l=1,r=1;
ll ans,Ans[maxm],suml[maxn],sumr[maxn];
inline int get(int x){ //分块
    return (x-1)/g+1;
}
struct STACK{    //手写栈
    int s[maxn],tall;
    STACK(){memset(s,0,sizeof(s));tall=0;}
    inline void push(int x){s[++tall]=x;}
    inline void pop(){--tall;}
    inline int top(){return s[tall];}
}s;
struct ASK{   //离线算法，记录询问
    int l,r,lk,id;
    bool operator < (const ASK &A) const{
         return lk==A.lk?r<A.r:lk<A.lk;
    }
}A[maxm];
inline int Query(int l,int r){   //ST表（记录位置版）查询
    int k=Log[r-l+1],pos=r-(1<<k)+1;
    return a[f[l][k]]>a[f[pos][k]]?f[pos][k]:f[l][k];
}
inline void updata(int mode){  //莫队更新状态
    if(mode==1) {int pos=Query(l,r);ans+=(pos-l+1)*a[pos]+suml[r]-suml[pos];}  //l,r+1
    if(mode==2) {int pos=Query(l,r);ans-=(pos-l+1)*a[pos]+suml[r]-suml[pos];}  //l,r-1
    if(mode==3) {int pos=Query(l,r);ans-=(r-pos+1)*a[pos]+sumr[l]-sumr[pos];}  //l+1,r
    if(mode==4) {int pos=Query(l,r);ans+=(r-pos+1)*a[pos]+sumr[l]-sumr[pos];}  //l-1,r
}
int main(){
     g=sqrt(n=read());m=read();Log[0]=-1;
     rep(i,1,n) a[i]=read(),Log[i]=Log[i/2]+1,f[i][0]=i;
     rep(i,1,16)
        rep(j,1,n){
           int pos=j+(1<<(i-1));
           f[j][i]=a[f[j][i-1]]>a[f[pos][i-1]]?f[pos][i-1]:f[j][i-1];
        }
     rep(i,1,n){  //单调栈求last和Next
        while(s.tall&&a[i]<a[s.top()]) Next[s.top()]=i,s.pop();
        last[i]=s.top();
        s.push(i);
     }
     while(s.tall) Next[s.top()]=n+1,s.pop();
     rep(i,1,m){
        A[i].l=read();A[i].r=read();
        A[i].lk=get(A[i].l);A[i].id=i;
     }
     rep(i,1,n) suml[i]=suml[last[i]]+(ll)(i-last[i])*a[i];    //前缀和
     dop(i,n,1) sumr[i]=sumr[Next[i]]+(ll)(Next[i]-i)*a[i];
     sort(A+1,A+m+1);ans=a[1];
     rep(i,1,m){
        while(r<A[i].r) ++r,updata(1);
        while(l>A[i].l) --l,updata(4);
        while(r>A[i].r) updata(2),--r;
        while(l<A[i].l) updata(3),++l;
        Ans[A[i].id]=ans;
     }
     rep(i,1,m) printf("%lld\n",Ans[i]);
     return 0;
}
```

---

## 作者：Demoe (赞：3)

### [题目传送门](https://www.luogu.com.cn/problem/P3246)

## 题意

- 给定一个长度为 $n$ 的正整数序列，有 $q$ 次询问。

- 每次询问给定区间 $[l,r]$ ，求给定区间的**所有子段中的最小值的和**。

## Sol

~~比模板简单的莫队二次离线~~

题目中要求区间最小，因为问询有多次且无修改，先尝试采用 $\text{ST表}$，预处理 $O(n \log n)$，问询 $O(1)$。（没用也没事（雾））

可离线的区间问询，显然**莫队**。

但我们发现莫队的话，复杂度已经 $O(n \sqrt n)$ 了，于是便要求更新操作是 $O(1)$ 的。

我们来探讨一下**更新操作**。

我们只说右端点右移操作更新，其他以此类推。

设新区间为 $[l,r]$，我们更新的答案就是 $\sum\limits_{i=l}^rmin[i,r]$。

设 $min[l,r]=a_x$。

#### 因为不确定 $x$ 的位置进行分类讨论。

1. $i \le x$

   $min[i,r]=a_x$，所以对答案的总贡献是 $(x-l+1) \times a_x$。

2. $1 \le i \le r$ 

   定义 $sumL_i=\sum\limits_{j=1}^imin[j,i]$。

   我们可得贡献为 $sumL_r$。

3. $1 \le i \le x$

   因为 $a_x=min[l,r]$。

   所以 $min[i,r]=min[i,x]$。

   所以贡献即为 $sumL_x$。

综上，更新答案为 $(x-l+1) \times a_x-sumL_x+sumL_r$。

那么我们就要计算 $sumL_i,sumR_i$。

设 $lst_i$ $=$ $i$ 之前第一个小于 $a[i]$ 的值的位置。

当右端点为 $i$ 时，进行分讨。

1. $j  > lst_i$ 

   $min[j,i]=a[i]$。

2. $j \le lst_i$

   $sumL_i=sumL_{lst_i}+(i-lst_i) \times a_i$。

然后我们就发现还要计算 $lst_i,nxt_i$。（$nxt_i$ 就是反过来。）

设 $x < y$，$a_x \ge a_y$。

则当 $i > y$ 时，$x$ 对其无贡献。

所以我们用单调~~队列~~栈维护。

当且仅当 $a_i \le a_{q_{r-1}}$ 时，$nxt_{q_{r-1}}=i$，并踢出 $q_{r-1}$。

决策：$lst_i=q_{r-1}$。

#### 现在你什么都有了。/cy

你就可以手切这题啦。/cy

```cpp
/*
***
还要继续努力
成为一名烤咕学家哦
***
*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1e5+5,INF=0x3f3f3f3f;
ll n,m,k,a[N],ans[N],len,qu[N],tot,l,r,f[N][25],Log[N],suml[N],sumr[N],lst[N],nxt[N]; 
struct question{ll l,r,id,pos;}q[N];
template <typename T> void rd(T &x){
	ll fl=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') fl=-fl;
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';
	x*=fl;
}
void wr(ll x){
	if(x<0) x=-x,putchar('-');
	if(x<10) putchar(x+'0');
	if(x>9) wr(x/10),putchar(x%10+'0');
}
bool cmp(question x,question y){
	if(x.pos!=y.pos) return x.pos<y.pos;
	if(x.pos&1) return x.r<y.r;
	return x.r>y.r;
}
inline ll RMQ(ll L,ll R){
    ll val=Log[R-L+1];
	ll to=R-(1<<val)+1;
    return (a[f[L][val]]>a[f[to][val]]?f[to][val]:f[L][val]);
}
inline void upd(ll op){
	ll x=RMQ(l,r);
	if(op==1) tot+=(r-x+1)*a[x]+sumr[l]-sumr[x];
	if(op==2) tot+=(x-l+1)*a[x]+suml[r]-suml[x];
	if(op==3) tot-=(r-x+1)*a[x]+sumr[l]-sumr[x];
	if(op==4) tot-=(x-l+1)*a[x]+suml[r]-suml[x];
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	rd(n);rd(m);
	memset(a,INF,sizeof(a));
	len=(ll)sqrt(n);qu[0]=0;l=0,r=1;Log[0]=-1;
	for(ll i=1;i<=n;i++) rd(a[i]),Log[i]=Log[i/2]+1,f[i][0]=i;
	for(ll i=1;i<=m;i++) rd(q[i].l),rd(q[i].r),q[i].id=i,q[i].pos=(q[i].l-1)/len+1;
	for(ll i=1;i<25;i++)
		for(ll j=1;j<=n-(1<<(i-1));j++){
			ll to=j+(1<<(i-1));
			f[j][i]=(a[f[j][i-1]]>a[f[to][i-1]]?f[to][i-1]:f[j][i-1]);
		}
	for(ll i=1;i<=n;i++){
		for(;l<r&&a[i]<a[qu[r-1]];r--) nxt[qu[r-1]]=i;
		lst[i]=qu[r-1];
		qu[r++]=i;
	}
	for(;l<r;r--) nxt[qu[r-1]]=n+1;
	for(ll i=1;i<=n;i++) suml[i]=suml[lst[i]]+(i-lst[i])*a[i];
	for(ll i=n;i>0;i--) sumr[i]=sumr[nxt[i]]+(nxt[i]-i)*a[i];
	sort(q+1,q+m+1,cmp);l=1;r=0;
	for(ll i=1;i<=m;i++){
		while(l>q[i].l) --l,upd(1);
		while(r<q[i].r) ++r,upd(2);
		while(l<q[i].l) upd(3),l++;
		while(r>q[i].r) upd(4),r--;
		ans[q[i].id]=tot;
	}
	for(ll i=1;i<=m;i++) wr(ans[i]),puts("");
	return 0;
}
```

真是令人高兴呢。/cy

---

## 作者：Joky_02 (赞：2)

~~行吧行吧我copy一遍原来的总可以了吧==~~

（以上与文章无关，以下内容来自本人的[csdn博客](https://blog.csdn.net/Joky_2002/article/details/85000739)）


## [题目链接](https://lydsy.com/JudgeOnline/problem.php?id=4540) ##

好久以前写的东西了==，现在已经记不起来当时线段树咋写的了
于是$YY$出一个$CDQ$的做法
好像还没人发过$CDQ$的题解？~~抢个fb~~

首先先把给的序列预处理一把
记$L[i]$为 $i$左边小等$a[i]$的位置$+1$
同理有$R[i]$为 $i$右边小等$a[i]$的位置$-1$

然后上一把二维数点~~叫我二维数点大师~~

显然可以发现，一个以$(L[i],i)$为左下角的，以$(i,R[i])$为右上角的矩形会贡献$a[i]$的答案（也就是说，这个矩形里全是$a[i]$

然后询问就相当于查询一个以$(l,l)$为左下角的，以$(r,r)$为右上角的矩形和

考虑操作和询问都具有前缀性，于是可以把一个矩形拆成四个点
具体来说，把操作$(xl,xr,yl,yr)$拆成$(xl,yl),(xl,yr + 1),(xr + 1,yl),(xr + 1,yr + 1)$

把询问$(xl,xr,yl,yr)$拆成$(xr,yr),(xl - 1,yr),(xr,yl - 1),(xl - 1,yl - 1)$

然后填填正负号
答案即为询问和操作的四个点两两贡献的和

当然直接计算两两贡献是$O(n ^ 2)$的

考虑$CDQ$分治

就是先把询问和操作都按$x$排序，然后考虑计算完贡献后归并$y$上来

然后考虑一件事情：如何计算贡献？

如果说直接计算贡献的话，就是$val[i] * val[j].val * abs(x[i] - x[j] + 1) * abs(y[i] - y[j] + 1)$
（也就是把以$i$和$j$形成的矩形大小乘以权值，其中$i$为操作，$j$为询问，$val$是填上正负号的权值）

当然这样直接做是不行的，考虑怎么利用$x[i] < x[j]$并且$y$有序的性质

考虑某个$j$点计算完答案长啥样子：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20181214113335950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pva3lfMjAwMg==,size_16,color_FFFFFF,t_70)

然后我们现在要把他变成

![在这里插入图片描述](https://img-blog.csdnimg.cn/2018121411351670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pva3lfMjAwMg==,size_16,color_FFFFFF,t_70)

类似这样的形状

记一个$len$和$wid$，分别表示$i_1,i_2,i_3$到$j$的长和宽的带权和

具体而言就是
![在这里插入图片描述](https://img-blog.csdnimg.cn/20181214113948168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pva3lfMjAwMg==,size_16,color_FFFFFF,t_70)

（大概是这个意思，只不过要带权

那我们每次先把原来的矩形向左向右扩一下，再向上向下扩一下，就可以了

用$len$和$wid$表现出来就是
$now += wid * (x[i] - x[j - 1]); len += sum * (x[j] - x[j - 1]);$
$now += len * (y[i] - y[j - 1]); wid += sum * (y[i] - y[j - 1]);$
$sum$表示当前所有点的权值和
当然可能会出现新的点（也就是原来不在$j$的范围内，现在出现在$j + 1$的范围内了），那么这个直接加起来就好了

最后要开$\_int128$，当然因为博主比较懒，$long\ long$交了一个$80pts$的就没再管了

代码（$80pts$）
```
#include<cstdio>
#include<cmath>
#include<queue>
#include<stack>
#include<vector>
#include<algorithm>
#include<cstring>
using namespace std;

typedef long long LL;

const int maxn = 1000010;

struct node{
	int x,y,val,typ,id;
}q[maxn],tmp[maxn];

int n,m,N,L[maxn],R[maxn],a[maxn];
int stk[maxn],top;
LL ans[maxn];

inline LL getint()
{
	LL ret = 0,f = 1;
	char c = getchar();
	while (c < '0' || c > '9')
	{
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9')
		ret = ret * 10 + c - '0',c = getchar();
	return ret * f;
}

inline int cmp(node a,node b)
{
	return a.x < b.x || (a.x == b.x && a.y < b.y) || (a.x == b.x && a.y == b.y && a.typ < b.typ);
}

inline void solve(int l,int r)
{
	if (l == r) return;
	int mid = l + r >> 1;
	solve(l,mid); solve(mid + 1,r);
	int j = l,pre = 0; LL now = 0,len = 0,wid = 0,cnt = 0;
	for (int i = mid + 1; i <= r; i++)
	{
		if (!q[i].typ) continue;
		now += wid * (q[i].x - q[pre].x); len += 1ll * cnt * (q[i].x - q[pre].x);
		now += len * (q[i].y - q[pre].y); wid += 1ll * cnt * (q[i].y - q[pre].y);
		pre = i;
		while (j <= mid && q[j].y <= q[i].y)
		{
			if (q[j].typ) {j++; continue;}
			len += 1ll * q[j].val * (q[i].x - q[j].x + 1); 
			wid += 1ll * q[j].val * (q[i].y - q[j].y + 1);
			now += 1ll * q[j].val * (q[i].x - q[j].x + 1) * (q[i].y - q[j].y + 1);
			cnt += q[j].val; j++;
		}
		ans[q[i].id] += q[i].val * now;
	}

	int u = l,v = mid + 1,cur = l - 1;
	while (u <= mid && v <= r)
	{
		if (q[u].y <= q[v].y) tmp[++cur] = q[u++];
		else tmp[++cur] = q[v++];
	}
	for (int i = u; i <= mid; i++) tmp[++cur] = q[i];
	for (int i = v; i <= r; i++) tmp[++cur] = q[i];
	for (int i = l; i <= r; i++) q[i] = tmp[i];
}

inline void split(int xl,int xr,int yl,int yr,int typ,int id)
{
	if (typ == 0)
	{
		q[++N] = (node){xl,yl,a[id],0,id};
		q[++N] = (node){xl,yr + 1,-a[id],0,id};
		q[++N] = (node){xr + 1,yl,-a[id],0,id};
		q[++N] = (node){xr + 1,yr + 1,a[id],0,id};
	}
	else 
	{
		q[++N] = (node){xr,yr,1,1,id};
		q[++N] = (node){xl - 1,yr,-1,1,id};
		q[++N] = (node){xr,yl - 1,-1,1,id};
		q[++N] = (node){xl - 1,yl - 1,1,1,id};
	}
}

int main()
{
	#ifdef AMC
		freopen("AMC1.txt","r",stdin);
		freopen("AMC2.txt","w",stdout);
	#endif
	n = getint(); m = getint();
	for (int i = 1; i <= n; i++) a[i] = getint();
	for (int i = 1; i <= n; i++)
	{
		while (top && a[stk[top]] > a[i]) top--;
		L[i] = stk[top] + 1;
		stk[++top] = i;
	}

	top = 0;
	for (int i = n; i >= 1; i--)
	{
		while (top && a[stk[top]] > a[i]) top--;
		if (top) R[i] = stk[top] - 1; else R[i] = n;
		stk[++top] = i;
	}

	for (int i = 1; i <= n; i++)
		split(L[i],i,i,R[i],0,i);
	
	for (int i = 1; i <= m; i++)
	{
		int l = getint(),r = getint();
		split(l,r,l,r,1,i);
	}

	sort(q + 1,q + N + 1,cmp);

	solve(1,N);

	for (int i = 1; i <= m; i++)
		printf("%lld\n",ans[i]);
	return 0;
}
```
非常好写并且短233333333

---

## 作者：Prean (赞：2)

~~此题的这种做法极度考察代码能力~~

题意：求一个区间中所有子区间的 $\min$ 之和，多次询问。

粗略看了一下题解好像有几个都是没有优化过的这个做法（

看到 $\min$ 第一步就是建笛卡尔树啊。

根据一个套路，预处理 $L[i]$ 和 $R[i]$ 表示节点 $i$ 的子树代表序列上的一个区间 $[L[i],R[i]]$。

答案很明显是 $\sum_{i=l}^ra[i]\times(\min(R[i],r)-i+1)\times(i-\max(L[i],l)+1)$。

开始大力拆式子：
$$\sum_{i=l}^ra[i]\times(\min(R[i]+1,r+1)-i)\times(i-\max(L[i]-1,l-1))$$
$$(\sum_{i=l}^ra[i]\min(R[i]+1,r+1)\max(L[i]-1,l-1))$$
$$+(\sum_{i=l}^ri\times a[i]\times(\max(L[i]-1,l-1)+\min(R[i]+1,r+1)))$$
$$-(\sum_{i=l}^ri^2\times a[i])$$
第二个 $\sum$ 和第三个 $\sum$ 都相当平凡。

第二个 $\sum$ 的具体做法是，将 $\min$ 和 $\max$ 分开，然后将询问离线到 $l-1$ 和 $r+1$ 上，然后维护每一个位置现在是 $L[i]-1$ 还是 $l-1$，树状数组可以做到 $O(m\log n)$。

第一个 $\sum$ 有点儿像区间二维数点，树套树可以做到 $O(m\log^2n)$，实际上有办法优化到 $O(m\log n)$。

考虑整个序列减去前缀和后缀的贡献。注意到对于 $i\in[1,L)$ 有 $l[i]\leq l$ 和对于 $i\in(R,n]$ 有 $R[i]\geq r$，能够得到：
$$\sum_{i=1}^na[i]\min(R[i]+1,r+1)\max(L[i]-1,l-1)$$
$$-(\sum_{i=1}^{l-1}a[i](l-1)\min(R[i]+1,r+1)+\sum_{i=r+1}^na[i](r+1)\max(L[i]-1,l-1))$$
后面两个使用前面第三个 $\sum$ 的做法即可，第一个直接使用主席树即可。

使用前缀和优化一下可以做到只查询一次主席树。

复杂度 $O((n+m)\log n)$。

为什么这是对的？

考虑建立笛卡尔树的过程，是弹出一堆元素再加入一个元素。

这个操作的本质是 **固定弹出元素所对应的区间，并且令栈内元素的右端点右移**。

考虑从一个区间的笛卡尔树扩展到整个序列的笛卡尔树，可以通过上述的插入操作来完成。

因此这样每个节点所对应的区间一定是正确的。

还有一种理解，是区间的笛卡尔树相当于对序列笛卡尔树建立虚树。
```cpp
#include<cstdio>
#include<vector>
typedef long long ull;
const int M=1e5+5;
int n,m,l[M],r[M],a[M],L[M],R[M],ls[M],rs[M],siz[M];int top,stk[M];ull ans[M];
ull BIT1[M],BIT2[M];std::vector<int>idL[M],idR[M];
struct Query{
	int L,R,id,opt;
};
inline void Mdf1(int x,const ull&V){
	while(x<=n)BIT1[x]+=V,x+=x&-x;
}
inline void Mdf2(int x,const ull&V){
	while(x<=n)BIT2[x]+=V,x+=x&-x;
}
inline ull Qry1(int x){
	ull ans(0);
	while(x>=1)ans+=BIT1[x],x^=x&-x;
	return ans;
}
inline ull Qry2(int x){
	ull ans(0);
	while(x>=1)ans+=BIT2[x],x^=x&-x;
	return ans;
}
namespace Sol1{
//\sum[l,r] i*Vi*(max(L[i]-1,l-1)+min(R[i]+1,r+1))
	std::vector<Query>Q1[M],Q2[M];
	inline void init(){
		for(int i=1;i<=m;++i){
			Q1[r[i]+1].push_back((Query){l[i],r[i],i,1});
			Q2[l[i]-1].push_back((Query){l[i],r[i],i,1});
		}
	}
	inline void Solve(){
		for(int i=1;i<=n;++i)BIT1[i]=BIT2[i]=0;
		for(int i=1;i<=n;++i)Mdf1(i,1ull*i*a[i]);
		for(int i=1;i<=n+1;++i){
			for(int&x:idR[i-1])Mdf1(x,-1ull*x*a[x]),Mdf2(x,1ull*x*a[x]*(R[x]+1));
			for(Query&x:Q1[i])ans[x.id]+=x.opt*(1ull*(x.R+1)*(Qry1(x.R)-Qry1(x.L-1))+(Qry2(x.R)-Qry2(x.L-1)));
		}
		for(int i=1;i<=n;++i)BIT1[i]=BIT2[i]=0;
		for(int i=1;i<=n;++i)Mdf1(i,1ull*i*a[i]);
		for(int i=n;i>=0;--i){
			for(int&x:idL[i+1])Mdf1(x,-1ull*x*a[x]),Mdf2(x,1ull*x*a[x]*(L[x]-1));
			for(Query&x:Q2[i])ans[x.id]+=x.opt*(1ull*(x.L-1)*(Qry1(x.R)-Qry1(x.L-1))+(Qry2(x.R)-Qry2(x.L-1)));
		}
	}
}
namespace Sol2{
//\sum[1,l) Vi*(l-1)*min(R[i]+1,r+1)
//\sum(r,n] Vi*(r+1)*max(L[i]-1,l-1)
	std::vector<Query>Q1[M],Q2[M];
	inline void init(){
		for(int i=1;i<=m;++i){
			Q1[r[i]+1].push_back((Query){l[i],r[i],i,l[i]-1});
			Q2[l[i]-1].push_back((Query){l[i],r[i],i,r[i]+1});
		}
	}
	inline void Solve(){
		for(int i=1;i<=n;++i)BIT1[i]=BIT2[i]=0;
		for(int i=1;i<=n;++i)Mdf1(i,a[i]);
		for(int i=1;i<=n+1;++i){
			for(int&x:idR[i-1])Mdf1(x,-a[x]),Mdf2(x,1ull*a[x]*(R[x]+1));
			for(Query&x:Q1[i])ans[x.id]+=x.opt*(1ull*(x.R+1)*(Qry1(x.L-1)-Qry1(0))+(Qry2(x.L-1)-Qry2(0)));
		}
		for(int i=1;i<=n;++i)BIT1[i]=BIT2[i]=0;
		for(int i=1;i<=n;++i)Mdf1(i,a[i]);
		for(int i=n;i>=0;--i){
			for(int&x:idL[i+1])Mdf1(x,-a[x]),Mdf2(x,1ull*a[x]*(L[x]-1));
			for(Query&x:Q2[i])ans[x.id]+=x.opt*(1ull*(x.L-1)*(Qry1(n)-Qry1(x.R))+(Qry2(n)-Qry2(x.R)));
		}
	}
}
namespace Sol3{
//\sum[1,n] i*Vi*min(R[i]+1,r+1)*max(L[i]-1,l-1)
	struct Node{
		int L,R;ull sum1,sum2,sum3,sum4;
	}t[M*20];
	int tot,root[M];ull T1,T2,T3,T4,S1x[M],S1y[M],S2x[M],S2y[M],S3x[M],S3y[M],S4x[M],S4y[M];ull S1,S2,S3,S4;
	inline int Mdf(int u,const int&x,const ull&V1,const ull&V2,const ull&V3,const ull&V4,const int&L=1,const int&R=n){
		const int id=++tot;
		t[id]=t[u];
		t[id].sum1+=V1;
		t[id].sum2+=V2;
		t[id].sum3+=V3;
		t[id].sum4+=V4;
		if(L<R){
			const int mid=L+R>>1;
			if(x<=mid)t[id].L=Mdf(t[u].L,x,V1,V2,V3,V4,L,mid);
			else t[id].R=Mdf(t[u].R,x,V1,V2,V3,V4,mid+1,R);
		}
		return id;
	}
	inline void Qry(int q,int p,const int&l,const int&r,const int&L=1,const int&R=n){
		if(l>R||L>r||!p)return;
		if(l<=L&&R<=r){
			S1+=t[p].sum1-t[q].sum1;
			S2+=t[p].sum2-t[q].sum2;
			S3+=t[p].sum3-t[q].sum3;
			S4+=t[p].sum4-t[q].sum4;
			return;
		}
		const int mid=L+R>>1;
		Qry(t[q].L,t[p].L,l,r,L,mid);Qry(t[q].R,t[p].R,l,r,mid+1,R);
	}
	inline void init(){
		for(int i=1;i<=n;++i){
			root[i]=root[i-1];
			for(int&ID:idR[i]){
				const ull&V=a[ID];const int&l=L[ID]-1,&r=R[ID]+1;
				root[i]=Mdf(root[i],L[ID],V,V*l,V*r,V*l*r);
			}
		}
		for(int i=1;i<=n;++i){
			const ull&V=a[i];const int&l=L[i]-1,&r=R[i]+1;
			S1x[R[i]]+=V;S1y[L[i]]+=V;T1+=V;
			S2x[R[i]]+=V*l;S2y[L[i]]+=V*l;T2+=V*l;
			S3x[R[i]]+=V*r;S3y[L[i]]+=V*r;T3+=V*r;
			S4x[R[i]]+=V*l*r;S4y[L[i]]+=V*l*r;T4+=V*l*r;
		}
		for(int i=1;i<=n;++i){
			S1x[i]+=S1x[i-1];S1y[i]+=S1y[i-1];
			S2x[i]+=S2x[i-1];S2y[i]+=S2y[i-1];
			S3x[i]+=S3x[i-1];S3y[i]+=S3y[i-1];
			S4x[i]+=S4x[i-1];S4y[i]+=S4y[i-1];
		}
	}
	inline void Solve(){
		for(int i=1;i<=m;++i){
			const int&L=l[i],&R=r[i];
			S1=S2=S3=S4=0;Qry(root[0],root[R],1,L);
			ans[i]-=
			1ull*S3*(L-1)+
			1ull*(S4x[R]-S4)+
			1ull*(S1y[L]-S1)*(R+1)*(L-1)+
			1ull*(T2-S2x[R]-S2y[L]+S2)*(R+1);
		}
	}
}
namespace Sol4{
//\sum[l,r] i^2*Vi
	ull sum[M];
	inline void init(){
		for(int i=1;i<=n;++i)sum[i]=sum[i-1]+1ull*i*i*a[i];
	}
	inline void Solve(){
		for(int i=1;i<=m;++i){
			ans[i]-=sum[r[i]]-sum[l[i]-1];
		}
	}
}
inline void Build(){
	for(int i=1;i<=n;++i){
		if(top&&a[i]<=a[stk[top]]){
			while(top&&a[i]<=a[stk[top]])--top;
			ls[i]=stk[top+1];
		}
		if(top)rs[stk[top]]=i;stk[++top]=i;
	}
}
inline void DFS(const int&u){
	if(ls[u])DFS(ls[u]);if(rs[u])DFS(rs[u]);
	L[u]=u-siz[ls[u]];R[u]=u+siz[rs[u]];
	siz[u]=siz[ls[u]]+siz[rs[u]]+1;
}
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)scanf("%d",a+i);Build();DFS(stk[1]);
	for(int i=1;i<=n;++i){
		idL[L[i]].push_back(i);
		idR[R[i]].push_back(i);
	}
	for(int i=1;i<=m;++i)scanf("%d%d",l+i,r+i);
	Sol1::init();Sol2::init();Sol3::init();Sol4::init();
	Sol1::Solve();Sol2::Solve();Sol3::Solve();Sol4::Solve();
	for(int i=1;i<=m;++i)printf("%lld\n",ans[i]);
}
```

---

## 作者：PragmaGCC (赞：2)

题目要求的是所有子区间的最小值，所以一个数显然很有可能被算很多次。我们考虑怎么算贡献：

对于一个区间 $[L,R]$，我们找到这个区间的最小值 $x$。那么，对于左端点在左半部分，右端点在右半部分的子区间，其答案必定是 $x$。

现在要统计的就是左半部分的答案和右半部分的答案。由于左右地位对称，我们只考虑右半部分。

我们令 $pre_i$ 表示 $i$ 前面第一个小于 $a_i$ 的数的位置，$f_i$ 为以 $i$ 为右端点的答案。

因为 $pre_i$ 是第一个更小的，所以我们可以列出递推式：$f_i = f_{pre_i} + (i - pre_i) \times a_i$。

由于最终必定存在一个点，其 $pre=x$，所以将其展开得到区间 $[l,r]$ 的答案为 $f_r-f_{l-1}$。

对 $f$ 做前缀和即可求出整个右半部分的答案。

至于左半部分同理。

算法瓶颈在于 RMQ，可以用 Four Russian 优化。

```cpp
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <stack>
using namespace std;
const int N = 1e5 + 5;
long long a[N];
int n, m;
#define isdigit(ch) (ch >= '0' && ch <= '9')
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define Debug(x)                                                               \
    debug("Passing [%s] in LINE %d , %s=%d\n", __FUNCTION__, __LINE__, #x, x)
char buf[1 << 23], *p1 = buf, *p2 = buf;
#define getchar()                                                              \
    (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++ )
inline int read() {
    int x = 0, f = 1;
    char ch = getchar();
    while (!isdigit(ch)) {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (isdigit(ch))
        x = x * 10 + (ch ^ 48), ch = getchar();
    return x * f;
}
namespace FR {
int st[N / 100][30], lg[N];
int pre[N], suf[N];
int pos[N];
int block;
inline int bf(int l, int r) {
    int p = l;
    for (int i = l; i <= r; i++)
        if (a[i] < a[p])
            p = i;
    return p;
}
inline void init() {
    for (int i = 1; i <= n; i++)
        pos[i] = (i + block - 1) / block;
    for (int i=2; i<=n; i++) lg[i] = lg[i>>1] + 1;
    int p = pos[n];
    for (int i=1; i<=n; i++) {
        int j = pos[i];
        if (a[i] < a[st[j][0]]) st[j][0] = i;
    }
    for (int len=1; len<=lg[p]; len++) {
        for (int i=1; i<=p-(1<<len)+1; i++) {
            if (a[st[i][len - 1]] <= a[st[i + (1 << (len - 1))][len - 1]])
                st[i][len] = st[i][len - 1];
            else st[i][len] = st[i + (1 << (len - 1))][len - 1];
        }
    }
    pre[1] = 1;
    for (int i = 2; i <= n; i++)
        if (pos[i-1] == pos[i]) {
            if (a[pre[i - 1]] <= a[i])
                pre[i] = pre[i - 1];
            else
                pre[i] = i;
        } else
            pre[i] = i;
    suf[n] = n;
    for (int i = n - 1; i >= 1; i--)
        if (pos[i+1] == pos[i]) {
            if (a[suf[i + 1]] <= a[i])
                suf[i] = suf[i + 1];
            else
                suf[i] = i;
        } else
            suf[i] = i;
}
inline int rmq(int x, int y) {
    int l = pos[x], r = pos[y];
    if (l == r)
        return bf(x, y);
    else if (r - l == 1) {
        return a[pre[y]] <= a[suf[x]] ? pre[y] : suf[x];
    } else {
        int e = lg[r - l - 1];
        int p, pl = st[l + 1][e], pr = st[r-(1<<e)][e];
        p = a[pl] <= a[pr] ? pl : pr;
        if (a[suf[x]] <= a[pre[y]] && a[suf[x]] <= a[p])
            return suf[x];
        else if (a[pre[y]] <= a[suf[x]] && a[pre[y]] <= a[p])
            return pre[y];
        else
            return p;
    }
}
} // namespace FR
int sta[N], top;
int pre[N], suf[N];
long long L[N], R[N], LL[N], RR[N];
int main() {
    n = read(), m = read();
    FR::block = sqrt(n);
    a[0] = a[n + 1] = 0x3f3f3f3f3f3f3f3f;
    for (int i = 1; i <= n; i++)
        a[i] = read();
    FR::init();
    for (int i = 1; i <= n + 1; i++) {
        while (top && a[sta[top]] > a[i]) {
            suf[sta[top]] = i;
            top--;
        }
        pre[i] = sta[top];
        sta[++top] = i;
    }
    for (int i = 1; i <= n; i++)
        R[i] = a[i] * (i - pre[i]) + R[pre[i]], RR[i] = RR[i - 1] + R[i];
    for (int i = n; i >= 1; i--)
        L[i] = a[i] * (suf[i] - i) + L[suf[i]], LL[i] = LL[i + 1] + L[i];
    for (int l, r; m; m--) {
        l = read(), r = read();
        int p = FR::rmq(l, r);
        printf("%lld\n", (p - l + 1) * (r - p + 1) * a[p] + LL[l] - LL[p] -
                             L[p] * (p - l) + RR[r] - RR[p] - R[p] * (r - p));
    }
    return 0;
}
```



---

## 作者：Egg_eating_master (赞：1)

我不太会莫队，所以考虑暴力分块。

令 $st_i$ 表示块 $i$ 的开头位置，$ed_i$ 表示其结尾位置。

对于每一个询问区间，把它划分成左散块、整块和右散块三个部分。

那么考虑分别计算以下五种情况：

- 左散块内部的贡献

- 右散块内部的贡献

- 整块内部的贡献

- 左散块对整块的贡献

- 右散块对整块和左散块的贡献

最后显然求和就是答案。

对于前两种，直接暴力计算。对于第三种，预处理出 $f_{i,j}$ 表示区间 $[st_i,j]$ 的答案，这个预处理显然可以 $O(n\sqrt n)$ 做。

对于第四种，预处理出 $g_{i,j}$ 表示 $\sum\limits_{k=st_i}^j\min\limits_{l=st_i}^ka_l$。然后枚举左散块中的每个元素，利用 $g$ 可以计算出以其为开头对整块的贡献。

第五种同理。

时空复杂度均为 $O(n\sqrt n)$。

常数和代码复杂度都大得一匹。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn = 100005, maxb = 325;
int n, m, block, t;
int a[maxn];
int st[maxb], ed[maxb], pos[maxn];
int f[maxb][maxn];
int g[maxb][maxn], h[maxb][maxn];
int l[maxn], r[maxn];
int L[maxn], R[maxn];
int sum[maxn];
stack<int> s;
void init() {
    block = sqrt(n); t = ceil(n * 1. / block);
    for (int i = 1; i <= t; i++) {
        st[i] = (i - 1) * block + 1; ed[i] = min(i * block, n);
        for (int j = st[i]; j <= ed[i]; j++) pos[j] = i;
    }
    for (int i = 1; i <= t; i++) {
        while (!s.empty()) s.pop();
        for (int j = st[i]; j <= n; j++) l[j] = st[i] - 1;
        for (int j = st[i]; j <= n; j++) {
            while (!s.empty() && a[s.top()] > a[j]) s.pop();
            if (!s.empty()) l[j] = s.top(); s.push(j);
        }
        for (int j = st[i]; j <= n; j++) f[i][j] = a[j] * (j - l[j]) + f[i][l[j]];
        for (int j = st[i]; j <= n; j++) f[i][j] += f[i][j - 1];
    }
    for (int i = 1; i <= t; i++) {
        int minn = 1e9;
        for (int j = st[i]; j <= n; j++)
            g[i][j] = g[i][j - 1] + (minn = min(minn, a[j]));
    }
    for (int i = t; i >= 1; i--) {
        int minn = 1e9;
        for (int j = ed[i]; j >= 1; j--)
            h[i][j] = h[i][j + 1] + (minn = min(minn, a[j]));
    }
    for (int i = 1; i <= n; i++) L[i] = 0;
    while (!s.empty()) s.pop();
    for (int i = 1; i <= n; i++) {
        while (!s.empty() && a[s.top()] >= a[i]) s.pop();
        if (!s.empty()) L[i] = s.top();
        s.push(i);
    }
    while (!s.empty()) s.pop();
    for (int i = 1; i <= n; i++) R[i] = n + 1;
    for (int i = n; i >= 1; i--) {
        while (!s.empty() && a[s.top()] > a[i]) s.pop();
        if (!s.empty()) R[i] = s.top();
        s.push(i);
    }
}
int get(int x, int y) {
    for (int i = x; i <= y; i++) l[i] = x - 1;
    while (!s.empty()) s.pop();
    for (int i = x; i <= y; i++) {
        while (!s.empty() && a[s.top()] >= a[i]) s.pop();
        if (!s.empty()) l[i] = s.top();
        s.push(i);
    }
    for (int i = x; i <= y; i++) r[i] = y + 1;
    while (!s.empty()) s.pop();
    for (int i = y; i >= x; i--) {
        while (!s.empty() && a[s.top()] > a[i]) s.pop();
        if (!s.empty()) r[i] = s.top();
        s.push(i);
    }
    int ans = 0;
    for (int i = x; i <= y; i++) ans += (r[i] - i) * (i - l[i]) * a[i];
    return ans;
}
int query(int x, int y) {
    int p = pos[x], q = pos[y];
    if (p == q) return get(x, y);
    int ans = get(x, ed[p]) + get(st[q], y) + f[p + 1][ed[q - 1]];
    int minn = 0;
    for (int i = ed[p]; i >= x; i--) {
        if (minn == 0 || a[minn] > a[i]) minn = i;
        if (R[minn] > ed[q - 1]) ans += a[minn] * (ed[q - 1] - ed[p]);
        else ans += a[minn] * (R[minn] - st[p + 1]) + g[p + 1][ed[q - 1]] - g[p + 1][R[minn] - 1];
    }
    minn = 0;
    for (int i = st[q]; i <= y; i++) {
        if (minn == 0 || a[minn] > a[i]) minn = i;
        if (L[minn] < x) ans += a[minn] * (ed[q - 1] - x + 1);
        else ans += a[minn] * (ed[q - 1] - L[minn]) + h[q - 1][x] - h[q - 1][L[minn] + 1];
    }
    return ans;
}
signed main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    init();
    for (int i = 1; i <= m; i++) {
        int x, y; cin >> x >> y;
        cout << query(x, y) << endl;
    }
    return 0;
}
```


---

## 作者：FutaRimeWoawaSete (赞：1)

比较考技巧与性质的一道莫队题。

不开 O2 根本怎么卡常都过不了，有可能是 ST 表也有常数吧。         

我们考虑用莫队转移区间 $[l , r]$ 至区间 $[l , r + 1]$ ，增加的量即固定下来的右端点到 $l$ 所产生的所有子序列贡献的答案。            

我们考虑维护一个前缀 $Sum_i$ 表示 $[1 , i] , [2 , i] ……[i , i]$ 的答案，考虑如何 $O(n)$ 递推。           

我们找到前面第一个比 $a_i$ 小的数，其位置记为 $pos$ ，那么 $[pos + 1 , i]$ 中没有一个数比 $a_i$ 小，而 $[pos - 1 , i] , [pos - 2 , i] …… [1 , i]$ 中的最小值也一定产生在 $pos$ 之前，令 $val(l , r)$ 为一个区间的答案，那么   

$val([pos , pos]) = val([pos , i]) , val([pos - 1 , pos]) = val([pos - 1 , i]) …… val([1 , pos]) = val([1 , i])$         

即这一部分的贡献等价于 $Sum_p$ ，所以递推式就出来了：         

$Sum_i = Sum_p + (i - pos) \times a_i$               

接着我们倒着把后缀也做一遍类似的操作，记为 $Suf_i$ 。这是为了处理左端点移动时的贡献计算，其实就是把右端点的操作对称一下就好了。                   

之后我们在莫队转移时再换一种方法计算贡献，还是以 $[l , r] -> [l , r + 1]$ 举例。               

我们先找到区间 $[l , r]$ 内最小值对应的点，记为 $P$ ，那么 $[l \sim P , r]$ 的区间贡献就可以 $O(1)$ 算了。            

接着我们考虑 $[P + 1 \sim  r , r]$ 的贡献如何计算，考虑使用我们预处理出来的前缀 $Sum$ 。       

我们知道 $a[P] < min_{i = P + 1} ^ r a[i]$ ，所以如果对于一个左端点不固定的区间 $[ll , r]$ 而言，如果 $ll <= P$ ，那么这个区间的最小值就又不在 $[P + 1 , r]$ 之间了。         

换句话说这些区间的答案又可以和 $[ll , P]$ 等价了，而我们要做的不就是只要 $[P + 1 \sim r , r]$ 这些区间的贡献吗？那么直接用 $Sum_r - Sum_P$ 就好了。            

对于左端点移动的情况就全部反过来就好了。       

关于找最小点和最近的一个比它小的点，前一个我们直接用 ST 表预处理，后一个二分或单调栈都可以做。    

最后时间复杂度 $O(n \log n + n \sqrt n)$ 不知道为什么把莫队卡了，得开 O2 才能过。          

建议 ST 表卡一下 Cache 。

---

## 作者：Kinandra (赞：1)


. 做法: 莫队.

. 该题用莫队来做, 只需知道如何$\mathcal{O}(1)$求区间$[l,r], [l+1,r]$, $[l+2,r]$,...,$[r,r]$的最小值的和(设为$S$).

. 考虑维护一个$pre$数组,令$pre_i=\sum_{j=1}^{i}min_{k=j}^{i}a_k$.

设$i$的前方第一个比$i$小的数的位置为$l_i$(没有比$i$小的数则$l_i=0$), 则$pre_i=pre_{l_i}+(i-l_i)\times a_i$.

. 设区间$[l,r]$的最小值的位置为$pos$, 则$\forall i\in [l,pos], min_{j=i}^{pos}a_j=a_{pos}$, 即$[l,r]$,...,$[pos,r]$的答案为$a_{pos}\times(pos-l+1)$, 而$[pos+1,r],...,[r,r]$的答案为$pre_r-pre_{pos}$.

. 故$S=a_{pos}\times(pos-l+1)+pre_r-pre_{pos}$.

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

int read() {
    int x = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9') {
        if (c == '-') f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9') {
        x = x * 10 + c - '0';
        c = getchar();
    }
    return x * f;
}

int n, m;
long long st[200005][20], a[200005];
int pos[200005][20];
int p2[20], lg2[200005];
void mkst() {
    p2[0] = 1;
    for (int i = 1; i <= 18; ++i) p2[i] = p2[i - 1] * 2;
    lg2[0] = -1;
    for (int i = 1; i <= n; ++i) lg2[i] = lg2[i >> 1] + 1;
    for (int i = 1; (1 << i) <= n; ++i) {
        for (int j = 1; j + (1 << i) - 1 <= n; ++j) {
            if (st[j][i - 1] < st[j + p2[i - 1]][i - 1]) {
                st[j][i] = st[j][i - 1];
                pos[j][i] = pos[j][i - 1];
            } else {
                st[j][i] = st[j + p2[i - 1]][i - 1];
                pos[j][i] = pos[j + p2[i - 1]][i - 1];
            }
        }
    }
    return ;
}

int stqry(int l, int r) {
    int t = lg2[r - l + 1];
    return min(st[l][t], st[r - p2[t] + 1][t]);
}

int l[200005], r[200005];
long long pre[200005], pst[200005];
void gtpp() {
    for (int i = 1; i <= n; ++i) {
        l[i] = i;
        while (l[i] > 1 && a[i] < a[l[i] - 1]) l[i] = l[l[i] - 1];
        pre[i] = pre[l[i] - 1] + (i - l[i] + 1) * a[i];
    }
    for (int i = n; i >= 1; --i) {
        r[i] = i;
        while (r[i] < n && a[i] < a[r[i] + 1]) r[i] = r[r[i] + 1];
        pst[i] = pst[r[i] + 1] + (r[i] - i + 1) * a[i];
    }
    return ;
}

struct Q {
    int l, r;
    int i;
} q[200005];

bool cmp(Q a, Q b) {
    if (a.l / 315 == b.l / 315) return a.r < b.r;
    return a.l < b.l;
}

long long ans[200005], res;
int qpos(int l, int r) {
    int t = lg2[r - l + 1];
    if (st[l][t] < st[r - p2[t] + 1][t]) return pos[l][t];
    return pos[r - p2[t] + 1][t];
}

int main() {
    n = read(), m = read();
    for (int i = 1; i <= n; ++i) {
        st[i][0] = a[i] = read();
        pos[i][0] = i;
    }
    mkst();
    gtpp();
    for (int i = 1; i <= m; ++i) {
        q[i].l = read();
        q[i].r = read();
        q[i].i = i;
    }
    sort(q + 1, q + 1 + m, cmp);
    int L = 1, R = 1;
    res = a[1];
    for (int i = 1; i <= m; ++i) {
        while (R < q[i].r) {
            R++;
            int ps = qpos(L, R);
            res += (long long)(ps - L + 1) * a[ps] + pre[R] - pre[ps];
        }
        while (L > q[i].l) {
            L--;
            int ps = qpos(L, R);
            res += (long long)(R - ps + 1) * a[ps] + pst[L] - pst[ps];
        }
        while (R > q[i].r) {
            int ps = qpos(L, R);
            res -= (long long)(ps - L + 1) * a[ps] + pre[R] - pre[ps];
            R--;
        }
        while (L < q[i].l) {
            int ps = qpos(L, R);
            res -= (long long)(R - ps + 1) * a[ps] + pst[L] - pst[ps];
            L++;
        }
        ans[q[i].i] = res;
    }
    for (int i = 1; i <= m; ++i) {
        printf("%lld\n", ans[i]);
    }
    return 0;
}
```

---

## 作者：Siyunshan (赞：0)

提交记录里一堆线段树，表示迷惑。

其实莫队吧…也不怎么会。

莫队可以把这个问题变成对于区间[l,r]，以r为右端点，求答案。而且由于莫队的复杂度，必需做到$O(1)$

本来想存一个每个点左右比它小的第一个数，结果发现，貌似成了一个递归的子问题，偏离了初衷

然后教练讲过一种巧妙的做法：有区间$[1,r]$的答案，向左扩展一位。

先找出$[1,r+1]$中最小的数$k$，$k$左边作为左端点所以对答案有贡献的是$k$。

计算$[k+1,r]$，可以一（慢）眼（慢）瞪（计）出（算），$[k+1,r]$中比$k$都大。预处理以$i$为右端点的区间的答案和$s[i]$。

由于$k$及$k$左侧的贡献都会是$k$左边的数，所以在$s[k+1]$和$s[r]$是可以相减的,做一做减法就好了。

$RMQ$是$O(1)$的。

PS：除100会WA，不知道为什么…

[评测记录](https://www.luogu.com.cn/record/33695123)

---

## 作者：feecle6418 (赞：0)

## 乱搞做法

这是菜鸡在考场上想到的乱搞做法。

首先看单组询问怎么做：显然是单调栈，出栈的时候算一下贡献即可。这样可得到 $60$ 分（直接做 $40$，预处理每个区间的答案 $20$）。

多组询问呢？考虑将询问按照右端点从左到右处理。每个数 $a_i$ 对询问 $[l,r]$ 的贡献为：（$fl,fr$ 为一个点作为最小值的区间左右端点，均可用单调栈维护出）

$$a_i(fr_i-i+1)(i-fl_i+1)$$

考虑如何处理这个贡献。假设现在扫描的右端点为 $R$，则所有 $i\le r$ 的 $fl$ 都已经确定。将所有位置分为两部分，一部分是 $fr\le R$ 即已经从单调栈内弹出的点，一部分是还在栈内的点。第一部分好维护（因为 $fr$ 已经成为定值），如何维护第二部分呢？注意到 $R$ 这些点每往右移动一步，这些点的 $fr$ 就往右移动一步，因此可以用线段树处理：维护这些点的 $a_i(i-fl_i+1)$ 之和，每次让总贡献加上这个和即可。

然后一个询问一个询问看：设询问为 $[L,R]$（其中 $R$ 为定值），则这个询问的答案为 

$$\sum\limits_{i=L}^{R} a_i(fr_i-i+1)(i-\min(L,fl_i)+1)$$

假如没有 $\min$ 我们完全可以用线段树维护，但是 $\min$ 使我们乱了阵脚。这便引出了本种乱搞的精髓：我们将 $[L,R]$ 划分为许多小区间，使得每个区间内要么 $fl_i$ 都小于等于 $L$，要么都大于等于 $L$，容易发现这两种情况都可以直接用线段树维护区间和。假如不属于这两种情况，就在线段树上往下递归，总能划分成两种情况之一：这样就能维护出答案。

复杂度？最坏显然是 $\Theta(n^2)$，但是很难卡（需要 $fl$ 的值上下动荡大，而一个正常出题人是绝对想不到的），因此实际效率与 $O(n\log^2 n)$ 的算法相近，在普通数据上最大点耗时约为 $700\text{ms}$。

到底要维护哪些标记？我们数数（以下省略 $\sum$）：

1. $\min,\max fl$（为了划分区间）；
2. $a_i(fr_i-i+1)(i-fl_i+1)$（$\min fl\ge L$ 时答案）；
3. $a_i(fr_i-i+1)$ 和 $(i-fl_i+1)a_i$（可算出 $\max fl\le L$ 时答案）；
4. $(i-fl_i+1)a_i$，$(i+1)a_i$，$a_i$（为了快速算出 $R$ 右移时答案的变化量）。

一共八个标记，比标算（莫队）不知道难写到哪里去了。

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<set>
#include<vector>
using namespace std;
typedef long long ll;
int n,m,a[100005],st[100005],top,fl[100005],fr[100005],minn[400005],maxx[400005],tag[400005];
//sum:sum{a[i](fr[i]-i+1)(i-fl[i]+1)}
//sumr:sum{(i+1)a[i](fr[i]-i+1)}
//sumr2:sum{a[i](fr[i]-i+1)}
//summ:sum{(i-fl[i]+1)a[i]}
//summ2:sum{(i+1)a[i]}
//summ3:sum{a[i]}
ll fans[100005],sum[400005],sumr[400005],sumr2[400005];
ll summ[400005],summ2[400005],summ3[400005];
vector<int> vec[100005];
struct Query {
	int l,r;
} q[100005];
void Addtag(int p,int q) {
	sum[p]+=q*summ[p];
	sumr[p]+=q*summ2[p];
	sumr2[p]+=q*summ3[p];
	tag[p]+=q;
}
void Pushdown(int p) {
	if(tag[p]) {
		Addtag(p*2,tag[p]);
		Addtag(p*2+1,tag[p]);
		tag[p]=0;
	}
}
void Pushup(int p) {
	sum[p]=sum[p*2]+sum[p*2+1];
	sumr[p]=sumr[p*2]+sumr[p*2+1];
	sumr2[p]=sumr2[p*2]+sumr2[p*2+1];
	summ[p]=summ[p*2]+summ[p*2+1];
	summ3[p]=summ3[p*2]+summ3[p*2+1];
	summ2[p]=summ2[p*2]+summ2[p*2+1];
	minn[p]=min(minn[p*2],minn[p*2+1]);
	maxx[p]=max(maxx[p*2],maxx[p*2+1]);
}
void Modifyr(int p,int l,int r,int x,int y) {
	if(l==r) {
		sumr[p]=1ll*(l+1)*a[l]*(y-x+1);
		sumr2[p]=1ll*a[l]*(y-x+1);
		sum[p]=1ll*a[l]*(y-x+1)*(l-fl[l]+1);
		summ[p]=summ2[p]=summ3[p]=0;
		return ;
	}
	Pushdown(p);
	int mid=(l+r)/2;
	if(x<=mid)Modifyr(p*2,l,mid,x,y);
	else Modifyr(p*2+1,mid+1,r,x,y);
	Pushup(p);
}
void Modifyl(int p,int l,int r,int x,int y) {
	if(l==r) {
		fl[l]=y;
		sumr[p]=1ll*(l+1)*a[l];
		sumr2[p]=a[l];
		sum[p]=1ll*a[l]*(l-fl[l]+1);
		summ3[p]=a[l];
		summ2[p]=1ll*(l+1)*a[l];
		summ[p]=1ll*(l-y+1)*a[l];
		minn[p]=maxx[p]=y;
		return ;
	}
	Pushdown(p);
	int mid=(l+r)/2;
	if(x<=mid)Modifyl(p*2,l,mid,x,y);
	else Modifyl(p*2+1,mid+1,r,x,y);
	Pushup(p);
}
ll Query(int p,int l,int r,int x,int y) {
	if(x<=l&&r<=y) {
		if(minn[p]>=x)return sum[p];
		if(maxx[p]<=x)return sumr[p]-1ll*x*sumr2[p];
		Pushdown(p);
		int mid=(l+r)/2;
		ll ret=Query(p*2,l,mid,x,y)+Query(p*2+1,mid+1,r,x,y);
		Pushup(p);
		return ret;
	}
	Pushdown(p);
	int mid=(l+r)/2;
	ll ret=0;
	if(x<=mid)ret+=Query(p*2,l,mid,x,y);
	if(mid<y)ret+=Query(p*2+1,mid+1,r,x,y);
	Pushup(p);
	return ret;
}
int main() {
	//freopen("sequence.in","r",stdin);
	//freopen("sequence.out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; i++)scanf("%d",&a[i]);
	for(int j=1; j<=m; j++)scanf("%d%d",&q[j].l,&q[j].r),vec[q[j].r].push_back(j);
	memset(minn,0x3f,sizeof(minn));
	for(int i=1; i<=n; i++) {
		while(top&&a[st[top]]>a[i]) {
			fr[st[top]]=i-1;
			Modifyr(1,1,n,st[top],i-1);//fr变成了i-1
			top--;
		}
		Addtag(1,1);//没有fr的向右推进一格
		Modifyl(1,1,n,i,top?st[top]+1:1);//i的fl加进去
		st[++top]=i;
		for(int j=0; j<vec[i].size(); j++) {
			int id=vec[i][j];
			fans[id]=Query(1,1,n,q[id].l,q[id].r);//复杂度不清楚正不正确……
		}
	}
	for(int i=1; i<=m; i++)printf("%lld\n",fans[i]);
}
```

---


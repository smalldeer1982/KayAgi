# [HNOI2016] 树

## 题目描述

小A想做一棵很大的树，但是他手上的材料有限，只好用点小技巧了。开始，小A只有一棵结点数为 $N$ 的树，结点的编号为 $1,2,...,N$，其中结点 $1$ 为根；我们称这颗树为模板树。小A决定通过这棵模板树来构建一颗大树。构建过程如下：

1. 将模板树复制为初始的大树。

2. 以下(2.1)(2.2)(2.3)步循环执行 $M$ 次

（2.1）选择两个数字 $a,b$，其中 $1 \leq a \leq N, 1 \leq b \leq \text{当前大树的结点数}$。

（2.2）将模板树中以结点 $a$ 为根的子树复制一遍，挂到大树中结点 $b$ 的下方(也就是说，模板树中的结点 $a$ 为根的子树复制到大树中后，将成为大树中结点 $b$ 的子树)。

（2.3）将新加入大树的结点按照在模板树中编号的顺序重新编号。例如，假设在进行2.2步之前大树有 $L$ 个结点，模板树中以 $a$ 为根的子树共有 $C$ 个结点，那么新加入模板树的 $C$ 个结点在大树中的编号将是 $L+1,L+2,...,L+C$ ；大树中这C个结点编号的大小顺序和模板树中对应的 $C$ 个结点的大小顺序是一致的。下面给出一个实例。假设模板树如下图：![](https://cdn.luogu.com.cn/upload/image_hosting/mchs3i55.png)

根据第(1)步，初始的大树与模板树是相同的。

在(2.1)步，假设选择了 $a=4, b=3$。运行(2.2)和(2.3)后，得到新的大树如下图所示

![](https://cdn.luogu.com.cn/upload/image_hosting/ey2lqez8.png)

现在他想问你，树中一些结点对的距离是多少。


## 说明/提示

经过两次操作后，大树变成了下图所示的形状：

![](https://cdn.luogu.com.cn/upload/image_hosting/370xfnn2.png)

结点6到9之间经过了6条边，所以距离为6；类似地，结点1到8之间经过了3条边；结点5到3之间也经过了3条边。


## 样例 #1

### 输入

```
5 2 3
1 4
1 3
4 2
4 5
4 3
3 2
6 9
1 8
5 3```

### 输出

```
6
3
3```

# 题解

## 作者：徐致远 (赞：16)

[本蒟蒻的Blog](https://www.chnxuzhiyuan.cn/2019/01/05/%E3%80%8CHNOI2016%E3%80%8D%E6%A0%91-Solution/)

### 题解

蒟蒻我定睛一看，一共有$10^{10}$个点，立马把蒟蒻我给吓到了QwQ。显然这是一道毒瘤题。我深深地感受到了出题人的恶意(~~然而我还是太菜了，像XHW这种dalao就可以想着要[把出题人阿掉](https://xcfubuki.cn/2018/HNOI2016-Tree-sol/)，我却不行~~)。

既然有这么多点，肯定是存不下的。因为每次操作都是copy一整颗子树，所以我们可以用一种叫做 真•树套树 的方法来解决呢poi。

我们构造大树时，令每一个大节点都对应模板树中的一整棵子树，并对新树重新编号，就像这样（样例）：

![tree1](https://www.chnxuzhiyuan.cn/images/HNOI2016-Tree-tree1.png)

然后我们定义两个大节点之间的边的变权为两个大节点所包含的树的树根之间的距离。如上图中大节点1和2之间的边权为2,1与3之间的边权为3。

每一个大节点还需要存储以下信息：

- S[],T[]：该大节点包含的小节点的编号区间的起点和终点，如上图节点1的编号区间是[1,5]，节点2是[6,8]，节点3是[9,9]。
- pre[]：该大节点对应的是模板树中哪一个节点的子树，如pre[1]=1，pre[2]=4，pre[3]=3。
- lnk[]：该大节点挂在大树中的哪一个节点底下，如lnk[2]=3，lnk[3]=2。

以及常见的倍增LCA所需的信息。

还需要写几个函数：

- int GetRoot(long long u);用于查找小节点u所在的大节点。构造好S[],T[0]后，二分即可实现。
- int GetPre(long long u);用于查找小节点u在模板树中对应的是哪个节点。假设小节点u在大节点rt里，那么根据题意，我们要找的就是rt对应的模板树的子树中该子树编号第$u-S[rt]+1$小的节点。这个我们可以把模板树~~一巴掌拍扁~~求个DFS序，然后用主席树解决（[不会主席树的童鞋戳这里](https://www.chnxuzhiyuan.cn/2019/01/04/%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%88%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89/)）。
- int GetDist(int u,int v);用于求模板树上的节点u,v之间的距离。LCA解决。

然后就可以开始考虑如何计算答案了。

计算答案的主要思想就是在大树上通过倍增LCA求解，但是与普通LCA不同的是，不能纯粹地就在大树上LCA，需要注意很多细节。比如当再跳一步就跳到最近的大节点公共祖先时，不能马上往上跳，而需要往上跳一小步后转到模板树上去LCA。因为计算答案的细节，劳资%@#@￥%(~~文明靠大家~~)地交了4次才AC(~~不过好像也不算多~~)。

这样这题就解完了。时空复杂度都是大约$\Theta(超大常数*n\log n)$呢poi。

### 总结&反思

这是一道十分毒瘤的代码题(但是在某些dalao眼里就是送分题)，思维难度一般，但蒟蒻我前前后后一共花了3个多小时才AC(听说隔壁[XCW](https://xsamsara.tk/)一看题就秒掉了)QwQ。这道题很好地反映出蒟蒻我的代码实现能力还是太差，可能是由于做题太少的缘故。我虽然很菜，但是如果ZJOI2019真的出了像这样的一道题(或者类似于猪国杀什么的)，空有想法却没时间写代码和调试，那可就亏大发了QwQ。

### 代码

蒟蒻我为了避免变量重名，于是开了两个namespace（~~不知代码是更好看了还是更丑了~~）。



```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long LL;
const int maxn=100005,LOG=20;
int Q;
inline LL read()
{
	LL ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9'){ret=ret*10+ch-'0';ch=getchar();}
	return ret*f;
}
struct ChairmanTree               //封装好的主席树
{
	int tot,T[maxn];
	struct Node{int L,R,Sum;}Tree[maxn*LOG];
	int Build(int L,int R)
	{
		int rt=++tot,mid=L+R>>1;
		if(L>=R) return rt;
		Tree[rt].L=Build(L,mid);
		Tree[rt].R=Build(mid+1,R);
		if(rt==1) T[0]=rt;
		return rt;
	}
	int Update(int num,int pre,int L,int R)
	{
		int rt=++tot,mid=L+R>>1;
		Tree[rt].L=Tree[pre].L;Tree[rt].R=Tree[pre].R;Tree[rt].Sum=Tree[pre].Sum+1;
		if(L>=R) return rt;
		if(num<=mid) Tree[rt].L=Update(num,Tree[pre].L,L,mid);
		else Tree[rt].R=Update(num,Tree[pre].R,mid+1,R);
		return rt;
	}
	int Query(int u,int v,int k,int L,int R)
	{
		int mid=L+R>>1,x=Tree[Tree[v].L].Sum-Tree[Tree[u].L].Sum;
		if(L==R) return mid;
		if(x>=k) return Query(Tree[u].L,Tree[v].L,k,L,mid);
		else return Query(Tree[u].R,Tree[v].R,k-x,mid+1,R);
	}
}CT;
namespace TemplateTree           //模板树
{
	int n,father[maxn][LOG],dep[maxn],idx,que[maxn],S[maxn],T[maxn],tot,lnk[maxn],son[maxn*2],nxt[maxn*2];
	inline void add_e(int x,int y){tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;}
	void Build(int now,int fa)   //把树上的一些信息构造好
	{
		S[now]=++idx;que[idx]=now;father[now][0]=fa;dep[now]=dep[fa]+1;
		for(int i=1;i<=16;i++) father[now][i]=father[father[now][i-1]][i-1];
		for(int i=lnk[now];i;i=nxt[i])
			if(son[i]!=fa)
				Build(son[i],now);
		T[now]=idx;
	}
	inline void BuildCT()      //初始化主席树
	{
		CT.Build(1,n);
		for(int i=1;i<=n;i++) CT.T[i]=CT.Update(que[i],CT.T[i-1],1,n);
	}
	inline void Input()       //读入数据
	{
		for(int i=1;i<n;i++)
		{
			int a=read(),b=read();
			add_e(a,b);add_e(b,a);
		}
		Build(1,0);BuildCT();
	}
	int GetDist(int u,int v)    //LCA求亮点间距离
	{
		int ret=0;
		if(dep[u]<dep[v]) swap(u,v);
		for(int i=16;i>=0;i--) if(dep[father[u][i]]>=dep[v]){ret+=(1<<i);u=father[u][i];}
		for(int i=16;i>=0;i--) if(father[u][i]!=father[v][i]){ret+=(1<<i+1);u=father[u][i];v=father[v][i];}
		if(u==v) return ret;
		return ret+2;
	}
}
namespace BigTree             //大树
{
	int n,m,father[maxn][LOG],dep[maxn],pre[maxn];LL dist[maxn][LOG],S[maxn],T[maxn],lnk[maxn],cnt;
	inline int GetRoot(LL u)
	{
		int L=1,R=n,mid;
		while(L<=R)
		{
			mid=L+R>>1;
			S[mid]<=u?L=mid+1:R=mid-1;
		}
		return R;
	}
	inline int GetPre(LL u)
	{
		int rt=GetRoot(u);
		return CT.Query(CT.T[TemplateTree::S[pre[rt]]-1],CT.T[TemplateTree::T[pre[rt]]],u-S[rt]+1,1,TemplateTree::n);
	}
	inline void Build()        //初始化大树
	{
		n=1;dep[1]=1;pre[1]=1;S[1]=1;T[1]=TemplateTree::n;cnt=T[1];
		for(int i=1;i<=m;i++)
		{
			int fr=read();LL to=read();int rt=GetRoot(to);
			n++;dep[n]=dep[rt]+1;lnk[n]=to;pre[n]=fr;S[n]=cnt+1;T[n]=cnt+TemplateTree::T[fr]-TemplateTree::S[fr]+1;cnt=T[n];
			father[n][0]=rt;dist[n][0]=TemplateTree::dep[GetPre(to)]-TemplateTree::dep[pre[rt]]+1;
			for(int j=1;j<=16;j++){father[n][j]=father[father[n][j-1]][j-1];dist[n][j]=dist[n][j-1]+dist[father[n][j-1]][j-1];}
		}
	}
	inline LL Solve(LL u,LL v)     //计算答案(写的真丑QwQ)
	{
		LL ret=0;int rtu=GetRoot(u),rtv=GetRoot(v);
		if(rtu==rtv) return TemplateTree::GetDist(GetPre(u),GetPre(v));
		if(dep[rtu]<dep[rtv]){swap(u,v);swap(rtu,rtv);}
		ret+=TemplateTree::dep[GetPre(u)]-TemplateTree::dep[pre[rtu]];u=rtu;
		for(int i=16;i>=0;i--) if(dep[father[u][i]]>dep[rtv]){ret+=dist[u][i];u=father[u][i];}
		if(GetRoot(lnk[u])==rtv) return ret+1+TemplateTree::GetDist(GetPre(lnk[u]),GetPre(v));
		ret+=TemplateTree::dep[GetPre(v)]-TemplateTree::dep[pre[rtv]];v=rtv;
		if(dep[u]>dep[v]){ret+=dist[u][0];u=father[u][0];}
		for(int i=16;i>=0;i--) if(father[u][i]!=father[v][i]){ret+=dist[u][i]+dist[v][i];u=father[u][i];v=father[v][i];}
		u=lnk[u];v=lnk[v];ret+=2;
		return ret+TemplateTree::GetDist(GetPre(u),GetPre(v));
	}
}
int main()                    //好简洁的主函数
{
	TemplateTree::n=read();BigTree::m=read();Q=read();
	TemplateTree::Input();BigTree::Build();
	while(Q--) printf("%lld\n",BigTree::Solve(read(),read()));
	return 0;
}
```



---

## 作者：shadowice1984 (赞：11)

woc真的难写……毒瘤压行的我写了将近120行………

而且可怕的是这道题并没用各种高级数据结构……

# 真·树套树

这道题并没有让你用树套树的做法去做

而是题目中给你的树本来就是一棵树套树

大树中其实是一棵套着各种膜板树的子树的树

于是平时在树上轻而易举的操作，例如lca之类的，到了树套树上都会极为艰难

## 本题题解

先解释一下为什么题目中的大树是树套树吧

首先我们发现极限点数是1e10级别的,这种东西我们连把树建出来都会TLE+MLE

因此我们肯定是不能硬莽的……当我们发现这个问题变得十分辣手的时候，我们要动脑子想一想，是否有一种等价的映射方式，可以在保留这个只大树的所有信息的同时，减少信息的存储量

但是我们发现大树中的所有点都是由膜板树中的点复制出来的，这意味着大树中的本质不同的点只有O(N)个，我们可以按照这个点是由膜板树中的哪一个点复制过来的来给大树中的点再标一个1~N的号，记为sn，表示这个点被复制时，在膜板树上的编号为sn

此时我们发现有一些关键点，是复制时子树的根，为此我们给大树中的点再标一重号，记为root，**表示这个点被复制时，他所在的膜板树子树根为root**

我们此时发现root相同的点一定在大树上是相邻的，我们可以把root相邻的点缩成一个点，只留下那个sn==root的点，也就是发生复制时子树的根

现在我们需要在缩好点的树上维护树上距离，由于我们在映射的时候只留下了root，因此我们现在只需要保证两个root在**大树上的距离**和**在缩点之后的树上距离是一样的**，而对于两个任意点，我们待会会通过一些奇技淫巧解决这个问题。

那么我们可以这样规定，两个root的边权就是在**执行复制操作**时，大树上to节点到自己root的距离+1

 _(如果你不死抠root的定义的话这句话你应该能懂，但是如果你要硬抠的话，这里root的意思是to节点在被复制过来时，所在的膜板树的子树的根被复制过来之后对应的大树节点)_

这样的话我们可以保证任意两个root的边权是准的，同时我们再定义一个att\[i]表示点i在大树上的真实父亲的sn值，这里的i表示缩点之后树上的编号而不是原来大树的编号

那么这个缩完点之后的树，一个节点代表着一棵树，所以对于一个大树原来的节点to，我们可以用一个二元组(sn,bn)唯一表示它，sn就是这个节点的sn，而bn代表了它的所在的子树缩点后在树上的编号

 _有点像表格的查找方式，先确定列再确定行_
 
 ### 如何求树上距离
 
 再说一遍,数据结构题最重要的是脑子清楚，时刻明白自己在干什么，不然很快就会把自己码晕……
 
我们的思路大概是这样，首先两个节点u，v跳到自己的缩点之后的根节点，之后再跳到缩点树上的lca，此时我们发现这样走的不是最短路，重复走的部分是两个节点跳到lca内部之后，在lca所对应树的里的lca深度的2倍，减掉即可~

当然这么说肯定是听不懂的，所以我们还是上图片吧

![](https://cdn.luogu.com.cn/upload/pic/15806.png)

图中两个节点的距离=蓝色-2\*红色=一部分蓝色+紫色+黑色

### 需要滋磁的操作

不得不说的是，刚才的操作十分的辣手，我们需要实现一系列复杂的操作才可以做到这一点

那么我们先从建树说起吧~

#### 建树

1.读入x,to

2.将to转换为(sn,bn)的二元组形式

3.查找sn到bn.root的在膜板树上距离val

3.新建一个缩点树节点newnode，在newnode和bn之间连一条边权为val+1的边

4.newnode的att属性记为sn

下面是查找距离~

#### 查找距离

1.读入u,v

2.将u，v转换为(sn1,bn1)，(sn2,bn2)的二元组形式

3.查找bn1,bn2的lca p，并且记录j1,j2两个点

j1,j2因bn1，bn2在树上的关系而不同

如果bn1==bn2,那么j1=sn1,j2=sn2

如果bn1与bn2是直系祖先关系，且bn1是祖先，那么j1=sn1

**j2=bn1儿子中是bn2祖先的那个点的att属性**

其他情况

**j1=p儿子中是bn1祖先的那个点的att属性**

**j2=p儿子中是bn2祖先的那个点的att属性**

不难发现，在每一种情况下，j1,j2都是u,v跳到同一个小树以后所在的节点，而这个小树在缩点树上对应着点p

4.查找sn1与bn1.root的距离

5.查找sn2与bn2.root的距离

6.查找bn1,bn2间的距离

7.**查找j1,j2的lca和p.root的距离**

8.将4,5,6步中的距离加起来再减去2倍的7步中查到的距离就是答案了

## 如何写代码

额，从上面的伪代码来讲我们的需要实现的操作十分的辣手

大体来讲分为3个

1.将大树的编号转换为二元组

2.缩点树上查距离，膜板树上查距离

3.查找j1,j2

那么我们静下心来，一个操作一个操作的想实现

### 编号转换

发现bn值相同的点编号是一段连续的区间，于是我们可以开一个a数组记录每个bn值所对应的最大大树编号，也就只是记录bn的区间右端点编号

此时我们可以通过lower_bound求出这个编号的bn值

通过这个点和区间右端点编号的差我们可以算出来这个点在bn.root的子树中的排名，现在我们要求sn，也就是求子树第k大

此时我们通过dfs序把子树拍平为一段区间，这样问题变成了求静态区间第k小，经典的主席树问题

好了我们用logN的复杂度(以及巨大的代码量)实现了映射操作~

### 查距离

树上倍增找lca，直接算距离，同时我们发现查点和直系祖先距离的操作特别多，再额外实现一个O(1)的快速算法，不会出门左转luogu板子区

### 查找j1,j2

啊~这是一个辣手的操作

但是我们首先可以大力特判掉u==v的情形。

接下来还记得树上倍增的过程吗?如果u和v不是直系祖先关系，那么循环结束时u，v的父亲才是lca，此时的u,v一定是原来u,v的的祖先，同时也是lca的儿子
所以直接去att属性就行了

下面是最辣手的情况，u和v是直系祖先关系

我们在将u，v跳到深度相等的操作改为u比v的深度低1，由于特判掉了u==v所以我们总是可以查到那个是lca儿子又是u祖先的点，取这个点的att属性就好了

好了我们终于做完操作了

大概是写一个膜板树类，还有一个缩点树类，还有一个主席树+lower_bound类吧

如果不注意写法的话应该会写的非常艰难吧~不懂的看注释

(如果好好实现的话其实没啥细节，但是如果开始胡写瞎写的话就要靠大力特判来AC了)

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;typedef long long ll;
const int N=1e5+10;int n;int m;int q;
int dfn[N];int nfd[N];int df;int siz[N];int cnt;//开全局变量方便主席树类访问
struct smtree
{
	struct data{int v;int x;}e[2*N];int al[N];int ct;
	inline void add(int u,int v){e[++ct]=(data){v,al[u]};al[u]=ct;}
	ll d[N];bool book[N];int fa[22][N];//倍增板子
	void dfs(int x)
	{
		for(int i=0;fa[i][x];i++){fa[i+1][x]=fa[i][fa[i][x]];}
		book[x]=true;siz[x]=1;dfn[++df]=x;nfd[x]=df;
		for(int i=al[x],v=e[i].v;i;i=e[i].x,v=e[i].v)
		{if(!book[v]){fa[0][v]=x;d[v]=d[x]+1;dfs(v);siz[x]+=siz[v];}}
	}
	inline int lca(int u,int v)//lca板子
	{
		if(d[u]<d[v]){swap(u,v);}int del=d[u]-d[v];
		for(int i=0;del;del>>=1,i++){if(del&1){u=fa[i][u];}}if(u==v){return u;}
		for(int i=20;i>=0;i--){if(fa[i][u]!=fa[i][v]){u=fa[i][u];v=fa[i][v];}}
		return fa[0][u];
	}
	inline ll cd(int u,int v)//求祖先的距离，O(1)
	{ll ret=abs(d[u]-d[v]);return ret;}
	inline ll cdlca(int u,int v,int r)//求lca和公共根的距离
	{ll ret=d[lca(u,v)]-d[r];return ret;}
}st;
struct per_linetree//主席树类
{
	int s[2][22*N];int val[22*N];int root[N];int cnt;
	inline void cson(int p1,int p2,int tp)//静态区间第k大板子没啥好说的
	{s[tp][p2]=++cnt;s[tp^1][p2]=s[tp^1][p1];}
	inline void add(int p1,int p2,int l,int r,int pos)
	{
		val[p2]=val[p1]+1;if(r-l==1){return;}int mid=(l+r)/2;
		if(pos<=mid){cson(p1,p2,0);add(s[0][p1],cnt,l,mid,pos);}
		else {cson(p1,p2,1);add(s[1][p1],cnt,mid,r,pos);}
	}
	inline int kth(int p1,int p2,int l,int r,int rk)
	{
		if(r-l==1){return r;}int mid=(r+l)/2;int nv=val[s[0][p2]]-val[s[0][p1]];
		if(rk<=nv){return kth(s[0][p1],s[0][p2],l,mid,rk);}
		else {return kth(s[1][p1],s[1][p2],mid,r,rk-nv);}
	}
	inline int ckth(int l,int r,int rk){return kth(root[l],root[r],0,n,rk);}
	inline void build()//对dfn建主席树
	{
		root[0]=++cnt;for(int i=1;i<=n;i++)
		{root[i]=++cnt;add(root[i-1],root[i],0,n,dfn[i]);}
	}
	struct nod//用来存bn区间右端点的结构体
	{
		ll v;int root;int bn;
		friend bool operator <(nod a,nod b){return a.v<b.v;}
	}a[N];int ctt;//有序数组
	inline void dtr(ll x,int& root,int& su,int& bu)//这里额外返回一个root，代表bn.root
	{
		nod p=*(lower_bound(a+1,a+ctt+1,(nod){x,0,0}));//先lower_bound
		root=p.root;bu=p.bn;int rk=x+siz[root]-p.v;//写的是第k小板子，所以转一下排名
		su=ckth(nfd[root]-1,nfd[root]+siz[root]-1,rk);//计算sn
	}
	inline void push_nod(int root,int bu)//插入一个新节点，保证数组的有序性
	{a[ctt+1]=(nod){a[ctt].v+siz[root],root,bu};ctt++;}
}plt;
struct bigtree
{
	struct data{int v;int x;ll val;}e[2*N];int al[N];int ct;
	inline void add(int u,int v,ll val){e[++ct]=(data){v,al[u],val};al[u]=ct;}
	bool book[N];int fa[22][N];int d[N];ll dis[N];int att[N];
	void dfs(int x)//倍增板子没啥好说的
	{
		book[x]=true;for(int i=0;fa[i][x];i++){fa[i+1][x]=fa[i][fa[i][x]];}
		for(int i=al[x],v=e[i].v;i;i=e[i].x,v=e[i].v)
		{if(!book[v]){dis[v]=dis[x]+e[i].val;d[v]=d[x]+1;fa[0][v]=x;dfs(v);}}
	}
	inline int lca(int u,int v,int& snu,int& snv)//魔改后的lca，可以传回j1,j2
	{
		if(u==v){return u;}//大力特判u==v
		if(d[u]<d[v]){swap(u,v);swap(snu,snv);}
		int del=d[u]-d[v]-1;//这里u跳到和v差1就好
		for(int i=0;del>0;del>>=1,i++){if(del&1){u=fa[i][u];}}
		if(fa[0][u]==v){snu=att[u];return v;}else if(del!=-1){u=fa[0][u];}//如果不是祖先的话还要补回来
		for(int i=20;i>=0;i--){if(fa[i][u]!=fa[i][v]){u=fa[i][u];v=fa[i][v];}}
		snu=att[u];snv=att[v];return fa[0][u];//如果不是祖先的话直接取att属性就好
	}
	inline ll cd(int u,int v,int p){return dis[u]+dis[v]-2*dis[p];}//因为我们求了lca了，因此直接算就好
}bt;
inline ll cd(ll u,ll v)//正式的计算距离的函数
{
	int r1;int sn1;int bn1;int j1;int r2;int sn2;int bn2;int j2;
	plt.dtr(u,r1,sn1,bn1);plt.dtr(v,r2,sn2,bn2);j1=sn1;j2=sn2;//强行转二元组
	int p=bt.lca(bn1,bn2,j1,j2);int r0=plt.a[p].root;//计算j1.j2,p
	return st.cd(r1,sn1)+st.cd(r2,sn2)-2*st.cdlca(j1,j2,r0)+bt.cd(bn1,bn2,p);//按公式算就行了
}
int main()
{
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<n;i++)
	{int u;int v;scanf("%d%d",&u,&v);st.add(u,v);st.add(v,u);}
	st.dfs(1);plt.build();plt.push_nod(1,++cnt);//记得一开始大树是有一个点的
	for(int i=1;i<=m;i++)
	{
		int x;ll to;scanf("%d%lld",&x,&to);
		int root;int sn;int bn;plt.dtr(to,root,sn,bn);//强行转二元组
		plt.push_nod(x,++cnt);bt.att[cnt]=sn;//插点
		int val=st.cd(sn,root)+1;//计算边权
		bt.add(bn,cnt,val);bt.add(cnt,bn,val);//连边
	}bt.dfs(1);
	for(int i=1;i<=q;i++)
	{
		ll u;ll v;scanf("%lld%lld",&u,&v);
		printf("%lld\n",cd(u,v));//大力计算就好了
	}return 0;//拜拜程序~
}
```















 










---

## 作者：_AyachiNene (赞：6)

# 思路：
由于模板树是固定的，所以每次加入的子树是很容易表示出来，即记一下根节点，然后很容易想到把每次加入的子树缩成一个点加到大树里。

对于询问直接分讨：
- 两个点在大树的同一个点中：直接在原树上求解就行。
- 不在大树的同一个点中，且在大树上一个点所在的点是另一个点所在点的祖先：定义交点表示两个大树上的点的真实接上去的点。在把大树上两个点接起来时，把大树下面的点上记一下接的点在模板树上的对应编号，再倍增一下就能求出大树上有祖先关系的两个点的交点。设查询点对为 $(x,y)$，$u$ 为查询的点对在大树上深度大的点，$v$ 为小的点， 那么答案就为 $x$ 到大树上所在点在模板树上的根的距离，加上 $u$ 到 $v$ 在大树上的距离，在加上模板树上 $u$ 和 $v$ 的交点到 $x$ 的距离。
- 最后一种和第二种类似，即两个点没有祖先管系，只需要在第二种情况的基础上变成两个点分别到两个点 lca 的距离就行。

分讨比较抽象，还有一些开闭区间的细节，建议画个图，然后就很明显了。

题目还要求要维护编号，这个就很简单，只需要记一下每次加入的子树的大小，做一个前缀和，二分一下就能知道一个点在大树上的点是哪一个和是第几个，由于题目钦定了编号的排列顺序，所以要求出这个点是模板树上的哪个点就是求一个原树上子树内的 $k$ 大值，$k$ 为还要在大树的这个点里找几个点，这里我用了个线段树合并，也可以把 dfs 序拍下来用主席树做。

# Code：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
namespace IO
{
	char buff[1<<21],*p1=buff,*p2=buff;
	char getch(){return p1==p2&&(p2=((p1=buff)+fread(buff,1,1<<21,stdin)),p1==p2)?EOF:*p1++;}
	template<typename T>void read(T &x){char ch=getch();int fl=1;x=0;while(ch>'9'||ch<'0'){if(ch=='-')fl=-1;ch=getch();}while(ch<='9'&&ch>='0'){x=x*10+ch-48;ch=getch();}x*=fl;}
	template<typename T>void read_s(T &x){char ch=getch();while(ch<'A'||ch>'Z')ch=getch();while(ch>='A'&&ch<='Z'){x+=ch;ch=getch();}}
	template<typename T,typename ...Args>void read(T &x,Args& ...args){read(x);read(args...);}
	char obuf[1<<21],*p3=obuf;
	void putch(char ch) {if(p3-obuf<(1<<21))*p3++=ch;else fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=ch;}
	char ch[100];
	template<typename T>void write(T x) {if(!x)return putch('0');if(x<0)putch('-'),x*=-1;int top=0;while(x)ch[++top]=x%10+48,x/=10;while(top)putch(ch[top]),top--;}
	template<typename T,typename ...Args>void write(T x,Args ...args) {write(x);write(args...);}
	void flush(){fwrite(obuf,p3-obuf,1,stdout);}
}
using namespace IO;
int n,m,q;
namespace Elaina
{
	struct segt
	{
		int l,r,val;
	}t[1000005<<3];
	int rt[100005<<1],cnt;
	#define mid (l+r>>1)
	inline void update(int root){t[root].val=t[t[root].l].val+t[t[root].r].val;}
	void insert(int x,int v,int &root,int l=1,int r=n)
	{
		if(!root) root=++cnt;
		if(l==r)
		{
			t[root].val+=v;
			return;
		}
		if(x<=mid) insert(x,v,t[root].l,l,mid);
		else insert(x,v,t[root].r,mid+1,r);
		update(root);
	}
	int merge(int x,int y,int l=1,int r=n)
	{
		if(!x||!y) return x|y;
		int cur=++cnt;
		if(l==r)
		{
			t[cur].val=t[x].val+t[y].val;
			return cur;
		}
		t[cur].l=merge(t[x].l,t[y].l,l,mid);t[cur].r=merge(t[x].r,t[y].r,mid+1,r);
		update(cur);
		return cur;
	}
	int query(int k,int root,int l=1,int r=n)
	{
		if(!root) return 0;
		if(l==r) return l; 
		if(t[t[root].l].val<k) return query(k-t[t[root].l].val,t[root].r,mid+1,r);
		return query(k,t[root].l,l,mid);
	}
	#undef mid
}
struct tree
{
	struct node
	{
		int nxt,to,val;
	}e[114514<<1];
	int head[114514],cnt_edge;
	void add_edge(int u,int v,int w)
	{
		e[++cnt_edge].to=v;
		e[cnt_edge].nxt=head[u];
		e[cnt_edge].val=w;
		head[u]=cnt_edge;
	}
	int f[114514],top[114514],dep[114514],dis[114514],siz[114514],son[114514];
	void dfs1(int u,int fa,int op)
	{
		f[u]=fa;
		dep[u]=dep[fa]+1;
		siz[u]=1;
		if(op) Elaina::insert(u,1,Elaina::rt[u]);
		for(int i=head[u];i;i=e[i].nxt)
		{
			int v=e[i].to;
			if(v==fa) continue;
			dis[v]=dis[u]+e[i].val;
			dfs1(v,u,op);
			if(op) Elaina::rt[u]=Elaina::merge(Elaina::rt[u],Elaina::rt[v]);
			siz[u]+=siz[v];
			if(siz[v]>siz[son[u]]) son[u]=v;
		}
	}
	void dfs2(int u,int t)
	{
		top[u]=t;
		if(son[u]) dfs2(son[u],t);
		for(int i=head[u];i;i=e[i].nxt)
		{
			int v=e[i].to;
			if(v==f[u]||v==son[u]) continue;
			dfs2(v,v); 
		}
	}
	int lca(int x,int y)
	{
		while(top[x]!=top[y])
		{
			if(dep[top[x]]<dep[top[y]]) swap(x,y);
			x=f[top[x]];
		}
		return dep[x]<dep[y]?x:y;
	}
	int calc(int x,int y){return dis[x]+dis[y]-2*dis[lca(x,y)];}
}t[2];
int sum[114514],cnt;
int p[114514],rt[114514];
int f[114514][20];
pair<int,int>find(int id)
{
	int l=1,r=cnt;
	int res=0;
	while(l<=r)
	{
		int mid=l+r>>1;
		if(sum[mid]<id) res=mid,l=mid+1;
		else r=mid-1; 
	}
	++res;
	return {res,Elaina::query(id-sum[res-1],Elaina::rt[rt[res]])};
}
int findp(int x,int y){for(int i=19;~i;i--)if(t[1].dep[f[x][i]]>t[1].dep[y]) x=f[x][i];return x;}
signed main()
{
	read(n,m,q);
	for(int i=1;i<n;i++)
	{
		int u,v;
		read(u,v);
		t[0].add_edge(u,v,1);t[0].add_edge(v,u,1);
	}
	t[0].dfs1(1,0,1);t[0].dfs2(1,1);
	sum[++cnt]=n;rt[1]=1;
	for(int i=1;i<=m;i++)
	{
		int a,b;
		read(a,b);
		pair<int,int>tmp=find(b);
		++cnt;
		rt[cnt]=a;p[cnt]=tmp.second;f[cnt][0]=tmp.first;
		int w=t[0].dis[tmp.second]-t[0].dis[rt[tmp.first]]+1;
		t[1].add_edge(tmp.first,cnt,w);t[1].add_edge(cnt,tmp.first,w);
//		cout<<tmp.first<<" "<<cnt<<" "<<w<<endl;
		sum[cnt]=sum[cnt-1]+t[0].siz[a];
		for(int j=1;j<20;j++) f[cnt][j]=f[f[cnt][j-1]][j-1];
	}
	t[1].dfs1(1,0,0);t[1].dfs2(1,1);
	while(q--)
	{
		int x,y;
		read(x,y);
		pair<int,int>u=find(x),v=find(y);
//		cout<<u.first<<" "<<u.second<<" "<<v.first<<" "<<v.second<<endl;
		if(u.first==v.first)
		{
			write(t[0].calc(u.second,v.second));putch('\n');
			continue;
		}
		if(t[1].lca(u.first,v.first)==v.first) swap(u,v);
		int ans=0;
		if(t[1].lca(u.first,v.first)==u.first)
		{
			ans+=t[0].dis[v.second]-t[0].dis[rt[v.first]];
			ans+=t[1].calc(v.first,findp(v.first,u.first))+1;
			ans+=t[0].calc(p[findp(v.first,u.first)],u.second);
		}
		else
		{
			ans+=t[0].dis[u.second]-t[0].dis[rt[u.first]]+t[0].dis[v.second]-t[0].dis[rt[v.first]];
			int tmp=t[1].lca(u.first,v.first);
			ans+=t[1].calc(u.first,findp(u.first,tmp))+t[1].calc(v.first,findp(v.first,tmp))+2;
			ans+=t[0].calc(p[findp(u.first,tmp)],p[findp(v.first,tmp)]);
		}
		write(ans),putch('\n');
	}
	flush();
}
```

---

## 作者：Leap_Frog (赞：4)

### PS.
此题大毒瘤。  
此题个人感觉不是一个树套树，而是一个模拟题。  

### Problem.
首先给定一颗模板树和大树。  
大树初始为模板树。  
然后我们需要维护的操作：把模板树的一棵子树挂在大树上。  
挂了之后重新编号。  
**挂完所有操作之后**，给出查询。  
每次查询是询问大树上两个点的LCA。  

### Solution.
首先，此题操作就是把一个树套在另一棵树上，所以显然用树套树维护。  
首先，我们看一下数据范围，结果~~惊奇的~~发现：$N\le100000,M\le100000$，那么总共的大树节点是$N\times M\le10^{10}$，结果发现大树在最后根本存不下！~~然后当场自闭。~~  

那么大树存不下怎么办呢，我们考虑缩点。  
首先，我们发现，一个根节点和一个当前的编号数可以唯一确定一棵子树。  
我们可以考虑用在模板树上的根节点和编号来表示一颗子树，然后直接记录它的根节点和当前的大树节点数目。  
就有了一棵$M+1$个节点的缩点树。  
然后给定一个序号，我们能通过二分查找直接找到它的父亲节点。  
然后我们就把所有修改操作处理好了。  

然后我们考虑询问操作。  
我们需要找到大树上的两个节点的 LCA ，应该怎么找呢。  
首先，我们可以先对于模板树和大树分别做一遍 LCA 。  
模板树的边权是1，大树的边权是1，点权缩点内的点到根的距离。  
然后又可以把大树的点权加到下面那条边上。  
然后最终答案就出来了，首先先分别跳两个点，跳到当前缩点的根，在模板树上操作，然后从当前缩点的根开始跳祖先，跳到LCA的儿子，然后再回到模板树上跳，跳它们直系父亲的LCA。  

但是这里还有一个问题，如果给定一个大树上的编号，目前无法求出在模板树上对应的点。  
我们来思考一下如何解决这个问题。  
首先我们先把那个编号减去之前的cnt值得到当前这个节点在这棵子树里是第几大。  
然后我们需要查询模板树上的子树第k大，而且还没有修改。  
显然用主席树维护DFN序。  

然后这题才做完。  

相当于此题需要维护三棵树，一颗模板树，一颗大树，还有一颗主席树，真是毒瘤，虽然没有套在一起。  

### Coding.
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int bs(int x) {return x>0?x:-x;}
namespace zxs//主席树的名字空间
{
	struct node{int ls,rs,val;}t[10000005];
	int rt[100005],tot=0;
	inline void build(int &x,int l,int r) {x=++tot;if(l==r) return;else build(t[x].ls,l,(l+r)>>1),build(t[x].rs,((l+r)>>1)+1,r);}//主席树建树
	inline void chang(int old,int &now,int l,int r,int w)
	{
		t[now=++tot]=t[old],t[now].val++;if(l==r) return;
		if(w<=((l+r)>>1)) chang(t[old].ls,t[now].ls,l,(l+r)>>1,w);else chang(t[old].rs,t[now].rs,((l+r)>>1)+1,r,w);
	}//主席树修改
	inline int query(int xl,int xr,int l,int r,int w)
	{
		int c=t[t[xr].ls].val-t[t[xl].ls].val;if(l==r) return l;
		if(w<=c) return query(t[xl].ls,t[xr].ls,l,(l+r)>>1,w);else return query(t[xl].rs,t[xr].rs,((l+r)>>1)+1,r,w-c);
	}//主席树查询
}
namespace mbs//模板树的名字空间
{
	struct edge{int to,nxt;}e[200005];int n,tot,cnt,dfn[100005],nfd[100005],siz[100005],head[100005],f[100005][35],dep[100005];
	inline void init() {tot=cnt=0,memset(head,0,sizeof(head)),dep[0]=0;}//初始化
	inline void adde(int x,int y) {e[++tot]=(edge){y,head[x]},head[x]=tot;}//加边
	inline void dfs(int x,int fa=0)//dfs得到倍增
	{
		dfn[++cnt]=x,nfd[x]=cnt,dep[x]=dep[fa]+1,f[x][0]=fa,siz[x]=1;
		for(int i=1;i<=25;i++) f[x][i]=f[f[x][i-1]][i-1];
		for(int i=head[x];i;i=e[i].nxt) if(e[i].to!=fa) dfs(e[i].to,x),siz[x]+=siz[e[i].to];
	}
	inline void build()//对dfn建主席树
	{
		zxs::build(zxs::rt[0],1,n);
		for(int i=1;i<=n;i++) zxs::chang(zxs::rt[i-1],zxs::rt[i],1,n,dfn[i]);
	}
	inline int lca(int x,int y)//模板树上LCA
	{
		int res=0;if(dep[x]<dep[y]) swap(x,y);
		for(int i=25;i>=0;i--) if(dep[f[x][i]]>=dep[y]) res+=(1<<i),x=f[x][i];
		for(int i=25;i>=0;i--) if(f[x][i]!=f[y][i]) res+=(1<<(i+1)),x=f[x][i],y=f[y][i];
		if(x==y) return res;else return res+2;
	}
	inline void read()
	{
		for(int i=1,x,y;i<n;i++) scanf("%lld%lld",&x,&y),adde(x,y),adde(y,x);
		dep[0]=0,dfs(1,0),build();
	}
}
namespace ds//大树的名字空间
{
	int n,m,cnt,f[100005][35],dis[100005][35],dep[100005],lst[100005],dfn[100005],nfd[100005],hd[100005];
	inline int getrt(int x)//得到一个节点所对应的根，用二分查找
	{
		int l=1,r=n;
		while(l<=r) dfn[(l+r)>>1]<=x?l=((l+r)>>1)+1:r=((l+r)>>1)-1;
		return r;
	}
	inline int getlst(int x)//得到一个节点的祖先
	{
		int rt=getrt(x);
		return zxs::query(zxs::rt[mbs::nfd[lst[rt]]-1],zxs::rt[mbs::nfd[lst[rt]]+mbs::siz[lst[rt]]-1],1,mbs::n,x-dfn[rt]+1);
	}
	inline void build()//建立LCA
	{
		n=1,dep[1]=1,lst[1]=1,dfn[1]=1,cnt=nfd[1]=mbs::n;
		for(int i=1,x,y,rt;i<=m;i++)
		{
			scanf("%lld%lld",&x,&y),rt=getrt(y),dep[++n]=dep[rt]+1,hd[n]=y,lst[n]=x,dfn[n]=cnt+1;
			nfd[n]=cnt+mbs::nfd[x]+mbs::siz[x]-mbs::nfd[x],cnt=nfd[n],f[n][0]=rt,dis[n][0]=mbs::dep[getlst(y)]-mbs::dep[lst[rt]]+1;
			for(int j=1;j<=25;j++) f[n][j]=f[f[n][j-1]][j-1],dis[n][j]=dis[f[n][j-1]][j-1]+dis[n][j-1];
		}
	}
	inline int work(int x,int y)//查询答案
	{
		int res=0,rx=getrt(x),ry=getrt(y);
		if(rx==ry) return mbs::lca(getlst(x),getlst(y));
		if(dep[rx]<dep[ry]) swap(x,y),swap(rx,ry);
		res+=mbs::dep[getlst(x)]-mbs::dep[lst[rx]],x=rx;
		for(int i=25;i>=0;i--) if(dep[f[x][i]]>dep[ry]) res+=dis[x][i],x=f[x][i];
		if(getrt(hd[x])==ry) return res+1+mbs::lca(getlst(hd[x]),getlst(y));
		res+=mbs::dep[getlst(y)]-mbs::dep[lst[ry]],y=ry;
		if(dep[x]>dep[y]) res+=dis[x][0],x=f[x][0];
		for(int i=25;i>=0;i--) if(f[x][i]!=f[y][i]) res+=dis[x][i]+dis[y][i],x=f[x][i],y=f[y][i];
		return x=hd[x],y=hd[y],res+2+mbs::lca(getlst(x),getlst(y));
	}
}
signed main()
{//主函数没什么好解释的了吧
	int q;scanf("%lld%lld%lld",&mbs::n,&ds::m,&q),mbs::read(),ds::build();
	for(int x,y;q--;) scanf("%lld%lld",&x,&y),printf("%lld\n",ds::work(x,y));
	return 0;
}
```
~~完结散花，无耻求赞~~

---

## 作者：Kelin (赞：4)

## [题意](https://blog.csdn.net/BeNoble_/article/details/79785925)

给你一颗模板树,一颗大树初始等于模板树

先有一堆操作表示把模板树中以$u$为根的子树复制一下接到大树的第$y$号节点上

然后进行重新标号,新节点的编号$=$大树原总结点数$+$**这个节点在模板树那颗子树里的排名**

然后一堆询问.问大树上两个节点的距离

---

## 题解

一道~~十分毒瘤并且不好实现的~~代码题

#### 建树

我们把大树上的每一整块缩成一个点,这样大树的点数就是线性的了(下面的图都是样例)

![这里写图片描述](https://img-blog.csdn.net/20180402092738751?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JlTm9ibGVf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

我们可以预处理两个块根节点之间的信息,然后其他的信息可以在原树中得到

我们先考虑一个问题,就是如何把大树中的点的编号转化成原树中的点的编号

可以发现我们只要记录一下所有块的起始编号,记为数组$begin$

因为$begin$是递增的,所以我们可以二分求出这个点属于哪个块了

我们用大树中这个点的标号$-$这个块起始的编号$+1$就是这个点在原子树中的排名了

>$e.g.$样例$begin$数组是$1\ 6\ 9$

>假设询问$7$,二分可以得到这个点属于$1$号块

>这个点的排名就是$7-begin_1+1=2$

>在原树中以$4$为根的子树排名为$2$的点就是$4$

所以我们就需要用主席树来实现求树上第$k$大了(窝是按照二进制位来写的)

考虑一下怎么维护两个块根节点之间的距离

就是$dep[y$在原树中所代表的点$]-dep[y$所属的块的根节点在原树中代表的点$]+1$


![这里写图片描述](https://img-blog.csdn.net/20180402095542252?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JlTm9ibGVf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

所以我们还要记录一个东西,$from$表示$y$在原树中所代表的点

然后我们在对这棵缩点后的树$dfs$预处理长度信息

#### 考虑询问怎么办$?$

假设询问$dis(x,y),$设$belong(x)=u,belong(y)=v,w=lca(u,v)$

$1.$如果询问的两个点在同一个块里,那么可以直接在原树中查询了

$2.$如果两点不在同一个块里,主要的想法就是把他们都跳到$w$块里,然后再在原树上查询

只考虑其中一个点$x$,另一个点类似

①:$u=w,$那么可以直接令$u=id(x)$,然后返回了

②:$u\neq w,$我们找到$w\to u$中的第一个点$z$,我们处理$x\to u\to z\to from_z$的距离,然后令$u=from_z$即可

>$x\to u$的距离就是原树中$dis(id(x),root[u])$

>$u\to z$的距离是建树时$dfs$可以预处理出来的

>$z\to from_z$的距离就是$1$

给几张图理解一下

![这里写图片描述](https://img-blog.csdn.net/20180402104218828?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JlTm9ibGVf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![这里写图片描述](https://img-blog.csdn.net/20180402104210992?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JlTm9ibGVf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![这里写图片描述](https://img-blog.csdn.net/20180402104451499?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JlTm9ibGVf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

对于$y$做同样的处理,最后$ans+=$原树中$dis(u,v)$就可以了

```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){return A==B&&(B=(A=ss)+fread(ss,1,1<<17,stdin),A==B)?-1:*A++;}
template<class T>inline void sd(T&x){
    char c;T y=1;while(c=gc(),(c<48||57<c)&&c!=-1)if(c==45)y=-1;x=c-48;
    while(c=gc(),47<c&&c<58)x=x*10+c-48;x*=y;
}
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
template<class T>inline void we(T x){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
const int N=1e5+5,M=2e5+5;
typedef int arr[N];
typedef long long ll;
struct eg{int nx,to;};
struct Pt{int sz;Pt*ch[2];};
int n,m,q;
struct Real{
    int dft,H;arr fi,fa,sz,son,top,dep,lef,rig;
    Pt tr[N*20],*pt,*T[N];eg e[M];
    inline Pt*ins(Pt*B,const int x){
        Pt*A=++pt,*tp=A;int d;
        fd(i,H,0){d=(x>>i)&1;
            A->sz=B->sz+1;
            A->ch[!d]=B->ch[!d];
            A=A->ch[d]=++pt;B=B->ch[d];
        }A->sz=B->sz+1;
        return tp;
    }
    void dfs(int u){
        dep[u]=dep[fa[u]]+(sz[u]=1);
        go(u)if(v^fa[u]){
            fa[v]=u;dfs(v);sz[u]+=sz[v];
            if(sz[v]>sz[son[u]])son[u]=v;
        }
    }
    void dfs(int u,int t){
        lef[u]=++dft;T[dft]=ins(T[dft-1],u);
        top[u]=t;if(son[u])dfs(son[u],t);
        go(u)if(v^fa[u]&&v^son[u])dfs(v,v);rig[u]=dft;
    }
    inline int lca(int u,int v){
        for(;top[u]^top[v];dep[top[u]]>dep[top[v]]?u=fa[top[u]]:v=fa[top[v]]);
        return dep[u]<dep[v]?u:v;
    }
    inline int dis(int u,int v){return dep[u]+dep[v]-(dep[lca(u,v)]<<1);}
    inline void add(int u,int v){static int ce=0;e[++ce]={fi[u],v},fi[u]=ce;}
    inline void init(){
        int u,v;H=log2(n)+1;pt=tr;
        *(T[0]=tr)=(Pt){0,tr,tr};
        fp(i,2,n)sd(u),sd(v),add(u,v),add(v,u);
        dfs(1),dfs(1,1);
    }
    inline int qry(int u,int k){
        Pt*A=T[lef[u]-1],*B=T[rig[u]];int sp,tp=0;
        fd(i,H,0){
            sp=B->ch[0]->sz-A->ch[0]->sz;
            if(k<=sp)A=A->ch[0],B=B->ch[0];
            else k-=sp,tp|=1<<i,A=A->ch[1],B=B->ch[1];
        }return tp;
    }
}t1;
struct Vitual{
    eg e[N];int A;arr fi,fa,rt,sz,dep,son,top,from;ll len[N],bg[N];
    void dfs(int u){
        dep[u]=dep[fa[u]]+(sz[u]=1);
        go(u){
            dfs(v);sz[u]+=sz[v];
            if(sz[v]>sz[son[u]])son[u]=v;
        }
    }
    void dfs(int u,int t){
        top[u]=t;if(son[u])dfs(son[u],t);
        go(u)if(v^son[u])dfs(v,v);
    }
    inline int lca(int u,int v){
        for(;top[u]^top[v];dep[top[u]]>dep[top[v]]?u=fa[top[u]]:v=fa[top[v]]);
        return dep[u]<dep[v]?u:v;
    }
    inline int Go(int u,int f){
        while(top[u]^top[f]){u=top[u];if(fa[u]==f)return u;u=fa[u];}
        return son[f];
    }
    inline void add(int u,int v,int w){static int ce=0;e[++ce]={fi[u],v},fi[u]=ce;len[v]=len[u]+w;}
    inline int bl(ll x){return upper_bound(bg,bg+A+1,x)-bg-1;}
    inline int RealId(ll x){
        if(x<bg[1])return x;
        int b=bl(x),k=x-bg[b]+1;
        if(rt[b]==1)return k;
        return t1.qry(rt[b],k);
    }
    inline void sol(){
        ll Cnt=n,y;bg[0]=rt[0]=1;
        fp(i,1,m){
            A=i;sd(rt[i]),sd(y);
            bg[i]=Cnt+1;Cnt+=t1.sz[rt[i]];
            from[i]=RealId(y);fa[i]=bl(y);
            add(fa[i],i,t1.dep[from[i]]-t1.dep[rt[fa[i]]]+1);
        }dfs(0),dfs(0,0);
        ll x,ans=0;int u,v,w;
        while(q--){
            sd(x),sd(y);u=bl(x),v=bl(y);
            if(u==v){we(t1.dis(RealId(x),RealId(y)));continue;}
            w=lca(u,v);ans=0;
            if(u^w){
                int _=Go(u,w);
                ans+=len[u]-len[_]+1+t1.dep[RealId(x)]-t1.dep[rt[u]];
                u=from[_];
            }else u=RealId(x);
            if(v^w){
                int _=Go(v,w);
                ans+=len[v]-len[_]+1+t1.dep[RealId(y)]-t1.dep[rt[v]];
                v=from[_];
            }else v=RealId(y);
            ans+=t1.dis(u,v);
            we(ans);
        }
    }
}t2;
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    sd(n),sd(m),sd(q);
    t1.init();t2.sol();
return Ot(),0;
}
```

---

## 作者：CuriousCat (赞：3)

其他的题解写得很详细了我就写下我的实现方法吧，感觉好像好写不少qwq
本质上我们只需要实现两个操作

1.lca

2.深度

我平常求lca都是这样的

```
int lca(int u, int v) {
	if (dep[u] < dep[v]) swap(u, v);
	dec(k, K - 1, 0) if (dep[prt[u][k]] >= dep[v]) u = prt[u][k];
	if (u == v) return u;
	dec(k, K - 1, 0) if (prt[u][k] != prt[v][k]) 
		u = prt[u][k], v = prt[v][k];
	return prt[u][0];
}
```
但是在这颗毒瘤树上并不好做，所以我们退而求其次，只求出缩点后的树上的lca

然后再利用这个函数，找到lca的接入点
```
int get_to(int v, int x) {
	int b = belong(v);
	if (b == x) return v;
	dec(k, K - 1, 0) if (lev[pr[b][k]] > lev[x]) {
		b = pr[b][k];
	}
	return ori[b];
}
```
lev就是depth数组

然后利用这种暴力从2^k->2^0枚举的思路就能降低不少复杂度qwq

2.深度
需要找到这个点属于缩掉的哪个点
```
int depth(int v) {
	int b = belong(v);
	int o = tr[b];
	int z = kth(o, v - arr[b] + 1);
	return dp[b] + dep[z] - dep[o];
}
```
懒得开两颗树了然后变量名就有点毒瘤
不压行的代码奉上qwq

```
// luogu-judger-enable-o2
#include <bits/stdc++.h>
#define pb push_back
#define cmin(a, b) (a > b ? a = b : a)
#define cmax(a, b) (a < b ? a = b : a)
#define lop(i, s, t) for(int i = s;i < (t);++i)
#define rep(i, s, t) for(int i = s;i <= (t);++i)
#define dec(i, s, t) for(int i = s;i >= (t);--i)
using namespace std;

const int N = 2e5 + 50, K = 20;

typedef int inte;
#define int long long

void read(int &x) {
    scanf("%lld", &x);
}

int n, m, q;

const int S = N * K;
int rt[N], sum[S], ls[S], rs[S], vn;
int new_from(int o) {
    ++vn;
    sum[vn] = sum[o];
    ls[vn] = ls[o];
    rs[vn] = rs[o];
    return vn;
}
void update(int &v, int o, int l, int r, int p) {
    v = new_from(o);
    ++sum[v];
    if (l == r) return;
    else {
        int mid = (l + r) >> 1;
        if (p <= mid) update(ls[v], ls[o], l, mid, p); 
        else update(rs[v], rs[o], mid + 1, r, p);
    }
}
int kth(int vl, int vr, int l, int r, int k) {
    if (l == r) return l;
    else {
        int mid = (l + r) >> 1;
        int s = sum[ls[vr]] - sum[ls[vl]];
        if (k <= s) return kth(ls[vl], ls[vr], l, mid, k); 
        else return kth(rs[vl], rs[vr], mid + 1, r, k - s);
    }
}
struct E { int d, w, nxt; } es[N << 1];
int g[N], en;
int dep[N], siz[N], clk;
int seq[N], plc[N], prt[N][K];
void add(int s, int d, int w = 0) {
    es[++en] = (E) { d, w, g[s] };
    g[s] = en;
}
void dfs(int v, int p) {
    siz[v] = 1;
    prt[v][0] = p;
    plc[v] = ++clk;
    seq[clk] = v;
    dep[v] = dep[p] + 1;
    lop(k, 1, K) prt[v][k] = prt[prt[v][k - 1]][k - 1];
    for (int i = g[v];i;i = es[i].nxt) {
        int d = es[i].d;
        if (d == p) continue;
        dfs(d, v); 
        siz[v] += siz[d];
    }
}
int kth(int v, int k) {
    return kth(rt[plc[v] - 1], rt[plc[v] + siz[v] - 1], 1, n, k);
}
int lca(int u, int v) {
    if (dep[u] < dep[v]) swap(u, v);
    dec(k, K - 1, 0) if (dep[prt[u][k]] >= dep[v]) u = prt[u][k];
    if (u == v) return u;
    dec(k, K - 1, 0) if (prt[u][k] != prt[v][k]) 
        u = prt[u][k], v = prt[v][k];
    return prt[u][0];
}
int arr[N], top, tr[N], tot, pr[N][K], dp[N], ori[N], lev[N];
int belong(int v) {
    int p = upper_bound(arr + 1, arr + top + 1, v) - arr - 1;
    return p;
}
int orignal(int v) {
    int b = belong(v);
    int o = tr[b];
    int z = kth(o, v - arr[b] + 1);
    return z;
}
int depth(int v) {
    int b = belong(v);
    int o = tr[b];
    int z = kth(o, v - arr[b] + 1);
    return dp[b] + dep[z] - dep[o];
}
void link(int v, int p) {
    int u = ++top;
    arr[u] = tot + 1;
    tr[u] = v;
    tot += siz[v];
    ori[u] = p;
    int b = belong(p);
    pr[u][0] = b;
    lev[u] = lev[b] + 1;
    lop(k, 1, K) pr[u][k] = pr[pr[u][k - 1]][k - 1];
    dp[u] = depth(p) + 1;
}
int get_to(int v, int x) {
    int b = belong(v);
    if (b == x) return v;
    dec(k, K - 1, 0) if (lev[pr[b][k]] > lev[x]) {
        b = pr[b][k];
    }
    return ori[b];
}
int distance(int u, int v) {
    int x = belong(u), y = belong(v), l;
    if (lev[x] < lev[y]) swap(x, y);
    dec(k, K - 1, 0) if (lev[pr[x][k]] >= lev[y]) x = pr[x][k];
    if (x != y) {
        dec(k, K - 1, 0) if (pr[x][k] != pr[y][k]) {
            x = pr[x][k], y = pr[y][k];
        }
        l = pr[x][0];
    } else l = x;
    int uu = get_to(u, l);
    int vv = get_to(v, l);
    int b = belong(uu);
    uu = orignal(uu), vv = orignal(vv);
    int d = dp[b] + dep[lca(uu, vv)] - dep[tr[b]];
    return depth(u) + depth(v) - 2 * d;
}

inte main(inte argc,char *argv[]){
#ifndef ONLINE_JUDGE
    freopen("dat.in","r",stdin); 
    freopen("my.out","w",stdout); 
#endif
    read(n), read(m), read(q);
    rep(i, 2, n) {
        int u, v; 
        read(u), read(v);
        add(u, v); 
        add(v, u);
    }
    dfs(1, 0); 
    rep(i, 1, n) {
        update(rt[i], rt[i - 1], 1, n, seq[i]);
    }
    tot = n;
    top = 1;
    arr[1] = 1;
    tr[1] = 1;
    dp[1] = 1;
    lev[1] = 1;
    while (m--) {
        int x, to;
        read(x), read(to);
        link(x, to);
    }
    while (q--) {
        int x, y;
        read(x), read(y);
        printf("%lld\n", distance(x, y));
    }
    return 0; 
}

```

---

## 作者：Rem_CandleFire (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P3248)

### 题目大意

初始一棵树，复制子树接入，求最终树上任意两点的距离。

### 分析与做法

注意到数据范围 $N,M,Q\le10^5$，不能直接建树。

考虑树套树（物理），把模板树看做节点 $1$，每操作一次就认为是新建了一个节点 $i$，其代表复制的子树，从而得到一棵有 $M+1$ 个节点的大树。

于是，我们需要实现：对于每个询问给出的 $x,y$，得到 $x,y$ 属于的大节点编号，在大树上跳 $lca(x,y)$ 并计算距离，最后在 $lca$ 所代表的子树内加上最后的距离。

也就是说，$dis(x,y)$ 分为：$x,y$ 分别到大节点内子树根的距离，大树距离，$lca$ 中小树距离。

注意到最终树的每一个节点都是从模板树得到的，所以需要映射关系指向模板树。

为了达到目的，我们需要求以下内容：

- 对于点 $x$，其属于的大节点编号。
- 小节点 $x$ 到其小树根的距离。
- 大、小树上 LCA。

于是考虑维护：

- $Pre_i$，大节点 $i$ 对应模板树上以 $Pre_i$ 为根的子树。
- $Link_i$，大节点 $i$ 为最终树上节点 $Link_i$ 的子树。
- $S_i,T_i$，大节点 $i$ 内的小树编号范围为 $S_i\rightarrow T_i$。
- vector 存大树、模板树的连边。
- 模板树、大树上 dfs 与 LCA 的相关数组。
- $Bdis_{u,i}$，帮助我们在大树上计算距离（因为我们相当于把最终树的一个个部分缩成的大节点，所以大节点内部的距离也要算）。

这样一来，我们就可以：

- $get\_root(x)$，使用数组 $S_i,T_i$ 二分得到小节点 $x$ 对应的大节点编号。
- $find(Bx,x)$，求大节点 $Bx$ 中的节点 $x$ 在模板树上对应的节点，注意到编号规则是按大小顺序，所以模板树的 dfs 序用主席树维护即可。
- 在求 LCA 的过程中计算距离。

思路简单，代码需要注意细节，注意开 **long long**。

### code

```cpp
#include<bits/stdc++.h>
#define int long long
#define ll long long
using namespace std;
const int N=2e5+5;
int n,m,q,id,tim,cnt,ans;
vector<int> Mg[N],Bg[N];
int rt[N]; 
int Mdep[N],Mfa[N][25],Msiz[N],Min[N],Mout[N],Ref[N];
int Pre[N],Link[N],S[N],T[N],Bdep[N],Bfa[N][25],Bvis[N],Bdis[N][25];
int get_root(int x) // 求构造树的节点x属于的大树节点 
{
	int l=1,r=m,pos=0;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(S[mid]<=x&&x<=T[mid]){ pos=mid; break;}
		if(S[mid]>x) r=mid-1;
		if(T[mid]<x) l=mid+1;
	}
	return pos;
}
struct tree{
	int ls,rs,num;
}tr[N*24];
int update(int p,int l,int r,int x)
{
	int k=++cnt; tr[k]=tr[p];
	if(l==r) { tr[k].num++; return k; }
	int mid=(l+r)>>1;
	if(x<=mid) tr[k].ls=update(tr[p].ls,l,mid,x);
	else tr[k].rs=update(tr[p].rs,mid+1,r,x);
	tr[k].num=tr[tr[k].ls].num+tr[tr[k].rs].num;
	return k;
}
int query(int x,int y,int l,int r,int k)
{
	if(l==r) return l;
	int num=tr[tr[y].ls].num-tr[tr[x].ls].num;
	int mid=(l+r)>>1;
	if(num>=k) return query(tr[x].ls,tr[y].ls,l,mid,k);
	else return query(tr[x].rs,tr[y].rs,mid+1,r,k-num);
}
int find(int Brx,int x)
	{ return query(rt[Min[Pre[Brx]]-1],rt[Mout[Pre[Brx]]],1,n,x-S[Brx]+1); }
void Mode_dfs(int u,int las) //模板树上dfs 
{
	Mfa[u][0]=las;
	for(int i=1;i<=19;i++) Mfa[u][i]=Mfa[Mfa[u][i-1]][i-1];
	Mdep[u]=Mdep[las]+1;
	Msiz[u]=1; 
	Min[u]=++tim; Ref[tim]=u; 
	for(int i=0;i<Mg[u].size();i++)
	{
		int v=Mg[u][i];
		if(v==las) continue;
		Mode_dfs(v,u);
		Msiz[u]+=Msiz[v];
	}
	Mout[u]=tim;
}
void Big_dfs(int u,int las) // 大树上dfs 
{
	Bfa[u][0]=las; Bvis[u]=1; 
	Bdis[u][0]=Mdep[find(las,Link[u])]-Mdep[Pre[las]]; 
	for(int i=1;i<=19;i++) 
		Bfa[u][i]=Bfa[Bfa[u][i-1]][i-1],
		Bdis[u][i]=Bdis[u][i-1]+Bdis[Bfa[u][i-1]][i-1];
	Bdep[u]=Bdep[las]+1;
	for(int i=0;i<Bg[u].size();i++)
	{	
		int v=Bg[u][i];
		if(Bvis[v]) continue;
		Big_dfs(v,u);
	}
}
int B_dist(int x,int y) // LCA求大树上距离 
{
	if(Bdep[x]<Bdep[y]) swap(x,y);
	for(int i=19;i>=0;i--)
		if(Bdep[Bfa[x][i]]>=Bdep[y]) 
			ans+=(1<<i),x=Bfa[x][i];
	if(x==y) return x;
	for(int i=19;i>=0;i--)
		if(Bfa[x][i]!=Bfa[y][i])
			ans+=(1<<i+1),x=Bfa[x][i],y=Bfa[y][i];
	ans+=2;
	return Bfa[x][0];
}
int M_dist(int x,int y) // LCA求小树内距离 
{
	if(Mdep[x]<Mdep[y]) swap(x,y);
	for(int i=19;i>=0;i--)
		if(Mdep[Mfa[x][i]]>=Mdep[y])
			ans+=(1<<i),x=Mfa[x][i];
	if(x==y) return ans;
	for(int i=19;i>=0;i--)
		if(Mfa[x][i]!=Mfa[y][i])
			ans+=(1<<i+1),x=Mfa[x][i],y=Mfa[y][i];
	ans+=2; 
	return ans;
}
signed main()
{
	scanf("%lld%lld%lld",&n,&m,&q);
	int x,y;
	for(int i=1;i<n;i++)
	{
		scanf("%lld%lld",&x,&y);
		Mg[x].push_back(y);
		Mg[y].push_back(x);
	}
	Mode_dfs(1,0); id=n+1;
	for(int i=1;i<=n;i++)
		rt[i]=update(rt[i-1],1,n,Ref[i]); //dfs序第i个作为版本插入对应节点 
	for(int i=1;i<=m;i++)
	{
		scanf("%lld%lld",&x,&y);
		Pre[i+1]=x; Link[i+1]=y;
		S[i+1]=id; id+=Msiz[x]; T[i+1]=id-1;
	}
	Pre[1]=Link[1]=1; S[1]=1; T[1]=n; m++;
	for(int i=1;i<=m;i++)
	{
		int rt=get_root(Link[i]); 
		Bg[rt].push_back(i);
	}
	Big_dfs(1,0);
	int Brx,rx,Bry,ry,tx,ty,lca;
	for(int i=1;i<=q;i++)
	{
		scanf("%lld%lld",&x,&y); ans=0; 
		Brx=get_root(x); Bry=get_root(y);
		if(Bdep[Brx]<Bdep[Bry]) swap(Brx,Bry),swap(x,y); // 保证x为更低的节点 
		rx=find(Brx,x); ry=find(Bry,y); // 求对应节点 
		if(Brx==Bry) { printf("%lld\n",M_dist(rx,ry)); continue; } // 在同一大节点内 
		lca=B_dist(Brx,Bry); // 求大树上的LCA ，顺便计算距离 
		ans+=Mdep[rx]-Mdep[Pre[Brx]]; // 低节点x到对应根的距离一定算入答案 
		if(lca!=Bry) ans+=Mdep[ry]-Mdep[Pre[Bry]];
		for(int i=19;i>=0;i--) // 倍增跳Link，转移到同一个大节点内 
		{
			if(Bdep[Bfa[Brx][i]]>Bdep[lca]) ans+=Bdis[Brx][i],Brx=Bfa[Brx][i];
			if(Bdep[Bfa[Bry][i]]>Bdep[lca]) ans+=Bdis[Bry][i],Bry=Bfa[Bry][i];
		}
		rx=find(lca,Link[Brx]); ry=find(lca,y);
		if(lca!=Bry) ry=find(lca,Link[Bry]); // 在同一大节点内对应的节点（特判链） 
		ans=M_dist(rx,ry);
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：tribool4_in (赞：2)

首先观察复制的过程，若每次复制整棵树，复制 $10^5$ 次，总结点数可到达 $10^{10}$ 的级别，因此肯定不能将整棵树存下。

考虑每次复制的都为原树（模板树）的一棵子树，可以将复制出来的子树作为一个结点，记录子树的根，使得整棵树结构为“树套树”。然后在求两点之间距离时，大部分路径可以直接在大树上面倍增，边界位置（即 $u$ 和 $v$ 所在的大结点内部以及 $\operatorname{LCA}$ 内部）的距离可以在模板树上求解。

对于每个大树的结点，记录该结点对应的子树的 $\operatorname{dfn}$ 范围，这样就可以通过二分求出任意结点对应的大树结点。另外还要记录每个结点对应的子树中的根结点编号和最小结点的 $\operatorname{dfn}$，便于求出最终树中某个结点对应的模板树结点编号。

至于如何求出某个结点对应的模板树结点编号，注意到一个子树中的结点编号与模板树中对应子树中的结点编号顺序一致。考虑以 $\operatorname{dfn}$ 为版本，结点编号作为值域建立**可持久化平衡树**，可以利用前面记录的信息求出子树内（$\operatorname{dfn}$ 连续的一段）的第 $k$ 小值，也就是对应模板树结点编号。

另外还有很多细节需要进行特判（也可能是我写的太乱），例如当倍增时 $u$ 为 $v$ 的祖先时的情况，以及当两个大树结点为祖孙关系时是否都要计算到内部根节点的路径 等。

代码实现的很混乱，去掉注释写了 8.3 kb。

```cpp
#include <bits/stdc++.h>
#define int long long
#define println(x) print(x), putchar('\n')
#define printsp(x) print(x), putchar(' ')
#define printpa(x, y) printsp(x), println(y)
#define debug(x) printf(#x" = %d\n", x)
using namespace std;
const int N = 1e6 + 10, mod = 1e9 + 7, pid = 3248;
inline int read() {
    int x = 0, f = 1; char c = getchar();
    while (!isdigit(c)) { if (c == '-') f = -1; c = getchar(); }
    while (isdigit(c)) x = x * 10 + c - '0', c = getchar();
    return x * f;
}
inline void readstr(char *s) {
    char c = getchar(); int pt = 0;
    while (c != ' ' && c != '\n') s[pt++] = c, c = getchar();
}
void print(int x) {
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) print(x / 10);
    putchar(x % 10 + '0');
}
int n, m, q;
vector<int> G[N];
namespace inner {
    struct node {
        int l, r, sum;
    } t[N << 2]; int tot = 0;
    int clone(int id) {
        t[++tot] = t[id];
        return tot;
    }
    void push_up(int id) {
        t[id].sum = t[t[id].l].sum + t[t[id].r].sum;
    }
    int build(int l, int r) {
        int id = ++tot;
        if (l == r) {
            t[id].sum = 0;
            return id;
        }
        int mid = (l + r) >> 1;
        t[id].l = build(l, mid);
        t[id].r = build(mid + 1, r);
        push_up(id);
        return id;
    }
    int update(int id, int l, int r, int x, int v) {
        id = clone(id);
        if (l == r) {
            t[id].sum += v;
            return id;
        }
        int mid = (l + r) >> 1;
        if (x <= mid) t[id].l = update(t[id].l, l, mid, x, v);
        else t[id].r = update(t[id].r, mid + 1, r, x, v);
        push_up(id);
        return id;
    }
    int query(int id, int l, int r, int x, int y) {
        if (x <= l && r <= y) {
            return t[id].sum;
        }
        int mid = (l + r) >> 1, res = 0;
        if (x <= mid) res += query(t[id].l, l, mid, x, y);
        if (mid < y) res += query(t[id].r, mid + 1, r, x, y);
        return res;
    }
    int querykth(int idx, int idy, int l, int r, int k) {
        if (l == r) return l;
        int mid = (l + r) >> 1;
        int sum = t[t[idy].l].sum - t[t[idx].l].sum;
        if (k <= sum) {
            return querykth(t[idx].l, t[idy].l, l, mid, k);
        } else {
            return querykth(t[idx].r, t[idy].r, mid + 1, r, k - sum);
        }
    }

    int f[N][31], d[N], siz[N];
    int dfn[N], idfn[N], dfns;
    int root[N];
    void make_ptree() {
        root[0] = build(1, n); // ?
        for (int i = 1; i <= n; i++) {
            root[i] = update(root[i - 1], 1, n, idfn[i], 1);
        }
    }

    void dfs(int u, int fa) {
        f[u][0] = fa; d[u] = d[fa] + 1; siz[u] = 1;
        dfn[u] = ++dfns; idfn[dfns] = u;
        for (int i = 0; i < G[u].size(); i++) {
            int v = G[u][i];
            if (v == fa) continue;
            dfs(v, u);
            siz[u] += siz[v];
        }
    }
    void init_lca() {
        for (int j = 1; j <= 20; j++) {
            for (int i = 1; i <= n; i++) {
                f[i][j] = f[f[i][j - 1]][j - 1];
            }
        }
    }
    int lca(int u, int v) {
        if (d[u] < d[v]) swap(u, v);
        for (int i = 20; i >= 0; i--) {
            if (d[f[u][i]] >= d[v]) {
                u = f[u][i];
            }
        }
        if (u == v) return u;
        for (int i = 20; i >= 0; i--) {
            if (f[u][i] != f[v][i]) {
                u = f[u][i];
                v = f[v][i];
            }
        }
        return f[u][0];
    }
    int get_dis(int u, int v) {
        int l = lca(u, v);
        return d[u] + d[v] - d[l] * 2;
    }

    int query_subtree_kth(int u, int k) {
        return querykth(root[dfn[u] - 1], root[dfn[u] + siz[u] - 1], 1, n, k);
    }
}

pair<int, int> dfn_range[N]; int cnt;
namespace outer {
    struct node {
        int v, w;
    };
    vector<node> H[N];
    void add_edge(int u, int v, int w) {
        H[u].push_back((node){v, w});
        H[v].push_back((node){u, w});
    }
    int f[N][31], d[N], dis[N];

    void dfs(int u, int fa, int fw) {
        f[u][0] = fa; d[u] = d[fa] + 1; dis[u] = dis[fa] + fw;
        for (int i = 0; i < H[u].size(); i++) {
            int v = H[u][i].v;
            if (v == fa) continue;
            dfs(v, u, H[u][i].w);
        }
    }
    void init_lca() {
        for (int j = 1; j <= 20; j++) {
            for (int i = 1; i <= cnt; i++) {
                f[i][j] = f[f[i][j - 1]][j - 1];
            }
        }
    }
    pair<int, pair<int, int> > lca(int u, int v) {
        bool flag = 0;
        if (d[u] < d[v]) swap(u, v), flag = 1;
        for (int i = 20; i >= 0; i--) {
            if (d[f[u][i]] > d[v]) {
                u = f[u][i];
            }
        }
        if (f[u][0] == v) return make_pair(v, (flag ? make_pair(-1ll, u) : make_pair(u, -1ll)));
        if (d[u] != d[v]) u = f[u][0];
        for (int i = 20; i >= 0; i--) {
            if (f[u][i] != f[v][i]) {
                u = f[u][i];
                v = f[v][i];
            }
        }
        return make_pair(f[u][0], make_pair(u, v));
    }
}

int fa[N], rtdfn[N], rtdfnt[N], rtminid[N], rtidt[N]; int mxn;
int get_ru(int dfn) {
    int l = 1, r = cnt;
    while (l <= r) {
        int mid = (l + r) >> 1;
        int ml = dfn_range[mid].first, mr = dfn_range[mid].second;
        if (mr < dfn) l = mid + 1;
        else if (dfn < ml) r = mid - 1;
        else return mid;
    }
    assert(0);
    return -1;
}
pair<int, int> id2t(int u) {
    int fu = get_ru(u);
    int rti = rtminid[fu], rtit = rtidt[fu]; int k = u - rti + 1;
    int xu = inner::query_subtree_kth(rtit, k);
    return make_pair(xu, rtit);
}

int get_dis(int u, int v) {
    int fu = get_ru(u), fv = get_ru(v);
    if (fu == fv) return 0;
    pair<int, pair<int, int> > p = outer::lca(fu, fv);
    int u0 = p.second.first, v0 = p.second.second;
    if (u0 == -1) swap(u0, v0), swap(fu, fv), swap(u, v);
    if (v0 == -1) {
        int d = outer::dis[fu] - outer::dis[u0] + 1;
        int uu = id2t(fa[u0]).first;
        int vv = id2t(v).first;
        d += inner::get_dis(uu, vv);
        int ll = inner::lca(uu, vv);
        return d;
    } else {
        int d = outer::dis[fu] - outer::dis[u0] + 1 + outer::dis[fv] - outer::dis[v0] + 1;
        int uu = id2t(fa[u0]).first, vv = id2t(fa[v0]).first;
        d += inner::get_dis(uu, vv);
        return d;
    }
}

signed main() {
    n = read(), m = read(), q = read();
    for (int i = 1; i < n; i++) {
        int u = read(), v = read();
        G[u].push_back(v);
        G[v].push_back(u);
    }
    inner::dfs(1, 0);
    inner::init_lca();
    inner::make_ptree();
    dfn_range[++cnt] = make_pair(1, n); mxn = n;
    rtdfn[cnt] = rtdfnt[cnt] = inner::dfn[1];
    rtminid[cnt] = rtidt[cnt] = 1;
    for (int i = 1; i <= m; i++) {
        int u = read(), v = read();
        int siz = inner::siz[u];
        int fu = get_ru(v);
        dfn_range[++cnt] = make_pair(mxn + 1, mxn + siz);
        fa[cnt] = v;
        rtidt[cnt] = u;
        rtminid[cnt] = 1 + mxn;
        rtdfn[cnt] = (rtdfnt[cnt] = inner::dfn[u]) + mxn;
        mxn += siz;

        int rti = rtminid[fu], rtit = rtidt[fu]; int k = v - rti + 1;
        
        int xv = inner::query_subtree_kth(rtit, k);
        int w = inner::get_dis(rtit, xv) + 1;
        outer::add_edge(fu, cnt, w);
    }
    outer::dfs(1, 0, 0);
    outer::init_lca();
    for (int i = 1; i <= q; i++) {
        int u = read(), v = read();
        int fu = get_ru(u), fv = get_ru(v);
        int dis = get_dis(u, v);
        if (fu != fv) {
            pair<int, int> pu = id2t(u), pv = id2t(v);
            int wu = inner::get_dis(pu.first, pu.second);
            int wv = inner::get_dis(pv.first, pv.second);
            if (outer::lca(fu, fv).first == fu) wu = 0;
            if (outer::lca(fu, fv).first == fv) wv = 0;
            dis += wu + wv;
        } else {
            int xu = id2t(u).first; // inner::query_subtree_kth(rtit, u - rti + 1);
            int xv = id2t(v).first; // inner::query_subtree_kth(rtit, v - rti + 1);
            int w = inner::get_dis(xu, xv);
            dis += w;
        }
        println(dis);
    }
    return 0;
}
```

---

## 作者：crashed (赞：2)

# 题目  
&emsp;&emsp;[点这里](https://www.luogu.com.cn/problem/P3248)看题目。  
# 分析
&emsp;&emsp;一个真正的**树套树**的题目。  
&emsp;&emsp;大体思路非常简单，就是把从模板树上面复制下来的子树用一个点来代表，再插入到大树里面。接着就“正常”地维护一下倍增和深度，查询也跟“正常”的一样，先查 LCA ，再用深度做差。这种思路......形象地称为树套树。    
&emsp;&emsp;~~什么，你说这是水题？开什么玩笑，我可调了一个下午......~~  
&emsp;&emsp;具体来说，本体有~~亿~~些细节：  
### LCA 的查询
&emsp;&emsp;查询，我们先找到两个点会在大树上哪个点相遇，然后再把大树上的点提出来，还原成小树上的形态，再进行一次 LCA ，再把这个 LCA 还原到大树的编号上。  
&emsp;&emsp;1.大树上的 LCA ：直接对点维护倍增。注意，由于我们会把形态还原，因此我们需要知道，**原来两个点具体会跳到树上哪两个点**；这个可以通过记录大树上的点的**真实父亲**得到。  
&emsp;&emsp;2.还原成小树：我们需要知道大树上的编号具体对应小树上的哪些点。我们可以对每个“虚点”记录它所管辖的编号区间。因此大树上的点就可以通过二分找到自己所属的“虚点”，并且知道自己在大树中的**大小排名**。接着我们需要将它和小树上的点对应起来，这可以通过把排名丢到**主席树**里面查第 K 大实现。  
&emsp;&emsp;3.小树上的 LCA ：同上，它可以和大树共用一个倍增数组。  
&emsp;&emsp;4.还原到大树：同上，我们需要知道它在子树中的**大小排名**，这可以继续到主席树里面查询，然后就可以转到大树上来。  
### 深度的查询  
&emsp;&emsp;1.大树上的“虚点”深度：直接动态维护。  
&emsp;&emsp;2.大树上的真实深度：我们对每个“虚点”，维护**它的“假根”到树根的深度**。这个可以在插入的时候，将父亲所在的“虚点”的深度查出来，再加上父亲到父亲的“假根”的真实深度，计算得出。查询就查所在“虚点”的真实深度加上到“假根”的深度的和。    
  
&emsp;&emsp;时间复杂度：也就那么$O(\text{“U(@*@(E(!):+?|”的巨大常数} \times n\log_2n)$吧。  
# 代码
```cpp
#include <cmath>
#include <cstdio>

typedef long long LL;

const int MAXN = 2e5 + 5, MAXLOG = 20, MAXS = MAXN * MAXLOG;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T ABS( const _T a )
{
	return a < 0 ? -a : a;
}

struct edge
{
	int to, nxt;
}Graph[MAXN << 1];

LL fa[MAXN], dep[MAXN], rdep[MAXN], nsiz[MAXN];
int s[MAXS], lch[MAXS], rch[MAXS];
int f[MAXN][MAXLOG], rot[MAXN];
int head[MAXN], tsiz[MAXN], DFN[MAXN], seq[MAXN], ref[MAXN];
LL N, M, Q, tot, siz, ID, lg2, cnt;

void upt( const int u ) { s[u] = s[lch[u]] + s[rch[u]]; }
void copy( int a, int b ) { s[a] = s[b], lch[a] = lch[b], rch[a] = rch[b]; }

int update( const int u, const int l, const int r, const int pos )
{
	int cur = ++ siz, mid = l + r >> 1; copy( cur, u );
	if( l == r ) { s[cur] ++; return cur; }
	if( pos <= mid ) lch[cur] = update( lch[u], l, mid, pos );
	else rch[cur] = update( rch[u], mid + 1, r, pos );
	upt( cur );
	return cur;
}

int query( const int u, const int l, const int r, const int segL, const int segR )
{
	if( ! u ) return 0;
	if( segL <= l && r <= segR ) return s[u];
	int mid = l + r >> 1, ret = 0;
	if( segL <= mid ) ret += query( lch[u], l, mid, segL, segR );
	if( segR > mid ) ret += query( rch[u], mid + 1, r, segL, segR );
	return ret;
}

int Kth( const int u, const int v, const int l, const int r, const int rnk )
{
	if( l == r ) return l;
	int mid = l + r >> 1, num = s[lch[v]] - s[lch[u]];
	if( rnk <= num ) return Kth( lch[u], lch[v], l, mid, rnk );
	return Kth( rch[u], rch[v], mid + 1, r, rnk - num );
}

void addEdge( const int from, const int to )
{
	Graph[++ cnt].to = to, Graph[cnt].nxt = head[from];
	head[from] = cnt;
}

void maintain( const int u )
{
	for( int j = 1 ; j <= lg2 ; j ++ )
		f[u][j] = f[f[u][j - 1]][j - 1];
}

void DFS( const int u, const int fath )
{
	nsiz[u] = ref[u] = u;
	DFN[u] = ++ ID, seq[ID] = u;
	fa[u] = f[u][0] = fath, maintain( u );
	rdep[u] = dep[u] = dep[fath] + 1, tsiz[u] = 1;
	for( int i = head[u], v ; i ; i = Graph[i].nxt )
		if( ( v = Graph[i].to ) ^ fath )
			DFS( v, u ), tsiz[u] += tsiz[v];
}

int bel( const LL id )
{
	int l = 1, r = tot, mid;
	while( r - l > 1 )
	{
		if( id <= nsiz[mid = l + r >> 1] ) r = mid;
		else l = mid + 1;
	}
	if( id <= nsiz[l] ) return l;
	return r;
}

void balance( LL &u, const int step )
{
	for( int i = 0 ; ( 1 << i ) <= step ; i ++ )
		if( step & ( 1 << i ) )
			u = f[u][i];
}

LL getRef( const LL u )
{
	if( u <= N ) return u;
	LL com = bel( u ), fr = ref[com];
	return Kth( rot[DFN[fr] - 1], rot[DFN[fr] + tsiz[fr] - 1], 1, N, u - nsiz[com - 1] );
}

LL getDep( const LL u )
{
	LL com = bel( u ), tru = getRef( u );
	return rdep[com] + rdep[tru] - rdep[ref[com]];
}

LL LCA( LL u, LL v )
{
	if( dep[u] > dep[v] ) balance( u, dep[u] - dep[v] );
	if( dep[v] > dep[u] ) balance( v, dep[v] - dep[u] );
	if( u == v ) return u;
	for( int i = lg2 ; ~ i ; i -- ) if( f[u][i] ^ f[v][i] ) u = f[u][i], v = f[v][i];
	return f[u][0];
}

LL getDist( LL from, LL to )
{
	LL u = bel( from ), v = bel( to ), ff, tt;
	if( u == v ) ff = from, tt = to;
	else
	{
		if( dep[u] > dep[v] ) balance( u, dep[u] - dep[v] );
		if( dep[v] > dep[u] ) balance( v, dep[v] - dep[u] );
		if( u == v ) 
		{
			u = bel( from ), v = bel( to );
			if( dep[u] > dep[v] ) balance( u, dep[u] - dep[v] - 1 ), ff = fa[u], tt = to;
			if( dep[v] > dep[u] ) balance( v, dep[v] - dep[u] - 1 ), ff = from, tt = fa[v];
		}
		else 
		{
			for( int i = lg2 ; ~ i ; i -- ) if( f[u][i] ^ f[v][i] ) u = f[u][i], v = f[v][i];
			ff = fa[u], tt = fa[v];
		}
	}
	LL lca = LCA( getRef( ff ), getRef( tt ) ), in = bel( ff );
	lca = in <= N ? lca : 
		  query( rot[DFN[ref[in]] + tsiz[ref[in]] - 1], 1, N, 1, lca ) 
		- query( rot[DFN[ref[in]] - 1], 1, N, 1, lca ) 
		+ nsiz[in - 1];
	return getDep( from ) + getDep( to ) - 2 * getDep( lca );
}

signed main()
{
	read( N ), read( M ), read( Q );
	for( int i = 1, a, b ; i < N ; i ++ ) read( a ), read( b ), addEdge( a, b ), addEdge( b, a );
	lg2 = log2( N ), DFS( 1, 0 ), tot = N;
	for( int i = 1 ; i <= N ; i ++ ) rot[i] = update( rot[i - 1], 1, N, seq[i] );
	LL fr, to, a, b;
	for( int i = 1 ; i <= M ; i ++ )
	{
		read( fr ), read( to );
		ref[++ tot] = fr, fa[tot] = to;
		nsiz[tot] = nsiz[tot - 1] + tsiz[fr];
		int com = bel( to );
		rdep[tot] = rdep[com] + rdep[getRef( to )] - rdep[ref[com]] + 1;
		dep[tot] = dep[com] + 1;
		f[tot][0] = com, maintain( tot );
	}
	for( int i = 1 ; i <= Q ; i ++ )
	{
		read( a ), read( b );
		write( getDist( a, b ) ), putchar( '\n' );
	}
	return 0;
}
```

---

## 作者：2018LZY (赞：1)

看完题目以后直接猜了个$O(n\log n)$的复杂度。

之后想了半天。。。

为了保证空间合法，我们先定义第$i$次操作后添加的子树命名为块$i$，特别的，一开始的模式树为块0.

然后，显然我们需要把任意编号的点映射回原树，这个用二分找到对应的块+主席树即可实现。

对于询问操作，如果两个点在同一块内就映射回原树然后倍增即可。

为了处理不同块的询问，我们需要预处理块形成的树，并预处理$fa$数组。然后依然倍增往上跳即可。

**综上：本题就是二次倍增**

```cpp
#include<cstdio>
#include<cctype>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#define fi first
#define se second
#define lc tr[x].l
#define rc tr[x].r
#define g getchar()
#define mk make_pair
#define pi pair<int,ll>
using namespace std;
typedef long long ll;
const int N=1e5+10;
template<class o>void qr(o&x) {
	char c=g;int f=1;x=0;
	while(!isdigit(c)){if(c=='-')f=-1;c=g;}
	while(isdigit(c))x=x*10+c-'0',c=g;
	x*=f;
}
template<class o>void qw(o x) {
	if(x/10)qw(x/10);
	putchar(x%10+'0');
}
template<class o> void pr1(o x) {
	if(x<0)x=-x,putchar('-');
	qw(x); putchar(' ');
}
template<class o>void pr2(o x) {
	if(x<0)x=-x,putchar('-');
	qw(x);puts("");
}

int n,m,q,sz[N],dep[N],fa[N][20],rt[N],f[N][20],Dep[N],now; ll L[N],R[N],D[N],Node[N];
struct edge{int y,next;}a[N<<1]; int len,last[N];
void ins(int x,int y) {a[++len]=(edge){y,last[x]}; last[x]=len;}

struct node{int l,r,s;} tr[N*40]; int cnt,root[N];

void insert(int &x,int l,int r,int pos) {
	if(!x) x=++cnt;
	tr[x].s++;
	if(l==r) return; 
	int mid=l+r>>1;
	if(pos<=mid) insert(lc,l,mid,pos);
	else insert(rc,mid+1,r,pos);
}

int merge(int x,int y,int l,int r) {
	if(!x||!y) return x|y;
	int z=++cnt;
	if(l==r) return z;
	int mid=l+r>>1;
	tr[z].l=merge(tr[x].l,tr[y].l,l,mid);
	tr[z].r=merge(tr[x].r,tr[y].r,mid+1,r);
	tr[z].s=tr[tr[z].l].s+tr[tr[z].r].s;
	return z;
}

int ask(int x,int l,int r,int k) {
	while(l^r) {
		int mid=l+r>>1;
		if(k<=tr[lc].s) r=mid,x=lc;
		else l=mid+1,k-=tr[lc].s,x=rc;
	}
	return l;
}

void dfs(int x) { 
	insert(root[x],1,n,x); sz[x]=1;
	for(int k=last[x],y;k;k=a[k].next)	
		if(!dep[y=a[k].y]) {
			dep[y]=dep[x]+1; fa[y][0]=x;
			for(int i=0;fa[y][i];i++) fa[y][i+1]=fa[fa[y][i]][i]; 
			dfs(y); sz[x]+=sz[y]; root[x]=merge(root[x],root[y],1,n);
		}
}

pi find(ll t) {//求编号为t的点的对应块和深度 
	int x=upper_bound(L,L+now,t)-L-1;
	return mk(x,D[x]+dep[ask(root[rt[x]],1,n,t-L[x]+1)]-dep[rt[x]]);
}
ll pos(ll t) {//求对应模式树位置
	if(t<=n) return t;
	int x=upper_bound(L,L+now,t)-L-1; 
	return ask(root[rt[x]],1,n,t-L[x]+1);
}

ll dis(ll x,ll y) {
	ll z=dep[x]+dep[y];
	if(dep[x]<dep[y]) swap(x,y);
	for(int i=0,k=dep[x]-dep[y];k;i++)
		if(k>>i&1) x=fa[x][i],k^=1<<i;
	if(x^y) {
		for(int i=17;i>=0;i--)
			if(fa[x][i]^fa[y][i]) x=fa[x][i],y=fa[y][i];
		x=fa[x][0];
	}
	return z-dep[x]*2;
}

ll solve(ll x,ll y) {
	pi u=find(x),v=find(y);
	ll ans=0;int a=u.fi,b=v.fi;
	if(a^b) {
		if(Dep[a]<Dep[b]) swap(x,y),swap(a,b),swap(u,v);
		if(Dep[a]^Dep[b]) {
			for(int i=0,k=Dep[a]-Dep[b]-1;k;i++)
				if(k>>i&1) a=f[a][i],k^=1<<i;
			ans+=u.se-D[a]+1; u.se=D[a]-1; x=Node[a]; a=f[a][0];
		}
		if(a^b) {
			for(int i=17;i>=0;i--)
				if(f[a][i]^f[b][i])	
					a=f[a][i],b=f[b][i];
			ans+=u.se-D[a]+1+v.se-D[b]+1;
			x=Node[a]; y=Node[b];
		}
	}
	ans+=dis(pos(x),pos(y));
	return ans;
}

int main() {
	qr(n); qr(m); qr(q);
	for(int i=1,x,y;i<n;i++)
		qr(x),qr(y),ins(x,y),ins(y,x);
	dfs(dep[1]=1);
	L[0]=1; R[0]=n; rt[0]=1; D[0]=Dep[0]=1;//D[i]表示i块的根的真实深度，Dep[i]是块组成的树的深度 
	for(now=1;now<=m;now++) {
		qr(rt[now]); L[now]=R[now-1]+1; R[now]=R[now-1]+sz[rt[now]];
		qr(Node[now]); pi p=find(Node[now]); 
		f[now][0]=p.fi; D[now]=p.se+1; Dep[now]=Dep[p.fi]+1; 
		for(int i=0;f[now][i];i++) 
			f[now][i+1]=f[f[now][i]][i];
	}
	while(q--) {
		ll x,y; qr(x); qr(y);
		pr2(solve(x,y));
	}
	return 0;
}
```




---

## 作者：logwzc (赞：1)

## 抽象
把题目的建树看成是一棵1e5级别的树，只不过每个树节点也同样是一棵1e5级别的树。

为了方便描述，定义这整棵树为外树，它的每个树节点为内树。

显然有任意一棵内树都是原树的一棵子树。
## 分析
先粗略的想一下答案怎么求，很显然两个点的LCA所在的内树一定是在它们对应内树的LCA。那么可以记录每棵内树的根节点的真实深度。对于一组询问，先在外树上倍增找到两个点对应内树的LCA，再在这个内树中直接求LCA。
## 维护信息
有了思路，我们就可以尝试维护信息了。
### 1、如何找一个点对应的内树？
显然我们可以处理出每棵内树包含的点的编号范围 [ L , R ] 。直接二分即可。
### 2、如何对两棵内树求LCA？
先通过问题1连边建出外树，然后直接倍增即可。
### 3、如何求一棵内树的真实深度？
内树的根节点的深度显然等于它父亲所在的内树的真实深度+它父亲在其所在内树中的深度+1。

那么我们引出了第4个问题：
### 4、如何求一个点在其所在内树中的深度？
定义一个点在一棵树中的相对编号为它的编号在这棵树中是第几小的。

由于编号顺序与原树相等，所以这个点在这棵内树中的相对编号等于其在原树中的对应子树的相对编号。

也就意味着这个点在这棵内树中的深度，等于其在原树中的对应子树中相对编号与其相同的点，相对于这棵子树的根节点的深度。

于是我们引出了第5个问题：
### 5、如何求原树中的一个子树内相对编号为k的点？
显然我们可以先对原树求一遍dfs序，这样子树查询就相当于区间查询，子树相对编号为k就相当于区间第k小。

静态区间第k小？主席树即可。
## 查询答案
对于一组查询u，v

### 先考虑处理出u，v正要跳到它们所在内树的LCA中的时候的答案。

对于u，如果它所在的内树并不是LCA，那么这个答案包含以下几部分：
#### 1、它到它所在内树的根节点的距离
#### 2、它所在内树的根节点到它的祖先中LCA下方的内树的根节点的距离
对于1，见问题4。

对于2，先倍增找到它的祖先中LCA下方的内树，再用已经通过问题3求好的信息算。

对于v同理。

### 接下来处理u，v都到了它们所在内树的LCA中的答案。
通过类似问题5的做法我们可以得到u，v在这个LCA中对应原树中的点的编号。

得到到这两个编号后直接在原树中求LCA即可。

代码
```cpp
#include<bits/stdc++.h>
#define N 100010
#define D 21
#define ll long long
using namespace std;
template<typename T> void read(T &x){
	x=0;char c=getchar();T sig=1;
	for (;!isdigit(c);c=getchar()) if (c=='-') sig=-1;
	for (; isdigit(c);c=getchar()) x=x*10+c-48;
	x*=sig;
}
template<typename T> void write(T x){
	if (x<0){putchar('-');x=-x;}
	T y=0;int wei=0;
	while (x>9){++wei;y=y*10+x%10;x/=10;}putchar(x+48);
	while (wei--){putchar(y%10+48);y/=10;}
}
int n,m,Q;
struct Parent{
	int fa[N][D];
};
Parent Big,Small;
int Dep_Big[N],Dep_Small[N];
int High_Big[N],High_Small[N];
struct Side{
	int len,head[N],last[N<<1],to[N<<1];
};
Side S,C;
struct Line{
	int root;
	ll Lef,Rig,True_Dep;
	void crt(int x,ll y,ll z,ll k){
		root=x;
		Lef=y;
		Rig=z;
		True_Dep=k;
		return;
	}
};
Line Position[N];
struct Point{
	int dfn,low;
};
Point List[N];
int Cnt;
int What[N];
int Who[N];
int tot;
struct Segment_Tree{
	struct Node_Tree{
		int lc,rc,sum;
	};
	Node_Tree tr[N*D];
	int tot,root[N];
	#define ls(i) tr[i].lc
	#define rs(i) tr[i].rc
	#define val(i) tr[i].sum
	void PushUp(int i){
		val(i)=val(ls(i))+val(rs(i));
		return;
	}
	void Add(int &now,int last,int ql,int qr,int idx){
		if (!now) now=++tot;
		if (ql==qr){
			val(now)=1;
			return;
		}
		int mid=(ql+qr)>>1;
		if (idx<=mid) rs(now)=rs(last),Add(ls(now),ls(last),ql,mid,idx);
		else ls(now)=ls(last),Add(rs(now),rs(last),mid+1,qr,idx);
		PushUp(now);
		return;
	}
	int Query(int now,int last,int ql,int qr,int idx){
		if (ql==qr) return ql;
		int k=val(ls(now))-val(ls(last));
		int mid=(ql+qr)>>1;
		if (k>=idx) return Query(ls(now),ls(last),ql,mid,idx);
		return Query(rs(now),rs(last),mid+1,qr,idx-k);
	}
	int Ask(int p,int idx){
		return Query(root[List[p].low],root[List[p].dfn-1],1,n,idx);
	}
};
Segment_Tree tree;
void Put(Side &R,int x,int y){
	R.len++;
	R.to[R.len]=y;
	R.last[R.len]=R.head[x];
	R.head[x]=R.len;
	return;
}
void Addedge(Side &R,int x,int y){
	Put(R,x,y);
	Put(R,y,x);
	return;
}
void Dfs(int p,Parent &Now,int *Dep_Now,int *High_Now,Side &R){
	for (int i=R.head[p];i;i=R.last[i])
		if (Now.fa[p][0]!=R.to[i]){
			Dep_Now[R.to[i]]=Dep_Now[p]+1;
			Now.fa[R.to[i]][0]=p;
			High_Now[R.to[i]]=-1;
			for (int j=1;Now.fa[R.to[i]][j-1];++j,++High_Now[R.to[i]])
				Now.fa[R.to[i]][j]=Now.fa[Now.fa[R.to[i]][j-1]][j-1];
			Dfs(R.to[i],Now,Dep_Now,High_Now,R);
		}
	return;
}
void Dfs_Big(){
	Dfs(1,Big,Dep_Big,High_Big,S);
	return;
}
void Dfs_Small(){
	Dfs(1,Small,Dep_Small,High_Small,C);
	return;
}
void Dfs_2(int p){
	What[++Cnt]=p;
	List[p].dfn=Cnt;
	for (int i=C.head[p];i;i=C.last[i])
		if (Small.fa[p][0]!=C.to[i])
			Dfs_2(C.to[i]);
	List[p].low=Cnt;
	return;
}
void Prepare(){
	Dfs_Small();
	Dfs_2(1);
	for (int i=1;i<=n;i++) tree.Add(tree.root[i],tree.root[i-1],1,n,What[i]);
	return;
}
int Find_Pos(ll x){
	int L=0,R=tot;
	while (L<R-1){
		int mid=(L+R)>>1;
		if (x<=Position[mid].Rig) R=mid;
		else L=mid;
	}
	return R;
}
void Get_data(){
	read(n);
	read(m);
	read(Q);
	for (int i=1;i<n;i++){
		int x,y;
		read(x);
		read(y);
		Addedge(C,x,y);
	}
	Prepare();
	Position[1].crt(1,1,n,1);
	for (int i=2;i<=m+1;i++){
		int x;ll y;
		read(x);
		read(y);
		tot=i-1;
		int Par=Find_Pos(y);
		int kth=y-Position[Par].Lef+1;
		Who[i]=tree.Ask(Position[Par].root,kth);
		Addedge(S,Par,i);
		Position[i].crt(x,Position[i-1].Rig+1,Position[i-1].Rig+List[x].low-List[x].dfn+1,Position[Par].True_Dep+Dep_Small[Who[i]]-Dep_Small[Position[Par].root]+1ll);
	}
	tot=m+1;
	Dfs_Big();
	return;
}
int Skip(int x,int k,Parent &Now){
	int t=0;
	while (k){
		if (k&1) x=Now.fa[x][t];
		++t;
		k>>=1;
	}
	return x;
}
int Lca(int x,int y,Parent &Now,int *Dep_Now,int *High_Now){
	if (Dep_Now[x]<Dep_Now[y]) swap(x,y);
	x=Skip(x,Dep_Now[x]-Dep_Now[y],Now);
	if (x==y) return x;
	for (int i=High_Now[x];i>=0;i--)
		if (Now.fa[x][i]!=Now.fa[y][i]){
			x=Now.fa[x][i];
			y=Now.fa[y][i];
		}
	return Now.fa[x][0];
}
int Lca_Big(int x,int y){
	return Lca(x,y,Big,Dep_Big,High_Big);
}
int Lca_Small(int x,int y){
	return Lca(x,y,Small,Dep_Small,High_Small);
}
int Fur(int x,int y){
	int k=Lca_Small(x,y);
	return Dep_Small[x]+Dep_Small[y]-2*Dep_Small[k];
}
ll Ex_Lca(ll x,ll y){
	ll res=0;
	int u=Find_Pos(x);
	int v=Find_Pos(y);
	int u_kth=x-Position[u].Lef+1;
	int v_kth=y-Position[v].Lef+1;
	int Top=Lca_Big(u,v);
	if (u!=Top){
		res+=Dep_Small[tree.Ask(Position[u].root,u_kth)]-Dep_Small[Position[u].root];
		int k=Dep_Big[u]-Dep_Big[Top]-1;
		int u_Topson=Skip(u,k,Big);
		res+=Position[u].True_Dep-Position[u_Topson].True_Dep;
		res++;
		x=Who[u_Topson];
	}
	else x=tree.Ask(Position[u].root,u_kth);
	if (v!=Top){
		res+=Dep_Small[tree.Ask(Position[v].root,v_kth)]-Dep_Small[Position[v].root];
		int k=Dep_Big[v]-Dep_Big[Top]-1;
		int v_Topson=Skip(v,k,Big);
		res+=Position[v].True_Dep-Position[v_Topson].True_Dep;
		res++;
		y=Who[v_Topson];
	}
	else y=tree.Ask(Position[v].root,v_kth);
	res+=Fur(x,y);
	return res;
}
void Solve(){
	while (Q--){
		ll x,y;
		read(x);
		read(y);
		write(Ex_Lca(x,y));
		putchar('\n');
	}
	return;
}
int main(){
//	freopen("P3248.in","r",stdin);
//	freopen("P3248.out","w",stdout);
	Get_data();
	Solve();
	return 0;
}
```


---

## 作者：劉子颺 (赞：1)

一个毒瘤但不失精致的题解

由于写了ZJOI2016 大森林我一度以为本题是那个LCT转

冷静分析后发现 模板树固定 并不需要那么搞

考虑维护一个点代表一个模板树子树

那么查询时一共有4种情况

1. 都在在点内 在模板树上查LCA即可
2. 祖先关系* 两种 先倍增上去到dep只差为1 然后转为1好问题
3. 倍增到深度一样后一起倍增 最后还是1问题

一个有三种名字对应关系

最好封装起来


```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<vector>
#include<map>
typedef long long LL;
using namespace std;
const int N=2e5+100;
inline void read(int &x){
	x=0;
	int f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-'0';
		ch=getchar();
	}
	x*=f;
}
inline void read(LL &x){
	x=0;
	int f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-'0';
		ch=getchar();
	}
	x*=f;
}
int n,m,Q;
int root[N];
struct Chairman_Tree{
	int lson[N*30];
	int rson[N*30];
	int sum[N*30];
	int tot;
	void Update(int x,int &y,int l,int r,int pos){
		y=++tot;
		lson[y]=lson[x];
		rson[y]=rson[x];
		sum[y]=sum[x]+1;
		if(l==r)return;
		int mid=(l+r)>>1;
		if(pos<=mid)Update(lson[x],lson[y],l,mid,pos);
		else Update(rson[x],rson[y],mid+1,r,pos);
	}
	int Query(int x,int y,int l,int r,int K){
		if(l==r)return l;
		int tmp=sum[lson[y]]-sum[lson[x]];
		int mid=(l+r)>>1;
		if(K>tmp)
			return Query(rson[x],rson[y],mid+1,r,K-tmp);
		else 
			return Query(lson[x],lson[y],l,mid,K);
	}
}PST;
int dfn[N];
int low[N];
int pre[N];
int siz[N];
struct Template_Tree{
	struct Front_Star{
		int u,v,nxt;
	}e[N<<2];
	int cnt=0;
	int first[N];
	int fa[N][21];
	int dep[N];
	void add(int u,int v){
		++cnt;
		e[cnt].u=u;
		e[cnt].v=v;
		e[cnt].nxt=first[u];
		first[u]=cnt;
	}
	int dfn_cnt;
	void DFS(int u,int fat){
		siz[u]=1;
		dfn[u]=++dfn_cnt;
		pre[dfn_cnt]=u;
		fa[u][0]=fat;
		for(int i=1;i<=20;++i)fa[u][i]=fa[fa[u][i-1]][i-1];
		for(int i=first[u];i;i=e[i].nxt){
			int v=e[i].v;
			if(v==fat)continue;
			dep[v]=dep[u]+1;
			DFS(v,u);
			siz[u]+=siz[v];
		}
		low[u]=dfn_cnt;
	}
	int LCA(int x,int y){
		if(dep[x]<dep[y])swap(x,y);
		for(int i=20;i>=0;--i){
			if(dep[x]-(1<<i)>=dep[y])x=fa[x][i];
		}
		if(x==y)return x;
		for(int i=20;i>=0;--i){
			if(fa[x][i]!=fa[y][i]){
				x=fa[x][i];
				y=fa[y][i];
			}
		}
		return fa[x][0];
	}
	int Dis(int x,int y){
		return dep[x]+dep[y]-2*dep[LCA(x,y)];
	}	
}G;
struct Id_Table{
	vector<LL> End;
	map<int,int> mmp;
	int Idcnt;
	int Insert(LL R){
		End.push_back(R);
		return ++Idcnt;
	}
	int GetId(LL x){
		int pos=1+lower_bound(End.begin(),End.end(),x)-End.begin();
		return pos;
	}
}Id;
struct Big_Tree{
	LL fa;
	LL L;
	int rt,Id;
}T[N<<2];
struct Front_star{
	int u,v,w,nxt;
}e[N<<2];
int cnt=0;
int first[N];
void add(int u,int v,LL w){
	++cnt;
	e[cnt].u=u;
	e[cnt].v=v;
	e[cnt].w=w;
	e[cnt].nxt=first[u];
	first[u]=cnt;
}
LL dis[N];
int dep[N];
int fa[N][21];
LL Tnode=0;
LL LCADis(LL x,LL y,int Id){
	
	
	if(Id==1){
		return G.Dis(x,y);
	}
	
	
	x=PST.Query(root[dfn[T[Id].rt]-1],root[low[T[Id].rt]],1,n,x-T[Id].L);
	if(y!=-1)y=PST.Query(root[dfn[T[Id].rt]-1],root[low[T[Id].rt]],1,n,y-T[Id].L);
	
	
	return G.Dis(x,y==-1?T[Id].rt:y);
}
LL Dis(LL x,LL y){
	int Idx=Id.GetId(x);
	int Idy=Id.GetId(y);
	
	
	if(Idx==Idy){
		return LCADis(x,y,Idx);
	}
	if(dep[Idx]<dep[Idy]){
		swap(x,y);
		swap(Idx,Idy);
	}
	LL ret=0;
	for(int i=20;i>=0;--i){
		if(dep[Idx]-(1<<i)>dep[Idy]){
			ret+=dis[Idx]-dis[fa[Idx][i]];
			Idx=fa[Idx][i];
		}
	}
	
	
	if(fa[Idx][0]==Idy){
		
		
		return ret+1+LCADis(T[Idx].fa,y,Idy)+LCADis(x,-1,Id.GetId(x));
		
	}
	else{
		if(dep[Idx]!=dep[Idy]){
			ret+=dis[Idx]-dis[fa[Idx][0]];
			Idx=fa[Idx][0];			
		}
		ret+=LCADis(x,-1,Id.GetId(x));
		ret+=LCADis(y,-1,Id.GetId(y));
		
	}
	
	
	for(int i=20;i>=0;--i){
		if(fa[Idx][i]!=fa[Idy][i]){
			ret+=dis[Idx]-dis[fa[Idx][i]];
			ret+=dis[Idy]-dis[fa[Idy][i]];
			Idx=fa[Idx][i];
			Idy=fa[Idy][i];
		}
	}
	
	
	ret+=2;
	
	x=T[Idx].fa;
	y=T[Idy].fa;
	
	
	int pos=fa[Idx][0];
	
	
	ret+=LCADis(x,y,pos);
	return ret;
}
int main(){
//	freopen("P3248.in","r",stdin);
//	freopen("P3248.out","w",stdout);
	
	read(n);read(m);read(Q);
	for(int i=1;i<n;++i){
		int u,v;
		read(u);read(v);
		G.add(u,v);
		G.add(v,u);
	}
	G.DFS(1,0);
	for(int i=1;i<=n;++i){
		PST.Update(root[i-1],root[i],1,n,pre[i]);
	}
	T[Id.Insert(n)].rt=1;
	T[1].Id=1;
	T[1].L=0;
	Tnode=n;
	
	dep[1]=1;
	
	while(m--){
		int x;
		LL to;
		read(x);read(to);
		
		
		int Par=Id.GetId(to);
		int Ed=PST.Query(root[dfn[T[Par].rt]-1],root[low[T[Par].rt]],1,n,to-T[Par].L);
		
		
		int now=Id.Insert(Tnode+siz[x]);
		T[now].fa=to;
		T[now].L=Tnode;
		T[now].rt=x;
		T[now].Id=now;
		
		
		fa[now][0]=Par;
		dep[now]=dep[Par]+1;
		dis[now]=dis[Par]+1+G.Dis(T[Par].rt,Ed);
		
		for(int i=1;i<=20;++i)fa[now][i]=fa[fa[now][i-1]][i-1];
		
		Tnode+=siz[x];
	}
	
//	exit(0);
	
	while(Q--){
		LL u,v;
		read(u);
		read(v);
		cout<<Dis(u,v)<<'\n';
	}
	return 0;
}
```



---

## 作者：出言不逊王子 (赞：1)

我们发现最后答案有很大一段是两个被复制的树根间东奔西走，所以我们考虑把答案分两段统计：在被复制的树根间东奔西走的距离，和在单棵树中间跑步的距离。

对于答案的第一部分，我们无需关心树的具体形态，只需要记录每棵树的树根是从哪棵树开始复制而来的即可。因此我们在模板树的基础上开一棵新树，记录每个复制而来的树的树根的相对位置。特别地，一开始的 $1$ 号点也是一个树根。

但是点的个数可能达到 $10^{10}$ 级别，所以我们得离散化一下，新树的点编号实际上是 $t_i$，即一个点被复制的时间。

按照这个规则建树，我们得到了一棵巨大的树。

---

现在我们要查询 $x$ 和 $y$ 的距离。

如果 $x$ 和 $y$ 在大树上是处于同一个节点，即 $x$ 和 $y$ 是在同一次被复制过来的，那么我们只要把复制出来的这棵树拉出来，在上面跑一趟 LCA 即可。

如果 $x$ 和 $y$ 在大树上的点是祖先关系（这里假设 $y$ 是 $x$ 的祖先），那么我们要先把 $x$ 拉到 $y$ 所在的子树（即 $y$ 所在的复制过来的树）上，再像第一种情况一样跑 LCA。

因此，我们在建大树时，我们还需要记录一开始连边时具体的 $t$。

那么我们先在大树上找到 $y$ 在 $x\to y$ 这条链上的第一个儿子，让 $x$ 跳到那，再把 $x$ 往上跳一格跳到 $t$，显然 $t$ 和 $y$ 在同一棵子树上，且 $\text{LCA}(t,y)=\text{LCA}(x,y)$。

因此我们在大树上求出 $y$ 和 $x$ 的**距离**，剩下的问题就转化成第一种情况了。

如果 $x$ 和 $y$ 在大树上的点不是祖先关系，那么我们需要先找到 $x$ 和 $y$ 在大树上的 LCA。

剩下的就是第一种情况了。

代码暴戾语言注释太多，干脆删了，要的话私信。

---

## 作者：rubbishZZZ (赞：0)

## P3248 [HNOI2016] 树



#### 题意：

​	初始时你有一个模板树以及当前大树，他们初始时是一样的。

​	你会进行 $M$ 轮操作，每次将模板树的某个子树复制并挂在大树中某个节点的下方。

​	将新加入大树的结点按照在模板树中编号的顺序重新编号。假设在进行操作前大数有 $L$ 个节点，模板树中以 $a$ 为根的子树共有 $C$ 个结点，那么新加入模板树的 $C$ 个结点在大树中的编号将是 $L+1,L+2,\cdots,L+C$。大树中这 $C$ 个结点编号的大小顺序和模板树中对应的 $C$ 个结点的大小顺序是一致的。

​	接下来是 $Q$ 次询问，每次询问两点在大树上的距离。



#### 解法：

- 我们将每一轮新加入大树的位置记作一个**块**，同个块内的编号是连续的，这些块也形成了一个树形结构：

![](https://cdn.luogu.com.cn/upload/image_hosting/mloyl7x0.png)

  例如蓝色是初始的大树，红色是每次接入的子树，三角形就是块，紫色的边就是块形成的树。

  我们将边权设为当前块最顶端到父亲块最顶端的距离，那么两个不同块之间的距离可以通过跳紫边变成同个块之间两点的距离，这部分可以倍增。

  然后我们还有问题，如何求紫边的长度。

  我们对模板树做一个 dfs，使用可持久化线段树来维护每个子树内存在哪些点，那么询问大树上同块点之间的距离就可以线段树二分求出对应模板树上的点，再求模板树上点的距离即可。

  复杂度 $O(n\log n)$。



#### 代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <iostream>
#include <vector>
#include <set>
#include <queue>
#include <map>
#include <ctime>
#include <random>
#include <cassert>
#include <numeric>
#include <cmath>
#include <bitset>
#include <ext/pb_ds/assoc_container.hpp>
#define pii pair<int, int>
#define fi first
#define se second
#define MP make_pair
#define ep emplace
#define eb emplace_back
#define int long long
#define rep(i, j, k) for (int i = (j); i <= (k); i++)
#define per(i, j, k) for (int i = (j); i >= (k); i--)
typedef double db;
typedef long double ldb;
typedef long long ll;
//typedef __int128 lll;
typedef unsigned long long ull;
typedef unsigned int ui;
using namespace std;
using namespace __gnu_pbds;
bool Mbe;

//char buf[1<<20],*p1,*p2;
//#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1<<20,stdin), p1 == p2) ? 0 : *p1++)
int read() {
	int s = 0, f = 1;
	char c = getchar();
	while (c < '0' || c > '9') f ^= (c == '-'), c = getchar();
	while (c >= '0' && c <= '9') s = s * 10 + c - '0', c = getchar();
	return f ? s : -s;
}
template<typename T>void chkmax(T&x,const T&y){if(x<y)x=y;}
template<typename T>void chkmin(T&x,const T&y){if(x>y)x=y;}

const int N=100005;
int n,m,q,rt[N],sz[N],depe[N],depg[N],ru[N],dis[N],fag[N][20],fae[N][20];
vector<int>e[N];
struct SGT{
	int tot,ls[N<<7],rs[N<<7],sz[N<<7];
	void upd(int l,int r,int p,int&u){
		sz[u=++tot]++;
		if(l==r)return;
		int mid=(l+r)>>1;
		if(mid>=p)upd(l,mid,p,ls[u]);
		else upd(mid+1,r,p,rs[u]);
	}
	void merge(int l,int r,int u,int&x,int v){
		if(!u||!v)return x=u|v,void();
		sz[x=++tot]=sz[u]+sz[v];
		int mid=(l+r)>>1;
		merge(l,mid,ls[u],ls[x],ls[v]);
		merge(mid+1,r,rs[u],rs[x],rs[v]);
	}
	int query(int l,int r,int k,int u){
		if(l==r)return l;
		int mid=(l+r)>>1;
		if(sz[ls[u]]>=k)return query(l,mid,k,ls[u]);
		return query(mid+1,r,k-sz[ls[u]],rs[u]);
	}
}sgt;
void dfs(int u,int fat){
	sz[u]=1,depe[u]=depe[fat]+1,fae[u][0]=fat;
	rep(i,1,17)fae[u][i]=fae[fae[u][i-1]][i-1];
	sgt.upd(1,n,u,rt[u]);
	for(int v:e[u])if(v^fat)dfs(v,u),sz[u]+=sz[v];
	if(fat)sgt.merge(1,n,rt[fat],rt[fat],rt[u]);
}
vector<pii>g[N];
int b[N],pos[N],mm;
int find(int x){
	return lower_bound(b+1,b+mm+1,x)-b;
}
int get(int x){
	int id=find(x);
	return sgt.query(1,n,x-b[id-1],rt[pos[id]]);
}
int getdep(int x){
	int id=find(x);
	return depe[get(x)]-depe[pos[id]]+1;
}
void dfs2(int u,int fat){
	fag[u][0]=fat,depg[u]=depg[fat]+1;
	rep(i,1,17)fag[u][i]=fag[fag[u][i-1]][i-1];
	for(pii p:g[u]){
		int v=p.fi,w=p.se;
		dis[v]=dis[u]+w;
		dfs2(v,u);
	}
}
int LCAG(int u,int v){
	if(depg[u]<depg[v])swap(u,v);
	per(i,17,0)if(depg[fag[u][i]]>=depg[v])u=fag[u][i];
	if(u==v)return u;
	per(i,17,0)if(fag[u][i]^fag[v][i])u=fag[u][i],v=fag[v][i];
	return fag[u][0];
}
int LCAE(int u,int v){
	if(depe[u]<depe[v])swap(u,v);
	per(i,17,0)if(depe[fae[u][i]]>=depe[v])u=fae[u][i];
	if(u==v)return u;
	per(i,17,0)if(fae[u][i]^fae[v][i])u=fae[u][i],v=fae[v][i];
	return fae[u][0];
}
int jump(int u,int v){
	int d=depg[u]-depg[v]-1;
	per(i,17,0)if(d>>i&1)u=fag[u][i];
	return u;
}

signed main() {
//	freopen("tree1.in","r",stdin);
//	freopen("my.out","w",stdout);
	n=read(),m=read()+1,q=read();
	rep(i,1,n-1){
		int u=read(),v=read();
		e[u].eb(v),e[v].eb(u);
	}
	dfs(1,0);
	b[mm=1]=n,pos[1]=1;
	rep(i,2,m){
		int u=read(),v=read();
		b[i]=b[i-1]+sz[u];
		pos[mm=i]=u,ru[i]=get(v);
		g[find(v)].eb(i,getdep(v));
	}
	dfs2(1,0);
	rep(i,1,q){
		int u=read(),v=read();
		int idu=find(u),idv=find(v);
		int uu=get(u),vv=get(v);
		int lca=LCAG(idu,idv);
		int ans=dis[idu]+dis[idv]-2*dis[lca];
		ans+=depe[uu]-depe[pos[idu]]+depe[vv]-depe[pos[idv]];
		if(idu^lca)uu=ru[jump(idu,lca)];
		if(idv^lca)vv=ru[jump(idv,lca)];
		ans-=2*(depe[LCAE(uu,vv)]-depe[pos[lca]]);
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：strlen_s_ (赞：0)

这是一道练习代码能力的好题。虽是数据结构题，但是码量与细节都跟大模拟相近了。

审题发现，假如要存下这么多点，空间肯定毫无悬念的爆掉。所以要考虑怎样正确计算。

可以发现每一次操作就是复制原树上以 $u$ 为根的子树再放到大树的一个节点下面，那我们就可以考虑维护这一整颗子树。具体来讲，就是将整颗子树作为一个节点来维护。那么我们就可以根据这个大树的构建过程，重新建出一棵树，这颗树上每个结点都是原树的一颗子树。这颗树的边权就是两个结点的子树的树根之间的距离。

假设操作完后，大树长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/fho9bkn8.png)

那么这几个用圆圈出来的点就是我们构建的新树的结点。

令 $rt_i$ 表示第 $i$ 号大点的根是原树上的哪一个结点，那么树建出来就应该长这样:

![](https://cdn.luogu.com.cn/upload/image_hosting/zte1vkkq.png)

那么每次求 $\operatorname{LCA}$ 时，就只需要先跳跳到当前节点的根，再跳大点，最后再跳 $\operatorname{LCA}$ 上的大结点，就可以求出答案了。

还需注意一些细节，就是当一个大点为另一个大点的祖先时，在祖先的那个询问点不能先跳到所在结点的根，因为最终两点的 $\operatorname{LCA}$ 并不一定落在上面。

详见代码。

```
#include<bits/stdc++.h>
#define in inline
#define re register
#define int long long
using namespace std;
int read(){
	int x=0,f=1;
	char c;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;
}
const int N=1e5+10,inf=2e18;
int n,m,q;
struct President_Tree{              //这个主席树是用来求当前结点在原树中的编号。 
    struct tree{
        int ls,rs,sum;
    }t[N*20];
    int top,rt[N];;
    int clone(int k){t[++top]=t[k];t[top].sum++;return top;}
    #define mid (l+r>>1)
    int upd(int k,int l,int r,int x){
        k=clone(k);
        if(l==r)return k;
        if(mid>=x)t[k].ls=upd(t[k].ls,l,mid,x);
        else t[k].rs=upd(t[k].rs,mid+1,r,x);
        return k;
    }
    int qry(int L,int R,int l,int r,int z){
        if(l==r)return l;
        int sum=t[t[R].ls].sum-t[t[L].ls].sum;
        if(sum>=z)return qry(t[L].ls,t[R].ls,l,mid,z);
        else return qry(t[L].rs,t[R].rs,mid+1,r,z-sum);
    }
    #undef mid
}PT;
struct Template_Tree{           //模板树的建立。 
    int siz[N],dep[N],dfn[N],num;
    int h[N],nex[N<<1],to[N<<1],tot;
    int f[N][19];
    void add(int x,int y){to[++tot]=y,nex[tot]=h[x],h[x]=tot;}
    void dfs(int u,int fa){
        dfn[u]=++num;
        PT.rt[num]=PT.upd(PT.rt[num-1],1,n,u);
        siz[u]=1;dep[u]=dep[fa]+1;f[u][0]=fa;
        for(int i=1;i<=18;i++)f[u][i]=f[f[u][i-1]][i-1];
        for(int i=h[u];i;i=nex[i]){
            int v=to[i];
            if(v==fa)continue;
            dfs(v,u);
            siz[u]+=siz[v];
        }
    }
    void build(){
        n=read(),m=read(),q=read();
        for(int i=1;i<n;i++){
            int x=read(),y=read();
            add(x,y),add(y,x);
        }
        dfs(1,0);
    }
    int lca(int x,int y){
        if(dep[x]<dep[y])swap(x,y);
        for(int i=18;i>=0;i--){
            if(dep[f[x][i]]>=dep[y])x=f[x][i];
            if(x==y)return x;
        }
        for(int i=18;i>=0;i--){
            if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];
        }
        return f[x][0];
    }
    int get_path(int x,int y){
        int l=lca(x,y);
        return dep[x]+dep[y]-2*dep[l];
    }
    int qry(int x,int k){
        int l=dfn[x]-1,r=dfn[x]+siz[x]-1;
        return PT.qry(PT.rt[l],PT.rt[r],1,n,k);
    }
}TT;
struct big_tree{
    int siz[N],rt[N],TTfa[N];       // TTF 是被复制的点在大树中的父亲在原树中的编号。 
    int f[N][19],dep[N],sum[N];
    int h[N],nex[N<<1],to[N<<1],e[N<<1],tot;
    void add(int x,int y,int z){to[++tot]=y,nex[tot]=h[x],e[tot]=z,h[x]=tot;}
    int find_fa(int x,int r){return lower_bound(siz+1,siz+r+1,x)-siz;}          //找当前结点的所在的大点的编号。 
    int qry(int x,int y,int p){ 
        int fa=find_fa(y,p);y-=siz[fa-1];
        return TT.qry(x,y);
    }
    int get_id(int x){
        return qry(rt[find_fa(x,m)],x,m);       //找当前结点对应会原树中的结点的编号。 
    }
    void dfs(int u,int fa,int w){
        dep[u]=dep[fa]+1;f[u][0]=fa;sum[u]=sum[fa]+w;
        for(int i=1;i<=18;i++)f[u][i]=f[f[u][i-1]][i-1];
        for(int i=h[u];i;i=nex[i])dfs(to[i],u,e[i]);
    }
    void build(){
        m++;
        siz[1]=TT.siz[1];
        rt[1]=1;
        for(int i=2;i<=m;i++){
            int x=read(),y=read();
            rt[i]=x;
            siz[i]=siz[i-1]+TT.siz[rt[i]];
            int fa=find_fa(y,i);
            TTfa[i]=qry(rt[fa],y,i);
            add(fa,i,TT.get_path(TTfa[i],rt[fa])+1);
        }
        dfs(1,0,0);
    }
    int lca(int x,int y){
        if(find_fa(x,m)==find_fa(y,m))return TT.get_path(get_id(x),get_id(y));
        int ans=0;
        if(dep[find_fa(x,m)]<dep[find_fa(y,m)])swap(x,y);
        ans+=TT.get_path(get_id(x),rt[find_fa(x,m)]);x=find_fa(x,m);        //不能两个一下全跳到根。 
        int xx=x,yy;
        for(int i=18;i>=0;i--){
            if((dep[f[x][i]]>=dep[find_fa(y,m)]&&f[x][i]!=find_fa(y,m))||(dep[f[x][i]]>dep[find_fa(y,m)]))x=f[x][i];
        }
        if(f[x][0]==find_fa(y,m)){
            ans+=sum[xx]-sum[x]+1;
            ans+=TT.get_path(TTfa[x],get_id(y));
            return ans;
        }
        ans+=TT.get_path(get_id(y),rt[find_fa(y,m)]);y=find_fa(y,m);
        yy=y;
        for(int i=18;i>=0;i--){
            if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];
        }
        ans+=sum[xx]-sum[x]+sum[yy]-sum[y]+2;
        ans+=TT.get_path(TTfa[x],TTfa[y]);
        return ans;
    }
}BT;
signed main(){
    TT.build();BT.build();
    while(q--){
        int x=read(),y=read();
        printf("%lld\n",BT.lca(x,y));
    }
    return 0;
}
```

---

## 作者：Find_Yourself (赞：0)

有意思的题，927ms 拿下最优解。

点数最多 $10^{10}$ 个，没法暴力拼接，考虑简化大树。

每次拼接，我们记录 $x$，$to$ 和 $to$ 所在大树的根节点 $rt$。然后连两条边： $(rt,to)$ 和 $(to,x)$。本质上相当于把每次接上来的子树缩成一个点。

这样大树的点数最多就只有 $2\times 10^5$ 个了。

考虑询问。我们定义 $tu,tv$ 为两点在模板树上的编号，$u,v$ 为大树的编号。然后对于一个节点 $u$，我们可以通过二分+主席树算出 $tu$，方法显然不再赘述。

每次询问给定 $u,v$。分三种情况讨论。

1. $u,v$ 在同一颗子树内：直接算出 $tu,tv$ 在模板树中计算答案。

2. $u,v$ 中一个为另一个的祖先：令 $u$ 为大树中深度更深的节点，求出其在对应子树中的深度，跳到离 $v$ 最近的节点，然后转化到模板树上求距离。

3. 其他情况：分别求出 $u,v$ 在对应子树中的深度，定义 $g$ 为 $u,v$ 在大树上的 LCA，然后让 $u,v$ 分别跳到离 $g$ 最近的节点，转化到模板树上求距离即可。

复杂度 $O(n\log n)$。注意编号不要搞混。

code:

```cpp
//fa[i][j]模板树，adj[u]模板树，fa2[i][j]新树
//siz[u]模板树
//dep[u]模板树u深度，dep2[u]新树节点u的深度，dis[u]新树节点u在大树上的深度
//dfn[u],r[u]模板树的dfs序
//a[i]dfs序为i的节点编号
//rk[i]模板树节点i在子树中的排名
//rt[i]模板树上主席树，t[u]主席树
//c[i]模板树树桩数组
//cnt为dfn序计数变量
//tot为新树编号计数变量
//num为主席树编号计数变量
//sum[i]进行i次拼接操作后大树的大小
//tx,ty模板树编号
//x,y大树编号
//dy[x]新树节点x对应的模板树编号
//head[i]第i次拼接的根的新树编号
//g[i]计算模板树节点排名的过程数组
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2e5+5;
int n,m,q,fa[N][22],siz[N],dep[N],dep2[N],r[N],fa2[N][22],a[N],rk[N],rt[N],dfn[N],num=0,dy[N],c[N];
int tot=1,cnt=0;
ll sum[N],head[N],dis[N];
vector<int>adj[N];
struct node{int val,op;node(int val=0,int op=0):val(val),op(op){}};
vector<node>g[N];
struct tree{int ch[2],d;}t[N*30];
void dfs(int u,int lst){
  dep[u]=dep[lst]+1;fa[u][0]=lst;siz[u]=1;dfn[u]=++cnt;a[cnt]=u;
  for(int i=1;i<=20;++i)fa[u][i]=fa[fa[u][i-1]][i-1];
  for(int i=0;i<adj[u].size();++i){
    int v=adj[u][i];if(v==lst)continue;
    dfs(v,u);siz[u]+=siz[v];
  }
  r[u]=cnt;
  g[dfn[u]-1].push_back(node(u,-1));
  g[r[u]].push_back(node(u,1));
}
int lca(int u,int v){
  if(dep[u]<dep[v])swap(u,v);
  for(int i=20;i>=0;--i)if(dep[fa[u][i]]>=dep[v])u=fa[u][i];
  if(u==v)return u;
  for(int i=20;i>=0;--i)if(fa[u][i]!=fa[v][i])u=fa[u][i],v=fa[v][i];
  return fa[u][0];
}
int lbt(int x){return x&(-x);}
void update(int i){for(;i<=n;i+=lbt(i))++c[i];}
int getsum(int i){
  int res=0;
  for(;i;i-=lbt(i))res+=c[i];
  return res;
}
void add(int v,int u,ll w){
  dis[v]=dis[u]+w;dep2[v]=dep2[u]+1;
  fa2[v][0]=u;
  for(int i=1;i<=20;++i)fa2[v][i]=fa2[fa2[v][i-1]][i-1];
}
void change(int x,int &y,int l,int r,int k){
  y=++num;t[y]=t[x];
  if(l==r){++t[y].d;return;}
  int mid=(l+r)>>1;
  if(k<=mid)change(t[x].ch[0],t[y].ch[0],l,mid,k);
  else change(t[x].ch[1],t[y].ch[1],mid+1,r,k);
  t[y].d=t[t[y].ch[0]].d+t[t[y].ch[1]].d;
}
int query(int x,int y,int l,int r,int k){
  if(l==r)return l;
  int tmp=t[t[y].ch[0]].d-t[t[x].ch[0]].d,mid=(l+r)>>1;
  if(tmp>=k)return query(t[x].ch[0],t[y].ch[0],l,mid,k);
  else return query(t[x].ch[1],t[y].ch[1],mid+1,r,k-tmp);
}
int sonv;
inline pair<int,int> lca2(int u,int v){
  bool flag=0;
  if(dep2[u]<dep2[v])swap(u,v),flag=1;
  for(int i=20;i>=0;--i)if(dep2[fa2[u][i]]>dep2[v])u=fa2[u][i];
  sonv=u;
  if(dep2[u]>dep2[v])u=fa2[u][0];
  if(u==v)return make_pair(u,v);
  for(int i=20;i>=0;--i)if(fa2[u][i]!=fa2[v][i])u=fa2[u][i],v=fa2[v][i];
  if(flag)swap(u,v);
  return make_pair(u,v);
}
int P;
inline int getreal(ll x,int i){
  P=lower_bound(sum,sum+i+1,x)-sum;
  int u=dy[head[P]];
  return query(rt[dfn[u]-1],rt[r[u]],1,n,x-(P?sum[P-1]:0));
}
inline ll read()
{
	ll x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int main(){
  n=read();m=read();q=read();
  for(int i=1;i<n;++i){
    int u,v;u=read();v=read();
    adj[u].push_back(v);adj[v].push_back(u);
  }
  dfs(1,0);
  for(int i=1;i<=n;++i){
    update(a[i]);
    for(int j=0;j<g[i].size();++j){
      node tmp=g[i][j];
      rk[tmp.val]+=tmp.op*getsum(tmp.val);
    }
  }
  for(int i=1;i<=n;++i)change(rt[i-1],rt[i],1,n,a[i]);
  sum[0]=n;dep2[1]=dis[1]=head[0]=dy[1]=1;
  for(int i=1;i<=m;++i){
    ll tx,x,ty,y;tx=read();y=read();sum[i]=sum[i-1]+siz[tx];
    x=rk[tx]+sum[i-1];
    ty=getreal(y,i);
    dy[++tot]=ty;
    add(tot,head[P],dep[ty]-dep[dy[head[P]]]);
    dy[++tot]=tx;head[i]=tot;
    add(tot,tot-1,1);
  }
  while(q--){
    ll u,v,ans=0;u=read();v=read();
    int tu=getreal(u,m),hu=head[P],gu=dy[hu];
    int tv=getreal(v,m),hv=head[P],gv=dy[hv];
    int Lca;
    if(hu==hv)ans=dep[tu]+dep[tv]-2*dep[lca(tu,tv)];
    else{
      pair<int,int>pr=lca2(hu,hv);
      if(pr.first==pr.second){
        if(pr.first==hu)swap(u,v),swap(tu,tv),swap(hu,hv),swap(gu,gv);
        ans+=dep[tu]-dep[gu]+dis[hu]-dis[sonv];
        u=dy[sonv];
        ans+=dep[u]+dep[tv]-2*dep[lca(u,tv)];
      }else{
        ans+=dep[tu]-dep[gu]+dep[tv]-dep[gv]+dis[hu]-dis[pr.first]+dis[hv]-dis[pr.second];
        u=dy[pr.first];v=dy[pr.second];
        ans+=dep[u]+dep[v]-2*dep[lca(u,v)];
      }
    }
    printf("%lld\n",ans);
  }
  return 0;
}

```


---

## 作者：_HL_ (赞：0)

楼上做法已经讲得很详细了 我主要是做了个比直观的图 qwq

简单讲一下做法

子树复制 $10^5$ 范围暴力复制肯定寄

我们称复制的一个模板树上的子树为一个树上的块

由于只有一个模板树 本质不同的树上的块是有限的

我们要求树上路径长度 考虑将复制块内和块外的祖先关系分开讨论 如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/qjmm30t5.png)

两红点之间的树上路径 为黄色所示

由于需要在树上动态加点 所以用倍增 考虑具体实现：

$fa_{x,k}$ 表示树块 $x$ 的第 $k$ 级祖先的树块编号

$pa_{x,k}$ 表示树块 $x$ 向上跳 $k$ 个树块后落在该树块哪个点上

讨论一下 

特殊的部分只有红点到所在树块根，和 $\text{lca}$ 树块两个 $pa$ 的树块内距离

由于复制树块时树块编号顺序与模板树相同 我们可以考虑将该树块等价到模板树上讨论 所以只需要转 dfs 序 主席树维护区间 kth 即可

其余部分树上差分可以快速搞

复杂度似乎是时空都单只 $\log$ 的 不过常数有亿些大 

总的来讲这道题思维难度不大 是道大模拟题 但细节有些多 比较难调。。调了3个半小时。。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
inline int read()
{
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c<='9'&&c>='0')
	{
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x;
}
const int N=1e5+3;
int n;
struct edge
{
	int to,nxt;
}e[N<<1];
int h[N],etot;
inline void eadd(int x,int y)
{
	e[++etot].to=y;
	e[etot].nxt=h[x];
	h[x]=etot;
}
int dfn[N],dep[N],dcnt,fa1[N],siz[N],top[N],son[N];
void dfs1(int x)
{
	siz[x]=1;
	int mxson=-1;
	for(int i=h[x];i;i=e[i].nxt)
	{
		if(e[i].to!=fa1[x])
		{
			fa1[e[i].to]=x;
			dep[e[i].to]=dep[x]+1;
			dfs1(e[i].to);
			siz[x]+=siz[e[i].to];
			if(siz[e[i].to]>mxson)
			{
				mxson=siz[e[i].to];
				son[x]=e[i].to;
			}
		}
	}
}
int a[N];
void dfs2(int x,int topn)
{
	top[x]=topn;
	dfn[x]=++dcnt;
	a[dcnt]=x;
	if(!son[x])return;
	dfs2(son[x],topn);
	for(int i=h[x];i;i=e[i].nxt)
	{
		if(e[i].to!=son[x]&&e[i].to!=fa1[x])
		dfs2(e[i].to,e[i].to);
	}
}
inline int get_lca(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		x=fa1[top[x]];
	}
	if(dep[x]>dep[y])swap(x,y);
	return x;
}
int rt[N],ndtot;
struct seg
{
	int val,son[2];
}t[N*100];
#define ls t[p].son[0]
#define rs t[p].son[1]
inline void update(int p)
{
	t[p].val=t[ls].val+t[rs].val;
}
void modify(int l,int r,int x,int &p,int o)
{
	p=++ndtot;
	if(l==r)
	{
		t[p].val=t[o].val+1;
		return;
	}
	int mid=l+r>>1;
	if(x<=mid)
	{
		if(t[o].son[1])rs=t[o].son[1];
		modify(l,mid,x,ls,t[o].son[0]);
	}
	else
	{
		if(t[o].son[0])ls=t[o].son[0];
		modify(mid+1,r,x,rs,t[o].son[1]);
	}
	update(p);
}

inline int rk(int l,int r,int k)
{
	int p=rt[r],o=rt[l-1];
	l=1,r=n;
	while(1)
	{
		if(l==r)return l;
		int mid=l+r>>1;
		int tmp=t[ls].val-t[t[o].son[0]].val;
		if(k<=tmp)
		{
			p=ls;
			o=t[o].son[0];
			r=mid;
		}
		else
		{
			k-=tmp;
			p=rs;
			o=t[o].son[1];
			l=mid+1;
		}
	}
}
int nd,tot;
int st[N],ed[N],pa[N][20],fa[N][20],root[N],dd[N],dis[N];
inline int get_dis(int x,int y)
{
	int lca=get_lca(x,y);
	return dep[x]+dep[y]-2*dep[lca];
}
inline int qry(int id,int p)
{
	int res=rk(dfn[root[id]],dfn[root[id]]+siz[root[id]]-1,p-st[id]+1);
	return res;
}
inline void solve(int x,int y,int idx,int idy)
{
	if(dd[idx]<dd[idy])swap(idx,idy),swap(x,y);
	int res=get_dis(qry(idx,x),root[idx]);
	res+=dis[idx];
	for(int j=log2(dd[idx]-dd[idy]+1)+1;~j;--j)
	if(dd[fa[idx][j]]>=dd[idy])
	{
		x=pa[idx][j];
		idx=fa[idx][j];
	}
	if(idx==idy)
	{
		res-=dis[idx];
		res-=get_dis(qry(idx,x),root[idx]);
	}
	else
	{
		res+=dis[idy];
		res+=get_dis(qry(idy,y),root[idy]);
		for(int j=log2(dd[idx]+1)+1;~j;--j)
		{
			if(fa[idx][j]!=fa[idy][j])
			{
				x=pa[idx][j];
				y=pa[idy][j];
				idx=fa[idx][j];
				idy=fa[idy][j];
			}
		}
		x=pa[idx][0];
		y=pa[idy][0];
		idx=fa[idx][0];
		idy=fa[idy][0];
		res-=2*dis[idx];
		res-=get_dis(qry(idx,x),root[idx]);
		res-=get_dis(qry(idy,y),root[idy]);
	}
	res+=get_dis(qry(idx,x),qry(idy,y));
	printf("%lld\n",res);
}
signed main()
{
	//freopen("in.txt","r",stdin);
	//freopen("out.txt","w",stdout);
	n=read();
	int m=read(),q=read();
	for(int i=1;i<n;i++)
	{
		int x=read(),y=read();
		eadd(x,y);
		eadd(y,x);
	}
	dfs1(1);
	dfs2(1,1);
	for(int i=1;i<=n;i++)
	modify(1,n,a[i],rt[i],rt[i-1]);
	st[1]=1;
	tot=ed[1]=siz[1];
	nd=root[1]=dd[1]=1;
	for(int i=1;i<=m;i++)
	{
		int x=read(),p=read();
		st[++nd]=tot+1;
		ed[nd]=tot+siz[x];
		tot+=siz[x];
		int id=lower_bound(ed+1,ed+nd+1,p)-ed;
		pa[nd][0]=p;
		fa[nd][0]=id;
		root[nd]=x;
		dd[nd]=dd[id]+1;
		dis[nd]=dis[id]+1+get_dis(root[id],qry(id,p));
		for(int j=1;;j++)
		{
			if(fa[fa[nd][j-1]][j-1]==0)break;
			fa[nd][j]=fa[fa[nd][j-1]][j-1];
			pa[nd][j]=pa[fa[nd][j-1]][j-1];
		}
	}
	for(int i=1;i<=q;i++)
	{
		int x=read(),y=read();
		int idx=lower_bound(ed+1,ed+nd+1,x)-ed,idy=lower_bound(ed+1,ed+nd+1,y)-ed;
		if(idx==idy)
		{
			printf("%lld\n",get_dis(qry(idx,x),qry(idy,y)));
		}
		else
		{
			solve(x,y,idx,idy);
		}
	}
	return 0;
}

```







---


# [JLOI2014] 路径规划

## 题目描述

相信大家都用过地图上的路径规划功能，只要输入起点终点就能找出一条最优路线。现在告诉你一张地图的信息，请你找出最优路径（即最短路径）。考虑到实际情况，一辆车加满油能开的时间有限，**为 $limit$**，所以在地图上增加了几个加油站。

地图由点和双向边构成，每个点代表一个路口，也有可能是加油站或起点终点。有些路口还装有红绿灯。由于经过太多的红绿灯会让人感到不爽，所以请求在经过不超过 $k$ 个红绿灯的情况下，最少平均花费多少时间能从起点到终点。保证起点终点和加油站没有红绿灯。（题目不考虑最坏情况下能否加到油，只考虑平均花费时间的前提下，车能否到达加油站加油）。


注意：

1. $limit$ 指的是车最多能走多长时间，可以看作车的油箱，是不能叠加的（比如不能连续经过多个加油站后剩余能走的时间 $>limit$）。
2. 与上面类似，一个加油站最多只能加到 $limit$，不能累加。
3. 不管在加油站加多少油，反正加一次耗费的时间都是 $cost$。
4. 经过加油站可以不加油。



## 说明/提示

共 $14$ 组数据。

- 其中 $3$ 组数据，满足 $1 \le n<10$，$1 \le m<20$，$1 \le k<5$。
- 另有 $3$ 组没有红绿灯。

所有数据满足 $1 \le n \le 10000$，$1 \le m \le 20000$，$1 \le k \le 10$，加油站 $\le 50$。

## 样例 #1

### 输入

```
5 8 1 100 10
start 0 0
azhan 10 10
xxgasxx 0 5
bpoint 20 5
end 0 100
start azhan sdf 30
azhan xxgasxx ewfg 20
start end r3tg 200
end azhan 1xq2 70
azhan bpoint gg 10
xxgasxx bpoint kk 30
bpoint end dsg 40
xxgasxx end t_s 100```

### 输出

```
162.500```

# 题解

## 作者：斯德哥尔摩 (赞：8)

[P3259 [JLOI2014]路径规划](https://www.luogu.org/problemnew/show/P3259)

这种题为什么做的人这么少？？？

我来贡献一发题解。

### 题目大意：

给定一个无向图，每条边有边权，有些点有点权，一些点是加油站。

求一条起点到终点的最短路，使经过有点权的点不超过$k$次，一管油只能走$limit$的时间，时间到了就只能到加油站花$cost$的时间加油。

### 解法

那个红绿灯的计算公式是$\frac{red^2}{2\times(red+green)}$。

然后把这个时间附加到节点的出边上。

然后，我们建立分层图：

第$i$层表示经过了$i$个红绿灯时，从源点到该点的最短路径长度。

如果没有油量限制，那么我们直接跑最短路就行了。

所以我们考虑如何去掉这个油量限制。

注意到加油站很少，于是我们枚举以每个加油站为起点，向其他加油站经过若干个红绿灯的最短路径。

若此长度不大于最大油量，那么可以直接转移。

我们用这种方法构造新图，依旧是分层图，可是每一层仅有$50$个点，且没有油量限制。

然后就能跑分层图$SPFA$了。

注：不知道为什么，我的$SPFA$要加上$SLF$优化才能过，否则就是#4 $TLE$。

[有空就到本蒟蒻的博客里坐坐嘛！](https://www.cnblogs.com/Yangrui-Blog/p/9535892.html)

附代码：（我自己都觉得好丑啊。。。）
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<map>
#include<string>
#include<deque>
#include<cmath>
#define MAXN 10010
#define MAXM 200010
#define eps (1e-7)
#define MAX (1<<30)//一大堆宏定义
using namespace std;

map<string,int> name;//直接用map存节点编号
int n,m,k,cost,limit,s,t;
int top=0,gas_stack[MAXN],id[MAXN][12];
double length[MAXN];
bool gas[MAXN];

inline int read(){
	int date=0,w=1;char c=0;
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}

struct SPFA{
	int c,head[MAXM];
	double path[MAXM];
	bool vis[MAXM];
	SPFA(){c=1;}
	struct Graph{
		int next,to;
		double w;
	}a[MAXM<<2];
	inline int relax(int u,int v,double w){
		if(path[v]>path[u]+w){
			path[v]=path[u]+w;
			return 1;
		}
		return 0;
	}
	inline void add(int u,int v,double w){
		a[c].to=v;a[c].w=w;a[c].next=head[u];head[u]=c++;
	}
	void spfa(int s){
	    int u,v;
	    deque<int> q;
	    for(int i=1;i<=n*(k+1);i++){path[i]=MAX;vis[i]=false;}
	    path[s]=0;
	    vis[s]=true;
	    q.push_back(s);
	    while(!q.empty()){
	        u=q.front();
	        q.pop_front();
	        vis[u]=false;
	        for(int i=head[u];i;i=a[i].next){
	            v=a[i].to;
	            if(relax(u,v,a[i].w)&&!vis[v]){
	                vis[v]=true;
	                if(!q.empty()){
	                    if(path[v]>path[q.front()])q.push_back(v);
	                    else q.push_front(v);
	                }
	                else q.push_back(v);
	            }
	        }
	    }
	}
}one,two;//旧图和新图

inline void add_edge(int u,int v,int w){//建立分层图
	if(fabs(length[v])>eps)for(int j=0;j<k;j++)one.add(id[u][j],id[v][j+1],w+length[v]);
	else for(int j=0;j<=k;j++)one.add(id[u][j],id[v][j],w);
}
void work(){//求解
	double ans=MAX;
	two.spfa(s);
	for(int i=0;i<=k;i++)ans=min(ans,two.path[t+i*n]);
	printf("%.3lf\n",ans);
}
void init(){//读入+预处理+建分层图
	string x;
	int u,v;
	double w;
	n=read();m=read();k=read();limit=read();cost=read();
    
	for(int i=0;i<=k;i++)
	for(int j=1;j<=n;j++)
	id[j][i]=j+i*n;
    
	for(int i=1;i<=n;i++){
		cin>>x;
		name[x]=i;
		int red=read(),green=read();
		if(x=="start")s=i;
		else if(x=="end")t=i;
		if(x.find("gas")!=string::npos)gas[i]=true;
		if(red)length[i]=1.00*red*red/(double)(2.00*(red+green));
		else length[i]=0;
	}
    
	for(int i=1;i<=m;i++){
		cin>>x;u=name[x];
		cin>>x;v=name[x];
		cin>>x;w=read();
		add_edge(u,v,w);
		add_edge(v,u,w);
	}
    
	gas[s]=gas[t]=true;
	for(int i=1;i<=n;i++)if(gas[i])gas_stack[++top]=i;
    
	for(int i=1;i<=top;i++){//旧图与新图的转换
		one.spfa(gas_stack[i]);
		for(int j=1;j<=top;j++){
			if(i==j)continue;
			w=(gas_stack[j]!=s&&gas_stack[j]!=t)?cost:0;
			for(int l=0;l<=k;l++)
			if(one.path[id[gas_stack[j]][l]]<=limit)
			for(int p=0;p+l<=k;p++)
			two.add(id[gas_stack[i]][p],id[gas_stack[j]][p+l],one.path[id[gas_stack[j]][l]]+w);
		}
	}
}
int main(){//主函数So easy!
	init();
	work();
    return 0;
}
```

---

## 作者：_Deer_Peach_ (赞：4)

背景：

放在训练里的压轴题，一道分层图~~难~~好题，这真把作者卡了好久，~~但为什么会放在树上差分的训练里？~~

题意：

有 $n$ 个点 $m$ 条边，车能开 $limit$ 长的时间，及加油所花时间 $cost$。$n$ 个点包括起点，终点，加油站和其他地方，有些地方可能有红绿灯，有些没有。求在经过不超过 $k$ 个红绿灯的情况下从起点到终点花费的最短时间。

思路：

题目中有很多的输入是无用信息，注意辨别（应该没人和作者一样记录这么多没用的信息吧）。

很明显是分层图最短路，从不超过 $k$ 个红绿灯以及车能行驶的时长就可以体现出。如果没写过分层图，建议看看[这题
](https://www.luogu.com.cn/problem/P4568)。

考虑建红绿灯的分层图，经过 $k$ 个红绿灯就是第 $k$ 层图。然后，我们可以发现，在这些点中，除了起点终点，只有加油站是有用的，其它的点是没有用的。所以我们可以记录下加油站，这样以每个加油站为起点求最短路，对于其他的加油站的每一层的点，能在行驶时长范围内跑到的点，就连接一条边建出新图。

还要计算红绿灯的平均等待时间。

设红灯时长为 $rt$，绿灯时长为 $gt$，到达红绿灯的时间为 $x$，则 $0 \le x \le rt+gt$。

等待时间分两种情况：
1. $0 \le x \lt rt$，也就是红灯，等待时间为 $rt-x$；
2. $rt \le x \le rt+gt$，也就是绿灯，等待时间为 $0$。

那么期望等待时间为 $\frac{rt-x}{rt+gt}$。

可以用函数图像解，设函数 $y=\frac{rt-x}{rt+gt}$，我们要求 $x$ 轴，$y$ 轴和函数图像围成的三角形面积。

不难计算，与 $y$ 轴相交的点为 $(0,\frac{rt}{rt+gt})$，与 $x$ 轴相交的点坐标为 $(rt,0)$。三角形面积就为 $\frac{1}{2} \times rt \times \frac{rt}{rt+gt} = \frac{rt^2}{2 \times (rt+gt)}$。

直接把这个值加到对应的边上就行了。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
const int N=1e6+5,M=2e6+5;
int n,m,k,limit,cost;
int Start,End;
inline int where(string x){
	if(x=="start")return 1;
	if(x=="end")return 2;
	int len=x.size();
	for(int i=0;i+2<len;i++){
		if(x[i]=='g'&&x[i+1]=='a'&&x[i+2]=='s')return 3;
	}return 4;
}map<string,int>nid;
struct node{
	int x,y;
	double Time;
};
double rd[N];
vector<int>Gas;
int sid[15][N];
bool vis[N];
struct pq{
	double w;
	int x;
	bool operator<(const pq a)const{
		return w>a.w;
	}
};
struct{
	vector<node>g[N];
	double dis[N];
	bool vis[N];
	void dijkstra(int start){
		for(int i=1;i<N;i++){
			vis[i]=false;
			dis[i]=INT_MAX;
		}
		dis[start]=0;
		priority_queue<pq>q;
		q.push(pq{0,start});
		while(!q.empty()){
			int x=q.top().x;
			q.pop();
			if(vis[x])continue;
			vis[x]=true;
			int len=g[x].size();
			for(int i=0;i<len;i++){
				int y=g[x][i].y;
				if(dis[y]>dis[x]+g[x][i].Time){
					dis[y]=dis[x]+g[x][i].Time;
					q.push(pq{dis[y],y});
				}
			}
		}
		
	}
}G,GG;
signed main(){
	IOS;
	cin>>n>>m>>k>>limit>>cost;
	for(int i=0;i<=k;i++)
		for(int j=1;j<=n;j++)
			sid[i][j]=i*n+j;
	for(int i=1;i<=n;i++){
		string name;
		double rt,gt;
		cin>>name>>rt>>gt;
		int Pla=where(name);
		nid[name]=i;
		if(Pla<4)Gas.push_back(i);
		if(name=="start")Start=i;
		if(name=="end")End=i;
		if(rt)rd[i]=rt*rt/((rt+gt)*2.0);
	}
	for(int i=1;i<=m;i++){
		string start,eend,name;
		double Time;
		cin>>start>>eend>>name>>Time;
		int x=nid[start];
		int y=nid[eend];
		double w=Time;
		if(rd[y]!=0){
			for(int j=0;j<k;j++){
				int sx=sid[j][x],ex=sid[j+1][y];
				G.g[sx].push_back(node{sx,ex,w+rd[y]});
			}
		}else{
			for(int j=0;j<=k;j++){
				int sx=sid[j][x],ex=sid[j][y];
				G.g[sx].push_back(node{sx,ex,w});				
			}
		}
		
		swap(x,y);
		
		if(rd[y]!=0){
			for(int j=0;j<k;j++){
				int sx=sid[j][x],ex=sid[j+1][y];
				G.g[sx].push_back(node{sx,ex,w+rd[y]});
			}
		}else{
			for(int j=0;j<=k;j++){
				int sx=sid[j][x],ex=sid[j][y];
				G.g[sx].push_back(node{sx,ex,w});				
			}
		}
	}
	int len=Gas.size();
	for(int i=0;i<len;i++){
		int x=Gas[i];
		G.dijkstra(sid[0][x]);
		for(int j=0;j<len;j++){
			if(i==j)continue;
			int y=Gas[j];
			int Tim=(x==Start||x==End?0:cost);
			for(int I=0;I<=k;I++){
				if(G.dis[sid[I][y]]>limit)continue;
				for(int J=0;I+J<=k;J++){
					int xx=sid[J][x];
					int yy=sid[I+J][y];
					double ww=G.dis[sid[I][y]]+Tim;
					GG.g[xx].push_back(node{xx,yy,ww});
				}
			}
		}
	}
	GG.dijkstra(sid[0][Start]);
	double ans=INT_MAX;
	for(int i=0;i<=k;i++){
		ans=min(ans,GG.dis[sid[i][End]]);
	}
	printf("%.3lf",ans);
	return 0;
}
```
[提交记录](https://www.luogu.com.cn/record/209155661)。

---

## 作者：uncle_steve (赞：1)

等红绿灯所花费时间的期望为 $\frac{x^2}{2(a+b)}$。具体的，我们假设一个长度为 $a+b$ 的周期中红灯的出现时间为 $[0,a]$ 这一区间， 我们在 $x$ 时刻到达的概率是 $\frac{1}{a+b}$，等待的时间期望为 $\frac{a-x}{a+b}$
。那么总的期望就是:

$\displaystyle \int_0^x \frac{a-x}{a+b} \mathop{}\!\mathrm{d} x = \frac{x^2}{2(a+b)}$

由于加油站很少，我们考虑预处理出从每个加油站出发能到达哪些加油站。注意，这里我们将起点和终点也视作加油站。那么这就是一个分层图问题，我们设 $d[i][j]$ 
表示经过了 $i$ 个红绿灯到达 $j$ 的最短路，这个东西可以用 SPFA 轻松求出。

现在我们已经知道了每个加油站可以到哪些加油站以及中间需要经过的红绿灯数，那么其余的不是加油站的点都已经没有用了。我们可以建一张新图，只保留加油站，得到的仍是分层图。然后再在新图上跑一边 SPFA 
即可得到答案。

## 放代码：


```cpp
#include<bits/stdc++.h>
#define MAXN 20010
#define INF 0x3f3f3f3f
#define fir first
#define sec second
#define mkp make_pair
using namespace std;
typedef pair<int, int> pa;
double d[15][MAXN];
bool vis[15][MAXN];
map<string, int> ma;
struct Point {
	int r, g; double w;
}p[MAXN];
struct Edge {
	int t, next; double v;
}e[MAXN << 1];
struct New {
	int t, next, w; double v;
}g[MAXN << 1];
int hd1[MAXN], cnt1, hd2[MAXN], cnt2, N, M, K, L, C, gas[MAXN], tot;
inline void Add_Edge(int from, int to, double v) {
	e[++cnt1].t = to; e[cnt1].next = hd1[from]; hd1[from] = cnt1; e[cnt1].v = v;
}
inline void Add_New(int from, int to, double v, int w) {
	g[++cnt2].t = to; g[cnt2].next = hd2[from]; hd2[from] = cnt2; g[cnt2].v = v; g[cnt2].w = w;
}
queue< pa >q;
inline void Spfa1(int S) {
	memset(vis, 0, sizeof(vis));
	memset(d, 0x7f, sizeof(d));
	d[0][S] = 0; q.push(mkp(S, 0)); vis[0][S] = 1;
	while (!q.empty()) {
		int u = q.front().fir, x = q.front().sec; q.pop(); vis[x][u] = 0;
		for (int i = hd1[u]; i; i = e[i].next) {
			int v = e[i].t, y = p[v].r ? x + 1 : x;
			double dis = e[i].v + p[v].w + d[x][u];
			if (dis <= L && dis<d[y][v] && y <= K) {
				d[y][v] = dis;
				if (!vis[y][v])vis[y][v] = 1, q.push(mkp(v, y));
			}
		}
	}
}
inline void Spfa2(int S) {
	memset(vis, 0, sizeof(vis));
	memset(d, 0x7f, sizeof(d));
	d[0][S] = 0; q.push(mkp(S, 0)); vis[0][S] = 1;
	while (!q.empty()) {
		int u = q.front().fir, x = q.front().sec; q.pop(); vis[x][u] = 0;
		for (int i = hd2[u]; i; i = g[i].next) {
			int v = g[i].t, y = x + g[i].w;
			if (y>K)continue;
			double dis = g[i].v + C + d[x][u];
			if (dis<d[y][v]) {
				d[y][v] = dis;
				if (!vis[y][v])vis[y][v] = 1, q.push(mkp(v, y));
			}
		}
	}
}
string s, s1, s2;
int S, T, x, y;
int main() {
#ifndef ONLINE_JUDGE
	freopen("pathplan.in", "r", stdin);
	freopen("pathplan.out", "w", stdout);
#endif
	scanf("%d%d%d%d%d", &N, &M, &K,&L, &C);
	for (int i = 1; i <= N; i++) {
		cin >> s; scanf("%d%d", &p[i].r, &p[i].g);
		ma[s] = i;
		if (s.find("gas") != string::npos)gas[++tot] = i;
		if (!s.compare("start"))S = i, gas[++tot] = i;
		if (!s.compare("end"))T = i, gas[++tot] = i;
		if (p[i].r)p[i].w = (double)p[i].r*p[i].r*0.5 / (p[i].r + p[i].g);
	}
	for (int i = 1; i <= M; i++) {
		cin >> s >> s1 >> s2; scanf("%d", &x);
		Add_Edge(ma[s], ma[s1], x); Add_Edge(ma[s1], ma[s], x);
	}
	for (int i = 1; i <= tot; i++) {
		Spfa1(gas[i]);
		for (int j = 1; j <= tot; j++) {
			if (j == i)continue;
			for (int k = 0; k <= K; k++) {
				if (d[k][gas[j]] != INF)Add_New(gas[i], gas[j], d[k][gas[j]], k);
			}
		}
	}
	Spfa2(S);
	double ans = INF;
	for (int i = 0; i <= K; i++)ans = min(ans, d[i][T]);
	printf("%.3lf", ans - C);
	return 0;
}
```

---

## 作者：Laoshan_PLUS (赞：1)

# [P3259 [JLOI2014] 路径规划](https://www.luogu.com.cn/problem/P3259)

如此分层图好题做的人却不多，不知为何。

## 红绿灯的期望通过时间

省流：$\dfrac{a^2}{2(a+b)}$。具体计算过程如下：

首先标签带一个 `数学` 的原因就是在于**红绿灯期望通过时间**的计算。由于我们可以在任意时刻进入这个红绿灯，由于一个红绿灯的周期是 $[0,a+b]$，其中 $a$ 是红灯时长，$b$ 是绿灯时长。考虑设我们在第 $x$ 个时刻进入这个红绿灯，其中 $x\in[0,a+b]$，那么有两种情况：

- $a\le x\le a+b$，此时不需要等，期望通过时间为 $0$；
- $0\le x<a$，此时需要等的时间为 $a-x$。

于是容易得到对于任意的 $x\in[0,a)$，我们的期望通过时间为 $\dfrac{a-x}{a+b}$。实际上如果我们会积分，这个东西就是
$$
\int_0^a\frac{a-x}{a+b}\,\mathrm dx=\frac{a^2}{2(a+b)}
$$
但是我们不会积分，于是考虑作出函数图象 $y=\dfrac{a-x}{a+b}$，我们要求的就是这个函数图象和 $x$ 轴、$y$ 轴围成的一个三角形的面积。显然这是个一次函数，经计算可得到与 $x$ 轴的交点 $A(a,0)$，与 $y$ 轴的交点为 $B\bigg(0,\dfrac a{a+b}\bigg)$，所以
$$
S_{\triangle\text{OAB}}=\frac12\times a\times\frac a{a+b}=\frac{a^2}{2(a+b)}
$$
这个东西就是这么来的。

知道了每个红绿灯的期望通过时间，考虑直接把这个时间加到这个点出边的边权里，这个部分就解决了。

## 分层图最短路

考虑分层图的原因是：本题的最短路有两个限制：油量的限制 $\mathit{limit}$，以及不能走超过 $k$ 个红绿灯。并且 $\mathit{limit}$ 和 $k$ 都很小，这就妥妥的分层图最短路。

但是分层图最短路只能解决一个限制，不妨先解决红绿灯，因为 $k$ 比 $\mathit{limit}$ 要小，并且 “不能超过” 这个限制比油量的限制好实现一些，设计第 $i$ 层图表示经过 $i$ 个红绿灯的最短路，在红绿灯节点上连接相邻两层。

如果没有油量的限制，我们直接从第零层的起点跑最短路，最后在终点的各个层统计 $\text{dis}$ 的最小值即可。但是做题没有如果，现在我们要加上油量的限制，虽然不能通过分层图解决，但是我们发现 $\mathit{limit}$ 也很小，而除了加油站之外的点**没什么用**。所以考虑先建出原图的分层图，枚举每个加油站 $x$ 作为起点跑最短路，然后看对于其他的加油站 $y$ 的每一层的点，有哪些点是能用一箱油跑到的，然后每层之间连接 $x\to y$ 的边，建出一个新图。

这个新图也是有 $k$ 层，每层的点不超过 $\mathit{limit}$ 个。在新图上第零层的起点跑最短路，最后在终点的各个层统计 $\text{dis}$ 的最小值即可。

时间复杂度方面，由于原图有 $nk$ 个节点，而瓶颈在于我们需要跑 $\mathit{limit}$ 遍原图的最短路，应该是 $O(\mathit{limit}\times mk\log nk)$，总之是能过且很快。

```cpp
#include<bits/stdc++.h>
using namespace std;

constexpr int MAXN=1.1e6+5;
constexpr double INF=156842099845.0,eps=1e-10;
int n,m,k,limit,cost,S,T;
int id[11][MAXN/10];
unordered_map<string,int>mp;
vector<int>gas;
double out[MAXN];
struct{
	int head[MAXN],tot;
	struct{
		int v,to;
		double w;
	}e[MAXN<<1];
	void addedge(int u,int v,double w){
		e[++tot]={v,head[u],w};
		head[u]=tot;
	}
	void addf(int u,int v,double w){
		if(fabs(out[v])>eps)
			for(int i=0;i<k;i++)
				addedge(id[i][u],id[i+1][v],w+out[v]);
		else
			for(int i=0;i<=k;i++)
				addedge(id[i][u],id[i][v],w);
	}
	double dis[MAXN];
	bool vis[MAXN];
	void dijkstra(int s){
		memset(dis,0x42,(n*(k+1)+1)<<3); // double也是可以memset的哦！
		memset(vis,0,n*(k+1)+1);
		priority_queue<pair<double,int>>q;
		dis[s]=0;
		q.emplace(0,s);
		while(!q.empty()){
			int u=q.top().second;
			q.pop();
			if(vis[u]) continue;
			vis[u]=1;
			for(int i=head[u],v;i;i=e[i].to)
				if(dis[v=e[i].v]>dis[u]+e[i].w){
					dis[v]=dis[u]+e[i].w;
					q.emplace(-dis[v],v);
				}
		}
	}
}G,GF; // G原图，GF新图 

int main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>n>>m>>k>>limit>>cost;
	for(int i=0;i<=k;i++)
		for(int j=1;j<=n;j++)
			id[i][j]=i*n+j;
	for(int i=1;i<=n;i++){
		string s;
		int a,b;
		cin>>s>>a>>b;
		mp[s]=i;
		if(s=="start"||s=="end"||s.find("gas")!=string::npos) gas.emplace_back(i);
		if(s=="start") S=i;
		else if(s=="end") T=i;
		if(a) out[i]=1.0*a*a/2/(a+b);
	}
	for(int i=1;i<=m;i++){
		string u,v,fk;
		int w;
		cin>>u>>v>>fk>>w;
		G.addf(mp[u],mp[v],w);
		G.addf(mp[v],mp[u],w);
	}
	for(auto x:gas){
		G.dijkstra(id[0][x]);
		for(auto y:gas){
			if(x==y) continue;
			int w=(x!=S&&x!=T?cost:0);
			for(int i=0;i<=k;i++)
				if(G.dis[id[i][y]]<=limit)
					for(int j=0;i+j<=k;j++)
						GF.addedge(id[j][x],id[i+j][y],G.dis[id[i][y]]+w);
		}
	}
	GF.dijkstra(id[0][S]);
	double ans=INF;
	for(int i=0;i<=k;i++) ans=min(ans,GF.dis[id[i][T]]);
	cout<<fixed<<setprecision(3)<<ans<<'\n';
	return 0;
}
```

---

## 作者：LEWISAK (赞：1)

[传送门](https://www.luogu.com.cn/problem/P3259)

[我的部落格](https://www.cnblogs.com/lewisak/p/18756606)

这个题总体很割裂，感觉是给分层图上面强行套了个数学，不过两部分的思路都挺巧妙的。

# 题目大意

这道题 luogu 题面不太清晰，大意给定一张无向图，你需要开车从起点走到终点，有些点会设红绿灯，给出每个红绿灯的红灯时间和绿灯时间，**你见到红绿灯时红绿灯的状态随机** $^1$，你只能连续开油箱中储存油量时间车（等红绿灯也会耗油），到加油站会补油，求到终点的最优路线，使得：
  1. 期望时间最短。
  2. 经过红绿灯的数量不多于 $k$。

$1$：状态随机指在红绿灯循环周期中的一个随机时刻（可以不是整数）。

# 题解

## 数学部分

先说结论，红绿灯的期望通过时间是 $\frac{red^2}{2(red+green)}$，网上的证明要么不严谨要么要用积分，我来一发亲民的。

注意到当我们在周期的 $x$ 时进入的话，贡献就是 $\max(\frac{red-x}{red+green},0)$，对 $0$ 取 $\max$ 的原因是如果进入的时间大于 $red$ 那么就直接通过了，然后我们以 $8$ 秒红灯，$1$ 秒绿灯画出函数图像：

![](https://cdn.luogu.com.cn/upload/image_hosting/qg6insvq.png)

那么对 $0$ 取 $\max$ 就相当于不计算函数值为负的图像，再加上 $x$ 只能为正就是只算第一象限，不难发现第一象限的贡献之和就是一个三角形：

![](https://cdn.luogu.com.cn/upload/image_hosting/ei72tbnx.png)

然后当 $x$ 取到 $0$ 时有三角形的高 $\frac{red}{red+green}$，三角形的底就是在第一象限时 $x$ 能取到的最大值 $red$，于是有总期望为：

$$
\frac{red}{red+green}\times red\times\frac{1}{2} = \frac{red^2}{2(red+green)}
$$

算完期望后直接开一个输出储存就可以了，接下来转化成了普通图论。

## 图论部分

我们考虑先忽略油量限制，直接对红绿灯建分层图，理由是不多于 $k$ 个红绿灯这个限制长得就像分层图，而且 $k\le 5$。

第 $i$ 层分层图表示经过了 $i$ 个红绿灯，在红绿灯处连接两层分层图，最后建出的图有 $k$ 层，每层 $n$ 个节点。

接下来考虑油量限制，注意到保证中有一个很可以的限制：

> 加油站数量 $\le 50$

于是考虑建出第一张图后枚举加油站作为起点，最短路看其他哪些其他加油站是可以跑到的，然后在这两个加油站中连边建出新图。

然后第二张图也是有 $k$ 层，每层不超过 $50$ 个节点，直接跑起点到终点的最短路就可以了。

最后这个题的复杂度还是证一下，瓶颈显然在于建第二张图对每个加油站跑最短路的复杂度 $O(50km\log{nk})$，计算器敲一下发现是 $1.6\times10^8$ 多一点，实际根本跑不满。

# 代码

代码中最短路用的是 dijkstra。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int eps=1e-7;
namespace FFF{
unordered_map<string,int> dian;
int yo[200200],zhan[200200],id[200200][20],n,m,k,s,t,top,jia,kai;
double out[200200];
struct UUU{
	int tot,head[200200],vis[200200];
	double dis[200200];
	struct CCC{
		int nxt,to;
		double w;
	}e[400400];
	void add(int u,int v,double w){//链式前向星
		e[++tot].to=v;
		e[tot].nxt=head[u];
		e[tot].w=w;
		head[u]=tot;
		return;
	}
	void dij(int s){//dijkstra
	    for(int i=1;i<=n*(k+1);i++){
			dis[i]=1e9;
			vis[i]=0;
		}
		priority_queue<pair<double,int>,vector<pair<double,int> >,greater<pair<double,int> > >q;
		dis[s]=0;
		q.emplace(0,s);
		while(!q.empty()){
			int u=q.top().second;
			q.pop();
			if(vis[u]){
				continue;
			}
			vis[u]=1;
			for(int i=head[u];i;i=e[i].nxt){
				int v=e[i].to;
				if(dis[v]>dis[u]+e[i].w){
					dis[v]=dis[u]+e[i].w;
					q.emplace(dis[v],v);
				}
			}
		}
	}
}two,one;
void add(int u,int v,int w){//建分层图
	if(fabs(out[v])>eps){
		for(int j=0;j<k;j++){
			one.add(id[u][j],id[v][j+1],w+out[v]);
		}
	}
	else{
		for(int j=0;j<=k;j++){
			one.add(id[u][j],id[v][j],w);
		}
	}
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m>>k>>kai>>jia;
	for(int i=1;i<=n;i++){
		for(int j=0;j<=k;j++){
			id[i][j]=i+j*n;
		}
	}
	for(int i=1;i<=n;i++){//输入
		string st;
		int red,green;
		cin>>st>>red>>green;
		dian[st]=i;
		if(st=="start"){
			s=i;
		}
		else if(st=="end"){
			t=i;
		}
		if(st.find("gas")!=string::npos){
			yo[i]=1;
		}
		if(red){
			out[i]=1.00*red*red/(double)(2.00*(red+green));//算期望
		}
		else{
			out[i]=0;
		}
	}
	for(int i=1;i<=m;i++){//建边
		string uu,vv,zxc,fw="114514";
		double w;
		cin>>uu>>vv>>zxc>>w;
		zxc=fw;
		add(dian[uu],dian[vv],w);
		add(dian[vv],dian[uu],w);
	}
	yo[s]=yo[t]=1;
	for(int i=1;i<=n;i++){
		if(yo[i]){
			zhan[++top]=i;
		}
	}
	for(int i=1;i<=top;i++){//枚举加油站
		one.dij(zhan[i]);
		for(int j=1;j<=top;j++){
			if(i==j){
				continue;
			}
			int w=(zhan[j]!=s&&zhan[j]!=t)?jia:0;
			for(int l=0;l<=k;l++){
				if(one.dis[id[zhan[j]][l]]<=kai){
					for(int p=0;p+l<=k;p++){
						two.add(id[zhan[i]][p],id[zhan[j]][p+l],one.dis[id[zhan[j]][l]]+w);
					}
				}
			}
		}
	}
	double ans=1e9;//统计答案
	two.dij(s);
	for(int i=0;i<=k;i++){
		ans=min(ans,two.dis[t+i*n]);
	}
	printf("%.3lf\n",ans);
	return 0;
} 
}
int main(){
	FFF::main();
	return 0;
}
```

---

## 作者：zhangxy__hp (赞：0)

首先计算在红绿灯 $(a,b)$ 处期望的等待时间。记 $a+b$ 为一个周期（即先有时长为 $a$ 的红灯，再有时长为 $b$ 的绿灯），设我们在 $x$ 时刻到达了这个红绿灯，那么我们需要等待的时间显然为 $\max(a-x,0)$。

要求出期望，就要用上面那个函数的和再除以总时长，也就是 $\frac{a^2}{2(a+b)}$。于是这道题就变成了一道普通的图论问题。

考虑分层图，一共建 $k+1$ 层图，在每个红绿灯处向上一层连边。考虑答案路径，一定是从起点开始再若干个加油站加油再走到终点的过程，而加油站与加油站之间怎么走我们是不用管它的。那么我们就以每个加油站为起点跑最短路，将所有加油站抽出来，在限制内能走到另一个加油站就在新图上连边。最后再在新图上跑一次最短路即可。

时间复杂度 $O(50kn\log kn)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define il inline
#define pb push_back
#define mp make_pair
#define fir first
#define sec second
#define id(x,y) ((x)+n*((y)-1))
using namespace std;
namespace asbt{
namespace cplx{bool begin;}
const int maxn=2e5+5;
int n,m,_k,lim,cst;
double dis[maxn],out[maxn];
bool gas[maxn],vis[maxn];
map<string,int> hao;
vector<pair<int,double> > e1[maxn],e2[maxn];
priority_queue<pair<double,int> > q;
il void dijkstra(int s,auto &e){
	for(int i=1;i<=n*(_k+1);i++){
		dis[i]=1e18,vis[i]=0;
	}
	dis[s]=0,q.push(mp(0,s));
	while(q.size()){
		int u=q.top().sec;
		q.pop();
		if(vis[u]){
			continue;
		}
		vis[u]=1;
		for(auto i:e[u]){
			int v=i.fir;
			double w=i.sec;
			if(!vis[v]&&dis[v]>dis[u]+w){
				dis[v]=dis[u]+w;
				q.push(mp(-dis[v],v));
			}
		}
	}
}
namespace cplx{
	bool end;
	il double usdmem(){return (&begin-&end)/1048576.0;}
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n>>m>>_k>>lim>>cst;
	for(int i=1,a,b;i<=n;i++){
		string s;
		cin>>s>>a>>b;
		hao[s]=i;
		gas[i]=~s.find("gas");
		if(a){
//			cout<<i<<"\n";
			out[i]=a*1.0*a/2/(a+b);
		}
	}
	int st=hao["start"],ed=hao["end"];
	for(int i=1,u,v,w;i<=m;i++){
		string a,b,c;
		cin>>a>>b>>c>>w;
		u=hao[a],v=hao[b];
		for(int j=1;j<=_k+1;j++){
			if(out[u]){
				if(j<=_k){
					e1[id(u,j)].pb(mp(id(v,j+1),w+out[u]));
				}
			}
			else{
				e1[id(u,j)].pb(mp(id(v,j),w));
			}
			if(out[v]){
				if(j<=_k){
					e1[id(v,j)].pb(mp(id(u,j+1),w+out[v]));
				}
			}
			else{
				e1[id(v,j)].pb(mp(id(u,j),w));
			}
		}
	}
	for(int i=1;i<=n;i++){
		if(i==st||gas[i]){
//			cout<<i<<"---";
			dijkstra(i,e1);
			for(int j=1;j<=n;j++){
				if(gas[j]){
					for(int k=1;k<=_k+1;k++){
						if(dis[id(j,k)]<=lim){
							for(int x=1,y=k;y<=_k+1;x++,y++){
								e2[id(i,x)].pb(mp(id(j,y),dis[id(j,k)]+cst));
//								cout<<id(i,x)<<" "<<id(j,y)<<" "<<dis[id(j,k)]+cst<<"\n";
							}
						}
					}
				}
				else if(j==ed){
					for(int k=1;k<=_k+1;k++){
						if(dis[id(j,k)]<=lim){
							for(int x=1,y=k;y<=_k+1;x++,y++){
								e2[id(i,x)].pb(mp(id(j,y),dis[id(j,k)]));
//								cout<<id(i,x)<<" "<<id(j,y)<<" "<<dis[id(j,k)]<<"\n";
							}
						}
					}
				}
			}
		}
	}
	dijkstra(st,e2);
	double ans=1e18;
	for(int i=1;i<=_k+1;i++){
//		cout<<dis[id(ed,i)]<<"\n";
		ans=min(ans,dis[id(ed,i)]);
	}
	printf("%.3f",ans);
	return 0;
}
}
int main(){return asbt::main();}
```

---

## 作者：wwt100127 (赞：0)

## 写在前面

- 将原图记作 $G_0$；

- $dist_{i,x}$ 表示从当前起点出发，到达 $x$，经过 $i$ 个红绿灯，所需最小时间；

- 集合 $A=\{$ 所有加油站，$s$，$t\}$。

## First

红灯的平均等待时间怎么求？

等待时间（平均）=总等待时间/总时间，
也就是 $\frac{a^2}{2(a+b)}$。

用下图思考会更易理解，总等待时间其实就是三角形面积。

![](https://cdn.luogu.com.cn/upload/image_hosting/4cbjcp94.png)

## Second

看到“最多经过 $k$ 个红绿灯”，果断分层图 Dijkstra（SPFA）。

## Third

注意到加油站的数量比较少，考虑从此下手，我们可以将加油站作为“中转点”，在原 $G_0$ 上跑 Dijkstra（SPFA）。

## Fourth

对于：任意 $x,y\in A$，暴力求出 $x$ 到达 $y$ 的 $dist_{i,y}(0\leq i\leq k,dist_{i,y} \leq Limit)$（跑 Dijkstra（SPFA）时，若 $dist > Limit$，就 `continue`），再建一张图，记作 $G_1$。

## Fifth

最后只需以 $s$ 为起点，在 $G_1$ 上跑分层图即可。

## Last：时间复杂度

以 Dijkstra 为例，设加油站的数量为 $num$。

第一次 Dijkstra 的复杂度是 $O(num\times K\times (n+m) \times \log n)$。

第二次 Dijkstra 的复杂度是 $O(K^2\times num^2\times\log num)$（边数最多是 $num^2\times K$）。

所以最终复杂度 $O(num \times K\times m\times \log n + K^2\times num^2\times\log num)$。

最后的最后（~~这个才是你们要的~~）。

```cpp
#include<bits/stdc++.h>
#define int long long
#define mp(x,y,p) make_pair(x,make_pair(y,p))
#define se second
#define fi first
using namespace std;
using PII=pair<int,int>;
using PDII=pair<double,PII>;
const int maxn=2e4+5;
const int maxm=4e5+5;
const double INF=1e18;
int n,m,K,Limit,Cost,s,t;
double Time[maxn];

unordered_map<string,int> Map;
vector<int> Gas;

struct Edge{int v,c,next; double w;};
struct Graph
{
	int head[maxn],tot;
	Edge e[maxm];
	double dist[15][maxn];
	bool vis[15][maxn];
	Graph()
	{
		memset(head,-1,sizeof(head));
		tot=-1;
	}
	void add(int u,int v,double w,int c)
	{
		e[++tot]=(Edge){v,c,head[u],w};
		head[u]=tot;
	}
	priority_queue<PDII,vector<PDII>,greater<PDII> >q;
	void init()
	{
		int i,j;
		for(i=0;i<=K+1;i++)
		{
			for(j=0;j<=n+1;j++)
			dist[i][j]=INF,vis[i][j]=0;
		}
	}
	void Dijkstra(int s)
	{
		int i; init();
		q.push(mp(0,0,s));
		dist[0][s]=0;
		while(q.size())
		{
			int k=q.top().se.fi,x=q.top().se.se;
			q.pop();
			if(vis[k][x])
			continue; 
			vis[k][x]=1;
			for(i=head[x];~i;i=e[i].next)
			{
				int y=e[i].v,c=e[i].c; double w=e[i].w;
				if(k+c<=K && dist[k+c][y]>dist[k][x]+w)
				{
					dist[k+c][y]=dist[k][x]+w;
					q.push(mp(dist[k+c][y],k+c,y));
				}
			}
		}
	}
}G[2];


bool Get_gas(string Name)
{
	for(int i=0;i+2<Name.size();i++)
	{
		if(Name[i]=='g' && Name[i+1]=='a' && Name[i+2]=='s')
		return true;
	}
	return false;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int i,k,x,y,u,v;
	double w; string Name;
	cin>>n>>m>>K>>Limit>>Cost;
	for(i=1;i<=n;i++)
	{
		cin>>Name>>x>>y;
		Map[Name]=i;
		if(x) Time[i]=1.0*x*x/(2*(x+y));
		if(Name=="start") Gas.push_back(s=i);
		if(Name=="end")   Gas.push_back(t=i);
		if(Get_gas(Name)) Gas.push_back(i);
	}
	for(i=1;i<=m;i++)
	{
		cin>>Name; u=Map[Name];
		cin>>Name; v=Map[Name];
		cin>>Name>>w;
		G[0].add(u,v,w+Time[v],(Time[v]? 1:0));
		G[0].add(v,u,w+Time[u],(Time[u]? 1:0));
	}
	for(int i:Gas)
	{
		G[0].Dijkstra(i);
		for(int j:Gas)
		{
			if(i==j) continue;
			for(k=0;k<=K;k++)
			{
				if(G[0].dist[k][j]>Limit) continue;
				w=((j!=s && j!=t)? Cost:0);
				G[1].add(i,j,G[0].dist[k][j]+w,k);
			}
		}
	}
	
	double ans=INF;
	G[1].Dijkstra(s);
	for(i=0;i<=K;i++)
	ans=min(ans,G[1].dist[i][t]);
	cout<<fixed<<setprecision(3)<<ans<<'\n';
	return 0;
}
```

---


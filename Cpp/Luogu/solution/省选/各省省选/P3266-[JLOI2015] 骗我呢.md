# [JLOI2015] 骗我呢

## 题目描述

说起来，毕业之后 B 君也就见过 R 君两面而已。  
R 君有一个 $n \times m$ 的数组 $x_{i,j}(1 \le i \le n; 1 \le j \le m)$。  
对于 $1 \le i \le n; 1 \le j \le m$，满足$0 \le x_{i,j} \le m$。求 可能的数组$x_{i,j}$ 的解数。  
B 君觉得限制太宽松，还要求对于 $1 \le i \le n; 1 \le j<m$，满足 $x_{i,j} <x_{i,j+1}$，对于$1 <i \le n; 1 \le j<m$，满足 $x_{i,j} <x_{i-1,j+1}$。  
B 君认为 R 君可以直接 pwn 掉这个题。  
R 君说：「黑的实在逼真 =.=，你起码把解数模 $10^9+7$ 吧。」B 君觉得 R 君说的有道理，于是想让你求解数模 $10^9+7$ 的结果。


## 说明/提示

对于 $100\%$ 的数据，$1 \leq m, n \leq 10^6$


## 样例 #1

### 输入

```
3 3```

### 输出

```
40```

# 题解

## 作者：xzyxzy (赞：76)

## **TAG：数学，DP**
## 此篇文章同步发布于博客上：https://www.cnblogs.com/xzyxzy/p/9812585.html
## **题意**

~~骗你呢~~

求满足以下条件的$n*m$的矩阵的个数对$10^9+7$取模

对于矩阵中的第$i$行第$j$列的元素$x_{i,j}$都有

 - $x_{i,j}<x_{i,j+1}$
 - $x_{i,j}<x_{i-1,j+1}$
 - $0\le x_{i,j}\le m$
 

## **题解**
### **Part 0 前言** 

不会做啊！（杠了四五个小时！）

谢两位dalao：[blog1](https://blog.csdn.net/Dream_Lolita/article/details/79234128)、[blog2](http://www.cnblogs.com/coco-night/p/9552677.html)

以下图片大部分来自于此篇文章：http://www.cnblogs.com/coco-night/p/9552677.html，如有冒犯请与我联系，谢谢！

### **Part 1 朴素DP**

首先发现一个很好的性质：

每行是递增的并且一行$m$个元素，取值只能在$[0,m]$中选

那么必然该行至多有一个位置与后一个位置相差2，其余的都只相差1

　


由此可以列出一个简单的$DP$：

$dp[i][j]$表示第$i$行没有出现过的数是$j$的方案数

$dp[i][j]=\sum_{k=0}^{j+1}dp[i-1][k]$
至于上界为什么是$j+1$可以手动模拟一下，假设这行$j$没有出现过，上一行试一试$j-1$、$j$、$j+1$、$j+2$，发现大于$j+1$的就不合法了

略微优化一下就变成了$dp[i][j]=dp[i-1][j+1]+dp[i][j-1]$

### **Part 2 转化为图形**
发现这个$DP$像极了组合数公式，把它套用在坐标系里就是这个样子
![iwUEt0.png](https://s1.ax1x.com/2018/10/18/iwUEt0.png)

自上而下第$i$行，从左往右第$j$列的点就表示$dp[i][j]$，其指向的点就表示可以转移
这样仍然不太好处理，我们继续转化：
![iwUwBd.png](https://s1.ax1x.com/2018/10/18/iwUwBd.png)

还是不好看，给它对称一下：
![iwUt1O.png](https://s1.ax1x.com/2018/10/18/iwUt1O.png)

### **Part 3 挖掘组合意义**

这么一看，不就是**从原点出发，只能向右或向上走，不接触直线A,B，到达点(n+m+1,n)的路径条数**吗！

直线$A:y=x+1$，直线$B:y=x-(m+2)$

### **Part 4 计算**

这种格路数计算（如两双手）都可以考虑采用容斥计数

不考虑其他限制，原点到$x,y$的方案数是$C_{x+y}^x$

考虑不合法方案是什么：如依次经过$AABBAAAABB$

把它缩一下：$ABAB$

　

可以发现不合法方案要么以$A$开头要么以$B$开头

表示为首次跨越的直线是$A$还是$B$

所以：**答案=总方案数 - A开头的方案数 - B开头的方案数**

　

$x=n+m+1,y=n$，把$(x,y)$沿$A$对称得到$(x',y')=(y-1,x+1)$

**每条从$(0,0)$到$(x',y')$的路径都依次对应一条以A结尾或者以AB结尾的路径！**

如图：（这个图是我自己画的！）
![此处输入图片的描述](http://wx4.sinaimg.cn/mw690/0060lm7Tly1fwcmwpd2irj30id0gudgm.jpg)

上面是一条以$A$结尾的路径
![此处输入图片的描述](http://wx2.sinaimg.cn/mw690/0060lm7Tly1fwcmwqn12rj30j60i4jsb.jpg)

上面是一条以$AB$结尾的路径

所以，总共的不合法方案是

- A
- B
- AB
- BA
- ABA
- BAB
- ABAB
- BABA
- ...

为了减去以$A$开头的方案，需要**减去以A,AB结尾的方案，加上以BA,BAB结尾的方案，减去....**

那么实现方式是：**把(x,y)沿A翻折，减去答案；将翻折过的点沿B翻着，加上答案；再沿A翻折...**

　

同理计算以$B$开头的方案，就是先沿$B$折就好了

具体细节的话沿着$A$折是$(x,y)->(y-1,x+1)$，沿着$B$折是$(x,y)->(y+(m+2),x-(m+2))$

完美解决本题！

## **代码**
```cpp
#include<iostream>
using namespace std;
const int P=1e9+7,N=3e6+10;
int n,m,up,inv[N],jc[N],inj[N];
int Calc(int x,int y) {return (x<0||y<0)?0:1ll*jc[x+y]*inj[x]%P*inj[y]%P;}
void flip1(int &x,int &y) {swap(x,y);x--;y++;}
void flip2(int &x,int &y) {swap(x,y);x+=m+2;y-=m+2;}
void add(int &x,int y) {x+=y;if(x>=P) x-=P;}
int main()
{
	cin>>n>>m;inv[0]=inv[1]=jc[0]=inj[0]=1;up=max(n,m)*3+1;
	for(int i=2;i<=up;i++) inv[i]=(P-1ll*P/i*inv[P%i]%P)%P;
	for(int i=1;i<=up;i++) jc[i]=1ll*jc[i-1]*i%P,inj[i]=1ll*inj[i-1]*inv[i]%P;
	int x=n+m+1,y=n,ans=Calc(x,y);
	while(x>=0&&y>=0)
	{
		flip1(x,y);add(ans,P-Calc(x,y));
		flip2(x,y);add(ans,Calc(x,y));
	}
	x=n+m+1,y=n;
	while(x>=0&&y>=0)
	{
		flip2(x,y);add(ans,P-Calc(x,y));
		flip1(x,y);add(ans,Calc(x,y));
	}
	return cout<<ans<<endl,0;
}
```
骗一波访问量（不过应该没有什么人做这题）：https://www.cnblogs.com/xzyxzy

---

## 作者：Peanut_Tang (赞：32)

## [[JLOI2015]骗我呢](https://www.luogu.com.cn/problem/P3266)

**更好的阅读体验：https://www.cnblogs.com/peanuttang/p/14389554.html**

### 简要题意

给定 $n,m$，求有多少个 $n\times m$ 的矩阵，满足：  
对于任意的 $i,j$，都满足矩阵中的第 $i$ 行第 $j$ 列的元素 $x_{i,j}$ 有：
1. $x_{i,j}<x_{i,j+1}(j<m)$；
2. $x_{i,j}<x_{i-1,j-1}(i,j>1)$；
3. $0\le x_{i,j}\le m$。

结果对 $10^9+7$ 取模，$1\le n,m\le 10^6$。

### 题解

第 $1$ 条性质表示这个矩阵中每行都是单调递增的，而第 $3$ 条性质则限制了每个只有 $m+1$ 种取值。

我们发现，一行只有 $m$ 个元素，而每个元素只可能有 $m+1$ 中取值，且行内单调递增。于是这行有且只有一个在 $[0,m]$ 中的元素没有被取到，而剩下的元素从小到大排序来填充这一行。

于是我们设计 DP 状态 $f_{i,j}$ 表示进行到第 $i$ 行，满足第 $i$ 行缺少的元素时 $j$ 的方案数。

考虑转移，发现如果 $k>j+1$ 则对于 $f_{i,p}=j+1$，就会有 $f_{i,p}=j+1=f_{i-1,p+1}$，不满足第 $2$ 条性质。于是要有 $k\le j+1$，所以有转移：$f_{i,j}=\sum_{k=1}^{j+1}{f_{i-1,k}}$。

再优化一下：$f_{i,j}=\sum_{k=0}^{j+1}{f_{i-1,k}}=\sum_{k=0}^{j}{f_{i-1,k}}+f_{i-1,j+1}=f_{i,j-1}+f_{i-1,j+1}$。

答案就是 $f_{n+1,m}$，这样子做是 $O(nm)$ 的，要考虑优化。

---

我们考虑这个式子的组合意义，我们先将它映射到坐标轴上。下图中箭头表示转移，而答案就是从 $(1,1)$ 走到 $(n,m)$ 的路径数量。

![](https://cdn.luogu.com.cn/upload/image_hosting/cqua8vso.png?x-oss-process=image/resize,m_lfit,h_520,w_575)

这里面有些转移时“斜”的，这不太直观。我们将这个网格图变换一下，将第 $i$ 行的点向右平移 $i-1$ 格。同时将第 $1$ 列之间的转移变成先往上再往右走。得到下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/yva84us9.png?x-oss-process=image/resize,m_lfit,h_520,w_575)

我们在 $x$ 轴上再加上额外的一行，把起点弄到原点上，再画出两条直线：

![](https://cdn.luogu.com.cn/upload/image_hosting/l6k15xa7.png?x-oss-process=image/resize,m_lfit,h_520,w_575)

我们发现答案就是从 $(0,0)$ 到 $T$ 即坐标轴上的 $(n+m+1,n)$ 的路径数量，即只能向右或者向上走，不能触碰到 $a:y=x+1$ 与 $b:y=x-m-2$ 两条直线的从 $(0,0)$ 到 $(n+m+1,n)$ 的路径数量。

---

如果没有两条直线的限制，那么答案显然就是 $\dbinom {x_T+y_T}{x_T}$。对于碰到了直线的，例如我们先后触碰到了 $aabbabb$，发现其实连续触碰到相同的直线之没有上面影响的，可以整个缩起来，于是上面的例子可以被缩为 $abab$。

我们回想一下初中奥数“将军饮马”问题，我们发现将 $(n+m+1,n)$ 关于 $a$ 对称，得到 $A'$，则从 $(0,0)$ 到 $A'$ 的每一条路径都和对应的先触碰到 $a$ 再折回到 $(n+m+1,n)$ 的路径都是一一对应的，数量自然而然也是相等的。这个方法是可以叠加的，例如我们先将 $(n+m+1,n)$ 关于 $a$ 对称，再关于 $b$ 对称，则到对应点的路径数则是结尾为 $ba$ 的路径数。可以见下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/pyf27pbh.png?x-oss-process=image/resize,m_lfit,h_520,w_575)

这样我们就可以计算了。容斥一下，答案就是 $\dbinom {x_T+y_T}{x_T}-\texttt{先到a的路径数}-\texttt{先到b的路径数}$。减去先到 $a$ 的路径数，我们只需要减去以 $a,ab$ 结尾的方案，加上以 $ba,bab$ 结尾的方案，减去$\ldots$

预处理阶乘的复杂度是线性的；而对称过程，每次的对称距至少增加 $1$，所以复杂度也是不超过线性的。所以总时间复杂度是线性的，而空间复杂度是 $O(n)$ 的。

### Code

```cpp
#include <bits/stdc++.h>

#define il inline
#define ll long long
const int N=3e6+5,P=1e9+7;

int n,m,fac[N],ans;

il int ksm(int a,int b){int res=1; for ( ; b; b>>=1,a=(ll)a*a%P) if (b&1) res=(ll)res*a%P; return res;}

il int C(int x,int y){return x<0||y<0?0:(ll)fac[x+y]*ksm(fac[x],P-2)%P*ksm(fac[y],P-2)%P;}

il void trans(int &x,int &y,int a){std::swap(x,y),x-=a,y+=a;}

int main()
{
    scanf("%d%d",&n,&m); int i,x,y;
    for (i=fac[0]=1; i<N; i++) fac[i]=(ll)fac[i-1]*i%P;

    for (x=n+m+1,y=n,ans=C(x,y); x>=0&&y>=0;) trans(x,y,1),ans=(ans-C(x,y)+P)%P,trans(x,y,-m-2),ans=(ans+C(x,y))%P;
    for (x=n+m+1,y=n; x>=0&&y>=0; ) trans(x,y,-m-2),ans=(ans-C(x,y)+P)%P,trans(x,y,1),ans=(ans+C(x,y))%P; printf("%d\n",ans);

    return 0;
}
```

---

## 作者：Kun_9 (赞：16)

反射容斥优化格路计数类DP。

~~多图警告~~。
### 朴素DP
提取出题目中的条件：

$$
x_{i,j}\in[0,m]
$$


$$
x_{i,j}\lt x_{i,j+1}
$$


$$
x_{i,j} \lt x_{i-1,j+1}
$$

也就是说每一行都是 $[0,m]$ 中删去一个数得到的一个递增序列，并且要满足条件三，条件只限制相邻两行，不妨画张图出来，两点间连线表示相等：

![](https://cdn.luogu.com.cn/upload/image_hosting/tlpoap2n.png)

考虑删掉第一行的一个数 $j$ 变成：

![](https://cdn.luogu.com.cn/upload/image_hosting/15n31wl1.png)

可以发现一种删数方案不合法当且仅当存在这种“向右”的连线，考虑通过在第二行删掉一个数使得这种方案变得合法，粗略考虑一下大概可以按照和 $j$ 的位置关系分类讨论，但是在 $j+1$ 的时候似乎有所不同，那就继续画画图看看。

假设我们删掉了一个位置 $k$ 满足 $k \lt j$，有：

![](https://cdn.luogu.com.cn/upload/image_hosting/bhpgwl2v.png)

此时满足条件。

如果 $k = j$，有：

![](https://cdn.luogu.com.cn/upload/image_hosting/g82aqj4d.png)

也满足条件。

如果 $k = j + 1$ 有：

![](https://cdn.luogu.com.cn/upload/image_hosting/5mxq80tv.png)

也满足条件。

再往后试试，如果 $k = j + 2$ 有：

![](https://cdn.luogu.com.cn/upload/image_hosting/eb6nl7m5.png)

出现了向右的连线说明不合法，所以说确定了第一行的删数位置 $j$ 后第二行合法的删数位置是 $[0,j+1]$。这时候就可以 DP 了，设 $f_{i,j}$ 表示第 $i$ 行删除的数是 $j$ 的方案，转移有：
$$
	f_{i,j} =  \sum_{k = 0} ^ {j + 1} f_{i-1,k}
$$
$k$ 的枚举是不必要的，也就是说转移可以写成
$$
f_{i,j} = f_{i,j-1} + f_{i-1,j+1}
$$
### 反射容斥优化
大眼观察上面的式子，有没有很像“从某个点到某个点规定走法的路径条数”之类的计数问题？顺着这个思路我们也把这个式子赋一个类似的含义：从源点出发每步只能向右或向左上走的路径条数。试着画个图出来：

![](https://cdn.luogu.com.cn/upload/image_hosting/xxazjr7o.png)

走斜线不好转移，试着把它拉伸一下：

![](https://cdn.luogu.com.cn/upload/image_hosting/c5f2ecem.png)

问题也就转化成了“求从 $(0,0)$ 出发，每次只能向上或向右走，不能经过直线 $y=x+1$ 和 直线 $y=x-m-2$ 走到 $(n+m+1,n)$ 的方案数”。

对于这种“不能经过某条直线从某点到某点的方案数”的问题，有一个经典的 trick 叫反射容斥，这里假设我们求的是从 $(0,0)$ 到 $(n,m)$ 的方案数。

现在先考虑一下简单的情况：只有一条直线 $y = x + b$ 的限制（为了方便令 $n+b > m$），那么每一条不合法的路线都能对应一条从 $(0,0)$ 到 $(n,m)$ 关于 $y = x + b$ 的对称点 $(m - b, n + b)$ 的路线（从第一次碰撞开始对称），如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/ib3nw7nj.png)

接下来是两条直线的情况，不难想到容斥：总方案 - 碰到一条直线的方案 + 碰到两条直线的方案。

但是这是不对的，因为反射后的直线可能还会碰到另一条直线，然后在两条直线之间疯狂反弹。

不妨设反射序列 $ABABAB...$ 表示先碰到直线 $a$ 再碰到直线 $B$，……。

那么最后的答案就是：总方案 - $A....$ - $B....$，发现后面是一个递归的形式可以直接算，并且对称的时候每次至少走 $1$ 的距离，所以复杂度是 $O(n)$ 的。

画图不易，留个赞再走呗 QAQ。

code：
```cpp
#include <bits/stdc++.h>

#define AC true
#define int long long
#define dub double
#define mar(x) for(int i = head[x]; i; i = e[i].nxt)
#define car(a) memset(a, 0, sizeof(a))
#define cap(a, b) memcpy(a, b, sizeof(b))
const int inf = 1e9 + 7;
const int MAXN = 6e6 + 10;
const int mod = 1e9 + 7;

using namespace std;

void cmx(int &x, int y){x < y && (x = y);}
void cmi(int &x, int y){x > y && (x = y);}
inline int read( ){
    int x = 0 ; short w = 0 ; char ch = 0;
    while( !isdigit(ch) ) { w|=ch=='-';ch=getchar();}
    while( isdigit(ch) ) {x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return w ? -x : x;
}
int ji[MAXN], inv[MAXN];
int ans, n, m;
void cof(int &x, int &y, int b){swap(x, y); x -= b; y += b;}
int fsp(int x, int k = mod - 2){
	int res = 1;
	while(k){
		if(k & 1) res = res * x % mod;
		x = x * x % mod;
		k >>= 1;
	}
	return res;
}
void init(int n){
	ji[0] = inv[0] = 1;
	for(int i = 1; i <= n; i++) ji[i] = ji[i-1] * i % mod;
	inv[n] = fsp(ji[n]);
	for(int i = n - 1; i >= 1; i--) inv[i] = inv[i+1] * (i + 1) % mod;
	return;
}
int C(int n, int m){return ji[n] * inv[m] % mod * inv[n-m] % mod;}
signed main( ){
	n = read( ); m = read( );
	init(5e6 + 500);
	ans = C((n << 1) + m + 1, n);
	int x = n + m + 1, y = n;
	while(x >= 0 and y >= 0){//-ABABABABABA
		cof(x, y, 1); ans -= C(x + y, x) - mod; ans %= mod;
		cof(x, y, -(m + 2)); ans += C(x + y, x); ans %= mod;
	}
	x = n + m + 1, y = n;
	while(x >= 0 and y >= 0){//-BABABABABAB
		cof(x, y, -(m + 2)); ans -= C(x + y, x) - mod; ans %= mod;
		cof(x, y, 1); ans += C(x + y, x); ans %= mod;
	}
	printf("%lld\n",ans);
	return (0-0);
}
```

---

## 作者：tzc_wk (赞：14)

[题面传送门](https://www.luogu.com.cn/problem/P3266)

神仙题。

首先乍一看此题非常棘手，不过注意到有一个条件 $0\le x_{i,j}\le m$，而整个矩阵恰好有 $m$ 列，这就启发我们考虑将每个元素的上下界求出来，如果我们第一列全填 $0$，其余每个数都恰好等于它左边的数加 $1$，那么 $x_{i,j}$ 刚好取到下界 $j-1$；如果我们最后一列全填 $m$，其余每个数都恰好等于它右边的数减 $1$，那么 $x_{i,j}$ 刚好取到上界 $j$，因此对于任意一个第 $j$ 列的元素 $x_{i,j}$，它的取值只有两种：$j-1$ 和 $j$。

我们记一类格为填 $j-1$ 的 $x_{i,j}$，二类格为填 $j$ 的 $x_{i,j}$，那么不难发现对于一个二类格 $x_{i,j}$，所有形如 $x_{i-p,j+q}$，$p\le q$ 的格子（也就是下图中的蓝色区域）都必须是二类格，而不难发现对于任意一个合法的矩阵，都存在唯一的二类格的集合 $S$，满足任意两个二类格都不在互相所管辖的范围内。因此题目可以转化为，有多少个二类格的集合 $S$，满足任意两个格子都不在互相管辖的范围内。

![](https://cdn.luogu.com.cn/upload/image_hosting/almscwne.png)

考虑 $dp$，不难发现任意一行，一类格必定是一段后缀，因此记 $dp_{i,j}$ 表示从下往上考虑到了第 $i$ 行，一类格前缀长度为 $j$ 的方案数，那么显然上一行一类格前缀的长度 $\le j+1$，因此我们不难得到 $dp$ 转移方程式 $dp_{i,j}=\sum\limits_{k=j-1}^{m}dp_{i+1,k}$，上式稍微化简一下可以得到 $dp_{i,j}=dp_{i,j+1}+dp_{i+1,j-1}$，注意，对于 $dp_{i,m}$ 而言，上式只有 $dp_{i+1,m-1}$，而实际上 $dp_{i+1,m}$ 也能转移到 $dp_{i,m}$，故 $dp_{i,m}=dp_{i+1,m-1}+dp_{i+1,m}$。

这样 $dp$ 是 $nm$ 的，无法通过，考虑使用组合意义优化，对于 $n=3,m=3$ 而言，该 $dp$ 的值等价于下图（这里借用了张题解区的图）中从左上角走到右下角的方案数（提示：如果将整张图旋转 $\pi$ 那可能比较好理解，因为上面的 $dp$ 过程是从下往上推的）

![](https://s1.ax1x.com/2018/10/18/iwUEt0.png)

稍微将它变形一下可以得到下图：

![](https://s1.ax1x.com/2018/10/18/iwUt1O.png)

不难发现这东西就等价于从 $(0,0)$ 出发到达 $P(n+m+1,n)$ 的方案数，其中不能碰到直线 $A:y=x+1$ 和直线 $B:y=x-(m+2)$

这个东西怎么求呢？一个比较棘手的地方是它涉及两条直线，如果只涉及一条直线那可以像我们的经典问题——求卡特兰数递推式那样做一个对称然后简单求个组合数。因此这里介绍一种思考问题的方法：前缀容斥。注意到对于所有不合法情况，它经过直线 $AB$ 的情况必然构成一个序列，比方说 $AABBAABBBA$，把连续段缩一下可以得到 $ABABA$，我们不妨就从这个缩好的序列入手计算方案数。显然对于每个不合法的序列，它缩好的序列要么以 $A$ 开头要么以 $B$ 开头，因此答案就是总方案数减去以 $A$ 开头的方案数减去以 $B$ 开头的方案数。

怎样求以 $A$ 开头的方案数呢？我们不妨把以 $A$ 开头的方案罗列一下，可以得到：

- A
- AB
- ABA
- ABAB
- ...

看到以 $A$ 开头我们直观地想到做 $P(n+m+1,n)$ 关于直线 $A$ 的对称点 $P'$，但事实上这是不对的。In fact，仔细分析一下就可以发现，对于所有 $(0,0)$ 到 $P'$ 的路径，如果我们把最后一个与 $A$ 的交点 $X$ 找到，然后把 $X\to P'$ 的折线翻下来，那么最后一段 $X\to P'$ 必然与 $A$ 没有交点，因此这样的路径末尾要么是 $A$（最后一段与 $B$ 没有交点）要么是 $AB$（最后一段与 $AB$ 有交点），因此求得的方案数是以 $A$ 或 $AB$ 为结尾的方案数，但这样只是以 $A$ 或 $AB$ 结尾的啊，还会多算什么 $BA,BAB,ABA,ABAB\cdots$，别急，如果我们再作 $P'$ 关于 $B$ 的对称点 $P''$，那么所有 $(0,0)\to P''$ 的路径必然经过 $B$，再把它翻上来就得到了 $(0,0)\to P'$ 的路径，由已知 $(0,0)\to P'$ 所对应的 $(0,0)\to P$ 的路径要么以 $A$ 为结尾，要么以 $AB$ 为结尾，前面再填个 $B$，故 $(0,0)\to P''$ 所对应的路径要么以 $BA$ 为结尾，要么以 $BAB$ 结尾，发现就是上面 $BA,BAB,ABA,ABAB\cdots$，二者相减就得到了 $A,AB$ 的方案数。

求 $ABA,ABAB$，以及后面 $ABABA,ABABAB\cdots$ 的方案数也同理，只需要再做 $P''$ 关于 $A$ 的对称点计算方案数，再关于 $B$ 对称计算方案数，二者相减即可得到 $ABA,ABAB$ 的方案数，以此类推即可求出以 $A$ 开头的方案数。求以 $B$ 开头的也同理。

时间复杂度 $\mathcal O(n)$

代码就不放了，大概和题解区其他代码大同小异（？）

---

## 作者：A_Big_Jiong (赞：12)

# 〇 · 前言
由于本人菜的很，所以这题杠了好久

可能中间会很多有口胡的地方，还请指出纠正，万分感谢

这里感谢一位dalao的[博客](https://blog.csdn.net/xyz32768/article/details/86750297)，讲的非常好，给我提供了很多的帮助

# Ⅰ· 朴素dp做法
~~朴素？看来还是我太菜了~~ 

**状态表示**：$f[i][j]$， 指第$i$行，不填数字$j$的方案总数

$\because \forall x_{i, j} \in [0, m]$

（这里可能是洛谷的题面有锅，疑似LaTeX写炸了）

$\therefore$每一行总有$j \in [0, m]$不被使用，$j$有且仅有一个

**转移方程**：$f[i][j] = f[i][j - 1] + f[i - 1][j + 1]$

其中$f[i][j - 1]$，指的是这行不填$j - 1$的方案数，不填$j$与不填$j - 1$等价；

$f[i - 1][j + 1]$即在满足$x_{i, j} < x_{i + 1, j - 1}$的方案数

（其实楼上的dp讲的真的挺不错的，比我这个dp菜鸡bb的强多了）

**目标**： $f[n][m + 1]$

如果考虑为$f[n][m]$的话，最后一个数在统计答案时不确定是否填$m$，影响最后数量的计算

多算一个数，保证不会漏掉最后一个数**不选**$m$的种类数

**边界**： $f[0][0] = 0$
# Ⅱ · dp转换为组合数学问题

OI Wiki上有这样一句话

![](https://cdn.luogu.com.cn/upload/image_hosting/dndhexrj.png)

~~我一直在想，这得是个啥玩意毒瘤题，给写这个页面的人留下了这么深的心理阴影， 然后我就看到了这道题...~~

我们把dp方程的转移表示在平面直角坐标系上，并进行平移

楼上dalao已经讲的很详细了，这里不再赘述 ~~（其实就是懒得画图）~~

然后就变成了一个走格子计数的问题了，一看是计数，先考虑组合数学
# Ⅲ · 初步计算

上面提到，他是一个走格子的问题，但存在约束， 只能在一个平行四边形的方阵上走

我们考虑把这个平行四边形补全为矩形， 然后减去那些不合法的方案

即从$(0,0)$走到$P(n + m, n)$的路径，且路径不穿过$y = x - 1$和$y = x + m + 1$的方案总数

设直线$A,B$， 分别为$y = x - 1$和$y = x + m + 1$


------------

然后我们引进**对称**的做法

则$(x ,y)$关于$A$对称点为$(y + 1, x - 1)$, 关于$B$的对称点为$(y - m - 2, x + m + 2)$

这里先考虑$A$

$P(n + m, n)$关于$A$的对称点$P_1(n + 1, n + m - 1)$

则到$P_1$的方案数就等于穿过$A$到$P$的方案数，可以将各个方案关于$A$对称，则一一映射到$(0, 0)$到$P$的一种方案路径上

同理，$B$也是这样

------------

因为从$(0, 0)$到$(x ,y)$的方案数等于$\binom{x + y}{x}$

所以我们用$\binom{2n + m + 1}{n} - \binom{2n + m + 1}{n + m + 2} - \binom{2n + m + 1}{n - 1}$来表示答案

然后，**炸了**。
# Ⅳ · 容斥

在爆炸之后，我们考虑， 其路线不只是能够穿过$A$或$B$， 可以多次穿过，我们把它表示为一个$AB$串， 例如：$ABABA$

我们设$AB$串$X$，

当$X$以$A$开头时， 我们可以在最前面添加一次$B$，以$B$开头路线就会被计算多次($X$，$BX$....)

那么我们就应该减去重复计算的数量，必然**容斥**

我们把我们所使用的对称做法推广到多次对称

------------
把第$i$次对称产生的点在第$i + 1$次对称时， 视作未对称的点

根据之前单次对称的正确， 那么本次对称也是可行的

所以这个对称做法可以推广到多次

------------

又因为$AB$串中$A,B$相间分布（连续的话可以视为一次，~~强行相间~~）

所以一次关于$A$对称的方案应当减去先前关于$B$对称的方案， 同理， 关于$B$对称的方案应当减去先前关于$A$对称的方案

当产生的新点$P'$不在第一象限的时候， 则之间的路径无法在被映射回去， 也就是说， $(0, 0)$和$(n + m, n)$之间无法通过此路径联通，此时应当停止容斥

最后把答案统计一下， 用递归实现容斥， 用费马小定理+公式计算组合数，不要忘记容斥减数取模的先加上个模数，实现即可
# Ⅴ · Code
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int N = 3000005;
const int mod = 1e9 + 7;
typedef long long lld;
lld n, m, ans;
lld fac[N];

lld qpow(lld a, lld b) {
	lld base = 1ll;
	while (b) {
		if (b & 1)  base = (base * a) % mod;
		a = (a * a) % mod;
		b >>= 1;
	}
	return base;
}
lld Comb(lld x, lld y) {
	return fac[x] * qpow(fac[y], mod - 2) % mod * qpow(fac[x - y], mod - 2) % mod;
}

lld A(lld, lld);
lld B(lld, lld);

lld A(lld x, lld y) {
	if (x < 0 || y < 0)  return 0;
	return (Comb(x + y, y) - B(y + 1, x - 1) + mod) % mod;
}

lld B(lld x, lld y) {
	if (x < 0 || y < 0)  return 0;
	return (Comb(x + y, y) - A(y - m - 2, x + m + 2) + mod) % mod;
}

int main() {
	scanf("%lld%lld", &n, &m);
	fac[0] = 1;
	for (int i = 1; i <= (n << 1) + m + 1; ++i)  fac[i] = fac[i - 1] * i % mod;
	ans = Comb((n << 1) + m + 1, n);
	ans = (ans - A(n - 1, n + m + 2) + mod) % mod;
	ans = (ans - B(n + m + 2, n - 1) + mod) % mod;
	printf("%lld\n", ans);
	return 0;
}
```


---

## 作者：Imitators (赞：9)








把大小关系看成一条边。

![](https://cdn.luogu.com.cn/upload/image_hosting/5ld2ucd2.png)

发现，最长的路径，就是从 $(1,x)\rightarrow(n,y)$ 的这样长度为 $m$ 的路径。

现在一共有 $m+1$ 种不同数值，所以每条路径只会有 $1$ 处可以选择比正常大 $1$ 的数值。

所以假如要选某一个点作为 $+1$ 的点，此时，他左上的的点都不能选。

所以可以有以下爆搜的代码。

``` cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans;
inline void dfs(int x,int down)
{
    if(x==n+1) {ans++;return ;}
    for(int i=down;i<=m;i++) dfs(x+1,i);
    dfs(x+1,max(down-1,1));
}
int main()
{
    cin>>n>>m;
    dfs(1,1);
    cout<<ans<<endl;
}
```


---


发现这个选的状态可以理解成走格子。

![](https://cdn.luogu.com.cn/upload/image_hosting/6yvatxj4.png)

假如上次选的是红色节点，那么红色圈起来的就是可选。

可以选的状态，相当于每次向右下走，接下来向上走能到的节点状态。

那么可以用一条只往 右下，上，走的路径，代表一种状态。

这个代表是双射，证明比较显然。

任何一种状态可以用一条路径表示，这个显然。

一条路径，可以代表一种状态，就是看那一步是向右下走。

$tips$

注意这个最下一排，我们要新建一排 虚点使其可以转移。

为了统计最后一列的和，可以新建一排虚点，然后把路径个数和转成到点  $(n+1,m+1)$ 的路径个数。

![](https://cdn.luogu.com.cn/upload/image_hosting/yit8z40d.png)

统计路径大概的 $dp$

``` cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans;
#define int long long
int dp[1000][1000];
const int mod=1e9+7;
signed main()
{
    cin>>n>>m;
    dp[1][1]=1;
    for(int i=1;i<=m+1;i++) dp[1][i]=1;
    for(int i=2;i<=n;i++)
    {
        dp[i][0]=dp[i-1][1];
        for(int j=1;j<=m+1;j++) dp[i][j]=dp[i-1][j+1]+dp[i][j-1], dp[i][j]%=mod;
    }
    int ans=0;
    for(int i=1;i<=m+1;i++) ans+=dp[n][i],ans%=mod;
    cout<<ans<<endl;
}
```


---


把这个斜着的图“转正”。

本质上相当于是一个矩形，有两条线限制，不能经过这两条线的点。

![](https://cdn.luogu.com.cn/upload/image_hosting/p5p81po3.png)

如果只有一条线限制，可以用折线法，构造双射。

如果我们对于每一条线折一次线，会用重复，比如说，我们假设经过 第一条线叫做 $A$ ，经过第二条线叫做 $B$。注意，假如连续经过$A\ or \ B$ ，我们只算一次。 

那么  $AB$ 。会被 $A$ 算一遍 ，$B$ 算一遍。

这时我们要减去 $AB,BA$ 。此时还会有类似问题 。于是考虑容斥，这个类似前缀容斥。

即对 $ABAB\cdots$ 这种串进行容斥。

$tips$

具体就是每次把一条直线根据另一条直线对称，然后把终点关于“对称后”这条新直线，再次对称。

由于每次问题都可以化归成经过两条直线的路径数，而且直线斜率均为 $1$，我们可以只维护截距，这样很好计算对称后的坐标，新的截距等你所维护的东西。



折线法代码。

``` cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
#define int long long
const int mod=1e9+7,N=3e6+10;;
int f[N],finv[N];
inline int qpow(int a,int b)
{
    int k=1;
    while(b){if(b&1) k=k*a%mod;a=a*a%mod,b>>=1;}
    return k;
}
inline pair<int,int> ref(int x,int y,int d){return make_pair(y-d,x+y-(y-d));}
inline int reflect(int a,int b){return a+a-b;}
inline int comb(int n,int m)
{
    if(n<0||m<0||n<m) return 0;
    return f[n]*finv[n-m]%mod*finv[m]%mod;
}
signed main()
{
    cin>>n>>m;n++,m+=2;
    f[0]=1;finv[0]=1;
    for(int i=1;i<=n+n+m;i++) f[i]=f[i-1]*i%mod;
    finv[n+n+m]=qpow(f[n+n+m],mod-2);
    for(int i=n+n+m-1;i>=1;i--) finv[i]=finv[i+1]*(i+1)%mod;
    int x,y,a,b,ans=0;
    x=n-1,y=n+m-1-1;a=-1,b=m;
    ans=comb(x+y,x);
    for(int j=1;j<=2;j++)
    {
        x=n-1,y=n+m-1-1;a=m,b=-1;
        if(j==2) swap(a,b);
        for(int i=1;i<=n+n+m;i++)
        {
            if(i==1)
            {
                pair<int,int>pot=ref(x,y,a);x=pot.first,y=pot.second;
            }
            else
            {
                if(i&1)
                {
                    a=reflect(b,a);pair<int,int>pot=ref(x,y,a);
                    x=pot.first,y=pot.second;
                }
                else
                {
                    b=reflect(a,b);pair<int,int>pot=ref(x,y,b);
                    x=pot.first,y=pot.second;
                }
            }
            if(i&1) 
            {
                ans-=comb(x+y,x);
                if(ans<0) ans+=mod;
            }
            else 
            {
                ans+=comb(x+y,x);
                if(ans>=mod) ans-=mod;
            }
        
        }
    }
    cout<<ans;
}
/*
23 233
938980383
*/
```



---

## 作者：hhhqx (赞：6)

为 2025 攒 RP……


---



好多题解讲解求 $ABABAB$ 的对应点的时候，都是直接说将 $P$ 关于 $A$ 对称，然后关于 $B$ 对称，然后循环下去。难道不应该 $A$ 和 $B$ 之间也需要对称吗？？？

蒟蒻也不清楚是不是自己哪里理解有问题，如果有问题请指正。

参考：https://www.cnblogs.com/Zeardoe/p/17003282.html & https://www.luogu.com.cn/article/bhqmc3nc 。

## 转化
题意是每一行只有一个数不存在，$dp_{i,j}$ 表示前 $i$ 行中第 $i$ 行 $j$ 这个数不存在的方案数，有 $dp_{i,j} = \sum\limits_{k=0}^{j+1}{dp_{i-1,k}}$。

设 $f_{i,j} = \sum\limits_{k=0}^{j}{dp_{i,j}}$，有 $f_{i,j} = f_{i-1,j+1} + f_{i,j-1}$，初始状态是 $f_{0,0} = 1$，答案是 $f_{n,m}$。

画到网格图上是这样：![](https://s1.ax1x.com/2018/10/18/iwUEt0.png) 问题是求左上角到右下角的路径数。

可以依次把一行右移一位，得到图：![](https://s1.ax1x.com/2018/10/18/iwUwBd.png)

拿到 $xOy$ 图上：![](https://s1.ax1x.com/2018/10/18/iwUt1O.png)

问题变为：求从 $(0,0)$ 到 $(n + m + 1, n)$ 的方案数，每次只能向上或右走，不可触碰 $y=x+1$ 和 $y=x-m-2$ 这两条线。

这就是反射容斥板子了。

## 反射容斥
### 前置知识
每次只能向上走或向右走，$(0,0)$ 到 $(n,m)$ 有 $\dbinom{n+m}{n}$ 种路径。

如果要求不能**碰** $y=x+b$ 这条线，问 $(0,0)$ 到 $(n,m)$ 有多少种路径：

- 如果碰了 $y=x+b$，可以将第一次碰的节点以及之后的路径都根据 $y=x+b$ 对称。
- $(n,m)$ 关于 $y=x+b$ 反射到 $(m-b,n+b)$。
- 那么路径数为 $\dbinom{n+m}{n} - \dbinom{m+n}{n+b}$。

$y=x+b$ 关于 $y=x+c$ 对称后的结果是 $y=x+2c-b$。

### 反射容斥

如果要求不能**碰** $y=x+b$ 和 $y=x+c$ 这两条线（$c < 0 < b$），问 $(0,0)$ 到 $(n,m)$ 有多少种路径：

（下面很多话可能和 https://www.cnblogs.com/Zeardoe/p/17003282.html 一样，图也都是从那里偷的……）

先思考一下如何求先经过 $y=x+b$ 若干次再经过 $y=x+c$ 若干次的路径数？

- 类似这样的路径：![](https://cdn.luogu.com.cn/upload/image_hosting/mosus4qx.png)
- 设终点为 $P$。第一次关于 $y=x+b$ 对称，第二次关于 $y=x+2b-c$（也就是 $y=x+b$ 关于 $y=x+c$ 的结果） 对称。
- 如图：![](https://cdn.luogu.com.cn/upload/image_hosting/42jsca2w.png)
- 答案就是 $(0,0)$ 到 $P$ 的方案数。

对于一条路径，每次碰 $y=x+b$ 或 $y=x+c$ 都在字符串 $S$ 后添加一个字符 $A$ 或 $B$。$S$ 中如果有相邻的 $A$ 或 $B$，就只保留一个。这样一条路径都有一个对应的字符串 $S$。$S$ 是类似 `ABAB` 、`ABABABAB` 这样的字符串。

设 $F(S)$ 条路径对应的字符串是 $S$。

求 $F(S)$：

- 顺序便利字符。
- 如果是 $A$：$P$ 和 $y=x+c$ 都关于 $y=x+b$ 对称。
- 如果是 $B$：$P$ 和 $y=x+b$ 都关于 $y=x+c$ 对称。
- 最后得到的 $P$ 到 $(0,0)$ 的路径数就是 $F(S)$。
- 如果 $P$ 的横坐标或纵坐标小于 $0$，就舍去。

根据容斥原理答案是 $F(空) - F(AB) - F(BA) + F(ABA) + F(BAB
) - F(ABAB) - \cdots$。

## Code
```cpp
#include <bits/stdc++.h>

using namespace std;
using LL = long long;
using PII = pair<int, int>;

const LL mod = 1e9 + 7;
const int MAXN = 5e6 + 3;

LL qpow(LL A, LL B){
	LL ret = 1;
	while(B > 0){
		if(B & 1) ret = ret * A % mod;
		A = A * A % mod, B >>= 1;
	}
	return ret;
}

int n, m;
LL fac[MAXN], ifac[MAXN];

LL Get(int A, int B){ return (A < 0 | B < 0 ? 0ll : fac[A + B] * ifac[A] % mod * ifac[B] % mod); }

inline void F1(int &x, int y){ x = y * 2 - x; }                   // y=x+x 关于 y=x+y 对称
inline void F2(PII &p, int x){ p = {p.second - x, p.first + x}; } // p 关于 y=x+x 对称

int main(){
	ios::sync_with_stdio(0), cin.tie(0);
	cin >> n >> m;
	fac[0] = ifac[0] = 1;
	for(int i = 1; i <= 5e6; i++) fac[i] = fac[i - 1] * i % mod, ifac[i] = qpow(fac[i], mod - 2);
	int x = 1, y = - m - 2;
	PII p = {n + m + 1, n};
	LL ans = Get(p.first, p.second), op = -1;
	while(p.second >= 0 && p.first >= 0){
		F2(p, x), ans += op * Get(p.first, p.second) + mod, ans %= mod, F1(y, x), op *= -1;
		F2(p, y), ans += op * Get(p.first, p.second) + mod, ans %= mod, F1(x, y), op *= -1;
	}
	p = {n + m + 1, n}, x = 1, y = - m - 2, op = -1;
	while(p.second >= 0 && p.first >= 0){
		F2(p, y), ans += op * Get(p.first, p.second) + mod, ans %= mod, F1(x, y), op *= -1;
		F2(p, x), ans += op * Get(p.first, p.second) + mod, ans %= mod, F1(y, x), op *= -1;
	}
	cout << ans;
	return 0;
}
```
## 为什么其他题解那样写可以通过？
也就是我的 Code 中不使用 `F1()` 这个函数。

还是来看看这个例子：![](https://cdn.luogu.com.cn/upload/image_hosting/42jsca2w.png) 

由于 $S$ 是 $A,B$ 交替的，每次 $y=x+b$ 关于 $y=x+c$ 对称然后 $y=x+c$ 关于 $y=x+b$ 对称，显然两个直线的 $b-c$ 都是定值，可以画出这样一个图：![](https://cdn.luogu.com.cn/upload/image_hosting/frf388uw.png)。

顺序处理字符，设最开始字符是 $A$，那第 $i$ 次 $P$ 对称是关于 $y=x+c$ 向上第 $i$ 条直线对称。

很容易脑补出这个过程，也就是 $P$ 向左上移动两个直线的间距大小，然后在区间中反过来。

把所有字符串 $S$ 得到的 $P$ 都画出来，也就是：![](https://cdn.luogu.com.cn/upload/image_hosting/ekwv6kw6.png)

那直接关于固定的 $y=x+b,y=x+c$ 对称效果是怎样？

也可以脑补出这个过程，$P$ 点会一上一下。

发现得到的点集和上面那个图完全一样的！至于为什么，留给读者思考（~~其实是不想写了……~~）。

这样实现，复杂度很显然是 $O(\frac{n + m}{b-c})$（这里的 $n,m,c,b$ 是“反射容斥”中使用的量）。

## Code
```cpp
#include <bits/stdc++.h>

using namespace std;
using LL = long long;
using PII = pair<int, int>;

const LL mod = 1e9 + 7;
const int MAXN = 5e6 + 3;

LL qpow(LL A, LL B){
	LL ret = 1;
	while(B > 0){
		if(B & 1) ret = ret * A % mod;
		A = A * A % mod, B >>= 1;
	}
	return ret;
}

int n, m;
LL fac[MAXN], ifac[MAXN];

LL Get(int A, int B){ return (A < 0 | B < 0 ? 0ll : fac[A + B] * ifac[A] % mod * ifac[B] % mod); }

inline void F1(int &x, int y){ x = y * 2 - x; }                   // y=x+x 关于 y=x+y 对称
inline void F2(PII &p, int x){ p = {p.second - x, p.first + x}; } // p 关于 y=x+x 对称

int main(){
	ios::sync_with_stdio(0), cin.tie(0);
	cin >> n >> m;
	fac[0] = ifac[0] = 1;
	for(int i = 1; i <= 5e6; i++) fac[i] = fac[i - 1] * i % mod, ifac[i] = qpow(fac[i], mod - 2);
	int x = 1, y = - m - 2;
	PII p = {n + m + 1, n};
	LL ans = Get(p.first, p.second), op = -1;
	while(p.second >= 0 && p.first >= 0){
		F2(p, x), ans += op * Get(p.first, p.second) + mod, ans %= mod, op *= -1;
		F2(p, y), ans += op * Get(p.first, p.second) + mod, ans %= mod, op *= -1;
	}
	p = {n + m + 1, n}, x = 1, y = - m - 2, op = -1;
	while(p.second >= 0 && p.first >= 0){
		F2(p, y), ans += op * Get(p.first, p.second) + mod, ans %= mod, op *= -1;
		F2(p, x), ans += op * Get(p.first, p.second) + mod, ans %= mod, op *= -1;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Cocoly1990 (赞：6)

## 从 $\mathcal{O}(n^2)$ 入手

不难发现，值域和列数是接近的，那么我们置 $f_{i,j}$ 表示对于前 $i$ 行，第 $i$ 行不存在值 $j$ 的合法方案数，其中 $j\in[0,m]$。那么容易有转移 $f_{i,j}=\sum\limits_{k=0}^{j+1}f_{i-1,k}$。原因是当第 $i$ 列没有 $j$ 时，我们找不到办法去应对上一行的 $j+2$。该式直接转移的复杂度是 $\mathcal{O}(n^3)$ 的。

平凡地，我们有 $f_{i,j}=\sum\limits_{k=0}^j f_{i-1,k}+f_{i-1,j+1}=f_{i,j-1}+f_{i-1,j+1}$，初值是 $f_{1,i}=1$，目标状态 $\sum\limits_{j=0}^m f_{n,j}=f_{n+1,m}$。

```
int get(int x, int y) {return (x - 1) * (m + 2) + y;}
int main(){
	cin >> n >> m; 
	for(int i = 0; i <= m; i ++) f[get(1, i)] = 1;
	for(int i = 2; i <= n + 1; i ++){
		for(int j = 0; j <= m; j ++){
			if(j) f[get(i, j)] = (f[get(i - 1, j + 1)] + f[get(i, j - 1)]) % Mod; 
			else f[get(i, j)] = (f[get(i - 1, 1)] + f[get(i - 1, 0)]) % Mod;
		}
	}
	int ans = 0; cout << f[get(n + 1, m)];
}
```

## 进一步优化

套路地，我们把贡献放到平面上并分析其组合意义，具体过程不再赘述，最后的方案数相当于从 $(0,0)\rightarrow (n + m+1,n)$ 且不触碰到直线 $y_1=x+1$ 和 $y_2=x-m-2$ 的方案数。

首先我们抛出一个子问题，如果计算 $(x_i,y_i)\rightarrow (x_j,y_j)$ 且触碰到 $y=x+1$ 的方案数。正难则反，我们考虑用总方案数减去不合法方案数，其中不合法的情况恰好是 $(x_i,y_i)$ 到 $(x_j,y_j)$ 关于 $x-y+1=0$ 的对称点，也就是 $(y_j-1,x_j+1)$ 的路径数。

![1657079067925.png](https://img-kysic-1258722770.file.myqcloud.com/aa4922d0aaffbeed835f3212dba37fd6/4f66d3c9f39b1.png)

之所以等价，是因为任何一条由 $(x_i,y_i)$ 到 $(x_j,y_j)$ 的不合法路径都可以通过翻折对应成一条 $(x_i,y_i)$ 到 $(y_j-1,x_j+1)$ 的路径，上图很好地体现了这一过程。

回到本题，不难想到用总方案减去碰到 $y_1$ 和 $y_2$ 的贡献，并加回先碰到 $y_1$ 再碰到 $y_2$ 和先碰到 $y_2$ 再碰到 $y_1$ 的方案数，以此类推，具体的方法是仿照上述子问题，不断对目标点沿两条直线翻折，可以证明，翻折的次数（也就是容斥的次数）是 $\mathcal{O}(n)$ 的，因此可以通过。

```
struct tools{	
	int fc[Maxn], inv[Maxn];
	int qpow(int u, int v){
		int ans = 1; for(; v; v >>= 1) {if(v & 1) ans = 1ll * ans * u % Mod; u = 1ll * u * u % Mod;} return ans;
	}
	void prefac(int s) {
 		for (int i = 0; i <= s; i ++){
        	fc[i] = (i == 0) ? 1 : (1ll * fc[i - 1] * i % Mod);
    	}		
	}
	void prefcinv(int s){
    	inv[s] = qpow(fc[s], Mod - 2);
    	for (int i = s - 1; i >= 0; i --) 
    		inv[i] = 1ll * inv[i + 1] * (i + 1) % Mod;		
	}
	int C(int u, int v) {
	    if (v > u or u < 0 or v < 0) return 0;
	    else return 1ll * fc[u] * inv[v] % Mod * inv[u - v] % Mod;
	}
	int path(int u, int v){
		return C(u + v, v);
	}
	void turn(int opt, int &x, int &y){
		if(opt) swap(++ x, -- y); //关于 y = x + 1;
		else swap(x = x - m - 2, y = y + m + 2); // 关于 y = x - m - 2;
	}	
}t;
int main(){
	cin >> n >> m; int L = Maxn - 5; t.prefac(L); t.prefcinv(L);
	int x = n + m + 1, y = n; ans = t.path(x, y);
	while(x >= 0 and y >= 0){
		//-1 + 12 - 121 + ... 
		t.turn(1, x, y); ans = (1ll * ans +  -1ll * t.path(x, y) + Mod) % Mod;
		t.turn(0, x, y); ans = (1ll * ans + 1ll * t.path(x, y)) % Mod;
	}
	x = n + m + 1, y = n;
	while(x >= 0 and y >= 0){
		t.turn(0, x, y); ans = (1ll * ans +  -1ll * t.path(x, y) + Mod) % Mod;
		t.turn(1, x, y); ans = (1ll * ans + 1ll * t.path(x, y)) % Mod;
	} cout << ans;
}
```



---

## 作者：PragmaGCC (赞：6)

由题意，每一行内的数单调递增。又因为 $0 \leqslant a_{i,j} \leqslant m$ 限制了这些数的取值范围。

那么我们相当于在 $m + 1$ 个数中选 $m$ 个数。必然有两个之间相差 $2$，其余的数连续。

我们设 $f_{i,j}$ 表示第 $i$ 行中，被舍弃掉的数是 $j$ 的方案数。

那么则有
$$
\begin{aligned}
f_{i,j} &= \sum_{k=0}^{j+1} f_{i-1,k} \\
&=\sum_{k=0}^{j} f_{i-1,k} + f_{i-1,j+1} \\
&= f_{i,j-1} + f_{i-1,j+1}
\end{aligned}
$$
这个式子看上去是一个表格中的递推，我们将其画到网格图中（第 $i$ 行第 $j$ 列）：

![](https://ae03.alicdn.com/kf/Ucaf61cc2441d44db976c82a4fa4cea55p.jpg)

这个样子很丑，我们尽量将转移变成水平/垂直的。

![](https://ae03.alicdn.com/kf/U298cb7bbf5ca44608911742b0441b90dt.jpg)

虚线为原本的转移，将其改成向上再向右。

这样看上去有点像组合问题。

我们在两侧加上两条直线：

![](https://ae04.alicdn.com/kf/Ubaeb23f373f647399f19eec86b9668a71.jpg)

不难发现，结果即为从 $(0,0)$ 到 $(n+m,n)$ ，不经过直线 $A:y=x+1$ 和 $B:y=x-m-2$ 的路径总数。

考虑用组合数算这个东西。我们定义由 $A$ 和 $B$ 组成的序列表示先经过 $A$ 或 $B$ 的方案。如 $AABABBAB$。

我们发现，连续经过同一条直线没有影响，所以把所有的相同部分全部缩成一个。

显然，它要么以 $A$ 开头，要么以 $B$ 开头。

我们直接用总方案数 （ $\tbinom{2n+m+1}{n}$ ） - $A$ 开头的方案数 - $B$ 开头的方案数。

但是后两者又该怎么计算呢？

我们使用对称。

我们将直线 $B$ 关于直线 $A$ 对称过去。过 $A$ 再过 $B$ 实质上就是不停的跨越直线的过程。我们一直对称下去。当我们发现，对称过去的某个点在回来之后并不属于第一象限了，说明这条路径不合法。

容斥。$A$ 开头相当于 $A+AB-BA-BAB+ABA+ABAB \cdots$。 $B$ 开头同理。

我们每次对称都必然会使得距离加一，所以最终一定能找到答案。

```cpp
#include <cstdio>
const int ccf = 1e9 + 7, N = 3e6 + 5;
int n, m, nn, fac[N], inv[N];
void init() {
    fac[0] = fac[1] = inv[0] = inv[1] = 1;
    nn = n * 2 + m + 1;
    for (int i = 2; i <= nn; i++) fac[i] = 1ll * fac[i - 1] * i % ccf;
    for (int i = 2; i <= nn; i++) inv[i] = 1ll * (ccf - ccf / i) * inv[ccf % i] % ccf;
    for (int i = 2; i <= nn; i++) inv[i] = 1ll * inv[i] * inv[i - 1] % ccf;
}
int C(int n, int m) { return 1ll * fac[n] * inv[m] % ccf * inv[n - m] % ccf; }
int Mir(int x, int y, int dir) {
    if (x < 0 || y < 0) return 0;
    int delta = dir ? -m - 2 : 1;
    return (C(x + y, y) - Mir(y + delta, x - delta, dir ^ 1) + ccf) % ccf;
}
int main(void) {
    scanf("%d%d", &n, &m);
    init();
    int ans = C(nn, n);
    ans = (ans - Mir(n - 1, n + m + 2, 0) + ccf) % ccf;
    ans = (ans - Mir(n + m + 2, n - 1, 1) + ccf) % ccf;
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：Nuisdete (赞：5)

题意：

求有多少个 $n × m$ 的矩阵满足

- $0$ $≤$ $a_i,_j$ $≤$ $m$
- $a_{i,j}$ $<$ $a_{i,j + 1}$
- $a_{i,j}$ $<$ $a_{i-1, j + 1}$

首先观察到 $a_{i,j}$ 的取值范围以及矩阵的列，得出矩阵的每一行必然有一个在 $0$ ~ $m$ 之间的数是不存在的。

通过第二个矩阵需要满足的条件得出每一行除去这个不存在的数，这个序列是单调递增的。

设第 $i$ 行这个不存在的数为 $b_{i}$，那么看看 $b_i$ 与 $a_{i, j}$ 的关系。

根据矩阵每一行单调递增的性质，不难得出：

$a_{i, j}$ $=$ $j$ $-$ $1$ $+$ $[$ $b_i$ $≤$ $j$ $]$；

再将这个式子代入矩阵需要满足的第三个条件得出：

$j$ $-$ $1$ $+$ $[$ $b_i$ $≤$ $j$ $]$ $<$ $j$ $+$ $1$ $-$ $1$ $+$ $[$ $b_{i - 1}$ $≤$ $j$ $+$ $1$ $]$；

化简可得：

$[$ $b_i$ $≤$ $j$ $]$ $<$ $1$ $+$ $[$ $b_{i - 1}$ $≤$ $j$ $+$ $1$ $]$；

因此可以知道：

当 $b_i$ $≤$ $j$ 成立时 $b_{i - 1}$ $≤$ $j$ $+$ $1$ 一定也成立。

进而可得：

$b_i$ $≥$ $b_{i - 1}$ $-$ $1$；

得出这个关系后，我们设 $f_{i, j}$ 表示第 $i$ 行中值为 $j$ 的数不存在所能构成的矩阵的个数。

根据上面 $b_i$ 和 $b_{i-1}$ 的关系式，不难得出 $f_{i,j}$ 的转移方程：

$f_{i,j}$ $=$ $\sum_{k = 0}^{j + 1}$ $f_{i-1, k}$；

将这个方程展开化简得出：

$f_{i, j}$ $=$ $f_{i, j - 1}$ $+$ $f_{i - 1, j + 1}$；

边界条件：

$f_{i, 0}$ $=$ $f_{i - 1, 0}$ $+$ $f_{i - 1, 1}$；

根据上面的最开始得出的转移方程可以知道最终答案就是 $f_{n + 1, m - 1}$

将转移式子转化为一张图可得：

![图1](https://cdn.luogu.com.cn/upload/image_hosting/0xzu1us7.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

发现图的左边与中间并不整齐，因此再转化：

![图2](https://cdn.luogu.com.cn/upload/image_hosting/07npd9sh.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

因此此题此时转化为了从左上角的 $(0,$ $-1)$ 号点，每次可以向左下或者向右走，不能走出图的边界，走到画绿挑的点 $(2,$ $2)$ 号点（到蓝挑点也一样）的方案数。

首先只有向左下走一种方法可以到达下一层，而我们一共需要下 $n$ 层，因此向左下走的步数就为 $n$，且这样走一定不会越出矩阵下面或上面的边界。

此时也相当于我们一共向左也走了 $n$ 步，而为了到达右端的 $m$ $-$ $1$ 点，我们还需要向右走 $n$ $+$ $m$ 步，因此问题再次转化为：

在一个数轴上，从 $-1$ 出发，向左走 $n$ 步，向右走 $n$ $+$ $m$ 步，不越过 $[$ $-1,$ $m$ $]$ 这个范围，求方案数。

为了方便，将整体向右平移一位，问题最终变为：

在一个数轴上，从原点出发，向左走 $n$ 步，向右走 $n$ $+$ $m$ 步，不越过 $[$ $0,$ $m$ $+$ $1$ $]$ 这个范围，求方案数。

考虑采用反射的方法，以点 $-1$ 为中心对称，以 $m$ $+$ $2$ 为中心进行对称，而这个方法的基础可以在 [这道题](https://www.luogu.com.cn/problem/P1641) 学习。

相较于普通的采用反射法的题来说，此题最大的不同就是需要进行反复容斥，即我们不仅需要求出越过原点的方案数，还需要求出先越过 $m$ $+$ $1$ 再越过原点的方案数，再就还需要求出先越过原点再越过 $m$ $+$ $1$ 再越过原点的方案数，因此可以递归求解。

以先横跨左端点为例：

设 $crossL(l,$ $r,$ $end)$ 表示当前经过若干次反射得到的限制区间为 $l$ ~ $r$，需要到达的终点为 $end$，的方案数。

那么它的返回值就是从 $0$ 到 $end$ 走 $2n$ $+$ $m$ 步的方案数 $-$ 再跨一遍左（右）区间的方案数。

设向左走 $a$ 步，向右走 $b$ 步到达 $end$（这里 $a$，$b$ 是啥都无所谓）

那么可得方程：

$\begin{cases}a+b=2n + m\\
a-b=end\\
\end{cases}$

解得

$a$ $=$ $n$ $+$ $\frac{m + end}{2}$；

所以总的方案数就为 $C(n$ $+$ $\frac{m + end}{2},$ $2n$ $+$ $m)$；

当然还需要减去 $crossL(2$ $\times$ $(l$ $-$ $1)$ $-$ $r,$ $2$ $\times$ $(l$ $-$ $1)$ $-$ $l,$ $2$ $\times$ $(l$ $-$ $1)$ $-$ $end)$。这是因为对于每一次反射，区间左端点就变为了右端点，右端点就变为了左端点，因此我们只需不断的按照当前的左端点进行反射即可。

具体见 code：

```cpp
#include <cstdio>
#include <cmath>

typedef long long ll;

const int MAXN = 1e6;
const ll MOD = 1e9 + 7;

ll n, m;
ll fac[3 * MAXN + 10], invFac[3 * MAXN + 10];

ll quickPow(ll x, ll k) {

	ll ans = 1ll;
	while(k) {
		if(k & 1) {
			ans = ans * x % MOD;
		}
		k >>= 1;
		x = x * x % MOD;
	}

	return ans;
}

ll C(ll mm, ll nn) {
	return fac[nn] * invFac[mm] % MOD * invFac[nn - mm] % MOD;
}

ll crossR(ll l, ll r, ll end) {
	if(abs(end) > 2 * n + m) return 0ll; //判断终点能否到达 
	return (C(n + ((m + end) >> 1), 2 * n + m) - crossR(2 * (r + 1) - r, 2 * (r + 1) - l, 2 * (r + 1) - end)) % MOD;
}

ll crossL(ll l, ll r, ll end) {
	if(abs(end) > 2 * n + m) return 0ll;
	return (C(n + ((m + end) >> 1), 2 * n + m) - crossL(2 * (l - 1) - r, 2 * (l - 1) - l, 2 * (l - 1) - end)) % MOD;
}

int main() {

	scanf("%lld %lld", &n, &m);
	
	fac[0] = 1ll, invFac[0] = 1ll;
	fac[1] = 1ll, invFac[1] = 1ll;
	for(int i = 2; i <= 2 * n + m; ++i) { //求阶乘和其逆元，以便于 O(1) 计算组合数 
		fac[i] = fac[i - 1] * i % MOD;
		invFac[i] = quickPow(fac[i], MOD - 2);
	}
		
	ll ans = ((crossR(0, m + 1, m) + crossL(0, m + 1, m)) % MOD - C(n + m, 2 * n + m)) % MOD; //第一次横跨L和R把中间这一段算了两遍，因此要再减一下 
	
	printf("%lld\n", (ans + MOD) % MOD);

	return 0;
}
```


---

## 作者：___w (赞：4)

[P3266 [JLOI2015] 骗我呢](https://www.luogu.com.cn/problem/P3266)

[更好的阅读体验？](https://www.cnblogs.com/123wwm/articles/17987001)

考虑 dp。观察到每行只会有一个数字不会出现，所以设计状态 $f_{i,j}$ 为第 $i$ 行只有 $j$ 这个数字没出现。

显然状态转移方程为

$$f_{i,j}=\sum_{k=0}^{j+1}f_{i-1,k}$$

上界为 $j+1$ 的原因是当 $k>j+1$ 时第 $i$ 行的 $j+1$ 所对的位置不满足 $x_{i,j}<x_{i-1,j+1}$。

观察上式可以发现 $f_{i,j}$ 能由 $f_{i,j-1}$ 推来，所以有

$$f_{i,j}=f_{i,j-1}+f_{i-1,j+1}$$

这样我们得到了 $O(nm)$ 的 dp 了。

进一步想，先把每个点从何转移得来标注出来。

![1](https://cdn.luogu.com.cn/upload/image_hosting/2in1qv1f.png)

给它拉直

![2](https://cdn.luogu.com.cn/upload/image_hosting/o6ov8whu.png)

在对称一下

![3](https://cdn.luogu.com.cn/upload/image_hosting/pi7agcem.png)

（图片来自转载，侵权即删）

发现了什么？我们要求的答案即为从 $(0,0)$ 到 $(n+m+1,n)$ 的路径且与 $y=x+1$ 和 $y=x-m-2$ 这两条线不相交的方案数。

$(0,0)$ 到 $(n+m+1,n)$ 的路径显然为 ${n+m+1\choose n}$，考虑减去那些不合法的。

记 $y=x+1$ 为 $A$，$y=x-m-2$ 为 $B$。

那么我们如果每次经过一条线就写下来对应字母，缩起来相同的字母可以得到一个跨越直线的序列。

像比如：

- $A$

- $B$

- $AB$

- $BA$

- $ABA$

- $BAB$

- $ABAB$

- $BABA$

- $\dots$

答案为总数减去以 A 开头的路径个数再减去以 B 开头的路径总数。

以求以 $A$ 开头的路径个数为例，现将终点作关于 $A$ 对称，记为 $A'$，先减去 $O$ 到 $A'$ 的路径个数，会减去以 $A$ 或 $AB$ 结尾的路径，但是会多减去类似 $BAB$ 这种 $B$ 开头的路径。那么我们再作 $A'$ 关于 $B$ 对称，记为 $A''$，加上 $O$ 到 $A''$ 的路径，前面多减的加回来了，但是又多加了类似 $BABA$ 的路径，我们在加上……

怎么对称？有结论点 $(x,y)$ 关于直线 $y=x+b$ 的对称点为 $(y-b,x+b)$，套进去就行。

code:

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define pb push_back
#define mk make_pair
#define ll long long
#define space putchar(' ')
#define enter putchar('\n')
using namespace std;

inline int read() {
	int x = 0, f = 1;
	char c = getchar();
	while (c < '0' || c > '9') f = c == '-' ? -1 : f, c = getchar();
	while (c >= '0' && c <= '9') x = (x<<3)+(x<<1)+(c^48), c = getchar();
	return x*f;
}

inline void write(int x) {
	if (x < 0) x = -x, putchar('-');
	if (x > 9) write(x/10);
	putchar('0'+x%10);
}

const int N = 3e6+5, mod = 1e9+7;
int n, m, k, ans, fac[N], ifac[N];

int qpow(int x, int y) {
	int res = 1;
	for (; y; y >>= 1, x = 1ll*x*x%mod) if (y&1) res = 1ll*res*x%mod;
	return res;
}

int c(int x, int y) {
	if (x < 0 || y < 0 || x < y) return 0;
	return 1ll*fac[x]*ifac[y]%mod*ifac[x-y]%mod;
}

void init(int n) {
	fac[0] = 1;
	for (int i = 1; i <= n; ++i) fac[i] = 1ll*fac[i-1]*i%mod;
	ifac[n] = qpow(fac[n], mod-2);
	for (int i = n-1; ~i; --i) ifac[i] = 1ll*ifac[i+1]*(i+1)%mod;
}

void pls(int &x, int y) { x = (x+y)%mod; }

void sub(int &x, int y) { x = (x-y+mod)%mod; }

void flip1(int &x, int &y) { swap(x, y); --x, ++y; }

void flip2(int &x, int &y) { swap(x, y); x += m+2, y -= m+2; }

int main() {
	init(N-5);
	n = read(), m = read();
	int x = n+m+1, y = n;
	ans = c(x+y, x);
	while (x >= 0 && y >= 0) {
		flip1(x, y), sub(ans, c(x+y, x));
		flip2(x, y), pls(ans, c(x+y, x));
	}
	x = n+m+1, y = n;
	while (x >= 0 && y >= 0) {
		flip2(x, y), sub(ans, c(x+y, x));
		flip1(x, y), pls(ans, c(x+y, x));
	}
	write(ans);
	return 0;
}
```

---

## 作者：湖南省队御用绫厨TM_Sharweek (赞：3)

[或许你会愿意看看这个](https://www.cnblogs.com/sharweek/articles/18732477)

## 题意
给出 $n,m$，求大小为 $n\times m$ 的满足下列条件的矩阵 $A=\{a_{i,j}\}$ 个数：
- $\forall i\in[1,n]\cap\N,j\in[1,m]\cap\N,a_{i,j}\in[0,m]\cap\N$。
- $\forall i\in[1,n]\cap\N,j\in[1,m-1]\cap\N,a_{i,j}<a_{i,j+1}$。
- $\forall i\in[2,n]\cap\N,j\in[1,m-1]\cap\N,a_{i,j}<a_{i-1,j+1}$。

对 $10^9+7$ 取模，$1\le n,m\le 10^6$。

## 思路
注意到 $a_{i,j}$ 的值域和一行元素的个数相关，与此同时，$A$ 中每一行分别单调递增。也就是说，$A$ 的每一行都一定是 $0$ 至 $m$ 中删去一个元素后排序的值。那么 $A$ 的一行可以直接由它删去的元素决定。所以我们可以考虑设 $f_{i,j}$ 表示考虑前 $i$ 行，第 $i$ 行少的元素是 $j$。怎么转移呢？我们先考虑如何通过少的元素 $j$ 来确定第 $i$ 行。对于整数 $k$，如果 $0\le k-1<j$ 的话，显然就有 $a_{i,k}=k-1$，因为 $0$ 至 $j-1$ 的元素都有，所以前 $j$ 个元素一定就是 $0$ 到 $j-1$；如果 $j+1\le k\le m$，那么 $a_{i,k}$ 就应该是 $k$，因为 $j+1$ 到 $m$ 也一定都有，所以后 $m-j$ 个元素一定是 $j+1$ 到 $m$。

我们已经将前两条限制做到了，考虑第三条限制。第三条限制要求 $a_{i,k}<a_{i-1,k+1}$。我们考虑把它转换为对每行没有的元素的约束。设第 $i$ 行没有的元素为 $j$，第 $i-1$ 行没有的为 $j'$。我们发现第 $i$ 行不选 $j$ 正相当于第 $i$ 行是个 $0$ 至 $m-1$ 的数列然后 $[j,m]$ 区间加一。而把第 $i-1$ 行全部左移一位相当于把 $i-1$ 行全部加上 $1$ 再把位置 $j'-1$ 上的元素加一。左移一位后，限制就变成了 $a_{i,k}<a_{i-1,k}$。左移之后的第 $i-1$ 行相当于数列 $1$ 至 $m$ 再 $[j'-1,m]$ 区间加一。作差，只要有 $k$ 使得 $a_{i,k}-a_{i-1,k}\ge 0$ 限制就满足，否则就不满足。作差后就是一个全是 $-1$ 的数列 $[j,m]$ 区间加一再 $[j'-1,m]$ 区间减一。显然，这样就要求加的区间比减的区间多出一段。所以当且仅当 $j<j'-1$ 时限制才不满足，也就是说 $j'\le j+1$ 是限制满足的充分必要条件。

所以，$f_{i,j}$ 可以从 $f_{i,j'}(0\le j'\le j+1)$ 转移过来。即得状态转移方程 $f_{i,j}=\sum_{k=0}^{j+1}f_{i-1,k}$，边界条件是 $f_{1,k}=1(0\le k\le m)$，答案是 $\sum_{i=0}^mf_{n,i}$。容易发现这个转移方程就是在对上一行做前缀和。所以我们就可以像前缀和一样转移：$f_{i,j}=[j\ge 0]\times f_{i,j-1}+[j\le m-1\land i>1]\times f_{i-1,j+1}$（没错，$j$ 可以取到 $-1$。如果不能取到，$f_{i-1,0}$ 就不会被计算了），边界条件是 $f_{1,0}=1$，答案是 $\sum_{i=0}^mf_{n,i}=f_{n+1,m-1}$。容易看出来这是一个有限制的走路方案数计数。因为限制关于 $j$ 的更多,所以我们把 $j$ 作为 $x$ 轴方便讨论。

于是我们得到这样一个结论：答案就是从 $(0,1)$ 出发走到 $(m-1,n+1)$ 的方案数，每次可以往右走或者往左上走，且走得过程不能越过或触碰三条直线：$x=-2,x=m+1,y=0$。但我们知道它不能往下走，所以 $y=0$ 不需要考虑。如下图（$n=4,m=3$）：

![阿绫阿绫](https://cdn.luogu.com.cn/upload/image_hosting/iurtxat8.png)

这里有很多悬浮在空中的平行四边形，还有很多坐标是负数的点，十分讨厌。我们将整个图像向下平移一格，再向右平移一格（起点变为 $(1,0)$，终点变为 $(m,n)$，两条直线变为 $x=-1,x=m+2$）：

![1099](https://cdn.luogu.com.cn/upload/image_hosting/dgq53nt1.png)

然而，直到现在我们还不会走平行四边形的计数。没有限制的情况还简单：总共往上走了 $n$ 格，也就总共往左走了 $n$ 格，所以往右就要总共走 $n+m-1$ 步。所以总共走了 $2n+m-1$ 步，其中 $n$ 步往左上走。答案即为 ${2n+m-1}\choose{n}$。但有限制的就很难办了。可能有人还想像 P1641 那样搞，但我们发现对称过去了之后向右的变成向左的，向左上的变成了向右上的。所以那样对称的话就会有两个阶段，两个阶段走路的规则不同，非常不可爱。

### 如果你不知道 P1641 是怎么搞的
P1641 要你求从 $(0,0)$ 走到 $(n,m)$ 不经过 $y=x+1$ 的方案数。如下图：

![关注洛天依谢谢喵](https://cdn.luogu.com.cn/upload/image_hosting/mxv2s4cc.png)

那我们就要求走的过程中不经过 $y=x+1$。容易想到方案数就是不做要求的方案数减去经过 $y=x+1$ 的方案数。这是一个基础的容斥。

不做要求的方案数是很好求的。我们总共要走 $n+m$ 步，其中 $n$ 步是在横坐标上走，答案就是 ${n+m}\choose n$。经过 $y=x+1$ 的方案数怎么求呢？既然经过就一定有第一次经过。我们把第一次经过 $y=x+1$ 前的点都沿 $y=x+1$ 做轴对称。如下图：

![马上就要省选了我还什么都不会怎么办](https://cdn.luogu.com.cn/upload/image_hosting/34kiy95l.png)

向上走对称过去成了向右走，向右走成了向上走，起点对称过去成了 $(-1,1)$。容易发现，从 $(-1,1)$ 到 $(n,m)$ 的路径集合与经过 $y=x+1$ 的路径集合形成了一个双射：把第一次 $y=x+1$ 前的步数全部把向上走变成向右走，向右走变成向上走。所以这两个集合大小也相等。所以经过 $y=x+1$ 的方案数就是从 $(-1,1)$ 到 $(n,m)$ 的方案数，即 ${n+m}\choose{n+1}$。该题答案即为 ${{n+m} \choose {n}} - {{n+m} \choose {n+1}}$。
### 继续

我们考虑将其转换为像 P1641 一样的向上走和向右走，约束线与 $x$ 轴夹角为 $\frac{\pi}{4}$。这个是一个非常常见的技巧，对坐标系做个变换即可。具体的，将原来坐标系中的 $y$ 轴旋转 $\frac{\pi}{4}$，再伸长到原来的 $\sqrt 2$ 倍。图像就变成了下图：

![我永远喜欢矩阵群姐姐](https://cdn.luogu.com.cn/upload/image_hosting/bwmsgxsu.png)

起点还在 $(1,0)$，终点变成了 $(m+n,n)$，两条直线变成了 $y=x+1$ 和 $y=x-m-2$。

然后就可以做容斥了，用无限制路径数减去穿过 $y=x+1$ 或 $y=x-m-2$ 的路径数。但我们发现穿过 $y=x+1$ 或 $y=x-m-2$ 的路径总数并不是很好求，因为一个路径可能会多次穿过 $y=x+1$ 的同时多次穿过 $y=x-m-2$。怎么处理呢？我们可以考虑它第一个穿过的是 $y=x+1$ 还是 $y=x-m-2$，这两个集合显然是无交的。所以如果我们能分别求出这两个集合的大小，那么两个集合的大小之和就是穿过 $y=x+1$ 或 $y=x-m-2$ 的路径数量。

我们先考虑如何求出第一次穿过的是 $y=x+1$ 的方案数。我们记穿过一次 $y=x+1$ 为 $A$，穿过一次 $y=x-m-2$ 为 $B$。我们现在有方法求出 $\cdots A\cdots$ 的路径条数。怎么在此基础上求出所有 $A\cdots$ 的路径呢？显然，我们应该把还有 $B$ 在它前面的路径也就是 $\cdots B\cdots A\cdots$ 的路径删去。但这么做是错的，因为 $B$ 前面可能还有 $A$，于是我们再把形如 $\cdots A\cdots B\cdots A\cdots$ 的路径加上，然后再把 $\cdots B\cdots A\cdots B\cdots A\cdots$ 的路径减去………以此类推，直到这样的路径不存在为止。

那么怎么求呢？之前我们是把第一次接触到直线之前的对称。现在为了求出来的不重不漏，我们应该把最后一次接触到直线之后的对称，因为我们是从后往前加的。具体怎么对称呢？我们来试着玩一下：

第一次，我们把终点沿 $y=x+1$ 轴对称过去，这样从起点到新终点的路径数就是 $\cdots A\cdots$ 的方案数：

![阿绫阿绫阿绫绫](https://cdn.luogu.com.cn/upload/image_hosting/uz1j329j.png)

我们发现从起点到新终点之间的路径有个重要的性质：如果它会穿过一次 $y=x-m-2$，那么它在这之后一定会穿过至少一次 $y=x+1$（虽然在我给出的例子里不可能穿过 $y=x-m-2$），因为 $y=x+1$ 在 $y=x-m-2$ 上面，而新终点又在 $y=x+1$ 上面。而这正是我们想要的性质：可以求出 $\cdots B\cdots A\cdots$ 的方案数。我们只需要再对新终点沿 $y=x-m-2$ 做一次反射，就可以求出 $\cdots B\cdots A\cdots$ 的数量了。接着我们发现它仍然具有这个良好的性质：即如果从起点到新新终点的路径穿过 $y=x+1$，那这次穿过一定在一次穿过 $y=x-m-2$ 之前。事实上，无论我们轴反射多少次，这条性质始终成立。对于 $y=x+1$，我们做轴对称的原点一定在 $y=x+1$ 下方，所以新点就在 $y=x+1$ 上方，所以接触了 $y=x-m-2$ 的路径一定要在接触后再穿过一次 $y=x+1$ 才有可能走到新点；对于 $y=x-m-2$ 同理。而轴反射的原点一定在 $y=x-m-2$ 上方或 $y=x+1$ 下方可以用归纳法轻松证明。于是我们轮流对称多次就可以求出形如我们需要的方案数了。

什么时候结束对称呢？之前已经说过，直到这样的路径不存在为止。什么时候这种路径不存在？当然是终点已经不能被起点走到的时候。什么时候终点不能被起点走到？当然是终点在起点左边或起点下面时。

现在我们已经会了怎么求出第一次是 $A$ 的路径，第一次是 $B$ 的路径把 $A$ 和 $B$ 交换一下做类似方法就行了。

相信各位读者可以自行推出点 $(x,y)$ 沿直线 $y=x+b$ 对称后的结果是什么，在此直接给出结论：结果是 $(y-b,x+b)$。

这么做的时间复杂度是多少？我们先沿 $y=x+1$ 做一次对称，终点变成了 $(n-1,m+n+1)$。然后再做 $k$ 次“先沿 $y=x-m-2$ 对称，再沿 $y=x+1$ 对称”，得到的就是 $(n-1-(m+3)k,m+n+1+(m+3)k)$。而在 $\lceil\frac{n-1}{m+3}\rceil$ 次对称操作后横坐标就一定小于 $1$ 了，在起点左边，所以这个的时间复杂度是 $\Theta(\frac{n}{m})$ 的。同理可证求第一次是 $B$ 的时间复杂度也为 $\Theta(\frac{n}{m})$，总时间复杂度就是 $\Theta(\frac{n}{m})$。不过考虑到我们要预处理阶乘和快速幂算乘法逆元来做组合数，所以真正的时间复杂度应该是 $\Theta(\frac{n\log n}{m}+n)$。

## 代码
```cpp
/*********************************************************************
    程序名:
    版权:
    作者: TM_Sharweek
    日期: 2025-02-22 20:42
    说明: 省选前还在做这种题的也是神人了
*********************************************************************/
#include <bits/stdc++.h>

#define p_b push_back
#define m_p make_pair
#define sec second
#define fst first
#define p_q priority_queue
#define u_m unordered_map

using namespace std;

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;

const int N = 1e7 + 50;
const ll P = 1e9 + 7;
const ll LTYL = 10071204121099;

ll jc[N];// 朴实无华的拼音

ll qpow(ll a, ll x) {
	ll ans = 1;
	while (x) {
		if (x % 2)
			ans = ans * a % P;
		a = a * a % P;
		x >>= 1;
	}
	return ans;
}

ll C(ll n, ll m) {
	return n > m || n < 0 ? 0 : jc[m] * qpow(jc[n], P - 2) % P * qpow(jc[m - n], P - 2) % P;
}

void dc(ll &a, ll &b, ll jj) {
	swap(a, b);
	a -= jj, b += jj;
}// 把 (a,b) 沿 y=x+jj 做轴反射

int main() {
//	freopen("LuoTianyi.in","r",stdin);
//	freopen("YuezhengLing.out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	ll n, m;
	cin >> n >> m;
	ll edx = n + m, edy = n;
	ll jj1 = 1, jj2 = -m - 2;
	ll qwq = 0;
	jc[0] = 1;
	for (int i = 1; i <= int(1e7); i++) {
		jc[i] = jc[i - 1] * i % P;
	}
	while (1 <= edx && 0 <= edy) {
		dc(edx, edy, jj1);
		qwq = (qwq + C(edx - 1, edx + edy - 1)) % P;// 从 (1,0) 走到 (edx,edy) 的方案数
		if (1 > edx || 0 > edy)// 边界处理
			break;
		dc(edx, edy, jj2);
		qwq = (qwq + P - C(edx - 1, edx + edy - 1)) % P;
	}
	edx = n + m, edy = n;
	while (1 <= edx && 0 <= edy) {
		dc(edx, edy, jj2);
		qwq = (qwq + C(edx - 1, edx + edy - 1)) % P;
		if (1 > edx || 0 > edy)
			break;
		dc(edx, edy, jj1);
		qwq = (qwq + P - C(edx - 1, edx + edy - 1)) % P;
	}
	cout << (C(n, 2 * n + m - 1) + P - qwq) % P << endl;

	return -1;// 炸死你
}
``````

---

## 作者：tzl_Dedicatus545 (赞：2)

拜谢反射容斥大神 irris。

假设我们要计算从 $(0,0)$ 到 $(n,m)$ 不经过直线 $A$ 和 $B$，每步都往右或者往上的方案数。

类似这样：（图是偷得）![](https://cdn.luogu.com.cn/upload/image_hosting/c4nn7lq0.png)

总数显然是 $\binom{n+m}{n}$。

我们现在希望计数经过直线 $A$ 或 $B$ 的方案数，我们可以计数以 A 开头的加上以 B 开头的。

缩一下 AB 连续段，相同的交点我们只考虑第一个

我们首先做 $P(n,m)$ 关于 $A$ 的对称点 $P'$，然后做 $P'$ 关于 $B$ 的对称点 $P''$，两者相减，我们就得到了以下的方案数：

- A
- AB

这是因为 $P'$ 实际上计算了以 A 和 AB 结尾的方案树，$P''$ 计算了以 BA 和 BAB 结尾的方案数。

如此递归的操作下去，直到折到第一象限外面去（因为这代表此时已经无法以目前的后缀结尾了）就停止即可。

设 A 和 B 在 $y$ 轴上的截距为 $p,q$，则复杂度是 $\Theta(\frac{n}{|p-q|})$。

---

## 作者：JimmyLee (赞：1)

# 题意

> 有一个 $n \times m$ 的数组 $x_{i,j} (1 \le i \le n, 1 \le j \le m)$，满足：
>
> - $x_{i,j}\in[0,m]$
>
> - $\forall i \in [1,n],\forall j\in[1,m),x_{i,j}<x_{i,j+1}$
>
> - $\forall i \in (1,n],\forall j\in[1,m),x_{i,j} <x_{i-1,j+1}$
>
> 求可能的数组 $x_{i,j}$ 的解数，答案对 $10^9+7$ 取模。 

# 分析

首先根据 $x_{i, j} < x_{i,j+1}$ 得到 $i$ 相同的一行 $m$ 个元素是单调上升的。

又因为 $x_{i,j}\in[0,m]$，所以这一行就是 $0 \sim m$ 的序列中去掉一个元素。

---

考虑使用 dp。

令 $dp_{i,j}$ 为第 $i$ 行去掉元素 $j$ 的解数。

模拟过程可得若第 $i$ 行去除元素 $j$，那么第 $i-1$ 行可以去除 $[0,j+1]$ 中的任一元素。

所以得到转移方程：
$$
\begin{align}

dp_{i,j}&=\sum^{j+1}_{k=0} dp_{i-1,k}\\

&=\sum^{j}_{k=0} dp_{i-1,k}+dp_{i-1, j+1} \\

&=dp_{i, j-1}+dp_{i-1,j+1}

\end{align}
$$
答案即为 $\sum^m_{k=0}\limits dp_{n,k}=dp_{n+1,m-1}$。

转移过程如下（$n=3,m=4$）：

![](https://cdn.luogu.com.cn/upload/image_hosting/2tuaam50.png)

我们将这个图像拉伸，平移一下：

![](https://cdn.luogu.com.cn/upload/image_hosting/15y8acka.png)

发现就是求从 $(0,0)$ 到 $(n+m-1,n)$ 且**只能向上和向右**且**与直线 $l_1:y=x+2$ 和直线 $l_2:y=x-m-1$ 不交**的路径数。 

---

考虑使用反射容斥。

由容斥得：答案为总方案数 - 经过 $l_1$ - 经过 $l_2$ + 经过 $l_1l_2$ + 经过 $l_2l_1$ - 经过 $l_1l_2l_1$ - 经过 $l_2l_1l_2$...

考虑如何计算每一部分。

已知从点 $(0,0)$ 到 $(n, m)$ 只能向上和向右的路径数为 $\binom{n+m}{n}$。

总方案数为原点到到 $(n+m-1,n)$ 的方案数。

经过 $l_1$ 的方案数为原点到目标点 $A$ 沿 $l_1$ 对称得到的 $A'$ 的方案数。

经过 $l_1l_2$ 的方案数如何求解？

$l_1$ 沿 $l_2$ 对称得到直线 $l_1'$。

将 $A'$ 沿 $l_1'$ 对称得到 $A''$。

方案数即为原点到 $A''$ 的方案数。

---

若某次对称得到的点 $A_x$ 不在第一象限，那么结束循环。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define mod 1000000007
#define maxn 4000006

int pre[maxn], inv[maxn];
int64_t ksm(int64_t x, int l)
{
    int64_t ret=1;
    for(;l;l>>=1, x=x*x%mod)
        if(l&1) ret=ret*x%mod;
    return ret;
}

int C(int n, int m) {return ((int64_t)pre[n]*inv[n-m]%mod)*inv[m]%mod;}

typedef pair<int, int> pos_t;
int path_count(pos_t p) {return C(p.first+p.second, p.first);}
pos_t reflect(int a, pos_t p) {return {p.second-a, a+p.first};}
int reflect(int a, int b) {return (a<<1)-b;}

int main()
{
    pre[0]=1;
    for(int i=1;i<maxn;i++) pre[i]=(int64_t)pre[i-1]*i%mod;
    inv[maxn-1]=ksm(pre[maxn-1], mod-2);
    for(int i=maxn-2;~i;i--) inv[i]=(int64_t)inv[i+1]*(i+1)%mod;
    int n, m;
    cin>>n>>m;
    int a1=2, a2=-m-1;
    int mul=-1, ans=path_count({n+m-1, n});
    for(pos_t p=reflect(a1, {n+m-1, n});p.first>=0&&p.second>=0;)
    {
        ans=((ans+mul*path_count(p))%mod+mod)%mod;
        a2=reflect(a1, a2);
        swap(a1, a2);
        p=reflect(a1, p);
        mul*=-1;
    }
    mul=-1;
    a1=-m-1, a2=2;
    for(pos_t p=reflect(a1, {n+m-1, n});p.first>=0&&p.second>=0;)
    {
        ans=((ans+mul*path_count(p))%mod+mod)%mod;
        a2=reflect(a1, a2);
        swap(a1, a2);
        p=reflect(a1, p);
        mul*=-1;
    }
    cout<<ans;
}
```

---


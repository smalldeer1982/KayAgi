# [JLOI2016] 成绩比较

## 题目描述

G 系共有 $N$ 位同学，$M$ 门必修课。这 $N$ 位同学的编号为 $0$ 到 $N-1$ 的整数，其中 B 神的编号为 $0$ 号。这 $M$ 门必修课编号为 $0$ 到 $M-1$ 的整数。一位同学在必修课上可以获得的分数是 $1$ 到 $U_i$ 中的一个整数。

如果在每门课上 A 获得的成绩均小于等于 B 获得的成绩，则称 A 被 B 碾压。在 B 神的说法中，G 系共有 $K$ 位同学被他碾压（不包括他自己），而其他 $N-K-1$ 位同学则没有被他碾压。D 神查到了 B 神每门必修课的排名。

这里的排名是指：如果 B 神某门课的排名为 $R$，则表示有且仅有 $R-1$ 位同学这门课的分数大于 B 神的分数，有且仅有 $N-R$ 位同学这门课的分数小于等于 B 神（不包括他自己）。

我们需要求出全系所有同学每门必修课得分的情况数，使其既能满足 B 神的说法，也能符合 D 神查到的排名。这里两种情况不同当且仅当有任意一位同学在任意一门课上获得的分数不同。

你不需要像 D 神那么厉害，你只需要计算出情况数模 $10^9+7$ 的余数就可以了。

## 说明/提示

$1\leq N\leq 100$，$1\leq M\leq 100$，$1\leq U_i\leq 10^9$，$1\leq R_i\leq N$。

## 样例 #1

### 输入

```
3 2 1
2 2
1 2```

### 输出

```
10```

# 题解

## 作者：Redpojoe (赞：34)

（数学公式的锅暂时已修复）

玄学组合数学题。对于我等蒟蒻，高级的方法是不存在的，~~dp是不存在的~~，所以我们只有用强硬的组合数学功底解决。

前置知识：没有神仙的各种数学知识，只有基本的组合数学。

#### 大体思路框架

我们可以清晰地把整个题目的框架分成三份：

1. 计算在n-1个人中选出k个，被B神碾压的方案数。
2. 对于剩下的n-1-k个人，计算有多少种方案来合法分配每一个人、每一门科目的得分状况。这里，得分状况定义为是比B神高，还是比B神低或相等。
3. 已知每一门科目的得分状况，计算对于给定的满分，有多少种分配分数的方案。

首先，第一个部分的答案很显然是$C(n-1,k)$。接下来我们要讨论第2、3部分。

#### 第二部分计数

在第二部分中，很显然我们可以对于每一门科目进行讨论。对于每一门科目，分数比B神高的人有$R[i]-1$个（不能重复，不计顺序），并且只可能在那$n-k-1$个人中诞生。所以对于这门课，方案为$C(R[i]-1,n-k-1)$个。用乘法原理可以得到。

但是有一个问题：由于**恰好**有k个人被碾压，每个人都必须被选中至少一次。对于这种问题，一个很常用的方法就是**容斥原理**。

定义函数$F(p)$表示至多有p个人被碾压，这一步总共的方案数。上述的乘法原理+组合数的计算过程就是$F(n-k-1)$的计算过程，只用把参数改成p即可解决。然后枚举p进行容斥，即可得到第二部分的计算结果。复杂度$O(nm)$。

#### 第三部分计数

在第三部分中，显然，可以把每一门科目分开来处理。这样，需要我们实现一个函数$G(u,a,b)$，表示有u种可选分数，其中a个人比B神高，b个人低于或等于B神的方案数。这里假定根据第一、第二步，这些人的得分状况已经被选定好，所以不用考虑顺序问题。

枚举B神的分数，显然有：

$$G(u,a,b)=\sum_{i=0}^{u-1}i^a\cdot(u-i)^b$$

其中i表示有多少种分数比B神的分数高。

然而，由于u的范围很大，这样显然T飞。所以我们需要作出一些措施。想想，你平常遇到这种数据范围很大的题都是怎么做的？很容易想到离散化。当然这里不用直接离散化，而要借助离散化的思想。

我们可以**枚举这n个人有t种不同的得分**，然后，t的范围就很小了，这个时候直接调用暴力函数也没事。同时，我们知道有$C(u,t)$种方案从u个分数中选出t个。所以对于t，贡献为$D(t)=G(t,a,b)\cdot C(u,t)$。最后用加法原理加起来即可。

但是那个式子其实是错的，因为又有一个问题：在暴力函数中，有一种情况就是：给你t种可能的分数，但是并不全都取到t种，会导致重复。所以，我们可以再用一次容斥，把重复的情况剔除。对于**恰**有r种分数的情况，被重复计算了$C(t,r)$次。故有：

$D(t)=(G(t,a,b)-\sum_{i=1}^{t-1}D(i)\cdot C(t,i))\cdot C(u,t)$

所以而t最大为n。所以每次用$O(n^2)$的复杂度，可以计算出$G(u,a,b)$。

最后乘法原理把三步乘起来，从复杂度$O(n^2m)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int P=1e9+7;

int n,m,k;
int U[105],R[105];

long long Pow(long long a,long long p) {
	long long ret=1;
	for(; p; p>>=1,a=a*a%P)if(p&1)ret=ret*a%P;
	return ret;
}

//各种预处理
long long C[105][105],Pw[105][105];//在暴力G函数中用的乘方也可以预处理
long long Fact[105],Inv[105];
void Init() {
	for(int i=1; i<=100; i++)
		for(int j=0; j<=i; j++)
			if(j==0||j==i)C[i][j]=1;
			else C[i][j]=(C[i-1][j-1]+C[i-1][j])%P;
	Fact[0]=1;
	for(int i=1; i<=100; i++)Fact[i]=Fact[i-1]*i%P,Inv[i]=Pow(i,P-2);
	for(int i=0; i<=100; i++) {
		Pw[i][0]=1;
		for(int j=1; j<=100; j++)Pw[i][j]=Pw[i][j-1]*i%P;
	}
}

long long F(int p) {//F函数
	long long Ans=1;
	for(int i=1; i<=m; i++)Ans=Ans*C[p][R[i]-1]%P;//暴力即可
	return Ans;
}

long long Calc() {
	int tot=n-k-1;
	long long Ans=0;
	for(int i=0; i<tot; i++) {
		long long th=F(tot-i)*C[tot][i];//不要忘记乘组合数！
		if(i&1)Ans-=th;//i表示tot个人中有多少个人没有出现，故偶加奇减
		else Ans+=th;
		Ans%=P;
	}
	Ans=(Ans+P)%P;
	return Ans;
}

long long g(int u,int a,int b) {//暴力G函数
	long long ret=0;
	for(int i=0; i<u; i++)ret=(ret+Pw[i][a]*Pw[u-i][b])%P;
	return ret;
}

long long D[105];
long long G(int u,int a,int b) {//离散化优化G函数
	long long Ans=0;
	long long Combination=1;
	for(int i=1; i<=n; i++) {
		D[i]=g(i,a,b);
		for(int j=1; j<i; j++)D[i]=(D[i]-D[j]*C[i][j])%P;//减去重复的
		Combination=Combination*(u-i+1)%P*Inv[i]%P;//组合数可以递推
		Ans=(Ans+D[i]*Combination)%P;//加法原理
	}
	return (Ans+P)%P;
}

void Solve() {
	Init();
	long long Ans=C[n-1][k]*Calc()%P;
	for(int i=1; i<=m; i++)Ans=Ans*G(U[i],R[i]-1,n-R[i])%P;//乘法原理
	printf("%lld\n",Ans);
}

int main() {
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1; i<=m; i++)scanf("%d",&U[i]);
	for(int i=1; i<=m; i++)scanf("%d",&R[i]);
	Solve();
	return 0;
}
```

By ^3

---

## 作者：WinXP (赞：22)

开始的时候这么多量我是一头雾水，所以只好一点点求。

//所涉及到的变量如未特殊声明即为题目中的变量

.

1.首先根据题意同学们是互不相同的。(显然...)

$k$ 名同学被B神碾压。$k$ 名同学的组成共有 $C^k_{n-1}$ 种方式。

2.嗯..然后 $n-k-1$ (记为 $num$ ) 名同学是没有被B神碾压的，所以每人都至少有一科比B神高。

3.再然后，B神排名是已知的，所以考虑比B神某科高的人出现在 $num$ 名同学中的方案。显然为 $C^{Rk-1}_{num}$。

4.把 $m$ 科一起算，计 $T_{num}$ 为m个科目分给 $num$ 人的方案数，为

$$T_{num}=\prod_{k=1}^{m} {C^{R_k-1}_{num}}$$

5.不过有个问题，$num$ 人不被B神碾压，要求每个人都至少有一科比B神高，这样计算会出现只涉及到一部分人的情况。

容斥一下。得

$$T=\sum_{i=0}^{num}(-1)^{num-i} C_{num}^i T_{i}$$

$$=\sum_{i=0}^{num}(-1)^{num-i} C_{num}^i\prod_{k=1}^{m} {C^{R_k-1}_{i}}$$

那么到现在 $C^{k}_{n-1}T$ 即为同学比B神的成绩相对大小的方案数。不过还没有考虑分数的问题。

6.先考虑单科，考虑某一科满足B神排名为 $Ri$ 的方案数。

7.首先，$n$ 个同学分布在 $x$ 分内的方案显然为 $x^n$ (最低为1分，开始我没好好读题以为可以有0分卡了好久)，因为我们只是考虑同学与B神的分数高低方案，同学间的高低没算在内，所以不是组合数形式...

因为 $Ri-1$ 名同学必须严格大于B神，$n-Ri$ 名同学是小于等于B神，所以不能简单乘一乘，那就枚举b神的分数

$$Si=\sum_{x=1}^{Ui} x^{n-Ri}(Ui-x)^{Ri-1}$$

这显然会T，因为 $Ui$ 很大。

8.所以~~根据经验~~就乱搞一下———把后面的$(Ui-x)^{Ri-1}$展开~~应该会很不错~~。然后交换一下求和的顺序。

$$Si=\sum_{x=1}^{Ui} x^{n-Ri}(Ui-x)^{Ri-1}$$
$$=\sum_{x=1}^{Ui} x^{n-Ri} \sum_{t=0}^{Ri-1}(-1)^t C^t_{Ri-1}Ui^{Ri-1-t}x^t$$
$$=\sum_{x=1}^{Ui} \sum_{t=0}^{Ri-1}(-1)^t C^t_{Ri-1}Ui^{Ri-1-t}x^t x^{n-Ri}$$
$$= \sum_{t=0}^{Ri-1}(-1)^t C^t_{Ri-1}Ui^{Ri-1-t}\sum_{x=1}^{Ui}x^{n-Ri+t}$$

那么这个东西就可求了。求出 $\sum_{x=1}^{Ui}x^{n-Ri+t}$就可以了。

怎么就可求了呢？

9.考虑$1^2+2^2+3^2+4^2+...+n^2=\frac{n(n+1)(2n+1)}{6}$的证明方法。其中一种证明法为：

设$Tn=(n+1)^3-n^3$,有

$$Tn=(n+1)^3-n^3=3n^2+3n+1$$

		然后显然的是
$$\sum_{i=1}^n Ti=(n+1)^3-n^3+n^3-(n-1)^3+...-1^3$$
$$=(n+1)^3-1$$

		根据上面还有
        
$$\sum_{i=1}^n Ti=3 \sum_{i=1}^n i^2+3\sum_{i=1}^ni+\sum_{i=1}^n1$$

10.所以对于 $1^t+2^t+3^t+...+n^t$ 可以用类似方法求。把这个数列记为 $X_t^n$，则有

$$(n+1)^{t+1}-1=\sum_{i=0}^t C_{t+1}^{t-i+1} X_i^n$$

$$X_t^n=(n+1)^{t+1}-1-\sum_{i=0}^{t-1} C_{t+1}^{t-i+1}X_i^n$$

$$X_0^n=n$$

可以在$O(t^2)$时间内得到 $X$。

11.认真考虑一下，好像没有别的了。当然乘一起。

$$ans=C^k_{n-1}T\prod_{i=1}^m Si$$
$$=C^k_{n-1}(\sum_{i=0}^{num}(-1)^{num-i}C_{num}^i \prod_{k=1}^{m} {C^{R_k-1}_{i}})\prod_{i=1}^m \sum_{t=0}^{Ri-1}(-1)^t C^t_{Ri-1}Ui^{Ri-1-t}X_{n-Ri+t}^{Ui}$$

复杂度$O(mn^2)$，主要在于处理 $X$ 。

```cpp
#include <bits/stdc++.h>
#define rap(i,s,n) for(int i=s;i<=n;i++)
#define drap(i,s,n) for(int i=s;i>=n;i--)
#define N 233
#define ll long long
#define P 1000000007
#define m(s,k) memset(s,k,sizeof s)
using namespace std;
char xB[1<<15],*xS=xB,*xTT=xB;
#define getc() (xS==xTT&&(xTT=(xS=xB)+fread(xB,1,1<<15,stdin),xS==xTT)?0:*xS++)
#define isd(c) ((c>='0'&&c<='9')||(c=='-'))
template<typename T>
inline bool rd(T& xa){
    char xchh; T f=1; while(xchh=getc(),(!isd(xchh))&&(xchh!=0));
    if(xchh==0) return 0; if(xchh=='-') xchh=getc(),f=-1; xa=xchh-'0';
    while(xchh=getc(),isd(xchh)) xa=xa*10+xchh-'0'; xa*=f; return 1;
}
ll mpow(ll a,ll k,ll p){ll res=1; while(k){if(k&1) res=res*a%p; k>>=1; a=a*a%p;} return res%p;}
int n,m,nm,num,k,R[N];
ll U[N],C[N][N],X[N][N],inv[N];
int main(){
    rd(n),rd(m),rd(k); rap(i,1,m) rd(U[i]); rap(i,1,m) rd(R[i]); num=n-k-1,nm=max(n,m);
    C[0][0]=1; rap(i,1,nm+10){C[i][0]=1; rap(j,1,i) C[i][j]=(C[i-1][j-1]+C[i-1][j])%P;}
    inv[1]=1; rap(i,2,n+10) inv[i]=inv[P%i]*(P-P/i)%P;
    ll T=0,f=-1; drap(i,num,0){f=-f; ll Ti=1; rap(k,1,m) Ti=(Ti*C[i][R[k]-1])%P; T=(T+Ti*f*C[num][i]+P)%P;}
    rap(k,1,m) rap(t,0,n){
        ll s=0; rap(i,0,t-1) s=(s+C[t+1][t-i+1]*X[k][i])%P;
        X[k][t]=(mpow(U[k]+1,t+1,P)-1-s+P)%P*inv[t+1]%P;
    }
    ll S=1; rap(i,1,m){
        ll si=0,f=-1;
        rap(t,0,R[i]-1) f=-f,si=(si+f*C[R[i]-1][t]*mpow(U[i],R[i]-1-t,P)%P*X[i][n-R[i]+t]%P+P)%P;
        S=(S*si+P)%P;
    }
    printf("%lld\n",C[n-1][k]*T%P*S%P);
    return 0;
}
```

---

## 作者：K8He (赞：12)

[原题链接。](https://www.luogu.com.cn/problem/P3270)

看到这个「恰好」就比较套路的放上二项式反演：设 $f(k)$ 表示恰好 $k$ 个人被碾压，$g(x)$ 表示钦定 $k$ 个人被碾压。

不难得到反演式子:

$$
g(k) = \sum_{i = k}^{n}\dbinom{i}{k}f(i)\Leftrightarrow f(k) = \sum_{i = k}^{n}(-1)^{i - k}\dbinom{i}{k}g(i)
$$

考虑求 $g(k)$，有式子：

$$
g(k) = \dbinom{n - 1}{k}\prod_{i = 1}^{m}\sum_{s = 1}^{U_i}\dbinom{n - k - 1}{R_i - 1}s^{n - R_i}(U_i - s)^{R_i - 1}
$$

简单解释：选出 $k$ 个人被钦定，对于每一科考虑枚举 D 神的分数，在没被钦定的 $n - k - 1$ 个人中选出 $R_i - 1$ 个人作为分数比 D 神高的人，然后可以知道每个人分数的可能数，其积为每个人的分数的总可能数。

这样复杂度是基于值域的，考虑展开后面的依托：

$$
\begin{aligned}
 &\sum_{s = 1}^{U_i}\dbinom{n - k - 1}{R_i - 1}s^{n - R_i}(U_i - s)^{R_i - 1}\\
=&\sum_{s = 1}^{U_i}\dbinom{n - k - 1}{R_i - 1}s^{n - R_i}\sum_{j = 0}^{R_i - 1}\dbinom{R_i - 1}{j}U_i^{j}(-1)^{R_i - 1 - j}s^{R_i - 1 - j}\\
=&\dbinom{n - k - 1}{R_i - 1}\sum_{j = 0}^{R_i - 1}(-1)^{R_i - 1 - j}\dbinom{R_i - 1}{j}U_i^{j}\sum_{s = 1}^{U_i}s^{n - j - 1}\\
=&\dbinom{n - k - 1}{R_i - 1}h(i)
\end{aligned}
$$

这个 $h(i)$ 部分只与 $i$ 有关所以单独提出来进行预处理，现在和值域有关的部分只剩下了后面的自然数幂和，这样就可以拉插或伯努利数处理了。

但是我不会拉插也不会伯努利数，咋整呀？

答案是用扰动法可以得到自然数幂和的一个递推式：

$$
S_{t}(n) = \sum_{k = 1}^{n}k^{t} = \frac{(n + 1) ^ {t + 1} - \sum_{j = 0}^{t - 1}\dbinom{t + 1}{j}S_j(n)}{(t + 1)}
$$

我写这个是为了让你知道我代码里有啥，最好还是用拉插的，不然别人也不知道你在干什么。

这样可以 $O(mR^2) = O(n^3)$ 预处理出所有的 $h(i)$，然后把它带回原式：

$$
f(k) = \sum_{i = k}^{n}(-1)^{i - k}\dbinom{i}{k}\dbinom{n - 1}{i}\prod_{j = 1}^{m}\dbinom{n - i - 1}{R_j - 1}h(j)
$$


可以 $O(n^2)$ 算出。

代码：

```cpp
#include <bits/stdc++.h>
#define lowb(a, r, x) lower_bound(a + 1, a + r + 1, x) - a
#define uppb(a, r, x) upper_bound(a + 1, a + r + 1, x) - a
#define _for(i, a, b) for (ll i = a; i <= b; ++i)
#define for_(i, a, b) for (ll i = a; i >= b; --i)
#define far(i, vec) for (auto i : vec)
#define bdmd ll mid = (l + r) >> 1
#define NO nullptr
typedef long double ldb;
typedef long long ll;
typedef double db;
typedef std::pair <ll, ll> pll;
const ll N = 110, P = 1e9 + 7;
namespace SOLVE {
	ll n, m, k, U[N], R[N], s[N], h[N], fac[N], inv[N], invf[N], ans;
	inline ll rnt () {
		ll x = 0, w = 1; char c = getchar ();
		while (!isdigit (c)) { if (c == '-') w = -1; c = getchar (); }
		while (isdigit (c)) x = (x << 3) + (x << 1) + (c ^ 48), c = getchar ();
		return x * w;
	}
	inline ll FastPow (ll a, ll b) {
		ll ans = 1;
		while (b) {
			if (b & 1) ans = ans * a % P;
			a = a * a % P, b >>= 1;
		}
		return ans;
	}
	inline void PreC (ll n) {
		fac[0] = fac[1] = 1, inv[0] = inv[1] = 1, invf[0] = invf[1] = 1;
		_for (i, 2, n) {
			fac[i] = fac[i - 1] * i % P;
			inv[i] = (P - P / i) * inv[P % i] % P;
			invf[i] = invf[i - 1] * inv[i] % P;
		}
		return;
	}
	inline ll C (ll n, ll m) {
		return fac[n] * invf[m] % P * invf[n - m] % P;
	}
	inline void PreS (ll n, ll t) { //  Sum of powers of natural numbers.
		s[0] = n + 1;
		_for (i, 1, t) {
			s[i] = 0;
			_for (j, 0, i - 1) s[i] = (s[i] + C (i + 1, j) * s[j]) % P;
			s[i] = (FastPow (n + 1, i + 1) - s[i] + P) * FastPow (i + 1, P - 2) % P;
		}
		return;
	}
	inline void In () {
		n = rnt (), m = rnt (), k = rnt ();
		_for (i, 1, m) U[i] = rnt ();
		_for (i, 1, m) R[i] = rnt ();
		return;
	}
	inline void Solve () {
		PreC (n);
		ll w = 1;
		_for (i, 1, m) {
			PreS (U[i], n);
			ll w = 1;
			for_ (j, R[i] - 1, 0) {
				h[i] = (h[i] + w * C (R[i] - 1, j) * FastPow (U[i], j) % P * s[n - 1 - j]) % P;
				w *= -1;
			}
		}
		_for (i, k, n) {
			ll g = C (n - 1, i);
			_for (j, 1, m) g = g * C (n - i - 1, R[j] - 1) % P * h[j] % P;
			ans = (ans + w * C (i, k) * g % P + P) % P;
			w *= -1;
		}
		return;
	}
	inline void Out () {
		printf ("%lld\n", ans);
		return;
	}
}
int main () {
#ifndef ONLINE_JUDGE
	freopen ("data.in", "r", stdin);
#endif
	SOLVE::In ();
	SOLVE::Solve ();
	SOLVE::Out ();
	return 0;
} /*

*/
```


---

## 作者：The_KOG (赞：10)

[更好阅读体验戳这里](<https://www.cnblogs.com/nlKOG/p/10822634.html>)

要求的是三部分:
1.只考虑从所有人中选出K个人被碾压的方案数

2.只考虑所有人每门成绩高低关系(高于B神或低于B神)的方案数

3.只考虑所有人的具体成绩方案数

答案显然是三数相乘

(下文中下标均从1开始,比如$文中U_i表示题中U_{i-1}$)

### 第一部分

显然是$C_{N-1}^K$

### 第二部分

每门都要有$R-1$个人的成绩超过B神

考虑$F(x)=\prod\limits_{i=1}^MC_x^{R_i-1}$表示每门有R-1个人超过B神的方案数

设d=N-K-1

由容斥得$G=\sum\limits_{i=0}^d (-1)^{d-i}C_d^i F(i)$表示d个人不被碾压的方案数

### 第三部分

首先只考虑一门的方案数

a个人分布在b分里的方案数为$b^a$

先考虑B神分数为x时的方案数为$x^{N-R}(U-x)^{R-1}$

所以第 i 门的方案数为$H(i)=\sum\limits_{x=1}^{U_i} x^{N-R_i} (U_i-x)^{R_i-1}$

把$(U_i-x)^{R_i-1}$二项式定理展开得到$\sum\limits_{t=0}^{R_i-1}(-x)^t U_i^{R_i-t-1}C_{R_i-1}^t$
$\therefore H(i)=\sum\limits_{x=1}^{U_i}x^{N-R_i}\sum\limits_{t=0}^{R_i-1}(-1)^tx^tU_i^{R_i-t-1}C_{R_i-1}^t$

$=\sum\limits_{x=1}^{U_i}\sum\limits_{t=0}^{R_i-1}(-1)^tx^{N-R_i}x^tU_i^{R_i-t-1}C_{R_i-1}^t$

$=\sum\limits_{x=1}^{U_i}\sum\limits_{t=0}^{R_i-1}(-1)^tx^{N-R_i+t}U_i^{R_i-t-1}C_{R_i-1}^t$

$=\sum\limits_{t=0}^{R_i-1}\sum\limits_{x=1}^{U_i}(-1)^tx^{N-R_i+t}U_i^{R_i-t-1}C_{R_i-1}^t$

$=\sum\limits_{t=0}^{R_i-1}(-1)^tU_i^{R_i-t-1}C_{R_i-1}^t\sum\limits_{x=1}^{U_i}x^{N-R_i+t}$

其中$\sum\limits_{x=1}^{U_i}x^{N-R_i+t}$是连续自然数幂和

根据定理: 前N个自然数的K次幂和一定能表示为关于N的K+1次多项式

就可以用拉格朗日插值在$O(N)$的时间内算出

那么M门加一起的方案数是$\prod\limits_{i=1}^M H(i)$, 时间复杂度$O(N^2M)$

### 结论

$ans=C_{N-1}^K G\prod\limits_{i=1}^MH(i)$

### 代码

```cpp
#include<bits/stdc++.h>
const int N=305;
const int mod=1e9+7;
int Pow(int x,int f=mod-2){
    int re=1;
    while(f){
        if(f&1)re=1ll*re*x%mod;
        f>>=1;
        x=1ll*x*x%mod;
    }
    return re;
}
namespace Lagrange{
    int mul[N];
    int Lagrange(int n,int t,int *f){
        if(t<=n)return f[t];
        int re=0,s=1;
        for(int i=1;i<=n;i++)s=1ll*s*(t-i)%mod;
        for(int i=1;i<=n;i++){
            int tmp=1ll*s*f[i]%mod;
            int div=1ll*mul[i-1]*mul[n-i]%mod;
            div=1ll*div*(t-i)%mod;
            div=Pow(div);
            tmp=1ll*tmp*div%mod;
            if((n-i)&1)re=(re-tmp+mod)%mod;
            else re=(re+tmp)%mod;
        }
        return re;
    }
    void Pre(int t,int *f){
        mul[0]=mul[1]=1;
        for(int i=2;i<=t+2;i++)mul[i]=1ll*mul[i-1]*i%mod;
        for(int i=1;i<=t+2;i++)f[i]=(f[i-1]+Pow(i,t))%mod;
    }
    int f[N];
    int Sum(int n,int t){
        Pre(t,f);
        int re=Lagrange(t+2,n,f);
        return re;
    }
}
int n,m,k,u[N],r[N],c[N][N];
void Init(){
    c[0][0]=1;
    for(int i=1;i<=n;i++){
        c[i][0]=1;
        for(int j=1;j<=i;j++){
            c[i][j]=c[i-1][j-1]+c[i-1][j];
            c[i][j]%=mod;
        }
    }
}
int Count(int x){
    int re=1;
    for(int i=1;i<=m;i++)
        re=1ll*re*c[x][r[i]-1]%mod;
    return re;
}
signed main(){
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=m;i++)scanf("%d",u+i);
    for(int i=1;i<=m;i++)scanf("%d",r+i);
    Init();
    int ans=0,tmp,d=n-k-1;
    for(int i=0;i<=d;i++){
        int tmp=((d-i)&1)?mod-1:1;
        tmp=1ll*tmp*c[d][i]%mod;
        tmp=1ll*tmp*Count(i)%mod;
        ans=(ans+tmp)%mod;
    }
    for(int i=1,s;i<=m;i++){
        s=0;
        for(int t=0;t<r[i];t++){
            tmp=(t&1)?mod-1:1;
            tmp=1ll*tmp*Pow(u[i],r[i]-t-1)%mod;
            tmp=1ll*tmp*c[r[i]-1][t]%mod;
			tmp=1ll*tmp*Lagrange::Sum(u[i],n+t-r[i])%mod;
            s=(s+tmp)%mod;
        }
        ans=1ll*ans*s%mod;
    }
    ans=1ll*ans*c[n-1][k]%mod;
    printf("%d",ans);
    return 0;
}
```

---

## 作者：D2T1 (赞：9)

是我会的题，所以感觉难度不如 noip T3T4。

设 $f_{i,j}$ 表示考虑到前 $i$ 门课，有 $j$ 人被 B 碾压。

转移，设这轮中有 $k$ 个原本被碾压的人不再被碾压，则相当于从 $f_{i-1,j+k}$ 转移到 $f_{i,j}$。考虑转移系数，首先是 $j+k$ 人中选 $k$ 人，现在排名在 B 前面的位置还有 $r_i-1-k$ 位，所以从 $n-1-j-k$ 中选 $r_i-1-k$ 个。最后是每个人有一个分数，易得要乘上 $\sum_{j=1}^{u_i}j^{n-r_i}(u_i-j)^{r_i-1}$。所以转移方程为：

$$
f_{i,j} = \sum_{k=0}^{\min(n-j-1,r_i-1)}f_{i-1,j+k}\dbinom{j+k}k\dbinom{n-1-j-k}{r_i-1-k}T_i
$$

其中：

$$
T_i = \sum_{j=1}^{u_i}j^{n-r_i}(u_i-j)^{r_i-1}
$$

边界是 $f_{0,n-1}=1$，答案取 $f_{m,k}$。

容易发现瓶颈在于 $T_i$ 的计算，看到这个式子我们想到了 [CF622F](https://codeforces.com/contest/622/problem/F)，于是直接拉格朗日插值就能求出来了。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N = 110;
const ll P = 1e9 + 7;
int n, m, k, u[N], r[N];
ll f[N][N], y[N*2], t[N], C[N][N];

ll qp(ll x, ll y){
	ll ans = 1;
	while(y){
		if(y & 1){
			ans = ans * x % P;
		}
		x = x * x % P;
		y >>= 1;
	}
	return ans;
}

ll lglr(int xk){
	ll res = 0;
	for(int i = 1; i <= n + n; ++ i){
		ll mul = y[i];
		for(int j = 1; j <= n + n; ++ j){
			if(j != i){
				mul = mul * (xk - j + P) % P * qp(i-j+P, P-2) % P;
			}
		}
		res = (res + mul) % P;
	}
	return res;
}

int main(){
	scanf("%d%d%d", &n, &m, &k);
	for(int i = 1; i <= m; ++ i){
		scanf("%d", &u[i]);
	}
	for(int i = 1; i <= m; ++ i){
		scanf("%d", &r[i]);
	}
	C[0][0] = 1;
	for(int i = 1; i <= n; ++ i){
		C[i][0] = C[i][i] = 1;
		for(int j = 1; j < i; ++ j){
			C[i][j] = (C[i-1][j] + C[i-1][j-1]) % P;
		}
	}
	f[0][n-1] = 1;
	for(int i = 1; i <= m; ++ i){
		for(int j = 1; j <= n + n; ++ j){
			y[j] = (y[j-1] + qp(j, n-r[i]) * qp(u[i]-j, r[i]-1)) % P;
		}
		t[i] = lglr(u[i]);
		for(int j = 0; j <= n-1; ++ j){
			for(int k = 0; k <= min(n-j-1, r[i]-1); ++ k){
				f[i][j] = (f[i][j] + f[i-1][j+k] * C[j+k][k] % P * C[n-1-j-k][r[i]-1-k] % P * t[i] % P) % P;
			}
		}
	}
	printf("%lld\n", f[m][k]);
	return 0;
}
```

---

## 作者：ppip (赞：8)

以下 $n$ 均为输入的 $n$ 减去 $1$，即排除 B 神。

同时我们定义 $r_i$ 为排在 B 神前的同学个数，即 $R_i-1$。

先将题目分解为两部分：求 $f_k$ 表示 $m$ 个集合，每个从 $n$ 同学中随机选择 $r_i-1$ 个，求并集大小为 $k$ 的方案数；以及对于每个题目，求 $\sum_{i=1}^{U_i} (u-i)^{r_i}i^{n-r_i}$。答案为这两部分所有数值乘起来。

第二部分求出该前缀和的前 $n-2$ 项然后使用连续值的拉格朗日插值做到 $O(mn\log n)$，$\log n$ 是因为需要计算快速幂。

前半部分，我们考虑求出所有的 $f$ 值。

我们修改 $f_k$ 的含义为集合正好为一个指定的大小为 $k$ 的集合，这样最终乘上 $\binom{n}{k}$ 即可。

设 $g_k$ 为最终答案为指定的一个大小为 $k$ 的集合的子集的方案数。显然有 $g_i=\sum_{j=0}^i \binom{i}{j} f_j$，使用二项式反演即可得到 $f_i=\sum_{j=0}^{i}\binom ij(-1)^{i-j}g_j$。所以我们求出 $g$ 即可通过卷积求出 $f$。

根据定义，$g_i=\prod_j\binom i{r_j}=\frac{i!^n}{\prod_jr_j!(i-r_j)!}$。显然只有 $\prod_j(i-r_j)!$ 是困难的。考虑如何算这个。

有两种方法：

1. 记其为 $h_i$，不难发现 $\frac{h_i}{h_{i-1}}=\prod_j(i-r_j)$，也就是说对于每个 $i$ 我们能算出右边这堆东西就能递推出 $h_i$。可以使用分治 NTT 求出右边这个多项式，然后多点求值，把所有 $i$ 带进去就能算出右边的所有值了。复杂度 $O(n\log ^2n)$。
2. 考虑取模数的一个原根 $g$，可以认为我们要求 $\sum_{j}\log_g((i-r_j)!)$，这个我们可以求出 $O(n)$ 范围内的 $\log_g(x!)$，然后答案为 $[x^i](\sum_{j}x^{r_j})(\sum_{k=0}^n x^k\log_g(k!))$，可以通过一次卷积求得。$\log_g(k!)$ 则可以使用 BSGS 算出每个质数的对数，再进行欧拉筛求出 $\log_g(k)$，再进行一次前缀和得出。复杂度 $O(\sqrt{\frac{np}{\ln n}}+n\log n)$，本题 $p=10^9+7$。

多点求值和卷积均可支持任意模数，但是做法二需求模数 $p$ 有原根。

此部分复杂度不在瓶颈，总复杂度为 $O(mn\log n)$。

以下代码为做法二。

**警告：该代码为多人共同完成，包含大量可能引人不适的内容，请谨慎阅读。**

```cpp
#include<bits/stdc++.h>
#include<complex>
#define ll long long
#define vi vector<int>
#define pb push_back
#define pii pair<int,int>
#define pb push_back
#define mp make_pair
#define S second
#define GREAT_MOD 1000000007
#define GREAT_PHI GREAT_MOD-1
using namespace std;
#define int long long
#define mod GREAT_MOD
int qpow(int b, int e) {
    return e ? e & 1 ? qpow(b * b % mod, e >> 1) * b % mod : qpow(b * b % mod, e >> 1) : 1;
}
namespace IntrepidDuck {

#define mod GREAT_MOD
constexpr int G=5; // baka
constexpr int GREAT_BLOCK_SIZE_1=10000,GREAT_BLOCK_SIZE_2=100001;
int A[GREAT_BLOCK_SIZE_1+5], iA[GREAT_BLOCK_SIZE_1+5], B[GREAT_BLOCK_SIZE_2+5], mark[101], LN[101];

unordered_map<int, int> M;

int qpow(int b, int e) {
    return e ? e & 1 ? qpow(b * b % mod, e >> 1) * b % mod : qpow(b * b % mod, e >> 1) : 1;
}

int EXP(int x) {
    return qpow(G, x);
}

int ln(int x) {
    return LN[x];
}
void init() {
    A[0] = iA[0] = B[0] = 1;
	int awa=qpow(G,mod-2);
    for (int i = 1; i <= GREAT_BLOCK_SIZE_1; i++) {
        A[i] = A[i - 1] * G % mod;
        iA[i] = iA[i - 1] * awa % mod;
    }
    for (int i = 1; i < GREAT_BLOCK_SIZE_2; i++) {
        B[i] = B[i - 1] * A[GREAT_BLOCK_SIZE_1] % mod;
        M[B[i]] = i;
    }
    vector<int> V;
    for (int i = 2; i <= 100; i++) {
        if (!mark[i]) {
            V.push_back(i);
            for (int j = 0; j < GREAT_BLOCK_SIZE_1; j++) {
                if (M.count(i * iA[j] % mod)) {
					LN[i] = (M[i * iA[j] % mod] * GREAT_BLOCK_SIZE_1 + j) % (mod - 1);
                    break;
                }
            }
        }
        for (auto j : V) {
            if (i * j > 100) {
                break;
            }
            mark[i * j] = 1;
            LN[i * j] = (LN[i] + LN[j]) % (mod - 1);
            if (i % j == 0) {
                break;
            }
        }
    }
}
#undef mod
}
// baka code starts
using IntrepidDuck::init;
using IntrepidDuck::ln;
using IntrepidDuck::EXP;

const int N=1029;int MOD;
int r[N];ll A[N],B[N],C[N],D[N],E[N],F[N];
struct Poly{
    int f[N],g[N],p,P;ll mod;
    ll ksm(ll x,ll y){
        if(!y)return 1;
        ll res=ksm(x,y/2);
        res=res*res%mod;
        if(y&1)res=res*x%mod;
        return res;
    }
    void NTT(int *a,int n,int op){
        for(int i=0;i<n;i++)
            if(i<r[i])swap(a[i],a[r[i]]);
        for(int len=1;len<n;len*=2)
        {
            int w=ksm(op==1?p:P,(mod-1)/2/len);
            for(int i=0;i<n;i+=len*2)
            {
                int W=1;
                for(int j=i;j<i+len;j++,W=1ll*W*w%mod)
                {
                    int tp=1ll*W*a[j+len]%mod;
                    a[j+len]=(a[j]-tp+mod)%mod;
                    a[j]=(a[j]+tp)%mod;
                }
            }
        }
    }void solve(int n)
    {
        p=3;P=ksm(3,mod-2);
        NTT(f,n,1);NTT(g,n,1);//cerr<<n<<"?\n";
        for(int i=0;i<n;i++)f[i]=1ll*f[i]*g[i]%mod;
		NTT(f,n,-1);
        for(int i=0;i<n;i++)f[i]=1ll*f[i]*ksm(n,mod-2)%mod;
    }
}mul[3];
ll ksm(ll x,ll y){
    if(!y)return 1;
    ll res=ksm(x,y/2);
    res=res*res%MOD;
    if(y&1)res=res*x%MOD;
    return res;
}
void NAOTAN(int n,int m,int _MOD=GREAT_PHI)
{
    MOD=_MOD;
    for(int i=0;i<=n;i++)for(int j=0;j<3;j++)mul[j].f[i]=A[i];
    for(int i=0;i<=m;i++)for(int j=0;j<3;j++)mul[j].g[i]=B[i];
    for(m+=n,n=1;n<=m;n*=2);
    for(int i=0;i<n;i++)r[i]=(r[i>>1]>>1)+n/2*(i%2);
    mul[0].mod=998244353;
    mul[1].mod=1004535809;
    mul[2].mod=469762049;
    for(int i=0;i<3;i++)mul[i].solve(n);
    for(int i=0;i<=m;i++)
    {
        ll ans=0,X1=mul[0].f[i],x2=mul[1].f[i],x3=mul[2].f[i];
        ll k1=(x2-X1+mul[1].mod)*mul[1].ksm(mul[0].mod,mul[1].mod-2)%mul[1].mod;ll x4=X1+k1*mul[0].mod;
        ll k4=(x3-x4%mul[2].mod+mul[2].mod)%mul[2].mod*mul[2].ksm(mul[0].mod*mul[1].mod%mul[2].mod,mul[2].mod-2)%mul[2].mod;
        ans=x4%MOD+k4%MOD*mul[0].mod%MOD*mul[1].mod%MOD;ans%=MOD;
        C[i]=ans;
    }return;
}
void NAOTANT(int n,int m,int _MOD=GREAT_MOD)
{
    MOD=_MOD;
    for(int i=0;i<=n;i++)for(int j=0;j<3;j++)mul[j].f[i]=D[i];
    for(int i=0;i<=m;i++)for(int j=0;j<3;j++)mul[j].g[i]=E[i];
    for(m+=n,n=1;n<=m;n*=2);
    for(int i=0;i<n;i++)r[i]=(r[i>>1]>>1)+n/2*(i%2);
    mul[0].mod=998244353;
    mul[1].mod=1004535809;
    mul[2].mod=469762049;
    for(int i=0;i<3;i++)mul[i].solve(n);
    for(int i=0;i<=m;i++)
    {
        ll ans=0,X1=mul[0].f[i],x2=mul[1].f[i],x3=mul[2].f[i];
        ll k1=(x2-X1+mul[1].mod)*mul[1].ksm(mul[0].mod,mul[1].mod-2)%mul[1].mod;ll x4=X1+k1*mul[0].mod;
        ll k4=(x3-x4%mul[2].mod+mul[2].mod)%mul[2].mod*mul[2].ksm(mul[0].mod*mul[1].mod%mul[2].mod,mul[2].mod-2)%mul[2].mod;
        ans=x4%MOD+k4%MOD*mul[0].mod%MOD*mul[1].mod%MOD;ans%=MOD;
        F[i]=ans;
    }return;
}
int cnt[N];ll fac[N];const int mod=GREAT_MOD;
inline ll niyuan(ll x){return qpow(x,mod-2);}
int U[N+5],R[N+5];
int mian(int m,int n,int k)
{
    init();fac[0]=1;
    for(int i=1;i<=N-5;i++)fac[i]=fac[i-1]*i%mod;
    int mx=0, res=1;
	for(int i=0;i<=m;i++)cnt[i]=0;
	for(int i=1;i<=n;i++){int x;x=R[i]-1;cnt[x]++;mx=max(mx,x);res=res*fac[x]%mod;}
	A[0] = 0;
	B[0] = cnt[0];
	for (int i = 1; i <= m; i++) {
		A[i] = (ln(i) + A[i - 1]) % (mod - 1);
		B[i] = cnt[i];
	}
	NAOTAN(m*2,m*2);
	for(int i=0;i<=m;i++)
		if(i<mx)D[i]=0;
		else D[i] = qpow(fac[i],n)*niyuan(EXP(C[i])) % mod;
	for (int i = 0; i <= m; i++) {
		D[i] = D[i] * niyuan(fac[i]) % mod;
	}
	for(int i=0;i<=m;i++)
		E[i]=(mod+(i%2==0?1:mod-1)*niyuan(fac[i]))%mod;
	mul[0] = mul[1] = mul[2] = {};
	NAOTANT(m*2,m*2);
	return k<mx?0:F[k]*fac[m]%mod*qpow(fac[m-k]*res%mod,mod-2)%mod;
}
#undef int
// baka code ends
namespace qwq {
constexpr int Spp{1<<20};
char buf[Spp],*p1,*p2;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,Spp,stdin),p1==p2)?EOF:*p1++)
template <typename T>
void read(T &x) {
	char c;int f{1};
	do x=(c=getchar())^48;
	while (!isdigit(c)&&c!='-');
	if (x==29) f=-1,x=0;
	while (isdigit(c=getchar()))
		x=(x*10)+(c^48);
	x*=f;
}
template <typename T,typename ...Args>
void read(T& x,Args&... args) {read(x);read(args...);}
constexpr int b6e0(GREAT_MOD);
int n,m,k;
int y[N+5],G[N+5],F[N+5];
int calc(int u,int r) {
    int ans{0};
    for (int i{1};i<=min(u,n+2);++i) {
        ans=(ans+1LL*qpow(u-i,r-1)*qpow(i,n-r+1))%b6e0;
        y[i]=ans;
    }
    if (u<=n+2) return y[u];
    ans=0;
    for (int i{1};i<=n+2;++i)
        ans=(ans+1LL*qpow(-1,n+2-i)*y[i]%b6e0*qpow(u-i,b6e0-2)%b6e0*G[i-1]%b6e0*G[n+2-i])%b6e0;
    for (int j{1};j<=n+2;++j) ans=1LL*ans*(u-j)%b6e0;
    return ans;
}
int main() {
	read(n,m,k);
	F[0]=1;
    for (int i{1};i<=n;++i) F[i]=1LL*F[i-1]*i%b6e0;
    G[n]=qpow(F[n],b6e0-2);
    for (int i{n};i>=1;--i) G[i-1]=1LL*G[i]*i%b6e0;
	for (int i{1};i<=m;++i) {
		read(U[i]);
	}
	for (int i{1};i<=m;++i) {
		read(R[i]);
	}
	--n;
	int ans(mian(n,m,n-k));
	cerr<<ans<<endl;
	for (int i{1};i<=m;++i) ans=1LL*ans*calc(U[i],R[i])%b6e0;
	cout<<(ans+b6e0)%b6e0<<endl;
	return 0;
}
}
int main() {return qwq::main();}
```

---

## 作者：foreverlasting (赞：8)

[题面](https://www.luogu.org/problemnew/show/P3270)

拉格朗日插值。

按照套路，先推出$dp$式。$f[i][j]$表示前$i$门课有$j$个人被碾压的方案数。然后使转移方程：$f[i][j]=\sum_{l=1}^{n-1} (f[i-1][l]*C(k,k-j)*C(n-k-1,r[i]-1-(k-j))*\sum_{p=1}^{u[i]} (p^{n-r[i]}*(u[i]-p)^{r[i]-1}))$

分析一下这条式子怎么处理。

第一个$sigma$直接枚举了，组合数$C$直接预处理掉，$O(1)$询问。第二个$sigma$中，显然是一条最高次不超过$n$关于$p$的多项式，而$u[i]$太大，直接插值就可以了。

总复杂度$O(n^2*m)$

code:
```
//2018.10.14 by ljz
#include<bits/stdc++.h>
using namespace std;
#define res register int
#define LL long long
#define inf 0x3f3f3f3f
#define eps 1e-15
inline int read(){
    res s=0;
    bool w=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return w?-s:s;
}
inline void _swap(res &x,res &y){
    x^=y^=x^=y;
}
inline int _abs(const res &x){
    return x>0?x:-x;
}
inline int _max(const res &x,const res &y){
    return x>y?x:y;
}
inline int _min(const res &x,const res &y){
    return x<y?x:y;
}
const int kcz=1e9+7;
const int N=1e3+10;
namespace MAIN{
    int C[N][N];
    inline void pre(){
        C[0][0]=1;
        for(res i=1;i<=N-10;i++){
            C[i][0]=1;
            for(res j=1;j<=i;j++)C[i][j]=(1LL*C[i-1][j-1]+C[i-1][j])%kcz;
        }
    }
    int n,m,k;
    inline int qpow(res x,res y){
        res ret=1;
        while(y){
            if(y&1)ret=1LL*ret*x%kcz;
            y>>=1,x=1LL*x*x%kcz;
        }
        return ret%kcz;
    }
    inline void add(res &x,const res &y){
        x+=y;
        x>=kcz?x-=kcz:1;
        x<0?x+=kcz:1;
    }
    int dp[N];
    int u[N],r[N];
    inline void DP(const res &r,const res &u){
        for(res i=1;i<=n;i++){
            dp[i]=0;
            for(res j=1;j<=i;j++)add(dp[i],1LL*qpow(j,n-r)*qpow(u-j,r-1)%kcz);
        }
    }
    inline int calc(const res &x,const res &n){
        if(x<=n)return dp[x];
        res tmp=1,ret=0,p=(n&1)?kcz-1:1;
        for(res i=1;i<=n;i++)tmp=1LL*tmp*(x-i)%kcz*qpow(i,kcz-2)%kcz;
        for(res i=0;i<=n;i++,p=kcz-p)
            add(ret,1LL*p*dp[i]%kcz*tmp%kcz),tmp=1LL*tmp*(x-i)%kcz*qpow(x-i-1,kcz-2)%kcz*(n-i)%kcz*qpow(i+1,kcz-2)%kcz;
        return ret;
    }
    int f[N][N];
    inline void MAIN(){
        pre();
        n=read(),m=read(),k=read();
        for(res i=1;i<=m;i++)u[i]=read();
        for(res i=1;i<=m;i++)r[i]=read();
        f[0][n-1]=1;
        for(res i=1;i<=m;i++){
            DP(r[i],u[i]);
            res d=calc(u[i],n);
            for(res j=k;j<=n-1;j++)
                for(res l=j;l<=n-1;l++){
                    if(r[i]-1<l-j)break;
                    add(f[i][j],1LL*f[i-1][l]*C[l][l-j]%kcz*C[n-l-1][r[i]-1-(l-j)]%kcz*d%kcz);
                }
        }
        printf("%d\n",f[m][k]);
    }
}
int main(){
    MAIN::MAIN();
    return 0;
}
```

---

## 作者：cyffff (赞：6)

[$\text{Link}$](https://www.luogu.com.cn/problem/P3270)

本文参考神仙 [$\color{black}\texttt{R}\color{red}\texttt{edpojoe}$](https://www.luogu.com.cn/user/98939) 的题解。
## 题意
有 $n$ 名学生，$m$ 名课程，一位同学在第 $i$ 门课程中可被评为 $[1,u_i]$ 范围内的分数。其中有一位同学，在第 $i$ 门课程中排名 $r_i$，其余 $n-1$ 名同学中有 $k$ 名每门的分数都不高于这位同学。

求方案数，对 $10^9+7$ 取模。

$1\le n,m\le100,1\le u_i\le10^9$
## 思路
首先我们将问题用乘法原理划分：

- 从 $n-1$ 个同学中选出 $k$ 个同学被 B 神碾压的方案数；
- 剩余 $n-k-1$ 个同学在课程中与 B 神成绩的大小关系的方案数；
- 每科中每名同学具体成绩方案数。

### 第一部分
答案显然为 $\displaystyle\binom{n-1}{k}$。
### 第二部分
我们仍可以使用乘法原理将问题分解为单科的子问题，第 $i$ 科中，比 B 神高的只有 $r_i-1$ 名，则方案数为 $\displaystyle\binom{n-k-1}{r_i-1}$。

但是我们求出的只是有不超过 $k$ 人被碾压，因为我们需要保证 $n-k-1$ 个人都被选中了至少一次，我们设
$$f_i=\prod_{j=1}^m\binom{n-i-1}{r_j-1}$$
即不超过 $k$ 人被碾压时的方案数，容斥后得到答案为
$$\sum_{i=1}^{n-k-1}(-1)^{i+1}f_{n-k-i}\binom{n-k-1}{i-1}$$
#### 第三部分
拆分为单科后设 $G(u,a,b)$ 表示分数上限为 $u$，有 $a$ 人比 B 神高，$b$ 人不比 B 神高的方案数，显然：
$$G_{u,a,b}=\sum_{i=0}^{u-1}i^a(u-i)^b$$

直接暴力求则会得到一个 $O(n^2+nm+mv\log n)$ 的暴力（$v=\max\{u_i\}$），无法通过。

接下来可以通过二项式定理展开+拉格朗日插值求自然数 $k$ 次幂和的方法解决，不过我们这里使用神仙 [$\color{black}\texttt{R}\color{red}\texttt{edpojoe}$](https://www.luogu.com.cn/user/98939) 的做法：枚举 $n$ 人有 $i$ 种得分的方案数，设为 $d_i$，算出每类的方案数之和即可。

可以得出，$n$ 人有不超过 $i$ 种得分的方案数为
$$\binom{u}{i}G_{i,a,b}$$
为了得出 $d_i$，我们考虑容斥，易得
$$d_i=\binom{u}{i}\left(G_{i,a,b}-\sum_{j=1}^{i-1}d_j\binom{i}{j}\right)$$
设 $\displaystyle G'_{u,a,b}=\sum_{i=1}^nd_i=\sum_{i=1}^n\binom{u}{i}\left(G_{i,a,b}-\sum_{j=1}^{i-1}d_j\binom{i}{j}\right)$，这部分的答案即为
$$\prod_{i=1}^nG'_{u_i,r_i-1,n-r_i}$$

则最终答案为三部分乘在一起。

$O(n^2)$ 预处理组合数和 $i^j$（$1\le i,j\le n$），则三部分复杂度分别为 $O(1),O(nm),O(n^2m)$，总时间复杂度为 $O(n^2m)$，且此方法码量较少。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
	
}
const int N=100+10,mod=1e9+7;
int n,m,k,u[N],r[N];
int C[N][N],pw[N][N],inv[N];
inline int qpow(int x,int y){
	int res=1;
	while(y){
		if(y&1) res=1ll*res*x%mod;
		x=1ll*x*x%mod;
		y>>=1;
	}
	return res;
}
inline void Prefix(int n){
	inv[1]=1;
	for(int i=2;i<=n;i++)
		inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
	for(int i=0;i<=n;i++){
		C[i][0]=C[i][i]=1;
		for(int j=1;j<i;j++)
			C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;
	}
	for(int i=0;i<=n;i++){
		pw[i][0]=1;
		for(int j=1;j<=n;j++)
			pw[i][j]=1ll*pw[i][j-1]*i%mod;
	}
}
inline int Type1(){
	return C[n-1][k];
}
inline int F(int n){
	int ans=1;
	for(int i=1;i<=m;i++)
		ans=1ll*ans*C[n][r[i]-1]%mod;
	return ans;
}
inline int Type2(){
	int t=n-k-1;
	int ans=0;
	for(int i=0;i<t;i++){
		int tmp=1ll*F(t-i)*C[t][i]%mod;
		ans=(ans+(i&1?mod-tmp:tmp))%mod;
	}
	return ans;
}
int D[N];
inline int G(int n,int a,int b){
	int ans=0;
	for(int i=0;i<n;i++)
		ans=(ans+1ll*pw[i][a]*pw[n-i][b])%mod;
	return ans;
}
inline int Gpi(int u,int a,int b){
	int ans=0,tmp=1;
	for(int i=1;i<=n;i++){
		D[i]=G(i,a,b);
		for(int j=1;j<i;j++)
			D[i]=(D[i]+mod-1ll*D[j]*C[i][j]%mod)%mod;
		tmp=1ll*tmp*(u-i+1)%mod*inv[i]%mod;
		ans=(ans+1ll*tmp*D[i])%mod;
	}
	return ans;
}
inline int Type3(){
	int ans=1;
	for(int i=1;i<=m;i++)
		ans=1ll*ans*Gpi(u[i],r[i]-1,n-r[i])%mod;
	return ans;
}
int main(){
	Prefix(N-10);
	n=read(),m=read(),k=read();
	for(int i=1;i<=m;i++)
		u[i]=read();
	for(int i=1;i<=m;i++)
		r[i]=read();
	write(1ll*Type1()*Type2()%mod*Type3()%mod);
	flush();
}
```
再见 qwq~

---

## 作者：ComeIntoCalm (赞：5)

题意：https://www.lydsy.com/JudgeOnline/problem.php?id=4559

Sol：

因为Markdown挂掉了，所以这里丢一下blog



~~第一眼看起来就是个稍微麻烦的组合数~~

但是发现如果钦点哪些同学分数在某科目上分数比B神低以后的方案，就会出现没有被钦

点碾压的同学也会被碾压，（后面钦点分数时可能钦点的一直是同一批人导致人数不够不被碾压的人数）

于是可以考虑容斥，用至少$i$个人的方案算出恰好$k$个人的方案。

可以得到

因为被碾压的不能超过B君最大的一个排名，所以定义$up=min\{n-R_i\}$

$$\sum_{i=k}^{up} {(-1)^{i-k} \binom{i}{k} \binom{n-1}{i} \prod_{j=1}^{m}\binom{n-i-1}{R_j-1} \sum_{x=1}^{U_j} (U_j-x)^{R_j-1} x^{n-R_j}}$$

发现后边枚举分数的$\sum$实际上是在对关于$U_j$的多项式做前缀和，因此是个$n$次多项式，拉格朗日插值即可，因为x是自己取，所以可以做线性插值，复杂度$n^2$

```cpp
#include<cctype>
#include<cmath>
#include<cstdio>
const int N = 1e2+9;
typedef long long LL;
const int upmax = 1e2+5;
#define p 1000000007
#define debug printf("GG\n")
inline int min(int a, int b) {return a > b ? b : a;}
inline LL FST(LL b, LL k) {
  if (!b && k > 0) return 0;
  LL ans = 1LL;
  while (k) {
    if (k & 1) ans = ans * b % p; b = b * b % p, k >>= 1;
  } return ans;
}
int n, m, k, rk[N]; LL U[N];
LL lagr(LL *ax, LL *ay, int up, LL x) {
  LL res = 0;
  for (int i = 1; i <= up; i++) {
    LL s1 = 1, s2 = 1;
    for (int j = 1; j <= up; j++) {
      if (i == j) continue;
      s1 = (LL)(s1 * ((x - ax[j]) % p + p) % p) % p;
      s2 = (LL)(s2 * ((ax[i] - ax[j]) % p + p)) % p;
    } res = (res + (LL)(s1 * FST(s2, p - 2)) % p * ay[i] % p) % p;
  } return res;
} LL tx[N], ty[N], poly[N]; LL inv[N], fac[N];
inline LL C(int n, int m) {
  return fac[n] * inv[n - m] % p * inv[m] % p;
}int up;
void init() {
  scanf("%d%d%d", &n, &m, &k);
  inv[1] = 1LL, fac[1] = 1LL, fac[0] = inv[0] = 1LL;
  for (int i = 2; i <= upmax; i++) inv[i] = inv[i - 1] * FST(i, p - 2) % p;
  for (int i = 2; i <= upmax; i++) fac[i] = fac[i - 1] * (LL)i % p;
  for (int i = 1; i <= m; i++) scanf("%lld", &U[i]);
  for (int i = 1; i <= m; i++) scanf("%d", &rk[i]);
  for (int i = 1; i <= m; i++) {
    int R = rk[i]; 
    for (int j = 1; j <= n + 1; j++) {
      tx[j] = j, ty[j] = 0;
      for (int x = 1; x <= j; x++) 
        ty[j] = (ty[j] + FST(j - x, R - 1) * FST(x, n - R) % p) % p;
    } poly[i] = lagr(tx, ty, n + 1, U[i]);
  }
  up = n;
  for (int i = 1; i <= m; i++) up = min(up, n - rk[i]);
} 
void solve() {
  LL ans = 0; 
  for (int i = k; i <= up; i++) {
    LL res = ((i - k) & 1 ? -1 : 1) * C(i, k) % p * C(n - 1, i) % p;
    for (int j = 1; j <= m; j++) 
      res = res * poly[j] % p * C(n - i - 1, rk[j] - 1) % p;
    ans = (ans + res) % p;
  } printf ("%lld\n", (ans % p + p) % p);
} 
void debugR() {
  LL ans = 0;
  for (int i = k; i <= up; i++) {
    LL res = ((i - k) & 1 ? -1 : 1) * C(n - 1, i) % p * C(i, k) % p;
    res = (res % p + p) % p;
    for (int j = 1; j <= m; j++) {
      LL res2 = 0;
      for (int og = 1; og <= U[j]; og++) {
        res2 = (res2 + FST(U[j] - og, rk[j] - 1) * FST(og, n - rk[j]) % p) % p;
      }
      res = res2 * res % p * C(n - 1 - i, n - rk[j] - i) % p;
    } ans = (ans + res) % p;
  } printf("%lld\n",(ans % p + p) % p);
}
int main() {
  init(), solve();
 // debugR();
}
```


---

## 作者：xyz32768 (赞：5)

由容斥原理得：

$$ans=\sum_{i=K}^{\min\{N-1-R\}}(-1)^{i-K}C_i^KC_{N-1}^i\prod_{j=1}^MC_{N-1-i}^{N-R_j-i}\sum_{x=1}^{U_i}x^{N-R_j}(U_j-x)^{R_j-1}$$

这么长的式子，一项一项地进行解析：

（1） $\sum_{i=K}^{\min\{N-1-R\}}(-1)^{i-K}C_i^K$ ：求「恰好完虐 $K$ 个同学」时乘上容斥系数。

（2） $C_{N-1}^i$ ：在 $N-1$ 个同学中选出 $i$ 个同学被完虐。

（3） $\prod_{j=1}^M$ ：把每一科分开处理之后相乘。

（4） $C_{N-1-i}^{N-R_j-i}$ ：在没有被完虐的 $N-1-i$ 个同学中，选出 $N-R_j-i$ 个同学，让他们第 $j$ 课被虐。

（5） $\sum_{x=1}^{U_i}$ ：枚举 B 神第 $j$ 科成绩。

（6） $x^{N-R_j}$ ：第 $j$ 科被虐的同学的成绩方案数。

（7） $(U_j-x)^{R_j-1}$ ：第 $j$ 科没有被虐的同学的方案数。

显然，我们要处理的关键在于 $\sum_{x=1}^{U_i}$ 及之后的式子。

发现 $(U_j-x)^{R_j-1}$ 不好处理。

考虑无脑展开：

$$\sum_{x=1}^{U_i}x^{N-R_j}\sum_{k=0}^{R_j-1}(-1)^kx^kU_j^{R_j-1-k}$$

$$=\sum_{k=0}^{R_j-1}(-1)^kU_j^{R_j-1-k}\sum_{x=1}^{U_i}x^{N-R_j+k}$$

注意到 $\sum_{x=1}^{U_i}x^{N-R_j+k}$ 是以 $x$ 为自变量的 $N-R_j+k+1$ 次多项式，上拉格朗日插值法即可求得。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define For(i, a, b) for (i = a; i <= b; i++)
#define Rof(i, a, b) for (i = a; i >= b; i--)
using namespace std;
inline int read() {
	int res = 0; bool bo = 0; char c;
	while (((c = getchar()) < '0' || c > '9') && c != '-');
	if (c == '-') bo = 1; else res = c - 48;
	while ((c = getchar()) >= '0' && c <= '9')
		res = (res << 3) + (res << 1) + (c - 48);
	return bo ? ~res + 1 : res;
}
const int N = 111, ZZQ = 1e9 + 7;
int pwe[N][N], y[N], qaq[N], tmp[N], rps[N], inv[N], com[N][N],
C[N][N], n, m, K, U[N], R[N], ans, czk[N];
int qpow(int a, int b) {
	int res = 1;
	while (b) {
		if (b & 1) res = 1ll * res * a % ZZQ;
		a = 1ll * a * a % ZZQ;
		b >>= 1;
	}
	return res;
}
void lagrange(int n) {
	int i, j;
	For (i, 1, n + 2)
		y[i] = (y[i - 1] + pwe[i][n]) % ZZQ;
	qaq[0] = 1;
	For (i, 1, n + 2) {
		tmp[0] = qaq[i] = 0;
		For (j, 0, i - 1) tmp[j + 1] = qaq[j];
		For (j, 0, i)
			qaq[j] = (tmp[j] - 1ll * qaq[j] * i % ZZQ + ZZQ) % ZZQ;
	}
	For (i, 1, n + 2) {
		For (j, 0, n + 2) tmp[j] = qaq[j];
		Rof (j, n + 1, 0) rps[j] = tmp[j + 1],
			tmp[j] = (tmp[j] + 1ll * tmp[j + 1] * i % ZZQ) % ZZQ;
		int sp = 1;
		For (j, 1, i - 1) sp = 1ll * sp * inv[j] % ZZQ;
		For (j, 1, n - i + 2)
			sp = 1ll * sp * (ZZQ - inv[j]) % ZZQ;
		For (j, 0, n + 1)
			com[n][j] = (com[n][j] + 1ll * y[i] *
			rps[j] % ZZQ * sp % ZZQ) % ZZQ;
	}
}
void init() {
	int i, j; inv[1] = 1;
	For (i, 2, 101) inv[i] = 1ll * (ZZQ - ZZQ / i) * inv[ZZQ % i] % ZZQ;
	For (i, 0, 102) {
		pwe[i][0] = 1;
		For (j, 1, 100) pwe[i][j] = 1ll * pwe[i][j - 1] * i % ZZQ;
	}
	For (i, 0, 100) lagrange(i);
	For (i, 0, 100) C[i][0] = 1;
	For (i, 1, 100) For (j, 1, i)
		C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % ZZQ;
}
int getval(int n, int k) {
	int i, x = 1, res = 0;
	For (i, 0, k + 1) res = (res + 1ll * com[k][i] * x % ZZQ) % ZZQ,
		x = 1ll * x * n % ZZQ;
	return res;
}
int main() {
	int i, j, k, dalao;
	init();
	dalao = n = read(); m = read(); K = read();
	For (i, 1, m) U[i] = read();
	For (i, 1, m) R[i] = read();
	For (i, 1, m) dalao = min(dalao, n - R[i]);
	For (j, 1, m) For (k, 0, R[j] - 1) {
		int miu = k & 1 ? ZZQ - 1 : 1, delta;
		delta = 1ll * C[R[j] - 1][k] *
			qpow(U[j], R[j] - 1 - k) % ZZQ
			* getval(U[j], n + k - R[j]) % ZZQ;
		czk[j] = (czk[j] + 1ll * miu * delta % ZZQ) % ZZQ;
	}
	For (i, K, dalao) {
		int miu = i - K & 1 ? ZZQ - 1 : 1,
			delta = 1ll * C[n - 1][i] * C[i][K] % ZZQ, pyz = 1;
		For (j, 1, m)
			pyz = 1ll * pyz * C[n - 1 - i][n - R[j] - i] % ZZQ,
			pyz = 1ll * pyz * czk[j] % ZZQ;
		ans = (ans + 1ll * miu * delta % ZZQ * pyz % ZZQ) % ZZQ;
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Colletto (赞：4)

这边给出一个几乎不用思考的用第二类斯特林数推的做法，

对我这种对容斥原理不熟悉的萌新比较友好（虽然第二类斯特林数本质上就是容斥）。

## 一、题意 略去

## 二、递推方程

看到这种各门课程相对独立且数据范围不大的时候，如果不是网络流的话，可以考虑多维 dp 。

那么这道题我们可以假设 $f_{i,j}$ 表示考虑完前 $i$ 门课程的得分情况，当前仍然有 $j$ 个同学被碾压的方案数 $\mod 10^9+7$ 的结果。

可以发现：随着课程数量的增加，被碾压的同学单调不升。

所以可以得到：$f_{0,n-1} = 1$，答案为 $f_{m,k}$ 。

转移方程： 

$$f_{i+1,j} = \sum_{k=j}^{k=n-1}S \cdot f_{i, k}$$ 

其中 $S$ 是一个需要求的转移系数。

## 三、求 $S$ 

为了书写简洁，记 $u = U_{i+1}, r = R_{i + 1}$ 。

下面是求 $f_{i, j}$ 对 $f_{i+1, j-k}$ 贡献的转移系数的过程。 $k$ 即为原先被 B 神碾压，而在这门课上得分高于 B 神的同学数量，在合理范围内。

先在外层枚举 B 神的得分 $t$ ，再考虑选出在这门课上比 B 神厉害的人，最后枚举所有人的得分： 

$$
\sum_{t=0}^{u}
\begin{pmatrix}
j\\k
\end{pmatrix}\begin{pmatrix}
n-1-j\\r-1-k
\end{pmatrix}
(u-t)^{r-1}t^{n-r}
$$

组合数是常数，扔到求和记号外面，再把普通幂用第二类斯特林数转化成下降幂：

$$
=\begin{pmatrix}
j\\k
\end{pmatrix}\begin{pmatrix}
n-1-j\\r-1-k
\end{pmatrix}
\sum_{t=0}^{u}
\sum_{x=0}^{r-1}
\sum_{y=0}^{n-r}\begin{Bmatrix}r-1\\x\end{Bmatrix}(u-t)^{\underline x}\begin{Bmatrix}n-r\\y\end{Bmatrix}t^{\underline y}
$$

$$
=\begin{pmatrix}
j\\k
\end{pmatrix}\begin{pmatrix}
n-1-j\\r-1-k
\end{pmatrix}
\sum_{t=0}^{u}
\sum_{x=0}^{r-1}
\sum_{y=0}^{n-r}\begin{Bmatrix}r-1\\x\end{Bmatrix}\begin{Bmatrix}n-r\\y\end{Bmatrix}x!y!
\begin{pmatrix}u-t\\x \end{pmatrix} \begin{pmatrix}t\\y\end{pmatrix}
$$

$$
=\begin{pmatrix}
j\\k
\end{pmatrix}\begin{pmatrix}
n-1-j\\r-1-k
\end{pmatrix}
\sum_{x=0}^{r-1}
\sum_{y=0}^{n-r}\begin{Bmatrix}r-1\\x\end{Bmatrix}\begin{Bmatrix}n-r\\y\end{Bmatrix}x!y!
\sum_{t=0}^{u}
\begin{pmatrix}u-t\\x \end{pmatrix} \begin{pmatrix}t\\y\end{pmatrix}
$$

考虑最后一个式子： 

$$\sum_{t=0}^{u}\begin{pmatrix}u-t\\x \end{pmatrix} \begin{pmatrix}t\\y\end{pmatrix}$$

的组合意义：在 $u$ 个球中间切一刀，然后两边分别选 $x,y$ 个球，于是我们可以在切的位置加一个球，切一刀即取走这个球，用一一映射的关系可以得到：

$$\sum_{t=0}^{u}\begin{pmatrix}u-t\\x \end{pmatrix} \begin{pmatrix}t\\y\end{pmatrix}=\begin{pmatrix}u+1\\x+y+1\end{pmatrix}$$

所以 

$$S=\begin{pmatrix}
j\\k
\end{pmatrix}\begin{pmatrix}
n-1-j\\r-1-k
\end{pmatrix}
\sum_{x=0}^{r-1}
\sum_{y=0}^{n-r}\begin{Bmatrix}r-1\\x\end{Bmatrix}\begin{Bmatrix}n-r\\y\end{Bmatrix}x!y!
\begin{pmatrix}u+1\\x+y+1\end{pmatrix}
$$

具体实现方法是：先把组合数和第二类斯特林数预处理出来，然后对于每一门课程我们只需要计算一次 $S$，转移时枚举 $i,j,k$ 即可 $O(1)$ 的转移，又计算 $S$ 的单次复杂度为 $O(n^2)$ ，所以全部的复杂度为 $O(n^2m)$ ，可以通过本题。

---

## 作者：james1BadCreeper (赞：2)


首先在 $n-1$ 名同学中钦定 $k$ 名同学被 B 神碾压。

需要钦定同学分数的具体情况，此时对于每一科可以分开考虑。

考虑 $G(u,a,b)$ 代表有 $u$ 种可选分数，$a$ 人比 B 神高，$b$ 人不比 B 神高，则：

$$
G(u,a,b)=\sum_{i=0}^u i^a (u-i)^b
$$

直接做会爆炸，考虑枚举有 $t$ 种得分，答案为 $d(t)$，根据容斥原理得：

$$
d(t)=\binom{u}{t}\left(G(t,a,b)-\sum_{i=1}^{t-1}d(i)\times \binom{t}{i}\right)
$$

然后需要分配这些分数给每一个人，这里考虑分配给不被 B 神碾压的比较方便，在 $n-1-k$ 个同学中，让 $r_i-1$ 个人第 $i$ 科分数比 B 君高，方案数为 $\dbinom{n-k-1}{r_i-1}$。但是不对！我们需要保证这些人都不能被 B 君碾压！设 $f_i$ 代表不超过 $i$ 个人被碾压的方案数，那么：

$$
f_i=\prod_{j=1}^{m} \binom{n-i-1}{r_j-1}
$$

容斥原理，得到答案：

$$
\sum_{i=0}^{n-k-1}(-1)^{n-k-1-i} f_i\binom{n-k-1}i
$$

将三个东西全部乘起来即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int P = 1000000007; 
const int N = 100; 

inline int poww(int a, int b) {
    int r = 1; 
    for (; b; b >>= 1, a = 1ll * a * a % P) if (b & 1) r = 1ll * r * a % P; 
    return r; 
}
inline void add(int &x, int t) { x += t; x -= x >= P ? P : 0; }
inline void del(int &x, int t) { x -= t; x += x < 0 ? P : 0; }

int n, m, k, u[105], r[105]; 
int fac[105], ifac[105], pw[105][105]; 
inline int C(int n, int m) { 
    if (n < m || n < 0 || m < 0) return 0; 
    return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P; 
}

inline int F(int i) {
    int res = 1; 
    for (int j = 1; j <= m; ++j) res = 1ll * res * C(i, r[j] - 1) % P; 
    return res; 
}
inline int calc1(void) {
    int ans = 0, t = n - k - 1; 
    for (int i = 0; i <= t; ++i) {
        int tmp = 1ll * F(i) * C(t, i) % P; 
        if (t - i & 1) add(ans, P - tmp); 
        else add(ans, tmp); 
    }
    return ans; 
}
inline int G(int u, int a, int b) { // a 比 B 神高，b 比 B 神低
    int res = 0; 
    for (int i = 0; i < u; ++i) add(res, 1ll * pw[i][a] * pw[u - i][b] % P); 
    return res; 
}
int d[105]; 
inline int g(int u, int a, int b) {
    int ans = 0, comb = 1; 
    // C(u, t) = u! / t! / (u-t)!
    for (int i = 1; i <= n; ++i) {
        d[i] = G(i, a, b); 
        for (int j = 1; j < i; ++j) del(d[i], 1ll * d[j] * C(i, j) % P); 
        comb = 1ll * comb * (u - i + 1) % P * poww(i, P - 2) % P; 
        add(ans, 1ll * comb * d[i] % P); 
    }
    return ans; 
}
inline int calc2(void) {
    int ans = 1; 
    for (int i = 1; i <= m; ++i) ans = 1ll * ans * g(u[i], r[i] - 1, n - r[i]) % P; 
    return ans; 
}

int main(void) {
    for (int i = fac[0] = 1; i <= N; ++i) fac[i] = 1ll * fac[i - 1] * i % P; 
    ifac[N] = poww(fac[N], P - 2); 
    for (int i = N - 1; i >= 0; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P; 
    for (int i = 0; i <= N; ++i) for (int j = pw[i][0] = 1; j <= N; ++j) pw[i][j] = 1ll * pw[i][j - 1] * i % P;

    scanf("%d%d%d", &n, &m, &k); 
    for (int i = 1; i <= m; ++i) scanf("%d", u + i); 
    for (int i = 1; i <= m; ++i) scanf("%d", r + i); 
    return !printf("%d\n", 1ll * C(n - 1, k) * calc1() % P * calc2() % P); 
}
```

---

## 作者：tzc_wk (赞：2)

[题面传送门](https://www.luogu.com.cn/problem/P3270)

考虑容斥。我们记 $a_i$ 为钦定 $i$ 个人被 B 神碾压的方案数，如果我们已经求出了 $a_i$ 那么一遍二项式反演即可求出答案，即 $ans=\sum\limits_{i=k}^{n-1}a_i(-1)^{i-k}\dbinom{i}{k}$，于是现在问题转化为怎样求 $a_i$。首先我们肯定要从另外 $n-1$ 个学生中选出这 $i$ 个，方案数 $\dbinom{n-1}{i}$，其次，根据“碾压”的定义，这 $i$ 个学生在任何一门学科中的分数都 $\le$ B 神的分数，也就是说对于任何一门学科 $j$，都有这 $i$ 个学生属于被 B 神吊打的 $n-r_j$ 个学生中，故对于每一门学科，被被 B 神吊打的 $n-r_j$ 个学生中有 $i$ 个学生是确定的，我们只需另从 $n-i-1$ 个学生中选出 $n-r_j-i$ 即可，方案数为 $\dbinom{n-i-1}{n-i-r_j}$，再其次，对每门学科我们要确定有多少种可能的分数，我们枚举 B 神的分数 $l$，那么对于被 B 神吊打的 $n-r_j$ 个学生，每个人都有 $l$ 种可能的分数，方案数 $l^{n-r_j}$，对于吊打 B 神的 $r_j-1$ 个学生，每个人都有 $u_j-l$ 种可能的分数，方案数 $(u_j-l)^{r_j-1}$，因此我们有：
$$
a_i=\dbinom{n-1}{i}\prod\limits_{j=1}^m\dbinom{n-i-1}{n-i-r_j}\sum\limits_{l=1}^{u_j}l^{n-r_j}(u_j-l)^{r_j-1}
$$
由于这题 $u_i$ 很大，直接算显然无法通过，不过注意到后面那坨东西 $\sum\limits_{l=1}^{u_j}l^{n-r_j}(u_j-l)^{r_j-1}$ 是与 $i$ 严格无关的，因此考虑将这东西预处理出来。怎么预处理呢，考虑将这东西用二项式定理展开变个形，具体来说：
$$
\begin{aligned}
&\sum\limits_{l=1}^{u_j}l^{n-r_j}(u_j-l)^{r_j-1}\\
=&\sum\limits_{l=1}^{u_j}l^{n-r_j}\sum\limits_{t=0}^{r_j-1}u_j^t(-l)^{r_j-1-t}\dbinom{r_i-1}{t}\\
=&\sum\limits_{t=0}^{r_j-1}u_j^t\dbinom{r_i-1}{t}\sum\limits_{l=1}^{u_j}l^{n-r_j}(-l)^{r_j-1-t}\\
=&\sum\limits_{t=0}^{r_j-1}u_j^t\dbinom{r_i-1}{t}(-1)^{r_i-1-t}\sum\limits_{l=1}^{u_j}l^{n-1-t}
\end{aligned}
$$
芜湖~好了，前面枚举复杂度显然不会爆，后面那东西是自然数 $k$ 次幂之和的形式，可以拉格朗日插值求出，于是复杂度就降到了 $n^2m$，可以通过此题。

```cpp
const int MAXN=100;
const int MOD=1e9+7;
int qpow(int x,int e){
	int ret=1;
	for(;e;e>>=1,x=1ll*x*x%MOD) if(e&1) ret=1ll*ret*x%MOD;
	return ret;
}
int n,m,k,u[MAXN+5],r[MAXN+5],s[MAXN+5],f[MAXN+5],fac[MAXN+5],ifac[MAXN+5];
void init_fac(int mx){
	for(int i=(fac[0]=ifac[0]=ifac[1]=1)+1;i<=mx;i++) ifac[i]=1ll*ifac[MOD%i]*(MOD-MOD/i)%MOD;
	for(int i=1;i<=mx;i++) fac[i]=1ll*fac[i-1]*i%MOD,ifac[i]=1ll*ifac[i-1]*ifac[i]%MOD;
}
int binom(int n,int k){
	if(n<0||k<0||n<k) return 0;
	return 1ll*fac[n]*ifac[k]%MOD*ifac[n-k]%MOD;
}
int sum[MAXN+5],pre[MAXN+5],suf[MAXN+5];
int calc(int n,int k){
	for(int i=1;i<=k+1;i++) sum[i]=(sum[i-1]+qpow(i,k))%MOD;
	pre[0]=n;for(int i=1;i<=k+1;i++) pre[i]=1ll*pre[i-1]*(n-i+MOD)%MOD;
	suf[k+2]=1;for(int i=k+1;~i;i--) suf[i]=1ll*suf[i+1]*(n-i+MOD)%MOD;
	int ans=0;
	for(int i=1;i<=k+1;i++){
		int mul=1ll*sum[i]*pre[i-1]%MOD*suf[i+1]%MOD*ifac[i]%MOD*ifac[k+1-i]%MOD;
		if((k+1-i)&1) ans=(ans-mul+MOD)%MOD;else ans=(ans+mul)%MOD;
	} return ans;
}
int main(){
	scanf("%d%d%d",&n,&m,&k);init_fac(n+1);
	for(int i=1;i<=m;i++) scanf("%d",&u[i]);
	for(int i=1;i<=m;i++) scanf("%d",&r[i]);
	for(int i=1;i<=m;i++) for(int l=0;l<r[i];l++){
		int mul=1ll*binom(r[i]-1,l)*qpow(u[i],l)%MOD*calc(u[i],n-1-l)%MOD;
		if((r[i]-1-l)&1) s[i]=(s[i]-mul+MOD)%MOD;else s[i]=(s[i]+mul)%MOD;
	} int ans=0;
	for(int i=k;i<n;i++){
		int mul=binom(n-1,i);
		for(int j=1;j<=m;j++) mul=1ll*mul*binom(n-i-1,n-r[j]-i)%MOD*s[j]%MOD;
		if((i-k)&1) ans=(ans-1ll*mul*binom(i,k)%MOD+MOD)%MOD;
		else ans=(ans+1ll*mul*binom(i,k)%MOD)%MOD;
	} printf("%d\n",ans);
	return 0;
}
```



---

## 作者：Super_Cube (赞：1)

# Solution

设 $dp_{i,j}$ 表示前 $i$ 个必修课有 $j$ 个同学被碾压的方案数。

$$dp_{i,j}=\sum_{c=j}^{n-1}dp_{i-1,c}\binom{c}{c-j}\binom{n-1-c}{r_i-1-c+j}\sum_{d=1}^{u_i}d^{n-r_i}(u_i-d)^{r_i-1}$$

被碾压的人数是单调不增的。枚举上一次被碾压的人的个数 $c$，那么要选 $c-j$ 个人不再被碾压，为了符合排名，要在没被碾压的 $n-1-c$ 个人中选 $r_i-1-(c-j)$ 个人。所有人的分数还有上界 $u_i$，枚举 $d$ 为 B 神的分数，那么有 $n-r_i$ 个人的分数小于等于他，$r_i-1$ 个人的分数大于他。初始化 $dp_{0,n-1}=1$，最后答案为 $dp_{m,k}$。

现在问题在于快速计算 $f(u_i)=\displaystyle\sum_{d=1}^{u_i}d^{n-r_i}(u_i-d)^{r_i-1}$。~~可以看出~~ $f(u_i)$ 是关于 $u_i$ 的 $n$ 次多项式，所以用拉格朗日插值就能快速计算啦。

---

## 作者：Purslane (赞：1)

# Solution

清新可爱的简单小题目。

我们将问题划分为两个阶段：

1. 给定了 $R_i$，计算有多少种情况（只区分是否比 B 神强）恰好有 $k$ 个人被偏序。

这个可以使用基础的二项式反演。设 $g_k$ 为钦定 $k$ 个人被偏序，$f_k$ 为实际有 $k$ 个人被偏序。则有

$$
g_k = \sum_{i\ge k} f_i \dbinom{i}{k}
$$

则

$$
f_k = \sum_{i \ge k} g_i (-1)^{i-k} \dbinom{i}{k}
$$

2. 对于每门课，计算得分的可能性。这时候假定谁比 B 考得高已经确定了。

那么设 $dp_{i,j,t}$ 为目前有 $i$ 种得分和 $j$ 个确定的人的方案数。转移的时候，假设下一种的分有 $x$ 个人，要乘上 $\dfrac{1}{x!}$。最后确定一下 B 神是否和比他弱的最强的人水平相同即可。

复杂度 $O(n^3)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=100+10,MOD=1e9+7;
int n,m,k,u[MAXN],r[MAXN],frac[MAXN],inv[MAXN];
int qpow(int base,int p) {
	int ans=1;
	while(p) {
		if(p&1) ans=ans*base%MOD;
		base=base*base%MOD,p>>=1;
	}
	return ans;
}
int C(int u,int d) {if(u>d||u<0) return 0;return frac[d]*inv[u]%MOD*inv[d-u]%MOD;}
int g[MAXN],dp[MAXN][MAXN],c[MAXN];
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m>>k;
	frac[0]=inv[0]=1;
	ffor(i,1,100) frac[i]=frac[i-1]*i%MOD,inv[i]=qpow(frac[i],MOD-2);
	ffor(i,1,m) cin>>u[i];
	ffor(i,1,m) cin>>r[i];
	ffor(i,0,n-1) {
		g[i]=C(i,n-1);
		ffor(j,1,m) g[i]=g[i]*C(r[j]-1,n-1-i)%MOD;
	}
	int ans1=0,ans2=1;
	ffor(i,k,n-1) ans1=(ans1+C(k,i)*(((i-k)%2)?-1:1)*g[i])%MOD;
	dp[0][0]=1;
	ffor(i,0,n-1) ffor(j,0,n-1) ffor(t,1,n-1-j) dp[i+1][j+t]=(dp[i+1][j+t]+dp[i][j]*inv[t])%MOD;
	ffor(i,1,m) {
		int ans=0;
		c[0]=1;
		ffor(j,1,n) c[j]=c[j-1]*(u[i]-j+1)%MOD*qpow(j,MOD-2)%MOD;
		ffor(a,0,n-1) ffor(b,0,n-1) if(a+b<=n-1) {
			int mul=dp[a][r[i]-1]*dp[b][n-r[i]]%MOD;
			ans=(ans+mul*c[a+b])%MOD;
			if(n-r[i]) ans=(ans+mul*c[a+b+1])%MOD;
		}
		ans=ans*frac[r[i]-1]%MOD*frac[n-r[i]]%MOD;
		ans2=ans2*ans%MOD;
	}
	cout<<(ans1*ans2%MOD+MOD)%MOD;
	return 0;
}
```

---

## 作者：int_R (赞：1)

[更好的阅读体验](https://www.cnblogs.com/int-R/p/18206340/P3270)

记 $a_i=N-R_i,n=N-1$。

先不考虑有多少人被碾压，计算出符合排名限制的方案数。枚举每门课和 B 神在每门课中的得分，选出 $a_i$ 个人得分小于等于他，即：

$$\prod\limits_{i=1}^m \dbinom{n}{a_i} \sum\limits_{j=1}^{U_i} j^{a_i}(U_i-j)^{n-a_i}$$

设 $s(x)=\sum\limits_{j=1}^{x} j^{a_i}(U_i-j)^{n-a_i}$，是关于 $x$ 的 $n$ 次多项式，直接拉格朗日插值求出 $s(U_i)$ 即可。

接下来计算出恰好有 $k$ 个人被碾压的概率。设 $f_{i,j}$ 表示仅考虑前 $i$ 门课，恰好有 $j$ 个人被碾压的概率。初始状态 $f_{0,n}=1$，根据组合意义可得转移方程为：

$$f_{i,j}=\sum\limits_{p=j}^{n+j-a_i} f_{i-1,p}\times\dfrac{\tbinom{p}{j}\tbinom{n-p}{a_i-j}}{\tbinom{n}{a_i}}$$

最终答案即为 $f_{n,k}\times \prod\limits_{i=1}^{m} s(U_i)$，时间复杂度 $O(n^2m)$。

```cpp
#include<stdio.h>
#include<iostream>
#include<algorithm>
#define ll long long
using namespace std;
const int N=110,mod=1e9+7;
int n,m,k,U[N],a[N],s[N];
ll ans=1,P[N],I[N],f[N],g[N],dp[N][N];
inline ll ksm(ll a,int b=mod-2)
{
    ll ans=1;
    for(;b;b>>=1,a=a*a%mod)
        if(b&1) ans=ans*a%mod;
    return ans;
}
inline ll C(int n,int m)
    {return P[n]*I[m]%mod*I[n-m]%mod;}
inline ll work(int m,int k)
{
    for(int i=1;i<=min(m,n+1);++i)
        s[i]=(ksm(i,k)*ksm(m-i,n-k)+s[i-1])%mod;
    if(m<=n+1) return s[m];
    f[0]=m,g[n+2]=1;ll ans=0;
    for(int i=1;i<=n+1;++i) f[i]=(m-i)*f[i-1]%mod;
    for(int i=n+1;~i;--i) g[i]=(m-i)*g[i+1]%mod; 
    for(int i=1;i<=n+1;++i)
        ans+=I[i]*I[n+1-i]%mod*f[i-1]%mod*g[i+1]%mod*s[i]%mod*(((n+1-i)&1)?-1:1);
    return (ans%mod+mod)%mod;
}
signed main()
{
    cin>>n>>m>>k;
    P[0]=1;for(int i=1;i<=n;++i) P[i]=P[i-1]*i%mod;
    I[n]=ksm(P[n]);for(int i=n;i;--i) I[i-1]=I[i]*i%mod;
    --n,dp[0][n]=1;for(int i=1;i<=m;++i) cin>>U[i];
    for(int i=1;i<=m;++i) cin>>a[i],a[i]=n-(a[i]-1);
    for(int i=1;i<=m;++i)
        ans=ans*C(n,a[i])%mod*work(U[i],a[i])%mod;
    for(int i=1;i<=m;++i) for(int j=k;j<=a[i];++j)
    {
        for(int p=j;p<=n+j-a[i];++p)
            dp[i][j]+=C(p,j)*C(n-p,a[i]-j)%mod*dp[i-1][p]%mod;
        dp[i][j]=dp[i][j]%mod*ksm(C(n,a[i]))%mod;
    }
    cout<<ans*dp[m][k]%mod<<'\n';
}
```

---

## 作者：User_Unauthorized (赞：1)

首先，我们将方案数分为两部分：

- 选出 $k$ 名被碾压的同学并分配每位同学每个学科的分数与 B 神的关系。
- 对每个学科的分数进行排列。

> 对第一部分做出一点解释：将计算碾压同学的方案数和分配分数与 B 神的关系放到一起是因为一位同学各学科的分数与 B 神的关系决定了其是否被碾压，因此需要将其放到一起考虑。

下面考虑如何计数，首先是第一部分。若**不考虑除我们钦定外的同学是否被碾压**，那么我们钦定已经有 $w$ 名同学被碾压，而其余 $n - w - 1$ 名同学是否被碾压是不确定的，因此我们有：

$$f_{w} = \prod\limits_{i}\dbinom{n - w - 1}{R_i - 1}$$

发现这样计数在这 $n - w - 1$ 名同学中可能存在同学被碾压，因此 $f_w$ 实质上表达的是钦定有 $w$ 名同学被碾压的方案数，设 $g_w$ 表示恰好有 $w$ 名同学被碾压的方案数，那么我们有：

$$f_w = \sum\limits_{i = 1}^{w} \dbinom{w}{i} g_i$$

根据二项式反演，我们有：

$$g_w = \sum\limits_{i = 1}^{w} \dbinom{w}{i} \left(-1\right)^{w - i} f_i$$

因此我们可以在 $\mathcal{O}(nm)$ 的时间内求出 $g_k$，完成第一部分的计数。

下面考虑第二部分，如何统计每个学科的分数排列方案数。首先由于各学科是独立的，因此我们只需要考虑如何求解单独一门学科的方案数即可。设 $U$ 表示该门学科的最高分，$r$ 表示 B 神在这门学科中的排名

由于分数的值域较大，不能直接计算，因此我们考虑枚举有多少种分数，设有 $t$ 种分数，那么一种直观的想法是枚举 B 神的分数 $i$，进而可以确定两个分数段及其对应的人数，有 $x$ 人的分数一个长度为 $l$ 的区间内的方案数为 $l^x$，因此上述计数方法对应的计算式为：

$$f_t = \sum\limits_{i} i^{n - r}\times\left(n - i\right)^{r - 1}$$

但是我们可以发现上述计数方法存在一个问题，即可能会计算到实际分数种类不足 $t$ 的情况，因此我们不妨设 $f_t$ 表示给定 $t$ 种分数的情况下赋分方案数，$g_t$ 表示恰好使用 $t$ 种分数的赋分方案数，那么我们有：

$$f_t = \sum\limits_{i = 1}^{t} \dbinom{t}{i} g_i$$

根据二项式反演，我们有：

$$g_t = \sum\limits_{i = 1}^{t} \dbinom{t}{i} \left(-1\right)^{t - i} f_i$$

因此我们可以在 $\mathcal{O}(n^2)$ 的时间内求出 $g_t$，完成第二部分的计数。

总复杂度为 $\mathcal{O}(n^2m)$。

---

## 作者：Leasier (赞：1)

前置芝士：[二项式反演](https://blog.csdn.net/sizeof_you/article/details/86365003)、[拉格朗日插值](https://oi-wiki.org/math/poly/lagrange/)

考虑将原问题分为求排名方案数和成绩方案数两个子问题并将其积作为答案。

1. 排名方案数

直接算恰好有 $k$ 个人被碾压的方案数较为困难，考虑计算钦定 $k$ 个人被碾压的方案数。

设 $f(k)$ 表示恰好有 $k$ 个人被碾压的方案数，$g(k)$ 表示钦定 $k$ 个人被碾压的方案数，显然可以二项式反演得：$f(k) = \displaystyle\sum_{i = k}^{n - 1} (-1)^{i - k} C_i^k g(i)$。

现在问题转变为快速求出 $g(k)$。首先在 $n - 1$ 个人中选择 $k$ 个人作为这被碾压的 $k$ 个人，然后对于每个学科 $i$，我们需要从没被碾压的 $n - k - 1$ 个人中选出 $r_i - 1$ 个人作为排名比他高的人，于是 $g(k) = C_{n - 1}^k \displaystyle\prod_{i = 1}^m C_{n - k - 1}^{r_i - 1}$。

预处理组合数后直接计算即可。时间复杂度为 $O(n^2 + nm)$。

2. 成绩方案数

容易发现学科之间互相独立。对于 B 神的第 $i$ 科成绩为 $j$ 的情况，由于有 $r_i - 1$ 个人的成绩高于他，有 $n - r_i$ 个人的成绩低于他，我们可以得到整体表达式为 $\displaystyle\prod_{i = 1}^m \sum_{j = 1}^{u_i} j^{n - r_i} (u_i - j)^{r_i - 1}$。容易发现对于固定的 $i, j$，$j^{n - r_i} (u_i - j)^{r_i - 1}$ 是一个关于 $j$ 的 $n - 1$ 次函数，则 $\displaystyle\sum_{j = 1}^{u_i} j^{n - r_i} (u_i - j)^{r_i - 1}$ 是一个关于 $u_i$ 的 $n$ 次函数。

对这 $m$ 个 $n$ 次函数分别拉格朗日插值即可。时间复杂度为 $O(n^2)$。

综上，总体时间复杂度为 $O(nm + n^2)$。

代码：
```cpp
#include <stdio.h>

typedef long long ll;

const int mod = 1e9 + 7;
int c[107][107], u[107], r[107];
ll fac[107], inv_fac[107], b[107], y[107], pre[107], suf[107], val[107];

inline void init1(int n){
	c[0][0] = 1;
	for (register int i = 1; i <= n; i++){
		c[i][0] = 1;
		for (register int j = 1; j <= i; j++){
			c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
		}
	}
}

inline ll quick_pow(ll x, ll p, ll mod){
	ll ans = 1;
	while (p){
		if (p & 1) ans = ans * x % mod;
		x = x * x % mod;
		p >>= 1;
	}
	return ans;
}

inline void init2(int n){
	fac[0] = 1;
	for (register int i = 1; i <= n; i++){
		fac[i] = fac[i - 1] * i % mod;
	}
	inv_fac[n] = quick_pow(fac[n], mod - 2, mod);
	for (register int i = n - 1; i >= 0; i--){
		inv_fac[i] = inv_fac[i + 1] * (i + 1) % mod;
	}
	for (register int i = 0; i <= n; i++){
		b[i] = inv_fac[i] * inv_fac[n - i] % mod;
		if ((n - i) % 2 != 0) b[i] = (mod - b[i]) % mod;
	}
}

inline ll lagrange(int n, ll y[], int k){
	ll ans = 0;
	for (register int i = 0; i <= n; i++){
		pre[i] = suf[i] = ((k - i) % mod + mod) % mod;
		if (i > 0) pre[i] = pre[i] * pre[i - 1] % mod;
	}
	for (register int i = n - 1; i >= 0; i--){
		suf[i] = suf[i] * suf[i + 1] % mod;
	}
	for (register int i = 0; i <= n; i++){
		ll a = 1;
		if (i > 0) a = pre[i - 1];
		if (i < n) a = a * suf[i + 1] % mod;
		ans = (ans + y[i] * a % mod * b[i] % mod) % mod;
	}
	return ans;
}

int main(){
	int n, m, k, nd;
	ll sum = 0, mul = 1;
	scanf("%d %d %d", &n, &m, &k);
	nd = n - 1;
	init1(nd);
	init2(n);
	for (register int i = 1; i <= m; i++){
		scanf("%d", &u[i]);
	}
	for (register int i = 1; i <= m; i++){
		scanf("%d", &r[i]);
	}
	for (register int i = k; i < n; i++){
		ll cur_mul = (ll)c[i][k] * c[n - 1][i] % mod;
		for (register int j = 1; j <= m; j++){
			cur_mul = cur_mul * c[n - i - 1][r[j] - 1] % mod;
		}
		if ((i - k) % 2 == 0){
			sum = (sum + cur_mul) % mod;
		} else {
			sum = ((sum - cur_mul) % mod + mod) % mod;
		}
	}
	for (register int i = 1; i <= m; i++){
		for (register int j = 1; j <= n; j++){
			y[j] = (y[j - 1] + quick_pow(j, n - r[i], mod) * quick_pow(u[i] - j, r[i] - 1, mod) % mod) % mod;
		}
		mul = mul * lagrange(n, y, u[i]) % mod;
	}
	printf("%lld", sum * mul % mod);
	return 0;
}
```

---

## 作者：UltiMadow (赞：1)

神仙组合数学题（

要求恰好 $k$ 个人被碾压，转化为至少 $k$ 个人被碾压，然后用容斥处理

设 $f_i$ 为至少 $i$ 个人被碾压的方案数

首先，我们先钦定 $i$ 个人被碾压，方案数为 $\binom{n-1}i$

接下来对于每一门学科处理，对于学科 $j$ 由于已经有 $i$ 个人被全面碾压了，于是只要再钦定 $n-R_j-i$ 个人被单科碾压，方案数 $\binom{n-i-1}{n-R_j-i}$

对于学科 $j$ 还有 $U_j$ 种分数，我们钦定他的分数为 $k$，则有 $n-R_j$ 个人的分数区间为 $[1,k]$，剩下 $R_j-1$ 个人的分数区间为 $(k,U_j]$，于是方案数为 $k^{n-R_j}(U_j-k)^{R_j-1}$

可得 $f_i=\binom{n-1}i\prod\limits_{j=1}^m \binom{n-i-1}{n-R_j-i}\sum\limits\limits_{k=1}^{U_j}k^{n-R_j}(U_j-k)^{R_j-1}$

加上容斥，答案即为 $\sum\limits_{i=K}^n (-1)^{i-K}\binom i K f_i=\sum\limits_{i=K}^n (-1)^{i-K}\binom i K \binom{n-1}i\prod\limits_{j=1}^m \binom{n-i-1}{n-R_j-i}\sum\limits\limits_{k=1}^{U_j}k^{n-R_j}(U_j-k)^{R_j-1}$

然后一看数据范围 $U_j\le 10^9$，直接 T 飞，继续推式子：

$$
\begin{aligned}
\sum\limits\limits_{k=1}^{U_j}k^{n-R_j}(U_j-k)^{R_j-1}&=\sum_{k=1}^{U_j}k^{n-R_j}\sum_{w=0}^{R_j-1}(-1)^w\binom{R_j-1}wU_j^{R_j-w-1}k^w\cr
&=\sum_{k=1}^{U_j}\sum_{w=0}^{R_j-1}(-1)^w\binom{R_j-1}wU_j^{R_j-w-1}k^{n+w-R_j}\cr
&=\sum_{w=0}^{R_j-1}(-1)^w\binom{R_j-1}wU_j^{R_j-w-1}\sum_{k=1}^{U_j}k^{n+w-R_j}
\end{aligned}
$$

于是答案就变成了

$$
\sum_{i=K}^n (-1)^{i-K}\binom i K\binom{n-1}i \prod_{j=1}^m\binom{n-i-1}{n-R_j-i}\sum_{w=0}^{R_j-1}(-1)^w\binom{R_j-1}w U_j^{Rj-w-1}\sum_{k=1}^{U_j}k^{n+w-R_j}
$$

然后发现后面 $k$ 的计算就是一个 $n+w-R_j$ 次方的前缀和，用拉格朗日插值即可做到 $\mathcal O(n^2)$/$\mathcal O(n)$ 解决

我这里偷懒写了 $\mathcal O(n^2)$ 的插值，那么直接暴力计算是 $\mathcal O(n^4m)$ 的，又 T 飞了

所以考虑对于每一个 $j$ 预处理 $\sum_{w=0}^{R_j-1}(-1)^w\binom{R_j-1}w U_j^{Rj-w-1}\sum_{k=1}^{U_j}k^{n+w-R_j}$

于是时间复杂度变为 $\mathcal O(n^3m)$，可以通过

最后注意不要在插值的时候暴力计算逆元，不然还是会 T 飞（

code:
```cpp
#include<bits/stdc++.h>
#define MAXN 210
#define int long long
#define p 1000000007
using namespace std;
int n,m,K;
int u[MAXN],r[MAXN],pw[MAXN];
int c[MAXN][MAXN],inv[MAXN];
int qpow(int x,int y){
	int ret=1;
	for(;y;y>>=1,x=x*x%p)if(y&1)ret=ret*x%p;
	return ret;
}
int X[MAXN],Y[MAXN];
int calc(int x,int y){//1^y+2^y+...+x^y
	for(int i=1;i<=y+2;i++)
		X[i]=i,Y[i]=(Y[i-1]+qpow(i,y))%p;
	if(x<=y+2)return Y[x];
	int ret=0;
	for(int i=1;i<=y+2;i++){
		int sum=1;
		for(int j=1;j<=y+2;j++)
			if(i!=j)sum=sum*(x-X[j])%p*inv[X[i]-X[j]+n]%p;
		ret=(ret+sum*Y[i]%p)%p;
	}return ret;
}
signed main(){
	scanf("%lld%lld%lld",&n,&m,&K);
	for(int i=1;i<=m;i++)scanf("%lld",&u[i]);
	for(int i=1;i<=m;i++)scanf("%lld",&r[i]);
	c[0][0]=1;
	for(int i=1;i<=n;i++){
		c[i][0]=1;
		for(int j=1;j<=n;j++)
			c[i][j]=(c[i-1][j-1]+c[i-1][j])%p;
	}
	for(int i=-n;i<=n;i++)inv[i+n]=qpow(i,p-2);
	for(int j=1;j<=m;j++)
		for(int w=0;w<r[j];w++)
			pw[j]=(pw[j]+qpow(-1,w)*c[r[j]-1][w]%p*qpow(u[j],r[j]-w-1)%p*calc(u[j],n+w-r[j])%p)%p;
	int ans=0;
	for(int i=K;i<=n;i++){
		int now=qpow(-1,i-K)*c[i][K]*c[n-1][i]%p;
		for(int j=1;j<=m;j++){
			if(n-r[j]-i<0){now=0;break;}
			now=now*c[n-i-1][n-r[j]-i]%p*pw[j]%p;
		}
		ans=(ans+now)%p;
	}printf("%lld\n",(ans%p+p)%p);
	return 0;
}
```

---

## 作者：Otomachi_Una_ (赞：1)

## 题目简述

> - 有 $n+1$ 个人，进行 $m$ 场考试，第 $i$ 场考试的可能得分是 $[0,U_i]$ 之间的整数。
> - 假设你是其中一人，你知道每场考试的排名 $r_i$（相同分数算后排名），并且恰有 $k$ 个人每一场考试的分数都不大于你。
> - 求方案数，对 $10^9+7$ 取模。
> - $n,m\leq 100$，$U_i\leq10^9$。

## 解题思路

很显然的计数分为三个部分：

- 确定被你碾压的 $k$ 人。
- 确定每个人和你分数的大小关系。
- 确定每个人的分数。

对于第 $1$ 部分，显然是 $C_n^k$。

对于第 $2$ 部分，我们可以通过排名确定出每场比赛 $i$ 有多少人分数 $\leq $ 你，多少人分数 $>$ 你。那么由于已经确定出 $k$ 个被碾压的人了，所以这 $k$ 个人的分数 $\leq $ 你，我们的问题转换成在剩下的人当中去分配 $R_i$ 使得每个人至少有一个 $>$ 你的分数。很显然的可以使用容斥。

由于 $k$ 个被碾压者已经确定，记剩下的人 $N=n-k$，假设有：
$$
f_i=\prod_{j=1}^m C^{r_j-1}_{i}
$$
表示有至多 $i$ 个人被你碾压，很显然的容斥为：
$$
ans=\sum_{i=0}^N (-1)^{N-i}\times f_i\times C_{N}^i
$$
对于第三部分，每一场考试是独立的，我们可以写出式子：
$$
\sum_{k=0}^{U_i} k^{n-r_i+1}\times (U_i-k)^{r_i-1}
$$
我们不难发现原式改写成 $\sum_{k=0}^{x} k^{n-r_i+1}\times (U_i-k)^{r_i-1}$ 是关于 $x$ 的 $n+1$ 次多项式，所以我们对于 $\leq n+2$ 的值暴力枚举，然后使用插值求出 $x=U_i$ 的值即可。

暴力拉格朗日的复杂度 $O(n^2\log V)$，可以通过。我们也可以优化到 $O(n\log n)$ 的拉格朗日。

## 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MP make_pair
const int MAXN=105;
const int MOD=1e9+7;
int n,m,k;
int x[MAXN],r[MAXN];
ll fac[MAXN],inf[MAXN];
ll ksm(ll a,int b){ll res=1;while(b){if(b&1)res=res*a%MOD;a=a*a%MOD,b>>=1;}return res;}
ll inv(ll a){return ksm(a,MOD-2);}
void init(){
	fac[0]=inf[0]=1;
	for(int i=1;i<MAXN;i++)
		fac[i]=fac[i-1]*i%MOD,
		inf[i]=inv(fac[i]);
	return;
}
ll C(int n,int m){if(n>m) return 0;return fac[m]*inf[n]%MOD*inf[m-n]%MOD;}
ll sgn(int x){return (x&1)?-1:1;}
ll Part_2(){
	ll f[MAXN];
	for(int i=0;i<=n;i++){
		f[i]=1;
		for(int j=1;j<=m;j++)
			f[i]=f[i]*C(r[j]-1,i)%MOD;
	}
	ll res=0;
	int d=n-k;
	for(int i=0;i<=d;i++)
		res=(res+sgn(d-i)*f[i]%MOD*C(i,d)%MOD+MOD)%MOD;
	return res;
}
ll Func(ll x,int a,int b){
	ll y[MAXN],res=0;
	for(int i=1;i<=n+2;i++){
		res+=ksm(i,a)*ksm(x-i+MOD,b)%MOD;
		res%=MOD;
		y[i]=res;
	}
	ll ans=0;
	for(int i=1;i<=n+2;i++){
		res=y[i];
		for(int j=1;j<=n+2;j++)
			if(i!=j)
				res=res*(x-j+MOD)%MOD*inv(i-j+MOD)%MOD;
		ans+=res;ans%=MOD;
	}
	return ans;
}
int main(){
	ios::sync_with_stdio(false);
	init();
	cin>>n>>m>>k;n--;
	for(int i=1;i<=m;i++)
		cin>>x[i];
	for(int i=1;i<=m;i++)
		cin>>r[i];
	ll ans=C(k,n)*Part_2()%MOD;
	for(int i=1;i<=m;i++)
		ans=ans*Func(x[i],n-r[i]+1,r[i]-1)%MOD;
	cout<<ans;
	return 0;
}
```



---

## 作者：david0911 (赞：0)

看到恰好 $k$ 人被碾压，直接上二项式反演，转化到钦定 $k$ 人被碾压。

设 $f_i$ 表示钦定 $i$ 个人被碾压的方案数，$g_i$ 表示恰好 $i$ 个人被碾压的方案数。写一下式子，$f_k=\dbinom{n-1}{k}\prod\limits_{0\le i<m}\dbinom{n-k-1}{n-R_i-k}$。那么 $g_k=\sum\limits_{i=k}^n (-1)^{i-k} \dbinom{i}{k} \dbinom{n-1}{i}\prod\limits_{0\le j<m}\dbinom{n-i-1}{n-R_j-i}$。

现在还要算给每个人分配分数的方案数。可以枚举中间那个人的分数 $x$，然后方案数就是 $\prod\limits_{0\le j<m}\sum\limits_{1\le x\le U_j} x^{n-R_j}(U_i-x)^{R_j-1}$。把这个东西乘到 $g_k$ 的后面就得到了答案：

$$\sum\limits_{i=k}^n (-1)^{i-k} \dbinom{i}{k} \dbinom{n-1}{i}\prod\limits_{0\le j<m}\dbinom{n-i-1}{n-R_j-i}\sum\limits_{1\le x\le U_j} x^{n-R_j}(U_i-x)^{R_j-1}$$

但是这样你发现时间复杂度好像有点问题，$O(n^2V\log n)$ 过不了。继续化简式子，用二项式定理拆最后那一个求和号后面的式子：

$$
\begin{aligned}
\sum\limits_{1\le x\le U_j} x^{n-R_j}(U_i-x)^{R_j-1}&=\sum\limits_{1\le x\le U_j} x^{n-R_j}\sum\limits_{0\le t\le R_j-1}\dbinom{R_j-1}{t}(-1)^tx^tU_j^{R_j-1-t}\\
&=\sum\limits_{0\le t\le R_j-1}(-1)^tU_j^{R_j-1-t}\dbinom{R_j-1}{t}\sum\limits_{1\le x\le U_j} x^{n-R_j+t}
\end{aligned}
$$

最后的一坨是连续自然数幂和，可以拉插 $O(n)$ 算一次。

视 $n,m$ 同阶，分析一下复杂度。那一坨连续自然数幂和只有 $O(n^2)$ 种不同的值，可以 $O(n^3)$ 预处理。然后整个式子 $O(n^3)$ 算即可。

所以是 $O(n^3)$ 的。


```cpp
#include<bits/stdc++.h>

using namespace std;

using i64=long long;

constexpr int maxn=110,mo=1000000007;

int n,m,k,Lim,U[maxn],R[maxn],fac[maxn],ifac[maxn],pr[maxn],sf[maxn],Y[maxn],S[maxn][maxn],mi[maxn][maxn];

int ksm(int a,int b){
	int rs=1;for(;b;b>>=1,a=(i64)a*a%mo) if(b&1) rs=(i64)rs*a%mo;return rs;
}

inline int add(int x,int y){
	return x+y<mo?x+y:x-mo+y;
}

int Lag(int x,int c){
	if(x<=c) return Y[x];
	pr[0]=1;for(int i=1;i<=c;++i) pr[i]=(i64)pr[i-1]*(x-i)%mo;
	sf[c+1]=1;for(int i=c;i;--i) sf[i]=(i64)sf[i+1]*(x-i)%mo;
	int ans=0;
	for(int i=1;i<=c;++i) ans=add(ans,(i64)Y[i]*pr[i-1]%mo*sf[i+1]%mo*ifac[c-i]%mo*((c-i)&1?mo-1:1)%mo*ifac[i-1]%mo);
	return ans;
}

void prework(){
	Lim=maxn;for(int i=1;i<=m;++i) Lim=min(Lim,n-R[i]);
	
	fac[0]=1;for(int i=1;i<=n;++i) fac[i]=(i64)fac[i-1]*i%mo;
	
	ifac[n]=ksm(fac[n],mo-2);for(int i=n;i;--i) ifac[i-1]=(i64)ifac[i]*i%mo;

	for(int i=0;i<=n;++i){
		for(int j=1;j<=i+2;++j) Y[j]=(Y[j-1]+ksm(j,i))%mo;
		for(int j=1;j<=m;++j) S[j][i]=Lag(U[j],i+2);
	}
	for(int i=1;i<=m;++i){
		for(int j=0;j<R[i];++j) mi[i][j]=ksm(U[i],j);
	}
}

inline int C(int x,int y){
	if(y<0||y>x) return 0;
	return (i64)fac[x]*ifac[y]%mo*ifac[x-y]%mo;
}

int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>m>>k;
	for(int i=1;i<=m;++i) cin>>U[i];
	for(int i=1;i<=m;++i) cin>>R[i];
	
	prework();
	
	int ans=0;
	for(int i=k;i<=Lim;++i){
		int prod=1;
		for(int j=1;j<=m;++j){
			int s=0;
			for(int t=0;t<R[j];++t) s=add(s,(i64)C(R[j]-1,t)*mi[j][t]%mo*((R[j]-1-t)&1?mo-1:1)%mo*S[j][n-t-1]%mo);
			prod=(i64)prod*C(n-i-1,R[j]-1)%mo*s%mo;
		}
		ans=add(ans,(i64)((i-k)&1?mo-1:1)*C(i,k)%mo*C(n-1,i)%mo*prod%mo);
	}
	
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：MiniLong (赞：0)

简单容斥题，被搞了一中午，还是太菜了呜呜呜。

首先看到**恰好 $k$ 个**考虑二项式反演，设 $F(x)$ 为**钦定** $x$ 个数被碾压的方案数，则最后答案为 $\sum\limits_{i=k}^{n-1} (-1)^i \binom{i}{k} F(i)$。

考虑求出 $F(x)$，首先要在 $n-1$ 个数中选出这 $x$ 个数，方案是 $\binom{n-1}{x}$。

然后设 $g(i,u_i,r_i)$ 为在第 $i$ 个课程中，每个人最多分数最多为 $u$，且大于 $B$ 这个人的有 $n-r$ 个人。

因为 $u$ 很大，肯定不能直接枚举 $B$ 多少分，考虑到 $n$ 比较小，就直接枚举 $n$ 个人选了 $t$ 个不同的数，其中 $B$ 选了第 $p$ 大的。现在就要求 $r-1$ 个人都是前 $t-p$ 个数，$n-r+1$ 个人放到后 $p$ 个数，**且每个数至少有 $1$ 个人**。

那就转化成了一个经典模型，有 $x$ 个不同的小球，放到 $y$ 个不同盒子里，要求非空，方案数就是第二类斯特林数 ${x\brace y} y!$。

那么 $g(i,u_i,r_i)$ 就可以简单求出了，即 $\sum\limits_{t=1}^n \binom{u}{t} \sum\limits_{p=1}^t {n-r+1 \brace p} {r-1 \brace t - p} (p-1)!(t-p)!$

乘上 $(p-1)!$ 而不是 $p!$ 是因为我要强制钦定 $B$ 选的那个盒子是第 $p$ 大的。并且，**这里的 $g$ 其实是不完整的**，我们考虑了两边各自编号是不同的，还没考虑将除 $B$ 之外的 $n-1$ 个人分配给这两边，也就是少乘了个 $\binom{n-1}{r-1}$，但是**先不去管它**，因为如果这样做了那原本强制钦定的那些答案就不好分配了。

显然所有 $g(i,u_i,r_i)$ 是可以 $\Theta(n^2m)$ 简单预处理的，然后回到 $F(x)$。

现在就好做了，$F(x)=\binom{n-1}{x} \prod\limits_{i=1}^m g(i,u_i,r_i)\binom{n-1-x}{r_i - 1}$。现在就可以把 $g$ 不完整的空缺补上来，$\binom{n-1-x}{r_i - 1}$ 就是强制把 $x$ 放到后面 $p$ 个盒子后再分配编号的方案。

然后就做完了，$ans=\sum\limits_{i=k}^{n-1} (-1)^i \binom{i}{k} F(i)$，这部分复杂度是 $\Theta(nm)$ 的。

注意一些组合数值域比较大，直接循环求就行。

总复杂度 $\Theta(n^2m)$。

我还是太菜了呜呜呜。

```cpp
#include <bits/stdc++.h>
#define _rep(i, x, y) for(int i = x; i <= y; ++i)
#define _req(i, x, y) for(int i = x; i >= y; --i)
#define _rev(i, u) for(int i = head[u]; i; i = e[i].nxt)
#define pb push_back
#define fi first
#define se second
#define mst(f, i) memset(f, i, sizeof f)
using namespace std;
#ifdef ONLINE_JUDGE
#define debug(...) 0
#else
#define debug(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)
#endif
typedef long long ll;
typedef pair<int, int> PII;
namespace fastio{
    char ibuf[50007],*p1 = ibuf, *p2 = ibuf;
    #ifdef ONLINE_JUDGE
    #define get() p1 == p2 && (p2 = (p1 = ibuf) + fread(ibuf, 1, 50007, stdin), p1 == p2) ? EOF : *p1++
    #else
    #define get() getchar()
    #endif
    template<typename T> inline void read(T &t){
        T x = 0, f = 1;
        char c = getchar();
        while(!isdigit(c)){
            if(c == '-') f = -f;
            c = getchar();
        }
        while(isdigit(c)) x = x * 10 + c - '0', c = getchar();
        t = x * f;
    }
    template<typename T, typename ... Args> inline void read(T &t, Args&... args){
        read(t);
        read(args...);
    }
    template<typename T> void write(T t){
        if(t < 0) putchar('-'), t = -t;
        if(t >= 10) write(t / 10);
        putchar(t % 10 + '0');
    }
    template<typename T, typename ... Args> void write(T t, Args... args){
        write(t), putchar(' '), write(args...);
    }
    template<typename T> void writeln(T t){
        write(t);
        puts("");
    }
    template<typename T> void writes(T t){
        write(t), putchar(' ');
    }
    #undef get
};
using namespace fastio;
#define multitest() int T; read(T); _rep(tCase, 1, T)
namespace Calculation{
    const ll mod = 1e9 + 7;
    ll ksm(ll p, ll h){ll base = p % mod, res = 1; while(h){if(h & 1ll) res = res * base % mod; base = base * base % mod, h >>= 1ll;} return res;}
    void dec(ll &x, ll y){x = ((x - y) % mod + mod) % mod;}
    void add(ll &x, ll y){x = (x + y) % mod;}
    void mul(ll &x, ll y){x = x * y % mod;}
    ll sub(ll x, ll y){return ((x - y) % mod + mod) % mod;}
    ll pls(ll x, ll y){return ((x + y) % mod + mod) % mod;}
    ll mult(ll x, ll y){return x * y % mod;}
}
using namespace Calculation;
const int N = 105;
ll n, m, k, a[N], r[N], pw[N], inv[N], f[N][N];
ll C(ll n, ll m){
    if(n < m || m < 0) return 0;
    if(n == m || !m) return 1;
    ll res = 1;
    _rep(i, n - m + 1, n) res = res * i % mod;
    return res * inv[m] % mod;
}
ll g[N];
int main(){
    read(n, m, k), pw[0] = inv[0] = 1;
    _rep(i, 1, n) pw[i] = pw[i - 1] * i % mod, inv[i] = ksm(pw[i], mod - 2);
    _rep(i, 1, m) read(a[i]);
    _rep(i, 1, m) read(r[i]);
    f[0][0] = 1;
    _rep(i, 1, n){
        _rep(j, 1, n){
            f[i][j] = (j * f[i - 1][j] % mod + f[i - 1][j - 1]) % mod;
        }
    }
    _rep(j, 1, m){
        _rep(t, 1, n){
            ll o = C(a[j], t) % mod;
            _rep(p, 1, t){
                ll now = f[n - r[j] + 1][p] % mod * f[r[j] - 1][t - p] % mod;
                now = now * pw[p - 1] % mod * pw[t - p] % mod;
                now = now * o % mod;
                add(g[j], now);
            }
        }
    }
    ll ans = 0;
    _rep(i, k, n - 1){
        ll cur = C(n - 1, i) * C(i, k) % mod, op = (i - k & 1) ? (mod - 1) : 1;
        _rep(j, 1, m) mul(cur, g[j] * C(n - 1 - i, r[j] - 1) % mod);
        add(ans, op * cur % mod);
    }
    writeln(ans);
    return 0;
}
```

---

## 作者：UnyieldingTrilobite (赞：0)

UPD 6.8：修复了一个组合数上下顺序的问题。

首先我们把要求的东西切成三个部分，答案就是它们乘起来。

1. 从 $N-1$ 个人中选 $K$ 个被 B 神无情爆碾。

这部分显然是 $\binom{N-1}{K}$。

2. 确定每门课分数小于等于 B 神的人的集合。

对于这部分，首先每个这样的集合里都有选定爆碾的所有人，不如直接删掉。

那接下来只要要求剩下所有删完后的集合交起来是空集就好了。

显然可以随便动规，$dp_{i,j}$ 表示前 $i$ 个集合，交集大小是 $j$，然后转移只需要枚举下一个集合和这个当前交集的交集大小就可以了。这边推荐 $i$ 推 $i+1$ 的方式转移，特别舒服。

3. 第二步确定完集合后计算人的分数情况。

显然是每门课分别算然乘起来。记当前课程分数上限为 $U$，B 神第 $R$ 名。

考虑暴力，枚举 B 神的分数，设之为 $i$，则所有比他高的 $R-1$ 个人分数情况有 $(U-i)^{R-1}$ 中，小于等于他的人则有 $i^{N-R}$ 种。那么这门课的答案就是：

$$\sum^{U}_{i=1}i^{N-R}(U-i)^{R-1}$$

这个求和上的 $U$ 长得不好看，随便找个字母 $x$ 把它换掉。

$$\sum^{x}_{i=1}i^{N-R}(U-i)^{R-1}$$

然后这个 $i^{N-R}(U-i)^{R-1}$ 显然是一个关于 $i$ 的 $N-1$ 次多项式，拆开每一项对 $i$ 累和。由于我们知道 $\sum^{n}_{j=1}j^k$ 是一个关于 $n$ 的 $k+1$ 次多项式，于是累出来一定是一个关于 $x$ 的 $N$ 次多项式。

由于这个 $U$ 太大了于是我们考虑拉格朗日插值，把 $x=1,2,\ldots,N+1$ 往上面那个求和式里一丢就能得到 $N+1$ 个点，然后就没有然后了。

加一些预处理可以把复杂度控制在三次方，但猜测不控也能过。

很好的题，思维难度适中，为良心出题人点赞！

下面是代码环节。

[代码头](https://www.luogu.com.cn/paste/lqcow18g)。

去头代码：

```cpp
#define int long long
const modder mod=1e9+7;
int n,m,k,u[100],r[100],ans,dp[109][109],C[109][109],S[109],inv[109];
int qpow(int bs,int pw=1e9+5){
	int ret=1;
	for(;pw;pw>>=1,(bs*=bs)%=mod)
		if(pw&1)(ret*=bs)%=mod;
	return ret;
}
void main_init(){
	cin>>n>>m>>k;
	for(int i:range(m))cin>>u[i];
	for(int i:range(m))cin>>r[i];
	for(int i:range(109)){
		C[i][0]=1;
		for(int j:range(1,109))
			C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;
	}
	for(int i:range(m))S[i]=n-r[i]-k;
	for(int i:range(1ll,n+1))inv[i]=qpow(i);
	dp[1][S[0]]=C[n-k-1][S[0]];
}
int sinv(int x){return x>0?inv[x]:-inv[-x];}
int calc(int U,int R){
	int*f=new int[109],ret=f[0]=0;
	for(int i:range(1ll,n+2)){
		int tmp=f[i]=(f[i-1]+qpow(i,n-R)*qpow(U-i,R-1))%mod;
		for(int j:range(1ll,n+2))if(j!=i)
			(tmp*=(U-j)*sinv(i-j)%mod)%=mod;
		(ret+=tmp)%=mod;
	}
	return delete[]f,ret;
}
signed main(){
	main_init();
	for(int i:range(1ll,m))
		for(int j:range(n-k))
			for(int w:range(min(j+1,S[i]+1)))
				(dp[i+1][w]+=dp[i][j]*C[j][w]%mod*C[n-k-1-j][S[i]-w]%mod)%=mod;
	ans=C[n-1][k]*dp[m][0]%mod;
	for(int i:range(m))(ans*=calc(u[i],r[i]))%=mod;
	cout<<ans<<endl;
	return 0;
}
```

可以看到全代码也不算长，建议自己手打一遍。

Over.

---

## 作者：木xx木大 (赞：0)

[P3270 [JLOI2016]成绩比较](https://www.luogu.com.cn/problem/P3270)

由容斥原理得：
$$
ans=\sum_{i=K}^{\min\{N-R\}}(-1)^{i-K}C_i^KC_{N-1}^i\prod_{j=1}^MC_{N-1-i}^{N-R_j-i}\sum_{x=1}^{U_j}x^{N-R_j}(U_j-x)^{R_j-1}
$$

这个很长的式子表示：分别求至少有 $i$ 个人被碾压的方案数，然后容斥一下；从 $n-1$ 个人里选 $i$ 个被碾压；对每门课考虑有多少人这门课这门课被碾压；枚举 B 神的成绩，算这门课被碾压的人的成绩的情况数及碾压 B 神的人的成绩的情况数。

由于 $U_i$ 太大，$(U_j-x)^{R_j-1}$ 不好处理。可以暴力展开
$$
\begin{aligned}\sum_{x=1}^{U_j}x^{N-R_j}(U_j-x)^{R_j-1}=&\sum_{x=1}^{U_j}x^{N-R_j}\sum_{k=0}^{R_j-1}{R_j-1\choose k}(-1)^kx^kU_j^{R_j-1-k}\\=&\sum_{k=0}^{R_j-1}{R_j-1\choose k}(-1)^kU_j^{R_j-1-k}\sum_{x=1}^{U_j}x^{N-R_j+k}\end{aligned}
$$

$\sum_{x=1}^{U_i}x^{N-R_j+k}$ 用拉格朗日插值或者用伯努利数预处理一下即可，我写的是伯努利数。

复杂度 $O(n^2m)$

不是很长的代码不知道为啥写了一个小时。抄不对式子啊（捂脸）

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
namespace FGF
{
	int n,m,K;
	const int N=110,mo=1e9+7;
	int U[N],R[N],B[N],C[N][N],S[N][N],inv[N],mn=10000,ans;
	void work()
	{
		scanf("%d%d%d",&n,&m,&K);
		for(int i=1;i<=m;i++)
			scanf("%d",&U[i]);
		for(int i=1;i<=m;i++)
			scanf("%d",&R[i]),mn=min(mn,n-R[i]);
		for(int i=0;i<=n;i++)
		{
			C[i][0]=1;
			for(int j=1;j<=i;j++)
				C[i][j]=(C[i-1][j]+C[i-1][j-1])%mo;
		}
		inv[0]=inv[1]=B[0]=1;
		for(int i=2;i<=max(n,m)+5;i++)
			inv[i]=1ll*inv[mo%i]*(mo-mo/i)%mo;
		for(int i=1;i<=n;i++)
			for(int j=0;j<i;j++)
				B[i]=(B[i]-1ll*B[j]*inv[i-j+1]%mo*C[i][j]%mo+mo)%mo;
		for(int i=1;i<=m;i++)
			for(int j=1;j<=n;j++)
			{
				int sum=0;
				for(int k=j,s=U[i]+1;k>=0;k--,s=1ll*s*(U[i]+1)%mo)
					sum=(sum+1ll*C[j+1][k]*B[k]%mo*s%mo)%mo;
				S[i][j]=1ll*inv[j+1]*sum%mo;
			}
		for(int i=K;i<=mn;i++)
		{
			int tmp=1ll*((i-K)&1?mo-1:1)*C[i][K]%mo*C[n-1][i]%mo,s=1;
			for(int j=1;j<=m;j++)
			{
				int sum=0;
				for(int k=R[j]-1,tmp=1;k>=0;k--,tmp=1ll*tmp*U[j]%mo)
					sum=(sum+1ll*((k&1)?mo-1:1)*tmp%mo*S[j][n-R[j]+k]%mo*C[R[j]-1][k]%mo)%mo;
				s=1ll*s*C[n-1-i][n-R[j]-i]%mo*sum%mo;
			}
			ans=(ans+1ll*tmp*s%mo)%mo;	
		}
		printf("%d\n",ans);
	}
}
int main()
{
	FGF::work();
	return 0;
}
```

---

